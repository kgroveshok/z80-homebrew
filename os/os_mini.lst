# File os_mini.asm
0000			; 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ 0 
0000			CPU_CLOCK_10MHZ: equ 0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			tos:	equ 0fffdh 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
0000			 
0000			 
0000			; Full OS but with the small 4x4 keypad 
0000			 
0000			display_rows: equ 4     ; move out to mini and mega files 
0000			display_cols: equ 20 
0000			 
0000			key_rows: equ 4     ; TODO move out to mini and mega 
0000			key_cols: equ 4    ; TODO move out to mini and mega 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 69 1b			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			 
0003 .. 00		buildtime: db   "Build: 00/00/00 00:00:00",0 
001c			 
001c			 
001c			;        nop  
001c			;        nop 
001c			;;	org 05h		; null out bdos call 
001c			; 
001c			;        nop  
001c			;        nop  
001c			;        nop 
001c			;;	org 08h 
001c			;;; 
001c			;;	jp cin		; rst 8 - char in 
001c			;;; 
001c			; 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;	org 010h 
001c			;; 
001c			;	jp cout		; rest 010h  - char out 
001c			;; 
001c			;	org 01bh   
001c			; 
001c			;	;jp  		; rst 01bh   - write string to display 
001c			;	jp str_at_display 
001c			; 
001c			; 
001c			;	org 020h 
001c			; 
001c			;	; jp		 ; rst 020h - read char at screen location 
001c			; 
001c			;	org 028h 
001c			 
001c				; jp		 ; rst 028h  - storage i/o 
001c			 
001c			; 	org 030h 
001c			;	jp break_point_state 
001c			  
001c			; $30  
001c			; org 038h 
001c			; $38 
001c			 
001c			; TODO any more important entry points to add to jump table for easier coding use? 
001c			 
001c			 
001c			include "firmware.asm" 
001c			  
001c			; main constants (used here and in firmware)  
001c			  
001c			; TODO have page 0 of storage as bios  
001c			  
001c			Device_A: equ 0h  
001c			Device_B: equ 040h          ; Sound  
001c			  
001c			if BASE_KEV  
001c			Device_C: equ 080h          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			if BASE_SC114  
001c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			if BASE_CPM  
001c			; TODO fixup for CPM  
001c			Device_C: equ 080h          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			Device_D: equ 0c0h             ; Keyboard and LCD  
001c			  
001c			; Odd specific debug points for testing hardware dev  
001c			  
001c			DEBUG_SOUND: equ 1  
001c			DEBUG_STK_FAULT: equ 0  
001c			DEBUG_INPUT: equ 0     ; Debug input entry code  
001c			DEBUG_KEYCINWAIT: equ 0  
001c			DEBUG_KEYCIN: equ 0  
001c			DEBUG_KEY: equ 0  
001c			DEBUG_KEY_MATRIX: equ 0  
001c			DEBUG_STORECF: equ 0  
001c			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
001c			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
001c			DEBUG_SPI: equ 0    ; low level spi tests  
001c			  
001c			; Enable many break points  
001c			  
001c			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
001c			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
001c			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
001c			DEBUG_FORTH_JP: equ 0    ; 4  
001c			DEBUG_FORTH_MALLOC: equ 0  
001c			DEBUG_FORTH_MALLOC_INT: equ 0  
001c			DEBUG_FORTH_DOT: equ 0  
001c			DEBUG_FORTH_DOT_WAIT: equ 0  
001c			DEBUG_FORTH_MATHS: equ 0  
001c			DEBUG_FORTH_TOK: equ 0    ; 4  
001c			DEBUG_FORTH_PARSE: equ 0    ; 3  
001c			DEBUG_FORTH: equ 0  ;2  
001c			DEBUG_FORTH_WORDS: equ 1   ; 1  
001c			DEBUG_FORTH_PUSH: equ 1   ; 1  
001c			DEBUG_FORTH_UWORD: equ 1   ; 1  
001c			  
001c			; Enable key point breakpoints  
001c			  
001c			DEBUG_FORTH_DOT_KEY: equ 0  
001c			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
001c			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
001c			  
001c			; Debug stack imbalances  
001c			  
001c			ON: equ 1  
001c			OFF: equ 0  
001c			  
001c			DEBUG_STACK_IMB: equ 0  
001c			STACK_IMB_STORE: equ 20  
001c			  
001c			; House keeping and protections  
001c			  
001c			DEBUG_FORTH_STACK_GUARD: equ 1  
001c			DEBUG_FORTH_MALLOC_GUARD: equ 1  
001c			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
001c			FORTH_ENABLE_FREE: equ 0  
001c			FORTH_ENABLE_MALLOCFREE: equ 1  
001c			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
001c			FORTH_ENABLE_FLOATMATH: equ 0  
001c			  
001c			  
001c			CALLMONITOR: macro  
001c				call break_point_state  
001c				endm  
001c			  
001c			MALLOC_1: equ 1        ; from dk88   
001c			MALLOC_2: equ 0           ; broke  
001c			MALLOC_3: equ 0           ; really broke  
001c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
001c			  
001c			if BASE_KEV   
001c			stacksize: equ 256  
001c			  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 512  
001c			endif  
001c			if BASE_SC114  
001c			;tos:	equ 0f000h  
001c			stacksize: equ 256  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 256  
001c			endif  
001c			  
001c			if BASE_CPM  
001c			;tos:	equ 0f000h  
001c			stacksize: equ 256  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 256  
001c			endif  
001c			  
001c			;if STORAGE_SE == 0  
001c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
001c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
001c			;endif  
001c			  
001c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
001c			  
001c			STORE_0_AUTORUN: equ $20  
001c			  
001c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
001c			  
001c			STORE_0_AUTOFILE: equ $21  
001c			STORE_0_BANKRUN: equ $23  
001c			STORE_0_FILERUN: equ $24  
001c			  
001c			; Block 0 offsets for settings  
001c			  
001c			; if set then skip prompt for start up and accept all  
001c			  
001c			STORE_0_QUICKSTART: equ $25  
001c			  
001c			; Blocks where directory table is held  
001c			  
001c			; Reducing the number of entries increases the max file size  
001c			  
001c			;STORE_DIR_START: equ 1  
001c			;STORE_DIR_END: equ 33  
001c			  
001c			; Blocks from where file data is stored  
001c			  
001c			;STORE_DATA_START: equ STORE_DIR_END + 1  
001c			  
001c			; Block indicators (<32 are data files)  
001c			  
001c			;STORE_BLOCK_CFG: equ $8f       ; config block  
001c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
001c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
001c			;STORE_BLOCK_FREE: equ $85       ; data block free  
001c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
001c			  
001c			  
001c			  
001c			; Directory entry flags  
001c			  
001c			;STORE_DIR_FREE: equ 0  
001c			;STORE_DIR_FILE:  equ 1  
001c			  
001c			; Structure offsets to directory entries  
001c			;STORE_DE_FLAG: equ 0  
001c			;STORE_DE_MAXEXT: equ 1  
001c			;STORE_DE_FILENAME: equ 2  
001c			  
001c			; Structure offsets to block 0  
001c			  
001c			;STORE_BK0_ISFOR: equ 1  
001c			;STORE_BK0_LABEL: equ 3  
001c			  
001c			; memory allocation   
001c			  
001c			chk_stund: equ tos+2           ; underflow check word  
001c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
001c			  
001c			; keyscan table needs rows x cols buffer  
001c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
001c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
001c			  
001c			keyscan_table_row1: equ chk_stovr -key_cols-1  
001c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
001c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
001c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
001c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
001c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
001c			keyscan_scancol: equ keyscan_table-key_cols  
001c			;keyscan_table_len: equ key_rows*key_cols  
001c			;keybufptr: equ keyscan_table - 2  
001c			;keysymbol: equ keybufptr - 1  
001c			key_held: equ keyscan_scancol-1	; currently held  
001c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
001c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
001c			key_fa: equ key_repeat_ct -1 ;  
001c			key_fb: equ key_fa -1 ;  
001c			key_fc: equ key_fb -1 ;  
001c			key_fd: equ key_fc -1 ;  
001c			key_face_held: equ key_fd - 1   
001c			  
001c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
001c			  
001c			hardware_config: equ key_face_held - 10  
001c			  
001c			; hardware config switches  
001c			; TODO add bitmasks on includes for hardware  
001c			; high byte for expansion ids  
001c			;     0000 0000  no card inserted  
001c			;     0000 0001  storage card inserted  
001c			;     0000 0010  spi sd card active  
001c			  
001c			;       
001c			; low byte:  
001c			;     0000 0001   4x4 keypad  
001c			;     0000 0010   full keyboard  
001c			;     0000 0011   spi/ext keyboard  
001c			;     0000 0100   20x4 lcd  
001c			;     0000 1000   40x4 lcd  
001c			;     0000 1100   spi/ext display  
001c			;     0001 0000   ide interface available  
001c			  
001c			hardware_word: equ hardware_config - 2  
001c			  
001c			; debug marker - optional display of debug point on the debug screens  
001c			  
001c			debug_mark: equ hardware_word - 4  
001c			  
001c			; input_str vars  
001c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
001c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
001c			input_size: equ input_start -1  ; number of chars  
001c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
001c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
001c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
001c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
001c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
001c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
001c			input_len: equ input_cur_onoff - 5 ; length of current input  
001c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
001c			  
001c			CUR_BLINK_RATE: equ 15  
001c			  
001c			key_actual_pressed: equ input_cursor - 1   
001c			key_symbol: equ key_actual_pressed - 1   
001c			key_shift: equ key_symbol - 1   
001c			  
001c			; Display allocation  
001c			  
001c			;display_rows: equ 4     ; move out to mini and mega files  
001c			;display_cols: equ 20  
001c			  
001c			display_fb_len: equ display_rows*display_cols  
001c			  
001c			; primary frame buffer     
001c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
001c			; working frame buffers  
001c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
001c			display_fb3: equ  display_fb1-display_fb_len - 1  
001c			display_fb2: equ  display_fb3-display_fb_len - 1  
001c			;  
001c			; pointer to active frame buffer  
001c			display_fb_active: equ display_fb2 - 2  
001c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
001c			display_write_tmp: equ display_lcde1e2 - 2  
001c			  
001c			  
001c			;  
001c			  
001c			;; can load into de directory  
001c			cursor_col: equ display_write_tmp-1  
001c			cursor_row: equ cursor_col-1  
001c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
001c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
001c			  
001c			; maths vars  
001c			  
001c			LFSRSeed: equ cursor_shape -20   
001c			randData: equ LFSRSeed - 2  
001c			xrandc: equ randData - 2  
001c			stackstore: equ xrandc - 2  
001c			seed1: equ  stackstore -2   
001c			seed2: equ seed1 - 2  
001c			  
001c			; cf storage vars  
001c			  
001c			iErrorNum:  equ seed2-1         ;Error number  
001c			iErrorReg:  equ iErrorNum -1              ;Error register  
001c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
001c			  
001c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
001c			  
001c			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
001c			  
001c			store_page: equ store_bank_active-STORE_BLOCK_LOG            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
001c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
001c			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
001c			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
001c			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
001c			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
001c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
001c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
001c			store_tmpid: equ store_tmp3 - 1		; page temp id  
001c			store_tmpext: equ store_tmpid - 1		; file extent temp  
001c			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
001c			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
001c			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
001c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
001c			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
001c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
001c			;  
001c			; spi vars  
001c			  
001c			  
001c			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
001c			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
001c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
001c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
001c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
001c			spi_device_id: equ spi_device - 1    ; human readable bank number  
001c			  
001c			;;;;; forth cli params  
001c			  
001c			; TODO use a different frame buffer for forth???  
001c			  
001c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
001c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
001c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
001c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
001c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
001c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
001c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
001c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
001c			  
001c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
001c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
001c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
001c			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
001c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
001c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
001c			  
001c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
001c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
001c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
001c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
001c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
001c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
001c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
001c			  
001c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
001c			  
001c			; os/forth token vars  
001c			  
001c			os_last_cmd: equ os_var_array-255  
001c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
001c			os_current_i: equ os_cli_cmd-2  
001c			os_cur_ptr: equ os_current_i-2  
001c			os_word_scratch: equ os_cur_ptr-30  
001c			os_tok_len: equ os_word_scratch - 2  
001c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
001c			os_tok_malloc: equ os_tok_ptr - 2  
001c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
001c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
001c			execscratch: equ os_input-255        ; exec cmd eval buffer  
001c			scratch: equ execscratch-255  
001c			  
001c			  
001c			; temp locations for new word processing to save on adding more   
001c			  
001c			os_new_malloc: equ scratch-2  
001c			os_new_parse_len: equ os_new_malloc - 2  
001c			os_new_word_len: equ os_new_parse_len - 2  
001c			os_new_work_ptr: equ os_new_word_len - 2  
001c			os_new_src_ptr: equ os_new_work_ptr - 2  
001c			os_new_exec: equ os_new_src_ptr - 2  
001c			os_new_exec_ptr: equ os_new_exec - 2  
001c			  
001c			; resume memory alloocations....  
001c			  
001c			os_view_disable: equ os_new_exec_ptr - 1  
001c			os_view_af: equ os_view_disable - 2  
001c			os_view_hl: equ os_view_af -2  
001c			os_view_de: equ os_view_hl - 2  
001c			os_view_bc: equ os_view_de - 2  
001c			  
001c			; stack checksum word  
001c			if DEBUG_STACK_IMB  
001c				curframe: equ  os_view_de - 5  
001c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
001c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
001c			else  
001c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
001c			endif  
001c			  
001c			; with data stack could see memory filled with junk. need some memory management   
001c			; malloc and free entry points added  
001c			  
001c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
001c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
001c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			;heap_end: equ free_list-1  ; Starting address of heap  
001c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			  
001c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			heap_end: equ chk_word-1  ; Starting address of heap  
001c			  
001c			  
001c			;if BASE_KEV   
001c			;heap_start: equ 0800eh  ; Starting address of heap  
001c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
001c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
001c			;endif  
001c			  
001c			;if BASE_SC114  
001c			;heap_start: equ baseram+15  ; Starting address of heap  
001c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
001c			;endif  
001c			  
001c			  
001c			;;;;  
001c			  
001c			  
001c			; change below to point to last memory alloc above  
001c			topusermem:  equ   heap_start  
001c			  
001c			;if BASE_KEV   
001c			;baseusermem: equ 08000h  
001c			;endif  
001c			  
001c			;if BASE_SC114  
001c			;;aseusermem:     equ    12  
001c			;baseusermem:     equ    prompt  
001c			;;baseusermem:     equ    endofcode  
001c			;endif  
001c			  
001c			  
001c			; **********************************************************************  
001c			; **  Constants  
001c			; **********************************************************************  
001c			  
001c			; Constants used by this code module  
001c			kDataReg:   EQU Device_D           ;PIO port A data register  
001c			kContReg:   EQU Device_D+2           ;PIO port A control register  
001c			  
001c			  
001c			portbdata:  equ Device_D+1    ; port b data  
001c			portbctl:   equ Device_D+3    ; port b control  
001c			  
001c			  
001c			;KEY_SHIFT:   equ 5  
001c			;KEY_SYMBOLSHIFT:  equ 6  
001c			  
001c			KEY_SHIFTLOCK: equ 4  
001c			  
001c			  
001c			KEY_UP: equ 5  
001c			KEY_NEXTWORD: equ 6  
001c			KEY_PREVWORD: equ 7  
001c			KEY_BS: equ 8  
001c			KEY_TAB:  equ 9  
001c			KEY_DOWN: equ 10  
001c			KEY_LEFT: equ 11  
001c			KEY_RIGHT: equ 12  
001c			KEY_CR:   equ 13  
001c			KEY_HOME: equ 14  
001c			KEY_END: equ 15  
001c			  
001c			KEY_F1: equ 16  
001c			KEY_F2: equ 17  
001c			KEY_F3: equ 18  
001c			KEY_F4: equ 19  
001c			  
001c			KEY_F5: equ 20  
001c			KEY_F6: equ 21  
001c			KEY_F7: equ 22  
001c			KEY_F8: equ 23  
001c			  
001c			KEY_F9: equ 24  
001c			KEY_F10: equ 25  
001c			KEY_F11: equ 26  
001c			KEY_F12: equ 27  
001c			  
001c			;if DEBUG_KEY  
001c			;	KEY_MATRIX_NO_PRESS: equ '.'  
001c			;	KEY_SHIFT:   equ '.'  
001c			;	KEY_SYMBOLSHIFT:  equ '.'  
001c			;else  
001c				KEY_SHIFT:   equ '~'  
001c				KEY_SYMBOLSHIFT:  equ '~'  
001c				KEY_MATRIX_NO_PRESS: equ '~'  
001c			;endi  
001c			  
001c			  
001c			  
001c			  
001c			; Macro to make adding debug marks easier  
001c			  
001c			DMARK: macro str  
001c				push af  
001c				ld a, (.dmark)  
001c				ld (debug_mark),a  
001c				ld a, (.dmark+1)  
001c				ld (debug_mark+1),a  
001c				ld a, (.dmark+2)  
001c				ld (debug_mark+2),a  
001c				jr .pastdmark  
001c			.dmark: db str  
001c			.pastdmark: pop af  
001c			  
001c			endm  
001c			  
001c			  
001c			; macro to detect for stack imbalances  
001c			  
001c			include "stackimbal.asm"  
001c			; Macro and code to detect stock imbalances 
001c			 
001c			SPPUSH: equ 0 
001c			 
001c			; Add a stack frame which can be checked before return 
001c			 
001c			STACKFRAME: macro onoff frame1 frame2 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						; save current SP 
001c						exx 
001c			 
001c						ld de, frame1 
001c						ld a, d 
001c						ld hl, curframe 
001c						call hexout 
001c						ld a, e 
001c						ld hl, curframe+2 
001c						call hexout 
001c			  
001c						ld hl, frame1 
001c						push hl 
001c						ld hl, frame2 
001c						push hl 
001c						exx 
001c					endif 
001c					 
001c				endif 
001c			endm 
001c			 
001c			STACKFRAMECHK: macro onoff frame1 frame2 
001c			 
001c					 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						exx 
001c						; check stack frame SP 
001c			 
001c						ld hl, frame2 
001c						pop de   ; frame2 
001c			 
001c						call cmp16 
001c						jr nz, .spnosame 
001c						 
001c			 
001c						ld hl, frame1 
001c						pop de   ; frame1 
001c			 
001c						call cmp16 
001c						jr z, .spfrsame 
001c			 
001c						.spnosame: call showsperror 
001c			 
001c						.spfrsame: nop 
001c			 
001c						exx 
001c					endif 
001c					 
001c				endif 
001c			 
001c			 
001c			endm 
001c			 
001c			 
001c			; for a sub routine, wrap SP collection and comparisons 
001c			 
001c			; Usage: 
001c			; 
001c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
001c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
001c			 
001c			SAVESP: macro onoff storeword 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						; save current SP 
001c			 
001c						ld (store_sp+(storeword*4)), sp 
001c			 
001c					endif 
001c					 
001c				endif 
001c			 
001c			endm 
001c			 
001c			CHECKSP: macro onoff storeword 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c			 
001c						; save SP after last save 
001c				 
001c						ld (store_sp+(storeword*4)+2), sp 
001c			 
001c						push hl 
001c						ld hl, store_sp+(storeword*4) 
001c						call check_stack_sp  
001c						pop hl 
001c			 
001c			 
001c					endif 
001c					 
001c				endif 
001c			 
001c			endm 
001c			 
001c			if DEBUG_STACK_IMB 
001c			 
001c			check_stack_sp: 
001c					push de 
001c			 
001c					ld e, (hl) 
001c					inc hl 
001c					ld d, (hl) 
001c					inc hl 
001c			 
001c					push de 
001c			 
001c			 
001c					ld e, (hl) 
001c					inc hl 
001c					ld d, (hl) 
001c					inc hl 
001c			 
001c					pop hl 
001c			 
001c			 
001c					; check to see if the same 
001c			 
001c					call cmp16 
001c					jr z, .spsame 
001c			 
001c					; not same 
001c			 
001c					call showsperror 
001c			.spsame: 
001c			 
001c					pop de 
001c			 
001c					ret 
001c			 
001c			.sperr:  db "Stack imbalance",0 
001c			 
001c			 
001c			showsperror: 
001c			 
001c			 
001c				push hl 
001c				push af 
001c				push de 
001c				call clear_display 
001c				ld de, .sperr 
001c				ld a,0 
001c			;	ld de,os_word_scratch 
001c				call str_at_display 
001c				ld a, display_row_1+17 
001c				ld de, debug_mark 
001c				call str_at_display 
001c				ld a, 0 
001c				ld (curframe+4),a 
001c				ld hl, curframe 
001c				ld de, os_word_scratch 
001c				ld a, display_row_4 
001c				call str_at_display 
001c				call update_display 
001c				;call break_point_state 
001c				call cin_wait 
001c			 
001c				ld a, ' ' 
001c				ld (os_view_disable), a 
001c				pop de	 
001c				pop af 
001c				pop hl 
001c				CALLMONITOR 
001c				ret 
001c			 
001c			endif 
001c			 
001c			 
001c			 
001c			; eof 
# End of file stackimbal.asm
001c			  
001c			;TODO macro to calc col and row offset into screen  
001c			  
001c			  
001c			  
001c			hardware_init:  
001c			  
001c				  
001c			  
001c					;ld a, 0  
001c					;ld (hardware_diag), a  
001c			  
001c					; clear all the buffers  
001c			  
001c 21 f9 fd				ld hl, display_fb1  
001f 22 55 fd				ld (display_fb_active), hl  
0022			  
0022 cd 15 0d				call clear_display  
0025			  
0025 21 57 fd				ld hl, display_fb2  
0028 22 55 fd				ld (display_fb_active), hl  
002b			  
002b cd 15 0d				call clear_display  
002e			  
002e					; init primary frame buffer area  
002e 21 4a fe				ld hl, display_fb0  
0031 22 55 fd				ld (display_fb_active), hl  
0034			  
0034 cd 15 0d				call clear_display  
0037			  
0037			  
0037 cd 43 6d				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
003a			  
003a cd 8c 6e			call key_init  
003d cd fb 01			call storage_init  
0040			  
0040				; setup malloc functions  
0040			  
0040				if MALLOC_1  
0040 cd ec 13				call  heap_init  
0043				endif  
0043				if MALLOC_4  
0043					call  heap_init  
0043				endif  
0043			  
0043				; init sound hardware if present  
0043			  
0043				if SOUND_ENABLE  
0043					call sound_init  
0043				endif  
0043			  
0043				; lcd test sequence  
0043					  
0043 cd 38 0d			call update_display  
0046 cd 92 0c			call delay1s  
0049 3e 2b			ld a,'+'  
004b cd 1a 0d			call fill_display  
004e cd 38 0d			call update_display  
0051 cd 92 0c			call delay1s  
0054 3e 2a			ld a,'*'  
0056 cd 1a 0d			call fill_display  
0059 cd 38 0d			call update_display  
005c cd 92 0c			call delay1s  
005f 3e 2d			ld a,'-'  
0061 cd 1a 0d			call fill_display  
0064 cd 38 0d			call update_display  
0067 cd 92 0c			call delay1s  
006a			  
006a			; boot splash screen  
006a			if display_cols == 20	  
006a 3e 00		        ld a, display_row_1    
006c			else  
006c			        ld a, display_row_1 +10   
006c			endif  
006c 11 9c 1a			ld de, prom_bootmsg  
006f cd 28 0d			call str_at_display  
0072 cd 38 0d			call update_display  
0075			  
0075			  
0075 cd 92 0c			call delay1s  
0078 cd 92 0c			call delay1s  
007b			if display_cols == 20	  
007b 3e 2a		            LD   A, display_row_3+2  
007d			else  
007d			            LD   A, display_row_3+12  
007d			endif  
007d 11 b1 1a			ld de, prom_bootmsg1  
0080 cd 28 0d			call str_at_display  
0083 cd 38 0d			call update_display  
0086 cd 92 0c			call delay1s  
0089 cd 92 0c			call delay1s  
008c			  
008c			;	ld a, display_row_4+3  
008c			;	ld de, bootmsg2  
008c			;	call str_at_display  
008c			;	call update_display  
008c			;	call delay1s  
008c			;	call delay1s  
008c			  
008c			; debug mark setup  
008c			  
008c 3e 5f		ld a, '_'  
008e 32 b4 fe		ld (debug_mark),a  
0091 32 b5 fe		ld (debug_mark+1),a  
0094 32 b6 fe		ld (debug_mark+2),a  
0097 3e 00		ld a,0  
0099 32 b7 fe		ld (debug_mark+3),a  
009c			  
009c c9					ret  
009d			  
009d			  
009d			;bootmsg2:	db "Firmware v0.1",0  
009d			  
009d			; a 4x20 lcd  
009d			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
009d			  
009d			;if display_cols == 20  
009d			;	include "firmware_lcd_4x20.asm"  
009d			;endif  
009d			  
009d			;if display_cols == 40  
009d			;	include "firmware_lcd_4x40.asm"  
009d			;endif  
009d			  
009d			;  
009d			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
009d			; TODO abstract the bit bang video out interface for dual display  
009d			; TODO wire video out to tx pin on rc2014 bus  
009d			  
009d			; must supply cin, and cin_wait for low level hardware abstraction   
009d			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
009d			; test scancode  
009d			  
009d			;;;;;  
009d			;;;  
009d			; Moved out to mini and maxi versions  
009d			;  
009d			; include "firmware_key_4x4.asm"  
009d			; using existing 4 wire x 4 resistor array for input  
009d			;include "firmware_key_4x10.asm"  
009d			; need to mod the board for 5 rows due to resistor array  
009d			;include "firmware_key_5x10.asm"  
009d			  
009d			; storage hardware interface  
009d			  
009d			; use microchip serial eeprom for storage  
009d			  
009d			  
009d			if STORAGE_SE  
009d				include "firmware_spi.asm"  
009d			; my spi protocol (used by storage) 
009d			 
009d			; SPI pins 
009d			 
009d			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
009d			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
009d			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
009d			 
009d			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
009d			; chip pin 4 gnd 
009d			 
009d			 
009d			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
009d			SPI_CE1: equ 1      ;    port a1 pin 14  
009d			SPI_CE2: equ 2      ;    port a2 pin pin 13 
009d			SPI_CE3: equ 3      ; port    a3 pin pin 12 
009d			SPI_CE4: equ 4      ; port a4     pin 10 
009d			 
009d			; active low AND masks 
009d			 
009d			;SPI_CE0_MASK: equ    255-1 
009d			;SPI_CE1_MASK: equ   255-2 
009d			;SPI_CE2_MASK: equ   255-4 
009d			;SPI_CE3_MASK: equ   255-8 
009d			;SPI_CE4_MASK: equ   255-16 
009d			SPI_CE_HIGH:  equ 255 
009d			 
009d			 
009d			 
009d			;  Perform SCLK wait pulse 
009d			 
009d			spi_clk: 
009d f5				push af 
009e 3a f1 fb			ld a, (spi_clktime) 
00a1 fe 00			cp 0 
00a3 28 03			jr z, .scskip 
00a5 cd 77 0c			call aDelayInMS 
00a8			.scskip: 
00a8 f1				pop af 
00a9 c9				ret 
00aa			 
00aa			 
00aa			 
00aa			; TODO store port id for spi device ie dev c 
00aa			; TODO store pin for SO 
00aa			; TODO store pin for SI 
00aa			; TODO store pin for SCLK 
00aa			 
00aa			; 
00aa			 
00aa			; ensure that spi bus is in a stable state with default pins  
00aa			 
00aa			se_stable_spi:   
00aa			 
00aa				 ; set DI high, CE high , SCLK low 
00aa				;ld a, SPI_DI | SPI_CE0 
00aa 3e 07			ld a, SPI_DI  
00ac cd b6 01			call spi_ce_high 
00af d3 80			 out (storage_adata),a 
00b1 32 ee fb			ld (spi_portbyte),a 
00b4			 
00b4				if DEBUG_SPI 
00b4					push hl 
00b4					ld l, a 
00b4					DMARK "SPI" 
00b4					CALLMONITOR 
00b4					pop hl 
00b4				endif 
00b4 c9				ret 
00b5			 
00b5			; byte to send in a 
00b5			 
00b5			spi_send_byte: 
00b5				; save byte to send for bit mask shift out 
00b5 4f			        ld c,a 
00b6 3a ee fb			ld a,(spi_portbyte) 
00b9				  
00b9				; clock out	each bit of the byte msb first 
00b9			 
00b9 06 08			ld b, 8 
00bb			.ssb1: 
00bb				; clear so bit  
00bb cb bf			res SPI_DI, a 
00bd cb 11			rl c 
00bf				; if bit 7 is set then carry is set 
00bf 30 02			jr nc, .ssb2 
00c1 cb ff			set SPI_DI,a 
00c3			.ssb2:  ; output bit to ensure it is stable 
00c3 d3 80			out (storage_adata),a 
00c5 00				nop 
00c6				; clock bit high 
00c6 cb ef			set SPI_SCLK,a 
00c8 d3 80			out (storage_adata),a 
00ca 00				nop 
00cb cd 9d 00			call spi_clk 
00ce				; then low 
00ce cb af			res SPI_SCLK,a 
00d0 d3 80			out (storage_adata),a 
00d2 00				nop 
00d3 cd 9d 00			call spi_clk 
00d6 10 e3			djnz .ssb1 
00d8			 
00d8 32 ee fb			ld (spi_portbyte),a 
00db c9				ret 
00dc			 
00dc			; TODO low level get byte into A on spi 
00dc			 
00dc			spi_read_byte:  
00dc			 
00dc				; save byte to send for bit mask shift out 
00dc 0e 00		    ld c,0 
00de 3a ee fb			ld a,(spi_portbyte) 
00e1				  
00e1				; clock out	each bit of the byte msb first 
00e1			 
00e1			 
00e1				; clock bit high 
00e1 cb ef			set SPI_SCLK,a 
00e3 d3 80			out (storage_adata),a 
00e5 00				nop 
00e6 cd 9d 00			call spi_clk 
00e9			 
00e9			    ; read DO  
00e9			 
00e9 cb f9		    set 7,c 
00eb db 80			in a,(storage_adata) 
00ed cb 77		    bit SPI_DO,a 
00ef 20 02		    jr nz, .b7 
00f1 cb b9		    res 7,c 
00f3			.b7: 
00f3				; then low 
00f3 cb af			res SPI_SCLK,a 
00f5 d3 80			out (storage_adata),a 
00f7 00				nop 
00f8 cd 9d 00			call spi_clk 
00fb			     
00fb			 
00fb				; clock bit high 
00fb cb ef			set SPI_SCLK,a 
00fd d3 80			out (storage_adata),a 
00ff 00				nop 
0100 cd 9d 00			call spi_clk 
0103			 
0103			    ; read DO  
0103			 
0103 cb f1		    set 6,c 
0105 db 80			in a,(storage_adata) 
0107 cb 77		    bit SPI_DO,a 
0109 20 02		    jr nz, .b6 
010b cb b1		    res 6,c 
010d			.b6: 
010d				; then low 
010d cb af			res SPI_SCLK,a 
010f d3 80			out (storage_adata),a 
0111 00				nop 
0112 cd 9d 00			call spi_clk 
0115			 
0115				; clock bit high 
0115 cb ef			set SPI_SCLK,a 
0117 d3 80			out (storage_adata),a 
0119 00				nop 
011a cd 9d 00			call spi_clk 
011d			 
011d			 
011d			    ; read DO  
011d			 
011d cb e9		    set 5,c 
011f db 80			in a,(storage_adata) 
0121 cb 77		    bit SPI_DO,a 
0123 20 02		    jr nz, .b5 
0125 cb a9		    res 5,c 
0127			.b5: 
0127				; then low 
0127 cb af			res SPI_SCLK,a 
0129 d3 80			out (storage_adata),a 
012b 00				nop 
012c cd 9d 00			call spi_clk 
012f				; clock bit high 
012f cb ef			set SPI_SCLK,a 
0131 d3 80			out (storage_adata),a 
0133 00				nop 
0134 cd 9d 00			call spi_clk 
0137			 
0137			    ; read DO  
0137			 
0137 cb e1		    set 4,c 
0139 db 80			in a,(storage_adata) 
013b cb 77		    bit SPI_DO,a 
013d 20 02		    jr nz, .b4 
013f cb a1		    res 4,c 
0141			.b4: 
0141				; then low 
0141 cb af			res SPI_SCLK,a 
0143 d3 80			out (storage_adata),a 
0145 00				nop 
0146 cd 9d 00			call spi_clk 
0149				; clock bit high 
0149 cb ef			set SPI_SCLK,a 
014b d3 80			out (storage_adata),a 
014d 00				nop 
014e cd 9d 00			call spi_clk 
0151			 
0151			    ; read DO  
0151			 
0151 cb d9		    set 3,c 
0153 db 80			in a,(storage_adata) 
0155 cb 77		    bit SPI_DO,a 
0157 20 02		    jr nz, .b3 
0159 cb 99		    res 3,c 
015b			.b3: 
015b				; then low 
015b cb af			res SPI_SCLK,a 
015d d3 80			out (storage_adata),a 
015f 00				nop 
0160 cd 9d 00			call spi_clk 
0163				; clock bit high 
0163 cb ef			set SPI_SCLK,a 
0165 d3 80			out (storage_adata),a 
0167 00				nop 
0168 cd 9d 00			call spi_clk 
016b			 
016b			    ; read DO  
016b			 
016b cb d1		    set 2,c 
016d db 80			in a,(storage_adata) 
016f cb 77		    bit SPI_DO,a 
0171 20 02		    jr nz, .b2 
0173 cb 91		    res 2,c 
0175			.b2: 
0175				; then low 
0175 cb af			res SPI_SCLK,a 
0177 d3 80			out (storage_adata),a 
0179 00				nop 
017a cd 9d 00			call spi_clk 
017d				; clock bit high 
017d cb ef			set SPI_SCLK,a 
017f d3 80			out (storage_adata),a 
0181 00				nop 
0182 cd 9d 00			call spi_clk 
0185			 
0185			    ; read DO  
0185			 
0185 cb c9		    set 1,c 
0187 db 80			in a,(storage_adata) 
0189 cb 77		    bit SPI_DO,a 
018b 20 02		    jr nz, .b1 
018d cb 89		    res 1,c 
018f			.b1: 
018f				; then low 
018f cb af			res SPI_SCLK,a 
0191 d3 80			out (storage_adata),a 
0193 00				nop 
0194 cd 9d 00			call spi_clk 
0197				; clock bit high 
0197 cb ef			set SPI_SCLK,a 
0199 d3 80			out (storage_adata),a 
019b 00				nop 
019c cd 9d 00			call spi_clk 
019f			 
019f			    ; read DO  
019f			 
019f cb c1		    set 0,c 
01a1 db 80			in a,(storage_adata) 
01a3 cb 77		    bit SPI_DO,a 
01a5 20 02		    jr nz, .b0 
01a7 cb 81		    res 0,c 
01a9			.b0: 
01a9				; then low 
01a9 cb af			res SPI_SCLK,a 
01ab d3 80			out (storage_adata),a 
01ad 00				nop 
01ae cd 9d 00			call spi_clk 
01b1			 
01b1			 
01b1 32 ee fb			ld (spi_portbyte),a 
01b4			 
01b4			    ; return byte 
01b4 79			    ld a,c 
01b5			 
01b5			 
01b5 c9				ret 
01b6			 
01b6			 
01b6			 
01b6			spi_ce_high: 
01b6			 
01b6				if DEBUG_SPI_HARD_CE0 
01b6			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
01b6					ret 
01b6			 
01b6				endif 
01b6			 
01b6			 
01b6 f5				push af 
01b7			 
01b7				; send direct ce to port b 
01b7 3e ff			ld a, 255 
01b9 d3 81			out (storage_bdata), a 
01bb			 
01bb f1				pop af 
01bc			 
01bc				; for port a that shares with spi lines AND the mask 
01bc			  
01bc				if DEBUG_SPI 
01bc					push hl 
01bc					ld h, a 
01bc				endif 
01bc			;	ld c, SPI_CE_HIGH 
01bc			;	and c 
01bc cb c7			set SPI_CE0, a 
01be cb cf			set SPI_CE1, a 
01c0 cb d7			set SPI_CE2, a 
01c2 cb df			set SPI_CE3, a 
01c4 cb e7			set SPI_CE4, a 
01c6			 
01c6				if DEBUG_SPI 
01c6					ld l, a 
01c6					DMARK "CEh" 
01c6					CALLMONITOR 
01c6					pop hl 
01c6				endif 
01c6 c9				ret 
01c7			 
01c7			 
01c7			spi_ce_low: 
01c7			 
01c7				if DEBUG_SPI_HARD_CE0 
01c7			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01c7					ret 
01c7			 
01c7				endif 
01c7			 
01c7 c5				push bc 
01c8 f5				push af 
01c9			 
01c9				; send direct ce to port b 
01c9 3a f0 fb			ld a, (spi_cartdev) 
01cc d3 81			out (storage_bdata), a 
01ce			 
01ce			 
01ce			 
01ce				; for port a that shares with spi lines AND the mask 
01ce			 
01ce 3a ed fb			ld a, (spi_device)  
01d1 4f				ld c, a 
01d2			 
01d2 f1				pop af 
01d3			 
01d3				; detect CEx 
01d3			 
01d3				if DEBUG_SPI 
01d3					push hl 
01d3					ld h, a 
01d3				endif 
01d3			 
01d3 cb 41			bit SPI_CE0, c 
01d5 20 04			jr nz, .cel1 
01d7 cb 87			res SPI_CE0, a 
01d9 18 1e			jr .celn 
01db			.cel1: 
01db cb 49			bit SPI_CE1, c 
01dd 20 04			jr nz, .cel2 
01df cb 8f			res SPI_CE1, a 
01e1 18 16			jr .celn 
01e3			.cel2: 
01e3 cb 51			bit SPI_CE2, c 
01e5 20 04			jr nz, .cel3 
01e7 cb 97			res SPI_CE2, a 
01e9 18 0e			jr .celn 
01eb			.cel3: 
01eb cb 59			bit SPI_CE3, c 
01ed 20 04			jr nz, .cel4 
01ef cb 9f			res SPI_CE3, a 
01f1 18 06			jr .celn 
01f3			.cel4: 
01f3 cb 61			bit SPI_CE4, c 
01f5 20 02			jr nz, .celn 
01f7 cb a7			res SPI_CE4, a 
01f9			.celn: 
01f9			 
01f9			 
01f9			 
01f9			;	add c 
01f9			 
01f9				if DEBUG_SPI 
01f9					ld l, a 
01f9					DMARK "CEl" 
01f9					CALLMONITOR 
01f9					pop hl 
01f9				endif 
01f9 c1				pop bc 
01fa c9				ret 
01fb			 
01fb			 
01fb			 
01fb			; eof 
01fb			 
01fb			 
01fb			 
01fb			 
01fb			 
# End of file firmware_spi.asm
01fb				include "firmware_seeprom.asm"  
01fb			; 
01fb			; persisent storage interface via microchip serial eeprom 
01fb			 
01fb			; port a pio 2 
01fb			; pa 7 - si 
01fb			; pa 6 - sclk  
01fb			; pa 5 - so 
01fb			; pa 4 - cs 
01fb			; pa 3 - cs 
01fb			; pa 2 - cs 
01fb			; pa 1 - cs 
01fb			; pa 0 - cs 
01fb			; 
01fb			; TODO get block 
01fb			; TODO save block 
01fb			; TODO load file 
01fb			; TODO save file 
01fb			; TODO get dir  
01fb			 
01fb			;  
01fb			storage_adata: equ Device_C    ; device c port a - onboard storage 
01fb			storage_actl: equ Device_C+2     ; device c port a 
01fb			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
01fb			storage_bctl: equ Device_C+3     ; device c port b 
01fb			 
01fb			 
01fb			; TODO move these to hardware driver file 
01fb			 
01fb			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
01fb			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
01fb			; storage bank file system format 
01fb			; 
01fb			; first page of bank: 
01fb			; 	addr 0 - status check 
01fb			;       addr 1 - write protect flag 
01fb			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
01fb			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
01fb			;         TODO see if scanning whole of for available next file id is fast enough 
01fb			;	addr 4 > zero term string of bank label 
01fb			; 
01fb			;        
01fb			;  
01fb			; first page of any file: 
01fb			;      byte 0 - file id  
01fb			;      byte 1-17 - fixed file name  
01fb			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
01fb			; 
01fb			; other pages of any file: 
01fb			;      byte 0 - file id 
01fb			;      byte 1> - file data 
01fb			; 
01fb			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
01fb			;  
01fb			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
01fb			 
01fb			 
01fb			;storage_so_bit: 5 
01fb			;storage_si_bit: 7 
01fb			;storage_sclk_bit: 6 
01fb			  
01fb			 
01fb			; init storage pio 
01fb			 
01fb			storage_init: 
01fb			 
01fb			 
01fb					; set default SPI clk pulse time as disabled 
01fb			 
01fb 3e 00				ld a, 0 
01fd 32 f1 fb				ld (spi_clktime), a 
0200			 
0200					; init hardware 
0200			 
0200 3e cf		            LD   A, 11001111b 
0202 d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
0204 3e 00		            LD   A, 00000000b 
0206 cb f7			set SPI_DO,a 
0208			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
0208 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
020a			 
020a 3e cf		            LD   A, 11001111b 
020c d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
020e 3e 00		            LD   A, 00000000b 
0210 d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
0212			 
0212				; set all external spi devices off  
0212 3e ff			ld a, 255 
0214 32 ed fb			ld (spi_device), a 
0217 32 f0 fb			ld (spi_cartdev), a 
021a			 
021a					; ensure the spi bus is in a default stable state 
021a cd aa 00				call se_stable_spi 
021d			 
021d			; TODO scan spi bus and gather which storage banks are present 
021d			 
021d			; populate store_bank_active  
021d			; for each ce line activate and attempt to write first byte of bank and read back 
021d			; if zero is returned then bank is empty 
021d			;   
021d			; 
021d			 
021d					; init file extent cache to save on slow reads 
021d			 
021d			;	ld hl, store_filecache 
021d			;	ld de, 0 
021d			;	ld hl,(de)	 
021d			 
021d			 
021d c9			    ret 
021e			 
021e			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
021e			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
021e			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
021e			 
021e			; INSTRUCTION SET 
021e			; READ 0000 0011 Read data from memory array beginning at selected address 
021e			; WRITE 0000 0010 Write data to memory array beginning at selected address 
021e			; WREN 0000 0110 Set the write enable latch (enable write operations) 
021e			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
021e			; RDSR 0000 0101 Read STATUS register 
021e			; WRSR 0000 0001 Write STATUS register 
021e			; PE 0100 0010 Page Erase – erase one page in memory array 
021e			; SE 1101 1000 Sector Erase – erase one sector in memory array 
021e			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
021e			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
021e			 
021e			; TODO send byte steam for page without setting the address for every single byte 
021e			; TODO read byte  
021e			 
021e			; byte in a 
021e			; address in hl  
021e			se_writebyte: 
021e			        
021e			    ;   ld c, a 
021e f5			        push af 
021f e5			        push hl 
0220			 
0220			    ; initi write mode 
0220			    ; 
0220			    ;CS low 
0220			 
0220 3a ee fb		       ld a,(spi_portbyte) 
0223 cd c7 01			call spi_ce_low 
0226			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0226 d3 80		       out (storage_adata),a 
0228 32 ee fb		       ld (spi_portbyte), a 
022b			 
022b			    ;clock out wren instruction 
022b			 
022b 3e 06		    ld a, store_wren_ins 
022d cd b5 00		    call spi_send_byte  
0230			 
0230			    ;cs high to enable write latch 
0230			 
0230 3a ee fb		       ld a,(spi_portbyte) 
0233 cd b6 01			call spi_ce_high 
0236			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0236 d3 80		       out (storage_adata),a 
0238 32 ee fb		       ld (spi_portbyte), a 
023b			 
023b 00				nop 
023c			    ; 
023c			    ; intial write data 
023c			    ; 
023c			    ; cs low 
023c			     
023c 3a ee fb		       ld a,(spi_portbyte) 
023f cd c7 01			call spi_ce_low 
0242			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0242 d3 80		       out (storage_adata),a 
0244 32 ee fb		       ld (spi_portbyte), a 
0247			 
0247			    ; clock out write instruction 
0247			     
0247 3e 02		    ld a, store_write_ins  
0249 cd b5 00		    call spi_send_byte  
024c			 
024c			    ; clock out address (depending on address size) 
024c			     
024c e1			    pop hl 
024d 7c			    ld a,h    ; address out msb first 
024e cd b5 00		    call spi_send_byte  
0251 7d			    ld a,l 
0252 cd b5 00		    call spi_send_byte  
0255			 
0255			    ; clock out byte(s) for page 
0255			 
0255 f1			    pop af 
0256 cd b5 00		    call spi_send_byte  
0259			 
0259			    ; end write with ce high 
0259 3a ee fb		       ld a,(spi_portbyte) 
025c			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
025c cd b6 01			call spi_ce_high 
025f d3 80		       out (storage_adata),a 
0261 32 ee fb		       ld (spi_portbyte), a 
0264			 
0264				; pause for internal write cycle 
0264 3e 0a			ld a, 10 
0266 cd 77 0c			call aDelayInMS 
0269 c9			    ret 
026a			 
026a			; buffer to write in de 
026a			; address in hl  
026a			se_writepage: 
026a			        
026a			    ;   ld c, a 
026a d5				push de 
026b e5			        push hl 
026c			 
026c			    ; initi write mode 
026c			    ; 
026c			    ;CS low 
026c			 
026c 3a ee fb		       ld a,(spi_portbyte) 
026f cd c7 01			call spi_ce_low 
0272			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0272 d3 80		       out (storage_adata),a 
0274 32 ee fb		       ld (spi_portbyte), a 
0277			 
0277			    ;clock out wren instruction 
0277			 
0277 3e 06		    ld a, store_wren_ins 
0279 cd b5 00		    call spi_send_byte  
027c			 
027c			    ;cs high to enable write latch 
027c			 
027c 3a ee fb		       ld a,(spi_portbyte) 
027f cd b6 01			call spi_ce_high 
0282			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0282 d3 80		       out (storage_adata),a 
0284 32 ee fb		       ld (spi_portbyte), a 
0287			 
0287 00				nop 
0288			    ; 
0288			    ; intial write data 
0288			    ; 
0288			    ; cs low 
0288			     
0288 3a ee fb		       ld a,(spi_portbyte) 
028b			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
028b cd c7 01			call spi_ce_low 
028e d3 80		       out (storage_adata),a 
0290 32 ee fb		       ld (spi_portbyte), a 
0293			 
0293			    ; clock out write instruction 
0293			     
0293 3e 02		    ld a, store_write_ins  
0295 cd b5 00		    call spi_send_byte  
0298			 
0298			    ; clock out address (depending on address size) 
0298			     
0298 e1			    pop hl 
0299 7c			    ld a,h    ; address out msb first 
029a cd b5 00		    call spi_send_byte  
029d 7d			    ld a,l 
029e cd b5 00		    call spi_send_byte  
02a1			 
02a1			    ; clock out byte(s) for page 
02a1			 
02a1 e1				pop hl 
02a2 06 40			ld b, STORE_BLOCK_PHY 
02a4			.bytewrite: 
02a4			 
02a4 7e				ld a,(hl) 
02a5 e5			    push hl 
02a6 c5				push bc 
02a7 cd b5 00		    call spi_send_byte  
02aa c1				pop bc 
02ab e1				pop hl 
02ac			 
02ac			    ; end write with ce high 
02ac 3a ee fb		       ld a,(spi_portbyte) 
02af cd b6 01			call spi_ce_high 
02b2			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02b2 d3 80		       out (storage_adata),a 
02b4 32 ee fb		       ld (spi_portbyte), a 
02b7			 
02b7 23				inc hl 
02b8 10 ea			djnz .bytewrite 
02ba			 
02ba				; pause for internal write cycle 
02ba 3e 64			ld a, 100 
02bc cd 77 0c			call aDelayInMS 
02bf c9			    ret 
02c0			; returns byte in a 
02c0			; address in hl  
02c0			se_readbyte: 
02c0 d5				push de 
02c1 c5				push bc 
02c2			 
02c2			    ;   ld c, a 
02c2 e5			        push hl 
02c3			 
02c3			    ; initi write mode 
02c3			    ; 
02c3			    ;CS low 
02c3			 
02c3 3a ee fb		       ld a,(spi_portbyte) 
02c6 cd c7 01			call spi_ce_low 
02c9			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02c9 d3 80		       out (storage_adata),a 
02cb 32 ee fb		       ld (spi_portbyte), a 
02ce			 
02ce			    ;clock out wren instruction 
02ce			 
02ce 3e 03		    ld a, store_read_ins 
02d0 cd b5 00		    call spi_send_byte  
02d3			 
02d3			 
02d3			    ; clock out address (depending on address size) 
02d3			     
02d3 e1			    pop hl 
02d4 7c			    ld a,h    ; address out msb first 
02d5 cd b5 00		    call spi_send_byte  
02d8 7d			    ld a,l 
02d9 cd b5 00		    call spi_send_byte  
02dc			 
02dc			    ; clock in byte(s) for page 
02dc			 
02dc cd dc 00		    call spi_read_byte  
02df f5				push af 
02e0			 
02e0			    ; end write with ce high 
02e0 3a ee fb		       ld a,(spi_portbyte) 
02e3			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02e3 cd b6 01			call spi_ce_high 
02e6 d3 80		       out (storage_adata),a 
02e8 32 ee fb		       ld (spi_portbyte), a 
02eb			 
02eb f1				pop af 
02ec			 
02ec c1				pop bc 
02ed d1				pop de 
02ee			 
02ee c9			    ret 
02ef			 
02ef			if DEBUG_STORESE 
02ef			 
02ef			storageput:  
02ef			 
02ef			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
02ef			 
02ef 21 84 f3			ld hl,scratch+2 
02f2 cd 00 13			call get_word_hl 
02f5			 
02f5				; stuff it here for the moment as it will be overwritten later anyway 
02f5			 
02f5 22 a5 f6			ld (os_cur_ptr),hl	 
02f8			 
02f8			 
02f8			; get pointer to start of string 
02f8			 
02f8 21 89 f3			ld hl, scratch+7 
02fb			 
02fb			; loop writing char of string to eeprom 
02fb			 
02fb 7e			.writestr:	ld a,(hl) 
02fc fe 00				cp 0 
02fe 28 12				jr z, .wsdone		; done writing 
0300 e5					push hl 
0301 2a a5 f6				ld hl,(os_cur_ptr) 
0304 cd 1e 02				call se_writebyte 
0307			 
0307 2a a5 f6				ld hl,(os_cur_ptr)	 ; save next eeprom address 
030a 23					inc hl 
030b 22 a5 f6				ld (os_cur_ptr),hl 
030e			 
030e					; restore string pointer and get next char 
030e			 
030e e1					pop hl 
030f 23					inc hl 
0310 18 e9				jr .writestr 
0312			 
0312			 
0312			 
0312			.wsdone: 
0312			 
0312			 
0312			; when done load first page into a buffer  
0312			 
0312 21 00 80				ld hl,08000h		; start in ram 
0315 22 a5 f6				ld (os_cur_ptr),hl 
0318 21 00 00				ld hl, 0		 ; start of page 
031b 22 aa f3				ld (scratch+40),hl	; hang on to it 
031e			 
031e 06 80				ld b, 128		; actually get more then one page 
0320 c5			.wsload:	push bc 
0321 2a aa f3				ld hl,(scratch+40) 
0324 e5					push hl 
0325 cd c0 02				call se_readbyte 
0328			 
0328					; a now as the byte 
0328			 
0328 2a a5 f6				ld hl,(os_cur_ptr) 
032b 77					ld (hl),a 
032c					; inc next buffer area 
032c 23					inc hl 
032d 22 a5 f6				ld (os_cur_ptr),hl 
0330			 
0330					; get eeprom position, inc and save for next round 
0330 e1					pop hl		 
0331 23					inc hl 
0332 22 aa f3				ld (scratch+40),hl 
0335 c1					pop bc 
0336 10 e8				djnz .wsload 
0338			 
0338			; set 'd' pointer to start of buffer 
0338			 
0338 21 00 80				ld hl,08000h 
033b 22 a5 f6				ld (os_cur_ptr),hl 
033e			 
033e			 
033e c9			ret 
033f			 
033f			 
033f c9			storageread: ret 
0340			 
0340			 
0340			 
0340			 
0340			 
0340			 
0340			endif 
0340			 
0340			 
0340			 
# End of file firmware_seeprom.asm
0340			else  
0340			   ; create some stubs for the labels  
0340			se_readbyte: ret  
0340			se_writebyte: ret  
0340			storage_init: ret  
0340			  
0340			endif  
0340			  
0340			; use cf card for storage - throwing timeout errors. Hardware or software?????  
0340			;include "firmware_cf.asm"  
0340			  
0340			; load up high level storage hardward abstractions  
0340			include "firmware_storage.asm"  
0340			 
0340			; persisent storage hardware abstraction layer  
0340			 
0340			 
0340			 
0340			; Block 0 on storage is a config state 
0340			 
0340			 
0340			 
0340			; TODO add read phy block and write phy block functions 
0340			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
0340			 
0340			; Abstraction layer  
0340			 
0340			; Logocial block size is same size as physical size - using tape concept 
0340			 
0340			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
0340			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
0340			 
0340			 
0340			 
0340			; Filesystem layout (Logical layout) 
0340			; 
0340			; Block 0 - Bank config  
0340			; 
0340			;      Byte - 0 file id counter 
0340			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0340			;      Byte - 3-20 zero terminated bank label 
0340			; 
0340			; Block 1 > File storage 
0340			; 
0340			;      Byte 0 file id    - block 0 file details 
0340			;      Byte 1 block id - block 0 is file  
0340			;            Byte 2-15 - File name 
0340			; 
0340			;       - to end of block data 
0340			; 
0340			 
0340			; Get ID for the file named in pointer held HL 
0340			; Returns ID in HL = 255 if no file found 
0340			 
0340			storage_getid: 
0340			 
0340 22 00 fc			ld (store_tmp1), hl 
0343			 
0343				if DEBUG_STORESE 
0343					DMARK "SGI" 
0343 f5				push af  
0344 3a 58 03			ld a, (.dmark)  
0347 32 b4 fe			ld (debug_mark),a  
034a 3a 59 03			ld a, (.dmark+1)  
034d 32 b5 fe			ld (debug_mark+1),a  
0350 3a 5a 03			ld a, (.dmark+2)  
0353 32 b6 fe			ld (debug_mark+2),a  
0356 18 03			jr .pastdmark  
0358 ..			.dmark: db "SGI"  
035b f1			.pastdmark: pop af  
035c			endm  
# End of macro DMARK
035c					CALLMONITOR 
035c cd c6 18			call break_point_state  
035f				endm  
# End of macro CALLMONITOR
035f				endif 
035f				; get block 0 and set counter for number of files to scan 
035f			 
035f cd ca 04			call storage_get_block_0 
0362			 
0362 3a 07 fc			ld a, (store_page) 
0365 47				ld b, a 
0366			 
0366				; get extent 0 of each file id 
0366			 
0366				if DEBUG_STORESE 
0366					DMARK "SGc" 
0366 f5				push af  
0367 3a 7b 03			ld a, (.dmark)  
036a 32 b4 fe			ld (debug_mark),a  
036d 3a 7c 03			ld a, (.dmark+1)  
0370 32 b5 fe			ld (debug_mark+1),a  
0373 3a 7d 03			ld a, (.dmark+2)  
0376 32 b6 fe			ld (debug_mark+2),a  
0379 18 03			jr .pastdmark  
037b ..			.dmark: db "SGc"  
037e f1			.pastdmark: pop af  
037f			endm  
# End of macro DMARK
037f					CALLMONITOR 
037f cd c6 18			call break_point_state  
0382				endm  
# End of macro CALLMONITOR
0382				endif 
0382 60			.getloop:	ld h, b 
0383 2e 00				ld l, 0 
0385 c5					push bc 
0386			 
0386 11 07 fc				ld de, store_page 
0389				if DEBUG_STORESE 
0389					DMARK "SGr" 
0389 f5				push af  
038a 3a 9e 03			ld a, (.dmark)  
038d 32 b4 fe			ld (debug_mark),a  
0390 3a 9f 03			ld a, (.dmark+1)  
0393 32 b5 fe			ld (debug_mark+1),a  
0396 3a a0 03			ld a, (.dmark+2)  
0399 32 b6 fe			ld (debug_mark+2),a  
039c 18 03			jr .pastdmark  
039e ..			.dmark: db "SGr"  
03a1 f1			.pastdmark: pop af  
03a2			endm  
# End of macro DMARK
03a2					CALLMONITOR 
03a2 cd c6 18			call break_point_state  
03a5				endm  
# End of macro CALLMONITOR
03a5				endif 
03a5 cd 72 09				call storage_read 
03a8 cd 72 0f				call ishlzero 
03ab 28 2d				jr z, .gap 
03ad					 
03ad					; have a file name read. Is it one we want. 
03ad			 
03ad 2a 00 fc				ld hl, (store_tmp1) 
03b0 11 0a fc				ld de, store_page+3   ; file name 
03b3			 
03b3				if DEBUG_STORESE 
03b3					DMARK "SGc" 
03b3 f5				push af  
03b4 3a c8 03			ld a, (.dmark)  
03b7 32 b4 fe			ld (debug_mark),a  
03ba 3a c9 03			ld a, (.dmark+1)  
03bd 32 b5 fe			ld (debug_mark+1),a  
03c0 3a ca 03			ld a, (.dmark+2)  
03c3 32 b6 fe			ld (debug_mark+2),a  
03c6 18 03			jr .pastdmark  
03c8 ..			.dmark: db "SGc"  
03cb f1			.pastdmark: pop af  
03cc			endm  
# End of macro DMARK
03cc					CALLMONITOR 
03cc cd c6 18			call break_point_state  
03cf				endm  
# End of macro CALLMONITOR
03cf				endif 
03cf cd df 13				call strcmp 
03d2 20 06				jr nz, .gap   ; not this one 
03d4			 
03d4 c1				        pop bc 
03d5			 
03d5 26 00				ld h, 0 
03d7 68					ld l, b 
03d8 18 22				jr .getdone 
03da						 
03da			 
03da			 
03da			 
03da			.gap: 
03da				if DEBUG_STORESE 
03da					DMARK "SGg" 
03da f5				push af  
03db 3a ef 03			ld a, (.dmark)  
03de 32 b4 fe			ld (debug_mark),a  
03e1 3a f0 03			ld a, (.dmark+1)  
03e4 32 b5 fe			ld (debug_mark+1),a  
03e7 3a f1 03			ld a, (.dmark+2)  
03ea 32 b6 fe			ld (debug_mark+2),a  
03ed 18 03			jr .pastdmark  
03ef ..			.dmark: db "SGg"  
03f2 f1			.pastdmark: pop af  
03f3			endm  
# End of macro DMARK
03f3					CALLMONITOR 
03f3 cd c6 18			call break_point_state  
03f6				endm  
# End of macro CALLMONITOR
03f6				endif 
03f6			 
03f6 c1					pop bc 
03f7 10 89				djnz .getloop 
03f9 21 ff 00				ld hl, 255 
03fc			.getdone: 
03fc			 
03fc				if DEBUG_STORESE 
03fc					DMARK "SGe" 
03fc f5				push af  
03fd 3a 11 04			ld a, (.dmark)  
0400 32 b4 fe			ld (debug_mark),a  
0403 3a 12 04			ld a, (.dmark+1)  
0406 32 b5 fe			ld (debug_mark+1),a  
0409 3a 13 04			ld a, (.dmark+2)  
040c 32 b6 fe			ld (debug_mark+2),a  
040f 18 03			jr .pastdmark  
0411 ..			.dmark: db "SGe"  
0414 f1			.pastdmark: pop af  
0415			endm  
# End of macro DMARK
0415					CALLMONITOR 
0415 cd c6 18			call break_point_state  
0418				endm  
# End of macro CALLMONITOR
0418				endif 
0418			 
0418 c9				ret 
0419			 
0419			 
0419			 
0419			 
0419			 
0419			 
0419			 
0419			 
0419			; Read Block 
0419			; ---------- 
0419			; 
0419			; With current bank 
0419			;  
0419			; Get block number to read 
0419			; Load physical blocks starting at start block into buffer 
0419			 
0419			; de points to buffer to use 
0419			; hl holds logical block number  
0419			 
0419			storage_read_block: 
0419			 
0419				; TODO bank selection 
0419			 
0419				; for each of the physical blocks read it into the buffer 
0419 06 40			ld b, STORE_BLOCK_PHY 
041b			 
041b				if DEBUG_STORESE 
041b d5					push de 
041c				endif 
041c				 
041c			.rl1:    
041c			 
041c				; read physical block at hl into de 
041c			        ; increment hl and de to next read position on exit 
041c			 
041c e5				push hl 
041d d5				push de	 
041e c5				push bc 
041f			;	if DEBUG_STORESE 
041f			;		push af 
041f			;		ld a, 'R' 
041f			;		ld (debug_mark),a 
041f			;		pop af 
041f			;		CALLMONITOR 
041f			;	endif 
041f cd c0 02			call se_readbyte 
0422			;	if DEBUG_STORESE 
0422			;		ld a,(spi_portbyte) 
0422			;		ld l, a 
0422			;		push af 
0422			;		ld a, '1' 
0422			;		ld (debug_mark),a 
0422			;		pop af 
0422			;		CALLMONITOR 
0422			;	endif 
0422 c1				pop bc 
0423 d1				pop de 
0424 e1				pop hl 
0425 12				ld (de),a 
0426 23				inc hl 
0427 13				inc de 
0428			 
0428			;	if DEBUG_STORESE 
0428			;		push af 
0428			;		ld a, 'r' 
0428			;		ld (debug_mark),a 
0428			;		pop af 
0428			;		CALLMONITOR 
0428			;	endif 
0428			 
0428 10 f2			djnz .rl1 
042a			 
042a				if DEBUG_STORESE 
042a					DMARK "SRB" 
042a f5				push af  
042b 3a 3f 04			ld a, (.dmark)  
042e 32 b4 fe			ld (debug_mark),a  
0431 3a 40 04			ld a, (.dmark+1)  
0434 32 b5 fe			ld (debug_mark+1),a  
0437 3a 41 04			ld a, (.dmark+2)  
043a 32 b6 fe			ld (debug_mark+2),a  
043d 18 03			jr .pastdmark  
043f ..			.dmark: db "SRB"  
0442 f1			.pastdmark: pop af  
0443			endm  
# End of macro DMARK
0443 d1					pop de 
0444			; 
0444			;		push af 
0444			;		ld a, 'R' 
0444			;		ld (debug_mark),a 
0444			;		pop af 
0444					CALLMONITOR 
0444 cd c6 18			call break_point_state  
0447				endm  
# End of macro CALLMONITOR
0447				endif 
0447 c9				ret	 
0448				 
0448			 
0448			; File Size 
0448			; --------- 
0448			; 
0448			;   hl file id 
0448			; 
0448			;  returns in hl the number of blocks 
0448			 
0448			storage_file_size: 
0448 5d				ld e, l 
0449 16 00			ld d, 0 
044b 21 40 00			ld hl, STORE_BLOCK_PHY 
044e					if DEBUG_FORTH_WORDS 
044e						DMARK "SIZ" 
044e f5				push af  
044f 3a 63 04			ld a, (.dmark)  
0452 32 b4 fe			ld (debug_mark),a  
0455 3a 64 04			ld a, (.dmark+1)  
0458 32 b5 fe			ld (debug_mark+1),a  
045b 3a 65 04			ld a, (.dmark+2)  
045e 32 b6 fe			ld (debug_mark+2),a  
0461 18 03			jr .pastdmark  
0463 ..			.dmark: db "SIZ"  
0466 f1			.pastdmark: pop af  
0467			endm  
# End of macro DMARK
0467						CALLMONITOR 
0467 cd c6 18			call break_point_state  
046a				endm  
# End of macro CALLMONITOR
046a					endif 
046a cd 4c 07			call storage_findnextid 
046d			 
046d cd 72 0f			call ishlzero 
0470			;	ld a, l 
0470			;	add h 
0470			;	cp 0 
0470 c8				ret z			; block not found so EOF 
0471			 
0471 11 07 fc			ld de, store_page 
0474 cd 19 04			call storage_read_block 
0477			 
0477 3a 09 fc			ld a, (store_page+2)	 ; get extent count 
047a 6f				ld l, a 
047b 26 00			ld h, 0 
047d c9			 	ret 
047e			 
047e			 
047e			; Write Block 
047e			; ----------- 
047e			; 
047e			; With current bank 
047e			;  
047e			; Get block number to write 
047e			; Write physical blocks starting at start block from buffer 
047e			  
047e			storage_write_block: 
047e				; TODO bank selection 
047e			 
047e				; for each of the physical blocks read it into the buffer 
047e 06 40			ld b, STORE_BLOCK_PHY 
0480			 
0480				if DEBUG_STORESE 
0480					DMARK "SWB" 
0480 f5				push af  
0481 3a 95 04			ld a, (.dmark)  
0484 32 b4 fe			ld (debug_mark),a  
0487 3a 96 04			ld a, (.dmark+1)  
048a 32 b5 fe			ld (debug_mark+1),a  
048d 3a 97 04			ld a, (.dmark+2)  
0490 32 b6 fe			ld (debug_mark+2),a  
0493 18 03			jr .pastdmark  
0495 ..			.dmark: db "SWB"  
0498 f1			.pastdmark: pop af  
0499			endm  
# End of macro DMARK
0499			 
0499					;push af 
0499					;ld a, 'W' 
0499					;ld (debug_mark),a 
0499					;pop af 
0499					CALLMONITOR 
0499 cd c6 18			call break_point_state  
049c				endm  
# End of macro CALLMONITOR
049c				endif 
049c			 
049c			; might not be working 
049c			;	call se_writepage 
049c			 
049c			;	ret 
049c			; 
049c			 
049c			 
049c			 
049c			.wl1:    
049c			 
049c				; read physical block at hl into de 
049c			        ; increment hl and de to next read position on exit 
049c			 
049c e5				push hl 
049d d5				push de	 
049e c5				push bc 
049f 1a				ld a,(de) 
04a0				;if DEBUG_STORESE 
04a0			;		push af 
04a0			;		ld a, 'W' 
04a0			;		ld (debug_mark),a 
04a0			;		pop af 
04a0			;		CALLMONITOR 
04a0			;	endif 
04a0 cd 1e 02			call se_writebyte 
04a3			;	call delay250ms 
04a3 00				nop 
04a4 00				nop 
04a5 00				nop 
04a6			;	if DEBUG_STORESE 
04a6			;		push af 
04a6			;		ld a, 'w' 
04a6			;		ld (debug_mark),a 
04a6			;		pop af 
04a6			;		CALLMONITOR 
04a6			;	endif 
04a6 c1				pop bc 
04a7 d1				pop de 
04a8 e1				pop hl 
04a9 23				inc hl 
04aa 13				inc de 
04ab			 
04ab			 
04ab 10 ef			djnz .wl1 
04ad			 
04ad				if DEBUG_STORESE 
04ad					DMARK "SW2" 
04ad f5				push af  
04ae 3a c2 04			ld a, (.dmark)  
04b1 32 b4 fe			ld (debug_mark),a  
04b4 3a c3 04			ld a, (.dmark+1)  
04b7 32 b5 fe			ld (debug_mark+1),a  
04ba 3a c4 04			ld a, (.dmark+2)  
04bd 32 b6 fe			ld (debug_mark+2),a  
04c0 18 03			jr .pastdmark  
04c2 ..			.dmark: db "SW2"  
04c5 f1			.pastdmark: pop af  
04c6			endm  
# End of macro DMARK
04c6			 
04c6					;push af 
04c6					;ld a, 'W' 
04c6					;ld (debug_mark),a 
04c6					;pop af 
04c6					CALLMONITOR 
04c6 cd c6 18			call break_point_state  
04c9				endm  
# End of macro CALLMONITOR
04c9				endif 
04c9 c9				ret	 
04ca			 
04ca			; Init bank 
04ca			; --------- 
04ca			; 
04ca			; With current bank 
04ca			; 
04ca			; Setup block 0 config 
04ca			;     Set 0 file id counter 
04ca			;     Set formatted byte pattern 
04ca			;     Zero out bank label 
04ca			;      
04ca			; For every logical block write 0-1 byte as null 
04ca			 
04ca			storage_get_block_0: 
04ca			 
04ca				; TODO check presence 
04ca			 
04ca				; get block 0 config 
04ca			 
04ca 21 00 00			ld hl, 0 
04cd 11 07 fc			ld de, store_page 
04d0 cd 19 04			call storage_read_block 
04d3			 
04d3				if DEBUG_STORESE 
04d3					DMARK "SB0" 
04d3 f5				push af  
04d4 3a e8 04			ld a, (.dmark)  
04d7 32 b4 fe			ld (debug_mark),a  
04da 3a e9 04			ld a, (.dmark+1)  
04dd 32 b5 fe			ld (debug_mark+1),a  
04e0 3a ea 04			ld a, (.dmark+2)  
04e3 32 b6 fe			ld (debug_mark+2),a  
04e6 18 03			jr .pastdmark  
04e8 ..			.dmark: db "SB0"  
04eb f1			.pastdmark: pop af  
04ec			endm  
# End of macro DMARK
04ec 11 07 fc				ld de, store_page 
04ef			;		push af 
04ef			;		ld a, 'i' 
04ef			;		ld (debug_mark),a 
04ef			;		pop af 
04ef					CALLMONITOR 
04ef cd c6 18			call break_point_state  
04f2				endm  
# End of macro CALLMONITOR
04f2				endif 
04f2			 
04f2				; is this area formatted? 
04f2			 
04f2			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
04f2 2a 08 fc			ld hl, (store_page+1) 
04f5 3e 80			ld a,0x80 
04f7 bd				cp l 
04f8 20 22			jr nz, .ininotformatted 
04fa				; do a double check 
04fa 3e 27			ld a, 0x27 
04fc bc				cp h 
04fd 20 1d			jr nz, .ininotformatted 
04ff			 
04ff				; formatted then 
04ff			 
04ff				if DEBUG_STORESE 
04ff					DMARK "SB1" 
04ff f5				push af  
0500 3a 14 05			ld a, (.dmark)  
0503 32 b4 fe			ld (debug_mark),a  
0506 3a 15 05			ld a, (.dmark+1)  
0509 32 b5 fe			ld (debug_mark+1),a  
050c 3a 16 05			ld a, (.dmark+2)  
050f 32 b6 fe			ld (debug_mark+2),a  
0512 18 03			jr .pastdmark  
0514 ..			.dmark: db "SB1"  
0517 f1			.pastdmark: pop af  
0518			endm  
# End of macro DMARK
0518					;push af 
0518					;ld a, 'I' 
0518					;ld (debug_mark),a 
0518					;pop af 
0518					CALLMONITOR 
0518 cd c6 18			call break_point_state  
051b				endm  
# End of macro CALLMONITOR
051b				endif 
051b c9				ret 
051c			 
051c			.ininotformatted: 
051c				; bank not formatted so poke various bits to make sure 
051c			 
051c				if DEBUG_STORESE 
051c					DMARK "SB2" 
051c f5				push af  
051d 3a 31 05			ld a, (.dmark)  
0520 32 b4 fe			ld (debug_mark),a  
0523 3a 32 05			ld a, (.dmark+1)  
0526 32 b5 fe			ld (debug_mark+1),a  
0529 3a 33 05			ld a, (.dmark+2)  
052c 32 b6 fe			ld (debug_mark+2),a  
052f 18 03			jr .pastdmark  
0531 ..			.dmark: db "SB2"  
0534 f1			.pastdmark: pop af  
0535			endm  
# End of macro DMARK
0535					;push af 
0535					;ld a, 'f' 
0535					;ld (debug_mark),a 
0535					;pop af 
0535					CALLMONITOR 
0535 cd c6 18			call break_point_state  
0538				endm  
# End of macro CALLMONITOR
0538				endif 
0538			 
0538 cd 55 0c			call storage_clear_page 
053b			 
053b 21 07 fc			ld hl, store_page 
053e 3e 00			ld a, 0 
0540				 
0540 77				ld (hl),a   ; reset file counter 
0541			 
0541 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0544 22 08 fc		 	ld (store_page+1), hl	 
0547			 
0547				; set default label 
0547			 
0547 21 e3 05			ld hl, .defaultbanklabl 
054a 11 0a fc		 	ld de, store_page+3 
054d 01 0f 00			ld bc, 15 
0550 ed b0			ldir 
0552			 
0552				; Append the current bank id 
0552 21 13 fc			ld hl, store_page+3+9 
0555 3a ec fb			ld a, (spi_device_id) 
0558 77				ld (hl), a 
0559			 
0559				; save default page 0 
0559			 
0559 21 00 00			ld hl, 0 
055c 11 07 fc			ld de, store_page 
055f				if DEBUG_STORESE 
055f					DMARK "SB3" 
055f f5				push af  
0560 3a 74 05			ld a, (.dmark)  
0563 32 b4 fe			ld (debug_mark),a  
0566 3a 75 05			ld a, (.dmark+1)  
0569 32 b5 fe			ld (debug_mark+1),a  
056c 3a 76 05			ld a, (.dmark+2)  
056f 32 b6 fe			ld (debug_mark+2),a  
0572 18 03			jr .pastdmark  
0574 ..			.dmark: db "SB3"  
0577 f1			.pastdmark: pop af  
0578			endm  
# End of macro DMARK
0578			;		push af 
0578			;		ld a, 'F' 
0578			;		ld (debug_mark),a 
0578			;		pop af 
0578					CALLMONITOR 
0578 cd c6 18			call break_point_state  
057b				endm  
# End of macro CALLMONITOR
057b				endif 
057b cd 7e 04			call storage_write_block 
057e				if DEBUG_STORESE 
057e					DMARK "SB4" 
057e f5				push af  
057f 3a 93 05			ld a, (.dmark)  
0582 32 b4 fe			ld (debug_mark),a  
0585 3a 94 05			ld a, (.dmark+1)  
0588 32 b5 fe			ld (debug_mark+1),a  
058b 3a 95 05			ld a, (.dmark+2)  
058e 32 b6 fe			ld (debug_mark+2),a  
0591 18 03			jr .pastdmark  
0593 ..			.dmark: db "SB4"  
0596 f1			.pastdmark: pop af  
0597			endm  
# End of macro DMARK
0597			;		push af 
0597			;		ld a, '>' 
0597			;		ld (debug_mark),a 
0597			;		pop af 
0597					CALLMONITOR 
0597 cd c6 18			call break_point_state  
059a				endm  
# End of macro CALLMONITOR
059a				endif 
059a			 
059a 00				nop 
059b 00				nop 
059c 00				nop 
059d			 
059d				; now set 0 in every page to mark as a free block 
059d			 
059d 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
059f 21 40 00			ld hl, STORE_BLOCK_PHY 
05a2			 
05a2 3e 00		.setmark1:   	ld a,0 
05a4 e5					push hl 
05a5 c5					push bc 
05a6 cd 1e 02				call se_writebyte 
05a9 3e 0a			ld a, 10 
05ab cd 77 0c			call aDelayInMS 
05ae 23				inc hl 
05af cd 1e 02				call se_writebyte 
05b2 3e 0a			ld a, 10 
05b4 cd 77 0c			call aDelayInMS 
05b7 2b				dec hl 
05b8 c1					pop bc 
05b9 e1					pop hl 
05ba 3e 40				ld a, STORE_BLOCK_PHY 
05bc cd 49 0f				call addatohl 
05bf 10 e1				djnz .setmark1 
05c1			 
05c1 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05c3 3e 00		.setmark2:   	ld a,0 
05c5 e5					push hl 
05c6 c5					push bc 
05c7 cd 1e 02				call se_writebyte 
05ca 3e 0a			ld a, 10 
05cc cd 77 0c			call aDelayInMS 
05cf 23				inc hl 
05d0 cd 1e 02				call se_writebyte 
05d3 3e 0a			ld a, 10 
05d5 cd 77 0c			call aDelayInMS 
05d8 2b				dec hl 
05d9 c1					pop bc 
05da e1					pop hl 
05db 3e 40				ld a, STORE_BLOCK_PHY 
05dd cd 49 0f				call addatohl 
05e0 10 e1				djnz .setmark2 
05e2			 
05e2					 
05e2			 
05e2			 
05e2 c9				ret 
05e3			 
05e3			 
05e3			 
05e3			 
05e3 .. 00		.defaultbanklabl:   db "BankLabel_",0 
05ee			 
05ee			 
05ee			 
05ee			; Label Bank 
05ee			; ---------- 
05ee			; 
05ee			; With current bank 
05ee			; Read block 0 
05ee			; Set label 
05ee			; Write block 0 
05ee			 
05ee			; label str pointer in hl 
05ee			 
05ee			storage_label:     
05ee			 
05ee				if DEBUG_STORESE 
05ee					DMARK "LBL" 
05ee f5				push af  
05ef 3a 03 06			ld a, (.dmark)  
05f2 32 b4 fe			ld (debug_mark),a  
05f5 3a 04 06			ld a, (.dmark+1)  
05f8 32 b5 fe			ld (debug_mark+1),a  
05fb 3a 05 06			ld a, (.dmark+2)  
05fe 32 b6 fe			ld (debug_mark+2),a  
0601 18 03			jr .pastdmark  
0603 ..			.dmark: db "LBL"  
0606 f1			.pastdmark: pop af  
0607			endm  
# End of macro DMARK
0607					CALLMONITOR 
0607 cd c6 18			call break_point_state  
060a				endm  
# End of macro CALLMONITOR
060a				endif 
060a			 
060a e5				push hl 
060b			 
060b cd ca 04			call storage_get_block_0 
060e			 
060e				; set default label 
060e			 
060e e1				pop hl 
060f			 
060f 11 0a fc		 	ld de, store_page+3 
0612 01 0f 00			ld bc, 15 
0615				if DEBUG_STORESE 
0615					DMARK "LB3" 
0615 f5				push af  
0616 3a 2a 06			ld a, (.dmark)  
0619 32 b4 fe			ld (debug_mark),a  
061c 3a 2b 06			ld a, (.dmark+1)  
061f 32 b5 fe			ld (debug_mark+1),a  
0622 3a 2c 06			ld a, (.dmark+2)  
0625 32 b6 fe			ld (debug_mark+2),a  
0628 18 03			jr .pastdmark  
062a ..			.dmark: db "LB3"  
062d f1			.pastdmark: pop af  
062e			endm  
# End of macro DMARK
062e					CALLMONITOR 
062e cd c6 18			call break_point_state  
0631				endm  
# End of macro CALLMONITOR
0631				endif 
0631 ed b0			ldir 
0633				; save default page 0 
0633			 
0633 21 00 00			ld hl, 0 
0636 11 07 fc			ld de, store_page 
0639				if DEBUG_STORESE 
0639					DMARK "LBW" 
0639 f5				push af  
063a 3a 4e 06			ld a, (.dmark)  
063d 32 b4 fe			ld (debug_mark),a  
0640 3a 4f 06			ld a, (.dmark+1)  
0643 32 b5 fe			ld (debug_mark+1),a  
0646 3a 50 06			ld a, (.dmark+2)  
0649 32 b6 fe			ld (debug_mark+2),a  
064c 18 03			jr .pastdmark  
064e ..			.dmark: db "LBW"  
0651 f1			.pastdmark: pop af  
0652			endm  
# End of macro DMARK
0652					CALLMONITOR 
0652 cd c6 18			call break_point_state  
0655				endm  
# End of macro CALLMONITOR
0655				endif 
0655 cd 7e 04			call storage_write_block 
0658			 
0658 c9				ret 
0659			 
0659			 
0659			 
0659			; Read Block 0 - Config 
0659			; --------------------- 
0659			; 
0659			; With current bank 
0659			; Call presence test 
0659			;    If not present format/init bank  
0659			; Read block 0  
0659			;  
0659			 
0659			 
0659			; Dir 
0659			; --- 
0659			; 
0659			; With current bank 
0659			; Load Block 0 Config 
0659			; Get max file id number 
0659			; For each logical block 
0659			;    Read block read byte 2 
0659			;      if first block of file 
0659			;         Display file name 
0659			;         Display type flags for file 
0659			;        
0659			 
0659			; moving to words as this requires stack control 
0659			 
0659			 
0659			; Delete File 
0659			; ----------- 
0659			; 
0659			; With current bank 
0659			; 
0659			; Load Block 0 Config 
0659			; Get max file id number 
0659			; For each logical block 
0659			;    Read block file id 
0659			;      If first block of file and dont have file id 
0659			;         if file to delete 
0659			;         Save file id 
0659			;         Null file id 
0659			;         Write this block back 
0659			;      If file id is one saved 
0659			;         Null file id 
0659			;         Write this block back 
0659			 
0659			 
0659			.se_done: 
0659 e1				pop hl 
065a c9				ret 
065b			 
065b			storage_erase: 
065b			 
065b				; hl contains the file id 
065b			 
065b 5d				ld e, l 
065c 16 00			ld d, 0 
065e 21 40 00			ld hl, STORE_BLOCK_PHY 
0661					if DEBUG_FORTH_WORDS 
0661						DMARK "ERA" 
0661 f5				push af  
0662 3a 76 06			ld a, (.dmark)  
0665 32 b4 fe			ld (debug_mark),a  
0668 3a 77 06			ld a, (.dmark+1)  
066b 32 b5 fe			ld (debug_mark+1),a  
066e 3a 78 06			ld a, (.dmark+2)  
0671 32 b6 fe			ld (debug_mark+2),a  
0674 18 03			jr .pastdmark  
0676 ..			.dmark: db "ERA"  
0679 f1			.pastdmark: pop af  
067a			endm  
# End of macro DMARK
067a						CALLMONITOR 
067a cd c6 18			call break_point_state  
067d				endm  
# End of macro CALLMONITOR
067d					endif 
067d cd 4c 07			call storage_findnextid 
0680 cd 72 0f			call ishlzero 
0683 c8				ret z 
0684			 
0684 e5				push hl 
0685			 
0685				; TODO check file not found 
0685			 
0685 11 07 fc			ld de, store_page 
0688 cd 19 04			call storage_read_block 
068b			 
068b cd 72 0f			call ishlzero 
068e ca 59 06			jp z,.se_done 
0691			 
0691					if DEBUG_FORTH_WORDS 
0691						DMARK "ER1" 
0691 f5				push af  
0692 3a a6 06			ld a, (.dmark)  
0695 32 b4 fe			ld (debug_mark),a  
0698 3a a7 06			ld a, (.dmark+1)  
069b 32 b5 fe			ld (debug_mark+1),a  
069e 3a a8 06			ld a, (.dmark+2)  
06a1 32 b6 fe			ld (debug_mark+2),a  
06a4 18 03			jr .pastdmark  
06a6 ..			.dmark: db "ER1"  
06a9 f1			.pastdmark: pop af  
06aa			endm  
# End of macro DMARK
06aa						CALLMONITOR 
06aa cd c6 18			call break_point_state  
06ad				endm  
# End of macro CALLMONITOR
06ad					endif 
06ad 3a 07 fc			ld a, (store_page)	; get file id 
06b0 32 fb fb			ld (store_tmpid), a 
06b3			 
06b3 3a 09 fc			ld a, (store_page+2)    ; get count of extends 
06b6 32 fa fb			ld (store_tmpext), a 
06b9			 
06b9				; wipe file header 
06b9			 
06b9 e1				pop hl 
06ba 3e 00			ld a, 0 
06bc 32 07 fc			ld (store_page), a 
06bf 32 08 fc			ld (store_page+1),a 
06c2 11 07 fc			ld de, store_page 
06c5					if DEBUG_FORTH_WORDS 
06c5						DMARK "ER2" 
06c5 f5				push af  
06c6 3a da 06			ld a, (.dmark)  
06c9 32 b4 fe			ld (debug_mark),a  
06cc 3a db 06			ld a, (.dmark+1)  
06cf 32 b5 fe			ld (debug_mark+1),a  
06d2 3a dc 06			ld a, (.dmark+2)  
06d5 32 b6 fe			ld (debug_mark+2),a  
06d8 18 03			jr .pastdmark  
06da ..			.dmark: db "ER2"  
06dd f1			.pastdmark: pop af  
06de			endm  
# End of macro DMARK
06de						CALLMONITOR 
06de cd c6 18			call break_point_state  
06e1				endm  
# End of macro CALLMONITOR
06e1					endif 
06e1 cd 7e 04			call storage_write_block 
06e4			 
06e4			 
06e4				; wipe file extents 
06e4			 
06e4 3a fa fb			ld a, (store_tmpext) 
06e7 47				ld b, a 
06e8			 
06e8			.eraext:	  
06e8 c5				push bc 
06e9			 
06e9 21 40 00			ld hl, STORE_BLOCK_PHY 
06ec 3a fb fb			ld a,(store_tmpid) 
06ef 5f				ld e, a 
06f0 50				ld d, b	 
06f1					if DEBUG_FORTH_WORDS 
06f1						DMARK "ER3" 
06f1 f5				push af  
06f2 3a 06 07			ld a, (.dmark)  
06f5 32 b4 fe			ld (debug_mark),a  
06f8 3a 07 07			ld a, (.dmark+1)  
06fb 32 b5 fe			ld (debug_mark+1),a  
06fe 3a 08 07			ld a, (.dmark+2)  
0701 32 b6 fe			ld (debug_mark+2),a  
0704 18 03			jr .pastdmark  
0706 ..			.dmark: db "ER3"  
0709 f1			.pastdmark: pop af  
070a			endm  
# End of macro DMARK
070a						CALLMONITOR 
070a cd c6 18			call break_point_state  
070d				endm  
# End of macro CALLMONITOR
070d					endif 
070d cd 4c 07			call storage_findnextid 
0710 cd 72 0f			call ishlzero 
0713 ca 59 06			jp z,.se_done 
0716			 
0716 e5				push hl 
0717 11 07 fc			ld de, store_page 
071a cd 19 04			call storage_read_block 
071d			 
071d				; free block	 
071d			 
071d 3e 00			ld a, 0 
071f 32 07 fc			ld (store_page), a 
0722 32 08 fc			ld (store_page+1),a 
0725 11 07 fc			ld de, store_page 
0728 e1				pop hl 
0729					if DEBUG_FORTH_WORDS 
0729						DMARK "ER4" 
0729 f5				push af  
072a 3a 3e 07			ld a, (.dmark)  
072d 32 b4 fe			ld (debug_mark),a  
0730 3a 3f 07			ld a, (.dmark+1)  
0733 32 b5 fe			ld (debug_mark+1),a  
0736 3a 40 07			ld a, (.dmark+2)  
0739 32 b6 fe			ld (debug_mark+2),a  
073c 18 03			jr .pastdmark  
073e ..			.dmark: db "ER4"  
0741 f1			.pastdmark: pop af  
0742			endm  
# End of macro DMARK
0742						CALLMONITOR 
0742 cd c6 18			call break_point_state  
0745				endm  
# End of macro CALLMONITOR
0745					endif 
0745 cd 7e 04			call storage_write_block 
0748			 
0748 c1				pop bc 
0749 10 9d			djnz .eraext 
074b			 
074b c9				ret 
074c			 
074c			 
074c			; Find Free Block 
074c			; --------------- 
074c			; 
074c			; With current bank 
074c			;  
074c			; From given starting logical block 
074c			;    Read block  
074c			;    If no file id 
074c			;         Return block id 
074c			 
074c			 
074c			; hl starting page number 
074c			; hl contains free page number or zero if no pages free 
074c			; e contains the file id to locate 
074c			; d contains the block number 
074c			 
074c			; TODO change to find file id and use zero for free block 
074c			 
074c			storage_findnextid: 
074c			 
074c				; now locate first 0 page to mark as a free block 
074c			 
074c 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
074e			;	ld hl, STORE_BLOCK_PHY 
074e			 
074e					if DEBUG_FORTH_WORDS 
074e					DMARK "FNI" 
074e f5				push af  
074f 3a 63 07			ld a, (.dmark)  
0752 32 b4 fe			ld (debug_mark),a  
0755 3a 64 07			ld a, (.dmark+1)  
0758 32 b5 fe			ld (debug_mark+1),a  
075b 3a 65 07			ld a, (.dmark+2)  
075e 32 b6 fe			ld (debug_mark+2),a  
0761 18 03			jr .pastdmark  
0763 ..			.dmark: db "FNI"  
0766 f1			.pastdmark: pop af  
0767			endm  
# End of macro DMARK
0767						CALLMONITOR 
0767 cd c6 18			call break_point_state  
076a				endm  
# End of macro CALLMONITOR
076a					endif 
076a			.ff1:   	 
076a e5					push hl 
076b c5					push bc 
076c d5					push de 
076d cd c0 02				call se_readbyte 
0770 5f					ld e,a 
0771 23					inc hl 
0772 cd c0 02				call se_readbyte 
0775 57					ld d, a 
0776 e1					pop hl 
0777 e5					push hl 
0778 cd 67 0f				call cmp16 
077b 28 49				jr z, .fffound 
077d			 
077d d1					pop de 
077e c1					pop bc 
077f e1					pop hl 
0780			 
0780					; is found? 
0780					;cp e 
0780					;ret z 
0780			 
0780 3e 40				ld a, STORE_BLOCK_PHY 
0782 cd 49 0f				call addatohl 
0785 10 e3				djnz .ff1 
0787			 
0787 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0789			.ff2:   	 
0789			 
0789 e5					push hl 
078a c5					push bc 
078b d5					push de 
078c cd c0 02				call se_readbyte 
078f 5f					ld e,a 
0790 23					inc hl 
0791 cd c0 02				call se_readbyte 
0794 57					ld d, a 
0795			 
0795 e1					pop hl 
0796 e5					push hl 
0797 cd 67 0f				call cmp16 
079a 28 2a				jr z, .fffound 
079c			 
079c d1					pop de 
079d c1					pop bc 
079e e1					pop hl 
079f					; is found? 
079f					;cp e 
079f					;ret z 
079f			 
079f 3e 40				ld a, STORE_BLOCK_PHY 
07a1 cd 49 0f				call addatohl 
07a4 10 e3				djnz .ff2 
07a6			 
07a6			 
07a6					if DEBUG_FORTH_WORDS 
07a6					DMARK "FN-" 
07a6 f5				push af  
07a7 3a bb 07			ld a, (.dmark)  
07aa 32 b4 fe			ld (debug_mark),a  
07ad 3a bc 07			ld a, (.dmark+1)  
07b0 32 b5 fe			ld (debug_mark+1),a  
07b3 3a bd 07			ld a, (.dmark+2)  
07b6 32 b6 fe			ld (debug_mark+2),a  
07b9 18 03			jr .pastdmark  
07bb ..			.dmark: db "FN-"  
07be f1			.pastdmark: pop af  
07bf			endm  
# End of macro DMARK
07bf					;	push af 
07bf					;	ld a, 'n' 
07bf					;	ld (debug_mark),a 
07bf					;	pop af 
07bf						CALLMONITOR 
07bf cd c6 18			call break_point_state  
07c2				endm  
# End of macro CALLMONITOR
07c2					endif 
07c2				; no free marks! 
07c2 21 00 00				ld hl, 0 
07c5 c9				ret 
07c6			.fffound: 
07c6				 
07c6			 
07c6 d1					pop de 
07c7 c1					pop bc 
07c8 e1					pop hl 
07c9					if DEBUG_FORTH_WORDS 
07c9					DMARK "FNF" 
07c9 f5				push af  
07ca 3a de 07			ld a, (.dmark)  
07cd 32 b4 fe			ld (debug_mark),a  
07d0 3a df 07			ld a, (.dmark+1)  
07d3 32 b5 fe			ld (debug_mark+1),a  
07d6 3a e0 07			ld a, (.dmark+2)  
07d9 32 b6 fe			ld (debug_mark+2),a  
07dc 18 03			jr .pastdmark  
07de ..			.dmark: db "FNF"  
07e1 f1			.pastdmark: pop af  
07e2			endm  
# End of macro DMARK
07e2					;	push af 
07e2					;	ld a, 'n' 
07e2					;	ld (debug_mark),a 
07e2					;	pop af 
07e2						CALLMONITOR 
07e2 cd c6 18			call break_point_state  
07e5				endm  
# End of macro CALLMONITOR
07e5					endif 
07e5 c9				ret 
07e6			 
07e6			 
07e6			 
07e6			; Free Space 
07e6			; ---------- 
07e6			; 
07e6			; With current bank 
07e6			; 
07e6			; Set block count to zero 
07e6			; Starting with first logical block 
07e6			;      Find free block  
07e6			;      If block id given, increment block count 
07e6			; 
07e6			;  
07e6			 
07e6			 
07e6			; hl contains count of free blocks 
07e6			 
07e6			storage_freeblocks: 
07e6			 
07e6				; now locate first 0 page to mark as a free block 
07e6			 
07e6 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07e8 21 40 00			ld hl, STORE_BLOCK_PHY 
07eb 11 00 00			ld de, 0 
07ee			 
07ee			.fb1:   	 
07ee e5					push hl 
07ef c5					push bc 
07f0 d5					push de 
07f1 cd c0 02				call se_readbyte 
07f4 d1					pop de 
07f5 c1					pop bc 
07f6 e1					pop hl 
07f7			 
07f7					; is free? 
07f7 fe 00				cp 0 
07f9 20 01				jr nz, .ff1cont 
07fb 13					inc de 
07fc			 
07fc			.ff1cont: 
07fc			 
07fc			 
07fc 3e 40				ld a, STORE_BLOCK_PHY 
07fe cd 49 0f				call addatohl 
0801 10 eb				djnz .fb1 
0803			 
0803 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0805			.fb2:   	 
0805 e5					push hl 
0806 c5					push bc 
0807 d5					push de 
0808 cd c0 02				call se_readbyte 
080b d1					pop de 
080c c1					pop bc 
080d e1					pop hl 
080e			 
080e					; is free? 
080e fe 00				cp 0 
0810 20 01				jr nz, .ff2cont 
0812 13					inc de 
0813			 
0813			.ff2cont: 
0813			 
0813 3e 40				ld a, STORE_BLOCK_PHY 
0815 cd 49 0f				call addatohl 
0818 10 eb				djnz .fb2 
081a			 
081a eb				ex de, hl 
081b c9				ret 
081c			 
081c			; Get File ID 
081c			; ----------- 
081c			; 
081c			; With current bank 
081c			;  
081c			; Load Block 0 Config 
081c			; Get max file id number 
081c			; For each logical block 
081c			;    Read block file id 
081c			;      If first block of file and dont have file id 
081c			;         if file get id and exit 
081c			 
081c			 
081c			 
081c			 
081c			; Create File 
081c			; ----------- 
081c			; 
081c			; With current bank  
081c			; Load Block 0 Config 
081c			; Get max file id number 
081c			; Increment file id number 
081c			; Save Config 
081c			; Find free block 
081c			; Set buffer with file name and file id 
081c			; Write buffer to free block  
081c			 
081c			 
081c			; hl point to file name 
081c			; hl returns file id 
081c			 
081c			; file format: 
081c			; byte 0 - file id 
081c			; byte 1 - extent number 
081c			; byte 2-> data 
081c			 
081c			; format for extent number 0: 
081c			; 
081c			; byte 0 - file id 
081c			; byte 1 - extent 0 
081c			; byte 2 - extent count 
081c			; byte 3 -> file name and meta data 
081c			 
081c			 
081c			storage_create: 
081c				if DEBUG_STORESE 
081c					DMARK "SCR" 
081c f5				push af  
081d 3a 31 08			ld a, (.dmark)  
0820 32 b4 fe			ld (debug_mark),a  
0823 3a 32 08			ld a, (.dmark+1)  
0826 32 b5 fe			ld (debug_mark+1),a  
0829 3a 33 08			ld a, (.dmark+2)  
082c 32 b6 fe			ld (debug_mark+2),a  
082f 18 03			jr .pastdmark  
0831 ..			.dmark: db "SCR"  
0834 f1			.pastdmark: pop af  
0835			endm  
# End of macro DMARK
0835					CALLMONITOR 
0835 cd c6 18			call break_point_state  
0838				endm  
# End of macro CALLMONITOR
0838				endif 
0838			 
0838 e5				push hl		; save file name pointer 
0839			 
0839 cd ca 04			call storage_get_block_0 
083c			 
083c 3a 07 fc			ld a,(store_page)	; get current file id 
083f 3c				inc a 
0840 32 07 fc			ld (store_page),a 
0843				 
0843 32 fb fb			ld (store_tmpid),a			; save id 
0846			 
0846 21 00 00			ld hl, 0 
0849 11 07 fc			ld de, store_page 
084c				if DEBUG_STORESE 
084c					DMARK "SCw" 
084c f5				push af  
084d 3a 61 08			ld a, (.dmark)  
0850 32 b4 fe			ld (debug_mark),a  
0853 3a 62 08			ld a, (.dmark+1)  
0856 32 b5 fe			ld (debug_mark+1),a  
0859 3a 63 08			ld a, (.dmark+2)  
085c 32 b6 fe			ld (debug_mark+2),a  
085f 18 03			jr .pastdmark  
0861 ..			.dmark: db "SCw"  
0864 f1			.pastdmark: pop af  
0865			endm  
# End of macro DMARK
0865					CALLMONITOR 
0865 cd c6 18			call break_point_state  
0868				endm  
# End of macro CALLMONITOR
0868				endif 
0868 cd 7e 04			call storage_write_block	 ; save update 
086b			 
086b				if DEBUG_STORESE 
086b 11 07 fc				ld de, store_page 
086e					DMARK "SCC" 
086e f5				push af  
086f 3a 83 08			ld a, (.dmark)  
0872 32 b4 fe			ld (debug_mark),a  
0875 3a 84 08			ld a, (.dmark+1)  
0878 32 b5 fe			ld (debug_mark+1),a  
087b 3a 85 08			ld a, (.dmark+2)  
087e 32 b6 fe			ld (debug_mark+2),a  
0881 18 03			jr .pastdmark  
0883 ..			.dmark: db "SCC"  
0886 f1			.pastdmark: pop af  
0887			endm  
# End of macro DMARK
0887					CALLMONITOR 
0887 cd c6 18			call break_point_state  
088a				endm  
# End of macro CALLMONITOR
088a				endif 
088a				;  
088a				 
088a 21 40 00			ld hl, STORE_BLOCK_PHY 
088d 11 00 00			ld de, 0 
0890 cd 4c 07			call storage_findnextid 
0893			 
0893 22 f2 fb			ld (store_tmppageid), hl    ; save page to use  
0896			 
0896				; TODO detect 0 = no spare blocks 
0896			 
0896				; hl now contains the free page to use for the file header page 
0896			 
0896				if DEBUG_STORESE 
0896				DMARK "SCF" 
0896 f5				push af  
0897 3a ab 08			ld a, (.dmark)  
089a 32 b4 fe			ld (debug_mark),a  
089d 3a ac 08			ld a, (.dmark+1)  
08a0 32 b5 fe			ld (debug_mark+1),a  
08a3 3a ad 08			ld a, (.dmark+2)  
08a6 32 b6 fe			ld (debug_mark+2),a  
08a9 18 03			jr .pastdmark  
08ab ..			.dmark: db "SCF"  
08ae f1			.pastdmark: pop af  
08af			endm  
# End of macro DMARK
08af					CALLMONITOR 
08af cd c6 18			call break_point_state  
08b2				endm  
# End of macro CALLMONITOR
08b2				endif 
08b2			 
08b2 22 f2 fb			ld (store_tmppageid), hl 
08b5				 
08b5 3a fb fb			ld a,(store_tmpid)    ; get file id 
08b8			;	ld a, (store_filecache)			; save to cache 
08b8			 
08b8 32 07 fc			ld (store_page),a    ; set page id 
08bb 3e 00			ld a, 0			 ; extent 0 is file header 
08bd 32 08 fc			ld (store_page+1), a   ; set file extent 
08c0			 
08c0 32 09 fc			ld (store_page+2), a   ; extent count for the file 
08c3			 
08c3			;	inc hl 		; init block 0 of file 
08c3			;	inc hl   		; skip file and extent id 
08c3			 ;       ld a, 0 
08c3			;	ld (hl),a 
08c3			;	ld a, (store_filecache+1)  	; save to cache 
08c3			 
08c3			;	inc hl    ; file name 
08c3				 
08c3				 
08c3 11 0a fc			ld de, store_page+3    ; get buffer for term string to use as file name 
08c6				if DEBUG_STORESE 
08c6					DMARK "SCc" 
08c6 f5				push af  
08c7 3a db 08			ld a, (.dmark)  
08ca 32 b4 fe			ld (debug_mark),a  
08cd 3a dc 08			ld a, (.dmark+1)  
08d0 32 b5 fe			ld (debug_mark+1),a  
08d3 3a dd 08			ld a, (.dmark+2)  
08d6 32 b6 fe			ld (debug_mark+2),a  
08d9 18 03			jr .pastdmark  
08db ..			.dmark: db "SCc"  
08de f1			.pastdmark: pop af  
08df			endm  
# End of macro DMARK
08df					CALLMONITOR 
08df cd c6 18			call break_point_state  
08e2				endm  
# End of macro CALLMONITOR
08e2				endif 
08e2 e1				pop hl    ; get zero term string 
08e3 e5				push hl 
08e4 3e 00			ld a, 0 
08e6 cd b2 13			call strlent 
08e9 23				inc hl   ; cover zero term 
08ea 06 00			ld b,0 
08ec 4d				ld c,l 
08ed e1				pop hl 
08ee				;ex de, hl 
08ee				if DEBUG_STORESE 
08ee					DMARK "SCa" 
08ee f5				push af  
08ef 3a 03 09			ld a, (.dmark)  
08f2 32 b4 fe			ld (debug_mark),a  
08f5 3a 04 09			ld a, (.dmark+1)  
08f8 32 b5 fe			ld (debug_mark+1),a  
08fb 3a 05 09			ld a, (.dmark+2)  
08fe 32 b6 fe			ld (debug_mark+2),a  
0901 18 03			jr .pastdmark  
0903 ..			.dmark: db "SCa"  
0906 f1			.pastdmark: pop af  
0907			endm  
# End of macro DMARK
0907					;push af 
0907					;ld a, 'a' 
0907					;ld (debug_mark),a 
0907					;pop af 
0907					CALLMONITOR 
0907 cd c6 18			call break_point_state  
090a				endm  
# End of macro CALLMONITOR
090a				endif 
090a ed b0			ldir    ; copy zero term string 
090c				if DEBUG_STORESE 
090c					DMARK "SCA" 
090c f5				push af  
090d 3a 21 09			ld a, (.dmark)  
0910 32 b4 fe			ld (debug_mark),a  
0913 3a 22 09			ld a, (.dmark+1)  
0916 32 b5 fe			ld (debug_mark+1),a  
0919 3a 23 09			ld a, (.dmark+2)  
091c 32 b6 fe			ld (debug_mark+2),a  
091f 18 03			jr .pastdmark  
0921 ..			.dmark: db "SCA"  
0924 f1			.pastdmark: pop af  
0925			endm  
# End of macro DMARK
0925					CALLMONITOR 
0925 cd c6 18			call break_point_state  
0928				endm  
# End of macro CALLMONITOR
0928				endif 
0928			 
0928				; write file header page 
0928			 
0928 2a f2 fb			ld hl,(store_tmppageid) 
092b 11 07 fc			ld de, store_page 
092e				if DEBUG_STORESE 
092e					DMARK "SCb" 
092e f5				push af  
092f 3a 43 09			ld a, (.dmark)  
0932 32 b4 fe			ld (debug_mark),a  
0935 3a 44 09			ld a, (.dmark+1)  
0938 32 b5 fe			ld (debug_mark+1),a  
093b 3a 45 09			ld a, (.dmark+2)  
093e 32 b6 fe			ld (debug_mark+2),a  
0941 18 03			jr .pastdmark  
0943 ..			.dmark: db "SCb"  
0946 f1			.pastdmark: pop af  
0947			endm  
# End of macro DMARK
0947					;push af 
0947					;ld a, 'b' 
0947					;ld (debug_mark),a 
0947					;pop af 
0947					CALLMONITOR 
0947 cd c6 18			call break_point_state  
094a				endm  
# End of macro CALLMONITOR
094a				endif 
094a cd 7e 04			call storage_write_block 
094d			 
094d 3a fb fb			ld a, (store_tmpid) 
0950 6f				ld l, a 
0951 26 00			ld h,0 
0953				if DEBUG_STORESE 
0953					DMARK "SCz" 
0953 f5				push af  
0954 3a 68 09			ld a, (.dmark)  
0957 32 b4 fe			ld (debug_mark),a  
095a 3a 69 09			ld a, (.dmark+1)  
095d 32 b5 fe			ld (debug_mark+1),a  
0960 3a 6a 09			ld a, (.dmark+2)  
0963 32 b6 fe			ld (debug_mark+2),a  
0966 18 03			jr .pastdmark  
0968 ..			.dmark: db "SCz"  
096b f1			.pastdmark: pop af  
096c			endm  
# End of macro DMARK
096c					CALLMONITOR 
096c cd c6 18			call break_point_state  
096f				endm  
# End of macro CALLMONITOR
096f				endif 
096f c9				ret 
0970				 
0970			 
0970			 
0970			; 
0970			; Read File 
0970			; 
0970			; h - file id to locate 
0970			; l - extent to locate 
0970			; de - pointer to string to read into 
0970			; 
0970			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
0970			 
0970			.sr_fail: 
0970 d1				pop de 
0971 c9				ret 
0972			 
0972			storage_read: 
0972			 
0972			 
0972 d5				push de 
0973			 
0973			; TODO BUG the above push is it popped before the RET Z? 
0973			 
0973			; TODO how to handle multiple part blocks 
0973			 
0973				; locate file extent to read 
0973			 
0973 5c				ld e, h 
0974 55				ld d, l 
0975			 
0975			.srext: 
0975 22 05 fc			ld (store_readptr), hl     ; save the current extent to load 
0978 ed 53 03 fc		ld (store_readbuf), de     ; save the current buffer to load in to 
097c			 
097c 21 40 00			ld hl, STORE_BLOCK_PHY 
097f				if DEBUG_STORESE 
097f					DMARK "sre" 
097f f5				push af  
0980 3a 94 09			ld a, (.dmark)  
0983 32 b4 fe			ld (debug_mark),a  
0986 3a 95 09			ld a, (.dmark+1)  
0989 32 b5 fe			ld (debug_mark+1),a  
098c 3a 96 09			ld a, (.dmark+2)  
098f 32 b6 fe			ld (debug_mark+2),a  
0992 18 03			jr .pastdmark  
0994 ..			.dmark: db "sre"  
0997 f1			.pastdmark: pop af  
0998			endm  
# End of macro DMARK
0998					CALLMONITOR 
0998 cd c6 18			call break_point_state  
099b				endm  
# End of macro CALLMONITOR
099b				endif 
099b cd 4c 07			call storage_findnextid 
099e			 
099e				if DEBUG_STORESE 
099e					DMARK "srf" 
099e f5				push af  
099f 3a b3 09			ld a, (.dmark)  
09a2 32 b4 fe			ld (debug_mark),a  
09a5 3a b4 09			ld a, (.dmark+1)  
09a8 32 b5 fe			ld (debug_mark+1),a  
09ab 3a b5 09			ld a, (.dmark+2)  
09ae 32 b6 fe			ld (debug_mark+2),a  
09b1 18 03			jr .pastdmark  
09b3 ..			.dmark: db "srf"  
09b6 f1			.pastdmark: pop af  
09b7			endm  
# End of macro DMARK
09b7					CALLMONITOR 
09b7 cd c6 18			call break_point_state  
09ba				endm  
# End of macro CALLMONITOR
09ba				endif 
09ba cd 72 0f			call ishlzero 
09bd			;	ld a, l 
09bd			;	add h 
09bd			;	cp 0 
09bd 28 b1			jr z,.sr_fail			; block not found so EOF 
09bf			 
09bf				; save current address for use by higher level words etc 
09bf			 
09bf 22 f8 fb			ld (store_openaddr),hl 
09c2			 
09c2			 
09c2				; hl contains page number to load 
09c2 d1				pop de   ; get storage 
09c3 ed 53 03 fc		ld (store_readbuf), de     ; current buffer to load in to 
09c7 d5				push de 
09c8				if DEBUG_STORESE 
09c8					DMARK "srg" 
09c8 f5				push af  
09c9 3a dd 09			ld a, (.dmark)  
09cc 32 b4 fe			ld (debug_mark),a  
09cf 3a de 09			ld a, (.dmark+1)  
09d2 32 b5 fe			ld (debug_mark+1),a  
09d5 3a df 09			ld a, (.dmark+2)  
09d8 32 b6 fe			ld (debug_mark+2),a  
09db 18 03			jr .pastdmark  
09dd ..			.dmark: db "srg"  
09e0 f1			.pastdmark: pop af  
09e1			endm  
# End of macro DMARK
09e1					CALLMONITOR 
09e1 cd c6 18			call break_point_state  
09e4				endm  
# End of macro CALLMONITOR
09e4				endif 
09e4 cd 19 04			call storage_read_block 
09e7			 
09e7				; if this a continuation read??? 
09e7			 
09e7 2a 03 fc			ld hl, (store_readbuf)     ; current buffer to load in to 
09ea			 
09ea 3e 3f			ld a, STORE_BLOCK_PHY-1 
09ec cd 49 0f			call addatohl 
09ef 7e				ld a,(hl) 
09f0 fe 00			cp 0 
09f2 28 02			jr z, .markiscont 
09f4 3e ff			ld a, 255 
09f6			 
09f6			.markiscont: 
09f6 32 fa fb			ld (store_readcont), a 
09f9			 
09f9				if DEBUG_STORESE 
09f9					DMARK "srC" 
09f9 f5				push af  
09fa 3a 0e 0a			ld a, (.dmark)  
09fd 32 b4 fe			ld (debug_mark),a  
0a00 3a 0f 0a			ld a, (.dmark+1)  
0a03 32 b5 fe			ld (debug_mark+1),a  
0a06 3a 10 0a			ld a, (.dmark+2)  
0a09 32 b6 fe			ld (debug_mark+2),a  
0a0c 18 03			jr .pastdmark  
0a0e ..			.dmark: db "srC"  
0a11 f1			.pastdmark: pop af  
0a12			endm  
# End of macro DMARK
0a12					CALLMONITOR 
0a12 cd c6 18			call break_point_state  
0a15				endm  
# End of macro CALLMONITOR
0a15				endif 
0a15				; only short reads enabled 
0a15			 
0a15 3a 02 fc			ld a, (store_longread) 
0a18 fe 00			cp 0 
0a1a ca e7 0a			jp z, .readdone 
0a1d			 
0a1d			; TODO if block has no zeros then need to read next block  
0a1d			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
0a1d			; check last byte of physical block. 
0a1d			; if not zero then the next block needs to be loaded 
0a1d			 
0a1d			 
0a1d 2a 03 fc			ld hl, (store_readbuf)     ; current buffer to load in to 
0a20			 
0a20 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a22 cd 49 0f			call addatohl 
0a25				;dec hl 
0a25 7e				ld a,(hl) 
0a26				if DEBUG_STORESE 
0a26					DMARK "sr?" 
0a26 f5				push af  
0a27 3a 3b 0a			ld a, (.dmark)  
0a2a 32 b4 fe			ld (debug_mark),a  
0a2d 3a 3c 0a			ld a, (.dmark+1)  
0a30 32 b5 fe			ld (debug_mark+1),a  
0a33 3a 3d 0a			ld a, (.dmark+2)  
0a36 32 b6 fe			ld (debug_mark+2),a  
0a39 18 03			jr .pastdmark  
0a3b ..			.dmark: db "sr?"  
0a3e f1			.pastdmark: pop af  
0a3f			endm  
# End of macro DMARK
0a3f					CALLMONITOR 
0a3f cd c6 18			call break_point_state  
0a42				endm  
# End of macro CALLMONITOR
0a42				endif 
0a42 fe 00			cp 0 
0a44 ca e7 0a			jp z, .readdone 
0a47			 
0a47				; last byte is not zero so there is more in the next extent. Load it on the end.	 
0a47			 
0a47 23				inc hl 
0a48			 
0a48 22 03 fc			ld (store_readbuf), hl     ; save the current buffer to load in to 
0a4b			 
0a4b ed 5b 05 fc		ld de, (store_readptr)     ; save the current extent to load 
0a4f			 
0a4f eb				ex de, hl 
0a50			 
0a50				; next ext 
0a50			 
0a50 23				inc hl 
0a51 22 05 fc			ld  (store_readptr), hl     ; save the current extent to load 
0a54			 
0a54				if DEBUG_STORESE 
0a54					DMARK "sF2" 
0a54 f5				push af  
0a55 3a 69 0a			ld a, (.dmark)  
0a58 32 b4 fe			ld (debug_mark),a  
0a5b 3a 6a 0a			ld a, (.dmark+1)  
0a5e 32 b5 fe			ld (debug_mark+1),a  
0a61 3a 6b 0a			ld a, (.dmark+2)  
0a64 32 b6 fe			ld (debug_mark+2),a  
0a67 18 03			jr .pastdmark  
0a69 ..			.dmark: db "sF2"  
0a6c f1			.pastdmark: pop af  
0a6d			endm  
# End of macro DMARK
0a6d					CALLMONITOR 
0a6d cd c6 18			call break_point_state  
0a70				endm  
# End of macro CALLMONITOR
0a70				endif 
0a70			 
0a70				; get and load block 
0a70			 
0a70 cd 4c 07			call storage_findnextid 
0a73			 
0a73				if DEBUG_STORESE 
0a73					DMARK "sf2" 
0a73 f5				push af  
0a74 3a 88 0a			ld a, (.dmark)  
0a77 32 b4 fe			ld (debug_mark),a  
0a7a 3a 89 0a			ld a, (.dmark+1)  
0a7d 32 b5 fe			ld (debug_mark+1),a  
0a80 3a 8a 0a			ld a, (.dmark+2)  
0a83 32 b6 fe			ld (debug_mark+2),a  
0a86 18 03			jr .pastdmark  
0a88 ..			.dmark: db "sf2"  
0a8b f1			.pastdmark: pop af  
0a8c			endm  
# End of macro DMARK
0a8c					CALLMONITOR 
0a8c cd c6 18			call break_point_state  
0a8f				endm  
# End of macro CALLMONITOR
0a8f				endif 
0a8f cd 72 0f			call ishlzero 
0a92			;	ld a, l 
0a92			;	add h 
0a92			;	cp 0 
0a92 ca 70 09			jp z,.sr_fail			; block not found so EOF 
0a95				 
0a95				; save current address for use by higher level words etc 
0a95			 
0a95 22 f8 fb			ld (store_openaddr),hl 
0a98			 
0a98 cd 19 04			call storage_read_block 
0a9b			 
0a9b				; on a continuation block, we now have the file id and ext in the middle of the block 
0a9b				; we need to pull everything back  
0a9b			 
0a9b ed 5b 03 fc		ld de, (store_readbuf)     ; current buffer to nudge into 
0a9f 2a 03 fc			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0aa2 23				inc hl 
0aa3 23				inc hl     ; skip id and ext 
0aa4 01 40 00			ld bc, STORE_BLOCK_PHY 
0aa7				if DEBUG_STORESE 
0aa7					DMARK "SR<" 
0aa7 f5				push af  
0aa8 3a bc 0a			ld a, (.dmark)  
0aab 32 b4 fe			ld (debug_mark),a  
0aae 3a bd 0a			ld a, (.dmark+1)  
0ab1 32 b5 fe			ld (debug_mark+1),a  
0ab4 3a be 0a			ld a, (.dmark+2)  
0ab7 32 b6 fe			ld (debug_mark+2),a  
0aba 18 03			jr .pastdmark  
0abc ..			.dmark: db "SR<"  
0abf f1			.pastdmark: pop af  
0ac0			endm  
# End of macro DMARK
0ac0					CALLMONITOR 
0ac0 cd c6 18			call break_point_state  
0ac3				endm  
# End of macro CALLMONITOR
0ac3				endif 
0ac3 ed b0			ldir     ; copy data 
0ac5			 
0ac5				; move the pointer back and pretend we have a full buffer for next recheck 
0ac5			 
0ac5 1b				dec de 
0ac6 1b				dec de 
0ac7			 
0ac7			; TODO do pop below now short circuit loop????? 
0ac7 c1				pop bc     ; get rid of spare de on stack 
0ac8				if DEBUG_STORESE 
0ac8					DMARK "SR>" 
0ac8 f5				push af  
0ac9 3a dd 0a			ld a, (.dmark)  
0acc 32 b4 fe			ld (debug_mark),a  
0acf 3a de 0a			ld a, (.dmark+1)  
0ad2 32 b5 fe			ld (debug_mark+1),a  
0ad5 3a df 0a			ld a, (.dmark+2)  
0ad8 32 b6 fe			ld (debug_mark+2),a  
0adb 18 03			jr .pastdmark  
0add ..			.dmark: db "SR>"  
0ae0 f1			.pastdmark: pop af  
0ae1			endm  
# End of macro DMARK
0ae1					CALLMONITOR 
0ae1 cd c6 18			call break_point_state  
0ae4				endm  
# End of macro CALLMONITOR
0ae4				endif 
0ae4 c3 75 09			jp .srext 
0ae7			 
0ae7			 
0ae7			 
0ae7			 
0ae7			 
0ae7			.readdone:		 
0ae7 e1				pop hl 		 ; return start of data to show as not EOF 
0ae8 23				inc hl   ; past file id 
0ae9 23				inc hl   ; past ext 
0aea				if DEBUG_STORESE 
0aea					DMARK "SRe" 
0aea f5				push af  
0aeb 3a ff 0a			ld a, (.dmark)  
0aee 32 b4 fe			ld (debug_mark),a  
0af1 3a 00 0b			ld a, (.dmark+1)  
0af4 32 b5 fe			ld (debug_mark+1),a  
0af7 3a 01 0b			ld a, (.dmark+2)  
0afa 32 b6 fe			ld (debug_mark+2),a  
0afd 18 03			jr .pastdmark  
0aff ..			.dmark: db "SRe"  
0b02 f1			.pastdmark: pop af  
0b03			endm  
# End of macro DMARK
0b03					CALLMONITOR 
0b03 cd c6 18			call break_point_state  
0b06				endm  
# End of macro CALLMONITOR
0b06				endif 
0b06 c9					ret 
0b07			 
0b07			 
0b07			 
0b07			; 
0b07			; Append File 
0b07			; 
0b07			; hl - file id to locate 
0b07			; de - pointer to (multi block) string to write 
0b07			 
0b07			.sa_notfound: 
0b07 d1				pop de 
0b08 c9				ret 
0b09			 
0b09			 
0b09			storage_append: 
0b09				; hl -  file id to append to 
0b09				; de - string to append 
0b09			 
0b09 d5				push de 
0b0a				 
0b0a				if DEBUG_STORESE 
0b0a					DMARK "AP1" 
0b0a f5				push af  
0b0b 3a 1f 0b			ld a, (.dmark)  
0b0e 32 b4 fe			ld (debug_mark),a  
0b11 3a 20 0b			ld a, (.dmark+1)  
0b14 32 b5 fe			ld (debug_mark+1),a  
0b17 3a 21 0b			ld a, (.dmark+2)  
0b1a 32 b6 fe			ld (debug_mark+2),a  
0b1d 18 03			jr .pastdmark  
0b1f ..			.dmark: db "AP1"  
0b22 f1			.pastdmark: pop af  
0b23			endm  
# End of macro DMARK
0b23					CALLMONITOR 
0b23 cd c6 18			call break_point_state  
0b26				endm  
# End of macro CALLMONITOR
0b26				endif 
0b26			 
0b26 7d				ld a, l 
0b27 32 fb fb			ld (store_tmpid), a 
0b2a			 
0b2a				; get file header  
0b2a			 
0b2a 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
0b2c 3a fb fb			ld a, (store_tmpid) 
0b2f 5f				ld e, a 
0b30			 
0b30 21 40 00				ld hl, STORE_BLOCK_PHY 
0b33 cd 4c 07				call storage_findnextid 
0b36			 
0b36 cd 72 0f			call ishlzero 
0b39 28 cc			jr z, .sa_notfound 
0b3b			 
0b3b 22 f2 fb			ld (store_tmppageid), hl 
0b3e			 
0b3e				; TODO handle file id not found 
0b3e			 
0b3e				if DEBUG_STORESE 
0b3e					DMARK "AP2" 
0b3e f5				push af  
0b3f 3a 53 0b			ld a, (.dmark)  
0b42 32 b4 fe			ld (debug_mark),a  
0b45 3a 54 0b			ld a, (.dmark+1)  
0b48 32 b5 fe			ld (debug_mark+1),a  
0b4b 3a 55 0b			ld a, (.dmark+2)  
0b4e 32 b6 fe			ld (debug_mark+2),a  
0b51 18 03			jr .pastdmark  
0b53 ..			.dmark: db "AP2"  
0b56 f1			.pastdmark: pop af  
0b57			endm  
# End of macro DMARK
0b57					CALLMONITOR 
0b57 cd c6 18			call break_point_state  
0b5a				endm  
# End of macro CALLMONITOR
0b5a				endif 
0b5a			 
0b5a				; update file extent count 
0b5a			 
0b5a 11 07 fc			ld de, store_page 
0b5d			 
0b5d cd 19 04			call storage_read_block 
0b60			 
0b60				if DEBUG_STORESE 
0b60					DMARK "AP3" 
0b60 f5				push af  
0b61 3a 75 0b			ld a, (.dmark)  
0b64 32 b4 fe			ld (debug_mark),a  
0b67 3a 76 0b			ld a, (.dmark+1)  
0b6a 32 b5 fe			ld (debug_mark+1),a  
0b6d 3a 77 0b			ld a, (.dmark+2)  
0b70 32 b6 fe			ld (debug_mark+2),a  
0b73 18 03			jr .pastdmark  
0b75 ..			.dmark: db "AP3"  
0b78 f1			.pastdmark: pop af  
0b79			endm  
# End of macro DMARK
0b79					CALLMONITOR 
0b79 cd c6 18			call break_point_state  
0b7c				endm  
# End of macro CALLMONITOR
0b7c				endif 
0b7c			;	ld (store_tmppageid), hl 
0b7c			 
0b7c 3a 09 fc			ld a, (store_page+2) 
0b7f 3c				inc a 
0b80 32 09 fc			ld (store_page+2), a 
0b83 32 fa fb			ld (store_tmpext), a 
0b86				 
0b86				if DEBUG_STORESE 
0b86					DMARK "AP3" 
0b86 f5				push af  
0b87 3a 9b 0b			ld a, (.dmark)  
0b8a 32 b4 fe			ld (debug_mark),a  
0b8d 3a 9c 0b			ld a, (.dmark+1)  
0b90 32 b5 fe			ld (debug_mark+1),a  
0b93 3a 9d 0b			ld a, (.dmark+2)  
0b96 32 b6 fe			ld (debug_mark+2),a  
0b99 18 03			jr .pastdmark  
0b9b ..			.dmark: db "AP3"  
0b9e f1			.pastdmark: pop af  
0b9f			endm  
# End of macro DMARK
0b9f					CALLMONITOR 
0b9f cd c6 18			call break_point_state  
0ba2				endm  
# End of macro CALLMONITOR
0ba2				endif 
0ba2 2a f2 fb			ld hl, (store_tmppageid) 
0ba5 11 07 fc			ld de, store_page 
0ba8 cd 7e 04			call storage_write_block 
0bab			 
0bab				; find free block 
0bab			 
0bab 11 00 00			ld de, 0			 ; file extent to locate 
0bae			 
0bae 21 40 00				ld hl, STORE_BLOCK_PHY 
0bb1 cd 4c 07				call storage_findnextid 
0bb4 cd 72 0f			call ishlzero 
0bb7 ca 07 0b			jp z, .sa_notfound 
0bba			 
0bba					; TODO handle no space left 
0bba					 
0bba 22 f2 fb				ld (store_tmppageid), hl 
0bbd			 
0bbd				if DEBUG_STORESE 
0bbd					DMARK "AP4" 
0bbd f5				push af  
0bbe 3a d2 0b			ld a, (.dmark)  
0bc1 32 b4 fe			ld (debug_mark),a  
0bc4 3a d3 0b			ld a, (.dmark+1)  
0bc7 32 b5 fe			ld (debug_mark+1),a  
0bca 3a d4 0b			ld a, (.dmark+2)  
0bcd 32 b6 fe			ld (debug_mark+2),a  
0bd0 18 03			jr .pastdmark  
0bd2 ..			.dmark: db "AP4"  
0bd5 f1			.pastdmark: pop af  
0bd6			endm  
# End of macro DMARK
0bd6					CALLMONITOR 
0bd6 cd c6 18			call break_point_state  
0bd9				endm  
# End of macro CALLMONITOR
0bd9				endif 
0bd9					; init the buffer with zeros so we can id if the buffer is full or not 
0bd9			 
0bd9 e5					push hl 
0bda c5					push bc 
0bdb			 
0bdb 21 07 fc				ld hl, store_page 
0bde 06 40				ld b, STORE_BLOCK_PHY 
0be0 3e 00				ld a, 0 
0be2 77			.zeroblock:	ld (hl), a 
0be3 23					inc hl 
0be4 10 fc				djnz .zeroblock 
0be6			 
0be6 c1					pop bc 
0be7 e1					pop hl 
0be8			 
0be8					; construct block 
0be8			 
0be8 3a fb fb				ld a, (store_tmpid) 
0beb 32 07 fc				ld (store_page), a   ; file id 
0bee 3a fa fb				ld a, (store_tmpext)   ; extent for this block 
0bf1 32 08 fc				ld (store_page+1), a 
0bf4			 
0bf4 e1					pop hl    ; get string to write 
0bf5 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0bf7 11 09 fc				ld de, store_page+2 
0bfa			 
0bfa				if DEBUG_STORESE 
0bfa					DMARK "AP5" 
0bfa f5				push af  
0bfb 3a 0f 0c			ld a, (.dmark)  
0bfe 32 b4 fe			ld (debug_mark),a  
0c01 3a 10 0c			ld a, (.dmark+1)  
0c04 32 b5 fe			ld (debug_mark+1),a  
0c07 3a 11 0c			ld a, (.dmark+2)  
0c0a 32 b6 fe			ld (debug_mark+2),a  
0c0d 18 03			jr .pastdmark  
0c0f ..			.dmark: db "AP5"  
0c12 f1			.pastdmark: pop af  
0c13			endm  
# End of macro DMARK
0c13					CALLMONITOR 
0c13 cd c6 18			call break_point_state  
0c16				endm  
# End of macro CALLMONITOR
0c16				endif 
0c16			 
0c16			 
0c16			 
0c16					; fill buffer with data until end of string or full block 
0c16			 
0c16 7e			.appd:		ld a, (hl) 
0c17 12					ld (de), a 
0c18 fe 00				cp 0 
0c1a 28 04				jr z, .appdone 
0c1c 23					inc hl 
0c1d 13					inc de 
0c1e 10 f6				djnz .appd 
0c20			 
0c20 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0c21 f5					push af   		; save last byte dumped 
0c22			 
0c22			 
0c22 2a f2 fb			ld hl, (store_tmppageid) 
0c25 11 07 fc			ld de, store_page 
0c28				if DEBUG_STORESE 
0c28					DMARK "AP6" 
0c28 f5				push af  
0c29 3a 3d 0c			ld a, (.dmark)  
0c2c 32 b4 fe			ld (debug_mark),a  
0c2f 3a 3e 0c			ld a, (.dmark+1)  
0c32 32 b5 fe			ld (debug_mark+1),a  
0c35 3a 3f 0c			ld a, (.dmark+2)  
0c38 32 b6 fe			ld (debug_mark+2),a  
0c3b 18 03			jr .pastdmark  
0c3d ..			.dmark: db "AP6"  
0c40 f1			.pastdmark: pop af  
0c41			endm  
# End of macro DMARK
0c41					CALLMONITOR 
0c41 cd c6 18			call break_point_state  
0c44				endm  
# End of macro CALLMONITOR
0c44				endif 
0c44 cd 7e 04				call storage_write_block 
0c47			 
0c47			 
0c47				; was that a full block of data written? 
0c47				; any more to write out? 
0c47			 
0c47				; if yes then set vars and jump to start of function again 
0c47			 
0c47 f1					pop af 
0c48 d1					pop de 
0c49			 
0c49 fe 00				cp 0		 ; no, string was fully written 
0c4b c8					ret z 
0c4c			 
0c4c					; setup vars for next cycle 
0c4c			 
0c4c 3a fb fb				ld a, (store_tmpid) 
0c4f 6f					ld l, a 
0c50 26 00				ld h, 0 
0c52			 
0c52 c3 09 0b			 	jp storage_append	 ; yes, need to write out some more 
0c55			 
0c55			 
0c55			 
0c55			 
0c55			 
0c55			 
0c55			 
0c55			if DEBUG_STORECF 
0c55			storageput:	 
0c55					ret 
0c55			storageread: 
0c55					ld hl, store_page 
0c55					ld b, 200 
0c55					ld a,0 
0c55			.src:		ld (hl),a 
0c55					inc hl 
0c55					djnz .src 
0c55					 
0c55			 
0c55					ld de, 0 
0c55					ld bc, 1 
0c55					ld hl, store_page 
0c55					call cfRead 
0c55			 
0c55				call cfGetError 
0c55				ld hl,scratch 
0c55				call hexout 
0c55				ld hl, scratch+2 
0c55				ld a, 0 
0c55				ld (hl),a 
0c55				ld de, scratch 
0c55				ld a,display_row_1 
0c55				call str_at_display 
0c55				call update_display 
0c55			 
0c55					ld hl, store_page 
0c55					ld (os_cur_ptr),hl 
0c55			 
0c55					ret 
0c55			endif 
0c55			 
0c55			 
0c55			; Clear out the main buffer store (used to remove junk before writing a new block) 
0c55			 
0c55			storage_clear_page: 
0c55 e5				push hl 
0c56 d5				push de 
0c57 c5				push bc 
0c58 21 07 fc			ld hl, store_page 
0c5b 3e 00			ld a, 0 
0c5d 77				ld (hl), a 
0c5e			 
0c5e 11 08 fc			ld de, store_page+1 
0c61 01 18 01			ld bc, STORE_BLOCK_LOG 
0c64			 
0c64 ed b0			ldir 
0c66				 
0c66 c1				pop bc 
0c67 d1				pop de 
0c68 e1				pop hl 
0c69 c9				ret 
0c6a			 
0c6a			; eof 
# End of file firmware_storage.asm
0c6a			  
0c6a			; support routines for above hardware abstraction layer  
0c6a			  
0c6a			include "firmware_general.asm"        ; general support functions  
0c6a			 
0c6a			; word look up 
0c6a			 
0c6a			; in 
0c6a			; a is the index 
0c6a			; hl is pointer start of array 
0c6a			; 
0c6a			; returns 
0c6a			; hl to the word 
0c6a			; 
0c6a			 
0c6a			table_lookup:  
0c6a d5					push de 
0c6b eb					ex de, hl 
0c6c			 
0c6c 6f					ld l, a 
0c6d 26 00				ld h, 0 
0c6f 29					add hl, hl 
0c70 19					add hl, de 
0c71 7e					ld a, (hl) 
0c72 23					inc hl 
0c73 66					ld h,(hl) 
0c74 6f					ld l, a 
0c75			 
0c75 d1					pop de 
0c76 c9					ret 
0c77			 
0c77			; Delay loops 
0c77			 
0c77			 
0c77			 
0c77			aDelayInMS: 
0c77 c5				push bc 
0c78 47				ld b,a 
0c79			msdelay: 
0c79 c5				push bc 
0c7a				 
0c7a			 
0c7a 01 41 00			ld bc,041h 
0c7d cd 95 0c			call delayloop 
0c80 c1				pop bc 
0c81 05				dec b 
0c82 20 f5			jr nz,msdelay 
0c84			 
0c84			;if CPU_CLOCK_8MHZ 
0c84			;msdelay8: 
0c84			;	push bc 
0c84			;	 
0c84			; 
0c84			;	ld bc,041h 
0c84			;	call delayloop 
0c84			;	pop bc 
0c84			;	dec b 
0c84			;	jr nz,msdelay8 
0c84			;endif 
0c84			 
0c84			 
0c84 c1				pop bc 
0c85 c9				ret 
0c86			 
0c86			 
0c86			delay250ms: 
0c86				;push de 
0c86 01 00 40			ld bc, 04000h 
0c89 c3 95 0c			jp delayloop 
0c8c			delay500ms: 
0c8c				;push de 
0c8c 01 00 80			ld bc, 08000h 
0c8f c3 95 0c			jp delayloop 
0c92			delay1s: 
0c92				;push bc 
0c92			   ; Clobbers A, d and e 
0c92 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0c95			delayloop: 
0c95 c5			    push bc 
0c96			 
0c96			if BASE_CPM 
0c96				ld bc, CPM_DELAY_TUNE 
0c96			.cpmloop: 
0c96				push bc 
0c96			 
0c96			endif 
0c96			 
0c96			 
0c96			 
0c96			delayloopi: 
0c96			;	push bc 
0c96			;.dl: 
0c96 cb 47		    bit     0,a    	; 8 
0c98 cb 47		    bit     0,a    	; 8 
0c9a cb 47		    bit     0,a    	; 8 
0c9c e6 ff		    and     255  	; 7 
0c9e 0b			    dec     bc      	; 6 
0c9f 79			    ld      a,c     	; 4 
0ca0 b0			    or      b     	; 4 
0ca1 c2 96 0c		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0ca4			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0ca4				;pop de 
0ca4			;pop bc 
0ca4			 
0ca4			if BASE_CPM 
0ca4				pop bc 
0ca4				 
0ca4			    dec     bc      	; 6 
0ca4			    ld      a,c     	; 4 
0ca4			    or      b     	; 4 
0ca4			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0ca4				 
0ca4			 
0ca4			endif 
0ca4			;if CPU_CLOCK_8MHZ 
0ca4			;    pop bc 
0ca4			;    push bc 
0ca4			;.dl8: 
0ca4			;    bit     0,a    	; 8 
0ca4			;    bit     0,a    	; 8 
0ca4			;    bit     0,a    	; 8 
0ca4			;    and     255  	; 7 
0ca4			;    dec     bc      	; 6 
0ca4			;    ld      a,c     	; 4 
0ca4			;    or      b     	; 4 
0ca4			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0ca4			;endif 
0ca4			 
0ca4			;if CPU_CLOCK_10MHZ 
0ca4			;    pop bc 
0ca4			;    push bc 
0ca4			;.dl8: 
0ca4			;    bit     0,a    	; 8 
0ca4			;    bit     0,a    	; 8 
0ca4			;    bit     0,a    	; 8 
0ca4			;    and     255  	; 7 
0ca4			;    dec     bc      	; 6 
0ca4			;    ld      a,c     	; 4 
0ca4			;    or      b     	; 4 
0ca4			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0ca4			;endif 
0ca4 c1			    pop bc 
0ca5			 
0ca5 c9				ret 
0ca6			 
0ca6			 
0ca6			 
0ca6			; eof 
# End of file firmware_general.asm
0ca6			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0ca6			; display routines that use the physical hardware abstraction layer 
0ca6			 
0ca6			 
0ca6			; information window 
0ca6			 
0ca6			; pass hl with 1st string to display 
0ca6			; pass de with 2nd string to display 
0ca6			 
0ca6			info_panel: 
0ca6 e5				push hl 
0ca7			 
0ca7 2a 55 fd			ld hl, (display_fb_active) 
0caa e5				push hl    ; future de destination 
0cab 21 4a fe				ld hl, display_fb0 
0cae 22 55 fd				ld (display_fb_active), hl 
0cb1			 
0cb1			;	call clear_display 
0cb1			 
0cb1				if BASE_CPM 
0cb1				ld a, '.' 
0cb1				else 
0cb1 3e a5			ld a, 165 
0cb3				endif 
0cb3 cd 1a 0d			call fill_display 
0cb6			 
0cb6			 
0cb6 3e 2d			ld a, display_row_3 + 5 
0cb8 cd 28 0d			call str_at_display 
0cbb			 
0cbb e1				pop hl 
0cbc d1				pop de 
0cbd			 
0cbd e5				push hl 
0cbe			 
0cbe			 
0cbe 3e 19			ld a, display_row_2 + 5 
0cc0 cd 28 0d			call str_at_display 
0cc3			 
0cc3			 
0cc3 cd 38 0d			call update_display 
0cc6 cd b2 1e			call next_page_prompt 
0cc9 cd 15 0d			call clear_display 
0ccc			 
0ccc				 
0ccc 21 f9 fd				ld hl, display_fb1 
0ccf 22 55 fd				ld (display_fb_active), hl 
0cd2 cd 38 0d			call update_display 
0cd5			 
0cd5 e1				pop hl 
0cd6			 
0cd6 c9				ret 
0cd7			 
0cd7			 
0cd7			 
0cd7			 
0cd7			; TODO windowing? 
0cd7			 
0cd7			; TODO scroll line up 
0cd7			 
0cd7			scroll_up: 
0cd7			 
0cd7 e5				push hl 
0cd8 d5				push de 
0cd9 c5				push bc 
0cda			 
0cda				; get frame buffer  
0cda			 
0cda 2a 55 fd			ld hl, (display_fb_active) 
0cdd e5				push hl    ; future de destination 
0cde			 
0cde 11 14 00			ld  de, display_cols 
0ce1 19				add hl, de 
0ce2			 
0ce2 d1				pop de 
0ce3			 
0ce3				;ex de, hl 
0ce3 01 4f 00			ld bc, display_fb_len -1  
0ce6			;if DEBUG_FORTH_WORDS 
0ce6			;	DMARK "SCL" 
0ce6			;	CALLMONITOR 
0ce6			;endif	 
0ce6 ed b0			ldir 
0ce8			 
0ce8				; wipe bottom row 
0ce8			 
0ce8			 
0ce8 2a 55 fd			ld hl, (display_fb_active) 
0ceb 11 50 00			ld de, display_cols*display_rows 
0cee 19				add hl, de 
0cef 06 14			ld b, display_cols 
0cf1 3e 20			ld a, ' ' 
0cf3			.scwipe: 
0cf3 77				ld (hl), a 
0cf4 2b				dec hl 
0cf5 10 fc			djnz .scwipe 
0cf7			 
0cf7				;pop hl 
0cf7			 
0cf7 c1				pop bc 
0cf8 d1				pop de 
0cf9 e1				pop hl 
0cfa			 
0cfa c9				ret 
0cfb			 
0cfb			 
0cfb			;scroll_upo: 
0cfb			;	ld de, display_row_1 
0cfb			 ;	ld hl, display_row_2 
0cfb			;	ld bc, display_cols 
0cfb			;	ldir 
0cfb			;	ld de, display_row_2 
0cfb			 ;	ld hl, display_row_3 
0cfb			;	ld bc, display_cols 
0cfb			;	ldir 
0cfb			;	ld de, display_row_3 
0cfb			 ;	ld hl, display_row_4 
0cfb			;	ld bc, display_cols 
0cfb			;	ldir 
0cfb			 
0cfb			; TODO clear row 4 
0cfb			 
0cfb			;	ret 
0cfb			 
0cfb				 
0cfb			scroll_down: 
0cfb			 
0cfb e5				push hl 
0cfc d5				push de 
0cfd c5				push bc 
0cfe			 
0cfe				; get frame buffer  
0cfe			 
0cfe 2a 55 fd			ld hl, (display_fb_active) 
0d01			 
0d01 11 4f 00			ld de, display_fb_len - 1 
0d04 19				add hl, de 
0d05			 
0d05 e5			push hl    ; future de destination 
0d06			 
0d06 11 14 00			ld  de, display_cols 
0d09 ed 52			sbc hl, de 
0d0b			 
0d0b			 
0d0b d1				pop de 
0d0c			 
0d0c			;	ex de, hl 
0d0c 01 4f 00			ld bc, display_fb_len -1  
0d0f			 
0d0f			 
0d0f				 
0d0f			 
0d0f ed b0			ldir 
0d11			 
0d11				; wipe bottom row 
0d11			 
0d11			 
0d11			;	ld hl, (display_fb_active) 
0d11			;;	ld de, display_cols*display_rows 
0d11			;;	add hl, de 
0d11			;	ld b, display_cols 
0d11			;	ld a, ' ' 
0d11			;.scwiped: 
0d11			;	ld (hl), a 
0d11			;	dec hl 
0d11			;	djnz .scwiped 
0d11			 
0d11				;pop hl 
0d11			 
0d11 c1				pop bc 
0d12 d1				pop de 
0d13 e1				pop hl 
0d14			 
0d14 c9				ret 
0d15			;scroll_down: 
0d15			;	ld de, display_row_4 
0d15			;	ld hl, display_row_3 
0d15			;	ld bc, display_cols 
0d15			;	ldir 
0d15			;	ld de, display_row_3 
0d15			; 	ld hl, display_row_2 
0d15			;	ld bc, display_cols 
0d15			;	ldir 
0d15			;	ld de, display_row_2 
0d15			;	ld hl, display_row_1 
0d15			;	ld bc, display_cols 
0d15			;	ldir 
0d15			;;; TODO clear row 1 
0d15			;	ret 
0d15			 
0d15			 
0d15			 
0d15			 
0d15			 
0d15			; clear active frame buffer 
0d15			 
0d15			clear_display: 
0d15 3e 20			ld a, ' ' 
0d17 c3 1a 0d			jp fill_display 
0d1a			 
0d1a			; fill active frame buffer with a char in A 
0d1a			 
0d1a			fill_display: 
0d1a 06 50			ld b,display_fb_len 
0d1c 2a 55 fd			ld hl, (display_fb_active) 
0d1f 77			.fd1:	ld (hl),a 
0d20 23				inc hl 
0d21 10 fc			djnz .fd1 
0d23 23				inc hl 
0d24 3e 00			ld a,0 
0d26 77				ld (hl),a 
0d27			 
0d27			 
0d27 c9				ret 
0d28			; Write string (DE) at pos (A) to active frame buffer 
0d28			 
0d28 2a 55 fd		str_at_display:    ld hl,(display_fb_active) 
0d2b 06 00					ld b,0 
0d2d 4f					ld c,a 
0d2e 09					add hl,bc 
0d2f 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0d30 b7			            OR   A              ;Null terminator? 
0d31 c8			            RET  Z              ;Yes, so finished 
0d32 77					ld (hl),a 
0d33 23				inc hl 
0d34 13			            INC  DE             ;Point to next character 
0d35 18 f8		            JR   .sad1     ;Repeat 
0d37 c9					ret 
0d38			 
0d38			; using current frame buffer write to physical display 
0d38			 
0d38			update_display: 
0d38 e5				push hl 
0d39 2a 55 fd			ld hl, (display_fb_active) 
0d3c cd 62 6d			call write_display 
0d3f e1				pop hl 
0d40 c9				ret 
0d41			 
0d41			; TODO scrolling 
0d41			 
0d41			 
0d41			; move cursor right one char 
0d41			cursor_right: 
0d41			 
0d41				; TODO shift right 
0d41				; TODO if beyond max col 
0d41				; TODO       cursor_next_line 
0d41			 
0d41 c9				ret 
0d42			 
0d42			 
0d42			cursor_next_line: 
0d42				; TODO first char 
0d42				; TODO line down 
0d42				; TODO if past last row 
0d42				; TODO    scroll up 
0d42			 
0d42 c9				ret 
0d43			 
0d43			cursor_left: 
0d43				; TODO shift left 
0d43				; TODO if beyond left  
0d43				; TODO     cursor prev line 
0d43				 
0d43 c9				ret 
0d44			 
0d44			cursor_prev_line: 
0d44				; TODO last char 
0d44				; TODO line up 
0d44				; TODO if past first row 
0d44				; TODO   scroll down 
0d44			 
0d44 c9				ret 
0d45			 
0d45			 
0d45			cout: 
0d45				; A - char 
0d45 c9				ret 
0d46			 
0d46			 
0d46			; Display a menu and allow item selection (optional toggle items) 
0d46			; 
0d46			; format: 
0d46			; hl pointer to word array with zero term for items 
0d46			; e.g.    db item1 
0d46			;         db .... 
0d46			;         db 0 
0d46			; 
0d46			; a = starting menu item  
0d46			; 
0d46			; de = pointer item toggle array   (todo) 
0d46			; 
0d46			; returns item selected in a 1-... 
0d46			; returns 0 if back button pressed 
0d46			; 
0d46			; NOTE: Uses system frame buffer to display 
0d46			; 
0d46			; LEFT, Q = go back 
0d46			; RIGHT, SPACE, CR = select 
0d46			; UP, A - Up 
0d46			; DOWN, Z - Down 
0d46			 
0d46			 
0d46			 
0d46			 
0d46			 
0d46			menu: 
0d46			 
0d46					; keep array pointer 
0d46			 
0d46 22 00 fc				ld (store_tmp1), hl 
0d49 32 fe fb				ld (store_tmp2), a 
0d4c			 
0d4c					; check for key bounce 
0d4c			 
0d4c			if BASE_KEV 
0d4c			 
0d4c cd 17 6f		.mbounce:	call cin 
0d4f fe 00				cp 0 
0d51 20 f9				jr nz, .mbounce 
0d53			endif 
0d53					; for ease use ex 
0d53			 
0d53					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0d53 21 4a fe				ld hl, display_fb0 
0d56 22 55 fd				ld (display_fb_active), hl 
0d59			 
0d59 cd 15 0d		.mloop:		call clear_display 
0d5c cd 38 0d				call update_display 
0d5f			 
0d5f					; draw selection id '>' at 1 
0d5f			 
0d5f					; init start of list display 
0d5f			 
0d5f 3e 05				ld a, 5 
0d61 32 fc fb				ld (store_tmp3), a   ; display row count 
0d64 3a fe fb				ld a,( store_tmp2) 
0d67 32 ff fb				ld (store_tmp2+1), a   ; display item count 
0d6a			 
0d6a					 
0d6a			.mitem:	 
0d6a			 
0d6a			 
0d6a 3a ff fb				ld a,(store_tmp2+1) 
0d6d 6f					ld l, a 
0d6e 26 00				ld h, 0 
0d70 29					add hl, hl 
0d71 ed 5b 00 fc			ld de, (store_tmp1) 
0d75 19					add hl, de 
0d76 7e					ld a, (hl) 
0d77 23					inc hl 
0d78 66					ld h,(hl) 
0d79 6f					ld l, a 
0d7a			 
0d7a cd 72 0f				call ishlzero 
0d7d 28 1a				jr z, .mdone 
0d7f			 
0d7f eb					ex de, hl 
0d80 3a fc fb				ld a, (store_tmp3) 
0d83 cd 28 0d				call str_at_display 
0d86					 
0d86			 
0d86					; next item 
0d86 3a ff fb				ld a, (store_tmp2+1) 
0d89 3c					inc a 
0d8a 32 ff fb				ld (store_tmp2+1), a   ; display item count 
0d8d			 
0d8d			 		; next row 
0d8d			 
0d8d 3a fc fb				ld a, (store_tmp3) 
0d90 c6 14				add display_cols 
0d92 32 fc fb				ld (store_tmp3), a 
0d95			 
0d95					; at end of screen? 
0d95			 
0d95 fe 10				cp display_rows*4 
0d97 20 d1				jr nz, .mitem 
0d99			 
0d99			 
0d99			.mdone: 
0d99 cd 72 0f				call ishlzero 
0d9c 28 08				jr z, .nodn 
0d9e			 
0d9e 3e 3c				ld a, display_row_4 
0da0 11 1f 0e				ld de, .mdown 
0da3 cd 28 0d				call str_at_display 
0da6			 
0da6					; draw options to fill the screens with active item on line 1 
0da6					; if current option is 2 or more then display ^ in top 
0da6			 
0da6 3a fe fb		.nodn:		ld a, (store_tmp2) 
0da9 fe 00				cp 0 
0dab 28 08				jr z, .noup 
0dad			 
0dad 3e 00				ld a, 0 
0daf 11 1d 0e				ld de, .mup 
0db2 cd 28 0d				call str_at_display 
0db5			 
0db5 3e 02		.noup:		ld a, 2 
0db7 11 1b 0e				ld de, .msel 
0dba cd 28 0d				call str_at_display 
0dbd			 
0dbd					; if current option + 1 is not null then display V in bottom 
0dbd					; get key 
0dbd cd 38 0d				call update_display 
0dc0			 
0dc0			 
0dc0					; handle key 
0dc0			 
0dc0 cd 06 6f				call cin_wait 
0dc3			 
0dc3 fe 05				cp KEY_UP 
0dc5 28 2b				jr z, .mgoup 
0dc7 fe 61				cp 'a' 
0dc9 28 27				jr z, .mgoup 
0dcb fe 0a				cp KEY_DOWN 
0dcd 28 32				jr z, .mgod 
0dcf fe 7a				cp 'z' 
0dd1 28 2e				jr z, .mgod 
0dd3 fe 20				cp ' ' 
0dd5 28 34				jr z, .goend 
0dd7 fe 0c				cp KEY_RIGHT 
0dd9 28 30				jr z, .goend 
0ddb fe 0d				cp KEY_CR 
0ddd 28 2c				jr z, .goend 
0ddf fe 71				cp 'q' 
0de1 28 0b				jr z, .goback 
0de3			 
0de3 fe 0b				cp KEY_LEFT 
0de5 28 07				jr z, .goback 
0de7 fe 08				cp KEY_BS 
0de9 28 03				jr z, .goback 
0deb c3 59 0d				jp .mloop 
0dee			 
0dee			.goback: 
0dee 3e 00			ld a, 0 
0df0 18 1d			jr .goend2 
0df2			 
0df2				; move up one 
0df2			.mgoup: 
0df2 3a fe fb				ld a, (store_tmp2) 
0df5 fe 00				cp 0 
0df7 ca 59 0d				jp z, .mloop 
0dfa 3d					dec a 
0dfb 32 fe fb				ld (store_tmp2), a 
0dfe c3 59 0d				jp .mloop 
0e01			 
0e01				; move down one 
0e01			.mgod: 
0e01 3a fe fb				ld a, (store_tmp2) 
0e04 3c					inc a 
0e05 32 fe fb				ld (store_tmp2), a 
0e08 c3 59 0d				jp .mloop 
0e0b			 
0e0b			 
0e0b			.goend: 
0e0b					; get selected item number 
0e0b			 
0e0b 3a fe fb				ld a, (store_tmp2) 
0e0e 3c					inc a 
0e0f			 
0e0f			.goend2: 
0e0f f5					push af 
0e10			 
0e10					; restore active fb 
0e10					; TODO BUG assumes fb1 
0e10			 
0e10 21 f9 fd				ld hl, display_fb1 
0e13 22 55 fd				ld (display_fb_active), hl 
0e16			 
0e16					; restore main regs 
0e16			 
0e16			 
0e16 cd 38 0d				call update_display 
0e19			 
0e19 f1					pop af 
0e1a			 
0e1a c9				ret 
0e1b			 
0e1b .. 00		.msel:   db ">",0 
0e1d .. 00		.mup:   db "^",0 
0e1f .. 00		.mdown:   db "v",0 
0e21			 
0e21			 
0e21			; eof 
0e21			 
# End of file firmware_display.asm
0e21			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0e21			; random number generators 
0e21			 
0e21			 
0e21			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0e21			 
0e21			 
0e21			;-----> Generate a random number 
0e21			; output a=answer 0<=a<=255 
0e21			; all registers are preserved except: af 
0e21			random: 
0e21 e5			        push    hl 
0e22 d5			        push    de 
0e23 2a 37 fd		        ld      hl,(randData) 
0e26 ed 5f		        ld      a,r 
0e28 57			        ld      d,a 
0e29 5e			        ld      e,(hl) 
0e2a 19			        add     hl,de 
0e2b 85			        add     a,l 
0e2c ac			        xor     h 
0e2d 22 37 fd		        ld      (randData),hl 
0e30 d1			        pop     de 
0e31 e1			        pop     hl 
0e32 c9			        ret 
0e33			 
0e33			 
0e33			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0e33			 
0e33			 
0e33			 
0e33			;------LFSR------ 
0e33			;James Montelongo 
0e33			;optimized by Spencer Putt 
0e33			;out: 
0e33			; a = 8 bit random number 
0e33			RandLFSR: 
0e33 21 3d fd		        ld hl,LFSRSeed+4 
0e36 5e			        ld e,(hl) 
0e37 23			        inc hl 
0e38 56			        ld d,(hl) 
0e39 23			        inc hl 
0e3a 4e			        ld c,(hl) 
0e3b 23			        inc hl 
0e3c 7e			        ld a,(hl) 
0e3d 47			        ld b,a 
0e3e cb 13		        rl e  
0e40 cb 12			rl d 
0e42 cb 11		        rl c  
0e44 17				rla 
0e45 cb 13		        rl e  
0e47 cb 12			rl d 
0e49 cb 11		        rl c  
0e4b 17				rla 
0e4c cb 13		        rl e  
0e4e cb 12			rl d 
0e50 cb 11		        rl c  
0e52 17				rla 
0e53 67			        ld h,a 
0e54 cb 13		        rl e  
0e56 cb 12			rl d 
0e58 cb 11		        rl c  
0e5a 17				rla 
0e5b a8			        xor b 
0e5c cb 13		        rl e  
0e5e cb 12			rl d 
0e60 ac			        xor h 
0e61 a9			        xor c 
0e62 aa			        xor d 
0e63 21 3f fd		        ld hl,LFSRSeed+6 
0e66 11 40 fd		        ld de,LFSRSeed+7 
0e69 01 07 00		        ld bc,7 
0e6c ed b8		        lddr 
0e6e 12			        ld (de),a 
0e6f c9			        ret 
0e70			 
0e70			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0e70			 
0e70			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0e70			 
0e70			 
0e70			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0e70			 
0e70			prng16: 
0e70			;Inputs: 
0e70			;   (seed1) contains a 16-bit seed value 
0e70			;   (seed2) contains a NON-ZERO 16-bit seed value 
0e70			;Outputs: 
0e70			;   HL is the result 
0e70			;   BC is the result of the LCG, so not that great of quality 
0e70			;   DE is preserved 
0e70			;Destroys: 
0e70			;   AF 
0e70			;cycle: 4,294,901,760 (almost 4.3 billion) 
0e70			;160cc 
0e70			;26 bytes 
0e70 2a 31 fd		    ld hl,(seed1) 
0e73 44			    ld b,h 
0e74 4d			    ld c,l 
0e75 29			    add hl,hl 
0e76 29			    add hl,hl 
0e77 2c			    inc l 
0e78 09			    add hl,bc 
0e79 22 31 fd		    ld (seed1),hl 
0e7c 2a 2f fd		    ld hl,(seed2) 
0e7f 29			    add hl,hl 
0e80 9f			    sbc a,a 
0e81 e6 2d		    and %00101101 
0e83 ad			    xor l 
0e84 6f			    ld l,a 
0e85 22 2f fd		    ld (seed2),hl 
0e88 09			    add hl,bc 
0e89 c9			    ret 
0e8a			 
0e8a			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0e8a			 
0e8a			rand32: 
0e8a			;Inputs: 
0e8a			;   (seed1_0) holds the lower 16 bits of the first seed 
0e8a			;   (seed1_1) holds the upper 16 bits of the first seed 
0e8a			;   (seed2_0) holds the lower 16 bits of the second seed 
0e8a			;   (seed2_1) holds the upper 16 bits of the second seed 
0e8a			;   **NOTE: seed2 must be non-zero 
0e8a			;Outputs: 
0e8a			;   HL is the result 
0e8a			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0e8a			;Destroys: 
0e8a			;   AF 
0e8a			;Tested and passes all CAcert tests 
0e8a			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0e8a			;it has a period of 18,446,744,069,414,584,320 
0e8a			;roughly 18.4 quintillion. 
0e8a			;LFSR taps: 0,2,6,7  = 11000101 
0e8a			;291cc 
0e8a			;seed1_0=$+1 
0e8a			;    ld hl,12345 
0e8a			;seed1_1=$+1 
0e8a			;    ld de,6789 
0e8a			;    ld b,h 
0e8a			;    ld c,l 
0e8a			;    add hl,hl \ rl e \ rl d 
0e8a			;    add hl,hl \ rl e \ rl d 
0e8a			;    inc l 
0e8a			;    add hl,bc 
0e8a			;    ld (seed1_0),hl 
0e8a			;    ld hl,(seed1_1) 
0e8a			;    adc hl,de 
0e8a			;    ld (seed1_1),hl 
0e8a			;    ex de,hl 
0e8a			;seed2_0=$+1 
0e8a			;    ld hl,9876 
0e8a			;seed2_1=$+1 
0e8a			;    ld bc,54321 
0e8a			;    add hl,hl \ rl c \ rl b 
0e8a			;    ld (seed2_1),bc 
0e8a			;    sbc a,a 
0e8a			;    and %11000101 
0e8a			;    xor l 
0e8a			;    ld l,a 
0e8a			;    ld (seed2_0),hl 
0e8a			;    ex de,hl 
0e8a			;    add hl,bc 
0e8a			;    ret 
0e8a			; 
0e8a			 
0e8a			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0e8a			; 20 bytes, 86 cycles (excluding ret) 
0e8a			 
0e8a			; returns   hl = pseudorandom number 
0e8a			; corrupts   a 
0e8a			 
0e8a			; generates 16-bit pseudorandom numbers with a period of 65535 
0e8a			; using the xorshift method: 
0e8a			 
0e8a			; hl ^= hl << 7 
0e8a			; hl ^= hl >> 9 
0e8a			; hl ^= hl << 8 
0e8a			 
0e8a			; some alternative shift triplets which also perform well are: 
0e8a			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0e8a			 
0e8a			;  org 32768 
0e8a			 
0e8a			xrnd: 
0e8a 2a 35 fd		  ld hl,(xrandc)       ; seed must not be 0 
0e8d 3e 00		  ld a,0 
0e8f bd			  cp l 
0e90 20 02		  jr nz, .xrnd1 
0e92 2e 01		  ld l, 1 
0e94			.xrnd1: 
0e94			 
0e94 7c			  ld a,h 
0e95 1f			  rra 
0e96 7d			  ld a,l 
0e97 1f			  rra 
0e98 ac			  xor h 
0e99 67			  ld h,a 
0e9a 7d			  ld a,l 
0e9b 1f			  rra 
0e9c 7c			  ld a,h 
0e9d 1f			  rra 
0e9e ad			  xor l 
0e9f 6f			  ld l,a 
0ea0 ac			  xor h 
0ea1 67			  ld h,a 
0ea2			 
0ea2 22 35 fd		  ld (xrandc),hl 
0ea5			 
0ea5 c9			  ret 
0ea6			;  
0ea6			 
0ea6			 
0ea6			;;;; int maths 
0ea6			 
0ea6			; https://map.grauw.nl/articles/mult_div_shifts.php 
0ea6			; Divide 16-bit values (with 16-bit result) 
0ea6			; In: Divide BC by divider DE 
0ea6			; Out: BC = result, HL = rest 
0ea6			; 
0ea6			Div16: 
0ea6 21 00 00		    ld hl,0 
0ea9 78			    ld a,b 
0eaa 06 08		    ld b,8 
0eac			Div16_Loop1: 
0eac 17			    rla 
0ead ed 6a		    adc hl,hl 
0eaf ed 52		    sbc hl,de 
0eb1 30 01		    jr nc,Div16_NoAdd1 
0eb3 19			    add hl,de 
0eb4			Div16_NoAdd1: 
0eb4 10 f6		    djnz Div16_Loop1 
0eb6 17			    rla 
0eb7 2f			    cpl 
0eb8 47			    ld b,a 
0eb9 79			    ld a,c 
0eba 48			    ld c,b 
0ebb 06 08		    ld b,8 
0ebd			Div16_Loop2: 
0ebd 17			    rla 
0ebe ed 6a		    adc hl,hl 
0ec0 ed 52		    sbc hl,de 
0ec2 30 01		    jr nc,Div16_NoAdd2 
0ec4 19			    add hl,de 
0ec5			Div16_NoAdd2: 
0ec5 10 f6		    djnz Div16_Loop2 
0ec7 17			    rla 
0ec8 2f			    cpl 
0ec9 41			    ld b,c 
0eca 4f			    ld c,a 
0ecb c9			ret 
0ecc			 
0ecc			 
0ecc			;http://z80-heaven.wikidot.com/math 
0ecc			; 
0ecc			;Inputs: 
0ecc			;     DE and A are factors 
0ecc			;Outputs: 
0ecc			;     A is not changed 
0ecc			;     B is 0 
0ecc			;     C is not changed 
0ecc			;     DE is not changed 
0ecc			;     HL is the product 
0ecc			;Time: 
0ecc			;     342+6x 
0ecc			; 
0ecc			Mult16: 
0ecc			 
0ecc 06 08		     ld b,8          ;7           7 
0ece 21 00 00		     ld hl,0         ;10         10 
0ed1 29			       add hl,hl     ;11*8       88 
0ed2 07			       rlca          ;4*8        32 
0ed3 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0ed5 19			         add hl,de   ;--         -- 
0ed6 10 f9		       djnz $-5      ;13*7+8     99 
0ed8 c9			ret 
0ed9			 
0ed9			; 
0ed9			; Square root of 16-bit value 
0ed9			; In:  HL = value 
0ed9			; Out:  D = result (rounded down) 
0ed9			; 
0ed9			;Sqr16: 
0ed9			;    ld de,#0040 
0ed9			;    ld a,l 
0ed9			;    ld l,h 
0ed9			;    ld h,d 
0ed9			;    or a 
0ed9			;    ld b,8 
0ed9			;Sqr16_Loop: 
0ed9			;    sbc hl,de 
0ed9			;    jr nc,Sqr16_Skip 
0ed9			;    add hl,de 
0ed9			;Sqr16_Skip: 
0ed9			;    ccf 
0ed9			;    rl d 
0ed9			;    add a,a 
0ed9			;    adc hl,hl 
0ed9			;    add a,a 
0ed9			;    adc hl,hl 
0ed9			;    djnz Sqr16_Loop 
0ed9			;    ret 
0ed9			; 
0ed9			; 
0ed9			; Divide 8-bit values 
0ed9			; In: Divide E by divider C 
0ed9			; Out: A = result, B = rest 
0ed9			; 
0ed9			Div8: 
0ed9 af			    xor a 
0eda 06 08		    ld b,8 
0edc			Div8_Loop: 
0edc cb 13		    rl e 
0ede 17			    rla 
0edf 91			    sub c 
0ee0 30 01		    jr nc,Div8_NoAdd 
0ee2 81			    add a,c 
0ee3			Div8_NoAdd: 
0ee3 10 f7		    djnz Div8_Loop 
0ee5 47			    ld b,a 
0ee6 7b			    ld a,e 
0ee7 17			    rla 
0ee8 2f			    cpl 
0ee9 c9			    ret 
0eea			 
0eea			; 
0eea			; Multiply 8-bit value with a 16-bit value (unrolled) 
0eea			; In: Multiply A with DE 
0eea			; Out: HL = result 
0eea			; 
0eea			Mult12U: 
0eea 2e 00		    ld l,0 
0eec 87			    add a,a 
0eed 30 01		    jr nc,Mult12U_NoAdd0 
0eef 19			    add hl,de 
0ef0			Mult12U_NoAdd0: 
0ef0 29			    add hl,hl 
0ef1 87			    add a,a 
0ef2 30 01		    jr nc,Mult12U_NoAdd1 
0ef4 19			    add hl,de 
0ef5			Mult12U_NoAdd1: 
0ef5 29			    add hl,hl 
0ef6 87			    add a,a 
0ef7 30 01		    jr nc,Mult12U_NoAdd2 
0ef9 19			    add hl,de 
0efa			Mult12U_NoAdd2: 
0efa 29			    add hl,hl 
0efb 87			    add a,a 
0efc 30 01		    jr nc,Mult12U_NoAdd3 
0efe 19			    add hl,de 
0eff			Mult12U_NoAdd3: 
0eff 29			    add hl,hl 
0f00 87			    add a,a 
0f01 30 01		    jr nc,Mult12U_NoAdd4 
0f03 19			    add hl,de 
0f04			Mult12U_NoAdd4: 
0f04 29			    add hl,hl 
0f05 87			    add a,a 
0f06 30 01		    jr nc,Mult12U_NoAdd5 
0f08 19			    add hl,de 
0f09			Mult12U_NoAdd5: 
0f09 29			    add hl,hl 
0f0a 87			    add a,a 
0f0b 30 01		    jr nc,Mult12U_NoAdd6 
0f0d 19			    add hl,de 
0f0e			Mult12U_NoAdd6: 
0f0e 29			    add hl,hl 
0f0f 87			    add a,a 
0f10 d0			    ret nc 
0f11 19			    add hl,de 
0f12 c9			    ret 
0f13			 
0f13			; 
0f13			; Multiply 8-bit value with a 16-bit value (right rotating) 
0f13			; In: Multiply A with DE 
0f13			;      Put lowest value in A for most efficient calculation 
0f13			; Out: HL = result 
0f13			; 
0f13			Mult12R: 
0f13 21 00 00		    ld hl,0 
0f16			Mult12R_Loop: 
0f16 cb 3f		    srl a 
0f18 30 01		    jr nc,Mult12R_NoAdd 
0f1a 19			    add hl,de 
0f1b			Mult12R_NoAdd: 
0f1b cb 23		    sla e 
0f1d cb 12		    rl d 
0f1f b7			    or a 
0f20 c2 16 0f		    jp nz,Mult12R_Loop 
0f23 c9			    ret 
0f24			 
0f24			; 
0f24			; Multiply 16-bit values (with 32-bit result) 
0f24			; In: Multiply BC with DE 
0f24			; Out: BCHL = result 
0f24			; 
0f24			Mult32: 
0f24 79			    ld a,c 
0f25 48			    ld c,b 
0f26 21 00 00		    ld hl,0 
0f29 06 10		    ld b,16 
0f2b			Mult32_Loop: 
0f2b 29			    add hl,hl 
0f2c 17			    rla 
0f2d cb 11		    rl c 
0f2f 30 07		    jr nc,Mult32_NoAdd 
0f31 19			    add hl,de 
0f32 ce 00		    adc a,0 
0f34 d2 38 0f		    jp nc,Mult32_NoAdd 
0f37 0c			    inc c 
0f38			Mult32_NoAdd: 
0f38 10 f1		    djnz Mult32_Loop 
0f3a 41			    ld b,c 
0f3b 4f			    ld c,a 
0f3c c9			    ret 
0f3d			 
0f3d			 
0f3d			 
0f3d			; 
0f3d			; Multiply 8-bit values 
0f3d			; In:  Multiply H with E 
0f3d			; Out: HL = result 
0f3d			; 
0f3d			Mult8: 
0f3d 16 00		    ld d,0 
0f3f 6a			    ld l,d 
0f40 06 08		    ld b,8 
0f42			Mult8_Loop: 
0f42 29			    add hl,hl 
0f43 30 01		    jr nc,Mult8_NoAdd 
0f45 19			    add hl,de 
0f46			Mult8_NoAdd: 
0f46 10 fa		    djnz Mult8_Loop 
0f48 c9			    ret 
0f49			 
0f49			 
0f49			 
0f49			 
0f49			 
0f49			 
0f49			 
0f49			 
0f49			;;http://z80-heaven.wikidot.com/math 
0f49			;;This divides DE by BC, storing the result in DE, remainder in HL 
0f49			; 
0f49			;DE_Div_BC:          ;1281-2x, x is at most 16 
0f49			;     ld a,16        ;7 
0f49			;     ld hl,0        ;10 
0f49			;     jp $+5         ;10 
0f49			;.DivLoop: 
0f49			;       add hl,bc    ;-- 
0f49			;       dec a        ;64 
0f49			;       jr z,.DivLoopEnd        ;86 
0f49			; 
0f49			;       sla e        ;128 
0f49			;       rl d         ;128 
0f49			;       adc hl,hl    ;240 
0f49			;       sbc hl,bc    ;240 
0f49			;       jr nc,.DivLoop ;23|21 
0f49			;       inc e        ;-- 
0f49			;       jp .DivLoop+1 
0f49			; 
0f49			;.DivLoopEnd: 
0f49			 
0f49			;HL_Div_C: 
0f49			;Inputs: 
0f49			;     HL is the numerator 
0f49			;     C is the denominator 
0f49			;Outputs: 
0f49			;     A is the remainder 
0f49			;     B is 0 
0f49			;     C is not changed 
0f49			;     DE is not changed 
0f49			;     HL is the quotient 
0f49			; 
0f49			;       ld b,16 
0f49			;       xor a 
0f49			;         add hl,hl 
0f49			;         rla 
0f49			;         cp c 
0f49			;         jr c,$+4 
0f49			;           inc l 
0f49			;           sub c 
0f49			;         djnz $-7 
0f49			 
0f49			; https://plutiedev.com/z80-add-8bit-to-16bit 
0f49			 
0f49			addatohl: 
0f49 85			    add   a, l    ; A = A+L 
0f4a 6f			    ld    l, a    ; L = A+L 
0f4b 8c			    adc   a, h    ; A = A+L+H+carry 
0f4c 95			    sub   l       ; A = H+carry 
0f4d 67			    ld    h, a    ; H = H+carry 
0f4e c9			ret 
0f4f			 
0f4f			addatode: 
0f4f 83			    add   a, e    ; A = A+L 
0f50 5f			    ld    e, a    ; L = A+L 
0f51 8a			    adc   a, d    ; A = A+L+H+carry 
0f52 93			    sub   e       ; A = H+carry 
0f53 57			    ld    d, a    ; H = H+carry 
0f54 c9			ret 
0f55			 
0f55			 
0f55			addatobc: 
0f55 81			    add   a, c    ; A = A+L 
0f56 4f			    ld    c, a    ; L = A+L 
0f57 88			    adc   a, b    ; A = A+L+H+carry 
0f58 91			    sub   c       ; A = H+carry 
0f59 47			    ld    b, a    ; H = H+carry 
0f5a c9			ret 
0f5b			 
0f5b			subafromhl: 
0f5b			   ; If A=0 do nothing 
0f5b			    ; Otherwise flip A's sign. Since 
0f5b			    ; the upper byte becomes -1, also 
0f5b			    ; substract 1 from H. 
0f5b ed 44		    neg 
0f5d ca 66 0f		    jp    z, Skip 
0f60 25			    dec   h 
0f61			     
0f61			    ; Now add the low byte as usual 
0f61			    ; Two's complement takes care of 
0f61			    ; ensuring the result is correct 
0f61 85			    add   a, l 
0f62 6f			    ld    l, a 
0f63 8c			    adc   a, h 
0f64 95			    sub   l 
0f65 67			    ld    h, a 
0f66			Skip: 
0f66 c9				ret 
0f67			 
0f67			 
0f67			; compare hl and de 
0f67			; returns:  
0f67			; if hl = de, z=1, s=0, c0=0 
0f67			; if hl > de, z=0, s=0, c=0 
0f67			; if hl < de, z=0, s=1, c=1 
0f67			cmp16:	 
0f67 b7				or a 
0f68 ed 52			sbc hl,de 
0f6a e0				ret po 
0f6b 7c				ld a,h 
0f6c 1f				rra 
0f6d ee 40			xor 01000000B 
0f6f 37				scf 
0f70 8f				adc a,a 
0f71 c9				ret 
0f72			 
0f72			 
0f72			; test if hl contains zero   - A is destroyed 
0f72			 
0f72			ishlzero:    
0f72 b7				or a     ; reset flags 
0f73 7c				ld a, h 
0f74 b5				or l        	 
0f75			 
0f75 c9				ret 
0f76			 
0f76			 
0f76			 
0f76			 
0f76			if FORTH_ENABLE_FLOATMATH 
0f76			;include "float/bbcmath.z80" 
0f76			include "float/lpfpcalc.asm" 
0f76			endif 
0f76			 
0f76			 
0f76			; eof 
0f76			 
# End of file firmware_maths.asm
0f76			include "firmware_strings.asm"   ; string handling  
0f76			 
0f76			 
0f76			; TODO string len 
0f76			; input text string, end on cr with zero term 
0f76			; a offset into frame buffer to start prompt 
0f76			; d is max length 
0f76			; e is display size TODO 
0f76			; c is current cursor position 
0f76			; hl is ptr to where string will be stored 
0f76			 
0f76			 
0f76			; TODO check limit of buffer for new inserts 
0f76			; TODO check insert does not push beyond buffer 
0f76			; TODO scroll in a limited display area 
0f76			; TODO scroll whole screen on page wrap 
0f76			 
0f76			 
0f76			; TODO handle KEY_PREVWORD 
0f76			; TODO handle KEY_NEXTWORD 
0f76			; TODO handle KEY_HOME 
0f76			; TODO handle KEY_END 
0f76			; TODO use LCD cursor? 
0f76			 
0f76 32 ad fe		input_str:    	ld (input_at_pos),a      ; save display position to start 
0f79 81					add c 
0f7a 32 ab fe				ld (input_at_cursor),a	; save draw pos of cursor 
0f7d 22 b0 fe				ld (input_start), hl     ; save ptr to buffer 
0f80 79					ld a, c 
0f81 cd 49 0f				call addatohl 
0f84 22 b2 fe				ld (input_ptr), hl     ; save ptr to point under the cursor 
0f87 7a					ld a,d 
0f88 32 af fe			        ld (input_size), a       ; save length of input area 
0f8b 79					ld a, c 
0f8c 32 9e fe				ld (input_cursor),a      ; init cursor start position  
0f8f 7b					ld a,e 
0f90 32 ae fe			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0f93					 
0f93					 
0f93			 
0f93			;		ld a,(input_ptr) 
0f93			;		ld (input_under_cursor),a 	; save what is under the cursor 
0f93			 
0f93			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0f93					; init cursor shape if not set by the cin routines 
0f93 21 4d fd				ld hl, cursor_shape 
0f96 3e ff				ld a, 255 
0f98 77					ld (hl), a 
0f99 23					inc hl 
0f9a 3e 00				ld a, 0 
0f9c 77					ld (hl), a 
0f9d			 
0f9d 3e 0f				ld a, CUR_BLINK_RATE 
0f9f 32 a9 fe				ld (input_cur_flash), a 
0fa2 3e 01				ld a, 1 
0fa4 32 a8 fe				ld (input_cur_onoff),a 
0fa7			 
0fa7			;	if DEBUG_INPUT 
0fa7			;		push af 
0fa7			;		ld a, 'I' 
0fa7			;		ld (debug_mark),a 
0fa7			;		pop af 
0fa7			;		CALLMONITOR 
0fa7			;	endif 
0fa7			.is1:		; main entry loop 
0fa7			 
0fa7			 
0fa7			 
0fa7					; pause 1ms 
0fa7			 
0fa7 3e 01				ld a, 1 
0fa9 cd 77 0c				call aDelayInMS 
0fac			 
0fac					; dec flash counter 
0fac 3a a9 fe				ld a, (input_cur_flash) 
0faf 3d					dec a 
0fb0 32 a9 fe				ld (input_cur_flash), a 
0fb3 fe 00				cp 0 
0fb5 20 0d				jr nz, .nochgstate 
0fb7			 
0fb7			 
0fb7					; change state 
0fb7 3a a8 fe				ld a,(input_cur_onoff) 
0fba ed 44				neg 
0fbc 32 a8 fe				ld (input_cur_onoff),a 
0fbf			 
0fbf			 
0fbf					; reset on change of state 
0fbf 3e 0f				ld a, CUR_BLINK_RATE 
0fc1 32 a9 fe				ld (input_cur_flash), a 
0fc4			 
0fc4			.nochgstate: 
0fc4					 
0fc4					 
0fc4			 
0fc4					; display cursor  
0fc4			 
0fc4			;		ld hl, (input_start) 
0fc4			;		ld a, (input_cursor) 
0fc4			;		call addatohl 
0fc4			 
0fc4					; get char under cursor and replace with cursor 
0fc4 2a b2 fe		ld hl, (input_ptr) 
0fc7			;		ld a, (hl) 
0fc7			;		ld (input_under_cursor),a 
0fc7			;		ld a, '_' 
0fc7			;		ld (hl), a 
0fc7			 
0fc7					; display string 
0fc7			 
0fc7 ed 5b b0 fe			ld de, (input_start) 
0fcb 3a ad fe				ld a, (input_at_pos) 
0fce cd 28 0d				call str_at_display 
0fd1			;	        call update_display 
0fd1			 
0fd1					; find place to put the cursor 
0fd1			;		add h 
0fd1			;		ld l, display_row_1 
0fd1			;		sub l 
0fd1			; (input_at_pos) 
0fd1					;ld c, a 
0fd1			;		ld a, (input_cursor) 
0fd1			;		ld l, (input_at_pos) 
0fd1			;		;ld b, h 
0fd1			;		add l 
0fd1			;		ld (input_at_cursor),a 
0fd1					;ld l,h 
0fd1			 
0fd1			;		ld h, 0 
0fd1			;		ld l,(input_at_pos) 
0fd1			;		ld a, (input_cursor) 
0fd1			;		call addatohl 
0fd1			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0fd1			;		call subafromhl 
0fd1			;		ld a,l 
0fd1			;		ld (input_at_cursor), a 
0fd1			 
0fd1				if DEBUG_INPUT 
0fd1					ld a, (hardware_diag) 
0fd1					cp 0 
0fd1					jr z, .skip_input_diag 
0fd1			 
0fd1					ld a,(input_at_pos) 
0fd1					ld hl, LFSRSeed 
0fd1					call hexout 
0fd1					ld a, (input_cursor) 
0fd1					ld hl, LFSRSeed+2 
0fd1					call hexout 
0fd1					ld a,(input_at_cursor) 
0fd1					ld hl, LFSRSeed+4 
0fd1					call hexout 
0fd1			 
0fd1					ld a,(input_cur_onoff) 
0fd1					ld hl, LFSRSeed+6 
0fd1					call hexout 
0fd1			 
0fd1					ld a,(input_cur_flash) 
0fd1					ld hl, LFSRSeed+8 
0fd1					call hexout 
0fd1			 
0fd1					ld a,(input_len) 
0fd1					ld hl, LFSRSeed+10 
0fd1					call hexout 
0fd1					ld hl, LFSRSeed+12 
0fd1					ld a, 0 
0fd1					ld (hl),a 
0fd1					ld a, display_row_4 
0fd1					ld de, LFSRSeed 
0fd1					call str_at_display 
0fd1					.skip_input_diag: 
0fd1				endif 
0fd1			 
0fd1					; decide on if we are showing the cursor this time round 
0fd1			 
0fd1 3a a8 fe				ld a, (input_cur_onoff) 
0fd4 fe ff				cp 255 
0fd6 28 13				jr z, .skipcur 
0fd8			 
0fd8			 
0fd8 3a ab fe				ld a,(input_at_cursor) 
0fdb 11 4d fd				ld de, cursor_shape 
0fde cd 28 0d				call str_at_display 
0fe1			 
0fe1					; save length of current input string 
0fe1 2a b0 fe				ld hl, (input_start) 
0fe4 cd a7 13				call strlenz 
0fe7 7d					ld a,l 
0fe8 32 a3 fe				ld (input_len),a 
0feb			 
0feb			.skipcur: 
0feb			 
0feb cd 38 0d			        call update_display 
0fee					 
0fee			 
0fee			 
0fee					; wait 
0fee				 
0fee					; TODO loop without wait to flash the cursor and char under cursor	 
0fee cd 17 6f				call cin    ; _wait 
0ff1			 
0ff1 fe 00				cp 0 
0ff3 ca a7 0f				jp z, .is1 
0ff6			 
0ff6					; get ptr to char to input into 
0ff6			 
0ff6 4f					ld c,a 
0ff7 2a b0 fe				ld hl, (input_start) 
0ffa 3a 9e fe				ld a, (input_cursor) 
0ffd cd 49 0f				call addatohl 
1000 22 b2 fe				ld (input_ptr), hl 
1003 79					ld a,c 
1004			 
1004					; replace char under cursor 
1004			 
1004			;		ld hl, (input_ptr) 
1004			;		ld a, (input_under_cursor) 	; get what is under the cursor 
1004			;		ld (hl), a 
1004			 
1004			;	if DEBUG_INPUT 
1004			;		push af 
1004			;		ld a, 'i' 
1004			;		ld (debug_mark),a 
1004			;		pop af 
1004			;		CALLMONITOR 
1004			;	endif 
1004 fe 0e				cp KEY_HOME 
1006 20 0e				jr nz, .iske 
1008			 
1008 3a ad fe				ld a, (input_at_pos) 
100b 32 ab fe				ld (input_at_cursor),a 
100e 3e 00				ld a, 0 
1010 32 9e fe				ld (input_cursor), a 
1013 c3 a7 0f				jp .is1 
1016					 
1016 fe 0f		.iske:		cp KEY_END 
1018 20 03				jr nz, .isknw 
101a c3 a7 0f				jp .is1 
101d			 
101d fe 06		.isknw:		cp KEY_NEXTWORD 
101f 20 1b				jr nz, .iskpw 
1021			 
1021 2a b2 fe		.isknwm:	ld hl, (input_ptr) 
1024 7e					ld a,(hl)	 
1025 fe 00				cp 0 
1027 ca a7 0f				jp z, .is1    ; end of string 
102a fe 20				cp ' ' 
102c ca a7 0f				jp z, .is1    ; end of word 
102f 23					inc hl 
1030 22 b2 fe				ld (input_ptr), hl 
1033 3a ab fe				ld a, (input_at_cursor) 
1036 3c					inc a 
1037 32 ab fe				ld (input_at_cursor), a 
103a 18 e5				jr .isknwm 
103c			 
103c fe 07		.iskpw:		cp KEY_PREVWORD 
103e 20 1b				jr nz, .iskl 
1040			.iskpwm:	 
1040 2a b2 fe				ld hl, (input_ptr) 
1043 7e					ld a,(hl)	 
1044 fe 00				cp 0  
1046 ca a7 0f				jp z, .is1    ; end of string 
1049 fe 20				cp ' ' 
104b ca a7 0f				jp z, .is1    ; end of word 
104e 2b					dec hl 
104f 22 b2 fe				ld (input_ptr), hl 
1052 3a ab fe				ld a, (input_at_cursor) 
1055 3d					dec a 
1056 32 ab fe				ld (input_at_cursor), a 
1059 18 e5				jr .iskpwm 
105b			 
105b			 
105b fe 0b		.iskl:		cp KEY_LEFT 
105d 20 27				jr nz, .isk1 
105f			 
105f 3a 9e fe				ld a, (input_cursor) 
1062			 
1062 fe 00				cp 0 
1064 ca a7 0f				jp z, .is1 		; at start of line to ignore  
1067			 
1067 3d					dec  a 		; TODO check underflow 
1068 32 9e fe				ld (input_cursor), a 
106b			 
106b 2a b2 fe				ld hl, (input_ptr) 
106e 2b					dec hl 
106f 22 b2 fe				ld (input_ptr), hl 
1072					 
1072 3a ab fe				ld a, (input_at_cursor) 
1075 3d					dec a 
1076 32 ab fe				ld (input_at_cursor), a 
1079			 
1079 3e 01				ld a, 1		; show cursor moving 
107b 32 a8 fe				ld (input_cur_onoff),a 
107e 3e 0f				ld a, CUR_BLINK_RATE 
1080 32 a9 fe				ld (input_cur_flash), a 
1083			 
1083 c3 a7 0f				jp .is1 
1086			 
1086 fe 0c		.isk1:		cp KEY_RIGHT 
1088 20 2a				jr nz, .isk2 
108a			 
108a 3a a3 fe				ld a,(input_len)		; TODO BUG why cant i load e direct? 
108d 5f					ld e,a 
108e 3a 9e fe				ld a, (input_cursor) 
1091 bb					cp e 
1092 ca a7 0f				jp z, .is1		; at the end of string so dont go right 
1095			 
1095 3c					inc  a 		; TODO check overflow 
1096 32 9e fe				ld (input_cursor), a 
1099			 
1099 3a ab fe				ld a, (input_at_cursor) 
109c 3c					inc a 
109d 32 ab fe				ld (input_at_cursor), a 
10a0			 
10a0 2a b2 fe				ld hl, (input_ptr) 
10a3 23					inc hl 
10a4 22 b2 fe				ld (input_ptr), hl 
10a7			 
10a7 3e 01				ld a, 1		; show cursor moving 
10a9 32 a8 fe				ld (input_cur_onoff),a 
10ac 3e 0f				ld a, CUR_BLINK_RATE 
10ae 32 a9 fe				ld (input_cur_flash), a 
10b1			 
10b1 c3 a7 0f				jp .is1 
10b4			 
10b4 fe 05		.isk2:		cp KEY_UP 
10b6			 
10b6 20 26				jr nz, .isk3 
10b8			 
10b8					; swap last command with the current on 
10b8			 
10b8					; move cursor to start of string 
10b8 2a b0 fe				ld hl, (input_start) 
10bb 22 b2 fe				ld (input_ptr), hl 
10be			 
10be 3a ad fe				ld a, (input_at_pos) 
10c1 32 ab fe				ld (input_at_cursor), a 
10c4			 
10c4 3e 00				ld a, 0 
10c6 32 9e fe				ld (input_cursor), a 
10c9					 
10c9					; swap input and last command buffers 
10c9			 
10c9 21 a9 f6				ld hl, os_cli_cmd 
10cc 11 a8 f7				ld de, os_last_cmd 
10cf 06 ff				ld b, 255 
10d1 7e			.swap1:		ld a, (hl) 
10d2 4f					ld c,a 
10d3 1a					ld a, (de) 
10d4 77					ld (hl), a 
10d5 79					ld a,c 
10d6 12					ld (de),a 
10d7 23					inc hl 
10d8 13					inc de 
10d9 10 f6				djnz .swap1 
10db			 
10db			 
10db			 
10db			 
10db			 
10db c3 a7 0f				jp .is1 
10de			 
10de fe 08		.isk3:		cp KEY_BS 
10e0 20 3c				jr nz, .isk4 
10e2			 
10e2 3a 9e fe				ld a, (input_cursor) 
10e5			 
10e5 fe 00				cp 0 
10e7 ca a7 0f				jp z, .is1 		; at start of line to ignore  
10ea			 
10ea 3d					dec  a 		; TODO check underflow 
10eb 32 9e fe				ld (input_cursor), a 
10ee			 
10ee					; hl is source 
10ee					; de needs to be source - 1 
10ee			 
10ee			;		ld a, 0 
10ee			;		dec hl 
10ee			;		ld (hl), a 
10ee			 
10ee 2a b2 fe				ld hl, (input_ptr) 
10f1 2b					dec hl 
10f2 22 b2 fe				ld (input_ptr), hl 
10f5			 
10f5					; shift all data 
10f5			 
10f5 e5					push hl 
10f6 23					inc hl 
10f7 d1					pop de 
10f8 3a a3 fe				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
10fb 4f					ld c,a 
10fc 06 00				ld b,0 
10fe ed b0				ldir  
1100			 
1100			 
1100			 
1100			 
1100 3a ab fe				ld a, (input_at_cursor) 
1103 3d					dec a 
1104 32 ab fe				ld (input_at_cursor), a 
1107			 
1107			 
1107 3e 01				ld a, 1		; show cursor moving 
1109 32 a8 fe				ld (input_cur_onoff),a 
110c 3e 0f				ld a, CUR_BLINK_RATE 
110e 32 a9 fe				ld (input_cur_flash), a 
1111			 
1111					; remove char 
1111 3a ab fe				ld a, (input_at_cursor) 
1114 3c					inc a 
1115 11 9f 11				ld de,.iblank 
1118 cd 28 0d				call str_at_display 
111b			 
111b c3 a7 0f				jp .is1 
111e			 
111e fe 0d		.isk4:		cp KEY_CR 
1120 28 6c				jr z, .endinput 
1122			 
1122					; else add the key press to the end 
1122			 
1122 4f					ld c, a			; save key pressed 
1123			 
1123 7e					ld a,(hl)		; get what is currently under char 
1124			 
1124 fe 00				cp 0			; we are at the end of the string 
1126 20 2f				jr nz, .onchar 
1128					 
1128					; add a char to the end of the string 
1128				 
1128 71					ld (hl),c 
1129 23					inc hl 
112a			;		ld a,' ' 
112a			;		ld (hl),a 
112a			;		inc hl 
112a 3e 00				ld a,0 
112c 77					ld (hl),a 
112d 2b					dec hl 
112e			 
112e 3a 9e fe				ld a, (input_cursor) 
1131 3c					inc a				; TODO check max string length and scroll  
1132 32 9e fe				ld (input_cursor), a		; inc cursor pos 
1135							 
1135 3a ab fe				ld a, (input_at_cursor) 
1138 3c					inc a 
1139 32 ab fe				ld (input_at_cursor), a 
113c			 
113c 2a b2 fe				ld hl, (input_ptr) 
113f 23					inc hl 
1140 22 b2 fe				ld (input_ptr), hl 
1143			 
1143 2a b2 fe				ld hl, (input_ptr) 
1146 23					inc hl 
1147 22 b2 fe				ld (input_ptr), hl 
114a			;	if DEBUG_INPUT 
114a			;		push af 
114a			;		ld a, '+' 
114a			;		ld (debug_mark),a 
114a			;		pop af 
114a			;		CALLMONITOR 
114a			;	endif 
114a 3e 01				ld a, 1		; show cursor moving 
114c 32 a8 fe				ld (input_cur_onoff),a 
114f 3e 0f				ld a, CUR_BLINK_RATE 
1151 32 a9 fe				ld (input_cur_flash), a 
1154 c3 a7 0f				jp .is1 
1157					 
1157			 
1157			 
1157					; if on a char then insert 
1157			.onchar: 
1157			 
1157					; TODO over flow check: make sure insert does not blow out buffer 
1157			 
1157					; need to do some maths to use lddr 
1157			 
1157 e5					push hl   ; save char pos 
1158 c5					push bc 
1159			 
1159 2a b0 fe				ld hl, (input_start) 
115c 3a a3 fe				ld a, (input_len) 
115f cd 49 0f				call addatohl  		; end of string 
1162 23					inc hl 
1163 23					inc hl		; past zero term 
1164 e5					push hl 
1165 23					inc hl 
1166 e5					push hl  
1167			 
1167								; start and end of lddr set, now how much to move? 
1167			 
1167							 
1167 3a 9e fe				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
116a 47					ld b,a 
116b 3a a3 fe				ld a,(input_len) 
116e 5f					ld e,a 
116f 90					sub b 
1170 3c					inc a		;?? 
1171 3c					inc a		;?? 
1172 3c					inc a		;?? 
1173			 
1173 06 00				ld b,0 
1175 4f					ld c,a 
1176			 
1176				if DEBUG_INPUT 
1176					push af 
1176					ld a, 'i' 
1176					ld (debug_mark),a 
1176					pop af 
1176			;		CALLMONITOR 
1176				endif 
1176 d1					pop de 
1177 e1					pop hl 
1178				if DEBUG_INPUT 
1178					push af 
1178					ld a, 'I' 
1178					ld (debug_mark),a 
1178					pop af 
1178			;		CALLMONITOR 
1178				endif 
1178 ed b8				lddr 
117a				 
117a			 
117a			 
117a					; TODO have a key for insert/overwrite mode???? 
117a c1					pop bc 
117b e1					pop hl 
117c 71					ld (hl), c		; otherwise overwrite current char 
117d					 
117d			 
117d			 
117d			 
117d 3a 9e fe				ld a, (input_cursor) 
1180 3c					inc  a 		; TODO check overflow 
1181 32 9e fe				ld (input_cursor), a 
1184			 
1184 3a ab fe				ld a, (input_at_cursor) 
1187 3c					inc a 
1188 32 ab fe				ld (input_at_cursor), a 
118b			 
118b c3 a7 0f				jp .is1 
118e			 
118e			.endinput:	; TODO look for end of string 
118e			 
118e					; add trailing space for end of token 
118e			 
118e 2a b0 fe				ld hl, (input_start) 
1191 3a a3 fe				ld a,(input_len) 
1194 cd 49 0f				call addatohl 
1197 3e 20				ld a, ' ' 
1199 77					ld (hl),a 
119a					; TODO eof of parse marker 
119a			 
119a 23					inc hl 
119b 3e 00				ld a, 0 
119d 77					ld (hl),a 
119e			 
119e			 
119e c9					ret 
119f			 
119f .. 00		.iblank: db " ",0 
11a1			 
11a1			 
11a1 32 ad fe		input_str_prev:	ld (input_at_pos), a 
11a4 22 b0 fe				ld (input_start), hl 
11a7 3e 01				ld a,1			; add cursor 
11a9 77					ld (hl),a 
11aa 23					inc hl 
11ab 3e 00				ld a,0 
11ad 77					ld (hl),a 
11ae 22 b2 fe				ld (input_ptr), hl 
11b1 7a					ld a,d 
11b2 32 af fe				ld (input_size), a 
11b5 3e 00				ld a,0 
11b7 32 9e fe				ld (input_cursor),a 
11ba			.instr1:	 
11ba			 
11ba					; TODO do block cursor 
11ba					; TODO switch cursor depending on the modifer key 
11ba			 
11ba					; update cursor shape change on key hold 
11ba			 
11ba 2a b2 fe				ld hl, (input_ptr) 
11bd 2b					dec hl 
11be 3a 4d fd				ld a,(cursor_shape) 
11c1 77					ld (hl), a 
11c2			 
11c2					; display entered text 
11c2 3a ad fe				ld a,(input_at_pos) 
11c5 cd 35 6e		            	CALL fLCD_Pos       ;Position cursor to location in A 
11c8 ed 5b b0 fe	            	LD   de, (input_start) 
11cc cd 3d 6e		            	CALL fLCD_Str       ;Display string pointed to by DE 
11cf			 
11cf cd 17 6f				call cin 
11d2 fe 00				cp 0 
11d4 28 e4				jr z, .instr1 
11d6			 
11d6					; proecess keyboard controls first 
11d6			 
11d6 2a b2 fe				ld hl,(input_ptr) 
11d9			 
11d9 fe 0d				cp KEY_CR	 ; pressing enter ends input 
11db 28 5a				jr z, .instrcr 
11dd			 
11dd fe 08				cp KEY_BS 	; back space 
11df 20 0f				jr nz, .instr2 
11e1					; process back space 
11e1			 
11e1					; TODO stop back space if at start of string 
11e1 2b					dec hl 
11e2 2b					dec hl ; to over write cursor 
11e3 3a 4d fd				ld a,(cursor_shape) 
11e6					;ld a,0 
11e6 77					ld (hl),a 
11e7 23					inc hl 
11e8 3e 20				ld a," " 
11ea 77					ld (hl),a 
11eb 22 b2 fe				ld (input_ptr),hl 
11ee					 
11ee			 
11ee 18 ca				jr .instr1 
11f0			 
11f0 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
11f2 20 06				jr nz, .instr3 
11f4 2b					dec hl 
11f5 22 b2 fe				ld (input_ptr),hl 
11f8 18 c0				jr .instr1 
11fa				 
11fa fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
11fc 20 06				jr nz, .instr4 
11fe 23					inc hl 
11ff 22 b2 fe				ld (input_ptr),hl 
1202 18 b6				jr .instr1 
1204			 
1204 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
1206 20 06				jr nz, .instr5 
1208 2b					dec hl 
1209 22 b2 fe				ld (input_ptr),hl 
120c 18 ac				jr .instr1 
120e			 
120e fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
1210 20 06				jr nz, .instr6 
1212 2b					dec hl 
1213 22 b2 fe				ld (input_ptr),hl 
1216 18 a2				jr .instr1 
1218 fe 05		.instr6:        cp KEY_UP      ; recall last command 
121a 20 0b				jr nz, .instrnew 
121c			 
121c 21 82 f3			ld hl, scratch 
121f 11 a8 f7			ld de, os_last_cmd 
1222 cd 40 12			call strcpy 
1225 18 93				jr .instr1 
1227			 
1227			 
1227			.instrnew:	; no special key pressed to see if we have room to store it 
1227			 
1227					; TODO do string size test 
1227			 
1227 2b					dec hl ; to over write cursor 
1228 77					ld (hl),a 
1229 23					inc hl 
122a 3a 4d fd				ld a,(cursor_shape) 
122d 77					ld (hl),a 
122e 23					inc hl 
122f 3e 00				ld a,0 
1231 77					ld (hl),a 
1232			 
1232 22 b2 fe				ld (input_ptr),hl 
1235					 
1235 18 83				jr .instr1 
1237 2b			.instrcr:	dec hl		; remove cursor 
1238 3e 20				ld a,' '	; TODO add a trailing space for safety 
123a 77					ld (hl),a 
123b 23					inc hl 
123c 3e 00				ld a,0 
123e 77					ld (hl),a 
123f			 
123f			 
123f					; if at end of line scroll up    
123f					; TODO detecting only end of line 4 for scroll up  
123f			 
123f					;ld   
123f			 
123f c9					ret 
1240			 
1240			 
1240			; strcpy hl = dest, de source 
1240			 
1240 1a			strcpy:   LD   A, (DE)        ;Get character from string 
1241 b7			            OR   A              ;Null terminator? 
1242 c8			            RET  Z              ;Yes, so finished 
1243 1a					ld a,(de) 
1244 77					ld (hl),a 
1245 13			            INC  DE             ;Point to next character 
1246 23					inc hl 
1247 18 f7		            JR   strcpy       ;Repeat 
1249 c9					ret 
124a			 
124a			 
124a			; TODO string_at  
124a			; pass string which starts with lcd offset address and then null term string 
124a			 
124a			; TODO string to dec 
124a			; TODO string to hex 
124a			; TODO byte to string hex 
124a			; TODO byte to string dec 
124a			 
124a			 
124a			 
124a			; from z80uartmonitor 
124a			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
124a			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
124a			; pass hl for where to put the text 
124a			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
124a c5			hexout:	PUSH BC 
124b f5					PUSH AF 
124c 47					LD B, A 
124d					; Upper nybble 
124d cb 3f				SRL A 
124f cb 3f				SRL A 
1251 cb 3f				SRL A 
1253 cb 3f				SRL A 
1255 cd 65 12				CALL tohex 
1258 77					ld (hl),a 
1259 23					inc hl	 
125a					 
125a					; Lower nybble 
125a 78					LD A, B 
125b e6 0f				AND 0FH 
125d cd 65 12				CALL tohex 
1260 77					ld (hl),a 
1261 23					inc hl	 
1262					 
1262 f1					POP AF 
1263 c1					POP BC 
1264 c9					RET 
1265					 
1265			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1265			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
1265			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1265			tohex: 
1265 e5					PUSH HL 
1266 d5					PUSH DE 
1267 16 00				LD D, 0 
1269 5f					LD E, A 
126a 21 72 12				LD HL, .DATA 
126d 19					ADD HL, DE 
126e 7e					LD A, (HL) 
126f d1					POP DE 
1270 e1					POP HL 
1271 c9					RET 
1272			 
1272			.DATA: 
1272 30					DEFB	30h	; 0 
1273 31					DEFB	31h	; 1 
1274 32					DEFB	32h	; 2 
1275 33					DEFB	33h	; 3 
1276 34					DEFB	34h	; 4 
1277 35					DEFB	35h	; 5 
1278 36					DEFB	36h	; 6 
1279 37					DEFB	37h	; 7 
127a 38					DEFB	38h	; 8 
127b 39					DEFB	39h	; 9 
127c 41					DEFB	41h	; A 
127d 42					DEFB	42h	; B 
127e 43					DEFB	43h	; C 
127f 44					DEFB	44h	; D 
1280 45					DEFB	45h	; E 
1281 46					DEFB	46h	; F 
1282			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1282			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1282			;;    subtract $30, if result > 9 then subtract $7 more 
1282			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1282			atohex: 
1282 d6 30				SUB $30 
1284 fe 0a				CP 10 
1286 f8					RET M		; If result negative it was 0-9 so we're done 
1287 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
1289 c9					RET		 
128a			 
128a			 
128a			 
128a			 
128a			; Get 2 ASCII characters as hex byte from pointer in hl 
128a			 
128a			BYTERD: 
128a 16 00			LD	D,00h		;Set up 
128c cd 94 12			CALL	HEXCON		;Get byte and convert to hex 
128f 87				ADD	A,A		;First nibble so 
1290 87				ADD	A,A		;multiply by 16 
1291 87				ADD	A,A		; 
1292 87				ADD	A,A		; 
1293 57				LD	D,A		;Save hi nibble in D 
1294			HEXCON: 
1294 7e				ld a, (hl)		;Get next chr 
1295 23				inc hl 
1296 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
1298 fe 0a			CP	00Ah		;Is it 0-9 ? 
129a 38 02			JR	C,NALPHA	;If so miss next bit 
129c d6 07			SUB	007h		;Else convert alpha 
129e			NALPHA: 
129e b2				OR	D		;Add hi nibble back 
129f c9				RET			; 
12a0			 
12a0			 
12a0			; 
12a0			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
12a0			; Since the routines get_byte and therefore get_nibble are called, only valid 
12a0			; characters (0-9a-f) are accepted. 
12a0			; 
12a0			;get_word        push    af 
12a0			;                call    get_byte        ; Get the upper byte 
12a0			;                ld      h, a 
12a0			;                call    get_byte        ; Get the lower byte 
12a0			;                ld      l, a 
12a0			;                pop     af 
12a0			;                ret 
12a0			; 
12a0			; Get a byte in hexadecimal notation. The result is returned in A. Since 
12a0			; the routine get_nibble is used only valid characters are accepted - the  
12a0			; input routine only accepts characters 0-9a-f. 
12a0			; 
12a0 c5			get_byte:        push    bc              ; Save contents of B (and C) 
12a1 7e					ld a,(hl) 
12a2 23					inc hl 
12a3 cd c8 12		                call    nibble2val      ; Get upper nibble 
12a6 cb 07		                rlc     a 
12a8 cb 07		                rlc     a 
12aa cb 07		                rlc     a 
12ac cb 07		                rlc     a 
12ae 47			                ld      b, a            ; Save upper four bits 
12af 7e					ld a,(hl) 
12b0 cd c8 12		                call    nibble2val      ; Get lower nibble 
12b3 b0			                or      b               ; Combine both nibbles 
12b4 c1			                pop     bc              ; Restore B (and C) 
12b5 c9			                ret 
12b6			; 
12b6			; Get a hexadecimal digit from the serial line. This routine blocks until 
12b6			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
12b6			; to the serial line interface. The lower 4 bits of A contain the value of  
12b6			; that particular digit. 
12b6			; 
12b6			;get_nibble      ld a,(hl)           ; Read a character 
12b6			;                call    to_upper        ; Convert to upper case 
12b6			;                call    is_hex          ; Was it a hex digit? 
12b6			;                jr      nc, get_nibble  ; No, get another character 
12b6			 ;               call    nibble2val      ; Convert nibble to value 
12b6			 ;               call    print_nibble 
12b6			 ;               ret 
12b6			; 
12b6			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
12b6			; A valid hexadecimal digit is denoted by a set C flag. 
12b6			; 
12b6			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
12b6			;                ret     nc              ; Yes 
12b6			;                cp      '0'             ; Less than '0'? 
12b6			;                jr      nc, is_hex_1    ; No, continue 
12b6			;                ccf                     ; Complement carry (i.e. clear it) 
12b6			;                ret 
12b6			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
12b6			;                ret     c               ; Yes 
12b6			;                cp      'A'             ; Less than 'A'? 
12b6			;                jr      nc, is_hex_2    ; No, continue 
12b6			;                ccf                     ; Yes - clear carry and return 
12b6			;                ret 
12b6			;is_hex_2        scf                     ; Set carry 
12b6			;                ret 
12b6			; 
12b6			; Convert a single character contained in A to upper case: 
12b6			; 
12b6 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
12b8 d8			                ret     c 
12b9 fe 7b		                cp      'z' + 1         ; > 'z'? 
12bb d0			                ret     nc              ; Nothing to do, either 
12bc e6 5f		                and     $5f             ; Convert to upper case 
12be c9			                ret 
12bf			 
12bf			 
12bf			to_lower: 
12bf			 
12bf			   ; if char is in [A-Z] make it lower case 
12bf			 
12bf			   ; enter : a = char 
12bf			   ; exit  : a = lower case char 
12bf			   ; uses  : af 
12bf			 
12bf fe 41		   cp 'A' 
12c1 d8			   ret c 
12c2			    
12c2 fe 5b		   cp 'Z'+1 
12c4 d0			   ret nc 
12c5			    
12c5 f6 20		   or $20 
12c7 c9			   ret 
12c8			 
12c8			; 
12c8			; Expects a hexadecimal digit (upper case!) in A and returns the 
12c8			; corresponding value in A. 
12c8			; 
12c8 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
12ca 38 02		                jr      c, nibble2val_1 ; Yes 
12cc d6 07		                sub     7               ; Adjust for A-F 
12ce d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
12d0 e6 0f		                and     $f              ; Only return lower 4 bits 
12d2 c9			                ret 
12d3			; 
12d3			; Print_nibble prints a single hex nibble which is contained in the lower  
12d3			; four bits of A: 
12d3			; 
12d3			;print_nibble    push    af              ; We won't destroy the contents of A 
12d3			;                and     $f              ; Just in case... 
12d3			;                add     a, '0'             ; If we have a digit we are done here. 
12d3			;                cp      '9' + 1         ; Is the result > 9? 
12d3			;                jr      c, print_nibble_1 
12d3			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
12d3			;print_nibble_1  call    putc            ; Print the nibble and 
12d3			;                pop     af              ; restore the original value of A 
12d3			;                ret 
12d3			;; 
12d3			;; Send a CR/LF pair: 
12d3			; 
12d3			;crlf            push    af 
12d3			;                ld      a, cr 
12d3			;                call    putc 
12d3			;                ld      a, lf 
12d3			;                call    putc 
12d3			;                pop     af 
12d3			;                ret 
12d3			; 
12d3			; Print_word prints the four hex digits of a word to the serial line. The  
12d3			; word is expected to be in HL. 
12d3			; 
12d3			;print_word      push    hl 
12d3			;                push    af 
12d3			;                ld      a, h 
12d3			;                call    print_byte 
12d3			;                ld      a, l 
12d3			;                call    print_byte 
12d3			;                pop     af 
12d3			;                pop     hl 
12d3			;                ret 
12d3			; 
12d3			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
12d3			; The byte to be printed is expected to be in A. 
12d3			; 
12d3			;print_byte      push    af              ; Save the contents of the registers 
12d3			;                push    bc 
12d3			;                ld      b, a 
12d3			;                rrca 
12d3			;                rrca 
12d3			;                rrca 
12d3			;                rrca 
12d3			;                call    print_nibble    ; Print high nibble 
12d3			;                ld      a, b 
12d3			;                call    print_nibble    ; Print low nibble 
12d3			;                pop     bc              ; Restore original register contents 
12d3			;                pop     af 
12d3			;                ret 
12d3			 
12d3			 
12d3			 
12d3			 
12d3			 
12d3			fourehexhl:  
12d3 7e				ld a,(hl) 
12d4 cd 82 12			call atohex 
12d7 cb 3f				SRL A 
12d9 cb 3f				SRL A 
12db cb 3f				SRL A 
12dd cb 3f				SRL A 
12df 47				ld b, a 
12e0 23				inc hl 
12e1 7e				ld a,(hl) 
12e2 23				inc hl 
12e3 cd 82 12			call atohex 
12e6 80				add b 
12e7 57				ld d,a 
12e8 7e				ld a,(hl) 
12e9 cd 82 12			call atohex 
12ec cb 3f				SRL A 
12ee cb 3f				SRL A 
12f0 cb 3f				SRL A 
12f2 cb 3f				SRL A 
12f4 47				ld b, a 
12f5 23				inc hl 
12f6 7e				ld a,(hl) 
12f7 23				inc hl 
12f8 cd 82 12			call atohex 
12fb 80				add b 
12fc 5f				ld e, a 
12fd d5				push de 
12fe e1				pop hl 
12ff c9				ret 
1300			 
1300			; pass hl. returns z set if the byte at hl is a digit 
1300			;isdigithl:  
1300			;	push bc 
1300			;	ld a,(hl) 
1300			;	cp ':' 
1300			;	jr nc, .isdf 		; > 
1300			;	cp '0' 
1300			;	jr c, .isdf		; < 
1300			; 
1300			;	; TODO find a better way to set z 
1300			; 
1300			;	ld b,a 
1300			;	cp b 
1300			;	pop bc 
1300			;	ret 
1300			; 
1300			;.isdf:	; not digit so clear z 
1300			; 
1300			;	; TODO find a better way to unset z 
1300			; 
1300			;	ld b,a 
1300			;	inc b 
1300			;	cp b 
1300			; 
1300			;	pop bc 
1300			;	ret 
1300				 
1300				 
1300			 
1300			 
1300			; pass hl as the four byte address to load 
1300			 
1300			get_word_hl:  
1300 e5				push hl 
1301 cd a0 12			call get_byte 
1304				 
1304 47				ld b, a 
1305			 
1305 e1				pop hl 
1306 23				inc hl 
1307 23				inc hl 
1308			 
1308			; TODO not able to handle a-f  
1308 7e				ld a,(hl) 
1309			;	;cp ':' 
1309			;	cp 'g' 
1309			;	jr nc, .single_byte_hl 		; > 
1309			;	cp 'G' 
1309			;	jr nc, .single_byte_hl 		; > 
1309			;	cp '0' 
1309			;	jr c, .single_byte_hl		; < 
1309			 
1309				;call isdigithl 
1309 fe 00			cp 0 
130b 28 06			jr z, .single_byte_hl 
130d			 
130d			.getwhln:   ; hex word so get next byte 
130d			 
130d cd a0 12			call get_byte 
1310 6f				ld l, a 
1311 60				ld h,b 
1312 c9				ret 
1313 68			.single_byte_hl:   ld l,b 
1314 26 00				ld h,0 
1316 c9					ret 
1317			 
1317			 
1317			 
1317			 
1317 21 51 1c			ld hl,asc+1 
131a			;	ld a, (hl) 
131a			;	call nibble2val 
131a cd a0 12			call get_byte 
131d			 
131d			;	call fourehexhl 
131d 32 b6 f3			ld (scratch+52),a 
1320				 
1320 21 b4 f3			ld hl,scratch+50 
1323 22 a5 f6			ld (os_cur_ptr),hl 
1326			 
1326 c9				ret 
1327			 
1327			 
1327			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
1327			 
1327			; Decimal Unsigned Version 
1327			 
1327			;Number in a to decimal ASCII 
1327			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
1327			;Example: display a=56 as "056" 
1327			;input: a = number 
1327			;Output: a=0,value of a in the screen 
1327			;destroys af,bc (don't know about hl and de) 
1327			DispAToASCII: 
1327 0e 9c			ld	c,-100 
1329 cd 33 13			call	.Na1 
132c 0e f6			ld	c,-10 
132e cd 33 13			call	.Na1 
1331 0e ff			ld	c,-1 
1333 06 2f		.Na1:	ld	b,'0'-1 
1335 04			.Na2:	inc	b 
1336 81				add	a,c 
1337 38 fc			jr	c,.Na2 
1339 91				sub	c		;works as add 100/10/1 
133a f5				push af		;safer than ld c,a 
133b 78				ld	a,b		;char is in b 
133c			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
133c f1				pop af		;safer than ld a,c 
133d c9				ret 
133e			 
133e			; Decimal Signed Version 
133e			 
133e			; DispA 
133e			; -------------------------------------------------------------- 
133e			; Converts a signed integer value to a zero-terminated ASCII 
133e			; string representative of that value (using radix 10). 
133e			; -------------------------------------------------------------- 
133e			; INPUTS: 
133e			;     HL     Value to convert (two's complement integer). 
133e			;     DE     Base address of string destination. (pointer). 
133e			; -------------------------------------------------------------- 
133e			; OUTPUTS: 
133e			;     None 
133e			; -------------------------------------------------------------- 
133e			; REGISTERS/MEMORY DESTROYED 
133e			; AF HL 
133e			; -------------------------------------------------------------- 
133e			 
133e			;DispHLToASCII: 
133e			;   push    de 
133e			;   push    bc 
133e			; 
133e			;; Detect sign of HL. 
133e			;    bit    7, h 
133e			;    jr     z, ._DoConvert 
133e			; 
133e			;; HL is negative. Output '-' to string and negate HL. 
133e			;    ld     a, '-' 
133e			;    ld     (de), a 
133e			;    inc    de 
133e			; 
133e			;; Negate HL (using two's complement) 
133e			;    xor    a 
133e			;    sub    l 
133e			;    ld     l, a 
133e			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
133e			;    sbc    a, h 
133e			;    ld     h, a 
133e			; 
133e			;; Convert HL to digit characters 
133e			;._DoConvert: 
133e			;    ld     b, 0     ; B will count character length of number 
133e			;-   ld     a, 10 
133e			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
133e			;    push   af 
133e			;    inc    b 
133e			;    ld     a, h 
133e			;    or     l 
133e			;    jr     nz, - 
133e			; 
133e			;; Retrieve digits from stack 
133e			;-   pop    af 
133e			;    or     $30 
133e			;    ld     (de), a 
133e			;    inc    de 
133e			;    djnz   - 
133e			; 
133e			;; Terminate string with NULL 
133e			;    xor    a 
133e			;    ld     (de), a 
133e			; 
133e			;    pop    bc 
133e			;    pop    de 
133e			;    ret 
133e			 
133e			;Comments 
133e			; 
133e			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
133e			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
133e			;    Note that the output string will not be fixed-width. 
133e			; 
133e			;Example Usage 
133e			; 
133e			;    ld    hl, -1004 
133e			;    ld    de, OP1 
133e			;    call  DispA 
133e			;    ld    hl, OP1 
133e			;    syscall  PutS 
133e			 
133e			 
133e			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
133e			 
133e			 
133e			;Converts an ASCII string to an unsigned 16-bit integer 
133e			;Quits when it reaches a non-decimal digit 
133e			 
133e			string_to_uint16: 
133e			atoui_16: 
133e			;Input: 
133e			;     DE points to the string 
133e			;Outputs: 
133e			;     HL is the result 
133e			;     A is the 8-bit value of the number 
133e			;     DE points to the byte after the number 
133e			;Destroys: 
133e			;     BC 
133e			;       if the string is non-empty, BC is HL/10 
133e			;Size:  24 bytes 
133e			;Speed: 42+d(104+{0,9}) 
133e			;       d is the number of digits in the number 
133e			;       max is 640 cycles for a 5 digit number 
133e			;Assuming no leading zeros: 
133e			;1 digit:  146cc 
133e			;2 digit:  250cc 
133e			;3 digit:  354cc or 363cc (avg: 354.126cc) 
133e			;4 digit:  458cc or 467cc (avg: 458.27cc) 
133e			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
133e			;avg: 544.81158447265625cc (544+13297/16384) 
133e			;=============================================================== 
133e 21 00 00		  ld hl,0 
1341			.u16a: 
1341 1a			  ld a,(de) 
1342 d6 30		  sub 30h 
1344 fe 0a		  cp 10 
1346 d0			  ret nc 
1347 13			  inc de 
1348 44			  ld b,h 
1349 4d			  ld c,l 
134a 29			  add hl,hl 
134b 29			  add hl,hl 
134c 09			  add hl,bc 
134d 29			  add hl,hl 
134e 85			  add a,l 
134f 6f			  ld l,a 
1350 30 ef		  jr nc,.u16a 
1352 24			  inc h 
1353 c3 41 13		  jp .u16a 
1356			 
1356			 
1356			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
1356			 
1356			;written by Zeda 
1356			;Converts a 16-bit unsigned integer to an ASCII string. 
1356			 
1356			uitoa_16: 
1356			;Input: 
1356			;   DE is the number to convert 
1356			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
1356			;Output: 
1356			;   HL points to the null-terminated ASCII string 
1356			;      NOTE: This isn't necessarily the same as the input HL. 
1356 d5			  push de 
1357 c5			  push bc 
1358 f5			  push af 
1359 eb			  ex de,hl 
135a			 
135a 01 f0 d8		  ld bc,-10000 
135d 3e 2f		  ld a,'0'-1 
135f 3c			  inc a 
1360 09			  add hl,bc  
1361 38 fc		   jr c,$-2 
1363 12			  ld (de),a 
1364 13			  inc de 
1365			 
1365 01 e8 03		  ld bc,1000 
1368 3e 3a		  ld a,'9'+1 
136a 3d			  dec a  
136b 09			  add hl,bc  
136c 30 fc		   jr nc,$-2 
136e 12			  ld (de),a 
136f 13			  inc de 
1370			 
1370 01 9c ff		  ld bc,-100 
1373 3e 2f		  ld a,'0'-1 
1375 3c			  inc a  
1376 09			  add hl,bc  
1377 38 fc		   jr c,$-2 
1379 12			  ld (de),a 
137a 13			  inc de 
137b			 
137b 7d			  ld a,l 
137c 26 3a		  ld h,'9'+1 
137e 25			  dec h  
137f c6 0a		  add a,10  
1381 30 fb		   jr nc,$-3 
1383 c6 30		  add a,'0' 
1385 eb			  ex de,hl 
1386 72			  ld (hl),d 
1387 23			  inc hl 
1388 77			  ld (hl),a 
1389 23			  inc hl 
138a 36 00		  ld (hl),0 
138c			 
138c			;Now strip the leading zeros 
138c 0e fa		  ld c,-6 
138e 09			  add hl,bc 
138f 3e 30		  ld a,'0' 
1391 23			  inc hl  
1392 be			  cp (hl)  
1393 28 fc		  jr z,$-2 
1395			 
1395			;Make sure that the string is non-empty! 
1395 7e			  ld a,(hl) 
1396 b7			  or a 
1397 20 01		  jr nz,.atoub 
1399 2b			  dec hl 
139a			.atoub: 
139a			 
139a f1			  pop af 
139b c1			  pop bc 
139c d1			  pop de 
139d c9			  ret 
139e			 
139e			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
139e			 
139e			toUpper: 
139e			;A is the char. 
139e			;If A is a lowercase letter, this sets it to the matching uppercase 
139e			;18cc or 30cc or 41cc 
139e			;avg: 26.75cc 
139e fe 61		  cp 'a' 
13a0 d8			  ret c 
13a1 fe 7b		  cp 'z'+1 
13a3 d0			  ret nc 
13a4 d6 20		  sub 'a'-'A' 
13a6 c9			  ret 
13a7			 
13a7			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
13a7			 
13a7			; String Length 
13a7			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
13a7			 
13a7			; Get the length of the null-terminated string starting at $8000 hl 
13a7			;    LD     HL, $8000 
13a7			 
13a7			strlenz: 
13a7			 
13a7 af			    XOR    A               ; Zero is the value we are looking for. 
13a8 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
13a9 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
13aa			                           ; 65, 536 bytes (the entire addressable memory space). 
13aa ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
13ac			 
13ac			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
13ac 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
13ad 6f			    LD     L, A             ; number of bytes 
13ae ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
13b0 2b			    DEC    HL              ; Compensate for null. 
13b1 c9				ret 
13b2			 
13b2			; Get the length of the A terminated string starting at $8000 hl 
13b2			;    LD     HL, $8000 
13b2			 
13b2			strlent: 
13b2			 
13b2			                  ; A is the value we are looking for. 
13b2 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
13b4 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
13b6			                           ; 65, 536 bytes (the entire addressable memory space). 
13b6 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
13b8			 
13b8			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
13b8 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
13ba 2e 00		    LD     L, 0             ; number of bytes 
13bc ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
13be 2b			    DEC    HL              ; Compensate for null. 
13bf c9				ret 
13c0			 
13c0			 
13c0			;Comparing Strings 
13c0			 
13c0			;IN    HL     Address of string1. 
13c0			;      DE     Address of string2. 
13c0			 
13c0			; doc given but wrong??? 
13c0			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
13c0			;      carry  Set if string1 > string2, reset if string1 <= string2. 
13c0			; tested 
13c0			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
13c0			 
13c0			strcmp_old: 
13c0 e5			    PUSH   HL 
13c1 d5			    PUSH   DE 
13c2			 
13c2 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
13c3 be			    CP     (HL)            ; (want to minimize work). 
13c4 38 01		    JR     C, Str1IsBigger 
13c6 7e			    LD     A, (HL) 
13c7			 
13c7			Str1IsBigger: 
13c7 4f			    LD     C, A             ; Put length in BC 
13c8 06 00		    LD     B, 0 
13ca 13			    INC    DE              ; Increment pointers to meat of string. 
13cb 23			    INC    HL 
13cc			 
13cc			CmpLoop: 
13cc 1a			    LD     A, (DE)          ; Compare bytes. 
13cd ed a1		    CPI 
13cf 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
13d1 13			    INC    DE              ; Update pointer. 
13d2 ea cc 13		    JP     PE, CmpLoop 
13d5			 
13d5 d1			    POP    DE 
13d6 e1			    POP    HL 
13d7 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
13d8 be			    CP     (HL) 
13d9 c9			    RET 
13da			 
13da			NoMatch: 
13da 2b			    DEC    HL 
13db be			    CP     (HL)            ; Compare again to affect carry. 
13dc d1			    POP    DE 
13dd e1			    POP    HL 
13de c9			    RET 
13df			 
13df			;; test strmp 
13df			; 
13df			;ld de, .str1 
13df			;ld hl, .str2 
13df			;call strcmp 
13df			;jr z, .z1 
13df			;;this 
13df			;	if DEBUG_FORTH_WORDS 
13df			;		DMARK "NZ1" 
13df			;		CALLMONITOR 
13df			;	endif 
13df			;.z1: 
13df			; 
13df			;	if DEBUG_FORTH_WORDS 
13df			;		DMARK "ZZ1" 
13df			;		CALLMONITOR 
13df			;	endif 
13df			; 
13df			;ld de, .str1 
13df			;ld hl, .str1 
13df			;call strcmp 
13df			;jr z, .z2 
13df			;;this 
13df			;	if DEBUG_FORTH_WORDS 
13df			;		DMARK "NZ2" 
13df			;		CALLMONITOR 
13df			;	endif 
13df			;.z2: 
13df			; 
13df			;	if DEBUG_FORTH_WORDS 
13df			;		DMARK "ZZ2" 
13df			;		CALLMONITOR 
13df			;	endif 
13df			; 
13df			;ld de, .str1 
13df			;ld hl, .str2 
13df			;call strcmp 
13df			;jr c, .c1 
13df			; 
13df			;	if DEBUG_FORTH_WORDS 
13df			;		DMARK "Nc1" 
13df			;		CALLMONITOR 
13df			;	endif 
13df			;.c1: 
13df			;;this 
13df			;	if DEBUG_FORTH_WORDS 
13df			;		DMARK "cc1" 
13df			;		CALLMONITOR 
13df			;	endif 
13df			; 
13df			;ld de, .str1 
13df			;ld hl, .str1 
13df			;call strcmp 
13df			;jr c, .c2 
13df			;;this 
13df			;	if DEBUG_FORTH_WORDS 
13df			;		DMARK "Nc2" 
13df			;		CALLMONITOR 
13df			;	endif 
13df			;.c2: 
13df			; 
13df			;	if DEBUG_FORTH_WORDS 
13df			;		DMARK "cc2" 
13df			;		CALLMONITOR 
13df			;	endif 
13df			;	NEXTW 
13df			;.str1:   db "string1",0 
13df			;.str2:   db "string2",0 
13df			 
13df			; only care about direct match or not 
13df			; hl and de strings 
13df			; zero set if the same 
13df			 
13df			strcmp: 
13df 1a				ld a, (de) 
13e0 be				cp (hl) 
13e1 28 02			jr z, .ssame 
13e3 b7				or a 
13e4 c9				ret 
13e5			 
13e5			.ssame:  
13e5 fe 00			cp 0 
13e7 c8				ret z 
13e8			 
13e8 23				inc hl 
13e9 13				inc de 
13ea 18 f3			jr strcmp 
13ec				 
13ec				 
13ec			 
13ec			 
13ec			 
13ec			 
13ec			; eof 
13ec			 
13ec			 
13ec			 
13ec			 
13ec			 
13ec			 
# End of file firmware_strings.asm
13ec			include "firmware_memory.asm"   ; malloc and free  
13ec			 
13ec			if DEBUG_FORTH_MALLOC_HIGH 
13ec			.mallocsize: db "Wants malloc >256",0 
13ec			.mallocasize: db "MALLOC gives >256",0 
13ec			.malloczero: db "MALLOC gives zero",0 
13ec			 
13ec			malloc_guard_zerolen: 
13ec				push hl 
13ec				push de 
13ec				push af 
13ec			 
13ec				ld de, 0 
13ec			        call cmp16 
13ec				jr nz, .lowalloz 
13ec			 
13ec				push hl 
13ec				push de 
13ec					ld hl, display_fb0 
13ec					ld (display_fb_active), hl 
13ec				call clear_display 
13ec				ld a, 0 
13ec				ld de, .malloczero 
13ec				call str_at_display 
13ec				call update_display 
13ec				call delay1s 
13ec				call delay1s 
13ec				ld a, 0 
13ec				ld (os_view_disable), a 
13ec			 
13ec				pop de 
13ec				pop hl 
13ec			 
13ec				 
13ec			 
13ec				CALLMONITOR 
13ec			.lowalloz: 
13ec			 
13ec			 
13ec				pop af 
13ec				pop de 
13ec				pop hl 
13ec			ret 
13ec			 
13ec			malloc_guard_entry: 
13ec				push hl 
13ec				push de 
13ec				push af 
13ec			 
13ec			 	or a      ;clear carry flag 
13ec				push hl 
13ec				ld de, 255 
13ec				sbc hl, de 
13ec				jr c, .lowalloc 
13ec			 
13ec				push de 
13ec					ld hl, display_fb0 
13ec					ld (display_fb_active), hl 
13ec				call clear_display 
13ec				ld a, 0 
13ec				ld de, .mallocsize 
13ec				call str_at_display 
13ec				call update_display 
13ec				call delay1s 
13ec				call delay1s 
13ec				ld a, 0 
13ec				ld (os_view_disable), a 
13ec			 
13ec				pop de 
13ec				pop hl 
13ec			 
13ec				 
13ec			 
13ec				CALLMONITOR 
13ec				jr .lowdone 
13ec			.lowalloc: 
13ec			 
13ec			 
13ec				pop hl 
13ec			.lowdone:	pop af 
13ec				pop de 
13ec				pop hl 
13ec			ret 
13ec			 
13ec			malloc_guard_exit: 
13ec				push hl 
13ec				push de 
13ec				push af 
13ec			 
13ec			 	or a      ;clear carry flag 
13ec				push hl 
13ec				ld de, 255 
13ec				sbc hl, de 
13ec				jr c, .lowallocx 
13ec			 
13ec				push de 
13ec					ld hl, display_fb0 
13ec					ld (display_fb_active), hl 
13ec				call clear_display 
13ec				ld a, 0 
13ec				ld de, .mallocasize 
13ec				call str_at_display 
13ec				call update_display 
13ec				call delay1s 
13ec				call delay1s 
13ec				ld a, 0 
13ec				ld (os_view_disable), a 
13ec				pop de 
13ec				pop hl 
13ec			 
13ec				CALLMONITOR 
13ec				jr .lowdonex 
13ec			.lowallocx: 
13ec			 
13ec				pop hl 
13ec			.lowdonex:	pop af 
13ec				pop de 
13ec				pop hl 
13ec			ret 
13ec			endif 
13ec			 
13ec			if MALLOC_2 
13ec			; Z80 Malloc and Free Functions 
13ec			 
13ec			; Malloc Function: 
13ec			; Input: 
13ec			;   HL: Size of block to allocate 
13ec			; Output: 
13ec			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
13ec			 
13ec			malloc: 
13ec				 
13ec			if DEBUG_FORTH_MALLOC_HIGH 
13ec			call malloc_guard_entry 
13ec			endif 
13ec			 
13ec			 
13ec			 
13ec			 
13ec					if DEBUG_FORTH_MALLOC 
13ec						DMARK "mal" 
13ec						CALLMONITOR 
13ec					endif 
13ec			    push af            ; Save AF register 
13ec			    ld a, l            ; Load low byte of size into A 
13ec			    or h               ; Check if size is zero 
13ec			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
13ec			 
13ec			    ; Allocate memory 
13ec			    ld hl, (heap_start) ; Load start of heap into HL 
13ec					if DEBUG_FORTH_MALLOC 
13ec						DMARK "ma1" 
13ec						CALLMONITOR 
13ec					endif 
13ec			    call malloc_internal ; Call internal malloc function 
13ec			    pop af             ; Restore AF register 
13ec			if DEBUG_FORTH_MALLOC_HIGH 
13ec			call malloc_guard_exit 
13ec			call malloc_guard_zerolen 
13ec			endif 
13ec			    ret                ; Return 
13ec			 
13ec			; Free Function: 
13ec			; Input: 
13ec			;   HL: Pointer to memory block to free 
13ec			; Output: 
13ec			;   None 
13ec			 
13ec			free: 
13ec			    push af            ; Save AF register 
13ec			    ld a, l            ; Load low byte of pointer into A 
13ec			    or h               ; Check if pointer is NULL 
13ec			    jp z, free_exit    ; If pointer is NULL, exit 
13ec			 
13ec			    ; Free memory 
13ec			    ld hl, (heap_start) ; Load start of heap into HL 
13ec			    call free_internal  ; Call internal free function 
13ec			    pop af             ; Restore AF register 
13ec			    ret                ; Return 
13ec			 
13ec			; Internal Malloc Function: 
13ec			; Input: 
13ec			;   HL: Size of block to allocate 
13ec			; Output: 
13ec			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
13ec			 
13ec			malloc_internal: 
13ec			    ld bc, 2           ; Number of bytes to allocate for management overhead 
13ec			    add hl, bc         ; Add management overhead to requested size 
13ec			    ex de, hl          ; Save total size in DE, and keep it in HL 
13ec					if DEBUG_FORTH_MALLOC 
13ec						DMARK "ma2" 
13ec						CALLMONITOR 
13ec					endif 
13ec			 
13ec			    ; Search for free memory block 
13ec			    ld de, (heap_end)  ; Load end of heap into DE 
13ec			    ld bc, 0           ; Initialize counter 
13ec			 
13ec					if DEBUG_FORTH_MALLOC 
13ec						DMARK "ma2" 
13ec						CALLMONITOR 
13ec					endif 
13ec			malloc_search_loop: 
13ec			    ; Check if current block is free 
13ec			    ld a, (hl)         ; Load current block's status (free or used) 
13ec			    cp 0               ; Compare with zero (free) 
13ec			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
13ec			 
13ec			    ; Check if current block is large enough 
13ec			    ld a, (hl+1)       ; Load high byte of block size 
13ec			    cp l               ; Compare with low byte of requested size 
13ec			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
13ec			 
13ec			    ld a, (hl+2)       ; Load low byte of block size 
13ec			    cp h               ; Compare with high byte of requested size 
13ec			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
13ec			 
13ec			    ; Mark block as used 
13ec			    ld (hl), 0xFF      ; Set status byte to indicate used block 
13ec			 
13ec			    ; Calculate remaining space in block 
13ec			    ld bc, 0           ; Clear BC 
13ec			    add hl, bc         ; Increment HL to point to start of data block 
13ec			    add hl, de         ; HL = HL + DE (total size) 
13ec			    ld bc, 1           ; Number of bytes to allocate for management overhead 
13ec			    add hl, bc         ; Add management overhead to start of data block 
13ec			 
13ec			    ; Save pointer to allocated block in HL 
13ec			if DEBUG_FORTH_MALLOC_HIGH 
13ec						DMARK "ma5" 
13ec			call malloc_guard_exit 
13ec			call malloc_guard_zerolen 
13ec			endif 
13ec			    ret 
13ec			 
13ec			malloc_skip_block_check: 
13ec			    ; Move to the next block 
13ec			    ld bc, 3           ; Size of management overhead 
13ec			    add hl, bc         ; Move to the next block 
13ec			    inc de             ; Increment counter 
13ec			 
13ec			    ; Check if we have reached the end of heap 
13ec			    ld a, e            ; Load low byte of heap end address 
13ec			    cp (hl)            ; Compare with low byte of current address 
13ec			    jr nz, malloc_search_loop  ; If not equal, continue searching 
13ec			    ld a, d            ; Load high byte of heap end address 
13ec			    cp 0               ; Check if it's zero (end of memory) 
13ec			    jr nz, malloc_search_loop  ; If not zero, continue searching 
13ec			 
13ec			    ; If we reached here, allocation failed 
13ec			    xor a              ; Set result to NULL 
13ec			if DEBUG_FORTH_MALLOC_HIGH 
13ec						DMARK "ma6" 
13ec			call malloc_guard_exit 
13ec			call malloc_guard_zerolen 
13ec			endif 
13ec			    ret 
13ec			malloc_exit: 
13ec			if DEBUG_FORTH_MALLOC_HIGH 
13ec						DMARK "ma7" 
13ec			call malloc_guard_exit 
13ec			call malloc_guard_zerolen 
13ec			endif 
13ec			    ret 
13ec			 
13ec			; Internal Free Function: 
13ec			; Input: 
13ec			;   HL: Pointer to memory block to free 
13ec			; Output: 
13ec			;   None 
13ec			 
13ec			free_internal: 
13ec			    ld de, (heap_start) ; Load start of heap into DE 
13ec			    ld bc, 0            ; Initialize counter 
13ec			 
13ec			free_search_loop: 
13ec			    ; Check if current block contains the pointer 
13ec			    ld a, l             ; Load low byte of pointer 
13ec			    cp (hl+1)           ; Compare with high byte of current block's address 
13ec			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
13ec			    ld a, h             ; Load high byte of pointer 
13ec			    cp (hl+2)           ; Compare with low byte of current block's address 
13ec			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
13ec			 
13ec			    ; Mark block as free 
13ec			    ld (hl), 0          ; Set status byte to indicate free block 
13ec			    ret                 ; Return 
13ec			 
13ec			free_skip_block_check: 
13ec			    ; Move to the next block 
13ec			    ld bc, 3            ; Size of management overhead 
13ec			    add hl, bc          ; Move to the next block 
13ec			    inc de              ; Increment counter 
13ec			 
13ec			    ; Check if we have reached the end of heap 
13ec			    ld a, e             ; Load low byte of heap end address 
13ec			    cp (hl)             ; Compare with low byte of current address 
13ec			    jr nz, free_search_loop  ; If not equal, continue searching 
13ec			    ld a, d             ; Load high byte of heap end address 
13ec			    cp 0                ; Check if it's zero (end of memory) 
13ec			    jr nz, free_search_loop  ; If not zero, continue searching 
13ec			 
13ec			    ; If we reached here, pointer is not found in heap 
13ec			    ret 
13ec			 
13ec			free_exit: 
13ec			    ret                 ; Return 
13ec			 
13ec			; Define heap start and end addresses 
13ec			;heap_start:    .dw 0xC000   ; Start of heap 
13ec			;heap_end:      .dw 0xE000   ; End of heap 
13ec			 
13ec			endif 
13ec			 
13ec			 
13ec			if MALLOC_1 
13ec			 
13ec			 
13ec			 
13ec			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
13ec			 
13ec			;moved to firmware.asm 
13ec			;heap_start        .equ  0x9000      ; Starting address of heap 
13ec			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
13ec			 
13ec			;      .org 0 
13ec			;      jp    main 
13ec			 
13ec			 
13ec			;      .org  0x100 
13ec			;main: 
13ec			;      ld    HL, 0x8100 
13ec			;      ld    SP, HL 
13ec			; 
13ec			;      call  heap_init 
13ec			; 
13ec			;      ; Make some allocations 
13ec			;      ld    HL, 12 
13ec			;      call  malloc            ; Allocates 0x9004 
13ec			; 
13ec			;      ld    HL, 12 
13ec			;      call  malloc            ; Allocates 0x9014 
13ec			; 
13ec			;      ld    HL, 12 
13ec			;      call  malloc            ; Allocates 0x9024 
13ec			; 
13ec			;      ; Free some allocations 
13ec			;      ld    HL, 0x9014 
13ec			;      call  free 
13ec			; 
13ec			;      ld    HL, 0x9004 
13ec			;      call  free 
13ec			; 
13ec			;      ld    HL, 0x9024 
13ec			;      call  free 
13ec			; 
13ec			; 
13ec			;      halt 
13ec			 
13ec			 
13ec			;------------------------------------------------------------------------------ 
13ec			;     heap_init                                                               : 
13ec			;                                                                             : 
13ec			; Description                                                                 : 
13ec			;     Initialise the heap and make it ready for malloc and free operations.   : 
13ec			;                                                                             : 
13ec			;     The heap is maintained as a linked list, starting with an initial       : 
13ec			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
13ec			;     the first free block in the heap. Each block then points to the next    : 
13ec			;     free block within the heap, and the free list ends at the first block   : 
13ec			;     with a null pointer to the next free block.                             : 
13ec			;                                                                             : 
13ec			; Parameters                                                                  : 
13ec			;     Inputs are compile-time only. Two defines which specify the starting    : 
13ec			;     address of the heap and its size are required, along with a memory      : 
13ec			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
13ec			;     principally stores a pointer to the first free block in the heap.       : 
13ec			;                                                                             : 
13ec			; Returns                                                                     : 
13ec			;     Nothing                                                                 : 
13ec			;------------------------------------------------------------------------------ 
13ec			heap_init: 
13ec e5			      push  HL 
13ed			 
13ed			      ; Initialise free list struct 
13ed 21 0e 80		      ld    HL, heap_start 
13f0 22 0a 80		      ld    (free_list), HL 
13f3 21 00 00		      ld    HL, 0 
13f6 22 0c 80		      ld    (free_list+2), HL 
13f9			 
13f9			      ; Insert first free block at bottom of heap, consumes entire heap 
13f9 21 0a 80		      ld    HL, heap_start+heap_size-4 
13fc 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
13ff 21 fc ff		      ld    HL, heap_size-4 
1402 22 10 80		      ld    (heap_start+2), HL      ; Block size 
1405			 
1405			      ; Insert end of free list block at top of heap - two null words will 
1405			      ; terminate the free list 
1405 21 00 00		      ld    HL, 0 
1408 22 0c 80		      ld    (heap_start+heap_size-2), HL 
140b 22 0a 80		      ld    (heap_start+heap_size-4), HL 
140e			 
140e e1			      pop   HL 
140f			 
140f c9			      ret 
1410			 
1410			 
1410			;------------------------------------------------------------------------------ 
1410			;     malloc                                                                  : 
1410			;                                                                             : 
1410			; Description                                                                 : 
1410			;     Allocates the wanted space from the heap and returns the address of the : 
1410			;     first useable byte of the allocation.                                   : 
1410			;                                                                             : 
1410			;     Allocations can happen in one of two ways:                              : 
1410			;                                                                             : 
1410			;     1. A free block may be found which is the exact size wanted. In this    : 
1410			;        case the block is removed from the free list and retuedn to the      : 
1410			;        caller.                                                              : 
1410			;     2. A free block may be found which is larger than the size wanted. In   : 
1410			;        this case, the larger block is split into two. The first portion of  : 
1410			;        this block will become the requested space by the malloc call and    : 
1410			;        is returned to the caller. The second portion becomes a new free     : 
1410			;        block, and the free list is adjusted to maintain continuity via this : 
1410			;        newly created block.                                                 : 
1410			;                                                                             : 
1410			;     malloc does not set any initial value in the allocated space, the       : 
1410			;     caller is required to do this as required.                              : 
1410			;                                                                             : 
1410			;     This implementation of malloc uses the stack exclusively, and is        : 
1410			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1410			;     advisable to disable interrupts before calling malloc, and recommended  : 
1410			;     to avoid the use of malloc inside ISRs in general.                      : 
1410			;                                                                             : 
1410			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1410			;                                                                             : 
1410			; Parameters                                                                  : 
1410			;     HL  Number of bytes wanted                                              : 
1410			;                                                                             : 
1410			; Returns                                                                     : 
1410			;     HL  Address of the first useable byte of the allocation                 : 
1410			;                                                                             : 
1410			; Flags                                                                       : 
1410			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1410			;                                                                             : 
1410			; Stack frame                                                                 : 
1410			;       |             |                                                       : 
1410			;       +-------------+                                                       : 
1410			;       |     BC      |                                                       : 
1410			;       +-------------+                                                       : 
1410			;       |     DE      |                                                       : 
1410			;       +-------------+                                                       : 
1410			;       |     IX      |                                                       : 
1410			;       +-------------+                                                       : 
1410			;       |  prev_free  |                                                       : 
1410			;   +4  +-------------+                                                       : 
1410			;       |  this_free  |                                                       : 
1410			;   +2  +-------------+                                                       : 
1410			;       |  next_free  |                                                       : 
1410			;   +0  +-------------+                                                       : 
1410			;       |             |                                                       : 
1410			;                                                                             : 
1410			;------------------------------------------------------------------------------ 
1410			 
1410			 
1410			;malloc: 
1410			; 
1410			;	SAVESP ON 1 
1410			; 
1410			;	call malloc_code 
1410			; 
1410			;	CHECKSP ON 1 
1410			;	ret 
1410			 
1410			 
1410			malloc: 
1410 c5			      push  BC 
1411 d5			      push  DE 
1412 dd e5		      push  IX 
1414			if DEBUG_FORTH_MALLOC_HIGH 
1414			call malloc_guard_entry 
1414			endif 
1414			 
1414					if DEBUG_FORTH_MALLOC 
1414						DMARK "mal" 
1414						CALLMONITOR 
1414					endif 
1414 7c			      ld    A, H                    ; Exit if no space requested 
1415 b5			      or    L 
1416 ca d5 14		      jp    Z, malloc_early_exit 
1419			 
1419			;inc hl 
1419			;inc hl 
1419			;inc hl 
1419			; 
1419			;inc hl 
1419			;inc hl 
1419			;inc hl 
1419			;inc hl 
1419			;inc hl 
1419			;inc hl 
1419			;inc hl 
1419			;inc hl 
1419			;inc hl 
1419			 
1419			 
1419			 
1419			 
1419					if DEBUG_FORTH_MALLOC 
1419						DMARK "maA" 
1419						CALLMONITOR 
1419					endif 
1419			      ; Set up stack frame 
1419 eb			      ex    DE, HL 
141a 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
141d 39			      add   HL, SP 
141e f9			      ld    SP, HL 
141f dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1423 dd 39		      add   IX, SP 
1425			 
1425			      ; Setup initial state 
1425 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
1428 19			      add   HL, DE 
1429			 
1429 44			      ld    B, H                    ; Move want to BC 
142a 4d			      ld    C, L 
142b			 
142b 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
142e dd 75 04		      ld    (IX+4), L 
1431 dd 74 05		      ld    (IX+5), H 
1434			 
1434 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
1435 23			      inc   HL 
1436 56			      ld    D, (HL) 
1437 dd 73 02		      ld    (IX+2), E 
143a dd 72 03		      ld    (IX+3), D 
143d eb			      ex    DE, HL                  ; this_free ptr into HL 
143e			 
143e					if DEBUG_FORTH_MALLOC 
143e						DMARK "maB" 
143e						CALLMONITOR 
143e					endif 
143e			      ; Loop through free block list to find some space 
143e			malloc_find_space: 
143e 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
143f 23			      inc   HL 
1440 56			      ld    D, (HL) 
1441			 
1441 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1442 b3			      or    E 
1443 ca cf 14		      jp    Z, malloc_no_space 
1446			 
1446 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
1449 dd 72 01		      ld    (IX+1), D 
144c			 
144c			      ; Does this block have enough space to make the allocation? 
144c 23			      inc   HL                      ; Load free block size into DE 
144d 5e			      ld    E, (HL) 
144e 23			      inc   HL 
144f 56			      ld    D, (HL) 
1450			 
1450 eb			      ex    DE, HL                  ; Check size of block against want 
1451 b7			      or    A                       ; Ensure carry flag clear 
1452 ed 42		      sbc   HL, BC 
1454 e5			      push  HL                      ; Store the result for later (new block size) 
1455			 
1455 ca a4 14		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1458 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
145a			 
145a			      ; this_free block is not big enough, setup ptrs to test next free block 
145a e1			      pop   HL                      ; Discard previous result 
145b			 
145b dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
145e dd 66 03		      ld    H, (IX+3) 
1461 dd 75 04		      ld    (IX+4), L 
1464 dd 74 05		      ld    (IX+5), H 
1467			 
1467 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
146a dd 66 01		      ld    H, (IX+1) 
146d dd 75 02		      ld    (IX+2), L 
1470 dd 74 03		      ld    (IX+3), H 
1473			 
1473					if DEBUG_FORTH_MALLOC 
1473						DMARK "MA>" 
1473						CALLMONITOR 
1473					endif 
1473 18 c9		      jr    malloc_find_space 
1475			 
1475			      ; split a bigger block into two - requested size and remaining size 
1475			malloc_alloc_split: 
1475					if DEBUG_FORTH_MALLOC 
1475						DMARK "MAs" 
1475						CALLMONITOR 
1475					endif 
1475 eb			      ex    DE, HL                  ; Calculate address of new free block 
1476 2b			      dec   HL 
1477 2b			      dec   HL 
1478 2b			      dec   HL 
1479 09			      add   HL, BC 
147a			 
147a			      ; Create a new block and point it at next_free 
147a dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
147d dd 56 01		      ld    D, (IX+1) 
1480			 
1480 73			      ld    (HL), E                 ; Store next_free ptr into new block 
1481 23			      inc   HL 
1482 72			      ld    (HL), D 
1483			 
1483 d1			      pop   DE                      ; Store size of new block into new block 
1484 23			      inc   HL 
1485 73			      ld    (HL), E 
1486 23			      inc   HL 
1487 72			      ld    (HL), D 
1488			 
1488			      ; Update this_free ptr to point to new block 
1488 2b			      dec   HL 
1489 2b			      dec   HL 
148a 2b			      dec   HL 
148b			 
148b dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
148e dd 56 03		      ld    D, (IX+3) 
1491			 
1491 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1494 dd 74 03		      ld    (IX+3), H 
1497			 
1497			      ; Modify this_free block to be allocation 
1497 eb			      ex    DE, HL 
1498 af			      xor   A                       ; Null the next block ptr of allocated block 
1499 77			      ld    (HL), A 
149a 23			      inc   HL 
149b 77			      ld    (HL), A 
149c			 
149c 23			      inc   HL                      ; Store want size into allocated block 
149d 71			      ld    (HL), C 
149e 23			      inc   HL 
149f 70			      ld    (HL), B 
14a0 23			      inc   HL 
14a1 e5			      push  HL                      ; Address of allocation to return 
14a2			 
14a2 18 19		      jr    malloc_update_links 
14a4			 
14a4			malloc_alloc_fit: 
14a4 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
14a5			 
14a5					if DEBUG_FORTH_MALLOC 
14a5						DMARK "MAf" 
14a5						CALLMONITOR 
14a5					endif 
14a5			      ; Modify this_free block to be allocation 
14a5 eb			      ex    DE, HL 
14a6 2b			      dec   HL 
14a7 2b			      dec   HL 
14a8 2b			      dec   HL 
14a9			 
14a9 af			      xor   A                       ; Null the next block ptr of allocated block 
14aa 77			      ld    (HL), A 
14ab 23			      inc   HL 
14ac 77			      ld    (HL), A 
14ad			 
14ad 23			      inc   HL                      ; Store address of allocation to return 
14ae 23			      inc   HL 
14af 23			      inc   HL 
14b0 e5			      push  HL 
14b1			 
14b1			      ; Copy next_free ptr to this_free, remove allocated block from free list 
14b1 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
14b4 dd 66 01		      ld    H, (IX+1) 
14b7			 
14b7 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
14ba dd 74 03		      ld    (IX+3), H 
14bd			 
14bd			 
14bd			malloc_update_links: 
14bd			      ; Update prev_free ptr to point to this_free 
14bd dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
14c0 dd 66 05		      ld    H, (IX+5) 
14c3			 
14c3 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
14c6 dd 56 03		      ld    D, (IX+3) 
14c9			 
14c9 73			      ld    (HL), E                 ; this_free ptr into prev_free 
14ca 23			      inc   HL 
14cb 72			      ld    (HL), D 
14cc			 
14cc					if DEBUG_FORTH_MALLOC 
14cc						DMARK "Mul" 
14cc						CALLMONITOR 
14cc					endif 
14cc			      ; Clear the Z flag to indicate successful allocation 
14cc 7a			      ld    A, D 
14cd b3			      or    E 
14ce			 
14ce d1			      pop   DE                      ; Address of allocation 
14cf					if DEBUG_FORTH_MALLOC 
14cf						DMARK "MAu" 
14cf						CALLMONITOR 
14cf					endif 
14cf			 
14cf			malloc_no_space: 
14cf 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
14d2 39			      add   HL, SP 
14d3 f9			      ld    SP, HL 
14d4			 
14d4 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
14d5					if DEBUG_FORTH_MALLOC 
14d5						DMARK "MAN" 
14d5						CALLMONITOR 
14d5					endif 
14d5			 
14d5			malloc_early_exit: 
14d5					if DEBUG_FORTH_MALLOC 
14d5						DMARK "MAx" 
14d5						CALLMONITOR 
14d5					endif 
14d5 dd e1		      pop   IX 
14d7 d1			      pop   DE 
14d8 c1			      pop   BC 
14d9			 
14d9			if DEBUG_FORTH_MALLOC_HIGH 
14d9			call malloc_guard_exit 
14d9			call malloc_guard_zerolen 
14d9			endif 
14d9 c9			      ret 
14da			 
14da			 
14da			;------------------------------------------------------------------------------ 
14da			;     free                                                                    : 
14da			;                                                                             : 
14da			; Description                                                                 : 
14da			;     Return the space pointed to by HL to the heap. HL must be an address as : 
14da			;     returned by malloc, otherwise the behaviour is undefined.               : 
14da			;                                                                             : 
14da			;     Where possible, directly adjacent free blocks will be merged together   : 
14da			;     into larger blocks to help ensure that the heap does not become         : 
14da			;     excessively fragmented.                                                 : 
14da			;                                                                             : 
14da			;     free does not clear or set any other value into the freed space, and    : 
14da			;     therefore its contents may be visible through subsequent malloc's. The  : 
14da			;     caller should clear the freed space as required.                        : 
14da			;                                                                             : 
14da			;     This implementation of free uses the stack exclusively, and is          : 
14da			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
14da			;     advisable to disable interrupts before calling free, and recommended    : 
14da			;     to avoid the use of free inside ISRs in general.                        : 
14da			;                                                                             : 
14da			;     NOTE: heap_init must be called before malloc and free can be used.      : 
14da			;                                                                             : 
14da			; Parameters                                                                  : 
14da			;     HL  Pointer to address of first byte of allocation to be freed          : 
14da			;                                                                             : 
14da			; Returns                                                                     : 
14da			;     Nothing                                                                 : 
14da			;                                                                             : 
14da			; Stack frame                                                                 : 
14da			;       |             |                                                       : 
14da			;       +-------------+                                                       : 
14da			;       |     BC      |                                                       : 
14da			;       +-------------+                                                       : 
14da			;       |     DE      |                                                       : 
14da			;       +-------------+                                                       : 
14da			;       |     IX      |                                                       : 
14da			;       +-------------+                                                       : 
14da			;       |  prev_free  |                                                       : 
14da			;   +2  +-------------+                                                       : 
14da			;       |  next_free  |                                                       : 
14da			;   +0  +-------------+                                                       : 
14da			;       |             |                                                       : 
14da			;                                                                             : 
14da			;------------------------------------------------------------------------------ 
14da			free: 
14da c5			      push  BC 
14db d5			      push  DE 
14dc dd e5		      push  IX 
14de			 
14de 7c			      ld    A, H                    ; Exit if ptr is null 
14df b5			      or    L 
14e0 ca a4 15		      jp    Z, free_early_exit 
14e3			 
14e3			      ; Set up stack frame 
14e3 eb			      ex    DE, HL 
14e4 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
14e7 39			      add   HL, SP 
14e8 f9			      ld    SP, HL 
14e9 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
14ed dd 39		      add   IX, SP 
14ef			 
14ef			      ; The address in HL points to the start of the useable allocated space, 
14ef			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
14ef			      ; address of the block itself. 
14ef eb			      ex    DE, HL 
14f0 11 fc ff		      ld    DE, -4 
14f3 19			      add   HL, DE 
14f4			 
14f4			      ; An allocated block must have a null next block pointer in it 
14f4 7e			      ld    A, (HL) 
14f5 23			      inc   HL 
14f6 b6			      or    (HL) 
14f7 c2 9f 15		      jp    NZ, free_done 
14fa			 
14fa 2b			      dec   HL 
14fb			 
14fb 44			      ld    B, H                    ; Copy HL to BC 
14fc 4d			      ld    C, L 
14fd			 
14fd			      ; Loop through the free list to find the first block with an address 
14fd			      ; higher than the block being freed 
14fd 21 0a 80		      ld    HL, free_list 
1500			 
1500			free_find_higher_block: 
1500 5e			      ld    E, (HL)                 ; Load next ptr from free block 
1501 23			      inc   HL 
1502 56			      ld    D, (HL) 
1503 2b			      dec   HL 
1504			 
1504 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
1507 dd 72 01		      ld    (IX+1), D 
150a dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
150d dd 74 03		      ld    (IX+3), H 
1510			 
1510 78			      ld    A, B                    ; Check if DE is greater than BC 
1511 ba			      cp    D                       ; Compare MSB first 
1512 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
1514 30 04		      jr    NC, free_find_higher_block_skip 
1516 79			      ld    A, C 
1517 bb			      cp    E                       ; Then compare LSB 
1518 38 08		      jr    C, free_found_higher_block 
151a			 
151a			free_find_higher_block_skip: 
151a 7a			      ld    A, D                    ; Reached the end of the free list? 
151b b3			      or    E 
151c ca 9f 15		      jp    Z, free_done 
151f			 
151f eb			      ex    DE, HL 
1520			 
1520 18 de		      jr    free_find_higher_block 
1522			 
1522			free_found_higher_block: 
1522			      ; Insert freed block between prev and next free blocks 
1522 71			      ld    (HL), C                 ; Point prev free block to freed block 
1523 23			      inc   HL 
1524 70			      ld    (HL), B 
1525			 
1525 60			      ld    H, B                    ; Point freed block at next free block 
1526 69			      ld    L, C 
1527 73			      ld    (HL), E 
1528 23			      inc   HL 
1529 72			      ld    (HL), D 
152a			 
152a			      ; Check if the freed block is adjacent to the next free block 
152a 23			      inc   HL                      ; Load size of freed block into HL 
152b 5e			      ld    E, (HL) 
152c 23			      inc   HL 
152d 56			      ld    D, (HL) 
152e eb			      ex    DE, HL 
152f			 
152f 09			      add   HL, BC                  ; Add addr of freed block and its size 
1530			 
1530 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
1533 dd 56 01		      ld    D, (IX+1) 
1536			 
1536 b7			      or    A                       ; Clear the carry flag 
1537 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1539 20 22		      jr    NZ, free_check_adjacent_to_prev 
153b			 
153b			      ; Freed block is adjacent to next, merge into one bigger block 
153b eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
153c 5e			      ld    E, (HL) 
153d 23			      inc   HL 
153e 56			      ld    D, (HL) 
153f e5			      push  HL                      ; Save ptr to next block for later 
1540			 
1540 60			      ld    H, B                    ; Store ptr from next block into freed block 
1541 69			      ld    L, C 
1542 73			      ld    (HL), E 
1543 23			      inc   HL 
1544 72			      ld    (HL), D 
1545			 
1545 e1			      pop   HL                      ; Restore ptr to next block 
1546 23			      inc   HL                      ; Load size of next block into DE 
1547 5e			      ld    E, (HL) 
1548 23			      inc   HL 
1549 56			      ld    D, (HL) 
154a d5			      push  DE                      ; Save next block size for later 
154b			 
154b 60			      ld    H, B                    ; Load size of freed block into HL 
154c 69			      ld    L, C 
154d 23			      inc   HL 
154e 23			      inc   HL 
154f 5e			      ld    E, (HL) 
1550 23			      inc   HL 
1551 56			      ld    D, (HL) 
1552 eb			      ex    DE, HL 
1553			 
1553 d1			      pop   DE                      ; Restore size of next block 
1554 19			      add   HL, DE                  ; Add sizes of both blocks 
1555 eb			      ex    DE, HL 
1556			 
1556 60			      ld    H, B                    ; Store new bigger size into freed block 
1557 69			      ld    L, C 
1558 23			      inc   HL 
1559 23			      inc   HL 
155a 73			      ld    (HL), E 
155b 23			      inc   HL 
155c 72			      ld    (HL), D 
155d			 
155d			free_check_adjacent_to_prev: 
155d			      ; Check if the freed block is adjacent to the prev free block 
155d dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
1560 dd 66 03		      ld    H, (IX+3) 
1563			 
1563 23			      inc   HL                      ; Size of prev free block into DE 
1564 23			      inc   HL 
1565 5e			      ld    E, (HL) 
1566 23			      inc   HL 
1567 56			      ld    D, (HL) 
1568 2b			      dec   HL 
1569 2b			      dec   HL 
156a 2b			      dec   HL 
156b			 
156b 19			      add   HL, DE                  ; Add prev block addr and size 
156c			 
156c b7			      or    A                       ; Clear the carry flag 
156d ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
156f 20 2e		      jr    NZ, free_done 
1571			 
1571			      ; Freed block is adjacent to prev, merge into one bigger block 
1571 60			      ld    H, B                    ; Load next ptr from freed block into DE 
1572 69			      ld    L, C 
1573 5e			      ld    E, (HL) 
1574 23			      inc   HL 
1575 56			      ld    D, (HL) 
1576 e5			      push  HL                      ; Save freed block ptr for later 
1577			 
1577 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
157a dd 66 03		      ld    H, (IX+3) 
157d 73			      ld    (HL), E 
157e 23			      inc   HL 
157f 72			      ld    (HL), D 
1580			 
1580 e1			      pop   HL                      ; Restore freed block ptr 
1581 23			      inc   HL                      ; Load size of freed block into DE 
1582 5e			      ld    E, (HL) 
1583 23			      inc   HL 
1584 56			      ld    D, (HL) 
1585 d5			      push  DE                      ; Save freed block size for later 
1586			 
1586 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1589 dd 66 03		      ld    H, (IX+3) 
158c 23			      inc   HL 
158d 23			      inc   HL 
158e 5e			      ld    E, (HL) 
158f 23			      inc   HL 
1590 56			      ld    D, (HL) 
1591			 
1591 e1			      pop   HL                      ; Add sizes of both blocks 
1592 19			      add   HL, DE 
1593 eb			      ex    DE, HL 
1594			 
1594 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1597 dd 66 03		      ld    H, (IX+3) 
159a 23			      inc   HL 
159b 23			      inc   HL 
159c 73			      ld    (HL), E 
159d 23			      inc   HL 
159e 72			      ld    (HL), D 
159f			 
159f			free_done: 
159f 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
15a2 39			      add   HL, SP 
15a3 f9			      ld    SP, HL 
15a4			 
15a4			free_early_exit: 
15a4 dd e1		      pop   IX 
15a6 d1			      pop   DE 
15a7 c1			      pop   BC 
15a8			 
15a8 c9			      ret 
15a9			 
15a9			; moved to firmware.asm 
15a9			; 
15a9			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
15a9			;                  .dw   0 
15a9			 
15a9			 
15a9			endif 
15a9			 
15a9			 
15a9			if MALLOC_3 
15a9			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
15a9			;heap_start        .equ  0x9000      ; Starting address of heap 
15a9			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
15a9			; 
15a9			 ;     .org 0 
15a9			  ;    jp    main 
15a9			; 
15a9			; 
15a9			 ;     .org  0x100 
15a9			;main: 
15a9			 ;     ld    HL, 0x8100 
15a9			  ;    ld    SP, HL 
15a9			; 
15a9			;      call  heap_init 
15a9			 
15a9			      ; Make some allocations 
15a9			;      ld    HL, 12 
15a9			;      call  malloc            ; Allocates 0x9004 
15a9			; 
15a9			 ;     ld    HL, 12 
15a9			;      call  malloc            ; Allocates 0x9014 
15a9			 
15a9			;      ld    HL, 12 
15a9			;      call  malloc            ; Allocates 0x9024 
15a9			 
15a9			      ; Free some allocations 
15a9			;      ld    HL, 0x9014 
15a9			;      call  free 
15a9			 
15a9			;      ld    HL, 0x9004 
15a9			;      call  free 
15a9			; 
15a9			;      ld    HL, 0x9024 
15a9			;      call  free 
15a9			 
15a9			 
15a9			 ;     halt 
15a9			 
15a9			 
15a9			;------------------------------------------------------------------------------ 
15a9			;     heap_init                                                               : 
15a9			;                                                                             : 
15a9			; Description                                                                 : 
15a9			;     Initialise the heap and make it ready for malloc and free operations.   : 
15a9			;                                                                             : 
15a9			;     The heap is maintained as a linked list, starting with an initial       : 
15a9			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
15a9			;     the first free block in the heap. Each block then points to the next    : 
15a9			;     free block within the heap, and the free list ends at the first block   : 
15a9			;     with a null pointer to the next free block.                             : 
15a9			;                                                                             : 
15a9			; Parameters                                                                  : 
15a9			;     Inputs are compile-time only. Two defines which specify the starting    : 
15a9			;     address of the heap and its size are required, along with a memory      : 
15a9			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
15a9			;     principally stores a pointer to the first free block in the heap.       : 
15a9			;                                                                             : 
15a9			; Returns                                                                     : 
15a9			;     Nothing                                                                 : 
15a9			;------------------------------------------------------------------------------ 
15a9			heap_init: 
15a9			      push  HL 
15a9			 
15a9			      ; Initialise free list struct 
15a9			      ld    HL, heap_start 
15a9			      ld    (free_list), HL 
15a9			      ld    HL, 0 
15a9			      ld    (free_list+2), HL 
15a9			 
15a9			      ; Insert first free block at bottom of heap, consumes entire heap 
15a9			      ld    HL, heap_start+heap_size-4 
15a9			      ld    (heap_start), HL        ; Next block (end of free list) 
15a9			      ld    HL, heap_size-4 
15a9			      ld    (heap_start+2), HL      ; Block size 
15a9			 
15a9			      ; Insert end of free list block at top of heap - two null words will 
15a9			      ; terminate the free list 
15a9			      ld    HL, 0 
15a9			      ld    (heap_start+heap_size-2), HL 
15a9			      ld    (heap_start+heap_size-4), HL 
15a9			 
15a9			      pop   HL 
15a9			 
15a9			      ret 
15a9			 
15a9			 
15a9			;------------------------------------------------------------------------------ 
15a9			;     malloc                                                                  : 
15a9			;                                                                             : 
15a9			; Description                                                                 : 
15a9			;     Allocates the wanted space from the heap and returns the address of the : 
15a9			;     first useable byte of the allocation.                                   : 
15a9			;                                                                             : 
15a9			;     Allocations can happen in one of two ways:                              : 
15a9			;                                                                             : 
15a9			;     1. A free block may be found which is the exact size wanted. In this    : 
15a9			;        case the block is removed from the free list and retuedn to the      : 
15a9			;        caller.                                                              : 
15a9			;     2. A free block may be found which is larger than the size wanted. In   : 
15a9			;        this case, the larger block is split into two. The first portion of  : 
15a9			;        this block will become the requested space by the malloc call and    : 
15a9			;        is returned to the caller. The second portion becomes a new free     : 
15a9			;        block, and the free list is adjusted to maintain continuity via this : 
15a9			;        newly created block.                                                 : 
15a9			;                                                                             : 
15a9			;     malloc does not set any initial value in the allocated space, the       : 
15a9			;     caller is required to do this as required.                              : 
15a9			;                                                                             : 
15a9			;     This implementation of malloc uses the stack exclusively, and is        : 
15a9			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
15a9			;     advisable to disable interrupts before calling malloc, and recommended  : 
15a9			;     to avoid the use of malloc inside ISRs in general.                      : 
15a9			;                                                                             : 
15a9			;     NOTE: heap_init must be called before malloc and free can be used.      : 
15a9			;                                                                             : 
15a9			; Parameters                                                                  : 
15a9			;     HL  Number of bytes wanted                                              : 
15a9			;                                                                             : 
15a9			; Returns                                                                     : 
15a9			;     HL  Address of the first useable byte of the allocation                 : 
15a9			;                                                                             : 
15a9			; Flags                                                                       : 
15a9			;     Z   Set if the allocation did not succeed, clear otherwise              : 
15a9			;                                                                             : 
15a9			; Stack frame                                                                 : 
15a9			;       |             |                                                       : 
15a9			;       +-------------+                                                       : 
15a9			;       |     BC      |                                                       : 
15a9			;       +-------------+                                                       : 
15a9			;       |     DE      |                                                       : 
15a9			;       +-------------+                                                       : 
15a9			;       |     IX      |                                                       : 
15a9			;       +-------------+                                                       : 
15a9			;       |  prev_free  |                                                       : 
15a9			;   +4  +-------------+                                                       : 
15a9			;       |  this_free  |                                                       : 
15a9			;   +2  +-------------+                                                       : 
15a9			;       |  next_free  |                                                       : 
15a9			;   +0  +-------------+                                                       : 
15a9			;       |             |                                                       : 
15a9			;                                                                             : 
15a9			;------------------------------------------------------------------------------ 
15a9			malloc: 
15a9			      push  BC 
15a9			      push  DE 
15a9			      push  IX 
15a9			 
15a9			      ld    A, H                    ; Exit if no space requested 
15a9			      or    L 
15a9			      jp    Z, malloc_early_exit 
15a9			 
15a9			      ; Set up stack frame 
15a9			      ex    DE, HL 
15a9			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
15a9			      add   HL, SP 
15a9			      ld    SP, HL 
15a9			      ld    IX, 0                   ; Use IX as a frame pointer 
15a9			      add   IX, SP 
15a9			 
15a9			      ; Setup initial state 
15a9			      ld    HL, 4                   ; want must also include space used by block struct 
15a9			      add   HL, DE 
15a9			 
15a9			      ld    B, H                    ; Move want to BC 
15a9			      ld    C, L 
15a9			 
15a9			      ld    HL, free_list           ; Store prev_free ptr to stack 
15a9			      ld    (IX+4), L 
15a9			      ld    (IX+5), H 
15a9			 
15a9			      ld    E, (HL)                 ; Store this_free ptr to stack 
15a9			      inc   HL 
15a9			      ld    D, (HL) 
15a9			      ld    (IX+2), E 
15a9			      ld    (IX+3), D 
15a9			      ex    DE, HL                  ; this_free ptr into HL 
15a9			 
15a9			      ; Loop through free block list to find some space 
15a9			malloc_find_space: 
15a9			      ld    E, (HL)                 ; Load next_free ptr into DE 
15a9			      inc   HL 
15a9			      ld    D, (HL) 
15a9			 
15a9			      ld    A, D                    ; Check for null next_free ptr - end of free list 
15a9			      or    E 
15a9			      jp    Z, malloc_no_space 
15a9			 
15a9			      ld    (IX+0), E               ; Store next_free ptr to stack 
15a9			      ld    (IX+1), D 
15a9			 
15a9			      ; Does this block have enough space to make the allocation? 
15a9			      inc   HL                      ; Load free block size into DE 
15a9			      ld    E, (HL) 
15a9			      inc   HL 
15a9			      ld    D, (HL) 
15a9			 
15a9			      ex    DE, HL                  ; Check size of block against want 
15a9			      or    A                       ; Ensure carry flag clear 
15a9			      sbc   HL, BC 
15a9			      push  HL                      ; Store the result for later (new block size) 
15a9			 
15a9			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
15a9			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
15a9			 
15a9			      ; this_free block is not big enough, setup ptrs to test next free block 
15a9			      pop   HL                      ; Discard previous result 
15a9			 
15a9			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
15a9			      ld    H, (IX+3) 
15a9			      ld    (IX+4), L 
15a9			      ld    (IX+5), H 
15a9			 
15a9			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
15a9			      ld    H, (IX+1) 
15a9			      ld    (IX+2), L 
15a9			      ld    (IX+3), H 
15a9			 
15a9			      jr    malloc_find_space 
15a9			 
15a9			      ; split a bigger block into two - requested size and remaining size 
15a9			malloc_alloc_split: 
15a9			      ex    DE, HL                  ; Calculate address of new free block 
15a9			      dec   HL 
15a9			      dec   HL 
15a9			      dec   HL 
15a9			      add   HL, BC 
15a9			 
15a9			      ; Create a new block and point it at next_free 
15a9			      ld    E, (IX+0)               ; Load next_free ptr into DE 
15a9			      ld    D, (IX+1) 
15a9			 
15a9			      ld    (HL), E                 ; Store next_free ptr into new block 
15a9			      inc   HL 
15a9			      ld    (HL), D 
15a9			 
15a9			      pop   DE                      ; Store size of new block into new block 
15a9			      inc   HL 
15a9			      ld    (HL), E 
15a9			      inc   HL 
15a9			      ld    (HL), D 
15a9			 
15a9			      ; Update this_free ptr to point to new block 
15a9			      dec   HL 
15a9			      dec   HL 
15a9			      dec   HL 
15a9			 
15a9			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
15a9			      ld    D, (IX+3) 
15a9			 
15a9			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
15a9			      ld    (IX+3), H 
15a9			 
15a9			      ; Modify this_free block to be allocation 
15a9			      ex    DE, HL 
15a9			      xor   A                       ; Null the next block ptr of allocated block 
15a9			      ld    (HL), A 
15a9			      inc   HL 
15a9			      ld    (HL), A 
15a9			 
15a9			      inc   HL                      ; Store want size into allocated block 
15a9			      ld    (HL), C 
15a9			      inc   HL 
15a9			      ld    (HL), B 
15a9			      inc   HL 
15a9			      push  HL                      ; Address of allocation to return 
15a9			 
15a9			      jr    malloc_update_links 
15a9			 
15a9			malloc_alloc_fit: 
15a9			      pop   HL                      ; Dont need new block size, want is exact fit 
15a9			 
15a9			      ; Modify this_free block to be allocation 
15a9			      ex    DE, HL 
15a9			      dec   HL 
15a9			      dec   HL 
15a9			      dec   HL 
15a9			 
15a9			      xor   A                       ; Null the next block ptr of allocated block 
15a9			      ld    (HL), A 
15a9			      inc   HL 
15a9			      ld    (HL), A 
15a9			 
15a9			      inc   HL                      ; Store address of allocation to return 
15a9			      inc   HL 
15a9			      inc   HL 
15a9			      push  HL 
15a9			 
15a9			      ; Copy next_free ptr to this_free, remove allocated block from free list 
15a9			      ld    L, (IX+0)               ; next_free to HL 
15a9			      ld    H, (IX+1) 
15a9			 
15a9			      ld    (IX+2), L               ; HL to this_free 
15a9			      ld    (IX+3), H 
15a9			 
15a9			 
15a9			malloc_update_links: 
15a9			      ; Update prev_free ptr to point to this_free 
15a9			      ld    L, (IX+4)               ; prev_free ptr to HL 
15a9			      ld    H, (IX+5) 
15a9			 
15a9			      ld    E, (IX+2)               ; this_free ptr to DE 
15a9			      ld    D, (IX+3) 
15a9			 
15a9			      ld    (HL), E                 ; this_free ptr into prev_free 
15a9			      inc   HL 
15a9			      ld    (HL), D 
15a9			 
15a9			      ; Clear the Z flag to indicate successful allocation 
15a9			      ld    A, D 
15a9			      or    E 
15a9			 
15a9			      pop   DE                      ; Address of allocation 
15a9			 
15a9			malloc_no_space: 
15a9			      ld    HL, 6                   ; Clean up stack frame 
15a9			      add   HL, SP 
15a9			      ld    SP, HL 
15a9			 
15a9			      ex    DE, HL                  ; Alloc addr into HL for return 
15a9			 
15a9			malloc_early_exit: 
15a9			      pop   IX 
15a9			      pop   DE 
15a9			      pop   BC 
15a9			 
15a9			      ret 
15a9			 
15a9			 
15a9			;------------------------------------------------------------------------------ 
15a9			;     free                                                                    : 
15a9			;                                                                             : 
15a9			; Description                                                                 : 
15a9			;     Return the space pointed to by HL to the heap. HL must be an address as : 
15a9			;     returned by malloc, otherwise the behaviour is undefined.               : 
15a9			;                                                                             : 
15a9			;     Where possible, directly adjacent free blocks will be merged together   : 
15a9			;     into larger blocks to help ensure that the heap does not become         : 
15a9			;     excessively fragmented.                                                 : 
15a9			;                                                                             : 
15a9			;     free does not clear or set any other value into the freed space, and    : 
15a9			;     therefore its contents may be visible through subsequent malloc's. The  : 
15a9			;     caller should clear the freed space as required.                        : 
15a9			;                                                                             : 
15a9			;     This implementation of free uses the stack exclusively, and is          : 
15a9			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
15a9			;     advisable to disable interrupts before calling free, and recommended    : 
15a9			;     to avoid the use of free inside ISRs in general.                        : 
15a9			;                                                                             : 
15a9			;     NOTE: heap_init must be called before malloc and free can be used.      : 
15a9			;                                                                             : 
15a9			; Parameters                                                                  : 
15a9			;     HL  Pointer to address of first byte of allocation to be freed          : 
15a9			;                                                                             : 
15a9			; Returns                                                                     : 
15a9			;     Nothing                                                                 : 
15a9			;                                                                             : 
15a9			; Stack frame                                                                 : 
15a9			;       |             |                                                       : 
15a9			;       +-------------+                                                       : 
15a9			;       |     BC      |                                                       : 
15a9			;       +-------------+                                                       : 
15a9			;       |     DE      |                                                       : 
15a9			;       +-------------+                                                       : 
15a9			;       |     IX      |                                                       : 
15a9			;       +-------------+                                                       : 
15a9			;       |  prev_free  |                                                       : 
15a9			;   +2  +-------------+                                                       : 
15a9			;       |  next_free  |                                                       : 
15a9			;   +0  +-------------+                                                       : 
15a9			;       |             |                                                       : 
15a9			;                                                                             : 
15a9			;------------------------------------------------------------------------------ 
15a9			free: 
15a9			      push  BC 
15a9			      push  DE 
15a9			      push  IX 
15a9			 
15a9			      ld    A, H                    ; Exit if ptr is null 
15a9			      or    L 
15a9			      jp    Z, free_early_exit 
15a9			 
15a9			      ; Set up stack frame 
15a9			      ex    DE, HL 
15a9			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
15a9			      add   HL, SP 
15a9			      ld    SP, HL 
15a9			      ld    IX, 0                   ; Use IX as a frame pointer 
15a9			      add   IX, SP 
15a9			 
15a9			      ; The address in HL points to the start of the useable allocated space, 
15a9			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
15a9			      ; address of the block itself. 
15a9			      ex    DE, HL 
15a9			      ld    DE, -4 
15a9			      add   HL, DE 
15a9			 
15a9			      ; An allocated block must have a null next block pointer in it 
15a9			      ld    A, (HL) 
15a9			      inc   HL 
15a9			      or    (HL) 
15a9			      jp    NZ, free_done 
15a9			 
15a9			      dec   HL 
15a9			 
15a9			      ld    B, H                    ; Copy HL to BC 
15a9			      ld    C, L 
15a9			 
15a9			      ; Loop through the free list to find the first block with an address 
15a9			      ; higher than the block being freed 
15a9			      ld    HL, free_list 
15a9			 
15a9			free_find_higher_block: 
15a9			      ld    E, (HL)                 ; Load next ptr from free block 
15a9			      inc   HL 
15a9			      ld    D, (HL) 
15a9			      dec   HL 
15a9			 
15a9			      ld    (IX+0), E               ; Save ptr to next free block 
15a9			      ld    (IX+1), D 
15a9			      ld    (IX+2), L               ; Save ptr to prev free block 
15a9			      ld    (IX+3), H 
15a9			 
15a9			      ld    A, B                    ; Check if DE is greater than BC 
15a9			      cp    D                       ; Compare MSB first 
15a9			      jr    Z, $+4                  ; MSB the same, compare LSB 
15a9			      jr    NC, free_find_higher_block_skip 
15a9			      ld    A, C 
15a9			      cp    E                       ; Then compare LSB 
15a9			      jr    C, free_found_higher_block 
15a9			 
15a9			free_find_higher_block_skip: 
15a9			      ld    A, D                    ; Reached the end of the free list? 
15a9			      or    E 
15a9			      jp    Z, free_done 
15a9			 
15a9			      ex    DE, HL 
15a9			 
15a9			      jr    free_find_higher_block 
15a9			 
15a9			free_found_higher_block: 
15a9			      ; Insert freed block between prev and next free blocks 
15a9			      ld    (HL), C                 ; Point prev free block to freed block 
15a9			      inc   HL 
15a9			      ld    (HL), B 
15a9			 
15a9			      ld    H, B                    ; Point freed block at next free block 
15a9			      ld    L, C 
15a9			      ld    (HL), E 
15a9			      inc   HL 
15a9			      ld    (HL), D 
15a9			 
15a9			      ; Check if the freed block is adjacent to the next free block 
15a9			      inc   HL                      ; Load size of freed block into HL 
15a9			      ld    E, (HL) 
15a9			      inc   HL 
15a9			      ld    D, (HL) 
15a9			      ex    DE, HL 
15a9			 
15a9			      add   HL, BC                  ; Add addr of freed block and its size 
15a9			 
15a9			      ld    E, (IX+0)               ; Load addr of next free block into DE 
15a9			      ld    D, (IX+1) 
15a9			 
15a9			      or    A                       ; Clear the carry flag 
15a9			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
15a9			      jr    NZ, free_check_adjacent_to_prev 
15a9			 
15a9			      ; Freed block is adjacent to next, merge into one bigger block 
15a9			      ex    DE, HL                  ; Load next ptr from next block into DE 
15a9			      ld    E, (HL) 
15a9			      inc   HL 
15a9			      ld    D, (HL) 
15a9			      push  HL                      ; Save ptr to next block for later 
15a9			 
15a9			      ld    H, B                    ; Store ptr from next block into freed block 
15a9			      ld    L, C 
15a9			      ld    (HL), E 
15a9			      inc   HL 
15a9			      ld    (HL), D 
15a9			 
15a9			      pop   HL                      ; Restore ptr to next block 
15a9			      inc   HL                      ; Load size of next block into DE 
15a9			      ld    E, (HL) 
15a9			      inc   HL 
15a9			      ld    D, (HL) 
15a9			      push  DE                      ; Save next block size for later 
15a9			 
15a9			      ld    H, B                    ; Load size of freed block into HL 
15a9			      ld    L, C 
15a9			      inc   HL 
15a9			      inc   HL 
15a9			      ld    E, (HL) 
15a9			      inc   HL 
15a9			      ld    D, (HL) 
15a9			      ex    DE, HL 
15a9			 
15a9			      pop   DE                      ; Restore size of next block 
15a9			      add   HL, DE                  ; Add sizes of both blocks 
15a9			      ex    DE, HL 
15a9			 
15a9			      ld    H, B                    ; Store new bigger size into freed block 
15a9			      ld    L, C 
15a9			      inc   HL 
15a9			      inc   HL 
15a9			      ld    (HL), E 
15a9			      inc   HL 
15a9			      ld    (HL), D 
15a9			 
15a9			free_check_adjacent_to_prev: 
15a9			      ; Check if the freed block is adjacent to the prev free block 
15a9			      ld    L, (IX+2)               ; Prev free block ptr into HL 
15a9			      ld    H, (IX+3) 
15a9			 
15a9			      inc   HL                      ; Size of prev free block into DE 
15a9			      inc   HL 
15a9			      ld    E, (HL) 
15a9			      inc   HL 
15a9			      ld    D, (HL) 
15a9			      dec   HL 
15a9			      dec   HL 
15a9			      dec   HL 
15a9			 
15a9			      add   HL, DE                  ; Add prev block addr and size 
15a9			 
15a9			      or    A                       ; Clear the carry flag 
15a9			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
15a9			      jr    NZ, free_done 
15a9			 
15a9			      ; Freed block is adjacent to prev, merge into one bigger block 
15a9			      ld    H, B                    ; Load next ptr from freed block into DE 
15a9			      ld    L, C 
15a9			      ld    E, (HL) 
15a9			      inc   HL 
15a9			      ld    D, (HL) 
15a9			      push  HL                      ; Save freed block ptr for later 
15a9			 
15a9			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
15a9			      ld    H, (IX+3) 
15a9			      ld    (HL), E 
15a9			      inc   HL 
15a9			      ld    (HL), D 
15a9			 
15a9			      pop   HL                      ; Restore freed block ptr 
15a9			      inc   HL                      ; Load size of freed block into DE 
15a9			      ld    E, (HL) 
15a9			      inc   HL 
15a9			      ld    D, (HL) 
15a9			      push  DE                      ; Save freed block size for later 
15a9			 
15a9			      ld    L, (IX+2)               ; Load size of prev block into DE 
15a9			      ld    H, (IX+3) 
15a9			      inc   HL 
15a9			      inc   HL 
15a9			      ld    E, (HL) 
15a9			      inc   HL 
15a9			      ld    D, (HL) 
15a9			 
15a9			      pop   HL                      ; Add sizes of both blocks 
15a9			      add   HL, DE 
15a9			      ex    DE, HL 
15a9			 
15a9			      ld    L, (IX+2)               ; Store new bigger size into prev block 
15a9			      ld    H, (IX+3) 
15a9			      inc   HL 
15a9			      inc   HL 
15a9			      ld    (HL), E 
15a9			      inc   HL 
15a9			      ld    (HL), D 
15a9			 
15a9			free_done: 
15a9			      ld    HL, 4                   ; Clean up stack frame 
15a9			      add   HL, SP 
15a9			      ld    SP, HL 
15a9			 
15a9			free_early_exit: 
15a9			      pop   IX 
15a9			      pop   DE 
15a9			      pop   BC 
15a9			 
15a9			      ret 
15a9			 
15a9			 
15a9			;      .org 0x8000 
15a9			; 
15a9			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
15a9			 ;                 .dw   0 
15a9			 
15a9			endif 
15a9			 
15a9			 
15a9			if MALLOC_4 
15a9			 
15a9			; My memory allocation code. Very very simple.... 
15a9			; allocate space under 250 chars 
15a9			 
15a9			heap_init: 
15a9				; init start of heap as zero 
15a9				;  
15a9			 
15a9				ld hl, heap_start 
15a9				ld a, 0 
15a9				ld (hl), a      ; empty block 
15a9				inc hl 
15a9				ld a, 0 
15a9				ld (hl), a      ; length of block 
15a9				; write end of list 
15a9				inc hl 
15a9				ld a,(hl) 
15a9				inc hl 
15a9				ld a,(hl) 
15a9				 
15a9			 
15a9				; init some malloc vars 
15a9			 
15a9				ld hl, 0 
15a9				ld (free_list), hl       ; store last malloc location 
15a9			 
15a9				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
15a9				ld a, 0 
15a9				ld (hl), a 
15a9			 
15a9			 
15a9				ld hl, heap_start 
15a9				;  
15a9				  
15a9				ret 
15a9			 
15a9			 
15a9			;    free block marker 
15a9			;    requested size  
15a9			;    pointer to next block 
15a9			;    .... 
15a9			;    next block marker 
15a9			 
15a9			 
15a9			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
15a9			; 
15a9			 
15a9			 
15a9			malloc:  
15a9				push de 
15a9				push bc 
15a9				push af 
15a9			 
15a9				; hl space required 
15a9				 
15a9				ld c, l    ; hold space   (TODO only a max of 255) 
15a9			 
15a9			;	inc c     ; TODO BUG need to fix memory leak on push str 
15a9			;	inc c 
15a9			;	inc c 
15a9			;	inc c 
15a9			;	inc c 
15a9			;	inc c 
15a9			;	inc c 
15a9			 
15a9			 
15a9			 
15a9				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
15a9			 
15a9				ld a, (free_list+3) 
15a9				cp 0 
15a9				jr z, .contheap 
15a9			 
15a9				ld hl, (free_list)     ; get last alloc 
15a9					if DEBUG_FORTH_MALLOC_INT 
15a9						DMARK "mrs" 
15a9						CALLMONITOR 
15a9					endif 
15a9				jr .startalloc 
15a9			 
15a9			.contheap: 
15a9				ld hl, heap_start 
15a9			 
15a9			.startalloc: 
15a9			 
15a9					if DEBUG_FORTH_MALLOC_INT 
15a9						DMARK "mym" 
15a9						CALLMONITOR 
15a9					endif 
15a9			.findblock: 
15a9					if DEBUG_FORTH_MALLOC_INT 
15a9						DMARK "mmf" 
15a9						CALLMONITOR 
15a9					endif 
15a9			 
15a9				ld a,(hl)  
15a9				; if byte is zero then clear to use 
15a9			 
15a9				cp 0 
15a9				jr z, .foundemptyblock 
15a9			 
15a9				; if byte is not clear 
15a9				;     then byte is offset to next block 
15a9			 
15a9				inc hl 
15a9				ld a, (hl) ; get size 
15a9			.nextblock:	inc hl 
15a9					ld e, (hl) 
15a9					inc hl 
15a9					ld d, (hl) 
15a9					ex de, hl 
15a9			;	inc hl  ; move past the store space 
15a9			;	inc hl  ; move past zero index  
15a9			 
15a9				; TODO detect no more space 
15a9			 
15a9				push hl 
15a9				ld de, heap_end 
15a9				call cmp16 
15a9				pop hl 
15a9				jr nc, .nospace 
15a9			 
15a9				jr .findblock 
15a9			 
15a9			.nospace: ld hl, 0 
15a9				jp .exit 
15a9			 
15a9			 
15a9			.foundemptyblock:	 
15a9					if DEBUG_FORTH_MALLOC_INT 
15a9						DMARK "mme" 
15a9						CALLMONITOR 
15a9					endif 
15a9			 
15a9			; TODO has block enough space if reusing??? 
15a9			 
15a9				;  
15a9			 
15a9			; see if this block has been previously used 
15a9				inc hl 
15a9				ld a, (hl) 
15a9				dec hl 
15a9				cp 0 
15a9				jr z, .newblock 
15a9			 
15a9					if DEBUG_FORTH_MALLOC_INT 
15a9						DMARK "meR" 
15a9						CALLMONITOR 
15a9					endif 
15a9			 
15a9			; no reusing previously allocated block 
15a9			 
15a9			; is it smaller than previously used? 
15a9				 
15a9				inc hl    ; move to size 
15a9				ld a, c 
15a9				sub (hl)        ; we want c < (hl) 
15a9				dec hl    ; move back to marker 
15a9			        jr z, .findblock 
15a9			 
15a9				; update with the new size which should be lower 
15a9			 
15a9			        ;inc  hl   ; negate next move. move back to size  
15a9			 
15a9			.newblock: 
15a9				; need to be at marker here 
15a9			 
15a9					if DEBUG_FORTH_MALLOC_INT 
15a9						DMARK "meN" 
15a9						CALLMONITOR 
15a9					endif 
15a9			 
15a9			 
15a9				ld a, c 
15a9			 
15a9				ld (free_list+3), a	 ; flag resume from last malloc  
15a9				ld (free_list), hl    ; save out last location 
15a9			 
15a9			 
15a9				;inc a     ; space for length byte 
15a9				ld (hl), a     ; save block in use marker 
15a9			 
15a9				inc hl   ; move to space marker 
15a9				ld (hl), a    ; save new space 
15a9			 
15a9				inc hl   ; move to start of allocated area 
15a9				 
15a9			;	push hl     ; save where we are - 1  
15a9			 
15a9			;	inc hl  ; move past zero index  
15a9				; skip space to set down new marker 
15a9			 
15a9				; provide some extra space for now 
15a9			 
15a9				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
15a9				inc a 
15a9				inc a 
15a9			 
15a9				push hl   ; save where we are in the node block 
15a9			 
15a9				call addatohl 
15a9			 
15a9				; write linked list point 
15a9			 
15a9				pop de     ; get our node position 
15a9				ex de, hl 
15a9			 
15a9				ld (hl), e 
15a9				inc hl 
15a9				ld (hl), d 
15a9			 
15a9				inc hl 
15a9			 
15a9				; now at start of allocated data so save pointer 
15a9			 
15a9				push hl 
15a9			 
15a9				; jump to position of next node and setup empty header in DE 
15a9			 
15a9				ex de, hl 
15a9			 
15a9			;	inc hl ; move past end of block 
15a9			 
15a9				ld a, 0 
15a9				ld (hl), a   ; empty marker 
15a9				inc hl 
15a9				ld (hl), a   ; size 
15a9				inc hl  
15a9				ld (hl), a   ; ptr 
15a9				inc hl 
15a9				ld (hl), a   ; ptr 
15a9			 
15a9			 
15a9				pop hl 
15a9			 
15a9					if DEBUG_FORTH_MALLOC_INT 
15a9						DMARK "mmr" 
15a9						CALLMONITOR 
15a9					endif 
15a9			 
15a9			.exit: 
15a9				pop af 
15a9				pop bc 
15a9				pop de  
15a9				ret 
15a9			 
15a9			 
15a9			 
15a9			 
15a9			free:  
15a9				push hl 
15a9				push af 
15a9				; get address in hl 
15a9			 
15a9					if DEBUG_FORTH_MALLOC_INT 
15a9						DMARK "fre" 
15a9						CALLMONITOR 
15a9					endif 
15a9				; data is at hl - move to block count 
15a9				dec hl 
15a9				dec hl    ; get past pointer 
15a9				dec hl 
15a9			 
15a9				ld a, (hl)    ; need this for a validation check 
15a9			 
15a9				dec hl    ; move to block marker 
15a9			 
15a9				; now check that the block count and block marker are the same  
15a9			        ; this checks that we are on a malloc node and not random memory 
15a9			        ; OK a faint chance this could be a problem but rare - famous last words! 
15a9			 
15a9				ld c, a 
15a9				ld a, (hl)    
15a9			 
15a9				cp c 
15a9				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
15a9			 
15a9				; yes good chance we are on a malloc node 
15a9			 
15a9				ld a, 0      
15a9				ld (hl), a   ; mark as free 
15a9			 
15a9				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
15a9			 
15a9			.freeignore:  
15a9			 
15a9				pop af 
15a9				pop hl 
15a9			 
15a9				ret 
15a9			 
15a9			 
15a9			 
15a9			endif 
15a9			 
15a9			; eof 
# End of file firmware_memory.asm
15a9			  
15a9			; device C  
15a9			if SOUND_ENABLE  
15a9				include "firmware_sound.asm"  
15a9			endif  
15a9			  
15a9			include "firmware_diags.asm"  
15a9			; Hardware diags menu 
15a9			 
15a9			 
15a9			config: 
15a9			 
15a9 3e 00			ld a, 0 
15ab 21 d9 15			ld hl, .configmn 
15ae cd 46 0d			call menu 
15b1			 
15b1 fe 00			cp 0 
15b3 c8				ret z 
15b4			 
15b4 fe 01			cp 1 
15b6 cc b2 16			call z, .savetostore 
15b9			 
15b9 fe 02			cp 2 
15bb cc 00 16			call z, .selautoload 
15be fe 03			cp 3 
15c0 cc e9 15			call z, .disautoload 
15c3 fe 04			cp 4 
15c5 cc b0 16			call z, .selbank 
15c8 fe 05			cp 5 
15ca cc 8d 17			call z, .debug_tog 
15cd fe 06			cp 6 
15cf cc d0 18			call z, .bpsgo 
15d2 fe 07			cp 7 
15d4 cc b3 17			call z, hardware_diags 
15d7			 
15d7 18 d0			jr config 
15d9			 
15d9			.configmn: 
15d9 c1 1a			dw prom_c3 
15db d8 1a			dw prom_c2 
15dd ed 1a			dw prom_c2a 
15df 03 1b			dw prom_c2b 
15e1			;	dw prom_c4 
15e1 20 1b			dw prom_m4 
15e3 3b 1b			dw prom_m4b 
15e5 43 1b			dw prom_c1 
15e7 00 00			dw 0 
15e9				 
15e9			 
15e9			 
15e9			 
15e9			.disautoload: 
15e9				if STORAGE_SE 
15e9 3e fe			ld a, $fe      ; bit 0 clear 
15eb 32 ed fb			ld (spi_device), a 
15ee			 
15ee cd ca 04			call storage_get_block_0 
15f1			 
15f1 3e 00			ld a, 0 
15f3 32 28 fc			ld (store_page+STORE_0_AUTOFILE), a 
15f6			 
15f6 21 00 00				ld hl, 0 
15f9 11 07 fc				ld de, store_page 
15fc cd 7e 04			call storage_write_block	 ; save update 
15ff				else 
15ff			 
15ff				ld hl, prom_notav 
15ff				ld de, prom_empty 
15ff				call info_panel 
15ff				endif 
15ff			 
15ff			 
15ff c9				ret 
1600			 
1600			 
1600			 
1600			; Select auto start 
1600			 
1600			.selautoload: 
1600			 
1600				 
1600				if STORAGE_SE 
1600			 
1600 cd d7 16				call config_dir 
1603 21 82 f3			        ld hl, scratch 
1606 3e 00				ld a, 0 
1608 cd 46 0d				call menu 
160b			 
160b fe 00				cp 0 
160d c8					ret z 
160e			 
160e 3d					dec a 
160f			 
160f			 
160f					; locate menu option 
160f			 
160f 21 82 f3				ld hl, scratch 
1612 cd 6a 0c				call table_lookup 
1615			 
1615					if DEBUG_FORTH_WORDS 
1615						DMARK "ALl" 
1615 f5				push af  
1616 3a 2a 16			ld a, (.dmark)  
1619 32 b4 fe			ld (debug_mark),a  
161c 3a 2b 16			ld a, (.dmark+1)  
161f 32 b5 fe			ld (debug_mark+1),a  
1622 3a 2c 16			ld a, (.dmark+2)  
1625 32 b6 fe			ld (debug_mark+2),a  
1628 18 03			jr .pastdmark  
162a ..			.dmark: db "ALl"  
162d f1			.pastdmark: pop af  
162e			endm  
# End of macro DMARK
162e						CALLMONITOR 
162e cd c6 18			call break_point_state  
1631				endm  
# End of macro CALLMONITOR
1631					endif 
1631					; with the pointer to the menu it, the byte following the zero term is the file id 
1631			 
1631 3e 00				ld a, 0 
1633 01 32 00				ld bc, 50   ; max of bytes to look at 
1636 ed b1				cpir  
1638			 
1638					if DEBUG_FORTH_WORDS 
1638						DMARK "ALb" 
1638 f5				push af  
1639 3a 4d 16			ld a, (.dmark)  
163c 32 b4 fe			ld (debug_mark),a  
163f 3a 4e 16			ld a, (.dmark+1)  
1642 32 b5 fe			ld (debug_mark+1),a  
1645 3a 4f 16			ld a, (.dmark+2)  
1648 32 b6 fe			ld (debug_mark+2),a  
164b 18 03			jr .pastdmark  
164d ..			.dmark: db "ALb"  
1650 f1			.pastdmark: pop af  
1651			endm  
# End of macro DMARK
1651						CALLMONITOR 
1651 cd c6 18			call break_point_state  
1654				endm  
# End of macro CALLMONITOR
1654					endif 
1654					;inc hl 
1654			 
1654 7e					ld a, (hl)   ; file id 
1655					 
1655				        ; save bank and file ids 
1655			 
1655 f5					push af 
1656			 
1656			; TODO need to save to block 0 on bank 1	 
1656			 
1656 cd ca 04				call storage_get_block_0 
1659			 
1659					if DEBUG_FORTH_WORDS 
1659						DMARK "AL0" 
1659 f5				push af  
165a 3a 6e 16			ld a, (.dmark)  
165d 32 b4 fe			ld (debug_mark),a  
1660 3a 6f 16			ld a, (.dmark+1)  
1663 32 b5 fe			ld (debug_mark+1),a  
1666 3a 70 16			ld a, (.dmark+2)  
1669 32 b6 fe			ld (debug_mark+2),a  
166c 18 03			jr .pastdmark  
166e ..			.dmark: db "AL0"  
1671 f1			.pastdmark: pop af  
1672			endm  
# End of macro DMARK
1672						CALLMONITOR 
1672 cd c6 18			call break_point_state  
1675				endm  
# End of macro CALLMONITOR
1675					endif 
1675 f1					pop af 
1676			 
1676 32 2b fc				ld (store_page+STORE_0_FILERUN),a 
1679					 
1679					; save bank id 
1679			 
1679 3a ed fb				ld a,(spi_device) 
167c 32 2a fc				ld (store_page+STORE_0_BANKRUN),a 
167f			 
167f					; enable auto run of store file 
167f			 
167f 3e 01				ld a, 1 
1681 32 28 fc				ld (store_page+STORE_0_AUTOFILE),a 
1684			 
1684					; save buffer 
1684			 
1684 21 00 00				ld hl, 0 
1687 11 07 fc				ld de, store_page 
168a					if DEBUG_FORTH_WORDS 
168a						DMARK "ALw" 
168a f5				push af  
168b 3a 9f 16			ld a, (.dmark)  
168e 32 b4 fe			ld (debug_mark),a  
1691 3a a0 16			ld a, (.dmark+1)  
1694 32 b5 fe			ld (debug_mark+1),a  
1697 3a a1 16			ld a, (.dmark+2)  
169a 32 b6 fe			ld (debug_mark+2),a  
169d 18 03			jr .pastdmark  
169f ..			.dmark: db "ALw"  
16a2 f1			.pastdmark: pop af  
16a3			endm  
# End of macro DMARK
16a3						CALLMONITOR 
16a3 cd c6 18			call break_point_state  
16a6				endm  
# End of macro CALLMONITOR
16a6					endif 
16a6 cd 7e 04			call storage_write_block	 ; save update 
16a9			  
16a9			 
16a9			 
16a9			 
16a9 21 82 f3				ld hl, scratch 
16ac cd c4 16				call config_fdir 
16af			 
16af				else 
16af			 
16af				ld hl, prom_notav 
16af				ld de, prom_empty 
16af				call info_panel 
16af			 
16af				endif 
16af c9				ret 
16b0			 
16b0			 
16b0			 
16b0			; Select storage bank 
16b0			 
16b0			.selbank: 
16b0			 
16b0				if STORAGE_SE 
16b0				else 
16b0			 
16b0				ld hl, prom_notav 
16b0				ld de, prom_empty 
16b0				call info_panel 
16b0				endif 
16b0				 
16b0 c9				ret 
16b1			 
16b1			if STORAGE_SE 
16b1			 
16b1			.config_ldir:   
16b1				; Load storage bank labels into menu array 
16b1			 
16b1				 
16b1			 
16b1			 
16b1 c9				ret 
16b2			 
16b2			 
16b2			endif 
16b2			 
16b2			 
16b2			; Save user words to storage 
16b2			 
16b2			.savetostore: 
16b2			 
16b2				if STORAGE_SE 
16b2			 
16b2 cd d7 16				call config_dir 
16b5 21 82 f3			        ld hl, scratch 
16b8 3e 00				ld a, 0 
16ba cd 46 0d				call menu 
16bd					 
16bd 21 82 f3				ld hl, scratch 
16c0 cd c4 16				call config_fdir 
16c3			 
16c3				else 
16c3			 
16c3				ld hl, prom_notav 
16c3				ld de, prom_empty 
16c3				call info_panel 
16c3			 
16c3				endif 
16c3			 
16c3 c9				ret 
16c4			 
16c4			 
16c4			 
16c4			if STORAGE_SE 
16c4			 
16c4			config_fdir: 
16c4				; using the scratch dir go through and release the memory allocated for each string 
16c4				 
16c4 21 82 f3			ld hl, scratch 
16c7 5e			.cfdir:	ld e,(hl) 
16c8 23				inc hl 
16c9 56				ld d,(hl) 
16ca 23				inc hl 
16cb			 
16cb eb				ex de, hl 
16cc cd 72 0f			call ishlzero 
16cf c8				ret z     ; return on null pointer 
16d0 cd da 14			call free 
16d3 eb				ex de, hl 
16d4 18 f1			jr .cfdir 
16d6			 
16d6			 
16d6 c9				ret 
16d7			 
16d7			 
16d7			config_dir: 
16d7			 
16d7				; for the config menus that need to build a directory of storage call this routine 
16d7				; it will construct a menu in scratch to pass to menu 
16d7			 
16d7				; open storage device 
16d7			 
16d7				; execute DIR to build a list of files and their ids into scratch in menu format 
16d7				; once the menu has finished then will need to call config_fdir to release the strings 
16d7				 
16d7				; c = number items 
16d7			 
16d7				 
16d7 cd ca 04			call storage_get_block_0 
16da			 
16da 21 07 fc			ld hl, store_page     ; get current id count 
16dd 46				ld b, (hl) 
16de 0e 00			ld c, 0    ; count of files   
16e0			 
16e0			 
16e0 21 82 f3			ld hl, scratch 
16e3 22 fe fb			ld (store_tmp2), hl    ; location to poke strings 
16e6			 
16e6				; check for empty drive 
16e6			 
16e6 3e 00			ld a, 0 
16e8 b8				cp b 
16e9 ca 83 17			jp z, .dirdone 
16ec			 
16ec				 
16ec					if DEBUG_FORTH_WORDS 
16ec						DMARK "Cdc" 
16ec f5				push af  
16ed 3a 01 17			ld a, (.dmark)  
16f0 32 b4 fe			ld (debug_mark),a  
16f3 3a 02 17			ld a, (.dmark+1)  
16f6 32 b5 fe			ld (debug_mark+1),a  
16f9 3a 03 17			ld a, (.dmark+2)  
16fc 32 b6 fe			ld (debug_mark+2),a  
16ff 18 03			jr .pastdmark  
1701 ..			.dmark: db "Cdc"  
1704 f1			.pastdmark: pop af  
1705			endm  
# End of macro DMARK
1705						CALLMONITOR 
1705 cd c6 18			call break_point_state  
1708				endm  
# End of macro CALLMONITOR
1708					endif 
1708			 
1708			 
1708			.diritem:	 
1708 c5				push bc 
1709				; for each of the current ids do a search for them and if found push to stack 
1709			 
1709 21 40 00				ld hl, STORE_BLOCK_PHY 
170c 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
170e 58					ld e,b 
170f			 
170f cd 4c 07				call storage_findnextid 
1712			 
1712			 
1712					; if found hl will be non zero 
1712			 
1712 cd 72 0f				call ishlzero 
1715 28 69				jr z, .dirnotfound 
1717			 
1717					; increase count 
1717			 
1717 c1					pop bc	 
1718 0c					inc c 
1719 c5					push bc 
171a					 
171a			 
171a					; get file header and push the file name 
171a			 
171a 11 07 fc				ld de, store_page 
171d cd 19 04				call storage_read_block 
1720			 
1720					; push file id to stack 
1720				 
1720 3a 07 fc				ld a, (store_page) 
1723 26 00				ld h, 0 
1725 6f					ld l, a 
1726			 
1726					;call forth_push_numhl 
1726					; TODO store id 
1726			 
1726 e5					push hl 
1727			 
1727					; push extent count to stack  
1727				 
1727 21 0a fc				ld hl, store_page+3 
172a			 
172a					; get file name length 
172a			 
172a cd a7 13				call strlenz   
172d			 
172d 23					inc hl   ; cover zero term 
172e 23					inc hl  ; stick the id at the end of the area 
172f			 
172f e5					push hl 
1730 c1					pop bc    ; move length to bc 
1731			 
1731 cd 10 14				call malloc 
1734			 
1734					; TODO save malloc area to scratch 
1734			 
1734 eb					ex de, hl 
1735 2a fe fb				ld hl, (store_tmp2) 
1738 73					ld (hl), e 
1739 23					inc hl 
173a 72					ld (hl), d 
173b 23					inc hl 
173c 22 fe fb				ld (store_tmp2), hl 
173f			 
173f					 
173f			 
173f					;pop hl   ; get source 
173f			;		ex de, hl    ; swap aronund	 
173f			 
173f 21 0a fc				ld hl, store_page+3 
1742					if DEBUG_FORTH_WORDS 
1742						DMARK "CFd" 
1742 f5				push af  
1743 3a 57 17			ld a, (.dmark)  
1746 32 b4 fe			ld (debug_mark),a  
1749 3a 58 17			ld a, (.dmark+1)  
174c 32 b5 fe			ld (debug_mark+1),a  
174f 3a 59 17			ld a, (.dmark+2)  
1752 32 b6 fe			ld (debug_mark+2),a  
1755 18 03			jr .pastdmark  
1757 ..			.dmark: db "CFd"  
175a f1			.pastdmark: pop af  
175b			endm  
# End of macro DMARK
175b						CALLMONITOR 
175b cd c6 18			call break_point_state  
175e				endm  
# End of macro CALLMONITOR
175e					endif 
175e ed b0				ldir 
1760			 
1760					; de is past string, move back one and store id 
1760					 
1760 1b					dec de 
1761			 
1761					; store file id 
1761			 
1761 e1					pop hl 
1762 eb					ex de,hl 
1763 73					ld (hl), e 
1764			 
1764					if DEBUG_FORTH_WORDS 
1764						DMARK "Cdi" 
1764 f5				push af  
1765 3a 79 17			ld a, (.dmark)  
1768 32 b4 fe			ld (debug_mark),a  
176b 3a 7a 17			ld a, (.dmark+1)  
176e 32 b5 fe			ld (debug_mark+1),a  
1771 3a 7b 17			ld a, (.dmark+2)  
1774 32 b6 fe			ld (debug_mark+2),a  
1777 18 03			jr .pastdmark  
1779 ..			.dmark: db "Cdi"  
177c f1			.pastdmark: pop af  
177d			endm  
# End of macro DMARK
177d						CALLMONITOR 
177d cd c6 18			call break_point_state  
1780				endm  
# End of macro CALLMONITOR
1780					endif 
1780					 
1780			.dirnotfound: 
1780 c1					pop bc     
1781 10 85				djnz .diritem 
1783				 
1783			.dirdone:	 
1783			 
1783 3e 00				ld a, 0 
1785 2a fe fb				ld hl, (store_tmp2) 
1788 77					ld (hl), a 
1789 23					inc hl 
178a 77					ld (hl), a 
178b 23					inc hl 
178c					; push a count of the dir items found 
178c			 
178c			;		ld h, 0 
178c			;		ld l, c 
178c			 
178c c9				ret 
178d			 
178d			endif 
178d			 
178d			 
178d			; Settings 
178d			; Run  
178d			 
178d			 
178d			 
178d			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
178d			;;hd_menu2:   db "        2: Editor",0   
178d			;hd_menu2:   db "        2: Editor       6: Menu",0   
178d			;hd_menu3:   db "        3: Storage",0 
178d			;hd_menu4:   db "0=quit  4: Debug",0 
178d			;hd_don:     db "ON",0 
178d			;hd_doff:     db "OFF",0 
178d			; 
178d			; 
178d			; 
178d			;hardware_diags_old:       
178d			; 
178d			;.diagmenu: 
178d			;	call clear_display 
178d			;	ld a, display_row_1 
178d			;	ld de, hd_menu1 
178d			;	call str_at_display 
178d			; 
178d			;	ld a, display_row_2 
178d			;	ld de, hd_menu2 
178d			;	call str_at_display 
178d			; 
178d			;	ld a, display_row_3 
178d			;	ld de, hd_menu3 
178d			;	call str_at_display 
178d			; 
178d			;	ld a,  display_row_4 
178d			;	ld de, hd_menu4 
178d			;	call str_at_display 
178d			; 
178d			;	; display debug state 
178d			; 
178d			;	ld de, hd_don 
178d			;	ld a, (os_view_disable) 
178d			;	cp 0 
178d			;	jr z, .distog 
178d			;	ld de, hd_doff 
178d			;.distog: ld a, display_row_4+17 
178d			;	call str_at_display 
178d			; 
178d			;	call update_display 
178d			; 
178d			;	call cin_wait 
178d			; 
178d			; 
178d			; 
178d			;	cp '4' 
178d			;	jr nz, .diagn1 
178d			; 
178d			;	; debug toggle 
178d			; 
178d			;	ld a, (os_view_disable) 
178d			;	ld b, '*' 
178d			;	cp 0 
178d			;	jr z, .debtog 
178d			;	ld b, 0 
178d			;.debtog:	 
178d			;	ld a,b 
178d			;	ld (os_view_disable),a 
178d			; 
178d			;.diagn1: cp '0' 
178d			;	 ret z 
178d			; 
178d			;;	cp '1' 
178d			;;       jp z, matrix	 
178d			;;   TODO keyboard matrix test 
178d			; 
178d			;	cp '2' 
178d			;	jp z, .diagedit 
178d			; 
178d			;;	cp '6' 
178d			;;	jp z, .menutest 
178d			;;if ENABLE_BASIC 
178d			;;	cp '6' 
178d			;;	jp z, basic 
178d			;;endif 
178d			 ; 
178d			;	jp .diagmenu 
178d			; 
178d			; 
178d			;	ret 
178d			 
178d			 
178d			.debug_tog: 
178d 21 d4 17			ld hl, .menudebug 
1790				 
1790 3a 73 f3			ld a, (os_view_disable) 
1793 fe 2a			cp '*' 
1795 20 04			jr nz,.tdon  
1797 3e 01			ld a, 1 
1799 18 02			jr .tog1 
179b 3e 00		.tdon: ld a, 0 
179d			 
179d			.tog1: 
179d cd 46 0d			call menu 
17a0 fe 00			cp 0 
17a2 c8				ret z 
17a3 fe 01			cp 1    ; disable debug 
17a5 28 04			jr z, .dtog0 
17a7 3e 2a			ld a, '*' 
17a9 18 02			jr .dtogset 
17ab 3e 00		.dtog0: ld a, 0 
17ad 32 73 f3		.dtogset:  ld (os_view_disable), a 
17b0 c3 8d 17			jp .debug_tog 
17b3			 
17b3			 
17b3			hardware_diags:       
17b3			 
17b3			.diagm: 
17b3 21 c6 17			ld hl, .menuitems 
17b6 3e 00			ld a, 0 
17b8 cd 46 0d			call menu 
17bb			 
17bb fe 00		         cp 0 
17bd c8				 ret z 
17be			 
17be fe 02			cp 2 
17c0 ca 1f 18			jp z, .diagedit 
17c3			 
17c3			;	cp '6' 
17c3			;	jp z, .menutest 
17c3			;if ENABLE_BASIC 
17c3			;	cp '6' 
17c3			;	jp z, basic 
17c3			;endif 
17c3			  
17c3 c3 b3 17			jp .diagm 
17c6			 
17c6				 
17c6 da 17		.menuitems:   	dw .m1 
17c8 e5 17				dw .m2 
17ca ec 17				dw .m3 
17cc f4 17				dw .m5 
17ce fa 17				dw .m5a 
17d0 03 18				dw .m5b 
17d2 00 00				dw 0 
17d4			 
17d4			.menudebug: 
17d4 0c 18				dw .m6 
17d6 15 18				dw .m7 
17d8 00 00				dw 0 
17da			 
17da .. 00		.m1:   db "Key Matrix",0 
17e5 .. 00		.m2:   db "Editor",0 
17ec .. 00		.m3:   db "Storage",0 
17f4 .. 00		.m5:   db "Sound",0 
17fa .. 00		.m5a:  db "RAM Test",0 
1803 .. 00		.m5b:  db "LCD Test",0 
180c			 
180c .. 00		.m6:   db "Debug ON",0 
1815 .. 00		.m7:   db "Debug OFF",0 
181f			 
181f			; debug editor 
181f			 
181f			.diagedit: 
181f			 
181f 21 82 f3			ld hl, scratch 
1822			;	ld bc, 250 
1822			;	ldir 
1822				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1822 3e 00			ld a, 0 
1824 77				ld (hl), a 
1825 23				inc hl 
1826 77				ld (hl), a 
1827 23				inc hl 
1828 77				ld (hl), a 
1829			 
1829 cd 15 0d		        call clear_display 
182c cd 38 0d			call update_display 
182f				;ld a, 1 
182f				;ld (hardware_diag), a 
182f			.diloop: 
182f 3e 00			ld a, display_row_1 
1831 0e 00			ld c, 0 
1833 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1835 1e 28			ld e, 40 
1837			 
1837 21 82 f3			ld hl, scratch	 
183a cd 76 0f			call input_str 
183d			 
183d 3e 14			ld a, display_row_2 
183f 11 82 f3			ld de, scratch 
1842 cd 28 0d			call str_at_display 
1845 cd 38 0d			call update_display 
1848			 
1848 c3 2f 18			jp .diloop 
184b			 
184b			 
184b			; pass word in hl 
184b			; a has display location 
184b			display_word_at: 
184b f5				push af 
184c e5				push hl 
184d 7c				ld a,h 
184e 21 87 f6			ld hl, os_word_scratch 
1851 cd 4a 12			call hexout 
1854 e1				pop hl 
1855 7d				ld a,l 
1856 21 89 f6			ld hl, os_word_scratch+2 
1859 cd 4a 12			call hexout 
185c 21 8b f6			ld hl, os_word_scratch+4 
185f 3e 00			ld a,0 
1861 77				ld (hl),a 
1862 11 87 f6			ld de,os_word_scratch 
1865 f1				pop af 
1866 cd 28 0d				call str_at_display 
1869 c9				ret 
186a			 
186a			display_ptr_state: 
186a			 
186a				; to restore afterwards 
186a			 
186a d5				push de 
186b c5				push bc 
186c e5				push hl 
186d f5				push af 
186e			 
186e				; for use in here 
186e			 
186e			;	push bc 
186e			;	push de 
186e			;	push hl 
186e			;	push af 
186e			 
186e cd 15 0d			call clear_display 
1871			 
1871 11 44 1a			ld de, .ptrstate 
1874 3e 00			ld a, display_row_1 
1876 cd 28 0d			call str_at_display 
1879			 
1879				; display debug step 
1879			 
1879			 
1879 11 b4 fe			ld de, debug_mark 
187c 3e 12			ld a, display_row_1+display_cols-2 
187e cd 28 0d			call str_at_display 
1881			 
1881				; display a 
1881 11 4e 1a			ld de, .ptrcliptr 
1884 3e 14			ld a, display_row_2 
1886 cd 28 0d			call str_at_display 
1889			 
1889 f1				pop af 
188a 2a cd fb			ld hl,(cli_ptr) 
188d 3e 1c			ld a, display_row_2+8 
188f cd 4b 18			call display_word_at 
1892			 
1892			 
1892				; display hl 
1892			 
1892			 
1892 11 56 1a			ld de, .ptrclioptr 
1895 3e 1e			ld a, display_row_2+10 
1897 cd 28 0d			call str_at_display 
189a			; 
189a			;	pop hl 
189a 3e 21			ld a, display_row_2+13 
189c 2a cb fb			ld hl,(cli_origptr) 
189f cd 4b 18			call display_word_at 
18a2			; 
18a2			;	 
18a2			;	; display de 
18a2			 
18a2			;	ld de, .regstatede 
18a2			;	ld a, display_row_3 
18a2			;	call str_at_display 
18a2			 
18a2			;	pop de 
18a2			;	ld h,d 
18a2			;	ld l, e 
18a2			;	ld a, display_row_3+3 
18a2			;	call display_word_at 
18a2			 
18a2			 
18a2				; display bc 
18a2			 
18a2			;	ld de, .regstatebc 
18a2			;	ld a, display_row_3+10 
18a2			;	call str_at_display 
18a2			 
18a2			;	pop bc 
18a2			;	ld h,b 
18a2			;	ld l, c 
18a2			;	ld a, display_row_3+13 
18a2			;	call display_word_at 
18a2			 
18a2			 
18a2				; display dsp 
18a2			 
18a2			;	ld de, .regstatedsp 
18a2			;	ld a, display_row_4 
18a2			;	call str_at_display 
18a2			 
18a2				 
18a2			;	ld hl,(cli_data_sp) 
18a2			;	ld a, display_row_4+4 
18a2			;	call display_word_at 
18a2			 
18a2				; display rsp 
18a2			 
18a2 11 85 1a			ld de, .regstatersp 
18a5 3e 46			ld a, display_row_4+10 
18a7 cd 28 0d			call str_at_display 
18aa			 
18aa				 
18aa 2a b3 fb			ld hl,(cli_ret_sp) 
18ad 3e 4a			ld a, display_row_4+14 
18af cd 4b 18			call display_word_at 
18b2			 
18b2 cd 38 0d			call update_display 
18b5			 
18b5 cd 92 0c			call delay1s 
18b8 cd 92 0c			call delay1s 
18bb cd 92 0c			call delay1s 
18be			 
18be			 
18be cd b2 1e			call next_page_prompt 
18c1			 
18c1				; restore  
18c1			 
18c1 f1				pop af 
18c2 e1				pop hl 
18c3 c1				pop bc 
18c4 d1				pop de 
18c5 c9				ret 
18c6			 
18c6			break_point_state: 
18c6 f5				push af 
18c7			 
18c7				; see if disabled 
18c7			 
18c7 3a 73 f3			ld a, (os_view_disable) 
18ca fe 2a			cp '*' 
18cc 20 02			jr nz, .bpsgo 
18ce f1				pop af 
18cf c9				ret 
18d0			 
18d0			.bpsgo: 
18d0 f1				pop af 
18d1 f5				push af 
18d2 22 6f f3			ld (os_view_hl), hl 
18d5 ed 53 6d f3		ld (os_view_de), de 
18d9 ed 43 6b f3		ld (os_view_bc), bc 
18dd e5				push hl 
18de 6f				ld l, a 
18df 26 00			ld h, 0 
18e1 22 71 f3			ld (os_view_af),hl 
18e4			 
18e4 21 4a fe				ld hl, display_fb0 
18e7 22 55 fd				ld (display_fb_active), hl 
18ea e1				pop hl	 
18eb			 
18eb 3e 31			ld a, '1' 
18ed fe 2a		.bps1:  cp '*' 
18ef 20 03			jr nz, .bps1b 
18f1 32 73 f3			ld (os_view_disable),a 
18f4 fe 31		.bps1b:  cp '1' 
18f6 20 14			jr nz, .bps2 
18f8			 
18f8				; display reg 
18f8			 
18f8				 
18f8			 
18f8 3a 71 f3			ld a, (os_view_af) 
18fb 2a 6f f3			ld hl, (os_view_hl) 
18fe ed 5b 6d f3		ld de, (os_view_de) 
1902 ed 4b 6b f3		ld bc, (os_view_bc) 
1906 cd a0 19			call display_reg_state 
1909 c3 8c 19			jp .bpschk 
190c			 
190c fe 32		.bps2:  cp '2' 
190e 20 08			jr nz, .bps3 
1910				 
1910				; display hl 
1910 2a 6f f3			ld hl, (os_view_hl) 
1913 cd 8a 1a			call display_dump_at_hl 
1916			 
1916 18 74			jr .bpschk 
1918			 
1918 fe 33		.bps3:  cp '3' 
191a 20 08			jr nz, .bps4 
191c			 
191c			        ; display de 
191c 2a 6d f3			ld hl, (os_view_de) 
191f cd 8a 1a			call display_dump_at_hl 
1922			 
1922 18 68			jr .bpschk 
1924 fe 34		.bps4:  cp '4' 
1926 20 08			jr nz, .bps5 
1928			 
1928			        ; display bc 
1928 2a 6b f3			ld hl, (os_view_bc) 
192b cd 8a 1a			call display_dump_at_hl 
192e			 
192e 18 5c			jr .bpschk 
1930 fe 35		.bps5:  cp '5' 
1932 20 08		        jr nz, .bps7 
1934			 
1934				; display cur ptr 
1934 2a cd fb			ld hl, (cli_ptr) 
1937 cd 8a 1a			call display_dump_at_hl 
193a			 
193a 18 50			jr .bpschk 
193c fe 36		.bps7:  cp '6' 
193e 20 08			jr nz, .bps8b 
1940				 
1940				; display cur orig ptr 
1940 2a cb fb			ld hl, (cli_origptr) 
1943 cd 8a 1a			call display_dump_at_hl 
1946 18 44			jr .bpschk 
1948 fe 37		.bps8b:  cp '7' 
194a 20 08			jr nz, .bps9 
194c				 
194c				; display dsp 
194c 2a af fb			ld hl, (cli_data_sp) 
194f cd 8a 1a			call display_dump_at_hl 
1952			 
1952 18 38			jr .bpschk 
1954 fe 39		.bps9:  cp '9' 
1956 20 05			jr nz, .bps8c 
1958				 
1958				; display SP 
1958			;	ld hl, sp 
1958 cd 8a 1a			call display_dump_at_hl 
195b			 
195b 18 2f			jr .bpschk 
195d fe 38		.bps8c:  cp '8' 
195f 20 08			jr nz, .bps8d 
1961				 
1961				; display rsp 
1961 2a b3 fb			ld hl, (cli_ret_sp) 
1964 cd 8a 1a			call display_dump_at_hl 
1967			 
1967 18 23			jr .bpschk 
1969 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
196b 20 05			jr nz, .bps8 
196d cd a8 1c			call monitor 
1970			 
1970 18 1a			jr .bpschk 
1972 fe 30		.bps8:  cp '0' 
1974 20 16			jr nz, .bpschk 
1976			 
1976 21 f9 fd				ld hl, display_fb1 
1979 22 55 fd				ld (display_fb_active), hl 
197c cd 38 0d				call update_display 
197f			 
197f				;ld a, (os_view_af) 
197f 2a 6f f3			ld hl, (os_view_hl) 
1982 ed 5b 6d f3		ld de, (os_view_de) 
1986 ed 4b 6b f3		ld bc, (os_view_bc) 
198a f1				pop af 
198b c9				ret 
198c			 
198c			.bpschk:   
198c cd 92 0c			call delay1s 
198f 3e 4f		ld a,display_row_4 + display_cols - 1 
1991 11 b0 1e		        ld de, endprg 
1994 cd 28 0d			call str_at_display 
1997 cd 38 0d			call update_display 
199a cd 06 6f			call cin_wait 
199d			 
199d c3 ed 18			jp .bps1 
19a0			 
19a0			 
19a0			display_reg_state: 
19a0			 
19a0				; to restore afterwards 
19a0			 
19a0 d5				push de 
19a1 c5				push bc 
19a2 e5				push hl 
19a3 f5				push af 
19a4			 
19a4				; for use in here 
19a4			 
19a4 c5				push bc 
19a5 d5				push de 
19a6 e5				push hl 
19a7 f5				push af 
19a8			 
19a8 cd 15 0d			call clear_display 
19ab			 
19ab 11 60 1a			ld de, .regstate 
19ae 3e 00			ld a, display_row_1 
19b0 cd 28 0d			call str_at_display 
19b3			 
19b3				; display debug step 
19b3			 
19b3			 
19b3 11 b4 fe			ld de, debug_mark 
19b6 3e 11			ld a, display_row_1+display_cols-3 
19b8 cd 28 0d			call str_at_display 
19bb			 
19bb				; display a 
19bb 11 7c 1a			ld de, .regstatea 
19be 3e 14			ld a, display_row_2 
19c0 cd 28 0d			call str_at_display 
19c3			 
19c3 e1				pop hl 
19c4			;	ld h,0 
19c4			;	ld l, a 
19c4 3e 17			ld a, display_row_2+3 
19c6 cd 4b 18			call display_word_at 
19c9			 
19c9			 
19c9				; display hl 
19c9			 
19c9			 
19c9 11 70 1a			ld de, .regstatehl 
19cc 3e 1e			ld a, display_row_2+10 
19ce cd 28 0d			call str_at_display 
19d1			 
19d1 e1				pop hl 
19d2 3e 21			ld a, display_row_2+13 
19d4 cd 4b 18			call display_word_at 
19d7			 
19d7				 
19d7				; display de 
19d7			 
19d7 11 74 1a			ld de, .regstatede 
19da 3e 28			ld a, display_row_3 
19dc cd 28 0d			call str_at_display 
19df			 
19df e1				pop hl 
19e0			;	ld h,d 
19e0			;	ld l, e 
19e0 3e 2b			ld a, display_row_3+3 
19e2 cd 4b 18			call display_word_at 
19e5			 
19e5			 
19e5				; display bc 
19e5			 
19e5 11 78 1a			ld de, .regstatebc 
19e8 3e 32			ld a, display_row_3+10 
19ea cd 28 0d			call str_at_display 
19ed			 
19ed e1				pop hl 
19ee			;	ld h,b 
19ee			;	ld l, c 
19ee 3e 35			ld a, display_row_3+13 
19f0 cd 4b 18			call display_word_at 
19f3			 
19f3			 
19f3				; display dsp 
19f3			 
19f3 11 80 1a			ld de, .regstatedsp 
19f6 3e 3c			ld a, display_row_4 
19f8 cd 28 0d			call str_at_display 
19fb			 
19fb				 
19fb 2a af fb			ld hl,(cli_data_sp) 
19fe 3e 40			ld a, display_row_4+4 
1a00 cd 4b 18			call display_word_at 
1a03			 
1a03				; display rsp 
1a03			 
1a03 11 85 1a			ld de, .regstatersp 
1a06 3e 46			ld a, display_row_4+10 
1a08 cd 28 0d			call str_at_display 
1a0b			 
1a0b				 
1a0b 2a b3 fb			ld hl,(cli_ret_sp) 
1a0e 3e 4a			ld a, display_row_4+14 
1a10 cd 4b 18			call display_word_at 
1a13			 
1a13 cd 38 0d			call update_display 
1a16			 
1a16			;	call delay1s 
1a16			;	call delay1s 
1a16			;	call delay1s 
1a16			 
1a16			 
1a16			;	call next_page_prompt 
1a16			 
1a16				; restore  
1a16			 
1a16 f1				pop af 
1a17 e1				pop hl 
1a18 c1				pop bc 
1a19 d1				pop de 
1a1a c9				ret 
1a1b			 
1a1b .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1a2f .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1a44 .. 00		.ptrstate:	db "Ptr State",0 
1a4e .. 00		.ptrcliptr:     db "cli_ptr",0 
1a56 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1a60 .. 00		.regstate:	db "Reg State (1/0)",0 
1a70 .. 00		.regstatehl:	db "HL:",0 
1a74 .. 00		.regstatede:	db "DE:",0 
1a78 .. 00		.regstatebc:	db "BC:",0 
1a7c .. 00		.regstatea:	db "A :",0 
1a80 .. 00		.regstatedsp:	db "DSP:",0 
1a85 .. 00		.regstatersp:	db "RSP:",0 
1a8a			 
1a8a			display_dump_at_hl: 
1a8a e5				push hl 
1a8b d5				push de 
1a8c c5				push bc 
1a8d f5				push af 
1a8e			 
1a8e 22 a5 f6			ld (os_cur_ptr),hl	 
1a91 cd 15 0d			call clear_display 
1a94 cd ba 1d			call dumpcont 
1a97			;	call delay1s 
1a97			;	call next_page_prompt 
1a97			 
1a97			 
1a97 f1				pop af 
1a98 c1				pop bc 
1a99 d1				pop de 
1a9a e1				pop hl 
1a9b c9				ret 
1a9c			 
1a9c			;if ENABLE_BASIC 
1a9c			;	include "nascombasic.asm" 
1a9c			;	basic: 
1a9c			;	include "forth/FORTH.ASM" 
1a9c			;endif 
1a9c			 
1a9c			; eof 
1a9c			 
1a9c			 
# End of file firmware_diags.asm
1a9c			  
1a9c			include "firmware_prompts.asm"  
1a9c			; Prompts  
1a9c			 
1a9c			; boot messages 
1a9c			 
1a9c .. 00		prom_bootmsg:	db "z80-homebrew OS v1.6",0 
1ab1 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
1ac1			 
1ac1			 
1ac1			; config menus 
1ac1			 
1ac1 .. 00		prom_c3: db "Add Dictionary To File",0 
1ad8 .. 00		prom_c2: db "Select Autoload File",0 
1aed .. 00		prom_c2a: db "Disable Autoload File", 0 
1b03 .. 00		prom_c2b: db "Select Storage Bank",0 
1b17 .. 00		prom_c4: db "Settings",0 
1b20 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
1b3b .. 00		prom_m4b:   db "Monitor",0 
1b43 .. 00		prom_c1: db "Hardware Diags",0 
1b52			 
1b52			 
1b52 .. 00		prom_notav:    db "Feature not available",0 
1b68 .. 00		prom_empty:    db "",0 
1b69			 
1b69			; eof 
1b69			 
# End of file firmware_prompts.asm
1b69			  
1b69			  
1b69			; eof  
1b69			  
# End of file firmware.asm
1b69			 
1b69			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1b69			;if BASE_KEV  
1b69			;baseram: equ 08000h 
1b69			;endif 
1b69			 
1b69			;if BASE_SC114 
1b69			;baseram:     equ    endofcode 
1b69			;endif 
1b69			 
1b69			 
1b69			; start system 
1b69			 
1b69			coldstart: 
1b69				; set sp 
1b69				; di/ei 
1b69			 
1b69 f3				di 
1b6a 31 fd ff			ld sp, tos 
1b6d			;	ei 
1b6d			 
1b6d			 
1b6d				; disable breakpoint by default 
1b6d			 
1b6d 3e 2a			ld a,'*' 
1b6f 32 73 f3			ld (os_view_disable),a 
1b72			 
1b72				; init hardware 
1b72			 
1b72				; init keyboard and screen hardware 
1b72			 
1b72 cd 1c 00			call hardware_init 
1b75			 
1b75			 
1b75 cd 92 0c			call delay1s 
1b78 3e 30			ld a, display_row_3+8 
1b7a 11 03 00			ld de, buildtime 
1b7d cd 28 0d			call str_at_display 
1b80 cd 38 0d			call update_display 
1b83			 
1b83 cd 92 0c			call delay1s 
1b86 cd 92 0c			call delay1s 
1b89 cd 92 0c			call delay1s 
1b8c			 
1b8c				; detect if any keys are held down to enable breakpoints at start up 
1b8c			 
1b8c cd 17 6f			call cin  
1b8f fe 00			cp 0 
1b91 28 03			jr z, .nokeys 
1b93			 
1b93				;call hardware_diags 
1b93 cd a9 15			call config 
1b96			 
1b96			;	ld de, .bpen 
1b96			;	ld a, display_row_4 
1b96			;	call str_at_display 
1b96			;	call update_display 
1b96			; 
1b96			;	ld a,0 
1b96			;	ld (os_view_disable),a 
1b96			; 
1b96			;.bpwait: 
1b96			;	call cin 
1b96			;	cp 0 
1b96			;	jr z, .bpwait 
1b96			;	jr .nokeys 
1b96			; 
1b96			; 
1b96			;.bpen:  db "Break points enabled!",0 
1b96			 
1b96			 
1b96			 
1b96			 
1b96			 
1b96			 
1b96			.nokeys: 
1b96			 
1b96			 
1b96				 
1b96			 
1b96			;jp  testkey 
1b96			 
1b96			;call storage_get_block_0 
1b96			; 
1b96			;ld hl, 0 
1b96			;ld de, store_page 
1b96			;call storage_read_block 
1b96			 
1b96				 
1b96			;ld hl, 10 
1b96			;ld de, store_page 
1b96			;call storage_read_block 
1b96			 
1b96			 
1b96			 
1b96			 
1b96			 
1b96			;stop:	nop 
1b96			;	jp stop 
1b96			 
1b96			 
1b96			 
1b96			main: 
1b96 cd 15 0d			call clear_display 
1b99 cd 38 0d			call update_display 
1b9c			 
1b9c			 
1b9c			 
1b9c			;	call testlcd 
1b9c			 
1b9c			 
1b9c			 
1b9c cd 78 22			call forth_init 
1b9f			 
1b9f			 
1b9f			warmstart: 
1b9f cd 4e 22			call forth_warmstart 
1ba2			 
1ba2				; run startup word load 
1ba2			        ; TODO prevent this running at warmstart after crash  
1ba2			 
1ba2				if STARTUP_ENABLE 
1ba2					if STORAGE_SE 
1ba2 cd 48 6c					call forth_autoload 
1ba5					endif 
1ba5 cd 57 69				call forth_startup 
1ba8			 
1ba8			 
1ba8				endif 
1ba8			 
1ba8				; show free memory after boot 
1ba8 11 42 1c			ld de, freeram 
1bab 3e 00			ld a, display_row_1 
1bad cd 28 0d			call str_at_display 
1bb0			 
1bb0			; Or use heap_size word???? 
1bb0 21 68 f3			ld hl, heap_end 
1bb3 11 0e 80			ld de, heap_start 
1bb6 ed 52			sbc hl, de 
1bb8 e5				push hl 
1bb9 7c				ld a,h	         	 
1bba 21 87 f6			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1bbd cd 4a 12			call hexout 
1bc0 e1			   	pop hl 
1bc1			 
1bc1 7d				ld a,l 
1bc2 21 89 f6			ld hl, os_word_scratch+2 
1bc5 cd 4a 12			call hexout 
1bc8 21 8b f6			ld hl, os_word_scratch+4 
1bcb 3e 00			ld a, 0 
1bcd 77				ld (hl),a 
1bce 11 87 f6			ld de, os_word_scratch 
1bd1 3e 0d			ld a, display_row_1 + 13 
1bd3 cd 28 0d			call str_at_display 
1bd6 cd 38 0d			call update_display 
1bd9			 
1bd9			 
1bd9				;call demo 
1bd9			 
1bd9			 
1bd9				; init scratch input area for cli commands 
1bd9			 
1bd9 21 a9 f6			ld hl, os_cli_cmd 
1bdc 3e 00			ld a,0 
1bde 77				ld (hl),a 
1bdf 23				inc hl 
1be0 77				ld (hl),a 
1be1			 
1be1 3e 00			ld a,0 
1be3 32 a8 f7			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1be6			 
1be6 32 a5 f6			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1be9 32 a6 f6			ld (os_cur_ptr+1),a	 
1bec			 
1bec 32 87 f6			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1bef 32 88 f6			ld (os_word_scratch+1),a	 
1bf2				 
1bf2			 
1bf2				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1bf2 21 a9 f6			ld hl, os_cli_cmd 
1bf5			 
1bf5 3e 00			ld a, 0		 ; init cli input 
1bf7 77				ld (hl), a 
1bf8 3e 14			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1bfa			cli: 
1bfa				; show cli prompt 
1bfa				;push af 
1bfa				;ld a, 0 
1bfa				;ld de, prompt 
1bfa				;call str_at_display 
1bfa			 
1bfa				;call update_display 
1bfa				;pop af 
1bfa				;inc a 
1bfa				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1bfa 0e 00			ld c, 0 
1bfc 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1bfe 1e 28			ld e, 40 
1c00			 
1c00 21 a9 f6			ld hl, os_cli_cmd 
1c03			 
1c03				STACKFRAME OFF $fefe $9f9f 
1c03				if DEBUG_STACK_IMB 
1c03					if OFF 
1c03						exx 
1c03						ld de, $fefe 
1c03						ld a, d 
1c03						ld hl, curframe 
1c03						call hexout 
1c03						ld a, e 
1c03						ld hl, curframe+2 
1c03						call hexout 
1c03						ld hl, $fefe 
1c03						push hl 
1c03						ld hl, $9f9f 
1c03						push hl 
1c03						exx 
1c03					endif 
1c03				endif 
1c03			endm 
# End of macro STACKFRAME
1c03			 
1c03 cd 76 0f			call input_str 
1c06			 
1c06				STACKFRAMECHK OFF $fefe $9f9f 
1c06				if DEBUG_STACK_IMB 
1c06					if OFF 
1c06						exx 
1c06						ld hl, $9f9f 
1c06						pop de   ; $9f9f 
1c06						call cmp16 
1c06						jr nz, .spnosame 
1c06						ld hl, $fefe 
1c06						pop de   ; $fefe 
1c06						call cmp16 
1c06						jr z, .spfrsame 
1c06						.spnosame: call showsperror 
1c06						.spfrsame: nop 
1c06						exx 
1c06					endif 
1c06				endif 
1c06			endm 
# End of macro STACKFRAMECHK
1c06			 
1c06				; copy input to last command 
1c06			 
1c06 21 a9 f6			ld hl, os_cli_cmd 
1c09 11 a8 f7			ld de, os_last_cmd 
1c0c 01 ff 00			ld bc, 255 
1c0f ed b0			ldir 
1c11			 
1c11				; wipe current buffer 
1c11			 
1c11			;	ld a, 0 
1c11			;	ld hl, os_cli_cmd 
1c11			;	ld de, os_cli_cmd+1 
1c11			;	ld bc, 254 
1c11			;	ldir 
1c11				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1c11			;	call strcpy 
1c11			;	ld a, 0 
1c11			;	ld (hl), a 
1c11			;	inc hl 
1c11			;	ld (hl), a 
1c11			;	inc hl 
1c11			;	ld (hl), a 
1c11			 
1c11				; switch frame buffer to program  
1c11			 
1c11 21 f9 fd				ld hl, display_fb1 
1c14 22 55 fd				ld (display_fb_active), hl 
1c17			 
1c17			;	nop 
1c17				STACKFRAME ON $fbfe $8f9f 
1c17				if DEBUG_STACK_IMB 
1c17					if ON 
1c17						exx 
1c17						ld de, $fbfe 
1c17						ld a, d 
1c17						ld hl, curframe 
1c17						call hexout 
1c17						ld a, e 
1c17						ld hl, curframe+2 
1c17						call hexout 
1c17						ld hl, $fbfe 
1c17						push hl 
1c17						ld hl, $8f9f 
1c17						push hl 
1c17						exx 
1c17					endif 
1c17				endif 
1c17			endm 
# End of macro STACKFRAME
1c17				; first time into the parser so pass over the current scratch pad 
1c17 21 a9 f6			ld hl,os_cli_cmd 
1c1a				; tokenise the entered statement(s) in HL 
1c1a cd f6 22			call forthparse 
1c1d			        ; exec forth statements in top of return stack 
1c1d cd 36 23			call forthexec 
1c20				;call forthexec_cleanup 
1c20			;	call parsenext 
1c20			 
1c20				STACKFRAMECHK ON $fbfe $8f9f 
1c20				if DEBUG_STACK_IMB 
1c20					if ON 
1c20						exx 
1c20						ld hl, $8f9f 
1c20						pop de   ; $8f9f 
1c20						call cmp16 
1c20						jr nz, .spnosame 
1c20						ld hl, $fbfe 
1c20						pop de   ; $fbfe 
1c20						call cmp16 
1c20						jr z, .spfrsame 
1c20						.spnosame: call showsperror 
1c20						.spfrsame: nop 
1c20						exx 
1c20					endif 
1c20				endif 
1c20			endm 
# End of macro STACKFRAMECHK
1c20				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1c20			 
1c20 3e 3c			ld a, display_row_4 
1c22 11 54 1c			ld de, endprog 
1c25			 
1c25 cd 38 0d			call update_display		 
1c28			 
1c28 cd b2 1e			call next_page_prompt 
1c2b			 
1c2b				; switch frame buffer to cli 
1c2b			 
1c2b 21 4a fe				ld hl, display_fb0 
1c2e 22 55 fd				ld (display_fb_active), hl 
1c31			 
1c31			 
1c31 cd 15 0d		        call clear_display 
1c34 cd 38 0d			call update_display		 
1c37			 
1c37 21 a9 f6			ld hl, os_cli_cmd 
1c3a			 
1c3a 3e 00			ld a, 0		 ; init cli input 
1c3c 77				ld (hl), a 
1c3d			 
1c3d				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1c3d			 
1c3d				; now on last line 
1c3d			 
1c3d				; TODO scroll screen up 
1c3d			 
1c3d				; TODO instead just clear screen and place at top of screen 
1c3d			 
1c3d			;	ld a, 0 
1c3d			;	ld (f_cursor_ptr),a 
1c3d			 
1c3d				;call clear_display 
1c3d				;call update_display 
1c3d			 
1c3d				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1c3d 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1c3f c3 fa 1b			jp cli 
1c42			 
1c42 .. 00		freeram: db "Free bytes: $",0 
1c50 ..			asc: db "1A2F" 
1c54 .. 00		endprog: db "End prog...",0 
1c60			 
1c60			testenter2:   
1c60 21 b4 f3			ld hl,scratch+50 
1c63 22 a5 f6			ld (os_cur_ptr),hl 
1c66 c3 fa 1b			jp cli 
1c69			 
1c69			testenter:  
1c69			 
1c69 21 50 1c			ld hl,asc 
1c6c			;	ld a,(hl) 
1c6c			;	call nibble2val 
1c6c cd a0 12			call get_byte 
1c6f			 
1c6f			 
1c6f			;	ld a,(hl) 
1c6f			;	call atohex 
1c6f			 
1c6f			;	call fourehexhl 
1c6f 32 b4 f3			ld (scratch+50),a 
1c72			 
1c72			 
1c72			 
1c72 21 52 1c			ld hl,asc+2 
1c75			;	ld a, (hl) 
1c75			;	call nibble2val 
1c75 cd a0 12			call get_byte 
1c78			 
1c78			;	call fourehexhl 
1c78 32 b6 f3			ld (scratch+52),a 
1c7b				 
1c7b 21 b4 f3			ld hl,scratch+50 
1c7e 22 a5 f6			ld (os_cur_ptr),hl 
1c81 c3 fa 1b			jp cli 
1c84			 
1c84			enter:	 
1c84 3a 86 f3			ld a,(scratch+4) 
1c87 fe 00			cp 0 
1c89 28 0c			jr z, .entercont 
1c8b				; no, not a null term line so has an address to work out.... 
1c8b			 
1c8b 21 84 f3			ld hl,scratch+2 
1c8e cd 00 13			call get_word_hl 
1c91			 
1c91 22 a5 f6			ld (os_cur_ptr),hl	 
1c94 c3 fa 1b			jp cli 
1c97			 
1c97			 
1c97			.entercont:  
1c97			 
1c97 21 84 f3			ld hl, scratch+2 
1c9a cd a0 12			call get_byte 
1c9d			 
1c9d 2a a5 f6		   	ld hl,(os_cur_ptr) 
1ca0 77					ld (hl),a 
1ca1 23					inc hl 
1ca2 22 a5 f6				ld (os_cur_ptr),hl 
1ca5				 
1ca5			; get byte  
1ca5			 
1ca5			 
1ca5 c3 fa 1b			jp cli 
1ca8			 
1ca8			 
1ca8			; basic monitor support 
1ca8			 
1ca8			monitor: 
1ca8				;  
1ca8 cd 15 0d			call clear_display 
1cab 3e 00			ld a, 0 
1cad 11 f5 1c			ld de, .monprompt 
1cb0 cd 28 0d			call str_at_display 
1cb3 cd 38 0d			call update_display 
1cb6			 
1cb6				; get a monitor command 
1cb6			 
1cb6 0e 00			ld c, 0     ; entry at top left 
1cb8 16 64			ld d, 100   ; max buffer size 
1cba 1e 0f			ld e, 15    ; input scroll area 
1cbc 3e 00			ld a, 0     ; init string 
1cbe 21 80 f5			ld hl, os_input 
1cc1 77				ld (hl), a 
1cc2 23				inc hl 
1cc3 77				ld (hl), a 
1cc4 21 80 f5			ld hl, os_input 
1cc7 3e 01			ld a, 1     ; init string 
1cc9 cd 76 0f			call input_str 
1ccc			 
1ccc cd 15 0d		        call clear_display 
1ccf cd 38 0d			call update_display		 
1cd2			 
1cd2 3a 80 f5			ld a, (os_input) 
1cd5 cd 9e 13			call toUpper 
1cd8 fe 48		        cp 'H' 
1cda 28 6f		        jr z, .monhelp 
1cdc fe 44			cp 'D'		; dump 
1cde ca 6c 1d			jp z, .mondump	 
1ce1 fe 43			cp 'C'		; dump 
1ce3 ca 86 1d			jp z, .moncdump	 
1ce6 fe 4d			cp 'M'		; dump 
1ce8 ca f7 1c			jp z, .moneditstart 
1ceb fe 55			cp 'U'		; dump 
1ced 28 14			jr z, .monedit	 
1cef fe 51			cp 'Q'		; dump 
1cf1 c8				ret z	 
1cf2			 
1cf2			 
1cf2				; TODO "S" to access symbol by name and not need the address 
1cf2				; TODO "F" to find a string in memory 
1cf2			 
1cf2 c3 a8 1c			jp monitor 
1cf5			 
1cf5 .. 00		.monprompt: db ">", 0 
1cf7			 
1cf7			.moneditstart: 
1cf7				; get starting address 
1cf7			 
1cf7 21 82 f5			ld hl,os_input+2 
1cfa cd 00 13			call get_word_hl 
1cfd			 
1cfd 22 a5 f6			ld (os_cur_ptr),hl	 
1d00			 
1d00 c3 a8 1c			jp monitor 
1d03			 
1d03			.monedit: 
1d03				; get byte to load 
1d03			 
1d03 21 82 f5			ld hl,os_input+2 
1d06 cd a0 12			call get_byte 
1d09			 
1d09				; get address to update 
1d09 2a a5 f6			ld hl, (os_cur_ptr) 
1d0c			 
1d0c				; update byte 
1d0c			 
1d0c 77				ld (hl), a 
1d0d			 
1d0d				; move to next address and save it 
1d0d			 
1d0d 23				inc hl 
1d0e 22 a5 f6			ld (os_cur_ptr),hl	 
1d11			 
1d11 c3 a8 1c			jp monitor 
1d14			 
1d14			 
1d14 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1d28 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1d44 .. 00		.monhelptext3:  db "Q-Quit",0 
1d4b			        
1d4b			.monhelp: 
1d4b 3e 00			ld a, display_row_1 
1d4d 11 14 1d		        ld de, .monhelptext1 
1d50			 
1d50 cd 28 0d			call str_at_display 
1d53 3e 14			ld a, display_row_2 
1d55 11 28 1d		        ld de, .monhelptext2 
1d58					 
1d58 cd 28 0d			call str_at_display 
1d5b 3e 28			ld a, display_row_3 
1d5d 11 44 1d		        ld de, .monhelptext3 
1d60					 
1d60 cd 28 0d			call str_at_display 
1d63 cd 38 0d			call update_display		 
1d66			 
1d66 cd b2 1e			call next_page_prompt 
1d69 c3 a8 1c			jp monitor 
1d6c			 
1d6c			.mondump:    
1d6c 21 82 f5			ld hl,os_input+2 
1d6f cd 00 13			call get_word_hl 
1d72			 
1d72 22 a5 f6			ld (os_cur_ptr),hl	 
1d75 cd ba 1d			call dumpcont 
1d78 3e 3c			ld a, display_row_4 
1d7a 11 54 1c			ld de, endprog 
1d7d			 
1d7d cd 38 0d			call update_display		 
1d80			 
1d80 cd b2 1e			call next_page_prompt 
1d83 c3 a8 1c			jp monitor 
1d86			.moncdump: 
1d86 cd ba 1d			call dumpcont 
1d89 3e 3c			ld a, display_row_4 
1d8b 11 54 1c			ld de, endprog 
1d8e			 
1d8e cd 38 0d			call update_display		 
1d91			 
1d91 cd b2 1e			call next_page_prompt 
1d94 c3 a8 1c			jp monitor 
1d97			 
1d97			 
1d97			; TODO symbol access  
1d97			 
1d97			.symbols:     ;; A list of symbols that can be called up  
1d97 4a fe			dw display_fb0 
1d99 .. 00			db "fb0",0  
1d9d 07 fc		     	dw store_page 
1d9f .. 00			db "store_page",0 
1daa			 
1daa			 
1daa			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1daa			 
1daa 3a 83 f3			ld a,(scratch+1) 
1dad fe 00			cp 0 
1daf 28 09			jr z, dumpcont 
1db1			 
1db1				; no, not a null term line so has an address to work out.... 
1db1			 
1db1 21 84 f3			ld hl,scratch+2 
1db4 cd 00 13			call get_word_hl 
1db7			 
1db7 22 a5 f6			ld (os_cur_ptr),hl	 
1dba			 
1dba			 
1dba			 
1dba			dumpcont: 
1dba			 
1dba				; dump bytes at ptr 
1dba			 
1dba			 
1dba 3e 00			ld a, display_row_1 
1dbc 2a 55 fd			ld hl, (display_fb_active) 
1dbf cd 49 0f			call addatohl 
1dc2 cd ea 1d			call .dumpbyterow 
1dc5			 
1dc5 3e 14			ld a, display_row_2 
1dc7 2a 55 fd			ld hl, (display_fb_active) 
1dca cd 49 0f			call addatohl 
1dcd cd ea 1d			call .dumpbyterow 
1dd0			 
1dd0			 
1dd0 3e 28			ld a, display_row_3 
1dd2 2a 55 fd			ld hl, (display_fb_active) 
1dd5 cd 49 0f			call addatohl 
1dd8 cd ea 1d			call .dumpbyterow 
1ddb			 
1ddb 3e 3c			ld a, display_row_4 
1ddd 2a 55 fd			ld hl, (display_fb_active) 
1de0 cd 49 0f			call addatohl 
1de3 cd ea 1d			call .dumpbyterow 
1de6			 
1de6 cd 38 0d			call update_display 
1de9			;		jp cli 
1de9 c9				ret 
1dea			 
1dea			.dumpbyterow: 
1dea			 
1dea				;push af 
1dea			 
1dea e5				push hl 
1deb			 
1deb				; calc where to poke the ascii 
1deb			if display_cols == 20 
1deb 3e 10			ld a, 16 
1ded			else 
1ded				ld a, 31 
1ded			endif 
1ded			 
1ded cd 49 0f			call addatohl 
1df0 22 87 f6			ld (os_word_scratch),hl  		; save pos for later 
1df3			 
1df3			 
1df3			; display decoding address 
1df3 2a a5 f6		   	ld hl,(os_cur_ptr) 
1df6			 
1df6 7c				ld a,h 
1df7 e1				pop hl 
1df8 e5				push hl 
1df9			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1df9 cd 4a 12			call hexout 
1dfc 2a a5 f6		   	ld hl,(os_cur_ptr) 
1dff			 
1dff 7d				ld a,l 
1e00 e1				pop hl 
1e01 23				inc hl 
1e02 23				inc hl 
1e03 e5				push hl 
1e04			;	ld hl, os_word_scratch+2 
1e04 cd 4a 12			call hexout 
1e07 e1				pop hl 
1e08 23				inc hl 
1e09 23				inc hl 
1e0a				;ld hl, os_word_scratch+4 
1e0a 3e 3a			ld a, ':' 
1e0c 77				ld (hl),a 
1e0d 23				inc hl 
1e0e				;ld a, 0 
1e0e				;ld (hl),a 
1e0e				;ld de, os_word_scratch 
1e0e				;pop af 
1e0e				;push af 
1e0e			;		ld a, display_row_2 
1e0e			;		call str_at_display 
1e0e			;		call update_display 
1e0e			 
1e0e			 
1e0e			;pop af 
1e0e			;	add 5 
1e0e			 
1e0e			if display_cols == 20 
1e0e 06 04			ld b, 4 
1e10			else 
1e10				ld b, 8 
1e10			endif	 
1e10			 
1e10			.dumpbyte: 
1e10 c5				push bc 
1e11 e5				push hl 
1e12			 
1e12			 
1e12 2a a5 f6		   	ld hl,(os_cur_ptr) 
1e15 7e					ld a,(hl) 
1e16			 
1e16					; poke the ascii to display 
1e16 2a 87 f6				ld hl,(os_word_scratch) 
1e19 77					ld (hl),a 
1e1a 23					inc hl 
1e1b 22 87 f6				ld (os_word_scratch),hl 
1e1e			 
1e1e					 
1e1e			 
1e1e			 
1e1e e1					pop hl 
1e1f e5					push hl 
1e20			 
1e20 cd 4a 12				call hexout 
1e23			 
1e23					 
1e23 2a a5 f6		   	ld hl,(os_cur_ptr) 
1e26 23				inc hl 
1e27 22 a5 f6		   	ld (os_cur_ptr),hl 
1e2a			 
1e2a e1					pop hl 
1e2b 23					inc hl 
1e2c 23					inc hl 
1e2d 23					inc hl 
1e2e			 
1e2e			 
1e2e			 
1e2e					;ld a,0 
1e2e					;ld (os_word_scratch+2),a 
1e2e					;pop af 
1e2e					;push af 
1e2e			 
1e2e					;ld de, os_word_scratch 
1e2e					;call str_at_display 
1e2e			;		call update_display 
1e2e			;		pop af 
1e2e c1					pop bc 
1e2f c6 03				add 3 
1e31 10 dd			djnz .dumpbyte 
1e33			 
1e33				 
1e33			 
1e33 c9				ret 
1e34			 
1e34			jump:	 
1e34			 
1e34 21 84 f3			ld hl,scratch+2 
1e37 cd 00 13			call get_word_hl 
1e3a				;ld hl,(scratch+2) 
1e3a				;call fourehexhl 
1e3a			 
1e3a 22 a5 f6			ld (os_cur_ptr),hl	 
1e3d			 
1e3d e9				jp (hl) 
1e3e			 
1e3e			 
1e3e			 
1e3e			; TODO implement a basic monitor mode to start with 
1e3e			 
1e3e			 
1e3e			 
1e3e			 
1e3e			 
1e3e			 
1e3e			 
1e3e			 
1e3e			 
1e3e			; testing and demo code during development 
1e3e			 
1e3e			 
1e3e .. 00		str1: db "Enter some text...",0 
1e51 .. 00		clear: db "                    ",0 
1e66			 
1e66			demo: 
1e66			 
1e66			 
1e66			 
1e66			;	call update_display 
1e66			 
1e66				; init scratch input area for testing 
1e66 21 82 f3			ld hl, scratch	 
1e69 3e 00			ld a,0 
1e6b 77				ld (hl),a 
1e6c			 
1e6c			 
1e6c 3e 14		            LD   A, display_row_2 
1e6e			;            CALL fLCD_Pos       ;Position cursor to location in A 
1e6e 11 3e 1e		            LD   DE, str1 
1e71 cd 28 0d			call str_at_display 
1e74			 
1e74			;            CALL fLCD_Str       ;Display string pointed to by DE 
1e74			cloop:	 
1e74 3e 28		            LD   A, display_row_3 
1e76			;            CALL fLCD_Pos       ;Position cursor to location in A 
1e76 11 51 1e		            LD   DE, clear 
1e79			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1e79 cd 28 0d				call str_at_display 
1e7c 3e 3c			ld a, display_row_4 
1e7e 11 ae 1e			ld de, prompt 
1e81			 
1e81 cd 28 0d				call str_at_display 
1e84 cd 38 0d			call update_display 
1e87			 
1e87 3e 55			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1e89 16 0a			ld d, 10 
1e8b 21 82 f3			ld hl, scratch	 
1e8e cd 76 0f			call input_str 
1e91			 
1e91			;	call clear_display 
1e91			;'	call update_display 
1e91			 
1e91 3e 00		            LD   A, display_row_1 
1e93			;            CALL fLCD_Pos       ;Position cursor to location in A 
1e93 11 51 1e		            LD   DE, clear 
1e96 cd 28 0d				call str_at_display 
1e99			;            CALL fLCD_Str       ;Display string pointed to by DE 
1e99 3e 00		            LD   A, display_row_1 
1e9b			;            CALL fLCD_Pos       ;Position cursor to location in A 
1e9b 11 82 f3		            LD   DE, scratch 
1e9e			;            CALL fLCD_Str       ;Display string pointed to by DE 
1e9e cd 28 0d				call str_at_display 
1ea1 cd 38 0d			call update_display 
1ea4			 
1ea4 3e 00				ld a,0 
1ea6 21 82 f3			ld hl, scratch 
1ea9 77				ld (hl),a 
1eaa			 
1eaa 00				nop 
1eab c3 74 1e			jp cloop 
1eae			 
1eae			 
1eae			 
1eae			; OS Prompt 
1eae			 
1eae .. 00		prompt: db ">",0 
1eb0 .. 00		endprg: db "?",0 
1eb2			 
1eb2			 
1eb2			; handy next page prompt 
1eb2			next_page_prompt: 
1eb2 e5				push hl 
1eb3 d5				push de 
1eb4 f5				push af 
1eb5 c5				push bc 
1eb6			 
1eb6 3e 4f			ld a,display_row_4 + display_cols - 1 
1eb8 11 b0 1e		        ld de, endprg 
1ebb cd 28 0d			call str_at_display 
1ebe cd 38 0d			call update_display 
1ec1 cd 06 6f			call cin_wait 
1ec4 c1				pop bc 
1ec5 f1				pop af 
1ec6 d1				pop de 
1ec7 e1				pop hl 
1ec8			 
1ec8			 
1ec8 c9				ret 
1ec9			 
1ec9			 
1ec9			; forth parser 
1ec9			 
1ec9			; My forth kernel 
1ec9			include "forth_kernel.asm" 
1ec9			; 
1ec9			; kernel to the forth OS 
1ec9			 
1ec9			DS_TYPE_STR: equ 1     ; string type 
1ec9			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1ec9			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1ec9			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1ec9			 
1ec9			FORTH_PARSEV1: equ 0 
1ec9			FORTH_PARSEV2: equ 0 
1ec9			FORTH_PARSEV3: equ 0 
1ec9			FORTH_PARSEV4: equ 0 
1ec9			FORTH_PARSEV5: equ 1 
1ec9			 
1ec9			;if FORTH_PARSEV5 
1ec9			;	FORTH_END_BUFFER: equ 0 
1ec9			;else 
1ec9			FORTH_END_BUFFER: equ 127 
1ec9			;endif 
1ec9			 
1ec9			FORTH_TRUE: equ 1 
1ec9			FORTH_FALSE: equ 0 
1ec9			 
1ec9			if FORTH_PARSEV4 
1ec9			include "forth_stackops.asm" 
1ec9			endif 
1ec9			 
1ec9			if FORTH_PARSEV5 
1ec9			include "forth_stackopsv5.asm" 
1ec9			 
1ec9			; Stack operations for v5 parser on wards 
1ec9			; * DATA stack 
1ec9			; * LOOP stack 
1ec9			; * RETURN stack 
1ec9			 
1ec9			 
1ec9			 
1ec9			FORTH_CHK_DSP_UNDER: macro 
1ec9				push hl 
1ec9				push de 
1ec9				ld hl,(cli_data_sp) 
1ec9				ld de, cli_data_stack 
1ec9				call cmp16 
1ec9				jp c, fault_dsp_under 
1ec9				pop de 
1ec9				pop hl 
1ec9				endm 
1ec9			 
1ec9			 
1ec9			FORTH_CHK_RSP_UNDER: macro 
1ec9				push hl 
1ec9				push de 
1ec9				ld hl,(cli_ret_sp) 
1ec9				ld de, cli_ret_stack 
1ec9				call cmp16 
1ec9				jp c, fault_rsp_under 
1ec9				pop de 
1ec9				pop hl 
1ec9				endm 
1ec9			 
1ec9			FORTH_CHK_LOOP_UNDER: macro 
1ec9				push hl 
1ec9				push de 
1ec9				ld hl,(cli_loop_sp) 
1ec9				ld de, cli_loop_stack 
1ec9				call cmp16 
1ec9				jp c, fault_loop_under 
1ec9				pop de 
1ec9				pop hl 
1ec9				endm 
1ec9			 
1ec9			FORTH_ERR_TOS_NOTSTR: macro 
1ec9				; TOSO might need more for checks when used 
1ec9				push af 
1ec9				ld a,(hl) 
1ec9				cp DS_TYPE_STR 
1ec9				jp nz, type_faultn   
1ec9				pop af 
1ec9				endm 
1ec9			 
1ec9			FORTH_ERR_TOS_NOTNUM: macro 
1ec9				push af 
1ec9				ld a,(hl) 
1ec9				cp DS_TYPE_INUM 
1ec9				jp nz, type_faultn   
1ec9				pop af 
1ec9				endm 
1ec9			 
1ec9			 
1ec9			; increase data stack pointer and save hl to it 
1ec9				 
1ec9			FORTH_DSP_NEXT: macro 
1ec9				call macro_forth_dsp_next 
1ec9				endm 
1ec9			 
1ec9			 
1ec9			macro_forth_dsp_next: 
1ec9				if DEBUG_FORTH_STACK_GUARD 
1ec9 cd 21 6a				call check_stacks 
1ecc				endif 
1ecc e5				push hl 
1ecd d5				push de 
1ece eb				ex de,hl 
1ecf 2a af fb			ld hl,(cli_data_sp) 
1ed2 23				inc hl 
1ed3 23				inc hl 
1ed4			 
1ed4			; PARSEV5 
1ed4 23				inc hl 
1ed5 22 af fb			ld (cli_data_sp),hl 
1ed8 73				ld (hl), e 
1ed9 23				inc hl 
1eda 72				ld (hl), d 
1edb d1				pop de 
1edc e1				pop hl 
1edd				if DEBUG_FORTH_STACK_GUARD 
1edd cd 21 6a				call check_stacks 
1ee0				endif 
1ee0 c9				ret 
1ee1			 
1ee1			 
1ee1			; increase ret stack pointer and save hl to it 
1ee1				 
1ee1			FORTH_RSP_NEXT: macro 
1ee1				call macro_forth_rsp_next 
1ee1				endm 
1ee1			 
1ee1			macro_forth_rsp_next: 
1ee1				if DEBUG_FORTH_STACK_GUARD 
1ee1 cd 21 6a				call check_stacks 
1ee4				endif 
1ee4 e5				push hl 
1ee5 d5				push de 
1ee6 eb				ex de,hl 
1ee7 2a b3 fb			ld hl,(cli_ret_sp) 
1eea 23				inc hl 
1eeb 23				inc hl 
1eec 22 b3 fb			ld (cli_ret_sp),hl 
1eef 73				ld (hl), e 
1ef0 23				inc hl 
1ef1 72				ld (hl), d 
1ef2 d1				pop de 
1ef3 e1				pop hl 
1ef4				if DEBUG_FORTH_STACK_GUARD 
1ef4 cd 21 6a				call check_stacks 
1ef7				endif 
1ef7 c9				ret 
1ef8			 
1ef8			; get current ret stack pointer and save to hl  
1ef8				 
1ef8			FORTH_RSP_TOS: macro 
1ef8				call macro_forth_rsp_tos 
1ef8				endm 
1ef8			 
1ef8			macro_forth_rsp_tos: 
1ef8				;push de 
1ef8 2a b3 fb			ld hl,(cli_ret_sp) 
1efb cd 33 1f			call loadhlptrtohl 
1efe				;ld e, (hl) 
1efe				;inc hl 
1efe				;ld d, (hl) 
1efe				;ex de, hl 
1efe					if DEBUG_FORTH_WORDS 
1efe			;			DMARK "RST" 
1efe						CALLMONITOR 
1efe cd c6 18			call break_point_state  
1f01				endm  
# End of macro CALLMONITOR
1f01					endif 
1f01				;pop de 
1f01 c9				ret 
1f02			 
1f02			; pop ret stack pointer 
1f02				 
1f02			FORTH_RSP_POP: macro 
1f02				call macro_forth_rsp_pop 
1f02				endm 
1f02			 
1f02			 
1f02			macro_forth_rsp_pop: 
1f02				if DEBUG_FORTH_STACK_GUARD 
1f02			;		DMARK "RPP" 
1f02 cd 21 6a				call check_stacks 
1f05					FORTH_CHK_RSP_UNDER 
1f05 e5				push hl 
1f06 d5				push de 
1f07 2a b3 fb			ld hl,(cli_ret_sp) 
1f0a 11 6d fb			ld de, cli_ret_stack 
1f0d cd 67 0f			call cmp16 
1f10 da 35 6b			jp c, fault_rsp_under 
1f13 d1				pop de 
1f14 e1				pop hl 
1f15				endm 
# End of macro FORTH_CHK_RSP_UNDER
1f15				endif 
1f15 e5				push hl 
1f16 2a b3 fb			ld hl,(cli_ret_sp) 
1f19			 
1f19			 
1f19				if FORTH_ENABLE_FREE 
1f19			 
1f19					; get pointer 
1f19			 
1f19					push de 
1f19					push hl 
1f19			 
1f19					ld e, (hl) 
1f19					inc hl 
1f19					ld d, (hl) 
1f19			 
1f19					ex de, hl 
1f19					call free 
1f19			 
1f19					pop hl 
1f19					pop de 
1f19			 
1f19			 
1f19				endif 
1f19			 
1f19			 
1f19 2b				dec hl 
1f1a 2b				dec hl 
1f1b 22 b3 fb			ld (cli_ret_sp), hl 
1f1e				; do stack underflow checks 
1f1e e1				pop hl 
1f1f				if DEBUG_FORTH_STACK_GUARD 
1f1f cd 21 6a				call check_stacks 
1f22					FORTH_CHK_RSP_UNDER 
1f22 e5				push hl 
1f23 d5				push de 
1f24 2a b3 fb			ld hl,(cli_ret_sp) 
1f27 11 6d fb			ld de, cli_ret_stack 
1f2a cd 67 0f			call cmp16 
1f2d da 35 6b			jp c, fault_rsp_under 
1f30 d1				pop de 
1f31 e1				pop hl 
1f32				endm 
# End of macro FORTH_CHK_RSP_UNDER
1f32				endif 
1f32 c9				ret 
1f33			 
1f33			 
1f33			 
1f33			; routine to load word pointed to by hl into hl 
1f33			 
1f33			loadhlptrtohl: 
1f33			 
1f33 d5				push de 
1f34 5e				ld e, (hl) 
1f35 23				inc hl 
1f36 56				ld d, (hl) 
1f37 eb				ex de, hl 
1f38 d1				pop de 
1f39			 
1f39 c9				ret 
1f3a			 
1f3a			 
1f3a			 
1f3a			 
1f3a			 
1f3a			; push a number held in HL onto the data stack 
1f3a			; entry point for pushing a value when already in hl used in function above 
1f3a			 
1f3a			forth_push_numhl: 
1f3a			 
1f3a e5				push hl    ; save value to push 
1f3b			 
1f3b			if DEBUG_FORTH_PUSH 
1f3b				; see if disabled 
1f3b			 
1f3b			 
1f3b f5				push af 
1f3c 3a 73 f3			ld a, (os_view_disable) 
1f3f fe 2a			cp '*' 
1f41 28 34			jr z, .pskip2 
1f43 e5				push hl 
1f44 e5			push hl 
1f45 cd 15 0d			call clear_display 
1f48 e1			pop hl 
1f49 7c				ld a,h 
1f4a 21 87 f6			ld hl, os_word_scratch 
1f4d cd 4a 12			call hexout 
1f50 e1				pop hl 
1f51 7d				ld a,l 
1f52 21 89 f6			ld hl, os_word_scratch+2 
1f55 cd 4a 12			call hexout 
1f58			 
1f58 21 8b f6			ld hl, os_word_scratch+4 
1f5b 3e 00			ld a,0 
1f5d 77				ld (hl),a 
1f5e 11 87 f6			ld de,os_word_scratch 
1f61 3e 14				ld a, display_row_2 
1f63 cd 28 0d				call str_at_display 
1f66 11 ee 55			ld de, .push_num 
1f69 3e 00			ld a, display_row_1 
1f6b			 
1f6b cd 28 0d				call str_at_display 
1f6e			 
1f6e			 
1f6e cd 38 0d			call update_display 
1f71 cd 92 0c			call delay1s 
1f74 cd 92 0c			call delay1s 
1f77			.pskip2:  
1f77			 
1f77 f1				pop af 
1f78			endif	 
1f78			 
1f78			 
1f78				FORTH_DSP_NEXT 
1f78 cd c9 1e			call macro_forth_dsp_next 
1f7b				endm 
# End of macro FORTH_DSP_NEXT
1f7b			 
1f7b 2a af fb			ld hl, (cli_data_sp) 
1f7e			 
1f7e				; save item type 
1f7e 3e 02			ld a,  DS_TYPE_INUM 
1f80 77				ld (hl), a 
1f81 23				inc hl 
1f82			 
1f82				; get word off stack 
1f82 d1				pop de 
1f83 7b				ld a,e 
1f84 77				ld (hl), a 
1f85 23				inc hl 
1f86 7a				ld a,d 
1f87 77				ld (hl), a 
1f88			 
1f88			if DEBUG_FORTH_PUSH 
1f88 2b				dec hl 
1f89 2b				dec hl 
1f8a 2b				dec hl 
1f8b						DMARK "PH5" 
1f8b f5				push af  
1f8c 3a a0 1f			ld a, (.dmark)  
1f8f 32 b4 fe			ld (debug_mark),a  
1f92 3a a1 1f			ld a, (.dmark+1)  
1f95 32 b5 fe			ld (debug_mark+1),a  
1f98 3a a2 1f			ld a, (.dmark+2)  
1f9b 32 b6 fe			ld (debug_mark+2),a  
1f9e 18 03			jr .pastdmark  
1fa0 ..			.dmark: db "PH5"  
1fa3 f1			.pastdmark: pop af  
1fa4			endm  
# End of macro DMARK
1fa4				CALLMONITOR 
1fa4 cd c6 18			call break_point_state  
1fa7				endm  
# End of macro CALLMONITOR
1fa7			endif	 
1fa7			 
1fa7 c9				ret 
1fa8			 
1fa8			 
1fa8			; Push a string to stack pointed to by hl 
1fa8			 
1fa8			forth_push_str: 
1fa8			 
1fa8			if DEBUG_FORTH_PUSH 
1fa8						DMARK "PSQ" 
1fa8 f5				push af  
1fa9 3a bd 1f			ld a, (.dmark)  
1fac 32 b4 fe			ld (debug_mark),a  
1faf 3a be 1f			ld a, (.dmark+1)  
1fb2 32 b5 fe			ld (debug_mark+1),a  
1fb5 3a bf 1f			ld a, (.dmark+2)  
1fb8 32 b6 fe			ld (debug_mark+2),a  
1fbb 18 03			jr .pastdmark  
1fbd ..			.dmark: db "PSQ"  
1fc0 f1			.pastdmark: pop af  
1fc1			endm  
# End of macro DMARK
1fc1				CALLMONITOR 
1fc1 cd c6 18			call break_point_state  
1fc4				endm  
# End of macro CALLMONITOR
1fc4			endif	 
1fc4			    
1fc4 e5				push hl 
1fc5 e5				push hl 
1fc6			 
1fc6			;	ld a, 0   ; find end of string 
1fc6 cd a7 13			call strlenz 
1fc9			if DEBUG_FORTH_PUSH 
1fc9						DMARK "PQ2" 
1fc9 f5				push af  
1fca 3a de 1f			ld a, (.dmark)  
1fcd 32 b4 fe			ld (debug_mark),a  
1fd0 3a df 1f			ld a, (.dmark+1)  
1fd3 32 b5 fe			ld (debug_mark+1),a  
1fd6 3a e0 1f			ld a, (.dmark+2)  
1fd9 32 b6 fe			ld (debug_mark+2),a  
1fdc 18 03			jr .pastdmark  
1fde ..			.dmark: db "PQ2"  
1fe1 f1			.pastdmark: pop af  
1fe2			endm  
# End of macro DMARK
1fe2				CALLMONITOR 
1fe2 cd c6 18			call break_point_state  
1fe5				endm  
# End of macro CALLMONITOR
1fe5			endif	 
1fe5 eb				ex de, hl 
1fe6 e1				pop hl   ; get ptr to start of string 
1fe7			if DEBUG_FORTH_PUSH 
1fe7						DMARK "PQ3" 
1fe7 f5				push af  
1fe8 3a fc 1f			ld a, (.dmark)  
1feb 32 b4 fe			ld (debug_mark),a  
1fee 3a fd 1f			ld a, (.dmark+1)  
1ff1 32 b5 fe			ld (debug_mark+1),a  
1ff4 3a fe 1f			ld a, (.dmark+2)  
1ff7 32 b6 fe			ld (debug_mark+2),a  
1ffa 18 03			jr .pastdmark  
1ffc ..			.dmark: db "PQ3"  
1fff f1			.pastdmark: pop af  
2000			endm  
# End of macro DMARK
2000				CALLMONITOR 
2000 cd c6 18			call break_point_state  
2003				endm  
# End of macro CALLMONITOR
2003			endif	 
2003 19				add hl,de 
2004			if DEBUG_FORTH_PUSH 
2004						DMARK "PQE" 
2004 f5				push af  
2005 3a 19 20			ld a, (.dmark)  
2008 32 b4 fe			ld (debug_mark),a  
200b 3a 1a 20			ld a, (.dmark+1)  
200e 32 b5 fe			ld (debug_mark+1),a  
2011 3a 1b 20			ld a, (.dmark+2)  
2014 32 b6 fe			ld (debug_mark+2),a  
2017 18 03			jr .pastdmark  
2019 ..			.dmark: db "PQE"  
201c f1			.pastdmark: pop af  
201d			endm  
# End of macro DMARK
201d				CALLMONITOR 
201d cd c6 18			call break_point_state  
2020				endm  
# End of macro CALLMONITOR
2020			endif	 
2020			 
2020 2b				dec hl    ; see if there is an optional trailing double quote 
2021 7e				ld a,(hl) 
2022 fe 22			cp '"' 
2024 20 03			jr nz, .strnoq 
2026 3e 00			ld a, 0      ; get rid of double quote 
2028 77				ld (hl), a 
2029 23			.strnoq: inc hl 
202a			 
202a 3e 00			ld a, 0 
202c 77				ld (hl), a     ; add null term and get rid of trailing double quote 
202d			 
202d 13				inc de ; add one for the type string 
202e 13				inc de ; add one for null term??? 
202f			 
202f				; tos is get string pointer again 
202f				; de contains space to allocate 
202f				 
202f d5				push de 
2030			 
2030 eb				ex de, hl 
2031			 
2031				;push af 
2031			 
2031			if DEBUG_FORTH_PUSH 
2031						DMARK "PHm" 
2031 f5				push af  
2032 3a 46 20			ld a, (.dmark)  
2035 32 b4 fe			ld (debug_mark),a  
2038 3a 47 20			ld a, (.dmark+1)  
203b 32 b5 fe			ld (debug_mark+1),a  
203e 3a 48 20			ld a, (.dmark+2)  
2041 32 b6 fe			ld (debug_mark+2),a  
2044 18 03			jr .pastdmark  
2046 ..			.dmark: db "PHm"  
2049 f1			.pastdmark: pop af  
204a			endm  
# End of macro DMARK
204a				CALLMONITOR 
204a cd c6 18			call break_point_state  
204d				endm  
# End of macro CALLMONITOR
204d			endif	 
204d cd 10 14			call malloc	; on ret hl now contains allocated memory 
2050				if DEBUG_FORTH_MALLOC_GUARD 
2050 cc 46 56				call z,malloc_error 
2053				endif 
2053			 
2053				 
2053 c1				pop bc    ; get length 
2054 d1				pop de   ;  get string start    
2055			 
2055				; hl has destination from malloc 
2055			 
2055 eb				ex de, hl    ; prep for ldir 
2056			 
2056 d5				push de   ; save malloc area for DSP later 
2057				;push hl   ; save malloc area for DSP later 
2057			 
2057			if DEBUG_FORTH_PUSH 
2057						DMARK "PHc" 
2057 f5				push af  
2058 3a 6c 20			ld a, (.dmark)  
205b 32 b4 fe			ld (debug_mark),a  
205e 3a 6d 20			ld a, (.dmark+1)  
2061 32 b5 fe			ld (debug_mark+1),a  
2064 3a 6e 20			ld a, (.dmark+2)  
2067 32 b6 fe			ld (debug_mark+2),a  
206a 18 03			jr .pastdmark  
206c ..			.dmark: db "PHc"  
206f f1			.pastdmark: pop af  
2070			endm  
# End of macro DMARK
2070				CALLMONITOR 
2070 cd c6 18			call break_point_state  
2073				endm  
# End of macro CALLMONITOR
2073			endif	 
2073			 
2073			 
2073 ed b0			ldir 
2075			 
2075			 
2075				; push malloc to data stack     macro?????  
2075			 
2075				FORTH_DSP_NEXT 
2075 cd c9 1e			call macro_forth_dsp_next 
2078				endm 
# End of macro FORTH_DSP_NEXT
2078			 
2078				; save value and type 
2078			 
2078 2a af fb			ld hl, (cli_data_sp) 
207b			 
207b				; save item type 
207b 3e 01			ld a,  DS_TYPE_STR 
207d 77				ld (hl), a 
207e 23				inc hl 
207f			 
207f				; get malloc word off stack 
207f d1				pop de 
2080 73				ld (hl), e 
2081 23				inc hl 
2082 72				ld (hl), d 
2083			 
2083			 
2083			 
2083			if DEBUG_FORTH_PUSH 
2083 2a af fb			ld hl, (cli_data_sp) 
2086						DMARK "PHS" 
2086 f5				push af  
2087 3a 9b 20			ld a, (.dmark)  
208a 32 b4 fe			ld (debug_mark),a  
208d 3a 9c 20			ld a, (.dmark+1)  
2090 32 b5 fe			ld (debug_mark+1),a  
2093 3a 9d 20			ld a, (.dmark+2)  
2096 32 b6 fe			ld (debug_mark+2),a  
2099 18 03			jr .pastdmark  
209b ..			.dmark: db "PHS"  
209e f1			.pastdmark: pop af  
209f			endm  
# End of macro DMARK
209f				CALLMONITOR 
209f cd c6 18			call break_point_state  
20a2				endm  
# End of macro CALLMONITOR
20a2			;	ex de,hl 
20a2			endif	 
20a2				; in case of spaces, skip the ptr past the copied string 
20a2				;pop af 
20a2				;ld (cli_origptr),hl 
20a2			 
20a2 c9				ret 
20a3			 
20a3			 
20a3			 
20a3			; TODO ascii push input onto stack given hl to start of input 
20a3			 
20a3			; identify type 
20a3			; if starts with a " then a string 
20a3			; otherwise it is a number 
20a3			;  
20a3			; if a string 
20a3			;     scan for ending " to get length of string to malloc for + 1 
20a3			;     malloc 
20a3			;     put pointer to string on stack first byte flags as string 
20a3			; 
20a3			; else a number 
20a3			;    look for number format identifier 
20a3			;    $xx hex 
20a3			;    %xxxxx bin 
20a3			;    xxxxx decimal 
20a3			;    convert number to 16bit word.  
20a3			;    malloc word + 1 with flag to identiy as num 
20a3			;    put pointer to number on stack 
20a3			;   
20a3			;  
20a3			  
20a3			forth_apush: 
20a3				; kernel push 
20a3			 
20a3			if DEBUG_FORTH_PUSH 
20a3						DMARK "PSH" 
20a3 f5				push af  
20a4 3a b8 20			ld a, (.dmark)  
20a7 32 b4 fe			ld (debug_mark),a  
20aa 3a b9 20			ld a, (.dmark+1)  
20ad 32 b5 fe			ld (debug_mark+1),a  
20b0 3a ba 20			ld a, (.dmark+2)  
20b3 32 b6 fe			ld (debug_mark+2),a  
20b6 18 03			jr .pastdmark  
20b8 ..			.dmark: db "PSH"  
20bb f1			.pastdmark: pop af  
20bc			endm  
# End of macro DMARK
20bc				CALLMONITOR 
20bc cd c6 18			call break_point_state  
20bf				endm  
# End of macro CALLMONITOR
20bf			endif	 
20bf				; identify input type 
20bf			 
20bf 7e				ld a,(hl) 
20c0 fe 22			cp '"' 
20c2 28 0a			jr z, .fapstr 
20c4 fe 24			cp '$' 
20c6 ca ee 20			jp z, .faphex 
20c9 fe 25			cp '%' 
20cb ca d6 20			jp z, .fapbin 
20ce			;	cp 'b' 
20ce			;	jp z, .fabin 
20ce				; else decimal 
20ce			 
20ce				; TODO do decimal conversion 
20ce				; decimal is stored as a 16bit word 
20ce			 
20ce				; by default everything is a string if type is not detected 
20ce			.fapstr: ; 
20ce fe 22			cp '"' 
20d0 20 01			jr nz, .strnoqu 
20d2 23				inc hl 
20d3			.strnoqu: 
20d3 c3 a8 1f			jp forth_push_str 
20d6			 
20d6			 
20d6			 
20d6			.fapbin:    ; push a binary string.  
20d6 11 00 00			ld de, 0   ; hold a 16bit value 
20d9			 
20d9 23			.fapbinshift:	inc hl  
20da 7e				ld a,(hl) 
20db fe 00			cp 0     ; done scanning  
20dd 28 0b			jr z, .fapbdone  	; got it in HL so push  
20df			 
20df				; left shift de 
20df eb				ex de, hl	 
20e0 29				add hl, hl 
20e1			 
20e1				; is 1 
20e1 fe 31			cp '1' 
20e3 20 02			jr nz, .binzero 
20e5 cb 4d			bit 1, l 
20e7			.binzero: 
20e7 eb				ex de, hl	 ; save current de 
20e8 18 ef			jr .fapbinshift 
20ea			 
20ea			.fapbdone: 
20ea eb				ex de, hl 
20eb c3 3a 1f			jp forth_push_numhl 
20ee			 
20ee			 
20ee			.faphex:   ; hex is always stored as a 16bit word 
20ee				; skip number prefix 
20ee 23				inc hl 
20ef				; turn ascii into number 
20ef cd 00 13			call get_word_hl	; ret 16bit word in hl 
20f2			 
20f2 c3 3a 1f			jp forth_push_numhl 
20f5			 
20f5 00				 nop 
20f6			 
20f6			.fabin:   ; TODO bin conversion 
20f6			 
20f6			 
20f6 c9				ret 
20f7			 
20f7			 
20f7			; get either a string ptr or a 16bit word from the data stack 
20f7			 
20f7			FORTH_DSP: macro 
20f7				call macro_forth_dsp 
20f7				endm 
20f7			 
20f7			macro_forth_dsp: 
20f7				; data stack pointer points to current word on tos 
20f7			 
20f7 2a af fb			ld hl,(cli_data_sp) 
20fa			 
20fa				if DEBUG_FORTH_PUSH 
20fa						DMARK "DSP" 
20fa f5				push af  
20fb 3a 0f 21			ld a, (.dmark)  
20fe 32 b4 fe			ld (debug_mark),a  
2101 3a 10 21			ld a, (.dmark+1)  
2104 32 b5 fe			ld (debug_mark+1),a  
2107 3a 11 21			ld a, (.dmark+2)  
210a 32 b6 fe			ld (debug_mark+2),a  
210d 18 03			jr .pastdmark  
210f ..			.dmark: db "DSP"  
2112 f1			.pastdmark: pop af  
2113			endm  
# End of macro DMARK
2113			 
2113 cd 7b 56				call display_data_sp 
2116				;call break_point_state 
2116				;rst 030h 
2116				CALLMONITOR 
2116 cd c6 18			call break_point_state  
2119				endm  
# End of macro CALLMONITOR
2119				endif 
2119			 
2119 c9				ret 
211a			 
211a			; return hl to start of value on stack 
211a			 
211a			FORTH_DSP_VALUE: macro 
211a				call macro_forth_dsp_value 
211a				endm 
211a			 
211a			macro_forth_dsp_value: 
211a			 
211a				FORTH_DSP 
211a cd f7 20			call macro_forth_dsp 
211d				endm 
# End of macro FORTH_DSP
211d			 
211d d5				push de 
211e			 
211e 23				inc hl ; skip type 
211f			 
211f 5e				ld e, (hl) 
2120 23				inc hl 
2121 56				ld d, (hl) 
2122 eb				ex de,hl  
2123			 
2123 d1				pop de 
2124			 
2124 c9				ret 
2125			 
2125			; return hl to start of value to second item on stack 
2125			 
2125			FORTH_DSP_VALUEM1: macro 
2125				call macro_forth_dsp_value_m1 
2125				endm 
2125			 
2125			macro_forth_dsp_value_m1: 
2125			 
2125				FORTH_DSP 
2125 cd f7 20			call macro_forth_dsp 
2128				endm 
# End of macro FORTH_DSP
2128			 
2128 2b				dec hl 
2129 2b				dec hl 
212a			;	dec hl 
212a			 
212a d5				push de 
212b			 
212b 5e				ld e, (hl) 
212c 23				inc hl 
212d 56				ld d, (hl) 
212e eb				ex de,hl  
212f			 
212f d1				pop de 
2130			 
2130 c9				ret 
2131			 
2131				 
2131			 
2131			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
2131			 
2131			FORTH_DSP_POP: macro 
2131				call macro_forth_dsp_pop 
2131				endm 
2131			 
2131			 
2131			; get the tos data type 
2131			 
2131			FORTH_DSP_TYPE:   macro 
2131			 
2131				;FORTH_DSP_VALUE 
2131				FORTH_DSP 
2131				 
2131				; hl points to value 
2131				; check type 
2131			 
2131				ld a,(hl) 
2131			 
2131				endm 
2131			 
2131			; load the tos value into hl 
2131			 
2131			 
2131			FORTH_DSP_VALUEHL:  macro 
2131				call macro_dsp_valuehl 
2131				endm 
2131			 
2131			 
2131			 
2131			macro_dsp_valuehl: 
2131				FORTH_DSP_VALUE 
2131 cd 1a 21			call macro_forth_dsp_value 
2134				endm 
# End of macro FORTH_DSP_VALUE
2134			 
2134				;FORTH_ERR_TOS_NOTNUM 
2134			 
2134				;inc hl   ; skip type id 
2134			 
2134			;	push de 
2134			; 
2134			;	ld e, (hl) 
2134			;	inc hl 
2134			;	ld d, (hl) 
2134			;	ex de,hl  
2134			 
2134			;	pop de 
2134			 
2134				if DEBUG_FORTH_PUSH 
2134						DMARK "DVL" 
2134 f5				push af  
2135 3a 49 21			ld a, (.dmark)  
2138 32 b4 fe			ld (debug_mark),a  
213b 3a 4a 21			ld a, (.dmark+1)  
213e 32 b5 fe			ld (debug_mark+1),a  
2141 3a 4b 21			ld a, (.dmark+2)  
2144 32 b6 fe			ld (debug_mark+2),a  
2147 18 03			jr .pastdmark  
2149 ..			.dmark: db "DVL"  
214c f1			.pastdmark: pop af  
214d			endm  
# End of macro DMARK
214d				CALLMONITOR 
214d cd c6 18			call break_point_state  
2150				endm  
# End of macro CALLMONITOR
2150				endif 
2150 c9				ret 
2151			 
2151			forth_apushstrhl:      
2151				; push of string requires use of cli_origptr 
2151				; bodge use 
2151			 
2151				; get current cli_origptr, save, update with temp pointer  
2151 ed 5b cb fb		ld de, (cli_origptr) 
2155 22 cb fb			ld (cli_origptr), hl 
2158 d5				push de 
2159 cd a3 20			call forth_apush 
215c d1				pop de 
215d ed 53 cb fb		ld (cli_origptr), de 
2161 c9			        ret	 
2162			 
2162			 
2162			; increase loop stack pointer and save hl to it 
2162				 
2162			FORTH_LOOP_NEXT: macro 
2162				call macro_forth_loop_next 
2162				;nop 
2162				endm 
2162			 
2162			macro_forth_loop_next: 
2162				if DEBUG_FORTH_STACK_GUARD 
2162 cd 21 6a				call check_stacks 
2165				endif 
2165 e5				push hl 
2166 d5				push de 
2167 eb				ex de,hl 
2168 2a b1 fb			ld hl,(cli_loop_sp) 
216b 23				inc hl 
216c 23				inc hl 
216d					if DEBUG_FORTH_WORDS 
216d						DMARK "LNX" 
216d f5				push af  
216e 3a 82 21			ld a, (.dmark)  
2171 32 b4 fe			ld (debug_mark),a  
2174 3a 83 21			ld a, (.dmark+1)  
2177 32 b5 fe			ld (debug_mark+1),a  
217a 3a 84 21			ld a, (.dmark+2)  
217d 32 b6 fe			ld (debug_mark+2),a  
2180 18 03			jr .pastdmark  
2182 ..			.dmark: db "LNX"  
2185 f1			.pastdmark: pop af  
2186			endm  
# End of macro DMARK
2186						CALLMONITOR 
2186 cd c6 18			call break_point_state  
2189				endm  
# End of macro CALLMONITOR
2189					endif 
2189 22 b1 fb			ld (cli_loop_sp),hl 
218c 73				ld (hl), e 
218d 23				inc hl 
218e 72				ld (hl), d 
218f d1				pop de    ; been reversed so save a swap on restore 
2190 e1				pop hl 
2191				if DEBUG_FORTH_STACK_GUARD 
2191 cd 21 6a				call check_stacks 
2194				endif 
2194 c9				ret 
2195			 
2195			; get current ret stack pointer and save to hl  
2195				 
2195			FORTH_LOOP_TOS: macro 
2195				call macro_forth_loop_tos 
2195				endm 
2195			 
2195			macro_forth_loop_tos: 
2195 d5				push de 
2196 2a b1 fb			ld hl,(cli_loop_sp) 
2199 5e				ld e, (hl) 
219a 23				inc hl 
219b 56				ld d, (hl) 
219c eb				ex de, hl 
219d d1				pop de 
219e c9				ret 
219f			 
219f			; pop loop stack pointer 
219f				 
219f			FORTH_LOOP_POP: macro 
219f				call macro_forth_loop_pop 
219f				endm 
219f			 
219f			 
219f			macro_forth_loop_pop: 
219f				if DEBUG_FORTH_STACK_GUARD 
219f					DMARK "LPP" 
219f f5				push af  
21a0 3a b4 21			ld a, (.dmark)  
21a3 32 b4 fe			ld (debug_mark),a  
21a6 3a b5 21			ld a, (.dmark+1)  
21a9 32 b5 fe			ld (debug_mark+1),a  
21ac 3a b6 21			ld a, (.dmark+2)  
21af 32 b6 fe			ld (debug_mark+2),a  
21b2 18 03			jr .pastdmark  
21b4 ..			.dmark: db "LPP"  
21b7 f1			.pastdmark: pop af  
21b8			endm  
# End of macro DMARK
21b8 cd 21 6a				call check_stacks 
21bb					FORTH_CHK_LOOP_UNDER 
21bb e5				push hl 
21bc d5				push de 
21bd 2a b1 fb			ld hl,(cli_loop_sp) 
21c0 11 eb fa			ld de, cli_loop_stack 
21c3 cd 67 0f			call cmp16 
21c6 da 3b 6b			jp c, fault_loop_under 
21c9 d1				pop de 
21ca e1				pop hl 
21cb				endm 
# End of macro FORTH_CHK_LOOP_UNDER
21cb				endif 
21cb e5				push hl 
21cc 2a b1 fb			ld hl,(cli_loop_sp) 
21cf 2b				dec hl 
21d0 2b				dec hl 
21d1 22 b1 fb			ld (cli_loop_sp), hl 
21d4				; TODO do stack underflow checks 
21d4 e1				pop hl 
21d5				if DEBUG_FORTH_STACK_GUARD 
21d5 cd 21 6a				call check_stacks 
21d8					FORTH_CHK_LOOP_UNDER 
21d8 e5				push hl 
21d9 d5				push de 
21da 2a b1 fb			ld hl,(cli_loop_sp) 
21dd 11 eb fa			ld de, cli_loop_stack 
21e0 cd 67 0f			call cmp16 
21e3 da 3b 6b			jp c, fault_loop_under 
21e6 d1				pop de 
21e7 e1				pop hl 
21e8				endm 
# End of macro FORTH_CHK_LOOP_UNDER
21e8				endif 
21e8 c9				ret 
21e9			 
21e9			macro_forth_dsp_pop: 
21e9			 
21e9 e5				push hl 
21ea			 
21ea				; release malloc data 
21ea			 
21ea				if DEBUG_FORTH_STACK_GUARD 
21ea cd 21 6a				call check_stacks 
21ed					FORTH_CHK_DSP_UNDER 
21ed e5				push hl 
21ee d5				push de 
21ef 2a af fb			ld hl,(cli_data_sp) 
21f2 11 e9 f8			ld de, cli_data_stack 
21f5 cd 67 0f			call cmp16 
21f8 da 2f 6b			jp c, fault_dsp_under 
21fb d1				pop de 
21fc e1				pop hl 
21fd				endm 
# End of macro FORTH_CHK_DSP_UNDER
21fd				endif 
21fd				;ld hl,(cli_data_sp) 
21fd			if DEBUG_FORTH_DOT 
21fd				DMARK "DPP" 
21fd				CALLMONITOR 
21fd			endif	 
21fd			 
21fd			 
21fd			if FORTH_ENABLE_DSPPOPFREE 
21fd			 
21fd				FORTH_DSP 
21fd cd f7 20			call macro_forth_dsp 
2200				endm 
# End of macro FORTH_DSP
2200			 
2200 7e				ld a, (hl) 
2201 fe 01			cp DS_TYPE_STR 
2203 20 07			jr nz, .skippopfree 
2205			 
2205				FORTH_DSP_VALUEHL 
2205 cd 31 21			call macro_dsp_valuehl 
2208				endm 
# End of macro FORTH_DSP_VALUEHL
2208 00				nop 
2209			if DEBUG_FORTH_DOT 
2209				DMARK "DPf" 
2209				CALLMONITOR 
2209			endif	 
2209 cd da 14			call free 
220c			.skippopfree: 
220c				 
220c			 
220c			endif 
220c			 
220c			if DEBUG_FORTH_DOT_KEY 
220c				DMARK "DP2" 
220c				CALLMONITOR 
220c			endif	 
220c			 
220c				; move pointer down 
220c			 
220c 2a af fb			ld hl,(cli_data_sp) 
220f 2b				dec hl 
2210 2b				dec hl 
2211			; PARSEV5 
2211 2b				dec hl 
2212 22 af fb			ld (cli_data_sp), hl 
2215			 
2215				if DEBUG_FORTH_STACK_GUARD 
2215 cd 21 6a				call check_stacks 
2218					FORTH_CHK_DSP_UNDER 
2218 e5				push hl 
2219 d5				push de 
221a 2a af fb			ld hl,(cli_data_sp) 
221d 11 e9 f8			ld de, cli_data_stack 
2220 cd 67 0f			call cmp16 
2223 da 2f 6b			jp c, fault_dsp_under 
2226 d1				pop de 
2227 e1				pop hl 
2228				endm 
# End of macro FORTH_CHK_DSP_UNDER
2228				endif 
2228			 
2228 e1				pop hl 
2229			 
2229 c9				ret 
222a			 
222a			getwordathl: 
222a				; hl points to an address 
222a				; load hl with the word at that address 
222a			 
222a d5				push de 
222b			 
222b 5e				ld e, (hl) 
222c 23				inc hl 
222d 56				ld d, (hl) 
222e eb				ex de, hl 
222f			 
222f d1				pop de 
2230 c9				ret 
2231			 
2231			 
2231			 
2231			 
2231			 
2231			; eof 
2231			 
# End of file forth_stackopsv5.asm
2231			endif 
2231			 
2231			user_word_eol:  
2231				; hl contains the pointer to where to create a linked list item from the end 
2231				; of the user dict to continue on at the system word dict 
2231				 
2231				; poke the stub of the word list linked list to repoint to rom words 
2231			 
2231				; stub format 
2231				; db   word id 
2231				; dw    link to next word 
2231			        ; db char length of token 
2231				; db string + 0 term 
2231				; db exec code....  
2231			 
2231 3e 00			ld a, WORD_SYS_ROOT     ; root word 
2233 77				ld (hl), a		; word id 
2234 23				inc hl 
2235			 
2235 11 00 24			ld de, sysdict 
2238 73				ld (hl), e		; next word link ie system dict 
2239 23				inc hl 
223a 72				ld (hl), d		; next word link ie system dict 
223b 23				inc hl	 
223c			 
223c			;	ld (hl), sysdict		; next word link ie system dict 
223c			;	inc hl 
223c			;	inc hl 
223c			 
223c			;	inc hl 
223c			;	inc hl 
223c			 
223c 3e 02			ld a, 2			; word length is 0 
223e 77				ld (hl), a	 
223f 23				inc hl 
2240			 
2240 3e 7e			ld a, '~'			; word length is 0 
2242 77				ld (hl), a	 
2243 23				inc hl 
2244 3e 00			ld a, 0			; save empty word 
2246 77				ld (hl), a 
2247			 
2247 c9				ret 
2248			 
2248				 
2248			 
2248			forthexec_cleanup: 
2248				FORTH_RSP_POP 
2248 cd 02 1f			call macro_forth_rsp_pop 
224b				endm 
# End of macro FORTH_RSP_POP
224b c9				ret 
224c			 
224c			forth_call_hl: 
224c				; taking hl 
224c e5				push hl 
224d c9				ret 
224e			 
224e			; this is called to reset Forth system but keep existing uwords etc 
224e			 
224e			forth_warmstart: 
224e				; setup stack over/under flow checks 
224e				if DEBUG_FORTH_STACK_GUARD 
224e cd 07 6a				call chk_stk_init 
2251				endif 
2251			 
2251				; init stack pointers  - * these stacks go upwards *  
2251 21 6d fb			ld hl, cli_ret_stack 
2254 22 b3 fb			ld (cli_ret_sp), hl	 
2257				; set bottom of stack 
2257 3e 00			ld a,0 
2259 77				ld (hl),a 
225a 23				inc hl 
225b 77				ld (hl),a 
225c			 
225c 21 e9 f8			ld hl, cli_data_stack 
225f 22 af fb			ld (cli_data_sp), hl	 
2262				; set bottom of stack 
2262 3e 00			ld a,0 
2264 77				ld (hl),a 
2265 23				inc hl 
2266 77				ld (hl),a 
2267			 
2267 21 eb fa			ld hl, cli_loop_stack 
226a 22 b1 fb			ld (cli_loop_sp), hl	 
226d				; set bottom of stack 
226d 3e 00			ld a,0 
226f 77				ld (hl),a 
2270 23				inc hl 
2271 77				ld (hl),a 
2272			 
2272				; init extent of current open file 
2272			 
2272 3e 00			ld a, 0 
2274 32 f7 fb			ld (store_openext), a 
2277			 
2277 c9				ret 
2278			 
2278			 
2278			; Cold Start - this is called to setup the whole Forth system 
2278			 
2278			forth_init: 
2278			 
2278				; setup stack over/under flow checks 
2278			 
2278			;	if DEBUG_FORTH_STACK_GUARD 
2278			;		call chk_stk_init 
2278			;	endif 
2278			 
2278				; enable auto display updates (slow.....) 
2278			 
2278 3e 01			ld a, 1 
227a 32 c9 fb			ld (cli_autodisplay), a 
227d			 
227d				; if storage is in use disable long reads for now 
227d 3e 00			ld a, 0 
227f 32 02 fc			ld (store_longread), a 
2282			 
2282			 
2282				; show start up screen 
2282			 
2282 cd 15 0d			call clear_display 
2285			 
2285 3e 00			ld a,0 
2287 32 eb fb			ld (f_cursor_ptr), a 
228a			 
228a				; set start of word list in start of ram - for use when creating user words 
228a			 
228a 21 00 80			ld hl, baseram 
228d 22 7f f6			ld (os_last_new_uword), hl 
2290 cd 31 22			call user_word_eol 
2293				 
2293			;		call display_data_sp 
2293			;		call next_page_prompt 
2293			 
2293			 
2293			 
2293			 
2293 c9				ret 
2294			 
2294 .. 00		.bootforth: db " Forth Kernel Init ",0 
22a8			 
22a8			; TODO push to stack 
22a8			 
22a8			;  
22a8			 
22a8			if FORTH_PARSEV2 
22a8			 
22a8			 
22a8				include "forth_parserv2.asm" 
22a8			 
22a8			endif 
22a8			 
22a8			 
22a8			; parse cli version 1 
22a8			 
22a8			if FORTH_PARSEV1 
22a8			 
22a8			 
22a8			 
22a8			      include "forth_parserv1.asm" 
22a8			endif 
22a8				 
22a8			if FORTH_PARSEV3 
22a8			 
22a8			 
22a8			 
22a8			      include "forth_parserv3.asm" 
22a8				include "forth_wordsv3.asm" 
22a8			endif 
22a8			 
22a8			if FORTH_PARSEV4 
22a8			 
22a8			 
22a8			 
22a8			      include "forth_parserv4.asm" 
22a8				include "forth_wordsv4.asm" 
22a8			endif 
22a8			 
22a8			if FORTH_PARSEV5 
22a8			 
22a8			 
22a8			 
22a8			      include "forth_parserv5.asm" 
22a8			 
22a8			 
22a8			; A better parser without using malloc and string copies all over the place.  
22a8			; Exec in situ should be faster 
22a8			 
22a8			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
22a8			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
22a8			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
22a8			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
22a8			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
22a8			WORD_SYS_END: equ 0   ; Opcode for all user words 
22a8			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
22a8			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
22a8			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
22a8			 
22a8			; Core word preamble macro 
22a8			 
22a8			CWHEAD:   macro nxtword opcode lit len opflags 
22a8				db WORD_SYS_CORE+opcode             
22a8				; internal op code number 
22a8				dw nxtword            
22a8				; link to next dict word block 
22a8				db len + 1 
22a8				; literal length of dict word inc zero term 
22a8				db lit,0              
22a8				; literal dict word 
22a8			        ; TODO db opflags        
22a8				endm 
22a8			 
22a8			 
22a8			NEXTW: macro  
22a8				jp macro_next 
22a8				endm 
22a8			 
22a8			macro_next: 
22a8			if DEBUG_FORTH_PARSE_KEY 
22a8				DMARK "NXT" 
22a8				CALLMONITOR 
22a8			endif	 
22a8			;	inc hl  ; skip token null term  
22a8 ed 4b cd fb		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
22ac ed 5b cb fb		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
22b0 2a 83 f6			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
22b3			if DEBUG_FORTH_PARSE_KEY 
22b3				DMARK "}AA" 
22b3				CALLMONITOR 
22b3			endif	 
22b3 c3 b6 23			jp execnext 
22b6				;jp exec1 
22b6			       
22b6			 
22b6			 
22b6			; Another go at the parser to compile  
22b6			 
22b6			 
22b6			; TODO rework parser to change all of the string words to byte tokens 
22b6			; TODO do a search for  
22b6			 
22b6			; TODO first run normal parser to zero term sections 
22b6			; TODO for each word do a token look up to get the op code 
22b6			; TODO need some means to flag to the exec that this is a byte code form    
22b6			 
22b6			 
22b6			forthcompile: 
22b6			 
22b6			; 
22b6			; line parse: 
22b6			;       parse raw input buffer 
22b6			;       tokenise the words 
22b6			;       malloc new copy (for looping etc) 
22b6			;       copy to malloc + current pc in line to start of string and add line term 
22b6			;       save on new rsp 
22b6			; 
22b6			 
22b6			; hl to point to the line to tokenise 
22b6			 
22b6			;	push hl 
22b6 22 83 f6			ld (os_tok_ptr), hl  ; save ptr to string 
22b9			 
22b9			;	ld a,0		; string term on input 
22b9			;	call strlent 
22b9			 
22b9			;	ld (os_tok_len), hl	 ; save string length 
22b9			 
22b9			;if DEBUG_FORTH_TOK 
22b9			;	ex de,hl		 
22b9			;endif 
22b9			 
22b9			;	pop hl 		; get back string pointer 
22b9			 
22b9			if DEBUG_FORTH_TOK 
22b9						DMARK "TOc" 
22b9				CALLMONITOR 
22b9			endif 
22b9 7e			.cptoken2:    ld a,(hl) 
22ba 23				inc hl 
22bb fe 7f			cp FORTH_END_BUFFER 
22bd 28 29			jr z, .cptokendone2 
22bf fe 00			cp 0 
22c1 28 25			jr z, .cptokendone2 
22c3 fe 22			cp '"' 
22c5 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
22c7 fe 20			cp ' ' 
22c9 20 ee			jr nz,  .cptoken2 
22cb			 
22cb			; TODO consume comments held between ( and ) 
22cb			 
22cb				; we have a space so change to zero term for dict match later 
22cb 2b				dec hl 
22cc 3e 00			ld a,0 
22ce 77				ld (hl), a 
22cf 23				inc hl 
22d0 18 e7			jr .cptoken2 
22d2				 
22d2			 
22d2			.cptokenstr2: 
22d2				; skip all white space until either eol (because forgot to term) or end double quote 
22d2			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
22d2				;inc hl ; skip current double quote 
22d2 7e				ld a,(hl) 
22d3 23				inc hl 
22d4 fe 22			cp '"' 
22d6 28 e1			jr z, .cptoken2 
22d8 fe 7f			cp FORTH_END_BUFFER 
22da 28 0c			jr z, .cptokendone2 
22dc fe 00			cp 0 
22de 28 08			jr z, .cptokendone2 
22e0 fe 20			cp ' ' 
22e2 28 02			jr z, .cptmp2 
22e4 18 ec			jr .cptokenstr2 
22e6			 
22e6			.cptmp2:	; we have a space so change to zero term for dict match later 
22e6				;dec hl 
22e6				;ld a,"-"	; TODO remove this when working 
22e6				;ld (hl), a 
22e6				;inc hl 
22e6 18 ea			jr .cptokenstr2 
22e8			 
22e8			.cptokendone2: 
22e8				;inc hl 
22e8 3e 7f			ld a, FORTH_END_BUFFER 
22ea 77				ld (hl),a 
22eb 23				inc hl 
22ec 3e 21			ld a, '!' 
22ee 77				ld (hl),a 
22ef			 
22ef 2a 83 f6			ld hl,(os_tok_ptr) 
22f2			         
22f2			if DEBUG_FORTH_TOK 
22f2						DMARK "Tc1" 
22f2				CALLMONITOR 
22f2			endif 
22f2			 
22f2				; push exec string to top of return stack 
22f2				FORTH_RSP_NEXT 
22f2 cd e1 1e			call macro_forth_rsp_next 
22f5				endm 
# End of macro FORTH_RSP_NEXT
22f5 c9				ret 
22f6			 
22f6			; Another go at the parser need to simplify the process 
22f6			 
22f6			forthparse: 
22f6			 
22f6			; 
22f6			; line parse: 
22f6			;       parse raw input buffer 
22f6			;       tokenise the words 
22f6			;       malloc new copy (for looping etc) 
22f6			;       copy to malloc + current pc in line to start of string and add line term 
22f6			;       save on new rsp 
22f6			; 
22f6			 
22f6			; hl to point to the line to tokenise 
22f6			 
22f6			;	push hl 
22f6 22 83 f6			ld (os_tok_ptr), hl  ; save ptr to string 
22f9			 
22f9			;	ld a,0		; string term on input 
22f9			;	call strlent 
22f9			 
22f9			;	ld (os_tok_len), hl	 ; save string length 
22f9			 
22f9			;if DEBUG_FORTH_TOK 
22f9			;	ex de,hl		 
22f9			;endif 
22f9			 
22f9			;	pop hl 		; get back string pointer 
22f9			 
22f9			if DEBUG_FORTH_TOK 
22f9						DMARK "TOK" 
22f9				CALLMONITOR 
22f9			endif 
22f9 7e			.ptoken2:    ld a,(hl) 
22fa 23				inc hl 
22fb fe 7f			cp FORTH_END_BUFFER 
22fd 28 29			jr z, .ptokendone2 
22ff fe 00			cp 0 
2301 28 25			jr z, .ptokendone2 
2303 fe 22			cp '"' 
2305 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
2307 fe 20			cp ' ' 
2309 20 ee			jr nz,  .ptoken2 
230b			 
230b			; TODO consume comments held between ( and ) 
230b			 
230b				; we have a space so change to zero term for dict match later 
230b 2b				dec hl 
230c 3e 00			ld a,0 
230e 77				ld (hl), a 
230f 23				inc hl 
2310 18 e7			jr .ptoken2 
2312				 
2312			 
2312			.ptokenstr2: 
2312				; skip all white space until either eol (because forgot to term) or end double quote 
2312			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
2312				;inc hl ; skip current double quote 
2312 7e				ld a,(hl) 
2313 23				inc hl 
2314 fe 22			cp '"' 
2316 28 e1			jr z, .ptoken2 
2318 fe 7f			cp FORTH_END_BUFFER 
231a 28 0c			jr z, .ptokendone2 
231c fe 00			cp 0 
231e 28 08			jr z, .ptokendone2 
2320 fe 20			cp ' ' 
2322 28 02			jr z, .ptmp2 
2324 18 ec			jr .ptokenstr2 
2326			 
2326			.ptmp2:	; we have a space so change to zero term for dict match later 
2326				;dec hl 
2326				;ld a,"-"	; TODO remove this when working 
2326				;ld (hl), a 
2326				;inc hl 
2326 18 ea			jr .ptokenstr2 
2328			 
2328			.ptokendone2: 
2328				;inc hl 
2328 3e 7f			ld a, FORTH_END_BUFFER 
232a 77				ld (hl),a 
232b 23				inc hl 
232c 3e 21			ld a, '!' 
232e 77				ld (hl),a 
232f			 
232f 2a 83 f6			ld hl,(os_tok_ptr) 
2332			         
2332			if DEBUG_FORTH_TOK 
2332						DMARK "TK1" 
2332				CALLMONITOR 
2332			endif 
2332			 
2332				; push exec string to top of return stack 
2332				FORTH_RSP_NEXT 
2332 cd e1 1e			call macro_forth_rsp_next 
2335				endm 
# End of macro FORTH_RSP_NEXT
2335 c9				ret 
2336			 
2336			; 
2336			;	; malloc size + buffer pointer + if is loop flag 
2336			;	ld hl,(os_tok_len) 		 ; get string length 
2336			; 
2336			;	ld a,l 
2336			; 
2336			;	cp 0			; we dont want to use a null string 
2336			;	ret z 
2336			; 
2336			;;	add 3    ; prefix malloc with buffer for current word ptr 
2336			; 
2336			;	add 5     ; TODO when certain not over writing memory remove 
2336			; 
2336			;		 
2336			; 
2336			;if DEBUG_FORTH_TOK 
2336			;			DMARK "TKE" 
2336			;	CALLMONITOR 
2336			;endif 
2336			; 
2336			;	ld l,a 
2336			;	ld h,0 
2336			;;	push hl   ; save required space for the copy later 
2336			;	call malloc 
2336			;if DEBUG_FORTH_TOK 
2336			;			DMARK "TKM" 
2336			;	CALLMONITOR 
2336			;endif 
2336			;	if DEBUG_FORTH_MALLOC_GUARD 
2336			;		push af 
2336			;		call ishlzero 
2336			;;		ld a, l 
2336			;;		add h 
2336			;;		cp 0 
2336			;		pop af 
2336			;		 
2336			;		call z,malloc_error 
2336			;	endif 
2336			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
2336			; 
2336			; 
2336			;if DEBUG_FORTH_TOK 
2336			;			DMARK "TKR" 
2336			;	CALLMONITOR 
2336			;endif 
2336			; 
2336			;	FORTH_RSP_NEXT 
2336			; 
2336			;	;inc hl	 ; go past current buffer pointer 
2336			;	;inc hl 
2336			;	;inc hl   ; and past if loop flag 
2336			;		; TODO Need to set flag  
2336			; 
2336			;	 
2336			;	 
2336			;	ex de,hl	; malloc is dest 
2336			;	ld hl, (os_tok_len) 
2336			;;	pop bc 
2336			;	ld c, l                
2336			;	ld b,0 
2336			;	ld hl, (os_tok_ptr) 
2336			; 
2336			;if DEBUG_FORTH_TOK 
2336			;			DMARK "TKT" 
2336			;	CALLMONITOR 
2336			;endif 
2336			; 
2336			;	; do str cpy 
2336			; 
2336			;	ldir      ; copy byte in hl to de 
2336			; 
2336			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
2336			; 
2336			;if DEBUG_FORTH_TOK 
2336			; 
2336			;			DMARK "TKY" 
2336			;	CALLMONITOR 
2336			;endif 
2336			;	;ld a,0 
2336			;	;ld a,FORTH_END_BUFFER 
2336			;	ex de, hl 
2336			;	;dec hl			 ; go back over the space delim at the end of word 
2336			;	;ld (hl),a 
2336			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
2336			;	ld a,FORTH_END_BUFFER 
2336			;	ld (hl),a 
2336			;	inc hl 
2336			;	ld a,FORTH_END_BUFFER 
2336			;	ld (hl),a 
2336			; 
2336			;	; init the malloc area data 
2336			;	; set pc for in current area 
2336			;	;ld hl, (os_tok_malloc) 
2336			;	;inc hl 
2336			;	;inc hl 
2336			;	;inc hl 
2336			;	;ex de,hl 
2336			;	;ld hl, (os_tok_malloc) 
2336			;	;ld (hl),e 
2336			;	;inc hl 
2336			;	;ld (hl),d 
2336			; 
2336			; 
2336			;	ld hl,(os_tok_malloc) 
2336			;if DEBUG_FORTH_PARSE_KEY 
2336			;			DMARK "TKU" 
2336			;	CALLMONITOR 
2336			;endif 
2336			; 
2336			;	ret 
2336			 
2336			forthexec: 
2336			 
2336			; line exec: 
2336			; forth parser 
2336			 
2336			; 
2336			;       get current exec line on rsp 
2336			 
2336				FORTH_RSP_TOS 
2336 cd f8 1e			call macro_forth_rsp_tos 
2339				endm 
# End of macro FORTH_RSP_TOS
2339			 
2339			;       restore current pc - hl points to malloc of data 
2339			 
2339				;ld e, (hl) 
2339				;inc hl 
2339				;ld d, (hl) 
2339				;ex de,hl 
2339			 
2339			 
2339			exec1: 
2339 22 83 f6			ld (os_tok_ptr), hl 
233c			 
233c				; copy our PC to working vars  
233c 22 cd fb			ld (cli_ptr), hl 
233f 22 cb fb			ld (cli_origptr), hl 
2342			 
2342 7e				ld a,(hl) 
2343 fe 7f			cp FORTH_END_BUFFER 
2345 c8				ret z 
2346			 
2346				; skip any nulls 
2346			 
2346 fe 00			cp 0 
2348 20 03			jr nz, .execword 
234a 23				inc hl 
234b 18 ec			jr exec1 
234d			 
234d			 
234d			.execword: 
234d			 
234d			 
234d			 
234d			if DEBUG_FORTH_PARSE_KEY 
234d						DMARK "KYQ" 
234d				CALLMONITOR 
234d			endif 
234d			;       while at start of word: 
234d			; get start of dict (in user area first) 
234d			 
234d 21 00 80		ld hl, baseram 
2350			;ld hl, sysdict 
2350 22 cf fb		ld (cli_nextword),hl 
2353			;           match word at pc 
2353			;           exec word 
2353			;           or push to dsp 
2353			;           forward to next token 
2353			;           if line term pop rsp and exit 
2353			;        
2353			 
2353			if DEBUG_FORTH_PARSE_KEY 
2353						DMARK "KYq" 
2353				CALLMONITOR 
2353			endif 
2353			 
2353			; 
2353			; word comp 
2353			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
2353			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
2353			;    move to start of word  
2353			;    compare word to cli_token 
2353			 
2353			.execpnword:	; HL at start of a word in the dictionary to check 
2353			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
2353			;	ld (cli_ptr), hl 
2353			 
2353 2a cf fb			ld hl,(cli_nextword) 
2356			 
2356 cd f9 23			call forth_tok_next 
2359			; tok next start here 
2359			;	; TODO skip compiled symbol for now 
2359			;	inc hl 
2359			; 
2359			;	; save pointer to next word 
2359			; 
2359			;	; hl now points to the address of the next word pointer  
2359			;	ld e, (hl) 
2359			;	inc hl 
2359			;	ld d, (hl) 
2359			;	inc l 
2359			; 
2359			;	ex de,hl 
2359			;if DEBUG_FORTH_PARSE_NEXTWORD 
2359			;	push bc 
2359			;	ld bc, (cli_nextword) 
2359			;			DMARK "NXW" 
2359			;	CALLMONITOR 
2359			;	pop bc 
2359			;endif 
2359			; tok next end here 
2359 22 cf fb			ld (cli_nextword), hl     ; save for next check if no match on this word 
235c eb				ex de, hl 
235d			 
235d			 
235d				; save the pointer of the current token - 1 to check against 
235d				 
235d 22 d3 fb			ld (cli_token), hl   
2360				; TODO maybe remove below save if no debug 
2360				; save token string ptr for any debug later 
2360 23				inc hl  
2361 22 d5 fb			ld (cli_origtoken), hl 
2364 2b				dec hl 
2365				; save pointer to the start of the next dictionay word 
2365 7e				ld a,(hl)   ; get string length 
2366 47				ld b,a 
2367			.execpnwordinc:  
2367 23				inc hl 
2368 10 fd			djnz .execpnwordinc 
236a 22 d1 fb			ld (cli_execword), hl      ; save start of this words code 
236d			 
236d				; now check the word token against the string being parsed 
236d			 
236d 2a d3 fb			ld hl,(cli_token) 
2370 23				inc hl     ; skip string length (use zero term instead to end) 
2371 22 d3 fb			ld (cli_token), hl 
2374			 
2374			if DEBUG_FORTH_PARSE_KEY 
2374						DMARK "KY2" 
2374			endif 
2374			if DEBUG_FORTH_PARSE_EXEC 
2374				; see if disabled 
2374			 
2374				ld a, (os_view_disable) 
2374				cp '*' 
2374				jr z, .skip 
2374			 
2374				push hl 
2374				push hl 
2374				call clear_display 
2374				ld de, .compword 
2374				ld a, display_row_1 
2374				call str_at_display 
2374				pop de 
2374				ld a, display_row_2 
2374				call str_at_display 
2374				ld hl,(cli_ptr) 
2374				ld a,(hl) 
2374			        ld hl, os_word_scratch 
2374				ld (hl),a 
2374				ld a,0 
2374				inc hl 
2374				ld (hl),a 	 
2374				ld de, os_word_scratch 
2374				ld a, display_row_2+10 
2374				call str_at_display 
2374				call update_display 
2374				ld a, 100 
2374				call aDelayInMS 
2374				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2374				call delay250ms 
2374				endif 
2374				pop hl 
2374			.skip:  
2374			endif	 
2374			.execpnchar:    ; compare char between token and string to parse 
2374			 
2374			if DEBUG_FORTH_PARSE_KEY 
2374						DMARK "Ky3" 
2374			endif 
2374			if DEBUG_FORTH_PARSE_EXEC 
2374				; see if disabled 
2374			 
2374				ld a, (os_view_disable) 
2374				cp '*' 
2374				jr z, .skip2 
2374			 
2374			;	call clear_display 
2374			ld hl,(cli_token) 
2374			ld a,(hl) 
2374			ld (os_word_scratch),a 
2374				ld hl,(cli_ptr) 
2374			ld a,(hl) 
2374				ld (os_word_scratch+1),a 
2374				ld a,0 
2374				ld (os_word_scratch+2),a 
2374				ld de,os_word_scratch 
2374				ld a,display_row_4 
2374				call str_at_display 
2374				call update_display 
2374			.skip2:  
2374			endif 
2374 2a d3 fb			ld hl,(cli_token) 
2377 7e				ld a, (hl)	 ; char in word token 
2378 23				inc hl 		; move to next char 
2379 22 d3 fb			ld (cli_token), hl ; and save it 
237c 47				ld b,a 
237d			 
237d 2a cd fb			ld hl,(cli_ptr) ;	get the char from the string to parse 
2380 7e				ld a,(hl) 
2381 23				inc hl 
2382 22 cd fb			ld (cli_ptr), hl		; move to next char 
2385 cd 9e 13			call toUpper 		; make sure the input string matches case 
2388			 
2388			if DEBUG_FORTH_PARSE 
2388			endif 
2388			 
2388				; input stream end of token is a space so get rid of it 
2388			 
2388			;	cp ' ' 
2388			;	jr nz, .pnskipspace 
2388			; 
2388			;	ld a, 0		; make same term as word token term 
2388			; 
2388			;.pnskipspace: 
2388			 
2388			if DEBUG_FORTH_PARSE_KEY 
2388						DMARK "KY7" 
2388			endif 
2388 b8				cp b 
2389 c2 9f 23			jp nz, .execpnskipword	 ; no match so move to next word 
238c				 
238c			;    if same 
238c			;       scan for string terms 0 for token and 32 for input 
238c			 
238c				 
238c			if DEBUG_FORTH_PARSE_KEY 
238c						DMARK "KY8" 
238c			endif 
238c			 
238c 80				add b			 
238d fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
238f							; TODO need to make sure last word in zero term string is accounted for 
238f 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
2391			 
2391			 
2391				; at end of both strings so both are exact match 
2391			 
2391			;       skip ptr for next word 
2391			 
2391 2a cd fb			ld hl,(cli_ptr) 	; at input string term 
2394 23				inc hl			 ; at next char 
2395 22 cd fb			ld (cli_ptr), hl     ; save for next round of the parser 
2398 22 cb fb			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
239b				 
239b				 
239b			if DEBUG_FORTH_PARSE_KEY 
239b						DMARK "KY3" 
239b			endif 
239b			 
239b			 
239b			 
239b			;       exec code block 
239b			if DEBUG_FORTH_JP 
239b				call clear_display 
239b				call update_display 
239b				call delay1s 
239b				ld hl, (cli_execword)     ; save for next check if no match on this word 
239b				ld a,h 
239b				ld hl, os_word_scratch 
239b				call hexout 
239b				ld hl, (cli_execword)     ; save for next check if no match on this word 
239b				ld a,l 
239b				ld hl, os_word_scratch+2 
239b				call hexout 
239b				ld hl, os_word_scratch+4 
239b				ld a,0 
239b				ld (hl),a 
239b				ld de,os_word_scratch 
239b				call str_at_display 
239b					ld a, display_row_2 
239b					call str_at_display 
239b				ld de, (cli_origtoken) 
239b				ld a, display_row_1+10 
239b					call str_at_display 
239b			 
239b				ld a,display_row_1 
239b				ld de, .foundword 
239b				ld a, display_row_3 
239b				call str_at_display 
239b				call update_display 
239b				call delay1s 
239b				call delay1s 
239b				call delay1s 
239b			endif 
239b			 
239b			if DEBUG_FORTH_PARSE_KEY 
239b						DMARK "KYj" 
239b			endif 
239b				; TODO save the word pointer in this exec 
239b			 
239b 2a d1 fb			ld hl,(cli_execword) 
239e e9				jp (hl) 
239f			 
239f			 
239f			;    if not same 
239f			;	scan for zero term 
239f			;	get ptr for next word 
239f			;	goto word comp 
239f			 
239f			.execpnskipword:	; get pointer to next word 
239f 2a cf fb			ld hl,(cli_nextword) 
23a2			 
23a2 7e				ld a,(hl) 
23a3 fe 00			cp WORD_SYS_END 
23a5			;	cp 0 
23a5 28 09			jr z, .execendofdict			 ; at end of words 
23a7			 
23a7			if DEBUG_FORTH_PARSE_KEY 
23a7						DMARK "KY4" 
23a7			endif 
23a7			if DEBUG_FORTH_PARSE_EXEC 
23a7			 
23a7				; see if disabled 
23a7			 
23a7				ld a, (os_view_disable) 
23a7				cp '*' 
23a7				jr z, .noskip 
23a7			 
23a7			 
23a7				ld de, .nowordfound 
23a7				ld a, display_row_3 
23a7				call str_at_display 
23a7				call update_display 
23a7				ld a, 100 
23a7				call aDelayInMS 
23a7				 
23a7				if DEBUG_FORTH_PARSE_EXEC_SLOW 
23a7					call delay250ms 
23a7				endif 
23a7			.noskip:  
23a7			 
23a7			endif	 
23a7			 
23a7 2a cb fb			ld hl,(cli_origptr) 
23aa 22 cd fb			ld (cli_ptr),hl 
23ad			 
23ad			if DEBUG_FORTH_PARSE_KEY 
23ad						DMARK "KY5" 
23ad			endif 
23ad c3 53 23			jp .execpnword			; else go to next word 
23b0			 
23b0			.execendofdict:  
23b0			 
23b0			if DEBUG_FORTH_PARSE_KEY 
23b0						DMARK "KYe" 
23b0			endif 
23b0			if DEBUG_FORTH_PARSE_EXEC 
23b0				; see if disabled 
23b0			 
23b0				ld a, (os_view_disable) 
23b0				cp '*' 
23b0				jr z, .ispskip 
23b0			 
23b0				call clear_display 
23b0				call update_display 
23b0				call delay1s 
23b0				ld de, (cli_origptr) 
23b0				ld a, display_row_1 
23b0				call str_at_display 
23b0				 
23b0				ld de, .enddict 
23b0				ld a, display_row_3 
23b0				call str_at_display 
23b0				call update_display 
23b0				ld a, 100 
23b0				call aDelayInMS 
23b0				if DEBUG_FORTH_PARSE_EXEC_SLOW 
23b0				call delay1s 
23b0				call delay1s 
23b0				call delay1s 
23b0				endif 
23b0			.ispskip:  
23b0				 
23b0			endif	 
23b0			 
23b0			 
23b0			 
23b0				; if the word is not a keyword then must be a literal so push it to stack 
23b0			 
23b0			; push token to stack to end of word 
23b0			 
23b0				STACKFRAME ON $1efe $2f9f 
23b0				if DEBUG_STACK_IMB 
23b0					if ON 
23b0						exx 
23b0						ld de, $1efe 
23b0						ld a, d 
23b0						ld hl, curframe 
23b0						call hexout 
23b0						ld a, e 
23b0						ld hl, curframe+2 
23b0						call hexout 
23b0						ld hl, $1efe 
23b0						push hl 
23b0						ld hl, $2f9f 
23b0						push hl 
23b0						exx 
23b0					endif 
23b0				endif 
23b0			endm 
# End of macro STACKFRAME
23b0			 
23b0 2a 83 f6		ld hl,(os_tok_ptr) 
23b3 cd a3 20		call forth_apush 
23b6			 
23b6				STACKFRAMECHK ON $1efe $2f9f 
23b6				if DEBUG_STACK_IMB 
23b6					if ON 
23b6						exx 
23b6						ld hl, $2f9f 
23b6						pop de   ; $2f9f 
23b6						call cmp16 
23b6						jr nz, .spnosame 
23b6						ld hl, $1efe 
23b6						pop de   ; $1efe 
23b6						call cmp16 
23b6						jr z, .spfrsame 
23b6						.spnosame: call showsperror 
23b6						.spfrsame: nop 
23b6						exx 
23b6					endif 
23b6				endif 
23b6			endm 
# End of macro STACKFRAMECHK
23b6			 
23b6			execnext: 
23b6			 
23b6			if DEBUG_FORTH_PARSE_KEY 
23b6						DMARK "KY>" 
23b6			endif 
23b6			; move past token to next word 
23b6			 
23b6 2a 83 f6		ld hl, (os_tok_ptr) 
23b9 3e 00		ld a, 0 
23bb 01 ff 00		ld bc, 255     ; input buffer size 
23be ed b1		cpir 
23c0			 
23c0			if DEBUG_FORTH_PARSE_KEY 
23c0						DMARK "KY!" 
23c0				CALLMONITOR 
23c0			endif	 
23c0			; TODO this might place hl on the null, so will need to forward on??? 
23c0			;inc hl   ; see if this gets onto the next item 
23c0			 
23c0			 
23c0			; TODO pass a pointer to the buffer to push 
23c0			; TODO call function to push 
23c0			 
23c0			; look for end of input 
23c0			 
23c0			;inc hl 
23c0			;ld a,(hl) 
23c0			;cp FORTH_END_BUFFER 
23c0			;ret z 
23c0			 
23c0			 
23c0 c3 39 23		jp exec1 
23c3			 
23c3			 
23c3			 
23c3			 
23c3			 
23c3			 
23c3			 
23c3			 
23c3			 
23c3			findnexttok: 
23c3			 
23c3				; hl is pointer to move 
23c3				; de is the token to locate 
23c3			 
23c3					if DEBUG_FORTH 
23c3						DMARK "NTK" 
23c3						CALLMONITOR 
23c3					endif 
23c3 d5				push de 
23c4			 
23c4			.fnt1:	 
23c4				; find first char of token to locate 
23c4			 
23c4 1a				ld a, (de) 
23c5 4f				ld c,a 
23c6 7e				ld a,(hl) 
23c7 cd 9e 13			call toUpper 
23ca					if DEBUG_FORTH 
23ca						DMARK "NT1" 
23ca						CALLMONITOR 
23ca					endif 
23ca b9				cp c 
23cb			 
23cb 28 03			jr z, .fnt2cmpmorefirst	 
23cd			 
23cd				; first char not found move to next char 
23cd			 
23cd 23				inc hl 
23ce 18 f4			jr .fnt1 
23d0			 
23d0			.fnt2cmpmorefirst:	 
23d0				; first char of token found.  
23d0			 
23d0 e5				push hl     ; save start of token just in case it is the right one 
23d1 d9				exx 
23d2 e1				pop hl        ; save it to hl' 
23d3 d9				exx 
23d4			 
23d4			 
23d4			.fnt2cmpmore:	 
23d4				; compare the rest 
23d4				 
23d4 23				inc hl 
23d5 13				inc de 
23d6				 
23d6 1a				ld a, (de) 
23d7 4f				ld c,a 
23d8 7e				ld a,(hl) 
23d9 cd 9e 13			call toUpper 
23dc			 
23dc					if DEBUG_FORTH 
23dc						DMARK "NT2" 
23dc						CALLMONITOR 
23dc					endif 
23dc				; c has the token to find char 
23dc				; a has the mem to scan char 
23dc			 
23dc b9				cp c 
23dd 28 04			jr z,.fntmatch1 
23df			 
23df				; they are not the same 
23df			 
23df					if DEBUG_FORTH 
23df						DMARK "NT3" 
23df						CALLMONITOR 
23df					endif 
23df d1				pop de	; reset de token to look for 
23e0 d5				push de 
23e1 18 e1			jr .fnt1 
23e3				 
23e3			.fntmatch1: 
23e3			 
23e3				; is the same char a null which means we might have a full hit? 
23e3					if DEBUG_FORTH 
23e3						DMARK "NT4" 
23e3						CALLMONITOR 
23e3					endif 
23e3			 
23e3 fe 00			cp 0 
23e5 28 0b			jr z, .fntmatchyes 
23e7			 
23e7				; are we at the end of the token to find? 
23e7			 
23e7					if DEBUG_FORTH 
23e7						DMARK "NT5" 
23e7						CALLMONITOR 
23e7					endif 
23e7 3e 00			ld a, 0 
23e9 b9				cp c 
23ea			 
23ea c2 d4 23			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
23ed			 
23ed					if DEBUG_FORTH 
23ed						DMARK "NT6" 
23ed						CALLMONITOR 
23ed					endif 
23ed				; token to find is exhusted but no match to stream 
23ed			 
23ed				; restore tok pointer and continue on 
23ed d1				pop de 
23ee d5				push de 
23ef c3 c4 23			jp .fnt1 
23f2			 
23f2			 
23f2			.fntmatchyes: 
23f2			 
23f2				; hl now contains the end of the found token 
23f2			 
23f2				; get rid of saved token pointer to find 
23f2			 
23f2 d1				pop de 
23f3			 
23f3					if DEBUG_FORTH 
23f3						DMARK "NT9" 
23f3						CALLMONITOR 
23f3					endif 
23f3			 
23f3				; hl will be on the null term so forward on 
23f3			 
23f3				; get back the saved start of the token 
23f3			 
23f3 d9				exx 
23f4 e5				push hl     ; save start of token just in case it is the right one 
23f5 d9				exx 
23f6 e1				pop hl        ; save it to hl 
23f7			 
23f7 c9				ret 
23f8			 
23f8			 
23f8			; LIST needs to find a specific token   
23f8			; FORGET needs to find a spefici token 
23f8			 
23f8			; SAVE needs to find all tokens by flag 
23f8			; WORDS just needs to scan through all  by flag 
23f8			; UWORDS needs to scan through all by flag 
23f8			 
23f8			 
23f8			; given hl as pointer to start of dict look up string 
23f8			; return hl as pointer to start of word block 
23f8			; or 0 if not found 
23f8			 
23f8			forth_find_tok: 
23f8 c9				ret 
23f9			 
23f9			; given hl as pointer to dict structure 
23f9			; move to the next dict block structure 
23f9			 
23f9			forth_tok_next: 
23f9				; hl now points to the address of the next word pointer  
23f9				; TODO skip compiled symbol for now 
23f9			;	push de 
23f9 23				inc hl 
23fa 5e				ld e, (hl) 
23fb 23				inc hl 
23fc 56				ld d, (hl) 
23fd 23				inc hl 
23fe			 
23fe eb				ex de,hl 
23ff			if DEBUG_FORTH_PARSE_NEXTWORD 
23ff				push bc 
23ff				ld bc, (cli_nextword) 
23ff						DMARK "NXW" 
23ff				CALLMONITOR 
23ff				pop bc 
23ff			endif 
23ff			;	pop de	 
23ff c9				ret 
2400			 
2400			 
2400			 
2400			; eof 
# End of file forth_parserv5.asm
2400				include "forth_wordsv4.asm" 
2400			 
2400			; the core word dictionary v4 
2400			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
2400			 
2400			; this is a linked list for each of the system words used 
2400			; user defined words will follow the same format but will be in ram 
2400			 
2400			 
2400			; 
2400			; 
2400			; define linked list: 
2400			; 
2400			; 1. compiled byte op code 
2400			; 2. len of text word 
2400			; 3. text word 
2400			; 4. ptr to next dictionary word 
2400			; 5. asm, calls etc for the word 
2400			; 
2400			;  if 1 == 0 then last word in dict  
2400			;   
2400			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
2400			;  
2400			;  
2400			; create basic standard set of words 
2400			; 
2400			;  
2400			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
2400			; 2DUP 2DROP 2SWAP  
2400			; @ C@ - get byte  
2400			; ! C! - store byte 
2400			; 0< true if less than zero 
2400			; 0= true if zero 
2400			; < >  
2400			; = true if same 
2400			; variables 
2400			 
2400			 
2400			; Hardware specific words I may need 
2400			; 
2400			; IN OUT  
2400			; calls to key util functions 
2400			; calls to hardward abstraction stuff 
2400			; easy control of frame buffers and lcd i/o 
2400			; keyboard  
2400			 
2400			 
2400			;DICT: macro 
2400			; op_code, len, word, next 
2400			;    word: 
2400			;    db op_code 
2400			;    ds word zero term 
2400			;    dw next 
2400			;    endm 
2400			 
2400			 
2400			 
2400			 
2400			; op code 1 is a flag for user define words which are to be handled differently 
2400			 
2400			 
2400			; 
2400			; 
2400			;    TODO on entry to a word this should be the expected environment 
2400			;    hl - tos value if number then held, if string this is the ptr 
2400			;    de -  
2400			 
2400			 
2400			; opcode ranges 
2400			; 0 - end of word dict 
2400			; 255 - user define words 
2400			 
2400			sysdict: 
2400			include "forth_opcodes.asm" 
2400			; op codes for forth keywords 
2400			; free to use code 0  
2400				OPCODE_HEAP: equ  1 
2400				OPCODE_EXEC: equ 2 
2400				OPCODE_DUP: equ 3 
2400				OPCODE_SWAP: equ 4 
2400				OPCODE_COLN: equ 5 
2400				OPCODE_SCOLN: equ 6 
2400				OPCODE_DROP: equ 7 
2400				OPCODE_DUP2: equ 8 
2400				OPCODE_DROP2: equ 9 
2400				OPCODE_SWAP2: equ 10 
2400				OPCODE_AT: equ 11 
2400				OPCODE_CAT: equ 12 
2400				OPCODE_BANG: equ 13 
2400				OPCODE_CBANG: equ 14 
2400				OPCODE_SCALL: equ 15 
2400				OPCODE_DEPTH: equ 16 
2400				OPCODE_OVER: equ 17 
2400				OPCODE_PAUSE: equ 18 
2400				OPCODE_PAUSES: equ 19 
2400				OPCODE_ROT: equ 20 
2400			;free to reuse	OPCODE_WORDS: equ 21 
2400			        OPCODE_NOT: equ 21 
2400				OPCODE_UWORDS: equ 22 
2400				OPCODE_BP: equ 23 
2400				OPCODE_MONITOR: equ 24  
2400				OPCODE_MALLOC: equ 25 
2400				OPCODE_FREE: equ 26 
2400				OPCODE_LIST: equ 27 
2400				OPCODE_FORGET: equ 28 
2400				OPCODE_NOP: equ 29 
2400				OPCODE_COMO: equ 30 
2400				OPCODE_COMC: equ 31 
2400			;free to reuse	OPCODE_ENDCORE: equ 32 
2400				OPCODE_AFTERSOUND: equ 33 
2400				OPCODE_GP2: equ 34 
2400				OPCODE_GP3: equ 35 
2400				OPCODE_GP4: equ 36 
2400				OPCODE_SIN: equ 37 
2400				OPCODE_SOUT: equ 38 
2400				OPCODE_SPIO: equ 39 
2400				OPCODE_SPICEH: equ 40 
2400				OPCODE_SPIOb: equ 41 
2400				OPCODE_SPII: equ 42 
2400				OPCODE_SESEL: equ 43 
2400				OPCODE_CARTDEV: equ 44 
2400			; free to reuse	OPCODE_ENDDEVICE: equ 45 
2400				OPCODE_FB: equ 46 
2400				OPCODE_EMIT: equ 47 
2400				OPCODE_DOTH: equ 48 
2400				OPCODE_DOTF: equ 49 
2400				OPCODE_DOT: equ 50 
2400				OPCODE_CLS: equ 51 
2400				OPCODE_DRAW: equ 52 
2400				OPCODE_DUMP: equ 53 
2400				OPCODE_CDUMP: equ 54 
2400				OPCODE_DAT: equ 55 
2400				OPCODE_HOME: equ 56 
2400				OPCODE_SPACE: equ 57 
2400				OPCODE_SPACES: equ 58 
2400				OPCODE_SCROLL: equ 59 
2400				OPCODE_ATQ: equ 60 
2400				OPCODE_AUTODSP: equ 61 
2400				OPCODE_MENU: equ 62 
2400			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
2400				OPCODE_THEN: equ 64 
2400				OPCODE_ELSE: equ 65 
2400				OPCODE_DO: equ 66 
2400				OPCODE_LOOP: equ 67 
2400				OPCODE_I: equ 68 
2400				OPCODE_DLOOP: equ 69  
2400				OPCODE_REPEAT: equ 70  
2400				OPCODE_UNTIL: equ 71 
2400				OPCODE_ENDFLOW: equ 72 
2400				OPCODE_WAITK: equ 73 
2400				OPCODE_ACCEPT: equ 74 
2400				OPCODE_EDIT: equ 75 
2400			;free to reuse	OPCODE_ENDKEY: equ 76 
2400				OPCODE_LZERO: equ 77 
2400				OPCODE_TZERO: equ 78 
2400				OPCODE_LESS: equ 79 
2400				OPCODE_GT: equ 80 
2400				OPCODE_EQUAL: equ 81  
2400			;free to reuse	OPCODE_ENDLOGIC: equ 82 
2400				OPCODE_NEG: equ 83 
2400				OPCODE_DIV: equ 84 
2400				OPCODE_MUL: equ 85 
2400				OPCODE_MIN: equ 86 
2400				OPCODE_MAX: equ 87 
2400				OPCODE_RND16: equ 88 
2400				OPCODE_RND8: equ 89 
2400				OPCODE_RND: equ 90 
2400			;free to reuse	OPCODE_ENDMATHS: equ 91  
2400				OPCODE_BYNAME: equ 92 
2400				OPCODE_DIR: equ 93 
2400				OPCODE_SAVE: equ 94 
2400				OPCODE_LOAD: equ 95 
2400				OPCODE_BSAVE: equ 96 
2400				OPCODE_BLOAD: equ 97 
2400				OPCODE_SEO: equ 98  
2400				OPCODE_SEI: equ 99 
2400				OPCODE_SFREE: equ 100 
2400				OPCODE_SIZE: equ 101 
2400				OPCODE_CREATE: equ 102 
2400				OPCODE_APPEND: equ 103 
2400				OPCODE_SDEL: equ 104 
2400				OPCODE_OPEN: equ 105 
2400				OPCODE_READ: equ 106 
2400				OPCODE_EOF: equ 106 
2400				OPCODE_FORMAT: equ 107 
2400				OPCODE_LABEL: equ 108 
2400				OPCODE_LABELS: equ 109 
2400			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
2400				OPCODE_UPPER: equ 111 
2400				OPCODE_LOWER: equ 112 
2400				OPCODE_SUBSTR: equ 113 
2400				OPCODE_LEFT: equ 114 
2400				OPCODE_RIGHT: equ 115 
2400				OPCODE_STR2NUM: equ 116 
2400				OPCODE_NUM2STR: equ 117 
2400				OPCODE_CONCAT: equ 118 
2400				OPCODE_FIND: equ 119 
2400				OPCODE_LEN: equ 120 
2400				OPCODE_CHAR: equ 121 
2400			; free to reuse	OPCODE_STRLEN: equ 122 
2400			; free to reuse	OPCODE_ENDSTR: equ 123 
2400				OPCODE_V0S: equ 124 
2400				OPCODE_V0Q: equ 125 
2400				OPCODE_V1S: equ 126 
2400				OPCODE_V1Q: equ 127 
2400				OPCODE_V2S: equ 128 
2400				OPCODE_V2Q: equ 129 
2400				OPCODE_V3S: equ 130 
2400				OPCODE_V3Q: equ 131 
2400			;free to reuse	OPCODE_END: equ 132 
2400				OPCODE_ZDUP: equ 133 
2400			 
2400			; eof 
# End of file forth_opcodes.asm
2400			 
2400			include "forth_words_core.asm" 
2400			 
2400			; | ## Core Words 
2400			 
2400			;if MALLOC_4 
2400			 
2400			.HEAP: 
2400				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
2400 15				db WORD_SYS_CORE+OPCODE_HEAP             
2401 3f 24			dw .EXEC            
2403 05				db 4 + 1 
2404 .. 00			db "HEAP",0              
2409				endm 
# End of macro CWHEAD
2409			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
2409			; | | u1 - Current number of bytes in the heap 
2409			; | | u2 - Remaining bytes left on the heap 
2409			; | |  
2409			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
2409			 
2409			 
2409					if DEBUG_FORTH_WORDS_KEY 
2409						DMARK "HEP" 
2409 f5				push af  
240a 3a 1e 24			ld a, (.dmark)  
240d 32 b4 fe			ld (debug_mark),a  
2410 3a 1f 24			ld a, (.dmark+1)  
2413 32 b5 fe			ld (debug_mark+1),a  
2416 3a 20 24			ld a, (.dmark+2)  
2419 32 b6 fe			ld (debug_mark+2),a  
241c 18 03			jr .pastdmark  
241e ..			.dmark: db "HEP"  
2421 f1			.pastdmark: pop af  
2422			endm  
# End of macro DMARK
2422						CALLMONITOR 
2422 cd c6 18			call break_point_state  
2425				endm  
# End of macro CALLMONITOR
2425					endif 
2425 2a 0a 80				ld hl, (free_list )      
2428 11 0e 80				ld de, heap_start 
242b			 
242b ed 52				sbc hl, de  
242d			 
242d cd 3a 1f				call forth_push_numhl 
2430			 
2430			 
2430 ed 5b 0a 80			ld de, (free_list )      
2434 21 68 f3				ld hl, heap_end 
2437			 
2437 ed 52				sbc hl, de 
2439			 
2439 cd 3a 1f				call forth_push_numhl 
243c					 
243c			 
243c					 
243c			 
243c			 
243c			 
243c					NEXTW 
243c c3 a8 22			jp macro_next 
243f				endm 
# End of macro NEXTW
243f			;endif 
243f			 
243f			.EXEC: 
243f			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
243f			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
243f			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
243f			;; > > 
243f			;; > >   
243f			;	STACKFRAME OFF $5efe $5f9f 
243f			; 
243f			;		if DEBUG_FORTH_WORDS_KEY 
243f			;			DMARK "EXE" 
243f			;			CALLMONITOR 
243f			;		endif 
243f			; 
243f			;	FORTH_DSP_VALUEHL 
243f			; 
243f			;	FORTH_DSP_POP 
243f			; 
243f			;		if DEBUG_FORTH_WORDS 
243f			;			DMARK "EX1" 
243f			;			CALLMONITOR 
243f			;		endif 
243f			;;	ld e,(hl) 
243f			;;	inc hl 
243f			;;	ld d,(hl) 
243f			;;	ex de,hl 
243f			; 
243f			;;		if DEBUG_FORTH_WORDS 
243f			;;			DMARK "EX2" 
243f			;;			CALLMONITOR 
243f			;;		endif 
243f			;	push hl 
243f			; 
243f			;	;ld a, 0 
243f			;	;ld a, FORTH_END_BUFFER 
243f			;	call strlenz 
243f			;	inc hl   ; include zero term to copy 
243f			;	inc hl   ; include term 
243f			;	inc hl   ; include term 
243f			;	ld b,0 
243f			;	ld c,l 
243f			;	pop hl 
243f			;	ld de, execscratch 
243f			;		if DEBUG_FORTH_WORDS 
243f			;			DMARK "EX3" 
243f			;			CALLMONITOR 
243f			;		endif 
243f			;	ldir 
243f			; 
243f			; 
243f			;	ld hl, execscratch 
243f			; 
243f			;		if DEBUG_FORTH_WORDS 
243f			;			DMARK "EXe" 
243f			;			CALLMONITOR 
243f			;		endif 
243f			; 
243f			;	call forthparse 
243f			;	call forthexec 
243f			;;	call forthexec_cleanup 
243f			;;	call forthparse 
243f			;;	call forthexec 
243f			; 
243f			;	STACKFRAMECHK OFF $5efe $5f9f 
243f			; 
243f			;	; an immediate word so no need to process any more words 
243f			;	ret 
243f			;	NEXTW 
243f			 
243f			; dead code - old version  
243f			;	FORTH_RSP_NEXT 
243f			 
243f			;  
243f			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
243f			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
243f			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
243f			;	push hl 
243f			;	push de 
243f			;	push bc 
243f			; 
243f			; 
243f			;		if DEBUG_FORTH_WORDS_KEY 
243f			;			DMARK "EXR" 
243f			;			CALLMONITOR 
243f			;		endif 
243f			; 
243f			; 
243f			; 
243f			;	;v5 FORTH_DSP_VALUE 
243f			;	FORTH_DSP_VALUEHL 
243f			; 
243f			;	; TODO do string type checks 
243f			; 
243f			;;v5	inc hl   ; skip type 
243f			; 
243f			;	push hl  ; source code  
243f			;		if DEBUG_FORTH_WORDS 
243f			;			DMARK "EX1" 
243f			;			CALLMONITOR 
243f			;		endif 
243f			;	ld a, 0 
243f			;	call strlent 
243f			; 
243f			;	inc hl 
243f			;	inc hl 
243f			;	inc hl 
243f			;	inc hl 
243f			; 
243f			;	push hl    ; size 
243f			; 
243f			;		if DEBUG_FORTH_WORDS 
243f			;			DMARK "EX2" 
243f			;			CALLMONITOR 
243f			;		endif 
243f			;	call malloc 
243f			; 
243f			;	ex de, hl    ; de now contains malloc area 
243f			;	pop bc   	; get byte count 
243f			;	pop hl      ; get string to copy 
243f			; 
243f			;	push de     ; save malloc for free later 
243f			; 
243f			;		if DEBUG_FORTH_WORDS 
243f			;			DMARK "EX3" 
243f			;			CALLMONITOR 
243f			;		endif 
243f			;	ldir       ; duplicate string 
243f			; 
243f			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
243f			;	 
243f			;	; TODO fix the parse would be better than this...  
243f			;	ex de, hl 
243f			;	dec hl 
243f			;	ld a, 0 
243f			;	ld (hl), a 
243f			;	dec hl 
243f			;	ld a, ' ' 
243f			;	ld (hl), a 
243f			;	dec hl 
243f			;	ld (hl), a 
243f			; 
243f			;	dec hl 
243f			;	ld (hl), a 
243f			; 
243f			; 
243f			;	FORTH_DSP_POP  
243f			; 
243f			;	pop hl     
243f			;	push hl    ; save malloc area 
243f			; 
243f			;		if DEBUG_FORTH_WORDS 
243f			;			DMARK "EX4" 
243f			;			CALLMONITOR 
243f			;		endif 
243f			; 
243f			;	call forthparse 
243f			;	call forthexec 
243f			;	 
243f			;	pop hl 
243f			;	if DEBUG_FORTH_WORDS 
243f			;		DMARK "EX5" 
243f			;		CALLMONITOR 
243f			;	endif 
243f			; 
243f			;	if FORTH_ENABLE_FREE 
243f			;	call free 
243f			;	endif 
243f			; 
243f			;	if DEBUG_FORTH_WORDS 
243f			;		DMARK "EX6" 
243f			;		CALLMONITOR 
243f			;	endif 
243f			; 
243f			;	pop bc 
243f			;	pop de 
243f			;	pop hl 
243f			;;	FORTH_RSP_POP	  
243f			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
243f			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
243f			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
243f			; 
243f			;	if DEBUG_FORTH_WORDS 
243f			;		DMARK "EX7" 
243f			;		CALLMONITOR 
243f			;	endif 
243f			;	NEXTW 
243f			 
243f			;.STKEXEC: 
243f			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
243f			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
243f			; 
243f			; 
243f			;		if DEBUG_FORTH_WORDS_KEY 
243f			;			DMARK "STX" 
243f			;			CALLMONITOR 
243f			;		endif 
243f			; 
243f			;	FORTH_DSP_VALUEHL 
243f			; 
243f			;	ld (store_tmp1), hl    ; count 
243f			; 
243f			;	FORTH_DSP_POP 
243f			;.stkexec1: 
243f			;	ld hl, (store_tmp1)   ; count 
243f			;	ld a, 0 
243f			;	cp l 
243f			;	ret z 
243f			; 
243f			;	dec hl 
243f			;	ld (store_tmp1), hl    ; count 
243f			;	 
243f			;	FORTH_DSP_VALUEHL 
243f			;	push hl 
243f			;	 
243f			;		if DEBUG_FORTH_WORDS 
243f			;			DMARK "EXp" 
243f			;			CALLMONITOR 
243f			;		endif 
243f			;	FORTH_DSP_POP 
243f			; 
243f			;	call strlenz 
243f			;	inc hl   ; include zero term to copy 
243f			;	inc hl   ; include zero term to copy 
243f			;	inc hl   ; include zero term to copy 
243f			;	ld b,0 
243f			;	ld c,l 
243f			;	pop hl 
243f			;	ld de, execscratch 
243f			;		if DEBUG_FORTH_WORDS 
243f			;			DMARK "EX3" 
243f			;			CALLMONITOR 
243f			;		endif 
243f			;	ldir 
243f			; 
243f			; 
243f			;	ld hl, execscratch 
243f			; 
243f			;		if DEBUG_FORTH_WORDS 
243f			;			DMARK "EXP" 
243f			;			CALLMONITOR 
243f			;		endif 
243f			; 
243f			;	call forthparse 
243f			;	ld hl, execscratch 
243f			;		if DEBUG_FORTH_WORDS 
243f			;			DMARK "EXx" 
243f			;			CALLMONITOR 
243f			;		endif 
243f			;	call forthexec 
243f			; 
243f			;	jp .stkexec1 
243f			; 
243f			;	ret 
243f			 
243f			 
243f			.DUP: 
243f				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
243f 17				db WORD_SYS_CORE+OPCODE_DUP             
2440 b5 24			dw .ZDUP            
2442 04				db 3 + 1 
2443 .. 00			db "DUP",0              
2447				endm 
# End of macro CWHEAD
2447			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
2447			 
2447					if DEBUG_FORTH_WORDS_KEY 
2447						DMARK "DUP" 
2447 f5				push af  
2448 3a 5c 24			ld a, (.dmark)  
244b 32 b4 fe			ld (debug_mark),a  
244e 3a 5d 24			ld a, (.dmark+1)  
2451 32 b5 fe			ld (debug_mark+1),a  
2454 3a 5e 24			ld a, (.dmark+2)  
2457 32 b6 fe			ld (debug_mark+2),a  
245a 18 03			jr .pastdmark  
245c ..			.dmark: db "DUP"  
245f f1			.pastdmark: pop af  
2460			endm  
# End of macro DMARK
2460						CALLMONITOR 
2460 cd c6 18			call break_point_state  
2463				endm  
# End of macro CALLMONITOR
2463					endif 
2463			 
2463					FORTH_DSP 
2463 cd f7 20			call macro_forth_dsp 
2466				endm 
# End of macro FORTH_DSP
2466			 
2466 7e					ld a, (HL) 
2467 fe 01				cp DS_TYPE_STR 
2469 20 25				jr nz, .dupinum 
246b			 
246b					; push another string 
246b			 
246b					FORTH_DSP_VALUEHL     		 
246b cd 31 21			call macro_dsp_valuehl 
246e				endm 
# End of macro FORTH_DSP_VALUEHL
246e			 
246e				if DEBUG_FORTH_WORDS 
246e					DMARK "DUs" 
246e f5				push af  
246f 3a 83 24			ld a, (.dmark)  
2472 32 b4 fe			ld (debug_mark),a  
2475 3a 84 24			ld a, (.dmark+1)  
2478 32 b5 fe			ld (debug_mark+1),a  
247b 3a 85 24			ld a, (.dmark+2)  
247e 32 b6 fe			ld (debug_mark+2),a  
2481 18 03			jr .pastdmark  
2483 ..			.dmark: db "DUs"  
2486 f1			.pastdmark: pop af  
2487			endm  
# End of macro DMARK
2487					CALLMONITOR 
2487 cd c6 18			call break_point_state  
248a				endm  
# End of macro CALLMONITOR
248a				endif 
248a cd a8 1f				call forth_push_str 
248d			 
248d					NEXTW 
248d c3 a8 22			jp macro_next 
2490				endm 
# End of macro NEXTW
2490			 
2490			 
2490			.dupinum: 
2490					 
2490			 
2490			 
2490					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2490 cd 31 21			call macro_dsp_valuehl 
2493				endm 
# End of macro FORTH_DSP_VALUEHL
2493			 
2493				; TODO add floating point number detection 
2493			 
2493				if DEBUG_FORTH_WORDS 
2493					DMARK "DUi" 
2493 f5				push af  
2494 3a a8 24			ld a, (.dmark)  
2497 32 b4 fe			ld (debug_mark),a  
249a 3a a9 24			ld a, (.dmark+1)  
249d 32 b5 fe			ld (debug_mark+1),a  
24a0 3a aa 24			ld a, (.dmark+2)  
24a3 32 b6 fe			ld (debug_mark+2),a  
24a6 18 03			jr .pastdmark  
24a8 ..			.dmark: db "DUi"  
24ab f1			.pastdmark: pop af  
24ac			endm  
# End of macro DMARK
24ac					CALLMONITOR 
24ac cd c6 18			call break_point_state  
24af				endm  
# End of macro CALLMONITOR
24af				endif 
24af			 
24af cd 3a 1f				call forth_push_numhl 
24b2					NEXTW 
24b2 c3 a8 22			jp macro_next 
24b5				endm 
# End of macro NEXTW
24b5			.ZDUP: 
24b5				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
24b5 99				db WORD_SYS_CORE+OPCODE_ZDUP             
24b6 ed 24			dw .SWAP            
24b8 05				db 4 + 1 
24b9 .. 00			db "?DUP",0              
24be				endm 
# End of macro CWHEAD
24be			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
24be			 
24be					if DEBUG_FORTH_WORDS_KEY 
24be						DMARK "qDU" 
24be f5				push af  
24bf 3a d3 24			ld a, (.dmark)  
24c2 32 b4 fe			ld (debug_mark),a  
24c5 3a d4 24			ld a, (.dmark+1)  
24c8 32 b5 fe			ld (debug_mark+1),a  
24cb 3a d5 24			ld a, (.dmark+2)  
24ce 32 b6 fe			ld (debug_mark+2),a  
24d1 18 03			jr .pastdmark  
24d3 ..			.dmark: db "qDU"  
24d6 f1			.pastdmark: pop af  
24d7			endm  
# End of macro DMARK
24d7						CALLMONITOR 
24d7 cd c6 18			call break_point_state  
24da				endm  
# End of macro CALLMONITOR
24da					endif 
24da					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
24da cd 31 21			call macro_dsp_valuehl 
24dd				endm 
# End of macro FORTH_DSP_VALUEHL
24dd			 
24dd e5					push hl 
24de			 
24de					; is it a zero? 
24de			 
24de 3e 00				ld a, 0 
24e0 84					add h 
24e1 85					add l 
24e2			 
24e2 e1					pop hl 
24e3			 
24e3 fe 00				cp 0 
24e5 28 03				jr z, .dup2orig 
24e7			 
24e7			 
24e7 cd 3a 1f				call forth_push_numhl 
24ea			 
24ea			 
24ea				; TODO add floating point number detection 
24ea			 
24ea			.dup2orig: 
24ea			 
24ea					NEXTW 
24ea c3 a8 22			jp macro_next 
24ed				endm 
# End of macro NEXTW
24ed			.SWAP: 
24ed				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
24ed 18				db WORD_SYS_CORE+OPCODE_SWAP             
24ee 2c 25			dw .COLN            
24f0 05				db 4 + 1 
24f1 .. 00			db "SWAP",0              
24f6				endm 
# End of macro CWHEAD
24f6			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
24f6					if DEBUG_FORTH_WORDS_KEY 
24f6						DMARK "SWP" 
24f6 f5				push af  
24f7 3a 0b 25			ld a, (.dmark)  
24fa 32 b4 fe			ld (debug_mark),a  
24fd 3a 0c 25			ld a, (.dmark+1)  
2500 32 b5 fe			ld (debug_mark+1),a  
2503 3a 0d 25			ld a, (.dmark+2)  
2506 32 b6 fe			ld (debug_mark+2),a  
2509 18 03			jr .pastdmark  
250b ..			.dmark: db "SWP"  
250e f1			.pastdmark: pop af  
250f			endm  
# End of macro DMARK
250f						CALLMONITOR 
250f cd c6 18			call break_point_state  
2512				endm  
# End of macro CALLMONITOR
2512					endif 
2512			 
2512					FORTH_DSP_VALUEHL 
2512 cd 31 21			call macro_dsp_valuehl 
2515				endm 
# End of macro FORTH_DSP_VALUEHL
2515 e5					push hl     ; w2 
2516			 
2516					FORTH_DSP_POP 
2516 cd e9 21			call macro_forth_dsp_pop 
2519				endm 
# End of macro FORTH_DSP_POP
2519			 
2519					FORTH_DSP_VALUEHL 
2519 cd 31 21			call macro_dsp_valuehl 
251c				endm 
# End of macro FORTH_DSP_VALUEHL
251c			 
251c					FORTH_DSP_POP 
251c cd e9 21			call macro_forth_dsp_pop 
251f				endm 
# End of macro FORTH_DSP_POP
251f			 
251f d1					pop de     ; w2	, hl = w1 
2520			 
2520 eb					ex de, hl 
2521 d5					push de 
2522			 
2522 cd 3a 1f				call forth_push_numhl 
2525			 
2525 e1					pop hl 
2526			 
2526 cd 3a 1f				call forth_push_numhl 
2529					 
2529			 
2529					NEXTW 
2529 c3 a8 22			jp macro_next 
252c				endm 
# End of macro NEXTW
252c			.COLN: 
252c				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
252c 19				db WORD_SYS_CORE+OPCODE_COLN             
252d b8 26			dw .SCOLN            
252f 02				db 1 + 1 
2530 .. 00			db ":",0              
2532				endm 
# End of macro CWHEAD
2532			; | : ( -- )         Create new word | DONE 
2532			 
2532					if DEBUG_FORTH_WORDS_KEY 
2532						DMARK "CLN" 
2532 f5				push af  
2533 3a 47 25			ld a, (.dmark)  
2536 32 b4 fe			ld (debug_mark),a  
2539 3a 48 25			ld a, (.dmark+1)  
253c 32 b5 fe			ld (debug_mark+1),a  
253f 3a 49 25			ld a, (.dmark+2)  
2542 32 b6 fe			ld (debug_mark+2),a  
2545 18 03			jr .pastdmark  
2547 ..			.dmark: db "CLN"  
254a f1			.pastdmark: pop af  
254b			endm  
# End of macro DMARK
254b						CALLMONITOR 
254b cd c6 18			call break_point_state  
254e				endm  
# End of macro CALLMONITOR
254e					endif 
254e				STACKFRAME OFF $8efe $989f 
254e				if DEBUG_STACK_IMB 
254e					if OFF 
254e						exx 
254e						ld de, $8efe 
254e						ld a, d 
254e						ld hl, curframe 
254e						call hexout 
254e						ld a, e 
254e						ld hl, curframe+2 
254e						call hexout 
254e						ld hl, $8efe 
254e						push hl 
254e						ld hl, $989f 
254e						push hl 
254e						exx 
254e					endif 
254e				endif 
254e			endm 
# End of macro STACKFRAME
254e				; get parser buffer length  of new word 
254e			 
254e				 
254e			 
254e					; move tok past this to start of name defintition 
254e					; TODO get word to define 
254e					; TODO Move past word token 
254e					; TODO get length of string up to the ';' 
254e			 
254e 2a 83 f6			ld hl, (os_tok_ptr) 
2551 23				inc hl 
2552 23				inc hl 
2553			 
2553 3e 3b			ld a, ';' 
2555 cd b2 13			call strlent 
2558			 
2558 7d				ld a,l 
2559 32 7e f3			ld (os_new_parse_len), a 
255c			 
255c			 
255c			if DEBUG_FORTH_UWORD 
255c ed 5b 83 f6		ld de, (os_tok_ptr) 
2560						DMARK ":01" 
2560 f5				push af  
2561 3a 75 25			ld a, (.dmark)  
2564 32 b4 fe			ld (debug_mark),a  
2567 3a 76 25			ld a, (.dmark+1)  
256a 32 b5 fe			ld (debug_mark+1),a  
256d 3a 77 25			ld a, (.dmark+2)  
2570 32 b6 fe			ld (debug_mark+2),a  
2573 18 03			jr .pastdmark  
2575 ..			.dmark: db ":01"  
2578 f1			.pastdmark: pop af  
2579			endm  
# End of macro DMARK
2579				CALLMONITOR 
2579 cd c6 18			call break_point_state  
257c				endm  
# End of macro CALLMONITOR
257c			endif 
257c			 
257c			; 
257c			;  new word memory layout: 
257c			;  
257c			;    : adg 6666 ;  
257c			; 
257c			;    db   1     ; user defined word  
257c 23				inc hl    
257d			;    dw   sysdict 
257d 23				inc hl 
257e 23				inc hl 
257f			;    db <word len>+1 (for null) 
257f 23				inc hl 
2580			;    db .... <word> 
2580			; 
2580			 
2580 23				inc hl    ; some extras for the word preamble before the above 
2581 23				inc hl 
2582 23				inc hl 
2583 23				inc hl 
2584 23				inc hl 
2585 23				inc hl 
2586 23				inc hl  
2587 23				inc hl 
2588 23				inc hl 
2589 23				inc hl 
258a 23				inc hl 
258b 23				inc hl 
258c 23				inc hl 
258d 23				inc hl     ; TODO how many do we really need?     maybe only 6 
258e			;       exec word buffer 
258e			;	<ptr word>   
258e 23				inc hl 
258f 23				inc hl 
2590			;       <word list><null term> 7F final term 
2590			 
2590			 
2590			if DEBUG_FORTH_UWORD 
2590						DMARK ":02" 
2590 f5				push af  
2591 3a a5 25			ld a, (.dmark)  
2594 32 b4 fe			ld (debug_mark),a  
2597 3a a6 25			ld a, (.dmark+1)  
259a 32 b5 fe			ld (debug_mark+1),a  
259d 3a a7 25			ld a, (.dmark+2)  
25a0 32 b6 fe			ld (debug_mark+2),a  
25a3 18 03			jr .pastdmark  
25a5 ..			.dmark: db ":02"  
25a8 f1			.pastdmark: pop af  
25a9			endm  
# End of macro DMARK
25a9				CALLMONITOR 
25a9 cd c6 18			call break_point_state  
25ac				endm  
# End of macro CALLMONITOR
25ac			endif 
25ac			 
25ac				 
25ac					; malloc the size 
25ac			 
25ac cd 10 14				call malloc 
25af 22 80 f3				ld (os_new_malloc), hl     ; save malloc start 
25b2			 
25b2			;    db   1     ; user defined word  
25b2 3e 01				ld a, WORD_SYS_UWORD  
25b4 77					ld (hl), a 
25b5				 
25b5 23				inc hl    
25b6			;    dw   sysdict 
25b6 11 00 24			ld de, sysdict       ; continue on with the scan to the system dict 
25b9 73				ld (hl), e 
25ba 23				inc hl 
25bb 72				ld (hl), d 
25bc 23				inc hl 
25bd			 
25bd			 
25bd			;    Setup dict word 
25bd			 
25bd 23				inc hl 
25be 22 7a f3			ld (os_new_work_ptr), hl     ; save start of dict word  
25c1			 
25c1				; 1. get length of dict word 
25c1			 
25c1			 
25c1 2a 83 f6			ld hl, (os_tok_ptr) 
25c4 23				inc hl 
25c5 23				inc hl    ; position to start of dict word 
25c6 3e 00			ld a, 0 
25c8 cd b2 13			call strlent 
25cb			 
25cb			 
25cb 23				inc hl    ; to include null??? 
25cc			 
25cc				; write length of dict word 
25cc			 
25cc ed 5b 7a f3		ld de, (os_new_work_ptr)   ; get dest for copy of word 
25d0 1b				dec de 
25d1 eb				ex de, hl 
25d2 73				ld (hl), e 
25d3 eb				ex de, hl 
25d4			 
25d4				 
25d4			 
25d4				; copy  
25d4 4d				ld c, l 
25d5 06 00			ld b, 0 
25d7 ed 5b 7a f3		ld de, (os_new_work_ptr)   ; get dest for copy of word 
25db 2a 83 f6			ld hl, (os_tok_ptr) 
25de 23				inc hl 
25df 23				inc hl    ; position to start of dict word 
25e0				 
25e0			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
25e0				 
25e0				; TODO need to convert word to upper case 
25e0			 
25e0			ucasetok:	 
25e0 7e				ld a,(hl) 
25e1 cd 9e 13			call toUpper 
25e4 77				ld (hl),a 
25e5 ed a0			ldi 
25e7 f2 e0 25		 	jp p, ucasetok 
25ea			 
25ea			 
25ea			 
25ea				; de now points to start of where the word body code should be placed 
25ea ed 53 7a f3		ld (os_new_work_ptr), de 
25ee				; hl now points to the words to throw at forthexec which needs to be copied 
25ee 22 78 f3			ld (os_new_src_ptr), hl 
25f1			 
25f1				; TODO add 'call to forthexec' 
25f1			 
25f1			if DEBUG_FORTH_UWORD 
25f1 c5				push bc 
25f2 ed 4b 80 f3		ld bc, (os_new_malloc) 
25f6						DMARK ":0x" 
25f6 f5				push af  
25f7 3a 0b 26			ld a, (.dmark)  
25fa 32 b4 fe			ld (debug_mark),a  
25fd 3a 0c 26			ld a, (.dmark+1)  
2600 32 b5 fe			ld (debug_mark+1),a  
2603 3a 0d 26			ld a, (.dmark+2)  
2606 32 b6 fe			ld (debug_mark+2),a  
2609 18 03			jr .pastdmark  
260b ..			.dmark: db ":0x"  
260e f1			.pastdmark: pop af  
260f			endm  
# End of macro DMARK
260f				CALLMONITOR 
260f cd c6 18			call break_point_state  
2612				endm  
# End of macro CALLMONITOR
2612 c1				pop bc 
2613			endif 
2613			 
2613			 
2613				; create word preamble which should be: 
2613			 
2613			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
2613			 
2613				;    ld hl, <word code> 
2613				;    jp user_exec 
2613			        ;    <word code bytes> 
2613			 
2613			 
2613			;	inc de     ; TODO ??? or are we already past the word's null 
2613 eb				ex de, hl 
2614			 
2614 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
2616			 
2616 23				inc hl 
2617 22 74 f3			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
261a 23				inc hl 
261b			 
261b 23				inc hl 
261c 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
261e			 
261e 01 74 55			ld bc, user_exec 
2621 23				inc hl 
2622 71				ld (hl), c     ; poke address of user_exec 
2623 23				inc hl 
2624 70				ld (hl), b     
2625			 ; 
2625			;	inc hl 
2625			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2625			; 
2625			; 
2625			;	ld bc, macro_forth_rsp_next 
2625			;	inc hl 
2625			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
2625			;	inc hl 
2625			;	ld (hl), b     
2625			 ; 
2625			;	inc hl 
2625			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2625			; 
2625			; 
2625			;	inc hl 
2625			;	ld bc, forthexec 
2625			;	ld (hl), c     ; poke address of forthexec 
2625			;	inc hl 
2625			;	ld (hl), b      
2625			; 
2625			;	inc hl 
2625			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
2625			; 
2625			;	ld bc, user_dict_next 
2625			;	inc hl 
2625			;	ld (hl), c     ; poke address of forthexec 
2625			;	inc hl 
2625			;	ld (hl), b      
2625			 
2625				; hl is now where we need to copy the word byte data to save this 
2625			 
2625 23				inc hl 
2626 22 76 f3			ld (os_new_exec), hl 
2629				 
2629				; copy definition 
2629			 
2629 eb				ex de, hl 
262a			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
262a			;	inc de    ; skip the PC for this parse 
262a 3a 7e f3			ld a, (os_new_parse_len) 
262d 4f				ld c, a 
262e 06 00			ld b, 0 
2630 ed b0			ldir		 ; copy defintion 
2632			 
2632			 
2632				; poke the address of where the new word bytes live for forthexec 
2632			 
2632 2a 74 f3			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
2635			 
2635 ed 5b 76 f3		ld de, (os_new_exec)      
2639				 
2639 73				ld (hl), e 
263a 23				inc hl 
263b 72				ld (hl), d 
263c			 
263c					; TODO copy last user dict word next link to this word 
263c					; TODO update last user dict word to point to this word 
263c			; 
263c			; hl f923 de 812a ; bc 811a 
263c			 
263c			if DEBUG_FORTH_UWORD 
263c c5				push bc 
263d ed 4b 80 f3		ld bc, (os_new_malloc) 
2641						DMARK ":0A" 
2641 f5				push af  
2642 3a 56 26			ld a, (.dmark)  
2645 32 b4 fe			ld (debug_mark),a  
2648 3a 57 26			ld a, (.dmark+1)  
264b 32 b5 fe			ld (debug_mark+1),a  
264e 3a 58 26			ld a, (.dmark+2)  
2651 32 b6 fe			ld (debug_mark+2),a  
2654 18 03			jr .pastdmark  
2656 ..			.dmark: db ":0A"  
2659 f1			.pastdmark: pop af  
265a			endm  
# End of macro DMARK
265a				CALLMONITOR 
265a cd c6 18			call break_point_state  
265d				endm  
# End of macro CALLMONITOR
265d c1				pop bc 
265e			endif 
265e			if DEBUG_FORTH_UWORD 
265e c5				push bc 
265f ed 4b 80 f3		ld bc, (os_new_malloc) 
2663 03				inc bc 
2664 03				inc bc 
2665 03				inc bc 
2666 03				inc bc 
2667 03				inc bc 
2668 03				inc bc 
2669 03				inc bc 
266a 03				inc bc 
266b			 
266b						DMARK ":0B" 
266b f5				push af  
266c 3a 80 26			ld a, (.dmark)  
266f 32 b4 fe			ld (debug_mark),a  
2672 3a 81 26			ld a, (.dmark+1)  
2675 32 b5 fe			ld (debug_mark+1),a  
2678 3a 82 26			ld a, (.dmark+2)  
267b 32 b6 fe			ld (debug_mark+2),a  
267e 18 03			jr .pastdmark  
2680 ..			.dmark: db ":0B"  
2683 f1			.pastdmark: pop af  
2684			endm  
# End of macro DMARK
2684				CALLMONITOR 
2684 cd c6 18			call break_point_state  
2687				endm  
# End of macro CALLMONITOR
2687 c1				pop bc 
2688			endif 
2688			 
2688			; update word dict linked list for new word 
2688			 
2688			 
2688 2a 7f f6		ld hl, (os_last_new_uword)		; get the start of the last added uword 
268b 23			inc hl     ; move to next work linked list ptr 
268c			 
268c ed 5b 80 f3	ld de, (os_new_malloc)		 ; new next word 
2690 73			ld (hl), e 
2691 23			inc hl 
2692 72			ld (hl), d 
2693			 
2693			if DEBUG_FORTH_UWORD 
2693 ed 4b 7f f6		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
2697			endif 
2697			 
2697 ed 53 7f f6	ld (os_last_new_uword), de      ; update last new uword ptr 
269b			 
269b			 
269b			if DEBUG_FORTH_UWORD 
269b						DMARK ":0+" 
269b f5				push af  
269c 3a b0 26			ld a, (.dmark)  
269f 32 b4 fe			ld (debug_mark),a  
26a2 3a b1 26			ld a, (.dmark+1)  
26a5 32 b5 fe			ld (debug_mark+1),a  
26a8 3a b2 26			ld a, (.dmark+2)  
26ab 32 b6 fe			ld (debug_mark+2),a  
26ae 18 03			jr .pastdmark  
26b0 ..			.dmark: db ":0+"  
26b3 f1			.pastdmark: pop af  
26b4			endm  
# End of macro DMARK
26b4				CALLMONITOR 
26b4 cd c6 18			call break_point_state  
26b7				endm  
# End of macro CALLMONITOR
26b7			endif 
26b7			 
26b7				STACKFRAMECHK OFF $8efe $989f 
26b7				if DEBUG_STACK_IMB 
26b7					if OFF 
26b7						exx 
26b7						ld hl, $989f 
26b7						pop de   ; $989f 
26b7						call cmp16 
26b7						jr nz, .spnosame 
26b7						ld hl, $8efe 
26b7						pop de   ; $8efe 
26b7						call cmp16 
26b7						jr z, .spfrsame 
26b7						.spnosame: call showsperror 
26b7						.spfrsame: nop 
26b7						exx 
26b7					endif 
26b7				endif 
26b7			endm 
# End of macro STACKFRAMECHK
26b7			 
26b7 c9			ret    ; dont process any remaining parser tokens as they form new word 
26b8			 
26b8			 
26b8			 
26b8			 
26b8			;		NEXT 
26b8			.SCOLN: 
26b8			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
26b8 06				db OPCODE_SCOLN 
26b9 04 27			dw .DROP 
26bb 02				db 2 
26bc .. 00			db ";",0           
26be			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
26be					if DEBUG_FORTH_WORDS_KEY 
26be						DMARK "SCN" 
26be f5				push af  
26bf 3a d3 26			ld a, (.dmark)  
26c2 32 b4 fe			ld (debug_mark),a  
26c5 3a d4 26			ld a, (.dmark+1)  
26c8 32 b5 fe			ld (debug_mark+1),a  
26cb 3a d5 26			ld a, (.dmark+2)  
26ce 32 b6 fe			ld (debug_mark+2),a  
26d1 18 03			jr .pastdmark  
26d3 ..			.dmark: db "SCN"  
26d6 f1			.pastdmark: pop af  
26d7			endm  
# End of macro DMARK
26d7						CALLMONITOR 
26d7 cd c6 18			call break_point_state  
26da				endm  
# End of macro CALLMONITOR
26da					endif 
26da					FORTH_RSP_TOS 
26da cd f8 1e			call macro_forth_rsp_tos 
26dd				endm 
# End of macro FORTH_RSP_TOS
26dd e5					push hl 
26de					FORTH_RSP_POP 
26de cd 02 1f			call macro_forth_rsp_pop 
26e1				endm 
# End of macro FORTH_RSP_POP
26e1 e1					pop hl 
26e2			;		ex de,hl 
26e2 22 83 f6				ld (os_tok_ptr),hl 
26e5			 
26e5			if DEBUG_FORTH_UWORD 
26e5						DMARK "SCL" 
26e5 f5				push af  
26e6 3a fa 26			ld a, (.dmark)  
26e9 32 b4 fe			ld (debug_mark),a  
26ec 3a fb 26			ld a, (.dmark+1)  
26ef 32 b5 fe			ld (debug_mark+1),a  
26f2 3a fc 26			ld a, (.dmark+2)  
26f5 32 b6 fe			ld (debug_mark+2),a  
26f8 18 03			jr .pastdmark  
26fa ..			.dmark: db "SCL"  
26fd f1			.pastdmark: pop af  
26fe			endm  
# End of macro DMARK
26fe				CALLMONITOR 
26fe cd c6 18			call break_point_state  
2701				endm  
# End of macro CALLMONITOR
2701			endif 
2701					NEXTW 
2701 c3 a8 22			jp macro_next 
2704				endm 
# End of macro NEXTW
2704			 
2704			.DROP: 
2704				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
2704 1b				db WORD_SYS_CORE+OPCODE_DROP             
2705 2f 27			dw .DUP2            
2707 05				db 4 + 1 
2708 .. 00			db "DROP",0              
270d				endm 
# End of macro CWHEAD
270d			; | DROP ( w -- )   drop the TOS item   | DONE 
270d					if DEBUG_FORTH_WORDS_KEY 
270d						DMARK "DRP" 
270d f5				push af  
270e 3a 22 27			ld a, (.dmark)  
2711 32 b4 fe			ld (debug_mark),a  
2714 3a 23 27			ld a, (.dmark+1)  
2717 32 b5 fe			ld (debug_mark+1),a  
271a 3a 24 27			ld a, (.dmark+2)  
271d 32 b6 fe			ld (debug_mark+2),a  
2720 18 03			jr .pastdmark  
2722 ..			.dmark: db "DRP"  
2725 f1			.pastdmark: pop af  
2726			endm  
# End of macro DMARK
2726						CALLMONITOR 
2726 cd c6 18			call break_point_state  
2729				endm  
# End of macro CALLMONITOR
2729					endif 
2729					FORTH_DSP_POP 
2729 cd e9 21			call macro_forth_dsp_pop 
272c				endm 
# End of macro FORTH_DSP_POP
272c					NEXTW 
272c c3 a8 22			jp macro_next 
272f				endm 
# End of macro NEXTW
272f			.DUP2: 
272f				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
272f 1c				db WORD_SYS_CORE+OPCODE_DUP2             
2730 74 27			dw .DROP2            
2732 05				db 4 + 1 
2733 .. 00			db "2DUP",0              
2738				endm 
# End of macro CWHEAD
2738			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
2738					if DEBUG_FORTH_WORDS_KEY 
2738						DMARK "2DU" 
2738 f5				push af  
2739 3a 4d 27			ld a, (.dmark)  
273c 32 b4 fe			ld (debug_mark),a  
273f 3a 4e 27			ld a, (.dmark+1)  
2742 32 b5 fe			ld (debug_mark+1),a  
2745 3a 4f 27			ld a, (.dmark+2)  
2748 32 b6 fe			ld (debug_mark+2),a  
274b 18 03			jr .pastdmark  
274d ..			.dmark: db "2DU"  
2750 f1			.pastdmark: pop af  
2751			endm  
# End of macro DMARK
2751						CALLMONITOR 
2751 cd c6 18			call break_point_state  
2754				endm  
# End of macro CALLMONITOR
2754					endif 
2754					FORTH_DSP_VALUEHL 
2754 cd 31 21			call macro_dsp_valuehl 
2757				endm 
# End of macro FORTH_DSP_VALUEHL
2757 e5					push hl      ; 2 
2758			 
2758					FORTH_DSP_POP 
2758 cd e9 21			call macro_forth_dsp_pop 
275b				endm 
# End of macro FORTH_DSP_POP
275b					 
275b					FORTH_DSP_VALUEHL 
275b cd 31 21			call macro_dsp_valuehl 
275e				endm 
# End of macro FORTH_DSP_VALUEHL
275e			;		push hl      ; 1 
275e			 
275e					FORTH_DSP_POP 
275e cd e9 21			call macro_forth_dsp_pop 
2761				endm 
# End of macro FORTH_DSP_POP
2761			 
2761			;		pop hl       ; 1 
2761 d1					pop de       ; 2 
2762			 
2762 cd 3a 1f				call forth_push_numhl 
2765 eb					ex de, hl 
2766 cd 3a 1f				call forth_push_numhl 
2769			 
2769					 
2769 eb					ex de, hl 
276a			 
276a cd 3a 1f				call forth_push_numhl 
276d eb					ex de, hl 
276e cd 3a 1f				call forth_push_numhl 
2771			 
2771			 
2771					NEXTW 
2771 c3 a8 22			jp macro_next 
2774				endm 
# End of macro NEXTW
2774			.DROP2: 
2774				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
2774 1d				db WORD_SYS_CORE+OPCODE_DROP2             
2775 a3 27			dw .SWAP2            
2777 06				db 5 + 1 
2778 .. 00			db "2DROP",0              
277e				endm 
# End of macro CWHEAD
277e			; | 2DROP ( w w -- )    Double drop | DONE 
277e					if DEBUG_FORTH_WORDS_KEY 
277e						DMARK "2DR" 
277e f5				push af  
277f 3a 93 27			ld a, (.dmark)  
2782 32 b4 fe			ld (debug_mark),a  
2785 3a 94 27			ld a, (.dmark+1)  
2788 32 b5 fe			ld (debug_mark+1),a  
278b 3a 95 27			ld a, (.dmark+2)  
278e 32 b6 fe			ld (debug_mark+2),a  
2791 18 03			jr .pastdmark  
2793 ..			.dmark: db "2DR"  
2796 f1			.pastdmark: pop af  
2797			endm  
# End of macro DMARK
2797						CALLMONITOR 
2797 cd c6 18			call break_point_state  
279a				endm  
# End of macro CALLMONITOR
279a					endif 
279a					FORTH_DSP_POP 
279a cd e9 21			call macro_forth_dsp_pop 
279d				endm 
# End of macro FORTH_DSP_POP
279d					FORTH_DSP_POP 
279d cd e9 21			call macro_forth_dsp_pop 
27a0				endm 
# End of macro FORTH_DSP_POP
27a0					NEXTW 
27a0 c3 a8 22			jp macro_next 
27a3				endm 
# End of macro NEXTW
27a3			.SWAP2: 
27a3				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
27a3 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
27a4 cc 27			dw .AT            
27a6 06				db 5 + 1 
27a7 .. 00			db "2SWAP",0              
27ad				endm 
# End of macro CWHEAD
27ad			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
27ad					if DEBUG_FORTH_WORDS_KEY 
27ad						DMARK "2SW" 
27ad f5				push af  
27ae 3a c2 27			ld a, (.dmark)  
27b1 32 b4 fe			ld (debug_mark),a  
27b4 3a c3 27			ld a, (.dmark+1)  
27b7 32 b5 fe			ld (debug_mark+1),a  
27ba 3a c4 27			ld a, (.dmark+2)  
27bd 32 b6 fe			ld (debug_mark+2),a  
27c0 18 03			jr .pastdmark  
27c2 ..			.dmark: db "2SW"  
27c5 f1			.pastdmark: pop af  
27c6			endm  
# End of macro DMARK
27c6						CALLMONITOR 
27c6 cd c6 18			call break_point_state  
27c9				endm  
# End of macro CALLMONITOR
27c9					endif 
27c9					NEXTW 
27c9 c3 a8 22			jp macro_next 
27cc				endm 
# End of macro NEXTW
27cc			.AT: 
27cc				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
27cc 1f				db WORD_SYS_CORE+OPCODE_AT             
27cd fe 27			dw .CAT            
27cf 02				db 1 + 1 
27d0 .. 00			db "@",0              
27d2				endm 
# End of macro CWHEAD
27d2			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
27d2			 
27d2					if DEBUG_FORTH_WORDS_KEY 
27d2						DMARK "AT." 
27d2 f5				push af  
27d3 3a e7 27			ld a, (.dmark)  
27d6 32 b4 fe			ld (debug_mark),a  
27d9 3a e8 27			ld a, (.dmark+1)  
27dc 32 b5 fe			ld (debug_mark+1),a  
27df 3a e9 27			ld a, (.dmark+2)  
27e2 32 b6 fe			ld (debug_mark+2),a  
27e5 18 03			jr .pastdmark  
27e7 ..			.dmark: db "AT."  
27ea f1			.pastdmark: pop af  
27eb			endm  
# End of macro DMARK
27eb						CALLMONITOR 
27eb cd c6 18			call break_point_state  
27ee				endm  
# End of macro CALLMONITOR
27ee					endif 
27ee			.getbyteat:	 
27ee					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
27ee cd 31 21			call macro_dsp_valuehl 
27f1				endm 
# End of macro FORTH_DSP_VALUEHL
27f1					 
27f1			;		push hl 
27f1				 
27f1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
27f1 cd e9 21			call macro_forth_dsp_pop 
27f4				endm 
# End of macro FORTH_DSP_POP
27f4			 
27f4			;		pop hl 
27f4			 
27f4 7e					ld a, (hl) 
27f5			 
27f5 6f					ld l, a 
27f6 26 00				ld h, 0 
27f8 cd 3a 1f				call forth_push_numhl 
27fb			 
27fb					NEXTW 
27fb c3 a8 22			jp macro_next 
27fe				endm 
# End of macro NEXTW
27fe			.CAT: 
27fe				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
27fe 20				db WORD_SYS_CORE+OPCODE_CAT             
27ff 27 28			dw .BANG            
2801 03				db 2 + 1 
2802 .. 00			db "C@",0              
2805				endm 
# End of macro CWHEAD
2805			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
2805					if DEBUG_FORTH_WORDS_KEY 
2805						DMARK "CAA" 
2805 f5				push af  
2806 3a 1a 28			ld a, (.dmark)  
2809 32 b4 fe			ld (debug_mark),a  
280c 3a 1b 28			ld a, (.dmark+1)  
280f 32 b5 fe			ld (debug_mark+1),a  
2812 3a 1c 28			ld a, (.dmark+2)  
2815 32 b6 fe			ld (debug_mark+2),a  
2818 18 03			jr .pastdmark  
281a ..			.dmark: db "CAA"  
281d f1			.pastdmark: pop af  
281e			endm  
# End of macro DMARK
281e						CALLMONITOR 
281e cd c6 18			call break_point_state  
2821				endm  
# End of macro CALLMONITOR
2821					endif 
2821 c3 ee 27				jp .getbyteat 
2824					NEXTW 
2824 c3 a8 22			jp macro_next 
2827				endm 
# End of macro NEXTW
2827			.BANG: 
2827				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
2827 21				db WORD_SYS_CORE+OPCODE_BANG             
2828 5d 28			dw .CBANG            
282a 02				db 1 + 1 
282b .. 00			db "!",0              
282d				endm 
# End of macro CWHEAD
282d			; | ! ( x w -- ) Store x at address w      | DONE 
282d					if DEBUG_FORTH_WORDS_KEY 
282d						DMARK "BNG" 
282d f5				push af  
282e 3a 42 28			ld a, (.dmark)  
2831 32 b4 fe			ld (debug_mark),a  
2834 3a 43 28			ld a, (.dmark+1)  
2837 32 b5 fe			ld (debug_mark+1),a  
283a 3a 44 28			ld a, (.dmark+2)  
283d 32 b6 fe			ld (debug_mark+2),a  
2840 18 03			jr .pastdmark  
2842 ..			.dmark: db "BNG"  
2845 f1			.pastdmark: pop af  
2846			endm  
# End of macro DMARK
2846						CALLMONITOR 
2846 cd c6 18			call break_point_state  
2849				endm  
# End of macro CALLMONITOR
2849					endif 
2849			 
2849			.storebyteat:		 
2849					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2849 cd 31 21			call macro_dsp_valuehl 
284c				endm 
# End of macro FORTH_DSP_VALUEHL
284c					 
284c e5					push hl 
284d				 
284d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
284d cd e9 21			call macro_forth_dsp_pop 
2850				endm 
# End of macro FORTH_DSP_POP
2850			 
2850					; get byte to poke 
2850			 
2850					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2850 cd 31 21			call macro_dsp_valuehl 
2853				endm 
# End of macro FORTH_DSP_VALUEHL
2853 e5					push hl 
2854			 
2854			 
2854					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2854 cd e9 21			call macro_forth_dsp_pop 
2857				endm 
# End of macro FORTH_DSP_POP
2857			 
2857			 
2857 d1					pop de 
2858 e1					pop hl 
2859			 
2859 73					ld (hl),e 
285a			 
285a			 
285a					NEXTW 
285a c3 a8 22			jp macro_next 
285d				endm 
# End of macro NEXTW
285d			.CBANG: 
285d				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
285d 22				db WORD_SYS_CORE+OPCODE_CBANG             
285e 86 28			dw .SCALL            
2860 03				db 2 + 1 
2861 .. 00			db "C!",0              
2864				endm 
# End of macro CWHEAD
2864			; | C!  ( x w -- ) Store x at address w  | DONE 
2864					if DEBUG_FORTH_WORDS_KEY 
2864						DMARK "CBA" 
2864 f5				push af  
2865 3a 79 28			ld a, (.dmark)  
2868 32 b4 fe			ld (debug_mark),a  
286b 3a 7a 28			ld a, (.dmark+1)  
286e 32 b5 fe			ld (debug_mark+1),a  
2871 3a 7b 28			ld a, (.dmark+2)  
2874 32 b6 fe			ld (debug_mark+2),a  
2877 18 03			jr .pastdmark  
2879 ..			.dmark: db "CBA"  
287c f1			.pastdmark: pop af  
287d			endm  
# End of macro DMARK
287d						CALLMONITOR 
287d cd c6 18			call break_point_state  
2880				endm  
# End of macro CALLMONITOR
2880					endif 
2880 c3 49 28				jp .storebyteat 
2883					NEXTW 
2883 c3 a8 22			jp macro_next 
2886				endm 
# End of macro NEXTW
2886			.SCALL: 
2886				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
2886 23				db WORD_SYS_CORE+OPCODE_SCALL             
2887 ba 28			dw .DEPTH            
2889 05				db 4 + 1 
288a .. 00			db "CALL",0              
288f				endm 
# End of macro CWHEAD
288f			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
288f					if DEBUG_FORTH_WORDS_KEY 
288f						DMARK "CLL" 
288f f5				push af  
2890 3a a4 28			ld a, (.dmark)  
2893 32 b4 fe			ld (debug_mark),a  
2896 3a a5 28			ld a, (.dmark+1)  
2899 32 b5 fe			ld (debug_mark+1),a  
289c 3a a6 28			ld a, (.dmark+2)  
289f 32 b6 fe			ld (debug_mark+2),a  
28a2 18 03			jr .pastdmark  
28a4 ..			.dmark: db "CLL"  
28a7 f1			.pastdmark: pop af  
28a8			endm  
# End of macro DMARK
28a8						CALLMONITOR 
28a8 cd c6 18			call break_point_state  
28ab				endm  
# End of macro CALLMONITOR
28ab					endif 
28ab			 
28ab					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
28ab cd 31 21			call macro_dsp_valuehl 
28ae				endm 
# End of macro FORTH_DSP_VALUEHL
28ae			 
28ae			;		push hl 
28ae			 
28ae					; destroy value TOS 
28ae			 
28ae					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
28ae cd e9 21			call macro_forth_dsp_pop 
28b1				endm 
# End of macro FORTH_DSP_POP
28b1			 
28b1						 
28b1			;		pop hl 
28b1			 
28b1					; how to do a call with hl???? save SP? 
28b1 cd 4c 22				call forth_call_hl 
28b4			 
28b4			 
28b4					; TODO push value back onto stack for another op etc 
28b4			 
28b4 cd 3a 1f				call forth_push_numhl 
28b7					NEXTW 
28b7 c3 a8 22			jp macro_next 
28ba				endm 
# End of macro NEXTW
28ba			.DEPTH: 
28ba				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
28ba 24				db WORD_SYS_CORE+OPCODE_DEPTH             
28bb f7 28			dw .OVER            
28bd 06				db 5 + 1 
28be .. 00			db "DEPTH",0              
28c4				endm 
# End of macro CWHEAD
28c4			; | DEPTH ( -- u ) Push count of stack | DONE 
28c4					; take current TOS and remove from base value div by two to get count 
28c4					if DEBUG_FORTH_WORDS_KEY 
28c4						DMARK "DEP" 
28c4 f5				push af  
28c5 3a d9 28			ld a, (.dmark)  
28c8 32 b4 fe			ld (debug_mark),a  
28cb 3a da 28			ld a, (.dmark+1)  
28ce 32 b5 fe			ld (debug_mark+1),a  
28d1 3a db 28			ld a, (.dmark+2)  
28d4 32 b6 fe			ld (debug_mark+2),a  
28d7 18 03			jr .pastdmark  
28d9 ..			.dmark: db "DEP"  
28dc f1			.pastdmark: pop af  
28dd			endm  
# End of macro DMARK
28dd						CALLMONITOR 
28dd cd c6 18			call break_point_state  
28e0				endm  
# End of macro CALLMONITOR
28e0					endif 
28e0			 
28e0			 
28e0 2a af fb			ld hl, (cli_data_sp) 
28e3 11 e9 f8			ld de, cli_data_stack 
28e6 ed 52			sbc hl,de 
28e8				 
28e8				; div by size of stack item 
28e8			 
28e8 5d				ld e,l 
28e9 0e 03			ld c, 3 
28eb cd d9 0e			call Div8 
28ee			 
28ee 6f				ld l,a 
28ef 26 00			ld h,0 
28f1			 
28f1				;srl h 
28f1				;rr l 
28f1			 
28f1 cd 3a 1f				call forth_push_numhl 
28f4					NEXTW 
28f4 c3 a8 22			jp macro_next 
28f7				endm 
# End of macro NEXTW
28f7			.OVER: 
28f7				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
28f7 42				db WORD_SYS_CORE+46             
28f8 3e 29			dw .PAUSE            
28fa 05				db 4 + 1 
28fb .. 00			db "OVER",0              
2900				endm 
# End of macro CWHEAD
2900			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
2900					if DEBUG_FORTH_WORDS_KEY 
2900						DMARK "OVR" 
2900 f5				push af  
2901 3a 15 29			ld a, (.dmark)  
2904 32 b4 fe			ld (debug_mark),a  
2907 3a 16 29			ld a, (.dmark+1)  
290a 32 b5 fe			ld (debug_mark+1),a  
290d 3a 17 29			ld a, (.dmark+2)  
2910 32 b6 fe			ld (debug_mark+2),a  
2913 18 03			jr .pastdmark  
2915 ..			.dmark: db "OVR"  
2918 f1			.pastdmark: pop af  
2919			endm  
# End of macro DMARK
2919						CALLMONITOR 
2919 cd c6 18			call break_point_state  
291c				endm  
# End of macro CALLMONITOR
291c					endif 
291c			 
291c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
291c cd 31 21			call macro_dsp_valuehl 
291f				endm 
# End of macro FORTH_DSP_VALUEHL
291f e5					push hl    ; n2 
2920					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2920 cd e9 21			call macro_forth_dsp_pop 
2923				endm 
# End of macro FORTH_DSP_POP
2923			 
2923					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2923 cd 31 21			call macro_dsp_valuehl 
2926				endm 
# End of macro FORTH_DSP_VALUEHL
2926 e5					push hl    ; n1 
2927					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2927 cd e9 21			call macro_forth_dsp_pop 
292a				endm 
# End of macro FORTH_DSP_POP
292a			 
292a d1					pop de     ; n1 
292b e1					pop hl     ; n2 
292c			 
292c d5					push de 
292d e5					push hl 
292e d5					push de 
292f			 
292f					; push back  
292f			 
292f e1					pop hl 
2930 cd 3a 1f				call forth_push_numhl 
2933 e1					pop hl 
2934 cd 3a 1f				call forth_push_numhl 
2937 e1					pop hl 
2938 cd 3a 1f				call forth_push_numhl 
293b					NEXTW 
293b c3 a8 22			jp macro_next 
293e				endm 
# End of macro NEXTW
293e			 
293e			.PAUSE: 
293e				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
293e 43				db WORD_SYS_CORE+47             
293f 73 29			dw .PAUSES            
2941 08				db 7 + 1 
2942 .. 00			db "PAUSEMS",0              
294a				endm 
# End of macro CWHEAD
294a			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
294a					if DEBUG_FORTH_WORDS_KEY 
294a						DMARK "PMS" 
294a f5				push af  
294b 3a 5f 29			ld a, (.dmark)  
294e 32 b4 fe			ld (debug_mark),a  
2951 3a 60 29			ld a, (.dmark+1)  
2954 32 b5 fe			ld (debug_mark+1),a  
2957 3a 61 29			ld a, (.dmark+2)  
295a 32 b6 fe			ld (debug_mark+2),a  
295d 18 03			jr .pastdmark  
295f ..			.dmark: db "PMS"  
2962 f1			.pastdmark: pop af  
2963			endm  
# End of macro DMARK
2963						CALLMONITOR 
2963 cd c6 18			call break_point_state  
2966				endm  
# End of macro CALLMONITOR
2966					endif 
2966					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2966 cd 31 21			call macro_dsp_valuehl 
2969				endm 
# End of macro FORTH_DSP_VALUEHL
2969			;		push hl    ; n2 
2969					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2969 cd e9 21			call macro_forth_dsp_pop 
296c				endm 
# End of macro FORTH_DSP_POP
296c			;		pop hl 
296c			 
296c 7d					ld a, l 
296d cd 77 0c				call aDelayInMS 
2970				       NEXTW 
2970 c3 a8 22			jp macro_next 
2973				endm 
# End of macro NEXTW
2973			.PAUSES:  
2973				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
2973 44				db WORD_SYS_CORE+48             
2974 e2 29			dw .ROT            
2976 06				db 5 + 1 
2977 .. 00			db "PAUSE",0              
297d				endm 
# End of macro CWHEAD
297d			; | PAUSE ( n -- )  Pause for n seconds | DONE 
297d					if DEBUG_FORTH_WORDS_KEY 
297d						DMARK "PAU" 
297d f5				push af  
297e 3a 92 29			ld a, (.dmark)  
2981 32 b4 fe			ld (debug_mark),a  
2984 3a 93 29			ld a, (.dmark+1)  
2987 32 b5 fe			ld (debug_mark+1),a  
298a 3a 94 29			ld a, (.dmark+2)  
298d 32 b6 fe			ld (debug_mark+2),a  
2990 18 03			jr .pastdmark  
2992 ..			.dmark: db "PAU"  
2995 f1			.pastdmark: pop af  
2996			endm  
# End of macro DMARK
2996						CALLMONITOR 
2996 cd c6 18			call break_point_state  
2999				endm  
# End of macro CALLMONITOR
2999					endif 
2999					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2999 cd 31 21			call macro_dsp_valuehl 
299c				endm 
# End of macro FORTH_DSP_VALUEHL
299c			;		push hl    ; n2 
299c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
299c cd e9 21			call macro_forth_dsp_pop 
299f				endm 
# End of macro FORTH_DSP_POP
299f			;		pop hl 
299f 45					ld b, l 
29a0					if DEBUG_FORTH_WORDS 
29a0						DMARK "PAU" 
29a0 f5				push af  
29a1 3a b5 29			ld a, (.dmark)  
29a4 32 b4 fe			ld (debug_mark),a  
29a7 3a b6 29			ld a, (.dmark+1)  
29aa 32 b5 fe			ld (debug_mark+1),a  
29ad 3a b7 29			ld a, (.dmark+2)  
29b0 32 b6 fe			ld (debug_mark+2),a  
29b3 18 03			jr .pastdmark  
29b5 ..			.dmark: db "PAU"  
29b8 f1			.pastdmark: pop af  
29b9			endm  
# End of macro DMARK
29b9						CALLMONITOR 
29b9 cd c6 18			call break_point_state  
29bc				endm  
# End of macro CALLMONITOR
29bc					endif 
29bc c5			.pauses1:	push bc 
29bd cd 92 0c				call delay1s 
29c0 c1					pop bc 
29c1					if DEBUG_FORTH_WORDS 
29c1						DMARK "PA1" 
29c1 f5				push af  
29c2 3a d6 29			ld a, (.dmark)  
29c5 32 b4 fe			ld (debug_mark),a  
29c8 3a d7 29			ld a, (.dmark+1)  
29cb 32 b5 fe			ld (debug_mark+1),a  
29ce 3a d8 29			ld a, (.dmark+2)  
29d1 32 b6 fe			ld (debug_mark+2),a  
29d4 18 03			jr .pastdmark  
29d6 ..			.dmark: db "PA1"  
29d9 f1			.pastdmark: pop af  
29da			endm  
# End of macro DMARK
29da						CALLMONITOR 
29da cd c6 18			call break_point_state  
29dd				endm  
# End of macro CALLMONITOR
29dd					endif 
29dd 10 dd				djnz .pauses1 
29df			 
29df				       NEXTW 
29df c3 a8 22			jp macro_next 
29e2				endm 
# End of macro NEXTW
29e2			.ROT: 
29e2				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
29e2 45				db WORD_SYS_CORE+49             
29e3 30 2a			dw .UWORDS            
29e5 04				db 3 + 1 
29e6 .. 00			db "ROT",0              
29ea				endm 
# End of macro CWHEAD
29ea			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
29ea					if DEBUG_FORTH_WORDS_KEY 
29ea						DMARK "ROT" 
29ea f5				push af  
29eb 3a ff 29			ld a, (.dmark)  
29ee 32 b4 fe			ld (debug_mark),a  
29f1 3a 00 2a			ld a, (.dmark+1)  
29f4 32 b5 fe			ld (debug_mark+1),a  
29f7 3a 01 2a			ld a, (.dmark+2)  
29fa 32 b6 fe			ld (debug_mark+2),a  
29fd 18 03			jr .pastdmark  
29ff ..			.dmark: db "ROT"  
2a02 f1			.pastdmark: pop af  
2a03			endm  
# End of macro DMARK
2a03						CALLMONITOR 
2a03 cd c6 18			call break_point_state  
2a06				endm  
# End of macro CALLMONITOR
2a06					endif 
2a06			 
2a06					FORTH_DSP_VALUEHL 
2a06 cd 31 21			call macro_dsp_valuehl 
2a09				endm 
# End of macro FORTH_DSP_VALUEHL
2a09 e5					push hl    ; u3  
2a0a			 
2a0a					FORTH_DSP_POP 
2a0a cd e9 21			call macro_forth_dsp_pop 
2a0d				endm 
# End of macro FORTH_DSP_POP
2a0d			   
2a0d					FORTH_DSP_VALUEHL 
2a0d cd 31 21			call macro_dsp_valuehl 
2a10				endm 
# End of macro FORTH_DSP_VALUEHL
2a10 e5					push hl     ; u2 
2a11			 
2a11					FORTH_DSP_POP 
2a11 cd e9 21			call macro_forth_dsp_pop 
2a14				endm 
# End of macro FORTH_DSP_POP
2a14			 
2a14					FORTH_DSP_VALUEHL 
2a14 cd 31 21			call macro_dsp_valuehl 
2a17				endm 
# End of macro FORTH_DSP_VALUEHL
2a17 e5					push hl     ; u1 
2a18			 
2a18					FORTH_DSP_POP 
2a18 cd e9 21			call macro_forth_dsp_pop 
2a1b				endm 
# End of macro FORTH_DSP_POP
2a1b			 
2a1b c1					pop bc      ; u1 
2a1c e1					pop hl      ; u2 
2a1d d1					pop de      ; u3 
2a1e			 
2a1e			 
2a1e c5					push bc 
2a1f d5					push de 
2a20 e5					push hl 
2a21			 
2a21			 
2a21 e1					pop hl 
2a22 cd 3a 1f				call forth_push_numhl 
2a25			 
2a25 e1					pop hl 
2a26 cd 3a 1f				call forth_push_numhl 
2a29			 
2a29 e1					pop hl 
2a2a cd 3a 1f				call forth_push_numhl 
2a2d					 
2a2d			 
2a2d			 
2a2d			 
2a2d			 
2a2d			 
2a2d				       NEXTW 
2a2d c3 a8 22			jp macro_next 
2a30				endm 
# End of macro NEXTW
2a30			 
2a30			.UWORDS: 
2a30				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2a30 50				db WORD_SYS_CORE+60             
2a31 f2 2a			dw .BP            
2a33 07				db 6 + 1 
2a34 .. 00			db "UWORDS",0              
2a3b				endm 
# End of macro CWHEAD
2a3b			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2a3b			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2a3b			; | | Following the count are the individual words. 
2a3b			; | | 
2a3b			; | | e.g. UWORDS 
2a3b			; | | BOX DIRLIST 2 
2a3b			; | |  
2a3b			; | | Can be used to save the words to storage via: 
2a3b			; | | UWORDS $01 DO $01 APPEND LOOP 
2a3b				if DEBUG_FORTH_WORDS_KEY 
2a3b					DMARK "UWR" 
2a3b f5				push af  
2a3c 3a 50 2a			ld a, (.dmark)  
2a3f 32 b4 fe			ld (debug_mark),a  
2a42 3a 51 2a			ld a, (.dmark+1)  
2a45 32 b5 fe			ld (debug_mark+1),a  
2a48 3a 52 2a			ld a, (.dmark+2)  
2a4b 32 b6 fe			ld (debug_mark+2),a  
2a4e 18 03			jr .pastdmark  
2a50 ..			.dmark: db "UWR"  
2a53 f1			.pastdmark: pop af  
2a54			endm  
# End of macro DMARK
2a54					CALLMONITOR 
2a54 cd c6 18			call break_point_state  
2a57				endm  
# End of macro CALLMONITOR
2a57				endif 
2a57 21 00 80				ld hl, baseram 
2a5a					;ld hl, baseusermem 
2a5a 01 00 00				ld bc, 0    ; start a counter 
2a5d			 
2a5d				; skip dict stub 
2a5d			 
2a5d cd f9 23				call forth_tok_next 
2a60			 
2a60			 
2a60			; while we have words to look for 
2a60			 
2a60 7e			.douscan:	ld a, (hl)      
2a61				if DEBUG_FORTH_WORDS 
2a61					DMARK "UWs" 
2a61 f5				push af  
2a62 3a 76 2a			ld a, (.dmark)  
2a65 32 b4 fe			ld (debug_mark),a  
2a68 3a 77 2a			ld a, (.dmark+1)  
2a6b 32 b5 fe			ld (debug_mark+1),a  
2a6e 3a 78 2a			ld a, (.dmark+2)  
2a71 32 b6 fe			ld (debug_mark+2),a  
2a74 18 03			jr .pastdmark  
2a76 ..			.dmark: db "UWs"  
2a79 f1			.pastdmark: pop af  
2a7a			endm  
# End of macro DMARK
2a7a					CALLMONITOR 
2a7a cd c6 18			call break_point_state  
2a7d				endm  
# End of macro CALLMONITOR
2a7d				endif 
2a7d fe 00				cp WORD_SYS_END 
2a7f 28 4d				jr z, .udone 
2a81 fe 01				cp WORD_SYS_UWORD 
2a83 20 44				jr nz, .nuword 
2a85			 
2a85				if DEBUG_FORTH_WORDS 
2a85					DMARK "UWu" 
2a85 f5				push af  
2a86 3a 9a 2a			ld a, (.dmark)  
2a89 32 b4 fe			ld (debug_mark),a  
2a8c 3a 9b 2a			ld a, (.dmark+1)  
2a8f 32 b5 fe			ld (debug_mark+1),a  
2a92 3a 9c 2a			ld a, (.dmark+2)  
2a95 32 b6 fe			ld (debug_mark+2),a  
2a98 18 03			jr .pastdmark  
2a9a ..			.dmark: db "UWu"  
2a9d f1			.pastdmark: pop af  
2a9e			endm  
# End of macro DMARK
2a9e					CALLMONITOR 
2a9e cd c6 18			call break_point_state  
2aa1				endm  
# End of macro CALLMONITOR
2aa1				endif 
2aa1					; we have a uword so push its name to the stack 
2aa1			 
2aa1 e5				   	push hl  ; save so we can move to next dict block 
2aa2			 
2aa2					; skip opcode 
2aa2 23					inc hl  
2aa3					; skip next ptr 
2aa3 23					inc hl  
2aa4 23					inc hl 
2aa5					; skip len 
2aa5 23					inc hl 
2aa6				if DEBUG_FORTH_WORDS 
2aa6					DMARK "UWt" 
2aa6 f5				push af  
2aa7 3a bb 2a			ld a, (.dmark)  
2aaa 32 b4 fe			ld (debug_mark),a  
2aad 3a bc 2a			ld a, (.dmark+1)  
2ab0 32 b5 fe			ld (debug_mark+1),a  
2ab3 3a bd 2a			ld a, (.dmark+2)  
2ab6 32 b6 fe			ld (debug_mark+2),a  
2ab9 18 03			jr .pastdmark  
2abb ..			.dmark: db "UWt"  
2abe f1			.pastdmark: pop af  
2abf			endm  
# End of macro DMARK
2abf					CALLMONITOR 
2abf cd c6 18			call break_point_state  
2ac2				endm  
# End of macro CALLMONITOR
2ac2				endif 
2ac2 03					inc bc 
2ac3			 
2ac3 c5					push bc 
2ac4 cd a8 1f				call forth_push_str 
2ac7 c1					pop bc 
2ac8			 
2ac8 e1					pop hl 	 
2ac9			 
2ac9 cd f9 23		.nuword:	call forth_tok_next 
2acc 18 92				jr .douscan  
2ace			 
2ace			.udone:		 ; push count of uwords found 
2ace c5					push bc 
2acf e1					pop hl 
2ad0			 
2ad0				if DEBUG_FORTH_WORDS 
2ad0					DMARK "UWc" 
2ad0 f5				push af  
2ad1 3a e5 2a			ld a, (.dmark)  
2ad4 32 b4 fe			ld (debug_mark),a  
2ad7 3a e6 2a			ld a, (.dmark+1)  
2ada 32 b5 fe			ld (debug_mark+1),a  
2add 3a e7 2a			ld a, (.dmark+2)  
2ae0 32 b6 fe			ld (debug_mark+2),a  
2ae3 18 03			jr .pastdmark  
2ae5 ..			.dmark: db "UWc"  
2ae8 f1			.pastdmark: pop af  
2ae9			endm  
# End of macro DMARK
2ae9					CALLMONITOR 
2ae9 cd c6 18			call break_point_state  
2aec				endm  
# End of macro CALLMONITOR
2aec				endif 
2aec cd 3a 1f				call forth_push_numhl 
2aef			 
2aef			 
2aef				       NEXTW 
2aef c3 a8 22			jp macro_next 
2af2				endm 
# End of macro NEXTW
2af2			 
2af2			.BP: 
2af2				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2af2 54				db WORD_SYS_CORE+64             
2af3 28 2b			dw .MONITOR            
2af5 03				db 2 + 1 
2af6 .. 00			db "BP",0              
2af9				endm 
# End of macro CWHEAD
2af9			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2af9			; | | $00 Will enable the break points within specific code paths 
2af9			; | | $01 Will disable break points 
2af9			; | |  
2af9			; | | By default break points are off. Either the above can be used to enable them 
2af9			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2af9			; | | and on release of the pressed key a message will be disaplayed to notify 
2af9			; | | that break points are enabled. Pressing any key will then continue boot process. 
2af9					; get byte count 
2af9					if DEBUG_FORTH_WORDS_KEY 
2af9						DMARK "BP." 
2af9 f5				push af  
2afa 3a 0e 2b			ld a, (.dmark)  
2afd 32 b4 fe			ld (debug_mark),a  
2b00 3a 0f 2b			ld a, (.dmark+1)  
2b03 32 b5 fe			ld (debug_mark+1),a  
2b06 3a 10 2b			ld a, (.dmark+2)  
2b09 32 b6 fe			ld (debug_mark+2),a  
2b0c 18 03			jr .pastdmark  
2b0e ..			.dmark: db "BP."  
2b11 f1			.pastdmark: pop af  
2b12			endm  
# End of macro DMARK
2b12						CALLMONITOR 
2b12 cd c6 18			call break_point_state  
2b15				endm  
# End of macro CALLMONITOR
2b15					endif 
2b15			 
2b15					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b15 cd 31 21			call macro_dsp_valuehl 
2b18				endm 
# End of macro FORTH_DSP_VALUEHL
2b18			 
2b18			;		push hl 
2b18			 
2b18					; destroy value TOS 
2b18			 
2b18					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b18 cd e9 21			call macro_forth_dsp_pop 
2b1b				endm 
# End of macro FORTH_DSP_POP
2b1b			 
2b1b			;		pop hl 
2b1b			 
2b1b 3e 00				ld a,0 
2b1d bd					cp l 
2b1e 28 02				jr z, .bpset 
2b20 3e 2a				ld a, '*' 
2b22			 
2b22 32 73 f3		.bpset:		ld (os_view_disable), a 
2b25			 
2b25			 
2b25					NEXTW 
2b25 c3 a8 22			jp macro_next 
2b28				endm 
# End of macro NEXTW
2b28			 
2b28			 
2b28			.MONITOR: 
2b28				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2b28 55				db WORD_SYS_CORE+65             
2b29 5b 2b			dw .MALLOC            
2b2b 08				db 7 + 1 
2b2c .. 00			db "MONITOR",0              
2b34				endm 
# End of macro CWHEAD
2b34			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2b34			; | | At start the current various registers will be displayed with contents. 
2b34			; | | Top right corner will show the most recent debug marker seen. 
2b34			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2b34			; | | and the return stack pointer (RSP). 
2b34			; | | Pressing: 
2b34			; | |    1 - Initial screen 
2b34			; | |    2 - Display a data dump of HL 
2b34			; | |    3 - Display a data dump of DE 
2b34			; | |    4 - Display a data dump of BC 
2b34			; | |    5 - Display a data dump of HL 
2b34			; | |    6 - Display a data dump of DSP 
2b34			; | |    7 - Display a data dump of RSP 
2b34			; | |    8 - Display a data dump of what is at DSP 
2b34			; | |    9 - Display a data dump of what is at RSP 
2b34			; | |    0 - Exit monitor and continue running. This will also enable break points 
2b34			; | |    * - Disable break points 
2b34			; | |    # - Enter traditional monitor mode 
2b34			; | | 
2b34			; | | Monitor Mode 
2b34			; | | ------------ 
2b34			; | | A prompt of '>' will be shown for various commands: 
2b34			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2b34			; | |    C - Continue display a data dump from the last set address 
2b34			; | |    M xxxx - Set start of memory edit at address xx 
2b34			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2b34			; | |    Q - Return to previous 
2b34					if DEBUG_FORTH_WORDS_KEY 
2b34						DMARK "MON" 
2b34 f5				push af  
2b35 3a 49 2b			ld a, (.dmark)  
2b38 32 b4 fe			ld (debug_mark),a  
2b3b 3a 4a 2b			ld a, (.dmark+1)  
2b3e 32 b5 fe			ld (debug_mark+1),a  
2b41 3a 4b 2b			ld a, (.dmark+2)  
2b44 32 b6 fe			ld (debug_mark+2),a  
2b47 18 03			jr .pastdmark  
2b49 ..			.dmark: db "MON"  
2b4c f1			.pastdmark: pop af  
2b4d			endm  
# End of macro DMARK
2b4d						CALLMONITOR 
2b4d cd c6 18			call break_point_state  
2b50				endm  
# End of macro CALLMONITOR
2b50					endif 
2b50 3e 00				ld a, 0 
2b52 32 73 f3				ld (os_view_disable), a 
2b55			 
2b55					CALLMONITOR 
2b55 cd c6 18			call break_point_state  
2b58				endm  
# End of macro CALLMONITOR
2b58			 
2b58			;	call monitor 
2b58			 
2b58					NEXTW 
2b58 c3 a8 22			jp macro_next 
2b5b				endm 
# End of macro NEXTW
2b5b			 
2b5b			 
2b5b			.MALLOC: 
2b5b				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2b5b 56				db WORD_SYS_CORE+66             
2b5c 84 2b			dw .MALLOC2            
2b5e 06				db 5 + 1 
2b5f .. 00			db "ALLOT",0              
2b65				endm 
# End of macro CWHEAD
2b65			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2b65					if DEBUG_FORTH_WORDS_KEY 
2b65						DMARK "ALL" 
2b65 f5				push af  
2b66 3a 7a 2b			ld a, (.dmark)  
2b69 32 b4 fe			ld (debug_mark),a  
2b6c 3a 7b 2b			ld a, (.dmark+1)  
2b6f 32 b5 fe			ld (debug_mark+1),a  
2b72 3a 7c 2b			ld a, (.dmark+2)  
2b75 32 b6 fe			ld (debug_mark+2),a  
2b78 18 03			jr .pastdmark  
2b7a ..			.dmark: db "ALL"  
2b7d f1			.pastdmark: pop af  
2b7e			endm  
# End of macro DMARK
2b7e						CALLMONITOR 
2b7e cd c6 18			call break_point_state  
2b81				endm  
# End of macro CALLMONITOR
2b81					endif 
2b81 c3 ab 2b				jp .mallocc 
2b84			.MALLOC2: 
2b84				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2b84 56				db WORD_SYS_CORE+66             
2b85 c2 2b			dw .FREE            
2b87 07				db 6 + 1 
2b88 .. 00			db "MALLOC",0              
2b8f				endm 
# End of macro CWHEAD
2b8f			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2b8f					; get byte count 
2b8f					if DEBUG_FORTH_WORDS_KEY 
2b8f						DMARK "MAL" 
2b8f f5				push af  
2b90 3a a4 2b			ld a, (.dmark)  
2b93 32 b4 fe			ld (debug_mark),a  
2b96 3a a5 2b			ld a, (.dmark+1)  
2b99 32 b5 fe			ld (debug_mark+1),a  
2b9c 3a a6 2b			ld a, (.dmark+2)  
2b9f 32 b6 fe			ld (debug_mark+2),a  
2ba2 18 03			jr .pastdmark  
2ba4 ..			.dmark: db "MAL"  
2ba7 f1			.pastdmark: pop af  
2ba8			endm  
# End of macro DMARK
2ba8						CALLMONITOR 
2ba8 cd c6 18			call break_point_state  
2bab				endm  
# End of macro CALLMONITOR
2bab					endif 
2bab			.mallocc: 
2bab					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2bab cd 31 21			call macro_dsp_valuehl 
2bae				endm 
# End of macro FORTH_DSP_VALUEHL
2bae			 
2bae			;		push hl 
2bae			 
2bae					; destroy value TOS 
2bae			 
2bae					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2bae cd e9 21			call macro_forth_dsp_pop 
2bb1				endm 
# End of macro FORTH_DSP_POP
2bb1			 
2bb1			;		pop hl 
2bb1 cd 10 14				call malloc 
2bb4				if DEBUG_FORTH_MALLOC_GUARD 
2bb4 f5					push af 
2bb5 cd 72 0f				call ishlzero 
2bb8			;		ld a, l 
2bb8			;		add h 
2bb8			;		cp 0 
2bb8 f1					pop af 
2bb9					 
2bb9 cc 46 56				call z,malloc_error 
2bbc				endif 
2bbc			 
2bbc cd 3a 1f				call forth_push_numhl 
2bbf					NEXTW 
2bbf c3 a8 22			jp macro_next 
2bc2				endm 
# End of macro NEXTW
2bc2			 
2bc2			.FREE: 
2bc2				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2bc2 57				db WORD_SYS_CORE+67             
2bc3 f3 2b			dw .LIST            
2bc5 05				db 4 + 1 
2bc6 .. 00			db "FREE",0              
2bcb				endm 
# End of macro CWHEAD
2bcb			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2bcb					if DEBUG_FORTH_WORDS_KEY 
2bcb						DMARK "FRE" 
2bcb f5				push af  
2bcc 3a e0 2b			ld a, (.dmark)  
2bcf 32 b4 fe			ld (debug_mark),a  
2bd2 3a e1 2b			ld a, (.dmark+1)  
2bd5 32 b5 fe			ld (debug_mark+1),a  
2bd8 3a e2 2b			ld a, (.dmark+2)  
2bdb 32 b6 fe			ld (debug_mark+2),a  
2bde 18 03			jr .pastdmark  
2be0 ..			.dmark: db "FRE"  
2be3 f1			.pastdmark: pop af  
2be4			endm  
# End of macro DMARK
2be4						CALLMONITOR 
2be4 cd c6 18			call break_point_state  
2be7				endm  
# End of macro CALLMONITOR
2be7					endif 
2be7					; get address 
2be7			 
2be7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2be7 cd 31 21			call macro_dsp_valuehl 
2bea				endm 
# End of macro FORTH_DSP_VALUEHL
2bea			 
2bea			;		push hl 
2bea			 
2bea					; destroy value TOS 
2bea			 
2bea					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2bea cd e9 21			call macro_forth_dsp_pop 
2bed				endm 
# End of macro FORTH_DSP_POP
2bed			 
2bed			;		pop hl 
2bed			if FORTH_ENABLE_MALLOCFREE 
2bed cd da 14				call free 
2bf0			endif 
2bf0					NEXTW 
2bf0 c3 a8 22			jp macro_next 
2bf3				endm 
# End of macro NEXTW
2bf3			.LIST: 
2bf3				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2bf3 5c				db WORD_SYS_CORE+72             
2bf4 e1 2d			dw .FORGET            
2bf6 05				db 4 + 1 
2bf7 .. 00			db "LIST",0              
2bfc				endm 
# End of macro CWHEAD
2bfc			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2bfc			; | | The quoted word must be in upper case. 
2bfc				if DEBUG_FORTH_WORDS_KEY 
2bfc					DMARK "LST" 
2bfc f5				push af  
2bfd 3a 11 2c			ld a, (.dmark)  
2c00 32 b4 fe			ld (debug_mark),a  
2c03 3a 12 2c			ld a, (.dmark+1)  
2c06 32 b5 fe			ld (debug_mark+1),a  
2c09 3a 13 2c			ld a, (.dmark+2)  
2c0c 32 b6 fe			ld (debug_mark+2),a  
2c0f 18 03			jr .pastdmark  
2c11 ..			.dmark: db "LST"  
2c14 f1			.pastdmark: pop af  
2c15			endm  
# End of macro DMARK
2c15					CALLMONITOR 
2c15 cd c6 18			call break_point_state  
2c18				endm  
# End of macro CALLMONITOR
2c18				endif 
2c18			 
2c18					FORTH_DSP_VALUEHL 
2c18 cd 31 21			call macro_dsp_valuehl 
2c1b				endm 
# End of macro FORTH_DSP_VALUEHL
2c1b			 
2c1b e5					push hl 
2c1c					FORTH_DSP_POP 
2c1c cd e9 21			call macro_forth_dsp_pop 
2c1f				endm 
# End of macro FORTH_DSP_POP
2c1f c1					pop bc 
2c20			 
2c20			; Start format of scratch string 
2c20			 
2c20 21 82 f3				ld hl, scratch 
2c23			 
2c23 3e 3a				ld a, ':' 
2c25 77					ld (hl),a 
2c26 23					inc hl 
2c27 3e 20				ld a, ' ' 
2c29 77					ld (hl), a 
2c2a			 
2c2a					; Get ptr to the word we need to look up 
2c2a			 
2c2a			;		FORTH_DSP_VALUEHL 
2c2a					;v5 FORTH_DSP_VALUE 
2c2a				; TODO type check 
2c2a			;		inc hl    ; Skip type check  
2c2a			;		push hl 
2c2a			;		ex de, hl    ; put into DE 
2c2a			 
2c2a			 
2c2a 21 00 80				ld hl, baseram 
2c2d					;ld hl, baseusermem 
2c2d			 
2c2d e5			push hl   ; sacreifical push 
2c2e			 
2c2e			.ldouscanm: 
2c2e e1				pop hl 
2c2f			.ldouscan: 
2c2f				if DEBUG_FORTH_WORDS 
2c2f					DMARK "LSs" 
2c2f f5				push af  
2c30 3a 44 2c			ld a, (.dmark)  
2c33 32 b4 fe			ld (debug_mark),a  
2c36 3a 45 2c			ld a, (.dmark+1)  
2c39 32 b5 fe			ld (debug_mark+1),a  
2c3c 3a 46 2c			ld a, (.dmark+2)  
2c3f 32 b6 fe			ld (debug_mark+2),a  
2c42 18 03			jr .pastdmark  
2c44 ..			.dmark: db "LSs"  
2c47 f1			.pastdmark: pop af  
2c48			endm  
# End of macro DMARK
2c48					CALLMONITOR 
2c48 cd c6 18			call break_point_state  
2c4b				endm  
# End of macro CALLMONITOR
2c4b				endif 
2c4b				; skip dict stub 
2c4b cd f9 23				call forth_tok_next 
2c4e			 
2c4e			 
2c4e			; while we have words to look for 
2c4e			 
2c4e 7e				ld a, (hl)      
2c4f				if DEBUG_FORTH_WORDS 
2c4f					DMARK "LSk" 
2c4f f5				push af  
2c50 3a 64 2c			ld a, (.dmark)  
2c53 32 b4 fe			ld (debug_mark),a  
2c56 3a 65 2c			ld a, (.dmark+1)  
2c59 32 b5 fe			ld (debug_mark+1),a  
2c5c 3a 66 2c			ld a, (.dmark+2)  
2c5f 32 b6 fe			ld (debug_mark+2),a  
2c62 18 03			jr .pastdmark  
2c64 ..			.dmark: db "LSk"  
2c67 f1			.pastdmark: pop af  
2c68			endm  
# End of macro DMARK
2c68					CALLMONITOR 
2c68 cd c6 18			call break_point_state  
2c6b				endm  
# End of macro CALLMONITOR
2c6b				endif 
2c6b					;cp WORD_SYS_END 
2c6b					;jp z, .lunotfound 
2c6b			 
2c6b					; if we hit non uwords then gone too far 
2c6b fe 01				cp WORD_SYS_UWORD 
2c6d c2 9d 2d				jp nz, .lunotfound 
2c70			 
2c70				if DEBUG_FORTH_WORDS 
2c70					DMARK "LSu" 
2c70 f5				push af  
2c71 3a 85 2c			ld a, (.dmark)  
2c74 32 b4 fe			ld (debug_mark),a  
2c77 3a 86 2c			ld a, (.dmark+1)  
2c7a 32 b5 fe			ld (debug_mark+1),a  
2c7d 3a 87 2c			ld a, (.dmark+2)  
2c80 32 b6 fe			ld (debug_mark+2),a  
2c83 18 03			jr .pastdmark  
2c85 ..			.dmark: db "LSu"  
2c88 f1			.pastdmark: pop af  
2c89			endm  
# End of macro DMARK
2c89					CALLMONITOR 
2c89 cd c6 18			call break_point_state  
2c8c				endm  
# End of macro CALLMONITOR
2c8c				endif 
2c8c			 
2c8c					; found a uword but is it the one we want... 
2c8c			 
2c8c c5					push bc     ; uword to find is on bc 
2c8d d1					pop de 
2c8e			 
2c8e e5					push hl  ; to save the ptr 
2c8f			 
2c8f					; skip opcode 
2c8f 23					inc hl  
2c90					; skip next ptr 
2c90 23					inc hl  
2c91 23					inc hl 
2c92					; skip len 
2c92 23					inc hl 
2c93			 
2c93				if DEBUG_FORTH_WORDS 
2c93					DMARK "LSc" 
2c93 f5				push af  
2c94 3a a8 2c			ld a, (.dmark)  
2c97 32 b4 fe			ld (debug_mark),a  
2c9a 3a a9 2c			ld a, (.dmark+1)  
2c9d 32 b5 fe			ld (debug_mark+1),a  
2ca0 3a aa 2c			ld a, (.dmark+2)  
2ca3 32 b6 fe			ld (debug_mark+2),a  
2ca6 18 03			jr .pastdmark  
2ca8 ..			.dmark: db "LSc"  
2cab f1			.pastdmark: pop af  
2cac			endm  
# End of macro DMARK
2cac					CALLMONITOR 
2cac cd c6 18			call break_point_state  
2caf				endm  
# End of macro CALLMONITOR
2caf				endif 
2caf cd df 13				call strcmp 
2cb2 c2 2e 2c				jp nz, .ldouscanm 
2cb5				 
2cb5			 
2cb5			 
2cb5					; we have a uword so push its name to the stack 
2cb5			 
2cb5			;	   	push hl  ; save so we can move to next dict block 
2cb5 e1			pop hl 
2cb6			 
2cb6				if DEBUG_FORTH_WORDS 
2cb6					DMARK "LSm" 
2cb6 f5				push af  
2cb7 3a cb 2c			ld a, (.dmark)  
2cba 32 b4 fe			ld (debug_mark),a  
2cbd 3a cc 2c			ld a, (.dmark+1)  
2cc0 32 b5 fe			ld (debug_mark+1),a  
2cc3 3a cd 2c			ld a, (.dmark+2)  
2cc6 32 b6 fe			ld (debug_mark+2),a  
2cc9 18 03			jr .pastdmark  
2ccb ..			.dmark: db "LSm"  
2cce f1			.pastdmark: pop af  
2ccf			endm  
# End of macro DMARK
2ccf					CALLMONITOR 
2ccf cd c6 18			call break_point_state  
2cd2				endm  
# End of macro CALLMONITOR
2cd2				endif 
2cd2			 
2cd2					; skip opcode 
2cd2 23					inc hl  
2cd3					; skip next ptr 
2cd3 23					inc hl  
2cd4 23					inc hl 
2cd5					; skip len 
2cd5 7e					ld a, (hl)   ; save length to add 
2cd6				if DEBUG_FORTH_WORDS 
2cd6					DMARK "LS2" 
2cd6 f5				push af  
2cd7 3a eb 2c			ld a, (.dmark)  
2cda 32 b4 fe			ld (debug_mark),a  
2cdd 3a ec 2c			ld a, (.dmark+1)  
2ce0 32 b5 fe			ld (debug_mark+1),a  
2ce3 3a ed 2c			ld a, (.dmark+2)  
2ce6 32 b6 fe			ld (debug_mark+2),a  
2ce9 18 03			jr .pastdmark  
2ceb ..			.dmark: db "LS2"  
2cee f1			.pastdmark: pop af  
2cef			endm  
# End of macro DMARK
2cef					CALLMONITOR 
2cef cd c6 18			call break_point_state  
2cf2				endm  
# End of macro CALLMONITOR
2cf2				endif 
2cf2			 
2cf2					; save this location 
2cf2				 
2cf2 e5					push hl 
2cf3			 
2cf3 23					inc hl 
2cf4 11 84 f3				ld de, scratch+2 
2cf7 4f					ld c, a 
2cf8 06 00				ld b, 0 
2cfa			 
2cfa				if DEBUG_FORTH_WORDS 
2cfa					DMARK "LSn" 
2cfa f5				push af  
2cfb 3a 0f 2d			ld a, (.dmark)  
2cfe 32 b4 fe			ld (debug_mark),a  
2d01 3a 10 2d			ld a, (.dmark+1)  
2d04 32 b5 fe			ld (debug_mark+1),a  
2d07 3a 11 2d			ld a, (.dmark+2)  
2d0a 32 b6 fe			ld (debug_mark+2),a  
2d0d 18 03			jr .pastdmark  
2d0f ..			.dmark: db "LSn"  
2d12 f1			.pastdmark: pop af  
2d13			endm  
# End of macro DMARK
2d13					CALLMONITOR 
2d13 cd c6 18			call break_point_state  
2d16				endm  
# End of macro CALLMONITOR
2d16				endif 
2d16			 
2d16					; copy uword name to scratch 
2d16			 
2d16 ed b0				ldir 
2d18			 
2d18 1b					dec de 
2d19 3e 20				ld a, ' '    ; change null to space 
2d1b 12					ld (de), a 
2d1c			 
2d1c 13					inc de 
2d1d			 
2d1d d5					push de 
2d1e c1					pop bc     ; move scratch pointer to end of word name and save it 
2d1f			 
2d1f e1					pop hl 
2d20 7e					ld a, (hl) 
2d21					;inc hl 
2d21					; skip word string 
2d21 cd 49 0f				call addatohl 
2d24			 
2d24 23					inc hl 
2d25			 
2d25				if DEBUG_FORTH_WORDS 
2d25					DMARK "LS3" 
2d25 f5				push af  
2d26 3a 3a 2d			ld a, (.dmark)  
2d29 32 b4 fe			ld (debug_mark),a  
2d2c 3a 3b 2d			ld a, (.dmark+1)  
2d2f 32 b5 fe			ld (debug_mark+1),a  
2d32 3a 3c 2d			ld a, (.dmark+2)  
2d35 32 b6 fe			ld (debug_mark+2),a  
2d38 18 03			jr .pastdmark  
2d3a ..			.dmark: db "LS3"  
2d3d f1			.pastdmark: pop af  
2d3e			endm  
# End of macro DMARK
2d3e					CALLMONITOR 
2d3e cd c6 18			call break_point_state  
2d41				endm  
# End of macro CALLMONITOR
2d41				endif 
2d41					; should now be at the start of the machine code to setup the eval of the uword 
2d41					; now locate the ptr to the string defintion 
2d41			 
2d41					; skip ld hl, 
2d41					; then load the ptr 
2d41			; TODO use get from hl ptr 
2d41 23					inc hl 
2d42 5e					ld e, (hl) 
2d43 23					inc hl 
2d44 56					ld d, (hl) 
2d45 eb					ex de, hl 
2d46			 
2d46			 
2d46				if DEBUG_FORTH_WORDS 
2d46					DMARK "LSt" 
2d46 f5				push af  
2d47 3a 5b 2d			ld a, (.dmark)  
2d4a 32 b4 fe			ld (debug_mark),a  
2d4d 3a 5c 2d			ld a, (.dmark+1)  
2d50 32 b5 fe			ld (debug_mark+1),a  
2d53 3a 5d 2d			ld a, (.dmark+2)  
2d56 32 b6 fe			ld (debug_mark+2),a  
2d59 18 03			jr .pastdmark  
2d5b ..			.dmark: db "LSt"  
2d5e f1			.pastdmark: pop af  
2d5f			endm  
# End of macro DMARK
2d5f					CALLMONITOR 
2d5f cd c6 18			call break_point_state  
2d62				endm  
# End of macro CALLMONITOR
2d62				endif 
2d62			 
2d62			; cant push right now due to tokenised strings  
2d62			 
2d62			; get the destination of where to copy this definition to. 
2d62			 
2d62 c5					push bc 
2d63 d1					pop de 
2d64			 
2d64 7e			.listl:         ld a,(hl) 
2d65 fe 00				cp 0 
2d67 28 09				jr z, .lreplsp     ; replace zero with space 
2d69					;cp FORTH_END_BUFFER 
2d69 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2d6b 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2d6d				 
2d6d					; just copy this char as is then 
2d6d			 
2d6d 12					ld (de), a 
2d6e			 
2d6e 23			.listnxt:	inc hl 
2d6f 13					inc de 
2d70 18 f2				jr .listl 
2d72			 
2d72 3e 20		.lreplsp:	ld a,' ' 
2d74 12					ld (de), a 
2d75 18 f7				jr .listnxt 
2d77			 
2d77			; close up uword def 
2d77			 
2d77			.listdone: 
2d77 12					ld (de), a 
2d78 13					inc de 
2d79 3e 00				ld a, 0 
2d7b 12					ld (de), a 
2d7c			 
2d7c			; now have def so clean up and push to stack 
2d7c			 
2d7c 21 82 f3				ld hl, scratch 
2d7f				if DEBUG_FORTH_WORDS 
2d7f					DMARK "Ltp" 
2d7f f5				push af  
2d80 3a 94 2d			ld a, (.dmark)  
2d83 32 b4 fe			ld (debug_mark),a  
2d86 3a 95 2d			ld a, (.dmark+1)  
2d89 32 b5 fe			ld (debug_mark+1),a  
2d8c 3a 96 2d			ld a, (.dmark+2)  
2d8f 32 b6 fe			ld (debug_mark+2),a  
2d92 18 03			jr .pastdmark  
2d94 ..			.dmark: db "Ltp"  
2d97 f1			.pastdmark: pop af  
2d98			endm  
# End of macro DMARK
2d98					CALLMONITOR 
2d98 cd c6 18			call break_point_state  
2d9b				endm  
# End of macro CALLMONITOR
2d9b				endif 
2d9b			 
2d9b 18 1f			jr .listpush 
2d9d			 
2d9d			;.lnuword:	pop hl 
2d9d			;		call forth_tok_next 
2d9d			;		jp .ldouscan  
2d9d			 
2d9d			.lunotfound:		  
2d9d			 
2d9d				if DEBUG_FORTH_WORDS 
2d9d					DMARK "LSn" 
2d9d f5				push af  
2d9e 3a b2 2d			ld a, (.dmark)  
2da1 32 b4 fe			ld (debug_mark),a  
2da4 3a b3 2d			ld a, (.dmark+1)  
2da7 32 b5 fe			ld (debug_mark+1),a  
2daa 3a b4 2d			ld a, (.dmark+2)  
2dad 32 b6 fe			ld (debug_mark+2),a  
2db0 18 03			jr .pastdmark  
2db2 ..			.dmark: db "LSn"  
2db5 f1			.pastdmark: pop af  
2db6			endm  
# End of macro DMARK
2db6					CALLMONITOR 
2db6 cd c6 18			call break_point_state  
2db9				endm  
# End of macro CALLMONITOR
2db9				endif 
2db9			 
2db9					 
2db9			;		FORTH_DSP_POP 
2db9			;		ld hl, .luno 
2db9			 
2db9					NEXTW			 
2db9 c3 a8 22			jp macro_next 
2dbc				endm 
# End of macro NEXTW
2dbc			 
2dbc			.listpush: 
2dbc				if DEBUG_FORTH_WORDS 
2dbc					DMARK "LS>" 
2dbc f5				push af  
2dbd 3a d1 2d			ld a, (.dmark)  
2dc0 32 b4 fe			ld (debug_mark),a  
2dc3 3a d2 2d			ld a, (.dmark+1)  
2dc6 32 b5 fe			ld (debug_mark+1),a  
2dc9 3a d3 2d			ld a, (.dmark+2)  
2dcc 32 b6 fe			ld (debug_mark+2),a  
2dcf 18 03			jr .pastdmark  
2dd1 ..			.dmark: db "LS>"  
2dd4 f1			.pastdmark: pop af  
2dd5			endm  
# End of macro DMARK
2dd5					CALLMONITOR 
2dd5 cd c6 18			call break_point_state  
2dd8				endm  
# End of macro CALLMONITOR
2dd8				endif 
2dd8 cd a8 1f				call forth_push_str 
2ddb			 
2ddb			 
2ddb			 
2ddb					NEXTW 
2ddb c3 a8 22			jp macro_next 
2dde				endm 
# End of macro NEXTW
2dde			 
2dde			;.luno:    db "Word not found",0 
2dde			 
2dde			 
2dde			 
2dde			 
2dde			 
2dde			;		push hl   ; save pointer to start of uword def string 
2dde			; 
2dde			;; look for FORTH_EOL_LINE 
2dde			;		ld a, FORTH_END_BUFFER 
2dde			;		call strlent 
2dde			; 
2dde			;		inc hl		 ; space for coln def 
2dde			;		inc hl 
2dde			;		inc hl          ; space for terms 
2dde			;		inc hl 
2dde			; 
2dde			;		ld a, 20   ; TODO get actual length 
2dde			;		call addatohl    ; include a random amount of room for the uword name 
2dde			; 
2dde			;		 
2dde			;	if DEBUG_FORTH_WORDS 
2dde			;		DMARK "Lt1" 
2dde			;		CALLMONITOR 
2dde			;	endif 
2dde			;		 
2dde			; 
2dde			;; malloc space for the string because we cant change it 
2dde			; 
2dde			;		call malloc 
2dde			;	if DEBUG_FORTH_MALLOC_GUARD 
2dde			;		push af 
2dde			;		call ishlzero 
2dde			;		pop af 
2dde			;		 
2dde			;		call z,malloc_error 
2dde			;	endif 
2dde			; 
2dde			;	if DEBUG_FORTH_WORDS 
2dde			;		DMARK "Lt2" 
2dde			;		CALLMONITOR 
2dde			;	endif 
2dde			;		pop de 
2dde			;		push hl    ; push the malloc to release later 
2dde			;		push hl   ;  push back a copy for the later stack push 
2dde			;		 
2dde			;; copy the string swapping out the zero terms for spaces 
2dde			; 
2dde			;		; de has our source 
2dde			;		; hl has our dest 
2dde			; 
2dde			;; add the coln def 
2dde			; 
2dde			;		ld a, ':' 
2dde			;		ld (hl), a 
2dde			;		inc hl 
2dde			;		ld a, ' ' 
2dde			;		ld (hl), a 
2dde			;		inc hl 
2dde			; 
2dde			;; add the uname word 
2dde			;		push de   ; save our string for now 
2dde			;		ex de, hl 
2dde			; 
2dde			;		FORTH_DSP_VALUE 
2dde			;		;v5 FORTH_DSP_VALUE 
2dde			; 
2dde			;		inc hl   ; skip type but we know by now this is OK 
2dde			; 
2dde			;.luword:	ld a,(hl) 
2dde			;		cp 0 
2dde			;		jr z, .luword2 
2dde			;		ld (de), a 
2dde			;		inc de 
2dde			;		inc hl 
2dde			;		jr .luword 
2dde			; 
2dde			;.luword2:	ld a, ' ' 
2dde			;		ld (de), a 
2dde			;;		inc hl 
2dde			;;		inc de 
2dde			;;		ld (de), a 
2dde			;;		inc hl 
2dde			;		inc de 
2dde			; 
2dde			;		ex de, hl 
2dde			;		pop de 
2dde			;		 
2dde			;		 
2dde			; 
2dde			;; detoken that string and copy it 
2dde			; 
2dde			;	if DEBUG_FORTH_WORDS 
2dde			;		DMARK "Lt2" 
2dde			;		CALLMONITOR 
2dde			;	endif 
2dde			;.ldetok:	ld a, (de) 
2dde			;		cp FORTH_END_BUFFER 
2dde			;		jr z, .ldetokend 
2dde			;		; swap out any zero term for space 
2dde			;		cp 0 
2dde			;		jr nz, .ldetoknext 
2dde			;		ld a, ' ' 
2dde			; 
2dde			;	if DEBUG_FORTH_WORDS 
2dde			;		DMARK "LtS" 
2dde			;		CALLMONITOR 
2dde			;	endif 
2dde			;.ldetoknext:	ld (hl), a 
2dde			;		inc de 
2dde			;		inc hl 
2dde			;		jr .ldetok 
2dde			; 
2dde			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2dde			;		ld (hl), a  
2dde			; 
2dde			;; free that temp malloc 
2dde			; 
2dde			;		pop hl    
2dde			; 
2dde			;	if DEBUG_FORTH_WORDS 
2dde			;		DMARK "Lt4" 
2dde			;		CALLMONITOR 
2dde			;	endif 
2dde			;		call forth_apushstrhl 
2dde			; 
2dde			;		; get rid of temp malloc area 
2dde			; 
2dde			;		pop hl 
2dde			;		call free 
2dde			; 
2dde			;		jr .ludone 
2dde			; 
2dde			;.lnuword:	pop hl 
2dde			;		call forth_tok_next 
2dde			;		jp .ldouscan  
2dde			; 
2dde			;.ludone:		 pop hl 
2dde			; 
2dde					NEXTW 
2dde c3 a8 22			jp macro_next 
2de1				endm 
# End of macro NEXTW
2de1			 
2de1			.FORGET: 
2de1				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2de1 5d				db WORD_SYS_CORE+73             
2de2 5a 2e			dw .NOP            
2de4 07				db 6 + 1 
2de5 .. 00			db "FORGET",0              
2dec				endm 
# End of macro CWHEAD
2dec			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2dec			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2dec			; | |  
2dec			; | | e.g. "MORE" forget 
2dec					if DEBUG_FORTH_WORDS_KEY 
2dec						DMARK "FRG" 
2dec f5				push af  
2ded 3a 01 2e			ld a, (.dmark)  
2df0 32 b4 fe			ld (debug_mark),a  
2df3 3a 02 2e			ld a, (.dmark+1)  
2df6 32 b5 fe			ld (debug_mark+1),a  
2df9 3a 03 2e			ld a, (.dmark+2)  
2dfc 32 b6 fe			ld (debug_mark+2),a  
2dff 18 03			jr .pastdmark  
2e01 ..			.dmark: db "FRG"  
2e04 f1			.pastdmark: pop af  
2e05			endm  
# End of macro DMARK
2e05						CALLMONITOR 
2e05 cd c6 18			call break_point_state  
2e08				endm  
# End of macro CALLMONITOR
2e08					endif 
2e08			 
2e08				; find uword 
2e08			        ; update start of word with "_" 
2e08				; replace uword with deleted flag 
2e08			 
2e08			 
2e08			;	if DEBUG_FORTH_WORDS 
2e08			;		DMARK "FOG" 
2e08			;		CALLMONITOR 
2e08			;	endif 
2e08			 
2e08			 
2e08					; Get ptr to the word we need to look up 
2e08			 
2e08					FORTH_DSP_VALUEHL 
2e08 cd 31 21			call macro_dsp_valuehl 
2e0b				endm 
# End of macro FORTH_DSP_VALUEHL
2e0b					;v5 FORTH_DSP_VALUE 
2e0b				; TODO type check 
2e0b			;		inc hl    ; Skip type check  
2e0b e5					push hl 
2e0c c1					pop bc 
2e0d			;		ex de, hl    ; put into DE 
2e0d			 
2e0d			 
2e0d 21 00 80				ld hl, baseram 
2e10					;ld hl, baseusermem 
2e10			 
2e10				; skip dict stub 
2e10			;	call forth_tok_next 
2e10 e5			push hl   ; sacreifical push 
2e11			 
2e11			.fldouscanm: 
2e11 e1				pop hl 
2e12			.fldouscan: 
2e12			;	if DEBUG_FORTH_WORDS 
2e12			;		DMARK "LSs" 
2e12			;		CALLMONITOR 
2e12			;	endif 
2e12				; skip dict stub 
2e12 cd f9 23				call forth_tok_next 
2e15			 
2e15			 
2e15			; while we have words to look for 
2e15			 
2e15 7e				ld a, (hl)      
2e16			;	if DEBUG_FORTH_WORDS 
2e16			;		DMARK "LSk" 
2e16			;		CALLMONITOR 
2e16			;	endif 
2e16 fe 00				cp WORD_SYS_END 
2e18 ca 54 2e				jp z, .flunotfound 
2e1b fe 01				cp WORD_SYS_UWORD 
2e1d c2 12 2e				jp nz, .fldouscan 
2e20			 
2e20			;	if DEBUG_FORTH_WORDS 
2e20			;		DMARK "LSu" 
2e20			;		CALLMONITOR 
2e20			;	endif 
2e20			 
2e20					; found a uword but is it the one we want... 
2e20			 
2e20 c5					push bc     ; uword to find is on bc 
2e21 d1					pop de 
2e22			 
2e22 e5					push hl  ; to save the ptr 
2e23			 
2e23					; skip opcode 
2e23 23					inc hl  
2e24					; skip next ptr 
2e24 23					inc hl  
2e25 23					inc hl 
2e26					; skip len 
2e26 23					inc hl 
2e27			 
2e27			;	if DEBUG_FORTH_WORDS 
2e27			;		DMARK "LSc" 
2e27			;		CALLMONITOR 
2e27			;	endif 
2e27 cd df 13				call strcmp 
2e2a c2 11 2e				jp nz, .fldouscanm 
2e2d			; 
2e2d			; 
2e2d			;; while we have words to look for 
2e2d			; 
2e2d			;.fdouscan:	ld a, (hl)      
2e2d			;	if DEBUG_FORTH_WORDS 
2e2d			;		DMARK "LSs" 
2e2d			;		CALLMONITOR 
2e2d			;	endif 
2e2d			;		cp WORD_SYS_END 
2e2d			;		jp z, .fudone 
2e2d			;		cp WORD_SYS_UWORD 
2e2d			;		jp nz, .fnuword 
2e2d			; 
2e2d			;	if DEBUG_FORTH_WORDS 
2e2d			;		DMARK "FGu" 
2e2d			;		CALLMONITOR 
2e2d			;	endif 
2e2d			; 
2e2d			;		; found a uword but is it the one we want... 
2e2d			; 
2e2d			; 
2e2d			;	        pop de   ; get back the dsp name 
2e2d			;		push de 
2e2d			; 
2e2d			;		push hl  ; to save the ptr 
2e2d			; 
2e2d			;		; skip opcode 
2e2d			;		inc hl  
2e2d			;		; skip next ptr 
2e2d			;		inc hl  
2e2d			;		inc hl 
2e2d			;		; skip len 
2e2d			;		inc hl 
2e2d			; 
2e2d			;	if DEBUG_FORTH_WORDS 
2e2d			;		DMARK "FGc" 
2e2d			;		CALLMONITOR 
2e2d			;	endif 
2e2d			;		call strcmp 
2e2d			;		jp nz, .fnuword 
2e2d			 
2e2d			 
2e2d e1			pop hl 
2e2e			 
2e2e				 
2e2e				if DEBUG_FORTH_WORDS 
2e2e					DMARK "FGm" 
2e2e f5				push af  
2e2f 3a 43 2e			ld a, (.dmark)  
2e32 32 b4 fe			ld (debug_mark),a  
2e35 3a 44 2e			ld a, (.dmark+1)  
2e38 32 b5 fe			ld (debug_mark+1),a  
2e3b 3a 45 2e			ld a, (.dmark+2)  
2e3e 32 b6 fe			ld (debug_mark+2),a  
2e41 18 03			jr .pastdmark  
2e43 ..			.dmark: db "FGm"  
2e46 f1			.pastdmark: pop af  
2e47			endm  
# End of macro DMARK
2e47					CALLMONITOR 
2e47 cd c6 18			call break_point_state  
2e4a				endm  
# End of macro CALLMONITOR
2e4a				endif 
2e4a			 
2e4a			 
2e4a			 
2e4a					; we have a uword so push its name to the stack 
2e4a			 
2e4a			;	   	push hl  ; save so we can move to next dict block 
2e4a			;pop hl 
2e4a			 
2e4a					; update opcode to deleted 
2e4a 3e 03				ld a, WORD_SYS_DELETED 
2e4c 77					ld (hl), a 
2e4d			 
2e4d 23					inc hl  
2e4e					; skip next ptr 
2e4e 23					inc hl  
2e4f 23					inc hl 
2e50					; skip len 
2e50 23					inc hl 
2e51			 
2e51					; TODO change parser to skip deleted words but for now mark it out 
2e51 3e 5f				ld a, "_" 
2e53 77					ld  (hl),a 
2e54			 
2e54			;		jr .fudone 
2e54			; 
2e54			;.fnuword:	pop hl 
2e54			;		call forth_tok_next 
2e54			;		jp .fdouscan  
2e54			 
2e54			.flunotfound:		  
2e54			 
2e54			 
2e54					 
2e54					FORTH_DSP_POP 
2e54 cd e9 21			call macro_forth_dsp_pop 
2e57				endm 
# End of macro FORTH_DSP_POP
2e57			;		ld hl, .luno 
2e57			;.fudone:		 pop hl 
2e57					NEXTW 
2e57 c3 a8 22			jp macro_next 
2e5a				endm 
# End of macro NEXTW
2e5a			.NOP: 
2e5a				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2e5a 61				db WORD_SYS_CORE+77             
2e5b 81 2e			dw .COMO            
2e5d 04				db 3 + 1 
2e5e .. 00			db "NOP",0              
2e62				endm 
# End of macro CWHEAD
2e62			; | NOP (  --  ) Do nothing | DONE 
2e62					if DEBUG_FORTH_WORDS_KEY 
2e62						DMARK "NOP" 
2e62 f5				push af  
2e63 3a 77 2e			ld a, (.dmark)  
2e66 32 b4 fe			ld (debug_mark),a  
2e69 3a 78 2e			ld a, (.dmark+1)  
2e6c 32 b5 fe			ld (debug_mark+1),a  
2e6f 3a 79 2e			ld a, (.dmark+2)  
2e72 32 b6 fe			ld (debug_mark+2),a  
2e75 18 03			jr .pastdmark  
2e77 ..			.dmark: db "NOP"  
2e7a f1			.pastdmark: pop af  
2e7b			endm  
# End of macro DMARK
2e7b						CALLMONITOR 
2e7b cd c6 18			call break_point_state  
2e7e				endm  
# End of macro CALLMONITOR
2e7e					endif 
2e7e				       NEXTW 
2e7e c3 a8 22			jp macro_next 
2e81				endm 
# End of macro NEXTW
2e81			.COMO: 
2e81				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2e81 6e				db WORD_SYS_CORE+90             
2e82 d3 2e			dw .COMC            
2e84 02				db 1 + 1 
2e85 .. 00			db "(",0              
2e87				endm 
# End of macro CWHEAD
2e87			; | ( ( -- )  Start of comment | DONE 
2e87			 
2e87			 
2e87 2a 83 f6				ld hl, ( os_tok_ptr) 
2e8a 11 ce 2e			ld de, .closepar 
2e8d					 
2e8d					if DEBUG_FORTH_WORDS 
2e8d						DMARK ").." 
2e8d f5				push af  
2e8e 3a a2 2e			ld a, (.dmark)  
2e91 32 b4 fe			ld (debug_mark),a  
2e94 3a a3 2e			ld a, (.dmark+1)  
2e97 32 b5 fe			ld (debug_mark+1),a  
2e9a 3a a4 2e			ld a, (.dmark+2)  
2e9d 32 b6 fe			ld (debug_mark+2),a  
2ea0 18 03			jr .pastdmark  
2ea2 ..			.dmark: db ").."  
2ea5 f1			.pastdmark: pop af  
2ea6			endm  
# End of macro DMARK
2ea6						CALLMONITOR 
2ea6 cd c6 18			call break_point_state  
2ea9				endm  
# End of macro CALLMONITOR
2ea9					endif 
2ea9 cd c3 23			call findnexttok  
2eac			 
2eac					if DEBUG_FORTH_WORDS 
2eac						DMARK "IF5" 
2eac f5				push af  
2ead 3a c1 2e			ld a, (.dmark)  
2eb0 32 b4 fe			ld (debug_mark),a  
2eb3 3a c2 2e			ld a, (.dmark+1)  
2eb6 32 b5 fe			ld (debug_mark+1),a  
2eb9 3a c3 2e			ld a, (.dmark+2)  
2ebc 32 b6 fe			ld (debug_mark+2),a  
2ebf 18 03			jr .pastdmark  
2ec1 ..			.dmark: db "IF5"  
2ec4 f1			.pastdmark: pop af  
2ec5			endm  
# End of macro DMARK
2ec5						CALLMONITOR 
2ec5 cd c6 18			call break_point_state  
2ec8				endm  
# End of macro CALLMONITOR
2ec8					endif 
2ec8				; replace below with ) exec using tok_ptr 
2ec8 22 83 f6			ld (os_tok_ptr), hl 
2ecb c3 39 23			jp exec1 
2ece			 
2ece .. 00			.closepar:   db ")",0 
2ed0			 
2ed0				       NEXTW 
2ed0 c3 a8 22			jp macro_next 
2ed3				endm 
# End of macro NEXTW
2ed3			.COMC: 
2ed3				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2ed3 6f				db WORD_SYS_CORE+91             
2ed4 dc 2e			dw .SCRATCH            
2ed6 02				db 1 + 1 
2ed7 .. 00			db ")",0              
2ed9				endm 
# End of macro CWHEAD
2ed9			; | ) ( -- )  End of comment |  DONE  
2ed9				       NEXTW 
2ed9 c3 a8 22			jp macro_next 
2edc				endm 
# End of macro NEXTW
2edc			 
2edc			.SCRATCH: 
2edc				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2edc 6f				db WORD_SYS_CORE+91             
2edd 17 2f			dw .INC            
2edf 08				db 7 + 1 
2ee0 .. 00			db "SCRATCH",0              
2ee8				endm 
# End of macro CWHEAD
2ee8			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2ee8			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2ee8			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2ee8			; | |  
2ee8			; | | e.g.    : score $00 scratch ; 
2ee8			; | |  
2ee8			; | | $00 score ! 
2ee8			; | | $01 score +! 
2ee8			; | |  
2ee8			; | | e.g.   : varword $0a scratch ;  
2ee8			; | | 
2ee8			; | | $8000 varword ! 
2ee8					if DEBUG_FORTH_WORDS_KEY 
2ee8						DMARK "SCR" 
2ee8 f5				push af  
2ee9 3a fd 2e			ld a, (.dmark)  
2eec 32 b4 fe			ld (debug_mark),a  
2eef 3a fe 2e			ld a, (.dmark+1)  
2ef2 32 b5 fe			ld (debug_mark+1),a  
2ef5 3a ff 2e			ld a, (.dmark+2)  
2ef8 32 b6 fe			ld (debug_mark+2),a  
2efb 18 03			jr .pastdmark  
2efd ..			.dmark: db "SCR"  
2f00 f1			.pastdmark: pop af  
2f01			endm  
# End of macro DMARK
2f01						CALLMONITOR 
2f01 cd c6 18			call break_point_state  
2f04				endm  
# End of macro CALLMONITOR
2f04					endif 
2f04			 
2f04					FORTH_DSP_VALUEHL 
2f04 cd 31 21			call macro_dsp_valuehl 
2f07				endm 
# End of macro FORTH_DSP_VALUEHL
2f07				 
2f07					FORTH_DSP_POP 
2f07 cd e9 21			call macro_forth_dsp_pop 
2f0a				endm 
# End of macro FORTH_DSP_POP
2f0a			 
2f0a 7d					ld a, l 
2f0b 21 a7 f8				ld hl, os_var_array 
2f0e cd 49 0f				call addatohl 
2f11			 
2f11 cd 3a 1f				call forth_push_numhl 
2f14			 
2f14				       NEXTW 
2f14 c3 a8 22			jp macro_next 
2f17				endm 
# End of macro NEXTW
2f17			 
2f17			.INC: 
2f17				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2f17 6f				db WORD_SYS_CORE+91             
2f18 6b 2f			dw .DEC            
2f1a 03				db 2 + 1 
2f1b .. 00			db "+!",0              
2f1e				endm 
# End of macro CWHEAD
2f1e			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2f1e					if DEBUG_FORTH_WORDS_KEY 
2f1e						DMARK "+s_" 
2f1e f5				push af  
2f1f 3a 33 2f			ld a, (.dmark)  
2f22 32 b4 fe			ld (debug_mark),a  
2f25 3a 34 2f			ld a, (.dmark+1)  
2f28 32 b5 fe			ld (debug_mark+1),a  
2f2b 3a 35 2f			ld a, (.dmark+2)  
2f2e 32 b6 fe			ld (debug_mark+2),a  
2f31 18 03			jr .pastdmark  
2f33 ..			.dmark: db "+s_"  
2f36 f1			.pastdmark: pop af  
2f37			endm  
# End of macro DMARK
2f37						CALLMONITOR 
2f37 cd c6 18			call break_point_state  
2f3a				endm  
# End of macro CALLMONITOR
2f3a					endif 
2f3a			 
2f3a					FORTH_DSP_VALUEHL 
2f3a cd 31 21			call macro_dsp_valuehl 
2f3d				endm 
# End of macro FORTH_DSP_VALUEHL
2f3d			 
2f3d e5					push hl   ; save address 
2f3e			 
2f3e					FORTH_DSP_POP 
2f3e cd e9 21			call macro_forth_dsp_pop 
2f41				endm 
# End of macro FORTH_DSP_POP
2f41			 
2f41					FORTH_DSP_VALUEHL 
2f41 cd 31 21			call macro_dsp_valuehl 
2f44				endm 
# End of macro FORTH_DSP_VALUEHL
2f44			 
2f44					FORTH_DSP_POP 
2f44 cd e9 21			call macro_forth_dsp_pop 
2f47				endm 
# End of macro FORTH_DSP_POP
2f47			 
2f47					; hl contains value to add to byte at a 
2f47				 
2f47 eb					ex de, hl 
2f48			 
2f48 e1					pop hl 
2f49			 
2f49					if DEBUG_FORTH_WORDS 
2f49						DMARK "INC" 
2f49 f5				push af  
2f4a 3a 5e 2f			ld a, (.dmark)  
2f4d 32 b4 fe			ld (debug_mark),a  
2f50 3a 5f 2f			ld a, (.dmark+1)  
2f53 32 b5 fe			ld (debug_mark+1),a  
2f56 3a 60 2f			ld a, (.dmark+2)  
2f59 32 b6 fe			ld (debug_mark+2),a  
2f5c 18 03			jr .pastdmark  
2f5e ..			.dmark: db "INC"  
2f61 f1			.pastdmark: pop af  
2f62			endm  
# End of macro DMARK
2f62						CALLMONITOR 
2f62 cd c6 18			call break_point_state  
2f65				endm  
# End of macro CALLMONITOR
2f65					endif 
2f65			 
2f65 7e					ld a,(hl) 
2f66 83					add e 
2f67 77					ld (hl),a 
2f68			 
2f68			 
2f68			 
2f68				       NEXTW 
2f68 c3 a8 22			jp macro_next 
2f6b				endm 
# End of macro NEXTW
2f6b			 
2f6b			.DEC: 
2f6b				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2f6b 6f				db WORD_SYS_CORE+91             
2f6c bc 2f			dw .INC2            
2f6e 03				db 2 + 1 
2f6f .. 00			db "-!",0              
2f72				endm 
# End of macro CWHEAD
2f72			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2f72					if DEBUG_FORTH_WORDS_KEY 
2f72						DMARK "-s_" 
2f72 f5				push af  
2f73 3a 87 2f			ld a, (.dmark)  
2f76 32 b4 fe			ld (debug_mark),a  
2f79 3a 88 2f			ld a, (.dmark+1)  
2f7c 32 b5 fe			ld (debug_mark+1),a  
2f7f 3a 89 2f			ld a, (.dmark+2)  
2f82 32 b6 fe			ld (debug_mark+2),a  
2f85 18 03			jr .pastdmark  
2f87 ..			.dmark: db "-s_"  
2f8a f1			.pastdmark: pop af  
2f8b			endm  
# End of macro DMARK
2f8b						CALLMONITOR 
2f8b cd c6 18			call break_point_state  
2f8e				endm  
# End of macro CALLMONITOR
2f8e					endif 
2f8e			 
2f8e					FORTH_DSP_VALUEHL 
2f8e cd 31 21			call macro_dsp_valuehl 
2f91				endm 
# End of macro FORTH_DSP_VALUEHL
2f91			 
2f91 e5					push hl   ; save address 
2f92			 
2f92					FORTH_DSP_POP 
2f92 cd e9 21			call macro_forth_dsp_pop 
2f95				endm 
# End of macro FORTH_DSP_POP
2f95			 
2f95					FORTH_DSP_VALUEHL 
2f95 cd 31 21			call macro_dsp_valuehl 
2f98				endm 
# End of macro FORTH_DSP_VALUEHL
2f98			 
2f98					; hl contains value to add to byte at a 
2f98				 
2f98 eb					ex de, hl 
2f99			 
2f99 e1					pop hl 
2f9a			 
2f9a					if DEBUG_FORTH_WORDS 
2f9a						DMARK "DEC" 
2f9a f5				push af  
2f9b 3a af 2f			ld a, (.dmark)  
2f9e 32 b4 fe			ld (debug_mark),a  
2fa1 3a b0 2f			ld a, (.dmark+1)  
2fa4 32 b5 fe			ld (debug_mark+1),a  
2fa7 3a b1 2f			ld a, (.dmark+2)  
2faa 32 b6 fe			ld (debug_mark+2),a  
2fad 18 03			jr .pastdmark  
2faf ..			.dmark: db "DEC"  
2fb2 f1			.pastdmark: pop af  
2fb3			endm  
# End of macro DMARK
2fb3						CALLMONITOR 
2fb3 cd c6 18			call break_point_state  
2fb6				endm  
# End of macro CALLMONITOR
2fb6					endif 
2fb6			 
2fb6 7e					ld a,(hl) 
2fb7 93					sub e 
2fb8 77					ld (hl),a 
2fb9			 
2fb9			 
2fb9			 
2fb9				       NEXTW 
2fb9 c3 a8 22			jp macro_next 
2fbc				endm 
# End of macro NEXTW
2fbc			 
2fbc			.INC2: 
2fbc				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2fbc 6f				db WORD_SYS_CORE+91             
2fbd 66 30			dw .DEC2            
2fbf 04				db 3 + 1 
2fc0 .. 00			db "+2!",0              
2fc4				endm 
# End of macro CWHEAD
2fc4			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2fc4			 
2fc4					if DEBUG_FORTH_WORDS_KEY 
2fc4						DMARK "+2s" 
2fc4 f5				push af  
2fc5 3a d9 2f			ld a, (.dmark)  
2fc8 32 b4 fe			ld (debug_mark),a  
2fcb 3a da 2f			ld a, (.dmark+1)  
2fce 32 b5 fe			ld (debug_mark+1),a  
2fd1 3a db 2f			ld a, (.dmark+2)  
2fd4 32 b6 fe			ld (debug_mark+2),a  
2fd7 18 03			jr .pastdmark  
2fd9 ..			.dmark: db "+2s"  
2fdc f1			.pastdmark: pop af  
2fdd			endm  
# End of macro DMARK
2fdd						CALLMONITOR 
2fdd cd c6 18			call break_point_state  
2fe0				endm  
# End of macro CALLMONITOR
2fe0					endif 
2fe0			 
2fe0					; Address 
2fe0			 
2fe0					FORTH_DSP_VALUEHL 
2fe0 cd 31 21			call macro_dsp_valuehl 
2fe3				endm 
# End of macro FORTH_DSP_VALUEHL
2fe3			 
2fe3 e5					push hl    ; save address 
2fe4			 
2fe4					; load content into de 
2fe4			 
2fe4 5e					ld e,(hl) 
2fe5 23					inc hl 
2fe6 56					ld d, (hl) 
2fe7			 
2fe7					if DEBUG_FORTH_WORDS 
2fe7						DMARK "+2a" 
2fe7 f5				push af  
2fe8 3a fc 2f			ld a, (.dmark)  
2feb 32 b4 fe			ld (debug_mark),a  
2fee 3a fd 2f			ld a, (.dmark+1)  
2ff1 32 b5 fe			ld (debug_mark+1),a  
2ff4 3a fe 2f			ld a, (.dmark+2)  
2ff7 32 b6 fe			ld (debug_mark+2),a  
2ffa 18 03			jr .pastdmark  
2ffc ..			.dmark: db "+2a"  
2fff f1			.pastdmark: pop af  
3000			endm  
# End of macro DMARK
3000						CALLMONITOR 
3000 cd c6 18			call break_point_state  
3003				endm  
# End of macro CALLMONITOR
3003					endif 
3003			 
3003					FORTH_DSP_POP 
3003 cd e9 21			call macro_forth_dsp_pop 
3006				endm 
# End of macro FORTH_DSP_POP
3006			 
3006					; Get value to add 
3006			 
3006					FORTH_DSP_VALUE 
3006 cd 1a 21			call macro_forth_dsp_value 
3009				endm 
# End of macro FORTH_DSP_VALUE
3009			 
3009					if DEBUG_FORTH_WORDS 
3009						DMARK "+2v" 
3009 f5				push af  
300a 3a 1e 30			ld a, (.dmark)  
300d 32 b4 fe			ld (debug_mark),a  
3010 3a 1f 30			ld a, (.dmark+1)  
3013 32 b5 fe			ld (debug_mark+1),a  
3016 3a 20 30			ld a, (.dmark+2)  
3019 32 b6 fe			ld (debug_mark+2),a  
301c 18 03			jr .pastdmark  
301e ..			.dmark: db "+2v"  
3021 f1			.pastdmark: pop af  
3022			endm  
# End of macro DMARK
3022						CALLMONITOR 
3022 cd c6 18			call break_point_state  
3025				endm  
# End of macro CALLMONITOR
3025					endif 
3025			 
3025 19					add hl, de 
3026			 
3026					if DEBUG_FORTH_WORDS 
3026						DMARK "+2+" 
3026 f5				push af  
3027 3a 3b 30			ld a, (.dmark)  
302a 32 b4 fe			ld (debug_mark),a  
302d 3a 3c 30			ld a, (.dmark+1)  
3030 32 b5 fe			ld (debug_mark+1),a  
3033 3a 3d 30			ld a, (.dmark+2)  
3036 32 b6 fe			ld (debug_mark+2),a  
3039 18 03			jr .pastdmark  
303b ..			.dmark: db "+2+"  
303e f1			.pastdmark: pop af  
303f			endm  
# End of macro DMARK
303f						CALLMONITOR 
303f cd c6 18			call break_point_state  
3042				endm  
# End of macro CALLMONITOR
3042					endif 
3042			 
3042					; move result to de 
3042			 
3042 eb					ex de, hl 
3043			 
3043					; Address 
3043			 
3043 e1					pop hl 
3044			 
3044					; save it back 
3044			 
3044 73					ld (hl), e 
3045 23					inc hl 
3046 72					ld (hl), d 
3047			 
3047					if DEBUG_FORTH_WORDS 
3047						DMARK "+2e" 
3047 f5				push af  
3048 3a 5c 30			ld a, (.dmark)  
304b 32 b4 fe			ld (debug_mark),a  
304e 3a 5d 30			ld a, (.dmark+1)  
3051 32 b5 fe			ld (debug_mark+1),a  
3054 3a 5e 30			ld a, (.dmark+2)  
3057 32 b6 fe			ld (debug_mark+2),a  
305a 18 03			jr .pastdmark  
305c ..			.dmark: db "+2e"  
305f f1			.pastdmark: pop af  
3060			endm  
# End of macro DMARK
3060						CALLMONITOR 
3060 cd c6 18			call break_point_state  
3063				endm  
# End of macro CALLMONITOR
3063					endif 
3063			 
3063			 
3063			 
3063			 
3063			 
3063				       NEXTW 
3063 c3 a8 22			jp macro_next 
3066				endm 
# End of macro NEXTW
3066			 
3066			.DEC2: 
3066				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
3066 6f				db WORD_SYS_CORE+91             
3067 12 31			dw .GET2            
3069 04				db 3 + 1 
306a .. 00			db "-2!",0              
306e				endm 
# End of macro CWHEAD
306e			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
306e			 
306e			 
306e					if DEBUG_FORTH_WORDS_KEY 
306e						DMARK "-2s" 
306e f5				push af  
306f 3a 83 30			ld a, (.dmark)  
3072 32 b4 fe			ld (debug_mark),a  
3075 3a 84 30			ld a, (.dmark+1)  
3078 32 b5 fe			ld (debug_mark+1),a  
307b 3a 85 30			ld a, (.dmark+2)  
307e 32 b6 fe			ld (debug_mark+2),a  
3081 18 03			jr .pastdmark  
3083 ..			.dmark: db "-2s"  
3086 f1			.pastdmark: pop af  
3087			endm  
# End of macro DMARK
3087						CALLMONITOR 
3087 cd c6 18			call break_point_state  
308a				endm  
# End of macro CALLMONITOR
308a					endif 
308a			 
308a					; Address 
308a			 
308a					FORTH_DSP_VALUEHL 
308a cd 31 21			call macro_dsp_valuehl 
308d				endm 
# End of macro FORTH_DSP_VALUEHL
308d			 
308d e5					push hl    ; save address 
308e			 
308e					; load content into de 
308e			 
308e 5e					ld e,(hl) 
308f 23					inc hl 
3090 56					ld d, (hl) 
3091			 
3091					if DEBUG_FORTH_WORDS 
3091						DMARK "-2a" 
3091 f5				push af  
3092 3a a6 30			ld a, (.dmark)  
3095 32 b4 fe			ld (debug_mark),a  
3098 3a a7 30			ld a, (.dmark+1)  
309b 32 b5 fe			ld (debug_mark+1),a  
309e 3a a8 30			ld a, (.dmark+2)  
30a1 32 b6 fe			ld (debug_mark+2),a  
30a4 18 03			jr .pastdmark  
30a6 ..			.dmark: db "-2a"  
30a9 f1			.pastdmark: pop af  
30aa			endm  
# End of macro DMARK
30aa						CALLMONITOR 
30aa cd c6 18			call break_point_state  
30ad				endm  
# End of macro CALLMONITOR
30ad					endif 
30ad			 
30ad					FORTH_DSP_POP 
30ad cd e9 21			call macro_forth_dsp_pop 
30b0				endm 
# End of macro FORTH_DSP_POP
30b0			 
30b0					; Get value to remove 
30b0			 
30b0					FORTH_DSP_VALUE 
30b0 cd 1a 21			call macro_forth_dsp_value 
30b3				endm 
# End of macro FORTH_DSP_VALUE
30b3			 
30b3					if DEBUG_FORTH_WORDS 
30b3						DMARK "-2v" 
30b3 f5				push af  
30b4 3a c8 30			ld a, (.dmark)  
30b7 32 b4 fe			ld (debug_mark),a  
30ba 3a c9 30			ld a, (.dmark+1)  
30bd 32 b5 fe			ld (debug_mark+1),a  
30c0 3a ca 30			ld a, (.dmark+2)  
30c3 32 b6 fe			ld (debug_mark+2),a  
30c6 18 03			jr .pastdmark  
30c8 ..			.dmark: db "-2v"  
30cb f1			.pastdmark: pop af  
30cc			endm  
# End of macro DMARK
30cc						CALLMONITOR 
30cc cd c6 18			call break_point_state  
30cf				endm  
# End of macro CALLMONITOR
30cf					endif 
30cf			 
30cf eb					ex de, hl 
30d0 ed 52				sbc hl, de 
30d2			 
30d2					if DEBUG_FORTH_WORDS 
30d2						DMARK "-2d" 
30d2 f5				push af  
30d3 3a e7 30			ld a, (.dmark)  
30d6 32 b4 fe			ld (debug_mark),a  
30d9 3a e8 30			ld a, (.dmark+1)  
30dc 32 b5 fe			ld (debug_mark+1),a  
30df 3a e9 30			ld a, (.dmark+2)  
30e2 32 b6 fe			ld (debug_mark+2),a  
30e5 18 03			jr .pastdmark  
30e7 ..			.dmark: db "-2d"  
30ea f1			.pastdmark: pop af  
30eb			endm  
# End of macro DMARK
30eb						CALLMONITOR 
30eb cd c6 18			call break_point_state  
30ee				endm  
# End of macro CALLMONITOR
30ee					endif 
30ee			 
30ee					; move result to de 
30ee			 
30ee eb					ex de, hl 
30ef			 
30ef					; Address 
30ef			 
30ef e1					pop hl 
30f0			 
30f0					; save it back 
30f0			 
30f0 73					ld (hl), e 
30f1 23					inc hl 
30f2 72					ld (hl), d 
30f3			 
30f3					if DEBUG_FORTH_WORDS 
30f3						DMARK "-2e" 
30f3 f5				push af  
30f4 3a 08 31			ld a, (.dmark)  
30f7 32 b4 fe			ld (debug_mark),a  
30fa 3a 09 31			ld a, (.dmark+1)  
30fd 32 b5 fe			ld (debug_mark+1),a  
3100 3a 0a 31			ld a, (.dmark+2)  
3103 32 b6 fe			ld (debug_mark+2),a  
3106 18 03			jr .pastdmark  
3108 ..			.dmark: db "-2e"  
310b f1			.pastdmark: pop af  
310c			endm  
# End of macro DMARK
310c						CALLMONITOR 
310c cd c6 18			call break_point_state  
310f				endm  
# End of macro CALLMONITOR
310f					endif 
310f			 
310f			 
310f			 
310f			 
310f			 
310f				       NEXTW 
310f c3 a8 22			jp macro_next 
3112				endm 
# End of macro NEXTW
3112			.GET2: 
3112				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
3112 6f				db WORD_SYS_CORE+91             
3113 42 31			dw .BANG2            
3115 03				db 2 + 1 
3116 .. 00			db "2@",0              
3119				endm 
# End of macro CWHEAD
3119			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
3119					if DEBUG_FORTH_WORDS_KEY 
3119						DMARK "2A_" 
3119 f5				push af  
311a 3a 2e 31			ld a, (.dmark)  
311d 32 b4 fe			ld (debug_mark),a  
3120 3a 2f 31			ld a, (.dmark+1)  
3123 32 b5 fe			ld (debug_mark+1),a  
3126 3a 30 31			ld a, (.dmark+2)  
3129 32 b6 fe			ld (debug_mark+2),a  
312c 18 03			jr .pastdmark  
312e ..			.dmark: db "2A_"  
3131 f1			.pastdmark: pop af  
3132			endm  
# End of macro DMARK
3132						CALLMONITOR 
3132 cd c6 18			call break_point_state  
3135				endm  
# End of macro CALLMONITOR
3135					endif 
3135			 
3135					FORTH_DSP_VALUEHL 
3135 cd 31 21			call macro_dsp_valuehl 
3138				endm 
# End of macro FORTH_DSP_VALUEHL
3138			 
3138 5e					ld e, (hl) 
3139 23					inc hl 
313a 56					ld d, (hl) 
313b			 
313b eb					ex de, hl 
313c			 
313c cd 3a 1f				call forth_push_numhl 
313f			 
313f				       NEXTW 
313f c3 a8 22			jp macro_next 
3142				endm 
# End of macro NEXTW
3142			.BANG2: 
3142				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
3142 6f				db WORD_SYS_CORE+91             
3143 7a 31			dw .CONFIG            
3145 03				db 2 + 1 
3146 .. 00			db "2!",0              
3149				endm 
# End of macro CWHEAD
3149			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
3149					if DEBUG_FORTH_WORDS_KEY 
3149						DMARK "2S_" 
3149 f5				push af  
314a 3a 5e 31			ld a, (.dmark)  
314d 32 b4 fe			ld (debug_mark),a  
3150 3a 5f 31			ld a, (.dmark+1)  
3153 32 b5 fe			ld (debug_mark+1),a  
3156 3a 60 31			ld a, (.dmark+2)  
3159 32 b6 fe			ld (debug_mark+2),a  
315c 18 03			jr .pastdmark  
315e ..			.dmark: db "2S_"  
3161 f1			.pastdmark: pop af  
3162			endm  
# End of macro DMARK
3162						CALLMONITOR 
3162 cd c6 18			call break_point_state  
3165				endm  
# End of macro CALLMONITOR
3165					endif 
3165			 
3165					FORTH_DSP_VALUEHL 
3165 cd 31 21			call macro_dsp_valuehl 
3168				endm 
# End of macro FORTH_DSP_VALUEHL
3168			 
3168 e5					push hl   ; save address 
3169			 
3169			 
3169					FORTH_DSP_POP 
3169 cd e9 21			call macro_forth_dsp_pop 
316c				endm 
# End of macro FORTH_DSP_POP
316c			 
316c					 
316c					FORTH_DSP_VALUEHL 
316c cd 31 21			call macro_dsp_valuehl 
316f				endm 
# End of macro FORTH_DSP_VALUEHL
316f			 
316f					FORTH_DSP_POP 
316f cd e9 21			call macro_forth_dsp_pop 
3172				endm 
# End of macro FORTH_DSP_POP
3172			 
3172 eb					ex de, hl    ; value now in de 
3173			 
3173 e1					pop hl 
3174			 
3174 73					ld (hl), e 
3175			 
3175 23					inc hl 
3176			 
3176 72					ld (hl), d 
3177			 
3177			 
3177				       NEXTW 
3177 c3 a8 22			jp macro_next 
317a				endm 
# End of macro NEXTW
317a			.CONFIG: 
317a				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
317a 6f				db WORD_SYS_CORE+91             
317b 8b 31			dw .ENDCORE            
317d 07				db 6 + 1 
317e .. 00			db "CONFIG",0              
3185				endm 
# End of macro CWHEAD
3185			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
3185			 
3185 cd a9 15				call config 
3188					NEXTW 
3188 c3 a8 22			jp macro_next 
318b				endm 
# End of macro NEXTW
318b			.ENDCORE: 
318b			 
318b			; eof 
318b			 
318b			 
# End of file forth_words_core.asm
318b			include "forth_words_flow.asm" 
318b			 
318b			; | ## Program Flow Words 
318b			 
318b			.IF: 
318b				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
318b 1e				db WORD_SYS_CORE+10             
318c 80 32			dw .THEN            
318e 03				db 2 + 1 
318f .. 00			db "IF",0              
3192				endm 
# End of macro CWHEAD
3192			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
3192			; 
3192					if DEBUG_FORTH_WORDS_KEY 
3192						DMARK "IF." 
3192 f5				push af  
3193 3a a7 31			ld a, (.dmark)  
3196 32 b4 fe			ld (debug_mark),a  
3199 3a a8 31			ld a, (.dmark+1)  
319c 32 b5 fe			ld (debug_mark+1),a  
319f 3a a9 31			ld a, (.dmark+2)  
31a2 32 b6 fe			ld (debug_mark+2),a  
31a5 18 03			jr .pastdmark  
31a7 ..			.dmark: db "IF."  
31aa f1			.pastdmark: pop af  
31ab			endm  
# End of macro DMARK
31ab						CALLMONITOR 
31ab cd c6 18			call break_point_state  
31ae				endm  
# End of macro CALLMONITOR
31ae					endif 
31ae			; eval TOS 
31ae			 
31ae				FORTH_DSP_VALUEHL 
31ae cd 31 21			call macro_dsp_valuehl 
31b1				endm 
# End of macro FORTH_DSP_VALUEHL
31b1			 
31b1			;	push hl 
31b1				FORTH_DSP_POP 
31b1 cd e9 21			call macro_forth_dsp_pop 
31b4				endm 
# End of macro FORTH_DSP_POP
31b4			;	pop hl 
31b4			 
31b4					if DEBUG_FORTH_WORDS 
31b4						DMARK "IF1" 
31b4 f5				push af  
31b5 3a c9 31			ld a, (.dmark)  
31b8 32 b4 fe			ld (debug_mark),a  
31bb 3a ca 31			ld a, (.dmark+1)  
31be 32 b5 fe			ld (debug_mark+1),a  
31c1 3a cb 31			ld a, (.dmark+2)  
31c4 32 b6 fe			ld (debug_mark+2),a  
31c7 18 03			jr .pastdmark  
31c9 ..			.dmark: db "IF1"  
31cc f1			.pastdmark: pop af  
31cd			endm  
# End of macro DMARK
31cd						CALLMONITOR 
31cd cd c6 18			call break_point_state  
31d0				endm  
# End of macro CALLMONITOR
31d0					endif 
31d0 b7				or a        ; clear carry flag 
31d1 11 00 00			ld de, 0 
31d4 eb				ex de,hl 
31d5 ed 52			sbc hl, de 
31d7 c2 61 32			jp nz, .iftrue 
31da			 
31da					if DEBUG_FORTH_WORDS 
31da						DMARK "IF2" 
31da f5				push af  
31db 3a ef 31			ld a, (.dmark)  
31de 32 b4 fe			ld (debug_mark),a  
31e1 3a f0 31			ld a, (.dmark+1)  
31e4 32 b5 fe			ld (debug_mark+1),a  
31e7 3a f1 31			ld a, (.dmark+2)  
31ea 32 b6 fe			ld (debug_mark+2),a  
31ed 18 03			jr .pastdmark  
31ef ..			.dmark: db "IF2"  
31f2 f1			.pastdmark: pop af  
31f3			endm  
# End of macro DMARK
31f3						CALLMONITOR 
31f3 cd c6 18			call break_point_state  
31f6				endm  
# End of macro CALLMONITOR
31f6					endif 
31f6			 
31f6			; if not true then skip to THEN 
31f6			 
31f6				; TODO get tok_ptr 
31f6				; TODO consume toks until we get to THEN 
31f6			 
31f6 2a 83 f6			ld hl, (os_tok_ptr) 
31f9					if DEBUG_FORTH_WORDS 
31f9						DMARK "IF3" 
31f9 f5				push af  
31fa 3a 0e 32			ld a, (.dmark)  
31fd 32 b4 fe			ld (debug_mark),a  
3200 3a 0f 32			ld a, (.dmark+1)  
3203 32 b5 fe			ld (debug_mark+1),a  
3206 3a 10 32			ld a, (.dmark+2)  
3209 32 b6 fe			ld (debug_mark+2),a  
320c 18 03			jr .pastdmark  
320e ..			.dmark: db "IF3"  
3211 f1			.pastdmark: pop af  
3212			endm  
# End of macro DMARK
3212						CALLMONITOR 
3212 cd c6 18			call break_point_state  
3215				endm  
# End of macro CALLMONITOR
3215						 
3215					endif 
3215 11 5c 32			ld de, .ifthen 
3218					if DEBUG_FORTH_WORDS 
3218						DMARK "IF4" 
3218 f5				push af  
3219 3a 2d 32			ld a, (.dmark)  
321c 32 b4 fe			ld (debug_mark),a  
321f 3a 2e 32			ld a, (.dmark+1)  
3222 32 b5 fe			ld (debug_mark+1),a  
3225 3a 2f 32			ld a, (.dmark+2)  
3228 32 b6 fe			ld (debug_mark+2),a  
322b 18 03			jr .pastdmark  
322d ..			.dmark: db "IF4"  
3230 f1			.pastdmark: pop af  
3231			endm  
# End of macro DMARK
3231						CALLMONITOR 
3231 cd c6 18			call break_point_state  
3234				endm  
# End of macro CALLMONITOR
3234					endif 
3234 cd c3 23			call findnexttok  
3237			 
3237					if DEBUG_FORTH_WORDS 
3237						DMARK "IF5" 
3237 f5				push af  
3238 3a 4c 32			ld a, (.dmark)  
323b 32 b4 fe			ld (debug_mark),a  
323e 3a 4d 32			ld a, (.dmark+1)  
3241 32 b5 fe			ld (debug_mark+1),a  
3244 3a 4e 32			ld a, (.dmark+2)  
3247 32 b6 fe			ld (debug_mark+2),a  
324a 18 03			jr .pastdmark  
324c ..			.dmark: db "IF5"  
324f f1			.pastdmark: pop af  
3250			endm  
# End of macro DMARK
3250						CALLMONITOR 
3250 cd c6 18			call break_point_state  
3253				endm  
# End of macro CALLMONITOR
3253					endif 
3253				; TODO replace below with ; exec using tok_ptr 
3253 22 83 f6			ld (os_tok_ptr), hl 
3256 c3 39 23			jp exec1 
3259				NEXTW 
3259 c3 a8 22			jp macro_next 
325c				endm 
# End of macro NEXTW
325c			 
325c .. 00		.ifthen:  db "THEN",0 
3261			 
3261			.iftrue:		 
3261				; Exec next words normally 
3261			 
3261				; if true then exec following IF as normal 
3261					if DEBUG_FORTH_WORDS 
3261						DMARK "IFT" 
3261 f5				push af  
3262 3a 76 32			ld a, (.dmark)  
3265 32 b4 fe			ld (debug_mark),a  
3268 3a 77 32			ld a, (.dmark+1)  
326b 32 b5 fe			ld (debug_mark+1),a  
326e 3a 78 32			ld a, (.dmark+2)  
3271 32 b6 fe			ld (debug_mark+2),a  
3274 18 03			jr .pastdmark  
3276 ..			.dmark: db "IFT"  
3279 f1			.pastdmark: pop af  
327a			endm  
# End of macro DMARK
327a						CALLMONITOR 
327a cd c6 18			call break_point_state  
327d				endm  
# End of macro CALLMONITOR
327d					endif 
327d			 
327d					NEXTW 
327d c3 a8 22			jp macro_next 
3280				endm 
# End of macro NEXTW
3280			.THEN: 
3280				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
3280 1f				db WORD_SYS_CORE+11             
3281 a8 32			dw .ELSE            
3283 05				db 4 + 1 
3284 .. 00			db "THEN",0              
3289				endm 
# End of macro CWHEAD
3289			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
3289					if DEBUG_FORTH_WORDS_KEY 
3289						DMARK "THN" 
3289 f5				push af  
328a 3a 9e 32			ld a, (.dmark)  
328d 32 b4 fe			ld (debug_mark),a  
3290 3a 9f 32			ld a, (.dmark+1)  
3293 32 b5 fe			ld (debug_mark+1),a  
3296 3a a0 32			ld a, (.dmark+2)  
3299 32 b6 fe			ld (debug_mark+2),a  
329c 18 03			jr .pastdmark  
329e ..			.dmark: db "THN"  
32a1 f1			.pastdmark: pop af  
32a2			endm  
# End of macro DMARK
32a2						CALLMONITOR 
32a2 cd c6 18			call break_point_state  
32a5				endm  
# End of macro CALLMONITOR
32a5					endif 
32a5					NEXTW 
32a5 c3 a8 22			jp macro_next 
32a8				endm 
# End of macro NEXTW
32a8			.ELSE: 
32a8				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
32a8 20				db WORD_SYS_CORE+12             
32a9 d0 32			dw .DO            
32ab 03				db 2 + 1 
32ac .. 00			db "ELSE",0              
32b1				endm 
# End of macro CWHEAD
32b1			; | ELSE ( -- ) Not supported - does nothing | TODO 
32b1			 
32b1					if DEBUG_FORTH_WORDS_KEY 
32b1						DMARK "ELS" 
32b1 f5				push af  
32b2 3a c6 32			ld a, (.dmark)  
32b5 32 b4 fe			ld (debug_mark),a  
32b8 3a c7 32			ld a, (.dmark+1)  
32bb 32 b5 fe			ld (debug_mark+1),a  
32be 3a c8 32			ld a, (.dmark+2)  
32c1 32 b6 fe			ld (debug_mark+2),a  
32c4 18 03			jr .pastdmark  
32c6 ..			.dmark: db "ELS"  
32c9 f1			.pastdmark: pop af  
32ca			endm  
# End of macro DMARK
32ca						CALLMONITOR 
32ca cd c6 18			call break_point_state  
32cd				endm  
# End of macro CALLMONITOR
32cd					endif 
32cd			 
32cd			 
32cd					NEXTW 
32cd c3 a8 22			jp macro_next 
32d0				endm 
# End of macro NEXTW
32d0			.DO: 
32d0				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
32d0 21				db WORD_SYS_CORE+13             
32d1 f7 33			dw .LOOP            
32d3 03				db 2 + 1 
32d4 .. 00			db "DO",0              
32d7				endm 
# End of macro CWHEAD
32d7			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
32d7			 
32d7					if DEBUG_FORTH_WORDS_KEY 
32d7						DMARK "DO." 
32d7 f5				push af  
32d8 3a ec 32			ld a, (.dmark)  
32db 32 b4 fe			ld (debug_mark),a  
32de 3a ed 32			ld a, (.dmark+1)  
32e1 32 b5 fe			ld (debug_mark+1),a  
32e4 3a ee 32			ld a, (.dmark+2)  
32e7 32 b6 fe			ld (debug_mark+2),a  
32ea 18 03			jr .pastdmark  
32ec ..			.dmark: db "DO."  
32ef f1			.pastdmark: pop af  
32f0			endm  
# End of macro DMARK
32f0						CALLMONITOR 
32f0 cd c6 18			call break_point_state  
32f3				endm  
# End of macro CALLMONITOR
32f3					endif 
32f3			;  push pc to rsp stack past the DO 
32f3			 
32f3 2a 83 f6				ld hl, (os_tok_ptr) 
32f6 23					inc hl   ; D 
32f7 23					inc hl  ; O 
32f8 23					inc hl   ; null 
32f9					if DEBUG_FORTH_WORDS 
32f9						DMARK "DO2" 
32f9 f5				push af  
32fa 3a 0e 33			ld a, (.dmark)  
32fd 32 b4 fe			ld (debug_mark),a  
3300 3a 0f 33			ld a, (.dmark+1)  
3303 32 b5 fe			ld (debug_mark+1),a  
3306 3a 10 33			ld a, (.dmark+2)  
3309 32 b6 fe			ld (debug_mark+2),a  
330c 18 03			jr .pastdmark  
330e ..			.dmark: db "DO2"  
3311 f1			.pastdmark: pop af  
3312			endm  
# End of macro DMARK
3312						CALLMONITOR 
3312 cd c6 18			call break_point_state  
3315				endm  
# End of macro CALLMONITOR
3315					endif 
3315					FORTH_RSP_NEXT 
3315 cd e1 1e			call macro_forth_rsp_next 
3318				endm 
# End of macro FORTH_RSP_NEXT
3318					if DEBUG_FORTH_WORDS 
3318						DMARK "DO3" 
3318 f5				push af  
3319 3a 2d 33			ld a, (.dmark)  
331c 32 b4 fe			ld (debug_mark),a  
331f 3a 2e 33			ld a, (.dmark+1)  
3322 32 b5 fe			ld (debug_mark+1),a  
3325 3a 2f 33			ld a, (.dmark+2)  
3328 32 b6 fe			ld (debug_mark+2),a  
332b 18 03			jr .pastdmark  
332d ..			.dmark: db "DO3"  
3330 f1			.pastdmark: pop af  
3331			endm  
# End of macro DMARK
3331						CALLMONITOR 
3331 cd c6 18			call break_point_state  
3334				endm  
# End of macro CALLMONITOR
3334					endif 
3334			 
3334					;if DEBUG_FORTH_WORDS 
3334				;		push hl 
3334			;		endif  
3334			 
3334			; get counters from data stack 
3334			 
3334			 
3334					FORTH_DSP_VALUEHL 
3334 cd 31 21			call macro_dsp_valuehl 
3337				endm 
# End of macro FORTH_DSP_VALUEHL
3337 e5					push hl		 ; hl now has starting counter which needs to be tos 
3338			 
3338					if DEBUG_FORTH_WORDS 
3338						DMARK "DO4" 
3338 f5				push af  
3339 3a 4d 33			ld a, (.dmark)  
333c 32 b4 fe			ld (debug_mark),a  
333f 3a 4e 33			ld a, (.dmark+1)  
3342 32 b5 fe			ld (debug_mark+1),a  
3345 3a 4f 33			ld a, (.dmark+2)  
3348 32 b6 fe			ld (debug_mark+2),a  
334b 18 03			jr .pastdmark  
334d ..			.dmark: db "DO4"  
3350 f1			.pastdmark: pop af  
3351			endm  
# End of macro DMARK
3351						CALLMONITOR 
3351 cd c6 18			call break_point_state  
3354				endm  
# End of macro CALLMONITOR
3354					endif 
3354					FORTH_DSP_POP 
3354 cd e9 21			call macro_forth_dsp_pop 
3357				endm 
# End of macro FORTH_DSP_POP
3357			 
3357					if DEBUG_FORTH_WORDS 
3357						DMARK "DO5" 
3357 f5				push af  
3358 3a 6c 33			ld a, (.dmark)  
335b 32 b4 fe			ld (debug_mark),a  
335e 3a 6d 33			ld a, (.dmark+1)  
3361 32 b5 fe			ld (debug_mark+1),a  
3364 3a 6e 33			ld a, (.dmark+2)  
3367 32 b6 fe			ld (debug_mark+2),a  
336a 18 03			jr .pastdmark  
336c ..			.dmark: db "DO5"  
336f f1			.pastdmark: pop af  
3370			endm  
# End of macro DMARK
3370						CALLMONITOR 
3370 cd c6 18			call break_point_state  
3373				endm  
# End of macro CALLMONITOR
3373					endif 
3373			 
3373					FORTH_DSP_VALUEHL 
3373 cd 31 21			call macro_dsp_valuehl 
3376				endm 
# End of macro FORTH_DSP_VALUEHL
3376			;		push hl		 ; hl now has starting limit counter 
3376			 
3376					if DEBUG_FORTH_WORDS 
3376						DMARK "DO6" 
3376 f5				push af  
3377 3a 8b 33			ld a, (.dmark)  
337a 32 b4 fe			ld (debug_mark),a  
337d 3a 8c 33			ld a, (.dmark+1)  
3380 32 b5 fe			ld (debug_mark+1),a  
3383 3a 8d 33			ld a, (.dmark+2)  
3386 32 b6 fe			ld (debug_mark+2),a  
3389 18 03			jr .pastdmark  
338b ..			.dmark: db "DO6"  
338e f1			.pastdmark: pop af  
338f			endm  
# End of macro DMARK
338f						CALLMONITOR 
338f cd c6 18			call break_point_state  
3392				endm  
# End of macro CALLMONITOR
3392					endif 
3392					FORTH_DSP_POP 
3392 cd e9 21			call macro_forth_dsp_pop 
3395				endm 
# End of macro FORTH_DSP_POP
3395			 
3395			; put counters on the loop stack 
3395			 
3395			;		pop hl			 ; limit counter 
3395 d1					pop de			; start counter 
3396			 
3396					; push limit counter 
3396			 
3396					if DEBUG_FORTH_WORDS 
3396						DMARK "DO7" 
3396 f5				push af  
3397 3a ab 33			ld a, (.dmark)  
339a 32 b4 fe			ld (debug_mark),a  
339d 3a ac 33			ld a, (.dmark+1)  
33a0 32 b5 fe			ld (debug_mark+1),a  
33a3 3a ad 33			ld a, (.dmark+2)  
33a6 32 b6 fe			ld (debug_mark+2),a  
33a9 18 03			jr .pastdmark  
33ab ..			.dmark: db "DO7"  
33ae f1			.pastdmark: pop af  
33af			endm  
# End of macro DMARK
33af						CALLMONITOR 
33af cd c6 18			call break_point_state  
33b2				endm  
# End of macro CALLMONITOR
33b2					endif 
33b2					FORTH_LOOP_NEXT 
33b2 cd 62 21			call macro_forth_loop_next 
33b5				endm 
# End of macro FORTH_LOOP_NEXT
33b5			 
33b5					; push start counter 
33b5			 
33b5 eb					ex de, hl 
33b6					if DEBUG_FORTH_WORDS 
33b6						DMARK "DO7" 
33b6 f5				push af  
33b7 3a cb 33			ld a, (.dmark)  
33ba 32 b4 fe			ld (debug_mark),a  
33bd 3a cc 33			ld a, (.dmark+1)  
33c0 32 b5 fe			ld (debug_mark+1),a  
33c3 3a cd 33			ld a, (.dmark+2)  
33c6 32 b6 fe			ld (debug_mark+2),a  
33c9 18 03			jr .pastdmark  
33cb ..			.dmark: db "DO7"  
33ce f1			.pastdmark: pop af  
33cf			endm  
# End of macro DMARK
33cf						CALLMONITOR 
33cf cd c6 18			call break_point_state  
33d2				endm  
# End of macro CALLMONITOR
33d2					endif 
33d2					FORTH_LOOP_NEXT 
33d2 cd 62 21			call macro_forth_loop_next 
33d5				endm 
# End of macro FORTH_LOOP_NEXT
33d5			 
33d5			 
33d5					; init first round of I counter 
33d5			 
33d5 22 a7 f6				ld (os_current_i), hl 
33d8			 
33d8					if DEBUG_FORTH_WORDS 
33d8						DMARK "DO8" 
33d8 f5				push af  
33d9 3a ed 33			ld a, (.dmark)  
33dc 32 b4 fe			ld (debug_mark),a  
33df 3a ee 33			ld a, (.dmark+1)  
33e2 32 b5 fe			ld (debug_mark+1),a  
33e5 3a ef 33			ld a, (.dmark+2)  
33e8 32 b6 fe			ld (debug_mark+2),a  
33eb 18 03			jr .pastdmark  
33ed ..			.dmark: db "DO8"  
33f0 f1			.pastdmark: pop af  
33f1			endm  
# End of macro DMARK
33f1						CALLMONITOR 
33f1 cd c6 18			call break_point_state  
33f4				endm  
# End of macro CALLMONITOR
33f4					endif 
33f4			 
33f4					NEXTW 
33f4 c3 a8 22			jp macro_next 
33f7				endm 
# End of macro NEXTW
33f7			.LOOP: 
33f7				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
33f7 22				db WORD_SYS_CORE+14             
33f8 0f 35			dw .I            
33fa 05				db 4 + 1 
33fb .. 00			db "LOOP",0              
3400				endm 
# End of macro CWHEAD
3400			; | LOOP ( -- ) Increment and test loop counter  | DONE 
3400			 
3400				; pop tos as current loop count to hl 
3400			 
3400				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3400			 
3400				FORTH_LOOP_TOS 
3400 cd 95 21			call macro_forth_loop_tos 
3403				endm 
# End of macro FORTH_LOOP_TOS
3403 e5				push hl 
3404			 
3404					if DEBUG_FORTH_WORDS_KEY 
3404						DMARK "LOP" 
3404 f5				push af  
3405 3a 19 34			ld a, (.dmark)  
3408 32 b4 fe			ld (debug_mark),a  
340b 3a 1a 34			ld a, (.dmark+1)  
340e 32 b5 fe			ld (debug_mark+1),a  
3411 3a 1b 34			ld a, (.dmark+2)  
3414 32 b6 fe			ld (debug_mark+2),a  
3417 18 03			jr .pastdmark  
3419 ..			.dmark: db "LOP"  
341c f1			.pastdmark: pop af  
341d			endm  
# End of macro DMARK
341d						CALLMONITOR 
341d cd c6 18			call break_point_state  
3420				endm  
# End of macro CALLMONITOR
3420					endif 
3420				; next item on the stack is the limit. get it 
3420			 
3420			 
3420				FORTH_LOOP_POP 
3420 cd 9f 21			call macro_forth_loop_pop 
3423				endm 
# End of macro FORTH_LOOP_POP
3423			 
3423				FORTH_LOOP_TOS 
3423 cd 95 21			call macro_forth_loop_tos 
3426				endm 
# End of macro FORTH_LOOP_TOS
3426			 
3426 d1				pop de		 ; de = i, hl = limit 
3427			 
3427					if DEBUG_FORTH_WORDS 
3427						DMARK "LP1" 
3427 f5				push af  
3428 3a 3c 34			ld a, (.dmark)  
342b 32 b4 fe			ld (debug_mark),a  
342e 3a 3d 34			ld a, (.dmark+1)  
3431 32 b5 fe			ld (debug_mark+1),a  
3434 3a 3e 34			ld a, (.dmark+2)  
3437 32 b6 fe			ld (debug_mark+2),a  
343a 18 03			jr .pastdmark  
343c ..			.dmark: db "LP1"  
343f f1			.pastdmark: pop af  
3440			endm  
# End of macro DMARK
3440						CALLMONITOR 
3440 cd c6 18			call break_point_state  
3443				endm  
# End of macro CALLMONITOR
3443					endif 
3443			 
3443				; go back to previous word 
3443			 
3443 d5				push de    ; save I for inc later 
3444			 
3444			 
3444				; get limit 
3444				;  is I at limit? 
3444			 
3444			 
3444					if DEBUG_FORTH_WORDS 
3444						DMARK "LP1" 
3444 f5				push af  
3445 3a 59 34			ld a, (.dmark)  
3448 32 b4 fe			ld (debug_mark),a  
344b 3a 5a 34			ld a, (.dmark+1)  
344e 32 b5 fe			ld (debug_mark+1),a  
3451 3a 5b 34			ld a, (.dmark+2)  
3454 32 b6 fe			ld (debug_mark+2),a  
3457 18 03			jr .pastdmark  
3459 ..			.dmark: db "LP1"  
345c f1			.pastdmark: pop af  
345d			endm  
# End of macro DMARK
345d						CALLMONITOR 
345d cd c6 18			call break_point_state  
3460				endm  
# End of macro CALLMONITOR
3460					endif 
3460			 
3460 ed 52			sbc hl, de 
3462			 
3462			 
3462				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3462			 
3462 20 26				jr nz, .loopnotdone 
3464			 
3464 e1				pop hl   ; get rid of saved I 
3465				FORTH_LOOP_POP     ; get rid of limit 
3465 cd 9f 21			call macro_forth_loop_pop 
3468				endm 
# End of macro FORTH_LOOP_POP
3468			 
3468				FORTH_RSP_POP     ; get rid of DO ptr 
3468 cd 02 1f			call macro_forth_rsp_pop 
346b				endm 
# End of macro FORTH_RSP_POP
346b			 
346b			if DEBUG_FORTH_WORDS 
346b						DMARK "LP>" 
346b f5				push af  
346c 3a 80 34			ld a, (.dmark)  
346f 32 b4 fe			ld (debug_mark),a  
3472 3a 81 34			ld a, (.dmark+1)  
3475 32 b5 fe			ld (debug_mark+1),a  
3478 3a 82 34			ld a, (.dmark+2)  
347b 32 b6 fe			ld (debug_mark+2),a  
347e 18 03			jr .pastdmark  
3480 ..			.dmark: db "LP>"  
3483 f1			.pastdmark: pop af  
3484			endm  
# End of macro DMARK
3484				CALLMONITOR 
3484 cd c6 18			call break_point_state  
3487				endm  
# End of macro CALLMONITOR
3487			endif 
3487			 
3487					NEXTW 
3487 c3 a8 22			jp macro_next 
348a				endm 
# End of macro NEXTW
348a				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
348a			 
348a			.loopnotdone: 
348a			 
348a e1				pop hl    ; get I 
348b 23				inc hl 
348c			 
348c			   	; save new I 
348c			 
348c			 
348c					; set I counter 
348c			 
348c 22 a7 f6				ld (os_current_i), hl 
348f			 
348f					if DEBUG_FORTH_WORDS 
348f						DMARK "LPN" 
348f f5				push af  
3490 3a a4 34			ld a, (.dmark)  
3493 32 b4 fe			ld (debug_mark),a  
3496 3a a5 34			ld a, (.dmark+1)  
3499 32 b5 fe			ld (debug_mark+1),a  
349c 3a a6 34			ld a, (.dmark+2)  
349f 32 b6 fe			ld (debug_mark+2),a  
34a2 18 03			jr .pastdmark  
34a4 ..			.dmark: db "LPN"  
34a7 f1			.pastdmark: pop af  
34a8			endm  
# End of macro DMARK
34a8					CALLMONITOR 
34a8 cd c6 18			call break_point_state  
34ab				endm  
# End of macro CALLMONITOR
34ab					endif 
34ab					 
34ab				FORTH_LOOP_NEXT 
34ab cd 62 21			call macro_forth_loop_next 
34ae				endm 
# End of macro FORTH_LOOP_NEXT
34ae			 
34ae			 
34ae					if DEBUG_FORTH_WORDS 
34ae eb						ex de,hl 
34af					endif 
34af			 
34af			;	; get DO ptr 
34af			; 
34af					if DEBUG_FORTH_WORDS 
34af						DMARK "LP7" 
34af f5				push af  
34b0 3a c4 34			ld a, (.dmark)  
34b3 32 b4 fe			ld (debug_mark),a  
34b6 3a c5 34			ld a, (.dmark+1)  
34b9 32 b5 fe			ld (debug_mark+1),a  
34bc 3a c6 34			ld a, (.dmark+2)  
34bf 32 b6 fe			ld (debug_mark+2),a  
34c2 18 03			jr .pastdmark  
34c4 ..			.dmark: db "LP7"  
34c7 f1			.pastdmark: pop af  
34c8			endm  
# End of macro DMARK
34c8					CALLMONITOR 
34c8 cd c6 18			call break_point_state  
34cb				endm  
# End of macro CALLMONITOR
34cb					endif 
34cb				FORTH_RSP_TOS 
34cb cd f8 1e			call macro_forth_rsp_tos 
34ce				endm 
# End of macro FORTH_RSP_TOS
34ce			 
34ce					if DEBUG_FORTH_WORDS 
34ce						DMARK "LP8" 
34ce f5				push af  
34cf 3a e3 34			ld a, (.dmark)  
34d2 32 b4 fe			ld (debug_mark),a  
34d5 3a e4 34			ld a, (.dmark+1)  
34d8 32 b5 fe			ld (debug_mark+1),a  
34db 3a e5 34			ld a, (.dmark+2)  
34de 32 b6 fe			ld (debug_mark+2),a  
34e1 18 03			jr .pastdmark  
34e3 ..			.dmark: db "LP8"  
34e6 f1			.pastdmark: pop af  
34e7			endm  
# End of macro DMARK
34e7					CALLMONITOR 
34e7 cd c6 18			call break_point_state  
34ea				endm  
# End of macro CALLMONITOR
34ea					endif 
34ea				;push hl 
34ea			 
34ea				; not going to DO any more 
34ea				; get rid of the RSP pointer as DO will add it back in 
34ea				;FORTH_RSP_POP 
34ea				;pop hl 
34ea			 
34ea				;ld hl,(cli_ret_sp) 
34ea				;ld e, (hl) 
34ea				;inc hl 
34ea				;ld d, (hl) 
34ea				;ex de,hl 
34ea 22 83 f6			ld (os_tok_ptr), hl 
34ed					if DEBUG_FORTH_WORDS 
34ed						DMARK "LP<" 
34ed f5				push af  
34ee 3a 02 35			ld a, (.dmark)  
34f1 32 b4 fe			ld (debug_mark),a  
34f4 3a 03 35			ld a, (.dmark+1)  
34f7 32 b5 fe			ld (debug_mark+1),a  
34fa 3a 04 35			ld a, (.dmark+2)  
34fd 32 b6 fe			ld (debug_mark+2),a  
3500 18 03			jr .pastdmark  
3502 ..			.dmark: db "LP<"  
3505 f1			.pastdmark: pop af  
3506			endm  
# End of macro DMARK
3506					CALLMONITOR 
3506 cd c6 18			call break_point_state  
3509				endm  
# End of macro CALLMONITOR
3509				endif 
3509 c3 39 23			jp exec1 
350c			 
350c					 
350c			 
350c			 
350c					NEXTW 
350c c3 a8 22			jp macro_next 
350f				endm 
# End of macro NEXTW
350f			.I:  
350f			 
350f				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
350f 5e				db WORD_SYS_CORE+74             
3510 3a 35			dw .DLOOP            
3512 02				db 1 + 1 
3513 .. 00			db "I",0              
3515				endm 
# End of macro CWHEAD
3515			; | I ( -- ) Current loop counter | DONE 
3515					if DEBUG_FORTH_WORDS_KEY 
3515						DMARK "I.." 
3515 f5				push af  
3516 3a 2a 35			ld a, (.dmark)  
3519 32 b4 fe			ld (debug_mark),a  
351c 3a 2b 35			ld a, (.dmark+1)  
351f 32 b5 fe			ld (debug_mark+1),a  
3522 3a 2c 35			ld a, (.dmark+2)  
3525 32 b6 fe			ld (debug_mark+2),a  
3528 18 03			jr .pastdmark  
352a ..			.dmark: db "I.."  
352d f1			.pastdmark: pop af  
352e			endm  
# End of macro DMARK
352e						CALLMONITOR 
352e cd c6 18			call break_point_state  
3531				endm  
# End of macro CALLMONITOR
3531					endif 
3531			 
3531 2a a7 f6				ld hl,(os_current_i) 
3534 cd 3a 1f				call forth_push_numhl 
3537			 
3537					NEXTW 
3537 c3 a8 22			jp macro_next 
353a				endm 
# End of macro NEXTW
353a			.DLOOP: 
353a				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
353a 5f				db WORD_SYS_CORE+75             
353b 1b 36			dw .REPEAT            
353d 06				db 5 + 1 
353e .. 00			db "-LOOP",0              
3544				endm 
# End of macro CWHEAD
3544			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
3544				; pop tos as current loop count to hl 
3544					if DEBUG_FORTH_WORDS_KEY 
3544						DMARK "-LP" 
3544 f5				push af  
3545 3a 59 35			ld a, (.dmark)  
3548 32 b4 fe			ld (debug_mark),a  
354b 3a 5a 35			ld a, (.dmark+1)  
354e 32 b5 fe			ld (debug_mark+1),a  
3551 3a 5b 35			ld a, (.dmark+2)  
3554 32 b6 fe			ld (debug_mark+2),a  
3557 18 03			jr .pastdmark  
3559 ..			.dmark: db "-LP"  
355c f1			.pastdmark: pop af  
355d			endm  
# End of macro DMARK
355d						CALLMONITOR 
355d cd c6 18			call break_point_state  
3560				endm  
# End of macro CALLMONITOR
3560					endif 
3560			 
3560				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3560			 
3560				FORTH_LOOP_TOS 
3560 cd 95 21			call macro_forth_loop_tos 
3563				endm 
# End of macro FORTH_LOOP_TOS
3563 e5				push hl 
3564			 
3564					if DEBUG_FORTH_WORDS 
3564						DMARK "-LP" 
3564 f5				push af  
3565 3a 79 35			ld a, (.dmark)  
3568 32 b4 fe			ld (debug_mark),a  
356b 3a 7a 35			ld a, (.dmark+1)  
356e 32 b5 fe			ld (debug_mark+1),a  
3571 3a 7b 35			ld a, (.dmark+2)  
3574 32 b6 fe			ld (debug_mark+2),a  
3577 18 03			jr .pastdmark  
3579 ..			.dmark: db "-LP"  
357c f1			.pastdmark: pop af  
357d			endm  
# End of macro DMARK
357d						CALLMONITOR 
357d cd c6 18			call break_point_state  
3580				endm  
# End of macro CALLMONITOR
3580					endif 
3580				; next item on the stack is the limit. get it 
3580			 
3580			 
3580				FORTH_LOOP_POP 
3580 cd 9f 21			call macro_forth_loop_pop 
3583				endm 
# End of macro FORTH_LOOP_POP
3583			 
3583				FORTH_LOOP_TOS 
3583 cd 95 21			call macro_forth_loop_tos 
3586				endm 
# End of macro FORTH_LOOP_TOS
3586			 
3586 d1				pop de		 ; de = i, hl = limit 
3587			 
3587					if DEBUG_FORTH_WORDS 
3587						DMARK "-L1" 
3587 f5				push af  
3588 3a 9c 35			ld a, (.dmark)  
358b 32 b4 fe			ld (debug_mark),a  
358e 3a 9d 35			ld a, (.dmark+1)  
3591 32 b5 fe			ld (debug_mark+1),a  
3594 3a 9e 35			ld a, (.dmark+2)  
3597 32 b6 fe			ld (debug_mark+2),a  
359a 18 03			jr .pastdmark  
359c ..			.dmark: db "-L1"  
359f f1			.pastdmark: pop af  
35a0			endm  
# End of macro DMARK
35a0						CALLMONITOR 
35a0 cd c6 18			call break_point_state  
35a3				endm  
# End of macro CALLMONITOR
35a3					endif 
35a3			 
35a3				; go back to previous word 
35a3			 
35a3 d5				push de    ; save I for inc later 
35a4			 
35a4			 
35a4				; get limit 
35a4				;  is I at limit? 
35a4			 
35a4			 
35a4					if DEBUG_FORTH_WORDS 
35a4						DMARK "-L1" 
35a4 f5				push af  
35a5 3a b9 35			ld a, (.dmark)  
35a8 32 b4 fe			ld (debug_mark),a  
35ab 3a ba 35			ld a, (.dmark+1)  
35ae 32 b5 fe			ld (debug_mark+1),a  
35b1 3a bb 35			ld a, (.dmark+2)  
35b4 32 b6 fe			ld (debug_mark+2),a  
35b7 18 03			jr .pastdmark  
35b9 ..			.dmark: db "-L1"  
35bc f1			.pastdmark: pop af  
35bd			endm  
# End of macro DMARK
35bd						CALLMONITOR 
35bd cd c6 18			call break_point_state  
35c0				endm  
# End of macro CALLMONITOR
35c0					endif 
35c0			 
35c0 ed 52			sbc hl, de 
35c2			 
35c2			 
35c2				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
35c2			 
35c2 20 26				jr nz, .mloopnotdone 
35c4			 
35c4 e1				pop hl   ; get rid of saved I 
35c5				FORTH_LOOP_POP     ; get rid of limit 
35c5 cd 9f 21			call macro_forth_loop_pop 
35c8				endm 
# End of macro FORTH_LOOP_POP
35c8			 
35c8				FORTH_RSP_POP     ; get rid of DO ptr 
35c8 cd 02 1f			call macro_forth_rsp_pop 
35cb				endm 
# End of macro FORTH_RSP_POP
35cb			 
35cb			if DEBUG_FORTH_WORDS 
35cb						DMARK "-L>" 
35cb f5				push af  
35cc 3a e0 35			ld a, (.dmark)  
35cf 32 b4 fe			ld (debug_mark),a  
35d2 3a e1 35			ld a, (.dmark+1)  
35d5 32 b5 fe			ld (debug_mark+1),a  
35d8 3a e2 35			ld a, (.dmark+2)  
35db 32 b6 fe			ld (debug_mark+2),a  
35de 18 03			jr .pastdmark  
35e0 ..			.dmark: db "-L>"  
35e3 f1			.pastdmark: pop af  
35e4			endm  
# End of macro DMARK
35e4				CALLMONITOR 
35e4 cd c6 18			call break_point_state  
35e7				endm  
# End of macro CALLMONITOR
35e7			endif 
35e7			 
35e7					NEXTW 
35e7 c3 a8 22			jp macro_next 
35ea				endm 
# End of macro NEXTW
35ea				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
35ea			 
35ea			.mloopnotdone: 
35ea			 
35ea e1				pop hl    ; get I 
35eb 2b				dec hl 
35ec			 
35ec			   	; save new I 
35ec			 
35ec			 
35ec					; set I counter 
35ec			 
35ec 22 a7 f6				ld (os_current_i), hl 
35ef			 
35ef					 
35ef				FORTH_LOOP_NEXT 
35ef cd 62 21			call macro_forth_loop_next 
35f2				endm 
# End of macro FORTH_LOOP_NEXT
35f2			 
35f2			 
35f2					if DEBUG_FORTH_WORDS 
35f2 eb						ex de,hl 
35f3					endif 
35f3			 
35f3			;	; get DO ptr 
35f3			; 
35f3				FORTH_RSP_TOS 
35f3 cd f8 1e			call macro_forth_rsp_tos 
35f6				endm 
# End of macro FORTH_RSP_TOS
35f6			 
35f6				;push hl 
35f6			 
35f6				; not going to DO any more 
35f6				; get rid of the RSP pointer as DO will add it back in 
35f6				;FORTH_RSP_POP 
35f6				;pop hl 
35f6			 
35f6			 
35f6 22 83 f6			ld (os_tok_ptr), hl 
35f9					if DEBUG_FORTH_WORDS 
35f9						DMARK "-L<" 
35f9 f5				push af  
35fa 3a 0e 36			ld a, (.dmark)  
35fd 32 b4 fe			ld (debug_mark),a  
3600 3a 0f 36			ld a, (.dmark+1)  
3603 32 b5 fe			ld (debug_mark+1),a  
3606 3a 10 36			ld a, (.dmark+2)  
3609 32 b6 fe			ld (debug_mark+2),a  
360c 18 03			jr .pastdmark  
360e ..			.dmark: db "-L<"  
3611 f1			.pastdmark: pop af  
3612			endm  
# End of macro DMARK
3612					CALLMONITOR 
3612 cd c6 18			call break_point_state  
3615				endm  
# End of macro CALLMONITOR
3615				endif 
3615 c3 39 23			jp exec1 
3618			 
3618					 
3618			 
3618			 
3618			 
3618				NEXTW 
3618 c3 a8 22			jp macro_next 
361b				endm 
# End of macro NEXTW
361b			 
361b			 
361b			 
361b			 
361b			.REPEAT: 
361b				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
361b 71				db WORD_SYS_CORE+93             
361c 6e 36			dw .UNTIL            
361e 06				db 5 + 1 
361f .. 00			db "REPEAT",0              
3626				endm 
# End of macro CWHEAD
3626			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
3626			;  push pc to rsp stack past the REPEAT 
3626					if DEBUG_FORTH_WORDS_KEY 
3626						DMARK "REP" 
3626 f5				push af  
3627 3a 3b 36			ld a, (.dmark)  
362a 32 b4 fe			ld (debug_mark),a  
362d 3a 3c 36			ld a, (.dmark+1)  
3630 32 b5 fe			ld (debug_mark+1),a  
3633 3a 3d 36			ld a, (.dmark+2)  
3636 32 b6 fe			ld (debug_mark+2),a  
3639 18 03			jr .pastdmark  
363b ..			.dmark: db "REP"  
363e f1			.pastdmark: pop af  
363f			endm  
# End of macro DMARK
363f						CALLMONITOR 
363f cd c6 18			call break_point_state  
3642				endm  
# End of macro CALLMONITOR
3642					endif 
3642			 
3642 2a 83 f6				ld hl, (os_tok_ptr) 
3645 23					inc hl   ; R 
3646 23					inc hl  ; E 
3647 23					inc hl   ; P 
3648 23					inc hl   ; E 
3649 23					inc hl   ; A 
364a 23					inc hl   ; T 
364b 23					inc hl   ; zero 
364c					FORTH_RSP_NEXT 
364c cd e1 1e			call macro_forth_rsp_next 
364f				endm 
# End of macro FORTH_RSP_NEXT
364f			 
364f			 
364f					if DEBUG_FORTH_WORDS 
364f						DMARK "REP" 
364f f5				push af  
3650 3a 64 36			ld a, (.dmark)  
3653 32 b4 fe			ld (debug_mark),a  
3656 3a 65 36			ld a, (.dmark+1)  
3659 32 b5 fe			ld (debug_mark+1),a  
365c 3a 66 36			ld a, (.dmark+2)  
365f 32 b6 fe			ld (debug_mark+2),a  
3662 18 03			jr .pastdmark  
3664 ..			.dmark: db "REP"  
3667 f1			.pastdmark: pop af  
3668			endm  
# End of macro DMARK
3668						;pop bc    ; TODO BUG ?????? what is this for???? 
3668						CALLMONITOR 
3668 cd c6 18			call break_point_state  
366b				endm  
# End of macro CALLMONITOR
366b					endif 
366b			 
366b					NEXTW 
366b c3 a8 22			jp macro_next 
366e				endm 
# End of macro NEXTW
366e			;	       NEXTW 
366e			 
366e			.UNTIL: 
366e				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
366e 72				db WORD_SYS_CORE+94             
366f 05 37			dw .ENDFLOW            
3671 06				db 5 + 1 
3672 .. 00			db "UNTIL",0              
3678				endm 
# End of macro CWHEAD
3678			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
3678			 
3678				; pop tos as check 
3678			 
3678				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3678			 
3678				FORTH_DSP_VALUEHL 
3678 cd 31 21			call macro_dsp_valuehl 
367b				endm 
# End of macro FORTH_DSP_VALUEHL
367b			 
367b					if DEBUG_FORTH_WORDS_KEY 
367b						DMARK "UNT" 
367b f5				push af  
367c 3a 90 36			ld a, (.dmark)  
367f 32 b4 fe			ld (debug_mark),a  
3682 3a 91 36			ld a, (.dmark+1)  
3685 32 b5 fe			ld (debug_mark+1),a  
3688 3a 92 36			ld a, (.dmark+2)  
368b 32 b6 fe			ld (debug_mark+2),a  
368e 18 03			jr .pastdmark  
3690 ..			.dmark: db "UNT"  
3693 f1			.pastdmark: pop af  
3694			endm  
# End of macro DMARK
3694						CALLMONITOR 
3694 cd c6 18			call break_point_state  
3697				endm  
# End of macro CALLMONITOR
3697					endif 
3697			 
3697			;	push hl 
3697				FORTH_DSP_POP 
3697 cd e9 21			call macro_forth_dsp_pop 
369a				endm 
# End of macro FORTH_DSP_POP
369a			 
369a			;	pop hl 
369a			 
369a				; test if true 
369a			 
369a cd 72 0f			call ishlzero 
369d			;	ld a,l 
369d			;	add h 
369d			; 
369d			;	cp 0 
369d			 
369d 20 3e			jr nz, .untilnotdone 
369f			 
369f					if DEBUG_FORTH_WORDS 
369f						DMARK "UNf" 
369f f5				push af  
36a0 3a b4 36			ld a, (.dmark)  
36a3 32 b4 fe			ld (debug_mark),a  
36a6 3a b5 36			ld a, (.dmark+1)  
36a9 32 b5 fe			ld (debug_mark+1),a  
36ac 3a b6 36			ld a, (.dmark+2)  
36af 32 b6 fe			ld (debug_mark+2),a  
36b2 18 03			jr .pastdmark  
36b4 ..			.dmark: db "UNf"  
36b7 f1			.pastdmark: pop af  
36b8			endm  
# End of macro DMARK
36b8						CALLMONITOR 
36b8 cd c6 18			call break_point_state  
36bb				endm  
# End of macro CALLMONITOR
36bb					endif 
36bb			 
36bb			 
36bb			 
36bb				FORTH_RSP_POP     ; get rid of DO ptr 
36bb cd 02 1f			call macro_forth_rsp_pop 
36be				endm 
# End of macro FORTH_RSP_POP
36be			 
36be			if DEBUG_FORTH_WORDS 
36be						DMARK "UN>" 
36be f5				push af  
36bf 3a d3 36			ld a, (.dmark)  
36c2 32 b4 fe			ld (debug_mark),a  
36c5 3a d4 36			ld a, (.dmark+1)  
36c8 32 b5 fe			ld (debug_mark+1),a  
36cb 3a d5 36			ld a, (.dmark+2)  
36ce 32 b6 fe			ld (debug_mark+2),a  
36d1 18 03			jr .pastdmark  
36d3 ..			.dmark: db "UN>"  
36d6 f1			.pastdmark: pop af  
36d7			endm  
# End of macro DMARK
36d7				CALLMONITOR 
36d7 cd c6 18			call break_point_state  
36da				endm  
# End of macro CALLMONITOR
36da			endif 
36da			 
36da					NEXTW 
36da c3 a8 22			jp macro_next 
36dd				endm 
# End of macro NEXTW
36dd				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
36dd			 
36dd			.untilnotdone: 
36dd			 
36dd			 
36dd			;	; get DO ptr 
36dd			; 
36dd				FORTH_RSP_TOS 
36dd cd f8 1e			call macro_forth_rsp_tos 
36e0				endm 
# End of macro FORTH_RSP_TOS
36e0			 
36e0				;push hl 
36e0			 
36e0				; not going to DO any more 
36e0				; get rid of the RSP pointer as DO will add it back in 
36e0				;FORTH_RSP_POP 
36e0				;pop hl 
36e0			 
36e0			 
36e0 22 83 f6			ld (os_tok_ptr), hl 
36e3					if DEBUG_FORTH_WORDS 
36e3						DMARK "UN<" 
36e3 f5				push af  
36e4 3a f8 36			ld a, (.dmark)  
36e7 32 b4 fe			ld (debug_mark),a  
36ea 3a f9 36			ld a, (.dmark+1)  
36ed 32 b5 fe			ld (debug_mark+1),a  
36f0 3a fa 36			ld a, (.dmark+2)  
36f3 32 b6 fe			ld (debug_mark+2),a  
36f6 18 03			jr .pastdmark  
36f8 ..			.dmark: db "UN<"  
36fb f1			.pastdmark: pop af  
36fc			endm  
# End of macro DMARK
36fc					CALLMONITOR 
36fc cd c6 18			call break_point_state  
36ff				endm  
# End of macro CALLMONITOR
36ff				endif 
36ff c3 39 23			jp exec1 
3702			 
3702					 
3702			 
3702			 
3702					NEXTW 
3702 c3 a8 22			jp macro_next 
3705				endm 
# End of macro NEXTW
3705			 
3705			 
3705			.ENDFLOW: 
3705			 
3705			; eof 
3705			 
# End of file forth_words_flow.asm
3705			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
3705			include "forth_words_logic.asm" 
3705			 
3705			; | ## Logic Words 
3705			 
3705			.NOT: 
3705				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
3705 2d				db WORD_SYS_CORE+25             
3706 4d 37			dw .IS            
3708 04				db 3 + 1 
3709 .. 00			db "NOT",0              
370d				endm 
# End of macro CWHEAD
370d			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
370d					if DEBUG_FORTH_WORDS_KEY 
370d						DMARK "NOT" 
370d f5				push af  
370e 3a 22 37			ld a, (.dmark)  
3711 32 b4 fe			ld (debug_mark),a  
3714 3a 23 37			ld a, (.dmark+1)  
3717 32 b5 fe			ld (debug_mark+1),a  
371a 3a 24 37			ld a, (.dmark+2)  
371d 32 b6 fe			ld (debug_mark+2),a  
3720 18 03			jr .pastdmark  
3722 ..			.dmark: db "NOT"  
3725 f1			.pastdmark: pop af  
3726			endm  
# End of macro DMARK
3726						CALLMONITOR 
3726 cd c6 18			call break_point_state  
3729				endm  
# End of macro CALLMONITOR
3729					endif 
3729					FORTH_DSP 
3729 cd f7 20			call macro_forth_dsp 
372c				endm 
# End of macro FORTH_DSP
372c 7e					ld a,(hl)	; get type of value on TOS 
372d fe 02				cp DS_TYPE_INUM  
372f 28 03				jr z, .noti 
3731					NEXTW 
3731 c3 a8 22			jp macro_next 
3734				endm 
# End of macro NEXTW
3734			.noti:          FORTH_DSP_VALUEHL 
3734 cd 31 21			call macro_dsp_valuehl 
3737				endm 
# End of macro FORTH_DSP_VALUEHL
3737			;		push hl 
3737					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3737 cd e9 21			call macro_forth_dsp_pop 
373a				endm 
# End of macro FORTH_DSP_POP
373a			;		pop hl 
373a 3e 00				ld a,0 
373c bd					cp l 
373d 28 04				jr z, .not2t 
373f 2e 00				ld l, 0 
3741 18 02				jr .notip 
3743			 
3743 2e ff		.not2t:		ld l, 255 
3745			 
3745 26 00		.notip:		ld h, 0	 
3747			 
3747 cd 3a 1f				call forth_push_numhl 
374a					NEXTW 
374a c3 a8 22			jp macro_next 
374d				endm 
# End of macro NEXTW
374d			 
374d			.IS: 
374d				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
374d 2d				db WORD_SYS_CORE+25             
374e 73 37			dw .LZERO            
3750 03				db 2 + 1 
3751 .. 00			db "IS",0              
3754				endm 
# End of macro CWHEAD
3754			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
3754					if DEBUG_FORTH_WORDS_KEY 
3754						DMARK "IS." 
3754 f5				push af  
3755 3a 69 37			ld a, (.dmark)  
3758 32 b4 fe			ld (debug_mark),a  
375b 3a 6a 37			ld a, (.dmark+1)  
375e 32 b5 fe			ld (debug_mark+1),a  
3761 3a 6b 37			ld a, (.dmark+2)  
3764 32 b6 fe			ld (debug_mark+2),a  
3767 18 03			jr .pastdmark  
3769 ..			.dmark: db "IS."  
376c f1			.pastdmark: pop af  
376d			endm  
# End of macro DMARK
376d						CALLMONITOR 
376d cd c6 18			call break_point_state  
3770				endm  
# End of macro CALLMONITOR
3770					endif 
3770					NEXTW 
3770 c3 a8 22			jp macro_next 
3773				endm 
# End of macro NEXTW
3773			.LZERO: 
3773				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
3773 2d				db WORD_SYS_CORE+25             
3774 7d 37			dw .TZERO            
3776 03				db 2 + 1 
3777 .. 00			db "0<",0              
377a				endm 
# End of macro CWHEAD
377a			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
377a					NEXTW 
377a c3 a8 22			jp macro_next 
377d				endm 
# End of macro NEXTW
377d			.TZERO: 
377d				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
377d 2e				db WORD_SYS_CORE+26             
377e c4 37			dw .LESS            
3780 03				db 2 + 1 
3781 .. 00			db "0=",0              
3784				endm 
# End of macro CWHEAD
3784			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
3784				; TODO add floating point number detection 
3784					;v5 FORTH_DSP_VALUE 
3784					if DEBUG_FORTH_WORDS_KEY 
3784						DMARK "0=." 
3784 f5				push af  
3785 3a 99 37			ld a, (.dmark)  
3788 32 b4 fe			ld (debug_mark),a  
378b 3a 9a 37			ld a, (.dmark+1)  
378e 32 b5 fe			ld (debug_mark+1),a  
3791 3a 9b 37			ld a, (.dmark+2)  
3794 32 b6 fe			ld (debug_mark+2),a  
3797 18 03			jr .pastdmark  
3799 ..			.dmark: db "0=."  
379c f1			.pastdmark: pop af  
379d			endm  
# End of macro DMARK
379d						CALLMONITOR 
379d cd c6 18			call break_point_state  
37a0				endm  
# End of macro CALLMONITOR
37a0					endif 
37a0					FORTH_DSP 
37a0 cd f7 20			call macro_forth_dsp 
37a3				endm 
# End of macro FORTH_DSP
37a3 7e					ld a,(hl)	; get type of value on TOS 
37a4 fe 02				cp DS_TYPE_INUM  
37a6 28 00				jr z, .tz_inum 
37a8			 
37a8				if FORTH_ENABLE_FLOATMATH 
37a8					jr .tz_done 
37a8			 
37a8				endif 
37a8					 
37a8			 
37a8			.tz_inum: 
37a8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37a8 cd 31 21			call macro_dsp_valuehl 
37ab				endm 
# End of macro FORTH_DSP_VALUEHL
37ab			 
37ab			;		push hl 
37ab			 
37ab					; destroy value TOS 
37ab			 
37ab					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37ab cd e9 21			call macro_forth_dsp_pop 
37ae				endm 
# End of macro FORTH_DSP_POP
37ae			 
37ae			;		pop hl 
37ae			 
37ae 3e 00				ld a,0 
37b0			 
37b0 bd					cp l 
37b1 20 08				jr nz, .tz_notzero 
37b3			 
37b3 bc					cp h 
37b4			 
37b4 20 05				jr nz, .tz_notzero 
37b6			 
37b6			 
37b6 21 01 00				ld hl, FORTH_TRUE 
37b9 18 03				jr .tz_done 
37bb			 
37bb 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
37be			 
37be					; push value back onto stack for another op etc 
37be			 
37be			.tz_done: 
37be cd 3a 1f				call forth_push_numhl 
37c1			 
37c1					NEXTW 
37c1 c3 a8 22			jp macro_next 
37c4				endm 
# End of macro NEXTW
37c4			.LESS: 
37c4				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
37c4 2f				db WORD_SYS_CORE+27             
37c5 2d 38			dw .GT            
37c7 02				db 1 + 1 
37c8 .. 00			db "<",0              
37ca				endm 
# End of macro CWHEAD
37ca			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
37ca				; TODO add floating point number detection 
37ca					if DEBUG_FORTH_WORDS_KEY 
37ca						DMARK "LES" 
37ca f5				push af  
37cb 3a df 37			ld a, (.dmark)  
37ce 32 b4 fe			ld (debug_mark),a  
37d1 3a e0 37			ld a, (.dmark+1)  
37d4 32 b5 fe			ld (debug_mark+1),a  
37d7 3a e1 37			ld a, (.dmark+2)  
37da 32 b6 fe			ld (debug_mark+2),a  
37dd 18 03			jr .pastdmark  
37df ..			.dmark: db "LES"  
37e2 f1			.pastdmark: pop af  
37e3			endm  
# End of macro DMARK
37e3						CALLMONITOR 
37e3 cd c6 18			call break_point_state  
37e6				endm  
# End of macro CALLMONITOR
37e6					endif 
37e6					FORTH_DSP 
37e6 cd f7 20			call macro_forth_dsp 
37e9				endm 
# End of macro FORTH_DSP
37e9					;v5 FORTH_DSP_VALUE 
37e9 7e					ld a,(hl)	; get type of value on TOS 
37ea fe 02				cp DS_TYPE_INUM  
37ec 28 00				jr z, .less_inum 
37ee			 
37ee				if FORTH_ENABLE_FLOATMATH 
37ee					jr .less_done 
37ee			 
37ee				endif 
37ee					 
37ee			 
37ee			.less_inum: 
37ee					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37ee cd 31 21			call macro_dsp_valuehl 
37f1				endm 
# End of macro FORTH_DSP_VALUEHL
37f1			 
37f1 e5					push hl  ; u2 
37f2			 
37f2					; destroy value TOS 
37f2			 
37f2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37f2 cd e9 21			call macro_forth_dsp_pop 
37f5				endm 
# End of macro FORTH_DSP_POP
37f5			 
37f5			 
37f5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37f5 cd 31 21			call macro_dsp_valuehl 
37f8				endm 
# End of macro FORTH_DSP_VALUEHL
37f8			 
37f8 e5					push hl    ; u1 
37f9			 
37f9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37f9 cd e9 21			call macro_forth_dsp_pop 
37fc				endm 
# End of macro FORTH_DSP_POP
37fc			 
37fc			 
37fc b7			 or a      ;clear carry flag 
37fd 01 00 00		 ld bc, FORTH_FALSE 
3800 e1			  pop hl    ; u1 
3801 d1			  pop de    ; u2 
3802 ed 52		  sbc hl,de 
3804 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
3806			 
3806 01 01 00		 ld bc, FORTH_TRUE 
3809			.lscont:  
3809 c5					push bc 
380a e1					pop hl 
380b			 
380b					if DEBUG_FORTH_WORDS 
380b						DMARK "LT1" 
380b f5				push af  
380c 3a 20 38			ld a, (.dmark)  
380f 32 b4 fe			ld (debug_mark),a  
3812 3a 21 38			ld a, (.dmark+1)  
3815 32 b5 fe			ld (debug_mark+1),a  
3818 3a 22 38			ld a, (.dmark+2)  
381b 32 b6 fe			ld (debug_mark+2),a  
381e 18 03			jr .pastdmark  
3820 ..			.dmark: db "LT1"  
3823 f1			.pastdmark: pop af  
3824			endm  
# End of macro DMARK
3824						CALLMONITOR 
3824 cd c6 18			call break_point_state  
3827				endm  
# End of macro CALLMONITOR
3827					endif 
3827 cd 3a 1f				call forth_push_numhl 
382a			 
382a					NEXTW 
382a c3 a8 22			jp macro_next 
382d				endm 
# End of macro NEXTW
382d			.GT: 
382d				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
382d 30				db WORD_SYS_CORE+28             
382e 96 38			dw .EQUAL            
3830 02				db 1 + 1 
3831 .. 00			db ">",0              
3833				endm 
# End of macro CWHEAD
3833			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
3833				; TODO add floating point number detection 
3833					if DEBUG_FORTH_WORDS_KEY 
3833						DMARK "GRT" 
3833 f5				push af  
3834 3a 48 38			ld a, (.dmark)  
3837 32 b4 fe			ld (debug_mark),a  
383a 3a 49 38			ld a, (.dmark+1)  
383d 32 b5 fe			ld (debug_mark+1),a  
3840 3a 4a 38			ld a, (.dmark+2)  
3843 32 b6 fe			ld (debug_mark+2),a  
3846 18 03			jr .pastdmark  
3848 ..			.dmark: db "GRT"  
384b f1			.pastdmark: pop af  
384c			endm  
# End of macro DMARK
384c						CALLMONITOR 
384c cd c6 18			call break_point_state  
384f				endm  
# End of macro CALLMONITOR
384f					endif 
384f					FORTH_DSP 
384f cd f7 20			call macro_forth_dsp 
3852				endm 
# End of macro FORTH_DSP
3852					;FORTH_DSP_VALUE 
3852 7e					ld a,(hl)	; get type of value on TOS 
3853 fe 02				cp DS_TYPE_INUM  
3855 28 00				jr z, .gt_inum 
3857			 
3857				if FORTH_ENABLE_FLOATMATH 
3857					jr .gt_done 
3857			 
3857				endif 
3857					 
3857			 
3857			.gt_inum: 
3857					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3857 cd 31 21			call macro_dsp_valuehl 
385a				endm 
# End of macro FORTH_DSP_VALUEHL
385a			 
385a e5					push hl  ; u2 
385b			 
385b					; destroy value TOS 
385b			 
385b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
385b cd e9 21			call macro_forth_dsp_pop 
385e				endm 
# End of macro FORTH_DSP_POP
385e			 
385e			 
385e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
385e cd 31 21			call macro_dsp_valuehl 
3861				endm 
# End of macro FORTH_DSP_VALUEHL
3861			 
3861 e5					push hl    ; u1 
3862			 
3862					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3862 cd e9 21			call macro_forth_dsp_pop 
3865				endm 
# End of macro FORTH_DSP_POP
3865			 
3865			 
3865 b7			 or a      ;clear carry flag 
3866 01 00 00		 ld bc, FORTH_FALSE 
3869 e1			  pop hl    ; u1 
386a d1			  pop de    ; u2 
386b ed 52		  sbc hl,de 
386d 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
386f			 
386f 01 01 00		 ld bc, FORTH_TRUE 
3872			.gtcont:  
3872 c5					push bc 
3873 e1					pop hl 
3874			 
3874					if DEBUG_FORTH_WORDS 
3874						DMARK "GT1" 
3874 f5				push af  
3875 3a 89 38			ld a, (.dmark)  
3878 32 b4 fe			ld (debug_mark),a  
387b 3a 8a 38			ld a, (.dmark+1)  
387e 32 b5 fe			ld (debug_mark+1),a  
3881 3a 8b 38			ld a, (.dmark+2)  
3884 32 b6 fe			ld (debug_mark+2),a  
3887 18 03			jr .pastdmark  
3889 ..			.dmark: db "GT1"  
388c f1			.pastdmark: pop af  
388d			endm  
# End of macro DMARK
388d						CALLMONITOR 
388d cd c6 18			call break_point_state  
3890				endm  
# End of macro CALLMONITOR
3890					endif 
3890 cd 3a 1f				call forth_push_numhl 
3893			 
3893					NEXTW 
3893 c3 a8 22			jp macro_next 
3896				endm 
# End of macro NEXTW
3896			.EQUAL: 
3896				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3896 31				db WORD_SYS_CORE+29             
3897 01 39			dw .ENDLOGIC            
3899 02				db 1 + 1 
389a .. 00			db "=",0              
389c				endm 
# End of macro CWHEAD
389c			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
389c				; TODO add floating point number detection 
389c					if DEBUG_FORTH_WORDS_KEY 
389c						DMARK "EQ." 
389c f5				push af  
389d 3a b1 38			ld a, (.dmark)  
38a0 32 b4 fe			ld (debug_mark),a  
38a3 3a b2 38			ld a, (.dmark+1)  
38a6 32 b5 fe			ld (debug_mark+1),a  
38a9 3a b3 38			ld a, (.dmark+2)  
38ac 32 b6 fe			ld (debug_mark+2),a  
38af 18 03			jr .pastdmark  
38b1 ..			.dmark: db "EQ."  
38b4 f1			.pastdmark: pop af  
38b5			endm  
# End of macro DMARK
38b5						CALLMONITOR 
38b5 cd c6 18			call break_point_state  
38b8				endm  
# End of macro CALLMONITOR
38b8					endif 
38b8					FORTH_DSP 
38b8 cd f7 20			call macro_forth_dsp 
38bb				endm 
# End of macro FORTH_DSP
38bb					;v5 FORTH_DSP_VALUE 
38bb 7e					ld a,(hl)	; get type of value on TOS 
38bc fe 02				cp DS_TYPE_INUM  
38be 28 00				jr z, .eq_inum 
38c0			 
38c0				if FORTH_ENABLE_FLOATMATH 
38c0					jr .eq_done 
38c0			 
38c0				endif 
38c0					 
38c0			 
38c0			.eq_inum: 
38c0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38c0 cd 31 21			call macro_dsp_valuehl 
38c3				endm 
# End of macro FORTH_DSP_VALUEHL
38c3			 
38c3 e5					push hl 
38c4			 
38c4					; destroy value TOS 
38c4			 
38c4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38c4 cd e9 21			call macro_forth_dsp_pop 
38c7				endm 
# End of macro FORTH_DSP_POP
38c7			 
38c7			 
38c7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38c7 cd 31 21			call macro_dsp_valuehl 
38ca				endm 
# End of macro FORTH_DSP_VALUEHL
38ca			 
38ca					; one value on hl get other one back 
38ca			 
38ca e5					push hl 
38cb			 
38cb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38cb cd e9 21			call macro_forth_dsp_pop 
38ce				endm 
# End of macro FORTH_DSP_POP
38ce			 
38ce 0e 00				ld c, FORTH_FALSE 
38d0			 
38d0 e1					pop hl 
38d1 d1					pop de 
38d2			 
38d2 7b					ld a, e 
38d3 bd					cp l 
38d4			 
38d4 20 06				jr nz, .eq_done 
38d6			 
38d6 7a					ld a, d 
38d7 bc					cp h 
38d8			 
38d8 20 02				jr nz, .eq_done 
38da			 
38da 0e 01				ld c, FORTH_TRUE 
38dc					 
38dc			 
38dc			 
38dc			.eq_done: 
38dc			 
38dc					; TODO push value back onto stack for another op etc 
38dc			 
38dc 26 00				ld h, 0 
38de 69					ld l, c 
38df					if DEBUG_FORTH_WORDS 
38df						DMARK "EQ1" 
38df f5				push af  
38e0 3a f4 38			ld a, (.dmark)  
38e3 32 b4 fe			ld (debug_mark),a  
38e6 3a f5 38			ld a, (.dmark+1)  
38e9 32 b5 fe			ld (debug_mark+1),a  
38ec 3a f6 38			ld a, (.dmark+2)  
38ef 32 b6 fe			ld (debug_mark+2),a  
38f2 18 03			jr .pastdmark  
38f4 ..			.dmark: db "EQ1"  
38f7 f1			.pastdmark: pop af  
38f8			endm  
# End of macro DMARK
38f8						CALLMONITOR 
38f8 cd c6 18			call break_point_state  
38fb				endm  
# End of macro CALLMONITOR
38fb					endif 
38fb cd 3a 1f				call forth_push_numhl 
38fe			 
38fe					NEXTW 
38fe c3 a8 22			jp macro_next 
3901				endm 
# End of macro NEXTW
3901			 
3901			 
3901			.ENDLOGIC: 
3901			; eof 
3901			 
3901			 
# End of file forth_words_logic.asm
3901			include "forth_words_maths.asm" 
3901			 
3901			; | ## Maths Words 
3901			 
3901			.PLUS:	 
3901				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3901 15				db WORD_SYS_CORE+1             
3902 43 39			dw .NEG            
3904 02				db 1 + 1 
3905 .. 00			db "+",0              
3907				endm 
# End of macro CWHEAD
3907			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3907					if DEBUG_FORTH_WORDS_KEY 
3907						DMARK "PLU" 
3907 f5				push af  
3908 3a 1c 39			ld a, (.dmark)  
390b 32 b4 fe			ld (debug_mark),a  
390e 3a 1d 39			ld a, (.dmark+1)  
3911 32 b5 fe			ld (debug_mark+1),a  
3914 3a 1e 39			ld a, (.dmark+2)  
3917 32 b6 fe			ld (debug_mark+2),a  
391a 18 03			jr .pastdmark  
391c ..			.dmark: db "PLU"  
391f f1			.pastdmark: pop af  
3920			endm  
# End of macro DMARK
3920						CALLMONITOR 
3920 cd c6 18			call break_point_state  
3923				endm  
# End of macro CALLMONITOR
3923					endif 
3923					; add top two values and push back result 
3923			 
3923					;for v5 FORTH_DSP_VALUE 
3923					FORTH_DSP 
3923 cd f7 20			call macro_forth_dsp 
3926				endm 
# End of macro FORTH_DSP
3926 7e					ld a,(hl)	; get type of value on TOS 
3927 fe 02				cp DS_TYPE_INUM  
3929 28 03				jr z, .dot_inum 
392b			 
392b					NEXTW 
392b c3 a8 22			jp macro_next 
392e				endm 
# End of macro NEXTW
392e			 
392e			; float maths 
392e			 
392e				if FORTH_ENABLE_FLOATMATH 
392e						inc hl      ; now at start of numeric as string 
392e			 
392e					if DEBUG_FORTH_MATHS 
392e						DMARK "ADD" 
392e				CALLMONITOR 
392e					endif 
392e			 
392e					;ld ix, hl 
392e					call CON 
392e			 
392e			 
392e					push hl 
392e					 
392e					 
392e			 
392e						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
392e			 
392e					; get next number 
392e			 
392e						FORTH_DSP_VALUE 
392e			 
392e						inc hl      ; now at start of numeric as string 
392e			 
392e					;ld ix, hl 
392e					call CON 
392e			 
392e					push hl 
392e			 
392e			 
392e						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
392e			 
392e						; TODO do add 
392e			 
392e						call IADD 
392e			 
392e						; TODO get result back as ascii 
392e			 
392e						; TODO push result  
392e			 
392e			 
392e			 
392e						jr .dot_done 
392e				endif 
392e			 
392e			.dot_inum: 
392e			 
392e			 
392e					if DEBUG_FORTH_DOT 
392e						DMARK "+IT" 
392e				CALLMONITOR 
392e					endif 
392e			 
392e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
392e cd 31 21			call macro_dsp_valuehl 
3931				endm 
# End of macro FORTH_DSP_VALUEHL
3931			 
3931				; TODO add floating point number detection 
3931			 
3931 e5					push hl 
3932			 
3932					; destroy value TOS 
3932			 
3932					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3932 cd e9 21			call macro_forth_dsp_pop 
3935				endm 
# End of macro FORTH_DSP_POP
3935			 
3935			 
3935					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3935 cd 31 21			call macro_dsp_valuehl 
3938				endm 
# End of macro FORTH_DSP_VALUEHL
3938			 
3938					; one value on hl get other one back 
3938			 
3938 d1					pop de 
3939			 
3939					; do the add 
3939			 
3939 19					add hl,de 
393a			 
393a					; save it 
393a			 
393a			;		push hl	 
393a			 
393a					; 
393a			 
393a					; destroy value TOS 
393a			 
393a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
393a cd e9 21			call macro_forth_dsp_pop 
393d				endm 
# End of macro FORTH_DSP_POP
393d			 
393d					; TODO push value back onto stack for another op etc 
393d			 
393d			;		pop hl 
393d			 
393d			.dot_done: 
393d cd 3a 1f				call forth_push_numhl 
3940			 
3940					NEXTW 
3940 c3 a8 22			jp macro_next 
3943				endm 
# End of macro NEXTW
3943			.NEG: 
3943			 
3943				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
3943 17				db WORD_SYS_CORE+3             
3944 86 39			dw .DIV            
3946 02				db 1 + 1 
3947 .. 00			db "-",0              
3949				endm 
# End of macro CWHEAD
3949			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3949					if DEBUG_FORTH_WORDS_KEY 
3949						DMARK "SUB" 
3949 f5				push af  
394a 3a 5e 39			ld a, (.dmark)  
394d 32 b4 fe			ld (debug_mark),a  
3950 3a 5f 39			ld a, (.dmark+1)  
3953 32 b5 fe			ld (debug_mark+1),a  
3956 3a 60 39			ld a, (.dmark+2)  
3959 32 b6 fe			ld (debug_mark+2),a  
395c 18 03			jr .pastdmark  
395e ..			.dmark: db "SUB"  
3961 f1			.pastdmark: pop af  
3962			endm  
# End of macro DMARK
3962						CALLMONITOR 
3962 cd c6 18			call break_point_state  
3965				endm  
# End of macro CALLMONITOR
3965					endif 
3965			 
3965			 
3965				; TODO add floating point number detection 
3965					; v5 FORTH_DSP_VALUE 
3965					FORTH_DSP 
3965 cd f7 20			call macro_forth_dsp 
3968				endm 
# End of macro FORTH_DSP
3968 7e					ld a,(hl)	; get type of value on TOS 
3969 fe 02				cp DS_TYPE_INUM  
396b 28 03				jr z, .neg_inum 
396d			 
396d					NEXTW 
396d c3 a8 22			jp macro_next 
3970				endm 
# End of macro NEXTW
3970			 
3970			; float maths 
3970			 
3970				if FORTH_ENABLE_FLOATMATH 
3970					jr .neg_done 
3970			 
3970				endif 
3970					 
3970			 
3970			.neg_inum: 
3970					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3970 cd 31 21			call macro_dsp_valuehl 
3973				endm 
# End of macro FORTH_DSP_VALUEHL
3973			 
3973 e5					push hl 
3974			 
3974					; destroy value TOS 
3974			 
3974					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3974 cd e9 21			call macro_forth_dsp_pop 
3977				endm 
# End of macro FORTH_DSP_POP
3977			 
3977			 
3977					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3977 cd 31 21			call macro_dsp_valuehl 
397a				endm 
# End of macro FORTH_DSP_VALUEHL
397a			 
397a					; one value on hl get other one back 
397a			 
397a d1					pop de 
397b			 
397b					; do the sub 
397b			;		ex de, hl 
397b			 
397b ed 52				sbc hl,de 
397d			 
397d					; save it 
397d			 
397d			;		push hl	 
397d			 
397d					; 
397d			 
397d					; destroy value TOS 
397d			 
397d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
397d cd e9 21			call macro_forth_dsp_pop 
3980				endm 
# End of macro FORTH_DSP_POP
3980			 
3980					; TODO push value back onto stack for another op etc 
3980			 
3980			;		pop hl 
3980			 
3980 cd 3a 1f				call forth_push_numhl 
3983			.neg_done: 
3983			 
3983					NEXTW 
3983 c3 a8 22			jp macro_next 
3986				endm 
# End of macro NEXTW
3986			.DIV: 
3986				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3986 18				db WORD_SYS_CORE+4             
3987 d3 39			dw .MUL            
3989 02				db 1 + 1 
398a .. 00			db "/",0              
398c				endm 
# End of macro CWHEAD
398c			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
398c					if DEBUG_FORTH_WORDS_KEY 
398c						DMARK "DIV" 
398c f5				push af  
398d 3a a1 39			ld a, (.dmark)  
3990 32 b4 fe			ld (debug_mark),a  
3993 3a a2 39			ld a, (.dmark+1)  
3996 32 b5 fe			ld (debug_mark+1),a  
3999 3a a3 39			ld a, (.dmark+2)  
399c 32 b6 fe			ld (debug_mark+2),a  
399f 18 03			jr .pastdmark  
39a1 ..			.dmark: db "DIV"  
39a4 f1			.pastdmark: pop af  
39a5			endm  
# End of macro DMARK
39a5						CALLMONITOR 
39a5 cd c6 18			call break_point_state  
39a8				endm  
# End of macro CALLMONITOR
39a8					endif 
39a8				; TODO add floating point number detection 
39a8					; v5 FORTH_DSP_VALUE 
39a8					FORTH_DSP 
39a8 cd f7 20			call macro_forth_dsp 
39ab				endm 
# End of macro FORTH_DSP
39ab 7e					ld a,(hl)	; get type of value on TOS 
39ac fe 02				cp DS_TYPE_INUM  
39ae 28 03				jr z, .div_inum 
39b0			 
39b0				if FORTH_ENABLE_FLOATMATH 
39b0					jr .div_done 
39b0			 
39b0				endif 
39b0					NEXTW 
39b0 c3 a8 22			jp macro_next 
39b3				endm 
# End of macro NEXTW
39b3			.div_inum: 
39b3			 
39b3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39b3 cd 31 21			call macro_dsp_valuehl 
39b6				endm 
# End of macro FORTH_DSP_VALUEHL
39b6			 
39b6 e5					push hl    ; to go to bc 
39b7			 
39b7					; destroy value TOS 
39b7			 
39b7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39b7 cd e9 21			call macro_forth_dsp_pop 
39ba				endm 
# End of macro FORTH_DSP_POP
39ba			 
39ba			 
39ba					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39ba cd 31 21			call macro_dsp_valuehl 
39bd				endm 
# End of macro FORTH_DSP_VALUEHL
39bd			 
39bd					; hl to go to de 
39bd			 
39bd e5					push hl 
39be			 
39be c1					pop bc 
39bf d1					pop de		 
39c0			 
39c0			 
39c0					if DEBUG_FORTH_MATHS 
39c0						DMARK "DIV" 
39c0				CALLMONITOR 
39c0					endif 
39c0					; one value on hl but move to a get other one back 
39c0			 
39c0			        
39c0 cd a6 0e			call Div16 
39c3			 
39c3			;	push af	 
39c3 e5				push hl 
39c4 c5				push bc 
39c5			 
39c5					if DEBUG_FORTH_MATHS 
39c5						DMARK "DI1" 
39c5				CALLMONITOR 
39c5					endif 
39c5			 
39c5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39c5 cd e9 21			call macro_forth_dsp_pop 
39c8				endm 
# End of macro FORTH_DSP_POP
39c8			 
39c8			 
39c8			 
39c8 e1					pop hl    ; result 
39c9			 
39c9 cd 3a 1f				call forth_push_numhl 
39cc			 
39cc e1					pop hl    ; reminder 
39cd			;		ld h,0 
39cd			;		ld l,d 
39cd			 
39cd cd 3a 1f				call forth_push_numhl 
39d0			.div_done: 
39d0					NEXTW 
39d0 c3 a8 22			jp macro_next 
39d3				endm 
# End of macro NEXTW
39d3			.MUL: 
39d3				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
39d3 19				db WORD_SYS_CORE+5             
39d4 18 3a			dw .MIN            
39d6 02				db 1 + 1 
39d7 .. 00			db "*",0              
39d9				endm 
# End of macro CWHEAD
39d9			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
39d9				; TODO add floating point number detection 
39d9					if DEBUG_FORTH_WORDS_KEY 
39d9						DMARK "MUL" 
39d9 f5				push af  
39da 3a ee 39			ld a, (.dmark)  
39dd 32 b4 fe			ld (debug_mark),a  
39e0 3a ef 39			ld a, (.dmark+1)  
39e3 32 b5 fe			ld (debug_mark+1),a  
39e6 3a f0 39			ld a, (.dmark+2)  
39e9 32 b6 fe			ld (debug_mark+2),a  
39ec 18 03			jr .pastdmark  
39ee ..			.dmark: db "MUL"  
39f1 f1			.pastdmark: pop af  
39f2			endm  
# End of macro DMARK
39f2						CALLMONITOR 
39f2 cd c6 18			call break_point_state  
39f5				endm  
# End of macro CALLMONITOR
39f5					endif 
39f5					FORTH_DSP 
39f5 cd f7 20			call macro_forth_dsp 
39f8				endm 
# End of macro FORTH_DSP
39f8					; v5 FORTH_DSP_VALUE 
39f8 7e					ld a,(hl)	; get type of value on TOS 
39f9 fe 02				cp DS_TYPE_INUM  
39fb 28 03				jr z, .mul_inum 
39fd			 
39fd				if FORTH_ENABLE_FLOATMATH 
39fd					jr .mul_done 
39fd			 
39fd				endif 
39fd			 
39fd					NEXTW 
39fd c3 a8 22			jp macro_next 
3a00				endm 
# End of macro NEXTW
3a00			.mul_inum:	 
3a00			 
3a00					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a00 cd 31 21			call macro_dsp_valuehl 
3a03				endm 
# End of macro FORTH_DSP_VALUEHL
3a03			 
3a03 e5					push hl 
3a04			 
3a04					; destroy value TOS 
3a04			 
3a04					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a04 cd e9 21			call macro_forth_dsp_pop 
3a07				endm 
# End of macro FORTH_DSP_POP
3a07			 
3a07			 
3a07					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a07 cd 31 21			call macro_dsp_valuehl 
3a0a				endm 
# End of macro FORTH_DSP_VALUEHL
3a0a			 
3a0a					; one value on hl but move to a get other one back 
3a0a			 
3a0a 7d					ld a, l 
3a0b			 
3a0b d1					pop de 
3a0c			 
3a0c					; do the mull 
3a0c			;		ex de, hl 
3a0c			 
3a0c cd cc 0e				call Mult16 
3a0f					; save it 
3a0f			 
3a0f			;		push hl	 
3a0f			 
3a0f					; 
3a0f			 
3a0f					; destroy value TOS 
3a0f			 
3a0f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a0f cd e9 21			call macro_forth_dsp_pop 
3a12				endm 
# End of macro FORTH_DSP_POP
3a12			 
3a12					; TODO push value back onto stack for another op etc 
3a12			 
3a12			;		pop hl 
3a12			 
3a12 cd 3a 1f				call forth_push_numhl 
3a15			 
3a15			.mul_done: 
3a15					NEXTW 
3a15 c3 a8 22			jp macro_next 
3a18				endm 
# End of macro NEXTW
3a18			 
3a18			 
3a18			 
3a18			 
3a18			.MIN: 
3a18				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3a18 49				db WORD_SYS_CORE+53             
3a19 99 3a			dw .MAX            
3a1b 04				db 3 + 1 
3a1c .. 00			db "MIN",0              
3a20				endm 
# End of macro CWHEAD
3a20			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3a20					if DEBUG_FORTH_WORDS_KEY 
3a20						DMARK "MIN" 
3a20 f5				push af  
3a21 3a 35 3a			ld a, (.dmark)  
3a24 32 b4 fe			ld (debug_mark),a  
3a27 3a 36 3a			ld a, (.dmark+1)  
3a2a 32 b5 fe			ld (debug_mark+1),a  
3a2d 3a 37 3a			ld a, (.dmark+2)  
3a30 32 b6 fe			ld (debug_mark+2),a  
3a33 18 03			jr .pastdmark  
3a35 ..			.dmark: db "MIN"  
3a38 f1			.pastdmark: pop af  
3a39			endm  
# End of macro DMARK
3a39						CALLMONITOR 
3a39 cd c6 18			call break_point_state  
3a3c				endm  
# End of macro CALLMONITOR
3a3c					endif 
3a3c					; get u2 
3a3c			 
3a3c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a3c cd 31 21			call macro_dsp_valuehl 
3a3f				endm 
# End of macro FORTH_DSP_VALUEHL
3a3f			 
3a3f e5					push hl   ; u2 
3a40			 
3a40					; destroy value TOS 
3a40			 
3a40					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a40 cd e9 21			call macro_forth_dsp_pop 
3a43				endm 
# End of macro FORTH_DSP_POP
3a43			 
3a43					; get u1 
3a43			 
3a43					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a43 cd 31 21			call macro_dsp_valuehl 
3a46				endm 
# End of macro FORTH_DSP_VALUEHL
3a46			 
3a46 e5					push hl  ; u1 
3a47			 
3a47					; destroy value TOS 
3a47			 
3a47					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a47 cd e9 21			call macro_forth_dsp_pop 
3a4a				endm 
# End of macro FORTH_DSP_POP
3a4a			 
3a4a b7			 or a      ;clear carry flag 
3a4b e1			  pop hl    ; u1 
3a4c d1			  pop de    ; u2 
3a4d e5				push hl   ; saved in case hl is lowest 
3a4e ed 52		  sbc hl,de 
3a50 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3a52			 
3a52 e1				pop hl 
3a53					if DEBUG_FORTH_WORDS 
3a53						DMARK "MIN" 
3a53 f5				push af  
3a54 3a 68 3a			ld a, (.dmark)  
3a57 32 b4 fe			ld (debug_mark),a  
3a5a 3a 69 3a			ld a, (.dmark+1)  
3a5d 32 b5 fe			ld (debug_mark+1),a  
3a60 3a 6a 3a			ld a, (.dmark+2)  
3a63 32 b6 fe			ld (debug_mark+2),a  
3a66 18 03			jr .pastdmark  
3a68 ..			.dmark: db "MIN"  
3a6b f1			.pastdmark: pop af  
3a6c			endm  
# End of macro DMARK
3a6c						CALLMONITOR 
3a6c cd c6 18			call break_point_state  
3a6f				endm  
# End of macro CALLMONITOR
3a6f					endif 
3a6f cd 3a 1f				call forth_push_numhl 
3a72			 
3a72				       NEXTW 
3a72 c3 a8 22			jp macro_next 
3a75				endm 
# End of macro NEXTW
3a75			 
3a75			.mincont:  
3a75 c1				pop bc   ; tidy up 
3a76 eb				ex de , hl  
3a77					if DEBUG_FORTH_WORDS 
3a77						DMARK "MI1" 
3a77 f5				push af  
3a78 3a 8c 3a			ld a, (.dmark)  
3a7b 32 b4 fe			ld (debug_mark),a  
3a7e 3a 8d 3a			ld a, (.dmark+1)  
3a81 32 b5 fe			ld (debug_mark+1),a  
3a84 3a 8e 3a			ld a, (.dmark+2)  
3a87 32 b6 fe			ld (debug_mark+2),a  
3a8a 18 03			jr .pastdmark  
3a8c ..			.dmark: db "MI1"  
3a8f f1			.pastdmark: pop af  
3a90			endm  
# End of macro DMARK
3a90						CALLMONITOR 
3a90 cd c6 18			call break_point_state  
3a93				endm  
# End of macro CALLMONITOR
3a93					endif 
3a93 cd 3a 1f				call forth_push_numhl 
3a96			 
3a96				       NEXTW 
3a96 c3 a8 22			jp macro_next 
3a99				endm 
# End of macro NEXTW
3a99			.MAX: 
3a99				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3a99 4a				db WORD_SYS_CORE+54             
3a9a 1a 3b			dw .RND16            
3a9c 04				db 3 + 1 
3a9d .. 00			db "MAX",0              
3aa1				endm 
# End of macro CWHEAD
3aa1			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3aa1					if DEBUG_FORTH_WORDS_KEY 
3aa1						DMARK "MAX" 
3aa1 f5				push af  
3aa2 3a b6 3a			ld a, (.dmark)  
3aa5 32 b4 fe			ld (debug_mark),a  
3aa8 3a b7 3a			ld a, (.dmark+1)  
3aab 32 b5 fe			ld (debug_mark+1),a  
3aae 3a b8 3a			ld a, (.dmark+2)  
3ab1 32 b6 fe			ld (debug_mark+2),a  
3ab4 18 03			jr .pastdmark  
3ab6 ..			.dmark: db "MAX"  
3ab9 f1			.pastdmark: pop af  
3aba			endm  
# End of macro DMARK
3aba						CALLMONITOR 
3aba cd c6 18			call break_point_state  
3abd				endm  
# End of macro CALLMONITOR
3abd					endif 
3abd					; get u2 
3abd			 
3abd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3abd cd 31 21			call macro_dsp_valuehl 
3ac0				endm 
# End of macro FORTH_DSP_VALUEHL
3ac0			 
3ac0 e5					push hl   ; u2 
3ac1			 
3ac1					; destroy value TOS 
3ac1			 
3ac1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ac1 cd e9 21			call macro_forth_dsp_pop 
3ac4				endm 
# End of macro FORTH_DSP_POP
3ac4			 
3ac4					; get u1 
3ac4			 
3ac4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ac4 cd 31 21			call macro_dsp_valuehl 
3ac7				endm 
# End of macro FORTH_DSP_VALUEHL
3ac7			 
3ac7 e5					push hl  ; u1 
3ac8			 
3ac8					; destroy value TOS 
3ac8			 
3ac8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ac8 cd e9 21			call macro_forth_dsp_pop 
3acb				endm 
# End of macro FORTH_DSP_POP
3acb			 
3acb b7			 or a      ;clear carry flag 
3acc e1			  pop hl    ; u1 
3acd d1			  pop de    ; u2 
3ace e5				push hl   ; saved in case hl is lowest 
3acf ed 52		  sbc hl,de 
3ad1 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3ad3			 
3ad3 e1				pop hl 
3ad4					if DEBUG_FORTH_WORDS 
3ad4						DMARK "MAX" 
3ad4 f5				push af  
3ad5 3a e9 3a			ld a, (.dmark)  
3ad8 32 b4 fe			ld (debug_mark),a  
3adb 3a ea 3a			ld a, (.dmark+1)  
3ade 32 b5 fe			ld (debug_mark+1),a  
3ae1 3a eb 3a			ld a, (.dmark+2)  
3ae4 32 b6 fe			ld (debug_mark+2),a  
3ae7 18 03			jr .pastdmark  
3ae9 ..			.dmark: db "MAX"  
3aec f1			.pastdmark: pop af  
3aed			endm  
# End of macro DMARK
3aed						CALLMONITOR 
3aed cd c6 18			call break_point_state  
3af0				endm  
# End of macro CALLMONITOR
3af0					endif 
3af0 cd 3a 1f				call forth_push_numhl 
3af3			 
3af3				       NEXTW 
3af3 c3 a8 22			jp macro_next 
3af6				endm 
# End of macro NEXTW
3af6			 
3af6			.maxcont:  
3af6 c1				pop bc   ; tidy up 
3af7 eb				ex de , hl  
3af8					if DEBUG_FORTH_WORDS 
3af8						DMARK "MA1" 
3af8 f5				push af  
3af9 3a 0d 3b			ld a, (.dmark)  
3afc 32 b4 fe			ld (debug_mark),a  
3aff 3a 0e 3b			ld a, (.dmark+1)  
3b02 32 b5 fe			ld (debug_mark+1),a  
3b05 3a 0f 3b			ld a, (.dmark+2)  
3b08 32 b6 fe			ld (debug_mark+2),a  
3b0b 18 03			jr .pastdmark  
3b0d ..			.dmark: db "MA1"  
3b10 f1			.pastdmark: pop af  
3b11			endm  
# End of macro DMARK
3b11						CALLMONITOR 
3b11 cd c6 18			call break_point_state  
3b14				endm  
# End of macro CALLMONITOR
3b14					endif 
3b14 cd 3a 1f				call forth_push_numhl 
3b17				       NEXTW 
3b17 c3 a8 22			jp macro_next 
3b1a				endm 
# End of macro NEXTW
3b1a			 
3b1a			.RND16: 
3b1a				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3b1a 4e				db WORD_SYS_CORE+58             
3b1b 49 3b			dw .RND8            
3b1d 06				db 5 + 1 
3b1e .. 00			db "RND16",0              
3b24				endm 
# End of macro CWHEAD
3b24			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3b24					if DEBUG_FORTH_WORDS_KEY 
3b24						DMARK "R16" 
3b24 f5				push af  
3b25 3a 39 3b			ld a, (.dmark)  
3b28 32 b4 fe			ld (debug_mark),a  
3b2b 3a 3a 3b			ld a, (.dmark+1)  
3b2e 32 b5 fe			ld (debug_mark+1),a  
3b31 3a 3b 3b			ld a, (.dmark+2)  
3b34 32 b6 fe			ld (debug_mark+2),a  
3b37 18 03			jr .pastdmark  
3b39 ..			.dmark: db "R16"  
3b3c f1			.pastdmark: pop af  
3b3d			endm  
# End of macro DMARK
3b3d						CALLMONITOR 
3b3d cd c6 18			call break_point_state  
3b40				endm  
# End of macro CALLMONITOR
3b40					endif 
3b40 cd 70 0e				call prng16  
3b43 cd 3a 1f				call forth_push_numhl 
3b46				       NEXTW 
3b46 c3 a8 22			jp macro_next 
3b49				endm 
# End of macro NEXTW
3b49			.RND8: 
3b49				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3b49 60				db WORD_SYS_CORE+76             
3b4a 7e 3b			dw .RND            
3b4c 05				db 4 + 1 
3b4d .. 00			db "RND8",0              
3b52				endm 
# End of macro CWHEAD
3b52			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3b52					if DEBUG_FORTH_WORDS_KEY 
3b52						DMARK "RN8" 
3b52 f5				push af  
3b53 3a 67 3b			ld a, (.dmark)  
3b56 32 b4 fe			ld (debug_mark),a  
3b59 3a 68 3b			ld a, (.dmark+1)  
3b5c 32 b5 fe			ld (debug_mark+1),a  
3b5f 3a 69 3b			ld a, (.dmark+2)  
3b62 32 b6 fe			ld (debug_mark+2),a  
3b65 18 03			jr .pastdmark  
3b67 ..			.dmark: db "RN8"  
3b6a f1			.pastdmark: pop af  
3b6b			endm  
# End of macro DMARK
3b6b						CALLMONITOR 
3b6b cd c6 18			call break_point_state  
3b6e				endm  
# End of macro CALLMONITOR
3b6e					endif 
3b6e 2a 35 fd				ld hl,(xrandc) 
3b71 23					inc hl 
3b72 cd 8a 0e				call xrnd 
3b75 6f					ld l,a	 
3b76 26 00				ld h,0 
3b78 cd 3a 1f				call forth_push_numhl 
3b7b				       NEXTW 
3b7b c3 a8 22			jp macro_next 
3b7e				endm 
# End of macro NEXTW
3b7e			.RND: 
3b7e				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3b7e 60				db WORD_SYS_CORE+76             
3b7f 84 3c			dw .ENDMATHS            
3b81 04				db 3 + 1 
3b82 .. 00			db "RND",0              
3b86				endm 
# End of macro CWHEAD
3b86			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3b86			 
3b86					if DEBUG_FORTH_WORDS_KEY 
3b86						DMARK "RND" 
3b86 f5				push af  
3b87 3a 9b 3b			ld a, (.dmark)  
3b8a 32 b4 fe			ld (debug_mark),a  
3b8d 3a 9c 3b			ld a, (.dmark+1)  
3b90 32 b5 fe			ld (debug_mark+1),a  
3b93 3a 9d 3b			ld a, (.dmark+2)  
3b96 32 b6 fe			ld (debug_mark+2),a  
3b99 18 03			jr .pastdmark  
3b9b ..			.dmark: db "RND"  
3b9e f1			.pastdmark: pop af  
3b9f			endm  
# End of macro DMARK
3b9f						CALLMONITOR 
3b9f cd c6 18			call break_point_state  
3ba2				endm  
# End of macro CALLMONITOR
3ba2					endif 
3ba2					 
3ba2					FORTH_DSP_VALUEHL    ; upper range 
3ba2 cd 31 21			call macro_dsp_valuehl 
3ba5				endm 
# End of macro FORTH_DSP_VALUEHL
3ba5			 
3ba5 22 39 fd				ld (LFSRSeed), hl	 
3ba8			 
3ba8					if DEBUG_FORTH_WORDS 
3ba8						DMARK "RN1" 
3ba8 f5				push af  
3ba9 3a bd 3b			ld a, (.dmark)  
3bac 32 b4 fe			ld (debug_mark),a  
3baf 3a be 3b			ld a, (.dmark+1)  
3bb2 32 b5 fe			ld (debug_mark+1),a  
3bb5 3a bf 3b			ld a, (.dmark+2)  
3bb8 32 b6 fe			ld (debug_mark+2),a  
3bbb 18 03			jr .pastdmark  
3bbd ..			.dmark: db "RN1"  
3bc0 f1			.pastdmark: pop af  
3bc1			endm  
# End of macro DMARK
3bc1						CALLMONITOR 
3bc1 cd c6 18			call break_point_state  
3bc4				endm  
# End of macro CALLMONITOR
3bc4					endif 
3bc4					FORTH_DSP_POP 
3bc4 cd e9 21			call macro_forth_dsp_pop 
3bc7				endm 
# End of macro FORTH_DSP_POP
3bc7			 
3bc7					FORTH_DSP_VALUEHL    ; low range 
3bc7 cd 31 21			call macro_dsp_valuehl 
3bca				endm 
# End of macro FORTH_DSP_VALUEHL
3bca			 
3bca					if DEBUG_FORTH_WORDS 
3bca						DMARK "RN2" 
3bca f5				push af  
3bcb 3a df 3b			ld a, (.dmark)  
3bce 32 b4 fe			ld (debug_mark),a  
3bd1 3a e0 3b			ld a, (.dmark+1)  
3bd4 32 b5 fe			ld (debug_mark+1),a  
3bd7 3a e1 3b			ld a, (.dmark+2)  
3bda 32 b6 fe			ld (debug_mark+2),a  
3bdd 18 03			jr .pastdmark  
3bdf ..			.dmark: db "RN2"  
3be2 f1			.pastdmark: pop af  
3be3			endm  
# End of macro DMARK
3be3						CALLMONITOR 
3be3 cd c6 18			call break_point_state  
3be6				endm  
# End of macro CALLMONITOR
3be6					endif 
3be6 22 3b fd				ld (LFSRSeed+2), hl 
3be9			 
3be9					FORTH_DSP_POP 
3be9 cd e9 21			call macro_forth_dsp_pop 
3bec				endm 
# End of macro FORTH_DSP_POP
3bec			 
3bec e5					push hl 
3bed			 
3bed e1			.inrange:	pop hl 
3bee cd 70 0e				call prng16  
3bf1					if DEBUG_FORTH_WORDS 
3bf1						DMARK "RN3" 
3bf1 f5				push af  
3bf2 3a 06 3c			ld a, (.dmark)  
3bf5 32 b4 fe			ld (debug_mark),a  
3bf8 3a 07 3c			ld a, (.dmark+1)  
3bfb 32 b5 fe			ld (debug_mark+1),a  
3bfe 3a 08 3c			ld a, (.dmark+2)  
3c01 32 b6 fe			ld (debug_mark+2),a  
3c04 18 03			jr .pastdmark  
3c06 ..			.dmark: db "RN3"  
3c09 f1			.pastdmark: pop af  
3c0a			endm  
# End of macro DMARK
3c0a						CALLMONITOR 
3c0a cd c6 18			call break_point_state  
3c0d				endm  
# End of macro CALLMONITOR
3c0d					endif 
3c0d					 
3c0d					; if the range is 8bit knock out the high byte 
3c0d			 
3c0d ed 5b 39 fd			ld de, (LFSRSeed)     ; check high level 
3c11			 
3c11 3e 00				ld a, 0 
3c13 ba					cp d  
3c14 20 1e				jr nz, .hirange 
3c16 26 00				ld h, 0   ; knock it down to 8bit 
3c18			 
3c18					if DEBUG_FORTH_WORDS 
3c18						DMARK "RNk" 
3c18 f5				push af  
3c19 3a 2d 3c			ld a, (.dmark)  
3c1c 32 b4 fe			ld (debug_mark),a  
3c1f 3a 2e 3c			ld a, (.dmark+1)  
3c22 32 b5 fe			ld (debug_mark+1),a  
3c25 3a 2f 3c			ld a, (.dmark+2)  
3c28 32 b6 fe			ld (debug_mark+2),a  
3c2b 18 03			jr .pastdmark  
3c2d ..			.dmark: db "RNk"  
3c30 f1			.pastdmark: pop af  
3c31			endm  
# End of macro DMARK
3c31						CALLMONITOR 
3c31 cd c6 18			call break_point_state  
3c34				endm  
# End of macro CALLMONITOR
3c34					endif 
3c34			.hirange:   
3c34 e5					push hl  
3c35 b7					or a  
3c36 ed 52		                sbc hl, de 
3c38			 
3c38					;call cmp16 
3c38			 
3c38 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3c3a e1					pop hl 
3c3b e5					push hl 
3c3c			 
3c3c					if DEBUG_FORTH_WORDS 
3c3c						DMARK "RN4" 
3c3c f5				push af  
3c3d 3a 51 3c			ld a, (.dmark)  
3c40 32 b4 fe			ld (debug_mark),a  
3c43 3a 52 3c			ld a, (.dmark+1)  
3c46 32 b5 fe			ld (debug_mark+1),a  
3c49 3a 53 3c			ld a, (.dmark+2)  
3c4c 32 b6 fe			ld (debug_mark+2),a  
3c4f 18 03			jr .pastdmark  
3c51 ..			.dmark: db "RN4"  
3c54 f1			.pastdmark: pop af  
3c55			endm  
# End of macro DMARK
3c55						CALLMONITOR 
3c55 cd c6 18			call break_point_state  
3c58				endm  
# End of macro CALLMONITOR
3c58					endif 
3c58 ed 5b 3b fd			ld de, (LFSRSeed+2)   ; check low range 
3c5c					;call cmp16 
3c5c				 
3c5c b7					or a  
3c5d ed 52		                sbc hl, de 
3c5f 38 8c				jr c, .inrange 
3c61			 
3c61 e1					pop hl 
3c62					 
3c62					if DEBUG_FORTH_WORDS 
3c62						DMARK "RNd" 
3c62 f5				push af  
3c63 3a 77 3c			ld a, (.dmark)  
3c66 32 b4 fe			ld (debug_mark),a  
3c69 3a 78 3c			ld a, (.dmark+1)  
3c6c 32 b5 fe			ld (debug_mark+1),a  
3c6f 3a 79 3c			ld a, (.dmark+2)  
3c72 32 b6 fe			ld (debug_mark+2),a  
3c75 18 03			jr .pastdmark  
3c77 ..			.dmark: db "RNd"  
3c7a f1			.pastdmark: pop af  
3c7b			endm  
# End of macro DMARK
3c7b						CALLMONITOR 
3c7b cd c6 18			call break_point_state  
3c7e				endm  
# End of macro CALLMONITOR
3c7e					endif 
3c7e			 
3c7e			 
3c7e cd 3a 1f				call forth_push_numhl 
3c81				       NEXTW 
3c81 c3 a8 22			jp macro_next 
3c84				endm 
# End of macro NEXTW
3c84			 
3c84			.ENDMATHS: 
3c84			 
3c84			; eof 
3c84			 
# End of file forth_words_maths.asm
3c84			include "forth_words_display.asm" 
3c84			 
3c84			; | ## Display Words 
3c84			 
3c84			.INFO: 
3c84			 
3c84				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3c84 62				db WORD_SYS_CORE+78             
3c85 a1 3c			dw .ATP            
3c87 05				db 4 + 1 
3c88 .. 00			db "INFO",0              
3c8d				endm 
# End of macro CWHEAD
3c8d			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3c8d					FORTH_DSP_VALUEHL 
3c8d cd 31 21			call macro_dsp_valuehl 
3c90				endm 
# End of macro FORTH_DSP_VALUEHL
3c90			 
3c90					FORTH_DSP_POP 
3c90 cd e9 21			call macro_forth_dsp_pop 
3c93				endm 
# End of macro FORTH_DSP_POP
3c93			 
3c93 e5					push hl 
3c94			 
3c94					FORTH_DSP_VALUEHL 
3c94 cd 31 21			call macro_dsp_valuehl 
3c97				endm 
# End of macro FORTH_DSP_VALUEHL
3c97			 
3c97					FORTH_DSP_POP 
3c97 cd e9 21			call macro_forth_dsp_pop 
3c9a				endm 
# End of macro FORTH_DSP_POP
3c9a			 
3c9a d1					pop de 
3c9b			 
3c9b cd a6 0c				call info_panel 
3c9e			 
3c9e			 
3c9e					NEXTW 
3c9e c3 a8 22			jp macro_next 
3ca1				endm 
# End of macro NEXTW
3ca1			.ATP: 
3ca1				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3ca1 62				db WORD_SYS_CORE+78             
3ca2 18 3d			dw .FB            
3ca4 04				db 3 + 1 
3ca5 .. 00			db "AT?",0              
3ca9				endm 
# End of macro CWHEAD
3ca9			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3ca9					if DEBUG_FORTH_WORDS_KEY 
3ca9						DMARK "AT?" 
3ca9 f5				push af  
3caa 3a be 3c			ld a, (.dmark)  
3cad 32 b4 fe			ld (debug_mark),a  
3cb0 3a bf 3c			ld a, (.dmark+1)  
3cb3 32 b5 fe			ld (debug_mark+1),a  
3cb6 3a c0 3c			ld a, (.dmark+2)  
3cb9 32 b6 fe			ld (debug_mark+2),a  
3cbc 18 03			jr .pastdmark  
3cbe ..			.dmark: db "AT?"  
3cc1 f1			.pastdmark: pop af  
3cc2			endm  
# End of macro DMARK
3cc2						CALLMONITOR 
3cc2 cd c6 18			call break_point_state  
3cc5				endm  
# End of macro CALLMONITOR
3cc5					endif 
3cc5 3a eb fb				ld a, (f_cursor_ptr) 
3cc8			 
3cc8			if DEBUG_FORTH_WORDS 
3cc8				DMARK "AT?" 
3cc8 f5				push af  
3cc9 3a dd 3c			ld a, (.dmark)  
3ccc 32 b4 fe			ld (debug_mark),a  
3ccf 3a de 3c			ld a, (.dmark+1)  
3cd2 32 b5 fe			ld (debug_mark+1),a  
3cd5 3a df 3c			ld a, (.dmark+2)  
3cd8 32 b6 fe			ld (debug_mark+2),a  
3cdb 18 03			jr .pastdmark  
3cdd ..			.dmark: db "AT?"  
3ce0 f1			.pastdmark: pop af  
3ce1			endm  
# End of macro DMARK
3ce1				CALLMONITOR 
3ce1 cd c6 18			call break_point_state  
3ce4				endm  
# End of macro CALLMONITOR
3ce4			endif	 
3ce4					; count the number of rows 
3ce4			 
3ce4 06 00				ld b, 0 
3ce6 4f			.atpr:		ld c, a    ; save in case we go below zero 
3ce7 d6 14				sub display_cols 
3ce9 f2 ef 3c				jp p, .atprunder 
3cec 04					inc b 
3ced 18 f7				jr .atpr 
3cef			.atprunder:	 
3cef			if DEBUG_FORTH_WORDS 
3cef				DMARK "A?2" 
3cef f5				push af  
3cf0 3a 04 3d			ld a, (.dmark)  
3cf3 32 b4 fe			ld (debug_mark),a  
3cf6 3a 05 3d			ld a, (.dmark+1)  
3cf9 32 b5 fe			ld (debug_mark+1),a  
3cfc 3a 06 3d			ld a, (.dmark+2)  
3cff 32 b6 fe			ld (debug_mark+2),a  
3d02 18 03			jr .pastdmark  
3d04 ..			.dmark: db "A?2"  
3d07 f1			.pastdmark: pop af  
3d08			endm  
# End of macro DMARK
3d08				CALLMONITOR 
3d08 cd c6 18			call break_point_state  
3d0b				endm  
# End of macro CALLMONITOR
3d0b			endif	 
3d0b 26 00				ld h, 0 
3d0d 69					ld l, c 
3d0e cd 3a 1f				call forth_push_numhl 
3d11 68					ld l, b  
3d12 cd 3a 1f				call forth_push_numhl 
3d15			 
3d15			 
3d15				NEXTW 
3d15 c3 a8 22			jp macro_next 
3d18				endm 
# End of macro NEXTW
3d18			 
3d18			.FB: 
3d18				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3d18 1b				db WORD_SYS_CORE+7             
3d19 66 3d			dw .EMIT            
3d1b 03				db 2 + 1 
3d1c .. 00			db "FB",0              
3d1f				endm 
# End of macro CWHEAD
3d1f			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3d1f			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3d1f			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3d1f			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3d1f					if DEBUG_FORTH_WORDS_KEY 
3d1f						DMARK "FB." 
3d1f f5				push af  
3d20 3a 34 3d			ld a, (.dmark)  
3d23 32 b4 fe			ld (debug_mark),a  
3d26 3a 35 3d			ld a, (.dmark+1)  
3d29 32 b5 fe			ld (debug_mark+1),a  
3d2c 3a 36 3d			ld a, (.dmark+2)  
3d2f 32 b6 fe			ld (debug_mark+2),a  
3d32 18 03			jr .pastdmark  
3d34 ..			.dmark: db "FB."  
3d37 f1			.pastdmark: pop af  
3d38			endm  
# End of macro DMARK
3d38						CALLMONITOR 
3d38 cd c6 18			call break_point_state  
3d3b				endm  
# End of macro CALLMONITOR
3d3b					endif 
3d3b			 
3d3b					FORTH_DSP_VALUEHL 
3d3b cd 31 21			call macro_dsp_valuehl 
3d3e				endm 
# End of macro FORTH_DSP_VALUEHL
3d3e			 
3d3e 7d					ld a, l 
3d3f fe 01				cp 1 
3d41 20 05				jr nz, .fbn1 
3d43 21 f9 fd				ld hl, display_fb1 
3d46 18 15				jr .fbset 
3d48 fe 02		.fbn1:		cp 2 
3d4a 20 05				jr nz, .fbn2 
3d4c 21 57 fd				ld hl, display_fb2 
3d4f 18 0c				jr .fbset 
3d51 fe 03		.fbn2:		cp 3 
3d53 20 05				jr nz, .fbn3 
3d55 21 a8 fd				ld hl, display_fb3 
3d58 18 03				jr .fbset 
3d5a			.fbn3:		 ; if invalid number select first 
3d5a 21 f9 fd				ld hl, display_fb1 
3d5d 22 55 fd		.fbset:		ld (display_fb_active), hl 
3d60			 
3d60					FORTH_DSP_POP 
3d60 cd e9 21			call macro_forth_dsp_pop 
3d63				endm 
# End of macro FORTH_DSP_POP
3d63			 
3d63					NEXTW 
3d63 c3 a8 22			jp macro_next 
3d66				endm 
# End of macro NEXTW
3d66			 
3d66			 
3d66			.EMIT: 
3d66				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3d66 1b				db WORD_SYS_CORE+7             
3d67 b7 3d			dw .DOTH            
3d69 05				db 4 + 1 
3d6a .. 00			db "EMIT",0              
3d6f				endm 
# End of macro CWHEAD
3d6f			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3d6f					; get value off TOS and display it 
3d6f			 
3d6f					if DEBUG_FORTH_WORDS_KEY 
3d6f						DMARK "EMT" 
3d6f f5				push af  
3d70 3a 84 3d			ld a, (.dmark)  
3d73 32 b4 fe			ld (debug_mark),a  
3d76 3a 85 3d			ld a, (.dmark+1)  
3d79 32 b5 fe			ld (debug_mark+1),a  
3d7c 3a 86 3d			ld a, (.dmark+2)  
3d7f 32 b6 fe			ld (debug_mark+2),a  
3d82 18 03			jr .pastdmark  
3d84 ..			.dmark: db "EMT"  
3d87 f1			.pastdmark: pop af  
3d88			endm  
# End of macro DMARK
3d88						CALLMONITOR 
3d88 cd c6 18			call break_point_state  
3d8b				endm  
# End of macro CALLMONITOR
3d8b					endif 
3d8b			 
3d8b					FORTH_DSP_VALUEHL 
3d8b cd 31 21			call macro_dsp_valuehl 
3d8e				endm 
# End of macro FORTH_DSP_VALUEHL
3d8e			 
3d8e 7d					ld a,l 
3d8f			 
3d8f					; TODO write to display 
3d8f			 
3d8f 32 80 f5				ld (os_input), a 
3d92 3e 00				ld a, 0 
3d94 32 81 f5				ld (os_input+1), a 
3d97					 
3d97 3a eb fb				ld a, (f_cursor_ptr) 
3d9a 11 80 f5				ld de, os_input 
3d9d cd 28 0d				call str_at_display 
3da0			 
3da0			 
3da0 3a c9 fb				ld a,(cli_autodisplay) 
3da3 fe 00				cp 0 
3da5 28 03				jr z, .enoupdate 
3da7 cd 38 0d						call update_display 
3daa					.enoupdate: 
3daa			 
3daa 3a eb fb				ld a, (f_cursor_ptr) 
3dad 3c					inc a 
3dae 32 eb fb				ld (f_cursor_ptr), a   ; save new pos 
3db1			 
3db1			 
3db1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3db1 cd e9 21			call macro_forth_dsp_pop 
3db4				endm 
# End of macro FORTH_DSP_POP
3db4			  
3db4			 
3db4					NEXTW 
3db4 c3 a8 22			jp macro_next 
3db7				endm 
# End of macro NEXTW
3db7			.DOTH: 
3db7				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3db7 1c				db WORD_SYS_CORE+8             
3db8 e7 3d			dw .DOTF            
3dba 03				db 2 + 1 
3dbb .. 00			db ".-",0              
3dbe				endm 
# End of macro CWHEAD
3dbe			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3dbe					; get value off TOS and display it 
3dbe					if DEBUG_FORTH_WORDS_KEY 
3dbe						DMARK "DTD" 
3dbe f5				push af  
3dbf 3a d3 3d			ld a, (.dmark)  
3dc2 32 b4 fe			ld (debug_mark),a  
3dc5 3a d4 3d			ld a, (.dmark+1)  
3dc8 32 b5 fe			ld (debug_mark+1),a  
3dcb 3a d5 3d			ld a, (.dmark+2)  
3dce 32 b6 fe			ld (debug_mark+2),a  
3dd1 18 03			jr .pastdmark  
3dd3 ..			.dmark: db "DTD"  
3dd6 f1			.pastdmark: pop af  
3dd7			endm  
# End of macro DMARK
3dd7						CALLMONITOR 
3dd7 cd c6 18			call break_point_state  
3dda				endm  
# End of macro CALLMONITOR
3dda					endif 
3dda 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3ddc 3e 00			ld a, 0 
3dde 32 ca fb			ld (cli_mvdot), a 
3de1 c3 3e 3e			jp .dotgo 
3de4				NEXTW 
3de4 c3 a8 22			jp macro_next 
3de7				endm 
# End of macro NEXTW
3de7			.DOTF: 
3de7				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3de7 1c				db WORD_SYS_CORE+8             
3de8 15 3e			dw .DOT            
3dea 03				db 2 + 1 
3deb .. 00			db ".>",0              
3dee				endm 
# End of macro CWHEAD
3dee			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3dee					; get value off TOS and display it 
3dee			        ; TODO BUG adds extra spaces 
3dee			        ; TODO BUG handle numerics? 
3dee					if DEBUG_FORTH_WORDS_KEY 
3dee						DMARK "DTC" 
3dee f5				push af  
3def 3a 03 3e			ld a, (.dmark)  
3df2 32 b4 fe			ld (debug_mark),a  
3df5 3a 04 3e			ld a, (.dmark+1)  
3df8 32 b5 fe			ld (debug_mark+1),a  
3dfb 3a 05 3e			ld a, (.dmark+2)  
3dfe 32 b6 fe			ld (debug_mark+2),a  
3e01 18 03			jr .pastdmark  
3e03 ..			.dmark: db "DTC"  
3e06 f1			.pastdmark: pop af  
3e07			endm  
# End of macro DMARK
3e07						CALLMONITOR 
3e07 cd c6 18			call break_point_state  
3e0a				endm  
# End of macro CALLMONITOR
3e0a					endif 
3e0a 3e 01			ld a, 1 
3e0c 32 ca fb			ld (cli_mvdot), a 
3e0f c3 3e 3e			jp .dotgo 
3e12				NEXTW 
3e12 c3 a8 22			jp macro_next 
3e15				endm 
# End of macro NEXTW
3e15			 
3e15			.DOT: 
3e15				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3e15 1c				db WORD_SYS_CORE+8             
3e16 a1 3e			dw .CLS            
3e18 02				db 1 + 1 
3e19 .. 00			db ".",0              
3e1b				endm 
# End of macro CWHEAD
3e1b			        ; | . ( u -- ) Display TOS | DONE 
3e1b					; get value off TOS and display it 
3e1b			 
3e1b					if DEBUG_FORTH_WORDS_KEY 
3e1b						DMARK "DOT" 
3e1b f5				push af  
3e1c 3a 30 3e			ld a, (.dmark)  
3e1f 32 b4 fe			ld (debug_mark),a  
3e22 3a 31 3e			ld a, (.dmark+1)  
3e25 32 b5 fe			ld (debug_mark+1),a  
3e28 3a 32 3e			ld a, (.dmark+2)  
3e2b 32 b6 fe			ld (debug_mark+2),a  
3e2e 18 03			jr .pastdmark  
3e30 ..			.dmark: db "DOT"  
3e33 f1			.pastdmark: pop af  
3e34			endm  
# End of macro DMARK
3e34						CALLMONITOR 
3e34 cd c6 18			call break_point_state  
3e37				endm  
# End of macro CALLMONITOR
3e37					endif 
3e37 3e 00			ld a, 0 
3e39 32 ca fb			ld (cli_mvdot), a 
3e3c 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3e3e				 
3e3e			 
3e3e			.dotgo: 
3e3e			 
3e3e			; move up type to on stack for parserv5 
3e3e					FORTH_DSP 
3e3e cd f7 20			call macro_forth_dsp 
3e41				endm 
# End of macro FORTH_DSP
3e41				;FORTH_DSP_VALUE  
3e41			 
3e41			if DEBUG_FORTH_DOT 
3e41				DMARK "DOT" 
3e41				CALLMONITOR 
3e41			endif	 
3e41			;		.print: 
3e41			 
3e41 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3e42 23				inc hl   ; position to the actual value 
3e43 fe 01			cp DS_TYPE_STR 
3e45 20 06			jr nz, .dotnum1  
3e47			 
3e47			; display string 
3e47				FORTH_DSP_VALUE  
3e47 cd 1a 21			call macro_forth_dsp_value 
3e4a				endm 
# End of macro FORTH_DSP_VALUE
3e4a eb				ex de,hl 
3e4b 18 11			jr .dotwrite 
3e4d			 
3e4d			.dotnum1: 
3e4d fe 02			cp DS_TYPE_INUM 
3e4f 20 0c			jr nz, .dotflot 
3e51			 
3e51			 
3e51			; display number 
3e51			 
3e51			;	push hl 
3e51			;	call clear_display 
3e51			;	pop hl 
3e51			 
3e51 5e				ld e, (hl) 
3e52 23				inc hl 
3e53 56				ld d, (hl) 
3e54 21 82 f3			ld hl, scratch 
3e57			if DEBUG_FORTH_DOT 
3e57				DMARK "DT1" 
3e57				CALLMONITOR 
3e57			endif	 
3e57			 
3e57 cd 56 13			call uitoa_16 
3e5a eb				ex de,hl 
3e5b			 
3e5b			if DEBUG_FORTH_DOT 
3e5b				DMARK "DT2" 
3e5b				CALLMONITOR 
3e5b			endif	 
3e5b			 
3e5b			;	ld de, os_word_scratch 
3e5b 18 01			jr .dotwrite 
3e5d			 
3e5d 00			.dotflot:   nop 
3e5e			; TODO print floating point number 
3e5e			 
3e5e			.dotwrite:		 
3e5e			 
3e5e					; if c is set then set all '-' to spaces 
3e5e					; need to also take into account .>  
3e5e			 
3e5e 3e 01				ld a, 1 
3e60 b9					cp c 
3e61 20 13				jr nz, .nodashswap 
3e63			 
3e63					; DE has the string to write, working with HL 
3e63			 
3e63 06 ff				ld b, 255 
3e65 d5					push de 
3e66 e1					pop hl 
3e67			 
3e67			if DEBUG_FORTH_DOT 
3e67				DMARK "DT-" 
3e67				CALLMONITOR 
3e67			endif	 
3e67 7e			.dashscan:	ld a, (hl) 
3e68 fe 00				cp 0 
3e6a 28 0a				jr z, .nodashswap 
3e6c fe 2d				cp '-' 
3e6e 20 03				jr nz, .dashskip 
3e70 3e 20				ld a, ' ' 
3e72 77					ld (hl), a 
3e73 23			.dashskip:	inc hl 
3e74			if DEBUG_FORTH_DOT 
3e74				DMARK "D-2" 
3e74				CALLMONITOR 
3e74			endif	 
3e74 10 f1				djnz .dashscan 
3e76			 
3e76			if DEBUG_FORTH_DOT 
3e76				DMARK "D-1" 
3e76				CALLMONITOR 
3e76			endif	 
3e76			 
3e76			.nodashswap: 
3e76			 
3e76 e5					push hl   ; save string start in case we need to advance print 
3e77			 
3e77 3a eb fb				ld a, (f_cursor_ptr) 
3e7a cd 28 0d				call str_at_display 
3e7d 3a c9 fb				ld a,(cli_autodisplay) 
3e80 fe 00				cp 0 
3e82 28 03				jr z, .noupdate 
3e84 cd 38 0d						call update_display 
3e87					.noupdate: 
3e87			 
3e87			 
3e87					; see if we need to advance the print position 
3e87			 
3e87 e1					pop hl   ; get back string 
3e88			 
3e88 3a ca fb				ld a, (cli_mvdot) 
3e8b			if DEBUG_FORTH_DOT 
3e8b					ld e,a 
3e8b				DMARK "D>1" 
3e8b				CALLMONITOR 
3e8b			endif	 
3e8b fe 00				cp 0 
3e8d 28 0c				jr z, .noadv 
3e8f					; yes, lets advance the print position 
3e8f 3e 00				ld a, 0 
3e91 cd b2 13				call strlent 
3e94 3a eb fb				ld a, (f_cursor_ptr) 
3e97 85					add a,l 
3e98					;call addatohl 
3e98					;ld a, l 
3e98 32 eb fb				ld (f_cursor_ptr), a   ; save new pos 
3e9b			 
3e9b			if DEBUG_FORTH_DOT 
3e9b				DMARK "D->" 
3e9b				CALLMONITOR 
3e9b			endif	 
3e9b			 
3e9b			.noadv:	 
3e9b			 
3e9b					if DEBUG_FORTH_DOT_WAIT 
3e9b							call next_page_prompt 
3e9b					endif	 
3e9b			; TODO this pop off the stack causes a crash. i dont know why 
3e9b			 
3e9b			 
3e9b			if DEBUG_FORTH_DOT 
3e9b				DMARK "DTh" 
3e9b				CALLMONITOR 
3e9b			endif	 
3e9b			 
3e9b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e9b cd e9 21			call macro_forth_dsp_pop 
3e9e				endm 
# End of macro FORTH_DSP_POP
3e9e			 
3e9e			if DEBUG_FORTH_DOT 
3e9e				DMARK "DTi" 
3e9e				CALLMONITOR 
3e9e			endif	 
3e9e			 
3e9e			 
3e9e					NEXTW 
3e9e c3 a8 22			jp macro_next 
3ea1				endm 
# End of macro NEXTW
3ea1			 
3ea1			.CLS: 
3ea1				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3ea1 35				db WORD_SYS_CORE+33             
3ea2 ce 3e			dw .DRAW            
3ea4 04				db 3 + 1 
3ea5 .. 00			db "CLS",0              
3ea9				endm 
# End of macro CWHEAD
3ea9			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3ea9					if DEBUG_FORTH_WORDS_KEY 
3ea9						DMARK "CLS" 
3ea9 f5				push af  
3eaa 3a be 3e			ld a, (.dmark)  
3ead 32 b4 fe			ld (debug_mark),a  
3eb0 3a bf 3e			ld a, (.dmark+1)  
3eb3 32 b5 fe			ld (debug_mark+1),a  
3eb6 3a c0 3e			ld a, (.dmark+2)  
3eb9 32 b6 fe			ld (debug_mark+2),a  
3ebc 18 03			jr .pastdmark  
3ebe ..			.dmark: db "CLS"  
3ec1 f1			.pastdmark: pop af  
3ec2			endm  
# End of macro DMARK
3ec2						CALLMONITOR 
3ec2 cd c6 18			call break_point_state  
3ec5				endm  
# End of macro CALLMONITOR
3ec5					endif 
3ec5 cd 15 0d				call clear_display 
3ec8 c3 dc 3f				jp .home		; and home cursor 
3ecb					NEXTW 
3ecb c3 a8 22			jp macro_next 
3ece				endm 
# End of macro NEXTW
3ece			 
3ece			.DRAW: 
3ece				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3ece 36				db WORD_SYS_CORE+34             
3ecf f9 3e			dw .DUMP            
3ed1 05				db 4 + 1 
3ed2 .. 00			db "DRAW",0              
3ed7				endm 
# End of macro CWHEAD
3ed7			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3ed7					if DEBUG_FORTH_WORDS_KEY 
3ed7						DMARK "DRW" 
3ed7 f5				push af  
3ed8 3a ec 3e			ld a, (.dmark)  
3edb 32 b4 fe			ld (debug_mark),a  
3ede 3a ed 3e			ld a, (.dmark+1)  
3ee1 32 b5 fe			ld (debug_mark+1),a  
3ee4 3a ee 3e			ld a, (.dmark+2)  
3ee7 32 b6 fe			ld (debug_mark+2),a  
3eea 18 03			jr .pastdmark  
3eec ..			.dmark: db "DRW"  
3eef f1			.pastdmark: pop af  
3ef0			endm  
# End of macro DMARK
3ef0						CALLMONITOR 
3ef0 cd c6 18			call break_point_state  
3ef3				endm  
# End of macro CALLMONITOR
3ef3					endif 
3ef3 cd 38 0d				call update_display 
3ef6					NEXTW 
3ef6 c3 a8 22			jp macro_next 
3ef9				endm 
# End of macro NEXTW
3ef9			 
3ef9			.DUMP: 
3ef9				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3ef9 37				db WORD_SYS_CORE+35             
3efa 31 3f			dw .CDUMP            
3efc 05				db 4 + 1 
3efd .. 00			db "DUMP",0              
3f02				endm 
# End of macro CWHEAD
3f02			; | DUMP ( x -- ) With address x display dump   | DONE 
3f02			; TODO pop address to use off of the stack 
3f02					if DEBUG_FORTH_WORDS_KEY 
3f02						DMARK "DUM" 
3f02 f5				push af  
3f03 3a 17 3f			ld a, (.dmark)  
3f06 32 b4 fe			ld (debug_mark),a  
3f09 3a 18 3f			ld a, (.dmark+1)  
3f0c 32 b5 fe			ld (debug_mark+1),a  
3f0f 3a 19 3f			ld a, (.dmark+2)  
3f12 32 b6 fe			ld (debug_mark+2),a  
3f15 18 03			jr .pastdmark  
3f17 ..			.dmark: db "DUM"  
3f1a f1			.pastdmark: pop af  
3f1b			endm  
# End of macro DMARK
3f1b						CALLMONITOR 
3f1b cd c6 18			call break_point_state  
3f1e				endm  
# End of macro CALLMONITOR
3f1e					endif 
3f1e cd 15 0d				call clear_display 
3f21			 
3f21					; get address 
3f21			 
3f21					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f21 cd 31 21			call macro_dsp_valuehl 
3f24				endm 
# End of macro FORTH_DSP_VALUEHL
3f24				 
3f24					; save it for cdump 
3f24			 
3f24 22 a5 f6				ld (os_cur_ptr),hl 
3f27			 
3f27					; destroy value TOS 
3f27			 
3f27					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f27 cd e9 21			call macro_forth_dsp_pop 
3f2a				endm 
# End of macro FORTH_DSP_POP
3f2a			 
3f2a cd ba 1d				call dumpcont	; skip old style of param parsing	 
3f2d c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3f2e					NEXTW 
3f2e c3 a8 22			jp macro_next 
3f31				endm 
# End of macro NEXTW
3f31			.CDUMP: 
3f31				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3f31 38				db WORD_SYS_CORE+36             
3f32 61 3f			dw .DAT            
3f34 06				db 5 + 1 
3f35 .. 00			db "CDUMP",0              
3f3b				endm 
# End of macro CWHEAD
3f3b			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3f3b					if DEBUG_FORTH_WORDS_KEY 
3f3b						DMARK "CDP" 
3f3b f5				push af  
3f3c 3a 50 3f			ld a, (.dmark)  
3f3f 32 b4 fe			ld (debug_mark),a  
3f42 3a 51 3f			ld a, (.dmark+1)  
3f45 32 b5 fe			ld (debug_mark+1),a  
3f48 3a 52 3f			ld a, (.dmark+2)  
3f4b 32 b6 fe			ld (debug_mark+2),a  
3f4e 18 03			jr .pastdmark  
3f50 ..			.dmark: db "CDP"  
3f53 f1			.pastdmark: pop af  
3f54			endm  
# End of macro DMARK
3f54						CALLMONITOR 
3f54 cd c6 18			call break_point_state  
3f57				endm  
# End of macro CALLMONITOR
3f57					endif 
3f57 cd 15 0d				call clear_display 
3f5a cd ba 1d				call dumpcont	 
3f5d c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3f5e					NEXTW 
3f5e c3 a8 22			jp macro_next 
3f61				endm 
# End of macro NEXTW
3f61			 
3f61			 
3f61			 
3f61			 
3f61			.DAT: 
3f61				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3f61 3d				db WORD_SYS_CORE+41             
3f62 b7 3f			dw .HOME            
3f64 03				db 2 + 1 
3f65 .. 00			db "AT",0              
3f68				endm 
# End of macro CWHEAD
3f68			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3f68					if DEBUG_FORTH_WORDS_KEY 
3f68						DMARK "AT." 
3f68 f5				push af  
3f69 3a 7d 3f			ld a, (.dmark)  
3f6c 32 b4 fe			ld (debug_mark),a  
3f6f 3a 7e 3f			ld a, (.dmark+1)  
3f72 32 b5 fe			ld (debug_mark+1),a  
3f75 3a 7f 3f			ld a, (.dmark+2)  
3f78 32 b6 fe			ld (debug_mark+2),a  
3f7b 18 03			jr .pastdmark  
3f7d ..			.dmark: db "AT."  
3f80 f1			.pastdmark: pop af  
3f81			endm  
# End of macro DMARK
3f81						CALLMONITOR 
3f81 cd c6 18			call break_point_state  
3f84				endm  
# End of macro CALLMONITOR
3f84					endif 
3f84					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f84 cd 31 21			call macro_dsp_valuehl 
3f87				endm 
# End of macro FORTH_DSP_VALUEHL
3f87			 
3f87			 
3f87					; TODO save cursor row 
3f87 7d					ld a,l 
3f88 fe 02				cp 2 
3f8a 20 04				jr nz, .crow3 
3f8c 3e 14				ld a, display_row_2 
3f8e 18 12				jr .ccol1 
3f90 fe 03		.crow3:		cp 3 
3f92 20 04				jr nz, .crow4 
3f94 3e 28				ld a, display_row_3 
3f96 18 0a				jr .ccol1 
3f98 fe 04		.crow4:		cp 4 
3f9a 20 04				jr nz, .crow1 
3f9c 3e 3c				ld a, display_row_4 
3f9e 18 02				jr .ccol1 
3fa0 3e 00		.crow1:		ld a,display_row_1 
3fa2 f5			.ccol1:		push af			; got row offset 
3fa3 6f					ld l,a 
3fa4 26 00				ld h,0 
3fa6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3fa6 cd e9 21			call macro_forth_dsp_pop 
3fa9				endm 
# End of macro FORTH_DSP_POP
3fa9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3fa9 cd 31 21			call macro_dsp_valuehl 
3fac				endm 
# End of macro FORTH_DSP_VALUEHL
3fac					; TODO save cursor col 
3fac f1					pop af 
3fad 85					add l		; add col offset 
3fae 32 eb fb				ld (f_cursor_ptr), a 
3fb1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3fb1 cd e9 21			call macro_forth_dsp_pop 
3fb4				endm 
# End of macro FORTH_DSP_POP
3fb4			 
3fb4					; calculate  
3fb4			 
3fb4					NEXTW 
3fb4 c3 a8 22			jp macro_next 
3fb7				endm 
# End of macro NEXTW
3fb7			 
3fb7			 
3fb7			.HOME: 
3fb7				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3fb7 41				db WORD_SYS_CORE+45             
3fb8 e4 3f			dw .SPACE            
3fba 05				db 4 + 1 
3fbb .. 00			db "HOME",0              
3fc0				endm 
# End of macro CWHEAD
3fc0			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3fc0					if DEBUG_FORTH_WORDS_KEY 
3fc0						DMARK "HOM" 
3fc0 f5				push af  
3fc1 3a d5 3f			ld a, (.dmark)  
3fc4 32 b4 fe			ld (debug_mark),a  
3fc7 3a d6 3f			ld a, (.dmark+1)  
3fca 32 b5 fe			ld (debug_mark+1),a  
3fcd 3a d7 3f			ld a, (.dmark+2)  
3fd0 32 b6 fe			ld (debug_mark+2),a  
3fd3 18 03			jr .pastdmark  
3fd5 ..			.dmark: db "HOM"  
3fd8 f1			.pastdmark: pop af  
3fd9			endm  
# End of macro DMARK
3fd9						CALLMONITOR 
3fd9 cd c6 18			call break_point_state  
3fdc				endm  
# End of macro CALLMONITOR
3fdc					endif 
3fdc 3e 00		.home:		ld a, 0		; and home cursor 
3fde 32 eb fb				ld (f_cursor_ptr), a 
3fe1					NEXTW 
3fe1 c3 a8 22			jp macro_next 
3fe4				endm 
# End of macro NEXTW
3fe4			 
3fe4			 
3fe4			.SPACE: 
3fe4				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3fe4 46				db WORD_SYS_CORE+50             
3fe5 12 40			dw .SPACES            
3fe7 03				db 2 + 1 
3fe8 .. 00			db "BL",0              
3feb				endm 
# End of macro CWHEAD
3feb			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3feb					if DEBUG_FORTH_WORDS_KEY 
3feb						DMARK "BL." 
3feb f5				push af  
3fec 3a 00 40			ld a, (.dmark)  
3fef 32 b4 fe			ld (debug_mark),a  
3ff2 3a 01 40			ld a, (.dmark+1)  
3ff5 32 b5 fe			ld (debug_mark+1),a  
3ff8 3a 02 40			ld a, (.dmark+2)  
3ffb 32 b6 fe			ld (debug_mark+2),a  
3ffe 18 03			jr .pastdmark  
4000 ..			.dmark: db "BL."  
4003 f1			.pastdmark: pop af  
4004			endm  
# End of macro DMARK
4004						CALLMONITOR 
4004 cd c6 18			call break_point_state  
4007				endm  
# End of macro CALLMONITOR
4007					endif 
4007 21 10 40				ld hl, .blstr 
400a cd a8 1f				call forth_push_str 
400d					 
400d				       NEXTW 
400d c3 a8 22			jp macro_next 
4010				endm 
# End of macro NEXTW
4010			 
4010 .. 00		.blstr: db " ", 0 
4012			 
4012			.SPACES: 
4012				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
4012 47				db WORD_SYS_CORE+51             
4013 ad 40			dw .SCROLL            
4015 07				db 6 + 1 
4016 .. 00			db "SPACES",0              
401d				endm 
# End of macro CWHEAD
401d			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
401d					if DEBUG_FORTH_WORDS_KEY 
401d						DMARK "SPS" 
401d f5				push af  
401e 3a 32 40			ld a, (.dmark)  
4021 32 b4 fe			ld (debug_mark),a  
4024 3a 33 40			ld a, (.dmark+1)  
4027 32 b5 fe			ld (debug_mark+1),a  
402a 3a 34 40			ld a, (.dmark+2)  
402d 32 b6 fe			ld (debug_mark+2),a  
4030 18 03			jr .pastdmark  
4032 ..			.dmark: db "SPS"  
4035 f1			.pastdmark: pop af  
4036			endm  
# End of macro DMARK
4036						CALLMONITOR 
4036 cd c6 18			call break_point_state  
4039				endm  
# End of macro CALLMONITOR
4039					endif 
4039			 
4039			 
4039					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4039 cd 31 21			call macro_dsp_valuehl 
403c				endm 
# End of macro FORTH_DSP_VALUEHL
403c			 
403c			;		push hl    ; u 
403c					if DEBUG_FORTH_WORDS 
403c						DMARK "SPA" 
403c f5				push af  
403d 3a 51 40			ld a, (.dmark)  
4040 32 b4 fe			ld (debug_mark),a  
4043 3a 52 40			ld a, (.dmark+1)  
4046 32 b5 fe			ld (debug_mark+1),a  
4049 3a 53 40			ld a, (.dmark+2)  
404c 32 b6 fe			ld (debug_mark+2),a  
404f 18 03			jr .pastdmark  
4051 ..			.dmark: db "SPA"  
4054 f1			.pastdmark: pop af  
4055			endm  
# End of macro DMARK
4055						CALLMONITOR 
4055 cd c6 18			call break_point_state  
4058				endm  
# End of macro CALLMONITOR
4058					endif 
4058			 
4058					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4058 cd e9 21			call macro_forth_dsp_pop 
405b				endm 
# End of macro FORTH_DSP_POP
405b			;		pop hl 
405b 4d					ld c, l 
405c 06 00				ld b, 0 
405e 21 82 f3				ld hl, scratch  
4061			 
4061					if DEBUG_FORTH_WORDS 
4061						DMARK "SP2" 
4061 f5				push af  
4062 3a 76 40			ld a, (.dmark)  
4065 32 b4 fe			ld (debug_mark),a  
4068 3a 77 40			ld a, (.dmark+1)  
406b 32 b5 fe			ld (debug_mark+1),a  
406e 3a 78 40			ld a, (.dmark+2)  
4071 32 b6 fe			ld (debug_mark+2),a  
4074 18 03			jr .pastdmark  
4076 ..			.dmark: db "SP2"  
4079 f1			.pastdmark: pop af  
407a			endm  
# End of macro DMARK
407a						CALLMONITOR 
407a cd c6 18			call break_point_state  
407d				endm  
# End of macro CALLMONITOR
407d					endif 
407d 3e 20				ld a, ' ' 
407f c5			.spaces1:	push bc 
4080 77					ld (hl),a 
4081 23					inc hl 
4082 c1					pop bc 
4083 10 fa				djnz .spaces1 
4085 3e 00				ld a,0 
4087 77					ld (hl),a 
4088 21 82 f3				ld hl, scratch 
408b					if DEBUG_FORTH_WORDS 
408b						DMARK "SP3" 
408b f5				push af  
408c 3a a0 40			ld a, (.dmark)  
408f 32 b4 fe			ld (debug_mark),a  
4092 3a a1 40			ld a, (.dmark+1)  
4095 32 b5 fe			ld (debug_mark+1),a  
4098 3a a2 40			ld a, (.dmark+2)  
409b 32 b6 fe			ld (debug_mark+2),a  
409e 18 03			jr .pastdmark  
40a0 ..			.dmark: db "SP3"  
40a3 f1			.pastdmark: pop af  
40a4			endm  
# End of macro DMARK
40a4						CALLMONITOR 
40a4 cd c6 18			call break_point_state  
40a7				endm  
# End of macro CALLMONITOR
40a7					endif 
40a7 cd a3 20				call forth_apush 
40aa			 
40aa				       NEXTW 
40aa c3 a8 22			jp macro_next 
40ad				endm 
# End of macro NEXTW
40ad			 
40ad			 
40ad			 
40ad			.SCROLL: 
40ad				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
40ad 53				db WORD_SYS_CORE+63             
40ae da 40			dw .SCROLLD            
40b0 07				db 6 + 1 
40b1 .. 00			db "SCROLL",0              
40b8				endm 
# End of macro CWHEAD
40b8			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
40b8					if DEBUG_FORTH_WORDS_KEY 
40b8						DMARK "SCR" 
40b8 f5				push af  
40b9 3a cd 40			ld a, (.dmark)  
40bc 32 b4 fe			ld (debug_mark),a  
40bf 3a ce 40			ld a, (.dmark+1)  
40c2 32 b5 fe			ld (debug_mark+1),a  
40c5 3a cf 40			ld a, (.dmark+2)  
40c8 32 b6 fe			ld (debug_mark+2),a  
40cb 18 03			jr .pastdmark  
40cd ..			.dmark: db "SCR"  
40d0 f1			.pastdmark: pop af  
40d1			endm  
# End of macro DMARK
40d1						CALLMONITOR 
40d1 cd c6 18			call break_point_state  
40d4				endm  
# End of macro CALLMONITOR
40d4					endif 
40d4			 
40d4 cd d7 0c			call scroll_up 
40d7			;	call update_display 
40d7			 
40d7					NEXTW 
40d7 c3 a8 22			jp macro_next 
40da				endm 
# End of macro NEXTW
40da			 
40da			 
40da			 
40da			;		; get dir 
40da			; 
40da			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
40da			; 
40da			;		push hl 
40da			; 
40da			;		; destroy value TOS 
40da			; 
40da			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40da			; 
40da			;		; get count 
40da			; 
40da			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
40da			; 
40da			;		push hl 
40da			; 
40da			;		; destroy value TOS 
40da			; 
40da			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40da			; 
40da			;		; one value on hl get other one back 
40da			; 
40da			;		pop bc    ; count 
40da			; 
40da			;		pop de   ; dir 
40da			; 
40da			; 
40da			;		ld b, c 
40da			; 
40da			;.scrolldir:     push bc 
40da			;		push de 
40da			; 
40da			;		ld a, 0 
40da			;		cp e 
40da			;		jr z, .scrollup  
40da			;		call scroll_down 
40da			;		jr .scrollnext 
40da			;.scrollup:	call scroll_up 
40da			; 
40da			;		 
40da			;.scrollnext: 
40da			;		pop de 
40da			;		pop bc 
40da			;		djnz .scrolldir 
40da			; 
40da			; 
40da			; 
40da			; 
40da			; 
40da			;		NEXTW 
40da			 
40da			.SCROLLD: 
40da				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
40da 53				db WORD_SYS_CORE+63             
40db 08 41			dw .ATQ            
40dd 08				db 7 + 1 
40de .. 00			db "SCROLLD",0              
40e6				endm 
# End of macro CWHEAD
40e6			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
40e6					if DEBUG_FORTH_WORDS_KEY 
40e6						DMARK "SCD" 
40e6 f5				push af  
40e7 3a fb 40			ld a, (.dmark)  
40ea 32 b4 fe			ld (debug_mark),a  
40ed 3a fc 40			ld a, (.dmark+1)  
40f0 32 b5 fe			ld (debug_mark+1),a  
40f3 3a fd 40			ld a, (.dmark+2)  
40f6 32 b6 fe			ld (debug_mark+2),a  
40f9 18 03			jr .pastdmark  
40fb ..			.dmark: db "SCD"  
40fe f1			.pastdmark: pop af  
40ff			endm  
# End of macro DMARK
40ff						CALLMONITOR 
40ff cd c6 18			call break_point_state  
4102				endm  
# End of macro CALLMONITOR
4102					endif 
4102			 
4102 cd fb 0c			call scroll_down 
4105			;	call update_display 
4105			 
4105					NEXTW 
4105 c3 a8 22			jp macro_next 
4108				endm 
# End of macro NEXTW
4108			 
4108			 
4108			.ATQ: 
4108				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
4108 62				db WORD_SYS_CORE+78             
4109 66 41			dw .AUTODSP            
410b 04				db 3 + 1 
410c .. 00			db "AT@",0              
4110				endm 
# End of macro CWHEAD
4110			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
4110					if DEBUG_FORTH_WORDS_KEY 
4110						DMARK "ATA" 
4110 f5				push af  
4111 3a 25 41			ld a, (.dmark)  
4114 32 b4 fe			ld (debug_mark),a  
4117 3a 26 41			ld a, (.dmark+1)  
411a 32 b5 fe			ld (debug_mark+1),a  
411d 3a 27 41			ld a, (.dmark+2)  
4120 32 b6 fe			ld (debug_mark+2),a  
4123 18 03			jr .pastdmark  
4125 ..			.dmark: db "ATA"  
4128 f1			.pastdmark: pop af  
4129			endm  
# End of macro DMARK
4129						CALLMONITOR 
4129 cd c6 18			call break_point_state  
412c				endm  
# End of macro CALLMONITOR
412c					endif 
412c			 
412c			 
412c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
412c cd 31 21			call macro_dsp_valuehl 
412f				endm 
# End of macro FORTH_DSP_VALUEHL
412f			 
412f					; TODO save cursor row 
412f 7d					ld a,l 
4130 fe 02				cp 2 
4132 20 04				jr nz, .crow3aq 
4134 3e 14				ld a, display_row_2 
4136 18 12				jr .ccol1aq 
4138 fe 03		.crow3aq:		cp 3 
413a 20 04				jr nz, .crow4aq 
413c 3e 28				ld a, display_row_3 
413e 18 0a				jr .ccol1aq 
4140 fe 04		.crow4aq:		cp 4 
4142 20 04				jr nz, .crow1aq 
4144 3e 3c				ld a, display_row_4 
4146 18 02				jr .ccol1aq 
4148 3e 00		.crow1aq:		ld a,display_row_1 
414a f5			.ccol1aq:		push af			; got row offset 
414b 6f					ld l,a 
414c 26 00				ld h,0 
414e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
414e cd e9 21			call macro_forth_dsp_pop 
4151				endm 
# End of macro FORTH_DSP_POP
4151					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4151 cd 31 21			call macro_dsp_valuehl 
4154				endm 
# End of macro FORTH_DSP_VALUEHL
4154					; TODO save cursor col 
4154 f1					pop af 
4155 85					add l		; add col offset 
4156			 
4156					; add current frame buffer address 
4156 2a 55 fd				ld hl, (display_fb_active) 
4159 cd 49 0f				call addatohl 
415c			 
415c			 
415c			 
415c			 
415c					; get char frame buffer location offset in hl 
415c			 
415c 7e					ld a,(hl) 
415d 26 00				ld h, 0 
415f 6f					ld l, a 
4160			 
4160 cd 3a 1f				call forth_push_numhl 
4163			 
4163			 
4163					NEXTW 
4163 c3 a8 22			jp macro_next 
4166				endm 
# End of macro NEXTW
4166			 
4166			.AUTODSP: 
4166				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
4166 63				db WORD_SYS_CORE+79             
4167 7c 41			dw .MENU            
4169 05				db 4 + 1 
416a .. 00			db "ADSP",0              
416f				endm 
# End of macro CWHEAD
416f			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
416f			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
416f			 
416f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
416f cd 31 21			call macro_dsp_valuehl 
4172				endm 
# End of macro FORTH_DSP_VALUEHL
4172			 
4172			;		push hl 
4172			 
4172					; destroy value TOS 
4172			 
4172					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4172 cd e9 21			call macro_forth_dsp_pop 
4175				endm 
# End of macro FORTH_DSP_POP
4175			 
4175			;		pop hl 
4175			 
4175 7d					ld a,l 
4176 32 c9 fb				ld (cli_autodisplay), a 
4179				       NEXTW 
4179 c3 a8 22			jp macro_next 
417c				endm 
# End of macro NEXTW
417c			 
417c			.MENU: 
417c				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
417c 70				db WORD_SYS_CORE+92             
417d 25 42			dw .ENDDISPLAY            
417f 05				db 4 + 1 
4180 .. 00			db "MENU",0              
4185				endm 
# End of macro CWHEAD
4185			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
4185			 
4185			;		; get number of items on the stack 
4185			; 
4185				 
4185					FORTH_DSP_VALUEHL 
4185 cd 31 21			call macro_dsp_valuehl 
4188				endm 
# End of macro FORTH_DSP_VALUEHL
4188				 
4188					if DEBUG_FORTH_WORDS_KEY 
4188						DMARK "MNU" 
4188 f5				push af  
4189 3a 9d 41			ld a, (.dmark)  
418c 32 b4 fe			ld (debug_mark),a  
418f 3a 9e 41			ld a, (.dmark+1)  
4192 32 b5 fe			ld (debug_mark+1),a  
4195 3a 9f 41			ld a, (.dmark+2)  
4198 32 b6 fe			ld (debug_mark+2),a  
419b 18 03			jr .pastdmark  
419d ..			.dmark: db "MNU"  
41a0 f1			.pastdmark: pop af  
41a1			endm  
# End of macro DMARK
41a1						CALLMONITOR 
41a1 cd c6 18			call break_point_state  
41a4				endm  
# End of macro CALLMONITOR
41a4					endif 
41a4			 
41a4 45					ld b, l	 
41a5 05					dec b 
41a6			 
41a6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
41a6 cd e9 21			call macro_forth_dsp_pop 
41a9				endm 
# End of macro FORTH_DSP_POP
41a9			 
41a9			 
41a9					; go directly through the stack to pluck out the string pointers and build an array 
41a9			 
41a9			;		FORTH_DSP 
41a9			 
41a9					; hl contains top most stack item 
41a9				 
41a9 11 82 f3				ld de, scratch 
41ac			 
41ac			.mbuild: 
41ac			 
41ac					FORTH_DSP_VALUEHL 
41ac cd 31 21			call macro_dsp_valuehl 
41af				endm 
# End of macro FORTH_DSP_VALUEHL
41af			 
41af					if DEBUG_FORTH_WORDS 
41af						DMARK "MN3" 
41af f5				push af  
41b0 3a c4 41			ld a, (.dmark)  
41b3 32 b4 fe			ld (debug_mark),a  
41b6 3a c5 41			ld a, (.dmark+1)  
41b9 32 b5 fe			ld (debug_mark+1),a  
41bc 3a c6 41			ld a, (.dmark+2)  
41bf 32 b6 fe			ld (debug_mark+2),a  
41c2 18 03			jr .pastdmark  
41c4 ..			.dmark: db "MN3"  
41c7 f1			.pastdmark: pop af  
41c8			endm  
# End of macro DMARK
41c8						CALLMONITOR 
41c8 cd c6 18			call break_point_state  
41cb				endm  
# End of macro CALLMONITOR
41cb					endif 
41cb eb					ex de, hl 
41cc 73					ld (hl), e 
41cd 23					inc hl 
41ce 72					ld (hl), d 
41cf 23					inc hl 
41d0 eb					ex de, hl 
41d1			 
41d1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
41d1 cd e9 21			call macro_forth_dsp_pop 
41d4				endm 
# End of macro FORTH_DSP_POP
41d4			 
41d4 10 d6				djnz .mbuild 
41d6			 
41d6					; done add term 
41d6			 
41d6 eb					ex de, hl 
41d7 36 00				ld (hl), 0 
41d9 23					inc hl 
41da 36 00				ld (hl), 0 
41dc			 
41dc				 
41dc					 
41dc 21 82 f3				ld hl, scratch 
41df			 
41df					if DEBUG_FORTH_WORDS 
41df						DMARK "MNx" 
41df f5				push af  
41e0 3a f4 41			ld a, (.dmark)  
41e3 32 b4 fe			ld (debug_mark),a  
41e6 3a f5 41			ld a, (.dmark+1)  
41e9 32 b5 fe			ld (debug_mark+1),a  
41ec 3a f6 41			ld a, (.dmark+2)  
41ef 32 b6 fe			ld (debug_mark+2),a  
41f2 18 03			jr .pastdmark  
41f4 ..			.dmark: db "MNx"  
41f7 f1			.pastdmark: pop af  
41f8			endm  
# End of macro DMARK
41f8						CALLMONITOR 
41f8 cd c6 18			call break_point_state  
41fb				endm  
# End of macro CALLMONITOR
41fb					endif 
41fb			 
41fb			 
41fb			 
41fb 3e 00				ld a, 0 
41fd cd 46 0d				call menu 
4200			 
4200			 
4200 6f					ld l, a 
4201 26 00				ld h, 0 
4203			 
4203					if DEBUG_FORTH_WORDS 
4203						DMARK "MNr" 
4203 f5				push af  
4204 3a 18 42			ld a, (.dmark)  
4207 32 b4 fe			ld (debug_mark),a  
420a 3a 19 42			ld a, (.dmark+1)  
420d 32 b5 fe			ld (debug_mark+1),a  
4210 3a 1a 42			ld a, (.dmark+2)  
4213 32 b6 fe			ld (debug_mark+2),a  
4216 18 03			jr .pastdmark  
4218 ..			.dmark: db "MNr"  
421b f1			.pastdmark: pop af  
421c			endm  
# End of macro DMARK
421c						CALLMONITOR 
421c cd c6 18			call break_point_state  
421f				endm  
# End of macro CALLMONITOR
421f					endif 
421f			 
421f cd 3a 1f				call forth_push_numhl 
4222			 
4222			 
4222			 
4222			 
4222				       NEXTW 
4222 c3 a8 22			jp macro_next 
4225				endm 
# End of macro NEXTW
4225			 
4225			 
4225			.ENDDISPLAY: 
4225			 
4225			; eof 
# End of file forth_words_display.asm
4225			include "forth_words_str.asm" 
4225			 
4225			; | ## String Words 
4225			 
4225			.PTR:   
4225			 
4225				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
4225 48				db WORD_SYS_CORE+52             
4226 52 42			dw .STYPE            
4228 04				db 3 + 1 
4229 .. 00			db "PTR",0              
422d				endm 
# End of macro CWHEAD
422d			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
422d			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
422d			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
422d			 
422d					if DEBUG_FORTH_WORDS_KEY 
422d						DMARK "PTR" 
422d f5				push af  
422e 3a 42 42			ld a, (.dmark)  
4231 32 b4 fe			ld (debug_mark),a  
4234 3a 43 42			ld a, (.dmark+1)  
4237 32 b5 fe			ld (debug_mark+1),a  
423a 3a 44 42			ld a, (.dmark+2)  
423d 32 b6 fe			ld (debug_mark+2),a  
4240 18 03			jr .pastdmark  
4242 ..			.dmark: db "PTR"  
4245 f1			.pastdmark: pop af  
4246			endm  
# End of macro DMARK
4246						CALLMONITOR 
4246 cd c6 18			call break_point_state  
4249				endm  
# End of macro CALLMONITOR
4249					endif 
4249					FORTH_DSP_VALUEHL 
4249 cd 31 21			call macro_dsp_valuehl 
424c				endm 
# End of macro FORTH_DSP_VALUEHL
424c cd 3a 1f				call forth_push_numhl 
424f			 
424f			 
424f					NEXTW 
424f c3 a8 22			jp macro_next 
4252				endm 
# End of macro NEXTW
4252			.STYPE: 
4252				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
4252 48				db WORD_SYS_CORE+52             
4253 a1 42			dw .UPPER            
4255 06				db 5 + 1 
4256 .. 00			db "STYPE",0              
425c				endm 
# End of macro CWHEAD
425c			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
425c					if DEBUG_FORTH_WORDS_KEY 
425c						DMARK "STY" 
425c f5				push af  
425d 3a 71 42			ld a, (.dmark)  
4260 32 b4 fe			ld (debug_mark),a  
4263 3a 72 42			ld a, (.dmark+1)  
4266 32 b5 fe			ld (debug_mark+1),a  
4269 3a 73 42			ld a, (.dmark+2)  
426c 32 b6 fe			ld (debug_mark+2),a  
426f 18 03			jr .pastdmark  
4271 ..			.dmark: db "STY"  
4274 f1			.pastdmark: pop af  
4275			endm  
# End of macro DMARK
4275						CALLMONITOR 
4275 cd c6 18			call break_point_state  
4278				endm  
# End of macro CALLMONITOR
4278					endif 
4278					FORTH_DSP 
4278 cd f7 20			call macro_forth_dsp 
427b				endm 
# End of macro FORTH_DSP
427b					;v5 FORTH_DSP_VALUE 
427b			 
427b 7e					ld a, (hl) 
427c			 
427c f5					push af 
427d			 
427d			; Dont destroy TOS		FORTH_DSP_POP 
427d			 
427d f1					pop af 
427e			 
427e fe 01				cp DS_TYPE_STR 
4280 28 09				jr z, .typestr 
4282			 
4282 fe 02				cp DS_TYPE_INUM 
4284 28 0a				jr z, .typeinum 
4286			 
4286 21 9f 42				ld hl, .tna 
4289 18 0a				jr .tpush 
428b			 
428b 21 9b 42		.typestr:	ld hl, .tstr 
428e 18 05				jr .tpush 
4290 21 9d 42		.typeinum:	ld hl, .tinum 
4293 18 00				jr .tpush 
4295			 
4295			.tpush: 
4295			 
4295 cd a8 1f				call forth_push_str 
4298			 
4298					NEXTW 
4298 c3 a8 22			jp macro_next 
429b				endm 
# End of macro NEXTW
429b .. 00		.tstr:	db "s",0 
429d .. 00		.tinum:  db "i",0 
429f .. 00		.tna:   db "?", 0 
42a1			 
42a1			 
42a1			.UPPER: 
42a1				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
42a1 48				db WORD_SYS_CORE+52             
42a2 dc 42			dw .LOWER            
42a4 06				db 5 + 1 
42a5 .. 00			db "UPPER",0              
42ab				endm 
# End of macro CWHEAD
42ab			; | UPPER ( s -- s ) Upper case string s  | DONE 
42ab					if DEBUG_FORTH_WORDS_KEY 
42ab						DMARK "UPR" 
42ab f5				push af  
42ac 3a c0 42			ld a, (.dmark)  
42af 32 b4 fe			ld (debug_mark),a  
42b2 3a c1 42			ld a, (.dmark+1)  
42b5 32 b5 fe			ld (debug_mark+1),a  
42b8 3a c2 42			ld a, (.dmark+2)  
42bb 32 b6 fe			ld (debug_mark+2),a  
42be 18 03			jr .pastdmark  
42c0 ..			.dmark: db "UPR"  
42c3 f1			.pastdmark: pop af  
42c4			endm  
# End of macro DMARK
42c4						CALLMONITOR 
42c4 cd c6 18			call break_point_state  
42c7				endm  
# End of macro CALLMONITOR
42c7					endif 
42c7			 
42c7					FORTH_DSP 
42c7 cd f7 20			call macro_forth_dsp 
42ca				endm 
# End of macro FORTH_DSP
42ca					 
42ca			; TODO check is string type 
42ca			 
42ca					FORTH_DSP_VALUEHL 
42ca cd 31 21			call macro_dsp_valuehl 
42cd				endm 
# End of macro FORTH_DSP_VALUEHL
42cd			; get pointer to string in hl 
42cd			 
42cd 7e			.toup:		ld a, (hl) 
42ce fe 00				cp 0 
42d0 28 07				jr z, .toupdone 
42d2			 
42d2 cd b6 12				call to_upper 
42d5			 
42d5 77					ld (hl), a 
42d6 23					inc hl 
42d7 18 f4				jr .toup 
42d9			 
42d9					 
42d9			 
42d9			 
42d9			; for each char convert to upper 
42d9					 
42d9			.toupdone: 
42d9			 
42d9			 
42d9					NEXTW 
42d9 c3 a8 22			jp macro_next 
42dc				endm 
# End of macro NEXTW
42dc			.LOWER: 
42dc				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
42dc 48				db WORD_SYS_CORE+52             
42dd 17 43			dw .TCASE            
42df 06				db 5 + 1 
42e0 .. 00			db "LOWER",0              
42e6				endm 
# End of macro CWHEAD
42e6			; | LOWER ( s -- s ) Lower case string s  | DONE 
42e6					if DEBUG_FORTH_WORDS_KEY 
42e6						DMARK "LWR" 
42e6 f5				push af  
42e7 3a fb 42			ld a, (.dmark)  
42ea 32 b4 fe			ld (debug_mark),a  
42ed 3a fc 42			ld a, (.dmark+1)  
42f0 32 b5 fe			ld (debug_mark+1),a  
42f3 3a fd 42			ld a, (.dmark+2)  
42f6 32 b6 fe			ld (debug_mark+2),a  
42f9 18 03			jr .pastdmark  
42fb ..			.dmark: db "LWR"  
42fe f1			.pastdmark: pop af  
42ff			endm  
# End of macro DMARK
42ff						CALLMONITOR 
42ff cd c6 18			call break_point_state  
4302				endm  
# End of macro CALLMONITOR
4302					endif 
4302			 
4302					FORTH_DSP 
4302 cd f7 20			call macro_forth_dsp 
4305				endm 
# End of macro FORTH_DSP
4305					 
4305			; TODO check is string type 
4305			 
4305					FORTH_DSP_VALUEHL 
4305 cd 31 21			call macro_dsp_valuehl 
4308				endm 
# End of macro FORTH_DSP_VALUEHL
4308			; get pointer to string in hl 
4308			 
4308 7e			.tolow:		ld a, (hl) 
4309 fe 00				cp 0 
430b 28 07				jr z, .tolowdone 
430d			 
430d cd bf 12				call to_lower 
4310			 
4310 77					ld (hl), a 
4311 23					inc hl 
4312 18 f4				jr .tolow 
4314			 
4314					 
4314			 
4314			 
4314			; for each char convert to low 
4314					 
4314			.tolowdone: 
4314					NEXTW 
4314 c3 a8 22			jp macro_next 
4317				endm 
# End of macro NEXTW
4317			.TCASE: 
4317				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
4317 48				db WORD_SYS_CORE+52             
4318 4d 44			dw .SUBSTR            
431a 06				db 5 + 1 
431b .. 00			db "TCASE",0              
4321				endm 
# End of macro CWHEAD
4321			; | TCASE ( s -- s ) Title case string s  | DONE 
4321					if DEBUG_FORTH_WORDS_KEY 
4321						DMARK "TCS" 
4321 f5				push af  
4322 3a 36 43			ld a, (.dmark)  
4325 32 b4 fe			ld (debug_mark),a  
4328 3a 37 43			ld a, (.dmark+1)  
432b 32 b5 fe			ld (debug_mark+1),a  
432e 3a 38 43			ld a, (.dmark+2)  
4331 32 b6 fe			ld (debug_mark+2),a  
4334 18 03			jr .pastdmark  
4336 ..			.dmark: db "TCS"  
4339 f1			.pastdmark: pop af  
433a			endm  
# End of macro DMARK
433a						CALLMONITOR 
433a cd c6 18			call break_point_state  
433d				endm  
# End of macro CALLMONITOR
433d					endif 
433d			 
433d					FORTH_DSP 
433d cd f7 20			call macro_forth_dsp 
4340				endm 
# End of macro FORTH_DSP
4340					 
4340			; TODO check is string type 
4340			 
4340					FORTH_DSP_VALUEHL 
4340 cd 31 21			call macro_dsp_valuehl 
4343				endm 
# End of macro FORTH_DSP_VALUEHL
4343			; get pointer to string in hl 
4343			 
4343					if DEBUG_FORTH_WORDS 
4343						DMARK "TC1" 
4343 f5				push af  
4344 3a 58 43			ld a, (.dmark)  
4347 32 b4 fe			ld (debug_mark),a  
434a 3a 59 43			ld a, (.dmark+1)  
434d 32 b5 fe			ld (debug_mark+1),a  
4350 3a 5a 43			ld a, (.dmark+2)  
4353 32 b6 fe			ld (debug_mark+2),a  
4356 18 03			jr .pastdmark  
4358 ..			.dmark: db "TC1"  
435b f1			.pastdmark: pop af  
435c			endm  
# End of macro DMARK
435c						CALLMONITOR 
435c cd c6 18			call break_point_state  
435f				endm  
# End of macro CALLMONITOR
435f					endif 
435f			 
435f					; first time in turn to upper case first char 
435f			 
435f 7e					ld a, (hl) 
4360 c3 ea 43				jp .totsiptou 
4363			 
4363			 
4363 7e			.tot:		ld a, (hl) 
4364 fe 00				cp 0 
4366 ca 2e 44				jp z, .totdone 
4369			 
4369					if DEBUG_FORTH_WORDS 
4369						DMARK "TC2" 
4369 f5				push af  
436a 3a 7e 43			ld a, (.dmark)  
436d 32 b4 fe			ld (debug_mark),a  
4370 3a 7f 43			ld a, (.dmark+1)  
4373 32 b5 fe			ld (debug_mark+1),a  
4376 3a 80 43			ld a, (.dmark+2)  
4379 32 b6 fe			ld (debug_mark+2),a  
437c 18 03			jr .pastdmark  
437e ..			.dmark: db "TC2"  
4381 f1			.pastdmark: pop af  
4382			endm  
# End of macro DMARK
4382						CALLMONITOR 
4382 cd c6 18			call break_point_state  
4385				endm  
# End of macro CALLMONITOR
4385					endif 
4385					; check to see if current char is a space 
4385			 
4385 fe 20				cp ' ' 
4387 28 21				jr z, .totsp 
4389 cd bf 12				call to_lower 
438c					if DEBUG_FORTH_WORDS 
438c						DMARK "TC3" 
438c f5				push af  
438d 3a a1 43			ld a, (.dmark)  
4390 32 b4 fe			ld (debug_mark),a  
4393 3a a2 43			ld a, (.dmark+1)  
4396 32 b5 fe			ld (debug_mark+1),a  
4399 3a a3 43			ld a, (.dmark+2)  
439c 32 b6 fe			ld (debug_mark+2),a  
439f 18 03			jr .pastdmark  
43a1 ..			.dmark: db "TC3"  
43a4 f1			.pastdmark: pop af  
43a5			endm  
# End of macro DMARK
43a5						CALLMONITOR 
43a5 cd c6 18			call break_point_state  
43a8				endm  
# End of macro CALLMONITOR
43a8					endif 
43a8 18 63				jr .totnxt 
43aa			 
43aa			.totsp:         ; on a space, find next char which should be upper 
43aa			 
43aa					if DEBUG_FORTH_WORDS 
43aa						DMARK "TC4" 
43aa f5				push af  
43ab 3a bf 43			ld a, (.dmark)  
43ae 32 b4 fe			ld (debug_mark),a  
43b1 3a c0 43			ld a, (.dmark+1)  
43b4 32 b5 fe			ld (debug_mark+1),a  
43b7 3a c1 43			ld a, (.dmark+2)  
43ba 32 b6 fe			ld (debug_mark+2),a  
43bd 18 03			jr .pastdmark  
43bf ..			.dmark: db "TC4"  
43c2 f1			.pastdmark: pop af  
43c3			endm  
# End of macro DMARK
43c3						CALLMONITOR 
43c3 cd c6 18			call break_point_state  
43c6				endm  
# End of macro CALLMONITOR
43c6					endif 
43c6					;; 
43c6			 
43c6 fe 20				cp ' ' 
43c8 20 20				jr nz, .totsiptou 
43ca 23					inc hl 
43cb 7e					ld a, (hl) 
43cc					if DEBUG_FORTH_WORDS 
43cc						DMARK "TC5" 
43cc f5				push af  
43cd 3a e1 43			ld a, (.dmark)  
43d0 32 b4 fe			ld (debug_mark),a  
43d3 3a e2 43			ld a, (.dmark+1)  
43d6 32 b5 fe			ld (debug_mark+1),a  
43d9 3a e3 43			ld a, (.dmark+2)  
43dc 32 b6 fe			ld (debug_mark+2),a  
43df 18 03			jr .pastdmark  
43e1 ..			.dmark: db "TC5"  
43e4 f1			.pastdmark: pop af  
43e5			endm  
# End of macro DMARK
43e5						CALLMONITOR 
43e5 cd c6 18			call break_point_state  
43e8				endm  
# End of macro CALLMONITOR
43e8					endif 
43e8 18 c0				jr .totsp 
43ea fe 00		.totsiptou:    cp 0 
43ec 28 40				jr z, .totdone 
43ee					; not space and not zero term so upper case it 
43ee cd b6 12				call to_upper 
43f1			 
43f1					if DEBUG_FORTH_WORDS 
43f1						DMARK "TC6" 
43f1 f5				push af  
43f2 3a 06 44			ld a, (.dmark)  
43f5 32 b4 fe			ld (debug_mark),a  
43f8 3a 07 44			ld a, (.dmark+1)  
43fb 32 b5 fe			ld (debug_mark+1),a  
43fe 3a 08 44			ld a, (.dmark+2)  
4401 32 b6 fe			ld (debug_mark+2),a  
4404 18 03			jr .pastdmark  
4406 ..			.dmark: db "TC6"  
4409 f1			.pastdmark: pop af  
440a			endm  
# End of macro DMARK
440a						CALLMONITOR 
440a cd c6 18			call break_point_state  
440d				endm  
# End of macro CALLMONITOR
440d					endif 
440d			 
440d			 
440d			.totnxt: 
440d			 
440d 77					ld (hl), a 
440e 23					inc hl 
440f					if DEBUG_FORTH_WORDS 
440f						DMARK "TC7" 
440f f5				push af  
4410 3a 24 44			ld a, (.dmark)  
4413 32 b4 fe			ld (debug_mark),a  
4416 3a 25 44			ld a, (.dmark+1)  
4419 32 b5 fe			ld (debug_mark+1),a  
441c 3a 26 44			ld a, (.dmark+2)  
441f 32 b6 fe			ld (debug_mark+2),a  
4422 18 03			jr .pastdmark  
4424 ..			.dmark: db "TC7"  
4427 f1			.pastdmark: pop af  
4428			endm  
# End of macro DMARK
4428						CALLMONITOR 
4428 cd c6 18			call break_point_state  
442b				endm  
# End of macro CALLMONITOR
442b					endif 
442b c3 63 43				jp .tot 
442e			 
442e					 
442e			 
442e			 
442e			; for each char convert to low 
442e					 
442e			.totdone: 
442e					if DEBUG_FORTH_WORDS 
442e						DMARK "TCd" 
442e f5				push af  
442f 3a 43 44			ld a, (.dmark)  
4432 32 b4 fe			ld (debug_mark),a  
4435 3a 44 44			ld a, (.dmark+1)  
4438 32 b5 fe			ld (debug_mark+1),a  
443b 3a 45 44			ld a, (.dmark+2)  
443e 32 b6 fe			ld (debug_mark+2),a  
4441 18 03			jr .pastdmark  
4443 ..			.dmark: db "TCd"  
4446 f1			.pastdmark: pop af  
4447			endm  
# End of macro DMARK
4447						CALLMONITOR 
4447 cd c6 18			call break_point_state  
444a				endm  
# End of macro CALLMONITOR
444a					endif 
444a					NEXTW 
444a c3 a8 22			jp macro_next 
444d				endm 
# End of macro NEXTW
444d			 
444d			.SUBSTR: 
444d				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
444d 48				db WORD_SYS_CORE+52             
444e ab 44			dw .LEFT            
4450 07				db 6 + 1 
4451 .. 00			db "SUBSTR",0              
4458				endm 
# End of macro CWHEAD
4458			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
4458			 
4458					if DEBUG_FORTH_WORDS_KEY 
4458						DMARK "SST" 
4458 f5				push af  
4459 3a 6d 44			ld a, (.dmark)  
445c 32 b4 fe			ld (debug_mark),a  
445f 3a 6e 44			ld a, (.dmark+1)  
4462 32 b5 fe			ld (debug_mark+1),a  
4465 3a 6f 44			ld a, (.dmark+2)  
4468 32 b6 fe			ld (debug_mark+2),a  
446b 18 03			jr .pastdmark  
446d ..			.dmark: db "SST"  
4470 f1			.pastdmark: pop af  
4471			endm  
# End of macro DMARK
4471						CALLMONITOR 
4471 cd c6 18			call break_point_state  
4474				endm  
# End of macro CALLMONITOR
4474					endif 
4474			; TODO check string type 
4474					FORTH_DSP_VALUEHL 
4474 cd 31 21			call macro_dsp_valuehl 
4477				endm 
# End of macro FORTH_DSP_VALUEHL
4477			 
4477 e5					push hl      ; string length 
4478			 
4478					FORTH_DSP_POP 
4478 cd e9 21			call macro_forth_dsp_pop 
447b				endm 
# End of macro FORTH_DSP_POP
447b			 
447b					FORTH_DSP_VALUEHL 
447b cd 31 21			call macro_dsp_valuehl 
447e				endm 
# End of macro FORTH_DSP_VALUEHL
447e			 
447e e5					push hl     ; start char 
447f			 
447f					FORTH_DSP_POP 
447f cd e9 21			call macro_forth_dsp_pop 
4482				endm 
# End of macro FORTH_DSP_POP
4482			 
4482			 
4482					FORTH_DSP_VALUE 
4482 cd 1a 21			call macro_forth_dsp_value 
4485				endm 
# End of macro FORTH_DSP_VALUE
4485			 
4485 d1					pop de    ; get start post offset 
4486			 
4486 19					add hl, de    ; starting offset 
4487			 
4487 c1					pop bc 
4488 c5					push bc      ; grab size of string 
4489			 
4489 e5					push hl    ; save string start  
448a			 
448a 26 00				ld h, 0 
448c 69					ld l, c 
448d 23					inc hl 
448e 23					inc hl 
448f			 
448f cd 10 14				call malloc 
4492				if DEBUG_FORTH_MALLOC_GUARD 
4492 cc 46 56				call z,malloc_error 
4495				endif 
4495			 
4495 eb					ex de, hl      ; save malloc area for string copy 
4496 e1					pop hl    ; get back source 
4497 c1					pop bc    ; get length of string back 
4498			 
4498 d5					push de    ; save malloc area for after we push 
4499 ed b0				ldir     ; copy substr 
449b			 
449b			 
449b eb					ex de, hl 
449c 3e 00				ld a, 0 
449e 77					ld (hl), a   ; term substr 
449f			 
449f					 
449f e1					pop hl    ; get malloc so we can push it 
44a0 e5					push hl   ; save so we can free it afterwards 
44a1			 
44a1 cd a8 1f				call forth_push_str 
44a4			 
44a4 e1					pop hl 
44a5 cd da 14				call free 
44a8			 
44a8					 
44a8					 
44a8			 
44a8			 
44a8					NEXTW 
44a8 c3 a8 22			jp macro_next 
44ab				endm 
# End of macro NEXTW
44ab			 
44ab			.LEFT: 
44ab				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
44ab 48				db WORD_SYS_CORE+52             
44ac d3 44			dw .RIGHT            
44ae 05				db 4 + 1 
44af .. 00			db "LEFT",0              
44b4				endm 
# End of macro CWHEAD
44b4			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
44b4					if DEBUG_FORTH_WORDS_KEY 
44b4						DMARK "LEF" 
44b4 f5				push af  
44b5 3a c9 44			ld a, (.dmark)  
44b8 32 b4 fe			ld (debug_mark),a  
44bb 3a ca 44			ld a, (.dmark+1)  
44be 32 b5 fe			ld (debug_mark+1),a  
44c1 3a cb 44			ld a, (.dmark+2)  
44c4 32 b6 fe			ld (debug_mark+2),a  
44c7 18 03			jr .pastdmark  
44c9 ..			.dmark: db "LEF"  
44cc f1			.pastdmark: pop af  
44cd			endm  
# End of macro DMARK
44cd						CALLMONITOR 
44cd cd c6 18			call break_point_state  
44d0				endm  
# End of macro CALLMONITOR
44d0					endif 
44d0			 
44d0					NEXTW 
44d0 c3 a8 22			jp macro_next 
44d3				endm 
# End of macro NEXTW
44d3			.RIGHT: 
44d3				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
44d3 48				db WORD_SYS_CORE+52             
44d4 fc 44			dw .STR2NUM            
44d6 06				db 5 + 1 
44d7 .. 00			db "RIGHT",0              
44dd				endm 
# End of macro CWHEAD
44dd			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
44dd					if DEBUG_FORTH_WORDS_KEY 
44dd						DMARK "RIG" 
44dd f5				push af  
44de 3a f2 44			ld a, (.dmark)  
44e1 32 b4 fe			ld (debug_mark),a  
44e4 3a f3 44			ld a, (.dmark+1)  
44e7 32 b5 fe			ld (debug_mark+1),a  
44ea 3a f4 44			ld a, (.dmark+2)  
44ed 32 b6 fe			ld (debug_mark+2),a  
44f0 18 03			jr .pastdmark  
44f2 ..			.dmark: db "RIG"  
44f5 f1			.pastdmark: pop af  
44f6			endm  
# End of macro DMARK
44f6						CALLMONITOR 
44f6 cd c6 18			call break_point_state  
44f9				endm  
# End of macro CALLMONITOR
44f9					endif 
44f9			 
44f9					NEXTW 
44f9 c3 a8 22			jp macro_next 
44fc				endm 
# End of macro NEXTW
44fc			 
44fc			 
44fc			.STR2NUM: 
44fc				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
44fc 48				db WORD_SYS_CORE+52             
44fd 88 45			dw .NUM2STR            
44ff 08				db 7 + 1 
4500 .. 00			db "STR2NUM",0              
4508				endm 
# End of macro CWHEAD
4508			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
4508			 
4508			 
4508			; TODO STR type check to do 
4508					if DEBUG_FORTH_WORDS_KEY 
4508						DMARK "S2N" 
4508 f5				push af  
4509 3a 1d 45			ld a, (.dmark)  
450c 32 b4 fe			ld (debug_mark),a  
450f 3a 1e 45			ld a, (.dmark+1)  
4512 32 b5 fe			ld (debug_mark+1),a  
4515 3a 1f 45			ld a, (.dmark+2)  
4518 32 b6 fe			ld (debug_mark+2),a  
451b 18 03			jr .pastdmark  
451d ..			.dmark: db "S2N"  
4520 f1			.pastdmark: pop af  
4521			endm  
# End of macro DMARK
4521						CALLMONITOR 
4521 cd c6 18			call break_point_state  
4524				endm  
# End of macro CALLMONITOR
4524					endif 
4524			 
4524					;FORTH_DSP 
4524					FORTH_DSP_VALUE 
4524 cd 1a 21			call macro_forth_dsp_value 
4527				endm 
# End of macro FORTH_DSP_VALUE
4527					;inc hl 
4527			 
4527 eb					ex de, hl 
4528					if DEBUG_FORTH_WORDS 
4528						DMARK "S2a" 
4528 f5				push af  
4529 3a 3d 45			ld a, (.dmark)  
452c 32 b4 fe			ld (debug_mark),a  
452f 3a 3e 45			ld a, (.dmark+1)  
4532 32 b5 fe			ld (debug_mark+1),a  
4535 3a 3f 45			ld a, (.dmark+2)  
4538 32 b6 fe			ld (debug_mark+2),a  
453b 18 03			jr .pastdmark  
453d ..			.dmark: db "S2a"  
4540 f1			.pastdmark: pop af  
4541			endm  
# End of macro DMARK
4541						CALLMONITOR 
4541 cd c6 18			call break_point_state  
4544				endm  
# End of macro CALLMONITOR
4544					endif 
4544 cd 3e 13				call string_to_uint16 
4547			 
4547					if DEBUG_FORTH_WORDS 
4547						DMARK "S2b" 
4547 f5				push af  
4548 3a 5c 45			ld a, (.dmark)  
454b 32 b4 fe			ld (debug_mark),a  
454e 3a 5d 45			ld a, (.dmark+1)  
4551 32 b5 fe			ld (debug_mark+1),a  
4554 3a 5e 45			ld a, (.dmark+2)  
4557 32 b6 fe			ld (debug_mark+2),a  
455a 18 03			jr .pastdmark  
455c ..			.dmark: db "S2b"  
455f f1			.pastdmark: pop af  
4560			endm  
# End of macro DMARK
4560						CALLMONITOR 
4560 cd c6 18			call break_point_state  
4563				endm  
# End of macro CALLMONITOR
4563					endif 
4563			;		push hl 
4563					FORTH_DSP_POP 
4563 cd e9 21			call macro_forth_dsp_pop 
4566				endm 
# End of macro FORTH_DSP_POP
4566			;		pop hl 
4566					 
4566					if DEBUG_FORTH_WORDS 
4566						DMARK "S2b" 
4566 f5				push af  
4567 3a 7b 45			ld a, (.dmark)  
456a 32 b4 fe			ld (debug_mark),a  
456d 3a 7c 45			ld a, (.dmark+1)  
4570 32 b5 fe			ld (debug_mark+1),a  
4573 3a 7d 45			ld a, (.dmark+2)  
4576 32 b6 fe			ld (debug_mark+2),a  
4579 18 03			jr .pastdmark  
457b ..			.dmark: db "S2b"  
457e f1			.pastdmark: pop af  
457f			endm  
# End of macro DMARK
457f						CALLMONITOR 
457f cd c6 18			call break_point_state  
4582				endm  
# End of macro CALLMONITOR
4582					endif 
4582 cd 3a 1f				call forth_push_numhl	 
4585			 
4585				 
4585				       NEXTW 
4585 c3 a8 22			jp macro_next 
4588				endm 
# End of macro NEXTW
4588			.NUM2STR: 
4588				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
4588 48				db WORD_SYS_CORE+52             
4589 97 45			dw .CONCAT            
458b 08				db 7 + 1 
458c .. 00			db "NUM2STR",0              
4594				endm 
# End of macro CWHEAD
4594			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
4594			 
4594			;		; malloc a string to target 
4594			;		ld hl, 10     ; TODO max string size should be fine 
4594			;		call malloc 
4594			;		push hl    ; save malloc location 
4594			; 
4594			; 
4594			;; TODO check int type 
4594			;		FORTH_DSP_VALUEHL 
4594			;		ld a, l 
4594			;		call DispAToASCII   
4594			;;TODO need to chage above call to dump into string 
4594			; 
4594			; 
4594			 
4594				       NEXTW 
4594 c3 a8 22			jp macro_next 
4597				endm 
# End of macro NEXTW
4597			 
4597			.CONCAT: 
4597				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
4597 48				db WORD_SYS_CORE+52             
4598 4a 46			dw .FIND            
459a 07				db 6 + 1 
459b .. 00			db "CONCAT",0              
45a2				endm 
# End of macro CWHEAD
45a2			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
45a2			 
45a2			; TODO check string type 
45a2			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
45a2			 
45a2					if DEBUG_FORTH_WORDS_KEY 
45a2						DMARK "CON" 
45a2 f5				push af  
45a3 3a b7 45			ld a, (.dmark)  
45a6 32 b4 fe			ld (debug_mark),a  
45a9 3a b8 45			ld a, (.dmark+1)  
45ac 32 b5 fe			ld (debug_mark+1),a  
45af 3a b9 45			ld a, (.dmark+2)  
45b2 32 b6 fe			ld (debug_mark+2),a  
45b5 18 03			jr .pastdmark  
45b7 ..			.dmark: db "CON"  
45ba f1			.pastdmark: pop af  
45bb			endm  
# End of macro DMARK
45bb						CALLMONITOR 
45bb cd c6 18			call break_point_state  
45be				endm  
# End of macro CALLMONITOR
45be					endif 
45be			 
45be			 
45be					FORTH_DSP_VALUE 
45be cd 1a 21			call macro_forth_dsp_value 
45c1				endm 
# End of macro FORTH_DSP_VALUE
45c1 e5					push hl   ; s2 
45c2			 
45c2					FORTH_DSP_POP 
45c2 cd e9 21			call macro_forth_dsp_pop 
45c5				endm 
# End of macro FORTH_DSP_POP
45c5			 
45c5					FORTH_DSP_VALUE 
45c5 cd 1a 21			call macro_forth_dsp_value 
45c8				endm 
# End of macro FORTH_DSP_VALUE
45c8			 
45c8 e5					push hl   ; s1 
45c9			 
45c9					FORTH_DSP_POP 
45c9 cd e9 21			call macro_forth_dsp_pop 
45cc				endm 
# End of macro FORTH_DSP_POP
45cc					 
45cc			 
45cc					; copy s1 
45cc			 
45cc				 
45cc					; save ptr 
45cc e1					pop hl  
45cd e5					push hl 
45ce 3e 00				ld a, 0 
45d0 cd b2 13				call strlent 
45d3					;inc hl    ; zer0 
45d3 06 00				ld b, 0 
45d5 4d					ld c, l 
45d6 e1					pop hl		 
45d7 11 82 f3				ld de, scratch	 
45da					if DEBUG_FORTH_WORDS 
45da						DMARK "CO1" 
45da f5				push af  
45db 3a ef 45			ld a, (.dmark)  
45de 32 b4 fe			ld (debug_mark),a  
45e1 3a f0 45			ld a, (.dmark+1)  
45e4 32 b5 fe			ld (debug_mark+1),a  
45e7 3a f1 45			ld a, (.dmark+2)  
45ea 32 b6 fe			ld (debug_mark+2),a  
45ed 18 03			jr .pastdmark  
45ef ..			.dmark: db "CO1"  
45f2 f1			.pastdmark: pop af  
45f3			endm  
# End of macro DMARK
45f3						CALLMONITOR 
45f3 cd c6 18			call break_point_state  
45f6				endm  
# End of macro CALLMONITOR
45f6					endif 
45f6 ed b0				ldir 
45f8			 
45f8 e1					pop hl 
45f9 e5					push hl 
45fa d5					push de 
45fb			 
45fb			 
45fb 3e 00				ld a, 0 
45fd cd b2 13				call strlent 
4600 23					inc hl    ; zer0 
4601 23					inc hl 
4602 06 00				ld b, 0 
4604 4d					ld c, l 
4605 d1					pop de 
4606 e1					pop hl		 
4607					if DEBUG_FORTH_WORDS 
4607						DMARK "CO2" 
4607 f5				push af  
4608 3a 1c 46			ld a, (.dmark)  
460b 32 b4 fe			ld (debug_mark),a  
460e 3a 1d 46			ld a, (.dmark+1)  
4611 32 b5 fe			ld (debug_mark+1),a  
4614 3a 1e 46			ld a, (.dmark+2)  
4617 32 b6 fe			ld (debug_mark+2),a  
461a 18 03			jr .pastdmark  
461c ..			.dmark: db "CO2"  
461f f1			.pastdmark: pop af  
4620			endm  
# End of macro DMARK
4620						CALLMONITOR 
4620 cd c6 18			call break_point_state  
4623				endm  
# End of macro CALLMONITOR
4623					endif 
4623 ed b0				ldir 
4625			 
4625			 
4625			 
4625 21 82 f3				ld hl, scratch 
4628					if DEBUG_FORTH_WORDS 
4628						DMARK "CO5" 
4628 f5				push af  
4629 3a 3d 46			ld a, (.dmark)  
462c 32 b4 fe			ld (debug_mark),a  
462f 3a 3e 46			ld a, (.dmark+1)  
4632 32 b5 fe			ld (debug_mark+1),a  
4635 3a 3f 46			ld a, (.dmark+2)  
4638 32 b6 fe			ld (debug_mark+2),a  
463b 18 03			jr .pastdmark  
463d ..			.dmark: db "CO5"  
4640 f1			.pastdmark: pop af  
4641			endm  
# End of macro DMARK
4641						CALLMONITOR 
4641 cd c6 18			call break_point_state  
4644				endm  
# End of macro CALLMONITOR
4644					endif 
4644			 
4644 cd a8 1f				call forth_push_str 
4647			 
4647			 
4647			 
4647			 
4647				       NEXTW 
4647 c3 a8 22			jp macro_next 
464a				endm 
# End of macro NEXTW
464a			 
464a			 
464a			.FIND: 
464a				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
464a 4b				db WORD_SYS_CORE+55             
464b 08 47			dw .LEN            
464d 05				db 4 + 1 
464e .. 00			db "FIND",0              
4653				endm 
# End of macro CWHEAD
4653			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
4653			 
4653					if DEBUG_FORTH_WORDS_KEY 
4653						DMARK "FND" 
4653 f5				push af  
4654 3a 68 46			ld a, (.dmark)  
4657 32 b4 fe			ld (debug_mark),a  
465a 3a 69 46			ld a, (.dmark+1)  
465d 32 b5 fe			ld (debug_mark+1),a  
4660 3a 6a 46			ld a, (.dmark+2)  
4663 32 b6 fe			ld (debug_mark+2),a  
4666 18 03			jr .pastdmark  
4668 ..			.dmark: db "FND"  
466b f1			.pastdmark: pop af  
466c			endm  
# End of macro DMARK
466c						CALLMONITOR 
466c cd c6 18			call break_point_state  
466f				endm  
# End of macro CALLMONITOR
466f					endif 
466f			 
466f			; TODO check string type 
466f					FORTH_DSP_VALUE 
466f cd 1a 21			call macro_forth_dsp_value 
4672				endm 
# End of macro FORTH_DSP_VALUE
4672			 
4672 e5					push hl    
4673 7e					ld a,(hl)    ; char to find   
4674			; TODO change char to substr 
4674			 
4674 f5					push af 
4675					 
4675			 
4675			 
4675					if DEBUG_FORTH_WORDS 
4675						DMARK "FN1" 
4675 f5				push af  
4676 3a 8a 46			ld a, (.dmark)  
4679 32 b4 fe			ld (debug_mark),a  
467c 3a 8b 46			ld a, (.dmark+1)  
467f 32 b5 fe			ld (debug_mark+1),a  
4682 3a 8c 46			ld a, (.dmark+2)  
4685 32 b6 fe			ld (debug_mark+2),a  
4688 18 03			jr .pastdmark  
468a ..			.dmark: db "FN1"  
468d f1			.pastdmark: pop af  
468e			endm  
# End of macro DMARK
468e						CALLMONITOR 
468e cd c6 18			call break_point_state  
4691				endm  
# End of macro CALLMONITOR
4691					endif 
4691			 
4691					FORTH_DSP_POP 
4691 cd e9 21			call macro_forth_dsp_pop 
4694				endm 
# End of macro FORTH_DSP_POP
4694			 
4694					; string to search 
4694			 
4694					FORTH_DSP_VALUE 
4694 cd 1a 21			call macro_forth_dsp_value 
4697				endm 
# End of macro FORTH_DSP_VALUE
4697			 
4697 d1					pop de  ; d is char to find  
4698			 
4698					if DEBUG_FORTH_WORDS 
4698						DMARK "FN2" 
4698 f5				push af  
4699 3a ad 46			ld a, (.dmark)  
469c 32 b4 fe			ld (debug_mark),a  
469f 3a ae 46			ld a, (.dmark+1)  
46a2 32 b5 fe			ld (debug_mark+1),a  
46a5 3a af 46			ld a, (.dmark+2)  
46a8 32 b6 fe			ld (debug_mark+2),a  
46ab 18 03			jr .pastdmark  
46ad ..			.dmark: db "FN2"  
46b0 f1			.pastdmark: pop af  
46b1			endm  
# End of macro DMARK
46b1						CALLMONITOR 
46b1 cd c6 18			call break_point_state  
46b4				endm  
# End of macro CALLMONITOR
46b4					endif 
46b4					 
46b4 01 00 00				ld bc, 0 
46b7 7e			.findchar:      ld a,(hl) 
46b8 fe 00				cp 0   		 
46ba 28 27				jr z, .finddone     
46bc ba					cp d 
46bd 28 20				jr z, .foundchar 
46bf 03					inc bc 
46c0 23					inc hl 
46c1					if DEBUG_FORTH_WORDS 
46c1						DMARK "FN3" 
46c1 f5				push af  
46c2 3a d6 46			ld a, (.dmark)  
46c5 32 b4 fe			ld (debug_mark),a  
46c8 3a d7 46			ld a, (.dmark+1)  
46cb 32 b5 fe			ld (debug_mark+1),a  
46ce 3a d8 46			ld a, (.dmark+2)  
46d1 32 b6 fe			ld (debug_mark+2),a  
46d4 18 03			jr .pastdmark  
46d6 ..			.dmark: db "FN3"  
46d9 f1			.pastdmark: pop af  
46da			endm  
# End of macro DMARK
46da						CALLMONITOR 
46da cd c6 18			call break_point_state  
46dd				endm  
# End of macro CALLMONITOR
46dd					endif 
46dd 18 d8				jr .findchar 
46df			 
46df			 
46df c5			.foundchar:	push bc 
46e0 e1					pop hl 
46e1 18 03				jr .findexit 
46e3			 
46e3			 
46e3							 
46e3			 
46e3			.finddone:     ; got to end of string with no find 
46e3 21 00 00				ld hl, 0 
46e6			.findexit: 
46e6			 
46e6					if DEBUG_FORTH_WORDS 
46e6						DMARK "FNd" 
46e6 f5				push af  
46e7 3a fb 46			ld a, (.dmark)  
46ea 32 b4 fe			ld (debug_mark),a  
46ed 3a fc 46			ld a, (.dmark+1)  
46f0 32 b5 fe			ld (debug_mark+1),a  
46f3 3a fd 46			ld a, (.dmark+2)  
46f6 32 b6 fe			ld (debug_mark+2),a  
46f9 18 03			jr .pastdmark  
46fb ..			.dmark: db "FNd"  
46fe f1			.pastdmark: pop af  
46ff			endm  
# End of macro DMARK
46ff						CALLMONITOR 
46ff cd c6 18			call break_point_state  
4702				endm  
# End of macro CALLMONITOR
4702					endif 
4702 cd 3a 1f			call forth_push_numhl 
4705			 
4705				       NEXTW 
4705 c3 a8 22			jp macro_next 
4708				endm 
# End of macro NEXTW
4708			 
4708			.LEN: 
4708				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
4708 4c				db WORD_SYS_CORE+56             
4709 72 47			dw .ASC            
470b 06				db 5 + 1 
470c .. 00			db "COUNT",0              
4712				endm 
# End of macro CWHEAD
4712			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
4712			 
4712					if DEBUG_FORTH_WORDS_KEY 
4712						DMARK "CNT" 
4712 f5				push af  
4713 3a 27 47			ld a, (.dmark)  
4716 32 b4 fe			ld (debug_mark),a  
4719 3a 28 47			ld a, (.dmark+1)  
471c 32 b5 fe			ld (debug_mark+1),a  
471f 3a 29 47			ld a, (.dmark+2)  
4722 32 b6 fe			ld (debug_mark+2),a  
4725 18 03			jr .pastdmark  
4727 ..			.dmark: db "CNT"  
472a f1			.pastdmark: pop af  
472b			endm  
# End of macro DMARK
472b						CALLMONITOR 
472b cd c6 18			call break_point_state  
472e				endm  
# End of macro CALLMONITOR
472e					endif 
472e			; TODO check string type 
472e					FORTH_DSP_VALUE 
472e cd 1a 21			call macro_forth_dsp_value 
4731				endm 
# End of macro FORTH_DSP_VALUE
4731			 
4731			 
4731					if DEBUG_FORTH_WORDS 
4731						DMARK "CN?" 
4731 f5				push af  
4732 3a 46 47			ld a, (.dmark)  
4735 32 b4 fe			ld (debug_mark),a  
4738 3a 47 47			ld a, (.dmark+1)  
473b 32 b5 fe			ld (debug_mark+1),a  
473e 3a 48 47			ld a, (.dmark+2)  
4741 32 b6 fe			ld (debug_mark+2),a  
4744 18 03			jr .pastdmark  
4746 ..			.dmark: db "CN?"  
4749 f1			.pastdmark: pop af  
474a			endm  
# End of macro DMARK
474a						CALLMONITOR 
474a cd c6 18			call break_point_state  
474d				endm  
# End of macro CALLMONITOR
474d					endif 
474d cd a7 13				call strlenz 
4750					if DEBUG_FORTH_WORDS 
4750						DMARK "CNl" 
4750 f5				push af  
4751 3a 65 47			ld a, (.dmark)  
4754 32 b4 fe			ld (debug_mark),a  
4757 3a 66 47			ld a, (.dmark+1)  
475a 32 b5 fe			ld (debug_mark+1),a  
475d 3a 67 47			ld a, (.dmark+2)  
4760 32 b6 fe			ld (debug_mark+2),a  
4763 18 03			jr .pastdmark  
4765 ..			.dmark: db "CNl"  
4768 f1			.pastdmark: pop af  
4769			endm  
# End of macro DMARK
4769						CALLMONITOR 
4769 cd c6 18			call break_point_state  
476c				endm  
# End of macro CALLMONITOR
476c					endif 
476c			 
476c cd 3a 1f				call forth_push_numhl 
476f			 
476f			 
476f			 
476f				       NEXTW 
476f c3 a8 22			jp macro_next 
4772				endm 
# End of macro NEXTW
4772			.ASC: 
4772				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
4772 4d				db WORD_SYS_CORE+57             
4773 a7 47			dw .CHR            
4775 04				db 3 + 1 
4776 .. 00			db "ASC",0              
477a				endm 
# End of macro CWHEAD
477a			; | ASC ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
477a					if DEBUG_FORTH_WORDS_KEY 
477a						DMARK "ASC" 
477a f5				push af  
477b 3a 8f 47			ld a, (.dmark)  
477e 32 b4 fe			ld (debug_mark),a  
4781 3a 90 47			ld a, (.dmark+1)  
4784 32 b5 fe			ld (debug_mark+1),a  
4787 3a 91 47			ld a, (.dmark+2)  
478a 32 b6 fe			ld (debug_mark+2),a  
478d 18 03			jr .pastdmark  
478f ..			.dmark: db "ASC"  
4792 f1			.pastdmark: pop af  
4793			endm  
# End of macro DMARK
4793						CALLMONITOR 
4793 cd c6 18			call break_point_state  
4796				endm  
# End of macro CALLMONITOR
4796					endif 
4796					FORTH_DSP 
4796 cd f7 20			call macro_forth_dsp 
4799				endm 
# End of macro FORTH_DSP
4799					;v5 FORTH_DSP_VALUE 
4799 23					inc hl      ; now at start of numeric as string 
479a			 
479a			;		push hl 
479a			 
479a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
479a cd e9 21			call macro_forth_dsp_pop 
479d				endm 
# End of macro FORTH_DSP_POP
479d			 
479d			;		pop hl 
479d			 
479d					; push the content of a onto the stack as a value 
479d			 
479d 7e					ld a,(hl)   ; get char 
479e 26 00				ld h,0 
47a0 6f					ld l,a 
47a1 cd 3a 1f				call forth_push_numhl 
47a4			 
47a4				       NEXTW 
47a4 c3 a8 22			jp macro_next 
47a7				endm 
# End of macro NEXTW
47a7			 
47a7			.CHR: 
47a7				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
47a7 4d				db WORD_SYS_CORE+57             
47a8 e3 47			dw .ENDSTR            
47aa 04				db 3 + 1 
47ab .. 00			db "CHR",0              
47af				endm 
# End of macro CWHEAD
47af			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
47af					if DEBUG_FORTH_WORDS_KEY 
47af						DMARK "CHR" 
47af f5				push af  
47b0 3a c4 47			ld a, (.dmark)  
47b3 32 b4 fe			ld (debug_mark),a  
47b6 3a c5 47			ld a, (.dmark+1)  
47b9 32 b5 fe			ld (debug_mark+1),a  
47bc 3a c6 47			ld a, (.dmark+2)  
47bf 32 b6 fe			ld (debug_mark+2),a  
47c2 18 03			jr .pastdmark  
47c4 ..			.dmark: db "CHR"  
47c7 f1			.pastdmark: pop af  
47c8			endm  
# End of macro DMARK
47c8						CALLMONITOR 
47c8 cd c6 18			call break_point_state  
47cb				endm  
# End of macro CALLMONITOR
47cb					endif 
47cb					FORTH_DSP_VALUEHL 
47cb cd 31 21			call macro_dsp_valuehl 
47ce				endm 
# End of macro FORTH_DSP_VALUEHL
47ce			 
47ce					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
47ce cd e9 21			call macro_forth_dsp_pop 
47d1				endm 
# End of macro FORTH_DSP_POP
47d1			 
47d1					; save asci byte as a zero term string and push string 
47d1			 
47d1 7d					ld a,l 
47d2 32 82 f3				ld (scratch), a 
47d5			 
47d5 3e 00				ld a, 0 
47d7 32 83 f3				ld (scratch+1), a 
47da			 
47da 21 82 f3				ld hl, scratch 
47dd cd a8 1f				call forth_push_str 
47e0			 
47e0			 
47e0				       NEXTW 
47e0 c3 a8 22			jp macro_next 
47e3				endm 
# End of macro NEXTW
47e3			 
47e3			 
47e3			 
47e3			 
47e3			.ENDSTR: 
47e3			; eof 
47e3			 
# End of file forth_words_str.asm
47e3			include "forth_words_key.asm" 
47e3			 
47e3			; | ## Keyboard Words 
47e3			 
47e3			.KEY: 
47e3				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
47e3 3e				db WORD_SYS_CORE+42             
47e4 13 48			dw .WAITK            
47e6 04				db 3 + 1 
47e7 .. 00			db "KEY",0              
47eb				endm 
# End of macro CWHEAD
47eb			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
47eb			 
47eb					if DEBUG_FORTH_WORDS_KEY 
47eb						DMARK "KEY" 
47eb f5				push af  
47ec 3a 00 48			ld a, (.dmark)  
47ef 32 b4 fe			ld (debug_mark),a  
47f2 3a 01 48			ld a, (.dmark+1)  
47f5 32 b5 fe			ld (debug_mark+1),a  
47f8 3a 02 48			ld a, (.dmark+2)  
47fb 32 b6 fe			ld (debug_mark+2),a  
47fe 18 03			jr .pastdmark  
4800 ..			.dmark: db "KEY"  
4803 f1			.pastdmark: pop af  
4804			endm  
# End of macro DMARK
4804						CALLMONITOR 
4804 cd c6 18			call break_point_state  
4807				endm  
# End of macro CALLMONITOR
4807					endif 
4807			; TODO currently waits 
4807 cd 17 6f				call cin 
480a					;call cin_wait 
480a 6f					ld l, a 
480b 26 00				ld h, 0 
480d cd 3a 1f				call forth_push_numhl 
4810					NEXTW 
4810 c3 a8 22			jp macro_next 
4813				endm 
# End of macro NEXTW
4813			.WAITK: 
4813				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4813 3f				db WORD_SYS_CORE+43             
4814 45 48			dw .ACCEPT            
4816 06				db 5 + 1 
4817 .. 00			db "WAITK",0              
481d				endm 
# End of macro CWHEAD
481d			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
481d					if DEBUG_FORTH_WORDS_KEY 
481d						DMARK "WAI" 
481d f5				push af  
481e 3a 32 48			ld a, (.dmark)  
4821 32 b4 fe			ld (debug_mark),a  
4824 3a 33 48			ld a, (.dmark+1)  
4827 32 b5 fe			ld (debug_mark+1),a  
482a 3a 34 48			ld a, (.dmark+2)  
482d 32 b6 fe			ld (debug_mark+2),a  
4830 18 03			jr .pastdmark  
4832 ..			.dmark: db "WAI"  
4835 f1			.pastdmark: pop af  
4836			endm  
# End of macro DMARK
4836						CALLMONITOR 
4836 cd c6 18			call break_point_state  
4839				endm  
# End of macro CALLMONITOR
4839					endif 
4839 cd 06 6f				call cin_wait 
483c 6f					ld l, a 
483d 26 00				ld h, 0 
483f cd 3a 1f				call forth_push_numhl 
4842					NEXTW 
4842 c3 a8 22			jp macro_next 
4845				endm 
# End of macro NEXTW
4845			.ACCEPT: 
4845				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4845 40				db WORD_SYS_CORE+44             
4846 a3 48			dw .EDIT            
4848 07				db 6 + 1 
4849 .. 00			db "ACCEPT",0              
4850				endm 
# End of macro CWHEAD
4850			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
4850					; TODO crashes on push 
4850					if DEBUG_FORTH_WORDS_KEY 
4850						DMARK "ACC" 
4850 f5				push af  
4851 3a 65 48			ld a, (.dmark)  
4854 32 b4 fe			ld (debug_mark),a  
4857 3a 66 48			ld a, (.dmark+1)  
485a 32 b5 fe			ld (debug_mark+1),a  
485d 3a 67 48			ld a, (.dmark+2)  
4860 32 b6 fe			ld (debug_mark+2),a  
4863 18 03			jr .pastdmark  
4865 ..			.dmark: db "ACC"  
4868 f1			.pastdmark: pop af  
4869			endm  
# End of macro DMARK
4869						CALLMONITOR 
4869 cd c6 18			call break_point_state  
486c				endm  
# End of macro CALLMONITOR
486c					endif 
486c 21 80 f5				ld hl, os_input 
486f 3e 00				ld a, 0 
4871 77					ld (hl),a 
4872 3a eb fb				ld a,(f_cursor_ptr) 
4875 16 64				ld d, 100 
4877 0e 00				ld c, 0 
4879 1e 28				ld e, 40 
487b cd 76 0f				call input_str 
487e					; TODO perhaps do a type check and wrap in quotes if not a number 
487e 21 80 f5				ld hl, os_input 
4881					if DEBUG_FORTH_WORDS 
4881						DMARK "AC1" 
4881 f5				push af  
4882 3a 96 48			ld a, (.dmark)  
4885 32 b4 fe			ld (debug_mark),a  
4888 3a 97 48			ld a, (.dmark+1)  
488b 32 b5 fe			ld (debug_mark+1),a  
488e 3a 98 48			ld a, (.dmark+2)  
4891 32 b6 fe			ld (debug_mark+2),a  
4894 18 03			jr .pastdmark  
4896 ..			.dmark: db "AC1"  
4899 f1			.pastdmark: pop af  
489a			endm  
# End of macro DMARK
489a						CALLMONITOR 
489a cd c6 18			call break_point_state  
489d				endm  
# End of macro CALLMONITOR
489d					endif 
489d cd a8 1f				call forth_push_str 
48a0					NEXTW 
48a0 c3 a8 22			jp macro_next 
48a3				endm 
# End of macro NEXTW
48a3			 
48a3			.EDIT: 
48a3				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
48a3 40				db WORD_SYS_CORE+44             
48a4 45 49			dw .ENDKEY            
48a6 05				db 4 + 1 
48a7 .. 00			db "EDIT",0              
48ac				endm 
# End of macro CWHEAD
48ac			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
48ac			 
48ac					; TODO does not copy from stack 
48ac					if DEBUG_FORTH_WORDS_KEY 
48ac						DMARK "EDT" 
48ac f5				push af  
48ad 3a c1 48			ld a, (.dmark)  
48b0 32 b4 fe			ld (debug_mark),a  
48b3 3a c2 48			ld a, (.dmark+1)  
48b6 32 b5 fe			ld (debug_mark+1),a  
48b9 3a c3 48			ld a, (.dmark+2)  
48bc 32 b6 fe			ld (debug_mark+2),a  
48bf 18 03			jr .pastdmark  
48c1 ..			.dmark: db "EDT"  
48c4 f1			.pastdmark: pop af  
48c5			endm  
# End of macro DMARK
48c5						CALLMONITOR 
48c5 cd c6 18			call break_point_state  
48c8				endm  
# End of macro CALLMONITOR
48c8					endif 
48c8			 
48c8					;FORTH_DSP 
48c8					FORTH_DSP_VALUEHL 
48c8 cd 31 21			call macro_dsp_valuehl 
48cb				endm 
# End of macro FORTH_DSP_VALUEHL
48cb			;		inc hl    ; TODO do type check 
48cb			 
48cb			;		call get_word_hl 
48cb e5					push hl 
48cc					if DEBUG_FORTH_WORDS 
48cc						DMARK "EDp" 
48cc f5				push af  
48cd 3a e1 48			ld a, (.dmark)  
48d0 32 b4 fe			ld (debug_mark),a  
48d3 3a e2 48			ld a, (.dmark+1)  
48d6 32 b5 fe			ld (debug_mark+1),a  
48d9 3a e3 48			ld a, (.dmark+2)  
48dc 32 b6 fe			ld (debug_mark+2),a  
48df 18 03			jr .pastdmark  
48e1 ..			.dmark: db "EDp"  
48e4 f1			.pastdmark: pop af  
48e5			endm  
# End of macro DMARK
48e5						CALLMONITOR 
48e5 cd c6 18			call break_point_state  
48e8				endm  
# End of macro CALLMONITOR
48e8					endif 
48e8				;	ld a, 0 
48e8 cd a7 13				call strlenz 
48eb 23					inc hl 
48ec			 
48ec 06 00				ld b, 0 
48ee 4d					ld c, l 
48ef			 
48ef e1					pop hl 
48f0 11 80 f5				ld de, os_input 
48f3					if DEBUG_FORTH_WORDS_KEY 
48f3						DMARK "EDc" 
48f3 f5				push af  
48f4 3a 08 49			ld a, (.dmark)  
48f7 32 b4 fe			ld (debug_mark),a  
48fa 3a 09 49			ld a, (.dmark+1)  
48fd 32 b5 fe			ld (debug_mark+1),a  
4900 3a 0a 49			ld a, (.dmark+2)  
4903 32 b6 fe			ld (debug_mark+2),a  
4906 18 03			jr .pastdmark  
4908 ..			.dmark: db "EDc"  
490b f1			.pastdmark: pop af  
490c			endm  
# End of macro DMARK
490c						CALLMONITOR 
490c cd c6 18			call break_point_state  
490f				endm  
# End of macro CALLMONITOR
490f					endif 
490f ed b0				ldir 
4911			 
4911			 
4911 21 80 f5				ld hl, os_input 
4914					;ld a, 0 
4914					;ld (hl),a 
4914 3a eb fb				ld a,(f_cursor_ptr) 
4917 16 64				ld d, 100 
4919 0e 00				ld c, 0 
491b 1e 28				ld e, 40 
491d cd 76 0f				call input_str 
4920					; TODO perhaps do a type check and wrap in quotes if not a number 
4920 21 80 f5				ld hl, os_input 
4923					if DEBUG_FORTH_WORDS 
4923						DMARK "ED1" 
4923 f5				push af  
4924 3a 38 49			ld a, (.dmark)  
4927 32 b4 fe			ld (debug_mark),a  
492a 3a 39 49			ld a, (.dmark+1)  
492d 32 b5 fe			ld (debug_mark+1),a  
4930 3a 3a 49			ld a, (.dmark+2)  
4933 32 b6 fe			ld (debug_mark+2),a  
4936 18 03			jr .pastdmark  
4938 ..			.dmark: db "ED1"  
493b f1			.pastdmark: pop af  
493c			endm  
# End of macro DMARK
493c						CALLMONITOR 
493c cd c6 18			call break_point_state  
493f				endm  
# End of macro CALLMONITOR
493f					endif 
493f cd a8 1f				call forth_push_str 
4942					NEXTW 
4942 c3 a8 22			jp macro_next 
4945				endm 
# End of macro NEXTW
4945			 
4945			 
4945			 
4945			.ENDKEY: 
4945			; eof 
4945			 
# End of file forth_words_key.asm
4945			 
4945			if STORAGE_SE 
4945			   	include "forth_words_storage.asm" 
4945			 
4945			; | ## Fixed Storage Words 
4945			 
4945			.RECORD: 
4945			  
4945				CWHEAD .BREAD 38 "RECORD" 6 WORD_FLAG_CODE 
4945 3a				db WORD_SYS_CORE+38             
4946 e9 49			dw .BREAD            
4948 07				db 6 + 1 
4949 .. 00			db "RECORD",0              
4950				endm 
# End of macro CWHEAD
4950			; | RECORD ( u id -- s ) With the current bank, read record number u from file id and push to stack  | DONE 
4950			 
4950					if DEBUG_FORTH_WORDS_KEY 
4950						DMARK "REC" 
4950 f5				push af  
4951 3a 65 49			ld a, (.dmark)  
4954 32 b4 fe			ld (debug_mark),a  
4957 3a 66 49			ld a, (.dmark+1)  
495a 32 b5 fe			ld (debug_mark+1),a  
495d 3a 67 49			ld a, (.dmark+2)  
4960 32 b6 fe			ld (debug_mark+2),a  
4963 18 03			jr .pastdmark  
4965 ..			.dmark: db "REC"  
4968 f1			.pastdmark: pop af  
4969			endm  
# End of macro DMARK
4969						CALLMONITOR 
4969 cd c6 18			call break_point_state  
496c				endm  
# End of macro CALLMONITOR
496c					endif 
496c			 
496c					FORTH_DSP_VALUEHL 
496c cd 31 21			call macro_dsp_valuehl 
496f				endm 
# End of macro FORTH_DSP_VALUEHL
496f			 
496f e5					push hl    ; id 
4970			 
4970					FORTH_DSP_POP 
4970 cd e9 21			call macro_forth_dsp_pop 
4973				endm 
# End of macro FORTH_DSP_POP
4973			 
4973					FORTH_DSP_VALUEHL 
4973 cd 31 21			call macro_dsp_valuehl 
4976				endm 
# End of macro FORTH_DSP_VALUEHL
4976			 
4976					FORTH_DSP_POP 
4976 cd e9 21			call macro_forth_dsp_pop 
4979				endm 
# End of macro FORTH_DSP_POP
4979			 
4979 d1					pop de     ; get file id 
497a			 
497a					; e = file id 
497a					; l = file extent 
497a			 
497a			 
497a					; construct request to access file extent 
497a			 
497a			;		ld a, e 
497a 63					ld h, e 
497b					 
497b					 
497b					 
497b			 
497b					; e has id 
497b			 
497b 11 07 fc			ld de, store_page 
497e					if DEBUG_FORTH_WORDS 
497e						DMARK "REr" 
497e f5				push af  
497f 3a 93 49			ld a, (.dmark)  
4982 32 b4 fe			ld (debug_mark),a  
4985 3a 94 49			ld a, (.dmark+1)  
4988 32 b5 fe			ld (debug_mark+1),a  
498b 3a 95 49			ld a, (.dmark+2)  
498e 32 b6 fe			ld (debug_mark+2),a  
4991 18 03			jr .pastdmark  
4993 ..			.dmark: db "REr"  
4996 f1			.pastdmark: pop af  
4997			endm  
# End of macro DMARK
4997						CALLMONITOR 
4997 cd c6 18			call break_point_state  
499a				endm  
# End of macro CALLMONITOR
499a					endif 
499a cd 72 09				call storage_read 
499d cd 72 0f			call ishlzero 
49a0 28 22			jr z, .recnotfound 
49a2			 
49a2			 
49a2					if DEBUG_FORTH_WORDS 
49a2						DMARK "REe" 
49a2 f5				push af  
49a3 3a b7 49			ld a, (.dmark)  
49a6 32 b4 fe			ld (debug_mark),a  
49a9 3a b8 49			ld a, (.dmark+1)  
49ac 32 b5 fe			ld (debug_mark+1),a  
49af 3a b9 49			ld a, (.dmark+2)  
49b2 32 b6 fe			ld (debug_mark+2),a  
49b5 18 03			jr .pastdmark  
49b7 ..			.dmark: db "REe"  
49ba f1			.pastdmark: pop af  
49bb			endm  
# End of macro DMARK
49bb						CALLMONITOR 
49bb cd c6 18			call break_point_state  
49be				endm  
# End of macro CALLMONITOR
49be					endif 
49be cd a8 1f			call forth_push_str 
49c1			 
49c1					NEXTW 
49c1 c3 a8 22			jp macro_next 
49c4				endm 
# End of macro NEXTW
49c4			 
49c4			.recnotfound: 
49c4					if DEBUG_FORTH_WORDS 
49c4						DMARK "REf" 
49c4 f5				push af  
49c5 3a d9 49			ld a, (.dmark)  
49c8 32 b4 fe			ld (debug_mark),a  
49cb 3a da 49			ld a, (.dmark+1)  
49ce 32 b5 fe			ld (debug_mark+1),a  
49d1 3a db 49			ld a, (.dmark+2)  
49d4 32 b6 fe			ld (debug_mark+2),a  
49d7 18 03			jr .pastdmark  
49d9 ..			.dmark: db "REf"  
49dc f1			.pastdmark: pop af  
49dd			endm  
# End of macro DMARK
49dd						CALLMONITOR 
49dd cd c6 18			call break_point_state  
49e0				endm  
# End of macro CALLMONITOR
49e0					endif 
49e0 21 ff 00			ld hl, 255 
49e3 cd 3a 1f			call forth_push_numhl 
49e6				NEXTW 
49e6 c3 a8 22			jp macro_next 
49e9				endm 
# End of macro NEXTW
49e9			 
49e9			 
49e9			.BREAD: 
49e9			  
49e9				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
49e9 3a				db WORD_SYS_CORE+38             
49ea 6c 4a			dw .BWRITE            
49ec 06				db 5 + 1 
49ed .. 00			db "BREAD",0              
49f3				endm 
# End of macro CWHEAD
49f3			; | BREAD ( u -- u ) Lowlevel storage word. With the current bank, read a block from block address u (1-512) and push to stack  | DONE 
49f3				 
49f3					if DEBUG_FORTH_WORDS_KEY 
49f3						DMARK "BRD" 
49f3 f5				push af  
49f4 3a 08 4a			ld a, (.dmark)  
49f7 32 b4 fe			ld (debug_mark),a  
49fa 3a 09 4a			ld a, (.dmark+1)  
49fd 32 b5 fe			ld (debug_mark+1),a  
4a00 3a 0a 4a			ld a, (.dmark+2)  
4a03 32 b6 fe			ld (debug_mark+2),a  
4a06 18 03			jr .pastdmark  
4a08 ..			.dmark: db "BRD"  
4a0b f1			.pastdmark: pop af  
4a0c			endm  
# End of macro DMARK
4a0c						CALLMONITOR 
4a0c cd c6 18			call break_point_state  
4a0f				endm  
# End of macro CALLMONITOR
4a0f					endif 
4a0f			 
4a0f				FORTH_DSP_VALUEHL 
4a0f cd 31 21			call macro_dsp_valuehl 
4a12				endm 
# End of macro FORTH_DSP_VALUEHL
4a12			 
4a12				FORTH_DSP_POP 
4a12 cd e9 21			call macro_forth_dsp_pop 
4a15				endm 
# End of macro FORTH_DSP_POP
4a15			 
4a15				; calc block address 
4a15			 
4a15 eb				ex de, hl 
4a16 3e 40			ld a, STORE_BLOCK_PHY 
4a18 cd cc 0e			call Mult16 
4a1b			 
4a1b			 
4a1b 11 07 fc			ld de, store_page 
4a1e			 
4a1e					if DEBUG_FORTH_WORDS 
4a1e						DMARK "BR1" 
4a1e f5				push af  
4a1f 3a 33 4a			ld a, (.dmark)  
4a22 32 b4 fe			ld (debug_mark),a  
4a25 3a 34 4a			ld a, (.dmark+1)  
4a28 32 b5 fe			ld (debug_mark+1),a  
4a2b 3a 35 4a			ld a, (.dmark+2)  
4a2e 32 b6 fe			ld (debug_mark+2),a  
4a31 18 03			jr .pastdmark  
4a33 ..			.dmark: db "BR1"  
4a36 f1			.pastdmark: pop af  
4a37			endm  
# End of macro DMARK
4a37						CALLMONITOR 
4a37 cd c6 18			call break_point_state  
4a3a				endm  
# End of macro CALLMONITOR
4a3a					endif 
4a3a			 
4a3a cd 19 04			call storage_read_block 
4a3d			 
4a3d cd 72 0f			call ishlzero 
4a40 20 05			jr nz, .brfound 
4a42			 
4a42 cd 3a 1f			call forth_push_numhl 
4a45 18 22			jr .brdone 
4a47			 
4a47			 
4a47			.brfound: 
4a47 21 09 fc		        ld hl, store_page+2 
4a4a			 
4a4a					if DEBUG_FORTH_WORDS 
4a4a						DMARK "BR2" 
4a4a f5				push af  
4a4b 3a 5f 4a			ld a, (.dmark)  
4a4e 32 b4 fe			ld (debug_mark),a  
4a51 3a 60 4a			ld a, (.dmark+1)  
4a54 32 b5 fe			ld (debug_mark+1),a  
4a57 3a 61 4a			ld a, (.dmark+2)  
4a5a 32 b6 fe			ld (debug_mark+2),a  
4a5d 18 03			jr .pastdmark  
4a5f ..			.dmark: db "BR2"  
4a62 f1			.pastdmark: pop af  
4a63			endm  
# End of macro DMARK
4a63						CALLMONITOR 
4a63 cd c6 18			call break_point_state  
4a66				endm  
# End of macro CALLMONITOR
4a66					endif 
4a66			 
4a66 cd a8 1f			call forth_push_str 
4a69			 
4a69			 
4a69			.brdone: 
4a69			 
4a69					NEXTW 
4a69 c3 a8 22			jp macro_next 
4a6c				endm 
# End of macro NEXTW
4a6c			.BWRITE: 
4a6c				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
4a6c 3a				db WORD_SYS_CORE+38             
4a6d 01 4b			dw .BUPD            
4a6f 07				db 6 + 1 
4a70 .. 00			db "BWRITE",0              
4a77				endm 
# End of macro CWHEAD
4a77			; | BWRITE ( s u -- ) Lowlevel storage word. With the current bank, write the string s to address u | DONE 
4a77			 
4a77					if DEBUG_FORTH_WORDS_KEY 
4a77						DMARK "BWR" 
4a77 f5				push af  
4a78 3a 8c 4a			ld a, (.dmark)  
4a7b 32 b4 fe			ld (debug_mark),a  
4a7e 3a 8d 4a			ld a, (.dmark+1)  
4a81 32 b5 fe			ld (debug_mark+1),a  
4a84 3a 8e 4a			ld a, (.dmark+2)  
4a87 32 b6 fe			ld (debug_mark+2),a  
4a8a 18 03			jr .pastdmark  
4a8c ..			.dmark: db "BWR"  
4a8f f1			.pastdmark: pop af  
4a90			endm  
# End of macro DMARK
4a90						CALLMONITOR 
4a90 cd c6 18			call break_point_state  
4a93				endm  
# End of macro CALLMONITOR
4a93					endif 
4a93			 
4a93				FORTH_DSP_VALUEHL 
4a93 cd 31 21			call macro_dsp_valuehl 
4a96				endm 
# End of macro FORTH_DSP_VALUEHL
4a96			 
4a96				; calc block address 
4a96			 
4a96 eb				ex de, hl 
4a97 3e 40			ld a, STORE_BLOCK_PHY 
4a99 cd cc 0e			call Mult16 
4a9c			 
4a9c e5				push hl         ; address 
4a9d			 
4a9d				FORTH_DSP_POP 
4a9d cd e9 21			call macro_forth_dsp_pop 
4aa0				endm 
# End of macro FORTH_DSP_POP
4aa0			 
4aa0				FORTH_DSP_VALUEHL 
4aa0 cd 31 21			call macro_dsp_valuehl 
4aa3				endm 
# End of macro FORTH_DSP_VALUEHL
4aa3			 
4aa3				FORTH_DSP_POP 
4aa3 cd e9 21			call macro_forth_dsp_pop 
4aa6				endm 
# End of macro FORTH_DSP_POP
4aa6			 
4aa6 cd 55 0c			call storage_clear_page 
4aa9			 
4aa9				; copy string to store page 
4aa9			 
4aa9 e5				push hl     ; save string address 
4aaa			 
4aaa 3e 00			ld a, 0 
4aac cd b2 13			call strlent 
4aaf			 
4aaf 23				inc hl 
4ab0			 
4ab0 4d				ld c, l 
4ab1 06 00			ld b, 0 
4ab3			 
4ab3 e1				pop hl 
4ab4 11 09 fc			ld de, store_page + 2 
4ab7					if DEBUG_FORTH_WORDS 
4ab7						DMARK "BW1" 
4ab7 f5				push af  
4ab8 3a cc 4a			ld a, (.dmark)  
4abb 32 b4 fe			ld (debug_mark),a  
4abe 3a cd 4a			ld a, (.dmark+1)  
4ac1 32 b5 fe			ld (debug_mark+1),a  
4ac4 3a ce 4a			ld a, (.dmark+2)  
4ac7 32 b6 fe			ld (debug_mark+2),a  
4aca 18 03			jr .pastdmark  
4acc ..			.dmark: db "BW1"  
4acf f1			.pastdmark: pop af  
4ad0			endm  
# End of macro DMARK
4ad0						CALLMONITOR 
4ad0 cd c6 18			call break_point_state  
4ad3				endm  
# End of macro CALLMONITOR
4ad3					endif 
4ad3 ed b0			ldir 
4ad5			 
4ad5			 
4ad5				; poke the start of the block with flags to prevent high level file ops hitting the block 
4ad5			 
4ad5 21 ff ff			ld hl, $ffff 
4ad8			 
4ad8 22 07 fc			ld (store_page), hl	 
4adb				 
4adb e1				pop hl    ; get address 
4adc 11 07 fc			ld de, store_page 
4adf			 
4adf					if DEBUG_FORTH_WORDS 
4adf						DMARK "BW2" 
4adf f5				push af  
4ae0 3a f4 4a			ld a, (.dmark)  
4ae3 32 b4 fe			ld (debug_mark),a  
4ae6 3a f5 4a			ld a, (.dmark+1)  
4ae9 32 b5 fe			ld (debug_mark+1),a  
4aec 3a f6 4a			ld a, (.dmark+2)  
4aef 32 b6 fe			ld (debug_mark+2),a  
4af2 18 03			jr .pastdmark  
4af4 ..			.dmark: db "BW2"  
4af7 f1			.pastdmark: pop af  
4af8			endm  
# End of macro DMARK
4af8						CALLMONITOR 
4af8 cd c6 18			call break_point_state  
4afb				endm  
# End of macro CALLMONITOR
4afb					endif 
4afb			 
4afb cd 7e 04			call storage_write_block 
4afe			 
4afe					NEXTW 
4afe c3 a8 22			jp macro_next 
4b01				endm 
# End of macro NEXTW
4b01			 
4b01			.BUPD: 
4b01				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
4b01 3a				db WORD_SYS_CORE+38             
4b02 57 4b			dw .BYID            
4b04 05				db 4 + 1 
4b05 .. 00			db "BUPD",0              
4b0a				endm 
# End of macro CWHEAD
4b0a			; | BUPD ( u -- ) Lowlevel storage word. Write the contents of the current file system storage buffer directly to address u | DONE 
4b0a			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
4b0a			; | | or completely different file system structure. 
4b0a			 
4b0a					if DEBUG_FORTH_WORDS_KEY 
4b0a						DMARK "BUD" 
4b0a f5				push af  
4b0b 3a 1f 4b			ld a, (.dmark)  
4b0e 32 b4 fe			ld (debug_mark),a  
4b11 3a 20 4b			ld a, (.dmark+1)  
4b14 32 b5 fe			ld (debug_mark+1),a  
4b17 3a 21 4b			ld a, (.dmark+2)  
4b1a 32 b6 fe			ld (debug_mark+2),a  
4b1d 18 03			jr .pastdmark  
4b1f ..			.dmark: db "BUD"  
4b22 f1			.pastdmark: pop af  
4b23			endm  
# End of macro DMARK
4b23						CALLMONITOR 
4b23 cd c6 18			call break_point_state  
4b26				endm  
# End of macro CALLMONITOR
4b26					endif 
4b26			 
4b26				FORTH_DSP_VALUEHL 
4b26 cd 31 21			call macro_dsp_valuehl 
4b29				endm 
# End of macro FORTH_DSP_VALUEHL
4b29			 
4b29				; calc block address 
4b29			 
4b29 eb				ex de, hl 
4b2a 3e 40			ld a, STORE_BLOCK_PHY 
4b2c cd cc 0e			call Mult16 
4b2f			 
4b2f				FORTH_DSP_POP 
4b2f cd e9 21			call macro_forth_dsp_pop 
4b32				endm 
# End of macro FORTH_DSP_POP
4b32			 
4b32			 
4b32 11 07 fc			ld de, store_page 
4b35			 
4b35					if DEBUG_FORTH_WORDS 
4b35						DMARK "BUe" 
4b35 f5				push af  
4b36 3a 4a 4b			ld a, (.dmark)  
4b39 32 b4 fe			ld (debug_mark),a  
4b3c 3a 4b 4b			ld a, (.dmark+1)  
4b3f 32 b5 fe			ld (debug_mark+1),a  
4b42 3a 4c 4b			ld a, (.dmark+2)  
4b45 32 b6 fe			ld (debug_mark+2),a  
4b48 18 03			jr .pastdmark  
4b4a ..			.dmark: db "BUe"  
4b4d f1			.pastdmark: pop af  
4b4e			endm  
# End of macro DMARK
4b4e						CALLMONITOR 
4b4e cd c6 18			call break_point_state  
4b51				endm  
# End of macro CALLMONITOR
4b51					endif 
4b51			 
4b51 cd 7e 04			call storage_write_block 
4b54			 
4b54					NEXTW 
4b54 c3 a8 22			jp macro_next 
4b57				endm 
# End of macro NEXTW
4b57			 
4b57			.BYID: 
4b57			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
4b57			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
4b57			; 
4b57			;		 
4b57			;		if DEBUG_FORTH_WORDS_KEY 
4b57			;			DMARK "BYID" 
4b57			;			CALLMONITOR 
4b57			;		endif 
4b57			; 
4b57			;		; get direct address 
4b57			; 
4b57			;		FORTH_DSP_VALUEHL 
4b57			; 
4b57			;		FORTH_DSP_POP 
4b57			; 
4b57			;	; calc block address 
4b57			; 
4b57			;	ex de, hl 
4b57			;	ld a, STORE_BLOCK_PHY 
4b57			;	call Mult16 
4b57			;	;	do BREAD with number as param 
4b57			;	; push the file name	 
4b57			;	ld de, store_page 
4b57			;	call storage_read_block 
4b57			 ;       ld hl, store_page+2 
4b57			; 
4b57			; 
4b57			;		NEXTW 
4b57			;.BYNAME: 
4b57				CWHEAD .DIR 38 "GETID" 5 WORD_FLAG_CODE 
4b57 3a				db WORD_SYS_CORE+38             
4b58 70 4b			dw .DIR            
4b5a 06				db 5 + 1 
4b5b .. 00			db "GETID",0              
4b61				endm 
# End of macro CWHEAD
4b61			; | GETID ( s -- u ) Get the file ID in the current BANK of the file named s | DONE 
4b61			 
4b61					; get pointer to file name to seek 
4b61			 
4b61					FORTH_DSP_VALUEHL 
4b61 cd 31 21			call macro_dsp_valuehl 
4b64				endm 
# End of macro FORTH_DSP_VALUEHL
4b64			 
4b64			 
4b64 cd 40 03				call storage_getid  
4b67			 
4b67					FORTH_DSP_POP 
4b67 cd e9 21			call macro_forth_dsp_pop 
4b6a				endm 
# End of macro FORTH_DSP_POP
4b6a			 
4b6a cd 3a 1f				call forth_push_numhl 
4b6d			 
4b6d					NEXTW 
4b6d c3 a8 22			jp macro_next 
4b70				endm 
# End of macro NEXTW
4b70			; 
4b70			.DIR: 
4b70				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
4b70 3a				db WORD_SYS_CORE+38             
4b71 74 4c			dw .SAVE            
4b73 04				db 3 + 1 
4b74 .. 00			db "DIR",0              
4b78				endm 
# End of macro CWHEAD
4b78			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
4b78			 
4b78					if DEBUG_FORTH_WORDS_KEY 
4b78						DMARK "DIR" 
4b78 f5				push af  
4b79 3a 8d 4b			ld a, (.dmark)  
4b7c 32 b4 fe			ld (debug_mark),a  
4b7f 3a 8e 4b			ld a, (.dmark+1)  
4b82 32 b5 fe			ld (debug_mark+1),a  
4b85 3a 8f 4b			ld a, (.dmark+2)  
4b88 32 b6 fe			ld (debug_mark+2),a  
4b8b 18 03			jr .pastdmark  
4b8d ..			.dmark: db "DIR"  
4b90 f1			.pastdmark: pop af  
4b91			endm  
# End of macro DMARK
4b91						CALLMONITOR 
4b91 cd c6 18			call break_point_state  
4b94				endm  
# End of macro CALLMONITOR
4b94					endif 
4b94 cd ca 04			call storage_get_block_0 
4b97			 
4b97 21 07 fc			ld hl, store_page     ; get current id count 
4b9a 46				ld b, (hl) 
4b9b 0e 00			ld c, 0    ; count of files   
4b9d					if DEBUG_FORTH_WORDS 
4b9d						DMARK "DI1" 
4b9d f5				push af  
4b9e 3a b2 4b			ld a, (.dmark)  
4ba1 32 b4 fe			ld (debug_mark),a  
4ba4 3a b3 4b			ld a, (.dmark+1)  
4ba7 32 b5 fe			ld (debug_mark+1),a  
4baa 3a b4 4b			ld a, (.dmark+2)  
4bad 32 b6 fe			ld (debug_mark+2),a  
4bb0 18 03			jr .pastdmark  
4bb2 ..			.dmark: db "DI1"  
4bb5 f1			.pastdmark: pop af  
4bb6			endm  
# End of macro DMARK
4bb6						CALLMONITOR 
4bb6 cd c6 18			call break_point_state  
4bb9				endm  
# End of macro CALLMONITOR
4bb9					endif 
4bb9			 
4bb9				; check for empty drive 
4bb9			 
4bb9 3e 00			ld a, 0 
4bbb b8				cp b 
4bbc ca 2a 4c			jp z, .dirdone 
4bbf			 
4bbf				; for each of the current ids do a search for them and if found push to stack 
4bbf			 
4bbf c5			.diritem:	push bc 
4bc0 21 40 00				ld hl, STORE_BLOCK_PHY 
4bc3 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
4bc5 58					ld e,b 
4bc6			 
4bc6			;		if DEBUG_FORTH_WORDS 
4bc6			;			DMARK "DI2" 
4bc6			;			CALLMONITOR 
4bc6			;		endif 
4bc6			 
4bc6 cd 4c 07				call storage_findnextid 
4bc9			 
4bc9			;		if DEBUG_FORTH_WORDS 
4bc9			;			DMARK "DI3" 
4bc9			;			CALLMONITOR 
4bc9			;		endif 
4bc9			 
4bc9					; if found hl will be non zero 
4bc9			 
4bc9 cd 72 0f				call ishlzero 
4bcc			;		ld a, l 
4bcc			;		add h 
4bcc			; 
4bcc			;		cp 0 
4bcc 28 59				jr z, .dirnotfound 
4bce			 
4bce					; increase count 
4bce			 
4bce c1					pop bc	 
4bcf 0c					inc c 
4bd0 c5					push bc 
4bd1					 
4bd1			 
4bd1					; get file header and push the file name 
4bd1			 
4bd1 11 07 fc				ld de, store_page 
4bd4 cd 19 04				call storage_read_block 
4bd7			 
4bd7					; push file id to stack 
4bd7				 
4bd7 3a 07 fc				ld a, (store_page) 
4bda 26 00				ld h, 0 
4bdc 6f					ld l, a 
4bdd cd 3a 1f				call forth_push_numhl 
4be0			 
4be0					; push extent count to stack  
4be0				 
4be0 3a 09 fc				ld a, (store_page+2) 
4be3 26 00				ld h, 0 
4be5 6f					ld l, a 
4be6 cd 3a 1f				call forth_push_numhl 
4be9			 
4be9					; push file name 
4be9			 
4be9 21 0a fc				ld hl, store_page+3 
4bec					if DEBUG_FORTH_WORDS 
4bec						DMARK "DI5" 
4bec f5				push af  
4bed 3a 01 4c			ld a, (.dmark)  
4bf0 32 b4 fe			ld (debug_mark),a  
4bf3 3a 02 4c			ld a, (.dmark+1)  
4bf6 32 b5 fe			ld (debug_mark+1),a  
4bf9 3a 03 4c			ld a, (.dmark+2)  
4bfc 32 b6 fe			ld (debug_mark+2),a  
4bff 18 03			jr .pastdmark  
4c01 ..			.dmark: db "DI5"  
4c04 f1			.pastdmark: pop af  
4c05			endm  
# End of macro DMARK
4c05						CALLMONITOR 
4c05 cd c6 18			call break_point_state  
4c08				endm  
# End of macro CALLMONITOR
4c08					endif 
4c08 cd a8 1f				call forth_push_str 
4c0b					if DEBUG_FORTH_WORDS 
4c0b						DMARK "DI6" 
4c0b f5				push af  
4c0c 3a 20 4c			ld a, (.dmark)  
4c0f 32 b4 fe			ld (debug_mark),a  
4c12 3a 21 4c			ld a, (.dmark+1)  
4c15 32 b5 fe			ld (debug_mark+1),a  
4c18 3a 22 4c			ld a, (.dmark+2)  
4c1b 32 b6 fe			ld (debug_mark+2),a  
4c1e 18 03			jr .pastdmark  
4c20 ..			.dmark: db "DI6"  
4c23 f1			.pastdmark: pop af  
4c24			endm  
# End of macro DMARK
4c24						CALLMONITOR 
4c24 cd c6 18			call break_point_state  
4c27				endm  
# End of macro CALLMONITOR
4c27					endif 
4c27			.dirnotfound: 
4c27 c1					pop bc     
4c28 10 95				djnz .diritem 
4c2a				 
4c2a			.dirdone:	 
4c2a					if DEBUG_FORTH_WORDS 
4c2a						DMARK "DI7" 
4c2a f5				push af  
4c2b 3a 3f 4c			ld a, (.dmark)  
4c2e 32 b4 fe			ld (debug_mark),a  
4c31 3a 40 4c			ld a, (.dmark+1)  
4c34 32 b5 fe			ld (debug_mark+1),a  
4c37 3a 41 4c			ld a, (.dmark+2)  
4c3a 32 b6 fe			ld (debug_mark+2),a  
4c3d 18 03			jr .pastdmark  
4c3f ..			.dmark: db "DI7"  
4c42 f1			.pastdmark: pop af  
4c43			endm  
# End of macro DMARK
4c43						CALLMONITOR 
4c43 cd c6 18			call break_point_state  
4c46				endm  
# End of macro CALLMONITOR
4c46					endif 
4c46			 
4c46					; push a count of the dir items found 
4c46			 
4c46 26 00				ld h, 0 
4c48 69					ld l, c 
4c49 cd 3a 1f				call forth_push_numhl 
4c4c			 
4c4c					; push the bank label 
4c4c			 
4c4c cd ca 04				call storage_get_block_0 
4c4f			 
4c4f				 
4c4f 21 0a fc		 		ld hl, store_page+3 
4c52			 
4c52					if DEBUG_FORTH_WORDS 
4c52						DMARK "DI8" 
4c52 f5				push af  
4c53 3a 67 4c			ld a, (.dmark)  
4c56 32 b4 fe			ld (debug_mark),a  
4c59 3a 68 4c			ld a, (.dmark+1)  
4c5c 32 b5 fe			ld (debug_mark+1),a  
4c5f 3a 69 4c			ld a, (.dmark+2)  
4c62 32 b6 fe			ld (debug_mark+2),a  
4c65 18 03			jr .pastdmark  
4c67 ..			.dmark: db "DI8"  
4c6a f1			.pastdmark: pop af  
4c6b			endm  
# End of macro DMARK
4c6b						CALLMONITOR 
4c6b cd c6 18			call break_point_state  
4c6e				endm  
# End of macro CALLMONITOR
4c6e					endif 
4c6e cd a8 1f				call forth_push_str 
4c71			 
4c71			 
4c71				 
4c71					NEXTW 
4c71 c3 a8 22			jp macro_next 
4c74				endm 
# End of macro NEXTW
4c74			.SAVE: 
4c74			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
4c74			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
4c74			;		NEXTW 
4c74			;.LOAD: 
4c74			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
4c74			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
4c74			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
4c74			;; > > The LOAD command can not be used in any user words or compound lines. 
4c74			; 
4c74			;		; store_openext use it. If zero it is EOF 
4c74			; 
4c74			;		; read block from current stream id 
4c74			;		; if the block does not contain zero term keep reading blocks until zero found 
4c74			;		; push the block to stack 
4c74			;		; save the block id to stream 
4c74			; 
4c74			; 
4c74			;		FORTH_DSP_VALUEHL 
4c74			; 
4c74			;;		push hl 
4c74			; 
4c74			;	if DEBUG_STORESE 
4c74			;		DMARK "LOA" 
4c74			;		CALLMONITOR 
4c74			;	endif 
4c74			;		FORTH_DSP_POP 
4c74			; 
4c74			;;		pop hl 
4c74			; 
4c74			;		ld h, l 
4c74			;		ld l, 0 
4c74			; 
4c74			;		push hl     ; stack holds current file id and extent to work with 
4c74			; 
4c74			; 
4c74			;		ld de, store_page      ; get block zero of file 
4c74			;	if DEBUG_STORESE 
4c74			;		DMARK "LO0" 
4c74			;		CALLMONITOR 
4c74			;	endif 
4c74			;		call storage_read 
4c74			; 
4c74			;		ld a, (store_page+2)    ; max extents for this file 
4c74			;		ld  (store_openmaxext),a   ; get our limit 
4c74			; 
4c74			;	if DEBUG_STORESE 
4c74			;		DMARK "LOE" 
4c74			;		CALLMONITOR 
4c74			;	endif 
4c74			; 
4c74			;; TODO dont know why max extents are not present 
4c74			;;		cp 0 
4c74			;;		jp z, .loadeof     ; dont read past eof 
4c74			; 
4c74			;;		ld a, 1   ; start from the head of the file 
4c74			; 
4c74			;.loadline:	pop hl 
4c74			;		inc hl 
4c74			;		ld  a, (store_openmaxext)   ; get our limit 
4c74			;	if DEBUG_STORESE 
4c74			;		DMARK "LOx" 
4c74			;		CALLMONITOR 
4c74			;	endif 
4c74			;		inc a 
4c74			;		cp l 
4c74			;		jp z, .loadeof 
4c74			;		push hl    ; save current extent 
4c74			; 
4c74			;		ld de, store_page 
4c74			; 
4c74			;	if DEBUG_STORESE 
4c74			;		DMARK "LO1" 
4c74			;		CALLMONITOR 
4c74			;	endif 
4c74			;		call storage_read 
4c74			; 
4c74			;	if DEBUG_STORESE 
4c74			;		DMARK "LO2" 
4c74			;		CALLMONITOR 
4c74			;	endif 
4c74			;	call ishlzero 
4c74			;	ld a, l 
4c74			;	add h 
4c74			;	cp 0 
4c74			;	jr z, .loadeof 
4c74			; 
4c74			;	; not eof so hl should point to data to exec 
4c74			; 
4c74			;	; will need to add the FORTH_END_BUFFER flag 
4c74			 ; 
4c74			;	ld hl, store_page+2 
4c74			;	ld bc, 255 
4c74			;	ld a, 0 
4c74			;	cpir 
4c74			;	if DEBUG_STORESE 
4c74			;		DMARK "LOt" 
4c74			;		CALLMONITOR 
4c74			;	endif 
4c74			;	dec hl 
4c74			;	ld a, ' ' 
4c74			;	ld (hl), a 
4c74			;	inc hl 
4c74			;	ld (hl), a 
4c74			;	inc hl 
4c74			;	ld (hl), a 
4c74			;	inc hl 
4c74			;	ld a, FORTH_END_BUFFER 
4c74			;	ld (hl), a 
4c74			; 
4c74			;	; TODO handle more than a single block read 
4c74			; 
4c74			; 
4c74			;	ld hl, store_page+2 
4c74			; 
4c74			;	ld (os_tok_ptr), hl 
4c74			; 
4c74			;	if DEBUG_STORESE 
4c74			;		DMARK "LO3" 
4c74			;		CALLMONITOR 
4c74			;	endif 
4c74			; 
4c74			;	call forthparse 
4c74			;	call forthexec 
4c74			;	call forthexec_cleanup 
4c74			; 
4c74			;	; go to next extent 
4c74			; 
4c74			;	; get next block  or mark as eof 
4c74			;	jp .loadline 
4c74			; 
4c74			; 
4c74			; 
4c74			;	       NEXTW 
4c74			;.loadeof:	ld a, 0 
4c74			;		ld (store_openext), a 
4c74			; 
4c74			;	if DEBUG_STORESE 
4c74			;		DMARK "LOF" 
4c74			;		CALLMONITOR 
4c74			;	endif 
4c74			;		ret 
4c74			;		;NEXTW 
4c74			;.BSAVE:   
4c74			; 
4c74			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
4c74			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
4c74			;		NEXTW 
4c74			;.BLOAD: 
4c74			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
4c74			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
4c74			;		NEXTW 
4c74			;;;; counter gap 
4c74			 
4c74			 
4c74			.SEO: 
4c74				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
4c74 64				db WORD_SYS_CORE+80             
4c75 93 4c			dw .SEI            
4c77 04				db 3 + 1 
4c78 .. 00			db "SEO",0              
4c7c				endm 
# End of macro CWHEAD
4c7c			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
4c7c			 
4c7c					; get port 
4c7c			 
4c7c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4c7c cd 31 21			call macro_dsp_valuehl 
4c7f				endm 
# End of macro FORTH_DSP_VALUEHL
4c7f			 
4c7f e5					push hl    ; u2 - byte 
4c80			 
4c80					; destroy value TOS 
4c80			 
4c80					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c80 cd e9 21			call macro_forth_dsp_pop 
4c83				endm 
# End of macro FORTH_DSP_POP
4c83			 
4c83					; get byte to send 
4c83			 
4c83					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4c83 cd 31 21			call macro_dsp_valuehl 
4c86				endm 
# End of macro FORTH_DSP_VALUEHL
4c86			 
4c86 e5					push hl    ; u1 - addr 
4c87			 
4c87					; destroy value TOS 
4c87			 
4c87					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c87 cd e9 21			call macro_forth_dsp_pop 
4c8a				endm 
# End of macro FORTH_DSP_POP
4c8a			 
4c8a					; one value on hl get other one back 
4c8a			 
4c8a d1					pop de   ; u1 - byte 
4c8b			 
4c8b e1					pop hl   ; u2 - addr 
4c8c			 
4c8c					; TODO Send SPI byte 
4c8c			 
4c8c			 
4c8c 7b					ld a, e 
4c8d cd 1e 02				call se_writebyte 
4c90			 
4c90					 
4c90			 
4c90					NEXTW 
4c90 c3 a8 22			jp macro_next 
4c93				endm 
# End of macro NEXTW
4c93			 
4c93			.SEI: 
4c93				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
4c93 65				db WORD_SYS_CORE+81             
4c94 ad 4c			dw .SFREE            
4c96 04				db 3 + 1 
4c97 .. 00			db "SEI",0              
4c9b				endm 
# End of macro CWHEAD
4c9b			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
4c9b			 
4c9b					; get port 
4c9b			 
4c9b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4c9b cd 31 21			call macro_dsp_valuehl 
4c9e				endm 
# End of macro FORTH_DSP_VALUEHL
4c9e			 
4c9e			;		push hl 
4c9e			 
4c9e					; destroy value TOS 
4c9e			 
4c9e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c9e cd e9 21			call macro_forth_dsp_pop 
4ca1				endm 
# End of macro FORTH_DSP_POP
4ca1			 
4ca1					; one value on hl get other one back 
4ca1			 
4ca1			;		pop hl 
4ca1			 
4ca1			 
4ca1					; TODO Get SPI byte 
4ca1			 
4ca1 cd c0 02				call se_readbyte 
4ca4			 
4ca4 26 00				ld h, 0 
4ca6 6f					ld l, a 
4ca7 cd 3a 1f				call forth_push_numhl 
4caa			 
4caa					NEXTW 
4caa c3 a8 22			jp macro_next 
4cad				endm 
# End of macro NEXTW
4cad			 
4cad			.SFREE: 
4cad				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
4cad 67				db WORD_SYS_CORE+83             
4cae dc 4c			dw .SIZE            
4cb0 06				db 5 + 1 
4cb1 .. 00			db "FFREE",0              
4cb7				endm 
# End of macro CWHEAD
4cb7			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
4cb7					if DEBUG_FORTH_WORDS_KEY 
4cb7						DMARK "FFR" 
4cb7 f5				push af  
4cb8 3a cc 4c			ld a, (.dmark)  
4cbb 32 b4 fe			ld (debug_mark),a  
4cbe 3a cd 4c			ld a, (.dmark+1)  
4cc1 32 b5 fe			ld (debug_mark+1),a  
4cc4 3a ce 4c			ld a, (.dmark+2)  
4cc7 32 b6 fe			ld (debug_mark+2),a  
4cca 18 03			jr .pastdmark  
4ccc ..			.dmark: db "FFR"  
4ccf f1			.pastdmark: pop af  
4cd0			endm  
# End of macro DMARK
4cd0						CALLMONITOR 
4cd0 cd c6 18			call break_point_state  
4cd3				endm  
# End of macro CALLMONITOR
4cd3					endif 
4cd3			 
4cd3 cd e6 07				call storage_freeblocks 
4cd6			 
4cd6 cd 3a 1f				call forth_push_numhl 
4cd9			 
4cd9				       NEXTW 
4cd9 c3 a8 22			jp macro_next 
4cdc				endm 
# End of macro NEXTW
4cdc			.SIZE: 
4cdc				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
4cdc 67				db WORD_SYS_CORE+83             
4cdd 10 4d			dw .CREATE            
4cdf 05				db 4 + 1 
4ce0 .. 00			db "SIZE",0              
4ce5				endm 
# End of macro CWHEAD
4ce5			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
4ce5					if DEBUG_FORTH_WORDS_KEY 
4ce5						DMARK "SIZ" 
4ce5 f5				push af  
4ce6 3a fa 4c			ld a, (.dmark)  
4ce9 32 b4 fe			ld (debug_mark),a  
4cec 3a fb 4c			ld a, (.dmark+1)  
4cef 32 b5 fe			ld (debug_mark+1),a  
4cf2 3a fc 4c			ld a, (.dmark+2)  
4cf5 32 b6 fe			ld (debug_mark+2),a  
4cf8 18 03			jr .pastdmark  
4cfa ..			.dmark: db "SIZ"  
4cfd f1			.pastdmark: pop af  
4cfe			endm  
# End of macro DMARK
4cfe						CALLMONITOR 
4cfe cd c6 18			call break_point_state  
4d01				endm  
# End of macro CALLMONITOR
4d01					endif 
4d01			 
4d01					FORTH_DSP_VALUEHL 
4d01 cd 31 21			call macro_dsp_valuehl 
4d04				endm 
# End of macro FORTH_DSP_VALUEHL
4d04			;		push hl 
4d04					FORTH_DSP_POP 
4d04 cd e9 21			call macro_forth_dsp_pop 
4d07				endm 
# End of macro FORTH_DSP_POP
4d07			;		pop hl 
4d07 cd 48 04				call storage_file_size 
4d0a			 
4d0a cd 3a 1f				call forth_push_numhl 
4d0d			  
4d0d			 
4d0d				       NEXTW 
4d0d c3 a8 22			jp macro_next 
4d10				endm 
# End of macro NEXTW
4d10			 
4d10			.CREATE: 
4d10				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
4d10 68				db WORD_SYS_CORE+84             
4d11 7e 4d			dw .APPEND            
4d13 07				db 6 + 1 
4d14 .. 00			db "CREATE",0              
4d1b				endm 
# End of macro CWHEAD
4d1b			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
4d1b			; | | e.g.  
4d1b			; | | TestProgram CREATE 
4d1b			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
4d1b			; | |  
4d1b			; | | Max file IDs are 255. 
4d1b			; | |  
4d1b					 
4d1b					if DEBUG_FORTH_WORDS_KEY 
4d1b						DMARK "CRT" 
4d1b f5				push af  
4d1c 3a 30 4d			ld a, (.dmark)  
4d1f 32 b4 fe			ld (debug_mark),a  
4d22 3a 31 4d			ld a, (.dmark+1)  
4d25 32 b5 fe			ld (debug_mark+1),a  
4d28 3a 32 4d			ld a, (.dmark+2)  
4d2b 32 b6 fe			ld (debug_mark+2),a  
4d2e 18 03			jr .pastdmark  
4d30 ..			.dmark: db "CRT"  
4d33 f1			.pastdmark: pop af  
4d34			endm  
# End of macro DMARK
4d34						CALLMONITOR 
4d34 cd c6 18			call break_point_state  
4d37				endm  
# End of macro CALLMONITOR
4d37					endif 
4d37			;		call storage_get_block_0 
4d37			 
4d37					; TODO pop hl 
4d37			 
4d37					;v5 FORTH_DSP_VALUE 
4d37					FORTH_DSP_VALUE 
4d37 cd 1a 21			call macro_forth_dsp_value 
4d3a				endm 
# End of macro FORTH_DSP_VALUE
4d3a			 
4d3a				if DEBUG_STORESE 
4d3a					DMARK "CR1" 
4d3a f5				push af  
4d3b 3a 4f 4d			ld a, (.dmark)  
4d3e 32 b4 fe			ld (debug_mark),a  
4d41 3a 50 4d			ld a, (.dmark+1)  
4d44 32 b5 fe			ld (debug_mark+1),a  
4d47 3a 51 4d			ld a, (.dmark+2)  
4d4a 32 b6 fe			ld (debug_mark+2),a  
4d4d 18 03			jr .pastdmark  
4d4f ..			.dmark: db "CR1"  
4d52 f1			.pastdmark: pop af  
4d53			endm  
# End of macro DMARK
4d53					CALLMONITOR 
4d53 cd c6 18			call break_point_state  
4d56				endm  
# End of macro CALLMONITOR
4d56				endif 
4d56			;		push hl 
4d56			;		FORTH_DSP_POP 
4d56			;		pop hl 
4d56			 
4d56			;		inc hl   ; move past the type marker 
4d56			 
4d56 cd 1c 08				call storage_create 
4d59			 
4d59				if DEBUG_STORESE 
4d59					DMARK "CT1" 
4d59 f5				push af  
4d5a 3a 6e 4d			ld a, (.dmark)  
4d5d 32 b4 fe			ld (debug_mark),a  
4d60 3a 6f 4d			ld a, (.dmark+1)  
4d63 32 b5 fe			ld (debug_mark+1),a  
4d66 3a 70 4d			ld a, (.dmark+2)  
4d69 32 b6 fe			ld (debug_mark+2),a  
4d6c 18 03			jr .pastdmark  
4d6e ..			.dmark: db "CT1"  
4d71 f1			.pastdmark: pop af  
4d72			endm  
# End of macro DMARK
4d72					CALLMONITOR 
4d72 cd c6 18			call break_point_state  
4d75				endm  
# End of macro CALLMONITOR
4d75				endif 
4d75			;		push hl 
4d75					FORTH_DSP_POP 
4d75 cd e9 21			call macro_forth_dsp_pop 
4d78				endm 
# End of macro FORTH_DSP_POP
4d78			;		pop hl 
4d78					; push file id to stack 
4d78 cd 3a 1f				call forth_push_numhl 
4d7b			 
4d7b			 
4d7b			 
4d7b				       NEXTW 
4d7b c3 a8 22			jp macro_next 
4d7e				endm 
# End of macro NEXTW
4d7e			 
4d7e			.APPEND: 
4d7e				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
4d7e 69				db WORD_SYS_CORE+85             
4d7f 0f 4e			dw .SDEL            
4d81 07				db 6 + 1 
4d82 .. 00			db "APPEND",0              
4d89				endm 
# End of macro CWHEAD
4d89			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
4d89			; | | e.g. 
4d89			; | | Test CREATE      -> $01 
4d89			; | | "A string to add to file" $01 APPEND 
4d89			; | |  
4d89			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
4d89					if DEBUG_FORTH_WORDS_KEY 
4d89						DMARK "APP" 
4d89 f5				push af  
4d8a 3a 9e 4d			ld a, (.dmark)  
4d8d 32 b4 fe			ld (debug_mark),a  
4d90 3a 9f 4d			ld a, (.dmark+1)  
4d93 32 b5 fe			ld (debug_mark+1),a  
4d96 3a a0 4d			ld a, (.dmark+2)  
4d99 32 b6 fe			ld (debug_mark+2),a  
4d9c 18 03			jr .pastdmark  
4d9e ..			.dmark: db "APP"  
4da1 f1			.pastdmark: pop af  
4da2			endm  
# End of macro DMARK
4da2						CALLMONITOR 
4da2 cd c6 18			call break_point_state  
4da5				endm  
# End of macro CALLMONITOR
4da5					endif 
4da5			 
4da5					FORTH_DSP_VALUEHL 
4da5 cd 31 21			call macro_dsp_valuehl 
4da8				endm 
# End of macro FORTH_DSP_VALUEHL
4da8 e5					push hl 	; save file id 
4da9			 
4da9				if DEBUG_STORESE 
4da9					DMARK "AP1" 
4da9 f5				push af  
4daa 3a be 4d			ld a, (.dmark)  
4dad 32 b4 fe			ld (debug_mark),a  
4db0 3a bf 4d			ld a, (.dmark+1)  
4db3 32 b5 fe			ld (debug_mark+1),a  
4db6 3a c0 4d			ld a, (.dmark+2)  
4db9 32 b6 fe			ld (debug_mark+2),a  
4dbc 18 03			jr .pastdmark  
4dbe ..			.dmark: db "AP1"  
4dc1 f1			.pastdmark: pop af  
4dc2			endm  
# End of macro DMARK
4dc2					CALLMONITOR 
4dc2 cd c6 18			call break_point_state  
4dc5				endm  
# End of macro CALLMONITOR
4dc5				endif 
4dc5					FORTH_DSP_POP 
4dc5 cd e9 21			call macro_forth_dsp_pop 
4dc8				endm 
# End of macro FORTH_DSP_POP
4dc8			 
4dc8					FORTH_DSP_VALUEHL 
4dc8 cd 31 21			call macro_dsp_valuehl 
4dcb				endm 
# End of macro FORTH_DSP_VALUEHL
4dcb					;v5 FORTH_DSP_VALUE 
4dcb e5					push hl 	; save ptr to string to save 
4dcc			 
4dcc				if DEBUG_STORESE 
4dcc					DMARK "AP1" 
4dcc f5				push af  
4dcd 3a e1 4d			ld a, (.dmark)  
4dd0 32 b4 fe			ld (debug_mark),a  
4dd3 3a e2 4d			ld a, (.dmark+1)  
4dd6 32 b5 fe			ld (debug_mark+1),a  
4dd9 3a e3 4d			ld a, (.dmark+2)  
4ddc 32 b6 fe			ld (debug_mark+2),a  
4ddf 18 03			jr .pastdmark  
4de1 ..			.dmark: db "AP1"  
4de4 f1			.pastdmark: pop af  
4de5			endm  
# End of macro DMARK
4de5					CALLMONITOR 
4de5 cd c6 18			call break_point_state  
4de8				endm  
# End of macro CALLMONITOR
4de8				endif 
4de8					FORTH_DSP_POP 
4de8 cd e9 21			call macro_forth_dsp_pop 
4deb				endm 
# End of macro FORTH_DSP_POP
4deb			 
4deb d1					pop de 
4dec e1					pop hl 
4ded				if DEBUG_STORESE 
4ded					DMARK "AP2" 
4ded f5				push af  
4dee 3a 02 4e			ld a, (.dmark)  
4df1 32 b4 fe			ld (debug_mark),a  
4df4 3a 03 4e			ld a, (.dmark+1)  
4df7 32 b5 fe			ld (debug_mark+1),a  
4dfa 3a 04 4e			ld a, (.dmark+2)  
4dfd 32 b6 fe			ld (debug_mark+2),a  
4e00 18 03			jr .pastdmark  
4e02 ..			.dmark: db "AP2"  
4e05 f1			.pastdmark: pop af  
4e06			endm  
# End of macro DMARK
4e06					CALLMONITOR 
4e06 cd c6 18			call break_point_state  
4e09				endm  
# End of macro CALLMONITOR
4e09				endif 
4e09					;inc de ; skip var type indicator 
4e09			 
4e09					; TODO how to append numerics???? 
4e09			 
4e09 cd 09 0b				call storage_append		 
4e0c			 
4e0c				       NEXTW 
4e0c c3 a8 22			jp macro_next 
4e0f				endm 
# End of macro NEXTW
4e0f			.SDEL: 
4e0f				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
4e0f 6a				db WORD_SYS_CORE+86             
4e10 5b 4e			dw .OPEN            
4e12 05				db 4 + 1 
4e13 .. 00			db "ERA",0              
4e17				endm 
# End of macro CWHEAD
4e17			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
4e17					FORTH_DSP_VALUEHL 
4e17 cd 31 21			call macro_dsp_valuehl 
4e1a				endm 
# End of macro FORTH_DSP_VALUEHL
4e1a			;		push hl 	; save file id 
4e1a			 
4e1a					if DEBUG_FORTH_WORDS_KEY 
4e1a						DMARK "ERA" 
4e1a f5				push af  
4e1b 3a 2f 4e			ld a, (.dmark)  
4e1e 32 b4 fe			ld (debug_mark),a  
4e21 3a 30 4e			ld a, (.dmark+1)  
4e24 32 b5 fe			ld (debug_mark+1),a  
4e27 3a 31 4e			ld a, (.dmark+2)  
4e2a 32 b6 fe			ld (debug_mark+2),a  
4e2d 18 03			jr .pastdmark  
4e2f ..			.dmark: db "ERA"  
4e32 f1			.pastdmark: pop af  
4e33			endm  
# End of macro DMARK
4e33						CALLMONITOR 
4e33 cd c6 18			call break_point_state  
4e36				endm  
# End of macro CALLMONITOR
4e36					endif 
4e36				if DEBUG_STORESE 
4e36					DMARK "ER1" 
4e36 f5				push af  
4e37 3a 4b 4e			ld a, (.dmark)  
4e3a 32 b4 fe			ld (debug_mark),a  
4e3d 3a 4c 4e			ld a, (.dmark+1)  
4e40 32 b5 fe			ld (debug_mark+1),a  
4e43 3a 4d 4e			ld a, (.dmark+2)  
4e46 32 b6 fe			ld (debug_mark+2),a  
4e49 18 03			jr .pastdmark  
4e4b ..			.dmark: db "ER1"  
4e4e f1			.pastdmark: pop af  
4e4f			endm  
# End of macro DMARK
4e4f					CALLMONITOR 
4e4f cd c6 18			call break_point_state  
4e52				endm  
# End of macro CALLMONITOR
4e52				endif 
4e52					FORTH_DSP_POP 
4e52 cd e9 21			call macro_forth_dsp_pop 
4e55				endm 
# End of macro FORTH_DSP_POP
4e55			 
4e55			;		pop hl 
4e55			 
4e55 cd 5b 06				call storage_erase 
4e58				       NEXTW 
4e58 c3 a8 22			jp macro_next 
4e5b				endm 
# End of macro NEXTW
4e5b			 
4e5b			.OPEN: 
4e5b				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
4e5b 6b				db WORD_SYS_CORE+87             
4e5c ef 4e			dw .READ            
4e5e 05				db 4 + 1 
4e5f .. 00			db "OPEN",0              
4e64				endm 
# End of macro CWHEAD
4e64			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
4e64			; | | e.g. 
4e64			; | | $01 OPEN $01 DO $01 READ . LOOP 
4e64			; | | 
4e64			; | | Will return with 255 blocks if the file does not exist 
4e64			 
4e64					if DEBUG_FORTH_WORDS_KEY 
4e64						DMARK "OPN" 
4e64 f5				push af  
4e65 3a 79 4e			ld a, (.dmark)  
4e68 32 b4 fe			ld (debug_mark),a  
4e6b 3a 7a 4e			ld a, (.dmark+1)  
4e6e 32 b5 fe			ld (debug_mark+1),a  
4e71 3a 7b 4e			ld a, (.dmark+2)  
4e74 32 b6 fe			ld (debug_mark+2),a  
4e77 18 03			jr .pastdmark  
4e79 ..			.dmark: db "OPN"  
4e7c f1			.pastdmark: pop af  
4e7d			endm  
# End of macro DMARK
4e7d						CALLMONITOR 
4e7d cd c6 18			call break_point_state  
4e80				endm  
# End of macro CALLMONITOR
4e80					endif 
4e80					; TODO handle multiple file opens 
4e80			 
4e80 3e 01			       	ld a, 1 
4e82 32 f7 fb				ld (store_openext), a 
4e85			 
4e85					; get max extents for this file 
4e85				 
4e85								 
4e85					FORTH_DSP_VALUEHL 
4e85 cd 31 21			call macro_dsp_valuehl 
4e88				endm 
# End of macro FORTH_DSP_VALUEHL
4e88			 
4e88 65					ld h, l 
4e89 2e 00				ld l, 0 
4e8b			 
4e8b					; store file id 
4e8b			 
4e8b 7c					ld a, h 
4e8c 32 f4 fb				ld (store_filecache), a 
4e8f			 
4e8f				if DEBUG_STORESE 
4e8f					DMARK "OPN" 
4e8f f5				push af  
4e90 3a a4 4e			ld a, (.dmark)  
4e93 32 b4 fe			ld (debug_mark),a  
4e96 3a a5 4e			ld a, (.dmark+1)  
4e99 32 b5 fe			ld (debug_mark+1),a  
4e9c 3a a6 4e			ld a, (.dmark+2)  
4e9f 32 b6 fe			ld (debug_mark+2),a  
4ea2 18 03			jr .pastdmark  
4ea4 ..			.dmark: db "OPN"  
4ea7 f1			.pastdmark: pop af  
4ea8			endm  
# End of macro DMARK
4ea8					CALLMONITOR 
4ea8 cd c6 18			call break_point_state  
4eab				endm  
# End of macro CALLMONITOR
4eab				endif 
4eab			;		push hl 
4eab					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
4eab cd e9 21			call macro_forth_dsp_pop 
4eae				endm 
# End of macro FORTH_DSP_POP
4eae			;		pop hl 
4eae						 
4eae 11 07 fc				ld de, store_page      ; get block zero of file 
4eb1 cd 72 09				call storage_read 
4eb4 cd 72 0f			call ishlzero 
4eb7 20 04			jr nz, .opfound 
4eb9			 
4eb9				; file does not exist so indicate with 255 extents in use 
4eb9			 
4eb9 3e ff			ld a, 255 
4ebb 18 29			jr .skipopeneof 
4ebd			 
4ebd			 
4ebd			.opfound: 
4ebd			 
4ebd			 
4ebd 3a 09 fc				ld a, (store_page+2)    ; max extents for this file 
4ec0 32 f6 fb				ld  (store_openmaxext), a   ; get our limit and push 
4ec3					 
4ec3				if DEBUG_STORESE 
4ec3					DMARK "OPx" 
4ec3 f5				push af  
4ec4 3a d8 4e			ld a, (.dmark)  
4ec7 32 b4 fe			ld (debug_mark),a  
4eca 3a d9 4e			ld a, (.dmark+1)  
4ecd 32 b5 fe			ld (debug_mark+1),a  
4ed0 3a da 4e			ld a, (.dmark+2)  
4ed3 32 b6 fe			ld (debug_mark+2),a  
4ed6 18 03			jr .pastdmark  
4ed8 ..			.dmark: db "OPx"  
4edb f1			.pastdmark: pop af  
4edc			endm  
# End of macro DMARK
4edc					CALLMONITOR 
4edc cd c6 18			call break_point_state  
4edf				endm  
# End of macro CALLMONITOR
4edf				endif 
4edf fe 00				cp 0 
4ee1 20 03				jr nz, .skipopeneof 
4ee3					; have opened an empty file 
4ee3					 
4ee3 32 f7 fb				ld (store_openext), a 
4ee6			 
4ee6			.skipopeneof: 
4ee6			 
4ee6 6f					ld l, a 
4ee7 26 00				ld h, 0 
4ee9 cd 3a 1f				call forth_push_numhl 
4eec			 
4eec			 
4eec				       NEXTW 
4eec c3 a8 22			jp macro_next 
4eef				endm 
# End of macro NEXTW
4eef			.READ: 
4eef				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
4eef 6c				db WORD_SYS_CORE+88             
4ef0 19 50			dw .EOF            
4ef2 05				db 4 + 1 
4ef3 .. 00			db "READ",0              
4ef8				endm 
# End of macro CWHEAD
4ef8			; | READ ( -- n  )  Reads next page of current file id and push to stack | DONE 
4ef8			; | | e.g. 
4ef8			; | | $01 OPEN $01 DO READ . LOOP 
4ef8			; | | 
4ef8			; | | As this word only reads one 64 byte block in at a time, if the APPEND word has created extra blocks for the excess, this READ 
4ef8			; | | word is unaware so the long string needs to be joined if the string is a full. A single block read might be what you want, 
4ef8			; | | but if not then writing a word to join blocks will be required. The upshot is a full string will be 62 bytes as the first 
4ef8			; | | two bytes contain the file id and extent. 
4ef8			; | |  
4ef8			; | | Note: There is a flag that enables/disables long block reads called 'store_longread' and a poke of a non-zero value will 
4ef8			; | | enable the code to automatically read futher blocks if full. It is BUGGY so don't use for now. 
4ef8			 
4ef8					if DEBUG_FORTH_WORDS_KEY 
4ef8						DMARK "REA" 
4ef8 f5				push af  
4ef9 3a 0d 4f			ld a, (.dmark)  
4efc 32 b4 fe			ld (debug_mark),a  
4eff 3a 0e 4f			ld a, (.dmark+1)  
4f02 32 b5 fe			ld (debug_mark+1),a  
4f05 3a 0f 4f			ld a, (.dmark+2)  
4f08 32 b6 fe			ld (debug_mark+2),a  
4f0b 18 03			jr .pastdmark  
4f0d ..			.dmark: db "REA"  
4f10 f1			.pastdmark: pop af  
4f11			endm  
# End of macro DMARK
4f11						CALLMONITOR 
4f11 cd c6 18			call break_point_state  
4f14				endm  
# End of macro CALLMONITOR
4f14					endif 
4f14					; store_openext use it. If zero it is EOF 
4f14			 
4f14					; read block from current stream id 
4f14					; if the block does not contain zero term keep reading blocks until zero found 
4f14					; push the block to stack 
4f14					; save the block id to stream 
4f14			 
4f14			 
4f14 cd 46 50				call .testeof 
4f17 3e 01				ld a, 1 
4f19 bd					cp l 
4f1a ca f5 4f				jp z, .ateof 
4f1d			 
4f1d			 
4f1d			;		FORTH_DSP_VALUEHL 
4f1d			 
4f1d			;		push hl 
4f1d			 
4f1d			;	if DEBUG_STORESE 
4f1d			;		DMARK "REA" 
4f1d			;		CALLMONITOR 
4f1d			;	endif 
4f1d			;		FORTH_DSP_POP 
4f1d			 
4f1d			;		pop hl 
4f1d				 
4f1d 3a f4 fb				ld a, (store_filecache) 
4f20 67					ld h,a 
4f21			 
4f21 3a f7 fb				ld a, (store_openext) 
4f24 6f					ld l, a 
4f25					 
4f25 fe 00				cp 0 
4f27 ca f5 4f				jp z, .ateof     ; dont read past eof 
4f2a			 
4f2a cd 55 0c				call storage_clear_page 
4f2d			 
4f2d 11 07 fc				ld de, store_page 
4f30				if DEBUG_STORESE 
4f30					DMARK "RE1" 
4f30 f5				push af  
4f31 3a 45 4f			ld a, (.dmark)  
4f34 32 b4 fe			ld (debug_mark),a  
4f37 3a 46 4f			ld a, (.dmark+1)  
4f3a 32 b5 fe			ld (debug_mark+1),a  
4f3d 3a 47 4f			ld a, (.dmark+2)  
4f40 32 b6 fe			ld (debug_mark+2),a  
4f43 18 03			jr .pastdmark  
4f45 ..			.dmark: db "RE1"  
4f48 f1			.pastdmark: pop af  
4f49			endm  
# End of macro DMARK
4f49					CALLMONITOR 
4f49 cd c6 18			call break_point_state  
4f4c				endm  
# End of macro CALLMONITOR
4f4c				endif 
4f4c cd 72 09				call storage_read 
4f4f			 
4f4f				if DEBUG_STORESE 
4f4f					DMARK "RE2" 
4f4f f5				push af  
4f50 3a 64 4f			ld a, (.dmark)  
4f53 32 b4 fe			ld (debug_mark),a  
4f56 3a 65 4f			ld a, (.dmark+1)  
4f59 32 b5 fe			ld (debug_mark+1),a  
4f5c 3a 66 4f			ld a, (.dmark+2)  
4f5f 32 b6 fe			ld (debug_mark+2),a  
4f62 18 03			jr .pastdmark  
4f64 ..			.dmark: db "RE2"  
4f67 f1			.pastdmark: pop af  
4f68			endm  
# End of macro DMARK
4f68					CALLMONITOR 
4f68 cd c6 18			call break_point_state  
4f6b				endm  
# End of macro CALLMONITOR
4f6b				endif 
4f6b cd 72 0f			call ishlzero 
4f6e			;	ld a, l 
4f6e			;	add h 
4f6e			;	cp 0 
4f6e ca f5 4f			jp z, .readeof 
4f71			 
4f71				; not eof so hl should point to data to push to stack 
4f71			 
4f71				if DEBUG_STORESE 
4f71					DMARK "RE3" 
4f71 f5				push af  
4f72 3a 86 4f			ld a, (.dmark)  
4f75 32 b4 fe			ld (debug_mark),a  
4f78 3a 87 4f			ld a, (.dmark+1)  
4f7b 32 b5 fe			ld (debug_mark+1),a  
4f7e 3a 88 4f			ld a, (.dmark+2)  
4f81 32 b6 fe			ld (debug_mark+2),a  
4f84 18 03			jr .pastdmark  
4f86 ..			.dmark: db "RE3"  
4f89 f1			.pastdmark: pop af  
4f8a			endm  
# End of macro DMARK
4f8a					CALLMONITOR 
4f8a cd c6 18			call break_point_state  
4f8d				endm  
# End of macro CALLMONITOR
4f8d				endif 
4f8d cd a8 1f			call forth_push_str 
4f90			 
4f90				if DEBUG_STORESE 
4f90					DMARK "RE4" 
4f90 f5				push af  
4f91 3a a5 4f			ld a, (.dmark)  
4f94 32 b4 fe			ld (debug_mark),a  
4f97 3a a6 4f			ld a, (.dmark+1)  
4f9a 32 b5 fe			ld (debug_mark+1),a  
4f9d 3a a7 4f			ld a, (.dmark+2)  
4fa0 32 b6 fe			ld (debug_mark+2),a  
4fa3 18 03			jr .pastdmark  
4fa5 ..			.dmark: db "RE4"  
4fa8 f1			.pastdmark: pop af  
4fa9			endm  
# End of macro DMARK
4fa9					CALLMONITOR 
4fa9 cd c6 18			call break_point_state  
4fac				endm  
# End of macro CALLMONITOR
4fac				endif 
4fac				; get next block  or mark as eof 
4fac			 
4fac 3a f6 fb			ld a, (store_openmaxext)   ; get our limit 
4faf 4f				ld c, a	 
4fb0 3a f7 fb			ld a, (store_openext) 
4fb3			 
4fb3				if DEBUG_STORESE 
4fb3					DMARK "RE5" 
4fb3 f5				push af  
4fb4 3a c8 4f			ld a, (.dmark)  
4fb7 32 b4 fe			ld (debug_mark),a  
4fba 3a c9 4f			ld a, (.dmark+1)  
4fbd 32 b5 fe			ld (debug_mark+1),a  
4fc0 3a ca 4f			ld a, (.dmark+2)  
4fc3 32 b6 fe			ld (debug_mark+2),a  
4fc6 18 03			jr .pastdmark  
4fc8 ..			.dmark: db "RE5"  
4fcb f1			.pastdmark: pop af  
4fcc			endm  
# End of macro DMARK
4fcc					CALLMONITOR 
4fcc cd c6 18			call break_point_state  
4fcf				endm  
# End of macro CALLMONITOR
4fcf				endif 
4fcf b9				cp c 
4fd0 28 23			jr z, .readeof     ; at last extent 
4fd2			 
4fd2 3c					inc a 
4fd3 32 f7 fb				ld (store_openext), a 
4fd6			 
4fd6				if DEBUG_STORESE 
4fd6					DMARK "RE6" 
4fd6 f5				push af  
4fd7 3a eb 4f			ld a, (.dmark)  
4fda 32 b4 fe			ld (debug_mark),a  
4fdd 3a ec 4f			ld a, (.dmark+1)  
4fe0 32 b5 fe			ld (debug_mark+1),a  
4fe3 3a ed 4f			ld a, (.dmark+2)  
4fe6 32 b6 fe			ld (debug_mark+2),a  
4fe9 18 03			jr .pastdmark  
4feb ..			.dmark: db "RE6"  
4fee f1			.pastdmark: pop af  
4fef			endm  
# End of macro DMARK
4fef					CALLMONITOR 
4fef cd c6 18			call break_point_state  
4ff2				endm  
# End of macro CALLMONITOR
4ff2				endif 
4ff2			 
4ff2			 
4ff2				       NEXTW 
4ff2 c3 a8 22			jp macro_next 
4ff5				endm 
# End of macro NEXTW
4ff5			.ateof: 
4ff5				;	ld hl, .showeof 
4ff5				;	call forth_push_str 
4ff5 3e 00		.readeof:	ld a, 0 
4ff7 32 f7 fb				ld (store_openext), a 
4ffa			 
4ffa					 
4ffa				if DEBUG_STORESE 
4ffa					DMARK "REF" 
4ffa f5				push af  
4ffb 3a 0f 50			ld a, (.dmark)  
4ffe 32 b4 fe			ld (debug_mark),a  
5001 3a 10 50			ld a, (.dmark+1)  
5004 32 b5 fe			ld (debug_mark+1),a  
5007 3a 11 50			ld a, (.dmark+2)  
500a 32 b6 fe			ld (debug_mark+2),a  
500d 18 03			jr .pastdmark  
500f ..			.dmark: db "REF"  
5012 f1			.pastdmark: pop af  
5013			endm  
# End of macro DMARK
5013					CALLMONITOR 
5013 cd c6 18			call break_point_state  
5016				endm  
# End of macro CALLMONITOR
5016				endif 
5016				       NEXTW 
5016 c3 a8 22			jp macro_next 
5019				endm 
# End of macro NEXTW
5019			 
5019			;.showeof:   db "eof", 0 
5019			 
5019			 
5019			.EOF: 
5019				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
5019 6d				db WORD_SYS_CORE+89             
501a 5b 50			dw .FORMAT            
501c 04				db 3 + 1 
501d .. 00			db "EOF",0              
5021				endm 
# End of macro CWHEAD
5021			; | EOF ( -- u )  Returns EOF logical state of current open file id | DONE 
5021			; | | e.g. 
5021			; | | $01 OPEN REPEAT READ EOF $00 IF LOOP 
5021					; TODO if current block id for stream is zero then push true else false 
5021			 
5021					if DEBUG_FORTH_WORDS_KEY 
5021						DMARK "EOF" 
5021 f5				push af  
5022 3a 36 50			ld a, (.dmark)  
5025 32 b4 fe			ld (debug_mark),a  
5028 3a 37 50			ld a, (.dmark+1)  
502b 32 b5 fe			ld (debug_mark+1),a  
502e 3a 38 50			ld a, (.dmark+2)  
5031 32 b6 fe			ld (debug_mark+2),a  
5034 18 03			jr .pastdmark  
5036 ..			.dmark: db "EOF"  
5039 f1			.pastdmark: pop af  
503a			endm  
# End of macro DMARK
503a						CALLMONITOR 
503a cd c6 18			call break_point_state  
503d				endm  
# End of macro CALLMONITOR
503d					endif 
503d			 
503d					; TODO handlue multiple file streams 
503d			 
503d			;		FORTH_iDSP_POP     ; for now just get rid of stream id 
503d cd 46 50				call .testeof 
5040 cd 3a 1f				call forth_push_numhl 
5043			 
5043			 
5043				       NEXTW 
5043 c3 a8 22			jp macro_next 
5046				endm 
# End of macro NEXTW
5046			 
5046			.testeof: 
5046 2e 01				ld l, 1 
5048 3a f6 fb				ld a, (store_openmaxext) 
504b fe 00				cp 0 
504d 28 09				jr  z, .eofdone   ; empty file 
504f 3a f7 fb				ld a, (store_openext) 
5052 fe 00				cp 0 
5054 28 02				jr  z, .eofdone 
5056 2e 00				ld l, 0 
5058 26 00		.eofdone:	ld h, 0 
505a c9					ret 
505b			 
505b			 
505b			 
505b			 
505b			.FORMAT: 
505b				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
505b 6d				db WORD_SYS_CORE+89             
505c ac 50			dw .LABEL            
505e 07				db 6 + 1 
505f .. 00			db "FORMAT",0              
5066				endm 
# End of macro CWHEAD
5066			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
5066					; TODO if current block id for stream is zero then push true else false 
5066				 
5066				if DEBUG_STORESE 
5066					DMARK "FOR" 
5066 f5				push af  
5067 3a 7b 50			ld a, (.dmark)  
506a 32 b4 fe			ld (debug_mark),a  
506d 3a 7c 50			ld a, (.dmark+1)  
5070 32 b5 fe			ld (debug_mark+1),a  
5073 3a 7d 50			ld a, (.dmark+2)  
5076 32 b6 fe			ld (debug_mark+2),a  
5079 18 03			jr .pastdmark  
507b ..			.dmark: db "FOR"  
507e f1			.pastdmark: pop af  
507f			endm  
# End of macro DMARK
507f					CALLMONITOR 
507f cd c6 18			call break_point_state  
5082				endm  
# End of macro CALLMONITOR
5082				endif 
5082					; Wipes the bank check flags to cause a reformat on next block 0 read 
5082			 
5082 21 01 00				ld hl, 1 
5085 3e 00				ld a, 0 
5087 cd 1e 02				call se_writebyte 
508a			 
508a				if DEBUG_STORESE 
508a					DMARK "FO0" 
508a f5				push af  
508b 3a 9f 50			ld a, (.dmark)  
508e 32 b4 fe			ld (debug_mark),a  
5091 3a a0 50			ld a, (.dmark+1)  
5094 32 b5 fe			ld (debug_mark+1),a  
5097 3a a1 50			ld a, (.dmark+2)  
509a 32 b6 fe			ld (debug_mark+2),a  
509d 18 03			jr .pastdmark  
509f ..			.dmark: db "FO0"  
50a2 f1			.pastdmark: pop af  
50a3			endm  
# End of macro DMARK
50a3					CALLMONITOR 
50a3 cd c6 18			call break_point_state  
50a6				endm  
# End of macro CALLMONITOR
50a6				endif 
50a6					; force bank init 
50a6			 
50a6 cd ca 04				call storage_get_block_0 
50a9					 
50a9				       NEXTW 
50a9 c3 a8 22			jp macro_next 
50ac				endm 
# End of macro NEXTW
50ac			.LABEL: 
50ac				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
50ac 6d				db WORD_SYS_CORE+89             
50ad fa 50			dw .STOREPAGE            
50af 06				db 5 + 1 
50b0 .. 00			db "LABEL",0              
50b6				endm 
# End of macro CWHEAD
50b6			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
50b6					; TODO test to see if bank is selected 
50b6				 
50b6					if DEBUG_FORTH_WORDS_KEY 
50b6						DMARK "LBL" 
50b6 f5				push af  
50b7 3a cb 50			ld a, (.dmark)  
50ba 32 b4 fe			ld (debug_mark),a  
50bd 3a cc 50			ld a, (.dmark+1)  
50c0 32 b5 fe			ld (debug_mark+1),a  
50c3 3a cd 50			ld a, (.dmark+2)  
50c6 32 b6 fe			ld (debug_mark+2),a  
50c9 18 03			jr .pastdmark  
50cb ..			.dmark: db "LBL"  
50ce f1			.pastdmark: pop af  
50cf			endm  
# End of macro DMARK
50cf						CALLMONITOR 
50cf cd c6 18			call break_point_state  
50d2				endm  
# End of macro CALLMONITOR
50d2					endif 
50d2			;	if DEBUG_STORESE 
50d2			;		DMARK "LBL" 
50d2			;		CALLMONITOR 
50d2			;	endif 
50d2					FORTH_DSP_VALUEHL 
50d2 cd 31 21			call macro_dsp_valuehl 
50d5				endm 
# End of macro FORTH_DSP_VALUEHL
50d5					;v5FORTH_DSP_VALUE 
50d5					 
50d5			;		push hl 
50d5					FORTH_DSP_POP 
50d5 cd e9 21			call macro_forth_dsp_pop 
50d8				endm 
# End of macro FORTH_DSP_POP
50d8			;		pop hl 
50d8			 
50d8			;v5		inc hl   ; move past the type marker 
50d8			 
50d8				if DEBUG_STORESE 
50d8					DMARK "LBl" 
50d8 f5				push af  
50d9 3a ed 50			ld a, (.dmark)  
50dc 32 b4 fe			ld (debug_mark),a  
50df 3a ee 50			ld a, (.dmark+1)  
50e2 32 b5 fe			ld (debug_mark+1),a  
50e5 3a ef 50			ld a, (.dmark+2)  
50e8 32 b6 fe			ld (debug_mark+2),a  
50eb 18 03			jr .pastdmark  
50ed ..			.dmark: db "LBl"  
50f0 f1			.pastdmark: pop af  
50f1			endm  
# End of macro DMARK
50f1					CALLMONITOR 
50f1 cd c6 18			call break_point_state  
50f4				endm  
# End of macro CALLMONITOR
50f4				endif 
50f4 cd ee 05				call storage_label 
50f7			 
50f7				       NEXTW 
50f7 c3 a8 22			jp macro_next 
50fa				endm 
# End of macro NEXTW
50fa			.STOREPAGE: 
50fa				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
50fa 6d				db WORD_SYS_CORE+89             
50fb 2d 51			dw .LABELS            
50fd 0a				db 9 + 1 
50fe .. 00			db "STOREPAGE",0              
5108				endm 
# End of macro CWHEAD
5108			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
5108					; TODO test to see if bank is selected 
5108				 
5108					if DEBUG_FORTH_WORDS_KEY 
5108						DMARK "STP" 
5108 f5				push af  
5109 3a 1d 51			ld a, (.dmark)  
510c 32 b4 fe			ld (debug_mark),a  
510f 3a 1e 51			ld a, (.dmark+1)  
5112 32 b5 fe			ld (debug_mark+1),a  
5115 3a 1f 51			ld a, (.dmark+2)  
5118 32 b6 fe			ld (debug_mark+2),a  
511b 18 03			jr .pastdmark  
511d ..			.dmark: db "STP"  
5120 f1			.pastdmark: pop af  
5121			endm  
# End of macro DMARK
5121						CALLMONITOR 
5121 cd c6 18			call break_point_state  
5124				endm  
# End of macro CALLMONITOR
5124					endif 
5124			;	if DEBUG_STORESE 
5124			;		DMARK "STP" 
5124			;		CALLMONITOR 
5124			;	endif 
5124			 
5124 21 07 fc			ld hl, store_page 
5127 cd 3a 1f			call forth_push_numhl 
512a			 
512a			 
512a				       NEXTW 
512a c3 a8 22			jp macro_next 
512d				endm 
# End of macro NEXTW
512d			.LABELS: 
512d				CWHEAD .SCONST1 89 "LABELS" 6 WORD_FLAG_CODE 
512d 6d				db WORD_SYS_CORE+89             
512e b7 51			dw .SCONST1            
5130 07				db 6 + 1 
5131 .. 00			db "LABELS",0              
5138				endm 
# End of macro CWHEAD
5138			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | TO TEST 
5138					;  
5138			 
5138					; save the current device selected to restore afterwards 
5138				 
5138 3a ed fb				ld a, (spi_device) 
513b f5					push af 
513c			 
513c			 
513c					; run through each of the banks 
513c			 
513c 21 01 00				ld hl, 1 
513f cd 3a 1f				call forth_push_numhl 
5142 3e ff				ld a, SPI_CE_HIGH 
5144 cb 87				res SPI_CE0, a 
5146 32 ed fb				ld (spi_device), a 
5149 cd ca 04				call storage_get_block_0 
514c 21 0a fc				ld hl, store_page+3 
514f cd a8 1f				call forth_push_str 
5152			 
5152					 
5152 21 02 00				ld hl, 2 
5155 cd 3a 1f				call forth_push_numhl 
5158 3e ff				ld a, SPI_CE_HIGH 
515a cb 8f				res SPI_CE1, a 
515c 32 ed fb				ld (spi_device), a 
515f cd ca 04				call storage_get_block_0 
5162 21 0a fc				ld hl, store_page+3 
5165 cd a8 1f				call forth_push_str 
5168			 
5168					 
5168 21 03 00				ld hl, 3 
516b cd 3a 1f				call forth_push_numhl 
516e 3e ff				ld a, SPI_CE_HIGH 
5170 cb 97				res SPI_CE2, a 
5172 32 ed fb				ld (spi_device), a 
5175 cd ca 04				call storage_get_block_0 
5178 21 0a fc				ld hl, store_page+3 
517b cd a8 1f				call forth_push_str 
517e			 
517e			 
517e 21 04 00				ld hl, 4 
5181 cd 3a 1f				call forth_push_numhl 
5184 3e ff				ld a, SPI_CE_HIGH 
5186 cb 9f				res SPI_CE3, a 
5188 32 ed fb				ld (spi_device), a 
518b cd ca 04				call storage_get_block_0 
518e 21 0a fc				ld hl, store_page+3 
5191 cd a8 1f				call forth_push_str 
5194			 
5194					 
5194			 
5194 21 05 00				ld hl, 5 
5197 cd 3a 1f				call forth_push_numhl 
519a 3e ff				ld a, SPI_CE_HIGH 
519c cb a7				res SPI_CE4, a 
519e 32 ed fb				ld (spi_device), a 
51a1 cd ca 04				call storage_get_block_0 
51a4 21 0a fc				ld hl, store_page+3 
51a7 cd a8 1f				call forth_push_str 
51aa			 
51aa					 
51aa					; push fixed count of storage devices (on board) for now 
51aa			 
51aa 21 05 00				ld hl, 5 
51ad cd 3a 1f				call forth_push_numhl 
51b0			 
51b0					; restore selected device  
51b0				 
51b0 f1					pop af 
51b1 32 ed fb				ld (spi_device), a 
51b4			 
51b4				       NEXTW 
51b4 c3 a8 22			jp macro_next 
51b7				endm 
# End of macro NEXTW
51b7			 
51b7			.SCONST1: 
51b7				CWHEAD .SCONST2 89 "FILEID" 6 WORD_FLAG_CODE 
51b7 6d				db WORD_SYS_CORE+89             
51b8 ce 51			dw .SCONST2            
51ba 07				db 6 + 1 
51bb .. 00			db "FILEID",0              
51c2				endm 
# End of macro CWHEAD
51c2			; | FILEID (  -- u1  )  Pushes currently open file ID to stack | DONE 
51c2 3a f4 fb				ld a, (store_filecache) 
51c5 26 00				ld h, 0 
51c7 6f					ld l, a 
51c8 cd 3a 1f				call forth_push_numhl 
51cb					NEXTW 
51cb c3 a8 22			jp macro_next 
51ce				endm 
# End of macro NEXTW
51ce			.SCONST2: 
51ce				CWHEAD .SCONST3 89 "FILEEXT" 7 WORD_FLAG_CODE 
51ce 6d				db WORD_SYS_CORE+89             
51cf e6 51			dw .SCONST3            
51d1 08				db 7 + 1 
51d2 .. 00			db "FILEEXT",0              
51da				endm 
# End of macro CWHEAD
51da			; | FILEEXT (  -- u1  )  Pushes the currently read file extent of the file to stack | DONE 
51da 3a f7 fb				ld a, (store_openext) 
51dd 26 00				ld h, 0 
51df 6f					ld l, a 
51e0 cd 3a 1f				call forth_push_numhl 
51e3					NEXTW 
51e3 c3 a8 22			jp macro_next 
51e6				endm 
# End of macro NEXTW
51e6			.SCONST3: 
51e6				CWHEAD .SCONST4 89 "FILEMAX" 7 WORD_FLAG_CODE 
51e6 6d				db WORD_SYS_CORE+89             
51e7 fe 51			dw .SCONST4            
51e9 08				db 7 + 1 
51ea .. 00			db "FILEMAX",0              
51f2				endm 
# End of macro CWHEAD
51f2			; | FILEMAXEXT (  -- u1  )  Pushes the maximum file extent of the currenlty open file to stack | DONE 
51f2 3a f6 fb				ld a, (store_openmaxext) 
51f5 26 00				ld h, 0 
51f7 6f					ld l, a 
51f8 cd 3a 1f				call forth_push_numhl 
51fb					NEXTW 
51fb c3 a8 22			jp macro_next 
51fe				endm 
# End of macro NEXTW
51fe			.SCONST4: 
51fe				CWHEAD .SCONST5 89 "FILEADDR" 8 WORD_FLAG_CODE 
51fe 6d				db WORD_SYS_CORE+89             
51ff 14 52			dw .SCONST5            
5201 09				db 8 + 1 
5202 .. 00			db "FILEADDR",0              
520b				endm 
# End of macro CWHEAD
520b			; | FILEADDR (  -- u1  )  Pushes the address of the block accessed for the currenlty open file to stack | DONE 
520b 2a f8 fb				ld hl, (store_openaddr) 
520e cd 3a 1f				call forth_push_numhl 
5211					NEXTW 
5211 c3 a8 22			jp macro_next 
5214				endm 
# End of macro NEXTW
5214			.SCONST5: 
5214				CWHEAD .ENDSTORAGE 89 "READCONT" 8 WORD_FLAG_CODE 
5214 6d				db WORD_SYS_CORE+89             
5215 2d 52			dw .ENDSTORAGE            
5217 09				db 8 + 1 
5218 .. 00			db "READCONT",0              
5221				endm 
# End of macro CWHEAD
5221			; | READCONT (  -- u1  )  Pushes the READ continuation flag to stack | DONE 
5221			; | | If the most recent READ results in a full buffer load then this flag is set and will indicate that 
5221			; | | a further read should, if applicable, be CONCAT to the previous read. 
5221 3a fa fb				ld a, (store_readcont) 
5224 26 00				ld h, 0 
5226 6f					ld l, a 
5227 cd 3a 1f				call forth_push_numhl 
522a					NEXTW 
522a c3 a8 22			jp macro_next 
522d				endm 
# End of macro NEXTW
522d			.ENDSTORAGE: 
522d			; eof 
# End of file forth_words_storage.asm
522d			endif 
522d				include "forth_words_device.asm" 
522d			; Device related words 
522d			 
522d			; | ## Device Words 
522d			 
522d			if SOUND_ENABLE 
522d			.NOTE: 
522d				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
522d			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
522d					if DEBUG_FORTH_WORDS_KEY 
522d						DMARK "NTE" 
522d						CALLMONITOR 
522d					endif 
522d			 
522d				 
522d			 
522d					NEXTW 
522d			.AFTERSOUND: 
522d			endif 
522d			 
522d			 
522d			USE_GPIO: equ 0 
522d			 
522d			if USE_GPIO 
522d			.GP1: 
522d				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
522d			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
522d					NEXTW 
522d			.GP2: 
522d				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
522d			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
522d			 
522d					NEXTW 
522d			 
522d			.GP3: 
522d				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
522d			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
522d			 
522d					NEXTW 
522d			 
522d			.GP4: 
522d				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
522d			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
522d			 
522d					NEXTW 
522d			.SIN: 
522d			 
522d			 
522d			endif 
522d			 
522d			 
522d				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
522d 33				db WORD_SYS_CORE+31             
522e 62 52			dw .SOUT            
5230 03				db 2 + 1 
5231 .. 00			db "IN",0              
5234				endm 
# End of macro CWHEAD
5234			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
5234					if DEBUG_FORTH_WORDS_KEY 
5234						DMARK "IN." 
5234 f5				push af  
5235 3a 49 52			ld a, (.dmark)  
5238 32 b4 fe			ld (debug_mark),a  
523b 3a 4a 52			ld a, (.dmark+1)  
523e 32 b5 fe			ld (debug_mark+1),a  
5241 3a 4b 52			ld a, (.dmark+2)  
5244 32 b6 fe			ld (debug_mark+2),a  
5247 18 03			jr .pastdmark  
5249 ..			.dmark: db "IN."  
524c f1			.pastdmark: pop af  
524d			endm  
# End of macro DMARK
524d						CALLMONITOR 
524d cd c6 18			call break_point_state  
5250				endm  
# End of macro CALLMONITOR
5250					endif 
5250					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5250 cd 31 21			call macro_dsp_valuehl 
5253				endm 
# End of macro FORTH_DSP_VALUEHL
5253			 
5253 e5					push hl 
5254			 
5254					; destroy value TOS 
5254			 
5254					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5254 cd e9 21			call macro_forth_dsp_pop 
5257				endm 
# End of macro FORTH_DSP_POP
5257			 
5257					; one value on hl get other one back 
5257			 
5257 c1					pop bc 
5258			 
5258					; do the sub 
5258			;		ex de, hl 
5258			 
5258 ed 68				in l,(c) 
525a			 
525a					; save it 
525a			 
525a 26 00				ld h,0 
525c			 
525c					; TODO push value back onto stack for another op etc 
525c			 
525c cd 3a 1f				call forth_push_numhl 
525f					NEXTW 
525f c3 a8 22			jp macro_next 
5262				endm 
# End of macro NEXTW
5262			.SOUT: 
5262				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
5262 34				db WORD_SYS_CORE+32             
5263 b5 52			dw .SPIO            
5265 04				db 3 + 1 
5266 .. 00			db "OUT",0              
526a				endm 
# End of macro CWHEAD
526a			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
526a					if DEBUG_FORTH_WORDS_KEY 
526a						DMARK "OUT" 
526a f5				push af  
526b 3a 7f 52			ld a, (.dmark)  
526e 32 b4 fe			ld (debug_mark),a  
5271 3a 80 52			ld a, (.dmark+1)  
5274 32 b5 fe			ld (debug_mark+1),a  
5277 3a 81 52			ld a, (.dmark+2)  
527a 32 b6 fe			ld (debug_mark+2),a  
527d 18 03			jr .pastdmark  
527f ..			.dmark: db "OUT"  
5282 f1			.pastdmark: pop af  
5283			endm  
# End of macro DMARK
5283						CALLMONITOR 
5283 cd c6 18			call break_point_state  
5286				endm  
# End of macro CALLMONITOR
5286					endif 
5286			 
5286					; get port 
5286			 
5286					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5286 cd 31 21			call macro_dsp_valuehl 
5289				endm 
# End of macro FORTH_DSP_VALUEHL
5289			 
5289 e5					push hl 
528a			 
528a					; destroy value TOS 
528a			 
528a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
528a cd e9 21			call macro_forth_dsp_pop 
528d				endm 
# End of macro FORTH_DSP_POP
528d			 
528d					; get byte to send 
528d			 
528d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
528d cd 31 21			call macro_dsp_valuehl 
5290				endm 
# End of macro FORTH_DSP_VALUEHL
5290			 
5290			;		push hl 
5290			 
5290					; destroy value TOS 
5290			 
5290					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5290 cd e9 21			call macro_forth_dsp_pop 
5293				endm 
# End of macro FORTH_DSP_POP
5293			 
5293					; one value on hl get other one back 
5293			 
5293			;		pop hl 
5293			 
5293 c1					pop bc 
5294			 
5294					if DEBUG_FORTH_WORDS 
5294						DMARK "OUT" 
5294 f5				push af  
5295 3a a9 52			ld a, (.dmark)  
5298 32 b4 fe			ld (debug_mark),a  
529b 3a aa 52			ld a, (.dmark+1)  
529e 32 b5 fe			ld (debug_mark+1),a  
52a1 3a ab 52			ld a, (.dmark+2)  
52a4 32 b6 fe			ld (debug_mark+2),a  
52a7 18 03			jr .pastdmark  
52a9 ..			.dmark: db "OUT"  
52ac f1			.pastdmark: pop af  
52ad			endm  
# End of macro DMARK
52ad						CALLMONITOR 
52ad cd c6 18			call break_point_state  
52b0				endm  
# End of macro CALLMONITOR
52b0					endif 
52b0			 
52b0 ed 69				out (c), l 
52b2			 
52b2					NEXTW 
52b2 c3 a8 22			jp macro_next 
52b5				endm 
# End of macro NEXTW
52b5			 
52b5			 
52b5			.SPIO: 
52b5			 
52b5			if STORAGE_SE 
52b5				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
52b5 51				db WORD_SYS_CORE+61             
52b6 c6 52			dw .SPICEH            
52b8 07				db 6 + 1 
52b9 .. 00			db "SPICEL",0              
52c0				endm 
# End of macro CWHEAD
52c0			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
52c0			 
52c0 cd c7 01				call spi_ce_low 
52c3			    NEXTW 
52c3 c3 a8 22			jp macro_next 
52c6				endm 
# End of macro NEXTW
52c6			 
52c6			.SPICEH: 
52c6				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
52c6 51				db WORD_SYS_CORE+61             
52c7 d7 52			dw .SPIOb            
52c9 07				db 6 + 1 
52ca .. 00			db "SPICEH",0              
52d1				endm 
# End of macro CWHEAD
52d1			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
52d1			 
52d1 cd b6 01				call spi_ce_high 
52d4			    NEXTW 
52d4 c3 a8 22			jp macro_next 
52d7				endm 
# End of macro NEXTW
52d7			 
52d7			 
52d7			.SPIOb: 
52d7			 
52d7				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
52d7 51				db WORD_SYS_CORE+61             
52d8 09 53			dw .SPII            
52da 05				db 4 + 1 
52db .. 00			db "SPIO",0              
52e0				endm 
# End of macro CWHEAD
52e0			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
52e0			 
52e0					if DEBUG_FORTH_WORDS_KEY 
52e0						DMARK "SPo" 
52e0 f5				push af  
52e1 3a f5 52			ld a, (.dmark)  
52e4 32 b4 fe			ld (debug_mark),a  
52e7 3a f6 52			ld a, (.dmark+1)  
52ea 32 b5 fe			ld (debug_mark+1),a  
52ed 3a f7 52			ld a, (.dmark+2)  
52f0 32 b6 fe			ld (debug_mark+2),a  
52f3 18 03			jr .pastdmark  
52f5 ..			.dmark: db "SPo"  
52f8 f1			.pastdmark: pop af  
52f9			endm  
# End of macro DMARK
52f9						CALLMONITOR 
52f9 cd c6 18			call break_point_state  
52fc				endm  
# End of macro CALLMONITOR
52fc					endif 
52fc					; get port 
52fc			 
52fc			 
52fc					; get byte to send 
52fc			 
52fc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
52fc cd 31 21			call macro_dsp_valuehl 
52ff				endm 
# End of macro FORTH_DSP_VALUEHL
52ff			 
52ff			;		push hl    ; u1  
52ff			 
52ff					; destroy value TOS 
52ff			 
52ff					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
52ff cd e9 21			call macro_forth_dsp_pop 
5302				endm 
# End of macro FORTH_DSP_POP
5302			 
5302					; one value on hl get other one back 
5302			 
5302			;		pop hl   ; u2 - addr 
5302			 
5302					; TODO Send SPI byte 
5302			 
5302			;		push hl 
5302			;		call spi_ce_low 
5302			;		pop hl 
5302 7d					ld a, l 
5303 cd b5 00				call spi_send_byte 
5306			;		call spi_ce_high 
5306			 
5306					NEXTW 
5306 c3 a8 22			jp macro_next 
5309				endm 
# End of macro NEXTW
5309			 
5309			.SPII: 
5309				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
5309 52				db WORD_SYS_CORE+62             
530a 72 53			dw .SESEL            
530c 06				db 5 + 1 
530d .. 00			db "SPII",0              
5312				endm 
# End of macro CWHEAD
5312			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
5312					if DEBUG_FORTH_WORDS_KEY 
5312						DMARK "SPi" 
5312 f5				push af  
5313 3a 27 53			ld a, (.dmark)  
5316 32 b4 fe			ld (debug_mark),a  
5319 3a 28 53			ld a, (.dmark+1)  
531c 32 b5 fe			ld (debug_mark+1),a  
531f 3a 29 53			ld a, (.dmark+2)  
5322 32 b6 fe			ld (debug_mark+2),a  
5325 18 03			jr .pastdmark  
5327 ..			.dmark: db "SPi"  
532a f1			.pastdmark: pop af  
532b			endm  
# End of macro DMARK
532b						CALLMONITOR 
532b cd c6 18			call break_point_state  
532e				endm  
# End of macro CALLMONITOR
532e					endif 
532e			 
532e					; TODO Get SPI byte 
532e			 
532e cd dc 00				call spi_read_byte 
5331			 
5331					if DEBUG_FORTH_WORDS 
5331						DMARK "Si2" 
5331 f5				push af  
5332 3a 46 53			ld a, (.dmark)  
5335 32 b4 fe			ld (debug_mark),a  
5338 3a 47 53			ld a, (.dmark+1)  
533b 32 b5 fe			ld (debug_mark+1),a  
533e 3a 48 53			ld a, (.dmark+2)  
5341 32 b6 fe			ld (debug_mark+2),a  
5344 18 03			jr .pastdmark  
5346 ..			.dmark: db "Si2"  
5349 f1			.pastdmark: pop af  
534a			endm  
# End of macro DMARK
534a						CALLMONITOR 
534a cd c6 18			call break_point_state  
534d				endm  
# End of macro CALLMONITOR
534d					endif 
534d 26 00				ld h, 0 
534f 6f					ld l, a 
5350					if DEBUG_FORTH_WORDS 
5350						DMARK "Si3" 
5350 f5				push af  
5351 3a 65 53			ld a, (.dmark)  
5354 32 b4 fe			ld (debug_mark),a  
5357 3a 66 53			ld a, (.dmark+1)  
535a 32 b5 fe			ld (debug_mark+1),a  
535d 3a 67 53			ld a, (.dmark+2)  
5360 32 b6 fe			ld (debug_mark+2),a  
5363 18 03			jr .pastdmark  
5365 ..			.dmark: db "Si3"  
5368 f1			.pastdmark: pop af  
5369			endm  
# End of macro DMARK
5369						CALLMONITOR 
5369 cd c6 18			call break_point_state  
536c				endm  
# End of macro CALLMONITOR
536c					endif 
536c cd 3a 1f				call forth_push_numhl 
536f			 
536f					NEXTW 
536f c3 a8 22			jp macro_next 
5372				endm 
# End of macro NEXTW
5372			 
5372			 
5372			 
5372			.SESEL: 
5372				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
5372 66				db WORD_SYS_CORE+82             
5373 1b 54			dw .CARTDEV            
5375 05				db 4 + 1 
5376 .. 00			db "BANK",0              
537b				endm 
# End of macro CWHEAD
537b			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
537b					if DEBUG_FORTH_WORDS_KEY 
537b						DMARK "BNK" 
537b f5				push af  
537c 3a 90 53			ld a, (.dmark)  
537f 32 b4 fe			ld (debug_mark),a  
5382 3a 91 53			ld a, (.dmark+1)  
5385 32 b5 fe			ld (debug_mark+1),a  
5388 3a 92 53			ld a, (.dmark+2)  
538b 32 b6 fe			ld (debug_mark+2),a  
538e 18 03			jr .pastdmark  
5390 ..			.dmark: db "BNK"  
5393 f1			.pastdmark: pop af  
5394			endm  
# End of macro DMARK
5394						CALLMONITOR 
5394 cd c6 18			call break_point_state  
5397				endm  
# End of macro CALLMONITOR
5397					endif 
5397			 
5397 3e ff				ld a, 255 
5399 32 f0 fb				ld (spi_cartdev), a 
539c			 
539c					; get bank 
539c			 
539c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
539c cd 31 21			call macro_dsp_valuehl 
539f				endm 
# End of macro FORTH_DSP_VALUEHL
539f			 
539f			;		push hl 
539f			 
539f					; destroy value TOS 
539f			 
539f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
539f cd e9 21			call macro_forth_dsp_pop 
53a2				endm 
# End of macro FORTH_DSP_POP
53a2			 
53a2					; one value on hl get other one back 
53a2			 
53a2			;		pop hl 
53a2			 
53a2			 
53a2 0e ff				ld c, SPI_CE_HIGH 
53a4 06 30				ld b, '0'    ; human readable bank number 
53a6			 
53a6 7d					ld a, l 
53a7			 
53a7					if DEBUG_FORTH_WORDS 
53a7						DMARK "BNK" 
53a7 f5				push af  
53a8 3a bc 53			ld a, (.dmark)  
53ab 32 b4 fe			ld (debug_mark),a  
53ae 3a bd 53			ld a, (.dmark+1)  
53b1 32 b5 fe			ld (debug_mark+1),a  
53b4 3a be 53			ld a, (.dmark+2)  
53b7 32 b6 fe			ld (debug_mark+2),a  
53ba 18 03			jr .pastdmark  
53bc ..			.dmark: db "BNK"  
53bf f1			.pastdmark: pop af  
53c0			endm  
# End of macro DMARK
53c0						CALLMONITOR 
53c0 cd c6 18			call break_point_state  
53c3				endm  
# End of macro CALLMONITOR
53c3					endif 
53c3			 
53c3					; active low 
53c3			 
53c3 fe 00				cp 0 
53c5 28 28				jr z, .bset 
53c7 fe 01				cp 1 
53c9 20 04				jr nz, .b2 
53cb cb 81				res 0, c 
53cd 06 31				ld b, '1'    ; human readable bank number 
53cf fe 02		.b2:		cp 2 
53d1 20 04				jr nz, .b3 
53d3 cb 89				res 1, c 
53d5 06 32				ld b, '2'    ; human readable bank number 
53d7 fe 03		.b3:		cp 3 
53d9 20 04				jr nz, .b4 
53db cb 91				res 2, c 
53dd 06 33				ld b, '3'    ; human readable bank number 
53df fe 04		.b4:		cp 4 
53e1 20 04				jr nz, .b5 
53e3 cb 99				res 3, c 
53e5 06 34				ld b, '4'    ; human readable bank number 
53e7 fe 05		.b5:		cp 5 
53e9 20 04				jr nz, .bset 
53eb cb a1				res 4, c 
53ed 06 35				ld b, '5'    ; human readable bank number 
53ef			 
53ef			.bset: 
53ef 79					ld a, c 
53f0 32 ed fb				ld (spi_device),a 
53f3 78					ld a, b 
53f4 32 ec fb				ld (spi_device_id),a 
53f7					if DEBUG_FORTH_WORDS 
53f7						DMARK "BN2" 
53f7 f5				push af  
53f8 3a 0c 54			ld a, (.dmark)  
53fb 32 b4 fe			ld (debug_mark),a  
53fe 3a 0d 54			ld a, (.dmark+1)  
5401 32 b5 fe			ld (debug_mark+1),a  
5404 3a 0e 54			ld a, (.dmark+2)  
5407 32 b6 fe			ld (debug_mark+2),a  
540a 18 03			jr .pastdmark  
540c ..			.dmark: db "BN2"  
540f f1			.pastdmark: pop af  
5410			endm  
# End of macro DMARK
5410						CALLMONITOR 
5410 cd c6 18			call break_point_state  
5413				endm  
# End of macro CALLMONITOR
5413					endif 
5413			 
5413					; set default SPI clk pulse time as disabled for BANK use 
5413			 
5413 3e 00				ld a, 0 
5415 32 f1 fb				ld (spi_clktime), a 
5418			 
5418					NEXTW 
5418 c3 a8 22			jp macro_next 
541b				endm 
# End of macro NEXTW
541b			 
541b			.CARTDEV: 
541b				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
541b 66				db WORD_SYS_CORE+82             
541c c9 54			dw .ENDDEVICE            
541e 08				db 7 + 1 
541f .. 00			db "CARTDEV",0              
5427				endm 
# End of macro CWHEAD
5427			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
5427					if DEBUG_FORTH_WORDS_KEY 
5427						DMARK "CDV" 
5427 f5				push af  
5428 3a 3c 54			ld a, (.dmark)  
542b 32 b4 fe			ld (debug_mark),a  
542e 3a 3d 54			ld a, (.dmark+1)  
5431 32 b5 fe			ld (debug_mark+1),a  
5434 3a 3e 54			ld a, (.dmark+2)  
5437 32 b6 fe			ld (debug_mark+2),a  
543a 18 03			jr .pastdmark  
543c ..			.dmark: db "CDV"  
543f f1			.pastdmark: pop af  
5440			endm  
# End of macro DMARK
5440						CALLMONITOR 
5440 cd c6 18			call break_point_state  
5443				endm  
# End of macro CALLMONITOR
5443					endif 
5443			 
5443					; disable se storage bank selection 
5443			 
5443 3e ff				ld a, SPI_CE_HIGH		; ce high 
5445 32 ed fb				ld (spi_device), a 
5448			 
5448					; get bank 
5448			 
5448					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5448 cd 31 21			call macro_dsp_valuehl 
544b				endm 
# End of macro FORTH_DSP_VALUEHL
544b			 
544b			;		push hl 
544b			 
544b					; destroy value TOS 
544b			 
544b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
544b cd e9 21			call macro_forth_dsp_pop 
544e				endm 
# End of macro FORTH_DSP_POP
544e			 
544e					; one value on hl get other one back 
544e			 
544e			;		pop hl 
544e			 
544e					; active low 
544e			 
544e 0e ff				ld c, 255 
5450			 
5450 7d					ld a, l 
5451					if DEBUG_FORTH_WORDS 
5451						DMARK "CDV" 
5451 f5				push af  
5452 3a 66 54			ld a, (.dmark)  
5455 32 b4 fe			ld (debug_mark),a  
5458 3a 67 54			ld a, (.dmark+1)  
545b 32 b5 fe			ld (debug_mark+1),a  
545e 3a 68 54			ld a, (.dmark+2)  
5461 32 b6 fe			ld (debug_mark+2),a  
5464 18 03			jr .pastdmark  
5466 ..			.dmark: db "CDV"  
5469 f1			.pastdmark: pop af  
546a			endm  
# End of macro DMARK
546a						CALLMONITOR 
546a cd c6 18			call break_point_state  
546d				endm  
# End of macro CALLMONITOR
546d					endif 
546d fe 00				cp 0 
546f 28 30				jr z, .cset 
5471 fe 01				cp 1 
5473 20 02				jr nz, .c2 
5475 cb 81				res 0, c 
5477 fe 02		.c2:		cp 2 
5479 20 02				jr nz, .c3 
547b cb 89				res 1, c 
547d fe 03		.c3:		cp 3 
547f 20 02				jr nz, .c4 
5481 cb 91				res 2, c 
5483 fe 04		.c4:		cp 4 
5485 20 02				jr nz, .c5 
5487 cb 99				res 3, c 
5489 fe 05		.c5:		cp 5 
548b 20 02				jr nz, .c6 
548d cb a1				res 4, c 
548f fe 06		.c6:		cp 6 
5491 20 02				jr nz, .c7 
5493 cb a9				res 5, c 
5495 fe 07		.c7:		cp 7 
5497 20 02				jr nz, .c8 
5499 cb b1				res 6, c 
549b fe 08		.c8:		cp 8 
549d 20 02				jr nz, .cset 
549f cb b9				res 7, c 
54a1 79			.cset:		ld a, c 
54a2 32 f0 fb				ld (spi_cartdev),a 
54a5			 
54a5					if DEBUG_FORTH_WORDS 
54a5						DMARK "CD2" 
54a5 f5				push af  
54a6 3a ba 54			ld a, (.dmark)  
54a9 32 b4 fe			ld (debug_mark),a  
54ac 3a bb 54			ld a, (.dmark+1)  
54af 32 b5 fe			ld (debug_mark+1),a  
54b2 3a bc 54			ld a, (.dmark+2)  
54b5 32 b6 fe			ld (debug_mark+2),a  
54b8 18 03			jr .pastdmark  
54ba ..			.dmark: db "CD2"  
54bd f1			.pastdmark: pop af  
54be			endm  
# End of macro DMARK
54be						CALLMONITOR 
54be cd c6 18			call break_point_state  
54c1				endm  
# End of macro CALLMONITOR
54c1					endif 
54c1			 
54c1					; set default SPI clk pulse time as 10ms for CARTDEV use 
54c1			 
54c1 3e 0a				ld a, $0a 
54c3 32 f1 fb				ld (spi_clktime), a 
54c6					NEXTW 
54c6 c3 a8 22			jp macro_next 
54c9				endm 
# End of macro NEXTW
54c9			endif 
54c9			 
54c9			.ENDDEVICE: 
54c9			; eof 
54c9			 
# End of file forth_words_device.asm
54c9			 
54c9			; var handler 
54c9			 
54c9			 
54c9			.VARS: 
54c9				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
54c9 78				db WORD_SYS_CORE+100             
54ca e1 54			dw .V0Q            
54cc 04				db 3 + 1 
54cd .. 00			db "V0!",0              
54d1				endm 
# End of macro CWHEAD
54d1			;| V0! ( u1 -- )  Store value to v0  | DONE 
54d1			 
54d1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
54d1 cd 31 21			call macro_dsp_valuehl 
54d4				endm 
# End of macro FORTH_DSP_VALUEHL
54d4			 
54d4 11 b5 fb				ld de, cli_var_array 
54d7			 
54d7 eb					ex de, hl 
54d8 73					ld (hl), e 
54d9 23					inc hl 
54da 72					ld (hl), d 
54db			 
54db					; destroy value TOS 
54db			 
54db					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
54db cd e9 21			call macro_forth_dsp_pop 
54de				endm 
# End of macro FORTH_DSP_POP
54de			 
54de				       NEXTW 
54de c3 a8 22			jp macro_next 
54e1				endm 
# End of macro NEXTW
54e1			.V0Q: 
54e1				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
54e1 79				db WORD_SYS_CORE+101             
54e2 f2 54			dw .V1S            
54e4 04				db 3 + 1 
54e5 .. 00			db "V0@",0              
54e9				endm 
# End of macro CWHEAD
54e9			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
54e9 2a b5 fb				ld hl, (cli_var_array) 
54ec cd 3a 1f				call forth_push_numhl 
54ef			 
54ef				       NEXTW 
54ef c3 a8 22			jp macro_next 
54f2				endm 
# End of macro NEXTW
54f2			.V1S: 
54f2				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
54f2 7a				db WORD_SYS_CORE+102             
54f3 0a 55			dw .V1Q            
54f5 04				db 3 + 1 
54f6 .. 00			db "V1!",0              
54fa				endm 
# End of macro CWHEAD
54fa			;| V1! ( u1 -- )  Store value to v1 | DONE 
54fa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
54fa cd 31 21			call macro_dsp_valuehl 
54fd				endm 
# End of macro FORTH_DSP_VALUEHL
54fd			 
54fd 11 b7 fb				ld de, cli_var_array+2 
5500				 
5500 eb					ex de, hl 
5501 73					ld (hl), e 
5502 23					inc hl 
5503 72					ld (hl), d 
5504			 
5504					; destroy value TOS 
5504			 
5504					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5504 cd e9 21			call macro_forth_dsp_pop 
5507				endm 
# End of macro FORTH_DSP_POP
5507				       NEXTW 
5507 c3 a8 22			jp macro_next 
550a				endm 
# End of macro NEXTW
550a			.V1Q: 
550a				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
550a 7b				db WORD_SYS_CORE+103             
550b 1b 55			dw .V2S            
550d 04				db 3 + 1 
550e .. 00			db "V1@",0              
5512				endm 
# End of macro CWHEAD
5512			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
5512 2a b7 fb				ld hl, (cli_var_array+2) 
5515 cd 3a 1f				call forth_push_numhl 
5518				       NEXTW 
5518 c3 a8 22			jp macro_next 
551b				endm 
# End of macro NEXTW
551b			.V2S: 
551b				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
551b 7c				db WORD_SYS_CORE+104             
551c 33 55			dw .V2Q            
551e 04				db 3 + 1 
551f .. 00			db "V2!",0              
5523				endm 
# End of macro CWHEAD
5523			;| V2! ( u1 -- )  Store value to v2 | DONE 
5523					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5523 cd 31 21			call macro_dsp_valuehl 
5526				endm 
# End of macro FORTH_DSP_VALUEHL
5526			 
5526 11 b9 fb				ld de, cli_var_array+4 
5529				 
5529 eb					ex de, hl 
552a 73					ld (hl), e 
552b 23					inc hl 
552c 72					ld (hl), d 
552d			 
552d					; destroy value TOS 
552d			 
552d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
552d cd e9 21			call macro_forth_dsp_pop 
5530				endm 
# End of macro FORTH_DSP_POP
5530				       NEXTW 
5530 c3 a8 22			jp macro_next 
5533				endm 
# End of macro NEXTW
5533			.V2Q: 
5533				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
5533 7d				db WORD_SYS_CORE+105             
5534 44 55			dw .V3S            
5536 04				db 3 + 1 
5537 .. 00			db "V2@",0              
553b				endm 
# End of macro CWHEAD
553b			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
553b 2a b9 fb				ld hl, (cli_var_array+4) 
553e cd 3a 1f				call forth_push_numhl 
5541				       NEXTW 
5541 c3 a8 22			jp macro_next 
5544				endm 
# End of macro NEXTW
5544			.V3S: 
5544				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
5544 7c				db WORD_SYS_CORE+104             
5545 5c 55			dw .V3Q            
5547 04				db 3 + 1 
5548 .. 00			db "V3!",0              
554c				endm 
# End of macro CWHEAD
554c			;| V3! ( u1 -- )  Store value to v3 | DONE 
554c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
554c cd 31 21			call macro_dsp_valuehl 
554f				endm 
# End of macro FORTH_DSP_VALUEHL
554f			 
554f 11 bb fb				ld de, cli_var_array+6 
5552				 
5552 eb					ex de, hl 
5553 73					ld (hl), e 
5554 23					inc hl 
5555 72					ld (hl), d 
5556			 
5556					; destroy value TOS 
5556			 
5556					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5556 cd e9 21			call macro_forth_dsp_pop 
5559				endm 
# End of macro FORTH_DSP_POP
5559				       NEXTW 
5559 c3 a8 22			jp macro_next 
555c				endm 
# End of macro NEXTW
555c			.V3Q: 
555c				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
555c 7d				db WORD_SYS_CORE+105             
555d 6d 55			dw .END            
555f 04				db 3 + 1 
5560 .. 00			db "V3@",0              
5564				endm 
# End of macro CWHEAD
5564			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
5564 2a bb fb				ld hl, (cli_var_array+6) 
5567 cd 3a 1f				call forth_push_numhl 
556a				       NEXTW 
556a c3 a8 22			jp macro_next 
556d				endm 
# End of macro NEXTW
556d			 
556d			 
556d			 
556d			 
556d			 
556d			; end of dict marker 
556d			 
556d 00			.END:    db WORD_SYS_END 
556e 00 00			dw 0 
5570 00				db 0 
5571			 
5571			; use to jp here for user dict words to save on macro expansion  
5571			 
5571			user_dict_next: 
5571				NEXTW 
5571 c3 a8 22			jp macro_next 
5574				endm 
# End of macro NEXTW
5574			 
5574			 
5574			user_exec: 
5574				;    ld hl, <word code> 
5574				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
5574				;    call forthexec 
5574				;    jp user_dict_next   (NEXT) 
5574			        ;    <word code bytes> 
5574 eb				ex de, hl 
5575 2a 83 f6			ld hl,(os_tok_ptr) 
5578				 
5578				FORTH_RSP_NEXT 
5578 cd e1 1e			call macro_forth_rsp_next 
557b				endm 
# End of macro FORTH_RSP_NEXT
557b			 
557b			if DEBUG_FORTH_UWORD 
557b						DMARK "UEX" 
557b f5				push af  
557c 3a 90 55			ld a, (.dmark)  
557f 32 b4 fe			ld (debug_mark),a  
5582 3a 91 55			ld a, (.dmark+1)  
5585 32 b5 fe			ld (debug_mark+1),a  
5588 3a 92 55			ld a, (.dmark+2)  
558b 32 b6 fe			ld (debug_mark+2),a  
558e 18 03			jr .pastdmark  
5590 ..			.dmark: db "UEX"  
5593 f1			.pastdmark: pop af  
5594			endm  
# End of macro DMARK
5594				CALLMONITOR 
5594 cd c6 18			call break_point_state  
5597				endm  
# End of macro CALLMONITOR
5597			endif 
5597			 
5597			 
5597			 
5597 eb				ex de, hl 
5598 22 83 f6			ld (os_tok_ptr), hl 
559b				 
559b				; Don't use next - Skips the first word in uword. 
559b			 
559b c3 39 23			jp exec1 
559e			;	NEXT 
559e			 
559e			 
559e			; eof 
# End of file forth_wordsv4.asm
559e			endif 
559e			;;;;;;;;;;;;;; Debug code 
559e			 
559e			 
559e			;if DEBUG_FORTH_PARSE 
559e .. 00		.nowordfound: db "No match",0 
55a7 .. 00		.compword:	db "Comparing word ",0 
55b7 .. 00		.nextwordat:	db "Next word at",0 
55c4 .. 00		.charmatch:	db "Char match",0 
55cf			;endif 
55cf			if DEBUG_FORTH_JP 
55cf			.foundword:	db "Word match. Exec..",0 
55cf			endif 
55cf			;if DEBUG_FORTH_PUSH 
55cf .. 00		.enddict:	db "Dict end. Push.",0 
55df .. 00		.push_str:	db "Pushing string",0 
55ee .. 00		.push_num:	db "Pushing number",0 
55fd .. 00		.data_sp:	db "SP:",0 
5601 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
5613 .. 00		.wordinde:	db "Word in DE (3/0):",0 
5625 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
5637			;endif 
5637			;if DEBUG_FORTH_MALLOC 
5637 .. 00		.push_malloc:	db "Malloc address",0 
5646			;endif 
5646			 
5646			 
5646			 
5646			; display malloc address and current data stack pointer  
5646			 
5646			malloc_error: 
5646 d5				push de 
5647 f5				push af 
5648 e5				push hl 
5649 cd 15 0d			call clear_display 
564c 11 6e 56			ld de, .mallocerr 
564f 3e 00			ld a,0 
5651			;	ld de,os_word_scratch 
5651 cd 28 0d			call str_at_display 
5654 3e 11			ld a, display_row_1+17 
5656 11 b4 fe			ld de, debug_mark 
5659 cd 28 0d			call str_at_display 
565c cd 38 0d			call update_display 
565f				;call break_point_state 
565f cd 06 6f			call cin_wait 
5662			 
5662 3e 20			ld a, ' ' 
5664 32 73 f3			ld (os_view_disable), a 
5667 e1				pop hl 
5668 f1				pop af 
5669 d1				pop de	 
566a				CALLMONITOR 
566a cd c6 18			call break_point_state  
566d				endm  
# End of macro CALLMONITOR
566d c9				ret 
566e			 
566e .. 00		.mallocerr: 	db "Malloc Error",0 
567b			;if DEBUG_FORTH_PUSH 
567b			display_data_sp: 
567b f5				push af 
567c			 
567c				; see if disabled 
567c			 
567c 3a 73 f3			ld a, (os_view_disable) 
567f fe 2a			cp '*' 
5681 28 67			jr z, .skipdsp 
5683			 
5683 e5				push hl 
5684 e5				push hl 
5685 e5			push hl 
5686 cd 15 0d			call clear_display 
5689 e1			pop hl 
568a 7c				ld a,h 
568b 21 87 f6			ld hl, os_word_scratch 
568e cd 4a 12			call hexout 
5691 e1				pop hl 
5692 7d				ld a,l 
5693 21 89 f6			ld hl, os_word_scratch+2 
5696 cd 4a 12			call hexout 
5699 21 8b f6			ld hl, os_word_scratch+4 
569c 3e 00			ld a,0 
569e 77				ld (hl),a 
569f 11 87 f6			ld de,os_word_scratch 
56a2 3e 14				ld a, display_row_2 
56a4 cd 28 0d				call str_at_display 
56a7 11 01 56			ld de, .wordinhl 
56aa 3e 00			ld a, display_row_1 
56ac			 
56ac cd 28 0d				call str_at_display 
56af 11 b4 fe			ld de, debug_mark 
56b2 3e 11			ld a, display_row_1+17 
56b4			 
56b4 cd 28 0d				call str_at_display 
56b7			 
56b7				; display current data stack pointer 
56b7 11 fd 55			ld de,.data_sp 
56ba 3e 1c				ld a, display_row_2 + 8 
56bc cd 28 0d				call str_at_display 
56bf			 
56bf 2a af fb			ld hl,(cli_data_sp) 
56c2 e5				push hl 
56c3 7c				ld a,h 
56c4 21 87 f6			ld hl, os_word_scratch 
56c7 cd 4a 12			call hexout 
56ca e1				pop hl 
56cb 7d				ld a,l 
56cc 21 89 f6			ld hl, os_word_scratch+2 
56cf cd 4a 12			call hexout 
56d2 21 8b f6			ld hl, os_word_scratch+4 
56d5 3e 00			ld a,0 
56d7 77				ld (hl),a 
56d8 11 87 f6			ld de,os_word_scratch 
56db 3e 1f				ld a, display_row_2 + 11 
56dd cd 28 0d				call str_at_display 
56e0			 
56e0			 
56e0 cd 38 0d			call update_display 
56e3 cd 92 0c			call delay1s 
56e6 cd 92 0c			call delay1s 
56e9 e1				pop hl 
56ea			.skipdsp: 
56ea f1				pop af 
56eb c9				ret 
56ec			 
56ec			display_data_malloc: 
56ec			 
56ec f5				push af 
56ed e5				push hl 
56ee e5				push hl 
56ef e5			push hl 
56f0 cd 15 0d			call clear_display 
56f3 e1			pop hl 
56f4 7c				ld a,h 
56f5 21 87 f6			ld hl, os_word_scratch 
56f8 cd 4a 12			call hexout 
56fb e1				pop hl 
56fc 7d				ld a,l 
56fd 21 89 f6			ld hl, os_word_scratch+2 
5700 cd 4a 12			call hexout 
5703 21 8b f6			ld hl, os_word_scratch+4 
5706 3e 00			ld a,0 
5708 77				ld (hl),a 
5709 11 87 f6			ld de,os_word_scratch 
570c 3e 14				ld a, display_row_2 
570e cd 28 0d				call str_at_display 
5711 11 37 56			ld de, .push_malloc 
5714 3e 00			ld a, display_row_1 
5716			 
5716 cd 28 0d				call str_at_display 
5719			 
5719				; display current data stack pointer 
5719 11 fd 55			ld de,.data_sp 
571c 3e 1c				ld a, display_row_2 + 8 
571e cd 28 0d				call str_at_display 
5721			 
5721 2a af fb			ld hl,(cli_data_sp) 
5724 e5				push hl 
5725 7c				ld a,h 
5726 21 87 f6			ld hl, os_word_scratch 
5729 cd 4a 12			call hexout 
572c e1				pop hl 
572d 7d				ld a,l 
572e 21 89 f6			ld hl, os_word_scratch+2 
5731 cd 4a 12			call hexout 
5734 21 8b f6			ld hl, os_word_scratch+4 
5737 3e 00			ld a,0 
5739 77				ld (hl),a 
573a 11 87 f6			ld de,os_word_scratch 
573d 3e 1f				ld a, display_row_2 + 11 
573f cd 28 0d				call str_at_display 
5742			 
5742 cd 38 0d			call update_display 
5745 cd 92 0c			call delay1s 
5748 cd 92 0c			call delay1s 
574b e1				pop hl 
574c f1				pop af 
574d c9				ret 
574e			;endif 
574e			 
574e			include "forth_autostart.asm" 
574e			; list of commands to perform at system start up 
574e			 
574e			startcmds: 
574e			;	dw test11 
574e			;	dw test12 
574e			;	dw test13 
574e			;	dw test14 
574e			;	dw test15 
574e			;	dw test16 
574e			;	dw test17 
574e			;	dw ifthtest1 
574e			;	dw ifthtest2 
574e			;	dw ifthtest3 
574e			;	dw mmtest1 
574e			;	dw mmtest2 
574e			;	dw mmtest3 
574e			;	dw mmtest4 
574e			;	dw mmtest5 
574e			;	dw mmtest6 
574e			;	dw iftest1 
574e			;	dw iftest2 
574e			;	dw iftest3 
574e			;	dw looptest1 
574e			;	dw looptest2 
574e			;	dw test1 
574e			;	dw test2 
574e			;	dw test3 
574e			;	dw test4 
574e			;	dw game2r 
574e			;	dw game2b1 
574e			;	dw game2b2 
574e			 
574e				; start up words that are actually useful 
574e			 
574e c2 57		    dw spi1 
5750 16 58		    dw spi2 
5752 4c 58		    dw spi3 
5754 88 58		    dw spi4 
5756 b3 58		    dw spi5 
5758 e0 58		    dw spi6 
575a 35 59		    dw spi7 
575c			 
575c 8d 59		    dw spi8 
575e ac 59		    dw spi9 
5760 04 5a		    dw spi10 
5762			 
5762 77 5a			dw longread 
5764 be 5a			dw clrstack 
5766 f1 5a			dw type 
5768 e1 5c			dw stest 
576a 15 5b			dw strncpy 
576c 77 5c			dw list 
576e 76 5b			dw start1 
5770 88 5b			dw start2 
5772			;	dw start3 
5772 9b 5b			dw start3b 
5774 17 5c			dw start3c 
5776			 
5776				; (unit) testing words 
5776			 
5776 58 5d			dw mtesta 
5778 0d 5e			dw mtestb 
577a b0 5e			dw mtestc 
577c 65 5f			dw mtestd 
577e 09 60			dw mteste 
5780			 
5780				; demo/game words 
5780			 
5780 15 67		        dw game3w 
5782 43 67		        dw game3p 
5784 61 67		        dw game3sc 
5786 92 67		        dw game3vsi 
5788 be 67		        dw game3vs 
578a				 
578a 08 65			dw game2b 
578c 76 65			dw game2bf 
578e c0 65			dw game2mba 
5790 56 66			dw game2mbas 
5792 98 66			dw game2mb 
5794			 
5794 c9 61			dw game1 
5796 da 61			dw game1a 
5798 3c 62			dw game1b 
579a 71 62			dw game1c 
579c a7 62			dw game1d 
579e d8 62			dw game1s 
57a0 ec 62			dw game1t 
57a2 01 63			dw game1f 
57a4 35 63			dw game1z 
57a6 79 63			dw game1zz 
57a8			 
57a8 bf 60			dw test5 
57aa f7 60			dw test6 
57ac 2f 61			dw test7 
57ae 43 61			dw test8 
57b0 6f 61			dw test9 
57b2 85 61			dw test10 
57b4				 
57b4 50 64		        dw ssv5 
57b6 34 64		        dw ssv4 
57b8 18 64		        dw ssv3 
57ba e2 63		        dw ssv2 
57bc 69 64		        dw ssv1 
57be b1 64		        dw ssv1cpm 
57c0			;	dw keyup 
57c0			;	dw keydown 
57c0			;	dw keyleft 
57c0			;	dw keyright 
57c0			;	dw 	keyf1 
57c0			;	dw keyf2 
57c0			;	dw keyf3 
57c0			;	dw keyf4 
57c0			;	dw keyf5 
57c0			;	dw keyf6 
57c0			;	dw keyf7 
57c0			;	dw keyf8 
57c0			;	dw keyf9 
57c0			;	dw keyf10 
57c0			;	dw keyf11 
57c0			;	dw keyf12 
57c0			;	dw keytab 
57c0			;	dw keycr 
57c0			;	dw keyhome 
57c0			;	dw keyend 
57c0			;	dw keybs 
57c0 00 00			db 0, 0	 
57c2			 
57c2			; SPI Net support words 
57c2			 
57c2			; v0! = node to send to 
57c2			; ( str count - ) 
57c2 .. 00		spi1:       db ": spitype spicel $00 do dup i + @ v0@ $10 spio spio spio $01 pause loop spiceh ; ; ",0 
5816			 
5816			; spiputchr ( char node - ) 
5816 .. 00		spi2:       db ": spiputchr spicel $10 spio spio ptr @ spio spiceh ; ",0 
584c .. 00		spi3:       db ": storestr spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
5888			 
5888			; spigetchr ( - n ) 
5888 .. 00		spi4:       db ": spigetchr spicel $11 spio spii spiceh ; ", 0 
58b3			 
58b3			; getnode ( - n ) 
58b3 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
58e0			 
58e0			 
58e0			; store string ( str i - ) 
58e0			 
58e0 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
5935			 
5935			; get string ( addr i -  )    TO FIX 
5935			 
5935 .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
598d			 
598d			 
598d			; SPICHAT (TODO) 
598d			; Program to allow two nodes to chat with eachother 
598d			; 
598d			; v0 - target node 
598d			;  
598d			; accept input at 0,0 
598d			; if input is string send spitype to target node 
598d			; starting at row 2,0 , while spigetchr is not zero ->  
598d			; 
598d			; ( node - ) 
598d .. 00		spi8:		db ": spichatp $00 $00 at accept ;", 0 
59ac .. 00		spi9: 		db ": spichatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
5a04 .. 00		spi10:		db ": spichat v0! repeat spichatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . spichatr true until ;", 0 
5a77			 
5a77			 
5a77			; Long read of currently open file 
5a77 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
5abe			 
5abe			; clear stack  
5abe			 
5abe .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
5af1			 
5af1			; type ( addr count - ) 
5af1 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
5b15			 
5b15			; some direct memory words 
5b15			; strncpy ( len t f -- t ) 
5b15			 
5b15 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
5b76			 
5b76 .. 00		start1:     	db ": bpon $0000 bp ;",0 
5b88 .. 00		start2:     	db ": bpoff $0001 bp ;",0 
5b9b .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
5c17 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
5c77			 
5c77			 
5c77			; a handy word to list items on the stack 
5c77			 
5c77 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
5ce1			 
5ce1			 
5ce1			; test stack  
5ce1			; rnd8 stest 
5ce1			 
5ce1 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
5d58			 
5d58			; random malloc and free cycles 
5d58			 
5d58 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5e0d			 
5e0d			; fixed malloc and free cycles 
5e0d			 
5e0d .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5eb0			 
5eb0			; fixed double string push and drop cycle  
5eb0			 
5eb0 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
5f65			 
5f65			; consistent fixed string push and drop cycle  
5f65			 
5f65 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
6009			 
6009 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
60bf			 
60bf			;test1:		db ": aa 1 2 3 ;", 0 
60bf			;test2:     	db "111 aa 888 999",0 
60bf			;test3:     	db ": bb 77 ;",0 
60bf			;test4:     	db "$02 $01 do i . loop bb",0 
60bf			 
60bf .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
60f7 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
612f .. 00		test7:     	db ": box hline vline ;",0 
6143 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
616f .. 00		test9:     	db ": sw $01 adsp world ;",0 
6185 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
61aa .. 00		test11:     	db "hello create .",0 
61b9 .. 00		test12:     	db "hello2 create .",0 
61c9			 
61c9			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
61c9			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
61c9			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
61c9			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
61c9			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
61c9			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
61c9			 
61c9			;iftest1:     	db "$0001 IF cls .",0 
61c9			;iftest2:     	db "$0000 IF cls .",0 
61c9			;iftest3:     	db "$0002 $0003 - IF cls .",0 
61c9			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
61c9			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
61c9			 
61c9			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
61c9			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
61c9			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
61c9			 
61c9			 
61c9			 
61c9			; a small guess the number game 
61c9			 
61c9 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
61da .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
623c			 
623c .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
6271 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
62a7 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
62d8 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
62ec .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
6301 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
6335 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
6379			 
6379			; Using 'ga' save a high score across multiple runs using external storage 
6379			 
6379 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
63e2			 
63e2			 
63e2			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
63e2			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
63e2			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
63e2			 
63e2			; simple screen saver to test code memory reuse to destruction 
63e2			 
63e2 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
6418 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
6434 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
6450 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
6469 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
64b1 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
6508			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
6508			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
6508			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
6508			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
6508			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
6508			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
6508			 
6508			 
6508			 
6508			; minesweeper/battleship finding game 
6508			; draws a game board of random ship/mine positions 
6508			; user enters coords to see if it hits on 
6508			; game ends when all are hit 
6508			; when hit or miss says how many may be in the area 
6508			 
6508			; setup the game board and then hide it 
6508 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
6576 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
65c0			; prompt for where to target 
65c0 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
6656 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
667b			; TODO see if the entered coords hits or misses pushes char hit of miss 
667b .. 00		game2mbht:      db ": mbckht nop ;",0 
668a .. 00		game2mbms:      db ": mbcms nop ;",0 
6698			; TODO how many might be near by 
6698 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
6715			 
6715			; Game 3 
6715			 
6715			; Vert scroller ski game - avoid the trees! 
6715			 
6715			; v0 score (ie turns) 
6715			; v1 player pos 
6715			; v2 left wall 
6715			; v3 right wall 
6715			 
6715			; Draw side walls randomly 
6715			 
6715 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
6743			 
6743			; Draw player 
6743 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
6761			 
6761			; TODO Get Key 
6761			 
6761			; TODO Move left right 
6761			 
6761			; scroll and move walls a bit 
6761			 
6761 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
6792			 
6792			; main game loop 
6792			 
6792 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
67be .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
67fd			 
67fd			; key board defs 
67fd			 
67fd .. 00		keyup:       db ": keyup $05 ;",0 
680b .. 00		keydown:       db ": keydown $0a ;",0 
681b .. 00		keyleft:       db ": keyleft $0b ;",0 
682b .. 00		keyright:       db ": keyright $0c ;",0 
683c .. 00		keyf1:       db ": keyf1 $10 ;",0 
684a .. 00		keyf2:       db ": keyf2 $11 ;",0 
6858 .. 00		keyf3:       db ": keyf3 $12 ;",0 
6866 .. 00		keyf4:       db ": keyf4 $13 ;",0 
6874 .. 00		keyf5:       db ": keyf5 $14 ;",0 
6882 .. 00		keyf6:       db ": keyf6 $15 ;",0 
6890 .. 00		keyf7:       db ": keyf7 $16 ;",0 
689e .. 00		keyf8:       db ": keyf8 $17 ;",0 
68ac .. 00		keyf9:       db ": keyf9 $18 ;",0 
68ba .. 00		keyf10:       db ": keyf10 $19 ;",0 
68c9 .. 00		keyf11:       db ": keyf11 $1a ;",0 
68d8 .. 00		keyf12:       db ": keyf12 $1b ;",0 
68e7			 
68e7 .. 00		keytab:       db ": keytab $09 ;",0 
68f6 .. 00		keycr:       db ": keycr $0d ;",0 
6904 .. 00		keyhome:       db ": keyhome $0e ;",0 
6914 .. 00		keyend:       db ": keyend $0f ;",0 
6923 .. 00		keybs:       db ": keybs $08 ;",0 
6931			 
6931			   
6931			 
6931			 
6931			 
6931			; eof 
# End of file forth_autostart.asm
6931			 
6931 .. 00		sprompt1: db "Startup load...",0 
6941 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
6957			 
6957			 
6957			 
6957			 
6957			forth_startup: 
6957 21 4e 57			ld hl, startcmds 
695a 3e 00			ld a, 0 
695c 32 a8 f7			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
695f			 
695f e5			.start1:	push hl 
6960 cd 15 0d			call clear_display 
6963 11 31 69			ld de, sprompt1 
6966 3e 00		        ld a, display_row_1 
6968 cd 28 0d			call str_at_display 
696b 11 41 69			ld de, sprompt2 
696e 3e 14		        ld a, display_row_2 
6970 cd 28 0d			call str_at_display 
6973 e1				pop hl 
6974 e5				push hl 
6975 5e				ld e,(hl) 
6976 23				inc hl 
6977 56				ld d,(hl) 
6978 3e 28		        ld a, display_row_3 
697a cd 28 0d			call str_at_display 
697d cd 38 0d			call update_display 
6980			 
6980			 
6980 3a a8 f7			ld a, (os_last_cmd) 
6983 fe 00			cp 0 
6985 28 05			jr z, .startprompt 
6987 cd 86 0c			call delay250ms 
698a 18 24			jr .startdo 
698c				 
698c				 
698c			 
698c			.startprompt: 
698c			 
698c 3e 4f			ld a,display_row_4 + display_cols - 1 
698e 11 b0 1e		        ld de, endprg 
6991 cd 28 0d			call str_at_display 
6994 cd 38 0d			call update_display 
6997 cd 92 0c			call delay1s 
699a cd 06 6f			call cin_wait 
699d						 
699d fe 2a			cp '*' 
699f 28 5e			jr z, .startupend1 
69a1 fe 23			cp '#' 
69a3 20 07			jr nz, .startno 
69a5 3e 01			ld a, 1 
69a7 32 a8 f7			ld (os_last_cmd),a 
69aa 18 04			jr .startdo 
69ac fe 31		.startno:	cp '1' 
69ae 28 3a			jr z,.startnxt  
69b0			 
69b0				; exec startup line 
69b0			.startdo:	 
69b0 e1				pop hl 
69b1 e5				push hl 
69b2				 
69b2 5e				ld e,(hl) 
69b3 23				inc hl 
69b4 56				ld d,(hl) 
69b5 eb				ex de,hl 
69b6			 
69b6 e5				push hl 
69b7			 
69b7 3e 00			ld a, 0 
69b9				;ld a, FORTH_END_BUFFER 
69b9 cd b2 13			call strlent 
69bc 23				inc hl   ; include zero term to copy 
69bd 06 00			ld b,0 
69bf 4d				ld c,l 
69c0 e1				pop hl 
69c1 11 82 f3			ld de, scratch 
69c4 ed b0			ldir 
69c6			 
69c6			 
69c6 21 82 f3			ld hl, scratch 
69c9 cd f6 22			call forthparse 
69cc cd 36 23			call forthexec 
69cf cd 48 22			call forthexec_cleanup 
69d2			 
69d2 3e 3c			ld a, display_row_4 
69d4 11 54 1c			ld de, endprog 
69d7			 
69d7 cd 38 0d			call update_display		 
69da			 
69da 3a a8 f7			ld a, (os_last_cmd) 
69dd fe 00			cp 0 
69df 20 09			jr nz, .startnxt 
69e1 cd b2 1e			call next_page_prompt 
69e4 cd 15 0d		        call clear_display 
69e7 cd 38 0d			call update_display		 
69ea			 
69ea				; move onto next startup line? 
69ea			.startnxt: 
69ea			 
69ea cd 86 0c			call delay250ms 
69ed e1				pop hl 
69ee			 
69ee 23				inc hl 
69ef 23				inc hl 
69f0			 
69f0 e5				push hl 
69f1 5e				ld e, (hl) 
69f2 23				inc hl 
69f3 56				ld d, (hl) 
69f4 e1				pop hl 
69f5				; TODO replace 0 test 
69f5			 
69f5 eb				ex de, hl 
69f6 cd 72 0f			call ishlzero 
69f9			;	ld a,e 
69f9			;	add d 
69f9			;	cp 0    ; any left to do? 
69f9 eb				ex de, hl 
69fa c2 5f 69			jp nz, .start1 
69fd 18 01			jr .startupend 
69ff			 
69ff e1			.startupend1: pop hl 
6a00			.startupend: 
6a00			 
6a00 cd 15 0d			call clear_display 
6a03 cd 38 0d			call update_display 
6a06 c9				ret 
6a07			 
6a07			 
6a07			; stack over and underflow checks 
6a07			 
6a07			; init the words to detect the under/overflow 
6a07			 
6a07			chk_stk_init: 
6a07				; a vague random number to check so we dont get any "lucky" hits 
6a07 3e 2d			ld a, 45 
6a09 6f				ld l, a 
6a0a 00				nop 
6a0b 3e 17			ld a, 23 
6a0d 67				ld h, a 
6a0e			 
6a0e 22 69 f3			ld (chk_word), hl     ; the word we need to check against 
6a11			 
6a11			;	ld (chk_stund), hl	; stack points.... 
6a11 22 fd fe			ld (chk_stovr), hl 
6a14 22 ad fb			ld (chk_ret_und), hl 
6a17 22 6b fb			ld (chk_ret_ovr), hl 
6a1a 22 e9 fa			ld (chk_loop_ovr), hl 
6a1d 22 e7 f8			ld (chk_data_ovr), hl 
6a20 c9				ret 
6a21				 
6a21			check_stacks: 
6a21				; check all stack words 
6a21			 
6a21 e5				push hl 
6a22 d5				push de 
6a23			 
6a23			;	ld de,(chk_word) 
6a23			;	ld hl, (chk_stund)	; stack points.... 
6a23			;	if DEBUG_STK_FAULT 
6a23			;		DMARK "FAa" 
6a23			;		CALLMONITOR 
6a23			;	endif 
6a23			;	call cmp16 
6a23			;	jp z, .chk_faulta 
6a23			; 
6a23			;	ld de, sfaultsu 
6a23			;	jp .chk_fault 
6a23			 
6a23 2a fd fe		.chk_faulta: ld hl, (chk_stovr) 
6a26 ed 5b 69 f3		ld de,(chk_word) 
6a2a				if DEBUG_STK_FAULT 
6a2a					DMARK "FAb" 
6a2a					CALLMONITOR 
6a2a				endif 
6a2a cd 67 0f			call cmp16 
6a2d 28 06			jr z, .chk_fault1 
6a2f 11 d0 6a			ld de, sfaultso 
6a32 c3 84 6a			jp .chk_fault 
6a35			.chk_fault1:  
6a35 2a ad fb			ld hl, (chk_ret_und) 
6a38 ed 5b 69 f3		ld de,(chk_word) 
6a3c				if DEBUG_STK_FAULT 
6a3c					DMARK "FAU" 
6a3c					CALLMONITOR 
6a3c				endif 
6a3c cd 67 0f			call cmp16 
6a3f ca 48 6a			jp z, .chk_fault2 
6a42 11 e0 6a			ld de, sfaultru 
6a45 c3 84 6a			jp .chk_fault 
6a48			.chk_fault2:  
6a48 2a 6b fb			ld hl, (chk_ret_ovr) 
6a4b ed 5b 69 f3		ld de,(chk_word) 
6a4f				if DEBUG_STK_FAULT 
6a4f					DMARK "FA1" 
6a4f					CALLMONITOR 
6a4f				endif 
6a4f cd 67 0f			call cmp16 
6a52 ca 5b 6a			jp z, .chk_fault3 
6a55 11 ee 6a			ld de, sfaultro 
6a58 c3 84 6a			jp .chk_fault 
6a5b			.chk_fault3:  
6a5b 2a e9 fa			ld hl, (chk_loop_ovr) 
6a5e ed 5b 69 f3		ld de,(chk_word) 
6a62				if DEBUG_STK_FAULT 
6a62					DMARK "FA2" 
6a62					CALLMONITOR 
6a62				endif 
6a62 cd 67 0f			call cmp16 
6a65 ca 6e 6a			jp z, .chk_fault4 
6a68 11 08 6b			ld de, sfaultlo 
6a6b c3 84 6a			jp .chk_fault 
6a6e			.chk_fault4:  
6a6e 2a e7 f8			ld hl, (chk_data_ovr) 
6a71 ed 5b 69 f3		ld de,(chk_word) 
6a75				if DEBUG_STK_FAULT 
6a75					DMARK "FA3" 
6a75					CALLMONITOR 
6a75				endif 
6a75 cd 67 0f			call cmp16 
6a78 ca 81 6a			jp z, .chk_fault5 
6a7b 11 22 6b			ld de, sfaultdo 
6a7e c3 84 6a			jp .chk_fault 
6a81			 
6a81			 
6a81			.chk_fault5:  
6a81 d1				pop de 
6a82 e1				pop hl 
6a83			 
6a83 c9				ret 
6a84			 
6a84 cd 15 0d		.chk_fault: 	call clear_display 
6a87 3e 14				ld a, display_row_2 
6a89 cd 28 0d				call str_at_display 
6a8c 11 b2 6a				   ld de, .stackfault 
6a8f 3e 00				ld a, display_row_1 
6a91 cd 28 0d				call str_at_display 
6a94 11 b4 fe				    ld de, debug_mark 
6a97 3e 11				ld a, display_row_1+17 
6a99 cd 28 0d				call str_at_display 
6a9c cd 38 0d				call update_display 
6a9f			 
6a9f				; prompt before entering montior for investigating issue 
6a9f			 
6a9f 3e 3c			ld a, display_row_4 
6aa1 11 54 1c			ld de, endprog 
6aa4			 
6aa4 cd 38 0d			call update_display		 
6aa7			 
6aa7 cd b2 1e			call next_page_prompt 
6aaa			 
6aaa d1				pop de 
6aab e1				pop hl 
6aac cd a8 1c				call monitor 
6aaf c3 9f 1b				jp warmstart 
6ab2					;jp 0 
6ab2					;halt 
6ab2			 
6ab2			 
6ab2			 
6ab2 .. 00		.stackfault: 	db "Stack fault:",0 
6abf			 
6abf .. 00		sfaultsu: 	db	"Stack under flow",0 
6ad0 .. 00		sfaultso: 	db	"Stack over flow",0 
6ae0 .. 00		sfaultru:	db "RTS underflow",0 
6aee .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
6b08 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
6b22 .. 00		sfaultdo:	db "DTS overflow", 0 
6b2f			 
6b2f			 
6b2f			fault_dsp_under: 
6b2f 11 41 6b			ld de, .dsp_under 
6b32 c3 f1 6b			jp .show_fault 
6b35			 
6b35			fault_rsp_under: 
6b35 11 4f 6b			ld de, .rsp_under 
6b38 c3 f1 6b			jp .show_fault 
6b3b			fault_loop_under: 
6b3b 11 5d 6b			ld de, .loop_under 
6b3e c3 f1 6b			jp .show_fault 
6b41			 
6b41 .. 00		.dsp_under: db "DSP Underflow",0 
6b4f .. 00		.rsp_under: db "RSP Underflow",0 
6b5d .. 00		.loop_under: db "LOOP Underflow",0 
6b6c			 
6b6c			 
6b6c d5			type_faultn: 	push de 
6b6d e5					push hl 
6b6e cd 15 0d				call clear_display 
6b71 11 98 6b				   ld de, .typefaultn 
6b74 3e 00				ld a, display_row_1 
6b76 cd 28 0d				call str_at_display 
6b79 11 b4 fe				    ld de, debug_mark 
6b7c 3e 11				ld a, display_row_1+17 
6b7e cd 28 0d				call str_at_display 
6b81 cd 38 0d				call update_display 
6b84			 
6b84				; prompt before entering montior for investigating issue 
6b84			 
6b84 3e 3c			ld a, display_row_4 
6b86 11 54 1c			ld de, endprog 
6b89			 
6b89 cd 38 0d			call update_display		 
6b8c			 
6b8c cd b2 1e			call next_page_prompt 
6b8f			 
6b8f e5					push hl 
6b90 d5					push de 
6b91 cd a8 1c				call monitor 
6b94 c3 9f 1b				jp warmstart 
6b97 76					halt 
6b98			 
6b98			 
6b98 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
6baf			 
6baf d5			type_faults: 	push de 
6bb0 e5					push hl 
6bb1 cd 15 0d				call clear_display 
6bb4 11 da 6b				   ld de, .typefaults 
6bb7 3e 00				ld a, display_row_1 
6bb9 cd 28 0d				call str_at_display 
6bbc 11 b4 fe				    ld de, debug_mark 
6bbf 3e 11				ld a, display_row_1+17 
6bc1 cd 28 0d				call str_at_display 
6bc4 cd 38 0d				call update_display 
6bc7			 
6bc7				; prompt before entering montior for investigating issue 
6bc7			 
6bc7 3e 3c			ld a, display_row_4 
6bc9 11 54 1c			ld de, endprog 
6bcc			 
6bcc cd 38 0d			call update_display		 
6bcf			 
6bcf cd b2 1e			call next_page_prompt 
6bd2			 
6bd2 e1					pop hl 
6bd3 d1					pop de 
6bd4 cd a8 1c				call monitor 
6bd7 c3 9f 1b				jp warmstart 
6bda			 
6bda			 
6bda .. 00		.typefaults: db "STR Type Expected TOS!",0 
6bf1			 
6bf1			.show_fault: 	 
6bf1 d5					push de 
6bf2 cd 15 0d				call clear_display 
6bf5 d1					pop de 
6bf6 3e 00				ld a, display_row_1 
6bf8 cd 28 0d				call str_at_display 
6bfb 11 b4 fe				    ld de, debug_mark 
6bfe 3e 11				ld a, display_row_1+17 
6c00 cd 28 0d				call str_at_display 
6c03 cd 38 0d				call update_display 
6c06			 
6c06				; prompt before entering montior for investigating issue 
6c06			 
6c06 3e 3c			ld a, display_row_4 
6c08 11 54 1c			ld de, endprog 
6c0b			 
6c0b cd 38 0d			call update_display		 
6c0e			 
6c0e cd b2 1e			call next_page_prompt 
6c11			 
6c11 e1					pop hl 
6c12 d1					pop de 
6c13 cd a8 1c				call monitor 
6c16			; do a dump to cli and not warmstart so we preserve all of the uwords.  
6c16			; TODO Make optional fault restart to cli or warm boot? 
6c16					;jp warmstart 
6c16 c3 fa 1b				jp cli 
6c19 76					halt 
6c1a			 
6c1a			; handle the auto run of code from files in storage 
6c1a			 
6c1a			 
6c1a			if STORAGE_SE 
6c1a			 
6c1a .. 00		sprompt3: db "Loading from start-up file?:",0 
6c37 .. 00		sprompt4: db "(Y=Any key/N=No)",0 
6c48			 
6c48			 
6c48			forth_autoload: 
6c48			 
6c48				; load block 0 of store 1 
6c48				 
6c48 3e fe			ld a, $fe      ; bit 0 clear 
6c4a 32 ed fb			ld (spi_device), a 
6c4d			 
6c4d cd ca 04			call storage_get_block_0 
6c50			 
6c50 3a 28 fc			ld a, (store_page+STORE_0_AUTOFILE) 
6c53			 
6c53 fe 00			cp 0 
6c55 c8				ret z     ; auto start not enabled 
6c56			 
6c56 cd 15 0d			call clear_display 
6c59			 
6c59				; set bank 
6c59			 
6c59 3a 2a fc				ld a, (store_page+STORE_0_BANKRUN) 
6c5c 32 ed fb				ld (spi_device), a 
6c5f			 
6c5f				; get file id to load from and get the file name to display 
6c5f			 
6c5f 3a 2b fc				ld a, (store_page+STORE_0_FILERUN) 
6c62			 
6c62 2e 00				ld l, 0 
6c64 67					ld h, a 
6c65 11 07 fc				ld de, store_page 
6c68			 
6c68					if DEBUG_FORTH_WORDS 
6c68						DMARK "ASp" 
6c68 f5				push af  
6c69 3a 7d 6c			ld a, (.dmark)  
6c6c 32 b4 fe			ld (debug_mark),a  
6c6f 3a 7e 6c			ld a, (.dmark+1)  
6c72 32 b5 fe			ld (debug_mark+1),a  
6c75 3a 7f 6c			ld a, (.dmark+2)  
6c78 32 b6 fe			ld (debug_mark+2),a  
6c7b 18 03			jr .pastdmark  
6c7d ..			.dmark: db "ASp"  
6c80 f1			.pastdmark: pop af  
6c81			endm  
# End of macro DMARK
6c81						CALLMONITOR 
6c81 cd c6 18			call break_point_state  
6c84				endm  
# End of macro CALLMONITOR
6c84					endif 
6c84 cd 72 09				call storage_read 
6c87			 
6c87					if DEBUG_FORTH_WORDS 
6c87						DMARK "ASr" 
6c87 f5				push af  
6c88 3a 9c 6c			ld a, (.dmark)  
6c8b 32 b4 fe			ld (debug_mark),a  
6c8e 3a 9d 6c			ld a, (.dmark+1)  
6c91 32 b5 fe			ld (debug_mark+1),a  
6c94 3a 9e 6c			ld a, (.dmark+2)  
6c97 32 b6 fe			ld (debug_mark+2),a  
6c9a 18 03			jr .pastdmark  
6c9c ..			.dmark: db "ASr"  
6c9f f1			.pastdmark: pop af  
6ca0			endm  
# End of macro DMARK
6ca0						CALLMONITOR 
6ca0 cd c6 18			call break_point_state  
6ca3				endm  
# End of macro CALLMONITOR
6ca3					endif 
6ca3			 
6ca3 cd 72 0f				call ishlzero 
6ca6 c8					ret z             ; file not found 
6ca7			 
6ca7 3e 1e				ld a, display_row_2 + 10 
6ca9 11 0a fc				ld de, store_page+3 
6cac cd 28 0d				call str_at_display 
6caf				 
6caf			; 
6caf			 
6caf 3e 05			ld a, display_row_1+5 
6cb1 11 1a 6c			ld de, sprompt3 
6cb4 cd 28 0d			call str_at_display 
6cb7 3e 37			ld a, display_row_3+15 
6cb9 11 37 6c			ld de, sprompt4 
6cbc cd 28 0d			call str_at_display 
6cbf			 
6cbf cd 38 0d			call update_display 
6cc2			 
6cc2 cd 06 6f			call cin_wait 
6cc5 fe 6e			cp 'n' 
6cc7 c8				ret z 
6cc8 fe 4e			cp 'N' 
6cca c8				ret z 
6ccb			 
6ccb cd 92 0c			call delay1s 
6cce			 
6cce 3a 09 fc			ld a, (store_page+2) 
6cd1 32 f6 fb			ld (store_openmaxext), a    ; save count of ext 
6cd4 3e 01			ld a, 1  
6cd6 32 f7 fb			ld (store_openext), a    ; save count of ext 
6cd9			 
6cd9			.autof:  
6cd9 6f				ld l , a 
6cda				 
6cda 3a 07 fc			ld a, (store_page) 
6cdd 67				ld h, a	 
6cde 11 07 fc			ld de, store_page 
6ce1					if DEBUG_FORTH_WORDS 
6ce1						DMARK "ASl" 
6ce1 f5				push af  
6ce2 3a f6 6c			ld a, (.dmark)  
6ce5 32 b4 fe			ld (debug_mark),a  
6ce8 3a f7 6c			ld a, (.dmark+1)  
6ceb 32 b5 fe			ld (debug_mark+1),a  
6cee 3a f8 6c			ld a, (.dmark+2)  
6cf1 32 b6 fe			ld (debug_mark+2),a  
6cf4 18 03			jr .pastdmark  
6cf6 ..			.dmark: db "ASl"  
6cf9 f1			.pastdmark: pop af  
6cfa			endm  
# End of macro DMARK
6cfa						CALLMONITOR 
6cfa cd c6 18			call break_point_state  
6cfd				endm  
# End of macro CALLMONITOR
6cfd					endif 
6cfd cd 72 09				call storage_read 
6d00 cd 72 0f			call ishlzero 
6d03 c8				ret z 
6d04			;	jr z, .autoend 
6d04			 
6d04					if DEBUG_FORTH_WORDS 
6d04						DMARK "ASc" 
6d04 f5				push af  
6d05 3a 19 6d			ld a, (.dmark)  
6d08 32 b4 fe			ld (debug_mark),a  
6d0b 3a 1a 6d			ld a, (.dmark+1)  
6d0e 32 b5 fe			ld (debug_mark+1),a  
6d11 3a 1b 6d			ld a, (.dmark+2)  
6d14 32 b6 fe			ld (debug_mark+2),a  
6d17 18 03			jr .pastdmark  
6d19 ..			.dmark: db "ASc"  
6d1c f1			.pastdmark: pop af  
6d1d			endm  
# End of macro DMARK
6d1d						CALLMONITOR 
6d1d cd c6 18			call break_point_state  
6d20				endm  
# End of macro CALLMONITOR
6d20					endif 
6d20 11 09 fc			ld de, store_page+2 
6d23 3e 3c			ld a, display_row_4 
6d25 cd 28 0d			call str_at_display 
6d28			 
6d28 cd 38 0d			call update_display 
6d2b cd 86 0c			call delay250ms 
6d2e			 
6d2e			 
6d2e			 
6d2e 21 09 fc			ld hl, store_page+2 
6d31 cd f6 22			call forthparse 
6d34 cd 36 23			call forthexec 
6d37 cd 48 22			call forthexec_cleanup 
6d3a			 
6d3a				 
6d3a 3a f7 fb			ld a, (store_openext) 
6d3d 3c				inc a 
6d3e 32 f7 fb			ld (store_openext), a    ; save count of ext 
6d41			 
6d41 18 96			jr .autof 
6d43			;.autofdone: 
6d43			; 
6d43			;		if DEBUG_FORTH_WORDS 
6d43			;			DMARK "ASx" 
6d43			;			CALLMONITOR 
6d43			;		endif 
6d43			;;	call clear_display 
6d43			;	ret 
6d43			 
6d43			 
6d43			 
6d43			endif 
6d43			 
6d43			 
6d43			; eof 
# End of file forth_kernel.asm
6d43			;include "nascombasic.asm" 
6d43			 
6d43			 
6d43			; find out where the code ends if loaded into RAM (for SC114) 
6d43			;endofcode:  
6d43			;	nop 
6d43			 
6d43			 
6d43			; eof 
6d43			 
# End of file main.asm
6d43			include "firmware_lcd_4x20.asm" 
6d43			; **********************************************************************  
6d43			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
6d43			; **********************************************************************  
6d43			;  
6d43			; **  Written as a Small Computer Monitor App  
6d43			; **  www.scc.me.uk  
6d43			;  
6d43			; History  
6d43			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
6d43			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
6d43			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
6d43			;  
6d43			; **********************************************************************  
6d43			;  
6d43			; This program is an example of one of the methods of interfacing an   
6d43			; alphanumeric LCD module.   
6d43			;  
6d43			; In this example the display is connected to either a Z80 PIO or a   
6d43			; simple 8-bit output port.   
6d43			;  
6d43			; This interfacing method uses 4-bit data mode and uses time delays  
6d43			; rather than polling the display's ready status. As a result the   
6d43			; interface only requires 6 simple output lines:  
6d43			;   Output bit 0 = not used  
6d43			;   Output bit 1 = not used  
6d43			;   Output bit 2 = RS         High = data, Low = instruction  
6d43			;   Output bit 3 = E          Active high  
6d43			;   Output bit 4 = DB4  
6d43			;   Output bit 5 = DB5  
6d43			;   Output bit 6 = DB6  
6d43			;   Output bit 7 = DB7  
6d43			; Display's R/W is connected to 0v so it is always in write mode  
6d43			;  
6d43			; This set up should work with any system supporting the RC2014 bus  
6d43			  
6d43			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
6d43			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
6d43			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
6d43			;  
6d43			; **********************************************************************  
6d43			  
6d43			; **********************************************************************  
6d43			; **  Constants  
6d43			; **********************************************************************  
6d43			; LCD constants required by LCD support module  
6d43			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
6d43			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
6d43			kLCDBitE:   EQU 3              ;Port bit for LCD E signal  
6d43			kLCDWidth:  EQU display_cols             ;Width in characters  
6d43			  
6d43			; **********************************************************************  
6d43			; **  Code library usage  
6d43			; **********************************************************************  
6d43			  
6d43			; send character to current cursor position  
6d43			; wraps and/or scrolls screen automatically  
6d43			  
6d43			  
6d43			lcd_init:  
6d43			  
6d43			; SCMonAPI functions used  
6d43			  
6d43			; Alphanumeric LCD functions used  
6d43			; no need to specify specific functions for this module  
6d43			  
6d43 3e cf		            LD   A, 11001111b  
6d45 d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
6d47 3e 00		            LD   A, 00000000b  
6d49 d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
6d4b			  
6d4b			; Initialise alphanumeric LCD module  
6d4b cd c4 6d		            CALL fLCD_Init      ;Initialise LCD module  
6d4e			  
6d4e c9				ret  
6d4f			  
6d4f			;  
6d4f			;;  
6d4f			; lcd functions  
6d4f			;  
6d4f			;  
6d4f			  
6d4f			; what is at cursor position   
6d4f			  
6d4f			;get_cursor:	ld de, (cursor_row)   ;  row + col  
6d4f			;		call curptr  
6d4f			;		ret  
6d4f			  
6d4f			  
6d4f			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
6d4f			  
6d4f			curptr:  
6d4f c5				push bc  
6d50 21 4a fe			ld hl, display_fb0  
6d53			cpr:	  
6d53				; loop for cursor whole row  
6d53 0e 14			ld c, display_cols  
6d55 23			cpr1:	inc hl  
6d56 0d				dec c  
6d57 20 fc			jr nz, cpr1  
6d59 05				dec b  
6d5a 20 f7			jr nz, cpr  
6d5c			  
6d5c				; add col	  
6d5c			  
6d5c 23			cpr2:	inc hl  
6d5d 1d				dec e  
6d5e 20 fc			jr nz, cpr2  
6d60			  
6d60 c1				pop bc  
6d61 c9				ret  
6d62				  
6d62			  
6d62			  
6d62			  
6d62			  
6d62			; write the frame buffer given in hl to hardware   
6d62 22 52 fd		write_display: ld (display_write_tmp), hl 	   
6d65 3e 00			ld a, kLCD_Line1  
6d67 cd 35 6e		            CALL fLCD_Pos       ;Position cursor to location in A  
6d6a 06 14			ld b, display_cols  
6d6c ed 5b 52 fd		ld de, (display_write_tmp)  
6d70 cd bc 6d			call write_len_string  
6d73				  
6d73				  
6d73 2a 52 fd			ld hl, (display_write_tmp)  
6d76 11 14 00			ld de, display_cols  
6d79 19				add hl,de  
6d7a 22 52 fd			ld (display_write_tmp),hl  
6d7d			  
6d7d				  
6d7d 3e 40			ld a, kLCD_Line2  
6d7f cd 35 6e		            CALL fLCD_Pos       ;Position cursor to location in A  
6d82 06 14			ld b, display_cols  
6d84 ed 5b 52 fd		ld de, (display_write_tmp)  
6d88 cd bc 6d			call write_len_string  
6d8b				  
6d8b 2a 52 fd			ld hl, (display_write_tmp)  
6d8e 11 14 00			ld de, display_cols  
6d91 19				add hl,de  
6d92 22 52 fd			ld (display_write_tmp),hl  
6d95			  
6d95				  
6d95 3e 14			ld a, kLCD_Line3  
6d97 cd 35 6e		            CALL fLCD_Pos       ;Position cursor to location in A  
6d9a 06 14			ld b, display_cols  
6d9c ed 5b 52 fd		ld de, (display_write_tmp)  
6da0 cd bc 6d			call write_len_string  
6da3				  
6da3 2a 52 fd			ld hl, (display_write_tmp)  
6da6 11 14 00			ld de, display_cols  
6da9 19				add hl,de  
6daa 22 52 fd			ld (display_write_tmp),hl  
6dad			  
6dad				  
6dad 3e 54			ld a, kLCD_Line4  
6daf cd 35 6e		            CALL fLCD_Pos       ;Position cursor to location in A  
6db2 06 14			ld b, display_cols  
6db4 ed 5b 52 fd		ld de, (display_write_tmp)  
6db8 cd bc 6d			call write_len_string  
6dbb c9					ret  
6dbc				  
6dbc				; write out a fixed length string given in b from de  
6dbc			  
6dbc 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
6dbd cd 0e 6e		            CALL fLCD_Data      ;Write character to display  
6dc0 13				inc de  
6dc1 10 f9			djnz write_len_string  
6dc3 c9				ret  
6dc4			  
6dc4			; Some other things to do  
6dc4			;            LD   A, kLCD_Clear ;Display clear  
6dc4			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
6dc4			;            LD   A, kLCD_Under ;Display on with underscore cursor  
6dc4			;            LD   A, kLCD_On     ;Display on with no cursor  
6dc4			;            ;LD   A, kLCD_Off   ;Display off  
6dc4			;            CALL fLCD_Inst      ;Send instruction to display  
6dc4			;  
6dc4			;  
6dc4			;            halt  
6dc4			;  
6dc4			;  
6dc4			;MsgHello:   DB  "Hello World!",0  
6dc4			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
6dc4			  
6dc4			; Custom characters 5 pixels wide by 8 pixels high  
6dc4			; Up to 8 custom characters can be defined  
6dc4			;BitMaps:      
6dc4			;; Character 0x00 = Battery icon  
6dc4			;            DB  01110b  
6dc4			;            DB  11011b  
6dc4			;            DB  10001b  
6dc4			;            DB  10001b  
6dc4			;            DB  11111b  
6dc4			;            DB  11111b  
6dc4			;            DB  11111b  
6dc4			;            DB  11111b  
6dc4			;; Character 0x01 = Bluetooth icon  
6dc4			;            DB  01100b  
6dc4			;            DB  01010b  
6dc4			;            DB  11100b  
6dc4			;            DB  01000b  
6dc4			;            DB  11100b  
6dc4			;            DB  01010b  
6dc4			;            DB  01100b  
6dc4			;            DB  00000b  
6dc4			;  
6dc4			  
6dc4			  
6dc4			; **********************************************************************  
6dc4			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
6dc4			; **********************************************************************  
6dc4			;  
6dc4			; **  Written as a Small Computer Monitor App   
6dc4			; **  Version 0.1 SCC 2018-05-16  
6dc4			; **  www.scc.me.uk  
6dc4			;  
6dc4			; **********************************************************************  
6dc4			;  
6dc4			; This module provides support for alphanumeric LCD modules using with  
6dc4			; *  HD44780 (or compatible) controller  
6dc4			; *  5 x 7 pixel fonts  
6dc4			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
6dc4			; *  Interface via six digital outputs to the display (see below)  
6dc4			;  
6dc4			; LCD module pinout:  
6dc4			;   1  Vss   0v supply  
6dc4			;   2  Vdd   5v supply  
6dc4			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
6dc4			;   4  RS    High = data, Low = instruction  
6dc4			;   5  R/W   High = Read, Low = Write  
6dc4			;   6  E     Enable signal (active high)  
6dc4			;   7  DB0   Data bit 0  
6dc4			;   8  DB1   Data bit 1  
6dc4			;   9  DB2   Data bit 2  
6dc4			;  10  DB3   Data bit 3  
6dc4			;  11  DB4   Data bit 4  
6dc4			;  12  DB5   Data bit 5  
6dc4			;  13  DB6   Data bit 6  
6dc4			;  14  DB7   Data bit 7  
6dc4			;  15  A     Backlight anode (+)  
6dc4			;  16  K     Backlight cathode (-)  
6dc4			;  
6dc4			; This interfacing method uses 4-bit data mode and uses time delays  
6dc4			; rather than polling the display's ready status. As a result the   
6dc4			; interface only requires 6 simple output lines:  
6dc4			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
6dc4			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
6dc4			;   LCD DB4 = Microcomputer output port bit 4  
6dc4			;   LCD DB5 = Microcomputer output port bit 5  
6dc4			;   LCD DB6 = Microcomputer output port bit 6  
6dc4			;   LCD DB7 = Microcomputer output port bit 7  
6dc4			; Display's R/W is connected to 0v so it is always in write mode  
6dc4			; All 6 connections must be on the same port address <kLCDPrt>  
6dc4			; This method also allows a decent length of cable from micro to LCD  
6dc4			;  
6dc4			; **********************************************************************  
6dc4			;  
6dc4			; To include the code for any given function provided by this module,   
6dc4			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
6dc4			; the parent source file.  
6dc4			; For example:  #REQUIRES   uHexPrefix  
6dc4			;  
6dc4			; Also #INCLUDE this file at some point after the #REQUIRES statements  
6dc4			; in the parent source file.  
6dc4			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
6dc4			;  
6dc4			; These are the function names provided by this module:  
6dc4			; fLCD_Init                     ;Initialise LCD  
6dc4			; fLCD_Inst                     ;Send instruction to LCD  
6dc4			; fLCD_Data                     ;Send data byte to LCD  
6dc4			; fLCD_Pos                      ;Position cursor  
6dc4			; fLCD_Str                      ;Display string  
6dc4			; fLCD_Def                      ;Define custom character  
6dc4			;  
6dc4			; **********************************************************************  
6dc4			;  
6dc4			; Requires SCMonAPI.asm to also be included in the project  
6dc4			;  
6dc4			  
6dc4			  
6dc4			; **********************************************************************  
6dc4			; **  Constants  
6dc4			; **********************************************************************  
6dc4			  
6dc4			; Constants that must be defined externally  
6dc4			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
6dc4			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
6dc4			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
6dc4			;kLCDWidth: EQU 20             ;Width in characters  
6dc4			  
6dc4			; general line offsets in any frame buffer  
6dc4			  
6dc4			  
6dc4			display_row_1: equ 0  
6dc4			display_row_2: equ display_row_1+display_cols  
6dc4			display_row_3: equ display_row_2 + display_cols  
6dc4			display_row_4: equ display_row_3 + display_cols  
6dc4			;display_row_4_eol:   
6dc4			  
6dc4			  
6dc4			; Cursor position values for the start of each line  
6dc4			kLCD_Line1: EQU 0x00   
6dc4			kLCD_Line2: EQU 0x40    
6dc4			kLCD_Line3: EQU kLCD_Line1+kLCDWidth  
6dc4			kLCD_Line4: EQU kLCD_Line2+kLCDWidth   
6dc4			  
6dc4			; Instructions to send as A register to fLCD_Inst  
6dc4			kLCD_Clear: EQU 00000001b     ;LCD clear  
6dc4			kLCD_Off:   EQU 00001000b     ;LCD off  
6dc4			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
6dc4			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
6dc4			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
6dc4			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
6dc4			  
6dc4			; Constants used by this code module  
6dc4			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
6dc4			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
6dc4			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
6dc4			  
6dc4			  
6dc4			  
6dc4			; **********************************************************************  
6dc4			; **  LCD support functions  
6dc4			; **********************************************************************  
6dc4			  
6dc4			; Initialise alphanumeric LCD module  
6dc4			; LCD control register codes:  
6dc4			;   DL   0 = 4-bit mode        1 = 8-bit mode  
6dc4			;   N    0 = 1-line mode       1 = 2-line mode  
6dc4			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
6dc4			;   D    0 = Display off       1 = Display on  
6dc4			;   C    0 = Cursor off        1 = Cursor on  
6dc4			;   B    0 = Blinking off      1 = Blinking on  
6dc4			;   ID   0 = Decrement mode    1 = Increment mode  
6dc4			;   SH   0 = Entire shift off  1 = Entire shift on  
6dc4 3e 28		fLCD_Init:  LD   A, 40  
6dc6 cd 7b 6e		            CALL LCDDelay       ;Delay 40ms after power up  
6dc9			; For reliable reset set 8-bit mode - 3 times  
6dc9 cd 65 6e		            CALL WrFn8bit       ;Function = 8-bit mode  
6dcc cd 65 6e		            CALL WrFn8bit       ;Function = 8-bit mode  
6dcf cd 65 6e		            CALL WrFn8bit       ;Function = 8-bit mode  
6dd2			; Set 4-bit mode  
6dd2 cd 61 6e		            CALL WrFn4bit       ;Function = 4-bit mode  
6dd5 cd 79 6e		            CALL LCDDelay1      ;Delay 37 us or more  
6dd8			; Function set  
6dd8 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
6dda cd ed 6d		            CALL fLCD_Inst      ;2 line, display on  
6ddd			; Display On/Off control  
6ddd 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
6ddf cd ed 6d		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
6de2			; Display Clear  
6de2 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
6de4 cd ed 6d		            CALL fLCD_Inst      ;Clear display  
6de7			; Entry mode  
6de7 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
6de9 cd ed 6d		            CALL fLCD_Inst      ;Increment mode, shift off  
6dec			; Display module now initialised  
6dec c9			            RET  
6ded			; ok to here  
6ded			  
6ded			; Write instruction to LCD  
6ded			;   On entry: A = Instruction byte to be written  
6ded			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6ded f5			fLCD_Inst:  PUSH AF  
6dee f5			            PUSH AF  
6def cd 01 6e		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
6df2 f1			            POP  AF  
6df3 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
6df4 17			            RLA  
6df5 17			            RLA  
6df6 17			            RLA  
6df7 cd 01 6e		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
6dfa 3e 02		            LD   A, 2  
6dfc cd 7b 6e		            CALL LCDDelay       ;Delay 2 ms to complete   
6dff f1			            POP  AF  
6e00 c9			            RET  
6e01 e6 f0		Wr4bits:   AND  0xF0           ;Mask so we only have D4 to D7  
6e03 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6e05 cb df		            SET  kLCDBitE, A  
6e07 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6e09 cb 9f		            RES  kLCDBitE, A  
6e0b d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6e0d c9			            RET  
6e0e			  
6e0e			  
6e0e			; Write data to LCD  
6e0e			;   On entry: A = Data byte to be written  
6e0e			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6e0e f5			fLCD_Data:  PUSH AF  
6e0f f5			            PUSH AF  
6e10 cd 22 6e		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
6e13 f1			            POP  AF  
6e14 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
6e15 17			            RLA  
6e16 17			            RLA  
6e17 17			            RLA  
6e18 cd 22 6e		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
6e1b 3e 96		            LD   A, 150  
6e1d 3d			Wait:      DEC  A              ;Wait a while to allow data   
6e1e 20 fd		            JR   NZ, Wait      ;  write to complete  
6e20 f1			            POP  AF  
6e21 c9			            RET  
6e22 e6 f0		Wr4bitsa:   AND  0xF0           ;Mask so we only have D4 to D7  
6e24 cb d7		            SET  kLCDBitRS, A  
6e26 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
6e28 cb df		            SET  kLCDBitE, A  
6e2a d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
6e2c cb 9f		            RES  kLCDBitE, A  
6e2e d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
6e30 cb 97		            RES  kLCDBitRS, A  
6e32 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6e34 c9			            RET  
6e35			  
6e35			  
6e35			; Position cursor to specified location  
6e35			;   On entry: A = Cursor position  
6e35			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6e35 f5			fLCD_Pos:   PUSH AF  
6e36 f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
6e38 cd ed 6d		            CALL fLCD_Inst      ;Write instruction to LCD  
6e3b f1			            POP  AF  
6e3c c9			            RET  
6e3d			  
6e3d			  
6e3d			; Output text string to LCD  
6e3d			;   On entry: DE = Pointer to null terminated text string  
6e3d			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
6e3d 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
6e3e b7			            OR   A              ;Null terminator?  
6e3f c8			            RET  Z              ;Yes, so finished  
6e40 cd 0e 6e		            CALL fLCD_Data      ;Write character to display  
6e43 13			            INC  DE             ;Point to next character  
6e44 18 f7		            JR   fLCD_Str       ;Repeat  
6e46 c9					ret  
6e47			  
6e47			; Define custom character  
6e47			;   On entry: A = Character number (0 to 7)  
6e47			;             DE = Pointer to character bitmap data  
6e47			;   On exit:  A = Next character number  
6e47			;             DE = Next location following bitmap  
6e47			;             BC HL IX IY I AF' BC' DE' HL' preserved  
6e47			; Character is   
6e47 c5			fLCD_Def:   PUSH BC  
6e48 f5			            PUSH AF  
6e49 07			            RLCA                ;Calculate location  
6e4a 07			            RLCA                ;  for bitmap data  
6e4b 07			            RLCA                ;  = 8 x CharacterNumber  
6e4c f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
6e4e cd ed 6d		            CALL fLCD_Inst      ;Write instruction to LCD  
6e51 06 00		            LD   B, 0  
6e53 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
6e54 cd 0e 6e		            CALL fLCD_Data      ;Write byte to display  
6e57 13			            INC  DE             ;Point to next byte  
6e58 04			            INC  B              ;Count bytes  
6e59 cb 58		            BIT  3, B           ;Finish all 8 bytes?  
6e5b 28 f6		            JR   Z, Loop       ;No, so repeat  
6e5d f1			            POP  AF  
6e5e 3c			            INC  A              ;Increment character number  
6e5f c1			            POP  BC  
6e60 c9			            RET  
6e61			  
6e61			  
6e61			; **********************************************************************  
6e61			; **  Private functions  
6e61			; **********************************************************************  
6e61			  
6e61			; Write function to LCD  
6e61			;   On entry: A = Function byte to be written  
6e61			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6e61 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
6e63 18 02		            JR   WrFunc  
6e65 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
6e67 f5			WrFunc:     PUSH AF  
6e68 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6e6a cb df		            SET  kLCDBitE, A  
6e6c d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6e6e cb 9f		            RES  kLCDBitE, A  
6e70 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6e72 3e 05		            LD   A, 5  
6e74 cd 7b 6e		            CALL LCDDelay       ;Delay 5 ms to complete  
6e77 f1			            POP  AF  
6e78 c9			            RET  
6e79			  
6e79			  
6e79			; Delay in milliseconds  
6e79			;   On entry: A = Number of milliseconds delay  
6e79			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6e79 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
6e7b d5			LCDDelay:   PUSH DE  
6e7c 5f			            LD   E, A           ;Delay by 'A' ms  
6e7d 16 00		            LD   D, 0  
6e7f cd 77 0c		            CALL aDelayInMS  
6e82 d1			            POP  DE  
6e83 c9			            RET  
6e84			  
6e84			  
6e84			  
6e84			  
6e84			; eof  
6e84			  
# End of file firmware_lcd_4x20.asm
6e84			include "firmware_key_4x4.asm" 
6e84			  
6e84			  
6e84			; bit mask for each scan column and row for teing the matrix  
6e84			  
6e84			; out   
6e84 80 40 20 10	key_row_bitmask:    db 128, 64, 32, 16  
6e88			; in  
6e88 01 02 04 08	key_col_bitmask:    db 1, 2, 4, 8  
6e8c			  
6e8c			; row/col to character map  
6e8c			  
6e8c			; char, state use   123xxsss   - bit 8,7,6 this key selects specified state, s is this key is member of that state  
6e8c			;    
6e8c			  
6e8c			; physical key matrix map to face of key  
6e8c			  
6e8c			  
6e8c			;      	1	2	3	A  
6e8c			;   	abc”	def&	ghi$	s1  
6e8c			;			  
6e8c			;	4	5	6	B  
6e8c			; 	jkl,	mno.	pqr:	s2  
6e8c			;			  
6e8c			; 	7	8	9	C  
6e8c			;	stu;	vwx@	yz?!	s3  
6e8c			;			  
6e8c			; 	*	0	#	D  
6e8c			; 	shift lck '	Space < >	Enter ( )	s4  
6e8c			;       tab bs 		  
6e8c			  
6e8c			  
6e8c			  
6e8c			  
6e8c			key_init:  
6e8c			  
6e8c			; SCMonAPI functions used  
6e8c			  
6e8c			; Alphanumeric LCD functions used  
6e8c			; no need to specify specific functions for this module  
6e8c			  
6e8c			  
6e8c 3e cf		            LD   A, 11001111b  
6e8e d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
6e90			;            LD   A, 00000000b  
6e90 3e 0f		            LD   A, 00001111b  
6e92 d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
6e94			  
6e94			  
6e94				; TODO Configure cursor shapes  
6e94			  
6e94				; Load cursor shapes   
6e94 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
6e96 11 a6 6e		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
6e99 06 02		            LD   B, 2           ;Number of characters to define  
6e9b cd 47 6e		.DefLoop:   CALL fLCD_Def       ;Define custom character  
6e9e 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
6ea0			  
6ea0 3e 01				ld a, 1  
6ea2 32 4d fd			ld (cursor_shape),a  
6ea5 c9				ret  
6ea6			  
6ea6			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
6ea6			; Up to 8 custom characters can be defined  
6ea6			.cursor_shapes:      
6ea6			;; Character 0x00 = Normal  
6ea6 1f			            DB  11111b  
6ea7 1f			            DB  11111b  
6ea8 1f			            DB  11111b  
6ea9 1f			            DB  11111b  
6eaa 1f			            DB  11111b  
6eab 1f			            DB  11111b  
6eac 1f			            DB  11111b  
6ead 1f			            DB  11111b  
6eae			;; Character 0x01 = Modifier  
6eae 1f			            DB  11111b  
6eaf 1b			            DB  11011b  
6eb0 1b			            DB  11011b  
6eb1 1b			            DB  11011b  
6eb2 1b			            DB  11011b  
6eb3 1f			            DB  11111b  
6eb4 1b			            DB  11011b  
6eb5 1f			            DB  11111b  
6eb6			  
6eb6			  
6eb6			  
6eb6			  
6eb6			; Display custom character 0  
6eb6			;            LD   A, kLCD_Line1+14  
6eb6			;            CALL fLCD_Pos       ;Position cursor to location in A  
6eb6			;            LD   A, 0  
6eb6			;            CALL fLCD_Data      ;Write character in A at cursor  
6eb6			  
6eb6			; Display custom character 1  
6eb6			;            LD   A, kLCD_Line2+14  
6eb6			;            CALL fLCD_Pos      ;Position cursor to location in A  
6eb6			;            LD   A, 1  
6eb6			;            CALL fLCD_Data     ;Write character in A at cursor  
6eb6			  
6eb6			; keyboard scanning   
6eb6			  
6eb6			  
6eb6			; key_rows: equ 4  
6eb6			; key_cols: equ 4  
6eb6			; keyscan_table: edu ( tos-stacksize-(key_rows*key_cols))  
6eb6			  
6eb6			; key_scanr: equ key_row_bitmask  
6eb6			; key_scanc: equ key_col_bitmask  
6eb6			  
6eb6			; key_char_map: equ key_map  
6eb6			  
6eb6			  
6eb6			  
6eb6			; character in from keyboard  
6eb6			  
6eb6 ..			.matrix_to_char: db "D#0*C987B654A321"  
6ec6			  
6ec6			  
6ec6			; map the physical key to a char dependant on state  
6ec6			  
6ec6			.key_map_fa:   
6ec6			  
6ec6 ..					db 'D'  
6ec7 0d					db KEY_CR    ; cr  
6ec8 ..					db ' '  
6ec9 04					db  KEY_SHIFTLOCK   ; TODO Shift lock  
6eca ..					db 'C'  
6ecb ..					db 'y'  
6ecc ..					db 'v'  
6ecd ..					db 's'  
6ece ..					db 'B'  
6ecf ..					db 'p'  
6ed0 ..					db 'm'  
6ed1 ..					db 'j'  
6ed2 ..					db 'A'  
6ed3 ..					db 'g'  
6ed4 ..					db 'd'  
6ed5 ..					db 'a'  
6ed6			  
6ed6			.key_map_fb:  
6ed6			  
6ed6 ..					db 'A'  
6ed7 ..					db '+'   
6ed8 ..					db '<'  
6ed9 ..					db  "'"    
6eda			  
6eda ..					db 'A'  
6edb ..					db 'z'  
6edc ..					db 'w'  
6edd ..					db 't'  
6ede ..					db 'A'  
6edf ..					db 'q'  
6ee0 ..					db 'n'  
6ee1 ..					db 'k'  
6ee2 ..					db 'A'  
6ee3 ..					db 'h'  
6ee4 ..					db 'e'  
6ee5 ..			 		db 'b'  
6ee6			  
6ee6			.key_map_fc:   
6ee6			  
6ee6			  
6ee6 ..					db 'A'  
6ee7 ..					db '-'   
6ee8 ..					db '>'  
6ee9 ..					db  '='   	  
6eea ..					db 'A'  
6eeb ..					db '?'  
6eec ..					db 'x'  
6eed ..					db 'u'  
6eee ..					db 'A'  
6eef ..					db 'r'  
6ef0 ..					db 'o'  
6ef1 ..					db 'l'  
6ef2 ..					db 'A'  
6ef3 ..					db 'i'  
6ef4 ..					db 'f'  
6ef5 ..					db 'c'  
6ef6			  
6ef6				  
6ef6			.key_map_fd:  
6ef6			  
6ef6 ..					db 'A'  
6ef7 ..					db '/'   
6ef8 ..					db '%'   
6ef9 08					db KEY_BS  ; back space  
6efa ..					db 'A'  
6efb ..					db '!'  
6efc ..					db '@'  
6efd ..					db ';'  
6efe ..					db 'A'  
6eff ..					db ':'  
6f00 ..					db '.'  
6f01 ..					db ','  
6f02 ..					db 'A'  
6f03 ..					db '$'  
6f04 ..					db '&'  
6f05 ..				 	db '"'  
6f06			  
6f06					  
6f06				  
6f06			  
6f06			; add cin and cin_wait  
6f06			  
6f06 cd 17 6f		cin_wait: 	call cin  
6f09 fe 00			cp 0  
6f0b 28 f9			jr z, cin_wait   ; block until key press  
6f0d			  
6f0d f5				push af   ; save key pressed  
6f0e			  
6f0e cd 17 6f		.cin_wait1:	call cin  
6f11 fe 00			cp 0  
6f13 20 f9			jr nz, .cin_wait1  	; wait for key release  
6f15			  
6f15 f1				pop af   ; get key  
6f16 c9				ret  
6f17			  
6f17			  
6f17 cd 28 6f		cin: 	call .mtoc  
6f1a			  
6f1a				; no key held  
6f1a fe 00			cp 0  
6f1c c8				ret z  
6f1d			  
6f1d				; stop key bounce  
6f1d			  
6f1d			;	ld (key_held),a		 ; save it  
6f1d 47				ld b, a  
6f1e			  
6f1e c5			.cina1:	push bc  
6f1f cd 28 6f			call .mtoc  
6f22 c1				pop bc  
6f23 b8				cp b  
6f24 28 f8			jr z, .cina1  
6f26 78				ld a,b		  
6f27 c9				ret  
6f28			  
6f28			; detect keyboard modifier key press and apply new overlay to the face key held  
6f28			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
6f28			  
6f28			;.cin_map_modifier:   
6f28			;	ld a, (hl)  
6f28			;	and 255  
6f28			;	ret NZ		; modifier key not flagged  
6f28			;  
6f28			;	; get key face  
6f28			;  
6f28			;	ld b,(key_face_held)  
6f28			;  
6f28			;	ld b, key_cols * key_rows  
6f28			;  
6f28			;	push de  
6f28			;	pop hl  
6f28			;  
6f28			;.mmod1: ld a,(hl)   ; get map test  
6f28			;	cp b  
6f28			;	jr z, .mmod2  
6f28			;  
6f28			;  
6f28			;  
6f28			;.mmod2: inc hl    ;   
6f28			;  
6f28			;	  
6f28			;  
6f28			;	  
6f28			;  
6f28			;	ld hl,key_actual_pressed  
6f28			;	ld (hl),a,  
6f28			;	ret  
6f28			  
6f28				  
6f28			  
6f28			; map matrix key held to char on face of key  
6f28			  
6f28			.mtoc:  
6f28			  
6f28			  
6f28				; TODO optimise the code....  
6f28			  
6f28			; scan keyboard row 1  
6f28 3e 80			ld a, 128  
6f2a 21 d3 fe			ld hl, keyscan_table  
6f2d cd 0f 70			call .rowscan  
6f30			  
6f30				   
6f30			  
6f30 3e 40			ld a, 64  
6f32 21 d7 fe			ld hl, keyscan_table+key_cols  
6f35 cd 0f 70			call .rowscan  
6f38			  
6f38			  
6f38			  
6f38			  
6f38 3e 20			ld a, 32  
6f3a 21 db fe			ld hl, keyscan_table+(key_cols*2)  
6f3d cd 0f 70			call .rowscan  
6f40			  
6f40			  
6f40			  
6f40 3e 10			ld a, 16  
6f42 21 df fe			ld hl, keyscan_table+(key_cols*3)  
6f45 cd 0f 70			call .rowscan  
6f48			  
6f48			  
6f48				; flag if key D is held down and remove from reporting  
6f48 01 f6 6e			ld bc, .key_map_fd    
6f4b 21 d3 fe			ld hl, keyscan_table  
6f4e 11 c5 fe			ld de, key_fd  
6f51 cd a1 6f			call .key_shift_hold  
6f54 fe ff			cp 255  
6f56 28 33			jr z, .cinmap  
6f58				; flag if key C is held down and remove from reporting  
6f58 01 e6 6e			ld bc, .key_map_fc    
6f5b 21 d7 fe			ld hl, keyscan_table+key_cols  
6f5e 11 c6 fe			ld de, key_fc  
6f61 cd a1 6f			call .key_shift_hold  
6f64 fe ff			cp 255  
6f66 28 23			jr z, .cinmap  
6f68				; flag if key B is held down and remove from reporting  
6f68 01 d6 6e			ld bc, .key_map_fb    
6f6b 21 db fe			ld hl, keyscan_table+(key_cols*2)  
6f6e 11 c7 fe			ld de, key_fb  
6f71 cd a1 6f			call .key_shift_hold  
6f74 fe ff			cp 255  
6f76 28 13			jr z, .cinmap  
6f78				; flag if key A is held down and remove from reporting  
6f78 01 c6 6e			ld bc, .key_map_fa    
6f7b 21 df fe			ld hl, keyscan_table+(key_cols*3)  
6f7e 11 c8 fe			ld de, key_fa  
6f81 cd a1 6f			call .key_shift_hold  
6f84 fe ff			cp 255  
6f86 28 03			jr z, .cinmap  
6f88			  
6f88 11 b6 6e			ld de, .matrix_to_char  
6f8b			  
6f8b			  
6f8b			.cinmap:   
6f8b				if DEBUG_KEY  
6f8b			            LD   A, kLCD_Line4  
6f8b			            CALL fLCD_Pos       ;Position cursor to location in A  
6f8b					push de  
6f8b			            LD   DE, keyscan_table  
6f8b			            CALL fLCD_Str       ;Display string pointed to by DE  
6f8b					pop de  
6f8b				endif  
6f8b			  
6f8b				; scan key matrix table for any held key  
6f8b			  
6f8b				; de holds either the default matrix or one selected above  
6f8b			  
6f8b 21 d3 fe			ld hl, keyscan_table  
6f8e 06 10			ld b,key_cols*key_rows  
6f90			  
6f90 7e			.cin1:	ld a,(hl)  
6f91 fe 23			cp '#'  
6f93 28 08			jr z, .cinhit  
6f95 23				inc hl  
6f96 13				inc de  
6f97 05				dec b  
6f98 20 f6			jr nz, .cin1  
6f9a				; no key found held  
6f9a 3e 00			ld a,0  
6f9c c9				ret  
6f9d d5			.cinhit: push de  
6f9e e1				pop hl  
6f9f 7e				ld a,(hl)  
6fa0 c9				ret  
6fa1			  
6fa1			; flag a control key is held   
6fa1			; hl is key pin, de is flag indicator  
6fa1			  
6fa1			.key_shift_hold:  
6fa1 c5				push bc  
6fa2 3e 01			ld a, 1  
6fa4 32 4d fd			ld (cursor_shape),a  
6fa7 06 00			ld b, 0  
6fa9 7e				ld a, (hl)  
6faa fe 2e			cp '.'  
6fac 28 0a			jr z, .key_shift1  
6fae 06 ff			ld b, 255  
6fb0 3e 2b			ld a, '+'    ; hide key from later scans  
6fb2 77				ld (hl),a  
6fb3 3e 02			ld a, 2  
6fb5 32 4d fd			ld (cursor_shape),a  
6fb8			.key_shift1:  
6fb8				; write flag indicator  
6fb8 78				ld a,b  
6fb9 12				ld (de),a  
6fba			  
6fba d1				pop de    ; de now holds the key map ptr  
6fbb c9				ret  
6fbc			  
6fbc				  
6fbc				  
6fbc			  
6fbc			  
6fbc			  
6fbc			  
6fbc			  
6fbc			  
6fbc			  
6fbc			  
6fbc			  
6fbc			  
6fbc c9				ret  
6fbd			  
6fbd			;	push hl  
6fbd			;	push de  
6fbd			;	push bc  
6fbd			;	call keyscan  
6fbd			;	; map key matrix to ascii value of key face  
6fbd			;  
6fbd			;	ld hl, key_face_map  
6fbd			;	ld de, keyscan_table  
6fbd			;  
6fbd			;	; get how many keys to look at  
6fbd			;	ld b, keyscan_table_len  
6fbd			;	  
6fbd			;  
6fbd			;	; at this stage fall out on first key hit  
6fbd			;	; TODO handle multiple key press  
6fbd			;  
6fbd			;map1:	ld a,(hl)  
6fbd			;	cp '#'  
6fbd			;	jr z, keyhit  
6fbd			;	inc hl  
6fbd			;	inc de  
6fbd			;	dec b  
6fbd			;	jr nz, map1  
6fbd			;nohit:	ld a, 0  
6fbd			;	jr keydone  
6fbd			;keyhit: push de  
6fbd			;	pop hl  
6fbd			;	ld a,(hl)  
6fbd			;keydone:  
6fbd			;	push bc  
6fbd			;	push de  
6fbd			; 	push hl  
6fbd			;	ret   
6fbd			;  
6fbd			  
6fbd			  
6fbd			  
6fbd			  
6fbd			; scan physical key matrix  
6fbd			  
6fbd			  
6fbd			;keyscan:  
6fbd			;  
6fbd			;; for each key_row use keyscanr bit mask for out  
6fbd			;; then read in for keyscanc bitmask  
6fbd			;; save result of row scan to keyscantable  
6fbd			;  
6fbd			;; scan keyboard row 1  
6fbd			;  
6fbd			;	ld b, key_rows  
6fbd			;	ld hl, key_scanr  
6fbd			;	ld de, keyscan_table  
6fbd			;  
6fbd			;rowloop:  
6fbd			;  
6fbd			;	ld a,(hl)		; out bit mask to energise keyboard row  
6fbd			;	call rowscan  
6fbd			;	inc hl  
6fbd			;	dec b  
6fbd			;	jr nz, rowloop  
6fbd			;  
6fbd			;	ret  
6fbd			;  
6fbd			;  
6fbd			;; pass a out bitmask, b row number  
6fbd			;arowscan:   
6fbd			;	push bc  
6fbd			;  
6fbd			;	ld d, b  
6fbd			;  
6fbd			;	; calculate buffer location for this row  
6fbd			;  
6fbd			;	ld hl, keyscan_table	  
6fbd			;kbufr:  ld e, key_cols  
6fbd			;kbufc:	inc hl  
6fbd			;	dec e  
6fbd			;	jr nz, kbufc  
6fbd			;	dec d  
6fbd			;	jr nz, kbufr  
6fbd			;  
6fbd			;	; energise row and read columns  
6fbd			;  
6fbd			;	out (portbdata),a  
6fbd			;	in a,(portbdata)  
6fbd			;	ld c,a  
6fbd			;  
6fbd			;  
6fbd			;	; save buffer loc  
6fbd			;  
6fbd			;	ld (keybufptr), hl  
6fbd			;  
6fbd			;	ld hl, key_scanc  
6fbd			;	ld d, key_cols  
6fbd			;  
6fbd			;	; for each column check each bit mask  
6fbd			;  
6fbd			;colloop:  
6fbd			;	  
6fbd			;  
6fbd			;	; reset flags for the row   
6fbd			;  
6fbd			;	ld b,'.'  
6fbd			;	and (hl)  
6fbd			;	jr z, maskskip  
6fbd			;	ld b,'#'  
6fbd			;maskskip:  
6fbd			;	; save  key state  
6fbd			;	push hl  
6fbd			;	ld hl, (keybufptr)  
6fbd			;	ld (hl), b  
6fbd			;	inc hl  
6fbd			;	ld (keybufptr), hl  
6fbd			;  
6fbd			;	; move to next bit mask  
6fbd			;	pop hl  
6fbd			;	inc hl  
6fbd			;  
6fbd			;	dec d  
6fbd			;	jr nz, colloop  
6fbd			;  
6fbd			;	ret  
6fbd			;  
6fbd			;  
6fbd			;;  
6fbd			; lcd functions  
6fbd			;  
6fbd			;  
6fbd			  
6fbd			;if DEBUG_KEY_MATRIX  
6fbd			  
6fbd			; test function to display hardware view of matrix state  
6fbd			  
6fbd			matrix:  
6fbd			  
6fbd			  
6fbd			  
6fbd			; scan keyboard row 1  
6fbd 3e 80			ld a, 128  
6fbf 21 f8 fe			ld hl, keyscan_table_row1  
6fc2 cd 0f 70			call .rowscan  
6fc5			  
6fc5 3e 40			ld a, 64  
6fc7 21 f3 fe			ld hl, keyscan_table_row2  
6fca cd 0f 70			call .rowscan  
6fcd			  
6fcd 3e 20			ld a, 32  
6fcf 21 ee fe			ld hl, keyscan_table_row3  
6fd2 cd 0f 70			call .rowscan  
6fd5			  
6fd5 3e 10			ld a, 16  
6fd7 21 e9 fe			ld hl, keyscan_table_row4  
6fda cd 0f 70			call .rowscan  
6fdd			  
6fdd			; Display text on first line  
6fdd 3e 00		            LD   A, kLCD_Line1  
6fdf cd 35 6e		            CALL fLCD_Pos       ;Position cursor to location in A  
6fe2 11 f8 fe		            LD   DE, keyscan_table_row1  
6fe5			            ;LD   DE, MsgHello  
6fe5 cd 3d 6e		            CALL fLCD_Str       ;Display string pointed to by DE  
6fe8			  
6fe8			; Display text on second line  
6fe8 3e 40		            LD   A, kLCD_Line2  
6fea cd 35 6e		            CALL fLCD_Pos       ;Position cursor to location in A  
6fed 11 f3 fe		            LD   DE, keyscan_table_row2  
6ff0 cd 3d 6e		            CALL fLCD_Str       ;Display string pointed to by DE  
6ff3 3e 14		            LD   A, kLCD_Line3  
6ff5 cd 35 6e		            CALL fLCD_Pos       ;Position cursor to location in A  
6ff8 11 ee fe		            LD   DE, keyscan_table_row3  
6ffb cd 3d 6e		            CALL fLCD_Str       ;Display string pointed to by DE  
6ffe 3e 54		            LD   A, kLCD_Line4  
7000 cd 35 6e		            CALL fLCD_Pos       ;Position cursor to location in A  
7003 11 e9 fe		            LD   DE, keyscan_table_row4  
7006 cd 3d 6e		            CALL fLCD_Str       ;Display string pointed to by DE  
7009			  
7009 cd 86 0c			call delay250ms  
700c c3 bd 6f			jp matrix  
700f			  
700f			; pass de as row display flags  
700f			.rowscan:   
700f d3 c1			out (portbdata),a  
7011 db c1			in a,(portbdata)  
7013 4f				ld c,a  
7014				; reset flags for the row   
7014 06 2e			ld b,'.'  
7016 e6 01			and 1  
7018 28 02			jr z, .p1on  
701a 06 23			ld b,'#'  
701c			.p1on:  
701c 70				ld (hl), b  
701d 23				inc hl  
701e			  
701e 06 2e			ld b,'.'  
7020 79				ld a,c  
7021 e6 02			and 2  
7023			;	bit 0,a  
7023 28 02			jr z, .p2on  
7025 06 23			ld b,'#'  
7027			.p2on:  
7027 70				ld (hl), b  
7028 23				inc hl  
7029			;  
7029 06 2e			ld b,'.'  
702b 79				ld a,c  
702c e6 04			and 4  
702e			;;	bit 0,a  
702e 28 02			jr z, .p3on  
7030 06 23			ld b,'#'  
7032			.p3on:  
7032 70				ld (hl), b  
7033 23				inc hl  
7034			;;  
7034 06 2e			ld b,'.'  
7036			;;	bit 0,a  
7036 79				ld a,c  
7037 e6 08			and 8  
7039 28 02			jr z, .p4on  
703b 06 23			ld b,'#'  
703d			.p4on:  
703d 70				ld (hl), b  
703e 23				inc hl  
703f			  
703f			; zero term  
703f 06 00			ld b,0  
7041 70				ld (hl), b  
7042			  
7042 c9			.rscandone: ret  
7043			  
7043			  
7043			  
7043			;endif  
7043			  
7043			  
7043			; eof  
# End of file firmware_key_4x4.asm
# End of file os_mini.asm
7043
