# File os_mega_cpm.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 1 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; Use this to tune the delay functions if your CPU is a bit quick. i.e. RunCPM on a PC 
0000			 
0000			CPM_DELAY_TUNE: equ 4000 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0100			endif 
0100 c3 4b 18			jp coldstart     ; rst 0 - cold boot 
0103			 
0103			 
0103 .. 00		buildtime: db   "Build: 00/00/00 00:00:00",0 
011c			 
011c			 
011c			;        nop  
011c			;        nop 
011c			;;	org 05h		; null out bdos call 
011c			; 
011c			;        nop  
011c			;        nop  
011c			;        nop 
011c			;;	org 08h 
011c			;;; 
011c			;;	jp cin		; rst 8 - char in 
011c			;;; 
011c			; 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;	org 010h 
011c			;; 
011c			;	jp cout		; rest 010h  - char out 
011c			;; 
011c			;	org 01bh   
011c			; 
011c			;	;jp  		; rst 01bh   - write string to display 
011c			;	jp str_at_display 
011c			; 
011c			; 
011c			;	org 020h 
011c			; 
011c			;	; jp		 ; rst 020h - read char at screen location 
011c			; 
011c			;	org 028h 
011c			 
011c				; jp		 ; rst 028h  - storage i/o 
011c			 
011c			; 	org 030h 
011c			;	jp break_point_state 
011c			  
011c			; $30  
011c			; org 038h 
011c			; $38 
011c			 
011c			; TODO any more important entry points to add to jump table for easier coding use? 
011c			 
011c			 
011c			include "firmware.asm" 
011c			  
011c			; main constants (used here and in firmware)  
011c			  
011c			; TODO have page 0 of storage as bios  
011c			  
011c			Device_A: equ 0h  
011c			Device_B: equ 040h          ; Sound  
011c			  
011c			if BASE_KEV  
011c			Device_C: equ 080h          ; Storage and ext cart devices  
011c			endif  
011c			  
011c			if BASE_SC114  
011c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
011c			endif  
011c			  
011c			if BASE_CPM  
011c			; TODO fixup for CPM  
011c			Device_C: equ 080h          ; Storage and ext cart devices  
011c			endif  
011c			  
011c			Device_D: equ 0c0h             ; Keyboard and LCD  
011c			  
011c			; Odd specific debug points for testing hardware dev  
011c			  
011c			DEBUG_SOUND: equ 1  
011c			DEBUG_STK_FAULT: equ 0  
011c			DEBUG_INPUT: equ 0     ; Debug input entry code  
011c			DEBUG_KEYCINWAIT: equ 0  
011c			DEBUG_KEYCIN: equ 0  
011c			DEBUG_KEY: equ 0  
011c			DEBUG_KEY_MATRIX: equ 0  
011c			DEBUG_STORECF: equ 0  
011c			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
011c			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
011c			DEBUG_SPI: equ 0    ; low level spi tests  
011c			  
011c			; Enable many break points  
011c			  
011c			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
011c			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
011c			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
011c			DEBUG_FORTH_JP: equ 0    ; 4  
011c			DEBUG_FORTH_MALLOC: equ 0  
011c			DEBUG_FORTH_MALLOC_INT: equ 0  
011c			DEBUG_FORTH_DOT: equ 0  
011c			DEBUG_FORTH_DOT_WAIT: equ 0  
011c			DEBUG_FORTH_MATHS: equ 0  
011c			DEBUG_FORTH_TOK: equ 0    ; 4  
011c			DEBUG_FORTH_PARSE: equ 0    ; 3  
011c			DEBUG_FORTH: equ 0  ;2  
011c			DEBUG_FORTH_WORDS: equ 1   ; 1  
011c			DEBUG_FORTH_PUSH: equ 1   ; 1  
011c			DEBUG_FORTH_UWORD: equ 1   ; 1  
011c			  
011c			; Enable key point breakpoints  
011c			  
011c			DEBUG_FORTH_DOT_KEY: equ 0  
011c			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
011c			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
011c			  
011c			; Debug stack imbalances  
011c			  
011c			ON: equ 1  
011c			OFF: equ 0  
011c			  
011c			DEBUG_STACK_IMB: equ 0  
011c			STACK_IMB_STORE: equ 20  
011c			  
011c			; House keeping and protections  
011c			  
011c			DEBUG_FORTH_STACK_GUARD: equ 1  
011c			DEBUG_FORTH_MALLOC_GUARD: equ 1  
011c			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
011c			FORTH_ENABLE_FREE: equ 0  
011c			FORTH_ENABLE_MALLOCFREE: equ 1  
011c			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
011c			FORTH_ENABLE_FLOATMATH: equ 0  
011c			  
011c			  
011c			CALLMONITOR: macro  
011c				call break_point_state  
011c				endm  
011c			  
011c			MALLOC_1: equ 1        ; from dk88   
011c			MALLOC_2: equ 0           ; broke  
011c			MALLOC_3: equ 0           ; really broke  
011c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
011c			  
011c			if BASE_KEV   
011c			stacksize: equ 256  
011c			  
011c			STACK_RET_SIZE: equ 64  
011c			STACK_LOOP_SIZE: equ 128  
011c			STACK_DATA_SIZE: equ 512  
011c			endif  
011c			if BASE_SC114  
011c			;tos:	equ 0f000h  
011c			stacksize: equ 256  
011c			STACK_RET_SIZE: equ 64  
011c			STACK_LOOP_SIZE: equ 128  
011c			STACK_DATA_SIZE: equ 256  
011c			endif  
011c			  
011c			if BASE_CPM  
011c			;tos:	equ 0f000h  
011c			stacksize: equ 256  
011c			STACK_RET_SIZE: equ 64  
011c			STACK_LOOP_SIZE: equ 128  
011c			STACK_DATA_SIZE: equ 256  
011c			endif  
011c			  
011c			;if STORAGE_SE == 0  
011c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
011c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
011c			;endif  
011c			  
011c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
011c			  
011c			STORE_0_AUTORUN: equ $20  
011c			  
011c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
011c			  
011c			STORE_0_AUTOFILE: equ $21  
011c			STORE_0_BANKRUN: equ $23  
011c			STORE_0_FILERUN: equ $24  
011c			  
011c			; Block 0 offsets for settings  
011c			  
011c			; if set then skip prompt for start up and accept all  
011c			  
011c			STORE_0_QUICKSTART: equ $25  
011c			  
011c			; Blocks where directory table is held  
011c			  
011c			; Reducing the number of entries increases the max file size  
011c			  
011c			;STORE_DIR_START: equ 1  
011c			;STORE_DIR_END: equ 33  
011c			  
011c			; Blocks from where file data is stored  
011c			  
011c			;STORE_DATA_START: equ STORE_DIR_END + 1  
011c			  
011c			; Block indicators (<32 are data files)  
011c			  
011c			;STORE_BLOCK_CFG: equ $8f       ; config block  
011c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
011c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
011c			;STORE_BLOCK_FREE: equ $85       ; data block free  
011c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
011c			  
011c			  
011c			  
011c			; Directory entry flags  
011c			  
011c			;STORE_DIR_FREE: equ 0  
011c			;STORE_DIR_FILE:  equ 1  
011c			  
011c			; Structure offsets to directory entries  
011c			;STORE_DE_FLAG: equ 0  
011c			;STORE_DE_MAXEXT: equ 1  
011c			;STORE_DE_FILENAME: equ 2  
011c			  
011c			; Structure offsets to block 0  
011c			  
011c			;STORE_BK0_ISFOR: equ 1  
011c			;STORE_BK0_LABEL: equ 3  
011c			  
011c			; memory allocation   
011c			  
011c			chk_stund: equ tos+2           ; underflow check word  
011c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
011c			  
011c			; keyscan table needs rows x cols buffer  
011c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
011c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
011c			  
011c			keyscan_table_row1: equ chk_stovr -key_cols-1  
011c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
011c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
011c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
011c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
011c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
011c			keyscan_scancol: equ keyscan_table-key_cols  
011c			;keyscan_table_len: equ key_rows*key_cols  
011c			;keybufptr: equ keyscan_table - 2  
011c			;keysymbol: equ keybufptr - 1  
011c			key_held: equ keyscan_scancol-1	; currently held  
011c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
011c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
011c			key_fa: equ key_repeat_ct -1 ;  
011c			key_fb: equ key_fa -1 ;  
011c			key_fc: equ key_fb -1 ;  
011c			key_fd: equ key_fc -1 ;  
011c			key_face_held: equ key_fd - 1   
011c			  
011c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
011c			  
011c			hardware_config: equ key_face_held - 10  
011c			  
011c			; hardware config switches  
011c			; TODO add bitmasks on includes for hardware  
011c			; high byte for expansion ids  
011c			;     0000 0000  no card inserted  
011c			;     0000 0001  storage card inserted  
011c			;     0000 0010  spi sd card active  
011c			  
011c			;       
011c			; low byte:  
011c			;     0000 0001   4x4 keypad  
011c			;     0000 0010   full keyboard  
011c			;     0000 0011   spi/ext keyboard  
011c			;     0000 0100   20x4 lcd  
011c			;     0000 1000   40x4 lcd  
011c			;     0000 1100   spi/ext display  
011c			;     0001 0000   ide interface available  
011c			  
011c			hardware_word: equ hardware_config - 2  
011c			  
011c			; debug marker - optional display of debug point on the debug screens  
011c			  
011c			debug_mark: equ hardware_word - 4  
011c			  
011c			; input_str vars  
011c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
011c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
011c			input_size: equ input_start -1  ; number of chars  
011c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
011c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
011c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
011c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
011c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
011c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
011c			input_len: equ input_cur_onoff - 5 ; length of current input  
011c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
011c			  
011c			CUR_BLINK_RATE: equ 15  
011c			  
011c			key_actual_pressed: equ input_cursor - 1   
011c			key_symbol: equ key_actual_pressed - 1   
011c			key_shift: equ key_symbol - 1   
011c			  
011c			; Display allocation  
011c			  
011c			;display_rows: equ 4     ; move out to mini and mega files  
011c			;display_cols: equ 20  
011c			  
011c			display_fb_len: equ display_rows*display_cols  
011c			  
011c			; primary frame buffer     
011c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
011c			; working frame buffers  
011c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
011c			display_fb3: equ  display_fb1-display_fb_len - 1  
011c			display_fb2: equ  display_fb3-display_fb_len - 1  
011c			;  
011c			; pointer to active frame buffer  
011c			display_fb_active: equ display_fb2 - 2  
011c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
011c			display_write_tmp: equ display_lcde1e2 - 2  
011c			  
011c			  
011c			;  
011c			  
011c			;; can load into de directory  
011c			cursor_col: equ display_write_tmp-1  
011c			cursor_row: equ cursor_col-1  
011c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
011c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
011c			  
011c			; maths vars  
011c			  
011c			LFSRSeed: equ cursor_shape -20   
011c			randData: equ LFSRSeed - 2  
011c			xrandc: equ randData - 2  
011c			stackstore: equ xrandc - 2  
011c			seed1: equ  stackstore -2   
011c			seed2: equ seed1 - 2  
011c			  
011c			; cf storage vars  
011c			  
011c			iErrorNum:  equ seed2-1         ;Error number  
011c			iErrorReg:  equ iErrorNum -1              ;Error register  
011c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
011c			  
011c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
011c			  
011c			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
011c			  
011c			store_page: equ store_bank_active-STORE_BLOCK_LOG            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
011c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
011c			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
011c			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
011c			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
011c			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
011c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
011c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
011c			store_tmpid: equ store_tmp3 - 1		; page temp id  
011c			store_tmpext: equ store_tmpid - 1		; file extent temp  
011c			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
011c			store_openext: equ store_readcont - 1		; file extent of current opened file for read  
011c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
011c			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
011c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
011c			;  
011c			; spi vars  
011c			  
011c			  
011c			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
011c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
011c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
011c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
011c			spi_device_id: equ spi_device - 1    ; human readable bank number  
011c			  
011c			;;;;; forth cli params  
011c			  
011c			; TODO use a different frame buffer for forth???  
011c			  
011c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
011c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
011c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
011c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
011c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
011c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
011c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
011c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
011c			  
011c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
011c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
011c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
011c			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
011c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
011c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
011c			  
011c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
011c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
011c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
011c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
011c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
011c			  
011c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
011c			  
011c			; os/forth token vars  
011c			  
011c			os_last_cmd: equ os_var_array-255  
011c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
011c			os_current_i: equ os_cli_cmd-2  
011c			os_cur_ptr: equ os_current_i-2  
011c			os_word_scratch: equ os_cur_ptr-30  
011c			os_tok_len: equ os_word_scratch - 2  
011c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
011c			os_tok_malloc: equ os_tok_ptr - 2  
011c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
011c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
011c			execscratch: equ os_input-255        ; exec cmd eval buffer  
011c			scratch: equ execscratch-255  
011c			  
011c			  
011c			; temp locations for new word processing to save on adding more   
011c			  
011c			os_new_malloc: equ scratch-2  
011c			os_new_parse_len: equ os_new_malloc - 2  
011c			os_new_word_len: equ os_new_parse_len - 2  
011c			os_new_work_ptr: equ os_new_word_len - 2  
011c			os_new_src_ptr: equ os_new_work_ptr - 2  
011c			os_new_exec: equ os_new_src_ptr - 2  
011c			os_new_exec_ptr: equ os_new_exec - 2  
011c			  
011c			; resume memory alloocations....  
011c			  
011c			os_view_disable: equ os_new_exec_ptr - 1  
011c			os_view_af: equ os_view_disable - 2  
011c			os_view_hl: equ os_view_af -2  
011c			os_view_de: equ os_view_hl - 2  
011c			os_view_bc: equ os_view_de - 2  
011c			  
011c			; stack checksum word  
011c			if DEBUG_STACK_IMB  
011c				curframe: equ  os_view_de - 5  
011c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
011c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011c			else  
011c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011c			endif  
011c			  
011c			; with data stack could see memory filled with junk. need some memory management   
011c			; malloc and free entry points added  
011c			  
011c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
011c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
011c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
011c			;heap_end: equ free_list-1  ; Starting address of heap  
011c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011c			  
011c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011c			heap_end: equ chk_word-1  ; Starting address of heap  
011c			  
011c			  
011c			;if BASE_KEV   
011c			;heap_start: equ 0800eh  ; Starting address of heap  
011c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
011c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
011c			;endif  
011c			  
011c			;if BASE_SC114  
011c			;heap_start: equ baseram+15  ; Starting address of heap  
011c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
011c			;endif  
011c			  
011c			  
011c			;;;;  
011c			  
011c			  
011c			; change below to point to last memory alloc above  
011c			topusermem:  equ   heap_start  
011c			  
011c			;if BASE_KEV   
011c			;baseusermem: equ 08000h  
011c			;endif  
011c			  
011c			;if BASE_SC114  
011c			;;aseusermem:     equ    12  
011c			;baseusermem:     equ    prompt  
011c			;;baseusermem:     equ    endofcode  
011c			;endif  
011c			  
011c			  
011c			; **********************************************************************  
011c			; **  Constants  
011c			; **********************************************************************  
011c			  
011c			; Constants used by this code module  
011c			kDataReg:   EQU Device_D           ;PIO port A data register  
011c			kContReg:   EQU Device_D+2           ;PIO port A control register  
011c			  
011c			  
011c			portbdata:  equ Device_D+1    ; port b data  
011c			portbctl:   equ Device_D+3    ; port b control  
011c			  
011c			  
011c			;KEY_SHIFT:   equ 5  
011c			;KEY_SYMBOLSHIFT:  equ 6  
011c			  
011c			KEY_SHIFTLOCK: equ 4  
011c			  
011c			  
011c			KEY_UP: equ 5  
011c			KEY_NEXTWORD: equ 6  
011c			KEY_PREVWORD: equ 7  
011c			KEY_BS: equ 8  
011c			KEY_TAB:  equ 9  
011c			KEY_DOWN: equ 10  
011c			KEY_LEFT: equ 11  
011c			KEY_RIGHT: equ 12  
011c			KEY_CR:   equ 13  
011c			KEY_HOME: equ 14  
011c			KEY_END: equ 15  
011c			  
011c			KEY_F1: equ 16  
011c			KEY_F2: equ 17  
011c			KEY_F3: equ 18  
011c			KEY_F4: equ 19  
011c			  
011c			KEY_F5: equ 20  
011c			KEY_F6: equ 21  
011c			KEY_F7: equ 22  
011c			KEY_F8: equ 23  
011c			  
011c			KEY_F9: equ 24  
011c			KEY_F10: equ 25  
011c			KEY_F11: equ 26  
011c			KEY_F12: equ 27  
011c			  
011c			;if DEBUG_KEY  
011c			;	KEY_MATRIX_NO_PRESS: equ '.'  
011c			;	KEY_SHIFT:   equ '.'  
011c			;	KEY_SYMBOLSHIFT:  equ '.'  
011c			;else  
011c				KEY_SHIFT:   equ '~'  
011c				KEY_SYMBOLSHIFT:  equ '~'  
011c				KEY_MATRIX_NO_PRESS: equ '~'  
011c			;endi  
011c			  
011c			  
011c			  
011c			  
011c			; Macro to make adding debug marks easier  
011c			  
011c			DMARK: macro str  
011c				push af  
011c				ld a, (.dmark)  
011c				ld (debug_mark),a  
011c				ld a, (.dmark+1)  
011c				ld (debug_mark+1),a  
011c				ld a, (.dmark+2)  
011c				ld (debug_mark+2),a  
011c				jr .pastdmark  
011c			.dmark: db str  
011c			.pastdmark: pop af  
011c			  
011c			endm  
011c			  
011c			  
011c			; macro to detect for stack imbalances  
011c			  
011c			include "stackimbal.asm"  
011c			; Macro and code to detect stock imbalances 
011c			 
011c			SPPUSH: equ 0 
011c			 
011c			; Add a stack frame which can be checked before return 
011c			 
011c			STACKFRAME: macro onoff frame1 frame2 
011c			 
011c				if DEBUG_STACK_IMB 
011c					if onoff 
011c						; save current SP 
011c						exx 
011c			 
011c						ld de, frame1 
011c						ld a, d 
011c						ld hl, curframe 
011c						call hexout 
011c						ld a, e 
011c						ld hl, curframe+2 
011c						call hexout 
011c			  
011c						ld hl, frame1 
011c						push hl 
011c						ld hl, frame2 
011c						push hl 
011c						exx 
011c					endif 
011c					 
011c				endif 
011c			endm 
011c			 
011c			STACKFRAMECHK: macro onoff frame1 frame2 
011c			 
011c					 
011c				if DEBUG_STACK_IMB 
011c					if onoff 
011c						exx 
011c						; check stack frame SP 
011c			 
011c						ld hl, frame2 
011c						pop de   ; frame2 
011c			 
011c						call cmp16 
011c						jr nz, .spnosame 
011c						 
011c			 
011c						ld hl, frame1 
011c						pop de   ; frame1 
011c			 
011c						call cmp16 
011c						jr z, .spfrsame 
011c			 
011c						.spnosame: call showsperror 
011c			 
011c						.spfrsame: nop 
011c			 
011c						exx 
011c					endif 
011c					 
011c				endif 
011c			 
011c			 
011c			endm 
011c			 
011c			 
011c			; for a sub routine, wrap SP collection and comparisons 
011c			 
011c			; Usage: 
011c			; 
011c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
011c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
011c			 
011c			SAVESP: macro onoff storeword 
011c			 
011c				if DEBUG_STACK_IMB 
011c					if onoff 
011c						; save current SP 
011c			 
011c						ld (store_sp+(storeword*4)), sp 
011c			 
011c					endif 
011c					 
011c				endif 
011c			 
011c			endm 
011c			 
011c			CHECKSP: macro onoff storeword 
011c			 
011c				if DEBUG_STACK_IMB 
011c					if onoff 
011c			 
011c						; save SP after last save 
011c				 
011c						ld (store_sp+(storeword*4)+2), sp 
011c			 
011c						push hl 
011c						ld hl, store_sp+(storeword*4) 
011c						call check_stack_sp  
011c						pop hl 
011c			 
011c			 
011c					endif 
011c					 
011c				endif 
011c			 
011c			endm 
011c			 
011c			if DEBUG_STACK_IMB 
011c			 
011c			check_stack_sp: 
011c					push de 
011c			 
011c					ld e, (hl) 
011c					inc hl 
011c					ld d, (hl) 
011c					inc hl 
011c			 
011c					push de 
011c			 
011c			 
011c					ld e, (hl) 
011c					inc hl 
011c					ld d, (hl) 
011c					inc hl 
011c			 
011c					pop hl 
011c			 
011c			 
011c					; check to see if the same 
011c			 
011c					call cmp16 
011c					jr z, .spsame 
011c			 
011c					; not same 
011c			 
011c					call showsperror 
011c			.spsame: 
011c			 
011c					pop de 
011c			 
011c					ret 
011c			 
011c			.sperr:  db "Stack imbalance",0 
011c			 
011c			 
011c			showsperror: 
011c			 
011c			 
011c				push hl 
011c				push af 
011c				push de 
011c				call clear_display 
011c				ld de, .sperr 
011c				ld a,0 
011c			;	ld de,os_word_scratch 
011c				call str_at_display 
011c				ld a, display_row_1+17 
011c				ld de, debug_mark 
011c				call str_at_display 
011c				ld a, 0 
011c				ld (curframe+4),a 
011c				ld hl, curframe 
011c				ld de, os_word_scratch 
011c				ld a, display_row_4 
011c				call str_at_display 
011c				call update_display 
011c				;call break_point_state 
011c				call cin_wait 
011c			 
011c				ld a, ' ' 
011c				ld (os_view_disable), a 
011c				pop de	 
011c				pop af 
011c				pop hl 
011c				CALLMONITOR 
011c				ret 
011c			 
011c			endif 
011c			 
011c			 
011c			 
011c			; eof 
# End of file stackimbal.asm
011c			  
011c			;TODO macro to calc col and row offset into screen  
011c			  
011c			  
011c			  
011c			hardware_init:  
011c			  
011c				  
011c			  
011c					;ld a, 0  
011c					;ld (hardware_diag), a  
011c			  
011c					; clear all the buffers  
011c			  
011c 21 16 ed				ld hl, display_fb1  
011f 22 d2 eb				ld (display_fb_active), hl  
0122			  
0122 cd 7a 0b				call clear_display  
0125			  
0125 21 d4 eb				ld hl, display_fb2  
0128 22 d2 eb				ld (display_fb_active), hl  
012b			  
012b cd 7a 0b				call clear_display  
012e			  
012e					; init primary frame buffer area  
012e 21 b7 ed				ld hl, display_fb0  
0131 22 d2 eb				ld (display_fb_active), hl  
0134			  
0134 cd 7a 0b				call clear_display  
0137			  
0137			  
0137 cd f9 5a				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
013a			  
013a cd e7 5b			call key_init  
013d cd 9f 01			call storage_init  
0140			  
0140				; setup malloc functions  
0140			  
0140				if MALLOC_1  
0140 cd 4a 12				call  heap_init  
0143				endif  
0143				if MALLOC_4  
0143					call  heap_init  
0143				endif  
0143			  
0143				; init sound hardware if present  
0143			  
0143				if SOUND_ENABLE  
0143					call sound_init  
0143				endif  
0143			  
0143				; lcd test sequence  
0143					  
0143 cd 9d 0b			call update_display  
0146 cd ec 0a			call delay1s  
0149 3e 2b			ld a,'+'  
014b cd 7f 0b			call fill_display  
014e cd 9d 0b			call update_display  
0151 cd ec 0a			call delay1s  
0154 3e 2a			ld a,'*'  
0156 cd 7f 0b			call fill_display  
0159 cd 9d 0b			call update_display  
015c cd ec 0a			call delay1s  
015f 3e 2d			ld a,'-'  
0161 cd 7f 0b			call fill_display  
0164 cd 9d 0b			call update_display  
0167 cd ec 0a			call delay1s  
016a			  
016a			; boot splash screen  
016a			if display_cols == 20	  
016a			        ld a, display_row_1    
016a			else  
016a 3e 0a		        ld a, display_row_1 +10   
016c			endif  
016c 11 7e 17			ld de, prom_bootmsg  
016f cd 8d 0b			call str_at_display  
0172 cd 9d 0b			call update_display  
0175			  
0175			  
0175 cd ec 0a			call delay1s  
0178 cd ec 0a			call delay1s  
017b			if display_cols == 20	  
017b			            LD   A, display_row_3+2  
017b			else  
017b 3e 5c		            LD   A, display_row_3+12  
017d			endif  
017d 11 93 17			ld de, prom_bootmsg1  
0180 cd 8d 0b			call str_at_display  
0183 cd 9d 0b			call update_display  
0186 cd ec 0a			call delay1s  
0189 cd ec 0a			call delay1s  
018c			  
018c			;	ld a, display_row_4+3  
018c			;	ld de, bootmsg2  
018c			;	call str_at_display  
018c			;	call update_display  
018c			;	call delay1s  
018c			;	call delay1s  
018c			  
018c			; debug mark setup  
018c			  
018c 3e 5f		ld a, '_'  
018e 32 71 ee		ld (debug_mark),a  
0191 32 72 ee		ld (debug_mark+1),a  
0194 32 73 ee		ld (debug_mark+2),a  
0197 3e 00		ld a,0  
0199 32 74 ee		ld (debug_mark+3),a  
019c			  
019c c9					ret  
019d			  
019d			  
019d			;bootmsg2:	db "Firmware v0.1",0  
019d			  
019d			; a 4x20 lcd  
019d			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
019d			  
019d			;if display_cols == 20  
019d			;	include "firmware_lcd_4x20.asm"  
019d			;endif  
019d			  
019d			;if display_cols == 40  
019d			;	include "firmware_lcd_4x40.asm"  
019d			;endif  
019d			  
019d			;  
019d			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
019d			; TODO abstract the bit bang video out interface for dual display  
019d			; TODO wire video out to tx pin on rc2014 bus  
019d			  
019d			; must supply cin, and cin_wait for low level hardware abstraction   
019d			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
019d			; test scancode  
019d			  
019d			;;;;;  
019d			;;;  
019d			; Moved out to mini and maxi versions  
019d			;  
019d			; include "firmware_key_4x4.asm"  
019d			; using existing 4 wire x 4 resistor array for input  
019d			;include "firmware_key_4x10.asm"  
019d			; need to mod the board for 5 rows due to resistor array  
019d			;include "firmware_key_5x10.asm"  
019d			  
019d			; storage hardware interface  
019d			  
019d			; use microchip serial eeprom for storage  
019d			  
019d			  
019d			if STORAGE_SE  
019d				include "firmware_spi.asm"  
019d				include "firmware_seeprom.asm"  
019d			else  
019d			   ; create some stubs for the labels  
019d c9			se_readbyte: ret  
019e c9			se_writebyte: ret  
019f c9			storage_init: ret  
01a0			  
01a0			endif  
01a0			  
01a0			; use cf card for storage - throwing timeout errors. Hardware or software?????  
01a0			;include "firmware_cf.asm"  
01a0			  
01a0			; load up high level storage hardward abstractions  
01a0			include "firmware_storage.asm"  
01a0			 
01a0			; persisent storage hardware abstraction layer  
01a0			 
01a0			 
01a0			 
01a0			; Block 0 on storage is a config state 
01a0			 
01a0			 
01a0			 
01a0			; TODO add read phy block and write phy block functions 
01a0			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
01a0			 
01a0			; Abstraction layer  
01a0			 
01a0			; Logocial block size is same size as physical size - using tape concept 
01a0			 
01a0			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
01a0			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
01a0			 
01a0			 
01a0			 
01a0			; Filesystem layout (Logical layout) 
01a0			; 
01a0			; Block 0 - Bank config  
01a0			; 
01a0			;      Byte - 0 file id counter 
01a0			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
01a0			;      Byte - 3-20 zero terminated bank label 
01a0			; 
01a0			; Block 1 > File storage 
01a0			; 
01a0			;      Byte 0 file id    - block 0 file details 
01a0			;      Byte 1 block id - block 0 is file  
01a0			;            Byte 2-15 - File name 
01a0			; 
01a0			;       - to end of block data 
01a0			; 
01a0			 
01a0			; Get ID for the file named in pointer held HL 
01a0			; Returns ID in HL = 255 if no file found 
01a0			 
01a0			storage_getid: 
01a0			 
01a0 22 7d ea			ld (store_tmp1), hl 
01a3			 
01a3				if DEBUG_STORESE 
01a3					DMARK "SGI" 
01a3 f5				push af  
01a4 3a b8 01			ld a, (.dmark)  
01a7 32 71 ee			ld (debug_mark),a  
01aa 3a b9 01			ld a, (.dmark+1)  
01ad 32 72 ee			ld (debug_mark+1),a  
01b0 3a ba 01			ld a, (.dmark+2)  
01b3 32 73 ee			ld (debug_mark+2),a  
01b6 18 03			jr .pastdmark  
01b8 ..			.dmark: db "SGI"  
01bb f1			.pastdmark: pop af  
01bc			endm  
# End of macro DMARK
01bc					CALLMONITOR 
01bc cd a8 15			call break_point_state  
01bf				endm  
# End of macro CALLMONITOR
01bf				endif 
01bf				; get block 0 and set counter for number of files to scan 
01bf			 
01bf cd 2a 03			call storage_get_block_0 
01c2			 
01c2 3a 84 ea			ld a, (store_page) 
01c5 47				ld b, a 
01c6			 
01c6				; get extent 0 of each file id 
01c6			 
01c6				if DEBUG_STORESE 
01c6					DMARK "SGc" 
01c6 f5				push af  
01c7 3a db 01			ld a, (.dmark)  
01ca 32 71 ee			ld (debug_mark),a  
01cd 3a dc 01			ld a, (.dmark+1)  
01d0 32 72 ee			ld (debug_mark+1),a  
01d3 3a dd 01			ld a, (.dmark+2)  
01d6 32 73 ee			ld (debug_mark+2),a  
01d9 18 03			jr .pastdmark  
01db ..			.dmark: db "SGc"  
01de f1			.pastdmark: pop af  
01df			endm  
# End of macro DMARK
01df					CALLMONITOR 
01df cd a8 15			call break_point_state  
01e2				endm  
# End of macro CALLMONITOR
01e2				endif 
01e2 60			.getloop:	ld h, b 
01e3 2e 00				ld l, 0 
01e5 c5					push bc 
01e6			 
01e6 11 84 ea				ld de, store_page 
01e9				if DEBUG_STORESE 
01e9					DMARK "SGr" 
01e9 f5				push af  
01ea 3a fe 01			ld a, (.dmark)  
01ed 32 71 ee			ld (debug_mark),a  
01f0 3a ff 01			ld a, (.dmark+1)  
01f3 32 72 ee			ld (debug_mark+1),a  
01f6 3a 00 02			ld a, (.dmark+2)  
01f9 32 73 ee			ld (debug_mark+2),a  
01fc 18 03			jr .pastdmark  
01fe ..			.dmark: db "SGr"  
0201 f1			.pastdmark: pop af  
0202			endm  
# End of macro DMARK
0202					CALLMONITOR 
0202 cd a8 15			call break_point_state  
0205				endm  
# End of macro CALLMONITOR
0205				endif 
0205 cd d2 07				call storage_read 
0208 cd d0 0d				call ishlzero 
020b 28 2d				jr z, .gap 
020d					 
020d					; have a file name read. Is it one we want. 
020d			 
020d 2a 7d ea				ld hl, (store_tmp1) 
0210 11 87 ea				ld de, store_page+3   ; file name 
0213			 
0213				if DEBUG_STORESE 
0213					DMARK "SGc" 
0213 f5				push af  
0214 3a 28 02			ld a, (.dmark)  
0217 32 71 ee			ld (debug_mark),a  
021a 3a 29 02			ld a, (.dmark+1)  
021d 32 72 ee			ld (debug_mark+1),a  
0220 3a 2a 02			ld a, (.dmark+2)  
0223 32 73 ee			ld (debug_mark+2),a  
0226 18 03			jr .pastdmark  
0228 ..			.dmark: db "SGc"  
022b f1			.pastdmark: pop af  
022c			endm  
# End of macro DMARK
022c					CALLMONITOR 
022c cd a8 15			call break_point_state  
022f				endm  
# End of macro CALLMONITOR
022f				endif 
022f cd 3d 12				call strcmp 
0232 20 06				jr nz, .gap   ; not this one 
0234			 
0234 c1				        pop bc 
0235			 
0235 26 00				ld h, 0 
0237 68					ld l, b 
0238 18 22				jr .getdone 
023a						 
023a			 
023a			 
023a			 
023a			.gap: 
023a				if DEBUG_STORESE 
023a					DMARK "SGg" 
023a f5				push af  
023b 3a 4f 02			ld a, (.dmark)  
023e 32 71 ee			ld (debug_mark),a  
0241 3a 50 02			ld a, (.dmark+1)  
0244 32 72 ee			ld (debug_mark+1),a  
0247 3a 51 02			ld a, (.dmark+2)  
024a 32 73 ee			ld (debug_mark+2),a  
024d 18 03			jr .pastdmark  
024f ..			.dmark: db "SGg"  
0252 f1			.pastdmark: pop af  
0253			endm  
# End of macro DMARK
0253					CALLMONITOR 
0253 cd a8 15			call break_point_state  
0256				endm  
# End of macro CALLMONITOR
0256				endif 
0256			 
0256 c1					pop bc 
0257 10 89				djnz .getloop 
0259 21 ff 00				ld hl, 255 
025c			.getdone: 
025c			 
025c				if DEBUG_STORESE 
025c					DMARK "SGe" 
025c f5				push af  
025d 3a 71 02			ld a, (.dmark)  
0260 32 71 ee			ld (debug_mark),a  
0263 3a 72 02			ld a, (.dmark+1)  
0266 32 72 ee			ld (debug_mark+1),a  
0269 3a 73 02			ld a, (.dmark+2)  
026c 32 73 ee			ld (debug_mark+2),a  
026f 18 03			jr .pastdmark  
0271 ..			.dmark: db "SGe"  
0274 f1			.pastdmark: pop af  
0275			endm  
# End of macro DMARK
0275					CALLMONITOR 
0275 cd a8 15			call break_point_state  
0278				endm  
# End of macro CALLMONITOR
0278				endif 
0278			 
0278 c9				ret 
0279			 
0279			 
0279			 
0279			 
0279			 
0279			 
0279			 
0279			 
0279			; Read Block 
0279			; ---------- 
0279			; 
0279			; With current bank 
0279			;  
0279			; Get block number to read 
0279			; Load physical blocks starting at start block into buffer 
0279			 
0279			; de points to buffer to use 
0279			; hl holds logical block number  
0279			 
0279			storage_read_block: 
0279			 
0279				; TODO bank selection 
0279			 
0279				; for each of the physical blocks read it into the buffer 
0279 06 40			ld b, STORE_BLOCK_PHY 
027b			 
027b				if DEBUG_STORESE 
027b d5					push de 
027c				endif 
027c				 
027c			.rl1:    
027c			 
027c				; read physical block at hl into de 
027c			        ; increment hl and de to next read position on exit 
027c			 
027c e5				push hl 
027d d5				push de	 
027e c5				push bc 
027f			;	if DEBUG_STORESE 
027f			;		push af 
027f			;		ld a, 'R' 
027f			;		ld (debug_mark),a 
027f			;		pop af 
027f			;		CALLMONITOR 
027f			;	endif 
027f cd 9d 01			call se_readbyte 
0282			;	if DEBUG_STORESE 
0282			;		ld a,(spi_portbyte) 
0282			;		ld l, a 
0282			;		push af 
0282			;		ld a, '1' 
0282			;		ld (debug_mark),a 
0282			;		pop af 
0282			;		CALLMONITOR 
0282			;	endif 
0282 c1				pop bc 
0283 d1				pop de 
0284 e1				pop hl 
0285 12				ld (de),a 
0286 23				inc hl 
0287 13				inc de 
0288			 
0288			;	if DEBUG_STORESE 
0288			;		push af 
0288			;		ld a, 'r' 
0288			;		ld (debug_mark),a 
0288			;		pop af 
0288			;		CALLMONITOR 
0288			;	endif 
0288			 
0288 10 f2			djnz .rl1 
028a			 
028a				if DEBUG_STORESE 
028a					DMARK "SRB" 
028a f5				push af  
028b 3a 9f 02			ld a, (.dmark)  
028e 32 71 ee			ld (debug_mark),a  
0291 3a a0 02			ld a, (.dmark+1)  
0294 32 72 ee			ld (debug_mark+1),a  
0297 3a a1 02			ld a, (.dmark+2)  
029a 32 73 ee			ld (debug_mark+2),a  
029d 18 03			jr .pastdmark  
029f ..			.dmark: db "SRB"  
02a2 f1			.pastdmark: pop af  
02a3			endm  
# End of macro DMARK
02a3 d1					pop de 
02a4			; 
02a4			;		push af 
02a4			;		ld a, 'R' 
02a4			;		ld (debug_mark),a 
02a4			;		pop af 
02a4					CALLMONITOR 
02a4 cd a8 15			call break_point_state  
02a7				endm  
# End of macro CALLMONITOR
02a7				endif 
02a7 c9				ret	 
02a8				 
02a8			 
02a8			; File Size 
02a8			; --------- 
02a8			; 
02a8			;   hl file id 
02a8			; 
02a8			;  returns in hl the number of blocks 
02a8			 
02a8			storage_file_size: 
02a8 5d				ld e, l 
02a9 16 00			ld d, 0 
02ab 21 40 00			ld hl, STORE_BLOCK_PHY 
02ae					if DEBUG_FORTH_WORDS 
02ae						DMARK "SIZ" 
02ae f5				push af  
02af 3a c3 02			ld a, (.dmark)  
02b2 32 71 ee			ld (debug_mark),a  
02b5 3a c4 02			ld a, (.dmark+1)  
02b8 32 72 ee			ld (debug_mark+1),a  
02bb 3a c5 02			ld a, (.dmark+2)  
02be 32 73 ee			ld (debug_mark+2),a  
02c1 18 03			jr .pastdmark  
02c3 ..			.dmark: db "SIZ"  
02c6 f1			.pastdmark: pop af  
02c7			endm  
# End of macro DMARK
02c7						CALLMONITOR 
02c7 cd a8 15			call break_point_state  
02ca				endm  
# End of macro CALLMONITOR
02ca					endif 
02ca cd ac 05			call storage_findnextid 
02cd			 
02cd cd d0 0d			call ishlzero 
02d0			;	ld a, l 
02d0			;	add h 
02d0			;	cp 0 
02d0 c8				ret z			; block not found so EOF 
02d1			 
02d1 11 84 ea			ld de, store_page 
02d4 cd 79 02			call storage_read_block 
02d7			 
02d7 3a 86 ea			ld a, (store_page+2)	 ; get extent count 
02da 6f				ld l, a 
02db 26 00			ld h, 0 
02dd c9			 	ret 
02de			 
02de			 
02de			; Write Block 
02de			; ----------- 
02de			; 
02de			; With current bank 
02de			;  
02de			; Get block number to write 
02de			; Write physical blocks starting at start block from buffer 
02de			  
02de			storage_write_block: 
02de				; TODO bank selection 
02de			 
02de				; for each of the physical blocks read it into the buffer 
02de 06 40			ld b, STORE_BLOCK_PHY 
02e0			 
02e0				if DEBUG_STORESE 
02e0					DMARK "SWB" 
02e0 f5				push af  
02e1 3a f5 02			ld a, (.dmark)  
02e4 32 71 ee			ld (debug_mark),a  
02e7 3a f6 02			ld a, (.dmark+1)  
02ea 32 72 ee			ld (debug_mark+1),a  
02ed 3a f7 02			ld a, (.dmark+2)  
02f0 32 73 ee			ld (debug_mark+2),a  
02f3 18 03			jr .pastdmark  
02f5 ..			.dmark: db "SWB"  
02f8 f1			.pastdmark: pop af  
02f9			endm  
# End of macro DMARK
02f9			 
02f9					;push af 
02f9					;ld a, 'W' 
02f9					;ld (debug_mark),a 
02f9					;pop af 
02f9					CALLMONITOR 
02f9 cd a8 15			call break_point_state  
02fc				endm  
# End of macro CALLMONITOR
02fc				endif 
02fc			 
02fc			; might not be working 
02fc			;	call se_writepage 
02fc			 
02fc			;	ret 
02fc			; 
02fc			 
02fc			 
02fc			 
02fc			.wl1:    
02fc			 
02fc				; read physical block at hl into de 
02fc			        ; increment hl and de to next read position on exit 
02fc			 
02fc e5				push hl 
02fd d5				push de	 
02fe c5				push bc 
02ff 1a				ld a,(de) 
0300				;if DEBUG_STORESE 
0300			;		push af 
0300			;		ld a, 'W' 
0300			;		ld (debug_mark),a 
0300			;		pop af 
0300			;		CALLMONITOR 
0300			;	endif 
0300 cd 9e 01			call se_writebyte 
0303			;	call delay250ms 
0303 00				nop 
0304 00				nop 
0305 00				nop 
0306			;	if DEBUG_STORESE 
0306			;		push af 
0306			;		ld a, 'w' 
0306			;		ld (debug_mark),a 
0306			;		pop af 
0306			;		CALLMONITOR 
0306			;	endif 
0306 c1				pop bc 
0307 d1				pop de 
0308 e1				pop hl 
0309 23				inc hl 
030a 13				inc de 
030b			 
030b			 
030b 10 ef			djnz .wl1 
030d			 
030d				if DEBUG_STORESE 
030d					DMARK "SW2" 
030d f5				push af  
030e 3a 22 03			ld a, (.dmark)  
0311 32 71 ee			ld (debug_mark),a  
0314 3a 23 03			ld a, (.dmark+1)  
0317 32 72 ee			ld (debug_mark+1),a  
031a 3a 24 03			ld a, (.dmark+2)  
031d 32 73 ee			ld (debug_mark+2),a  
0320 18 03			jr .pastdmark  
0322 ..			.dmark: db "SW2"  
0325 f1			.pastdmark: pop af  
0326			endm  
# End of macro DMARK
0326			 
0326					;push af 
0326					;ld a, 'W' 
0326					;ld (debug_mark),a 
0326					;pop af 
0326					CALLMONITOR 
0326 cd a8 15			call break_point_state  
0329				endm  
# End of macro CALLMONITOR
0329				endif 
0329 c9				ret	 
032a			 
032a			; Init bank 
032a			; --------- 
032a			; 
032a			; With current bank 
032a			; 
032a			; Setup block 0 config 
032a			;     Set 0 file id counter 
032a			;     Set formatted byte pattern 
032a			;     Zero out bank label 
032a			;      
032a			; For every logical block write 0-1 byte as null 
032a			 
032a			storage_get_block_0: 
032a			 
032a				; TODO check presence 
032a			 
032a				; get block 0 config 
032a			 
032a 21 00 00			ld hl, 0 
032d 11 84 ea			ld de, store_page 
0330 cd 79 02			call storage_read_block 
0333			 
0333				if DEBUG_STORESE 
0333					DMARK "SB0" 
0333 f5				push af  
0334 3a 48 03			ld a, (.dmark)  
0337 32 71 ee			ld (debug_mark),a  
033a 3a 49 03			ld a, (.dmark+1)  
033d 32 72 ee			ld (debug_mark+1),a  
0340 3a 4a 03			ld a, (.dmark+2)  
0343 32 73 ee			ld (debug_mark+2),a  
0346 18 03			jr .pastdmark  
0348 ..			.dmark: db "SB0"  
034b f1			.pastdmark: pop af  
034c			endm  
# End of macro DMARK
034c 11 84 ea				ld de, store_page 
034f			;		push af 
034f			;		ld a, 'i' 
034f			;		ld (debug_mark),a 
034f			;		pop af 
034f					CALLMONITOR 
034f cd a8 15			call break_point_state  
0352				endm  
# End of macro CALLMONITOR
0352				endif 
0352			 
0352				; is this area formatted? 
0352			 
0352			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0352 2a 85 ea			ld hl, (store_page+1) 
0355 3e 80			ld a,0x80 
0357 bd				cp l 
0358 20 22			jr nz, .ininotformatted 
035a				; do a double check 
035a 3e 27			ld a, 0x27 
035c bc				cp h 
035d 20 1d			jr nz, .ininotformatted 
035f			 
035f				; formatted then 
035f			 
035f				if DEBUG_STORESE 
035f					DMARK "SB1" 
035f f5				push af  
0360 3a 74 03			ld a, (.dmark)  
0363 32 71 ee			ld (debug_mark),a  
0366 3a 75 03			ld a, (.dmark+1)  
0369 32 72 ee			ld (debug_mark+1),a  
036c 3a 76 03			ld a, (.dmark+2)  
036f 32 73 ee			ld (debug_mark+2),a  
0372 18 03			jr .pastdmark  
0374 ..			.dmark: db "SB1"  
0377 f1			.pastdmark: pop af  
0378			endm  
# End of macro DMARK
0378					;push af 
0378					;ld a, 'I' 
0378					;ld (debug_mark),a 
0378					;pop af 
0378					CALLMONITOR 
0378 cd a8 15			call break_point_state  
037b				endm  
# End of macro CALLMONITOR
037b				endif 
037b c9				ret 
037c			 
037c			.ininotformatted: 
037c				; bank not formatted so poke various bits to make sure 
037c			 
037c				if DEBUG_STORESE 
037c					DMARK "SB2" 
037c f5				push af  
037d 3a 91 03			ld a, (.dmark)  
0380 32 71 ee			ld (debug_mark),a  
0383 3a 92 03			ld a, (.dmark+1)  
0386 32 72 ee			ld (debug_mark+1),a  
0389 3a 93 03			ld a, (.dmark+2)  
038c 32 73 ee			ld (debug_mark+2),a  
038f 18 03			jr .pastdmark  
0391 ..			.dmark: db "SB2"  
0394 f1			.pastdmark: pop af  
0395			endm  
# End of macro DMARK
0395					;push af 
0395					;ld a, 'f' 
0395					;ld (debug_mark),a 
0395					;pop af 
0395					CALLMONITOR 
0395 cd a8 15			call break_point_state  
0398				endm  
# End of macro CALLMONITOR
0398				endif 
0398			 
0398 cd af 0a			call storage_clear_page 
039b			 
039b 21 84 ea			ld hl, store_page 
039e 3e 00			ld a, 0 
03a0				 
03a0 77				ld (hl),a   ; reset file counter 
03a1			 
03a1 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03a4 22 85 ea		 	ld (store_page+1), hl	 
03a7			 
03a7				; set default label 
03a7			 
03a7 21 43 04			ld hl, .defaultbanklabl 
03aa 11 87 ea		 	ld de, store_page+3 
03ad 01 0f 00			ld bc, 15 
03b0 ed b0			ldir 
03b2			 
03b2				; Append the current bank id 
03b2 21 90 ea			ld hl, store_page+3+9 
03b5 3a 6c ea			ld a, (spi_device_id) 
03b8 77				ld (hl), a 
03b9			 
03b9				; save default page 0 
03b9			 
03b9 21 00 00			ld hl, 0 
03bc 11 84 ea			ld de, store_page 
03bf				if DEBUG_STORESE 
03bf					DMARK "SB3" 
03bf f5				push af  
03c0 3a d4 03			ld a, (.dmark)  
03c3 32 71 ee			ld (debug_mark),a  
03c6 3a d5 03			ld a, (.dmark+1)  
03c9 32 72 ee			ld (debug_mark+1),a  
03cc 3a d6 03			ld a, (.dmark+2)  
03cf 32 73 ee			ld (debug_mark+2),a  
03d2 18 03			jr .pastdmark  
03d4 ..			.dmark: db "SB3"  
03d7 f1			.pastdmark: pop af  
03d8			endm  
# End of macro DMARK
03d8			;		push af 
03d8			;		ld a, 'F' 
03d8			;		ld (debug_mark),a 
03d8			;		pop af 
03d8					CALLMONITOR 
03d8 cd a8 15			call break_point_state  
03db				endm  
# End of macro CALLMONITOR
03db				endif 
03db cd de 02			call storage_write_block 
03de				if DEBUG_STORESE 
03de					DMARK "SB4" 
03de f5				push af  
03df 3a f3 03			ld a, (.dmark)  
03e2 32 71 ee			ld (debug_mark),a  
03e5 3a f4 03			ld a, (.dmark+1)  
03e8 32 72 ee			ld (debug_mark+1),a  
03eb 3a f5 03			ld a, (.dmark+2)  
03ee 32 73 ee			ld (debug_mark+2),a  
03f1 18 03			jr .pastdmark  
03f3 ..			.dmark: db "SB4"  
03f6 f1			.pastdmark: pop af  
03f7			endm  
# End of macro DMARK
03f7			;		push af 
03f7			;		ld a, '>' 
03f7			;		ld (debug_mark),a 
03f7			;		pop af 
03f7					CALLMONITOR 
03f7 cd a8 15			call break_point_state  
03fa				endm  
# End of macro CALLMONITOR
03fa				endif 
03fa			 
03fa 00				nop 
03fb 00				nop 
03fc 00				nop 
03fd			 
03fd				; now set 0 in every page to mark as a free block 
03fd			 
03fd 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
03ff 21 40 00			ld hl, STORE_BLOCK_PHY 
0402			 
0402 3e 00		.setmark1:   	ld a,0 
0404 e5					push hl 
0405 c5					push bc 
0406 cd 9e 01				call se_writebyte 
0409 3e 0a			ld a, 10 
040b cd d1 0a			call aDelayInMS 
040e 23				inc hl 
040f cd 9e 01				call se_writebyte 
0412 3e 0a			ld a, 10 
0414 cd d1 0a			call aDelayInMS 
0417 2b				dec hl 
0418 c1					pop bc 
0419 e1					pop hl 
041a 3e 40				ld a, STORE_BLOCK_PHY 
041c cd a7 0d				call addatohl 
041f 10 e1				djnz .setmark1 
0421			 
0421 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0423 3e 00		.setmark2:   	ld a,0 
0425 e5					push hl 
0426 c5					push bc 
0427 cd 9e 01				call se_writebyte 
042a 3e 0a			ld a, 10 
042c cd d1 0a			call aDelayInMS 
042f 23				inc hl 
0430 cd 9e 01				call se_writebyte 
0433 3e 0a			ld a, 10 
0435 cd d1 0a			call aDelayInMS 
0438 2b				dec hl 
0439 c1					pop bc 
043a e1					pop hl 
043b 3e 40				ld a, STORE_BLOCK_PHY 
043d cd a7 0d				call addatohl 
0440 10 e1				djnz .setmark2 
0442			 
0442					 
0442			 
0442			 
0442 c9				ret 
0443			 
0443			 
0443			 
0443			 
0443 .. 00		.defaultbanklabl:   db "BankLabel_",0 
044e			 
044e			 
044e			 
044e			; Label Bank 
044e			; ---------- 
044e			; 
044e			; With current bank 
044e			; Read block 0 
044e			; Set label 
044e			; Write block 0 
044e			 
044e			; label str pointer in hl 
044e			 
044e			storage_label:     
044e			 
044e				if DEBUG_STORESE 
044e					DMARK "LBL" 
044e f5				push af  
044f 3a 63 04			ld a, (.dmark)  
0452 32 71 ee			ld (debug_mark),a  
0455 3a 64 04			ld a, (.dmark+1)  
0458 32 72 ee			ld (debug_mark+1),a  
045b 3a 65 04			ld a, (.dmark+2)  
045e 32 73 ee			ld (debug_mark+2),a  
0461 18 03			jr .pastdmark  
0463 ..			.dmark: db "LBL"  
0466 f1			.pastdmark: pop af  
0467			endm  
# End of macro DMARK
0467					CALLMONITOR 
0467 cd a8 15			call break_point_state  
046a				endm  
# End of macro CALLMONITOR
046a				endif 
046a			 
046a e5				push hl 
046b			 
046b cd 2a 03			call storage_get_block_0 
046e			 
046e				; set default label 
046e			 
046e e1				pop hl 
046f			 
046f 11 87 ea		 	ld de, store_page+3 
0472 01 0f 00			ld bc, 15 
0475				if DEBUG_STORESE 
0475					DMARK "LB3" 
0475 f5				push af  
0476 3a 8a 04			ld a, (.dmark)  
0479 32 71 ee			ld (debug_mark),a  
047c 3a 8b 04			ld a, (.dmark+1)  
047f 32 72 ee			ld (debug_mark+1),a  
0482 3a 8c 04			ld a, (.dmark+2)  
0485 32 73 ee			ld (debug_mark+2),a  
0488 18 03			jr .pastdmark  
048a ..			.dmark: db "LB3"  
048d f1			.pastdmark: pop af  
048e			endm  
# End of macro DMARK
048e					CALLMONITOR 
048e cd a8 15			call break_point_state  
0491				endm  
# End of macro CALLMONITOR
0491				endif 
0491 ed b0			ldir 
0493				; save default page 0 
0493			 
0493 21 00 00			ld hl, 0 
0496 11 84 ea			ld de, store_page 
0499				if DEBUG_STORESE 
0499					DMARK "LBW" 
0499 f5				push af  
049a 3a ae 04			ld a, (.dmark)  
049d 32 71 ee			ld (debug_mark),a  
04a0 3a af 04			ld a, (.dmark+1)  
04a3 32 72 ee			ld (debug_mark+1),a  
04a6 3a b0 04			ld a, (.dmark+2)  
04a9 32 73 ee			ld (debug_mark+2),a  
04ac 18 03			jr .pastdmark  
04ae ..			.dmark: db "LBW"  
04b1 f1			.pastdmark: pop af  
04b2			endm  
# End of macro DMARK
04b2					CALLMONITOR 
04b2 cd a8 15			call break_point_state  
04b5				endm  
# End of macro CALLMONITOR
04b5				endif 
04b5 cd de 02			call storage_write_block 
04b8			 
04b8 c9				ret 
04b9			 
04b9			 
04b9			 
04b9			; Read Block 0 - Config 
04b9			; --------------------- 
04b9			; 
04b9			; With current bank 
04b9			; Call presence test 
04b9			;    If not present format/init bank  
04b9			; Read block 0  
04b9			;  
04b9			 
04b9			 
04b9			; Dir 
04b9			; --- 
04b9			; 
04b9			; With current bank 
04b9			; Load Block 0 Config 
04b9			; Get max file id number 
04b9			; For each logical block 
04b9			;    Read block read byte 2 
04b9			;      if first block of file 
04b9			;         Display file name 
04b9			;         Display type flags for file 
04b9			;        
04b9			 
04b9			; moving to words as this requires stack control 
04b9			 
04b9			 
04b9			; Delete File 
04b9			; ----------- 
04b9			; 
04b9			; With current bank 
04b9			; 
04b9			; Load Block 0 Config 
04b9			; Get max file id number 
04b9			; For each logical block 
04b9			;    Read block file id 
04b9			;      If first block of file and dont have file id 
04b9			;         if file to delete 
04b9			;         Save file id 
04b9			;         Null file id 
04b9			;         Write this block back 
04b9			;      If file id is one saved 
04b9			;         Null file id 
04b9			;         Write this block back 
04b9			 
04b9			 
04b9			.se_done: 
04b9 e1				pop hl 
04ba c9				ret 
04bb			 
04bb			storage_erase: 
04bb			 
04bb				; hl contains the file id 
04bb			 
04bb 5d				ld e, l 
04bc 16 00			ld d, 0 
04be 21 40 00			ld hl, STORE_BLOCK_PHY 
04c1					if DEBUG_FORTH_WORDS 
04c1						DMARK "ERA" 
04c1 f5				push af  
04c2 3a d6 04			ld a, (.dmark)  
04c5 32 71 ee			ld (debug_mark),a  
04c8 3a d7 04			ld a, (.dmark+1)  
04cb 32 72 ee			ld (debug_mark+1),a  
04ce 3a d8 04			ld a, (.dmark+2)  
04d1 32 73 ee			ld (debug_mark+2),a  
04d4 18 03			jr .pastdmark  
04d6 ..			.dmark: db "ERA"  
04d9 f1			.pastdmark: pop af  
04da			endm  
# End of macro DMARK
04da						CALLMONITOR 
04da cd a8 15			call break_point_state  
04dd				endm  
# End of macro CALLMONITOR
04dd					endif 
04dd cd ac 05			call storage_findnextid 
04e0 cd d0 0d			call ishlzero 
04e3 c8				ret z 
04e4			 
04e4 e5				push hl 
04e5			 
04e5				; TODO check file not found 
04e5			 
04e5 11 84 ea			ld de, store_page 
04e8 cd 79 02			call storage_read_block 
04eb			 
04eb cd d0 0d			call ishlzero 
04ee ca b9 04			jp z,.se_done 
04f1			 
04f1					if DEBUG_FORTH_WORDS 
04f1						DMARK "ER1" 
04f1 f5				push af  
04f2 3a 06 05			ld a, (.dmark)  
04f5 32 71 ee			ld (debug_mark),a  
04f8 3a 07 05			ld a, (.dmark+1)  
04fb 32 72 ee			ld (debug_mark+1),a  
04fe 3a 08 05			ld a, (.dmark+2)  
0501 32 73 ee			ld (debug_mark+2),a  
0504 18 03			jr .pastdmark  
0506 ..			.dmark: db "ER1"  
0509 f1			.pastdmark: pop af  
050a			endm  
# End of macro DMARK
050a						CALLMONITOR 
050a cd a8 15			call break_point_state  
050d				endm  
# End of macro CALLMONITOR
050d					endif 
050d 3a 84 ea			ld a, (store_page)	; get file id 
0510 32 78 ea			ld (store_tmpid), a 
0513			 
0513 3a 86 ea			ld a, (store_page+2)    ; get count of extends 
0516 32 77 ea			ld (store_tmpext), a 
0519			 
0519				; wipe file header 
0519			 
0519 e1				pop hl 
051a 3e 00			ld a, 0 
051c 32 84 ea			ld (store_page), a 
051f 32 85 ea			ld (store_page+1),a 
0522 11 84 ea			ld de, store_page 
0525					if DEBUG_FORTH_WORDS 
0525						DMARK "ER2" 
0525 f5				push af  
0526 3a 3a 05			ld a, (.dmark)  
0529 32 71 ee			ld (debug_mark),a  
052c 3a 3b 05			ld a, (.dmark+1)  
052f 32 72 ee			ld (debug_mark+1),a  
0532 3a 3c 05			ld a, (.dmark+2)  
0535 32 73 ee			ld (debug_mark+2),a  
0538 18 03			jr .pastdmark  
053a ..			.dmark: db "ER2"  
053d f1			.pastdmark: pop af  
053e			endm  
# End of macro DMARK
053e						CALLMONITOR 
053e cd a8 15			call break_point_state  
0541				endm  
# End of macro CALLMONITOR
0541					endif 
0541 cd de 02			call storage_write_block 
0544			 
0544			 
0544				; wipe file extents 
0544			 
0544 3a 77 ea			ld a, (store_tmpext) 
0547 47				ld b, a 
0548			 
0548			.eraext:	  
0548 c5				push bc 
0549			 
0549 21 40 00			ld hl, STORE_BLOCK_PHY 
054c 3a 78 ea			ld a,(store_tmpid) 
054f 5f				ld e, a 
0550 50				ld d, b	 
0551					if DEBUG_FORTH_WORDS 
0551						DMARK "ER3" 
0551 f5				push af  
0552 3a 66 05			ld a, (.dmark)  
0555 32 71 ee			ld (debug_mark),a  
0558 3a 67 05			ld a, (.dmark+1)  
055b 32 72 ee			ld (debug_mark+1),a  
055e 3a 68 05			ld a, (.dmark+2)  
0561 32 73 ee			ld (debug_mark+2),a  
0564 18 03			jr .pastdmark  
0566 ..			.dmark: db "ER3"  
0569 f1			.pastdmark: pop af  
056a			endm  
# End of macro DMARK
056a						CALLMONITOR 
056a cd a8 15			call break_point_state  
056d				endm  
# End of macro CALLMONITOR
056d					endif 
056d cd ac 05			call storage_findnextid 
0570 cd d0 0d			call ishlzero 
0573 ca b9 04			jp z,.se_done 
0576			 
0576 e5				push hl 
0577 11 84 ea			ld de, store_page 
057a cd 79 02			call storage_read_block 
057d			 
057d				; free block	 
057d			 
057d 3e 00			ld a, 0 
057f 32 84 ea			ld (store_page), a 
0582 32 85 ea			ld (store_page+1),a 
0585 11 84 ea			ld de, store_page 
0588 e1				pop hl 
0589					if DEBUG_FORTH_WORDS 
0589						DMARK "ER4" 
0589 f5				push af  
058a 3a 9e 05			ld a, (.dmark)  
058d 32 71 ee			ld (debug_mark),a  
0590 3a 9f 05			ld a, (.dmark+1)  
0593 32 72 ee			ld (debug_mark+1),a  
0596 3a a0 05			ld a, (.dmark+2)  
0599 32 73 ee			ld (debug_mark+2),a  
059c 18 03			jr .pastdmark  
059e ..			.dmark: db "ER4"  
05a1 f1			.pastdmark: pop af  
05a2			endm  
# End of macro DMARK
05a2						CALLMONITOR 
05a2 cd a8 15			call break_point_state  
05a5				endm  
# End of macro CALLMONITOR
05a5					endif 
05a5 cd de 02			call storage_write_block 
05a8			 
05a8 c1				pop bc 
05a9 10 9d			djnz .eraext 
05ab			 
05ab c9				ret 
05ac			 
05ac			 
05ac			; Find Free Block 
05ac			; --------------- 
05ac			; 
05ac			; With current bank 
05ac			;  
05ac			; From given starting logical block 
05ac			;    Read block  
05ac			;    If no file id 
05ac			;         Return block id 
05ac			 
05ac			 
05ac			; hl starting page number 
05ac			; hl contains free page number or zero if no pages free 
05ac			; e contains the file id to locate 
05ac			; d contains the block number 
05ac			 
05ac			; TODO change to find file id and use zero for free block 
05ac			 
05ac			storage_findnextid: 
05ac			 
05ac				; now locate first 0 page to mark as a free block 
05ac			 
05ac 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05ae			;	ld hl, STORE_BLOCK_PHY 
05ae			 
05ae					if DEBUG_FORTH_WORDS 
05ae					DMARK "FNI" 
05ae f5				push af  
05af 3a c3 05			ld a, (.dmark)  
05b2 32 71 ee			ld (debug_mark),a  
05b5 3a c4 05			ld a, (.dmark+1)  
05b8 32 72 ee			ld (debug_mark+1),a  
05bb 3a c5 05			ld a, (.dmark+2)  
05be 32 73 ee			ld (debug_mark+2),a  
05c1 18 03			jr .pastdmark  
05c3 ..			.dmark: db "FNI"  
05c6 f1			.pastdmark: pop af  
05c7			endm  
# End of macro DMARK
05c7						CALLMONITOR 
05c7 cd a8 15			call break_point_state  
05ca				endm  
# End of macro CALLMONITOR
05ca					endif 
05ca			.ff1:   	 
05ca e5					push hl 
05cb c5					push bc 
05cc d5					push de 
05cd cd 9d 01				call se_readbyte 
05d0 5f					ld e,a 
05d1 23					inc hl 
05d2 cd 9d 01				call se_readbyte 
05d5 57					ld d, a 
05d6 e1					pop hl 
05d7 e5					push hl 
05d8 cd c5 0d				call cmp16 
05db 28 49				jr z, .fffound 
05dd			 
05dd d1					pop de 
05de c1					pop bc 
05df e1					pop hl 
05e0			 
05e0					; is found? 
05e0					;cp e 
05e0					;ret z 
05e0			 
05e0 3e 40				ld a, STORE_BLOCK_PHY 
05e2 cd a7 0d				call addatohl 
05e5 10 e3				djnz .ff1 
05e7			 
05e7 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05e9			.ff2:   	 
05e9			 
05e9 e5					push hl 
05ea c5					push bc 
05eb d5					push de 
05ec cd 9d 01				call se_readbyte 
05ef 5f					ld e,a 
05f0 23					inc hl 
05f1 cd 9d 01				call se_readbyte 
05f4 57					ld d, a 
05f5			 
05f5 e1					pop hl 
05f6 e5					push hl 
05f7 cd c5 0d				call cmp16 
05fa 28 2a				jr z, .fffound 
05fc			 
05fc d1					pop de 
05fd c1					pop bc 
05fe e1					pop hl 
05ff					; is found? 
05ff					;cp e 
05ff					;ret z 
05ff			 
05ff 3e 40				ld a, STORE_BLOCK_PHY 
0601 cd a7 0d				call addatohl 
0604 10 e3				djnz .ff2 
0606			 
0606			 
0606					if DEBUG_FORTH_WORDS 
0606					DMARK "FN-" 
0606 f5				push af  
0607 3a 1b 06			ld a, (.dmark)  
060a 32 71 ee			ld (debug_mark),a  
060d 3a 1c 06			ld a, (.dmark+1)  
0610 32 72 ee			ld (debug_mark+1),a  
0613 3a 1d 06			ld a, (.dmark+2)  
0616 32 73 ee			ld (debug_mark+2),a  
0619 18 03			jr .pastdmark  
061b ..			.dmark: db "FN-"  
061e f1			.pastdmark: pop af  
061f			endm  
# End of macro DMARK
061f					;	push af 
061f					;	ld a, 'n' 
061f					;	ld (debug_mark),a 
061f					;	pop af 
061f						CALLMONITOR 
061f cd a8 15			call break_point_state  
0622				endm  
# End of macro CALLMONITOR
0622					endif 
0622				; no free marks! 
0622 21 00 00				ld hl, 0 
0625 c9				ret 
0626			.fffound: 
0626				 
0626			 
0626 d1					pop de 
0627 c1					pop bc 
0628 e1					pop hl 
0629					if DEBUG_FORTH_WORDS 
0629					DMARK "FNF" 
0629 f5				push af  
062a 3a 3e 06			ld a, (.dmark)  
062d 32 71 ee			ld (debug_mark),a  
0630 3a 3f 06			ld a, (.dmark+1)  
0633 32 72 ee			ld (debug_mark+1),a  
0636 3a 40 06			ld a, (.dmark+2)  
0639 32 73 ee			ld (debug_mark+2),a  
063c 18 03			jr .pastdmark  
063e ..			.dmark: db "FNF"  
0641 f1			.pastdmark: pop af  
0642			endm  
# End of macro DMARK
0642					;	push af 
0642					;	ld a, 'n' 
0642					;	ld (debug_mark),a 
0642					;	pop af 
0642						CALLMONITOR 
0642 cd a8 15			call break_point_state  
0645				endm  
# End of macro CALLMONITOR
0645					endif 
0645 c9				ret 
0646			 
0646			 
0646			 
0646			; Free Space 
0646			; ---------- 
0646			; 
0646			; With current bank 
0646			; 
0646			; Set block count to zero 
0646			; Starting with first logical block 
0646			;      Find free block  
0646			;      If block id given, increment block count 
0646			; 
0646			;  
0646			 
0646			 
0646			; hl contains count of free blocks 
0646			 
0646			storage_freeblocks: 
0646			 
0646				; now locate first 0 page to mark as a free block 
0646			 
0646 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0648 21 40 00			ld hl, STORE_BLOCK_PHY 
064b 11 00 00			ld de, 0 
064e			 
064e			.fb1:   	 
064e e5					push hl 
064f c5					push bc 
0650 d5					push de 
0651 cd 9d 01				call se_readbyte 
0654 d1					pop de 
0655 c1					pop bc 
0656 e1					pop hl 
0657			 
0657					; is free? 
0657 fe 00				cp 0 
0659 20 01				jr nz, .ff1cont 
065b 13					inc de 
065c			 
065c			.ff1cont: 
065c			 
065c			 
065c 3e 40				ld a, STORE_BLOCK_PHY 
065e cd a7 0d				call addatohl 
0661 10 eb				djnz .fb1 
0663			 
0663 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0665			.fb2:   	 
0665 e5					push hl 
0666 c5					push bc 
0667 d5					push de 
0668 cd 9d 01				call se_readbyte 
066b d1					pop de 
066c c1					pop bc 
066d e1					pop hl 
066e			 
066e					; is free? 
066e fe 00				cp 0 
0670 20 01				jr nz, .ff2cont 
0672 13					inc de 
0673			 
0673			.ff2cont: 
0673			 
0673 3e 40				ld a, STORE_BLOCK_PHY 
0675 cd a7 0d				call addatohl 
0678 10 eb				djnz .fb2 
067a			 
067a eb				ex de, hl 
067b c9				ret 
067c			 
067c			; Get File ID 
067c			; ----------- 
067c			; 
067c			; With current bank 
067c			;  
067c			; Load Block 0 Config 
067c			; Get max file id number 
067c			; For each logical block 
067c			;    Read block file id 
067c			;      If first block of file and dont have file id 
067c			;         if file get id and exit 
067c			 
067c			 
067c			 
067c			 
067c			; Create File 
067c			; ----------- 
067c			; 
067c			; With current bank  
067c			; Load Block 0 Config 
067c			; Get max file id number 
067c			; Increment file id number 
067c			; Save Config 
067c			; Find free block 
067c			; Set buffer with file name and file id 
067c			; Write buffer to free block  
067c			 
067c			 
067c			; hl point to file name 
067c			; hl returns file id 
067c			 
067c			; file format: 
067c			; byte 0 - file id 
067c			; byte 1 - extent number 
067c			; byte 2-> data 
067c			 
067c			; format for extent number 0: 
067c			; 
067c			; byte 0 - file id 
067c			; byte 1 - extent 0 
067c			; byte 2 - extent count 
067c			; byte 3 -> file name and meta data 
067c			 
067c			 
067c			storage_create: 
067c				if DEBUG_STORESE 
067c					DMARK "SCR" 
067c f5				push af  
067d 3a 91 06			ld a, (.dmark)  
0680 32 71 ee			ld (debug_mark),a  
0683 3a 92 06			ld a, (.dmark+1)  
0686 32 72 ee			ld (debug_mark+1),a  
0689 3a 93 06			ld a, (.dmark+2)  
068c 32 73 ee			ld (debug_mark+2),a  
068f 18 03			jr .pastdmark  
0691 ..			.dmark: db "SCR"  
0694 f1			.pastdmark: pop af  
0695			endm  
# End of macro DMARK
0695					CALLMONITOR 
0695 cd a8 15			call break_point_state  
0698				endm  
# End of macro CALLMONITOR
0698				endif 
0698			 
0698 e5				push hl		; save file name pointer 
0699			 
0699 cd 2a 03			call storage_get_block_0 
069c			 
069c 3a 84 ea			ld a,(store_page)	; get current file id 
069f 3c				inc a 
06a0 32 84 ea			ld (store_page),a 
06a3				 
06a3 32 78 ea			ld (store_tmpid),a			; save id 
06a6			 
06a6 21 00 00			ld hl, 0 
06a9 11 84 ea			ld de, store_page 
06ac				if DEBUG_STORESE 
06ac					DMARK "SCw" 
06ac f5				push af  
06ad 3a c1 06			ld a, (.dmark)  
06b0 32 71 ee			ld (debug_mark),a  
06b3 3a c2 06			ld a, (.dmark+1)  
06b6 32 72 ee			ld (debug_mark+1),a  
06b9 3a c3 06			ld a, (.dmark+2)  
06bc 32 73 ee			ld (debug_mark+2),a  
06bf 18 03			jr .pastdmark  
06c1 ..			.dmark: db "SCw"  
06c4 f1			.pastdmark: pop af  
06c5			endm  
# End of macro DMARK
06c5					CALLMONITOR 
06c5 cd a8 15			call break_point_state  
06c8				endm  
# End of macro CALLMONITOR
06c8				endif 
06c8 cd de 02			call storage_write_block	 ; save update 
06cb			 
06cb				if DEBUG_STORESE 
06cb 11 84 ea				ld de, store_page 
06ce					DMARK "SCC" 
06ce f5				push af  
06cf 3a e3 06			ld a, (.dmark)  
06d2 32 71 ee			ld (debug_mark),a  
06d5 3a e4 06			ld a, (.dmark+1)  
06d8 32 72 ee			ld (debug_mark+1),a  
06db 3a e5 06			ld a, (.dmark+2)  
06de 32 73 ee			ld (debug_mark+2),a  
06e1 18 03			jr .pastdmark  
06e3 ..			.dmark: db "SCC"  
06e6 f1			.pastdmark: pop af  
06e7			endm  
# End of macro DMARK
06e7					CALLMONITOR 
06e7 cd a8 15			call break_point_state  
06ea				endm  
# End of macro CALLMONITOR
06ea				endif 
06ea				;  
06ea				 
06ea 21 40 00			ld hl, STORE_BLOCK_PHY 
06ed 11 00 00			ld de, 0 
06f0 cd ac 05			call storage_findnextid 
06f3			 
06f3 22 71 ea			ld (store_tmppageid), hl    ; save page to use  
06f6			 
06f6				; TODO detect 0 = no spare blocks 
06f6			 
06f6				; hl now contains the free page to use for the file header page 
06f6			 
06f6				if DEBUG_STORESE 
06f6				DMARK "SCF" 
06f6 f5				push af  
06f7 3a 0b 07			ld a, (.dmark)  
06fa 32 71 ee			ld (debug_mark),a  
06fd 3a 0c 07			ld a, (.dmark+1)  
0700 32 72 ee			ld (debug_mark+1),a  
0703 3a 0d 07			ld a, (.dmark+2)  
0706 32 73 ee			ld (debug_mark+2),a  
0709 18 03			jr .pastdmark  
070b ..			.dmark: db "SCF"  
070e f1			.pastdmark: pop af  
070f			endm  
# End of macro DMARK
070f					CALLMONITOR 
070f cd a8 15			call break_point_state  
0712				endm  
# End of macro CALLMONITOR
0712				endif 
0712			 
0712 22 71 ea			ld (store_tmppageid), hl 
0715				 
0715 3a 78 ea			ld a,(store_tmpid)    ; get file id 
0718			;	ld a, (store_filecache)			; save to cache 
0718			 
0718 32 84 ea			ld (store_page),a    ; set page id 
071b 3e 00			ld a, 0			 ; extent 0 is file header 
071d 32 85 ea			ld (store_page+1), a   ; set file extent 
0720			 
0720 32 86 ea			ld (store_page+2), a   ; extent count for the file 
0723			 
0723			;	inc hl 		; init block 0 of file 
0723			;	inc hl   		; skip file and extent id 
0723			 ;       ld a, 0 
0723			;	ld (hl),a 
0723			;	ld a, (store_filecache+1)  	; save to cache 
0723			 
0723			;	inc hl    ; file name 
0723				 
0723				 
0723 11 87 ea			ld de, store_page+3    ; get buffer for term string to use as file name 
0726				if DEBUG_STORESE 
0726					DMARK "SCc" 
0726 f5				push af  
0727 3a 3b 07			ld a, (.dmark)  
072a 32 71 ee			ld (debug_mark),a  
072d 3a 3c 07			ld a, (.dmark+1)  
0730 32 72 ee			ld (debug_mark+1),a  
0733 3a 3d 07			ld a, (.dmark+2)  
0736 32 73 ee			ld (debug_mark+2),a  
0739 18 03			jr .pastdmark  
073b ..			.dmark: db "SCc"  
073e f1			.pastdmark: pop af  
073f			endm  
# End of macro DMARK
073f					CALLMONITOR 
073f cd a8 15			call break_point_state  
0742				endm  
# End of macro CALLMONITOR
0742				endif 
0742 e1				pop hl    ; get zero term string 
0743 e5				push hl 
0744 3e 00			ld a, 0 
0746 cd 10 12			call strlent 
0749 23				inc hl   ; cover zero term 
074a 06 00			ld b,0 
074c 4d				ld c,l 
074d e1				pop hl 
074e				;ex de, hl 
074e				if DEBUG_STORESE 
074e					DMARK "SCa" 
074e f5				push af  
074f 3a 63 07			ld a, (.dmark)  
0752 32 71 ee			ld (debug_mark),a  
0755 3a 64 07			ld a, (.dmark+1)  
0758 32 72 ee			ld (debug_mark+1),a  
075b 3a 65 07			ld a, (.dmark+2)  
075e 32 73 ee			ld (debug_mark+2),a  
0761 18 03			jr .pastdmark  
0763 ..			.dmark: db "SCa"  
0766 f1			.pastdmark: pop af  
0767			endm  
# End of macro DMARK
0767					;push af 
0767					;ld a, 'a' 
0767					;ld (debug_mark),a 
0767					;pop af 
0767					CALLMONITOR 
0767 cd a8 15			call break_point_state  
076a				endm  
# End of macro CALLMONITOR
076a				endif 
076a ed b0			ldir    ; copy zero term string 
076c				if DEBUG_STORESE 
076c					DMARK "SCA" 
076c f5				push af  
076d 3a 81 07			ld a, (.dmark)  
0770 32 71 ee			ld (debug_mark),a  
0773 3a 82 07			ld a, (.dmark+1)  
0776 32 72 ee			ld (debug_mark+1),a  
0779 3a 83 07			ld a, (.dmark+2)  
077c 32 73 ee			ld (debug_mark+2),a  
077f 18 03			jr .pastdmark  
0781 ..			.dmark: db "SCA"  
0784 f1			.pastdmark: pop af  
0785			endm  
# End of macro DMARK
0785					CALLMONITOR 
0785 cd a8 15			call break_point_state  
0788				endm  
# End of macro CALLMONITOR
0788				endif 
0788			 
0788				; write file header page 
0788			 
0788 2a 71 ea			ld hl,(store_tmppageid) 
078b 11 84 ea			ld de, store_page 
078e				if DEBUG_STORESE 
078e					DMARK "SCb" 
078e f5				push af  
078f 3a a3 07			ld a, (.dmark)  
0792 32 71 ee			ld (debug_mark),a  
0795 3a a4 07			ld a, (.dmark+1)  
0798 32 72 ee			ld (debug_mark+1),a  
079b 3a a5 07			ld a, (.dmark+2)  
079e 32 73 ee			ld (debug_mark+2),a  
07a1 18 03			jr .pastdmark  
07a3 ..			.dmark: db "SCb"  
07a6 f1			.pastdmark: pop af  
07a7			endm  
# End of macro DMARK
07a7					;push af 
07a7					;ld a, 'b' 
07a7					;ld (debug_mark),a 
07a7					;pop af 
07a7					CALLMONITOR 
07a7 cd a8 15			call break_point_state  
07aa				endm  
# End of macro CALLMONITOR
07aa				endif 
07aa cd de 02			call storage_write_block 
07ad			 
07ad 3a 78 ea			ld a, (store_tmpid) 
07b0 6f				ld l, a 
07b1 26 00			ld h,0 
07b3				if DEBUG_STORESE 
07b3					DMARK "SCz" 
07b3 f5				push af  
07b4 3a c8 07			ld a, (.dmark)  
07b7 32 71 ee			ld (debug_mark),a  
07ba 3a c9 07			ld a, (.dmark+1)  
07bd 32 72 ee			ld (debug_mark+1),a  
07c0 3a ca 07			ld a, (.dmark+2)  
07c3 32 73 ee			ld (debug_mark+2),a  
07c6 18 03			jr .pastdmark  
07c8 ..			.dmark: db "SCz"  
07cb f1			.pastdmark: pop af  
07cc			endm  
# End of macro DMARK
07cc					CALLMONITOR 
07cc cd a8 15			call break_point_state  
07cf				endm  
# End of macro CALLMONITOR
07cf				endif 
07cf c9				ret 
07d0				 
07d0			 
07d0			 
07d0			; 
07d0			; Read File 
07d0			; 
07d0			; h - file id to locate 
07d0			; l - extent to locate 
07d0			; de - pointer to string to read into 
07d0			; 
07d0			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
07d0			 
07d0			.sr_fail: 
07d0 d1				pop de 
07d1 c9				ret 
07d2			 
07d2			storage_read: 
07d2			 
07d2			 
07d2 d5				push de 
07d3			 
07d3			; TODO BUG the above push is it popped before the RET Z? 
07d3			 
07d3			; TODO how to handle multiple part blocks 
07d3			 
07d3				; locate file extent to read 
07d3			 
07d3 5c				ld e, h 
07d4 55				ld d, l 
07d5			 
07d5			.srext: 
07d5 22 82 ea			ld (store_readptr), hl     ; save the current extent to load 
07d8 ed 53 80 ea		ld (store_readbuf), de     ; save the current buffer to load in to 
07dc			 
07dc 21 40 00			ld hl, STORE_BLOCK_PHY 
07df				if DEBUG_STORESE 
07df					DMARK "sre" 
07df f5				push af  
07e0 3a f4 07			ld a, (.dmark)  
07e3 32 71 ee			ld (debug_mark),a  
07e6 3a f5 07			ld a, (.dmark+1)  
07e9 32 72 ee			ld (debug_mark+1),a  
07ec 3a f6 07			ld a, (.dmark+2)  
07ef 32 73 ee			ld (debug_mark+2),a  
07f2 18 03			jr .pastdmark  
07f4 ..			.dmark: db "sre"  
07f7 f1			.pastdmark: pop af  
07f8			endm  
# End of macro DMARK
07f8					CALLMONITOR 
07f8 cd a8 15			call break_point_state  
07fb				endm  
# End of macro CALLMONITOR
07fb				endif 
07fb cd ac 05			call storage_findnextid 
07fe			 
07fe				if DEBUG_STORESE 
07fe					DMARK "srf" 
07fe f5				push af  
07ff 3a 13 08			ld a, (.dmark)  
0802 32 71 ee			ld (debug_mark),a  
0805 3a 14 08			ld a, (.dmark+1)  
0808 32 72 ee			ld (debug_mark+1),a  
080b 3a 15 08			ld a, (.dmark+2)  
080e 32 73 ee			ld (debug_mark+2),a  
0811 18 03			jr .pastdmark  
0813 ..			.dmark: db "srf"  
0816 f1			.pastdmark: pop af  
0817			endm  
# End of macro DMARK
0817					CALLMONITOR 
0817 cd a8 15			call break_point_state  
081a				endm  
# End of macro CALLMONITOR
081a				endif 
081a cd d0 0d			call ishlzero 
081d			;	ld a, l 
081d			;	add h 
081d			;	cp 0 
081d 28 b1			jr z,.sr_fail			; block not found so EOF 
081f			 
081f				; hl contains page number to load 
081f d1				pop de   ; get storage 
0820 ed 53 80 ea		ld (store_readbuf), de     ; current buffer to load in to 
0824 d5				push de 
0825				if DEBUG_STORESE 
0825					DMARK "srg" 
0825 f5				push af  
0826 3a 3a 08			ld a, (.dmark)  
0829 32 71 ee			ld (debug_mark),a  
082c 3a 3b 08			ld a, (.dmark+1)  
082f 32 72 ee			ld (debug_mark+1),a  
0832 3a 3c 08			ld a, (.dmark+2)  
0835 32 73 ee			ld (debug_mark+2),a  
0838 18 03			jr .pastdmark  
083a ..			.dmark: db "srg"  
083d f1			.pastdmark: pop af  
083e			endm  
# End of macro DMARK
083e					CALLMONITOR 
083e cd a8 15			call break_point_state  
0841				endm  
# End of macro CALLMONITOR
0841				endif 
0841 cd 79 02			call storage_read_block 
0844			 
0844				; if this a continuation read??? 
0844			 
0844 2a 80 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
0847			 
0847 3e 3f			ld a, STORE_BLOCK_PHY-1 
0849 cd a7 0d			call addatohl 
084c 7e				ld a,(hl) 
084d fe 00			cp 0 
084f 28 02			jr z, .markiscont 
0851 3e ff			ld a, 255 
0853			 
0853			.markiscont: 
0853 32 77 ea			ld (store_readcont), a 
0856			 
0856				if DEBUG_STORESE 
0856					DMARK "srC" 
0856 f5				push af  
0857 3a 6b 08			ld a, (.dmark)  
085a 32 71 ee			ld (debug_mark),a  
085d 3a 6c 08			ld a, (.dmark+1)  
0860 32 72 ee			ld (debug_mark+1),a  
0863 3a 6d 08			ld a, (.dmark+2)  
0866 32 73 ee			ld (debug_mark+2),a  
0869 18 03			jr .pastdmark  
086b ..			.dmark: db "srC"  
086e f1			.pastdmark: pop af  
086f			endm  
# End of macro DMARK
086f					CALLMONITOR 
086f cd a8 15			call break_point_state  
0872				endm  
# End of macro CALLMONITOR
0872				endif 
0872				; only short reads enabled 
0872			 
0872 3a 7f ea			ld a, (store_longread) 
0875 fe 00			cp 0 
0877 ca 41 09			jp z, .readdone 
087a			 
087a			; TODO if block has no zeros then need to read next block  
087a			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
087a			; check last byte of physical block. 
087a			; if not zero then the next block needs to be loaded 
087a			 
087a			 
087a 2a 80 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
087d			 
087d 3e 3f			ld a, STORE_BLOCK_PHY-1 
087f cd a7 0d			call addatohl 
0882				;dec hl 
0882 7e				ld a,(hl) 
0883				if DEBUG_STORESE 
0883					DMARK "sr?" 
0883 f5				push af  
0884 3a 98 08			ld a, (.dmark)  
0887 32 71 ee			ld (debug_mark),a  
088a 3a 99 08			ld a, (.dmark+1)  
088d 32 72 ee			ld (debug_mark+1),a  
0890 3a 9a 08			ld a, (.dmark+2)  
0893 32 73 ee			ld (debug_mark+2),a  
0896 18 03			jr .pastdmark  
0898 ..			.dmark: db "sr?"  
089b f1			.pastdmark: pop af  
089c			endm  
# End of macro DMARK
089c					CALLMONITOR 
089c cd a8 15			call break_point_state  
089f				endm  
# End of macro CALLMONITOR
089f				endif 
089f fe 00			cp 0 
08a1 ca 41 09			jp z, .readdone 
08a4			 
08a4				; last byte is not zero so there is more in the next extent. Load it on the end.	 
08a4			 
08a4 23				inc hl 
08a5			 
08a5 22 80 ea			ld (store_readbuf), hl     ; save the current buffer to load in to 
08a8			 
08a8 ed 5b 82 ea		ld de, (store_readptr)     ; save the current extent to load 
08ac			 
08ac eb				ex de, hl 
08ad			 
08ad				; next ext 
08ad			 
08ad 23				inc hl 
08ae 22 82 ea			ld  (store_readptr), hl     ; save the current extent to load 
08b1			 
08b1				if DEBUG_STORESE 
08b1					DMARK "sF2" 
08b1 f5				push af  
08b2 3a c6 08			ld a, (.dmark)  
08b5 32 71 ee			ld (debug_mark),a  
08b8 3a c7 08			ld a, (.dmark+1)  
08bb 32 72 ee			ld (debug_mark+1),a  
08be 3a c8 08			ld a, (.dmark+2)  
08c1 32 73 ee			ld (debug_mark+2),a  
08c4 18 03			jr .pastdmark  
08c6 ..			.dmark: db "sF2"  
08c9 f1			.pastdmark: pop af  
08ca			endm  
# End of macro DMARK
08ca					CALLMONITOR 
08ca cd a8 15			call break_point_state  
08cd				endm  
# End of macro CALLMONITOR
08cd				endif 
08cd			 
08cd				; get and load block 
08cd			 
08cd cd ac 05			call storage_findnextid 
08d0			 
08d0				if DEBUG_STORESE 
08d0					DMARK "sf2" 
08d0 f5				push af  
08d1 3a e5 08			ld a, (.dmark)  
08d4 32 71 ee			ld (debug_mark),a  
08d7 3a e6 08			ld a, (.dmark+1)  
08da 32 72 ee			ld (debug_mark+1),a  
08dd 3a e7 08			ld a, (.dmark+2)  
08e0 32 73 ee			ld (debug_mark+2),a  
08e3 18 03			jr .pastdmark  
08e5 ..			.dmark: db "sf2"  
08e8 f1			.pastdmark: pop af  
08e9			endm  
# End of macro DMARK
08e9					CALLMONITOR 
08e9 cd a8 15			call break_point_state  
08ec				endm  
# End of macro CALLMONITOR
08ec				endif 
08ec cd d0 0d			call ishlzero 
08ef			;	ld a, l 
08ef			;	add h 
08ef			;	cp 0 
08ef ca d0 07			jp z,.sr_fail			; block not found so EOF 
08f2				 
08f2 cd 79 02			call storage_read_block 
08f5			 
08f5				; on a continuation block, we now have the file id and ext in the middle of the block 
08f5				; we need to pull everything back  
08f5			 
08f5 ed 5b 80 ea		ld de, (store_readbuf)     ; current buffer to nudge into 
08f9 2a 80 ea			ld hl, (store_readbuf)     ; current buffer where data actually exists 
08fc 23				inc hl 
08fd 23				inc hl     ; skip id and ext 
08fe 01 40 00			ld bc, STORE_BLOCK_PHY 
0901				if DEBUG_STORESE 
0901					DMARK "SR<" 
0901 f5				push af  
0902 3a 16 09			ld a, (.dmark)  
0905 32 71 ee			ld (debug_mark),a  
0908 3a 17 09			ld a, (.dmark+1)  
090b 32 72 ee			ld (debug_mark+1),a  
090e 3a 18 09			ld a, (.dmark+2)  
0911 32 73 ee			ld (debug_mark+2),a  
0914 18 03			jr .pastdmark  
0916 ..			.dmark: db "SR<"  
0919 f1			.pastdmark: pop af  
091a			endm  
# End of macro DMARK
091a					CALLMONITOR 
091a cd a8 15			call break_point_state  
091d				endm  
# End of macro CALLMONITOR
091d				endif 
091d ed b0			ldir     ; copy data 
091f			 
091f				; move the pointer back and pretend we have a full buffer for next recheck 
091f			 
091f 1b				dec de 
0920 1b				dec de 
0921			 
0921			; TODO do pop below now short circuit loop????? 
0921 c1				pop bc     ; get rid of spare de on stack 
0922				if DEBUG_STORESE 
0922					DMARK "SR>" 
0922 f5				push af  
0923 3a 37 09			ld a, (.dmark)  
0926 32 71 ee			ld (debug_mark),a  
0929 3a 38 09			ld a, (.dmark+1)  
092c 32 72 ee			ld (debug_mark+1),a  
092f 3a 39 09			ld a, (.dmark+2)  
0932 32 73 ee			ld (debug_mark+2),a  
0935 18 03			jr .pastdmark  
0937 ..			.dmark: db "SR>"  
093a f1			.pastdmark: pop af  
093b			endm  
# End of macro DMARK
093b					CALLMONITOR 
093b cd a8 15			call break_point_state  
093e				endm  
# End of macro CALLMONITOR
093e				endif 
093e c3 d5 07			jp .srext 
0941			 
0941			 
0941			 
0941			 
0941			 
0941			.readdone:		 
0941 e1				pop hl 		 ; return start of data to show as not EOF 
0942 23				inc hl   ; past file id 
0943 23				inc hl   ; past ext 
0944				if DEBUG_STORESE 
0944					DMARK "SRe" 
0944 f5				push af  
0945 3a 59 09			ld a, (.dmark)  
0948 32 71 ee			ld (debug_mark),a  
094b 3a 5a 09			ld a, (.dmark+1)  
094e 32 72 ee			ld (debug_mark+1),a  
0951 3a 5b 09			ld a, (.dmark+2)  
0954 32 73 ee			ld (debug_mark+2),a  
0957 18 03			jr .pastdmark  
0959 ..			.dmark: db "SRe"  
095c f1			.pastdmark: pop af  
095d			endm  
# End of macro DMARK
095d					CALLMONITOR 
095d cd a8 15			call break_point_state  
0960				endm  
# End of macro CALLMONITOR
0960				endif 
0960 c9					ret 
0961			 
0961			 
0961			 
0961			; 
0961			; Append File 
0961			; 
0961			; hl - file id to locate 
0961			; de - pointer to (multi block) string to write 
0961			 
0961			.sa_notfound: 
0961 d1				pop de 
0962 c9				ret 
0963			 
0963			 
0963			storage_append: 
0963				; hl -  file id to append to 
0963				; de - string to append 
0963			 
0963 d5				push de 
0964				 
0964				if DEBUG_STORESE 
0964					DMARK "AP1" 
0964 f5				push af  
0965 3a 79 09			ld a, (.dmark)  
0968 32 71 ee			ld (debug_mark),a  
096b 3a 7a 09			ld a, (.dmark+1)  
096e 32 72 ee			ld (debug_mark+1),a  
0971 3a 7b 09			ld a, (.dmark+2)  
0974 32 73 ee			ld (debug_mark+2),a  
0977 18 03			jr .pastdmark  
0979 ..			.dmark: db "AP1"  
097c f1			.pastdmark: pop af  
097d			endm  
# End of macro DMARK
097d					CALLMONITOR 
097d cd a8 15			call break_point_state  
0980				endm  
# End of macro CALLMONITOR
0980				endif 
0980			 
0980 7d				ld a, l 
0981 32 78 ea			ld (store_tmpid), a 
0984			 
0984				; get file header  
0984			 
0984 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
0986 3a 78 ea			ld a, (store_tmpid) 
0989 5f				ld e, a 
098a			 
098a 21 40 00				ld hl, STORE_BLOCK_PHY 
098d cd ac 05				call storage_findnextid 
0990			 
0990 cd d0 0d			call ishlzero 
0993 28 cc			jr z, .sa_notfound 
0995			 
0995 22 71 ea			ld (store_tmppageid), hl 
0998			 
0998				; TODO handle file id not found 
0998			 
0998				if DEBUG_STORESE 
0998					DMARK "AP2" 
0998 f5				push af  
0999 3a ad 09			ld a, (.dmark)  
099c 32 71 ee			ld (debug_mark),a  
099f 3a ae 09			ld a, (.dmark+1)  
09a2 32 72 ee			ld (debug_mark+1),a  
09a5 3a af 09			ld a, (.dmark+2)  
09a8 32 73 ee			ld (debug_mark+2),a  
09ab 18 03			jr .pastdmark  
09ad ..			.dmark: db "AP2"  
09b0 f1			.pastdmark: pop af  
09b1			endm  
# End of macro DMARK
09b1					CALLMONITOR 
09b1 cd a8 15			call break_point_state  
09b4				endm  
# End of macro CALLMONITOR
09b4				endif 
09b4			 
09b4				; update file extent count 
09b4			 
09b4 11 84 ea			ld de, store_page 
09b7			 
09b7 cd 79 02			call storage_read_block 
09ba			 
09ba				if DEBUG_STORESE 
09ba					DMARK "AP3" 
09ba f5				push af  
09bb 3a cf 09			ld a, (.dmark)  
09be 32 71 ee			ld (debug_mark),a  
09c1 3a d0 09			ld a, (.dmark+1)  
09c4 32 72 ee			ld (debug_mark+1),a  
09c7 3a d1 09			ld a, (.dmark+2)  
09ca 32 73 ee			ld (debug_mark+2),a  
09cd 18 03			jr .pastdmark  
09cf ..			.dmark: db "AP3"  
09d2 f1			.pastdmark: pop af  
09d3			endm  
# End of macro DMARK
09d3					CALLMONITOR 
09d3 cd a8 15			call break_point_state  
09d6				endm  
# End of macro CALLMONITOR
09d6				endif 
09d6			;	ld (store_tmppageid), hl 
09d6			 
09d6 3a 86 ea			ld a, (store_page+2) 
09d9 3c				inc a 
09da 32 86 ea			ld (store_page+2), a 
09dd 32 77 ea			ld (store_tmpext), a 
09e0				 
09e0				if DEBUG_STORESE 
09e0					DMARK "AP3" 
09e0 f5				push af  
09e1 3a f5 09			ld a, (.dmark)  
09e4 32 71 ee			ld (debug_mark),a  
09e7 3a f6 09			ld a, (.dmark+1)  
09ea 32 72 ee			ld (debug_mark+1),a  
09ed 3a f7 09			ld a, (.dmark+2)  
09f0 32 73 ee			ld (debug_mark+2),a  
09f3 18 03			jr .pastdmark  
09f5 ..			.dmark: db "AP3"  
09f8 f1			.pastdmark: pop af  
09f9			endm  
# End of macro DMARK
09f9					CALLMONITOR 
09f9 cd a8 15			call break_point_state  
09fc				endm  
# End of macro CALLMONITOR
09fc				endif 
09fc 2a 71 ea			ld hl, (store_tmppageid) 
09ff 11 84 ea			ld de, store_page 
0a02 cd de 02			call storage_write_block 
0a05			 
0a05				; find free block 
0a05			 
0a05 11 00 00			ld de, 0			 ; file extent to locate 
0a08			 
0a08 21 40 00				ld hl, STORE_BLOCK_PHY 
0a0b cd ac 05				call storage_findnextid 
0a0e cd d0 0d			call ishlzero 
0a11 ca 61 09			jp z, .sa_notfound 
0a14			 
0a14					; TODO handle no space left 
0a14					 
0a14 22 71 ea				ld (store_tmppageid), hl 
0a17			 
0a17				if DEBUG_STORESE 
0a17					DMARK "AP4" 
0a17 f5				push af  
0a18 3a 2c 0a			ld a, (.dmark)  
0a1b 32 71 ee			ld (debug_mark),a  
0a1e 3a 2d 0a			ld a, (.dmark+1)  
0a21 32 72 ee			ld (debug_mark+1),a  
0a24 3a 2e 0a			ld a, (.dmark+2)  
0a27 32 73 ee			ld (debug_mark+2),a  
0a2a 18 03			jr .pastdmark  
0a2c ..			.dmark: db "AP4"  
0a2f f1			.pastdmark: pop af  
0a30			endm  
# End of macro DMARK
0a30					CALLMONITOR 
0a30 cd a8 15			call break_point_state  
0a33				endm  
# End of macro CALLMONITOR
0a33				endif 
0a33					; init the buffer with zeros so we can id if the buffer is full or not 
0a33			 
0a33 e5					push hl 
0a34 c5					push bc 
0a35			 
0a35 21 84 ea				ld hl, store_page 
0a38 06 40				ld b, STORE_BLOCK_PHY 
0a3a 3e 00				ld a, 0 
0a3c 77			.zeroblock:	ld (hl), a 
0a3d 23					inc hl 
0a3e 10 fc				djnz .zeroblock 
0a40			 
0a40 c1					pop bc 
0a41 e1					pop hl 
0a42			 
0a42					; construct block 
0a42			 
0a42 3a 78 ea				ld a, (store_tmpid) 
0a45 32 84 ea				ld (store_page), a   ; file id 
0a48 3a 77 ea				ld a, (store_tmpext)   ; extent for this block 
0a4b 32 85 ea				ld (store_page+1), a 
0a4e			 
0a4e e1					pop hl    ; get string to write 
0a4f 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0a51 11 86 ea				ld de, store_page+2 
0a54			 
0a54				if DEBUG_STORESE 
0a54					DMARK "AP5" 
0a54 f5				push af  
0a55 3a 69 0a			ld a, (.dmark)  
0a58 32 71 ee			ld (debug_mark),a  
0a5b 3a 6a 0a			ld a, (.dmark+1)  
0a5e 32 72 ee			ld (debug_mark+1),a  
0a61 3a 6b 0a			ld a, (.dmark+2)  
0a64 32 73 ee			ld (debug_mark+2),a  
0a67 18 03			jr .pastdmark  
0a69 ..			.dmark: db "AP5"  
0a6c f1			.pastdmark: pop af  
0a6d			endm  
# End of macro DMARK
0a6d					CALLMONITOR 
0a6d cd a8 15			call break_point_state  
0a70				endm  
# End of macro CALLMONITOR
0a70				endif 
0a70			 
0a70			 
0a70			 
0a70					; fill buffer with data until end of string or full block 
0a70			 
0a70 7e			.appd:		ld a, (hl) 
0a71 12					ld (de), a 
0a72 fe 00				cp 0 
0a74 28 04				jr z, .appdone 
0a76 23					inc hl 
0a77 13					inc de 
0a78 10 f6				djnz .appd 
0a7a			 
0a7a e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0a7b f5					push af   		; save last byte dumped 
0a7c			 
0a7c			 
0a7c 2a 71 ea			ld hl, (store_tmppageid) 
0a7f 11 84 ea			ld de, store_page 
0a82				if DEBUG_STORESE 
0a82					DMARK "AP6" 
0a82 f5				push af  
0a83 3a 97 0a			ld a, (.dmark)  
0a86 32 71 ee			ld (debug_mark),a  
0a89 3a 98 0a			ld a, (.dmark+1)  
0a8c 32 72 ee			ld (debug_mark+1),a  
0a8f 3a 99 0a			ld a, (.dmark+2)  
0a92 32 73 ee			ld (debug_mark+2),a  
0a95 18 03			jr .pastdmark  
0a97 ..			.dmark: db "AP6"  
0a9a f1			.pastdmark: pop af  
0a9b			endm  
# End of macro DMARK
0a9b					CALLMONITOR 
0a9b cd a8 15			call break_point_state  
0a9e				endm  
# End of macro CALLMONITOR
0a9e				endif 
0a9e cd de 02				call storage_write_block 
0aa1			 
0aa1			 
0aa1				; was that a full block of data written? 
0aa1				; any more to write out? 
0aa1			 
0aa1				; if yes then set vars and jump to start of function again 
0aa1			 
0aa1 f1					pop af 
0aa2 d1					pop de 
0aa3			 
0aa3 fe 00				cp 0		 ; no, string was fully written 
0aa5 c8					ret z 
0aa6			 
0aa6					; setup vars for next cycle 
0aa6			 
0aa6 3a 78 ea				ld a, (store_tmpid) 
0aa9 6f					ld l, a 
0aaa 26 00				ld h, 0 
0aac			 
0aac c3 63 09			 	jp storage_append	 ; yes, need to write out some more 
0aaf			 
0aaf			 
0aaf			 
0aaf			 
0aaf			 
0aaf			 
0aaf			 
0aaf			if DEBUG_STORECF 
0aaf			storageput:	 
0aaf					ret 
0aaf			storageread: 
0aaf					ld hl, store_page 
0aaf					ld b, 200 
0aaf					ld a,0 
0aaf			.src:		ld (hl),a 
0aaf					inc hl 
0aaf					djnz .src 
0aaf					 
0aaf			 
0aaf					ld de, 0 
0aaf					ld bc, 1 
0aaf					ld hl, store_page 
0aaf					call cfRead 
0aaf			 
0aaf				call cfGetError 
0aaf				ld hl,scratch 
0aaf				call hexout 
0aaf				ld hl, scratch+2 
0aaf				ld a, 0 
0aaf				ld (hl),a 
0aaf				ld de, scratch 
0aaf				ld a,display_row_1 
0aaf				call str_at_display 
0aaf				call update_display 
0aaf			 
0aaf					ld hl, store_page 
0aaf					ld (os_cur_ptr),hl 
0aaf			 
0aaf					ret 
0aaf			endif 
0aaf			 
0aaf			 
0aaf			; Clear out the main buffer store (used to remove junk before writing a new block) 
0aaf			 
0aaf			storage_clear_page: 
0aaf e5				push hl 
0ab0 d5				push de 
0ab1 c5				push bc 
0ab2 21 84 ea			ld hl, store_page 
0ab5 3e 00			ld a, 0 
0ab7 77				ld (hl), a 
0ab8			 
0ab8 11 85 ea			ld de, store_page+1 
0abb 01 18 01			ld bc, STORE_BLOCK_LOG 
0abe			 
0abe ed b0			ldir 
0ac0				 
0ac0 c1				pop bc 
0ac1 d1				pop de 
0ac2 e1				pop hl 
0ac3 c9				ret 
0ac4			 
0ac4			; eof 
# End of file firmware_storage.asm
0ac4			  
0ac4			; support routines for above hardware abstraction layer  
0ac4			  
0ac4			include "firmware_general.asm"        ; general support functions  
0ac4			 
0ac4			; word look up 
0ac4			 
0ac4			; in 
0ac4			; a is the index 
0ac4			; hl is pointer start of array 
0ac4			; 
0ac4			; returns 
0ac4			; hl to the word 
0ac4			; 
0ac4			 
0ac4			table_lookup:  
0ac4 d5					push de 
0ac5 eb					ex de, hl 
0ac6			 
0ac6 6f					ld l, a 
0ac7 26 00				ld h, 0 
0ac9 29					add hl, hl 
0aca 19					add hl, de 
0acb 7e					ld a, (hl) 
0acc 23					inc hl 
0acd 66					ld h,(hl) 
0ace 6f					ld l, a 
0acf			 
0acf d1					pop de 
0ad0 c9					ret 
0ad1			 
0ad1			; Delay loops 
0ad1			 
0ad1			 
0ad1			 
0ad1			aDelayInMS: 
0ad1 c5				push bc 
0ad2 47				ld b,a 
0ad3			msdelay: 
0ad3 c5				push bc 
0ad4				 
0ad4			 
0ad4 01 41 00			ld bc,041h 
0ad7 cd ef 0a			call delayloop 
0ada c1				pop bc 
0adb 05				dec b 
0adc 20 f5			jr nz,msdelay 
0ade			 
0ade			;if CPU_CLOCK_8MHZ 
0ade			;msdelay8: 
0ade			;	push bc 
0ade			;	 
0ade			; 
0ade			;	ld bc,041h 
0ade			;	call delayloop 
0ade			;	pop bc 
0ade			;	dec b 
0ade			;	jr nz,msdelay8 
0ade			;endif 
0ade			 
0ade			 
0ade c1				pop bc 
0adf c9				ret 
0ae0			 
0ae0			 
0ae0			delay250ms: 
0ae0				;push de 
0ae0 01 00 40			ld bc, 04000h 
0ae3 c3 ef 0a			jp delayloop 
0ae6			delay500ms: 
0ae6				;push de 
0ae6 01 00 80			ld bc, 08000h 
0ae9 c3 ef 0a			jp delayloop 
0aec			delay1s: 
0aec				;push bc 
0aec			   ; Clobbers A, d and e 
0aec 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0aef			delayloop: 
0aef c5			    push bc 
0af0			 
0af0			if BASE_CPM 
0af0 01 a0 0f			ld bc, CPM_DELAY_TUNE 
0af3			.cpmloop: 
0af3 c5				push bc 
0af4			 
0af4			endif 
0af4			 
0af4			 
0af4			 
0af4			delayloopi: 
0af4			;	push bc 
0af4			;.dl: 
0af4 cb 47		    bit     0,a    	; 8 
0af6 cb 47		    bit     0,a    	; 8 
0af8 cb 47		    bit     0,a    	; 8 
0afa e6 ff		    and     255  	; 7 
0afc 0b			    dec     bc      	; 6 
0afd 79			    ld      a,c     	; 4 
0afe b0			    or      b     	; 4 
0aff c2 f4 0a		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0b02			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0b02				;pop de 
0b02			;pop bc 
0b02			 
0b02			if BASE_CPM 
0b02 c1				pop bc 
0b03				 
0b03 0b			    dec     bc      	; 6 
0b04 79			    ld      a,c     	; 4 
0b05 b0			    or      b     	; 4 
0b06 c2 f3 0a		    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0b09				 
0b09			 
0b09			endif 
0b09			;if CPU_CLOCK_8MHZ 
0b09			;    pop bc 
0b09			;    push bc 
0b09			;.dl8: 
0b09			;    bit     0,a    	; 8 
0b09			;    bit     0,a    	; 8 
0b09			;    bit     0,a    	; 8 
0b09			;    and     255  	; 7 
0b09			;    dec     bc      	; 6 
0b09			;    ld      a,c     	; 4 
0b09			;    or      b     	; 4 
0b09			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b09			;endif 
0b09			 
0b09			;if CPU_CLOCK_10MHZ 
0b09			;    pop bc 
0b09			;    push bc 
0b09			;.dl8: 
0b09			;    bit     0,a    	; 8 
0b09			;    bit     0,a    	; 8 
0b09			;    bit     0,a    	; 8 
0b09			;    and     255  	; 7 
0b09			;    dec     bc      	; 6 
0b09			;    ld      a,c     	; 4 
0b09			;    or      b     	; 4 
0b09			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b09			;endif 
0b09 c1			    pop bc 
0b0a			 
0b0a c9				ret 
0b0b			 
0b0b			 
0b0b			 
0b0b			; eof 
# End of file firmware_general.asm
0b0b			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0b0b			; display routines that use the physical hardware abstraction layer 
0b0b			 
0b0b			 
0b0b			; information window 
0b0b			 
0b0b			; pass hl with 1st string to display 
0b0b			; pass de with 2nd string to display 
0b0b			 
0b0b			info_panel: 
0b0b e5				push hl 
0b0c			 
0b0c 2a d2 eb			ld hl, (display_fb_active) 
0b0f e5				push hl    ; future de destination 
0b10 21 b7 ed				ld hl, display_fb0 
0b13 22 d2 eb				ld (display_fb_active), hl 
0b16			 
0b16			;	call clear_display 
0b16			 
0b16				if BASE_CPM 
0b16 3e 2e			ld a, '.' 
0b18				else 
0b18				ld a, 165 
0b18				endif 
0b18 cd 7f 0b			call fill_display 
0b1b			 
0b1b			 
0b1b 3e 55			ld a, display_row_3 + 5 
0b1d cd 8d 0b			call str_at_display 
0b20			 
0b20 e1				pop hl 
0b21 d1				pop de 
0b22			 
0b22 e5				push hl 
0b23			 
0b23			 
0b23 3e 2d			ld a, display_row_2 + 5 
0b25 cd 8d 0b			call str_at_display 
0b28			 
0b28			 
0b28 cd 9d 0b			call update_display 
0b2b cd 91 1b			call next_page_prompt 
0b2e cd 7a 0b			call clear_display 
0b31			 
0b31				 
0b31 21 16 ed				ld hl, display_fb1 
0b34 22 d2 eb				ld (display_fb_active), hl 
0b37 cd 9d 0b			call update_display 
0b3a			 
0b3a e1				pop hl 
0b3b			 
0b3b c9				ret 
0b3c			 
0b3c			 
0b3c			 
0b3c			 
0b3c			; TODO windowing? 
0b3c			 
0b3c			; TODO scroll line up 
0b3c			 
0b3c			scroll_up: 
0b3c			 
0b3c e5				push hl 
0b3d d5				push de 
0b3e c5				push bc 
0b3f			 
0b3f				; get frame buffer  
0b3f			 
0b3f 2a d2 eb			ld hl, (display_fb_active) 
0b42 e5				push hl    ; future de destination 
0b43			 
0b43 11 28 00			ld  de, display_cols 
0b46 19				add hl, de 
0b47			 
0b47 d1				pop de 
0b48			 
0b48				;ex de, hl 
0b48 01 9f 00			ld bc, display_fb_len -1  
0b4b			;if DEBUG_FORTH_WORDS 
0b4b			;	DMARK "SCL" 
0b4b			;	CALLMONITOR 
0b4b			;endif	 
0b4b ed b0			ldir 
0b4d			 
0b4d				; wipe bottom row 
0b4d			 
0b4d			 
0b4d 2a d2 eb			ld hl, (display_fb_active) 
0b50 11 a0 00			ld de, display_cols*display_rows 
0b53 19				add hl, de 
0b54 06 28			ld b, display_cols 
0b56 3e 20			ld a, ' ' 
0b58			.scwipe: 
0b58 77				ld (hl), a 
0b59 2b				dec hl 
0b5a 10 fc			djnz .scwipe 
0b5c			 
0b5c				;pop hl 
0b5c			 
0b5c c1				pop bc 
0b5d d1				pop de 
0b5e e1				pop hl 
0b5f			 
0b5f c9				ret 
0b60			 
0b60			 
0b60			;scroll_upo: 
0b60			;	ld de, display_row_1 
0b60			 ;	ld hl, display_row_2 
0b60			;	ld bc, display_cols 
0b60			;	ldir 
0b60			;	ld de, display_row_2 
0b60			 ;	ld hl, display_row_3 
0b60			;	ld bc, display_cols 
0b60			;	ldir 
0b60			;	ld de, display_row_3 
0b60			 ;	ld hl, display_row_4 
0b60			;	ld bc, display_cols 
0b60			;	ldir 
0b60			 
0b60			; TODO clear row 4 
0b60			 
0b60			;	ret 
0b60			 
0b60				 
0b60			scroll_down: 
0b60			 
0b60 e5				push hl 
0b61 d5				push de 
0b62 c5				push bc 
0b63			 
0b63				; get frame buffer  
0b63			 
0b63 2a d2 eb			ld hl, (display_fb_active) 
0b66			 
0b66 11 9f 00			ld de, display_fb_len - 1 
0b69 19				add hl, de 
0b6a			 
0b6a e5			push hl    ; future de destination 
0b6b			 
0b6b 11 28 00			ld  de, display_cols 
0b6e ed 52			sbc hl, de 
0b70			 
0b70			 
0b70 d1				pop de 
0b71			 
0b71			;	ex de, hl 
0b71 01 9f 00			ld bc, display_fb_len -1  
0b74			 
0b74			 
0b74				 
0b74			 
0b74 ed b0			ldir 
0b76			 
0b76				; wipe bottom row 
0b76			 
0b76			 
0b76			;	ld hl, (display_fb_active) 
0b76			;;	ld de, display_cols*display_rows 
0b76			;;	add hl, de 
0b76			;	ld b, display_cols 
0b76			;	ld a, ' ' 
0b76			;.scwiped: 
0b76			;	ld (hl), a 
0b76			;	dec hl 
0b76			;	djnz .scwiped 
0b76			 
0b76				;pop hl 
0b76			 
0b76 c1				pop bc 
0b77 d1				pop de 
0b78 e1				pop hl 
0b79			 
0b79 c9				ret 
0b7a			;scroll_down: 
0b7a			;	ld de, display_row_4 
0b7a			;	ld hl, display_row_3 
0b7a			;	ld bc, display_cols 
0b7a			;	ldir 
0b7a			;	ld de, display_row_3 
0b7a			; 	ld hl, display_row_2 
0b7a			;	ld bc, display_cols 
0b7a			;	ldir 
0b7a			;	ld de, display_row_2 
0b7a			;	ld hl, display_row_1 
0b7a			;	ld bc, display_cols 
0b7a			;	ldir 
0b7a			;;; TODO clear row 1 
0b7a			;	ret 
0b7a			 
0b7a			 
0b7a			 
0b7a			 
0b7a			 
0b7a			; clear active frame buffer 
0b7a			 
0b7a			clear_display: 
0b7a 3e 20			ld a, ' ' 
0b7c c3 7f 0b			jp fill_display 
0b7f			 
0b7f			; fill active frame buffer with a char in A 
0b7f			 
0b7f			fill_display: 
0b7f 06 a0			ld b,display_fb_len 
0b81 2a d2 eb			ld hl, (display_fb_active) 
0b84 77			.fd1:	ld (hl),a 
0b85 23				inc hl 
0b86 10 fc			djnz .fd1 
0b88 23				inc hl 
0b89 3e 00			ld a,0 
0b8b 77				ld (hl),a 
0b8c			 
0b8c			 
0b8c c9				ret 
0b8d			; Write string (DE) at pos (A) to active frame buffer 
0b8d			 
0b8d 2a d2 eb		str_at_display:    ld hl,(display_fb_active) 
0b90 06 00					ld b,0 
0b92 4f					ld c,a 
0b93 09					add hl,bc 
0b94 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0b95 b7			            OR   A              ;Null terminator? 
0b96 c8			            RET  Z              ;Yes, so finished 
0b97 77					ld (hl),a 
0b98 23				inc hl 
0b99 13			            INC  DE             ;Point to next character 
0b9a 18 f8		            JR   .sad1     ;Repeat 
0b9c c9					ret 
0b9d			 
0b9d			; using current frame buffer write to physical display 
0b9d			 
0b9d			update_display: 
0b9d e5				push hl 
0b9e 2a d2 eb			ld hl, (display_fb_active) 
0ba1 cd 36 5b			call write_display 
0ba4 e1				pop hl 
0ba5 c9				ret 
0ba6			 
0ba6			; TODO scrolling 
0ba6			 
0ba6			 
0ba6			; move cursor right one char 
0ba6			cursor_right: 
0ba6			 
0ba6				; TODO shift right 
0ba6				; TODO if beyond max col 
0ba6				; TODO       cursor_next_line 
0ba6			 
0ba6 c9				ret 
0ba7			 
0ba7			 
0ba7			cursor_next_line: 
0ba7				; TODO first char 
0ba7				; TODO line down 
0ba7				; TODO if past last row 
0ba7				; TODO    scroll up 
0ba7			 
0ba7 c9				ret 
0ba8			 
0ba8			cursor_left: 
0ba8				; TODO shift left 
0ba8				; TODO if beyond left  
0ba8				; TODO     cursor prev line 
0ba8				 
0ba8 c9				ret 
0ba9			 
0ba9			cursor_prev_line: 
0ba9				; TODO last char 
0ba9				; TODO line up 
0ba9				; TODO if past first row 
0ba9				; TODO   scroll down 
0ba9			 
0ba9 c9				ret 
0baa			 
0baa			 
0baa			cout: 
0baa				; A - char 
0baa c9				ret 
0bab			 
0bab			 
0bab			; Display a menu and allow item selection (optional toggle items) 
0bab			; 
0bab			; format: 
0bab			; hl pointer to word array with zero term for items 
0bab			; e.g.    db item1 
0bab			;         db .... 
0bab			;         db 0 
0bab			; 
0bab			; a = starting menu item  
0bab			; 
0bab			; de = pointer item toggle array   (todo) 
0bab			; 
0bab			; returns item selected in a 1-... 
0bab			; returns 0 if back button pressed 
0bab			; 
0bab			; NOTE: Uses system frame buffer to display 
0bab			; 
0bab			; LEFT, Q = go back 
0bab			; RIGHT, SPACE, CR = select 
0bab			; UP, A - Up 
0bab			; DOWN, Z - Down 
0bab			 
0bab			 
0bab			 
0bab			 
0bab			 
0bab			menu: 
0bab			 
0bab					; keep array pointer 
0bab			 
0bab 22 7d ea				ld (store_tmp1), hl 
0bae 32 7b ea				ld (store_tmp2), a 
0bb1			 
0bb1					; check for key bounce 
0bb1			 
0bb1			if BASE_KEV 
0bb1			 
0bb1			.mbounce:	call cin 
0bb1					cp 0 
0bb1					jr nz, .mbounce 
0bb1			endif 
0bb1					; for ease use ex 
0bb1			 
0bb1					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0bb1 21 b7 ed				ld hl, display_fb0 
0bb4 22 d2 eb				ld (display_fb_active), hl 
0bb7			 
0bb7 cd 7a 0b		.mloop:		call clear_display 
0bba cd 9d 0b				call update_display 
0bbd			 
0bbd					; draw selection id '>' at 1 
0bbd			 
0bbd					; init start of list display 
0bbd			 
0bbd 3e 05				ld a, 5 
0bbf 32 79 ea				ld (store_tmp3), a   ; display row count 
0bc2 3a 7b ea				ld a,( store_tmp2) 
0bc5 32 7c ea				ld (store_tmp2+1), a   ; display item count 
0bc8			 
0bc8					 
0bc8			.mitem:	 
0bc8			 
0bc8			 
0bc8 3a 7c ea				ld a,(store_tmp2+1) 
0bcb 6f					ld l, a 
0bcc 26 00				ld h, 0 
0bce 29					add hl, hl 
0bcf ed 5b 7d ea			ld de, (store_tmp1) 
0bd3 19					add hl, de 
0bd4 7e					ld a, (hl) 
0bd5 23					inc hl 
0bd6 66					ld h,(hl) 
0bd7 6f					ld l, a 
0bd8			 
0bd8 cd d0 0d				call ishlzero 
0bdb 28 1a				jr z, .mdone 
0bdd			 
0bdd eb					ex de, hl 
0bde 3a 79 ea				ld a, (store_tmp3) 
0be1 cd 8d 0b				call str_at_display 
0be4					 
0be4			 
0be4					; next item 
0be4 3a 7c ea				ld a, (store_tmp2+1) 
0be7 3c					inc a 
0be8 32 7c ea				ld (store_tmp2+1), a   ; display item count 
0beb			 
0beb			 		; next row 
0beb			 
0beb 3a 79 ea				ld a, (store_tmp3) 
0bee c6 28				add display_cols 
0bf0 32 79 ea				ld (store_tmp3), a 
0bf3			 
0bf3					; at end of screen? 
0bf3			 
0bf3 fe 10				cp display_rows*4 
0bf5 20 d1				jr nz, .mitem 
0bf7			 
0bf7			 
0bf7			.mdone: 
0bf7 cd d0 0d				call ishlzero 
0bfa 28 08				jr z, .nodn 
0bfc			 
0bfc 3e 78				ld a, display_row_4 
0bfe 11 7d 0c				ld de, .mdown 
0c01 cd 8d 0b				call str_at_display 
0c04			 
0c04					; draw options to fill the screens with active item on line 1 
0c04					; if current option is 2 or more then display ^ in top 
0c04			 
0c04 3a 7b ea		.nodn:		ld a, (store_tmp2) 
0c07 fe 00				cp 0 
0c09 28 08				jr z, .noup 
0c0b			 
0c0b 3e 00				ld a, 0 
0c0d 11 7b 0c				ld de, .mup 
0c10 cd 8d 0b				call str_at_display 
0c13			 
0c13 3e 02		.noup:		ld a, 2 
0c15 11 79 0c				ld de, .msel 
0c18 cd 8d 0b				call str_at_display 
0c1b			 
0c1b					; if current option + 1 is not null then display V in bottom 
0c1b					; get key 
0c1b cd 9d 0b				call update_display 
0c1e			 
0c1e			 
0c1e					; handle key 
0c1e			 
0c1e cd e8 5b				call cin_wait 
0c21			 
0c21 fe 05				cp KEY_UP 
0c23 28 2b				jr z, .mgoup 
0c25 fe 61				cp 'a' 
0c27 28 27				jr z, .mgoup 
0c29 fe 0a				cp KEY_DOWN 
0c2b 28 32				jr z, .mgod 
0c2d fe 7a				cp 'z' 
0c2f 28 2e				jr z, .mgod 
0c31 fe 20				cp ' ' 
0c33 28 34				jr z, .goend 
0c35 fe 0c				cp KEY_RIGHT 
0c37 28 30				jr z, .goend 
0c39 fe 0d				cp KEY_CR 
0c3b 28 2c				jr z, .goend 
0c3d fe 71				cp 'q' 
0c3f 28 0b				jr z, .goback 
0c41			 
0c41 fe 0b				cp KEY_LEFT 
0c43 28 07				jr z, .goback 
0c45 fe 08				cp KEY_BS 
0c47 28 03				jr z, .goback 
0c49 c3 b7 0b				jp .mloop 
0c4c			 
0c4c			.goback: 
0c4c 3e 00			ld a, 0 
0c4e 18 1d			jr .goend2 
0c50			 
0c50				; move up one 
0c50			.mgoup: 
0c50 3a 7b ea				ld a, (store_tmp2) 
0c53 fe 00				cp 0 
0c55 ca b7 0b				jp z, .mloop 
0c58 3d					dec a 
0c59 32 7b ea				ld (store_tmp2), a 
0c5c c3 b7 0b				jp .mloop 
0c5f			 
0c5f				; move down one 
0c5f			.mgod: 
0c5f 3a 7b ea				ld a, (store_tmp2) 
0c62 3c					inc a 
0c63 32 7b ea				ld (store_tmp2), a 
0c66 c3 b7 0b				jp .mloop 
0c69			 
0c69			 
0c69			.goend: 
0c69					; get selected item number 
0c69			 
0c69 3a 7b ea				ld a, (store_tmp2) 
0c6c 3c					inc a 
0c6d			 
0c6d			.goend2: 
0c6d f5					push af 
0c6e			 
0c6e					; restore active fb 
0c6e					; TODO BUG assumes fb1 
0c6e			 
0c6e 21 16 ed				ld hl, display_fb1 
0c71 22 d2 eb				ld (display_fb_active), hl 
0c74			 
0c74					; restore main regs 
0c74			 
0c74			 
0c74 cd 9d 0b				call update_display 
0c77			 
0c77 f1					pop af 
0c78			 
0c78 c9				ret 
0c79			 
0c79 .. 00		.msel:   db ">",0 
0c7b .. 00		.mup:   db "^",0 
0c7d .. 00		.mdown:   db "v",0 
0c7f			 
0c7f			 
0c7f			; eof 
0c7f			 
# End of file firmware_display.asm
0c7f			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0c7f			; random number generators 
0c7f			 
0c7f			 
0c7f			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0c7f			 
0c7f			 
0c7f			;-----> Generate a random number 
0c7f			; output a=answer 0<=a<=255 
0c7f			; all registers are preserved except: af 
0c7f			random: 
0c7f e5			        push    hl 
0c80 d5			        push    de 
0c81 2a b4 eb		        ld      hl,(randData) 
0c84 ed 5f		        ld      a,r 
0c86 57			        ld      d,a 
0c87 5e			        ld      e,(hl) 
0c88 19			        add     hl,de 
0c89 85			        add     a,l 
0c8a ac			        xor     h 
0c8b 22 b4 eb		        ld      (randData),hl 
0c8e d1			        pop     de 
0c8f e1			        pop     hl 
0c90 c9			        ret 
0c91			 
0c91			 
0c91			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0c91			 
0c91			 
0c91			 
0c91			;------LFSR------ 
0c91			;James Montelongo 
0c91			;optimized by Spencer Putt 
0c91			;out: 
0c91			; a = 8 bit random number 
0c91			RandLFSR: 
0c91 21 ba eb		        ld hl,LFSRSeed+4 
0c94 5e			        ld e,(hl) 
0c95 23			        inc hl 
0c96 56			        ld d,(hl) 
0c97 23			        inc hl 
0c98 4e			        ld c,(hl) 
0c99 23			        inc hl 
0c9a 7e			        ld a,(hl) 
0c9b 47			        ld b,a 
0c9c cb 13		        rl e  
0c9e cb 12			rl d 
0ca0 cb 11		        rl c  
0ca2 17				rla 
0ca3 cb 13		        rl e  
0ca5 cb 12			rl d 
0ca7 cb 11		        rl c  
0ca9 17				rla 
0caa cb 13		        rl e  
0cac cb 12			rl d 
0cae cb 11		        rl c  
0cb0 17				rla 
0cb1 67			        ld h,a 
0cb2 cb 13		        rl e  
0cb4 cb 12			rl d 
0cb6 cb 11		        rl c  
0cb8 17				rla 
0cb9 a8			        xor b 
0cba cb 13		        rl e  
0cbc cb 12			rl d 
0cbe ac			        xor h 
0cbf a9			        xor c 
0cc0 aa			        xor d 
0cc1 21 bc eb		        ld hl,LFSRSeed+6 
0cc4 11 bd eb		        ld de,LFSRSeed+7 
0cc7 01 07 00		        ld bc,7 
0cca ed b8		        lddr 
0ccc 12			        ld (de),a 
0ccd c9			        ret 
0cce			 
0cce			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0cce			 
0cce			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0cce			 
0cce			 
0cce			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0cce			 
0cce			prng16: 
0cce			;Inputs: 
0cce			;   (seed1) contains a 16-bit seed value 
0cce			;   (seed2) contains a NON-ZERO 16-bit seed value 
0cce			;Outputs: 
0cce			;   HL is the result 
0cce			;   BC is the result of the LCG, so not that great of quality 
0cce			;   DE is preserved 
0cce			;Destroys: 
0cce			;   AF 
0cce			;cycle: 4,294,901,760 (almost 4.3 billion) 
0cce			;160cc 
0cce			;26 bytes 
0cce 2a ae eb		    ld hl,(seed1) 
0cd1 44			    ld b,h 
0cd2 4d			    ld c,l 
0cd3 29			    add hl,hl 
0cd4 29			    add hl,hl 
0cd5 2c			    inc l 
0cd6 09			    add hl,bc 
0cd7 22 ae eb		    ld (seed1),hl 
0cda 2a ac eb		    ld hl,(seed2) 
0cdd 29			    add hl,hl 
0cde 9f			    sbc a,a 
0cdf e6 2d		    and %00101101 
0ce1 ad			    xor l 
0ce2 6f			    ld l,a 
0ce3 22 ac eb		    ld (seed2),hl 
0ce6 09			    add hl,bc 
0ce7 c9			    ret 
0ce8			 
0ce8			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0ce8			 
0ce8			rand32: 
0ce8			;Inputs: 
0ce8			;   (seed1_0) holds the lower 16 bits of the first seed 
0ce8			;   (seed1_1) holds the upper 16 bits of the first seed 
0ce8			;   (seed2_0) holds the lower 16 bits of the second seed 
0ce8			;   (seed2_1) holds the upper 16 bits of the second seed 
0ce8			;   **NOTE: seed2 must be non-zero 
0ce8			;Outputs: 
0ce8			;   HL is the result 
0ce8			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0ce8			;Destroys: 
0ce8			;   AF 
0ce8			;Tested and passes all CAcert tests 
0ce8			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0ce8			;it has a period of 18,446,744,069,414,584,320 
0ce8			;roughly 18.4 quintillion. 
0ce8			;LFSR taps: 0,2,6,7  = 11000101 
0ce8			;291cc 
0ce8			;seed1_0=$+1 
0ce8			;    ld hl,12345 
0ce8			;seed1_1=$+1 
0ce8			;    ld de,6789 
0ce8			;    ld b,h 
0ce8			;    ld c,l 
0ce8			;    add hl,hl \ rl e \ rl d 
0ce8			;    add hl,hl \ rl e \ rl d 
0ce8			;    inc l 
0ce8			;    add hl,bc 
0ce8			;    ld (seed1_0),hl 
0ce8			;    ld hl,(seed1_1) 
0ce8			;    adc hl,de 
0ce8			;    ld (seed1_1),hl 
0ce8			;    ex de,hl 
0ce8			;seed2_0=$+1 
0ce8			;    ld hl,9876 
0ce8			;seed2_1=$+1 
0ce8			;    ld bc,54321 
0ce8			;    add hl,hl \ rl c \ rl b 
0ce8			;    ld (seed2_1),bc 
0ce8			;    sbc a,a 
0ce8			;    and %11000101 
0ce8			;    xor l 
0ce8			;    ld l,a 
0ce8			;    ld (seed2_0),hl 
0ce8			;    ex de,hl 
0ce8			;    add hl,bc 
0ce8			;    ret 
0ce8			; 
0ce8			 
0ce8			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0ce8			; 20 bytes, 86 cycles (excluding ret) 
0ce8			 
0ce8			; returns   hl = pseudorandom number 
0ce8			; corrupts   a 
0ce8			 
0ce8			; generates 16-bit pseudorandom numbers with a period of 65535 
0ce8			; using the xorshift method: 
0ce8			 
0ce8			; hl ^= hl << 7 
0ce8			; hl ^= hl >> 9 
0ce8			; hl ^= hl << 8 
0ce8			 
0ce8			; some alternative shift triplets which also perform well are: 
0ce8			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0ce8			 
0ce8			;  org 32768 
0ce8			 
0ce8			xrnd: 
0ce8 2a b2 eb		  ld hl,(xrandc)       ; seed must not be 0 
0ceb 3e 00		  ld a,0 
0ced bd			  cp l 
0cee 20 02		  jr nz, .xrnd1 
0cf0 2e 01		  ld l, 1 
0cf2			.xrnd1: 
0cf2			 
0cf2 7c			  ld a,h 
0cf3 1f			  rra 
0cf4 7d			  ld a,l 
0cf5 1f			  rra 
0cf6 ac			  xor h 
0cf7 67			  ld h,a 
0cf8 7d			  ld a,l 
0cf9 1f			  rra 
0cfa 7c			  ld a,h 
0cfb 1f			  rra 
0cfc ad			  xor l 
0cfd 6f			  ld l,a 
0cfe ac			  xor h 
0cff 67			  ld h,a 
0d00			 
0d00 22 b2 eb		  ld (xrandc),hl 
0d03			 
0d03 c9			  ret 
0d04			;  
0d04			 
0d04			 
0d04			;;;; int maths 
0d04			 
0d04			; https://map.grauw.nl/articles/mult_div_shifts.php 
0d04			; Divide 16-bit values (with 16-bit result) 
0d04			; In: Divide BC by divider DE 
0d04			; Out: BC = result, HL = rest 
0d04			; 
0d04			Div16: 
0d04 21 00 00		    ld hl,0 
0d07 78			    ld a,b 
0d08 06 08		    ld b,8 
0d0a			Div16_Loop1: 
0d0a 17			    rla 
0d0b ed 6a		    adc hl,hl 
0d0d ed 52		    sbc hl,de 
0d0f 30 01		    jr nc,Div16_NoAdd1 
0d11 19			    add hl,de 
0d12			Div16_NoAdd1: 
0d12 10 f6		    djnz Div16_Loop1 
0d14 17			    rla 
0d15 2f			    cpl 
0d16 47			    ld b,a 
0d17 79			    ld a,c 
0d18 48			    ld c,b 
0d19 06 08		    ld b,8 
0d1b			Div16_Loop2: 
0d1b 17			    rla 
0d1c ed 6a		    adc hl,hl 
0d1e ed 52		    sbc hl,de 
0d20 30 01		    jr nc,Div16_NoAdd2 
0d22 19			    add hl,de 
0d23			Div16_NoAdd2: 
0d23 10 f6		    djnz Div16_Loop2 
0d25 17			    rla 
0d26 2f			    cpl 
0d27 41			    ld b,c 
0d28 4f			    ld c,a 
0d29 c9			ret 
0d2a			 
0d2a			 
0d2a			;http://z80-heaven.wikidot.com/math 
0d2a			; 
0d2a			;Inputs: 
0d2a			;     DE and A are factors 
0d2a			;Outputs: 
0d2a			;     A is not changed 
0d2a			;     B is 0 
0d2a			;     C is not changed 
0d2a			;     DE is not changed 
0d2a			;     HL is the product 
0d2a			;Time: 
0d2a			;     342+6x 
0d2a			; 
0d2a			Mult16: 
0d2a			 
0d2a 06 08		     ld b,8          ;7           7 
0d2c 21 00 00		     ld hl,0         ;10         10 
0d2f 29			       add hl,hl     ;11*8       88 
0d30 07			       rlca          ;4*8        32 
0d31 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0d33 19			         add hl,de   ;--         -- 
0d34 10 f9		       djnz $-5      ;13*7+8     99 
0d36 c9			ret 
0d37			 
0d37			; 
0d37			; Square root of 16-bit value 
0d37			; In:  HL = value 
0d37			; Out:  D = result (rounded down) 
0d37			; 
0d37			;Sqr16: 
0d37			;    ld de,#0040 
0d37			;    ld a,l 
0d37			;    ld l,h 
0d37			;    ld h,d 
0d37			;    or a 
0d37			;    ld b,8 
0d37			;Sqr16_Loop: 
0d37			;    sbc hl,de 
0d37			;    jr nc,Sqr16_Skip 
0d37			;    add hl,de 
0d37			;Sqr16_Skip: 
0d37			;    ccf 
0d37			;    rl d 
0d37			;    add a,a 
0d37			;    adc hl,hl 
0d37			;    add a,a 
0d37			;    adc hl,hl 
0d37			;    djnz Sqr16_Loop 
0d37			;    ret 
0d37			; 
0d37			; 
0d37			; Divide 8-bit values 
0d37			; In: Divide E by divider C 
0d37			; Out: A = result, B = rest 
0d37			; 
0d37			Div8: 
0d37 af			    xor a 
0d38 06 08		    ld b,8 
0d3a			Div8_Loop: 
0d3a cb 13		    rl e 
0d3c 17			    rla 
0d3d 91			    sub c 
0d3e 30 01		    jr nc,Div8_NoAdd 
0d40 81			    add a,c 
0d41			Div8_NoAdd: 
0d41 10 f7		    djnz Div8_Loop 
0d43 47			    ld b,a 
0d44 7b			    ld a,e 
0d45 17			    rla 
0d46 2f			    cpl 
0d47 c9			    ret 
0d48			 
0d48			; 
0d48			; Multiply 8-bit value with a 16-bit value (unrolled) 
0d48			; In: Multiply A with DE 
0d48			; Out: HL = result 
0d48			; 
0d48			Mult12U: 
0d48 2e 00		    ld l,0 
0d4a 87			    add a,a 
0d4b 30 01		    jr nc,Mult12U_NoAdd0 
0d4d 19			    add hl,de 
0d4e			Mult12U_NoAdd0: 
0d4e 29			    add hl,hl 
0d4f 87			    add a,a 
0d50 30 01		    jr nc,Mult12U_NoAdd1 
0d52 19			    add hl,de 
0d53			Mult12U_NoAdd1: 
0d53 29			    add hl,hl 
0d54 87			    add a,a 
0d55 30 01		    jr nc,Mult12U_NoAdd2 
0d57 19			    add hl,de 
0d58			Mult12U_NoAdd2: 
0d58 29			    add hl,hl 
0d59 87			    add a,a 
0d5a 30 01		    jr nc,Mult12U_NoAdd3 
0d5c 19			    add hl,de 
0d5d			Mult12U_NoAdd3: 
0d5d 29			    add hl,hl 
0d5e 87			    add a,a 
0d5f 30 01		    jr nc,Mult12U_NoAdd4 
0d61 19			    add hl,de 
0d62			Mult12U_NoAdd4: 
0d62 29			    add hl,hl 
0d63 87			    add a,a 
0d64 30 01		    jr nc,Mult12U_NoAdd5 
0d66 19			    add hl,de 
0d67			Mult12U_NoAdd5: 
0d67 29			    add hl,hl 
0d68 87			    add a,a 
0d69 30 01		    jr nc,Mult12U_NoAdd6 
0d6b 19			    add hl,de 
0d6c			Mult12U_NoAdd6: 
0d6c 29			    add hl,hl 
0d6d 87			    add a,a 
0d6e d0			    ret nc 
0d6f 19			    add hl,de 
0d70 c9			    ret 
0d71			 
0d71			; 
0d71			; Multiply 8-bit value with a 16-bit value (right rotating) 
0d71			; In: Multiply A with DE 
0d71			;      Put lowest value in A for most efficient calculation 
0d71			; Out: HL = result 
0d71			; 
0d71			Mult12R: 
0d71 21 00 00		    ld hl,0 
0d74			Mult12R_Loop: 
0d74 cb 3f		    srl a 
0d76 30 01		    jr nc,Mult12R_NoAdd 
0d78 19			    add hl,de 
0d79			Mult12R_NoAdd: 
0d79 cb 23		    sla e 
0d7b cb 12		    rl d 
0d7d b7			    or a 
0d7e c2 74 0d		    jp nz,Mult12R_Loop 
0d81 c9			    ret 
0d82			 
0d82			; 
0d82			; Multiply 16-bit values (with 32-bit result) 
0d82			; In: Multiply BC with DE 
0d82			; Out: BCHL = result 
0d82			; 
0d82			Mult32: 
0d82 79			    ld a,c 
0d83 48			    ld c,b 
0d84 21 00 00		    ld hl,0 
0d87 06 10		    ld b,16 
0d89			Mult32_Loop: 
0d89 29			    add hl,hl 
0d8a 17			    rla 
0d8b cb 11		    rl c 
0d8d 30 07		    jr nc,Mult32_NoAdd 
0d8f 19			    add hl,de 
0d90 ce 00		    adc a,0 
0d92 d2 96 0d		    jp nc,Mult32_NoAdd 
0d95 0c			    inc c 
0d96			Mult32_NoAdd: 
0d96 10 f1		    djnz Mult32_Loop 
0d98 41			    ld b,c 
0d99 4f			    ld c,a 
0d9a c9			    ret 
0d9b			 
0d9b			 
0d9b			 
0d9b			; 
0d9b			; Multiply 8-bit values 
0d9b			; In:  Multiply H with E 
0d9b			; Out: HL = result 
0d9b			; 
0d9b			Mult8: 
0d9b 16 00		    ld d,0 
0d9d 6a			    ld l,d 
0d9e 06 08		    ld b,8 
0da0			Mult8_Loop: 
0da0 29			    add hl,hl 
0da1 30 01		    jr nc,Mult8_NoAdd 
0da3 19			    add hl,de 
0da4			Mult8_NoAdd: 
0da4 10 fa		    djnz Mult8_Loop 
0da6 c9			    ret 
0da7			 
0da7			 
0da7			 
0da7			 
0da7			 
0da7			 
0da7			 
0da7			 
0da7			;;http://z80-heaven.wikidot.com/math 
0da7			;;This divides DE by BC, storing the result in DE, remainder in HL 
0da7			; 
0da7			;DE_Div_BC:          ;1281-2x, x is at most 16 
0da7			;     ld a,16        ;7 
0da7			;     ld hl,0        ;10 
0da7			;     jp $+5         ;10 
0da7			;.DivLoop: 
0da7			;       add hl,bc    ;-- 
0da7			;       dec a        ;64 
0da7			;       jr z,.DivLoopEnd        ;86 
0da7			; 
0da7			;       sla e        ;128 
0da7			;       rl d         ;128 
0da7			;       adc hl,hl    ;240 
0da7			;       sbc hl,bc    ;240 
0da7			;       jr nc,.DivLoop ;23|21 
0da7			;       inc e        ;-- 
0da7			;       jp .DivLoop+1 
0da7			; 
0da7			;.DivLoopEnd: 
0da7			 
0da7			;HL_Div_C: 
0da7			;Inputs: 
0da7			;     HL is the numerator 
0da7			;     C is the denominator 
0da7			;Outputs: 
0da7			;     A is the remainder 
0da7			;     B is 0 
0da7			;     C is not changed 
0da7			;     DE is not changed 
0da7			;     HL is the quotient 
0da7			; 
0da7			;       ld b,16 
0da7			;       xor a 
0da7			;         add hl,hl 
0da7			;         rla 
0da7			;         cp c 
0da7			;         jr c,$+4 
0da7			;           inc l 
0da7			;           sub c 
0da7			;         djnz $-7 
0da7			 
0da7			; https://plutiedev.com/z80-add-8bit-to-16bit 
0da7			 
0da7			addatohl: 
0da7 85			    add   a, l    ; A = A+L 
0da8 6f			    ld    l, a    ; L = A+L 
0da9 8c			    adc   a, h    ; A = A+L+H+carry 
0daa 95			    sub   l       ; A = H+carry 
0dab 67			    ld    h, a    ; H = H+carry 
0dac c9			ret 
0dad			 
0dad			addatode: 
0dad 83			    add   a, e    ; A = A+L 
0dae 5f			    ld    e, a    ; L = A+L 
0daf 8a			    adc   a, d    ; A = A+L+H+carry 
0db0 93			    sub   e       ; A = H+carry 
0db1 57			    ld    d, a    ; H = H+carry 
0db2 c9			ret 
0db3			 
0db3			 
0db3			addatobc: 
0db3 81			    add   a, c    ; A = A+L 
0db4 4f			    ld    c, a    ; L = A+L 
0db5 88			    adc   a, b    ; A = A+L+H+carry 
0db6 91			    sub   c       ; A = H+carry 
0db7 47			    ld    b, a    ; H = H+carry 
0db8 c9			ret 
0db9			 
0db9			subafromhl: 
0db9			   ; If A=0 do nothing 
0db9			    ; Otherwise flip A's sign. Since 
0db9			    ; the upper byte becomes -1, also 
0db9			    ; substract 1 from H. 
0db9 ed 44		    neg 
0dbb ca c4 0d		    jp    z, Skip 
0dbe 25			    dec   h 
0dbf			     
0dbf			    ; Now add the low byte as usual 
0dbf			    ; Two's complement takes care of 
0dbf			    ; ensuring the result is correct 
0dbf 85			    add   a, l 
0dc0 6f			    ld    l, a 
0dc1 8c			    adc   a, h 
0dc2 95			    sub   l 
0dc3 67			    ld    h, a 
0dc4			Skip: 
0dc4 c9				ret 
0dc5			 
0dc5			 
0dc5			; compare hl and de 
0dc5			; returns:  
0dc5			; if hl = de, z=1, s=0, c0=0 
0dc5			; if hl > de, z=0, s=0, c=0 
0dc5			; if hl < de, z=0, s=1, c=1 
0dc5			cmp16:	 
0dc5 b7				or a 
0dc6 ed 52			sbc hl,de 
0dc8 e0				ret po 
0dc9 7c				ld a,h 
0dca 1f				rra 
0dcb ee 40			xor 01000000B 
0dcd 37				scf 
0dce 8f				adc a,a 
0dcf c9				ret 
0dd0			 
0dd0			 
0dd0			; test if hl contains zero   - A is destroyed 
0dd0			 
0dd0			ishlzero:    
0dd0 b7				or a     ; reset flags 
0dd1 7c				ld a, h 
0dd2 b5				or l        	 
0dd3			 
0dd3 c9				ret 
0dd4			 
0dd4			 
0dd4			 
0dd4			 
0dd4			if FORTH_ENABLE_FLOATMATH 
0dd4			;include "float/bbcmath.z80" 
0dd4			include "float/lpfpcalc.asm" 
0dd4			endif 
0dd4			 
0dd4			 
0dd4			; eof 
0dd4			 
# End of file firmware_maths.asm
0dd4			include "firmware_strings.asm"   ; string handling  
0dd4			 
0dd4			 
0dd4			; TODO string len 
0dd4			; input text string, end on cr with zero term 
0dd4			; a offset into frame buffer to start prompt 
0dd4			; d is max length 
0dd4			; e is display size TODO 
0dd4			; c is current cursor position 
0dd4			; hl is ptr to where string will be stored 
0dd4			 
0dd4			 
0dd4			; TODO check limit of buffer for new inserts 
0dd4			; TODO check insert does not push beyond buffer 
0dd4			; TODO scroll in a limited display area 
0dd4			; TODO scroll whole screen on page wrap 
0dd4			 
0dd4			 
0dd4			; TODO handle KEY_PREVWORD 
0dd4			; TODO handle KEY_NEXTWORD 
0dd4			; TODO handle KEY_HOME 
0dd4			; TODO handle KEY_END 
0dd4			; TODO use LCD cursor? 
0dd4			 
0dd4 32 6a ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
0dd7 81					add c 
0dd8 32 68 ee				ld (input_at_cursor),a	; save draw pos of cursor 
0ddb 22 6d ee				ld (input_start), hl     ; save ptr to buffer 
0dde 79					ld a, c 
0ddf cd a7 0d				call addatohl 
0de2 22 6f ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
0de5 7a					ld a,d 
0de6 32 6c ee			        ld (input_size), a       ; save length of input area 
0de9 79					ld a, c 
0dea 32 5b ee				ld (input_cursor),a      ; init cursor start position  
0ded 7b					ld a,e 
0dee 32 6b ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0df1					 
0df1					 
0df1			 
0df1			;		ld a,(input_ptr) 
0df1			;		ld (input_under_cursor),a 	; save what is under the cursor 
0df1			 
0df1			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0df1					; init cursor shape if not set by the cin routines 
0df1 21 ca eb				ld hl, cursor_shape 
0df4 3e ff				ld a, 255 
0df6 77					ld (hl), a 
0df7 23					inc hl 
0df8 3e 00				ld a, 0 
0dfa 77					ld (hl), a 
0dfb			 
0dfb 3e 0f				ld a, CUR_BLINK_RATE 
0dfd 32 66 ee				ld (input_cur_flash), a 
0e00 3e 01				ld a, 1 
0e02 32 65 ee				ld (input_cur_onoff),a 
0e05			 
0e05			;	if DEBUG_INPUT 
0e05			;		push af 
0e05			;		ld a, 'I' 
0e05			;		ld (debug_mark),a 
0e05			;		pop af 
0e05			;		CALLMONITOR 
0e05			;	endif 
0e05			.is1:		; main entry loop 
0e05			 
0e05			 
0e05			 
0e05					; pause 1ms 
0e05			 
0e05 3e 01				ld a, 1 
0e07 cd d1 0a				call aDelayInMS 
0e0a			 
0e0a					; dec flash counter 
0e0a 3a 66 ee				ld a, (input_cur_flash) 
0e0d 3d					dec a 
0e0e 32 66 ee				ld (input_cur_flash), a 
0e11 fe 00				cp 0 
0e13 20 0d				jr nz, .nochgstate 
0e15			 
0e15			 
0e15					; change state 
0e15 3a 65 ee				ld a,(input_cur_onoff) 
0e18 ed 44				neg 
0e1a 32 65 ee				ld (input_cur_onoff),a 
0e1d			 
0e1d			 
0e1d					; reset on change of state 
0e1d 3e 0f				ld a, CUR_BLINK_RATE 
0e1f 32 66 ee				ld (input_cur_flash), a 
0e22			 
0e22			.nochgstate: 
0e22					 
0e22					 
0e22			 
0e22					; display cursor  
0e22			 
0e22			;		ld hl, (input_start) 
0e22			;		ld a, (input_cursor) 
0e22			;		call addatohl 
0e22			 
0e22					; get char under cursor and replace with cursor 
0e22 2a 6f ee		ld hl, (input_ptr) 
0e25			;		ld a, (hl) 
0e25			;		ld (input_under_cursor),a 
0e25			;		ld a, '_' 
0e25			;		ld (hl), a 
0e25			 
0e25					; display string 
0e25			 
0e25 ed 5b 6d ee			ld de, (input_start) 
0e29 3a 6a ee				ld a, (input_at_pos) 
0e2c cd 8d 0b				call str_at_display 
0e2f			;	        call update_display 
0e2f			 
0e2f					; find place to put the cursor 
0e2f			;		add h 
0e2f			;		ld l, display_row_1 
0e2f			;		sub l 
0e2f			; (input_at_pos) 
0e2f					;ld c, a 
0e2f			;		ld a, (input_cursor) 
0e2f			;		ld l, (input_at_pos) 
0e2f			;		;ld b, h 
0e2f			;		add l 
0e2f			;		ld (input_at_cursor),a 
0e2f					;ld l,h 
0e2f			 
0e2f			;		ld h, 0 
0e2f			;		ld l,(input_at_pos) 
0e2f			;		ld a, (input_cursor) 
0e2f			;		call addatohl 
0e2f			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0e2f			;		call subafromhl 
0e2f			;		ld a,l 
0e2f			;		ld (input_at_cursor), a 
0e2f			 
0e2f				if DEBUG_INPUT 
0e2f					ld a, (hardware_diag) 
0e2f					cp 0 
0e2f					jr z, .skip_input_diag 
0e2f			 
0e2f					ld a,(input_at_pos) 
0e2f					ld hl, LFSRSeed 
0e2f					call hexout 
0e2f					ld a, (input_cursor) 
0e2f					ld hl, LFSRSeed+2 
0e2f					call hexout 
0e2f					ld a,(input_at_cursor) 
0e2f					ld hl, LFSRSeed+4 
0e2f					call hexout 
0e2f			 
0e2f					ld a,(input_cur_onoff) 
0e2f					ld hl, LFSRSeed+6 
0e2f					call hexout 
0e2f			 
0e2f					ld a,(input_cur_flash) 
0e2f					ld hl, LFSRSeed+8 
0e2f					call hexout 
0e2f			 
0e2f					ld a,(input_len) 
0e2f					ld hl, LFSRSeed+10 
0e2f					call hexout 
0e2f					ld hl, LFSRSeed+12 
0e2f					ld a, 0 
0e2f					ld (hl),a 
0e2f					ld a, display_row_4 
0e2f					ld de, LFSRSeed 
0e2f					call str_at_display 
0e2f					.skip_input_diag: 
0e2f				endif 
0e2f			 
0e2f					; decide on if we are showing the cursor this time round 
0e2f			 
0e2f 3a 65 ee				ld a, (input_cur_onoff) 
0e32 fe ff				cp 255 
0e34 28 13				jr z, .skipcur 
0e36			 
0e36			 
0e36 3a 68 ee				ld a,(input_at_cursor) 
0e39 11 ca eb				ld de, cursor_shape 
0e3c cd 8d 0b				call str_at_display 
0e3f			 
0e3f					; save length of current input string 
0e3f 2a 6d ee				ld hl, (input_start) 
0e42 cd 05 12				call strlenz 
0e45 7d					ld a,l 
0e46 32 60 ee				ld (input_len),a 
0e49			 
0e49			.skipcur: 
0e49			 
0e49 cd 9d 0b			        call update_display 
0e4c					 
0e4c			 
0e4c			 
0e4c					; wait 
0e4c				 
0e4c					; TODO loop without wait to flash the cursor and char under cursor	 
0e4c cd f0 5b				call cin    ; _wait 
0e4f			 
0e4f fe 00				cp 0 
0e51 ca 05 0e				jp z, .is1 
0e54			 
0e54					; get ptr to char to input into 
0e54			 
0e54 4f					ld c,a 
0e55 2a 6d ee				ld hl, (input_start) 
0e58 3a 5b ee				ld a, (input_cursor) 
0e5b cd a7 0d				call addatohl 
0e5e 22 6f ee				ld (input_ptr), hl 
0e61 79					ld a,c 
0e62			 
0e62					; replace char under cursor 
0e62			 
0e62			;		ld hl, (input_ptr) 
0e62			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0e62			;		ld (hl), a 
0e62			 
0e62			;	if DEBUG_INPUT 
0e62			;		push af 
0e62			;		ld a, 'i' 
0e62			;		ld (debug_mark),a 
0e62			;		pop af 
0e62			;		CALLMONITOR 
0e62			;	endif 
0e62 fe 0e				cp KEY_HOME 
0e64 20 0e				jr nz, .iske 
0e66			 
0e66 3a 6a ee				ld a, (input_at_pos) 
0e69 32 68 ee				ld (input_at_cursor),a 
0e6c 3e 00				ld a, 0 
0e6e 32 5b ee				ld (input_cursor), a 
0e71 c3 05 0e				jp .is1 
0e74					 
0e74 fe 0f		.iske:		cp KEY_END 
0e76 20 03				jr nz, .isknw 
0e78 c3 05 0e				jp .is1 
0e7b			 
0e7b fe 06		.isknw:		cp KEY_NEXTWORD 
0e7d 20 1b				jr nz, .iskpw 
0e7f			 
0e7f 2a 6f ee		.isknwm:	ld hl, (input_ptr) 
0e82 7e					ld a,(hl)	 
0e83 fe 00				cp 0 
0e85 ca 05 0e				jp z, .is1    ; end of string 
0e88 fe 20				cp ' ' 
0e8a ca 05 0e				jp z, .is1    ; end of word 
0e8d 23					inc hl 
0e8e 22 6f ee				ld (input_ptr), hl 
0e91 3a 68 ee				ld a, (input_at_cursor) 
0e94 3c					inc a 
0e95 32 68 ee				ld (input_at_cursor), a 
0e98 18 e5				jr .isknwm 
0e9a			 
0e9a fe 07		.iskpw:		cp KEY_PREVWORD 
0e9c 20 1b				jr nz, .iskl 
0e9e			.iskpwm:	 
0e9e 2a 6f ee				ld hl, (input_ptr) 
0ea1 7e					ld a,(hl)	 
0ea2 fe 00				cp 0  
0ea4 ca 05 0e				jp z, .is1    ; end of string 
0ea7 fe 20				cp ' ' 
0ea9 ca 05 0e				jp z, .is1    ; end of word 
0eac 2b					dec hl 
0ead 22 6f ee				ld (input_ptr), hl 
0eb0 3a 68 ee				ld a, (input_at_cursor) 
0eb3 3d					dec a 
0eb4 32 68 ee				ld (input_at_cursor), a 
0eb7 18 e5				jr .iskpwm 
0eb9			 
0eb9			 
0eb9 fe 0b		.iskl:		cp KEY_LEFT 
0ebb 20 27				jr nz, .isk1 
0ebd			 
0ebd 3a 5b ee				ld a, (input_cursor) 
0ec0			 
0ec0 fe 00				cp 0 
0ec2 ca 05 0e				jp z, .is1 		; at start of line to ignore  
0ec5			 
0ec5 3d					dec  a 		; TODO check underflow 
0ec6 32 5b ee				ld (input_cursor), a 
0ec9			 
0ec9 2a 6f ee				ld hl, (input_ptr) 
0ecc 2b					dec hl 
0ecd 22 6f ee				ld (input_ptr), hl 
0ed0					 
0ed0 3a 68 ee				ld a, (input_at_cursor) 
0ed3 3d					dec a 
0ed4 32 68 ee				ld (input_at_cursor), a 
0ed7			 
0ed7 3e 01				ld a, 1		; show cursor moving 
0ed9 32 65 ee				ld (input_cur_onoff),a 
0edc 3e 0f				ld a, CUR_BLINK_RATE 
0ede 32 66 ee				ld (input_cur_flash), a 
0ee1			 
0ee1 c3 05 0e				jp .is1 
0ee4			 
0ee4 fe 0c		.isk1:		cp KEY_RIGHT 
0ee6 20 2a				jr nz, .isk2 
0ee8			 
0ee8 3a 60 ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0eeb 5f					ld e,a 
0eec 3a 5b ee				ld a, (input_cursor) 
0eef bb					cp e 
0ef0 ca 05 0e				jp z, .is1		; at the end of string so dont go right 
0ef3			 
0ef3 3c					inc  a 		; TODO check overflow 
0ef4 32 5b ee				ld (input_cursor), a 
0ef7			 
0ef7 3a 68 ee				ld a, (input_at_cursor) 
0efa 3c					inc a 
0efb 32 68 ee				ld (input_at_cursor), a 
0efe			 
0efe 2a 6f ee				ld hl, (input_ptr) 
0f01 23					inc hl 
0f02 22 6f ee				ld (input_ptr), hl 
0f05			 
0f05 3e 01				ld a, 1		; show cursor moving 
0f07 32 65 ee				ld (input_cur_onoff),a 
0f0a 3e 0f				ld a, CUR_BLINK_RATE 
0f0c 32 66 ee				ld (input_cur_flash), a 
0f0f			 
0f0f c3 05 0e				jp .is1 
0f12			 
0f12 fe 05		.isk2:		cp KEY_UP 
0f14			 
0f14 20 26				jr nz, .isk3 
0f16			 
0f16					; swap last command with the current on 
0f16			 
0f16					; move cursor to start of string 
0f16 2a 6d ee				ld hl, (input_start) 
0f19 22 6f ee				ld (input_ptr), hl 
0f1c			 
0f1c 3a 6a ee				ld a, (input_at_pos) 
0f1f 32 68 ee				ld (input_at_cursor), a 
0f22			 
0f22 3e 00				ld a, 0 
0f24 32 5b ee				ld (input_cursor), a 
0f27					 
0f27					; swap input and last command buffers 
0f27			 
0f27 21 29 e6				ld hl, os_cli_cmd 
0f2a 11 28 e7				ld de, os_last_cmd 
0f2d 06 ff				ld b, 255 
0f2f 7e			.swap1:		ld a, (hl) 
0f30 4f					ld c,a 
0f31 1a					ld a, (de) 
0f32 77					ld (hl), a 
0f33 79					ld a,c 
0f34 12					ld (de),a 
0f35 23					inc hl 
0f36 13					inc de 
0f37 10 f6				djnz .swap1 
0f39			 
0f39			 
0f39			 
0f39			 
0f39			 
0f39 c3 05 0e				jp .is1 
0f3c			 
0f3c fe 08		.isk3:		cp KEY_BS 
0f3e 20 3c				jr nz, .isk4 
0f40			 
0f40 3a 5b ee				ld a, (input_cursor) 
0f43			 
0f43 fe 00				cp 0 
0f45 ca 05 0e				jp z, .is1 		; at start of line to ignore  
0f48			 
0f48 3d					dec  a 		; TODO check underflow 
0f49 32 5b ee				ld (input_cursor), a 
0f4c			 
0f4c					; hl is source 
0f4c					; de needs to be source - 1 
0f4c			 
0f4c			;		ld a, 0 
0f4c			;		dec hl 
0f4c			;		ld (hl), a 
0f4c			 
0f4c 2a 6f ee				ld hl, (input_ptr) 
0f4f 2b					dec hl 
0f50 22 6f ee				ld (input_ptr), hl 
0f53			 
0f53					; shift all data 
0f53			 
0f53 e5					push hl 
0f54 23					inc hl 
0f55 d1					pop de 
0f56 3a 60 ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0f59 4f					ld c,a 
0f5a 06 00				ld b,0 
0f5c ed b0				ldir  
0f5e			 
0f5e			 
0f5e			 
0f5e			 
0f5e 3a 68 ee				ld a, (input_at_cursor) 
0f61 3d					dec a 
0f62 32 68 ee				ld (input_at_cursor), a 
0f65			 
0f65			 
0f65 3e 01				ld a, 1		; show cursor moving 
0f67 32 65 ee				ld (input_cur_onoff),a 
0f6a 3e 0f				ld a, CUR_BLINK_RATE 
0f6c 32 66 ee				ld (input_cur_flash), a 
0f6f			 
0f6f					; remove char 
0f6f 3a 68 ee				ld a, (input_at_cursor) 
0f72 3c					inc a 
0f73 11 fd 0f				ld de,.iblank 
0f76 cd 8d 0b				call str_at_display 
0f79			 
0f79 c3 05 0e				jp .is1 
0f7c			 
0f7c fe 0d		.isk4:		cp KEY_CR 
0f7e 28 6c				jr z, .endinput 
0f80			 
0f80					; else add the key press to the end 
0f80			 
0f80 4f					ld c, a			; save key pressed 
0f81			 
0f81 7e					ld a,(hl)		; get what is currently under char 
0f82			 
0f82 fe 00				cp 0			; we are at the end of the string 
0f84 20 2f				jr nz, .onchar 
0f86					 
0f86					; add a char to the end of the string 
0f86				 
0f86 71					ld (hl),c 
0f87 23					inc hl 
0f88			;		ld a,' ' 
0f88			;		ld (hl),a 
0f88			;		inc hl 
0f88 3e 00				ld a,0 
0f8a 77					ld (hl),a 
0f8b 2b					dec hl 
0f8c			 
0f8c 3a 5b ee				ld a, (input_cursor) 
0f8f 3c					inc a				; TODO check max string length and scroll  
0f90 32 5b ee				ld (input_cursor), a		; inc cursor pos 
0f93							 
0f93 3a 68 ee				ld a, (input_at_cursor) 
0f96 3c					inc a 
0f97 32 68 ee				ld (input_at_cursor), a 
0f9a			 
0f9a 2a 6f ee				ld hl, (input_ptr) 
0f9d 23					inc hl 
0f9e 22 6f ee				ld (input_ptr), hl 
0fa1			 
0fa1 2a 6f ee				ld hl, (input_ptr) 
0fa4 23					inc hl 
0fa5 22 6f ee				ld (input_ptr), hl 
0fa8			;	if DEBUG_INPUT 
0fa8			;		push af 
0fa8			;		ld a, '+' 
0fa8			;		ld (debug_mark),a 
0fa8			;		pop af 
0fa8			;		CALLMONITOR 
0fa8			;	endif 
0fa8 3e 01				ld a, 1		; show cursor moving 
0faa 32 65 ee				ld (input_cur_onoff),a 
0fad 3e 0f				ld a, CUR_BLINK_RATE 
0faf 32 66 ee				ld (input_cur_flash), a 
0fb2 c3 05 0e				jp .is1 
0fb5					 
0fb5			 
0fb5			 
0fb5					; if on a char then insert 
0fb5			.onchar: 
0fb5			 
0fb5					; TODO over flow check: make sure insert does not blow out buffer 
0fb5			 
0fb5					; need to do some maths to use lddr 
0fb5			 
0fb5 e5					push hl   ; save char pos 
0fb6 c5					push bc 
0fb7			 
0fb7 2a 6d ee				ld hl, (input_start) 
0fba 3a 60 ee				ld a, (input_len) 
0fbd cd a7 0d				call addatohl  		; end of string 
0fc0 23					inc hl 
0fc1 23					inc hl		; past zero term 
0fc2 e5					push hl 
0fc3 23					inc hl 
0fc4 e5					push hl  
0fc5			 
0fc5								; start and end of lddr set, now how much to move? 
0fc5			 
0fc5							 
0fc5 3a 5b ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0fc8 47					ld b,a 
0fc9 3a 60 ee				ld a,(input_len) 
0fcc 5f					ld e,a 
0fcd 90					sub b 
0fce 3c					inc a		;?? 
0fcf 3c					inc a		;?? 
0fd0 3c					inc a		;?? 
0fd1			 
0fd1 06 00				ld b,0 
0fd3 4f					ld c,a 
0fd4			 
0fd4				if DEBUG_INPUT 
0fd4					push af 
0fd4					ld a, 'i' 
0fd4					ld (debug_mark),a 
0fd4					pop af 
0fd4			;		CALLMONITOR 
0fd4				endif 
0fd4 d1					pop de 
0fd5 e1					pop hl 
0fd6				if DEBUG_INPUT 
0fd6					push af 
0fd6					ld a, 'I' 
0fd6					ld (debug_mark),a 
0fd6					pop af 
0fd6			;		CALLMONITOR 
0fd6				endif 
0fd6 ed b8				lddr 
0fd8				 
0fd8			 
0fd8			 
0fd8					; TODO have a key for insert/overwrite mode???? 
0fd8 c1					pop bc 
0fd9 e1					pop hl 
0fda 71					ld (hl), c		; otherwise overwrite current char 
0fdb					 
0fdb			 
0fdb			 
0fdb			 
0fdb 3a 5b ee				ld a, (input_cursor) 
0fde 3c					inc  a 		; TODO check overflow 
0fdf 32 5b ee				ld (input_cursor), a 
0fe2			 
0fe2 3a 68 ee				ld a, (input_at_cursor) 
0fe5 3c					inc a 
0fe6 32 68 ee				ld (input_at_cursor), a 
0fe9			 
0fe9 c3 05 0e				jp .is1 
0fec			 
0fec			.endinput:	; TODO look for end of string 
0fec			 
0fec					; add trailing space for end of token 
0fec			 
0fec 2a 6d ee				ld hl, (input_start) 
0fef 3a 60 ee				ld a,(input_len) 
0ff2 cd a7 0d				call addatohl 
0ff5 3e 20				ld a, ' ' 
0ff7 77					ld (hl),a 
0ff8					; TODO eof of parse marker 
0ff8			 
0ff8 23					inc hl 
0ff9 3e 00				ld a, 0 
0ffb 77					ld (hl),a 
0ffc			 
0ffc			 
0ffc c9					ret 
0ffd			 
0ffd .. 00		.iblank: db " ",0 
0fff			 
0fff			 
0fff 32 6a ee		input_str_prev:	ld (input_at_pos), a 
1002 22 6d ee				ld (input_start), hl 
1005 3e 01				ld a,1			; add cursor 
1007 77					ld (hl),a 
1008 23					inc hl 
1009 3e 00				ld a,0 
100b 77					ld (hl),a 
100c 22 6f ee				ld (input_ptr), hl 
100f 7a					ld a,d 
1010 32 6c ee				ld (input_size), a 
1013 3e 00				ld a,0 
1015 32 5b ee				ld (input_cursor),a 
1018			.instr1:	 
1018			 
1018					; TODO do block cursor 
1018					; TODO switch cursor depending on the modifer key 
1018			 
1018					; update cursor shape change on key hold 
1018			 
1018 2a 6f ee				ld hl, (input_ptr) 
101b 2b					dec hl 
101c 3a ca eb				ld a,(cursor_shape) 
101f 77					ld (hl), a 
1020			 
1020					; display entered text 
1020 3a 6a ee				ld a,(input_at_pos) 
1023 cd 05 5b		            	CALL fLCD_Pos       ;Position cursor to location in A 
1026 ed 5b 6d ee	            	LD   de, (input_start) 
102a cd fa 5a		            	CALL fLCD_Str       ;Display string pointed to by DE 
102d			 
102d cd f0 5b				call cin 
1030 fe 00				cp 0 
1032 28 e4				jr z, .instr1 
1034			 
1034					; proecess keyboard controls first 
1034			 
1034 2a 6f ee				ld hl,(input_ptr) 
1037			 
1037 fe 0d				cp KEY_CR	 ; pressing enter ends input 
1039 28 5a				jr z, .instrcr 
103b			 
103b fe 08				cp KEY_BS 	; back space 
103d 20 0f				jr nz, .instr2 
103f					; process back space 
103f			 
103f					; TODO stop back space if at start of string 
103f 2b					dec hl 
1040 2b					dec hl ; to over write cursor 
1041 3a ca eb				ld a,(cursor_shape) 
1044					;ld a,0 
1044 77					ld (hl),a 
1045 23					inc hl 
1046 3e 20				ld a," " 
1048 77					ld (hl),a 
1049 22 6f ee				ld (input_ptr),hl 
104c					 
104c			 
104c 18 ca				jr .instr1 
104e			 
104e fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
1050 20 06				jr nz, .instr3 
1052 2b					dec hl 
1053 22 6f ee				ld (input_ptr),hl 
1056 18 c0				jr .instr1 
1058				 
1058 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
105a 20 06				jr nz, .instr4 
105c 23					inc hl 
105d 22 6f ee				ld (input_ptr),hl 
1060 18 b6				jr .instr1 
1062			 
1062 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
1064 20 06				jr nz, .instr5 
1066 2b					dec hl 
1067 22 6f ee				ld (input_ptr),hl 
106a 18 ac				jr .instr1 
106c			 
106c fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
106e 20 06				jr nz, .instr6 
1070 2b					dec hl 
1071 22 6f ee				ld (input_ptr),hl 
1074 18 a2				jr .instr1 
1076 fe 05		.instr6:        cp KEY_UP      ; recall last command 
1078 20 0b				jr nz, .instrnew 
107a			 
107a 21 02 e3			ld hl, scratch 
107d 11 28 e7			ld de, os_last_cmd 
1080 cd 9e 10			call strcpy 
1083 18 93				jr .instr1 
1085			 
1085			 
1085			.instrnew:	; no special key pressed to see if we have room to store it 
1085			 
1085					; TODO do string size test 
1085			 
1085 2b					dec hl ; to over write cursor 
1086 77					ld (hl),a 
1087 23					inc hl 
1088 3a ca eb				ld a,(cursor_shape) 
108b 77					ld (hl),a 
108c 23					inc hl 
108d 3e 00				ld a,0 
108f 77					ld (hl),a 
1090			 
1090 22 6f ee				ld (input_ptr),hl 
1093					 
1093 18 83				jr .instr1 
1095 2b			.instrcr:	dec hl		; remove cursor 
1096 3e 20				ld a,' '	; TODO add a trailing space for safety 
1098 77					ld (hl),a 
1099 23					inc hl 
109a 3e 00				ld a,0 
109c 77					ld (hl),a 
109d			 
109d			 
109d					; if at end of line scroll up    
109d					; TODO detecting only end of line 4 for scroll up  
109d			 
109d					;ld   
109d			 
109d c9					ret 
109e			 
109e			 
109e			; strcpy hl = dest, de source 
109e			 
109e 1a			strcpy:   LD   A, (DE)        ;Get character from string 
109f b7			            OR   A              ;Null terminator? 
10a0 c8			            RET  Z              ;Yes, so finished 
10a1 1a					ld a,(de) 
10a2 77					ld (hl),a 
10a3 13			            INC  DE             ;Point to next character 
10a4 23					inc hl 
10a5 18 f7		            JR   strcpy       ;Repeat 
10a7 c9					ret 
10a8			 
10a8			 
10a8			; TODO string_at  
10a8			; pass string which starts with lcd offset address and then null term string 
10a8			 
10a8			; TODO string to dec 
10a8			; TODO string to hex 
10a8			; TODO byte to string hex 
10a8			; TODO byte to string dec 
10a8			 
10a8			 
10a8			 
10a8			; from z80uartmonitor 
10a8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
10a8			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
10a8			; pass hl for where to put the text 
10a8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
10a8 c5			hexout:	PUSH BC 
10a9 f5					PUSH AF 
10aa 47					LD B, A 
10ab					; Upper nybble 
10ab cb 3f				SRL A 
10ad cb 3f				SRL A 
10af cb 3f				SRL A 
10b1 cb 3f				SRL A 
10b3 cd c3 10				CALL tohex 
10b6 77					ld (hl),a 
10b7 23					inc hl	 
10b8					 
10b8					; Lower nybble 
10b8 78					LD A, B 
10b9 e6 0f				AND 0FH 
10bb cd c3 10				CALL tohex 
10be 77					ld (hl),a 
10bf 23					inc hl	 
10c0					 
10c0 f1					POP AF 
10c1 c1					POP BC 
10c2 c9					RET 
10c3					 
10c3			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
10c3			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
10c3			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
10c3			tohex: 
10c3 e5					PUSH HL 
10c4 d5					PUSH DE 
10c5 16 00				LD D, 0 
10c7 5f					LD E, A 
10c8 21 d0 10				LD HL, .DATA 
10cb 19					ADD HL, DE 
10cc 7e					LD A, (HL) 
10cd d1					POP DE 
10ce e1					POP HL 
10cf c9					RET 
10d0			 
10d0			.DATA: 
10d0 30					DEFB	30h	; 0 
10d1 31					DEFB	31h	; 1 
10d2 32					DEFB	32h	; 2 
10d3 33					DEFB	33h	; 3 
10d4 34					DEFB	34h	; 4 
10d5 35					DEFB	35h	; 5 
10d6 36					DEFB	36h	; 6 
10d7 37					DEFB	37h	; 7 
10d8 38					DEFB	38h	; 8 
10d9 39					DEFB	39h	; 9 
10da 41					DEFB	41h	; A 
10db 42					DEFB	42h	; B 
10dc 43					DEFB	43h	; C 
10dd 44					DEFB	44h	; D 
10de 45					DEFB	45h	; E 
10df 46					DEFB	46h	; F 
10e0			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
10e0			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
10e0			;;    subtract $30, if result > 9 then subtract $7 more 
10e0			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
10e0			atohex: 
10e0 d6 30				SUB $30 
10e2 fe 0a				CP 10 
10e4 f8					RET M		; If result negative it was 0-9 so we're done 
10e5 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
10e7 c9					RET		 
10e8			 
10e8			 
10e8			 
10e8			 
10e8			; Get 2 ASCII characters as hex byte from pointer in hl 
10e8			 
10e8			BYTERD: 
10e8 16 00			LD	D,00h		;Set up 
10ea cd f2 10			CALL	HEXCON		;Get byte and convert to hex 
10ed 87				ADD	A,A		;First nibble so 
10ee 87				ADD	A,A		;multiply by 16 
10ef 87				ADD	A,A		; 
10f0 87				ADD	A,A		; 
10f1 57				LD	D,A		;Save hi nibble in D 
10f2			HEXCON: 
10f2 7e				ld a, (hl)		;Get next chr 
10f3 23				inc hl 
10f4 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
10f6 fe 0a			CP	00Ah		;Is it 0-9 ? 
10f8 38 02			JR	C,NALPHA	;If so miss next bit 
10fa d6 07			SUB	007h		;Else convert alpha 
10fc			NALPHA: 
10fc b2				OR	D		;Add hi nibble back 
10fd c9				RET			; 
10fe			 
10fe			 
10fe			; 
10fe			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
10fe			; Since the routines get_byte and therefore get_nibble are called, only valid 
10fe			; characters (0-9a-f) are accepted. 
10fe			; 
10fe			;get_word        push    af 
10fe			;                call    get_byte        ; Get the upper byte 
10fe			;                ld      h, a 
10fe			;                call    get_byte        ; Get the lower byte 
10fe			;                ld      l, a 
10fe			;                pop     af 
10fe			;                ret 
10fe			; 
10fe			; Get a byte in hexadecimal notation. The result is returned in A. Since 
10fe			; the routine get_nibble is used only valid characters are accepted - the  
10fe			; input routine only accepts characters 0-9a-f. 
10fe			; 
10fe c5			get_byte:        push    bc              ; Save contents of B (and C) 
10ff 7e					ld a,(hl) 
1100 23					inc hl 
1101 cd 26 11		                call    nibble2val      ; Get upper nibble 
1104 cb 07		                rlc     a 
1106 cb 07		                rlc     a 
1108 cb 07		                rlc     a 
110a cb 07		                rlc     a 
110c 47			                ld      b, a            ; Save upper four bits 
110d 7e					ld a,(hl) 
110e cd 26 11		                call    nibble2val      ; Get lower nibble 
1111 b0			                or      b               ; Combine both nibbles 
1112 c1			                pop     bc              ; Restore B (and C) 
1113 c9			                ret 
1114			; 
1114			; Get a hexadecimal digit from the serial line. This routine blocks until 
1114			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
1114			; to the serial line interface. The lower 4 bits of A contain the value of  
1114			; that particular digit. 
1114			; 
1114			;get_nibble      ld a,(hl)           ; Read a character 
1114			;                call    to_upper        ; Convert to upper case 
1114			;                call    is_hex          ; Was it a hex digit? 
1114			;                jr      nc, get_nibble  ; No, get another character 
1114			 ;               call    nibble2val      ; Convert nibble to value 
1114			 ;               call    print_nibble 
1114			 ;               ret 
1114			; 
1114			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
1114			; A valid hexadecimal digit is denoted by a set C flag. 
1114			; 
1114			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
1114			;                ret     nc              ; Yes 
1114			;                cp      '0'             ; Less than '0'? 
1114			;                jr      nc, is_hex_1    ; No, continue 
1114			;                ccf                     ; Complement carry (i.e. clear it) 
1114			;                ret 
1114			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
1114			;                ret     c               ; Yes 
1114			;                cp      'A'             ; Less than 'A'? 
1114			;                jr      nc, is_hex_2    ; No, continue 
1114			;                ccf                     ; Yes - clear carry and return 
1114			;                ret 
1114			;is_hex_2        scf                     ; Set carry 
1114			;                ret 
1114			; 
1114			; Convert a single character contained in A to upper case: 
1114			; 
1114 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
1116 d8			                ret     c 
1117 fe 7b		                cp      'z' + 1         ; > 'z'? 
1119 d0			                ret     nc              ; Nothing to do, either 
111a e6 5f		                and     $5f             ; Convert to upper case 
111c c9			                ret 
111d			 
111d			 
111d			to_lower: 
111d			 
111d			   ; if char is in [A-Z] make it lower case 
111d			 
111d			   ; enter : a = char 
111d			   ; exit  : a = lower case char 
111d			   ; uses  : af 
111d			 
111d fe 41		   cp 'A' 
111f d8			   ret c 
1120			    
1120 fe 5b		   cp 'Z'+1 
1122 d0			   ret nc 
1123			    
1123 f6 20		   or $20 
1125 c9			   ret 
1126			 
1126			; 
1126			; Expects a hexadecimal digit (upper case!) in A and returns the 
1126			; corresponding value in A. 
1126			; 
1126 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
1128 38 02		                jr      c, nibble2val_1 ; Yes 
112a d6 07		                sub     7               ; Adjust for A-F 
112c d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
112e e6 0f		                and     $f              ; Only return lower 4 bits 
1130 c9			                ret 
1131			; 
1131			; Print_nibble prints a single hex nibble which is contained in the lower  
1131			; four bits of A: 
1131			; 
1131			;print_nibble    push    af              ; We won't destroy the contents of A 
1131			;                and     $f              ; Just in case... 
1131			;                add     a, '0'             ; If we have a digit we are done here. 
1131			;                cp      '9' + 1         ; Is the result > 9? 
1131			;                jr      c, print_nibble_1 
1131			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1131			;print_nibble_1  call    putc            ; Print the nibble and 
1131			;                pop     af              ; restore the original value of A 
1131			;                ret 
1131			;; 
1131			;; Send a CR/LF pair: 
1131			; 
1131			;crlf            push    af 
1131			;                ld      a, cr 
1131			;                call    putc 
1131			;                ld      a, lf 
1131			;                call    putc 
1131			;                pop     af 
1131			;                ret 
1131			; 
1131			; Print_word prints the four hex digits of a word to the serial line. The  
1131			; word is expected to be in HL. 
1131			; 
1131			;print_word      push    hl 
1131			;                push    af 
1131			;                ld      a, h 
1131			;                call    print_byte 
1131			;                ld      a, l 
1131			;                call    print_byte 
1131			;                pop     af 
1131			;                pop     hl 
1131			;                ret 
1131			; 
1131			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1131			; The byte to be printed is expected to be in A. 
1131			; 
1131			;print_byte      push    af              ; Save the contents of the registers 
1131			;                push    bc 
1131			;                ld      b, a 
1131			;                rrca 
1131			;                rrca 
1131			;                rrca 
1131			;                rrca 
1131			;                call    print_nibble    ; Print high nibble 
1131			;                ld      a, b 
1131			;                call    print_nibble    ; Print low nibble 
1131			;                pop     bc              ; Restore original register contents 
1131			;                pop     af 
1131			;                ret 
1131			 
1131			 
1131			 
1131			 
1131			 
1131			fourehexhl:  
1131 7e				ld a,(hl) 
1132 cd e0 10			call atohex 
1135 cb 3f				SRL A 
1137 cb 3f				SRL A 
1139 cb 3f				SRL A 
113b cb 3f				SRL A 
113d 47				ld b, a 
113e 23				inc hl 
113f 7e				ld a,(hl) 
1140 23				inc hl 
1141 cd e0 10			call atohex 
1144 80				add b 
1145 57				ld d,a 
1146 7e				ld a,(hl) 
1147 cd e0 10			call atohex 
114a cb 3f				SRL A 
114c cb 3f				SRL A 
114e cb 3f				SRL A 
1150 cb 3f				SRL A 
1152 47				ld b, a 
1153 23				inc hl 
1154 7e				ld a,(hl) 
1155 23				inc hl 
1156 cd e0 10			call atohex 
1159 80				add b 
115a 5f				ld e, a 
115b d5				push de 
115c e1				pop hl 
115d c9				ret 
115e			 
115e			; pass hl. returns z set if the byte at hl is a digit 
115e			;isdigithl:  
115e			;	push bc 
115e			;	ld a,(hl) 
115e			;	cp ':' 
115e			;	jr nc, .isdf 		; > 
115e			;	cp '0' 
115e			;	jr c, .isdf		; < 
115e			; 
115e			;	; TODO find a better way to set z 
115e			; 
115e			;	ld b,a 
115e			;	cp b 
115e			;	pop bc 
115e			;	ret 
115e			; 
115e			;.isdf:	; not digit so clear z 
115e			; 
115e			;	; TODO find a better way to unset z 
115e			; 
115e			;	ld b,a 
115e			;	inc b 
115e			;	cp b 
115e			; 
115e			;	pop bc 
115e			;	ret 
115e				 
115e				 
115e			 
115e			 
115e			; pass hl as the four byte address to load 
115e			 
115e			get_word_hl:  
115e e5				push hl 
115f cd fe 10			call get_byte 
1162				 
1162 47				ld b, a 
1163			 
1163 e1				pop hl 
1164 23				inc hl 
1165 23				inc hl 
1166			 
1166			; TODO not able to handle a-f  
1166 7e				ld a,(hl) 
1167			;	;cp ':' 
1167			;	cp 'g' 
1167			;	jr nc, .single_byte_hl 		; > 
1167			;	cp 'G' 
1167			;	jr nc, .single_byte_hl 		; > 
1167			;	cp '0' 
1167			;	jr c, .single_byte_hl		; < 
1167			 
1167				;call isdigithl 
1167 fe 00			cp 0 
1169 28 06			jr z, .single_byte_hl 
116b			 
116b			.getwhln:   ; hex word so get next byte 
116b			 
116b cd fe 10			call get_byte 
116e 6f				ld l, a 
116f 60				ld h,b 
1170 c9				ret 
1171 68			.single_byte_hl:   ld l,b 
1172 26 00				ld h,0 
1174 c9					ret 
1175			 
1175			 
1175			 
1175			 
1175 21 30 19			ld hl,asc+1 
1178			;	ld a, (hl) 
1178			;	call nibble2val 
1178 cd fe 10			call get_byte 
117b			 
117b			;	call fourehexhl 
117b 32 36 e3			ld (scratch+52),a 
117e				 
117e 21 34 e3			ld hl,scratch+50 
1181 22 25 e6			ld (os_cur_ptr),hl 
1184			 
1184 c9				ret 
1185			 
1185			 
1185			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
1185			 
1185			; Decimal Unsigned Version 
1185			 
1185			;Number in a to decimal ASCII 
1185			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
1185			;Example: display a=56 as "056" 
1185			;input: a = number 
1185			;Output: a=0,value of a in the screen 
1185			;destroys af,bc (don't know about hl and de) 
1185			DispAToASCII: 
1185 0e 9c			ld	c,-100 
1187 cd 91 11			call	.Na1 
118a 0e f6			ld	c,-10 
118c cd 91 11			call	.Na1 
118f 0e ff			ld	c,-1 
1191 06 2f		.Na1:	ld	b,'0'-1 
1193 04			.Na2:	inc	b 
1194 81				add	a,c 
1195 38 fc			jr	c,.Na2 
1197 91				sub	c		;works as add 100/10/1 
1198 f5				push af		;safer than ld c,a 
1199 78				ld	a,b		;char is in b 
119a			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
119a f1				pop af		;safer than ld a,c 
119b c9				ret 
119c			 
119c			; Decimal Signed Version 
119c			 
119c			; DispA 
119c			; -------------------------------------------------------------- 
119c			; Converts a signed integer value to a zero-terminated ASCII 
119c			; string representative of that value (using radix 10). 
119c			; -------------------------------------------------------------- 
119c			; INPUTS: 
119c			;     HL     Value to convert (two's complement integer). 
119c			;     DE     Base address of string destination. (pointer). 
119c			; -------------------------------------------------------------- 
119c			; OUTPUTS: 
119c			;     None 
119c			; -------------------------------------------------------------- 
119c			; REGISTERS/MEMORY DESTROYED 
119c			; AF HL 
119c			; -------------------------------------------------------------- 
119c			 
119c			;DispHLToASCII: 
119c			;   push    de 
119c			;   push    bc 
119c			; 
119c			;; Detect sign of HL. 
119c			;    bit    7, h 
119c			;    jr     z, ._DoConvert 
119c			; 
119c			;; HL is negative. Output '-' to string and negate HL. 
119c			;    ld     a, '-' 
119c			;    ld     (de), a 
119c			;    inc    de 
119c			; 
119c			;; Negate HL (using two's complement) 
119c			;    xor    a 
119c			;    sub    l 
119c			;    ld     l, a 
119c			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
119c			;    sbc    a, h 
119c			;    ld     h, a 
119c			; 
119c			;; Convert HL to digit characters 
119c			;._DoConvert: 
119c			;    ld     b, 0     ; B will count character length of number 
119c			;-   ld     a, 10 
119c			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
119c			;    push   af 
119c			;    inc    b 
119c			;    ld     a, h 
119c			;    or     l 
119c			;    jr     nz, - 
119c			; 
119c			;; Retrieve digits from stack 
119c			;-   pop    af 
119c			;    or     $30 
119c			;    ld     (de), a 
119c			;    inc    de 
119c			;    djnz   - 
119c			; 
119c			;; Terminate string with NULL 
119c			;    xor    a 
119c			;    ld     (de), a 
119c			; 
119c			;    pop    bc 
119c			;    pop    de 
119c			;    ret 
119c			 
119c			;Comments 
119c			; 
119c			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
119c			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
119c			;    Note that the output string will not be fixed-width. 
119c			; 
119c			;Example Usage 
119c			; 
119c			;    ld    hl, -1004 
119c			;    ld    de, OP1 
119c			;    call  DispA 
119c			;    ld    hl, OP1 
119c			;    syscall  PutS 
119c			 
119c			 
119c			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
119c			 
119c			 
119c			;Converts an ASCII string to an unsigned 16-bit integer 
119c			;Quits when it reaches a non-decimal digit 
119c			 
119c			string_to_uint16: 
119c			atoui_16: 
119c			;Input: 
119c			;     DE points to the string 
119c			;Outputs: 
119c			;     HL is the result 
119c			;     A is the 8-bit value of the number 
119c			;     DE points to the byte after the number 
119c			;Destroys: 
119c			;     BC 
119c			;       if the string is non-empty, BC is HL/10 
119c			;Size:  24 bytes 
119c			;Speed: 42+d(104+{0,9}) 
119c			;       d is the number of digits in the number 
119c			;       max is 640 cycles for a 5 digit number 
119c			;Assuming no leading zeros: 
119c			;1 digit:  146cc 
119c			;2 digit:  250cc 
119c			;3 digit:  354cc or 363cc (avg: 354.126cc) 
119c			;4 digit:  458cc or 467cc (avg: 458.27cc) 
119c			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
119c			;avg: 544.81158447265625cc (544+13297/16384) 
119c			;=============================================================== 
119c 21 00 00		  ld hl,0 
119f			.u16a: 
119f 1a			  ld a,(de) 
11a0 d6 30		  sub 30h 
11a2 fe 0a		  cp 10 
11a4 d0			  ret nc 
11a5 13			  inc de 
11a6 44			  ld b,h 
11a7 4d			  ld c,l 
11a8 29			  add hl,hl 
11a9 29			  add hl,hl 
11aa 09			  add hl,bc 
11ab 29			  add hl,hl 
11ac 85			  add a,l 
11ad 6f			  ld l,a 
11ae 30 ef		  jr nc,.u16a 
11b0 24			  inc h 
11b1 c3 9f 11		  jp .u16a 
11b4			 
11b4			 
11b4			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
11b4			 
11b4			;written by Zeda 
11b4			;Converts a 16-bit unsigned integer to an ASCII string. 
11b4			 
11b4			uitoa_16: 
11b4			;Input: 
11b4			;   DE is the number to convert 
11b4			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
11b4			;Output: 
11b4			;   HL points to the null-terminated ASCII string 
11b4			;      NOTE: This isn't necessarily the same as the input HL. 
11b4 d5			  push de 
11b5 c5			  push bc 
11b6 f5			  push af 
11b7 eb			  ex de,hl 
11b8			 
11b8 01 f0 d8		  ld bc,-10000 
11bb 3e 2f		  ld a,'0'-1 
11bd 3c			  inc a 
11be 09			  add hl,bc  
11bf 38 fc		   jr c,$-2 
11c1 12			  ld (de),a 
11c2 13			  inc de 
11c3			 
11c3 01 e8 03		  ld bc,1000 
11c6 3e 3a		  ld a,'9'+1 
11c8 3d			  dec a  
11c9 09			  add hl,bc  
11ca 30 fc		   jr nc,$-2 
11cc 12			  ld (de),a 
11cd 13			  inc de 
11ce			 
11ce 01 9c ff		  ld bc,-100 
11d1 3e 2f		  ld a,'0'-1 
11d3 3c			  inc a  
11d4 09			  add hl,bc  
11d5 38 fc		   jr c,$-2 
11d7 12			  ld (de),a 
11d8 13			  inc de 
11d9			 
11d9 7d			  ld a,l 
11da 26 3a		  ld h,'9'+1 
11dc 25			  dec h  
11dd c6 0a		  add a,10  
11df 30 fb		   jr nc,$-3 
11e1 c6 30		  add a,'0' 
11e3 eb			  ex de,hl 
11e4 72			  ld (hl),d 
11e5 23			  inc hl 
11e6 77			  ld (hl),a 
11e7 23			  inc hl 
11e8 36 00		  ld (hl),0 
11ea			 
11ea			;Now strip the leading zeros 
11ea 0e fa		  ld c,-6 
11ec 09			  add hl,bc 
11ed 3e 30		  ld a,'0' 
11ef 23			  inc hl  
11f0 be			  cp (hl)  
11f1 28 fc		  jr z,$-2 
11f3			 
11f3			;Make sure that the string is non-empty! 
11f3 7e			  ld a,(hl) 
11f4 b7			  or a 
11f5 20 01		  jr nz,.atoub 
11f7 2b			  dec hl 
11f8			.atoub: 
11f8			 
11f8 f1			  pop af 
11f9 c1			  pop bc 
11fa d1			  pop de 
11fb c9			  ret 
11fc			 
11fc			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
11fc			 
11fc			toUpper: 
11fc			;A is the char. 
11fc			;If A is a lowercase letter, this sets it to the matching uppercase 
11fc			;18cc or 30cc or 41cc 
11fc			;avg: 26.75cc 
11fc fe 61		  cp 'a' 
11fe d8			  ret c 
11ff fe 7b		  cp 'z'+1 
1201 d0			  ret nc 
1202 d6 20		  sub 'a'-'A' 
1204 c9			  ret 
1205			 
1205			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1205			 
1205			; String Length 
1205			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1205			 
1205			; Get the length of the null-terminated string starting at $8000 hl 
1205			;    LD     HL, $8000 
1205			 
1205			strlenz: 
1205			 
1205 af			    XOR    A               ; Zero is the value we are looking for. 
1206 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1207 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1208			                           ; 65, 536 bytes (the entire addressable memory space). 
1208 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
120a			 
120a			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
120a 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
120b 6f			    LD     L, A             ; number of bytes 
120c ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
120e 2b			    DEC    HL              ; Compensate for null. 
120f c9				ret 
1210			 
1210			; Get the length of the A terminated string starting at $8000 hl 
1210			;    LD     HL, $8000 
1210			 
1210			strlent: 
1210			 
1210			                  ; A is the value we are looking for. 
1210 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1212 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1214			                           ; 65, 536 bytes (the entire addressable memory space). 
1214 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1216			 
1216			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1216 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1218 2e 00		    LD     L, 0             ; number of bytes 
121a ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
121c 2b			    DEC    HL              ; Compensate for null. 
121d c9				ret 
121e			 
121e			 
121e			;Comparing Strings 
121e			 
121e			;IN    HL     Address of string1. 
121e			;      DE     Address of string2. 
121e			 
121e			; doc given but wrong??? 
121e			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
121e			;      carry  Set if string1 > string2, reset if string1 <= string2. 
121e			; tested 
121e			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
121e			 
121e			strcmp_old: 
121e e5			    PUSH   HL 
121f d5			    PUSH   DE 
1220			 
1220 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1221 be			    CP     (HL)            ; (want to minimize work). 
1222 38 01		    JR     C, Str1IsBigger 
1224 7e			    LD     A, (HL) 
1225			 
1225			Str1IsBigger: 
1225 4f			    LD     C, A             ; Put length in BC 
1226 06 00		    LD     B, 0 
1228 13			    INC    DE              ; Increment pointers to meat of string. 
1229 23			    INC    HL 
122a			 
122a			CmpLoop: 
122a 1a			    LD     A, (DE)          ; Compare bytes. 
122b ed a1		    CPI 
122d 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
122f 13			    INC    DE              ; Update pointer. 
1230 ea 2a 12		    JP     PE, CmpLoop 
1233			 
1233 d1			    POP    DE 
1234 e1			    POP    HL 
1235 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
1236 be			    CP     (HL) 
1237 c9			    RET 
1238			 
1238			NoMatch: 
1238 2b			    DEC    HL 
1239 be			    CP     (HL)            ; Compare again to affect carry. 
123a d1			    POP    DE 
123b e1			    POP    HL 
123c c9			    RET 
123d			 
123d			;; test strmp 
123d			; 
123d			;ld de, .str1 
123d			;ld hl, .str2 
123d			;call strcmp 
123d			;jr z, .z1 
123d			;;this 
123d			;	if DEBUG_FORTH_WORDS 
123d			;		DMARK "NZ1" 
123d			;		CALLMONITOR 
123d			;	endif 
123d			;.z1: 
123d			; 
123d			;	if DEBUG_FORTH_WORDS 
123d			;		DMARK "ZZ1" 
123d			;		CALLMONITOR 
123d			;	endif 
123d			; 
123d			;ld de, .str1 
123d			;ld hl, .str1 
123d			;call strcmp 
123d			;jr z, .z2 
123d			;;this 
123d			;	if DEBUG_FORTH_WORDS 
123d			;		DMARK "NZ2" 
123d			;		CALLMONITOR 
123d			;	endif 
123d			;.z2: 
123d			; 
123d			;	if DEBUG_FORTH_WORDS 
123d			;		DMARK "ZZ2" 
123d			;		CALLMONITOR 
123d			;	endif 
123d			; 
123d			;ld de, .str1 
123d			;ld hl, .str2 
123d			;call strcmp 
123d			;jr c, .c1 
123d			; 
123d			;	if DEBUG_FORTH_WORDS 
123d			;		DMARK "Nc1" 
123d			;		CALLMONITOR 
123d			;	endif 
123d			;.c1: 
123d			;;this 
123d			;	if DEBUG_FORTH_WORDS 
123d			;		DMARK "cc1" 
123d			;		CALLMONITOR 
123d			;	endif 
123d			; 
123d			;ld de, .str1 
123d			;ld hl, .str1 
123d			;call strcmp 
123d			;jr c, .c2 
123d			;;this 
123d			;	if DEBUG_FORTH_WORDS 
123d			;		DMARK "Nc2" 
123d			;		CALLMONITOR 
123d			;	endif 
123d			;.c2: 
123d			; 
123d			;	if DEBUG_FORTH_WORDS 
123d			;		DMARK "cc2" 
123d			;		CALLMONITOR 
123d			;	endif 
123d			;	NEXTW 
123d			;.str1:   db "string1",0 
123d			;.str2:   db "string2",0 
123d			 
123d			; only care about direct match or not 
123d			; hl and de strings 
123d			; zero set if the same 
123d			 
123d			strcmp: 
123d 1a				ld a, (de) 
123e be				cp (hl) 
123f 28 02			jr z, .ssame 
1241 b7				or a 
1242 c9				ret 
1243			 
1243			.ssame:  
1243 fe 00			cp 0 
1245 c8				ret z 
1246			 
1246 23				inc hl 
1247 13				inc de 
1248 18 f3			jr strcmp 
124a				 
124a				 
124a			 
124a			 
124a			 
124a			 
124a			; eof 
124a			 
124a			 
124a			 
124a			 
124a			 
124a			 
# End of file firmware_strings.asm
124a			include "firmware_memory.asm"   ; malloc and free  
124a			 
124a			if DEBUG_FORTH_MALLOC_HIGH 
124a			.mallocsize: db "Wants malloc >256",0 
124a			.mallocasize: db "MALLOC gives >256",0 
124a			.malloczero: db "MALLOC gives zero",0 
124a			 
124a			malloc_guard_zerolen: 
124a				push hl 
124a				push de 
124a				push af 
124a			 
124a				ld de, 0 
124a			        call cmp16 
124a				jr nz, .lowalloz 
124a			 
124a				push hl 
124a				push de 
124a					ld hl, display_fb0 
124a					ld (display_fb_active), hl 
124a				call clear_display 
124a				ld a, 0 
124a				ld de, .malloczero 
124a				call str_at_display 
124a				call update_display 
124a				call delay1s 
124a				call delay1s 
124a				ld a, 0 
124a				ld (os_view_disable), a 
124a			 
124a				pop de 
124a				pop hl 
124a			 
124a				 
124a			 
124a				CALLMONITOR 
124a			.lowalloz: 
124a			 
124a			 
124a				pop af 
124a				pop de 
124a				pop hl 
124a			ret 
124a			 
124a			malloc_guard_entry: 
124a				push hl 
124a				push de 
124a				push af 
124a			 
124a			 	or a      ;clear carry flag 
124a				push hl 
124a				ld de, 255 
124a				sbc hl, de 
124a				jr c, .lowalloc 
124a			 
124a				push de 
124a					ld hl, display_fb0 
124a					ld (display_fb_active), hl 
124a				call clear_display 
124a				ld a, 0 
124a				ld de, .mallocsize 
124a				call str_at_display 
124a				call update_display 
124a				call delay1s 
124a				call delay1s 
124a				ld a, 0 
124a				ld (os_view_disable), a 
124a			 
124a				pop de 
124a				pop hl 
124a			 
124a				 
124a			 
124a				CALLMONITOR 
124a				jr .lowdone 
124a			.lowalloc: 
124a			 
124a			 
124a				pop hl 
124a			.lowdone:	pop af 
124a				pop de 
124a				pop hl 
124a			ret 
124a			 
124a			malloc_guard_exit: 
124a				push hl 
124a				push de 
124a				push af 
124a			 
124a			 	or a      ;clear carry flag 
124a				push hl 
124a				ld de, 255 
124a				sbc hl, de 
124a				jr c, .lowallocx 
124a			 
124a				push de 
124a					ld hl, display_fb0 
124a					ld (display_fb_active), hl 
124a				call clear_display 
124a				ld a, 0 
124a				ld de, .mallocasize 
124a				call str_at_display 
124a				call update_display 
124a				call delay1s 
124a				call delay1s 
124a				ld a, 0 
124a				ld (os_view_disable), a 
124a				pop de 
124a				pop hl 
124a			 
124a				CALLMONITOR 
124a				jr .lowdonex 
124a			.lowallocx: 
124a			 
124a				pop hl 
124a			.lowdonex:	pop af 
124a				pop de 
124a				pop hl 
124a			ret 
124a			endif 
124a			 
124a			if MALLOC_2 
124a			; Z80 Malloc and Free Functions 
124a			 
124a			; Malloc Function: 
124a			; Input: 
124a			;   HL: Size of block to allocate 
124a			; Output: 
124a			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
124a			 
124a			malloc: 
124a				 
124a			if DEBUG_FORTH_MALLOC_HIGH 
124a			call malloc_guard_entry 
124a			endif 
124a			 
124a			 
124a			 
124a			 
124a					if DEBUG_FORTH_MALLOC 
124a						DMARK "mal" 
124a						CALLMONITOR 
124a					endif 
124a			    push af            ; Save AF register 
124a			    ld a, l            ; Load low byte of size into A 
124a			    or h               ; Check if size is zero 
124a			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
124a			 
124a			    ; Allocate memory 
124a			    ld hl, (heap_start) ; Load start of heap into HL 
124a					if DEBUG_FORTH_MALLOC 
124a						DMARK "ma1" 
124a						CALLMONITOR 
124a					endif 
124a			    call malloc_internal ; Call internal malloc function 
124a			    pop af             ; Restore AF register 
124a			if DEBUG_FORTH_MALLOC_HIGH 
124a			call malloc_guard_exit 
124a			call malloc_guard_zerolen 
124a			endif 
124a			    ret                ; Return 
124a			 
124a			; Free Function: 
124a			; Input: 
124a			;   HL: Pointer to memory block to free 
124a			; Output: 
124a			;   None 
124a			 
124a			free: 
124a			    push af            ; Save AF register 
124a			    ld a, l            ; Load low byte of pointer into A 
124a			    or h               ; Check if pointer is NULL 
124a			    jp z, free_exit    ; If pointer is NULL, exit 
124a			 
124a			    ; Free memory 
124a			    ld hl, (heap_start) ; Load start of heap into HL 
124a			    call free_internal  ; Call internal free function 
124a			    pop af             ; Restore AF register 
124a			    ret                ; Return 
124a			 
124a			; Internal Malloc Function: 
124a			; Input: 
124a			;   HL: Size of block to allocate 
124a			; Output: 
124a			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
124a			 
124a			malloc_internal: 
124a			    ld bc, 2           ; Number of bytes to allocate for management overhead 
124a			    add hl, bc         ; Add management overhead to requested size 
124a			    ex de, hl          ; Save total size in DE, and keep it in HL 
124a					if DEBUG_FORTH_MALLOC 
124a						DMARK "ma2" 
124a						CALLMONITOR 
124a					endif 
124a			 
124a			    ; Search for free memory block 
124a			    ld de, (heap_end)  ; Load end of heap into DE 
124a			    ld bc, 0           ; Initialize counter 
124a			 
124a					if DEBUG_FORTH_MALLOC 
124a						DMARK "ma2" 
124a						CALLMONITOR 
124a					endif 
124a			malloc_search_loop: 
124a			    ; Check if current block is free 
124a			    ld a, (hl)         ; Load current block's status (free or used) 
124a			    cp 0               ; Compare with zero (free) 
124a			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
124a			 
124a			    ; Check if current block is large enough 
124a			    ld a, (hl+1)       ; Load high byte of block size 
124a			    cp l               ; Compare with low byte of requested size 
124a			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
124a			 
124a			    ld a, (hl+2)       ; Load low byte of block size 
124a			    cp h               ; Compare with high byte of requested size 
124a			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
124a			 
124a			    ; Mark block as used 
124a			    ld (hl), 0xFF      ; Set status byte to indicate used block 
124a			 
124a			    ; Calculate remaining space in block 
124a			    ld bc, 0           ; Clear BC 
124a			    add hl, bc         ; Increment HL to point to start of data block 
124a			    add hl, de         ; HL = HL + DE (total size) 
124a			    ld bc, 1           ; Number of bytes to allocate for management overhead 
124a			    add hl, bc         ; Add management overhead to start of data block 
124a			 
124a			    ; Save pointer to allocated block in HL 
124a			if DEBUG_FORTH_MALLOC_HIGH 
124a						DMARK "ma5" 
124a			call malloc_guard_exit 
124a			call malloc_guard_zerolen 
124a			endif 
124a			    ret 
124a			 
124a			malloc_skip_block_check: 
124a			    ; Move to the next block 
124a			    ld bc, 3           ; Size of management overhead 
124a			    add hl, bc         ; Move to the next block 
124a			    inc de             ; Increment counter 
124a			 
124a			    ; Check if we have reached the end of heap 
124a			    ld a, e            ; Load low byte of heap end address 
124a			    cp (hl)            ; Compare with low byte of current address 
124a			    jr nz, malloc_search_loop  ; If not equal, continue searching 
124a			    ld a, d            ; Load high byte of heap end address 
124a			    cp 0               ; Check if it's zero (end of memory) 
124a			    jr nz, malloc_search_loop  ; If not zero, continue searching 
124a			 
124a			    ; If we reached here, allocation failed 
124a			    xor a              ; Set result to NULL 
124a			if DEBUG_FORTH_MALLOC_HIGH 
124a						DMARK "ma6" 
124a			call malloc_guard_exit 
124a			call malloc_guard_zerolen 
124a			endif 
124a			    ret 
124a			malloc_exit: 
124a			if DEBUG_FORTH_MALLOC_HIGH 
124a						DMARK "ma7" 
124a			call malloc_guard_exit 
124a			call malloc_guard_zerolen 
124a			endif 
124a			    ret 
124a			 
124a			; Internal Free Function: 
124a			; Input: 
124a			;   HL: Pointer to memory block to free 
124a			; Output: 
124a			;   None 
124a			 
124a			free_internal: 
124a			    ld de, (heap_start) ; Load start of heap into DE 
124a			    ld bc, 0            ; Initialize counter 
124a			 
124a			free_search_loop: 
124a			    ; Check if current block contains the pointer 
124a			    ld a, l             ; Load low byte of pointer 
124a			    cp (hl+1)           ; Compare with high byte of current block's address 
124a			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
124a			    ld a, h             ; Load high byte of pointer 
124a			    cp (hl+2)           ; Compare with low byte of current block's address 
124a			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
124a			 
124a			    ; Mark block as free 
124a			    ld (hl), 0          ; Set status byte to indicate free block 
124a			    ret                 ; Return 
124a			 
124a			free_skip_block_check: 
124a			    ; Move to the next block 
124a			    ld bc, 3            ; Size of management overhead 
124a			    add hl, bc          ; Move to the next block 
124a			    inc de              ; Increment counter 
124a			 
124a			    ; Check if we have reached the end of heap 
124a			    ld a, e             ; Load low byte of heap end address 
124a			    cp (hl)             ; Compare with low byte of current address 
124a			    jr nz, free_search_loop  ; If not equal, continue searching 
124a			    ld a, d             ; Load high byte of heap end address 
124a			    cp 0                ; Check if it's zero (end of memory) 
124a			    jr nz, free_search_loop  ; If not zero, continue searching 
124a			 
124a			    ; If we reached here, pointer is not found in heap 
124a			    ret 
124a			 
124a			free_exit: 
124a			    ret                 ; Return 
124a			 
124a			; Define heap start and end addresses 
124a			;heap_start:    .dw 0xC000   ; Start of heap 
124a			;heap_end:      .dw 0xE000   ; End of heap 
124a			 
124a			endif 
124a			 
124a			 
124a			if MALLOC_1 
124a			 
124a			 
124a			 
124a			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
124a			 
124a			;moved to firmware.asm 
124a			;heap_start        .equ  0x9000      ; Starting address of heap 
124a			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
124a			 
124a			;      .org 0 
124a			;      jp    main 
124a			 
124a			 
124a			;      .org  0x100 
124a			;main: 
124a			;      ld    HL, 0x8100 
124a			;      ld    SP, HL 
124a			; 
124a			;      call  heap_init 
124a			; 
124a			;      ; Make some allocations 
124a			;      ld    HL, 12 
124a			;      call  malloc            ; Allocates 0x9004 
124a			; 
124a			;      ld    HL, 12 
124a			;      call  malloc            ; Allocates 0x9014 
124a			; 
124a			;      ld    HL, 12 
124a			;      call  malloc            ; Allocates 0x9024 
124a			; 
124a			;      ; Free some allocations 
124a			;      ld    HL, 0x9014 
124a			;      call  free 
124a			; 
124a			;      ld    HL, 0x9004 
124a			;      call  free 
124a			; 
124a			;      ld    HL, 0x9024 
124a			;      call  free 
124a			; 
124a			; 
124a			;      halt 
124a			 
124a			 
124a			;------------------------------------------------------------------------------ 
124a			;     heap_init                                                               : 
124a			;                                                                             : 
124a			; Description                                                                 : 
124a			;     Initialise the heap and make it ready for malloc and free operations.   : 
124a			;                                                                             : 
124a			;     The heap is maintained as a linked list, starting with an initial       : 
124a			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
124a			;     the first free block in the heap. Each block then points to the next    : 
124a			;     free block within the heap, and the free list ends at the first block   : 
124a			;     with a null pointer to the next free block.                             : 
124a			;                                                                             : 
124a			; Parameters                                                                  : 
124a			;     Inputs are compile-time only. Two defines which specify the starting    : 
124a			;     address of the heap and its size are required, along with a memory      : 
124a			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
124a			;     principally stores a pointer to the first free block in the heap.       : 
124a			;                                                                             : 
124a			; Returns                                                                     : 
124a			;     Nothing                                                                 : 
124a			;------------------------------------------------------------------------------ 
124a			heap_init: 
124a e5			      push  HL 
124b			 
124b			      ; Initialise free list struct 
124b 21 18 5c		      ld    HL, heap_start 
124e 22 13 5c		      ld    (free_list), HL 
1251 21 00 00		      ld    HL, 0 
1254 22 15 5c		      ld    (free_list+2), HL 
1257			 
1257			      ; Insert first free block at bottom of heap, consumes entire heap 
1257 21 e4 e2		      ld    HL, heap_start+heap_size-4 
125a 22 18 5c		      ld    (heap_start), HL        ; Next block (end of free list) 
125d 21 cc 86		      ld    HL, heap_size-4 
1260 22 1a 5c		      ld    (heap_start+2), HL      ; Block size 
1263			 
1263			      ; Insert end of free list block at top of heap - two null words will 
1263			      ; terminate the free list 
1263 21 00 00		      ld    HL, 0 
1266 22 e6 e2		      ld    (heap_start+heap_size-2), HL 
1269 22 e4 e2		      ld    (heap_start+heap_size-4), HL 
126c			 
126c e1			      pop   HL 
126d			 
126d c9			      ret 
126e			 
126e			 
126e			;------------------------------------------------------------------------------ 
126e			;     malloc                                                                  : 
126e			;                                                                             : 
126e			; Description                                                                 : 
126e			;     Allocates the wanted space from the heap and returns the address of the : 
126e			;     first useable byte of the allocation.                                   : 
126e			;                                                                             : 
126e			;     Allocations can happen in one of two ways:                              : 
126e			;                                                                             : 
126e			;     1. A free block may be found which is the exact size wanted. In this    : 
126e			;        case the block is removed from the free list and retuedn to the      : 
126e			;        caller.                                                              : 
126e			;     2. A free block may be found which is larger than the size wanted. In   : 
126e			;        this case, the larger block is split into two. The first portion of  : 
126e			;        this block will become the requested space by the malloc call and    : 
126e			;        is returned to the caller. The second portion becomes a new free     : 
126e			;        block, and the free list is adjusted to maintain continuity via this : 
126e			;        newly created block.                                                 : 
126e			;                                                                             : 
126e			;     malloc does not set any initial value in the allocated space, the       : 
126e			;     caller is required to do this as required.                              : 
126e			;                                                                             : 
126e			;     This implementation of malloc uses the stack exclusively, and is        : 
126e			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
126e			;     advisable to disable interrupts before calling malloc, and recommended  : 
126e			;     to avoid the use of malloc inside ISRs in general.                      : 
126e			;                                                                             : 
126e			;     NOTE: heap_init must be called before malloc and free can be used.      : 
126e			;                                                                             : 
126e			; Parameters                                                                  : 
126e			;     HL  Number of bytes wanted                                              : 
126e			;                                                                             : 
126e			; Returns                                                                     : 
126e			;     HL  Address of the first useable byte of the allocation                 : 
126e			;                                                                             : 
126e			; Flags                                                                       : 
126e			;     Z   Set if the allocation did not succeed, clear otherwise              : 
126e			;                                                                             : 
126e			; Stack frame                                                                 : 
126e			;       |             |                                                       : 
126e			;       +-------------+                                                       : 
126e			;       |     BC      |                                                       : 
126e			;       +-------------+                                                       : 
126e			;       |     DE      |                                                       : 
126e			;       +-------------+                                                       : 
126e			;       |     IX      |                                                       : 
126e			;       +-------------+                                                       : 
126e			;       |  prev_free  |                                                       : 
126e			;   +4  +-------------+                                                       : 
126e			;       |  this_free  |                                                       : 
126e			;   +2  +-------------+                                                       : 
126e			;       |  next_free  |                                                       : 
126e			;   +0  +-------------+                                                       : 
126e			;       |             |                                                       : 
126e			;                                                                             : 
126e			;------------------------------------------------------------------------------ 
126e			 
126e			 
126e			;malloc: 
126e			; 
126e			;	SAVESP ON 1 
126e			; 
126e			;	call malloc_code 
126e			; 
126e			;	CHECKSP ON 1 
126e			;	ret 
126e			 
126e			 
126e			malloc: 
126e c5			      push  BC 
126f d5			      push  DE 
1270 dd e5		      push  IX 
1272			if DEBUG_FORTH_MALLOC_HIGH 
1272			call malloc_guard_entry 
1272			endif 
1272			 
1272					if DEBUG_FORTH_MALLOC 
1272						DMARK "mal" 
1272						CALLMONITOR 
1272					endif 
1272 7c			      ld    A, H                    ; Exit if no space requested 
1273 b5			      or    L 
1274 ca 33 13		      jp    Z, malloc_early_exit 
1277			 
1277			;inc hl 
1277			;inc hl 
1277			;inc hl 
1277			; 
1277			;inc hl 
1277			;inc hl 
1277			;inc hl 
1277			;inc hl 
1277			;inc hl 
1277			;inc hl 
1277			;inc hl 
1277			;inc hl 
1277			;inc hl 
1277			 
1277			 
1277			 
1277			 
1277					if DEBUG_FORTH_MALLOC 
1277						DMARK "maA" 
1277						CALLMONITOR 
1277					endif 
1277			      ; Set up stack frame 
1277 eb			      ex    DE, HL 
1278 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
127b 39			      add   HL, SP 
127c f9			      ld    SP, HL 
127d dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1281 dd 39		      add   IX, SP 
1283			 
1283			      ; Setup initial state 
1283 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
1286 19			      add   HL, DE 
1287			 
1287 44			      ld    B, H                    ; Move want to BC 
1288 4d			      ld    C, L 
1289			 
1289 21 13 5c		      ld    HL, free_list           ; Store prev_free ptr to stack 
128c dd 75 04		      ld    (IX+4), L 
128f dd 74 05		      ld    (IX+5), H 
1292			 
1292 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
1293 23			      inc   HL 
1294 56			      ld    D, (HL) 
1295 dd 73 02		      ld    (IX+2), E 
1298 dd 72 03		      ld    (IX+3), D 
129b eb			      ex    DE, HL                  ; this_free ptr into HL 
129c			 
129c					if DEBUG_FORTH_MALLOC 
129c						DMARK "maB" 
129c						CALLMONITOR 
129c					endif 
129c			      ; Loop through free block list to find some space 
129c			malloc_find_space: 
129c 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
129d 23			      inc   HL 
129e 56			      ld    D, (HL) 
129f			 
129f 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
12a0 b3			      or    E 
12a1 ca 2d 13		      jp    Z, malloc_no_space 
12a4			 
12a4 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
12a7 dd 72 01		      ld    (IX+1), D 
12aa			 
12aa			      ; Does this block have enough space to make the allocation? 
12aa 23			      inc   HL                      ; Load free block size into DE 
12ab 5e			      ld    E, (HL) 
12ac 23			      inc   HL 
12ad 56			      ld    D, (HL) 
12ae			 
12ae eb			      ex    DE, HL                  ; Check size of block against want 
12af b7			      or    A                       ; Ensure carry flag clear 
12b0 ed 42		      sbc   HL, BC 
12b2 e5			      push  HL                      ; Store the result for later (new block size) 
12b3			 
12b3 ca 02 13		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
12b6 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
12b8			 
12b8			      ; this_free block is not big enough, setup ptrs to test next free block 
12b8 e1			      pop   HL                      ; Discard previous result 
12b9			 
12b9 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
12bc dd 66 03		      ld    H, (IX+3) 
12bf dd 75 04		      ld    (IX+4), L 
12c2 dd 74 05		      ld    (IX+5), H 
12c5			 
12c5 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
12c8 dd 66 01		      ld    H, (IX+1) 
12cb dd 75 02		      ld    (IX+2), L 
12ce dd 74 03		      ld    (IX+3), H 
12d1			 
12d1					if DEBUG_FORTH_MALLOC 
12d1						DMARK "MA>" 
12d1						CALLMONITOR 
12d1					endif 
12d1 18 c9		      jr    malloc_find_space 
12d3			 
12d3			      ; split a bigger block into two - requested size and remaining size 
12d3			malloc_alloc_split: 
12d3					if DEBUG_FORTH_MALLOC 
12d3						DMARK "MAs" 
12d3						CALLMONITOR 
12d3					endif 
12d3 eb			      ex    DE, HL                  ; Calculate address of new free block 
12d4 2b			      dec   HL 
12d5 2b			      dec   HL 
12d6 2b			      dec   HL 
12d7 09			      add   HL, BC 
12d8			 
12d8			      ; Create a new block and point it at next_free 
12d8 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
12db dd 56 01		      ld    D, (IX+1) 
12de			 
12de 73			      ld    (HL), E                 ; Store next_free ptr into new block 
12df 23			      inc   HL 
12e0 72			      ld    (HL), D 
12e1			 
12e1 d1			      pop   DE                      ; Store size of new block into new block 
12e2 23			      inc   HL 
12e3 73			      ld    (HL), E 
12e4 23			      inc   HL 
12e5 72			      ld    (HL), D 
12e6			 
12e6			      ; Update this_free ptr to point to new block 
12e6 2b			      dec   HL 
12e7 2b			      dec   HL 
12e8 2b			      dec   HL 
12e9			 
12e9 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
12ec dd 56 03		      ld    D, (IX+3) 
12ef			 
12ef dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
12f2 dd 74 03		      ld    (IX+3), H 
12f5			 
12f5			      ; Modify this_free block to be allocation 
12f5 eb			      ex    DE, HL 
12f6 af			      xor   A                       ; Null the next block ptr of allocated block 
12f7 77			      ld    (HL), A 
12f8 23			      inc   HL 
12f9 77			      ld    (HL), A 
12fa			 
12fa 23			      inc   HL                      ; Store want size into allocated block 
12fb 71			      ld    (HL), C 
12fc 23			      inc   HL 
12fd 70			      ld    (HL), B 
12fe 23			      inc   HL 
12ff e5			      push  HL                      ; Address of allocation to return 
1300			 
1300 18 19		      jr    malloc_update_links 
1302			 
1302			malloc_alloc_fit: 
1302 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1303			 
1303					if DEBUG_FORTH_MALLOC 
1303						DMARK "MAf" 
1303						CALLMONITOR 
1303					endif 
1303			      ; Modify this_free block to be allocation 
1303 eb			      ex    DE, HL 
1304 2b			      dec   HL 
1305 2b			      dec   HL 
1306 2b			      dec   HL 
1307			 
1307 af			      xor   A                       ; Null the next block ptr of allocated block 
1308 77			      ld    (HL), A 
1309 23			      inc   HL 
130a 77			      ld    (HL), A 
130b			 
130b 23			      inc   HL                      ; Store address of allocation to return 
130c 23			      inc   HL 
130d 23			      inc   HL 
130e e5			      push  HL 
130f			 
130f			      ; Copy next_free ptr to this_free, remove allocated block from free list 
130f dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
1312 dd 66 01		      ld    H, (IX+1) 
1315			 
1315 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1318 dd 74 03		      ld    (IX+3), H 
131b			 
131b			 
131b			malloc_update_links: 
131b			      ; Update prev_free ptr to point to this_free 
131b dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
131e dd 66 05		      ld    H, (IX+5) 
1321			 
1321 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1324 dd 56 03		      ld    D, (IX+3) 
1327			 
1327 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1328 23			      inc   HL 
1329 72			      ld    (HL), D 
132a			 
132a					if DEBUG_FORTH_MALLOC 
132a						DMARK "Mul" 
132a						CALLMONITOR 
132a					endif 
132a			      ; Clear the Z flag to indicate successful allocation 
132a 7a			      ld    A, D 
132b b3			      or    E 
132c			 
132c d1			      pop   DE                      ; Address of allocation 
132d					if DEBUG_FORTH_MALLOC 
132d						DMARK "MAu" 
132d						CALLMONITOR 
132d					endif 
132d			 
132d			malloc_no_space: 
132d 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
1330 39			      add   HL, SP 
1331 f9			      ld    SP, HL 
1332			 
1332 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1333					if DEBUG_FORTH_MALLOC 
1333						DMARK "MAN" 
1333						CALLMONITOR 
1333					endif 
1333			 
1333			malloc_early_exit: 
1333					if DEBUG_FORTH_MALLOC 
1333						DMARK "MAx" 
1333						CALLMONITOR 
1333					endif 
1333 dd e1		      pop   IX 
1335 d1			      pop   DE 
1336 c1			      pop   BC 
1337			 
1337			if DEBUG_FORTH_MALLOC_HIGH 
1337			call malloc_guard_exit 
1337			call malloc_guard_zerolen 
1337			endif 
1337 c9			      ret 
1338			 
1338			 
1338			;------------------------------------------------------------------------------ 
1338			;     free                                                                    : 
1338			;                                                                             : 
1338			; Description                                                                 : 
1338			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1338			;     returned by malloc, otherwise the behaviour is undefined.               : 
1338			;                                                                             : 
1338			;     Where possible, directly adjacent free blocks will be merged together   : 
1338			;     into larger blocks to help ensure that the heap does not become         : 
1338			;     excessively fragmented.                                                 : 
1338			;                                                                             : 
1338			;     free does not clear or set any other value into the freed space, and    : 
1338			;     therefore its contents may be visible through subsequent malloc's. The  : 
1338			;     caller should clear the freed space as required.                        : 
1338			;                                                                             : 
1338			;     This implementation of free uses the stack exclusively, and is          : 
1338			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1338			;     advisable to disable interrupts before calling free, and recommended    : 
1338			;     to avoid the use of free inside ISRs in general.                        : 
1338			;                                                                             : 
1338			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1338			;                                                                             : 
1338			; Parameters                                                                  : 
1338			;     HL  Pointer to address of first byte of allocation to be freed          : 
1338			;                                                                             : 
1338			; Returns                                                                     : 
1338			;     Nothing                                                                 : 
1338			;                                                                             : 
1338			; Stack frame                                                                 : 
1338			;       |             |                                                       : 
1338			;       +-------------+                                                       : 
1338			;       |     BC      |                                                       : 
1338			;       +-------------+                                                       : 
1338			;       |     DE      |                                                       : 
1338			;       +-------------+                                                       : 
1338			;       |     IX      |                                                       : 
1338			;       +-------------+                                                       : 
1338			;       |  prev_free  |                                                       : 
1338			;   +2  +-------------+                                                       : 
1338			;       |  next_free  |                                                       : 
1338			;   +0  +-------------+                                                       : 
1338			;       |             |                                                       : 
1338			;                                                                             : 
1338			;------------------------------------------------------------------------------ 
1338			free: 
1338 c5			      push  BC 
1339 d5			      push  DE 
133a dd e5		      push  IX 
133c			 
133c 7c			      ld    A, H                    ; Exit if ptr is null 
133d b5			      or    L 
133e ca 02 14		      jp    Z, free_early_exit 
1341			 
1341			      ; Set up stack frame 
1341 eb			      ex    DE, HL 
1342 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1345 39			      add   HL, SP 
1346 f9			      ld    SP, HL 
1347 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
134b dd 39		      add   IX, SP 
134d			 
134d			      ; The address in HL points to the start of the useable allocated space, 
134d			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
134d			      ; address of the block itself. 
134d eb			      ex    DE, HL 
134e 11 fc ff		      ld    DE, -4 
1351 19			      add   HL, DE 
1352			 
1352			      ; An allocated block must have a null next block pointer in it 
1352 7e			      ld    A, (HL) 
1353 23			      inc   HL 
1354 b6			      or    (HL) 
1355 c2 fd 13		      jp    NZ, free_done 
1358			 
1358 2b			      dec   HL 
1359			 
1359 44			      ld    B, H                    ; Copy HL to BC 
135a 4d			      ld    C, L 
135b			 
135b			      ; Loop through the free list to find the first block with an address 
135b			      ; higher than the block being freed 
135b 21 13 5c		      ld    HL, free_list 
135e			 
135e			free_find_higher_block: 
135e 5e			      ld    E, (HL)                 ; Load next ptr from free block 
135f 23			      inc   HL 
1360 56			      ld    D, (HL) 
1361 2b			      dec   HL 
1362			 
1362 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
1365 dd 72 01		      ld    (IX+1), D 
1368 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
136b dd 74 03		      ld    (IX+3), H 
136e			 
136e 78			      ld    A, B                    ; Check if DE is greater than BC 
136f ba			      cp    D                       ; Compare MSB first 
1370 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
1372 30 04		      jr    NC, free_find_higher_block_skip 
1374 79			      ld    A, C 
1375 bb			      cp    E                       ; Then compare LSB 
1376 38 08		      jr    C, free_found_higher_block 
1378			 
1378			free_find_higher_block_skip: 
1378 7a			      ld    A, D                    ; Reached the end of the free list? 
1379 b3			      or    E 
137a ca fd 13		      jp    Z, free_done 
137d			 
137d eb			      ex    DE, HL 
137e			 
137e 18 de		      jr    free_find_higher_block 
1380			 
1380			free_found_higher_block: 
1380			      ; Insert freed block between prev and next free blocks 
1380 71			      ld    (HL), C                 ; Point prev free block to freed block 
1381 23			      inc   HL 
1382 70			      ld    (HL), B 
1383			 
1383 60			      ld    H, B                    ; Point freed block at next free block 
1384 69			      ld    L, C 
1385 73			      ld    (HL), E 
1386 23			      inc   HL 
1387 72			      ld    (HL), D 
1388			 
1388			      ; Check if the freed block is adjacent to the next free block 
1388 23			      inc   HL                      ; Load size of freed block into HL 
1389 5e			      ld    E, (HL) 
138a 23			      inc   HL 
138b 56			      ld    D, (HL) 
138c eb			      ex    DE, HL 
138d			 
138d 09			      add   HL, BC                  ; Add addr of freed block and its size 
138e			 
138e dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
1391 dd 56 01		      ld    D, (IX+1) 
1394			 
1394 b7			      or    A                       ; Clear the carry flag 
1395 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1397 20 22		      jr    NZ, free_check_adjacent_to_prev 
1399			 
1399			      ; Freed block is adjacent to next, merge into one bigger block 
1399 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
139a 5e			      ld    E, (HL) 
139b 23			      inc   HL 
139c 56			      ld    D, (HL) 
139d e5			      push  HL                      ; Save ptr to next block for later 
139e			 
139e 60			      ld    H, B                    ; Store ptr from next block into freed block 
139f 69			      ld    L, C 
13a0 73			      ld    (HL), E 
13a1 23			      inc   HL 
13a2 72			      ld    (HL), D 
13a3			 
13a3 e1			      pop   HL                      ; Restore ptr to next block 
13a4 23			      inc   HL                      ; Load size of next block into DE 
13a5 5e			      ld    E, (HL) 
13a6 23			      inc   HL 
13a7 56			      ld    D, (HL) 
13a8 d5			      push  DE                      ; Save next block size for later 
13a9			 
13a9 60			      ld    H, B                    ; Load size of freed block into HL 
13aa 69			      ld    L, C 
13ab 23			      inc   HL 
13ac 23			      inc   HL 
13ad 5e			      ld    E, (HL) 
13ae 23			      inc   HL 
13af 56			      ld    D, (HL) 
13b0 eb			      ex    DE, HL 
13b1			 
13b1 d1			      pop   DE                      ; Restore size of next block 
13b2 19			      add   HL, DE                  ; Add sizes of both blocks 
13b3 eb			      ex    DE, HL 
13b4			 
13b4 60			      ld    H, B                    ; Store new bigger size into freed block 
13b5 69			      ld    L, C 
13b6 23			      inc   HL 
13b7 23			      inc   HL 
13b8 73			      ld    (HL), E 
13b9 23			      inc   HL 
13ba 72			      ld    (HL), D 
13bb			 
13bb			free_check_adjacent_to_prev: 
13bb			      ; Check if the freed block is adjacent to the prev free block 
13bb dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
13be dd 66 03		      ld    H, (IX+3) 
13c1			 
13c1 23			      inc   HL                      ; Size of prev free block into DE 
13c2 23			      inc   HL 
13c3 5e			      ld    E, (HL) 
13c4 23			      inc   HL 
13c5 56			      ld    D, (HL) 
13c6 2b			      dec   HL 
13c7 2b			      dec   HL 
13c8 2b			      dec   HL 
13c9			 
13c9 19			      add   HL, DE                  ; Add prev block addr and size 
13ca			 
13ca b7			      or    A                       ; Clear the carry flag 
13cb ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
13cd 20 2e		      jr    NZ, free_done 
13cf			 
13cf			      ; Freed block is adjacent to prev, merge into one bigger block 
13cf 60			      ld    H, B                    ; Load next ptr from freed block into DE 
13d0 69			      ld    L, C 
13d1 5e			      ld    E, (HL) 
13d2 23			      inc   HL 
13d3 56			      ld    D, (HL) 
13d4 e5			      push  HL                      ; Save freed block ptr for later 
13d5			 
13d5 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
13d8 dd 66 03		      ld    H, (IX+3) 
13db 73			      ld    (HL), E 
13dc 23			      inc   HL 
13dd 72			      ld    (HL), D 
13de			 
13de e1			      pop   HL                      ; Restore freed block ptr 
13df 23			      inc   HL                      ; Load size of freed block into DE 
13e0 5e			      ld    E, (HL) 
13e1 23			      inc   HL 
13e2 56			      ld    D, (HL) 
13e3 d5			      push  DE                      ; Save freed block size for later 
13e4			 
13e4 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
13e7 dd 66 03		      ld    H, (IX+3) 
13ea 23			      inc   HL 
13eb 23			      inc   HL 
13ec 5e			      ld    E, (HL) 
13ed 23			      inc   HL 
13ee 56			      ld    D, (HL) 
13ef			 
13ef e1			      pop   HL                      ; Add sizes of both blocks 
13f0 19			      add   HL, DE 
13f1 eb			      ex    DE, HL 
13f2			 
13f2 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
13f5 dd 66 03		      ld    H, (IX+3) 
13f8 23			      inc   HL 
13f9 23			      inc   HL 
13fa 73			      ld    (HL), E 
13fb 23			      inc   HL 
13fc 72			      ld    (HL), D 
13fd			 
13fd			free_done: 
13fd 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
1400 39			      add   HL, SP 
1401 f9			      ld    SP, HL 
1402			 
1402			free_early_exit: 
1402 dd e1		      pop   IX 
1404 d1			      pop   DE 
1405 c1			      pop   BC 
1406			 
1406 c9			      ret 
1407			 
1407			; moved to firmware.asm 
1407			; 
1407			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1407			;                  .dw   0 
1407			 
1407			 
1407			endif 
1407			 
1407			 
1407			if MALLOC_3 
1407			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1407			;heap_start        .equ  0x9000      ; Starting address of heap 
1407			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1407			; 
1407			 ;     .org 0 
1407			  ;    jp    main 
1407			; 
1407			; 
1407			 ;     .org  0x100 
1407			;main: 
1407			 ;     ld    HL, 0x8100 
1407			  ;    ld    SP, HL 
1407			; 
1407			;      call  heap_init 
1407			 
1407			      ; Make some allocations 
1407			;      ld    HL, 12 
1407			;      call  malloc            ; Allocates 0x9004 
1407			; 
1407			 ;     ld    HL, 12 
1407			;      call  malloc            ; Allocates 0x9014 
1407			 
1407			;      ld    HL, 12 
1407			;      call  malloc            ; Allocates 0x9024 
1407			 
1407			      ; Free some allocations 
1407			;      ld    HL, 0x9014 
1407			;      call  free 
1407			 
1407			;      ld    HL, 0x9004 
1407			;      call  free 
1407			; 
1407			;      ld    HL, 0x9024 
1407			;      call  free 
1407			 
1407			 
1407			 ;     halt 
1407			 
1407			 
1407			;------------------------------------------------------------------------------ 
1407			;     heap_init                                                               : 
1407			;                                                                             : 
1407			; Description                                                                 : 
1407			;     Initialise the heap and make it ready for malloc and free operations.   : 
1407			;                                                                             : 
1407			;     The heap is maintained as a linked list, starting with an initial       : 
1407			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1407			;     the first free block in the heap. Each block then points to the next    : 
1407			;     free block within the heap, and the free list ends at the first block   : 
1407			;     with a null pointer to the next free block.                             : 
1407			;                                                                             : 
1407			; Parameters                                                                  : 
1407			;     Inputs are compile-time only. Two defines which specify the starting    : 
1407			;     address of the heap and its size are required, along with a memory      : 
1407			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1407			;     principally stores a pointer to the first free block in the heap.       : 
1407			;                                                                             : 
1407			; Returns                                                                     : 
1407			;     Nothing                                                                 : 
1407			;------------------------------------------------------------------------------ 
1407			heap_init: 
1407			      push  HL 
1407			 
1407			      ; Initialise free list struct 
1407			      ld    HL, heap_start 
1407			      ld    (free_list), HL 
1407			      ld    HL, 0 
1407			      ld    (free_list+2), HL 
1407			 
1407			      ; Insert first free block at bottom of heap, consumes entire heap 
1407			      ld    HL, heap_start+heap_size-4 
1407			      ld    (heap_start), HL        ; Next block (end of free list) 
1407			      ld    HL, heap_size-4 
1407			      ld    (heap_start+2), HL      ; Block size 
1407			 
1407			      ; Insert end of free list block at top of heap - two null words will 
1407			      ; terminate the free list 
1407			      ld    HL, 0 
1407			      ld    (heap_start+heap_size-2), HL 
1407			      ld    (heap_start+heap_size-4), HL 
1407			 
1407			      pop   HL 
1407			 
1407			      ret 
1407			 
1407			 
1407			;------------------------------------------------------------------------------ 
1407			;     malloc                                                                  : 
1407			;                                                                             : 
1407			; Description                                                                 : 
1407			;     Allocates the wanted space from the heap and returns the address of the : 
1407			;     first useable byte of the allocation.                                   : 
1407			;                                                                             : 
1407			;     Allocations can happen in one of two ways:                              : 
1407			;                                                                             : 
1407			;     1. A free block may be found which is the exact size wanted. In this    : 
1407			;        case the block is removed from the free list and retuedn to the      : 
1407			;        caller.                                                              : 
1407			;     2. A free block may be found which is larger than the size wanted. In   : 
1407			;        this case, the larger block is split into two. The first portion of  : 
1407			;        this block will become the requested space by the malloc call and    : 
1407			;        is returned to the caller. The second portion becomes a new free     : 
1407			;        block, and the free list is adjusted to maintain continuity via this : 
1407			;        newly created block.                                                 : 
1407			;                                                                             : 
1407			;     malloc does not set any initial value in the allocated space, the       : 
1407			;     caller is required to do this as required.                              : 
1407			;                                                                             : 
1407			;     This implementation of malloc uses the stack exclusively, and is        : 
1407			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1407			;     advisable to disable interrupts before calling malloc, and recommended  : 
1407			;     to avoid the use of malloc inside ISRs in general.                      : 
1407			;                                                                             : 
1407			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1407			;                                                                             : 
1407			; Parameters                                                                  : 
1407			;     HL  Number of bytes wanted                                              : 
1407			;                                                                             : 
1407			; Returns                                                                     : 
1407			;     HL  Address of the first useable byte of the allocation                 : 
1407			;                                                                             : 
1407			; Flags                                                                       : 
1407			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1407			;                                                                             : 
1407			; Stack frame                                                                 : 
1407			;       |             |                                                       : 
1407			;       +-------------+                                                       : 
1407			;       |     BC      |                                                       : 
1407			;       +-------------+                                                       : 
1407			;       |     DE      |                                                       : 
1407			;       +-------------+                                                       : 
1407			;       |     IX      |                                                       : 
1407			;       +-------------+                                                       : 
1407			;       |  prev_free  |                                                       : 
1407			;   +4  +-------------+                                                       : 
1407			;       |  this_free  |                                                       : 
1407			;   +2  +-------------+                                                       : 
1407			;       |  next_free  |                                                       : 
1407			;   +0  +-------------+                                                       : 
1407			;       |             |                                                       : 
1407			;                                                                             : 
1407			;------------------------------------------------------------------------------ 
1407			malloc: 
1407			      push  BC 
1407			      push  DE 
1407			      push  IX 
1407			 
1407			      ld    A, H                    ; Exit if no space requested 
1407			      or    L 
1407			      jp    Z, malloc_early_exit 
1407			 
1407			      ; Set up stack frame 
1407			      ex    DE, HL 
1407			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1407			      add   HL, SP 
1407			      ld    SP, HL 
1407			      ld    IX, 0                   ; Use IX as a frame pointer 
1407			      add   IX, SP 
1407			 
1407			      ; Setup initial state 
1407			      ld    HL, 4                   ; want must also include space used by block struct 
1407			      add   HL, DE 
1407			 
1407			      ld    B, H                    ; Move want to BC 
1407			      ld    C, L 
1407			 
1407			      ld    HL, free_list           ; Store prev_free ptr to stack 
1407			      ld    (IX+4), L 
1407			      ld    (IX+5), H 
1407			 
1407			      ld    E, (HL)                 ; Store this_free ptr to stack 
1407			      inc   HL 
1407			      ld    D, (HL) 
1407			      ld    (IX+2), E 
1407			      ld    (IX+3), D 
1407			      ex    DE, HL                  ; this_free ptr into HL 
1407			 
1407			      ; Loop through free block list to find some space 
1407			malloc_find_space: 
1407			      ld    E, (HL)                 ; Load next_free ptr into DE 
1407			      inc   HL 
1407			      ld    D, (HL) 
1407			 
1407			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1407			      or    E 
1407			      jp    Z, malloc_no_space 
1407			 
1407			      ld    (IX+0), E               ; Store next_free ptr to stack 
1407			      ld    (IX+1), D 
1407			 
1407			      ; Does this block have enough space to make the allocation? 
1407			      inc   HL                      ; Load free block size into DE 
1407			      ld    E, (HL) 
1407			      inc   HL 
1407			      ld    D, (HL) 
1407			 
1407			      ex    DE, HL                  ; Check size of block against want 
1407			      or    A                       ; Ensure carry flag clear 
1407			      sbc   HL, BC 
1407			      push  HL                      ; Store the result for later (new block size) 
1407			 
1407			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1407			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1407			 
1407			      ; this_free block is not big enough, setup ptrs to test next free block 
1407			      pop   HL                      ; Discard previous result 
1407			 
1407			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1407			      ld    H, (IX+3) 
1407			      ld    (IX+4), L 
1407			      ld    (IX+5), H 
1407			 
1407			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1407			      ld    H, (IX+1) 
1407			      ld    (IX+2), L 
1407			      ld    (IX+3), H 
1407			 
1407			      jr    malloc_find_space 
1407			 
1407			      ; split a bigger block into two - requested size and remaining size 
1407			malloc_alloc_split: 
1407			      ex    DE, HL                  ; Calculate address of new free block 
1407			      dec   HL 
1407			      dec   HL 
1407			      dec   HL 
1407			      add   HL, BC 
1407			 
1407			      ; Create a new block and point it at next_free 
1407			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1407			      ld    D, (IX+1) 
1407			 
1407			      ld    (HL), E                 ; Store next_free ptr into new block 
1407			      inc   HL 
1407			      ld    (HL), D 
1407			 
1407			      pop   DE                      ; Store size of new block into new block 
1407			      inc   HL 
1407			      ld    (HL), E 
1407			      inc   HL 
1407			      ld    (HL), D 
1407			 
1407			      ; Update this_free ptr to point to new block 
1407			      dec   HL 
1407			      dec   HL 
1407			      dec   HL 
1407			 
1407			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1407			      ld    D, (IX+3) 
1407			 
1407			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1407			      ld    (IX+3), H 
1407			 
1407			      ; Modify this_free block to be allocation 
1407			      ex    DE, HL 
1407			      xor   A                       ; Null the next block ptr of allocated block 
1407			      ld    (HL), A 
1407			      inc   HL 
1407			      ld    (HL), A 
1407			 
1407			      inc   HL                      ; Store want size into allocated block 
1407			      ld    (HL), C 
1407			      inc   HL 
1407			      ld    (HL), B 
1407			      inc   HL 
1407			      push  HL                      ; Address of allocation to return 
1407			 
1407			      jr    malloc_update_links 
1407			 
1407			malloc_alloc_fit: 
1407			      pop   HL                      ; Dont need new block size, want is exact fit 
1407			 
1407			      ; Modify this_free block to be allocation 
1407			      ex    DE, HL 
1407			      dec   HL 
1407			      dec   HL 
1407			      dec   HL 
1407			 
1407			      xor   A                       ; Null the next block ptr of allocated block 
1407			      ld    (HL), A 
1407			      inc   HL 
1407			      ld    (HL), A 
1407			 
1407			      inc   HL                      ; Store address of allocation to return 
1407			      inc   HL 
1407			      inc   HL 
1407			      push  HL 
1407			 
1407			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1407			      ld    L, (IX+0)               ; next_free to HL 
1407			      ld    H, (IX+1) 
1407			 
1407			      ld    (IX+2), L               ; HL to this_free 
1407			      ld    (IX+3), H 
1407			 
1407			 
1407			malloc_update_links: 
1407			      ; Update prev_free ptr to point to this_free 
1407			      ld    L, (IX+4)               ; prev_free ptr to HL 
1407			      ld    H, (IX+5) 
1407			 
1407			      ld    E, (IX+2)               ; this_free ptr to DE 
1407			      ld    D, (IX+3) 
1407			 
1407			      ld    (HL), E                 ; this_free ptr into prev_free 
1407			      inc   HL 
1407			      ld    (HL), D 
1407			 
1407			      ; Clear the Z flag to indicate successful allocation 
1407			      ld    A, D 
1407			      or    E 
1407			 
1407			      pop   DE                      ; Address of allocation 
1407			 
1407			malloc_no_space: 
1407			      ld    HL, 6                   ; Clean up stack frame 
1407			      add   HL, SP 
1407			      ld    SP, HL 
1407			 
1407			      ex    DE, HL                  ; Alloc addr into HL for return 
1407			 
1407			malloc_early_exit: 
1407			      pop   IX 
1407			      pop   DE 
1407			      pop   BC 
1407			 
1407			      ret 
1407			 
1407			 
1407			;------------------------------------------------------------------------------ 
1407			;     free                                                                    : 
1407			;                                                                             : 
1407			; Description                                                                 : 
1407			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1407			;     returned by malloc, otherwise the behaviour is undefined.               : 
1407			;                                                                             : 
1407			;     Where possible, directly adjacent free blocks will be merged together   : 
1407			;     into larger blocks to help ensure that the heap does not become         : 
1407			;     excessively fragmented.                                                 : 
1407			;                                                                             : 
1407			;     free does not clear or set any other value into the freed space, and    : 
1407			;     therefore its contents may be visible through subsequent malloc's. The  : 
1407			;     caller should clear the freed space as required.                        : 
1407			;                                                                             : 
1407			;     This implementation of free uses the stack exclusively, and is          : 
1407			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1407			;     advisable to disable interrupts before calling free, and recommended    : 
1407			;     to avoid the use of free inside ISRs in general.                        : 
1407			;                                                                             : 
1407			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1407			;                                                                             : 
1407			; Parameters                                                                  : 
1407			;     HL  Pointer to address of first byte of allocation to be freed          : 
1407			;                                                                             : 
1407			; Returns                                                                     : 
1407			;     Nothing                                                                 : 
1407			;                                                                             : 
1407			; Stack frame                                                                 : 
1407			;       |             |                                                       : 
1407			;       +-------------+                                                       : 
1407			;       |     BC      |                                                       : 
1407			;       +-------------+                                                       : 
1407			;       |     DE      |                                                       : 
1407			;       +-------------+                                                       : 
1407			;       |     IX      |                                                       : 
1407			;       +-------------+                                                       : 
1407			;       |  prev_free  |                                                       : 
1407			;   +2  +-------------+                                                       : 
1407			;       |  next_free  |                                                       : 
1407			;   +0  +-------------+                                                       : 
1407			;       |             |                                                       : 
1407			;                                                                             : 
1407			;------------------------------------------------------------------------------ 
1407			free: 
1407			      push  BC 
1407			      push  DE 
1407			      push  IX 
1407			 
1407			      ld    A, H                    ; Exit if ptr is null 
1407			      or    L 
1407			      jp    Z, free_early_exit 
1407			 
1407			      ; Set up stack frame 
1407			      ex    DE, HL 
1407			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1407			      add   HL, SP 
1407			      ld    SP, HL 
1407			      ld    IX, 0                   ; Use IX as a frame pointer 
1407			      add   IX, SP 
1407			 
1407			      ; The address in HL points to the start of the useable allocated space, 
1407			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1407			      ; address of the block itself. 
1407			      ex    DE, HL 
1407			      ld    DE, -4 
1407			      add   HL, DE 
1407			 
1407			      ; An allocated block must have a null next block pointer in it 
1407			      ld    A, (HL) 
1407			      inc   HL 
1407			      or    (HL) 
1407			      jp    NZ, free_done 
1407			 
1407			      dec   HL 
1407			 
1407			      ld    B, H                    ; Copy HL to BC 
1407			      ld    C, L 
1407			 
1407			      ; Loop through the free list to find the first block with an address 
1407			      ; higher than the block being freed 
1407			      ld    HL, free_list 
1407			 
1407			free_find_higher_block: 
1407			      ld    E, (HL)                 ; Load next ptr from free block 
1407			      inc   HL 
1407			      ld    D, (HL) 
1407			      dec   HL 
1407			 
1407			      ld    (IX+0), E               ; Save ptr to next free block 
1407			      ld    (IX+1), D 
1407			      ld    (IX+2), L               ; Save ptr to prev free block 
1407			      ld    (IX+3), H 
1407			 
1407			      ld    A, B                    ; Check if DE is greater than BC 
1407			      cp    D                       ; Compare MSB first 
1407			      jr    Z, $+4                  ; MSB the same, compare LSB 
1407			      jr    NC, free_find_higher_block_skip 
1407			      ld    A, C 
1407			      cp    E                       ; Then compare LSB 
1407			      jr    C, free_found_higher_block 
1407			 
1407			free_find_higher_block_skip: 
1407			      ld    A, D                    ; Reached the end of the free list? 
1407			      or    E 
1407			      jp    Z, free_done 
1407			 
1407			      ex    DE, HL 
1407			 
1407			      jr    free_find_higher_block 
1407			 
1407			free_found_higher_block: 
1407			      ; Insert freed block between prev and next free blocks 
1407			      ld    (HL), C                 ; Point prev free block to freed block 
1407			      inc   HL 
1407			      ld    (HL), B 
1407			 
1407			      ld    H, B                    ; Point freed block at next free block 
1407			      ld    L, C 
1407			      ld    (HL), E 
1407			      inc   HL 
1407			      ld    (HL), D 
1407			 
1407			      ; Check if the freed block is adjacent to the next free block 
1407			      inc   HL                      ; Load size of freed block into HL 
1407			      ld    E, (HL) 
1407			      inc   HL 
1407			      ld    D, (HL) 
1407			      ex    DE, HL 
1407			 
1407			      add   HL, BC                  ; Add addr of freed block and its size 
1407			 
1407			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1407			      ld    D, (IX+1) 
1407			 
1407			      or    A                       ; Clear the carry flag 
1407			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1407			      jr    NZ, free_check_adjacent_to_prev 
1407			 
1407			      ; Freed block is adjacent to next, merge into one bigger block 
1407			      ex    DE, HL                  ; Load next ptr from next block into DE 
1407			      ld    E, (HL) 
1407			      inc   HL 
1407			      ld    D, (HL) 
1407			      push  HL                      ; Save ptr to next block for later 
1407			 
1407			      ld    H, B                    ; Store ptr from next block into freed block 
1407			      ld    L, C 
1407			      ld    (HL), E 
1407			      inc   HL 
1407			      ld    (HL), D 
1407			 
1407			      pop   HL                      ; Restore ptr to next block 
1407			      inc   HL                      ; Load size of next block into DE 
1407			      ld    E, (HL) 
1407			      inc   HL 
1407			      ld    D, (HL) 
1407			      push  DE                      ; Save next block size for later 
1407			 
1407			      ld    H, B                    ; Load size of freed block into HL 
1407			      ld    L, C 
1407			      inc   HL 
1407			      inc   HL 
1407			      ld    E, (HL) 
1407			      inc   HL 
1407			      ld    D, (HL) 
1407			      ex    DE, HL 
1407			 
1407			      pop   DE                      ; Restore size of next block 
1407			      add   HL, DE                  ; Add sizes of both blocks 
1407			      ex    DE, HL 
1407			 
1407			      ld    H, B                    ; Store new bigger size into freed block 
1407			      ld    L, C 
1407			      inc   HL 
1407			      inc   HL 
1407			      ld    (HL), E 
1407			      inc   HL 
1407			      ld    (HL), D 
1407			 
1407			free_check_adjacent_to_prev: 
1407			      ; Check if the freed block is adjacent to the prev free block 
1407			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1407			      ld    H, (IX+3) 
1407			 
1407			      inc   HL                      ; Size of prev free block into DE 
1407			      inc   HL 
1407			      ld    E, (HL) 
1407			      inc   HL 
1407			      ld    D, (HL) 
1407			      dec   HL 
1407			      dec   HL 
1407			      dec   HL 
1407			 
1407			      add   HL, DE                  ; Add prev block addr and size 
1407			 
1407			      or    A                       ; Clear the carry flag 
1407			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1407			      jr    NZ, free_done 
1407			 
1407			      ; Freed block is adjacent to prev, merge into one bigger block 
1407			      ld    H, B                    ; Load next ptr from freed block into DE 
1407			      ld    L, C 
1407			      ld    E, (HL) 
1407			      inc   HL 
1407			      ld    D, (HL) 
1407			      push  HL                      ; Save freed block ptr for later 
1407			 
1407			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1407			      ld    H, (IX+3) 
1407			      ld    (HL), E 
1407			      inc   HL 
1407			      ld    (HL), D 
1407			 
1407			      pop   HL                      ; Restore freed block ptr 
1407			      inc   HL                      ; Load size of freed block into DE 
1407			      ld    E, (HL) 
1407			      inc   HL 
1407			      ld    D, (HL) 
1407			      push  DE                      ; Save freed block size for later 
1407			 
1407			      ld    L, (IX+2)               ; Load size of prev block into DE 
1407			      ld    H, (IX+3) 
1407			      inc   HL 
1407			      inc   HL 
1407			      ld    E, (HL) 
1407			      inc   HL 
1407			      ld    D, (HL) 
1407			 
1407			      pop   HL                      ; Add sizes of both blocks 
1407			      add   HL, DE 
1407			      ex    DE, HL 
1407			 
1407			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1407			      ld    H, (IX+3) 
1407			      inc   HL 
1407			      inc   HL 
1407			      ld    (HL), E 
1407			      inc   HL 
1407			      ld    (HL), D 
1407			 
1407			free_done: 
1407			      ld    HL, 4                   ; Clean up stack frame 
1407			      add   HL, SP 
1407			      ld    SP, HL 
1407			 
1407			free_early_exit: 
1407			      pop   IX 
1407			      pop   DE 
1407			      pop   BC 
1407			 
1407			      ret 
1407			 
1407			 
1407			;      .org 0x8000 
1407			; 
1407			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1407			 ;                 .dw   0 
1407			 
1407			endif 
1407			 
1407			 
1407			if MALLOC_4 
1407			 
1407			; My memory allocation code. Very very simple.... 
1407			; allocate space under 250 chars 
1407			 
1407			heap_init: 
1407				; init start of heap as zero 
1407				;  
1407			 
1407				ld hl, heap_start 
1407				ld a, 0 
1407				ld (hl), a      ; empty block 
1407				inc hl 
1407				ld a, 0 
1407				ld (hl), a      ; length of block 
1407				; write end of list 
1407				inc hl 
1407				ld a,(hl) 
1407				inc hl 
1407				ld a,(hl) 
1407				 
1407			 
1407				; init some malloc vars 
1407			 
1407				ld hl, 0 
1407				ld (free_list), hl       ; store last malloc location 
1407			 
1407				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1407				ld a, 0 
1407				ld (hl), a 
1407			 
1407			 
1407				ld hl, heap_start 
1407				;  
1407				  
1407				ret 
1407			 
1407			 
1407			;    free block marker 
1407			;    requested size  
1407			;    pointer to next block 
1407			;    .... 
1407			;    next block marker 
1407			 
1407			 
1407			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1407			; 
1407			 
1407			 
1407			malloc:  
1407				push de 
1407				push bc 
1407				push af 
1407			 
1407				; hl space required 
1407				 
1407				ld c, l    ; hold space   (TODO only a max of 255) 
1407			 
1407			;	inc c     ; TODO BUG need to fix memory leak on push str 
1407			;	inc c 
1407			;	inc c 
1407			;	inc c 
1407			;	inc c 
1407			;	inc c 
1407			;	inc c 
1407			 
1407			 
1407			 
1407				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1407			 
1407				ld a, (free_list+3) 
1407				cp 0 
1407				jr z, .contheap 
1407			 
1407				ld hl, (free_list)     ; get last alloc 
1407					if DEBUG_FORTH_MALLOC_INT 
1407						DMARK "mrs" 
1407						CALLMONITOR 
1407					endif 
1407				jr .startalloc 
1407			 
1407			.contheap: 
1407				ld hl, heap_start 
1407			 
1407			.startalloc: 
1407			 
1407					if DEBUG_FORTH_MALLOC_INT 
1407						DMARK "mym" 
1407						CALLMONITOR 
1407					endif 
1407			.findblock: 
1407					if DEBUG_FORTH_MALLOC_INT 
1407						DMARK "mmf" 
1407						CALLMONITOR 
1407					endif 
1407			 
1407				ld a,(hl)  
1407				; if byte is zero then clear to use 
1407			 
1407				cp 0 
1407				jr z, .foundemptyblock 
1407			 
1407				; if byte is not clear 
1407				;     then byte is offset to next block 
1407			 
1407				inc hl 
1407				ld a, (hl) ; get size 
1407			.nextblock:	inc hl 
1407					ld e, (hl) 
1407					inc hl 
1407					ld d, (hl) 
1407					ex de, hl 
1407			;	inc hl  ; move past the store space 
1407			;	inc hl  ; move past zero index  
1407			 
1407				; TODO detect no more space 
1407			 
1407				push hl 
1407				ld de, heap_end 
1407				call cmp16 
1407				pop hl 
1407				jr nc, .nospace 
1407			 
1407				jr .findblock 
1407			 
1407			.nospace: ld hl, 0 
1407				jp .exit 
1407			 
1407			 
1407			.foundemptyblock:	 
1407					if DEBUG_FORTH_MALLOC_INT 
1407						DMARK "mme" 
1407						CALLMONITOR 
1407					endif 
1407			 
1407			; TODO has block enough space if reusing??? 
1407			 
1407				;  
1407			 
1407			; see if this block has been previously used 
1407				inc hl 
1407				ld a, (hl) 
1407				dec hl 
1407				cp 0 
1407				jr z, .newblock 
1407			 
1407					if DEBUG_FORTH_MALLOC_INT 
1407						DMARK "meR" 
1407						CALLMONITOR 
1407					endif 
1407			 
1407			; no reusing previously allocated block 
1407			 
1407			; is it smaller than previously used? 
1407				 
1407				inc hl    ; move to size 
1407				ld a, c 
1407				sub (hl)        ; we want c < (hl) 
1407				dec hl    ; move back to marker 
1407			        jr z, .findblock 
1407			 
1407				; update with the new size which should be lower 
1407			 
1407			        ;inc  hl   ; negate next move. move back to size  
1407			 
1407			.newblock: 
1407				; need to be at marker here 
1407			 
1407					if DEBUG_FORTH_MALLOC_INT 
1407						DMARK "meN" 
1407						CALLMONITOR 
1407					endif 
1407			 
1407			 
1407				ld a, c 
1407			 
1407				ld (free_list+3), a	 ; flag resume from last malloc  
1407				ld (free_list), hl    ; save out last location 
1407			 
1407			 
1407				;inc a     ; space for length byte 
1407				ld (hl), a     ; save block in use marker 
1407			 
1407				inc hl   ; move to space marker 
1407				ld (hl), a    ; save new space 
1407			 
1407				inc hl   ; move to start of allocated area 
1407				 
1407			;	push hl     ; save where we are - 1  
1407			 
1407			;	inc hl  ; move past zero index  
1407				; skip space to set down new marker 
1407			 
1407				; provide some extra space for now 
1407			 
1407				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1407				inc a 
1407				inc a 
1407			 
1407				push hl   ; save where we are in the node block 
1407			 
1407				call addatohl 
1407			 
1407				; write linked list point 
1407			 
1407				pop de     ; get our node position 
1407				ex de, hl 
1407			 
1407				ld (hl), e 
1407				inc hl 
1407				ld (hl), d 
1407			 
1407				inc hl 
1407			 
1407				; now at start of allocated data so save pointer 
1407			 
1407				push hl 
1407			 
1407				; jump to position of next node and setup empty header in DE 
1407			 
1407				ex de, hl 
1407			 
1407			;	inc hl ; move past end of block 
1407			 
1407				ld a, 0 
1407				ld (hl), a   ; empty marker 
1407				inc hl 
1407				ld (hl), a   ; size 
1407				inc hl  
1407				ld (hl), a   ; ptr 
1407				inc hl 
1407				ld (hl), a   ; ptr 
1407			 
1407			 
1407				pop hl 
1407			 
1407					if DEBUG_FORTH_MALLOC_INT 
1407						DMARK "mmr" 
1407						CALLMONITOR 
1407					endif 
1407			 
1407			.exit: 
1407				pop af 
1407				pop bc 
1407				pop de  
1407				ret 
1407			 
1407			 
1407			 
1407			 
1407			free:  
1407				push hl 
1407				push af 
1407				; get address in hl 
1407			 
1407					if DEBUG_FORTH_MALLOC_INT 
1407						DMARK "fre" 
1407						CALLMONITOR 
1407					endif 
1407				; data is at hl - move to block count 
1407				dec hl 
1407				dec hl    ; get past pointer 
1407				dec hl 
1407			 
1407				ld a, (hl)    ; need this for a validation check 
1407			 
1407				dec hl    ; move to block marker 
1407			 
1407				; now check that the block count and block marker are the same  
1407			        ; this checks that we are on a malloc node and not random memory 
1407			        ; OK a faint chance this could be a problem but rare - famous last words! 
1407			 
1407				ld c, a 
1407				ld a, (hl)    
1407			 
1407				cp c 
1407				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1407			 
1407				; yes good chance we are on a malloc node 
1407			 
1407				ld a, 0      
1407				ld (hl), a   ; mark as free 
1407			 
1407				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1407			 
1407			.freeignore:  
1407			 
1407				pop af 
1407				pop hl 
1407			 
1407				ret 
1407			 
1407			 
1407			 
1407			endif 
1407			 
1407			; eof 
# End of file firmware_memory.asm
1407			  
1407			; device C  
1407			if SOUND_ENABLE  
1407				include "firmware_sound.asm"  
1407			endif  
1407			  
1407			include "firmware_diags.asm"  
1407			; Hardware diags menu 
1407			 
1407			 
1407			config: 
1407			 
1407 3e 00			ld a, 0 
1409 21 37 14			ld hl, .configmn 
140c cd ab 0b			call menu 
140f			 
140f fe 00			cp 0 
1411 c8				ret z 
1412			 
1412 fe 01			cp 1 
1414 cc 65 14			call z, .savetostore 
1417			 
1417 fe 02			cp 2 
1419 cc 51 14			call z, .selautoload 
141c fe 03			cp 3 
141e cc 47 14			call z, .disautoload 
1421 fe 04			cp 4 
1423 cc 5b 14			call z, .selbank 
1426 fe 05			cp 5 
1428 cc 6f 14			call z, .debug_tog 
142b fe 06			cp 6 
142d cc b2 15			call z, .bpsgo 
1430 fe 07			cp 7 
1432 cc 95 14			call z, hardware_diags 
1435			 
1435 18 d0			jr config 
1437			 
1437			.configmn: 
1437 a3 17			dw prom_c3 
1439 ba 17			dw prom_c2 
143b cf 17			dw prom_c2a 
143d e5 17			dw prom_c2b 
143f			;	dw prom_c4 
143f 02 18			dw prom_m4 
1441 1d 18			dw prom_m4b 
1443 25 18			dw prom_c1 
1445 00 00			dw 0 
1447				 
1447			 
1447			 
1447			 
1447			.disautoload: 
1447				if STORAGE_SE 
1447				ld a, $fe      ; bit 0 clear 
1447				ld (spi_device), a 
1447			 
1447				call storage_get_block_0 
1447			 
1447				ld a, 0 
1447				ld (store_page+STORE_0_AUTOFILE), a 
1447			 
1447					ld hl, 0 
1447					ld de, store_page 
1447				call storage_write_block	 ; save update 
1447				else 
1447			 
1447 21 34 18			ld hl, prom_notav 
144a 11 4a 18			ld de, prom_empty 
144d cd 0b 0b			call info_panel 
1450				endif 
1450			 
1450			 
1450 c9				ret 
1451			 
1451			 
1451			 
1451			; Select auto start 
1451			 
1451			.selautoload: 
1451			 
1451				 
1451				if STORAGE_SE 
1451			 
1451					call config_dir 
1451				        ld hl, scratch 
1451					ld a, 0 
1451					call menu 
1451			 
1451					cp 0 
1451					ret z 
1451			 
1451					dec a 
1451			 
1451			 
1451					; locate menu option 
1451			 
1451					ld hl, scratch 
1451					call table_lookup 
1451			 
1451					if DEBUG_FORTH_WORDS 
1451						DMARK "ALl" 
1451						CALLMONITOR 
1451					endif 
1451					; with the pointer to the menu it, the byte following the zero term is the file id 
1451			 
1451					ld a, 0 
1451					ld bc, 50   ; max of bytes to look at 
1451					cpir  
1451			 
1451					if DEBUG_FORTH_WORDS 
1451						DMARK "ALb" 
1451						CALLMONITOR 
1451					endif 
1451					;inc hl 
1451			 
1451					ld a, (hl)   ; file id 
1451					 
1451				        ; save bank and file ids 
1451			 
1451					push af 
1451			 
1451			; TODO need to save to block 0 on bank 1	 
1451			 
1451					call storage_get_block_0 
1451			 
1451					if DEBUG_FORTH_WORDS 
1451						DMARK "AL0" 
1451						CALLMONITOR 
1451					endif 
1451					pop af 
1451			 
1451					ld (store_page+STORE_0_FILERUN),a 
1451					 
1451					; save bank id 
1451			 
1451					ld a,(spi_device) 
1451					ld (store_page+STORE_0_BANKRUN),a 
1451			 
1451					; enable auto run of store file 
1451			 
1451					ld a, 1 
1451					ld (store_page+STORE_0_AUTOFILE),a 
1451			 
1451					; save buffer 
1451			 
1451					ld hl, 0 
1451					ld de, store_page 
1451					if DEBUG_FORTH_WORDS 
1451						DMARK "ALw" 
1451						CALLMONITOR 
1451					endif 
1451				call storage_write_block	 ; save update 
1451			  
1451			 
1451			 
1451			 
1451					ld hl, scratch 
1451					call config_fdir 
1451			 
1451				else 
1451			 
1451 21 34 18			ld hl, prom_notav 
1454 11 4a 18			ld de, prom_empty 
1457 cd 0b 0b			call info_panel 
145a			 
145a				endif 
145a c9				ret 
145b			 
145b			 
145b			 
145b			; Select storage bank 
145b			 
145b			.selbank: 
145b			 
145b				if STORAGE_SE 
145b				else 
145b			 
145b 21 34 18			ld hl, prom_notav 
145e 11 4a 18			ld de, prom_empty 
1461 cd 0b 0b			call info_panel 
1464				endif 
1464				 
1464 c9				ret 
1465			 
1465			if STORAGE_SE 
1465			 
1465			.config_ldir:   
1465				; Load storage bank labels into menu array 
1465			 
1465				 
1465			 
1465			 
1465				ret 
1465			 
1465			 
1465			endif 
1465			 
1465			 
1465			; Save user words to storage 
1465			 
1465			.savetostore: 
1465			 
1465				if STORAGE_SE 
1465			 
1465					call config_dir 
1465				        ld hl, scratch 
1465					ld a, 0 
1465					call menu 
1465					 
1465					ld hl, scratch 
1465					call config_fdir 
1465			 
1465				else 
1465			 
1465 21 34 18			ld hl, prom_notav 
1468 11 4a 18			ld de, prom_empty 
146b cd 0b 0b			call info_panel 
146e			 
146e				endif 
146e			 
146e c9				ret 
146f			 
146f			 
146f			 
146f			if STORAGE_SE 
146f			 
146f			config_fdir: 
146f				; using the scratch dir go through and release the memory allocated for each string 
146f				 
146f				ld hl, scratch 
146f			.cfdir:	ld e,(hl) 
146f				inc hl 
146f				ld d,(hl) 
146f				inc hl 
146f			 
146f				ex de, hl 
146f				call ishlzero 
146f				ret z     ; return on null pointer 
146f				call free 
146f				ex de, hl 
146f				jr .cfdir 
146f			 
146f			 
146f				ret 
146f			 
146f			 
146f			config_dir: 
146f			 
146f				; for the config menus that need to build a directory of storage call this routine 
146f				; it will construct a menu in scratch to pass to menu 
146f			 
146f				; open storage device 
146f			 
146f				; execute DIR to build a list of files and their ids into scratch in menu format 
146f				; once the menu has finished then will need to call config_fdir to release the strings 
146f				 
146f				; c = number items 
146f			 
146f				 
146f				call storage_get_block_0 
146f			 
146f				ld hl, store_page     ; get current id count 
146f				ld b, (hl) 
146f				ld c, 0    ; count of files   
146f			 
146f			 
146f				ld hl, scratch 
146f				ld (store_tmp2), hl    ; location to poke strings 
146f			 
146f				; check for empty drive 
146f			 
146f				ld a, 0 
146f				cp b 
146f				jp z, .dirdone 
146f			 
146f				 
146f					if DEBUG_FORTH_WORDS 
146f						DMARK "Cdc" 
146f						CALLMONITOR 
146f					endif 
146f			 
146f			 
146f			.diritem:	 
146f				push bc 
146f				; for each of the current ids do a search for them and if found push to stack 
146f			 
146f					ld hl, STORE_BLOCK_PHY 
146f					ld d, 0		 ; look for extent 0 of block id as this contains file name 
146f					ld e,b 
146f			 
146f					call storage_findnextid 
146f			 
146f			 
146f					; if found hl will be non zero 
146f			 
146f					call ishlzero 
146f					jr z, .dirnotfound 
146f			 
146f					; increase count 
146f			 
146f					pop bc	 
146f					inc c 
146f					push bc 
146f					 
146f			 
146f					; get file header and push the file name 
146f			 
146f					ld de, store_page 
146f					call storage_read_block 
146f			 
146f					; push file id to stack 
146f				 
146f					ld a, (store_page) 
146f					ld h, 0 
146f					ld l, a 
146f			 
146f					;call forth_push_numhl 
146f					; TODO store id 
146f			 
146f					push hl 
146f			 
146f					; push extent count to stack  
146f				 
146f					ld hl, store_page+3 
146f			 
146f					; get file name length 
146f			 
146f					call strlenz   
146f			 
146f					inc hl   ; cover zero term 
146f					inc hl  ; stick the id at the end of the area 
146f			 
146f					push hl 
146f					pop bc    ; move length to bc 
146f			 
146f					call malloc 
146f			 
146f					; TODO save malloc area to scratch 
146f			 
146f					ex de, hl 
146f					ld hl, (store_tmp2) 
146f					ld (hl), e 
146f					inc hl 
146f					ld (hl), d 
146f					inc hl 
146f					ld (store_tmp2), hl 
146f			 
146f					 
146f			 
146f					;pop hl   ; get source 
146f			;		ex de, hl    ; swap aronund	 
146f			 
146f					ld hl, store_page+3 
146f					if DEBUG_FORTH_WORDS 
146f						DMARK "CFd" 
146f						CALLMONITOR 
146f					endif 
146f					ldir 
146f			 
146f					; de is past string, move back one and store id 
146f					 
146f					dec de 
146f			 
146f					; store file id 
146f			 
146f					pop hl 
146f					ex de,hl 
146f					ld (hl), e 
146f			 
146f					if DEBUG_FORTH_WORDS 
146f						DMARK "Cdi" 
146f						CALLMONITOR 
146f					endif 
146f					 
146f			.dirnotfound: 
146f					pop bc     
146f					djnz .diritem 
146f				 
146f			.dirdone:	 
146f			 
146f					ld a, 0 
146f					ld hl, (store_tmp2) 
146f					ld (hl), a 
146f					inc hl 
146f					ld (hl), a 
146f					inc hl 
146f					; push a count of the dir items found 
146f			 
146f			;		ld h, 0 
146f			;		ld l, c 
146f			 
146f				ret 
146f			 
146f			endif 
146f			 
146f			 
146f			; Settings 
146f			; Run  
146f			 
146f			 
146f			 
146f			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
146f			;;hd_menu2:   db "        2: Editor",0   
146f			;hd_menu2:   db "        2: Editor       6: Menu",0   
146f			;hd_menu3:   db "        3: Storage",0 
146f			;hd_menu4:   db "0=quit  4: Debug",0 
146f			;hd_don:     db "ON",0 
146f			;hd_doff:     db "OFF",0 
146f			; 
146f			; 
146f			; 
146f			;hardware_diags_old:       
146f			; 
146f			;.diagmenu: 
146f			;	call clear_display 
146f			;	ld a, display_row_1 
146f			;	ld de, hd_menu1 
146f			;	call str_at_display 
146f			; 
146f			;	ld a, display_row_2 
146f			;	ld de, hd_menu2 
146f			;	call str_at_display 
146f			; 
146f			;	ld a, display_row_3 
146f			;	ld de, hd_menu3 
146f			;	call str_at_display 
146f			; 
146f			;	ld a,  display_row_4 
146f			;	ld de, hd_menu4 
146f			;	call str_at_display 
146f			; 
146f			;	; display debug state 
146f			; 
146f			;	ld de, hd_don 
146f			;	ld a, (os_view_disable) 
146f			;	cp 0 
146f			;	jr z, .distog 
146f			;	ld de, hd_doff 
146f			;.distog: ld a, display_row_4+17 
146f			;	call str_at_display 
146f			; 
146f			;	call update_display 
146f			; 
146f			;	call cin_wait 
146f			; 
146f			; 
146f			; 
146f			;	cp '4' 
146f			;	jr nz, .diagn1 
146f			; 
146f			;	; debug toggle 
146f			; 
146f			;	ld a, (os_view_disable) 
146f			;	ld b, '*' 
146f			;	cp 0 
146f			;	jr z, .debtog 
146f			;	ld b, 0 
146f			;.debtog:	 
146f			;	ld a,b 
146f			;	ld (os_view_disable),a 
146f			; 
146f			;.diagn1: cp '0' 
146f			;	 ret z 
146f			; 
146f			;;	cp '1' 
146f			;;       jp z, matrix	 
146f			;;   TODO keyboard matrix test 
146f			; 
146f			;	cp '2' 
146f			;	jp z, .diagedit 
146f			; 
146f			;;	cp '6' 
146f			;;	jp z, .menutest 
146f			;;if ENABLE_BASIC 
146f			;;	cp '6' 
146f			;;	jp z, basic 
146f			;;endif 
146f			 ; 
146f			;	jp .diagmenu 
146f			; 
146f			; 
146f			;	ret 
146f			 
146f			 
146f			.debug_tog: 
146f 21 b6 14			ld hl, .menudebug 
1472				 
1472 3a f3 e2			ld a, (os_view_disable) 
1475 fe 2a			cp '*' 
1477 20 04			jr nz,.tdon  
1479 3e 01			ld a, 1 
147b 18 02			jr .tog1 
147d 3e 00		.tdon: ld a, 0 
147f			 
147f			.tog1: 
147f cd ab 0b			call menu 
1482 fe 00			cp 0 
1484 c8				ret z 
1485 fe 01			cp 1    ; disable debug 
1487 28 04			jr z, .dtog0 
1489 3e 2a			ld a, '*' 
148b 18 02			jr .dtogset 
148d 3e 00		.dtog0: ld a, 0 
148f 32 f3 e2		.dtogset:  ld (os_view_disable), a 
1492 c3 6f 14			jp .debug_tog 
1495			 
1495			 
1495			hardware_diags:       
1495			 
1495			.diagm: 
1495 21 a8 14			ld hl, .menuitems 
1498 3e 00			ld a, 0 
149a cd ab 0b			call menu 
149d			 
149d fe 00		         cp 0 
149f c8				 ret z 
14a0			 
14a0 fe 02			cp 2 
14a2 ca 01 15			jp z, .diagedit 
14a5			 
14a5			;	cp '6' 
14a5			;	jp z, .menutest 
14a5			;if ENABLE_BASIC 
14a5			;	cp '6' 
14a5			;	jp z, basic 
14a5			;endif 
14a5			  
14a5 c3 95 14			jp .diagm 
14a8			 
14a8				 
14a8 bc 14		.menuitems:   	dw .m1 
14aa c7 14				dw .m2 
14ac ce 14				dw .m3 
14ae d6 14				dw .m5 
14b0 dc 14				dw .m5a 
14b2 e5 14				dw .m5b 
14b4 00 00				dw 0 
14b6			 
14b6			.menudebug: 
14b6 ee 14				dw .m6 
14b8 f7 14				dw .m7 
14ba 00 00				dw 0 
14bc			 
14bc .. 00		.m1:   db "Key Matrix",0 
14c7 .. 00		.m2:   db "Editor",0 
14ce .. 00		.m3:   db "Storage",0 
14d6 .. 00		.m5:   db "Sound",0 
14dc .. 00		.m5a:  db "RAM Test",0 
14e5 .. 00		.m5b:  db "LCD Test",0 
14ee			 
14ee .. 00		.m6:   db "Debug ON",0 
14f7 .. 00		.m7:   db "Debug OFF",0 
1501			 
1501			; debug editor 
1501			 
1501			.diagedit: 
1501			 
1501 21 02 e3			ld hl, scratch 
1504			;	ld bc, 250 
1504			;	ldir 
1504				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1504 3e 00			ld a, 0 
1506 77				ld (hl), a 
1507 23				inc hl 
1508 77				ld (hl), a 
1509 23				inc hl 
150a 77				ld (hl), a 
150b			 
150b cd 7a 0b		        call clear_display 
150e cd 9d 0b			call update_display 
1511				;ld a, 1 
1511				;ld (hardware_diag), a 
1511			.diloop: 
1511 3e 00			ld a, display_row_1 
1513 0e 00			ld c, 0 
1515 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1517 1e 28			ld e, 40 
1519			 
1519 21 02 e3			ld hl, scratch	 
151c cd d4 0d			call input_str 
151f			 
151f 3e 28			ld a, display_row_2 
1521 11 02 e3			ld de, scratch 
1524 cd 8d 0b			call str_at_display 
1527 cd 9d 0b			call update_display 
152a			 
152a c3 11 15			jp .diloop 
152d			 
152d			 
152d			; pass word in hl 
152d			; a has display location 
152d			display_word_at: 
152d f5				push af 
152e e5				push hl 
152f 7c				ld a,h 
1530 21 07 e6			ld hl, os_word_scratch 
1533 cd a8 10			call hexout 
1536 e1				pop hl 
1537 7d				ld a,l 
1538 21 09 e6			ld hl, os_word_scratch+2 
153b cd a8 10			call hexout 
153e 21 0b e6			ld hl, os_word_scratch+4 
1541 3e 00			ld a,0 
1543 77				ld (hl),a 
1544 11 07 e6			ld de,os_word_scratch 
1547 f1				pop af 
1548 cd 8d 0b				call str_at_display 
154b c9				ret 
154c			 
154c			display_ptr_state: 
154c			 
154c				; to restore afterwards 
154c			 
154c d5				push de 
154d c5				push bc 
154e e5				push hl 
154f f5				push af 
1550			 
1550				; for use in here 
1550			 
1550			;	push bc 
1550			;	push de 
1550			;	push hl 
1550			;	push af 
1550			 
1550 cd 7a 0b			call clear_display 
1553			 
1553 11 26 17			ld de, .ptrstate 
1556 3e 00			ld a, display_row_1 
1558 cd 8d 0b			call str_at_display 
155b			 
155b				; display debug step 
155b			 
155b			 
155b 11 71 ee			ld de, debug_mark 
155e 3e 26			ld a, display_row_1+display_cols-2 
1560 cd 8d 0b			call str_at_display 
1563			 
1563				; display a 
1563 11 30 17			ld de, .ptrcliptr 
1566 3e 28			ld a, display_row_2 
1568 cd 8d 0b			call str_at_display 
156b			 
156b f1				pop af 
156c 2a 4d ea			ld hl,(cli_ptr) 
156f 3e 30			ld a, display_row_2+8 
1571 cd 2d 15			call display_word_at 
1574			 
1574			 
1574				; display hl 
1574			 
1574			 
1574 11 38 17			ld de, .ptrclioptr 
1577 3e 32			ld a, display_row_2+10 
1579 cd 8d 0b			call str_at_display 
157c			; 
157c			;	pop hl 
157c 3e 35			ld a, display_row_2+13 
157e 2a 4b ea			ld hl,(cli_origptr) 
1581 cd 2d 15			call display_word_at 
1584			; 
1584			;	 
1584			;	; display de 
1584			 
1584			;	ld de, .regstatede 
1584			;	ld a, display_row_3 
1584			;	call str_at_display 
1584			 
1584			;	pop de 
1584			;	ld h,d 
1584			;	ld l, e 
1584			;	ld a, display_row_3+3 
1584			;	call display_word_at 
1584			 
1584			 
1584				; display bc 
1584			 
1584			;	ld de, .regstatebc 
1584			;	ld a, display_row_3+10 
1584			;	call str_at_display 
1584			 
1584			;	pop bc 
1584			;	ld h,b 
1584			;	ld l, c 
1584			;	ld a, display_row_3+13 
1584			;	call display_word_at 
1584			 
1584			 
1584				; display dsp 
1584			 
1584			;	ld de, .regstatedsp 
1584			;	ld a, display_row_4 
1584			;	call str_at_display 
1584			 
1584				 
1584			;	ld hl,(cli_data_sp) 
1584			;	ld a, display_row_4+4 
1584			;	call display_word_at 
1584			 
1584				; display rsp 
1584			 
1584 11 67 17			ld de, .regstatersp 
1587 3e 82			ld a, display_row_4+10 
1589 cd 8d 0b			call str_at_display 
158c			 
158c				 
158c 2a 33 ea			ld hl,(cli_ret_sp) 
158f 3e 86			ld a, display_row_4+14 
1591 cd 2d 15			call display_word_at 
1594			 
1594 cd 9d 0b			call update_display 
1597			 
1597 cd ec 0a			call delay1s 
159a cd ec 0a			call delay1s 
159d cd ec 0a			call delay1s 
15a0			 
15a0			 
15a0 cd 91 1b			call next_page_prompt 
15a3			 
15a3				; restore  
15a3			 
15a3 f1				pop af 
15a4 e1				pop hl 
15a5 c1				pop bc 
15a6 d1				pop de 
15a7 c9				ret 
15a8			 
15a8			break_point_state: 
15a8 f5				push af 
15a9			 
15a9				; see if disabled 
15a9			 
15a9 3a f3 e2			ld a, (os_view_disable) 
15ac fe 2a			cp '*' 
15ae 20 02			jr nz, .bpsgo 
15b0 f1				pop af 
15b1 c9				ret 
15b2			 
15b2			.bpsgo: 
15b2 f1				pop af 
15b3 f5				push af 
15b4 22 ef e2			ld (os_view_hl), hl 
15b7 ed 53 ed e2		ld (os_view_de), de 
15bb ed 43 eb e2		ld (os_view_bc), bc 
15bf e5				push hl 
15c0 6f				ld l, a 
15c1 26 00			ld h, 0 
15c3 22 f1 e2			ld (os_view_af),hl 
15c6			 
15c6 21 b7 ed				ld hl, display_fb0 
15c9 22 d2 eb				ld (display_fb_active), hl 
15cc e1				pop hl	 
15cd			 
15cd 3e 31			ld a, '1' 
15cf fe 2a		.bps1:  cp '*' 
15d1 20 03			jr nz, .bps1b 
15d3 32 f3 e2			ld (os_view_disable),a 
15d6 fe 31		.bps1b:  cp '1' 
15d8 20 14			jr nz, .bps2 
15da			 
15da				; display reg 
15da			 
15da				 
15da			 
15da 3a f1 e2			ld a, (os_view_af) 
15dd 2a ef e2			ld hl, (os_view_hl) 
15e0 ed 5b ed e2		ld de, (os_view_de) 
15e4 ed 4b eb e2		ld bc, (os_view_bc) 
15e8 cd 82 16			call display_reg_state 
15eb c3 6e 16			jp .bpschk 
15ee			 
15ee fe 32		.bps2:  cp '2' 
15f0 20 08			jr nz, .bps3 
15f2				 
15f2				; display hl 
15f2 2a ef e2			ld hl, (os_view_hl) 
15f5 cd 6c 17			call display_dump_at_hl 
15f8			 
15f8 18 74			jr .bpschk 
15fa			 
15fa fe 33		.bps3:  cp '3' 
15fc 20 08			jr nz, .bps4 
15fe			 
15fe			        ; display de 
15fe 2a ed e2			ld hl, (os_view_de) 
1601 cd 6c 17			call display_dump_at_hl 
1604			 
1604 18 68			jr .bpschk 
1606 fe 34		.bps4:  cp '4' 
1608 20 08			jr nz, .bps5 
160a			 
160a			        ; display bc 
160a 2a eb e2			ld hl, (os_view_bc) 
160d cd 6c 17			call display_dump_at_hl 
1610			 
1610 18 5c			jr .bpschk 
1612 fe 35		.bps5:  cp '5' 
1614 20 08		        jr nz, .bps7 
1616			 
1616				; display cur ptr 
1616 2a 4d ea			ld hl, (cli_ptr) 
1619 cd 6c 17			call display_dump_at_hl 
161c			 
161c 18 50			jr .bpschk 
161e fe 36		.bps7:  cp '6' 
1620 20 08			jr nz, .bps8b 
1622				 
1622				; display cur orig ptr 
1622 2a 4b ea			ld hl, (cli_origptr) 
1625 cd 6c 17			call display_dump_at_hl 
1628 18 44			jr .bpschk 
162a fe 37		.bps8b:  cp '7' 
162c 20 08			jr nz, .bps9 
162e				 
162e				; display dsp 
162e 2a 2f ea			ld hl, (cli_data_sp) 
1631 cd 6c 17			call display_dump_at_hl 
1634			 
1634 18 38			jr .bpschk 
1636 fe 39		.bps9:  cp '9' 
1638 20 05			jr nz, .bps8c 
163a				 
163a				; display SP 
163a			;	ld hl, sp 
163a cd 6c 17			call display_dump_at_hl 
163d			 
163d 18 2f			jr .bpschk 
163f fe 38		.bps8c:  cp '8' 
1641 20 08			jr nz, .bps8d 
1643				 
1643				; display rsp 
1643 2a 33 ea			ld hl, (cli_ret_sp) 
1646 cd 6c 17			call display_dump_at_hl 
1649			 
1649 18 23			jr .bpschk 
164b fe 23		.bps8d:  cp '#'     ; access monitor sub system 
164d 20 05			jr nz, .bps8 
164f cd 87 19			call monitor 
1652			 
1652 18 1a			jr .bpschk 
1654 fe 30		.bps8:  cp '0' 
1656 20 16			jr nz, .bpschk 
1658			 
1658 21 16 ed				ld hl, display_fb1 
165b 22 d2 eb				ld (display_fb_active), hl 
165e cd 9d 0b				call update_display 
1661			 
1661				;ld a, (os_view_af) 
1661 2a ef e2			ld hl, (os_view_hl) 
1664 ed 5b ed e2		ld de, (os_view_de) 
1668 ed 4b eb e2		ld bc, (os_view_bc) 
166c f1				pop af 
166d c9				ret 
166e			 
166e			.bpschk:   
166e cd ec 0a			call delay1s 
1671 3e 9f		ld a,display_row_4 + display_cols - 1 
1673 11 8f 1b		        ld de, endprg 
1676 cd 8d 0b			call str_at_display 
1679 cd 9d 0b			call update_display 
167c cd e8 5b			call cin_wait 
167f			 
167f c3 cf 15			jp .bps1 
1682			 
1682			 
1682			display_reg_state: 
1682			 
1682				; to restore afterwards 
1682			 
1682 d5				push de 
1683 c5				push bc 
1684 e5				push hl 
1685 f5				push af 
1686			 
1686				; for use in here 
1686			 
1686 c5				push bc 
1687 d5				push de 
1688 e5				push hl 
1689 f5				push af 
168a			 
168a cd 7a 0b			call clear_display 
168d			 
168d 11 42 17			ld de, .regstate 
1690 3e 00			ld a, display_row_1 
1692 cd 8d 0b			call str_at_display 
1695			 
1695				; display debug step 
1695			 
1695			 
1695 11 71 ee			ld de, debug_mark 
1698 3e 25			ld a, display_row_1+display_cols-3 
169a cd 8d 0b			call str_at_display 
169d			 
169d				; display a 
169d 11 5e 17			ld de, .regstatea 
16a0 3e 28			ld a, display_row_2 
16a2 cd 8d 0b			call str_at_display 
16a5			 
16a5 e1				pop hl 
16a6			;	ld h,0 
16a6			;	ld l, a 
16a6 3e 2b			ld a, display_row_2+3 
16a8 cd 2d 15			call display_word_at 
16ab			 
16ab			 
16ab				; display hl 
16ab			 
16ab			 
16ab 11 52 17			ld de, .regstatehl 
16ae 3e 32			ld a, display_row_2+10 
16b0 cd 8d 0b			call str_at_display 
16b3			 
16b3 e1				pop hl 
16b4 3e 35			ld a, display_row_2+13 
16b6 cd 2d 15			call display_word_at 
16b9			 
16b9				 
16b9				; display de 
16b9			 
16b9 11 56 17			ld de, .regstatede 
16bc 3e 50			ld a, display_row_3 
16be cd 8d 0b			call str_at_display 
16c1			 
16c1 e1				pop hl 
16c2			;	ld h,d 
16c2			;	ld l, e 
16c2 3e 53			ld a, display_row_3+3 
16c4 cd 2d 15			call display_word_at 
16c7			 
16c7			 
16c7				; display bc 
16c7			 
16c7 11 5a 17			ld de, .regstatebc 
16ca 3e 5a			ld a, display_row_3+10 
16cc cd 8d 0b			call str_at_display 
16cf			 
16cf e1				pop hl 
16d0			;	ld h,b 
16d0			;	ld l, c 
16d0 3e 5d			ld a, display_row_3+13 
16d2 cd 2d 15			call display_word_at 
16d5			 
16d5			 
16d5				; display dsp 
16d5			 
16d5 11 62 17			ld de, .regstatedsp 
16d8 3e 78			ld a, display_row_4 
16da cd 8d 0b			call str_at_display 
16dd			 
16dd				 
16dd 2a 2f ea			ld hl,(cli_data_sp) 
16e0 3e 7c			ld a, display_row_4+4 
16e2 cd 2d 15			call display_word_at 
16e5			 
16e5				; display rsp 
16e5			 
16e5 11 67 17			ld de, .regstatersp 
16e8 3e 82			ld a, display_row_4+10 
16ea cd 8d 0b			call str_at_display 
16ed			 
16ed				 
16ed 2a 33 ea			ld hl,(cli_ret_sp) 
16f0 3e 86			ld a, display_row_4+14 
16f2 cd 2d 15			call display_word_at 
16f5			 
16f5 cd 9d 0b			call update_display 
16f8			 
16f8			;	call delay1s 
16f8			;	call delay1s 
16f8			;	call delay1s 
16f8			 
16f8			 
16f8			;	call next_page_prompt 
16f8			 
16f8				; restore  
16f8			 
16f8 f1				pop af 
16f9 e1				pop hl 
16fa c1				pop bc 
16fb d1				pop de 
16fc c9				ret 
16fd			 
16fd .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1711 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1726 .. 00		.ptrstate:	db "Ptr State",0 
1730 .. 00		.ptrcliptr:     db "cli_ptr",0 
1738 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1742 .. 00		.regstate:	db "Reg State (1/0)",0 
1752 .. 00		.regstatehl:	db "HL:",0 
1756 .. 00		.regstatede:	db "DE:",0 
175a .. 00		.regstatebc:	db "BC:",0 
175e .. 00		.regstatea:	db "A :",0 
1762 .. 00		.regstatedsp:	db "DSP:",0 
1767 .. 00		.regstatersp:	db "RSP:",0 
176c			 
176c			display_dump_at_hl: 
176c e5				push hl 
176d d5				push de 
176e c5				push bc 
176f f5				push af 
1770			 
1770 22 25 e6			ld (os_cur_ptr),hl	 
1773 cd 7a 0b			call clear_display 
1776 cd 99 1a			call dumpcont 
1779			;	call delay1s 
1779			;	call next_page_prompt 
1779			 
1779			 
1779 f1				pop af 
177a c1				pop bc 
177b d1				pop de 
177c e1				pop hl 
177d c9				ret 
177e			 
177e			;if ENABLE_BASIC 
177e			;	include "nascombasic.asm" 
177e			;	basic: 
177e			;	include "forth/FORTH.ASM" 
177e			;endif 
177e			 
177e			; eof 
177e			 
177e			 
# End of file firmware_diags.asm
177e			  
177e			include "firmware_prompts.asm"  
177e			; Prompts  
177e			 
177e			; boot messages 
177e			 
177e .. 00		prom_bootmsg:	db "z80-homebrew OS v1.6",0 
1793 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
17a3			 
17a3			 
17a3			; config menus 
17a3			 
17a3 .. 00		prom_c3: db "Add Dictionary To File",0 
17ba .. 00		prom_c2: db "Select Autoload File",0 
17cf .. 00		prom_c2a: db "Disable Autoload File", 0 
17e5 .. 00		prom_c2b: db "Select Storage Bank",0 
17f9 .. 00		prom_c4: db "Settings",0 
1802 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
181d .. 00		prom_m4b:   db "Monitor",0 
1825 .. 00		prom_c1: db "Hardware Diags",0 
1834			 
1834			 
1834 .. 00		prom_notav:    db "Feature not available",0 
184a .. 00		prom_empty:    db "",0 
184b			 
184b			; eof 
184b			 
# End of file firmware_prompts.asm
184b			  
184b			  
184b			; eof  
184b			  
# End of file firmware.asm
184b			 
184b			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
184b			;if BASE_KEV  
184b			;baseram: equ 08000h 
184b			;endif 
184b			 
184b			;if BASE_SC114 
184b			;baseram:     equ    endofcode 
184b			;endif 
184b			 
184b			 
184b			; start system 
184b			 
184b			coldstart: 
184b				; set sp 
184b				; di/ei 
184b			 
184b f3				di 
184c 31 00 f0			ld sp, tos 
184f			;	ei 
184f			 
184f			 
184f				; disable breakpoint by default 
184f			 
184f 3e 2a			ld a,'*' 
1851 32 f3 e2			ld (os_view_disable),a 
1854			 
1854				; init hardware 
1854			 
1854				; init keyboard and screen hardware 
1854			 
1854 cd 1c 01			call hardware_init 
1857			 
1857			 
1857 cd ec 0a			call delay1s 
185a 3e 58			ld a, display_row_3+8 
185c 11 03 01			ld de, buildtime 
185f cd 8d 0b			call str_at_display 
1862 cd 9d 0b			call update_display 
1865			 
1865 cd ec 0a			call delay1s 
1868 cd ec 0a			call delay1s 
186b cd ec 0a			call delay1s 
186e			 
186e				; detect if any keys are held down to enable breakpoints at start up 
186e			 
186e cd f0 5b			call cin  
1871 fe 00			cp 0 
1873 28 03			jr z, .nokeys 
1875			 
1875				;call hardware_diags 
1875 cd 07 14			call config 
1878			 
1878			;	ld de, .bpen 
1878			;	ld a, display_row_4 
1878			;	call str_at_display 
1878			;	call update_display 
1878			; 
1878			;	ld a,0 
1878			;	ld (os_view_disable),a 
1878			; 
1878			;.bpwait: 
1878			;	call cin 
1878			;	cp 0 
1878			;	jr z, .bpwait 
1878			;	jr .nokeys 
1878			; 
1878			; 
1878			;.bpen:  db "Break points enabled!",0 
1878			 
1878			 
1878			 
1878			 
1878			 
1878			 
1878			.nokeys: 
1878			 
1878			 
1878				 
1878			 
1878			;jp  testkey 
1878			 
1878			;call storage_get_block_0 
1878			; 
1878			;ld hl, 0 
1878			;ld de, store_page 
1878			;call storage_read_block 
1878			 
1878				 
1878			;ld hl, 10 
1878			;ld de, store_page 
1878			;call storage_read_block 
1878			 
1878			 
1878			 
1878			 
1878			 
1878			;stop:	nop 
1878			;	jp stop 
1878			 
1878			 
1878			 
1878			main: 
1878 cd 7a 0b			call clear_display 
187b cd 9d 0b			call update_display 
187e			 
187e			 
187e			 
187e			;	call testlcd 
187e			 
187e			 
187e			 
187e cd 57 1f			call forth_init 
1881			 
1881			 
1881			warmstart: 
1881 cd 2d 1f			call forth_warmstart 
1884			 
1884				; run startup word load 
1884			        ; TODO prevent this running at warmstart after crash  
1884			 
1884				if STARTUP_ENABLE 
1884					if STORAGE_SE 
1884						call forth_autoload 
1884					endif 
1884 cd 36 58				call forth_startup 
1887			 
1887			 
1887				endif 
1887			 
1887				; show free memory after boot 
1887 11 21 19			ld de, freeram 
188a 3e 00			ld a, display_row_1 
188c cd 8d 0b			call str_at_display 
188f			 
188f			; Or use heap_size word???? 
188f 21 e8 e2			ld hl, heap_end 
1892 11 18 5c			ld de, heap_start 
1895 ed 52			sbc hl, de 
1897 e5				push hl 
1898 7c				ld a,h	         	 
1899 21 07 e6			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
189c cd a8 10			call hexout 
189f e1			   	pop hl 
18a0			 
18a0 7d				ld a,l 
18a1 21 09 e6			ld hl, os_word_scratch+2 
18a4 cd a8 10			call hexout 
18a7 21 0b e6			ld hl, os_word_scratch+4 
18aa 3e 00			ld a, 0 
18ac 77				ld (hl),a 
18ad 11 07 e6			ld de, os_word_scratch 
18b0 3e 0d			ld a, display_row_1 + 13 
18b2 cd 8d 0b			call str_at_display 
18b5 cd 9d 0b			call update_display 
18b8			 
18b8			 
18b8				;call demo 
18b8			 
18b8			 
18b8				; init scratch input area for cli commands 
18b8			 
18b8 21 29 e6			ld hl, os_cli_cmd 
18bb 3e 00			ld a,0 
18bd 77				ld (hl),a 
18be 23				inc hl 
18bf 77				ld (hl),a 
18c0			 
18c0 3e 00			ld a,0 
18c2 32 28 e7			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
18c5			 
18c5 32 25 e6			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
18c8 32 26 e6			ld (os_cur_ptr+1),a	 
18cb			 
18cb 32 07 e6			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
18ce 32 08 e6			ld (os_word_scratch+1),a	 
18d1				 
18d1			 
18d1				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
18d1 21 29 e6			ld hl, os_cli_cmd 
18d4			 
18d4 3e 00			ld a, 0		 ; init cli input 
18d6 77				ld (hl), a 
18d7 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
18d9			cli: 
18d9				; show cli prompt 
18d9				;push af 
18d9				;ld a, 0 
18d9				;ld de, prompt 
18d9				;call str_at_display 
18d9			 
18d9				;call update_display 
18d9				;pop af 
18d9				;inc a 
18d9				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
18d9 0e 00			ld c, 0 
18db 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
18dd 1e 28			ld e, 40 
18df			 
18df 21 29 e6			ld hl, os_cli_cmd 
18e2			 
18e2				STACKFRAME OFF $fefe $9f9f 
18e2				if DEBUG_STACK_IMB 
18e2					if OFF 
18e2						exx 
18e2						ld de, $fefe 
18e2						ld a, d 
18e2						ld hl, curframe 
18e2						call hexout 
18e2						ld a, e 
18e2						ld hl, curframe+2 
18e2						call hexout 
18e2						ld hl, $fefe 
18e2						push hl 
18e2						ld hl, $9f9f 
18e2						push hl 
18e2						exx 
18e2					endif 
18e2				endif 
18e2			endm 
# End of macro STACKFRAME
18e2			 
18e2 cd d4 0d			call input_str 
18e5			 
18e5				STACKFRAMECHK OFF $fefe $9f9f 
18e5				if DEBUG_STACK_IMB 
18e5					if OFF 
18e5						exx 
18e5						ld hl, $9f9f 
18e5						pop de   ; $9f9f 
18e5						call cmp16 
18e5						jr nz, .spnosame 
18e5						ld hl, $fefe 
18e5						pop de   ; $fefe 
18e5						call cmp16 
18e5						jr z, .spfrsame 
18e5						.spnosame: call showsperror 
18e5						.spfrsame: nop 
18e5						exx 
18e5					endif 
18e5				endif 
18e5			endm 
# End of macro STACKFRAMECHK
18e5			 
18e5				; copy input to last command 
18e5			 
18e5 21 29 e6			ld hl, os_cli_cmd 
18e8 11 28 e7			ld de, os_last_cmd 
18eb 01 ff 00			ld bc, 255 
18ee ed b0			ldir 
18f0			 
18f0				; wipe current buffer 
18f0			 
18f0			;	ld a, 0 
18f0			;	ld hl, os_cli_cmd 
18f0			;	ld de, os_cli_cmd+1 
18f0			;	ld bc, 254 
18f0			;	ldir 
18f0				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
18f0			;	call strcpy 
18f0			;	ld a, 0 
18f0			;	ld (hl), a 
18f0			;	inc hl 
18f0			;	ld (hl), a 
18f0			;	inc hl 
18f0			;	ld (hl), a 
18f0			 
18f0				; switch frame buffer to program  
18f0			 
18f0 21 16 ed				ld hl, display_fb1 
18f3 22 d2 eb				ld (display_fb_active), hl 
18f6			 
18f6			;	nop 
18f6				STACKFRAME ON $fbfe $8f9f 
18f6				if DEBUG_STACK_IMB 
18f6					if ON 
18f6						exx 
18f6						ld de, $fbfe 
18f6						ld a, d 
18f6						ld hl, curframe 
18f6						call hexout 
18f6						ld a, e 
18f6						ld hl, curframe+2 
18f6						call hexout 
18f6						ld hl, $fbfe 
18f6						push hl 
18f6						ld hl, $8f9f 
18f6						push hl 
18f6						exx 
18f6					endif 
18f6				endif 
18f6			endm 
# End of macro STACKFRAME
18f6				; first time into the parser so pass over the current scratch pad 
18f6 21 29 e6			ld hl,os_cli_cmd 
18f9				; tokenise the entered statement(s) in HL 
18f9 cd d5 1f			call forthparse 
18fc			        ; exec forth statements in top of return stack 
18fc cd 15 20			call forthexec 
18ff				;call forthexec_cleanup 
18ff			;	call parsenext 
18ff			 
18ff				STACKFRAMECHK ON $fbfe $8f9f 
18ff				if DEBUG_STACK_IMB 
18ff					if ON 
18ff						exx 
18ff						ld hl, $8f9f 
18ff						pop de   ; $8f9f 
18ff						call cmp16 
18ff						jr nz, .spnosame 
18ff						ld hl, $fbfe 
18ff						pop de   ; $fbfe 
18ff						call cmp16 
18ff						jr z, .spfrsame 
18ff						.spnosame: call showsperror 
18ff						.spfrsame: nop 
18ff						exx 
18ff					endif 
18ff				endif 
18ff			endm 
# End of macro STACKFRAMECHK
18ff				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
18ff			 
18ff 3e 78			ld a, display_row_4 
1901 11 33 19			ld de, endprog 
1904			 
1904 cd 9d 0b			call update_display		 
1907			 
1907 cd 91 1b			call next_page_prompt 
190a			 
190a				; switch frame buffer to cli 
190a			 
190a 21 b7 ed				ld hl, display_fb0 
190d 22 d2 eb				ld (display_fb_active), hl 
1910			 
1910			 
1910 cd 7a 0b		        call clear_display 
1913 cd 9d 0b			call update_display		 
1916			 
1916 21 29 e6			ld hl, os_cli_cmd 
1919			 
1919 3e 00			ld a, 0		 ; init cli input 
191b 77				ld (hl), a 
191c			 
191c				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
191c			 
191c				; now on last line 
191c			 
191c				; TODO scroll screen up 
191c			 
191c				; TODO instead just clear screen and place at top of screen 
191c			 
191c			;	ld a, 0 
191c			;	ld (f_cursor_ptr),a 
191c			 
191c				;call clear_display 
191c				;call update_display 
191c			 
191c				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
191c 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
191e c3 d9 18			jp cli 
1921			 
1921 .. 00		freeram: db "Free bytes: $",0 
192f ..			asc: db "1A2F" 
1933 .. 00		endprog: db "End prog...",0 
193f			 
193f			testenter2:   
193f 21 34 e3			ld hl,scratch+50 
1942 22 25 e6			ld (os_cur_ptr),hl 
1945 c3 d9 18			jp cli 
1948			 
1948			testenter:  
1948			 
1948 21 2f 19			ld hl,asc 
194b			;	ld a,(hl) 
194b			;	call nibble2val 
194b cd fe 10			call get_byte 
194e			 
194e			 
194e			;	ld a,(hl) 
194e			;	call atohex 
194e			 
194e			;	call fourehexhl 
194e 32 34 e3			ld (scratch+50),a 
1951			 
1951			 
1951			 
1951 21 31 19			ld hl,asc+2 
1954			;	ld a, (hl) 
1954			;	call nibble2val 
1954 cd fe 10			call get_byte 
1957			 
1957			;	call fourehexhl 
1957 32 36 e3			ld (scratch+52),a 
195a				 
195a 21 34 e3			ld hl,scratch+50 
195d 22 25 e6			ld (os_cur_ptr),hl 
1960 c3 d9 18			jp cli 
1963			 
1963			enter:	 
1963 3a 06 e3			ld a,(scratch+4) 
1966 fe 00			cp 0 
1968 28 0c			jr z, .entercont 
196a				; no, not a null term line so has an address to work out.... 
196a			 
196a 21 04 e3			ld hl,scratch+2 
196d cd 5e 11			call get_word_hl 
1970			 
1970 22 25 e6			ld (os_cur_ptr),hl	 
1973 c3 d9 18			jp cli 
1976			 
1976			 
1976			.entercont:  
1976			 
1976 21 04 e3			ld hl, scratch+2 
1979 cd fe 10			call get_byte 
197c			 
197c 2a 25 e6		   	ld hl,(os_cur_ptr) 
197f 77					ld (hl),a 
1980 23					inc hl 
1981 22 25 e6				ld (os_cur_ptr),hl 
1984				 
1984			; get byte  
1984			 
1984			 
1984 c3 d9 18			jp cli 
1987			 
1987			 
1987			; basic monitor support 
1987			 
1987			monitor: 
1987				;  
1987 cd 7a 0b			call clear_display 
198a 3e 00			ld a, 0 
198c 11 d4 19			ld de, .monprompt 
198f cd 8d 0b			call str_at_display 
1992 cd 9d 0b			call update_display 
1995			 
1995				; get a monitor command 
1995			 
1995 0e 00			ld c, 0     ; entry at top left 
1997 16 64			ld d, 100   ; max buffer size 
1999 1e 0f			ld e, 15    ; input scroll area 
199b 3e 00			ld a, 0     ; init string 
199d 21 00 e5			ld hl, os_input 
19a0 77				ld (hl), a 
19a1 23				inc hl 
19a2 77				ld (hl), a 
19a3 21 00 e5			ld hl, os_input 
19a6 3e 01			ld a, 1     ; init string 
19a8 cd d4 0d			call input_str 
19ab			 
19ab cd 7a 0b		        call clear_display 
19ae cd 9d 0b			call update_display		 
19b1			 
19b1 3a 00 e5			ld a, (os_input) 
19b4 cd fc 11			call toUpper 
19b7 fe 48		        cp 'H' 
19b9 28 6f		        jr z, .monhelp 
19bb fe 44			cp 'D'		; dump 
19bd ca 4b 1a			jp z, .mondump	 
19c0 fe 43			cp 'C'		; dump 
19c2 ca 65 1a			jp z, .moncdump	 
19c5 fe 4d			cp 'M'		; dump 
19c7 ca d6 19			jp z, .moneditstart 
19ca fe 55			cp 'U'		; dump 
19cc 28 14			jr z, .monedit	 
19ce fe 51			cp 'Q'		; dump 
19d0 c8				ret z	 
19d1			 
19d1			 
19d1				; TODO "S" to access symbol by name and not need the address 
19d1				; TODO "F" to find a string in memory 
19d1			 
19d1 c3 87 19			jp monitor 
19d4			 
19d4 .. 00		.monprompt: db ">", 0 
19d6			 
19d6			.moneditstart: 
19d6				; get starting address 
19d6			 
19d6 21 02 e5			ld hl,os_input+2 
19d9 cd 5e 11			call get_word_hl 
19dc			 
19dc 22 25 e6			ld (os_cur_ptr),hl	 
19df			 
19df c3 87 19			jp monitor 
19e2			 
19e2			.monedit: 
19e2				; get byte to load 
19e2			 
19e2 21 02 e5			ld hl,os_input+2 
19e5 cd fe 10			call get_byte 
19e8			 
19e8				; get address to update 
19e8 2a 25 e6			ld hl, (os_cur_ptr) 
19eb			 
19eb				; update byte 
19eb			 
19eb 77				ld (hl), a 
19ec			 
19ec				; move to next address and save it 
19ec			 
19ec 23				inc hl 
19ed 22 25 e6			ld (os_cur_ptr),hl	 
19f0			 
19f0 c3 87 19			jp monitor 
19f3			 
19f3			 
19f3 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1a07 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1a23 .. 00		.monhelptext3:  db "Q-Quit",0 
1a2a			        
1a2a			.monhelp: 
1a2a 3e 00			ld a, display_row_1 
1a2c 11 f3 19		        ld de, .monhelptext1 
1a2f			 
1a2f cd 8d 0b			call str_at_display 
1a32 3e 28			ld a, display_row_2 
1a34 11 07 1a		        ld de, .monhelptext2 
1a37					 
1a37 cd 8d 0b			call str_at_display 
1a3a 3e 50			ld a, display_row_3 
1a3c 11 23 1a		        ld de, .monhelptext3 
1a3f					 
1a3f cd 8d 0b			call str_at_display 
1a42 cd 9d 0b			call update_display		 
1a45			 
1a45 cd 91 1b			call next_page_prompt 
1a48 c3 87 19			jp monitor 
1a4b			 
1a4b			.mondump:    
1a4b 21 02 e5			ld hl,os_input+2 
1a4e cd 5e 11			call get_word_hl 
1a51			 
1a51 22 25 e6			ld (os_cur_ptr),hl	 
1a54 cd 99 1a			call dumpcont 
1a57 3e 78			ld a, display_row_4 
1a59 11 33 19			ld de, endprog 
1a5c			 
1a5c cd 9d 0b			call update_display		 
1a5f			 
1a5f cd 91 1b			call next_page_prompt 
1a62 c3 87 19			jp monitor 
1a65			.moncdump: 
1a65 cd 99 1a			call dumpcont 
1a68 3e 78			ld a, display_row_4 
1a6a 11 33 19			ld de, endprog 
1a6d			 
1a6d cd 9d 0b			call update_display		 
1a70			 
1a70 cd 91 1b			call next_page_prompt 
1a73 c3 87 19			jp monitor 
1a76			 
1a76			 
1a76			; TODO symbol access  
1a76			 
1a76			.symbols:     ;; A list of symbols that can be called up  
1a76 b7 ed			dw display_fb0 
1a78 .. 00			db "fb0",0  
1a7c 84 ea		     	dw store_page 
1a7e .. 00			db "store_page",0 
1a89			 
1a89			 
1a89			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1a89			 
1a89 3a 03 e3			ld a,(scratch+1) 
1a8c fe 00			cp 0 
1a8e 28 09			jr z, dumpcont 
1a90			 
1a90				; no, not a null term line so has an address to work out.... 
1a90			 
1a90 21 04 e3			ld hl,scratch+2 
1a93 cd 5e 11			call get_word_hl 
1a96			 
1a96 22 25 e6			ld (os_cur_ptr),hl	 
1a99			 
1a99			 
1a99			 
1a99			dumpcont: 
1a99			 
1a99				; dump bytes at ptr 
1a99			 
1a99			 
1a99 3e 00			ld a, display_row_1 
1a9b 2a d2 eb			ld hl, (display_fb_active) 
1a9e cd a7 0d			call addatohl 
1aa1 cd c9 1a			call .dumpbyterow 
1aa4			 
1aa4 3e 28			ld a, display_row_2 
1aa6 2a d2 eb			ld hl, (display_fb_active) 
1aa9 cd a7 0d			call addatohl 
1aac cd c9 1a			call .dumpbyterow 
1aaf			 
1aaf			 
1aaf 3e 50			ld a, display_row_3 
1ab1 2a d2 eb			ld hl, (display_fb_active) 
1ab4 cd a7 0d			call addatohl 
1ab7 cd c9 1a			call .dumpbyterow 
1aba			 
1aba 3e 78			ld a, display_row_4 
1abc 2a d2 eb			ld hl, (display_fb_active) 
1abf cd a7 0d			call addatohl 
1ac2 cd c9 1a			call .dumpbyterow 
1ac5			 
1ac5 cd 9d 0b			call update_display 
1ac8			;		jp cli 
1ac8 c9				ret 
1ac9			 
1ac9			.dumpbyterow: 
1ac9			 
1ac9				;push af 
1ac9			 
1ac9 e5				push hl 
1aca			 
1aca				; calc where to poke the ascii 
1aca			if display_cols == 20 
1aca				ld a, 16 
1aca			else 
1aca 3e 1f			ld a, 31 
1acc			endif 
1acc			 
1acc cd a7 0d			call addatohl 
1acf 22 07 e6			ld (os_word_scratch),hl  		; save pos for later 
1ad2			 
1ad2			 
1ad2			; display decoding address 
1ad2 2a 25 e6		   	ld hl,(os_cur_ptr) 
1ad5			 
1ad5 7c				ld a,h 
1ad6 e1				pop hl 
1ad7 e5				push hl 
1ad8			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1ad8 cd a8 10			call hexout 
1adb 2a 25 e6		   	ld hl,(os_cur_ptr) 
1ade			 
1ade 7d				ld a,l 
1adf e1				pop hl 
1ae0 23				inc hl 
1ae1 23				inc hl 
1ae2 e5				push hl 
1ae3			;	ld hl, os_word_scratch+2 
1ae3 cd a8 10			call hexout 
1ae6 e1				pop hl 
1ae7 23				inc hl 
1ae8 23				inc hl 
1ae9				;ld hl, os_word_scratch+4 
1ae9 3e 3a			ld a, ':' 
1aeb 77				ld (hl),a 
1aec 23				inc hl 
1aed				;ld a, 0 
1aed				;ld (hl),a 
1aed				;ld de, os_word_scratch 
1aed				;pop af 
1aed				;push af 
1aed			;		ld a, display_row_2 
1aed			;		call str_at_display 
1aed			;		call update_display 
1aed			 
1aed			 
1aed			;pop af 
1aed			;	add 5 
1aed			 
1aed			if display_cols == 20 
1aed				ld b, 4 
1aed			else 
1aed 06 08			ld b, 8 
1aef			endif	 
1aef			 
1aef			.dumpbyte: 
1aef c5				push bc 
1af0 e5				push hl 
1af1			 
1af1			 
1af1 2a 25 e6		   	ld hl,(os_cur_ptr) 
1af4 7e					ld a,(hl) 
1af5			 
1af5					; poke the ascii to display 
1af5 2a 07 e6				ld hl,(os_word_scratch) 
1af8 77					ld (hl),a 
1af9 23					inc hl 
1afa 22 07 e6				ld (os_word_scratch),hl 
1afd			 
1afd					 
1afd			 
1afd			 
1afd e1					pop hl 
1afe e5					push hl 
1aff			 
1aff cd a8 10				call hexout 
1b02			 
1b02					 
1b02 2a 25 e6		   	ld hl,(os_cur_ptr) 
1b05 23				inc hl 
1b06 22 25 e6		   	ld (os_cur_ptr),hl 
1b09			 
1b09 e1					pop hl 
1b0a 23					inc hl 
1b0b 23					inc hl 
1b0c 23					inc hl 
1b0d			 
1b0d			 
1b0d			 
1b0d					;ld a,0 
1b0d					;ld (os_word_scratch+2),a 
1b0d					;pop af 
1b0d					;push af 
1b0d			 
1b0d					;ld de, os_word_scratch 
1b0d					;call str_at_display 
1b0d			;		call update_display 
1b0d			;		pop af 
1b0d c1					pop bc 
1b0e c6 03				add 3 
1b10 10 dd			djnz .dumpbyte 
1b12			 
1b12				 
1b12			 
1b12 c9				ret 
1b13			 
1b13			jump:	 
1b13			 
1b13 21 04 e3			ld hl,scratch+2 
1b16 cd 5e 11			call get_word_hl 
1b19				;ld hl,(scratch+2) 
1b19				;call fourehexhl 
1b19			 
1b19 22 25 e6			ld (os_cur_ptr),hl	 
1b1c			 
1b1c e9				jp (hl) 
1b1d			 
1b1d			 
1b1d			 
1b1d			; TODO implement a basic monitor mode to start with 
1b1d			 
1b1d			 
1b1d			 
1b1d			 
1b1d			 
1b1d			 
1b1d			 
1b1d			 
1b1d			 
1b1d			; testing and demo code during development 
1b1d			 
1b1d			 
1b1d .. 00		str1: db "Enter some text...",0 
1b30 .. 00		clear: db "                    ",0 
1b45			 
1b45			demo: 
1b45			 
1b45			 
1b45			 
1b45			;	call update_display 
1b45			 
1b45				; init scratch input area for testing 
1b45 21 02 e3			ld hl, scratch	 
1b48 3e 00			ld a,0 
1b4a 77				ld (hl),a 
1b4b			 
1b4b			 
1b4b 3e 28		            LD   A, display_row_2 
1b4d			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b4d 11 1d 1b		            LD   DE, str1 
1b50 cd 8d 0b			call str_at_display 
1b53			 
1b53			;            CALL fLCD_Str       ;Display string pointed to by DE 
1b53			cloop:	 
1b53 3e 50		            LD   A, display_row_3 
1b55			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b55 11 30 1b		            LD   DE, clear 
1b58			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1b58 cd 8d 0b				call str_at_display 
1b5b 3e 78			ld a, display_row_4 
1b5d 11 8d 1b			ld de, prompt 
1b60			 
1b60 cd 8d 0b				call str_at_display 
1b63 cd 9d 0b			call update_display 
1b66			 
1b66 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1b68 16 0a			ld d, 10 
1b6a 21 02 e3			ld hl, scratch	 
1b6d cd d4 0d			call input_str 
1b70			 
1b70			;	call clear_display 
1b70			;'	call update_display 
1b70			 
1b70 3e 00		            LD   A, display_row_1 
1b72			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b72 11 30 1b		            LD   DE, clear 
1b75 cd 8d 0b				call str_at_display 
1b78			;            CALL fLCD_Str       ;Display string pointed to by DE 
1b78 3e 00		            LD   A, display_row_1 
1b7a			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b7a 11 02 e3		            LD   DE, scratch 
1b7d			;            CALL fLCD_Str       ;Display string pointed to by DE 
1b7d cd 8d 0b				call str_at_display 
1b80 cd 9d 0b			call update_display 
1b83			 
1b83 3e 00				ld a,0 
1b85 21 02 e3			ld hl, scratch 
1b88 77				ld (hl),a 
1b89			 
1b89 00				nop 
1b8a c3 53 1b			jp cloop 
1b8d			 
1b8d			 
1b8d			 
1b8d			; OS Prompt 
1b8d			 
1b8d .. 00		prompt: db ">",0 
1b8f .. 00		endprg: db "?",0 
1b91			 
1b91			 
1b91			; handy next page prompt 
1b91			next_page_prompt: 
1b91 e5				push hl 
1b92 d5				push de 
1b93 f5				push af 
1b94 c5				push bc 
1b95			 
1b95 3e 9f			ld a,display_row_4 + display_cols - 1 
1b97 11 8f 1b		        ld de, endprg 
1b9a cd 8d 0b			call str_at_display 
1b9d cd 9d 0b			call update_display 
1ba0 cd e8 5b			call cin_wait 
1ba3 c1				pop bc 
1ba4 f1				pop af 
1ba5 d1				pop de 
1ba6 e1				pop hl 
1ba7			 
1ba7			 
1ba7 c9				ret 
1ba8			 
1ba8			 
1ba8			; forth parser 
1ba8			 
1ba8			; My forth kernel 
1ba8			include "forth_kernel.asm" 
1ba8			; 
1ba8			; kernel to the forth OS 
1ba8			 
1ba8			DS_TYPE_STR: equ 1     ; string type 
1ba8			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1ba8			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1ba8			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1ba8			 
1ba8			FORTH_PARSEV1: equ 0 
1ba8			FORTH_PARSEV2: equ 0 
1ba8			FORTH_PARSEV3: equ 0 
1ba8			FORTH_PARSEV4: equ 0 
1ba8			FORTH_PARSEV5: equ 1 
1ba8			 
1ba8			;if FORTH_PARSEV5 
1ba8			;	FORTH_END_BUFFER: equ 0 
1ba8			;else 
1ba8			FORTH_END_BUFFER: equ 127 
1ba8			;endif 
1ba8			 
1ba8			FORTH_TRUE: equ 1 
1ba8			FORTH_FALSE: equ 0 
1ba8			 
1ba8			if FORTH_PARSEV4 
1ba8			include "forth_stackops.asm" 
1ba8			endif 
1ba8			 
1ba8			if FORTH_PARSEV5 
1ba8			include "forth_stackopsv5.asm" 
1ba8			 
1ba8			; Stack operations for v5 parser on wards 
1ba8			; * DATA stack 
1ba8			; * LOOP stack 
1ba8			; * RETURN stack 
1ba8			 
1ba8			 
1ba8			 
1ba8			FORTH_CHK_DSP_UNDER: macro 
1ba8				push hl 
1ba8				push de 
1ba8				ld hl,(cli_data_sp) 
1ba8				ld de, cli_data_stack 
1ba8				call cmp16 
1ba8				jp c, fault_dsp_under 
1ba8				pop de 
1ba8				pop hl 
1ba8				endm 
1ba8			 
1ba8			 
1ba8			FORTH_CHK_RSP_UNDER: macro 
1ba8				push hl 
1ba8				push de 
1ba8				ld hl,(cli_ret_sp) 
1ba8				ld de, cli_ret_stack 
1ba8				call cmp16 
1ba8				jp c, fault_rsp_under 
1ba8				pop de 
1ba8				pop hl 
1ba8				endm 
1ba8			 
1ba8			FORTH_CHK_LOOP_UNDER: macro 
1ba8				push hl 
1ba8				push de 
1ba8				ld hl,(cli_loop_sp) 
1ba8				ld de, cli_loop_stack 
1ba8				call cmp16 
1ba8				jp c, fault_loop_under 
1ba8				pop de 
1ba8				pop hl 
1ba8				endm 
1ba8			 
1ba8			FORTH_ERR_TOS_NOTSTR: macro 
1ba8				; TOSO might need more for checks when used 
1ba8				push af 
1ba8				ld a,(hl) 
1ba8				cp DS_TYPE_STR 
1ba8				jp nz, type_faultn   
1ba8				pop af 
1ba8				endm 
1ba8			 
1ba8			FORTH_ERR_TOS_NOTNUM: macro 
1ba8				push af 
1ba8				ld a,(hl) 
1ba8				cp DS_TYPE_INUM 
1ba8				jp nz, type_faultn   
1ba8				pop af 
1ba8				endm 
1ba8			 
1ba8			 
1ba8			; increase data stack pointer and save hl to it 
1ba8				 
1ba8			FORTH_DSP_NEXT: macro 
1ba8				call macro_forth_dsp_next 
1ba8				endm 
1ba8			 
1ba8			 
1ba8			macro_forth_dsp_next: 
1ba8				if DEBUG_FORTH_STACK_GUARD 
1ba8 cd 00 59				call check_stacks 
1bab				endif 
1bab e5				push hl 
1bac d5				push de 
1bad eb				ex de,hl 
1bae 2a 2f ea			ld hl,(cli_data_sp) 
1bb1 23				inc hl 
1bb2 23				inc hl 
1bb3			 
1bb3			; PARSEV5 
1bb3 23				inc hl 
1bb4 22 2f ea			ld (cli_data_sp),hl 
1bb7 73				ld (hl), e 
1bb8 23				inc hl 
1bb9 72				ld (hl), d 
1bba d1				pop de 
1bbb e1				pop hl 
1bbc				if DEBUG_FORTH_STACK_GUARD 
1bbc cd 00 59				call check_stacks 
1bbf				endif 
1bbf c9				ret 
1bc0			 
1bc0			 
1bc0			; increase ret stack pointer and save hl to it 
1bc0				 
1bc0			FORTH_RSP_NEXT: macro 
1bc0				call macro_forth_rsp_next 
1bc0				endm 
1bc0			 
1bc0			macro_forth_rsp_next: 
1bc0				if DEBUG_FORTH_STACK_GUARD 
1bc0 cd 00 59				call check_stacks 
1bc3				endif 
1bc3 e5				push hl 
1bc4 d5				push de 
1bc5 eb				ex de,hl 
1bc6 2a 33 ea			ld hl,(cli_ret_sp) 
1bc9 23				inc hl 
1bca 23				inc hl 
1bcb 22 33 ea			ld (cli_ret_sp),hl 
1bce 73				ld (hl), e 
1bcf 23				inc hl 
1bd0 72				ld (hl), d 
1bd1 d1				pop de 
1bd2 e1				pop hl 
1bd3				if DEBUG_FORTH_STACK_GUARD 
1bd3 cd 00 59				call check_stacks 
1bd6				endif 
1bd6 c9				ret 
1bd7			 
1bd7			; get current ret stack pointer and save to hl  
1bd7				 
1bd7			FORTH_RSP_TOS: macro 
1bd7				call macro_forth_rsp_tos 
1bd7				endm 
1bd7			 
1bd7			macro_forth_rsp_tos: 
1bd7				;push de 
1bd7 2a 33 ea			ld hl,(cli_ret_sp) 
1bda cd 12 1c			call loadhlptrtohl 
1bdd				;ld e, (hl) 
1bdd				;inc hl 
1bdd				;ld d, (hl) 
1bdd				;ex de, hl 
1bdd					if DEBUG_FORTH_WORDS 
1bdd			;			DMARK "RST" 
1bdd						CALLMONITOR 
1bdd cd a8 15			call break_point_state  
1be0				endm  
# End of macro CALLMONITOR
1be0					endif 
1be0				;pop de 
1be0 c9				ret 
1be1			 
1be1			; pop ret stack pointer 
1be1				 
1be1			FORTH_RSP_POP: macro 
1be1				call macro_forth_rsp_pop 
1be1				endm 
1be1			 
1be1			 
1be1			macro_forth_rsp_pop: 
1be1				if DEBUG_FORTH_STACK_GUARD 
1be1			;		DMARK "RPP" 
1be1 cd 00 59				call check_stacks 
1be4					FORTH_CHK_RSP_UNDER 
1be4 e5				push hl 
1be5 d5				push de 
1be6 2a 33 ea			ld hl,(cli_ret_sp) 
1be9 11 ed e9			ld de, cli_ret_stack 
1bec cd c5 0d			call cmp16 
1bef da 14 5a			jp c, fault_rsp_under 
1bf2 d1				pop de 
1bf3 e1				pop hl 
1bf4				endm 
# End of macro FORTH_CHK_RSP_UNDER
1bf4				endif 
1bf4 e5				push hl 
1bf5 2a 33 ea			ld hl,(cli_ret_sp) 
1bf8			 
1bf8			 
1bf8				if FORTH_ENABLE_FREE 
1bf8			 
1bf8					; get pointer 
1bf8			 
1bf8					push de 
1bf8					push hl 
1bf8			 
1bf8					ld e, (hl) 
1bf8					inc hl 
1bf8					ld d, (hl) 
1bf8			 
1bf8					ex de, hl 
1bf8					call free 
1bf8			 
1bf8					pop hl 
1bf8					pop de 
1bf8			 
1bf8			 
1bf8				endif 
1bf8			 
1bf8			 
1bf8 2b				dec hl 
1bf9 2b				dec hl 
1bfa 22 33 ea			ld (cli_ret_sp), hl 
1bfd				; do stack underflow checks 
1bfd e1				pop hl 
1bfe				if DEBUG_FORTH_STACK_GUARD 
1bfe cd 00 59				call check_stacks 
1c01					FORTH_CHK_RSP_UNDER 
1c01 e5				push hl 
1c02 d5				push de 
1c03 2a 33 ea			ld hl,(cli_ret_sp) 
1c06 11 ed e9			ld de, cli_ret_stack 
1c09 cd c5 0d			call cmp16 
1c0c da 14 5a			jp c, fault_rsp_under 
1c0f d1				pop de 
1c10 e1				pop hl 
1c11				endm 
# End of macro FORTH_CHK_RSP_UNDER
1c11				endif 
1c11 c9				ret 
1c12			 
1c12			 
1c12			 
1c12			; routine to load word pointed to by hl into hl 
1c12			 
1c12			loadhlptrtohl: 
1c12			 
1c12 d5				push de 
1c13 5e				ld e, (hl) 
1c14 23				inc hl 
1c15 56				ld d, (hl) 
1c16 eb				ex de, hl 
1c17 d1				pop de 
1c18			 
1c18 c9				ret 
1c19			 
1c19			 
1c19			 
1c19			 
1c19			 
1c19			; push a number held in HL onto the data stack 
1c19			; entry point for pushing a value when already in hl used in function above 
1c19			 
1c19			forth_push_numhl: 
1c19			 
1c19 e5				push hl    ; save value to push 
1c1a			 
1c1a			if DEBUG_FORTH_PUSH 
1c1a				; see if disabled 
1c1a			 
1c1a			 
1c1a f5				push af 
1c1b 3a f3 e2			ld a, (os_view_disable) 
1c1e fe 2a			cp '*' 
1c20 28 34			jr z, .pskip2 
1c22 e5				push hl 
1c23 e5			push hl 
1c24 cd 7a 0b			call clear_display 
1c27 e1			pop hl 
1c28 7c				ld a,h 
1c29 21 07 e6			ld hl, os_word_scratch 
1c2c cd a8 10			call hexout 
1c2f e1				pop hl 
1c30 7d				ld a,l 
1c31 21 09 e6			ld hl, os_word_scratch+2 
1c34 cd a8 10			call hexout 
1c37			 
1c37 21 0b e6			ld hl, os_word_scratch+4 
1c3a 3e 00			ld a,0 
1c3c 77				ld (hl),a 
1c3d 11 07 e6			ld de,os_word_scratch 
1c40 3e 28				ld a, display_row_2 
1c42 cd 8d 0b				call str_at_display 
1c45 11 96 47			ld de, .push_num 
1c48 3e 00			ld a, display_row_1 
1c4a			 
1c4a cd 8d 0b				call str_at_display 
1c4d			 
1c4d			 
1c4d cd 9d 0b			call update_display 
1c50 cd ec 0a			call delay1s 
1c53 cd ec 0a			call delay1s 
1c56			.pskip2:  
1c56			 
1c56 f1				pop af 
1c57			endif	 
1c57			 
1c57			 
1c57				FORTH_DSP_NEXT 
1c57 cd a8 1b			call macro_forth_dsp_next 
1c5a				endm 
# End of macro FORTH_DSP_NEXT
1c5a			 
1c5a 2a 2f ea			ld hl, (cli_data_sp) 
1c5d			 
1c5d				; save item type 
1c5d 3e 02			ld a,  DS_TYPE_INUM 
1c5f 77				ld (hl), a 
1c60 23				inc hl 
1c61			 
1c61				; get word off stack 
1c61 d1				pop de 
1c62 7b				ld a,e 
1c63 77				ld (hl), a 
1c64 23				inc hl 
1c65 7a				ld a,d 
1c66 77				ld (hl), a 
1c67			 
1c67			if DEBUG_FORTH_PUSH 
1c67 2b				dec hl 
1c68 2b				dec hl 
1c69 2b				dec hl 
1c6a						DMARK "PH5" 
1c6a f5				push af  
1c6b 3a 7f 1c			ld a, (.dmark)  
1c6e 32 71 ee			ld (debug_mark),a  
1c71 3a 80 1c			ld a, (.dmark+1)  
1c74 32 72 ee			ld (debug_mark+1),a  
1c77 3a 81 1c			ld a, (.dmark+2)  
1c7a 32 73 ee			ld (debug_mark+2),a  
1c7d 18 03			jr .pastdmark  
1c7f ..			.dmark: db "PH5"  
1c82 f1			.pastdmark: pop af  
1c83			endm  
# End of macro DMARK
1c83				CALLMONITOR 
1c83 cd a8 15			call break_point_state  
1c86				endm  
# End of macro CALLMONITOR
1c86			endif	 
1c86			 
1c86 c9				ret 
1c87			 
1c87			 
1c87			; Push a string to stack pointed to by hl 
1c87			 
1c87			forth_push_str: 
1c87			 
1c87			if DEBUG_FORTH_PUSH 
1c87						DMARK "PSQ" 
1c87 f5				push af  
1c88 3a 9c 1c			ld a, (.dmark)  
1c8b 32 71 ee			ld (debug_mark),a  
1c8e 3a 9d 1c			ld a, (.dmark+1)  
1c91 32 72 ee			ld (debug_mark+1),a  
1c94 3a 9e 1c			ld a, (.dmark+2)  
1c97 32 73 ee			ld (debug_mark+2),a  
1c9a 18 03			jr .pastdmark  
1c9c ..			.dmark: db "PSQ"  
1c9f f1			.pastdmark: pop af  
1ca0			endm  
# End of macro DMARK
1ca0				CALLMONITOR 
1ca0 cd a8 15			call break_point_state  
1ca3				endm  
# End of macro CALLMONITOR
1ca3			endif	 
1ca3			    
1ca3 e5				push hl 
1ca4 e5				push hl 
1ca5			 
1ca5			;	ld a, 0   ; find end of string 
1ca5 cd 05 12			call strlenz 
1ca8			if DEBUG_FORTH_PUSH 
1ca8						DMARK "PQ2" 
1ca8 f5				push af  
1ca9 3a bd 1c			ld a, (.dmark)  
1cac 32 71 ee			ld (debug_mark),a  
1caf 3a be 1c			ld a, (.dmark+1)  
1cb2 32 72 ee			ld (debug_mark+1),a  
1cb5 3a bf 1c			ld a, (.dmark+2)  
1cb8 32 73 ee			ld (debug_mark+2),a  
1cbb 18 03			jr .pastdmark  
1cbd ..			.dmark: db "PQ2"  
1cc0 f1			.pastdmark: pop af  
1cc1			endm  
# End of macro DMARK
1cc1				CALLMONITOR 
1cc1 cd a8 15			call break_point_state  
1cc4				endm  
# End of macro CALLMONITOR
1cc4			endif	 
1cc4 eb				ex de, hl 
1cc5 e1				pop hl   ; get ptr to start of string 
1cc6			if DEBUG_FORTH_PUSH 
1cc6						DMARK "PQ3" 
1cc6 f5				push af  
1cc7 3a db 1c			ld a, (.dmark)  
1cca 32 71 ee			ld (debug_mark),a  
1ccd 3a dc 1c			ld a, (.dmark+1)  
1cd0 32 72 ee			ld (debug_mark+1),a  
1cd3 3a dd 1c			ld a, (.dmark+2)  
1cd6 32 73 ee			ld (debug_mark+2),a  
1cd9 18 03			jr .pastdmark  
1cdb ..			.dmark: db "PQ3"  
1cde f1			.pastdmark: pop af  
1cdf			endm  
# End of macro DMARK
1cdf				CALLMONITOR 
1cdf cd a8 15			call break_point_state  
1ce2				endm  
# End of macro CALLMONITOR
1ce2			endif	 
1ce2 19				add hl,de 
1ce3			if DEBUG_FORTH_PUSH 
1ce3						DMARK "PQE" 
1ce3 f5				push af  
1ce4 3a f8 1c			ld a, (.dmark)  
1ce7 32 71 ee			ld (debug_mark),a  
1cea 3a f9 1c			ld a, (.dmark+1)  
1ced 32 72 ee			ld (debug_mark+1),a  
1cf0 3a fa 1c			ld a, (.dmark+2)  
1cf3 32 73 ee			ld (debug_mark+2),a  
1cf6 18 03			jr .pastdmark  
1cf8 ..			.dmark: db "PQE"  
1cfb f1			.pastdmark: pop af  
1cfc			endm  
# End of macro DMARK
1cfc				CALLMONITOR 
1cfc cd a8 15			call break_point_state  
1cff				endm  
# End of macro CALLMONITOR
1cff			endif	 
1cff			 
1cff 2b				dec hl    ; see if there is an optional trailing double quote 
1d00 7e				ld a,(hl) 
1d01 fe 22			cp '"' 
1d03 20 03			jr nz, .strnoq 
1d05 3e 00			ld a, 0      ; get rid of double quote 
1d07 77				ld (hl), a 
1d08 23			.strnoq: inc hl 
1d09			 
1d09 3e 00			ld a, 0 
1d0b 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1d0c			 
1d0c 13				inc de ; add one for the type string 
1d0d 13				inc de ; add one for null term??? 
1d0e			 
1d0e				; tos is get string pointer again 
1d0e				; de contains space to allocate 
1d0e				 
1d0e d5				push de 
1d0f			 
1d0f eb				ex de, hl 
1d10			 
1d10				;push af 
1d10			 
1d10			if DEBUG_FORTH_PUSH 
1d10						DMARK "PHm" 
1d10 f5				push af  
1d11 3a 25 1d			ld a, (.dmark)  
1d14 32 71 ee			ld (debug_mark),a  
1d17 3a 26 1d			ld a, (.dmark+1)  
1d1a 32 72 ee			ld (debug_mark+1),a  
1d1d 3a 27 1d			ld a, (.dmark+2)  
1d20 32 73 ee			ld (debug_mark+2),a  
1d23 18 03			jr .pastdmark  
1d25 ..			.dmark: db "PHm"  
1d28 f1			.pastdmark: pop af  
1d29			endm  
# End of macro DMARK
1d29				CALLMONITOR 
1d29 cd a8 15			call break_point_state  
1d2c				endm  
# End of macro CALLMONITOR
1d2c			endif	 
1d2c cd 6e 12			call malloc	; on ret hl now contains allocated memory 
1d2f				if DEBUG_FORTH_MALLOC_GUARD 
1d2f cc ee 47				call z,malloc_error 
1d32				endif 
1d32			 
1d32				 
1d32 c1				pop bc    ; get length 
1d33 d1				pop de   ;  get string start    
1d34			 
1d34				; hl has destination from malloc 
1d34			 
1d34 eb				ex de, hl    ; prep for ldir 
1d35			 
1d35 d5				push de   ; save malloc area for DSP later 
1d36				;push hl   ; save malloc area for DSP later 
1d36			 
1d36			if DEBUG_FORTH_PUSH 
1d36						DMARK "PHc" 
1d36 f5				push af  
1d37 3a 4b 1d			ld a, (.dmark)  
1d3a 32 71 ee			ld (debug_mark),a  
1d3d 3a 4c 1d			ld a, (.dmark+1)  
1d40 32 72 ee			ld (debug_mark+1),a  
1d43 3a 4d 1d			ld a, (.dmark+2)  
1d46 32 73 ee			ld (debug_mark+2),a  
1d49 18 03			jr .pastdmark  
1d4b ..			.dmark: db "PHc"  
1d4e f1			.pastdmark: pop af  
1d4f			endm  
# End of macro DMARK
1d4f				CALLMONITOR 
1d4f cd a8 15			call break_point_state  
1d52				endm  
# End of macro CALLMONITOR
1d52			endif	 
1d52			 
1d52			 
1d52 ed b0			ldir 
1d54			 
1d54			 
1d54				; push malloc to data stack     macro?????  
1d54			 
1d54				FORTH_DSP_NEXT 
1d54 cd a8 1b			call macro_forth_dsp_next 
1d57				endm 
# End of macro FORTH_DSP_NEXT
1d57			 
1d57				; save value and type 
1d57			 
1d57 2a 2f ea			ld hl, (cli_data_sp) 
1d5a			 
1d5a				; save item type 
1d5a 3e 01			ld a,  DS_TYPE_STR 
1d5c 77				ld (hl), a 
1d5d 23				inc hl 
1d5e			 
1d5e				; get malloc word off stack 
1d5e d1				pop de 
1d5f 73				ld (hl), e 
1d60 23				inc hl 
1d61 72				ld (hl), d 
1d62			 
1d62			 
1d62			 
1d62			if DEBUG_FORTH_PUSH 
1d62 2a 2f ea			ld hl, (cli_data_sp) 
1d65						DMARK "PHS" 
1d65 f5				push af  
1d66 3a 7a 1d			ld a, (.dmark)  
1d69 32 71 ee			ld (debug_mark),a  
1d6c 3a 7b 1d			ld a, (.dmark+1)  
1d6f 32 72 ee			ld (debug_mark+1),a  
1d72 3a 7c 1d			ld a, (.dmark+2)  
1d75 32 73 ee			ld (debug_mark+2),a  
1d78 18 03			jr .pastdmark  
1d7a ..			.dmark: db "PHS"  
1d7d f1			.pastdmark: pop af  
1d7e			endm  
# End of macro DMARK
1d7e				CALLMONITOR 
1d7e cd a8 15			call break_point_state  
1d81				endm  
# End of macro CALLMONITOR
1d81			;	ex de,hl 
1d81			endif	 
1d81				; in case of spaces, skip the ptr past the copied string 
1d81				;pop af 
1d81				;ld (cli_origptr),hl 
1d81			 
1d81 c9				ret 
1d82			 
1d82			 
1d82			 
1d82			; TODO ascii push input onto stack given hl to start of input 
1d82			 
1d82			; identify type 
1d82			; if starts with a " then a string 
1d82			; otherwise it is a number 
1d82			;  
1d82			; if a string 
1d82			;     scan for ending " to get length of string to malloc for + 1 
1d82			;     malloc 
1d82			;     put pointer to string on stack first byte flags as string 
1d82			; 
1d82			; else a number 
1d82			;    look for number format identifier 
1d82			;    $xx hex 
1d82			;    %xxxxx bin 
1d82			;    xxxxx decimal 
1d82			;    convert number to 16bit word.  
1d82			;    malloc word + 1 with flag to identiy as num 
1d82			;    put pointer to number on stack 
1d82			;   
1d82			;  
1d82			  
1d82			forth_apush: 
1d82				; kernel push 
1d82			 
1d82			if DEBUG_FORTH_PUSH 
1d82						DMARK "PSH" 
1d82 f5				push af  
1d83 3a 97 1d			ld a, (.dmark)  
1d86 32 71 ee			ld (debug_mark),a  
1d89 3a 98 1d			ld a, (.dmark+1)  
1d8c 32 72 ee			ld (debug_mark+1),a  
1d8f 3a 99 1d			ld a, (.dmark+2)  
1d92 32 73 ee			ld (debug_mark+2),a  
1d95 18 03			jr .pastdmark  
1d97 ..			.dmark: db "PSH"  
1d9a f1			.pastdmark: pop af  
1d9b			endm  
# End of macro DMARK
1d9b				CALLMONITOR 
1d9b cd a8 15			call break_point_state  
1d9e				endm  
# End of macro CALLMONITOR
1d9e			endif	 
1d9e				; identify input type 
1d9e			 
1d9e 7e				ld a,(hl) 
1d9f fe 22			cp '"' 
1da1 28 0a			jr z, .fapstr 
1da3 fe 24			cp '$' 
1da5 ca cd 1d			jp z, .faphex 
1da8 fe 25			cp '%' 
1daa ca b5 1d			jp z, .fapbin 
1dad			;	cp 'b' 
1dad			;	jp z, .fabin 
1dad				; else decimal 
1dad			 
1dad				; TODO do decimal conversion 
1dad				; decimal is stored as a 16bit word 
1dad			 
1dad				; by default everything is a string if type is not detected 
1dad			.fapstr: ; 
1dad fe 22			cp '"' 
1daf 20 01			jr nz, .strnoqu 
1db1 23				inc hl 
1db2			.strnoqu: 
1db2 c3 87 1c			jp forth_push_str 
1db5			 
1db5			 
1db5			 
1db5			.fapbin:    ; push a binary string.  
1db5 11 00 00			ld de, 0   ; hold a 16bit value 
1db8			 
1db8 23			.fapbinshift:	inc hl  
1db9 7e				ld a,(hl) 
1dba fe 00			cp 0     ; done scanning  
1dbc 28 0b			jr z, .fapbdone  	; got it in HL so push  
1dbe			 
1dbe				; left shift de 
1dbe eb				ex de, hl	 
1dbf 29				add hl, hl 
1dc0			 
1dc0				; is 1 
1dc0 fe 31			cp '1' 
1dc2 20 02			jr nz, .binzero 
1dc4 cb 4d			bit 1, l 
1dc6			.binzero: 
1dc6 eb				ex de, hl	 ; save current de 
1dc7 18 ef			jr .fapbinshift 
1dc9			 
1dc9			.fapbdone: 
1dc9 eb				ex de, hl 
1dca c3 19 1c			jp forth_push_numhl 
1dcd			 
1dcd			 
1dcd			.faphex:   ; hex is always stored as a 16bit word 
1dcd				; skip number prefix 
1dcd 23				inc hl 
1dce				; turn ascii into number 
1dce cd 5e 11			call get_word_hl	; ret 16bit word in hl 
1dd1			 
1dd1 c3 19 1c			jp forth_push_numhl 
1dd4			 
1dd4 00				 nop 
1dd5			 
1dd5			.fabin:   ; TODO bin conversion 
1dd5			 
1dd5			 
1dd5 c9				ret 
1dd6			 
1dd6			 
1dd6			; get either a string ptr or a 16bit word from the data stack 
1dd6			 
1dd6			FORTH_DSP: macro 
1dd6				call macro_forth_dsp 
1dd6				endm 
1dd6			 
1dd6			macro_forth_dsp: 
1dd6				; data stack pointer points to current word on tos 
1dd6			 
1dd6 2a 2f ea			ld hl,(cli_data_sp) 
1dd9			 
1dd9				if DEBUG_FORTH_PUSH 
1dd9						DMARK "DSP" 
1dd9 f5				push af  
1dda 3a ee 1d			ld a, (.dmark)  
1ddd 32 71 ee			ld (debug_mark),a  
1de0 3a ef 1d			ld a, (.dmark+1)  
1de3 32 72 ee			ld (debug_mark+1),a  
1de6 3a f0 1d			ld a, (.dmark+2)  
1de9 32 73 ee			ld (debug_mark+2),a  
1dec 18 03			jr .pastdmark  
1dee ..			.dmark: db "DSP"  
1df1 f1			.pastdmark: pop af  
1df2			endm  
# End of macro DMARK
1df2			 
1df2 cd 23 48				call display_data_sp 
1df5				;call break_point_state 
1df5				;rst 030h 
1df5				CALLMONITOR 
1df5 cd a8 15			call break_point_state  
1df8				endm  
# End of macro CALLMONITOR
1df8				endif 
1df8			 
1df8 c9				ret 
1df9			 
1df9			; return hl to start of value on stack 
1df9			 
1df9			FORTH_DSP_VALUE: macro 
1df9				call macro_forth_dsp_value 
1df9				endm 
1df9			 
1df9			macro_forth_dsp_value: 
1df9			 
1df9				FORTH_DSP 
1df9 cd d6 1d			call macro_forth_dsp 
1dfc				endm 
# End of macro FORTH_DSP
1dfc			 
1dfc d5				push de 
1dfd			 
1dfd 23				inc hl ; skip type 
1dfe			 
1dfe 5e				ld e, (hl) 
1dff 23				inc hl 
1e00 56				ld d, (hl) 
1e01 eb				ex de,hl  
1e02			 
1e02 d1				pop de 
1e03			 
1e03 c9				ret 
1e04			 
1e04			; return hl to start of value to second item on stack 
1e04			 
1e04			FORTH_DSP_VALUEM1: macro 
1e04				call macro_forth_dsp_value_m1 
1e04				endm 
1e04			 
1e04			macro_forth_dsp_value_m1: 
1e04			 
1e04				FORTH_DSP 
1e04 cd d6 1d			call macro_forth_dsp 
1e07				endm 
# End of macro FORTH_DSP
1e07			 
1e07 2b				dec hl 
1e08 2b				dec hl 
1e09			;	dec hl 
1e09			 
1e09 d5				push de 
1e0a			 
1e0a 5e				ld e, (hl) 
1e0b 23				inc hl 
1e0c 56				ld d, (hl) 
1e0d eb				ex de,hl  
1e0e			 
1e0e d1				pop de 
1e0f			 
1e0f c9				ret 
1e10			 
1e10				 
1e10			 
1e10			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1e10			 
1e10			FORTH_DSP_POP: macro 
1e10				call macro_forth_dsp_pop 
1e10				endm 
1e10			 
1e10			 
1e10			; get the tos data type 
1e10			 
1e10			FORTH_DSP_TYPE:   macro 
1e10			 
1e10				;FORTH_DSP_VALUE 
1e10				FORTH_DSP 
1e10				 
1e10				; hl points to value 
1e10				; check type 
1e10			 
1e10				ld a,(hl) 
1e10			 
1e10				endm 
1e10			 
1e10			; load the tos value into hl 
1e10			 
1e10			 
1e10			FORTH_DSP_VALUEHL:  macro 
1e10				call macro_dsp_valuehl 
1e10				endm 
1e10			 
1e10			 
1e10			 
1e10			macro_dsp_valuehl: 
1e10				FORTH_DSP_VALUE 
1e10 cd f9 1d			call macro_forth_dsp_value 
1e13				endm 
# End of macro FORTH_DSP_VALUE
1e13			 
1e13				;FORTH_ERR_TOS_NOTNUM 
1e13			 
1e13				;inc hl   ; skip type id 
1e13			 
1e13			;	push de 
1e13			; 
1e13			;	ld e, (hl) 
1e13			;	inc hl 
1e13			;	ld d, (hl) 
1e13			;	ex de,hl  
1e13			 
1e13			;	pop de 
1e13			 
1e13				if DEBUG_FORTH_PUSH 
1e13						DMARK "DVL" 
1e13 f5				push af  
1e14 3a 28 1e			ld a, (.dmark)  
1e17 32 71 ee			ld (debug_mark),a  
1e1a 3a 29 1e			ld a, (.dmark+1)  
1e1d 32 72 ee			ld (debug_mark+1),a  
1e20 3a 2a 1e			ld a, (.dmark+2)  
1e23 32 73 ee			ld (debug_mark+2),a  
1e26 18 03			jr .pastdmark  
1e28 ..			.dmark: db "DVL"  
1e2b f1			.pastdmark: pop af  
1e2c			endm  
# End of macro DMARK
1e2c				CALLMONITOR 
1e2c cd a8 15			call break_point_state  
1e2f				endm  
# End of macro CALLMONITOR
1e2f				endif 
1e2f c9				ret 
1e30			 
1e30			forth_apushstrhl:      
1e30				; push of string requires use of cli_origptr 
1e30				; bodge use 
1e30			 
1e30				; get current cli_origptr, save, update with temp pointer  
1e30 ed 5b 4b ea		ld de, (cli_origptr) 
1e34 22 4b ea			ld (cli_origptr), hl 
1e37 d5				push de 
1e38 cd 82 1d			call forth_apush 
1e3b d1				pop de 
1e3c ed 53 4b ea		ld (cli_origptr), de 
1e40 c9			        ret	 
1e41			 
1e41			 
1e41			; increase loop stack pointer and save hl to it 
1e41				 
1e41			FORTH_LOOP_NEXT: macro 
1e41				call macro_forth_loop_next 
1e41				;nop 
1e41				endm 
1e41			 
1e41			macro_forth_loop_next: 
1e41				if DEBUG_FORTH_STACK_GUARD 
1e41 cd 00 59				call check_stacks 
1e44				endif 
1e44 e5				push hl 
1e45 d5				push de 
1e46 eb				ex de,hl 
1e47 2a 31 ea			ld hl,(cli_loop_sp) 
1e4a 23				inc hl 
1e4b 23				inc hl 
1e4c					if DEBUG_FORTH_WORDS 
1e4c						DMARK "LNX" 
1e4c f5				push af  
1e4d 3a 61 1e			ld a, (.dmark)  
1e50 32 71 ee			ld (debug_mark),a  
1e53 3a 62 1e			ld a, (.dmark+1)  
1e56 32 72 ee			ld (debug_mark+1),a  
1e59 3a 63 1e			ld a, (.dmark+2)  
1e5c 32 73 ee			ld (debug_mark+2),a  
1e5f 18 03			jr .pastdmark  
1e61 ..			.dmark: db "LNX"  
1e64 f1			.pastdmark: pop af  
1e65			endm  
# End of macro DMARK
1e65						CALLMONITOR 
1e65 cd a8 15			call break_point_state  
1e68				endm  
# End of macro CALLMONITOR
1e68					endif 
1e68 22 31 ea			ld (cli_loop_sp),hl 
1e6b 73				ld (hl), e 
1e6c 23				inc hl 
1e6d 72				ld (hl), d 
1e6e d1				pop de    ; been reversed so save a swap on restore 
1e6f e1				pop hl 
1e70				if DEBUG_FORTH_STACK_GUARD 
1e70 cd 00 59				call check_stacks 
1e73				endif 
1e73 c9				ret 
1e74			 
1e74			; get current ret stack pointer and save to hl  
1e74				 
1e74			FORTH_LOOP_TOS: macro 
1e74				call macro_forth_loop_tos 
1e74				endm 
1e74			 
1e74			macro_forth_loop_tos: 
1e74 d5				push de 
1e75 2a 31 ea			ld hl,(cli_loop_sp) 
1e78 5e				ld e, (hl) 
1e79 23				inc hl 
1e7a 56				ld d, (hl) 
1e7b eb				ex de, hl 
1e7c d1				pop de 
1e7d c9				ret 
1e7e			 
1e7e			; pop loop stack pointer 
1e7e				 
1e7e			FORTH_LOOP_POP: macro 
1e7e				call macro_forth_loop_pop 
1e7e				endm 
1e7e			 
1e7e			 
1e7e			macro_forth_loop_pop: 
1e7e				if DEBUG_FORTH_STACK_GUARD 
1e7e					DMARK "LPP" 
1e7e f5				push af  
1e7f 3a 93 1e			ld a, (.dmark)  
1e82 32 71 ee			ld (debug_mark),a  
1e85 3a 94 1e			ld a, (.dmark+1)  
1e88 32 72 ee			ld (debug_mark+1),a  
1e8b 3a 95 1e			ld a, (.dmark+2)  
1e8e 32 73 ee			ld (debug_mark+2),a  
1e91 18 03			jr .pastdmark  
1e93 ..			.dmark: db "LPP"  
1e96 f1			.pastdmark: pop af  
1e97			endm  
# End of macro DMARK
1e97 cd 00 59				call check_stacks 
1e9a					FORTH_CHK_LOOP_UNDER 
1e9a e5				push hl 
1e9b d5				push de 
1e9c 2a 31 ea			ld hl,(cli_loop_sp) 
1e9f 11 6b e9			ld de, cli_loop_stack 
1ea2 cd c5 0d			call cmp16 
1ea5 da 1a 5a			jp c, fault_loop_under 
1ea8 d1				pop de 
1ea9 e1				pop hl 
1eaa				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1eaa				endif 
1eaa e5				push hl 
1eab 2a 31 ea			ld hl,(cli_loop_sp) 
1eae 2b				dec hl 
1eaf 2b				dec hl 
1eb0 22 31 ea			ld (cli_loop_sp), hl 
1eb3				; TODO do stack underflow checks 
1eb3 e1				pop hl 
1eb4				if DEBUG_FORTH_STACK_GUARD 
1eb4 cd 00 59				call check_stacks 
1eb7					FORTH_CHK_LOOP_UNDER 
1eb7 e5				push hl 
1eb8 d5				push de 
1eb9 2a 31 ea			ld hl,(cli_loop_sp) 
1ebc 11 6b e9			ld de, cli_loop_stack 
1ebf cd c5 0d			call cmp16 
1ec2 da 1a 5a			jp c, fault_loop_under 
1ec5 d1				pop de 
1ec6 e1				pop hl 
1ec7				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1ec7				endif 
1ec7 c9				ret 
1ec8			 
1ec8			macro_forth_dsp_pop: 
1ec8			 
1ec8 e5				push hl 
1ec9			 
1ec9				; release malloc data 
1ec9			 
1ec9				if DEBUG_FORTH_STACK_GUARD 
1ec9 cd 00 59				call check_stacks 
1ecc					FORTH_CHK_DSP_UNDER 
1ecc e5				push hl 
1ecd d5				push de 
1ece 2a 2f ea			ld hl,(cli_data_sp) 
1ed1 11 69 e8			ld de, cli_data_stack 
1ed4 cd c5 0d			call cmp16 
1ed7 da 0e 5a			jp c, fault_dsp_under 
1eda d1				pop de 
1edb e1				pop hl 
1edc				endm 
# End of macro FORTH_CHK_DSP_UNDER
1edc				endif 
1edc				;ld hl,(cli_data_sp) 
1edc			if DEBUG_FORTH_DOT 
1edc				DMARK "DPP" 
1edc				CALLMONITOR 
1edc			endif	 
1edc			 
1edc			 
1edc			if FORTH_ENABLE_DSPPOPFREE 
1edc			 
1edc				FORTH_DSP 
1edc cd d6 1d			call macro_forth_dsp 
1edf				endm 
# End of macro FORTH_DSP
1edf			 
1edf 7e				ld a, (hl) 
1ee0 fe 01			cp DS_TYPE_STR 
1ee2 20 07			jr nz, .skippopfree 
1ee4			 
1ee4				FORTH_DSP_VALUEHL 
1ee4 cd 10 1e			call macro_dsp_valuehl 
1ee7				endm 
# End of macro FORTH_DSP_VALUEHL
1ee7 00				nop 
1ee8			if DEBUG_FORTH_DOT 
1ee8				DMARK "DPf" 
1ee8				CALLMONITOR 
1ee8			endif	 
1ee8 cd 38 13			call free 
1eeb			.skippopfree: 
1eeb				 
1eeb			 
1eeb			endif 
1eeb			 
1eeb			if DEBUG_FORTH_DOT_KEY 
1eeb				DMARK "DP2" 
1eeb				CALLMONITOR 
1eeb			endif	 
1eeb			 
1eeb				; move pointer down 
1eeb			 
1eeb 2a 2f ea			ld hl,(cli_data_sp) 
1eee 2b				dec hl 
1eef 2b				dec hl 
1ef0			; PARSEV5 
1ef0 2b				dec hl 
1ef1 22 2f ea			ld (cli_data_sp), hl 
1ef4			 
1ef4				if DEBUG_FORTH_STACK_GUARD 
1ef4 cd 00 59				call check_stacks 
1ef7					FORTH_CHK_DSP_UNDER 
1ef7 e5				push hl 
1ef8 d5				push de 
1ef9 2a 2f ea			ld hl,(cli_data_sp) 
1efc 11 69 e8			ld de, cli_data_stack 
1eff cd c5 0d			call cmp16 
1f02 da 0e 5a			jp c, fault_dsp_under 
1f05 d1				pop de 
1f06 e1				pop hl 
1f07				endm 
# End of macro FORTH_CHK_DSP_UNDER
1f07				endif 
1f07			 
1f07 e1				pop hl 
1f08			 
1f08 c9				ret 
1f09			 
1f09			getwordathl: 
1f09				; hl points to an address 
1f09				; load hl with the word at that address 
1f09			 
1f09 d5				push de 
1f0a			 
1f0a 5e				ld e, (hl) 
1f0b 23				inc hl 
1f0c 56				ld d, (hl) 
1f0d eb				ex de, hl 
1f0e			 
1f0e d1				pop de 
1f0f c9				ret 
1f10			 
1f10			 
1f10			 
1f10			 
1f10			 
1f10			; eof 
1f10			 
# End of file forth_stackopsv5.asm
1f10			endif 
1f10			 
1f10			user_word_eol:  
1f10				; hl contains the pointer to where to create a linked list item from the end 
1f10				; of the user dict to continue on at the system word dict 
1f10				 
1f10				; poke the stub of the word list linked list to repoint to rom words 
1f10			 
1f10				; stub format 
1f10				; db   word id 
1f10				; dw    link to next word 
1f10			        ; db char length of token 
1f10				; db string + 0 term 
1f10				; db exec code....  
1f10			 
1f10 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1f12 77				ld (hl), a		; word id 
1f13 23				inc hl 
1f14			 
1f14 11 df 20			ld de, sysdict 
1f17 73				ld (hl), e		; next word link ie system dict 
1f18 23				inc hl 
1f19 72				ld (hl), d		; next word link ie system dict 
1f1a 23				inc hl	 
1f1b			 
1f1b			;	ld (hl), sysdict		; next word link ie system dict 
1f1b			;	inc hl 
1f1b			;	inc hl 
1f1b			 
1f1b			;	inc hl 
1f1b			;	inc hl 
1f1b			 
1f1b 3e 02			ld a, 2			; word length is 0 
1f1d 77				ld (hl), a	 
1f1e 23				inc hl 
1f1f			 
1f1f 3e 7e			ld a, '~'			; word length is 0 
1f21 77				ld (hl), a	 
1f22 23				inc hl 
1f23 3e 00			ld a, 0			; save empty word 
1f25 77				ld (hl), a 
1f26			 
1f26 c9				ret 
1f27			 
1f27				 
1f27			 
1f27			forthexec_cleanup: 
1f27				FORTH_RSP_POP 
1f27 cd e1 1b			call macro_forth_rsp_pop 
1f2a				endm 
# End of macro FORTH_RSP_POP
1f2a c9				ret 
1f2b			 
1f2b			forth_call_hl: 
1f2b				; taking hl 
1f2b e5				push hl 
1f2c c9				ret 
1f2d			 
1f2d			; this is called to reset Forth system but keep existing uwords etc 
1f2d			 
1f2d			forth_warmstart: 
1f2d				; setup stack over/under flow checks 
1f2d				if DEBUG_FORTH_STACK_GUARD 
1f2d cd e6 58				call chk_stk_init 
1f30				endif 
1f30			 
1f30				; init stack pointers  - * these stacks go upwards *  
1f30 21 ed e9			ld hl, cli_ret_stack 
1f33 22 33 ea			ld (cli_ret_sp), hl	 
1f36				; set bottom of stack 
1f36 3e 00			ld a,0 
1f38 77				ld (hl),a 
1f39 23				inc hl 
1f3a 77				ld (hl),a 
1f3b			 
1f3b 21 69 e8			ld hl, cli_data_stack 
1f3e 22 2f ea			ld (cli_data_sp), hl	 
1f41				; set bottom of stack 
1f41 3e 00			ld a,0 
1f43 77				ld (hl),a 
1f44 23				inc hl 
1f45 77				ld (hl),a 
1f46			 
1f46 21 6b e9			ld hl, cli_loop_stack 
1f49 22 31 ea			ld (cli_loop_sp), hl	 
1f4c				; set bottom of stack 
1f4c 3e 00			ld a,0 
1f4e 77				ld (hl),a 
1f4f 23				inc hl 
1f50 77				ld (hl),a 
1f51			 
1f51				; init extent of current open file 
1f51			 
1f51 3e 00			ld a, 0 
1f53 32 76 ea			ld (store_openext), a 
1f56			 
1f56 c9				ret 
1f57			 
1f57			 
1f57			; Cold Start - this is called to setup the whole Forth system 
1f57			 
1f57			forth_init: 
1f57			 
1f57				; setup stack over/under flow checks 
1f57			 
1f57			;	if DEBUG_FORTH_STACK_GUARD 
1f57			;		call chk_stk_init 
1f57			;	endif 
1f57			 
1f57				; enable auto display updates (slow.....) 
1f57			 
1f57 3e 01			ld a, 1 
1f59 32 49 ea			ld (cli_autodisplay), a 
1f5c			 
1f5c				; if storage is in use disable long reads for now 
1f5c 3e 00			ld a, 0 
1f5e 32 7f ea			ld (store_longread), a 
1f61			 
1f61			 
1f61				; show start up screen 
1f61			 
1f61 cd 7a 0b			call clear_display 
1f64			 
1f64 3e 00			ld a,0 
1f66 32 6b ea			ld (f_cursor_ptr), a 
1f69			 
1f69				; set start of word list in start of ram - for use when creating user words 
1f69			 
1f69 21 09 5c			ld hl, baseram 
1f6c 22 ff e5			ld (os_last_new_uword), hl 
1f6f cd 10 1f			call user_word_eol 
1f72				 
1f72			;		call display_data_sp 
1f72			;		call next_page_prompt 
1f72			 
1f72			 
1f72			 
1f72			 
1f72 c9				ret 
1f73			 
1f73 .. 00		.bootforth: db " Forth Kernel Init ",0 
1f87			 
1f87			; TODO push to stack 
1f87			 
1f87			;  
1f87			 
1f87			if FORTH_PARSEV2 
1f87			 
1f87			 
1f87				include "forth_parserv2.asm" 
1f87			 
1f87			endif 
1f87			 
1f87			 
1f87			; parse cli version 1 
1f87			 
1f87			if FORTH_PARSEV1 
1f87			 
1f87			 
1f87			 
1f87			      include "forth_parserv1.asm" 
1f87			endif 
1f87				 
1f87			if FORTH_PARSEV3 
1f87			 
1f87			 
1f87			 
1f87			      include "forth_parserv3.asm" 
1f87				include "forth_wordsv3.asm" 
1f87			endif 
1f87			 
1f87			if FORTH_PARSEV4 
1f87			 
1f87			 
1f87			 
1f87			      include "forth_parserv4.asm" 
1f87				include "forth_wordsv4.asm" 
1f87			endif 
1f87			 
1f87			if FORTH_PARSEV5 
1f87			 
1f87			 
1f87			 
1f87			      include "forth_parserv5.asm" 
1f87			 
1f87			 
1f87			; A better parser without using malloc and string copies all over the place.  
1f87			; Exec in situ should be faster 
1f87			 
1f87			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
1f87			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
1f87			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
1f87			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
1f87			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
1f87			WORD_SYS_END: equ 0   ; Opcode for all user words 
1f87			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
1f87			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
1f87			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
1f87			 
1f87			; Core word preamble macro 
1f87			 
1f87			CWHEAD:   macro nxtword opcode lit len opflags 
1f87				db WORD_SYS_CORE+opcode             
1f87				; internal op code number 
1f87				dw nxtword            
1f87				; link to next dict word block 
1f87				db len + 1 
1f87				; literal length of dict word inc zero term 
1f87				db lit,0              
1f87				; literal dict word 
1f87			        ; TODO db opflags        
1f87				endm 
1f87			 
1f87			 
1f87			NEXTW: macro  
1f87				jp macro_next 
1f87				endm 
1f87			 
1f87			macro_next: 
1f87			if DEBUG_FORTH_PARSE_KEY 
1f87				DMARK "NXT" 
1f87				CALLMONITOR 
1f87			endif	 
1f87			;	inc hl  ; skip token null term  
1f87 ed 4b 4d ea		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1f8b ed 5b 4b ea		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1f8f 2a 03 e6			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1f92			if DEBUG_FORTH_PARSE_KEY 
1f92				DMARK "}AA" 
1f92				CALLMONITOR 
1f92			endif	 
1f92 c3 95 20			jp execnext 
1f95				;jp exec1 
1f95			       
1f95			 
1f95			 
1f95			; Another go at the parser to compile  
1f95			 
1f95			 
1f95			; TODO rework parser to change all of the string words to byte tokens 
1f95			; TODO do a search for  
1f95			 
1f95			; TODO first run normal parser to zero term sections 
1f95			; TODO for each word do a token look up to get the op code 
1f95			; TODO need some means to flag to the exec that this is a byte code form    
1f95			 
1f95			 
1f95			forthcompile: 
1f95			 
1f95			; 
1f95			; line parse: 
1f95			;       parse raw input buffer 
1f95			;       tokenise the words 
1f95			;       malloc new copy (for looping etc) 
1f95			;       copy to malloc + current pc in line to start of string and add line term 
1f95			;       save on new rsp 
1f95			; 
1f95			 
1f95			; hl to point to the line to tokenise 
1f95			 
1f95			;	push hl 
1f95 22 03 e6			ld (os_tok_ptr), hl  ; save ptr to string 
1f98			 
1f98			;	ld a,0		; string term on input 
1f98			;	call strlent 
1f98			 
1f98			;	ld (os_tok_len), hl	 ; save string length 
1f98			 
1f98			;if DEBUG_FORTH_TOK 
1f98			;	ex de,hl		 
1f98			;endif 
1f98			 
1f98			;	pop hl 		; get back string pointer 
1f98			 
1f98			if DEBUG_FORTH_TOK 
1f98						DMARK "TOc" 
1f98				CALLMONITOR 
1f98			endif 
1f98 7e			.cptoken2:    ld a,(hl) 
1f99 23				inc hl 
1f9a fe 7f			cp FORTH_END_BUFFER 
1f9c 28 29			jr z, .cptokendone2 
1f9e fe 00			cp 0 
1fa0 28 25			jr z, .cptokendone2 
1fa2 fe 22			cp '"' 
1fa4 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
1fa6 fe 20			cp ' ' 
1fa8 20 ee			jr nz,  .cptoken2 
1faa			 
1faa			; TODO consume comments held between ( and ) 
1faa			 
1faa				; we have a space so change to zero term for dict match later 
1faa 2b				dec hl 
1fab 3e 00			ld a,0 
1fad 77				ld (hl), a 
1fae 23				inc hl 
1faf 18 e7			jr .cptoken2 
1fb1				 
1fb1			 
1fb1			.cptokenstr2: 
1fb1				; skip all white space until either eol (because forgot to term) or end double quote 
1fb1			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1fb1				;inc hl ; skip current double quote 
1fb1 7e				ld a,(hl) 
1fb2 23				inc hl 
1fb3 fe 22			cp '"' 
1fb5 28 e1			jr z, .cptoken2 
1fb7 fe 7f			cp FORTH_END_BUFFER 
1fb9 28 0c			jr z, .cptokendone2 
1fbb fe 00			cp 0 
1fbd 28 08			jr z, .cptokendone2 
1fbf fe 20			cp ' ' 
1fc1 28 02			jr z, .cptmp2 
1fc3 18 ec			jr .cptokenstr2 
1fc5			 
1fc5			.cptmp2:	; we have a space so change to zero term for dict match later 
1fc5				;dec hl 
1fc5				;ld a,"-"	; TODO remove this when working 
1fc5				;ld (hl), a 
1fc5				;inc hl 
1fc5 18 ea			jr .cptokenstr2 
1fc7			 
1fc7			.cptokendone2: 
1fc7				;inc hl 
1fc7 3e 7f			ld a, FORTH_END_BUFFER 
1fc9 77				ld (hl),a 
1fca 23				inc hl 
1fcb 3e 21			ld a, '!' 
1fcd 77				ld (hl),a 
1fce			 
1fce 2a 03 e6			ld hl,(os_tok_ptr) 
1fd1			         
1fd1			if DEBUG_FORTH_TOK 
1fd1						DMARK "Tc1" 
1fd1				CALLMONITOR 
1fd1			endif 
1fd1			 
1fd1				; push exec string to top of return stack 
1fd1				FORTH_RSP_NEXT 
1fd1 cd c0 1b			call macro_forth_rsp_next 
1fd4				endm 
# End of macro FORTH_RSP_NEXT
1fd4 c9				ret 
1fd5			 
1fd5			; Another go at the parser need to simplify the process 
1fd5			 
1fd5			forthparse: 
1fd5			 
1fd5			; 
1fd5			; line parse: 
1fd5			;       parse raw input buffer 
1fd5			;       tokenise the words 
1fd5			;       malloc new copy (for looping etc) 
1fd5			;       copy to malloc + current pc in line to start of string and add line term 
1fd5			;       save on new rsp 
1fd5			; 
1fd5			 
1fd5			; hl to point to the line to tokenise 
1fd5			 
1fd5			;	push hl 
1fd5 22 03 e6			ld (os_tok_ptr), hl  ; save ptr to string 
1fd8			 
1fd8			;	ld a,0		; string term on input 
1fd8			;	call strlent 
1fd8			 
1fd8			;	ld (os_tok_len), hl	 ; save string length 
1fd8			 
1fd8			;if DEBUG_FORTH_TOK 
1fd8			;	ex de,hl		 
1fd8			;endif 
1fd8			 
1fd8			;	pop hl 		; get back string pointer 
1fd8			 
1fd8			if DEBUG_FORTH_TOK 
1fd8						DMARK "TOK" 
1fd8				CALLMONITOR 
1fd8			endif 
1fd8 7e			.ptoken2:    ld a,(hl) 
1fd9 23				inc hl 
1fda fe 7f			cp FORTH_END_BUFFER 
1fdc 28 29			jr z, .ptokendone2 
1fde fe 00			cp 0 
1fe0 28 25			jr z, .ptokendone2 
1fe2 fe 22			cp '"' 
1fe4 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
1fe6 fe 20			cp ' ' 
1fe8 20 ee			jr nz,  .ptoken2 
1fea			 
1fea			; TODO consume comments held between ( and ) 
1fea			 
1fea				; we have a space so change to zero term for dict match later 
1fea 2b				dec hl 
1feb 3e 00			ld a,0 
1fed 77				ld (hl), a 
1fee 23				inc hl 
1fef 18 e7			jr .ptoken2 
1ff1				 
1ff1			 
1ff1			.ptokenstr2: 
1ff1				; skip all white space until either eol (because forgot to term) or end double quote 
1ff1			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1ff1				;inc hl ; skip current double quote 
1ff1 7e				ld a,(hl) 
1ff2 23				inc hl 
1ff3 fe 22			cp '"' 
1ff5 28 e1			jr z, .ptoken2 
1ff7 fe 7f			cp FORTH_END_BUFFER 
1ff9 28 0c			jr z, .ptokendone2 
1ffb fe 00			cp 0 
1ffd 28 08			jr z, .ptokendone2 
1fff fe 20			cp ' ' 
2001 28 02			jr z, .ptmp2 
2003 18 ec			jr .ptokenstr2 
2005			 
2005			.ptmp2:	; we have a space so change to zero term for dict match later 
2005				;dec hl 
2005				;ld a,"-"	; TODO remove this when working 
2005				;ld (hl), a 
2005				;inc hl 
2005 18 ea			jr .ptokenstr2 
2007			 
2007			.ptokendone2: 
2007				;inc hl 
2007 3e 7f			ld a, FORTH_END_BUFFER 
2009 77				ld (hl),a 
200a 23				inc hl 
200b 3e 21			ld a, '!' 
200d 77				ld (hl),a 
200e			 
200e 2a 03 e6			ld hl,(os_tok_ptr) 
2011			         
2011			if DEBUG_FORTH_TOK 
2011						DMARK "TK1" 
2011				CALLMONITOR 
2011			endif 
2011			 
2011				; push exec string to top of return stack 
2011				FORTH_RSP_NEXT 
2011 cd c0 1b			call macro_forth_rsp_next 
2014				endm 
# End of macro FORTH_RSP_NEXT
2014 c9				ret 
2015			 
2015			; 
2015			;	; malloc size + buffer pointer + if is loop flag 
2015			;	ld hl,(os_tok_len) 		 ; get string length 
2015			; 
2015			;	ld a,l 
2015			; 
2015			;	cp 0			; we dont want to use a null string 
2015			;	ret z 
2015			; 
2015			;;	add 3    ; prefix malloc with buffer for current word ptr 
2015			; 
2015			;	add 5     ; TODO when certain not over writing memory remove 
2015			; 
2015			;		 
2015			; 
2015			;if DEBUG_FORTH_TOK 
2015			;			DMARK "TKE" 
2015			;	CALLMONITOR 
2015			;endif 
2015			; 
2015			;	ld l,a 
2015			;	ld h,0 
2015			;;	push hl   ; save required space for the copy later 
2015			;	call malloc 
2015			;if DEBUG_FORTH_TOK 
2015			;			DMARK "TKM" 
2015			;	CALLMONITOR 
2015			;endif 
2015			;	if DEBUG_FORTH_MALLOC_GUARD 
2015			;		push af 
2015			;		call ishlzero 
2015			;;		ld a, l 
2015			;;		add h 
2015			;;		cp 0 
2015			;		pop af 
2015			;		 
2015			;		call z,malloc_error 
2015			;	endif 
2015			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
2015			; 
2015			; 
2015			;if DEBUG_FORTH_TOK 
2015			;			DMARK "TKR" 
2015			;	CALLMONITOR 
2015			;endif 
2015			; 
2015			;	FORTH_RSP_NEXT 
2015			; 
2015			;	;inc hl	 ; go past current buffer pointer 
2015			;	;inc hl 
2015			;	;inc hl   ; and past if loop flag 
2015			;		; TODO Need to set flag  
2015			; 
2015			;	 
2015			;	 
2015			;	ex de,hl	; malloc is dest 
2015			;	ld hl, (os_tok_len) 
2015			;;	pop bc 
2015			;	ld c, l                
2015			;	ld b,0 
2015			;	ld hl, (os_tok_ptr) 
2015			; 
2015			;if DEBUG_FORTH_TOK 
2015			;			DMARK "TKT" 
2015			;	CALLMONITOR 
2015			;endif 
2015			; 
2015			;	; do str cpy 
2015			; 
2015			;	ldir      ; copy byte in hl to de 
2015			; 
2015			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
2015			; 
2015			;if DEBUG_FORTH_TOK 
2015			; 
2015			;			DMARK "TKY" 
2015			;	CALLMONITOR 
2015			;endif 
2015			;	;ld a,0 
2015			;	;ld a,FORTH_END_BUFFER 
2015			;	ex de, hl 
2015			;	;dec hl			 ; go back over the space delim at the end of word 
2015			;	;ld (hl),a 
2015			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
2015			;	ld a,FORTH_END_BUFFER 
2015			;	ld (hl),a 
2015			;	inc hl 
2015			;	ld a,FORTH_END_BUFFER 
2015			;	ld (hl),a 
2015			; 
2015			;	; init the malloc area data 
2015			;	; set pc for in current area 
2015			;	;ld hl, (os_tok_malloc) 
2015			;	;inc hl 
2015			;	;inc hl 
2015			;	;inc hl 
2015			;	;ex de,hl 
2015			;	;ld hl, (os_tok_malloc) 
2015			;	;ld (hl),e 
2015			;	;inc hl 
2015			;	;ld (hl),d 
2015			; 
2015			; 
2015			;	ld hl,(os_tok_malloc) 
2015			;if DEBUG_FORTH_PARSE_KEY 
2015			;			DMARK "TKU" 
2015			;	CALLMONITOR 
2015			;endif 
2015			; 
2015			;	ret 
2015			 
2015			forthexec: 
2015			 
2015			; line exec: 
2015			; forth parser 
2015			 
2015			; 
2015			;       get current exec line on rsp 
2015			 
2015				FORTH_RSP_TOS 
2015 cd d7 1b			call macro_forth_rsp_tos 
2018				endm 
# End of macro FORTH_RSP_TOS
2018			 
2018			;       restore current pc - hl points to malloc of data 
2018			 
2018				;ld e, (hl) 
2018				;inc hl 
2018				;ld d, (hl) 
2018				;ex de,hl 
2018			 
2018			 
2018			exec1: 
2018 22 03 e6			ld (os_tok_ptr), hl 
201b			 
201b				; copy our PC to working vars  
201b 22 4d ea			ld (cli_ptr), hl 
201e 22 4b ea			ld (cli_origptr), hl 
2021			 
2021 7e				ld a,(hl) 
2022 fe 7f			cp FORTH_END_BUFFER 
2024 c8				ret z 
2025			 
2025				; skip any nulls 
2025			 
2025 fe 00			cp 0 
2027 20 03			jr nz, .execword 
2029 23				inc hl 
202a 18 ec			jr exec1 
202c			 
202c			 
202c			.execword: 
202c			 
202c			 
202c			 
202c			if DEBUG_FORTH_PARSE_KEY 
202c						DMARK "KYQ" 
202c				CALLMONITOR 
202c			endif 
202c			;       while at start of word: 
202c			; get start of dict (in user area first) 
202c			 
202c 21 09 5c		ld hl, baseram 
202f			;ld hl, sysdict 
202f 22 4f ea		ld (cli_nextword),hl 
2032			;           match word at pc 
2032			;           exec word 
2032			;           or push to dsp 
2032			;           forward to next token 
2032			;           if line term pop rsp and exit 
2032			;        
2032			 
2032			if DEBUG_FORTH_PARSE_KEY 
2032						DMARK "KYq" 
2032				CALLMONITOR 
2032			endif 
2032			 
2032			; 
2032			; word comp 
2032			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
2032			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
2032			;    move to start of word  
2032			;    compare word to cli_token 
2032			 
2032			.execpnword:	; HL at start of a word in the dictionary to check 
2032			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
2032			;	ld (cli_ptr), hl 
2032			 
2032 2a 4f ea			ld hl,(cli_nextword) 
2035			 
2035 cd d8 20			call forth_tok_next 
2038			; tok next start here 
2038			;	; TODO skip compiled symbol for now 
2038			;	inc hl 
2038			; 
2038			;	; save pointer to next word 
2038			; 
2038			;	; hl now points to the address of the next word pointer  
2038			;	ld e, (hl) 
2038			;	inc hl 
2038			;	ld d, (hl) 
2038			;	inc l 
2038			; 
2038			;	ex de,hl 
2038			;if DEBUG_FORTH_PARSE_NEXTWORD 
2038			;	push bc 
2038			;	ld bc, (cli_nextword) 
2038			;			DMARK "NXW" 
2038			;	CALLMONITOR 
2038			;	pop bc 
2038			;endif 
2038			; tok next end here 
2038 22 4f ea			ld (cli_nextword), hl     ; save for next check if no match on this word 
203b eb				ex de, hl 
203c			 
203c			 
203c				; save the pointer of the current token - 1 to check against 
203c				 
203c 22 53 ea			ld (cli_token), hl   
203f				; TODO maybe remove below save if no debug 
203f				; save token string ptr for any debug later 
203f 23				inc hl  
2040 22 55 ea			ld (cli_origtoken), hl 
2043 2b				dec hl 
2044				; save pointer to the start of the next dictionay word 
2044 7e				ld a,(hl)   ; get string length 
2045 47				ld b,a 
2046			.execpnwordinc:  
2046 23				inc hl 
2047 10 fd			djnz .execpnwordinc 
2049 22 51 ea			ld (cli_execword), hl      ; save start of this words code 
204c			 
204c				; now check the word token against the string being parsed 
204c			 
204c 2a 53 ea			ld hl,(cli_token) 
204f 23				inc hl     ; skip string length (use zero term instead to end) 
2050 22 53 ea			ld (cli_token), hl 
2053			 
2053			if DEBUG_FORTH_PARSE_KEY 
2053						DMARK "KY2" 
2053			endif 
2053			if DEBUG_FORTH_PARSE_EXEC 
2053				; see if disabled 
2053			 
2053				ld a, (os_view_disable) 
2053				cp '*' 
2053				jr z, .skip 
2053			 
2053				push hl 
2053				push hl 
2053				call clear_display 
2053				ld de, .compword 
2053				ld a, display_row_1 
2053				call str_at_display 
2053				pop de 
2053				ld a, display_row_2 
2053				call str_at_display 
2053				ld hl,(cli_ptr) 
2053				ld a,(hl) 
2053			        ld hl, os_word_scratch 
2053				ld (hl),a 
2053				ld a,0 
2053				inc hl 
2053				ld (hl),a 	 
2053				ld de, os_word_scratch 
2053				ld a, display_row_2+10 
2053				call str_at_display 
2053				call update_display 
2053				ld a, 100 
2053				call aDelayInMS 
2053				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2053				call delay250ms 
2053				endif 
2053				pop hl 
2053			.skip:  
2053			endif	 
2053			.execpnchar:    ; compare char between token and string to parse 
2053			 
2053			if DEBUG_FORTH_PARSE_KEY 
2053						DMARK "Ky3" 
2053			endif 
2053			if DEBUG_FORTH_PARSE_EXEC 
2053				; see if disabled 
2053			 
2053				ld a, (os_view_disable) 
2053				cp '*' 
2053				jr z, .skip2 
2053			 
2053			;	call clear_display 
2053			ld hl,(cli_token) 
2053			ld a,(hl) 
2053			ld (os_word_scratch),a 
2053				ld hl,(cli_ptr) 
2053			ld a,(hl) 
2053				ld (os_word_scratch+1),a 
2053				ld a,0 
2053				ld (os_word_scratch+2),a 
2053				ld de,os_word_scratch 
2053				ld a,display_row_4 
2053				call str_at_display 
2053				call update_display 
2053			.skip2:  
2053			endif 
2053 2a 53 ea			ld hl,(cli_token) 
2056 7e				ld a, (hl)	 ; char in word token 
2057 23				inc hl 		; move to next char 
2058 22 53 ea			ld (cli_token), hl ; and save it 
205b 47				ld b,a 
205c			 
205c 2a 4d ea			ld hl,(cli_ptr) ;	get the char from the string to parse 
205f 7e				ld a,(hl) 
2060 23				inc hl 
2061 22 4d ea			ld (cli_ptr), hl		; move to next char 
2064 cd fc 11			call toUpper 		; make sure the input string matches case 
2067			 
2067			if DEBUG_FORTH_PARSE 
2067			endif 
2067			 
2067				; input stream end of token is a space so get rid of it 
2067			 
2067			;	cp ' ' 
2067			;	jr nz, .pnskipspace 
2067			; 
2067			;	ld a, 0		; make same term as word token term 
2067			; 
2067			;.pnskipspace: 
2067			 
2067			if DEBUG_FORTH_PARSE_KEY 
2067						DMARK "KY7" 
2067			endif 
2067 b8				cp b 
2068 c2 7e 20			jp nz, .execpnskipword	 ; no match so move to next word 
206b				 
206b			;    if same 
206b			;       scan for string terms 0 for token and 32 for input 
206b			 
206b				 
206b			if DEBUG_FORTH_PARSE_KEY 
206b						DMARK "KY8" 
206b			endif 
206b			 
206b 80				add b			 
206c fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
206e							; TODO need to make sure last word in zero term string is accounted for 
206e 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
2070			 
2070			 
2070				; at end of both strings so both are exact match 
2070			 
2070			;       skip ptr for next word 
2070			 
2070 2a 4d ea			ld hl,(cli_ptr) 	; at input string term 
2073 23				inc hl			 ; at next char 
2074 22 4d ea			ld (cli_ptr), hl     ; save for next round of the parser 
2077 22 4b ea			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
207a				 
207a				 
207a			if DEBUG_FORTH_PARSE_KEY 
207a						DMARK "KY3" 
207a			endif 
207a			 
207a			 
207a			 
207a			;       exec code block 
207a			if DEBUG_FORTH_JP 
207a				call clear_display 
207a				call update_display 
207a				call delay1s 
207a				ld hl, (cli_execword)     ; save for next check if no match on this word 
207a				ld a,h 
207a				ld hl, os_word_scratch 
207a				call hexout 
207a				ld hl, (cli_execword)     ; save for next check if no match on this word 
207a				ld a,l 
207a				ld hl, os_word_scratch+2 
207a				call hexout 
207a				ld hl, os_word_scratch+4 
207a				ld a,0 
207a				ld (hl),a 
207a				ld de,os_word_scratch 
207a				call str_at_display 
207a					ld a, display_row_2 
207a					call str_at_display 
207a				ld de, (cli_origtoken) 
207a				ld a, display_row_1+10 
207a					call str_at_display 
207a			 
207a				ld a,display_row_1 
207a				ld de, .foundword 
207a				ld a, display_row_3 
207a				call str_at_display 
207a				call update_display 
207a				call delay1s 
207a				call delay1s 
207a				call delay1s 
207a			endif 
207a			 
207a			if DEBUG_FORTH_PARSE_KEY 
207a						DMARK "KYj" 
207a			endif 
207a				; TODO save the word pointer in this exec 
207a			 
207a 2a 51 ea			ld hl,(cli_execword) 
207d e9				jp (hl) 
207e			 
207e			 
207e			;    if not same 
207e			;	scan for zero term 
207e			;	get ptr for next word 
207e			;	goto word comp 
207e			 
207e			.execpnskipword:	; get pointer to next word 
207e 2a 4f ea			ld hl,(cli_nextword) 
2081			 
2081 7e				ld a,(hl) 
2082 fe 00			cp WORD_SYS_END 
2084			;	cp 0 
2084 28 09			jr z, .execendofdict			 ; at end of words 
2086			 
2086			if DEBUG_FORTH_PARSE_KEY 
2086						DMARK "KY4" 
2086			endif 
2086			if DEBUG_FORTH_PARSE_EXEC 
2086			 
2086				; see if disabled 
2086			 
2086				ld a, (os_view_disable) 
2086				cp '*' 
2086				jr z, .noskip 
2086			 
2086			 
2086				ld de, .nowordfound 
2086				ld a, display_row_3 
2086				call str_at_display 
2086				call update_display 
2086				ld a, 100 
2086				call aDelayInMS 
2086				 
2086				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2086					call delay250ms 
2086				endif 
2086			.noskip:  
2086			 
2086			endif	 
2086			 
2086 2a 4b ea			ld hl,(cli_origptr) 
2089 22 4d ea			ld (cli_ptr),hl 
208c			 
208c			if DEBUG_FORTH_PARSE_KEY 
208c						DMARK "KY5" 
208c			endif 
208c c3 32 20			jp .execpnword			; else go to next word 
208f			 
208f			.execendofdict:  
208f			 
208f			if DEBUG_FORTH_PARSE_KEY 
208f						DMARK "KYe" 
208f			endif 
208f			if DEBUG_FORTH_PARSE_EXEC 
208f				; see if disabled 
208f			 
208f				ld a, (os_view_disable) 
208f				cp '*' 
208f				jr z, .ispskip 
208f			 
208f				call clear_display 
208f				call update_display 
208f				call delay1s 
208f				ld de, (cli_origptr) 
208f				ld a, display_row_1 
208f				call str_at_display 
208f				 
208f				ld de, .enddict 
208f				ld a, display_row_3 
208f				call str_at_display 
208f				call update_display 
208f				ld a, 100 
208f				call aDelayInMS 
208f				if DEBUG_FORTH_PARSE_EXEC_SLOW 
208f				call delay1s 
208f				call delay1s 
208f				call delay1s 
208f				endif 
208f			.ispskip:  
208f				 
208f			endif	 
208f			 
208f			 
208f			 
208f				; if the word is not a keyword then must be a literal so push it to stack 
208f			 
208f			; push token to stack to end of word 
208f			 
208f				STACKFRAME ON $1efe $2f9f 
208f				if DEBUG_STACK_IMB 
208f					if ON 
208f						exx 
208f						ld de, $1efe 
208f						ld a, d 
208f						ld hl, curframe 
208f						call hexout 
208f						ld a, e 
208f						ld hl, curframe+2 
208f						call hexout 
208f						ld hl, $1efe 
208f						push hl 
208f						ld hl, $2f9f 
208f						push hl 
208f						exx 
208f					endif 
208f				endif 
208f			endm 
# End of macro STACKFRAME
208f			 
208f 2a 03 e6		ld hl,(os_tok_ptr) 
2092 cd 82 1d		call forth_apush 
2095			 
2095				STACKFRAMECHK ON $1efe $2f9f 
2095				if DEBUG_STACK_IMB 
2095					if ON 
2095						exx 
2095						ld hl, $2f9f 
2095						pop de   ; $2f9f 
2095						call cmp16 
2095						jr nz, .spnosame 
2095						ld hl, $1efe 
2095						pop de   ; $1efe 
2095						call cmp16 
2095						jr z, .spfrsame 
2095						.spnosame: call showsperror 
2095						.spfrsame: nop 
2095						exx 
2095					endif 
2095				endif 
2095			endm 
# End of macro STACKFRAMECHK
2095			 
2095			execnext: 
2095			 
2095			if DEBUG_FORTH_PARSE_KEY 
2095						DMARK "KY>" 
2095			endif 
2095			; move past token to next word 
2095			 
2095 2a 03 e6		ld hl, (os_tok_ptr) 
2098 3e 00		ld a, 0 
209a 01 ff 00		ld bc, 255     ; input buffer size 
209d ed b1		cpir 
209f			 
209f			if DEBUG_FORTH_PARSE_KEY 
209f						DMARK "KY!" 
209f				CALLMONITOR 
209f			endif	 
209f			; TODO this might place hl on the null, so will need to forward on??? 
209f			;inc hl   ; see if this gets onto the next item 
209f			 
209f			 
209f			; TODO pass a pointer to the buffer to push 
209f			; TODO call function to push 
209f			 
209f			; look for end of input 
209f			 
209f			;inc hl 
209f			;ld a,(hl) 
209f			;cp FORTH_END_BUFFER 
209f			;ret z 
209f			 
209f			 
209f c3 18 20		jp exec1 
20a2			 
20a2			 
20a2			 
20a2			 
20a2			 
20a2			 
20a2			 
20a2			 
20a2			 
20a2			findnexttok: 
20a2			 
20a2				; hl is pointer to move 
20a2				; de is the token to locate 
20a2			 
20a2					if DEBUG_FORTH 
20a2						DMARK "NTK" 
20a2						CALLMONITOR 
20a2					endif 
20a2 d5				push de 
20a3			 
20a3			.fnt1:	 
20a3				; find first char of token to locate 
20a3			 
20a3 1a				ld a, (de) 
20a4 4f				ld c,a 
20a5 7e				ld a,(hl) 
20a6 cd fc 11			call toUpper 
20a9					if DEBUG_FORTH 
20a9						DMARK "NT1" 
20a9						CALLMONITOR 
20a9					endif 
20a9 b9				cp c 
20aa			 
20aa 28 03			jr z, .fnt2cmpmorefirst	 
20ac			 
20ac				; first char not found move to next char 
20ac			 
20ac 23				inc hl 
20ad 18 f4			jr .fnt1 
20af			 
20af			.fnt2cmpmorefirst:	 
20af				; first char of token found.  
20af			 
20af e5				push hl     ; save start of token just in case it is the right one 
20b0 d9				exx 
20b1 e1				pop hl        ; save it to hl' 
20b2 d9				exx 
20b3			 
20b3			 
20b3			.fnt2cmpmore:	 
20b3				; compare the rest 
20b3				 
20b3 23				inc hl 
20b4 13				inc de 
20b5				 
20b5 1a				ld a, (de) 
20b6 4f				ld c,a 
20b7 7e				ld a,(hl) 
20b8 cd fc 11			call toUpper 
20bb			 
20bb					if DEBUG_FORTH 
20bb						DMARK "NT2" 
20bb						CALLMONITOR 
20bb					endif 
20bb				; c has the token to find char 
20bb				; a has the mem to scan char 
20bb			 
20bb b9				cp c 
20bc 28 04			jr z,.fntmatch1 
20be			 
20be				; they are not the same 
20be			 
20be					if DEBUG_FORTH 
20be						DMARK "NT3" 
20be						CALLMONITOR 
20be					endif 
20be d1				pop de	; reset de token to look for 
20bf d5				push de 
20c0 18 e1			jr .fnt1 
20c2				 
20c2			.fntmatch1: 
20c2			 
20c2				; is the same char a null which means we might have a full hit? 
20c2					if DEBUG_FORTH 
20c2						DMARK "NT4" 
20c2						CALLMONITOR 
20c2					endif 
20c2			 
20c2 fe 00			cp 0 
20c4 28 0b			jr z, .fntmatchyes 
20c6			 
20c6				; are we at the end of the token to find? 
20c6			 
20c6					if DEBUG_FORTH 
20c6						DMARK "NT5" 
20c6						CALLMONITOR 
20c6					endif 
20c6 3e 00			ld a, 0 
20c8 b9				cp c 
20c9			 
20c9 c2 b3 20			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
20cc			 
20cc					if DEBUG_FORTH 
20cc						DMARK "NT6" 
20cc						CALLMONITOR 
20cc					endif 
20cc				; token to find is exhusted but no match to stream 
20cc			 
20cc				; restore tok pointer and continue on 
20cc d1				pop de 
20cd d5				push de 
20ce c3 a3 20			jp .fnt1 
20d1			 
20d1			 
20d1			.fntmatchyes: 
20d1			 
20d1				; hl now contains the end of the found token 
20d1			 
20d1				; get rid of saved token pointer to find 
20d1			 
20d1 d1				pop de 
20d2			 
20d2					if DEBUG_FORTH 
20d2						DMARK "NT9" 
20d2						CALLMONITOR 
20d2					endif 
20d2			 
20d2				; hl will be on the null term so forward on 
20d2			 
20d2				; get back the saved start of the token 
20d2			 
20d2 d9				exx 
20d3 e5				push hl     ; save start of token just in case it is the right one 
20d4 d9				exx 
20d5 e1				pop hl        ; save it to hl 
20d6			 
20d6 c9				ret 
20d7			 
20d7			 
20d7			; LIST needs to find a specific token   
20d7			; FORGET needs to find a spefici token 
20d7			 
20d7			; SAVE needs to find all tokens by flag 
20d7			; WORDS just needs to scan through all  by flag 
20d7			; UWORDS needs to scan through all by flag 
20d7			 
20d7			 
20d7			; given hl as pointer to start of dict look up string 
20d7			; return hl as pointer to start of word block 
20d7			; or 0 if not found 
20d7			 
20d7			forth_find_tok: 
20d7 c9				ret 
20d8			 
20d8			; given hl as pointer to dict structure 
20d8			; move to the next dict block structure 
20d8			 
20d8			forth_tok_next: 
20d8				; hl now points to the address of the next word pointer  
20d8				; TODO skip compiled symbol for now 
20d8			;	push de 
20d8 23				inc hl 
20d9 5e				ld e, (hl) 
20da 23				inc hl 
20db 56				ld d, (hl) 
20dc 23				inc hl 
20dd			 
20dd eb				ex de,hl 
20de			if DEBUG_FORTH_PARSE_NEXTWORD 
20de				push bc 
20de				ld bc, (cli_nextword) 
20de						DMARK "NXW" 
20de				CALLMONITOR 
20de				pop bc 
20de			endif 
20de			;	pop de	 
20de c9				ret 
20df			 
20df			 
20df			 
20df			; eof 
# End of file forth_parserv5.asm
20df				include "forth_wordsv4.asm" 
20df			 
20df			; the core word dictionary v4 
20df			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
20df			 
20df			; this is a linked list for each of the system words used 
20df			; user defined words will follow the same format but will be in ram 
20df			 
20df			 
20df			; 
20df			; 
20df			; define linked list: 
20df			; 
20df			; 1. compiled byte op code 
20df			; 2. len of text word 
20df			; 3. text word 
20df			; 4. ptr to next dictionary word 
20df			; 5. asm, calls etc for the word 
20df			; 
20df			;  if 1 == 0 then last word in dict  
20df			;   
20df			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
20df			;  
20df			;  
20df			; create basic standard set of words 
20df			; 
20df			;  
20df			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
20df			; 2DUP 2DROP 2SWAP  
20df			; @ C@ - get byte  
20df			; ! C! - store byte 
20df			; 0< true if less than zero 
20df			; 0= true if zero 
20df			; < >  
20df			; = true if same 
20df			; variables 
20df			 
20df			 
20df			; Hardware specific words I may need 
20df			; 
20df			; IN OUT  
20df			; calls to key util functions 
20df			; calls to hardward abstraction stuff 
20df			; easy control of frame buffers and lcd i/o 
20df			; keyboard  
20df			 
20df			 
20df			;DICT: macro 
20df			; op_code, len, word, next 
20df			;    word: 
20df			;    db op_code 
20df			;    ds word zero term 
20df			;    dw next 
20df			;    endm 
20df			 
20df			 
20df			 
20df			 
20df			; op code 1 is a flag for user define words which are to be handled differently 
20df			 
20df			 
20df			; 
20df			; 
20df			;    TODO on entry to a word this should be the expected environment 
20df			;    hl - tos value if number then held, if string this is the ptr 
20df			;    de -  
20df			 
20df			 
20df			; opcode ranges 
20df			; 0 - end of word dict 
20df			; 255 - user define words 
20df			 
20df			sysdict: 
20df			include "forth_opcodes.asm" 
20df			; op codes for forth keywords 
20df			; free to use code 0  
20df				OPCODE_HEAP: equ  1 
20df				OPCODE_EXEC: equ 2 
20df				OPCODE_DUP: equ 3 
20df				OPCODE_SWAP: equ 4 
20df				OPCODE_COLN: equ 5 
20df				OPCODE_SCOLN: equ 6 
20df				OPCODE_DROP: equ 7 
20df				OPCODE_DUP2: equ 8 
20df				OPCODE_DROP2: equ 9 
20df				OPCODE_SWAP2: equ 10 
20df				OPCODE_AT: equ 11 
20df				OPCODE_CAT: equ 12 
20df				OPCODE_BANG: equ 13 
20df				OPCODE_CBANG: equ 14 
20df				OPCODE_SCALL: equ 15 
20df				OPCODE_DEPTH: equ 16 
20df				OPCODE_OVER: equ 17 
20df				OPCODE_PAUSE: equ 18 
20df				OPCODE_PAUSES: equ 19 
20df				OPCODE_ROT: equ 20 
20df			;free to reuse	OPCODE_WORDS: equ 21 
20df			        OPCODE_NOT: equ 21 
20df				OPCODE_UWORDS: equ 22 
20df				OPCODE_BP: equ 23 
20df				OPCODE_MONITOR: equ 24  
20df				OPCODE_MALLOC: equ 25 
20df				OPCODE_FREE: equ 26 
20df				OPCODE_LIST: equ 27 
20df				OPCODE_FORGET: equ 28 
20df				OPCODE_NOP: equ 29 
20df				OPCODE_COMO: equ 30 
20df				OPCODE_COMC: equ 31 
20df			;free to reuse	OPCODE_ENDCORE: equ 32 
20df				OPCODE_AFTERSOUND: equ 33 
20df				OPCODE_GP2: equ 34 
20df				OPCODE_GP3: equ 35 
20df				OPCODE_GP4: equ 36 
20df				OPCODE_SIN: equ 37 
20df				OPCODE_SOUT: equ 38 
20df				OPCODE_SPIO: equ 39 
20df				OPCODE_SPICEH: equ 40 
20df				OPCODE_SPIOb: equ 41 
20df				OPCODE_SPII: equ 42 
20df				OPCODE_SESEL: equ 43 
20df				OPCODE_CARTDEV: equ 44 
20df			; free to reuse	OPCODE_ENDDEVICE: equ 45 
20df				OPCODE_FB: equ 46 
20df				OPCODE_EMIT: equ 47 
20df				OPCODE_DOTH: equ 48 
20df				OPCODE_DOTF: equ 49 
20df				OPCODE_DOT: equ 50 
20df				OPCODE_CLS: equ 51 
20df				OPCODE_DRAW: equ 52 
20df				OPCODE_DUMP: equ 53 
20df				OPCODE_CDUMP: equ 54 
20df				OPCODE_DAT: equ 55 
20df				OPCODE_HOME: equ 56 
20df				OPCODE_SPACE: equ 57 
20df				OPCODE_SPACES: equ 58 
20df				OPCODE_SCROLL: equ 59 
20df				OPCODE_ATQ: equ 60 
20df				OPCODE_AUTODSP: equ 61 
20df				OPCODE_MENU: equ 62 
20df			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
20df				OPCODE_THEN: equ 64 
20df				OPCODE_ELSE: equ 65 
20df				OPCODE_DO: equ 66 
20df				OPCODE_LOOP: equ 67 
20df				OPCODE_I: equ 68 
20df				OPCODE_DLOOP: equ 69  
20df				OPCODE_REPEAT: equ 70  
20df				OPCODE_UNTIL: equ 71 
20df				OPCODE_ENDFLOW: equ 72 
20df				OPCODE_WAITK: equ 73 
20df				OPCODE_ACCEPT: equ 74 
20df				OPCODE_EDIT: equ 75 
20df			;free to reuse	OPCODE_ENDKEY: equ 76 
20df				OPCODE_LZERO: equ 77 
20df				OPCODE_TZERO: equ 78 
20df				OPCODE_LESS: equ 79 
20df				OPCODE_GT: equ 80 
20df				OPCODE_EQUAL: equ 81  
20df			;free to reuse	OPCODE_ENDLOGIC: equ 82 
20df				OPCODE_NEG: equ 83 
20df				OPCODE_DIV: equ 84 
20df				OPCODE_MUL: equ 85 
20df				OPCODE_MIN: equ 86 
20df				OPCODE_MAX: equ 87 
20df				OPCODE_RND16: equ 88 
20df				OPCODE_RND8: equ 89 
20df				OPCODE_RND: equ 90 
20df			;free to reuse	OPCODE_ENDMATHS: equ 91  
20df				OPCODE_BYNAME: equ 92 
20df				OPCODE_DIR: equ 93 
20df				OPCODE_SAVE: equ 94 
20df				OPCODE_LOAD: equ 95 
20df				OPCODE_BSAVE: equ 96 
20df				OPCODE_BLOAD: equ 97 
20df				OPCODE_SEO: equ 98  
20df				OPCODE_SEI: equ 99 
20df				OPCODE_SFREE: equ 100 
20df				OPCODE_SIZE: equ 101 
20df				OPCODE_CREATE: equ 102 
20df				OPCODE_APPEND: equ 103 
20df				OPCODE_SDEL: equ 104 
20df				OPCODE_OPEN: equ 105 
20df				OPCODE_READ: equ 106 
20df				OPCODE_EOF: equ 106 
20df				OPCODE_FORMAT: equ 107 
20df				OPCODE_LABEL: equ 108 
20df				OPCODE_LABELS: equ 109 
20df			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
20df				OPCODE_UPPER: equ 111 
20df				OPCODE_LOWER: equ 112 
20df				OPCODE_SUBSTR: equ 113 
20df				OPCODE_LEFT: equ 114 
20df				OPCODE_RIGHT: equ 115 
20df				OPCODE_STR2NUM: equ 116 
20df				OPCODE_NUM2STR: equ 117 
20df				OPCODE_CONCAT: equ 118 
20df				OPCODE_FIND: equ 119 
20df				OPCODE_LEN: equ 120 
20df				OPCODE_CHAR: equ 121 
20df			; free to reuse	OPCODE_STRLEN: equ 122 
20df			; free to reuse	OPCODE_ENDSTR: equ 123 
20df				OPCODE_V0S: equ 124 
20df				OPCODE_V0Q: equ 125 
20df				OPCODE_V1S: equ 126 
20df				OPCODE_V1Q: equ 127 
20df				OPCODE_V2S: equ 128 
20df				OPCODE_V2Q: equ 129 
20df				OPCODE_V3S: equ 130 
20df				OPCODE_V3Q: equ 131 
20df			;free to reuse	OPCODE_END: equ 132 
20df				OPCODE_ZDUP: equ 133 
20df			 
20df			; eof 
# End of file forth_opcodes.asm
20df			 
20df			include "forth_words_core.asm" 
20df			 
20df			; | ## Core Words 
20df			 
20df			;if MALLOC_4 
20df			 
20df			.HEAP: 
20df				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
20df 15				db WORD_SYS_CORE+OPCODE_HEAP             
20e0 1e 21			dw .EXEC            
20e2 05				db 4 + 1 
20e3 .. 00			db "HEAP",0              
20e8				endm 
# End of macro CWHEAD
20e8			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
20e8			; | | u1 - Current number of bytes in the heap 
20e8			; | | u2 - Remaining bytes left on the heap 
20e8			; | |  
20e8			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
20e8			 
20e8			 
20e8					if DEBUG_FORTH_WORDS_KEY 
20e8						DMARK "HEP" 
20e8 f5				push af  
20e9 3a fd 20			ld a, (.dmark)  
20ec 32 71 ee			ld (debug_mark),a  
20ef 3a fe 20			ld a, (.dmark+1)  
20f2 32 72 ee			ld (debug_mark+1),a  
20f5 3a ff 20			ld a, (.dmark+2)  
20f8 32 73 ee			ld (debug_mark+2),a  
20fb 18 03			jr .pastdmark  
20fd ..			.dmark: db "HEP"  
2100 f1			.pastdmark: pop af  
2101			endm  
# End of macro DMARK
2101						CALLMONITOR 
2101 cd a8 15			call break_point_state  
2104				endm  
# End of macro CALLMONITOR
2104					endif 
2104 2a 13 5c				ld hl, (free_list )      
2107 11 18 5c				ld de, heap_start 
210a			 
210a ed 52				sbc hl, de  
210c			 
210c cd 19 1c				call forth_push_numhl 
210f			 
210f			 
210f ed 5b 13 5c			ld de, (free_list )      
2113 21 e8 e2				ld hl, heap_end 
2116			 
2116 ed 52				sbc hl, de 
2118			 
2118 cd 19 1c				call forth_push_numhl 
211b					 
211b			 
211b					 
211b			 
211b			 
211b			 
211b					NEXTW 
211b c3 87 1f			jp macro_next 
211e				endm 
# End of macro NEXTW
211e			;endif 
211e			 
211e			.EXEC: 
211e			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
211e			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
211e			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
211e			;; > > 
211e			;; > >   
211e			;	STACKFRAME OFF $5efe $5f9f 
211e			; 
211e			;		if DEBUG_FORTH_WORDS_KEY 
211e			;			DMARK "EXE" 
211e			;			CALLMONITOR 
211e			;		endif 
211e			; 
211e			;	FORTH_DSP_VALUEHL 
211e			; 
211e			;	FORTH_DSP_POP 
211e			; 
211e			;		if DEBUG_FORTH_WORDS 
211e			;			DMARK "EX1" 
211e			;			CALLMONITOR 
211e			;		endif 
211e			;;	ld e,(hl) 
211e			;;	inc hl 
211e			;;	ld d,(hl) 
211e			;;	ex de,hl 
211e			; 
211e			;;		if DEBUG_FORTH_WORDS 
211e			;;			DMARK "EX2" 
211e			;;			CALLMONITOR 
211e			;;		endif 
211e			;	push hl 
211e			; 
211e			;	;ld a, 0 
211e			;	;ld a, FORTH_END_BUFFER 
211e			;	call strlenz 
211e			;	inc hl   ; include zero term to copy 
211e			;	inc hl   ; include term 
211e			;	inc hl   ; include term 
211e			;	ld b,0 
211e			;	ld c,l 
211e			;	pop hl 
211e			;	ld de, execscratch 
211e			;		if DEBUG_FORTH_WORDS 
211e			;			DMARK "EX3" 
211e			;			CALLMONITOR 
211e			;		endif 
211e			;	ldir 
211e			; 
211e			; 
211e			;	ld hl, execscratch 
211e			; 
211e			;		if DEBUG_FORTH_WORDS 
211e			;			DMARK "EXe" 
211e			;			CALLMONITOR 
211e			;		endif 
211e			; 
211e			;	call forthparse 
211e			;	call forthexec 
211e			;;	call forthexec_cleanup 
211e			;;	call forthparse 
211e			;;	call forthexec 
211e			; 
211e			;	STACKFRAMECHK OFF $5efe $5f9f 
211e			; 
211e			;	; an immediate word so no need to process any more words 
211e			;	ret 
211e			;	NEXTW 
211e			 
211e			; dead code - old version  
211e			;	FORTH_RSP_NEXT 
211e			 
211e			;  
211e			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
211e			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
211e			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
211e			;	push hl 
211e			;	push de 
211e			;	push bc 
211e			; 
211e			; 
211e			;		if DEBUG_FORTH_WORDS_KEY 
211e			;			DMARK "EXR" 
211e			;			CALLMONITOR 
211e			;		endif 
211e			; 
211e			; 
211e			; 
211e			;	;v5 FORTH_DSP_VALUE 
211e			;	FORTH_DSP_VALUEHL 
211e			; 
211e			;	; TODO do string type checks 
211e			; 
211e			;;v5	inc hl   ; skip type 
211e			; 
211e			;	push hl  ; source code  
211e			;		if DEBUG_FORTH_WORDS 
211e			;			DMARK "EX1" 
211e			;			CALLMONITOR 
211e			;		endif 
211e			;	ld a, 0 
211e			;	call strlent 
211e			; 
211e			;	inc hl 
211e			;	inc hl 
211e			;	inc hl 
211e			;	inc hl 
211e			; 
211e			;	push hl    ; size 
211e			; 
211e			;		if DEBUG_FORTH_WORDS 
211e			;			DMARK "EX2" 
211e			;			CALLMONITOR 
211e			;		endif 
211e			;	call malloc 
211e			; 
211e			;	ex de, hl    ; de now contains malloc area 
211e			;	pop bc   	; get byte count 
211e			;	pop hl      ; get string to copy 
211e			; 
211e			;	push de     ; save malloc for free later 
211e			; 
211e			;		if DEBUG_FORTH_WORDS 
211e			;			DMARK "EX3" 
211e			;			CALLMONITOR 
211e			;		endif 
211e			;	ldir       ; duplicate string 
211e			; 
211e			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
211e			;	 
211e			;	; TODO fix the parse would be better than this...  
211e			;	ex de, hl 
211e			;	dec hl 
211e			;	ld a, 0 
211e			;	ld (hl), a 
211e			;	dec hl 
211e			;	ld a, ' ' 
211e			;	ld (hl), a 
211e			;	dec hl 
211e			;	ld (hl), a 
211e			; 
211e			;	dec hl 
211e			;	ld (hl), a 
211e			; 
211e			; 
211e			;	FORTH_DSP_POP  
211e			; 
211e			;	pop hl     
211e			;	push hl    ; save malloc area 
211e			; 
211e			;		if DEBUG_FORTH_WORDS 
211e			;			DMARK "EX4" 
211e			;			CALLMONITOR 
211e			;		endif 
211e			; 
211e			;	call forthparse 
211e			;	call forthexec 
211e			;	 
211e			;	pop hl 
211e			;	if DEBUG_FORTH_WORDS 
211e			;		DMARK "EX5" 
211e			;		CALLMONITOR 
211e			;	endif 
211e			; 
211e			;	if FORTH_ENABLE_FREE 
211e			;	call free 
211e			;	endif 
211e			; 
211e			;	if DEBUG_FORTH_WORDS 
211e			;		DMARK "EX6" 
211e			;		CALLMONITOR 
211e			;	endif 
211e			; 
211e			;	pop bc 
211e			;	pop de 
211e			;	pop hl 
211e			;;	FORTH_RSP_POP	  
211e			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
211e			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
211e			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
211e			; 
211e			;	if DEBUG_FORTH_WORDS 
211e			;		DMARK "EX7" 
211e			;		CALLMONITOR 
211e			;	endif 
211e			;	NEXTW 
211e			 
211e			;.STKEXEC: 
211e			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
211e			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
211e			; 
211e			; 
211e			;		if DEBUG_FORTH_WORDS_KEY 
211e			;			DMARK "STX" 
211e			;			CALLMONITOR 
211e			;		endif 
211e			; 
211e			;	FORTH_DSP_VALUEHL 
211e			; 
211e			;	ld (store_tmp1), hl    ; count 
211e			; 
211e			;	FORTH_DSP_POP 
211e			;.stkexec1: 
211e			;	ld hl, (store_tmp1)   ; count 
211e			;	ld a, 0 
211e			;	cp l 
211e			;	ret z 
211e			; 
211e			;	dec hl 
211e			;	ld (store_tmp1), hl    ; count 
211e			;	 
211e			;	FORTH_DSP_VALUEHL 
211e			;	push hl 
211e			;	 
211e			;		if DEBUG_FORTH_WORDS 
211e			;			DMARK "EXp" 
211e			;			CALLMONITOR 
211e			;		endif 
211e			;	FORTH_DSP_POP 
211e			; 
211e			;	call strlenz 
211e			;	inc hl   ; include zero term to copy 
211e			;	inc hl   ; include zero term to copy 
211e			;	inc hl   ; include zero term to copy 
211e			;	ld b,0 
211e			;	ld c,l 
211e			;	pop hl 
211e			;	ld de, execscratch 
211e			;		if DEBUG_FORTH_WORDS 
211e			;			DMARK "EX3" 
211e			;			CALLMONITOR 
211e			;		endif 
211e			;	ldir 
211e			; 
211e			; 
211e			;	ld hl, execscratch 
211e			; 
211e			;		if DEBUG_FORTH_WORDS 
211e			;			DMARK "EXP" 
211e			;			CALLMONITOR 
211e			;		endif 
211e			; 
211e			;	call forthparse 
211e			;	ld hl, execscratch 
211e			;		if DEBUG_FORTH_WORDS 
211e			;			DMARK "EXx" 
211e			;			CALLMONITOR 
211e			;		endif 
211e			;	call forthexec 
211e			; 
211e			;	jp .stkexec1 
211e			; 
211e			;	ret 
211e			 
211e			 
211e			.DUP: 
211e				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
211e 17				db WORD_SYS_CORE+OPCODE_DUP             
211f 94 21			dw .ZDUP            
2121 04				db 3 + 1 
2122 .. 00			db "DUP",0              
2126				endm 
# End of macro CWHEAD
2126			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
2126			 
2126					if DEBUG_FORTH_WORDS_KEY 
2126						DMARK "DUP" 
2126 f5				push af  
2127 3a 3b 21			ld a, (.dmark)  
212a 32 71 ee			ld (debug_mark),a  
212d 3a 3c 21			ld a, (.dmark+1)  
2130 32 72 ee			ld (debug_mark+1),a  
2133 3a 3d 21			ld a, (.dmark+2)  
2136 32 73 ee			ld (debug_mark+2),a  
2139 18 03			jr .pastdmark  
213b ..			.dmark: db "DUP"  
213e f1			.pastdmark: pop af  
213f			endm  
# End of macro DMARK
213f						CALLMONITOR 
213f cd a8 15			call break_point_state  
2142				endm  
# End of macro CALLMONITOR
2142					endif 
2142			 
2142					FORTH_DSP 
2142 cd d6 1d			call macro_forth_dsp 
2145				endm 
# End of macro FORTH_DSP
2145			 
2145 7e					ld a, (HL) 
2146 fe 01				cp DS_TYPE_STR 
2148 20 25				jr nz, .dupinum 
214a			 
214a					; push another string 
214a			 
214a					FORTH_DSP_VALUEHL     		 
214a cd 10 1e			call macro_dsp_valuehl 
214d				endm 
# End of macro FORTH_DSP_VALUEHL
214d			 
214d				if DEBUG_FORTH_WORDS 
214d					DMARK "DUs" 
214d f5				push af  
214e 3a 62 21			ld a, (.dmark)  
2151 32 71 ee			ld (debug_mark),a  
2154 3a 63 21			ld a, (.dmark+1)  
2157 32 72 ee			ld (debug_mark+1),a  
215a 3a 64 21			ld a, (.dmark+2)  
215d 32 73 ee			ld (debug_mark+2),a  
2160 18 03			jr .pastdmark  
2162 ..			.dmark: db "DUs"  
2165 f1			.pastdmark: pop af  
2166			endm  
# End of macro DMARK
2166					CALLMONITOR 
2166 cd a8 15			call break_point_state  
2169				endm  
# End of macro CALLMONITOR
2169				endif 
2169 cd 87 1c				call forth_push_str 
216c			 
216c					NEXTW 
216c c3 87 1f			jp macro_next 
216f				endm 
# End of macro NEXTW
216f			 
216f			 
216f			.dupinum: 
216f					 
216f			 
216f			 
216f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
216f cd 10 1e			call macro_dsp_valuehl 
2172				endm 
# End of macro FORTH_DSP_VALUEHL
2172			 
2172				; TODO add floating point number detection 
2172			 
2172				if DEBUG_FORTH_WORDS 
2172					DMARK "DUi" 
2172 f5				push af  
2173 3a 87 21			ld a, (.dmark)  
2176 32 71 ee			ld (debug_mark),a  
2179 3a 88 21			ld a, (.dmark+1)  
217c 32 72 ee			ld (debug_mark+1),a  
217f 3a 89 21			ld a, (.dmark+2)  
2182 32 73 ee			ld (debug_mark+2),a  
2185 18 03			jr .pastdmark  
2187 ..			.dmark: db "DUi"  
218a f1			.pastdmark: pop af  
218b			endm  
# End of macro DMARK
218b					CALLMONITOR 
218b cd a8 15			call break_point_state  
218e				endm  
# End of macro CALLMONITOR
218e				endif 
218e			 
218e cd 19 1c				call forth_push_numhl 
2191					NEXTW 
2191 c3 87 1f			jp macro_next 
2194				endm 
# End of macro NEXTW
2194			.ZDUP: 
2194				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
2194 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2195 cc 21			dw .SWAP            
2197 05				db 4 + 1 
2198 .. 00			db "?DUP",0              
219d				endm 
# End of macro CWHEAD
219d			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
219d			 
219d					if DEBUG_FORTH_WORDS_KEY 
219d						DMARK "qDU" 
219d f5				push af  
219e 3a b2 21			ld a, (.dmark)  
21a1 32 71 ee			ld (debug_mark),a  
21a4 3a b3 21			ld a, (.dmark+1)  
21a7 32 72 ee			ld (debug_mark+1),a  
21aa 3a b4 21			ld a, (.dmark+2)  
21ad 32 73 ee			ld (debug_mark+2),a  
21b0 18 03			jr .pastdmark  
21b2 ..			.dmark: db "qDU"  
21b5 f1			.pastdmark: pop af  
21b6			endm  
# End of macro DMARK
21b6						CALLMONITOR 
21b6 cd a8 15			call break_point_state  
21b9				endm  
# End of macro CALLMONITOR
21b9					endif 
21b9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
21b9 cd 10 1e			call macro_dsp_valuehl 
21bc				endm 
# End of macro FORTH_DSP_VALUEHL
21bc			 
21bc e5					push hl 
21bd			 
21bd					; is it a zero? 
21bd			 
21bd 3e 00				ld a, 0 
21bf 84					add h 
21c0 85					add l 
21c1			 
21c1 e1					pop hl 
21c2			 
21c2 fe 00				cp 0 
21c4 28 03				jr z, .dup2orig 
21c6			 
21c6			 
21c6 cd 19 1c				call forth_push_numhl 
21c9			 
21c9			 
21c9				; TODO add floating point number detection 
21c9			 
21c9			.dup2orig: 
21c9			 
21c9					NEXTW 
21c9 c3 87 1f			jp macro_next 
21cc				endm 
# End of macro NEXTW
21cc			.SWAP: 
21cc				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
21cc 18				db WORD_SYS_CORE+OPCODE_SWAP             
21cd 0b 22			dw .COLN            
21cf 05				db 4 + 1 
21d0 .. 00			db "SWAP",0              
21d5				endm 
# End of macro CWHEAD
21d5			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
21d5					if DEBUG_FORTH_WORDS_KEY 
21d5						DMARK "SWP" 
21d5 f5				push af  
21d6 3a ea 21			ld a, (.dmark)  
21d9 32 71 ee			ld (debug_mark),a  
21dc 3a eb 21			ld a, (.dmark+1)  
21df 32 72 ee			ld (debug_mark+1),a  
21e2 3a ec 21			ld a, (.dmark+2)  
21e5 32 73 ee			ld (debug_mark+2),a  
21e8 18 03			jr .pastdmark  
21ea ..			.dmark: db "SWP"  
21ed f1			.pastdmark: pop af  
21ee			endm  
# End of macro DMARK
21ee						CALLMONITOR 
21ee cd a8 15			call break_point_state  
21f1				endm  
# End of macro CALLMONITOR
21f1					endif 
21f1			 
21f1					FORTH_DSP_VALUEHL 
21f1 cd 10 1e			call macro_dsp_valuehl 
21f4				endm 
# End of macro FORTH_DSP_VALUEHL
21f4 e5					push hl     ; w2 
21f5			 
21f5					FORTH_DSP_POP 
21f5 cd c8 1e			call macro_forth_dsp_pop 
21f8				endm 
# End of macro FORTH_DSP_POP
21f8			 
21f8					FORTH_DSP_VALUEHL 
21f8 cd 10 1e			call macro_dsp_valuehl 
21fb				endm 
# End of macro FORTH_DSP_VALUEHL
21fb			 
21fb					FORTH_DSP_POP 
21fb cd c8 1e			call macro_forth_dsp_pop 
21fe				endm 
# End of macro FORTH_DSP_POP
21fe			 
21fe d1					pop de     ; w2	, hl = w1 
21ff			 
21ff eb					ex de, hl 
2200 d5					push de 
2201			 
2201 cd 19 1c				call forth_push_numhl 
2204			 
2204 e1					pop hl 
2205			 
2205 cd 19 1c				call forth_push_numhl 
2208					 
2208			 
2208					NEXTW 
2208 c3 87 1f			jp macro_next 
220b				endm 
# End of macro NEXTW
220b			.COLN: 
220b				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
220b 19				db WORD_SYS_CORE+OPCODE_COLN             
220c 97 23			dw .SCOLN            
220e 02				db 1 + 1 
220f .. 00			db ":",0              
2211				endm 
# End of macro CWHEAD
2211			; | : ( -- )         Create new word | DONE 
2211			 
2211					if DEBUG_FORTH_WORDS_KEY 
2211						DMARK "CLN" 
2211 f5				push af  
2212 3a 26 22			ld a, (.dmark)  
2215 32 71 ee			ld (debug_mark),a  
2218 3a 27 22			ld a, (.dmark+1)  
221b 32 72 ee			ld (debug_mark+1),a  
221e 3a 28 22			ld a, (.dmark+2)  
2221 32 73 ee			ld (debug_mark+2),a  
2224 18 03			jr .pastdmark  
2226 ..			.dmark: db "CLN"  
2229 f1			.pastdmark: pop af  
222a			endm  
# End of macro DMARK
222a						CALLMONITOR 
222a cd a8 15			call break_point_state  
222d				endm  
# End of macro CALLMONITOR
222d					endif 
222d				STACKFRAME OFF $8efe $989f 
222d				if DEBUG_STACK_IMB 
222d					if OFF 
222d						exx 
222d						ld de, $8efe 
222d						ld a, d 
222d						ld hl, curframe 
222d						call hexout 
222d						ld a, e 
222d						ld hl, curframe+2 
222d						call hexout 
222d						ld hl, $8efe 
222d						push hl 
222d						ld hl, $989f 
222d						push hl 
222d						exx 
222d					endif 
222d				endif 
222d			endm 
# End of macro STACKFRAME
222d				; get parser buffer length  of new word 
222d			 
222d				 
222d			 
222d					; move tok past this to start of name defintition 
222d					; TODO get word to define 
222d					; TODO Move past word token 
222d					; TODO get length of string up to the ';' 
222d			 
222d 2a 03 e6			ld hl, (os_tok_ptr) 
2230 23				inc hl 
2231 23				inc hl 
2232			 
2232 3e 3b			ld a, ';' 
2234 cd 10 12			call strlent 
2237			 
2237 7d				ld a,l 
2238 32 fe e2			ld (os_new_parse_len), a 
223b			 
223b			 
223b			if DEBUG_FORTH_UWORD 
223b ed 5b 03 e6		ld de, (os_tok_ptr) 
223f						DMARK ":01" 
223f f5				push af  
2240 3a 54 22			ld a, (.dmark)  
2243 32 71 ee			ld (debug_mark),a  
2246 3a 55 22			ld a, (.dmark+1)  
2249 32 72 ee			ld (debug_mark+1),a  
224c 3a 56 22			ld a, (.dmark+2)  
224f 32 73 ee			ld (debug_mark+2),a  
2252 18 03			jr .pastdmark  
2254 ..			.dmark: db ":01"  
2257 f1			.pastdmark: pop af  
2258			endm  
# End of macro DMARK
2258				CALLMONITOR 
2258 cd a8 15			call break_point_state  
225b				endm  
# End of macro CALLMONITOR
225b			endif 
225b			 
225b			; 
225b			;  new word memory layout: 
225b			;  
225b			;    : adg 6666 ;  
225b			; 
225b			;    db   1     ; user defined word  
225b 23				inc hl    
225c			;    dw   sysdict 
225c 23				inc hl 
225d 23				inc hl 
225e			;    db <word len>+1 (for null) 
225e 23				inc hl 
225f			;    db .... <word> 
225f			; 
225f			 
225f 23				inc hl    ; some extras for the word preamble before the above 
2260 23				inc hl 
2261 23				inc hl 
2262 23				inc hl 
2263 23				inc hl 
2264 23				inc hl 
2265 23				inc hl  
2266 23				inc hl 
2267 23				inc hl 
2268 23				inc hl 
2269 23				inc hl 
226a 23				inc hl 
226b 23				inc hl 
226c 23				inc hl     ; TODO how many do we really need?     maybe only 6 
226d			;       exec word buffer 
226d			;	<ptr word>   
226d 23				inc hl 
226e 23				inc hl 
226f			;       <word list><null term> 7F final term 
226f			 
226f			 
226f			if DEBUG_FORTH_UWORD 
226f						DMARK ":02" 
226f f5				push af  
2270 3a 84 22			ld a, (.dmark)  
2273 32 71 ee			ld (debug_mark),a  
2276 3a 85 22			ld a, (.dmark+1)  
2279 32 72 ee			ld (debug_mark+1),a  
227c 3a 86 22			ld a, (.dmark+2)  
227f 32 73 ee			ld (debug_mark+2),a  
2282 18 03			jr .pastdmark  
2284 ..			.dmark: db ":02"  
2287 f1			.pastdmark: pop af  
2288			endm  
# End of macro DMARK
2288				CALLMONITOR 
2288 cd a8 15			call break_point_state  
228b				endm  
# End of macro CALLMONITOR
228b			endif 
228b			 
228b				 
228b					; malloc the size 
228b			 
228b cd 6e 12				call malloc 
228e 22 00 e3				ld (os_new_malloc), hl     ; save malloc start 
2291			 
2291			;    db   1     ; user defined word  
2291 3e 01				ld a, WORD_SYS_UWORD  
2293 77					ld (hl), a 
2294				 
2294 23				inc hl    
2295			;    dw   sysdict 
2295 11 df 20			ld de, sysdict       ; continue on with the scan to the system dict 
2298 73				ld (hl), e 
2299 23				inc hl 
229a 72				ld (hl), d 
229b 23				inc hl 
229c			 
229c			 
229c			;    Setup dict word 
229c			 
229c 23				inc hl 
229d 22 fa e2			ld (os_new_work_ptr), hl     ; save start of dict word  
22a0			 
22a0				; 1. get length of dict word 
22a0			 
22a0			 
22a0 2a 03 e6			ld hl, (os_tok_ptr) 
22a3 23				inc hl 
22a4 23				inc hl    ; position to start of dict word 
22a5 3e 00			ld a, 0 
22a7 cd 10 12			call strlent 
22aa			 
22aa			 
22aa 23				inc hl    ; to include null??? 
22ab			 
22ab				; write length of dict word 
22ab			 
22ab ed 5b fa e2		ld de, (os_new_work_ptr)   ; get dest for copy of word 
22af 1b				dec de 
22b0 eb				ex de, hl 
22b1 73				ld (hl), e 
22b2 eb				ex de, hl 
22b3			 
22b3				 
22b3			 
22b3				; copy  
22b3 4d				ld c, l 
22b4 06 00			ld b, 0 
22b6 ed 5b fa e2		ld de, (os_new_work_ptr)   ; get dest for copy of word 
22ba 2a 03 e6			ld hl, (os_tok_ptr) 
22bd 23				inc hl 
22be 23				inc hl    ; position to start of dict word 
22bf				 
22bf			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
22bf				 
22bf				; TODO need to convert word to upper case 
22bf			 
22bf			ucasetok:	 
22bf 7e				ld a,(hl) 
22c0 cd fc 11			call toUpper 
22c3 77				ld (hl),a 
22c4 ed a0			ldi 
22c6 f2 bf 22		 	jp p, ucasetok 
22c9			 
22c9			 
22c9			 
22c9				; de now points to start of where the word body code should be placed 
22c9 ed 53 fa e2		ld (os_new_work_ptr), de 
22cd				; hl now points to the words to throw at forthexec which needs to be copied 
22cd 22 f8 e2			ld (os_new_src_ptr), hl 
22d0			 
22d0				; TODO add 'call to forthexec' 
22d0			 
22d0			if DEBUG_FORTH_UWORD 
22d0 c5				push bc 
22d1 ed 4b 00 e3		ld bc, (os_new_malloc) 
22d5						DMARK ":0x" 
22d5 f5				push af  
22d6 3a ea 22			ld a, (.dmark)  
22d9 32 71 ee			ld (debug_mark),a  
22dc 3a eb 22			ld a, (.dmark+1)  
22df 32 72 ee			ld (debug_mark+1),a  
22e2 3a ec 22			ld a, (.dmark+2)  
22e5 32 73 ee			ld (debug_mark+2),a  
22e8 18 03			jr .pastdmark  
22ea ..			.dmark: db ":0x"  
22ed f1			.pastdmark: pop af  
22ee			endm  
# End of macro DMARK
22ee				CALLMONITOR 
22ee cd a8 15			call break_point_state  
22f1				endm  
# End of macro CALLMONITOR
22f1 c1				pop bc 
22f2			endif 
22f2			 
22f2			 
22f2				; create word preamble which should be: 
22f2			 
22f2			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
22f2			 
22f2				;    ld hl, <word code> 
22f2				;    jp user_exec 
22f2			        ;    <word code bytes> 
22f2			 
22f2			 
22f2			;	inc de     ; TODO ??? or are we already past the word's null 
22f2 eb				ex de, hl 
22f3			 
22f3 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
22f5			 
22f5 23				inc hl 
22f6 22 f4 e2			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
22f9 23				inc hl 
22fa			 
22fa 23				inc hl 
22fb 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
22fd			 
22fd 01 1c 47			ld bc, user_exec 
2300 23				inc hl 
2301 71				ld (hl), c     ; poke address of user_exec 
2302 23				inc hl 
2303 70				ld (hl), b     
2304			 ; 
2304			;	inc hl 
2304			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2304			; 
2304			; 
2304			;	ld bc, macro_forth_rsp_next 
2304			;	inc hl 
2304			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
2304			;	inc hl 
2304			;	ld (hl), b     
2304			 ; 
2304			;	inc hl 
2304			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2304			; 
2304			; 
2304			;	inc hl 
2304			;	ld bc, forthexec 
2304			;	ld (hl), c     ; poke address of forthexec 
2304			;	inc hl 
2304			;	ld (hl), b      
2304			; 
2304			;	inc hl 
2304			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
2304			; 
2304			;	ld bc, user_dict_next 
2304			;	inc hl 
2304			;	ld (hl), c     ; poke address of forthexec 
2304			;	inc hl 
2304			;	ld (hl), b      
2304			 
2304				; hl is now where we need to copy the word byte data to save this 
2304			 
2304 23				inc hl 
2305 22 f6 e2			ld (os_new_exec), hl 
2308				 
2308				; copy definition 
2308			 
2308 eb				ex de, hl 
2309			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
2309			;	inc de    ; skip the PC for this parse 
2309 3a fe e2			ld a, (os_new_parse_len) 
230c 4f				ld c, a 
230d 06 00			ld b, 0 
230f ed b0			ldir		 ; copy defintion 
2311			 
2311			 
2311				; poke the address of where the new word bytes live for forthexec 
2311			 
2311 2a f4 e2			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
2314			 
2314 ed 5b f6 e2		ld de, (os_new_exec)      
2318				 
2318 73				ld (hl), e 
2319 23				inc hl 
231a 72				ld (hl), d 
231b			 
231b					; TODO copy last user dict word next link to this word 
231b					; TODO update last user dict word to point to this word 
231b			; 
231b			; hl f923 de 812a ; bc 811a 
231b			 
231b			if DEBUG_FORTH_UWORD 
231b c5				push bc 
231c ed 4b 00 e3		ld bc, (os_new_malloc) 
2320						DMARK ":0A" 
2320 f5				push af  
2321 3a 35 23			ld a, (.dmark)  
2324 32 71 ee			ld (debug_mark),a  
2327 3a 36 23			ld a, (.dmark+1)  
232a 32 72 ee			ld (debug_mark+1),a  
232d 3a 37 23			ld a, (.dmark+2)  
2330 32 73 ee			ld (debug_mark+2),a  
2333 18 03			jr .pastdmark  
2335 ..			.dmark: db ":0A"  
2338 f1			.pastdmark: pop af  
2339			endm  
# End of macro DMARK
2339				CALLMONITOR 
2339 cd a8 15			call break_point_state  
233c				endm  
# End of macro CALLMONITOR
233c c1				pop bc 
233d			endif 
233d			if DEBUG_FORTH_UWORD 
233d c5				push bc 
233e ed 4b 00 e3		ld bc, (os_new_malloc) 
2342 03				inc bc 
2343 03				inc bc 
2344 03				inc bc 
2345 03				inc bc 
2346 03				inc bc 
2347 03				inc bc 
2348 03				inc bc 
2349 03				inc bc 
234a			 
234a						DMARK ":0B" 
234a f5				push af  
234b 3a 5f 23			ld a, (.dmark)  
234e 32 71 ee			ld (debug_mark),a  
2351 3a 60 23			ld a, (.dmark+1)  
2354 32 72 ee			ld (debug_mark+1),a  
2357 3a 61 23			ld a, (.dmark+2)  
235a 32 73 ee			ld (debug_mark+2),a  
235d 18 03			jr .pastdmark  
235f ..			.dmark: db ":0B"  
2362 f1			.pastdmark: pop af  
2363			endm  
# End of macro DMARK
2363				CALLMONITOR 
2363 cd a8 15			call break_point_state  
2366				endm  
# End of macro CALLMONITOR
2366 c1				pop bc 
2367			endif 
2367			 
2367			; update word dict linked list for new word 
2367			 
2367			 
2367 2a ff e5		ld hl, (os_last_new_uword)		; get the start of the last added uword 
236a 23			inc hl     ; move to next work linked list ptr 
236b			 
236b ed 5b 00 e3	ld de, (os_new_malloc)		 ; new next word 
236f 73			ld (hl), e 
2370 23			inc hl 
2371 72			ld (hl), d 
2372			 
2372			if DEBUG_FORTH_UWORD 
2372 ed 4b ff e5		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
2376			endif 
2376			 
2376 ed 53 ff e5	ld (os_last_new_uword), de      ; update last new uword ptr 
237a			 
237a			 
237a			if DEBUG_FORTH_UWORD 
237a						DMARK ":0+" 
237a f5				push af  
237b 3a 8f 23			ld a, (.dmark)  
237e 32 71 ee			ld (debug_mark),a  
2381 3a 90 23			ld a, (.dmark+1)  
2384 32 72 ee			ld (debug_mark+1),a  
2387 3a 91 23			ld a, (.dmark+2)  
238a 32 73 ee			ld (debug_mark+2),a  
238d 18 03			jr .pastdmark  
238f ..			.dmark: db ":0+"  
2392 f1			.pastdmark: pop af  
2393			endm  
# End of macro DMARK
2393				CALLMONITOR 
2393 cd a8 15			call break_point_state  
2396				endm  
# End of macro CALLMONITOR
2396			endif 
2396			 
2396				STACKFRAMECHK OFF $8efe $989f 
2396				if DEBUG_STACK_IMB 
2396					if OFF 
2396						exx 
2396						ld hl, $989f 
2396						pop de   ; $989f 
2396						call cmp16 
2396						jr nz, .spnosame 
2396						ld hl, $8efe 
2396						pop de   ; $8efe 
2396						call cmp16 
2396						jr z, .spfrsame 
2396						.spnosame: call showsperror 
2396						.spfrsame: nop 
2396						exx 
2396					endif 
2396				endif 
2396			endm 
# End of macro STACKFRAMECHK
2396			 
2396 c9			ret    ; dont process any remaining parser tokens as they form new word 
2397			 
2397			 
2397			 
2397			 
2397			;		NEXT 
2397			.SCOLN: 
2397			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
2397 06				db OPCODE_SCOLN 
2398 e3 23			dw .DROP 
239a 02				db 2 
239b .. 00			db ";",0           
239d			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
239d					if DEBUG_FORTH_WORDS_KEY 
239d						DMARK "SCN" 
239d f5				push af  
239e 3a b2 23			ld a, (.dmark)  
23a1 32 71 ee			ld (debug_mark),a  
23a4 3a b3 23			ld a, (.dmark+1)  
23a7 32 72 ee			ld (debug_mark+1),a  
23aa 3a b4 23			ld a, (.dmark+2)  
23ad 32 73 ee			ld (debug_mark+2),a  
23b0 18 03			jr .pastdmark  
23b2 ..			.dmark: db "SCN"  
23b5 f1			.pastdmark: pop af  
23b6			endm  
# End of macro DMARK
23b6						CALLMONITOR 
23b6 cd a8 15			call break_point_state  
23b9				endm  
# End of macro CALLMONITOR
23b9					endif 
23b9					FORTH_RSP_TOS 
23b9 cd d7 1b			call macro_forth_rsp_tos 
23bc				endm 
# End of macro FORTH_RSP_TOS
23bc e5					push hl 
23bd					FORTH_RSP_POP 
23bd cd e1 1b			call macro_forth_rsp_pop 
23c0				endm 
# End of macro FORTH_RSP_POP
23c0 e1					pop hl 
23c1			;		ex de,hl 
23c1 22 03 e6				ld (os_tok_ptr),hl 
23c4			 
23c4			if DEBUG_FORTH_UWORD 
23c4						DMARK "SCL" 
23c4 f5				push af  
23c5 3a d9 23			ld a, (.dmark)  
23c8 32 71 ee			ld (debug_mark),a  
23cb 3a da 23			ld a, (.dmark+1)  
23ce 32 72 ee			ld (debug_mark+1),a  
23d1 3a db 23			ld a, (.dmark+2)  
23d4 32 73 ee			ld (debug_mark+2),a  
23d7 18 03			jr .pastdmark  
23d9 ..			.dmark: db "SCL"  
23dc f1			.pastdmark: pop af  
23dd			endm  
# End of macro DMARK
23dd				CALLMONITOR 
23dd cd a8 15			call break_point_state  
23e0				endm  
# End of macro CALLMONITOR
23e0			endif 
23e0					NEXTW 
23e0 c3 87 1f			jp macro_next 
23e3				endm 
# End of macro NEXTW
23e3			 
23e3			.DROP: 
23e3				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
23e3 1b				db WORD_SYS_CORE+OPCODE_DROP             
23e4 0e 24			dw .DUP2            
23e6 05				db 4 + 1 
23e7 .. 00			db "DROP",0              
23ec				endm 
# End of macro CWHEAD
23ec			; | DROP ( w -- )   drop the TOS item   | DONE 
23ec					if DEBUG_FORTH_WORDS_KEY 
23ec						DMARK "DRP" 
23ec f5				push af  
23ed 3a 01 24			ld a, (.dmark)  
23f0 32 71 ee			ld (debug_mark),a  
23f3 3a 02 24			ld a, (.dmark+1)  
23f6 32 72 ee			ld (debug_mark+1),a  
23f9 3a 03 24			ld a, (.dmark+2)  
23fc 32 73 ee			ld (debug_mark+2),a  
23ff 18 03			jr .pastdmark  
2401 ..			.dmark: db "DRP"  
2404 f1			.pastdmark: pop af  
2405			endm  
# End of macro DMARK
2405						CALLMONITOR 
2405 cd a8 15			call break_point_state  
2408				endm  
# End of macro CALLMONITOR
2408					endif 
2408					FORTH_DSP_POP 
2408 cd c8 1e			call macro_forth_dsp_pop 
240b				endm 
# End of macro FORTH_DSP_POP
240b					NEXTW 
240b c3 87 1f			jp macro_next 
240e				endm 
# End of macro NEXTW
240e			.DUP2: 
240e				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
240e 1c				db WORD_SYS_CORE+OPCODE_DUP2             
240f 53 24			dw .DROP2            
2411 05				db 4 + 1 
2412 .. 00			db "2DUP",0              
2417				endm 
# End of macro CWHEAD
2417			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
2417					if DEBUG_FORTH_WORDS_KEY 
2417						DMARK "2DU" 
2417 f5				push af  
2418 3a 2c 24			ld a, (.dmark)  
241b 32 71 ee			ld (debug_mark),a  
241e 3a 2d 24			ld a, (.dmark+1)  
2421 32 72 ee			ld (debug_mark+1),a  
2424 3a 2e 24			ld a, (.dmark+2)  
2427 32 73 ee			ld (debug_mark+2),a  
242a 18 03			jr .pastdmark  
242c ..			.dmark: db "2DU"  
242f f1			.pastdmark: pop af  
2430			endm  
# End of macro DMARK
2430						CALLMONITOR 
2430 cd a8 15			call break_point_state  
2433				endm  
# End of macro CALLMONITOR
2433					endif 
2433					FORTH_DSP_VALUEHL 
2433 cd 10 1e			call macro_dsp_valuehl 
2436				endm 
# End of macro FORTH_DSP_VALUEHL
2436 e5					push hl      ; 2 
2437			 
2437					FORTH_DSP_POP 
2437 cd c8 1e			call macro_forth_dsp_pop 
243a				endm 
# End of macro FORTH_DSP_POP
243a					 
243a					FORTH_DSP_VALUEHL 
243a cd 10 1e			call macro_dsp_valuehl 
243d				endm 
# End of macro FORTH_DSP_VALUEHL
243d			;		push hl      ; 1 
243d			 
243d					FORTH_DSP_POP 
243d cd c8 1e			call macro_forth_dsp_pop 
2440				endm 
# End of macro FORTH_DSP_POP
2440			 
2440			;		pop hl       ; 1 
2440 d1					pop de       ; 2 
2441			 
2441 cd 19 1c				call forth_push_numhl 
2444 eb					ex de, hl 
2445 cd 19 1c				call forth_push_numhl 
2448			 
2448					 
2448 eb					ex de, hl 
2449			 
2449 cd 19 1c				call forth_push_numhl 
244c eb					ex de, hl 
244d cd 19 1c				call forth_push_numhl 
2450			 
2450			 
2450					NEXTW 
2450 c3 87 1f			jp macro_next 
2453				endm 
# End of macro NEXTW
2453			.DROP2: 
2453				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
2453 1d				db WORD_SYS_CORE+OPCODE_DROP2             
2454 82 24			dw .SWAP2            
2456 06				db 5 + 1 
2457 .. 00			db "2DROP",0              
245d				endm 
# End of macro CWHEAD
245d			; | 2DROP ( w w -- )    Double drop | DONE 
245d					if DEBUG_FORTH_WORDS_KEY 
245d						DMARK "2DR" 
245d f5				push af  
245e 3a 72 24			ld a, (.dmark)  
2461 32 71 ee			ld (debug_mark),a  
2464 3a 73 24			ld a, (.dmark+1)  
2467 32 72 ee			ld (debug_mark+1),a  
246a 3a 74 24			ld a, (.dmark+2)  
246d 32 73 ee			ld (debug_mark+2),a  
2470 18 03			jr .pastdmark  
2472 ..			.dmark: db "2DR"  
2475 f1			.pastdmark: pop af  
2476			endm  
# End of macro DMARK
2476						CALLMONITOR 
2476 cd a8 15			call break_point_state  
2479				endm  
# End of macro CALLMONITOR
2479					endif 
2479					FORTH_DSP_POP 
2479 cd c8 1e			call macro_forth_dsp_pop 
247c				endm 
# End of macro FORTH_DSP_POP
247c					FORTH_DSP_POP 
247c cd c8 1e			call macro_forth_dsp_pop 
247f				endm 
# End of macro FORTH_DSP_POP
247f					NEXTW 
247f c3 87 1f			jp macro_next 
2482				endm 
# End of macro NEXTW
2482			.SWAP2: 
2482				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
2482 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
2483 ab 24			dw .AT            
2485 06				db 5 + 1 
2486 .. 00			db "2SWAP",0              
248c				endm 
# End of macro CWHEAD
248c			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
248c					if DEBUG_FORTH_WORDS_KEY 
248c						DMARK "2SW" 
248c f5				push af  
248d 3a a1 24			ld a, (.dmark)  
2490 32 71 ee			ld (debug_mark),a  
2493 3a a2 24			ld a, (.dmark+1)  
2496 32 72 ee			ld (debug_mark+1),a  
2499 3a a3 24			ld a, (.dmark+2)  
249c 32 73 ee			ld (debug_mark+2),a  
249f 18 03			jr .pastdmark  
24a1 ..			.dmark: db "2SW"  
24a4 f1			.pastdmark: pop af  
24a5			endm  
# End of macro DMARK
24a5						CALLMONITOR 
24a5 cd a8 15			call break_point_state  
24a8				endm  
# End of macro CALLMONITOR
24a8					endif 
24a8					NEXTW 
24a8 c3 87 1f			jp macro_next 
24ab				endm 
# End of macro NEXTW
24ab			.AT: 
24ab				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
24ab 1f				db WORD_SYS_CORE+OPCODE_AT             
24ac dd 24			dw .CAT            
24ae 02				db 1 + 1 
24af .. 00			db "@",0              
24b1				endm 
# End of macro CWHEAD
24b1			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
24b1			 
24b1					if DEBUG_FORTH_WORDS_KEY 
24b1						DMARK "AT." 
24b1 f5				push af  
24b2 3a c6 24			ld a, (.dmark)  
24b5 32 71 ee			ld (debug_mark),a  
24b8 3a c7 24			ld a, (.dmark+1)  
24bb 32 72 ee			ld (debug_mark+1),a  
24be 3a c8 24			ld a, (.dmark+2)  
24c1 32 73 ee			ld (debug_mark+2),a  
24c4 18 03			jr .pastdmark  
24c6 ..			.dmark: db "AT."  
24c9 f1			.pastdmark: pop af  
24ca			endm  
# End of macro DMARK
24ca						CALLMONITOR 
24ca cd a8 15			call break_point_state  
24cd				endm  
# End of macro CALLMONITOR
24cd					endif 
24cd			.getbyteat:	 
24cd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
24cd cd 10 1e			call macro_dsp_valuehl 
24d0				endm 
# End of macro FORTH_DSP_VALUEHL
24d0					 
24d0			;		push hl 
24d0				 
24d0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
24d0 cd c8 1e			call macro_forth_dsp_pop 
24d3				endm 
# End of macro FORTH_DSP_POP
24d3			 
24d3			;		pop hl 
24d3			 
24d3 7e					ld a, (hl) 
24d4			 
24d4 6f					ld l, a 
24d5 26 00				ld h, 0 
24d7 cd 19 1c				call forth_push_numhl 
24da			 
24da					NEXTW 
24da c3 87 1f			jp macro_next 
24dd				endm 
# End of macro NEXTW
24dd			.CAT: 
24dd				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
24dd 20				db WORD_SYS_CORE+OPCODE_CAT             
24de 06 25			dw .BANG            
24e0 03				db 2 + 1 
24e1 .. 00			db "C@",0              
24e4				endm 
# End of macro CWHEAD
24e4			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
24e4					if DEBUG_FORTH_WORDS_KEY 
24e4						DMARK "CAA" 
24e4 f5				push af  
24e5 3a f9 24			ld a, (.dmark)  
24e8 32 71 ee			ld (debug_mark),a  
24eb 3a fa 24			ld a, (.dmark+1)  
24ee 32 72 ee			ld (debug_mark+1),a  
24f1 3a fb 24			ld a, (.dmark+2)  
24f4 32 73 ee			ld (debug_mark+2),a  
24f7 18 03			jr .pastdmark  
24f9 ..			.dmark: db "CAA"  
24fc f1			.pastdmark: pop af  
24fd			endm  
# End of macro DMARK
24fd						CALLMONITOR 
24fd cd a8 15			call break_point_state  
2500				endm  
# End of macro CALLMONITOR
2500					endif 
2500 c3 cd 24				jp .getbyteat 
2503					NEXTW 
2503 c3 87 1f			jp macro_next 
2506				endm 
# End of macro NEXTW
2506			.BANG: 
2506				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
2506 21				db WORD_SYS_CORE+OPCODE_BANG             
2507 3c 25			dw .CBANG            
2509 02				db 1 + 1 
250a .. 00			db "!",0              
250c				endm 
# End of macro CWHEAD
250c			; | ! ( x w -- ) Store x at address w      | DONE 
250c					if DEBUG_FORTH_WORDS_KEY 
250c						DMARK "BNG" 
250c f5				push af  
250d 3a 21 25			ld a, (.dmark)  
2510 32 71 ee			ld (debug_mark),a  
2513 3a 22 25			ld a, (.dmark+1)  
2516 32 72 ee			ld (debug_mark+1),a  
2519 3a 23 25			ld a, (.dmark+2)  
251c 32 73 ee			ld (debug_mark+2),a  
251f 18 03			jr .pastdmark  
2521 ..			.dmark: db "BNG"  
2524 f1			.pastdmark: pop af  
2525			endm  
# End of macro DMARK
2525						CALLMONITOR 
2525 cd a8 15			call break_point_state  
2528				endm  
# End of macro CALLMONITOR
2528					endif 
2528			 
2528			.storebyteat:		 
2528					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2528 cd 10 1e			call macro_dsp_valuehl 
252b				endm 
# End of macro FORTH_DSP_VALUEHL
252b					 
252b e5					push hl 
252c				 
252c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
252c cd c8 1e			call macro_forth_dsp_pop 
252f				endm 
# End of macro FORTH_DSP_POP
252f			 
252f					; get byte to poke 
252f			 
252f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
252f cd 10 1e			call macro_dsp_valuehl 
2532				endm 
# End of macro FORTH_DSP_VALUEHL
2532 e5					push hl 
2533			 
2533			 
2533					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2533 cd c8 1e			call macro_forth_dsp_pop 
2536				endm 
# End of macro FORTH_DSP_POP
2536			 
2536			 
2536 d1					pop de 
2537 e1					pop hl 
2538			 
2538 73					ld (hl),e 
2539			 
2539			 
2539					NEXTW 
2539 c3 87 1f			jp macro_next 
253c				endm 
# End of macro NEXTW
253c			.CBANG: 
253c				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
253c 22				db WORD_SYS_CORE+OPCODE_CBANG             
253d 65 25			dw .SCALL            
253f 03				db 2 + 1 
2540 .. 00			db "C!",0              
2543				endm 
# End of macro CWHEAD
2543			; | C!  ( x w -- ) Store x at address w  | DONE 
2543					if DEBUG_FORTH_WORDS_KEY 
2543						DMARK "CBA" 
2543 f5				push af  
2544 3a 58 25			ld a, (.dmark)  
2547 32 71 ee			ld (debug_mark),a  
254a 3a 59 25			ld a, (.dmark+1)  
254d 32 72 ee			ld (debug_mark+1),a  
2550 3a 5a 25			ld a, (.dmark+2)  
2553 32 73 ee			ld (debug_mark+2),a  
2556 18 03			jr .pastdmark  
2558 ..			.dmark: db "CBA"  
255b f1			.pastdmark: pop af  
255c			endm  
# End of macro DMARK
255c						CALLMONITOR 
255c cd a8 15			call break_point_state  
255f				endm  
# End of macro CALLMONITOR
255f					endif 
255f c3 28 25				jp .storebyteat 
2562					NEXTW 
2562 c3 87 1f			jp macro_next 
2565				endm 
# End of macro NEXTW
2565			.SCALL: 
2565				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
2565 23				db WORD_SYS_CORE+OPCODE_SCALL             
2566 99 25			dw .DEPTH            
2568 05				db 4 + 1 
2569 .. 00			db "CALL",0              
256e				endm 
# End of macro CWHEAD
256e			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
256e					if DEBUG_FORTH_WORDS_KEY 
256e						DMARK "CLL" 
256e f5				push af  
256f 3a 83 25			ld a, (.dmark)  
2572 32 71 ee			ld (debug_mark),a  
2575 3a 84 25			ld a, (.dmark+1)  
2578 32 72 ee			ld (debug_mark+1),a  
257b 3a 85 25			ld a, (.dmark+2)  
257e 32 73 ee			ld (debug_mark+2),a  
2581 18 03			jr .pastdmark  
2583 ..			.dmark: db "CLL"  
2586 f1			.pastdmark: pop af  
2587			endm  
# End of macro DMARK
2587						CALLMONITOR 
2587 cd a8 15			call break_point_state  
258a				endm  
# End of macro CALLMONITOR
258a					endif 
258a			 
258a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
258a cd 10 1e			call macro_dsp_valuehl 
258d				endm 
# End of macro FORTH_DSP_VALUEHL
258d			 
258d			;		push hl 
258d			 
258d					; destroy value TOS 
258d			 
258d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
258d cd c8 1e			call macro_forth_dsp_pop 
2590				endm 
# End of macro FORTH_DSP_POP
2590			 
2590						 
2590			;		pop hl 
2590			 
2590					; how to do a call with hl???? save SP? 
2590 cd 2b 1f				call forth_call_hl 
2593			 
2593			 
2593					; TODO push value back onto stack for another op etc 
2593			 
2593 cd 19 1c				call forth_push_numhl 
2596					NEXTW 
2596 c3 87 1f			jp macro_next 
2599				endm 
# End of macro NEXTW
2599			.DEPTH: 
2599				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2599 24				db WORD_SYS_CORE+OPCODE_DEPTH             
259a d6 25			dw .OVER            
259c 06				db 5 + 1 
259d .. 00			db "DEPTH",0              
25a3				endm 
# End of macro CWHEAD
25a3			; | DEPTH ( -- u ) Push count of stack | DONE 
25a3					; take current TOS and remove from base value div by two to get count 
25a3					if DEBUG_FORTH_WORDS_KEY 
25a3						DMARK "DEP" 
25a3 f5				push af  
25a4 3a b8 25			ld a, (.dmark)  
25a7 32 71 ee			ld (debug_mark),a  
25aa 3a b9 25			ld a, (.dmark+1)  
25ad 32 72 ee			ld (debug_mark+1),a  
25b0 3a ba 25			ld a, (.dmark+2)  
25b3 32 73 ee			ld (debug_mark+2),a  
25b6 18 03			jr .pastdmark  
25b8 ..			.dmark: db "DEP"  
25bb f1			.pastdmark: pop af  
25bc			endm  
# End of macro DMARK
25bc						CALLMONITOR 
25bc cd a8 15			call break_point_state  
25bf				endm  
# End of macro CALLMONITOR
25bf					endif 
25bf			 
25bf			 
25bf 2a 2f ea			ld hl, (cli_data_sp) 
25c2 11 69 e8			ld de, cli_data_stack 
25c5 ed 52			sbc hl,de 
25c7				 
25c7				; div by size of stack item 
25c7			 
25c7 5d				ld e,l 
25c8 0e 03			ld c, 3 
25ca cd 37 0d			call Div8 
25cd			 
25cd 6f				ld l,a 
25ce 26 00			ld h,0 
25d0			 
25d0				;srl h 
25d0				;rr l 
25d0			 
25d0 cd 19 1c				call forth_push_numhl 
25d3					NEXTW 
25d3 c3 87 1f			jp macro_next 
25d6				endm 
# End of macro NEXTW
25d6			.OVER: 
25d6				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
25d6 42				db WORD_SYS_CORE+46             
25d7 1d 26			dw .PAUSE            
25d9 05				db 4 + 1 
25da .. 00			db "OVER",0              
25df				endm 
# End of macro CWHEAD
25df			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
25df					if DEBUG_FORTH_WORDS_KEY 
25df						DMARK "OVR" 
25df f5				push af  
25e0 3a f4 25			ld a, (.dmark)  
25e3 32 71 ee			ld (debug_mark),a  
25e6 3a f5 25			ld a, (.dmark+1)  
25e9 32 72 ee			ld (debug_mark+1),a  
25ec 3a f6 25			ld a, (.dmark+2)  
25ef 32 73 ee			ld (debug_mark+2),a  
25f2 18 03			jr .pastdmark  
25f4 ..			.dmark: db "OVR"  
25f7 f1			.pastdmark: pop af  
25f8			endm  
# End of macro DMARK
25f8						CALLMONITOR 
25f8 cd a8 15			call break_point_state  
25fb				endm  
# End of macro CALLMONITOR
25fb					endif 
25fb			 
25fb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25fb cd 10 1e			call macro_dsp_valuehl 
25fe				endm 
# End of macro FORTH_DSP_VALUEHL
25fe e5					push hl    ; n2 
25ff					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25ff cd c8 1e			call macro_forth_dsp_pop 
2602				endm 
# End of macro FORTH_DSP_POP
2602			 
2602					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2602 cd 10 1e			call macro_dsp_valuehl 
2605				endm 
# End of macro FORTH_DSP_VALUEHL
2605 e5					push hl    ; n1 
2606					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2606 cd c8 1e			call macro_forth_dsp_pop 
2609				endm 
# End of macro FORTH_DSP_POP
2609			 
2609 d1					pop de     ; n1 
260a e1					pop hl     ; n2 
260b			 
260b d5					push de 
260c e5					push hl 
260d d5					push de 
260e			 
260e					; push back  
260e			 
260e e1					pop hl 
260f cd 19 1c				call forth_push_numhl 
2612 e1					pop hl 
2613 cd 19 1c				call forth_push_numhl 
2616 e1					pop hl 
2617 cd 19 1c				call forth_push_numhl 
261a					NEXTW 
261a c3 87 1f			jp macro_next 
261d				endm 
# End of macro NEXTW
261d			 
261d			.PAUSE: 
261d				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
261d 43				db WORD_SYS_CORE+47             
261e 52 26			dw .PAUSES            
2620 08				db 7 + 1 
2621 .. 00			db "PAUSEMS",0              
2629				endm 
# End of macro CWHEAD
2629			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
2629					if DEBUG_FORTH_WORDS_KEY 
2629						DMARK "PMS" 
2629 f5				push af  
262a 3a 3e 26			ld a, (.dmark)  
262d 32 71 ee			ld (debug_mark),a  
2630 3a 3f 26			ld a, (.dmark+1)  
2633 32 72 ee			ld (debug_mark+1),a  
2636 3a 40 26			ld a, (.dmark+2)  
2639 32 73 ee			ld (debug_mark+2),a  
263c 18 03			jr .pastdmark  
263e ..			.dmark: db "PMS"  
2641 f1			.pastdmark: pop af  
2642			endm  
# End of macro DMARK
2642						CALLMONITOR 
2642 cd a8 15			call break_point_state  
2645				endm  
# End of macro CALLMONITOR
2645					endif 
2645					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2645 cd 10 1e			call macro_dsp_valuehl 
2648				endm 
# End of macro FORTH_DSP_VALUEHL
2648			;		push hl    ; n2 
2648					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2648 cd c8 1e			call macro_forth_dsp_pop 
264b				endm 
# End of macro FORTH_DSP_POP
264b			;		pop hl 
264b			 
264b 7d					ld a, l 
264c cd d1 0a				call aDelayInMS 
264f				       NEXTW 
264f c3 87 1f			jp macro_next 
2652				endm 
# End of macro NEXTW
2652			.PAUSES:  
2652				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
2652 44				db WORD_SYS_CORE+48             
2653 c1 26			dw .ROT            
2655 06				db 5 + 1 
2656 .. 00			db "PAUSE",0              
265c				endm 
# End of macro CWHEAD
265c			; | PAUSE ( n -- )  Pause for n seconds | DONE 
265c					if DEBUG_FORTH_WORDS_KEY 
265c						DMARK "PAU" 
265c f5				push af  
265d 3a 71 26			ld a, (.dmark)  
2660 32 71 ee			ld (debug_mark),a  
2663 3a 72 26			ld a, (.dmark+1)  
2666 32 72 ee			ld (debug_mark+1),a  
2669 3a 73 26			ld a, (.dmark+2)  
266c 32 73 ee			ld (debug_mark+2),a  
266f 18 03			jr .pastdmark  
2671 ..			.dmark: db "PAU"  
2674 f1			.pastdmark: pop af  
2675			endm  
# End of macro DMARK
2675						CALLMONITOR 
2675 cd a8 15			call break_point_state  
2678				endm  
# End of macro CALLMONITOR
2678					endif 
2678					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2678 cd 10 1e			call macro_dsp_valuehl 
267b				endm 
# End of macro FORTH_DSP_VALUEHL
267b			;		push hl    ; n2 
267b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
267b cd c8 1e			call macro_forth_dsp_pop 
267e				endm 
# End of macro FORTH_DSP_POP
267e			;		pop hl 
267e 45					ld b, l 
267f					if DEBUG_FORTH_WORDS 
267f						DMARK "PAU" 
267f f5				push af  
2680 3a 94 26			ld a, (.dmark)  
2683 32 71 ee			ld (debug_mark),a  
2686 3a 95 26			ld a, (.dmark+1)  
2689 32 72 ee			ld (debug_mark+1),a  
268c 3a 96 26			ld a, (.dmark+2)  
268f 32 73 ee			ld (debug_mark+2),a  
2692 18 03			jr .pastdmark  
2694 ..			.dmark: db "PAU"  
2697 f1			.pastdmark: pop af  
2698			endm  
# End of macro DMARK
2698						CALLMONITOR 
2698 cd a8 15			call break_point_state  
269b				endm  
# End of macro CALLMONITOR
269b					endif 
269b c5			.pauses1:	push bc 
269c cd ec 0a				call delay1s 
269f c1					pop bc 
26a0					if DEBUG_FORTH_WORDS 
26a0						DMARK "PA1" 
26a0 f5				push af  
26a1 3a b5 26			ld a, (.dmark)  
26a4 32 71 ee			ld (debug_mark),a  
26a7 3a b6 26			ld a, (.dmark+1)  
26aa 32 72 ee			ld (debug_mark+1),a  
26ad 3a b7 26			ld a, (.dmark+2)  
26b0 32 73 ee			ld (debug_mark+2),a  
26b3 18 03			jr .pastdmark  
26b5 ..			.dmark: db "PA1"  
26b8 f1			.pastdmark: pop af  
26b9			endm  
# End of macro DMARK
26b9						CALLMONITOR 
26b9 cd a8 15			call break_point_state  
26bc				endm  
# End of macro CALLMONITOR
26bc					endif 
26bc 10 dd				djnz .pauses1 
26be			 
26be				       NEXTW 
26be c3 87 1f			jp macro_next 
26c1				endm 
# End of macro NEXTW
26c1			.ROT: 
26c1				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
26c1 45				db WORD_SYS_CORE+49             
26c2 0f 27			dw .UWORDS            
26c4 04				db 3 + 1 
26c5 .. 00			db "ROT",0              
26c9				endm 
# End of macro CWHEAD
26c9			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
26c9					if DEBUG_FORTH_WORDS_KEY 
26c9						DMARK "ROT" 
26c9 f5				push af  
26ca 3a de 26			ld a, (.dmark)  
26cd 32 71 ee			ld (debug_mark),a  
26d0 3a df 26			ld a, (.dmark+1)  
26d3 32 72 ee			ld (debug_mark+1),a  
26d6 3a e0 26			ld a, (.dmark+2)  
26d9 32 73 ee			ld (debug_mark+2),a  
26dc 18 03			jr .pastdmark  
26de ..			.dmark: db "ROT"  
26e1 f1			.pastdmark: pop af  
26e2			endm  
# End of macro DMARK
26e2						CALLMONITOR 
26e2 cd a8 15			call break_point_state  
26e5				endm  
# End of macro CALLMONITOR
26e5					endif 
26e5			 
26e5					FORTH_DSP_VALUEHL 
26e5 cd 10 1e			call macro_dsp_valuehl 
26e8				endm 
# End of macro FORTH_DSP_VALUEHL
26e8 e5					push hl    ; u3  
26e9			 
26e9					FORTH_DSP_POP 
26e9 cd c8 1e			call macro_forth_dsp_pop 
26ec				endm 
# End of macro FORTH_DSP_POP
26ec			   
26ec					FORTH_DSP_VALUEHL 
26ec cd 10 1e			call macro_dsp_valuehl 
26ef				endm 
# End of macro FORTH_DSP_VALUEHL
26ef e5					push hl     ; u2 
26f0			 
26f0					FORTH_DSP_POP 
26f0 cd c8 1e			call macro_forth_dsp_pop 
26f3				endm 
# End of macro FORTH_DSP_POP
26f3			 
26f3					FORTH_DSP_VALUEHL 
26f3 cd 10 1e			call macro_dsp_valuehl 
26f6				endm 
# End of macro FORTH_DSP_VALUEHL
26f6 e5					push hl     ; u1 
26f7			 
26f7					FORTH_DSP_POP 
26f7 cd c8 1e			call macro_forth_dsp_pop 
26fa				endm 
# End of macro FORTH_DSP_POP
26fa			 
26fa c1					pop bc      ; u1 
26fb e1					pop hl      ; u2 
26fc d1					pop de      ; u3 
26fd			 
26fd			 
26fd c5					push bc 
26fe d5					push de 
26ff e5					push hl 
2700			 
2700			 
2700 e1					pop hl 
2701 cd 19 1c				call forth_push_numhl 
2704			 
2704 e1					pop hl 
2705 cd 19 1c				call forth_push_numhl 
2708			 
2708 e1					pop hl 
2709 cd 19 1c				call forth_push_numhl 
270c					 
270c			 
270c			 
270c			 
270c			 
270c			 
270c				       NEXTW 
270c c3 87 1f			jp macro_next 
270f				endm 
# End of macro NEXTW
270f			 
270f			.UWORDS: 
270f				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
270f 50				db WORD_SYS_CORE+60             
2710 d1 27			dw .BP            
2712 07				db 6 + 1 
2713 .. 00			db "UWORDS",0              
271a				endm 
# End of macro CWHEAD
271a			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
271a			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
271a			; | | Following the count are the individual words. 
271a			; | | 
271a			; | | e.g. UWORDS 
271a			; | | BOX DIRLIST 2 
271a			; | |  
271a			; | | Can be used to save the words to storage via: 
271a			; | | UWORDS $01 DO $01 APPEND LOOP 
271a				if DEBUG_FORTH_WORDS_KEY 
271a					DMARK "UWR" 
271a f5				push af  
271b 3a 2f 27			ld a, (.dmark)  
271e 32 71 ee			ld (debug_mark),a  
2721 3a 30 27			ld a, (.dmark+1)  
2724 32 72 ee			ld (debug_mark+1),a  
2727 3a 31 27			ld a, (.dmark+2)  
272a 32 73 ee			ld (debug_mark+2),a  
272d 18 03			jr .pastdmark  
272f ..			.dmark: db "UWR"  
2732 f1			.pastdmark: pop af  
2733			endm  
# End of macro DMARK
2733					CALLMONITOR 
2733 cd a8 15			call break_point_state  
2736				endm  
# End of macro CALLMONITOR
2736				endif 
2736 21 09 5c				ld hl, baseram 
2739					;ld hl, baseusermem 
2739 01 00 00				ld bc, 0    ; start a counter 
273c			 
273c				; skip dict stub 
273c			 
273c cd d8 20				call forth_tok_next 
273f			 
273f			 
273f			; while we have words to look for 
273f			 
273f 7e			.douscan:	ld a, (hl)      
2740				if DEBUG_FORTH_WORDS 
2740					DMARK "UWs" 
2740 f5				push af  
2741 3a 55 27			ld a, (.dmark)  
2744 32 71 ee			ld (debug_mark),a  
2747 3a 56 27			ld a, (.dmark+1)  
274a 32 72 ee			ld (debug_mark+1),a  
274d 3a 57 27			ld a, (.dmark+2)  
2750 32 73 ee			ld (debug_mark+2),a  
2753 18 03			jr .pastdmark  
2755 ..			.dmark: db "UWs"  
2758 f1			.pastdmark: pop af  
2759			endm  
# End of macro DMARK
2759					CALLMONITOR 
2759 cd a8 15			call break_point_state  
275c				endm  
# End of macro CALLMONITOR
275c				endif 
275c fe 00				cp WORD_SYS_END 
275e 28 4d				jr z, .udone 
2760 fe 01				cp WORD_SYS_UWORD 
2762 20 44				jr nz, .nuword 
2764			 
2764				if DEBUG_FORTH_WORDS 
2764					DMARK "UWu" 
2764 f5				push af  
2765 3a 79 27			ld a, (.dmark)  
2768 32 71 ee			ld (debug_mark),a  
276b 3a 7a 27			ld a, (.dmark+1)  
276e 32 72 ee			ld (debug_mark+1),a  
2771 3a 7b 27			ld a, (.dmark+2)  
2774 32 73 ee			ld (debug_mark+2),a  
2777 18 03			jr .pastdmark  
2779 ..			.dmark: db "UWu"  
277c f1			.pastdmark: pop af  
277d			endm  
# End of macro DMARK
277d					CALLMONITOR 
277d cd a8 15			call break_point_state  
2780				endm  
# End of macro CALLMONITOR
2780				endif 
2780					; we have a uword so push its name to the stack 
2780			 
2780 e5				   	push hl  ; save so we can move to next dict block 
2781			 
2781					; skip opcode 
2781 23					inc hl  
2782					; skip next ptr 
2782 23					inc hl  
2783 23					inc hl 
2784					; skip len 
2784 23					inc hl 
2785				if DEBUG_FORTH_WORDS 
2785					DMARK "UWt" 
2785 f5				push af  
2786 3a 9a 27			ld a, (.dmark)  
2789 32 71 ee			ld (debug_mark),a  
278c 3a 9b 27			ld a, (.dmark+1)  
278f 32 72 ee			ld (debug_mark+1),a  
2792 3a 9c 27			ld a, (.dmark+2)  
2795 32 73 ee			ld (debug_mark+2),a  
2798 18 03			jr .pastdmark  
279a ..			.dmark: db "UWt"  
279d f1			.pastdmark: pop af  
279e			endm  
# End of macro DMARK
279e					CALLMONITOR 
279e cd a8 15			call break_point_state  
27a1				endm  
# End of macro CALLMONITOR
27a1				endif 
27a1 03					inc bc 
27a2			 
27a2 c5					push bc 
27a3 cd 87 1c				call forth_push_str 
27a6 c1					pop bc 
27a7			 
27a7 e1					pop hl 	 
27a8			 
27a8 cd d8 20		.nuword:	call forth_tok_next 
27ab 18 92				jr .douscan  
27ad			 
27ad			.udone:		 ; push count of uwords found 
27ad c5					push bc 
27ae e1					pop hl 
27af			 
27af				if DEBUG_FORTH_WORDS 
27af					DMARK "UWc" 
27af f5				push af  
27b0 3a c4 27			ld a, (.dmark)  
27b3 32 71 ee			ld (debug_mark),a  
27b6 3a c5 27			ld a, (.dmark+1)  
27b9 32 72 ee			ld (debug_mark+1),a  
27bc 3a c6 27			ld a, (.dmark+2)  
27bf 32 73 ee			ld (debug_mark+2),a  
27c2 18 03			jr .pastdmark  
27c4 ..			.dmark: db "UWc"  
27c7 f1			.pastdmark: pop af  
27c8			endm  
# End of macro DMARK
27c8					CALLMONITOR 
27c8 cd a8 15			call break_point_state  
27cb				endm  
# End of macro CALLMONITOR
27cb				endif 
27cb cd 19 1c				call forth_push_numhl 
27ce			 
27ce			 
27ce				       NEXTW 
27ce c3 87 1f			jp macro_next 
27d1				endm 
# End of macro NEXTW
27d1			 
27d1			.BP: 
27d1				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
27d1 54				db WORD_SYS_CORE+64             
27d2 07 28			dw .MONITOR            
27d4 03				db 2 + 1 
27d5 .. 00			db "BP",0              
27d8				endm 
# End of macro CWHEAD
27d8			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
27d8			; | | $00 Will enable the break points within specific code paths 
27d8			; | | $01 Will disable break points 
27d8			; | |  
27d8			; | | By default break points are off. Either the above can be used to enable them 
27d8			; | | or if a key is held down during start up the spashscreen will appear to freeze 
27d8			; | | and on release of the pressed key a message will be disaplayed to notify 
27d8			; | | that break points are enabled. Pressing any key will then continue boot process. 
27d8					; get byte count 
27d8					if DEBUG_FORTH_WORDS_KEY 
27d8						DMARK "BP." 
27d8 f5				push af  
27d9 3a ed 27			ld a, (.dmark)  
27dc 32 71 ee			ld (debug_mark),a  
27df 3a ee 27			ld a, (.dmark+1)  
27e2 32 72 ee			ld (debug_mark+1),a  
27e5 3a ef 27			ld a, (.dmark+2)  
27e8 32 73 ee			ld (debug_mark+2),a  
27eb 18 03			jr .pastdmark  
27ed ..			.dmark: db "BP."  
27f0 f1			.pastdmark: pop af  
27f1			endm  
# End of macro DMARK
27f1						CALLMONITOR 
27f1 cd a8 15			call break_point_state  
27f4				endm  
# End of macro CALLMONITOR
27f4					endif 
27f4			 
27f4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
27f4 cd 10 1e			call macro_dsp_valuehl 
27f7				endm 
# End of macro FORTH_DSP_VALUEHL
27f7			 
27f7			;		push hl 
27f7			 
27f7					; destroy value TOS 
27f7			 
27f7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
27f7 cd c8 1e			call macro_forth_dsp_pop 
27fa				endm 
# End of macro FORTH_DSP_POP
27fa			 
27fa			;		pop hl 
27fa			 
27fa 3e 00				ld a,0 
27fc bd					cp l 
27fd 28 02				jr z, .bpset 
27ff 3e 2a				ld a, '*' 
2801			 
2801 32 f3 e2		.bpset:		ld (os_view_disable), a 
2804			 
2804			 
2804					NEXTW 
2804 c3 87 1f			jp macro_next 
2807				endm 
# End of macro NEXTW
2807			 
2807			 
2807			.MONITOR: 
2807				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2807 55				db WORD_SYS_CORE+65             
2808 3a 28			dw .MALLOC            
280a 08				db 7 + 1 
280b .. 00			db "MONITOR",0              
2813				endm 
# End of macro CWHEAD
2813			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2813			; | | At start the current various registers will be displayed with contents. 
2813			; | | Top right corner will show the most recent debug marker seen. 
2813			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2813			; | | and the return stack pointer (RSP). 
2813			; | | Pressing: 
2813			; | |    1 - Initial screen 
2813			; | |    2 - Display a data dump of HL 
2813			; | |    3 - Display a data dump of DE 
2813			; | |    4 - Display a data dump of BC 
2813			; | |    5 - Display a data dump of HL 
2813			; | |    6 - Display a data dump of DSP 
2813			; | |    7 - Display a data dump of RSP 
2813			; | |    8 - Display a data dump of what is at DSP 
2813			; | |    9 - Display a data dump of what is at RSP 
2813			; | |    0 - Exit monitor and continue running. This will also enable break points 
2813			; | |    * - Disable break points 
2813			; | |    # - Enter traditional monitor mode 
2813			; | | 
2813			; | | Monitor Mode 
2813			; | | ------------ 
2813			; | | A prompt of '>' will be shown for various commands: 
2813			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2813			; | |    C - Continue display a data dump from the last set address 
2813			; | |    M xxxx - Set start of memory edit at address xx 
2813			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2813			; | |    Q - Return to previous 
2813					if DEBUG_FORTH_WORDS_KEY 
2813						DMARK "MON" 
2813 f5				push af  
2814 3a 28 28			ld a, (.dmark)  
2817 32 71 ee			ld (debug_mark),a  
281a 3a 29 28			ld a, (.dmark+1)  
281d 32 72 ee			ld (debug_mark+1),a  
2820 3a 2a 28			ld a, (.dmark+2)  
2823 32 73 ee			ld (debug_mark+2),a  
2826 18 03			jr .pastdmark  
2828 ..			.dmark: db "MON"  
282b f1			.pastdmark: pop af  
282c			endm  
# End of macro DMARK
282c						CALLMONITOR 
282c cd a8 15			call break_point_state  
282f				endm  
# End of macro CALLMONITOR
282f					endif 
282f 3e 00				ld a, 0 
2831 32 f3 e2				ld (os_view_disable), a 
2834			 
2834					CALLMONITOR 
2834 cd a8 15			call break_point_state  
2837				endm  
# End of macro CALLMONITOR
2837			 
2837			;	call monitor 
2837			 
2837					NEXTW 
2837 c3 87 1f			jp macro_next 
283a				endm 
# End of macro NEXTW
283a			 
283a			 
283a			.MALLOC: 
283a				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
283a 56				db WORD_SYS_CORE+66             
283b 63 28			dw .MALLOC2            
283d 06				db 5 + 1 
283e .. 00			db "ALLOT",0              
2844				endm 
# End of macro CWHEAD
2844			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2844					if DEBUG_FORTH_WORDS_KEY 
2844						DMARK "ALL" 
2844 f5				push af  
2845 3a 59 28			ld a, (.dmark)  
2848 32 71 ee			ld (debug_mark),a  
284b 3a 5a 28			ld a, (.dmark+1)  
284e 32 72 ee			ld (debug_mark+1),a  
2851 3a 5b 28			ld a, (.dmark+2)  
2854 32 73 ee			ld (debug_mark+2),a  
2857 18 03			jr .pastdmark  
2859 ..			.dmark: db "ALL"  
285c f1			.pastdmark: pop af  
285d			endm  
# End of macro DMARK
285d						CALLMONITOR 
285d cd a8 15			call break_point_state  
2860				endm  
# End of macro CALLMONITOR
2860					endif 
2860 c3 8a 28				jp .mallocc 
2863			.MALLOC2: 
2863				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2863 56				db WORD_SYS_CORE+66             
2864 a1 28			dw .FREE            
2866 07				db 6 + 1 
2867 .. 00			db "MALLOC",0              
286e				endm 
# End of macro CWHEAD
286e			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
286e					; get byte count 
286e					if DEBUG_FORTH_WORDS_KEY 
286e						DMARK "MAL" 
286e f5				push af  
286f 3a 83 28			ld a, (.dmark)  
2872 32 71 ee			ld (debug_mark),a  
2875 3a 84 28			ld a, (.dmark+1)  
2878 32 72 ee			ld (debug_mark+1),a  
287b 3a 85 28			ld a, (.dmark+2)  
287e 32 73 ee			ld (debug_mark+2),a  
2881 18 03			jr .pastdmark  
2883 ..			.dmark: db "MAL"  
2886 f1			.pastdmark: pop af  
2887			endm  
# End of macro DMARK
2887						CALLMONITOR 
2887 cd a8 15			call break_point_state  
288a				endm  
# End of macro CALLMONITOR
288a					endif 
288a			.mallocc: 
288a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
288a cd 10 1e			call macro_dsp_valuehl 
288d				endm 
# End of macro FORTH_DSP_VALUEHL
288d			 
288d			;		push hl 
288d			 
288d					; destroy value TOS 
288d			 
288d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
288d cd c8 1e			call macro_forth_dsp_pop 
2890				endm 
# End of macro FORTH_DSP_POP
2890			 
2890			;		pop hl 
2890 cd 6e 12				call malloc 
2893				if DEBUG_FORTH_MALLOC_GUARD 
2893 f5					push af 
2894 cd d0 0d				call ishlzero 
2897			;		ld a, l 
2897			;		add h 
2897			;		cp 0 
2897 f1					pop af 
2898					 
2898 cc ee 47				call z,malloc_error 
289b				endif 
289b			 
289b cd 19 1c				call forth_push_numhl 
289e					NEXTW 
289e c3 87 1f			jp macro_next 
28a1				endm 
# End of macro NEXTW
28a1			 
28a1			.FREE: 
28a1				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
28a1 57				db WORD_SYS_CORE+67             
28a2 d2 28			dw .LIST            
28a4 05				db 4 + 1 
28a5 .. 00			db "FREE",0              
28aa				endm 
# End of macro CWHEAD
28aa			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
28aa					if DEBUG_FORTH_WORDS_KEY 
28aa						DMARK "FRE" 
28aa f5				push af  
28ab 3a bf 28			ld a, (.dmark)  
28ae 32 71 ee			ld (debug_mark),a  
28b1 3a c0 28			ld a, (.dmark+1)  
28b4 32 72 ee			ld (debug_mark+1),a  
28b7 3a c1 28			ld a, (.dmark+2)  
28ba 32 73 ee			ld (debug_mark+2),a  
28bd 18 03			jr .pastdmark  
28bf ..			.dmark: db "FRE"  
28c2 f1			.pastdmark: pop af  
28c3			endm  
# End of macro DMARK
28c3						CALLMONITOR 
28c3 cd a8 15			call break_point_state  
28c6				endm  
# End of macro CALLMONITOR
28c6					endif 
28c6					; get address 
28c6			 
28c6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
28c6 cd 10 1e			call macro_dsp_valuehl 
28c9				endm 
# End of macro FORTH_DSP_VALUEHL
28c9			 
28c9			;		push hl 
28c9			 
28c9					; destroy value TOS 
28c9			 
28c9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
28c9 cd c8 1e			call macro_forth_dsp_pop 
28cc				endm 
# End of macro FORTH_DSP_POP
28cc			 
28cc			;		pop hl 
28cc			if FORTH_ENABLE_MALLOCFREE 
28cc cd 38 13				call free 
28cf			endif 
28cf					NEXTW 
28cf c3 87 1f			jp macro_next 
28d2				endm 
# End of macro NEXTW
28d2			.LIST: 
28d2				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
28d2 5c				db WORD_SYS_CORE+72             
28d3 c0 2a			dw .FORGET            
28d5 05				db 4 + 1 
28d6 .. 00			db "LIST",0              
28db				endm 
# End of macro CWHEAD
28db			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
28db			; | | The quoted word must be in upper case. 
28db				if DEBUG_FORTH_WORDS_KEY 
28db					DMARK "LST" 
28db f5				push af  
28dc 3a f0 28			ld a, (.dmark)  
28df 32 71 ee			ld (debug_mark),a  
28e2 3a f1 28			ld a, (.dmark+1)  
28e5 32 72 ee			ld (debug_mark+1),a  
28e8 3a f2 28			ld a, (.dmark+2)  
28eb 32 73 ee			ld (debug_mark+2),a  
28ee 18 03			jr .pastdmark  
28f0 ..			.dmark: db "LST"  
28f3 f1			.pastdmark: pop af  
28f4			endm  
# End of macro DMARK
28f4					CALLMONITOR 
28f4 cd a8 15			call break_point_state  
28f7				endm  
# End of macro CALLMONITOR
28f7				endif 
28f7			 
28f7					FORTH_DSP_VALUEHL 
28f7 cd 10 1e			call macro_dsp_valuehl 
28fa				endm 
# End of macro FORTH_DSP_VALUEHL
28fa			 
28fa e5					push hl 
28fb					FORTH_DSP_POP 
28fb cd c8 1e			call macro_forth_dsp_pop 
28fe				endm 
# End of macro FORTH_DSP_POP
28fe c1					pop bc 
28ff			 
28ff			; Start format of scratch string 
28ff			 
28ff 21 02 e3				ld hl, scratch 
2902			 
2902 3e 3a				ld a, ':' 
2904 77					ld (hl),a 
2905 23					inc hl 
2906 3e 20				ld a, ' ' 
2908 77					ld (hl), a 
2909			 
2909					; Get ptr to the word we need to look up 
2909			 
2909			;		FORTH_DSP_VALUEHL 
2909					;v5 FORTH_DSP_VALUE 
2909				; TODO type check 
2909			;		inc hl    ; Skip type check  
2909			;		push hl 
2909			;		ex de, hl    ; put into DE 
2909			 
2909			 
2909 21 09 5c				ld hl, baseram 
290c					;ld hl, baseusermem 
290c			 
290c e5			push hl   ; sacreifical push 
290d			 
290d			.ldouscanm: 
290d e1				pop hl 
290e			.ldouscan: 
290e				if DEBUG_FORTH_WORDS 
290e					DMARK "LSs" 
290e f5				push af  
290f 3a 23 29			ld a, (.dmark)  
2912 32 71 ee			ld (debug_mark),a  
2915 3a 24 29			ld a, (.dmark+1)  
2918 32 72 ee			ld (debug_mark+1),a  
291b 3a 25 29			ld a, (.dmark+2)  
291e 32 73 ee			ld (debug_mark+2),a  
2921 18 03			jr .pastdmark  
2923 ..			.dmark: db "LSs"  
2926 f1			.pastdmark: pop af  
2927			endm  
# End of macro DMARK
2927					CALLMONITOR 
2927 cd a8 15			call break_point_state  
292a				endm  
# End of macro CALLMONITOR
292a				endif 
292a				; skip dict stub 
292a cd d8 20				call forth_tok_next 
292d			 
292d			 
292d			; while we have words to look for 
292d			 
292d 7e				ld a, (hl)      
292e				if DEBUG_FORTH_WORDS 
292e					DMARK "LSk" 
292e f5				push af  
292f 3a 43 29			ld a, (.dmark)  
2932 32 71 ee			ld (debug_mark),a  
2935 3a 44 29			ld a, (.dmark+1)  
2938 32 72 ee			ld (debug_mark+1),a  
293b 3a 45 29			ld a, (.dmark+2)  
293e 32 73 ee			ld (debug_mark+2),a  
2941 18 03			jr .pastdmark  
2943 ..			.dmark: db "LSk"  
2946 f1			.pastdmark: pop af  
2947			endm  
# End of macro DMARK
2947					CALLMONITOR 
2947 cd a8 15			call break_point_state  
294a				endm  
# End of macro CALLMONITOR
294a				endif 
294a					;cp WORD_SYS_END 
294a					;jp z, .lunotfound 
294a			 
294a					; if we hit non uwords then gone too far 
294a fe 01				cp WORD_SYS_UWORD 
294c c2 7c 2a				jp nz, .lunotfound 
294f			 
294f				if DEBUG_FORTH_WORDS 
294f					DMARK "LSu" 
294f f5				push af  
2950 3a 64 29			ld a, (.dmark)  
2953 32 71 ee			ld (debug_mark),a  
2956 3a 65 29			ld a, (.dmark+1)  
2959 32 72 ee			ld (debug_mark+1),a  
295c 3a 66 29			ld a, (.dmark+2)  
295f 32 73 ee			ld (debug_mark+2),a  
2962 18 03			jr .pastdmark  
2964 ..			.dmark: db "LSu"  
2967 f1			.pastdmark: pop af  
2968			endm  
# End of macro DMARK
2968					CALLMONITOR 
2968 cd a8 15			call break_point_state  
296b				endm  
# End of macro CALLMONITOR
296b				endif 
296b			 
296b					; found a uword but is it the one we want... 
296b			 
296b c5					push bc     ; uword to find is on bc 
296c d1					pop de 
296d			 
296d e5					push hl  ; to save the ptr 
296e			 
296e					; skip opcode 
296e 23					inc hl  
296f					; skip next ptr 
296f 23					inc hl  
2970 23					inc hl 
2971					; skip len 
2971 23					inc hl 
2972			 
2972				if DEBUG_FORTH_WORDS 
2972					DMARK "LSc" 
2972 f5				push af  
2973 3a 87 29			ld a, (.dmark)  
2976 32 71 ee			ld (debug_mark),a  
2979 3a 88 29			ld a, (.dmark+1)  
297c 32 72 ee			ld (debug_mark+1),a  
297f 3a 89 29			ld a, (.dmark+2)  
2982 32 73 ee			ld (debug_mark+2),a  
2985 18 03			jr .pastdmark  
2987 ..			.dmark: db "LSc"  
298a f1			.pastdmark: pop af  
298b			endm  
# End of macro DMARK
298b					CALLMONITOR 
298b cd a8 15			call break_point_state  
298e				endm  
# End of macro CALLMONITOR
298e				endif 
298e cd 3d 12				call strcmp 
2991 c2 0d 29				jp nz, .ldouscanm 
2994				 
2994			 
2994			 
2994					; we have a uword so push its name to the stack 
2994			 
2994			;	   	push hl  ; save so we can move to next dict block 
2994 e1			pop hl 
2995			 
2995				if DEBUG_FORTH_WORDS 
2995					DMARK "LSm" 
2995 f5				push af  
2996 3a aa 29			ld a, (.dmark)  
2999 32 71 ee			ld (debug_mark),a  
299c 3a ab 29			ld a, (.dmark+1)  
299f 32 72 ee			ld (debug_mark+1),a  
29a2 3a ac 29			ld a, (.dmark+2)  
29a5 32 73 ee			ld (debug_mark+2),a  
29a8 18 03			jr .pastdmark  
29aa ..			.dmark: db "LSm"  
29ad f1			.pastdmark: pop af  
29ae			endm  
# End of macro DMARK
29ae					CALLMONITOR 
29ae cd a8 15			call break_point_state  
29b1				endm  
# End of macro CALLMONITOR
29b1				endif 
29b1			 
29b1					; skip opcode 
29b1 23					inc hl  
29b2					; skip next ptr 
29b2 23					inc hl  
29b3 23					inc hl 
29b4					; skip len 
29b4 7e					ld a, (hl)   ; save length to add 
29b5				if DEBUG_FORTH_WORDS 
29b5					DMARK "LS2" 
29b5 f5				push af  
29b6 3a ca 29			ld a, (.dmark)  
29b9 32 71 ee			ld (debug_mark),a  
29bc 3a cb 29			ld a, (.dmark+1)  
29bf 32 72 ee			ld (debug_mark+1),a  
29c2 3a cc 29			ld a, (.dmark+2)  
29c5 32 73 ee			ld (debug_mark+2),a  
29c8 18 03			jr .pastdmark  
29ca ..			.dmark: db "LS2"  
29cd f1			.pastdmark: pop af  
29ce			endm  
# End of macro DMARK
29ce					CALLMONITOR 
29ce cd a8 15			call break_point_state  
29d1				endm  
# End of macro CALLMONITOR
29d1				endif 
29d1			 
29d1					; save this location 
29d1				 
29d1 e5					push hl 
29d2			 
29d2 23					inc hl 
29d3 11 04 e3				ld de, scratch+2 
29d6 4f					ld c, a 
29d7 06 00				ld b, 0 
29d9			 
29d9				if DEBUG_FORTH_WORDS 
29d9					DMARK "LSn" 
29d9 f5				push af  
29da 3a ee 29			ld a, (.dmark)  
29dd 32 71 ee			ld (debug_mark),a  
29e0 3a ef 29			ld a, (.dmark+1)  
29e3 32 72 ee			ld (debug_mark+1),a  
29e6 3a f0 29			ld a, (.dmark+2)  
29e9 32 73 ee			ld (debug_mark+2),a  
29ec 18 03			jr .pastdmark  
29ee ..			.dmark: db "LSn"  
29f1 f1			.pastdmark: pop af  
29f2			endm  
# End of macro DMARK
29f2					CALLMONITOR 
29f2 cd a8 15			call break_point_state  
29f5				endm  
# End of macro CALLMONITOR
29f5				endif 
29f5			 
29f5					; copy uword name to scratch 
29f5			 
29f5 ed b0				ldir 
29f7			 
29f7 1b					dec de 
29f8 3e 20				ld a, ' '    ; change null to space 
29fa 12					ld (de), a 
29fb			 
29fb 13					inc de 
29fc			 
29fc d5					push de 
29fd c1					pop bc     ; move scratch pointer to end of word name and save it 
29fe			 
29fe e1					pop hl 
29ff 7e					ld a, (hl) 
2a00					;inc hl 
2a00					; skip word string 
2a00 cd a7 0d				call addatohl 
2a03			 
2a03 23					inc hl 
2a04			 
2a04				if DEBUG_FORTH_WORDS 
2a04					DMARK "LS3" 
2a04 f5				push af  
2a05 3a 19 2a			ld a, (.dmark)  
2a08 32 71 ee			ld (debug_mark),a  
2a0b 3a 1a 2a			ld a, (.dmark+1)  
2a0e 32 72 ee			ld (debug_mark+1),a  
2a11 3a 1b 2a			ld a, (.dmark+2)  
2a14 32 73 ee			ld (debug_mark+2),a  
2a17 18 03			jr .pastdmark  
2a19 ..			.dmark: db "LS3"  
2a1c f1			.pastdmark: pop af  
2a1d			endm  
# End of macro DMARK
2a1d					CALLMONITOR 
2a1d cd a8 15			call break_point_state  
2a20				endm  
# End of macro CALLMONITOR
2a20				endif 
2a20					; should now be at the start of the machine code to setup the eval of the uword 
2a20					; now locate the ptr to the string defintion 
2a20			 
2a20					; skip ld hl, 
2a20					; then load the ptr 
2a20			; TODO use get from hl ptr 
2a20 23					inc hl 
2a21 5e					ld e, (hl) 
2a22 23					inc hl 
2a23 56					ld d, (hl) 
2a24 eb					ex de, hl 
2a25			 
2a25			 
2a25				if DEBUG_FORTH_WORDS 
2a25					DMARK "LSt" 
2a25 f5				push af  
2a26 3a 3a 2a			ld a, (.dmark)  
2a29 32 71 ee			ld (debug_mark),a  
2a2c 3a 3b 2a			ld a, (.dmark+1)  
2a2f 32 72 ee			ld (debug_mark+1),a  
2a32 3a 3c 2a			ld a, (.dmark+2)  
2a35 32 73 ee			ld (debug_mark+2),a  
2a38 18 03			jr .pastdmark  
2a3a ..			.dmark: db "LSt"  
2a3d f1			.pastdmark: pop af  
2a3e			endm  
# End of macro DMARK
2a3e					CALLMONITOR 
2a3e cd a8 15			call break_point_state  
2a41				endm  
# End of macro CALLMONITOR
2a41				endif 
2a41			 
2a41			; cant push right now due to tokenised strings  
2a41			 
2a41			; get the destination of where to copy this definition to. 
2a41			 
2a41 c5					push bc 
2a42 d1					pop de 
2a43			 
2a43 7e			.listl:         ld a,(hl) 
2a44 fe 00				cp 0 
2a46 28 09				jr z, .lreplsp     ; replace zero with space 
2a48					;cp FORTH_END_BUFFER 
2a48 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2a4a 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2a4c				 
2a4c					; just copy this char as is then 
2a4c			 
2a4c 12					ld (de), a 
2a4d			 
2a4d 23			.listnxt:	inc hl 
2a4e 13					inc de 
2a4f 18 f2				jr .listl 
2a51			 
2a51 3e 20		.lreplsp:	ld a,' ' 
2a53 12					ld (de), a 
2a54 18 f7				jr .listnxt 
2a56			 
2a56			; close up uword def 
2a56			 
2a56			.listdone: 
2a56 12					ld (de), a 
2a57 13					inc de 
2a58 3e 00				ld a, 0 
2a5a 12					ld (de), a 
2a5b			 
2a5b			; now have def so clean up and push to stack 
2a5b			 
2a5b 21 02 e3				ld hl, scratch 
2a5e				if DEBUG_FORTH_WORDS 
2a5e					DMARK "Ltp" 
2a5e f5				push af  
2a5f 3a 73 2a			ld a, (.dmark)  
2a62 32 71 ee			ld (debug_mark),a  
2a65 3a 74 2a			ld a, (.dmark+1)  
2a68 32 72 ee			ld (debug_mark+1),a  
2a6b 3a 75 2a			ld a, (.dmark+2)  
2a6e 32 73 ee			ld (debug_mark+2),a  
2a71 18 03			jr .pastdmark  
2a73 ..			.dmark: db "Ltp"  
2a76 f1			.pastdmark: pop af  
2a77			endm  
# End of macro DMARK
2a77					CALLMONITOR 
2a77 cd a8 15			call break_point_state  
2a7a				endm  
# End of macro CALLMONITOR
2a7a				endif 
2a7a			 
2a7a 18 1f			jr .listpush 
2a7c			 
2a7c			;.lnuword:	pop hl 
2a7c			;		call forth_tok_next 
2a7c			;		jp .ldouscan  
2a7c			 
2a7c			.lunotfound:		  
2a7c			 
2a7c				if DEBUG_FORTH_WORDS 
2a7c					DMARK "LSn" 
2a7c f5				push af  
2a7d 3a 91 2a			ld a, (.dmark)  
2a80 32 71 ee			ld (debug_mark),a  
2a83 3a 92 2a			ld a, (.dmark+1)  
2a86 32 72 ee			ld (debug_mark+1),a  
2a89 3a 93 2a			ld a, (.dmark+2)  
2a8c 32 73 ee			ld (debug_mark+2),a  
2a8f 18 03			jr .pastdmark  
2a91 ..			.dmark: db "LSn"  
2a94 f1			.pastdmark: pop af  
2a95			endm  
# End of macro DMARK
2a95					CALLMONITOR 
2a95 cd a8 15			call break_point_state  
2a98				endm  
# End of macro CALLMONITOR
2a98				endif 
2a98			 
2a98					 
2a98			;		FORTH_DSP_POP 
2a98			;		ld hl, .luno 
2a98			 
2a98					NEXTW			 
2a98 c3 87 1f			jp macro_next 
2a9b				endm 
# End of macro NEXTW
2a9b			 
2a9b			.listpush: 
2a9b				if DEBUG_FORTH_WORDS 
2a9b					DMARK "LS>" 
2a9b f5				push af  
2a9c 3a b0 2a			ld a, (.dmark)  
2a9f 32 71 ee			ld (debug_mark),a  
2aa2 3a b1 2a			ld a, (.dmark+1)  
2aa5 32 72 ee			ld (debug_mark+1),a  
2aa8 3a b2 2a			ld a, (.dmark+2)  
2aab 32 73 ee			ld (debug_mark+2),a  
2aae 18 03			jr .pastdmark  
2ab0 ..			.dmark: db "LS>"  
2ab3 f1			.pastdmark: pop af  
2ab4			endm  
# End of macro DMARK
2ab4					CALLMONITOR 
2ab4 cd a8 15			call break_point_state  
2ab7				endm  
# End of macro CALLMONITOR
2ab7				endif 
2ab7 cd 87 1c				call forth_push_str 
2aba			 
2aba			 
2aba			 
2aba					NEXTW 
2aba c3 87 1f			jp macro_next 
2abd				endm 
# End of macro NEXTW
2abd			 
2abd			;.luno:    db "Word not found",0 
2abd			 
2abd			 
2abd			 
2abd			 
2abd			 
2abd			;		push hl   ; save pointer to start of uword def string 
2abd			; 
2abd			;; look for FORTH_EOL_LINE 
2abd			;		ld a, FORTH_END_BUFFER 
2abd			;		call strlent 
2abd			; 
2abd			;		inc hl		 ; space for coln def 
2abd			;		inc hl 
2abd			;		inc hl          ; space for terms 
2abd			;		inc hl 
2abd			; 
2abd			;		ld a, 20   ; TODO get actual length 
2abd			;		call addatohl    ; include a random amount of room for the uword name 
2abd			; 
2abd			;		 
2abd			;	if DEBUG_FORTH_WORDS 
2abd			;		DMARK "Lt1" 
2abd			;		CALLMONITOR 
2abd			;	endif 
2abd			;		 
2abd			; 
2abd			;; malloc space for the string because we cant change it 
2abd			; 
2abd			;		call malloc 
2abd			;	if DEBUG_FORTH_MALLOC_GUARD 
2abd			;		push af 
2abd			;		call ishlzero 
2abd			;		pop af 
2abd			;		 
2abd			;		call z,malloc_error 
2abd			;	endif 
2abd			; 
2abd			;	if DEBUG_FORTH_WORDS 
2abd			;		DMARK "Lt2" 
2abd			;		CALLMONITOR 
2abd			;	endif 
2abd			;		pop de 
2abd			;		push hl    ; push the malloc to release later 
2abd			;		push hl   ;  push back a copy for the later stack push 
2abd			;		 
2abd			;; copy the string swapping out the zero terms for spaces 
2abd			; 
2abd			;		; de has our source 
2abd			;		; hl has our dest 
2abd			; 
2abd			;; add the coln def 
2abd			; 
2abd			;		ld a, ':' 
2abd			;		ld (hl), a 
2abd			;		inc hl 
2abd			;		ld a, ' ' 
2abd			;		ld (hl), a 
2abd			;		inc hl 
2abd			; 
2abd			;; add the uname word 
2abd			;		push de   ; save our string for now 
2abd			;		ex de, hl 
2abd			; 
2abd			;		FORTH_DSP_VALUE 
2abd			;		;v5 FORTH_DSP_VALUE 
2abd			; 
2abd			;		inc hl   ; skip type but we know by now this is OK 
2abd			; 
2abd			;.luword:	ld a,(hl) 
2abd			;		cp 0 
2abd			;		jr z, .luword2 
2abd			;		ld (de), a 
2abd			;		inc de 
2abd			;		inc hl 
2abd			;		jr .luword 
2abd			; 
2abd			;.luword2:	ld a, ' ' 
2abd			;		ld (de), a 
2abd			;;		inc hl 
2abd			;;		inc de 
2abd			;;		ld (de), a 
2abd			;;		inc hl 
2abd			;		inc de 
2abd			; 
2abd			;		ex de, hl 
2abd			;		pop de 
2abd			;		 
2abd			;		 
2abd			; 
2abd			;; detoken that string and copy it 
2abd			; 
2abd			;	if DEBUG_FORTH_WORDS 
2abd			;		DMARK "Lt2" 
2abd			;		CALLMONITOR 
2abd			;	endif 
2abd			;.ldetok:	ld a, (de) 
2abd			;		cp FORTH_END_BUFFER 
2abd			;		jr z, .ldetokend 
2abd			;		; swap out any zero term for space 
2abd			;		cp 0 
2abd			;		jr nz, .ldetoknext 
2abd			;		ld a, ' ' 
2abd			; 
2abd			;	if DEBUG_FORTH_WORDS 
2abd			;		DMARK "LtS" 
2abd			;		CALLMONITOR 
2abd			;	endif 
2abd			;.ldetoknext:	ld (hl), a 
2abd			;		inc de 
2abd			;		inc hl 
2abd			;		jr .ldetok 
2abd			; 
2abd			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2abd			;		ld (hl), a  
2abd			; 
2abd			;; free that temp malloc 
2abd			; 
2abd			;		pop hl    
2abd			; 
2abd			;	if DEBUG_FORTH_WORDS 
2abd			;		DMARK "Lt4" 
2abd			;		CALLMONITOR 
2abd			;	endif 
2abd			;		call forth_apushstrhl 
2abd			; 
2abd			;		; get rid of temp malloc area 
2abd			; 
2abd			;		pop hl 
2abd			;		call free 
2abd			; 
2abd			;		jr .ludone 
2abd			; 
2abd			;.lnuword:	pop hl 
2abd			;		call forth_tok_next 
2abd			;		jp .ldouscan  
2abd			; 
2abd			;.ludone:		 pop hl 
2abd			; 
2abd					NEXTW 
2abd c3 87 1f			jp macro_next 
2ac0				endm 
# End of macro NEXTW
2ac0			 
2ac0			.FORGET: 
2ac0				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2ac0 5d				db WORD_SYS_CORE+73             
2ac1 39 2b			dw .NOP            
2ac3 07				db 6 + 1 
2ac4 .. 00			db "FORGET",0              
2acb				endm 
# End of macro CWHEAD
2acb			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2acb			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2acb			; | |  
2acb			; | | e.g. "MORE" forget 
2acb					if DEBUG_FORTH_WORDS_KEY 
2acb						DMARK "FRG" 
2acb f5				push af  
2acc 3a e0 2a			ld a, (.dmark)  
2acf 32 71 ee			ld (debug_mark),a  
2ad2 3a e1 2a			ld a, (.dmark+1)  
2ad5 32 72 ee			ld (debug_mark+1),a  
2ad8 3a e2 2a			ld a, (.dmark+2)  
2adb 32 73 ee			ld (debug_mark+2),a  
2ade 18 03			jr .pastdmark  
2ae0 ..			.dmark: db "FRG"  
2ae3 f1			.pastdmark: pop af  
2ae4			endm  
# End of macro DMARK
2ae4						CALLMONITOR 
2ae4 cd a8 15			call break_point_state  
2ae7				endm  
# End of macro CALLMONITOR
2ae7					endif 
2ae7			 
2ae7				; find uword 
2ae7			        ; update start of word with "_" 
2ae7				; replace uword with deleted flag 
2ae7			 
2ae7			 
2ae7			;	if DEBUG_FORTH_WORDS 
2ae7			;		DMARK "FOG" 
2ae7			;		CALLMONITOR 
2ae7			;	endif 
2ae7			 
2ae7			 
2ae7					; Get ptr to the word we need to look up 
2ae7			 
2ae7					FORTH_DSP_VALUEHL 
2ae7 cd 10 1e			call macro_dsp_valuehl 
2aea				endm 
# End of macro FORTH_DSP_VALUEHL
2aea					;v5 FORTH_DSP_VALUE 
2aea				; TODO type check 
2aea			;		inc hl    ; Skip type check  
2aea e5					push hl 
2aeb c1					pop bc 
2aec			;		ex de, hl    ; put into DE 
2aec			 
2aec			 
2aec 21 09 5c				ld hl, baseram 
2aef					;ld hl, baseusermem 
2aef			 
2aef				; skip dict stub 
2aef			;	call forth_tok_next 
2aef e5			push hl   ; sacreifical push 
2af0			 
2af0			.fldouscanm: 
2af0 e1				pop hl 
2af1			.fldouscan: 
2af1			;	if DEBUG_FORTH_WORDS 
2af1			;		DMARK "LSs" 
2af1			;		CALLMONITOR 
2af1			;	endif 
2af1				; skip dict stub 
2af1 cd d8 20				call forth_tok_next 
2af4			 
2af4			 
2af4			; while we have words to look for 
2af4			 
2af4 7e				ld a, (hl)      
2af5			;	if DEBUG_FORTH_WORDS 
2af5			;		DMARK "LSk" 
2af5			;		CALLMONITOR 
2af5			;	endif 
2af5 fe 00				cp WORD_SYS_END 
2af7 ca 33 2b				jp z, .flunotfound 
2afa fe 01				cp WORD_SYS_UWORD 
2afc c2 f1 2a				jp nz, .fldouscan 
2aff			 
2aff			;	if DEBUG_FORTH_WORDS 
2aff			;		DMARK "LSu" 
2aff			;		CALLMONITOR 
2aff			;	endif 
2aff			 
2aff					; found a uword but is it the one we want... 
2aff			 
2aff c5					push bc     ; uword to find is on bc 
2b00 d1					pop de 
2b01			 
2b01 e5					push hl  ; to save the ptr 
2b02			 
2b02					; skip opcode 
2b02 23					inc hl  
2b03					; skip next ptr 
2b03 23					inc hl  
2b04 23					inc hl 
2b05					; skip len 
2b05 23					inc hl 
2b06			 
2b06			;	if DEBUG_FORTH_WORDS 
2b06			;		DMARK "LSc" 
2b06			;		CALLMONITOR 
2b06			;	endif 
2b06 cd 3d 12				call strcmp 
2b09 c2 f0 2a				jp nz, .fldouscanm 
2b0c			; 
2b0c			; 
2b0c			;; while we have words to look for 
2b0c			; 
2b0c			;.fdouscan:	ld a, (hl)      
2b0c			;	if DEBUG_FORTH_WORDS 
2b0c			;		DMARK "LSs" 
2b0c			;		CALLMONITOR 
2b0c			;	endif 
2b0c			;		cp WORD_SYS_END 
2b0c			;		jp z, .fudone 
2b0c			;		cp WORD_SYS_UWORD 
2b0c			;		jp nz, .fnuword 
2b0c			; 
2b0c			;	if DEBUG_FORTH_WORDS 
2b0c			;		DMARK "FGu" 
2b0c			;		CALLMONITOR 
2b0c			;	endif 
2b0c			; 
2b0c			;		; found a uword but is it the one we want... 
2b0c			; 
2b0c			; 
2b0c			;	        pop de   ; get back the dsp name 
2b0c			;		push de 
2b0c			; 
2b0c			;		push hl  ; to save the ptr 
2b0c			; 
2b0c			;		; skip opcode 
2b0c			;		inc hl  
2b0c			;		; skip next ptr 
2b0c			;		inc hl  
2b0c			;		inc hl 
2b0c			;		; skip len 
2b0c			;		inc hl 
2b0c			; 
2b0c			;	if DEBUG_FORTH_WORDS 
2b0c			;		DMARK "FGc" 
2b0c			;		CALLMONITOR 
2b0c			;	endif 
2b0c			;		call strcmp 
2b0c			;		jp nz, .fnuword 
2b0c			 
2b0c			 
2b0c e1			pop hl 
2b0d			 
2b0d				 
2b0d				if DEBUG_FORTH_WORDS 
2b0d					DMARK "FGm" 
2b0d f5				push af  
2b0e 3a 22 2b			ld a, (.dmark)  
2b11 32 71 ee			ld (debug_mark),a  
2b14 3a 23 2b			ld a, (.dmark+1)  
2b17 32 72 ee			ld (debug_mark+1),a  
2b1a 3a 24 2b			ld a, (.dmark+2)  
2b1d 32 73 ee			ld (debug_mark+2),a  
2b20 18 03			jr .pastdmark  
2b22 ..			.dmark: db "FGm"  
2b25 f1			.pastdmark: pop af  
2b26			endm  
# End of macro DMARK
2b26					CALLMONITOR 
2b26 cd a8 15			call break_point_state  
2b29				endm  
# End of macro CALLMONITOR
2b29				endif 
2b29			 
2b29			 
2b29			 
2b29					; we have a uword so push its name to the stack 
2b29			 
2b29			;	   	push hl  ; save so we can move to next dict block 
2b29			;pop hl 
2b29			 
2b29					; update opcode to deleted 
2b29 3e 03				ld a, WORD_SYS_DELETED 
2b2b 77					ld (hl), a 
2b2c			 
2b2c 23					inc hl  
2b2d					; skip next ptr 
2b2d 23					inc hl  
2b2e 23					inc hl 
2b2f					; skip len 
2b2f 23					inc hl 
2b30			 
2b30					; TODO change parser to skip deleted words but for now mark it out 
2b30 3e 5f				ld a, "_" 
2b32 77					ld  (hl),a 
2b33			 
2b33			;		jr .fudone 
2b33			; 
2b33			;.fnuword:	pop hl 
2b33			;		call forth_tok_next 
2b33			;		jp .fdouscan  
2b33			 
2b33			.flunotfound:		  
2b33			 
2b33			 
2b33					 
2b33					FORTH_DSP_POP 
2b33 cd c8 1e			call macro_forth_dsp_pop 
2b36				endm 
# End of macro FORTH_DSP_POP
2b36			;		ld hl, .luno 
2b36			;.fudone:		 pop hl 
2b36					NEXTW 
2b36 c3 87 1f			jp macro_next 
2b39				endm 
# End of macro NEXTW
2b39			.NOP: 
2b39				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2b39 61				db WORD_SYS_CORE+77             
2b3a 60 2b			dw .COMO            
2b3c 04				db 3 + 1 
2b3d .. 00			db "NOP",0              
2b41				endm 
# End of macro CWHEAD
2b41			; | NOP (  --  ) Do nothing | DONE 
2b41					if DEBUG_FORTH_WORDS_KEY 
2b41						DMARK "NOP" 
2b41 f5				push af  
2b42 3a 56 2b			ld a, (.dmark)  
2b45 32 71 ee			ld (debug_mark),a  
2b48 3a 57 2b			ld a, (.dmark+1)  
2b4b 32 72 ee			ld (debug_mark+1),a  
2b4e 3a 58 2b			ld a, (.dmark+2)  
2b51 32 73 ee			ld (debug_mark+2),a  
2b54 18 03			jr .pastdmark  
2b56 ..			.dmark: db "NOP"  
2b59 f1			.pastdmark: pop af  
2b5a			endm  
# End of macro DMARK
2b5a						CALLMONITOR 
2b5a cd a8 15			call break_point_state  
2b5d				endm  
# End of macro CALLMONITOR
2b5d					endif 
2b5d				       NEXTW 
2b5d c3 87 1f			jp macro_next 
2b60				endm 
# End of macro NEXTW
2b60			.COMO: 
2b60				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2b60 6e				db WORD_SYS_CORE+90             
2b61 b2 2b			dw .COMC            
2b63 02				db 1 + 1 
2b64 .. 00			db "(",0              
2b66				endm 
# End of macro CWHEAD
2b66			; | ( ( -- )  Start of comment | DONE 
2b66			 
2b66			 
2b66 2a 03 e6				ld hl, ( os_tok_ptr) 
2b69 11 ad 2b			ld de, .closepar 
2b6c					 
2b6c					if DEBUG_FORTH_WORDS 
2b6c						DMARK ").." 
2b6c f5				push af  
2b6d 3a 81 2b			ld a, (.dmark)  
2b70 32 71 ee			ld (debug_mark),a  
2b73 3a 82 2b			ld a, (.dmark+1)  
2b76 32 72 ee			ld (debug_mark+1),a  
2b79 3a 83 2b			ld a, (.dmark+2)  
2b7c 32 73 ee			ld (debug_mark+2),a  
2b7f 18 03			jr .pastdmark  
2b81 ..			.dmark: db ").."  
2b84 f1			.pastdmark: pop af  
2b85			endm  
# End of macro DMARK
2b85						CALLMONITOR 
2b85 cd a8 15			call break_point_state  
2b88				endm  
# End of macro CALLMONITOR
2b88					endif 
2b88 cd a2 20			call findnexttok  
2b8b			 
2b8b					if DEBUG_FORTH_WORDS 
2b8b						DMARK "IF5" 
2b8b f5				push af  
2b8c 3a a0 2b			ld a, (.dmark)  
2b8f 32 71 ee			ld (debug_mark),a  
2b92 3a a1 2b			ld a, (.dmark+1)  
2b95 32 72 ee			ld (debug_mark+1),a  
2b98 3a a2 2b			ld a, (.dmark+2)  
2b9b 32 73 ee			ld (debug_mark+2),a  
2b9e 18 03			jr .pastdmark  
2ba0 ..			.dmark: db "IF5"  
2ba3 f1			.pastdmark: pop af  
2ba4			endm  
# End of macro DMARK
2ba4						CALLMONITOR 
2ba4 cd a8 15			call break_point_state  
2ba7				endm  
# End of macro CALLMONITOR
2ba7					endif 
2ba7				; replace below with ) exec using tok_ptr 
2ba7 22 03 e6			ld (os_tok_ptr), hl 
2baa c3 18 20			jp exec1 
2bad			 
2bad .. 00			.closepar:   db ")",0 
2baf			 
2baf				       NEXTW 
2baf c3 87 1f			jp macro_next 
2bb2				endm 
# End of macro NEXTW
2bb2			.COMC: 
2bb2				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2bb2 6f				db WORD_SYS_CORE+91             
2bb3 bb 2b			dw .SCRATCH            
2bb5 02				db 1 + 1 
2bb6 .. 00			db ")",0              
2bb8				endm 
# End of macro CWHEAD
2bb8			; | ) ( -- )  End of comment |  DONE  
2bb8				       NEXTW 
2bb8 c3 87 1f			jp macro_next 
2bbb				endm 
# End of macro NEXTW
2bbb			 
2bbb			.SCRATCH: 
2bbb				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2bbb 6f				db WORD_SYS_CORE+91             
2bbc f6 2b			dw .INC            
2bbe 08				db 7 + 1 
2bbf .. 00			db "SCRATCH",0              
2bc7				endm 
# End of macro CWHEAD
2bc7			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2bc7			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2bc7			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2bc7			; | |  
2bc7			; | | e.g.    : score $00 scratch ; 
2bc7			; | |  
2bc7			; | | $00 score ! 
2bc7			; | | $01 score +! 
2bc7			; | |  
2bc7			; | | e.g.   : varword $0a scratch ;  
2bc7			; | | 
2bc7			; | | $8000 varword ! 
2bc7					if DEBUG_FORTH_WORDS_KEY 
2bc7						DMARK "SCR" 
2bc7 f5				push af  
2bc8 3a dc 2b			ld a, (.dmark)  
2bcb 32 71 ee			ld (debug_mark),a  
2bce 3a dd 2b			ld a, (.dmark+1)  
2bd1 32 72 ee			ld (debug_mark+1),a  
2bd4 3a de 2b			ld a, (.dmark+2)  
2bd7 32 73 ee			ld (debug_mark+2),a  
2bda 18 03			jr .pastdmark  
2bdc ..			.dmark: db "SCR"  
2bdf f1			.pastdmark: pop af  
2be0			endm  
# End of macro DMARK
2be0						CALLMONITOR 
2be0 cd a8 15			call break_point_state  
2be3				endm  
# End of macro CALLMONITOR
2be3					endif 
2be3			 
2be3					FORTH_DSP_VALUEHL 
2be3 cd 10 1e			call macro_dsp_valuehl 
2be6				endm 
# End of macro FORTH_DSP_VALUEHL
2be6				 
2be6					FORTH_DSP_POP 
2be6 cd c8 1e			call macro_forth_dsp_pop 
2be9				endm 
# End of macro FORTH_DSP_POP
2be9			 
2be9 7d					ld a, l 
2bea 21 27 e8				ld hl, os_var_array 
2bed cd a7 0d				call addatohl 
2bf0			 
2bf0 cd 19 1c				call forth_push_numhl 
2bf3			 
2bf3				       NEXTW 
2bf3 c3 87 1f			jp macro_next 
2bf6				endm 
# End of macro NEXTW
2bf6			 
2bf6			.INC: 
2bf6				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2bf6 6f				db WORD_SYS_CORE+91             
2bf7 4a 2c			dw .DEC            
2bf9 03				db 2 + 1 
2bfa .. 00			db "+!",0              
2bfd				endm 
# End of macro CWHEAD
2bfd			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2bfd					if DEBUG_FORTH_WORDS_KEY 
2bfd						DMARK "+s_" 
2bfd f5				push af  
2bfe 3a 12 2c			ld a, (.dmark)  
2c01 32 71 ee			ld (debug_mark),a  
2c04 3a 13 2c			ld a, (.dmark+1)  
2c07 32 72 ee			ld (debug_mark+1),a  
2c0a 3a 14 2c			ld a, (.dmark+2)  
2c0d 32 73 ee			ld (debug_mark+2),a  
2c10 18 03			jr .pastdmark  
2c12 ..			.dmark: db "+s_"  
2c15 f1			.pastdmark: pop af  
2c16			endm  
# End of macro DMARK
2c16						CALLMONITOR 
2c16 cd a8 15			call break_point_state  
2c19				endm  
# End of macro CALLMONITOR
2c19					endif 
2c19			 
2c19					FORTH_DSP_VALUEHL 
2c19 cd 10 1e			call macro_dsp_valuehl 
2c1c				endm 
# End of macro FORTH_DSP_VALUEHL
2c1c			 
2c1c e5					push hl   ; save address 
2c1d			 
2c1d					FORTH_DSP_POP 
2c1d cd c8 1e			call macro_forth_dsp_pop 
2c20				endm 
# End of macro FORTH_DSP_POP
2c20			 
2c20					FORTH_DSP_VALUEHL 
2c20 cd 10 1e			call macro_dsp_valuehl 
2c23				endm 
# End of macro FORTH_DSP_VALUEHL
2c23			 
2c23					FORTH_DSP_POP 
2c23 cd c8 1e			call macro_forth_dsp_pop 
2c26				endm 
# End of macro FORTH_DSP_POP
2c26			 
2c26					; hl contains value to add to byte at a 
2c26				 
2c26 eb					ex de, hl 
2c27			 
2c27 e1					pop hl 
2c28			 
2c28					if DEBUG_FORTH_WORDS 
2c28						DMARK "INC" 
2c28 f5				push af  
2c29 3a 3d 2c			ld a, (.dmark)  
2c2c 32 71 ee			ld (debug_mark),a  
2c2f 3a 3e 2c			ld a, (.dmark+1)  
2c32 32 72 ee			ld (debug_mark+1),a  
2c35 3a 3f 2c			ld a, (.dmark+2)  
2c38 32 73 ee			ld (debug_mark+2),a  
2c3b 18 03			jr .pastdmark  
2c3d ..			.dmark: db "INC"  
2c40 f1			.pastdmark: pop af  
2c41			endm  
# End of macro DMARK
2c41						CALLMONITOR 
2c41 cd a8 15			call break_point_state  
2c44				endm  
# End of macro CALLMONITOR
2c44					endif 
2c44			 
2c44 7e					ld a,(hl) 
2c45 83					add e 
2c46 77					ld (hl),a 
2c47			 
2c47			 
2c47			 
2c47				       NEXTW 
2c47 c3 87 1f			jp macro_next 
2c4a				endm 
# End of macro NEXTW
2c4a			 
2c4a			.DEC: 
2c4a				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2c4a 6f				db WORD_SYS_CORE+91             
2c4b 9b 2c			dw .INC2            
2c4d 03				db 2 + 1 
2c4e .. 00			db "-!",0              
2c51				endm 
# End of macro CWHEAD
2c51			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2c51					if DEBUG_FORTH_WORDS_KEY 
2c51						DMARK "-s_" 
2c51 f5				push af  
2c52 3a 66 2c			ld a, (.dmark)  
2c55 32 71 ee			ld (debug_mark),a  
2c58 3a 67 2c			ld a, (.dmark+1)  
2c5b 32 72 ee			ld (debug_mark+1),a  
2c5e 3a 68 2c			ld a, (.dmark+2)  
2c61 32 73 ee			ld (debug_mark+2),a  
2c64 18 03			jr .pastdmark  
2c66 ..			.dmark: db "-s_"  
2c69 f1			.pastdmark: pop af  
2c6a			endm  
# End of macro DMARK
2c6a						CALLMONITOR 
2c6a cd a8 15			call break_point_state  
2c6d				endm  
# End of macro CALLMONITOR
2c6d					endif 
2c6d			 
2c6d					FORTH_DSP_VALUEHL 
2c6d cd 10 1e			call macro_dsp_valuehl 
2c70				endm 
# End of macro FORTH_DSP_VALUEHL
2c70			 
2c70 e5					push hl   ; save address 
2c71			 
2c71					FORTH_DSP_POP 
2c71 cd c8 1e			call macro_forth_dsp_pop 
2c74				endm 
# End of macro FORTH_DSP_POP
2c74			 
2c74					FORTH_DSP_VALUEHL 
2c74 cd 10 1e			call macro_dsp_valuehl 
2c77				endm 
# End of macro FORTH_DSP_VALUEHL
2c77			 
2c77					; hl contains value to add to byte at a 
2c77				 
2c77 eb					ex de, hl 
2c78			 
2c78 e1					pop hl 
2c79			 
2c79					if DEBUG_FORTH_WORDS 
2c79						DMARK "DEC" 
2c79 f5				push af  
2c7a 3a 8e 2c			ld a, (.dmark)  
2c7d 32 71 ee			ld (debug_mark),a  
2c80 3a 8f 2c			ld a, (.dmark+1)  
2c83 32 72 ee			ld (debug_mark+1),a  
2c86 3a 90 2c			ld a, (.dmark+2)  
2c89 32 73 ee			ld (debug_mark+2),a  
2c8c 18 03			jr .pastdmark  
2c8e ..			.dmark: db "DEC"  
2c91 f1			.pastdmark: pop af  
2c92			endm  
# End of macro DMARK
2c92						CALLMONITOR 
2c92 cd a8 15			call break_point_state  
2c95				endm  
# End of macro CALLMONITOR
2c95					endif 
2c95			 
2c95 7e					ld a,(hl) 
2c96 93					sub e 
2c97 77					ld (hl),a 
2c98			 
2c98			 
2c98			 
2c98				       NEXTW 
2c98 c3 87 1f			jp macro_next 
2c9b				endm 
# End of macro NEXTW
2c9b			 
2c9b			.INC2: 
2c9b				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2c9b 6f				db WORD_SYS_CORE+91             
2c9c 45 2d			dw .DEC2            
2c9e 04				db 3 + 1 
2c9f .. 00			db "+2!",0              
2ca3				endm 
# End of macro CWHEAD
2ca3			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2ca3			 
2ca3					if DEBUG_FORTH_WORDS_KEY 
2ca3						DMARK "+2s" 
2ca3 f5				push af  
2ca4 3a b8 2c			ld a, (.dmark)  
2ca7 32 71 ee			ld (debug_mark),a  
2caa 3a b9 2c			ld a, (.dmark+1)  
2cad 32 72 ee			ld (debug_mark+1),a  
2cb0 3a ba 2c			ld a, (.dmark+2)  
2cb3 32 73 ee			ld (debug_mark+2),a  
2cb6 18 03			jr .pastdmark  
2cb8 ..			.dmark: db "+2s"  
2cbb f1			.pastdmark: pop af  
2cbc			endm  
# End of macro DMARK
2cbc						CALLMONITOR 
2cbc cd a8 15			call break_point_state  
2cbf				endm  
# End of macro CALLMONITOR
2cbf					endif 
2cbf			 
2cbf					; Address 
2cbf			 
2cbf					FORTH_DSP_VALUEHL 
2cbf cd 10 1e			call macro_dsp_valuehl 
2cc2				endm 
# End of macro FORTH_DSP_VALUEHL
2cc2			 
2cc2 e5					push hl    ; save address 
2cc3			 
2cc3					; load content into de 
2cc3			 
2cc3 5e					ld e,(hl) 
2cc4 23					inc hl 
2cc5 56					ld d, (hl) 
2cc6			 
2cc6					if DEBUG_FORTH_WORDS 
2cc6						DMARK "+2a" 
2cc6 f5				push af  
2cc7 3a db 2c			ld a, (.dmark)  
2cca 32 71 ee			ld (debug_mark),a  
2ccd 3a dc 2c			ld a, (.dmark+1)  
2cd0 32 72 ee			ld (debug_mark+1),a  
2cd3 3a dd 2c			ld a, (.dmark+2)  
2cd6 32 73 ee			ld (debug_mark+2),a  
2cd9 18 03			jr .pastdmark  
2cdb ..			.dmark: db "+2a"  
2cde f1			.pastdmark: pop af  
2cdf			endm  
# End of macro DMARK
2cdf						CALLMONITOR 
2cdf cd a8 15			call break_point_state  
2ce2				endm  
# End of macro CALLMONITOR
2ce2					endif 
2ce2			 
2ce2					FORTH_DSP_POP 
2ce2 cd c8 1e			call macro_forth_dsp_pop 
2ce5				endm 
# End of macro FORTH_DSP_POP
2ce5			 
2ce5					; Get value to add 
2ce5			 
2ce5					FORTH_DSP_VALUE 
2ce5 cd f9 1d			call macro_forth_dsp_value 
2ce8				endm 
# End of macro FORTH_DSP_VALUE
2ce8			 
2ce8					if DEBUG_FORTH_WORDS 
2ce8						DMARK "+2v" 
2ce8 f5				push af  
2ce9 3a fd 2c			ld a, (.dmark)  
2cec 32 71 ee			ld (debug_mark),a  
2cef 3a fe 2c			ld a, (.dmark+1)  
2cf2 32 72 ee			ld (debug_mark+1),a  
2cf5 3a ff 2c			ld a, (.dmark+2)  
2cf8 32 73 ee			ld (debug_mark+2),a  
2cfb 18 03			jr .pastdmark  
2cfd ..			.dmark: db "+2v"  
2d00 f1			.pastdmark: pop af  
2d01			endm  
# End of macro DMARK
2d01						CALLMONITOR 
2d01 cd a8 15			call break_point_state  
2d04				endm  
# End of macro CALLMONITOR
2d04					endif 
2d04			 
2d04 19					add hl, de 
2d05			 
2d05					if DEBUG_FORTH_WORDS 
2d05						DMARK "+2+" 
2d05 f5				push af  
2d06 3a 1a 2d			ld a, (.dmark)  
2d09 32 71 ee			ld (debug_mark),a  
2d0c 3a 1b 2d			ld a, (.dmark+1)  
2d0f 32 72 ee			ld (debug_mark+1),a  
2d12 3a 1c 2d			ld a, (.dmark+2)  
2d15 32 73 ee			ld (debug_mark+2),a  
2d18 18 03			jr .pastdmark  
2d1a ..			.dmark: db "+2+"  
2d1d f1			.pastdmark: pop af  
2d1e			endm  
# End of macro DMARK
2d1e						CALLMONITOR 
2d1e cd a8 15			call break_point_state  
2d21				endm  
# End of macro CALLMONITOR
2d21					endif 
2d21			 
2d21					; move result to de 
2d21			 
2d21 eb					ex de, hl 
2d22			 
2d22					; Address 
2d22			 
2d22 e1					pop hl 
2d23			 
2d23					; save it back 
2d23			 
2d23 73					ld (hl), e 
2d24 23					inc hl 
2d25 72					ld (hl), d 
2d26			 
2d26					if DEBUG_FORTH_WORDS 
2d26						DMARK "+2e" 
2d26 f5				push af  
2d27 3a 3b 2d			ld a, (.dmark)  
2d2a 32 71 ee			ld (debug_mark),a  
2d2d 3a 3c 2d			ld a, (.dmark+1)  
2d30 32 72 ee			ld (debug_mark+1),a  
2d33 3a 3d 2d			ld a, (.dmark+2)  
2d36 32 73 ee			ld (debug_mark+2),a  
2d39 18 03			jr .pastdmark  
2d3b ..			.dmark: db "+2e"  
2d3e f1			.pastdmark: pop af  
2d3f			endm  
# End of macro DMARK
2d3f						CALLMONITOR 
2d3f cd a8 15			call break_point_state  
2d42				endm  
# End of macro CALLMONITOR
2d42					endif 
2d42			 
2d42			 
2d42			 
2d42			 
2d42			 
2d42				       NEXTW 
2d42 c3 87 1f			jp macro_next 
2d45				endm 
# End of macro NEXTW
2d45			 
2d45			.DEC2: 
2d45				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2d45 6f				db WORD_SYS_CORE+91             
2d46 f1 2d			dw .GET2            
2d48 04				db 3 + 1 
2d49 .. 00			db "-2!",0              
2d4d				endm 
# End of macro CWHEAD
2d4d			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2d4d			 
2d4d			 
2d4d					if DEBUG_FORTH_WORDS_KEY 
2d4d						DMARK "-2s" 
2d4d f5				push af  
2d4e 3a 62 2d			ld a, (.dmark)  
2d51 32 71 ee			ld (debug_mark),a  
2d54 3a 63 2d			ld a, (.dmark+1)  
2d57 32 72 ee			ld (debug_mark+1),a  
2d5a 3a 64 2d			ld a, (.dmark+2)  
2d5d 32 73 ee			ld (debug_mark+2),a  
2d60 18 03			jr .pastdmark  
2d62 ..			.dmark: db "-2s"  
2d65 f1			.pastdmark: pop af  
2d66			endm  
# End of macro DMARK
2d66						CALLMONITOR 
2d66 cd a8 15			call break_point_state  
2d69				endm  
# End of macro CALLMONITOR
2d69					endif 
2d69			 
2d69					; Address 
2d69			 
2d69					FORTH_DSP_VALUEHL 
2d69 cd 10 1e			call macro_dsp_valuehl 
2d6c				endm 
# End of macro FORTH_DSP_VALUEHL
2d6c			 
2d6c e5					push hl    ; save address 
2d6d			 
2d6d					; load content into de 
2d6d			 
2d6d 5e					ld e,(hl) 
2d6e 23					inc hl 
2d6f 56					ld d, (hl) 
2d70			 
2d70					if DEBUG_FORTH_WORDS 
2d70						DMARK "-2a" 
2d70 f5				push af  
2d71 3a 85 2d			ld a, (.dmark)  
2d74 32 71 ee			ld (debug_mark),a  
2d77 3a 86 2d			ld a, (.dmark+1)  
2d7a 32 72 ee			ld (debug_mark+1),a  
2d7d 3a 87 2d			ld a, (.dmark+2)  
2d80 32 73 ee			ld (debug_mark+2),a  
2d83 18 03			jr .pastdmark  
2d85 ..			.dmark: db "-2a"  
2d88 f1			.pastdmark: pop af  
2d89			endm  
# End of macro DMARK
2d89						CALLMONITOR 
2d89 cd a8 15			call break_point_state  
2d8c				endm  
# End of macro CALLMONITOR
2d8c					endif 
2d8c			 
2d8c					FORTH_DSP_POP 
2d8c cd c8 1e			call macro_forth_dsp_pop 
2d8f				endm 
# End of macro FORTH_DSP_POP
2d8f			 
2d8f					; Get value to remove 
2d8f			 
2d8f					FORTH_DSP_VALUE 
2d8f cd f9 1d			call macro_forth_dsp_value 
2d92				endm 
# End of macro FORTH_DSP_VALUE
2d92			 
2d92					if DEBUG_FORTH_WORDS 
2d92						DMARK "-2v" 
2d92 f5				push af  
2d93 3a a7 2d			ld a, (.dmark)  
2d96 32 71 ee			ld (debug_mark),a  
2d99 3a a8 2d			ld a, (.dmark+1)  
2d9c 32 72 ee			ld (debug_mark+1),a  
2d9f 3a a9 2d			ld a, (.dmark+2)  
2da2 32 73 ee			ld (debug_mark+2),a  
2da5 18 03			jr .pastdmark  
2da7 ..			.dmark: db "-2v"  
2daa f1			.pastdmark: pop af  
2dab			endm  
# End of macro DMARK
2dab						CALLMONITOR 
2dab cd a8 15			call break_point_state  
2dae				endm  
# End of macro CALLMONITOR
2dae					endif 
2dae			 
2dae eb					ex de, hl 
2daf ed 52				sbc hl, de 
2db1			 
2db1					if DEBUG_FORTH_WORDS 
2db1						DMARK "-2d" 
2db1 f5				push af  
2db2 3a c6 2d			ld a, (.dmark)  
2db5 32 71 ee			ld (debug_mark),a  
2db8 3a c7 2d			ld a, (.dmark+1)  
2dbb 32 72 ee			ld (debug_mark+1),a  
2dbe 3a c8 2d			ld a, (.dmark+2)  
2dc1 32 73 ee			ld (debug_mark+2),a  
2dc4 18 03			jr .pastdmark  
2dc6 ..			.dmark: db "-2d"  
2dc9 f1			.pastdmark: pop af  
2dca			endm  
# End of macro DMARK
2dca						CALLMONITOR 
2dca cd a8 15			call break_point_state  
2dcd				endm  
# End of macro CALLMONITOR
2dcd					endif 
2dcd			 
2dcd					; move result to de 
2dcd			 
2dcd eb					ex de, hl 
2dce			 
2dce					; Address 
2dce			 
2dce e1					pop hl 
2dcf			 
2dcf					; save it back 
2dcf			 
2dcf 73					ld (hl), e 
2dd0 23					inc hl 
2dd1 72					ld (hl), d 
2dd2			 
2dd2					if DEBUG_FORTH_WORDS 
2dd2						DMARK "-2e" 
2dd2 f5				push af  
2dd3 3a e7 2d			ld a, (.dmark)  
2dd6 32 71 ee			ld (debug_mark),a  
2dd9 3a e8 2d			ld a, (.dmark+1)  
2ddc 32 72 ee			ld (debug_mark+1),a  
2ddf 3a e9 2d			ld a, (.dmark+2)  
2de2 32 73 ee			ld (debug_mark+2),a  
2de5 18 03			jr .pastdmark  
2de7 ..			.dmark: db "-2e"  
2dea f1			.pastdmark: pop af  
2deb			endm  
# End of macro DMARK
2deb						CALLMONITOR 
2deb cd a8 15			call break_point_state  
2dee				endm  
# End of macro CALLMONITOR
2dee					endif 
2dee			 
2dee			 
2dee			 
2dee			 
2dee			 
2dee				       NEXTW 
2dee c3 87 1f			jp macro_next 
2df1				endm 
# End of macro NEXTW
2df1			.GET2: 
2df1				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2df1 6f				db WORD_SYS_CORE+91             
2df2 21 2e			dw .BANG2            
2df4 03				db 2 + 1 
2df5 .. 00			db "2@",0              
2df8				endm 
# End of macro CWHEAD
2df8			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2df8					if DEBUG_FORTH_WORDS_KEY 
2df8						DMARK "2A_" 
2df8 f5				push af  
2df9 3a 0d 2e			ld a, (.dmark)  
2dfc 32 71 ee			ld (debug_mark),a  
2dff 3a 0e 2e			ld a, (.dmark+1)  
2e02 32 72 ee			ld (debug_mark+1),a  
2e05 3a 0f 2e			ld a, (.dmark+2)  
2e08 32 73 ee			ld (debug_mark+2),a  
2e0b 18 03			jr .pastdmark  
2e0d ..			.dmark: db "2A_"  
2e10 f1			.pastdmark: pop af  
2e11			endm  
# End of macro DMARK
2e11						CALLMONITOR 
2e11 cd a8 15			call break_point_state  
2e14				endm  
# End of macro CALLMONITOR
2e14					endif 
2e14			 
2e14					FORTH_DSP_VALUEHL 
2e14 cd 10 1e			call macro_dsp_valuehl 
2e17				endm 
# End of macro FORTH_DSP_VALUEHL
2e17			 
2e17 5e					ld e, (hl) 
2e18 23					inc hl 
2e19 56					ld d, (hl) 
2e1a			 
2e1a eb					ex de, hl 
2e1b			 
2e1b cd 19 1c				call forth_push_numhl 
2e1e			 
2e1e				       NEXTW 
2e1e c3 87 1f			jp macro_next 
2e21				endm 
# End of macro NEXTW
2e21			.BANG2: 
2e21				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2e21 6f				db WORD_SYS_CORE+91             
2e22 59 2e			dw .CONFIG            
2e24 03				db 2 + 1 
2e25 .. 00			db "2!",0              
2e28				endm 
# End of macro CWHEAD
2e28			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2e28					if DEBUG_FORTH_WORDS_KEY 
2e28						DMARK "2S_" 
2e28 f5				push af  
2e29 3a 3d 2e			ld a, (.dmark)  
2e2c 32 71 ee			ld (debug_mark),a  
2e2f 3a 3e 2e			ld a, (.dmark+1)  
2e32 32 72 ee			ld (debug_mark+1),a  
2e35 3a 3f 2e			ld a, (.dmark+2)  
2e38 32 73 ee			ld (debug_mark+2),a  
2e3b 18 03			jr .pastdmark  
2e3d ..			.dmark: db "2S_"  
2e40 f1			.pastdmark: pop af  
2e41			endm  
# End of macro DMARK
2e41						CALLMONITOR 
2e41 cd a8 15			call break_point_state  
2e44				endm  
# End of macro CALLMONITOR
2e44					endif 
2e44			 
2e44					FORTH_DSP_VALUEHL 
2e44 cd 10 1e			call macro_dsp_valuehl 
2e47				endm 
# End of macro FORTH_DSP_VALUEHL
2e47			 
2e47 e5					push hl   ; save address 
2e48			 
2e48			 
2e48					FORTH_DSP_POP 
2e48 cd c8 1e			call macro_forth_dsp_pop 
2e4b				endm 
# End of macro FORTH_DSP_POP
2e4b			 
2e4b					 
2e4b					FORTH_DSP_VALUEHL 
2e4b cd 10 1e			call macro_dsp_valuehl 
2e4e				endm 
# End of macro FORTH_DSP_VALUEHL
2e4e			 
2e4e					FORTH_DSP_POP 
2e4e cd c8 1e			call macro_forth_dsp_pop 
2e51				endm 
# End of macro FORTH_DSP_POP
2e51			 
2e51 eb					ex de, hl    ; value now in de 
2e52			 
2e52 e1					pop hl 
2e53			 
2e53 73					ld (hl), e 
2e54			 
2e54 23					inc hl 
2e55			 
2e55 72					ld (hl), d 
2e56			 
2e56			 
2e56				       NEXTW 
2e56 c3 87 1f			jp macro_next 
2e59				endm 
# End of macro NEXTW
2e59			.CONFIG: 
2e59				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
2e59 6f				db WORD_SYS_CORE+91             
2e5a 6a 2e			dw .ENDCORE            
2e5c 07				db 6 + 1 
2e5d .. 00			db "CONFIG",0              
2e64				endm 
# End of macro CWHEAD
2e64			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
2e64			 
2e64 cd 07 14				call config 
2e67					NEXTW 
2e67 c3 87 1f			jp macro_next 
2e6a				endm 
# End of macro NEXTW
2e6a			.ENDCORE: 
2e6a			 
2e6a			; eof 
2e6a			 
2e6a			 
# End of file forth_words_core.asm
2e6a			include "forth_words_flow.asm" 
2e6a			 
2e6a			; | ## Program Flow Words 
2e6a			 
2e6a			.IF: 
2e6a				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2e6a 1e				db WORD_SYS_CORE+10             
2e6b 5f 2f			dw .THEN            
2e6d 03				db 2 + 1 
2e6e .. 00			db "IF",0              
2e71				endm 
# End of macro CWHEAD
2e71			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2e71			; 
2e71					if DEBUG_FORTH_WORDS_KEY 
2e71						DMARK "IF." 
2e71 f5				push af  
2e72 3a 86 2e			ld a, (.dmark)  
2e75 32 71 ee			ld (debug_mark),a  
2e78 3a 87 2e			ld a, (.dmark+1)  
2e7b 32 72 ee			ld (debug_mark+1),a  
2e7e 3a 88 2e			ld a, (.dmark+2)  
2e81 32 73 ee			ld (debug_mark+2),a  
2e84 18 03			jr .pastdmark  
2e86 ..			.dmark: db "IF."  
2e89 f1			.pastdmark: pop af  
2e8a			endm  
# End of macro DMARK
2e8a						CALLMONITOR 
2e8a cd a8 15			call break_point_state  
2e8d				endm  
# End of macro CALLMONITOR
2e8d					endif 
2e8d			; eval TOS 
2e8d			 
2e8d				FORTH_DSP_VALUEHL 
2e8d cd 10 1e			call macro_dsp_valuehl 
2e90				endm 
# End of macro FORTH_DSP_VALUEHL
2e90			 
2e90			;	push hl 
2e90				FORTH_DSP_POP 
2e90 cd c8 1e			call macro_forth_dsp_pop 
2e93				endm 
# End of macro FORTH_DSP_POP
2e93			;	pop hl 
2e93			 
2e93					if DEBUG_FORTH_WORDS 
2e93						DMARK "IF1" 
2e93 f5				push af  
2e94 3a a8 2e			ld a, (.dmark)  
2e97 32 71 ee			ld (debug_mark),a  
2e9a 3a a9 2e			ld a, (.dmark+1)  
2e9d 32 72 ee			ld (debug_mark+1),a  
2ea0 3a aa 2e			ld a, (.dmark+2)  
2ea3 32 73 ee			ld (debug_mark+2),a  
2ea6 18 03			jr .pastdmark  
2ea8 ..			.dmark: db "IF1"  
2eab f1			.pastdmark: pop af  
2eac			endm  
# End of macro DMARK
2eac						CALLMONITOR 
2eac cd a8 15			call break_point_state  
2eaf				endm  
# End of macro CALLMONITOR
2eaf					endif 
2eaf b7				or a        ; clear carry flag 
2eb0 11 00 00			ld de, 0 
2eb3 eb				ex de,hl 
2eb4 ed 52			sbc hl, de 
2eb6 c2 40 2f			jp nz, .iftrue 
2eb9			 
2eb9					if DEBUG_FORTH_WORDS 
2eb9						DMARK "IF2" 
2eb9 f5				push af  
2eba 3a ce 2e			ld a, (.dmark)  
2ebd 32 71 ee			ld (debug_mark),a  
2ec0 3a cf 2e			ld a, (.dmark+1)  
2ec3 32 72 ee			ld (debug_mark+1),a  
2ec6 3a d0 2e			ld a, (.dmark+2)  
2ec9 32 73 ee			ld (debug_mark+2),a  
2ecc 18 03			jr .pastdmark  
2ece ..			.dmark: db "IF2"  
2ed1 f1			.pastdmark: pop af  
2ed2			endm  
# End of macro DMARK
2ed2						CALLMONITOR 
2ed2 cd a8 15			call break_point_state  
2ed5				endm  
# End of macro CALLMONITOR
2ed5					endif 
2ed5			 
2ed5			; if not true then skip to THEN 
2ed5			 
2ed5				; TODO get tok_ptr 
2ed5				; TODO consume toks until we get to THEN 
2ed5			 
2ed5 2a 03 e6			ld hl, (os_tok_ptr) 
2ed8					if DEBUG_FORTH_WORDS 
2ed8						DMARK "IF3" 
2ed8 f5				push af  
2ed9 3a ed 2e			ld a, (.dmark)  
2edc 32 71 ee			ld (debug_mark),a  
2edf 3a ee 2e			ld a, (.dmark+1)  
2ee2 32 72 ee			ld (debug_mark+1),a  
2ee5 3a ef 2e			ld a, (.dmark+2)  
2ee8 32 73 ee			ld (debug_mark+2),a  
2eeb 18 03			jr .pastdmark  
2eed ..			.dmark: db "IF3"  
2ef0 f1			.pastdmark: pop af  
2ef1			endm  
# End of macro DMARK
2ef1						CALLMONITOR 
2ef1 cd a8 15			call break_point_state  
2ef4				endm  
# End of macro CALLMONITOR
2ef4						 
2ef4					endif 
2ef4 11 3b 2f			ld de, .ifthen 
2ef7					if DEBUG_FORTH_WORDS 
2ef7						DMARK "IF4" 
2ef7 f5				push af  
2ef8 3a 0c 2f			ld a, (.dmark)  
2efb 32 71 ee			ld (debug_mark),a  
2efe 3a 0d 2f			ld a, (.dmark+1)  
2f01 32 72 ee			ld (debug_mark+1),a  
2f04 3a 0e 2f			ld a, (.dmark+2)  
2f07 32 73 ee			ld (debug_mark+2),a  
2f0a 18 03			jr .pastdmark  
2f0c ..			.dmark: db "IF4"  
2f0f f1			.pastdmark: pop af  
2f10			endm  
# End of macro DMARK
2f10						CALLMONITOR 
2f10 cd a8 15			call break_point_state  
2f13				endm  
# End of macro CALLMONITOR
2f13					endif 
2f13 cd a2 20			call findnexttok  
2f16			 
2f16					if DEBUG_FORTH_WORDS 
2f16						DMARK "IF5" 
2f16 f5				push af  
2f17 3a 2b 2f			ld a, (.dmark)  
2f1a 32 71 ee			ld (debug_mark),a  
2f1d 3a 2c 2f			ld a, (.dmark+1)  
2f20 32 72 ee			ld (debug_mark+1),a  
2f23 3a 2d 2f			ld a, (.dmark+2)  
2f26 32 73 ee			ld (debug_mark+2),a  
2f29 18 03			jr .pastdmark  
2f2b ..			.dmark: db "IF5"  
2f2e f1			.pastdmark: pop af  
2f2f			endm  
# End of macro DMARK
2f2f						CALLMONITOR 
2f2f cd a8 15			call break_point_state  
2f32				endm  
# End of macro CALLMONITOR
2f32					endif 
2f32				; TODO replace below with ; exec using tok_ptr 
2f32 22 03 e6			ld (os_tok_ptr), hl 
2f35 c3 18 20			jp exec1 
2f38				NEXTW 
2f38 c3 87 1f			jp macro_next 
2f3b				endm 
# End of macro NEXTW
2f3b			 
2f3b .. 00		.ifthen:  db "THEN",0 
2f40			 
2f40			.iftrue:		 
2f40				; Exec next words normally 
2f40			 
2f40				; if true then exec following IF as normal 
2f40					if DEBUG_FORTH_WORDS 
2f40						DMARK "IFT" 
2f40 f5				push af  
2f41 3a 55 2f			ld a, (.dmark)  
2f44 32 71 ee			ld (debug_mark),a  
2f47 3a 56 2f			ld a, (.dmark+1)  
2f4a 32 72 ee			ld (debug_mark+1),a  
2f4d 3a 57 2f			ld a, (.dmark+2)  
2f50 32 73 ee			ld (debug_mark+2),a  
2f53 18 03			jr .pastdmark  
2f55 ..			.dmark: db "IFT"  
2f58 f1			.pastdmark: pop af  
2f59			endm  
# End of macro DMARK
2f59						CALLMONITOR 
2f59 cd a8 15			call break_point_state  
2f5c				endm  
# End of macro CALLMONITOR
2f5c					endif 
2f5c			 
2f5c					NEXTW 
2f5c c3 87 1f			jp macro_next 
2f5f				endm 
# End of macro NEXTW
2f5f			.THEN: 
2f5f				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
2f5f 1f				db WORD_SYS_CORE+11             
2f60 87 2f			dw .ELSE            
2f62 05				db 4 + 1 
2f63 .. 00			db "THEN",0              
2f68				endm 
# End of macro CWHEAD
2f68			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
2f68					if DEBUG_FORTH_WORDS_KEY 
2f68						DMARK "THN" 
2f68 f5				push af  
2f69 3a 7d 2f			ld a, (.dmark)  
2f6c 32 71 ee			ld (debug_mark),a  
2f6f 3a 7e 2f			ld a, (.dmark+1)  
2f72 32 72 ee			ld (debug_mark+1),a  
2f75 3a 7f 2f			ld a, (.dmark+2)  
2f78 32 73 ee			ld (debug_mark+2),a  
2f7b 18 03			jr .pastdmark  
2f7d ..			.dmark: db "THN"  
2f80 f1			.pastdmark: pop af  
2f81			endm  
# End of macro DMARK
2f81						CALLMONITOR 
2f81 cd a8 15			call break_point_state  
2f84				endm  
# End of macro CALLMONITOR
2f84					endif 
2f84					NEXTW 
2f84 c3 87 1f			jp macro_next 
2f87				endm 
# End of macro NEXTW
2f87			.ELSE: 
2f87				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
2f87 20				db WORD_SYS_CORE+12             
2f88 af 2f			dw .DO            
2f8a 03				db 2 + 1 
2f8b .. 00			db "ELSE",0              
2f90				endm 
# End of macro CWHEAD
2f90			; | ELSE ( -- ) Not supported - does nothing | TODO 
2f90			 
2f90					if DEBUG_FORTH_WORDS_KEY 
2f90						DMARK "ELS" 
2f90 f5				push af  
2f91 3a a5 2f			ld a, (.dmark)  
2f94 32 71 ee			ld (debug_mark),a  
2f97 3a a6 2f			ld a, (.dmark+1)  
2f9a 32 72 ee			ld (debug_mark+1),a  
2f9d 3a a7 2f			ld a, (.dmark+2)  
2fa0 32 73 ee			ld (debug_mark+2),a  
2fa3 18 03			jr .pastdmark  
2fa5 ..			.dmark: db "ELS"  
2fa8 f1			.pastdmark: pop af  
2fa9			endm  
# End of macro DMARK
2fa9						CALLMONITOR 
2fa9 cd a8 15			call break_point_state  
2fac				endm  
# End of macro CALLMONITOR
2fac					endif 
2fac			 
2fac			 
2fac					NEXTW 
2fac c3 87 1f			jp macro_next 
2faf				endm 
# End of macro NEXTW
2faf			.DO: 
2faf				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
2faf 21				db WORD_SYS_CORE+13             
2fb0 d6 30			dw .LOOP            
2fb2 03				db 2 + 1 
2fb3 .. 00			db "DO",0              
2fb6				endm 
# End of macro CWHEAD
2fb6			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
2fb6			 
2fb6					if DEBUG_FORTH_WORDS_KEY 
2fb6						DMARK "DO." 
2fb6 f5				push af  
2fb7 3a cb 2f			ld a, (.dmark)  
2fba 32 71 ee			ld (debug_mark),a  
2fbd 3a cc 2f			ld a, (.dmark+1)  
2fc0 32 72 ee			ld (debug_mark+1),a  
2fc3 3a cd 2f			ld a, (.dmark+2)  
2fc6 32 73 ee			ld (debug_mark+2),a  
2fc9 18 03			jr .pastdmark  
2fcb ..			.dmark: db "DO."  
2fce f1			.pastdmark: pop af  
2fcf			endm  
# End of macro DMARK
2fcf						CALLMONITOR 
2fcf cd a8 15			call break_point_state  
2fd2				endm  
# End of macro CALLMONITOR
2fd2					endif 
2fd2			;  push pc to rsp stack past the DO 
2fd2			 
2fd2 2a 03 e6				ld hl, (os_tok_ptr) 
2fd5 23					inc hl   ; D 
2fd6 23					inc hl  ; O 
2fd7 23					inc hl   ; null 
2fd8					if DEBUG_FORTH_WORDS 
2fd8						DMARK "DO2" 
2fd8 f5				push af  
2fd9 3a ed 2f			ld a, (.dmark)  
2fdc 32 71 ee			ld (debug_mark),a  
2fdf 3a ee 2f			ld a, (.dmark+1)  
2fe2 32 72 ee			ld (debug_mark+1),a  
2fe5 3a ef 2f			ld a, (.dmark+2)  
2fe8 32 73 ee			ld (debug_mark+2),a  
2feb 18 03			jr .pastdmark  
2fed ..			.dmark: db "DO2"  
2ff0 f1			.pastdmark: pop af  
2ff1			endm  
# End of macro DMARK
2ff1						CALLMONITOR 
2ff1 cd a8 15			call break_point_state  
2ff4				endm  
# End of macro CALLMONITOR
2ff4					endif 
2ff4					FORTH_RSP_NEXT 
2ff4 cd c0 1b			call macro_forth_rsp_next 
2ff7				endm 
# End of macro FORTH_RSP_NEXT
2ff7					if DEBUG_FORTH_WORDS 
2ff7						DMARK "DO3" 
2ff7 f5				push af  
2ff8 3a 0c 30			ld a, (.dmark)  
2ffb 32 71 ee			ld (debug_mark),a  
2ffe 3a 0d 30			ld a, (.dmark+1)  
3001 32 72 ee			ld (debug_mark+1),a  
3004 3a 0e 30			ld a, (.dmark+2)  
3007 32 73 ee			ld (debug_mark+2),a  
300a 18 03			jr .pastdmark  
300c ..			.dmark: db "DO3"  
300f f1			.pastdmark: pop af  
3010			endm  
# End of macro DMARK
3010						CALLMONITOR 
3010 cd a8 15			call break_point_state  
3013				endm  
# End of macro CALLMONITOR
3013					endif 
3013			 
3013					;if DEBUG_FORTH_WORDS 
3013				;		push hl 
3013			;		endif  
3013			 
3013			; get counters from data stack 
3013			 
3013			 
3013					FORTH_DSP_VALUEHL 
3013 cd 10 1e			call macro_dsp_valuehl 
3016				endm 
# End of macro FORTH_DSP_VALUEHL
3016 e5					push hl		 ; hl now has starting counter which needs to be tos 
3017			 
3017					if DEBUG_FORTH_WORDS 
3017						DMARK "DO4" 
3017 f5				push af  
3018 3a 2c 30			ld a, (.dmark)  
301b 32 71 ee			ld (debug_mark),a  
301e 3a 2d 30			ld a, (.dmark+1)  
3021 32 72 ee			ld (debug_mark+1),a  
3024 3a 2e 30			ld a, (.dmark+2)  
3027 32 73 ee			ld (debug_mark+2),a  
302a 18 03			jr .pastdmark  
302c ..			.dmark: db "DO4"  
302f f1			.pastdmark: pop af  
3030			endm  
# End of macro DMARK
3030						CALLMONITOR 
3030 cd a8 15			call break_point_state  
3033				endm  
# End of macro CALLMONITOR
3033					endif 
3033					FORTH_DSP_POP 
3033 cd c8 1e			call macro_forth_dsp_pop 
3036				endm 
# End of macro FORTH_DSP_POP
3036			 
3036					if DEBUG_FORTH_WORDS 
3036						DMARK "DO5" 
3036 f5				push af  
3037 3a 4b 30			ld a, (.dmark)  
303a 32 71 ee			ld (debug_mark),a  
303d 3a 4c 30			ld a, (.dmark+1)  
3040 32 72 ee			ld (debug_mark+1),a  
3043 3a 4d 30			ld a, (.dmark+2)  
3046 32 73 ee			ld (debug_mark+2),a  
3049 18 03			jr .pastdmark  
304b ..			.dmark: db "DO5"  
304e f1			.pastdmark: pop af  
304f			endm  
# End of macro DMARK
304f						CALLMONITOR 
304f cd a8 15			call break_point_state  
3052				endm  
# End of macro CALLMONITOR
3052					endif 
3052			 
3052					FORTH_DSP_VALUEHL 
3052 cd 10 1e			call macro_dsp_valuehl 
3055				endm 
# End of macro FORTH_DSP_VALUEHL
3055			;		push hl		 ; hl now has starting limit counter 
3055			 
3055					if DEBUG_FORTH_WORDS 
3055						DMARK "DO6" 
3055 f5				push af  
3056 3a 6a 30			ld a, (.dmark)  
3059 32 71 ee			ld (debug_mark),a  
305c 3a 6b 30			ld a, (.dmark+1)  
305f 32 72 ee			ld (debug_mark+1),a  
3062 3a 6c 30			ld a, (.dmark+2)  
3065 32 73 ee			ld (debug_mark+2),a  
3068 18 03			jr .pastdmark  
306a ..			.dmark: db "DO6"  
306d f1			.pastdmark: pop af  
306e			endm  
# End of macro DMARK
306e						CALLMONITOR 
306e cd a8 15			call break_point_state  
3071				endm  
# End of macro CALLMONITOR
3071					endif 
3071					FORTH_DSP_POP 
3071 cd c8 1e			call macro_forth_dsp_pop 
3074				endm 
# End of macro FORTH_DSP_POP
3074			 
3074			; put counters on the loop stack 
3074			 
3074			;		pop hl			 ; limit counter 
3074 d1					pop de			; start counter 
3075			 
3075					; push limit counter 
3075			 
3075					if DEBUG_FORTH_WORDS 
3075						DMARK "DO7" 
3075 f5				push af  
3076 3a 8a 30			ld a, (.dmark)  
3079 32 71 ee			ld (debug_mark),a  
307c 3a 8b 30			ld a, (.dmark+1)  
307f 32 72 ee			ld (debug_mark+1),a  
3082 3a 8c 30			ld a, (.dmark+2)  
3085 32 73 ee			ld (debug_mark+2),a  
3088 18 03			jr .pastdmark  
308a ..			.dmark: db "DO7"  
308d f1			.pastdmark: pop af  
308e			endm  
# End of macro DMARK
308e						CALLMONITOR 
308e cd a8 15			call break_point_state  
3091				endm  
# End of macro CALLMONITOR
3091					endif 
3091					FORTH_LOOP_NEXT 
3091 cd 41 1e			call macro_forth_loop_next 
3094				endm 
# End of macro FORTH_LOOP_NEXT
3094			 
3094					; push start counter 
3094			 
3094 eb					ex de, hl 
3095					if DEBUG_FORTH_WORDS 
3095						DMARK "DO7" 
3095 f5				push af  
3096 3a aa 30			ld a, (.dmark)  
3099 32 71 ee			ld (debug_mark),a  
309c 3a ab 30			ld a, (.dmark+1)  
309f 32 72 ee			ld (debug_mark+1),a  
30a2 3a ac 30			ld a, (.dmark+2)  
30a5 32 73 ee			ld (debug_mark+2),a  
30a8 18 03			jr .pastdmark  
30aa ..			.dmark: db "DO7"  
30ad f1			.pastdmark: pop af  
30ae			endm  
# End of macro DMARK
30ae						CALLMONITOR 
30ae cd a8 15			call break_point_state  
30b1				endm  
# End of macro CALLMONITOR
30b1					endif 
30b1					FORTH_LOOP_NEXT 
30b1 cd 41 1e			call macro_forth_loop_next 
30b4				endm 
# End of macro FORTH_LOOP_NEXT
30b4			 
30b4			 
30b4					; init first round of I counter 
30b4			 
30b4 22 27 e6				ld (os_current_i), hl 
30b7			 
30b7					if DEBUG_FORTH_WORDS 
30b7						DMARK "DO8" 
30b7 f5				push af  
30b8 3a cc 30			ld a, (.dmark)  
30bb 32 71 ee			ld (debug_mark),a  
30be 3a cd 30			ld a, (.dmark+1)  
30c1 32 72 ee			ld (debug_mark+1),a  
30c4 3a ce 30			ld a, (.dmark+2)  
30c7 32 73 ee			ld (debug_mark+2),a  
30ca 18 03			jr .pastdmark  
30cc ..			.dmark: db "DO8"  
30cf f1			.pastdmark: pop af  
30d0			endm  
# End of macro DMARK
30d0						CALLMONITOR 
30d0 cd a8 15			call break_point_state  
30d3				endm  
# End of macro CALLMONITOR
30d3					endif 
30d3			 
30d3					NEXTW 
30d3 c3 87 1f			jp macro_next 
30d6				endm 
# End of macro NEXTW
30d6			.LOOP: 
30d6				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
30d6 22				db WORD_SYS_CORE+14             
30d7 ee 31			dw .I            
30d9 05				db 4 + 1 
30da .. 00			db "LOOP",0              
30df				endm 
# End of macro CWHEAD
30df			; | LOOP ( -- ) Increment and test loop counter  | DONE 
30df			 
30df				; pop tos as current loop count to hl 
30df			 
30df				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
30df			 
30df				FORTH_LOOP_TOS 
30df cd 74 1e			call macro_forth_loop_tos 
30e2				endm 
# End of macro FORTH_LOOP_TOS
30e2 e5				push hl 
30e3			 
30e3					if DEBUG_FORTH_WORDS_KEY 
30e3						DMARK "LOP" 
30e3 f5				push af  
30e4 3a f8 30			ld a, (.dmark)  
30e7 32 71 ee			ld (debug_mark),a  
30ea 3a f9 30			ld a, (.dmark+1)  
30ed 32 72 ee			ld (debug_mark+1),a  
30f0 3a fa 30			ld a, (.dmark+2)  
30f3 32 73 ee			ld (debug_mark+2),a  
30f6 18 03			jr .pastdmark  
30f8 ..			.dmark: db "LOP"  
30fb f1			.pastdmark: pop af  
30fc			endm  
# End of macro DMARK
30fc						CALLMONITOR 
30fc cd a8 15			call break_point_state  
30ff				endm  
# End of macro CALLMONITOR
30ff					endif 
30ff				; next item on the stack is the limit. get it 
30ff			 
30ff			 
30ff				FORTH_LOOP_POP 
30ff cd 7e 1e			call macro_forth_loop_pop 
3102				endm 
# End of macro FORTH_LOOP_POP
3102			 
3102				FORTH_LOOP_TOS 
3102 cd 74 1e			call macro_forth_loop_tos 
3105				endm 
# End of macro FORTH_LOOP_TOS
3105			 
3105 d1				pop de		 ; de = i, hl = limit 
3106			 
3106					if DEBUG_FORTH_WORDS 
3106						DMARK "LP1" 
3106 f5				push af  
3107 3a 1b 31			ld a, (.dmark)  
310a 32 71 ee			ld (debug_mark),a  
310d 3a 1c 31			ld a, (.dmark+1)  
3110 32 72 ee			ld (debug_mark+1),a  
3113 3a 1d 31			ld a, (.dmark+2)  
3116 32 73 ee			ld (debug_mark+2),a  
3119 18 03			jr .pastdmark  
311b ..			.dmark: db "LP1"  
311e f1			.pastdmark: pop af  
311f			endm  
# End of macro DMARK
311f						CALLMONITOR 
311f cd a8 15			call break_point_state  
3122				endm  
# End of macro CALLMONITOR
3122					endif 
3122			 
3122				; go back to previous word 
3122			 
3122 d5				push de    ; save I for inc later 
3123			 
3123			 
3123				; get limit 
3123				;  is I at limit? 
3123			 
3123			 
3123					if DEBUG_FORTH_WORDS 
3123						DMARK "LP1" 
3123 f5				push af  
3124 3a 38 31			ld a, (.dmark)  
3127 32 71 ee			ld (debug_mark),a  
312a 3a 39 31			ld a, (.dmark+1)  
312d 32 72 ee			ld (debug_mark+1),a  
3130 3a 3a 31			ld a, (.dmark+2)  
3133 32 73 ee			ld (debug_mark+2),a  
3136 18 03			jr .pastdmark  
3138 ..			.dmark: db "LP1"  
313b f1			.pastdmark: pop af  
313c			endm  
# End of macro DMARK
313c						CALLMONITOR 
313c cd a8 15			call break_point_state  
313f				endm  
# End of macro CALLMONITOR
313f					endif 
313f			 
313f ed 52			sbc hl, de 
3141			 
3141			 
3141				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3141			 
3141 20 26				jr nz, .loopnotdone 
3143			 
3143 e1				pop hl   ; get rid of saved I 
3144				FORTH_LOOP_POP     ; get rid of limit 
3144 cd 7e 1e			call macro_forth_loop_pop 
3147				endm 
# End of macro FORTH_LOOP_POP
3147			 
3147				FORTH_RSP_POP     ; get rid of DO ptr 
3147 cd e1 1b			call macro_forth_rsp_pop 
314a				endm 
# End of macro FORTH_RSP_POP
314a			 
314a			if DEBUG_FORTH_WORDS 
314a						DMARK "LP>" 
314a f5				push af  
314b 3a 5f 31			ld a, (.dmark)  
314e 32 71 ee			ld (debug_mark),a  
3151 3a 60 31			ld a, (.dmark+1)  
3154 32 72 ee			ld (debug_mark+1),a  
3157 3a 61 31			ld a, (.dmark+2)  
315a 32 73 ee			ld (debug_mark+2),a  
315d 18 03			jr .pastdmark  
315f ..			.dmark: db "LP>"  
3162 f1			.pastdmark: pop af  
3163			endm  
# End of macro DMARK
3163				CALLMONITOR 
3163 cd a8 15			call break_point_state  
3166				endm  
# End of macro CALLMONITOR
3166			endif 
3166			 
3166					NEXTW 
3166 c3 87 1f			jp macro_next 
3169				endm 
# End of macro NEXTW
3169				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3169			 
3169			.loopnotdone: 
3169			 
3169 e1				pop hl    ; get I 
316a 23				inc hl 
316b			 
316b			   	; save new I 
316b			 
316b			 
316b					; set I counter 
316b			 
316b 22 27 e6				ld (os_current_i), hl 
316e			 
316e					if DEBUG_FORTH_WORDS 
316e						DMARK "LPN" 
316e f5				push af  
316f 3a 83 31			ld a, (.dmark)  
3172 32 71 ee			ld (debug_mark),a  
3175 3a 84 31			ld a, (.dmark+1)  
3178 32 72 ee			ld (debug_mark+1),a  
317b 3a 85 31			ld a, (.dmark+2)  
317e 32 73 ee			ld (debug_mark+2),a  
3181 18 03			jr .pastdmark  
3183 ..			.dmark: db "LPN"  
3186 f1			.pastdmark: pop af  
3187			endm  
# End of macro DMARK
3187					CALLMONITOR 
3187 cd a8 15			call break_point_state  
318a				endm  
# End of macro CALLMONITOR
318a					endif 
318a					 
318a				FORTH_LOOP_NEXT 
318a cd 41 1e			call macro_forth_loop_next 
318d				endm 
# End of macro FORTH_LOOP_NEXT
318d			 
318d			 
318d					if DEBUG_FORTH_WORDS 
318d eb						ex de,hl 
318e					endif 
318e			 
318e			;	; get DO ptr 
318e			; 
318e					if DEBUG_FORTH_WORDS 
318e						DMARK "LP7" 
318e f5				push af  
318f 3a a3 31			ld a, (.dmark)  
3192 32 71 ee			ld (debug_mark),a  
3195 3a a4 31			ld a, (.dmark+1)  
3198 32 72 ee			ld (debug_mark+1),a  
319b 3a a5 31			ld a, (.dmark+2)  
319e 32 73 ee			ld (debug_mark+2),a  
31a1 18 03			jr .pastdmark  
31a3 ..			.dmark: db "LP7"  
31a6 f1			.pastdmark: pop af  
31a7			endm  
# End of macro DMARK
31a7					CALLMONITOR 
31a7 cd a8 15			call break_point_state  
31aa				endm  
# End of macro CALLMONITOR
31aa					endif 
31aa				FORTH_RSP_TOS 
31aa cd d7 1b			call macro_forth_rsp_tos 
31ad				endm 
# End of macro FORTH_RSP_TOS
31ad			 
31ad					if DEBUG_FORTH_WORDS 
31ad						DMARK "LP8" 
31ad f5				push af  
31ae 3a c2 31			ld a, (.dmark)  
31b1 32 71 ee			ld (debug_mark),a  
31b4 3a c3 31			ld a, (.dmark+1)  
31b7 32 72 ee			ld (debug_mark+1),a  
31ba 3a c4 31			ld a, (.dmark+2)  
31bd 32 73 ee			ld (debug_mark+2),a  
31c0 18 03			jr .pastdmark  
31c2 ..			.dmark: db "LP8"  
31c5 f1			.pastdmark: pop af  
31c6			endm  
# End of macro DMARK
31c6					CALLMONITOR 
31c6 cd a8 15			call break_point_state  
31c9				endm  
# End of macro CALLMONITOR
31c9					endif 
31c9				;push hl 
31c9			 
31c9				; not going to DO any more 
31c9				; get rid of the RSP pointer as DO will add it back in 
31c9				;FORTH_RSP_POP 
31c9				;pop hl 
31c9			 
31c9				;ld hl,(cli_ret_sp) 
31c9				;ld e, (hl) 
31c9				;inc hl 
31c9				;ld d, (hl) 
31c9				;ex de,hl 
31c9 22 03 e6			ld (os_tok_ptr), hl 
31cc					if DEBUG_FORTH_WORDS 
31cc						DMARK "LP<" 
31cc f5				push af  
31cd 3a e1 31			ld a, (.dmark)  
31d0 32 71 ee			ld (debug_mark),a  
31d3 3a e2 31			ld a, (.dmark+1)  
31d6 32 72 ee			ld (debug_mark+1),a  
31d9 3a e3 31			ld a, (.dmark+2)  
31dc 32 73 ee			ld (debug_mark+2),a  
31df 18 03			jr .pastdmark  
31e1 ..			.dmark: db "LP<"  
31e4 f1			.pastdmark: pop af  
31e5			endm  
# End of macro DMARK
31e5					CALLMONITOR 
31e5 cd a8 15			call break_point_state  
31e8				endm  
# End of macro CALLMONITOR
31e8				endif 
31e8 c3 18 20			jp exec1 
31eb			 
31eb					 
31eb			 
31eb			 
31eb					NEXTW 
31eb c3 87 1f			jp macro_next 
31ee				endm 
# End of macro NEXTW
31ee			.I:  
31ee			 
31ee				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
31ee 5e				db WORD_SYS_CORE+74             
31ef 19 32			dw .DLOOP            
31f1 02				db 1 + 1 
31f2 .. 00			db "I",0              
31f4				endm 
# End of macro CWHEAD
31f4			; | I ( -- ) Current loop counter | DONE 
31f4					if DEBUG_FORTH_WORDS_KEY 
31f4						DMARK "I.." 
31f4 f5				push af  
31f5 3a 09 32			ld a, (.dmark)  
31f8 32 71 ee			ld (debug_mark),a  
31fb 3a 0a 32			ld a, (.dmark+1)  
31fe 32 72 ee			ld (debug_mark+1),a  
3201 3a 0b 32			ld a, (.dmark+2)  
3204 32 73 ee			ld (debug_mark+2),a  
3207 18 03			jr .pastdmark  
3209 ..			.dmark: db "I.."  
320c f1			.pastdmark: pop af  
320d			endm  
# End of macro DMARK
320d						CALLMONITOR 
320d cd a8 15			call break_point_state  
3210				endm  
# End of macro CALLMONITOR
3210					endif 
3210			 
3210 2a 27 e6				ld hl,(os_current_i) 
3213 cd 19 1c				call forth_push_numhl 
3216			 
3216					NEXTW 
3216 c3 87 1f			jp macro_next 
3219				endm 
# End of macro NEXTW
3219			.DLOOP: 
3219				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
3219 5f				db WORD_SYS_CORE+75             
321a fa 32			dw .REPEAT            
321c 06				db 5 + 1 
321d .. 00			db "-LOOP",0              
3223				endm 
# End of macro CWHEAD
3223			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
3223				; pop tos as current loop count to hl 
3223					if DEBUG_FORTH_WORDS_KEY 
3223						DMARK "-LP" 
3223 f5				push af  
3224 3a 38 32			ld a, (.dmark)  
3227 32 71 ee			ld (debug_mark),a  
322a 3a 39 32			ld a, (.dmark+1)  
322d 32 72 ee			ld (debug_mark+1),a  
3230 3a 3a 32			ld a, (.dmark+2)  
3233 32 73 ee			ld (debug_mark+2),a  
3236 18 03			jr .pastdmark  
3238 ..			.dmark: db "-LP"  
323b f1			.pastdmark: pop af  
323c			endm  
# End of macro DMARK
323c						CALLMONITOR 
323c cd a8 15			call break_point_state  
323f				endm  
# End of macro CALLMONITOR
323f					endif 
323f			 
323f				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
323f			 
323f				FORTH_LOOP_TOS 
323f cd 74 1e			call macro_forth_loop_tos 
3242				endm 
# End of macro FORTH_LOOP_TOS
3242 e5				push hl 
3243			 
3243					if DEBUG_FORTH_WORDS 
3243						DMARK "-LP" 
3243 f5				push af  
3244 3a 58 32			ld a, (.dmark)  
3247 32 71 ee			ld (debug_mark),a  
324a 3a 59 32			ld a, (.dmark+1)  
324d 32 72 ee			ld (debug_mark+1),a  
3250 3a 5a 32			ld a, (.dmark+2)  
3253 32 73 ee			ld (debug_mark+2),a  
3256 18 03			jr .pastdmark  
3258 ..			.dmark: db "-LP"  
325b f1			.pastdmark: pop af  
325c			endm  
# End of macro DMARK
325c						CALLMONITOR 
325c cd a8 15			call break_point_state  
325f				endm  
# End of macro CALLMONITOR
325f					endif 
325f				; next item on the stack is the limit. get it 
325f			 
325f			 
325f				FORTH_LOOP_POP 
325f cd 7e 1e			call macro_forth_loop_pop 
3262				endm 
# End of macro FORTH_LOOP_POP
3262			 
3262				FORTH_LOOP_TOS 
3262 cd 74 1e			call macro_forth_loop_tos 
3265				endm 
# End of macro FORTH_LOOP_TOS
3265			 
3265 d1				pop de		 ; de = i, hl = limit 
3266			 
3266					if DEBUG_FORTH_WORDS 
3266						DMARK "-L1" 
3266 f5				push af  
3267 3a 7b 32			ld a, (.dmark)  
326a 32 71 ee			ld (debug_mark),a  
326d 3a 7c 32			ld a, (.dmark+1)  
3270 32 72 ee			ld (debug_mark+1),a  
3273 3a 7d 32			ld a, (.dmark+2)  
3276 32 73 ee			ld (debug_mark+2),a  
3279 18 03			jr .pastdmark  
327b ..			.dmark: db "-L1"  
327e f1			.pastdmark: pop af  
327f			endm  
# End of macro DMARK
327f						CALLMONITOR 
327f cd a8 15			call break_point_state  
3282				endm  
# End of macro CALLMONITOR
3282					endif 
3282			 
3282				; go back to previous word 
3282			 
3282 d5				push de    ; save I for inc later 
3283			 
3283			 
3283				; get limit 
3283				;  is I at limit? 
3283			 
3283			 
3283					if DEBUG_FORTH_WORDS 
3283						DMARK "-L1" 
3283 f5				push af  
3284 3a 98 32			ld a, (.dmark)  
3287 32 71 ee			ld (debug_mark),a  
328a 3a 99 32			ld a, (.dmark+1)  
328d 32 72 ee			ld (debug_mark+1),a  
3290 3a 9a 32			ld a, (.dmark+2)  
3293 32 73 ee			ld (debug_mark+2),a  
3296 18 03			jr .pastdmark  
3298 ..			.dmark: db "-L1"  
329b f1			.pastdmark: pop af  
329c			endm  
# End of macro DMARK
329c						CALLMONITOR 
329c cd a8 15			call break_point_state  
329f				endm  
# End of macro CALLMONITOR
329f					endif 
329f			 
329f ed 52			sbc hl, de 
32a1			 
32a1			 
32a1				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
32a1			 
32a1 20 26				jr nz, .mloopnotdone 
32a3			 
32a3 e1				pop hl   ; get rid of saved I 
32a4				FORTH_LOOP_POP     ; get rid of limit 
32a4 cd 7e 1e			call macro_forth_loop_pop 
32a7				endm 
# End of macro FORTH_LOOP_POP
32a7			 
32a7				FORTH_RSP_POP     ; get rid of DO ptr 
32a7 cd e1 1b			call macro_forth_rsp_pop 
32aa				endm 
# End of macro FORTH_RSP_POP
32aa			 
32aa			if DEBUG_FORTH_WORDS 
32aa						DMARK "-L>" 
32aa f5				push af  
32ab 3a bf 32			ld a, (.dmark)  
32ae 32 71 ee			ld (debug_mark),a  
32b1 3a c0 32			ld a, (.dmark+1)  
32b4 32 72 ee			ld (debug_mark+1),a  
32b7 3a c1 32			ld a, (.dmark+2)  
32ba 32 73 ee			ld (debug_mark+2),a  
32bd 18 03			jr .pastdmark  
32bf ..			.dmark: db "-L>"  
32c2 f1			.pastdmark: pop af  
32c3			endm  
# End of macro DMARK
32c3				CALLMONITOR 
32c3 cd a8 15			call break_point_state  
32c6				endm  
# End of macro CALLMONITOR
32c6			endif 
32c6			 
32c6					NEXTW 
32c6 c3 87 1f			jp macro_next 
32c9				endm 
# End of macro NEXTW
32c9				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
32c9			 
32c9			.mloopnotdone: 
32c9			 
32c9 e1				pop hl    ; get I 
32ca 2b				dec hl 
32cb			 
32cb			   	; save new I 
32cb			 
32cb			 
32cb					; set I counter 
32cb			 
32cb 22 27 e6				ld (os_current_i), hl 
32ce			 
32ce					 
32ce				FORTH_LOOP_NEXT 
32ce cd 41 1e			call macro_forth_loop_next 
32d1				endm 
# End of macro FORTH_LOOP_NEXT
32d1			 
32d1			 
32d1					if DEBUG_FORTH_WORDS 
32d1 eb						ex de,hl 
32d2					endif 
32d2			 
32d2			;	; get DO ptr 
32d2			; 
32d2				FORTH_RSP_TOS 
32d2 cd d7 1b			call macro_forth_rsp_tos 
32d5				endm 
# End of macro FORTH_RSP_TOS
32d5			 
32d5				;push hl 
32d5			 
32d5				; not going to DO any more 
32d5				; get rid of the RSP pointer as DO will add it back in 
32d5				;FORTH_RSP_POP 
32d5				;pop hl 
32d5			 
32d5			 
32d5 22 03 e6			ld (os_tok_ptr), hl 
32d8					if DEBUG_FORTH_WORDS 
32d8						DMARK "-L<" 
32d8 f5				push af  
32d9 3a ed 32			ld a, (.dmark)  
32dc 32 71 ee			ld (debug_mark),a  
32df 3a ee 32			ld a, (.dmark+1)  
32e2 32 72 ee			ld (debug_mark+1),a  
32e5 3a ef 32			ld a, (.dmark+2)  
32e8 32 73 ee			ld (debug_mark+2),a  
32eb 18 03			jr .pastdmark  
32ed ..			.dmark: db "-L<"  
32f0 f1			.pastdmark: pop af  
32f1			endm  
# End of macro DMARK
32f1					CALLMONITOR 
32f1 cd a8 15			call break_point_state  
32f4				endm  
# End of macro CALLMONITOR
32f4				endif 
32f4 c3 18 20			jp exec1 
32f7			 
32f7					 
32f7			 
32f7			 
32f7			 
32f7				NEXTW 
32f7 c3 87 1f			jp macro_next 
32fa				endm 
# End of macro NEXTW
32fa			 
32fa			 
32fa			 
32fa			 
32fa			.REPEAT: 
32fa				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
32fa 71				db WORD_SYS_CORE+93             
32fb 4d 33			dw .UNTIL            
32fd 06				db 5 + 1 
32fe .. 00			db "REPEAT",0              
3305				endm 
# End of macro CWHEAD
3305			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
3305			;  push pc to rsp stack past the REPEAT 
3305					if DEBUG_FORTH_WORDS_KEY 
3305						DMARK "REP" 
3305 f5				push af  
3306 3a 1a 33			ld a, (.dmark)  
3309 32 71 ee			ld (debug_mark),a  
330c 3a 1b 33			ld a, (.dmark+1)  
330f 32 72 ee			ld (debug_mark+1),a  
3312 3a 1c 33			ld a, (.dmark+2)  
3315 32 73 ee			ld (debug_mark+2),a  
3318 18 03			jr .pastdmark  
331a ..			.dmark: db "REP"  
331d f1			.pastdmark: pop af  
331e			endm  
# End of macro DMARK
331e						CALLMONITOR 
331e cd a8 15			call break_point_state  
3321				endm  
# End of macro CALLMONITOR
3321					endif 
3321			 
3321 2a 03 e6				ld hl, (os_tok_ptr) 
3324 23					inc hl   ; R 
3325 23					inc hl  ; E 
3326 23					inc hl   ; P 
3327 23					inc hl   ; E 
3328 23					inc hl   ; A 
3329 23					inc hl   ; T 
332a 23					inc hl   ; zero 
332b					FORTH_RSP_NEXT 
332b cd c0 1b			call macro_forth_rsp_next 
332e				endm 
# End of macro FORTH_RSP_NEXT
332e			 
332e			 
332e					if DEBUG_FORTH_WORDS 
332e						DMARK "REP" 
332e f5				push af  
332f 3a 43 33			ld a, (.dmark)  
3332 32 71 ee			ld (debug_mark),a  
3335 3a 44 33			ld a, (.dmark+1)  
3338 32 72 ee			ld (debug_mark+1),a  
333b 3a 45 33			ld a, (.dmark+2)  
333e 32 73 ee			ld (debug_mark+2),a  
3341 18 03			jr .pastdmark  
3343 ..			.dmark: db "REP"  
3346 f1			.pastdmark: pop af  
3347			endm  
# End of macro DMARK
3347						;pop bc    ; TODO BUG ?????? what is this for???? 
3347						CALLMONITOR 
3347 cd a8 15			call break_point_state  
334a				endm  
# End of macro CALLMONITOR
334a					endif 
334a			 
334a					NEXTW 
334a c3 87 1f			jp macro_next 
334d				endm 
# End of macro NEXTW
334d			;	       NEXTW 
334d			 
334d			.UNTIL: 
334d				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
334d 72				db WORD_SYS_CORE+94             
334e e4 33			dw .ENDFLOW            
3350 06				db 5 + 1 
3351 .. 00			db "UNTIL",0              
3357				endm 
# End of macro CWHEAD
3357			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
3357			 
3357				; pop tos as check 
3357			 
3357				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3357			 
3357				FORTH_DSP_VALUEHL 
3357 cd 10 1e			call macro_dsp_valuehl 
335a				endm 
# End of macro FORTH_DSP_VALUEHL
335a			 
335a					if DEBUG_FORTH_WORDS_KEY 
335a						DMARK "UNT" 
335a f5				push af  
335b 3a 6f 33			ld a, (.dmark)  
335e 32 71 ee			ld (debug_mark),a  
3361 3a 70 33			ld a, (.dmark+1)  
3364 32 72 ee			ld (debug_mark+1),a  
3367 3a 71 33			ld a, (.dmark+2)  
336a 32 73 ee			ld (debug_mark+2),a  
336d 18 03			jr .pastdmark  
336f ..			.dmark: db "UNT"  
3372 f1			.pastdmark: pop af  
3373			endm  
# End of macro DMARK
3373						CALLMONITOR 
3373 cd a8 15			call break_point_state  
3376				endm  
# End of macro CALLMONITOR
3376					endif 
3376			 
3376			;	push hl 
3376				FORTH_DSP_POP 
3376 cd c8 1e			call macro_forth_dsp_pop 
3379				endm 
# End of macro FORTH_DSP_POP
3379			 
3379			;	pop hl 
3379			 
3379				; test if true 
3379			 
3379 cd d0 0d			call ishlzero 
337c			;	ld a,l 
337c			;	add h 
337c			; 
337c			;	cp 0 
337c			 
337c 20 3e			jr nz, .untilnotdone 
337e			 
337e					if DEBUG_FORTH_WORDS 
337e						DMARK "UNf" 
337e f5				push af  
337f 3a 93 33			ld a, (.dmark)  
3382 32 71 ee			ld (debug_mark),a  
3385 3a 94 33			ld a, (.dmark+1)  
3388 32 72 ee			ld (debug_mark+1),a  
338b 3a 95 33			ld a, (.dmark+2)  
338e 32 73 ee			ld (debug_mark+2),a  
3391 18 03			jr .pastdmark  
3393 ..			.dmark: db "UNf"  
3396 f1			.pastdmark: pop af  
3397			endm  
# End of macro DMARK
3397						CALLMONITOR 
3397 cd a8 15			call break_point_state  
339a				endm  
# End of macro CALLMONITOR
339a					endif 
339a			 
339a			 
339a			 
339a				FORTH_RSP_POP     ; get rid of DO ptr 
339a cd e1 1b			call macro_forth_rsp_pop 
339d				endm 
# End of macro FORTH_RSP_POP
339d			 
339d			if DEBUG_FORTH_WORDS 
339d						DMARK "UN>" 
339d f5				push af  
339e 3a b2 33			ld a, (.dmark)  
33a1 32 71 ee			ld (debug_mark),a  
33a4 3a b3 33			ld a, (.dmark+1)  
33a7 32 72 ee			ld (debug_mark+1),a  
33aa 3a b4 33			ld a, (.dmark+2)  
33ad 32 73 ee			ld (debug_mark+2),a  
33b0 18 03			jr .pastdmark  
33b2 ..			.dmark: db "UN>"  
33b5 f1			.pastdmark: pop af  
33b6			endm  
# End of macro DMARK
33b6				CALLMONITOR 
33b6 cd a8 15			call break_point_state  
33b9				endm  
# End of macro CALLMONITOR
33b9			endif 
33b9			 
33b9					NEXTW 
33b9 c3 87 1f			jp macro_next 
33bc				endm 
# End of macro NEXTW
33bc				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
33bc			 
33bc			.untilnotdone: 
33bc			 
33bc			 
33bc			;	; get DO ptr 
33bc			; 
33bc				FORTH_RSP_TOS 
33bc cd d7 1b			call macro_forth_rsp_tos 
33bf				endm 
# End of macro FORTH_RSP_TOS
33bf			 
33bf				;push hl 
33bf			 
33bf				; not going to DO any more 
33bf				; get rid of the RSP pointer as DO will add it back in 
33bf				;FORTH_RSP_POP 
33bf				;pop hl 
33bf			 
33bf			 
33bf 22 03 e6			ld (os_tok_ptr), hl 
33c2					if DEBUG_FORTH_WORDS 
33c2						DMARK "UN<" 
33c2 f5				push af  
33c3 3a d7 33			ld a, (.dmark)  
33c6 32 71 ee			ld (debug_mark),a  
33c9 3a d8 33			ld a, (.dmark+1)  
33cc 32 72 ee			ld (debug_mark+1),a  
33cf 3a d9 33			ld a, (.dmark+2)  
33d2 32 73 ee			ld (debug_mark+2),a  
33d5 18 03			jr .pastdmark  
33d7 ..			.dmark: db "UN<"  
33da f1			.pastdmark: pop af  
33db			endm  
# End of macro DMARK
33db					CALLMONITOR 
33db cd a8 15			call break_point_state  
33de				endm  
# End of macro CALLMONITOR
33de				endif 
33de c3 18 20			jp exec1 
33e1			 
33e1					 
33e1			 
33e1			 
33e1					NEXTW 
33e1 c3 87 1f			jp macro_next 
33e4				endm 
# End of macro NEXTW
33e4			 
33e4			 
33e4			.ENDFLOW: 
33e4			 
33e4			; eof 
33e4			 
# End of file forth_words_flow.asm
33e4			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
33e4			include "forth_words_logic.asm" 
33e4			 
33e4			; | ## Logic Words 
33e4			 
33e4			.NOT: 
33e4				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
33e4 2d				db WORD_SYS_CORE+25             
33e5 2c 34			dw .IS            
33e7 04				db 3 + 1 
33e8 .. 00			db "NOT",0              
33ec				endm 
# End of macro CWHEAD
33ec			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
33ec					if DEBUG_FORTH_WORDS_KEY 
33ec						DMARK "NOT" 
33ec f5				push af  
33ed 3a 01 34			ld a, (.dmark)  
33f0 32 71 ee			ld (debug_mark),a  
33f3 3a 02 34			ld a, (.dmark+1)  
33f6 32 72 ee			ld (debug_mark+1),a  
33f9 3a 03 34			ld a, (.dmark+2)  
33fc 32 73 ee			ld (debug_mark+2),a  
33ff 18 03			jr .pastdmark  
3401 ..			.dmark: db "NOT"  
3404 f1			.pastdmark: pop af  
3405			endm  
# End of macro DMARK
3405						CALLMONITOR 
3405 cd a8 15			call break_point_state  
3408				endm  
# End of macro CALLMONITOR
3408					endif 
3408					FORTH_DSP 
3408 cd d6 1d			call macro_forth_dsp 
340b				endm 
# End of macro FORTH_DSP
340b 7e					ld a,(hl)	; get type of value on TOS 
340c fe 02				cp DS_TYPE_INUM  
340e 28 03				jr z, .noti 
3410					NEXTW 
3410 c3 87 1f			jp macro_next 
3413				endm 
# End of macro NEXTW
3413			.noti:          FORTH_DSP_VALUEHL 
3413 cd 10 1e			call macro_dsp_valuehl 
3416				endm 
# End of macro FORTH_DSP_VALUEHL
3416			;		push hl 
3416					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3416 cd c8 1e			call macro_forth_dsp_pop 
3419				endm 
# End of macro FORTH_DSP_POP
3419			;		pop hl 
3419 3e 00				ld a,0 
341b bd					cp l 
341c 28 04				jr z, .not2t 
341e 2e 00				ld l, 0 
3420 18 02				jr .notip 
3422			 
3422 2e ff		.not2t:		ld l, 255 
3424			 
3424 26 00		.notip:		ld h, 0	 
3426			 
3426 cd 19 1c				call forth_push_numhl 
3429					NEXTW 
3429 c3 87 1f			jp macro_next 
342c				endm 
# End of macro NEXTW
342c			 
342c			.IS: 
342c				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
342c 2d				db WORD_SYS_CORE+25             
342d 52 34			dw .LZERO            
342f 03				db 2 + 1 
3430 .. 00			db "IS",0              
3433				endm 
# End of macro CWHEAD
3433			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
3433					if DEBUG_FORTH_WORDS_KEY 
3433						DMARK "IS." 
3433 f5				push af  
3434 3a 48 34			ld a, (.dmark)  
3437 32 71 ee			ld (debug_mark),a  
343a 3a 49 34			ld a, (.dmark+1)  
343d 32 72 ee			ld (debug_mark+1),a  
3440 3a 4a 34			ld a, (.dmark+2)  
3443 32 73 ee			ld (debug_mark+2),a  
3446 18 03			jr .pastdmark  
3448 ..			.dmark: db "IS."  
344b f1			.pastdmark: pop af  
344c			endm  
# End of macro DMARK
344c						CALLMONITOR 
344c cd a8 15			call break_point_state  
344f				endm  
# End of macro CALLMONITOR
344f					endif 
344f					NEXTW 
344f c3 87 1f			jp macro_next 
3452				endm 
# End of macro NEXTW
3452			.LZERO: 
3452				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
3452 2d				db WORD_SYS_CORE+25             
3453 5c 34			dw .TZERO            
3455 03				db 2 + 1 
3456 .. 00			db "0<",0              
3459				endm 
# End of macro CWHEAD
3459			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
3459					NEXTW 
3459 c3 87 1f			jp macro_next 
345c				endm 
# End of macro NEXTW
345c			.TZERO: 
345c				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
345c 2e				db WORD_SYS_CORE+26             
345d a3 34			dw .LESS            
345f 03				db 2 + 1 
3460 .. 00			db "0=",0              
3463				endm 
# End of macro CWHEAD
3463			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
3463				; TODO add floating point number detection 
3463					;v5 FORTH_DSP_VALUE 
3463					if DEBUG_FORTH_WORDS_KEY 
3463						DMARK "0=." 
3463 f5				push af  
3464 3a 78 34			ld a, (.dmark)  
3467 32 71 ee			ld (debug_mark),a  
346a 3a 79 34			ld a, (.dmark+1)  
346d 32 72 ee			ld (debug_mark+1),a  
3470 3a 7a 34			ld a, (.dmark+2)  
3473 32 73 ee			ld (debug_mark+2),a  
3476 18 03			jr .pastdmark  
3478 ..			.dmark: db "0=."  
347b f1			.pastdmark: pop af  
347c			endm  
# End of macro DMARK
347c						CALLMONITOR 
347c cd a8 15			call break_point_state  
347f				endm  
# End of macro CALLMONITOR
347f					endif 
347f					FORTH_DSP 
347f cd d6 1d			call macro_forth_dsp 
3482				endm 
# End of macro FORTH_DSP
3482 7e					ld a,(hl)	; get type of value on TOS 
3483 fe 02				cp DS_TYPE_INUM  
3485 28 00				jr z, .tz_inum 
3487			 
3487				if FORTH_ENABLE_FLOATMATH 
3487					jr .tz_done 
3487			 
3487				endif 
3487					 
3487			 
3487			.tz_inum: 
3487					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3487 cd 10 1e			call macro_dsp_valuehl 
348a				endm 
# End of macro FORTH_DSP_VALUEHL
348a			 
348a			;		push hl 
348a			 
348a					; destroy value TOS 
348a			 
348a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
348a cd c8 1e			call macro_forth_dsp_pop 
348d				endm 
# End of macro FORTH_DSP_POP
348d			 
348d			;		pop hl 
348d			 
348d 3e 00				ld a,0 
348f			 
348f bd					cp l 
3490 20 08				jr nz, .tz_notzero 
3492			 
3492 bc					cp h 
3493			 
3493 20 05				jr nz, .tz_notzero 
3495			 
3495			 
3495 21 01 00				ld hl, FORTH_TRUE 
3498 18 03				jr .tz_done 
349a			 
349a 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
349d			 
349d					; push value back onto stack for another op etc 
349d			 
349d			.tz_done: 
349d cd 19 1c				call forth_push_numhl 
34a0			 
34a0					NEXTW 
34a0 c3 87 1f			jp macro_next 
34a3				endm 
# End of macro NEXTW
34a3			.LESS: 
34a3				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
34a3 2f				db WORD_SYS_CORE+27             
34a4 0c 35			dw .GT            
34a6 02				db 1 + 1 
34a7 .. 00			db "<",0              
34a9				endm 
# End of macro CWHEAD
34a9			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
34a9				; TODO add floating point number detection 
34a9					if DEBUG_FORTH_WORDS_KEY 
34a9						DMARK "LES" 
34a9 f5				push af  
34aa 3a be 34			ld a, (.dmark)  
34ad 32 71 ee			ld (debug_mark),a  
34b0 3a bf 34			ld a, (.dmark+1)  
34b3 32 72 ee			ld (debug_mark+1),a  
34b6 3a c0 34			ld a, (.dmark+2)  
34b9 32 73 ee			ld (debug_mark+2),a  
34bc 18 03			jr .pastdmark  
34be ..			.dmark: db "LES"  
34c1 f1			.pastdmark: pop af  
34c2			endm  
# End of macro DMARK
34c2						CALLMONITOR 
34c2 cd a8 15			call break_point_state  
34c5				endm  
# End of macro CALLMONITOR
34c5					endif 
34c5					FORTH_DSP 
34c5 cd d6 1d			call macro_forth_dsp 
34c8				endm 
# End of macro FORTH_DSP
34c8					;v5 FORTH_DSP_VALUE 
34c8 7e					ld a,(hl)	; get type of value on TOS 
34c9 fe 02				cp DS_TYPE_INUM  
34cb 28 00				jr z, .less_inum 
34cd			 
34cd				if FORTH_ENABLE_FLOATMATH 
34cd					jr .less_done 
34cd			 
34cd				endif 
34cd					 
34cd			 
34cd			.less_inum: 
34cd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
34cd cd 10 1e			call macro_dsp_valuehl 
34d0				endm 
# End of macro FORTH_DSP_VALUEHL
34d0			 
34d0 e5					push hl  ; u2 
34d1			 
34d1					; destroy value TOS 
34d1			 
34d1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34d1 cd c8 1e			call macro_forth_dsp_pop 
34d4				endm 
# End of macro FORTH_DSP_POP
34d4			 
34d4			 
34d4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
34d4 cd 10 1e			call macro_dsp_valuehl 
34d7				endm 
# End of macro FORTH_DSP_VALUEHL
34d7			 
34d7 e5					push hl    ; u1 
34d8			 
34d8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34d8 cd c8 1e			call macro_forth_dsp_pop 
34db				endm 
# End of macro FORTH_DSP_POP
34db			 
34db			 
34db b7			 or a      ;clear carry flag 
34dc 01 00 00		 ld bc, FORTH_FALSE 
34df e1			  pop hl    ; u1 
34e0 d1			  pop de    ; u2 
34e1 ed 52		  sbc hl,de 
34e3 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
34e5			 
34e5 01 01 00		 ld bc, FORTH_TRUE 
34e8			.lscont:  
34e8 c5					push bc 
34e9 e1					pop hl 
34ea			 
34ea					if DEBUG_FORTH_WORDS 
34ea						DMARK "LT1" 
34ea f5				push af  
34eb 3a ff 34			ld a, (.dmark)  
34ee 32 71 ee			ld (debug_mark),a  
34f1 3a 00 35			ld a, (.dmark+1)  
34f4 32 72 ee			ld (debug_mark+1),a  
34f7 3a 01 35			ld a, (.dmark+2)  
34fa 32 73 ee			ld (debug_mark+2),a  
34fd 18 03			jr .pastdmark  
34ff ..			.dmark: db "LT1"  
3502 f1			.pastdmark: pop af  
3503			endm  
# End of macro DMARK
3503						CALLMONITOR 
3503 cd a8 15			call break_point_state  
3506				endm  
# End of macro CALLMONITOR
3506					endif 
3506 cd 19 1c				call forth_push_numhl 
3509			 
3509					NEXTW 
3509 c3 87 1f			jp macro_next 
350c				endm 
# End of macro NEXTW
350c			.GT: 
350c				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
350c 30				db WORD_SYS_CORE+28             
350d 75 35			dw .EQUAL            
350f 02				db 1 + 1 
3510 .. 00			db ">",0              
3512				endm 
# End of macro CWHEAD
3512			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
3512				; TODO add floating point number detection 
3512					if DEBUG_FORTH_WORDS_KEY 
3512						DMARK "GRT" 
3512 f5				push af  
3513 3a 27 35			ld a, (.dmark)  
3516 32 71 ee			ld (debug_mark),a  
3519 3a 28 35			ld a, (.dmark+1)  
351c 32 72 ee			ld (debug_mark+1),a  
351f 3a 29 35			ld a, (.dmark+2)  
3522 32 73 ee			ld (debug_mark+2),a  
3525 18 03			jr .pastdmark  
3527 ..			.dmark: db "GRT"  
352a f1			.pastdmark: pop af  
352b			endm  
# End of macro DMARK
352b						CALLMONITOR 
352b cd a8 15			call break_point_state  
352e				endm  
# End of macro CALLMONITOR
352e					endif 
352e					FORTH_DSP 
352e cd d6 1d			call macro_forth_dsp 
3531				endm 
# End of macro FORTH_DSP
3531					;FORTH_DSP_VALUE 
3531 7e					ld a,(hl)	; get type of value on TOS 
3532 fe 02				cp DS_TYPE_INUM  
3534 28 00				jr z, .gt_inum 
3536			 
3536				if FORTH_ENABLE_FLOATMATH 
3536					jr .gt_done 
3536			 
3536				endif 
3536					 
3536			 
3536			.gt_inum: 
3536					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3536 cd 10 1e			call macro_dsp_valuehl 
3539				endm 
# End of macro FORTH_DSP_VALUEHL
3539			 
3539 e5					push hl  ; u2 
353a			 
353a					; destroy value TOS 
353a			 
353a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
353a cd c8 1e			call macro_forth_dsp_pop 
353d				endm 
# End of macro FORTH_DSP_POP
353d			 
353d			 
353d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
353d cd 10 1e			call macro_dsp_valuehl 
3540				endm 
# End of macro FORTH_DSP_VALUEHL
3540			 
3540 e5					push hl    ; u1 
3541			 
3541					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3541 cd c8 1e			call macro_forth_dsp_pop 
3544				endm 
# End of macro FORTH_DSP_POP
3544			 
3544			 
3544 b7			 or a      ;clear carry flag 
3545 01 00 00		 ld bc, FORTH_FALSE 
3548 e1			  pop hl    ; u1 
3549 d1			  pop de    ; u2 
354a ed 52		  sbc hl,de 
354c 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
354e			 
354e 01 01 00		 ld bc, FORTH_TRUE 
3551			.gtcont:  
3551 c5					push bc 
3552 e1					pop hl 
3553			 
3553					if DEBUG_FORTH_WORDS 
3553						DMARK "GT1" 
3553 f5				push af  
3554 3a 68 35			ld a, (.dmark)  
3557 32 71 ee			ld (debug_mark),a  
355a 3a 69 35			ld a, (.dmark+1)  
355d 32 72 ee			ld (debug_mark+1),a  
3560 3a 6a 35			ld a, (.dmark+2)  
3563 32 73 ee			ld (debug_mark+2),a  
3566 18 03			jr .pastdmark  
3568 ..			.dmark: db "GT1"  
356b f1			.pastdmark: pop af  
356c			endm  
# End of macro DMARK
356c						CALLMONITOR 
356c cd a8 15			call break_point_state  
356f				endm  
# End of macro CALLMONITOR
356f					endif 
356f cd 19 1c				call forth_push_numhl 
3572			 
3572					NEXTW 
3572 c3 87 1f			jp macro_next 
3575				endm 
# End of macro NEXTW
3575			.EQUAL: 
3575				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3575 31				db WORD_SYS_CORE+29             
3576 e0 35			dw .ENDLOGIC            
3578 02				db 1 + 1 
3579 .. 00			db "=",0              
357b				endm 
# End of macro CWHEAD
357b			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
357b				; TODO add floating point number detection 
357b					if DEBUG_FORTH_WORDS_KEY 
357b						DMARK "EQ." 
357b f5				push af  
357c 3a 90 35			ld a, (.dmark)  
357f 32 71 ee			ld (debug_mark),a  
3582 3a 91 35			ld a, (.dmark+1)  
3585 32 72 ee			ld (debug_mark+1),a  
3588 3a 92 35			ld a, (.dmark+2)  
358b 32 73 ee			ld (debug_mark+2),a  
358e 18 03			jr .pastdmark  
3590 ..			.dmark: db "EQ."  
3593 f1			.pastdmark: pop af  
3594			endm  
# End of macro DMARK
3594						CALLMONITOR 
3594 cd a8 15			call break_point_state  
3597				endm  
# End of macro CALLMONITOR
3597					endif 
3597					FORTH_DSP 
3597 cd d6 1d			call macro_forth_dsp 
359a				endm 
# End of macro FORTH_DSP
359a					;v5 FORTH_DSP_VALUE 
359a 7e					ld a,(hl)	; get type of value on TOS 
359b fe 02				cp DS_TYPE_INUM  
359d 28 00				jr z, .eq_inum 
359f			 
359f				if FORTH_ENABLE_FLOATMATH 
359f					jr .eq_done 
359f			 
359f				endif 
359f					 
359f			 
359f			.eq_inum: 
359f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
359f cd 10 1e			call macro_dsp_valuehl 
35a2				endm 
# End of macro FORTH_DSP_VALUEHL
35a2			 
35a2 e5					push hl 
35a3			 
35a3					; destroy value TOS 
35a3			 
35a3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35a3 cd c8 1e			call macro_forth_dsp_pop 
35a6				endm 
# End of macro FORTH_DSP_POP
35a6			 
35a6			 
35a6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35a6 cd 10 1e			call macro_dsp_valuehl 
35a9				endm 
# End of macro FORTH_DSP_VALUEHL
35a9			 
35a9					; one value on hl get other one back 
35a9			 
35a9 e5					push hl 
35aa			 
35aa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35aa cd c8 1e			call macro_forth_dsp_pop 
35ad				endm 
# End of macro FORTH_DSP_POP
35ad			 
35ad 0e 00				ld c, FORTH_FALSE 
35af			 
35af e1					pop hl 
35b0 d1					pop de 
35b1			 
35b1 7b					ld a, e 
35b2 bd					cp l 
35b3			 
35b3 20 06				jr nz, .eq_done 
35b5			 
35b5 7a					ld a, d 
35b6 bc					cp h 
35b7			 
35b7 20 02				jr nz, .eq_done 
35b9			 
35b9 0e 01				ld c, FORTH_TRUE 
35bb					 
35bb			 
35bb			 
35bb			.eq_done: 
35bb			 
35bb					; TODO push value back onto stack for another op etc 
35bb			 
35bb 26 00				ld h, 0 
35bd 69					ld l, c 
35be					if DEBUG_FORTH_WORDS 
35be						DMARK "EQ1" 
35be f5				push af  
35bf 3a d3 35			ld a, (.dmark)  
35c2 32 71 ee			ld (debug_mark),a  
35c5 3a d4 35			ld a, (.dmark+1)  
35c8 32 72 ee			ld (debug_mark+1),a  
35cb 3a d5 35			ld a, (.dmark+2)  
35ce 32 73 ee			ld (debug_mark+2),a  
35d1 18 03			jr .pastdmark  
35d3 ..			.dmark: db "EQ1"  
35d6 f1			.pastdmark: pop af  
35d7			endm  
# End of macro DMARK
35d7						CALLMONITOR 
35d7 cd a8 15			call break_point_state  
35da				endm  
# End of macro CALLMONITOR
35da					endif 
35da cd 19 1c				call forth_push_numhl 
35dd			 
35dd					NEXTW 
35dd c3 87 1f			jp macro_next 
35e0				endm 
# End of macro NEXTW
35e0			 
35e0			 
35e0			.ENDLOGIC: 
35e0			; eof 
35e0			 
35e0			 
# End of file forth_words_logic.asm
35e0			include "forth_words_maths.asm" 
35e0			 
35e0			; | ## Maths Words 
35e0			 
35e0			.PLUS:	 
35e0				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
35e0 15				db WORD_SYS_CORE+1             
35e1 22 36			dw .NEG            
35e3 02				db 1 + 1 
35e4 .. 00			db "+",0              
35e6				endm 
# End of macro CWHEAD
35e6			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
35e6					if DEBUG_FORTH_WORDS_KEY 
35e6						DMARK "PLU" 
35e6 f5				push af  
35e7 3a fb 35			ld a, (.dmark)  
35ea 32 71 ee			ld (debug_mark),a  
35ed 3a fc 35			ld a, (.dmark+1)  
35f0 32 72 ee			ld (debug_mark+1),a  
35f3 3a fd 35			ld a, (.dmark+2)  
35f6 32 73 ee			ld (debug_mark+2),a  
35f9 18 03			jr .pastdmark  
35fb ..			.dmark: db "PLU"  
35fe f1			.pastdmark: pop af  
35ff			endm  
# End of macro DMARK
35ff						CALLMONITOR 
35ff cd a8 15			call break_point_state  
3602				endm  
# End of macro CALLMONITOR
3602					endif 
3602					; add top two values and push back result 
3602			 
3602					;for v5 FORTH_DSP_VALUE 
3602					FORTH_DSP 
3602 cd d6 1d			call macro_forth_dsp 
3605				endm 
# End of macro FORTH_DSP
3605 7e					ld a,(hl)	; get type of value on TOS 
3606 fe 02				cp DS_TYPE_INUM  
3608 28 03				jr z, .dot_inum 
360a			 
360a					NEXTW 
360a c3 87 1f			jp macro_next 
360d				endm 
# End of macro NEXTW
360d			 
360d			; float maths 
360d			 
360d				if FORTH_ENABLE_FLOATMATH 
360d						inc hl      ; now at start of numeric as string 
360d			 
360d					if DEBUG_FORTH_MATHS 
360d						DMARK "ADD" 
360d				CALLMONITOR 
360d					endif 
360d			 
360d					;ld ix, hl 
360d					call CON 
360d			 
360d			 
360d					push hl 
360d					 
360d					 
360d			 
360d						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
360d			 
360d					; get next number 
360d			 
360d						FORTH_DSP_VALUE 
360d			 
360d						inc hl      ; now at start of numeric as string 
360d			 
360d					;ld ix, hl 
360d					call CON 
360d			 
360d					push hl 
360d			 
360d			 
360d						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
360d			 
360d						; TODO do add 
360d			 
360d						call IADD 
360d			 
360d						; TODO get result back as ascii 
360d			 
360d						; TODO push result  
360d			 
360d			 
360d			 
360d						jr .dot_done 
360d				endif 
360d			 
360d			.dot_inum: 
360d			 
360d			 
360d					if DEBUG_FORTH_DOT 
360d						DMARK "+IT" 
360d				CALLMONITOR 
360d					endif 
360d			 
360d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
360d cd 10 1e			call macro_dsp_valuehl 
3610				endm 
# End of macro FORTH_DSP_VALUEHL
3610			 
3610				; TODO add floating point number detection 
3610			 
3610 e5					push hl 
3611			 
3611					; destroy value TOS 
3611			 
3611					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3611 cd c8 1e			call macro_forth_dsp_pop 
3614				endm 
# End of macro FORTH_DSP_POP
3614			 
3614			 
3614					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3614 cd 10 1e			call macro_dsp_valuehl 
3617				endm 
# End of macro FORTH_DSP_VALUEHL
3617			 
3617					; one value on hl get other one back 
3617			 
3617 d1					pop de 
3618			 
3618					; do the add 
3618			 
3618 19					add hl,de 
3619			 
3619					; save it 
3619			 
3619			;		push hl	 
3619			 
3619					; 
3619			 
3619					; destroy value TOS 
3619			 
3619					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3619 cd c8 1e			call macro_forth_dsp_pop 
361c				endm 
# End of macro FORTH_DSP_POP
361c			 
361c					; TODO push value back onto stack for another op etc 
361c			 
361c			;		pop hl 
361c			 
361c			.dot_done: 
361c cd 19 1c				call forth_push_numhl 
361f			 
361f					NEXTW 
361f c3 87 1f			jp macro_next 
3622				endm 
# End of macro NEXTW
3622			.NEG: 
3622			 
3622				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
3622 17				db WORD_SYS_CORE+3             
3623 65 36			dw .DIV            
3625 02				db 1 + 1 
3626 .. 00			db "-",0              
3628				endm 
# End of macro CWHEAD
3628			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3628					if DEBUG_FORTH_WORDS_KEY 
3628						DMARK "SUB" 
3628 f5				push af  
3629 3a 3d 36			ld a, (.dmark)  
362c 32 71 ee			ld (debug_mark),a  
362f 3a 3e 36			ld a, (.dmark+1)  
3632 32 72 ee			ld (debug_mark+1),a  
3635 3a 3f 36			ld a, (.dmark+2)  
3638 32 73 ee			ld (debug_mark+2),a  
363b 18 03			jr .pastdmark  
363d ..			.dmark: db "SUB"  
3640 f1			.pastdmark: pop af  
3641			endm  
# End of macro DMARK
3641						CALLMONITOR 
3641 cd a8 15			call break_point_state  
3644				endm  
# End of macro CALLMONITOR
3644					endif 
3644			 
3644			 
3644				; TODO add floating point number detection 
3644					; v5 FORTH_DSP_VALUE 
3644					FORTH_DSP 
3644 cd d6 1d			call macro_forth_dsp 
3647				endm 
# End of macro FORTH_DSP
3647 7e					ld a,(hl)	; get type of value on TOS 
3648 fe 02				cp DS_TYPE_INUM  
364a 28 03				jr z, .neg_inum 
364c			 
364c					NEXTW 
364c c3 87 1f			jp macro_next 
364f				endm 
# End of macro NEXTW
364f			 
364f			; float maths 
364f			 
364f				if FORTH_ENABLE_FLOATMATH 
364f					jr .neg_done 
364f			 
364f				endif 
364f					 
364f			 
364f			.neg_inum: 
364f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
364f cd 10 1e			call macro_dsp_valuehl 
3652				endm 
# End of macro FORTH_DSP_VALUEHL
3652			 
3652 e5					push hl 
3653			 
3653					; destroy value TOS 
3653			 
3653					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3653 cd c8 1e			call macro_forth_dsp_pop 
3656				endm 
# End of macro FORTH_DSP_POP
3656			 
3656			 
3656					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3656 cd 10 1e			call macro_dsp_valuehl 
3659				endm 
# End of macro FORTH_DSP_VALUEHL
3659			 
3659					; one value on hl get other one back 
3659			 
3659 d1					pop de 
365a			 
365a					; do the sub 
365a			;		ex de, hl 
365a			 
365a ed 52				sbc hl,de 
365c			 
365c					; save it 
365c			 
365c			;		push hl	 
365c			 
365c					; 
365c			 
365c					; destroy value TOS 
365c			 
365c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
365c cd c8 1e			call macro_forth_dsp_pop 
365f				endm 
# End of macro FORTH_DSP_POP
365f			 
365f					; TODO push value back onto stack for another op etc 
365f			 
365f			;		pop hl 
365f			 
365f cd 19 1c				call forth_push_numhl 
3662			.neg_done: 
3662			 
3662					NEXTW 
3662 c3 87 1f			jp macro_next 
3665				endm 
# End of macro NEXTW
3665			.DIV: 
3665				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3665 18				db WORD_SYS_CORE+4             
3666 b2 36			dw .MUL            
3668 02				db 1 + 1 
3669 .. 00			db "/",0              
366b				endm 
# End of macro CWHEAD
366b			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
366b					if DEBUG_FORTH_WORDS_KEY 
366b						DMARK "DIV" 
366b f5				push af  
366c 3a 80 36			ld a, (.dmark)  
366f 32 71 ee			ld (debug_mark),a  
3672 3a 81 36			ld a, (.dmark+1)  
3675 32 72 ee			ld (debug_mark+1),a  
3678 3a 82 36			ld a, (.dmark+2)  
367b 32 73 ee			ld (debug_mark+2),a  
367e 18 03			jr .pastdmark  
3680 ..			.dmark: db "DIV"  
3683 f1			.pastdmark: pop af  
3684			endm  
# End of macro DMARK
3684						CALLMONITOR 
3684 cd a8 15			call break_point_state  
3687				endm  
# End of macro CALLMONITOR
3687					endif 
3687				; TODO add floating point number detection 
3687					; v5 FORTH_DSP_VALUE 
3687					FORTH_DSP 
3687 cd d6 1d			call macro_forth_dsp 
368a				endm 
# End of macro FORTH_DSP
368a 7e					ld a,(hl)	; get type of value on TOS 
368b fe 02				cp DS_TYPE_INUM  
368d 28 03				jr z, .div_inum 
368f			 
368f				if FORTH_ENABLE_FLOATMATH 
368f					jr .div_done 
368f			 
368f				endif 
368f					NEXTW 
368f c3 87 1f			jp macro_next 
3692				endm 
# End of macro NEXTW
3692			.div_inum: 
3692			 
3692					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3692 cd 10 1e			call macro_dsp_valuehl 
3695				endm 
# End of macro FORTH_DSP_VALUEHL
3695			 
3695 e5					push hl    ; to go to bc 
3696			 
3696					; destroy value TOS 
3696			 
3696					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3696 cd c8 1e			call macro_forth_dsp_pop 
3699				endm 
# End of macro FORTH_DSP_POP
3699			 
3699			 
3699					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3699 cd 10 1e			call macro_dsp_valuehl 
369c				endm 
# End of macro FORTH_DSP_VALUEHL
369c			 
369c					; hl to go to de 
369c			 
369c e5					push hl 
369d			 
369d c1					pop bc 
369e d1					pop de		 
369f			 
369f			 
369f					if DEBUG_FORTH_MATHS 
369f						DMARK "DIV" 
369f				CALLMONITOR 
369f					endif 
369f					; one value on hl but move to a get other one back 
369f			 
369f			        
369f cd 04 0d			call Div16 
36a2			 
36a2			;	push af	 
36a2 e5				push hl 
36a3 c5				push bc 
36a4			 
36a4					if DEBUG_FORTH_MATHS 
36a4						DMARK "DI1" 
36a4				CALLMONITOR 
36a4					endif 
36a4			 
36a4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36a4 cd c8 1e			call macro_forth_dsp_pop 
36a7				endm 
# End of macro FORTH_DSP_POP
36a7			 
36a7			 
36a7			 
36a7 e1					pop hl    ; result 
36a8			 
36a8 cd 19 1c				call forth_push_numhl 
36ab			 
36ab e1					pop hl    ; reminder 
36ac			;		ld h,0 
36ac			;		ld l,d 
36ac			 
36ac cd 19 1c				call forth_push_numhl 
36af			.div_done: 
36af					NEXTW 
36af c3 87 1f			jp macro_next 
36b2				endm 
# End of macro NEXTW
36b2			.MUL: 
36b2				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
36b2 19				db WORD_SYS_CORE+5             
36b3 f7 36			dw .MIN            
36b5 02				db 1 + 1 
36b6 .. 00			db "*",0              
36b8				endm 
# End of macro CWHEAD
36b8			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
36b8				; TODO add floating point number detection 
36b8					if DEBUG_FORTH_WORDS_KEY 
36b8						DMARK "MUL" 
36b8 f5				push af  
36b9 3a cd 36			ld a, (.dmark)  
36bc 32 71 ee			ld (debug_mark),a  
36bf 3a ce 36			ld a, (.dmark+1)  
36c2 32 72 ee			ld (debug_mark+1),a  
36c5 3a cf 36			ld a, (.dmark+2)  
36c8 32 73 ee			ld (debug_mark+2),a  
36cb 18 03			jr .pastdmark  
36cd ..			.dmark: db "MUL"  
36d0 f1			.pastdmark: pop af  
36d1			endm  
# End of macro DMARK
36d1						CALLMONITOR 
36d1 cd a8 15			call break_point_state  
36d4				endm  
# End of macro CALLMONITOR
36d4					endif 
36d4					FORTH_DSP 
36d4 cd d6 1d			call macro_forth_dsp 
36d7				endm 
# End of macro FORTH_DSP
36d7					; v5 FORTH_DSP_VALUE 
36d7 7e					ld a,(hl)	; get type of value on TOS 
36d8 fe 02				cp DS_TYPE_INUM  
36da 28 03				jr z, .mul_inum 
36dc			 
36dc				if FORTH_ENABLE_FLOATMATH 
36dc					jr .mul_done 
36dc			 
36dc				endif 
36dc			 
36dc					NEXTW 
36dc c3 87 1f			jp macro_next 
36df				endm 
# End of macro NEXTW
36df			.mul_inum:	 
36df			 
36df					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36df cd 10 1e			call macro_dsp_valuehl 
36e2				endm 
# End of macro FORTH_DSP_VALUEHL
36e2			 
36e2 e5					push hl 
36e3			 
36e3					; destroy value TOS 
36e3			 
36e3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36e3 cd c8 1e			call macro_forth_dsp_pop 
36e6				endm 
# End of macro FORTH_DSP_POP
36e6			 
36e6			 
36e6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36e6 cd 10 1e			call macro_dsp_valuehl 
36e9				endm 
# End of macro FORTH_DSP_VALUEHL
36e9			 
36e9					; one value on hl but move to a get other one back 
36e9			 
36e9 7d					ld a, l 
36ea			 
36ea d1					pop de 
36eb			 
36eb					; do the mull 
36eb			;		ex de, hl 
36eb			 
36eb cd 2a 0d				call Mult16 
36ee					; save it 
36ee			 
36ee			;		push hl	 
36ee			 
36ee					; 
36ee			 
36ee					; destroy value TOS 
36ee			 
36ee					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36ee cd c8 1e			call macro_forth_dsp_pop 
36f1				endm 
# End of macro FORTH_DSP_POP
36f1			 
36f1					; TODO push value back onto stack for another op etc 
36f1			 
36f1			;		pop hl 
36f1			 
36f1 cd 19 1c				call forth_push_numhl 
36f4			 
36f4			.mul_done: 
36f4					NEXTW 
36f4 c3 87 1f			jp macro_next 
36f7				endm 
# End of macro NEXTW
36f7			 
36f7			 
36f7			 
36f7			 
36f7			.MIN: 
36f7				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
36f7 49				db WORD_SYS_CORE+53             
36f8 78 37			dw .MAX            
36fa 04				db 3 + 1 
36fb .. 00			db "MIN",0              
36ff				endm 
# End of macro CWHEAD
36ff			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
36ff					if DEBUG_FORTH_WORDS_KEY 
36ff						DMARK "MIN" 
36ff f5				push af  
3700 3a 14 37			ld a, (.dmark)  
3703 32 71 ee			ld (debug_mark),a  
3706 3a 15 37			ld a, (.dmark+1)  
3709 32 72 ee			ld (debug_mark+1),a  
370c 3a 16 37			ld a, (.dmark+2)  
370f 32 73 ee			ld (debug_mark+2),a  
3712 18 03			jr .pastdmark  
3714 ..			.dmark: db "MIN"  
3717 f1			.pastdmark: pop af  
3718			endm  
# End of macro DMARK
3718						CALLMONITOR 
3718 cd a8 15			call break_point_state  
371b				endm  
# End of macro CALLMONITOR
371b					endif 
371b					; get u2 
371b			 
371b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
371b cd 10 1e			call macro_dsp_valuehl 
371e				endm 
# End of macro FORTH_DSP_VALUEHL
371e			 
371e e5					push hl   ; u2 
371f			 
371f					; destroy value TOS 
371f			 
371f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
371f cd c8 1e			call macro_forth_dsp_pop 
3722				endm 
# End of macro FORTH_DSP_POP
3722			 
3722					; get u1 
3722			 
3722					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3722 cd 10 1e			call macro_dsp_valuehl 
3725				endm 
# End of macro FORTH_DSP_VALUEHL
3725			 
3725 e5					push hl  ; u1 
3726			 
3726					; destroy value TOS 
3726			 
3726					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3726 cd c8 1e			call macro_forth_dsp_pop 
3729				endm 
# End of macro FORTH_DSP_POP
3729			 
3729 b7			 or a      ;clear carry flag 
372a e1			  pop hl    ; u1 
372b d1			  pop de    ; u2 
372c e5				push hl   ; saved in case hl is lowest 
372d ed 52		  sbc hl,de 
372f 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3731			 
3731 e1				pop hl 
3732					if DEBUG_FORTH_WORDS 
3732						DMARK "MIN" 
3732 f5				push af  
3733 3a 47 37			ld a, (.dmark)  
3736 32 71 ee			ld (debug_mark),a  
3739 3a 48 37			ld a, (.dmark+1)  
373c 32 72 ee			ld (debug_mark+1),a  
373f 3a 49 37			ld a, (.dmark+2)  
3742 32 73 ee			ld (debug_mark+2),a  
3745 18 03			jr .pastdmark  
3747 ..			.dmark: db "MIN"  
374a f1			.pastdmark: pop af  
374b			endm  
# End of macro DMARK
374b						CALLMONITOR 
374b cd a8 15			call break_point_state  
374e				endm  
# End of macro CALLMONITOR
374e					endif 
374e cd 19 1c				call forth_push_numhl 
3751			 
3751				       NEXTW 
3751 c3 87 1f			jp macro_next 
3754				endm 
# End of macro NEXTW
3754			 
3754			.mincont:  
3754 c1				pop bc   ; tidy up 
3755 eb				ex de , hl  
3756					if DEBUG_FORTH_WORDS 
3756						DMARK "MI1" 
3756 f5				push af  
3757 3a 6b 37			ld a, (.dmark)  
375a 32 71 ee			ld (debug_mark),a  
375d 3a 6c 37			ld a, (.dmark+1)  
3760 32 72 ee			ld (debug_mark+1),a  
3763 3a 6d 37			ld a, (.dmark+2)  
3766 32 73 ee			ld (debug_mark+2),a  
3769 18 03			jr .pastdmark  
376b ..			.dmark: db "MI1"  
376e f1			.pastdmark: pop af  
376f			endm  
# End of macro DMARK
376f						CALLMONITOR 
376f cd a8 15			call break_point_state  
3772				endm  
# End of macro CALLMONITOR
3772					endif 
3772 cd 19 1c				call forth_push_numhl 
3775			 
3775				       NEXTW 
3775 c3 87 1f			jp macro_next 
3778				endm 
# End of macro NEXTW
3778			.MAX: 
3778				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3778 4a				db WORD_SYS_CORE+54             
3779 f9 37			dw .RND16            
377b 04				db 3 + 1 
377c .. 00			db "MAX",0              
3780				endm 
# End of macro CWHEAD
3780			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3780					if DEBUG_FORTH_WORDS_KEY 
3780						DMARK "MAX" 
3780 f5				push af  
3781 3a 95 37			ld a, (.dmark)  
3784 32 71 ee			ld (debug_mark),a  
3787 3a 96 37			ld a, (.dmark+1)  
378a 32 72 ee			ld (debug_mark+1),a  
378d 3a 97 37			ld a, (.dmark+2)  
3790 32 73 ee			ld (debug_mark+2),a  
3793 18 03			jr .pastdmark  
3795 ..			.dmark: db "MAX"  
3798 f1			.pastdmark: pop af  
3799			endm  
# End of macro DMARK
3799						CALLMONITOR 
3799 cd a8 15			call break_point_state  
379c				endm  
# End of macro CALLMONITOR
379c					endif 
379c					; get u2 
379c			 
379c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
379c cd 10 1e			call macro_dsp_valuehl 
379f				endm 
# End of macro FORTH_DSP_VALUEHL
379f			 
379f e5					push hl   ; u2 
37a0			 
37a0					; destroy value TOS 
37a0			 
37a0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37a0 cd c8 1e			call macro_forth_dsp_pop 
37a3				endm 
# End of macro FORTH_DSP_POP
37a3			 
37a3					; get u1 
37a3			 
37a3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37a3 cd 10 1e			call macro_dsp_valuehl 
37a6				endm 
# End of macro FORTH_DSP_VALUEHL
37a6			 
37a6 e5					push hl  ; u1 
37a7			 
37a7					; destroy value TOS 
37a7			 
37a7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37a7 cd c8 1e			call macro_forth_dsp_pop 
37aa				endm 
# End of macro FORTH_DSP_POP
37aa			 
37aa b7			 or a      ;clear carry flag 
37ab e1			  pop hl    ; u1 
37ac d1			  pop de    ; u2 
37ad e5				push hl   ; saved in case hl is lowest 
37ae ed 52		  sbc hl,de 
37b0 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
37b2			 
37b2 e1				pop hl 
37b3					if DEBUG_FORTH_WORDS 
37b3						DMARK "MAX" 
37b3 f5				push af  
37b4 3a c8 37			ld a, (.dmark)  
37b7 32 71 ee			ld (debug_mark),a  
37ba 3a c9 37			ld a, (.dmark+1)  
37bd 32 72 ee			ld (debug_mark+1),a  
37c0 3a ca 37			ld a, (.dmark+2)  
37c3 32 73 ee			ld (debug_mark+2),a  
37c6 18 03			jr .pastdmark  
37c8 ..			.dmark: db "MAX"  
37cb f1			.pastdmark: pop af  
37cc			endm  
# End of macro DMARK
37cc						CALLMONITOR 
37cc cd a8 15			call break_point_state  
37cf				endm  
# End of macro CALLMONITOR
37cf					endif 
37cf cd 19 1c				call forth_push_numhl 
37d2			 
37d2				       NEXTW 
37d2 c3 87 1f			jp macro_next 
37d5				endm 
# End of macro NEXTW
37d5			 
37d5			.maxcont:  
37d5 c1				pop bc   ; tidy up 
37d6 eb				ex de , hl  
37d7					if DEBUG_FORTH_WORDS 
37d7						DMARK "MA1" 
37d7 f5				push af  
37d8 3a ec 37			ld a, (.dmark)  
37db 32 71 ee			ld (debug_mark),a  
37de 3a ed 37			ld a, (.dmark+1)  
37e1 32 72 ee			ld (debug_mark+1),a  
37e4 3a ee 37			ld a, (.dmark+2)  
37e7 32 73 ee			ld (debug_mark+2),a  
37ea 18 03			jr .pastdmark  
37ec ..			.dmark: db "MA1"  
37ef f1			.pastdmark: pop af  
37f0			endm  
# End of macro DMARK
37f0						CALLMONITOR 
37f0 cd a8 15			call break_point_state  
37f3				endm  
# End of macro CALLMONITOR
37f3					endif 
37f3 cd 19 1c				call forth_push_numhl 
37f6				       NEXTW 
37f6 c3 87 1f			jp macro_next 
37f9				endm 
# End of macro NEXTW
37f9			 
37f9			.RND16: 
37f9				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
37f9 4e				db WORD_SYS_CORE+58             
37fa 28 38			dw .RND8            
37fc 06				db 5 + 1 
37fd .. 00			db "RND16",0              
3803				endm 
# End of macro CWHEAD
3803			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3803					if DEBUG_FORTH_WORDS_KEY 
3803						DMARK "R16" 
3803 f5				push af  
3804 3a 18 38			ld a, (.dmark)  
3807 32 71 ee			ld (debug_mark),a  
380a 3a 19 38			ld a, (.dmark+1)  
380d 32 72 ee			ld (debug_mark+1),a  
3810 3a 1a 38			ld a, (.dmark+2)  
3813 32 73 ee			ld (debug_mark+2),a  
3816 18 03			jr .pastdmark  
3818 ..			.dmark: db "R16"  
381b f1			.pastdmark: pop af  
381c			endm  
# End of macro DMARK
381c						CALLMONITOR 
381c cd a8 15			call break_point_state  
381f				endm  
# End of macro CALLMONITOR
381f					endif 
381f cd ce 0c				call prng16  
3822 cd 19 1c				call forth_push_numhl 
3825				       NEXTW 
3825 c3 87 1f			jp macro_next 
3828				endm 
# End of macro NEXTW
3828			.RND8: 
3828				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3828 60				db WORD_SYS_CORE+76             
3829 5d 38			dw .RND            
382b 05				db 4 + 1 
382c .. 00			db "RND8",0              
3831				endm 
# End of macro CWHEAD
3831			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3831					if DEBUG_FORTH_WORDS_KEY 
3831						DMARK "RN8" 
3831 f5				push af  
3832 3a 46 38			ld a, (.dmark)  
3835 32 71 ee			ld (debug_mark),a  
3838 3a 47 38			ld a, (.dmark+1)  
383b 32 72 ee			ld (debug_mark+1),a  
383e 3a 48 38			ld a, (.dmark+2)  
3841 32 73 ee			ld (debug_mark+2),a  
3844 18 03			jr .pastdmark  
3846 ..			.dmark: db "RN8"  
3849 f1			.pastdmark: pop af  
384a			endm  
# End of macro DMARK
384a						CALLMONITOR 
384a cd a8 15			call break_point_state  
384d				endm  
# End of macro CALLMONITOR
384d					endif 
384d 2a b2 eb				ld hl,(xrandc) 
3850 23					inc hl 
3851 cd e8 0c				call xrnd 
3854 6f					ld l,a	 
3855 26 00				ld h,0 
3857 cd 19 1c				call forth_push_numhl 
385a				       NEXTW 
385a c3 87 1f			jp macro_next 
385d				endm 
# End of macro NEXTW
385d			.RND: 
385d				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
385d 60				db WORD_SYS_CORE+76             
385e 63 39			dw .ENDMATHS            
3860 04				db 3 + 1 
3861 .. 00			db "RND",0              
3865				endm 
# End of macro CWHEAD
3865			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3865			 
3865					if DEBUG_FORTH_WORDS_KEY 
3865						DMARK "RND" 
3865 f5				push af  
3866 3a 7a 38			ld a, (.dmark)  
3869 32 71 ee			ld (debug_mark),a  
386c 3a 7b 38			ld a, (.dmark+1)  
386f 32 72 ee			ld (debug_mark+1),a  
3872 3a 7c 38			ld a, (.dmark+2)  
3875 32 73 ee			ld (debug_mark+2),a  
3878 18 03			jr .pastdmark  
387a ..			.dmark: db "RND"  
387d f1			.pastdmark: pop af  
387e			endm  
# End of macro DMARK
387e						CALLMONITOR 
387e cd a8 15			call break_point_state  
3881				endm  
# End of macro CALLMONITOR
3881					endif 
3881					 
3881					FORTH_DSP_VALUEHL    ; upper range 
3881 cd 10 1e			call macro_dsp_valuehl 
3884				endm 
# End of macro FORTH_DSP_VALUEHL
3884			 
3884 22 b6 eb				ld (LFSRSeed), hl	 
3887			 
3887					if DEBUG_FORTH_WORDS 
3887						DMARK "RN1" 
3887 f5				push af  
3888 3a 9c 38			ld a, (.dmark)  
388b 32 71 ee			ld (debug_mark),a  
388e 3a 9d 38			ld a, (.dmark+1)  
3891 32 72 ee			ld (debug_mark+1),a  
3894 3a 9e 38			ld a, (.dmark+2)  
3897 32 73 ee			ld (debug_mark+2),a  
389a 18 03			jr .pastdmark  
389c ..			.dmark: db "RN1"  
389f f1			.pastdmark: pop af  
38a0			endm  
# End of macro DMARK
38a0						CALLMONITOR 
38a0 cd a8 15			call break_point_state  
38a3				endm  
# End of macro CALLMONITOR
38a3					endif 
38a3					FORTH_DSP_POP 
38a3 cd c8 1e			call macro_forth_dsp_pop 
38a6				endm 
# End of macro FORTH_DSP_POP
38a6			 
38a6					FORTH_DSP_VALUEHL    ; low range 
38a6 cd 10 1e			call macro_dsp_valuehl 
38a9				endm 
# End of macro FORTH_DSP_VALUEHL
38a9			 
38a9					if DEBUG_FORTH_WORDS 
38a9						DMARK "RN2" 
38a9 f5				push af  
38aa 3a be 38			ld a, (.dmark)  
38ad 32 71 ee			ld (debug_mark),a  
38b0 3a bf 38			ld a, (.dmark+1)  
38b3 32 72 ee			ld (debug_mark+1),a  
38b6 3a c0 38			ld a, (.dmark+2)  
38b9 32 73 ee			ld (debug_mark+2),a  
38bc 18 03			jr .pastdmark  
38be ..			.dmark: db "RN2"  
38c1 f1			.pastdmark: pop af  
38c2			endm  
# End of macro DMARK
38c2						CALLMONITOR 
38c2 cd a8 15			call break_point_state  
38c5				endm  
# End of macro CALLMONITOR
38c5					endif 
38c5 22 b8 eb				ld (LFSRSeed+2), hl 
38c8			 
38c8					FORTH_DSP_POP 
38c8 cd c8 1e			call macro_forth_dsp_pop 
38cb				endm 
# End of macro FORTH_DSP_POP
38cb			 
38cb e5					push hl 
38cc			 
38cc e1			.inrange:	pop hl 
38cd cd ce 0c				call prng16  
38d0					if DEBUG_FORTH_WORDS 
38d0						DMARK "RN3" 
38d0 f5				push af  
38d1 3a e5 38			ld a, (.dmark)  
38d4 32 71 ee			ld (debug_mark),a  
38d7 3a e6 38			ld a, (.dmark+1)  
38da 32 72 ee			ld (debug_mark+1),a  
38dd 3a e7 38			ld a, (.dmark+2)  
38e0 32 73 ee			ld (debug_mark+2),a  
38e3 18 03			jr .pastdmark  
38e5 ..			.dmark: db "RN3"  
38e8 f1			.pastdmark: pop af  
38e9			endm  
# End of macro DMARK
38e9						CALLMONITOR 
38e9 cd a8 15			call break_point_state  
38ec				endm  
# End of macro CALLMONITOR
38ec					endif 
38ec					 
38ec					; if the range is 8bit knock out the high byte 
38ec			 
38ec ed 5b b6 eb			ld de, (LFSRSeed)     ; check high level 
38f0			 
38f0 3e 00				ld a, 0 
38f2 ba					cp d  
38f3 20 1e				jr nz, .hirange 
38f5 26 00				ld h, 0   ; knock it down to 8bit 
38f7			 
38f7					if DEBUG_FORTH_WORDS 
38f7						DMARK "RNk" 
38f7 f5				push af  
38f8 3a 0c 39			ld a, (.dmark)  
38fb 32 71 ee			ld (debug_mark),a  
38fe 3a 0d 39			ld a, (.dmark+1)  
3901 32 72 ee			ld (debug_mark+1),a  
3904 3a 0e 39			ld a, (.dmark+2)  
3907 32 73 ee			ld (debug_mark+2),a  
390a 18 03			jr .pastdmark  
390c ..			.dmark: db "RNk"  
390f f1			.pastdmark: pop af  
3910			endm  
# End of macro DMARK
3910						CALLMONITOR 
3910 cd a8 15			call break_point_state  
3913				endm  
# End of macro CALLMONITOR
3913					endif 
3913			.hirange:   
3913 e5					push hl  
3914 b7					or a  
3915 ed 52		                sbc hl, de 
3917			 
3917					;call cmp16 
3917			 
3917 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3919 e1					pop hl 
391a e5					push hl 
391b			 
391b					if DEBUG_FORTH_WORDS 
391b						DMARK "RN4" 
391b f5				push af  
391c 3a 30 39			ld a, (.dmark)  
391f 32 71 ee			ld (debug_mark),a  
3922 3a 31 39			ld a, (.dmark+1)  
3925 32 72 ee			ld (debug_mark+1),a  
3928 3a 32 39			ld a, (.dmark+2)  
392b 32 73 ee			ld (debug_mark+2),a  
392e 18 03			jr .pastdmark  
3930 ..			.dmark: db "RN4"  
3933 f1			.pastdmark: pop af  
3934			endm  
# End of macro DMARK
3934						CALLMONITOR 
3934 cd a8 15			call break_point_state  
3937				endm  
# End of macro CALLMONITOR
3937					endif 
3937 ed 5b b8 eb			ld de, (LFSRSeed+2)   ; check low range 
393b					;call cmp16 
393b				 
393b b7					or a  
393c ed 52		                sbc hl, de 
393e 38 8c				jr c, .inrange 
3940			 
3940 e1					pop hl 
3941					 
3941					if DEBUG_FORTH_WORDS 
3941						DMARK "RNd" 
3941 f5				push af  
3942 3a 56 39			ld a, (.dmark)  
3945 32 71 ee			ld (debug_mark),a  
3948 3a 57 39			ld a, (.dmark+1)  
394b 32 72 ee			ld (debug_mark+1),a  
394e 3a 58 39			ld a, (.dmark+2)  
3951 32 73 ee			ld (debug_mark+2),a  
3954 18 03			jr .pastdmark  
3956 ..			.dmark: db "RNd"  
3959 f1			.pastdmark: pop af  
395a			endm  
# End of macro DMARK
395a						CALLMONITOR 
395a cd a8 15			call break_point_state  
395d				endm  
# End of macro CALLMONITOR
395d					endif 
395d			 
395d			 
395d cd 19 1c				call forth_push_numhl 
3960				       NEXTW 
3960 c3 87 1f			jp macro_next 
3963				endm 
# End of macro NEXTW
3963			 
3963			.ENDMATHS: 
3963			 
3963			; eof 
3963			 
# End of file forth_words_maths.asm
3963			include "forth_words_display.asm" 
3963			 
3963			; | ## Display Words 
3963			 
3963			.INFO: 
3963			 
3963				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3963 62				db WORD_SYS_CORE+78             
3964 80 39			dw .ATP            
3966 05				db 4 + 1 
3967 .. 00			db "INFO",0              
396c				endm 
# End of macro CWHEAD
396c			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
396c					FORTH_DSP_VALUEHL 
396c cd 10 1e			call macro_dsp_valuehl 
396f				endm 
# End of macro FORTH_DSP_VALUEHL
396f			 
396f					FORTH_DSP_POP 
396f cd c8 1e			call macro_forth_dsp_pop 
3972				endm 
# End of macro FORTH_DSP_POP
3972			 
3972 e5					push hl 
3973			 
3973					FORTH_DSP_VALUEHL 
3973 cd 10 1e			call macro_dsp_valuehl 
3976				endm 
# End of macro FORTH_DSP_VALUEHL
3976			 
3976					FORTH_DSP_POP 
3976 cd c8 1e			call macro_forth_dsp_pop 
3979				endm 
# End of macro FORTH_DSP_POP
3979			 
3979 d1					pop de 
397a			 
397a cd 0b 0b				call info_panel 
397d			 
397d			 
397d					NEXTW 
397d c3 87 1f			jp macro_next 
3980				endm 
# End of macro NEXTW
3980			.ATP: 
3980				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3980 62				db WORD_SYS_CORE+78             
3981 f7 39			dw .FB            
3983 04				db 3 + 1 
3984 .. 00			db "AT?",0              
3988				endm 
# End of macro CWHEAD
3988			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3988					if DEBUG_FORTH_WORDS_KEY 
3988						DMARK "AT?" 
3988 f5				push af  
3989 3a 9d 39			ld a, (.dmark)  
398c 32 71 ee			ld (debug_mark),a  
398f 3a 9e 39			ld a, (.dmark+1)  
3992 32 72 ee			ld (debug_mark+1),a  
3995 3a 9f 39			ld a, (.dmark+2)  
3998 32 73 ee			ld (debug_mark+2),a  
399b 18 03			jr .pastdmark  
399d ..			.dmark: db "AT?"  
39a0 f1			.pastdmark: pop af  
39a1			endm  
# End of macro DMARK
39a1						CALLMONITOR 
39a1 cd a8 15			call break_point_state  
39a4				endm  
# End of macro CALLMONITOR
39a4					endif 
39a4 3a 6b ea				ld a, (f_cursor_ptr) 
39a7			 
39a7			if DEBUG_FORTH_WORDS 
39a7				DMARK "AT?" 
39a7 f5				push af  
39a8 3a bc 39			ld a, (.dmark)  
39ab 32 71 ee			ld (debug_mark),a  
39ae 3a bd 39			ld a, (.dmark+1)  
39b1 32 72 ee			ld (debug_mark+1),a  
39b4 3a be 39			ld a, (.dmark+2)  
39b7 32 73 ee			ld (debug_mark+2),a  
39ba 18 03			jr .pastdmark  
39bc ..			.dmark: db "AT?"  
39bf f1			.pastdmark: pop af  
39c0			endm  
# End of macro DMARK
39c0				CALLMONITOR 
39c0 cd a8 15			call break_point_state  
39c3				endm  
# End of macro CALLMONITOR
39c3			endif	 
39c3					; count the number of rows 
39c3			 
39c3 06 00				ld b, 0 
39c5 4f			.atpr:		ld c, a    ; save in case we go below zero 
39c6 d6 28				sub display_cols 
39c8 f2 ce 39				jp p, .atprunder 
39cb 04					inc b 
39cc 18 f7				jr .atpr 
39ce			.atprunder:	 
39ce			if DEBUG_FORTH_WORDS 
39ce				DMARK "A?2" 
39ce f5				push af  
39cf 3a e3 39			ld a, (.dmark)  
39d2 32 71 ee			ld (debug_mark),a  
39d5 3a e4 39			ld a, (.dmark+1)  
39d8 32 72 ee			ld (debug_mark+1),a  
39db 3a e5 39			ld a, (.dmark+2)  
39de 32 73 ee			ld (debug_mark+2),a  
39e1 18 03			jr .pastdmark  
39e3 ..			.dmark: db "A?2"  
39e6 f1			.pastdmark: pop af  
39e7			endm  
# End of macro DMARK
39e7				CALLMONITOR 
39e7 cd a8 15			call break_point_state  
39ea				endm  
# End of macro CALLMONITOR
39ea			endif	 
39ea 26 00				ld h, 0 
39ec 69					ld l, c 
39ed cd 19 1c				call forth_push_numhl 
39f0 68					ld l, b  
39f1 cd 19 1c				call forth_push_numhl 
39f4			 
39f4			 
39f4				NEXTW 
39f4 c3 87 1f			jp macro_next 
39f7				endm 
# End of macro NEXTW
39f7			 
39f7			.FB: 
39f7				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
39f7 1b				db WORD_SYS_CORE+7             
39f8 45 3a			dw .EMIT            
39fa 03				db 2 + 1 
39fb .. 00			db "FB",0              
39fe				endm 
# End of macro CWHEAD
39fe			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
39fe			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
39fe			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
39fe			; | | If automatic display is off then updates will not be shown until DRAW is used. 
39fe					if DEBUG_FORTH_WORDS_KEY 
39fe						DMARK "FB." 
39fe f5				push af  
39ff 3a 13 3a			ld a, (.dmark)  
3a02 32 71 ee			ld (debug_mark),a  
3a05 3a 14 3a			ld a, (.dmark+1)  
3a08 32 72 ee			ld (debug_mark+1),a  
3a0b 3a 15 3a			ld a, (.dmark+2)  
3a0e 32 73 ee			ld (debug_mark+2),a  
3a11 18 03			jr .pastdmark  
3a13 ..			.dmark: db "FB."  
3a16 f1			.pastdmark: pop af  
3a17			endm  
# End of macro DMARK
3a17						CALLMONITOR 
3a17 cd a8 15			call break_point_state  
3a1a				endm  
# End of macro CALLMONITOR
3a1a					endif 
3a1a			 
3a1a					FORTH_DSP_VALUEHL 
3a1a cd 10 1e			call macro_dsp_valuehl 
3a1d				endm 
# End of macro FORTH_DSP_VALUEHL
3a1d			 
3a1d 7d					ld a, l 
3a1e fe 01				cp 1 
3a20 20 05				jr nz, .fbn1 
3a22 21 16 ed				ld hl, display_fb1 
3a25 18 15				jr .fbset 
3a27 fe 02		.fbn1:		cp 2 
3a29 20 05				jr nz, .fbn2 
3a2b 21 d4 eb				ld hl, display_fb2 
3a2e 18 0c				jr .fbset 
3a30 fe 03		.fbn2:		cp 3 
3a32 20 05				jr nz, .fbn3 
3a34 21 75 ec				ld hl, display_fb3 
3a37 18 03				jr .fbset 
3a39			.fbn3:		 ; if invalid number select first 
3a39 21 16 ed				ld hl, display_fb1 
3a3c 22 d2 eb		.fbset:		ld (display_fb_active), hl 
3a3f			 
3a3f					FORTH_DSP_POP 
3a3f cd c8 1e			call macro_forth_dsp_pop 
3a42				endm 
# End of macro FORTH_DSP_POP
3a42			 
3a42					NEXTW 
3a42 c3 87 1f			jp macro_next 
3a45				endm 
# End of macro NEXTW
3a45			 
3a45			 
3a45			.EMIT: 
3a45				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3a45 1b				db WORD_SYS_CORE+7             
3a46 96 3a			dw .DOTH            
3a48 05				db 4 + 1 
3a49 .. 00			db "EMIT",0              
3a4e				endm 
# End of macro CWHEAD
3a4e			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3a4e					; get value off TOS and display it 
3a4e			 
3a4e					if DEBUG_FORTH_WORDS_KEY 
3a4e						DMARK "EMT" 
3a4e f5				push af  
3a4f 3a 63 3a			ld a, (.dmark)  
3a52 32 71 ee			ld (debug_mark),a  
3a55 3a 64 3a			ld a, (.dmark+1)  
3a58 32 72 ee			ld (debug_mark+1),a  
3a5b 3a 65 3a			ld a, (.dmark+2)  
3a5e 32 73 ee			ld (debug_mark+2),a  
3a61 18 03			jr .pastdmark  
3a63 ..			.dmark: db "EMT"  
3a66 f1			.pastdmark: pop af  
3a67			endm  
# End of macro DMARK
3a67						CALLMONITOR 
3a67 cd a8 15			call break_point_state  
3a6a				endm  
# End of macro CALLMONITOR
3a6a					endif 
3a6a			 
3a6a					FORTH_DSP_VALUEHL 
3a6a cd 10 1e			call macro_dsp_valuehl 
3a6d				endm 
# End of macro FORTH_DSP_VALUEHL
3a6d			 
3a6d 7d					ld a,l 
3a6e			 
3a6e					; TODO write to display 
3a6e			 
3a6e 32 00 e5				ld (os_input), a 
3a71 3e 00				ld a, 0 
3a73 32 01 e5				ld (os_input+1), a 
3a76					 
3a76 3a 6b ea				ld a, (f_cursor_ptr) 
3a79 11 00 e5				ld de, os_input 
3a7c cd 8d 0b				call str_at_display 
3a7f			 
3a7f			 
3a7f 3a 49 ea				ld a,(cli_autodisplay) 
3a82 fe 00				cp 0 
3a84 28 03				jr z, .enoupdate 
3a86 cd 9d 0b						call update_display 
3a89					.enoupdate: 
3a89			 
3a89 3a 6b ea				ld a, (f_cursor_ptr) 
3a8c 3c					inc a 
3a8d 32 6b ea				ld (f_cursor_ptr), a   ; save new pos 
3a90			 
3a90			 
3a90					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a90 cd c8 1e			call macro_forth_dsp_pop 
3a93				endm 
# End of macro FORTH_DSP_POP
3a93			  
3a93			 
3a93					NEXTW 
3a93 c3 87 1f			jp macro_next 
3a96				endm 
# End of macro NEXTW
3a96			.DOTH: 
3a96				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3a96 1c				db WORD_SYS_CORE+8             
3a97 c6 3a			dw .DOTF            
3a99 03				db 2 + 1 
3a9a .. 00			db ".-",0              
3a9d				endm 
# End of macro CWHEAD
3a9d			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3a9d					; get value off TOS and display it 
3a9d					if DEBUG_FORTH_WORDS_KEY 
3a9d						DMARK "DTD" 
3a9d f5				push af  
3a9e 3a b2 3a			ld a, (.dmark)  
3aa1 32 71 ee			ld (debug_mark),a  
3aa4 3a b3 3a			ld a, (.dmark+1)  
3aa7 32 72 ee			ld (debug_mark+1),a  
3aaa 3a b4 3a			ld a, (.dmark+2)  
3aad 32 73 ee			ld (debug_mark+2),a  
3ab0 18 03			jr .pastdmark  
3ab2 ..			.dmark: db "DTD"  
3ab5 f1			.pastdmark: pop af  
3ab6			endm  
# End of macro DMARK
3ab6						CALLMONITOR 
3ab6 cd a8 15			call break_point_state  
3ab9				endm  
# End of macro CALLMONITOR
3ab9					endif 
3ab9 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3abb 3e 00			ld a, 0 
3abd 32 4a ea			ld (cli_mvdot), a 
3ac0 c3 1d 3b			jp .dotgo 
3ac3				NEXTW 
3ac3 c3 87 1f			jp macro_next 
3ac6				endm 
# End of macro NEXTW
3ac6			.DOTF: 
3ac6				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3ac6 1c				db WORD_SYS_CORE+8             
3ac7 f4 3a			dw .DOT            
3ac9 03				db 2 + 1 
3aca .. 00			db ".>",0              
3acd				endm 
# End of macro CWHEAD
3acd			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3acd					; get value off TOS and display it 
3acd			        ; TODO BUG adds extra spaces 
3acd			        ; TODO BUG handle numerics? 
3acd					if DEBUG_FORTH_WORDS_KEY 
3acd						DMARK "DTC" 
3acd f5				push af  
3ace 3a e2 3a			ld a, (.dmark)  
3ad1 32 71 ee			ld (debug_mark),a  
3ad4 3a e3 3a			ld a, (.dmark+1)  
3ad7 32 72 ee			ld (debug_mark+1),a  
3ada 3a e4 3a			ld a, (.dmark+2)  
3add 32 73 ee			ld (debug_mark+2),a  
3ae0 18 03			jr .pastdmark  
3ae2 ..			.dmark: db "DTC"  
3ae5 f1			.pastdmark: pop af  
3ae6			endm  
# End of macro DMARK
3ae6						CALLMONITOR 
3ae6 cd a8 15			call break_point_state  
3ae9				endm  
# End of macro CALLMONITOR
3ae9					endif 
3ae9 3e 01			ld a, 1 
3aeb 32 4a ea			ld (cli_mvdot), a 
3aee c3 1d 3b			jp .dotgo 
3af1				NEXTW 
3af1 c3 87 1f			jp macro_next 
3af4				endm 
# End of macro NEXTW
3af4			 
3af4			.DOT: 
3af4				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3af4 1c				db WORD_SYS_CORE+8             
3af5 80 3b			dw .CLS            
3af7 02				db 1 + 1 
3af8 .. 00			db ".",0              
3afa				endm 
# End of macro CWHEAD
3afa			        ; | . ( u -- ) Display TOS | DONE 
3afa					; get value off TOS and display it 
3afa			 
3afa					if DEBUG_FORTH_WORDS_KEY 
3afa						DMARK "DOT" 
3afa f5				push af  
3afb 3a 0f 3b			ld a, (.dmark)  
3afe 32 71 ee			ld (debug_mark),a  
3b01 3a 10 3b			ld a, (.dmark+1)  
3b04 32 72 ee			ld (debug_mark+1),a  
3b07 3a 11 3b			ld a, (.dmark+2)  
3b0a 32 73 ee			ld (debug_mark+2),a  
3b0d 18 03			jr .pastdmark  
3b0f ..			.dmark: db "DOT"  
3b12 f1			.pastdmark: pop af  
3b13			endm  
# End of macro DMARK
3b13						CALLMONITOR 
3b13 cd a8 15			call break_point_state  
3b16				endm  
# End of macro CALLMONITOR
3b16					endif 
3b16 3e 00			ld a, 0 
3b18 32 4a ea			ld (cli_mvdot), a 
3b1b 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3b1d				 
3b1d			 
3b1d			.dotgo: 
3b1d			 
3b1d			; move up type to on stack for parserv5 
3b1d					FORTH_DSP 
3b1d cd d6 1d			call macro_forth_dsp 
3b20				endm 
# End of macro FORTH_DSP
3b20				;FORTH_DSP_VALUE  
3b20			 
3b20			if DEBUG_FORTH_DOT 
3b20				DMARK "DOT" 
3b20				CALLMONITOR 
3b20			endif	 
3b20			;		.print: 
3b20			 
3b20 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3b21 23				inc hl   ; position to the actual value 
3b22 fe 01			cp DS_TYPE_STR 
3b24 20 06			jr nz, .dotnum1  
3b26			 
3b26			; display string 
3b26				FORTH_DSP_VALUE  
3b26 cd f9 1d			call macro_forth_dsp_value 
3b29				endm 
# End of macro FORTH_DSP_VALUE
3b29 eb				ex de,hl 
3b2a 18 11			jr .dotwrite 
3b2c			 
3b2c			.dotnum1: 
3b2c fe 02			cp DS_TYPE_INUM 
3b2e 20 0c			jr nz, .dotflot 
3b30			 
3b30			 
3b30			; display number 
3b30			 
3b30			;	push hl 
3b30			;	call clear_display 
3b30			;	pop hl 
3b30			 
3b30 5e				ld e, (hl) 
3b31 23				inc hl 
3b32 56				ld d, (hl) 
3b33 21 02 e3			ld hl, scratch 
3b36			if DEBUG_FORTH_DOT 
3b36				DMARK "DT1" 
3b36				CALLMONITOR 
3b36			endif	 
3b36			 
3b36 cd b4 11			call uitoa_16 
3b39 eb				ex de,hl 
3b3a			 
3b3a			if DEBUG_FORTH_DOT 
3b3a				DMARK "DT2" 
3b3a				CALLMONITOR 
3b3a			endif	 
3b3a			 
3b3a			;	ld de, os_word_scratch 
3b3a 18 01			jr .dotwrite 
3b3c			 
3b3c 00			.dotflot:   nop 
3b3d			; TODO print floating point number 
3b3d			 
3b3d			.dotwrite:		 
3b3d			 
3b3d					; if c is set then set all '-' to spaces 
3b3d					; need to also take into account .>  
3b3d			 
3b3d 3e 01				ld a, 1 
3b3f b9					cp c 
3b40 20 13				jr nz, .nodashswap 
3b42			 
3b42					; DE has the string to write, working with HL 
3b42			 
3b42 06 ff				ld b, 255 
3b44 d5					push de 
3b45 e1					pop hl 
3b46			 
3b46			if DEBUG_FORTH_DOT 
3b46				DMARK "DT-" 
3b46				CALLMONITOR 
3b46			endif	 
3b46 7e			.dashscan:	ld a, (hl) 
3b47 fe 00				cp 0 
3b49 28 0a				jr z, .nodashswap 
3b4b fe 2d				cp '-' 
3b4d 20 03				jr nz, .dashskip 
3b4f 3e 20				ld a, ' ' 
3b51 77					ld (hl), a 
3b52 23			.dashskip:	inc hl 
3b53			if DEBUG_FORTH_DOT 
3b53				DMARK "D-2" 
3b53				CALLMONITOR 
3b53			endif	 
3b53 10 f1				djnz .dashscan 
3b55			 
3b55			if DEBUG_FORTH_DOT 
3b55				DMARK "D-1" 
3b55				CALLMONITOR 
3b55			endif	 
3b55			 
3b55			.nodashswap: 
3b55			 
3b55 e5					push hl   ; save string start in case we need to advance print 
3b56			 
3b56 3a 6b ea				ld a, (f_cursor_ptr) 
3b59 cd 8d 0b				call str_at_display 
3b5c 3a 49 ea				ld a,(cli_autodisplay) 
3b5f fe 00				cp 0 
3b61 28 03				jr z, .noupdate 
3b63 cd 9d 0b						call update_display 
3b66					.noupdate: 
3b66			 
3b66			 
3b66					; see if we need to advance the print position 
3b66			 
3b66 e1					pop hl   ; get back string 
3b67			 
3b67 3a 4a ea				ld a, (cli_mvdot) 
3b6a			if DEBUG_FORTH_DOT 
3b6a					ld e,a 
3b6a				DMARK "D>1" 
3b6a				CALLMONITOR 
3b6a			endif	 
3b6a fe 00				cp 0 
3b6c 28 0c				jr z, .noadv 
3b6e					; yes, lets advance the print position 
3b6e 3e 00				ld a, 0 
3b70 cd 10 12				call strlent 
3b73 3a 6b ea				ld a, (f_cursor_ptr) 
3b76 85					add a,l 
3b77					;call addatohl 
3b77					;ld a, l 
3b77 32 6b ea				ld (f_cursor_ptr), a   ; save new pos 
3b7a			 
3b7a			if DEBUG_FORTH_DOT 
3b7a				DMARK "D->" 
3b7a				CALLMONITOR 
3b7a			endif	 
3b7a			 
3b7a			.noadv:	 
3b7a			 
3b7a					if DEBUG_FORTH_DOT_WAIT 
3b7a							call next_page_prompt 
3b7a					endif	 
3b7a			; TODO this pop off the stack causes a crash. i dont know why 
3b7a			 
3b7a			 
3b7a			if DEBUG_FORTH_DOT 
3b7a				DMARK "DTh" 
3b7a				CALLMONITOR 
3b7a			endif	 
3b7a			 
3b7a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b7a cd c8 1e			call macro_forth_dsp_pop 
3b7d				endm 
# End of macro FORTH_DSP_POP
3b7d			 
3b7d			if DEBUG_FORTH_DOT 
3b7d				DMARK "DTi" 
3b7d				CALLMONITOR 
3b7d			endif	 
3b7d			 
3b7d			 
3b7d					NEXTW 
3b7d c3 87 1f			jp macro_next 
3b80				endm 
# End of macro NEXTW
3b80			 
3b80			.CLS: 
3b80				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3b80 35				db WORD_SYS_CORE+33             
3b81 ad 3b			dw .DRAW            
3b83 04				db 3 + 1 
3b84 .. 00			db "CLS",0              
3b88				endm 
# End of macro CWHEAD
3b88			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3b88					if DEBUG_FORTH_WORDS_KEY 
3b88						DMARK "CLS" 
3b88 f5				push af  
3b89 3a 9d 3b			ld a, (.dmark)  
3b8c 32 71 ee			ld (debug_mark),a  
3b8f 3a 9e 3b			ld a, (.dmark+1)  
3b92 32 72 ee			ld (debug_mark+1),a  
3b95 3a 9f 3b			ld a, (.dmark+2)  
3b98 32 73 ee			ld (debug_mark+2),a  
3b9b 18 03			jr .pastdmark  
3b9d ..			.dmark: db "CLS"  
3ba0 f1			.pastdmark: pop af  
3ba1			endm  
# End of macro DMARK
3ba1						CALLMONITOR 
3ba1 cd a8 15			call break_point_state  
3ba4				endm  
# End of macro CALLMONITOR
3ba4					endif 
3ba4 cd 7a 0b				call clear_display 
3ba7 c3 bb 3c				jp .home		; and home cursor 
3baa					NEXTW 
3baa c3 87 1f			jp macro_next 
3bad				endm 
# End of macro NEXTW
3bad			 
3bad			.DRAW: 
3bad				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3bad 36				db WORD_SYS_CORE+34             
3bae d8 3b			dw .DUMP            
3bb0 05				db 4 + 1 
3bb1 .. 00			db "DRAW",0              
3bb6				endm 
# End of macro CWHEAD
3bb6			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3bb6					if DEBUG_FORTH_WORDS_KEY 
3bb6						DMARK "DRW" 
3bb6 f5				push af  
3bb7 3a cb 3b			ld a, (.dmark)  
3bba 32 71 ee			ld (debug_mark),a  
3bbd 3a cc 3b			ld a, (.dmark+1)  
3bc0 32 72 ee			ld (debug_mark+1),a  
3bc3 3a cd 3b			ld a, (.dmark+2)  
3bc6 32 73 ee			ld (debug_mark+2),a  
3bc9 18 03			jr .pastdmark  
3bcb ..			.dmark: db "DRW"  
3bce f1			.pastdmark: pop af  
3bcf			endm  
# End of macro DMARK
3bcf						CALLMONITOR 
3bcf cd a8 15			call break_point_state  
3bd2				endm  
# End of macro CALLMONITOR
3bd2					endif 
3bd2 cd 9d 0b				call update_display 
3bd5					NEXTW 
3bd5 c3 87 1f			jp macro_next 
3bd8				endm 
# End of macro NEXTW
3bd8			 
3bd8			.DUMP: 
3bd8				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3bd8 37				db WORD_SYS_CORE+35             
3bd9 10 3c			dw .CDUMP            
3bdb 05				db 4 + 1 
3bdc .. 00			db "DUMP",0              
3be1				endm 
# End of macro CWHEAD
3be1			; | DUMP ( x -- ) With address x display dump   | DONE 
3be1			; TODO pop address to use off of the stack 
3be1					if DEBUG_FORTH_WORDS_KEY 
3be1						DMARK "DUM" 
3be1 f5				push af  
3be2 3a f6 3b			ld a, (.dmark)  
3be5 32 71 ee			ld (debug_mark),a  
3be8 3a f7 3b			ld a, (.dmark+1)  
3beb 32 72 ee			ld (debug_mark+1),a  
3bee 3a f8 3b			ld a, (.dmark+2)  
3bf1 32 73 ee			ld (debug_mark+2),a  
3bf4 18 03			jr .pastdmark  
3bf6 ..			.dmark: db "DUM"  
3bf9 f1			.pastdmark: pop af  
3bfa			endm  
# End of macro DMARK
3bfa						CALLMONITOR 
3bfa cd a8 15			call break_point_state  
3bfd				endm  
# End of macro CALLMONITOR
3bfd					endif 
3bfd cd 7a 0b				call clear_display 
3c00			 
3c00					; get address 
3c00			 
3c00					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c00 cd 10 1e			call macro_dsp_valuehl 
3c03				endm 
# End of macro FORTH_DSP_VALUEHL
3c03				 
3c03					; save it for cdump 
3c03			 
3c03 22 25 e6				ld (os_cur_ptr),hl 
3c06			 
3c06					; destroy value TOS 
3c06			 
3c06					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c06 cd c8 1e			call macro_forth_dsp_pop 
3c09				endm 
# End of macro FORTH_DSP_POP
3c09			 
3c09 cd 99 1a				call dumpcont	; skip old style of param parsing	 
3c0c c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3c0d					NEXTW 
3c0d c3 87 1f			jp macro_next 
3c10				endm 
# End of macro NEXTW
3c10			.CDUMP: 
3c10				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3c10 38				db WORD_SYS_CORE+36             
3c11 40 3c			dw .DAT            
3c13 06				db 5 + 1 
3c14 .. 00			db "CDUMP",0              
3c1a				endm 
# End of macro CWHEAD
3c1a			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3c1a					if DEBUG_FORTH_WORDS_KEY 
3c1a						DMARK "CDP" 
3c1a f5				push af  
3c1b 3a 2f 3c			ld a, (.dmark)  
3c1e 32 71 ee			ld (debug_mark),a  
3c21 3a 30 3c			ld a, (.dmark+1)  
3c24 32 72 ee			ld (debug_mark+1),a  
3c27 3a 31 3c			ld a, (.dmark+2)  
3c2a 32 73 ee			ld (debug_mark+2),a  
3c2d 18 03			jr .pastdmark  
3c2f ..			.dmark: db "CDP"  
3c32 f1			.pastdmark: pop af  
3c33			endm  
# End of macro DMARK
3c33						CALLMONITOR 
3c33 cd a8 15			call break_point_state  
3c36				endm  
# End of macro CALLMONITOR
3c36					endif 
3c36 cd 7a 0b				call clear_display 
3c39 cd 99 1a				call dumpcont	 
3c3c c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3c3d					NEXTW 
3c3d c3 87 1f			jp macro_next 
3c40				endm 
# End of macro NEXTW
3c40			 
3c40			 
3c40			 
3c40			 
3c40			.DAT: 
3c40				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3c40 3d				db WORD_SYS_CORE+41             
3c41 96 3c			dw .HOME            
3c43 03				db 2 + 1 
3c44 .. 00			db "AT",0              
3c47				endm 
# End of macro CWHEAD
3c47			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3c47					if DEBUG_FORTH_WORDS_KEY 
3c47						DMARK "AT." 
3c47 f5				push af  
3c48 3a 5c 3c			ld a, (.dmark)  
3c4b 32 71 ee			ld (debug_mark),a  
3c4e 3a 5d 3c			ld a, (.dmark+1)  
3c51 32 72 ee			ld (debug_mark+1),a  
3c54 3a 5e 3c			ld a, (.dmark+2)  
3c57 32 73 ee			ld (debug_mark+2),a  
3c5a 18 03			jr .pastdmark  
3c5c ..			.dmark: db "AT."  
3c5f f1			.pastdmark: pop af  
3c60			endm  
# End of macro DMARK
3c60						CALLMONITOR 
3c60 cd a8 15			call break_point_state  
3c63				endm  
# End of macro CALLMONITOR
3c63					endif 
3c63					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c63 cd 10 1e			call macro_dsp_valuehl 
3c66				endm 
# End of macro FORTH_DSP_VALUEHL
3c66			 
3c66			 
3c66					; TODO save cursor row 
3c66 7d					ld a,l 
3c67 fe 02				cp 2 
3c69 20 04				jr nz, .crow3 
3c6b 3e 28				ld a, display_row_2 
3c6d 18 12				jr .ccol1 
3c6f fe 03		.crow3:		cp 3 
3c71 20 04				jr nz, .crow4 
3c73 3e 50				ld a, display_row_3 
3c75 18 0a				jr .ccol1 
3c77 fe 04		.crow4:		cp 4 
3c79 20 04				jr nz, .crow1 
3c7b 3e 78				ld a, display_row_4 
3c7d 18 02				jr .ccol1 
3c7f 3e 00		.crow1:		ld a,display_row_1 
3c81 f5			.ccol1:		push af			; got row offset 
3c82 6f					ld l,a 
3c83 26 00				ld h,0 
3c85					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c85 cd c8 1e			call macro_forth_dsp_pop 
3c88				endm 
# End of macro FORTH_DSP_POP
3c88					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c88 cd 10 1e			call macro_dsp_valuehl 
3c8b				endm 
# End of macro FORTH_DSP_VALUEHL
3c8b					; TODO save cursor col 
3c8b f1					pop af 
3c8c 85					add l		; add col offset 
3c8d 32 6b ea				ld (f_cursor_ptr), a 
3c90					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c90 cd c8 1e			call macro_forth_dsp_pop 
3c93				endm 
# End of macro FORTH_DSP_POP
3c93			 
3c93					; calculate  
3c93			 
3c93					NEXTW 
3c93 c3 87 1f			jp macro_next 
3c96				endm 
# End of macro NEXTW
3c96			 
3c96			 
3c96			.HOME: 
3c96				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3c96 41				db WORD_SYS_CORE+45             
3c97 c3 3c			dw .SPACE            
3c99 05				db 4 + 1 
3c9a .. 00			db "HOME",0              
3c9f				endm 
# End of macro CWHEAD
3c9f			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3c9f					if DEBUG_FORTH_WORDS_KEY 
3c9f						DMARK "HOM" 
3c9f f5				push af  
3ca0 3a b4 3c			ld a, (.dmark)  
3ca3 32 71 ee			ld (debug_mark),a  
3ca6 3a b5 3c			ld a, (.dmark+1)  
3ca9 32 72 ee			ld (debug_mark+1),a  
3cac 3a b6 3c			ld a, (.dmark+2)  
3caf 32 73 ee			ld (debug_mark+2),a  
3cb2 18 03			jr .pastdmark  
3cb4 ..			.dmark: db "HOM"  
3cb7 f1			.pastdmark: pop af  
3cb8			endm  
# End of macro DMARK
3cb8						CALLMONITOR 
3cb8 cd a8 15			call break_point_state  
3cbb				endm  
# End of macro CALLMONITOR
3cbb					endif 
3cbb 3e 00		.home:		ld a, 0		; and home cursor 
3cbd 32 6b ea				ld (f_cursor_ptr), a 
3cc0					NEXTW 
3cc0 c3 87 1f			jp macro_next 
3cc3				endm 
# End of macro NEXTW
3cc3			 
3cc3			 
3cc3			.SPACE: 
3cc3				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3cc3 46				db WORD_SYS_CORE+50             
3cc4 f1 3c			dw .SPACES            
3cc6 03				db 2 + 1 
3cc7 .. 00			db "BL",0              
3cca				endm 
# End of macro CWHEAD
3cca			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3cca					if DEBUG_FORTH_WORDS_KEY 
3cca						DMARK "BL." 
3cca f5				push af  
3ccb 3a df 3c			ld a, (.dmark)  
3cce 32 71 ee			ld (debug_mark),a  
3cd1 3a e0 3c			ld a, (.dmark+1)  
3cd4 32 72 ee			ld (debug_mark+1),a  
3cd7 3a e1 3c			ld a, (.dmark+2)  
3cda 32 73 ee			ld (debug_mark+2),a  
3cdd 18 03			jr .pastdmark  
3cdf ..			.dmark: db "BL."  
3ce2 f1			.pastdmark: pop af  
3ce3			endm  
# End of macro DMARK
3ce3						CALLMONITOR 
3ce3 cd a8 15			call break_point_state  
3ce6				endm  
# End of macro CALLMONITOR
3ce6					endif 
3ce6 21 ef 3c				ld hl, .blstr 
3ce9 cd 87 1c				call forth_push_str 
3cec					 
3cec				       NEXTW 
3cec c3 87 1f			jp macro_next 
3cef				endm 
# End of macro NEXTW
3cef			 
3cef .. 00		.blstr: db " ", 0 
3cf1			 
3cf1			.SPACES: 
3cf1				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3cf1 47				db WORD_SYS_CORE+51             
3cf2 8c 3d			dw .SCROLL            
3cf4 07				db 6 + 1 
3cf5 .. 00			db "SPACES",0              
3cfc				endm 
# End of macro CWHEAD
3cfc			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
3cfc					if DEBUG_FORTH_WORDS_KEY 
3cfc						DMARK "SPS" 
3cfc f5				push af  
3cfd 3a 11 3d			ld a, (.dmark)  
3d00 32 71 ee			ld (debug_mark),a  
3d03 3a 12 3d			ld a, (.dmark+1)  
3d06 32 72 ee			ld (debug_mark+1),a  
3d09 3a 13 3d			ld a, (.dmark+2)  
3d0c 32 73 ee			ld (debug_mark+2),a  
3d0f 18 03			jr .pastdmark  
3d11 ..			.dmark: db "SPS"  
3d14 f1			.pastdmark: pop af  
3d15			endm  
# End of macro DMARK
3d15						CALLMONITOR 
3d15 cd a8 15			call break_point_state  
3d18				endm  
# End of macro CALLMONITOR
3d18					endif 
3d18			 
3d18			 
3d18					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d18 cd 10 1e			call macro_dsp_valuehl 
3d1b				endm 
# End of macro FORTH_DSP_VALUEHL
3d1b			 
3d1b			;		push hl    ; u 
3d1b					if DEBUG_FORTH_WORDS 
3d1b						DMARK "SPA" 
3d1b f5				push af  
3d1c 3a 30 3d			ld a, (.dmark)  
3d1f 32 71 ee			ld (debug_mark),a  
3d22 3a 31 3d			ld a, (.dmark+1)  
3d25 32 72 ee			ld (debug_mark+1),a  
3d28 3a 32 3d			ld a, (.dmark+2)  
3d2b 32 73 ee			ld (debug_mark+2),a  
3d2e 18 03			jr .pastdmark  
3d30 ..			.dmark: db "SPA"  
3d33 f1			.pastdmark: pop af  
3d34			endm  
# End of macro DMARK
3d34						CALLMONITOR 
3d34 cd a8 15			call break_point_state  
3d37				endm  
# End of macro CALLMONITOR
3d37					endif 
3d37			 
3d37					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d37 cd c8 1e			call macro_forth_dsp_pop 
3d3a				endm 
# End of macro FORTH_DSP_POP
3d3a			;		pop hl 
3d3a 4d					ld c, l 
3d3b 06 00				ld b, 0 
3d3d 21 02 e3				ld hl, scratch  
3d40			 
3d40					if DEBUG_FORTH_WORDS 
3d40						DMARK "SP2" 
3d40 f5				push af  
3d41 3a 55 3d			ld a, (.dmark)  
3d44 32 71 ee			ld (debug_mark),a  
3d47 3a 56 3d			ld a, (.dmark+1)  
3d4a 32 72 ee			ld (debug_mark+1),a  
3d4d 3a 57 3d			ld a, (.dmark+2)  
3d50 32 73 ee			ld (debug_mark+2),a  
3d53 18 03			jr .pastdmark  
3d55 ..			.dmark: db "SP2"  
3d58 f1			.pastdmark: pop af  
3d59			endm  
# End of macro DMARK
3d59						CALLMONITOR 
3d59 cd a8 15			call break_point_state  
3d5c				endm  
# End of macro CALLMONITOR
3d5c					endif 
3d5c 3e 20				ld a, ' ' 
3d5e c5			.spaces1:	push bc 
3d5f 77					ld (hl),a 
3d60 23					inc hl 
3d61 c1					pop bc 
3d62 10 fa				djnz .spaces1 
3d64 3e 00				ld a,0 
3d66 77					ld (hl),a 
3d67 21 02 e3				ld hl, scratch 
3d6a					if DEBUG_FORTH_WORDS 
3d6a						DMARK "SP3" 
3d6a f5				push af  
3d6b 3a 7f 3d			ld a, (.dmark)  
3d6e 32 71 ee			ld (debug_mark),a  
3d71 3a 80 3d			ld a, (.dmark+1)  
3d74 32 72 ee			ld (debug_mark+1),a  
3d77 3a 81 3d			ld a, (.dmark+2)  
3d7a 32 73 ee			ld (debug_mark+2),a  
3d7d 18 03			jr .pastdmark  
3d7f ..			.dmark: db "SP3"  
3d82 f1			.pastdmark: pop af  
3d83			endm  
# End of macro DMARK
3d83						CALLMONITOR 
3d83 cd a8 15			call break_point_state  
3d86				endm  
# End of macro CALLMONITOR
3d86					endif 
3d86 cd 82 1d				call forth_apush 
3d89			 
3d89				       NEXTW 
3d89 c3 87 1f			jp macro_next 
3d8c				endm 
# End of macro NEXTW
3d8c			 
3d8c			 
3d8c			 
3d8c			.SCROLL: 
3d8c				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
3d8c 53				db WORD_SYS_CORE+63             
3d8d b9 3d			dw .SCROLLD            
3d8f 07				db 6 + 1 
3d90 .. 00			db "SCROLL",0              
3d97				endm 
# End of macro CWHEAD
3d97			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
3d97					if DEBUG_FORTH_WORDS_KEY 
3d97						DMARK "SCR" 
3d97 f5				push af  
3d98 3a ac 3d			ld a, (.dmark)  
3d9b 32 71 ee			ld (debug_mark),a  
3d9e 3a ad 3d			ld a, (.dmark+1)  
3da1 32 72 ee			ld (debug_mark+1),a  
3da4 3a ae 3d			ld a, (.dmark+2)  
3da7 32 73 ee			ld (debug_mark+2),a  
3daa 18 03			jr .pastdmark  
3dac ..			.dmark: db "SCR"  
3daf f1			.pastdmark: pop af  
3db0			endm  
# End of macro DMARK
3db0						CALLMONITOR 
3db0 cd a8 15			call break_point_state  
3db3				endm  
# End of macro CALLMONITOR
3db3					endif 
3db3			 
3db3 cd 3c 0b			call scroll_up 
3db6			;	call update_display 
3db6			 
3db6					NEXTW 
3db6 c3 87 1f			jp macro_next 
3db9				endm 
# End of macro NEXTW
3db9			 
3db9			 
3db9			 
3db9			;		; get dir 
3db9			; 
3db9			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3db9			; 
3db9			;		push hl 
3db9			; 
3db9			;		; destroy value TOS 
3db9			; 
3db9			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3db9			; 
3db9			;		; get count 
3db9			; 
3db9			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3db9			; 
3db9			;		push hl 
3db9			; 
3db9			;		; destroy value TOS 
3db9			; 
3db9			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3db9			; 
3db9			;		; one value on hl get other one back 
3db9			; 
3db9			;		pop bc    ; count 
3db9			; 
3db9			;		pop de   ; dir 
3db9			; 
3db9			; 
3db9			;		ld b, c 
3db9			; 
3db9			;.scrolldir:     push bc 
3db9			;		push de 
3db9			; 
3db9			;		ld a, 0 
3db9			;		cp e 
3db9			;		jr z, .scrollup  
3db9			;		call scroll_down 
3db9			;		jr .scrollnext 
3db9			;.scrollup:	call scroll_up 
3db9			; 
3db9			;		 
3db9			;.scrollnext: 
3db9			;		pop de 
3db9			;		pop bc 
3db9			;		djnz .scrolldir 
3db9			; 
3db9			; 
3db9			; 
3db9			; 
3db9			; 
3db9			;		NEXTW 
3db9			 
3db9			.SCROLLD: 
3db9				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
3db9 53				db WORD_SYS_CORE+63             
3dba e7 3d			dw .ATQ            
3dbc 08				db 7 + 1 
3dbd .. 00			db "SCROLLD",0              
3dc5				endm 
# End of macro CWHEAD
3dc5			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
3dc5					if DEBUG_FORTH_WORDS_KEY 
3dc5						DMARK "SCD" 
3dc5 f5				push af  
3dc6 3a da 3d			ld a, (.dmark)  
3dc9 32 71 ee			ld (debug_mark),a  
3dcc 3a db 3d			ld a, (.dmark+1)  
3dcf 32 72 ee			ld (debug_mark+1),a  
3dd2 3a dc 3d			ld a, (.dmark+2)  
3dd5 32 73 ee			ld (debug_mark+2),a  
3dd8 18 03			jr .pastdmark  
3dda ..			.dmark: db "SCD"  
3ddd f1			.pastdmark: pop af  
3dde			endm  
# End of macro DMARK
3dde						CALLMONITOR 
3dde cd a8 15			call break_point_state  
3de1				endm  
# End of macro CALLMONITOR
3de1					endif 
3de1			 
3de1 cd 60 0b			call scroll_down 
3de4			;	call update_display 
3de4			 
3de4					NEXTW 
3de4 c3 87 1f			jp macro_next 
3de7				endm 
# End of macro NEXTW
3de7			 
3de7			 
3de7			.ATQ: 
3de7				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
3de7 62				db WORD_SYS_CORE+78             
3de8 45 3e			dw .AUTODSP            
3dea 04				db 3 + 1 
3deb .. 00			db "AT@",0              
3def				endm 
# End of macro CWHEAD
3def			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
3def					if DEBUG_FORTH_WORDS_KEY 
3def						DMARK "ATA" 
3def f5				push af  
3df0 3a 04 3e			ld a, (.dmark)  
3df3 32 71 ee			ld (debug_mark),a  
3df6 3a 05 3e			ld a, (.dmark+1)  
3df9 32 72 ee			ld (debug_mark+1),a  
3dfc 3a 06 3e			ld a, (.dmark+2)  
3dff 32 73 ee			ld (debug_mark+2),a  
3e02 18 03			jr .pastdmark  
3e04 ..			.dmark: db "ATA"  
3e07 f1			.pastdmark: pop af  
3e08			endm  
# End of macro DMARK
3e08						CALLMONITOR 
3e08 cd a8 15			call break_point_state  
3e0b				endm  
# End of macro CALLMONITOR
3e0b					endif 
3e0b			 
3e0b			 
3e0b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e0b cd 10 1e			call macro_dsp_valuehl 
3e0e				endm 
# End of macro FORTH_DSP_VALUEHL
3e0e			 
3e0e					; TODO save cursor row 
3e0e 7d					ld a,l 
3e0f fe 02				cp 2 
3e11 20 04				jr nz, .crow3aq 
3e13 3e 28				ld a, display_row_2 
3e15 18 12				jr .ccol1aq 
3e17 fe 03		.crow3aq:		cp 3 
3e19 20 04				jr nz, .crow4aq 
3e1b 3e 50				ld a, display_row_3 
3e1d 18 0a				jr .ccol1aq 
3e1f fe 04		.crow4aq:		cp 4 
3e21 20 04				jr nz, .crow1aq 
3e23 3e 78				ld a, display_row_4 
3e25 18 02				jr .ccol1aq 
3e27 3e 00		.crow1aq:		ld a,display_row_1 
3e29 f5			.ccol1aq:		push af			; got row offset 
3e2a 6f					ld l,a 
3e2b 26 00				ld h,0 
3e2d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e2d cd c8 1e			call macro_forth_dsp_pop 
3e30				endm 
# End of macro FORTH_DSP_POP
3e30					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e30 cd 10 1e			call macro_dsp_valuehl 
3e33				endm 
# End of macro FORTH_DSP_VALUEHL
3e33					; TODO save cursor col 
3e33 f1					pop af 
3e34 85					add l		; add col offset 
3e35			 
3e35					; add current frame buffer address 
3e35 2a d2 eb				ld hl, (display_fb_active) 
3e38 cd a7 0d				call addatohl 
3e3b			 
3e3b			 
3e3b			 
3e3b			 
3e3b					; get char frame buffer location offset in hl 
3e3b			 
3e3b 7e					ld a,(hl) 
3e3c 26 00				ld h, 0 
3e3e 6f					ld l, a 
3e3f			 
3e3f cd 19 1c				call forth_push_numhl 
3e42			 
3e42			 
3e42					NEXTW 
3e42 c3 87 1f			jp macro_next 
3e45				endm 
# End of macro NEXTW
3e45			 
3e45			.AUTODSP: 
3e45				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
3e45 63				db WORD_SYS_CORE+79             
3e46 5b 3e			dw .MENU            
3e48 05				db 4 + 1 
3e49 .. 00			db "ADSP",0              
3e4e				endm 
# End of macro CWHEAD
3e4e			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
3e4e			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
3e4e			 
3e4e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e4e cd 10 1e			call macro_dsp_valuehl 
3e51				endm 
# End of macro FORTH_DSP_VALUEHL
3e51			 
3e51			;		push hl 
3e51			 
3e51					; destroy value TOS 
3e51			 
3e51					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e51 cd c8 1e			call macro_forth_dsp_pop 
3e54				endm 
# End of macro FORTH_DSP_POP
3e54			 
3e54			;		pop hl 
3e54			 
3e54 7d					ld a,l 
3e55 32 49 ea				ld (cli_autodisplay), a 
3e58				       NEXTW 
3e58 c3 87 1f			jp macro_next 
3e5b				endm 
# End of macro NEXTW
3e5b			 
3e5b			.MENU: 
3e5b				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
3e5b 70				db WORD_SYS_CORE+92             
3e5c 04 3f			dw .ENDDISPLAY            
3e5e 05				db 4 + 1 
3e5f .. 00			db "MENU",0              
3e64				endm 
# End of macro CWHEAD
3e64			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
3e64			 
3e64			;		; get number of items on the stack 
3e64			; 
3e64				 
3e64					FORTH_DSP_VALUEHL 
3e64 cd 10 1e			call macro_dsp_valuehl 
3e67				endm 
# End of macro FORTH_DSP_VALUEHL
3e67				 
3e67					if DEBUG_FORTH_WORDS_KEY 
3e67						DMARK "MNU" 
3e67 f5				push af  
3e68 3a 7c 3e			ld a, (.dmark)  
3e6b 32 71 ee			ld (debug_mark),a  
3e6e 3a 7d 3e			ld a, (.dmark+1)  
3e71 32 72 ee			ld (debug_mark+1),a  
3e74 3a 7e 3e			ld a, (.dmark+2)  
3e77 32 73 ee			ld (debug_mark+2),a  
3e7a 18 03			jr .pastdmark  
3e7c ..			.dmark: db "MNU"  
3e7f f1			.pastdmark: pop af  
3e80			endm  
# End of macro DMARK
3e80						CALLMONITOR 
3e80 cd a8 15			call break_point_state  
3e83				endm  
# End of macro CALLMONITOR
3e83					endif 
3e83			 
3e83 45					ld b, l	 
3e84 05					dec b 
3e85			 
3e85					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e85 cd c8 1e			call macro_forth_dsp_pop 
3e88				endm 
# End of macro FORTH_DSP_POP
3e88			 
3e88			 
3e88					; go directly through the stack to pluck out the string pointers and build an array 
3e88			 
3e88			;		FORTH_DSP 
3e88			 
3e88					; hl contains top most stack item 
3e88				 
3e88 11 02 e3				ld de, scratch 
3e8b			 
3e8b			.mbuild: 
3e8b			 
3e8b					FORTH_DSP_VALUEHL 
3e8b cd 10 1e			call macro_dsp_valuehl 
3e8e				endm 
# End of macro FORTH_DSP_VALUEHL
3e8e			 
3e8e					if DEBUG_FORTH_WORDS 
3e8e						DMARK "MN3" 
3e8e f5				push af  
3e8f 3a a3 3e			ld a, (.dmark)  
3e92 32 71 ee			ld (debug_mark),a  
3e95 3a a4 3e			ld a, (.dmark+1)  
3e98 32 72 ee			ld (debug_mark+1),a  
3e9b 3a a5 3e			ld a, (.dmark+2)  
3e9e 32 73 ee			ld (debug_mark+2),a  
3ea1 18 03			jr .pastdmark  
3ea3 ..			.dmark: db "MN3"  
3ea6 f1			.pastdmark: pop af  
3ea7			endm  
# End of macro DMARK
3ea7						CALLMONITOR 
3ea7 cd a8 15			call break_point_state  
3eaa				endm  
# End of macro CALLMONITOR
3eaa					endif 
3eaa eb					ex de, hl 
3eab 73					ld (hl), e 
3eac 23					inc hl 
3ead 72					ld (hl), d 
3eae 23					inc hl 
3eaf eb					ex de, hl 
3eb0			 
3eb0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3eb0 cd c8 1e			call macro_forth_dsp_pop 
3eb3				endm 
# End of macro FORTH_DSP_POP
3eb3			 
3eb3 10 d6				djnz .mbuild 
3eb5			 
3eb5					; done add term 
3eb5			 
3eb5 eb					ex de, hl 
3eb6 36 00				ld (hl), 0 
3eb8 23					inc hl 
3eb9 36 00				ld (hl), 0 
3ebb			 
3ebb				 
3ebb					 
3ebb 21 02 e3				ld hl, scratch 
3ebe			 
3ebe					if DEBUG_FORTH_WORDS 
3ebe						DMARK "MNx" 
3ebe f5				push af  
3ebf 3a d3 3e			ld a, (.dmark)  
3ec2 32 71 ee			ld (debug_mark),a  
3ec5 3a d4 3e			ld a, (.dmark+1)  
3ec8 32 72 ee			ld (debug_mark+1),a  
3ecb 3a d5 3e			ld a, (.dmark+2)  
3ece 32 73 ee			ld (debug_mark+2),a  
3ed1 18 03			jr .pastdmark  
3ed3 ..			.dmark: db "MNx"  
3ed6 f1			.pastdmark: pop af  
3ed7			endm  
# End of macro DMARK
3ed7						CALLMONITOR 
3ed7 cd a8 15			call break_point_state  
3eda				endm  
# End of macro CALLMONITOR
3eda					endif 
3eda			 
3eda			 
3eda			 
3eda 3e 00				ld a, 0 
3edc cd ab 0b				call menu 
3edf			 
3edf			 
3edf 6f					ld l, a 
3ee0 26 00				ld h, 0 
3ee2			 
3ee2					if DEBUG_FORTH_WORDS 
3ee2						DMARK "MNr" 
3ee2 f5				push af  
3ee3 3a f7 3e			ld a, (.dmark)  
3ee6 32 71 ee			ld (debug_mark),a  
3ee9 3a f8 3e			ld a, (.dmark+1)  
3eec 32 72 ee			ld (debug_mark+1),a  
3eef 3a f9 3e			ld a, (.dmark+2)  
3ef2 32 73 ee			ld (debug_mark+2),a  
3ef5 18 03			jr .pastdmark  
3ef7 ..			.dmark: db "MNr"  
3efa f1			.pastdmark: pop af  
3efb			endm  
# End of macro DMARK
3efb						CALLMONITOR 
3efb cd a8 15			call break_point_state  
3efe				endm  
# End of macro CALLMONITOR
3efe					endif 
3efe			 
3efe cd 19 1c				call forth_push_numhl 
3f01			 
3f01			 
3f01			 
3f01			 
3f01				       NEXTW 
3f01 c3 87 1f			jp macro_next 
3f04				endm 
# End of macro NEXTW
3f04			 
3f04			 
3f04			.ENDDISPLAY: 
3f04			 
3f04			; eof 
# End of file forth_words_display.asm
3f04			include "forth_words_str.asm" 
3f04			 
3f04			; | ## String Words 
3f04			 
3f04			.PTR:   
3f04			 
3f04				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
3f04 48				db WORD_SYS_CORE+52             
3f05 31 3f			dw .STYPE            
3f07 04				db 3 + 1 
3f08 .. 00			db "PTR",0              
3f0c				endm 
# End of macro CWHEAD
3f0c			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
3f0c			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
3f0c			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
3f0c			 
3f0c					if DEBUG_FORTH_WORDS_KEY 
3f0c						DMARK "PTR" 
3f0c f5				push af  
3f0d 3a 21 3f			ld a, (.dmark)  
3f10 32 71 ee			ld (debug_mark),a  
3f13 3a 22 3f			ld a, (.dmark+1)  
3f16 32 72 ee			ld (debug_mark+1),a  
3f19 3a 23 3f			ld a, (.dmark+2)  
3f1c 32 73 ee			ld (debug_mark+2),a  
3f1f 18 03			jr .pastdmark  
3f21 ..			.dmark: db "PTR"  
3f24 f1			.pastdmark: pop af  
3f25			endm  
# End of macro DMARK
3f25						CALLMONITOR 
3f25 cd a8 15			call break_point_state  
3f28				endm  
# End of macro CALLMONITOR
3f28					endif 
3f28					FORTH_DSP_VALUEHL 
3f28 cd 10 1e			call macro_dsp_valuehl 
3f2b				endm 
# End of macro FORTH_DSP_VALUEHL
3f2b cd 19 1c				call forth_push_numhl 
3f2e			 
3f2e			 
3f2e					NEXTW 
3f2e c3 87 1f			jp macro_next 
3f31				endm 
# End of macro NEXTW
3f31			.STYPE: 
3f31				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
3f31 48				db WORD_SYS_CORE+52             
3f32 80 3f			dw .UPPER            
3f34 06				db 5 + 1 
3f35 .. 00			db "STYPE",0              
3f3b				endm 
# End of macro CWHEAD
3f3b			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
3f3b					if DEBUG_FORTH_WORDS_KEY 
3f3b						DMARK "STY" 
3f3b f5				push af  
3f3c 3a 50 3f			ld a, (.dmark)  
3f3f 32 71 ee			ld (debug_mark),a  
3f42 3a 51 3f			ld a, (.dmark+1)  
3f45 32 72 ee			ld (debug_mark+1),a  
3f48 3a 52 3f			ld a, (.dmark+2)  
3f4b 32 73 ee			ld (debug_mark+2),a  
3f4e 18 03			jr .pastdmark  
3f50 ..			.dmark: db "STY"  
3f53 f1			.pastdmark: pop af  
3f54			endm  
# End of macro DMARK
3f54						CALLMONITOR 
3f54 cd a8 15			call break_point_state  
3f57				endm  
# End of macro CALLMONITOR
3f57					endif 
3f57					FORTH_DSP 
3f57 cd d6 1d			call macro_forth_dsp 
3f5a				endm 
# End of macro FORTH_DSP
3f5a					;v5 FORTH_DSP_VALUE 
3f5a			 
3f5a 7e					ld a, (hl) 
3f5b			 
3f5b f5					push af 
3f5c			 
3f5c			; Dont destroy TOS		FORTH_DSP_POP 
3f5c			 
3f5c f1					pop af 
3f5d			 
3f5d fe 01				cp DS_TYPE_STR 
3f5f 28 09				jr z, .typestr 
3f61			 
3f61 fe 02				cp DS_TYPE_INUM 
3f63 28 0a				jr z, .typeinum 
3f65			 
3f65 21 7e 3f				ld hl, .tna 
3f68 18 0a				jr .tpush 
3f6a			 
3f6a 21 7a 3f		.typestr:	ld hl, .tstr 
3f6d 18 05				jr .tpush 
3f6f 21 7c 3f		.typeinum:	ld hl, .tinum 
3f72 18 00				jr .tpush 
3f74			 
3f74			.tpush: 
3f74			 
3f74 cd 87 1c				call forth_push_str 
3f77			 
3f77					NEXTW 
3f77 c3 87 1f			jp macro_next 
3f7a				endm 
# End of macro NEXTW
3f7a .. 00		.tstr:	db "s",0 
3f7c .. 00		.tinum:  db "i",0 
3f7e .. 00		.tna:   db "?", 0 
3f80			 
3f80			 
3f80			.UPPER: 
3f80				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
3f80 48				db WORD_SYS_CORE+52             
3f81 bb 3f			dw .LOWER            
3f83 06				db 5 + 1 
3f84 .. 00			db "UPPER",0              
3f8a				endm 
# End of macro CWHEAD
3f8a			; | UPPER ( s -- s ) Upper case string s  | DONE 
3f8a					if DEBUG_FORTH_WORDS_KEY 
3f8a						DMARK "UPR" 
3f8a f5				push af  
3f8b 3a 9f 3f			ld a, (.dmark)  
3f8e 32 71 ee			ld (debug_mark),a  
3f91 3a a0 3f			ld a, (.dmark+1)  
3f94 32 72 ee			ld (debug_mark+1),a  
3f97 3a a1 3f			ld a, (.dmark+2)  
3f9a 32 73 ee			ld (debug_mark+2),a  
3f9d 18 03			jr .pastdmark  
3f9f ..			.dmark: db "UPR"  
3fa2 f1			.pastdmark: pop af  
3fa3			endm  
# End of macro DMARK
3fa3						CALLMONITOR 
3fa3 cd a8 15			call break_point_state  
3fa6				endm  
# End of macro CALLMONITOR
3fa6					endif 
3fa6			 
3fa6					FORTH_DSP 
3fa6 cd d6 1d			call macro_forth_dsp 
3fa9				endm 
# End of macro FORTH_DSP
3fa9					 
3fa9			; TODO check is string type 
3fa9			 
3fa9					FORTH_DSP_VALUEHL 
3fa9 cd 10 1e			call macro_dsp_valuehl 
3fac				endm 
# End of macro FORTH_DSP_VALUEHL
3fac			; get pointer to string in hl 
3fac			 
3fac 7e			.toup:		ld a, (hl) 
3fad fe 00				cp 0 
3faf 28 07				jr z, .toupdone 
3fb1			 
3fb1 cd 14 11				call to_upper 
3fb4			 
3fb4 77					ld (hl), a 
3fb5 23					inc hl 
3fb6 18 f4				jr .toup 
3fb8			 
3fb8					 
3fb8			 
3fb8			 
3fb8			; for each char convert to upper 
3fb8					 
3fb8			.toupdone: 
3fb8			 
3fb8			 
3fb8					NEXTW 
3fb8 c3 87 1f			jp macro_next 
3fbb				endm 
# End of macro NEXTW
3fbb			.LOWER: 
3fbb				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
3fbb 48				db WORD_SYS_CORE+52             
3fbc f6 3f			dw .TCASE            
3fbe 06				db 5 + 1 
3fbf .. 00			db "LOWER",0              
3fc5				endm 
# End of macro CWHEAD
3fc5			; | LOWER ( s -- s ) Lower case string s  | DONE 
3fc5					if DEBUG_FORTH_WORDS_KEY 
3fc5						DMARK "LWR" 
3fc5 f5				push af  
3fc6 3a da 3f			ld a, (.dmark)  
3fc9 32 71 ee			ld (debug_mark),a  
3fcc 3a db 3f			ld a, (.dmark+1)  
3fcf 32 72 ee			ld (debug_mark+1),a  
3fd2 3a dc 3f			ld a, (.dmark+2)  
3fd5 32 73 ee			ld (debug_mark+2),a  
3fd8 18 03			jr .pastdmark  
3fda ..			.dmark: db "LWR"  
3fdd f1			.pastdmark: pop af  
3fde			endm  
# End of macro DMARK
3fde						CALLMONITOR 
3fde cd a8 15			call break_point_state  
3fe1				endm  
# End of macro CALLMONITOR
3fe1					endif 
3fe1			 
3fe1					FORTH_DSP 
3fe1 cd d6 1d			call macro_forth_dsp 
3fe4				endm 
# End of macro FORTH_DSP
3fe4					 
3fe4			; TODO check is string type 
3fe4			 
3fe4					FORTH_DSP_VALUEHL 
3fe4 cd 10 1e			call macro_dsp_valuehl 
3fe7				endm 
# End of macro FORTH_DSP_VALUEHL
3fe7			; get pointer to string in hl 
3fe7			 
3fe7 7e			.tolow:		ld a, (hl) 
3fe8 fe 00				cp 0 
3fea 28 07				jr z, .tolowdone 
3fec			 
3fec cd 1d 11				call to_lower 
3fef			 
3fef 77					ld (hl), a 
3ff0 23					inc hl 
3ff1 18 f4				jr .tolow 
3ff3			 
3ff3					 
3ff3			 
3ff3			 
3ff3			; for each char convert to low 
3ff3					 
3ff3			.tolowdone: 
3ff3					NEXTW 
3ff3 c3 87 1f			jp macro_next 
3ff6				endm 
# End of macro NEXTW
3ff6			.TCASE: 
3ff6				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
3ff6 48				db WORD_SYS_CORE+52             
3ff7 2c 41			dw .SUBSTR            
3ff9 06				db 5 + 1 
3ffa .. 00			db "TCASE",0              
4000				endm 
# End of macro CWHEAD
4000			; | TCASE ( s -- s ) Title case string s  | DONE 
4000					if DEBUG_FORTH_WORDS_KEY 
4000						DMARK "TCS" 
4000 f5				push af  
4001 3a 15 40			ld a, (.dmark)  
4004 32 71 ee			ld (debug_mark),a  
4007 3a 16 40			ld a, (.dmark+1)  
400a 32 72 ee			ld (debug_mark+1),a  
400d 3a 17 40			ld a, (.dmark+2)  
4010 32 73 ee			ld (debug_mark+2),a  
4013 18 03			jr .pastdmark  
4015 ..			.dmark: db "TCS"  
4018 f1			.pastdmark: pop af  
4019			endm  
# End of macro DMARK
4019						CALLMONITOR 
4019 cd a8 15			call break_point_state  
401c				endm  
# End of macro CALLMONITOR
401c					endif 
401c			 
401c					FORTH_DSP 
401c cd d6 1d			call macro_forth_dsp 
401f				endm 
# End of macro FORTH_DSP
401f					 
401f			; TODO check is string type 
401f			 
401f					FORTH_DSP_VALUEHL 
401f cd 10 1e			call macro_dsp_valuehl 
4022				endm 
# End of macro FORTH_DSP_VALUEHL
4022			; get pointer to string in hl 
4022			 
4022					if DEBUG_FORTH_WORDS 
4022						DMARK "TC1" 
4022 f5				push af  
4023 3a 37 40			ld a, (.dmark)  
4026 32 71 ee			ld (debug_mark),a  
4029 3a 38 40			ld a, (.dmark+1)  
402c 32 72 ee			ld (debug_mark+1),a  
402f 3a 39 40			ld a, (.dmark+2)  
4032 32 73 ee			ld (debug_mark+2),a  
4035 18 03			jr .pastdmark  
4037 ..			.dmark: db "TC1"  
403a f1			.pastdmark: pop af  
403b			endm  
# End of macro DMARK
403b						CALLMONITOR 
403b cd a8 15			call break_point_state  
403e				endm  
# End of macro CALLMONITOR
403e					endif 
403e			 
403e					; first time in turn to upper case first char 
403e			 
403e 7e					ld a, (hl) 
403f c3 c9 40				jp .totsiptou 
4042			 
4042			 
4042 7e			.tot:		ld a, (hl) 
4043 fe 00				cp 0 
4045 ca 0d 41				jp z, .totdone 
4048			 
4048					if DEBUG_FORTH_WORDS 
4048						DMARK "TC2" 
4048 f5				push af  
4049 3a 5d 40			ld a, (.dmark)  
404c 32 71 ee			ld (debug_mark),a  
404f 3a 5e 40			ld a, (.dmark+1)  
4052 32 72 ee			ld (debug_mark+1),a  
4055 3a 5f 40			ld a, (.dmark+2)  
4058 32 73 ee			ld (debug_mark+2),a  
405b 18 03			jr .pastdmark  
405d ..			.dmark: db "TC2"  
4060 f1			.pastdmark: pop af  
4061			endm  
# End of macro DMARK
4061						CALLMONITOR 
4061 cd a8 15			call break_point_state  
4064				endm  
# End of macro CALLMONITOR
4064					endif 
4064					; check to see if current char is a space 
4064			 
4064 fe 20				cp ' ' 
4066 28 21				jr z, .totsp 
4068 cd 1d 11				call to_lower 
406b					if DEBUG_FORTH_WORDS 
406b						DMARK "TC3" 
406b f5				push af  
406c 3a 80 40			ld a, (.dmark)  
406f 32 71 ee			ld (debug_mark),a  
4072 3a 81 40			ld a, (.dmark+1)  
4075 32 72 ee			ld (debug_mark+1),a  
4078 3a 82 40			ld a, (.dmark+2)  
407b 32 73 ee			ld (debug_mark+2),a  
407e 18 03			jr .pastdmark  
4080 ..			.dmark: db "TC3"  
4083 f1			.pastdmark: pop af  
4084			endm  
# End of macro DMARK
4084						CALLMONITOR 
4084 cd a8 15			call break_point_state  
4087				endm  
# End of macro CALLMONITOR
4087					endif 
4087 18 63				jr .totnxt 
4089			 
4089			.totsp:         ; on a space, find next char which should be upper 
4089			 
4089					if DEBUG_FORTH_WORDS 
4089						DMARK "TC4" 
4089 f5				push af  
408a 3a 9e 40			ld a, (.dmark)  
408d 32 71 ee			ld (debug_mark),a  
4090 3a 9f 40			ld a, (.dmark+1)  
4093 32 72 ee			ld (debug_mark+1),a  
4096 3a a0 40			ld a, (.dmark+2)  
4099 32 73 ee			ld (debug_mark+2),a  
409c 18 03			jr .pastdmark  
409e ..			.dmark: db "TC4"  
40a1 f1			.pastdmark: pop af  
40a2			endm  
# End of macro DMARK
40a2						CALLMONITOR 
40a2 cd a8 15			call break_point_state  
40a5				endm  
# End of macro CALLMONITOR
40a5					endif 
40a5					;; 
40a5			 
40a5 fe 20				cp ' ' 
40a7 20 20				jr nz, .totsiptou 
40a9 23					inc hl 
40aa 7e					ld a, (hl) 
40ab					if DEBUG_FORTH_WORDS 
40ab						DMARK "TC5" 
40ab f5				push af  
40ac 3a c0 40			ld a, (.dmark)  
40af 32 71 ee			ld (debug_mark),a  
40b2 3a c1 40			ld a, (.dmark+1)  
40b5 32 72 ee			ld (debug_mark+1),a  
40b8 3a c2 40			ld a, (.dmark+2)  
40bb 32 73 ee			ld (debug_mark+2),a  
40be 18 03			jr .pastdmark  
40c0 ..			.dmark: db "TC5"  
40c3 f1			.pastdmark: pop af  
40c4			endm  
# End of macro DMARK
40c4						CALLMONITOR 
40c4 cd a8 15			call break_point_state  
40c7				endm  
# End of macro CALLMONITOR
40c7					endif 
40c7 18 c0				jr .totsp 
40c9 fe 00		.totsiptou:    cp 0 
40cb 28 40				jr z, .totdone 
40cd					; not space and not zero term so upper case it 
40cd cd 14 11				call to_upper 
40d0			 
40d0					if DEBUG_FORTH_WORDS 
40d0						DMARK "TC6" 
40d0 f5				push af  
40d1 3a e5 40			ld a, (.dmark)  
40d4 32 71 ee			ld (debug_mark),a  
40d7 3a e6 40			ld a, (.dmark+1)  
40da 32 72 ee			ld (debug_mark+1),a  
40dd 3a e7 40			ld a, (.dmark+2)  
40e0 32 73 ee			ld (debug_mark+2),a  
40e3 18 03			jr .pastdmark  
40e5 ..			.dmark: db "TC6"  
40e8 f1			.pastdmark: pop af  
40e9			endm  
# End of macro DMARK
40e9						CALLMONITOR 
40e9 cd a8 15			call break_point_state  
40ec				endm  
# End of macro CALLMONITOR
40ec					endif 
40ec			 
40ec			 
40ec			.totnxt: 
40ec			 
40ec 77					ld (hl), a 
40ed 23					inc hl 
40ee					if DEBUG_FORTH_WORDS 
40ee						DMARK "TC7" 
40ee f5				push af  
40ef 3a 03 41			ld a, (.dmark)  
40f2 32 71 ee			ld (debug_mark),a  
40f5 3a 04 41			ld a, (.dmark+1)  
40f8 32 72 ee			ld (debug_mark+1),a  
40fb 3a 05 41			ld a, (.dmark+2)  
40fe 32 73 ee			ld (debug_mark+2),a  
4101 18 03			jr .pastdmark  
4103 ..			.dmark: db "TC7"  
4106 f1			.pastdmark: pop af  
4107			endm  
# End of macro DMARK
4107						CALLMONITOR 
4107 cd a8 15			call break_point_state  
410a				endm  
# End of macro CALLMONITOR
410a					endif 
410a c3 42 40				jp .tot 
410d			 
410d					 
410d			 
410d			 
410d			; for each char convert to low 
410d					 
410d			.totdone: 
410d					if DEBUG_FORTH_WORDS 
410d						DMARK "TCd" 
410d f5				push af  
410e 3a 22 41			ld a, (.dmark)  
4111 32 71 ee			ld (debug_mark),a  
4114 3a 23 41			ld a, (.dmark+1)  
4117 32 72 ee			ld (debug_mark+1),a  
411a 3a 24 41			ld a, (.dmark+2)  
411d 32 73 ee			ld (debug_mark+2),a  
4120 18 03			jr .pastdmark  
4122 ..			.dmark: db "TCd"  
4125 f1			.pastdmark: pop af  
4126			endm  
# End of macro DMARK
4126						CALLMONITOR 
4126 cd a8 15			call break_point_state  
4129				endm  
# End of macro CALLMONITOR
4129					endif 
4129					NEXTW 
4129 c3 87 1f			jp macro_next 
412c				endm 
# End of macro NEXTW
412c			 
412c			.SUBSTR: 
412c				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
412c 48				db WORD_SYS_CORE+52             
412d 8a 41			dw .LEFT            
412f 07				db 6 + 1 
4130 .. 00			db "SUBSTR",0              
4137				endm 
# End of macro CWHEAD
4137			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
4137			 
4137					if DEBUG_FORTH_WORDS_KEY 
4137						DMARK "SST" 
4137 f5				push af  
4138 3a 4c 41			ld a, (.dmark)  
413b 32 71 ee			ld (debug_mark),a  
413e 3a 4d 41			ld a, (.dmark+1)  
4141 32 72 ee			ld (debug_mark+1),a  
4144 3a 4e 41			ld a, (.dmark+2)  
4147 32 73 ee			ld (debug_mark+2),a  
414a 18 03			jr .pastdmark  
414c ..			.dmark: db "SST"  
414f f1			.pastdmark: pop af  
4150			endm  
# End of macro DMARK
4150						CALLMONITOR 
4150 cd a8 15			call break_point_state  
4153				endm  
# End of macro CALLMONITOR
4153					endif 
4153			; TODO check string type 
4153					FORTH_DSP_VALUEHL 
4153 cd 10 1e			call macro_dsp_valuehl 
4156				endm 
# End of macro FORTH_DSP_VALUEHL
4156			 
4156 e5					push hl      ; string length 
4157			 
4157					FORTH_DSP_POP 
4157 cd c8 1e			call macro_forth_dsp_pop 
415a				endm 
# End of macro FORTH_DSP_POP
415a			 
415a					FORTH_DSP_VALUEHL 
415a cd 10 1e			call macro_dsp_valuehl 
415d				endm 
# End of macro FORTH_DSP_VALUEHL
415d			 
415d e5					push hl     ; start char 
415e			 
415e					FORTH_DSP_POP 
415e cd c8 1e			call macro_forth_dsp_pop 
4161				endm 
# End of macro FORTH_DSP_POP
4161			 
4161			 
4161					FORTH_DSP_VALUE 
4161 cd f9 1d			call macro_forth_dsp_value 
4164				endm 
# End of macro FORTH_DSP_VALUE
4164			 
4164 d1					pop de    ; get start post offset 
4165			 
4165 19					add hl, de    ; starting offset 
4166			 
4166 c1					pop bc 
4167 c5					push bc      ; grab size of string 
4168			 
4168 e5					push hl    ; save string start  
4169			 
4169 26 00				ld h, 0 
416b 69					ld l, c 
416c 23					inc hl 
416d 23					inc hl 
416e			 
416e cd 6e 12				call malloc 
4171				if DEBUG_FORTH_MALLOC_GUARD 
4171 cc ee 47				call z,malloc_error 
4174				endif 
4174			 
4174 eb					ex de, hl      ; save malloc area for string copy 
4175 e1					pop hl    ; get back source 
4176 c1					pop bc    ; get length of string back 
4177			 
4177 d5					push de    ; save malloc area for after we push 
4178 ed b0				ldir     ; copy substr 
417a			 
417a			 
417a eb					ex de, hl 
417b 3e 00				ld a, 0 
417d 77					ld (hl), a   ; term substr 
417e			 
417e					 
417e e1					pop hl    ; get malloc so we can push it 
417f e5					push hl   ; save so we can free it afterwards 
4180			 
4180 cd 87 1c				call forth_push_str 
4183			 
4183 e1					pop hl 
4184 cd 38 13				call free 
4187			 
4187					 
4187					 
4187			 
4187			 
4187					NEXTW 
4187 c3 87 1f			jp macro_next 
418a				endm 
# End of macro NEXTW
418a			 
418a			.LEFT: 
418a				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
418a 48				db WORD_SYS_CORE+52             
418b b2 41			dw .RIGHT            
418d 05				db 4 + 1 
418e .. 00			db "LEFT",0              
4193				endm 
# End of macro CWHEAD
4193			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
4193					if DEBUG_FORTH_WORDS_KEY 
4193						DMARK "LEF" 
4193 f5				push af  
4194 3a a8 41			ld a, (.dmark)  
4197 32 71 ee			ld (debug_mark),a  
419a 3a a9 41			ld a, (.dmark+1)  
419d 32 72 ee			ld (debug_mark+1),a  
41a0 3a aa 41			ld a, (.dmark+2)  
41a3 32 73 ee			ld (debug_mark+2),a  
41a6 18 03			jr .pastdmark  
41a8 ..			.dmark: db "LEF"  
41ab f1			.pastdmark: pop af  
41ac			endm  
# End of macro DMARK
41ac						CALLMONITOR 
41ac cd a8 15			call break_point_state  
41af				endm  
# End of macro CALLMONITOR
41af					endif 
41af			 
41af					NEXTW 
41af c3 87 1f			jp macro_next 
41b2				endm 
# End of macro NEXTW
41b2			.RIGHT: 
41b2				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
41b2 48				db WORD_SYS_CORE+52             
41b3 db 41			dw .STR2NUM            
41b5 06				db 5 + 1 
41b6 .. 00			db "RIGHT",0              
41bc				endm 
# End of macro CWHEAD
41bc			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
41bc					if DEBUG_FORTH_WORDS_KEY 
41bc						DMARK "RIG" 
41bc f5				push af  
41bd 3a d1 41			ld a, (.dmark)  
41c0 32 71 ee			ld (debug_mark),a  
41c3 3a d2 41			ld a, (.dmark+1)  
41c6 32 72 ee			ld (debug_mark+1),a  
41c9 3a d3 41			ld a, (.dmark+2)  
41cc 32 73 ee			ld (debug_mark+2),a  
41cf 18 03			jr .pastdmark  
41d1 ..			.dmark: db "RIG"  
41d4 f1			.pastdmark: pop af  
41d5			endm  
# End of macro DMARK
41d5						CALLMONITOR 
41d5 cd a8 15			call break_point_state  
41d8				endm  
# End of macro CALLMONITOR
41d8					endif 
41d8			 
41d8					NEXTW 
41d8 c3 87 1f			jp macro_next 
41db				endm 
# End of macro NEXTW
41db			 
41db			 
41db			.STR2NUM: 
41db				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
41db 48				db WORD_SYS_CORE+52             
41dc 67 42			dw .NUM2STR            
41de 08				db 7 + 1 
41df .. 00			db "STR2NUM",0              
41e7				endm 
# End of macro CWHEAD
41e7			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
41e7			 
41e7			 
41e7			; TODO STR type check to do 
41e7					if DEBUG_FORTH_WORDS_KEY 
41e7						DMARK "S2N" 
41e7 f5				push af  
41e8 3a fc 41			ld a, (.dmark)  
41eb 32 71 ee			ld (debug_mark),a  
41ee 3a fd 41			ld a, (.dmark+1)  
41f1 32 72 ee			ld (debug_mark+1),a  
41f4 3a fe 41			ld a, (.dmark+2)  
41f7 32 73 ee			ld (debug_mark+2),a  
41fa 18 03			jr .pastdmark  
41fc ..			.dmark: db "S2N"  
41ff f1			.pastdmark: pop af  
4200			endm  
# End of macro DMARK
4200						CALLMONITOR 
4200 cd a8 15			call break_point_state  
4203				endm  
# End of macro CALLMONITOR
4203					endif 
4203			 
4203					;FORTH_DSP 
4203					FORTH_DSP_VALUE 
4203 cd f9 1d			call macro_forth_dsp_value 
4206				endm 
# End of macro FORTH_DSP_VALUE
4206					;inc hl 
4206			 
4206 eb					ex de, hl 
4207					if DEBUG_FORTH_WORDS 
4207						DMARK "S2a" 
4207 f5				push af  
4208 3a 1c 42			ld a, (.dmark)  
420b 32 71 ee			ld (debug_mark),a  
420e 3a 1d 42			ld a, (.dmark+1)  
4211 32 72 ee			ld (debug_mark+1),a  
4214 3a 1e 42			ld a, (.dmark+2)  
4217 32 73 ee			ld (debug_mark+2),a  
421a 18 03			jr .pastdmark  
421c ..			.dmark: db "S2a"  
421f f1			.pastdmark: pop af  
4220			endm  
# End of macro DMARK
4220						CALLMONITOR 
4220 cd a8 15			call break_point_state  
4223				endm  
# End of macro CALLMONITOR
4223					endif 
4223 cd 9c 11				call string_to_uint16 
4226			 
4226					if DEBUG_FORTH_WORDS 
4226						DMARK "S2b" 
4226 f5				push af  
4227 3a 3b 42			ld a, (.dmark)  
422a 32 71 ee			ld (debug_mark),a  
422d 3a 3c 42			ld a, (.dmark+1)  
4230 32 72 ee			ld (debug_mark+1),a  
4233 3a 3d 42			ld a, (.dmark+2)  
4236 32 73 ee			ld (debug_mark+2),a  
4239 18 03			jr .pastdmark  
423b ..			.dmark: db "S2b"  
423e f1			.pastdmark: pop af  
423f			endm  
# End of macro DMARK
423f						CALLMONITOR 
423f cd a8 15			call break_point_state  
4242				endm  
# End of macro CALLMONITOR
4242					endif 
4242			;		push hl 
4242					FORTH_DSP_POP 
4242 cd c8 1e			call macro_forth_dsp_pop 
4245				endm 
# End of macro FORTH_DSP_POP
4245			;		pop hl 
4245					 
4245					if DEBUG_FORTH_WORDS 
4245						DMARK "S2b" 
4245 f5				push af  
4246 3a 5a 42			ld a, (.dmark)  
4249 32 71 ee			ld (debug_mark),a  
424c 3a 5b 42			ld a, (.dmark+1)  
424f 32 72 ee			ld (debug_mark+1),a  
4252 3a 5c 42			ld a, (.dmark+2)  
4255 32 73 ee			ld (debug_mark+2),a  
4258 18 03			jr .pastdmark  
425a ..			.dmark: db "S2b"  
425d f1			.pastdmark: pop af  
425e			endm  
# End of macro DMARK
425e						CALLMONITOR 
425e cd a8 15			call break_point_state  
4261				endm  
# End of macro CALLMONITOR
4261					endif 
4261 cd 19 1c				call forth_push_numhl	 
4264			 
4264				 
4264				       NEXTW 
4264 c3 87 1f			jp macro_next 
4267				endm 
# End of macro NEXTW
4267			.NUM2STR: 
4267				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
4267 48				db WORD_SYS_CORE+52             
4268 76 42			dw .CONCAT            
426a 08				db 7 + 1 
426b .. 00			db "NUM2STR",0              
4273				endm 
# End of macro CWHEAD
4273			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
4273			 
4273			;		; malloc a string to target 
4273			;		ld hl, 10     ; TODO max string size should be fine 
4273			;		call malloc 
4273			;		push hl    ; save malloc location 
4273			; 
4273			; 
4273			;; TODO check int type 
4273			;		FORTH_DSP_VALUEHL 
4273			;		ld a, l 
4273			;		call DispAToASCII   
4273			;;TODO need to chage above call to dump into string 
4273			; 
4273			; 
4273			 
4273				       NEXTW 
4273 c3 87 1f			jp macro_next 
4276				endm 
# End of macro NEXTW
4276			 
4276			.CONCAT: 
4276				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
4276 48				db WORD_SYS_CORE+52             
4277 29 43			dw .FIND            
4279 07				db 6 + 1 
427a .. 00			db "CONCAT",0              
4281				endm 
# End of macro CWHEAD
4281			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
4281			 
4281			; TODO check string type 
4281			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
4281			 
4281					if DEBUG_FORTH_WORDS_KEY 
4281						DMARK "CON" 
4281 f5				push af  
4282 3a 96 42			ld a, (.dmark)  
4285 32 71 ee			ld (debug_mark),a  
4288 3a 97 42			ld a, (.dmark+1)  
428b 32 72 ee			ld (debug_mark+1),a  
428e 3a 98 42			ld a, (.dmark+2)  
4291 32 73 ee			ld (debug_mark+2),a  
4294 18 03			jr .pastdmark  
4296 ..			.dmark: db "CON"  
4299 f1			.pastdmark: pop af  
429a			endm  
# End of macro DMARK
429a						CALLMONITOR 
429a cd a8 15			call break_point_state  
429d				endm  
# End of macro CALLMONITOR
429d					endif 
429d			 
429d			 
429d					FORTH_DSP_VALUE 
429d cd f9 1d			call macro_forth_dsp_value 
42a0				endm 
# End of macro FORTH_DSP_VALUE
42a0 e5					push hl   ; s2 
42a1			 
42a1					FORTH_DSP_POP 
42a1 cd c8 1e			call macro_forth_dsp_pop 
42a4				endm 
# End of macro FORTH_DSP_POP
42a4			 
42a4					FORTH_DSP_VALUE 
42a4 cd f9 1d			call macro_forth_dsp_value 
42a7				endm 
# End of macro FORTH_DSP_VALUE
42a7			 
42a7 e5					push hl   ; s1 
42a8			 
42a8					FORTH_DSP_POP 
42a8 cd c8 1e			call macro_forth_dsp_pop 
42ab				endm 
# End of macro FORTH_DSP_POP
42ab					 
42ab			 
42ab					; copy s1 
42ab			 
42ab				 
42ab					; save ptr 
42ab e1					pop hl  
42ac e5					push hl 
42ad 3e 00				ld a, 0 
42af cd 10 12				call strlent 
42b2					;inc hl    ; zer0 
42b2 06 00				ld b, 0 
42b4 4d					ld c, l 
42b5 e1					pop hl		 
42b6 11 02 e3				ld de, scratch	 
42b9					if DEBUG_FORTH_WORDS 
42b9						DMARK "CO1" 
42b9 f5				push af  
42ba 3a ce 42			ld a, (.dmark)  
42bd 32 71 ee			ld (debug_mark),a  
42c0 3a cf 42			ld a, (.dmark+1)  
42c3 32 72 ee			ld (debug_mark+1),a  
42c6 3a d0 42			ld a, (.dmark+2)  
42c9 32 73 ee			ld (debug_mark+2),a  
42cc 18 03			jr .pastdmark  
42ce ..			.dmark: db "CO1"  
42d1 f1			.pastdmark: pop af  
42d2			endm  
# End of macro DMARK
42d2						CALLMONITOR 
42d2 cd a8 15			call break_point_state  
42d5				endm  
# End of macro CALLMONITOR
42d5					endif 
42d5 ed b0				ldir 
42d7			 
42d7 e1					pop hl 
42d8 e5					push hl 
42d9 d5					push de 
42da			 
42da			 
42da 3e 00				ld a, 0 
42dc cd 10 12				call strlent 
42df 23					inc hl    ; zer0 
42e0 23					inc hl 
42e1 06 00				ld b, 0 
42e3 4d					ld c, l 
42e4 d1					pop de 
42e5 e1					pop hl		 
42e6					if DEBUG_FORTH_WORDS 
42e6						DMARK "CO2" 
42e6 f5				push af  
42e7 3a fb 42			ld a, (.dmark)  
42ea 32 71 ee			ld (debug_mark),a  
42ed 3a fc 42			ld a, (.dmark+1)  
42f0 32 72 ee			ld (debug_mark+1),a  
42f3 3a fd 42			ld a, (.dmark+2)  
42f6 32 73 ee			ld (debug_mark+2),a  
42f9 18 03			jr .pastdmark  
42fb ..			.dmark: db "CO2"  
42fe f1			.pastdmark: pop af  
42ff			endm  
# End of macro DMARK
42ff						CALLMONITOR 
42ff cd a8 15			call break_point_state  
4302				endm  
# End of macro CALLMONITOR
4302					endif 
4302 ed b0				ldir 
4304			 
4304			 
4304			 
4304 21 02 e3				ld hl, scratch 
4307					if DEBUG_FORTH_WORDS 
4307						DMARK "CO5" 
4307 f5				push af  
4308 3a 1c 43			ld a, (.dmark)  
430b 32 71 ee			ld (debug_mark),a  
430e 3a 1d 43			ld a, (.dmark+1)  
4311 32 72 ee			ld (debug_mark+1),a  
4314 3a 1e 43			ld a, (.dmark+2)  
4317 32 73 ee			ld (debug_mark+2),a  
431a 18 03			jr .pastdmark  
431c ..			.dmark: db "CO5"  
431f f1			.pastdmark: pop af  
4320			endm  
# End of macro DMARK
4320						CALLMONITOR 
4320 cd a8 15			call break_point_state  
4323				endm  
# End of macro CALLMONITOR
4323					endif 
4323			 
4323 cd 87 1c				call forth_push_str 
4326			 
4326			 
4326			 
4326			 
4326				       NEXTW 
4326 c3 87 1f			jp macro_next 
4329				endm 
# End of macro NEXTW
4329			 
4329			 
4329			.FIND: 
4329				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
4329 4b				db WORD_SYS_CORE+55             
432a e7 43			dw .LEN            
432c 05				db 4 + 1 
432d .. 00			db "FIND",0              
4332				endm 
# End of macro CWHEAD
4332			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
4332			 
4332					if DEBUG_FORTH_WORDS_KEY 
4332						DMARK "FND" 
4332 f5				push af  
4333 3a 47 43			ld a, (.dmark)  
4336 32 71 ee			ld (debug_mark),a  
4339 3a 48 43			ld a, (.dmark+1)  
433c 32 72 ee			ld (debug_mark+1),a  
433f 3a 49 43			ld a, (.dmark+2)  
4342 32 73 ee			ld (debug_mark+2),a  
4345 18 03			jr .pastdmark  
4347 ..			.dmark: db "FND"  
434a f1			.pastdmark: pop af  
434b			endm  
# End of macro DMARK
434b						CALLMONITOR 
434b cd a8 15			call break_point_state  
434e				endm  
# End of macro CALLMONITOR
434e					endif 
434e			 
434e			; TODO check string type 
434e					FORTH_DSP_VALUE 
434e cd f9 1d			call macro_forth_dsp_value 
4351				endm 
# End of macro FORTH_DSP_VALUE
4351			 
4351 e5					push hl    
4352 7e					ld a,(hl)    ; char to find   
4353			; TODO change char to substr 
4353			 
4353 f5					push af 
4354					 
4354			 
4354			 
4354					if DEBUG_FORTH_WORDS 
4354						DMARK "FN1" 
4354 f5				push af  
4355 3a 69 43			ld a, (.dmark)  
4358 32 71 ee			ld (debug_mark),a  
435b 3a 6a 43			ld a, (.dmark+1)  
435e 32 72 ee			ld (debug_mark+1),a  
4361 3a 6b 43			ld a, (.dmark+2)  
4364 32 73 ee			ld (debug_mark+2),a  
4367 18 03			jr .pastdmark  
4369 ..			.dmark: db "FN1"  
436c f1			.pastdmark: pop af  
436d			endm  
# End of macro DMARK
436d						CALLMONITOR 
436d cd a8 15			call break_point_state  
4370				endm  
# End of macro CALLMONITOR
4370					endif 
4370			 
4370					FORTH_DSP_POP 
4370 cd c8 1e			call macro_forth_dsp_pop 
4373				endm 
# End of macro FORTH_DSP_POP
4373			 
4373					; string to search 
4373			 
4373					FORTH_DSP_VALUE 
4373 cd f9 1d			call macro_forth_dsp_value 
4376				endm 
# End of macro FORTH_DSP_VALUE
4376			 
4376 d1					pop de  ; d is char to find  
4377			 
4377					if DEBUG_FORTH_WORDS 
4377						DMARK "FN2" 
4377 f5				push af  
4378 3a 8c 43			ld a, (.dmark)  
437b 32 71 ee			ld (debug_mark),a  
437e 3a 8d 43			ld a, (.dmark+1)  
4381 32 72 ee			ld (debug_mark+1),a  
4384 3a 8e 43			ld a, (.dmark+2)  
4387 32 73 ee			ld (debug_mark+2),a  
438a 18 03			jr .pastdmark  
438c ..			.dmark: db "FN2"  
438f f1			.pastdmark: pop af  
4390			endm  
# End of macro DMARK
4390						CALLMONITOR 
4390 cd a8 15			call break_point_state  
4393				endm  
# End of macro CALLMONITOR
4393					endif 
4393					 
4393 01 00 00				ld bc, 0 
4396 7e			.findchar:      ld a,(hl) 
4397 fe 00				cp 0   		 
4399 28 27				jr z, .finddone     
439b ba					cp d 
439c 28 20				jr z, .foundchar 
439e 03					inc bc 
439f 23					inc hl 
43a0					if DEBUG_FORTH_WORDS 
43a0						DMARK "FN3" 
43a0 f5				push af  
43a1 3a b5 43			ld a, (.dmark)  
43a4 32 71 ee			ld (debug_mark),a  
43a7 3a b6 43			ld a, (.dmark+1)  
43aa 32 72 ee			ld (debug_mark+1),a  
43ad 3a b7 43			ld a, (.dmark+2)  
43b0 32 73 ee			ld (debug_mark+2),a  
43b3 18 03			jr .pastdmark  
43b5 ..			.dmark: db "FN3"  
43b8 f1			.pastdmark: pop af  
43b9			endm  
# End of macro DMARK
43b9						CALLMONITOR 
43b9 cd a8 15			call break_point_state  
43bc				endm  
# End of macro CALLMONITOR
43bc					endif 
43bc 18 d8				jr .findchar 
43be			 
43be			 
43be c5			.foundchar:	push bc 
43bf e1					pop hl 
43c0 18 03				jr .findexit 
43c2			 
43c2			 
43c2							 
43c2			 
43c2			.finddone:     ; got to end of string with no find 
43c2 21 00 00				ld hl, 0 
43c5			.findexit: 
43c5			 
43c5					if DEBUG_FORTH_WORDS 
43c5						DMARK "FNd" 
43c5 f5				push af  
43c6 3a da 43			ld a, (.dmark)  
43c9 32 71 ee			ld (debug_mark),a  
43cc 3a db 43			ld a, (.dmark+1)  
43cf 32 72 ee			ld (debug_mark+1),a  
43d2 3a dc 43			ld a, (.dmark+2)  
43d5 32 73 ee			ld (debug_mark+2),a  
43d8 18 03			jr .pastdmark  
43da ..			.dmark: db "FNd"  
43dd f1			.pastdmark: pop af  
43de			endm  
# End of macro DMARK
43de						CALLMONITOR 
43de cd a8 15			call break_point_state  
43e1				endm  
# End of macro CALLMONITOR
43e1					endif 
43e1 cd 19 1c			call forth_push_numhl 
43e4			 
43e4				       NEXTW 
43e4 c3 87 1f			jp macro_next 
43e7				endm 
# End of macro NEXTW
43e7			 
43e7			.LEN: 
43e7				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
43e7 4c				db WORD_SYS_CORE+56             
43e8 51 44			dw .CHAR            
43ea 06				db 5 + 1 
43eb .. 00			db "COUNT",0              
43f1				endm 
# End of macro CWHEAD
43f1			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
43f1			 
43f1					if DEBUG_FORTH_WORDS_KEY 
43f1						DMARK "CNT" 
43f1 f5				push af  
43f2 3a 06 44			ld a, (.dmark)  
43f5 32 71 ee			ld (debug_mark),a  
43f8 3a 07 44			ld a, (.dmark+1)  
43fb 32 72 ee			ld (debug_mark+1),a  
43fe 3a 08 44			ld a, (.dmark+2)  
4401 32 73 ee			ld (debug_mark+2),a  
4404 18 03			jr .pastdmark  
4406 ..			.dmark: db "CNT"  
4409 f1			.pastdmark: pop af  
440a			endm  
# End of macro DMARK
440a						CALLMONITOR 
440a cd a8 15			call break_point_state  
440d				endm  
# End of macro CALLMONITOR
440d					endif 
440d			; TODO check string type 
440d					FORTH_DSP_VALUE 
440d cd f9 1d			call macro_forth_dsp_value 
4410				endm 
# End of macro FORTH_DSP_VALUE
4410			 
4410			 
4410					if DEBUG_FORTH_WORDS 
4410						DMARK "CN?" 
4410 f5				push af  
4411 3a 25 44			ld a, (.dmark)  
4414 32 71 ee			ld (debug_mark),a  
4417 3a 26 44			ld a, (.dmark+1)  
441a 32 72 ee			ld (debug_mark+1),a  
441d 3a 27 44			ld a, (.dmark+2)  
4420 32 73 ee			ld (debug_mark+2),a  
4423 18 03			jr .pastdmark  
4425 ..			.dmark: db "CN?"  
4428 f1			.pastdmark: pop af  
4429			endm  
# End of macro DMARK
4429						CALLMONITOR 
4429 cd a8 15			call break_point_state  
442c				endm  
# End of macro CALLMONITOR
442c					endif 
442c cd 05 12				call strlenz 
442f					if DEBUG_FORTH_WORDS 
442f						DMARK "CNl" 
442f f5				push af  
4430 3a 44 44			ld a, (.dmark)  
4433 32 71 ee			ld (debug_mark),a  
4436 3a 45 44			ld a, (.dmark+1)  
4439 32 72 ee			ld (debug_mark+1),a  
443c 3a 46 44			ld a, (.dmark+2)  
443f 32 73 ee			ld (debug_mark+2),a  
4442 18 03			jr .pastdmark  
4444 ..			.dmark: db "CNl"  
4447 f1			.pastdmark: pop af  
4448			endm  
# End of macro DMARK
4448						CALLMONITOR 
4448 cd a8 15			call break_point_state  
444b				endm  
# End of macro CALLMONITOR
444b					endif 
444b			 
444b cd 19 1c				call forth_push_numhl 
444e			 
444e			 
444e			 
444e				       NEXTW 
444e c3 87 1f			jp macro_next 
4451				endm 
# End of macro NEXTW
4451			.CHAR: 
4451				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
4451 4d				db WORD_SYS_CORE+57             
4452 87 44			dw .ENDSTR            
4454 05				db 4 + 1 
4455 .. 00			db "CHAR",0              
445a				endm 
# End of macro CWHEAD
445a			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
445a					if DEBUG_FORTH_WORDS_KEY 
445a						DMARK "CHR" 
445a f5				push af  
445b 3a 6f 44			ld a, (.dmark)  
445e 32 71 ee			ld (debug_mark),a  
4461 3a 70 44			ld a, (.dmark+1)  
4464 32 72 ee			ld (debug_mark+1),a  
4467 3a 71 44			ld a, (.dmark+2)  
446a 32 73 ee			ld (debug_mark+2),a  
446d 18 03			jr .pastdmark  
446f ..			.dmark: db "CHR"  
4472 f1			.pastdmark: pop af  
4473			endm  
# End of macro DMARK
4473						CALLMONITOR 
4473 cd a8 15			call break_point_state  
4476				endm  
# End of macro CALLMONITOR
4476					endif 
4476					FORTH_DSP 
4476 cd d6 1d			call macro_forth_dsp 
4479				endm 
# End of macro FORTH_DSP
4479					;v5 FORTH_DSP_VALUE 
4479 23					inc hl      ; now at start of numeric as string 
447a			 
447a			;		push hl 
447a			 
447a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
447a cd c8 1e			call macro_forth_dsp_pop 
447d				endm 
# End of macro FORTH_DSP_POP
447d			 
447d			;		pop hl 
447d			 
447d					; push the content of a onto the stack as a value 
447d			 
447d 7e					ld a,(hl)   ; get char 
447e 26 00				ld h,0 
4480 6f					ld l,a 
4481 cd 19 1c				call forth_push_numhl 
4484			 
4484				       NEXTW 
4484 c3 87 1f			jp macro_next 
4487				endm 
# End of macro NEXTW
4487			 
4487			 
4487			 
4487			 
4487			.ENDSTR: 
4487			; eof 
4487			 
# End of file forth_words_str.asm
4487			include "forth_words_key.asm" 
4487			 
4487			; | ## Keyboard Words 
4487			 
4487			.KEY: 
4487				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
4487 3e				db WORD_SYS_CORE+42             
4488 b7 44			dw .WAITK            
448a 04				db 3 + 1 
448b .. 00			db "KEY",0              
448f				endm 
# End of macro CWHEAD
448f			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
448f			 
448f					if DEBUG_FORTH_WORDS_KEY 
448f						DMARK "KEY" 
448f f5				push af  
4490 3a a4 44			ld a, (.dmark)  
4493 32 71 ee			ld (debug_mark),a  
4496 3a a5 44			ld a, (.dmark+1)  
4499 32 72 ee			ld (debug_mark+1),a  
449c 3a a6 44			ld a, (.dmark+2)  
449f 32 73 ee			ld (debug_mark+2),a  
44a2 18 03			jr .pastdmark  
44a4 ..			.dmark: db "KEY"  
44a7 f1			.pastdmark: pop af  
44a8			endm  
# End of macro DMARK
44a8						CALLMONITOR 
44a8 cd a8 15			call break_point_state  
44ab				endm  
# End of macro CALLMONITOR
44ab					endif 
44ab			; TODO currently waits 
44ab cd f0 5b				call cin 
44ae					;call cin_wait 
44ae 6f					ld l, a 
44af 26 00				ld h, 0 
44b1 cd 19 1c				call forth_push_numhl 
44b4					NEXTW 
44b4 c3 87 1f			jp macro_next 
44b7				endm 
# End of macro NEXTW
44b7			.WAITK: 
44b7				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
44b7 3f				db WORD_SYS_CORE+43             
44b8 e9 44			dw .ACCEPT            
44ba 06				db 5 + 1 
44bb .. 00			db "WAITK",0              
44c1				endm 
# End of macro CWHEAD
44c1			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
44c1					if DEBUG_FORTH_WORDS_KEY 
44c1						DMARK "WAI" 
44c1 f5				push af  
44c2 3a d6 44			ld a, (.dmark)  
44c5 32 71 ee			ld (debug_mark),a  
44c8 3a d7 44			ld a, (.dmark+1)  
44cb 32 72 ee			ld (debug_mark+1),a  
44ce 3a d8 44			ld a, (.dmark+2)  
44d1 32 73 ee			ld (debug_mark+2),a  
44d4 18 03			jr .pastdmark  
44d6 ..			.dmark: db "WAI"  
44d9 f1			.pastdmark: pop af  
44da			endm  
# End of macro DMARK
44da						CALLMONITOR 
44da cd a8 15			call break_point_state  
44dd				endm  
# End of macro CALLMONITOR
44dd					endif 
44dd cd e8 5b				call cin_wait 
44e0 6f					ld l, a 
44e1 26 00				ld h, 0 
44e3 cd 19 1c				call forth_push_numhl 
44e6					NEXTW 
44e6 c3 87 1f			jp macro_next 
44e9				endm 
# End of macro NEXTW
44e9			.ACCEPT: 
44e9				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
44e9 40				db WORD_SYS_CORE+44             
44ea 47 45			dw .EDIT            
44ec 07				db 6 + 1 
44ed .. 00			db "ACCEPT",0              
44f4				endm 
# End of macro CWHEAD
44f4			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
44f4					; TODO crashes on push 
44f4					if DEBUG_FORTH_WORDS_KEY 
44f4						DMARK "ACC" 
44f4 f5				push af  
44f5 3a 09 45			ld a, (.dmark)  
44f8 32 71 ee			ld (debug_mark),a  
44fb 3a 0a 45			ld a, (.dmark+1)  
44fe 32 72 ee			ld (debug_mark+1),a  
4501 3a 0b 45			ld a, (.dmark+2)  
4504 32 73 ee			ld (debug_mark+2),a  
4507 18 03			jr .pastdmark  
4509 ..			.dmark: db "ACC"  
450c f1			.pastdmark: pop af  
450d			endm  
# End of macro DMARK
450d						CALLMONITOR 
450d cd a8 15			call break_point_state  
4510				endm  
# End of macro CALLMONITOR
4510					endif 
4510 21 00 e5				ld hl, os_input 
4513 3e 00				ld a, 0 
4515 77					ld (hl),a 
4516 3a 6b ea				ld a,(f_cursor_ptr) 
4519 16 64				ld d, 100 
451b 0e 00				ld c, 0 
451d 1e 28				ld e, 40 
451f cd d4 0d				call input_str 
4522					; TODO perhaps do a type check and wrap in quotes if not a number 
4522 21 00 e5				ld hl, os_input 
4525					if DEBUG_FORTH_WORDS 
4525						DMARK "AC1" 
4525 f5				push af  
4526 3a 3a 45			ld a, (.dmark)  
4529 32 71 ee			ld (debug_mark),a  
452c 3a 3b 45			ld a, (.dmark+1)  
452f 32 72 ee			ld (debug_mark+1),a  
4532 3a 3c 45			ld a, (.dmark+2)  
4535 32 73 ee			ld (debug_mark+2),a  
4538 18 03			jr .pastdmark  
453a ..			.dmark: db "AC1"  
453d f1			.pastdmark: pop af  
453e			endm  
# End of macro DMARK
453e						CALLMONITOR 
453e cd a8 15			call break_point_state  
4541				endm  
# End of macro CALLMONITOR
4541					endif 
4541 cd 87 1c				call forth_push_str 
4544					NEXTW 
4544 c3 87 1f			jp macro_next 
4547				endm 
# End of macro NEXTW
4547			 
4547			.EDIT: 
4547				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
4547 40				db WORD_SYS_CORE+44             
4548 e9 45			dw .ENDKEY            
454a 05				db 4 + 1 
454b .. 00			db "EDIT",0              
4550				endm 
# End of macro CWHEAD
4550			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4550			 
4550					; TODO does not copy from stack 
4550					if DEBUG_FORTH_WORDS_KEY 
4550						DMARK "EDT" 
4550 f5				push af  
4551 3a 65 45			ld a, (.dmark)  
4554 32 71 ee			ld (debug_mark),a  
4557 3a 66 45			ld a, (.dmark+1)  
455a 32 72 ee			ld (debug_mark+1),a  
455d 3a 67 45			ld a, (.dmark+2)  
4560 32 73 ee			ld (debug_mark+2),a  
4563 18 03			jr .pastdmark  
4565 ..			.dmark: db "EDT"  
4568 f1			.pastdmark: pop af  
4569			endm  
# End of macro DMARK
4569						CALLMONITOR 
4569 cd a8 15			call break_point_state  
456c				endm  
# End of macro CALLMONITOR
456c					endif 
456c			 
456c					;FORTH_DSP 
456c					FORTH_DSP_VALUEHL 
456c cd 10 1e			call macro_dsp_valuehl 
456f				endm 
# End of macro FORTH_DSP_VALUEHL
456f			;		inc hl    ; TODO do type check 
456f			 
456f			;		call get_word_hl 
456f e5					push hl 
4570					if DEBUG_FORTH_WORDS 
4570						DMARK "EDp" 
4570 f5				push af  
4571 3a 85 45			ld a, (.dmark)  
4574 32 71 ee			ld (debug_mark),a  
4577 3a 86 45			ld a, (.dmark+1)  
457a 32 72 ee			ld (debug_mark+1),a  
457d 3a 87 45			ld a, (.dmark+2)  
4580 32 73 ee			ld (debug_mark+2),a  
4583 18 03			jr .pastdmark  
4585 ..			.dmark: db "EDp"  
4588 f1			.pastdmark: pop af  
4589			endm  
# End of macro DMARK
4589						CALLMONITOR 
4589 cd a8 15			call break_point_state  
458c				endm  
# End of macro CALLMONITOR
458c					endif 
458c				;	ld a, 0 
458c cd 05 12				call strlenz 
458f 23					inc hl 
4590			 
4590 06 00				ld b, 0 
4592 4d					ld c, l 
4593			 
4593 e1					pop hl 
4594 11 00 e5				ld de, os_input 
4597					if DEBUG_FORTH_WORDS_KEY 
4597						DMARK "EDc" 
4597 f5				push af  
4598 3a ac 45			ld a, (.dmark)  
459b 32 71 ee			ld (debug_mark),a  
459e 3a ad 45			ld a, (.dmark+1)  
45a1 32 72 ee			ld (debug_mark+1),a  
45a4 3a ae 45			ld a, (.dmark+2)  
45a7 32 73 ee			ld (debug_mark+2),a  
45aa 18 03			jr .pastdmark  
45ac ..			.dmark: db "EDc"  
45af f1			.pastdmark: pop af  
45b0			endm  
# End of macro DMARK
45b0						CALLMONITOR 
45b0 cd a8 15			call break_point_state  
45b3				endm  
# End of macro CALLMONITOR
45b3					endif 
45b3 ed b0				ldir 
45b5			 
45b5			 
45b5 21 00 e5				ld hl, os_input 
45b8					;ld a, 0 
45b8					;ld (hl),a 
45b8 3a 6b ea				ld a,(f_cursor_ptr) 
45bb 16 64				ld d, 100 
45bd 0e 00				ld c, 0 
45bf 1e 28				ld e, 40 
45c1 cd d4 0d				call input_str 
45c4					; TODO perhaps do a type check and wrap in quotes if not a number 
45c4 21 00 e5				ld hl, os_input 
45c7					if DEBUG_FORTH_WORDS 
45c7						DMARK "ED1" 
45c7 f5				push af  
45c8 3a dc 45			ld a, (.dmark)  
45cb 32 71 ee			ld (debug_mark),a  
45ce 3a dd 45			ld a, (.dmark+1)  
45d1 32 72 ee			ld (debug_mark+1),a  
45d4 3a de 45			ld a, (.dmark+2)  
45d7 32 73 ee			ld (debug_mark+2),a  
45da 18 03			jr .pastdmark  
45dc ..			.dmark: db "ED1"  
45df f1			.pastdmark: pop af  
45e0			endm  
# End of macro DMARK
45e0						CALLMONITOR 
45e0 cd a8 15			call break_point_state  
45e3				endm  
# End of macro CALLMONITOR
45e3					endif 
45e3 cd 87 1c				call forth_push_str 
45e6					NEXTW 
45e6 c3 87 1f			jp macro_next 
45e9				endm 
# End of macro NEXTW
45e9			 
45e9			 
45e9			 
45e9			.ENDKEY: 
45e9			; eof 
45e9			 
# End of file forth_words_key.asm
45e9			 
45e9			if STORAGE_SE 
45e9			   	include "forth_words_storage.asm" 
45e9			endif 
45e9				include "forth_words_device.asm" 
45e9			; Device related words 
45e9			 
45e9			; | ## Device Words 
45e9			 
45e9			if SOUND_ENABLE 
45e9			.NOTE: 
45e9				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
45e9			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
45e9					if DEBUG_FORTH_WORDS_KEY 
45e9						DMARK "NTE" 
45e9						CALLMONITOR 
45e9					endif 
45e9			 
45e9				 
45e9			 
45e9					NEXTW 
45e9			.AFTERSOUND: 
45e9			endif 
45e9			 
45e9			 
45e9			USE_GPIO: equ 0 
45e9			 
45e9			if USE_GPIO 
45e9			.GP1: 
45e9				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
45e9			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
45e9					NEXTW 
45e9			.GP2: 
45e9				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
45e9			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
45e9			 
45e9					NEXTW 
45e9			 
45e9			.GP3: 
45e9				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
45e9			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
45e9			 
45e9					NEXTW 
45e9			 
45e9			.GP4: 
45e9				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
45e9			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
45e9			 
45e9					NEXTW 
45e9			.SIN: 
45e9			 
45e9			 
45e9			endif 
45e9			 
45e9			 
45e9				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
45e9 33				db WORD_SYS_CORE+31             
45ea 1e 46			dw .SOUT            
45ec 03				db 2 + 1 
45ed .. 00			db "IN",0              
45f0				endm 
# End of macro CWHEAD
45f0			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
45f0					if DEBUG_FORTH_WORDS_KEY 
45f0						DMARK "IN." 
45f0 f5				push af  
45f1 3a 05 46			ld a, (.dmark)  
45f4 32 71 ee			ld (debug_mark),a  
45f7 3a 06 46			ld a, (.dmark+1)  
45fa 32 72 ee			ld (debug_mark+1),a  
45fd 3a 07 46			ld a, (.dmark+2)  
4600 32 73 ee			ld (debug_mark+2),a  
4603 18 03			jr .pastdmark  
4605 ..			.dmark: db "IN."  
4608 f1			.pastdmark: pop af  
4609			endm  
# End of macro DMARK
4609						CALLMONITOR 
4609 cd a8 15			call break_point_state  
460c				endm  
# End of macro CALLMONITOR
460c					endif 
460c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
460c cd 10 1e			call macro_dsp_valuehl 
460f				endm 
# End of macro FORTH_DSP_VALUEHL
460f			 
460f e5					push hl 
4610			 
4610					; destroy value TOS 
4610			 
4610					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4610 cd c8 1e			call macro_forth_dsp_pop 
4613				endm 
# End of macro FORTH_DSP_POP
4613			 
4613					; one value on hl get other one back 
4613			 
4613 c1					pop bc 
4614			 
4614					; do the sub 
4614			;		ex de, hl 
4614			 
4614 ed 68				in l,(c) 
4616			 
4616					; save it 
4616			 
4616 26 00				ld h,0 
4618			 
4618					; TODO push value back onto stack for another op etc 
4618			 
4618 cd 19 1c				call forth_push_numhl 
461b					NEXTW 
461b c3 87 1f			jp macro_next 
461e				endm 
# End of macro NEXTW
461e			.SOUT: 
461e				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
461e 34				db WORD_SYS_CORE+32             
461f 71 46			dw .SPIO            
4621 04				db 3 + 1 
4622 .. 00			db "OUT",0              
4626				endm 
# End of macro CWHEAD
4626			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
4626					if DEBUG_FORTH_WORDS_KEY 
4626						DMARK "OUT" 
4626 f5				push af  
4627 3a 3b 46			ld a, (.dmark)  
462a 32 71 ee			ld (debug_mark),a  
462d 3a 3c 46			ld a, (.dmark+1)  
4630 32 72 ee			ld (debug_mark+1),a  
4633 3a 3d 46			ld a, (.dmark+2)  
4636 32 73 ee			ld (debug_mark+2),a  
4639 18 03			jr .pastdmark  
463b ..			.dmark: db "OUT"  
463e f1			.pastdmark: pop af  
463f			endm  
# End of macro DMARK
463f						CALLMONITOR 
463f cd a8 15			call break_point_state  
4642				endm  
# End of macro CALLMONITOR
4642					endif 
4642			 
4642					; get port 
4642			 
4642					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4642 cd 10 1e			call macro_dsp_valuehl 
4645				endm 
# End of macro FORTH_DSP_VALUEHL
4645			 
4645 e5					push hl 
4646			 
4646					; destroy value TOS 
4646			 
4646					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4646 cd c8 1e			call macro_forth_dsp_pop 
4649				endm 
# End of macro FORTH_DSP_POP
4649			 
4649					; get byte to send 
4649			 
4649					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4649 cd 10 1e			call macro_dsp_valuehl 
464c				endm 
# End of macro FORTH_DSP_VALUEHL
464c			 
464c			;		push hl 
464c			 
464c					; destroy value TOS 
464c			 
464c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
464c cd c8 1e			call macro_forth_dsp_pop 
464f				endm 
# End of macro FORTH_DSP_POP
464f			 
464f					; one value on hl get other one back 
464f			 
464f			;		pop hl 
464f			 
464f c1					pop bc 
4650			 
4650					if DEBUG_FORTH_WORDS 
4650						DMARK "OUT" 
4650 f5				push af  
4651 3a 65 46			ld a, (.dmark)  
4654 32 71 ee			ld (debug_mark),a  
4657 3a 66 46			ld a, (.dmark+1)  
465a 32 72 ee			ld (debug_mark+1),a  
465d 3a 67 46			ld a, (.dmark+2)  
4660 32 73 ee			ld (debug_mark+2),a  
4663 18 03			jr .pastdmark  
4665 ..			.dmark: db "OUT"  
4668 f1			.pastdmark: pop af  
4669			endm  
# End of macro DMARK
4669						CALLMONITOR 
4669 cd a8 15			call break_point_state  
466c				endm  
# End of macro CALLMONITOR
466c					endif 
466c			 
466c ed 69				out (c), l 
466e			 
466e					NEXTW 
466e c3 87 1f			jp macro_next 
4671				endm 
# End of macro NEXTW
4671			 
4671			 
4671			.SPIO: 
4671			 
4671			if STORAGE_SE 
4671				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
4671			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
4671			 
4671					call spi_ce_low 
4671			    NEXTW 
4671			 
4671			.SPICEH: 
4671				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
4671			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
4671			 
4671					call spi_ce_high 
4671			    NEXTW 
4671			 
4671			 
4671			.SPIOb: 
4671			 
4671				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
4671			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
4671			 
4671					; get port 
4671			 
4671			 
4671					; get byte to send 
4671			 
4671					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4671			 
4671			;		push hl    ; u1  
4671			 
4671					; destroy value TOS 
4671			 
4671					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4671			 
4671					; one value on hl get other one back 
4671			 
4671			;		pop hl   ; u2 - addr 
4671			 
4671					; TODO Send SPI byte 
4671			 
4671					ld a, l 
4671					call spi_send_byte 
4671			 
4671					NEXTW 
4671			 
4671			.SPII: 
4671				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
4671			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
4671			 
4671					; TODO Get SPI byte 
4671			 
4671					call spi_read_byte 
4671			 
4671					ld h, 0 
4671					ld l, a 
4671					call forth_push_numhl 
4671			 
4671					NEXTW 
4671			 
4671			 
4671			 
4671			.SESEL: 
4671				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
4671			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
4671					if DEBUG_FORTH_WORDS_KEY 
4671						DMARK "BNK" 
4671						CALLMONITOR 
4671					endif 
4671			 
4671					ld a, 255 
4671					ld (spi_cartdev), a 
4671			 
4671					; get bank 
4671			 
4671					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4671			 
4671			;		push hl 
4671			 
4671					; destroy value TOS 
4671			 
4671					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4671			 
4671					; one value on hl get other one back 
4671			 
4671			;		pop hl 
4671			 
4671			 
4671					ld c, SPI_CE_HIGH 
4671					ld b, '0'    ; human readable bank number 
4671			 
4671					ld a, l 
4671			 
4671					if DEBUG_FORTH_WORDS 
4671						DMARK "BNK" 
4671						CALLMONITOR 
4671					endif 
4671			 
4671					; active low 
4671			 
4671					cp 0 
4671					jr z, .bset 
4671					cp 1 
4671					jr nz, .b2 
4671					res 0, c 
4671					ld b, '1'    ; human readable bank number 
4671			.b2:		cp 2 
4671					jr nz, .b3 
4671					res 1, c 
4671					ld b, '2'    ; human readable bank number 
4671			.b3:		cp 3 
4671					jr nz, .b4 
4671					res 2, c 
4671					ld b, '3'    ; human readable bank number 
4671			.b4:		cp 4 
4671					jr nz, .b5 
4671					res 3, c 
4671					ld b, '4'    ; human readable bank number 
4671			.b5:		cp 5 
4671					jr nz, .bset 
4671					res 4, c 
4671					ld b, '5'    ; human readable bank number 
4671			 
4671			.bset: 
4671					ld a, c 
4671					ld (spi_device),a 
4671					ld a, b 
4671					ld (spi_device_id),a 
4671					if DEBUG_FORTH_WORDS 
4671						DMARK "BN2" 
4671						CALLMONITOR 
4671					endif 
4671			 
4671					NEXTW 
4671			 
4671			.CARTDEV: 
4671				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
4671			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
4671					if DEBUG_FORTH_WORDS_KEY 
4671						DMARK "CDV" 
4671						CALLMONITOR 
4671					endif 
4671			 
4671					; disable se storage bank selection 
4671			 
4671					ld a, SPI_CE_HIGH		; ce high 
4671					ld (spi_device), a 
4671			 
4671					; get bank 
4671			 
4671					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4671			 
4671			;		push hl 
4671			 
4671					; destroy value TOS 
4671			 
4671					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4671			 
4671					; one value on hl get other one back 
4671			 
4671			;		pop hl 
4671			 
4671					; active low 
4671			 
4671					ld c, 255 
4671			 
4671					ld a, l 
4671					if DEBUG_FORTH_WORDS 
4671						DMARK "CDV" 
4671						CALLMONITOR 
4671					endif 
4671					cp 0 
4671					jr z, .cset 
4671					cp 1 
4671					jr nz, .c2 
4671					res 0, c 
4671			.c2:		cp 2 
4671					jr nz, .c3 
4671					res 1, c 
4671			.c3:		cp 3 
4671					jr nz, .c4 
4671					res 2, c 
4671			.c4:		cp 4 
4671					jr nz, .c5 
4671					res 3, c 
4671			.c5:		cp 5 
4671					jr nz, .c6 
4671					res 4, c 
4671			.c6:		cp 6 
4671					jr nz, .c7 
4671					res 5, c 
4671			.c7:		cp 7 
4671					jr nz, .c8 
4671					res 6, c 
4671			.c8:		cp 8 
4671					jr nz, .cset 
4671					res 7, c 
4671			.cset:		ld a, c 
4671					ld (spi_cartdev),a 
4671			 
4671					if DEBUG_FORTH_WORDS 
4671						DMARK "CD2" 
4671						CALLMONITOR 
4671					endif 
4671					NEXTW 
4671			endif 
4671			 
4671			.ENDDEVICE: 
4671			; eof 
4671			 
# End of file forth_words_device.asm
4671			 
4671			; var handler 
4671			 
4671			 
4671			.VARS: 
4671				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
4671 78				db WORD_SYS_CORE+100             
4672 89 46			dw .V0Q            
4674 04				db 3 + 1 
4675 .. 00			db "V0!",0              
4679				endm 
# End of macro CWHEAD
4679			;| V0! ( u1 -- )  Store value to v0  | DONE 
4679			 
4679					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4679 cd 10 1e			call macro_dsp_valuehl 
467c				endm 
# End of macro FORTH_DSP_VALUEHL
467c			 
467c 11 35 ea				ld de, cli_var_array 
467f			 
467f eb					ex de, hl 
4680 73					ld (hl), e 
4681 23					inc hl 
4682 72					ld (hl), d 
4683			 
4683					; destroy value TOS 
4683			 
4683					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4683 cd c8 1e			call macro_forth_dsp_pop 
4686				endm 
# End of macro FORTH_DSP_POP
4686			 
4686				       NEXTW 
4686 c3 87 1f			jp macro_next 
4689				endm 
# End of macro NEXTW
4689			.V0Q: 
4689				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
4689 79				db WORD_SYS_CORE+101             
468a 9a 46			dw .V1S            
468c 04				db 3 + 1 
468d .. 00			db "V0@",0              
4691				endm 
# End of macro CWHEAD
4691			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
4691 2a 35 ea				ld hl, (cli_var_array) 
4694 cd 19 1c				call forth_push_numhl 
4697			 
4697				       NEXTW 
4697 c3 87 1f			jp macro_next 
469a				endm 
# End of macro NEXTW
469a			.V1S: 
469a				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
469a 7a				db WORD_SYS_CORE+102             
469b b2 46			dw .V1Q            
469d 04				db 3 + 1 
469e .. 00			db "V1!",0              
46a2				endm 
# End of macro CWHEAD
46a2			;| V1! ( u1 -- )  Store value to v1 | DONE 
46a2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
46a2 cd 10 1e			call macro_dsp_valuehl 
46a5				endm 
# End of macro FORTH_DSP_VALUEHL
46a5			 
46a5 11 37 ea				ld de, cli_var_array+2 
46a8				 
46a8 eb					ex de, hl 
46a9 73					ld (hl), e 
46aa 23					inc hl 
46ab 72					ld (hl), d 
46ac			 
46ac					; destroy value TOS 
46ac			 
46ac					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
46ac cd c8 1e			call macro_forth_dsp_pop 
46af				endm 
# End of macro FORTH_DSP_POP
46af				       NEXTW 
46af c3 87 1f			jp macro_next 
46b2				endm 
# End of macro NEXTW
46b2			.V1Q: 
46b2				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
46b2 7b				db WORD_SYS_CORE+103             
46b3 c3 46			dw .V2S            
46b5 04				db 3 + 1 
46b6 .. 00			db "V1@",0              
46ba				endm 
# End of macro CWHEAD
46ba			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
46ba 2a 37 ea				ld hl, (cli_var_array+2) 
46bd cd 19 1c				call forth_push_numhl 
46c0				       NEXTW 
46c0 c3 87 1f			jp macro_next 
46c3				endm 
# End of macro NEXTW
46c3			.V2S: 
46c3				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
46c3 7c				db WORD_SYS_CORE+104             
46c4 db 46			dw .V2Q            
46c6 04				db 3 + 1 
46c7 .. 00			db "V2!",0              
46cb				endm 
# End of macro CWHEAD
46cb			;| V2! ( u1 -- )  Store value to v2 | DONE 
46cb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
46cb cd 10 1e			call macro_dsp_valuehl 
46ce				endm 
# End of macro FORTH_DSP_VALUEHL
46ce			 
46ce 11 39 ea				ld de, cli_var_array+4 
46d1				 
46d1 eb					ex de, hl 
46d2 73					ld (hl), e 
46d3 23					inc hl 
46d4 72					ld (hl), d 
46d5			 
46d5					; destroy value TOS 
46d5			 
46d5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
46d5 cd c8 1e			call macro_forth_dsp_pop 
46d8				endm 
# End of macro FORTH_DSP_POP
46d8				       NEXTW 
46d8 c3 87 1f			jp macro_next 
46db				endm 
# End of macro NEXTW
46db			.V2Q: 
46db				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
46db 7d				db WORD_SYS_CORE+105             
46dc ec 46			dw .V3S            
46de 04				db 3 + 1 
46df .. 00			db "V2@",0              
46e3				endm 
# End of macro CWHEAD
46e3			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
46e3 2a 39 ea				ld hl, (cli_var_array+4) 
46e6 cd 19 1c				call forth_push_numhl 
46e9				       NEXTW 
46e9 c3 87 1f			jp macro_next 
46ec				endm 
# End of macro NEXTW
46ec			.V3S: 
46ec				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
46ec 7c				db WORD_SYS_CORE+104             
46ed 04 47			dw .V3Q            
46ef 04				db 3 + 1 
46f0 .. 00			db "V3!",0              
46f4				endm 
# End of macro CWHEAD
46f4			;| V3! ( u1 -- )  Store value to v3 | DONE 
46f4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
46f4 cd 10 1e			call macro_dsp_valuehl 
46f7				endm 
# End of macro FORTH_DSP_VALUEHL
46f7			 
46f7 11 3b ea				ld de, cli_var_array+6 
46fa				 
46fa eb					ex de, hl 
46fb 73					ld (hl), e 
46fc 23					inc hl 
46fd 72					ld (hl), d 
46fe			 
46fe					; destroy value TOS 
46fe			 
46fe					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
46fe cd c8 1e			call macro_forth_dsp_pop 
4701				endm 
# End of macro FORTH_DSP_POP
4701				       NEXTW 
4701 c3 87 1f			jp macro_next 
4704				endm 
# End of macro NEXTW
4704			.V3Q: 
4704				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
4704 7d				db WORD_SYS_CORE+105             
4705 15 47			dw .END            
4707 04				db 3 + 1 
4708 .. 00			db "V3@",0              
470c				endm 
# End of macro CWHEAD
470c			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
470c 2a 3b ea				ld hl, (cli_var_array+6) 
470f cd 19 1c				call forth_push_numhl 
4712				       NEXTW 
4712 c3 87 1f			jp macro_next 
4715				endm 
# End of macro NEXTW
4715			 
4715			 
4715			 
4715			 
4715			 
4715			; end of dict marker 
4715			 
4715 00			.END:    db WORD_SYS_END 
4716 00 00			dw 0 
4718 00				db 0 
4719			 
4719			; use to jp here for user dict words to save on macro expansion  
4719			 
4719			user_dict_next: 
4719				NEXTW 
4719 c3 87 1f			jp macro_next 
471c				endm 
# End of macro NEXTW
471c			 
471c			 
471c			user_exec: 
471c				;    ld hl, <word code> 
471c				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
471c				;    call forthexec 
471c				;    jp user_dict_next   (NEXT) 
471c			        ;    <word code bytes> 
471c eb				ex de, hl 
471d 2a 03 e6			ld hl,(os_tok_ptr) 
4720				 
4720				FORTH_RSP_NEXT 
4720 cd c0 1b			call macro_forth_rsp_next 
4723				endm 
# End of macro FORTH_RSP_NEXT
4723			 
4723			if DEBUG_FORTH_UWORD 
4723						DMARK "UEX" 
4723 f5				push af  
4724 3a 38 47			ld a, (.dmark)  
4727 32 71 ee			ld (debug_mark),a  
472a 3a 39 47			ld a, (.dmark+1)  
472d 32 72 ee			ld (debug_mark+1),a  
4730 3a 3a 47			ld a, (.dmark+2)  
4733 32 73 ee			ld (debug_mark+2),a  
4736 18 03			jr .pastdmark  
4738 ..			.dmark: db "UEX"  
473b f1			.pastdmark: pop af  
473c			endm  
# End of macro DMARK
473c				CALLMONITOR 
473c cd a8 15			call break_point_state  
473f				endm  
# End of macro CALLMONITOR
473f			endif 
473f			 
473f			 
473f			 
473f eb				ex de, hl 
4740 22 03 e6			ld (os_tok_ptr), hl 
4743				 
4743				; Don't use next - Skips the first word in uword. 
4743			 
4743 c3 18 20			jp exec1 
4746			;	NEXT 
4746			 
4746			 
4746			; eof 
# End of file forth_wordsv4.asm
4746			endif 
4746			;;;;;;;;;;;;;; Debug code 
4746			 
4746			 
4746			;if DEBUG_FORTH_PARSE 
4746 .. 00		.nowordfound: db "No match",0 
474f .. 00		.compword:	db "Comparing word ",0 
475f .. 00		.nextwordat:	db "Next word at",0 
476c .. 00		.charmatch:	db "Char match",0 
4777			;endif 
4777			if DEBUG_FORTH_JP 
4777			.foundword:	db "Word match. Exec..",0 
4777			endif 
4777			;if DEBUG_FORTH_PUSH 
4777 .. 00		.enddict:	db "Dict end. Push.",0 
4787 .. 00		.push_str:	db "Pushing string",0 
4796 .. 00		.push_num:	db "Pushing number",0 
47a5 .. 00		.data_sp:	db "SP:",0 
47a9 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
47bb .. 00		.wordinde:	db "Word in DE (3/0):",0 
47cd .. 00		.wordinbc:	db "Word in BC (4/0):",0 
47df			;endif 
47df			;if DEBUG_FORTH_MALLOC 
47df .. 00		.push_malloc:	db "Malloc address",0 
47ee			;endif 
47ee			 
47ee			 
47ee			 
47ee			; display malloc address and current data stack pointer  
47ee			 
47ee			malloc_error: 
47ee d5				push de 
47ef f5				push af 
47f0 e5				push hl 
47f1 cd 7a 0b			call clear_display 
47f4 11 16 48			ld de, .mallocerr 
47f7 3e 00			ld a,0 
47f9			;	ld de,os_word_scratch 
47f9 cd 8d 0b			call str_at_display 
47fc 3e 11			ld a, display_row_1+17 
47fe 11 71 ee			ld de, debug_mark 
4801 cd 8d 0b			call str_at_display 
4804 cd 9d 0b			call update_display 
4807				;call break_point_state 
4807 cd e8 5b			call cin_wait 
480a			 
480a 3e 20			ld a, ' ' 
480c 32 f3 e2			ld (os_view_disable), a 
480f e1				pop hl 
4810 f1				pop af 
4811 d1				pop de	 
4812				CALLMONITOR 
4812 cd a8 15			call break_point_state  
4815				endm  
# End of macro CALLMONITOR
4815 c9				ret 
4816			 
4816 .. 00		.mallocerr: 	db "Malloc Error",0 
4823			;if DEBUG_FORTH_PUSH 
4823			display_data_sp: 
4823 f5				push af 
4824			 
4824				; see if disabled 
4824			 
4824 3a f3 e2			ld a, (os_view_disable) 
4827 fe 2a			cp '*' 
4829 28 67			jr z, .skipdsp 
482b			 
482b e5				push hl 
482c e5				push hl 
482d e5			push hl 
482e cd 7a 0b			call clear_display 
4831 e1			pop hl 
4832 7c				ld a,h 
4833 21 07 e6			ld hl, os_word_scratch 
4836 cd a8 10			call hexout 
4839 e1				pop hl 
483a 7d				ld a,l 
483b 21 09 e6			ld hl, os_word_scratch+2 
483e cd a8 10			call hexout 
4841 21 0b e6			ld hl, os_word_scratch+4 
4844 3e 00			ld a,0 
4846 77				ld (hl),a 
4847 11 07 e6			ld de,os_word_scratch 
484a 3e 28				ld a, display_row_2 
484c cd 8d 0b				call str_at_display 
484f 11 a9 47			ld de, .wordinhl 
4852 3e 00			ld a, display_row_1 
4854			 
4854 cd 8d 0b				call str_at_display 
4857 11 71 ee			ld de, debug_mark 
485a 3e 11			ld a, display_row_1+17 
485c			 
485c cd 8d 0b				call str_at_display 
485f			 
485f				; display current data stack pointer 
485f 11 a5 47			ld de,.data_sp 
4862 3e 30				ld a, display_row_2 + 8 
4864 cd 8d 0b				call str_at_display 
4867			 
4867 2a 2f ea			ld hl,(cli_data_sp) 
486a e5				push hl 
486b 7c				ld a,h 
486c 21 07 e6			ld hl, os_word_scratch 
486f cd a8 10			call hexout 
4872 e1				pop hl 
4873 7d				ld a,l 
4874 21 09 e6			ld hl, os_word_scratch+2 
4877 cd a8 10			call hexout 
487a 21 0b e6			ld hl, os_word_scratch+4 
487d 3e 00			ld a,0 
487f 77				ld (hl),a 
4880 11 07 e6			ld de,os_word_scratch 
4883 3e 33				ld a, display_row_2 + 11 
4885 cd 8d 0b				call str_at_display 
4888			 
4888			 
4888 cd 9d 0b			call update_display 
488b cd ec 0a			call delay1s 
488e cd ec 0a			call delay1s 
4891 e1				pop hl 
4892			.skipdsp: 
4892 f1				pop af 
4893 c9				ret 
4894			 
4894			display_data_malloc: 
4894			 
4894 f5				push af 
4895 e5				push hl 
4896 e5				push hl 
4897 e5			push hl 
4898 cd 7a 0b			call clear_display 
489b e1			pop hl 
489c 7c				ld a,h 
489d 21 07 e6			ld hl, os_word_scratch 
48a0 cd a8 10			call hexout 
48a3 e1				pop hl 
48a4 7d				ld a,l 
48a5 21 09 e6			ld hl, os_word_scratch+2 
48a8 cd a8 10			call hexout 
48ab 21 0b e6			ld hl, os_word_scratch+4 
48ae 3e 00			ld a,0 
48b0 77				ld (hl),a 
48b1 11 07 e6			ld de,os_word_scratch 
48b4 3e 28				ld a, display_row_2 
48b6 cd 8d 0b				call str_at_display 
48b9 11 df 47			ld de, .push_malloc 
48bc 3e 00			ld a, display_row_1 
48be			 
48be cd 8d 0b				call str_at_display 
48c1			 
48c1				; display current data stack pointer 
48c1 11 a5 47			ld de,.data_sp 
48c4 3e 30				ld a, display_row_2 + 8 
48c6 cd 8d 0b				call str_at_display 
48c9			 
48c9 2a 2f ea			ld hl,(cli_data_sp) 
48cc e5				push hl 
48cd 7c				ld a,h 
48ce 21 07 e6			ld hl, os_word_scratch 
48d1 cd a8 10			call hexout 
48d4 e1				pop hl 
48d5 7d				ld a,l 
48d6 21 09 e6			ld hl, os_word_scratch+2 
48d9 cd a8 10			call hexout 
48dc 21 0b e6			ld hl, os_word_scratch+4 
48df 3e 00			ld a,0 
48e1 77				ld (hl),a 
48e2 11 07 e6			ld de,os_word_scratch 
48e5 3e 33				ld a, display_row_2 + 11 
48e7 cd 8d 0b				call str_at_display 
48ea			 
48ea cd 9d 0b			call update_display 
48ed cd ec 0a			call delay1s 
48f0 cd ec 0a			call delay1s 
48f3 e1				pop hl 
48f4 f1				pop af 
48f5 c9				ret 
48f6			;endif 
48f6			 
48f6			include "forth_autostart.asm" 
48f6			; list of commands to perform at system start up 
48f6			 
48f6			startcmds: 
48f6			;	dw test11 
48f6			;	dw test12 
48f6			;	dw test13 
48f6			;	dw test14 
48f6			;	dw test15 
48f6			;	dw test16 
48f6			;	dw test17 
48f6			;	dw ifthtest1 
48f6			;	dw ifthtest2 
48f6			;	dw ifthtest3 
48f6			;	dw mmtest1 
48f6			;	dw mmtest2 
48f6			;	dw mmtest3 
48f6			;	dw mmtest4 
48f6			;	dw mmtest5 
48f6			;	dw mmtest6 
48f6			;	dw iftest1 
48f6			;	dw iftest2 
48f6			;	dw iftest3 
48f6			;	dw looptest1 
48f6			;	dw looptest2 
48f6			;	dw test1 
48f6			;	dw test2 
48f6			;	dw test3 
48f6			;	dw test4 
48f6			;	dw game2r 
48f6			;	dw game2b1 
48f6			;	dw game2b2 
48f6			 
48f6				; start up words that are actually useful 
48f6			 
48f6 56 49			dw longread 
48f8 9d 49			dw clrstack 
48fa d0 49			dw type 
48fc c0 4b			dw stest 
48fe f4 49			dw strncpy 
4900 56 4b			dw list 
4902 55 4a			dw start1 
4904 67 4a			dw start2 
4906			;	dw start3 
4906 7a 4a			dw start3b 
4908 f6 4a			dw start3c 
490a			 
490a				; (unit) testing words 
490a			 
490a 37 4c			dw mtesta 
490c ec 4c			dw mtestb 
490e 8f 4d			dw mtestc 
4910 44 4e			dw mtestd 
4912 e8 4e			dw mteste 
4914			 
4914				; demo/game words 
4914			 
4914 f4 55		        dw game3w 
4916 22 56		        dw game3p 
4918 40 56		        dw game3sc 
491a 71 56		        dw game3vsi 
491c 9d 56		        dw game3vs 
491e				 
491e e7 53			dw game2b 
4920 55 54			dw game2bf 
4922 9f 54			dw game2mba 
4924 35 55			dw game2mbas 
4926 77 55			dw game2mb 
4928			 
4928 a8 50			dw game1 
492a b9 50			dw game1a 
492c 1b 51			dw game1b 
492e 50 51			dw game1c 
4930 86 51			dw game1d 
4932 b7 51			dw game1s 
4934 cb 51			dw game1t 
4936 e0 51			dw game1f 
4938 14 52			dw game1z 
493a 58 52			dw game1zz 
493c			 
493c 9e 4f			dw test5 
493e d6 4f			dw test6 
4940 0e 50			dw test7 
4942 22 50			dw test8 
4944 4e 50			dw test9 
4946 64 50			dw test10 
4948				 
4948 2f 53		        dw ssv5 
494a 13 53		        dw ssv4 
494c f7 52		        dw ssv3 
494e c1 52		        dw ssv2 
4950 48 53		        dw ssv1 
4952 90 53		        dw ssv1cpm 
4954			;	dw keyup 
4954			;	dw keydown 
4954			;	dw keyleft 
4954			;	dw keyright 
4954			;	dw 	keyf1 
4954			;	dw keyf2 
4954			;	dw keyf3 
4954			;	dw keyf4 
4954			;	dw keyf5 
4954			;	dw keyf6 
4954			;	dw keyf7 
4954			;	dw keyf8 
4954			;	dw keyf9 
4954			;	dw keyf10 
4954			;	dw keyf11 
4954			;	dw keyf12 
4954			;	dw keytab 
4954			;	dw keycr 
4954			;	dw keyhome 
4954			;	dw keyend 
4954			;	dw keybs 
4954 00 00			db 0, 0	 
4956			 
4956			 
4956			; Long read of currently open file 
4956 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
499d			 
499d			; clear stack  
499d			 
499d .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
49d0			 
49d0			; type ( addr count - ) 
49d0 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
49f4			 
49f4			; some direct memory words 
49f4			; strncpy ( len t f -- t ) 
49f4			 
49f4 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
4a55			 
4a55 .. 00		start1:     	db ": bpon $0000 bp ;",0 
4a67 .. 00		start2:     	db ": bpoff $0001 bp ;",0 
4a7a .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
4af6 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
4b56			 
4b56			 
4b56			; a handy word to list items on the stack 
4b56			 
4b56 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
4bc0			 
4bc0			 
4bc0			; test stack  
4bc0			; rnd8 stest 
4bc0			 
4bc0 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
4c37			 
4c37			; random malloc and free cycles 
4c37			 
4c37 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
4cec			 
4cec			; fixed malloc and free cycles 
4cec			 
4cec .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
4d8f			 
4d8f			; fixed double string push and drop cycle  
4d8f			 
4d8f .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
4e44			 
4e44			; consistent fixed string push and drop cycle  
4e44			 
4e44 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
4ee8			 
4ee8 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
4f9e			 
4f9e			;test1:		db ": aa 1 2 3 ;", 0 
4f9e			;test2:     	db "111 aa 888 999",0 
4f9e			;test3:     	db ": bb 77 ;",0 
4f9e			;test4:     	db "$02 $01 do i . loop bb",0 
4f9e			 
4f9e .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
4fd6 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
500e .. 00		test7:     	db ": box hline vline ;",0 
5022 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
504e .. 00		test9:     	db ": sw $01 adsp world ;",0 
5064 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
5089 .. 00		test11:     	db "hello create .",0 
5098 .. 00		test12:     	db "hello2 create .",0 
50a8			 
50a8			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
50a8			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
50a8			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
50a8			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
50a8			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
50a8			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
50a8			 
50a8			;iftest1:     	db "$0001 IF cls .",0 
50a8			;iftest2:     	db "$0000 IF cls .",0 
50a8			;iftest3:     	db "$0002 $0003 - IF cls .",0 
50a8			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
50a8			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
50a8			 
50a8			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
50a8			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
50a8			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
50a8			 
50a8			 
50a8			 
50a8			; a small guess the number game 
50a8			 
50a8 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
50b9 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
511b			 
511b .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
5150 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
5186 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
51b7 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
51cb .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
51e0 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5214 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
5258			 
5258			; Using 'ga' save a high score across multiple runs using external storage 
5258			 
5258 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
52c1			 
52c1			 
52c1			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
52c1			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
52c1			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
52c1			 
52c1			; simple screen saver to test code memory reuse to destruction 
52c1			 
52c1 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
52f7 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
5313 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
532f .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
5348 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
5390 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
53e7			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
53e7			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
53e7			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
53e7			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
53e7			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
53e7			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
53e7			 
53e7			 
53e7			 
53e7			; minesweeper/battleship finding game 
53e7			; draws a game board of random ship/mine positions 
53e7			; user enters coords to see if it hits on 
53e7			; game ends when all are hit 
53e7			; when hit or miss says how many may be in the area 
53e7			 
53e7			; setup the game board and then hide it 
53e7 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
5455 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
549f			; prompt for where to target 
549f .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
5535 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
555a			; TODO see if the entered coords hits or misses pushes char hit of miss 
555a .. 00		game2mbht:      db ": mbckht nop ;",0 
5569 .. 00		game2mbms:      db ": mbcms nop ;",0 
5577			; TODO how many might be near by 
5577 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
55f4			 
55f4			; Game 3 
55f4			 
55f4			; Vert scroller ski game - avoid the trees! 
55f4			 
55f4			; v0 score (ie turns) 
55f4			; v1 player pos 
55f4			; v2 left wall 
55f4			; v3 right wall 
55f4			 
55f4			; Draw side walls randomly 
55f4			 
55f4 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
5622			 
5622			; Draw player 
5622 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
5640			 
5640			; TODO Get Key 
5640			 
5640			; TODO Move left right 
5640			 
5640			; scroll and move walls a bit 
5640			 
5640 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
5671			 
5671			; main game loop 
5671			 
5671 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
569d .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
56dc			 
56dc			; key board defs 
56dc			 
56dc .. 00		keyup:       db ": keyup $05 ;",0 
56ea .. 00		keydown:       db ": keydown $0a ;",0 
56fa .. 00		keyleft:       db ": keyleft $0b ;",0 
570a .. 00		keyright:       db ": keyright $0c ;",0 
571b .. 00		keyf1:       db ": keyf1 $10 ;",0 
5729 .. 00		keyf2:       db ": keyf2 $11 ;",0 
5737 .. 00		keyf3:       db ": keyf3 $12 ;",0 
5745 .. 00		keyf4:       db ": keyf4 $13 ;",0 
5753 .. 00		keyf5:       db ": keyf5 $14 ;",0 
5761 .. 00		keyf6:       db ": keyf6 $15 ;",0 
576f .. 00		keyf7:       db ": keyf7 $16 ;",0 
577d .. 00		keyf8:       db ": keyf8 $17 ;",0 
578b .. 00		keyf9:       db ": keyf9 $18 ;",0 
5799 .. 00		keyf10:       db ": keyf10 $19 ;",0 
57a8 .. 00		keyf11:       db ": keyf11 $1a ;",0 
57b7 .. 00		keyf12:       db ": keyf12 $1b ;",0 
57c6			 
57c6 .. 00		keytab:       db ": keytab $09 ;",0 
57d5 .. 00		keycr:       db ": keycr $0d ;",0 
57e3 .. 00		keyhome:       db ": keyhome $0e ;",0 
57f3 .. 00		keyend:       db ": keyend $0f ;",0 
5802 .. 00		keybs:       db ": keybs $08 ;",0 
5810			 
5810			   
5810			 
5810			 
5810			 
5810			; eof 
# End of file forth_autostart.asm
5810			 
5810 .. 00		sprompt1: db "Startup load...",0 
5820 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
5836			 
5836			 
5836			 
5836			 
5836			forth_startup: 
5836 21 f6 48			ld hl, startcmds 
5839 3e 00			ld a, 0 
583b 32 28 e7			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
583e			 
583e e5			.start1:	push hl 
583f cd 7a 0b			call clear_display 
5842 11 10 58			ld de, sprompt1 
5845 3e 00		        ld a, display_row_1 
5847 cd 8d 0b			call str_at_display 
584a 11 20 58			ld de, sprompt2 
584d 3e 28		        ld a, display_row_2 
584f cd 8d 0b			call str_at_display 
5852 e1				pop hl 
5853 e5				push hl 
5854 5e				ld e,(hl) 
5855 23				inc hl 
5856 56				ld d,(hl) 
5857 3e 50		        ld a, display_row_3 
5859 cd 8d 0b			call str_at_display 
585c cd 9d 0b			call update_display 
585f			 
585f			 
585f 3a 28 e7			ld a, (os_last_cmd) 
5862 fe 00			cp 0 
5864 28 05			jr z, .startprompt 
5866 cd e0 0a			call delay250ms 
5869 18 24			jr .startdo 
586b				 
586b				 
586b			 
586b			.startprompt: 
586b			 
586b 3e 9f			ld a,display_row_4 + display_cols - 1 
586d 11 8f 1b		        ld de, endprg 
5870 cd 8d 0b			call str_at_display 
5873 cd 9d 0b			call update_display 
5876 cd ec 0a			call delay1s 
5879 cd e8 5b			call cin_wait 
587c						 
587c fe 2a			cp '*' 
587e 28 5e			jr z, .startupend1 
5880 fe 23			cp '#' 
5882 20 07			jr nz, .startno 
5884 3e 01			ld a, 1 
5886 32 28 e7			ld (os_last_cmd),a 
5889 18 04			jr .startdo 
588b fe 31		.startno:	cp '1' 
588d 28 3a			jr z,.startnxt  
588f			 
588f				; exec startup line 
588f			.startdo:	 
588f e1				pop hl 
5890 e5				push hl 
5891				 
5891 5e				ld e,(hl) 
5892 23				inc hl 
5893 56				ld d,(hl) 
5894 eb				ex de,hl 
5895			 
5895 e5				push hl 
5896			 
5896 3e 00			ld a, 0 
5898				;ld a, FORTH_END_BUFFER 
5898 cd 10 12			call strlent 
589b 23				inc hl   ; include zero term to copy 
589c 06 00			ld b,0 
589e 4d				ld c,l 
589f e1				pop hl 
58a0 11 02 e3			ld de, scratch 
58a3 ed b0			ldir 
58a5			 
58a5			 
58a5 21 02 e3			ld hl, scratch 
58a8 cd d5 1f			call forthparse 
58ab cd 15 20			call forthexec 
58ae cd 27 1f			call forthexec_cleanup 
58b1			 
58b1 3e 78			ld a, display_row_4 
58b3 11 33 19			ld de, endprog 
58b6			 
58b6 cd 9d 0b			call update_display		 
58b9			 
58b9 3a 28 e7			ld a, (os_last_cmd) 
58bc fe 00			cp 0 
58be 20 09			jr nz, .startnxt 
58c0 cd 91 1b			call next_page_prompt 
58c3 cd 7a 0b		        call clear_display 
58c6 cd 9d 0b			call update_display		 
58c9			 
58c9				; move onto next startup line? 
58c9			.startnxt: 
58c9			 
58c9 cd e0 0a			call delay250ms 
58cc e1				pop hl 
58cd			 
58cd 23				inc hl 
58ce 23				inc hl 
58cf			 
58cf e5				push hl 
58d0 5e				ld e, (hl) 
58d1 23				inc hl 
58d2 56				ld d, (hl) 
58d3 e1				pop hl 
58d4				; TODO replace 0 test 
58d4			 
58d4 eb				ex de, hl 
58d5 cd d0 0d			call ishlzero 
58d8			;	ld a,e 
58d8			;	add d 
58d8			;	cp 0    ; any left to do? 
58d8 eb				ex de, hl 
58d9 c2 3e 58			jp nz, .start1 
58dc 18 01			jr .startupend 
58de			 
58de e1			.startupend1: pop hl 
58df			.startupend: 
58df			 
58df cd 7a 0b			call clear_display 
58e2 cd 9d 0b			call update_display 
58e5 c9				ret 
58e6			 
58e6			 
58e6			; stack over and underflow checks 
58e6			 
58e6			; init the words to detect the under/overflow 
58e6			 
58e6			chk_stk_init: 
58e6				; a vague random number to check so we dont get any "lucky" hits 
58e6 3e 2d			ld a, 45 
58e8 6f				ld l, a 
58e9 00				nop 
58ea 3e 17			ld a, 23 
58ec 67				ld h, a 
58ed			 
58ed 22 e9 e2			ld (chk_word), hl     ; the word we need to check against 
58f0			 
58f0			;	ld (chk_stund), hl	; stack points.... 
58f0 22 00 ef			ld (chk_stovr), hl 
58f3 22 2d ea			ld (chk_ret_und), hl 
58f6 22 eb e9			ld (chk_ret_ovr), hl 
58f9 22 69 e9			ld (chk_loop_ovr), hl 
58fc 22 67 e8			ld (chk_data_ovr), hl 
58ff c9				ret 
5900				 
5900			check_stacks: 
5900				; check all stack words 
5900			 
5900 e5				push hl 
5901 d5				push de 
5902			 
5902			;	ld de,(chk_word) 
5902			;	ld hl, (chk_stund)	; stack points.... 
5902			;	if DEBUG_STK_FAULT 
5902			;		DMARK "FAa" 
5902			;		CALLMONITOR 
5902			;	endif 
5902			;	call cmp16 
5902			;	jp z, .chk_faulta 
5902			; 
5902			;	ld de, sfaultsu 
5902			;	jp .chk_fault 
5902			 
5902 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
5905 ed 5b e9 e2		ld de,(chk_word) 
5909				if DEBUG_STK_FAULT 
5909					DMARK "FAb" 
5909					CALLMONITOR 
5909				endif 
5909 cd c5 0d			call cmp16 
590c 28 06			jr z, .chk_fault1 
590e 11 af 59			ld de, sfaultso 
5911 c3 63 59			jp .chk_fault 
5914			.chk_fault1:  
5914 2a 2d ea			ld hl, (chk_ret_und) 
5917 ed 5b e9 e2		ld de,(chk_word) 
591b				if DEBUG_STK_FAULT 
591b					DMARK "FAU" 
591b					CALLMONITOR 
591b				endif 
591b cd c5 0d			call cmp16 
591e ca 27 59			jp z, .chk_fault2 
5921 11 bf 59			ld de, sfaultru 
5924 c3 63 59			jp .chk_fault 
5927			.chk_fault2:  
5927 2a eb e9			ld hl, (chk_ret_ovr) 
592a ed 5b e9 e2		ld de,(chk_word) 
592e				if DEBUG_STK_FAULT 
592e					DMARK "FA1" 
592e					CALLMONITOR 
592e				endif 
592e cd c5 0d			call cmp16 
5931 ca 3a 59			jp z, .chk_fault3 
5934 11 cd 59			ld de, sfaultro 
5937 c3 63 59			jp .chk_fault 
593a			.chk_fault3:  
593a 2a 69 e9			ld hl, (chk_loop_ovr) 
593d ed 5b e9 e2		ld de,(chk_word) 
5941				if DEBUG_STK_FAULT 
5941					DMARK "FA2" 
5941					CALLMONITOR 
5941				endif 
5941 cd c5 0d			call cmp16 
5944 ca 4d 59			jp z, .chk_fault4 
5947 11 e7 59			ld de, sfaultlo 
594a c3 63 59			jp .chk_fault 
594d			.chk_fault4:  
594d 2a 67 e8			ld hl, (chk_data_ovr) 
5950 ed 5b e9 e2		ld de,(chk_word) 
5954				if DEBUG_STK_FAULT 
5954					DMARK "FA3" 
5954					CALLMONITOR 
5954				endif 
5954 cd c5 0d			call cmp16 
5957 ca 60 59			jp z, .chk_fault5 
595a 11 01 5a			ld de, sfaultdo 
595d c3 63 59			jp .chk_fault 
5960			 
5960			 
5960			.chk_fault5:  
5960 d1				pop de 
5961 e1				pop hl 
5962			 
5962 c9				ret 
5963			 
5963 cd 7a 0b		.chk_fault: 	call clear_display 
5966 3e 28				ld a, display_row_2 
5968 cd 8d 0b				call str_at_display 
596b 11 91 59				   ld de, .stackfault 
596e 3e 00				ld a, display_row_1 
5970 cd 8d 0b				call str_at_display 
5973 11 71 ee				    ld de, debug_mark 
5976 3e 11				ld a, display_row_1+17 
5978 cd 8d 0b				call str_at_display 
597b cd 9d 0b				call update_display 
597e			 
597e				; prompt before entering montior for investigating issue 
597e			 
597e 3e 78			ld a, display_row_4 
5980 11 33 19			ld de, endprog 
5983			 
5983 cd 9d 0b			call update_display		 
5986			 
5986 cd 91 1b			call next_page_prompt 
5989			 
5989 d1				pop de 
598a e1				pop hl 
598b cd 87 19				call monitor 
598e c3 81 18				jp warmstart 
5991					;jp 0 
5991					;halt 
5991			 
5991			 
5991			 
5991 .. 00		.stackfault: 	db "Stack fault:",0 
599e			 
599e .. 00		sfaultsu: 	db	"Stack under flow",0 
59af .. 00		sfaultso: 	db	"Stack over flow",0 
59bf .. 00		sfaultru:	db "RTS underflow",0 
59cd .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
59e7 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
5a01 .. 00		sfaultdo:	db "DTS overflow", 0 
5a0e			 
5a0e			 
5a0e			fault_dsp_under: 
5a0e 11 20 5a			ld de, .dsp_under 
5a11 c3 d0 5a			jp .show_fault 
5a14			 
5a14			fault_rsp_under: 
5a14 11 2e 5a			ld de, .rsp_under 
5a17 c3 d0 5a			jp .show_fault 
5a1a			fault_loop_under: 
5a1a 11 3c 5a			ld de, .loop_under 
5a1d c3 d0 5a			jp .show_fault 
5a20			 
5a20 .. 00		.dsp_under: db "DSP Underflow",0 
5a2e .. 00		.rsp_under: db "RSP Underflow",0 
5a3c .. 00		.loop_under: db "LOOP Underflow",0 
5a4b			 
5a4b			 
5a4b d5			type_faultn: 	push de 
5a4c e5					push hl 
5a4d cd 7a 0b				call clear_display 
5a50 11 77 5a				   ld de, .typefaultn 
5a53 3e 00				ld a, display_row_1 
5a55 cd 8d 0b				call str_at_display 
5a58 11 71 ee				    ld de, debug_mark 
5a5b 3e 11				ld a, display_row_1+17 
5a5d cd 8d 0b				call str_at_display 
5a60 cd 9d 0b				call update_display 
5a63			 
5a63				; prompt before entering montior for investigating issue 
5a63			 
5a63 3e 78			ld a, display_row_4 
5a65 11 33 19			ld de, endprog 
5a68			 
5a68 cd 9d 0b			call update_display		 
5a6b			 
5a6b cd 91 1b			call next_page_prompt 
5a6e			 
5a6e e5					push hl 
5a6f d5					push de 
5a70 cd 87 19				call monitor 
5a73 c3 81 18				jp warmstart 
5a76 76					halt 
5a77			 
5a77			 
5a77 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
5a8e			 
5a8e d5			type_faults: 	push de 
5a8f e5					push hl 
5a90 cd 7a 0b				call clear_display 
5a93 11 b9 5a				   ld de, .typefaults 
5a96 3e 00				ld a, display_row_1 
5a98 cd 8d 0b				call str_at_display 
5a9b 11 71 ee				    ld de, debug_mark 
5a9e 3e 11				ld a, display_row_1+17 
5aa0 cd 8d 0b				call str_at_display 
5aa3 cd 9d 0b				call update_display 
5aa6			 
5aa6				; prompt before entering montior for investigating issue 
5aa6			 
5aa6 3e 78			ld a, display_row_4 
5aa8 11 33 19			ld de, endprog 
5aab			 
5aab cd 9d 0b			call update_display		 
5aae			 
5aae cd 91 1b			call next_page_prompt 
5ab1			 
5ab1 e1					pop hl 
5ab2 d1					pop de 
5ab3 cd 87 19				call monitor 
5ab6 c3 81 18				jp warmstart 
5ab9			 
5ab9			 
5ab9 .. 00		.typefaults: db "STR Type Expected TOS!",0 
5ad0			 
5ad0			.show_fault: 	 
5ad0 d5					push de 
5ad1 cd 7a 0b				call clear_display 
5ad4 d1					pop de 
5ad5 3e 00				ld a, display_row_1 
5ad7 cd 8d 0b				call str_at_display 
5ada 11 71 ee				    ld de, debug_mark 
5add 3e 11				ld a, display_row_1+17 
5adf cd 8d 0b				call str_at_display 
5ae2 cd 9d 0b				call update_display 
5ae5			 
5ae5				; prompt before entering montior for investigating issue 
5ae5			 
5ae5 3e 78			ld a, display_row_4 
5ae7 11 33 19			ld de, endprog 
5aea			 
5aea cd 9d 0b			call update_display		 
5aed			 
5aed cd 91 1b			call next_page_prompt 
5af0			 
5af0 e1					pop hl 
5af1 d1					pop de 
5af2 cd 87 19				call monitor 
5af5			; do a dump to cli and not warmstart so we preserve all of the uwords.  
5af5			; TODO Make optional fault restart to cli or warm boot? 
5af5					;jp warmstart 
5af5 c3 d9 18				jp cli 
5af8 76					halt 
5af9			 
5af9			; handle the auto run of code from files in storage 
5af9			 
5af9			 
5af9			if STORAGE_SE 
5af9			 
5af9			sprompt3: db "Loading from start-up file?:",0 
5af9			sprompt4: db "(Y=Any key/N=No)",0 
5af9			 
5af9			 
5af9			forth_autoload: 
5af9			 
5af9				; load block 0 of store 1 
5af9				 
5af9				ld a, $fe      ; bit 0 clear 
5af9				ld (spi_device), a 
5af9			 
5af9				call storage_get_block_0 
5af9			 
5af9				ld a, (store_page+STORE_0_AUTOFILE) 
5af9			 
5af9				cp 0 
5af9				ret z     ; auto start not enabled 
5af9			 
5af9				call clear_display 
5af9			 
5af9				; set bank 
5af9			 
5af9					ld a, (store_page+STORE_0_BANKRUN) 
5af9					ld (spi_device), a 
5af9			 
5af9				; get file id to load from and get the file name to display 
5af9			 
5af9					ld a, (store_page+STORE_0_FILERUN) 
5af9			 
5af9					ld l, 0 
5af9					ld h, a 
5af9					ld de, store_page 
5af9			 
5af9					if DEBUG_FORTH_WORDS 
5af9						DMARK "ASp" 
5af9						CALLMONITOR 
5af9					endif 
5af9					call storage_read 
5af9			 
5af9					if DEBUG_FORTH_WORDS 
5af9						DMARK "ASr" 
5af9						CALLMONITOR 
5af9					endif 
5af9			 
5af9					call ishlzero 
5af9					ret z             ; file not found 
5af9			 
5af9					ld a, display_row_2 + 10 
5af9					ld de, store_page+3 
5af9					call str_at_display 
5af9				 
5af9			; 
5af9			 
5af9				ld a, display_row_1+5 
5af9				ld de, sprompt3 
5af9				call str_at_display 
5af9				ld a, display_row_3+15 
5af9				ld de, sprompt4 
5af9				call str_at_display 
5af9			 
5af9				call update_display 
5af9			 
5af9				call cin_wait 
5af9				cp 'n' 
5af9				ret z 
5af9				cp 'N' 
5af9				ret z 
5af9			 
5af9				call delay1s 
5af9			 
5af9				ld a, (store_page+2) 
5af9				ld (store_openmaxext), a    ; save count of ext 
5af9				ld a, 1  
5af9				ld (store_openext), a    ; save count of ext 
5af9			 
5af9			.autof:  
5af9				ld l , a 
5af9				 
5af9				ld a, (store_page) 
5af9				ld h, a	 
5af9				ld de, store_page 
5af9					if DEBUG_FORTH_WORDS 
5af9						DMARK "ASl" 
5af9						CALLMONITOR 
5af9					endif 
5af9					call storage_read 
5af9				call ishlzero 
5af9				ret z 
5af9			;	jr z, .autoend 
5af9			 
5af9					if DEBUG_FORTH_WORDS 
5af9						DMARK "ASc" 
5af9						CALLMONITOR 
5af9					endif 
5af9				ld de, store_page+2 
5af9				ld a, display_row_4 
5af9				call str_at_display 
5af9			 
5af9				call update_display 
5af9				call delay250ms 
5af9			 
5af9			 
5af9			 
5af9				ld hl, store_page+2 
5af9				call forthparse 
5af9				call forthexec 
5af9				call forthexec_cleanup 
5af9			 
5af9				 
5af9				ld a, (store_openext) 
5af9				inc a 
5af9				ld (store_openext), a    ; save count of ext 
5af9			 
5af9				jr .autof 
5af9			;.autofdone: 
5af9			; 
5af9			;		if DEBUG_FORTH_WORDS 
5af9			;			DMARK "ASx" 
5af9			;			CALLMONITOR 
5af9			;		endif 
5af9			;;	call clear_display 
5af9			;	ret 
5af9			 
5af9			 
5af9			 
5af9			endif 
5af9			 
5af9			 
5af9			; eof 
# End of file forth_kernel.asm
5af9			;include "nascombasic.asm" 
5af9			 
5af9			 
5af9			; find out where the code ends if loaded into RAM (for SC114) 
5af9			;endofcode:  
5af9			;	nop 
5af9			 
5af9			 
5af9			; eof 
5af9			 
# End of file main.asm
5af9			;include "firmware_lcd_4x40.asm" 
5af9			;;include "firmware_lcd_4x20.asm" 
5af9			include "firmware_cpm_display.asm" 
5af9			 
5af9			; Serial display interface for SC114 
5af9			 
5af9			 
5af9			display_row_1: equ 0 
5af9			display_row_2: equ display_row_1+display_cols 
5af9			display_row_3: equ display_row_2 + display_cols 
5af9			display_row_4: equ display_row_3 + display_cols 
5af9			 
5af9			kLCDWidth:  EQU display_cols             ;Width in characters 
5af9			kLCD_Line1: EQU 0x00  
5af9			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
5af9			; E1 
5af9			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
5af9			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
5af9			 
5af9			lcd_init: 
5af9				; no init as handled by the SCM bios 
5af9 c9				ret 
5afa			 
5afa			 
5afa			; low level functions for direct screen writes 
5afa			 
5afa			; output char at pos? 
5afa			fLCD_Str: 
5afa			        ;out (SC114_SIO_1_OUT),a 
5afa c5				push bc 
5afb d5				push de 
5afc 5f				ld e, a 
5afd			; TODO Replace with CP/M BIOS call 
5afd 0e 02			ld c, $02 
5aff cd 05 00			call 5 
5b02 d1				pop de 
5b03 c1				pop bc 
5b04 c9				ret 
5b05			 
5b05			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
5b05			fLCD_Pos: 
5b05				; use ASCII escape to position 
5b05			        ;out (SC114_SIO_1_OUT),a 
5b05 c5				push bc 
5b06 d5				push de 
5b07 5f				ld e, a 
5b08 0e 02			ld c, $02 
5b0a			; TODO Replace with CP/M BIOS call 
5b0a cd 05 00			call 5 
5b0d d1				pop de 
5b0e c1				pop bc 
5b0f			 
5b0f c9				ret 
5b10			 
5b10			; output char at pos 
5b10			fLCD_Data: 
5b10			      ;  out (SC114_SIO_1_OUT),a 
5b10 c5				push bc 
5b11 d5				push de 
5b12 0e 02			ld c, $02 
5b14 5f				ld e, a 
5b15			; TODO Replace with CP/M BIOS call 
5b15 cd 05 00			call 5 
5b18 d1				pop de 
5b19 c1				pop bc 
5b1a			 
5b1a c9				ret 
5b1b			 
5b1b			; ascii cls  
5b1b			 
5b1b 1b 5b 48 24	.cls:   db 27, '[', 'H', "$" 
5b1f			 
5b1f 0d 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a ..	.clscpm: db 13, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,10,10,10,10,10,"$" 
5b36			;.clscpm: db 3, $3c,"$" 
5b36			 
5b36			; write the frame buffer given in hl to hardware  
5b36			write_display: 
5b36			 
5b36			API: equ 0 
5b36			 
5b36			if API 
5b36				push bc 
5b36				ld b, 4 
5b36			 
5b36			        ld (display_write_tmp), hl 	  
5b36			 
5b36				; clear and home cursor 
5b36			 
5b36				ld c, 9 
5b36				ld de, .cls 
5b36			; TODO Replace with CP/M BIOS call 
5b36				call 5 
5b36			 
5b36			 
5b36			.writeln: 
5b36			 
5b36				ld de, (display_write_tmp) 
5b36				ld c, 6 
5b36			; TODO Replace with CP/M BIOS call 
5b36				rst $30 
5b36				ld c, 7 
5b36				rst $30 
5b36			 
5b36				ld hl, (display_write_tmp) 
5b36				ld de, display_cols 
5b36				add hl,de 
5b36				ld (display_write_tmp),hl 
5b36			 
5b36				djnz  .writeln 
5b36			 
5b36				pop bc 
5b36			 
5b36			 
5b36				ret 
5b36			endif 
5b36 e5				push hl 
5b37 c5				push bc 
5b38 d5				push de 
5b39			 
5b39			;	ld c, 2 
5b39			;	;ld de, .cls 
5b39			;	ld a, 27 
5b39			;	rst $30 
5b39			;	ld c, 2 
5b39			;	;ld de, .cls 
5b39			;	ld a, '[' 
5b39			;	rst $30 
5b39			; 
5b39			;	ld c, 2 
5b39			;	;ld de, .cls 
5b39			;	ld a, 'H' 
5b39			;	rst $30 
5b39			; 
5b39			 
5b39			 
5b39			; lots of CR/LF 
5b39			;	ld c, 9 
5b39			;	ld de, .clscpm 
5b39			;	call 5 
5b39			 
5b39			; xterm cls 
5b39 0e 02			ld c, 2 
5b3b 1e 1b			ld e, 27 
5b3d cd 05 00			call 5 
5b40			; cls causes too much flicker 
5b40			;	ld c, 2 
5b40			;	ld e, 'c' 
5b40			;	call 5 
5b40			 
5b40			; use xterm home instead 
5b40 0e 02			ld c, 2 
5b42 1e 5b			ld e, '[' 
5b44 cd 05 00			call 5 
5b47 0e 02			ld c, 2 
5b49 1e 48			ld e, 'H' 
5b4b cd 05 00			call 5 
5b4e			LLL: equ 0 
5b4e			 
5b4e			if LLL 
5b4e			 
5b4e				ld c, 2 
5b4e				;ld de, .cls 
5b4e				ld e, 27 
5b4e			; TODO Replace with CP/M BIOS call 
5b4e				call 5 
5b4e			 
5b4e			 
5b4e				ld c, 2 
5b4e				;ld de, .cls 
5b4e				ld e, '[' 
5b4e			; TODO Replace with CP/M BIOS call 
5b4e				call 5 
5b4e				ld c, 2 
5b4e				;ld de, .cls 
5b4e				ld e, '2' 
5b4e			; TODO Replace with CP/M BIOS call 
5b4e				call 5 
5b4e				ld c, 2 
5b4e				;ld de, .cls 
5b4e				ld e, 'J' 
5b4e			; TODO Replace with CP/M BIOS call 
5b4e				call 5 
5b4e			 
5b4e			endif 
5b4e			 
5b4e d1				pop de 
5b4f c1				pop bc 
5b50 e1				pop hl 
5b51			 
5b51			 
5b51 22 cf eb		        ld (display_write_tmp), hl 	  
5b54 3e 00			ld a, kLCD_Line1 
5b56			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
5b56 06 28			ld b, display_cols 
5b58 ed 5b cf eb		ld de, (display_write_tmp) 
5b5c cd df 5b			call write_len_string 
5b5f				 
5b5f			 
5b5f e5			push hl 
5b60 d5			push de 
5b61 c5			push bc 
5b62 0e 02			ld c, 2 
5b64 1e 0a			ld e, 10 
5b66 cd 05 00			call 5 
5b69 0e 02			ld c, 2 
5b6b 1e 0d			ld e, 13 
5b6d cd 05 00			call 5 
5b70			; TODO Replace with CP/M BIOS call 
5b70				;rst $30 
5b70 c1			pop bc 
5b71 d1			pop de 
5b72 e1			pop hl 
5b73			 
5b73				 
5b73 2a cf eb			ld hl, (display_write_tmp) 
5b76 11 28 00			ld de, display_cols 
5b79 19				add hl,de 
5b7a 22 cf eb			ld (display_write_tmp),hl 
5b7d			 
5b7d				 
5b7d 3e 28			ld a, kLCD_Line2 
5b7f			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
5b7f 06 28			ld b, display_cols 
5b81 ed 5b cf eb		ld de, (display_write_tmp) 
5b85 cd df 5b			call write_len_string 
5b88				 
5b88 2a cf eb			ld hl, (display_write_tmp) 
5b8b 11 28 00			ld de, display_cols 
5b8e 19				add hl,de 
5b8f 22 cf eb			ld (display_write_tmp),hl 
5b92			 
5b92 e5			push hl 
5b93 d5			push de 
5b94 c5			push bc 
5b95 0e 07			ld c, 7 
5b97			; TODO Replace with CP/M BIOS call 
5b97				;rst $30 
5b97 0e 02			ld c, 2 
5b99 1e 0a			ld e, 10 
5b9b cd 05 00			call 5 
5b9e 0e 02			ld c, 2 
5ba0 1e 0d			ld e, 13 
5ba2 cd 05 00			call 5 
5ba5 c1			pop bc 
5ba6 d1			pop de 
5ba7 e1			pop hl 
5ba8			 
5ba8				 
5ba8 3e 50			ld a, kLCD_Line3 
5baa			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
5baa 06 28			ld b, display_cols 
5bac ed 5b cf eb		ld de, (display_write_tmp) 
5bb0 cd df 5b			call write_len_string 
5bb3				 
5bb3 2a cf eb			ld hl, (display_write_tmp) 
5bb6 11 28 00			ld de, display_cols 
5bb9 19				add hl,de 
5bba 22 cf eb			ld (display_write_tmp),hl 
5bbd			 
5bbd e5			push hl 
5bbe d5			push de 
5bbf c5			push bc 
5bc0 0e 07			ld c, 7 
5bc2			; TODO Replace with CP/M BIOS call 
5bc2				;rst $30 
5bc2 0e 02			ld c, 2 
5bc4 1e 0a			ld e, 10 
5bc6 cd 05 00			call 5 
5bc9 0e 02			ld c, 2 
5bcb 1e 0d			ld e, 13 
5bcd cd 05 00			call 5 
5bd0 c1			pop bc 
5bd1 d1			pop de 
5bd2 e1			pop hl 
5bd3			 
5bd3				 
5bd3 3e 78			ld a, kLCD_Line4 
5bd5			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
5bd5 06 28			ld b, display_cols 
5bd7 ed 5b cf eb		ld de, (display_write_tmp) 
5bdb cd df 5b			call write_len_string 
5bde c9					ret 
5bdf			 
5bdf			 
5bdf				; write out a fixed length string given in b from de 
5bdf			 
5bdf 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
5be0 cd 10 5b		            CALL fLCD_Data      ;Write character to display 
5be3 13				inc de 
5be4 10 f9			djnz write_len_string 
5be6 c9				ret 
5be7			 
5be7			 
5be7			; eof 
# End of file firmware_cpm_display.asm
5be7			;include "firmware_key_5x10.asm" 
5be7			;;include "firmware_key_4x10.asm" 
5be7			include "firmware_key_cpm.asm" 
5be7			; Serial keyboard interface for SC114 
5be7			 
5be7			 
5be7			key_init: 
5be7				; no init as handled by the SCM bios 
5be7 c9				ret 
5be8			 
5be8			 
5be8			cin_wait: 
5be8			;	ld a, 0 
5be8			;	ret 
5be8			 
5be8				;in a,(SC114_SIO_1_IN) 
5be8			        ; Use SCM API to get from whatever console device we are using 
5be8			 
5be8			; TODO Replace with CP/M BIOS call 
5be8 c5				push bc 
5be9 0e 01			ld c, $01 
5beb cd 05 00			call 5 
5bee c1				pop bc 
5bef c9				ret 
5bf0			 
5bf0			cin: 
5bf0			 
5bf0			 
5bf0 c5				push bc 
5bf1			 
5bf1				; any key waiting to process? 
5bf1			; TODO Replace with CP/M BIOS call 
5bf1 0e 06			ld c, $06 
5bf3 cd 05 00			call 5 
5bf6 28 0d			jr z, .cin_skip 
5bf8			 
5bf8				; yep, get it 
5bf8			 
5bf8 0e 01			ld c, $01 
5bfa			; TODO Replace with CP/M BIOS call 
5bfa cd 05 00			call 5 
5bfd			 
5bfd fe 7f			cp $7f     ; back space 
5bff 20 02			jr nz, .skipbs 
5c01 3e 08			ld a, KEY_BS 
5c03			.skipbs: 
5c03			 
5c03 c1				pop bc 
5c04 c9				ret 
5c05			.cin_skip: 
5c05 3e 00			ld a, 0 
5c07 c1				pop bc 
5c08 c9				ret 
5c09			 
5c09			 
5c09			 
5c09			 
# End of file firmware_key_cpm.asm
5c09			endofcode:  
5c09			baseram:  
5c09 00				nop 
5c0a			 
5c0a			heap_start: equ baseram+15  ; Starting address of heap 
5c0a			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
5c0a			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
5c0a			;VDU:  EQU     endofcode           ; BASIC Work space 
5c0a			; eof 
5c0a			 
# End of file os_mega_cpm.asm
5c0a
