# File os_mega.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			tos:	equ 0fffdh 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			SOUND_ENABLE: equ 1 
0000			 
0000			; Number of bytes available in heap   TODO make all of user ram 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 30 19			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			;        nop  
0003			;        nop 
0003			;;	org 05h		; null out bdos call 
0003			; 
0003			;        nop  
0003			;        nop  
0003			;        nop 
0003			;;	org 08h 
0003			;;; 
0003			;;	jp cin		; rst 8 - char in 
0003			;;; 
0003			; 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;	org 010h 
0003			;; 
0003			;	jp cout		; rest 010h  - char out 
0003			;; 
0003			;	org 01bh   
0003			; 
0003			;	;jp  		; rst 01bh   - write string to display 
0003			;	jp str_at_display 
0003			; 
0003			; 
0003			;	org 020h 
0003			; 
0003			;	; jp		 ; rst 020h - read char at screen location 
0003			; 
0003			;	org 028h 
0003			 
0003				; jp		 ; rst 028h  - storage i/o 
0003			 
0003			; 	org 030h 
0003			;	jp break_point_state 
0003			  
0003			; $30  
0003			; org 038h 
0003			; $38 
0003			 
0003			; TODO any more important entry points to add to jump table for easier coding use? 
0003			 
0003			 
0003			include "firmware.asm" 
0003			  
0003			; main constants (used here and in firmware)  
0003			  
0003			; TODO have page 0 of storage as bios  
0003			  
0003			Device_A: equ 0h  
0003			Device_B: equ 040h          ; Sound  
0003			  
0003			if BASE_KEV  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_SC114  
0003			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			; TODO fixup for CPM  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			Device_D: equ 0c0h             ; Keyboard and LCD  
0003			  
0003			; Odd specific debug points for testing hardware dev  
0003			  
0003			DEBUG_SOUND: equ 1  
0003			DEBUG_STK_FAULT: equ 0  
0003			DEBUG_INPUT: equ 0     ; Debug input entry code  
0003			DEBUG_KEYCINWAIT: equ 0  
0003			DEBUG_KEYCIN: equ 0  
0003			DEBUG_KEY: equ 0  
0003			DEBUG_KEY_MATRIX: equ 0  
0003			DEBUG_STORECF: equ 0  
0003			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
0003			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
0003			DEBUG_SPI: equ 0    ; low level spi tests  
0003			  
0003			; Enable many break points  
0003			  
0003			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
0003			DEBUG_FORTH_JP: equ 0    ; 4  
0003			DEBUG_FORTH_MALLOC: equ 0  
0003			DEBUG_FORTH_MALLOC_INT: equ 0  
0003			DEBUG_FORTH_DOT: equ 0  
0003			DEBUG_FORTH_DOT_WAIT: equ 0  
0003			DEBUG_FORTH_MATHS: equ 0  
0003			DEBUG_FORTH_TOK: equ 0    ; 4  
0003			DEBUG_FORTH_PARSE: equ 0    ; 3  
0003			DEBUG_FORTH: equ 0  ;2  
0003			DEBUG_FORTH_WORDS: equ 1   ; 1  
0003			DEBUG_FORTH_PUSH: equ 1   ; 1  
0003			DEBUG_FORTH_UWORD: equ 1   ; 1  
0003			  
0003			; Enable key point breakpoints  
0003			  
0003			DEBUG_FORTH_DOT_KEY: equ 0  
0003			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
0003			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
0003			  
0003			; Debug stack imbalances  
0003			  
0003			ON: equ 1  
0003			OFF: equ 0  
0003			  
0003			DEBUG_STACK_IMB: equ 0  
0003			STACK_IMB_STORE: equ 20  
0003			  
0003			; House keeping and protections  
0003			  
0003			DEBUG_FORTH_STACK_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
0003			FORTH_ENABLE_FREE: equ 0  
0003			FORTH_ENABLE_MALLOCFREE: equ 1  
0003			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
0003			FORTH_ENABLE_FLOATMATH: equ 0  
0003			  
0003			  
0003			CALLMONITOR: macro  
0003				call break_point_state  
0003				endm  
0003			  
0003			MALLOC_1: equ 1        ; from dk88   
0003			MALLOC_2: equ 0           ; broke  
0003			MALLOC_3: equ 0           ; really broke  
0003			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
0003			  
0003			if BASE_KEV   
0003			stacksize: equ 512*2  
0003			  
0003			STACK_RET_SIZE: equ 128  
0003			STACK_LOOP_SIZE: equ 512  
0003			STACK_DATA_SIZE: equ 512  
0003			endif  
0003			if BASE_SC114  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			;if STORAGE_SE == 0  
0003			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
0003			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
0003			;endif  
0003			  
0003			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
0003			  
0003			STORE_0_AUTOFILE: equ $21  
0003			STORE_0_BANKRUN: equ $23  
0003			STORE_0_FILERUN: equ $24  
0003			  
0003			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
0003			  
0003			STORE_0_AUTORUN: equ $20  
0003			  
0003			; Blocks where directory table is held  
0003			  
0003			; Reducing the number of entries increases the max file size  
0003			  
0003			;STORE_DIR_START: equ 1  
0003			;STORE_DIR_END: equ 33  
0003			  
0003			; Blocks from where file data is stored  
0003			  
0003			;STORE_DATA_START: equ STORE_DIR_END + 1  
0003			  
0003			; Block indicators (<32 are data files)  
0003			  
0003			;STORE_BLOCK_CFG: equ $8f       ; config block  
0003			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
0003			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
0003			;STORE_BLOCK_FREE: equ $85       ; data block free  
0003			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
0003			  
0003			  
0003			  
0003			; Directory entry flags  
0003			  
0003			;STORE_DIR_FREE: equ 0  
0003			;STORE_DIR_FILE:  equ 1  
0003			  
0003			; Structure offsets to directory entries  
0003			;STORE_DE_FLAG: equ 0  
0003			;STORE_DE_MAXEXT: equ 1  
0003			;STORE_DE_FILENAME: equ 2  
0003			  
0003			; Structure offsets to block 0  
0003			  
0003			;STORE_BK0_ISFOR: equ 1  
0003			;STORE_BK0_LABEL: equ 3  
0003			  
0003			; memory allocation   
0003			  
0003			chk_stund: equ tos+2           ; underflow check word  
0003			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
0003			  
0003			; keyscan table needs rows x cols buffer  
0003			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
0003			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
0003			  
0003			keyscan_table_row1: equ chk_stovr -key_cols-1  
0003			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
0003			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
0003			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
0003			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
0003			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
0003			keyscan_scancol: equ keyscan_table-key_cols  
0003			;keyscan_table_len: equ key_rows*key_cols  
0003			;keybufptr: equ keyscan_table - 2  
0003			;keysymbol: equ keybufptr - 1  
0003			key_held: equ keyscan_scancol-1	; currently held  
0003			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
0003			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
0003			key_fa: equ key_repeat_ct -1 ;  
0003			key_fb: equ key_fa -1 ;  
0003			key_fc: equ key_fb -1 ;  
0003			key_fd: equ key_fc -1 ;  
0003			key_face_held: equ key_fd - 1   
0003			  
0003			; flag for enabling/disabling various hardware diags   
0003			  
0003			hardware_diag: equ key_face_held - 1  
0003			  
0003			; hardware config switches  
0003			; TODO add bitmasks on includes for hardware  
0003			; high byte for expansion ids  
0003			;     0000 0000  no card inserted  
0003			;     0000 0001  storage card inserted  
0003			;     0000 0010  spi sd card active  
0003			  
0003			;       
0003			; low byte:  
0003			;     0000 0001   4x4 keypad  
0003			;     0000 0010   full keyboard  
0003			;     0000 0011   spi/ext keyboard  
0003			;     0000 0100   20x4 lcd  
0003			;     0000 1000   40x4 lcd  
0003			;     0000 1100   spi/ext display  
0003			;     0001 0000   ide interface available  
0003			  
0003			hardware_word: equ hardware_diag - 2  
0003			  
0003			; debug marker - optional display of debug point on the debug screens  
0003			  
0003			debug_mark: equ hardware_word - 4  
0003			  
0003			; input_str vars  
0003			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
0003			input_start:  equ input_ptr - 2    ; ptr to the start of string   
0003			input_size: equ input_start -1  ; number of chars  
0003			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
0003			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
0003			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
0003			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
0003			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
0003			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
0003			input_len: equ input_cur_onoff - 5 ; length of current input  
0003			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
0003			  
0003			CUR_BLINK_RATE: equ 15  
0003			  
0003			key_actual_pressed: equ input_cursor - 1   
0003			key_symbol: equ key_actual_pressed - 1   
0003			key_shift: equ key_symbol - 1   
0003			  
0003			; Display allocation  
0003			  
0003			;display_rows: equ 4     ; move out to mini and mega files  
0003			;display_cols: equ 20  
0003			  
0003			display_fb_len: equ display_rows*display_cols  
0003			  
0003			; primary frame buffer     
0003			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
0003			; working frame buffers  
0003			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
0003			display_fb3: equ  display_fb1-display_fb_len - 1  
0003			display_fb2: equ  display_fb3-display_fb_len - 1  
0003			;  
0003			; pointer to active frame buffer  
0003			display_fb_active: equ display_fb2 - 2  
0003			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
0003			display_write_tmp: equ display_lcde1e2 - 2  
0003			  
0003			  
0003			;  
0003			  
0003			;; can load into de directory  
0003			cursor_col: equ display_write_tmp-1  
0003			cursor_row: equ cursor_col-1  
0003			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
0003			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
0003			  
0003			; maths vars  
0003			  
0003			LFSRSeed: equ cursor_shape -20   
0003			randData: equ LFSRSeed - 2  
0003			xrandc: equ randData - 2  
0003			stackstore: equ xrandc - 2  
0003			seed1: equ  stackstore -2   
0003			seed2: equ seed1 - 2  
0003			  
0003			; cf storage vars  
0003			  
0003			iErrorNum:  equ seed2-1         ;Error number  
0003			iErrorReg:  equ iErrorNum -1              ;Error register  
0003			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
0003			  
0003			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
0003			  
0003			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
0003			  
0003			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
0003			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
0003			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
0003			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
0003			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
0003			store_tmpid: equ store_tmp3 - 1		; page temp id  
0003			store_tmpext: equ store_tmpid - 1		; file extent temp  
0003			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
0003			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
0003			store_filecache: equ store_openmaxext-(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
0003			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
0003			;  
0003			; spi vars  
0003			  
0003			  
0003			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
0003			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
0003			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
0003			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
0003			spi_device_id: equ spi_device - 1    ; human readable bank number  
0003			  
0003			;;;;; forth cli params  
0003			  
0003			; TODO use a different frame buffer for forth???  
0003			  
0003			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
0003			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
0003			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
0003			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
0003			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
0003			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
0003			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
0003			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
0003			  
0003			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
0003			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
0003			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
0003			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
0003			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
0003			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
0003			  
0003			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
0003			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
0003			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
0003			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
0003			chk_data_ovr: equ cli_data_stack -2; overflow check word  
0003			  
0003			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
0003			  
0003			; os/forth token vars  
0003			  
0003			os_last_cmd: equ os_var_array-255  
0003			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
0003			os_current_i: equ os_cli_cmd-2  
0003			os_cur_ptr: equ os_current_i-2  
0003			os_word_scratch: equ os_cur_ptr-30  
0003			os_tok_len: equ os_word_scratch - 2  
0003			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
0003			os_tok_malloc: equ os_tok_ptr - 2  
0003			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
0003			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
0003			execscratch: equ os_input-255        ; exec cmd eval buffer  
0003			scratch: equ execscratch-255  
0003			  
0003			  
0003			; temp locations for new word processing to save on adding more   
0003			  
0003			os_new_malloc: equ scratch-2  
0003			os_new_parse_len: equ os_new_malloc - 2  
0003			os_new_word_len: equ os_new_parse_len - 2  
0003			os_new_work_ptr: equ os_new_word_len - 2  
0003			os_new_src_ptr: equ os_new_work_ptr - 2  
0003			os_new_exec: equ os_new_src_ptr - 2  
0003			os_new_exec_ptr: equ os_new_exec - 2  
0003			  
0003			; resume memory alloocations....  
0003			  
0003			os_view_disable: equ os_new_exec_ptr - 1  
0003			os_view_af: equ os_view_disable - 2  
0003			os_view_hl: equ os_view_af -2  
0003			os_view_de: equ os_view_hl - 2  
0003			os_view_bc: equ os_view_de - 2  
0003			  
0003			; stack checksum word  
0003			if DEBUG_STACK_IMB  
0003				curframe: equ  os_view_de - 5  
0003				store_sp: equ curframe - (STACK_IMB_STORE*4)  
0003				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			else  
0003				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			endif  
0003			  
0003			; with data stack could see memory filled with junk. need some memory management   
0003			; malloc and free entry points added  
0003			  
0003			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
0003			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			;heap_end: equ free_list-1  ; Starting address of heap  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			heap_end: equ chk_word-1  ; Starting address of heap  
0003			  
0003			  
0003			;if BASE_KEV   
0003			;heap_start: equ 0800eh  ; Starting address of heap  
0003			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;heap_start: equ baseram+15  ; Starting address of heap  
0003			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;endif  
0003			  
0003			  
0003			;;;;  
0003			  
0003			  
0003			; change below to point to last memory alloc above  
0003			topusermem:  equ   heap_start  
0003			  
0003			;if BASE_KEV   
0003			;baseusermem: equ 08000h  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;;aseusermem:     equ    12  
0003			;baseusermem:     equ    prompt  
0003			;;baseusermem:     equ    endofcode  
0003			;endif  
0003			  
0003			  
0003			; **********************************************************************  
0003			; **  Constants  
0003			; **********************************************************************  
0003			  
0003			; Constants used by this code module  
0003			kDataReg:   EQU Device_D           ;PIO port A data register  
0003			kContReg:   EQU Device_D+2           ;PIO port A control register  
0003			  
0003			  
0003			portbdata:  equ Device_D+1    ; port b data  
0003			portbctl:   equ Device_D+3    ; port b control  
0003			  
0003			  
0003			;KEY_SHIFT:   equ 5  
0003			;KEY_SYMBOLSHIFT:  equ 6  
0003			  
0003			KEY_SHIFTLOCK: equ 4  
0003			  
0003			  
0003			KEY_UP: equ 5  
0003			KEY_NEXTWORD: equ 6  
0003			KEY_PREVWORD: equ 7  
0003			KEY_BS: equ 8  
0003			KEY_TAB:  equ 9  
0003			KEY_DOWN: equ 10  
0003			KEY_LEFT: equ 11  
0003			KEY_RIGHT: equ 12  
0003			KEY_CR:   equ 13  
0003			KEY_HOME: equ 14  
0003			KEY_END: equ 15  
0003			  
0003			KEY_F1: equ 16  
0003			KEY_F2: equ 17  
0003			KEY_F3: equ 18  
0003			KEY_F4: equ 19  
0003			  
0003			KEY_F5: equ 20  
0003			KEY_F6: equ 21  
0003			KEY_F7: equ 22  
0003			KEY_F8: equ 23  
0003			  
0003			KEY_F9: equ 24  
0003			KEY_F10: equ 25  
0003			KEY_F11: equ 26  
0003			KEY_F12: equ 27  
0003			  
0003			;if DEBUG_KEY  
0003			;	KEY_MATRIX_NO_PRESS: equ '.'  
0003			;	KEY_SHIFT:   equ '.'  
0003			;	KEY_SYMBOLSHIFT:  equ '.'  
0003			;else  
0003				KEY_SHIFT:   equ '~'  
0003				KEY_SYMBOLSHIFT:  equ '~'  
0003				KEY_MATRIX_NO_PRESS: equ '~'  
0003			;endi  
0003			  
0003			  
0003			  
0003			  
0003			; Macro to make adding debug marks easier  
0003			  
0003			DMARK: macro str  
0003				push af  
0003				ld a, (.dmark)  
0003				ld (debug_mark),a  
0003				ld a, (.dmark+1)  
0003				ld (debug_mark+1),a  
0003				ld a, (.dmark+2)  
0003				ld (debug_mark+2),a  
0003				jr .pastdmark  
0003			.dmark: db str  
0003			.pastdmark: pop af  
0003			  
0003			endm  
0003			  
0003			  
0003			; macro to detect for stack imbalances  
0003			  
0003			include "stackimbal.asm"  
0003			; Macro and code to detect stock imbalances 
0003			 
0003			SPPUSH: equ 0 
0003			 
0003			; Add a stack frame which can be checked before return 
0003			 
0003			STACKFRAME: macro onoff frame1 frame2 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003						exx 
0003			 
0003						ld de, frame1 
0003						ld a, d 
0003						ld hl, curframe 
0003						call hexout 
0003						ld a, e 
0003						ld hl, curframe+2 
0003						call hexout 
0003			  
0003						ld hl, frame1 
0003						push hl 
0003						ld hl, frame2 
0003						push hl 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			endm 
0003			 
0003			STACKFRAMECHK: macro onoff frame1 frame2 
0003			 
0003					 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						exx 
0003						; check stack frame SP 
0003			 
0003						ld hl, frame2 
0003						pop de   ; frame2 
0003			 
0003						call cmp16 
0003						jr nz, .spnosame 
0003						 
0003			 
0003						ld hl, frame1 
0003						pop de   ; frame1 
0003			 
0003						call cmp16 
0003						jr z, .spfrsame 
0003			 
0003						.spnosame: call showsperror 
0003			 
0003						.spfrsame: nop 
0003			 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			 
0003			 
0003			endm 
0003			 
0003			 
0003			; for a sub routine, wrap SP collection and comparisons 
0003			 
0003			; Usage: 
0003			; 
0003			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
0003			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
0003			 
0003			SAVESP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003			 
0003						ld (store_sp+(storeword*4)), sp 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			CHECKSP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003			 
0003						; save SP after last save 
0003				 
0003						ld (store_sp+(storeword*4)+2), sp 
0003			 
0003						push hl 
0003						ld hl, store_sp+(storeword*4) 
0003						call check_stack_sp  
0003						pop hl 
0003			 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			if DEBUG_STACK_IMB 
0003			 
0003			check_stack_sp: 
0003					push de 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					push de 
0003			 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					pop hl 
0003			 
0003			 
0003					; check to see if the same 
0003			 
0003					call cmp16 
0003					jr z, .spsame 
0003			 
0003					; not same 
0003			 
0003					call showsperror 
0003			.spsame: 
0003			 
0003					pop de 
0003			 
0003					ret 
0003			 
0003			.sperr:  db "Stack imbalance",0 
0003			 
0003			 
0003			showsperror: 
0003			 
0003			 
0003				push hl 
0003				push af 
0003				push de 
0003				call clear_display 
0003				ld de, .sperr 
0003				ld a,0 
0003			;	ld de,os_word_scratch 
0003				call str_at_display 
0003				ld a, display_row_1+17 
0003				ld de, debug_mark 
0003				call str_at_display 
0003				ld a, 0 
0003				ld (curframe+4),a 
0003				ld hl, curframe 
0003				ld de, os_word_scratch 
0003				ld a, display_row_4 
0003				call str_at_display 
0003				call update_display 
0003				;call break_point_state 
0003				call cin_wait 
0003			 
0003				ld a, ' ' 
0003				ld (os_view_disable), a 
0003				pop de	 
0003				pop af 
0003				pop hl 
0003				CALLMONITOR 
0003				ret 
0003			 
0003			endif 
0003			 
0003			 
0003			 
0003			; eof 
# End of file stackimbal.asm
0003			  
0003			;TODO macro to calc col and row offset into screen  
0003			  
0003			  
0003			  
0003			hardware_init:  
0003			  
0003 3e 00				ld a, 0  
0005 32 7d fb				ld (hardware_diag), a  
0008			  
0008					; clear all the buffers  
0008			  
0008 21 1c fa				ld hl, display_fb1  
000b 22 d8 f8				ld (display_fb_active), hl  
000e			  
000e cd e9 0a				call clear_display  
0011			  
0011 21 da f8				ld hl, display_fb2  
0014 22 d8 f8				ld (display_fb_active), hl  
0017			  
0017 cd e9 0a				call clear_display  
001a			  
001a					; init primary frame buffer area  
001a 21 bd fa				ld hl, display_fb0  
001d 22 d8 f8				ld (display_fb_active), hl  
0020			  
0020 cd e9 0a				call clear_display  
0023			  
0023			  
0023 cd b3 65				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0026			  
0026 cd 4a 68			call key_init  
0029 cd cc 01			call storage_init  
002c			  
002c				; setup malloc functions  
002c			  
002c				if MALLOC_1  
002c cd c0 11				call  heap_init  
002f				endif  
002f				if MALLOC_4  
002f					call  heap_init  
002f				endif  
002f			  
002f				; init sound hardware if present  
002f			  
002f				if SOUND_ENABLE  
002f cd 7d 13				call sound_init  
0032				endif  
0032			  
0032				; lcd test sequence  
0032					  
0032 cd 0c 0b			call update_display  
0035 cd 69 0a			call delay1s  
0038 3e 2b			ld a,'+'  
003a cd ee 0a			call fill_display  
003d cd 0c 0b			call update_display  
0040 cd 69 0a			call delay1s  
0043 3e 2a			ld a,'*'  
0045 cd ee 0a			call fill_display  
0048 cd 0c 0b			call update_display  
004b cd 69 0a			call delay1s  
004e 3e 2d			ld a,'-'  
0050 cd ee 0a			call fill_display  
0053 cd 0c 0b			call update_display  
0056 cd 69 0a			call delay1s  
0059			  
0059			; boot splash screen  
0059			if display_cols == 20	  
0059			        ld a, display_row_1    
0059			else  
0059 3e 0a		        ld a, display_row_1 +10   
005b			endif  
005b 11 8c 00			ld de, bootmsg  
005e cd fc 0a			call str_at_display  
0061 cd 0c 0b			call update_display  
0064			  
0064			  
0064 cd 69 0a			call delay1s  
0067 cd 69 0a			call delay1s  
006a			if display_cols == 20	  
006a			            LD   A, display_row_3+2  
006a			else  
006a 3e 5c		            LD   A, display_row_3+12  
006c			endif  
006c 11 a1 00			ld de, bootmsg1  
006f cd fc 0a			call str_at_display  
0072 cd 0c 0b			call update_display  
0075 cd 69 0a			call delay1s  
0078 cd 69 0a			call delay1s  
007b			  
007b			;	ld a, display_row_4+3  
007b			;	ld de, bootmsg2  
007b			;	call str_at_display  
007b			;	call update_display  
007b			;	call delay1s  
007b			;	call delay1s  
007b			  
007b			; debug mark setup  
007b			  
007b 3e 5f		ld a, '_'  
007d 32 77 fb		ld (debug_mark),a  
0080 32 78 fb		ld (debug_mark+1),a  
0083 32 79 fb		ld (debug_mark+2),a  
0086 3e 00		ld a,0  
0088 32 7a fb		ld (debug_mark+3),a  
008b			  
008b c9					ret  
008c			  
008c			  
008c .. 00		bootmsg:	db "z80-homebrew OS v1.5",0  
00a1 .. 00		bootmsg1:	db "by Kevin Groves",0  
00b1			;bootmsg2:	db "Firmware v0.1",0  
00b1			  
00b1			; a 4x20 lcd  
00b1			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00b1			  
00b1			;if display_cols == 20  
00b1			;	include "firmware_lcd_4x20.asm"  
00b1			;endif  
00b1			  
00b1			;if display_cols == 40  
00b1			;	include "firmware_lcd_4x40.asm"  
00b1			;endif  
00b1			  
00b1			;  
00b1			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00b1			; TODO abstract the bit bang video out interface for dual display  
00b1			; TODO wire video out to tx pin on rc2014 bus  
00b1			  
00b1			; must supply cin, and cin_wait for low level hardware abstraction   
00b1			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00b1			; test scancode  
00b1			  
00b1			;;;;;  
00b1			;;;  
00b1			; Moved out to mini and maxi versions  
00b1			;  
00b1			; include "firmware_key_4x4.asm"  
00b1			; using existing 4 wire x 4 resistor array for input  
00b1			;include "firmware_key_4x10.asm"  
00b1			; need to mod the board for 5 rows due to resistor array  
00b1			;include "firmware_key_5x10.asm"  
00b1			  
00b1			; storage hardware interface  
00b1			  
00b1			; use microchip serial eeprom for storage  
00b1			  
00b1			  
00b1			if STORAGE_SE  
00b1				include "firmware_spi.asm"  
00b1			; my spi protocol (used by storage) 
00b1			 
00b1			; SPI pins 
00b1			 
00b1			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00b1			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00b1			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00b1			 
00b1			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00b1			; chip pin 4 gnd 
00b1			 
00b1			 
00b1			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00b1			SPI_CE1: equ 1      ;    port a1 pin 14  
00b1			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00b1			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00b1			SPI_CE4: equ 4      ; port a4     pin 10 
00b1			 
00b1			; active low AND masks 
00b1			 
00b1			;SPI_CE0_MASK: equ    255-1 
00b1			;SPI_CE1_MASK: equ   255-2 
00b1			;SPI_CE2_MASK: equ   255-4 
00b1			;SPI_CE3_MASK: equ   255-8 
00b1			;SPI_CE4_MASK: equ   255-16 
00b1			SPI_CE_HIGH:  equ 255 
00b1			 
00b1			 
00b1			 
00b1			 
00b1			; TODO store port id for spi device ie dev c 
00b1			; TODO store pin for SO 
00b1			; TODO store pin for SI 
00b1			; TODO store pin for SCLK 
00b1			 
00b1			; 
00b1			 
00b1			; ensure that spi bus is in a stable state with default pins  
00b1			 
00b1			se_stable_spi:   
00b1			 
00b1				 ; set DI high, CE high , SCLK low 
00b1				;ld a, SPI_DI | SPI_CE0 
00b1 3e 07			ld a, SPI_DI  
00b3 cd 87 01			call spi_ce_high 
00b6 d3 80			 out (storage_adata),a 
00b8 32 49 f8			ld (spi_portbyte),a 
00bb			 
00bb				if DEBUG_SPI 
00bb					push hl 
00bb					ld l, a 
00bb					DMARK "SPI" 
00bb					CALLMONITOR 
00bb					pop hl 
00bb				endif 
00bb c9				ret 
00bc			 
00bc			; byte to send in a 
00bc			 
00bc			spi_send_byte: 
00bc				; save byte to send for bit mask shift out 
00bc 4f			        ld c,a 
00bd 3a 49 f8			ld a,(spi_portbyte) 
00c0				  
00c0				; clock out	each bit of the byte msb first 
00c0			 
00c0 06 08			ld b, 8 
00c2			.ssb1: 
00c2				; clear so bit  
00c2 cb bf			res SPI_DI, a 
00c4 cb 11			rl c 
00c6				; if bit 7 is set then carry is set 
00c6 30 02			jr nc, .ssb2 
00c8 cb ff			set SPI_DI,a 
00ca			.ssb2:  ; output bit to ensure it is stable 
00ca d3 80			out (storage_adata),a 
00cc 00				nop 
00cd				; clock bit high 
00cd cb ef			set SPI_SCLK,a 
00cf d3 80			out (storage_adata),a 
00d1 00				nop 
00d2				; then low 
00d2 cb af			res SPI_SCLK,a 
00d4 d3 80			out (storage_adata),a 
00d6 00				nop 
00d7 10 e9			djnz .ssb1 
00d9			 
00d9 32 49 f8			ld (spi_portbyte),a 
00dc c9				ret 
00dd			 
00dd			; TODO low level get byte into A on spi 
00dd			 
00dd			spi_read_byte:  
00dd			 
00dd				; save byte to send for bit mask shift out 
00dd 0e 00		    ld c,0 
00df 3a 49 f8			ld a,(spi_portbyte) 
00e2				  
00e2				; clock out	each bit of the byte msb first 
00e2			 
00e2			 
00e2				; clock bit high 
00e2 cb ef			set SPI_SCLK,a 
00e4 d3 80			out (storage_adata),a 
00e6 00				nop 
00e7			 
00e7			    ; read DO  
00e7			 
00e7 cb f9		    set 7,c 
00e9 db 80			in a,(storage_adata) 
00eb cb 77		    bit SPI_DO,a 
00ed 20 02		    jr nz, .b7 
00ef cb b9		    res 7,c 
00f1			.b7: 
00f1				; then low 
00f1 cb af			res SPI_SCLK,a 
00f3 d3 80			out (storage_adata),a 
00f5 00				nop 
00f6			     
00f6			 
00f6				; clock bit high 
00f6 cb ef			set SPI_SCLK,a 
00f8 d3 80			out (storage_adata),a 
00fa 00				nop 
00fb			 
00fb			    ; read DO  
00fb			 
00fb cb f1		    set 6,c 
00fd db 80			in a,(storage_adata) 
00ff cb 77		    bit SPI_DO,a 
0101 20 02		    jr nz, .b6 
0103 cb b1		    res 6,c 
0105			.b6: 
0105				; then low 
0105 cb af			res SPI_SCLK,a 
0107 d3 80			out (storage_adata),a 
0109 00				nop 
010a			 
010a				; clock bit high 
010a cb ef			set SPI_SCLK,a 
010c d3 80			out (storage_adata),a 
010e 00				nop 
010f			 
010f			 
010f			    ; read DO  
010f			 
010f cb e9		    set 5,c 
0111 db 80			in a,(storage_adata) 
0113 cb 77		    bit SPI_DO,a 
0115 20 02		    jr nz, .b5 
0117 cb a9		    res 5,c 
0119			.b5: 
0119				; then low 
0119 cb af			res SPI_SCLK,a 
011b d3 80			out (storage_adata),a 
011d 00				nop 
011e				; clock bit high 
011e cb ef			set SPI_SCLK,a 
0120 d3 80			out (storage_adata),a 
0122 00				nop 
0123			 
0123			    ; read DO  
0123			 
0123 cb e1		    set 4,c 
0125 db 80			in a,(storage_adata) 
0127 cb 77		    bit SPI_DO,a 
0129 20 02		    jr nz, .b4 
012b cb a1		    res 4,c 
012d			.b4: 
012d				; then low 
012d cb af			res SPI_SCLK,a 
012f d3 80			out (storage_adata),a 
0131 00				nop 
0132				; clock bit high 
0132 cb ef			set SPI_SCLK,a 
0134 d3 80			out (storage_adata),a 
0136 00				nop 
0137			 
0137			    ; read DO  
0137			 
0137 cb d9		    set 3,c 
0139 db 80			in a,(storage_adata) 
013b cb 77		    bit SPI_DO,a 
013d 20 02		    jr nz, .b3 
013f cb 99		    res 3,c 
0141			.b3: 
0141				; then low 
0141 cb af			res SPI_SCLK,a 
0143 d3 80			out (storage_adata),a 
0145 00				nop 
0146				; clock bit high 
0146 cb ef			set SPI_SCLK,a 
0148 d3 80			out (storage_adata),a 
014a 00				nop 
014b			 
014b			    ; read DO  
014b			 
014b cb d1		    set 2,c 
014d db 80			in a,(storage_adata) 
014f cb 77		    bit SPI_DO,a 
0151 20 02		    jr nz, .b2 
0153 cb 91		    res 2,c 
0155			.b2: 
0155				; then low 
0155 cb af			res SPI_SCLK,a 
0157 d3 80			out (storage_adata),a 
0159 00				nop 
015a				; clock bit high 
015a cb ef			set SPI_SCLK,a 
015c d3 80			out (storage_adata),a 
015e 00				nop 
015f			 
015f			    ; read DO  
015f			 
015f cb c9		    set 1,c 
0161 db 80			in a,(storage_adata) 
0163 cb 77		    bit SPI_DO,a 
0165 20 02		    jr nz, .b1 
0167 cb 89		    res 1,c 
0169			.b1: 
0169				; then low 
0169 cb af			res SPI_SCLK,a 
016b d3 80			out (storage_adata),a 
016d 00				nop 
016e				; clock bit high 
016e cb ef			set SPI_SCLK,a 
0170 d3 80			out (storage_adata),a 
0172 00				nop 
0173			 
0173			    ; read DO  
0173			 
0173 cb c1		    set 0,c 
0175 db 80			in a,(storage_adata) 
0177 cb 77		    bit SPI_DO,a 
0179 20 02		    jr nz, .b0 
017b cb 81		    res 0,c 
017d			.b0: 
017d				; then low 
017d cb af			res SPI_SCLK,a 
017f d3 80			out (storage_adata),a 
0181 00				nop 
0182			 
0182			 
0182 32 49 f8			ld (spi_portbyte),a 
0185			 
0185			    ; return byte 
0185 79			    ld a,c 
0186			 
0186			 
0186 c9				ret 
0187			 
0187			 
0187			 
0187			spi_ce_high: 
0187			 
0187				if DEBUG_SPI_HARD_CE0 
0187			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0187					ret 
0187			 
0187				endif 
0187			 
0187			 
0187 f5				push af 
0188			 
0188				; send direct ce to port b 
0188 3e ff			ld a, 255 
018a d3 81			out (storage_bdata), a 
018c			 
018c f1				pop af 
018d			 
018d				; for port a that shares with spi lines AND the mask 
018d			  
018d				if DEBUG_SPI 
018d					push hl 
018d					ld h, a 
018d				endif 
018d			;	ld c, SPI_CE_HIGH 
018d			;	and c 
018d cb c7			set SPI_CE0, a 
018f cb cf			set SPI_CE1, a 
0191 cb d7			set SPI_CE2, a 
0193 cb df			set SPI_CE3, a 
0195 cb e7			set SPI_CE4, a 
0197			 
0197				if DEBUG_SPI 
0197					ld l, a 
0197					DMARK "CEh" 
0197					CALLMONITOR 
0197					pop hl 
0197				endif 
0197 c9				ret 
0198			 
0198			 
0198			spi_ce_low: 
0198			 
0198				if DEBUG_SPI_HARD_CE0 
0198			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0198					ret 
0198			 
0198				endif 
0198			 
0198 c5				push bc 
0199 f5				push af 
019a			 
019a				; send direct ce to port b 
019a 3a 4b f8			ld a, (spi_cartdev) 
019d d3 81			out (storage_bdata), a 
019f			 
019f			 
019f			 
019f				; for port a that shares with spi lines AND the mask 
019f			 
019f 3a 48 f8			ld a, (spi_device)  
01a2 4f				ld c, a 
01a3			 
01a3 f1				pop af 
01a4			 
01a4				; detect CEx 
01a4			 
01a4				if DEBUG_SPI 
01a4					push hl 
01a4					ld h, a 
01a4				endif 
01a4			 
01a4 cb 41			bit SPI_CE0, c 
01a6 20 04			jr nz, .cel1 
01a8 cb 87			res SPI_CE0, a 
01aa 18 1e			jr .celn 
01ac			.cel1: 
01ac cb 49			bit SPI_CE1, c 
01ae 20 04			jr nz, .cel2 
01b0 cb 8f			res SPI_CE1, a 
01b2 18 16			jr .celn 
01b4			.cel2: 
01b4 cb 51			bit SPI_CE2, c 
01b6 20 04			jr nz, .cel3 
01b8 cb 97			res SPI_CE2, a 
01ba 18 0e			jr .celn 
01bc			.cel3: 
01bc cb 59			bit SPI_CE3, c 
01be 20 04			jr nz, .cel4 
01c0 cb 9f			res SPI_CE3, a 
01c2 18 06			jr .celn 
01c4			.cel4: 
01c4 cb 61			bit SPI_CE4, c 
01c6 20 02			jr nz, .celn 
01c8 cb a7			res SPI_CE4, a 
01ca			.celn: 
01ca			 
01ca			 
01ca			 
01ca			;	add c 
01ca			 
01ca				if DEBUG_SPI 
01ca					ld l, a 
01ca					DMARK "CEl" 
01ca					CALLMONITOR 
01ca					pop hl 
01ca				endif 
01ca c1				pop bc 
01cb c9				ret 
01cc			 
01cc			 
01cc			 
01cc			; eof 
01cc			 
01cc			 
01cc			 
01cc			 
01cc			 
# End of file firmware_spi.asm
01cc				include "firmware_seeprom.asm"  
01cc			; 
01cc			; persisent storage interface via microchip serial eeprom 
01cc			 
01cc			; port a pio 2 
01cc			; pa 7 - si 
01cc			; pa 6 - sclk  
01cc			; pa 5 - so 
01cc			; pa 4 - cs 
01cc			; pa 3 - cs 
01cc			; pa 2 - cs 
01cc			; pa 1 - cs 
01cc			; pa 0 - cs 
01cc			; 
01cc			; TODO get block 
01cc			; TODO save block 
01cc			; TODO load file 
01cc			; TODO save file 
01cc			; TODO get dir  
01cc			 
01cc			;  
01cc			storage_adata: equ Device_C    ; device c port a - onboard storage 
01cc			storage_actl: equ Device_C+2     ; device c port a 
01cc			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
01cc			storage_bctl: equ Device_C+3     ; device c port b 
01cc			 
01cc			 
01cc			; TODO move these to hardware driver file 
01cc			 
01cc			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
01cc			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
01cc			; storage bank file system format 
01cc			; 
01cc			; first page of bank: 
01cc			; 	addr 0 - status check 
01cc			;       addr 1 - write protect flag 
01cc			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
01cc			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
01cc			;         TODO see if scanning whole of for available next file id is fast enough 
01cc			;	addr 4 > zero term string of bank label 
01cc			; 
01cc			;        
01cc			;  
01cc			; first page of any file: 
01cc			;      byte 0 - file id  
01cc			;      byte 1-17 - fixed file name  
01cc			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
01cc			; 
01cc			; other pages of any file: 
01cc			;      byte 0 - file id 
01cc			;      byte 1> - file data 
01cc			; 
01cc			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
01cc			;  
01cc			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
01cc			 
01cc			 
01cc			;storage_so_bit: 5 
01cc			;storage_si_bit: 7 
01cc			;storage_sclk_bit: 6 
01cc			  
01cc			 
01cc			; init storage pio 
01cc			 
01cc			storage_init: 
01cc			 
01cc 3e cf		            LD   A, 11001111b 
01ce d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
01d0 3e 00		            LD   A, 00000000b 
01d2 cb f7			set SPI_DO,a 
01d4			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
01d4 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
01d6			 
01d6 3e cf		            LD   A, 11001111b 
01d8 d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
01da 3e 00		            LD   A, 00000000b 
01dc d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
01de			 
01de				; set all external spi devices off 
01de 3e 00			ld a, 0 
01e0 32 48 f8			ld (spi_device), a 
01e3 32 4b f8			ld (spi_cartdev), a 
01e6			 
01e6					; ensure the spi bus is in a default stable state 
01e6 cd b1 00				call se_stable_spi 
01e9			 
01e9			; TODO scan spi bus and gather which storage banks are present 
01e9			 
01e9			; populate store_bank_active  
01e9			; for each ce line activate and attempt to write first byte of bank and read back 
01e9			; if zero is returned then bank is empty 
01e9			;   
01e9			; 
01e9			 
01e9					; init file extent cache to save on slow reads 
01e9			 
01e9			;	ld hl, store_filecache 
01e9			;	ld de, 0 
01e9			;	ld hl,(de)	 
01e9			 
01e9			 
01e9 c9			    ret 
01ea			 
01ea			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
01ea			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
01ea			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
01ea			 
01ea			; INSTRUCTION SET 
01ea			; READ 0000 0011 Read data from memory array beginning at selected address 
01ea			; WRITE 0000 0010 Write data to memory array beginning at selected address 
01ea			; WREN 0000 0110 Set the write enable latch (enable write operations) 
01ea			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
01ea			; RDSR 0000 0101 Read STATUS register 
01ea			; WRSR 0000 0001 Write STATUS register 
01ea			; PE 0100 0010 Page Erase – erase one page in memory array 
01ea			; SE 1101 1000 Sector Erase – erase one sector in memory array 
01ea			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
01ea			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
01ea			 
01ea			; TODO send byte steam for page without setting the address for every single byte 
01ea			; TODO read byte  
01ea			 
01ea			; byte in a 
01ea			; address in hl  
01ea			se_writebyte: 
01ea			        
01ea			    ;   ld c, a 
01ea f5			        push af 
01eb e5			        push hl 
01ec			 
01ec			    ; initi write mode 
01ec			    ; 
01ec			    ;CS low 
01ec			 
01ec 3a 49 f8		       ld a,(spi_portbyte) 
01ef cd 98 01			call spi_ce_low 
01f2			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01f2 d3 80		       out (storage_adata),a 
01f4 32 49 f8		       ld (spi_portbyte), a 
01f7			 
01f7			    ;clock out wren instruction 
01f7			 
01f7 3e 06		    ld a, store_wren_ins 
01f9 cd bc 00		    call spi_send_byte  
01fc			 
01fc			    ;cs high to enable write latch 
01fc			 
01fc 3a 49 f8		       ld a,(spi_portbyte) 
01ff cd 87 01			call spi_ce_high 
0202			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0202 d3 80		       out (storage_adata),a 
0204 32 49 f8		       ld (spi_portbyte), a 
0207			 
0207 00				nop 
0208			    ; 
0208			    ; intial write data 
0208			    ; 
0208			    ; cs low 
0208			     
0208 3a 49 f8		       ld a,(spi_portbyte) 
020b cd 98 01			call spi_ce_low 
020e			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
020e d3 80		       out (storage_adata),a 
0210 32 49 f8		       ld (spi_portbyte), a 
0213			 
0213			    ; clock out write instruction 
0213			     
0213 3e 02		    ld a, store_write_ins  
0215 cd bc 00		    call spi_send_byte  
0218			 
0218			    ; clock out address (depending on address size) 
0218			     
0218 e1			    pop hl 
0219 7c			    ld a,h    ; address out msb first 
021a cd bc 00		    call spi_send_byte  
021d 7d			    ld a,l 
021e cd bc 00		    call spi_send_byte  
0221			 
0221			    ; clock out byte(s) for page 
0221			 
0221 f1			    pop af 
0222 cd bc 00		    call spi_send_byte  
0225			 
0225			    ; end write with ce high 
0225 3a 49 f8		       ld a,(spi_portbyte) 
0228			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
0228 cd 87 01			call spi_ce_high 
022b d3 80		       out (storage_adata),a 
022d 32 49 f8		       ld (spi_portbyte), a 
0230			 
0230				; pause for internal write cycle 
0230 3e 0a			ld a, 10 
0232 cd 4e 0a			call aDelayInMS 
0235 c9			    ret 
0236			 
0236			; buffer to write in de 
0236			; address in hl  
0236			se_writepage: 
0236			        
0236			    ;   ld c, a 
0236 d5				push de 
0237 e5			        push hl 
0238			 
0238			    ; initi write mode 
0238			    ; 
0238			    ;CS low 
0238			 
0238 3a 49 f8		       ld a,(spi_portbyte) 
023b cd 98 01			call spi_ce_low 
023e			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
023e d3 80		       out (storage_adata),a 
0240 32 49 f8		       ld (spi_portbyte), a 
0243			 
0243			    ;clock out wren instruction 
0243			 
0243 3e 06		    ld a, store_wren_ins 
0245 cd bc 00		    call spi_send_byte  
0248			 
0248			    ;cs high to enable write latch 
0248			 
0248 3a 49 f8		       ld a,(spi_portbyte) 
024b cd 87 01			call spi_ce_high 
024e			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
024e d3 80		       out (storage_adata),a 
0250 32 49 f8		       ld (spi_portbyte), a 
0253			 
0253 00				nop 
0254			    ; 
0254			    ; intial write data 
0254			    ; 
0254			    ; cs low 
0254			     
0254 3a 49 f8		       ld a,(spi_portbyte) 
0257			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0257 cd 98 01			call spi_ce_low 
025a d3 80		       out (storage_adata),a 
025c 32 49 f8		       ld (spi_portbyte), a 
025f			 
025f			    ; clock out write instruction 
025f			     
025f 3e 02		    ld a, store_write_ins  
0261 cd bc 00		    call spi_send_byte  
0264			 
0264			    ; clock out address (depending on address size) 
0264			     
0264 e1			    pop hl 
0265 7c			    ld a,h    ; address out msb first 
0266 cd bc 00		    call spi_send_byte  
0269 7d			    ld a,l 
026a cd bc 00		    call spi_send_byte  
026d			 
026d			    ; clock out byte(s) for page 
026d			 
026d e1				pop hl 
026e 06 40			ld b, STORE_BLOCK_PHY 
0270			.bytewrite: 
0270			 
0270 7e				ld a,(hl) 
0271 e5			    push hl 
0272 c5				push bc 
0273 cd bc 00		    call spi_send_byte  
0276 c1				pop bc 
0277 e1				pop hl 
0278			 
0278			    ; end write with ce high 
0278 3a 49 f8		       ld a,(spi_portbyte) 
027b cd 87 01			call spi_ce_high 
027e			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
027e d3 80		       out (storage_adata),a 
0280 32 49 f8		       ld (spi_portbyte), a 
0283			 
0283 23				inc hl 
0284 10 ea			djnz .bytewrite 
0286			 
0286				; pause for internal write cycle 
0286 3e 64			ld a, 100 
0288 cd 4e 0a			call aDelayInMS 
028b c9			    ret 
028c			; returns byte in a 
028c			; address in hl  
028c			se_readbyte: 
028c d5				push de 
028d c5				push bc 
028e			 
028e			    ;   ld c, a 
028e e5			        push hl 
028f			 
028f			    ; initi write mode 
028f			    ; 
028f			    ;CS low 
028f			 
028f 3a 49 f8		       ld a,(spi_portbyte) 
0292 cd 98 01			call spi_ce_low 
0295			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0295 d3 80		       out (storage_adata),a 
0297 32 49 f8		       ld (spi_portbyte), a 
029a			 
029a			    ;clock out wren instruction 
029a			 
029a 3e 03		    ld a, store_read_ins 
029c cd bc 00		    call spi_send_byte  
029f			 
029f			 
029f			    ; clock out address (depending on address size) 
029f			     
029f e1			    pop hl 
02a0 7c			    ld a,h    ; address out msb first 
02a1 cd bc 00		    call spi_send_byte  
02a4 7d			    ld a,l 
02a5 cd bc 00		    call spi_send_byte  
02a8			 
02a8			    ; clock in byte(s) for page 
02a8			 
02a8 cd dd 00		    call spi_read_byte  
02ab f5				push af 
02ac			 
02ac			    ; end write with ce high 
02ac 3a 49 f8		       ld a,(spi_portbyte) 
02af			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02af cd 87 01			call spi_ce_high 
02b2 d3 80		       out (storage_adata),a 
02b4 32 49 f8		       ld (spi_portbyte), a 
02b7			 
02b7 f1				pop af 
02b8			 
02b8 c1				pop bc 
02b9 d1				pop de 
02ba			 
02ba c9			    ret 
02bb			 
02bb			if DEBUG_STORESE 
02bb			 
02bb			storageput:  
02bb			 
02bb			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
02bb			 
02bb 21 1f ee			ld hl,scratch+2 
02be cd d4 10			call get_word_hl 
02c1			 
02c1				; stuff it here for the moment as it will be overwritten later anyway 
02c1			 
02c1 22 40 f1			ld (os_cur_ptr),hl	 
02c4			 
02c4			 
02c4			; get pointer to start of string 
02c4			 
02c4 21 24 ee			ld hl, scratch+7 
02c7			 
02c7			; loop writing char of string to eeprom 
02c7			 
02c7 7e			.writestr:	ld a,(hl) 
02c8 fe 00				cp 0 
02ca 28 12				jr z, .wsdone		; done writing 
02cc e5					push hl 
02cd 2a 40 f1				ld hl,(os_cur_ptr) 
02d0 cd ea 01				call se_writebyte 
02d3			 
02d3 2a 40 f1				ld hl,(os_cur_ptr)	 ; save next eeprom address 
02d6 23					inc hl 
02d7 22 40 f1				ld (os_cur_ptr),hl 
02da			 
02da					; restore string pointer and get next char 
02da			 
02da e1					pop hl 
02db 23					inc hl 
02dc 18 e9				jr .writestr 
02de			 
02de			 
02de			 
02de			.wsdone: 
02de			 
02de			 
02de			; when done load first page into a buffer  
02de			 
02de 21 00 80				ld hl,08000h		; start in ram 
02e1 22 40 f1				ld (os_cur_ptr),hl 
02e4 21 00 00				ld hl, 0		 ; start of page 
02e7 22 45 ee				ld (scratch+40),hl	; hang on to it 
02ea			 
02ea 06 80				ld b, 128		; actually get more then one page 
02ec c5			.wsload:	push bc 
02ed 2a 45 ee				ld hl,(scratch+40) 
02f0 e5					push hl 
02f1 cd 8c 02				call se_readbyte 
02f4			 
02f4					; a now as the byte 
02f4			 
02f4 2a 40 f1				ld hl,(os_cur_ptr) 
02f7 77					ld (hl),a 
02f8					; inc next buffer area 
02f8 23					inc hl 
02f9 22 40 f1				ld (os_cur_ptr),hl 
02fc			 
02fc					; get eeprom position, inc and save for next round 
02fc e1					pop hl		 
02fd 23					inc hl 
02fe 22 45 ee				ld (scratch+40),hl 
0301 c1					pop bc 
0302 10 e8				djnz .wsload 
0304			 
0304			; set 'd' pointer to start of buffer 
0304			 
0304 21 00 80				ld hl,08000h 
0307 22 40 f1				ld (os_cur_ptr),hl 
030a			 
030a			 
030a c9			ret 
030b			 
030b			 
030b c9			storageread: ret 
030c			 
030c			 
030c			 
030c			 
030c			 
030c			 
030c			endif 
030c			 
030c			 
030c			 
# End of file firmware_seeprom.asm
030c			else  
030c			   ; create some stubs for the labels  
030c			se_readbyte: ret  
030c			se_writebyte: ret  
030c			storage_init: ret  
030c			  
030c			endif  
030c			  
030c			; use cf card for storage - throwing timeout errors. Hardware or software?????  
030c			;include "firmware_cf.asm"  
030c			  
030c			; load up high level storage hardward abstractions  
030c			include "firmware_storage.asm"  
030c			 
030c			; persisent storage hardware abstraction layer  
030c			 
030c			 
030c			 
030c			; Block 0 on storage is a config state 
030c			 
030c			 
030c			 
030c			; TODO add read phy block and write phy block functions 
030c			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
030c			 
030c			; Abstraction layer  
030c			 
030c			; Logocial block size is same size as physical size - using tape concept 
030c			 
030c			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
030c			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
030c			 
030c			 
030c			 
030c			; Filesystem layout (Logical layout) 
030c			; 
030c			; Block 0 - Bank config  
030c			; 
030c			;      Byte - 0 file id counter 
030c			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
030c			;      Byte - 3-20 zero terminated bank label 
030c			; 
030c			; Block 1 > File storage 
030c			; 
030c			;      Byte 0 file id    - block 0 file details 
030c			;      Byte 1 block id - block 0 is file  
030c			;            Byte 2-15 - File name 
030c			; 
030c			;       - to end of block data 
030c			; 
030c			 
030c			 
030c			; Read Block 
030c			; ---------- 
030c			; 
030c			; With current bank 
030c			;  
030c			; Get block number to read 
030c			; Load physical blocks starting at start block into buffer 
030c			 
030c			; de points to buffer to use 
030c			; hl holds logical block number  
030c			 
030c			storage_read_block: 
030c			 
030c				; TODO bank selection 
030c			 
030c				; for each of the physical blocks read it into the buffer 
030c 06 40			ld b, STORE_BLOCK_PHY 
030e			 
030e				if DEBUG_STORESE 
030e d5					push de 
030f				endif 
030f				 
030f			.rl1:    
030f			 
030f				; read physical block at hl into de 
030f			        ; increment hl and de to next read position on exit 
030f			 
030f e5				push hl 
0310 d5				push de	 
0311 c5				push bc 
0312			;	if DEBUG_STORESE 
0312			;		push af 
0312			;		ld a, 'R' 
0312			;		ld (debug_mark),a 
0312			;		pop af 
0312			;		CALLMONITOR 
0312			;	endif 
0312 cd 8c 02			call se_readbyte 
0315			;	if DEBUG_STORESE 
0315			;		ld a,(spi_portbyte) 
0315			;		ld l, a 
0315			;		push af 
0315			;		ld a, '1' 
0315			;		ld (debug_mark),a 
0315			;		pop af 
0315			;		CALLMONITOR 
0315			;	endif 
0315 c1				pop bc 
0316 d1				pop de 
0317 e1				pop hl 
0318 12				ld (de),a 
0319 23				inc hl 
031a 13				inc de 
031b			 
031b			;	if DEBUG_STORESE 
031b			;		push af 
031b			;		ld a, 'r' 
031b			;		ld (debug_mark),a 
031b			;		pop af 
031b			;		CALLMONITOR 
031b			;	endif 
031b			 
031b 10 f2			djnz .rl1 
031d			 
031d				if DEBUG_STORESE 
031d					DMARK "SRB" 
031d f5				push af  
031e 3a 32 03			ld a, (.dmark)  
0321 32 77 fb			ld (debug_mark),a  
0324 3a 33 03			ld a, (.dmark+1)  
0327 32 78 fb			ld (debug_mark+1),a  
032a 3a 34 03			ld a, (.dmark+2)  
032d 32 79 fb			ld (debug_mark+2),a  
0330 18 03			jr .pastdmark  
0332 ..			.dmark: db "SRB"  
0335 f1			.pastdmark: pop af  
0336			endm  
# End of macro DMARK
0336 d1					pop de 
0337			; 
0337			;		push af 
0337			;		ld a, 'R' 
0337			;		ld (debug_mark),a 
0337			;		pop af 
0337					CALLMONITOR 
0337 cd 5a 17			call break_point_state  
033a				endm  
# End of macro CALLMONITOR
033a				endif 
033a c9				ret	 
033b				 
033b			 
033b			; File Size 
033b			; --------- 
033b			; 
033b			;   hl file id 
033b			; 
033b			;  returns in hl the number of blocks 
033b			 
033b			storage_file_size: 
033b 5d				ld e, l 
033c 16 00			ld d, 0 
033e 21 40 00			ld hl, STORE_BLOCK_PHY 
0341					if DEBUG_FORTH_WORDS 
0341						DMARK "SIZ" 
0341 f5				push af  
0342 3a 56 03			ld a, (.dmark)  
0345 32 77 fb			ld (debug_mark),a  
0348 3a 57 03			ld a, (.dmark+1)  
034b 32 78 fb			ld (debug_mark+1),a  
034e 3a 58 03			ld a, (.dmark+2)  
0351 32 79 fb			ld (debug_mark+2),a  
0354 18 03			jr .pastdmark  
0356 ..			.dmark: db "SIZ"  
0359 f1			.pastdmark: pop af  
035a			endm  
# End of macro DMARK
035a						CALLMONITOR 
035a cd 5a 17			call break_point_state  
035d				endm  
# End of macro CALLMONITOR
035d					endif 
035d cd 31 06			call storage_findnextid 
0360			 
0360 cd 46 0d			call ishlzero 
0363			;	ld a, l 
0363			;	add h 
0363			;	cp 0 
0363 c8				ret z			; block not found so EOF 
0364			 
0364 11 62 f8			ld de, store_page 
0367 cd 0c 03			call storage_read_block 
036a			 
036a 3a 64 f8			ld a, (store_page+2)	 ; get extent count 
036d 6f				ld l, a 
036e 26 00			ld h, 0 
0370 c9			 	ret 
0371			 
0371			 
0371			; Write Block 
0371			; ----------- 
0371			; 
0371			; With current bank 
0371			;  
0371			; Get block number to write 
0371			; Write physical blocks starting at start block from buffer 
0371			  
0371			storage_write_block: 
0371				; TODO bank selection 
0371			 
0371				; for each of the physical blocks read it into the buffer 
0371 06 40			ld b, STORE_BLOCK_PHY 
0373			 
0373				if DEBUG_STORESE 
0373					DMARK "SWB" 
0373 f5				push af  
0374 3a 88 03			ld a, (.dmark)  
0377 32 77 fb			ld (debug_mark),a  
037a 3a 89 03			ld a, (.dmark+1)  
037d 32 78 fb			ld (debug_mark+1),a  
0380 3a 8a 03			ld a, (.dmark+2)  
0383 32 79 fb			ld (debug_mark+2),a  
0386 18 03			jr .pastdmark  
0388 ..			.dmark: db "SWB"  
038b f1			.pastdmark: pop af  
038c			endm  
# End of macro DMARK
038c			 
038c					;push af 
038c					;ld a, 'W' 
038c					;ld (debug_mark),a 
038c					;pop af 
038c					CALLMONITOR 
038c cd 5a 17			call break_point_state  
038f				endm  
# End of macro CALLMONITOR
038f				endif 
038f			 
038f			; might not be working 
038f			;	call se_writepage 
038f			 
038f			;	ret 
038f			; 
038f			 
038f			 
038f			 
038f			.wl1:    
038f			 
038f				; read physical block at hl into de 
038f			        ; increment hl and de to next read position on exit 
038f			 
038f e5				push hl 
0390 d5				push de	 
0391 c5				push bc 
0392 1a				ld a,(de) 
0393				;if DEBUG_STORESE 
0393			;		push af 
0393			;		ld a, 'W' 
0393			;		ld (debug_mark),a 
0393			;		pop af 
0393			;		CALLMONITOR 
0393			;	endif 
0393 cd ea 01			call se_writebyte 
0396			;	call delay250ms 
0396 00				nop 
0397 00				nop 
0398 00				nop 
0399			;	if DEBUG_STORESE 
0399			;		push af 
0399			;		ld a, 'w' 
0399			;		ld (debug_mark),a 
0399			;		pop af 
0399			;		CALLMONITOR 
0399			;	endif 
0399 c1				pop bc 
039a d1				pop de 
039b e1				pop hl 
039c 23				inc hl 
039d 13				inc de 
039e			 
039e			 
039e 10 ef			djnz .wl1 
03a0			 
03a0				if DEBUG_STORESE 
03a0					DMARK "SW2" 
03a0 f5				push af  
03a1 3a b5 03			ld a, (.dmark)  
03a4 32 77 fb			ld (debug_mark),a  
03a7 3a b6 03			ld a, (.dmark+1)  
03aa 32 78 fb			ld (debug_mark+1),a  
03ad 3a b7 03			ld a, (.dmark+2)  
03b0 32 79 fb			ld (debug_mark+2),a  
03b3 18 03			jr .pastdmark  
03b5 ..			.dmark: db "SW2"  
03b8 f1			.pastdmark: pop af  
03b9			endm  
# End of macro DMARK
03b9			 
03b9					;push af 
03b9					;ld a, 'W' 
03b9					;ld (debug_mark),a 
03b9					;pop af 
03b9					CALLMONITOR 
03b9 cd 5a 17			call break_point_state  
03bc				endm  
# End of macro CALLMONITOR
03bc				endif 
03bc c9				ret	 
03bd			 
03bd			; Init bank 
03bd			; --------- 
03bd			; 
03bd			; With current bank 
03bd			; 
03bd			; Setup block 0 config 
03bd			;     Set 0 file id counter 
03bd			;     Set formatted byte pattern 
03bd			;     Zero out bank label 
03bd			;      
03bd			; For every logical block write 0-1 byte as null 
03bd			 
03bd			storage_get_block_0: 
03bd			 
03bd				; TODO check presence 
03bd			 
03bd				; get block 0 config 
03bd			 
03bd 21 00 00			ld hl, 0 
03c0 11 62 f8			ld de, store_page 
03c3 cd 0c 03			call storage_read_block 
03c6			 
03c6				if DEBUG_STORESE 
03c6					DMARK "SB0" 
03c6 f5				push af  
03c7 3a db 03			ld a, (.dmark)  
03ca 32 77 fb			ld (debug_mark),a  
03cd 3a dc 03			ld a, (.dmark+1)  
03d0 32 78 fb			ld (debug_mark+1),a  
03d3 3a dd 03			ld a, (.dmark+2)  
03d6 32 79 fb			ld (debug_mark+2),a  
03d9 18 03			jr .pastdmark  
03db ..			.dmark: db "SB0"  
03de f1			.pastdmark: pop af  
03df			endm  
# End of macro DMARK
03df 11 62 f8				ld de, store_page 
03e2			;		push af 
03e2			;		ld a, 'i' 
03e2			;		ld (debug_mark),a 
03e2			;		pop af 
03e2					CALLMONITOR 
03e2 cd 5a 17			call break_point_state  
03e5				endm  
# End of macro CALLMONITOR
03e5				endif 
03e5			 
03e5				; is this area formatted? 
03e5			 
03e5			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03e5 2a 63 f8			ld hl, (store_page+1) 
03e8 3e 80			ld a,0x80 
03ea bd				cp l 
03eb 20 22			jr nz, .ininotformatted 
03ed				; do a double check 
03ed 3e 27			ld a, 0x27 
03ef bc				cp h 
03f0 20 1d			jr nz, .ininotformatted 
03f2			 
03f2				; formatted then 
03f2			 
03f2				if DEBUG_STORESE 
03f2					DMARK "SB1" 
03f2 f5				push af  
03f3 3a 07 04			ld a, (.dmark)  
03f6 32 77 fb			ld (debug_mark),a  
03f9 3a 08 04			ld a, (.dmark+1)  
03fc 32 78 fb			ld (debug_mark+1),a  
03ff 3a 09 04			ld a, (.dmark+2)  
0402 32 79 fb			ld (debug_mark+2),a  
0405 18 03			jr .pastdmark  
0407 ..			.dmark: db "SB1"  
040a f1			.pastdmark: pop af  
040b			endm  
# End of macro DMARK
040b					;push af 
040b					;ld a, 'I' 
040b					;ld (debug_mark),a 
040b					;pop af 
040b					CALLMONITOR 
040b cd 5a 17			call break_point_state  
040e				endm  
# End of macro CALLMONITOR
040e				endif 
040e c9				ret 
040f			 
040f			.ininotformatted: 
040f				; bank not formatted so poke various bits to make sure 
040f			 
040f				if DEBUG_STORESE 
040f					DMARK "SB2" 
040f f5				push af  
0410 3a 24 04			ld a, (.dmark)  
0413 32 77 fb			ld (debug_mark),a  
0416 3a 25 04			ld a, (.dmark+1)  
0419 32 78 fb			ld (debug_mark+1),a  
041c 3a 26 04			ld a, (.dmark+2)  
041f 32 79 fb			ld (debug_mark+2),a  
0422 18 03			jr .pastdmark  
0424 ..			.dmark: db "SB2"  
0427 f1			.pastdmark: pop af  
0428			endm  
# End of macro DMARK
0428					;push af 
0428					;ld a, 'f' 
0428					;ld (debug_mark),a 
0428					;pop af 
0428					CALLMONITOR 
0428 cd 5a 17			call break_point_state  
042b				endm  
# End of macro CALLMONITOR
042b				endif 
042b			 
042b cd 2c 0a			call storage_clear_page 
042e			 
042e 21 62 f8			ld hl, store_page 
0431 3e 00			ld a, 0 
0433				 
0433 77				ld (hl),a   ; reset file counter 
0434			 
0434 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0437 22 63 f8		 	ld (store_page+1), hl	 
043a			 
043a				; set default label 
043a			 
043a 21 d6 04			ld hl, .defaultbanklabl 
043d 11 65 f8		 	ld de, store_page+3 
0440 01 0f 00			ld bc, 15 
0443 ed b0			ldir 
0445			 
0445				; Append the current bank id 
0445 21 6e f8			ld hl, store_page+3+9 
0448 3a 47 f8			ld a, (spi_device_id) 
044b 77				ld (hl), a 
044c			 
044c				; save default page 0 
044c			 
044c 21 00 00			ld hl, 0 
044f 11 62 f8			ld de, store_page 
0452				if DEBUG_STORESE 
0452					DMARK "SB3" 
0452 f5				push af  
0453 3a 67 04			ld a, (.dmark)  
0456 32 77 fb			ld (debug_mark),a  
0459 3a 68 04			ld a, (.dmark+1)  
045c 32 78 fb			ld (debug_mark+1),a  
045f 3a 69 04			ld a, (.dmark+2)  
0462 32 79 fb			ld (debug_mark+2),a  
0465 18 03			jr .pastdmark  
0467 ..			.dmark: db "SB3"  
046a f1			.pastdmark: pop af  
046b			endm  
# End of macro DMARK
046b			;		push af 
046b			;		ld a, 'F' 
046b			;		ld (debug_mark),a 
046b			;		pop af 
046b					CALLMONITOR 
046b cd 5a 17			call break_point_state  
046e				endm  
# End of macro CALLMONITOR
046e				endif 
046e cd 71 03			call storage_write_block 
0471				if DEBUG_STORESE 
0471					DMARK "SB4" 
0471 f5				push af  
0472 3a 86 04			ld a, (.dmark)  
0475 32 77 fb			ld (debug_mark),a  
0478 3a 87 04			ld a, (.dmark+1)  
047b 32 78 fb			ld (debug_mark+1),a  
047e 3a 88 04			ld a, (.dmark+2)  
0481 32 79 fb			ld (debug_mark+2),a  
0484 18 03			jr .pastdmark  
0486 ..			.dmark: db "SB4"  
0489 f1			.pastdmark: pop af  
048a			endm  
# End of macro DMARK
048a			;		push af 
048a			;		ld a, '>' 
048a			;		ld (debug_mark),a 
048a			;		pop af 
048a					CALLMONITOR 
048a cd 5a 17			call break_point_state  
048d				endm  
# End of macro CALLMONITOR
048d				endif 
048d			 
048d 00				nop 
048e 00				nop 
048f 00				nop 
0490			 
0490				; now set 0 in every page to mark as a free block 
0490			 
0490 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0492 21 40 00			ld hl, STORE_BLOCK_PHY 
0495			 
0495 3e 00		.setmark1:   	ld a,0 
0497 e5					push hl 
0498 c5					push bc 
0499 cd ea 01				call se_writebyte 
049c 3e 0a			ld a, 10 
049e cd 4e 0a			call aDelayInMS 
04a1 23				inc hl 
04a2 cd ea 01				call se_writebyte 
04a5 3e 0a			ld a, 10 
04a7 cd 4e 0a			call aDelayInMS 
04aa 2b				dec hl 
04ab c1					pop bc 
04ac e1					pop hl 
04ad 3e 40				ld a, STORE_BLOCK_PHY 
04af cd 1d 0d				call addatohl 
04b2 10 e1				djnz .setmark1 
04b4			 
04b4 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
04b6 3e 00		.setmark2:   	ld a,0 
04b8 e5					push hl 
04b9 c5					push bc 
04ba cd ea 01				call se_writebyte 
04bd 3e 0a			ld a, 10 
04bf cd 4e 0a			call aDelayInMS 
04c2 23				inc hl 
04c3 cd ea 01				call se_writebyte 
04c6 3e 0a			ld a, 10 
04c8 cd 4e 0a			call aDelayInMS 
04cb 2b				dec hl 
04cc c1					pop bc 
04cd e1					pop hl 
04ce 3e 40				ld a, STORE_BLOCK_PHY 
04d0 cd 1d 0d				call addatohl 
04d3 10 e1				djnz .setmark2 
04d5			 
04d5					 
04d5			 
04d5			 
04d5 c9				ret 
04d6			 
04d6			 
04d6			 
04d6			 
04d6 .. 00		.defaultbanklabl:   db "BankLabel_",0 
04e1			 
04e1			 
04e1			 
04e1			; Label Bank 
04e1			; ---------- 
04e1			; 
04e1			; With current bank 
04e1			; Read block 0 
04e1			; Set label 
04e1			; Write block 0 
04e1			 
04e1			; label str pointer in hl 
04e1			 
04e1			storage_label:     
04e1			 
04e1				if DEBUG_STORESE 
04e1					DMARK "LBL" 
04e1 f5				push af  
04e2 3a f6 04			ld a, (.dmark)  
04e5 32 77 fb			ld (debug_mark),a  
04e8 3a f7 04			ld a, (.dmark+1)  
04eb 32 78 fb			ld (debug_mark+1),a  
04ee 3a f8 04			ld a, (.dmark+2)  
04f1 32 79 fb			ld (debug_mark+2),a  
04f4 18 03			jr .pastdmark  
04f6 ..			.dmark: db "LBL"  
04f9 f1			.pastdmark: pop af  
04fa			endm  
# End of macro DMARK
04fa					CALLMONITOR 
04fa cd 5a 17			call break_point_state  
04fd				endm  
# End of macro CALLMONITOR
04fd				endif 
04fd			 
04fd e5				push hl 
04fe			 
04fe cd bd 03			call storage_get_block_0 
0501			 
0501				; set default label 
0501			 
0501 e1				pop hl 
0502			 
0502 11 65 f8		 	ld de, store_page+3 
0505 01 0f 00			ld bc, 15 
0508				if DEBUG_STORESE 
0508					DMARK "LB3" 
0508 f5				push af  
0509 3a 1d 05			ld a, (.dmark)  
050c 32 77 fb			ld (debug_mark),a  
050f 3a 1e 05			ld a, (.dmark+1)  
0512 32 78 fb			ld (debug_mark+1),a  
0515 3a 1f 05			ld a, (.dmark+2)  
0518 32 79 fb			ld (debug_mark+2),a  
051b 18 03			jr .pastdmark  
051d ..			.dmark: db "LB3"  
0520 f1			.pastdmark: pop af  
0521			endm  
# End of macro DMARK
0521					CALLMONITOR 
0521 cd 5a 17			call break_point_state  
0524				endm  
# End of macro CALLMONITOR
0524				endif 
0524 ed b0			ldir 
0526				; save default page 0 
0526			 
0526 21 00 00			ld hl, 0 
0529 11 62 f8			ld de, store_page 
052c				if DEBUG_STORESE 
052c					DMARK "LBW" 
052c f5				push af  
052d 3a 41 05			ld a, (.dmark)  
0530 32 77 fb			ld (debug_mark),a  
0533 3a 42 05			ld a, (.dmark+1)  
0536 32 78 fb			ld (debug_mark+1),a  
0539 3a 43 05			ld a, (.dmark+2)  
053c 32 79 fb			ld (debug_mark+2),a  
053f 18 03			jr .pastdmark  
0541 ..			.dmark: db "LBW"  
0544 f1			.pastdmark: pop af  
0545			endm  
# End of macro DMARK
0545					CALLMONITOR 
0545 cd 5a 17			call break_point_state  
0548				endm  
# End of macro CALLMONITOR
0548				endif 
0548 cd 71 03			call storage_write_block 
054b			 
054b c9				ret 
054c			 
054c			 
054c			 
054c			; Read Block 0 - Config 
054c			; --------------------- 
054c			; 
054c			; With current bank 
054c			; Call presence test 
054c			;    If not present format/init bank  
054c			; Read block 0  
054c			;  
054c			 
054c			 
054c			; Dir 
054c			; --- 
054c			; 
054c			; With current bank 
054c			; Load Block 0 Config 
054c			; Get max file id number 
054c			; For each logical block 
054c			;    Read block read byte 2 
054c			;      if first block of file 
054c			;         Display file name 
054c			;         Display type flags for file 
054c			;        
054c			 
054c			; moving to words as this requires stack control 
054c			 
054c			 
054c			; Delete File 
054c			; ----------- 
054c			; 
054c			; With current bank 
054c			; 
054c			; Load Block 0 Config 
054c			; Get max file id number 
054c			; For each logical block 
054c			;    Read block file id 
054c			;      If first block of file and dont have file id 
054c			;         if file to delete 
054c			;         Save file id 
054c			;         Null file id 
054c			;         Write this block back 
054c			;      If file id is one saved 
054c			;         Null file id 
054c			;         Write this block back 
054c			 
054c			storage_erase: 
054c			 
054c				; hl contains the file id 
054c			 
054c 5d				ld e, l 
054d 16 00			ld d, 0 
054f 21 40 00			ld hl, STORE_BLOCK_PHY 
0552					if DEBUG_FORTH_WORDS 
0552						DMARK "ERA" 
0552 f5				push af  
0553 3a 67 05			ld a, (.dmark)  
0556 32 77 fb			ld (debug_mark),a  
0559 3a 68 05			ld a, (.dmark+1)  
055c 32 78 fb			ld (debug_mark+1),a  
055f 3a 69 05			ld a, (.dmark+2)  
0562 32 79 fb			ld (debug_mark+2),a  
0565 18 03			jr .pastdmark  
0567 ..			.dmark: db "ERA"  
056a f1			.pastdmark: pop af  
056b			endm  
# End of macro DMARK
056b						CALLMONITOR 
056b cd 5a 17			call break_point_state  
056e				endm  
# End of macro CALLMONITOR
056e					endif 
056e cd 31 06			call storage_findnextid 
0571 cd 46 0d			call ishlzero 
0574 c8				ret z 
0575			 
0575 e5				push hl 
0576			 
0576				; TODO check file not found 
0576			 
0576 11 62 f8			ld de, store_page 
0579 cd 0c 03			call storage_read_block 
057c			 
057c					if DEBUG_FORTH_WORDS 
057c						DMARK "ER1" 
057c f5				push af  
057d 3a 91 05			ld a, (.dmark)  
0580 32 77 fb			ld (debug_mark),a  
0583 3a 92 05			ld a, (.dmark+1)  
0586 32 78 fb			ld (debug_mark+1),a  
0589 3a 93 05			ld a, (.dmark+2)  
058c 32 79 fb			ld (debug_mark+2),a  
058f 18 03			jr .pastdmark  
0591 ..			.dmark: db "ER1"  
0594 f1			.pastdmark: pop af  
0595			endm  
# End of macro DMARK
0595						CALLMONITOR 
0595 cd 5a 17			call break_point_state  
0598				endm  
# End of macro CALLMONITOR
0598					endif 
0598 3a 62 f8			ld a, (store_page)	; get file id 
059b 32 5b f8			ld (store_tmpid), a 
059e			 
059e 3a 64 f8			ld a, (store_page+2)    ; get count of extends 
05a1 32 5a f8			ld (store_tmpext), a 
05a4			 
05a4				; wipe file header 
05a4			 
05a4 e1				pop hl 
05a5 3e 00			ld a, 0 
05a7 32 62 f8			ld (store_page), a 
05aa 32 63 f8			ld (store_page+1),a 
05ad 11 62 f8			ld de, store_page 
05b0					if DEBUG_FORTH_WORDS 
05b0						DMARK "ER2" 
05b0 f5				push af  
05b1 3a c5 05			ld a, (.dmark)  
05b4 32 77 fb			ld (debug_mark),a  
05b7 3a c6 05			ld a, (.dmark+1)  
05ba 32 78 fb			ld (debug_mark+1),a  
05bd 3a c7 05			ld a, (.dmark+2)  
05c0 32 79 fb			ld (debug_mark+2),a  
05c3 18 03			jr .pastdmark  
05c5 ..			.dmark: db "ER2"  
05c8 f1			.pastdmark: pop af  
05c9			endm  
# End of macro DMARK
05c9						CALLMONITOR 
05c9 cd 5a 17			call break_point_state  
05cc				endm  
# End of macro CALLMONITOR
05cc					endif 
05cc cd 71 03			call storage_write_block 
05cf			 
05cf			 
05cf				; wipe file extents 
05cf			 
05cf 3a 5a f8			ld a, (store_tmpext) 
05d2 47				ld b, a 
05d3			 
05d3			.eraext:	  
05d3 c5				push bc 
05d4			 
05d4 21 40 00			ld hl, STORE_BLOCK_PHY 
05d7 3a 5b f8			ld a,(store_tmpid) 
05da 5f				ld e, a 
05db 50				ld d, b	 
05dc					if DEBUG_FORTH_WORDS 
05dc						DMARK "ER3" 
05dc f5				push af  
05dd 3a f1 05			ld a, (.dmark)  
05e0 32 77 fb			ld (debug_mark),a  
05e3 3a f2 05			ld a, (.dmark+1)  
05e6 32 78 fb			ld (debug_mark+1),a  
05e9 3a f3 05			ld a, (.dmark+2)  
05ec 32 79 fb			ld (debug_mark+2),a  
05ef 18 03			jr .pastdmark  
05f1 ..			.dmark: db "ER3"  
05f4 f1			.pastdmark: pop af  
05f5			endm  
# End of macro DMARK
05f5						CALLMONITOR 
05f5 cd 5a 17			call break_point_state  
05f8				endm  
# End of macro CALLMONITOR
05f8					endif 
05f8 cd 31 06			call storage_findnextid 
05fb			 
05fb e5				push hl 
05fc 11 62 f8			ld de, store_page 
05ff cd 0c 03			call storage_read_block 
0602			 
0602				; free block	 
0602			 
0602 3e 00			ld a, 0 
0604 32 62 f8			ld (store_page), a 
0607 32 63 f8			ld (store_page+1),a 
060a 11 62 f8			ld de, store_page 
060d e1				pop hl 
060e					if DEBUG_FORTH_WORDS 
060e						DMARK "ER4" 
060e f5				push af  
060f 3a 23 06			ld a, (.dmark)  
0612 32 77 fb			ld (debug_mark),a  
0615 3a 24 06			ld a, (.dmark+1)  
0618 32 78 fb			ld (debug_mark+1),a  
061b 3a 25 06			ld a, (.dmark+2)  
061e 32 79 fb			ld (debug_mark+2),a  
0621 18 03			jr .pastdmark  
0623 ..			.dmark: db "ER4"  
0626 f1			.pastdmark: pop af  
0627			endm  
# End of macro DMARK
0627						CALLMONITOR 
0627 cd 5a 17			call break_point_state  
062a				endm  
# End of macro CALLMONITOR
062a					endif 
062a cd 71 03			call storage_write_block 
062d			 
062d c1				pop bc 
062e 10 a3			djnz .eraext 
0630			 
0630 c9				ret 
0631			 
0631			 
0631			; Find Free Block 
0631			; --------------- 
0631			; 
0631			; With current bank 
0631			;  
0631			; From given starting logical block 
0631			;    Read block  
0631			;    If no file id 
0631			;         Return block id 
0631			 
0631			 
0631			; hl starting page number 
0631			; hl contains free page number or zero if no pages free 
0631			; e contains the file id to locate 
0631			; d contains the block number 
0631			 
0631			; TODO change to find file id and use zero for free block 
0631			 
0631			storage_findnextid: 
0631			 
0631				; now locate first 0 page to mark as a free block 
0631			 
0631 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0633			;	ld hl, STORE_BLOCK_PHY 
0633			 
0633					if DEBUG_FORTH_WORDS 
0633					DMARK "FNI" 
0633 f5				push af  
0634 3a 48 06			ld a, (.dmark)  
0637 32 77 fb			ld (debug_mark),a  
063a 3a 49 06			ld a, (.dmark+1)  
063d 32 78 fb			ld (debug_mark+1),a  
0640 3a 4a 06			ld a, (.dmark+2)  
0643 32 79 fb			ld (debug_mark+2),a  
0646 18 03			jr .pastdmark  
0648 ..			.dmark: db "FNI"  
064b f1			.pastdmark: pop af  
064c			endm  
# End of macro DMARK
064c						CALLMONITOR 
064c cd 5a 17			call break_point_state  
064f				endm  
# End of macro CALLMONITOR
064f					endif 
064f			.ff1:   	 
064f e5					push hl 
0650 c5					push bc 
0651 d5					push de 
0652 cd 8c 02				call se_readbyte 
0655 5f					ld e,a 
0656 23					inc hl 
0657 cd 8c 02				call se_readbyte 
065a 57					ld d, a 
065b e1					pop hl 
065c e5					push hl 
065d cd 3b 0d				call cmp16 
0660 28 49				jr z, .fffound 
0662			 
0662 d1					pop de 
0663 c1					pop bc 
0664 e1					pop hl 
0665			 
0665					; is found? 
0665					;cp e 
0665					;ret z 
0665			 
0665 3e 40				ld a, STORE_BLOCK_PHY 
0667 cd 1d 0d				call addatohl 
066a 10 e3				djnz .ff1 
066c			 
066c 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
066e			.ff2:   	 
066e			 
066e e5					push hl 
066f c5					push bc 
0670 d5					push de 
0671 cd 8c 02				call se_readbyte 
0674 5f					ld e,a 
0675 23					inc hl 
0676 cd 8c 02				call se_readbyte 
0679 57					ld d, a 
067a			 
067a e1					pop hl 
067b e5					push hl 
067c cd 3b 0d				call cmp16 
067f 28 2a				jr z, .fffound 
0681			 
0681 d1					pop de 
0682 c1					pop bc 
0683 e1					pop hl 
0684					; is found? 
0684					;cp e 
0684					;ret z 
0684			 
0684 3e 40				ld a, STORE_BLOCK_PHY 
0686 cd 1d 0d				call addatohl 
0689 10 e3				djnz .ff2 
068b			 
068b			 
068b					if DEBUG_FORTH_WORDS 
068b					DMARK "FN-" 
068b f5				push af  
068c 3a a0 06			ld a, (.dmark)  
068f 32 77 fb			ld (debug_mark),a  
0692 3a a1 06			ld a, (.dmark+1)  
0695 32 78 fb			ld (debug_mark+1),a  
0698 3a a2 06			ld a, (.dmark+2)  
069b 32 79 fb			ld (debug_mark+2),a  
069e 18 03			jr .pastdmark  
06a0 ..			.dmark: db "FN-"  
06a3 f1			.pastdmark: pop af  
06a4			endm  
# End of macro DMARK
06a4					;	push af 
06a4					;	ld a, 'n' 
06a4					;	ld (debug_mark),a 
06a4					;	pop af 
06a4						CALLMONITOR 
06a4 cd 5a 17			call break_point_state  
06a7				endm  
# End of macro CALLMONITOR
06a7					endif 
06a7				; no free marks! 
06a7 21 00 00				ld hl, 0 
06aa c9				ret 
06ab			.fffound: 
06ab				 
06ab			 
06ab d1					pop de 
06ac c1					pop bc 
06ad e1					pop hl 
06ae					if DEBUG_FORTH_WORDS 
06ae					DMARK "FNF" 
06ae f5				push af  
06af 3a c3 06			ld a, (.dmark)  
06b2 32 77 fb			ld (debug_mark),a  
06b5 3a c4 06			ld a, (.dmark+1)  
06b8 32 78 fb			ld (debug_mark+1),a  
06bb 3a c5 06			ld a, (.dmark+2)  
06be 32 79 fb			ld (debug_mark+2),a  
06c1 18 03			jr .pastdmark  
06c3 ..			.dmark: db "FNF"  
06c6 f1			.pastdmark: pop af  
06c7			endm  
# End of macro DMARK
06c7					;	push af 
06c7					;	ld a, 'n' 
06c7					;	ld (debug_mark),a 
06c7					;	pop af 
06c7						CALLMONITOR 
06c7 cd 5a 17			call break_point_state  
06ca				endm  
# End of macro CALLMONITOR
06ca					endif 
06ca c9				ret 
06cb			 
06cb			 
06cb			 
06cb			; Free Space 
06cb			; ---------- 
06cb			; 
06cb			; With current bank 
06cb			; 
06cb			; Set block count to zero 
06cb			; Starting with first logical block 
06cb			;      Find free block  
06cb			;      If block id given, increment block count 
06cb			; 
06cb			;  
06cb			 
06cb			 
06cb			; hl contains count of free blocks 
06cb			 
06cb			storage_freeblocks: 
06cb			 
06cb				; now locate first 0 page to mark as a free block 
06cb			 
06cb 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
06cd 21 40 00			ld hl, STORE_BLOCK_PHY 
06d0 11 00 00			ld de, 0 
06d3			 
06d3			.fb1:   	 
06d3 e5					push hl 
06d4 c5					push bc 
06d5 d5					push de 
06d6 cd 8c 02				call se_readbyte 
06d9 d1					pop de 
06da c1					pop bc 
06db e1					pop hl 
06dc			 
06dc					; is free? 
06dc fe 00				cp 0 
06de 20 01				jr nz, .ff1cont 
06e0 13					inc de 
06e1			 
06e1			.ff1cont: 
06e1			 
06e1			 
06e1 3e 40				ld a, STORE_BLOCK_PHY 
06e3 cd 1d 0d				call addatohl 
06e6 10 eb				djnz .fb1 
06e8			 
06e8 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
06ea			.fb2:   	 
06ea e5					push hl 
06eb c5					push bc 
06ec d5					push de 
06ed cd 8c 02				call se_readbyte 
06f0 d1					pop de 
06f1 c1					pop bc 
06f2 e1					pop hl 
06f3			 
06f3					; is free? 
06f3 fe 00				cp 0 
06f5 20 01				jr nz, .ff2cont 
06f7 13					inc de 
06f8			 
06f8			.ff2cont: 
06f8			 
06f8 3e 40				ld a, STORE_BLOCK_PHY 
06fa cd 1d 0d				call addatohl 
06fd 10 eb				djnz .fb2 
06ff			 
06ff eb				ex de, hl 
0700 c9				ret 
0701			 
0701			; Get File ID 
0701			; ----------- 
0701			; 
0701			; With current bank 
0701			;  
0701			; Load Block 0 Config 
0701			; Get max file id number 
0701			; For each logical block 
0701			;    Read block file id 
0701			;      If first block of file and dont have file id 
0701			;         if file get id and exit 
0701			 
0701			 
0701			 
0701			 
0701			; Create File 
0701			; ----------- 
0701			; 
0701			; With current bank  
0701			; Load Block 0 Config 
0701			; Get max file id number 
0701			; Increment file id number 
0701			; Save Config 
0701			; Find free block 
0701			; Set buffer with file name and file id 
0701			; Write buffer to free block  
0701			 
0701			 
0701			; hl point to file name 
0701			; hl returns file id 
0701			 
0701			; file format: 
0701			; byte 0 - file id 
0701			; byte 1 - extent number 
0701			; byte 2-> data 
0701			 
0701			; format for extent number 0: 
0701			; 
0701			; byte 0 - file id 
0701			; byte 1 - extent 0 
0701			; byte 2 - extent count 
0701			; byte 3 -> file name and meta data 
0701			 
0701			 
0701			storage_create: 
0701				if DEBUG_STORESE 
0701					DMARK "SCR" 
0701 f5				push af  
0702 3a 16 07			ld a, (.dmark)  
0705 32 77 fb			ld (debug_mark),a  
0708 3a 17 07			ld a, (.dmark+1)  
070b 32 78 fb			ld (debug_mark+1),a  
070e 3a 18 07			ld a, (.dmark+2)  
0711 32 79 fb			ld (debug_mark+2),a  
0714 18 03			jr .pastdmark  
0716 ..			.dmark: db "SCR"  
0719 f1			.pastdmark: pop af  
071a			endm  
# End of macro DMARK
071a					CALLMONITOR 
071a cd 5a 17			call break_point_state  
071d				endm  
# End of macro CALLMONITOR
071d				endif 
071d			 
071d e5				push hl		; save file name pointer 
071e			 
071e cd bd 03			call storage_get_block_0 
0721			 
0721 3a 62 f8			ld a,(store_page)	; get current file id 
0724 3c				inc a 
0725 32 62 f8			ld (store_page),a 
0728				 
0728 32 5b f8			ld (store_tmpid),a			; save id 
072b			 
072b 21 00 00			ld hl, 0 
072e 11 62 f8			ld de, store_page 
0731				if DEBUG_STORESE 
0731					DMARK "SCw" 
0731 f5				push af  
0732 3a 46 07			ld a, (.dmark)  
0735 32 77 fb			ld (debug_mark),a  
0738 3a 47 07			ld a, (.dmark+1)  
073b 32 78 fb			ld (debug_mark+1),a  
073e 3a 48 07			ld a, (.dmark+2)  
0741 32 79 fb			ld (debug_mark+2),a  
0744 18 03			jr .pastdmark  
0746 ..			.dmark: db "SCw"  
0749 f1			.pastdmark: pop af  
074a			endm  
# End of macro DMARK
074a					CALLMONITOR 
074a cd 5a 17			call break_point_state  
074d				endm  
# End of macro CALLMONITOR
074d				endif 
074d cd 71 03			call storage_write_block	 ; save update 
0750			 
0750				if DEBUG_STORESE 
0750 11 62 f8				ld de, store_page 
0753					DMARK "SCC" 
0753 f5				push af  
0754 3a 68 07			ld a, (.dmark)  
0757 32 77 fb			ld (debug_mark),a  
075a 3a 69 07			ld a, (.dmark+1)  
075d 32 78 fb			ld (debug_mark+1),a  
0760 3a 6a 07			ld a, (.dmark+2)  
0763 32 79 fb			ld (debug_mark+2),a  
0766 18 03			jr .pastdmark  
0768 ..			.dmark: db "SCC"  
076b f1			.pastdmark: pop af  
076c			endm  
# End of macro DMARK
076c					CALLMONITOR 
076c cd 5a 17			call break_point_state  
076f				endm  
# End of macro CALLMONITOR
076f				endif 
076f				;  
076f				 
076f 21 40 00			ld hl, STORE_BLOCK_PHY 
0772 11 00 00			ld de, 0 
0775 cd 31 06			call storage_findnextid 
0778			 
0778 22 4c f8			ld (store_tmppageid), hl    ; save page to use  
077b			 
077b				; TODO detect 0 = no spare blocks 
077b			 
077b				; hl now contains the free page to use for the file header page 
077b			 
077b				if DEBUG_STORESE 
077b				DMARK "SCF" 
077b f5				push af  
077c 3a 90 07			ld a, (.dmark)  
077f 32 77 fb			ld (debug_mark),a  
0782 3a 91 07			ld a, (.dmark+1)  
0785 32 78 fb			ld (debug_mark+1),a  
0788 3a 92 07			ld a, (.dmark+2)  
078b 32 79 fb			ld (debug_mark+2),a  
078e 18 03			jr .pastdmark  
0790 ..			.dmark: db "SCF"  
0793 f1			.pastdmark: pop af  
0794			endm  
# End of macro DMARK
0794					CALLMONITOR 
0794 cd 5a 17			call break_point_state  
0797				endm  
# End of macro CALLMONITOR
0797				endif 
0797			 
0797 22 4c f8			ld (store_tmppageid), hl 
079a				 
079a 3a 5b f8			ld a,(store_tmpid)    ; get file id 
079d			;	ld a, (store_filecache)			; save to cache 
079d			 
079d 32 62 f8			ld (store_page),a    ; set page id 
07a0 3e 00			ld a, 0			 ; extent 0 is file header 
07a2 32 63 f8			ld (store_page+1), a   ; set file extent 
07a5			 
07a5 32 64 f8			ld (store_page+2), a   ; extent count for the file 
07a8			 
07a8			;	inc hl 		; init block 0 of file 
07a8			;	inc hl   		; skip file and extent id 
07a8			 ;       ld a, 0 
07a8			;	ld (hl),a 
07a8			;	ld a, (store_filecache+1)  	; save to cache 
07a8			 
07a8			;	inc hl    ; file name 
07a8				 
07a8				 
07a8 11 65 f8			ld de, store_page+3    ; get buffer for term string to use as file name 
07ab				if DEBUG_STORESE 
07ab					DMARK "SCc" 
07ab f5				push af  
07ac 3a c0 07			ld a, (.dmark)  
07af 32 77 fb			ld (debug_mark),a  
07b2 3a c1 07			ld a, (.dmark+1)  
07b5 32 78 fb			ld (debug_mark+1),a  
07b8 3a c2 07			ld a, (.dmark+2)  
07bb 32 79 fb			ld (debug_mark+2),a  
07be 18 03			jr .pastdmark  
07c0 ..			.dmark: db "SCc"  
07c3 f1			.pastdmark: pop af  
07c4			endm  
# End of macro DMARK
07c4					CALLMONITOR 
07c4 cd 5a 17			call break_point_state  
07c7				endm  
# End of macro CALLMONITOR
07c7				endif 
07c7 e1				pop hl    ; get zero term string 
07c8 e5				push hl 
07c9 3e 00			ld a, 0 
07cb cd 86 11			call strlent 
07ce 23				inc hl   ; cover zero term 
07cf 06 00			ld b,0 
07d1 4d				ld c,l 
07d2 e1				pop hl 
07d3				;ex de, hl 
07d3				if DEBUG_STORESE 
07d3					DMARK "SCa" 
07d3 f5				push af  
07d4 3a e8 07			ld a, (.dmark)  
07d7 32 77 fb			ld (debug_mark),a  
07da 3a e9 07			ld a, (.dmark+1)  
07dd 32 78 fb			ld (debug_mark+1),a  
07e0 3a ea 07			ld a, (.dmark+2)  
07e3 32 79 fb			ld (debug_mark+2),a  
07e6 18 03			jr .pastdmark  
07e8 ..			.dmark: db "SCa"  
07eb f1			.pastdmark: pop af  
07ec			endm  
# End of macro DMARK
07ec					;push af 
07ec					;ld a, 'a' 
07ec					;ld (debug_mark),a 
07ec					;pop af 
07ec					CALLMONITOR 
07ec cd 5a 17			call break_point_state  
07ef				endm  
# End of macro CALLMONITOR
07ef				endif 
07ef ed b0			ldir    ; copy zero term string 
07f1				if DEBUG_STORESE 
07f1					DMARK "SCA" 
07f1 f5				push af  
07f2 3a 06 08			ld a, (.dmark)  
07f5 32 77 fb			ld (debug_mark),a  
07f8 3a 07 08			ld a, (.dmark+1)  
07fb 32 78 fb			ld (debug_mark+1),a  
07fe 3a 08 08			ld a, (.dmark+2)  
0801 32 79 fb			ld (debug_mark+2),a  
0804 18 03			jr .pastdmark  
0806 ..			.dmark: db "SCA"  
0809 f1			.pastdmark: pop af  
080a			endm  
# End of macro DMARK
080a					CALLMONITOR 
080a cd 5a 17			call break_point_state  
080d				endm  
# End of macro CALLMONITOR
080d				endif 
080d			 
080d				; write file header page 
080d			 
080d 2a 4c f8			ld hl,(store_tmppageid) 
0810 11 62 f8			ld de, store_page 
0813				if DEBUG_STORESE 
0813					DMARK "SCb" 
0813 f5				push af  
0814 3a 28 08			ld a, (.dmark)  
0817 32 77 fb			ld (debug_mark),a  
081a 3a 29 08			ld a, (.dmark+1)  
081d 32 78 fb			ld (debug_mark+1),a  
0820 3a 2a 08			ld a, (.dmark+2)  
0823 32 79 fb			ld (debug_mark+2),a  
0826 18 03			jr .pastdmark  
0828 ..			.dmark: db "SCb"  
082b f1			.pastdmark: pop af  
082c			endm  
# End of macro DMARK
082c					;push af 
082c					;ld a, 'b' 
082c					;ld (debug_mark),a 
082c					;pop af 
082c					CALLMONITOR 
082c cd 5a 17			call break_point_state  
082f				endm  
# End of macro CALLMONITOR
082f				endif 
082f cd 71 03			call storage_write_block 
0832			 
0832 3a 5b f8			ld a, (store_tmpid) 
0835 6f				ld l, a 
0836 26 00			ld h,0 
0838				if DEBUG_STORESE 
0838					DMARK "SCz" 
0838 f5				push af  
0839 3a 4d 08			ld a, (.dmark)  
083c 32 77 fb			ld (debug_mark),a  
083f 3a 4e 08			ld a, (.dmark+1)  
0842 32 78 fb			ld (debug_mark+1),a  
0845 3a 4f 08			ld a, (.dmark+2)  
0848 32 79 fb			ld (debug_mark+2),a  
084b 18 03			jr .pastdmark  
084d ..			.dmark: db "SCz"  
0850 f1			.pastdmark: pop af  
0851			endm  
# End of macro DMARK
0851					CALLMONITOR 
0851 cd 5a 17			call break_point_state  
0854				endm  
# End of macro CALLMONITOR
0854				endif 
0854 c9				ret 
0855				 
0855			 
0855			 
0855			; 
0855			; Read File 
0855			; 
0855			; h - file id to locate 
0855			; l - extent to locate 
0855			; de - pointer to string to read into 
0855			; 
0855			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
0855			 
0855			.sr_fail: 
0855 d1				pop de 
0856 c9				ret 
0857			 
0857			storage_read: 
0857 d5				push de 
0858			 
0858			; TODO BUG the above push is it popped before the RET Z? 
0858			 
0858			; TODO how to handle multiple part blocks 
0858			 
0858				; locate file extent to read 
0858			 
0858 5c				ld e, h 
0859 55				ld d, l 
085a 21 40 00			ld hl, STORE_BLOCK_PHY 
085d				if DEBUG_STORESE 
085d					DMARK "SRE" 
085d f5				push af  
085e 3a 72 08			ld a, (.dmark)  
0861 32 77 fb			ld (debug_mark),a  
0864 3a 73 08			ld a, (.dmark+1)  
0867 32 78 fb			ld (debug_mark+1),a  
086a 3a 74 08			ld a, (.dmark+2)  
086d 32 79 fb			ld (debug_mark+2),a  
0870 18 03			jr .pastdmark  
0872 ..			.dmark: db "SRE"  
0875 f1			.pastdmark: pop af  
0876			endm  
# End of macro DMARK
0876					CALLMONITOR 
0876 cd 5a 17			call break_point_state  
0879				endm  
# End of macro CALLMONITOR
0879				endif 
0879 cd 31 06			call storage_findnextid 
087c			 
087c				if DEBUG_STORESE 
087c					DMARK "SRf" 
087c f5				push af  
087d 3a 91 08			ld a, (.dmark)  
0880 32 77 fb			ld (debug_mark),a  
0883 3a 92 08			ld a, (.dmark+1)  
0886 32 78 fb			ld (debug_mark+1),a  
0889 3a 93 08			ld a, (.dmark+2)  
088c 32 79 fb			ld (debug_mark+2),a  
088f 18 03			jr .pastdmark  
0891 ..			.dmark: db "SRf"  
0894 f1			.pastdmark: pop af  
0895			endm  
# End of macro DMARK
0895					CALLMONITOR 
0895 cd 5a 17			call break_point_state  
0898				endm  
# End of macro CALLMONITOR
0898				endif 
0898 cd 46 0d			call ishlzero 
089b			;	ld a, l 
089b			;	add h 
089b			;	cp 0 
089b 28 b8			jr z,.sr_fail			; block not found so EOF 
089d			 
089d				; hl contains page number to load 
089d d1				pop de   ; get storage 
089e d5				push de 
089f				if DEBUG_STORESE 
089f					DMARK "SRg" 
089f f5				push af  
08a0 3a b4 08			ld a, (.dmark)  
08a3 32 77 fb			ld (debug_mark),a  
08a6 3a b5 08			ld a, (.dmark+1)  
08a9 32 78 fb			ld (debug_mark+1),a  
08ac 3a b6 08			ld a, (.dmark+2)  
08af 32 79 fb			ld (debug_mark+2),a  
08b2 18 03			jr .pastdmark  
08b4 ..			.dmark: db "SRg"  
08b7 f1			.pastdmark: pop af  
08b8			endm  
# End of macro DMARK
08b8					CALLMONITOR 
08b8 cd 5a 17			call break_point_state  
08bb				endm  
# End of macro CALLMONITOR
08bb				endif 
08bb cd 0c 03			call storage_read_block 
08be			 
08be			 
08be			; TODO if block has no zeros then need to read next block  
08be			 
08be			 
08be					 
08be e1				pop hl 		 ; return start of data to show as not EOF 
08bf 23				inc hl   ; past file id 
08c0 23				inc hl   ; past ext 
08c1				if DEBUG_STORESE 
08c1					DMARK "SRe" 
08c1 f5				push af  
08c2 3a d6 08			ld a, (.dmark)  
08c5 32 77 fb			ld (debug_mark),a  
08c8 3a d7 08			ld a, (.dmark+1)  
08cb 32 78 fb			ld (debug_mark+1),a  
08ce 3a d8 08			ld a, (.dmark+2)  
08d1 32 79 fb			ld (debug_mark+2),a  
08d4 18 03			jr .pastdmark  
08d6 ..			.dmark: db "SRe"  
08d9 f1			.pastdmark: pop af  
08da			endm  
# End of macro DMARK
08da					CALLMONITOR 
08da cd 5a 17			call break_point_state  
08dd				endm  
# End of macro CALLMONITOR
08dd				endif 
08dd c9					ret 
08de			 
08de			 
08de			 
08de			; 
08de			; Append File 
08de			; 
08de			; hl - file id to locate 
08de			; de - pointer to (multi block) string to write 
08de			 
08de			.sa_notfound: 
08de d1				pop de 
08df c9				ret 
08e0			 
08e0			 
08e0			storage_append: 
08e0				; hl -  file id to append to 
08e0				; de - string to append 
08e0			 
08e0 d5				push de 
08e1				 
08e1				if DEBUG_STORESE 
08e1					DMARK "AP1" 
08e1 f5				push af  
08e2 3a f6 08			ld a, (.dmark)  
08e5 32 77 fb			ld (debug_mark),a  
08e8 3a f7 08			ld a, (.dmark+1)  
08eb 32 78 fb			ld (debug_mark+1),a  
08ee 3a f8 08			ld a, (.dmark+2)  
08f1 32 79 fb			ld (debug_mark+2),a  
08f4 18 03			jr .pastdmark  
08f6 ..			.dmark: db "AP1"  
08f9 f1			.pastdmark: pop af  
08fa			endm  
# End of macro DMARK
08fa					CALLMONITOR 
08fa cd 5a 17			call break_point_state  
08fd				endm  
# End of macro CALLMONITOR
08fd				endif 
08fd			 
08fd 7d				ld a, l 
08fe 32 5b f8			ld (store_tmpid), a 
0901			 
0901				; get file header  
0901			 
0901 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
0903 3a 5b f8			ld a, (store_tmpid) 
0906 5f				ld e, a 
0907			 
0907 21 40 00				ld hl, STORE_BLOCK_PHY 
090a cd 31 06				call storage_findnextid 
090d			 
090d cd 46 0d			call ishlzero 
0910 28 cc			jr z, .sa_notfound 
0912			 
0912 22 4c f8			ld (store_tmppageid), hl 
0915			 
0915				; TODO handle file id not found 
0915			 
0915				if DEBUG_STORESE 
0915					DMARK "AP2" 
0915 f5				push af  
0916 3a 2a 09			ld a, (.dmark)  
0919 32 77 fb			ld (debug_mark),a  
091c 3a 2b 09			ld a, (.dmark+1)  
091f 32 78 fb			ld (debug_mark+1),a  
0922 3a 2c 09			ld a, (.dmark+2)  
0925 32 79 fb			ld (debug_mark+2),a  
0928 18 03			jr .pastdmark  
092a ..			.dmark: db "AP2"  
092d f1			.pastdmark: pop af  
092e			endm  
# End of macro DMARK
092e					CALLMONITOR 
092e cd 5a 17			call break_point_state  
0931				endm  
# End of macro CALLMONITOR
0931				endif 
0931			 
0931				; update file extent count 
0931			 
0931 11 62 f8			ld de, store_page 
0934			 
0934 cd 0c 03			call storage_read_block 
0937			 
0937				if DEBUG_STORESE 
0937					DMARK "AP3" 
0937 f5				push af  
0938 3a 4c 09			ld a, (.dmark)  
093b 32 77 fb			ld (debug_mark),a  
093e 3a 4d 09			ld a, (.dmark+1)  
0941 32 78 fb			ld (debug_mark+1),a  
0944 3a 4e 09			ld a, (.dmark+2)  
0947 32 79 fb			ld (debug_mark+2),a  
094a 18 03			jr .pastdmark  
094c ..			.dmark: db "AP3"  
094f f1			.pastdmark: pop af  
0950			endm  
# End of macro DMARK
0950					CALLMONITOR 
0950 cd 5a 17			call break_point_state  
0953				endm  
# End of macro CALLMONITOR
0953				endif 
0953			;	ld (store_tmppageid), hl 
0953			 
0953 3a 64 f8			ld a, (store_page+2) 
0956 3c				inc a 
0957 32 64 f8			ld (store_page+2), a 
095a 32 5a f8			ld (store_tmpext), a 
095d				 
095d				if DEBUG_STORESE 
095d					DMARK "AP3" 
095d f5				push af  
095e 3a 72 09			ld a, (.dmark)  
0961 32 77 fb			ld (debug_mark),a  
0964 3a 73 09			ld a, (.dmark+1)  
0967 32 78 fb			ld (debug_mark+1),a  
096a 3a 74 09			ld a, (.dmark+2)  
096d 32 79 fb			ld (debug_mark+2),a  
0970 18 03			jr .pastdmark  
0972 ..			.dmark: db "AP3"  
0975 f1			.pastdmark: pop af  
0976			endm  
# End of macro DMARK
0976					CALLMONITOR 
0976 cd 5a 17			call break_point_state  
0979				endm  
# End of macro CALLMONITOR
0979				endif 
0979 2a 4c f8			ld hl, (store_tmppageid) 
097c 11 62 f8			ld de, store_page 
097f cd 71 03			call storage_write_block 
0982			 
0982				; find free block 
0982			 
0982 11 00 00			ld de, 0			 ; file extent to locate 
0985			 
0985 21 40 00				ld hl, STORE_BLOCK_PHY 
0988 cd 31 06				call storage_findnextid 
098b cd 46 0d			call ishlzero 
098e ca de 08			jp z, .sa_notfound 
0991			 
0991					; TODO handle no space left 
0991					 
0991 22 4c f8				ld (store_tmppageid), hl 
0994			 
0994				if DEBUG_STORESE 
0994					DMARK "AP4" 
0994 f5				push af  
0995 3a a9 09			ld a, (.dmark)  
0998 32 77 fb			ld (debug_mark),a  
099b 3a aa 09			ld a, (.dmark+1)  
099e 32 78 fb			ld (debug_mark+1),a  
09a1 3a ab 09			ld a, (.dmark+2)  
09a4 32 79 fb			ld (debug_mark+2),a  
09a7 18 03			jr .pastdmark  
09a9 ..			.dmark: db "AP4"  
09ac f1			.pastdmark: pop af  
09ad			endm  
# End of macro DMARK
09ad					CALLMONITOR 
09ad cd 5a 17			call break_point_state  
09b0				endm  
# End of macro CALLMONITOR
09b0				endif 
09b0					; init the buffer with zeros so we can id if the buffer is full or not 
09b0			 
09b0 e5					push hl 
09b1 c5					push bc 
09b2			 
09b2 21 62 f8				ld hl, store_page 
09b5 06 40				ld b, STORE_BLOCK_PHY 
09b7 3e 00				ld a, 0 
09b9 77			.zeroblock:	ld (hl), a 
09ba 23					inc hl 
09bb 10 fc				djnz .zeroblock 
09bd			 
09bd c1					pop bc 
09be e1					pop hl 
09bf			 
09bf					; construct block 
09bf			 
09bf 3a 5b f8				ld a, (store_tmpid) 
09c2 32 62 f8				ld (store_page), a   ; file id 
09c5 3a 5a f8				ld a, (store_tmpext)   ; extent for this block 
09c8 32 63 f8				ld (store_page+1), a 
09cb			 
09cb e1					pop hl    ; get string to write 
09cc 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
09ce 11 64 f8				ld de, store_page+2 
09d1			 
09d1				if DEBUG_STORESE 
09d1					DMARK "AP5" 
09d1 f5				push af  
09d2 3a e6 09			ld a, (.dmark)  
09d5 32 77 fb			ld (debug_mark),a  
09d8 3a e7 09			ld a, (.dmark+1)  
09db 32 78 fb			ld (debug_mark+1),a  
09de 3a e8 09			ld a, (.dmark+2)  
09e1 32 79 fb			ld (debug_mark+2),a  
09e4 18 03			jr .pastdmark  
09e6 ..			.dmark: db "AP5"  
09e9 f1			.pastdmark: pop af  
09ea			endm  
# End of macro DMARK
09ea					CALLMONITOR 
09ea cd 5a 17			call break_point_state  
09ed				endm  
# End of macro CALLMONITOR
09ed				endif 
09ed			 
09ed			 
09ed			 
09ed					; fill buffer with data until end of string or full block 
09ed			 
09ed 7e			.appd:		ld a, (hl) 
09ee 12					ld (de), a 
09ef fe 00				cp 0 
09f1 28 04				jr z, .appdone 
09f3 23					inc hl 
09f4 13					inc de 
09f5 10 f6				djnz .appd 
09f7			 
09f7 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
09f8 f5					push af   		; save last byte dumped 
09f9			 
09f9			 
09f9 2a 4c f8			ld hl, (store_tmppageid) 
09fc 11 62 f8			ld de, store_page 
09ff				if DEBUG_STORESE 
09ff					DMARK "AP6" 
09ff f5				push af  
0a00 3a 14 0a			ld a, (.dmark)  
0a03 32 77 fb			ld (debug_mark),a  
0a06 3a 15 0a			ld a, (.dmark+1)  
0a09 32 78 fb			ld (debug_mark+1),a  
0a0c 3a 16 0a			ld a, (.dmark+2)  
0a0f 32 79 fb			ld (debug_mark+2),a  
0a12 18 03			jr .pastdmark  
0a14 ..			.dmark: db "AP6"  
0a17 f1			.pastdmark: pop af  
0a18			endm  
# End of macro DMARK
0a18					CALLMONITOR 
0a18 cd 5a 17			call break_point_state  
0a1b				endm  
# End of macro CALLMONITOR
0a1b				endif 
0a1b cd 71 03				call storage_write_block 
0a1e			 
0a1e			 
0a1e				; was that a full block of data written? 
0a1e				; any more to write out? 
0a1e			 
0a1e				; if yes then set vars and jump to start of function again 
0a1e			 
0a1e f1					pop af 
0a1f d1					pop de 
0a20			 
0a20 fe 00				cp 0		 ; no, string was fully written 
0a22 c8					ret z 
0a23			 
0a23					; setup vars for next cycle 
0a23			 
0a23 3a 5b f8				ld a, (store_tmpid) 
0a26 6f					ld l, a 
0a27 26 00				ld h, 0 
0a29			 
0a29 c3 e0 08			 	jp storage_append	 ; yes, need to write out some more 
0a2c			 
0a2c			 
0a2c			 
0a2c			 
0a2c			 
0a2c			 
0a2c			 
0a2c			if DEBUG_STORECF 
0a2c			storageput:	 
0a2c					ret 
0a2c			storageread: 
0a2c					ld hl, store_page 
0a2c					ld b, 200 
0a2c					ld a,0 
0a2c			.src:		ld (hl),a 
0a2c					inc hl 
0a2c					djnz .src 
0a2c					 
0a2c			 
0a2c					ld de, 0 
0a2c					ld bc, 1 
0a2c					ld hl, store_page 
0a2c					call cfRead 
0a2c			 
0a2c				call cfGetError 
0a2c				ld hl,scratch 
0a2c				call hexout 
0a2c				ld hl, scratch+2 
0a2c				ld a, 0 
0a2c				ld (hl),a 
0a2c				ld de, scratch 
0a2c				ld a,display_row_1 
0a2c				call str_at_display 
0a2c				call update_display 
0a2c			 
0a2c					ld hl, store_page 
0a2c					ld (os_cur_ptr),hl 
0a2c			 
0a2c					ret 
0a2c			endif 
0a2c			 
0a2c			 
0a2c			; Clear out the main buffer store (used to remove junk before writing a new block) 
0a2c			 
0a2c			storage_clear_page: 
0a2c e5				push hl 
0a2d d5				push de 
0a2e c5				push bc 
0a2f 21 62 f8			ld hl, store_page 
0a32 3e 00			ld a, 0 
0a34 77				ld (hl), a 
0a35			 
0a35 11 63 f8			ld de, store_page+1 
0a38 01 40 00			ld bc, STORE_BLOCK_PHY 
0a3b			 
0a3b ed b0			ldir 
0a3d				 
0a3d c1				pop bc 
0a3e d1				pop de 
0a3f e1				pop hl 
0a40 c9				ret 
0a41			 
0a41			; eof 
# End of file firmware_storage.asm
0a41			  
0a41			; support routines for above hardware abstraction layer  
0a41			  
0a41			include "firmware_general.asm"        ; general support functions  
0a41			 
0a41			; word look up 
0a41			 
0a41			; in 
0a41			; a is the index 
0a41			; hl is pointer start of array 
0a41			; 
0a41			; returns 
0a41			; hl to the word 
0a41			; 
0a41			 
0a41			table_lookup:  
0a41 d5					push de 
0a42 eb					ex de, hl 
0a43			 
0a43 6f					ld l, a 
0a44 26 00				ld h, 0 
0a46 29					add hl, hl 
0a47 19					add hl, de 
0a48 7e					ld a, (hl) 
0a49 23					inc hl 
0a4a 66					ld h,(hl) 
0a4b 6f					ld l, a 
0a4c			 
0a4c d1					pop de 
0a4d c9					ret 
0a4e			 
0a4e			; Delay loops 
0a4e			 
0a4e			 
0a4e			 
0a4e			aDelayInMS: 
0a4e c5				push bc 
0a4f 47				ld b,a 
0a50			msdelay: 
0a50 c5				push bc 
0a51				 
0a51			 
0a51 01 41 00			ld bc,041h 
0a54 cd 6c 0a			call delayloop 
0a57 c1				pop bc 
0a58 05				dec b 
0a59 20 f5			jr nz,msdelay 
0a5b			 
0a5b			;if CPU_CLOCK_8MHZ 
0a5b			;msdelay8: 
0a5b			;	push bc 
0a5b			;	 
0a5b			; 
0a5b			;	ld bc,041h 
0a5b			;	call delayloop 
0a5b			;	pop bc 
0a5b			;	dec b 
0a5b			;	jr nz,msdelay8 
0a5b			;endif 
0a5b			 
0a5b			 
0a5b c1				pop bc 
0a5c c9				ret 
0a5d			 
0a5d			 
0a5d			delay250ms: 
0a5d				;push de 
0a5d 01 00 40			ld bc, 04000h 
0a60 c3 6c 0a			jp delayloop 
0a63			delay500ms: 
0a63				;push de 
0a63 01 00 80			ld bc, 08000h 
0a66 c3 6c 0a			jp delayloop 
0a69			delay1s: 
0a69				;push bc 
0a69			   ; Clobbers A, d and e 
0a69 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0a6c			delayloop: 
0a6c c5			    push bc 
0a6d			 
0a6d			if BASE_CPM 
0a6d				ld bc, CPM_DELAY_TUNE 
0a6d			.cpmloop: 
0a6d				push bc 
0a6d			 
0a6d			endif 
0a6d			 
0a6d			 
0a6d			 
0a6d			delayloopi: 
0a6d			;	push bc 
0a6d			;.dl: 
0a6d cb 47		    bit     0,a    	; 8 
0a6f cb 47		    bit     0,a    	; 8 
0a71 cb 47		    bit     0,a    	; 8 
0a73 e6 ff		    and     255  	; 7 
0a75 0b			    dec     bc      	; 6 
0a76 79			    ld      a,c     	; 4 
0a77 b0			    or      b     	; 4 
0a78 c2 6d 0a		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0a7b			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0a7b				;pop de 
0a7b			;pop bc 
0a7b			 
0a7b			if BASE_CPM 
0a7b				pop bc 
0a7b				 
0a7b			    dec     bc      	; 6 
0a7b			    ld      a,c     	; 4 
0a7b			    or      b     	; 4 
0a7b			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0a7b				 
0a7b			 
0a7b			endif 
0a7b			;if CPU_CLOCK_8MHZ 
0a7b			;    pop bc 
0a7b			;    push bc 
0a7b			;.dl8: 
0a7b			;    bit     0,a    	; 8 
0a7b			;    bit     0,a    	; 8 
0a7b			;    bit     0,a    	; 8 
0a7b			;    and     255  	; 7 
0a7b			;    dec     bc      	; 6 
0a7b			;    ld      a,c     	; 4 
0a7b			;    or      b     	; 4 
0a7b			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0a7b			;endif 
0a7b			 
0a7b			;if CPU_CLOCK_10MHZ 
0a7b			;    pop bc 
0a7b			;    push bc 
0a7b			;.dl8: 
0a7b			;    bit     0,a    	; 8 
0a7b			;    bit     0,a    	; 8 
0a7b			;    bit     0,a    	; 8 
0a7b			;    and     255  	; 7 
0a7b			;    dec     bc      	; 6 
0a7b			;    ld      a,c     	; 4 
0a7b			;    or      b     	; 4 
0a7b			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0a7b			;endif 
0a7b c1			    pop bc 
0a7c			 
0a7c c9				ret 
0a7d			 
0a7d			 
0a7d			 
0a7d			; eof 
# End of file firmware_general.asm
0a7d			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0a7d			; display routines that use the physical hardware abstraction layer 
0a7d			 
0a7d			 
0a7d			; information window 
0a7d			 
0a7d			; pass hl with 1st string to display 
0a7d			; pass de with 2nd string to display 
0a7d			 
0a7d			info_panel: 
0a7d e5				push hl 
0a7e			 
0a7e 2a d8 f8			ld hl, (display_fb_active) 
0a81 e5				push hl    ; future de destination 
0a82 21 bd fa				ld hl, display_fb0 
0a85 22 d8 f8				ld (display_fb_active), hl 
0a88			 
0a88 cd e9 0a			call clear_display 
0a8b			 
0a8b			 
0a8b 3e 55			ld a, display_row_3 + 5 
0a8d cd fc 0a			call str_at_display 
0a90			 
0a90 e1				pop hl 
0a91 d1				pop de 
0a92			 
0a92 e5				push hl 
0a93			 
0a93			 
0a93 3e 2d			ld a, display_row_2 + 5 
0a95 cd fc 0a			call str_at_display 
0a98			 
0a98			 
0a98 cd 0c 0b			call update_display 
0a9b cd 62 1c			call next_page_prompt 
0a9e cd e9 0a			call clear_display 
0aa1			 
0aa1				 
0aa1 21 1c fa				ld hl, display_fb1 
0aa4 22 d8 f8				ld (display_fb_active), hl 
0aa7 cd 0c 0b			call update_display 
0aaa			 
0aaa			 
0aaa c9				ret 
0aab			 
0aab			 
0aab			 
0aab			 
0aab			; TODO windowing? 
0aab			 
0aab			; TODO scroll line up 
0aab			 
0aab			scroll_up: 
0aab			 
0aab e5				push hl 
0aac d5				push de 
0aad c5				push bc 
0aae			 
0aae				; get frame buffer  
0aae			 
0aae 2a d8 f8			ld hl, (display_fb_active) 
0ab1 e5				push hl    ; future de destination 
0ab2			 
0ab2 11 28 00			ld  de, display_cols 
0ab5 19				add hl, de 
0ab6			 
0ab6 d1				pop de 
0ab7			 
0ab7				;ex de, hl 
0ab7 01 9f 00			ld bc, display_fb_len -1  
0aba			;if DEBUG_FORTH_WORDS 
0aba			;	DMARK "SCL" 
0aba			;	CALLMONITOR 
0aba			;endif	 
0aba ed b0			ldir 
0abc			 
0abc				; wipe bottom row 
0abc			 
0abc			 
0abc 2a d8 f8			ld hl, (display_fb_active) 
0abf 11 a0 00			ld de, display_cols*display_rows 
0ac2 19				add hl, de 
0ac3 06 28			ld b, display_cols 
0ac5 3e 20			ld a, ' ' 
0ac7			.scwipe: 
0ac7 77				ld (hl), a 
0ac8 2b				dec hl 
0ac9 10 fc			djnz .scwipe 
0acb			 
0acb				;pop hl 
0acb			 
0acb c1				pop bc 
0acc d1				pop de 
0acd e1				pop hl 
0ace			 
0ace c9				ret 
0acf			 
0acf			 
0acf			;scroll_upo: 
0acf			;	ld de, display_row_1 
0acf			 ;	ld hl, display_row_2 
0acf			;	ld bc, display_cols 
0acf			;	ldir 
0acf			;	ld de, display_row_2 
0acf			 ;	ld hl, display_row_3 
0acf			;	ld bc, display_cols 
0acf			;	ldir 
0acf			;	ld de, display_row_3 
0acf			 ;	ld hl, display_row_4 
0acf			;	ld bc, display_cols 
0acf			;	ldir 
0acf			 
0acf			; TODO clear row 4 
0acf			 
0acf			;	ret 
0acf			 
0acf				 
0acf			scroll_down: 
0acf			 
0acf e5				push hl 
0ad0 d5				push de 
0ad1 c5				push bc 
0ad2			 
0ad2				; get frame buffer  
0ad2			 
0ad2 2a d8 f8			ld hl, (display_fb_active) 
0ad5			 
0ad5 11 9f 00			ld de, display_fb_len - 1 
0ad8 19				add hl, de 
0ad9			 
0ad9 e5			push hl    ; future de destination 
0ada			 
0ada 11 28 00			ld  de, display_cols 
0add ed 52			sbc hl, de 
0adf			 
0adf			 
0adf d1				pop de 
0ae0			 
0ae0			;	ex de, hl 
0ae0 01 9f 00			ld bc, display_fb_len -1  
0ae3			 
0ae3			 
0ae3				 
0ae3			 
0ae3 ed b0			ldir 
0ae5			 
0ae5				; wipe bottom row 
0ae5			 
0ae5			 
0ae5			;	ld hl, (display_fb_active) 
0ae5			;;	ld de, display_cols*display_rows 
0ae5			;;	add hl, de 
0ae5			;	ld b, display_cols 
0ae5			;	ld a, ' ' 
0ae5			;.scwiped: 
0ae5			;	ld (hl), a 
0ae5			;	dec hl 
0ae5			;	djnz .scwiped 
0ae5			 
0ae5				;pop hl 
0ae5			 
0ae5 c1				pop bc 
0ae6 d1				pop de 
0ae7 e1				pop hl 
0ae8			 
0ae8 c9				ret 
0ae9			;scroll_down: 
0ae9			;	ld de, display_row_4 
0ae9			;	ld hl, display_row_3 
0ae9			;	ld bc, display_cols 
0ae9			;	ldir 
0ae9			;	ld de, display_row_3 
0ae9			; 	ld hl, display_row_2 
0ae9			;	ld bc, display_cols 
0ae9			;	ldir 
0ae9			;	ld de, display_row_2 
0ae9			;	ld hl, display_row_1 
0ae9			;	ld bc, display_cols 
0ae9			;	ldir 
0ae9			;;; TODO clear row 1 
0ae9			;	ret 
0ae9			 
0ae9			 
0ae9			 
0ae9			 
0ae9			 
0ae9			; clear active frame buffer 
0ae9			 
0ae9			clear_display: 
0ae9 3e 20			ld a, ' ' 
0aeb c3 ee 0a			jp fill_display 
0aee			 
0aee			; fill active frame buffer with a char in A 
0aee			 
0aee			fill_display: 
0aee 06 a0			ld b,display_fb_len 
0af0 2a d8 f8			ld hl, (display_fb_active) 
0af3 77			.fd1:	ld (hl),a 
0af4 23				inc hl 
0af5 10 fc			djnz .fd1 
0af7 23				inc hl 
0af8 3e 00			ld a,0 
0afa 77				ld (hl),a 
0afb			 
0afb			 
0afb c9				ret 
0afc			; Write string (DE) at pos (A) to active frame buffer 
0afc			 
0afc 2a d8 f8		str_at_display:    ld hl,(display_fb_active) 
0aff 06 00					ld b,0 
0b01 4f					ld c,a 
0b02 09					add hl,bc 
0b03 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0b04 b7			            OR   A              ;Null terminator? 
0b05 c8			            RET  Z              ;Yes, so finished 
0b06 77					ld (hl),a 
0b07 23				inc hl 
0b08 13			            INC  DE             ;Point to next character 
0b09 18 f8		            JR   .sad1     ;Repeat 
0b0b c9					ret 
0b0c			 
0b0c			; using current frame buffer write to physical display 
0b0c			 
0b0c			update_display: 
0b0c e5				push hl 
0b0d 2a d8 f8			ld hl, (display_fb_active) 
0b10 cd df 65			call write_display 
0b13 e1				pop hl 
0b14 c9				ret 
0b15			 
0b15			; TODO scrolling 
0b15			 
0b15			 
0b15			; move cursor right one char 
0b15			cursor_right: 
0b15			 
0b15				; TODO shift right 
0b15				; TODO if beyond max col 
0b15				; TODO       cursor_next_line 
0b15			 
0b15 c9				ret 
0b16			 
0b16			 
0b16			cursor_next_line: 
0b16				; TODO first char 
0b16				; TODO line down 
0b16				; TODO if past last row 
0b16				; TODO    scroll up 
0b16			 
0b16 c9				ret 
0b17			 
0b17			cursor_left: 
0b17				; TODO shift left 
0b17				; TODO if beyond left  
0b17				; TODO     cursor prev line 
0b17				 
0b17 c9				ret 
0b18			 
0b18			cursor_prev_line: 
0b18				; TODO last char 
0b18				; TODO line up 
0b18				; TODO if past first row 
0b18				; TODO   scroll down 
0b18			 
0b18 c9				ret 
0b19			 
0b19			 
0b19			cout: 
0b19				; A - char 
0b19 c9				ret 
0b1a			 
0b1a			 
0b1a			; Display a menu and allow item selection (optional toggle items) 
0b1a			; 
0b1a			; format: 
0b1a			; hl pointer to word array with zero term for items 
0b1a			; e.g.    db item1 
0b1a			;         db .... 
0b1a			;         db 0 
0b1a			; 
0b1a			; a = starting menu item  
0b1a			; 
0b1a			; de = pointer item toggle array   (todo) 
0b1a			; 
0b1a			; returns item selected in a 1-... 
0b1a			; returns 0 if back button pressed 
0b1a			; 
0b1a			; NOTE: Uses system frame buffer to display 
0b1a			; 
0b1a			; LEFT, Q = go back 
0b1a			; RIGHT, SPACE, CR = select 
0b1a			; UP, A - Up 
0b1a			; DOWN, Z - Down 
0b1a			 
0b1a			 
0b1a			 
0b1a			 
0b1a			 
0b1a			menu: 
0b1a			 
0b1a					; keep array pointer 
0b1a			 
0b1a 22 60 f8				ld (store_tmp1), hl 
0b1d 32 5e f8				ld (store_tmp2), a 
0b20			 
0b20					; check for key bounce 
0b20			 
0b20			if BASE_KEV 
0b20			 
0b20 cd 2a 69		.mbounce:	call cin 
0b23 fe 00				cp 0 
0b25 20 f9				jr nz, .mbounce 
0b27			endif 
0b27					; for ease use ex 
0b27			 
0b27					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0b27 21 bd fa				ld hl, display_fb0 
0b2a 22 d8 f8				ld (display_fb_active), hl 
0b2d			 
0b2d cd e9 0a		.mloop:		call clear_display 
0b30 cd 0c 0b				call update_display 
0b33			 
0b33					; draw selection id '>' at 1 
0b33			 
0b33					; init start of list display 
0b33			 
0b33 3e 05				ld a, 5 
0b35 32 5c f8				ld (store_tmp3), a   ; display row count 
0b38 3a 5e f8				ld a,( store_tmp2) 
0b3b 32 5f f8				ld (store_tmp2+1), a   ; display item count 
0b3e			 
0b3e					 
0b3e			.mitem:	 
0b3e			 
0b3e			 
0b3e 3a 5f f8				ld a,(store_tmp2+1) 
0b41 6f					ld l, a 
0b42 26 00				ld h, 0 
0b44 29					add hl, hl 
0b45 ed 5b 60 f8			ld de, (store_tmp1) 
0b49 19					add hl, de 
0b4a 7e					ld a, (hl) 
0b4b 23					inc hl 
0b4c 66					ld h,(hl) 
0b4d 6f					ld l, a 
0b4e			 
0b4e cd 46 0d				call ishlzero 
0b51 28 1a				jr z, .mdone 
0b53			 
0b53 eb					ex de, hl 
0b54 3a 5c f8				ld a, (store_tmp3) 
0b57 cd fc 0a				call str_at_display 
0b5a					 
0b5a			 
0b5a					; next item 
0b5a 3a 5f f8				ld a, (store_tmp2+1) 
0b5d 3c					inc a 
0b5e 32 5f f8				ld (store_tmp2+1), a   ; display item count 
0b61			 
0b61			 		; next row 
0b61			 
0b61 3a 5c f8				ld a, (store_tmp3) 
0b64 c6 28				add display_cols 
0b66 32 5c f8				ld (store_tmp3), a 
0b69			 
0b69					; at end of screen? 
0b69			 
0b69 fe 10				cp display_rows*4 
0b6b 20 d1				jr nz, .mitem 
0b6d			 
0b6d			 
0b6d			.mdone: 
0b6d cd 46 0d				call ishlzero 
0b70 28 08				jr z, .nodn 
0b72			 
0b72 3e 78				ld a, display_row_4 
0b74 11 f3 0b				ld de, .mdown 
0b77 cd fc 0a				call str_at_display 
0b7a			 
0b7a					; draw options to fill the screens with active item on line 1 
0b7a					; if current option is 2 or more then display ^ in top 
0b7a			 
0b7a 3a 5e f8		.nodn:		ld a, (store_tmp2) 
0b7d fe 00				cp 0 
0b7f 28 08				jr z, .noup 
0b81			 
0b81 3e 00				ld a, 0 
0b83 11 f1 0b				ld de, .mup 
0b86 cd fc 0a				call str_at_display 
0b89			 
0b89 3e 02		.noup:		ld a, 2 
0b8b 11 ef 0b				ld de, .msel 
0b8e cd fc 0a				call str_at_display 
0b91			 
0b91					; if current option + 1 is not null then display V in bottom 
0b91					; get key 
0b91 cd 0c 0b				call update_display 
0b94			 
0b94			 
0b94					; handle key 
0b94			 
0b94 cd 19 69				call cin_wait 
0b97			 
0b97 fe 05				cp KEY_UP 
0b99 28 2b				jr z, .mgoup 
0b9b fe 61				cp 'a' 
0b9d 28 27				jr z, .mgoup 
0b9f fe 0a				cp KEY_DOWN 
0ba1 28 32				jr z, .mgod 
0ba3 fe 7a				cp 'z' 
0ba5 28 2e				jr z, .mgod 
0ba7 fe 20				cp ' ' 
0ba9 28 34				jr z, .goend 
0bab fe 0c				cp KEY_RIGHT 
0bad 28 30				jr z, .goend 
0baf fe 0d				cp KEY_CR 
0bb1 28 2c				jr z, .goend 
0bb3 fe 71				cp 'q' 
0bb5 28 0b				jr z, .goback 
0bb7			 
0bb7 fe 0b				cp KEY_LEFT 
0bb9 28 07				jr z, .goback 
0bbb fe 08				cp KEY_BS 
0bbd 28 03				jr z, .goback 
0bbf c3 2d 0b				jp .mloop 
0bc2			 
0bc2			.goback: 
0bc2 3e 00			ld a, 0 
0bc4 18 1d			jr .goend2 
0bc6			 
0bc6				; move up one 
0bc6			.mgoup: 
0bc6 3a 5e f8				ld a, (store_tmp2) 
0bc9 fe 00				cp 0 
0bcb ca 2d 0b				jp z, .mloop 
0bce 3d					dec a 
0bcf 32 5e f8				ld (store_tmp2), a 
0bd2 c3 2d 0b				jp .mloop 
0bd5			 
0bd5				; move down one 
0bd5			.mgod: 
0bd5 3a 5e f8				ld a, (store_tmp2) 
0bd8 3c					inc a 
0bd9 32 5e f8				ld (store_tmp2), a 
0bdc c3 2d 0b				jp .mloop 
0bdf			 
0bdf			 
0bdf			.goend: 
0bdf					; get selected item number 
0bdf			 
0bdf 3a 5e f8				ld a, (store_tmp2) 
0be2 3c					inc a 
0be3			 
0be3			.goend2: 
0be3 f5					push af 
0be4			 
0be4					; restore active fb 
0be4					; TODO BUG assumes fb1 
0be4			 
0be4 21 1c fa				ld hl, display_fb1 
0be7 22 d8 f8				ld (display_fb_active), hl 
0bea			 
0bea					; restore main regs 
0bea			 
0bea			 
0bea cd 0c 0b				call update_display 
0bed			 
0bed f1					pop af 
0bee			 
0bee c9				ret 
0bef			 
0bef .. 00		.msel:   db ">",0 
0bf1 .. 00		.mup:   db "^",0 
0bf3 .. 00		.mdown:   db "v",0 
0bf5			 
0bf5			 
0bf5			; eof 
0bf5			 
# End of file firmware_display.asm
0bf5			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0bf5			; random number generators 
0bf5			 
0bf5			 
0bf5			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0bf5			 
0bf5			 
0bf5			;-----> Generate a random number 
0bf5			; output a=answer 0<=a<=255 
0bf5			; all registers are preserved except: af 
0bf5			random: 
0bf5 e5			        push    hl 
0bf6 d5			        push    de 
0bf7 2a ba f8		        ld      hl,(randData) 
0bfa ed 5f		        ld      a,r 
0bfc 57			        ld      d,a 
0bfd 5e			        ld      e,(hl) 
0bfe 19			        add     hl,de 
0bff 85			        add     a,l 
0c00 ac			        xor     h 
0c01 22 ba f8		        ld      (randData),hl 
0c04 d1			        pop     de 
0c05 e1			        pop     hl 
0c06 c9			        ret 
0c07			 
0c07			 
0c07			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0c07			 
0c07			 
0c07			 
0c07			;------LFSR------ 
0c07			;James Montelongo 
0c07			;optimized by Spencer Putt 
0c07			;out: 
0c07			; a = 8 bit random number 
0c07			RandLFSR: 
0c07 21 c0 f8		        ld hl,LFSRSeed+4 
0c0a 5e			        ld e,(hl) 
0c0b 23			        inc hl 
0c0c 56			        ld d,(hl) 
0c0d 23			        inc hl 
0c0e 4e			        ld c,(hl) 
0c0f 23			        inc hl 
0c10 7e			        ld a,(hl) 
0c11 47			        ld b,a 
0c12 cb 13		        rl e  
0c14 cb 12			rl d 
0c16 cb 11		        rl c  
0c18 17				rla 
0c19 cb 13		        rl e  
0c1b cb 12			rl d 
0c1d cb 11		        rl c  
0c1f 17				rla 
0c20 cb 13		        rl e  
0c22 cb 12			rl d 
0c24 cb 11		        rl c  
0c26 17				rla 
0c27 67			        ld h,a 
0c28 cb 13		        rl e  
0c2a cb 12			rl d 
0c2c cb 11		        rl c  
0c2e 17				rla 
0c2f a8			        xor b 
0c30 cb 13		        rl e  
0c32 cb 12			rl d 
0c34 ac			        xor h 
0c35 a9			        xor c 
0c36 aa			        xor d 
0c37 21 c2 f8		        ld hl,LFSRSeed+6 
0c3a 11 c3 f8		        ld de,LFSRSeed+7 
0c3d 01 07 00		        ld bc,7 
0c40 ed b8		        lddr 
0c42 12			        ld (de),a 
0c43 c9			        ret 
0c44			 
0c44			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0c44			 
0c44			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0c44			 
0c44			 
0c44			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0c44			 
0c44			prng16: 
0c44			;Inputs: 
0c44			;   (seed1) contains a 16-bit seed value 
0c44			;   (seed2) contains a NON-ZERO 16-bit seed value 
0c44			;Outputs: 
0c44			;   HL is the result 
0c44			;   BC is the result of the LCG, so not that great of quality 
0c44			;   DE is preserved 
0c44			;Destroys: 
0c44			;   AF 
0c44			;cycle: 4,294,901,760 (almost 4.3 billion) 
0c44			;160cc 
0c44			;26 bytes 
0c44 2a b4 f8		    ld hl,(seed1) 
0c47 44			    ld b,h 
0c48 4d			    ld c,l 
0c49 29			    add hl,hl 
0c4a 29			    add hl,hl 
0c4b 2c			    inc l 
0c4c 09			    add hl,bc 
0c4d 22 b4 f8		    ld (seed1),hl 
0c50 2a b2 f8		    ld hl,(seed2) 
0c53 29			    add hl,hl 
0c54 9f			    sbc a,a 
0c55 e6 2d		    and %00101101 
0c57 ad			    xor l 
0c58 6f			    ld l,a 
0c59 22 b2 f8		    ld (seed2),hl 
0c5c 09			    add hl,bc 
0c5d c9			    ret 
0c5e			 
0c5e			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0c5e			 
0c5e			rand32: 
0c5e			;Inputs: 
0c5e			;   (seed1_0) holds the lower 16 bits of the first seed 
0c5e			;   (seed1_1) holds the upper 16 bits of the first seed 
0c5e			;   (seed2_0) holds the lower 16 bits of the second seed 
0c5e			;   (seed2_1) holds the upper 16 bits of the second seed 
0c5e			;   **NOTE: seed2 must be non-zero 
0c5e			;Outputs: 
0c5e			;   HL is the result 
0c5e			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0c5e			;Destroys: 
0c5e			;   AF 
0c5e			;Tested and passes all CAcert tests 
0c5e			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0c5e			;it has a period of 18,446,744,069,414,584,320 
0c5e			;roughly 18.4 quintillion. 
0c5e			;LFSR taps: 0,2,6,7  = 11000101 
0c5e			;291cc 
0c5e			;seed1_0=$+1 
0c5e			;    ld hl,12345 
0c5e			;seed1_1=$+1 
0c5e			;    ld de,6789 
0c5e			;    ld b,h 
0c5e			;    ld c,l 
0c5e			;    add hl,hl \ rl e \ rl d 
0c5e			;    add hl,hl \ rl e \ rl d 
0c5e			;    inc l 
0c5e			;    add hl,bc 
0c5e			;    ld (seed1_0),hl 
0c5e			;    ld hl,(seed1_1) 
0c5e			;    adc hl,de 
0c5e			;    ld (seed1_1),hl 
0c5e			;    ex de,hl 
0c5e			;seed2_0=$+1 
0c5e			;    ld hl,9876 
0c5e			;seed2_1=$+1 
0c5e			;    ld bc,54321 
0c5e			;    add hl,hl \ rl c \ rl b 
0c5e			;    ld (seed2_1),bc 
0c5e			;    sbc a,a 
0c5e			;    and %11000101 
0c5e			;    xor l 
0c5e			;    ld l,a 
0c5e			;    ld (seed2_0),hl 
0c5e			;    ex de,hl 
0c5e			;    add hl,bc 
0c5e			;    ret 
0c5e			; 
0c5e			 
0c5e			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0c5e			; 20 bytes, 86 cycles (excluding ret) 
0c5e			 
0c5e			; returns   hl = pseudorandom number 
0c5e			; corrupts   a 
0c5e			 
0c5e			; generates 16-bit pseudorandom numbers with a period of 65535 
0c5e			; using the xorshift method: 
0c5e			 
0c5e			; hl ^= hl << 7 
0c5e			; hl ^= hl >> 9 
0c5e			; hl ^= hl << 8 
0c5e			 
0c5e			; some alternative shift triplets which also perform well are: 
0c5e			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0c5e			 
0c5e			;  org 32768 
0c5e			 
0c5e			xrnd: 
0c5e 2a b8 f8		  ld hl,(xrandc)       ; seed must not be 0 
0c61 3e 00		  ld a,0 
0c63 bd			  cp l 
0c64 20 02		  jr nz, .xrnd1 
0c66 2e 01		  ld l, 1 
0c68			.xrnd1: 
0c68			 
0c68 7c			  ld a,h 
0c69 1f			  rra 
0c6a 7d			  ld a,l 
0c6b 1f			  rra 
0c6c ac			  xor h 
0c6d 67			  ld h,a 
0c6e 7d			  ld a,l 
0c6f 1f			  rra 
0c70 7c			  ld a,h 
0c71 1f			  rra 
0c72 ad			  xor l 
0c73 6f			  ld l,a 
0c74 ac			  xor h 
0c75 67			  ld h,a 
0c76			 
0c76 22 b8 f8		  ld (xrandc),hl 
0c79			 
0c79 c9			  ret 
0c7a			;  
0c7a			 
0c7a			 
0c7a			;;;; int maths 
0c7a			 
0c7a			; https://map.grauw.nl/articles/mult_div_shifts.php 
0c7a			; Divide 16-bit values (with 16-bit result) 
0c7a			; In: Divide BC by divider DE 
0c7a			; Out: BC = result, HL = rest 
0c7a			; 
0c7a			Div16: 
0c7a 21 00 00		    ld hl,0 
0c7d 78			    ld a,b 
0c7e 06 08		    ld b,8 
0c80			Div16_Loop1: 
0c80 17			    rla 
0c81 ed 6a		    adc hl,hl 
0c83 ed 52		    sbc hl,de 
0c85 30 01		    jr nc,Div16_NoAdd1 
0c87 19			    add hl,de 
0c88			Div16_NoAdd1: 
0c88 10 f6		    djnz Div16_Loop1 
0c8a 17			    rla 
0c8b 2f			    cpl 
0c8c 47			    ld b,a 
0c8d 79			    ld a,c 
0c8e 48			    ld c,b 
0c8f 06 08		    ld b,8 
0c91			Div16_Loop2: 
0c91 17			    rla 
0c92 ed 6a		    adc hl,hl 
0c94 ed 52		    sbc hl,de 
0c96 30 01		    jr nc,Div16_NoAdd2 
0c98 19			    add hl,de 
0c99			Div16_NoAdd2: 
0c99 10 f6		    djnz Div16_Loop2 
0c9b 17			    rla 
0c9c 2f			    cpl 
0c9d 41			    ld b,c 
0c9e 4f			    ld c,a 
0c9f c9			ret 
0ca0			 
0ca0			 
0ca0			;http://z80-heaven.wikidot.com/math 
0ca0			; 
0ca0			;Inputs: 
0ca0			;     DE and A are factors 
0ca0			;Outputs: 
0ca0			;     A is not changed 
0ca0			;     B is 0 
0ca0			;     C is not changed 
0ca0			;     DE is not changed 
0ca0			;     HL is the product 
0ca0			;Time: 
0ca0			;     342+6x 
0ca0			; 
0ca0			Mult16: 
0ca0			 
0ca0 06 08		     ld b,8          ;7           7 
0ca2 21 00 00		     ld hl,0         ;10         10 
0ca5 29			       add hl,hl     ;11*8       88 
0ca6 07			       rlca          ;4*8        32 
0ca7 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0ca9 19			         add hl,de   ;--         -- 
0caa 10 f9		       djnz $-5      ;13*7+8     99 
0cac c9			ret 
0cad			 
0cad			; 
0cad			; Square root of 16-bit value 
0cad			; In:  HL = value 
0cad			; Out:  D = result (rounded down) 
0cad			; 
0cad			;Sqr16: 
0cad			;    ld de,#0040 
0cad			;    ld a,l 
0cad			;    ld l,h 
0cad			;    ld h,d 
0cad			;    or a 
0cad			;    ld b,8 
0cad			;Sqr16_Loop: 
0cad			;    sbc hl,de 
0cad			;    jr nc,Sqr16_Skip 
0cad			;    add hl,de 
0cad			;Sqr16_Skip: 
0cad			;    ccf 
0cad			;    rl d 
0cad			;    add a,a 
0cad			;    adc hl,hl 
0cad			;    add a,a 
0cad			;    adc hl,hl 
0cad			;    djnz Sqr16_Loop 
0cad			;    ret 
0cad			; 
0cad			; 
0cad			; Divide 8-bit values 
0cad			; In: Divide E by divider C 
0cad			; Out: A = result, B = rest 
0cad			; 
0cad			Div8: 
0cad af			    xor a 
0cae 06 08		    ld b,8 
0cb0			Div8_Loop: 
0cb0 cb 13		    rl e 
0cb2 17			    rla 
0cb3 91			    sub c 
0cb4 30 01		    jr nc,Div8_NoAdd 
0cb6 81			    add a,c 
0cb7			Div8_NoAdd: 
0cb7 10 f7		    djnz Div8_Loop 
0cb9 47			    ld b,a 
0cba 7b			    ld a,e 
0cbb 17			    rla 
0cbc 2f			    cpl 
0cbd c9			    ret 
0cbe			 
0cbe			; 
0cbe			; Multiply 8-bit value with a 16-bit value (unrolled) 
0cbe			; In: Multiply A with DE 
0cbe			; Out: HL = result 
0cbe			; 
0cbe			Mult12U: 
0cbe 2e 00		    ld l,0 
0cc0 87			    add a,a 
0cc1 30 01		    jr nc,Mult12U_NoAdd0 
0cc3 19			    add hl,de 
0cc4			Mult12U_NoAdd0: 
0cc4 29			    add hl,hl 
0cc5 87			    add a,a 
0cc6 30 01		    jr nc,Mult12U_NoAdd1 
0cc8 19			    add hl,de 
0cc9			Mult12U_NoAdd1: 
0cc9 29			    add hl,hl 
0cca 87			    add a,a 
0ccb 30 01		    jr nc,Mult12U_NoAdd2 
0ccd 19			    add hl,de 
0cce			Mult12U_NoAdd2: 
0cce 29			    add hl,hl 
0ccf 87			    add a,a 
0cd0 30 01		    jr nc,Mult12U_NoAdd3 
0cd2 19			    add hl,de 
0cd3			Mult12U_NoAdd3: 
0cd3 29			    add hl,hl 
0cd4 87			    add a,a 
0cd5 30 01		    jr nc,Mult12U_NoAdd4 
0cd7 19			    add hl,de 
0cd8			Mult12U_NoAdd4: 
0cd8 29			    add hl,hl 
0cd9 87			    add a,a 
0cda 30 01		    jr nc,Mult12U_NoAdd5 
0cdc 19			    add hl,de 
0cdd			Mult12U_NoAdd5: 
0cdd 29			    add hl,hl 
0cde 87			    add a,a 
0cdf 30 01		    jr nc,Mult12U_NoAdd6 
0ce1 19			    add hl,de 
0ce2			Mult12U_NoAdd6: 
0ce2 29			    add hl,hl 
0ce3 87			    add a,a 
0ce4 d0			    ret nc 
0ce5 19			    add hl,de 
0ce6 c9			    ret 
0ce7			 
0ce7			; 
0ce7			; Multiply 8-bit value with a 16-bit value (right rotating) 
0ce7			; In: Multiply A with DE 
0ce7			;      Put lowest value in A for most efficient calculation 
0ce7			; Out: HL = result 
0ce7			; 
0ce7			Mult12R: 
0ce7 21 00 00		    ld hl,0 
0cea			Mult12R_Loop: 
0cea cb 3f		    srl a 
0cec 30 01		    jr nc,Mult12R_NoAdd 
0cee 19			    add hl,de 
0cef			Mult12R_NoAdd: 
0cef cb 23		    sla e 
0cf1 cb 12		    rl d 
0cf3 b7			    or a 
0cf4 c2 ea 0c		    jp nz,Mult12R_Loop 
0cf7 c9			    ret 
0cf8			 
0cf8			; 
0cf8			; Multiply 16-bit values (with 32-bit result) 
0cf8			; In: Multiply BC with DE 
0cf8			; Out: BCHL = result 
0cf8			; 
0cf8			Mult32: 
0cf8 79			    ld a,c 
0cf9 48			    ld c,b 
0cfa 21 00 00		    ld hl,0 
0cfd 06 10		    ld b,16 
0cff			Mult32_Loop: 
0cff 29			    add hl,hl 
0d00 17			    rla 
0d01 cb 11		    rl c 
0d03 30 07		    jr nc,Mult32_NoAdd 
0d05 19			    add hl,de 
0d06 ce 00		    adc a,0 
0d08 d2 0c 0d		    jp nc,Mult32_NoAdd 
0d0b 0c			    inc c 
0d0c			Mult32_NoAdd: 
0d0c 10 f1		    djnz Mult32_Loop 
0d0e 41			    ld b,c 
0d0f 4f			    ld c,a 
0d10 c9			    ret 
0d11			 
0d11			 
0d11			 
0d11			; 
0d11			; Multiply 8-bit values 
0d11			; In:  Multiply H with E 
0d11			; Out: HL = result 
0d11			; 
0d11			Mult8: 
0d11 16 00		    ld d,0 
0d13 6a			    ld l,d 
0d14 06 08		    ld b,8 
0d16			Mult8_Loop: 
0d16 29			    add hl,hl 
0d17 30 01		    jr nc,Mult8_NoAdd 
0d19 19			    add hl,de 
0d1a			Mult8_NoAdd: 
0d1a 10 fa		    djnz Mult8_Loop 
0d1c c9			    ret 
0d1d			 
0d1d			 
0d1d			 
0d1d			 
0d1d			 
0d1d			 
0d1d			 
0d1d			 
0d1d			;;http://z80-heaven.wikidot.com/math 
0d1d			;;This divides DE by BC, storing the result in DE, remainder in HL 
0d1d			; 
0d1d			;DE_Div_BC:          ;1281-2x, x is at most 16 
0d1d			;     ld a,16        ;7 
0d1d			;     ld hl,0        ;10 
0d1d			;     jp $+5         ;10 
0d1d			;.DivLoop: 
0d1d			;       add hl,bc    ;-- 
0d1d			;       dec a        ;64 
0d1d			;       jr z,.DivLoopEnd        ;86 
0d1d			; 
0d1d			;       sla e        ;128 
0d1d			;       rl d         ;128 
0d1d			;       adc hl,hl    ;240 
0d1d			;       sbc hl,bc    ;240 
0d1d			;       jr nc,.DivLoop ;23|21 
0d1d			;       inc e        ;-- 
0d1d			;       jp .DivLoop+1 
0d1d			; 
0d1d			;.DivLoopEnd: 
0d1d			 
0d1d			;HL_Div_C: 
0d1d			;Inputs: 
0d1d			;     HL is the numerator 
0d1d			;     C is the denominator 
0d1d			;Outputs: 
0d1d			;     A is the remainder 
0d1d			;     B is 0 
0d1d			;     C is not changed 
0d1d			;     DE is not changed 
0d1d			;     HL is the quotient 
0d1d			; 
0d1d			;       ld b,16 
0d1d			;       xor a 
0d1d			;         add hl,hl 
0d1d			;         rla 
0d1d			;         cp c 
0d1d			;         jr c,$+4 
0d1d			;           inc l 
0d1d			;           sub c 
0d1d			;         djnz $-7 
0d1d			 
0d1d			; https://plutiedev.com/z80-add-8bit-to-16bit 
0d1d			 
0d1d			addatohl: 
0d1d 85			    add   a, l    ; A = A+L 
0d1e 6f			    ld    l, a    ; L = A+L 
0d1f 8c			    adc   a, h    ; A = A+L+H+carry 
0d20 95			    sub   l       ; A = H+carry 
0d21 67			    ld    h, a    ; H = H+carry 
0d22 c9			ret 
0d23			 
0d23			addatode: 
0d23 83			    add   a, e    ; A = A+L 
0d24 5f			    ld    e, a    ; L = A+L 
0d25 8a			    adc   a, d    ; A = A+L+H+carry 
0d26 93			    sub   e       ; A = H+carry 
0d27 57			    ld    d, a    ; H = H+carry 
0d28 c9			ret 
0d29			 
0d29			 
0d29			addatobc: 
0d29 81			    add   a, c    ; A = A+L 
0d2a 4f			    ld    c, a    ; L = A+L 
0d2b 88			    adc   a, b    ; A = A+L+H+carry 
0d2c 91			    sub   c       ; A = H+carry 
0d2d 47			    ld    b, a    ; H = H+carry 
0d2e c9			ret 
0d2f			 
0d2f			subafromhl: 
0d2f			   ; If A=0 do nothing 
0d2f			    ; Otherwise flip A's sign. Since 
0d2f			    ; the upper byte becomes -1, also 
0d2f			    ; substract 1 from H. 
0d2f ed 44		    neg 
0d31 ca 3a 0d		    jp    z, Skip 
0d34 25			    dec   h 
0d35			     
0d35			    ; Now add the low byte as usual 
0d35			    ; Two's complement takes care of 
0d35			    ; ensuring the result is correct 
0d35 85			    add   a, l 
0d36 6f			    ld    l, a 
0d37 8c			    adc   a, h 
0d38 95			    sub   l 
0d39 67			    ld    h, a 
0d3a			Skip: 
0d3a c9				ret 
0d3b			 
0d3b			 
0d3b			; compare hl and de 
0d3b			; returns:  
0d3b			; if hl = de, z=1, s=0, c0=0 
0d3b			; if hl > de, z=0, s=0, c=0 
0d3b			; if hl < de, z=0, s=1, c=1 
0d3b			cmp16:	 
0d3b b7				or a 
0d3c ed 52			sbc hl,de 
0d3e e0				ret po 
0d3f 7c				ld a,h 
0d40 1f				rra 
0d41 ee 40			xor 01000000B 
0d43 37				scf 
0d44 8f				adc a,a 
0d45 c9				ret 
0d46			 
0d46			 
0d46			; test if hl contains zero   - A is destroyed 
0d46			 
0d46			ishlzero:    
0d46 b7				or a     ; reset flags 
0d47 7c				ld a, h 
0d48 b5				or l        	 
0d49			 
0d49 c9				ret 
0d4a			 
0d4a			 
0d4a			 
0d4a			 
0d4a			if FORTH_ENABLE_FLOATMATH 
0d4a			;include "float/bbcmath.z80" 
0d4a			include "float/lpfpcalc.asm" 
0d4a			endif 
0d4a			 
0d4a			 
0d4a			; eof 
0d4a			 
# End of file firmware_maths.asm
0d4a			include "firmware_strings.asm"   ; string handling  
0d4a			 
0d4a			 
0d4a			; TODO string len 
0d4a			; input text string, end on cr with zero term 
0d4a			; a offset into frame buffer to start prompt 
0d4a			; d is max length 
0d4a			; e is display size TODO 
0d4a			; c is current cursor position 
0d4a			; hl is ptr to where string will be stored 
0d4a			 
0d4a			 
0d4a			; TODO check limit of buffer for new inserts 
0d4a			; TODO check insert does not push beyond buffer 
0d4a			; TODO scroll in a limited display area 
0d4a			; TODO scroll whole screen on page wrap 
0d4a			 
0d4a			 
0d4a			; TODO handle KEY_PREVWORD 
0d4a			; TODO handle KEY_NEXTWORD 
0d4a			; TODO handle KEY_HOME 
0d4a			; TODO handle KEY_END 
0d4a			; TODO use LCD cursor? 
0d4a			 
0d4a 32 70 fb		input_str:    	ld (input_at_pos),a      ; save display position to start 
0d4d 81					add c 
0d4e 32 6e fb				ld (input_at_cursor),a	; save draw pos of cursor 
0d51 22 73 fb				ld (input_start), hl     ; save ptr to buffer 
0d54 79					ld a, c 
0d55 cd 1d 0d				call addatohl 
0d58 22 75 fb				ld (input_ptr), hl     ; save ptr to point under the cursor 
0d5b 7a					ld a,d 
0d5c 32 72 fb			        ld (input_size), a       ; save length of input area 
0d5f 79					ld a, c 
0d60 32 61 fb				ld (input_cursor),a      ; init cursor start position  
0d63 7b					ld a,e 
0d64 32 71 fb			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0d67					 
0d67					 
0d67			 
0d67			;		ld a,(input_ptr) 
0d67			;		ld (input_under_cursor),a 	; save what is under the cursor 
0d67			 
0d67			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0d67					; init cursor shape if not set by the cin routines 
0d67 21 d0 f8				ld hl, cursor_shape 
0d6a 3e ff				ld a, 255 
0d6c 77					ld (hl), a 
0d6d 23					inc hl 
0d6e 3e 00				ld a, 0 
0d70 77					ld (hl), a 
0d71			 
0d71 3e 0f				ld a, CUR_BLINK_RATE 
0d73 32 6c fb				ld (input_cur_flash), a 
0d76 3e 01				ld a, 1 
0d78 32 6b fb				ld (input_cur_onoff),a 
0d7b			 
0d7b			;	if DEBUG_INPUT 
0d7b			;		push af 
0d7b			;		ld a, 'I' 
0d7b			;		ld (debug_mark),a 
0d7b			;		pop af 
0d7b			;		CALLMONITOR 
0d7b			;	endif 
0d7b			.is1:		; main entry loop 
0d7b			 
0d7b			 
0d7b			 
0d7b					; pause 1ms 
0d7b			 
0d7b 3e 01				ld a, 1 
0d7d cd 4e 0a				call aDelayInMS 
0d80			 
0d80					; dec flash counter 
0d80 3a 6c fb				ld a, (input_cur_flash) 
0d83 3d					dec a 
0d84 32 6c fb				ld (input_cur_flash), a 
0d87 fe 00				cp 0 
0d89 20 0d				jr nz, .nochgstate 
0d8b			 
0d8b			 
0d8b					; change state 
0d8b 3a 6b fb				ld a,(input_cur_onoff) 
0d8e ed 44				neg 
0d90 32 6b fb				ld (input_cur_onoff),a 
0d93			 
0d93			 
0d93					; reset on change of state 
0d93 3e 0f				ld a, CUR_BLINK_RATE 
0d95 32 6c fb				ld (input_cur_flash), a 
0d98			 
0d98			.nochgstate: 
0d98					 
0d98					 
0d98			 
0d98					; display cursor  
0d98			 
0d98			;		ld hl, (input_start) 
0d98			;		ld a, (input_cursor) 
0d98			;		call addatohl 
0d98			 
0d98					; get char under cursor and replace with cursor 
0d98 2a 75 fb		ld hl, (input_ptr) 
0d9b			;		ld a, (hl) 
0d9b			;		ld (input_under_cursor),a 
0d9b			;		ld a, '_' 
0d9b			;		ld (hl), a 
0d9b			 
0d9b					; display string 
0d9b			 
0d9b ed 5b 73 fb			ld de, (input_start) 
0d9f 3a 70 fb				ld a, (input_at_pos) 
0da2 cd fc 0a				call str_at_display 
0da5			;	        call update_display 
0da5			 
0da5					; find place to put the cursor 
0da5			;		add h 
0da5			;		ld l, display_row_1 
0da5			;		sub l 
0da5			; (input_at_pos) 
0da5					;ld c, a 
0da5			;		ld a, (input_cursor) 
0da5			;		ld l, (input_at_pos) 
0da5			;		;ld b, h 
0da5			;		add l 
0da5			;		ld (input_at_cursor),a 
0da5					;ld l,h 
0da5			 
0da5			;		ld h, 0 
0da5			;		ld l,(input_at_pos) 
0da5			;		ld a, (input_cursor) 
0da5			;		call addatohl 
0da5			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0da5			;		call subafromhl 
0da5			;		ld a,l 
0da5			;		ld (input_at_cursor), a 
0da5			 
0da5				if DEBUG_INPUT 
0da5					ld a, (hardware_diag) 
0da5					cp 0 
0da5					jr z, .skip_input_diag 
0da5			 
0da5					ld a,(input_at_pos) 
0da5					ld hl, LFSRSeed 
0da5					call hexout 
0da5					ld a, (input_cursor) 
0da5					ld hl, LFSRSeed+2 
0da5					call hexout 
0da5					ld a,(input_at_cursor) 
0da5					ld hl, LFSRSeed+4 
0da5					call hexout 
0da5			 
0da5					ld a,(input_cur_onoff) 
0da5					ld hl, LFSRSeed+6 
0da5					call hexout 
0da5			 
0da5					ld a,(input_cur_flash) 
0da5					ld hl, LFSRSeed+8 
0da5					call hexout 
0da5			 
0da5					ld a,(input_len) 
0da5					ld hl, LFSRSeed+10 
0da5					call hexout 
0da5					ld hl, LFSRSeed+12 
0da5					ld a, 0 
0da5					ld (hl),a 
0da5					ld a, display_row_4 
0da5					ld de, LFSRSeed 
0da5					call str_at_display 
0da5					.skip_input_diag: 
0da5				endif 
0da5			 
0da5					; decide on if we are showing the cursor this time round 
0da5			 
0da5 3a 6b fb				ld a, (input_cur_onoff) 
0da8 fe ff				cp 255 
0daa 28 13				jr z, .skipcur 
0dac			 
0dac			 
0dac 3a 6e fb				ld a,(input_at_cursor) 
0daf 11 d0 f8				ld de, cursor_shape 
0db2 cd fc 0a				call str_at_display 
0db5			 
0db5					; save length of current input string 
0db5 2a 73 fb				ld hl, (input_start) 
0db8 cd 7b 11				call strlenz 
0dbb 7d					ld a,l 
0dbc 32 66 fb				ld (input_len),a 
0dbf			 
0dbf			.skipcur: 
0dbf			 
0dbf cd 0c 0b			        call update_display 
0dc2					 
0dc2			 
0dc2			 
0dc2					; wait 
0dc2				 
0dc2					; TODO loop without wait to flash the cursor and char under cursor	 
0dc2 cd 2a 69				call cin    ; _wait 
0dc5			 
0dc5 fe 00				cp 0 
0dc7 ca 7b 0d				jp z, .is1 
0dca			 
0dca					; get ptr to char to input into 
0dca			 
0dca 4f					ld c,a 
0dcb 2a 73 fb				ld hl, (input_start) 
0dce 3a 61 fb				ld a, (input_cursor) 
0dd1 cd 1d 0d				call addatohl 
0dd4 22 75 fb				ld (input_ptr), hl 
0dd7 79					ld a,c 
0dd8			 
0dd8					; replace char under cursor 
0dd8			 
0dd8			;		ld hl, (input_ptr) 
0dd8			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0dd8			;		ld (hl), a 
0dd8			 
0dd8			;	if DEBUG_INPUT 
0dd8			;		push af 
0dd8			;		ld a, 'i' 
0dd8			;		ld (debug_mark),a 
0dd8			;		pop af 
0dd8			;		CALLMONITOR 
0dd8			;	endif 
0dd8 fe 0e				cp KEY_HOME 
0dda 20 0e				jr nz, .iske 
0ddc			 
0ddc 3a 70 fb				ld a, (input_at_pos) 
0ddf 32 6e fb				ld (input_at_cursor),a 
0de2 3e 00				ld a, 0 
0de4 32 61 fb				ld (input_cursor), a 
0de7 c3 7b 0d				jp .is1 
0dea					 
0dea fe 0f		.iske:		cp KEY_END 
0dec 20 03				jr nz, .isknw 
0dee c3 7b 0d				jp .is1 
0df1			 
0df1 fe 06		.isknw:		cp KEY_NEXTWORD 
0df3 20 1b				jr nz, .iskpw 
0df5			 
0df5 2a 75 fb		.isknwm:	ld hl, (input_ptr) 
0df8 7e					ld a,(hl)	 
0df9 fe 00				cp 0 
0dfb ca 7b 0d				jp z, .is1    ; end of string 
0dfe fe 20				cp ' ' 
0e00 ca 7b 0d				jp z, .is1    ; end of word 
0e03 23					inc hl 
0e04 22 75 fb				ld (input_ptr), hl 
0e07 3a 6e fb				ld a, (input_at_cursor) 
0e0a 3c					inc a 
0e0b 32 6e fb				ld (input_at_cursor), a 
0e0e 18 e5				jr .isknwm 
0e10			 
0e10 fe 07		.iskpw:		cp KEY_PREVWORD 
0e12 20 1b				jr nz, .iskl 
0e14			.iskpwm:	 
0e14 2a 75 fb				ld hl, (input_ptr) 
0e17 7e					ld a,(hl)	 
0e18 fe 00				cp 0  
0e1a ca 7b 0d				jp z, .is1    ; end of string 
0e1d fe 20				cp ' ' 
0e1f ca 7b 0d				jp z, .is1    ; end of word 
0e22 2b					dec hl 
0e23 22 75 fb				ld (input_ptr), hl 
0e26 3a 6e fb				ld a, (input_at_cursor) 
0e29 3d					dec a 
0e2a 32 6e fb				ld (input_at_cursor), a 
0e2d 18 e5				jr .iskpwm 
0e2f			 
0e2f			 
0e2f fe 0b		.iskl:		cp KEY_LEFT 
0e31 20 27				jr nz, .isk1 
0e33			 
0e33 3a 61 fb				ld a, (input_cursor) 
0e36			 
0e36 fe 00				cp 0 
0e38 ca 7b 0d				jp z, .is1 		; at start of line to ignore  
0e3b			 
0e3b 3d					dec  a 		; TODO check underflow 
0e3c 32 61 fb				ld (input_cursor), a 
0e3f			 
0e3f 2a 75 fb				ld hl, (input_ptr) 
0e42 2b					dec hl 
0e43 22 75 fb				ld (input_ptr), hl 
0e46					 
0e46 3a 6e fb				ld a, (input_at_cursor) 
0e49 3d					dec a 
0e4a 32 6e fb				ld (input_at_cursor), a 
0e4d			 
0e4d 3e 01				ld a, 1		; show cursor moving 
0e4f 32 6b fb				ld (input_cur_onoff),a 
0e52 3e 0f				ld a, CUR_BLINK_RATE 
0e54 32 6c fb				ld (input_cur_flash), a 
0e57			 
0e57 c3 7b 0d				jp .is1 
0e5a			 
0e5a fe 0c		.isk1:		cp KEY_RIGHT 
0e5c 20 2a				jr nz, .isk2 
0e5e			 
0e5e 3a 66 fb				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0e61 5f					ld e,a 
0e62 3a 61 fb				ld a, (input_cursor) 
0e65 bb					cp e 
0e66 ca 7b 0d				jp z, .is1		; at the end of string so dont go right 
0e69			 
0e69 3c					inc  a 		; TODO check overflow 
0e6a 32 61 fb				ld (input_cursor), a 
0e6d			 
0e6d 3a 6e fb				ld a, (input_at_cursor) 
0e70 3c					inc a 
0e71 32 6e fb				ld (input_at_cursor), a 
0e74			 
0e74 2a 75 fb				ld hl, (input_ptr) 
0e77 23					inc hl 
0e78 22 75 fb				ld (input_ptr), hl 
0e7b			 
0e7b 3e 01				ld a, 1		; show cursor moving 
0e7d 32 6b fb				ld (input_cur_onoff),a 
0e80 3e 0f				ld a, CUR_BLINK_RATE 
0e82 32 6c fb				ld (input_cur_flash), a 
0e85			 
0e85 c3 7b 0d				jp .is1 
0e88			 
0e88 fe 05		.isk2:		cp KEY_UP 
0e8a			 
0e8a 20 26				jr nz, .isk3 
0e8c			 
0e8c					; swap last command with the current on 
0e8c			 
0e8c					; move cursor to start of string 
0e8c 2a 73 fb				ld hl, (input_start) 
0e8f 22 75 fb				ld (input_ptr), hl 
0e92			 
0e92 3a 70 fb				ld a, (input_at_pos) 
0e95 32 6e fb				ld (input_at_cursor), a 
0e98			 
0e98 3e 00				ld a, 0 
0e9a 32 61 fb				ld (input_cursor), a 
0e9d					 
0e9d					; swap input and last command buffers 
0e9d			 
0e9d 21 44 f1				ld hl, os_cli_cmd 
0ea0 11 43 f2				ld de, os_last_cmd 
0ea3 06 ff				ld b, 255 
0ea5 7e			.swap1:		ld a, (hl) 
0ea6 4f					ld c,a 
0ea7 1a					ld a, (de) 
0ea8 77					ld (hl), a 
0ea9 79					ld a,c 
0eaa 12					ld (de),a 
0eab 23					inc hl 
0eac 13					inc de 
0ead 10 f6				djnz .swap1 
0eaf			 
0eaf			 
0eaf			 
0eaf			 
0eaf			 
0eaf c3 7b 0d				jp .is1 
0eb2			 
0eb2 fe 08		.isk3:		cp KEY_BS 
0eb4 20 3c				jr nz, .isk4 
0eb6			 
0eb6 3a 61 fb				ld a, (input_cursor) 
0eb9			 
0eb9 fe 00				cp 0 
0ebb ca 7b 0d				jp z, .is1 		; at start of line to ignore  
0ebe			 
0ebe 3d					dec  a 		; TODO check underflow 
0ebf 32 61 fb				ld (input_cursor), a 
0ec2			 
0ec2					; hl is source 
0ec2					; de needs to be source - 1 
0ec2			 
0ec2			;		ld a, 0 
0ec2			;		dec hl 
0ec2			;		ld (hl), a 
0ec2			 
0ec2 2a 75 fb				ld hl, (input_ptr) 
0ec5 2b					dec hl 
0ec6 22 75 fb				ld (input_ptr), hl 
0ec9			 
0ec9					; shift all data 
0ec9			 
0ec9 e5					push hl 
0eca 23					inc hl 
0ecb d1					pop de 
0ecc 3a 66 fb				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0ecf 4f					ld c,a 
0ed0 06 00				ld b,0 
0ed2 ed b0				ldir  
0ed4			 
0ed4			 
0ed4			 
0ed4			 
0ed4 3a 6e fb				ld a, (input_at_cursor) 
0ed7 3d					dec a 
0ed8 32 6e fb				ld (input_at_cursor), a 
0edb			 
0edb			 
0edb 3e 01				ld a, 1		; show cursor moving 
0edd 32 6b fb				ld (input_cur_onoff),a 
0ee0 3e 0f				ld a, CUR_BLINK_RATE 
0ee2 32 6c fb				ld (input_cur_flash), a 
0ee5			 
0ee5					; remove char 
0ee5 3a 6e fb				ld a, (input_at_cursor) 
0ee8 3c					inc a 
0ee9 11 73 0f				ld de,.iblank 
0eec cd fc 0a				call str_at_display 
0eef			 
0eef c3 7b 0d				jp .is1 
0ef2			 
0ef2 fe 0d		.isk4:		cp KEY_CR 
0ef4 28 6c				jr z, .endinput 
0ef6			 
0ef6					; else add the key press to the end 
0ef6			 
0ef6 4f					ld c, a			; save key pressed 
0ef7			 
0ef7 7e					ld a,(hl)		; get what is currently under char 
0ef8			 
0ef8 fe 00				cp 0			; we are at the end of the string 
0efa 20 2f				jr nz, .onchar 
0efc					 
0efc					; add a char to the end of the string 
0efc				 
0efc 71					ld (hl),c 
0efd 23					inc hl 
0efe			;		ld a,' ' 
0efe			;		ld (hl),a 
0efe			;		inc hl 
0efe 3e 00				ld a,0 
0f00 77					ld (hl),a 
0f01 2b					dec hl 
0f02			 
0f02 3a 61 fb				ld a, (input_cursor) 
0f05 3c					inc a				; TODO check max string length and scroll  
0f06 32 61 fb				ld (input_cursor), a		; inc cursor pos 
0f09							 
0f09 3a 6e fb				ld a, (input_at_cursor) 
0f0c 3c					inc a 
0f0d 32 6e fb				ld (input_at_cursor), a 
0f10			 
0f10 2a 75 fb				ld hl, (input_ptr) 
0f13 23					inc hl 
0f14 22 75 fb				ld (input_ptr), hl 
0f17			 
0f17 2a 75 fb				ld hl, (input_ptr) 
0f1a 23					inc hl 
0f1b 22 75 fb				ld (input_ptr), hl 
0f1e			;	if DEBUG_INPUT 
0f1e			;		push af 
0f1e			;		ld a, '+' 
0f1e			;		ld (debug_mark),a 
0f1e			;		pop af 
0f1e			;		CALLMONITOR 
0f1e			;	endif 
0f1e 3e 01				ld a, 1		; show cursor moving 
0f20 32 6b fb				ld (input_cur_onoff),a 
0f23 3e 0f				ld a, CUR_BLINK_RATE 
0f25 32 6c fb				ld (input_cur_flash), a 
0f28 c3 7b 0d				jp .is1 
0f2b					 
0f2b			 
0f2b			 
0f2b					; if on a char then insert 
0f2b			.onchar: 
0f2b			 
0f2b					; TODO over flow check: make sure insert does not blow out buffer 
0f2b			 
0f2b					; need to do some maths to use lddr 
0f2b			 
0f2b e5					push hl   ; save char pos 
0f2c c5					push bc 
0f2d			 
0f2d 2a 73 fb				ld hl, (input_start) 
0f30 3a 66 fb				ld a, (input_len) 
0f33 cd 1d 0d				call addatohl  		; end of string 
0f36 23					inc hl 
0f37 23					inc hl		; past zero term 
0f38 e5					push hl 
0f39 23					inc hl 
0f3a e5					push hl  
0f3b			 
0f3b								; start and end of lddr set, now how much to move? 
0f3b			 
0f3b							 
0f3b 3a 61 fb				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0f3e 47					ld b,a 
0f3f 3a 66 fb				ld a,(input_len) 
0f42 5f					ld e,a 
0f43 90					sub b 
0f44 3c					inc a		;?? 
0f45 3c					inc a		;?? 
0f46 3c					inc a		;?? 
0f47			 
0f47 06 00				ld b,0 
0f49 4f					ld c,a 
0f4a			 
0f4a				if DEBUG_INPUT 
0f4a					push af 
0f4a					ld a, 'i' 
0f4a					ld (debug_mark),a 
0f4a					pop af 
0f4a			;		CALLMONITOR 
0f4a				endif 
0f4a d1					pop de 
0f4b e1					pop hl 
0f4c				if DEBUG_INPUT 
0f4c					push af 
0f4c					ld a, 'I' 
0f4c					ld (debug_mark),a 
0f4c					pop af 
0f4c			;		CALLMONITOR 
0f4c				endif 
0f4c ed b8				lddr 
0f4e				 
0f4e			 
0f4e			 
0f4e					; TODO have a key for insert/overwrite mode???? 
0f4e c1					pop bc 
0f4f e1					pop hl 
0f50 71					ld (hl), c		; otherwise overwrite current char 
0f51					 
0f51			 
0f51			 
0f51			 
0f51 3a 61 fb				ld a, (input_cursor) 
0f54 3c					inc  a 		; TODO check overflow 
0f55 32 61 fb				ld (input_cursor), a 
0f58			 
0f58 3a 6e fb				ld a, (input_at_cursor) 
0f5b 3c					inc a 
0f5c 32 6e fb				ld (input_at_cursor), a 
0f5f			 
0f5f c3 7b 0d				jp .is1 
0f62			 
0f62			.endinput:	; TODO look for end of string 
0f62			 
0f62					; add trailing space for end of token 
0f62			 
0f62 2a 73 fb				ld hl, (input_start) 
0f65 3a 66 fb				ld a,(input_len) 
0f68 cd 1d 0d				call addatohl 
0f6b 3e 20				ld a, ' ' 
0f6d 77					ld (hl),a 
0f6e					; TODO eof of parse marker 
0f6e			 
0f6e 23					inc hl 
0f6f 3e 00				ld a, 0 
0f71 77					ld (hl),a 
0f72			 
0f72			 
0f72 c9					ret 
0f73			 
0f73 .. 00		.iblank: db " ",0 
0f75			 
0f75			 
0f75 32 70 fb		input_str_prev:	ld (input_at_pos), a 
0f78 22 73 fb				ld (input_start), hl 
0f7b 3e 01				ld a,1			; add cursor 
0f7d 77					ld (hl),a 
0f7e 23					inc hl 
0f7f 3e 00				ld a,0 
0f81 77					ld (hl),a 
0f82 22 75 fb				ld (input_ptr), hl 
0f85 7a					ld a,d 
0f86 32 72 fb				ld (input_size), a 
0f89 3e 00				ld a,0 
0f8b 32 61 fb				ld (input_cursor),a 
0f8e			.instr1:	 
0f8e			 
0f8e					; TODO do block cursor 
0f8e					; TODO switch cursor depending on the modifer key 
0f8e			 
0f8e					; update cursor shape change on key hold 
0f8e			 
0f8e 2a 75 fb				ld hl, (input_ptr) 
0f91 2b					dec hl 
0f92 3a d0 f8				ld a,(cursor_shape) 
0f95 77					ld (hl), a 
0f96			 
0f96					; display entered text 
0f96 3a 70 fb				ld a,(input_at_pos) 
0f99 cd ee 66		            	CALL fLCD_Pos       ;Position cursor to location in A 
0f9c ed 5b 73 fb	            	LD   de, (input_start) 
0fa0 cd 10 67		            	CALL fLCD_Str       ;Display string pointed to by DE 
0fa3			 
0fa3 cd 2a 69				call cin 
0fa6 fe 00				cp 0 
0fa8 28 e4				jr z, .instr1 
0faa			 
0faa					; proecess keyboard controls first 
0faa			 
0faa 2a 75 fb				ld hl,(input_ptr) 
0fad			 
0fad fe 0d				cp KEY_CR	 ; pressing enter ends input 
0faf 28 5a				jr z, .instrcr 
0fb1			 
0fb1 fe 08				cp KEY_BS 	; back space 
0fb3 20 0f				jr nz, .instr2 
0fb5					; process back space 
0fb5			 
0fb5					; TODO stop back space if at start of string 
0fb5 2b					dec hl 
0fb6 2b					dec hl ; to over write cursor 
0fb7 3a d0 f8				ld a,(cursor_shape) 
0fba					;ld a,0 
0fba 77					ld (hl),a 
0fbb 23					inc hl 
0fbc 3e 20				ld a," " 
0fbe 77					ld (hl),a 
0fbf 22 75 fb				ld (input_ptr),hl 
0fc2					 
0fc2			 
0fc2 18 ca				jr .instr1 
0fc4			 
0fc4 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
0fc6 20 06				jr nz, .instr3 
0fc8 2b					dec hl 
0fc9 22 75 fb				ld (input_ptr),hl 
0fcc 18 c0				jr .instr1 
0fce				 
0fce fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
0fd0 20 06				jr nz, .instr4 
0fd2 23					inc hl 
0fd3 22 75 fb				ld (input_ptr),hl 
0fd6 18 b6				jr .instr1 
0fd8			 
0fd8 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
0fda 20 06				jr nz, .instr5 
0fdc 2b					dec hl 
0fdd 22 75 fb				ld (input_ptr),hl 
0fe0 18 ac				jr .instr1 
0fe2			 
0fe2 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
0fe4 20 06				jr nz, .instr6 
0fe6 2b					dec hl 
0fe7 22 75 fb				ld (input_ptr),hl 
0fea 18 a2				jr .instr1 
0fec fe 05		.instr6:        cp KEY_UP      ; recall last command 
0fee 20 0b				jr nz, .instrnew 
0ff0			 
0ff0 21 1d ee			ld hl, scratch 
0ff3 11 43 f2			ld de, os_last_cmd 
0ff6 cd 14 10			call strcpy 
0ff9 18 93				jr .instr1 
0ffb			 
0ffb			 
0ffb			.instrnew:	; no special key pressed to see if we have room to store it 
0ffb			 
0ffb					; TODO do string size test 
0ffb			 
0ffb 2b					dec hl ; to over write cursor 
0ffc 77					ld (hl),a 
0ffd 23					inc hl 
0ffe 3a d0 f8				ld a,(cursor_shape) 
1001 77					ld (hl),a 
1002 23					inc hl 
1003 3e 00				ld a,0 
1005 77					ld (hl),a 
1006			 
1006 22 75 fb				ld (input_ptr),hl 
1009					 
1009 18 83				jr .instr1 
100b 2b			.instrcr:	dec hl		; remove cursor 
100c 3e 20				ld a,' '	; TODO add a trailing space for safety 
100e 77					ld (hl),a 
100f 23					inc hl 
1010 3e 00				ld a,0 
1012 77					ld (hl),a 
1013			 
1013			 
1013					; if at end of line scroll up    
1013					; TODO detecting only end of line 4 for scroll up  
1013			 
1013					;ld   
1013			 
1013 c9					ret 
1014			 
1014			 
1014			; strcpy hl = dest, de source 
1014			 
1014 1a			strcpy:   LD   A, (DE)        ;Get character from string 
1015 b7			            OR   A              ;Null terminator? 
1016 c8			            RET  Z              ;Yes, so finished 
1017 1a					ld a,(de) 
1018 77					ld (hl),a 
1019 13			            INC  DE             ;Point to next character 
101a 23					inc hl 
101b 18 f7		            JR   strcpy       ;Repeat 
101d c9					ret 
101e			 
101e			 
101e			; TODO string_at  
101e			; pass string which starts with lcd offset address and then null term string 
101e			 
101e			; TODO string to dec 
101e			; TODO string to hex 
101e			; TODO byte to string hex 
101e			; TODO byte to string dec 
101e			 
101e			 
101e			 
101e			; from z80uartmonitor 
101e			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
101e			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
101e			; pass hl for where to put the text 
101e			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
101e c5			hexout:	PUSH BC 
101f f5					PUSH AF 
1020 47					LD B, A 
1021					; Upper nybble 
1021 cb 3f				SRL A 
1023 cb 3f				SRL A 
1025 cb 3f				SRL A 
1027 cb 3f				SRL A 
1029 cd 39 10				CALL tohex 
102c 77					ld (hl),a 
102d 23					inc hl	 
102e					 
102e					; Lower nybble 
102e 78					LD A, B 
102f e6 0f				AND 0FH 
1031 cd 39 10				CALL tohex 
1034 77					ld (hl),a 
1035 23					inc hl	 
1036					 
1036 f1					POP AF 
1037 c1					POP BC 
1038 c9					RET 
1039					 
1039			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1039			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
1039			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1039			tohex: 
1039 e5					PUSH HL 
103a d5					PUSH DE 
103b 16 00				LD D, 0 
103d 5f					LD E, A 
103e 21 46 10				LD HL, .DATA 
1041 19					ADD HL, DE 
1042 7e					LD A, (HL) 
1043 d1					POP DE 
1044 e1					POP HL 
1045 c9					RET 
1046			 
1046			.DATA: 
1046 30					DEFB	30h	; 0 
1047 31					DEFB	31h	; 1 
1048 32					DEFB	32h	; 2 
1049 33					DEFB	33h	; 3 
104a 34					DEFB	34h	; 4 
104b 35					DEFB	35h	; 5 
104c 36					DEFB	36h	; 6 
104d 37					DEFB	37h	; 7 
104e 38					DEFB	38h	; 8 
104f 39					DEFB	39h	; 9 
1050 41					DEFB	41h	; A 
1051 42					DEFB	42h	; B 
1052 43					DEFB	43h	; C 
1053 44					DEFB	44h	; D 
1054 45					DEFB	45h	; E 
1055 46					DEFB	46h	; F 
1056			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1056			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1056			;;    subtract $30, if result > 9 then subtract $7 more 
1056			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1056			atohex: 
1056 d6 30				SUB $30 
1058 fe 0a				CP 10 
105a f8					RET M		; If result negative it was 0-9 so we're done 
105b d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
105d c9					RET		 
105e			 
105e			 
105e			 
105e			 
105e			; Get 2 ASCII characters as hex byte from pointer in hl 
105e			 
105e			BYTERD: 
105e 16 00			LD	D,00h		;Set up 
1060 cd 68 10			CALL	HEXCON		;Get byte and convert to hex 
1063 87				ADD	A,A		;First nibble so 
1064 87				ADD	A,A		;multiply by 16 
1065 87				ADD	A,A		; 
1066 87				ADD	A,A		; 
1067 57				LD	D,A		;Save hi nibble in D 
1068			HEXCON: 
1068 7e				ld a, (hl)		;Get next chr 
1069 23				inc hl 
106a d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
106c fe 0a			CP	00Ah		;Is it 0-9 ? 
106e 38 02			JR	C,NALPHA	;If so miss next bit 
1070 d6 07			SUB	007h		;Else convert alpha 
1072			NALPHA: 
1072 b2				OR	D		;Add hi nibble back 
1073 c9				RET			; 
1074			 
1074			 
1074			; 
1074			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
1074			; Since the routines get_byte and therefore get_nibble are called, only valid 
1074			; characters (0-9a-f) are accepted. 
1074			; 
1074			;get_word        push    af 
1074			;                call    get_byte        ; Get the upper byte 
1074			;                ld      h, a 
1074			;                call    get_byte        ; Get the lower byte 
1074			;                ld      l, a 
1074			;                pop     af 
1074			;                ret 
1074			; 
1074			; Get a byte in hexadecimal notation. The result is returned in A. Since 
1074			; the routine get_nibble is used only valid characters are accepted - the  
1074			; input routine only accepts characters 0-9a-f. 
1074			; 
1074 c5			get_byte:        push    bc              ; Save contents of B (and C) 
1075 7e					ld a,(hl) 
1076 23					inc hl 
1077 cd 9c 10		                call    nibble2val      ; Get upper nibble 
107a cb 07		                rlc     a 
107c cb 07		                rlc     a 
107e cb 07		                rlc     a 
1080 cb 07		                rlc     a 
1082 47			                ld      b, a            ; Save upper four bits 
1083 7e					ld a,(hl) 
1084 cd 9c 10		                call    nibble2val      ; Get lower nibble 
1087 b0			                or      b               ; Combine both nibbles 
1088 c1			                pop     bc              ; Restore B (and C) 
1089 c9			                ret 
108a			; 
108a			; Get a hexadecimal digit from the serial line. This routine blocks until 
108a			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
108a			; to the serial line interface. The lower 4 bits of A contain the value of  
108a			; that particular digit. 
108a			; 
108a			;get_nibble      ld a,(hl)           ; Read a character 
108a			;                call    to_upper        ; Convert to upper case 
108a			;                call    is_hex          ; Was it a hex digit? 
108a			;                jr      nc, get_nibble  ; No, get another character 
108a			 ;               call    nibble2val      ; Convert nibble to value 
108a			 ;               call    print_nibble 
108a			 ;               ret 
108a			; 
108a			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
108a			; A valid hexadecimal digit is denoted by a set C flag. 
108a			; 
108a			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
108a			;                ret     nc              ; Yes 
108a			;                cp      '0'             ; Less than '0'? 
108a			;                jr      nc, is_hex_1    ; No, continue 
108a			;                ccf                     ; Complement carry (i.e. clear it) 
108a			;                ret 
108a			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
108a			;                ret     c               ; Yes 
108a			;                cp      'A'             ; Less than 'A'? 
108a			;                jr      nc, is_hex_2    ; No, continue 
108a			;                ccf                     ; Yes - clear carry and return 
108a			;                ret 
108a			;is_hex_2        scf                     ; Set carry 
108a			;                ret 
108a			; 
108a			; Convert a single character contained in A to upper case: 
108a			; 
108a fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
108c d8			                ret     c 
108d fe 7b		                cp      'z' + 1         ; > 'z'? 
108f d0			                ret     nc              ; Nothing to do, either 
1090 e6 5f		                and     $5f             ; Convert to upper case 
1092 c9			                ret 
1093			 
1093			 
1093			to_lower: 
1093			 
1093			   ; if char is in [A-Z] make it lower case 
1093			 
1093			   ; enter : a = char 
1093			   ; exit  : a = lower case char 
1093			   ; uses  : af 
1093			 
1093 fe 41		   cp 'A' 
1095 d8			   ret c 
1096			    
1096 fe 5b		   cp 'Z'+1 
1098 d0			   ret nc 
1099			    
1099 f6 20		   or $20 
109b c9			   ret 
109c			 
109c			; 
109c			; Expects a hexadecimal digit (upper case!) in A and returns the 
109c			; corresponding value in A. 
109c			; 
109c fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
109e 38 02		                jr      c, nibble2val_1 ; Yes 
10a0 d6 07		                sub     7               ; Adjust for A-F 
10a2 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
10a4 e6 0f		                and     $f              ; Only return lower 4 bits 
10a6 c9			                ret 
10a7			; 
10a7			; Print_nibble prints a single hex nibble which is contained in the lower  
10a7			; four bits of A: 
10a7			; 
10a7			;print_nibble    push    af              ; We won't destroy the contents of A 
10a7			;                and     $f              ; Just in case... 
10a7			;                add     a, '0'             ; If we have a digit we are done here. 
10a7			;                cp      '9' + 1         ; Is the result > 9? 
10a7			;                jr      c, print_nibble_1 
10a7			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
10a7			;print_nibble_1  call    putc            ; Print the nibble and 
10a7			;                pop     af              ; restore the original value of A 
10a7			;                ret 
10a7			;; 
10a7			;; Send a CR/LF pair: 
10a7			; 
10a7			;crlf            push    af 
10a7			;                ld      a, cr 
10a7			;                call    putc 
10a7			;                ld      a, lf 
10a7			;                call    putc 
10a7			;                pop     af 
10a7			;                ret 
10a7			; 
10a7			; Print_word prints the four hex digits of a word to the serial line. The  
10a7			; word is expected to be in HL. 
10a7			; 
10a7			;print_word      push    hl 
10a7			;                push    af 
10a7			;                ld      a, h 
10a7			;                call    print_byte 
10a7			;                ld      a, l 
10a7			;                call    print_byte 
10a7			;                pop     af 
10a7			;                pop     hl 
10a7			;                ret 
10a7			; 
10a7			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
10a7			; The byte to be printed is expected to be in A. 
10a7			; 
10a7			;print_byte      push    af              ; Save the contents of the registers 
10a7			;                push    bc 
10a7			;                ld      b, a 
10a7			;                rrca 
10a7			;                rrca 
10a7			;                rrca 
10a7			;                rrca 
10a7			;                call    print_nibble    ; Print high nibble 
10a7			;                ld      a, b 
10a7			;                call    print_nibble    ; Print low nibble 
10a7			;                pop     bc              ; Restore original register contents 
10a7			;                pop     af 
10a7			;                ret 
10a7			 
10a7			 
10a7			 
10a7			 
10a7			 
10a7			fourehexhl:  
10a7 7e				ld a,(hl) 
10a8 cd 56 10			call atohex 
10ab cb 3f				SRL A 
10ad cb 3f				SRL A 
10af cb 3f				SRL A 
10b1 cb 3f				SRL A 
10b3 47				ld b, a 
10b4 23				inc hl 
10b5 7e				ld a,(hl) 
10b6 23				inc hl 
10b7 cd 56 10			call atohex 
10ba 80				add b 
10bb 57				ld d,a 
10bc 7e				ld a,(hl) 
10bd cd 56 10			call atohex 
10c0 cb 3f				SRL A 
10c2 cb 3f				SRL A 
10c4 cb 3f				SRL A 
10c6 cb 3f				SRL A 
10c8 47				ld b, a 
10c9 23				inc hl 
10ca 7e				ld a,(hl) 
10cb 23				inc hl 
10cc cd 56 10			call atohex 
10cf 80				add b 
10d0 5f				ld e, a 
10d1 d5				push de 
10d2 e1				pop hl 
10d3 c9				ret 
10d4			 
10d4			; pass hl. returns z set if the byte at hl is a digit 
10d4			;isdigithl:  
10d4			;	push bc 
10d4			;	ld a,(hl) 
10d4			;	cp ':' 
10d4			;	jr nc, .isdf 		; > 
10d4			;	cp '0' 
10d4			;	jr c, .isdf		; < 
10d4			; 
10d4			;	; TODO find a better way to set z 
10d4			; 
10d4			;	ld b,a 
10d4			;	cp b 
10d4			;	pop bc 
10d4			;	ret 
10d4			; 
10d4			;.isdf:	; not digit so clear z 
10d4			; 
10d4			;	; TODO find a better way to unset z 
10d4			; 
10d4			;	ld b,a 
10d4			;	inc b 
10d4			;	cp b 
10d4			; 
10d4			;	pop bc 
10d4			;	ret 
10d4				 
10d4				 
10d4			 
10d4			 
10d4			; pass hl as the four byte address to load 
10d4			 
10d4			get_word_hl:  
10d4 e5				push hl 
10d5 cd 74 10			call get_byte 
10d8				 
10d8 47				ld b, a 
10d9			 
10d9 e1				pop hl 
10da 23				inc hl 
10db 23				inc hl 
10dc			 
10dc			; TODO not able to handle a-f  
10dc 7e				ld a,(hl) 
10dd			;	;cp ':' 
10dd			;	cp 'g' 
10dd			;	jr nc, .single_byte_hl 		; > 
10dd			;	cp 'G' 
10dd			;	jr nc, .single_byte_hl 		; > 
10dd			;	cp '0' 
10dd			;	jr c, .single_byte_hl		; < 
10dd			 
10dd				;call isdigithl 
10dd fe 00			cp 0 
10df 28 06			jr z, .single_byte_hl 
10e1			 
10e1			.getwhln:   ; hex word so get next byte 
10e1			 
10e1 cd 74 10			call get_byte 
10e4 6f				ld l, a 
10e5 60				ld h,b 
10e6 c9				ret 
10e7 68			.single_byte_hl:   ld l,b 
10e8 26 00				ld h,0 
10ea c9					ret 
10eb			 
10eb			 
10eb			 
10eb			 
10eb 21 01 1a			ld hl,asc+1 
10ee			;	ld a, (hl) 
10ee			;	call nibble2val 
10ee cd 74 10			call get_byte 
10f1			 
10f1			;	call fourehexhl 
10f1 32 51 ee			ld (scratch+52),a 
10f4				 
10f4 21 4f ee			ld hl,scratch+50 
10f7 22 40 f1			ld (os_cur_ptr),hl 
10fa			 
10fa c9				ret 
10fb			 
10fb			 
10fb			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
10fb			 
10fb			; Decimal Unsigned Version 
10fb			 
10fb			;Number in a to decimal ASCII 
10fb			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
10fb			;Example: display a=56 as "056" 
10fb			;input: a = number 
10fb			;Output: a=0,value of a in the screen 
10fb			;destroys af,bc (don't know about hl and de) 
10fb			DispAToASCII: 
10fb 0e 9c			ld	c,-100 
10fd cd 07 11			call	.Na1 
1100 0e f6			ld	c,-10 
1102 cd 07 11			call	.Na1 
1105 0e ff			ld	c,-1 
1107 06 2f		.Na1:	ld	b,'0'-1 
1109 04			.Na2:	inc	b 
110a 81				add	a,c 
110b 38 fc			jr	c,.Na2 
110d 91				sub	c		;works as add 100/10/1 
110e f5				push af		;safer than ld c,a 
110f 78				ld	a,b		;char is in b 
1110			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
1110 f1				pop af		;safer than ld a,c 
1111 c9				ret 
1112			 
1112			; Decimal Signed Version 
1112			 
1112			; DispA 
1112			; -------------------------------------------------------------- 
1112			; Converts a signed integer value to a zero-terminated ASCII 
1112			; string representative of that value (using radix 10). 
1112			; -------------------------------------------------------------- 
1112			; INPUTS: 
1112			;     HL     Value to convert (two's complement integer). 
1112			;     DE     Base address of string destination. (pointer). 
1112			; -------------------------------------------------------------- 
1112			; OUTPUTS: 
1112			;     None 
1112			; -------------------------------------------------------------- 
1112			; REGISTERS/MEMORY DESTROYED 
1112			; AF HL 
1112			; -------------------------------------------------------------- 
1112			 
1112			;DispHLToASCII: 
1112			;   push    de 
1112			;   push    bc 
1112			; 
1112			;; Detect sign of HL. 
1112			;    bit    7, h 
1112			;    jr     z, ._DoConvert 
1112			; 
1112			;; HL is negative. Output '-' to string and negate HL. 
1112			;    ld     a, '-' 
1112			;    ld     (de), a 
1112			;    inc    de 
1112			; 
1112			;; Negate HL (using two's complement) 
1112			;    xor    a 
1112			;    sub    l 
1112			;    ld     l, a 
1112			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
1112			;    sbc    a, h 
1112			;    ld     h, a 
1112			; 
1112			;; Convert HL to digit characters 
1112			;._DoConvert: 
1112			;    ld     b, 0     ; B will count character length of number 
1112			;-   ld     a, 10 
1112			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
1112			;    push   af 
1112			;    inc    b 
1112			;    ld     a, h 
1112			;    or     l 
1112			;    jr     nz, - 
1112			; 
1112			;; Retrieve digits from stack 
1112			;-   pop    af 
1112			;    or     $30 
1112			;    ld     (de), a 
1112			;    inc    de 
1112			;    djnz   - 
1112			; 
1112			;; Terminate string with NULL 
1112			;    xor    a 
1112			;    ld     (de), a 
1112			; 
1112			;    pop    bc 
1112			;    pop    de 
1112			;    ret 
1112			 
1112			;Comments 
1112			; 
1112			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
1112			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
1112			;    Note that the output string will not be fixed-width. 
1112			; 
1112			;Example Usage 
1112			; 
1112			;    ld    hl, -1004 
1112			;    ld    de, OP1 
1112			;    call  DispA 
1112			;    ld    hl, OP1 
1112			;    syscall  PutS 
1112			 
1112			 
1112			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
1112			 
1112			 
1112			;Converts an ASCII string to an unsigned 16-bit integer 
1112			;Quits when it reaches a non-decimal digit 
1112			 
1112			string_to_uint16: 
1112			atoui_16: 
1112			;Input: 
1112			;     DE points to the string 
1112			;Outputs: 
1112			;     HL is the result 
1112			;     A is the 8-bit value of the number 
1112			;     DE points to the byte after the number 
1112			;Destroys: 
1112			;     BC 
1112			;       if the string is non-empty, BC is HL/10 
1112			;Size:  24 bytes 
1112			;Speed: 42+d(104+{0,9}) 
1112			;       d is the number of digits in the number 
1112			;       max is 640 cycles for a 5 digit number 
1112			;Assuming no leading zeros: 
1112			;1 digit:  146cc 
1112			;2 digit:  250cc 
1112			;3 digit:  354cc or 363cc (avg: 354.126cc) 
1112			;4 digit:  458cc or 467cc (avg: 458.27cc) 
1112			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
1112			;avg: 544.81158447265625cc (544+13297/16384) 
1112			;=============================================================== 
1112 21 00 00		  ld hl,0 
1115			.u16a: 
1115 1a			  ld a,(de) 
1116 d6 30		  sub 30h 
1118 fe 0a		  cp 10 
111a d0			  ret nc 
111b 13			  inc de 
111c 44			  ld b,h 
111d 4d			  ld c,l 
111e 29			  add hl,hl 
111f 29			  add hl,hl 
1120 09			  add hl,bc 
1121 29			  add hl,hl 
1122 85			  add a,l 
1123 6f			  ld l,a 
1124 30 ef		  jr nc,.u16a 
1126 24			  inc h 
1127 c3 15 11		  jp .u16a 
112a			 
112a			 
112a			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
112a			 
112a			;written by Zeda 
112a			;Converts a 16-bit unsigned integer to an ASCII string. 
112a			 
112a			uitoa_16: 
112a			;Input: 
112a			;   DE is the number to convert 
112a			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
112a			;Output: 
112a			;   HL points to the null-terminated ASCII string 
112a			;      NOTE: This isn't necessarily the same as the input HL. 
112a d5			  push de 
112b c5			  push bc 
112c f5			  push af 
112d eb			  ex de,hl 
112e			 
112e 01 f0 d8		  ld bc,-10000 
1131 3e 2f		  ld a,'0'-1 
1133 3c			  inc a 
1134 09			  add hl,bc  
1135 38 fc		   jr c,$-2 
1137 12			  ld (de),a 
1138 13			  inc de 
1139			 
1139 01 e8 03		  ld bc,1000 
113c 3e 3a		  ld a,'9'+1 
113e 3d			  dec a  
113f 09			  add hl,bc  
1140 30 fc		   jr nc,$-2 
1142 12			  ld (de),a 
1143 13			  inc de 
1144			 
1144 01 9c ff		  ld bc,-100 
1147 3e 2f		  ld a,'0'-1 
1149 3c			  inc a  
114a 09			  add hl,bc  
114b 38 fc		   jr c,$-2 
114d 12			  ld (de),a 
114e 13			  inc de 
114f			 
114f 7d			  ld a,l 
1150 26 3a		  ld h,'9'+1 
1152 25			  dec h  
1153 c6 0a		  add a,10  
1155 30 fb		   jr nc,$-3 
1157 c6 30		  add a,'0' 
1159 eb			  ex de,hl 
115a 72			  ld (hl),d 
115b 23			  inc hl 
115c 77			  ld (hl),a 
115d 23			  inc hl 
115e 36 00		  ld (hl),0 
1160			 
1160			;Now strip the leading zeros 
1160 0e fa		  ld c,-6 
1162 09			  add hl,bc 
1163 3e 30		  ld a,'0' 
1165 23			  inc hl  
1166 be			  cp (hl)  
1167 28 fc		  jr z,$-2 
1169			 
1169			;Make sure that the string is non-empty! 
1169 7e			  ld a,(hl) 
116a b7			  or a 
116b 20 01		  jr nz,.atoub 
116d 2b			  dec hl 
116e			.atoub: 
116e			 
116e f1			  pop af 
116f c1			  pop bc 
1170 d1			  pop de 
1171 c9			  ret 
1172			 
1172			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
1172			 
1172			toUpper: 
1172			;A is the char. 
1172			;If A is a lowercase letter, this sets it to the matching uppercase 
1172			;18cc or 30cc or 41cc 
1172			;avg: 26.75cc 
1172 fe 61		  cp 'a' 
1174 d8			  ret c 
1175 fe 7b		  cp 'z'+1 
1177 d0			  ret nc 
1178 d6 20		  sub 'a'-'A' 
117a c9			  ret 
117b			 
117b			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
117b			 
117b			; String Length 
117b			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
117b			 
117b			; Get the length of the null-terminated string starting at $8000 hl 
117b			;    LD     HL, $8000 
117b			 
117b			strlenz: 
117b			 
117b af			    XOR    A               ; Zero is the value we are looking for. 
117c 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
117d 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
117e			                           ; 65, 536 bytes (the entire addressable memory space). 
117e ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1180			 
1180			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1180 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
1181 6f			    LD     L, A             ; number of bytes 
1182 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1184 2b			    DEC    HL              ; Compensate for null. 
1185 c9				ret 
1186			 
1186			; Get the length of the A terminated string starting at $8000 hl 
1186			;    LD     HL, $8000 
1186			 
1186			strlent: 
1186			 
1186			                  ; A is the value we are looking for. 
1186 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1188 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
118a			                           ; 65, 536 bytes (the entire addressable memory space). 
118a ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
118c			 
118c			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
118c 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
118e 2e 00		    LD     L, 0             ; number of bytes 
1190 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1192 2b			    DEC    HL              ; Compensate for null. 
1193 c9				ret 
1194			 
1194			 
1194			;Comparing Strings 
1194			 
1194			;IN    HL     Address of string1. 
1194			;      DE     Address of string2. 
1194			 
1194			; doc given but wrong??? 
1194			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
1194			;      carry  Set if string1 > string2, reset if string1 <= string2. 
1194			; tested 
1194			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
1194			 
1194			strcmp_old: 
1194 e5			    PUSH   HL 
1195 d5			    PUSH   DE 
1196			 
1196 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1197 be			    CP     (HL)            ; (want to minimize work). 
1198 38 01		    JR     C, Str1IsBigger 
119a 7e			    LD     A, (HL) 
119b			 
119b			Str1IsBigger: 
119b 4f			    LD     C, A             ; Put length in BC 
119c 06 00		    LD     B, 0 
119e 13			    INC    DE              ; Increment pointers to meat of string. 
119f 23			    INC    HL 
11a0			 
11a0			CmpLoop: 
11a0 1a			    LD     A, (DE)          ; Compare bytes. 
11a1 ed a1		    CPI 
11a3 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
11a5 13			    INC    DE              ; Update pointer. 
11a6 ea a0 11		    JP     PE, CmpLoop 
11a9			 
11a9 d1			    POP    DE 
11aa e1			    POP    HL 
11ab 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
11ac be			    CP     (HL) 
11ad c9			    RET 
11ae			 
11ae			NoMatch: 
11ae 2b			    DEC    HL 
11af be			    CP     (HL)            ; Compare again to affect carry. 
11b0 d1			    POP    DE 
11b1 e1			    POP    HL 
11b2 c9			    RET 
11b3			 
11b3			;; test strmp 
11b3			; 
11b3			;ld de, .str1 
11b3			;ld hl, .str2 
11b3			;call strcmp 
11b3			;jr z, .z1 
11b3			;;this 
11b3			;	if DEBUG_FORTH_WORDS 
11b3			;		DMARK "NZ1" 
11b3			;		CALLMONITOR 
11b3			;	endif 
11b3			;.z1: 
11b3			; 
11b3			;	if DEBUG_FORTH_WORDS 
11b3			;		DMARK "ZZ1" 
11b3			;		CALLMONITOR 
11b3			;	endif 
11b3			; 
11b3			;ld de, .str1 
11b3			;ld hl, .str1 
11b3			;call strcmp 
11b3			;jr z, .z2 
11b3			;;this 
11b3			;	if DEBUG_FORTH_WORDS 
11b3			;		DMARK "NZ2" 
11b3			;		CALLMONITOR 
11b3			;	endif 
11b3			;.z2: 
11b3			; 
11b3			;	if DEBUG_FORTH_WORDS 
11b3			;		DMARK "ZZ2" 
11b3			;		CALLMONITOR 
11b3			;	endif 
11b3			; 
11b3			;ld de, .str1 
11b3			;ld hl, .str2 
11b3			;call strcmp 
11b3			;jr c, .c1 
11b3			; 
11b3			;	if DEBUG_FORTH_WORDS 
11b3			;		DMARK "Nc1" 
11b3			;		CALLMONITOR 
11b3			;	endif 
11b3			;.c1: 
11b3			;;this 
11b3			;	if DEBUG_FORTH_WORDS 
11b3			;		DMARK "cc1" 
11b3			;		CALLMONITOR 
11b3			;	endif 
11b3			; 
11b3			;ld de, .str1 
11b3			;ld hl, .str1 
11b3			;call strcmp 
11b3			;jr c, .c2 
11b3			;;this 
11b3			;	if DEBUG_FORTH_WORDS 
11b3			;		DMARK "Nc2" 
11b3			;		CALLMONITOR 
11b3			;	endif 
11b3			;.c2: 
11b3			; 
11b3			;	if DEBUG_FORTH_WORDS 
11b3			;		DMARK "cc2" 
11b3			;		CALLMONITOR 
11b3			;	endif 
11b3			;	NEXTW 
11b3			;.str1:   db "string1",0 
11b3			;.str2:   db "string2",0 
11b3			 
11b3			; only care about direct match or not 
11b3			; hl and de strings 
11b3			; zero set if the same 
11b3			 
11b3			strcmp: 
11b3 1a				ld a, (de) 
11b4 be				cp (hl) 
11b5 28 02			jr z, .ssame 
11b7 b7				or a 
11b8 c9				ret 
11b9			 
11b9			.ssame:  
11b9 fe 00			cp 0 
11bb c8				ret z 
11bc			 
11bc 23				inc hl 
11bd 13				inc de 
11be 18 f3			jr strcmp 
11c0				 
11c0				 
11c0			 
11c0			 
11c0			 
11c0			 
11c0			; eof 
11c0			 
11c0			 
11c0			 
11c0			 
11c0			 
11c0			 
# End of file firmware_strings.asm
11c0			include "firmware_memory.asm"   ; malloc and free  
11c0			 
11c0			if DEBUG_FORTH_MALLOC_HIGH 
11c0			.mallocsize: db "Wants malloc >256",0 
11c0			.mallocasize: db "MALLOC gives >256",0 
11c0			.malloczero: db "MALLOC gives zero",0 
11c0			 
11c0			malloc_guard_zerolen: 
11c0				push hl 
11c0				push de 
11c0				push af 
11c0			 
11c0				ld de, 0 
11c0			        call cmp16 
11c0				jr nz, .lowalloz 
11c0			 
11c0				push hl 
11c0				push de 
11c0					ld hl, display_fb0 
11c0					ld (display_fb_active), hl 
11c0				call clear_display 
11c0				ld a, 0 
11c0				ld de, .malloczero 
11c0				call str_at_display 
11c0				call update_display 
11c0				call delay1s 
11c0				call delay1s 
11c0				ld a, 0 
11c0				ld (os_view_disable), a 
11c0			 
11c0				pop de 
11c0				pop hl 
11c0			 
11c0				 
11c0			 
11c0				CALLMONITOR 
11c0			.lowalloz: 
11c0			 
11c0			 
11c0				pop af 
11c0				pop de 
11c0				pop hl 
11c0			ret 
11c0			 
11c0			malloc_guard_entry: 
11c0				push hl 
11c0				push de 
11c0				push af 
11c0			 
11c0			 	or a      ;clear carry flag 
11c0				push hl 
11c0				ld de, 255 
11c0				sbc hl, de 
11c0				jr c, .lowalloc 
11c0			 
11c0				push de 
11c0					ld hl, display_fb0 
11c0					ld (display_fb_active), hl 
11c0				call clear_display 
11c0				ld a, 0 
11c0				ld de, .mallocsize 
11c0				call str_at_display 
11c0				call update_display 
11c0				call delay1s 
11c0				call delay1s 
11c0				ld a, 0 
11c0				ld (os_view_disable), a 
11c0			 
11c0				pop de 
11c0				pop hl 
11c0			 
11c0				 
11c0			 
11c0				CALLMONITOR 
11c0				jr .lowdone 
11c0			.lowalloc: 
11c0			 
11c0			 
11c0				pop hl 
11c0			.lowdone:	pop af 
11c0				pop de 
11c0				pop hl 
11c0			ret 
11c0			 
11c0			malloc_guard_exit: 
11c0				push hl 
11c0				push de 
11c0				push af 
11c0			 
11c0			 	or a      ;clear carry flag 
11c0				push hl 
11c0				ld de, 255 
11c0				sbc hl, de 
11c0				jr c, .lowallocx 
11c0			 
11c0				push de 
11c0					ld hl, display_fb0 
11c0					ld (display_fb_active), hl 
11c0				call clear_display 
11c0				ld a, 0 
11c0				ld de, .mallocasize 
11c0				call str_at_display 
11c0				call update_display 
11c0				call delay1s 
11c0				call delay1s 
11c0				ld a, 0 
11c0				ld (os_view_disable), a 
11c0				pop de 
11c0				pop hl 
11c0			 
11c0				CALLMONITOR 
11c0				jr .lowdonex 
11c0			.lowallocx: 
11c0			 
11c0				pop hl 
11c0			.lowdonex:	pop af 
11c0				pop de 
11c0				pop hl 
11c0			ret 
11c0			endif 
11c0			 
11c0			if MALLOC_2 
11c0			; Z80 Malloc and Free Functions 
11c0			 
11c0			; Malloc Function: 
11c0			; Input: 
11c0			;   HL: Size of block to allocate 
11c0			; Output: 
11c0			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
11c0			 
11c0			malloc: 
11c0				 
11c0			if DEBUG_FORTH_MALLOC_HIGH 
11c0			call malloc_guard_entry 
11c0			endif 
11c0			 
11c0			 
11c0			 
11c0			 
11c0					if DEBUG_FORTH_MALLOC 
11c0						DMARK "mal" 
11c0						CALLMONITOR 
11c0					endif 
11c0			    push af            ; Save AF register 
11c0			    ld a, l            ; Load low byte of size into A 
11c0			    or h               ; Check if size is zero 
11c0			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
11c0			 
11c0			    ; Allocate memory 
11c0			    ld hl, (heap_start) ; Load start of heap into HL 
11c0					if DEBUG_FORTH_MALLOC 
11c0						DMARK "ma1" 
11c0						CALLMONITOR 
11c0					endif 
11c0			    call malloc_internal ; Call internal malloc function 
11c0			    pop af             ; Restore AF register 
11c0			if DEBUG_FORTH_MALLOC_HIGH 
11c0			call malloc_guard_exit 
11c0			call malloc_guard_zerolen 
11c0			endif 
11c0			    ret                ; Return 
11c0			 
11c0			; Free Function: 
11c0			; Input: 
11c0			;   HL: Pointer to memory block to free 
11c0			; Output: 
11c0			;   None 
11c0			 
11c0			free: 
11c0			    push af            ; Save AF register 
11c0			    ld a, l            ; Load low byte of pointer into A 
11c0			    or h               ; Check if pointer is NULL 
11c0			    jp z, free_exit    ; If pointer is NULL, exit 
11c0			 
11c0			    ; Free memory 
11c0			    ld hl, (heap_start) ; Load start of heap into HL 
11c0			    call free_internal  ; Call internal free function 
11c0			    pop af             ; Restore AF register 
11c0			    ret                ; Return 
11c0			 
11c0			; Internal Malloc Function: 
11c0			; Input: 
11c0			;   HL: Size of block to allocate 
11c0			; Output: 
11c0			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
11c0			 
11c0			malloc_internal: 
11c0			    ld bc, 2           ; Number of bytes to allocate for management overhead 
11c0			    add hl, bc         ; Add management overhead to requested size 
11c0			    ex de, hl          ; Save total size in DE, and keep it in HL 
11c0					if DEBUG_FORTH_MALLOC 
11c0						DMARK "ma2" 
11c0						CALLMONITOR 
11c0					endif 
11c0			 
11c0			    ; Search for free memory block 
11c0			    ld de, (heap_end)  ; Load end of heap into DE 
11c0			    ld bc, 0           ; Initialize counter 
11c0			 
11c0					if DEBUG_FORTH_MALLOC 
11c0						DMARK "ma2" 
11c0						CALLMONITOR 
11c0					endif 
11c0			malloc_search_loop: 
11c0			    ; Check if current block is free 
11c0			    ld a, (hl)         ; Load current block's status (free or used) 
11c0			    cp 0               ; Compare with zero (free) 
11c0			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
11c0			 
11c0			    ; Check if current block is large enough 
11c0			    ld a, (hl+1)       ; Load high byte of block size 
11c0			    cp l               ; Compare with low byte of requested size 
11c0			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
11c0			 
11c0			    ld a, (hl+2)       ; Load low byte of block size 
11c0			    cp h               ; Compare with high byte of requested size 
11c0			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
11c0			 
11c0			    ; Mark block as used 
11c0			    ld (hl), 0xFF      ; Set status byte to indicate used block 
11c0			 
11c0			    ; Calculate remaining space in block 
11c0			    ld bc, 0           ; Clear BC 
11c0			    add hl, bc         ; Increment HL to point to start of data block 
11c0			    add hl, de         ; HL = HL + DE (total size) 
11c0			    ld bc, 1           ; Number of bytes to allocate for management overhead 
11c0			    add hl, bc         ; Add management overhead to start of data block 
11c0			 
11c0			    ; Save pointer to allocated block in HL 
11c0			if DEBUG_FORTH_MALLOC_HIGH 
11c0						DMARK "ma5" 
11c0			call malloc_guard_exit 
11c0			call malloc_guard_zerolen 
11c0			endif 
11c0			    ret 
11c0			 
11c0			malloc_skip_block_check: 
11c0			    ; Move to the next block 
11c0			    ld bc, 3           ; Size of management overhead 
11c0			    add hl, bc         ; Move to the next block 
11c0			    inc de             ; Increment counter 
11c0			 
11c0			    ; Check if we have reached the end of heap 
11c0			    ld a, e            ; Load low byte of heap end address 
11c0			    cp (hl)            ; Compare with low byte of current address 
11c0			    jr nz, malloc_search_loop  ; If not equal, continue searching 
11c0			    ld a, d            ; Load high byte of heap end address 
11c0			    cp 0               ; Check if it's zero (end of memory) 
11c0			    jr nz, malloc_search_loop  ; If not zero, continue searching 
11c0			 
11c0			    ; If we reached here, allocation failed 
11c0			    xor a              ; Set result to NULL 
11c0			if DEBUG_FORTH_MALLOC_HIGH 
11c0						DMARK "ma6" 
11c0			call malloc_guard_exit 
11c0			call malloc_guard_zerolen 
11c0			endif 
11c0			    ret 
11c0			malloc_exit: 
11c0			if DEBUG_FORTH_MALLOC_HIGH 
11c0						DMARK "ma7" 
11c0			call malloc_guard_exit 
11c0			call malloc_guard_zerolen 
11c0			endif 
11c0			    ret 
11c0			 
11c0			; Internal Free Function: 
11c0			; Input: 
11c0			;   HL: Pointer to memory block to free 
11c0			; Output: 
11c0			;   None 
11c0			 
11c0			free_internal: 
11c0			    ld de, (heap_start) ; Load start of heap into DE 
11c0			    ld bc, 0            ; Initialize counter 
11c0			 
11c0			free_search_loop: 
11c0			    ; Check if current block contains the pointer 
11c0			    ld a, l             ; Load low byte of pointer 
11c0			    cp (hl+1)           ; Compare with high byte of current block's address 
11c0			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
11c0			    ld a, h             ; Load high byte of pointer 
11c0			    cp (hl+2)           ; Compare with low byte of current block's address 
11c0			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
11c0			 
11c0			    ; Mark block as free 
11c0			    ld (hl), 0          ; Set status byte to indicate free block 
11c0			    ret                 ; Return 
11c0			 
11c0			free_skip_block_check: 
11c0			    ; Move to the next block 
11c0			    ld bc, 3            ; Size of management overhead 
11c0			    add hl, bc          ; Move to the next block 
11c0			    inc de              ; Increment counter 
11c0			 
11c0			    ; Check if we have reached the end of heap 
11c0			    ld a, e             ; Load low byte of heap end address 
11c0			    cp (hl)             ; Compare with low byte of current address 
11c0			    jr nz, free_search_loop  ; If not equal, continue searching 
11c0			    ld a, d             ; Load high byte of heap end address 
11c0			    cp 0                ; Check if it's zero (end of memory) 
11c0			    jr nz, free_search_loop  ; If not zero, continue searching 
11c0			 
11c0			    ; If we reached here, pointer is not found in heap 
11c0			    ret 
11c0			 
11c0			free_exit: 
11c0			    ret                 ; Return 
11c0			 
11c0			; Define heap start and end addresses 
11c0			;heap_start:    .dw 0xC000   ; Start of heap 
11c0			;heap_end:      .dw 0xE000   ; End of heap 
11c0			 
11c0			endif 
11c0			 
11c0			 
11c0			if MALLOC_1 
11c0			 
11c0			 
11c0			 
11c0			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
11c0			 
11c0			;moved to firmware.asm 
11c0			;heap_start        .equ  0x9000      ; Starting address of heap 
11c0			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
11c0			 
11c0			;      .org 0 
11c0			;      jp    main 
11c0			 
11c0			 
11c0			;      .org  0x100 
11c0			;main: 
11c0			;      ld    HL, 0x8100 
11c0			;      ld    SP, HL 
11c0			; 
11c0			;      call  heap_init 
11c0			; 
11c0			;      ; Make some allocations 
11c0			;      ld    HL, 12 
11c0			;      call  malloc            ; Allocates 0x9004 
11c0			; 
11c0			;      ld    HL, 12 
11c0			;      call  malloc            ; Allocates 0x9014 
11c0			; 
11c0			;      ld    HL, 12 
11c0			;      call  malloc            ; Allocates 0x9024 
11c0			; 
11c0			;      ; Free some allocations 
11c0			;      ld    HL, 0x9014 
11c0			;      call  free 
11c0			; 
11c0			;      ld    HL, 0x9004 
11c0			;      call  free 
11c0			; 
11c0			;      ld    HL, 0x9024 
11c0			;      call  free 
11c0			; 
11c0			; 
11c0			;      halt 
11c0			 
11c0			 
11c0			;------------------------------------------------------------------------------ 
11c0			;     heap_init                                                               : 
11c0			;                                                                             : 
11c0			; Description                                                                 : 
11c0			;     Initialise the heap and make it ready for malloc and free operations.   : 
11c0			;                                                                             : 
11c0			;     The heap is maintained as a linked list, starting with an initial       : 
11c0			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
11c0			;     the first free block in the heap. Each block then points to the next    : 
11c0			;     free block within the heap, and the free list ends at the first block   : 
11c0			;     with a null pointer to the next free block.                             : 
11c0			;                                                                             : 
11c0			; Parameters                                                                  : 
11c0			;     Inputs are compile-time only. Two defines which specify the starting    : 
11c0			;     address of the heap and its size are required, along with a memory      : 
11c0			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
11c0			;     principally stores a pointer to the first free block in the heap.       : 
11c0			;                                                                             : 
11c0			; Returns                                                                     : 
11c0			;     Nothing                                                                 : 
11c0			;------------------------------------------------------------------------------ 
11c0			heap_init: 
11c0 e5			      push  HL 
11c1			 
11c1			      ; Initialise free list struct 
11c1 21 0e 80		      ld    HL, heap_start 
11c4 22 0a 80		      ld    (free_list), HL 
11c7 21 00 00		      ld    HL, 0 
11ca 22 0c 80		      ld    (free_list+2), HL 
11cd			 
11cd			      ; Insert first free block at bottom of heap, consumes entire heap 
11cd 21 ff ed		      ld    HL, heap_start+heap_size-4 
11d0 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
11d3 21 f1 6d		      ld    HL, heap_size-4 
11d6 22 10 80		      ld    (heap_start+2), HL      ; Block size 
11d9			 
11d9			      ; Insert end of free list block at top of heap - two null words will 
11d9			      ; terminate the free list 
11d9 21 00 00		      ld    HL, 0 
11dc 22 01 ee		      ld    (heap_start+heap_size-2), HL 
11df 22 ff ed		      ld    (heap_start+heap_size-4), HL 
11e2			 
11e2 e1			      pop   HL 
11e3			 
11e3 c9			      ret 
11e4			 
11e4			 
11e4			;------------------------------------------------------------------------------ 
11e4			;     malloc                                                                  : 
11e4			;                                                                             : 
11e4			; Description                                                                 : 
11e4			;     Allocates the wanted space from the heap and returns the address of the : 
11e4			;     first useable byte of the allocation.                                   : 
11e4			;                                                                             : 
11e4			;     Allocations can happen in one of two ways:                              : 
11e4			;                                                                             : 
11e4			;     1. A free block may be found which is the exact size wanted. In this    : 
11e4			;        case the block is removed from the free list and retuedn to the      : 
11e4			;        caller.                                                              : 
11e4			;     2. A free block may be found which is larger than the size wanted. In   : 
11e4			;        this case, the larger block is split into two. The first portion of  : 
11e4			;        this block will become the requested space by the malloc call and    : 
11e4			;        is returned to the caller. The second portion becomes a new free     : 
11e4			;        block, and the free list is adjusted to maintain continuity via this : 
11e4			;        newly created block.                                                 : 
11e4			;                                                                             : 
11e4			;     malloc does not set any initial value in the allocated space, the       : 
11e4			;     caller is required to do this as required.                              : 
11e4			;                                                                             : 
11e4			;     This implementation of malloc uses the stack exclusively, and is        : 
11e4			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
11e4			;     advisable to disable interrupts before calling malloc, and recommended  : 
11e4			;     to avoid the use of malloc inside ISRs in general.                      : 
11e4			;                                                                             : 
11e4			;     NOTE: heap_init must be called before malloc and free can be used.      : 
11e4			;                                                                             : 
11e4			; Parameters                                                                  : 
11e4			;     HL  Number of bytes wanted                                              : 
11e4			;                                                                             : 
11e4			; Returns                                                                     : 
11e4			;     HL  Address of the first useable byte of the allocation                 : 
11e4			;                                                                             : 
11e4			; Flags                                                                       : 
11e4			;     Z   Set if the allocation did not succeed, clear otherwise              : 
11e4			;                                                                             : 
11e4			; Stack frame                                                                 : 
11e4			;       |             |                                                       : 
11e4			;       +-------------+                                                       : 
11e4			;       |     BC      |                                                       : 
11e4			;       +-------------+                                                       : 
11e4			;       |     DE      |                                                       : 
11e4			;       +-------------+                                                       : 
11e4			;       |     IX      |                                                       : 
11e4			;       +-------------+                                                       : 
11e4			;       |  prev_free  |                                                       : 
11e4			;   +4  +-------------+                                                       : 
11e4			;       |  this_free  |                                                       : 
11e4			;   +2  +-------------+                                                       : 
11e4			;       |  next_free  |                                                       : 
11e4			;   +0  +-------------+                                                       : 
11e4			;       |             |                                                       : 
11e4			;                                                                             : 
11e4			;------------------------------------------------------------------------------ 
11e4			 
11e4			 
11e4			;malloc: 
11e4			; 
11e4			;	SAVESP ON 1 
11e4			; 
11e4			;	call malloc_code 
11e4			; 
11e4			;	CHECKSP ON 1 
11e4			;	ret 
11e4			 
11e4			 
11e4			malloc: 
11e4 c5			      push  BC 
11e5 d5			      push  DE 
11e6 dd e5		      push  IX 
11e8			if DEBUG_FORTH_MALLOC_HIGH 
11e8			call malloc_guard_entry 
11e8			endif 
11e8			 
11e8					if DEBUG_FORTH_MALLOC 
11e8						DMARK "mal" 
11e8						CALLMONITOR 
11e8					endif 
11e8 7c			      ld    A, H                    ; Exit if no space requested 
11e9 b5			      or    L 
11ea ca a9 12		      jp    Z, malloc_early_exit 
11ed			 
11ed			;inc hl 
11ed			;inc hl 
11ed			;inc hl 
11ed			; 
11ed			;inc hl 
11ed			;inc hl 
11ed			;inc hl 
11ed			;inc hl 
11ed			;inc hl 
11ed			;inc hl 
11ed			;inc hl 
11ed			;inc hl 
11ed			;inc hl 
11ed			 
11ed			 
11ed			 
11ed			 
11ed					if DEBUG_FORTH_MALLOC 
11ed						DMARK "maA" 
11ed						CALLMONITOR 
11ed					endif 
11ed			      ; Set up stack frame 
11ed eb			      ex    DE, HL 
11ee 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
11f1 39			      add   HL, SP 
11f2 f9			      ld    SP, HL 
11f3 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
11f7 dd 39		      add   IX, SP 
11f9			 
11f9			      ; Setup initial state 
11f9 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
11fc 19			      add   HL, DE 
11fd			 
11fd 44			      ld    B, H                    ; Move want to BC 
11fe 4d			      ld    C, L 
11ff			 
11ff 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
1202 dd 75 04		      ld    (IX+4), L 
1205 dd 74 05		      ld    (IX+5), H 
1208			 
1208 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
1209 23			      inc   HL 
120a 56			      ld    D, (HL) 
120b dd 73 02		      ld    (IX+2), E 
120e dd 72 03		      ld    (IX+3), D 
1211 eb			      ex    DE, HL                  ; this_free ptr into HL 
1212			 
1212					if DEBUG_FORTH_MALLOC 
1212						DMARK "maB" 
1212						CALLMONITOR 
1212					endif 
1212			      ; Loop through free block list to find some space 
1212			malloc_find_space: 
1212 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
1213 23			      inc   HL 
1214 56			      ld    D, (HL) 
1215			 
1215 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1216 b3			      or    E 
1217 ca a3 12		      jp    Z, malloc_no_space 
121a			 
121a dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
121d dd 72 01		      ld    (IX+1), D 
1220			 
1220			      ; Does this block have enough space to make the allocation? 
1220 23			      inc   HL                      ; Load free block size into DE 
1221 5e			      ld    E, (HL) 
1222 23			      inc   HL 
1223 56			      ld    D, (HL) 
1224			 
1224 eb			      ex    DE, HL                  ; Check size of block against want 
1225 b7			      or    A                       ; Ensure carry flag clear 
1226 ed 42		      sbc   HL, BC 
1228 e5			      push  HL                      ; Store the result for later (new block size) 
1229			 
1229 ca 78 12		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
122c 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
122e			 
122e			      ; this_free block is not big enough, setup ptrs to test next free block 
122e e1			      pop   HL                      ; Discard previous result 
122f			 
122f dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1232 dd 66 03		      ld    H, (IX+3) 
1235 dd 75 04		      ld    (IX+4), L 
1238 dd 74 05		      ld    (IX+5), H 
123b			 
123b dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
123e dd 66 01		      ld    H, (IX+1) 
1241 dd 75 02		      ld    (IX+2), L 
1244 dd 74 03		      ld    (IX+3), H 
1247			 
1247					if DEBUG_FORTH_MALLOC 
1247						DMARK "MA>" 
1247						CALLMONITOR 
1247					endif 
1247 18 c9		      jr    malloc_find_space 
1249			 
1249			      ; split a bigger block into two - requested size and remaining size 
1249			malloc_alloc_split: 
1249					if DEBUG_FORTH_MALLOC 
1249						DMARK "MAs" 
1249						CALLMONITOR 
1249					endif 
1249 eb			      ex    DE, HL                  ; Calculate address of new free block 
124a 2b			      dec   HL 
124b 2b			      dec   HL 
124c 2b			      dec   HL 
124d 09			      add   HL, BC 
124e			 
124e			      ; Create a new block and point it at next_free 
124e dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
1251 dd 56 01		      ld    D, (IX+1) 
1254			 
1254 73			      ld    (HL), E                 ; Store next_free ptr into new block 
1255 23			      inc   HL 
1256 72			      ld    (HL), D 
1257			 
1257 d1			      pop   DE                      ; Store size of new block into new block 
1258 23			      inc   HL 
1259 73			      ld    (HL), E 
125a 23			      inc   HL 
125b 72			      ld    (HL), D 
125c			 
125c			      ; Update this_free ptr to point to new block 
125c 2b			      dec   HL 
125d 2b			      dec   HL 
125e 2b			      dec   HL 
125f			 
125f dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1262 dd 56 03		      ld    D, (IX+3) 
1265			 
1265 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1268 dd 74 03		      ld    (IX+3), H 
126b			 
126b			      ; Modify this_free block to be allocation 
126b eb			      ex    DE, HL 
126c af			      xor   A                       ; Null the next block ptr of allocated block 
126d 77			      ld    (HL), A 
126e 23			      inc   HL 
126f 77			      ld    (HL), A 
1270			 
1270 23			      inc   HL                      ; Store want size into allocated block 
1271 71			      ld    (HL), C 
1272 23			      inc   HL 
1273 70			      ld    (HL), B 
1274 23			      inc   HL 
1275 e5			      push  HL                      ; Address of allocation to return 
1276			 
1276 18 19		      jr    malloc_update_links 
1278			 
1278			malloc_alloc_fit: 
1278 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1279			 
1279					if DEBUG_FORTH_MALLOC 
1279						DMARK "MAf" 
1279						CALLMONITOR 
1279					endif 
1279			      ; Modify this_free block to be allocation 
1279 eb			      ex    DE, HL 
127a 2b			      dec   HL 
127b 2b			      dec   HL 
127c 2b			      dec   HL 
127d			 
127d af			      xor   A                       ; Null the next block ptr of allocated block 
127e 77			      ld    (HL), A 
127f 23			      inc   HL 
1280 77			      ld    (HL), A 
1281			 
1281 23			      inc   HL                      ; Store address of allocation to return 
1282 23			      inc   HL 
1283 23			      inc   HL 
1284 e5			      push  HL 
1285			 
1285			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1285 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
1288 dd 66 01		      ld    H, (IX+1) 
128b			 
128b dd 75 02		      ld    (IX+2), L               ; HL to this_free 
128e dd 74 03		      ld    (IX+3), H 
1291			 
1291			 
1291			malloc_update_links: 
1291			      ; Update prev_free ptr to point to this_free 
1291 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1294 dd 66 05		      ld    H, (IX+5) 
1297			 
1297 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
129a dd 56 03		      ld    D, (IX+3) 
129d			 
129d 73			      ld    (HL), E                 ; this_free ptr into prev_free 
129e 23			      inc   HL 
129f 72			      ld    (HL), D 
12a0			 
12a0					if DEBUG_FORTH_MALLOC 
12a0						DMARK "Mul" 
12a0						CALLMONITOR 
12a0					endif 
12a0			      ; Clear the Z flag to indicate successful allocation 
12a0 7a			      ld    A, D 
12a1 b3			      or    E 
12a2			 
12a2 d1			      pop   DE                      ; Address of allocation 
12a3					if DEBUG_FORTH_MALLOC 
12a3						DMARK "MAu" 
12a3						CALLMONITOR 
12a3					endif 
12a3			 
12a3			malloc_no_space: 
12a3 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
12a6 39			      add   HL, SP 
12a7 f9			      ld    SP, HL 
12a8			 
12a8 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
12a9					if DEBUG_FORTH_MALLOC 
12a9						DMARK "MAN" 
12a9						CALLMONITOR 
12a9					endif 
12a9			 
12a9			malloc_early_exit: 
12a9					if DEBUG_FORTH_MALLOC 
12a9						DMARK "MAx" 
12a9						CALLMONITOR 
12a9					endif 
12a9 dd e1		      pop   IX 
12ab d1			      pop   DE 
12ac c1			      pop   BC 
12ad			 
12ad			if DEBUG_FORTH_MALLOC_HIGH 
12ad			call malloc_guard_exit 
12ad			call malloc_guard_zerolen 
12ad			endif 
12ad c9			      ret 
12ae			 
12ae			 
12ae			;------------------------------------------------------------------------------ 
12ae			;     free                                                                    : 
12ae			;                                                                             : 
12ae			; Description                                                                 : 
12ae			;     Return the space pointed to by HL to the heap. HL must be an address as : 
12ae			;     returned by malloc, otherwise the behaviour is undefined.               : 
12ae			;                                                                             : 
12ae			;     Where possible, directly adjacent free blocks will be merged together   : 
12ae			;     into larger blocks to help ensure that the heap does not become         : 
12ae			;     excessively fragmented.                                                 : 
12ae			;                                                                             : 
12ae			;     free does not clear or set any other value into the freed space, and    : 
12ae			;     therefore its contents may be visible through subsequent malloc's. The  : 
12ae			;     caller should clear the freed space as required.                        : 
12ae			;                                                                             : 
12ae			;     This implementation of free uses the stack exclusively, and is          : 
12ae			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
12ae			;     advisable to disable interrupts before calling free, and recommended    : 
12ae			;     to avoid the use of free inside ISRs in general.                        : 
12ae			;                                                                             : 
12ae			;     NOTE: heap_init must be called before malloc and free can be used.      : 
12ae			;                                                                             : 
12ae			; Parameters                                                                  : 
12ae			;     HL  Pointer to address of first byte of allocation to be freed          : 
12ae			;                                                                             : 
12ae			; Returns                                                                     : 
12ae			;     Nothing                                                                 : 
12ae			;                                                                             : 
12ae			; Stack frame                                                                 : 
12ae			;       |             |                                                       : 
12ae			;       +-------------+                                                       : 
12ae			;       |     BC      |                                                       : 
12ae			;       +-------------+                                                       : 
12ae			;       |     DE      |                                                       : 
12ae			;       +-------------+                                                       : 
12ae			;       |     IX      |                                                       : 
12ae			;       +-------------+                                                       : 
12ae			;       |  prev_free  |                                                       : 
12ae			;   +2  +-------------+                                                       : 
12ae			;       |  next_free  |                                                       : 
12ae			;   +0  +-------------+                                                       : 
12ae			;       |             |                                                       : 
12ae			;                                                                             : 
12ae			;------------------------------------------------------------------------------ 
12ae			free: 
12ae c5			      push  BC 
12af d5			      push  DE 
12b0 dd e5		      push  IX 
12b2			 
12b2 7c			      ld    A, H                    ; Exit if ptr is null 
12b3 b5			      or    L 
12b4 ca 78 13		      jp    Z, free_early_exit 
12b7			 
12b7			      ; Set up stack frame 
12b7 eb			      ex    DE, HL 
12b8 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
12bb 39			      add   HL, SP 
12bc f9			      ld    SP, HL 
12bd dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
12c1 dd 39		      add   IX, SP 
12c3			 
12c3			      ; The address in HL points to the start of the useable allocated space, 
12c3			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
12c3			      ; address of the block itself. 
12c3 eb			      ex    DE, HL 
12c4 11 fc ff		      ld    DE, -4 
12c7 19			      add   HL, DE 
12c8			 
12c8			      ; An allocated block must have a null next block pointer in it 
12c8 7e			      ld    A, (HL) 
12c9 23			      inc   HL 
12ca b6			      or    (HL) 
12cb c2 73 13		      jp    NZ, free_done 
12ce			 
12ce 2b			      dec   HL 
12cf			 
12cf 44			      ld    B, H                    ; Copy HL to BC 
12d0 4d			      ld    C, L 
12d1			 
12d1			      ; Loop through the free list to find the first block with an address 
12d1			      ; higher than the block being freed 
12d1 21 0a 80		      ld    HL, free_list 
12d4			 
12d4			free_find_higher_block: 
12d4 5e			      ld    E, (HL)                 ; Load next ptr from free block 
12d5 23			      inc   HL 
12d6 56			      ld    D, (HL) 
12d7 2b			      dec   HL 
12d8			 
12d8 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
12db dd 72 01		      ld    (IX+1), D 
12de dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
12e1 dd 74 03		      ld    (IX+3), H 
12e4			 
12e4 78			      ld    A, B                    ; Check if DE is greater than BC 
12e5 ba			      cp    D                       ; Compare MSB first 
12e6 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
12e8 30 04		      jr    NC, free_find_higher_block_skip 
12ea 79			      ld    A, C 
12eb bb			      cp    E                       ; Then compare LSB 
12ec 38 08		      jr    C, free_found_higher_block 
12ee			 
12ee			free_find_higher_block_skip: 
12ee 7a			      ld    A, D                    ; Reached the end of the free list? 
12ef b3			      or    E 
12f0 ca 73 13		      jp    Z, free_done 
12f3			 
12f3 eb			      ex    DE, HL 
12f4			 
12f4 18 de		      jr    free_find_higher_block 
12f6			 
12f6			free_found_higher_block: 
12f6			      ; Insert freed block between prev and next free blocks 
12f6 71			      ld    (HL), C                 ; Point prev free block to freed block 
12f7 23			      inc   HL 
12f8 70			      ld    (HL), B 
12f9			 
12f9 60			      ld    H, B                    ; Point freed block at next free block 
12fa 69			      ld    L, C 
12fb 73			      ld    (HL), E 
12fc 23			      inc   HL 
12fd 72			      ld    (HL), D 
12fe			 
12fe			      ; Check if the freed block is adjacent to the next free block 
12fe 23			      inc   HL                      ; Load size of freed block into HL 
12ff 5e			      ld    E, (HL) 
1300 23			      inc   HL 
1301 56			      ld    D, (HL) 
1302 eb			      ex    DE, HL 
1303			 
1303 09			      add   HL, BC                  ; Add addr of freed block and its size 
1304			 
1304 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
1307 dd 56 01		      ld    D, (IX+1) 
130a			 
130a b7			      or    A                       ; Clear the carry flag 
130b ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
130d 20 22		      jr    NZ, free_check_adjacent_to_prev 
130f			 
130f			      ; Freed block is adjacent to next, merge into one bigger block 
130f eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
1310 5e			      ld    E, (HL) 
1311 23			      inc   HL 
1312 56			      ld    D, (HL) 
1313 e5			      push  HL                      ; Save ptr to next block for later 
1314			 
1314 60			      ld    H, B                    ; Store ptr from next block into freed block 
1315 69			      ld    L, C 
1316 73			      ld    (HL), E 
1317 23			      inc   HL 
1318 72			      ld    (HL), D 
1319			 
1319 e1			      pop   HL                      ; Restore ptr to next block 
131a 23			      inc   HL                      ; Load size of next block into DE 
131b 5e			      ld    E, (HL) 
131c 23			      inc   HL 
131d 56			      ld    D, (HL) 
131e d5			      push  DE                      ; Save next block size for later 
131f			 
131f 60			      ld    H, B                    ; Load size of freed block into HL 
1320 69			      ld    L, C 
1321 23			      inc   HL 
1322 23			      inc   HL 
1323 5e			      ld    E, (HL) 
1324 23			      inc   HL 
1325 56			      ld    D, (HL) 
1326 eb			      ex    DE, HL 
1327			 
1327 d1			      pop   DE                      ; Restore size of next block 
1328 19			      add   HL, DE                  ; Add sizes of both blocks 
1329 eb			      ex    DE, HL 
132a			 
132a 60			      ld    H, B                    ; Store new bigger size into freed block 
132b 69			      ld    L, C 
132c 23			      inc   HL 
132d 23			      inc   HL 
132e 73			      ld    (HL), E 
132f 23			      inc   HL 
1330 72			      ld    (HL), D 
1331			 
1331			free_check_adjacent_to_prev: 
1331			      ; Check if the freed block is adjacent to the prev free block 
1331 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
1334 dd 66 03		      ld    H, (IX+3) 
1337			 
1337 23			      inc   HL                      ; Size of prev free block into DE 
1338 23			      inc   HL 
1339 5e			      ld    E, (HL) 
133a 23			      inc   HL 
133b 56			      ld    D, (HL) 
133c 2b			      dec   HL 
133d 2b			      dec   HL 
133e 2b			      dec   HL 
133f			 
133f 19			      add   HL, DE                  ; Add prev block addr and size 
1340			 
1340 b7			      or    A                       ; Clear the carry flag 
1341 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1343 20 2e		      jr    NZ, free_done 
1345			 
1345			      ; Freed block is adjacent to prev, merge into one bigger block 
1345 60			      ld    H, B                    ; Load next ptr from freed block into DE 
1346 69			      ld    L, C 
1347 5e			      ld    E, (HL) 
1348 23			      inc   HL 
1349 56			      ld    D, (HL) 
134a e5			      push  HL                      ; Save freed block ptr for later 
134b			 
134b dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
134e dd 66 03		      ld    H, (IX+3) 
1351 73			      ld    (HL), E 
1352 23			      inc   HL 
1353 72			      ld    (HL), D 
1354			 
1354 e1			      pop   HL                      ; Restore freed block ptr 
1355 23			      inc   HL                      ; Load size of freed block into DE 
1356 5e			      ld    E, (HL) 
1357 23			      inc   HL 
1358 56			      ld    D, (HL) 
1359 d5			      push  DE                      ; Save freed block size for later 
135a			 
135a dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
135d dd 66 03		      ld    H, (IX+3) 
1360 23			      inc   HL 
1361 23			      inc   HL 
1362 5e			      ld    E, (HL) 
1363 23			      inc   HL 
1364 56			      ld    D, (HL) 
1365			 
1365 e1			      pop   HL                      ; Add sizes of both blocks 
1366 19			      add   HL, DE 
1367 eb			      ex    DE, HL 
1368			 
1368 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
136b dd 66 03		      ld    H, (IX+3) 
136e 23			      inc   HL 
136f 23			      inc   HL 
1370 73			      ld    (HL), E 
1371 23			      inc   HL 
1372 72			      ld    (HL), D 
1373			 
1373			free_done: 
1373 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
1376 39			      add   HL, SP 
1377 f9			      ld    SP, HL 
1378			 
1378			free_early_exit: 
1378 dd e1		      pop   IX 
137a d1			      pop   DE 
137b c1			      pop   BC 
137c			 
137c c9			      ret 
137d			 
137d			; moved to firmware.asm 
137d			; 
137d			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
137d			;                  .dw   0 
137d			 
137d			 
137d			endif 
137d			 
137d			 
137d			if MALLOC_3 
137d			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
137d			;heap_start        .equ  0x9000      ; Starting address of heap 
137d			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
137d			; 
137d			 ;     .org 0 
137d			  ;    jp    main 
137d			; 
137d			; 
137d			 ;     .org  0x100 
137d			;main: 
137d			 ;     ld    HL, 0x8100 
137d			  ;    ld    SP, HL 
137d			; 
137d			;      call  heap_init 
137d			 
137d			      ; Make some allocations 
137d			;      ld    HL, 12 
137d			;      call  malloc            ; Allocates 0x9004 
137d			; 
137d			 ;     ld    HL, 12 
137d			;      call  malloc            ; Allocates 0x9014 
137d			 
137d			;      ld    HL, 12 
137d			;      call  malloc            ; Allocates 0x9024 
137d			 
137d			      ; Free some allocations 
137d			;      ld    HL, 0x9014 
137d			;      call  free 
137d			 
137d			;      ld    HL, 0x9004 
137d			;      call  free 
137d			; 
137d			;      ld    HL, 0x9024 
137d			;      call  free 
137d			 
137d			 
137d			 ;     halt 
137d			 
137d			 
137d			;------------------------------------------------------------------------------ 
137d			;     heap_init                                                               : 
137d			;                                                                             : 
137d			; Description                                                                 : 
137d			;     Initialise the heap and make it ready for malloc and free operations.   : 
137d			;                                                                             : 
137d			;     The heap is maintained as a linked list, starting with an initial       : 
137d			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
137d			;     the first free block in the heap. Each block then points to the next    : 
137d			;     free block within the heap, and the free list ends at the first block   : 
137d			;     with a null pointer to the next free block.                             : 
137d			;                                                                             : 
137d			; Parameters                                                                  : 
137d			;     Inputs are compile-time only. Two defines which specify the starting    : 
137d			;     address of the heap and its size are required, along with a memory      : 
137d			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
137d			;     principally stores a pointer to the first free block in the heap.       : 
137d			;                                                                             : 
137d			; Returns                                                                     : 
137d			;     Nothing                                                                 : 
137d			;------------------------------------------------------------------------------ 
137d			heap_init: 
137d			      push  HL 
137d			 
137d			      ; Initialise free list struct 
137d			      ld    HL, heap_start 
137d			      ld    (free_list), HL 
137d			      ld    HL, 0 
137d			      ld    (free_list+2), HL 
137d			 
137d			      ; Insert first free block at bottom of heap, consumes entire heap 
137d			      ld    HL, heap_start+heap_size-4 
137d			      ld    (heap_start), HL        ; Next block (end of free list) 
137d			      ld    HL, heap_size-4 
137d			      ld    (heap_start+2), HL      ; Block size 
137d			 
137d			      ; Insert end of free list block at top of heap - two null words will 
137d			      ; terminate the free list 
137d			      ld    HL, 0 
137d			      ld    (heap_start+heap_size-2), HL 
137d			      ld    (heap_start+heap_size-4), HL 
137d			 
137d			      pop   HL 
137d			 
137d			      ret 
137d			 
137d			 
137d			;------------------------------------------------------------------------------ 
137d			;     malloc                                                                  : 
137d			;                                                                             : 
137d			; Description                                                                 : 
137d			;     Allocates the wanted space from the heap and returns the address of the : 
137d			;     first useable byte of the allocation.                                   : 
137d			;                                                                             : 
137d			;     Allocations can happen in one of two ways:                              : 
137d			;                                                                             : 
137d			;     1. A free block may be found which is the exact size wanted. In this    : 
137d			;        case the block is removed from the free list and retuedn to the      : 
137d			;        caller.                                                              : 
137d			;     2. A free block may be found which is larger than the size wanted. In   : 
137d			;        this case, the larger block is split into two. The first portion of  : 
137d			;        this block will become the requested space by the malloc call and    : 
137d			;        is returned to the caller. The second portion becomes a new free     : 
137d			;        block, and the free list is adjusted to maintain continuity via this : 
137d			;        newly created block.                                                 : 
137d			;                                                                             : 
137d			;     malloc does not set any initial value in the allocated space, the       : 
137d			;     caller is required to do this as required.                              : 
137d			;                                                                             : 
137d			;     This implementation of malloc uses the stack exclusively, and is        : 
137d			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
137d			;     advisable to disable interrupts before calling malloc, and recommended  : 
137d			;     to avoid the use of malloc inside ISRs in general.                      : 
137d			;                                                                             : 
137d			;     NOTE: heap_init must be called before malloc and free can be used.      : 
137d			;                                                                             : 
137d			; Parameters                                                                  : 
137d			;     HL  Number of bytes wanted                                              : 
137d			;                                                                             : 
137d			; Returns                                                                     : 
137d			;     HL  Address of the first useable byte of the allocation                 : 
137d			;                                                                             : 
137d			; Flags                                                                       : 
137d			;     Z   Set if the allocation did not succeed, clear otherwise              : 
137d			;                                                                             : 
137d			; Stack frame                                                                 : 
137d			;       |             |                                                       : 
137d			;       +-------------+                                                       : 
137d			;       |     BC      |                                                       : 
137d			;       +-------------+                                                       : 
137d			;       |     DE      |                                                       : 
137d			;       +-------------+                                                       : 
137d			;       |     IX      |                                                       : 
137d			;       +-------------+                                                       : 
137d			;       |  prev_free  |                                                       : 
137d			;   +4  +-------------+                                                       : 
137d			;       |  this_free  |                                                       : 
137d			;   +2  +-------------+                                                       : 
137d			;       |  next_free  |                                                       : 
137d			;   +0  +-------------+                                                       : 
137d			;       |             |                                                       : 
137d			;                                                                             : 
137d			;------------------------------------------------------------------------------ 
137d			malloc: 
137d			      push  BC 
137d			      push  DE 
137d			      push  IX 
137d			 
137d			      ld    A, H                    ; Exit if no space requested 
137d			      or    L 
137d			      jp    Z, malloc_early_exit 
137d			 
137d			      ; Set up stack frame 
137d			      ex    DE, HL 
137d			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
137d			      add   HL, SP 
137d			      ld    SP, HL 
137d			      ld    IX, 0                   ; Use IX as a frame pointer 
137d			      add   IX, SP 
137d			 
137d			      ; Setup initial state 
137d			      ld    HL, 4                   ; want must also include space used by block struct 
137d			      add   HL, DE 
137d			 
137d			      ld    B, H                    ; Move want to BC 
137d			      ld    C, L 
137d			 
137d			      ld    HL, free_list           ; Store prev_free ptr to stack 
137d			      ld    (IX+4), L 
137d			      ld    (IX+5), H 
137d			 
137d			      ld    E, (HL)                 ; Store this_free ptr to stack 
137d			      inc   HL 
137d			      ld    D, (HL) 
137d			      ld    (IX+2), E 
137d			      ld    (IX+3), D 
137d			      ex    DE, HL                  ; this_free ptr into HL 
137d			 
137d			      ; Loop through free block list to find some space 
137d			malloc_find_space: 
137d			      ld    E, (HL)                 ; Load next_free ptr into DE 
137d			      inc   HL 
137d			      ld    D, (HL) 
137d			 
137d			      ld    A, D                    ; Check for null next_free ptr - end of free list 
137d			      or    E 
137d			      jp    Z, malloc_no_space 
137d			 
137d			      ld    (IX+0), E               ; Store next_free ptr to stack 
137d			      ld    (IX+1), D 
137d			 
137d			      ; Does this block have enough space to make the allocation? 
137d			      inc   HL                      ; Load free block size into DE 
137d			      ld    E, (HL) 
137d			      inc   HL 
137d			      ld    D, (HL) 
137d			 
137d			      ex    DE, HL                  ; Check size of block against want 
137d			      or    A                       ; Ensure carry flag clear 
137d			      sbc   HL, BC 
137d			      push  HL                      ; Store the result for later (new block size) 
137d			 
137d			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
137d			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
137d			 
137d			      ; this_free block is not big enough, setup ptrs to test next free block 
137d			      pop   HL                      ; Discard previous result 
137d			 
137d			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
137d			      ld    H, (IX+3) 
137d			      ld    (IX+4), L 
137d			      ld    (IX+5), H 
137d			 
137d			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
137d			      ld    H, (IX+1) 
137d			      ld    (IX+2), L 
137d			      ld    (IX+3), H 
137d			 
137d			      jr    malloc_find_space 
137d			 
137d			      ; split a bigger block into two - requested size and remaining size 
137d			malloc_alloc_split: 
137d			      ex    DE, HL                  ; Calculate address of new free block 
137d			      dec   HL 
137d			      dec   HL 
137d			      dec   HL 
137d			      add   HL, BC 
137d			 
137d			      ; Create a new block and point it at next_free 
137d			      ld    E, (IX+0)               ; Load next_free ptr into DE 
137d			      ld    D, (IX+1) 
137d			 
137d			      ld    (HL), E                 ; Store next_free ptr into new block 
137d			      inc   HL 
137d			      ld    (HL), D 
137d			 
137d			      pop   DE                      ; Store size of new block into new block 
137d			      inc   HL 
137d			      ld    (HL), E 
137d			      inc   HL 
137d			      ld    (HL), D 
137d			 
137d			      ; Update this_free ptr to point to new block 
137d			      dec   HL 
137d			      dec   HL 
137d			      dec   HL 
137d			 
137d			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
137d			      ld    D, (IX+3) 
137d			 
137d			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
137d			      ld    (IX+3), H 
137d			 
137d			      ; Modify this_free block to be allocation 
137d			      ex    DE, HL 
137d			      xor   A                       ; Null the next block ptr of allocated block 
137d			      ld    (HL), A 
137d			      inc   HL 
137d			      ld    (HL), A 
137d			 
137d			      inc   HL                      ; Store want size into allocated block 
137d			      ld    (HL), C 
137d			      inc   HL 
137d			      ld    (HL), B 
137d			      inc   HL 
137d			      push  HL                      ; Address of allocation to return 
137d			 
137d			      jr    malloc_update_links 
137d			 
137d			malloc_alloc_fit: 
137d			      pop   HL                      ; Dont need new block size, want is exact fit 
137d			 
137d			      ; Modify this_free block to be allocation 
137d			      ex    DE, HL 
137d			      dec   HL 
137d			      dec   HL 
137d			      dec   HL 
137d			 
137d			      xor   A                       ; Null the next block ptr of allocated block 
137d			      ld    (HL), A 
137d			      inc   HL 
137d			      ld    (HL), A 
137d			 
137d			      inc   HL                      ; Store address of allocation to return 
137d			      inc   HL 
137d			      inc   HL 
137d			      push  HL 
137d			 
137d			      ; Copy next_free ptr to this_free, remove allocated block from free list 
137d			      ld    L, (IX+0)               ; next_free to HL 
137d			      ld    H, (IX+1) 
137d			 
137d			      ld    (IX+2), L               ; HL to this_free 
137d			      ld    (IX+3), H 
137d			 
137d			 
137d			malloc_update_links: 
137d			      ; Update prev_free ptr to point to this_free 
137d			      ld    L, (IX+4)               ; prev_free ptr to HL 
137d			      ld    H, (IX+5) 
137d			 
137d			      ld    E, (IX+2)               ; this_free ptr to DE 
137d			      ld    D, (IX+3) 
137d			 
137d			      ld    (HL), E                 ; this_free ptr into prev_free 
137d			      inc   HL 
137d			      ld    (HL), D 
137d			 
137d			      ; Clear the Z flag to indicate successful allocation 
137d			      ld    A, D 
137d			      or    E 
137d			 
137d			      pop   DE                      ; Address of allocation 
137d			 
137d			malloc_no_space: 
137d			      ld    HL, 6                   ; Clean up stack frame 
137d			      add   HL, SP 
137d			      ld    SP, HL 
137d			 
137d			      ex    DE, HL                  ; Alloc addr into HL for return 
137d			 
137d			malloc_early_exit: 
137d			      pop   IX 
137d			      pop   DE 
137d			      pop   BC 
137d			 
137d			      ret 
137d			 
137d			 
137d			;------------------------------------------------------------------------------ 
137d			;     free                                                                    : 
137d			;                                                                             : 
137d			; Description                                                                 : 
137d			;     Return the space pointed to by HL to the heap. HL must be an address as : 
137d			;     returned by malloc, otherwise the behaviour is undefined.               : 
137d			;                                                                             : 
137d			;     Where possible, directly adjacent free blocks will be merged together   : 
137d			;     into larger blocks to help ensure that the heap does not become         : 
137d			;     excessively fragmented.                                                 : 
137d			;                                                                             : 
137d			;     free does not clear or set any other value into the freed space, and    : 
137d			;     therefore its contents may be visible through subsequent malloc's. The  : 
137d			;     caller should clear the freed space as required.                        : 
137d			;                                                                             : 
137d			;     This implementation of free uses the stack exclusively, and is          : 
137d			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
137d			;     advisable to disable interrupts before calling free, and recommended    : 
137d			;     to avoid the use of free inside ISRs in general.                        : 
137d			;                                                                             : 
137d			;     NOTE: heap_init must be called before malloc and free can be used.      : 
137d			;                                                                             : 
137d			; Parameters                                                                  : 
137d			;     HL  Pointer to address of first byte of allocation to be freed          : 
137d			;                                                                             : 
137d			; Returns                                                                     : 
137d			;     Nothing                                                                 : 
137d			;                                                                             : 
137d			; Stack frame                                                                 : 
137d			;       |             |                                                       : 
137d			;       +-------------+                                                       : 
137d			;       |     BC      |                                                       : 
137d			;       +-------------+                                                       : 
137d			;       |     DE      |                                                       : 
137d			;       +-------------+                                                       : 
137d			;       |     IX      |                                                       : 
137d			;       +-------------+                                                       : 
137d			;       |  prev_free  |                                                       : 
137d			;   +2  +-------------+                                                       : 
137d			;       |  next_free  |                                                       : 
137d			;   +0  +-------------+                                                       : 
137d			;       |             |                                                       : 
137d			;                                                                             : 
137d			;------------------------------------------------------------------------------ 
137d			free: 
137d			      push  BC 
137d			      push  DE 
137d			      push  IX 
137d			 
137d			      ld    A, H                    ; Exit if ptr is null 
137d			      or    L 
137d			      jp    Z, free_early_exit 
137d			 
137d			      ; Set up stack frame 
137d			      ex    DE, HL 
137d			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
137d			      add   HL, SP 
137d			      ld    SP, HL 
137d			      ld    IX, 0                   ; Use IX as a frame pointer 
137d			      add   IX, SP 
137d			 
137d			      ; The address in HL points to the start of the useable allocated space, 
137d			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
137d			      ; address of the block itself. 
137d			      ex    DE, HL 
137d			      ld    DE, -4 
137d			      add   HL, DE 
137d			 
137d			      ; An allocated block must have a null next block pointer in it 
137d			      ld    A, (HL) 
137d			      inc   HL 
137d			      or    (HL) 
137d			      jp    NZ, free_done 
137d			 
137d			      dec   HL 
137d			 
137d			      ld    B, H                    ; Copy HL to BC 
137d			      ld    C, L 
137d			 
137d			      ; Loop through the free list to find the first block with an address 
137d			      ; higher than the block being freed 
137d			      ld    HL, free_list 
137d			 
137d			free_find_higher_block: 
137d			      ld    E, (HL)                 ; Load next ptr from free block 
137d			      inc   HL 
137d			      ld    D, (HL) 
137d			      dec   HL 
137d			 
137d			      ld    (IX+0), E               ; Save ptr to next free block 
137d			      ld    (IX+1), D 
137d			      ld    (IX+2), L               ; Save ptr to prev free block 
137d			      ld    (IX+3), H 
137d			 
137d			      ld    A, B                    ; Check if DE is greater than BC 
137d			      cp    D                       ; Compare MSB first 
137d			      jr    Z, $+4                  ; MSB the same, compare LSB 
137d			      jr    NC, free_find_higher_block_skip 
137d			      ld    A, C 
137d			      cp    E                       ; Then compare LSB 
137d			      jr    C, free_found_higher_block 
137d			 
137d			free_find_higher_block_skip: 
137d			      ld    A, D                    ; Reached the end of the free list? 
137d			      or    E 
137d			      jp    Z, free_done 
137d			 
137d			      ex    DE, HL 
137d			 
137d			      jr    free_find_higher_block 
137d			 
137d			free_found_higher_block: 
137d			      ; Insert freed block between prev and next free blocks 
137d			      ld    (HL), C                 ; Point prev free block to freed block 
137d			      inc   HL 
137d			      ld    (HL), B 
137d			 
137d			      ld    H, B                    ; Point freed block at next free block 
137d			      ld    L, C 
137d			      ld    (HL), E 
137d			      inc   HL 
137d			      ld    (HL), D 
137d			 
137d			      ; Check if the freed block is adjacent to the next free block 
137d			      inc   HL                      ; Load size of freed block into HL 
137d			      ld    E, (HL) 
137d			      inc   HL 
137d			      ld    D, (HL) 
137d			      ex    DE, HL 
137d			 
137d			      add   HL, BC                  ; Add addr of freed block and its size 
137d			 
137d			      ld    E, (IX+0)               ; Load addr of next free block into DE 
137d			      ld    D, (IX+1) 
137d			 
137d			      or    A                       ; Clear the carry flag 
137d			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
137d			      jr    NZ, free_check_adjacent_to_prev 
137d			 
137d			      ; Freed block is adjacent to next, merge into one bigger block 
137d			      ex    DE, HL                  ; Load next ptr from next block into DE 
137d			      ld    E, (HL) 
137d			      inc   HL 
137d			      ld    D, (HL) 
137d			      push  HL                      ; Save ptr to next block for later 
137d			 
137d			      ld    H, B                    ; Store ptr from next block into freed block 
137d			      ld    L, C 
137d			      ld    (HL), E 
137d			      inc   HL 
137d			      ld    (HL), D 
137d			 
137d			      pop   HL                      ; Restore ptr to next block 
137d			      inc   HL                      ; Load size of next block into DE 
137d			      ld    E, (HL) 
137d			      inc   HL 
137d			      ld    D, (HL) 
137d			      push  DE                      ; Save next block size for later 
137d			 
137d			      ld    H, B                    ; Load size of freed block into HL 
137d			      ld    L, C 
137d			      inc   HL 
137d			      inc   HL 
137d			      ld    E, (HL) 
137d			      inc   HL 
137d			      ld    D, (HL) 
137d			      ex    DE, HL 
137d			 
137d			      pop   DE                      ; Restore size of next block 
137d			      add   HL, DE                  ; Add sizes of both blocks 
137d			      ex    DE, HL 
137d			 
137d			      ld    H, B                    ; Store new bigger size into freed block 
137d			      ld    L, C 
137d			      inc   HL 
137d			      inc   HL 
137d			      ld    (HL), E 
137d			      inc   HL 
137d			      ld    (HL), D 
137d			 
137d			free_check_adjacent_to_prev: 
137d			      ; Check if the freed block is adjacent to the prev free block 
137d			      ld    L, (IX+2)               ; Prev free block ptr into HL 
137d			      ld    H, (IX+3) 
137d			 
137d			      inc   HL                      ; Size of prev free block into DE 
137d			      inc   HL 
137d			      ld    E, (HL) 
137d			      inc   HL 
137d			      ld    D, (HL) 
137d			      dec   HL 
137d			      dec   HL 
137d			      dec   HL 
137d			 
137d			      add   HL, DE                  ; Add prev block addr and size 
137d			 
137d			      or    A                       ; Clear the carry flag 
137d			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
137d			      jr    NZ, free_done 
137d			 
137d			      ; Freed block is adjacent to prev, merge into one bigger block 
137d			      ld    H, B                    ; Load next ptr from freed block into DE 
137d			      ld    L, C 
137d			      ld    E, (HL) 
137d			      inc   HL 
137d			      ld    D, (HL) 
137d			      push  HL                      ; Save freed block ptr for later 
137d			 
137d			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
137d			      ld    H, (IX+3) 
137d			      ld    (HL), E 
137d			      inc   HL 
137d			      ld    (HL), D 
137d			 
137d			      pop   HL                      ; Restore freed block ptr 
137d			      inc   HL                      ; Load size of freed block into DE 
137d			      ld    E, (HL) 
137d			      inc   HL 
137d			      ld    D, (HL) 
137d			      push  DE                      ; Save freed block size for later 
137d			 
137d			      ld    L, (IX+2)               ; Load size of prev block into DE 
137d			      ld    H, (IX+3) 
137d			      inc   HL 
137d			      inc   HL 
137d			      ld    E, (HL) 
137d			      inc   HL 
137d			      ld    D, (HL) 
137d			 
137d			      pop   HL                      ; Add sizes of both blocks 
137d			      add   HL, DE 
137d			      ex    DE, HL 
137d			 
137d			      ld    L, (IX+2)               ; Store new bigger size into prev block 
137d			      ld    H, (IX+3) 
137d			      inc   HL 
137d			      inc   HL 
137d			      ld    (HL), E 
137d			      inc   HL 
137d			      ld    (HL), D 
137d			 
137d			free_done: 
137d			      ld    HL, 4                   ; Clean up stack frame 
137d			      add   HL, SP 
137d			      ld    SP, HL 
137d			 
137d			free_early_exit: 
137d			      pop   IX 
137d			      pop   DE 
137d			      pop   BC 
137d			 
137d			      ret 
137d			 
137d			 
137d			;      .org 0x8000 
137d			; 
137d			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
137d			 ;                 .dw   0 
137d			 
137d			endif 
137d			 
137d			 
137d			if MALLOC_4 
137d			 
137d			; My memory allocation code. Very very simple.... 
137d			; allocate space under 250 chars 
137d			 
137d			heap_init: 
137d				; init start of heap as zero 
137d				;  
137d			 
137d				ld hl, heap_start 
137d				ld a, 0 
137d				ld (hl), a      ; empty block 
137d				inc hl 
137d				ld a, 0 
137d				ld (hl), a      ; length of block 
137d				; write end of list 
137d				inc hl 
137d				ld a,(hl) 
137d				inc hl 
137d				ld a,(hl) 
137d				 
137d			 
137d				; init some malloc vars 
137d			 
137d				ld hl, 0 
137d				ld (free_list), hl       ; store last malloc location 
137d			 
137d				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
137d				ld a, 0 
137d				ld (hl), a 
137d			 
137d			 
137d				ld hl, heap_start 
137d				;  
137d				  
137d				ret 
137d			 
137d			 
137d			;    free block marker 
137d			;    requested size  
137d			;    pointer to next block 
137d			;    .... 
137d			;    next block marker 
137d			 
137d			 
137d			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
137d			; 
137d			 
137d			 
137d			malloc:  
137d				push de 
137d				push bc 
137d				push af 
137d			 
137d				; hl space required 
137d				 
137d				ld c, l    ; hold space   (TODO only a max of 255) 
137d			 
137d			;	inc c     ; TODO BUG need to fix memory leak on push str 
137d			;	inc c 
137d			;	inc c 
137d			;	inc c 
137d			;	inc c 
137d			;	inc c 
137d			;	inc c 
137d			 
137d			 
137d			 
137d				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
137d			 
137d				ld a, (free_list+3) 
137d				cp 0 
137d				jr z, .contheap 
137d			 
137d				ld hl, (free_list)     ; get last alloc 
137d					if DEBUG_FORTH_MALLOC_INT 
137d						DMARK "mrs" 
137d						CALLMONITOR 
137d					endif 
137d				jr .startalloc 
137d			 
137d			.contheap: 
137d				ld hl, heap_start 
137d			 
137d			.startalloc: 
137d			 
137d					if DEBUG_FORTH_MALLOC_INT 
137d						DMARK "mym" 
137d						CALLMONITOR 
137d					endif 
137d			.findblock: 
137d					if DEBUG_FORTH_MALLOC_INT 
137d						DMARK "mmf" 
137d						CALLMONITOR 
137d					endif 
137d			 
137d				ld a,(hl)  
137d				; if byte is zero then clear to use 
137d			 
137d				cp 0 
137d				jr z, .foundemptyblock 
137d			 
137d				; if byte is not clear 
137d				;     then byte is offset to next block 
137d			 
137d				inc hl 
137d				ld a, (hl) ; get size 
137d			.nextblock:	inc hl 
137d					ld e, (hl) 
137d					inc hl 
137d					ld d, (hl) 
137d					ex de, hl 
137d			;	inc hl  ; move past the store space 
137d			;	inc hl  ; move past zero index  
137d			 
137d				; TODO detect no more space 
137d			 
137d				push hl 
137d				ld de, heap_end 
137d				call cmp16 
137d				pop hl 
137d				jr nc, .nospace 
137d			 
137d				jr .findblock 
137d			 
137d			.nospace: ld hl, 0 
137d				jp .exit 
137d			 
137d			 
137d			.foundemptyblock:	 
137d					if DEBUG_FORTH_MALLOC_INT 
137d						DMARK "mme" 
137d						CALLMONITOR 
137d					endif 
137d			 
137d			; TODO has block enough space if reusing??? 
137d			 
137d				;  
137d			 
137d			; see if this block has been previously used 
137d				inc hl 
137d				ld a, (hl) 
137d				dec hl 
137d				cp 0 
137d				jr z, .newblock 
137d			 
137d					if DEBUG_FORTH_MALLOC_INT 
137d						DMARK "meR" 
137d						CALLMONITOR 
137d					endif 
137d			 
137d			; no reusing previously allocated block 
137d			 
137d			; is it smaller than previously used? 
137d				 
137d				inc hl    ; move to size 
137d				ld a, c 
137d				sub (hl)        ; we want c < (hl) 
137d				dec hl    ; move back to marker 
137d			        jr z, .findblock 
137d			 
137d				; update with the new size which should be lower 
137d			 
137d			        ;inc  hl   ; negate next move. move back to size  
137d			 
137d			.newblock: 
137d				; need to be at marker here 
137d			 
137d					if DEBUG_FORTH_MALLOC_INT 
137d						DMARK "meN" 
137d						CALLMONITOR 
137d					endif 
137d			 
137d			 
137d				ld a, c 
137d			 
137d				ld (free_list+3), a	 ; flag resume from last malloc  
137d				ld (free_list), hl    ; save out last location 
137d			 
137d			 
137d				;inc a     ; space for length byte 
137d				ld (hl), a     ; save block in use marker 
137d			 
137d				inc hl   ; move to space marker 
137d				ld (hl), a    ; save new space 
137d			 
137d				inc hl   ; move to start of allocated area 
137d				 
137d			;	push hl     ; save where we are - 1  
137d			 
137d			;	inc hl  ; move past zero index  
137d				; skip space to set down new marker 
137d			 
137d				; provide some extra space for now 
137d			 
137d				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
137d				inc a 
137d				inc a 
137d			 
137d				push hl   ; save where we are in the node block 
137d			 
137d				call addatohl 
137d			 
137d				; write linked list point 
137d			 
137d				pop de     ; get our node position 
137d				ex de, hl 
137d			 
137d				ld (hl), e 
137d				inc hl 
137d				ld (hl), d 
137d			 
137d				inc hl 
137d			 
137d				; now at start of allocated data so save pointer 
137d			 
137d				push hl 
137d			 
137d				; jump to position of next node and setup empty header in DE 
137d			 
137d				ex de, hl 
137d			 
137d			;	inc hl ; move past end of block 
137d			 
137d				ld a, 0 
137d				ld (hl), a   ; empty marker 
137d				inc hl 
137d				ld (hl), a   ; size 
137d				inc hl  
137d				ld (hl), a   ; ptr 
137d				inc hl 
137d				ld (hl), a   ; ptr 
137d			 
137d			 
137d				pop hl 
137d			 
137d					if DEBUG_FORTH_MALLOC_INT 
137d						DMARK "mmr" 
137d						CALLMONITOR 
137d					endif 
137d			 
137d			.exit: 
137d				pop af 
137d				pop bc 
137d				pop de  
137d				ret 
137d			 
137d			 
137d			 
137d			 
137d			free:  
137d				push hl 
137d				push af 
137d				; get address in hl 
137d			 
137d					if DEBUG_FORTH_MALLOC_INT 
137d						DMARK "fre" 
137d						CALLMONITOR 
137d					endif 
137d				; data is at hl - move to block count 
137d				dec hl 
137d				dec hl    ; get past pointer 
137d				dec hl 
137d			 
137d				ld a, (hl)    ; need this for a validation check 
137d			 
137d				dec hl    ; move to block marker 
137d			 
137d				; now check that the block count and block marker are the same  
137d			        ; this checks that we are on a malloc node and not random memory 
137d			        ; OK a faint chance this could be a problem but rare - famous last words! 
137d			 
137d				ld c, a 
137d				ld a, (hl)    
137d			 
137d				cp c 
137d				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
137d			 
137d				; yes good chance we are on a malloc node 
137d			 
137d				ld a, 0      
137d				ld (hl), a   ; mark as free 
137d			 
137d				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
137d			 
137d			.freeignore:  
137d			 
137d				pop af 
137d				pop hl 
137d			 
137d				ret 
137d			 
137d			 
137d			 
137d			endif 
137d			 
137d			; eof 
# End of file firmware_memory.asm
137d			  
137d			; device C  
137d			if SOUND_ENABLE  
137d				include "firmware_sound.asm"  
137d			; Sound abstraction layer 
137d			 
137d			; support different sound chips through common interface 
137d			 
137d			SOUND_DEVICE_AY: equ 0 
137d			 
137d			SOUND_DEVICE: equ Device_A 
137d			 
137d			 
137d			 
137d			if SOUND_DEVICE_AY 
137d				include "firmware_sound_ay38910.asm" 
137d			else 
137d				include "firmware_sound_sn76489an.asm" 
137d			 
137d			; Device support for SN76489AN sound chip 
137d			 
137d			; https://arduinoplusplus.wordpress.com/2019/10/05/making-noise-with-a-sn76489-digital-sound-generator-part-1/ 
137d			; http://danceswithferrets.org/geekblog/?p=93 
137d			; https://www.smspower.org/Development/SN76489 
137d			 
137d			; D0 [ 3] 
137d			; D1 [ 2] 
137d			; D2 [ 1] 
137d			; D3 [15] 
137d			; D4 [13] 
137d			; D5 [12] 
137d			; D6 [11] 
137d			; D7 [10] 
137d			; /WE [ 5] 
137d			; CLK [14] 
137d			; /OE [ 6] 
137d			; AUDIO [ 7] 
137d			; GND 8 
137d			; +5 16 
137d			; 
137d			 
137d			; Write sequence: 
137d			; CE low 
137d			; Data bus 
137d			; WE low then high 
137d			; 32 clock cycles / 8ns write time at 4mhz 
137d			; 
137d			; https://github.com/jblang/SN76489 
137d			; Shows that the clock needs to be enabled when required. Noticed that with the clock connected it interupted the bus 
137d			; Tried: 
137d			; 
137d			; CE/OE -> Both pins of NAND -> To one pin of second NAND and second pin to full clock -> CLK on chip 
137d			; 
137d			; Connected WE to OR too 
137d			;  
137d			; That enabled the clock when required 
137d			; However still random bus corruption. Need further investigation 
137d			 
137d			 
137d			SOUND_LATCH: equ 10000000B 
137d			SOUND_DATA: equ 0B 
137d			SOUND_CH0:  equ 0B    ; Tone 
137d			SOUND_CH1: equ 0100000B        ; Tone 
137d			SOUND_CH2: equ 1000000B   ; Tone 
137d			SOUND_CH3: equ 1100000B    ; Noise 
137d			SOUND_VOL: equ 10000B 
137d			SOUND_TONE: equ 0B 
137d			 
137d			 
137d			sound_init: 
137d 3e 1f			ld a, SOUND_DATA | SOUND_CH0 | SOUND_VOL | 1111B 
137f cd 94 13			call note_send_byte 
1382 3e 07			ld a, SOUND_DATA | SOUND_CH0 | SOUND_TONE | 0111B 
1384 cd 94 13			call note_send_byte 
1387 cd 5d 0a			call delay250ms 
138a 3e 05			ld a, SOUND_DATA | SOUND_CH0 | SOUND_TONE | 0101B 
138c cd 94 13			call note_send_byte 
138f cd 5d 0a			call delay250ms 
1392 c9				ret 
1393			 
1393			; Play a note 
1393			; h = note 
1393			; l = duration 
1393			; a = channel 
1393			 
1393			 
1393			;  frequ = clock / ( 2 x reg valu x 32 )  
1393			 
1393			note:  
1393				 
1393			 
1393 c9				ret 
1394			 
1394			note_send_byte: 
1394				; byte in a 
1394			 
1394				; we high 
1394 d3 40			out (Device_B), a 
1396			;	ld a, 1 
1396			;	call aDelayInMS 
1396 00				nop  
1397 00				nop  
1398 00				nop  
1399 00				nop  
139a				; we low 
139a d3 40			out (Device_B), a 
139c			;	ld a, 1 
139c			;	call aDelayInMS 
139c 00				nop  
139d 00				nop  
139e 00				nop  
139f 00				nop  
13a0				; we high 
13a0 d3 40			out (Device_B), a 
13a2			;	ld a, 1 
13a2			;	call aDelayInMS 
13a2 00				nop  
13a3 00				nop  
13a4 00				nop  
13a5 00				nop  
13a6			 
13a6			 
13a6 c9				ret 
13a7			 
13a7			;void SilenceAllChannels() 
13a7			;{ 
13a7			;  SendByte(0x9f); 
13a7			;  SendByte(0xbf); 
13a7			;  SendByte(0xdf); 
13a7			;  SendByte(0xff); 
13a7			;} 
13a7			 
13a7			 
13a7			; eof 
13a7			 
# End of file firmware_sound_sn76489an.asm
13a7			endif 
13a7			 
13a7			 
13a7			; Abstraction entry points 
13a7			 
13a7			; init  
13a7			 
13a7			; sound_init in specific hardware files 
13a7			 
13a7			; Play a note 
13a7			; h = note 
13a7			; l = duration 
13a7			; a = channel 
13a7			 
13a7			;note:     
13a7			;	ret 
13a7			 
13a7			 
13a7			 
13a7			 
13a7			; eof 
13a7			 
# End of file firmware_sound.asm
13a7			endif  
13a7			  
13a7			include "firmware_diags.asm"  
13a7			; Hardware diags menu 
13a7			 
13a7			 
13a7			config: 
13a7			 
13a7 3e 00			ld a, 0 
13a9 21 d7 13			ld hl, .configmn 
13ac cd 1a 0b			call menu 
13af			 
13af fe 00			cp 0 
13b1 c8				ret z 
13b2			 
13b2 fe 01			cp 1 
13b4 cc 41 15			call z, .savetostore 
13b7			 
13b7 fe 02			cp 2 
13b9 cc 8f 14			call z, .selautoload 
13bc fe 03			cp 3 
13be cc 78 14			call z, .disautoload 
13c1 fe 04			cp 4 
13c3 cc 3f 15			call z, .selbank 
13c6 fe 05			cp 5 
13c8 cc 1c 16			call z, .debug_tog 
13cb fe 06			cp 6 
13cd cc 64 17			call z, .bpsgo 
13d0 fe 07			cp 7 
13d2 cc 42 16			call z, hardware_diags 
13d5			 
13d5 18 d0			jr config 
13d7			 
13d7			.configmn: 
13d7 e7 13			dw .c3 
13d9 fe 13			dw .c2 
13db 13 14			dw .c2a 
13dd 29 14			dw .c2b 
13df			;	dw .c4 
13df 46 14			dw .m4 
13e1 61 14			dw .m4b 
13e3 69 14			dw .c1 
13e5 00 00			dw 0 
13e7				 
13e7			 
13e7 .. 00		.c3: db "Add Dictionary To File",0 
13fe .. 00		.c2: db "Select Autoload File",0 
1413 .. 00		.c2a: db "Disable Autoload File", 0 
1429 .. 00		.c2b: db "Select Storage Bank",0 
143d .. 00		.c4: db "Settings",0 
1446 .. 00		.m4:   db "Debug & Breakpoints On/Off",0 
1461 .. 00		.m4b:   db "Monitor",0 
1469 .. 00		.c1: db "Hardware Diags",0 
1478			 
1478			 
1478			.disautoload: 
1478				if STORAGE_SE 
1478 3e fe			ld a, $fe      ; bit 0 clear 
147a 32 48 f8			ld (spi_device), a 
147d			 
147d cd bd 03			call storage_get_block_0 
1480			 
1480 3e 00			ld a, 0 
1482 32 83 f8			ld (store_page+STORE_0_AUTOFILE), a 
1485			 
1485 21 00 00				ld hl, 0 
1488 11 62 f8				ld de, store_page 
148b cd 71 03			call storage_write_block	 ; save update 
148e				endif 
148e			 
148e			 
148e c9				ret 
148f			 
148f			 
148f			 
148f			; Select auto start 
148f			 
148f			.selautoload: 
148f			 
148f				 
148f				if STORAGE_SE 
148f			 
148f cd 66 15				call config_dir 
1492 21 1d ee			        ld hl, scratch 
1495 3e 00				ld a, 0 
1497 cd 1a 0b				call menu 
149a			 
149a fe 00				cp 0 
149c c8					ret z 
149d			 
149d 3d					dec a 
149e			 
149e			 
149e					; locate menu option 
149e			 
149e 21 1d ee				ld hl, scratch 
14a1 cd 41 0a				call table_lookup 
14a4			 
14a4					if DEBUG_FORTH_WORDS 
14a4						DMARK "ALl" 
14a4 f5				push af  
14a5 3a b9 14			ld a, (.dmark)  
14a8 32 77 fb			ld (debug_mark),a  
14ab 3a ba 14			ld a, (.dmark+1)  
14ae 32 78 fb			ld (debug_mark+1),a  
14b1 3a bb 14			ld a, (.dmark+2)  
14b4 32 79 fb			ld (debug_mark+2),a  
14b7 18 03			jr .pastdmark  
14b9 ..			.dmark: db "ALl"  
14bc f1			.pastdmark: pop af  
14bd			endm  
# End of macro DMARK
14bd						CALLMONITOR 
14bd cd 5a 17			call break_point_state  
14c0				endm  
# End of macro CALLMONITOR
14c0					endif 
14c0					; with the pointer to the menu it, the byte following the zero term is the file id 
14c0			 
14c0 3e 00				ld a, 0 
14c2 01 32 00				ld bc, 50   ; max of bytes to look at 
14c5 ed b1				cpir  
14c7			 
14c7					if DEBUG_FORTH_WORDS 
14c7						DMARK "ALb" 
14c7 f5				push af  
14c8 3a dc 14			ld a, (.dmark)  
14cb 32 77 fb			ld (debug_mark),a  
14ce 3a dd 14			ld a, (.dmark+1)  
14d1 32 78 fb			ld (debug_mark+1),a  
14d4 3a de 14			ld a, (.dmark+2)  
14d7 32 79 fb			ld (debug_mark+2),a  
14da 18 03			jr .pastdmark  
14dc ..			.dmark: db "ALb"  
14df f1			.pastdmark: pop af  
14e0			endm  
# End of macro DMARK
14e0						CALLMONITOR 
14e0 cd 5a 17			call break_point_state  
14e3				endm  
# End of macro CALLMONITOR
14e3					endif 
14e3					;inc hl 
14e3			 
14e3 7e					ld a, (hl)   ; file id 
14e4					 
14e4				        ; save bank and file ids 
14e4			 
14e4 f5					push af 
14e5			 
14e5			; TODO need to save to block 0 on bank 1	 
14e5			 
14e5 cd bd 03				call storage_get_block_0 
14e8			 
14e8					if DEBUG_FORTH_WORDS 
14e8						DMARK "AL0" 
14e8 f5				push af  
14e9 3a fd 14			ld a, (.dmark)  
14ec 32 77 fb			ld (debug_mark),a  
14ef 3a fe 14			ld a, (.dmark+1)  
14f2 32 78 fb			ld (debug_mark+1),a  
14f5 3a ff 14			ld a, (.dmark+2)  
14f8 32 79 fb			ld (debug_mark+2),a  
14fb 18 03			jr .pastdmark  
14fd ..			.dmark: db "AL0"  
1500 f1			.pastdmark: pop af  
1501			endm  
# End of macro DMARK
1501						CALLMONITOR 
1501 cd 5a 17			call break_point_state  
1504				endm  
# End of macro CALLMONITOR
1504					endif 
1504 f1					pop af 
1505			 
1505 32 86 f8				ld (store_page+STORE_0_FILERUN),a 
1508					 
1508					; save bank id 
1508			 
1508 3a 48 f8				ld a,(spi_device) 
150b 32 85 f8				ld (store_page+STORE_0_BANKRUN),a 
150e			 
150e					; enable auto run of store file 
150e			 
150e 3e 01				ld a, 1 
1510 32 83 f8				ld (store_page+STORE_0_AUTOFILE),a 
1513			 
1513					; save buffer 
1513			 
1513 21 00 00				ld hl, 0 
1516 11 62 f8				ld de, store_page 
1519					if DEBUG_FORTH_WORDS 
1519						DMARK "ALw" 
1519 f5				push af  
151a 3a 2e 15			ld a, (.dmark)  
151d 32 77 fb			ld (debug_mark),a  
1520 3a 2f 15			ld a, (.dmark+1)  
1523 32 78 fb			ld (debug_mark+1),a  
1526 3a 30 15			ld a, (.dmark+2)  
1529 32 79 fb			ld (debug_mark+2),a  
152c 18 03			jr .pastdmark  
152e ..			.dmark: db "ALw"  
1531 f1			.pastdmark: pop af  
1532			endm  
# End of macro DMARK
1532						CALLMONITOR 
1532 cd 5a 17			call break_point_state  
1535				endm  
# End of macro CALLMONITOR
1535					endif 
1535 cd 71 03			call storage_write_block	 ; save update 
1538			  
1538			 
1538			 
1538			 
1538 21 1d ee				ld hl, scratch 
153b cd 53 15				call config_fdir 
153e			 
153e			 
153e				endif 
153e c9				ret 
153f			 
153f			 
153f			 
153f			; Select storage bank 
153f			 
153f			.selbank: 
153f			 
153f				if STORAGE_SE 
153f				endif 
153f				 
153f c9				ret 
1540			 
1540			if STORAGE_SE 
1540			 
1540			.config_ldir:   
1540				; Load storage bank labels into menu array 
1540			 
1540				 
1540			 
1540			 
1540 c9				ret 
1541			 
1541			 
1541			endif 
1541			 
1541			 
1541			; Save user words to storage 
1541			 
1541			.savetostore: 
1541			 
1541				if STORAGE_SE 
1541			 
1541 cd 66 15				call config_dir 
1544 21 1d ee			        ld hl, scratch 
1547 3e 00				ld a, 0 
1549 cd 1a 0b				call menu 
154c					 
154c 21 1d ee				ld hl, scratch 
154f cd 53 15				call config_fdir 
1552			 
1552			 
1552				endif 
1552			 
1552 c9				ret 
1553			 
1553			 
1553			 
1553			if STORAGE_SE 
1553			 
1553			config_fdir: 
1553				; using the scratch dir go through and release the memory allocated for each string 
1553				 
1553 21 1d ee			ld hl, scratch 
1556 5e			.cfdir:	ld e,(hl) 
1557 23				inc hl 
1558 56				ld d,(hl) 
1559 23				inc hl 
155a			 
155a eb				ex de, hl 
155b cd 46 0d			call ishlzero 
155e c8				ret z     ; return on null pointer 
155f cd ae 12			call free 
1562 eb				ex de, hl 
1563 18 f1			jr .cfdir 
1565			 
1565			 
1565 c9				ret 
1566			 
1566			 
1566			config_dir: 
1566			 
1566				; for the config menus that need to build a directory of storage call this routine 
1566				; it will construct a menu in scratch to pass to menu 
1566			 
1566				; open storage device 
1566			 
1566				; execute DIR to build a list of files and their ids into scratch in menu format 
1566				; once the menu has finished then will need to call config_fdir to release the strings 
1566				 
1566				; c = number items 
1566			 
1566				 
1566 cd bd 03			call storage_get_block_0 
1569			 
1569 21 62 f8			ld hl, store_page     ; get current id count 
156c 46				ld b, (hl) 
156d 0e 00			ld c, 0    ; count of files   
156f			 
156f			 
156f 21 1d ee			ld hl, scratch 
1572 22 5e f8			ld (store_tmp2), hl    ; location to poke strings 
1575			 
1575				; check for empty drive 
1575			 
1575 3e 00			ld a, 0 
1577 b8				cp b 
1578 ca 12 16			jp z, .dirdone 
157b			 
157b				 
157b					if DEBUG_FORTH_WORDS 
157b						DMARK "Cdc" 
157b f5				push af  
157c 3a 90 15			ld a, (.dmark)  
157f 32 77 fb			ld (debug_mark),a  
1582 3a 91 15			ld a, (.dmark+1)  
1585 32 78 fb			ld (debug_mark+1),a  
1588 3a 92 15			ld a, (.dmark+2)  
158b 32 79 fb			ld (debug_mark+2),a  
158e 18 03			jr .pastdmark  
1590 ..			.dmark: db "Cdc"  
1593 f1			.pastdmark: pop af  
1594			endm  
# End of macro DMARK
1594						CALLMONITOR 
1594 cd 5a 17			call break_point_state  
1597				endm  
# End of macro CALLMONITOR
1597					endif 
1597			 
1597			 
1597			.diritem:	 
1597 c5				push bc 
1598				; for each of the current ids do a search for them and if found push to stack 
1598			 
1598 21 40 00				ld hl, STORE_BLOCK_PHY 
159b 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
159d 58					ld e,b 
159e			 
159e cd 31 06				call storage_findnextid 
15a1			 
15a1			 
15a1					; if found hl will be non zero 
15a1			 
15a1 cd 46 0d				call ishlzero 
15a4 28 69				jr z, .dirnotfound 
15a6			 
15a6					; increase count 
15a6			 
15a6 c1					pop bc	 
15a7 0c					inc c 
15a8 c5					push bc 
15a9					 
15a9			 
15a9					; get file header and push the file name 
15a9			 
15a9 11 62 f8				ld de, store_page 
15ac cd 0c 03				call storage_read_block 
15af			 
15af					; push file id to stack 
15af				 
15af 3a 62 f8				ld a, (store_page) 
15b2 26 00				ld h, 0 
15b4 6f					ld l, a 
15b5			 
15b5					;call forth_push_numhl 
15b5					; TODO store id 
15b5			 
15b5 e5					push hl 
15b6			 
15b6					; push extent count to stack  
15b6				 
15b6 21 65 f8				ld hl, store_page+3 
15b9			 
15b9					; get file name length 
15b9			 
15b9 cd 7b 11				call strlenz   
15bc			 
15bc 23					inc hl   ; cover zero term 
15bd 23					inc hl  ; stick the id at the end of the area 
15be			 
15be e5					push hl 
15bf c1					pop bc    ; move length to bc 
15c0			 
15c0 cd e4 11				call malloc 
15c3			 
15c3					; TODO save malloc area to scratch 
15c3			 
15c3 eb					ex de, hl 
15c4 2a 5e f8				ld hl, (store_tmp2) 
15c7 73					ld (hl), e 
15c8 23					inc hl 
15c9 72					ld (hl), d 
15ca 23					inc hl 
15cb 22 5e f8				ld (store_tmp2), hl 
15ce			 
15ce					 
15ce			 
15ce					;pop hl   ; get source 
15ce			;		ex de, hl    ; swap aronund	 
15ce			 
15ce 21 65 f8				ld hl, store_page+3 
15d1					if DEBUG_FORTH_WORDS 
15d1						DMARK "CFd" 
15d1 f5				push af  
15d2 3a e6 15			ld a, (.dmark)  
15d5 32 77 fb			ld (debug_mark),a  
15d8 3a e7 15			ld a, (.dmark+1)  
15db 32 78 fb			ld (debug_mark+1),a  
15de 3a e8 15			ld a, (.dmark+2)  
15e1 32 79 fb			ld (debug_mark+2),a  
15e4 18 03			jr .pastdmark  
15e6 ..			.dmark: db "CFd"  
15e9 f1			.pastdmark: pop af  
15ea			endm  
# End of macro DMARK
15ea						CALLMONITOR 
15ea cd 5a 17			call break_point_state  
15ed				endm  
# End of macro CALLMONITOR
15ed					endif 
15ed ed b0				ldir 
15ef			 
15ef					; de is past string, move back one and store id 
15ef					 
15ef 1b					dec de 
15f0			 
15f0					; store file id 
15f0			 
15f0 e1					pop hl 
15f1 eb					ex de,hl 
15f2 73					ld (hl), e 
15f3			 
15f3					if DEBUG_FORTH_WORDS 
15f3						DMARK "Cdi" 
15f3 f5				push af  
15f4 3a 08 16			ld a, (.dmark)  
15f7 32 77 fb			ld (debug_mark),a  
15fa 3a 09 16			ld a, (.dmark+1)  
15fd 32 78 fb			ld (debug_mark+1),a  
1600 3a 0a 16			ld a, (.dmark+2)  
1603 32 79 fb			ld (debug_mark+2),a  
1606 18 03			jr .pastdmark  
1608 ..			.dmark: db "Cdi"  
160b f1			.pastdmark: pop af  
160c			endm  
# End of macro DMARK
160c						CALLMONITOR 
160c cd 5a 17			call break_point_state  
160f				endm  
# End of macro CALLMONITOR
160f					endif 
160f					 
160f			.dirnotfound: 
160f c1					pop bc     
1610 10 85				djnz .diritem 
1612				 
1612			.dirdone:	 
1612			 
1612 3e 00				ld a, 0 
1614 2a 5e f8				ld hl, (store_tmp2) 
1617 77					ld (hl), a 
1618 23					inc hl 
1619 77					ld (hl), a 
161a 23					inc hl 
161b					; push a count of the dir items found 
161b			 
161b			;		ld h, 0 
161b			;		ld l, c 
161b			 
161b c9				ret 
161c			 
161c			endif 
161c			 
161c			 
161c			; Settings 
161c			; Run  
161c			 
161c			 
161c			 
161c			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
161c			;;hd_menu2:   db "        2: Editor",0   
161c			;hd_menu2:   db "        2: Editor       6: Menu",0   
161c			;hd_menu3:   db "        3: Storage",0 
161c			;hd_menu4:   db "0=quit  4: Debug",0 
161c			;hd_don:     db "ON",0 
161c			;hd_doff:     db "OFF",0 
161c			; 
161c			; 
161c			; 
161c			;hardware_diags_old:       
161c			; 
161c			;.diagmenu: 
161c			;	call clear_display 
161c			;	ld a, display_row_1 
161c			;	ld de, hd_menu1 
161c			;	call str_at_display 
161c			; 
161c			;	ld a, display_row_2 
161c			;	ld de, hd_menu2 
161c			;	call str_at_display 
161c			; 
161c			;	ld a, display_row_3 
161c			;	ld de, hd_menu3 
161c			;	call str_at_display 
161c			; 
161c			;	ld a,  display_row_4 
161c			;	ld de, hd_menu4 
161c			;	call str_at_display 
161c			; 
161c			;	; display debug state 
161c			; 
161c			;	ld de, hd_don 
161c			;	ld a, (os_view_disable) 
161c			;	cp 0 
161c			;	jr z, .distog 
161c			;	ld de, hd_doff 
161c			;.distog: ld a, display_row_4+17 
161c			;	call str_at_display 
161c			; 
161c			;	call update_display 
161c			; 
161c			;	call cin_wait 
161c			; 
161c			; 
161c			; 
161c			;	cp '4' 
161c			;	jr nz, .diagn1 
161c			; 
161c			;	; debug toggle 
161c			; 
161c			;	ld a, (os_view_disable) 
161c			;	ld b, '*' 
161c			;	cp 0 
161c			;	jr z, .debtog 
161c			;	ld b, 0 
161c			;.debtog:	 
161c			;	ld a,b 
161c			;	ld (os_view_disable),a 
161c			; 
161c			;.diagn1: cp '0' 
161c			;	 ret z 
161c			; 
161c			;;	cp '1' 
161c			;;       jp z, matrix	 
161c			;;   TODO keyboard matrix test 
161c			; 
161c			;	cp '2' 
161c			;	jp z, .diagedit 
161c			; 
161c			;;	cp '6' 
161c			;;	jp z, .menutest 
161c			;;if ENABLE_BASIC 
161c			;;	cp '6' 
161c			;;	jp z, basic 
161c			;;endif 
161c			 ; 
161c			;	jp .diagmenu 
161c			; 
161c			; 
161c			;	ret 
161c			 
161c			 
161c			.debug_tog: 
161c 21 63 16			ld hl, .menudebug 
161f				 
161f 3a 0e ee			ld a, (os_view_disable) 
1622 fe 2a			cp '*' 
1624 20 04			jr nz,.tdon  
1626 3e 01			ld a, 1 
1628 18 02			jr .tog1 
162a 3e 00		.tdon: ld a, 0 
162c			 
162c			.tog1: 
162c cd 1a 0b			call menu 
162f fe 00			cp 0 
1631 c8				ret z 
1632 fe 01			cp 1    ; disable debug 
1634 28 04			jr z, .dtog0 
1636 3e 2a			ld a, '*' 
1638 18 02			jr .dtogset 
163a 3e 00		.dtog0: ld a, 0 
163c 32 0e ee		.dtogset:  ld (os_view_disable), a 
163f c3 1c 16			jp .debug_tog 
1642			 
1642			 
1642			hardware_diags:       
1642			 
1642			.diagm: 
1642 21 55 16			ld hl, .menuitems 
1645 3e 00			ld a, 0 
1647 cd 1a 0b			call menu 
164a			 
164a fe 00		         cp 0 
164c c8				 ret z 
164d			 
164d fe 02			cp 2 
164f ca ae 16			jp z, .diagedit 
1652			 
1652			;	cp '6' 
1652			;	jp z, .menutest 
1652			;if ENABLE_BASIC 
1652			;	cp '6' 
1652			;	jp z, basic 
1652			;endif 
1652			  
1652 c3 42 16			jp .diagm 
1655			 
1655				 
1655 69 16		.menuitems:   	dw .m1 
1657 74 16				dw .m2 
1659 7b 16				dw .m3 
165b 83 16				dw .m5 
165d 89 16				dw .m5a 
165f 92 16				dw .m5b 
1661 00 00				dw 0 
1663			 
1663			.menudebug: 
1663 9b 16				dw .m6 
1665 a4 16				dw .m7 
1667 00 00				dw 0 
1669			 
1669 .. 00		.m1:   db "Key Matrix",0 
1674 .. 00		.m2:   db "Editor",0 
167b .. 00		.m3:   db "Storage",0 
1683 .. 00		.m5:   db "Sound",0 
1689 .. 00		.m5a:  db "RAM Test",0 
1692 .. 00		.m5b:  db "LCD Test",0 
169b			 
169b .. 00		.m6:   db "Debug ON",0 
16a4 .. 00		.m7:   db "Debug OFF",0 
16ae			 
16ae			; debug editor 
16ae			 
16ae			.diagedit: 
16ae			 
16ae 21 1d ee			ld hl, scratch 
16b1			;	ld bc, 250 
16b1			;	ldir 
16b1				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
16b1 3e 00			ld a, 0 
16b3 77				ld (hl), a 
16b4 23				inc hl 
16b5 77				ld (hl), a 
16b6 23				inc hl 
16b7 77				ld (hl), a 
16b8			 
16b8 cd e9 0a		        call clear_display 
16bb cd 0c 0b			call update_display 
16be 3e 01			ld a, 1 
16c0 32 7d fb			ld (hardware_diag), a 
16c3			.diloop: 
16c3 3e 00			ld a, display_row_1 
16c5 0e 00			ld c, 0 
16c7 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
16c9 1e 28			ld e, 40 
16cb			 
16cb 21 1d ee			ld hl, scratch	 
16ce cd 4a 0d			call input_str 
16d1			 
16d1 3e 28			ld a, display_row_2 
16d3 11 1d ee			ld de, scratch 
16d6 cd fc 0a			call str_at_display 
16d9 cd 0c 0b			call update_display 
16dc			 
16dc c3 c3 16			jp .diloop 
16df			 
16df			 
16df			; pass word in hl 
16df			; a has display location 
16df			display_word_at: 
16df f5				push af 
16e0 e5				push hl 
16e1 7c				ld a,h 
16e2 21 22 f1			ld hl, os_word_scratch 
16e5 cd 1e 10			call hexout 
16e8 e1				pop hl 
16e9 7d				ld a,l 
16ea 21 24 f1			ld hl, os_word_scratch+2 
16ed cd 1e 10			call hexout 
16f0 21 26 f1			ld hl, os_word_scratch+4 
16f3 3e 00			ld a,0 
16f5 77				ld (hl),a 
16f6 11 22 f1			ld de,os_word_scratch 
16f9 f1				pop af 
16fa cd fc 0a				call str_at_display 
16fd c9				ret 
16fe			 
16fe			display_ptr_state: 
16fe			 
16fe				; to restore afterwards 
16fe			 
16fe d5				push de 
16ff c5				push bc 
1700 e5				push hl 
1701 f5				push af 
1702			 
1702				; for use in here 
1702			 
1702			;	push bc 
1702			;	push de 
1702			;	push hl 
1702			;	push af 
1702			 
1702 cd e9 0a			call clear_display 
1705			 
1705 11 d8 18			ld de, .ptrstate 
1708 3e 00			ld a, display_row_1 
170a cd fc 0a			call str_at_display 
170d			 
170d				; display debug step 
170d			 
170d			 
170d 11 77 fb			ld de, debug_mark 
1710 3e 26			ld a, display_row_1+display_cols-2 
1712 cd fc 0a			call str_at_display 
1715			 
1715				; display a 
1715 11 e2 18			ld de, .ptrcliptr 
1718 3e 28			ld a, display_row_2 
171a cd fc 0a			call str_at_display 
171d			 
171d f1				pop af 
171e 2a 28 f8			ld hl,(cli_ptr) 
1721 3e 30			ld a, display_row_2+8 
1723 cd df 16			call display_word_at 
1726			 
1726			 
1726				; display hl 
1726			 
1726			 
1726 11 ea 18			ld de, .ptrclioptr 
1729 3e 32			ld a, display_row_2+10 
172b cd fc 0a			call str_at_display 
172e			; 
172e			;	pop hl 
172e 3e 35			ld a, display_row_2+13 
1730 2a 26 f8			ld hl,(cli_origptr) 
1733 cd df 16			call display_word_at 
1736			; 
1736			;	 
1736			;	; display de 
1736			 
1736			;	ld de, .regstatede 
1736			;	ld a, display_row_3 
1736			;	call str_at_display 
1736			 
1736			;	pop de 
1736			;	ld h,d 
1736			;	ld l, e 
1736			;	ld a, display_row_3+3 
1736			;	call display_word_at 
1736			 
1736			 
1736				; display bc 
1736			 
1736			;	ld de, .regstatebc 
1736			;	ld a, display_row_3+10 
1736			;	call str_at_display 
1736			 
1736			;	pop bc 
1736			;	ld h,b 
1736			;	ld l, c 
1736			;	ld a, display_row_3+13 
1736			;	call display_word_at 
1736			 
1736			 
1736				; display dsp 
1736			 
1736			;	ld de, .regstatedsp 
1736			;	ld a, display_row_4 
1736			;	call str_at_display 
1736			 
1736				 
1736			;	ld hl,(cli_data_sp) 
1736			;	ld a, display_row_4+4 
1736			;	call display_word_at 
1736			 
1736				; display rsp 
1736			 
1736 11 19 19			ld de, .regstatersp 
1739 3e 82			ld a, display_row_4+10 
173b cd fc 0a			call str_at_display 
173e			 
173e				 
173e 2a 0e f8			ld hl,(cli_ret_sp) 
1741 3e 86			ld a, display_row_4+14 
1743 cd df 16			call display_word_at 
1746			 
1746 cd 0c 0b			call update_display 
1749			 
1749 cd 69 0a			call delay1s 
174c cd 69 0a			call delay1s 
174f cd 69 0a			call delay1s 
1752			 
1752			 
1752 cd 62 1c			call next_page_prompt 
1755			 
1755				; restore  
1755			 
1755 f1				pop af 
1756 e1				pop hl 
1757 c1				pop bc 
1758 d1				pop de 
1759 c9				ret 
175a			 
175a			break_point_state: 
175a f5				push af 
175b			 
175b				; see if disabled 
175b			 
175b 3a 0e ee			ld a, (os_view_disable) 
175e fe 2a			cp '*' 
1760 20 02			jr nz, .bpsgo 
1762 f1				pop af 
1763 c9				ret 
1764			 
1764			.bpsgo: 
1764 f1				pop af 
1765 f5				push af 
1766 22 0a ee			ld (os_view_hl), hl 
1769 ed 53 08 ee		ld (os_view_de), de 
176d ed 43 06 ee		ld (os_view_bc), bc 
1771 e5				push hl 
1772 6f				ld l, a 
1773 26 00			ld h, 0 
1775 22 0c ee			ld (os_view_af),hl 
1778			 
1778 21 bd fa				ld hl, display_fb0 
177b 22 d8 f8				ld (display_fb_active), hl 
177e e1				pop hl	 
177f			 
177f 3e 31			ld a, '1' 
1781 fe 2a		.bps1:  cp '*' 
1783 20 03			jr nz, .bps1b 
1785 32 0e ee			ld (os_view_disable),a 
1788 fe 31		.bps1b:  cp '1' 
178a 20 14			jr nz, .bps2 
178c			 
178c				; display reg 
178c			 
178c				 
178c			 
178c 3a 0c ee			ld a, (os_view_af) 
178f 2a 0a ee			ld hl, (os_view_hl) 
1792 ed 5b 08 ee		ld de, (os_view_de) 
1796 ed 4b 06 ee		ld bc, (os_view_bc) 
179a cd 34 18			call display_reg_state 
179d c3 20 18			jp .bpschk 
17a0			 
17a0 fe 32		.bps2:  cp '2' 
17a2 20 08			jr nz, .bps3 
17a4				 
17a4				; display hl 
17a4 2a 0a ee			ld hl, (os_view_hl) 
17a7 cd 1e 19			call display_dump_at_hl 
17aa			 
17aa 18 74			jr .bpschk 
17ac			 
17ac fe 33		.bps3:  cp '3' 
17ae 20 08			jr nz, .bps4 
17b0			 
17b0			        ; display de 
17b0 2a 08 ee			ld hl, (os_view_de) 
17b3 cd 1e 19			call display_dump_at_hl 
17b6			 
17b6 18 68			jr .bpschk 
17b8 fe 34		.bps4:  cp '4' 
17ba 20 08			jr nz, .bps5 
17bc			 
17bc			        ; display bc 
17bc 2a 06 ee			ld hl, (os_view_bc) 
17bf cd 1e 19			call display_dump_at_hl 
17c2			 
17c2 18 5c			jr .bpschk 
17c4 fe 35		.bps5:  cp '5' 
17c6 20 08		        jr nz, .bps7 
17c8			 
17c8				; display cur ptr 
17c8 2a 28 f8			ld hl, (cli_ptr) 
17cb cd 1e 19			call display_dump_at_hl 
17ce			 
17ce 18 50			jr .bpschk 
17d0 fe 36		.bps7:  cp '6' 
17d2 20 08			jr nz, .bps8b 
17d4				 
17d4				; display cur orig ptr 
17d4 2a 26 f8			ld hl, (cli_origptr) 
17d7 cd 1e 19			call display_dump_at_hl 
17da 18 44			jr .bpschk 
17dc fe 37		.bps8b:  cp '7' 
17de 20 08			jr nz, .bps9 
17e0				 
17e0				; display dsp 
17e0 2a 0a f8			ld hl, (cli_data_sp) 
17e3 cd 1e 19			call display_dump_at_hl 
17e6			 
17e6 18 38			jr .bpschk 
17e8 fe 39		.bps9:  cp '9' 
17ea 20 05			jr nz, .bps8c 
17ec				 
17ec				; display SP 
17ec			;	ld hl, sp 
17ec cd 1e 19			call display_dump_at_hl 
17ef			 
17ef 18 2f			jr .bpschk 
17f1 fe 38		.bps8c:  cp '8' 
17f3 20 08			jr nz, .bps8d 
17f5				 
17f5				; display rsp 
17f5 2a 0e f8			ld hl, (cli_ret_sp) 
17f8 cd 1e 19			call display_dump_at_hl 
17fb			 
17fb 18 23			jr .bpschk 
17fd fe 23		.bps8d:  cp '#'     ; access monitor sub system 
17ff 20 05			jr nz, .bps8 
1801 cd 58 1a			call monitor 
1804			 
1804 18 1a			jr .bpschk 
1806 fe 30		.bps8:  cp '0' 
1808 20 16			jr nz, .bpschk 
180a			 
180a 21 1c fa				ld hl, display_fb1 
180d 22 d8 f8				ld (display_fb_active), hl 
1810 cd 0c 0b				call update_display 
1813			 
1813				;ld a, (os_view_af) 
1813 2a 0a ee			ld hl, (os_view_hl) 
1816 ed 5b 08 ee		ld de, (os_view_de) 
181a ed 4b 06 ee		ld bc, (os_view_bc) 
181e f1				pop af 
181f c9				ret 
1820			 
1820			.bpschk:   
1820 cd 69 0a			call delay1s 
1823 3e 9f		ld a,display_row_4 + display_cols - 1 
1825 11 60 1c		        ld de, endprg 
1828 cd fc 0a			call str_at_display 
182b cd 0c 0b			call update_display 
182e cd 19 69			call cin_wait 
1831			 
1831 c3 81 17			jp .bps1 
1834			 
1834			 
1834			display_reg_state: 
1834			 
1834				; to restore afterwards 
1834			 
1834 d5				push de 
1835 c5				push bc 
1836 e5				push hl 
1837 f5				push af 
1838			 
1838				; for use in here 
1838			 
1838 c5				push bc 
1839 d5				push de 
183a e5				push hl 
183b f5				push af 
183c			 
183c cd e9 0a			call clear_display 
183f			 
183f 11 f4 18			ld de, .regstate 
1842 3e 00			ld a, display_row_1 
1844 cd fc 0a			call str_at_display 
1847			 
1847				; display debug step 
1847			 
1847			 
1847 11 77 fb			ld de, debug_mark 
184a 3e 25			ld a, display_row_1+display_cols-3 
184c cd fc 0a			call str_at_display 
184f			 
184f				; display a 
184f 11 10 19			ld de, .regstatea 
1852 3e 28			ld a, display_row_2 
1854 cd fc 0a			call str_at_display 
1857			 
1857 e1				pop hl 
1858			;	ld h,0 
1858			;	ld l, a 
1858 3e 2b			ld a, display_row_2+3 
185a cd df 16			call display_word_at 
185d			 
185d			 
185d				; display hl 
185d			 
185d			 
185d 11 04 19			ld de, .regstatehl 
1860 3e 32			ld a, display_row_2+10 
1862 cd fc 0a			call str_at_display 
1865			 
1865 e1				pop hl 
1866 3e 35			ld a, display_row_2+13 
1868 cd df 16			call display_word_at 
186b			 
186b				 
186b				; display de 
186b			 
186b 11 08 19			ld de, .regstatede 
186e 3e 50			ld a, display_row_3 
1870 cd fc 0a			call str_at_display 
1873			 
1873 e1				pop hl 
1874			;	ld h,d 
1874			;	ld l, e 
1874 3e 53			ld a, display_row_3+3 
1876 cd df 16			call display_word_at 
1879			 
1879			 
1879				; display bc 
1879			 
1879 11 0c 19			ld de, .regstatebc 
187c 3e 5a			ld a, display_row_3+10 
187e cd fc 0a			call str_at_display 
1881			 
1881 e1				pop hl 
1882			;	ld h,b 
1882			;	ld l, c 
1882 3e 5d			ld a, display_row_3+13 
1884 cd df 16			call display_word_at 
1887			 
1887			 
1887				; display dsp 
1887			 
1887 11 14 19			ld de, .regstatedsp 
188a 3e 78			ld a, display_row_4 
188c cd fc 0a			call str_at_display 
188f			 
188f				 
188f 2a 0a f8			ld hl,(cli_data_sp) 
1892 3e 7c			ld a, display_row_4+4 
1894 cd df 16			call display_word_at 
1897			 
1897				; display rsp 
1897			 
1897 11 19 19			ld de, .regstatersp 
189a 3e 82			ld a, display_row_4+10 
189c cd fc 0a			call str_at_display 
189f			 
189f				 
189f 2a 0e f8			ld hl,(cli_ret_sp) 
18a2 3e 86			ld a, display_row_4+14 
18a4 cd df 16			call display_word_at 
18a7			 
18a7 cd 0c 0b			call update_display 
18aa			 
18aa			;	call delay1s 
18aa			;	call delay1s 
18aa			;	call delay1s 
18aa			 
18aa			 
18aa			;	call next_page_prompt 
18aa			 
18aa				; restore  
18aa			 
18aa f1				pop af 
18ab e1				pop hl 
18ac c1				pop bc 
18ad d1				pop de 
18ae c9				ret 
18af			 
18af .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
18c3 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
18d8 .. 00		.ptrstate:	db "Ptr State",0 
18e2 .. 00		.ptrcliptr:     db "cli_ptr",0 
18ea .. 00		.ptrclioptr:     db "cli_o_ptr",0 
18f4 .. 00		.regstate:	db "Reg State (1/0)",0 
1904 .. 00		.regstatehl:	db "HL:",0 
1908 .. 00		.regstatede:	db "DE:",0 
190c .. 00		.regstatebc:	db "BC:",0 
1910 .. 00		.regstatea:	db "A :",0 
1914 .. 00		.regstatedsp:	db "DSP:",0 
1919 .. 00		.regstatersp:	db "RSP:",0 
191e			 
191e			display_dump_at_hl: 
191e e5				push hl 
191f d5				push de 
1920 c5				push bc 
1921 f5				push af 
1922			 
1922 22 40 f1			ld (os_cur_ptr),hl	 
1925 cd e9 0a			call clear_display 
1928 cd 6a 1b			call dumpcont 
192b			;	call delay1s 
192b			;	call next_page_prompt 
192b			 
192b			 
192b f1				pop af 
192c c1				pop bc 
192d d1				pop de 
192e e1				pop hl 
192f c9				ret 
1930			 
1930			;if ENABLE_BASIC 
1930			;	include "nascombasic.asm" 
1930			;	basic: 
1930			;	include "forth/FORTH.ASM" 
1930			;endif 
1930			 
1930			; eof 
1930			 
1930			 
# End of file firmware_diags.asm
1930			  
1930			  
1930			  
1930			  
1930			; eof  
1930			  
# End of file firmware.asm
1930			 
1930			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1930			;if BASE_KEV  
1930			;baseram: equ 08000h 
1930			;endif 
1930			 
1930			;if BASE_SC114 
1930			;baseram:     equ    endofcode 
1930			;endif 
1930			 
1930			 
1930			; start system 
1930			 
1930			coldstart: 
1930				; set sp 
1930				; di/ei 
1930			 
1930 f3				di 
1931 31 fd ff			ld sp, tos 
1934			;	ei 
1934			 
1934			 
1934				; disable breakpoint by default 
1934			 
1934 3e 2a			ld a,'*' 
1936 32 0e ee			ld (os_view_disable),a 
1939			 
1939				; init hardware 
1939			 
1939				; init keyboard and screen hardware 
1939			 
1939 cd 03 00			call hardware_init 
193c			 
193c			 
193c				; detect if any keys are held down to enable breakpoints at start up 
193c			 
193c cd 2a 69			call cin  
193f fe 00			cp 0 
1941 28 03			jr z, .nokeys 
1943			 
1943				;call hardware_diags 
1943 cd a7 13			call config 
1946			 
1946			;	ld de, .bpen 
1946			;	ld a, display_row_4 
1946			;	call str_at_display 
1946			;	call update_display 
1946			; 
1946			;	ld a,0 
1946			;	ld (os_view_disable),a 
1946			; 
1946			;.bpwait: 
1946			;	call cin 
1946			;	cp 0 
1946			;	jr z, .bpwait 
1946			;	jr .nokeys 
1946			; 
1946			; 
1946			;.bpen:  db "Break points enabled!",0 
1946			 
1946			 
1946			 
1946			 
1946			 
1946			 
1946			.nokeys: 
1946			 
1946			 
1946				 
1946			 
1946			;jp  testkey 
1946			 
1946			;call storage_get_block_0 
1946			; 
1946			;ld hl, 0 
1946			;ld de, store_page 
1946			;call storage_read_block 
1946			 
1946				 
1946			;ld hl, 10 
1946			;ld de, store_page 
1946			;call storage_read_block 
1946			 
1946			 
1946			 
1946			 
1946			 
1946			;stop:	nop 
1946			;	jp stop 
1946			 
1946			 
1946			 
1946			main: 
1946 cd e9 0a			call clear_display 
1949 cd 0c 0b			call update_display 
194c			 
194c			 
194c			 
194c			;	call testlcd 
194c			 
194c			 
194c			 
194c cd 28 20			call forth_init 
194f			 
194f			 
194f			warmstart: 
194f cd fe 1f			call forth_warmstart 
1952			 
1952				; run startup word load 
1952			        ; TODO prevent this running at warmstart after crash  
1952			 
1952				if STARTUP_ENABLE 
1952					if STORAGE_SE 
1952 cd b8 64					call forth_autoload 
1955					endif 
1955 cd c7 61				call forth_startup 
1958			 
1958			 
1958				endif 
1958			 
1958				; show free memory after boot 
1958 11 f2 19			ld de, freeram 
195b 3e 00			ld a, display_row_1 
195d cd fc 0a			call str_at_display 
1960			 
1960			; Or use heap_size word???? 
1960 21 03 ee			ld hl, heap_end 
1963 11 0e 80			ld de, heap_start 
1966 ed 52			sbc hl, de 
1968 e5				push hl 
1969 7c				ld a,h	         	 
196a 21 22 f1			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
196d cd 1e 10			call hexout 
1970 e1			   	pop hl 
1971			 
1971 7d				ld a,l 
1972 21 24 f1			ld hl, os_word_scratch+2 
1975 cd 1e 10			call hexout 
1978 21 26 f1			ld hl, os_word_scratch+4 
197b 3e 00			ld a, 0 
197d 77				ld (hl),a 
197e 11 22 f1			ld de, os_word_scratch 
1981 3e 0d			ld a, display_row_1 + 13 
1983 cd fc 0a			call str_at_display 
1986 cd 0c 0b			call update_display 
1989			 
1989			 
1989				;call demo 
1989			 
1989			 
1989				; init scratch input area for cli commands 
1989			 
1989 21 44 f1			ld hl, os_cli_cmd 
198c 3e 00			ld a,0 
198e 77				ld (hl),a 
198f 23				inc hl 
1990 77				ld (hl),a 
1991			 
1991 3e 00			ld a,0 
1993 32 43 f2			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1996			 
1996 32 40 f1			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1999 32 41 f1			ld (os_cur_ptr+1),a	 
199c			 
199c 32 22 f1			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
199f 32 23 f1			ld (os_word_scratch+1),a	 
19a2				 
19a2			 
19a2				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
19a2 21 44 f1			ld hl, os_cli_cmd 
19a5			 
19a5 3e 00			ld a, 0		 ; init cli input 
19a7 77				ld (hl), a 
19a8 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
19aa			cli: 
19aa				; show cli prompt 
19aa				;push af 
19aa				;ld a, 0 
19aa				;ld de, prompt 
19aa				;call str_at_display 
19aa			 
19aa				;call update_display 
19aa				;pop af 
19aa				;inc a 
19aa				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
19aa 0e 00			ld c, 0 
19ac 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
19ae 1e 28			ld e, 40 
19b0			 
19b0 21 44 f1			ld hl, os_cli_cmd 
19b3			 
19b3				STACKFRAME OFF $fefe $9f9f 
19b3				if DEBUG_STACK_IMB 
19b3					if OFF 
19b3						exx 
19b3						ld de, $fefe 
19b3						ld a, d 
19b3						ld hl, curframe 
19b3						call hexout 
19b3						ld a, e 
19b3						ld hl, curframe+2 
19b3						call hexout 
19b3						ld hl, $fefe 
19b3						push hl 
19b3						ld hl, $9f9f 
19b3						push hl 
19b3						exx 
19b3					endif 
19b3				endif 
19b3			endm 
# End of macro STACKFRAME
19b3			 
19b3 cd 4a 0d			call input_str 
19b6			 
19b6				STACKFRAMECHK OFF $fefe $9f9f 
19b6				if DEBUG_STACK_IMB 
19b6					if OFF 
19b6						exx 
19b6						ld hl, $9f9f 
19b6						pop de   ; $9f9f 
19b6						call cmp16 
19b6						jr nz, .spnosame 
19b6						ld hl, $fefe 
19b6						pop de   ; $fefe 
19b6						call cmp16 
19b6						jr z, .spfrsame 
19b6						.spnosame: call showsperror 
19b6						.spfrsame: nop 
19b6						exx 
19b6					endif 
19b6				endif 
19b6			endm 
# End of macro STACKFRAMECHK
19b6			 
19b6				; copy input to last command 
19b6			 
19b6 21 44 f1			ld hl, os_cli_cmd 
19b9 11 43 f2			ld de, os_last_cmd 
19bc 01 ff 00			ld bc, 255 
19bf ed b0			ldir 
19c1			 
19c1				; wipe current buffer 
19c1			 
19c1			;	ld a, 0 
19c1			;	ld hl, os_cli_cmd 
19c1			;	ld de, os_cli_cmd+1 
19c1			;	ld bc, 254 
19c1			;	ldir 
19c1				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
19c1			;	call strcpy 
19c1			;	ld a, 0 
19c1			;	ld (hl), a 
19c1			;	inc hl 
19c1			;	ld (hl), a 
19c1			;	inc hl 
19c1			;	ld (hl), a 
19c1			 
19c1				; switch frame buffer to program  
19c1			 
19c1 21 1c fa				ld hl, display_fb1 
19c4 22 d8 f8				ld (display_fb_active), hl 
19c7			 
19c7			;	nop 
19c7				STACKFRAME ON $fbfe $8f9f 
19c7				if DEBUG_STACK_IMB 
19c7					if ON 
19c7						exx 
19c7						ld de, $fbfe 
19c7						ld a, d 
19c7						ld hl, curframe 
19c7						call hexout 
19c7						ld a, e 
19c7						ld hl, curframe+2 
19c7						call hexout 
19c7						ld hl, $fbfe 
19c7						push hl 
19c7						ld hl, $8f9f 
19c7						push hl 
19c7						exx 
19c7					endif 
19c7				endif 
19c7			endm 
# End of macro STACKFRAME
19c7				; first time into the parser so pass over the current scratch pad 
19c7 21 44 f1			ld hl,os_cli_cmd 
19ca				; tokenise the entered statement(s) in HL 
19ca cd a1 20			call forthparse 
19cd			        ; exec forth statements in top of return stack 
19cd cd e1 20			call forthexec 
19d0				;call forthexec_cleanup 
19d0			;	call parsenext 
19d0			 
19d0				STACKFRAMECHK ON $fbfe $8f9f 
19d0				if DEBUG_STACK_IMB 
19d0					if ON 
19d0						exx 
19d0						ld hl, $8f9f 
19d0						pop de   ; $8f9f 
19d0						call cmp16 
19d0						jr nz, .spnosame 
19d0						ld hl, $fbfe 
19d0						pop de   ; $fbfe 
19d0						call cmp16 
19d0						jr z, .spfrsame 
19d0						.spnosame: call showsperror 
19d0						.spfrsame: nop 
19d0						exx 
19d0					endif 
19d0				endif 
19d0			endm 
# End of macro STACKFRAMECHK
19d0				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
19d0			 
19d0 3e 78			ld a, display_row_4 
19d2 11 04 1a			ld de, endprog 
19d5			 
19d5 cd 0c 0b			call update_display		 
19d8			 
19d8 cd 62 1c			call next_page_prompt 
19db			 
19db				; switch frame buffer to cli 
19db			 
19db 21 bd fa				ld hl, display_fb0 
19de 22 d8 f8				ld (display_fb_active), hl 
19e1			 
19e1			 
19e1 cd e9 0a		        call clear_display 
19e4 cd 0c 0b			call update_display		 
19e7			 
19e7 21 44 f1			ld hl, os_cli_cmd 
19ea			 
19ea 3e 00			ld a, 0		 ; init cli input 
19ec 77				ld (hl), a 
19ed			 
19ed				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
19ed			 
19ed				; now on last line 
19ed			 
19ed				; TODO scroll screen up 
19ed			 
19ed				; TODO instead just clear screen and place at top of screen 
19ed			 
19ed			;	ld a, 0 
19ed			;	ld (f_cursor_ptr),a 
19ed			 
19ed				;call clear_display 
19ed				;call update_display 
19ed			 
19ed				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
19ed 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
19ef c3 aa 19			jp cli 
19f2			 
19f2 .. 00		freeram: db "Free bytes: $",0 
1a00 ..			asc: db "1A2F" 
1a04 .. 00		endprog: db "End prog...",0 
1a10			 
1a10			testenter2:   
1a10 21 4f ee			ld hl,scratch+50 
1a13 22 40 f1			ld (os_cur_ptr),hl 
1a16 c3 aa 19			jp cli 
1a19			 
1a19			testenter:  
1a19			 
1a19 21 00 1a			ld hl,asc 
1a1c			;	ld a,(hl) 
1a1c			;	call nibble2val 
1a1c cd 74 10			call get_byte 
1a1f			 
1a1f			 
1a1f			;	ld a,(hl) 
1a1f			;	call atohex 
1a1f			 
1a1f			;	call fourehexhl 
1a1f 32 4f ee			ld (scratch+50),a 
1a22			 
1a22			 
1a22			 
1a22 21 02 1a			ld hl,asc+2 
1a25			;	ld a, (hl) 
1a25			;	call nibble2val 
1a25 cd 74 10			call get_byte 
1a28			 
1a28			;	call fourehexhl 
1a28 32 51 ee			ld (scratch+52),a 
1a2b				 
1a2b 21 4f ee			ld hl,scratch+50 
1a2e 22 40 f1			ld (os_cur_ptr),hl 
1a31 c3 aa 19			jp cli 
1a34			 
1a34			enter:	 
1a34 3a 21 ee			ld a,(scratch+4) 
1a37 fe 00			cp 0 
1a39 28 0c			jr z, .entercont 
1a3b				; no, not a null term line so has an address to work out.... 
1a3b			 
1a3b 21 1f ee			ld hl,scratch+2 
1a3e cd d4 10			call get_word_hl 
1a41			 
1a41 22 40 f1			ld (os_cur_ptr),hl	 
1a44 c3 aa 19			jp cli 
1a47			 
1a47			 
1a47			.entercont:  
1a47			 
1a47 21 1f ee			ld hl, scratch+2 
1a4a cd 74 10			call get_byte 
1a4d			 
1a4d 2a 40 f1		   	ld hl,(os_cur_ptr) 
1a50 77					ld (hl),a 
1a51 23					inc hl 
1a52 22 40 f1				ld (os_cur_ptr),hl 
1a55				 
1a55			; get byte  
1a55			 
1a55			 
1a55 c3 aa 19			jp cli 
1a58			 
1a58			 
1a58			; basic monitor support 
1a58			 
1a58			monitor: 
1a58				;  
1a58 cd e9 0a			call clear_display 
1a5b 3e 00			ld a, 0 
1a5d 11 a5 1a			ld de, .monprompt 
1a60 cd fc 0a			call str_at_display 
1a63 cd 0c 0b			call update_display 
1a66			 
1a66				; get a monitor command 
1a66			 
1a66 0e 00			ld c, 0     ; entry at top left 
1a68 16 64			ld d, 100   ; max buffer size 
1a6a 1e 0f			ld e, 15    ; input scroll area 
1a6c 3e 00			ld a, 0     ; init string 
1a6e 21 1b f0			ld hl, os_input 
1a71 77				ld (hl), a 
1a72 23				inc hl 
1a73 77				ld (hl), a 
1a74 21 1b f0			ld hl, os_input 
1a77 3e 01			ld a, 1     ; init string 
1a79 cd 4a 0d			call input_str 
1a7c			 
1a7c cd e9 0a		        call clear_display 
1a7f cd 0c 0b			call update_display		 
1a82			 
1a82 3a 1b f0			ld a, (os_input) 
1a85 cd 72 11			call toUpper 
1a88 fe 48		        cp 'H' 
1a8a 28 6f		        jr z, .monhelp 
1a8c fe 44			cp 'D'		; dump 
1a8e ca 1c 1b			jp z, .mondump	 
1a91 fe 43			cp 'C'		; dump 
1a93 ca 36 1b			jp z, .moncdump	 
1a96 fe 4d			cp 'M'		; dump 
1a98 ca a7 1a			jp z, .moneditstart 
1a9b fe 55			cp 'U'		; dump 
1a9d 28 14			jr z, .monedit	 
1a9f fe 51			cp 'Q'		; dump 
1aa1 c8				ret z	 
1aa2			 
1aa2			 
1aa2				; TODO "S" to access symbol by name and not need the address 
1aa2				; TODO "F" to find a string in memory 
1aa2			 
1aa2 c3 58 1a			jp monitor 
1aa5			 
1aa5 .. 00		.monprompt: db ">", 0 
1aa7			 
1aa7			.moneditstart: 
1aa7				; get starting address 
1aa7			 
1aa7 21 1d f0			ld hl,os_input+2 
1aaa cd d4 10			call get_word_hl 
1aad			 
1aad 22 40 f1			ld (os_cur_ptr),hl	 
1ab0			 
1ab0 c3 58 1a			jp monitor 
1ab3			 
1ab3			.monedit: 
1ab3				; get byte to load 
1ab3			 
1ab3 21 1d f0			ld hl,os_input+2 
1ab6 cd 74 10			call get_byte 
1ab9			 
1ab9				; get address to update 
1ab9 2a 40 f1			ld hl, (os_cur_ptr) 
1abc			 
1abc				; update byte 
1abc			 
1abc 77				ld (hl), a 
1abd			 
1abd				; move to next address and save it 
1abd			 
1abd 23				inc hl 
1abe 22 40 f1			ld (os_cur_ptr),hl	 
1ac1			 
1ac1 c3 58 1a			jp monitor 
1ac4			 
1ac4			 
1ac4 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1ad8 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1af4 .. 00		.monhelptext3:  db "Q-Quit",0 
1afb			        
1afb			.monhelp: 
1afb 3e 00			ld a, display_row_1 
1afd 11 c4 1a		        ld de, .monhelptext1 
1b00			 
1b00 cd fc 0a			call str_at_display 
1b03 3e 28			ld a, display_row_2 
1b05 11 d8 1a		        ld de, .monhelptext2 
1b08					 
1b08 cd fc 0a			call str_at_display 
1b0b 3e 50			ld a, display_row_3 
1b0d 11 f4 1a		        ld de, .monhelptext3 
1b10					 
1b10 cd fc 0a			call str_at_display 
1b13 cd 0c 0b			call update_display		 
1b16			 
1b16 cd 62 1c			call next_page_prompt 
1b19 c3 58 1a			jp monitor 
1b1c			 
1b1c			.mondump:    
1b1c 21 1d f0			ld hl,os_input+2 
1b1f cd d4 10			call get_word_hl 
1b22			 
1b22 22 40 f1			ld (os_cur_ptr),hl	 
1b25 cd 6a 1b			call dumpcont 
1b28 3e 78			ld a, display_row_4 
1b2a 11 04 1a			ld de, endprog 
1b2d			 
1b2d cd 0c 0b			call update_display		 
1b30			 
1b30 cd 62 1c			call next_page_prompt 
1b33 c3 58 1a			jp monitor 
1b36			.moncdump: 
1b36 cd 6a 1b			call dumpcont 
1b39 3e 78			ld a, display_row_4 
1b3b 11 04 1a			ld de, endprog 
1b3e			 
1b3e cd 0c 0b			call update_display		 
1b41			 
1b41 cd 62 1c			call next_page_prompt 
1b44 c3 58 1a			jp monitor 
1b47			 
1b47			 
1b47			; TODO symbol access  
1b47			 
1b47			.symbols:     ;; A list of symbols that can be called up  
1b47 bd fa			dw display_fb0 
1b49 .. 00			db "fb0",0  
1b4d 62 f8		     	dw store_page 
1b4f .. 00			db "store_page",0 
1b5a			 
1b5a			 
1b5a			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1b5a			 
1b5a 3a 1e ee			ld a,(scratch+1) 
1b5d fe 00			cp 0 
1b5f 28 09			jr z, dumpcont 
1b61			 
1b61				; no, not a null term line so has an address to work out.... 
1b61			 
1b61 21 1f ee			ld hl,scratch+2 
1b64 cd d4 10			call get_word_hl 
1b67			 
1b67 22 40 f1			ld (os_cur_ptr),hl	 
1b6a			 
1b6a			 
1b6a			 
1b6a			dumpcont: 
1b6a			 
1b6a				; dump bytes at ptr 
1b6a			 
1b6a			 
1b6a 3e 00			ld a, display_row_1 
1b6c 2a d8 f8			ld hl, (display_fb_active) 
1b6f cd 1d 0d			call addatohl 
1b72 cd 9a 1b			call .dumpbyterow 
1b75			 
1b75 3e 28			ld a, display_row_2 
1b77 2a d8 f8			ld hl, (display_fb_active) 
1b7a cd 1d 0d			call addatohl 
1b7d cd 9a 1b			call .dumpbyterow 
1b80			 
1b80			 
1b80 3e 50			ld a, display_row_3 
1b82 2a d8 f8			ld hl, (display_fb_active) 
1b85 cd 1d 0d			call addatohl 
1b88 cd 9a 1b			call .dumpbyterow 
1b8b			 
1b8b 3e 78			ld a, display_row_4 
1b8d 2a d8 f8			ld hl, (display_fb_active) 
1b90 cd 1d 0d			call addatohl 
1b93 cd 9a 1b			call .dumpbyterow 
1b96			 
1b96 cd 0c 0b			call update_display 
1b99			;		jp cli 
1b99 c9				ret 
1b9a			 
1b9a			.dumpbyterow: 
1b9a			 
1b9a				;push af 
1b9a			 
1b9a e5				push hl 
1b9b			 
1b9b				; calc where to poke the ascii 
1b9b			if display_cols == 20 
1b9b				ld a, 16 
1b9b			else 
1b9b 3e 1f			ld a, 31 
1b9d			endif 
1b9d			 
1b9d cd 1d 0d			call addatohl 
1ba0 22 22 f1			ld (os_word_scratch),hl  		; save pos for later 
1ba3			 
1ba3			 
1ba3			; display decoding address 
1ba3 2a 40 f1		   	ld hl,(os_cur_ptr) 
1ba6			 
1ba6 7c				ld a,h 
1ba7 e1				pop hl 
1ba8 e5				push hl 
1ba9			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1ba9 cd 1e 10			call hexout 
1bac 2a 40 f1		   	ld hl,(os_cur_ptr) 
1baf			 
1baf 7d				ld a,l 
1bb0 e1				pop hl 
1bb1 23				inc hl 
1bb2 23				inc hl 
1bb3 e5				push hl 
1bb4			;	ld hl, os_word_scratch+2 
1bb4 cd 1e 10			call hexout 
1bb7 e1				pop hl 
1bb8 23				inc hl 
1bb9 23				inc hl 
1bba				;ld hl, os_word_scratch+4 
1bba 3e 3a			ld a, ':' 
1bbc 77				ld (hl),a 
1bbd 23				inc hl 
1bbe				;ld a, 0 
1bbe				;ld (hl),a 
1bbe				;ld de, os_word_scratch 
1bbe				;pop af 
1bbe				;push af 
1bbe			;		ld a, display_row_2 
1bbe			;		call str_at_display 
1bbe			;		call update_display 
1bbe			 
1bbe			 
1bbe			;pop af 
1bbe			;	add 5 
1bbe			 
1bbe			if display_cols == 20 
1bbe				ld b, 4 
1bbe			else 
1bbe 06 08			ld b, 8 
1bc0			endif	 
1bc0			 
1bc0			.dumpbyte: 
1bc0 c5				push bc 
1bc1 e5				push hl 
1bc2			 
1bc2			 
1bc2 2a 40 f1		   	ld hl,(os_cur_ptr) 
1bc5 7e					ld a,(hl) 
1bc6			 
1bc6					; poke the ascii to display 
1bc6 2a 22 f1				ld hl,(os_word_scratch) 
1bc9 77					ld (hl),a 
1bca 23					inc hl 
1bcb 22 22 f1				ld (os_word_scratch),hl 
1bce			 
1bce					 
1bce			 
1bce			 
1bce e1					pop hl 
1bcf e5					push hl 
1bd0			 
1bd0 cd 1e 10				call hexout 
1bd3			 
1bd3					 
1bd3 2a 40 f1		   	ld hl,(os_cur_ptr) 
1bd6 23				inc hl 
1bd7 22 40 f1		   	ld (os_cur_ptr),hl 
1bda			 
1bda e1					pop hl 
1bdb 23					inc hl 
1bdc 23					inc hl 
1bdd 23					inc hl 
1bde			 
1bde			 
1bde			 
1bde					;ld a,0 
1bde					;ld (os_word_scratch+2),a 
1bde					;pop af 
1bde					;push af 
1bde			 
1bde					;ld de, os_word_scratch 
1bde					;call str_at_display 
1bde			;		call update_display 
1bde			;		pop af 
1bde c1					pop bc 
1bdf c6 03				add 3 
1be1 10 dd			djnz .dumpbyte 
1be3			 
1be3				 
1be3			 
1be3 c9				ret 
1be4			 
1be4			jump:	 
1be4			 
1be4 21 1f ee			ld hl,scratch+2 
1be7 cd d4 10			call get_word_hl 
1bea				;ld hl,(scratch+2) 
1bea				;call fourehexhl 
1bea			 
1bea 22 40 f1			ld (os_cur_ptr),hl	 
1bed			 
1bed e9				jp (hl) 
1bee			 
1bee			 
1bee			 
1bee			; TODO implement a basic monitor mode to start with 
1bee			 
1bee			 
1bee			 
1bee			 
1bee			 
1bee			 
1bee			 
1bee			 
1bee			 
1bee			; testing and demo code during development 
1bee			 
1bee			 
1bee .. 00		str1: db "Enter some text...",0 
1c01 .. 00		clear: db "                    ",0 
1c16			 
1c16			demo: 
1c16			 
1c16			 
1c16			 
1c16			;	call update_display 
1c16			 
1c16				; init scratch input area for testing 
1c16 21 1d ee			ld hl, scratch	 
1c19 3e 00			ld a,0 
1c1b 77				ld (hl),a 
1c1c			 
1c1c			 
1c1c 3e 28		            LD   A, display_row_2 
1c1e			;            CALL fLCD_Pos       ;Position cursor to location in A 
1c1e 11 ee 1b		            LD   DE, str1 
1c21 cd fc 0a			call str_at_display 
1c24			 
1c24			;            CALL fLCD_Str       ;Display string pointed to by DE 
1c24			cloop:	 
1c24 3e 50		            LD   A, display_row_3 
1c26			;            CALL fLCD_Pos       ;Position cursor to location in A 
1c26 11 01 1c		            LD   DE, clear 
1c29			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1c29 cd fc 0a				call str_at_display 
1c2c 3e 78			ld a, display_row_4 
1c2e 11 5e 1c			ld de, prompt 
1c31			 
1c31 cd fc 0a				call str_at_display 
1c34 cd 0c 0b			call update_display 
1c37			 
1c37 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1c39 16 0a			ld d, 10 
1c3b 21 1d ee			ld hl, scratch	 
1c3e cd 4a 0d			call input_str 
1c41			 
1c41			;	call clear_display 
1c41			;'	call update_display 
1c41			 
1c41 3e 00		            LD   A, display_row_1 
1c43			;            CALL fLCD_Pos       ;Position cursor to location in A 
1c43 11 01 1c		            LD   DE, clear 
1c46 cd fc 0a				call str_at_display 
1c49			;            CALL fLCD_Str       ;Display string pointed to by DE 
1c49 3e 00		            LD   A, display_row_1 
1c4b			;            CALL fLCD_Pos       ;Position cursor to location in A 
1c4b 11 1d ee		            LD   DE, scratch 
1c4e			;            CALL fLCD_Str       ;Display string pointed to by DE 
1c4e cd fc 0a				call str_at_display 
1c51 cd 0c 0b			call update_display 
1c54			 
1c54 3e 00				ld a,0 
1c56 21 1d ee			ld hl, scratch 
1c59 77				ld (hl),a 
1c5a			 
1c5a 00				nop 
1c5b c3 24 1c			jp cloop 
1c5e			 
1c5e			 
1c5e			 
1c5e			; OS Prompt 
1c5e			 
1c5e .. 00		prompt: db ">",0 
1c60 .. 00		endprg: db "?",0 
1c62			 
1c62			 
1c62			; handy next page prompt 
1c62			next_page_prompt: 
1c62 e5				push hl 
1c63 d5				push de 
1c64 f5				push af 
1c65 c5				push bc 
1c66			 
1c66 3e 9f			ld a,display_row_4 + display_cols - 1 
1c68 11 60 1c		        ld de, endprg 
1c6b cd fc 0a			call str_at_display 
1c6e cd 0c 0b			call update_display 
1c71 cd 19 69			call cin_wait 
1c74 c1				pop bc 
1c75 f1				pop af 
1c76 d1				pop de 
1c77 e1				pop hl 
1c78			 
1c78			 
1c78 c9				ret 
1c79			 
1c79			 
1c79			; forth parser 
1c79			 
1c79			; My forth kernel 
1c79			include "forth_kernel.asm" 
1c79			; 
1c79			; kernel to the forth OS 
1c79			 
1c79			DS_TYPE_STR: equ 1     ; string type 
1c79			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1c79			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1c79			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1c79			 
1c79			FORTH_PARSEV1: equ 0 
1c79			FORTH_PARSEV2: equ 0 
1c79			FORTH_PARSEV3: equ 0 
1c79			FORTH_PARSEV4: equ 0 
1c79			FORTH_PARSEV5: equ 1 
1c79			 
1c79			;if FORTH_PARSEV5 
1c79			;	FORTH_END_BUFFER: equ 0 
1c79			;else 
1c79			FORTH_END_BUFFER: equ 127 
1c79			;endif 
1c79			 
1c79			FORTH_TRUE: equ 1 
1c79			FORTH_FALSE: equ 0 
1c79			 
1c79			if FORTH_PARSEV4 
1c79			include "forth_stackops.asm" 
1c79			endif 
1c79			 
1c79			if FORTH_PARSEV5 
1c79			include "forth_stackopsv5.asm" 
1c79			 
1c79			; Stack operations for v5 parser on wards 
1c79			; * DATA stack 
1c79			; * LOOP stack 
1c79			; * RETURN stack 
1c79			 
1c79			 
1c79			 
1c79			FORTH_CHK_DSP_UNDER: macro 
1c79				push hl 
1c79				push de 
1c79				ld hl,(cli_data_sp) 
1c79				ld de, cli_data_stack 
1c79				call cmp16 
1c79				jp c, fault_dsp_under 
1c79				pop de 
1c79				pop hl 
1c79				endm 
1c79			 
1c79			 
1c79			FORTH_CHK_RSP_UNDER: macro 
1c79				push hl 
1c79				push de 
1c79				ld hl,(cli_ret_sp) 
1c79				ld de, cli_ret_stack 
1c79				call cmp16 
1c79				jp c, fault_rsp_under 
1c79				pop de 
1c79				pop hl 
1c79				endm 
1c79			 
1c79			FORTH_CHK_LOOP_UNDER: macro 
1c79				push hl 
1c79				push de 
1c79				ld hl,(cli_loop_sp) 
1c79				ld de, cli_loop_stack 
1c79				call cmp16 
1c79				jp c, fault_loop_under 
1c79				pop de 
1c79				pop hl 
1c79				endm 
1c79			 
1c79			FORTH_ERR_TOS_NOTSTR: macro 
1c79				; TOSO might need more for checks when used 
1c79				push af 
1c79				ld a,(hl) 
1c79				cp DS_TYPE_STR 
1c79				jp nz, type_faultn   
1c79				pop af 
1c79				endm 
1c79			 
1c79			FORTH_ERR_TOS_NOTNUM: macro 
1c79				push af 
1c79				ld a,(hl) 
1c79				cp DS_TYPE_INUM 
1c79				jp nz, type_faultn   
1c79				pop af 
1c79				endm 
1c79			 
1c79			 
1c79			; increase data stack pointer and save hl to it 
1c79				 
1c79			FORTH_DSP_NEXT: macro 
1c79				call macro_forth_dsp_next 
1c79				endm 
1c79			 
1c79			 
1c79			macro_forth_dsp_next: 
1c79				if DEBUG_FORTH_STACK_GUARD 
1c79 cd 91 62				call check_stacks 
1c7c				endif 
1c7c e5				push hl 
1c7d d5				push de 
1c7e eb				ex de,hl 
1c7f 2a 0a f8			ld hl,(cli_data_sp) 
1c82 23				inc hl 
1c83 23				inc hl 
1c84			 
1c84			; PARSEV5 
1c84 23				inc hl 
1c85 22 0a f8			ld (cli_data_sp),hl 
1c88 73				ld (hl), e 
1c89 23				inc hl 
1c8a 72				ld (hl), d 
1c8b d1				pop de 
1c8c e1				pop hl 
1c8d				if DEBUG_FORTH_STACK_GUARD 
1c8d cd 91 62				call check_stacks 
1c90				endif 
1c90 c9				ret 
1c91			 
1c91			 
1c91			; increase ret stack pointer and save hl to it 
1c91				 
1c91			FORTH_RSP_NEXT: macro 
1c91				call macro_forth_rsp_next 
1c91				endm 
1c91			 
1c91			macro_forth_rsp_next: 
1c91				if DEBUG_FORTH_STACK_GUARD 
1c91 cd 91 62				call check_stacks 
1c94				endif 
1c94 e5				push hl 
1c95 d5				push de 
1c96 eb				ex de,hl 
1c97 2a 0e f8			ld hl,(cli_ret_sp) 
1c9a 23				inc hl 
1c9b 23				inc hl 
1c9c 22 0e f8			ld (cli_ret_sp),hl 
1c9f 73				ld (hl), e 
1ca0 23				inc hl 
1ca1 72				ld (hl), d 
1ca2 d1				pop de 
1ca3 e1				pop hl 
1ca4				if DEBUG_FORTH_STACK_GUARD 
1ca4 cd 91 62				call check_stacks 
1ca7				endif 
1ca7 c9				ret 
1ca8			 
1ca8			; get current ret stack pointer and save to hl  
1ca8				 
1ca8			FORTH_RSP_TOS: macro 
1ca8				call macro_forth_rsp_tos 
1ca8				endm 
1ca8			 
1ca8			macro_forth_rsp_tos: 
1ca8				;push de 
1ca8 2a 0e f8			ld hl,(cli_ret_sp) 
1cab cd e3 1c			call loadhlptrtohl 
1cae				;ld e, (hl) 
1cae				;inc hl 
1cae				;ld d, (hl) 
1cae				;ex de, hl 
1cae					if DEBUG_FORTH_WORDS 
1cae			;			DMARK "RST" 
1cae						CALLMONITOR 
1cae cd 5a 17			call break_point_state  
1cb1				endm  
# End of macro CALLMONITOR
1cb1					endif 
1cb1				;pop de 
1cb1 c9				ret 
1cb2			 
1cb2			; pop ret stack pointer 
1cb2				 
1cb2			FORTH_RSP_POP: macro 
1cb2				call macro_forth_rsp_pop 
1cb2				endm 
1cb2			 
1cb2			 
1cb2			macro_forth_rsp_pop: 
1cb2				if DEBUG_FORTH_STACK_GUARD 
1cb2			;		DMARK "RPP" 
1cb2 cd 91 62				call check_stacks 
1cb5					FORTH_CHK_RSP_UNDER 
1cb5 e5				push hl 
1cb6 d5				push de 
1cb7 2a 0e f8			ld hl,(cli_ret_sp) 
1cba 11 88 f7			ld de, cli_ret_stack 
1cbd cd 3b 0d			call cmp16 
1cc0 da a5 63			jp c, fault_rsp_under 
1cc3 d1				pop de 
1cc4 e1				pop hl 
1cc5				endm 
# End of macro FORTH_CHK_RSP_UNDER
1cc5				endif 
1cc5 e5				push hl 
1cc6 2a 0e f8			ld hl,(cli_ret_sp) 
1cc9			 
1cc9			 
1cc9				if FORTH_ENABLE_FREE 
1cc9			 
1cc9					; get pointer 
1cc9			 
1cc9					push de 
1cc9					push hl 
1cc9			 
1cc9					ld e, (hl) 
1cc9					inc hl 
1cc9					ld d, (hl) 
1cc9			 
1cc9					ex de, hl 
1cc9					call free 
1cc9			 
1cc9					pop hl 
1cc9					pop de 
1cc9			 
1cc9			 
1cc9				endif 
1cc9			 
1cc9			 
1cc9 2b				dec hl 
1cca 2b				dec hl 
1ccb 22 0e f8			ld (cli_ret_sp), hl 
1cce				; do stack underflow checks 
1cce e1				pop hl 
1ccf				if DEBUG_FORTH_STACK_GUARD 
1ccf cd 91 62				call check_stacks 
1cd2					FORTH_CHK_RSP_UNDER 
1cd2 e5				push hl 
1cd3 d5				push de 
1cd4 2a 0e f8			ld hl,(cli_ret_sp) 
1cd7 11 88 f7			ld de, cli_ret_stack 
1cda cd 3b 0d			call cmp16 
1cdd da a5 63			jp c, fault_rsp_under 
1ce0 d1				pop de 
1ce1 e1				pop hl 
1ce2				endm 
# End of macro FORTH_CHK_RSP_UNDER
1ce2				endif 
1ce2 c9				ret 
1ce3			 
1ce3			 
1ce3			 
1ce3			; routine to load word pointed to by hl into hl 
1ce3			 
1ce3			loadhlptrtohl: 
1ce3			 
1ce3 d5				push de 
1ce4 5e				ld e, (hl) 
1ce5 23				inc hl 
1ce6 56				ld d, (hl) 
1ce7 eb				ex de, hl 
1ce8 d1				pop de 
1ce9			 
1ce9 c9				ret 
1cea			 
1cea			 
1cea			 
1cea			 
1cea			 
1cea			; push a number held in HL onto the data stack 
1cea			; entry point for pushing a value when already in hl used in function above 
1cea			 
1cea			forth_push_numhl: 
1cea			 
1cea e5				push hl    ; save value to push 
1ceb			 
1ceb			if DEBUG_FORTH_PUSH 
1ceb				; see if disabled 
1ceb			 
1ceb			 
1ceb f5				push af 
1cec 3a 0e ee			ld a, (os_view_disable) 
1cef fe 2a			cp '*' 
1cf1 28 34			jr z, .pskip2 
1cf3 e5				push hl 
1cf4 e5			push hl 
1cf5 cd e9 0a			call clear_display 
1cf8 e1			pop hl 
1cf9 7c				ld a,h 
1cfa 21 22 f1			ld hl, os_word_scratch 
1cfd cd 1e 10			call hexout 
1d00 e1				pop hl 
1d01 7d				ld a,l 
1d02 21 24 f1			ld hl, os_word_scratch+2 
1d05 cd 1e 10			call hexout 
1d08			 
1d08 21 26 f1			ld hl, os_word_scratch+4 
1d0b 3e 00			ld a,0 
1d0d 77				ld (hl),a 
1d0e 11 22 f1			ld de,os_word_scratch 
1d11 3e 28				ld a, display_row_2 
1d13 cd fc 0a				call str_at_display 
1d16 11 9f 51			ld de, .push_num 
1d19 3e 00			ld a, display_row_1 
1d1b			 
1d1b cd fc 0a				call str_at_display 
1d1e			 
1d1e			 
1d1e cd 0c 0b			call update_display 
1d21 cd 69 0a			call delay1s 
1d24 cd 69 0a			call delay1s 
1d27			.pskip2:  
1d27			 
1d27 f1				pop af 
1d28			endif	 
1d28			 
1d28			 
1d28				FORTH_DSP_NEXT 
1d28 cd 79 1c			call macro_forth_dsp_next 
1d2b				endm 
# End of macro FORTH_DSP_NEXT
1d2b			 
1d2b 2a 0a f8			ld hl, (cli_data_sp) 
1d2e			 
1d2e				; save item type 
1d2e 3e 02			ld a,  DS_TYPE_INUM 
1d30 77				ld (hl), a 
1d31 23				inc hl 
1d32			 
1d32				; get word off stack 
1d32 d1				pop de 
1d33 7b				ld a,e 
1d34 77				ld (hl), a 
1d35 23				inc hl 
1d36 7a				ld a,d 
1d37 77				ld (hl), a 
1d38			 
1d38			if DEBUG_FORTH_PUSH 
1d38 2b				dec hl 
1d39 2b				dec hl 
1d3a 2b				dec hl 
1d3b						DMARK "PH5" 
1d3b f5				push af  
1d3c 3a 50 1d			ld a, (.dmark)  
1d3f 32 77 fb			ld (debug_mark),a  
1d42 3a 51 1d			ld a, (.dmark+1)  
1d45 32 78 fb			ld (debug_mark+1),a  
1d48 3a 52 1d			ld a, (.dmark+2)  
1d4b 32 79 fb			ld (debug_mark+2),a  
1d4e 18 03			jr .pastdmark  
1d50 ..			.dmark: db "PH5"  
1d53 f1			.pastdmark: pop af  
1d54			endm  
# End of macro DMARK
1d54				CALLMONITOR 
1d54 cd 5a 17			call break_point_state  
1d57				endm  
# End of macro CALLMONITOR
1d57			endif	 
1d57			 
1d57 c9				ret 
1d58			 
1d58			 
1d58			; Push a string to stack pointed to by hl 
1d58			 
1d58			forth_push_str: 
1d58			 
1d58			if DEBUG_FORTH_PUSH 
1d58						DMARK "PSQ" 
1d58 f5				push af  
1d59 3a 6d 1d			ld a, (.dmark)  
1d5c 32 77 fb			ld (debug_mark),a  
1d5f 3a 6e 1d			ld a, (.dmark+1)  
1d62 32 78 fb			ld (debug_mark+1),a  
1d65 3a 6f 1d			ld a, (.dmark+2)  
1d68 32 79 fb			ld (debug_mark+2),a  
1d6b 18 03			jr .pastdmark  
1d6d ..			.dmark: db "PSQ"  
1d70 f1			.pastdmark: pop af  
1d71			endm  
# End of macro DMARK
1d71				CALLMONITOR 
1d71 cd 5a 17			call break_point_state  
1d74				endm  
# End of macro CALLMONITOR
1d74			endif	 
1d74			    
1d74 e5				push hl 
1d75 e5				push hl 
1d76			 
1d76			;	ld a, 0   ; find end of string 
1d76 cd 7b 11			call strlenz 
1d79			if DEBUG_FORTH_PUSH 
1d79						DMARK "PQ2" 
1d79 f5				push af  
1d7a 3a 8e 1d			ld a, (.dmark)  
1d7d 32 77 fb			ld (debug_mark),a  
1d80 3a 8f 1d			ld a, (.dmark+1)  
1d83 32 78 fb			ld (debug_mark+1),a  
1d86 3a 90 1d			ld a, (.dmark+2)  
1d89 32 79 fb			ld (debug_mark+2),a  
1d8c 18 03			jr .pastdmark  
1d8e ..			.dmark: db "PQ2"  
1d91 f1			.pastdmark: pop af  
1d92			endm  
# End of macro DMARK
1d92				CALLMONITOR 
1d92 cd 5a 17			call break_point_state  
1d95				endm  
# End of macro CALLMONITOR
1d95			endif	 
1d95 eb				ex de, hl 
1d96 e1				pop hl   ; get ptr to start of string 
1d97			if DEBUG_FORTH_PUSH 
1d97						DMARK "PQ3" 
1d97 f5				push af  
1d98 3a ac 1d			ld a, (.dmark)  
1d9b 32 77 fb			ld (debug_mark),a  
1d9e 3a ad 1d			ld a, (.dmark+1)  
1da1 32 78 fb			ld (debug_mark+1),a  
1da4 3a ae 1d			ld a, (.dmark+2)  
1da7 32 79 fb			ld (debug_mark+2),a  
1daa 18 03			jr .pastdmark  
1dac ..			.dmark: db "PQ3"  
1daf f1			.pastdmark: pop af  
1db0			endm  
# End of macro DMARK
1db0				CALLMONITOR 
1db0 cd 5a 17			call break_point_state  
1db3				endm  
# End of macro CALLMONITOR
1db3			endif	 
1db3 19				add hl,de 
1db4			if DEBUG_FORTH_PUSH 
1db4						DMARK "PQE" 
1db4 f5				push af  
1db5 3a c9 1d			ld a, (.dmark)  
1db8 32 77 fb			ld (debug_mark),a  
1dbb 3a ca 1d			ld a, (.dmark+1)  
1dbe 32 78 fb			ld (debug_mark+1),a  
1dc1 3a cb 1d			ld a, (.dmark+2)  
1dc4 32 79 fb			ld (debug_mark+2),a  
1dc7 18 03			jr .pastdmark  
1dc9 ..			.dmark: db "PQE"  
1dcc f1			.pastdmark: pop af  
1dcd			endm  
# End of macro DMARK
1dcd				CALLMONITOR 
1dcd cd 5a 17			call break_point_state  
1dd0				endm  
# End of macro CALLMONITOR
1dd0			endif	 
1dd0			 
1dd0 2b				dec hl    ; see if there is an optional trailing double quote 
1dd1 7e				ld a,(hl) 
1dd2 fe 22			cp '"' 
1dd4 20 03			jr nz, .strnoq 
1dd6 3e 00			ld a, 0      ; get rid of double quote 
1dd8 77				ld (hl), a 
1dd9 23			.strnoq: inc hl 
1dda			 
1dda 3e 00			ld a, 0 
1ddc 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1ddd			 
1ddd 13				inc de ; add one for the type string 
1dde 13				inc de ; add one for null term??? 
1ddf			 
1ddf				; tos is get string pointer again 
1ddf				; de contains space to allocate 
1ddf				 
1ddf d5				push de 
1de0			 
1de0 eb				ex de, hl 
1de1			 
1de1				;push af 
1de1			 
1de1			if DEBUG_FORTH_PUSH 
1de1						DMARK "PHm" 
1de1 f5				push af  
1de2 3a f6 1d			ld a, (.dmark)  
1de5 32 77 fb			ld (debug_mark),a  
1de8 3a f7 1d			ld a, (.dmark+1)  
1deb 32 78 fb			ld (debug_mark+1),a  
1dee 3a f8 1d			ld a, (.dmark+2)  
1df1 32 79 fb			ld (debug_mark+2),a  
1df4 18 03			jr .pastdmark  
1df6 ..			.dmark: db "PHm"  
1df9 f1			.pastdmark: pop af  
1dfa			endm  
# End of macro DMARK
1dfa				CALLMONITOR 
1dfa cd 5a 17			call break_point_state  
1dfd				endm  
# End of macro CALLMONITOR
1dfd			endif	 
1dfd cd e4 11			call malloc	; on ret hl now contains allocated memory 
1e00				if DEBUG_FORTH_MALLOC_GUARD 
1e00 cc f7 51				call z,malloc_error 
1e03				endif 
1e03			 
1e03				 
1e03 c1				pop bc    ; get length 
1e04 d1				pop de   ;  get string start    
1e05			 
1e05				; hl has destination from malloc 
1e05			 
1e05 eb				ex de, hl    ; prep for ldir 
1e06			 
1e06 d5				push de   ; save malloc area for DSP later 
1e07				;push hl   ; save malloc area for DSP later 
1e07			 
1e07			if DEBUG_FORTH_PUSH 
1e07						DMARK "PHc" 
1e07 f5				push af  
1e08 3a 1c 1e			ld a, (.dmark)  
1e0b 32 77 fb			ld (debug_mark),a  
1e0e 3a 1d 1e			ld a, (.dmark+1)  
1e11 32 78 fb			ld (debug_mark+1),a  
1e14 3a 1e 1e			ld a, (.dmark+2)  
1e17 32 79 fb			ld (debug_mark+2),a  
1e1a 18 03			jr .pastdmark  
1e1c ..			.dmark: db "PHc"  
1e1f f1			.pastdmark: pop af  
1e20			endm  
# End of macro DMARK
1e20				CALLMONITOR 
1e20 cd 5a 17			call break_point_state  
1e23				endm  
# End of macro CALLMONITOR
1e23			endif	 
1e23			 
1e23			 
1e23 ed b0			ldir 
1e25			 
1e25			 
1e25				; push malloc to data stack     macro?????  
1e25			 
1e25				FORTH_DSP_NEXT 
1e25 cd 79 1c			call macro_forth_dsp_next 
1e28				endm 
# End of macro FORTH_DSP_NEXT
1e28			 
1e28				; save value and type 
1e28			 
1e28 2a 0a f8			ld hl, (cli_data_sp) 
1e2b			 
1e2b				; save item type 
1e2b 3e 01			ld a,  DS_TYPE_STR 
1e2d 77				ld (hl), a 
1e2e 23				inc hl 
1e2f			 
1e2f				; get malloc word off stack 
1e2f d1				pop de 
1e30 73				ld (hl), e 
1e31 23				inc hl 
1e32 72				ld (hl), d 
1e33			 
1e33			 
1e33			 
1e33			if DEBUG_FORTH_PUSH 
1e33 2a 0a f8			ld hl, (cli_data_sp) 
1e36						DMARK "PHS" 
1e36 f5				push af  
1e37 3a 4b 1e			ld a, (.dmark)  
1e3a 32 77 fb			ld (debug_mark),a  
1e3d 3a 4c 1e			ld a, (.dmark+1)  
1e40 32 78 fb			ld (debug_mark+1),a  
1e43 3a 4d 1e			ld a, (.dmark+2)  
1e46 32 79 fb			ld (debug_mark+2),a  
1e49 18 03			jr .pastdmark  
1e4b ..			.dmark: db "PHS"  
1e4e f1			.pastdmark: pop af  
1e4f			endm  
# End of macro DMARK
1e4f				CALLMONITOR 
1e4f cd 5a 17			call break_point_state  
1e52				endm  
# End of macro CALLMONITOR
1e52			;	ex de,hl 
1e52			endif	 
1e52				; in case of spaces, skip the ptr past the copied string 
1e52				;pop af 
1e52				;ld (cli_origptr),hl 
1e52			 
1e52 c9				ret 
1e53			 
1e53			 
1e53			 
1e53			; TODO ascii push input onto stack given hl to start of input 
1e53			 
1e53			; identify type 
1e53			; if starts with a " then a string 
1e53			; otherwise it is a number 
1e53			;  
1e53			; if a string 
1e53			;     scan for ending " to get length of string to malloc for + 1 
1e53			;     malloc 
1e53			;     put pointer to string on stack first byte flags as string 
1e53			; 
1e53			; else a number 
1e53			;    look for number format identifier 
1e53			;    $xx hex 
1e53			;    %xxxxx bin 
1e53			;    xxxxx decimal 
1e53			;    convert number to 16bit word.  
1e53			;    malloc word + 1 with flag to identiy as num 
1e53			;    put pointer to number on stack 
1e53			;   
1e53			;  
1e53			  
1e53			forth_apush: 
1e53				; kernel push 
1e53			 
1e53			if DEBUG_FORTH_PUSH 
1e53						DMARK "PSH" 
1e53 f5				push af  
1e54 3a 68 1e			ld a, (.dmark)  
1e57 32 77 fb			ld (debug_mark),a  
1e5a 3a 69 1e			ld a, (.dmark+1)  
1e5d 32 78 fb			ld (debug_mark+1),a  
1e60 3a 6a 1e			ld a, (.dmark+2)  
1e63 32 79 fb			ld (debug_mark+2),a  
1e66 18 03			jr .pastdmark  
1e68 ..			.dmark: db "PSH"  
1e6b f1			.pastdmark: pop af  
1e6c			endm  
# End of macro DMARK
1e6c				CALLMONITOR 
1e6c cd 5a 17			call break_point_state  
1e6f				endm  
# End of macro CALLMONITOR
1e6f			endif	 
1e6f				; identify input type 
1e6f			 
1e6f 7e				ld a,(hl) 
1e70 fe 22			cp '"' 
1e72 28 0a			jr z, .fapstr 
1e74 fe 24			cp '$' 
1e76 ca 9e 1e			jp z, .faphex 
1e79 fe 25			cp '%' 
1e7b ca 86 1e			jp z, .fapbin 
1e7e			;	cp 'b' 
1e7e			;	jp z, .fabin 
1e7e				; else decimal 
1e7e			 
1e7e				; TODO do decimal conversion 
1e7e				; decimal is stored as a 16bit word 
1e7e			 
1e7e				; by default everything is a string if type is not detected 
1e7e			.fapstr: ; 
1e7e fe 22			cp '"' 
1e80 20 01			jr nz, .strnoqu 
1e82 23				inc hl 
1e83			.strnoqu: 
1e83 c3 58 1d			jp forth_push_str 
1e86			 
1e86			 
1e86			 
1e86			.fapbin:    ; push a binary string.  
1e86 11 00 00			ld de, 0   ; hold a 16bit value 
1e89			 
1e89 23			.fapbinshift:	inc hl  
1e8a 7e				ld a,(hl) 
1e8b fe 00			cp 0     ; done scanning  
1e8d 28 0b			jr z, .fapbdone  	; got it in HL so push  
1e8f			 
1e8f				; left shift de 
1e8f eb				ex de, hl	 
1e90 29				add hl, hl 
1e91			 
1e91				; is 1 
1e91 fe 31			cp '1' 
1e93 20 02			jr nz, .binzero 
1e95 cb 4d			bit 1, l 
1e97			.binzero: 
1e97 eb				ex de, hl	 ; save current de 
1e98 18 ef			jr .fapbinshift 
1e9a			 
1e9a			.fapbdone: 
1e9a eb				ex de, hl 
1e9b c3 ea 1c			jp forth_push_numhl 
1e9e			 
1e9e			 
1e9e			.faphex:   ; hex is always stored as a 16bit word 
1e9e				; skip number prefix 
1e9e 23				inc hl 
1e9f				; turn ascii into number 
1e9f cd d4 10			call get_word_hl	; ret 16bit word in hl 
1ea2			 
1ea2 c3 ea 1c			jp forth_push_numhl 
1ea5			 
1ea5 00				 nop 
1ea6			 
1ea6			.fabin:   ; TODO bin conversion 
1ea6			 
1ea6			 
1ea6 c9				ret 
1ea7			 
1ea7			 
1ea7			; get either a string ptr or a 16bit word from the data stack 
1ea7			 
1ea7			FORTH_DSP: macro 
1ea7				call macro_forth_dsp 
1ea7				endm 
1ea7			 
1ea7			macro_forth_dsp: 
1ea7				; data stack pointer points to current word on tos 
1ea7			 
1ea7 2a 0a f8			ld hl,(cli_data_sp) 
1eaa			 
1eaa				if DEBUG_FORTH_PUSH 
1eaa						DMARK "DSP" 
1eaa f5				push af  
1eab 3a bf 1e			ld a, (.dmark)  
1eae 32 77 fb			ld (debug_mark),a  
1eb1 3a c0 1e			ld a, (.dmark+1)  
1eb4 32 78 fb			ld (debug_mark+1),a  
1eb7 3a c1 1e			ld a, (.dmark+2)  
1eba 32 79 fb			ld (debug_mark+2),a  
1ebd 18 03			jr .pastdmark  
1ebf ..			.dmark: db "DSP"  
1ec2 f1			.pastdmark: pop af  
1ec3			endm  
# End of macro DMARK
1ec3			 
1ec3 cd 2c 52				call display_data_sp 
1ec6				;call break_point_state 
1ec6				;rst 030h 
1ec6				CALLMONITOR 
1ec6 cd 5a 17			call break_point_state  
1ec9				endm  
# End of macro CALLMONITOR
1ec9				endif 
1ec9			 
1ec9 c9				ret 
1eca			 
1eca			; return hl to start of value on stack 
1eca			 
1eca			FORTH_DSP_VALUE: macro 
1eca				call macro_forth_dsp_value 
1eca				endm 
1eca			 
1eca			macro_forth_dsp_value: 
1eca			 
1eca				FORTH_DSP 
1eca cd a7 1e			call macro_forth_dsp 
1ecd				endm 
# End of macro FORTH_DSP
1ecd			 
1ecd d5				push de 
1ece			 
1ece 23				inc hl ; skip type 
1ecf			 
1ecf 5e				ld e, (hl) 
1ed0 23				inc hl 
1ed1 56				ld d, (hl) 
1ed2 eb				ex de,hl  
1ed3			 
1ed3 d1				pop de 
1ed4			 
1ed4 c9				ret 
1ed5			 
1ed5			; return hl to start of value to second item on stack 
1ed5			 
1ed5			FORTH_DSP_VALUEM1: macro 
1ed5				call macro_forth_dsp_value_m1 
1ed5				endm 
1ed5			 
1ed5			macro_forth_dsp_value_m1: 
1ed5			 
1ed5				FORTH_DSP 
1ed5 cd a7 1e			call macro_forth_dsp 
1ed8				endm 
# End of macro FORTH_DSP
1ed8			 
1ed8 2b				dec hl 
1ed9 2b				dec hl 
1eda			;	dec hl 
1eda			 
1eda d5				push de 
1edb			 
1edb 5e				ld e, (hl) 
1edc 23				inc hl 
1edd 56				ld d, (hl) 
1ede eb				ex de,hl  
1edf			 
1edf d1				pop de 
1ee0			 
1ee0 c9				ret 
1ee1			 
1ee1				 
1ee1			 
1ee1			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1ee1			 
1ee1			FORTH_DSP_POP: macro 
1ee1				call macro_forth_dsp_pop 
1ee1				endm 
1ee1			 
1ee1			 
1ee1			; get the tos data type 
1ee1			 
1ee1			FORTH_DSP_TYPE:   macro 
1ee1			 
1ee1				;FORTH_DSP_VALUE 
1ee1				FORTH_DSP 
1ee1				 
1ee1				; hl points to value 
1ee1				; check type 
1ee1			 
1ee1				ld a,(hl) 
1ee1			 
1ee1				endm 
1ee1			 
1ee1			; load the tos value into hl 
1ee1			 
1ee1			 
1ee1			FORTH_DSP_VALUEHL:  macro 
1ee1				call macro_dsp_valuehl 
1ee1				endm 
1ee1			 
1ee1			 
1ee1			 
1ee1			macro_dsp_valuehl: 
1ee1				FORTH_DSP_VALUE 
1ee1 cd ca 1e			call macro_forth_dsp_value 
1ee4				endm 
# End of macro FORTH_DSP_VALUE
1ee4			 
1ee4				;FORTH_ERR_TOS_NOTNUM 
1ee4			 
1ee4				;inc hl   ; skip type id 
1ee4			 
1ee4			;	push de 
1ee4			; 
1ee4			;	ld e, (hl) 
1ee4			;	inc hl 
1ee4			;	ld d, (hl) 
1ee4			;	ex de,hl  
1ee4			 
1ee4			;	pop de 
1ee4			 
1ee4				if DEBUG_FORTH_PUSH 
1ee4						DMARK "DVL" 
1ee4 f5				push af  
1ee5 3a f9 1e			ld a, (.dmark)  
1ee8 32 77 fb			ld (debug_mark),a  
1eeb 3a fa 1e			ld a, (.dmark+1)  
1eee 32 78 fb			ld (debug_mark+1),a  
1ef1 3a fb 1e			ld a, (.dmark+2)  
1ef4 32 79 fb			ld (debug_mark+2),a  
1ef7 18 03			jr .pastdmark  
1ef9 ..			.dmark: db "DVL"  
1efc f1			.pastdmark: pop af  
1efd			endm  
# End of macro DMARK
1efd				CALLMONITOR 
1efd cd 5a 17			call break_point_state  
1f00				endm  
# End of macro CALLMONITOR
1f00				endif 
1f00 c9				ret 
1f01			 
1f01			forth_apushstrhl:      
1f01				; push of string requires use of cli_origptr 
1f01				; bodge use 
1f01			 
1f01				; get current cli_origptr, save, update with temp pointer  
1f01 ed 5b 26 f8		ld de, (cli_origptr) 
1f05 22 26 f8			ld (cli_origptr), hl 
1f08 d5				push de 
1f09 cd 53 1e			call forth_apush 
1f0c d1				pop de 
1f0d ed 53 26 f8		ld (cli_origptr), de 
1f11 c9			        ret	 
1f12			 
1f12			 
1f12			; increase loop stack pointer and save hl to it 
1f12				 
1f12			FORTH_LOOP_NEXT: macro 
1f12				call macro_forth_loop_next 
1f12				;nop 
1f12				endm 
1f12			 
1f12			macro_forth_loop_next: 
1f12				if DEBUG_FORTH_STACK_GUARD 
1f12 cd 91 62				call check_stacks 
1f15				endif 
1f15 e5				push hl 
1f16 d5				push de 
1f17 eb				ex de,hl 
1f18 2a 0c f8			ld hl,(cli_loop_sp) 
1f1b 23				inc hl 
1f1c 23				inc hl 
1f1d					if DEBUG_FORTH_WORDS 
1f1d						DMARK "LNX" 
1f1d f5				push af  
1f1e 3a 32 1f			ld a, (.dmark)  
1f21 32 77 fb			ld (debug_mark),a  
1f24 3a 33 1f			ld a, (.dmark+1)  
1f27 32 78 fb			ld (debug_mark+1),a  
1f2a 3a 34 1f			ld a, (.dmark+2)  
1f2d 32 79 fb			ld (debug_mark+2),a  
1f30 18 03			jr .pastdmark  
1f32 ..			.dmark: db "LNX"  
1f35 f1			.pastdmark: pop af  
1f36			endm  
# End of macro DMARK
1f36						CALLMONITOR 
1f36 cd 5a 17			call break_point_state  
1f39				endm  
# End of macro CALLMONITOR
1f39					endif 
1f39 22 0c f8			ld (cli_loop_sp),hl 
1f3c 73				ld (hl), e 
1f3d 23				inc hl 
1f3e 72				ld (hl), d 
1f3f d1				pop de    ; been reversed so save a swap on restore 
1f40 e1				pop hl 
1f41				if DEBUG_FORTH_STACK_GUARD 
1f41 cd 91 62				call check_stacks 
1f44				endif 
1f44 c9				ret 
1f45			 
1f45			; get current ret stack pointer and save to hl  
1f45				 
1f45			FORTH_LOOP_TOS: macro 
1f45				call macro_forth_loop_tos 
1f45				endm 
1f45			 
1f45			macro_forth_loop_tos: 
1f45 d5				push de 
1f46 2a 0c f8			ld hl,(cli_loop_sp) 
1f49 5e				ld e, (hl) 
1f4a 23				inc hl 
1f4b 56				ld d, (hl) 
1f4c eb				ex de, hl 
1f4d d1				pop de 
1f4e c9				ret 
1f4f			 
1f4f			; pop loop stack pointer 
1f4f				 
1f4f			FORTH_LOOP_POP: macro 
1f4f				call macro_forth_loop_pop 
1f4f				endm 
1f4f			 
1f4f			 
1f4f			macro_forth_loop_pop: 
1f4f				if DEBUG_FORTH_STACK_GUARD 
1f4f					DMARK "LPP" 
1f4f f5				push af  
1f50 3a 64 1f			ld a, (.dmark)  
1f53 32 77 fb			ld (debug_mark),a  
1f56 3a 65 1f			ld a, (.dmark+1)  
1f59 32 78 fb			ld (debug_mark+1),a  
1f5c 3a 66 1f			ld a, (.dmark+2)  
1f5f 32 79 fb			ld (debug_mark+2),a  
1f62 18 03			jr .pastdmark  
1f64 ..			.dmark: db "LPP"  
1f67 f1			.pastdmark: pop af  
1f68			endm  
# End of macro DMARK
1f68 cd 91 62				call check_stacks 
1f6b					FORTH_CHK_LOOP_UNDER 
1f6b e5				push hl 
1f6c d5				push de 
1f6d 2a 0c f8			ld hl,(cli_loop_sp) 
1f70 11 86 f5			ld de, cli_loop_stack 
1f73 cd 3b 0d			call cmp16 
1f76 da ab 63			jp c, fault_loop_under 
1f79 d1				pop de 
1f7a e1				pop hl 
1f7b				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1f7b				endif 
1f7b e5				push hl 
1f7c 2a 0c f8			ld hl,(cli_loop_sp) 
1f7f 2b				dec hl 
1f80 2b				dec hl 
1f81 22 0c f8			ld (cli_loop_sp), hl 
1f84				; TODO do stack underflow checks 
1f84 e1				pop hl 
1f85				if DEBUG_FORTH_STACK_GUARD 
1f85 cd 91 62				call check_stacks 
1f88					FORTH_CHK_LOOP_UNDER 
1f88 e5				push hl 
1f89 d5				push de 
1f8a 2a 0c f8			ld hl,(cli_loop_sp) 
1f8d 11 86 f5			ld de, cli_loop_stack 
1f90 cd 3b 0d			call cmp16 
1f93 da ab 63			jp c, fault_loop_under 
1f96 d1				pop de 
1f97 e1				pop hl 
1f98				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1f98				endif 
1f98 c9				ret 
1f99			 
1f99			macro_forth_dsp_pop: 
1f99			 
1f99 e5				push hl 
1f9a			 
1f9a				; release malloc data 
1f9a			 
1f9a				if DEBUG_FORTH_STACK_GUARD 
1f9a cd 91 62				call check_stacks 
1f9d					FORTH_CHK_DSP_UNDER 
1f9d e5				push hl 
1f9e d5				push de 
1f9f 2a 0a f8			ld hl,(cli_data_sp) 
1fa2 11 84 f3			ld de, cli_data_stack 
1fa5 cd 3b 0d			call cmp16 
1fa8 da 9f 63			jp c, fault_dsp_under 
1fab d1				pop de 
1fac e1				pop hl 
1fad				endm 
# End of macro FORTH_CHK_DSP_UNDER
1fad				endif 
1fad				;ld hl,(cli_data_sp) 
1fad			if DEBUG_FORTH_DOT 
1fad				DMARK "DPP" 
1fad				CALLMONITOR 
1fad			endif	 
1fad			 
1fad			 
1fad			if FORTH_ENABLE_DSPPOPFREE 
1fad			 
1fad				FORTH_DSP 
1fad cd a7 1e			call macro_forth_dsp 
1fb0				endm 
# End of macro FORTH_DSP
1fb0			 
1fb0 7e				ld a, (hl) 
1fb1 fe 01			cp DS_TYPE_STR 
1fb3 20 07			jr nz, .skippopfree 
1fb5			 
1fb5				FORTH_DSP_VALUEHL 
1fb5 cd e1 1e			call macro_dsp_valuehl 
1fb8				endm 
# End of macro FORTH_DSP_VALUEHL
1fb8 00				nop 
1fb9			if DEBUG_FORTH_DOT 
1fb9				DMARK "DPf" 
1fb9				CALLMONITOR 
1fb9			endif	 
1fb9 cd ae 12			call free 
1fbc			.skippopfree: 
1fbc				 
1fbc			 
1fbc			endif 
1fbc			 
1fbc			if DEBUG_FORTH_DOT_KEY 
1fbc				DMARK "DP2" 
1fbc				CALLMONITOR 
1fbc			endif	 
1fbc			 
1fbc				; move pointer down 
1fbc			 
1fbc 2a 0a f8			ld hl,(cli_data_sp) 
1fbf 2b				dec hl 
1fc0 2b				dec hl 
1fc1			; PARSEV5 
1fc1 2b				dec hl 
1fc2 22 0a f8			ld (cli_data_sp), hl 
1fc5			 
1fc5				if DEBUG_FORTH_STACK_GUARD 
1fc5 cd 91 62				call check_stacks 
1fc8					FORTH_CHK_DSP_UNDER 
1fc8 e5				push hl 
1fc9 d5				push de 
1fca 2a 0a f8			ld hl,(cli_data_sp) 
1fcd 11 84 f3			ld de, cli_data_stack 
1fd0 cd 3b 0d			call cmp16 
1fd3 da 9f 63			jp c, fault_dsp_under 
1fd6 d1				pop de 
1fd7 e1				pop hl 
1fd8				endm 
# End of macro FORTH_CHK_DSP_UNDER
1fd8				endif 
1fd8			 
1fd8 e1				pop hl 
1fd9			 
1fd9 c9				ret 
1fda			 
1fda			getwordathl: 
1fda				; hl points to an address 
1fda				; load hl with the word at that address 
1fda			 
1fda d5				push de 
1fdb			 
1fdb 5e				ld e, (hl) 
1fdc 23				inc hl 
1fdd 56				ld d, (hl) 
1fde eb				ex de, hl 
1fdf			 
1fdf d1				pop de 
1fe0 c9				ret 
1fe1			 
1fe1			 
1fe1			 
1fe1			 
1fe1			 
1fe1			; eof 
1fe1			 
# End of file forth_stackopsv5.asm
1fe1			endif 
1fe1			 
1fe1			user_word_eol:  
1fe1				; hl contains the pointer to where to create a linked list item from the end 
1fe1				; of the user dict to continue on at the system word dict 
1fe1				 
1fe1				; poke the stub of the word list linked list to repoint to rom words 
1fe1			 
1fe1				; stub format 
1fe1				; db   word id 
1fe1				; dw    link to next word 
1fe1			        ; db char length of token 
1fe1				; db string + 0 term 
1fe1				; db exec code....  
1fe1			 
1fe1 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1fe3 77				ld (hl), a		; word id 
1fe4 23				inc hl 
1fe5			 
1fe5 11 ab 21			ld de, sysdict 
1fe8 73				ld (hl), e		; next word link ie system dict 
1fe9 23				inc hl 
1fea 72				ld (hl), d		; next word link ie system dict 
1feb 23				inc hl	 
1fec			 
1fec			;	ld (hl), sysdict		; next word link ie system dict 
1fec			;	inc hl 
1fec			;	inc hl 
1fec			 
1fec			;	inc hl 
1fec			;	inc hl 
1fec			 
1fec 3e 02			ld a, 2			; word length is 0 
1fee 77				ld (hl), a	 
1fef 23				inc hl 
1ff0			 
1ff0 3e 7e			ld a, '~'			; word length is 0 
1ff2 77				ld (hl), a	 
1ff3 23				inc hl 
1ff4 3e 00			ld a, 0			; save empty word 
1ff6 77				ld (hl), a 
1ff7			 
1ff7 c9				ret 
1ff8			 
1ff8				 
1ff8			 
1ff8			forthexec_cleanup: 
1ff8				FORTH_RSP_POP 
1ff8 cd b2 1c			call macro_forth_rsp_pop 
1ffb				endm 
# End of macro FORTH_RSP_POP
1ffb c9				ret 
1ffc			 
1ffc			forth_call_hl: 
1ffc				; taking hl 
1ffc e5				push hl 
1ffd c9				ret 
1ffe			 
1ffe			; this is called to reset Forth system but keep existing uwords etc 
1ffe			 
1ffe			forth_warmstart: 
1ffe				; setup stack over/under flow checks 
1ffe				if DEBUG_FORTH_STACK_GUARD 
1ffe cd 77 62				call chk_stk_init 
2001				endif 
2001			 
2001				; init stack pointers  - * these stacks go upwards *  
2001 21 88 f7			ld hl, cli_ret_stack 
2004 22 0e f8			ld (cli_ret_sp), hl	 
2007				; set bottom of stack 
2007 3e 00			ld a,0 
2009 77				ld (hl),a 
200a 23				inc hl 
200b 77				ld (hl),a 
200c			 
200c 21 84 f3			ld hl, cli_data_stack 
200f 22 0a f8			ld (cli_data_sp), hl	 
2012				; set bottom of stack 
2012 3e 00			ld a,0 
2014 77				ld (hl),a 
2015 23				inc hl 
2016 77				ld (hl),a 
2017			 
2017 21 86 f5			ld hl, cli_loop_stack 
201a 22 0c f8			ld (cli_loop_sp), hl	 
201d				; set bottom of stack 
201d 3e 00			ld a,0 
201f 77				ld (hl),a 
2020 23				inc hl 
2021 77				ld (hl),a 
2022			 
2022				; init extent of current open file 
2022			 
2022 3e 00			ld a, 0 
2024 32 59 f8			ld (store_openext), a 
2027			 
2027 c9				ret 
2028			 
2028			 
2028			; Cold Start - this is called to setup the whole Forth system 
2028			 
2028			forth_init: 
2028			 
2028				; setup stack over/under flow checks 
2028			 
2028			;	if DEBUG_FORTH_STACK_GUARD 
2028			;		call chk_stk_init 
2028			;	endif 
2028			 
2028				; enable auto display updates (slow.....) 
2028			 
2028 3e 01			ld a, 1 
202a 32 24 f8			ld (cli_autodisplay), a 
202d			 
202d			 
202d			 
202d				; show start up screen 
202d			 
202d cd e9 0a			call clear_display 
2030			 
2030 3e 00			ld a,0 
2032 32 46 f8			ld (f_cursor_ptr), a 
2035			 
2035				; set start of word list in start of ram - for use when creating user words 
2035			 
2035 21 00 80			ld hl, baseram 
2038 22 1a f1			ld (os_last_new_uword), hl 
203b cd e1 1f			call user_word_eol 
203e				 
203e			;		call display_data_sp 
203e			;		call next_page_prompt 
203e			 
203e			 
203e			 
203e			 
203e c9				ret 
203f			 
203f .. 00		.bootforth: db " Forth Kernel Init ",0 
2053			 
2053			; TODO push to stack 
2053			 
2053			;  
2053			 
2053			if FORTH_PARSEV2 
2053			 
2053			 
2053				include "forth_parserv2.asm" 
2053			 
2053			endif 
2053			 
2053			 
2053			; parse cli version 1 
2053			 
2053			if FORTH_PARSEV1 
2053			 
2053			 
2053			 
2053			      include "forth_parserv1.asm" 
2053			endif 
2053				 
2053			if FORTH_PARSEV3 
2053			 
2053			 
2053			 
2053			      include "forth_parserv3.asm" 
2053				include "forth_wordsv3.asm" 
2053			endif 
2053			 
2053			if FORTH_PARSEV4 
2053			 
2053			 
2053			 
2053			      include "forth_parserv4.asm" 
2053				include "forth_wordsv4.asm" 
2053			endif 
2053			 
2053			if FORTH_PARSEV5 
2053			 
2053			 
2053			 
2053			      include "forth_parserv5.asm" 
2053			 
2053			 
2053			; A better parser without using malloc and string copies all over the place.  
2053			; Exec in situ should be faster 
2053			 
2053			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
2053			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
2053			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
2053			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
2053			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
2053			WORD_SYS_END: equ 0   ; Opcode for all user words 
2053			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
2053			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
2053			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
2053			 
2053			; Core word preamble macro 
2053			 
2053			CWHEAD:   macro nxtword opcode lit len opflags 
2053				db WORD_SYS_CORE+opcode             
2053				; internal op code number 
2053				dw nxtword            
2053				; link to next dict word block 
2053				db len + 1 
2053				; literal length of dict word inc zero term 
2053				db lit,0              
2053				; literal dict word 
2053			        ; TODO db opflags        
2053				endm 
2053			 
2053			 
2053			NEXTW: macro  
2053				jp macro_next 
2053				endm 
2053			 
2053			macro_next: 
2053			if DEBUG_FORTH_PARSE_KEY 
2053				DMARK "NXT" 
2053				CALLMONITOR 
2053			endif	 
2053			;	inc hl  ; skip token null term  
2053 ed 4b 28 f8		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
2057 ed 5b 26 f8		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
205b 2a 1e f1			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
205e			if DEBUG_FORTH_PARSE_KEY 
205e				DMARK "}AA" 
205e				CALLMONITOR 
205e			endif	 
205e c3 61 21			jp execnext 
2061				;jp exec1 
2061			       
2061			 
2061			 
2061			; Another go at the parser to compile  
2061			 
2061			 
2061			; TODO rework parser to change all of the string words to byte tokens 
2061			; TODO do a search for  
2061			 
2061			; TODO first run normal parser to zero term sections 
2061			; TODO for each word do a token look up to get the op code 
2061			; TODO need some means to flag to the exec that this is a byte code form    
2061			 
2061			 
2061			forthcompile: 
2061			 
2061			; 
2061			; line parse: 
2061			;       parse raw input buffer 
2061			;       tokenise the words 
2061			;       malloc new copy (for looping etc) 
2061			;       copy to malloc + current pc in line to start of string and add line term 
2061			;       save on new rsp 
2061			; 
2061			 
2061			; hl to point to the line to tokenise 
2061			 
2061			;	push hl 
2061 22 1e f1			ld (os_tok_ptr), hl  ; save ptr to string 
2064			 
2064			;	ld a,0		; string term on input 
2064			;	call strlent 
2064			 
2064			;	ld (os_tok_len), hl	 ; save string length 
2064			 
2064			;if DEBUG_FORTH_TOK 
2064			;	ex de,hl		 
2064			;endif 
2064			 
2064			;	pop hl 		; get back string pointer 
2064			 
2064			if DEBUG_FORTH_TOK 
2064						DMARK "TOc" 
2064				CALLMONITOR 
2064			endif 
2064 7e			.cptoken2:    ld a,(hl) 
2065 23				inc hl 
2066 fe 7f			cp FORTH_END_BUFFER 
2068 28 29			jr z, .cptokendone2 
206a fe 00			cp 0 
206c 28 25			jr z, .cptokendone2 
206e fe 22			cp '"' 
2070 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
2072 fe 20			cp ' ' 
2074 20 ee			jr nz,  .cptoken2 
2076			 
2076			; TODO consume comments held between ( and ) 
2076			 
2076				; we have a space so change to zero term for dict match later 
2076 2b				dec hl 
2077 3e 00			ld a,0 
2079 77				ld (hl), a 
207a 23				inc hl 
207b 18 e7			jr .cptoken2 
207d				 
207d			 
207d			.cptokenstr2: 
207d				; skip all white space until either eol (because forgot to term) or end double quote 
207d			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
207d				;inc hl ; skip current double quote 
207d 7e				ld a,(hl) 
207e 23				inc hl 
207f fe 22			cp '"' 
2081 28 e1			jr z, .cptoken2 
2083 fe 7f			cp FORTH_END_BUFFER 
2085 28 0c			jr z, .cptokendone2 
2087 fe 00			cp 0 
2089 28 08			jr z, .cptokendone2 
208b fe 20			cp ' ' 
208d 28 02			jr z, .cptmp2 
208f 18 ec			jr .cptokenstr2 
2091			 
2091			.cptmp2:	; we have a space so change to zero term for dict match later 
2091				;dec hl 
2091				;ld a,"-"	; TODO remove this when working 
2091				;ld (hl), a 
2091				;inc hl 
2091 18 ea			jr .cptokenstr2 
2093			 
2093			.cptokendone2: 
2093				;inc hl 
2093 3e 7f			ld a, FORTH_END_BUFFER 
2095 77				ld (hl),a 
2096 23				inc hl 
2097 3e 21			ld a, '!' 
2099 77				ld (hl),a 
209a			 
209a 2a 1e f1			ld hl,(os_tok_ptr) 
209d			         
209d			if DEBUG_FORTH_TOK 
209d						DMARK "Tc1" 
209d				CALLMONITOR 
209d			endif 
209d			 
209d				; push exec string to top of return stack 
209d				FORTH_RSP_NEXT 
209d cd 91 1c			call macro_forth_rsp_next 
20a0				endm 
# End of macro FORTH_RSP_NEXT
20a0 c9				ret 
20a1			 
20a1			; Another go at the parser need to simplify the process 
20a1			 
20a1			forthparse: 
20a1			 
20a1			; 
20a1			; line parse: 
20a1			;       parse raw input buffer 
20a1			;       tokenise the words 
20a1			;       malloc new copy (for looping etc) 
20a1			;       copy to malloc + current pc in line to start of string and add line term 
20a1			;       save on new rsp 
20a1			; 
20a1			 
20a1			; hl to point to the line to tokenise 
20a1			 
20a1			;	push hl 
20a1 22 1e f1			ld (os_tok_ptr), hl  ; save ptr to string 
20a4			 
20a4			;	ld a,0		; string term on input 
20a4			;	call strlent 
20a4			 
20a4			;	ld (os_tok_len), hl	 ; save string length 
20a4			 
20a4			;if DEBUG_FORTH_TOK 
20a4			;	ex de,hl		 
20a4			;endif 
20a4			 
20a4			;	pop hl 		; get back string pointer 
20a4			 
20a4			if DEBUG_FORTH_TOK 
20a4						DMARK "TOK" 
20a4				CALLMONITOR 
20a4			endif 
20a4 7e			.ptoken2:    ld a,(hl) 
20a5 23				inc hl 
20a6 fe 7f			cp FORTH_END_BUFFER 
20a8 28 29			jr z, .ptokendone2 
20aa fe 00			cp 0 
20ac 28 25			jr z, .ptokendone2 
20ae fe 22			cp '"' 
20b0 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
20b2 fe 20			cp ' ' 
20b4 20 ee			jr nz,  .ptoken2 
20b6			 
20b6			; TODO consume comments held between ( and ) 
20b6			 
20b6				; we have a space so change to zero term for dict match later 
20b6 2b				dec hl 
20b7 3e 00			ld a,0 
20b9 77				ld (hl), a 
20ba 23				inc hl 
20bb 18 e7			jr .ptoken2 
20bd				 
20bd			 
20bd			.ptokenstr2: 
20bd				; skip all white space until either eol (because forgot to term) or end double quote 
20bd			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
20bd				;inc hl ; skip current double quote 
20bd 7e				ld a,(hl) 
20be 23				inc hl 
20bf fe 22			cp '"' 
20c1 28 e1			jr z, .ptoken2 
20c3 fe 7f			cp FORTH_END_BUFFER 
20c5 28 0c			jr z, .ptokendone2 
20c7 fe 00			cp 0 
20c9 28 08			jr z, .ptokendone2 
20cb fe 20			cp ' ' 
20cd 28 02			jr z, .ptmp2 
20cf 18 ec			jr .ptokenstr2 
20d1			 
20d1			.ptmp2:	; we have a space so change to zero term for dict match later 
20d1				;dec hl 
20d1				;ld a,"-"	; TODO remove this when working 
20d1				;ld (hl), a 
20d1				;inc hl 
20d1 18 ea			jr .ptokenstr2 
20d3			 
20d3			.ptokendone2: 
20d3				;inc hl 
20d3 3e 7f			ld a, FORTH_END_BUFFER 
20d5 77				ld (hl),a 
20d6 23				inc hl 
20d7 3e 21			ld a, '!' 
20d9 77				ld (hl),a 
20da			 
20da 2a 1e f1			ld hl,(os_tok_ptr) 
20dd			         
20dd			if DEBUG_FORTH_TOK 
20dd						DMARK "TK1" 
20dd				CALLMONITOR 
20dd			endif 
20dd			 
20dd				; push exec string to top of return stack 
20dd				FORTH_RSP_NEXT 
20dd cd 91 1c			call macro_forth_rsp_next 
20e0				endm 
# End of macro FORTH_RSP_NEXT
20e0 c9				ret 
20e1			 
20e1			; 
20e1			;	; malloc size + buffer pointer + if is loop flag 
20e1			;	ld hl,(os_tok_len) 		 ; get string length 
20e1			; 
20e1			;	ld a,l 
20e1			; 
20e1			;	cp 0			; we dont want to use a null string 
20e1			;	ret z 
20e1			; 
20e1			;;	add 3    ; prefix malloc with buffer for current word ptr 
20e1			; 
20e1			;	add 5     ; TODO when certain not over writing memory remove 
20e1			; 
20e1			;		 
20e1			; 
20e1			;if DEBUG_FORTH_TOK 
20e1			;			DMARK "TKE" 
20e1			;	CALLMONITOR 
20e1			;endif 
20e1			; 
20e1			;	ld l,a 
20e1			;	ld h,0 
20e1			;;	push hl   ; save required space for the copy later 
20e1			;	call malloc 
20e1			;if DEBUG_FORTH_TOK 
20e1			;			DMARK "TKM" 
20e1			;	CALLMONITOR 
20e1			;endif 
20e1			;	if DEBUG_FORTH_MALLOC_GUARD 
20e1			;		push af 
20e1			;		call ishlzero 
20e1			;;		ld a, l 
20e1			;;		add h 
20e1			;;		cp 0 
20e1			;		pop af 
20e1			;		 
20e1			;		call z,malloc_error 
20e1			;	endif 
20e1			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
20e1			; 
20e1			; 
20e1			;if DEBUG_FORTH_TOK 
20e1			;			DMARK "TKR" 
20e1			;	CALLMONITOR 
20e1			;endif 
20e1			; 
20e1			;	FORTH_RSP_NEXT 
20e1			; 
20e1			;	;inc hl	 ; go past current buffer pointer 
20e1			;	;inc hl 
20e1			;	;inc hl   ; and past if loop flag 
20e1			;		; TODO Need to set flag  
20e1			; 
20e1			;	 
20e1			;	 
20e1			;	ex de,hl	; malloc is dest 
20e1			;	ld hl, (os_tok_len) 
20e1			;;	pop bc 
20e1			;	ld c, l                
20e1			;	ld b,0 
20e1			;	ld hl, (os_tok_ptr) 
20e1			; 
20e1			;if DEBUG_FORTH_TOK 
20e1			;			DMARK "TKT" 
20e1			;	CALLMONITOR 
20e1			;endif 
20e1			; 
20e1			;	; do str cpy 
20e1			; 
20e1			;	ldir      ; copy byte in hl to de 
20e1			; 
20e1			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
20e1			; 
20e1			;if DEBUG_FORTH_TOK 
20e1			; 
20e1			;			DMARK "TKY" 
20e1			;	CALLMONITOR 
20e1			;endif 
20e1			;	;ld a,0 
20e1			;	;ld a,FORTH_END_BUFFER 
20e1			;	ex de, hl 
20e1			;	;dec hl			 ; go back over the space delim at the end of word 
20e1			;	;ld (hl),a 
20e1			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
20e1			;	ld a,FORTH_END_BUFFER 
20e1			;	ld (hl),a 
20e1			;	inc hl 
20e1			;	ld a,FORTH_END_BUFFER 
20e1			;	ld (hl),a 
20e1			; 
20e1			;	; init the malloc area data 
20e1			;	; set pc for in current area 
20e1			;	;ld hl, (os_tok_malloc) 
20e1			;	;inc hl 
20e1			;	;inc hl 
20e1			;	;inc hl 
20e1			;	;ex de,hl 
20e1			;	;ld hl, (os_tok_malloc) 
20e1			;	;ld (hl),e 
20e1			;	;inc hl 
20e1			;	;ld (hl),d 
20e1			; 
20e1			; 
20e1			;	ld hl,(os_tok_malloc) 
20e1			;if DEBUG_FORTH_PARSE_KEY 
20e1			;			DMARK "TKU" 
20e1			;	CALLMONITOR 
20e1			;endif 
20e1			; 
20e1			;	ret 
20e1			 
20e1			forthexec: 
20e1			 
20e1			; line exec: 
20e1			; forth parser 
20e1			 
20e1			; 
20e1			;       get current exec line on rsp 
20e1			 
20e1				FORTH_RSP_TOS 
20e1 cd a8 1c			call macro_forth_rsp_tos 
20e4				endm 
# End of macro FORTH_RSP_TOS
20e4			 
20e4			;       restore current pc - hl points to malloc of data 
20e4			 
20e4				;ld e, (hl) 
20e4				;inc hl 
20e4				;ld d, (hl) 
20e4				;ex de,hl 
20e4			 
20e4			 
20e4			exec1: 
20e4 22 1e f1			ld (os_tok_ptr), hl 
20e7			 
20e7				; copy our PC to working vars  
20e7 22 28 f8			ld (cli_ptr), hl 
20ea 22 26 f8			ld (cli_origptr), hl 
20ed			 
20ed 7e				ld a,(hl) 
20ee fe 7f			cp FORTH_END_BUFFER 
20f0 c8				ret z 
20f1			 
20f1				; skip any nulls 
20f1			 
20f1 fe 00			cp 0 
20f3 20 03			jr nz, .execword 
20f5 23				inc hl 
20f6 18 ec			jr exec1 
20f8			 
20f8			 
20f8			.execword: 
20f8			 
20f8			 
20f8			 
20f8			if DEBUG_FORTH_PARSE_KEY 
20f8						DMARK "KYQ" 
20f8				CALLMONITOR 
20f8			endif 
20f8			;       while at start of word: 
20f8			; get start of dict (in user area first) 
20f8			 
20f8 21 00 80		ld hl, baseram 
20fb			;ld hl, sysdict 
20fb 22 2a f8		ld (cli_nextword),hl 
20fe			;           match word at pc 
20fe			;           exec word 
20fe			;           or push to dsp 
20fe			;           forward to next token 
20fe			;           if line term pop rsp and exit 
20fe			;        
20fe			 
20fe			if DEBUG_FORTH_PARSE_KEY 
20fe						DMARK "KYq" 
20fe				CALLMONITOR 
20fe			endif 
20fe			 
20fe			; 
20fe			; word comp 
20fe			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
20fe			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
20fe			;    move to start of word  
20fe			;    compare word to cli_token 
20fe			 
20fe			.execpnword:	; HL at start of a word in the dictionary to check 
20fe			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
20fe			;	ld (cli_ptr), hl 
20fe			 
20fe 2a 2a f8			ld hl,(cli_nextword) 
2101			 
2101 cd a4 21			call forth_tok_next 
2104			; tok next start here 
2104			;	; TODO skip compiled symbol for now 
2104			;	inc hl 
2104			; 
2104			;	; save pointer to next word 
2104			; 
2104			;	; hl now points to the address of the next word pointer  
2104			;	ld e, (hl) 
2104			;	inc hl 
2104			;	ld d, (hl) 
2104			;	inc l 
2104			; 
2104			;	ex de,hl 
2104			;if DEBUG_FORTH_PARSE_NEXTWORD 
2104			;	push bc 
2104			;	ld bc, (cli_nextword) 
2104			;			DMARK "NXW" 
2104			;	CALLMONITOR 
2104			;	pop bc 
2104			;endif 
2104			; tok next end here 
2104 22 2a f8			ld (cli_nextword), hl     ; save for next check if no match on this word 
2107 eb				ex de, hl 
2108			 
2108			 
2108				; save the pointer of the current token - 1 to check against 
2108				 
2108 22 2e f8			ld (cli_token), hl   
210b				; TODO maybe remove below save if no debug 
210b				; save token string ptr for any debug later 
210b 23				inc hl  
210c 22 30 f8			ld (cli_origtoken), hl 
210f 2b				dec hl 
2110				; save pointer to the start of the next dictionay word 
2110 7e				ld a,(hl)   ; get string length 
2111 47				ld b,a 
2112			.execpnwordinc:  
2112 23				inc hl 
2113 10 fd			djnz .execpnwordinc 
2115 22 2c f8			ld (cli_execword), hl      ; save start of this words code 
2118			 
2118				; now check the word token against the string being parsed 
2118			 
2118 2a 2e f8			ld hl,(cli_token) 
211b 23				inc hl     ; skip string length (use zero term instead to end) 
211c 22 2e f8			ld (cli_token), hl 
211f			 
211f			if DEBUG_FORTH_PARSE_KEY 
211f						DMARK "KY2" 
211f			endif 
211f			if DEBUG_FORTH_PARSE_EXEC 
211f				; see if disabled 
211f			 
211f				ld a, (os_view_disable) 
211f				cp '*' 
211f				jr z, .skip 
211f			 
211f				push hl 
211f				push hl 
211f				call clear_display 
211f				ld de, .compword 
211f				ld a, display_row_1 
211f				call str_at_display 
211f				pop de 
211f				ld a, display_row_2 
211f				call str_at_display 
211f				ld hl,(cli_ptr) 
211f				ld a,(hl) 
211f			        ld hl, os_word_scratch 
211f				ld (hl),a 
211f				ld a,0 
211f				inc hl 
211f				ld (hl),a 	 
211f				ld de, os_word_scratch 
211f				ld a, display_row_2+10 
211f				call str_at_display 
211f				call update_display 
211f				ld a, 100 
211f				call aDelayInMS 
211f				if DEBUG_FORTH_PARSE_EXEC_SLOW 
211f				call delay250ms 
211f				endif 
211f				pop hl 
211f			.skip:  
211f			endif	 
211f			.execpnchar:    ; compare char between token and string to parse 
211f			 
211f			if DEBUG_FORTH_PARSE_KEY 
211f						DMARK "Ky3" 
211f			endif 
211f			if DEBUG_FORTH_PARSE_EXEC 
211f				; see if disabled 
211f			 
211f				ld a, (os_view_disable) 
211f				cp '*' 
211f				jr z, .skip2 
211f			 
211f			;	call clear_display 
211f			ld hl,(cli_token) 
211f			ld a,(hl) 
211f			ld (os_word_scratch),a 
211f				ld hl,(cli_ptr) 
211f			ld a,(hl) 
211f				ld (os_word_scratch+1),a 
211f				ld a,0 
211f				ld (os_word_scratch+2),a 
211f				ld de,os_word_scratch 
211f				ld a,display_row_4 
211f				call str_at_display 
211f				call update_display 
211f			.skip2:  
211f			endif 
211f 2a 2e f8			ld hl,(cli_token) 
2122 7e				ld a, (hl)	 ; char in word token 
2123 23				inc hl 		; move to next char 
2124 22 2e f8			ld (cli_token), hl ; and save it 
2127 47				ld b,a 
2128			 
2128 2a 28 f8			ld hl,(cli_ptr) ;	get the char from the string to parse 
212b 7e				ld a,(hl) 
212c 23				inc hl 
212d 22 28 f8			ld (cli_ptr), hl		; move to next char 
2130 cd 72 11			call toUpper 		; make sure the input string matches case 
2133			 
2133			if DEBUG_FORTH_PARSE 
2133			endif 
2133			 
2133				; input stream end of token is a space so get rid of it 
2133			 
2133			;	cp ' ' 
2133			;	jr nz, .pnskipspace 
2133			; 
2133			;	ld a, 0		; make same term as word token term 
2133			; 
2133			;.pnskipspace: 
2133			 
2133			if DEBUG_FORTH_PARSE_KEY 
2133						DMARK "KY7" 
2133			endif 
2133 b8				cp b 
2134 c2 4a 21			jp nz, .execpnskipword	 ; no match so move to next word 
2137				 
2137			;    if same 
2137			;       scan for string terms 0 for token and 32 for input 
2137			 
2137				 
2137			if DEBUG_FORTH_PARSE_KEY 
2137						DMARK "KY8" 
2137			endif 
2137			 
2137 80				add b			 
2138 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
213a							; TODO need to make sure last word in zero term string is accounted for 
213a 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
213c			 
213c			 
213c				; at end of both strings so both are exact match 
213c			 
213c			;       skip ptr for next word 
213c			 
213c 2a 28 f8			ld hl,(cli_ptr) 	; at input string term 
213f 23				inc hl			 ; at next char 
2140 22 28 f8			ld (cli_ptr), hl     ; save for next round of the parser 
2143 22 26 f8			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
2146				 
2146				 
2146			if DEBUG_FORTH_PARSE_KEY 
2146						DMARK "KY3" 
2146			endif 
2146			 
2146			 
2146			 
2146			;       exec code block 
2146			if DEBUG_FORTH_JP 
2146				call clear_display 
2146				call update_display 
2146				call delay1s 
2146				ld hl, (cli_execword)     ; save for next check if no match on this word 
2146				ld a,h 
2146				ld hl, os_word_scratch 
2146				call hexout 
2146				ld hl, (cli_execword)     ; save for next check if no match on this word 
2146				ld a,l 
2146				ld hl, os_word_scratch+2 
2146				call hexout 
2146				ld hl, os_word_scratch+4 
2146				ld a,0 
2146				ld (hl),a 
2146				ld de,os_word_scratch 
2146				call str_at_display 
2146					ld a, display_row_2 
2146					call str_at_display 
2146				ld de, (cli_origtoken) 
2146				ld a, display_row_1+10 
2146					call str_at_display 
2146			 
2146				ld a,display_row_1 
2146				ld de, .foundword 
2146				ld a, display_row_3 
2146				call str_at_display 
2146				call update_display 
2146				call delay1s 
2146				call delay1s 
2146				call delay1s 
2146			endif 
2146			 
2146			if DEBUG_FORTH_PARSE_KEY 
2146						DMARK "KYj" 
2146			endif 
2146				; TODO save the word pointer in this exec 
2146			 
2146 2a 2c f8			ld hl,(cli_execword) 
2149 e9				jp (hl) 
214a			 
214a			 
214a			;    if not same 
214a			;	scan for zero term 
214a			;	get ptr for next word 
214a			;	goto word comp 
214a			 
214a			.execpnskipword:	; get pointer to next word 
214a 2a 2a f8			ld hl,(cli_nextword) 
214d			 
214d 7e				ld a,(hl) 
214e fe 00			cp WORD_SYS_END 
2150			;	cp 0 
2150 28 09			jr z, .execendofdict			 ; at end of words 
2152			 
2152			if DEBUG_FORTH_PARSE_KEY 
2152						DMARK "KY4" 
2152			endif 
2152			if DEBUG_FORTH_PARSE_EXEC 
2152			 
2152				; see if disabled 
2152			 
2152				ld a, (os_view_disable) 
2152				cp '*' 
2152				jr z, .noskip 
2152			 
2152			 
2152				ld de, .nowordfound 
2152				ld a, display_row_3 
2152				call str_at_display 
2152				call update_display 
2152				ld a, 100 
2152				call aDelayInMS 
2152				 
2152				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2152					call delay250ms 
2152				endif 
2152			.noskip:  
2152			 
2152			endif	 
2152			 
2152 2a 26 f8			ld hl,(cli_origptr) 
2155 22 28 f8			ld (cli_ptr),hl 
2158			 
2158			if DEBUG_FORTH_PARSE_KEY 
2158						DMARK "KY5" 
2158			endif 
2158 c3 fe 20			jp .execpnword			; else go to next word 
215b			 
215b			.execendofdict:  
215b			 
215b			if DEBUG_FORTH_PARSE_KEY 
215b						DMARK "KYe" 
215b			endif 
215b			if DEBUG_FORTH_PARSE_EXEC 
215b				; see if disabled 
215b			 
215b				ld a, (os_view_disable) 
215b				cp '*' 
215b				jr z, .ispskip 
215b			 
215b				call clear_display 
215b				call update_display 
215b				call delay1s 
215b				ld de, (cli_origptr) 
215b				ld a, display_row_1 
215b				call str_at_display 
215b				 
215b				ld de, .enddict 
215b				ld a, display_row_3 
215b				call str_at_display 
215b				call update_display 
215b				ld a, 100 
215b				call aDelayInMS 
215b				if DEBUG_FORTH_PARSE_EXEC_SLOW 
215b				call delay1s 
215b				call delay1s 
215b				call delay1s 
215b				endif 
215b			.ispskip:  
215b				 
215b			endif	 
215b			 
215b			 
215b			 
215b				; if the word is not a keyword then must be a literal so push it to stack 
215b			 
215b			; push token to stack to end of word 
215b			 
215b				STACKFRAME ON $1efe $2f9f 
215b				if DEBUG_STACK_IMB 
215b					if ON 
215b						exx 
215b						ld de, $1efe 
215b						ld a, d 
215b						ld hl, curframe 
215b						call hexout 
215b						ld a, e 
215b						ld hl, curframe+2 
215b						call hexout 
215b						ld hl, $1efe 
215b						push hl 
215b						ld hl, $2f9f 
215b						push hl 
215b						exx 
215b					endif 
215b				endif 
215b			endm 
# End of macro STACKFRAME
215b			 
215b 2a 1e f1		ld hl,(os_tok_ptr) 
215e cd 53 1e		call forth_apush 
2161			 
2161				STACKFRAMECHK ON $1efe $2f9f 
2161				if DEBUG_STACK_IMB 
2161					if ON 
2161						exx 
2161						ld hl, $2f9f 
2161						pop de   ; $2f9f 
2161						call cmp16 
2161						jr nz, .spnosame 
2161						ld hl, $1efe 
2161						pop de   ; $1efe 
2161						call cmp16 
2161						jr z, .spfrsame 
2161						.spnosame: call showsperror 
2161						.spfrsame: nop 
2161						exx 
2161					endif 
2161				endif 
2161			endm 
# End of macro STACKFRAMECHK
2161			 
2161			execnext: 
2161			 
2161			if DEBUG_FORTH_PARSE_KEY 
2161						DMARK "KY>" 
2161			endif 
2161			; move past token to next word 
2161			 
2161 2a 1e f1		ld hl, (os_tok_ptr) 
2164 3e 00		ld a, 0 
2166 01 ff 00		ld bc, 255     ; input buffer size 
2169 ed b1		cpir 
216b			 
216b			if DEBUG_FORTH_PARSE_KEY 
216b						DMARK "KY!" 
216b				CALLMONITOR 
216b			endif	 
216b			; TODO this might place hl on the null, so will need to forward on??? 
216b			;inc hl   ; see if this gets onto the next item 
216b			 
216b			 
216b			; TODO pass a pointer to the buffer to push 
216b			; TODO call function to push 
216b			 
216b			; look for end of input 
216b			 
216b			;inc hl 
216b			;ld a,(hl) 
216b			;cp FORTH_END_BUFFER 
216b			;ret z 
216b			 
216b			 
216b c3 e4 20		jp exec1 
216e			 
216e			 
216e			 
216e			 
216e			 
216e			 
216e			 
216e			 
216e			 
216e			findnexttok: 
216e			 
216e				; hl is pointer to move 
216e				; de is the token to locate 
216e			 
216e					if DEBUG_FORTH 
216e						DMARK "NTK" 
216e						CALLMONITOR 
216e					endif 
216e d5				push de 
216f			 
216f			.fnt1:	 
216f				; find first char of token to locate 
216f			 
216f 1a				ld a, (de) 
2170 4f				ld c,a 
2171 7e				ld a,(hl) 
2172 cd 72 11			call toUpper 
2175					if DEBUG_FORTH 
2175						DMARK "NT1" 
2175						CALLMONITOR 
2175					endif 
2175 b9				cp c 
2176			 
2176 28 03			jr z, .fnt2cmpmorefirst	 
2178			 
2178				; first char not found move to next char 
2178			 
2178 23				inc hl 
2179 18 f4			jr .fnt1 
217b			 
217b			.fnt2cmpmorefirst:	 
217b				; first char of token found.  
217b			 
217b e5				push hl     ; save start of token just in case it is the right one 
217c d9				exx 
217d e1				pop hl        ; save it to hl' 
217e d9				exx 
217f			 
217f			 
217f			.fnt2cmpmore:	 
217f				; compare the rest 
217f				 
217f 23				inc hl 
2180 13				inc de 
2181				 
2181 1a				ld a, (de) 
2182 4f				ld c,a 
2183 7e				ld a,(hl) 
2184 cd 72 11			call toUpper 
2187			 
2187					if DEBUG_FORTH 
2187						DMARK "NT2" 
2187						CALLMONITOR 
2187					endif 
2187				; c has the token to find char 
2187				; a has the mem to scan char 
2187			 
2187 b9				cp c 
2188 28 04			jr z,.fntmatch1 
218a			 
218a				; they are not the same 
218a			 
218a					if DEBUG_FORTH 
218a						DMARK "NT3" 
218a						CALLMONITOR 
218a					endif 
218a d1				pop de	; reset de token to look for 
218b d5				push de 
218c 18 e1			jr .fnt1 
218e				 
218e			.fntmatch1: 
218e			 
218e				; is the same char a null which means we might have a full hit? 
218e					if DEBUG_FORTH 
218e						DMARK "NT4" 
218e						CALLMONITOR 
218e					endif 
218e			 
218e fe 00			cp 0 
2190 28 0b			jr z, .fntmatchyes 
2192			 
2192				; are we at the end of the token to find? 
2192			 
2192					if DEBUG_FORTH 
2192						DMARK "NT5" 
2192						CALLMONITOR 
2192					endif 
2192 3e 00			ld a, 0 
2194 b9				cp c 
2195			 
2195 c2 7f 21			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
2198			 
2198					if DEBUG_FORTH 
2198						DMARK "NT6" 
2198						CALLMONITOR 
2198					endif 
2198				; token to find is exhusted but no match to stream 
2198			 
2198				; restore tok pointer and continue on 
2198 d1				pop de 
2199 d5				push de 
219a c3 6f 21			jp .fnt1 
219d			 
219d			 
219d			.fntmatchyes: 
219d			 
219d				; hl now contains the end of the found token 
219d			 
219d				; get rid of saved token pointer to find 
219d			 
219d d1				pop de 
219e			 
219e					if DEBUG_FORTH 
219e						DMARK "NT9" 
219e						CALLMONITOR 
219e					endif 
219e			 
219e				; hl will be on the null term so forward on 
219e			 
219e				; get back the saved start of the token 
219e			 
219e d9				exx 
219f e5				push hl     ; save start of token just in case it is the right one 
21a0 d9				exx 
21a1 e1				pop hl        ; save it to hl 
21a2			 
21a2 c9				ret 
21a3			 
21a3			 
21a3			; LIST needs to find a specific token   
21a3			; FORGET needs to find a spefici token 
21a3			 
21a3			; SAVE needs to find all tokens by flag 
21a3			; WORDS just needs to scan through all  by flag 
21a3			; UWORDS needs to scan through all by flag 
21a3			 
21a3			 
21a3			; given hl as pointer to start of dict look up string 
21a3			; return hl as pointer to start of word block 
21a3			; or 0 if not found 
21a3			 
21a3			forth_find_tok: 
21a3 c9				ret 
21a4			 
21a4			; given hl as pointer to dict structure 
21a4			; move to the next dict block structure 
21a4			 
21a4			forth_tok_next: 
21a4				; hl now points to the address of the next word pointer  
21a4				; TODO skip compiled symbol for now 
21a4			;	push de 
21a4 23				inc hl 
21a5 5e				ld e, (hl) 
21a6 23				inc hl 
21a7 56				ld d, (hl) 
21a8 23				inc hl 
21a9			 
21a9 eb				ex de,hl 
21aa			if DEBUG_FORTH_PARSE_NEXTWORD 
21aa				push bc 
21aa				ld bc, (cli_nextword) 
21aa						DMARK "NXW" 
21aa				CALLMONITOR 
21aa				pop bc 
21aa			endif 
21aa			;	pop de	 
21aa c9				ret 
21ab			 
21ab			 
21ab			 
21ab			; eof 
# End of file forth_parserv5.asm
21ab				include "forth_wordsv4.asm" 
21ab			 
21ab			; the core word dictionary v4 
21ab			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
21ab			 
21ab			; this is a linked list for each of the system words used 
21ab			; user defined words will follow the same format but will be in ram 
21ab			 
21ab			 
21ab			; 
21ab			; 
21ab			; define linked list: 
21ab			; 
21ab			; 1. compiled byte op code 
21ab			; 2. len of text word 
21ab			; 3. text word 
21ab			; 4. ptr to next dictionary word 
21ab			; 5. asm, calls etc for the word 
21ab			; 
21ab			;  if 1 == 0 then last word in dict  
21ab			;   
21ab			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
21ab			;  
21ab			;  
21ab			; create basic standard set of words 
21ab			; 
21ab			;  
21ab			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
21ab			; 2DUP 2DROP 2SWAP  
21ab			; @ C@ - get byte  
21ab			; ! C! - store byte 
21ab			; 0< true if less than zero 
21ab			; 0= true if zero 
21ab			; < >  
21ab			; = true if same 
21ab			; variables 
21ab			 
21ab			 
21ab			; Hardware specific words I may need 
21ab			; 
21ab			; IN OUT  
21ab			; calls to key util functions 
21ab			; calls to hardward abstraction stuff 
21ab			; easy control of frame buffers and lcd i/o 
21ab			; keyboard  
21ab			 
21ab			 
21ab			;DICT: macro 
21ab			; op_code, len, word, next 
21ab			;    word: 
21ab			;    db op_code 
21ab			;    ds word zero term 
21ab			;    dw next 
21ab			;    endm 
21ab			 
21ab			 
21ab			 
21ab			 
21ab			; op code 1 is a flag for user define words which are to be handled differently 
21ab			 
21ab			 
21ab			; 
21ab			; 
21ab			;    TODO on entry to a word this should be the expected environment 
21ab			;    hl - tos value if number then held, if string this is the ptr 
21ab			;    de -  
21ab			 
21ab			 
21ab			; opcode ranges 
21ab			; 0 - end of word dict 
21ab			; 255 - user define words 
21ab			 
21ab			sysdict: 
21ab			include "forth_opcodes.asm" 
21ab			; op codes for forth keywords 
21ab			; free to use code 0  
21ab				OPCODE_HEAP: equ  1 
21ab				OPCODE_EXEC: equ 2 
21ab				OPCODE_DUP: equ 3 
21ab				OPCODE_SWAP: equ 4 
21ab				OPCODE_COLN: equ 5 
21ab				OPCODE_SCOLN: equ 6 
21ab				OPCODE_DROP: equ 7 
21ab				OPCODE_DUP2: equ 8 
21ab				OPCODE_DROP2: equ 9 
21ab				OPCODE_SWAP2: equ 10 
21ab				OPCODE_AT: equ 11 
21ab				OPCODE_CAT: equ 12 
21ab				OPCODE_BANG: equ 13 
21ab				OPCODE_CBANG: equ 14 
21ab				OPCODE_SCALL: equ 15 
21ab				OPCODE_DEPTH: equ 16 
21ab				OPCODE_OVER: equ 17 
21ab				OPCODE_PAUSE: equ 18 
21ab				OPCODE_PAUSES: equ 19 
21ab				OPCODE_ROT: equ 20 
21ab			;free to reuse	OPCODE_WORDS: equ 21 
21ab			        OPCODE_NOT: equ 21 
21ab				OPCODE_UWORDS: equ 22 
21ab				OPCODE_BP: equ 23 
21ab				OPCODE_MONITOR: equ 24  
21ab				OPCODE_MALLOC: equ 25 
21ab				OPCODE_FREE: equ 26 
21ab				OPCODE_LIST: equ 27 
21ab				OPCODE_FORGET: equ 28 
21ab				OPCODE_NOP: equ 29 
21ab				OPCODE_COMO: equ 30 
21ab				OPCODE_COMC: equ 31 
21ab			;free to reuse	OPCODE_ENDCORE: equ 32 
21ab				OPCODE_AFTERSOUND: equ 33 
21ab				OPCODE_GP2: equ 34 
21ab				OPCODE_GP3: equ 35 
21ab				OPCODE_GP4: equ 36 
21ab				OPCODE_SIN: equ 37 
21ab				OPCODE_SOUT: equ 38 
21ab				OPCODE_SPIO: equ 39 
21ab				OPCODE_SPICEH: equ 40 
21ab				OPCODE_SPIOb: equ 41 
21ab				OPCODE_SPII: equ 42 
21ab				OPCODE_SESEL: equ 43 
21ab				OPCODE_CARTDEV: equ 44 
21ab			; free to reuse	OPCODE_ENDDEVICE: equ 45 
21ab				OPCODE_FB: equ 46 
21ab				OPCODE_EMIT: equ 47 
21ab				OPCODE_DOTH: equ 48 
21ab				OPCODE_DOTF: equ 49 
21ab				OPCODE_DOT: equ 50 
21ab				OPCODE_CLS: equ 51 
21ab				OPCODE_DRAW: equ 52 
21ab				OPCODE_DUMP: equ 53 
21ab				OPCODE_CDUMP: equ 54 
21ab				OPCODE_DAT: equ 55 
21ab				OPCODE_HOME: equ 56 
21ab				OPCODE_SPACE: equ 57 
21ab				OPCODE_SPACES: equ 58 
21ab				OPCODE_SCROLL: equ 59 
21ab				OPCODE_ATQ: equ 60 
21ab				OPCODE_AUTODSP: equ 61 
21ab				OPCODE_MENU: equ 62 
21ab			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
21ab				OPCODE_THEN: equ 64 
21ab				OPCODE_ELSE: equ 65 
21ab				OPCODE_DO: equ 66 
21ab				OPCODE_LOOP: equ 67 
21ab				OPCODE_I: equ 68 
21ab				OPCODE_DLOOP: equ 69  
21ab				OPCODE_REPEAT: equ 70  
21ab				OPCODE_UNTIL: equ 71 
21ab				OPCODE_ENDFLOW: equ 72 
21ab				OPCODE_WAITK: equ 73 
21ab				OPCODE_ACCEPT: equ 74 
21ab				OPCODE_EDIT: equ 75 
21ab			;free to reuse	OPCODE_ENDKEY: equ 76 
21ab				OPCODE_LZERO: equ 77 
21ab				OPCODE_TZERO: equ 78 
21ab				OPCODE_LESS: equ 79 
21ab				OPCODE_GT: equ 80 
21ab				OPCODE_EQUAL: equ 81  
21ab			;free to reuse	OPCODE_ENDLOGIC: equ 82 
21ab				OPCODE_NEG: equ 83 
21ab				OPCODE_DIV: equ 84 
21ab				OPCODE_MUL: equ 85 
21ab				OPCODE_MIN: equ 86 
21ab				OPCODE_MAX: equ 87 
21ab				OPCODE_RND16: equ 88 
21ab				OPCODE_RND8: equ 89 
21ab				OPCODE_RND: equ 90 
21ab			;free to reuse	OPCODE_ENDMATHS: equ 91  
21ab				OPCODE_BYNAME: equ 92 
21ab				OPCODE_DIR: equ 93 
21ab				OPCODE_SAVE: equ 94 
21ab				OPCODE_LOAD: equ 95 
21ab				OPCODE_BSAVE: equ 96 
21ab				OPCODE_BLOAD: equ 97 
21ab				OPCODE_SEO: equ 98  
21ab				OPCODE_SEI: equ 99 
21ab				OPCODE_SFREE: equ 100 
21ab				OPCODE_SIZE: equ 101 
21ab				OPCODE_CREATE: equ 102 
21ab				OPCODE_APPEND: equ 103 
21ab				OPCODE_SDEL: equ 104 
21ab				OPCODE_OPEN: equ 105 
21ab				OPCODE_READ: equ 106 
21ab				OPCODE_EOF: equ 106 
21ab				OPCODE_FORMAT: equ 107 
21ab				OPCODE_LABEL: equ 108 
21ab				OPCODE_LABELS: equ 109 
21ab			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
21ab				OPCODE_UPPER: equ 111 
21ab				OPCODE_LOWER: equ 112 
21ab				OPCODE_SUBSTR: equ 113 
21ab				OPCODE_LEFT: equ 114 
21ab				OPCODE_RIGHT: equ 115 
21ab				OPCODE_STR2NUM: equ 116 
21ab				OPCODE_NUM2STR: equ 117 
21ab				OPCODE_CONCAT: equ 118 
21ab				OPCODE_FIND: equ 119 
21ab				OPCODE_LEN: equ 120 
21ab				OPCODE_CHAR: equ 121 
21ab			; free to reuse	OPCODE_STRLEN: equ 122 
21ab			; free to reuse	OPCODE_ENDSTR: equ 123 
21ab				OPCODE_V0S: equ 124 
21ab				OPCODE_V0Q: equ 125 
21ab				OPCODE_V1S: equ 126 
21ab				OPCODE_V1Q: equ 127 
21ab				OPCODE_V2S: equ 128 
21ab				OPCODE_V2Q: equ 129 
21ab				OPCODE_V3S: equ 130 
21ab				OPCODE_V3Q: equ 131 
21ab			;free to reuse	OPCODE_END: equ 132 
21ab				OPCODE_ZDUP: equ 133 
21ab			 
21ab			; eof 
# End of file forth_opcodes.asm
21ab			 
21ab			include "forth_words_core.asm" 
21ab			 
21ab			; | ## Core Words 
21ab			 
21ab			;if MALLOC_4 
21ab			 
21ab			.HEAP: 
21ab				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
21ab 15				db WORD_SYS_CORE+OPCODE_HEAP             
21ac ea 21			dw .EXEC            
21ae 05				db 4 + 1 
21af .. 00			db "HEAP",0              
21b4				endm 
# End of macro CWHEAD
21b4			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
21b4			; | | u1 - Current number of bytes in the heap 
21b4			; | | u2 - Remaining bytes left on the heap 
21b4			; | |  
21b4			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
21b4			 
21b4			 
21b4					if DEBUG_FORTH_WORDS_KEY 
21b4						DMARK "HEP" 
21b4 f5				push af  
21b5 3a c9 21			ld a, (.dmark)  
21b8 32 77 fb			ld (debug_mark),a  
21bb 3a ca 21			ld a, (.dmark+1)  
21be 32 78 fb			ld (debug_mark+1),a  
21c1 3a cb 21			ld a, (.dmark+2)  
21c4 32 79 fb			ld (debug_mark+2),a  
21c7 18 03			jr .pastdmark  
21c9 ..			.dmark: db "HEP"  
21cc f1			.pastdmark: pop af  
21cd			endm  
# End of macro DMARK
21cd						CALLMONITOR 
21cd cd 5a 17			call break_point_state  
21d0				endm  
# End of macro CALLMONITOR
21d0					endif 
21d0 2a 0a 80				ld hl, (free_list )      
21d3 11 0e 80				ld de, heap_start 
21d6			 
21d6 ed 52				sbc hl, de  
21d8			 
21d8 cd ea 1c				call forth_push_numhl 
21db			 
21db			 
21db ed 5b 0a 80			ld de, (free_list )      
21df 21 03 ee				ld hl, heap_end 
21e2			 
21e2 ed 52				sbc hl, de 
21e4			 
21e4 cd ea 1c				call forth_push_numhl 
21e7					 
21e7			 
21e7					 
21e7			 
21e7			 
21e7			 
21e7					NEXTW 
21e7 c3 53 20			jp macro_next 
21ea				endm 
# End of macro NEXTW
21ea			;endif 
21ea			 
21ea			.EXEC: 
21ea			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
21ea			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
21ea			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
21ea			;; > > 
21ea			;; > >   
21ea			;	STACKFRAME OFF $5efe $5f9f 
21ea			; 
21ea			;		if DEBUG_FORTH_WORDS_KEY 
21ea			;			DMARK "EXE" 
21ea			;			CALLMONITOR 
21ea			;		endif 
21ea			; 
21ea			;	FORTH_DSP_VALUEHL 
21ea			; 
21ea			;	FORTH_DSP_POP 
21ea			; 
21ea			;		if DEBUG_FORTH_WORDS 
21ea			;			DMARK "EX1" 
21ea			;			CALLMONITOR 
21ea			;		endif 
21ea			;;	ld e,(hl) 
21ea			;;	inc hl 
21ea			;;	ld d,(hl) 
21ea			;;	ex de,hl 
21ea			; 
21ea			;;		if DEBUG_FORTH_WORDS 
21ea			;;			DMARK "EX2" 
21ea			;;			CALLMONITOR 
21ea			;;		endif 
21ea			;	push hl 
21ea			; 
21ea			;	;ld a, 0 
21ea			;	;ld a, FORTH_END_BUFFER 
21ea			;	call strlenz 
21ea			;	inc hl   ; include zero term to copy 
21ea			;	inc hl   ; include term 
21ea			;	inc hl   ; include term 
21ea			;	ld b,0 
21ea			;	ld c,l 
21ea			;	pop hl 
21ea			;	ld de, execscratch 
21ea			;		if DEBUG_FORTH_WORDS 
21ea			;			DMARK "EX3" 
21ea			;			CALLMONITOR 
21ea			;		endif 
21ea			;	ldir 
21ea			; 
21ea			; 
21ea			;	ld hl, execscratch 
21ea			; 
21ea			;		if DEBUG_FORTH_WORDS 
21ea			;			DMARK "EXe" 
21ea			;			CALLMONITOR 
21ea			;		endif 
21ea			; 
21ea			;	call forthparse 
21ea			;	call forthexec 
21ea			;;	call forthexec_cleanup 
21ea			;;	call forthparse 
21ea			;;	call forthexec 
21ea			; 
21ea			;	STACKFRAMECHK OFF $5efe $5f9f 
21ea			; 
21ea			;	; an immediate word so no need to process any more words 
21ea			;	ret 
21ea			;	NEXTW 
21ea			 
21ea			; dead code - old version  
21ea			;	FORTH_RSP_NEXT 
21ea			 
21ea			;  
21ea			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
21ea			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
21ea			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
21ea			;	push hl 
21ea			;	push de 
21ea			;	push bc 
21ea			; 
21ea			; 
21ea			;		if DEBUG_FORTH_WORDS_KEY 
21ea			;			DMARK "EXR" 
21ea			;			CALLMONITOR 
21ea			;		endif 
21ea			; 
21ea			; 
21ea			; 
21ea			;	;v5 FORTH_DSP_VALUE 
21ea			;	FORTH_DSP_VALUEHL 
21ea			; 
21ea			;	; TODO do string type checks 
21ea			; 
21ea			;;v5	inc hl   ; skip type 
21ea			; 
21ea			;	push hl  ; source code  
21ea			;		if DEBUG_FORTH_WORDS 
21ea			;			DMARK "EX1" 
21ea			;			CALLMONITOR 
21ea			;		endif 
21ea			;	ld a, 0 
21ea			;	call strlent 
21ea			; 
21ea			;	inc hl 
21ea			;	inc hl 
21ea			;	inc hl 
21ea			;	inc hl 
21ea			; 
21ea			;	push hl    ; size 
21ea			; 
21ea			;		if DEBUG_FORTH_WORDS 
21ea			;			DMARK "EX2" 
21ea			;			CALLMONITOR 
21ea			;		endif 
21ea			;	call malloc 
21ea			; 
21ea			;	ex de, hl    ; de now contains malloc area 
21ea			;	pop bc   	; get byte count 
21ea			;	pop hl      ; get string to copy 
21ea			; 
21ea			;	push de     ; save malloc for free later 
21ea			; 
21ea			;		if DEBUG_FORTH_WORDS 
21ea			;			DMARK "EX3" 
21ea			;			CALLMONITOR 
21ea			;		endif 
21ea			;	ldir       ; duplicate string 
21ea			; 
21ea			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
21ea			;	 
21ea			;	; TODO fix the parse would be better than this...  
21ea			;	ex de, hl 
21ea			;	dec hl 
21ea			;	ld a, 0 
21ea			;	ld (hl), a 
21ea			;	dec hl 
21ea			;	ld a, ' ' 
21ea			;	ld (hl), a 
21ea			;	dec hl 
21ea			;	ld (hl), a 
21ea			; 
21ea			;	dec hl 
21ea			;	ld (hl), a 
21ea			; 
21ea			; 
21ea			;	FORTH_DSP_POP  
21ea			; 
21ea			;	pop hl     
21ea			;	push hl    ; save malloc area 
21ea			; 
21ea			;		if DEBUG_FORTH_WORDS 
21ea			;			DMARK "EX4" 
21ea			;			CALLMONITOR 
21ea			;		endif 
21ea			; 
21ea			;	call forthparse 
21ea			;	call forthexec 
21ea			;	 
21ea			;	pop hl 
21ea			;	if DEBUG_FORTH_WORDS 
21ea			;		DMARK "EX5" 
21ea			;		CALLMONITOR 
21ea			;	endif 
21ea			; 
21ea			;	if FORTH_ENABLE_FREE 
21ea			;	call free 
21ea			;	endif 
21ea			; 
21ea			;	if DEBUG_FORTH_WORDS 
21ea			;		DMARK "EX6" 
21ea			;		CALLMONITOR 
21ea			;	endif 
21ea			; 
21ea			;	pop bc 
21ea			;	pop de 
21ea			;	pop hl 
21ea			;;	FORTH_RSP_POP	  
21ea			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
21ea			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
21ea			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
21ea			; 
21ea			;	if DEBUG_FORTH_WORDS 
21ea			;		DMARK "EX7" 
21ea			;		CALLMONITOR 
21ea			;	endif 
21ea			;	NEXTW 
21ea			 
21ea			;.STKEXEC: 
21ea			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
21ea			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
21ea			; 
21ea			; 
21ea			;		if DEBUG_FORTH_WORDS_KEY 
21ea			;			DMARK "STX" 
21ea			;			CALLMONITOR 
21ea			;		endif 
21ea			; 
21ea			;	FORTH_DSP_VALUEHL 
21ea			; 
21ea			;	ld (store_tmp1), hl    ; count 
21ea			; 
21ea			;	FORTH_DSP_POP 
21ea			;.stkexec1: 
21ea			;	ld hl, (store_tmp1)   ; count 
21ea			;	ld a, 0 
21ea			;	cp l 
21ea			;	ret z 
21ea			; 
21ea			;	dec hl 
21ea			;	ld (store_tmp1), hl    ; count 
21ea			;	 
21ea			;	FORTH_DSP_VALUEHL 
21ea			;	push hl 
21ea			;	 
21ea			;		if DEBUG_FORTH_WORDS 
21ea			;			DMARK "EXp" 
21ea			;			CALLMONITOR 
21ea			;		endif 
21ea			;	FORTH_DSP_POP 
21ea			; 
21ea			;	call strlenz 
21ea			;	inc hl   ; include zero term to copy 
21ea			;	inc hl   ; include zero term to copy 
21ea			;	inc hl   ; include zero term to copy 
21ea			;	ld b,0 
21ea			;	ld c,l 
21ea			;	pop hl 
21ea			;	ld de, execscratch 
21ea			;		if DEBUG_FORTH_WORDS 
21ea			;			DMARK "EX3" 
21ea			;			CALLMONITOR 
21ea			;		endif 
21ea			;	ldir 
21ea			; 
21ea			; 
21ea			;	ld hl, execscratch 
21ea			; 
21ea			;		if DEBUG_FORTH_WORDS 
21ea			;			DMARK "EXP" 
21ea			;			CALLMONITOR 
21ea			;		endif 
21ea			; 
21ea			;	call forthparse 
21ea			;	ld hl, execscratch 
21ea			;		if DEBUG_FORTH_WORDS 
21ea			;			DMARK "EXx" 
21ea			;			CALLMONITOR 
21ea			;		endif 
21ea			;	call forthexec 
21ea			; 
21ea			;	jp .stkexec1 
21ea			; 
21ea			;	ret 
21ea			 
21ea			 
21ea			.DUP: 
21ea				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
21ea 17				db WORD_SYS_CORE+OPCODE_DUP             
21eb 60 22			dw .ZDUP            
21ed 04				db 3 + 1 
21ee .. 00			db "DUP",0              
21f2				endm 
# End of macro CWHEAD
21f2			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
21f2			 
21f2					if DEBUG_FORTH_WORDS_KEY 
21f2						DMARK "DUP" 
21f2 f5				push af  
21f3 3a 07 22			ld a, (.dmark)  
21f6 32 77 fb			ld (debug_mark),a  
21f9 3a 08 22			ld a, (.dmark+1)  
21fc 32 78 fb			ld (debug_mark+1),a  
21ff 3a 09 22			ld a, (.dmark+2)  
2202 32 79 fb			ld (debug_mark+2),a  
2205 18 03			jr .pastdmark  
2207 ..			.dmark: db "DUP"  
220a f1			.pastdmark: pop af  
220b			endm  
# End of macro DMARK
220b						CALLMONITOR 
220b cd 5a 17			call break_point_state  
220e				endm  
# End of macro CALLMONITOR
220e					endif 
220e			 
220e					FORTH_DSP 
220e cd a7 1e			call macro_forth_dsp 
2211				endm 
# End of macro FORTH_DSP
2211			 
2211 7e					ld a, (HL) 
2212 fe 01				cp DS_TYPE_STR 
2214 20 25				jr nz, .dupinum 
2216			 
2216					; push another string 
2216			 
2216					FORTH_DSP_VALUEHL     		 
2216 cd e1 1e			call macro_dsp_valuehl 
2219				endm 
# End of macro FORTH_DSP_VALUEHL
2219			 
2219				if DEBUG_FORTH_WORDS 
2219					DMARK "DUs" 
2219 f5				push af  
221a 3a 2e 22			ld a, (.dmark)  
221d 32 77 fb			ld (debug_mark),a  
2220 3a 2f 22			ld a, (.dmark+1)  
2223 32 78 fb			ld (debug_mark+1),a  
2226 3a 30 22			ld a, (.dmark+2)  
2229 32 79 fb			ld (debug_mark+2),a  
222c 18 03			jr .pastdmark  
222e ..			.dmark: db "DUs"  
2231 f1			.pastdmark: pop af  
2232			endm  
# End of macro DMARK
2232					CALLMONITOR 
2232 cd 5a 17			call break_point_state  
2235				endm  
# End of macro CALLMONITOR
2235				endif 
2235 cd 58 1d				call forth_push_str 
2238			 
2238					NEXTW 
2238 c3 53 20			jp macro_next 
223b				endm 
# End of macro NEXTW
223b			 
223b			 
223b			.dupinum: 
223b					 
223b			 
223b			 
223b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
223b cd e1 1e			call macro_dsp_valuehl 
223e				endm 
# End of macro FORTH_DSP_VALUEHL
223e			 
223e				; TODO add floating point number detection 
223e			 
223e				if DEBUG_FORTH_WORDS 
223e					DMARK "DUi" 
223e f5				push af  
223f 3a 53 22			ld a, (.dmark)  
2242 32 77 fb			ld (debug_mark),a  
2245 3a 54 22			ld a, (.dmark+1)  
2248 32 78 fb			ld (debug_mark+1),a  
224b 3a 55 22			ld a, (.dmark+2)  
224e 32 79 fb			ld (debug_mark+2),a  
2251 18 03			jr .pastdmark  
2253 ..			.dmark: db "DUi"  
2256 f1			.pastdmark: pop af  
2257			endm  
# End of macro DMARK
2257					CALLMONITOR 
2257 cd 5a 17			call break_point_state  
225a				endm  
# End of macro CALLMONITOR
225a				endif 
225a			 
225a cd ea 1c				call forth_push_numhl 
225d					NEXTW 
225d c3 53 20			jp macro_next 
2260				endm 
# End of macro NEXTW
2260			.ZDUP: 
2260				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
2260 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2261 98 22			dw .SWAP            
2263 05				db 4 + 1 
2264 .. 00			db "?DUP",0              
2269				endm 
# End of macro CWHEAD
2269			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
2269			 
2269					if DEBUG_FORTH_WORDS_KEY 
2269						DMARK "qDU" 
2269 f5				push af  
226a 3a 7e 22			ld a, (.dmark)  
226d 32 77 fb			ld (debug_mark),a  
2270 3a 7f 22			ld a, (.dmark+1)  
2273 32 78 fb			ld (debug_mark+1),a  
2276 3a 80 22			ld a, (.dmark+2)  
2279 32 79 fb			ld (debug_mark+2),a  
227c 18 03			jr .pastdmark  
227e ..			.dmark: db "qDU"  
2281 f1			.pastdmark: pop af  
2282			endm  
# End of macro DMARK
2282						CALLMONITOR 
2282 cd 5a 17			call break_point_state  
2285				endm  
# End of macro CALLMONITOR
2285					endif 
2285					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2285 cd e1 1e			call macro_dsp_valuehl 
2288				endm 
# End of macro FORTH_DSP_VALUEHL
2288			 
2288 e5					push hl 
2289			 
2289					; is it a zero? 
2289			 
2289 3e 00				ld a, 0 
228b 84					add h 
228c 85					add l 
228d			 
228d e1					pop hl 
228e			 
228e fe 00				cp 0 
2290 28 03				jr z, .dup2orig 
2292			 
2292			 
2292 cd ea 1c				call forth_push_numhl 
2295			 
2295			 
2295				; TODO add floating point number detection 
2295			 
2295			.dup2orig: 
2295			 
2295					NEXTW 
2295 c3 53 20			jp macro_next 
2298				endm 
# End of macro NEXTW
2298			.SWAP: 
2298				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
2298 18				db WORD_SYS_CORE+OPCODE_SWAP             
2299 d7 22			dw .COLN            
229b 05				db 4 + 1 
229c .. 00			db "SWAP",0              
22a1				endm 
# End of macro CWHEAD
22a1			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
22a1					if DEBUG_FORTH_WORDS_KEY 
22a1						DMARK "SWP" 
22a1 f5				push af  
22a2 3a b6 22			ld a, (.dmark)  
22a5 32 77 fb			ld (debug_mark),a  
22a8 3a b7 22			ld a, (.dmark+1)  
22ab 32 78 fb			ld (debug_mark+1),a  
22ae 3a b8 22			ld a, (.dmark+2)  
22b1 32 79 fb			ld (debug_mark+2),a  
22b4 18 03			jr .pastdmark  
22b6 ..			.dmark: db "SWP"  
22b9 f1			.pastdmark: pop af  
22ba			endm  
# End of macro DMARK
22ba						CALLMONITOR 
22ba cd 5a 17			call break_point_state  
22bd				endm  
# End of macro CALLMONITOR
22bd					endif 
22bd			 
22bd					FORTH_DSP_VALUEHL 
22bd cd e1 1e			call macro_dsp_valuehl 
22c0				endm 
# End of macro FORTH_DSP_VALUEHL
22c0 e5					push hl     ; w2 
22c1			 
22c1					FORTH_DSP_POP 
22c1 cd 99 1f			call macro_forth_dsp_pop 
22c4				endm 
# End of macro FORTH_DSP_POP
22c4			 
22c4					FORTH_DSP_VALUEHL 
22c4 cd e1 1e			call macro_dsp_valuehl 
22c7				endm 
# End of macro FORTH_DSP_VALUEHL
22c7			 
22c7					FORTH_DSP_POP 
22c7 cd 99 1f			call macro_forth_dsp_pop 
22ca				endm 
# End of macro FORTH_DSP_POP
22ca			 
22ca d1					pop de     ; w2	, hl = w1 
22cb			 
22cb eb					ex de, hl 
22cc d5					push de 
22cd			 
22cd cd ea 1c				call forth_push_numhl 
22d0			 
22d0 e1					pop hl 
22d1			 
22d1 cd ea 1c				call forth_push_numhl 
22d4					 
22d4			 
22d4					NEXTW 
22d4 c3 53 20			jp macro_next 
22d7				endm 
# End of macro NEXTW
22d7			.COLN: 
22d7				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
22d7 19				db WORD_SYS_CORE+OPCODE_COLN             
22d8 63 24			dw .SCOLN            
22da 02				db 1 + 1 
22db .. 00			db ":",0              
22dd				endm 
# End of macro CWHEAD
22dd			; | : ( -- )         Create new word | DONE 
22dd			 
22dd					if DEBUG_FORTH_WORDS_KEY 
22dd						DMARK "CLN" 
22dd f5				push af  
22de 3a f2 22			ld a, (.dmark)  
22e1 32 77 fb			ld (debug_mark),a  
22e4 3a f3 22			ld a, (.dmark+1)  
22e7 32 78 fb			ld (debug_mark+1),a  
22ea 3a f4 22			ld a, (.dmark+2)  
22ed 32 79 fb			ld (debug_mark+2),a  
22f0 18 03			jr .pastdmark  
22f2 ..			.dmark: db "CLN"  
22f5 f1			.pastdmark: pop af  
22f6			endm  
# End of macro DMARK
22f6						CALLMONITOR 
22f6 cd 5a 17			call break_point_state  
22f9				endm  
# End of macro CALLMONITOR
22f9					endif 
22f9				STACKFRAME OFF $8efe $989f 
22f9				if DEBUG_STACK_IMB 
22f9					if OFF 
22f9						exx 
22f9						ld de, $8efe 
22f9						ld a, d 
22f9						ld hl, curframe 
22f9						call hexout 
22f9						ld a, e 
22f9						ld hl, curframe+2 
22f9						call hexout 
22f9						ld hl, $8efe 
22f9						push hl 
22f9						ld hl, $989f 
22f9						push hl 
22f9						exx 
22f9					endif 
22f9				endif 
22f9			endm 
# End of macro STACKFRAME
22f9				; get parser buffer length  of new word 
22f9			 
22f9				 
22f9			 
22f9					; move tok past this to start of name defintition 
22f9					; TODO get word to define 
22f9					; TODO Move past word token 
22f9					; TODO get length of string up to the ';' 
22f9			 
22f9 2a 1e f1			ld hl, (os_tok_ptr) 
22fc 23				inc hl 
22fd 23				inc hl 
22fe			 
22fe 3e 3b			ld a, ';' 
2300 cd 86 11			call strlent 
2303			 
2303 7d				ld a,l 
2304 32 19 ee			ld (os_new_parse_len), a 
2307			 
2307			 
2307			if DEBUG_FORTH_UWORD 
2307 ed 5b 1e f1		ld de, (os_tok_ptr) 
230b						DMARK ":01" 
230b f5				push af  
230c 3a 20 23			ld a, (.dmark)  
230f 32 77 fb			ld (debug_mark),a  
2312 3a 21 23			ld a, (.dmark+1)  
2315 32 78 fb			ld (debug_mark+1),a  
2318 3a 22 23			ld a, (.dmark+2)  
231b 32 79 fb			ld (debug_mark+2),a  
231e 18 03			jr .pastdmark  
2320 ..			.dmark: db ":01"  
2323 f1			.pastdmark: pop af  
2324			endm  
# End of macro DMARK
2324				CALLMONITOR 
2324 cd 5a 17			call break_point_state  
2327				endm  
# End of macro CALLMONITOR
2327			endif 
2327			 
2327			; 
2327			;  new word memory layout: 
2327			;  
2327			;    : adg 6666 ;  
2327			; 
2327			;    db   1     ; user defined word  
2327 23				inc hl    
2328			;    dw   sysdict 
2328 23				inc hl 
2329 23				inc hl 
232a			;    db <word len>+1 (for null) 
232a 23				inc hl 
232b			;    db .... <word> 
232b			; 
232b			 
232b 23				inc hl    ; some extras for the word preamble before the above 
232c 23				inc hl 
232d 23				inc hl 
232e 23				inc hl 
232f 23				inc hl 
2330 23				inc hl 
2331 23				inc hl  
2332 23				inc hl 
2333 23				inc hl 
2334 23				inc hl 
2335 23				inc hl 
2336 23				inc hl 
2337 23				inc hl 
2338 23				inc hl     ; TODO how many do we really need?     maybe only 6 
2339			;       exec word buffer 
2339			;	<ptr word>   
2339 23				inc hl 
233a 23				inc hl 
233b			;       <word list><null term> 7F final term 
233b			 
233b			 
233b			if DEBUG_FORTH_UWORD 
233b						DMARK ":02" 
233b f5				push af  
233c 3a 50 23			ld a, (.dmark)  
233f 32 77 fb			ld (debug_mark),a  
2342 3a 51 23			ld a, (.dmark+1)  
2345 32 78 fb			ld (debug_mark+1),a  
2348 3a 52 23			ld a, (.dmark+2)  
234b 32 79 fb			ld (debug_mark+2),a  
234e 18 03			jr .pastdmark  
2350 ..			.dmark: db ":02"  
2353 f1			.pastdmark: pop af  
2354			endm  
# End of macro DMARK
2354				CALLMONITOR 
2354 cd 5a 17			call break_point_state  
2357				endm  
# End of macro CALLMONITOR
2357			endif 
2357			 
2357				 
2357					; malloc the size 
2357			 
2357 cd e4 11				call malloc 
235a 22 1b ee				ld (os_new_malloc), hl     ; save malloc start 
235d			 
235d			;    db   1     ; user defined word  
235d 3e 01				ld a, WORD_SYS_UWORD  
235f 77					ld (hl), a 
2360				 
2360 23				inc hl    
2361			;    dw   sysdict 
2361 11 ab 21			ld de, sysdict       ; continue on with the scan to the system dict 
2364 73				ld (hl), e 
2365 23				inc hl 
2366 72				ld (hl), d 
2367 23				inc hl 
2368			 
2368			 
2368			;    Setup dict word 
2368			 
2368 23				inc hl 
2369 22 15 ee			ld (os_new_work_ptr), hl     ; save start of dict word  
236c			 
236c				; 1. get length of dict word 
236c			 
236c			 
236c 2a 1e f1			ld hl, (os_tok_ptr) 
236f 23				inc hl 
2370 23				inc hl    ; position to start of dict word 
2371 3e 00			ld a, 0 
2373 cd 86 11			call strlent 
2376			 
2376			 
2376 23				inc hl    ; to include null??? 
2377			 
2377				; write length of dict word 
2377			 
2377 ed 5b 15 ee		ld de, (os_new_work_ptr)   ; get dest for copy of word 
237b 1b				dec de 
237c eb				ex de, hl 
237d 73				ld (hl), e 
237e eb				ex de, hl 
237f			 
237f				 
237f			 
237f				; copy  
237f 4d				ld c, l 
2380 06 00			ld b, 0 
2382 ed 5b 15 ee		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2386 2a 1e f1			ld hl, (os_tok_ptr) 
2389 23				inc hl 
238a 23				inc hl    ; position to start of dict word 
238b				 
238b			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
238b				 
238b				; TODO need to convert word to upper case 
238b			 
238b			ucasetok:	 
238b 7e				ld a,(hl) 
238c cd 72 11			call toUpper 
238f 77				ld (hl),a 
2390 ed a0			ldi 
2392 f2 8b 23		 	jp p, ucasetok 
2395			 
2395			 
2395			 
2395				; de now points to start of where the word body code should be placed 
2395 ed 53 15 ee		ld (os_new_work_ptr), de 
2399				; hl now points to the words to throw at forthexec which needs to be copied 
2399 22 13 ee			ld (os_new_src_ptr), hl 
239c			 
239c				; TODO add 'call to forthexec' 
239c			 
239c			if DEBUG_FORTH_UWORD 
239c c5				push bc 
239d ed 4b 1b ee		ld bc, (os_new_malloc) 
23a1						DMARK ":0x" 
23a1 f5				push af  
23a2 3a b6 23			ld a, (.dmark)  
23a5 32 77 fb			ld (debug_mark),a  
23a8 3a b7 23			ld a, (.dmark+1)  
23ab 32 78 fb			ld (debug_mark+1),a  
23ae 3a b8 23			ld a, (.dmark+2)  
23b1 32 79 fb			ld (debug_mark+2),a  
23b4 18 03			jr .pastdmark  
23b6 ..			.dmark: db ":0x"  
23b9 f1			.pastdmark: pop af  
23ba			endm  
# End of macro DMARK
23ba				CALLMONITOR 
23ba cd 5a 17			call break_point_state  
23bd				endm  
# End of macro CALLMONITOR
23bd c1				pop bc 
23be			endif 
23be			 
23be			 
23be				; create word preamble which should be: 
23be			 
23be			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
23be			 
23be				;    ld hl, <word code> 
23be				;    jp user_exec 
23be			        ;    <word code bytes> 
23be			 
23be			 
23be			;	inc de     ; TODO ??? or are we already past the word's null 
23be eb				ex de, hl 
23bf			 
23bf 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
23c1			 
23c1 23				inc hl 
23c2 22 0f ee			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
23c5 23				inc hl 
23c6			 
23c6 23				inc hl 
23c7 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
23c9			 
23c9 01 25 51			ld bc, user_exec 
23cc 23				inc hl 
23cd 71				ld (hl), c     ; poke address of user_exec 
23ce 23				inc hl 
23cf 70				ld (hl), b     
23d0			 ; 
23d0			;	inc hl 
23d0			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
23d0			; 
23d0			; 
23d0			;	ld bc, macro_forth_rsp_next 
23d0			;	inc hl 
23d0			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
23d0			;	inc hl 
23d0			;	ld (hl), b     
23d0			 ; 
23d0			;	inc hl 
23d0			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
23d0			; 
23d0			; 
23d0			;	inc hl 
23d0			;	ld bc, forthexec 
23d0			;	ld (hl), c     ; poke address of forthexec 
23d0			;	inc hl 
23d0			;	ld (hl), b      
23d0			; 
23d0			;	inc hl 
23d0			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
23d0			; 
23d0			;	ld bc, user_dict_next 
23d0			;	inc hl 
23d0			;	ld (hl), c     ; poke address of forthexec 
23d0			;	inc hl 
23d0			;	ld (hl), b      
23d0			 
23d0				; hl is now where we need to copy the word byte data to save this 
23d0			 
23d0 23				inc hl 
23d1 22 11 ee			ld (os_new_exec), hl 
23d4				 
23d4				; copy definition 
23d4			 
23d4 eb				ex de, hl 
23d5			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
23d5			;	inc de    ; skip the PC for this parse 
23d5 3a 19 ee			ld a, (os_new_parse_len) 
23d8 4f				ld c, a 
23d9 06 00			ld b, 0 
23db ed b0			ldir		 ; copy defintion 
23dd			 
23dd			 
23dd				; poke the address of where the new word bytes live for forthexec 
23dd			 
23dd 2a 0f ee			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
23e0			 
23e0 ed 5b 11 ee		ld de, (os_new_exec)      
23e4				 
23e4 73				ld (hl), e 
23e5 23				inc hl 
23e6 72				ld (hl), d 
23e7			 
23e7					; TODO copy last user dict word next link to this word 
23e7					; TODO update last user dict word to point to this word 
23e7			; 
23e7			; hl f923 de 812a ; bc 811a 
23e7			 
23e7			if DEBUG_FORTH_UWORD 
23e7 c5				push bc 
23e8 ed 4b 1b ee		ld bc, (os_new_malloc) 
23ec						DMARK ":0A" 
23ec f5				push af  
23ed 3a 01 24			ld a, (.dmark)  
23f0 32 77 fb			ld (debug_mark),a  
23f3 3a 02 24			ld a, (.dmark+1)  
23f6 32 78 fb			ld (debug_mark+1),a  
23f9 3a 03 24			ld a, (.dmark+2)  
23fc 32 79 fb			ld (debug_mark+2),a  
23ff 18 03			jr .pastdmark  
2401 ..			.dmark: db ":0A"  
2404 f1			.pastdmark: pop af  
2405			endm  
# End of macro DMARK
2405				CALLMONITOR 
2405 cd 5a 17			call break_point_state  
2408				endm  
# End of macro CALLMONITOR
2408 c1				pop bc 
2409			endif 
2409			if DEBUG_FORTH_UWORD 
2409 c5				push bc 
240a ed 4b 1b ee		ld bc, (os_new_malloc) 
240e 03				inc bc 
240f 03				inc bc 
2410 03				inc bc 
2411 03				inc bc 
2412 03				inc bc 
2413 03				inc bc 
2414 03				inc bc 
2415 03				inc bc 
2416			 
2416						DMARK ":0B" 
2416 f5				push af  
2417 3a 2b 24			ld a, (.dmark)  
241a 32 77 fb			ld (debug_mark),a  
241d 3a 2c 24			ld a, (.dmark+1)  
2420 32 78 fb			ld (debug_mark+1),a  
2423 3a 2d 24			ld a, (.dmark+2)  
2426 32 79 fb			ld (debug_mark+2),a  
2429 18 03			jr .pastdmark  
242b ..			.dmark: db ":0B"  
242e f1			.pastdmark: pop af  
242f			endm  
# End of macro DMARK
242f				CALLMONITOR 
242f cd 5a 17			call break_point_state  
2432				endm  
# End of macro CALLMONITOR
2432 c1				pop bc 
2433			endif 
2433			 
2433			; update word dict linked list for new word 
2433			 
2433			 
2433 2a 1a f1		ld hl, (os_last_new_uword)		; get the start of the last added uword 
2436 23			inc hl     ; move to next work linked list ptr 
2437			 
2437 ed 5b 1b ee	ld de, (os_new_malloc)		 ; new next word 
243b 73			ld (hl), e 
243c 23			inc hl 
243d 72			ld (hl), d 
243e			 
243e			if DEBUG_FORTH_UWORD 
243e ed 4b 1a f1		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
2442			endif 
2442			 
2442 ed 53 1a f1	ld (os_last_new_uword), de      ; update last new uword ptr 
2446			 
2446			 
2446			if DEBUG_FORTH_UWORD 
2446						DMARK ":0+" 
2446 f5				push af  
2447 3a 5b 24			ld a, (.dmark)  
244a 32 77 fb			ld (debug_mark),a  
244d 3a 5c 24			ld a, (.dmark+1)  
2450 32 78 fb			ld (debug_mark+1),a  
2453 3a 5d 24			ld a, (.dmark+2)  
2456 32 79 fb			ld (debug_mark+2),a  
2459 18 03			jr .pastdmark  
245b ..			.dmark: db ":0+"  
245e f1			.pastdmark: pop af  
245f			endm  
# End of macro DMARK
245f				CALLMONITOR 
245f cd 5a 17			call break_point_state  
2462				endm  
# End of macro CALLMONITOR
2462			endif 
2462			 
2462				STACKFRAMECHK OFF $8efe $989f 
2462				if DEBUG_STACK_IMB 
2462					if OFF 
2462						exx 
2462						ld hl, $989f 
2462						pop de   ; $989f 
2462						call cmp16 
2462						jr nz, .spnosame 
2462						ld hl, $8efe 
2462						pop de   ; $8efe 
2462						call cmp16 
2462						jr z, .spfrsame 
2462						.spnosame: call showsperror 
2462						.spfrsame: nop 
2462						exx 
2462					endif 
2462				endif 
2462			endm 
# End of macro STACKFRAMECHK
2462			 
2462 c9			ret    ; dont process any remaining parser tokens as they form new word 
2463			 
2463			 
2463			 
2463			 
2463			;		NEXT 
2463			.SCOLN: 
2463			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
2463 06				db OPCODE_SCOLN 
2464 af 24			dw .DROP 
2466 02				db 2 
2467 .. 00			db ";",0           
2469			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
2469					if DEBUG_FORTH_WORDS_KEY 
2469						DMARK "SCN" 
2469 f5				push af  
246a 3a 7e 24			ld a, (.dmark)  
246d 32 77 fb			ld (debug_mark),a  
2470 3a 7f 24			ld a, (.dmark+1)  
2473 32 78 fb			ld (debug_mark+1),a  
2476 3a 80 24			ld a, (.dmark+2)  
2479 32 79 fb			ld (debug_mark+2),a  
247c 18 03			jr .pastdmark  
247e ..			.dmark: db "SCN"  
2481 f1			.pastdmark: pop af  
2482			endm  
# End of macro DMARK
2482						CALLMONITOR 
2482 cd 5a 17			call break_point_state  
2485				endm  
# End of macro CALLMONITOR
2485					endif 
2485					FORTH_RSP_TOS 
2485 cd a8 1c			call macro_forth_rsp_tos 
2488				endm 
# End of macro FORTH_RSP_TOS
2488 e5					push hl 
2489					FORTH_RSP_POP 
2489 cd b2 1c			call macro_forth_rsp_pop 
248c				endm 
# End of macro FORTH_RSP_POP
248c e1					pop hl 
248d			;		ex de,hl 
248d 22 1e f1				ld (os_tok_ptr),hl 
2490			 
2490			if DEBUG_FORTH_UWORD 
2490						DMARK "SCL" 
2490 f5				push af  
2491 3a a5 24			ld a, (.dmark)  
2494 32 77 fb			ld (debug_mark),a  
2497 3a a6 24			ld a, (.dmark+1)  
249a 32 78 fb			ld (debug_mark+1),a  
249d 3a a7 24			ld a, (.dmark+2)  
24a0 32 79 fb			ld (debug_mark+2),a  
24a3 18 03			jr .pastdmark  
24a5 ..			.dmark: db "SCL"  
24a8 f1			.pastdmark: pop af  
24a9			endm  
# End of macro DMARK
24a9				CALLMONITOR 
24a9 cd 5a 17			call break_point_state  
24ac				endm  
# End of macro CALLMONITOR
24ac			endif 
24ac					NEXTW 
24ac c3 53 20			jp macro_next 
24af				endm 
# End of macro NEXTW
24af			 
24af			.DROP: 
24af				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
24af 1b				db WORD_SYS_CORE+OPCODE_DROP             
24b0 da 24			dw .DUP2            
24b2 05				db 4 + 1 
24b3 .. 00			db "DROP",0              
24b8				endm 
# End of macro CWHEAD
24b8			; | DROP ( w -- )   drop the TOS item   | DONE 
24b8					if DEBUG_FORTH_WORDS_KEY 
24b8						DMARK "DRP" 
24b8 f5				push af  
24b9 3a cd 24			ld a, (.dmark)  
24bc 32 77 fb			ld (debug_mark),a  
24bf 3a ce 24			ld a, (.dmark+1)  
24c2 32 78 fb			ld (debug_mark+1),a  
24c5 3a cf 24			ld a, (.dmark+2)  
24c8 32 79 fb			ld (debug_mark+2),a  
24cb 18 03			jr .pastdmark  
24cd ..			.dmark: db "DRP"  
24d0 f1			.pastdmark: pop af  
24d1			endm  
# End of macro DMARK
24d1						CALLMONITOR 
24d1 cd 5a 17			call break_point_state  
24d4				endm  
# End of macro CALLMONITOR
24d4					endif 
24d4					FORTH_DSP_POP 
24d4 cd 99 1f			call macro_forth_dsp_pop 
24d7				endm 
# End of macro FORTH_DSP_POP
24d7					NEXTW 
24d7 c3 53 20			jp macro_next 
24da				endm 
# End of macro NEXTW
24da			.DUP2: 
24da				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
24da 1c				db WORD_SYS_CORE+OPCODE_DUP2             
24db 1f 25			dw .DROP2            
24dd 05				db 4 + 1 
24de .. 00			db "2DUP",0              
24e3				endm 
# End of macro CWHEAD
24e3			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
24e3					if DEBUG_FORTH_WORDS_KEY 
24e3						DMARK "2DU" 
24e3 f5				push af  
24e4 3a f8 24			ld a, (.dmark)  
24e7 32 77 fb			ld (debug_mark),a  
24ea 3a f9 24			ld a, (.dmark+1)  
24ed 32 78 fb			ld (debug_mark+1),a  
24f0 3a fa 24			ld a, (.dmark+2)  
24f3 32 79 fb			ld (debug_mark+2),a  
24f6 18 03			jr .pastdmark  
24f8 ..			.dmark: db "2DU"  
24fb f1			.pastdmark: pop af  
24fc			endm  
# End of macro DMARK
24fc						CALLMONITOR 
24fc cd 5a 17			call break_point_state  
24ff				endm  
# End of macro CALLMONITOR
24ff					endif 
24ff					FORTH_DSP_VALUEHL 
24ff cd e1 1e			call macro_dsp_valuehl 
2502				endm 
# End of macro FORTH_DSP_VALUEHL
2502 e5					push hl      ; 2 
2503			 
2503					FORTH_DSP_POP 
2503 cd 99 1f			call macro_forth_dsp_pop 
2506				endm 
# End of macro FORTH_DSP_POP
2506					 
2506					FORTH_DSP_VALUEHL 
2506 cd e1 1e			call macro_dsp_valuehl 
2509				endm 
# End of macro FORTH_DSP_VALUEHL
2509			;		push hl      ; 1 
2509			 
2509					FORTH_DSP_POP 
2509 cd 99 1f			call macro_forth_dsp_pop 
250c				endm 
# End of macro FORTH_DSP_POP
250c			 
250c			;		pop hl       ; 1 
250c d1					pop de       ; 2 
250d			 
250d cd ea 1c				call forth_push_numhl 
2510 eb					ex de, hl 
2511 cd ea 1c				call forth_push_numhl 
2514			 
2514					 
2514 eb					ex de, hl 
2515			 
2515 cd ea 1c				call forth_push_numhl 
2518 eb					ex de, hl 
2519 cd ea 1c				call forth_push_numhl 
251c			 
251c			 
251c					NEXTW 
251c c3 53 20			jp macro_next 
251f				endm 
# End of macro NEXTW
251f			.DROP2: 
251f				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
251f 1d				db WORD_SYS_CORE+OPCODE_DROP2             
2520 4e 25			dw .SWAP2            
2522 06				db 5 + 1 
2523 .. 00			db "2DROP",0              
2529				endm 
# End of macro CWHEAD
2529			; | 2DROP ( w w -- )    Double drop | DONE 
2529					if DEBUG_FORTH_WORDS_KEY 
2529						DMARK "2DR" 
2529 f5				push af  
252a 3a 3e 25			ld a, (.dmark)  
252d 32 77 fb			ld (debug_mark),a  
2530 3a 3f 25			ld a, (.dmark+1)  
2533 32 78 fb			ld (debug_mark+1),a  
2536 3a 40 25			ld a, (.dmark+2)  
2539 32 79 fb			ld (debug_mark+2),a  
253c 18 03			jr .pastdmark  
253e ..			.dmark: db "2DR"  
2541 f1			.pastdmark: pop af  
2542			endm  
# End of macro DMARK
2542						CALLMONITOR 
2542 cd 5a 17			call break_point_state  
2545				endm  
# End of macro CALLMONITOR
2545					endif 
2545					FORTH_DSP_POP 
2545 cd 99 1f			call macro_forth_dsp_pop 
2548				endm 
# End of macro FORTH_DSP_POP
2548					FORTH_DSP_POP 
2548 cd 99 1f			call macro_forth_dsp_pop 
254b				endm 
# End of macro FORTH_DSP_POP
254b					NEXTW 
254b c3 53 20			jp macro_next 
254e				endm 
# End of macro NEXTW
254e			.SWAP2: 
254e				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
254e 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
254f 77 25			dw .AT            
2551 06				db 5 + 1 
2552 .. 00			db "2SWAP",0              
2558				endm 
# End of macro CWHEAD
2558			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
2558					if DEBUG_FORTH_WORDS_KEY 
2558						DMARK "2SW" 
2558 f5				push af  
2559 3a 6d 25			ld a, (.dmark)  
255c 32 77 fb			ld (debug_mark),a  
255f 3a 6e 25			ld a, (.dmark+1)  
2562 32 78 fb			ld (debug_mark+1),a  
2565 3a 6f 25			ld a, (.dmark+2)  
2568 32 79 fb			ld (debug_mark+2),a  
256b 18 03			jr .pastdmark  
256d ..			.dmark: db "2SW"  
2570 f1			.pastdmark: pop af  
2571			endm  
# End of macro DMARK
2571						CALLMONITOR 
2571 cd 5a 17			call break_point_state  
2574				endm  
# End of macro CALLMONITOR
2574					endif 
2574					NEXTW 
2574 c3 53 20			jp macro_next 
2577				endm 
# End of macro NEXTW
2577			.AT: 
2577				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
2577 1f				db WORD_SYS_CORE+OPCODE_AT             
2578 a9 25			dw .CAT            
257a 02				db 1 + 1 
257b .. 00			db "@",0              
257d				endm 
# End of macro CWHEAD
257d			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
257d			 
257d					if DEBUG_FORTH_WORDS_KEY 
257d						DMARK "AT." 
257d f5				push af  
257e 3a 92 25			ld a, (.dmark)  
2581 32 77 fb			ld (debug_mark),a  
2584 3a 93 25			ld a, (.dmark+1)  
2587 32 78 fb			ld (debug_mark+1),a  
258a 3a 94 25			ld a, (.dmark+2)  
258d 32 79 fb			ld (debug_mark+2),a  
2590 18 03			jr .pastdmark  
2592 ..			.dmark: db "AT."  
2595 f1			.pastdmark: pop af  
2596			endm  
# End of macro DMARK
2596						CALLMONITOR 
2596 cd 5a 17			call break_point_state  
2599				endm  
# End of macro CALLMONITOR
2599					endif 
2599			.getbyteat:	 
2599					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2599 cd e1 1e			call macro_dsp_valuehl 
259c				endm 
# End of macro FORTH_DSP_VALUEHL
259c					 
259c			;		push hl 
259c				 
259c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
259c cd 99 1f			call macro_forth_dsp_pop 
259f				endm 
# End of macro FORTH_DSP_POP
259f			 
259f			;		pop hl 
259f			 
259f 7e					ld a, (hl) 
25a0			 
25a0 6f					ld l, a 
25a1 26 00				ld h, 0 
25a3 cd ea 1c				call forth_push_numhl 
25a6			 
25a6					NEXTW 
25a6 c3 53 20			jp macro_next 
25a9				endm 
# End of macro NEXTW
25a9			.CAT: 
25a9				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
25a9 20				db WORD_SYS_CORE+OPCODE_CAT             
25aa d2 25			dw .BANG            
25ac 03				db 2 + 1 
25ad .. 00			db "C@",0              
25b0				endm 
# End of macro CWHEAD
25b0			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
25b0					if DEBUG_FORTH_WORDS_KEY 
25b0						DMARK "CAA" 
25b0 f5				push af  
25b1 3a c5 25			ld a, (.dmark)  
25b4 32 77 fb			ld (debug_mark),a  
25b7 3a c6 25			ld a, (.dmark+1)  
25ba 32 78 fb			ld (debug_mark+1),a  
25bd 3a c7 25			ld a, (.dmark+2)  
25c0 32 79 fb			ld (debug_mark+2),a  
25c3 18 03			jr .pastdmark  
25c5 ..			.dmark: db "CAA"  
25c8 f1			.pastdmark: pop af  
25c9			endm  
# End of macro DMARK
25c9						CALLMONITOR 
25c9 cd 5a 17			call break_point_state  
25cc				endm  
# End of macro CALLMONITOR
25cc					endif 
25cc c3 99 25				jp .getbyteat 
25cf					NEXTW 
25cf c3 53 20			jp macro_next 
25d2				endm 
# End of macro NEXTW
25d2			.BANG: 
25d2				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
25d2 21				db WORD_SYS_CORE+OPCODE_BANG             
25d3 08 26			dw .CBANG            
25d5 02				db 1 + 1 
25d6 .. 00			db "!",0              
25d8				endm 
# End of macro CWHEAD
25d8			; | ! ( x w -- ) Store x at address w      | DONE 
25d8					if DEBUG_FORTH_WORDS_KEY 
25d8						DMARK "BNG" 
25d8 f5				push af  
25d9 3a ed 25			ld a, (.dmark)  
25dc 32 77 fb			ld (debug_mark),a  
25df 3a ee 25			ld a, (.dmark+1)  
25e2 32 78 fb			ld (debug_mark+1),a  
25e5 3a ef 25			ld a, (.dmark+2)  
25e8 32 79 fb			ld (debug_mark+2),a  
25eb 18 03			jr .pastdmark  
25ed ..			.dmark: db "BNG"  
25f0 f1			.pastdmark: pop af  
25f1			endm  
# End of macro DMARK
25f1						CALLMONITOR 
25f1 cd 5a 17			call break_point_state  
25f4				endm  
# End of macro CALLMONITOR
25f4					endif 
25f4			 
25f4			.storebyteat:		 
25f4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25f4 cd e1 1e			call macro_dsp_valuehl 
25f7				endm 
# End of macro FORTH_DSP_VALUEHL
25f7					 
25f7 e5					push hl 
25f8				 
25f8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25f8 cd 99 1f			call macro_forth_dsp_pop 
25fb				endm 
# End of macro FORTH_DSP_POP
25fb			 
25fb					; get byte to poke 
25fb			 
25fb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25fb cd e1 1e			call macro_dsp_valuehl 
25fe				endm 
# End of macro FORTH_DSP_VALUEHL
25fe e5					push hl 
25ff			 
25ff			 
25ff					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25ff cd 99 1f			call macro_forth_dsp_pop 
2602				endm 
# End of macro FORTH_DSP_POP
2602			 
2602			 
2602 d1					pop de 
2603 e1					pop hl 
2604			 
2604 73					ld (hl),e 
2605			 
2605			 
2605					NEXTW 
2605 c3 53 20			jp macro_next 
2608				endm 
# End of macro NEXTW
2608			.CBANG: 
2608				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
2608 22				db WORD_SYS_CORE+OPCODE_CBANG             
2609 31 26			dw .SCALL            
260b 03				db 2 + 1 
260c .. 00			db "C!",0              
260f				endm 
# End of macro CWHEAD
260f			; | C!  ( x w -- ) Store x at address w  | DONE 
260f					if DEBUG_FORTH_WORDS_KEY 
260f						DMARK "CBA" 
260f f5				push af  
2610 3a 24 26			ld a, (.dmark)  
2613 32 77 fb			ld (debug_mark),a  
2616 3a 25 26			ld a, (.dmark+1)  
2619 32 78 fb			ld (debug_mark+1),a  
261c 3a 26 26			ld a, (.dmark+2)  
261f 32 79 fb			ld (debug_mark+2),a  
2622 18 03			jr .pastdmark  
2624 ..			.dmark: db "CBA"  
2627 f1			.pastdmark: pop af  
2628			endm  
# End of macro DMARK
2628						CALLMONITOR 
2628 cd 5a 17			call break_point_state  
262b				endm  
# End of macro CALLMONITOR
262b					endif 
262b c3 f4 25				jp .storebyteat 
262e					NEXTW 
262e c3 53 20			jp macro_next 
2631				endm 
# End of macro NEXTW
2631			.SCALL: 
2631				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
2631 23				db WORD_SYS_CORE+OPCODE_SCALL             
2632 65 26			dw .DEPTH            
2634 05				db 4 + 1 
2635 .. 00			db "CALL",0              
263a				endm 
# End of macro CWHEAD
263a			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
263a					if DEBUG_FORTH_WORDS_KEY 
263a						DMARK "CLL" 
263a f5				push af  
263b 3a 4f 26			ld a, (.dmark)  
263e 32 77 fb			ld (debug_mark),a  
2641 3a 50 26			ld a, (.dmark+1)  
2644 32 78 fb			ld (debug_mark+1),a  
2647 3a 51 26			ld a, (.dmark+2)  
264a 32 79 fb			ld (debug_mark+2),a  
264d 18 03			jr .pastdmark  
264f ..			.dmark: db "CLL"  
2652 f1			.pastdmark: pop af  
2653			endm  
# End of macro DMARK
2653						CALLMONITOR 
2653 cd 5a 17			call break_point_state  
2656				endm  
# End of macro CALLMONITOR
2656					endif 
2656			 
2656					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2656 cd e1 1e			call macro_dsp_valuehl 
2659				endm 
# End of macro FORTH_DSP_VALUEHL
2659			 
2659			;		push hl 
2659			 
2659					; destroy value TOS 
2659			 
2659					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2659 cd 99 1f			call macro_forth_dsp_pop 
265c				endm 
# End of macro FORTH_DSP_POP
265c			 
265c						 
265c			;		pop hl 
265c			 
265c					; how to do a call with hl???? save SP? 
265c cd fc 1f				call forth_call_hl 
265f			 
265f			 
265f					; TODO push value back onto stack for another op etc 
265f			 
265f cd ea 1c				call forth_push_numhl 
2662					NEXTW 
2662 c3 53 20			jp macro_next 
2665				endm 
# End of macro NEXTW
2665			.DEPTH: 
2665				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2665 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2666 a2 26			dw .OVER            
2668 06				db 5 + 1 
2669 .. 00			db "DEPTH",0              
266f				endm 
# End of macro CWHEAD
266f			; | DEPTH ( -- u ) Push count of stack | DONE 
266f					; take current TOS and remove from base value div by two to get count 
266f					if DEBUG_FORTH_WORDS_KEY 
266f						DMARK "DEP" 
266f f5				push af  
2670 3a 84 26			ld a, (.dmark)  
2673 32 77 fb			ld (debug_mark),a  
2676 3a 85 26			ld a, (.dmark+1)  
2679 32 78 fb			ld (debug_mark+1),a  
267c 3a 86 26			ld a, (.dmark+2)  
267f 32 79 fb			ld (debug_mark+2),a  
2682 18 03			jr .pastdmark  
2684 ..			.dmark: db "DEP"  
2687 f1			.pastdmark: pop af  
2688			endm  
# End of macro DMARK
2688						CALLMONITOR 
2688 cd 5a 17			call break_point_state  
268b				endm  
# End of macro CALLMONITOR
268b					endif 
268b			 
268b			 
268b 2a 0a f8			ld hl, (cli_data_sp) 
268e 11 84 f3			ld de, cli_data_stack 
2691 ed 52			sbc hl,de 
2693				 
2693				; div by size of stack item 
2693			 
2693 5d				ld e,l 
2694 0e 03			ld c, 3 
2696 cd ad 0c			call Div8 
2699			 
2699 6f				ld l,a 
269a 26 00			ld h,0 
269c			 
269c				;srl h 
269c				;rr l 
269c			 
269c cd ea 1c				call forth_push_numhl 
269f					NEXTW 
269f c3 53 20			jp macro_next 
26a2				endm 
# End of macro NEXTW
26a2			.OVER: 
26a2				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
26a2 42				db WORD_SYS_CORE+46             
26a3 e9 26			dw .PAUSE            
26a5 05				db 4 + 1 
26a6 .. 00			db "OVER",0              
26ab				endm 
# End of macro CWHEAD
26ab			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
26ab					if DEBUG_FORTH_WORDS_KEY 
26ab						DMARK "OVR" 
26ab f5				push af  
26ac 3a c0 26			ld a, (.dmark)  
26af 32 77 fb			ld (debug_mark),a  
26b2 3a c1 26			ld a, (.dmark+1)  
26b5 32 78 fb			ld (debug_mark+1),a  
26b8 3a c2 26			ld a, (.dmark+2)  
26bb 32 79 fb			ld (debug_mark+2),a  
26be 18 03			jr .pastdmark  
26c0 ..			.dmark: db "OVR"  
26c3 f1			.pastdmark: pop af  
26c4			endm  
# End of macro DMARK
26c4						CALLMONITOR 
26c4 cd 5a 17			call break_point_state  
26c7				endm  
# End of macro CALLMONITOR
26c7					endif 
26c7			 
26c7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26c7 cd e1 1e			call macro_dsp_valuehl 
26ca				endm 
# End of macro FORTH_DSP_VALUEHL
26ca e5					push hl    ; n2 
26cb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26cb cd 99 1f			call macro_forth_dsp_pop 
26ce				endm 
# End of macro FORTH_DSP_POP
26ce			 
26ce					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26ce cd e1 1e			call macro_dsp_valuehl 
26d1				endm 
# End of macro FORTH_DSP_VALUEHL
26d1 e5					push hl    ; n1 
26d2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26d2 cd 99 1f			call macro_forth_dsp_pop 
26d5				endm 
# End of macro FORTH_DSP_POP
26d5			 
26d5 d1					pop de     ; n1 
26d6 e1					pop hl     ; n2 
26d7			 
26d7 d5					push de 
26d8 e5					push hl 
26d9 d5					push de 
26da			 
26da					; push back  
26da			 
26da e1					pop hl 
26db cd ea 1c				call forth_push_numhl 
26de e1					pop hl 
26df cd ea 1c				call forth_push_numhl 
26e2 e1					pop hl 
26e3 cd ea 1c				call forth_push_numhl 
26e6					NEXTW 
26e6 c3 53 20			jp macro_next 
26e9				endm 
# End of macro NEXTW
26e9			 
26e9			.PAUSE: 
26e9				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
26e9 43				db WORD_SYS_CORE+47             
26ea 1e 27			dw .PAUSES            
26ec 08				db 7 + 1 
26ed .. 00			db "PAUSEMS",0              
26f5				endm 
# End of macro CWHEAD
26f5			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
26f5					if DEBUG_FORTH_WORDS_KEY 
26f5						DMARK "PMS" 
26f5 f5				push af  
26f6 3a 0a 27			ld a, (.dmark)  
26f9 32 77 fb			ld (debug_mark),a  
26fc 3a 0b 27			ld a, (.dmark+1)  
26ff 32 78 fb			ld (debug_mark+1),a  
2702 3a 0c 27			ld a, (.dmark+2)  
2705 32 79 fb			ld (debug_mark+2),a  
2708 18 03			jr .pastdmark  
270a ..			.dmark: db "PMS"  
270d f1			.pastdmark: pop af  
270e			endm  
# End of macro DMARK
270e						CALLMONITOR 
270e cd 5a 17			call break_point_state  
2711				endm  
# End of macro CALLMONITOR
2711					endif 
2711					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2711 cd e1 1e			call macro_dsp_valuehl 
2714				endm 
# End of macro FORTH_DSP_VALUEHL
2714			;		push hl    ; n2 
2714					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2714 cd 99 1f			call macro_forth_dsp_pop 
2717				endm 
# End of macro FORTH_DSP_POP
2717			;		pop hl 
2717			 
2717 7d					ld a, l 
2718 cd 4e 0a				call aDelayInMS 
271b				       NEXTW 
271b c3 53 20			jp macro_next 
271e				endm 
# End of macro NEXTW
271e			.PAUSES:  
271e				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
271e 44				db WORD_SYS_CORE+48             
271f 8d 27			dw .ROT            
2721 06				db 5 + 1 
2722 .. 00			db "PAUSE",0              
2728				endm 
# End of macro CWHEAD
2728			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2728					if DEBUG_FORTH_WORDS_KEY 
2728						DMARK "PAU" 
2728 f5				push af  
2729 3a 3d 27			ld a, (.dmark)  
272c 32 77 fb			ld (debug_mark),a  
272f 3a 3e 27			ld a, (.dmark+1)  
2732 32 78 fb			ld (debug_mark+1),a  
2735 3a 3f 27			ld a, (.dmark+2)  
2738 32 79 fb			ld (debug_mark+2),a  
273b 18 03			jr .pastdmark  
273d ..			.dmark: db "PAU"  
2740 f1			.pastdmark: pop af  
2741			endm  
# End of macro DMARK
2741						CALLMONITOR 
2741 cd 5a 17			call break_point_state  
2744				endm  
# End of macro CALLMONITOR
2744					endif 
2744					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2744 cd e1 1e			call macro_dsp_valuehl 
2747				endm 
# End of macro FORTH_DSP_VALUEHL
2747			;		push hl    ; n2 
2747					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2747 cd 99 1f			call macro_forth_dsp_pop 
274a				endm 
# End of macro FORTH_DSP_POP
274a			;		pop hl 
274a 45					ld b, l 
274b					if DEBUG_FORTH_WORDS 
274b						DMARK "PAU" 
274b f5				push af  
274c 3a 60 27			ld a, (.dmark)  
274f 32 77 fb			ld (debug_mark),a  
2752 3a 61 27			ld a, (.dmark+1)  
2755 32 78 fb			ld (debug_mark+1),a  
2758 3a 62 27			ld a, (.dmark+2)  
275b 32 79 fb			ld (debug_mark+2),a  
275e 18 03			jr .pastdmark  
2760 ..			.dmark: db "PAU"  
2763 f1			.pastdmark: pop af  
2764			endm  
# End of macro DMARK
2764						CALLMONITOR 
2764 cd 5a 17			call break_point_state  
2767				endm  
# End of macro CALLMONITOR
2767					endif 
2767 c5			.pauses1:	push bc 
2768 cd 69 0a				call delay1s 
276b c1					pop bc 
276c					if DEBUG_FORTH_WORDS 
276c						DMARK "PA1" 
276c f5				push af  
276d 3a 81 27			ld a, (.dmark)  
2770 32 77 fb			ld (debug_mark),a  
2773 3a 82 27			ld a, (.dmark+1)  
2776 32 78 fb			ld (debug_mark+1),a  
2779 3a 83 27			ld a, (.dmark+2)  
277c 32 79 fb			ld (debug_mark+2),a  
277f 18 03			jr .pastdmark  
2781 ..			.dmark: db "PA1"  
2784 f1			.pastdmark: pop af  
2785			endm  
# End of macro DMARK
2785						CALLMONITOR 
2785 cd 5a 17			call break_point_state  
2788				endm  
# End of macro CALLMONITOR
2788					endif 
2788 10 dd				djnz .pauses1 
278a			 
278a				       NEXTW 
278a c3 53 20			jp macro_next 
278d				endm 
# End of macro NEXTW
278d			.ROT: 
278d				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
278d 45				db WORD_SYS_CORE+49             
278e db 27			dw .UWORDS            
2790 04				db 3 + 1 
2791 .. 00			db "ROT",0              
2795				endm 
# End of macro CWHEAD
2795			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2795					if DEBUG_FORTH_WORDS_KEY 
2795						DMARK "ROT" 
2795 f5				push af  
2796 3a aa 27			ld a, (.dmark)  
2799 32 77 fb			ld (debug_mark),a  
279c 3a ab 27			ld a, (.dmark+1)  
279f 32 78 fb			ld (debug_mark+1),a  
27a2 3a ac 27			ld a, (.dmark+2)  
27a5 32 79 fb			ld (debug_mark+2),a  
27a8 18 03			jr .pastdmark  
27aa ..			.dmark: db "ROT"  
27ad f1			.pastdmark: pop af  
27ae			endm  
# End of macro DMARK
27ae						CALLMONITOR 
27ae cd 5a 17			call break_point_state  
27b1				endm  
# End of macro CALLMONITOR
27b1					endif 
27b1			 
27b1					FORTH_DSP_VALUEHL 
27b1 cd e1 1e			call macro_dsp_valuehl 
27b4				endm 
# End of macro FORTH_DSP_VALUEHL
27b4 e5					push hl    ; u3  
27b5			 
27b5					FORTH_DSP_POP 
27b5 cd 99 1f			call macro_forth_dsp_pop 
27b8				endm 
# End of macro FORTH_DSP_POP
27b8			   
27b8					FORTH_DSP_VALUEHL 
27b8 cd e1 1e			call macro_dsp_valuehl 
27bb				endm 
# End of macro FORTH_DSP_VALUEHL
27bb e5					push hl     ; u2 
27bc			 
27bc					FORTH_DSP_POP 
27bc cd 99 1f			call macro_forth_dsp_pop 
27bf				endm 
# End of macro FORTH_DSP_POP
27bf			 
27bf					FORTH_DSP_VALUEHL 
27bf cd e1 1e			call macro_dsp_valuehl 
27c2				endm 
# End of macro FORTH_DSP_VALUEHL
27c2 e5					push hl     ; u1 
27c3			 
27c3					FORTH_DSP_POP 
27c3 cd 99 1f			call macro_forth_dsp_pop 
27c6				endm 
# End of macro FORTH_DSP_POP
27c6			 
27c6 c1					pop bc      ; u1 
27c7 e1					pop hl      ; u2 
27c8 d1					pop de      ; u3 
27c9			 
27c9			 
27c9 c5					push bc 
27ca d5					push de 
27cb e5					push hl 
27cc			 
27cc			 
27cc e1					pop hl 
27cd cd ea 1c				call forth_push_numhl 
27d0			 
27d0 e1					pop hl 
27d1 cd ea 1c				call forth_push_numhl 
27d4			 
27d4 e1					pop hl 
27d5 cd ea 1c				call forth_push_numhl 
27d8					 
27d8			 
27d8			 
27d8			 
27d8			 
27d8			 
27d8				       NEXTW 
27d8 c3 53 20			jp macro_next 
27db				endm 
# End of macro NEXTW
27db			 
27db			.UWORDS: 
27db				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
27db 50				db WORD_SYS_CORE+60             
27dc 9d 28			dw .BP            
27de 07				db 6 + 1 
27df .. 00			db "UWORDS",0              
27e6				endm 
# End of macro CWHEAD
27e6			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
27e6			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
27e6			; | | Following the count are the individual words. 
27e6			; | | 
27e6			; | | e.g. UWORDS 
27e6			; | | BOX DIRLIST 2 
27e6			; | |  
27e6			; | | Can be used to save the words to storage via: 
27e6			; | | UWORDS $01 DO $01 APPEND LOOP 
27e6				if DEBUG_FORTH_WORDS_KEY 
27e6					DMARK "UWR" 
27e6 f5				push af  
27e7 3a fb 27			ld a, (.dmark)  
27ea 32 77 fb			ld (debug_mark),a  
27ed 3a fc 27			ld a, (.dmark+1)  
27f0 32 78 fb			ld (debug_mark+1),a  
27f3 3a fd 27			ld a, (.dmark+2)  
27f6 32 79 fb			ld (debug_mark+2),a  
27f9 18 03			jr .pastdmark  
27fb ..			.dmark: db "UWR"  
27fe f1			.pastdmark: pop af  
27ff			endm  
# End of macro DMARK
27ff					CALLMONITOR 
27ff cd 5a 17			call break_point_state  
2802				endm  
# End of macro CALLMONITOR
2802				endif 
2802 21 00 80				ld hl, baseram 
2805					;ld hl, baseusermem 
2805 01 00 00				ld bc, 0    ; start a counter 
2808			 
2808				; skip dict stub 
2808			 
2808 cd a4 21				call forth_tok_next 
280b			 
280b			 
280b			; while we have words to look for 
280b			 
280b 7e			.douscan:	ld a, (hl)      
280c				if DEBUG_FORTH_WORDS 
280c					DMARK "UWs" 
280c f5				push af  
280d 3a 21 28			ld a, (.dmark)  
2810 32 77 fb			ld (debug_mark),a  
2813 3a 22 28			ld a, (.dmark+1)  
2816 32 78 fb			ld (debug_mark+1),a  
2819 3a 23 28			ld a, (.dmark+2)  
281c 32 79 fb			ld (debug_mark+2),a  
281f 18 03			jr .pastdmark  
2821 ..			.dmark: db "UWs"  
2824 f1			.pastdmark: pop af  
2825			endm  
# End of macro DMARK
2825					CALLMONITOR 
2825 cd 5a 17			call break_point_state  
2828				endm  
# End of macro CALLMONITOR
2828				endif 
2828 fe 00				cp WORD_SYS_END 
282a 28 4d				jr z, .udone 
282c fe 01				cp WORD_SYS_UWORD 
282e 20 44				jr nz, .nuword 
2830			 
2830				if DEBUG_FORTH_WORDS 
2830					DMARK "UWu" 
2830 f5				push af  
2831 3a 45 28			ld a, (.dmark)  
2834 32 77 fb			ld (debug_mark),a  
2837 3a 46 28			ld a, (.dmark+1)  
283a 32 78 fb			ld (debug_mark+1),a  
283d 3a 47 28			ld a, (.dmark+2)  
2840 32 79 fb			ld (debug_mark+2),a  
2843 18 03			jr .pastdmark  
2845 ..			.dmark: db "UWu"  
2848 f1			.pastdmark: pop af  
2849			endm  
# End of macro DMARK
2849					CALLMONITOR 
2849 cd 5a 17			call break_point_state  
284c				endm  
# End of macro CALLMONITOR
284c				endif 
284c					; we have a uword so push its name to the stack 
284c			 
284c e5				   	push hl  ; save so we can move to next dict block 
284d			 
284d					; skip opcode 
284d 23					inc hl  
284e					; skip next ptr 
284e 23					inc hl  
284f 23					inc hl 
2850					; skip len 
2850 23					inc hl 
2851				if DEBUG_FORTH_WORDS 
2851					DMARK "UWt" 
2851 f5				push af  
2852 3a 66 28			ld a, (.dmark)  
2855 32 77 fb			ld (debug_mark),a  
2858 3a 67 28			ld a, (.dmark+1)  
285b 32 78 fb			ld (debug_mark+1),a  
285e 3a 68 28			ld a, (.dmark+2)  
2861 32 79 fb			ld (debug_mark+2),a  
2864 18 03			jr .pastdmark  
2866 ..			.dmark: db "UWt"  
2869 f1			.pastdmark: pop af  
286a			endm  
# End of macro DMARK
286a					CALLMONITOR 
286a cd 5a 17			call break_point_state  
286d				endm  
# End of macro CALLMONITOR
286d				endif 
286d 03					inc bc 
286e			 
286e c5					push bc 
286f cd 58 1d				call forth_push_str 
2872 c1					pop bc 
2873			 
2873 e1					pop hl 	 
2874			 
2874 cd a4 21		.nuword:	call forth_tok_next 
2877 18 92				jr .douscan  
2879			 
2879			.udone:		 ; push count of uwords found 
2879 c5					push bc 
287a e1					pop hl 
287b			 
287b				if DEBUG_FORTH_WORDS 
287b					DMARK "UWc" 
287b f5				push af  
287c 3a 90 28			ld a, (.dmark)  
287f 32 77 fb			ld (debug_mark),a  
2882 3a 91 28			ld a, (.dmark+1)  
2885 32 78 fb			ld (debug_mark+1),a  
2888 3a 92 28			ld a, (.dmark+2)  
288b 32 79 fb			ld (debug_mark+2),a  
288e 18 03			jr .pastdmark  
2890 ..			.dmark: db "UWc"  
2893 f1			.pastdmark: pop af  
2894			endm  
# End of macro DMARK
2894					CALLMONITOR 
2894 cd 5a 17			call break_point_state  
2897				endm  
# End of macro CALLMONITOR
2897				endif 
2897 cd ea 1c				call forth_push_numhl 
289a			 
289a			 
289a				       NEXTW 
289a c3 53 20			jp macro_next 
289d				endm 
# End of macro NEXTW
289d			 
289d			.BP: 
289d				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
289d 54				db WORD_SYS_CORE+64             
289e d3 28			dw .MONITOR            
28a0 03				db 2 + 1 
28a1 .. 00			db "BP",0              
28a4				endm 
# End of macro CWHEAD
28a4			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
28a4			; | | $00 Will enable the break points within specific code paths 
28a4			; | | $01 Will disable break points 
28a4			; | |  
28a4			; | | By default break points are off. Either the above can be used to enable them 
28a4			; | | or if a key is held down during start up the spashscreen will appear to freeze 
28a4			; | | and on release of the pressed key a message will be disaplayed to notify 
28a4			; | | that break points are enabled. Pressing any key will then continue boot process. 
28a4					; get byte count 
28a4					if DEBUG_FORTH_WORDS_KEY 
28a4						DMARK "BP." 
28a4 f5				push af  
28a5 3a b9 28			ld a, (.dmark)  
28a8 32 77 fb			ld (debug_mark),a  
28ab 3a ba 28			ld a, (.dmark+1)  
28ae 32 78 fb			ld (debug_mark+1),a  
28b1 3a bb 28			ld a, (.dmark+2)  
28b4 32 79 fb			ld (debug_mark+2),a  
28b7 18 03			jr .pastdmark  
28b9 ..			.dmark: db "BP."  
28bc f1			.pastdmark: pop af  
28bd			endm  
# End of macro DMARK
28bd						CALLMONITOR 
28bd cd 5a 17			call break_point_state  
28c0				endm  
# End of macro CALLMONITOR
28c0					endif 
28c0			 
28c0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
28c0 cd e1 1e			call macro_dsp_valuehl 
28c3				endm 
# End of macro FORTH_DSP_VALUEHL
28c3			 
28c3			;		push hl 
28c3			 
28c3					; destroy value TOS 
28c3			 
28c3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
28c3 cd 99 1f			call macro_forth_dsp_pop 
28c6				endm 
# End of macro FORTH_DSP_POP
28c6			 
28c6			;		pop hl 
28c6			 
28c6 3e 00				ld a,0 
28c8 bd					cp l 
28c9 28 02				jr z, .bpset 
28cb 3e 2a				ld a, '*' 
28cd			 
28cd 32 0e ee		.bpset:		ld (os_view_disable), a 
28d0			 
28d0			 
28d0					NEXTW 
28d0 c3 53 20			jp macro_next 
28d3				endm 
# End of macro NEXTW
28d3			 
28d3			 
28d3			.MONITOR: 
28d3				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
28d3 55				db WORD_SYS_CORE+65             
28d4 06 29			dw .MALLOC            
28d6 08				db 7 + 1 
28d7 .. 00			db "MONITOR",0              
28df				endm 
# End of macro CWHEAD
28df			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
28df			; | | At start the current various registers will be displayed with contents. 
28df			; | | Top right corner will show the most recent debug marker seen. 
28df			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
28df			; | | and the return stack pointer (RSP). 
28df			; | | Pressing: 
28df			; | |    1 - Initial screen 
28df			; | |    2 - Display a data dump of HL 
28df			; | |    3 - Display a data dump of DE 
28df			; | |    4 - Display a data dump of BC 
28df			; | |    5 - Display a data dump of HL 
28df			; | |    6 - Display a data dump of DSP 
28df			; | |    7 - Display a data dump of RSP 
28df			; | |    8 - Display a data dump of what is at DSP 
28df			; | |    9 - Display a data dump of what is at RSP 
28df			; | |    0 - Exit monitor and continue running. This will also enable break points 
28df			; | |    * - Disable break points 
28df			; | |    # - Enter traditional monitor mode 
28df			; | | 
28df			; | | Monitor Mode 
28df			; | | ------------ 
28df			; | | A prompt of '>' will be shown for various commands: 
28df			; | |    D xxxx - Display a data dump starting from hex address xxxx 
28df			; | |    C - Continue display a data dump from the last set address 
28df			; | |    M xxxx - Set start of memory edit at address xx 
28df			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
28df			; | |    Q - Return to previous 
28df					if DEBUG_FORTH_WORDS_KEY 
28df						DMARK "MON" 
28df f5				push af  
28e0 3a f4 28			ld a, (.dmark)  
28e3 32 77 fb			ld (debug_mark),a  
28e6 3a f5 28			ld a, (.dmark+1)  
28e9 32 78 fb			ld (debug_mark+1),a  
28ec 3a f6 28			ld a, (.dmark+2)  
28ef 32 79 fb			ld (debug_mark+2),a  
28f2 18 03			jr .pastdmark  
28f4 ..			.dmark: db "MON"  
28f7 f1			.pastdmark: pop af  
28f8			endm  
# End of macro DMARK
28f8						CALLMONITOR 
28f8 cd 5a 17			call break_point_state  
28fb				endm  
# End of macro CALLMONITOR
28fb					endif 
28fb 3e 00				ld a, 0 
28fd 32 0e ee				ld (os_view_disable), a 
2900			 
2900					CALLMONITOR 
2900 cd 5a 17			call break_point_state  
2903				endm  
# End of macro CALLMONITOR
2903			 
2903			;	call monitor 
2903			 
2903					NEXTW 
2903 c3 53 20			jp macro_next 
2906				endm 
# End of macro NEXTW
2906			 
2906			 
2906			.MALLOC: 
2906				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2906 56				db WORD_SYS_CORE+66             
2907 2f 29			dw .MALLOC2            
2909 06				db 5 + 1 
290a .. 00			db "ALLOT",0              
2910				endm 
# End of macro CWHEAD
2910			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2910					if DEBUG_FORTH_WORDS_KEY 
2910						DMARK "ALL" 
2910 f5				push af  
2911 3a 25 29			ld a, (.dmark)  
2914 32 77 fb			ld (debug_mark),a  
2917 3a 26 29			ld a, (.dmark+1)  
291a 32 78 fb			ld (debug_mark+1),a  
291d 3a 27 29			ld a, (.dmark+2)  
2920 32 79 fb			ld (debug_mark+2),a  
2923 18 03			jr .pastdmark  
2925 ..			.dmark: db "ALL"  
2928 f1			.pastdmark: pop af  
2929			endm  
# End of macro DMARK
2929						CALLMONITOR 
2929 cd 5a 17			call break_point_state  
292c				endm  
# End of macro CALLMONITOR
292c					endif 
292c c3 56 29				jp .mallocc 
292f			.MALLOC2: 
292f				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
292f 56				db WORD_SYS_CORE+66             
2930 6d 29			dw .FREE            
2932 07				db 6 + 1 
2933 .. 00			db "MALLOC",0              
293a				endm 
# End of macro CWHEAD
293a			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
293a					; get byte count 
293a					if DEBUG_FORTH_WORDS_KEY 
293a						DMARK "MAL" 
293a f5				push af  
293b 3a 4f 29			ld a, (.dmark)  
293e 32 77 fb			ld (debug_mark),a  
2941 3a 50 29			ld a, (.dmark+1)  
2944 32 78 fb			ld (debug_mark+1),a  
2947 3a 51 29			ld a, (.dmark+2)  
294a 32 79 fb			ld (debug_mark+2),a  
294d 18 03			jr .pastdmark  
294f ..			.dmark: db "MAL"  
2952 f1			.pastdmark: pop af  
2953			endm  
# End of macro DMARK
2953						CALLMONITOR 
2953 cd 5a 17			call break_point_state  
2956				endm  
# End of macro CALLMONITOR
2956					endif 
2956			.mallocc: 
2956					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2956 cd e1 1e			call macro_dsp_valuehl 
2959				endm 
# End of macro FORTH_DSP_VALUEHL
2959			 
2959			;		push hl 
2959			 
2959					; destroy value TOS 
2959			 
2959					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2959 cd 99 1f			call macro_forth_dsp_pop 
295c				endm 
# End of macro FORTH_DSP_POP
295c			 
295c			;		pop hl 
295c cd e4 11				call malloc 
295f				if DEBUG_FORTH_MALLOC_GUARD 
295f f5					push af 
2960 cd 46 0d				call ishlzero 
2963			;		ld a, l 
2963			;		add h 
2963			;		cp 0 
2963 f1					pop af 
2964					 
2964 cc f7 51				call z,malloc_error 
2967				endif 
2967			 
2967 cd ea 1c				call forth_push_numhl 
296a					NEXTW 
296a c3 53 20			jp macro_next 
296d				endm 
# End of macro NEXTW
296d			 
296d			.FREE: 
296d				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
296d 57				db WORD_SYS_CORE+67             
296e 9e 29			dw .LIST            
2970 05				db 4 + 1 
2971 .. 00			db "FREE",0              
2976				endm 
# End of macro CWHEAD
2976			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2976					if DEBUG_FORTH_WORDS_KEY 
2976						DMARK "FRE" 
2976 f5				push af  
2977 3a 8b 29			ld a, (.dmark)  
297a 32 77 fb			ld (debug_mark),a  
297d 3a 8c 29			ld a, (.dmark+1)  
2980 32 78 fb			ld (debug_mark+1),a  
2983 3a 8d 29			ld a, (.dmark+2)  
2986 32 79 fb			ld (debug_mark+2),a  
2989 18 03			jr .pastdmark  
298b ..			.dmark: db "FRE"  
298e f1			.pastdmark: pop af  
298f			endm  
# End of macro DMARK
298f						CALLMONITOR 
298f cd 5a 17			call break_point_state  
2992				endm  
# End of macro CALLMONITOR
2992					endif 
2992					; get address 
2992			 
2992					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2992 cd e1 1e			call macro_dsp_valuehl 
2995				endm 
# End of macro FORTH_DSP_VALUEHL
2995			 
2995			;		push hl 
2995			 
2995					; destroy value TOS 
2995			 
2995					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2995 cd 99 1f			call macro_forth_dsp_pop 
2998				endm 
# End of macro FORTH_DSP_POP
2998			 
2998			;		pop hl 
2998			if FORTH_ENABLE_MALLOCFREE 
2998 cd ae 12				call free 
299b			endif 
299b					NEXTW 
299b c3 53 20			jp macro_next 
299e				endm 
# End of macro NEXTW
299e			.LIST: 
299e				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
299e 5c				db WORD_SYS_CORE+72             
299f 8c 2b			dw .FORGET            
29a1 05				db 4 + 1 
29a2 .. 00			db "LIST",0              
29a7				endm 
# End of macro CWHEAD
29a7			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
29a7			; | | The quoted word must be in upper case. 
29a7				if DEBUG_FORTH_WORDS_KEY 
29a7					DMARK "LST" 
29a7 f5				push af  
29a8 3a bc 29			ld a, (.dmark)  
29ab 32 77 fb			ld (debug_mark),a  
29ae 3a bd 29			ld a, (.dmark+1)  
29b1 32 78 fb			ld (debug_mark+1),a  
29b4 3a be 29			ld a, (.dmark+2)  
29b7 32 79 fb			ld (debug_mark+2),a  
29ba 18 03			jr .pastdmark  
29bc ..			.dmark: db "LST"  
29bf f1			.pastdmark: pop af  
29c0			endm  
# End of macro DMARK
29c0					CALLMONITOR 
29c0 cd 5a 17			call break_point_state  
29c3				endm  
# End of macro CALLMONITOR
29c3				endif 
29c3			 
29c3					FORTH_DSP_VALUEHL 
29c3 cd e1 1e			call macro_dsp_valuehl 
29c6				endm 
# End of macro FORTH_DSP_VALUEHL
29c6			 
29c6 e5					push hl 
29c7					FORTH_DSP_POP 
29c7 cd 99 1f			call macro_forth_dsp_pop 
29ca				endm 
# End of macro FORTH_DSP_POP
29ca c1					pop bc 
29cb			 
29cb			; Start format of scratch string 
29cb			 
29cb 21 1d ee				ld hl, scratch 
29ce			 
29ce 3e 3a				ld a, ':' 
29d0 77					ld (hl),a 
29d1 23					inc hl 
29d2 3e 20				ld a, ' ' 
29d4 77					ld (hl), a 
29d5			 
29d5					; Get ptr to the word we need to look up 
29d5			 
29d5			;		FORTH_DSP_VALUEHL 
29d5					;v5 FORTH_DSP_VALUE 
29d5				; TODO type check 
29d5			;		inc hl    ; Skip type check  
29d5			;		push hl 
29d5			;		ex de, hl    ; put into DE 
29d5			 
29d5			 
29d5 21 00 80				ld hl, baseram 
29d8					;ld hl, baseusermem 
29d8			 
29d8 e5			push hl   ; sacreifical push 
29d9			 
29d9			.ldouscanm: 
29d9 e1				pop hl 
29da			.ldouscan: 
29da				if DEBUG_FORTH_WORDS 
29da					DMARK "LSs" 
29da f5				push af  
29db 3a ef 29			ld a, (.dmark)  
29de 32 77 fb			ld (debug_mark),a  
29e1 3a f0 29			ld a, (.dmark+1)  
29e4 32 78 fb			ld (debug_mark+1),a  
29e7 3a f1 29			ld a, (.dmark+2)  
29ea 32 79 fb			ld (debug_mark+2),a  
29ed 18 03			jr .pastdmark  
29ef ..			.dmark: db "LSs"  
29f2 f1			.pastdmark: pop af  
29f3			endm  
# End of macro DMARK
29f3					CALLMONITOR 
29f3 cd 5a 17			call break_point_state  
29f6				endm  
# End of macro CALLMONITOR
29f6				endif 
29f6				; skip dict stub 
29f6 cd a4 21				call forth_tok_next 
29f9			 
29f9			 
29f9			; while we have words to look for 
29f9			 
29f9 7e				ld a, (hl)      
29fa				if DEBUG_FORTH_WORDS 
29fa					DMARK "LSk" 
29fa f5				push af  
29fb 3a 0f 2a			ld a, (.dmark)  
29fe 32 77 fb			ld (debug_mark),a  
2a01 3a 10 2a			ld a, (.dmark+1)  
2a04 32 78 fb			ld (debug_mark+1),a  
2a07 3a 11 2a			ld a, (.dmark+2)  
2a0a 32 79 fb			ld (debug_mark+2),a  
2a0d 18 03			jr .pastdmark  
2a0f ..			.dmark: db "LSk"  
2a12 f1			.pastdmark: pop af  
2a13			endm  
# End of macro DMARK
2a13					CALLMONITOR 
2a13 cd 5a 17			call break_point_state  
2a16				endm  
# End of macro CALLMONITOR
2a16				endif 
2a16					;cp WORD_SYS_END 
2a16					;jp z, .lunotfound 
2a16			 
2a16					; if we hit non uwords then gone too far 
2a16 fe 01				cp WORD_SYS_UWORD 
2a18 c2 48 2b				jp nz, .lunotfound 
2a1b			 
2a1b				if DEBUG_FORTH_WORDS 
2a1b					DMARK "LSu" 
2a1b f5				push af  
2a1c 3a 30 2a			ld a, (.dmark)  
2a1f 32 77 fb			ld (debug_mark),a  
2a22 3a 31 2a			ld a, (.dmark+1)  
2a25 32 78 fb			ld (debug_mark+1),a  
2a28 3a 32 2a			ld a, (.dmark+2)  
2a2b 32 79 fb			ld (debug_mark+2),a  
2a2e 18 03			jr .pastdmark  
2a30 ..			.dmark: db "LSu"  
2a33 f1			.pastdmark: pop af  
2a34			endm  
# End of macro DMARK
2a34					CALLMONITOR 
2a34 cd 5a 17			call break_point_state  
2a37				endm  
# End of macro CALLMONITOR
2a37				endif 
2a37			 
2a37					; found a uword but is it the one we want... 
2a37			 
2a37 c5					push bc     ; uword to find is on bc 
2a38 d1					pop de 
2a39			 
2a39 e5					push hl  ; to save the ptr 
2a3a			 
2a3a					; skip opcode 
2a3a 23					inc hl  
2a3b					; skip next ptr 
2a3b 23					inc hl  
2a3c 23					inc hl 
2a3d					; skip len 
2a3d 23					inc hl 
2a3e			 
2a3e				if DEBUG_FORTH_WORDS 
2a3e					DMARK "LSc" 
2a3e f5				push af  
2a3f 3a 53 2a			ld a, (.dmark)  
2a42 32 77 fb			ld (debug_mark),a  
2a45 3a 54 2a			ld a, (.dmark+1)  
2a48 32 78 fb			ld (debug_mark+1),a  
2a4b 3a 55 2a			ld a, (.dmark+2)  
2a4e 32 79 fb			ld (debug_mark+2),a  
2a51 18 03			jr .pastdmark  
2a53 ..			.dmark: db "LSc"  
2a56 f1			.pastdmark: pop af  
2a57			endm  
# End of macro DMARK
2a57					CALLMONITOR 
2a57 cd 5a 17			call break_point_state  
2a5a				endm  
# End of macro CALLMONITOR
2a5a				endif 
2a5a cd b3 11				call strcmp 
2a5d c2 d9 29				jp nz, .ldouscanm 
2a60				 
2a60			 
2a60			 
2a60					; we have a uword so push its name to the stack 
2a60			 
2a60			;	   	push hl  ; save so we can move to next dict block 
2a60 e1			pop hl 
2a61			 
2a61				if DEBUG_FORTH_WORDS 
2a61					DMARK "LSm" 
2a61 f5				push af  
2a62 3a 76 2a			ld a, (.dmark)  
2a65 32 77 fb			ld (debug_mark),a  
2a68 3a 77 2a			ld a, (.dmark+1)  
2a6b 32 78 fb			ld (debug_mark+1),a  
2a6e 3a 78 2a			ld a, (.dmark+2)  
2a71 32 79 fb			ld (debug_mark+2),a  
2a74 18 03			jr .pastdmark  
2a76 ..			.dmark: db "LSm"  
2a79 f1			.pastdmark: pop af  
2a7a			endm  
# End of macro DMARK
2a7a					CALLMONITOR 
2a7a cd 5a 17			call break_point_state  
2a7d				endm  
# End of macro CALLMONITOR
2a7d				endif 
2a7d			 
2a7d					; skip opcode 
2a7d 23					inc hl  
2a7e					; skip next ptr 
2a7e 23					inc hl  
2a7f 23					inc hl 
2a80					; skip len 
2a80 7e					ld a, (hl)   ; save length to add 
2a81				if DEBUG_FORTH_WORDS 
2a81					DMARK "LS2" 
2a81 f5				push af  
2a82 3a 96 2a			ld a, (.dmark)  
2a85 32 77 fb			ld (debug_mark),a  
2a88 3a 97 2a			ld a, (.dmark+1)  
2a8b 32 78 fb			ld (debug_mark+1),a  
2a8e 3a 98 2a			ld a, (.dmark+2)  
2a91 32 79 fb			ld (debug_mark+2),a  
2a94 18 03			jr .pastdmark  
2a96 ..			.dmark: db "LS2"  
2a99 f1			.pastdmark: pop af  
2a9a			endm  
# End of macro DMARK
2a9a					CALLMONITOR 
2a9a cd 5a 17			call break_point_state  
2a9d				endm  
# End of macro CALLMONITOR
2a9d				endif 
2a9d			 
2a9d					; save this location 
2a9d				 
2a9d e5					push hl 
2a9e			 
2a9e 23					inc hl 
2a9f 11 1f ee				ld de, scratch+2 
2aa2 4f					ld c, a 
2aa3 06 00				ld b, 0 
2aa5			 
2aa5				if DEBUG_FORTH_WORDS 
2aa5					DMARK "LSn" 
2aa5 f5				push af  
2aa6 3a ba 2a			ld a, (.dmark)  
2aa9 32 77 fb			ld (debug_mark),a  
2aac 3a bb 2a			ld a, (.dmark+1)  
2aaf 32 78 fb			ld (debug_mark+1),a  
2ab2 3a bc 2a			ld a, (.dmark+2)  
2ab5 32 79 fb			ld (debug_mark+2),a  
2ab8 18 03			jr .pastdmark  
2aba ..			.dmark: db "LSn"  
2abd f1			.pastdmark: pop af  
2abe			endm  
# End of macro DMARK
2abe					CALLMONITOR 
2abe cd 5a 17			call break_point_state  
2ac1				endm  
# End of macro CALLMONITOR
2ac1				endif 
2ac1			 
2ac1					; copy uword name to scratch 
2ac1			 
2ac1 ed b0				ldir 
2ac3			 
2ac3 1b					dec de 
2ac4 3e 20				ld a, ' '    ; change null to space 
2ac6 12					ld (de), a 
2ac7			 
2ac7 13					inc de 
2ac8			 
2ac8 d5					push de 
2ac9 c1					pop bc     ; move scratch pointer to end of word name and save it 
2aca			 
2aca e1					pop hl 
2acb 7e					ld a, (hl) 
2acc					;inc hl 
2acc					; skip word string 
2acc cd 1d 0d				call addatohl 
2acf			 
2acf 23					inc hl 
2ad0			 
2ad0				if DEBUG_FORTH_WORDS 
2ad0					DMARK "LS3" 
2ad0 f5				push af  
2ad1 3a e5 2a			ld a, (.dmark)  
2ad4 32 77 fb			ld (debug_mark),a  
2ad7 3a e6 2a			ld a, (.dmark+1)  
2ada 32 78 fb			ld (debug_mark+1),a  
2add 3a e7 2a			ld a, (.dmark+2)  
2ae0 32 79 fb			ld (debug_mark+2),a  
2ae3 18 03			jr .pastdmark  
2ae5 ..			.dmark: db "LS3"  
2ae8 f1			.pastdmark: pop af  
2ae9			endm  
# End of macro DMARK
2ae9					CALLMONITOR 
2ae9 cd 5a 17			call break_point_state  
2aec				endm  
# End of macro CALLMONITOR
2aec				endif 
2aec					; should now be at the start of the machine code to setup the eval of the uword 
2aec					; now locate the ptr to the string defintion 
2aec			 
2aec					; skip ld hl, 
2aec					; then load the ptr 
2aec			; TODO use get from hl ptr 
2aec 23					inc hl 
2aed 5e					ld e, (hl) 
2aee 23					inc hl 
2aef 56					ld d, (hl) 
2af0 eb					ex de, hl 
2af1			 
2af1			 
2af1				if DEBUG_FORTH_WORDS 
2af1					DMARK "LSt" 
2af1 f5				push af  
2af2 3a 06 2b			ld a, (.dmark)  
2af5 32 77 fb			ld (debug_mark),a  
2af8 3a 07 2b			ld a, (.dmark+1)  
2afb 32 78 fb			ld (debug_mark+1),a  
2afe 3a 08 2b			ld a, (.dmark+2)  
2b01 32 79 fb			ld (debug_mark+2),a  
2b04 18 03			jr .pastdmark  
2b06 ..			.dmark: db "LSt"  
2b09 f1			.pastdmark: pop af  
2b0a			endm  
# End of macro DMARK
2b0a					CALLMONITOR 
2b0a cd 5a 17			call break_point_state  
2b0d				endm  
# End of macro CALLMONITOR
2b0d				endif 
2b0d			 
2b0d			; cant push right now due to tokenised strings  
2b0d			 
2b0d			; get the destination of where to copy this definition to. 
2b0d			 
2b0d c5					push bc 
2b0e d1					pop de 
2b0f			 
2b0f 7e			.listl:         ld a,(hl) 
2b10 fe 00				cp 0 
2b12 28 09				jr z, .lreplsp     ; replace zero with space 
2b14					;cp FORTH_END_BUFFER 
2b14 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2b16 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2b18				 
2b18					; just copy this char as is then 
2b18			 
2b18 12					ld (de), a 
2b19			 
2b19 23			.listnxt:	inc hl 
2b1a 13					inc de 
2b1b 18 f2				jr .listl 
2b1d			 
2b1d 3e 20		.lreplsp:	ld a,' ' 
2b1f 12					ld (de), a 
2b20 18 f7				jr .listnxt 
2b22			 
2b22			; close up uword def 
2b22			 
2b22			.listdone: 
2b22 12					ld (de), a 
2b23 13					inc de 
2b24 3e 00				ld a, 0 
2b26 12					ld (de), a 
2b27			 
2b27			; now have def so clean up and push to stack 
2b27			 
2b27 21 1d ee				ld hl, scratch 
2b2a				if DEBUG_FORTH_WORDS 
2b2a					DMARK "Ltp" 
2b2a f5				push af  
2b2b 3a 3f 2b			ld a, (.dmark)  
2b2e 32 77 fb			ld (debug_mark),a  
2b31 3a 40 2b			ld a, (.dmark+1)  
2b34 32 78 fb			ld (debug_mark+1),a  
2b37 3a 41 2b			ld a, (.dmark+2)  
2b3a 32 79 fb			ld (debug_mark+2),a  
2b3d 18 03			jr .pastdmark  
2b3f ..			.dmark: db "Ltp"  
2b42 f1			.pastdmark: pop af  
2b43			endm  
# End of macro DMARK
2b43					CALLMONITOR 
2b43 cd 5a 17			call break_point_state  
2b46				endm  
# End of macro CALLMONITOR
2b46				endif 
2b46			 
2b46 18 1f			jr .listpush 
2b48			 
2b48			;.lnuword:	pop hl 
2b48			;		call forth_tok_next 
2b48			;		jp .ldouscan  
2b48			 
2b48			.lunotfound:		  
2b48			 
2b48				if DEBUG_FORTH_WORDS 
2b48					DMARK "LSn" 
2b48 f5				push af  
2b49 3a 5d 2b			ld a, (.dmark)  
2b4c 32 77 fb			ld (debug_mark),a  
2b4f 3a 5e 2b			ld a, (.dmark+1)  
2b52 32 78 fb			ld (debug_mark+1),a  
2b55 3a 5f 2b			ld a, (.dmark+2)  
2b58 32 79 fb			ld (debug_mark+2),a  
2b5b 18 03			jr .pastdmark  
2b5d ..			.dmark: db "LSn"  
2b60 f1			.pastdmark: pop af  
2b61			endm  
# End of macro DMARK
2b61					CALLMONITOR 
2b61 cd 5a 17			call break_point_state  
2b64				endm  
# End of macro CALLMONITOR
2b64				endif 
2b64			 
2b64					 
2b64			;		FORTH_DSP_POP 
2b64			;		ld hl, .luno 
2b64			 
2b64					NEXTW			 
2b64 c3 53 20			jp macro_next 
2b67				endm 
# End of macro NEXTW
2b67			 
2b67			.listpush: 
2b67				if DEBUG_FORTH_WORDS 
2b67					DMARK "LS>" 
2b67 f5				push af  
2b68 3a 7c 2b			ld a, (.dmark)  
2b6b 32 77 fb			ld (debug_mark),a  
2b6e 3a 7d 2b			ld a, (.dmark+1)  
2b71 32 78 fb			ld (debug_mark+1),a  
2b74 3a 7e 2b			ld a, (.dmark+2)  
2b77 32 79 fb			ld (debug_mark+2),a  
2b7a 18 03			jr .pastdmark  
2b7c ..			.dmark: db "LS>"  
2b7f f1			.pastdmark: pop af  
2b80			endm  
# End of macro DMARK
2b80					CALLMONITOR 
2b80 cd 5a 17			call break_point_state  
2b83				endm  
# End of macro CALLMONITOR
2b83				endif 
2b83 cd 58 1d				call forth_push_str 
2b86			 
2b86			 
2b86			 
2b86					NEXTW 
2b86 c3 53 20			jp macro_next 
2b89				endm 
# End of macro NEXTW
2b89			 
2b89			;.luno:    db "Word not found",0 
2b89			 
2b89			 
2b89			 
2b89			 
2b89			 
2b89			;		push hl   ; save pointer to start of uword def string 
2b89			; 
2b89			;; look for FORTH_EOL_LINE 
2b89			;		ld a, FORTH_END_BUFFER 
2b89			;		call strlent 
2b89			; 
2b89			;		inc hl		 ; space for coln def 
2b89			;		inc hl 
2b89			;		inc hl          ; space for terms 
2b89			;		inc hl 
2b89			; 
2b89			;		ld a, 20   ; TODO get actual length 
2b89			;		call addatohl    ; include a random amount of room for the uword name 
2b89			; 
2b89			;		 
2b89			;	if DEBUG_FORTH_WORDS 
2b89			;		DMARK "Lt1" 
2b89			;		CALLMONITOR 
2b89			;	endif 
2b89			;		 
2b89			; 
2b89			;; malloc space for the string because we cant change it 
2b89			; 
2b89			;		call malloc 
2b89			;	if DEBUG_FORTH_MALLOC_GUARD 
2b89			;		push af 
2b89			;		call ishlzero 
2b89			;		pop af 
2b89			;		 
2b89			;		call z,malloc_error 
2b89			;	endif 
2b89			; 
2b89			;	if DEBUG_FORTH_WORDS 
2b89			;		DMARK "Lt2" 
2b89			;		CALLMONITOR 
2b89			;	endif 
2b89			;		pop de 
2b89			;		push hl    ; push the malloc to release later 
2b89			;		push hl   ;  push back a copy for the later stack push 
2b89			;		 
2b89			;; copy the string swapping out the zero terms for spaces 
2b89			; 
2b89			;		; de has our source 
2b89			;		; hl has our dest 
2b89			; 
2b89			;; add the coln def 
2b89			; 
2b89			;		ld a, ':' 
2b89			;		ld (hl), a 
2b89			;		inc hl 
2b89			;		ld a, ' ' 
2b89			;		ld (hl), a 
2b89			;		inc hl 
2b89			; 
2b89			;; add the uname word 
2b89			;		push de   ; save our string for now 
2b89			;		ex de, hl 
2b89			; 
2b89			;		FORTH_DSP_VALUE 
2b89			;		;v5 FORTH_DSP_VALUE 
2b89			; 
2b89			;		inc hl   ; skip type but we know by now this is OK 
2b89			; 
2b89			;.luword:	ld a,(hl) 
2b89			;		cp 0 
2b89			;		jr z, .luword2 
2b89			;		ld (de), a 
2b89			;		inc de 
2b89			;		inc hl 
2b89			;		jr .luword 
2b89			; 
2b89			;.luword2:	ld a, ' ' 
2b89			;		ld (de), a 
2b89			;;		inc hl 
2b89			;;		inc de 
2b89			;;		ld (de), a 
2b89			;;		inc hl 
2b89			;		inc de 
2b89			; 
2b89			;		ex de, hl 
2b89			;		pop de 
2b89			;		 
2b89			;		 
2b89			; 
2b89			;; detoken that string and copy it 
2b89			; 
2b89			;	if DEBUG_FORTH_WORDS 
2b89			;		DMARK "Lt2" 
2b89			;		CALLMONITOR 
2b89			;	endif 
2b89			;.ldetok:	ld a, (de) 
2b89			;		cp FORTH_END_BUFFER 
2b89			;		jr z, .ldetokend 
2b89			;		; swap out any zero term for space 
2b89			;		cp 0 
2b89			;		jr nz, .ldetoknext 
2b89			;		ld a, ' ' 
2b89			; 
2b89			;	if DEBUG_FORTH_WORDS 
2b89			;		DMARK "LtS" 
2b89			;		CALLMONITOR 
2b89			;	endif 
2b89			;.ldetoknext:	ld (hl), a 
2b89			;		inc de 
2b89			;		inc hl 
2b89			;		jr .ldetok 
2b89			; 
2b89			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2b89			;		ld (hl), a  
2b89			; 
2b89			;; free that temp malloc 
2b89			; 
2b89			;		pop hl    
2b89			; 
2b89			;	if DEBUG_FORTH_WORDS 
2b89			;		DMARK "Lt4" 
2b89			;		CALLMONITOR 
2b89			;	endif 
2b89			;		call forth_apushstrhl 
2b89			; 
2b89			;		; get rid of temp malloc area 
2b89			; 
2b89			;		pop hl 
2b89			;		call free 
2b89			; 
2b89			;		jr .ludone 
2b89			; 
2b89			;.lnuword:	pop hl 
2b89			;		call forth_tok_next 
2b89			;		jp .ldouscan  
2b89			; 
2b89			;.ludone:		 pop hl 
2b89			; 
2b89					NEXTW 
2b89 c3 53 20			jp macro_next 
2b8c				endm 
# End of macro NEXTW
2b8c			 
2b8c			.FORGET: 
2b8c				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2b8c 5d				db WORD_SYS_CORE+73             
2b8d 05 2c			dw .NOP            
2b8f 07				db 6 + 1 
2b90 .. 00			db "FORGET",0              
2b97				endm 
# End of macro CWHEAD
2b97			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2b97			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2b97			; | |  
2b97			; | | e.g. "MORE" forget 
2b97					if DEBUG_FORTH_WORDS_KEY 
2b97						DMARK "FRG" 
2b97 f5				push af  
2b98 3a ac 2b			ld a, (.dmark)  
2b9b 32 77 fb			ld (debug_mark),a  
2b9e 3a ad 2b			ld a, (.dmark+1)  
2ba1 32 78 fb			ld (debug_mark+1),a  
2ba4 3a ae 2b			ld a, (.dmark+2)  
2ba7 32 79 fb			ld (debug_mark+2),a  
2baa 18 03			jr .pastdmark  
2bac ..			.dmark: db "FRG"  
2baf f1			.pastdmark: pop af  
2bb0			endm  
# End of macro DMARK
2bb0						CALLMONITOR 
2bb0 cd 5a 17			call break_point_state  
2bb3				endm  
# End of macro CALLMONITOR
2bb3					endif 
2bb3			 
2bb3				; find uword 
2bb3			        ; update start of word with "_" 
2bb3				; replace uword with deleted flag 
2bb3			 
2bb3			 
2bb3			;	if DEBUG_FORTH_WORDS 
2bb3			;		DMARK "FOG" 
2bb3			;		CALLMONITOR 
2bb3			;	endif 
2bb3			 
2bb3			 
2bb3					; Get ptr to the word we need to look up 
2bb3			 
2bb3					FORTH_DSP_VALUEHL 
2bb3 cd e1 1e			call macro_dsp_valuehl 
2bb6				endm 
# End of macro FORTH_DSP_VALUEHL
2bb6					;v5 FORTH_DSP_VALUE 
2bb6				; TODO type check 
2bb6			;		inc hl    ; Skip type check  
2bb6 e5					push hl 
2bb7 c1					pop bc 
2bb8			;		ex de, hl    ; put into DE 
2bb8			 
2bb8			 
2bb8 21 00 80				ld hl, baseram 
2bbb					;ld hl, baseusermem 
2bbb			 
2bbb				; skip dict stub 
2bbb			;	call forth_tok_next 
2bbb e5			push hl   ; sacreifical push 
2bbc			 
2bbc			.fldouscanm: 
2bbc e1				pop hl 
2bbd			.fldouscan: 
2bbd			;	if DEBUG_FORTH_WORDS 
2bbd			;		DMARK "LSs" 
2bbd			;		CALLMONITOR 
2bbd			;	endif 
2bbd				; skip dict stub 
2bbd cd a4 21				call forth_tok_next 
2bc0			 
2bc0			 
2bc0			; while we have words to look for 
2bc0			 
2bc0 7e				ld a, (hl)      
2bc1			;	if DEBUG_FORTH_WORDS 
2bc1			;		DMARK "LSk" 
2bc1			;		CALLMONITOR 
2bc1			;	endif 
2bc1 fe 00				cp WORD_SYS_END 
2bc3 ca ff 2b				jp z, .flunotfound 
2bc6 fe 01				cp WORD_SYS_UWORD 
2bc8 c2 bd 2b				jp nz, .fldouscan 
2bcb			 
2bcb			;	if DEBUG_FORTH_WORDS 
2bcb			;		DMARK "LSu" 
2bcb			;		CALLMONITOR 
2bcb			;	endif 
2bcb			 
2bcb					; found a uword but is it the one we want... 
2bcb			 
2bcb c5					push bc     ; uword to find is on bc 
2bcc d1					pop de 
2bcd			 
2bcd e5					push hl  ; to save the ptr 
2bce			 
2bce					; skip opcode 
2bce 23					inc hl  
2bcf					; skip next ptr 
2bcf 23					inc hl  
2bd0 23					inc hl 
2bd1					; skip len 
2bd1 23					inc hl 
2bd2			 
2bd2			;	if DEBUG_FORTH_WORDS 
2bd2			;		DMARK "LSc" 
2bd2			;		CALLMONITOR 
2bd2			;	endif 
2bd2 cd b3 11				call strcmp 
2bd5 c2 bc 2b				jp nz, .fldouscanm 
2bd8			; 
2bd8			; 
2bd8			;; while we have words to look for 
2bd8			; 
2bd8			;.fdouscan:	ld a, (hl)      
2bd8			;	if DEBUG_FORTH_WORDS 
2bd8			;		DMARK "LSs" 
2bd8			;		CALLMONITOR 
2bd8			;	endif 
2bd8			;		cp WORD_SYS_END 
2bd8			;		jp z, .fudone 
2bd8			;		cp WORD_SYS_UWORD 
2bd8			;		jp nz, .fnuword 
2bd8			; 
2bd8			;	if DEBUG_FORTH_WORDS 
2bd8			;		DMARK "FGu" 
2bd8			;		CALLMONITOR 
2bd8			;	endif 
2bd8			; 
2bd8			;		; found a uword but is it the one we want... 
2bd8			; 
2bd8			; 
2bd8			;	        pop de   ; get back the dsp name 
2bd8			;		push de 
2bd8			; 
2bd8			;		push hl  ; to save the ptr 
2bd8			; 
2bd8			;		; skip opcode 
2bd8			;		inc hl  
2bd8			;		; skip next ptr 
2bd8			;		inc hl  
2bd8			;		inc hl 
2bd8			;		; skip len 
2bd8			;		inc hl 
2bd8			; 
2bd8			;	if DEBUG_FORTH_WORDS 
2bd8			;		DMARK "FGc" 
2bd8			;		CALLMONITOR 
2bd8			;	endif 
2bd8			;		call strcmp 
2bd8			;		jp nz, .fnuword 
2bd8			 
2bd8			 
2bd8 e1			pop hl 
2bd9			 
2bd9				 
2bd9				if DEBUG_FORTH_WORDS 
2bd9					DMARK "FGm" 
2bd9 f5				push af  
2bda 3a ee 2b			ld a, (.dmark)  
2bdd 32 77 fb			ld (debug_mark),a  
2be0 3a ef 2b			ld a, (.dmark+1)  
2be3 32 78 fb			ld (debug_mark+1),a  
2be6 3a f0 2b			ld a, (.dmark+2)  
2be9 32 79 fb			ld (debug_mark+2),a  
2bec 18 03			jr .pastdmark  
2bee ..			.dmark: db "FGm"  
2bf1 f1			.pastdmark: pop af  
2bf2			endm  
# End of macro DMARK
2bf2					CALLMONITOR 
2bf2 cd 5a 17			call break_point_state  
2bf5				endm  
# End of macro CALLMONITOR
2bf5				endif 
2bf5			 
2bf5			 
2bf5			 
2bf5					; we have a uword so push its name to the stack 
2bf5			 
2bf5			;	   	push hl  ; save so we can move to next dict block 
2bf5			;pop hl 
2bf5			 
2bf5					; update opcode to deleted 
2bf5 3e 03				ld a, WORD_SYS_DELETED 
2bf7 77					ld (hl), a 
2bf8			 
2bf8 23					inc hl  
2bf9					; skip next ptr 
2bf9 23					inc hl  
2bfa 23					inc hl 
2bfb					; skip len 
2bfb 23					inc hl 
2bfc			 
2bfc					; TODO change parser to skip deleted words but for now mark it out 
2bfc 3e 5f				ld a, "_" 
2bfe 77					ld  (hl),a 
2bff			 
2bff			;		jr .fudone 
2bff			; 
2bff			;.fnuword:	pop hl 
2bff			;		call forth_tok_next 
2bff			;		jp .fdouscan  
2bff			 
2bff			.flunotfound:		  
2bff			 
2bff			 
2bff					 
2bff					FORTH_DSP_POP 
2bff cd 99 1f			call macro_forth_dsp_pop 
2c02				endm 
# End of macro FORTH_DSP_POP
2c02			;		ld hl, .luno 
2c02			;.fudone:		 pop hl 
2c02					NEXTW 
2c02 c3 53 20			jp macro_next 
2c05				endm 
# End of macro NEXTW
2c05			.NOP: 
2c05				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2c05 61				db WORD_SYS_CORE+77             
2c06 2c 2c			dw .COMO            
2c08 04				db 3 + 1 
2c09 .. 00			db "NOP",0              
2c0d				endm 
# End of macro CWHEAD
2c0d			; | NOP (  --  ) Do nothing | DONE 
2c0d					if DEBUG_FORTH_WORDS_KEY 
2c0d						DMARK "NOP" 
2c0d f5				push af  
2c0e 3a 22 2c			ld a, (.dmark)  
2c11 32 77 fb			ld (debug_mark),a  
2c14 3a 23 2c			ld a, (.dmark+1)  
2c17 32 78 fb			ld (debug_mark+1),a  
2c1a 3a 24 2c			ld a, (.dmark+2)  
2c1d 32 79 fb			ld (debug_mark+2),a  
2c20 18 03			jr .pastdmark  
2c22 ..			.dmark: db "NOP"  
2c25 f1			.pastdmark: pop af  
2c26			endm  
# End of macro DMARK
2c26						CALLMONITOR 
2c26 cd 5a 17			call break_point_state  
2c29				endm  
# End of macro CALLMONITOR
2c29					endif 
2c29				       NEXTW 
2c29 c3 53 20			jp macro_next 
2c2c				endm 
# End of macro NEXTW
2c2c			.COMO: 
2c2c				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2c2c 6e				db WORD_SYS_CORE+90             
2c2d 7e 2c			dw .COMC            
2c2f 02				db 1 + 1 
2c30 .. 00			db "(",0              
2c32				endm 
# End of macro CWHEAD
2c32			; | ( ( -- )  Start of comment | DONE 
2c32			 
2c32			 
2c32 2a 1e f1				ld hl, ( os_tok_ptr) 
2c35 11 79 2c			ld de, .closepar 
2c38					 
2c38					if DEBUG_FORTH_WORDS 
2c38						DMARK ").." 
2c38 f5				push af  
2c39 3a 4d 2c			ld a, (.dmark)  
2c3c 32 77 fb			ld (debug_mark),a  
2c3f 3a 4e 2c			ld a, (.dmark+1)  
2c42 32 78 fb			ld (debug_mark+1),a  
2c45 3a 4f 2c			ld a, (.dmark+2)  
2c48 32 79 fb			ld (debug_mark+2),a  
2c4b 18 03			jr .pastdmark  
2c4d ..			.dmark: db ").."  
2c50 f1			.pastdmark: pop af  
2c51			endm  
# End of macro DMARK
2c51						CALLMONITOR 
2c51 cd 5a 17			call break_point_state  
2c54				endm  
# End of macro CALLMONITOR
2c54					endif 
2c54 cd 6e 21			call findnexttok  
2c57			 
2c57					if DEBUG_FORTH_WORDS 
2c57						DMARK "IF5" 
2c57 f5				push af  
2c58 3a 6c 2c			ld a, (.dmark)  
2c5b 32 77 fb			ld (debug_mark),a  
2c5e 3a 6d 2c			ld a, (.dmark+1)  
2c61 32 78 fb			ld (debug_mark+1),a  
2c64 3a 6e 2c			ld a, (.dmark+2)  
2c67 32 79 fb			ld (debug_mark+2),a  
2c6a 18 03			jr .pastdmark  
2c6c ..			.dmark: db "IF5"  
2c6f f1			.pastdmark: pop af  
2c70			endm  
# End of macro DMARK
2c70						CALLMONITOR 
2c70 cd 5a 17			call break_point_state  
2c73				endm  
# End of macro CALLMONITOR
2c73					endif 
2c73				; replace below with ) exec using tok_ptr 
2c73 22 1e f1			ld (os_tok_ptr), hl 
2c76 c3 e4 20			jp exec1 
2c79			 
2c79 .. 00			.closepar:   db ")",0 
2c7b			 
2c7b				       NEXTW 
2c7b c3 53 20			jp macro_next 
2c7e				endm 
# End of macro NEXTW
2c7e			.COMC: 
2c7e				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2c7e 6f				db WORD_SYS_CORE+91             
2c7f 87 2c			dw .SCRATCH            
2c81 02				db 1 + 1 
2c82 .. 00			db ")",0              
2c84				endm 
# End of macro CWHEAD
2c84			; | ) ( -- )  End of comment |  DONE  
2c84				       NEXTW 
2c84 c3 53 20			jp macro_next 
2c87				endm 
# End of macro NEXTW
2c87			 
2c87			.SCRATCH: 
2c87				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2c87 6f				db WORD_SYS_CORE+91             
2c88 c2 2c			dw .INC            
2c8a 08				db 7 + 1 
2c8b .. 00			db "SCRATCH",0              
2c93				endm 
# End of macro CWHEAD
2c93			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2c93			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2c93			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2c93			; | |  
2c93			; | | e.g.    : score $00 scratch ; 
2c93			; | |  
2c93			; | | $00 score ! 
2c93			; | | $01 score +! 
2c93			; | |  
2c93			; | | e.g.   : varword $0a scratch ;  
2c93			; | | 
2c93			; | | $8000 varword ! 
2c93					if DEBUG_FORTH_WORDS_KEY 
2c93						DMARK "SCR" 
2c93 f5				push af  
2c94 3a a8 2c			ld a, (.dmark)  
2c97 32 77 fb			ld (debug_mark),a  
2c9a 3a a9 2c			ld a, (.dmark+1)  
2c9d 32 78 fb			ld (debug_mark+1),a  
2ca0 3a aa 2c			ld a, (.dmark+2)  
2ca3 32 79 fb			ld (debug_mark+2),a  
2ca6 18 03			jr .pastdmark  
2ca8 ..			.dmark: db "SCR"  
2cab f1			.pastdmark: pop af  
2cac			endm  
# End of macro DMARK
2cac						CALLMONITOR 
2cac cd 5a 17			call break_point_state  
2caf				endm  
# End of macro CALLMONITOR
2caf					endif 
2caf			 
2caf					FORTH_DSP_VALUEHL 
2caf cd e1 1e			call macro_dsp_valuehl 
2cb2				endm 
# End of macro FORTH_DSP_VALUEHL
2cb2				 
2cb2					FORTH_DSP_POP 
2cb2 cd 99 1f			call macro_forth_dsp_pop 
2cb5				endm 
# End of macro FORTH_DSP_POP
2cb5			 
2cb5 7d					ld a, l 
2cb6 21 42 f3				ld hl, os_var_array 
2cb9 cd 1d 0d				call addatohl 
2cbc			 
2cbc cd ea 1c				call forth_push_numhl 
2cbf			 
2cbf				       NEXTW 
2cbf c3 53 20			jp macro_next 
2cc2				endm 
# End of macro NEXTW
2cc2			 
2cc2			.INC: 
2cc2				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2cc2 6f				db WORD_SYS_CORE+91             
2cc3 16 2d			dw .DEC            
2cc5 03				db 2 + 1 
2cc6 .. 00			db "+!",0              
2cc9				endm 
# End of macro CWHEAD
2cc9			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2cc9					if DEBUG_FORTH_WORDS_KEY 
2cc9						DMARK "+s_" 
2cc9 f5				push af  
2cca 3a de 2c			ld a, (.dmark)  
2ccd 32 77 fb			ld (debug_mark),a  
2cd0 3a df 2c			ld a, (.dmark+1)  
2cd3 32 78 fb			ld (debug_mark+1),a  
2cd6 3a e0 2c			ld a, (.dmark+2)  
2cd9 32 79 fb			ld (debug_mark+2),a  
2cdc 18 03			jr .pastdmark  
2cde ..			.dmark: db "+s_"  
2ce1 f1			.pastdmark: pop af  
2ce2			endm  
# End of macro DMARK
2ce2						CALLMONITOR 
2ce2 cd 5a 17			call break_point_state  
2ce5				endm  
# End of macro CALLMONITOR
2ce5					endif 
2ce5			 
2ce5					FORTH_DSP_VALUEHL 
2ce5 cd e1 1e			call macro_dsp_valuehl 
2ce8				endm 
# End of macro FORTH_DSP_VALUEHL
2ce8			 
2ce8 e5					push hl   ; save address 
2ce9			 
2ce9					FORTH_DSP_POP 
2ce9 cd 99 1f			call macro_forth_dsp_pop 
2cec				endm 
# End of macro FORTH_DSP_POP
2cec			 
2cec					FORTH_DSP_VALUEHL 
2cec cd e1 1e			call macro_dsp_valuehl 
2cef				endm 
# End of macro FORTH_DSP_VALUEHL
2cef			 
2cef					FORTH_DSP_POP 
2cef cd 99 1f			call macro_forth_dsp_pop 
2cf2				endm 
# End of macro FORTH_DSP_POP
2cf2			 
2cf2					; hl contains value to add to byte at a 
2cf2				 
2cf2 eb					ex de, hl 
2cf3			 
2cf3 e1					pop hl 
2cf4			 
2cf4					if DEBUG_FORTH_WORDS 
2cf4						DMARK "INC" 
2cf4 f5				push af  
2cf5 3a 09 2d			ld a, (.dmark)  
2cf8 32 77 fb			ld (debug_mark),a  
2cfb 3a 0a 2d			ld a, (.dmark+1)  
2cfe 32 78 fb			ld (debug_mark+1),a  
2d01 3a 0b 2d			ld a, (.dmark+2)  
2d04 32 79 fb			ld (debug_mark+2),a  
2d07 18 03			jr .pastdmark  
2d09 ..			.dmark: db "INC"  
2d0c f1			.pastdmark: pop af  
2d0d			endm  
# End of macro DMARK
2d0d						CALLMONITOR 
2d0d cd 5a 17			call break_point_state  
2d10				endm  
# End of macro CALLMONITOR
2d10					endif 
2d10			 
2d10 7e					ld a,(hl) 
2d11 83					add e 
2d12 77					ld (hl),a 
2d13			 
2d13			 
2d13			 
2d13				       NEXTW 
2d13 c3 53 20			jp macro_next 
2d16				endm 
# End of macro NEXTW
2d16			 
2d16			.DEC: 
2d16				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2d16 6f				db WORD_SYS_CORE+91             
2d17 67 2d			dw .INC2            
2d19 03				db 2 + 1 
2d1a .. 00			db "-!",0              
2d1d				endm 
# End of macro CWHEAD
2d1d			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2d1d					if DEBUG_FORTH_WORDS_KEY 
2d1d						DMARK "-s_" 
2d1d f5				push af  
2d1e 3a 32 2d			ld a, (.dmark)  
2d21 32 77 fb			ld (debug_mark),a  
2d24 3a 33 2d			ld a, (.dmark+1)  
2d27 32 78 fb			ld (debug_mark+1),a  
2d2a 3a 34 2d			ld a, (.dmark+2)  
2d2d 32 79 fb			ld (debug_mark+2),a  
2d30 18 03			jr .pastdmark  
2d32 ..			.dmark: db "-s_"  
2d35 f1			.pastdmark: pop af  
2d36			endm  
# End of macro DMARK
2d36						CALLMONITOR 
2d36 cd 5a 17			call break_point_state  
2d39				endm  
# End of macro CALLMONITOR
2d39					endif 
2d39			 
2d39					FORTH_DSP_VALUEHL 
2d39 cd e1 1e			call macro_dsp_valuehl 
2d3c				endm 
# End of macro FORTH_DSP_VALUEHL
2d3c			 
2d3c e5					push hl   ; save address 
2d3d			 
2d3d					FORTH_DSP_POP 
2d3d cd 99 1f			call macro_forth_dsp_pop 
2d40				endm 
# End of macro FORTH_DSP_POP
2d40			 
2d40					FORTH_DSP_VALUEHL 
2d40 cd e1 1e			call macro_dsp_valuehl 
2d43				endm 
# End of macro FORTH_DSP_VALUEHL
2d43			 
2d43					; hl contains value to add to byte at a 
2d43				 
2d43 eb					ex de, hl 
2d44			 
2d44 e1					pop hl 
2d45			 
2d45					if DEBUG_FORTH_WORDS 
2d45						DMARK "DEC" 
2d45 f5				push af  
2d46 3a 5a 2d			ld a, (.dmark)  
2d49 32 77 fb			ld (debug_mark),a  
2d4c 3a 5b 2d			ld a, (.dmark+1)  
2d4f 32 78 fb			ld (debug_mark+1),a  
2d52 3a 5c 2d			ld a, (.dmark+2)  
2d55 32 79 fb			ld (debug_mark+2),a  
2d58 18 03			jr .pastdmark  
2d5a ..			.dmark: db "DEC"  
2d5d f1			.pastdmark: pop af  
2d5e			endm  
# End of macro DMARK
2d5e						CALLMONITOR 
2d5e cd 5a 17			call break_point_state  
2d61				endm  
# End of macro CALLMONITOR
2d61					endif 
2d61			 
2d61 7e					ld a,(hl) 
2d62 93					sub e 
2d63 77					ld (hl),a 
2d64			 
2d64			 
2d64			 
2d64				       NEXTW 
2d64 c3 53 20			jp macro_next 
2d67				endm 
# End of macro NEXTW
2d67			 
2d67			.INC2: 
2d67				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2d67 6f				db WORD_SYS_CORE+91             
2d68 11 2e			dw .DEC2            
2d6a 04				db 3 + 1 
2d6b .. 00			db "+2!",0              
2d6f				endm 
# End of macro CWHEAD
2d6f			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2d6f			 
2d6f					if DEBUG_FORTH_WORDS_KEY 
2d6f						DMARK "+2s" 
2d6f f5				push af  
2d70 3a 84 2d			ld a, (.dmark)  
2d73 32 77 fb			ld (debug_mark),a  
2d76 3a 85 2d			ld a, (.dmark+1)  
2d79 32 78 fb			ld (debug_mark+1),a  
2d7c 3a 86 2d			ld a, (.dmark+2)  
2d7f 32 79 fb			ld (debug_mark+2),a  
2d82 18 03			jr .pastdmark  
2d84 ..			.dmark: db "+2s"  
2d87 f1			.pastdmark: pop af  
2d88			endm  
# End of macro DMARK
2d88						CALLMONITOR 
2d88 cd 5a 17			call break_point_state  
2d8b				endm  
# End of macro CALLMONITOR
2d8b					endif 
2d8b			 
2d8b					; Address 
2d8b			 
2d8b					FORTH_DSP_VALUEHL 
2d8b cd e1 1e			call macro_dsp_valuehl 
2d8e				endm 
# End of macro FORTH_DSP_VALUEHL
2d8e			 
2d8e e5					push hl    ; save address 
2d8f			 
2d8f					; load content into de 
2d8f			 
2d8f 5e					ld e,(hl) 
2d90 23					inc hl 
2d91 56					ld d, (hl) 
2d92			 
2d92					if DEBUG_FORTH_WORDS 
2d92						DMARK "+2a" 
2d92 f5				push af  
2d93 3a a7 2d			ld a, (.dmark)  
2d96 32 77 fb			ld (debug_mark),a  
2d99 3a a8 2d			ld a, (.dmark+1)  
2d9c 32 78 fb			ld (debug_mark+1),a  
2d9f 3a a9 2d			ld a, (.dmark+2)  
2da2 32 79 fb			ld (debug_mark+2),a  
2da5 18 03			jr .pastdmark  
2da7 ..			.dmark: db "+2a"  
2daa f1			.pastdmark: pop af  
2dab			endm  
# End of macro DMARK
2dab						CALLMONITOR 
2dab cd 5a 17			call break_point_state  
2dae				endm  
# End of macro CALLMONITOR
2dae					endif 
2dae			 
2dae					FORTH_DSP_POP 
2dae cd 99 1f			call macro_forth_dsp_pop 
2db1				endm 
# End of macro FORTH_DSP_POP
2db1			 
2db1					; Get value to add 
2db1			 
2db1					FORTH_DSP_VALUE 
2db1 cd ca 1e			call macro_forth_dsp_value 
2db4				endm 
# End of macro FORTH_DSP_VALUE
2db4			 
2db4					if DEBUG_FORTH_WORDS 
2db4						DMARK "+2v" 
2db4 f5				push af  
2db5 3a c9 2d			ld a, (.dmark)  
2db8 32 77 fb			ld (debug_mark),a  
2dbb 3a ca 2d			ld a, (.dmark+1)  
2dbe 32 78 fb			ld (debug_mark+1),a  
2dc1 3a cb 2d			ld a, (.dmark+2)  
2dc4 32 79 fb			ld (debug_mark+2),a  
2dc7 18 03			jr .pastdmark  
2dc9 ..			.dmark: db "+2v"  
2dcc f1			.pastdmark: pop af  
2dcd			endm  
# End of macro DMARK
2dcd						CALLMONITOR 
2dcd cd 5a 17			call break_point_state  
2dd0				endm  
# End of macro CALLMONITOR
2dd0					endif 
2dd0			 
2dd0 19					add hl, de 
2dd1			 
2dd1					if DEBUG_FORTH_WORDS 
2dd1						DMARK "+2+" 
2dd1 f5				push af  
2dd2 3a e6 2d			ld a, (.dmark)  
2dd5 32 77 fb			ld (debug_mark),a  
2dd8 3a e7 2d			ld a, (.dmark+1)  
2ddb 32 78 fb			ld (debug_mark+1),a  
2dde 3a e8 2d			ld a, (.dmark+2)  
2de1 32 79 fb			ld (debug_mark+2),a  
2de4 18 03			jr .pastdmark  
2de6 ..			.dmark: db "+2+"  
2de9 f1			.pastdmark: pop af  
2dea			endm  
# End of macro DMARK
2dea						CALLMONITOR 
2dea cd 5a 17			call break_point_state  
2ded				endm  
# End of macro CALLMONITOR
2ded					endif 
2ded			 
2ded					; move result to de 
2ded			 
2ded eb					ex de, hl 
2dee			 
2dee					; Address 
2dee			 
2dee e1					pop hl 
2def			 
2def					; save it back 
2def			 
2def 73					ld (hl), e 
2df0 23					inc hl 
2df1 72					ld (hl), d 
2df2			 
2df2					if DEBUG_FORTH_WORDS 
2df2						DMARK "+2e" 
2df2 f5				push af  
2df3 3a 07 2e			ld a, (.dmark)  
2df6 32 77 fb			ld (debug_mark),a  
2df9 3a 08 2e			ld a, (.dmark+1)  
2dfc 32 78 fb			ld (debug_mark+1),a  
2dff 3a 09 2e			ld a, (.dmark+2)  
2e02 32 79 fb			ld (debug_mark+2),a  
2e05 18 03			jr .pastdmark  
2e07 ..			.dmark: db "+2e"  
2e0a f1			.pastdmark: pop af  
2e0b			endm  
# End of macro DMARK
2e0b						CALLMONITOR 
2e0b cd 5a 17			call break_point_state  
2e0e				endm  
# End of macro CALLMONITOR
2e0e					endif 
2e0e			 
2e0e			 
2e0e			 
2e0e			 
2e0e			 
2e0e				       NEXTW 
2e0e c3 53 20			jp macro_next 
2e11				endm 
# End of macro NEXTW
2e11			 
2e11			.DEC2: 
2e11				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2e11 6f				db WORD_SYS_CORE+91             
2e12 bd 2e			dw .GET2            
2e14 04				db 3 + 1 
2e15 .. 00			db "-2!",0              
2e19				endm 
# End of macro CWHEAD
2e19			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2e19			 
2e19			 
2e19					if DEBUG_FORTH_WORDS_KEY 
2e19						DMARK "-2s" 
2e19 f5				push af  
2e1a 3a 2e 2e			ld a, (.dmark)  
2e1d 32 77 fb			ld (debug_mark),a  
2e20 3a 2f 2e			ld a, (.dmark+1)  
2e23 32 78 fb			ld (debug_mark+1),a  
2e26 3a 30 2e			ld a, (.dmark+2)  
2e29 32 79 fb			ld (debug_mark+2),a  
2e2c 18 03			jr .pastdmark  
2e2e ..			.dmark: db "-2s"  
2e31 f1			.pastdmark: pop af  
2e32			endm  
# End of macro DMARK
2e32						CALLMONITOR 
2e32 cd 5a 17			call break_point_state  
2e35				endm  
# End of macro CALLMONITOR
2e35					endif 
2e35			 
2e35					; Address 
2e35			 
2e35					FORTH_DSP_VALUEHL 
2e35 cd e1 1e			call macro_dsp_valuehl 
2e38				endm 
# End of macro FORTH_DSP_VALUEHL
2e38			 
2e38 e5					push hl    ; save address 
2e39			 
2e39					; load content into de 
2e39			 
2e39 5e					ld e,(hl) 
2e3a 23					inc hl 
2e3b 56					ld d, (hl) 
2e3c			 
2e3c					if DEBUG_FORTH_WORDS 
2e3c						DMARK "-2a" 
2e3c f5				push af  
2e3d 3a 51 2e			ld a, (.dmark)  
2e40 32 77 fb			ld (debug_mark),a  
2e43 3a 52 2e			ld a, (.dmark+1)  
2e46 32 78 fb			ld (debug_mark+1),a  
2e49 3a 53 2e			ld a, (.dmark+2)  
2e4c 32 79 fb			ld (debug_mark+2),a  
2e4f 18 03			jr .pastdmark  
2e51 ..			.dmark: db "-2a"  
2e54 f1			.pastdmark: pop af  
2e55			endm  
# End of macro DMARK
2e55						CALLMONITOR 
2e55 cd 5a 17			call break_point_state  
2e58				endm  
# End of macro CALLMONITOR
2e58					endif 
2e58			 
2e58					FORTH_DSP_POP 
2e58 cd 99 1f			call macro_forth_dsp_pop 
2e5b				endm 
# End of macro FORTH_DSP_POP
2e5b			 
2e5b					; Get value to remove 
2e5b			 
2e5b					FORTH_DSP_VALUE 
2e5b cd ca 1e			call macro_forth_dsp_value 
2e5e				endm 
# End of macro FORTH_DSP_VALUE
2e5e			 
2e5e					if DEBUG_FORTH_WORDS 
2e5e						DMARK "-2v" 
2e5e f5				push af  
2e5f 3a 73 2e			ld a, (.dmark)  
2e62 32 77 fb			ld (debug_mark),a  
2e65 3a 74 2e			ld a, (.dmark+1)  
2e68 32 78 fb			ld (debug_mark+1),a  
2e6b 3a 75 2e			ld a, (.dmark+2)  
2e6e 32 79 fb			ld (debug_mark+2),a  
2e71 18 03			jr .pastdmark  
2e73 ..			.dmark: db "-2v"  
2e76 f1			.pastdmark: pop af  
2e77			endm  
# End of macro DMARK
2e77						CALLMONITOR 
2e77 cd 5a 17			call break_point_state  
2e7a				endm  
# End of macro CALLMONITOR
2e7a					endif 
2e7a			 
2e7a eb					ex de, hl 
2e7b ed 52				sbc hl, de 
2e7d			 
2e7d					if DEBUG_FORTH_WORDS 
2e7d						DMARK "-2d" 
2e7d f5				push af  
2e7e 3a 92 2e			ld a, (.dmark)  
2e81 32 77 fb			ld (debug_mark),a  
2e84 3a 93 2e			ld a, (.dmark+1)  
2e87 32 78 fb			ld (debug_mark+1),a  
2e8a 3a 94 2e			ld a, (.dmark+2)  
2e8d 32 79 fb			ld (debug_mark+2),a  
2e90 18 03			jr .pastdmark  
2e92 ..			.dmark: db "-2d"  
2e95 f1			.pastdmark: pop af  
2e96			endm  
# End of macro DMARK
2e96						CALLMONITOR 
2e96 cd 5a 17			call break_point_state  
2e99				endm  
# End of macro CALLMONITOR
2e99					endif 
2e99			 
2e99					; move result to de 
2e99			 
2e99 eb					ex de, hl 
2e9a			 
2e9a					; Address 
2e9a			 
2e9a e1					pop hl 
2e9b			 
2e9b					; save it back 
2e9b			 
2e9b 73					ld (hl), e 
2e9c 23					inc hl 
2e9d 72					ld (hl), d 
2e9e			 
2e9e					if DEBUG_FORTH_WORDS 
2e9e						DMARK "-2e" 
2e9e f5				push af  
2e9f 3a b3 2e			ld a, (.dmark)  
2ea2 32 77 fb			ld (debug_mark),a  
2ea5 3a b4 2e			ld a, (.dmark+1)  
2ea8 32 78 fb			ld (debug_mark+1),a  
2eab 3a b5 2e			ld a, (.dmark+2)  
2eae 32 79 fb			ld (debug_mark+2),a  
2eb1 18 03			jr .pastdmark  
2eb3 ..			.dmark: db "-2e"  
2eb6 f1			.pastdmark: pop af  
2eb7			endm  
# End of macro DMARK
2eb7						CALLMONITOR 
2eb7 cd 5a 17			call break_point_state  
2eba				endm  
# End of macro CALLMONITOR
2eba					endif 
2eba			 
2eba			 
2eba			 
2eba			 
2eba			 
2eba				       NEXTW 
2eba c3 53 20			jp macro_next 
2ebd				endm 
# End of macro NEXTW
2ebd			.GET2: 
2ebd				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2ebd 6f				db WORD_SYS_CORE+91             
2ebe ed 2e			dw .BANG2            
2ec0 03				db 2 + 1 
2ec1 .. 00			db "2@",0              
2ec4				endm 
# End of macro CWHEAD
2ec4			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2ec4					if DEBUG_FORTH_WORDS_KEY 
2ec4						DMARK "2A_" 
2ec4 f5				push af  
2ec5 3a d9 2e			ld a, (.dmark)  
2ec8 32 77 fb			ld (debug_mark),a  
2ecb 3a da 2e			ld a, (.dmark+1)  
2ece 32 78 fb			ld (debug_mark+1),a  
2ed1 3a db 2e			ld a, (.dmark+2)  
2ed4 32 79 fb			ld (debug_mark+2),a  
2ed7 18 03			jr .pastdmark  
2ed9 ..			.dmark: db "2A_"  
2edc f1			.pastdmark: pop af  
2edd			endm  
# End of macro DMARK
2edd						CALLMONITOR 
2edd cd 5a 17			call break_point_state  
2ee0				endm  
# End of macro CALLMONITOR
2ee0					endif 
2ee0			 
2ee0					FORTH_DSP_VALUEHL 
2ee0 cd e1 1e			call macro_dsp_valuehl 
2ee3				endm 
# End of macro FORTH_DSP_VALUEHL
2ee3			 
2ee3 5e					ld e, (hl) 
2ee4 23					inc hl 
2ee5 56					ld d, (hl) 
2ee6			 
2ee6 eb					ex de, hl 
2ee7			 
2ee7 cd ea 1c				call forth_push_numhl 
2eea			 
2eea				       NEXTW 
2eea c3 53 20			jp macro_next 
2eed				endm 
# End of macro NEXTW
2eed			.BANG2: 
2eed				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2eed 6f				db WORD_SYS_CORE+91             
2eee 25 2f			dw .CONFIG            
2ef0 03				db 2 + 1 
2ef1 .. 00			db "2!",0              
2ef4				endm 
# End of macro CWHEAD
2ef4			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2ef4					if DEBUG_FORTH_WORDS_KEY 
2ef4						DMARK "2S_" 
2ef4 f5				push af  
2ef5 3a 09 2f			ld a, (.dmark)  
2ef8 32 77 fb			ld (debug_mark),a  
2efb 3a 0a 2f			ld a, (.dmark+1)  
2efe 32 78 fb			ld (debug_mark+1),a  
2f01 3a 0b 2f			ld a, (.dmark+2)  
2f04 32 79 fb			ld (debug_mark+2),a  
2f07 18 03			jr .pastdmark  
2f09 ..			.dmark: db "2S_"  
2f0c f1			.pastdmark: pop af  
2f0d			endm  
# End of macro DMARK
2f0d						CALLMONITOR 
2f0d cd 5a 17			call break_point_state  
2f10				endm  
# End of macro CALLMONITOR
2f10					endif 
2f10			 
2f10					FORTH_DSP_VALUEHL 
2f10 cd e1 1e			call macro_dsp_valuehl 
2f13				endm 
# End of macro FORTH_DSP_VALUEHL
2f13			 
2f13 e5					push hl   ; save address 
2f14			 
2f14			 
2f14					FORTH_DSP_POP 
2f14 cd 99 1f			call macro_forth_dsp_pop 
2f17				endm 
# End of macro FORTH_DSP_POP
2f17			 
2f17					 
2f17					FORTH_DSP_VALUEHL 
2f17 cd e1 1e			call macro_dsp_valuehl 
2f1a				endm 
# End of macro FORTH_DSP_VALUEHL
2f1a			 
2f1a					FORTH_DSP_POP 
2f1a cd 99 1f			call macro_forth_dsp_pop 
2f1d				endm 
# End of macro FORTH_DSP_POP
2f1d			 
2f1d eb					ex de, hl    ; value now in de 
2f1e			 
2f1e e1					pop hl 
2f1f			 
2f1f 73					ld (hl), e 
2f20			 
2f20 23					inc hl 
2f21			 
2f21 72					ld (hl), d 
2f22			 
2f22			 
2f22				       NEXTW 
2f22 c3 53 20			jp macro_next 
2f25				endm 
# End of macro NEXTW
2f25			.CONFIG: 
2f25				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
2f25 6f				db WORD_SYS_CORE+91             
2f26 36 2f			dw .ENDCORE            
2f28 07				db 6 + 1 
2f29 .. 00			db "CONFIG",0              
2f30				endm 
# End of macro CWHEAD
2f30			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
2f30			 
2f30 cd a7 13				call config 
2f33					NEXTW 
2f33 c3 53 20			jp macro_next 
2f36				endm 
# End of macro NEXTW
2f36			.ENDCORE: 
2f36			 
2f36			; eof 
2f36			 
2f36			 
# End of file forth_words_core.asm
2f36			include "forth_words_flow.asm" 
2f36			 
2f36			; | ## Program Flow Words 
2f36			 
2f36			.IF: 
2f36				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2f36 1e				db WORD_SYS_CORE+10             
2f37 2b 30			dw .THEN            
2f39 03				db 2 + 1 
2f3a .. 00			db "IF",0              
2f3d				endm 
# End of macro CWHEAD
2f3d			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2f3d			; 
2f3d					if DEBUG_FORTH_WORDS_KEY 
2f3d						DMARK "IF." 
2f3d f5				push af  
2f3e 3a 52 2f			ld a, (.dmark)  
2f41 32 77 fb			ld (debug_mark),a  
2f44 3a 53 2f			ld a, (.dmark+1)  
2f47 32 78 fb			ld (debug_mark+1),a  
2f4a 3a 54 2f			ld a, (.dmark+2)  
2f4d 32 79 fb			ld (debug_mark+2),a  
2f50 18 03			jr .pastdmark  
2f52 ..			.dmark: db "IF."  
2f55 f1			.pastdmark: pop af  
2f56			endm  
# End of macro DMARK
2f56						CALLMONITOR 
2f56 cd 5a 17			call break_point_state  
2f59				endm  
# End of macro CALLMONITOR
2f59					endif 
2f59			; eval TOS 
2f59			 
2f59				FORTH_DSP_VALUEHL 
2f59 cd e1 1e			call macro_dsp_valuehl 
2f5c				endm 
# End of macro FORTH_DSP_VALUEHL
2f5c			 
2f5c			;	push hl 
2f5c				FORTH_DSP_POP 
2f5c cd 99 1f			call macro_forth_dsp_pop 
2f5f				endm 
# End of macro FORTH_DSP_POP
2f5f			;	pop hl 
2f5f			 
2f5f					if DEBUG_FORTH_WORDS 
2f5f						DMARK "IF1" 
2f5f f5				push af  
2f60 3a 74 2f			ld a, (.dmark)  
2f63 32 77 fb			ld (debug_mark),a  
2f66 3a 75 2f			ld a, (.dmark+1)  
2f69 32 78 fb			ld (debug_mark+1),a  
2f6c 3a 76 2f			ld a, (.dmark+2)  
2f6f 32 79 fb			ld (debug_mark+2),a  
2f72 18 03			jr .pastdmark  
2f74 ..			.dmark: db "IF1"  
2f77 f1			.pastdmark: pop af  
2f78			endm  
# End of macro DMARK
2f78						CALLMONITOR 
2f78 cd 5a 17			call break_point_state  
2f7b				endm  
# End of macro CALLMONITOR
2f7b					endif 
2f7b b7				or a        ; clear carry flag 
2f7c 11 00 00			ld de, 0 
2f7f eb				ex de,hl 
2f80 ed 52			sbc hl, de 
2f82 c2 0c 30			jp nz, .iftrue 
2f85			 
2f85					if DEBUG_FORTH_WORDS 
2f85						DMARK "IF2" 
2f85 f5				push af  
2f86 3a 9a 2f			ld a, (.dmark)  
2f89 32 77 fb			ld (debug_mark),a  
2f8c 3a 9b 2f			ld a, (.dmark+1)  
2f8f 32 78 fb			ld (debug_mark+1),a  
2f92 3a 9c 2f			ld a, (.dmark+2)  
2f95 32 79 fb			ld (debug_mark+2),a  
2f98 18 03			jr .pastdmark  
2f9a ..			.dmark: db "IF2"  
2f9d f1			.pastdmark: pop af  
2f9e			endm  
# End of macro DMARK
2f9e						CALLMONITOR 
2f9e cd 5a 17			call break_point_state  
2fa1				endm  
# End of macro CALLMONITOR
2fa1					endif 
2fa1			 
2fa1			; if not true then skip to THEN 
2fa1			 
2fa1				; TODO get tok_ptr 
2fa1				; TODO consume toks until we get to THEN 
2fa1			 
2fa1 2a 1e f1			ld hl, (os_tok_ptr) 
2fa4					if DEBUG_FORTH_WORDS 
2fa4						DMARK "IF3" 
2fa4 f5				push af  
2fa5 3a b9 2f			ld a, (.dmark)  
2fa8 32 77 fb			ld (debug_mark),a  
2fab 3a ba 2f			ld a, (.dmark+1)  
2fae 32 78 fb			ld (debug_mark+1),a  
2fb1 3a bb 2f			ld a, (.dmark+2)  
2fb4 32 79 fb			ld (debug_mark+2),a  
2fb7 18 03			jr .pastdmark  
2fb9 ..			.dmark: db "IF3"  
2fbc f1			.pastdmark: pop af  
2fbd			endm  
# End of macro DMARK
2fbd						CALLMONITOR 
2fbd cd 5a 17			call break_point_state  
2fc0				endm  
# End of macro CALLMONITOR
2fc0						 
2fc0					endif 
2fc0 11 07 30			ld de, .ifthen 
2fc3					if DEBUG_FORTH_WORDS 
2fc3						DMARK "IF4" 
2fc3 f5				push af  
2fc4 3a d8 2f			ld a, (.dmark)  
2fc7 32 77 fb			ld (debug_mark),a  
2fca 3a d9 2f			ld a, (.dmark+1)  
2fcd 32 78 fb			ld (debug_mark+1),a  
2fd0 3a da 2f			ld a, (.dmark+2)  
2fd3 32 79 fb			ld (debug_mark+2),a  
2fd6 18 03			jr .pastdmark  
2fd8 ..			.dmark: db "IF4"  
2fdb f1			.pastdmark: pop af  
2fdc			endm  
# End of macro DMARK
2fdc						CALLMONITOR 
2fdc cd 5a 17			call break_point_state  
2fdf				endm  
# End of macro CALLMONITOR
2fdf					endif 
2fdf cd 6e 21			call findnexttok  
2fe2			 
2fe2					if DEBUG_FORTH_WORDS 
2fe2						DMARK "IF5" 
2fe2 f5				push af  
2fe3 3a f7 2f			ld a, (.dmark)  
2fe6 32 77 fb			ld (debug_mark),a  
2fe9 3a f8 2f			ld a, (.dmark+1)  
2fec 32 78 fb			ld (debug_mark+1),a  
2fef 3a f9 2f			ld a, (.dmark+2)  
2ff2 32 79 fb			ld (debug_mark+2),a  
2ff5 18 03			jr .pastdmark  
2ff7 ..			.dmark: db "IF5"  
2ffa f1			.pastdmark: pop af  
2ffb			endm  
# End of macro DMARK
2ffb						CALLMONITOR 
2ffb cd 5a 17			call break_point_state  
2ffe				endm  
# End of macro CALLMONITOR
2ffe					endif 
2ffe				; TODO replace below with ; exec using tok_ptr 
2ffe 22 1e f1			ld (os_tok_ptr), hl 
3001 c3 e4 20			jp exec1 
3004				NEXTW 
3004 c3 53 20			jp macro_next 
3007				endm 
# End of macro NEXTW
3007			 
3007 .. 00		.ifthen:  db "THEN",0 
300c			 
300c			.iftrue:		 
300c				; Exec next words normally 
300c			 
300c				; if true then exec following IF as normal 
300c					if DEBUG_FORTH_WORDS 
300c						DMARK "IFT" 
300c f5				push af  
300d 3a 21 30			ld a, (.dmark)  
3010 32 77 fb			ld (debug_mark),a  
3013 3a 22 30			ld a, (.dmark+1)  
3016 32 78 fb			ld (debug_mark+1),a  
3019 3a 23 30			ld a, (.dmark+2)  
301c 32 79 fb			ld (debug_mark+2),a  
301f 18 03			jr .pastdmark  
3021 ..			.dmark: db "IFT"  
3024 f1			.pastdmark: pop af  
3025			endm  
# End of macro DMARK
3025						CALLMONITOR 
3025 cd 5a 17			call break_point_state  
3028				endm  
# End of macro CALLMONITOR
3028					endif 
3028			 
3028					NEXTW 
3028 c3 53 20			jp macro_next 
302b				endm 
# End of macro NEXTW
302b			.THEN: 
302b				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
302b 1f				db WORD_SYS_CORE+11             
302c 53 30			dw .ELSE            
302e 05				db 4 + 1 
302f .. 00			db "THEN",0              
3034				endm 
# End of macro CWHEAD
3034			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
3034					if DEBUG_FORTH_WORDS_KEY 
3034						DMARK "THN" 
3034 f5				push af  
3035 3a 49 30			ld a, (.dmark)  
3038 32 77 fb			ld (debug_mark),a  
303b 3a 4a 30			ld a, (.dmark+1)  
303e 32 78 fb			ld (debug_mark+1),a  
3041 3a 4b 30			ld a, (.dmark+2)  
3044 32 79 fb			ld (debug_mark+2),a  
3047 18 03			jr .pastdmark  
3049 ..			.dmark: db "THN"  
304c f1			.pastdmark: pop af  
304d			endm  
# End of macro DMARK
304d						CALLMONITOR 
304d cd 5a 17			call break_point_state  
3050				endm  
# End of macro CALLMONITOR
3050					endif 
3050					NEXTW 
3050 c3 53 20			jp macro_next 
3053				endm 
# End of macro NEXTW
3053			.ELSE: 
3053				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
3053 20				db WORD_SYS_CORE+12             
3054 7b 30			dw .DO            
3056 03				db 2 + 1 
3057 .. 00			db "ELSE",0              
305c				endm 
# End of macro CWHEAD
305c			; | ELSE ( -- ) Not supported - does nothing | TODO 
305c			 
305c					if DEBUG_FORTH_WORDS_KEY 
305c						DMARK "ELS" 
305c f5				push af  
305d 3a 71 30			ld a, (.dmark)  
3060 32 77 fb			ld (debug_mark),a  
3063 3a 72 30			ld a, (.dmark+1)  
3066 32 78 fb			ld (debug_mark+1),a  
3069 3a 73 30			ld a, (.dmark+2)  
306c 32 79 fb			ld (debug_mark+2),a  
306f 18 03			jr .pastdmark  
3071 ..			.dmark: db "ELS"  
3074 f1			.pastdmark: pop af  
3075			endm  
# End of macro DMARK
3075						CALLMONITOR 
3075 cd 5a 17			call break_point_state  
3078				endm  
# End of macro CALLMONITOR
3078					endif 
3078			 
3078			 
3078					NEXTW 
3078 c3 53 20			jp macro_next 
307b				endm 
# End of macro NEXTW
307b			.DO: 
307b				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
307b 21				db WORD_SYS_CORE+13             
307c a2 31			dw .LOOP            
307e 03				db 2 + 1 
307f .. 00			db "DO",0              
3082				endm 
# End of macro CWHEAD
3082			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
3082			 
3082					if DEBUG_FORTH_WORDS_KEY 
3082						DMARK "DO." 
3082 f5				push af  
3083 3a 97 30			ld a, (.dmark)  
3086 32 77 fb			ld (debug_mark),a  
3089 3a 98 30			ld a, (.dmark+1)  
308c 32 78 fb			ld (debug_mark+1),a  
308f 3a 99 30			ld a, (.dmark+2)  
3092 32 79 fb			ld (debug_mark+2),a  
3095 18 03			jr .pastdmark  
3097 ..			.dmark: db "DO."  
309a f1			.pastdmark: pop af  
309b			endm  
# End of macro DMARK
309b						CALLMONITOR 
309b cd 5a 17			call break_point_state  
309e				endm  
# End of macro CALLMONITOR
309e					endif 
309e			;  push pc to rsp stack past the DO 
309e			 
309e 2a 1e f1				ld hl, (os_tok_ptr) 
30a1 23					inc hl   ; D 
30a2 23					inc hl  ; O 
30a3 23					inc hl   ; null 
30a4					if DEBUG_FORTH_WORDS 
30a4						DMARK "DO2" 
30a4 f5				push af  
30a5 3a b9 30			ld a, (.dmark)  
30a8 32 77 fb			ld (debug_mark),a  
30ab 3a ba 30			ld a, (.dmark+1)  
30ae 32 78 fb			ld (debug_mark+1),a  
30b1 3a bb 30			ld a, (.dmark+2)  
30b4 32 79 fb			ld (debug_mark+2),a  
30b7 18 03			jr .pastdmark  
30b9 ..			.dmark: db "DO2"  
30bc f1			.pastdmark: pop af  
30bd			endm  
# End of macro DMARK
30bd						CALLMONITOR 
30bd cd 5a 17			call break_point_state  
30c0				endm  
# End of macro CALLMONITOR
30c0					endif 
30c0					FORTH_RSP_NEXT 
30c0 cd 91 1c			call macro_forth_rsp_next 
30c3				endm 
# End of macro FORTH_RSP_NEXT
30c3					if DEBUG_FORTH_WORDS 
30c3						DMARK "DO3" 
30c3 f5				push af  
30c4 3a d8 30			ld a, (.dmark)  
30c7 32 77 fb			ld (debug_mark),a  
30ca 3a d9 30			ld a, (.dmark+1)  
30cd 32 78 fb			ld (debug_mark+1),a  
30d0 3a da 30			ld a, (.dmark+2)  
30d3 32 79 fb			ld (debug_mark+2),a  
30d6 18 03			jr .pastdmark  
30d8 ..			.dmark: db "DO3"  
30db f1			.pastdmark: pop af  
30dc			endm  
# End of macro DMARK
30dc						CALLMONITOR 
30dc cd 5a 17			call break_point_state  
30df				endm  
# End of macro CALLMONITOR
30df					endif 
30df			 
30df					;if DEBUG_FORTH_WORDS 
30df				;		push hl 
30df			;		endif  
30df			 
30df			; get counters from data stack 
30df			 
30df			 
30df					FORTH_DSP_VALUEHL 
30df cd e1 1e			call macro_dsp_valuehl 
30e2				endm 
# End of macro FORTH_DSP_VALUEHL
30e2 e5					push hl		 ; hl now has starting counter which needs to be tos 
30e3			 
30e3					if DEBUG_FORTH_WORDS 
30e3						DMARK "DO4" 
30e3 f5				push af  
30e4 3a f8 30			ld a, (.dmark)  
30e7 32 77 fb			ld (debug_mark),a  
30ea 3a f9 30			ld a, (.dmark+1)  
30ed 32 78 fb			ld (debug_mark+1),a  
30f0 3a fa 30			ld a, (.dmark+2)  
30f3 32 79 fb			ld (debug_mark+2),a  
30f6 18 03			jr .pastdmark  
30f8 ..			.dmark: db "DO4"  
30fb f1			.pastdmark: pop af  
30fc			endm  
# End of macro DMARK
30fc						CALLMONITOR 
30fc cd 5a 17			call break_point_state  
30ff				endm  
# End of macro CALLMONITOR
30ff					endif 
30ff					FORTH_DSP_POP 
30ff cd 99 1f			call macro_forth_dsp_pop 
3102				endm 
# End of macro FORTH_DSP_POP
3102			 
3102					if DEBUG_FORTH_WORDS 
3102						DMARK "DO5" 
3102 f5				push af  
3103 3a 17 31			ld a, (.dmark)  
3106 32 77 fb			ld (debug_mark),a  
3109 3a 18 31			ld a, (.dmark+1)  
310c 32 78 fb			ld (debug_mark+1),a  
310f 3a 19 31			ld a, (.dmark+2)  
3112 32 79 fb			ld (debug_mark+2),a  
3115 18 03			jr .pastdmark  
3117 ..			.dmark: db "DO5"  
311a f1			.pastdmark: pop af  
311b			endm  
# End of macro DMARK
311b						CALLMONITOR 
311b cd 5a 17			call break_point_state  
311e				endm  
# End of macro CALLMONITOR
311e					endif 
311e			 
311e					FORTH_DSP_VALUEHL 
311e cd e1 1e			call macro_dsp_valuehl 
3121				endm 
# End of macro FORTH_DSP_VALUEHL
3121			;		push hl		 ; hl now has starting limit counter 
3121			 
3121					if DEBUG_FORTH_WORDS 
3121						DMARK "DO6" 
3121 f5				push af  
3122 3a 36 31			ld a, (.dmark)  
3125 32 77 fb			ld (debug_mark),a  
3128 3a 37 31			ld a, (.dmark+1)  
312b 32 78 fb			ld (debug_mark+1),a  
312e 3a 38 31			ld a, (.dmark+2)  
3131 32 79 fb			ld (debug_mark+2),a  
3134 18 03			jr .pastdmark  
3136 ..			.dmark: db "DO6"  
3139 f1			.pastdmark: pop af  
313a			endm  
# End of macro DMARK
313a						CALLMONITOR 
313a cd 5a 17			call break_point_state  
313d				endm  
# End of macro CALLMONITOR
313d					endif 
313d					FORTH_DSP_POP 
313d cd 99 1f			call macro_forth_dsp_pop 
3140				endm 
# End of macro FORTH_DSP_POP
3140			 
3140			; put counters on the loop stack 
3140			 
3140			;		pop hl			 ; limit counter 
3140 d1					pop de			; start counter 
3141			 
3141					; push limit counter 
3141			 
3141					if DEBUG_FORTH_WORDS 
3141						DMARK "DO7" 
3141 f5				push af  
3142 3a 56 31			ld a, (.dmark)  
3145 32 77 fb			ld (debug_mark),a  
3148 3a 57 31			ld a, (.dmark+1)  
314b 32 78 fb			ld (debug_mark+1),a  
314e 3a 58 31			ld a, (.dmark+2)  
3151 32 79 fb			ld (debug_mark+2),a  
3154 18 03			jr .pastdmark  
3156 ..			.dmark: db "DO7"  
3159 f1			.pastdmark: pop af  
315a			endm  
# End of macro DMARK
315a						CALLMONITOR 
315a cd 5a 17			call break_point_state  
315d				endm  
# End of macro CALLMONITOR
315d					endif 
315d					FORTH_LOOP_NEXT 
315d cd 12 1f			call macro_forth_loop_next 
3160				endm 
# End of macro FORTH_LOOP_NEXT
3160			 
3160					; push start counter 
3160			 
3160 eb					ex de, hl 
3161					if DEBUG_FORTH_WORDS 
3161						DMARK "DO7" 
3161 f5				push af  
3162 3a 76 31			ld a, (.dmark)  
3165 32 77 fb			ld (debug_mark),a  
3168 3a 77 31			ld a, (.dmark+1)  
316b 32 78 fb			ld (debug_mark+1),a  
316e 3a 78 31			ld a, (.dmark+2)  
3171 32 79 fb			ld (debug_mark+2),a  
3174 18 03			jr .pastdmark  
3176 ..			.dmark: db "DO7"  
3179 f1			.pastdmark: pop af  
317a			endm  
# End of macro DMARK
317a						CALLMONITOR 
317a cd 5a 17			call break_point_state  
317d				endm  
# End of macro CALLMONITOR
317d					endif 
317d					FORTH_LOOP_NEXT 
317d cd 12 1f			call macro_forth_loop_next 
3180				endm 
# End of macro FORTH_LOOP_NEXT
3180			 
3180			 
3180					; init first round of I counter 
3180			 
3180 22 42 f1				ld (os_current_i), hl 
3183			 
3183					if DEBUG_FORTH_WORDS 
3183						DMARK "DO8" 
3183 f5				push af  
3184 3a 98 31			ld a, (.dmark)  
3187 32 77 fb			ld (debug_mark),a  
318a 3a 99 31			ld a, (.dmark+1)  
318d 32 78 fb			ld (debug_mark+1),a  
3190 3a 9a 31			ld a, (.dmark+2)  
3193 32 79 fb			ld (debug_mark+2),a  
3196 18 03			jr .pastdmark  
3198 ..			.dmark: db "DO8"  
319b f1			.pastdmark: pop af  
319c			endm  
# End of macro DMARK
319c						CALLMONITOR 
319c cd 5a 17			call break_point_state  
319f				endm  
# End of macro CALLMONITOR
319f					endif 
319f			 
319f					NEXTW 
319f c3 53 20			jp macro_next 
31a2				endm 
# End of macro NEXTW
31a2			.LOOP: 
31a2				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
31a2 22				db WORD_SYS_CORE+14             
31a3 ba 32			dw .I            
31a5 05				db 4 + 1 
31a6 .. 00			db "LOOP",0              
31ab				endm 
# End of macro CWHEAD
31ab			; | LOOP ( -- ) Increment and test loop counter  | DONE 
31ab			 
31ab				; pop tos as current loop count to hl 
31ab			 
31ab				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
31ab			 
31ab				FORTH_LOOP_TOS 
31ab cd 45 1f			call macro_forth_loop_tos 
31ae				endm 
# End of macro FORTH_LOOP_TOS
31ae e5				push hl 
31af			 
31af					if DEBUG_FORTH_WORDS_KEY 
31af						DMARK "LOP" 
31af f5				push af  
31b0 3a c4 31			ld a, (.dmark)  
31b3 32 77 fb			ld (debug_mark),a  
31b6 3a c5 31			ld a, (.dmark+1)  
31b9 32 78 fb			ld (debug_mark+1),a  
31bc 3a c6 31			ld a, (.dmark+2)  
31bf 32 79 fb			ld (debug_mark+2),a  
31c2 18 03			jr .pastdmark  
31c4 ..			.dmark: db "LOP"  
31c7 f1			.pastdmark: pop af  
31c8			endm  
# End of macro DMARK
31c8						CALLMONITOR 
31c8 cd 5a 17			call break_point_state  
31cb				endm  
# End of macro CALLMONITOR
31cb					endif 
31cb				; next item on the stack is the limit. get it 
31cb			 
31cb			 
31cb				FORTH_LOOP_POP 
31cb cd 4f 1f			call macro_forth_loop_pop 
31ce				endm 
# End of macro FORTH_LOOP_POP
31ce			 
31ce				FORTH_LOOP_TOS 
31ce cd 45 1f			call macro_forth_loop_tos 
31d1				endm 
# End of macro FORTH_LOOP_TOS
31d1			 
31d1 d1				pop de		 ; de = i, hl = limit 
31d2			 
31d2					if DEBUG_FORTH_WORDS 
31d2						DMARK "LP1" 
31d2 f5				push af  
31d3 3a e7 31			ld a, (.dmark)  
31d6 32 77 fb			ld (debug_mark),a  
31d9 3a e8 31			ld a, (.dmark+1)  
31dc 32 78 fb			ld (debug_mark+1),a  
31df 3a e9 31			ld a, (.dmark+2)  
31e2 32 79 fb			ld (debug_mark+2),a  
31e5 18 03			jr .pastdmark  
31e7 ..			.dmark: db "LP1"  
31ea f1			.pastdmark: pop af  
31eb			endm  
# End of macro DMARK
31eb						CALLMONITOR 
31eb cd 5a 17			call break_point_state  
31ee				endm  
# End of macro CALLMONITOR
31ee					endif 
31ee			 
31ee				; go back to previous word 
31ee			 
31ee d5				push de    ; save I for inc later 
31ef			 
31ef			 
31ef				; get limit 
31ef				;  is I at limit? 
31ef			 
31ef			 
31ef					if DEBUG_FORTH_WORDS 
31ef						DMARK "LP1" 
31ef f5				push af  
31f0 3a 04 32			ld a, (.dmark)  
31f3 32 77 fb			ld (debug_mark),a  
31f6 3a 05 32			ld a, (.dmark+1)  
31f9 32 78 fb			ld (debug_mark+1),a  
31fc 3a 06 32			ld a, (.dmark+2)  
31ff 32 79 fb			ld (debug_mark+2),a  
3202 18 03			jr .pastdmark  
3204 ..			.dmark: db "LP1"  
3207 f1			.pastdmark: pop af  
3208			endm  
# End of macro DMARK
3208						CALLMONITOR 
3208 cd 5a 17			call break_point_state  
320b				endm  
# End of macro CALLMONITOR
320b					endif 
320b			 
320b ed 52			sbc hl, de 
320d			 
320d			 
320d				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
320d			 
320d 20 26				jr nz, .loopnotdone 
320f			 
320f e1				pop hl   ; get rid of saved I 
3210				FORTH_LOOP_POP     ; get rid of limit 
3210 cd 4f 1f			call macro_forth_loop_pop 
3213				endm 
# End of macro FORTH_LOOP_POP
3213			 
3213				FORTH_RSP_POP     ; get rid of DO ptr 
3213 cd b2 1c			call macro_forth_rsp_pop 
3216				endm 
# End of macro FORTH_RSP_POP
3216			 
3216			if DEBUG_FORTH_WORDS 
3216						DMARK "LP>" 
3216 f5				push af  
3217 3a 2b 32			ld a, (.dmark)  
321a 32 77 fb			ld (debug_mark),a  
321d 3a 2c 32			ld a, (.dmark+1)  
3220 32 78 fb			ld (debug_mark+1),a  
3223 3a 2d 32			ld a, (.dmark+2)  
3226 32 79 fb			ld (debug_mark+2),a  
3229 18 03			jr .pastdmark  
322b ..			.dmark: db "LP>"  
322e f1			.pastdmark: pop af  
322f			endm  
# End of macro DMARK
322f				CALLMONITOR 
322f cd 5a 17			call break_point_state  
3232				endm  
# End of macro CALLMONITOR
3232			endif 
3232			 
3232					NEXTW 
3232 c3 53 20			jp macro_next 
3235				endm 
# End of macro NEXTW
3235				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3235			 
3235			.loopnotdone: 
3235			 
3235 e1				pop hl    ; get I 
3236 23				inc hl 
3237			 
3237			   	; save new I 
3237			 
3237			 
3237					; set I counter 
3237			 
3237 22 42 f1				ld (os_current_i), hl 
323a			 
323a					if DEBUG_FORTH_WORDS 
323a						DMARK "LPN" 
323a f5				push af  
323b 3a 4f 32			ld a, (.dmark)  
323e 32 77 fb			ld (debug_mark),a  
3241 3a 50 32			ld a, (.dmark+1)  
3244 32 78 fb			ld (debug_mark+1),a  
3247 3a 51 32			ld a, (.dmark+2)  
324a 32 79 fb			ld (debug_mark+2),a  
324d 18 03			jr .pastdmark  
324f ..			.dmark: db "LPN"  
3252 f1			.pastdmark: pop af  
3253			endm  
# End of macro DMARK
3253					CALLMONITOR 
3253 cd 5a 17			call break_point_state  
3256				endm  
# End of macro CALLMONITOR
3256					endif 
3256					 
3256				FORTH_LOOP_NEXT 
3256 cd 12 1f			call macro_forth_loop_next 
3259				endm 
# End of macro FORTH_LOOP_NEXT
3259			 
3259			 
3259					if DEBUG_FORTH_WORDS 
3259 eb						ex de,hl 
325a					endif 
325a			 
325a			;	; get DO ptr 
325a			; 
325a					if DEBUG_FORTH_WORDS 
325a						DMARK "LP7" 
325a f5				push af  
325b 3a 6f 32			ld a, (.dmark)  
325e 32 77 fb			ld (debug_mark),a  
3261 3a 70 32			ld a, (.dmark+1)  
3264 32 78 fb			ld (debug_mark+1),a  
3267 3a 71 32			ld a, (.dmark+2)  
326a 32 79 fb			ld (debug_mark+2),a  
326d 18 03			jr .pastdmark  
326f ..			.dmark: db "LP7"  
3272 f1			.pastdmark: pop af  
3273			endm  
# End of macro DMARK
3273					CALLMONITOR 
3273 cd 5a 17			call break_point_state  
3276				endm  
# End of macro CALLMONITOR
3276					endif 
3276				FORTH_RSP_TOS 
3276 cd a8 1c			call macro_forth_rsp_tos 
3279				endm 
# End of macro FORTH_RSP_TOS
3279			 
3279					if DEBUG_FORTH_WORDS 
3279						DMARK "LP8" 
3279 f5				push af  
327a 3a 8e 32			ld a, (.dmark)  
327d 32 77 fb			ld (debug_mark),a  
3280 3a 8f 32			ld a, (.dmark+1)  
3283 32 78 fb			ld (debug_mark+1),a  
3286 3a 90 32			ld a, (.dmark+2)  
3289 32 79 fb			ld (debug_mark+2),a  
328c 18 03			jr .pastdmark  
328e ..			.dmark: db "LP8"  
3291 f1			.pastdmark: pop af  
3292			endm  
# End of macro DMARK
3292					CALLMONITOR 
3292 cd 5a 17			call break_point_state  
3295				endm  
# End of macro CALLMONITOR
3295					endif 
3295				;push hl 
3295			 
3295				; not going to DO any more 
3295				; get rid of the RSP pointer as DO will add it back in 
3295				;FORTH_RSP_POP 
3295				;pop hl 
3295			 
3295				;ld hl,(cli_ret_sp) 
3295				;ld e, (hl) 
3295				;inc hl 
3295				;ld d, (hl) 
3295				;ex de,hl 
3295 22 1e f1			ld (os_tok_ptr), hl 
3298					if DEBUG_FORTH_WORDS 
3298						DMARK "LP<" 
3298 f5				push af  
3299 3a ad 32			ld a, (.dmark)  
329c 32 77 fb			ld (debug_mark),a  
329f 3a ae 32			ld a, (.dmark+1)  
32a2 32 78 fb			ld (debug_mark+1),a  
32a5 3a af 32			ld a, (.dmark+2)  
32a8 32 79 fb			ld (debug_mark+2),a  
32ab 18 03			jr .pastdmark  
32ad ..			.dmark: db "LP<"  
32b0 f1			.pastdmark: pop af  
32b1			endm  
# End of macro DMARK
32b1					CALLMONITOR 
32b1 cd 5a 17			call break_point_state  
32b4				endm  
# End of macro CALLMONITOR
32b4				endif 
32b4 c3 e4 20			jp exec1 
32b7			 
32b7					 
32b7			 
32b7			 
32b7					NEXTW 
32b7 c3 53 20			jp macro_next 
32ba				endm 
# End of macro NEXTW
32ba			.I:  
32ba			 
32ba				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
32ba 5e				db WORD_SYS_CORE+74             
32bb e5 32			dw .DLOOP            
32bd 02				db 1 + 1 
32be .. 00			db "I",0              
32c0				endm 
# End of macro CWHEAD
32c0			; | I ( -- ) Current loop counter | DONE 
32c0					if DEBUG_FORTH_WORDS_KEY 
32c0						DMARK "I.." 
32c0 f5				push af  
32c1 3a d5 32			ld a, (.dmark)  
32c4 32 77 fb			ld (debug_mark),a  
32c7 3a d6 32			ld a, (.dmark+1)  
32ca 32 78 fb			ld (debug_mark+1),a  
32cd 3a d7 32			ld a, (.dmark+2)  
32d0 32 79 fb			ld (debug_mark+2),a  
32d3 18 03			jr .pastdmark  
32d5 ..			.dmark: db "I.."  
32d8 f1			.pastdmark: pop af  
32d9			endm  
# End of macro DMARK
32d9						CALLMONITOR 
32d9 cd 5a 17			call break_point_state  
32dc				endm  
# End of macro CALLMONITOR
32dc					endif 
32dc			 
32dc 2a 42 f1				ld hl,(os_current_i) 
32df cd ea 1c				call forth_push_numhl 
32e2			 
32e2					NEXTW 
32e2 c3 53 20			jp macro_next 
32e5				endm 
# End of macro NEXTW
32e5			.DLOOP: 
32e5				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
32e5 5f				db WORD_SYS_CORE+75             
32e6 c6 33			dw .REPEAT            
32e8 06				db 5 + 1 
32e9 .. 00			db "-LOOP",0              
32ef				endm 
# End of macro CWHEAD
32ef			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
32ef				; pop tos as current loop count to hl 
32ef					if DEBUG_FORTH_WORDS_KEY 
32ef						DMARK "-LP" 
32ef f5				push af  
32f0 3a 04 33			ld a, (.dmark)  
32f3 32 77 fb			ld (debug_mark),a  
32f6 3a 05 33			ld a, (.dmark+1)  
32f9 32 78 fb			ld (debug_mark+1),a  
32fc 3a 06 33			ld a, (.dmark+2)  
32ff 32 79 fb			ld (debug_mark+2),a  
3302 18 03			jr .pastdmark  
3304 ..			.dmark: db "-LP"  
3307 f1			.pastdmark: pop af  
3308			endm  
# End of macro DMARK
3308						CALLMONITOR 
3308 cd 5a 17			call break_point_state  
330b				endm  
# End of macro CALLMONITOR
330b					endif 
330b			 
330b				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
330b			 
330b				FORTH_LOOP_TOS 
330b cd 45 1f			call macro_forth_loop_tos 
330e				endm 
# End of macro FORTH_LOOP_TOS
330e e5				push hl 
330f			 
330f					if DEBUG_FORTH_WORDS 
330f						DMARK "-LP" 
330f f5				push af  
3310 3a 24 33			ld a, (.dmark)  
3313 32 77 fb			ld (debug_mark),a  
3316 3a 25 33			ld a, (.dmark+1)  
3319 32 78 fb			ld (debug_mark+1),a  
331c 3a 26 33			ld a, (.dmark+2)  
331f 32 79 fb			ld (debug_mark+2),a  
3322 18 03			jr .pastdmark  
3324 ..			.dmark: db "-LP"  
3327 f1			.pastdmark: pop af  
3328			endm  
# End of macro DMARK
3328						CALLMONITOR 
3328 cd 5a 17			call break_point_state  
332b				endm  
# End of macro CALLMONITOR
332b					endif 
332b				; next item on the stack is the limit. get it 
332b			 
332b			 
332b				FORTH_LOOP_POP 
332b cd 4f 1f			call macro_forth_loop_pop 
332e				endm 
# End of macro FORTH_LOOP_POP
332e			 
332e				FORTH_LOOP_TOS 
332e cd 45 1f			call macro_forth_loop_tos 
3331				endm 
# End of macro FORTH_LOOP_TOS
3331			 
3331 d1				pop de		 ; de = i, hl = limit 
3332			 
3332					if DEBUG_FORTH_WORDS 
3332						DMARK "-L1" 
3332 f5				push af  
3333 3a 47 33			ld a, (.dmark)  
3336 32 77 fb			ld (debug_mark),a  
3339 3a 48 33			ld a, (.dmark+1)  
333c 32 78 fb			ld (debug_mark+1),a  
333f 3a 49 33			ld a, (.dmark+2)  
3342 32 79 fb			ld (debug_mark+2),a  
3345 18 03			jr .pastdmark  
3347 ..			.dmark: db "-L1"  
334a f1			.pastdmark: pop af  
334b			endm  
# End of macro DMARK
334b						CALLMONITOR 
334b cd 5a 17			call break_point_state  
334e				endm  
# End of macro CALLMONITOR
334e					endif 
334e			 
334e				; go back to previous word 
334e			 
334e d5				push de    ; save I for inc later 
334f			 
334f			 
334f				; get limit 
334f				;  is I at limit? 
334f			 
334f			 
334f					if DEBUG_FORTH_WORDS 
334f						DMARK "-L1" 
334f f5				push af  
3350 3a 64 33			ld a, (.dmark)  
3353 32 77 fb			ld (debug_mark),a  
3356 3a 65 33			ld a, (.dmark+1)  
3359 32 78 fb			ld (debug_mark+1),a  
335c 3a 66 33			ld a, (.dmark+2)  
335f 32 79 fb			ld (debug_mark+2),a  
3362 18 03			jr .pastdmark  
3364 ..			.dmark: db "-L1"  
3367 f1			.pastdmark: pop af  
3368			endm  
# End of macro DMARK
3368						CALLMONITOR 
3368 cd 5a 17			call break_point_state  
336b				endm  
# End of macro CALLMONITOR
336b					endif 
336b			 
336b ed 52			sbc hl, de 
336d			 
336d			 
336d				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
336d			 
336d 20 26				jr nz, .mloopnotdone 
336f			 
336f e1				pop hl   ; get rid of saved I 
3370				FORTH_LOOP_POP     ; get rid of limit 
3370 cd 4f 1f			call macro_forth_loop_pop 
3373				endm 
# End of macro FORTH_LOOP_POP
3373			 
3373				FORTH_RSP_POP     ; get rid of DO ptr 
3373 cd b2 1c			call macro_forth_rsp_pop 
3376				endm 
# End of macro FORTH_RSP_POP
3376			 
3376			if DEBUG_FORTH_WORDS 
3376						DMARK "-L>" 
3376 f5				push af  
3377 3a 8b 33			ld a, (.dmark)  
337a 32 77 fb			ld (debug_mark),a  
337d 3a 8c 33			ld a, (.dmark+1)  
3380 32 78 fb			ld (debug_mark+1),a  
3383 3a 8d 33			ld a, (.dmark+2)  
3386 32 79 fb			ld (debug_mark+2),a  
3389 18 03			jr .pastdmark  
338b ..			.dmark: db "-L>"  
338e f1			.pastdmark: pop af  
338f			endm  
# End of macro DMARK
338f				CALLMONITOR 
338f cd 5a 17			call break_point_state  
3392				endm  
# End of macro CALLMONITOR
3392			endif 
3392			 
3392					NEXTW 
3392 c3 53 20			jp macro_next 
3395				endm 
# End of macro NEXTW
3395				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3395			 
3395			.mloopnotdone: 
3395			 
3395 e1				pop hl    ; get I 
3396 2b				dec hl 
3397			 
3397			   	; save new I 
3397			 
3397			 
3397					; set I counter 
3397			 
3397 22 42 f1				ld (os_current_i), hl 
339a			 
339a					 
339a				FORTH_LOOP_NEXT 
339a cd 12 1f			call macro_forth_loop_next 
339d				endm 
# End of macro FORTH_LOOP_NEXT
339d			 
339d			 
339d					if DEBUG_FORTH_WORDS 
339d eb						ex de,hl 
339e					endif 
339e			 
339e			;	; get DO ptr 
339e			; 
339e				FORTH_RSP_TOS 
339e cd a8 1c			call macro_forth_rsp_tos 
33a1				endm 
# End of macro FORTH_RSP_TOS
33a1			 
33a1				;push hl 
33a1			 
33a1				; not going to DO any more 
33a1				; get rid of the RSP pointer as DO will add it back in 
33a1				;FORTH_RSP_POP 
33a1				;pop hl 
33a1			 
33a1			 
33a1 22 1e f1			ld (os_tok_ptr), hl 
33a4					if DEBUG_FORTH_WORDS 
33a4						DMARK "-L<" 
33a4 f5				push af  
33a5 3a b9 33			ld a, (.dmark)  
33a8 32 77 fb			ld (debug_mark),a  
33ab 3a ba 33			ld a, (.dmark+1)  
33ae 32 78 fb			ld (debug_mark+1),a  
33b1 3a bb 33			ld a, (.dmark+2)  
33b4 32 79 fb			ld (debug_mark+2),a  
33b7 18 03			jr .pastdmark  
33b9 ..			.dmark: db "-L<"  
33bc f1			.pastdmark: pop af  
33bd			endm  
# End of macro DMARK
33bd					CALLMONITOR 
33bd cd 5a 17			call break_point_state  
33c0				endm  
# End of macro CALLMONITOR
33c0				endif 
33c0 c3 e4 20			jp exec1 
33c3			 
33c3					 
33c3			 
33c3			 
33c3			 
33c3				NEXTW 
33c3 c3 53 20			jp macro_next 
33c6				endm 
# End of macro NEXTW
33c6			 
33c6			 
33c6			 
33c6			 
33c6			.REPEAT: 
33c6				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
33c6 71				db WORD_SYS_CORE+93             
33c7 19 34			dw .UNTIL            
33c9 06				db 5 + 1 
33ca .. 00			db "REPEAT",0              
33d1				endm 
# End of macro CWHEAD
33d1			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
33d1			;  push pc to rsp stack past the REPEAT 
33d1					if DEBUG_FORTH_WORDS_KEY 
33d1						DMARK "REP" 
33d1 f5				push af  
33d2 3a e6 33			ld a, (.dmark)  
33d5 32 77 fb			ld (debug_mark),a  
33d8 3a e7 33			ld a, (.dmark+1)  
33db 32 78 fb			ld (debug_mark+1),a  
33de 3a e8 33			ld a, (.dmark+2)  
33e1 32 79 fb			ld (debug_mark+2),a  
33e4 18 03			jr .pastdmark  
33e6 ..			.dmark: db "REP"  
33e9 f1			.pastdmark: pop af  
33ea			endm  
# End of macro DMARK
33ea						CALLMONITOR 
33ea cd 5a 17			call break_point_state  
33ed				endm  
# End of macro CALLMONITOR
33ed					endif 
33ed			 
33ed 2a 1e f1				ld hl, (os_tok_ptr) 
33f0 23					inc hl   ; R 
33f1 23					inc hl  ; E 
33f2 23					inc hl   ; P 
33f3 23					inc hl   ; E 
33f4 23					inc hl   ; A 
33f5 23					inc hl   ; T 
33f6 23					inc hl   ; zero 
33f7					FORTH_RSP_NEXT 
33f7 cd 91 1c			call macro_forth_rsp_next 
33fa				endm 
# End of macro FORTH_RSP_NEXT
33fa			 
33fa			 
33fa					if DEBUG_FORTH_WORDS 
33fa						DMARK "REP" 
33fa f5				push af  
33fb 3a 0f 34			ld a, (.dmark)  
33fe 32 77 fb			ld (debug_mark),a  
3401 3a 10 34			ld a, (.dmark+1)  
3404 32 78 fb			ld (debug_mark+1),a  
3407 3a 11 34			ld a, (.dmark+2)  
340a 32 79 fb			ld (debug_mark+2),a  
340d 18 03			jr .pastdmark  
340f ..			.dmark: db "REP"  
3412 f1			.pastdmark: pop af  
3413			endm  
# End of macro DMARK
3413						;pop bc    ; TODO BUG ?????? what is this for???? 
3413						CALLMONITOR 
3413 cd 5a 17			call break_point_state  
3416				endm  
# End of macro CALLMONITOR
3416					endif 
3416			 
3416					NEXTW 
3416 c3 53 20			jp macro_next 
3419				endm 
# End of macro NEXTW
3419			;	       NEXTW 
3419			 
3419			.UNTIL: 
3419				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
3419 72				db WORD_SYS_CORE+94             
341a b0 34			dw .ENDFLOW            
341c 06				db 5 + 1 
341d .. 00			db "UNTIL",0              
3423				endm 
# End of macro CWHEAD
3423			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
3423			 
3423				; pop tos as check 
3423			 
3423				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3423			 
3423				FORTH_DSP_VALUEHL 
3423 cd e1 1e			call macro_dsp_valuehl 
3426				endm 
# End of macro FORTH_DSP_VALUEHL
3426			 
3426					if DEBUG_FORTH_WORDS_KEY 
3426						DMARK "UNT" 
3426 f5				push af  
3427 3a 3b 34			ld a, (.dmark)  
342a 32 77 fb			ld (debug_mark),a  
342d 3a 3c 34			ld a, (.dmark+1)  
3430 32 78 fb			ld (debug_mark+1),a  
3433 3a 3d 34			ld a, (.dmark+2)  
3436 32 79 fb			ld (debug_mark+2),a  
3439 18 03			jr .pastdmark  
343b ..			.dmark: db "UNT"  
343e f1			.pastdmark: pop af  
343f			endm  
# End of macro DMARK
343f						CALLMONITOR 
343f cd 5a 17			call break_point_state  
3442				endm  
# End of macro CALLMONITOR
3442					endif 
3442			 
3442			;	push hl 
3442				FORTH_DSP_POP 
3442 cd 99 1f			call macro_forth_dsp_pop 
3445				endm 
# End of macro FORTH_DSP_POP
3445			 
3445			;	pop hl 
3445			 
3445				; test if true 
3445			 
3445 cd 46 0d			call ishlzero 
3448			;	ld a,l 
3448			;	add h 
3448			; 
3448			;	cp 0 
3448			 
3448 20 3e			jr nz, .untilnotdone 
344a			 
344a					if DEBUG_FORTH_WORDS 
344a						DMARK "UNf" 
344a f5				push af  
344b 3a 5f 34			ld a, (.dmark)  
344e 32 77 fb			ld (debug_mark),a  
3451 3a 60 34			ld a, (.dmark+1)  
3454 32 78 fb			ld (debug_mark+1),a  
3457 3a 61 34			ld a, (.dmark+2)  
345a 32 79 fb			ld (debug_mark+2),a  
345d 18 03			jr .pastdmark  
345f ..			.dmark: db "UNf"  
3462 f1			.pastdmark: pop af  
3463			endm  
# End of macro DMARK
3463						CALLMONITOR 
3463 cd 5a 17			call break_point_state  
3466				endm  
# End of macro CALLMONITOR
3466					endif 
3466			 
3466			 
3466			 
3466				FORTH_RSP_POP     ; get rid of DO ptr 
3466 cd b2 1c			call macro_forth_rsp_pop 
3469				endm 
# End of macro FORTH_RSP_POP
3469			 
3469			if DEBUG_FORTH_WORDS 
3469						DMARK "UN>" 
3469 f5				push af  
346a 3a 7e 34			ld a, (.dmark)  
346d 32 77 fb			ld (debug_mark),a  
3470 3a 7f 34			ld a, (.dmark+1)  
3473 32 78 fb			ld (debug_mark+1),a  
3476 3a 80 34			ld a, (.dmark+2)  
3479 32 79 fb			ld (debug_mark+2),a  
347c 18 03			jr .pastdmark  
347e ..			.dmark: db "UN>"  
3481 f1			.pastdmark: pop af  
3482			endm  
# End of macro DMARK
3482				CALLMONITOR 
3482 cd 5a 17			call break_point_state  
3485				endm  
# End of macro CALLMONITOR
3485			endif 
3485			 
3485					NEXTW 
3485 c3 53 20			jp macro_next 
3488				endm 
# End of macro NEXTW
3488				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3488			 
3488			.untilnotdone: 
3488			 
3488			 
3488			;	; get DO ptr 
3488			; 
3488				FORTH_RSP_TOS 
3488 cd a8 1c			call macro_forth_rsp_tos 
348b				endm 
# End of macro FORTH_RSP_TOS
348b			 
348b				;push hl 
348b			 
348b				; not going to DO any more 
348b				; get rid of the RSP pointer as DO will add it back in 
348b				;FORTH_RSP_POP 
348b				;pop hl 
348b			 
348b			 
348b 22 1e f1			ld (os_tok_ptr), hl 
348e					if DEBUG_FORTH_WORDS 
348e						DMARK "UN<" 
348e f5				push af  
348f 3a a3 34			ld a, (.dmark)  
3492 32 77 fb			ld (debug_mark),a  
3495 3a a4 34			ld a, (.dmark+1)  
3498 32 78 fb			ld (debug_mark+1),a  
349b 3a a5 34			ld a, (.dmark+2)  
349e 32 79 fb			ld (debug_mark+2),a  
34a1 18 03			jr .pastdmark  
34a3 ..			.dmark: db "UN<"  
34a6 f1			.pastdmark: pop af  
34a7			endm  
# End of macro DMARK
34a7					CALLMONITOR 
34a7 cd 5a 17			call break_point_state  
34aa				endm  
# End of macro CALLMONITOR
34aa				endif 
34aa c3 e4 20			jp exec1 
34ad			 
34ad					 
34ad			 
34ad			 
34ad					NEXTW 
34ad c3 53 20			jp macro_next 
34b0				endm 
# End of macro NEXTW
34b0			 
34b0			 
34b0			.ENDFLOW: 
34b0			 
34b0			; eof 
34b0			 
# End of file forth_words_flow.asm
34b0			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
34b0			include "forth_words_logic.asm" 
34b0			 
34b0			; | ## Logic Words 
34b0			 
34b0			.NOT: 
34b0				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
34b0 2d				db WORD_SYS_CORE+25             
34b1 f8 34			dw .IS            
34b3 04				db 3 + 1 
34b4 .. 00			db "NOT",0              
34b8				endm 
# End of macro CWHEAD
34b8			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
34b8					if DEBUG_FORTH_WORDS_KEY 
34b8						DMARK "NOT" 
34b8 f5				push af  
34b9 3a cd 34			ld a, (.dmark)  
34bc 32 77 fb			ld (debug_mark),a  
34bf 3a ce 34			ld a, (.dmark+1)  
34c2 32 78 fb			ld (debug_mark+1),a  
34c5 3a cf 34			ld a, (.dmark+2)  
34c8 32 79 fb			ld (debug_mark+2),a  
34cb 18 03			jr .pastdmark  
34cd ..			.dmark: db "NOT"  
34d0 f1			.pastdmark: pop af  
34d1			endm  
# End of macro DMARK
34d1						CALLMONITOR 
34d1 cd 5a 17			call break_point_state  
34d4				endm  
# End of macro CALLMONITOR
34d4					endif 
34d4					FORTH_DSP 
34d4 cd a7 1e			call macro_forth_dsp 
34d7				endm 
# End of macro FORTH_DSP
34d7 7e					ld a,(hl)	; get type of value on TOS 
34d8 fe 02				cp DS_TYPE_INUM  
34da 28 03				jr z, .noti 
34dc					NEXTW 
34dc c3 53 20			jp macro_next 
34df				endm 
# End of macro NEXTW
34df			.noti:          FORTH_DSP_VALUEHL 
34df cd e1 1e			call macro_dsp_valuehl 
34e2				endm 
# End of macro FORTH_DSP_VALUEHL
34e2			;		push hl 
34e2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34e2 cd 99 1f			call macro_forth_dsp_pop 
34e5				endm 
# End of macro FORTH_DSP_POP
34e5			;		pop hl 
34e5 3e 00				ld a,0 
34e7 bd					cp l 
34e8 28 04				jr z, .not2t 
34ea 2e 00				ld l, 0 
34ec 18 02				jr .notip 
34ee			 
34ee 2e ff		.not2t:		ld l, 255 
34f0			 
34f0 26 00		.notip:		ld h, 0	 
34f2			 
34f2 cd ea 1c				call forth_push_numhl 
34f5					NEXTW 
34f5 c3 53 20			jp macro_next 
34f8				endm 
# End of macro NEXTW
34f8			 
34f8			.IS: 
34f8				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
34f8 2d				db WORD_SYS_CORE+25             
34f9 1e 35			dw .LZERO            
34fb 03				db 2 + 1 
34fc .. 00			db "IS",0              
34ff				endm 
# End of macro CWHEAD
34ff			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
34ff					if DEBUG_FORTH_WORDS_KEY 
34ff						DMARK "IS." 
34ff f5				push af  
3500 3a 14 35			ld a, (.dmark)  
3503 32 77 fb			ld (debug_mark),a  
3506 3a 15 35			ld a, (.dmark+1)  
3509 32 78 fb			ld (debug_mark+1),a  
350c 3a 16 35			ld a, (.dmark+2)  
350f 32 79 fb			ld (debug_mark+2),a  
3512 18 03			jr .pastdmark  
3514 ..			.dmark: db "IS."  
3517 f1			.pastdmark: pop af  
3518			endm  
# End of macro DMARK
3518						CALLMONITOR 
3518 cd 5a 17			call break_point_state  
351b				endm  
# End of macro CALLMONITOR
351b					endif 
351b					NEXTW 
351b c3 53 20			jp macro_next 
351e				endm 
# End of macro NEXTW
351e			.LZERO: 
351e				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
351e 2d				db WORD_SYS_CORE+25             
351f 28 35			dw .TZERO            
3521 03				db 2 + 1 
3522 .. 00			db "0<",0              
3525				endm 
# End of macro CWHEAD
3525			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
3525					NEXTW 
3525 c3 53 20			jp macro_next 
3528				endm 
# End of macro NEXTW
3528			.TZERO: 
3528				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
3528 2e				db WORD_SYS_CORE+26             
3529 6f 35			dw .LESS            
352b 03				db 2 + 1 
352c .. 00			db "0=",0              
352f				endm 
# End of macro CWHEAD
352f			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
352f				; TODO add floating point number detection 
352f					;v5 FORTH_DSP_VALUE 
352f					if DEBUG_FORTH_WORDS_KEY 
352f						DMARK "0=." 
352f f5				push af  
3530 3a 44 35			ld a, (.dmark)  
3533 32 77 fb			ld (debug_mark),a  
3536 3a 45 35			ld a, (.dmark+1)  
3539 32 78 fb			ld (debug_mark+1),a  
353c 3a 46 35			ld a, (.dmark+2)  
353f 32 79 fb			ld (debug_mark+2),a  
3542 18 03			jr .pastdmark  
3544 ..			.dmark: db "0=."  
3547 f1			.pastdmark: pop af  
3548			endm  
# End of macro DMARK
3548						CALLMONITOR 
3548 cd 5a 17			call break_point_state  
354b				endm  
# End of macro CALLMONITOR
354b					endif 
354b					FORTH_DSP 
354b cd a7 1e			call macro_forth_dsp 
354e				endm 
# End of macro FORTH_DSP
354e 7e					ld a,(hl)	; get type of value on TOS 
354f fe 02				cp DS_TYPE_INUM  
3551 28 00				jr z, .tz_inum 
3553			 
3553				if FORTH_ENABLE_FLOATMATH 
3553					jr .tz_done 
3553			 
3553				endif 
3553					 
3553			 
3553			.tz_inum: 
3553					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3553 cd e1 1e			call macro_dsp_valuehl 
3556				endm 
# End of macro FORTH_DSP_VALUEHL
3556			 
3556			;		push hl 
3556			 
3556					; destroy value TOS 
3556			 
3556					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3556 cd 99 1f			call macro_forth_dsp_pop 
3559				endm 
# End of macro FORTH_DSP_POP
3559			 
3559			;		pop hl 
3559			 
3559 3e 00				ld a,0 
355b			 
355b bd					cp l 
355c 20 08				jr nz, .tz_notzero 
355e			 
355e bc					cp h 
355f			 
355f 20 05				jr nz, .tz_notzero 
3561			 
3561			 
3561 21 01 00				ld hl, FORTH_TRUE 
3564 18 03				jr .tz_done 
3566			 
3566 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
3569			 
3569					; push value back onto stack for another op etc 
3569			 
3569			.tz_done: 
3569 cd ea 1c				call forth_push_numhl 
356c			 
356c					NEXTW 
356c c3 53 20			jp macro_next 
356f				endm 
# End of macro NEXTW
356f			.LESS: 
356f				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
356f 2f				db WORD_SYS_CORE+27             
3570 d8 35			dw .GT            
3572 02				db 1 + 1 
3573 .. 00			db "<",0              
3575				endm 
# End of macro CWHEAD
3575			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3575				; TODO add floating point number detection 
3575					if DEBUG_FORTH_WORDS_KEY 
3575						DMARK "LES" 
3575 f5				push af  
3576 3a 8a 35			ld a, (.dmark)  
3579 32 77 fb			ld (debug_mark),a  
357c 3a 8b 35			ld a, (.dmark+1)  
357f 32 78 fb			ld (debug_mark+1),a  
3582 3a 8c 35			ld a, (.dmark+2)  
3585 32 79 fb			ld (debug_mark+2),a  
3588 18 03			jr .pastdmark  
358a ..			.dmark: db "LES"  
358d f1			.pastdmark: pop af  
358e			endm  
# End of macro DMARK
358e						CALLMONITOR 
358e cd 5a 17			call break_point_state  
3591				endm  
# End of macro CALLMONITOR
3591					endif 
3591					FORTH_DSP 
3591 cd a7 1e			call macro_forth_dsp 
3594				endm 
# End of macro FORTH_DSP
3594					;v5 FORTH_DSP_VALUE 
3594 7e					ld a,(hl)	; get type of value on TOS 
3595 fe 02				cp DS_TYPE_INUM  
3597 28 00				jr z, .less_inum 
3599			 
3599				if FORTH_ENABLE_FLOATMATH 
3599					jr .less_done 
3599			 
3599				endif 
3599					 
3599			 
3599			.less_inum: 
3599					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3599 cd e1 1e			call macro_dsp_valuehl 
359c				endm 
# End of macro FORTH_DSP_VALUEHL
359c			 
359c e5					push hl  ; u2 
359d			 
359d					; destroy value TOS 
359d			 
359d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
359d cd 99 1f			call macro_forth_dsp_pop 
35a0				endm 
# End of macro FORTH_DSP_POP
35a0			 
35a0			 
35a0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35a0 cd e1 1e			call macro_dsp_valuehl 
35a3				endm 
# End of macro FORTH_DSP_VALUEHL
35a3			 
35a3 e5					push hl    ; u1 
35a4			 
35a4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35a4 cd 99 1f			call macro_forth_dsp_pop 
35a7				endm 
# End of macro FORTH_DSP_POP
35a7			 
35a7			 
35a7 b7			 or a      ;clear carry flag 
35a8 01 00 00		 ld bc, FORTH_FALSE 
35ab e1			  pop hl    ; u1 
35ac d1			  pop de    ; u2 
35ad ed 52		  sbc hl,de 
35af 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
35b1			 
35b1 01 01 00		 ld bc, FORTH_TRUE 
35b4			.lscont:  
35b4 c5					push bc 
35b5 e1					pop hl 
35b6			 
35b6					if DEBUG_FORTH_WORDS 
35b6						DMARK "LT1" 
35b6 f5				push af  
35b7 3a cb 35			ld a, (.dmark)  
35ba 32 77 fb			ld (debug_mark),a  
35bd 3a cc 35			ld a, (.dmark+1)  
35c0 32 78 fb			ld (debug_mark+1),a  
35c3 3a cd 35			ld a, (.dmark+2)  
35c6 32 79 fb			ld (debug_mark+2),a  
35c9 18 03			jr .pastdmark  
35cb ..			.dmark: db "LT1"  
35ce f1			.pastdmark: pop af  
35cf			endm  
# End of macro DMARK
35cf						CALLMONITOR 
35cf cd 5a 17			call break_point_state  
35d2				endm  
# End of macro CALLMONITOR
35d2					endif 
35d2 cd ea 1c				call forth_push_numhl 
35d5			 
35d5					NEXTW 
35d5 c3 53 20			jp macro_next 
35d8				endm 
# End of macro NEXTW
35d8			.GT: 
35d8				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
35d8 30				db WORD_SYS_CORE+28             
35d9 41 36			dw .EQUAL            
35db 02				db 1 + 1 
35dc .. 00			db ">",0              
35de				endm 
# End of macro CWHEAD
35de			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
35de				; TODO add floating point number detection 
35de					if DEBUG_FORTH_WORDS_KEY 
35de						DMARK "GRT" 
35de f5				push af  
35df 3a f3 35			ld a, (.dmark)  
35e2 32 77 fb			ld (debug_mark),a  
35e5 3a f4 35			ld a, (.dmark+1)  
35e8 32 78 fb			ld (debug_mark+1),a  
35eb 3a f5 35			ld a, (.dmark+2)  
35ee 32 79 fb			ld (debug_mark+2),a  
35f1 18 03			jr .pastdmark  
35f3 ..			.dmark: db "GRT"  
35f6 f1			.pastdmark: pop af  
35f7			endm  
# End of macro DMARK
35f7						CALLMONITOR 
35f7 cd 5a 17			call break_point_state  
35fa				endm  
# End of macro CALLMONITOR
35fa					endif 
35fa					FORTH_DSP 
35fa cd a7 1e			call macro_forth_dsp 
35fd				endm 
# End of macro FORTH_DSP
35fd					;FORTH_DSP_VALUE 
35fd 7e					ld a,(hl)	; get type of value on TOS 
35fe fe 02				cp DS_TYPE_INUM  
3600 28 00				jr z, .gt_inum 
3602			 
3602				if FORTH_ENABLE_FLOATMATH 
3602					jr .gt_done 
3602			 
3602				endif 
3602					 
3602			 
3602			.gt_inum: 
3602					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3602 cd e1 1e			call macro_dsp_valuehl 
3605				endm 
# End of macro FORTH_DSP_VALUEHL
3605			 
3605 e5					push hl  ; u2 
3606			 
3606					; destroy value TOS 
3606			 
3606					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3606 cd 99 1f			call macro_forth_dsp_pop 
3609				endm 
# End of macro FORTH_DSP_POP
3609			 
3609			 
3609					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3609 cd e1 1e			call macro_dsp_valuehl 
360c				endm 
# End of macro FORTH_DSP_VALUEHL
360c			 
360c e5					push hl    ; u1 
360d			 
360d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
360d cd 99 1f			call macro_forth_dsp_pop 
3610				endm 
# End of macro FORTH_DSP_POP
3610			 
3610			 
3610 b7			 or a      ;clear carry flag 
3611 01 00 00		 ld bc, FORTH_FALSE 
3614 e1			  pop hl    ; u1 
3615 d1			  pop de    ; u2 
3616 ed 52		  sbc hl,de 
3618 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
361a			 
361a 01 01 00		 ld bc, FORTH_TRUE 
361d			.gtcont:  
361d c5					push bc 
361e e1					pop hl 
361f			 
361f					if DEBUG_FORTH_WORDS 
361f						DMARK "GT1" 
361f f5				push af  
3620 3a 34 36			ld a, (.dmark)  
3623 32 77 fb			ld (debug_mark),a  
3626 3a 35 36			ld a, (.dmark+1)  
3629 32 78 fb			ld (debug_mark+1),a  
362c 3a 36 36			ld a, (.dmark+2)  
362f 32 79 fb			ld (debug_mark+2),a  
3632 18 03			jr .pastdmark  
3634 ..			.dmark: db "GT1"  
3637 f1			.pastdmark: pop af  
3638			endm  
# End of macro DMARK
3638						CALLMONITOR 
3638 cd 5a 17			call break_point_state  
363b				endm  
# End of macro CALLMONITOR
363b					endif 
363b cd ea 1c				call forth_push_numhl 
363e			 
363e					NEXTW 
363e c3 53 20			jp macro_next 
3641				endm 
# End of macro NEXTW
3641			.EQUAL: 
3641				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3641 31				db WORD_SYS_CORE+29             
3642 ac 36			dw .ENDLOGIC            
3644 02				db 1 + 1 
3645 .. 00			db "=",0              
3647				endm 
# End of macro CWHEAD
3647			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3647				; TODO add floating point number detection 
3647					if DEBUG_FORTH_WORDS_KEY 
3647						DMARK "EQ." 
3647 f5				push af  
3648 3a 5c 36			ld a, (.dmark)  
364b 32 77 fb			ld (debug_mark),a  
364e 3a 5d 36			ld a, (.dmark+1)  
3651 32 78 fb			ld (debug_mark+1),a  
3654 3a 5e 36			ld a, (.dmark+2)  
3657 32 79 fb			ld (debug_mark+2),a  
365a 18 03			jr .pastdmark  
365c ..			.dmark: db "EQ."  
365f f1			.pastdmark: pop af  
3660			endm  
# End of macro DMARK
3660						CALLMONITOR 
3660 cd 5a 17			call break_point_state  
3663				endm  
# End of macro CALLMONITOR
3663					endif 
3663					FORTH_DSP 
3663 cd a7 1e			call macro_forth_dsp 
3666				endm 
# End of macro FORTH_DSP
3666					;v5 FORTH_DSP_VALUE 
3666 7e					ld a,(hl)	; get type of value on TOS 
3667 fe 02				cp DS_TYPE_INUM  
3669 28 00				jr z, .eq_inum 
366b			 
366b				if FORTH_ENABLE_FLOATMATH 
366b					jr .eq_done 
366b			 
366b				endif 
366b					 
366b			 
366b			.eq_inum: 
366b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
366b cd e1 1e			call macro_dsp_valuehl 
366e				endm 
# End of macro FORTH_DSP_VALUEHL
366e			 
366e e5					push hl 
366f			 
366f					; destroy value TOS 
366f			 
366f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
366f cd 99 1f			call macro_forth_dsp_pop 
3672				endm 
# End of macro FORTH_DSP_POP
3672			 
3672			 
3672					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3672 cd e1 1e			call macro_dsp_valuehl 
3675				endm 
# End of macro FORTH_DSP_VALUEHL
3675			 
3675					; one value on hl get other one back 
3675			 
3675 e5					push hl 
3676			 
3676					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3676 cd 99 1f			call macro_forth_dsp_pop 
3679				endm 
# End of macro FORTH_DSP_POP
3679			 
3679 0e 00				ld c, FORTH_FALSE 
367b			 
367b e1					pop hl 
367c d1					pop de 
367d			 
367d 7b					ld a, e 
367e bd					cp l 
367f			 
367f 20 06				jr nz, .eq_done 
3681			 
3681 7a					ld a, d 
3682 bc					cp h 
3683			 
3683 20 02				jr nz, .eq_done 
3685			 
3685 0e 01				ld c, FORTH_TRUE 
3687					 
3687			 
3687			 
3687			.eq_done: 
3687			 
3687					; TODO push value back onto stack for another op etc 
3687			 
3687 26 00				ld h, 0 
3689 69					ld l, c 
368a					if DEBUG_FORTH_WORDS 
368a						DMARK "EQ1" 
368a f5				push af  
368b 3a 9f 36			ld a, (.dmark)  
368e 32 77 fb			ld (debug_mark),a  
3691 3a a0 36			ld a, (.dmark+1)  
3694 32 78 fb			ld (debug_mark+1),a  
3697 3a a1 36			ld a, (.dmark+2)  
369a 32 79 fb			ld (debug_mark+2),a  
369d 18 03			jr .pastdmark  
369f ..			.dmark: db "EQ1"  
36a2 f1			.pastdmark: pop af  
36a3			endm  
# End of macro DMARK
36a3						CALLMONITOR 
36a3 cd 5a 17			call break_point_state  
36a6				endm  
# End of macro CALLMONITOR
36a6					endif 
36a6 cd ea 1c				call forth_push_numhl 
36a9			 
36a9					NEXTW 
36a9 c3 53 20			jp macro_next 
36ac				endm 
# End of macro NEXTW
36ac			 
36ac			 
36ac			.ENDLOGIC: 
36ac			; eof 
36ac			 
36ac			 
# End of file forth_words_logic.asm
36ac			include "forth_words_maths.asm" 
36ac			 
36ac			; | ## Maths Words 
36ac			 
36ac			.PLUS:	 
36ac				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
36ac 15				db WORD_SYS_CORE+1             
36ad ee 36			dw .NEG            
36af 02				db 1 + 1 
36b0 .. 00			db "+",0              
36b2				endm 
# End of macro CWHEAD
36b2			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
36b2					if DEBUG_FORTH_WORDS_KEY 
36b2						DMARK "PLU" 
36b2 f5				push af  
36b3 3a c7 36			ld a, (.dmark)  
36b6 32 77 fb			ld (debug_mark),a  
36b9 3a c8 36			ld a, (.dmark+1)  
36bc 32 78 fb			ld (debug_mark+1),a  
36bf 3a c9 36			ld a, (.dmark+2)  
36c2 32 79 fb			ld (debug_mark+2),a  
36c5 18 03			jr .pastdmark  
36c7 ..			.dmark: db "PLU"  
36ca f1			.pastdmark: pop af  
36cb			endm  
# End of macro DMARK
36cb						CALLMONITOR 
36cb cd 5a 17			call break_point_state  
36ce				endm  
# End of macro CALLMONITOR
36ce					endif 
36ce					; add top two values and push back result 
36ce			 
36ce					;for v5 FORTH_DSP_VALUE 
36ce					FORTH_DSP 
36ce cd a7 1e			call macro_forth_dsp 
36d1				endm 
# End of macro FORTH_DSP
36d1 7e					ld a,(hl)	; get type of value on TOS 
36d2 fe 02				cp DS_TYPE_INUM  
36d4 28 03				jr z, .dot_inum 
36d6			 
36d6					NEXTW 
36d6 c3 53 20			jp macro_next 
36d9				endm 
# End of macro NEXTW
36d9			 
36d9			; float maths 
36d9			 
36d9				if FORTH_ENABLE_FLOATMATH 
36d9						inc hl      ; now at start of numeric as string 
36d9			 
36d9					if DEBUG_FORTH_MATHS 
36d9						DMARK "ADD" 
36d9				CALLMONITOR 
36d9					endif 
36d9			 
36d9					;ld ix, hl 
36d9					call CON 
36d9			 
36d9			 
36d9					push hl 
36d9					 
36d9					 
36d9			 
36d9						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
36d9			 
36d9					; get next number 
36d9			 
36d9						FORTH_DSP_VALUE 
36d9			 
36d9						inc hl      ; now at start of numeric as string 
36d9			 
36d9					;ld ix, hl 
36d9					call CON 
36d9			 
36d9					push hl 
36d9			 
36d9			 
36d9						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36d9			 
36d9						; TODO do add 
36d9			 
36d9						call IADD 
36d9			 
36d9						; TODO get result back as ascii 
36d9			 
36d9						; TODO push result  
36d9			 
36d9			 
36d9			 
36d9						jr .dot_done 
36d9				endif 
36d9			 
36d9			.dot_inum: 
36d9			 
36d9			 
36d9					if DEBUG_FORTH_DOT 
36d9						DMARK "+IT" 
36d9				CALLMONITOR 
36d9					endif 
36d9			 
36d9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36d9 cd e1 1e			call macro_dsp_valuehl 
36dc				endm 
# End of macro FORTH_DSP_VALUEHL
36dc			 
36dc				; TODO add floating point number detection 
36dc			 
36dc e5					push hl 
36dd			 
36dd					; destroy value TOS 
36dd			 
36dd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36dd cd 99 1f			call macro_forth_dsp_pop 
36e0				endm 
# End of macro FORTH_DSP_POP
36e0			 
36e0			 
36e0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36e0 cd e1 1e			call macro_dsp_valuehl 
36e3				endm 
# End of macro FORTH_DSP_VALUEHL
36e3			 
36e3					; one value on hl get other one back 
36e3			 
36e3 d1					pop de 
36e4			 
36e4					; do the add 
36e4			 
36e4 19					add hl,de 
36e5			 
36e5					; save it 
36e5			 
36e5			;		push hl	 
36e5			 
36e5					; 
36e5			 
36e5					; destroy value TOS 
36e5			 
36e5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36e5 cd 99 1f			call macro_forth_dsp_pop 
36e8				endm 
# End of macro FORTH_DSP_POP
36e8			 
36e8					; TODO push value back onto stack for another op etc 
36e8			 
36e8			;		pop hl 
36e8			 
36e8			.dot_done: 
36e8 cd ea 1c				call forth_push_numhl 
36eb			 
36eb					NEXTW 
36eb c3 53 20			jp macro_next 
36ee				endm 
# End of macro NEXTW
36ee			.NEG: 
36ee			 
36ee				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
36ee 17				db WORD_SYS_CORE+3             
36ef 31 37			dw .DIV            
36f1 02				db 1 + 1 
36f2 .. 00			db "-",0              
36f4				endm 
# End of macro CWHEAD
36f4			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
36f4					if DEBUG_FORTH_WORDS_KEY 
36f4						DMARK "SUB" 
36f4 f5				push af  
36f5 3a 09 37			ld a, (.dmark)  
36f8 32 77 fb			ld (debug_mark),a  
36fb 3a 0a 37			ld a, (.dmark+1)  
36fe 32 78 fb			ld (debug_mark+1),a  
3701 3a 0b 37			ld a, (.dmark+2)  
3704 32 79 fb			ld (debug_mark+2),a  
3707 18 03			jr .pastdmark  
3709 ..			.dmark: db "SUB"  
370c f1			.pastdmark: pop af  
370d			endm  
# End of macro DMARK
370d						CALLMONITOR 
370d cd 5a 17			call break_point_state  
3710				endm  
# End of macro CALLMONITOR
3710					endif 
3710			 
3710			 
3710				; TODO add floating point number detection 
3710					; v5 FORTH_DSP_VALUE 
3710					FORTH_DSP 
3710 cd a7 1e			call macro_forth_dsp 
3713				endm 
# End of macro FORTH_DSP
3713 7e					ld a,(hl)	; get type of value on TOS 
3714 fe 02				cp DS_TYPE_INUM  
3716 28 03				jr z, .neg_inum 
3718			 
3718					NEXTW 
3718 c3 53 20			jp macro_next 
371b				endm 
# End of macro NEXTW
371b			 
371b			; float maths 
371b			 
371b				if FORTH_ENABLE_FLOATMATH 
371b					jr .neg_done 
371b			 
371b				endif 
371b					 
371b			 
371b			.neg_inum: 
371b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
371b cd e1 1e			call macro_dsp_valuehl 
371e				endm 
# End of macro FORTH_DSP_VALUEHL
371e			 
371e e5					push hl 
371f			 
371f					; destroy value TOS 
371f			 
371f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
371f cd 99 1f			call macro_forth_dsp_pop 
3722				endm 
# End of macro FORTH_DSP_POP
3722			 
3722			 
3722					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3722 cd e1 1e			call macro_dsp_valuehl 
3725				endm 
# End of macro FORTH_DSP_VALUEHL
3725			 
3725					; one value on hl get other one back 
3725			 
3725 d1					pop de 
3726			 
3726					; do the sub 
3726			;		ex de, hl 
3726			 
3726 ed 52				sbc hl,de 
3728			 
3728					; save it 
3728			 
3728			;		push hl	 
3728			 
3728					; 
3728			 
3728					; destroy value TOS 
3728			 
3728					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3728 cd 99 1f			call macro_forth_dsp_pop 
372b				endm 
# End of macro FORTH_DSP_POP
372b			 
372b					; TODO push value back onto stack for another op etc 
372b			 
372b			;		pop hl 
372b			 
372b cd ea 1c				call forth_push_numhl 
372e			.neg_done: 
372e			 
372e					NEXTW 
372e c3 53 20			jp macro_next 
3731				endm 
# End of macro NEXTW
3731			.DIV: 
3731				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3731 18				db WORD_SYS_CORE+4             
3732 7e 37			dw .MUL            
3734 02				db 1 + 1 
3735 .. 00			db "/",0              
3737				endm 
# End of macro CWHEAD
3737			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3737					if DEBUG_FORTH_WORDS_KEY 
3737						DMARK "DIV" 
3737 f5				push af  
3738 3a 4c 37			ld a, (.dmark)  
373b 32 77 fb			ld (debug_mark),a  
373e 3a 4d 37			ld a, (.dmark+1)  
3741 32 78 fb			ld (debug_mark+1),a  
3744 3a 4e 37			ld a, (.dmark+2)  
3747 32 79 fb			ld (debug_mark+2),a  
374a 18 03			jr .pastdmark  
374c ..			.dmark: db "DIV"  
374f f1			.pastdmark: pop af  
3750			endm  
# End of macro DMARK
3750						CALLMONITOR 
3750 cd 5a 17			call break_point_state  
3753				endm  
# End of macro CALLMONITOR
3753					endif 
3753				; TODO add floating point number detection 
3753					; v5 FORTH_DSP_VALUE 
3753					FORTH_DSP 
3753 cd a7 1e			call macro_forth_dsp 
3756				endm 
# End of macro FORTH_DSP
3756 7e					ld a,(hl)	; get type of value on TOS 
3757 fe 02				cp DS_TYPE_INUM  
3759 28 03				jr z, .div_inum 
375b			 
375b				if FORTH_ENABLE_FLOATMATH 
375b					jr .div_done 
375b			 
375b				endif 
375b					NEXTW 
375b c3 53 20			jp macro_next 
375e				endm 
# End of macro NEXTW
375e			.div_inum: 
375e			 
375e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
375e cd e1 1e			call macro_dsp_valuehl 
3761				endm 
# End of macro FORTH_DSP_VALUEHL
3761			 
3761 e5					push hl    ; to go to bc 
3762			 
3762					; destroy value TOS 
3762			 
3762					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3762 cd 99 1f			call macro_forth_dsp_pop 
3765				endm 
# End of macro FORTH_DSP_POP
3765			 
3765			 
3765					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3765 cd e1 1e			call macro_dsp_valuehl 
3768				endm 
# End of macro FORTH_DSP_VALUEHL
3768			 
3768					; hl to go to de 
3768			 
3768 e5					push hl 
3769			 
3769 c1					pop bc 
376a d1					pop de		 
376b			 
376b			 
376b					if DEBUG_FORTH_MATHS 
376b						DMARK "DIV" 
376b				CALLMONITOR 
376b					endif 
376b					; one value on hl but move to a get other one back 
376b			 
376b			        
376b cd 7a 0c			call Div16 
376e			 
376e			;	push af	 
376e e5				push hl 
376f c5				push bc 
3770			 
3770					if DEBUG_FORTH_MATHS 
3770						DMARK "DI1" 
3770				CALLMONITOR 
3770					endif 
3770			 
3770					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3770 cd 99 1f			call macro_forth_dsp_pop 
3773				endm 
# End of macro FORTH_DSP_POP
3773			 
3773			 
3773			 
3773 e1					pop hl    ; result 
3774			 
3774 cd ea 1c				call forth_push_numhl 
3777			 
3777 e1					pop hl    ; reminder 
3778			;		ld h,0 
3778			;		ld l,d 
3778			 
3778 cd ea 1c				call forth_push_numhl 
377b			.div_done: 
377b					NEXTW 
377b c3 53 20			jp macro_next 
377e				endm 
# End of macro NEXTW
377e			.MUL: 
377e				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
377e 19				db WORD_SYS_CORE+5             
377f c3 37			dw .MIN            
3781 02				db 1 + 1 
3782 .. 00			db "*",0              
3784				endm 
# End of macro CWHEAD
3784			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3784				; TODO add floating point number detection 
3784					if DEBUG_FORTH_WORDS_KEY 
3784						DMARK "MUL" 
3784 f5				push af  
3785 3a 99 37			ld a, (.dmark)  
3788 32 77 fb			ld (debug_mark),a  
378b 3a 9a 37			ld a, (.dmark+1)  
378e 32 78 fb			ld (debug_mark+1),a  
3791 3a 9b 37			ld a, (.dmark+2)  
3794 32 79 fb			ld (debug_mark+2),a  
3797 18 03			jr .pastdmark  
3799 ..			.dmark: db "MUL"  
379c f1			.pastdmark: pop af  
379d			endm  
# End of macro DMARK
379d						CALLMONITOR 
379d cd 5a 17			call break_point_state  
37a0				endm  
# End of macro CALLMONITOR
37a0					endif 
37a0					FORTH_DSP 
37a0 cd a7 1e			call macro_forth_dsp 
37a3				endm 
# End of macro FORTH_DSP
37a3					; v5 FORTH_DSP_VALUE 
37a3 7e					ld a,(hl)	; get type of value on TOS 
37a4 fe 02				cp DS_TYPE_INUM  
37a6 28 03				jr z, .mul_inum 
37a8			 
37a8				if FORTH_ENABLE_FLOATMATH 
37a8					jr .mul_done 
37a8			 
37a8				endif 
37a8			 
37a8					NEXTW 
37a8 c3 53 20			jp macro_next 
37ab				endm 
# End of macro NEXTW
37ab			.mul_inum:	 
37ab			 
37ab					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37ab cd e1 1e			call macro_dsp_valuehl 
37ae				endm 
# End of macro FORTH_DSP_VALUEHL
37ae			 
37ae e5					push hl 
37af			 
37af					; destroy value TOS 
37af			 
37af					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37af cd 99 1f			call macro_forth_dsp_pop 
37b2				endm 
# End of macro FORTH_DSP_POP
37b2			 
37b2			 
37b2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37b2 cd e1 1e			call macro_dsp_valuehl 
37b5				endm 
# End of macro FORTH_DSP_VALUEHL
37b5			 
37b5					; one value on hl but move to a get other one back 
37b5			 
37b5 7d					ld a, l 
37b6			 
37b6 d1					pop de 
37b7			 
37b7					; do the mull 
37b7			;		ex de, hl 
37b7			 
37b7 cd a0 0c				call Mult16 
37ba					; save it 
37ba			 
37ba			;		push hl	 
37ba			 
37ba					; 
37ba			 
37ba					; destroy value TOS 
37ba			 
37ba					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37ba cd 99 1f			call macro_forth_dsp_pop 
37bd				endm 
# End of macro FORTH_DSP_POP
37bd			 
37bd					; TODO push value back onto stack for another op etc 
37bd			 
37bd			;		pop hl 
37bd			 
37bd cd ea 1c				call forth_push_numhl 
37c0			 
37c0			.mul_done: 
37c0					NEXTW 
37c0 c3 53 20			jp macro_next 
37c3				endm 
# End of macro NEXTW
37c3			 
37c3			 
37c3			 
37c3			 
37c3			.MIN: 
37c3				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
37c3 49				db WORD_SYS_CORE+53             
37c4 44 38			dw .MAX            
37c6 04				db 3 + 1 
37c7 .. 00			db "MIN",0              
37cb				endm 
# End of macro CWHEAD
37cb			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
37cb					if DEBUG_FORTH_WORDS_KEY 
37cb						DMARK "MIN" 
37cb f5				push af  
37cc 3a e0 37			ld a, (.dmark)  
37cf 32 77 fb			ld (debug_mark),a  
37d2 3a e1 37			ld a, (.dmark+1)  
37d5 32 78 fb			ld (debug_mark+1),a  
37d8 3a e2 37			ld a, (.dmark+2)  
37db 32 79 fb			ld (debug_mark+2),a  
37de 18 03			jr .pastdmark  
37e0 ..			.dmark: db "MIN"  
37e3 f1			.pastdmark: pop af  
37e4			endm  
# End of macro DMARK
37e4						CALLMONITOR 
37e4 cd 5a 17			call break_point_state  
37e7				endm  
# End of macro CALLMONITOR
37e7					endif 
37e7					; get u2 
37e7			 
37e7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37e7 cd e1 1e			call macro_dsp_valuehl 
37ea				endm 
# End of macro FORTH_DSP_VALUEHL
37ea			 
37ea e5					push hl   ; u2 
37eb			 
37eb					; destroy value TOS 
37eb			 
37eb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37eb cd 99 1f			call macro_forth_dsp_pop 
37ee				endm 
# End of macro FORTH_DSP_POP
37ee			 
37ee					; get u1 
37ee			 
37ee					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37ee cd e1 1e			call macro_dsp_valuehl 
37f1				endm 
# End of macro FORTH_DSP_VALUEHL
37f1			 
37f1 e5					push hl  ; u1 
37f2			 
37f2					; destroy value TOS 
37f2			 
37f2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37f2 cd 99 1f			call macro_forth_dsp_pop 
37f5				endm 
# End of macro FORTH_DSP_POP
37f5			 
37f5 b7			 or a      ;clear carry flag 
37f6 e1			  pop hl    ; u1 
37f7 d1			  pop de    ; u2 
37f8 e5				push hl   ; saved in case hl is lowest 
37f9 ed 52		  sbc hl,de 
37fb 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
37fd			 
37fd e1				pop hl 
37fe					if DEBUG_FORTH_WORDS 
37fe						DMARK "MIN" 
37fe f5				push af  
37ff 3a 13 38			ld a, (.dmark)  
3802 32 77 fb			ld (debug_mark),a  
3805 3a 14 38			ld a, (.dmark+1)  
3808 32 78 fb			ld (debug_mark+1),a  
380b 3a 15 38			ld a, (.dmark+2)  
380e 32 79 fb			ld (debug_mark+2),a  
3811 18 03			jr .pastdmark  
3813 ..			.dmark: db "MIN"  
3816 f1			.pastdmark: pop af  
3817			endm  
# End of macro DMARK
3817						CALLMONITOR 
3817 cd 5a 17			call break_point_state  
381a				endm  
# End of macro CALLMONITOR
381a					endif 
381a cd ea 1c				call forth_push_numhl 
381d			 
381d				       NEXTW 
381d c3 53 20			jp macro_next 
3820				endm 
# End of macro NEXTW
3820			 
3820			.mincont:  
3820 c1				pop bc   ; tidy up 
3821 eb				ex de , hl  
3822					if DEBUG_FORTH_WORDS 
3822						DMARK "MI1" 
3822 f5				push af  
3823 3a 37 38			ld a, (.dmark)  
3826 32 77 fb			ld (debug_mark),a  
3829 3a 38 38			ld a, (.dmark+1)  
382c 32 78 fb			ld (debug_mark+1),a  
382f 3a 39 38			ld a, (.dmark+2)  
3832 32 79 fb			ld (debug_mark+2),a  
3835 18 03			jr .pastdmark  
3837 ..			.dmark: db "MI1"  
383a f1			.pastdmark: pop af  
383b			endm  
# End of macro DMARK
383b						CALLMONITOR 
383b cd 5a 17			call break_point_state  
383e				endm  
# End of macro CALLMONITOR
383e					endif 
383e cd ea 1c				call forth_push_numhl 
3841			 
3841				       NEXTW 
3841 c3 53 20			jp macro_next 
3844				endm 
# End of macro NEXTW
3844			.MAX: 
3844				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3844 4a				db WORD_SYS_CORE+54             
3845 c5 38			dw .RND16            
3847 04				db 3 + 1 
3848 .. 00			db "MAX",0              
384c				endm 
# End of macro CWHEAD
384c			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
384c					if DEBUG_FORTH_WORDS_KEY 
384c						DMARK "MAX" 
384c f5				push af  
384d 3a 61 38			ld a, (.dmark)  
3850 32 77 fb			ld (debug_mark),a  
3853 3a 62 38			ld a, (.dmark+1)  
3856 32 78 fb			ld (debug_mark+1),a  
3859 3a 63 38			ld a, (.dmark+2)  
385c 32 79 fb			ld (debug_mark+2),a  
385f 18 03			jr .pastdmark  
3861 ..			.dmark: db "MAX"  
3864 f1			.pastdmark: pop af  
3865			endm  
# End of macro DMARK
3865						CALLMONITOR 
3865 cd 5a 17			call break_point_state  
3868				endm  
# End of macro CALLMONITOR
3868					endif 
3868					; get u2 
3868			 
3868					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3868 cd e1 1e			call macro_dsp_valuehl 
386b				endm 
# End of macro FORTH_DSP_VALUEHL
386b			 
386b e5					push hl   ; u2 
386c			 
386c					; destroy value TOS 
386c			 
386c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
386c cd 99 1f			call macro_forth_dsp_pop 
386f				endm 
# End of macro FORTH_DSP_POP
386f			 
386f					; get u1 
386f			 
386f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
386f cd e1 1e			call macro_dsp_valuehl 
3872				endm 
# End of macro FORTH_DSP_VALUEHL
3872			 
3872 e5					push hl  ; u1 
3873			 
3873					; destroy value TOS 
3873			 
3873					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3873 cd 99 1f			call macro_forth_dsp_pop 
3876				endm 
# End of macro FORTH_DSP_POP
3876			 
3876 b7			 or a      ;clear carry flag 
3877 e1			  pop hl    ; u1 
3878 d1			  pop de    ; u2 
3879 e5				push hl   ; saved in case hl is lowest 
387a ed 52		  sbc hl,de 
387c 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
387e			 
387e e1				pop hl 
387f					if DEBUG_FORTH_WORDS 
387f						DMARK "MAX" 
387f f5				push af  
3880 3a 94 38			ld a, (.dmark)  
3883 32 77 fb			ld (debug_mark),a  
3886 3a 95 38			ld a, (.dmark+1)  
3889 32 78 fb			ld (debug_mark+1),a  
388c 3a 96 38			ld a, (.dmark+2)  
388f 32 79 fb			ld (debug_mark+2),a  
3892 18 03			jr .pastdmark  
3894 ..			.dmark: db "MAX"  
3897 f1			.pastdmark: pop af  
3898			endm  
# End of macro DMARK
3898						CALLMONITOR 
3898 cd 5a 17			call break_point_state  
389b				endm  
# End of macro CALLMONITOR
389b					endif 
389b cd ea 1c				call forth_push_numhl 
389e			 
389e				       NEXTW 
389e c3 53 20			jp macro_next 
38a1				endm 
# End of macro NEXTW
38a1			 
38a1			.maxcont:  
38a1 c1				pop bc   ; tidy up 
38a2 eb				ex de , hl  
38a3					if DEBUG_FORTH_WORDS 
38a3						DMARK "MA1" 
38a3 f5				push af  
38a4 3a b8 38			ld a, (.dmark)  
38a7 32 77 fb			ld (debug_mark),a  
38aa 3a b9 38			ld a, (.dmark+1)  
38ad 32 78 fb			ld (debug_mark+1),a  
38b0 3a ba 38			ld a, (.dmark+2)  
38b3 32 79 fb			ld (debug_mark+2),a  
38b6 18 03			jr .pastdmark  
38b8 ..			.dmark: db "MA1"  
38bb f1			.pastdmark: pop af  
38bc			endm  
# End of macro DMARK
38bc						CALLMONITOR 
38bc cd 5a 17			call break_point_state  
38bf				endm  
# End of macro CALLMONITOR
38bf					endif 
38bf cd ea 1c				call forth_push_numhl 
38c2				       NEXTW 
38c2 c3 53 20			jp macro_next 
38c5				endm 
# End of macro NEXTW
38c5			 
38c5			.RND16: 
38c5				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
38c5 4e				db WORD_SYS_CORE+58             
38c6 f4 38			dw .RND8            
38c8 06				db 5 + 1 
38c9 .. 00			db "RND16",0              
38cf				endm 
# End of macro CWHEAD
38cf			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
38cf					if DEBUG_FORTH_WORDS_KEY 
38cf						DMARK "R16" 
38cf f5				push af  
38d0 3a e4 38			ld a, (.dmark)  
38d3 32 77 fb			ld (debug_mark),a  
38d6 3a e5 38			ld a, (.dmark+1)  
38d9 32 78 fb			ld (debug_mark+1),a  
38dc 3a e6 38			ld a, (.dmark+2)  
38df 32 79 fb			ld (debug_mark+2),a  
38e2 18 03			jr .pastdmark  
38e4 ..			.dmark: db "R16"  
38e7 f1			.pastdmark: pop af  
38e8			endm  
# End of macro DMARK
38e8						CALLMONITOR 
38e8 cd 5a 17			call break_point_state  
38eb				endm  
# End of macro CALLMONITOR
38eb					endif 
38eb cd 44 0c				call prng16  
38ee cd ea 1c				call forth_push_numhl 
38f1				       NEXTW 
38f1 c3 53 20			jp macro_next 
38f4				endm 
# End of macro NEXTW
38f4			.RND8: 
38f4				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
38f4 60				db WORD_SYS_CORE+76             
38f5 29 39			dw .RND            
38f7 05				db 4 + 1 
38f8 .. 00			db "RND8",0              
38fd				endm 
# End of macro CWHEAD
38fd			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
38fd					if DEBUG_FORTH_WORDS_KEY 
38fd						DMARK "RN8" 
38fd f5				push af  
38fe 3a 12 39			ld a, (.dmark)  
3901 32 77 fb			ld (debug_mark),a  
3904 3a 13 39			ld a, (.dmark+1)  
3907 32 78 fb			ld (debug_mark+1),a  
390a 3a 14 39			ld a, (.dmark+2)  
390d 32 79 fb			ld (debug_mark+2),a  
3910 18 03			jr .pastdmark  
3912 ..			.dmark: db "RN8"  
3915 f1			.pastdmark: pop af  
3916			endm  
# End of macro DMARK
3916						CALLMONITOR 
3916 cd 5a 17			call break_point_state  
3919				endm  
# End of macro CALLMONITOR
3919					endif 
3919 2a b8 f8				ld hl,(xrandc) 
391c 23					inc hl 
391d cd 5e 0c				call xrnd 
3920 6f					ld l,a	 
3921 26 00				ld h,0 
3923 cd ea 1c				call forth_push_numhl 
3926				       NEXTW 
3926 c3 53 20			jp macro_next 
3929				endm 
# End of macro NEXTW
3929			.RND: 
3929				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3929 60				db WORD_SYS_CORE+76             
392a 2f 3a			dw .ENDMATHS            
392c 04				db 3 + 1 
392d .. 00			db "RND",0              
3931				endm 
# End of macro CWHEAD
3931			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3931			 
3931					if DEBUG_FORTH_WORDS_KEY 
3931						DMARK "RND" 
3931 f5				push af  
3932 3a 46 39			ld a, (.dmark)  
3935 32 77 fb			ld (debug_mark),a  
3938 3a 47 39			ld a, (.dmark+1)  
393b 32 78 fb			ld (debug_mark+1),a  
393e 3a 48 39			ld a, (.dmark+2)  
3941 32 79 fb			ld (debug_mark+2),a  
3944 18 03			jr .pastdmark  
3946 ..			.dmark: db "RND"  
3949 f1			.pastdmark: pop af  
394a			endm  
# End of macro DMARK
394a						CALLMONITOR 
394a cd 5a 17			call break_point_state  
394d				endm  
# End of macro CALLMONITOR
394d					endif 
394d					 
394d					FORTH_DSP_VALUEHL    ; upper range 
394d cd e1 1e			call macro_dsp_valuehl 
3950				endm 
# End of macro FORTH_DSP_VALUEHL
3950			 
3950 22 bc f8				ld (LFSRSeed), hl	 
3953			 
3953					if DEBUG_FORTH_WORDS 
3953						DMARK "RN1" 
3953 f5				push af  
3954 3a 68 39			ld a, (.dmark)  
3957 32 77 fb			ld (debug_mark),a  
395a 3a 69 39			ld a, (.dmark+1)  
395d 32 78 fb			ld (debug_mark+1),a  
3960 3a 6a 39			ld a, (.dmark+2)  
3963 32 79 fb			ld (debug_mark+2),a  
3966 18 03			jr .pastdmark  
3968 ..			.dmark: db "RN1"  
396b f1			.pastdmark: pop af  
396c			endm  
# End of macro DMARK
396c						CALLMONITOR 
396c cd 5a 17			call break_point_state  
396f				endm  
# End of macro CALLMONITOR
396f					endif 
396f					FORTH_DSP_POP 
396f cd 99 1f			call macro_forth_dsp_pop 
3972				endm 
# End of macro FORTH_DSP_POP
3972			 
3972					FORTH_DSP_VALUEHL    ; low range 
3972 cd e1 1e			call macro_dsp_valuehl 
3975				endm 
# End of macro FORTH_DSP_VALUEHL
3975			 
3975					if DEBUG_FORTH_WORDS 
3975						DMARK "RN2" 
3975 f5				push af  
3976 3a 8a 39			ld a, (.dmark)  
3979 32 77 fb			ld (debug_mark),a  
397c 3a 8b 39			ld a, (.dmark+1)  
397f 32 78 fb			ld (debug_mark+1),a  
3982 3a 8c 39			ld a, (.dmark+2)  
3985 32 79 fb			ld (debug_mark+2),a  
3988 18 03			jr .pastdmark  
398a ..			.dmark: db "RN2"  
398d f1			.pastdmark: pop af  
398e			endm  
# End of macro DMARK
398e						CALLMONITOR 
398e cd 5a 17			call break_point_state  
3991				endm  
# End of macro CALLMONITOR
3991					endif 
3991 22 be f8				ld (LFSRSeed+2), hl 
3994			 
3994					FORTH_DSP_POP 
3994 cd 99 1f			call macro_forth_dsp_pop 
3997				endm 
# End of macro FORTH_DSP_POP
3997			 
3997 e5					push hl 
3998			 
3998 e1			.inrange:	pop hl 
3999 cd 44 0c				call prng16  
399c					if DEBUG_FORTH_WORDS 
399c						DMARK "RN3" 
399c f5				push af  
399d 3a b1 39			ld a, (.dmark)  
39a0 32 77 fb			ld (debug_mark),a  
39a3 3a b2 39			ld a, (.dmark+1)  
39a6 32 78 fb			ld (debug_mark+1),a  
39a9 3a b3 39			ld a, (.dmark+2)  
39ac 32 79 fb			ld (debug_mark+2),a  
39af 18 03			jr .pastdmark  
39b1 ..			.dmark: db "RN3"  
39b4 f1			.pastdmark: pop af  
39b5			endm  
# End of macro DMARK
39b5						CALLMONITOR 
39b5 cd 5a 17			call break_point_state  
39b8				endm  
# End of macro CALLMONITOR
39b8					endif 
39b8					 
39b8					; if the range is 8bit knock out the high byte 
39b8			 
39b8 ed 5b bc f8			ld de, (LFSRSeed)     ; check high level 
39bc			 
39bc 3e 00				ld a, 0 
39be ba					cp d  
39bf 20 1e				jr nz, .hirange 
39c1 26 00				ld h, 0   ; knock it down to 8bit 
39c3			 
39c3					if DEBUG_FORTH_WORDS 
39c3						DMARK "RNk" 
39c3 f5				push af  
39c4 3a d8 39			ld a, (.dmark)  
39c7 32 77 fb			ld (debug_mark),a  
39ca 3a d9 39			ld a, (.dmark+1)  
39cd 32 78 fb			ld (debug_mark+1),a  
39d0 3a da 39			ld a, (.dmark+2)  
39d3 32 79 fb			ld (debug_mark+2),a  
39d6 18 03			jr .pastdmark  
39d8 ..			.dmark: db "RNk"  
39db f1			.pastdmark: pop af  
39dc			endm  
# End of macro DMARK
39dc						CALLMONITOR 
39dc cd 5a 17			call break_point_state  
39df				endm  
# End of macro CALLMONITOR
39df					endif 
39df			.hirange:   
39df e5					push hl  
39e0 b7					or a  
39e1 ed 52		                sbc hl, de 
39e3			 
39e3					;call cmp16 
39e3			 
39e3 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
39e5 e1					pop hl 
39e6 e5					push hl 
39e7			 
39e7					if DEBUG_FORTH_WORDS 
39e7						DMARK "RN4" 
39e7 f5				push af  
39e8 3a fc 39			ld a, (.dmark)  
39eb 32 77 fb			ld (debug_mark),a  
39ee 3a fd 39			ld a, (.dmark+1)  
39f1 32 78 fb			ld (debug_mark+1),a  
39f4 3a fe 39			ld a, (.dmark+2)  
39f7 32 79 fb			ld (debug_mark+2),a  
39fa 18 03			jr .pastdmark  
39fc ..			.dmark: db "RN4"  
39ff f1			.pastdmark: pop af  
3a00			endm  
# End of macro DMARK
3a00						CALLMONITOR 
3a00 cd 5a 17			call break_point_state  
3a03				endm  
# End of macro CALLMONITOR
3a03					endif 
3a03 ed 5b be f8			ld de, (LFSRSeed+2)   ; check low range 
3a07					;call cmp16 
3a07				 
3a07 b7					or a  
3a08 ed 52		                sbc hl, de 
3a0a 38 8c				jr c, .inrange 
3a0c			 
3a0c e1					pop hl 
3a0d					 
3a0d					if DEBUG_FORTH_WORDS 
3a0d						DMARK "RNd" 
3a0d f5				push af  
3a0e 3a 22 3a			ld a, (.dmark)  
3a11 32 77 fb			ld (debug_mark),a  
3a14 3a 23 3a			ld a, (.dmark+1)  
3a17 32 78 fb			ld (debug_mark+1),a  
3a1a 3a 24 3a			ld a, (.dmark+2)  
3a1d 32 79 fb			ld (debug_mark+2),a  
3a20 18 03			jr .pastdmark  
3a22 ..			.dmark: db "RNd"  
3a25 f1			.pastdmark: pop af  
3a26			endm  
# End of macro DMARK
3a26						CALLMONITOR 
3a26 cd 5a 17			call break_point_state  
3a29				endm  
# End of macro CALLMONITOR
3a29					endif 
3a29			 
3a29			 
3a29 cd ea 1c				call forth_push_numhl 
3a2c				       NEXTW 
3a2c c3 53 20			jp macro_next 
3a2f				endm 
# End of macro NEXTW
3a2f			 
3a2f			.ENDMATHS: 
3a2f			 
3a2f			; eof 
3a2f			 
# End of file forth_words_maths.asm
3a2f			include "forth_words_display.asm" 
3a2f			 
3a2f			; | ## Display Words 
3a2f			 
3a2f			.ATP: 
3a2f				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3a2f 62				db WORD_SYS_CORE+78             
3a30 a6 3a			dw .FB            
3a32 04				db 3 + 1 
3a33 .. 00			db "AT?",0              
3a37				endm 
# End of macro CWHEAD
3a37			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3a37					if DEBUG_FORTH_WORDS_KEY 
3a37						DMARK "AT?" 
3a37 f5				push af  
3a38 3a 4c 3a			ld a, (.dmark)  
3a3b 32 77 fb			ld (debug_mark),a  
3a3e 3a 4d 3a			ld a, (.dmark+1)  
3a41 32 78 fb			ld (debug_mark+1),a  
3a44 3a 4e 3a			ld a, (.dmark+2)  
3a47 32 79 fb			ld (debug_mark+2),a  
3a4a 18 03			jr .pastdmark  
3a4c ..			.dmark: db "AT?"  
3a4f f1			.pastdmark: pop af  
3a50			endm  
# End of macro DMARK
3a50						CALLMONITOR 
3a50 cd 5a 17			call break_point_state  
3a53				endm  
# End of macro CALLMONITOR
3a53					endif 
3a53 3a 46 f8				ld a, (f_cursor_ptr) 
3a56			 
3a56			if DEBUG_FORTH_WORDS 
3a56				DMARK "AT?" 
3a56 f5				push af  
3a57 3a 6b 3a			ld a, (.dmark)  
3a5a 32 77 fb			ld (debug_mark),a  
3a5d 3a 6c 3a			ld a, (.dmark+1)  
3a60 32 78 fb			ld (debug_mark+1),a  
3a63 3a 6d 3a			ld a, (.dmark+2)  
3a66 32 79 fb			ld (debug_mark+2),a  
3a69 18 03			jr .pastdmark  
3a6b ..			.dmark: db "AT?"  
3a6e f1			.pastdmark: pop af  
3a6f			endm  
# End of macro DMARK
3a6f				CALLMONITOR 
3a6f cd 5a 17			call break_point_state  
3a72				endm  
# End of macro CALLMONITOR
3a72			endif	 
3a72					; count the number of rows 
3a72			 
3a72 06 00				ld b, 0 
3a74 4f			.atpr:		ld c, a    ; save in case we go below zero 
3a75 d6 28				sub display_cols 
3a77 f2 7d 3a				jp p, .atprunder 
3a7a 04					inc b 
3a7b 18 f7				jr .atpr 
3a7d			.atprunder:	 
3a7d			if DEBUG_FORTH_WORDS 
3a7d				DMARK "A?2" 
3a7d f5				push af  
3a7e 3a 92 3a			ld a, (.dmark)  
3a81 32 77 fb			ld (debug_mark),a  
3a84 3a 93 3a			ld a, (.dmark+1)  
3a87 32 78 fb			ld (debug_mark+1),a  
3a8a 3a 94 3a			ld a, (.dmark+2)  
3a8d 32 79 fb			ld (debug_mark+2),a  
3a90 18 03			jr .pastdmark  
3a92 ..			.dmark: db "A?2"  
3a95 f1			.pastdmark: pop af  
3a96			endm  
# End of macro DMARK
3a96				CALLMONITOR 
3a96 cd 5a 17			call break_point_state  
3a99				endm  
# End of macro CALLMONITOR
3a99			endif	 
3a99 26 00				ld h, 0 
3a9b 69					ld l, c 
3a9c cd ea 1c				call forth_push_numhl 
3a9f 68					ld l, b  
3aa0 cd ea 1c				call forth_push_numhl 
3aa3			 
3aa3			 
3aa3				NEXTW 
3aa3 c3 53 20			jp macro_next 
3aa6				endm 
# End of macro NEXTW
3aa6			 
3aa6			.FB: 
3aa6				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3aa6 1b				db WORD_SYS_CORE+7             
3aa7 f4 3a			dw .EMIT            
3aa9 03				db 2 + 1 
3aaa .. 00			db "FB",0              
3aad				endm 
# End of macro CWHEAD
3aad			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3aad			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3aad			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3aad			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3aad					if DEBUG_FORTH_WORDS_KEY 
3aad						DMARK "FB." 
3aad f5				push af  
3aae 3a c2 3a			ld a, (.dmark)  
3ab1 32 77 fb			ld (debug_mark),a  
3ab4 3a c3 3a			ld a, (.dmark+1)  
3ab7 32 78 fb			ld (debug_mark+1),a  
3aba 3a c4 3a			ld a, (.dmark+2)  
3abd 32 79 fb			ld (debug_mark+2),a  
3ac0 18 03			jr .pastdmark  
3ac2 ..			.dmark: db "FB."  
3ac5 f1			.pastdmark: pop af  
3ac6			endm  
# End of macro DMARK
3ac6						CALLMONITOR 
3ac6 cd 5a 17			call break_point_state  
3ac9				endm  
# End of macro CALLMONITOR
3ac9					endif 
3ac9			 
3ac9					FORTH_DSP_VALUEHL 
3ac9 cd e1 1e			call macro_dsp_valuehl 
3acc				endm 
# End of macro FORTH_DSP_VALUEHL
3acc			 
3acc 7d					ld a, l 
3acd fe 01				cp 1 
3acf 20 05				jr nz, .fbn1 
3ad1 21 1c fa				ld hl, display_fb1 
3ad4 18 15				jr .fbset 
3ad6 fe 02		.fbn1:		cp 2 
3ad8 20 05				jr nz, .fbn2 
3ada 21 da f8				ld hl, display_fb2 
3add 18 0c				jr .fbset 
3adf fe 03		.fbn2:		cp 3 
3ae1 20 05				jr nz, .fbn3 
3ae3 21 7b f9				ld hl, display_fb3 
3ae6 18 03				jr .fbset 
3ae8			.fbn3:		 ; if invalid number select first 
3ae8 21 1c fa				ld hl, display_fb1 
3aeb 22 d8 f8		.fbset:		ld (display_fb_active), hl 
3aee			 
3aee					FORTH_DSP_POP 
3aee cd 99 1f			call macro_forth_dsp_pop 
3af1				endm 
# End of macro FORTH_DSP_POP
3af1			 
3af1					NEXTW 
3af1 c3 53 20			jp macro_next 
3af4				endm 
# End of macro NEXTW
3af4			 
3af4			 
3af4			.EMIT: 
3af4				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3af4 1b				db WORD_SYS_CORE+7             
3af5 45 3b			dw .DOTH            
3af7 05				db 4 + 1 
3af8 .. 00			db "EMIT",0              
3afd				endm 
# End of macro CWHEAD
3afd			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3afd					; get value off TOS and display it 
3afd			 
3afd					if DEBUG_FORTH_WORDS_KEY 
3afd						DMARK "EMT" 
3afd f5				push af  
3afe 3a 12 3b			ld a, (.dmark)  
3b01 32 77 fb			ld (debug_mark),a  
3b04 3a 13 3b			ld a, (.dmark+1)  
3b07 32 78 fb			ld (debug_mark+1),a  
3b0a 3a 14 3b			ld a, (.dmark+2)  
3b0d 32 79 fb			ld (debug_mark+2),a  
3b10 18 03			jr .pastdmark  
3b12 ..			.dmark: db "EMT"  
3b15 f1			.pastdmark: pop af  
3b16			endm  
# End of macro DMARK
3b16						CALLMONITOR 
3b16 cd 5a 17			call break_point_state  
3b19				endm  
# End of macro CALLMONITOR
3b19					endif 
3b19			 
3b19					FORTH_DSP_VALUEHL 
3b19 cd e1 1e			call macro_dsp_valuehl 
3b1c				endm 
# End of macro FORTH_DSP_VALUEHL
3b1c			 
3b1c 7d					ld a,l 
3b1d			 
3b1d					; TODO write to display 
3b1d			 
3b1d 32 1b f0				ld (os_input), a 
3b20 3e 00				ld a, 0 
3b22 32 1c f0				ld (os_input+1), a 
3b25					 
3b25 3a 46 f8				ld a, (f_cursor_ptr) 
3b28 11 1b f0				ld de, os_input 
3b2b cd fc 0a				call str_at_display 
3b2e			 
3b2e			 
3b2e 3a 24 f8				ld a,(cli_autodisplay) 
3b31 fe 00				cp 0 
3b33 28 03				jr z, .enoupdate 
3b35 cd 0c 0b						call update_display 
3b38					.enoupdate: 
3b38			 
3b38 3a 46 f8				ld a, (f_cursor_ptr) 
3b3b 3c					inc a 
3b3c 32 46 f8				ld (f_cursor_ptr), a   ; save new pos 
3b3f			 
3b3f			 
3b3f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b3f cd 99 1f			call macro_forth_dsp_pop 
3b42				endm 
# End of macro FORTH_DSP_POP
3b42			  
3b42			 
3b42					NEXTW 
3b42 c3 53 20			jp macro_next 
3b45				endm 
# End of macro NEXTW
3b45			.DOTH: 
3b45				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3b45 1c				db WORD_SYS_CORE+8             
3b46 75 3b			dw .DOTF            
3b48 03				db 2 + 1 
3b49 .. 00			db ".-",0              
3b4c				endm 
# End of macro CWHEAD
3b4c			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3b4c					; get value off TOS and display it 
3b4c					if DEBUG_FORTH_WORDS_KEY 
3b4c						DMARK "DTD" 
3b4c f5				push af  
3b4d 3a 61 3b			ld a, (.dmark)  
3b50 32 77 fb			ld (debug_mark),a  
3b53 3a 62 3b			ld a, (.dmark+1)  
3b56 32 78 fb			ld (debug_mark+1),a  
3b59 3a 63 3b			ld a, (.dmark+2)  
3b5c 32 79 fb			ld (debug_mark+2),a  
3b5f 18 03			jr .pastdmark  
3b61 ..			.dmark: db "DTD"  
3b64 f1			.pastdmark: pop af  
3b65			endm  
# End of macro DMARK
3b65						CALLMONITOR 
3b65 cd 5a 17			call break_point_state  
3b68				endm  
# End of macro CALLMONITOR
3b68					endif 
3b68 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3b6a 3e 00			ld a, 0 
3b6c 32 25 f8			ld (cli_mvdot), a 
3b6f c3 cc 3b			jp .dotgo 
3b72				NEXTW 
3b72 c3 53 20			jp macro_next 
3b75				endm 
# End of macro NEXTW
3b75			.DOTF: 
3b75				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3b75 1c				db WORD_SYS_CORE+8             
3b76 a3 3b			dw .DOT            
3b78 03				db 2 + 1 
3b79 .. 00			db ".>",0              
3b7c				endm 
# End of macro CWHEAD
3b7c			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3b7c					; get value off TOS and display it 
3b7c			        ; TODO BUG adds extra spaces 
3b7c			        ; TODO BUG handle numerics? 
3b7c					if DEBUG_FORTH_WORDS_KEY 
3b7c						DMARK "DTC" 
3b7c f5				push af  
3b7d 3a 91 3b			ld a, (.dmark)  
3b80 32 77 fb			ld (debug_mark),a  
3b83 3a 92 3b			ld a, (.dmark+1)  
3b86 32 78 fb			ld (debug_mark+1),a  
3b89 3a 93 3b			ld a, (.dmark+2)  
3b8c 32 79 fb			ld (debug_mark+2),a  
3b8f 18 03			jr .pastdmark  
3b91 ..			.dmark: db "DTC"  
3b94 f1			.pastdmark: pop af  
3b95			endm  
# End of macro DMARK
3b95						CALLMONITOR 
3b95 cd 5a 17			call break_point_state  
3b98				endm  
# End of macro CALLMONITOR
3b98					endif 
3b98 3e 01			ld a, 1 
3b9a 32 25 f8			ld (cli_mvdot), a 
3b9d c3 cc 3b			jp .dotgo 
3ba0				NEXTW 
3ba0 c3 53 20			jp macro_next 
3ba3				endm 
# End of macro NEXTW
3ba3			 
3ba3			.DOT: 
3ba3				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3ba3 1c				db WORD_SYS_CORE+8             
3ba4 2f 3c			dw .CLS            
3ba6 02				db 1 + 1 
3ba7 .. 00			db ".",0              
3ba9				endm 
# End of macro CWHEAD
3ba9			        ; | . ( u -- ) Display TOS | DONE 
3ba9					; get value off TOS and display it 
3ba9			 
3ba9					if DEBUG_FORTH_WORDS_KEY 
3ba9						DMARK "DOT" 
3ba9 f5				push af  
3baa 3a be 3b			ld a, (.dmark)  
3bad 32 77 fb			ld (debug_mark),a  
3bb0 3a bf 3b			ld a, (.dmark+1)  
3bb3 32 78 fb			ld (debug_mark+1),a  
3bb6 3a c0 3b			ld a, (.dmark+2)  
3bb9 32 79 fb			ld (debug_mark+2),a  
3bbc 18 03			jr .pastdmark  
3bbe ..			.dmark: db "DOT"  
3bc1 f1			.pastdmark: pop af  
3bc2			endm  
# End of macro DMARK
3bc2						CALLMONITOR 
3bc2 cd 5a 17			call break_point_state  
3bc5				endm  
# End of macro CALLMONITOR
3bc5					endif 
3bc5 3e 00			ld a, 0 
3bc7 32 25 f8			ld (cli_mvdot), a 
3bca 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3bcc				 
3bcc			 
3bcc			.dotgo: 
3bcc			 
3bcc			; move up type to on stack for parserv5 
3bcc					FORTH_DSP 
3bcc cd a7 1e			call macro_forth_dsp 
3bcf				endm 
# End of macro FORTH_DSP
3bcf				;FORTH_DSP_VALUE  
3bcf			 
3bcf			if DEBUG_FORTH_DOT 
3bcf				DMARK "DOT" 
3bcf				CALLMONITOR 
3bcf			endif	 
3bcf			;		.print: 
3bcf			 
3bcf 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3bd0 23				inc hl   ; position to the actual value 
3bd1 fe 01			cp DS_TYPE_STR 
3bd3 20 06			jr nz, .dotnum1  
3bd5			 
3bd5			; display string 
3bd5				FORTH_DSP_VALUE  
3bd5 cd ca 1e			call macro_forth_dsp_value 
3bd8				endm 
# End of macro FORTH_DSP_VALUE
3bd8 eb				ex de,hl 
3bd9 18 11			jr .dotwrite 
3bdb			 
3bdb			.dotnum1: 
3bdb fe 02			cp DS_TYPE_INUM 
3bdd 20 0c			jr nz, .dotflot 
3bdf			 
3bdf			 
3bdf			; display number 
3bdf			 
3bdf			;	push hl 
3bdf			;	call clear_display 
3bdf			;	pop hl 
3bdf			 
3bdf 5e				ld e, (hl) 
3be0 23				inc hl 
3be1 56				ld d, (hl) 
3be2 21 1d ee			ld hl, scratch 
3be5			if DEBUG_FORTH_DOT 
3be5				DMARK "DT1" 
3be5				CALLMONITOR 
3be5			endif	 
3be5			 
3be5 cd 2a 11			call uitoa_16 
3be8 eb				ex de,hl 
3be9			 
3be9			if DEBUG_FORTH_DOT 
3be9				DMARK "DT2" 
3be9				CALLMONITOR 
3be9			endif	 
3be9			 
3be9			;	ld de, os_word_scratch 
3be9 18 01			jr .dotwrite 
3beb			 
3beb 00			.dotflot:   nop 
3bec			; TODO print floating point number 
3bec			 
3bec			.dotwrite:		 
3bec			 
3bec					; if c is set then set all '-' to spaces 
3bec					; need to also take into account .>  
3bec			 
3bec 3e 01				ld a, 1 
3bee b9					cp c 
3bef 20 13				jr nz, .nodashswap 
3bf1			 
3bf1					; DE has the string to write, working with HL 
3bf1			 
3bf1 06 ff				ld b, 255 
3bf3 d5					push de 
3bf4 e1					pop hl 
3bf5			 
3bf5			if DEBUG_FORTH_DOT 
3bf5				DMARK "DT-" 
3bf5				CALLMONITOR 
3bf5			endif	 
3bf5 7e			.dashscan:	ld a, (hl) 
3bf6 fe 00				cp 0 
3bf8 28 0a				jr z, .nodashswap 
3bfa fe 2d				cp '-' 
3bfc 20 03				jr nz, .dashskip 
3bfe 3e 20				ld a, ' ' 
3c00 77					ld (hl), a 
3c01 23			.dashskip:	inc hl 
3c02			if DEBUG_FORTH_DOT 
3c02				DMARK "D-2" 
3c02				CALLMONITOR 
3c02			endif	 
3c02 10 f1				djnz .dashscan 
3c04			 
3c04			if DEBUG_FORTH_DOT 
3c04				DMARK "D-1" 
3c04				CALLMONITOR 
3c04			endif	 
3c04			 
3c04			.nodashswap: 
3c04			 
3c04 e5					push hl   ; save string start in case we need to advance print 
3c05			 
3c05 3a 46 f8				ld a, (f_cursor_ptr) 
3c08 cd fc 0a				call str_at_display 
3c0b 3a 24 f8				ld a,(cli_autodisplay) 
3c0e fe 00				cp 0 
3c10 28 03				jr z, .noupdate 
3c12 cd 0c 0b						call update_display 
3c15					.noupdate: 
3c15			 
3c15			 
3c15					; see if we need to advance the print position 
3c15			 
3c15 e1					pop hl   ; get back string 
3c16			 
3c16 3a 25 f8				ld a, (cli_mvdot) 
3c19			if DEBUG_FORTH_DOT 
3c19					ld e,a 
3c19				DMARK "D>1" 
3c19				CALLMONITOR 
3c19			endif	 
3c19 fe 00				cp 0 
3c1b 28 0c				jr z, .noadv 
3c1d					; yes, lets advance the print position 
3c1d 3e 00				ld a, 0 
3c1f cd 86 11				call strlent 
3c22 3a 46 f8				ld a, (f_cursor_ptr) 
3c25 85					add a,l 
3c26					;call addatohl 
3c26					;ld a, l 
3c26 32 46 f8				ld (f_cursor_ptr), a   ; save new pos 
3c29			 
3c29			if DEBUG_FORTH_DOT 
3c29				DMARK "D->" 
3c29				CALLMONITOR 
3c29			endif	 
3c29			 
3c29			.noadv:	 
3c29			 
3c29					if DEBUG_FORTH_DOT_WAIT 
3c29							call next_page_prompt 
3c29					endif	 
3c29			; TODO this pop off the stack causes a crash. i dont know why 
3c29			 
3c29			 
3c29			if DEBUG_FORTH_DOT 
3c29				DMARK "DTh" 
3c29				CALLMONITOR 
3c29			endif	 
3c29			 
3c29					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c29 cd 99 1f			call macro_forth_dsp_pop 
3c2c				endm 
# End of macro FORTH_DSP_POP
3c2c			 
3c2c			if DEBUG_FORTH_DOT 
3c2c				DMARK "DTi" 
3c2c				CALLMONITOR 
3c2c			endif	 
3c2c			 
3c2c			 
3c2c					NEXTW 
3c2c c3 53 20			jp macro_next 
3c2f				endm 
# End of macro NEXTW
3c2f			 
3c2f			.CLS: 
3c2f				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3c2f 35				db WORD_SYS_CORE+33             
3c30 5c 3c			dw .DRAW            
3c32 04				db 3 + 1 
3c33 .. 00			db "CLS",0              
3c37				endm 
# End of macro CWHEAD
3c37			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3c37					if DEBUG_FORTH_WORDS_KEY 
3c37						DMARK "CLS" 
3c37 f5				push af  
3c38 3a 4c 3c			ld a, (.dmark)  
3c3b 32 77 fb			ld (debug_mark),a  
3c3e 3a 4d 3c			ld a, (.dmark+1)  
3c41 32 78 fb			ld (debug_mark+1),a  
3c44 3a 4e 3c			ld a, (.dmark+2)  
3c47 32 79 fb			ld (debug_mark+2),a  
3c4a 18 03			jr .pastdmark  
3c4c ..			.dmark: db "CLS"  
3c4f f1			.pastdmark: pop af  
3c50			endm  
# End of macro DMARK
3c50						CALLMONITOR 
3c50 cd 5a 17			call break_point_state  
3c53				endm  
# End of macro CALLMONITOR
3c53					endif 
3c53 cd e9 0a				call clear_display 
3c56 c3 6a 3d				jp .home		; and home cursor 
3c59					NEXTW 
3c59 c3 53 20			jp macro_next 
3c5c				endm 
# End of macro NEXTW
3c5c			 
3c5c			.DRAW: 
3c5c				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3c5c 36				db WORD_SYS_CORE+34             
3c5d 87 3c			dw .DUMP            
3c5f 05				db 4 + 1 
3c60 .. 00			db "DRAW",0              
3c65				endm 
# End of macro CWHEAD
3c65			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3c65					if DEBUG_FORTH_WORDS_KEY 
3c65						DMARK "DRW" 
3c65 f5				push af  
3c66 3a 7a 3c			ld a, (.dmark)  
3c69 32 77 fb			ld (debug_mark),a  
3c6c 3a 7b 3c			ld a, (.dmark+1)  
3c6f 32 78 fb			ld (debug_mark+1),a  
3c72 3a 7c 3c			ld a, (.dmark+2)  
3c75 32 79 fb			ld (debug_mark+2),a  
3c78 18 03			jr .pastdmark  
3c7a ..			.dmark: db "DRW"  
3c7d f1			.pastdmark: pop af  
3c7e			endm  
# End of macro DMARK
3c7e						CALLMONITOR 
3c7e cd 5a 17			call break_point_state  
3c81				endm  
# End of macro CALLMONITOR
3c81					endif 
3c81 cd 0c 0b				call update_display 
3c84					NEXTW 
3c84 c3 53 20			jp macro_next 
3c87				endm 
# End of macro NEXTW
3c87			 
3c87			.DUMP: 
3c87				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3c87 37				db WORD_SYS_CORE+35             
3c88 bf 3c			dw .CDUMP            
3c8a 05				db 4 + 1 
3c8b .. 00			db "DUMP",0              
3c90				endm 
# End of macro CWHEAD
3c90			; | DUMP ( x -- ) With address x display dump   | DONE 
3c90			; TODO pop address to use off of the stack 
3c90					if DEBUG_FORTH_WORDS_KEY 
3c90						DMARK "DUM" 
3c90 f5				push af  
3c91 3a a5 3c			ld a, (.dmark)  
3c94 32 77 fb			ld (debug_mark),a  
3c97 3a a6 3c			ld a, (.dmark+1)  
3c9a 32 78 fb			ld (debug_mark+1),a  
3c9d 3a a7 3c			ld a, (.dmark+2)  
3ca0 32 79 fb			ld (debug_mark+2),a  
3ca3 18 03			jr .pastdmark  
3ca5 ..			.dmark: db "DUM"  
3ca8 f1			.pastdmark: pop af  
3ca9			endm  
# End of macro DMARK
3ca9						CALLMONITOR 
3ca9 cd 5a 17			call break_point_state  
3cac				endm  
# End of macro CALLMONITOR
3cac					endif 
3cac cd e9 0a				call clear_display 
3caf			 
3caf					; get address 
3caf			 
3caf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3caf cd e1 1e			call macro_dsp_valuehl 
3cb2				endm 
# End of macro FORTH_DSP_VALUEHL
3cb2				 
3cb2					; save it for cdump 
3cb2			 
3cb2 22 40 f1				ld (os_cur_ptr),hl 
3cb5			 
3cb5					; destroy value TOS 
3cb5			 
3cb5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cb5 cd 99 1f			call macro_forth_dsp_pop 
3cb8				endm 
# End of macro FORTH_DSP_POP
3cb8			 
3cb8 cd 6a 1b				call dumpcont	; skip old style of param parsing	 
3cbb c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3cbc					NEXTW 
3cbc c3 53 20			jp macro_next 
3cbf				endm 
# End of macro NEXTW
3cbf			.CDUMP: 
3cbf				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3cbf 38				db WORD_SYS_CORE+36             
3cc0 ef 3c			dw .DAT            
3cc2 06				db 5 + 1 
3cc3 .. 00			db "CDUMP",0              
3cc9				endm 
# End of macro CWHEAD
3cc9			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3cc9					if DEBUG_FORTH_WORDS_KEY 
3cc9						DMARK "CDP" 
3cc9 f5				push af  
3cca 3a de 3c			ld a, (.dmark)  
3ccd 32 77 fb			ld (debug_mark),a  
3cd0 3a df 3c			ld a, (.dmark+1)  
3cd3 32 78 fb			ld (debug_mark+1),a  
3cd6 3a e0 3c			ld a, (.dmark+2)  
3cd9 32 79 fb			ld (debug_mark+2),a  
3cdc 18 03			jr .pastdmark  
3cde ..			.dmark: db "CDP"  
3ce1 f1			.pastdmark: pop af  
3ce2			endm  
# End of macro DMARK
3ce2						CALLMONITOR 
3ce2 cd 5a 17			call break_point_state  
3ce5				endm  
# End of macro CALLMONITOR
3ce5					endif 
3ce5 cd e9 0a				call clear_display 
3ce8 cd 6a 1b				call dumpcont	 
3ceb c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3cec					NEXTW 
3cec c3 53 20			jp macro_next 
3cef				endm 
# End of macro NEXTW
3cef			 
3cef			 
3cef			 
3cef			 
3cef			.DAT: 
3cef				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3cef 3d				db WORD_SYS_CORE+41             
3cf0 45 3d			dw .HOME            
3cf2 03				db 2 + 1 
3cf3 .. 00			db "AT",0              
3cf6				endm 
# End of macro CWHEAD
3cf6			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3cf6					if DEBUG_FORTH_WORDS_KEY 
3cf6						DMARK "AT." 
3cf6 f5				push af  
3cf7 3a 0b 3d			ld a, (.dmark)  
3cfa 32 77 fb			ld (debug_mark),a  
3cfd 3a 0c 3d			ld a, (.dmark+1)  
3d00 32 78 fb			ld (debug_mark+1),a  
3d03 3a 0d 3d			ld a, (.dmark+2)  
3d06 32 79 fb			ld (debug_mark+2),a  
3d09 18 03			jr .pastdmark  
3d0b ..			.dmark: db "AT."  
3d0e f1			.pastdmark: pop af  
3d0f			endm  
# End of macro DMARK
3d0f						CALLMONITOR 
3d0f cd 5a 17			call break_point_state  
3d12				endm  
# End of macro CALLMONITOR
3d12					endif 
3d12					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d12 cd e1 1e			call macro_dsp_valuehl 
3d15				endm 
# End of macro FORTH_DSP_VALUEHL
3d15			 
3d15			 
3d15					; TODO save cursor row 
3d15 7d					ld a,l 
3d16 fe 02				cp 2 
3d18 20 04				jr nz, .crow3 
3d1a 3e 28				ld a, display_row_2 
3d1c 18 12				jr .ccol1 
3d1e fe 03		.crow3:		cp 3 
3d20 20 04				jr nz, .crow4 
3d22 3e 50				ld a, display_row_3 
3d24 18 0a				jr .ccol1 
3d26 fe 04		.crow4:		cp 4 
3d28 20 04				jr nz, .crow1 
3d2a 3e 78				ld a, display_row_4 
3d2c 18 02				jr .ccol1 
3d2e 3e 00		.crow1:		ld a,display_row_1 
3d30 f5			.ccol1:		push af			; got row offset 
3d31 6f					ld l,a 
3d32 26 00				ld h,0 
3d34					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d34 cd 99 1f			call macro_forth_dsp_pop 
3d37				endm 
# End of macro FORTH_DSP_POP
3d37					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d37 cd e1 1e			call macro_dsp_valuehl 
3d3a				endm 
# End of macro FORTH_DSP_VALUEHL
3d3a					; TODO save cursor col 
3d3a f1					pop af 
3d3b 85					add l		; add col offset 
3d3c 32 46 f8				ld (f_cursor_ptr), a 
3d3f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d3f cd 99 1f			call macro_forth_dsp_pop 
3d42				endm 
# End of macro FORTH_DSP_POP
3d42			 
3d42					; calculate  
3d42			 
3d42					NEXTW 
3d42 c3 53 20			jp macro_next 
3d45				endm 
# End of macro NEXTW
3d45			 
3d45			 
3d45			.HOME: 
3d45				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3d45 41				db WORD_SYS_CORE+45             
3d46 72 3d			dw .SPACE            
3d48 05				db 4 + 1 
3d49 .. 00			db "HOME",0              
3d4e				endm 
# End of macro CWHEAD
3d4e			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3d4e					if DEBUG_FORTH_WORDS_KEY 
3d4e						DMARK "HOM" 
3d4e f5				push af  
3d4f 3a 63 3d			ld a, (.dmark)  
3d52 32 77 fb			ld (debug_mark),a  
3d55 3a 64 3d			ld a, (.dmark+1)  
3d58 32 78 fb			ld (debug_mark+1),a  
3d5b 3a 65 3d			ld a, (.dmark+2)  
3d5e 32 79 fb			ld (debug_mark+2),a  
3d61 18 03			jr .pastdmark  
3d63 ..			.dmark: db "HOM"  
3d66 f1			.pastdmark: pop af  
3d67			endm  
# End of macro DMARK
3d67						CALLMONITOR 
3d67 cd 5a 17			call break_point_state  
3d6a				endm  
# End of macro CALLMONITOR
3d6a					endif 
3d6a 3e 00		.home:		ld a, 0		; and home cursor 
3d6c 32 46 f8				ld (f_cursor_ptr), a 
3d6f					NEXTW 
3d6f c3 53 20			jp macro_next 
3d72				endm 
# End of macro NEXTW
3d72			 
3d72			 
3d72			.SPACE: 
3d72				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3d72 46				db WORD_SYS_CORE+50             
3d73 a0 3d			dw .SPACES            
3d75 03				db 2 + 1 
3d76 .. 00			db "BL",0              
3d79				endm 
# End of macro CWHEAD
3d79			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3d79					if DEBUG_FORTH_WORDS_KEY 
3d79						DMARK "BL." 
3d79 f5				push af  
3d7a 3a 8e 3d			ld a, (.dmark)  
3d7d 32 77 fb			ld (debug_mark),a  
3d80 3a 8f 3d			ld a, (.dmark+1)  
3d83 32 78 fb			ld (debug_mark+1),a  
3d86 3a 90 3d			ld a, (.dmark+2)  
3d89 32 79 fb			ld (debug_mark+2),a  
3d8c 18 03			jr .pastdmark  
3d8e ..			.dmark: db "BL."  
3d91 f1			.pastdmark: pop af  
3d92			endm  
# End of macro DMARK
3d92						CALLMONITOR 
3d92 cd 5a 17			call break_point_state  
3d95				endm  
# End of macro CALLMONITOR
3d95					endif 
3d95 21 9e 3d				ld hl, .blstr 
3d98 cd 58 1d				call forth_push_str 
3d9b					 
3d9b				       NEXTW 
3d9b c3 53 20			jp macro_next 
3d9e				endm 
# End of macro NEXTW
3d9e			 
3d9e .. 00		.blstr: db " ", 0 
3da0			 
3da0			.SPACES: 
3da0				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3da0 47				db WORD_SYS_CORE+51             
3da1 3b 3e			dw .SCROLL            
3da3 07				db 6 + 1 
3da4 .. 00			db "SPACES",0              
3dab				endm 
# End of macro CWHEAD
3dab			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
3dab					if DEBUG_FORTH_WORDS_KEY 
3dab						DMARK "SPS" 
3dab f5				push af  
3dac 3a c0 3d			ld a, (.dmark)  
3daf 32 77 fb			ld (debug_mark),a  
3db2 3a c1 3d			ld a, (.dmark+1)  
3db5 32 78 fb			ld (debug_mark+1),a  
3db8 3a c2 3d			ld a, (.dmark+2)  
3dbb 32 79 fb			ld (debug_mark+2),a  
3dbe 18 03			jr .pastdmark  
3dc0 ..			.dmark: db "SPS"  
3dc3 f1			.pastdmark: pop af  
3dc4			endm  
# End of macro DMARK
3dc4						CALLMONITOR 
3dc4 cd 5a 17			call break_point_state  
3dc7				endm  
# End of macro CALLMONITOR
3dc7					endif 
3dc7			 
3dc7			 
3dc7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3dc7 cd e1 1e			call macro_dsp_valuehl 
3dca				endm 
# End of macro FORTH_DSP_VALUEHL
3dca			 
3dca			;		push hl    ; u 
3dca					if DEBUG_FORTH_WORDS 
3dca						DMARK "SPA" 
3dca f5				push af  
3dcb 3a df 3d			ld a, (.dmark)  
3dce 32 77 fb			ld (debug_mark),a  
3dd1 3a e0 3d			ld a, (.dmark+1)  
3dd4 32 78 fb			ld (debug_mark+1),a  
3dd7 3a e1 3d			ld a, (.dmark+2)  
3dda 32 79 fb			ld (debug_mark+2),a  
3ddd 18 03			jr .pastdmark  
3ddf ..			.dmark: db "SPA"  
3de2 f1			.pastdmark: pop af  
3de3			endm  
# End of macro DMARK
3de3						CALLMONITOR 
3de3 cd 5a 17			call break_point_state  
3de6				endm  
# End of macro CALLMONITOR
3de6					endif 
3de6			 
3de6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3de6 cd 99 1f			call macro_forth_dsp_pop 
3de9				endm 
# End of macro FORTH_DSP_POP
3de9			;		pop hl 
3de9 4d					ld c, l 
3dea 06 00				ld b, 0 
3dec 21 1d ee				ld hl, scratch  
3def			 
3def					if DEBUG_FORTH_WORDS 
3def						DMARK "SP2" 
3def f5				push af  
3df0 3a 04 3e			ld a, (.dmark)  
3df3 32 77 fb			ld (debug_mark),a  
3df6 3a 05 3e			ld a, (.dmark+1)  
3df9 32 78 fb			ld (debug_mark+1),a  
3dfc 3a 06 3e			ld a, (.dmark+2)  
3dff 32 79 fb			ld (debug_mark+2),a  
3e02 18 03			jr .pastdmark  
3e04 ..			.dmark: db "SP2"  
3e07 f1			.pastdmark: pop af  
3e08			endm  
# End of macro DMARK
3e08						CALLMONITOR 
3e08 cd 5a 17			call break_point_state  
3e0b				endm  
# End of macro CALLMONITOR
3e0b					endif 
3e0b 3e 20				ld a, ' ' 
3e0d c5			.spaces1:	push bc 
3e0e 77					ld (hl),a 
3e0f 23					inc hl 
3e10 c1					pop bc 
3e11 10 fa				djnz .spaces1 
3e13 3e 00				ld a,0 
3e15 77					ld (hl),a 
3e16 21 1d ee				ld hl, scratch 
3e19					if DEBUG_FORTH_WORDS 
3e19						DMARK "SP3" 
3e19 f5				push af  
3e1a 3a 2e 3e			ld a, (.dmark)  
3e1d 32 77 fb			ld (debug_mark),a  
3e20 3a 2f 3e			ld a, (.dmark+1)  
3e23 32 78 fb			ld (debug_mark+1),a  
3e26 3a 30 3e			ld a, (.dmark+2)  
3e29 32 79 fb			ld (debug_mark+2),a  
3e2c 18 03			jr .pastdmark  
3e2e ..			.dmark: db "SP3"  
3e31 f1			.pastdmark: pop af  
3e32			endm  
# End of macro DMARK
3e32						CALLMONITOR 
3e32 cd 5a 17			call break_point_state  
3e35				endm  
# End of macro CALLMONITOR
3e35					endif 
3e35 cd 53 1e				call forth_apush 
3e38			 
3e38				       NEXTW 
3e38 c3 53 20			jp macro_next 
3e3b				endm 
# End of macro NEXTW
3e3b			 
3e3b			 
3e3b			 
3e3b			.SCROLL: 
3e3b				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
3e3b 53				db WORD_SYS_CORE+63             
3e3c 68 3e			dw .SCROLLD            
3e3e 07				db 6 + 1 
3e3f .. 00			db "SCROLL",0              
3e46				endm 
# End of macro CWHEAD
3e46			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
3e46					if DEBUG_FORTH_WORDS_KEY 
3e46						DMARK "SCR" 
3e46 f5				push af  
3e47 3a 5b 3e			ld a, (.dmark)  
3e4a 32 77 fb			ld (debug_mark),a  
3e4d 3a 5c 3e			ld a, (.dmark+1)  
3e50 32 78 fb			ld (debug_mark+1),a  
3e53 3a 5d 3e			ld a, (.dmark+2)  
3e56 32 79 fb			ld (debug_mark+2),a  
3e59 18 03			jr .pastdmark  
3e5b ..			.dmark: db "SCR"  
3e5e f1			.pastdmark: pop af  
3e5f			endm  
# End of macro DMARK
3e5f						CALLMONITOR 
3e5f cd 5a 17			call break_point_state  
3e62				endm  
# End of macro CALLMONITOR
3e62					endif 
3e62			 
3e62 cd ab 0a			call scroll_up 
3e65			;	call update_display 
3e65			 
3e65					NEXTW 
3e65 c3 53 20			jp macro_next 
3e68				endm 
# End of macro NEXTW
3e68			 
3e68			 
3e68			 
3e68			;		; get dir 
3e68			; 
3e68			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e68			; 
3e68			;		push hl 
3e68			; 
3e68			;		; destroy value TOS 
3e68			; 
3e68			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e68			; 
3e68			;		; get count 
3e68			; 
3e68			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e68			; 
3e68			;		push hl 
3e68			; 
3e68			;		; destroy value TOS 
3e68			; 
3e68			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e68			; 
3e68			;		; one value on hl get other one back 
3e68			; 
3e68			;		pop bc    ; count 
3e68			; 
3e68			;		pop de   ; dir 
3e68			; 
3e68			; 
3e68			;		ld b, c 
3e68			; 
3e68			;.scrolldir:     push bc 
3e68			;		push de 
3e68			; 
3e68			;		ld a, 0 
3e68			;		cp e 
3e68			;		jr z, .scrollup  
3e68			;		call scroll_down 
3e68			;		jr .scrollnext 
3e68			;.scrollup:	call scroll_up 
3e68			; 
3e68			;		 
3e68			;.scrollnext: 
3e68			;		pop de 
3e68			;		pop bc 
3e68			;		djnz .scrolldir 
3e68			; 
3e68			; 
3e68			; 
3e68			; 
3e68			; 
3e68			;		NEXTW 
3e68			 
3e68			.SCROLLD: 
3e68				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
3e68 53				db WORD_SYS_CORE+63             
3e69 96 3e			dw .ATQ            
3e6b 08				db 7 + 1 
3e6c .. 00			db "SCROLLD",0              
3e74				endm 
# End of macro CWHEAD
3e74			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
3e74					if DEBUG_FORTH_WORDS_KEY 
3e74						DMARK "SCD" 
3e74 f5				push af  
3e75 3a 89 3e			ld a, (.dmark)  
3e78 32 77 fb			ld (debug_mark),a  
3e7b 3a 8a 3e			ld a, (.dmark+1)  
3e7e 32 78 fb			ld (debug_mark+1),a  
3e81 3a 8b 3e			ld a, (.dmark+2)  
3e84 32 79 fb			ld (debug_mark+2),a  
3e87 18 03			jr .pastdmark  
3e89 ..			.dmark: db "SCD"  
3e8c f1			.pastdmark: pop af  
3e8d			endm  
# End of macro DMARK
3e8d						CALLMONITOR 
3e8d cd 5a 17			call break_point_state  
3e90				endm  
# End of macro CALLMONITOR
3e90					endif 
3e90			 
3e90 cd cf 0a			call scroll_down 
3e93			;	call update_display 
3e93			 
3e93					NEXTW 
3e93 c3 53 20			jp macro_next 
3e96				endm 
# End of macro NEXTW
3e96			 
3e96			 
3e96			.ATQ: 
3e96				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
3e96 62				db WORD_SYS_CORE+78             
3e97 f4 3e			dw .AUTODSP            
3e99 04				db 3 + 1 
3e9a .. 00			db "AT@",0              
3e9e				endm 
# End of macro CWHEAD
3e9e			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
3e9e					if DEBUG_FORTH_WORDS_KEY 
3e9e						DMARK "ATA" 
3e9e f5				push af  
3e9f 3a b3 3e			ld a, (.dmark)  
3ea2 32 77 fb			ld (debug_mark),a  
3ea5 3a b4 3e			ld a, (.dmark+1)  
3ea8 32 78 fb			ld (debug_mark+1),a  
3eab 3a b5 3e			ld a, (.dmark+2)  
3eae 32 79 fb			ld (debug_mark+2),a  
3eb1 18 03			jr .pastdmark  
3eb3 ..			.dmark: db "ATA"  
3eb6 f1			.pastdmark: pop af  
3eb7			endm  
# End of macro DMARK
3eb7						CALLMONITOR 
3eb7 cd 5a 17			call break_point_state  
3eba				endm  
# End of macro CALLMONITOR
3eba					endif 
3eba			 
3eba			 
3eba					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3eba cd e1 1e			call macro_dsp_valuehl 
3ebd				endm 
# End of macro FORTH_DSP_VALUEHL
3ebd			 
3ebd					; TODO save cursor row 
3ebd 7d					ld a,l 
3ebe fe 02				cp 2 
3ec0 20 04				jr nz, .crow3aq 
3ec2 3e 28				ld a, display_row_2 
3ec4 18 12				jr .ccol1aq 
3ec6 fe 03		.crow3aq:		cp 3 
3ec8 20 04				jr nz, .crow4aq 
3eca 3e 50				ld a, display_row_3 
3ecc 18 0a				jr .ccol1aq 
3ece fe 04		.crow4aq:		cp 4 
3ed0 20 04				jr nz, .crow1aq 
3ed2 3e 78				ld a, display_row_4 
3ed4 18 02				jr .ccol1aq 
3ed6 3e 00		.crow1aq:		ld a,display_row_1 
3ed8 f5			.ccol1aq:		push af			; got row offset 
3ed9 6f					ld l,a 
3eda 26 00				ld h,0 
3edc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3edc cd 99 1f			call macro_forth_dsp_pop 
3edf				endm 
# End of macro FORTH_DSP_POP
3edf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3edf cd e1 1e			call macro_dsp_valuehl 
3ee2				endm 
# End of macro FORTH_DSP_VALUEHL
3ee2					; TODO save cursor col 
3ee2 f1					pop af 
3ee3 85					add l		; add col offset 
3ee4			 
3ee4					; add current frame buffer address 
3ee4 2a d8 f8				ld hl, (display_fb_active) 
3ee7 cd 1d 0d				call addatohl 
3eea			 
3eea			 
3eea			 
3eea			 
3eea					; get char frame buffer location offset in hl 
3eea			 
3eea 7e					ld a,(hl) 
3eeb 26 00				ld h, 0 
3eed 6f					ld l, a 
3eee			 
3eee cd ea 1c				call forth_push_numhl 
3ef1			 
3ef1			 
3ef1					NEXTW 
3ef1 c3 53 20			jp macro_next 
3ef4				endm 
# End of macro NEXTW
3ef4			 
3ef4			.AUTODSP: 
3ef4				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
3ef4 63				db WORD_SYS_CORE+79             
3ef5 0a 3f			dw .MENU            
3ef7 05				db 4 + 1 
3ef8 .. 00			db "ADSP",0              
3efd				endm 
# End of macro CWHEAD
3efd			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
3efd			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
3efd			 
3efd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3efd cd e1 1e			call macro_dsp_valuehl 
3f00				endm 
# End of macro FORTH_DSP_VALUEHL
3f00			 
3f00			;		push hl 
3f00			 
3f00					; destroy value TOS 
3f00			 
3f00					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f00 cd 99 1f			call macro_forth_dsp_pop 
3f03				endm 
# End of macro FORTH_DSP_POP
3f03			 
3f03			;		pop hl 
3f03			 
3f03 7d					ld a,l 
3f04 32 24 f8				ld (cli_autodisplay), a 
3f07				       NEXTW 
3f07 c3 53 20			jp macro_next 
3f0a				endm 
# End of macro NEXTW
3f0a			 
3f0a			.MENU: 
3f0a				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
3f0a 70				db WORD_SYS_CORE+92             
3f0b b3 3f			dw .ENDDISPLAY            
3f0d 05				db 4 + 1 
3f0e .. 00			db "MENU",0              
3f13				endm 
# End of macro CWHEAD
3f13			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
3f13			 
3f13			;		; get number of items on the stack 
3f13			; 
3f13				 
3f13					FORTH_DSP_VALUEHL 
3f13 cd e1 1e			call macro_dsp_valuehl 
3f16				endm 
# End of macro FORTH_DSP_VALUEHL
3f16				 
3f16					if DEBUG_FORTH_WORDS_KEY 
3f16						DMARK "MNU" 
3f16 f5				push af  
3f17 3a 2b 3f			ld a, (.dmark)  
3f1a 32 77 fb			ld (debug_mark),a  
3f1d 3a 2c 3f			ld a, (.dmark+1)  
3f20 32 78 fb			ld (debug_mark+1),a  
3f23 3a 2d 3f			ld a, (.dmark+2)  
3f26 32 79 fb			ld (debug_mark+2),a  
3f29 18 03			jr .pastdmark  
3f2b ..			.dmark: db "MNU"  
3f2e f1			.pastdmark: pop af  
3f2f			endm  
# End of macro DMARK
3f2f						CALLMONITOR 
3f2f cd 5a 17			call break_point_state  
3f32				endm  
# End of macro CALLMONITOR
3f32					endif 
3f32			 
3f32 45					ld b, l	 
3f33 05					dec b 
3f34			 
3f34					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f34 cd 99 1f			call macro_forth_dsp_pop 
3f37				endm 
# End of macro FORTH_DSP_POP
3f37			 
3f37			 
3f37					; go directly through the stack to pluck out the string pointers and build an array 
3f37			 
3f37			;		FORTH_DSP 
3f37			 
3f37					; hl contains top most stack item 
3f37				 
3f37 11 1d ee				ld de, scratch 
3f3a			 
3f3a			.mbuild: 
3f3a			 
3f3a					FORTH_DSP_VALUEHL 
3f3a cd e1 1e			call macro_dsp_valuehl 
3f3d				endm 
# End of macro FORTH_DSP_VALUEHL
3f3d			 
3f3d					if DEBUG_FORTH_WORDS 
3f3d						DMARK "MN3" 
3f3d f5				push af  
3f3e 3a 52 3f			ld a, (.dmark)  
3f41 32 77 fb			ld (debug_mark),a  
3f44 3a 53 3f			ld a, (.dmark+1)  
3f47 32 78 fb			ld (debug_mark+1),a  
3f4a 3a 54 3f			ld a, (.dmark+2)  
3f4d 32 79 fb			ld (debug_mark+2),a  
3f50 18 03			jr .pastdmark  
3f52 ..			.dmark: db "MN3"  
3f55 f1			.pastdmark: pop af  
3f56			endm  
# End of macro DMARK
3f56						CALLMONITOR 
3f56 cd 5a 17			call break_point_state  
3f59				endm  
# End of macro CALLMONITOR
3f59					endif 
3f59 eb					ex de, hl 
3f5a 73					ld (hl), e 
3f5b 23					inc hl 
3f5c 72					ld (hl), d 
3f5d 23					inc hl 
3f5e eb					ex de, hl 
3f5f			 
3f5f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f5f cd 99 1f			call macro_forth_dsp_pop 
3f62				endm 
# End of macro FORTH_DSP_POP
3f62			 
3f62 10 d6				djnz .mbuild 
3f64			 
3f64					; done add term 
3f64			 
3f64 eb					ex de, hl 
3f65 36 00				ld (hl), 0 
3f67 23					inc hl 
3f68 36 00				ld (hl), 0 
3f6a			 
3f6a				 
3f6a					 
3f6a 21 1d ee				ld hl, scratch 
3f6d			 
3f6d					if DEBUG_FORTH_WORDS 
3f6d						DMARK "MNx" 
3f6d f5				push af  
3f6e 3a 82 3f			ld a, (.dmark)  
3f71 32 77 fb			ld (debug_mark),a  
3f74 3a 83 3f			ld a, (.dmark+1)  
3f77 32 78 fb			ld (debug_mark+1),a  
3f7a 3a 84 3f			ld a, (.dmark+2)  
3f7d 32 79 fb			ld (debug_mark+2),a  
3f80 18 03			jr .pastdmark  
3f82 ..			.dmark: db "MNx"  
3f85 f1			.pastdmark: pop af  
3f86			endm  
# End of macro DMARK
3f86						CALLMONITOR 
3f86 cd 5a 17			call break_point_state  
3f89				endm  
# End of macro CALLMONITOR
3f89					endif 
3f89			 
3f89			 
3f89			 
3f89 3e 00				ld a, 0 
3f8b cd 1a 0b				call menu 
3f8e			 
3f8e			 
3f8e 6f					ld l, a 
3f8f 26 00				ld h, 0 
3f91			 
3f91					if DEBUG_FORTH_WORDS 
3f91						DMARK "MNr" 
3f91 f5				push af  
3f92 3a a6 3f			ld a, (.dmark)  
3f95 32 77 fb			ld (debug_mark),a  
3f98 3a a7 3f			ld a, (.dmark+1)  
3f9b 32 78 fb			ld (debug_mark+1),a  
3f9e 3a a8 3f			ld a, (.dmark+2)  
3fa1 32 79 fb			ld (debug_mark+2),a  
3fa4 18 03			jr .pastdmark  
3fa6 ..			.dmark: db "MNr"  
3fa9 f1			.pastdmark: pop af  
3faa			endm  
# End of macro DMARK
3faa						CALLMONITOR 
3faa cd 5a 17			call break_point_state  
3fad				endm  
# End of macro CALLMONITOR
3fad					endif 
3fad			 
3fad cd ea 1c				call forth_push_numhl 
3fb0			 
3fb0			 
3fb0			 
3fb0			 
3fb0				       NEXTW 
3fb0 c3 53 20			jp macro_next 
3fb3				endm 
# End of macro NEXTW
3fb3			 
3fb3			 
3fb3			.ENDDISPLAY: 
3fb3			 
3fb3			; eof 
# End of file forth_words_display.asm
3fb3			include "forth_words_str.asm" 
3fb3			 
3fb3			; | ## String Words 
3fb3			 
3fb3			.PTR:   
3fb3			 
3fb3				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
3fb3 48				db WORD_SYS_CORE+52             
3fb4 e0 3f			dw .STYPE            
3fb6 04				db 3 + 1 
3fb7 .. 00			db "PTR",0              
3fbb				endm 
# End of macro CWHEAD
3fbb			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
3fbb			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
3fbb			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
3fbb			 
3fbb					if DEBUG_FORTH_WORDS_KEY 
3fbb						DMARK "PTR" 
3fbb f5				push af  
3fbc 3a d0 3f			ld a, (.dmark)  
3fbf 32 77 fb			ld (debug_mark),a  
3fc2 3a d1 3f			ld a, (.dmark+1)  
3fc5 32 78 fb			ld (debug_mark+1),a  
3fc8 3a d2 3f			ld a, (.dmark+2)  
3fcb 32 79 fb			ld (debug_mark+2),a  
3fce 18 03			jr .pastdmark  
3fd0 ..			.dmark: db "PTR"  
3fd3 f1			.pastdmark: pop af  
3fd4			endm  
# End of macro DMARK
3fd4						CALLMONITOR 
3fd4 cd 5a 17			call break_point_state  
3fd7				endm  
# End of macro CALLMONITOR
3fd7					endif 
3fd7					FORTH_DSP_VALUEHL 
3fd7 cd e1 1e			call macro_dsp_valuehl 
3fda				endm 
# End of macro FORTH_DSP_VALUEHL
3fda cd ea 1c				call forth_push_numhl 
3fdd			 
3fdd			 
3fdd					NEXTW 
3fdd c3 53 20			jp macro_next 
3fe0				endm 
# End of macro NEXTW
3fe0			.STYPE: 
3fe0				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
3fe0 48				db WORD_SYS_CORE+52             
3fe1 2f 40			dw .UPPER            
3fe3 06				db 5 + 1 
3fe4 .. 00			db "STYPE",0              
3fea				endm 
# End of macro CWHEAD
3fea			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
3fea					if DEBUG_FORTH_WORDS_KEY 
3fea						DMARK "STY" 
3fea f5				push af  
3feb 3a ff 3f			ld a, (.dmark)  
3fee 32 77 fb			ld (debug_mark),a  
3ff1 3a 00 40			ld a, (.dmark+1)  
3ff4 32 78 fb			ld (debug_mark+1),a  
3ff7 3a 01 40			ld a, (.dmark+2)  
3ffa 32 79 fb			ld (debug_mark+2),a  
3ffd 18 03			jr .pastdmark  
3fff ..			.dmark: db "STY"  
4002 f1			.pastdmark: pop af  
4003			endm  
# End of macro DMARK
4003						CALLMONITOR 
4003 cd 5a 17			call break_point_state  
4006				endm  
# End of macro CALLMONITOR
4006					endif 
4006					FORTH_DSP 
4006 cd a7 1e			call macro_forth_dsp 
4009				endm 
# End of macro FORTH_DSP
4009					;v5 FORTH_DSP_VALUE 
4009			 
4009 7e					ld a, (hl) 
400a			 
400a f5					push af 
400b			 
400b			; Dont destroy TOS		FORTH_DSP_POP 
400b			 
400b f1					pop af 
400c			 
400c fe 01				cp DS_TYPE_STR 
400e 28 09				jr z, .typestr 
4010			 
4010 fe 02				cp DS_TYPE_INUM 
4012 28 0a				jr z, .typeinum 
4014			 
4014 21 2d 40				ld hl, .tna 
4017 18 0a				jr .tpush 
4019			 
4019 21 29 40		.typestr:	ld hl, .tstr 
401c 18 05				jr .tpush 
401e 21 2b 40		.typeinum:	ld hl, .tinum 
4021 18 00				jr .tpush 
4023			 
4023			.tpush: 
4023			 
4023 cd 58 1d				call forth_push_str 
4026			 
4026					NEXTW 
4026 c3 53 20			jp macro_next 
4029				endm 
# End of macro NEXTW
4029 .. 00		.tstr:	db "s",0 
402b .. 00		.tinum:  db "i",0 
402d .. 00		.tna:   db "?", 0 
402f			 
402f			 
402f			.UPPER: 
402f				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
402f 48				db WORD_SYS_CORE+52             
4030 6a 40			dw .LOWER            
4032 06				db 5 + 1 
4033 .. 00			db "UPPER",0              
4039				endm 
# End of macro CWHEAD
4039			; | UPPER ( s -- s ) Upper case string s  | DONE 
4039					if DEBUG_FORTH_WORDS_KEY 
4039						DMARK "UPR" 
4039 f5				push af  
403a 3a 4e 40			ld a, (.dmark)  
403d 32 77 fb			ld (debug_mark),a  
4040 3a 4f 40			ld a, (.dmark+1)  
4043 32 78 fb			ld (debug_mark+1),a  
4046 3a 50 40			ld a, (.dmark+2)  
4049 32 79 fb			ld (debug_mark+2),a  
404c 18 03			jr .pastdmark  
404e ..			.dmark: db "UPR"  
4051 f1			.pastdmark: pop af  
4052			endm  
# End of macro DMARK
4052						CALLMONITOR 
4052 cd 5a 17			call break_point_state  
4055				endm  
# End of macro CALLMONITOR
4055					endif 
4055			 
4055					FORTH_DSP 
4055 cd a7 1e			call macro_forth_dsp 
4058				endm 
# End of macro FORTH_DSP
4058					 
4058			; TODO check is string type 
4058			 
4058					FORTH_DSP_VALUEHL 
4058 cd e1 1e			call macro_dsp_valuehl 
405b				endm 
# End of macro FORTH_DSP_VALUEHL
405b			; get pointer to string in hl 
405b			 
405b 7e			.toup:		ld a, (hl) 
405c fe 00				cp 0 
405e 28 07				jr z, .toupdone 
4060			 
4060 cd 8a 10				call to_upper 
4063			 
4063 77					ld (hl), a 
4064 23					inc hl 
4065 18 f4				jr .toup 
4067			 
4067					 
4067			 
4067			 
4067			; for each char convert to upper 
4067					 
4067			.toupdone: 
4067			 
4067			 
4067					NEXTW 
4067 c3 53 20			jp macro_next 
406a				endm 
# End of macro NEXTW
406a			.LOWER: 
406a				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
406a 48				db WORD_SYS_CORE+52             
406b a5 40			dw .TCASE            
406d 06				db 5 + 1 
406e .. 00			db "LOWER",0              
4074				endm 
# End of macro CWHEAD
4074			; | LOWER ( s -- s ) Lower case string s  | DONE 
4074					if DEBUG_FORTH_WORDS_KEY 
4074						DMARK "LWR" 
4074 f5				push af  
4075 3a 89 40			ld a, (.dmark)  
4078 32 77 fb			ld (debug_mark),a  
407b 3a 8a 40			ld a, (.dmark+1)  
407e 32 78 fb			ld (debug_mark+1),a  
4081 3a 8b 40			ld a, (.dmark+2)  
4084 32 79 fb			ld (debug_mark+2),a  
4087 18 03			jr .pastdmark  
4089 ..			.dmark: db "LWR"  
408c f1			.pastdmark: pop af  
408d			endm  
# End of macro DMARK
408d						CALLMONITOR 
408d cd 5a 17			call break_point_state  
4090				endm  
# End of macro CALLMONITOR
4090					endif 
4090			 
4090					FORTH_DSP 
4090 cd a7 1e			call macro_forth_dsp 
4093				endm 
# End of macro FORTH_DSP
4093					 
4093			; TODO check is string type 
4093			 
4093					FORTH_DSP_VALUEHL 
4093 cd e1 1e			call macro_dsp_valuehl 
4096				endm 
# End of macro FORTH_DSP_VALUEHL
4096			; get pointer to string in hl 
4096			 
4096 7e			.tolow:		ld a, (hl) 
4097 fe 00				cp 0 
4099 28 07				jr z, .tolowdone 
409b			 
409b cd 93 10				call to_lower 
409e			 
409e 77					ld (hl), a 
409f 23					inc hl 
40a0 18 f4				jr .tolow 
40a2			 
40a2					 
40a2			 
40a2			 
40a2			; for each char convert to low 
40a2					 
40a2			.tolowdone: 
40a2					NEXTW 
40a2 c3 53 20			jp macro_next 
40a5				endm 
# End of macro NEXTW
40a5			.TCASE: 
40a5				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
40a5 48				db WORD_SYS_CORE+52             
40a6 db 41			dw .SUBSTR            
40a8 06				db 5 + 1 
40a9 .. 00			db "TCASE",0              
40af				endm 
# End of macro CWHEAD
40af			; | TCASE ( s -- s ) Title case string s  | DONE 
40af					if DEBUG_FORTH_WORDS_KEY 
40af						DMARK "TCS" 
40af f5				push af  
40b0 3a c4 40			ld a, (.dmark)  
40b3 32 77 fb			ld (debug_mark),a  
40b6 3a c5 40			ld a, (.dmark+1)  
40b9 32 78 fb			ld (debug_mark+1),a  
40bc 3a c6 40			ld a, (.dmark+2)  
40bf 32 79 fb			ld (debug_mark+2),a  
40c2 18 03			jr .pastdmark  
40c4 ..			.dmark: db "TCS"  
40c7 f1			.pastdmark: pop af  
40c8			endm  
# End of macro DMARK
40c8						CALLMONITOR 
40c8 cd 5a 17			call break_point_state  
40cb				endm  
# End of macro CALLMONITOR
40cb					endif 
40cb			 
40cb					FORTH_DSP 
40cb cd a7 1e			call macro_forth_dsp 
40ce				endm 
# End of macro FORTH_DSP
40ce					 
40ce			; TODO check is string type 
40ce			 
40ce					FORTH_DSP_VALUEHL 
40ce cd e1 1e			call macro_dsp_valuehl 
40d1				endm 
# End of macro FORTH_DSP_VALUEHL
40d1			; get pointer to string in hl 
40d1			 
40d1					if DEBUG_FORTH_WORDS 
40d1						DMARK "TC1" 
40d1 f5				push af  
40d2 3a e6 40			ld a, (.dmark)  
40d5 32 77 fb			ld (debug_mark),a  
40d8 3a e7 40			ld a, (.dmark+1)  
40db 32 78 fb			ld (debug_mark+1),a  
40de 3a e8 40			ld a, (.dmark+2)  
40e1 32 79 fb			ld (debug_mark+2),a  
40e4 18 03			jr .pastdmark  
40e6 ..			.dmark: db "TC1"  
40e9 f1			.pastdmark: pop af  
40ea			endm  
# End of macro DMARK
40ea						CALLMONITOR 
40ea cd 5a 17			call break_point_state  
40ed				endm  
# End of macro CALLMONITOR
40ed					endif 
40ed			 
40ed					; first time in turn to upper case first char 
40ed			 
40ed 7e					ld a, (hl) 
40ee c3 78 41				jp .totsiptou 
40f1			 
40f1			 
40f1 7e			.tot:		ld a, (hl) 
40f2 fe 00				cp 0 
40f4 ca bc 41				jp z, .totdone 
40f7			 
40f7					if DEBUG_FORTH_WORDS 
40f7						DMARK "TC2" 
40f7 f5				push af  
40f8 3a 0c 41			ld a, (.dmark)  
40fb 32 77 fb			ld (debug_mark),a  
40fe 3a 0d 41			ld a, (.dmark+1)  
4101 32 78 fb			ld (debug_mark+1),a  
4104 3a 0e 41			ld a, (.dmark+2)  
4107 32 79 fb			ld (debug_mark+2),a  
410a 18 03			jr .pastdmark  
410c ..			.dmark: db "TC2"  
410f f1			.pastdmark: pop af  
4110			endm  
# End of macro DMARK
4110						CALLMONITOR 
4110 cd 5a 17			call break_point_state  
4113				endm  
# End of macro CALLMONITOR
4113					endif 
4113					; check to see if current char is a space 
4113			 
4113 fe 20				cp ' ' 
4115 28 21				jr z, .totsp 
4117 cd 93 10				call to_lower 
411a					if DEBUG_FORTH_WORDS 
411a						DMARK "TC3" 
411a f5				push af  
411b 3a 2f 41			ld a, (.dmark)  
411e 32 77 fb			ld (debug_mark),a  
4121 3a 30 41			ld a, (.dmark+1)  
4124 32 78 fb			ld (debug_mark+1),a  
4127 3a 31 41			ld a, (.dmark+2)  
412a 32 79 fb			ld (debug_mark+2),a  
412d 18 03			jr .pastdmark  
412f ..			.dmark: db "TC3"  
4132 f1			.pastdmark: pop af  
4133			endm  
# End of macro DMARK
4133						CALLMONITOR 
4133 cd 5a 17			call break_point_state  
4136				endm  
# End of macro CALLMONITOR
4136					endif 
4136 18 63				jr .totnxt 
4138			 
4138			.totsp:         ; on a space, find next char which should be upper 
4138			 
4138					if DEBUG_FORTH_WORDS 
4138						DMARK "TC4" 
4138 f5				push af  
4139 3a 4d 41			ld a, (.dmark)  
413c 32 77 fb			ld (debug_mark),a  
413f 3a 4e 41			ld a, (.dmark+1)  
4142 32 78 fb			ld (debug_mark+1),a  
4145 3a 4f 41			ld a, (.dmark+2)  
4148 32 79 fb			ld (debug_mark+2),a  
414b 18 03			jr .pastdmark  
414d ..			.dmark: db "TC4"  
4150 f1			.pastdmark: pop af  
4151			endm  
# End of macro DMARK
4151						CALLMONITOR 
4151 cd 5a 17			call break_point_state  
4154				endm  
# End of macro CALLMONITOR
4154					endif 
4154					;; 
4154			 
4154 fe 20				cp ' ' 
4156 20 20				jr nz, .totsiptou 
4158 23					inc hl 
4159 7e					ld a, (hl) 
415a					if DEBUG_FORTH_WORDS 
415a						DMARK "TC5" 
415a f5				push af  
415b 3a 6f 41			ld a, (.dmark)  
415e 32 77 fb			ld (debug_mark),a  
4161 3a 70 41			ld a, (.dmark+1)  
4164 32 78 fb			ld (debug_mark+1),a  
4167 3a 71 41			ld a, (.dmark+2)  
416a 32 79 fb			ld (debug_mark+2),a  
416d 18 03			jr .pastdmark  
416f ..			.dmark: db "TC5"  
4172 f1			.pastdmark: pop af  
4173			endm  
# End of macro DMARK
4173						CALLMONITOR 
4173 cd 5a 17			call break_point_state  
4176				endm  
# End of macro CALLMONITOR
4176					endif 
4176 18 c0				jr .totsp 
4178 fe 00		.totsiptou:    cp 0 
417a 28 40				jr z, .totdone 
417c					; not space and not zero term so upper case it 
417c cd 8a 10				call to_upper 
417f			 
417f					if DEBUG_FORTH_WORDS 
417f						DMARK "TC6" 
417f f5				push af  
4180 3a 94 41			ld a, (.dmark)  
4183 32 77 fb			ld (debug_mark),a  
4186 3a 95 41			ld a, (.dmark+1)  
4189 32 78 fb			ld (debug_mark+1),a  
418c 3a 96 41			ld a, (.dmark+2)  
418f 32 79 fb			ld (debug_mark+2),a  
4192 18 03			jr .pastdmark  
4194 ..			.dmark: db "TC6"  
4197 f1			.pastdmark: pop af  
4198			endm  
# End of macro DMARK
4198						CALLMONITOR 
4198 cd 5a 17			call break_point_state  
419b				endm  
# End of macro CALLMONITOR
419b					endif 
419b			 
419b			 
419b			.totnxt: 
419b			 
419b 77					ld (hl), a 
419c 23					inc hl 
419d					if DEBUG_FORTH_WORDS 
419d						DMARK "TC7" 
419d f5				push af  
419e 3a b2 41			ld a, (.dmark)  
41a1 32 77 fb			ld (debug_mark),a  
41a4 3a b3 41			ld a, (.dmark+1)  
41a7 32 78 fb			ld (debug_mark+1),a  
41aa 3a b4 41			ld a, (.dmark+2)  
41ad 32 79 fb			ld (debug_mark+2),a  
41b0 18 03			jr .pastdmark  
41b2 ..			.dmark: db "TC7"  
41b5 f1			.pastdmark: pop af  
41b6			endm  
# End of macro DMARK
41b6						CALLMONITOR 
41b6 cd 5a 17			call break_point_state  
41b9				endm  
# End of macro CALLMONITOR
41b9					endif 
41b9 c3 f1 40				jp .tot 
41bc			 
41bc					 
41bc			 
41bc			 
41bc			; for each char convert to low 
41bc					 
41bc			.totdone: 
41bc					if DEBUG_FORTH_WORDS 
41bc						DMARK "TCd" 
41bc f5				push af  
41bd 3a d1 41			ld a, (.dmark)  
41c0 32 77 fb			ld (debug_mark),a  
41c3 3a d2 41			ld a, (.dmark+1)  
41c6 32 78 fb			ld (debug_mark+1),a  
41c9 3a d3 41			ld a, (.dmark+2)  
41cc 32 79 fb			ld (debug_mark+2),a  
41cf 18 03			jr .pastdmark  
41d1 ..			.dmark: db "TCd"  
41d4 f1			.pastdmark: pop af  
41d5			endm  
# End of macro DMARK
41d5						CALLMONITOR 
41d5 cd 5a 17			call break_point_state  
41d8				endm  
# End of macro CALLMONITOR
41d8					endif 
41d8					NEXTW 
41d8 c3 53 20			jp macro_next 
41db				endm 
# End of macro NEXTW
41db			 
41db			.SUBSTR: 
41db				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
41db 48				db WORD_SYS_CORE+52             
41dc 39 42			dw .LEFT            
41de 07				db 6 + 1 
41df .. 00			db "SUBSTR",0              
41e6				endm 
# End of macro CWHEAD
41e6			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
41e6			 
41e6					if DEBUG_FORTH_WORDS_KEY 
41e6						DMARK "SST" 
41e6 f5				push af  
41e7 3a fb 41			ld a, (.dmark)  
41ea 32 77 fb			ld (debug_mark),a  
41ed 3a fc 41			ld a, (.dmark+1)  
41f0 32 78 fb			ld (debug_mark+1),a  
41f3 3a fd 41			ld a, (.dmark+2)  
41f6 32 79 fb			ld (debug_mark+2),a  
41f9 18 03			jr .pastdmark  
41fb ..			.dmark: db "SST"  
41fe f1			.pastdmark: pop af  
41ff			endm  
# End of macro DMARK
41ff						CALLMONITOR 
41ff cd 5a 17			call break_point_state  
4202				endm  
# End of macro CALLMONITOR
4202					endif 
4202			; TODO check string type 
4202					FORTH_DSP_VALUEHL 
4202 cd e1 1e			call macro_dsp_valuehl 
4205				endm 
# End of macro FORTH_DSP_VALUEHL
4205			 
4205 e5					push hl      ; string length 
4206			 
4206					FORTH_DSP_POP 
4206 cd 99 1f			call macro_forth_dsp_pop 
4209				endm 
# End of macro FORTH_DSP_POP
4209			 
4209					FORTH_DSP_VALUEHL 
4209 cd e1 1e			call macro_dsp_valuehl 
420c				endm 
# End of macro FORTH_DSP_VALUEHL
420c			 
420c e5					push hl     ; start char 
420d			 
420d					FORTH_DSP_POP 
420d cd 99 1f			call macro_forth_dsp_pop 
4210				endm 
# End of macro FORTH_DSP_POP
4210			 
4210			 
4210					FORTH_DSP_VALUE 
4210 cd ca 1e			call macro_forth_dsp_value 
4213				endm 
# End of macro FORTH_DSP_VALUE
4213			 
4213 d1					pop de    ; get start post offset 
4214			 
4214 19					add hl, de    ; starting offset 
4215			 
4215 c1					pop bc 
4216 c5					push bc      ; grab size of string 
4217			 
4217 e5					push hl    ; save string start  
4218			 
4218 26 00				ld h, 0 
421a 69					ld l, c 
421b 23					inc hl 
421c 23					inc hl 
421d			 
421d cd e4 11				call malloc 
4220				if DEBUG_FORTH_MALLOC_GUARD 
4220 cc f7 51				call z,malloc_error 
4223				endif 
4223			 
4223 eb					ex de, hl      ; save malloc area for string copy 
4224 e1					pop hl    ; get back source 
4225 c1					pop bc    ; get length of string back 
4226			 
4226 d5					push de    ; save malloc area for after we push 
4227 ed b0				ldir     ; copy substr 
4229			 
4229			 
4229 eb					ex de, hl 
422a 3e 00				ld a, 0 
422c 77					ld (hl), a   ; term substr 
422d			 
422d					 
422d e1					pop hl    ; get malloc so we can push it 
422e e5					push hl   ; save so we can free it afterwards 
422f			 
422f cd 58 1d				call forth_push_str 
4232			 
4232 e1					pop hl 
4233 cd ae 12				call free 
4236			 
4236					 
4236					 
4236			 
4236			 
4236					NEXTW 
4236 c3 53 20			jp macro_next 
4239				endm 
# End of macro NEXTW
4239			 
4239			.LEFT: 
4239				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
4239 48				db WORD_SYS_CORE+52             
423a 61 42			dw .RIGHT            
423c 05				db 4 + 1 
423d .. 00			db "LEFT",0              
4242				endm 
# End of macro CWHEAD
4242			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
4242					if DEBUG_FORTH_WORDS_KEY 
4242						DMARK "LEF" 
4242 f5				push af  
4243 3a 57 42			ld a, (.dmark)  
4246 32 77 fb			ld (debug_mark),a  
4249 3a 58 42			ld a, (.dmark+1)  
424c 32 78 fb			ld (debug_mark+1),a  
424f 3a 59 42			ld a, (.dmark+2)  
4252 32 79 fb			ld (debug_mark+2),a  
4255 18 03			jr .pastdmark  
4257 ..			.dmark: db "LEF"  
425a f1			.pastdmark: pop af  
425b			endm  
# End of macro DMARK
425b						CALLMONITOR 
425b cd 5a 17			call break_point_state  
425e				endm  
# End of macro CALLMONITOR
425e					endif 
425e			 
425e					NEXTW 
425e c3 53 20			jp macro_next 
4261				endm 
# End of macro NEXTW
4261			.RIGHT: 
4261				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
4261 48				db WORD_SYS_CORE+52             
4262 8a 42			dw .STR2NUM            
4264 06				db 5 + 1 
4265 .. 00			db "RIGHT",0              
426b				endm 
# End of macro CWHEAD
426b			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
426b					if DEBUG_FORTH_WORDS_KEY 
426b						DMARK "RIG" 
426b f5				push af  
426c 3a 80 42			ld a, (.dmark)  
426f 32 77 fb			ld (debug_mark),a  
4272 3a 81 42			ld a, (.dmark+1)  
4275 32 78 fb			ld (debug_mark+1),a  
4278 3a 82 42			ld a, (.dmark+2)  
427b 32 79 fb			ld (debug_mark+2),a  
427e 18 03			jr .pastdmark  
4280 ..			.dmark: db "RIG"  
4283 f1			.pastdmark: pop af  
4284			endm  
# End of macro DMARK
4284						CALLMONITOR 
4284 cd 5a 17			call break_point_state  
4287				endm  
# End of macro CALLMONITOR
4287					endif 
4287			 
4287					NEXTW 
4287 c3 53 20			jp macro_next 
428a				endm 
# End of macro NEXTW
428a			 
428a			 
428a			.STR2NUM: 
428a				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
428a 48				db WORD_SYS_CORE+52             
428b 16 43			dw .NUM2STR            
428d 08				db 7 + 1 
428e .. 00			db "STR2NUM",0              
4296				endm 
# End of macro CWHEAD
4296			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
4296			 
4296			 
4296			; TODO STR type check to do 
4296					if DEBUG_FORTH_WORDS_KEY 
4296						DMARK "S2N" 
4296 f5				push af  
4297 3a ab 42			ld a, (.dmark)  
429a 32 77 fb			ld (debug_mark),a  
429d 3a ac 42			ld a, (.dmark+1)  
42a0 32 78 fb			ld (debug_mark+1),a  
42a3 3a ad 42			ld a, (.dmark+2)  
42a6 32 79 fb			ld (debug_mark+2),a  
42a9 18 03			jr .pastdmark  
42ab ..			.dmark: db "S2N"  
42ae f1			.pastdmark: pop af  
42af			endm  
# End of macro DMARK
42af						CALLMONITOR 
42af cd 5a 17			call break_point_state  
42b2				endm  
# End of macro CALLMONITOR
42b2					endif 
42b2			 
42b2					;FORTH_DSP 
42b2					FORTH_DSP_VALUE 
42b2 cd ca 1e			call macro_forth_dsp_value 
42b5				endm 
# End of macro FORTH_DSP_VALUE
42b5					;inc hl 
42b5			 
42b5 eb					ex de, hl 
42b6					if DEBUG_FORTH_WORDS 
42b6						DMARK "S2a" 
42b6 f5				push af  
42b7 3a cb 42			ld a, (.dmark)  
42ba 32 77 fb			ld (debug_mark),a  
42bd 3a cc 42			ld a, (.dmark+1)  
42c0 32 78 fb			ld (debug_mark+1),a  
42c3 3a cd 42			ld a, (.dmark+2)  
42c6 32 79 fb			ld (debug_mark+2),a  
42c9 18 03			jr .pastdmark  
42cb ..			.dmark: db "S2a"  
42ce f1			.pastdmark: pop af  
42cf			endm  
# End of macro DMARK
42cf						CALLMONITOR 
42cf cd 5a 17			call break_point_state  
42d2				endm  
# End of macro CALLMONITOR
42d2					endif 
42d2 cd 12 11				call string_to_uint16 
42d5			 
42d5					if DEBUG_FORTH_WORDS 
42d5						DMARK "S2b" 
42d5 f5				push af  
42d6 3a ea 42			ld a, (.dmark)  
42d9 32 77 fb			ld (debug_mark),a  
42dc 3a eb 42			ld a, (.dmark+1)  
42df 32 78 fb			ld (debug_mark+1),a  
42e2 3a ec 42			ld a, (.dmark+2)  
42e5 32 79 fb			ld (debug_mark+2),a  
42e8 18 03			jr .pastdmark  
42ea ..			.dmark: db "S2b"  
42ed f1			.pastdmark: pop af  
42ee			endm  
# End of macro DMARK
42ee						CALLMONITOR 
42ee cd 5a 17			call break_point_state  
42f1				endm  
# End of macro CALLMONITOR
42f1					endif 
42f1			;		push hl 
42f1					FORTH_DSP_POP 
42f1 cd 99 1f			call macro_forth_dsp_pop 
42f4				endm 
# End of macro FORTH_DSP_POP
42f4			;		pop hl 
42f4					 
42f4					if DEBUG_FORTH_WORDS 
42f4						DMARK "S2b" 
42f4 f5				push af  
42f5 3a 09 43			ld a, (.dmark)  
42f8 32 77 fb			ld (debug_mark),a  
42fb 3a 0a 43			ld a, (.dmark+1)  
42fe 32 78 fb			ld (debug_mark+1),a  
4301 3a 0b 43			ld a, (.dmark+2)  
4304 32 79 fb			ld (debug_mark+2),a  
4307 18 03			jr .pastdmark  
4309 ..			.dmark: db "S2b"  
430c f1			.pastdmark: pop af  
430d			endm  
# End of macro DMARK
430d						CALLMONITOR 
430d cd 5a 17			call break_point_state  
4310				endm  
# End of macro CALLMONITOR
4310					endif 
4310 cd ea 1c				call forth_push_numhl	 
4313			 
4313				 
4313				       NEXTW 
4313 c3 53 20			jp macro_next 
4316				endm 
# End of macro NEXTW
4316			.NUM2STR: 
4316				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
4316 48				db WORD_SYS_CORE+52             
4317 25 43			dw .CONCAT            
4319 08				db 7 + 1 
431a .. 00			db "NUM2STR",0              
4322				endm 
# End of macro CWHEAD
4322			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
4322			 
4322			;		; malloc a string to target 
4322			;		ld hl, 10     ; TODO max string size should be fine 
4322			;		call malloc 
4322			;		push hl    ; save malloc location 
4322			; 
4322			; 
4322			;; TODO check int type 
4322			;		FORTH_DSP_VALUEHL 
4322			;		ld a, l 
4322			;		call DispAToASCII   
4322			;;TODO need to chage above call to dump into string 
4322			; 
4322			; 
4322			 
4322				       NEXTW 
4322 c3 53 20			jp macro_next 
4325				endm 
# End of macro NEXTW
4325			 
4325			.CONCAT: 
4325				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
4325 48				db WORD_SYS_CORE+52             
4326 d8 43			dw .FIND            
4328 07				db 6 + 1 
4329 .. 00			db "CONCAT",0              
4330				endm 
# End of macro CWHEAD
4330			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
4330			 
4330			; TODO check string type 
4330			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
4330			 
4330					if DEBUG_FORTH_WORDS_KEY 
4330						DMARK "CON" 
4330 f5				push af  
4331 3a 45 43			ld a, (.dmark)  
4334 32 77 fb			ld (debug_mark),a  
4337 3a 46 43			ld a, (.dmark+1)  
433a 32 78 fb			ld (debug_mark+1),a  
433d 3a 47 43			ld a, (.dmark+2)  
4340 32 79 fb			ld (debug_mark+2),a  
4343 18 03			jr .pastdmark  
4345 ..			.dmark: db "CON"  
4348 f1			.pastdmark: pop af  
4349			endm  
# End of macro DMARK
4349						CALLMONITOR 
4349 cd 5a 17			call break_point_state  
434c				endm  
# End of macro CALLMONITOR
434c					endif 
434c			 
434c			 
434c					FORTH_DSP_VALUE 
434c cd ca 1e			call macro_forth_dsp_value 
434f				endm 
# End of macro FORTH_DSP_VALUE
434f e5					push hl   ; s2 
4350			 
4350					FORTH_DSP_POP 
4350 cd 99 1f			call macro_forth_dsp_pop 
4353				endm 
# End of macro FORTH_DSP_POP
4353			 
4353					FORTH_DSP_VALUE 
4353 cd ca 1e			call macro_forth_dsp_value 
4356				endm 
# End of macro FORTH_DSP_VALUE
4356			 
4356 e5					push hl   ; s1 
4357			 
4357					FORTH_DSP_POP 
4357 cd 99 1f			call macro_forth_dsp_pop 
435a				endm 
# End of macro FORTH_DSP_POP
435a					 
435a			 
435a					; copy s1 
435a			 
435a				 
435a					; save ptr 
435a e1					pop hl  
435b e5					push hl 
435c 3e 00				ld a, 0 
435e cd 86 11				call strlent 
4361					;inc hl    ; zer0 
4361 06 00				ld b, 0 
4363 4d					ld c, l 
4364 e1					pop hl		 
4365 11 1d ee				ld de, scratch	 
4368					if DEBUG_FORTH_WORDS 
4368						DMARK "CO1" 
4368 f5				push af  
4369 3a 7d 43			ld a, (.dmark)  
436c 32 77 fb			ld (debug_mark),a  
436f 3a 7e 43			ld a, (.dmark+1)  
4372 32 78 fb			ld (debug_mark+1),a  
4375 3a 7f 43			ld a, (.dmark+2)  
4378 32 79 fb			ld (debug_mark+2),a  
437b 18 03			jr .pastdmark  
437d ..			.dmark: db "CO1"  
4380 f1			.pastdmark: pop af  
4381			endm  
# End of macro DMARK
4381						CALLMONITOR 
4381 cd 5a 17			call break_point_state  
4384				endm  
# End of macro CALLMONITOR
4384					endif 
4384 ed b0				ldir 
4386			 
4386 e1					pop hl 
4387 e5					push hl 
4388 d5					push de 
4389			 
4389			 
4389 3e 00				ld a, 0 
438b cd 86 11				call strlent 
438e 23					inc hl    ; zer0 
438f 23					inc hl 
4390 06 00				ld b, 0 
4392 4d					ld c, l 
4393 d1					pop de 
4394 e1					pop hl		 
4395					if DEBUG_FORTH_WORDS 
4395						DMARK "CO2" 
4395 f5				push af  
4396 3a aa 43			ld a, (.dmark)  
4399 32 77 fb			ld (debug_mark),a  
439c 3a ab 43			ld a, (.dmark+1)  
439f 32 78 fb			ld (debug_mark+1),a  
43a2 3a ac 43			ld a, (.dmark+2)  
43a5 32 79 fb			ld (debug_mark+2),a  
43a8 18 03			jr .pastdmark  
43aa ..			.dmark: db "CO2"  
43ad f1			.pastdmark: pop af  
43ae			endm  
# End of macro DMARK
43ae						CALLMONITOR 
43ae cd 5a 17			call break_point_state  
43b1				endm  
# End of macro CALLMONITOR
43b1					endif 
43b1 ed b0				ldir 
43b3			 
43b3			 
43b3			 
43b3 21 1d ee				ld hl, scratch 
43b6					if DEBUG_FORTH_WORDS 
43b6						DMARK "CO5" 
43b6 f5				push af  
43b7 3a cb 43			ld a, (.dmark)  
43ba 32 77 fb			ld (debug_mark),a  
43bd 3a cc 43			ld a, (.dmark+1)  
43c0 32 78 fb			ld (debug_mark+1),a  
43c3 3a cd 43			ld a, (.dmark+2)  
43c6 32 79 fb			ld (debug_mark+2),a  
43c9 18 03			jr .pastdmark  
43cb ..			.dmark: db "CO5"  
43ce f1			.pastdmark: pop af  
43cf			endm  
# End of macro DMARK
43cf						CALLMONITOR 
43cf cd 5a 17			call break_point_state  
43d2				endm  
# End of macro CALLMONITOR
43d2					endif 
43d2			 
43d2 cd 58 1d				call forth_push_str 
43d5			 
43d5			 
43d5			 
43d5			 
43d5				       NEXTW 
43d5 c3 53 20			jp macro_next 
43d8				endm 
# End of macro NEXTW
43d8			 
43d8			 
43d8			.FIND: 
43d8				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
43d8 4b				db WORD_SYS_CORE+55             
43d9 96 44			dw .LEN            
43db 05				db 4 + 1 
43dc .. 00			db "FIND",0              
43e1				endm 
# End of macro CWHEAD
43e1			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
43e1			 
43e1					if DEBUG_FORTH_WORDS_KEY 
43e1						DMARK "FND" 
43e1 f5				push af  
43e2 3a f6 43			ld a, (.dmark)  
43e5 32 77 fb			ld (debug_mark),a  
43e8 3a f7 43			ld a, (.dmark+1)  
43eb 32 78 fb			ld (debug_mark+1),a  
43ee 3a f8 43			ld a, (.dmark+2)  
43f1 32 79 fb			ld (debug_mark+2),a  
43f4 18 03			jr .pastdmark  
43f6 ..			.dmark: db "FND"  
43f9 f1			.pastdmark: pop af  
43fa			endm  
# End of macro DMARK
43fa						CALLMONITOR 
43fa cd 5a 17			call break_point_state  
43fd				endm  
# End of macro CALLMONITOR
43fd					endif 
43fd			 
43fd			; TODO check string type 
43fd					FORTH_DSP_VALUE 
43fd cd ca 1e			call macro_forth_dsp_value 
4400				endm 
# End of macro FORTH_DSP_VALUE
4400			 
4400 e5					push hl    
4401 7e					ld a,(hl)    ; char to find   
4402			; TODO change char to substr 
4402			 
4402 f5					push af 
4403					 
4403			 
4403			 
4403					if DEBUG_FORTH_WORDS 
4403						DMARK "FN1" 
4403 f5				push af  
4404 3a 18 44			ld a, (.dmark)  
4407 32 77 fb			ld (debug_mark),a  
440a 3a 19 44			ld a, (.dmark+1)  
440d 32 78 fb			ld (debug_mark+1),a  
4410 3a 1a 44			ld a, (.dmark+2)  
4413 32 79 fb			ld (debug_mark+2),a  
4416 18 03			jr .pastdmark  
4418 ..			.dmark: db "FN1"  
441b f1			.pastdmark: pop af  
441c			endm  
# End of macro DMARK
441c						CALLMONITOR 
441c cd 5a 17			call break_point_state  
441f				endm  
# End of macro CALLMONITOR
441f					endif 
441f			 
441f					FORTH_DSP_POP 
441f cd 99 1f			call macro_forth_dsp_pop 
4422				endm 
# End of macro FORTH_DSP_POP
4422			 
4422					; string to search 
4422			 
4422					FORTH_DSP_VALUE 
4422 cd ca 1e			call macro_forth_dsp_value 
4425				endm 
# End of macro FORTH_DSP_VALUE
4425			 
4425 d1					pop de  ; d is char to find  
4426			 
4426					if DEBUG_FORTH_WORDS 
4426						DMARK "FN2" 
4426 f5				push af  
4427 3a 3b 44			ld a, (.dmark)  
442a 32 77 fb			ld (debug_mark),a  
442d 3a 3c 44			ld a, (.dmark+1)  
4430 32 78 fb			ld (debug_mark+1),a  
4433 3a 3d 44			ld a, (.dmark+2)  
4436 32 79 fb			ld (debug_mark+2),a  
4439 18 03			jr .pastdmark  
443b ..			.dmark: db "FN2"  
443e f1			.pastdmark: pop af  
443f			endm  
# End of macro DMARK
443f						CALLMONITOR 
443f cd 5a 17			call break_point_state  
4442				endm  
# End of macro CALLMONITOR
4442					endif 
4442					 
4442 01 00 00				ld bc, 0 
4445 7e			.findchar:      ld a,(hl) 
4446 fe 00				cp 0   		 
4448 28 27				jr z, .finddone     
444a ba					cp d 
444b 28 20				jr z, .foundchar 
444d 03					inc bc 
444e 23					inc hl 
444f					if DEBUG_FORTH_WORDS 
444f						DMARK "FN3" 
444f f5				push af  
4450 3a 64 44			ld a, (.dmark)  
4453 32 77 fb			ld (debug_mark),a  
4456 3a 65 44			ld a, (.dmark+1)  
4459 32 78 fb			ld (debug_mark+1),a  
445c 3a 66 44			ld a, (.dmark+2)  
445f 32 79 fb			ld (debug_mark+2),a  
4462 18 03			jr .pastdmark  
4464 ..			.dmark: db "FN3"  
4467 f1			.pastdmark: pop af  
4468			endm  
# End of macro DMARK
4468						CALLMONITOR 
4468 cd 5a 17			call break_point_state  
446b				endm  
# End of macro CALLMONITOR
446b					endif 
446b 18 d8				jr .findchar 
446d			 
446d			 
446d c5			.foundchar:	push bc 
446e e1					pop hl 
446f 18 03				jr .findexit 
4471			 
4471			 
4471							 
4471			 
4471			.finddone:     ; got to end of string with no find 
4471 21 00 00				ld hl, 0 
4474			.findexit: 
4474			 
4474					if DEBUG_FORTH_WORDS 
4474						DMARK "FNd" 
4474 f5				push af  
4475 3a 89 44			ld a, (.dmark)  
4478 32 77 fb			ld (debug_mark),a  
447b 3a 8a 44			ld a, (.dmark+1)  
447e 32 78 fb			ld (debug_mark+1),a  
4481 3a 8b 44			ld a, (.dmark+2)  
4484 32 79 fb			ld (debug_mark+2),a  
4487 18 03			jr .pastdmark  
4489 ..			.dmark: db "FNd"  
448c f1			.pastdmark: pop af  
448d			endm  
# End of macro DMARK
448d						CALLMONITOR 
448d cd 5a 17			call break_point_state  
4490				endm  
# End of macro CALLMONITOR
4490					endif 
4490 cd ea 1c			call forth_push_numhl 
4493			 
4493				       NEXTW 
4493 c3 53 20			jp macro_next 
4496				endm 
# End of macro NEXTW
4496			 
4496			.LEN: 
4496				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
4496 4c				db WORD_SYS_CORE+56             
4497 cb 44			dw .CHAR            
4499 06				db 5 + 1 
449a .. 00			db "COUNT",0              
44a0				endm 
# End of macro CWHEAD
44a0			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
44a0			 
44a0					if DEBUG_FORTH_WORDS_KEY 
44a0						DMARK "CNT" 
44a0 f5				push af  
44a1 3a b5 44			ld a, (.dmark)  
44a4 32 77 fb			ld (debug_mark),a  
44a7 3a b6 44			ld a, (.dmark+1)  
44aa 32 78 fb			ld (debug_mark+1),a  
44ad 3a b7 44			ld a, (.dmark+2)  
44b0 32 79 fb			ld (debug_mark+2),a  
44b3 18 03			jr .pastdmark  
44b5 ..			.dmark: db "CNT"  
44b8 f1			.pastdmark: pop af  
44b9			endm  
# End of macro DMARK
44b9						CALLMONITOR 
44b9 cd 5a 17			call break_point_state  
44bc				endm  
# End of macro CALLMONITOR
44bc					endif 
44bc			; TODO check string type 
44bc					FORTH_DSP 
44bc cd a7 1e			call macro_forth_dsp 
44bf				endm 
# End of macro FORTH_DSP
44bf					;v5FORTH_DSP_VALUE 
44bf			 
44bf 23					inc hl 
44c0			 
44c0 3e 00				ld a, 0 
44c2 cd 86 11				call strlent 
44c5			 
44c5 cd ea 1c				call forth_push_numhl 
44c8			 
44c8			 
44c8			 
44c8				       NEXTW 
44c8 c3 53 20			jp macro_next 
44cb				endm 
# End of macro NEXTW
44cb			.CHAR: 
44cb				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
44cb 4d				db WORD_SYS_CORE+57             
44cc 01 45			dw .ENDSTR            
44ce 05				db 4 + 1 
44cf .. 00			db "CHAR",0              
44d4				endm 
# End of macro CWHEAD
44d4			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
44d4					if DEBUG_FORTH_WORDS_KEY 
44d4						DMARK "CHR" 
44d4 f5				push af  
44d5 3a e9 44			ld a, (.dmark)  
44d8 32 77 fb			ld (debug_mark),a  
44db 3a ea 44			ld a, (.dmark+1)  
44de 32 78 fb			ld (debug_mark+1),a  
44e1 3a eb 44			ld a, (.dmark+2)  
44e4 32 79 fb			ld (debug_mark+2),a  
44e7 18 03			jr .pastdmark  
44e9 ..			.dmark: db "CHR"  
44ec f1			.pastdmark: pop af  
44ed			endm  
# End of macro DMARK
44ed						CALLMONITOR 
44ed cd 5a 17			call break_point_state  
44f0				endm  
# End of macro CALLMONITOR
44f0					endif 
44f0					FORTH_DSP 
44f0 cd a7 1e			call macro_forth_dsp 
44f3				endm 
# End of macro FORTH_DSP
44f3					;v5 FORTH_DSP_VALUE 
44f3 23					inc hl      ; now at start of numeric as string 
44f4			 
44f4			;		push hl 
44f4			 
44f4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
44f4 cd 99 1f			call macro_forth_dsp_pop 
44f7				endm 
# End of macro FORTH_DSP_POP
44f7			 
44f7			;		pop hl 
44f7			 
44f7					; push the content of a onto the stack as a value 
44f7			 
44f7 7e					ld a,(hl)   ; get char 
44f8 26 00				ld h,0 
44fa 6f					ld l,a 
44fb cd ea 1c				call forth_push_numhl 
44fe			 
44fe				       NEXTW 
44fe c3 53 20			jp macro_next 
4501				endm 
# End of macro NEXTW
4501			 
4501			 
4501			 
4501			 
4501			.ENDSTR: 
4501			; eof 
4501			 
# End of file forth_words_str.asm
4501			include "forth_words_key.asm" 
4501			 
4501			; | ## Keyboard Words 
4501			 
4501			.KEY: 
4501				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
4501 3e				db WORD_SYS_CORE+42             
4502 31 45			dw .WAITK            
4504 04				db 3 + 1 
4505 .. 00			db "KEY",0              
4509				endm 
# End of macro CWHEAD
4509			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
4509			 
4509					if DEBUG_FORTH_WORDS_KEY 
4509						DMARK "KEY" 
4509 f5				push af  
450a 3a 1e 45			ld a, (.dmark)  
450d 32 77 fb			ld (debug_mark),a  
4510 3a 1f 45			ld a, (.dmark+1)  
4513 32 78 fb			ld (debug_mark+1),a  
4516 3a 20 45			ld a, (.dmark+2)  
4519 32 79 fb			ld (debug_mark+2),a  
451c 18 03			jr .pastdmark  
451e ..			.dmark: db "KEY"  
4521 f1			.pastdmark: pop af  
4522			endm  
# End of macro DMARK
4522						CALLMONITOR 
4522 cd 5a 17			call break_point_state  
4525				endm  
# End of macro CALLMONITOR
4525					endif 
4525			; TODO currently waits 
4525 cd 2a 69				call cin 
4528					;call cin_wait 
4528 6f					ld l, a 
4529 26 00				ld h, 0 
452b cd ea 1c				call forth_push_numhl 
452e					NEXTW 
452e c3 53 20			jp macro_next 
4531				endm 
# End of macro NEXTW
4531			.WAITK: 
4531				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4531 3f				db WORD_SYS_CORE+43             
4532 63 45			dw .ACCEPT            
4534 06				db 5 + 1 
4535 .. 00			db "WAITK",0              
453b				endm 
# End of macro CWHEAD
453b			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
453b					if DEBUG_FORTH_WORDS_KEY 
453b						DMARK "WAI" 
453b f5				push af  
453c 3a 50 45			ld a, (.dmark)  
453f 32 77 fb			ld (debug_mark),a  
4542 3a 51 45			ld a, (.dmark+1)  
4545 32 78 fb			ld (debug_mark+1),a  
4548 3a 52 45			ld a, (.dmark+2)  
454b 32 79 fb			ld (debug_mark+2),a  
454e 18 03			jr .pastdmark  
4550 ..			.dmark: db "WAI"  
4553 f1			.pastdmark: pop af  
4554			endm  
# End of macro DMARK
4554						CALLMONITOR 
4554 cd 5a 17			call break_point_state  
4557				endm  
# End of macro CALLMONITOR
4557					endif 
4557 cd 19 69				call cin_wait 
455a 6f					ld l, a 
455b 26 00				ld h, 0 
455d cd ea 1c				call forth_push_numhl 
4560					NEXTW 
4560 c3 53 20			jp macro_next 
4563				endm 
# End of macro NEXTW
4563			.ACCEPT: 
4563				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4563 40				db WORD_SYS_CORE+44             
4564 c1 45			dw .EDIT            
4566 07				db 6 + 1 
4567 .. 00			db "ACCEPT",0              
456e				endm 
# End of macro CWHEAD
456e			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
456e					; TODO crashes on push 
456e					if DEBUG_FORTH_WORDS_KEY 
456e						DMARK "ACC" 
456e f5				push af  
456f 3a 83 45			ld a, (.dmark)  
4572 32 77 fb			ld (debug_mark),a  
4575 3a 84 45			ld a, (.dmark+1)  
4578 32 78 fb			ld (debug_mark+1),a  
457b 3a 85 45			ld a, (.dmark+2)  
457e 32 79 fb			ld (debug_mark+2),a  
4581 18 03			jr .pastdmark  
4583 ..			.dmark: db "ACC"  
4586 f1			.pastdmark: pop af  
4587			endm  
# End of macro DMARK
4587						CALLMONITOR 
4587 cd 5a 17			call break_point_state  
458a				endm  
# End of macro CALLMONITOR
458a					endif 
458a 21 1b f0				ld hl, os_input 
458d 3e 00				ld a, 0 
458f 77					ld (hl),a 
4590 3a 46 f8				ld a,(f_cursor_ptr) 
4593 16 64				ld d, 100 
4595 0e 00				ld c, 0 
4597 1e 28				ld e, 40 
4599 cd 4a 0d				call input_str 
459c					; TODO perhaps do a type check and wrap in quotes if not a number 
459c 21 1b f0				ld hl, os_input 
459f					if DEBUG_FORTH_WORDS 
459f						DMARK "AC1" 
459f f5				push af  
45a0 3a b4 45			ld a, (.dmark)  
45a3 32 77 fb			ld (debug_mark),a  
45a6 3a b5 45			ld a, (.dmark+1)  
45a9 32 78 fb			ld (debug_mark+1),a  
45ac 3a b6 45			ld a, (.dmark+2)  
45af 32 79 fb			ld (debug_mark+2),a  
45b2 18 03			jr .pastdmark  
45b4 ..			.dmark: db "AC1"  
45b7 f1			.pastdmark: pop af  
45b8			endm  
# End of macro DMARK
45b8						CALLMONITOR 
45b8 cd 5a 17			call break_point_state  
45bb				endm  
# End of macro CALLMONITOR
45bb					endif 
45bb cd 58 1d				call forth_push_str 
45be					NEXTW 
45be c3 53 20			jp macro_next 
45c1				endm 
# End of macro NEXTW
45c1			 
45c1			.EDIT: 
45c1				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
45c1 40				db WORD_SYS_CORE+44             
45c2 63 46			dw .ENDKEY            
45c4 05				db 4 + 1 
45c5 .. 00			db "EDIT",0              
45ca				endm 
# End of macro CWHEAD
45ca			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
45ca			 
45ca					; TODO does not copy from stack 
45ca					if DEBUG_FORTH_WORDS_KEY 
45ca						DMARK "EDT" 
45ca f5				push af  
45cb 3a df 45			ld a, (.dmark)  
45ce 32 77 fb			ld (debug_mark),a  
45d1 3a e0 45			ld a, (.dmark+1)  
45d4 32 78 fb			ld (debug_mark+1),a  
45d7 3a e1 45			ld a, (.dmark+2)  
45da 32 79 fb			ld (debug_mark+2),a  
45dd 18 03			jr .pastdmark  
45df ..			.dmark: db "EDT"  
45e2 f1			.pastdmark: pop af  
45e3			endm  
# End of macro DMARK
45e3						CALLMONITOR 
45e3 cd 5a 17			call break_point_state  
45e6				endm  
# End of macro CALLMONITOR
45e6					endif 
45e6			 
45e6					;FORTH_DSP 
45e6					FORTH_DSP_VALUEHL 
45e6 cd e1 1e			call macro_dsp_valuehl 
45e9				endm 
# End of macro FORTH_DSP_VALUEHL
45e9			;		inc hl    ; TODO do type check 
45e9			 
45e9			;		call get_word_hl 
45e9 e5					push hl 
45ea					if DEBUG_FORTH_WORDS 
45ea						DMARK "EDp" 
45ea f5				push af  
45eb 3a ff 45			ld a, (.dmark)  
45ee 32 77 fb			ld (debug_mark),a  
45f1 3a 00 46			ld a, (.dmark+1)  
45f4 32 78 fb			ld (debug_mark+1),a  
45f7 3a 01 46			ld a, (.dmark+2)  
45fa 32 79 fb			ld (debug_mark+2),a  
45fd 18 03			jr .pastdmark  
45ff ..			.dmark: db "EDp"  
4602 f1			.pastdmark: pop af  
4603			endm  
# End of macro DMARK
4603						CALLMONITOR 
4603 cd 5a 17			call break_point_state  
4606				endm  
# End of macro CALLMONITOR
4606					endif 
4606				;	ld a, 0 
4606 cd 7b 11				call strlenz 
4609 23					inc hl 
460a			 
460a 06 00				ld b, 0 
460c 4d					ld c, l 
460d			 
460d e1					pop hl 
460e 11 1b f0				ld de, os_input 
4611					if DEBUG_FORTH_WORDS_KEY 
4611						DMARK "EDc" 
4611 f5				push af  
4612 3a 26 46			ld a, (.dmark)  
4615 32 77 fb			ld (debug_mark),a  
4618 3a 27 46			ld a, (.dmark+1)  
461b 32 78 fb			ld (debug_mark+1),a  
461e 3a 28 46			ld a, (.dmark+2)  
4621 32 79 fb			ld (debug_mark+2),a  
4624 18 03			jr .pastdmark  
4626 ..			.dmark: db "EDc"  
4629 f1			.pastdmark: pop af  
462a			endm  
# End of macro DMARK
462a						CALLMONITOR 
462a cd 5a 17			call break_point_state  
462d				endm  
# End of macro CALLMONITOR
462d					endif 
462d ed b0				ldir 
462f			 
462f			 
462f 21 1b f0				ld hl, os_input 
4632					;ld a, 0 
4632					;ld (hl),a 
4632 3a 46 f8				ld a,(f_cursor_ptr) 
4635 16 64				ld d, 100 
4637 0e 00				ld c, 0 
4639 1e 28				ld e, 40 
463b cd 4a 0d				call input_str 
463e					; TODO perhaps do a type check and wrap in quotes if not a number 
463e 21 1b f0				ld hl, os_input 
4641					if DEBUG_FORTH_WORDS 
4641						DMARK "ED1" 
4641 f5				push af  
4642 3a 56 46			ld a, (.dmark)  
4645 32 77 fb			ld (debug_mark),a  
4648 3a 57 46			ld a, (.dmark+1)  
464b 32 78 fb			ld (debug_mark+1),a  
464e 3a 58 46			ld a, (.dmark+2)  
4651 32 79 fb			ld (debug_mark+2),a  
4654 18 03			jr .pastdmark  
4656 ..			.dmark: db "ED1"  
4659 f1			.pastdmark: pop af  
465a			endm  
# End of macro DMARK
465a						CALLMONITOR 
465a cd 5a 17			call break_point_state  
465d				endm  
# End of macro CALLMONITOR
465d					endif 
465d cd 58 1d				call forth_push_str 
4660					NEXTW 
4660 c3 53 20			jp macro_next 
4663				endm 
# End of macro NEXTW
4663			 
4663			 
4663			 
4663			.ENDKEY: 
4663			; eof 
4663			 
# End of file forth_words_key.asm
4663			 
4663			if STORAGE_SE 
4663			   	include "forth_words_storage.asm" 
4663			 
4663			; | ## Fixed Storage Words 
4663			 
4663			 
4663			.BREAD: 
4663			  
4663				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
4663 3a				db WORD_SYS_CORE+38             
4664 e6 46			dw .BWRITE            
4666 06				db 5 + 1 
4667 .. 00			db "BREAD",0              
466d				endm 
# End of macro CWHEAD
466d			; | BREAD ( u -- u ) With the current bank, read a block from block address u (1-512) and push to stack  | DONE 
466d				 
466d					if DEBUG_FORTH_WORDS_KEY 
466d						DMARK "BRD" 
466d f5				push af  
466e 3a 82 46			ld a, (.dmark)  
4671 32 77 fb			ld (debug_mark),a  
4674 3a 83 46			ld a, (.dmark+1)  
4677 32 78 fb			ld (debug_mark+1),a  
467a 3a 84 46			ld a, (.dmark+2)  
467d 32 79 fb			ld (debug_mark+2),a  
4680 18 03			jr .pastdmark  
4682 ..			.dmark: db "BRD"  
4685 f1			.pastdmark: pop af  
4686			endm  
# End of macro DMARK
4686						CALLMONITOR 
4686 cd 5a 17			call break_point_state  
4689				endm  
# End of macro CALLMONITOR
4689					endif 
4689			 
4689				FORTH_DSP_VALUEHL 
4689 cd e1 1e			call macro_dsp_valuehl 
468c				endm 
# End of macro FORTH_DSP_VALUEHL
468c			 
468c				FORTH_DSP_POP 
468c cd 99 1f			call macro_forth_dsp_pop 
468f				endm 
# End of macro FORTH_DSP_POP
468f			 
468f				; calc block address 
468f			 
468f eb				ex de, hl 
4690 3e 40			ld a, STORE_BLOCK_PHY 
4692 cd a0 0c			call Mult16 
4695			 
4695			 
4695 11 62 f8			ld de, store_page 
4698			 
4698					if DEBUG_FORTH_WORDS 
4698						DMARK "BR1" 
4698 f5				push af  
4699 3a ad 46			ld a, (.dmark)  
469c 32 77 fb			ld (debug_mark),a  
469f 3a ae 46			ld a, (.dmark+1)  
46a2 32 78 fb			ld (debug_mark+1),a  
46a5 3a af 46			ld a, (.dmark+2)  
46a8 32 79 fb			ld (debug_mark+2),a  
46ab 18 03			jr .pastdmark  
46ad ..			.dmark: db "BR1"  
46b0 f1			.pastdmark: pop af  
46b1			endm  
# End of macro DMARK
46b1						CALLMONITOR 
46b1 cd 5a 17			call break_point_state  
46b4				endm  
# End of macro CALLMONITOR
46b4					endif 
46b4			 
46b4 cd 0c 03			call storage_read_block 
46b7			 
46b7 cd 46 0d			call ishlzero 
46ba 20 05			jr nz, .brfound 
46bc			 
46bc cd ea 1c			call forth_push_numhl 
46bf 18 22			jr .brdone 
46c1			 
46c1			 
46c1			.brfound: 
46c1 21 64 f8		        ld hl, store_page+2 
46c4			 
46c4					if DEBUG_FORTH_WORDS 
46c4						DMARK "BR2" 
46c4 f5				push af  
46c5 3a d9 46			ld a, (.dmark)  
46c8 32 77 fb			ld (debug_mark),a  
46cb 3a da 46			ld a, (.dmark+1)  
46ce 32 78 fb			ld (debug_mark+1),a  
46d1 3a db 46			ld a, (.dmark+2)  
46d4 32 79 fb			ld (debug_mark+2),a  
46d7 18 03			jr .pastdmark  
46d9 ..			.dmark: db "BR2"  
46dc f1			.pastdmark: pop af  
46dd			endm  
# End of macro DMARK
46dd						CALLMONITOR 
46dd cd 5a 17			call break_point_state  
46e0				endm  
# End of macro CALLMONITOR
46e0					endif 
46e0			 
46e0 cd 58 1d			call forth_push_str 
46e3			 
46e3			 
46e3			.brdone: 
46e3			 
46e3					NEXTW 
46e3 c3 53 20			jp macro_next 
46e6				endm 
# End of macro NEXTW
46e6			.BWRITE: 
46e6				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
46e6 3a				db WORD_SYS_CORE+38             
46e7 7b 47			dw .BUPD            
46e9 07				db 6 + 1 
46ea .. 00			db "BWRITE",0              
46f1				endm 
# End of macro CWHEAD
46f1			; | BWRITE ( s u -- ) With the current bank, write the string s to address u | DONE 
46f1			 
46f1					if DEBUG_FORTH_WORDS_KEY 
46f1						DMARK "BWR" 
46f1 f5				push af  
46f2 3a 06 47			ld a, (.dmark)  
46f5 32 77 fb			ld (debug_mark),a  
46f8 3a 07 47			ld a, (.dmark+1)  
46fb 32 78 fb			ld (debug_mark+1),a  
46fe 3a 08 47			ld a, (.dmark+2)  
4701 32 79 fb			ld (debug_mark+2),a  
4704 18 03			jr .pastdmark  
4706 ..			.dmark: db "BWR"  
4709 f1			.pastdmark: pop af  
470a			endm  
# End of macro DMARK
470a						CALLMONITOR 
470a cd 5a 17			call break_point_state  
470d				endm  
# End of macro CALLMONITOR
470d					endif 
470d			 
470d				FORTH_DSP_VALUEHL 
470d cd e1 1e			call macro_dsp_valuehl 
4710				endm 
# End of macro FORTH_DSP_VALUEHL
4710			 
4710				; calc block address 
4710			 
4710 eb				ex de, hl 
4711 3e 40			ld a, STORE_BLOCK_PHY 
4713 cd a0 0c			call Mult16 
4716			 
4716 e5				push hl         ; address 
4717			 
4717				FORTH_DSP_POP 
4717 cd 99 1f			call macro_forth_dsp_pop 
471a				endm 
# End of macro FORTH_DSP_POP
471a			 
471a				FORTH_DSP_VALUEHL 
471a cd e1 1e			call macro_dsp_valuehl 
471d				endm 
# End of macro FORTH_DSP_VALUEHL
471d			 
471d				FORTH_DSP_POP 
471d cd 99 1f			call macro_forth_dsp_pop 
4720				endm 
# End of macro FORTH_DSP_POP
4720			 
4720 cd 2c 0a			call storage_clear_page 
4723			 
4723				; copy string to store page 
4723			 
4723 e5				push hl     ; save string address 
4724			 
4724 3e 00			ld a, 0 
4726 cd 86 11			call strlent 
4729			 
4729 23				inc hl 
472a			 
472a 4d				ld c, l 
472b 06 00			ld b, 0 
472d			 
472d e1				pop hl 
472e 11 64 f8			ld de, store_page + 2 
4731					if DEBUG_FORTH_WORDS 
4731						DMARK "BW1" 
4731 f5				push af  
4732 3a 46 47			ld a, (.dmark)  
4735 32 77 fb			ld (debug_mark),a  
4738 3a 47 47			ld a, (.dmark+1)  
473b 32 78 fb			ld (debug_mark+1),a  
473e 3a 48 47			ld a, (.dmark+2)  
4741 32 79 fb			ld (debug_mark+2),a  
4744 18 03			jr .pastdmark  
4746 ..			.dmark: db "BW1"  
4749 f1			.pastdmark: pop af  
474a			endm  
# End of macro DMARK
474a						CALLMONITOR 
474a cd 5a 17			call break_point_state  
474d				endm  
# End of macro CALLMONITOR
474d					endif 
474d ed b0			ldir 
474f			 
474f			 
474f				; poke the start of the block with flags to prevent high level file ops hitting the block 
474f			 
474f 21 ff ff			ld hl, $ffff 
4752			 
4752 22 62 f8			ld (store_page), hl	 
4755				 
4755 e1				pop hl    ; get address 
4756 11 62 f8			ld de, store_page 
4759			 
4759					if DEBUG_FORTH_WORDS 
4759						DMARK "BW2" 
4759 f5				push af  
475a 3a 6e 47			ld a, (.dmark)  
475d 32 77 fb			ld (debug_mark),a  
4760 3a 6f 47			ld a, (.dmark+1)  
4763 32 78 fb			ld (debug_mark+1),a  
4766 3a 70 47			ld a, (.dmark+2)  
4769 32 79 fb			ld (debug_mark+2),a  
476c 18 03			jr .pastdmark  
476e ..			.dmark: db "BW2"  
4771 f1			.pastdmark: pop af  
4772			endm  
# End of macro DMARK
4772						CALLMONITOR 
4772 cd 5a 17			call break_point_state  
4775				endm  
# End of macro CALLMONITOR
4775					endif 
4775			 
4775 cd 71 03			call storage_write_block 
4778			 
4778					NEXTW 
4778 c3 53 20			jp macro_next 
477b				endm 
# End of macro NEXTW
477b			 
477b			.BUPD: 
477b				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
477b 3a				db WORD_SYS_CORE+38             
477c d1 47			dw .BYID            
477e 05				db 4 + 1 
477f .. 00			db "BUPD",0              
4784				endm 
# End of macro CWHEAD
4784			; | BUPD ( u -- ) Write the contents of the current file system storage buffer directly to address u | DONE 
4784			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
4784			; | | or completely different file system structure. 
4784			 
4784					if DEBUG_FORTH_WORDS_KEY 
4784						DMARK "BUD" 
4784 f5				push af  
4785 3a 99 47			ld a, (.dmark)  
4788 32 77 fb			ld (debug_mark),a  
478b 3a 9a 47			ld a, (.dmark+1)  
478e 32 78 fb			ld (debug_mark+1),a  
4791 3a 9b 47			ld a, (.dmark+2)  
4794 32 79 fb			ld (debug_mark+2),a  
4797 18 03			jr .pastdmark  
4799 ..			.dmark: db "BUD"  
479c f1			.pastdmark: pop af  
479d			endm  
# End of macro DMARK
479d						CALLMONITOR 
479d cd 5a 17			call break_point_state  
47a0				endm  
# End of macro CALLMONITOR
47a0					endif 
47a0			 
47a0				FORTH_DSP_VALUEHL 
47a0 cd e1 1e			call macro_dsp_valuehl 
47a3				endm 
# End of macro FORTH_DSP_VALUEHL
47a3			 
47a3				; calc block address 
47a3			 
47a3 eb				ex de, hl 
47a4 3e 40			ld a, STORE_BLOCK_PHY 
47a6 cd a0 0c			call Mult16 
47a9			 
47a9				FORTH_DSP_POP 
47a9 cd 99 1f			call macro_forth_dsp_pop 
47ac				endm 
# End of macro FORTH_DSP_POP
47ac			 
47ac			 
47ac 11 62 f8			ld de, store_page 
47af			 
47af					if DEBUG_FORTH_WORDS 
47af						DMARK "BUe" 
47af f5				push af  
47b0 3a c4 47			ld a, (.dmark)  
47b3 32 77 fb			ld (debug_mark),a  
47b6 3a c5 47			ld a, (.dmark+1)  
47b9 32 78 fb			ld (debug_mark+1),a  
47bc 3a c6 47			ld a, (.dmark+2)  
47bf 32 79 fb			ld (debug_mark+2),a  
47c2 18 03			jr .pastdmark  
47c4 ..			.dmark: db "BUe"  
47c7 f1			.pastdmark: pop af  
47c8			endm  
# End of macro DMARK
47c8						CALLMONITOR 
47c8 cd 5a 17			call break_point_state  
47cb				endm  
# End of macro CALLMONITOR
47cb					endif 
47cb			 
47cb cd 71 03			call storage_write_block 
47ce			 
47ce					NEXTW 
47ce c3 53 20			jp macro_next 
47d1				endm 
# End of macro NEXTW
47d1			 
47d1			.BYID: 
47d1			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
47d1			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
47d1			; 
47d1			;		 
47d1			;		if DEBUG_FORTH_WORDS_KEY 
47d1			;			DMARK "BYID" 
47d1			;			CALLMONITOR 
47d1			;		endif 
47d1			; 
47d1			;		; get direct address 
47d1			; 
47d1			;		FORTH_DSP_VALUEHL 
47d1			; 
47d1			;		FORTH_DSP_POP 
47d1			; 
47d1			;	; calc block address 
47d1			; 
47d1			;	ex de, hl 
47d1			;	ld a, STORE_BLOCK_PHY 
47d1			;	call Mult16 
47d1			;	;	do BREAD with number as param 
47d1			;	; push the file name	 
47d1			;	ld de, store_page 
47d1			;	call storage_read_block 
47d1			 ;       ld hl, store_page+2 
47d1			; 
47d1			; 
47d1			;		NEXTW 
47d1			;.BYNAME: 
47d1			;	CWHEAD .DIR 38 "BYNAME" 6 WORD_FLAG_CODE 
47d1			;; > BYNAME ( s -- u ) Get the file ID in the current BANK of the file named s > TODO 
47d1			;		NEXTW 
47d1			; 
47d1			.DIR: 
47d1				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
47d1 3a				db WORD_SYS_CORE+38             
47d2 d5 48			dw .SAVE            
47d4 04				db 3 + 1 
47d5 .. 00			db "DIR",0              
47d9				endm 
# End of macro CWHEAD
47d9			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
47d9			 
47d9					if DEBUG_FORTH_WORDS_KEY 
47d9						DMARK "DIR" 
47d9 f5				push af  
47da 3a ee 47			ld a, (.dmark)  
47dd 32 77 fb			ld (debug_mark),a  
47e0 3a ef 47			ld a, (.dmark+1)  
47e3 32 78 fb			ld (debug_mark+1),a  
47e6 3a f0 47			ld a, (.dmark+2)  
47e9 32 79 fb			ld (debug_mark+2),a  
47ec 18 03			jr .pastdmark  
47ee ..			.dmark: db "DIR"  
47f1 f1			.pastdmark: pop af  
47f2			endm  
# End of macro DMARK
47f2						CALLMONITOR 
47f2 cd 5a 17			call break_point_state  
47f5				endm  
# End of macro CALLMONITOR
47f5					endif 
47f5 cd bd 03			call storage_get_block_0 
47f8			 
47f8 21 62 f8			ld hl, store_page     ; get current id count 
47fb 46				ld b, (hl) 
47fc 0e 00			ld c, 0    ; count of files   
47fe					if DEBUG_FORTH_WORDS 
47fe						DMARK "DI1" 
47fe f5				push af  
47ff 3a 13 48			ld a, (.dmark)  
4802 32 77 fb			ld (debug_mark),a  
4805 3a 14 48			ld a, (.dmark+1)  
4808 32 78 fb			ld (debug_mark+1),a  
480b 3a 15 48			ld a, (.dmark+2)  
480e 32 79 fb			ld (debug_mark+2),a  
4811 18 03			jr .pastdmark  
4813 ..			.dmark: db "DI1"  
4816 f1			.pastdmark: pop af  
4817			endm  
# End of macro DMARK
4817						CALLMONITOR 
4817 cd 5a 17			call break_point_state  
481a				endm  
# End of macro CALLMONITOR
481a					endif 
481a			 
481a				; check for empty drive 
481a			 
481a 3e 00			ld a, 0 
481c b8				cp b 
481d ca 8b 48			jp z, .dirdone 
4820			 
4820				; for each of the current ids do a search for them and if found push to stack 
4820			 
4820 c5			.diritem:	push bc 
4821 21 40 00				ld hl, STORE_BLOCK_PHY 
4824 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
4826 58					ld e,b 
4827			 
4827			;		if DEBUG_FORTH_WORDS 
4827			;			DMARK "DI2" 
4827			;			CALLMONITOR 
4827			;		endif 
4827			 
4827 cd 31 06				call storage_findnextid 
482a			 
482a			;		if DEBUG_FORTH_WORDS 
482a			;			DMARK "DI3" 
482a			;			CALLMONITOR 
482a			;		endif 
482a			 
482a					; if found hl will be non zero 
482a			 
482a cd 46 0d				call ishlzero 
482d			;		ld a, l 
482d			;		add h 
482d			; 
482d			;		cp 0 
482d 28 59				jr z, .dirnotfound 
482f			 
482f					; increase count 
482f			 
482f c1					pop bc	 
4830 0c					inc c 
4831 c5					push bc 
4832					 
4832			 
4832					; get file header and push the file name 
4832			 
4832 11 62 f8				ld de, store_page 
4835 cd 0c 03				call storage_read_block 
4838			 
4838					; push file id to stack 
4838				 
4838 3a 62 f8				ld a, (store_page) 
483b 26 00				ld h, 0 
483d 6f					ld l, a 
483e cd ea 1c				call forth_push_numhl 
4841			 
4841					; push extent count to stack  
4841				 
4841 3a 64 f8				ld a, (store_page+2) 
4844 26 00				ld h, 0 
4846 6f					ld l, a 
4847 cd ea 1c				call forth_push_numhl 
484a			 
484a					; push file name 
484a			 
484a 21 65 f8				ld hl, store_page+3 
484d					if DEBUG_FORTH_WORDS 
484d						DMARK "DI5" 
484d f5				push af  
484e 3a 62 48			ld a, (.dmark)  
4851 32 77 fb			ld (debug_mark),a  
4854 3a 63 48			ld a, (.dmark+1)  
4857 32 78 fb			ld (debug_mark+1),a  
485a 3a 64 48			ld a, (.dmark+2)  
485d 32 79 fb			ld (debug_mark+2),a  
4860 18 03			jr .pastdmark  
4862 ..			.dmark: db "DI5"  
4865 f1			.pastdmark: pop af  
4866			endm  
# End of macro DMARK
4866						CALLMONITOR 
4866 cd 5a 17			call break_point_state  
4869				endm  
# End of macro CALLMONITOR
4869					endif 
4869 cd 58 1d				call forth_push_str 
486c					if DEBUG_FORTH_WORDS 
486c						DMARK "DI6" 
486c f5				push af  
486d 3a 81 48			ld a, (.dmark)  
4870 32 77 fb			ld (debug_mark),a  
4873 3a 82 48			ld a, (.dmark+1)  
4876 32 78 fb			ld (debug_mark+1),a  
4879 3a 83 48			ld a, (.dmark+2)  
487c 32 79 fb			ld (debug_mark+2),a  
487f 18 03			jr .pastdmark  
4881 ..			.dmark: db "DI6"  
4884 f1			.pastdmark: pop af  
4885			endm  
# End of macro DMARK
4885						CALLMONITOR 
4885 cd 5a 17			call break_point_state  
4888				endm  
# End of macro CALLMONITOR
4888					endif 
4888			.dirnotfound: 
4888 c1					pop bc     
4889 10 95				djnz .diritem 
488b				 
488b			.dirdone:	 
488b					if DEBUG_FORTH_WORDS 
488b						DMARK "DI7" 
488b f5				push af  
488c 3a a0 48			ld a, (.dmark)  
488f 32 77 fb			ld (debug_mark),a  
4892 3a a1 48			ld a, (.dmark+1)  
4895 32 78 fb			ld (debug_mark+1),a  
4898 3a a2 48			ld a, (.dmark+2)  
489b 32 79 fb			ld (debug_mark+2),a  
489e 18 03			jr .pastdmark  
48a0 ..			.dmark: db "DI7"  
48a3 f1			.pastdmark: pop af  
48a4			endm  
# End of macro DMARK
48a4						CALLMONITOR 
48a4 cd 5a 17			call break_point_state  
48a7				endm  
# End of macro CALLMONITOR
48a7					endif 
48a7			 
48a7					; push a count of the dir items found 
48a7			 
48a7 26 00				ld h, 0 
48a9 69					ld l, c 
48aa cd ea 1c				call forth_push_numhl 
48ad			 
48ad					; push the bank label 
48ad			 
48ad cd bd 03				call storage_get_block_0 
48b0			 
48b0				 
48b0 21 65 f8		 		ld hl, store_page+3 
48b3			 
48b3					if DEBUG_FORTH_WORDS 
48b3						DMARK "DI8" 
48b3 f5				push af  
48b4 3a c8 48			ld a, (.dmark)  
48b7 32 77 fb			ld (debug_mark),a  
48ba 3a c9 48			ld a, (.dmark+1)  
48bd 32 78 fb			ld (debug_mark+1),a  
48c0 3a ca 48			ld a, (.dmark+2)  
48c3 32 79 fb			ld (debug_mark+2),a  
48c6 18 03			jr .pastdmark  
48c8 ..			.dmark: db "DI8"  
48cb f1			.pastdmark: pop af  
48cc			endm  
# End of macro DMARK
48cc						CALLMONITOR 
48cc cd 5a 17			call break_point_state  
48cf				endm  
# End of macro CALLMONITOR
48cf					endif 
48cf cd 58 1d				call forth_push_str 
48d2			 
48d2			 
48d2				 
48d2					NEXTW 
48d2 c3 53 20			jp macro_next 
48d5				endm 
# End of macro NEXTW
48d5			.SAVE: 
48d5			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
48d5			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
48d5			;		NEXTW 
48d5			;.LOAD: 
48d5			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
48d5			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
48d5			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
48d5			;; > > The LOAD command can not be used in any user words or compound lines. 
48d5			; 
48d5			;		; store_openext use it. If zero it is EOF 
48d5			; 
48d5			;		; read block from current stream id 
48d5			;		; if the block does not contain zero term keep reading blocks until zero found 
48d5			;		; push the block to stack 
48d5			;		; save the block id to stream 
48d5			; 
48d5			; 
48d5			;		FORTH_DSP_VALUEHL 
48d5			; 
48d5			;;		push hl 
48d5			; 
48d5			;	if DEBUG_STORESE 
48d5			;		DMARK "LOA" 
48d5			;		CALLMONITOR 
48d5			;	endif 
48d5			;		FORTH_DSP_POP 
48d5			; 
48d5			;;		pop hl 
48d5			; 
48d5			;		ld h, l 
48d5			;		ld l, 0 
48d5			; 
48d5			;		push hl     ; stack holds current file id and extent to work with 
48d5			; 
48d5			; 
48d5			;		ld de, store_page      ; get block zero of file 
48d5			;	if DEBUG_STORESE 
48d5			;		DMARK "LO0" 
48d5			;		CALLMONITOR 
48d5			;	endif 
48d5			;		call storage_read 
48d5			; 
48d5			;		ld a, (store_page+2)    ; max extents for this file 
48d5			;		ld  (store_openmaxext),a   ; get our limit 
48d5			; 
48d5			;	if DEBUG_STORESE 
48d5			;		DMARK "LOE" 
48d5			;		CALLMONITOR 
48d5			;	endif 
48d5			; 
48d5			;; TODO dont know why max extents are not present 
48d5			;;		cp 0 
48d5			;;		jp z, .loadeof     ; dont read past eof 
48d5			; 
48d5			;;		ld a, 1   ; start from the head of the file 
48d5			; 
48d5			;.loadline:	pop hl 
48d5			;		inc hl 
48d5			;		ld  a, (store_openmaxext)   ; get our limit 
48d5			;	if DEBUG_STORESE 
48d5			;		DMARK "LOx" 
48d5			;		CALLMONITOR 
48d5			;	endif 
48d5			;		inc a 
48d5			;		cp l 
48d5			;		jp z, .loadeof 
48d5			;		push hl    ; save current extent 
48d5			; 
48d5			;		ld de, store_page 
48d5			; 
48d5			;	if DEBUG_STORESE 
48d5			;		DMARK "LO1" 
48d5			;		CALLMONITOR 
48d5			;	endif 
48d5			;		call storage_read 
48d5			; 
48d5			;	if DEBUG_STORESE 
48d5			;		DMARK "LO2" 
48d5			;		CALLMONITOR 
48d5			;	endif 
48d5			;	call ishlzero 
48d5			;	ld a, l 
48d5			;	add h 
48d5			;	cp 0 
48d5			;	jr z, .loadeof 
48d5			; 
48d5			;	; not eof so hl should point to data to exec 
48d5			; 
48d5			;	; will need to add the FORTH_END_BUFFER flag 
48d5			 ; 
48d5			;	ld hl, store_page+2 
48d5			;	ld bc, 255 
48d5			;	ld a, 0 
48d5			;	cpir 
48d5			;	if DEBUG_STORESE 
48d5			;		DMARK "LOt" 
48d5			;		CALLMONITOR 
48d5			;	endif 
48d5			;	dec hl 
48d5			;	ld a, ' ' 
48d5			;	ld (hl), a 
48d5			;	inc hl 
48d5			;	ld (hl), a 
48d5			;	inc hl 
48d5			;	ld (hl), a 
48d5			;	inc hl 
48d5			;	ld a, FORTH_END_BUFFER 
48d5			;	ld (hl), a 
48d5			; 
48d5			;	; TODO handle more than a single block read 
48d5			; 
48d5			; 
48d5			;	ld hl, store_page+2 
48d5			; 
48d5			;	ld (os_tok_ptr), hl 
48d5			; 
48d5			;	if DEBUG_STORESE 
48d5			;		DMARK "LO3" 
48d5			;		CALLMONITOR 
48d5			;	endif 
48d5			; 
48d5			;	call forthparse 
48d5			;	call forthexec 
48d5			;	call forthexec_cleanup 
48d5			; 
48d5			;	; go to next extent 
48d5			; 
48d5			;	; get next block  or mark as eof 
48d5			;	jp .loadline 
48d5			; 
48d5			; 
48d5			; 
48d5			;	       NEXTW 
48d5			;.loadeof:	ld a, 0 
48d5			;		ld (store_openext), a 
48d5			; 
48d5			;	if DEBUG_STORESE 
48d5			;		DMARK "LOF" 
48d5			;		CALLMONITOR 
48d5			;	endif 
48d5			;		ret 
48d5			;		;NEXTW 
48d5			;.BSAVE:   
48d5			; 
48d5			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
48d5			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
48d5			;		NEXTW 
48d5			;.BLOAD: 
48d5			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
48d5			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
48d5			;		NEXTW 
48d5			;;;; counter gap 
48d5			 
48d5			 
48d5			.SEO: 
48d5				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
48d5 64				db WORD_SYS_CORE+80             
48d6 f4 48			dw .SEI            
48d8 04				db 3 + 1 
48d9 .. 00			db "SEO",0              
48dd				endm 
# End of macro CWHEAD
48dd			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
48dd			 
48dd					; get port 
48dd			 
48dd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
48dd cd e1 1e			call macro_dsp_valuehl 
48e0				endm 
# End of macro FORTH_DSP_VALUEHL
48e0			 
48e0 e5					push hl    ; u2 - byte 
48e1			 
48e1					; destroy value TOS 
48e1			 
48e1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
48e1 cd 99 1f			call macro_forth_dsp_pop 
48e4				endm 
# End of macro FORTH_DSP_POP
48e4			 
48e4					; get byte to send 
48e4			 
48e4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
48e4 cd e1 1e			call macro_dsp_valuehl 
48e7				endm 
# End of macro FORTH_DSP_VALUEHL
48e7			 
48e7 e5					push hl    ; u1 - addr 
48e8			 
48e8					; destroy value TOS 
48e8			 
48e8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
48e8 cd 99 1f			call macro_forth_dsp_pop 
48eb				endm 
# End of macro FORTH_DSP_POP
48eb			 
48eb					; one value on hl get other one back 
48eb			 
48eb d1					pop de   ; u1 - byte 
48ec			 
48ec e1					pop hl   ; u2 - addr 
48ed			 
48ed					; TODO Send SPI byte 
48ed			 
48ed			 
48ed 7b					ld a, e 
48ee cd ea 01				call se_writebyte 
48f1			 
48f1					 
48f1			 
48f1					NEXTW 
48f1 c3 53 20			jp macro_next 
48f4				endm 
# End of macro NEXTW
48f4			 
48f4			.SEI: 
48f4				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
48f4 65				db WORD_SYS_CORE+81             
48f5 0e 49			dw .SFREE            
48f7 04				db 3 + 1 
48f8 .. 00			db "SEI",0              
48fc				endm 
# End of macro CWHEAD
48fc			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
48fc			 
48fc					; get port 
48fc			 
48fc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
48fc cd e1 1e			call macro_dsp_valuehl 
48ff				endm 
# End of macro FORTH_DSP_VALUEHL
48ff			 
48ff			;		push hl 
48ff			 
48ff					; destroy value TOS 
48ff			 
48ff					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
48ff cd 99 1f			call macro_forth_dsp_pop 
4902				endm 
# End of macro FORTH_DSP_POP
4902			 
4902					; one value on hl get other one back 
4902			 
4902			;		pop hl 
4902			 
4902			 
4902					; TODO Get SPI byte 
4902			 
4902 cd 8c 02				call se_readbyte 
4905			 
4905 26 00				ld h, 0 
4907 6f					ld l, a 
4908 cd ea 1c				call forth_push_numhl 
490b			 
490b					NEXTW 
490b c3 53 20			jp macro_next 
490e				endm 
# End of macro NEXTW
490e			 
490e			.SFREE: 
490e				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
490e 67				db WORD_SYS_CORE+83             
490f 3d 49			dw .SIZE            
4911 06				db 5 + 1 
4912 .. 00			db "FFREE",0              
4918				endm 
# End of macro CWHEAD
4918			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
4918					if DEBUG_FORTH_WORDS_KEY 
4918						DMARK "FFR" 
4918 f5				push af  
4919 3a 2d 49			ld a, (.dmark)  
491c 32 77 fb			ld (debug_mark),a  
491f 3a 2e 49			ld a, (.dmark+1)  
4922 32 78 fb			ld (debug_mark+1),a  
4925 3a 2f 49			ld a, (.dmark+2)  
4928 32 79 fb			ld (debug_mark+2),a  
492b 18 03			jr .pastdmark  
492d ..			.dmark: db "FFR"  
4930 f1			.pastdmark: pop af  
4931			endm  
# End of macro DMARK
4931						CALLMONITOR 
4931 cd 5a 17			call break_point_state  
4934				endm  
# End of macro CALLMONITOR
4934					endif 
4934			 
4934 cd cb 06				call storage_freeblocks 
4937			 
4937 cd ea 1c				call forth_push_numhl 
493a			 
493a				       NEXTW 
493a c3 53 20			jp macro_next 
493d				endm 
# End of macro NEXTW
493d			.SIZE: 
493d				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
493d 67				db WORD_SYS_CORE+83             
493e 71 49			dw .CREATE            
4940 05				db 4 + 1 
4941 .. 00			db "SIZE",0              
4946				endm 
# End of macro CWHEAD
4946			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
4946					if DEBUG_FORTH_WORDS_KEY 
4946						DMARK "SIZ" 
4946 f5				push af  
4947 3a 5b 49			ld a, (.dmark)  
494a 32 77 fb			ld (debug_mark),a  
494d 3a 5c 49			ld a, (.dmark+1)  
4950 32 78 fb			ld (debug_mark+1),a  
4953 3a 5d 49			ld a, (.dmark+2)  
4956 32 79 fb			ld (debug_mark+2),a  
4959 18 03			jr .pastdmark  
495b ..			.dmark: db "SIZ"  
495e f1			.pastdmark: pop af  
495f			endm  
# End of macro DMARK
495f						CALLMONITOR 
495f cd 5a 17			call break_point_state  
4962				endm  
# End of macro CALLMONITOR
4962					endif 
4962			 
4962					FORTH_DSP_VALUEHL 
4962 cd e1 1e			call macro_dsp_valuehl 
4965				endm 
# End of macro FORTH_DSP_VALUEHL
4965			;		push hl 
4965					FORTH_DSP_POP 
4965 cd 99 1f			call macro_forth_dsp_pop 
4968				endm 
# End of macro FORTH_DSP_POP
4968			;		pop hl 
4968 cd 3b 03				call storage_file_size 
496b			 
496b cd ea 1c				call forth_push_numhl 
496e			  
496e			 
496e				       NEXTW 
496e c3 53 20			jp macro_next 
4971				endm 
# End of macro NEXTW
4971			 
4971			.CREATE: 
4971				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
4971 68				db WORD_SYS_CORE+84             
4972 df 49			dw .APPEND            
4974 07				db 6 + 1 
4975 .. 00			db "CREATE",0              
497c				endm 
# End of macro CWHEAD
497c			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
497c			; | | e.g.  
497c			; | | TestProgram CREATE 
497c			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
497c			; | |  
497c			; | | Max file IDs are 255. 
497c			; | |  
497c					 
497c					if DEBUG_FORTH_WORDS_KEY 
497c						DMARK "CRT" 
497c f5				push af  
497d 3a 91 49			ld a, (.dmark)  
4980 32 77 fb			ld (debug_mark),a  
4983 3a 92 49			ld a, (.dmark+1)  
4986 32 78 fb			ld (debug_mark+1),a  
4989 3a 93 49			ld a, (.dmark+2)  
498c 32 79 fb			ld (debug_mark+2),a  
498f 18 03			jr .pastdmark  
4991 ..			.dmark: db "CRT"  
4994 f1			.pastdmark: pop af  
4995			endm  
# End of macro DMARK
4995						CALLMONITOR 
4995 cd 5a 17			call break_point_state  
4998				endm  
# End of macro CALLMONITOR
4998					endif 
4998			;		call storage_get_block_0 
4998			 
4998					; TODO pop hl 
4998			 
4998					;v5 FORTH_DSP_VALUE 
4998					FORTH_DSP_VALUE 
4998 cd ca 1e			call macro_forth_dsp_value 
499b				endm 
# End of macro FORTH_DSP_VALUE
499b			 
499b				if DEBUG_STORESE 
499b					DMARK "CR1" 
499b f5				push af  
499c 3a b0 49			ld a, (.dmark)  
499f 32 77 fb			ld (debug_mark),a  
49a2 3a b1 49			ld a, (.dmark+1)  
49a5 32 78 fb			ld (debug_mark+1),a  
49a8 3a b2 49			ld a, (.dmark+2)  
49ab 32 79 fb			ld (debug_mark+2),a  
49ae 18 03			jr .pastdmark  
49b0 ..			.dmark: db "CR1"  
49b3 f1			.pastdmark: pop af  
49b4			endm  
# End of macro DMARK
49b4					CALLMONITOR 
49b4 cd 5a 17			call break_point_state  
49b7				endm  
# End of macro CALLMONITOR
49b7				endif 
49b7			;		push hl 
49b7			;		FORTH_DSP_POP 
49b7			;		pop hl 
49b7			 
49b7			;		inc hl   ; move past the type marker 
49b7			 
49b7 cd 01 07				call storage_create 
49ba			 
49ba				if DEBUG_STORESE 
49ba					DMARK "CT1" 
49ba f5				push af  
49bb 3a cf 49			ld a, (.dmark)  
49be 32 77 fb			ld (debug_mark),a  
49c1 3a d0 49			ld a, (.dmark+1)  
49c4 32 78 fb			ld (debug_mark+1),a  
49c7 3a d1 49			ld a, (.dmark+2)  
49ca 32 79 fb			ld (debug_mark+2),a  
49cd 18 03			jr .pastdmark  
49cf ..			.dmark: db "CT1"  
49d2 f1			.pastdmark: pop af  
49d3			endm  
# End of macro DMARK
49d3					CALLMONITOR 
49d3 cd 5a 17			call break_point_state  
49d6				endm  
# End of macro CALLMONITOR
49d6				endif 
49d6			;		push hl 
49d6					FORTH_DSP_POP 
49d6 cd 99 1f			call macro_forth_dsp_pop 
49d9				endm 
# End of macro FORTH_DSP_POP
49d9			;		pop hl 
49d9					; push file id to stack 
49d9 cd ea 1c				call forth_push_numhl 
49dc			 
49dc			 
49dc			 
49dc				       NEXTW 
49dc c3 53 20			jp macro_next 
49df				endm 
# End of macro NEXTW
49df			 
49df			.APPEND: 
49df				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
49df 69				db WORD_SYS_CORE+85             
49e0 70 4a			dw .SDEL            
49e2 07				db 6 + 1 
49e3 .. 00			db "APPEND",0              
49ea				endm 
# End of macro CWHEAD
49ea			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
49ea			; | | e.g. 
49ea			; | | Test CREATE      -> $01 
49ea			; | | "A string to add to file" $01 APPEND 
49ea			; | |  
49ea			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
49ea					if DEBUG_FORTH_WORDS_KEY 
49ea						DMARK "APP" 
49ea f5				push af  
49eb 3a ff 49			ld a, (.dmark)  
49ee 32 77 fb			ld (debug_mark),a  
49f1 3a 00 4a			ld a, (.dmark+1)  
49f4 32 78 fb			ld (debug_mark+1),a  
49f7 3a 01 4a			ld a, (.dmark+2)  
49fa 32 79 fb			ld (debug_mark+2),a  
49fd 18 03			jr .pastdmark  
49ff ..			.dmark: db "APP"  
4a02 f1			.pastdmark: pop af  
4a03			endm  
# End of macro DMARK
4a03						CALLMONITOR 
4a03 cd 5a 17			call break_point_state  
4a06				endm  
# End of macro CALLMONITOR
4a06					endif 
4a06			 
4a06					FORTH_DSP_VALUEHL 
4a06 cd e1 1e			call macro_dsp_valuehl 
4a09				endm 
# End of macro FORTH_DSP_VALUEHL
4a09 e5					push hl 	; save file id 
4a0a			 
4a0a				if DEBUG_STORESE 
4a0a					DMARK "AP1" 
4a0a f5				push af  
4a0b 3a 1f 4a			ld a, (.dmark)  
4a0e 32 77 fb			ld (debug_mark),a  
4a11 3a 20 4a			ld a, (.dmark+1)  
4a14 32 78 fb			ld (debug_mark+1),a  
4a17 3a 21 4a			ld a, (.dmark+2)  
4a1a 32 79 fb			ld (debug_mark+2),a  
4a1d 18 03			jr .pastdmark  
4a1f ..			.dmark: db "AP1"  
4a22 f1			.pastdmark: pop af  
4a23			endm  
# End of macro DMARK
4a23					CALLMONITOR 
4a23 cd 5a 17			call break_point_state  
4a26				endm  
# End of macro CALLMONITOR
4a26				endif 
4a26					FORTH_DSP_POP 
4a26 cd 99 1f			call macro_forth_dsp_pop 
4a29				endm 
# End of macro FORTH_DSP_POP
4a29			 
4a29					FORTH_DSP_VALUEHL 
4a29 cd e1 1e			call macro_dsp_valuehl 
4a2c				endm 
# End of macro FORTH_DSP_VALUEHL
4a2c					;v5 FORTH_DSP_VALUE 
4a2c e5					push hl 	; save ptr to string to save 
4a2d			 
4a2d				if DEBUG_STORESE 
4a2d					DMARK "AP1" 
4a2d f5				push af  
4a2e 3a 42 4a			ld a, (.dmark)  
4a31 32 77 fb			ld (debug_mark),a  
4a34 3a 43 4a			ld a, (.dmark+1)  
4a37 32 78 fb			ld (debug_mark+1),a  
4a3a 3a 44 4a			ld a, (.dmark+2)  
4a3d 32 79 fb			ld (debug_mark+2),a  
4a40 18 03			jr .pastdmark  
4a42 ..			.dmark: db "AP1"  
4a45 f1			.pastdmark: pop af  
4a46			endm  
# End of macro DMARK
4a46					CALLMONITOR 
4a46 cd 5a 17			call break_point_state  
4a49				endm  
# End of macro CALLMONITOR
4a49				endif 
4a49					FORTH_DSP_POP 
4a49 cd 99 1f			call macro_forth_dsp_pop 
4a4c				endm 
# End of macro FORTH_DSP_POP
4a4c			 
4a4c d1					pop de 
4a4d e1					pop hl 
4a4e				if DEBUG_STORESE 
4a4e					DMARK "AP2" 
4a4e f5				push af  
4a4f 3a 63 4a			ld a, (.dmark)  
4a52 32 77 fb			ld (debug_mark),a  
4a55 3a 64 4a			ld a, (.dmark+1)  
4a58 32 78 fb			ld (debug_mark+1),a  
4a5b 3a 65 4a			ld a, (.dmark+2)  
4a5e 32 79 fb			ld (debug_mark+2),a  
4a61 18 03			jr .pastdmark  
4a63 ..			.dmark: db "AP2"  
4a66 f1			.pastdmark: pop af  
4a67			endm  
# End of macro DMARK
4a67					CALLMONITOR 
4a67 cd 5a 17			call break_point_state  
4a6a				endm  
# End of macro CALLMONITOR
4a6a				endif 
4a6a					;inc de ; skip var type indicator 
4a6a			 
4a6a					; TODO how to append numerics???? 
4a6a			 
4a6a cd e0 08				call storage_append		 
4a6d			 
4a6d				       NEXTW 
4a6d c3 53 20			jp macro_next 
4a70				endm 
# End of macro NEXTW
4a70			.SDEL: 
4a70				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
4a70 6a				db WORD_SYS_CORE+86             
4a71 bc 4a			dw .OPEN            
4a73 05				db 4 + 1 
4a74 .. 00			db "ERA",0              
4a78				endm 
# End of macro CWHEAD
4a78			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
4a78					FORTH_DSP_VALUEHL 
4a78 cd e1 1e			call macro_dsp_valuehl 
4a7b				endm 
# End of macro FORTH_DSP_VALUEHL
4a7b			;		push hl 	; save file id 
4a7b			 
4a7b					if DEBUG_FORTH_WORDS_KEY 
4a7b						DMARK "ERA" 
4a7b f5				push af  
4a7c 3a 90 4a			ld a, (.dmark)  
4a7f 32 77 fb			ld (debug_mark),a  
4a82 3a 91 4a			ld a, (.dmark+1)  
4a85 32 78 fb			ld (debug_mark+1),a  
4a88 3a 92 4a			ld a, (.dmark+2)  
4a8b 32 79 fb			ld (debug_mark+2),a  
4a8e 18 03			jr .pastdmark  
4a90 ..			.dmark: db "ERA"  
4a93 f1			.pastdmark: pop af  
4a94			endm  
# End of macro DMARK
4a94						CALLMONITOR 
4a94 cd 5a 17			call break_point_state  
4a97				endm  
# End of macro CALLMONITOR
4a97					endif 
4a97				if DEBUG_STORESE 
4a97					DMARK "ER1" 
4a97 f5				push af  
4a98 3a ac 4a			ld a, (.dmark)  
4a9b 32 77 fb			ld (debug_mark),a  
4a9e 3a ad 4a			ld a, (.dmark+1)  
4aa1 32 78 fb			ld (debug_mark+1),a  
4aa4 3a ae 4a			ld a, (.dmark+2)  
4aa7 32 79 fb			ld (debug_mark+2),a  
4aaa 18 03			jr .pastdmark  
4aac ..			.dmark: db "ER1"  
4aaf f1			.pastdmark: pop af  
4ab0			endm  
# End of macro DMARK
4ab0					CALLMONITOR 
4ab0 cd 5a 17			call break_point_state  
4ab3				endm  
# End of macro CALLMONITOR
4ab3				endif 
4ab3					FORTH_DSP_POP 
4ab3 cd 99 1f			call macro_forth_dsp_pop 
4ab6				endm 
# End of macro FORTH_DSP_POP
4ab6			 
4ab6			;		pop hl 
4ab6			 
4ab6 cd 4c 05				call storage_erase 
4ab9				       NEXTW 
4ab9 c3 53 20			jp macro_next 
4abc				endm 
# End of macro NEXTW
4abc			 
4abc			.OPEN: 
4abc				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
4abc 6b				db WORD_SYS_CORE+87             
4abd 4c 4b			dw .READ            
4abf 05				db 4 + 1 
4ac0 .. 00			db "OPEN",0              
4ac5				endm 
# End of macro CWHEAD
4ac5			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
4ac5			; | | e.g. 
4ac5			; | | $01 OPEN $01 DO $01 READ . LOOP 
4ac5			; | | 
4ac5			; | | Will return with 255 blocks if the file does not exist 
4ac5			 
4ac5					if DEBUG_FORTH_WORDS_KEY 
4ac5						DMARK "OPN" 
4ac5 f5				push af  
4ac6 3a da 4a			ld a, (.dmark)  
4ac9 32 77 fb			ld (debug_mark),a  
4acc 3a db 4a			ld a, (.dmark+1)  
4acf 32 78 fb			ld (debug_mark+1),a  
4ad2 3a dc 4a			ld a, (.dmark+2)  
4ad5 32 79 fb			ld (debug_mark+2),a  
4ad8 18 03			jr .pastdmark  
4ada ..			.dmark: db "OPN"  
4add f1			.pastdmark: pop af  
4ade			endm  
# End of macro DMARK
4ade						CALLMONITOR 
4ade cd 5a 17			call break_point_state  
4ae1				endm  
# End of macro CALLMONITOR
4ae1					endif 
4ae1					; TODO handle multiple file opens 
4ae1			 
4ae1 3e 01			       	ld a, 1 
4ae3 32 59 f8				ld (store_openext), a 
4ae6			 
4ae6					; get max extents for this file 
4ae6				 
4ae6								 
4ae6					FORTH_DSP_VALUEHL 
4ae6 cd e1 1e			call macro_dsp_valuehl 
4ae9				endm 
# End of macro FORTH_DSP_VALUEHL
4ae9			 
4ae9 65					ld h, l 
4aea 2e 00				ld l, 0 
4aec			 
4aec				if DEBUG_STORESE 
4aec					DMARK "OPN" 
4aec f5				push af  
4aed 3a 01 4b			ld a, (.dmark)  
4af0 32 77 fb			ld (debug_mark),a  
4af3 3a 02 4b			ld a, (.dmark+1)  
4af6 32 78 fb			ld (debug_mark+1),a  
4af9 3a 03 4b			ld a, (.dmark+2)  
4afc 32 79 fb			ld (debug_mark+2),a  
4aff 18 03			jr .pastdmark  
4b01 ..			.dmark: db "OPN"  
4b04 f1			.pastdmark: pop af  
4b05			endm  
# End of macro DMARK
4b05					CALLMONITOR 
4b05 cd 5a 17			call break_point_state  
4b08				endm  
# End of macro CALLMONITOR
4b08				endif 
4b08			;		push hl 
4b08					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
4b08 cd 99 1f			call macro_forth_dsp_pop 
4b0b				endm 
# End of macro FORTH_DSP_POP
4b0b			;		pop hl 
4b0b						 
4b0b 11 62 f8				ld de, store_page      ; get block zero of file 
4b0e cd 57 08				call storage_read 
4b11 cd 46 0d			call ishlzero 
4b14 20 04			jr nz, .opfound 
4b16			 
4b16				; file does not exist so indicate with 255 extents in use 
4b16			 
4b16 3e ff			ld a, 255 
4b18 18 29			jr .skipopeneof 
4b1a			 
4b1a			 
4b1a			.opfound: 
4b1a			 
4b1a			 
4b1a 3a 64 f8				ld a, (store_page+2)    ; max extents for this file 
4b1d 32 58 f8				ld  (store_openmaxext), a   ; get our limit and push 
4b20					 
4b20				if DEBUG_STORESE 
4b20					DMARK "OPx" 
4b20 f5				push af  
4b21 3a 35 4b			ld a, (.dmark)  
4b24 32 77 fb			ld (debug_mark),a  
4b27 3a 36 4b			ld a, (.dmark+1)  
4b2a 32 78 fb			ld (debug_mark+1),a  
4b2d 3a 37 4b			ld a, (.dmark+2)  
4b30 32 79 fb			ld (debug_mark+2),a  
4b33 18 03			jr .pastdmark  
4b35 ..			.dmark: db "OPx"  
4b38 f1			.pastdmark: pop af  
4b39			endm  
# End of macro DMARK
4b39					CALLMONITOR 
4b39 cd 5a 17			call break_point_state  
4b3c				endm  
# End of macro CALLMONITOR
4b3c				endif 
4b3c fe 00				cp 0 
4b3e 20 03				jr nz, .skipopeneof 
4b40					; have opened an empty file 
4b40					 
4b40 32 59 f8				ld (store_openext), a 
4b43			 
4b43			.skipopeneof: 
4b43			 
4b43 6f					ld l, a 
4b44 26 00				ld h, 0 
4b46 cd ea 1c				call forth_push_numhl 
4b49			 
4b49			 
4b49				       NEXTW 
4b49 c3 53 20			jp macro_next 
4b4c				endm 
# End of macro NEXTW
4b4c			.READ: 
4b4c				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
4b4c 6c				db WORD_SYS_CORE+88             
4b4d 93 4c			dw .EOF            
4b4f 05				db 4 + 1 
4b50 .. 00			db "READ",0              
4b55				endm 
# End of macro CWHEAD
4b55			; | READ ( n -- n  )  Reads next page of file id and push to stack | DONE 
4b55			; | | e.g. 
4b55			; | | $01 OPEN $01 DO $01 READ . LOOP 
4b55			 
4b55					if DEBUG_FORTH_WORDS_KEY 
4b55						DMARK "REA" 
4b55 f5				push af  
4b56 3a 6a 4b			ld a, (.dmark)  
4b59 32 77 fb			ld (debug_mark),a  
4b5c 3a 6b 4b			ld a, (.dmark+1)  
4b5f 32 78 fb			ld (debug_mark+1),a  
4b62 3a 6c 4b			ld a, (.dmark+2)  
4b65 32 79 fb			ld (debug_mark+2),a  
4b68 18 03			jr .pastdmark  
4b6a ..			.dmark: db "REA"  
4b6d f1			.pastdmark: pop af  
4b6e			endm  
# End of macro DMARK
4b6e						CALLMONITOR 
4b6e cd 5a 17			call break_point_state  
4b71				endm  
# End of macro CALLMONITOR
4b71					endif 
4b71					; store_openext use it. If zero it is EOF 
4b71			 
4b71					; read block from current stream id 
4b71					; if the block does not contain zero term keep reading blocks until zero found 
4b71					; push the block to stack 
4b71					; save the block id to stream 
4b71			 
4b71			 
4b71					FORTH_DSP_VALUEHL 
4b71 cd e1 1e			call macro_dsp_valuehl 
4b74				endm 
# End of macro FORTH_DSP_VALUEHL
4b74			 
4b74			;		push hl 
4b74			 
4b74				if DEBUG_STORESE 
4b74					DMARK "REA" 
4b74 f5				push af  
4b75 3a 89 4b			ld a, (.dmark)  
4b78 32 77 fb			ld (debug_mark),a  
4b7b 3a 8a 4b			ld a, (.dmark+1)  
4b7e 32 78 fb			ld (debug_mark+1),a  
4b81 3a 8b 4b			ld a, (.dmark+2)  
4b84 32 79 fb			ld (debug_mark+2),a  
4b87 18 03			jr .pastdmark  
4b89 ..			.dmark: db "REA"  
4b8c f1			.pastdmark: pop af  
4b8d			endm  
# End of macro DMARK
4b8d					CALLMONITOR 
4b8d cd 5a 17			call break_point_state  
4b90				endm  
# End of macro CALLMONITOR
4b90				endif 
4b90					FORTH_DSP_POP 
4b90 cd 99 1f			call macro_forth_dsp_pop 
4b93				endm 
# End of macro FORTH_DSP_POP
4b93			 
4b93			;		pop hl 
4b93				 
4b93 65					ld h,l 
4b94			 
4b94 3a 59 f8				ld a, (store_openext) 
4b97 6f					ld l, a 
4b98					 
4b98 fe 00				cp 0 
4b9a ca 65 4c				jp z, .ateof     ; dont read past eof 
4b9d			 
4b9d			 
4b9d 11 62 f8				ld de, store_page 
4ba0				if DEBUG_STORESE 
4ba0					DMARK "RE1" 
4ba0 f5				push af  
4ba1 3a b5 4b			ld a, (.dmark)  
4ba4 32 77 fb			ld (debug_mark),a  
4ba7 3a b6 4b			ld a, (.dmark+1)  
4baa 32 78 fb			ld (debug_mark+1),a  
4bad 3a b7 4b			ld a, (.dmark+2)  
4bb0 32 79 fb			ld (debug_mark+2),a  
4bb3 18 03			jr .pastdmark  
4bb5 ..			.dmark: db "RE1"  
4bb8 f1			.pastdmark: pop af  
4bb9			endm  
# End of macro DMARK
4bb9					CALLMONITOR 
4bb9 cd 5a 17			call break_point_state  
4bbc				endm  
# End of macro CALLMONITOR
4bbc				endif 
4bbc cd 57 08				call storage_read 
4bbf			 
4bbf				if DEBUG_STORESE 
4bbf					DMARK "RE2" 
4bbf f5				push af  
4bc0 3a d4 4b			ld a, (.dmark)  
4bc3 32 77 fb			ld (debug_mark),a  
4bc6 3a d5 4b			ld a, (.dmark+1)  
4bc9 32 78 fb			ld (debug_mark+1),a  
4bcc 3a d6 4b			ld a, (.dmark+2)  
4bcf 32 79 fb			ld (debug_mark+2),a  
4bd2 18 03			jr .pastdmark  
4bd4 ..			.dmark: db "RE2"  
4bd7 f1			.pastdmark: pop af  
4bd8			endm  
# End of macro DMARK
4bd8					CALLMONITOR 
4bd8 cd 5a 17			call break_point_state  
4bdb				endm  
# End of macro CALLMONITOR
4bdb				endif 
4bdb cd 46 0d			call ishlzero 
4bde			;	ld a, l 
4bde			;	add h 
4bde			;	cp 0 
4bde ca 6b 4c			jp z, .readeof 
4be1			 
4be1				; not eof so hl should point to data to push to stack 
4be1			 
4be1				if DEBUG_STORESE 
4be1					DMARK "RE3" 
4be1 f5				push af  
4be2 3a f6 4b			ld a, (.dmark)  
4be5 32 77 fb			ld (debug_mark),a  
4be8 3a f7 4b			ld a, (.dmark+1)  
4beb 32 78 fb			ld (debug_mark+1),a  
4bee 3a f8 4b			ld a, (.dmark+2)  
4bf1 32 79 fb			ld (debug_mark+2),a  
4bf4 18 03			jr .pastdmark  
4bf6 ..			.dmark: db "RE3"  
4bf9 f1			.pastdmark: pop af  
4bfa			endm  
# End of macro DMARK
4bfa					CALLMONITOR 
4bfa cd 5a 17			call break_point_state  
4bfd				endm  
# End of macro CALLMONITOR
4bfd				endif 
4bfd cd 58 1d			call forth_push_str 
4c00			 
4c00				if DEBUG_STORESE 
4c00					DMARK "RE4" 
4c00 f5				push af  
4c01 3a 15 4c			ld a, (.dmark)  
4c04 32 77 fb			ld (debug_mark),a  
4c07 3a 16 4c			ld a, (.dmark+1)  
4c0a 32 78 fb			ld (debug_mark+1),a  
4c0d 3a 17 4c			ld a, (.dmark+2)  
4c10 32 79 fb			ld (debug_mark+2),a  
4c13 18 03			jr .pastdmark  
4c15 ..			.dmark: db "RE4"  
4c18 f1			.pastdmark: pop af  
4c19			endm  
# End of macro DMARK
4c19					CALLMONITOR 
4c19 cd 5a 17			call break_point_state  
4c1c				endm  
# End of macro CALLMONITOR
4c1c				endif 
4c1c				; get next block  or mark as eof 
4c1c			 
4c1c 3a 58 f8			ld a, (store_openmaxext)   ; get our limit 
4c1f 4f				ld c, a	 
4c20 3a 59 f8			ld a, (store_openext) 
4c23			 
4c23				if DEBUG_STORESE 
4c23					DMARK "RE5" 
4c23 f5				push af  
4c24 3a 38 4c			ld a, (.dmark)  
4c27 32 77 fb			ld (debug_mark),a  
4c2a 3a 39 4c			ld a, (.dmark+1)  
4c2d 32 78 fb			ld (debug_mark+1),a  
4c30 3a 3a 4c			ld a, (.dmark+2)  
4c33 32 79 fb			ld (debug_mark+2),a  
4c36 18 03			jr .pastdmark  
4c38 ..			.dmark: db "RE5"  
4c3b f1			.pastdmark: pop af  
4c3c			endm  
# End of macro DMARK
4c3c					CALLMONITOR 
4c3c cd 5a 17			call break_point_state  
4c3f				endm  
# End of macro CALLMONITOR
4c3f				endif 
4c3f b9				cp c 
4c40 28 29			jr z, .readeof     ; at last extent 
4c42			 
4c42 3c					inc a 
4c43 32 59 f8				ld (store_openext), a 
4c46			 
4c46				if DEBUG_STORESE 
4c46					DMARK "RE6" 
4c46 f5				push af  
4c47 3a 5b 4c			ld a, (.dmark)  
4c4a 32 77 fb			ld (debug_mark),a  
4c4d 3a 5c 4c			ld a, (.dmark+1)  
4c50 32 78 fb			ld (debug_mark+1),a  
4c53 3a 5d 4c			ld a, (.dmark+2)  
4c56 32 79 fb			ld (debug_mark+2),a  
4c59 18 03			jr .pastdmark  
4c5b ..			.dmark: db "RE6"  
4c5e f1			.pastdmark: pop af  
4c5f			endm  
# End of macro DMARK
4c5f					CALLMONITOR 
4c5f cd 5a 17			call break_point_state  
4c62				endm  
# End of macro CALLMONITOR
4c62				endif 
4c62			 
4c62			 
4c62				       NEXTW 
4c62 c3 53 20			jp macro_next 
4c65				endm 
# End of macro NEXTW
4c65			.ateof: 
4c65 21 8f 4c				ld hl, .showeof 
4c68 cd 58 1d				call forth_push_str 
4c6b 3e 00		.readeof:	ld a, 0 
4c6d 32 59 f8				ld (store_openext), a 
4c70			 
4c70					 
4c70				if DEBUG_STORESE 
4c70					DMARK "REF" 
4c70 f5				push af  
4c71 3a 85 4c			ld a, (.dmark)  
4c74 32 77 fb			ld (debug_mark),a  
4c77 3a 86 4c			ld a, (.dmark+1)  
4c7a 32 78 fb			ld (debug_mark+1),a  
4c7d 3a 87 4c			ld a, (.dmark+2)  
4c80 32 79 fb			ld (debug_mark+2),a  
4c83 18 03			jr .pastdmark  
4c85 ..			.dmark: db "REF"  
4c88 f1			.pastdmark: pop af  
4c89			endm  
# End of macro DMARK
4c89					CALLMONITOR 
4c89 cd 5a 17			call break_point_state  
4c8c				endm  
# End of macro CALLMONITOR
4c8c				endif 
4c8c				       NEXTW 
4c8c c3 53 20			jp macro_next 
4c8f				endm 
# End of macro NEXTW
4c8f			 
4c8f .. 00		.showeof:   db "eof", 0 
4c93			 
4c93			 
4c93			.EOF: 
4c93				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
4c93 6d				db WORD_SYS_CORE+89             
4c94 d4 4c			dw .FORMAT            
4c96 04				db 3 + 1 
4c97 .. 00			db "EOF",0              
4c9b				endm 
# End of macro CWHEAD
4c9b			; | EOF ( n -- u )  Returns EOF logical state of file id n - CURRENTLY n IS IGNORED AND ONLY ONE STREAM IS SUPPORTED | DONE 
4c9b			; | | e.g. 
4c9b			; | | $01 OPEN REPEAT $01 READ $01 EOF $00 IF LOOP 
4c9b					; TODO if current block id for stream is zero then push true else false 
4c9b			 
4c9b					if DEBUG_FORTH_WORDS_KEY 
4c9b						DMARK "EOF" 
4c9b f5				push af  
4c9c 3a b0 4c			ld a, (.dmark)  
4c9f 32 77 fb			ld (debug_mark),a  
4ca2 3a b1 4c			ld a, (.dmark+1)  
4ca5 32 78 fb			ld (debug_mark+1),a  
4ca8 3a b2 4c			ld a, (.dmark+2)  
4cab 32 79 fb			ld (debug_mark+2),a  
4cae 18 03			jr .pastdmark  
4cb0 ..			.dmark: db "EOF"  
4cb3 f1			.pastdmark: pop af  
4cb4			endm  
# End of macro DMARK
4cb4						CALLMONITOR 
4cb4 cd 5a 17			call break_point_state  
4cb7				endm  
# End of macro CALLMONITOR
4cb7					endif 
4cb7			 
4cb7					; TODO handlue multiple file streams 
4cb7			 
4cb7					FORTH_DSP_POP     ; for now just get rid of stream id 
4cb7 cd 99 1f			call macro_forth_dsp_pop 
4cba				endm 
# End of macro FORTH_DSP_POP
4cba			 
4cba 2e 01				ld l, 1 
4cbc 3a 58 f8				ld a, (store_openmaxext) 
4cbf fe 00				cp 0 
4cc1 28 09				jr  z, .eofdone   ; empty file 
4cc3 3a 59 f8				ld a, (store_openext) 
4cc6 fe 00				cp 0 
4cc8 28 02				jr  z, .eofdone 
4cca 2e 00				ld l, 0 
4ccc 26 00		.eofdone:	ld h, 0 
4cce cd ea 1c				call forth_push_numhl 
4cd1			 
4cd1			 
4cd1				       NEXTW 
4cd1 c3 53 20			jp macro_next 
4cd4				endm 
# End of macro NEXTW
4cd4			 
4cd4			.FORMAT: 
4cd4				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
4cd4 6d				db WORD_SYS_CORE+89             
4cd5 25 4d			dw .LABEL            
4cd7 07				db 6 + 1 
4cd8 .. 00			db "FORMAT",0              
4cdf				endm 
# End of macro CWHEAD
4cdf			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
4cdf					; TODO if current block id for stream is zero then push true else false 
4cdf				 
4cdf				if DEBUG_STORESE 
4cdf					DMARK "FOR" 
4cdf f5				push af  
4ce0 3a f4 4c			ld a, (.dmark)  
4ce3 32 77 fb			ld (debug_mark),a  
4ce6 3a f5 4c			ld a, (.dmark+1)  
4ce9 32 78 fb			ld (debug_mark+1),a  
4cec 3a f6 4c			ld a, (.dmark+2)  
4cef 32 79 fb			ld (debug_mark+2),a  
4cf2 18 03			jr .pastdmark  
4cf4 ..			.dmark: db "FOR"  
4cf7 f1			.pastdmark: pop af  
4cf8			endm  
# End of macro DMARK
4cf8					CALLMONITOR 
4cf8 cd 5a 17			call break_point_state  
4cfb				endm  
# End of macro CALLMONITOR
4cfb				endif 
4cfb					; Wipes the bank check flags to cause a reformat on next block 0 read 
4cfb			 
4cfb 21 01 00				ld hl, 1 
4cfe 3e 00				ld a, 0 
4d00 cd ea 01				call se_writebyte 
4d03			 
4d03				if DEBUG_STORESE 
4d03					DMARK "FO0" 
4d03 f5				push af  
4d04 3a 18 4d			ld a, (.dmark)  
4d07 32 77 fb			ld (debug_mark),a  
4d0a 3a 19 4d			ld a, (.dmark+1)  
4d0d 32 78 fb			ld (debug_mark+1),a  
4d10 3a 1a 4d			ld a, (.dmark+2)  
4d13 32 79 fb			ld (debug_mark+2),a  
4d16 18 03			jr .pastdmark  
4d18 ..			.dmark: db "FO0"  
4d1b f1			.pastdmark: pop af  
4d1c			endm  
# End of macro DMARK
4d1c					CALLMONITOR 
4d1c cd 5a 17			call break_point_state  
4d1f				endm  
# End of macro CALLMONITOR
4d1f				endif 
4d1f					; force bank init 
4d1f			 
4d1f cd bd 03				call storage_get_block_0 
4d22					 
4d22				       NEXTW 
4d22 c3 53 20			jp macro_next 
4d25				endm 
# End of macro NEXTW
4d25			.LABEL: 
4d25				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
4d25 6d				db WORD_SYS_CORE+89             
4d26 73 4d			dw .STOREPAGE            
4d28 06				db 5 + 1 
4d29 .. 00			db "LABEL",0              
4d2f				endm 
# End of macro CWHEAD
4d2f			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
4d2f					; TODO test to see if bank is selected 
4d2f				 
4d2f					if DEBUG_FORTH_WORDS_KEY 
4d2f						DMARK "LBL" 
4d2f f5				push af  
4d30 3a 44 4d			ld a, (.dmark)  
4d33 32 77 fb			ld (debug_mark),a  
4d36 3a 45 4d			ld a, (.dmark+1)  
4d39 32 78 fb			ld (debug_mark+1),a  
4d3c 3a 46 4d			ld a, (.dmark+2)  
4d3f 32 79 fb			ld (debug_mark+2),a  
4d42 18 03			jr .pastdmark  
4d44 ..			.dmark: db "LBL"  
4d47 f1			.pastdmark: pop af  
4d48			endm  
# End of macro DMARK
4d48						CALLMONITOR 
4d48 cd 5a 17			call break_point_state  
4d4b				endm  
# End of macro CALLMONITOR
4d4b					endif 
4d4b			;	if DEBUG_STORESE 
4d4b			;		DMARK "LBL" 
4d4b			;		CALLMONITOR 
4d4b			;	endif 
4d4b					FORTH_DSP_VALUEHL 
4d4b cd e1 1e			call macro_dsp_valuehl 
4d4e				endm 
# End of macro FORTH_DSP_VALUEHL
4d4e					;v5FORTH_DSP_VALUE 
4d4e					 
4d4e			;		push hl 
4d4e					FORTH_DSP_POP 
4d4e cd 99 1f			call macro_forth_dsp_pop 
4d51				endm 
# End of macro FORTH_DSP_POP
4d51			;		pop hl 
4d51			 
4d51			;v5		inc hl   ; move past the type marker 
4d51			 
4d51				if DEBUG_STORESE 
4d51					DMARK "LBl" 
4d51 f5				push af  
4d52 3a 66 4d			ld a, (.dmark)  
4d55 32 77 fb			ld (debug_mark),a  
4d58 3a 67 4d			ld a, (.dmark+1)  
4d5b 32 78 fb			ld (debug_mark+1),a  
4d5e 3a 68 4d			ld a, (.dmark+2)  
4d61 32 79 fb			ld (debug_mark+2),a  
4d64 18 03			jr .pastdmark  
4d66 ..			.dmark: db "LBl"  
4d69 f1			.pastdmark: pop af  
4d6a			endm  
# End of macro DMARK
4d6a					CALLMONITOR 
4d6a cd 5a 17			call break_point_state  
4d6d				endm  
# End of macro CALLMONITOR
4d6d				endif 
4d6d cd e1 04				call storage_label 
4d70			 
4d70				       NEXTW 
4d70 c3 53 20			jp macro_next 
4d73				endm 
# End of macro NEXTW
4d73			.STOREPAGE: 
4d73				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
4d73 6d				db WORD_SYS_CORE+89             
4d74 a6 4d			dw .LABELS            
4d76 0a				db 9 + 1 
4d77 .. 00			db "STOREPAGE",0              
4d81				endm 
# End of macro CWHEAD
4d81			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
4d81					; TODO test to see if bank is selected 
4d81				 
4d81					if DEBUG_FORTH_WORDS_KEY 
4d81						DMARK "STP" 
4d81 f5				push af  
4d82 3a 96 4d			ld a, (.dmark)  
4d85 32 77 fb			ld (debug_mark),a  
4d88 3a 97 4d			ld a, (.dmark+1)  
4d8b 32 78 fb			ld (debug_mark+1),a  
4d8e 3a 98 4d			ld a, (.dmark+2)  
4d91 32 79 fb			ld (debug_mark+2),a  
4d94 18 03			jr .pastdmark  
4d96 ..			.dmark: db "STP"  
4d99 f1			.pastdmark: pop af  
4d9a			endm  
# End of macro DMARK
4d9a						CALLMONITOR 
4d9a cd 5a 17			call break_point_state  
4d9d				endm  
# End of macro CALLMONITOR
4d9d					endif 
4d9d			;	if DEBUG_STORESE 
4d9d			;		DMARK "STP" 
4d9d			;		CALLMONITOR 
4d9d			;	endif 
4d9d			 
4d9d 21 62 f8			ld hl, store_page 
4da0 cd ea 1c			call forth_push_numhl 
4da3			 
4da3			 
4da3				       NEXTW 
4da3 c3 53 20			jp macro_next 
4da6				endm 
# End of macro NEXTW
4da6			.LABELS: 
4da6				CWHEAD .ENDSTORAGE 89 "LABELS" 6 WORD_FLAG_CODE 
4da6 6d				db WORD_SYS_CORE+89             
4da7 30 4e			dw .ENDSTORAGE            
4da9 07				db 6 + 1 
4daa .. 00			db "LABELS",0              
4db1				endm 
# End of macro CWHEAD
4db1			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | TO TEST 
4db1					;  
4db1			 
4db1					; save the current device selected to restore afterwards 
4db1				 
4db1 3a 48 f8				ld a, (spi_device) 
4db4 f5					push af 
4db5			 
4db5			 
4db5					; run through each of the banks 
4db5			 
4db5 21 01 00				ld hl, 1 
4db8 cd ea 1c				call forth_push_numhl 
4dbb 3e ff				ld a, SPI_CE_HIGH 
4dbd cb 87				res SPI_CE0, a 
4dbf 32 48 f8				ld (spi_device), a 
4dc2 cd bd 03				call storage_get_block_0 
4dc5 21 65 f8				ld hl, store_page+3 
4dc8 cd 58 1d				call forth_push_str 
4dcb			 
4dcb					 
4dcb 21 02 00				ld hl, 2 
4dce cd ea 1c				call forth_push_numhl 
4dd1 3e ff				ld a, SPI_CE_HIGH 
4dd3 cb 8f				res SPI_CE1, a 
4dd5 32 48 f8				ld (spi_device), a 
4dd8 cd bd 03				call storage_get_block_0 
4ddb 21 65 f8				ld hl, store_page+3 
4dde cd 58 1d				call forth_push_str 
4de1			 
4de1					 
4de1 21 03 00				ld hl, 3 
4de4 cd ea 1c				call forth_push_numhl 
4de7 3e ff				ld a, SPI_CE_HIGH 
4de9 cb 97				res SPI_CE2, a 
4deb 32 48 f8				ld (spi_device), a 
4dee cd bd 03				call storage_get_block_0 
4df1 21 65 f8				ld hl, store_page+3 
4df4 cd 58 1d				call forth_push_str 
4df7			 
4df7			 
4df7 21 04 00				ld hl, 4 
4dfa cd ea 1c				call forth_push_numhl 
4dfd 3e ff				ld a, SPI_CE_HIGH 
4dff cb 9f				res SPI_CE3, a 
4e01 32 48 f8				ld (spi_device), a 
4e04 cd bd 03				call storage_get_block_0 
4e07 21 65 f8				ld hl, store_page+3 
4e0a cd 58 1d				call forth_push_str 
4e0d			 
4e0d					 
4e0d			 
4e0d 21 05 00				ld hl, 5 
4e10 cd ea 1c				call forth_push_numhl 
4e13 3e ff				ld a, SPI_CE_HIGH 
4e15 cb a7				res SPI_CE4, a 
4e17 32 48 f8				ld (spi_device), a 
4e1a cd bd 03				call storage_get_block_0 
4e1d 21 65 f8				ld hl, store_page+3 
4e20 cd 58 1d				call forth_push_str 
4e23			 
4e23					 
4e23					; push fixed count of storage devices (on board) for now 
4e23			 
4e23 21 05 00				ld hl, 5 
4e26 cd ea 1c				call forth_push_numhl 
4e29			 
4e29					; restore selected device  
4e29				 
4e29 f1					pop af 
4e2a 32 48 f8				ld (spi_device), a 
4e2d			 
4e2d				       NEXTW 
4e2d c3 53 20			jp macro_next 
4e30				endm 
# End of macro NEXTW
4e30			 
4e30			.ENDSTORAGE: 
4e30			; eof 
# End of file forth_words_storage.asm
4e30			endif 
4e30				include "forth_words_device.asm" 
4e30			; Device related words 
4e30			 
4e30			; | ## Device Words 
4e30			 
4e30			if SOUND_ENABLE 
4e30			.NOTE: 
4e30				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
4e30 33				db WORD_SYS_CORE+31             
4e31 58 4e			dw .AFTERSOUND            
4e33 05				db 4 + 1 
4e34 .. 00			db "NOTE",0              
4e39				endm 
# End of macro CWHEAD
4e39			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
4e39					if DEBUG_FORTH_WORDS_KEY 
4e39						DMARK "NTE" 
4e39 f5				push af  
4e3a 3a 4e 4e			ld a, (.dmark)  
4e3d 32 77 fb			ld (debug_mark),a  
4e40 3a 4f 4e			ld a, (.dmark+1)  
4e43 32 78 fb			ld (debug_mark+1),a  
4e46 3a 50 4e			ld a, (.dmark+2)  
4e49 32 79 fb			ld (debug_mark+2),a  
4e4c 18 03			jr .pastdmark  
4e4e ..			.dmark: db "NTE"  
4e51 f1			.pastdmark: pop af  
4e52			endm  
# End of macro DMARK
4e52						CALLMONITOR 
4e52 cd 5a 17			call break_point_state  
4e55				endm  
# End of macro CALLMONITOR
4e55					endif 
4e55			 
4e55				 
4e55			 
4e55					NEXTW 
4e55 c3 53 20			jp macro_next 
4e58				endm 
# End of macro NEXTW
4e58			.AFTERSOUND: 
4e58			endif 
4e58			 
4e58			 
4e58			USE_GPIO: equ 0 
4e58			 
4e58			if USE_GPIO 
4e58			.GP1: 
4e58				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
4e58			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
4e58					NEXTW 
4e58			.GP2: 
4e58				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
4e58			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
4e58			 
4e58					NEXTW 
4e58			 
4e58			.GP3: 
4e58				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
4e58			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
4e58			 
4e58					NEXTW 
4e58			 
4e58			.GP4: 
4e58				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
4e58			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
4e58			 
4e58					NEXTW 
4e58			.SIN: 
4e58			 
4e58			 
4e58			endif 
4e58			 
4e58			 
4e58				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
4e58 33				db WORD_SYS_CORE+31             
4e59 8d 4e			dw .SOUT            
4e5b 03				db 2 + 1 
4e5c .. 00			db "IN",0              
4e5f				endm 
# End of macro CWHEAD
4e5f			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
4e5f					if DEBUG_FORTH_WORDS_KEY 
4e5f						DMARK "IN." 
4e5f f5				push af  
4e60 3a 74 4e			ld a, (.dmark)  
4e63 32 77 fb			ld (debug_mark),a  
4e66 3a 75 4e			ld a, (.dmark+1)  
4e69 32 78 fb			ld (debug_mark+1),a  
4e6c 3a 76 4e			ld a, (.dmark+2)  
4e6f 32 79 fb			ld (debug_mark+2),a  
4e72 18 03			jr .pastdmark  
4e74 ..			.dmark: db "IN."  
4e77 f1			.pastdmark: pop af  
4e78			endm  
# End of macro DMARK
4e78						CALLMONITOR 
4e78 cd 5a 17			call break_point_state  
4e7b				endm  
# End of macro CALLMONITOR
4e7b					endif 
4e7b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4e7b cd e1 1e			call macro_dsp_valuehl 
4e7e				endm 
# End of macro FORTH_DSP_VALUEHL
4e7e			 
4e7e e5					push hl 
4e7f			 
4e7f					; destroy value TOS 
4e7f			 
4e7f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4e7f cd 99 1f			call macro_forth_dsp_pop 
4e82				endm 
# End of macro FORTH_DSP_POP
4e82			 
4e82					; one value on hl get other one back 
4e82			 
4e82 c1					pop bc 
4e83			 
4e83					; do the sub 
4e83			;		ex de, hl 
4e83			 
4e83 ed 68				in l,(c) 
4e85			 
4e85					; save it 
4e85			 
4e85 26 00				ld h,0 
4e87			 
4e87					; TODO push value back onto stack for another op etc 
4e87			 
4e87 cd ea 1c				call forth_push_numhl 
4e8a					NEXTW 
4e8a c3 53 20			jp macro_next 
4e8d				endm 
# End of macro NEXTW
4e8d			.SOUT: 
4e8d				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
4e8d 34				db WORD_SYS_CORE+32             
4e8e e0 4e			dw .SPIO            
4e90 04				db 3 + 1 
4e91 .. 00			db "OUT",0              
4e95				endm 
# End of macro CWHEAD
4e95			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
4e95					if DEBUG_FORTH_WORDS_KEY 
4e95						DMARK "OUT" 
4e95 f5				push af  
4e96 3a aa 4e			ld a, (.dmark)  
4e99 32 77 fb			ld (debug_mark),a  
4e9c 3a ab 4e			ld a, (.dmark+1)  
4e9f 32 78 fb			ld (debug_mark+1),a  
4ea2 3a ac 4e			ld a, (.dmark+2)  
4ea5 32 79 fb			ld (debug_mark+2),a  
4ea8 18 03			jr .pastdmark  
4eaa ..			.dmark: db "OUT"  
4ead f1			.pastdmark: pop af  
4eae			endm  
# End of macro DMARK
4eae						CALLMONITOR 
4eae cd 5a 17			call break_point_state  
4eb1				endm  
# End of macro CALLMONITOR
4eb1					endif 
4eb1			 
4eb1					; get port 
4eb1			 
4eb1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4eb1 cd e1 1e			call macro_dsp_valuehl 
4eb4				endm 
# End of macro FORTH_DSP_VALUEHL
4eb4			 
4eb4 e5					push hl 
4eb5			 
4eb5					; destroy value TOS 
4eb5			 
4eb5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4eb5 cd 99 1f			call macro_forth_dsp_pop 
4eb8				endm 
# End of macro FORTH_DSP_POP
4eb8			 
4eb8					; get byte to send 
4eb8			 
4eb8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4eb8 cd e1 1e			call macro_dsp_valuehl 
4ebb				endm 
# End of macro FORTH_DSP_VALUEHL
4ebb			 
4ebb			;		push hl 
4ebb			 
4ebb					; destroy value TOS 
4ebb			 
4ebb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ebb cd 99 1f			call macro_forth_dsp_pop 
4ebe				endm 
# End of macro FORTH_DSP_POP
4ebe			 
4ebe					; one value on hl get other one back 
4ebe			 
4ebe			;		pop hl 
4ebe			 
4ebe c1					pop bc 
4ebf			 
4ebf					if DEBUG_FORTH_WORDS 
4ebf						DMARK "OUT" 
4ebf f5				push af  
4ec0 3a d4 4e			ld a, (.dmark)  
4ec3 32 77 fb			ld (debug_mark),a  
4ec6 3a d5 4e			ld a, (.dmark+1)  
4ec9 32 78 fb			ld (debug_mark+1),a  
4ecc 3a d6 4e			ld a, (.dmark+2)  
4ecf 32 79 fb			ld (debug_mark+2),a  
4ed2 18 03			jr .pastdmark  
4ed4 ..			.dmark: db "OUT"  
4ed7 f1			.pastdmark: pop af  
4ed8			endm  
# End of macro DMARK
4ed8						CALLMONITOR 
4ed8 cd 5a 17			call break_point_state  
4edb				endm  
# End of macro CALLMONITOR
4edb					endif 
4edb			 
4edb ed 69				out (c), l 
4edd			 
4edd					NEXTW 
4edd c3 53 20			jp macro_next 
4ee0				endm 
# End of macro NEXTW
4ee0			 
4ee0			 
4ee0			.SPIO: 
4ee0			 
4ee0			if STORAGE_SE 
4ee0				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
4ee0 51				db WORD_SYS_CORE+61             
4ee1 f1 4e			dw .SPICEH            
4ee3 07				db 6 + 1 
4ee4 .. 00			db "SPICEL",0              
4eeb				endm 
# End of macro CWHEAD
4eeb			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
4eeb			 
4eeb cd 98 01				call spi_ce_low 
4eee			    NEXTW 
4eee c3 53 20			jp macro_next 
4ef1				endm 
# End of macro NEXTW
4ef1			 
4ef1			.SPICEH: 
4ef1				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
4ef1 51				db WORD_SYS_CORE+61             
4ef2 02 4f			dw .SPIOb            
4ef4 07				db 6 + 1 
4ef5 .. 00			db "SPICEH",0              
4efc				endm 
# End of macro CWHEAD
4efc			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
4efc			 
4efc cd 87 01				call spi_ce_high 
4eff			    NEXTW 
4eff c3 53 20			jp macro_next 
4f02				endm 
# End of macro NEXTW
4f02			 
4f02			 
4f02			.SPIOb: 
4f02			 
4f02				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
4f02 51				db WORD_SYS_CORE+61             
4f03 18 4f			dw .SPII            
4f05 05				db 4 + 1 
4f06 .. 00			db "SPIO",0              
4f0b				endm 
# End of macro CWHEAD
4f0b			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
4f0b			 
4f0b					; get port 
4f0b			 
4f0b			 
4f0b					; get byte to send 
4f0b			 
4f0b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4f0b cd e1 1e			call macro_dsp_valuehl 
4f0e				endm 
# End of macro FORTH_DSP_VALUEHL
4f0e			 
4f0e			;		push hl    ; u1  
4f0e			 
4f0e					; destroy value TOS 
4f0e			 
4f0e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4f0e cd 99 1f			call macro_forth_dsp_pop 
4f11				endm 
# End of macro FORTH_DSP_POP
4f11			 
4f11					; one value on hl get other one back 
4f11			 
4f11			;		pop hl   ; u2 - addr 
4f11			 
4f11					; TODO Send SPI byte 
4f11			 
4f11 7d					ld a, l 
4f12 cd bc 00				call spi_send_byte 
4f15			 
4f15					NEXTW 
4f15 c3 53 20			jp macro_next 
4f18				endm 
# End of macro NEXTW
4f18			 
4f18			.SPII: 
4f18				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
4f18 52				db WORD_SYS_CORE+62             
4f19 2d 4f			dw .SESEL            
4f1b 06				db 5 + 1 
4f1c .. 00			db "SPII",0              
4f21				endm 
# End of macro CWHEAD
4f21			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
4f21			 
4f21					; TODO Get SPI byte 
4f21			 
4f21 cd dd 00				call spi_read_byte 
4f24			 
4f24 26 00				ld h, 0 
4f26 6f					ld l, a 
4f27 cd ea 1c				call forth_push_numhl 
4f2a			 
4f2a					NEXTW 
4f2a c3 53 20			jp macro_next 
4f2d				endm 
# End of macro NEXTW
4f2d			 
4f2d			 
4f2d			 
4f2d			.SESEL: 
4f2d				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
4f2d 66				db WORD_SYS_CORE+82             
4f2e d1 4f			dw .CARTDEV            
4f30 05				db 4 + 1 
4f31 .. 00			db "BANK",0              
4f36				endm 
# End of macro CWHEAD
4f36			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
4f36					if DEBUG_FORTH_WORDS_KEY 
4f36						DMARK "BNK" 
4f36 f5				push af  
4f37 3a 4b 4f			ld a, (.dmark)  
4f3a 32 77 fb			ld (debug_mark),a  
4f3d 3a 4c 4f			ld a, (.dmark+1)  
4f40 32 78 fb			ld (debug_mark+1),a  
4f43 3a 4d 4f			ld a, (.dmark+2)  
4f46 32 79 fb			ld (debug_mark+2),a  
4f49 18 03			jr .pastdmark  
4f4b ..			.dmark: db "BNK"  
4f4e f1			.pastdmark: pop af  
4f4f			endm  
# End of macro DMARK
4f4f						CALLMONITOR 
4f4f cd 5a 17			call break_point_state  
4f52				endm  
# End of macro CALLMONITOR
4f52					endif 
4f52			 
4f52 3e ff				ld a, 255 
4f54 32 4b f8				ld (spi_cartdev), a 
4f57			 
4f57					; get bank 
4f57			 
4f57					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4f57 cd e1 1e			call macro_dsp_valuehl 
4f5a				endm 
# End of macro FORTH_DSP_VALUEHL
4f5a			 
4f5a			;		push hl 
4f5a			 
4f5a					; destroy value TOS 
4f5a			 
4f5a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4f5a cd 99 1f			call macro_forth_dsp_pop 
4f5d				endm 
# End of macro FORTH_DSP_POP
4f5d			 
4f5d					; one value on hl get other one back 
4f5d			 
4f5d			;		pop hl 
4f5d			 
4f5d			 
4f5d 0e ff				ld c, SPI_CE_HIGH 
4f5f 06 30				ld b, '0'    ; human readable bank number 
4f61			 
4f61 7d					ld a, l 
4f62			 
4f62					if DEBUG_FORTH_WORDS 
4f62						DMARK "BNK" 
4f62 f5				push af  
4f63 3a 77 4f			ld a, (.dmark)  
4f66 32 77 fb			ld (debug_mark),a  
4f69 3a 78 4f			ld a, (.dmark+1)  
4f6c 32 78 fb			ld (debug_mark+1),a  
4f6f 3a 79 4f			ld a, (.dmark+2)  
4f72 32 79 fb			ld (debug_mark+2),a  
4f75 18 03			jr .pastdmark  
4f77 ..			.dmark: db "BNK"  
4f7a f1			.pastdmark: pop af  
4f7b			endm  
# End of macro DMARK
4f7b						CALLMONITOR 
4f7b cd 5a 17			call break_point_state  
4f7e				endm  
# End of macro CALLMONITOR
4f7e					endif 
4f7e			 
4f7e					; active low 
4f7e			 
4f7e fe 00				cp 0 
4f80 28 28				jr z, .bset 
4f82 fe 01				cp 1 
4f84 20 04				jr nz, .b2 
4f86 cb 81				res 0, c 
4f88 06 31				ld b, '1'    ; human readable bank number 
4f8a fe 02		.b2:		cp 2 
4f8c 20 04				jr nz, .b3 
4f8e cb 89				res 1, c 
4f90 06 32				ld b, '2'    ; human readable bank number 
4f92 fe 03		.b3:		cp 3 
4f94 20 04				jr nz, .b4 
4f96 cb 91				res 2, c 
4f98 06 33				ld b, '3'    ; human readable bank number 
4f9a fe 04		.b4:		cp 4 
4f9c 20 04				jr nz, .b5 
4f9e cb 99				res 3, c 
4fa0 06 34				ld b, '4'    ; human readable bank number 
4fa2 fe 05		.b5:		cp 5 
4fa4 20 04				jr nz, .bset 
4fa6 cb a1				res 4, c 
4fa8 06 35				ld b, '5'    ; human readable bank number 
4faa			 
4faa			.bset: 
4faa 79					ld a, c 
4fab 32 48 f8				ld (spi_device),a 
4fae 78					ld a, b 
4faf 32 47 f8				ld (spi_device_id),a 
4fb2					if DEBUG_FORTH_WORDS 
4fb2						DMARK "BN2" 
4fb2 f5				push af  
4fb3 3a c7 4f			ld a, (.dmark)  
4fb6 32 77 fb			ld (debug_mark),a  
4fb9 3a c8 4f			ld a, (.dmark+1)  
4fbc 32 78 fb			ld (debug_mark+1),a  
4fbf 3a c9 4f			ld a, (.dmark+2)  
4fc2 32 79 fb			ld (debug_mark+2),a  
4fc5 18 03			jr .pastdmark  
4fc7 ..			.dmark: db "BN2"  
4fca f1			.pastdmark: pop af  
4fcb			endm  
# End of macro DMARK
4fcb						CALLMONITOR 
4fcb cd 5a 17			call break_point_state  
4fce				endm  
# End of macro CALLMONITOR
4fce					endif 
4fce			 
4fce					NEXTW 
4fce c3 53 20			jp macro_next 
4fd1				endm 
# End of macro NEXTW
4fd1			 
4fd1			.CARTDEV: 
4fd1				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
4fd1 66				db WORD_SYS_CORE+82             
4fd2 7a 50			dw .ENDDEVICE            
4fd4 08				db 7 + 1 
4fd5 .. 00			db "CARTDEV",0              
4fdd				endm 
# End of macro CWHEAD
4fdd			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
4fdd					if DEBUG_FORTH_WORDS_KEY 
4fdd						DMARK "CDV" 
4fdd f5				push af  
4fde 3a f2 4f			ld a, (.dmark)  
4fe1 32 77 fb			ld (debug_mark),a  
4fe4 3a f3 4f			ld a, (.dmark+1)  
4fe7 32 78 fb			ld (debug_mark+1),a  
4fea 3a f4 4f			ld a, (.dmark+2)  
4fed 32 79 fb			ld (debug_mark+2),a  
4ff0 18 03			jr .pastdmark  
4ff2 ..			.dmark: db "CDV"  
4ff5 f1			.pastdmark: pop af  
4ff6			endm  
# End of macro DMARK
4ff6						CALLMONITOR 
4ff6 cd 5a 17			call break_point_state  
4ff9				endm  
# End of macro CALLMONITOR
4ff9					endif 
4ff9			 
4ff9					; disable se storage bank selection 
4ff9			 
4ff9 3e ff				ld a, SPI_CE_HIGH		; ce high 
4ffb 32 48 f8				ld (spi_device), a 
4ffe			 
4ffe					; get bank 
4ffe			 
4ffe					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4ffe cd e1 1e			call macro_dsp_valuehl 
5001				endm 
# End of macro FORTH_DSP_VALUEHL
5001			 
5001			;		push hl 
5001			 
5001					; destroy value TOS 
5001			 
5001					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5001 cd 99 1f			call macro_forth_dsp_pop 
5004				endm 
# End of macro FORTH_DSP_POP
5004			 
5004					; one value on hl get other one back 
5004			 
5004			;		pop hl 
5004			 
5004					; active low 
5004			 
5004 0e ff				ld c, 255 
5006			 
5006 7d					ld a, l 
5007					if DEBUG_FORTH_WORDS 
5007						DMARK "CDV" 
5007 f5				push af  
5008 3a 1c 50			ld a, (.dmark)  
500b 32 77 fb			ld (debug_mark),a  
500e 3a 1d 50			ld a, (.dmark+1)  
5011 32 78 fb			ld (debug_mark+1),a  
5014 3a 1e 50			ld a, (.dmark+2)  
5017 32 79 fb			ld (debug_mark+2),a  
501a 18 03			jr .pastdmark  
501c ..			.dmark: db "CDV"  
501f f1			.pastdmark: pop af  
5020			endm  
# End of macro DMARK
5020						CALLMONITOR 
5020 cd 5a 17			call break_point_state  
5023				endm  
# End of macro CALLMONITOR
5023					endif 
5023 fe 00				cp 0 
5025 28 30				jr z, .cset 
5027 fe 01				cp 1 
5029 20 02				jr nz, .c2 
502b cb 81				res 0, c 
502d fe 02		.c2:		cp 2 
502f 20 02				jr nz, .c3 
5031 cb 89				res 1, c 
5033 fe 03		.c3:		cp 3 
5035 20 02				jr nz, .c4 
5037 cb 91				res 2, c 
5039 fe 04		.c4:		cp 4 
503b 20 02				jr nz, .c5 
503d cb 99				res 3, c 
503f fe 05		.c5:		cp 5 
5041 20 02				jr nz, .c6 
5043 cb a1				res 4, c 
5045 fe 06		.c6:		cp 6 
5047 20 02				jr nz, .c7 
5049 cb a9				res 5, c 
504b fe 07		.c7:		cp 7 
504d 20 02				jr nz, .c8 
504f cb b1				res 6, c 
5051 fe 08		.c8:		cp 8 
5053 20 02				jr nz, .cset 
5055 cb b9				res 7, c 
5057 79			.cset:		ld a, c 
5058 32 4b f8				ld (spi_cartdev),a 
505b			 
505b					if DEBUG_FORTH_WORDS 
505b						DMARK "CD2" 
505b f5				push af  
505c 3a 70 50			ld a, (.dmark)  
505f 32 77 fb			ld (debug_mark),a  
5062 3a 71 50			ld a, (.dmark+1)  
5065 32 78 fb			ld (debug_mark+1),a  
5068 3a 72 50			ld a, (.dmark+2)  
506b 32 79 fb			ld (debug_mark+2),a  
506e 18 03			jr .pastdmark  
5070 ..			.dmark: db "CD2"  
5073 f1			.pastdmark: pop af  
5074			endm  
# End of macro DMARK
5074						CALLMONITOR 
5074 cd 5a 17			call break_point_state  
5077				endm  
# End of macro CALLMONITOR
5077					endif 
5077					NEXTW 
5077 c3 53 20			jp macro_next 
507a				endm 
# End of macro NEXTW
507a			endif 
507a			 
507a			.ENDDEVICE: 
507a			; eof 
507a			 
# End of file forth_words_device.asm
507a			 
507a			; var handler 
507a			 
507a			 
507a			.VARS: 
507a				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
507a 78				db WORD_SYS_CORE+100             
507b 92 50			dw .V0Q            
507d 04				db 3 + 1 
507e .. 00			db "V0!",0              
5082				endm 
# End of macro CWHEAD
5082			;| V0! ( u1 -- )  Store value to v0  | DONE 
5082			 
5082					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5082 cd e1 1e			call macro_dsp_valuehl 
5085				endm 
# End of macro FORTH_DSP_VALUEHL
5085			 
5085 11 10 f8				ld de, cli_var_array 
5088			 
5088 eb					ex de, hl 
5089 73					ld (hl), e 
508a 23					inc hl 
508b 72					ld (hl), d 
508c			 
508c					; destroy value TOS 
508c			 
508c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
508c cd 99 1f			call macro_forth_dsp_pop 
508f				endm 
# End of macro FORTH_DSP_POP
508f			 
508f				       NEXTW 
508f c3 53 20			jp macro_next 
5092				endm 
# End of macro NEXTW
5092			.V0Q: 
5092				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
5092 79				db WORD_SYS_CORE+101             
5093 a3 50			dw .V1S            
5095 04				db 3 + 1 
5096 .. 00			db "V0@",0              
509a				endm 
# End of macro CWHEAD
509a			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
509a 2a 10 f8				ld hl, (cli_var_array) 
509d cd ea 1c				call forth_push_numhl 
50a0			 
50a0				       NEXTW 
50a0 c3 53 20			jp macro_next 
50a3				endm 
# End of macro NEXTW
50a3			.V1S: 
50a3				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
50a3 7a				db WORD_SYS_CORE+102             
50a4 bb 50			dw .V1Q            
50a6 04				db 3 + 1 
50a7 .. 00			db "V1!",0              
50ab				endm 
# End of macro CWHEAD
50ab			;| V1! ( u1 -- )  Store value to v1 | DONE 
50ab					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
50ab cd e1 1e			call macro_dsp_valuehl 
50ae				endm 
# End of macro FORTH_DSP_VALUEHL
50ae			 
50ae 11 12 f8				ld de, cli_var_array+2 
50b1				 
50b1 eb					ex de, hl 
50b2 73					ld (hl), e 
50b3 23					inc hl 
50b4 72					ld (hl), d 
50b5			 
50b5					; destroy value TOS 
50b5			 
50b5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
50b5 cd 99 1f			call macro_forth_dsp_pop 
50b8				endm 
# End of macro FORTH_DSP_POP
50b8				       NEXTW 
50b8 c3 53 20			jp macro_next 
50bb				endm 
# End of macro NEXTW
50bb			.V1Q: 
50bb				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
50bb 7b				db WORD_SYS_CORE+103             
50bc cc 50			dw .V2S            
50be 04				db 3 + 1 
50bf .. 00			db "V1@",0              
50c3				endm 
# End of macro CWHEAD
50c3			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
50c3 2a 12 f8				ld hl, (cli_var_array+2) 
50c6 cd ea 1c				call forth_push_numhl 
50c9				       NEXTW 
50c9 c3 53 20			jp macro_next 
50cc				endm 
# End of macro NEXTW
50cc			.V2S: 
50cc				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
50cc 7c				db WORD_SYS_CORE+104             
50cd e4 50			dw .V2Q            
50cf 04				db 3 + 1 
50d0 .. 00			db "V2!",0              
50d4				endm 
# End of macro CWHEAD
50d4			;| V2! ( u1 -- )  Store value to v2 | DONE 
50d4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
50d4 cd e1 1e			call macro_dsp_valuehl 
50d7				endm 
# End of macro FORTH_DSP_VALUEHL
50d7			 
50d7 11 14 f8				ld de, cli_var_array+4 
50da				 
50da eb					ex de, hl 
50db 73					ld (hl), e 
50dc 23					inc hl 
50dd 72					ld (hl), d 
50de			 
50de					; destroy value TOS 
50de			 
50de					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
50de cd 99 1f			call macro_forth_dsp_pop 
50e1				endm 
# End of macro FORTH_DSP_POP
50e1				       NEXTW 
50e1 c3 53 20			jp macro_next 
50e4				endm 
# End of macro NEXTW
50e4			.V2Q: 
50e4				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
50e4 7d				db WORD_SYS_CORE+105             
50e5 f5 50			dw .V3S            
50e7 04				db 3 + 1 
50e8 .. 00			db "V2@",0              
50ec				endm 
# End of macro CWHEAD
50ec			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
50ec 2a 14 f8				ld hl, (cli_var_array+4) 
50ef cd ea 1c				call forth_push_numhl 
50f2				       NEXTW 
50f2 c3 53 20			jp macro_next 
50f5				endm 
# End of macro NEXTW
50f5			.V3S: 
50f5				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
50f5 7c				db WORD_SYS_CORE+104             
50f6 0d 51			dw .V3Q            
50f8 04				db 3 + 1 
50f9 .. 00			db "V3!",0              
50fd				endm 
# End of macro CWHEAD
50fd			;| V3! ( u1 -- )  Store value to v3 | DONE 
50fd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
50fd cd e1 1e			call macro_dsp_valuehl 
5100				endm 
# End of macro FORTH_DSP_VALUEHL
5100			 
5100 11 16 f8				ld de, cli_var_array+6 
5103				 
5103 eb					ex de, hl 
5104 73					ld (hl), e 
5105 23					inc hl 
5106 72					ld (hl), d 
5107			 
5107					; destroy value TOS 
5107			 
5107					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5107 cd 99 1f			call macro_forth_dsp_pop 
510a				endm 
# End of macro FORTH_DSP_POP
510a				       NEXTW 
510a c3 53 20			jp macro_next 
510d				endm 
# End of macro NEXTW
510d			.V3Q: 
510d				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
510d 7d				db WORD_SYS_CORE+105             
510e 1e 51			dw .END            
5110 04				db 3 + 1 
5111 .. 00			db "V3@",0              
5115				endm 
# End of macro CWHEAD
5115			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
5115 2a 16 f8				ld hl, (cli_var_array+6) 
5118 cd ea 1c				call forth_push_numhl 
511b				       NEXTW 
511b c3 53 20			jp macro_next 
511e				endm 
# End of macro NEXTW
511e			 
511e			 
511e			 
511e			 
511e			 
511e			; end of dict marker 
511e			 
511e 00			.END:    db WORD_SYS_END 
511f 00 00			dw 0 
5121 00				db 0 
5122			 
5122			; use to jp here for user dict words to save on macro expansion  
5122			 
5122			user_dict_next: 
5122				NEXTW 
5122 c3 53 20			jp macro_next 
5125				endm 
# End of macro NEXTW
5125			 
5125			 
5125			user_exec: 
5125				;    ld hl, <word code> 
5125				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
5125				;    call forthexec 
5125				;    jp user_dict_next   (NEXT) 
5125			        ;    <word code bytes> 
5125 eb				ex de, hl 
5126 2a 1e f1			ld hl,(os_tok_ptr) 
5129				 
5129				FORTH_RSP_NEXT 
5129 cd 91 1c			call macro_forth_rsp_next 
512c				endm 
# End of macro FORTH_RSP_NEXT
512c			 
512c			if DEBUG_FORTH_UWORD 
512c						DMARK "UEX" 
512c f5				push af  
512d 3a 41 51			ld a, (.dmark)  
5130 32 77 fb			ld (debug_mark),a  
5133 3a 42 51			ld a, (.dmark+1)  
5136 32 78 fb			ld (debug_mark+1),a  
5139 3a 43 51			ld a, (.dmark+2)  
513c 32 79 fb			ld (debug_mark+2),a  
513f 18 03			jr .pastdmark  
5141 ..			.dmark: db "UEX"  
5144 f1			.pastdmark: pop af  
5145			endm  
# End of macro DMARK
5145				CALLMONITOR 
5145 cd 5a 17			call break_point_state  
5148				endm  
# End of macro CALLMONITOR
5148			endif 
5148			 
5148			 
5148			 
5148 eb				ex de, hl 
5149 22 1e f1			ld (os_tok_ptr), hl 
514c				 
514c				; Don't use next - Skips the first word in uword. 
514c			 
514c c3 e4 20			jp exec1 
514f			;	NEXT 
514f			 
514f			 
514f			; eof 
# End of file forth_wordsv4.asm
514f			endif 
514f			;;;;;;;;;;;;;; Debug code 
514f			 
514f			 
514f			;if DEBUG_FORTH_PARSE 
514f .. 00		.nowordfound: db "No match",0 
5158 .. 00		.compword:	db "Comparing word ",0 
5168 .. 00		.nextwordat:	db "Next word at",0 
5175 .. 00		.charmatch:	db "Char match",0 
5180			;endif 
5180			if DEBUG_FORTH_JP 
5180			.foundword:	db "Word match. Exec..",0 
5180			endif 
5180			;if DEBUG_FORTH_PUSH 
5180 .. 00		.enddict:	db "Dict end. Push.",0 
5190 .. 00		.push_str:	db "Pushing string",0 
519f .. 00		.push_num:	db "Pushing number",0 
51ae .. 00		.data_sp:	db "SP:",0 
51b2 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
51c4 .. 00		.wordinde:	db "Word in DE (3/0):",0 
51d6 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
51e8			;endif 
51e8			;if DEBUG_FORTH_MALLOC 
51e8 .. 00		.push_malloc:	db "Malloc address",0 
51f7			;endif 
51f7			 
51f7			 
51f7			 
51f7			; display malloc address and current data stack pointer  
51f7			 
51f7			malloc_error: 
51f7 d5				push de 
51f8 f5				push af 
51f9 e5				push hl 
51fa cd e9 0a			call clear_display 
51fd 11 1f 52			ld de, .mallocerr 
5200 3e 00			ld a,0 
5202			;	ld de,os_word_scratch 
5202 cd fc 0a			call str_at_display 
5205 3e 11			ld a, display_row_1+17 
5207 11 77 fb			ld de, debug_mark 
520a cd fc 0a			call str_at_display 
520d cd 0c 0b			call update_display 
5210				;call break_point_state 
5210 cd 19 69			call cin_wait 
5213			 
5213 3e 20			ld a, ' ' 
5215 32 0e ee			ld (os_view_disable), a 
5218 e1				pop hl 
5219 f1				pop af 
521a d1				pop de	 
521b				CALLMONITOR 
521b cd 5a 17			call break_point_state  
521e				endm  
# End of macro CALLMONITOR
521e c9				ret 
521f			 
521f .. 00		.mallocerr: 	db "Malloc Error",0 
522c			;if DEBUG_FORTH_PUSH 
522c			display_data_sp: 
522c f5				push af 
522d			 
522d				; see if disabled 
522d			 
522d 3a 0e ee			ld a, (os_view_disable) 
5230 fe 2a			cp '*' 
5232 28 67			jr z, .skipdsp 
5234			 
5234 e5				push hl 
5235 e5				push hl 
5236 e5			push hl 
5237 cd e9 0a			call clear_display 
523a e1			pop hl 
523b 7c				ld a,h 
523c 21 22 f1			ld hl, os_word_scratch 
523f cd 1e 10			call hexout 
5242 e1				pop hl 
5243 7d				ld a,l 
5244 21 24 f1			ld hl, os_word_scratch+2 
5247 cd 1e 10			call hexout 
524a 21 26 f1			ld hl, os_word_scratch+4 
524d 3e 00			ld a,0 
524f 77				ld (hl),a 
5250 11 22 f1			ld de,os_word_scratch 
5253 3e 28				ld a, display_row_2 
5255 cd fc 0a				call str_at_display 
5258 11 b2 51			ld de, .wordinhl 
525b 3e 00			ld a, display_row_1 
525d			 
525d cd fc 0a				call str_at_display 
5260 11 77 fb			ld de, debug_mark 
5263 3e 11			ld a, display_row_1+17 
5265			 
5265 cd fc 0a				call str_at_display 
5268			 
5268				; display current data stack pointer 
5268 11 ae 51			ld de,.data_sp 
526b 3e 30				ld a, display_row_2 + 8 
526d cd fc 0a				call str_at_display 
5270			 
5270 2a 0a f8			ld hl,(cli_data_sp) 
5273 e5				push hl 
5274 7c				ld a,h 
5275 21 22 f1			ld hl, os_word_scratch 
5278 cd 1e 10			call hexout 
527b e1				pop hl 
527c 7d				ld a,l 
527d 21 24 f1			ld hl, os_word_scratch+2 
5280 cd 1e 10			call hexout 
5283 21 26 f1			ld hl, os_word_scratch+4 
5286 3e 00			ld a,0 
5288 77				ld (hl),a 
5289 11 22 f1			ld de,os_word_scratch 
528c 3e 33				ld a, display_row_2 + 11 
528e cd fc 0a				call str_at_display 
5291			 
5291			 
5291 cd 0c 0b			call update_display 
5294 cd 69 0a			call delay1s 
5297 cd 69 0a			call delay1s 
529a e1				pop hl 
529b			.skipdsp: 
529b f1				pop af 
529c c9				ret 
529d			 
529d			display_data_malloc: 
529d			 
529d f5				push af 
529e e5				push hl 
529f e5				push hl 
52a0 e5			push hl 
52a1 cd e9 0a			call clear_display 
52a4 e1			pop hl 
52a5 7c				ld a,h 
52a6 21 22 f1			ld hl, os_word_scratch 
52a9 cd 1e 10			call hexout 
52ac e1				pop hl 
52ad 7d				ld a,l 
52ae 21 24 f1			ld hl, os_word_scratch+2 
52b1 cd 1e 10			call hexout 
52b4 21 26 f1			ld hl, os_word_scratch+4 
52b7 3e 00			ld a,0 
52b9 77				ld (hl),a 
52ba 11 22 f1			ld de,os_word_scratch 
52bd 3e 28				ld a, display_row_2 
52bf cd fc 0a				call str_at_display 
52c2 11 e8 51			ld de, .push_malloc 
52c5 3e 00			ld a, display_row_1 
52c7			 
52c7 cd fc 0a				call str_at_display 
52ca			 
52ca				; display current data stack pointer 
52ca 11 ae 51			ld de,.data_sp 
52cd 3e 30				ld a, display_row_2 + 8 
52cf cd fc 0a				call str_at_display 
52d2			 
52d2 2a 0a f8			ld hl,(cli_data_sp) 
52d5 e5				push hl 
52d6 7c				ld a,h 
52d7 21 22 f1			ld hl, os_word_scratch 
52da cd 1e 10			call hexout 
52dd e1				pop hl 
52de 7d				ld a,l 
52df 21 24 f1			ld hl, os_word_scratch+2 
52e2 cd 1e 10			call hexout 
52e5 21 26 f1			ld hl, os_word_scratch+4 
52e8 3e 00			ld a,0 
52ea 77				ld (hl),a 
52eb 11 22 f1			ld de,os_word_scratch 
52ee 3e 33				ld a, display_row_2 + 11 
52f0 cd fc 0a				call str_at_display 
52f3			 
52f3 cd 0c 0b			call update_display 
52f6 cd 69 0a			call delay1s 
52f9 cd 69 0a			call delay1s 
52fc e1				pop hl 
52fd f1				pop af 
52fe c9				ret 
52ff			;endif 
52ff			 
52ff			include "forth_autostart.asm" 
52ff			; list of commands to perform at system start up 
52ff			 
52ff			startcmds: 
52ff			;	dw test11 
52ff			;	dw test12 
52ff			;	dw test13 
52ff			;	dw test14 
52ff			;	dw test15 
52ff			;	dw test16 
52ff			;	dw test17 
52ff			;	dw ifthtest1 
52ff			;	dw ifthtest2 
52ff			;	dw ifthtest3 
52ff			;	dw mmtest1 
52ff			;	dw mmtest2 
52ff			;	dw mmtest3 
52ff			;	dw mmtest4 
52ff			;	dw mmtest5 
52ff			;	dw mmtest6 
52ff			;	dw iftest1 
52ff			;	dw iftest2 
52ff			;	dw iftest3 
52ff			;	dw looptest1 
52ff			;	dw looptest2 
52ff			;	dw test1 
52ff			;	dw test2 
52ff			;	dw test3 
52ff			;	dw test4 
52ff			;	dw game2r 
52ff			;	dw game2b1 
52ff			;	dw game2b2 
52ff			 
52ff				; start up words that are actually useful 
52ff			 
52ff 5d 53			dw clrstack 
5301 90 53			dw type 
5303 51 55			dw stest 
5305 b4 53			dw strncpy 
5307 f2 54			dw list 
5309 15 54			dw start1 
530b 27 54			dw start2 
530d			;	dw start3 
530d 3a 54			dw start3b 
530f 92 54			dw start3c 
5311			 
5311				; (unit) testing words 
5311			 
5311 c8 55			dw mtesta 
5313 7d 56			dw mtestb 
5315 20 57			dw mtestc 
5317 d5 57			dw mtestd 
5319 79 58			dw mteste 
531b			 
531b				; demo/game words 
531b			 
531b 85 5f		        dw game3w 
531d b3 5f		        dw game3p 
531f d1 5f		        dw game3sc 
5321 02 60		        dw game3vsi 
5323 2e 60		        dw game3vs 
5325				 
5325 78 5d			dw game2b 
5327 e6 5d			dw game2bf 
5329 30 5e			dw game2mba 
532b c6 5e			dw game2mbas 
532d 08 5f			dw game2mb 
532f			 
532f 39 5a			dw game1 
5331 4a 5a			dw game1a 
5333 ac 5a			dw game1b 
5335 e1 5a			dw game1c 
5337 17 5b			dw game1d 
5339 48 5b			dw game1s 
533b 5c 5b			dw game1t 
533d 71 5b			dw game1f 
533f a5 5b			dw game1z 
5341 e9 5b			dw game1zz 
5343			 
5343 2f 59			dw test5 
5345 67 59			dw test6 
5347 9f 59			dw test7 
5349 b3 59			dw test8 
534b df 59			dw test9 
534d f5 59			dw test10 
534f				 
534f c0 5c		        dw ssv5 
5351 a4 5c		        dw ssv4 
5353 88 5c		        dw ssv3 
5355 52 5c		        dw ssv2 
5357 d9 5c		        dw ssv1 
5359 21 5d		        dw ssv1cpm 
535b			;	dw keyup 
535b			;	dw keydown 
535b			;	dw keyleft 
535b			;	dw keyright 
535b			;	dw 	keyf1 
535b			;	dw keyf2 
535b			;	dw keyf3 
535b			;	dw keyf4 
535b			;	dw keyf5 
535b			;	dw keyf6 
535b			;	dw keyf7 
535b			;	dw keyf8 
535b			;	dw keyf9 
535b			;	dw keyf10 
535b			;	dw keyf11 
535b			;	dw keyf12 
535b			;	dw keytab 
535b			;	dw keycr 
535b			;	dw keyhome 
535b			;	dw keyend 
535b			;	dw keybs 
535b 00 00			db 0, 0	 
535d			 
535d			 
535d			; clear stack  
535d			 
535d .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
5390			 
5390			; type ( addr count - ) 
5390 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
53b4			 
53b4			; some direct memory words 
53b4			; strncpy ( len t f -- t ) 
53b4			 
53b4 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
5415			 
5415 .. 00		start1:     	db ": bpon $0000 bp ;",0 
5427 .. 00		start2:     	db ": bpoff $0001 bp ;",0 
543a			;start3:         db ": dirlist ir cls drop dup $00 > if $01 do .> BL .> .> BL .> .> BL .> loop then nop ;",0 
543a .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 i at . $01 i at . $04 i at . loop then nop ;",0 
5492 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
54f2			 
54f2			 
54f2			; a handy word to list items on the stack 
54f2			 
54f2 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> accept drop depth 0= not until nop ;",0 
5551			 
5551			 
5551			; test stack  
5551			; rnd8 stest 
5551			 
5551 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
55c8			 
55c8			; random malloc and free cycles 
55c8			 
55c8 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
567d			 
567d			; fixed malloc and free cycles 
567d			 
567d .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5720			 
5720			; fixed double string push and drop cycle  
5720			 
5720 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
57d5			 
57d5			; consistent fixed string push and drop cycle  
57d5			 
57d5 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5879			 
5879 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
592f			 
592f			;test1:		db ": aa 1 2 3 ;", 0 
592f			;test2:     	db "111 aa 888 999",0 
592f			;test3:     	db ": bb 77 ;",0 
592f			;test4:     	db "$02 $01 do i . loop bb",0 
592f			 
592f .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
5967 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
599f .. 00		test7:     	db ": box hline vline ;",0 
59b3 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
59df .. 00		test9:     	db ": sw $01 adsp world ;",0 
59f5 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
5a1a .. 00		test11:     	db "hello create .",0 
5a29 .. 00		test12:     	db "hello2 create .",0 
5a39			 
5a39			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
5a39			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
5a39			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
5a39			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
5a39			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
5a39			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
5a39			 
5a39			;iftest1:     	db "$0001 IF cls .",0 
5a39			;iftest2:     	db "$0000 IF cls .",0 
5a39			;iftest3:     	db "$0002 $0003 - IF cls .",0 
5a39			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
5a39			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
5a39			 
5a39			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5a39			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5a39			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5a39			 
5a39			 
5a39			 
5a39			; a small guess the number game 
5a39			 
5a39 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
5a4a .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
5aac			 
5aac .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
5ae1 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
5b17 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
5b48 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
5b5c .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
5b71 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5ba5 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
5be9			 
5be9			; Using 'ga' save a high score across multiple runs using external storage 
5be9			 
5be9 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
5c52			 
5c52			 
5c52			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
5c52			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
5c52			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
5c52			 
5c52			; simple screen saver to test code memory reuse to destruction 
5c52			 
5c52 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
5c88 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
5ca4 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
5cc0 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
5cd9 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
5d21 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
5d78			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
5d78			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
5d78			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
5d78			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
5d78			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
5d78			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
5d78			 
5d78			 
5d78			 
5d78			; minesweeper/battleship finding game 
5d78			; draws a game board of random ship/mine positions 
5d78			; user enters coords to see if it hits on 
5d78			; game ends when all are hit 
5d78			; when hit or miss says how many may be in the area 
5d78			 
5d78			; setup the game board and then hide it 
5d78 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
5de6 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
5e30			; prompt for where to target 
5e30 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
5ec6 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
5eeb			; TODO see if the entered coords hits or misses pushes char hit of miss 
5eeb .. 00		game2mbht:      db ": mbckht nop ;",0 
5efa .. 00		game2mbms:      db ": mbcms nop ;",0 
5f08			; TODO how many might be near by 
5f08 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
5f85			 
5f85			; Game 3 
5f85			 
5f85			; Vert scroller ski game - avoid the trees! 
5f85			 
5f85			; v0 score (ie turns) 
5f85			; v1 player pos 
5f85			; v2 left wall 
5f85			; v3 right wall 
5f85			 
5f85			; Draw side walls randomly 
5f85			 
5f85 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
5fb3			 
5fb3			; Draw player 
5fb3 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
5fd1			 
5fd1			; TODO Get Key 
5fd1			 
5fd1			; TODO Move left right 
5fd1			 
5fd1			; scroll and move walls a bit 
5fd1			 
5fd1 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
6002			 
6002			; main game loop 
6002			 
6002 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
602e .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
606d			 
606d			; key board defs 
606d			 
606d .. 00		keyup:       db ": keyup $05 ;",0 
607b .. 00		keydown:       db ": keydown $0a ;",0 
608b .. 00		keyleft:       db ": keyleft $0b ;",0 
609b .. 00		keyright:       db ": keyright $0c ;",0 
60ac .. 00		keyf1:       db ": keyf1 $10 ;",0 
60ba .. 00		keyf2:       db ": keyf2 $11 ;",0 
60c8 .. 00		keyf3:       db ": keyf3 $12 ;",0 
60d6 .. 00		keyf4:       db ": keyf4 $13 ;",0 
60e4 .. 00		keyf5:       db ": keyf5 $14 ;",0 
60f2 .. 00		keyf6:       db ": keyf6 $15 ;",0 
6100 .. 00		keyf7:       db ": keyf7 $16 ;",0 
610e .. 00		keyf8:       db ": keyf8 $17 ;",0 
611c .. 00		keyf9:       db ": keyf9 $18 ;",0 
612a .. 00		keyf10:       db ": keyf10 $19 ;",0 
6139 .. 00		keyf11:       db ": keyf11 $1a ;",0 
6148 .. 00		keyf12:       db ": keyf12 $1b ;",0 
6157			 
6157 .. 00		keytab:       db ": keytab $09 ;",0 
6166 .. 00		keycr:       db ": keycr $0d ;",0 
6174 .. 00		keyhome:       db ": keyhome $0e ;",0 
6184 .. 00		keyend:       db ": keyend $0f ;",0 
6193 .. 00		keybs:       db ": keybs $08 ;",0 
61a1			 
61a1			   
61a1			 
61a1			 
61a1			 
61a1			; eof 
# End of file forth_autostart.asm
61a1			 
61a1 .. 00		sprompt1: db "Startup load...",0 
61b1 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
61c7			 
61c7			 
61c7			 
61c7			 
61c7			forth_startup: 
61c7 21 ff 52			ld hl, startcmds 
61ca 3e 00			ld a, 0 
61cc 32 43 f2			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
61cf			 
61cf e5			.start1:	push hl 
61d0 cd e9 0a			call clear_display 
61d3 11 a1 61			ld de, sprompt1 
61d6 3e 00		        ld a, display_row_1 
61d8 cd fc 0a			call str_at_display 
61db 11 b1 61			ld de, sprompt2 
61de 3e 28		        ld a, display_row_2 
61e0 cd fc 0a			call str_at_display 
61e3 e1				pop hl 
61e4 e5				push hl 
61e5 5e				ld e,(hl) 
61e6 23				inc hl 
61e7 56				ld d,(hl) 
61e8 3e 50		        ld a, display_row_3 
61ea cd fc 0a			call str_at_display 
61ed cd 0c 0b			call update_display 
61f0			 
61f0			 
61f0 3a 43 f2			ld a, (os_last_cmd) 
61f3 fe 00			cp 0 
61f5 28 05			jr z, .startprompt 
61f7 cd 5d 0a			call delay250ms 
61fa 18 24			jr .startdo 
61fc				 
61fc				 
61fc			 
61fc			.startprompt: 
61fc			 
61fc 3e 9f			ld a,display_row_4 + display_cols - 1 
61fe 11 60 1c		        ld de, endprg 
6201 cd fc 0a			call str_at_display 
6204 cd 0c 0b			call update_display 
6207 cd 69 0a			call delay1s 
620a cd 19 69			call cin_wait 
620d						 
620d fe 2a			cp '*' 
620f 28 5e			jr z, .startupend1 
6211 fe 23			cp '#' 
6213 20 07			jr nz, .startno 
6215 3e 01			ld a, 1 
6217 32 43 f2			ld (os_last_cmd),a 
621a 18 04			jr .startdo 
621c fe 31		.startno:	cp '1' 
621e 28 3a			jr z,.startnxt  
6220			 
6220				; exec startup line 
6220			.startdo:	 
6220 e1				pop hl 
6221 e5				push hl 
6222				 
6222 5e				ld e,(hl) 
6223 23				inc hl 
6224 56				ld d,(hl) 
6225 eb				ex de,hl 
6226			 
6226 e5				push hl 
6227			 
6227 3e 00			ld a, 0 
6229				;ld a, FORTH_END_BUFFER 
6229 cd 86 11			call strlent 
622c 23				inc hl   ; include zero term to copy 
622d 06 00			ld b,0 
622f 4d				ld c,l 
6230 e1				pop hl 
6231 11 1d ee			ld de, scratch 
6234 ed b0			ldir 
6236			 
6236			 
6236 21 1d ee			ld hl, scratch 
6239 cd a1 20			call forthparse 
623c cd e1 20			call forthexec 
623f cd f8 1f			call forthexec_cleanup 
6242			 
6242 3e 78			ld a, display_row_4 
6244 11 04 1a			ld de, endprog 
6247			 
6247 cd 0c 0b			call update_display		 
624a			 
624a 3a 43 f2			ld a, (os_last_cmd) 
624d fe 00			cp 0 
624f 20 09			jr nz, .startnxt 
6251 cd 62 1c			call next_page_prompt 
6254 cd e9 0a		        call clear_display 
6257 cd 0c 0b			call update_display		 
625a			 
625a				; move onto next startup line? 
625a			.startnxt: 
625a			 
625a cd 5d 0a			call delay250ms 
625d e1				pop hl 
625e			 
625e 23				inc hl 
625f 23				inc hl 
6260			 
6260 e5				push hl 
6261 5e				ld e, (hl) 
6262 23				inc hl 
6263 56				ld d, (hl) 
6264 e1				pop hl 
6265				; TODO replace 0 test 
6265			 
6265 eb				ex de, hl 
6266 cd 46 0d			call ishlzero 
6269			;	ld a,e 
6269			;	add d 
6269			;	cp 0    ; any left to do? 
6269 eb				ex de, hl 
626a c2 cf 61			jp nz, .start1 
626d 18 01			jr .startupend 
626f			 
626f e1			.startupend1: pop hl 
6270			.startupend: 
6270			 
6270 cd e9 0a			call clear_display 
6273 cd 0c 0b			call update_display 
6276 c9				ret 
6277			 
6277			 
6277			; stack over and underflow checks 
6277			 
6277			; init the words to detect the under/overflow 
6277			 
6277			chk_stk_init: 
6277				; a vague random number to check so we dont get any "lucky" hits 
6277 3e 2d			ld a, 45 
6279 6f				ld l, a 
627a 00				nop 
627b 3e 17			ld a, 23 
627d 67				ld h, a 
627e			 
627e 22 04 ee			ld (chk_word), hl     ; the word we need to check against 
6281			 
6281			;	ld (chk_stund), hl	; stack points.... 
6281 22 fd fb			ld (chk_stovr), hl 
6284 22 08 f8			ld (chk_ret_und), hl 
6287 22 86 f7			ld (chk_ret_ovr), hl 
628a 22 84 f5			ld (chk_loop_ovr), hl 
628d 22 82 f3			ld (chk_data_ovr), hl 
6290 c9				ret 
6291				 
6291			check_stacks: 
6291				; check all stack words 
6291			 
6291 e5				push hl 
6292 d5				push de 
6293			 
6293			;	ld de,(chk_word) 
6293			;	ld hl, (chk_stund)	; stack points.... 
6293			;	if DEBUG_STK_FAULT 
6293			;		DMARK "FAa" 
6293			;		CALLMONITOR 
6293			;	endif 
6293			;	call cmp16 
6293			;	jp z, .chk_faulta 
6293			; 
6293			;	ld de, sfaultsu 
6293			;	jp .chk_fault 
6293			 
6293 2a fd fb		.chk_faulta: ld hl, (chk_stovr) 
6296 ed 5b 04 ee		ld de,(chk_word) 
629a				if DEBUG_STK_FAULT 
629a					DMARK "FAb" 
629a					CALLMONITOR 
629a				endif 
629a cd 3b 0d			call cmp16 
629d 28 06			jr z, .chk_fault1 
629f 11 40 63			ld de, sfaultso 
62a2 c3 f4 62			jp .chk_fault 
62a5			.chk_fault1:  
62a5 2a 08 f8			ld hl, (chk_ret_und) 
62a8 ed 5b 04 ee		ld de,(chk_word) 
62ac				if DEBUG_STK_FAULT 
62ac					DMARK "FAU" 
62ac					CALLMONITOR 
62ac				endif 
62ac cd 3b 0d			call cmp16 
62af ca b8 62			jp z, .chk_fault2 
62b2 11 50 63			ld de, sfaultru 
62b5 c3 f4 62			jp .chk_fault 
62b8			.chk_fault2:  
62b8 2a 86 f7			ld hl, (chk_ret_ovr) 
62bb ed 5b 04 ee		ld de,(chk_word) 
62bf				if DEBUG_STK_FAULT 
62bf					DMARK "FA1" 
62bf					CALLMONITOR 
62bf				endif 
62bf cd 3b 0d			call cmp16 
62c2 ca cb 62			jp z, .chk_fault3 
62c5 11 5e 63			ld de, sfaultro 
62c8 c3 f4 62			jp .chk_fault 
62cb			.chk_fault3:  
62cb 2a 84 f5			ld hl, (chk_loop_ovr) 
62ce ed 5b 04 ee		ld de,(chk_word) 
62d2				if DEBUG_STK_FAULT 
62d2					DMARK "FA2" 
62d2					CALLMONITOR 
62d2				endif 
62d2 cd 3b 0d			call cmp16 
62d5 ca de 62			jp z, .chk_fault4 
62d8 11 78 63			ld de, sfaultlo 
62db c3 f4 62			jp .chk_fault 
62de			.chk_fault4:  
62de 2a 82 f3			ld hl, (chk_data_ovr) 
62e1 ed 5b 04 ee		ld de,(chk_word) 
62e5				if DEBUG_STK_FAULT 
62e5					DMARK "FA3" 
62e5					CALLMONITOR 
62e5				endif 
62e5 cd 3b 0d			call cmp16 
62e8 ca f1 62			jp z, .chk_fault5 
62eb 11 92 63			ld de, sfaultdo 
62ee c3 f4 62			jp .chk_fault 
62f1			 
62f1			 
62f1			.chk_fault5:  
62f1 d1				pop de 
62f2 e1				pop hl 
62f3			 
62f3 c9				ret 
62f4			 
62f4 cd e9 0a		.chk_fault: 	call clear_display 
62f7 3e 28				ld a, display_row_2 
62f9 cd fc 0a				call str_at_display 
62fc 11 22 63				   ld de, .stackfault 
62ff 3e 00				ld a, display_row_1 
6301 cd fc 0a				call str_at_display 
6304 11 77 fb				    ld de, debug_mark 
6307 3e 11				ld a, display_row_1+17 
6309 cd fc 0a				call str_at_display 
630c cd 0c 0b				call update_display 
630f			 
630f				; prompt before entering montior for investigating issue 
630f			 
630f 3e 78			ld a, display_row_4 
6311 11 04 1a			ld de, endprog 
6314			 
6314 cd 0c 0b			call update_display		 
6317			 
6317 cd 62 1c			call next_page_prompt 
631a			 
631a d1				pop de 
631b e1				pop hl 
631c cd 58 1a				call monitor 
631f c3 4f 19				jp warmstart 
6322					;jp 0 
6322					;halt 
6322			 
6322			 
6322			 
6322 .. 00		.stackfault: 	db "Stack fault:",0 
632f			 
632f .. 00		sfaultsu: 	db	"Stack under flow",0 
6340 .. 00		sfaultso: 	db	"Stack over flow",0 
6350 .. 00		sfaultru:	db "RTS underflow",0 
635e .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
6378 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
6392 .. 00		sfaultdo:	db "DTS overflow", 0 
639f			 
639f			 
639f			fault_dsp_under: 
639f 11 b1 63			ld de, .dsp_under 
63a2 c3 61 64			jp .show_fault 
63a5			 
63a5			fault_rsp_under: 
63a5 11 bf 63			ld de, .rsp_under 
63a8 c3 61 64			jp .show_fault 
63ab			fault_loop_under: 
63ab 11 cd 63			ld de, .loop_under 
63ae c3 61 64			jp .show_fault 
63b1			 
63b1 .. 00		.dsp_under: db "DSP Underflow",0 
63bf .. 00		.rsp_under: db "RSP Underflow",0 
63cd .. 00		.loop_under: db "LOOP Underflow",0 
63dc			 
63dc			 
63dc d5			type_faultn: 	push de 
63dd e5					push hl 
63de cd e9 0a				call clear_display 
63e1 11 08 64				   ld de, .typefaultn 
63e4 3e 00				ld a, display_row_1 
63e6 cd fc 0a				call str_at_display 
63e9 11 77 fb				    ld de, debug_mark 
63ec 3e 11				ld a, display_row_1+17 
63ee cd fc 0a				call str_at_display 
63f1 cd 0c 0b				call update_display 
63f4			 
63f4				; prompt before entering montior for investigating issue 
63f4			 
63f4 3e 78			ld a, display_row_4 
63f6 11 04 1a			ld de, endprog 
63f9			 
63f9 cd 0c 0b			call update_display		 
63fc			 
63fc cd 62 1c			call next_page_prompt 
63ff			 
63ff e5					push hl 
6400 d5					push de 
6401 cd 58 1a				call monitor 
6404 c3 4f 19				jp warmstart 
6407 76					halt 
6408			 
6408			 
6408 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
641f			 
641f d5			type_faults: 	push de 
6420 e5					push hl 
6421 cd e9 0a				call clear_display 
6424 11 4a 64				   ld de, .typefaults 
6427 3e 00				ld a, display_row_1 
6429 cd fc 0a				call str_at_display 
642c 11 77 fb				    ld de, debug_mark 
642f 3e 11				ld a, display_row_1+17 
6431 cd fc 0a				call str_at_display 
6434 cd 0c 0b				call update_display 
6437			 
6437				; prompt before entering montior for investigating issue 
6437			 
6437 3e 78			ld a, display_row_4 
6439 11 04 1a			ld de, endprog 
643c			 
643c cd 0c 0b			call update_display		 
643f			 
643f cd 62 1c			call next_page_prompt 
6442			 
6442 e1					pop hl 
6443 d1					pop de 
6444 cd 58 1a				call monitor 
6447 c3 4f 19				jp warmstart 
644a			 
644a			 
644a .. 00		.typefaults: db "STR Type Expected TOS!",0 
6461			 
6461			.show_fault: 	 
6461 d5					push de 
6462 cd e9 0a				call clear_display 
6465 d1					pop de 
6466 3e 00				ld a, display_row_1 
6468 cd fc 0a				call str_at_display 
646b 11 77 fb				    ld de, debug_mark 
646e 3e 11				ld a, display_row_1+17 
6470 cd fc 0a				call str_at_display 
6473 cd 0c 0b				call update_display 
6476			 
6476				; prompt before entering montior for investigating issue 
6476			 
6476 3e 78			ld a, display_row_4 
6478 11 04 1a			ld de, endprog 
647b			 
647b cd 0c 0b			call update_display		 
647e			 
647e cd 62 1c			call next_page_prompt 
6481			 
6481 e1					pop hl 
6482 d1					pop de 
6483 cd 58 1a				call monitor 
6486			; do a dump to cli and not warmstart so we preserve all of the uwords.  
6486			; TODO Make optional fault restart to cli or warm boot? 
6486					;jp warmstart 
6486 c3 aa 19				jp cli 
6489 76					halt 
648a			 
648a			; handle the auto run of code from files in storage 
648a			 
648a			 
648a			if STORAGE_SE 
648a			 
648a .. 00		sprompt3: db "Loading from start-up file?:",0 
64a7 .. 00		sprompt4: db "(Y=Any key/N=No)",0 
64b8			 
64b8			 
64b8			forth_autoload: 
64b8			 
64b8				; load block 0 of store 1 
64b8				 
64b8 3e fe			ld a, $fe      ; bit 0 clear 
64ba 32 48 f8			ld (spi_device), a 
64bd			 
64bd cd bd 03			call storage_get_block_0 
64c0			 
64c0 3a 83 f8			ld a, (store_page+STORE_0_AUTOFILE) 
64c3			 
64c3 fe 00			cp 0 
64c5 c8				ret z     ; auto start not enabled 
64c6			 
64c6 cd e9 0a			call clear_display 
64c9			 
64c9				; set bank 
64c9			 
64c9 3a 85 f8				ld a, (store_page+STORE_0_BANKRUN) 
64cc 32 48 f8				ld (spi_device), a 
64cf			 
64cf				; get file id to load from and get the file name to display 
64cf			 
64cf 3a 86 f8				ld a, (store_page+STORE_0_FILERUN) 
64d2			 
64d2 2e 00				ld l, 0 
64d4 67					ld h, a 
64d5 11 62 f8				ld de, store_page 
64d8			 
64d8					if DEBUG_FORTH_WORDS 
64d8						DMARK "ASp" 
64d8 f5				push af  
64d9 3a ed 64			ld a, (.dmark)  
64dc 32 77 fb			ld (debug_mark),a  
64df 3a ee 64			ld a, (.dmark+1)  
64e2 32 78 fb			ld (debug_mark+1),a  
64e5 3a ef 64			ld a, (.dmark+2)  
64e8 32 79 fb			ld (debug_mark+2),a  
64eb 18 03			jr .pastdmark  
64ed ..			.dmark: db "ASp"  
64f0 f1			.pastdmark: pop af  
64f1			endm  
# End of macro DMARK
64f1						CALLMONITOR 
64f1 cd 5a 17			call break_point_state  
64f4				endm  
# End of macro CALLMONITOR
64f4					endif 
64f4 cd 57 08				call storage_read 
64f7			 
64f7					if DEBUG_FORTH_WORDS 
64f7						DMARK "ASr" 
64f7 f5				push af  
64f8 3a 0c 65			ld a, (.dmark)  
64fb 32 77 fb			ld (debug_mark),a  
64fe 3a 0d 65			ld a, (.dmark+1)  
6501 32 78 fb			ld (debug_mark+1),a  
6504 3a 0e 65			ld a, (.dmark+2)  
6507 32 79 fb			ld (debug_mark+2),a  
650a 18 03			jr .pastdmark  
650c ..			.dmark: db "ASr"  
650f f1			.pastdmark: pop af  
6510			endm  
# End of macro DMARK
6510						CALLMONITOR 
6510 cd 5a 17			call break_point_state  
6513				endm  
# End of macro CALLMONITOR
6513					endif 
6513			 
6513 cd 46 0d				call ishlzero 
6516 c8					ret z             ; file not found 
6517			 
6517 3e 32				ld a, display_row_2 + 10 
6519 11 65 f8				ld de, store_page+3 
651c cd fc 0a				call str_at_display 
651f				 
651f			; 
651f			 
651f 3e 05			ld a, display_row_1+5 
6521 11 8a 64			ld de, sprompt3 
6524 cd fc 0a			call str_at_display 
6527 3e 5f			ld a, display_row_3+15 
6529 11 a7 64			ld de, sprompt4 
652c cd fc 0a			call str_at_display 
652f			 
652f cd 0c 0b			call update_display 
6532			 
6532 cd 19 69			call cin_wait 
6535 fe 6e			cp 'n' 
6537 c8				ret z 
6538 fe 4e			cp 'N' 
653a c8				ret z 
653b			 
653b cd 69 0a			call delay1s 
653e			 
653e 3a 64 f8			ld a, (store_page+2) 
6541 32 58 f8			ld (store_openmaxext), a    ; save count of ext 
6544 3e 01			ld a, 1  
6546 32 59 f8			ld (store_openext), a    ; save count of ext 
6549			 
6549			.autof:  
6549 6f				ld l , a 
654a				 
654a 3a 62 f8			ld a, (store_page) 
654d 67				ld h, a	 
654e 11 62 f8			ld de, store_page 
6551					if DEBUG_FORTH_WORDS 
6551						DMARK "ASl" 
6551 f5				push af  
6552 3a 66 65			ld a, (.dmark)  
6555 32 77 fb			ld (debug_mark),a  
6558 3a 67 65			ld a, (.dmark+1)  
655b 32 78 fb			ld (debug_mark+1),a  
655e 3a 68 65			ld a, (.dmark+2)  
6561 32 79 fb			ld (debug_mark+2),a  
6564 18 03			jr .pastdmark  
6566 ..			.dmark: db "ASl"  
6569 f1			.pastdmark: pop af  
656a			endm  
# End of macro DMARK
656a						CALLMONITOR 
656a cd 5a 17			call break_point_state  
656d				endm  
# End of macro CALLMONITOR
656d					endif 
656d cd 57 08				call storage_read 
6570 cd 46 0d			call ishlzero 
6573 c8				ret z 
6574			;	jr z, .autoend 
6574			 
6574					if DEBUG_FORTH_WORDS 
6574						DMARK "ASc" 
6574 f5				push af  
6575 3a 89 65			ld a, (.dmark)  
6578 32 77 fb			ld (debug_mark),a  
657b 3a 8a 65			ld a, (.dmark+1)  
657e 32 78 fb			ld (debug_mark+1),a  
6581 3a 8b 65			ld a, (.dmark+2)  
6584 32 79 fb			ld (debug_mark+2),a  
6587 18 03			jr .pastdmark  
6589 ..			.dmark: db "ASc"  
658c f1			.pastdmark: pop af  
658d			endm  
# End of macro DMARK
658d						CALLMONITOR 
658d cd 5a 17			call break_point_state  
6590				endm  
# End of macro CALLMONITOR
6590					endif 
6590 11 64 f8			ld de, store_page+2 
6593 3e 78			ld a, display_row_4 
6595 cd fc 0a			call str_at_display 
6598			 
6598 cd 0c 0b			call update_display 
659b cd 5d 0a			call delay250ms 
659e			 
659e			 
659e			 
659e 21 64 f8			ld hl, store_page+2 
65a1 cd a1 20			call forthparse 
65a4 cd e1 20			call forthexec 
65a7 cd f8 1f			call forthexec_cleanup 
65aa			 
65aa				 
65aa 3a 59 f8			ld a, (store_openext) 
65ad 3c				inc a 
65ae 32 59 f8			ld (store_openext), a    ; save count of ext 
65b1			 
65b1 18 96			jr .autof 
65b3			;.autofdone: 
65b3			; 
65b3			;		if DEBUG_FORTH_WORDS 
65b3			;			DMARK "ASx" 
65b3			;			CALLMONITOR 
65b3			;		endif 
65b3			;;	call clear_display 
65b3			;	ret 
65b3			 
65b3			 
65b3			 
65b3			endif 
65b3			 
65b3			 
65b3			; eof 
# End of file forth_kernel.asm
65b3			;include "nascombasic.asm" 
65b3			 
65b3			 
65b3			; find out where the code ends if loaded into RAM (for SC114) 
65b3			;endofcode:  
65b3			;	nop 
65b3			 
65b3			 
65b3			; eof 
65b3			 
# End of file main.asm
65b3			include "firmware_lcd_4x40.asm" 
65b3			; **********************************************************************  
65b3			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
65b3			; **********************************************************************  
65b3			;  
65b3			; **  Written as a Small Computer Monitor App  
65b3			; **  www.scc.me.uk  
65b3			;  
65b3			; History  
65b3			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
65b3			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
65b3			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
65b3			;  
65b3			; **********************************************************************  
65b3			;  
65b3			; This program is an example of one of the methods of interfacing an   
65b3			; alphanumeric LCD module.   
65b3			;  
65b3			; In this example the display is connected to either a Z80 PIO or a   
65b3			; simple 8-bit output port.   
65b3			;  
65b3			; This interfacing method uses 4-bit data mode and uses time delays  
65b3			; rather than polling the display's ready status. As a result the   
65b3			; interface only requires 6 simple output lines:  
65b3			;   Output bit 0 = not used  
65b3			;   Output bit 1 = not used  
65b3			;   Output bit 2 = RS         High = data, Low = instruction  
65b3			;   Output bit 3 = E          Active high  
65b3			;   Output bit 4 = DB4  
65b3			;   Output bit 5 = DB5  
65b3			;   Output bit 6 = DB6  
65b3			;   Output bit 7 = DB7  
65b3			; Display's R/W is connected to 0v so it is always in write mode  
65b3			;  
65b3			; This set up should work with any system supporting the RC2014 bus  
65b3			  
65b3			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
65b3			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
65b3			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
65b3			;  
65b3			; **********************************************************************  
65b3			  
65b3			; Additonal for 4x40. E1 and E2 instead of just E   
65b3			; TODO swipe vidout signal on port a to activate E2  
65b3			  
65b3			; **********************************************************************  
65b3			; **  Constants  
65b3			; **********************************************************************  
65b3			; LCD constants required by LCD support module  
65b3			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
65b3			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
65b3			kLCDBitE:   EQU 3              ;Port bit for LCD E signal             
65b3			kLCDBitE2:   EQU 0              ;Port bit for LCD E2 signal            VIDOUT  
65b3			; TODO Decide which E is being set  
65b3			kLCDWidth:  EQU display_cols             ;Width in characters  
65b3			  
65b3			; **********************************************************************  
65b3			; **  Code library usage  
65b3			; **********************************************************************  
65b3			  
65b3			; send character to current cursor position  
65b3			; wraps and/or scrolls screen automatically  
65b3			  
65b3			  
65b3			  
65b3			lcd_init:  
65b3			  
65b3			; SCMonAPI functions used  
65b3			  
65b3			; Alphanumeric LCD functions used  
65b3			; no need to specify specific functions for this module  
65b3			  
65b3 3e cf		            LD   A, 11001111b  
65b5 d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
65b7 3e 00		            LD   A, 00000000b  
65b9 d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
65bb			  
65bb			; Initialise alphanumeric LCD module  
65bb 3e 00				ld a, 0  
65bd 32 d7 f8				ld (display_lcde1e2), a  
65c0 cd 41 66		            CALL fLCD_Init      ;Initialise LCD module  
65c3 3e 01				ld a, 1  
65c5 32 d7 f8				ld (display_lcde1e2), a  
65c8 cd 41 66		            CALL fLCD_Init      ;Initialise LCD module  
65cb			  
65cb c9				ret  
65cc			  
65cc			;  
65cc			;;  
65cc			; lcd functions  
65cc			;  
65cc			;  
65cc			  
65cc			; what is at cursor position   
65cc			  
65cc			;get_cursor:	ld de, (cursor_row)   ;  row + col  
65cc			;		call curptr  
65cc			;		ret  
65cc			  
65cc			  
65cc			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
65cc			  
65cc			curptr:  
65cc c5				push bc  
65cd 21 bd fa			ld hl, display_fb0  
65d0			cpr:	  
65d0				; loop for cursor whole row  
65d0 0e 28			ld c, display_cols  
65d2 23			cpr1:	inc hl  
65d3 0d				dec c  
65d4 20 fc			jr nz, cpr1  
65d6 05				dec b  
65d7 20 f7			jr nz, cpr  
65d9			  
65d9				; add col	  
65d9			  
65d9 23			cpr2:	inc hl  
65da 1d				dec e  
65db 20 fc			jr nz, cpr2  
65dd			  
65dd c1				pop bc  
65de c9				ret  
65df				  
65df			  
65df			  
65df			  
65df			  
65df			; write the frame buffer given in hl to hardware   
65df 22 d5 f8		write_display: ld (display_write_tmp), hl 	   
65e2 3e 00			ld a, kLCD_Line1  
65e4 cd ee 66		            CALL fLCD_Pos       ;Position cursor to location in A  
65e7 06 28			ld b, display_cols  
65e9 ed 5b d5 f8		ld de, (display_write_tmp)  
65ed cd 39 66			call write_len_string  
65f0				  
65f0				  
65f0 2a d5 f8			ld hl, (display_write_tmp)  
65f3 11 28 00			ld de, display_cols  
65f6 19				add hl,de  
65f7 22 d5 f8			ld (display_write_tmp),hl  
65fa			  
65fa				  
65fa 3e 28			ld a, kLCD_Line2  
65fc cd ee 66		            CALL fLCD_Pos       ;Position cursor to location in A  
65ff 06 28			ld b, display_cols  
6601 ed 5b d5 f8		ld de, (display_write_tmp)  
6605 cd 39 66			call write_len_string  
6608				  
6608 2a d5 f8			ld hl, (display_write_tmp)  
660b 11 28 00			ld de, display_cols  
660e 19				add hl,de  
660f 22 d5 f8			ld (display_write_tmp),hl  
6612			  
6612				  
6612 3e 50			ld a, kLCD_Line3  
6614 cd ee 66		            CALL fLCD_Pos       ;Position cursor to location in A  
6617 06 28			ld b, display_cols  
6619 ed 5b d5 f8		ld de, (display_write_tmp)  
661d cd 39 66			call write_len_string  
6620				  
6620 2a d5 f8			ld hl, (display_write_tmp)  
6623 11 28 00			ld de, display_cols  
6626 19				add hl,de  
6627 22 d5 f8			ld (display_write_tmp),hl  
662a			  
662a				  
662a 3e 78			ld a, kLCD_Line4  
662c cd ee 66		            CALL fLCD_Pos       ;Position cursor to location in A  
662f 06 28			ld b, display_cols  
6631 ed 5b d5 f8		ld de, (display_write_tmp)  
6635 cd 39 66			call write_len_string  
6638 c9					ret  
6639				  
6639				; write out a fixed length string given in b from de  
6639			  
6639 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
663a cd a6 66		            CALL fLCD_Data      ;Write character to display  
663d 13				inc de  
663e 10 f9			djnz write_len_string  
6640 c9				ret  
6641			  
6641			; Some other things to do  
6641			;            LD   A, kLCD_Clear ;Display clear  
6641			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
6641			;            LD   A, kLCD_Under ;Display on with underscore cursor  
6641			;            LD   A, kLCD_On     ;Display on with no cursor  
6641			;            ;LD   A, kLCD_Off   ;Display off  
6641			;            CALL fLCD_Inst      ;Send instruction to display  
6641			;  
6641			;  
6641			;            halt  
6641			;  
6641			;  
6641			;MsgHello:   DB  "Hello World!",0  
6641			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
6641			  
6641			; Custom characters 5 pixels wide by 8 pixels high  
6641			; Up to 8 custom characters can be defined  
6641			;BitMaps:      
6641			;; Character 0x00 = Battery icon  
6641			;            DB  01110b  
6641			;            DB  11011b  
6641			;            DB  10001b  
6641			;            DB  10001b  
6641			;            DB  11111b  
6641			;            DB  11111b  
6641			;            DB  11111b  
6641			;            DB  11111b  
6641			;; Character 0x01 = Bluetooth icon  
6641			;            DB  01100b  
6641			;            DB  01010b  
6641			;            DB  11100b  
6641			;            DB  01000b  
6641			;            DB  11100b  
6641			;            DB  01010b  
6641			;            DB  01100b  
6641			;            DB  00000b  
6641			;  
6641			  
6641			  
6641			; **********************************************************************  
6641			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
6641			; **********************************************************************  
6641			;  
6641			; **  Written as a Small Computer Monitor App   
6641			; **  Version 0.1 SCC 2018-05-16  
6641			; **  www.scc.me.uk  
6641			;  
6641			; **********************************************************************  
6641			;  
6641			; This module provides support for alphanumeric LCD modules using with  
6641			; *  HD44780 (or compatible) controller  
6641			; *  5 x 7 pixel fonts  
6641			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
6641			; *  Interface via six digital outputs to the display (see below)  
6641			;  
6641			; LCD module pinout:  
6641			;   1  Vss   0v supply  
6641			;   2  Vdd   5v supply  
6641			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
6641			;   4  RS    High = data, Low = instruction  
6641			;   5  R/W   High = Read, Low = Write  
6641			;   6  E     Enable signal (active high)  
6641			;   7  DB0   Data bit 0  
6641			;   8  DB1   Data bit 1  
6641			;   9  DB2   Data bit 2  
6641			;  10  DB3   Data bit 3  
6641			;  11  DB4   Data bit 4  
6641			;  12  DB5   Data bit 5  
6641			;  13  DB6   Data bit 6  
6641			;  14  DB7   Data bit 7  
6641			;  15  A     Backlight anode (+)  
6641			;  16  K     Backlight cathode (-)  
6641			;  
6641			; This interfacing method uses 4-bit data mode and uses time delays  
6641			; rather than polling the display's ready status. As a result the   
6641			; interface only requires 6 simple output lines:  
6641			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
6641			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
6641			;   LCD DB4 = Microcomputer output port bit 4  
6641			;   LCD DB5 = Microcomputer output port bit 5  
6641			;   LCD DB6 = Microcomputer output port bit 6  
6641			;   LCD DB7 = Microcomputer output port bit 7  
6641			; Display's R/W is connected to 0v so it is always in write mode  
6641			; All 6 connections must be on the same port address <kLCDPrt>  
6641			; This method also allows a decent length of cable from micro to LCD  
6641			;  
6641			; **********************************************************************  
6641			;  
6641			; To include the code for any given function provided by this module,   
6641			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
6641			; the parent source file.  
6641			; For example:  #REQUIRES   uHexPrefix  
6641			;  
6641			; Also #INCLUDE this file at some point after the #REQUIRES statements  
6641			; in the parent source file.  
6641			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
6641			;  
6641			; These are the function names provided by this module:  
6641			; fLCD_Init                     ;Initialise LCD  
6641			; fLCD_Inst                     ;Send instruction to LCD  
6641			; fLCD_Data                     ;Send data byte to LCD  
6641			; fLCD_Pos                      ;Position cursor  
6641			; fLCD_Str                      ;Display string  
6641			; fLCD_Def                      ;Define custom character  
6641			;  
6641			; **********************************************************************  
6641			;  
6641			; Requires SCMonAPI.asm to also be included in the project  
6641			;  
6641			  
6641			  
6641			; **********************************************************************  
6641			; **  Constants  
6641			; **********************************************************************  
6641			  
6641			; Constants that must be defined externally  
6641			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
6641			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
6641			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
6641			;kLCDWidth: EQU 20             ;Width in characters  
6641			  
6641			; general line offsets in any frame buffer  
6641			  
6641			  
6641			display_row_1: equ 0  
6641			display_row_2: equ display_row_1+display_cols  
6641			display_row_3: equ display_row_2 + display_cols  
6641			display_row_4: equ display_row_3 + display_cols  
6641			;display_row_4_eol:   
6641			  
6641			  
6641			; Cursor position values for the start of each line  
6641			  
6641			; E  
6641			kLCD_Line1: EQU 0x00   
6641			kLCD_Line2: EQU kLCD_Line1+kLCDWidth  
6641			; E1  
6641			kLCD_Line3: EQU kLCD_Line2+kLCDWidth  
6641			kLCD_Line4: EQU kLCD_Line3+kLCDWidth   
6641			  
6641			; Instructions to send as A register to fLCD_Inst  
6641			kLCD_Clear: EQU 00000001b     ;LCD clear  
6641			kLCD_Off:   EQU 00001000b     ;LCD off  
6641			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
6641			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
6641			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
6641			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
6641			  
6641			; Constants used by this code module  
6641			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
6641			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
6641			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
6641			  
6641			  
6641			  
6641			; **********************************************************************  
6641			; **  LCD support functions  
6641			; **********************************************************************  
6641			  
6641			; Initialise alphanumeric LCD module  
6641			; LCD control register codes:  
6641			;   DL   0 = 4-bit mode        1 = 8-bit mode  
6641			;   N    0 = 1-line mode       1 = 2-line mode  
6641			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
6641			;   D    0 = Display off       1 = Display on  
6641			;   C    0 = Cursor off        1 = Cursor on  
6641			;   B    0 = Blinking off      1 = Blinking on  
6641			;   ID   0 = Decrement mode    1 = Increment mode  
6641			;   SH   0 = Entire shift off  1 = Entire shift on  
6641 3e 28		fLCD_Init:  LD   A, 40  
6643 cd 68 67		            CALL LCDDelay       ;Delay 40ms after power up  
6646			; For reliable reset set 8-bit mode - 3 times  
6646 cd 38 67		            CALL WrFn8bit       ;Function = 8-bit mode  
6649 cd 38 67		            CALL WrFn8bit       ;Function = 8-bit mode  
664c cd 38 67		            CALL WrFn8bit       ;Function = 8-bit mode  
664f			; Set 4-bit mode  
664f cd 34 67		            CALL WrFn4bit       ;Function = 4-bit mode  
6652 cd 66 67		            CALL LCDDelay1      ;Delay 37 us or more  
6655			; Function set  
6655 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
6657 cd 6a 66		            CALL fLCD_Inst      ;2 line, display on  
665a			; Display On/Off control  
665a 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
665c cd 6a 66		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
665f			; Display Clear  
665f 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
6661 cd 6a 66		            CALL fLCD_Inst      ;Clear display  
6664			; Entry mode  
6664 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
6666 cd 6a 66		            CALL fLCD_Inst      ;Increment mode, shift off  
6669			; Display module now initialised  
6669 c9			            RET  
666a			; ok to here  
666a			  
666a			; Write instruction to LCD  
666a			;   On entry: A = Instruction byte to be written  
666a			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
666a f5			fLCD_Inst:  PUSH AF  
666b f5			            PUSH AF  
666c cd 7e 66		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
666f f1			            POP  AF  
6670 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
6671 17			            RLA  
6672 17			            RLA  
6673 17			            RLA  
6674 cd 7e 66		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
6677 3e 02		            LD   A, 2  
6679 cd 68 67		            CALL LCDDelay       ;Delay 2 ms to complete   
667c f1			            POP  AF  
667d c9			            RET  
667e			Wr4bits:   
667e f5					push af  
667f 3a d7 f8				ld a, (display_lcde1e2)  
6682 fe 00				cp 0     ; e  
6684 20 10				jr nz, .wea2	  
6686 f1					pop af  
6687 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
6689 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
668b cb df		            SET  kLCDBitE, A	    ; TODO decide which E is being set  
668d cb 87		            res  kLCDBitE2, A	    ; TODO decide which E is being set  
668f d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6691 cb 9f		            RES  kLCDBitE, A        ; TODO decide which E is being set  
6693 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6695 c9			            RET  
6696 f1			.wea2:		pop af  
6697 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
6699 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
669b cb c7		            SET  kLCDBitE2, A	    ; TODO decide which E is being set  
669d cb 9f		            res  kLCDBitE, A	    ; TODO decide which E is being set  
669f d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
66a1 cb 87		            RES  kLCDBitE2, A        ; TODO decide which E is being set  
66a3 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
66a5 c9			            RET  
66a6			  
66a6			  
66a6			; Write data to LCD  
66a6			;   On entry: A = Data byte to be written  
66a6			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
66a6 f5			fLCD_Data:  PUSH AF  
66a7 f5			            PUSH AF  
66a8 cd ba 66		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
66ab f1			            POP  AF  
66ac 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
66ad 17			            RLA  
66ae 17			            RLA  
66af 17			            RLA  
66b0 cd ba 66		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
66b3 3e 96		            LD   A, 150  
66b5 3d			Wait:      DEC  A              ;Wait a while to allow data   
66b6 20 fd		            JR   NZ, Wait      ;  write to complete  
66b8 f1			            POP  AF  
66b9 c9			            RET  
66ba			Wr4bitsa:     
66ba f5					push af  
66bb 3a d7 f8				ld a, (display_lcde1e2)  
66be fe 00				cp 0     ; e1  
66c0 20 16				jr nz, .we2	  
66c2 f1					pop af  
66c3 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
66c5 cb d7		            SET  kLCDBitRS, A  
66c7 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
66c9 cb df		            SET  kLCDBitE, A      ; TODO Decide which E is being set  
66cb cb 87		            res  kLCDBitE2, A      ; TODO Decide which E is being set  
66cd d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
66cf cb 9f		            RES  kLCDBitE, A       ; TODO Decide which E is being set  
66d1 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
66d3 cb 97		            RES  kLCDBitRS, A  
66d5 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
66d7 c9			            RET  
66d8 f1			.we2:		pop af  
66d9 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
66db cb d7		            SET  kLCDBitRS, A  
66dd d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
66df cb c7		            SET  kLCDBitE2, A      ; TODO Decide which E is being set  
66e1 cb 9f		            res  kLCDBitE, A      ; TODO Decide which E is being set  
66e3 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
66e5 cb 87		            RES  kLCDBitE2, A       ; TODO Decide which E is being set  
66e7 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
66e9 cb 97		            RES  kLCDBitRS, A  
66eb d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
66ed c9			            RET  
66ee			  
66ee			  
66ee			; Position cursor to specified location  
66ee			;   On entry: A = Cursor position  
66ee			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
66ee f5			fLCD_Pos:   PUSH AF  
66ef					; at this point set the E1 or E2 flag depending on position  
66ef			  
66ef c5					push bc  
66f0			;		push af  
66f0 06 00				ld b, 0  
66f2 4f					ld c, a  
66f3 3e 4f				ld a, kLCD_Line3-1  
66f5 b7			 		or a      ;clear carry flag  
66f6 99					sbc a,c    ; TODO may need to sub 80 from a to put in context of current frame    
66f7 38 04				jr c, .pe1  
66f9			  
66f9					; E selection  
66f9 cb 80				res 0, b         ; bit 0 unset e  
66fb			;		pop af    ; before line 3 so recover orig pos  
66fb			;		ld c, a    ; save for poking back  
66fb 18 06				jr .peset	          
66fd			.pe1:          	; E2 selection  
66fd cb c0				set 0, b         ; bit 0 set e1  
66ff 79					ld a, c  
6700 de 4f				sbc a, kLCD_Line3-1  
6702 4f					ld c, a	         ; save caculated offset  
6703			;		pop af     ; bin this original value now we have calculated form  
6703			  
6703			.peset:		; set bit  
6703 78					ld a, b  
6704 32 d7 f8				ld (display_lcde1e2), a 	  
6707 79					ld a, c  
6708 c1					pop bc  
6709			  
6709 f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
670b cd 6a 66		            CALL fLCD_Inst      ;Write instruction to LCD  
670e f1			            POP  AF  
670f c9			            RET  
6710			  
6710			  
6710			; Output text string to LCD  
6710			;   On entry: DE = Pointer to null terminated text string  
6710			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
6710 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
6711 b7			            OR   A              ;Null terminator?  
6712 c8			            RET  Z              ;Yes, so finished  
6713 cd a6 66		            CALL fLCD_Data      ;Write character to display  
6716 13			            INC  DE             ;Point to next character  
6717 18 f7		            JR   fLCD_Str       ;Repeat  
6719 c9					ret  
671a			  
671a			; Define custom character  
671a			;   On entry: A = Character number (0 to 7)  
671a			;             DE = Pointer to character bitmap data  
671a			;   On exit:  A = Next character number  
671a			;             DE = Next location following bitmap  
671a			;             BC HL IX IY I AF' BC' DE' HL' preserved  
671a			; Character is   
671a c5			fLCD_Def:   PUSH BC  
671b f5			            PUSH AF  
671c 07			            RLCA                ;Calculate location  
671d 07			            RLCA                ;  for bitmap data  
671e 07			            RLCA                ;  = 8 x CharacterNumber  
671f f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
6721 cd 6a 66		            CALL fLCD_Inst      ;Write instruction to LCD  
6724 06 00		            LD   B, 0  
6726 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
6727 cd a6 66		            CALL fLCD_Data      ;Write byte to display  
672a 13			            INC  DE             ;Point to next byte  
672b 04			            INC  B              ;Count bytes  
672c cb 58		            BIT  3, B           ;Finish all 8 bytes?  
672e 28 f6		            JR   Z, Loop       ;No, so repeat  
6730 f1			            POP  AF  
6731 3c			            INC  A              ;Increment character number  
6732 c1			            POP  BC  
6733 c9			            RET  
6734			  
6734			  
6734			; **********************************************************************  
6734			; **  Private functions  
6734			; **********************************************************************  
6734			  
6734			; Write function to LCD  
6734			;   On entry: A = Function byte to be written  
6734			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6734 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
6736 18 02		            JR   WrFunc  
6738 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
673a f5			WrFunc:     PUSH AF  
673b f5					push af  
673c 3a d7 f8				ld a, (display_lcde1e2)  
673f fe 00				cp 0     ; e1  
6741 20 0f				jr nz, .wfea2	  
6743 f1					pop af  
6744 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6746 cb df		            SET  kLCDBitE, A     ; TODO Decide which E is being set  
6748 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
674a d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
674c cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
674e d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6750 18 0d			jr .wfskip  
6752 f1			.wfea2:		pop af  
6753 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6755 cb c7		            SET  kLCDBitE2, A     ; TODO Decide which E is being set  
6757 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
6759 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
675b cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
675d d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
675f 3e 05		.wfskip:            LD  A, 5  
6761 cd 68 67		            CALL LCDDelay       ;Delay 5 ms to complete  
6764 f1			            POP  AF  
6765 c9			            RET  
6766			  
6766			  
6766			; Delay in milliseconds  
6766			;   On entry: A = Number of milliseconds delay  
6766			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6766 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
6768 d5			LCDDelay:   PUSH DE  
6769 5f			            LD   E, A           ;Delay by 'A' ms  
676a 16 00		            LD   D, 0  
676c cd 4e 0a		            CALL aDelayInMS  
676f d1			            POP  DE  
6770 c9			            RET  
6771			  
6771			  
6771			testlcd:  
6771 3e 00			ld a, kLCD_Line1  
6773 cd ee 66			call fLCD_Pos  
6776 06 28			ld b, 40  
6778 11 a6 67			ld de, .ttext1  
677b cd 39 66			call write_len_string  
677e			  
677e 3e 28			ld a, kLCD_Line2  
6780 cd ee 66			call fLCD_Pos  
6783 06 28			ld b, 40  
6785 11 cf 67			ld de, .ttext2  
6788 cd 39 66			call write_len_string  
678b 3e 50			ld a, kLCD_Line3  
678d cd ee 66			call fLCD_Pos  
6790 06 28			ld b, 40  
6792 11 f8 67			ld de, .ttext3  
6795 cd 39 66			call write_len_string  
6798 3e 78			ld a, kLCD_Line4  
679a cd ee 66			call fLCD_Pos  
679d 06 28			ld b, 40  
679f 11 21 68			ld de, .ttext4  
67a2 cd 39 66			call write_len_string  
67a5			  
67a5 76				halt  
67a6			  
67a6			  
67a6 .. 00		.ttext1: db "A234567890123456789012345678901234567890",0  
67cf .. 00		.ttext2: db "B234567890123456789012345678901234567890",0  
67f8 .. 00		.ttext3: db "C234567890123456789012345678901234567890",0  
6821 .. 00		.ttext4: db "D234567890123456789012345678901234567890",0  
684a			   
684a			  
684a			  
684a			; eof  
684a			  
# End of file firmware_lcd_4x40.asm
684a			;include "firmware_lcd_4x20.asm" 
684a			include "firmware_key_5x10.asm" 
684a			; 5 x 10 decade counter scanner  
684a			  
684a			  
684a			; TODO do cursor shape change for shift keys  
684a			; TODO hard coded positions for the shift keys. Change to work like 4x4 and detect and then hide them  
684a			  
684a			  
684a			; bit mask for each scan column and row for teing the matrix  
684a			  
684a			  
684a			key_init:  
684a			  
684a			; SCMonAPI functions used  
684a			  
684a			; Alphanumeric LCD functions used  
684a			; no need to specify specific functions for this module  
684a			  
684a			  
684a 3e cf		            LD   A, 11001111b  
684c d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
684e			;            LD   A, 00000000b  
684e 3e 1f		            LD   A, 00011111b  
6850 d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
6852			  
6852			  
6852				; TODO Configure cursor shapes  
6852			  
6852				; Load cursor shapes   
6852 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
6854 11 64 68		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
6857 06 02		            LD   B, 2           ;Number of characters to define  
6859 cd 1a 67		.DefLoop:   CALL fLCD_Def       ;Define custom character  
685c 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
685e			  
685e 3e 01				ld a, 1  
6860 32 d0 f8			ld (cursor_shape),a  
6863 c9				ret  
6864			  
6864			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
6864			; Up to 8 custom characters can be defined  
6864			.cursor_shapes:      
6864			;; Character 0x00 = Normal  
6864 1f			            DB  11111b  
6865 1f			            DB  11111b  
6866 1f			            DB  11111b  
6867 1f			            DB  11111b  
6868 1f			            DB  11111b  
6869 1f			            DB  11111b  
686a 1f			            DB  11111b  
686b 1f			            DB  11111b  
686c			;; Character 0x01 = Modifier  
686c 1f			            DB  11111b  
686d 1b			            DB  11011b  
686e 1b			            DB  11011b  
686f 1b			            DB  11011b  
6870 1b			            DB  11011b  
6871 1f			            DB  11111b  
6872 1b			            DB  11011b  
6873 1f			            DB  11111b  
6874			  
6874			  
6874			  
6874			  
6874			; Display custom character 0  
6874			;            LD   A, kLCD_Line1+14  
6874			;            CALL fLCD_Pos       ;Position cursor to location in A  
6874			;            LD   A, 0  
6874			;            CALL fLCD_Data      ;Write character in A at cursor  
6874			  
6874			; Display custom character 1  
6874			;            LD   A, kLCD_Line2+14  
6874			;            CALL fLCD_Pos      ;Position cursor to location in A  
6874			;            LD   A, 1  
6874			;            CALL fLCD_Data     ;Write character in A at cursor  
6874			  
6874			; keyboard scanning   
6874			  
6874			; character in from keyboard  
6874			  
6874			; mapping for the pcb layout  
6874			  
6874			.matrix_to_char:  
6874 .. 08 05 0a 00			db "1357890",KEY_BS,KEY_UP,KEY_DOWN,0  
687f .. 0b 0c 00			db "qweryiop",KEY_LEFT,KEY_RIGHT,0  
688a 7e .. 0d 00			db KEY_SYMBOLSHIFT,"asdfghjk",KEY_CR,0  
6895 7e .. 7e 00			db KEY_SHIFT,"zxcvbnm ",KEY_SHIFT,0  
68a0 .. 10 11 12 .. 13 00			db "246tu",KEY_F1,KEY_F2,KEY_F3,"l",KEY_F4,0  
68ab			.matrix_to_shift:  
68ab			  
68ab .. 08 05 0a 00			db "!#%&*()",KEY_BS,KEY_UP,KEY_DOWN,0  
68b6 .. 07 06 00			db "QWERYIOP",KEY_PREVWORD,KEY_NEXTWORD,0  
68c1 7e .. 0d 00			db KEY_SYMBOLSHIFT,"ASDFGHJK",KEY_CR,0  
68cc 7e .. 7e 00			db KEY_SHIFT,"ZXCVBNM|",KEY_SHIFT,0  
68d7 .. .. 14 15 16 .. 17 00			db '"',"$^TU",KEY_F5,KEY_F6,KEY_F7,"L",KEY_F8,0  
68e2			  
68e2			.matrix_to_symbolshift:  
68e2			  
68e2 fc ed .. f7 08 05 0a 00			db 252,237,"5789",247,KEY_BS,KEY_UP,KEY_DOWN,0  
68ed .. b0 0e 0f 00			db "-+/=_?~",176,KEY_HOME,KEY_END,0  
68f8 7e .. a5 7c db ff 0d 00			db KEY_SYMBOLSHIFT,"[]{}",165,124,219,255,KEY_CR,0  
6903			;		db KEY_SHIFT,"<>,.:;'\\",KEY_SHIFT,0  
6903 7e .. 5c 7e 00	    	 	db KEY_SHIFT,"<>,.:;'",92, KEY_SHIFT,0  
690e .. f6 eb 7d 7e 18 19 1a df 1b 00			db "@",246,235,125,126,KEY_F9,KEY_F10,KEY_F11,223,KEY_F12,0  
6919			  
6919			  
6919			  
6919			; mapping for a simple straight through breadboard layout  
6919			  
6919			;.matrix_to_char:  
6919			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
6919			;		db KEY_SHIFT,"zxcvbnm ",KEY_SYMBOLSHIFT,0  
6919			;		db "asdfghjkl",KEY_CR,0  
6919			;		db "qwertyuiop",0  
6919			;		 db "1234567890",0  
6919			;.matrix_to_shift:  
6919			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_HOME, KEY_END,0  
6919			;		db KEY_SHIFT,"ZXCVBNM",KEY_BS,KEY_SYMBOLSHIFT,0  
6919			;		db "ASDFGHJKL",KEY_CR,0  
6919			;		db "QWERTYUIOP",0  
6919			;		 db "!",'"',"#$%^&*()",0  
6919			;.matrix_to_symbolshift:  
6919			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
6919			;		db KEY_SHIFT,"<>:;b,.",KEY_BS,KEY_SYMBOLSHIFT,0  
6919			;		db "_?*fghjk=",KEY_CR,0  
6919			;		db "-/+*[]{}@#",0  
6919			;		 db "1234567890",0  
6919			  
6919			;.matrix_to_char: db "D#0*C987B654A321"  
6919			  
6919			  
6919				  
6919			  
6919			; add cin and cin_wait  
6919			  
6919 cd 2a 69		cin_wait: 	call cin  
691c						if DEBUG_KEYCINWAIT  
691c							push af  
691c							  
691c							ld hl,key_repeat_ct  
691c							ld (hl),a  
691c							inc hl  
691c							call hexout  
691c							ld hl,key_repeat_ct+3  
691c							ld a,0  
691c							ld (hl),a  
691c			  
691c							    LD   A, kLCD_Line1+11  
691c							    CALL fLCD_Pos       ;Position cursor to location in A  
691c							    LD   DE, key_repeat_ct  
691c							    ;LD   DE, MsgHello  
691c							    CALL fLCD_Str       ;Display string pointed to by DE  
691c			  
691c			  
691c			  
691c							pop af  
691c						endif  
691c fe 00			cp 0  
691e 28 f9			jr z, cin_wait   ; block until key press  
6920			  
6920							if DEBUG_KEYCINWAIT  
6920								push af  
6920			  
6920								ld a, 'A'	  
6920								ld hl,key_repeat_ct  
6920								ld (hl),a  
6920								inc hl  
6920								ld a,0  
6920								ld (hl),a  
6920			  
6920								    LD   A, kLCD_Line2+11  
6920								    CALL fLCD_Pos       ;Position cursor to location in A  
6920								    LD   DE, key_repeat_ct  
6920								    ;LD   DE, MsgHello  
6920								    CALL fLCD_Str       ;Display string pointed to by DE  
6920			  
6920							call delay500ms  
6920			  
6920								pop af  
6920							endif  
6920 f5				push af   ; save key pressed  
6921			  
6921			.cin_wait1:	  
6921							if DEBUG_KEYCINWAIT  
6921								push af  
6921			  
6921								ld a, 'b'	  
6921								ld hl,key_repeat_ct  
6921								ld (hl),a  
6921								inc hl  
6921								ld a,0  
6921								ld (hl),a  
6921			  
6921								    LD   A, kLCD_Line2+11  
6921								    CALL fLCD_Pos       ;Position cursor to location in A  
6921								    LD   DE, key_repeat_ct  
6921								    ;LD   DE, MsgHello  
6921								    CALL fLCD_Str       ;Display string pointed to by DE  
6921			  
6921			  
6921							call delay500ms  
6921			  
6921								pop af  
6921							endif  
6921			  
6921 cd 2a 69		call cin  
6924 fe 00			cp 0  
6926 20 f9			jr nz, .cin_wait1  	; wait for key release  
6928			if DEBUG_KEYCINWAIT  
6928				push af  
6928			  
6928				ld a, '3'	  
6928				ld hl,key_repeat_ct  
6928				ld (hl),a  
6928				inc hl  
6928				ld a,0  
6928				ld (hl),a  
6928			  
6928			            LD   A, kLCD_Line2+11  
6928			            CALL fLCD_Pos       ;Position cursor to location in A  
6928			            LD   DE, key_repeat_ct  
6928			            ;LD   DE, MsgHello  
6928			            CALL fLCD_Str       ;Display string pointed to by DE  
6928			  
6928			  
6928			call delay500ms  
6928			  
6928				pop af  
6928			endif  
6928			  
6928 f1				pop af   ; get key  
6929 c9				ret  
692a			  
692a			  
692a cd 3e 69		cin: 	call .mtoc  
692d			  
692d			if DEBUG_KEYCIN  
692d				push af  
692d				  
692d				ld hl,key_repeat_ct  
692d				ld (hl),a  
692d				inc hl  
692d				call hexout  
692d				ld hl,key_repeat_ct+3  
692d				ld a,0  
692d				ld (hl),a  
692d			  
692d			            LD   A, kLCD_Line3+15  
692d			            CALL fLCD_Pos       ;Position cursor to location in A  
692d			            LD   DE, key_repeat_ct  
692d			            ;LD   DE, MsgHello  
692d			            CALL fLCD_Str       ;Display string pointed to by DE  
692d			  
692d			  
692d			call delay500ms  
692d			  
692d				pop af  
692d			endif  
692d			  
692d			  
692d				; no key held  
692d fe 00			cp 0  
692f c8				ret z  
6930			  
6930			if DEBUG_KEYCIN  
6930				push af  
6930			  
6930				ld a, '1'	  
6930				ld hl,key_repeat_ct  
6930				ld (hl),a  
6930				inc hl  
6930				ld a,0  
6930				ld (hl),a  
6930			  
6930			            LD   A, kLCD_Line4+15  
6930			            CALL fLCD_Pos       ;Position cursor to location in A  
6930			            LD   DE, key_repeat_ct  
6930			            ;LD   DE, MsgHello  
6930			            CALL fLCD_Str       ;Display string pointed to by DE  
6930			  
6930			  
6930			call delay500ms  
6930			  
6930				pop af  
6930			endif  
6930			  
6930				; stop key bounce  
6930			  
6930 32 88 fb			ld (key_held),a		 ; save it  
6933 47				ld b, a  
6934			  
6934 c5			.cina1:	push bc  
6935			if DEBUG_KEYCIN  
6935				push af  
6935			  
6935				ld hl,key_repeat_ct  
6935				inc hl  
6935				call hexout  
6935				ld hl,key_repeat_ct+3  
6935				ld a,0  
6935				ld (hl),a  
6935				ld hl,key_repeat_ct  
6935				ld a, '2'	  
6935				ld (hl),a  
6935			  
6935			            LD   A, kLCD_Line4+15  
6935			            CALL fLCD_Pos       ;Position cursor to location in A  
6935			            LD   DE, key_repeat_ct  
6935			            ;LD   DE, MsgHello  
6935			            CALL fLCD_Str       ;Display string pointed to by DE  
6935			  
6935				pop af  
6935			endif  
6935 cd 3e 69			call .mtoc  
6938 c1				pop bc  
6939 b8				cp b  
693a 28 f8			jr z, .cina1  
693c 78				ld a,b		  
693d			if DEBUG_KEYCIN  
693d				push af  
693d			  
693d				ld hl,key_repeat_ct  
693d				inc hl  
693d				call hexout  
693d				ld hl,key_repeat_ct+3  
693d				ld a,0  
693d				ld (hl),a  
693d				ld hl,key_repeat_ct  
693d				ld a, '3'	  
693d				ld (hl),a  
693d			  
693d			            LD   A, kLCD_Line4+15  
693d			            CALL fLCD_Pos       ;Position cursor to location in A  
693d			            LD   DE, key_repeat_ct  
693d			            ;LD   DE, MsgHello  
693d			            CALL fLCD_Str       ;Display string pointed to by DE  
693d			  
693d				pop af  
693d			endif  
693d c9				ret  
693e			  
693e			; detect keyboard modifier key press and apply new overlay to the face key held  
693e			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
693e			  
693e			;.cin_map_modifier:   
693e			;	ld a, (hl)  
693e			;	and 255  
693e			;	ret NZ		; modifier key not flagged  
693e			;  
693e			;	; get key face  
693e			;  
693e			;	ld b,(key_face_held)  
693e			;  
693e			;	ld b, key_cols * key_rows  
693e			;  
693e			;	push de  
693e			;	pop hl  
693e			;  
693e			;.mmod1: ld a,(hl)   ; get map test  
693e			;	cp b  
693e			;	jr z, .mmod2  
693e			;  
693e			;  
693e			;  
693e			;.mmod2: inc hl    ;   
693e			;  
693e			;	  
693e			;  
693e			;	  
693e			;  
693e			;	ld hl,key_actual_pressed  
693e			;	ld (hl),a,  
693e			;	ret  
693e			  
693e			; map matrix key held to char on face of key  
693e			  
693e			.mtoc:  
693e			  
693e			; test decade counter strobes  
693e			  
693e			;.decadetest1:  
693e			  
693e			; reset counter  
693e			;ld a, 128  
693e			;out (portbdata),a  
693e			  
693e			  
693e			;ld b, 5  
693e			;.dec1:  
693e			;ld a, 0  
693e			;out (portbdata),a  
693e			;call delay1s  
693e			  
693e			;ld a, 32  
693e			;out (portbdata),a  
693e			;call delay1s  
693e			;call delay1s  
693e			;call delay1s  
693e			;  
693e			;ld a, 64+32  
693e			;out (portbdata),a  
693e			;call delay1s  
693e			;;djnz .dec1  
693e			;  
693e			;jp .decadetest1  
693e			  
693e			  
693e			  
693e			  
693e			  
693e			  
693e			  
693e			  
693e			  
693e			  
693e				; scan keyboard matrix and generate raw scan map  
693e cd d1 69			call matrix  
6941			  
6941				; reuse c bit 0 left modifer button - ie shift  
6941			        ; reuse c bit 1 for right modifer button - ie symbol shift  
6941				; both can be used with their other mappings and if seen together can do extra mappings (forth keywords????)  
6941			  
6941 0e 00			ld c, 0  
6943			  
6943				; TODO set flags for modifer key presses   
6943				; TODO do a search for modifer key...  
6943			  
6943				;ld hl,keyscan_table_row4  
6943 21 e7 fb			ld hl,keyscan_table_row2  
6946			  
6946 7e				ld a, (hl)  
6947 fe 23			cp '#'  
6949 20 07			jr nz, .nextmodcheck  
694b cb c1			set 0, c  
694d 21 ab 68			ld hl, .matrix_to_shift  
6950 18 21			jr .dokeymap  
6952				; TODO for now igonre  
6952			.nextmodcheck:  
6952 21 dc fb			ld hl,keyscan_table_row3  
6955			  
6955 7e				ld a, (hl)  
6956 fe 23			cp '#'  
6958 20 07			jr nz, .nextmodcheck2  
695a cb c9			set 1, c   
695c 21 e2 68			ld hl, .matrix_to_symbolshift  
695f 18 12			jr .dokeymap  
6961			.nextmodcheck2:  
6961 21 f0 fb			ld hl,keyscan_table_row2+9    ; right shift  
6964			  
6964 7e				ld a, (hl)  
6965 fe 23			cp '#'  
6967 20 07			jr nz, .donemodcheck  
6969 cb c9			set 1, c   
696b 21 ab 68			ld hl, .matrix_to_shift  
696e 18 03			jr .dokeymap  
6970			  
6970				; no modifer found so just map to normal keys  
6970				; get mtoc map matrix to respective keys  
6970			;	ld hl, .matrix_to_char  
6970			;	ld hl, .matrix_to_char  
6970			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
6970			;	ld a, KEY_SHIFT  
6970			;	call findchar  
6970			;  
6970			;	; got offset to key modifer in b  
6970			;  
6970			;	ld hl,keyscan_table_row5  
6970			;  
6970			;	ld a,b  
6970			;	call addatohl  
6970			;	ld a,(hl)  
6970			;  
6970			;	cp '#'  
6970			;	jr nz, .nextmodcheck  
6970			;	set 0, c  
6970			;	ld hl, .matrix_to_char  
6970			;	jr .dokeymap  
6970			;	; TODO for now igonre  
6970			;.nextmodcheck:  
6970			;	ld hl, .matrix_to_symbolshift  
6970			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
6970			;	ld a, KEY_SYMBOLSHIFT  
6970			;	call findchar  
6970			;  
6970			;  
6970			;	; got offset to key modifer in b  
6970			;  
6970			;	ld hl,keyscan_table_row5  
6970			;  
6970			;	ld a,b  
6970			;	call addatohl  
6970			;	ld a,(hl)  
6970			;  
6970			;	cp '#'  
6970			;	jr nz, .donemodcheck  
6970			;	set 1, c   
6970			;	ld hl, .matrix_to_symbolshift  
6970			;	jr .dokeymap  
6970			  
6970			  
6970			  
6970			.donemodcheck:  
6970				; no modifer found so just map to normal keys  
6970				; get mtoc map matrix to respective keys  
6970 21 74 68			ld hl, .matrix_to_char  
6973			  
6973			.dokeymap:  
6973				;ld (key_fa), c   
6973 cd 8c 69			call .mapkeys  
6976			  
6976			  
6976			if DEBUG_KEY  
6976			  
6976			; Display text on first line  
6976			            LD   A, kLCD_Line1  
6976			            CALL fLCD_Pos       ;Position cursor to location in A  
6976			            LD   DE, keyscan_table_row1  
6976			            ;LD   DE, MsgHello  
6976			            CALL fLCD_Str       ;Display string pointed to by DE  
6976			  
6976			; Display text on second line  
6976			            LD   A, kLCD_Line2  
6976			            CALL fLCD_Pos       ;Position cursor to location in A  
6976			            LD   DE, keyscan_table_row2  
6976			            CALL fLCD_Str       ;Display string pointed to by DE  
6976			            LD   A, kLCD_Line3  
6976			            CALL fLCD_Pos       ;Position cursor to location in A  
6976			            LD   DE, keyscan_table_row3  
6976			            CALL fLCD_Str       ;Display string pointed to by DE  
6976			            LD   A, kLCD_Line4  
6976			            CALL fLCD_Pos       ;Position cursor to location in A  
6976			            LD   DE, keyscan_table_row4  
6976			            CALL fLCD_Str       ;Display string pointed to by DE  
6976			            LD   A, kLCD_Line1+10  
6976			            CALL fLCD_Pos       ;Position cursor to location in A  
6976			            LD   DE, keyscan_table_row5  
6976			            CALL fLCD_Str       ;Display string pointed to by DE  
6976			  
6976				;call delay250ms  
6976			endif  
6976			;	jp testkey  
6976			  
6976			; get first char reported  
6976			  
6976 21 c6 fb			ld hl,keyscan_table_row5  
6979			  
6979				;ld b, 46   ; 30 keys to remap + 8 nulls   
6979 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
697b			.findkey:  
697b 7e				ld a,(hl)  
697c fe 00			cp 0  
697e 28 04			jr z, .nextkey  
6980 fe 7e			cp KEY_MATRIX_NO_PRESS  
6982 20 06			jr nz, .foundkey  
6984			.nextkey:  
6984 23				inc hl  
6985 10 f4			djnz .findkey  
6987 3e 00			ld a,0  
6989 c9				ret  
698a			.foundkey:  
698a 7e				ld a,(hl)  
698b c9				ret  
698c				  
698c			  
698c			; convert the raw key map given hl for destination key  
698c			.mapkeys:  
698c 11 c6 fb			ld de,keyscan_table_row5  
698f			  
698f 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
6991			.remap:  
6991 1a				ld a,(de)  
6992 fe 23			cp '#'  
6994 20 02			jr nz, .remapnext  
6996				;CALLMONITOR  
6996 7e				ld a,(hl)  
6997 12				ld (de),a  
6998			  
6998			  
6998			  
6998			.remapnext:  
6998 23				inc hl  
6999 13				inc de  
699a 10 f5			djnz .remap  
699c				  
699c c9				ret  
699d			  
699d			  
699d			  
699d			.mtocold2:  
699d			  
699d			;	; flag if key D is held down and remove from reporting  
699d			;	ld bc, .key_map_fd    
699d			;	ld hl, keyscan_table  
699d			;	ld de, key_fd  
699d			;	call .key_shift_hold  
699d			;	cp 255  
699d			;	jr z, .cinmap  
699d			;	; flag if key C is held down and remove from reporting  
699d			;	ld bc, .key_map_fc    
699d			;	ld hl, keyscan_table+key_cols  
699d			;	ld de, key_fc  
699d			;	call .key_shift_hold  
699d			;	cp 255  
699d			;	jr z, .cinmap  
699d			;	; flag if key B is held down and remove from reporting  
699d			;	ld bc, .key_map_fb    
699d			;	ld hl, keyscan_table+(key_cols*2)  
699d			;	ld de, key_fb  
699d			;	call .key_shift_hold  
699d			;	cp 255  
699d			;	jr z, .cinmap  
699d			;	; flag if key A is held down and remove from reporting  
699d			;	ld bc, .key_map_fa    
699d			;	ld hl, keyscan_table+(key_cols*3)  
699d			;	ld de, key_fa  
699d			;	call .key_shift_hold  
699d			;	cp 255  
699d			;	jr z, .cinmap  
699d			  
699d 11 74 68			ld de, .matrix_to_char  
69a0			  
69a0			  
69a0			.cinmap1:   
69a0				if DEBUG_KEY  
69a0			            LD   A, kLCD_Line4  
69a0			            CALL fLCD_Pos       ;Position cursor to location in A  
69a0					push de  
69a0			            LD   DE, keyscan_table  
69a0			            CALL fLCD_Str       ;Display string pointed to by DE  
69a0					pop de  
69a0				endif  
69a0			  
69a0				; scan key matrix table for any held key  
69a0			  
69a0				; de holds either the default matrix or one selected above  
69a0			  
69a0 21 93 fb			ld hl, keyscan_table  
69a3 06 32			ld b,key_cols*key_rows  
69a5			  
69a5 7e			.cin11:	ld a,(hl)  
69a6 fe 23			cp '#'  
69a8 28 08			jr z, .cinhit1  
69aa 23				inc hl  
69ab 13				inc de  
69ac 05				dec b  
69ad 20 f6			jr nz, .cin11  
69af				; no key found held  
69af 3e 00			ld a,0  
69b1 c9				ret  
69b2 d5			.cinhit1: push de  
69b3 e1				pop hl  
69b4 7e				ld a,(hl)  
69b5 c9				ret  
69b6			  
69b6			; flag a control key is held   
69b6			; hl is key pin, de is flag indicator  
69b6			  
69b6			.key_shift_hold1:  
69b6 c5				push bc  
69b7 3e 01			ld a, 1  
69b9 32 d0 f8			ld (cursor_shape),a  
69bc 06 00			ld b, 0  
69be 7e				ld a, (hl)  
69bf fe 2e			cp '.'  
69c1 28 0a			jr z, .key_shift11  
69c3 06 ff			ld b, 255  
69c5 3e 2b			ld a, '+'    ; hide key from later scans  
69c7 77				ld (hl),a  
69c8 3e 02			ld a, 2  
69ca 32 d0 f8			ld (cursor_shape),a  
69cd			.key_shift11:  
69cd				; write flag indicator  
69cd 78				ld a,b  
69ce 12				ld (de),a  
69cf			  
69cf d1				pop de    ; de now holds the key map ptr  
69d0 c9				ret  
69d1			  
69d1				  
69d1			  
69d1			; scans keyboard matrix and flags key press in memory array	  
69d1				  
69d1			matrix:  
69d1				;call matrix  
69d1				; TODO optimise the code....  
69d1			  
69d1			  
69d1			;ld hl, keyscan_table_row1  
69d1			;ld de, keyscan_table_row1+1  
69d1			;ld bc,46  
69d1			;ld a,KEY_MATRIX_NO_PRESS  
69d1			;ldir  
69d1			  
69d1			  
69d1			  
69d1			; reset counter  
69d1 3e 80		ld a, 128  
69d3 d3 c1		out (portbdata),a  
69d5			  
69d5 06 0a		ld b, 10  
69d7 0e 00		ld c, 0       ; current clock toggle  
69d9			  
69d9			.colscan:  
69d9			  
69d9			; set current column  
69d9			; disable clock enable and set clock low  
69d9			  
69d9			;ld a, 0  
69d9			;out (portbdata),a  
69d9			  
69d9			; For each column scan for switches  
69d9			  
69d9 c5			push bc  
69da 21 89 fb		ld hl, keyscan_scancol  
69dd cd e6 6a		call .rowscan  
69e0 c1			pop bc  
69e1			  
69e1			  
69e1			; get back current column  
69e1			  
69e1			; translate the row scan  
69e1			  
69e1			;   
69e1			; row 1  
69e1			  
69e1 78			ld a,b  
69e2			  
69e2 21 fc fb		LD   hl, keyscan_table_row1+10  
69e5			  
69e5 cd 2f 0d		call subafromhl  
69e8			;call addatohl  
69e8			  
69e8 11 89 fb		ld de, keyscan_scancol  
69eb			  
69eb 1a			ld a,(de)  
69ec 77			ld (hl),a  
69ed			  
69ed			  
69ed			  
69ed			  
69ed			; row 2  
69ed			  
69ed 78			ld a,b  
69ee			  
69ee 21 f1 fb		LD   hl, keyscan_table_row2+10  
69f1			  
69f1			;call addatohl  
69f1 cd 2f 0d		call subafromhl  
69f4			  
69f4			  
69f4 11 8a fb		ld de, keyscan_scancol+1  
69f7			  
69f7 1a			ld a,(de)  
69f8 77			ld (hl),a  
69f9			  
69f9			  
69f9			; row 3  
69f9			  
69f9 78			ld a,b  
69fa			  
69fa 21 e6 fb		LD   hl, keyscan_table_row3+10  
69fd			  
69fd			;call addatohl  
69fd cd 2f 0d		call subafromhl  
6a00			  
6a00 11 8b fb		ld de, keyscan_scancol+2  
6a03			  
6a03 1a			ld a,(de)  
6a04 77			ld (hl),a  
6a05			  
6a05			  
6a05			  
6a05			; row 4  
6a05			  
6a05 78			ld a,b  
6a06			  
6a06 21 db fb		LD   hl, keyscan_table_row4+10  
6a09			  
6a09			;call addatohl  
6a09 cd 2f 0d		call subafromhl  
6a0c			  
6a0c 11 8c fb		ld de, keyscan_scancol+3  
6a0f			  
6a0f 1a			ld a,(de)  
6a10 77			ld (hl),a  
6a11			  
6a11			; row 5  
6a11			  
6a11 78			ld a,b  
6a12			  
6a12 21 d0 fb		LD   hl, keyscan_table_row5+10  
6a15			  
6a15			;call addatohl  
6a15 cd 2f 0d		call subafromhl  
6a18			  
6a18 11 8d fb		ld de, keyscan_scancol+4  
6a1b			  
6a1b 1a			ld a,(de)  
6a1c 77			ld (hl),a  
6a1d			  
6a1d			; handshake next column  
6a1d			  
6a1d			  
6a1d 3e 40		ld a, 64  
6a1f d3 c1		out (portbdata),a  
6a21			  
6a21 3e 00		ld a, 0  
6a23 d3 c1		out (portbdata),a  
6a25			  
6a25			; toggle clk and move to next column  
6a25			;ld a, 64  
6a25			;cp c  
6a25			;  
6a25			;jr z, .coltoglow  
6a25			;ld c, a  
6a25			;jr .coltog  
6a25			;.coltoglow:  
6a25			;ld c, 0  
6a25			;.coltog:  
6a25			;ld a, c  
6a25			;out (portbdata),a  
6a25			  
6a25 10 b2		djnz .colscan  
6a27			  
6a27 3e 0a		ld a,10  
6a29 21 f2 fb		LD   hl, keyscan_table_row1  
6a2c cd 1d 0d		call addatohl  
6a2f 3e 00		ld a, 0  
6a31 77			ld (hl), a  
6a32			  
6a32			  
6a32 3e 0a		ld a,10  
6a34 21 e7 fb		LD   hl, keyscan_table_row2  
6a37 cd 1d 0d		call addatohl  
6a3a 3e 00		ld a, 0  
6a3c 77			ld (hl), a  
6a3d			  
6a3d 3e 0a		ld a,10  
6a3f 21 dc fb		LD   hl, keyscan_table_row3  
6a42 cd 1d 0d		call addatohl  
6a45 3e 00		ld a, 0  
6a47 77			ld (hl), a  
6a48			  
6a48 3e 0a		ld a,10  
6a4a 21 d1 fb		LD   hl, keyscan_table_row4  
6a4d cd 1d 0d		call addatohl  
6a50 3e 00		ld a, 0  
6a52 77			ld (hl), a  
6a53			  
6a53 3e 0a		ld a,10  
6a55 21 c6 fb		LD   hl, keyscan_table_row5  
6a58 cd 1d 0d		call addatohl  
6a5b 3e 00		ld a, 0  
6a5d 77			ld (hl), a  
6a5e			  
6a5e			if DEBUG_KEY_MATRIX  
6a5e			  
6a5e			; Display text on first line  
6a5e			            LD   A, kLCD_Line1  
6a5e			            CALL fLCD_Pos       ;Position cursor to location in A  
6a5e			            LD   DE, keyscan_table_row1  
6a5e			            ;LD   DE, MsgHello  
6a5e			            CALL fLCD_Str       ;Display string pointed to by DE  
6a5e			  
6a5e			; Display text on second line  
6a5e			            LD   A, kLCD_Line2  
6a5e			            CALL fLCD_Pos       ;Position cursor to location in A  
6a5e			            LD   DE, keyscan_table_row2  
6a5e			            CALL fLCD_Str       ;Display string pointed to by DE  
6a5e			            LD   A, kLCD_Line3  
6a5e			            CALL fLCD_Pos       ;Position cursor to location in A  
6a5e			            LD   DE, keyscan_table_row3  
6a5e			            CALL fLCD_Str       ;Display string pointed to by DE  
6a5e			            LD   A, kLCD_Line4  
6a5e			            CALL fLCD_Pos       ;Position cursor to location in A  
6a5e			            LD   DE, keyscan_table_row4  
6a5e			            CALL fLCD_Str       ;Display string pointed to by DE  
6a5e			            LD   A, kLCD_Line4+10  
6a5e			            CALL fLCD_Pos       ;Position cursor to location in A  
6a5e			            LD   DE, keyscan_table_row5  
6a5e			            CALL fLCD_Str       ;Display string pointed to by DE  
6a5e			  
6a5e			;call delay250ms  
6a5e				jp matrix  
6a5e			endif  
6a5e c9			ret  
6a5f			  
6a5f			; using decade counter....  
6a5f			  
6a5f			  
6a5f			; TODO reset decade counter to start of scan  
6a5f			  
6a5f			; reset 15  
6a5f			; clock 14  
6a5f			; ce 13  
6a5f			  
6a5f			; 1 - q5  
6a5f			; 2 - q1  
6a5f			; 3 - q0  
6a5f			; 4 - q2  
6a5f			; 5 - q6  
6a5f			; 6 - q7  
6a5f			; 7 - q3  
6a5f			; 8 - vss  
6a5f			; 9 - q8  
6a5f			; 10 - q4  
6a5f			; 11 - q9  
6a5f			; 12 - cout  
6a5f			; 16 - vdd  
6a5f			  
6a5f			; clock      ce       reset     output  
6a5f			; 0          x        0         n  
6a5f			; x          1        0         n  
6a5f			; x          x        1         q0  
6a5f			; rising     0        0         n+1  
6a5f			; falling    x        0         n  
6a5f			; x          rising   0         n  
6a5f			; 1          falling  0         x+1  
6a5f			;  
6a5f			; x = dont care, if n < 5 carry = 1 otherwise 0  
6a5f			  
6a5f			;   
6a5f			; reset   
6a5f			; 13=0, 14=0, 15=1 .. 15=0  
6a5f			;  
6a5f			; handshake line  
6a5f			; 14=1.... read line 14=0  
6a5f			  
6a5f			  
6a5f			  
6a5f			  
6a5f			  
6a5f			; TODO hand shake clock for next column scan  
6a5f			; TODO detect each row  
6a5f			  
6a5f			  
6a5f			  
6a5f			  
6a5f			; reset 128  
6a5f			; clock 64  
6a5f			; ce 32  
6a5f			  
6a5f			  
6a5f			.cyclestart:  
6a5f			  
6a5f			; reset counter  
6a5f 3e 80		ld a, 128  
6a61 d3 c1		out (portbdata),a  
6a63			  
6a63			; loop leds  
6a63 06 0a		ld b,10  
6a65			  
6a65			.cycle1:  
6a65 c5			push bc  
6a66 3e 00		ld a, 0  
6a68 d3 c1		out (portbdata),a  
6a6a cd 5d 0a		call delay250ms  
6a6d			  
6a6d 3e 40		ld a, 64  
6a6f d3 c1		out (portbdata),a  
6a71 cd 5d 0a		call delay250ms  
6a74			  
6a74 3e 00		ld a, 0  
6a76 d3 c1		out (portbdata),a  
6a78 cd 5d 0a		call delay250ms  
6a7b			  
6a7b c1			pop bc  
6a7c 10 e7		djnz .cycle1  
6a7e			  
6a7e			  
6a7e 18 df		jr .cyclestart  
6a80			  
6a80			  
6a80			  
6a80			  
6a80			  
6a80			  
6a80			  
6a80			  
6a80			  
6a80			; map matrix key held to char on face of key  
6a80			  
6a80			;.mtocold:  
6a80			;  
6a80			;  
6a80			;; reset counter  
6a80			;ld a, 128  
6a80			;out (portbdata),a  
6a80			;  
6a80			;  
6a80			;; scan keyboard row 1  
6a80			;ld a, 0  
6a80			;out (portbdata),a  
6a80			;;ld a, 64  
6a80			;;out (portbdata),a  
6a80			;  
6a80			;  
6a80			;	ld a, 128  
6a80			;	ld hl, keyscan_table  
6a80			;	call .rowscan  
6a80			;  
6a80			;;ld a, 0  
6a80			;;out (portbdata),a  
6a80			;ld a, 64  
6a80			;out (portbdata),a  
6a80			;  
6a80			;	ld a, 64  
6a80			;	ld hl, keyscan_table+key_cols  
6a80			;	call .rowscan  
6a80			;  
6a80			;ld a, 0  
6a80			;out (portbdata),a  
6a80			;;ld a, 64  
6a80			;;out (portbdata),a  
6a80			;	ld a, 32  
6a80			;	ld hl, keyscan_table+(key_cols*2)  
6a80			;	call .rowscan  
6a80			;  
6a80			;  
6a80			;;ld a, 0  
6a80			;;out (portbdata),a  
6a80			;ld a, 64  
6a80			;out (portbdata),a  
6a80			;  
6a80			;	ld a, 16  
6a80			;	ld hl, keyscan_table+(key_cols*3)  
6a80			;	call .rowscan  
6a80			;  
6a80			;  
6a80			;	; flag if key D is held down and remove from reporting  
6a80			;	ld bc, .key_map_fd    
6a80			;	ld hl, keyscan_table  
6a80			;	ld de, key_fd  
6a80			;	call .key_shift_hold  
6a80			;	cp 255  
6a80			;	jr z, .cinmap  
6a80			;	; flag if key C is held down and remove from reporting  
6a80			;	ld bc, .key_map_fc    
6a80			;	ld hl, keyscan_table+key_cols  
6a80			;	ld de, key_fc  
6a80			;	call .key_shift_hold  
6a80			;	cp 255  
6a80			;	jr z, .cinmap  
6a80			;	; flag if key B is held down and remove from reporting  
6a80			;	ld bc, .key_map_fb    
6a80			;	ld hl, keyscan_table+(key_cols*2)  
6a80			;	ld de, key_fb  
6a80			;	call .key_shift_hold  
6a80			;	cp 255  
6a80			;	jr z, .cinmap  
6a80			;	; flag if key A is held down and remove from reporting  
6a80			;	ld bc, .key_map_fa    
6a80			;	ld hl, keyscan_table+(key_cols*3)  
6a80			;	ld de, key_fa  
6a80			;	call .key_shift_hold  
6a80			;	cp 255  
6a80			;	jr z, .cinmap  
6a80			;  
6a80			;	ld de, .matrix_to_char  
6a80			;  
6a80			;  
6a80			;.cinmap:   
6a80			;	if DEBUG_KEY  
6a80			;            LD   A, kLCD_Line4  
6a80			;            CALL fLCD_Pos       ;Position cursor to location in A  
6a80			;		push de  
6a80			;            LD   DE, keyscan_table  
6a80			;            CALL fLCD_Str       ;Display string pointed to by DE  
6a80			;		pop de  
6a80			;	endif  
6a80			  
6a80				; scan key matrix table for any held key  
6a80			  
6a80				; de holds either the default matrix or one selected above  
6a80			  
6a80			;	ld hl, keyscan_table  
6a80			;	ld b,key_cols*key_rows  
6a80			;  
6a80			;.cin1:	ld a,(hl)  
6a80			;	cp '#'  
6a80			;	jr z, .cinhit  
6a80			;	inc hl  
6a80			;	inc de  
6a80			;	dec b  
6a80			;	jr nz, .cin1  
6a80			;	; no key found held  
6a80			;	ld a,0  
6a80			;	ret  
6a80			;.cinhit: push de  
6a80			;	pop hl  
6a80			;	ld a,(hl)  
6a80			;	ret  
6a80			  
6a80			; flag a control key is held   
6a80			; hl is key pin, de is flag indicator  
6a80			  
6a80			;.key_shift_hold:  
6a80			;	push bc  
6a80			;	ld a, 1  
6a80			;	ld (cursor_shape),a  
6a80			;	ld b, 0  
6a80			;	ld a, (hl)  
6a80			;	cp '.'  
6a80			;	jr z, .key_shift1  
6a80			;	ld b, 255  
6a80			;	ld a, '+'    ; hide key from later scans  
6a80			;	ld (hl),a  
6a80			;	ld a, 2  
6a80			;	ld (cursor_shape),a  
6a80			;.key_shift1:  
6a80			;	; write flag indicator  
6a80			;	ld a,b  
6a80			;	ld (de),a  
6a80			;  
6a80			;	pop de    ; de now holds the key map ptr  
6a80			;	ret  
6a80			  
6a80				  
6a80				  
6a80			  
6a80			  
6a80			  
6a80			  
6a80			  
6a80			  
6a80			  
6a80			  
6a80			  
6a80			  
6a80			  
6a80			;	push hl  
6a80			;	push de  
6a80			;	push bc  
6a80			;	call keyscan  
6a80			;	; map key matrix to ascii value of key face  
6a80			;  
6a80			;	ld hl, key_face_map  
6a80			;	ld de, keyscan_table  
6a80			;  
6a80			;	; get how many keys to look at  
6a80			;	ld b, keyscan_table_len  
6a80			;	  
6a80			;  
6a80			;	; at this stage fall out on first key hit  
6a80			;	; TODO handle multiple key press  
6a80			;  
6a80			;map1:	ld a,(hl)  
6a80			;	cp '#'  
6a80			;	jr z, keyhit  
6a80			;	inc hl  
6a80			;	inc de  
6a80			;	dec b  
6a80			;	jr nz, map1  
6a80			;nohit:	ld a, 0  
6a80			;	jr keydone  
6a80			;keyhit: push de  
6a80			;	pop hl  
6a80			;	ld a,(hl)  
6a80			;keydone:  
6a80			;	push bc  
6a80			;	push de  
6a80			; 	push hl  
6a80			;	ret   
6a80			;  
6a80			  
6a80			  
6a80			  
6a80			  
6a80			; scan physical key matrix  
6a80			  
6a80			  
6a80			;keyscan:  
6a80			;  
6a80			;; for each key_row use keyscanr bit mask for out  
6a80			;; then read in for keyscanc bitmask  
6a80			;; save result of row scan to keyscantable  
6a80			;  
6a80			;; scan keyboard row 1  
6a80			;  
6a80			;	ld b, key_rows  
6a80			;	ld hl, key_scanr  
6a80			;	ld de, keyscan_table  
6a80			;  
6a80			;rowloop:  
6a80			;  
6a80			;	ld a,(hl)		; out bit mask to energise keyboard row  
6a80			;	call rowscan  
6a80			;	inc hl  
6a80			;	dec b  
6a80			;	jr nz, rowloop  
6a80			;  
6a80			;	ret  
6a80			;  
6a80			;  
6a80			;; pass a out bitmask, b row number  
6a80			;arowscan:   
6a80			;	push bc  
6a80			;  
6a80			;	ld d, b  
6a80			;  
6a80			;	; calculate buffer location for this row  
6a80			;  
6a80			;	ld hl, keyscan_table	  
6a80			;kbufr:  ld e, key_cols  
6a80			;kbufc:	inc hl  
6a80			;	dec e  
6a80			;	jr nz, kbufc  
6a80			;	dec d  
6a80			;	jr nz, kbufr  
6a80			;  
6a80			;	; energise row and read columns  
6a80			;  
6a80			;	out (portbdata),a  
6a80			;	in a,(portbdata)  
6a80			;	ld c,a  
6a80			;  
6a80			;  
6a80			;	; save buffer loc  
6a80			;  
6a80			;	ld (keybufptr), hl  
6a80			;  
6a80			;	ld hl, key_scanc  
6a80			;	ld d, key_cols  
6a80			;  
6a80			;	; for each column check each bit mask  
6a80			;  
6a80			;colloop:  
6a80			;	  
6a80			;  
6a80			;	; reset flags for the row   
6a80			;  
6a80			;	ld b,'.'  
6a80			;	and (hl)  
6a80			;	jr z, maskskip  
6a80			;	ld b,'#'  
6a80			;maskskip:  
6a80			;	; save  key state  
6a80			;	push hl  
6a80			;	ld hl, (keybufptr)  
6a80			;	ld (hl), b  
6a80			;	inc hl  
6a80			;	ld (keybufptr), hl  
6a80			;  
6a80			;	; move to next bit mask  
6a80			;	pop hl  
6a80			;	inc hl  
6a80			;  
6a80			;	dec d  
6a80			;	jr nz, colloop  
6a80			;  
6a80			;	ret  
6a80			;  
6a80			;  
6a80			;;  
6a80			; lcd functions  
6a80			;  
6a80			;  
6a80			  
6a80			;if DEBUG_KEY_MATRIX  
6a80			  
6a80			; test function to display hardware view of matrix state  
6a80			  
6a80			matrixold:  
6a80			  
6a80			  
6a80			  
6a80			; reset counter  
6a80 3e 80		ld a, 128  
6a82 d3 c1		out (portbdata),a  
6a84			; scan keyboard row 1  
6a84 3e 00		ld a, 0  
6a86 d3 c1		out (portbdata),a  
6a88			;ld a, 64  
6a88			;out (portbdata),a  
6a88 3e 80			ld a, 128  
6a8a 21 f2 fb			ld hl, keyscan_table_row1  
6a8d cd e6 6a			call .rowscan  
6a90			  
6a90			;ld a, 0  
6a90			;out (portbdata),a  
6a90 3e 40		ld a, 64  
6a92 d3 c1		out (portbdata),a  
6a94 3e 40			ld a, 64  
6a96 21 e7 fb			ld hl, keyscan_table_row2  
6a99 cd e6 6a			call .rowscan  
6a9c			  
6a9c 3e 00		ld a, 0  
6a9e d3 c1		out (portbdata),a  
6aa0			;ld a, 64  
6aa0			;out (portbdata),a  
6aa0 3e 20			ld a, 32  
6aa2 21 dc fb			ld hl, keyscan_table_row3  
6aa5 cd e6 6a			call .rowscan  
6aa8			  
6aa8			;ld a, 0  
6aa8			;out (portbdata),a  
6aa8 3e 40		ld a, 64  
6aaa d3 c1		out (portbdata),a  
6aac 3e 10			ld a, 16  
6aae 21 d1 fb			ld hl, keyscan_table_row4  
6ab1 cd e6 6a			call .rowscan  
6ab4			  
6ab4			; Display text on first line  
6ab4 3e 00		            LD   A, kLCD_Line1  
6ab6 cd ee 66		            CALL fLCD_Pos       ;Position cursor to location in A  
6ab9 11 f2 fb		            LD   DE, keyscan_table_row1  
6abc			            ;LD   DE, MsgHello  
6abc cd 10 67		            CALL fLCD_Str       ;Display string pointed to by DE  
6abf			  
6abf			; Display text on second line  
6abf 3e 28		            LD   A, kLCD_Line2  
6ac1 cd ee 66		            CALL fLCD_Pos       ;Position cursor to location in A  
6ac4 11 e7 fb		            LD   DE, keyscan_table_row2  
6ac7 cd 10 67		            CALL fLCD_Str       ;Display string pointed to by DE  
6aca 3e 50		            LD   A, kLCD_Line3  
6acc cd ee 66		            CALL fLCD_Pos       ;Position cursor to location in A  
6acf 11 dc fb		            LD   DE, keyscan_table_row3  
6ad2 cd 10 67		            CALL fLCD_Str       ;Display string pointed to by DE  
6ad5 3e 78		            LD   A, kLCD_Line4  
6ad7 cd ee 66		            CALL fLCD_Pos       ;Position cursor to location in A  
6ada 11 d1 fb		            LD   DE, keyscan_table_row4  
6add cd 10 67		            CALL fLCD_Str       ;Display string pointed to by DE  
6ae0			  
6ae0 cd 5d 0a			call delay250ms  
6ae3 c3 d1 69			jp matrix  
6ae6			  
6ae6			; pass de as row display flags  
6ae6			.rowscan:   
6ae6			;	out (portbdata),a  
6ae6 db c1			in a,(portbdata)  
6ae8 4f				ld c,a  
6ae9				; reset flags for the row   
6ae9 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6aeb e6 01			and 1  
6aed 28 02			jr z, .p1on  
6aef 06 23			ld b,'#'  
6af1			.p1on:  
6af1 70				ld (hl), b  
6af2 23				inc hl  
6af3			  
6af3 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6af5 79				ld a,c  
6af6 e6 02			and 2  
6af8			;	bit 0,a  
6af8 28 02			jr z, .p2on  
6afa 06 23			ld b,'#'  
6afc			.p2on:  
6afc 70				ld (hl), b  
6afd 23				inc hl  
6afe			;  
6afe 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6b00 79				ld a,c  
6b01 e6 04			and 4  
6b03			;;	bit 0,a  
6b03 28 02			jr z, .p3on  
6b05 06 23			ld b,'#'  
6b07			.p3on:  
6b07 70				ld (hl), b  
6b08 23				inc hl  
6b09			;;  
6b09 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6b0b			;;	bit 0,a  
6b0b 79				ld a,c  
6b0c e6 08			and 8  
6b0e 28 02			jr z, .p4on  
6b10 06 23			ld b,'#'  
6b12			.p4on:  
6b12 70				ld (hl), b  
6b13 23				inc hl  
6b14			  
6b14 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6b16			;;	bit 0,a  
6b16 79				ld a,c  
6b17 e6 10			and 16  
6b19 28 02			jr z, .p5on  
6b1b 06 23			ld b,'#'  
6b1d			.p5on:  
6b1d 70				ld (hl), b  
6b1e 23				inc hl  
6b1f			; zero term  
6b1f 06 00			ld b,0  
6b21 70				ld (hl), b  
6b22			  
6b22 c9			.rscandone: ret  
6b23			  
6b23			;addatohl:  
6b23			;  
6b23			 ;add   a, l    ; A = A+L  
6b23			  ;  ld    l, a    ; L = A+L  
6b23			   ; adc   a, h    ; A = A+L+H+carry  
6b23			   ; sub   l       ; A = H+carry  
6b23			   ; ld    h, a    ; H = H+carry  
6b23			  
6b23			;ret  
6b23			; eof  
# End of file firmware_key_5x10.asm
6b23			;include "firmware_key_4x10.asm" 
6b23			 
6b23			heap_size:    equ heap_end - heap_start 
6b23			;eof 
# End of file os_mega.asm
6b23
