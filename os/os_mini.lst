# File os_mini.asm
0000			; 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ 0 
0000			CPU_CLOCK_10MHZ: equ 0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			tos:	equ 0fffdh 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
0000			 
0000			 
0000			; Full OS but with the small 4x4 keypad 
0000			 
0000			display_rows: equ 4     ; move out to mini and mega files 
0000			display_cols: equ 20 
0000			 
0000			key_rows: equ 4     ; TODO move out to mini and mega 
0000			key_cols: equ 4    ; TODO move out to mini and mega 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 c2 18			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			;        nop  
0003			;        nop 
0003			;;	org 05h		; null out bdos call 
0003			; 
0003			;        nop  
0003			;        nop  
0003			;        nop 
0003			;;	org 08h 
0003			;;; 
0003			;;	jp cin		; rst 8 - char in 
0003			;;; 
0003			; 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;	org 010h 
0003			;; 
0003			;	jp cout		; rest 010h  - char out 
0003			;; 
0003			;	org 01bh   
0003			; 
0003			;	;jp  		; rst 01bh   - write string to display 
0003			;	jp str_at_display 
0003			; 
0003			; 
0003			;	org 020h 
0003			; 
0003			;	; jp		 ; rst 020h - read char at screen location 
0003			; 
0003			;	org 028h 
0003			 
0003				; jp		 ; rst 028h  - storage i/o 
0003			 
0003			; 	org 030h 
0003			;	jp break_point_state 
0003			  
0003			; $30  
0003			; org 038h 
0003			; $38 
0003			 
0003			; TODO any more important entry points to add to jump table for easier coding use? 
0003			 
0003			 
0003			include "firmware.asm" 
0003			  
0003			; main constants (used here and in firmware)  
0003			  
0003			; TODO have page 0 of storage as bios  
0003			  
0003			Device_A: equ 0h  
0003			Device_B: equ 040h          ; Sound  
0003			  
0003			if BASE_KEV  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_SC114  
0003			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			; TODO fixup for CPM  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			Device_D: equ 0c0h             ; Keyboard and LCD  
0003			  
0003			; Odd specific debug points for testing hardware dev  
0003			  
0003			DEBUG_SOUND: equ 1  
0003			DEBUG_STK_FAULT: equ 0  
0003			DEBUG_INPUT: equ 0     ; Debug input entry code  
0003			DEBUG_KEYCINWAIT: equ 0  
0003			DEBUG_KEYCIN: equ 0  
0003			DEBUG_KEY: equ 0  
0003			DEBUG_KEY_MATRIX: equ 0  
0003			DEBUG_STORECF: equ 0  
0003			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
0003			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
0003			DEBUG_SPI: equ 0    ; low level spi tests  
0003			  
0003			; Enable many break points  
0003			  
0003			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
0003			DEBUG_FORTH_JP: equ 0    ; 4  
0003			DEBUG_FORTH_MALLOC: equ 0  
0003			DEBUG_FORTH_MALLOC_INT: equ 0  
0003			DEBUG_FORTH_DOT: equ 0  
0003			DEBUG_FORTH_DOT_WAIT: equ 0  
0003			DEBUG_FORTH_MATHS: equ 0  
0003			DEBUG_FORTH_TOK: equ 0    ; 4  
0003			DEBUG_FORTH_PARSE: equ 0    ; 3  
0003			DEBUG_FORTH: equ 0  ;2  
0003			DEBUG_FORTH_WORDS: equ 1   ; 1  
0003			DEBUG_FORTH_PUSH: equ 1   ; 1  
0003			DEBUG_FORTH_UWORD: equ 1   ; 1  
0003			  
0003			; Enable key point breakpoints  
0003			  
0003			DEBUG_FORTH_DOT_KEY: equ 0  
0003			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
0003			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
0003			  
0003			; Debug stack imbalances  
0003			  
0003			ON: equ 1  
0003			OFF: equ 0  
0003			  
0003			DEBUG_STACK_IMB: equ 0  
0003			STACK_IMB_STORE: equ 20  
0003			  
0003			; House keeping and protections  
0003			  
0003			DEBUG_FORTH_STACK_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
0003			FORTH_ENABLE_FREE: equ 0  
0003			FORTH_ENABLE_MALLOCFREE: equ 1  
0003			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
0003			FORTH_ENABLE_FLOATMATH: equ 0  
0003			  
0003			  
0003			CALLMONITOR: macro  
0003				call break_point_state  
0003				endm  
0003			  
0003			MALLOC_1: equ 1        ; from dk88   
0003			MALLOC_2: equ 0           ; broke  
0003			MALLOC_3: equ 0           ; really broke  
0003			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
0003			  
0003			if BASE_KEV   
0003			stacksize: equ 512*2  
0003			  
0003			STACK_RET_SIZE: equ 128  
0003			STACK_LOOP_SIZE: equ 512  
0003			STACK_DATA_SIZE: equ 512  
0003			endif  
0003			if BASE_SC114  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			;if STORAGE_SE == 0  
0003			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
0003			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
0003			;endif  
0003			  
0003			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
0003			  
0003			STORE_0_AUTOFILE: equ $21  
0003			STORE_0_BANKRUN: equ $23  
0003			STORE_0_FILERUN: equ $24  
0003			  
0003			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
0003			  
0003			STORE_0_AUTORUN: equ $20  
0003			  
0003			; Blocks where directory table is held  
0003			  
0003			; Reducing the number of entries increases the max file size  
0003			  
0003			;STORE_DIR_START: equ 1  
0003			;STORE_DIR_END: equ 33  
0003			  
0003			; Blocks from where file data is stored  
0003			  
0003			;STORE_DATA_START: equ STORE_DIR_END + 1  
0003			  
0003			; Block indicators (<32 are data files)  
0003			  
0003			;STORE_BLOCK_CFG: equ $8f       ; config block  
0003			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
0003			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
0003			;STORE_BLOCK_FREE: equ $85       ; data block free  
0003			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
0003			  
0003			  
0003			  
0003			; Directory entry flags  
0003			  
0003			;STORE_DIR_FREE: equ 0  
0003			;STORE_DIR_FILE:  equ 1  
0003			  
0003			; Structure offsets to directory entries  
0003			;STORE_DE_FLAG: equ 0  
0003			;STORE_DE_MAXEXT: equ 1  
0003			;STORE_DE_FILENAME: equ 2  
0003			  
0003			; Structure offsets to block 0  
0003			  
0003			;STORE_BK0_ISFOR: equ 1  
0003			;STORE_BK0_LABEL: equ 3  
0003			  
0003			; memory allocation   
0003			  
0003			chk_stund: equ tos+2           ; underflow check word  
0003			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
0003			  
0003			; keyscan table needs rows x cols buffer  
0003			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
0003			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
0003			  
0003			keyscan_table_row1: equ chk_stovr -key_cols-1  
0003			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
0003			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
0003			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
0003			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
0003			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
0003			keyscan_scancol: equ keyscan_table-key_cols  
0003			;keyscan_table_len: equ key_rows*key_cols  
0003			;keybufptr: equ keyscan_table - 2  
0003			;keysymbol: equ keybufptr - 1  
0003			key_held: equ keyscan_scancol-1	; currently held  
0003			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
0003			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
0003			key_fa: equ key_repeat_ct -1 ;  
0003			key_fb: equ key_fa -1 ;  
0003			key_fc: equ key_fb -1 ;  
0003			key_fd: equ key_fc -1 ;  
0003			key_face_held: equ key_fd - 1   
0003			  
0003			; flag for enabling/disabling various hardware diags   
0003			  
0003			hardware_diag: equ key_face_held - 1  
0003			  
0003			; hardware config switches  
0003			; TODO add bitmasks on includes for hardware  
0003			; high byte for expansion ids  
0003			;     0000 0000  no card inserted  
0003			;     0000 0001  storage card inserted  
0003			;     0000 0010  spi sd card active  
0003			  
0003			;       
0003			; low byte:  
0003			;     0000 0001   4x4 keypad  
0003			;     0000 0010   full keyboard  
0003			;     0000 0011   spi/ext keyboard  
0003			;     0000 0100   20x4 lcd  
0003			;     0000 1000   40x4 lcd  
0003			;     0000 1100   spi/ext display  
0003			;     0001 0000   ide interface available  
0003			  
0003			hardware_word: equ hardware_diag - 2  
0003			  
0003			; debug marker - optional display of debug point on the debug screens  
0003			  
0003			debug_mark: equ hardware_word - 4  
0003			  
0003			; input_str vars  
0003			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
0003			input_start:  equ input_ptr - 2    ; ptr to the start of string   
0003			input_size: equ input_start -1  ; number of chars  
0003			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
0003			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
0003			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
0003			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
0003			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
0003			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
0003			input_len: equ input_cur_onoff - 5 ; length of current input  
0003			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
0003			  
0003			CUR_BLINK_RATE: equ 15  
0003			  
0003			key_actual_pressed: equ input_cursor - 1   
0003			key_symbol: equ key_actual_pressed - 1   
0003			key_shift: equ key_symbol - 1   
0003			  
0003			; Display allocation  
0003			  
0003			;display_rows: equ 4     ; move out to mini and mega files  
0003			;display_cols: equ 20  
0003			  
0003			display_fb_len: equ display_rows*display_cols  
0003			  
0003			; primary frame buffer     
0003			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
0003			; working frame buffers  
0003			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
0003			display_fb3: equ  display_fb1-display_fb_len - 1  
0003			display_fb2: equ  display_fb3-display_fb_len - 1  
0003			;  
0003			; pointer to active frame buffer  
0003			display_fb_active: equ display_fb2 - 2  
0003			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
0003			display_write_tmp: equ display_lcde1e2 - 2  
0003			  
0003			  
0003			;  
0003			  
0003			;; can load into de directory  
0003			cursor_col: equ display_write_tmp-1  
0003			cursor_row: equ cursor_col-1  
0003			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
0003			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
0003			  
0003			; maths vars  
0003			  
0003			LFSRSeed: equ cursor_shape -20   
0003			randData: equ LFSRSeed - 2  
0003			xrandc: equ randData - 2  
0003			stackstore: equ xrandc - 2  
0003			seed1: equ  stackstore -2   
0003			seed2: equ seed1 - 2  
0003			  
0003			; cf storage vars  
0003			  
0003			iErrorNum:  equ seed2-1         ;Error number  
0003			iErrorReg:  equ iErrorNum -1              ;Error register  
0003			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
0003			  
0003			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
0003			  
0003			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
0003			  
0003			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
0003			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
0003			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
0003			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
0003			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
0003			store_tmpid: equ store_tmp3 - 1		; page temp id  
0003			store_tmpext: equ store_tmpid - 1		; file extent temp  
0003			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
0003			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
0003			store_filecache: equ store_openmaxext-(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
0003			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
0003			;  
0003			; spi vars  
0003			  
0003			  
0003			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
0003			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
0003			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
0003			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
0003			spi_device_id: equ spi_device - 1    ; human readable bank number  
0003			  
0003			;;;;; forth cli params  
0003			  
0003			; TODO use a different frame buffer for forth???  
0003			  
0003			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
0003			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
0003			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
0003			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
0003			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
0003			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
0003			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
0003			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
0003			  
0003			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
0003			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
0003			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
0003			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
0003			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
0003			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
0003			  
0003			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
0003			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
0003			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
0003			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
0003			chk_data_ovr: equ cli_data_stack -2; overflow check word  
0003			  
0003			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
0003			  
0003			; os/forth token vars  
0003			  
0003			os_last_cmd: equ os_var_array-255  
0003			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
0003			os_current_i: equ os_cli_cmd-2  
0003			os_cur_ptr: equ os_current_i-2  
0003			os_word_scratch: equ os_cur_ptr-30  
0003			os_tok_len: equ os_word_scratch - 2  
0003			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
0003			os_tok_malloc: equ os_tok_ptr - 2  
0003			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
0003			os_input: equ os_last_new_uword-255  
0003			execscratch: equ os_input-255        ; exec cmd eval buffer  
0003			scratch: equ execscratch-255  
0003			  
0003			  
0003			; temp locations for new word processing to save on adding more   
0003			  
0003			os_new_malloc: equ scratch-2  
0003			os_new_parse_len: equ os_new_malloc - 2  
0003			os_new_word_len: equ os_new_parse_len - 2  
0003			os_new_work_ptr: equ os_new_word_len - 2  
0003			os_new_src_ptr: equ os_new_work_ptr - 2  
0003			os_new_exec: equ os_new_src_ptr - 2  
0003			os_new_exec_ptr: equ os_new_exec - 2  
0003			  
0003			; resume memory alloocations....  
0003			  
0003			os_view_disable: equ os_new_exec_ptr - 1  
0003			os_view_af: equ os_view_disable - 2  
0003			os_view_hl: equ os_view_af -2  
0003			os_view_de: equ os_view_hl - 2  
0003			os_view_bc: equ os_view_de - 2  
0003			  
0003			; stack checksum word  
0003			if DEBUG_STACK_IMB  
0003				curframe: equ  os_view_de - 5  
0003				store_sp: equ curframe - (STACK_IMB_STORE*4)  
0003				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			else  
0003				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			endif  
0003			  
0003			; with data stack could see memory filled with junk. need some memory management   
0003			; malloc and free entry points added  
0003			  
0003			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
0003			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			;heap_end: equ free_list-1  ; Starting address of heap  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			heap_end: equ chk_word-1  ; Starting address of heap  
0003			  
0003			  
0003			;if BASE_KEV   
0003			;heap_start: equ 0800eh  ; Starting address of heap  
0003			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;heap_start: equ baseram+15  ; Starting address of heap  
0003			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;endif  
0003			  
0003			  
0003			;;;;  
0003			  
0003			  
0003			; change below to point to last memory alloc above  
0003			topusermem:  equ   heap_start  
0003			  
0003			;if BASE_KEV   
0003			;baseusermem: equ 08000h  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;;aseusermem:     equ    12  
0003			;baseusermem:     equ    prompt  
0003			;;baseusermem:     equ    endofcode  
0003			;endif  
0003			  
0003			  
0003			; **********************************************************************  
0003			; **  Constants  
0003			; **********************************************************************  
0003			  
0003			; Constants used by this code module  
0003			kDataReg:   EQU Device_D           ;PIO port A data register  
0003			kContReg:   EQU Device_D+2           ;PIO port A control register  
0003			  
0003			  
0003			portbdata:  equ Device_D+1    ; port b data  
0003			portbctl:   equ Device_D+3    ; port b control  
0003			  
0003			  
0003			;KEY_SHIFT:   equ 5  
0003			;KEY_SYMBOLSHIFT:  equ 6  
0003			  
0003			KEY_SHIFTLOCK: equ 4  
0003			  
0003			  
0003			KEY_UP: equ 5  
0003			KEY_NEXTWORD: equ 6  
0003			KEY_PREVWORD: equ 7  
0003			KEY_BS: equ 8  
0003			KEY_TAB:  equ 9  
0003			KEY_DOWN: equ 10  
0003			KEY_LEFT: equ 11  
0003			KEY_RIGHT: equ 12  
0003			KEY_CR:   equ 13  
0003			KEY_HOME: equ 14  
0003			KEY_END: equ 15  
0003			  
0003			KEY_F1: equ 16  
0003			KEY_F2: equ 17  
0003			KEY_F3: equ 18  
0003			KEY_F4: equ 19  
0003			  
0003			KEY_F5: equ 20  
0003			KEY_F6: equ 21  
0003			KEY_F7: equ 22  
0003			KEY_F8: equ 23  
0003			  
0003			KEY_F9: equ 24  
0003			KEY_F10: equ 25  
0003			KEY_F11: equ 26  
0003			KEY_F12: equ 27  
0003			  
0003			;if DEBUG_KEY  
0003			;	KEY_MATRIX_NO_PRESS: equ '.'  
0003			;	KEY_SHIFT:   equ '.'  
0003			;	KEY_SYMBOLSHIFT:  equ '.'  
0003			;else  
0003				KEY_SHIFT:   equ '~'  
0003				KEY_SYMBOLSHIFT:  equ '~'  
0003				KEY_MATRIX_NO_PRESS: equ '~'  
0003			;endi  
0003			  
0003			  
0003			  
0003			  
0003			; Macro to make adding debug marks easier  
0003			  
0003			DMARK: macro str  
0003				push af  
0003				ld a, (.dmark)  
0003				ld (debug_mark),a  
0003				ld a, (.dmark+1)  
0003				ld (debug_mark+1),a  
0003				ld a, (.dmark+2)  
0003				ld (debug_mark+2),a  
0003				jr .pastdmark  
0003			.dmark: db str  
0003			.pastdmark: pop af  
0003			  
0003			endm  
0003			  
0003			  
0003			; macro to detect for stack imbalances  
0003			  
0003			include "stackimbal.asm"  
0003			; Macro and code to detect stock imbalances 
0003			 
0003			SPPUSH: equ 0 
0003			 
0003			; Add a stack frame which can be checked before return 
0003			 
0003			STACKFRAME: macro onoff frame1 frame2 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003						exx 
0003			 
0003						ld de, frame1 
0003						ld a, d 
0003						ld hl, curframe 
0003						call hexout 
0003						ld a, e 
0003						ld hl, curframe+2 
0003						call hexout 
0003			  
0003						ld hl, frame1 
0003						push hl 
0003						ld hl, frame2 
0003						push hl 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			endm 
0003			 
0003			STACKFRAMECHK: macro onoff frame1 frame2 
0003			 
0003					 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						exx 
0003						; check stack frame SP 
0003			 
0003						ld hl, frame2 
0003						pop de   ; frame2 
0003			 
0003						call cmp16 
0003						jr nz, .spnosame 
0003						 
0003			 
0003						ld hl, frame1 
0003						pop de   ; frame1 
0003			 
0003						call cmp16 
0003						jr z, .spfrsame 
0003			 
0003						.spnosame: call showsperror 
0003			 
0003						.spfrsame: nop 
0003			 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			 
0003			 
0003			endm 
0003			 
0003			 
0003			; for a sub routine, wrap SP collection and comparisons 
0003			 
0003			; Usage: 
0003			; 
0003			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
0003			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
0003			 
0003			SAVESP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003			 
0003						ld (store_sp+(storeword*4)), sp 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			CHECKSP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003			 
0003						; save SP after last save 
0003				 
0003						ld (store_sp+(storeword*4)+2), sp 
0003			 
0003						push hl 
0003						ld hl, store_sp+(storeword*4) 
0003						call check_stack_sp  
0003						pop hl 
0003			 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			if DEBUG_STACK_IMB 
0003			 
0003			check_stack_sp: 
0003					push de 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					push de 
0003			 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					pop hl 
0003			 
0003			 
0003					; check to see if the same 
0003			 
0003					call cmp16 
0003					jr z, .spsame 
0003			 
0003					; not same 
0003			 
0003					call showsperror 
0003			.spsame: 
0003			 
0003					pop de 
0003			 
0003					ret 
0003			 
0003			.sperr:  db "Stack imbalance",0 
0003			 
0003			 
0003			showsperror: 
0003			 
0003			 
0003				push hl 
0003				push af 
0003				push de 
0003				call clear_display 
0003				ld de, .sperr 
0003				ld a,0 
0003			;	ld de,os_word_scratch 
0003				call str_at_display 
0003				ld a, display_row_1+17 
0003				ld de, debug_mark 
0003				call str_at_display 
0003				ld a, 0 
0003				ld (curframe+4),a 
0003				ld hl, curframe 
0003				ld de, os_word_scratch 
0003				ld a, display_row_4 
0003				call str_at_display 
0003				call update_display 
0003				;call break_point_state 
0003				call cin_wait 
0003			 
0003				ld a, ' ' 
0003				ld (os_view_disable), a 
0003				pop de	 
0003				pop af 
0003				pop hl 
0003				CALLMONITOR 
0003				ret 
0003			 
0003			endif 
0003			 
0003			 
0003			 
0003			; eof 
# End of file stackimbal.asm
0003			  
0003			;TODO macro to calc col and row offset into screen  
0003			  
0003			  
0003			  
0003			hardware_init:  
0003			  
0003 3e 00				ld a, 0  
0005 32 c3 fb				ld (hardware_diag), a  
0008			  
0008					; clear all the buffers  
0008			  
0008 21 02 fb				ld hl, display_fb1  
000b 22 5e fa				ld (display_fb_active), hl  
000e			  
000e cd d2 0a				call clear_display  
0011			  
0011 21 60 fa				ld hl, display_fb2  
0014 22 5e fa				ld (display_fb_active), hl  
0017			  
0017 cd d2 0a				call clear_display  
001a			  
001a					; init primary frame buffer area  
001a 21 53 fb				ld hl, display_fb0  
001d 22 5e fa				ld (display_fb_active), hl  
0020			  
0020 cd d2 0a				call clear_display  
0023			  
0023			  
0023 cd 39 66				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0026			  
0026 cd 82 67			call key_init  
0029 cd c9 01			call storage_init  
002c			  
002c				; setup malloc functions  
002c			  
002c				if MALLOC_1  
002c cd a9 11				call  heap_init  
002f				endif  
002f				if MALLOC_4  
002f					call  heap_init  
002f				endif  
002f			  
002f				; init sound hardware if present  
002f			  
002f				if SOUND_ENABLE  
002f					call sound_init  
002f				endif  
002f			  
002f				; lcd test sequence  
002f					  
002f cd f5 0a			call update_display  
0032 cd 52 0a			call delay1s  
0035 3e 2b			ld a,'+'  
0037 cd d7 0a			call fill_display  
003a cd f5 0a			call update_display  
003d cd 52 0a			call delay1s  
0040 3e 2a			ld a,'*'  
0042 cd d7 0a			call fill_display  
0045 cd f5 0a			call update_display  
0048 cd 52 0a			call delay1s  
004b 3e 2d			ld a,'-'  
004d cd d7 0a			call fill_display  
0050 cd f5 0a			call update_display  
0053 cd 52 0a			call delay1s  
0056			  
0056			; boot splash screen  
0056			if display_cols == 20	  
0056 3e 00		        ld a, display_row_1    
0058			else  
0058			        ld a, display_row_1 +10   
0058			endif  
0058 11 89 00			ld de, bootmsg  
005b cd e5 0a			call str_at_display  
005e cd f5 0a			call update_display  
0061			  
0061			  
0061 cd 52 0a			call delay1s  
0064 cd 52 0a			call delay1s  
0067			if display_cols == 20	  
0067 3e 2a		            LD   A, display_row_3+2  
0069			else  
0069			            LD   A, display_row_3+12  
0069			endif  
0069 11 9e 00			ld de, bootmsg1  
006c cd e5 0a			call str_at_display  
006f cd f5 0a			call update_display  
0072 cd 52 0a			call delay1s  
0075 cd 52 0a			call delay1s  
0078			  
0078			;	ld a, display_row_4+3  
0078			;	ld de, bootmsg2  
0078			;	call str_at_display  
0078			;	call update_display  
0078			;	call delay1s  
0078			;	call delay1s  
0078			  
0078			; debug mark setup  
0078			  
0078 3e 5f		ld a, '_'  
007a 32 bd fb		ld (debug_mark),a  
007d 32 be fb		ld (debug_mark+1),a  
0080 32 bf fb		ld (debug_mark+2),a  
0083 3e 00		ld a,0  
0085 32 c0 fb		ld (debug_mark+3),a  
0088			  
0088 c9					ret  
0089			  
0089			  
0089 .. 00		bootmsg:	db "z80-homebrew OS v1.5",0  
009e .. 00		bootmsg1:	db "by Kevin Groves",0  
00ae			;bootmsg2:	db "Firmware v0.1",0  
00ae			  
00ae			; a 4x20 lcd  
00ae			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00ae			  
00ae			;if display_cols == 20  
00ae			;	include "firmware_lcd_4x20.asm"  
00ae			;endif  
00ae			  
00ae			;if display_cols == 40  
00ae			;	include "firmware_lcd_4x40.asm"  
00ae			;endif  
00ae			  
00ae			;  
00ae			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00ae			; TODO abstract the bit bang video out interface for dual display  
00ae			; TODO wire video out to tx pin on rc2014 bus  
00ae			  
00ae			; must supply cin, and cin_wait for low level hardware abstraction   
00ae			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00ae			; test scancode  
00ae			  
00ae			;;;;;  
00ae			;;;  
00ae			; Moved out to mini and maxi versions  
00ae			;  
00ae			; include "firmware_key_4x4.asm"  
00ae			; using existing 4 wire x 4 resistor array for input  
00ae			;include "firmware_key_4x10.asm"  
00ae			; need to mod the board for 5 rows due to resistor array  
00ae			;include "firmware_key_5x10.asm"  
00ae			  
00ae			; storage hardware interface  
00ae			  
00ae			; use microchip serial eeprom for storage  
00ae			  
00ae			  
00ae			if STORAGE_SE  
00ae				include "firmware_spi.asm"  
00ae			; my spi protocol (used by storage) 
00ae			 
00ae			; SPI pins 
00ae			 
00ae			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00ae			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00ae			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00ae			 
00ae			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00ae			; chip pin 4 gnd 
00ae			 
00ae			 
00ae			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00ae			SPI_CE1: equ 1      ;    port a1 pin 14  
00ae			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00ae			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00ae			SPI_CE4: equ 4      ; port a4     pin 10 
00ae			 
00ae			; active low AND masks 
00ae			 
00ae			;SPI_CE0_MASK: equ    255-1 
00ae			;SPI_CE1_MASK: equ   255-2 
00ae			;SPI_CE2_MASK: equ   255-4 
00ae			;SPI_CE3_MASK: equ   255-8 
00ae			;SPI_CE4_MASK: equ   255-16 
00ae			SPI_CE_HIGH:  equ 255 
00ae			 
00ae			 
00ae			 
00ae			 
00ae			; TODO store port id for spi device ie dev c 
00ae			; TODO store pin for SO 
00ae			; TODO store pin for SI 
00ae			; TODO store pin for SCLK 
00ae			 
00ae			; 
00ae			 
00ae			; ensure that spi bus is in a stable state with default pins  
00ae			 
00ae			se_stable_spi:   
00ae			 
00ae				 ; set DI high, CE high , SCLK low 
00ae				;ld a, SPI_DI | SPI_CE0 
00ae 3e 07			ld a, SPI_DI  
00b0 cd 84 01			call spi_ce_high 
00b3 d3 80			 out (storage_adata),a 
00b5 32 cf f9			ld (spi_portbyte),a 
00b8			 
00b8				if DEBUG_SPI 
00b8					push hl 
00b8					ld l, a 
00b8					DMARK "SPI" 
00b8					CALLMONITOR 
00b8					pop hl 
00b8				endif 
00b8 c9				ret 
00b9			 
00b9			; byte to send in a 
00b9			 
00b9			spi_send_byte: 
00b9				; save byte to send for bit mask shift out 
00b9 4f			        ld c,a 
00ba 3a cf f9			ld a,(spi_portbyte) 
00bd				  
00bd				; clock out	each bit of the byte msb first 
00bd			 
00bd 06 08			ld b, 8 
00bf			.ssb1: 
00bf				; clear so bit  
00bf cb bf			res SPI_DI, a 
00c1 cb 11			rl c 
00c3				; if bit 7 is set then carry is set 
00c3 30 02			jr nc, .ssb2 
00c5 cb ff			set SPI_DI,a 
00c7			.ssb2:  ; output bit to ensure it is stable 
00c7 d3 80			out (storage_adata),a 
00c9 00				nop 
00ca				; clock bit high 
00ca cb ef			set SPI_SCLK,a 
00cc d3 80			out (storage_adata),a 
00ce 00				nop 
00cf				; then low 
00cf cb af			res SPI_SCLK,a 
00d1 d3 80			out (storage_adata),a 
00d3 00				nop 
00d4 10 e9			djnz .ssb1 
00d6			 
00d6 32 cf f9			ld (spi_portbyte),a 
00d9 c9				ret 
00da			 
00da			; TODO low level get byte into A on spi 
00da			 
00da			spi_read_byte:  
00da			 
00da				; save byte to send for bit mask shift out 
00da 0e 00		    ld c,0 
00dc 3a cf f9			ld a,(spi_portbyte) 
00df				  
00df				; clock out	each bit of the byte msb first 
00df			 
00df			 
00df				; clock bit high 
00df cb ef			set SPI_SCLK,a 
00e1 d3 80			out (storage_adata),a 
00e3 00				nop 
00e4			 
00e4			    ; read DO  
00e4			 
00e4 cb f9		    set 7,c 
00e6 db 80			in a,(storage_adata) 
00e8 cb 77		    bit SPI_DO,a 
00ea 20 02		    jr nz, .b7 
00ec cb b9		    res 7,c 
00ee			.b7: 
00ee				; then low 
00ee cb af			res SPI_SCLK,a 
00f0 d3 80			out (storage_adata),a 
00f2 00				nop 
00f3			     
00f3			 
00f3				; clock bit high 
00f3 cb ef			set SPI_SCLK,a 
00f5 d3 80			out (storage_adata),a 
00f7 00				nop 
00f8			 
00f8			    ; read DO  
00f8			 
00f8 cb f1		    set 6,c 
00fa db 80			in a,(storage_adata) 
00fc cb 77		    bit SPI_DO,a 
00fe 20 02		    jr nz, .b6 
0100 cb b1		    res 6,c 
0102			.b6: 
0102				; then low 
0102 cb af			res SPI_SCLK,a 
0104 d3 80			out (storage_adata),a 
0106 00				nop 
0107			 
0107				; clock bit high 
0107 cb ef			set SPI_SCLK,a 
0109 d3 80			out (storage_adata),a 
010b 00				nop 
010c			 
010c			 
010c			    ; read DO  
010c			 
010c cb e9		    set 5,c 
010e db 80			in a,(storage_adata) 
0110 cb 77		    bit SPI_DO,a 
0112 20 02		    jr nz, .b5 
0114 cb a9		    res 5,c 
0116			.b5: 
0116				; then low 
0116 cb af			res SPI_SCLK,a 
0118 d3 80			out (storage_adata),a 
011a 00				nop 
011b				; clock bit high 
011b cb ef			set SPI_SCLK,a 
011d d3 80			out (storage_adata),a 
011f 00				nop 
0120			 
0120			    ; read DO  
0120			 
0120 cb e1		    set 4,c 
0122 db 80			in a,(storage_adata) 
0124 cb 77		    bit SPI_DO,a 
0126 20 02		    jr nz, .b4 
0128 cb a1		    res 4,c 
012a			.b4: 
012a				; then low 
012a cb af			res SPI_SCLK,a 
012c d3 80			out (storage_adata),a 
012e 00				nop 
012f				; clock bit high 
012f cb ef			set SPI_SCLK,a 
0131 d3 80			out (storage_adata),a 
0133 00				nop 
0134			 
0134			    ; read DO  
0134			 
0134 cb d9		    set 3,c 
0136 db 80			in a,(storage_adata) 
0138 cb 77		    bit SPI_DO,a 
013a 20 02		    jr nz, .b3 
013c cb 99		    res 3,c 
013e			.b3: 
013e				; then low 
013e cb af			res SPI_SCLK,a 
0140 d3 80			out (storage_adata),a 
0142 00				nop 
0143				; clock bit high 
0143 cb ef			set SPI_SCLK,a 
0145 d3 80			out (storage_adata),a 
0147 00				nop 
0148			 
0148			    ; read DO  
0148			 
0148 cb d1		    set 2,c 
014a db 80			in a,(storage_adata) 
014c cb 77		    bit SPI_DO,a 
014e 20 02		    jr nz, .b2 
0150 cb 91		    res 2,c 
0152			.b2: 
0152				; then low 
0152 cb af			res SPI_SCLK,a 
0154 d3 80			out (storage_adata),a 
0156 00				nop 
0157				; clock bit high 
0157 cb ef			set SPI_SCLK,a 
0159 d3 80			out (storage_adata),a 
015b 00				nop 
015c			 
015c			    ; read DO  
015c			 
015c cb c9		    set 1,c 
015e db 80			in a,(storage_adata) 
0160 cb 77		    bit SPI_DO,a 
0162 20 02		    jr nz, .b1 
0164 cb 89		    res 1,c 
0166			.b1: 
0166				; then low 
0166 cb af			res SPI_SCLK,a 
0168 d3 80			out (storage_adata),a 
016a 00				nop 
016b				; clock bit high 
016b cb ef			set SPI_SCLK,a 
016d d3 80			out (storage_adata),a 
016f 00				nop 
0170			 
0170			    ; read DO  
0170			 
0170 cb c1		    set 0,c 
0172 db 80			in a,(storage_adata) 
0174 cb 77		    bit SPI_DO,a 
0176 20 02		    jr nz, .b0 
0178 cb 81		    res 0,c 
017a			.b0: 
017a				; then low 
017a cb af			res SPI_SCLK,a 
017c d3 80			out (storage_adata),a 
017e 00				nop 
017f			 
017f			 
017f 32 cf f9			ld (spi_portbyte),a 
0182			 
0182			    ; return byte 
0182 79			    ld a,c 
0183			 
0183			 
0183 c9				ret 
0184			 
0184			 
0184			 
0184			spi_ce_high: 
0184			 
0184				if DEBUG_SPI_HARD_CE0 
0184			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0184					ret 
0184			 
0184				endif 
0184			 
0184			 
0184 f5				push af 
0185			 
0185				; send direct ce to port b 
0185 3e ff			ld a, 255 
0187 d3 81			out (storage_bdata), a 
0189			 
0189 f1				pop af 
018a			 
018a				; for port a that shares with spi lines AND the mask 
018a			  
018a				if DEBUG_SPI 
018a					push hl 
018a					ld h, a 
018a				endif 
018a			;	ld c, SPI_CE_HIGH 
018a			;	and c 
018a cb c7			set SPI_CE0, a 
018c cb cf			set SPI_CE1, a 
018e cb d7			set SPI_CE2, a 
0190 cb df			set SPI_CE3, a 
0192 cb e7			set SPI_CE4, a 
0194			 
0194				if DEBUG_SPI 
0194					ld l, a 
0194					DMARK "CEh" 
0194					CALLMONITOR 
0194					pop hl 
0194				endif 
0194 c9				ret 
0195			 
0195			 
0195			spi_ce_low: 
0195			 
0195				if DEBUG_SPI_HARD_CE0 
0195			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0195					ret 
0195			 
0195				endif 
0195			 
0195 c5				push bc 
0196 f5				push af 
0197			 
0197				; send direct ce to port b 
0197 3a d1 f9			ld a, (spi_cartdev) 
019a d3 81			out (storage_bdata), a 
019c			 
019c			 
019c			 
019c				; for port a that shares with spi lines AND the mask 
019c			 
019c 3a ce f9			ld a, (spi_device)  
019f 4f				ld c, a 
01a0			 
01a0 f1				pop af 
01a1			 
01a1				; detect CEx 
01a1			 
01a1				if DEBUG_SPI 
01a1					push hl 
01a1					ld h, a 
01a1				endif 
01a1			 
01a1 cb 41			bit SPI_CE0, c 
01a3 20 04			jr nz, .cel1 
01a5 cb 87			res SPI_CE0, a 
01a7 18 1e			jr .celn 
01a9			.cel1: 
01a9 cb 49			bit SPI_CE1, c 
01ab 20 04			jr nz, .cel2 
01ad cb 8f			res SPI_CE1, a 
01af 18 16			jr .celn 
01b1			.cel2: 
01b1 cb 51			bit SPI_CE2, c 
01b3 20 04			jr nz, .cel3 
01b5 cb 97			res SPI_CE2, a 
01b7 18 0e			jr .celn 
01b9			.cel3: 
01b9 cb 59			bit SPI_CE3, c 
01bb 20 04			jr nz, .cel4 
01bd cb 9f			res SPI_CE3, a 
01bf 18 06			jr .celn 
01c1			.cel4: 
01c1 cb 61			bit SPI_CE4, c 
01c3 20 02			jr nz, .celn 
01c5 cb a7			res SPI_CE4, a 
01c7			.celn: 
01c7			 
01c7			 
01c7			 
01c7			;	add c 
01c7			 
01c7				if DEBUG_SPI 
01c7					ld l, a 
01c7					DMARK "CEl" 
01c7					CALLMONITOR 
01c7					pop hl 
01c7				endif 
01c7 c1				pop bc 
01c8 c9				ret 
01c9			 
01c9			 
01c9			 
01c9			; eof 
01c9			 
01c9			 
01c9			 
01c9			 
01c9			 
# End of file firmware_spi.asm
01c9				include "firmware_seeprom.asm"  
01c9			; 
01c9			; persisent storage interface via microchip serial eeprom 
01c9			 
01c9			; port a pio 2 
01c9			; pa 7 - si 
01c9			; pa 6 - sclk  
01c9			; pa 5 - so 
01c9			; pa 4 - cs 
01c9			; pa 3 - cs 
01c9			; pa 2 - cs 
01c9			; pa 1 - cs 
01c9			; pa 0 - cs 
01c9			; 
01c9			; TODO get block 
01c9			; TODO save block 
01c9			; TODO load file 
01c9			; TODO save file 
01c9			; TODO get dir  
01c9			 
01c9			;  
01c9			storage_adata: equ Device_C    ; device c port a - onboard storage 
01c9			storage_actl: equ Device_C+2     ; device c port a 
01c9			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
01c9			storage_bctl: equ Device_C+3     ; device c port b 
01c9			 
01c9			 
01c9			; TODO move these to hardware driver file 
01c9			 
01c9			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
01c9			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
01c9			; storage bank file system format 
01c9			; 
01c9			; first page of bank: 
01c9			; 	addr 0 - status check 
01c9			;       addr 1 - write protect flag 
01c9			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
01c9			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
01c9			;         TODO see if scanning whole of for available next file id is fast enough 
01c9			;	addr 4 > zero term string of bank label 
01c9			; 
01c9			;        
01c9			;  
01c9			; first page of any file: 
01c9			;      byte 0 - file id  
01c9			;      byte 1-17 - fixed file name  
01c9			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
01c9			; 
01c9			; other pages of any file: 
01c9			;      byte 0 - file id 
01c9			;      byte 1> - file data 
01c9			; 
01c9			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
01c9			;  
01c9			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
01c9			 
01c9			 
01c9			;storage_so_bit: 5 
01c9			;storage_si_bit: 7 
01c9			;storage_sclk_bit: 6 
01c9			  
01c9			 
01c9			; init storage pio 
01c9			 
01c9			storage_init: 
01c9			 
01c9 3e cf		            LD   A, 11001111b 
01cb d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
01cd 3e 00		            LD   A, 00000000b 
01cf cb f7			set SPI_DO,a 
01d1			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
01d1 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
01d3			 
01d3 3e cf		            LD   A, 11001111b 
01d5 d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
01d7 3e 00		            LD   A, 00000000b 
01d9 d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
01db			 
01db				; set all external spi devices off 
01db 3e 00			ld a, 0 
01dd 32 ce f9			ld (spi_device), a 
01e0 32 d1 f9			ld (spi_cartdev), a 
01e3			 
01e3					; ensure the spi bus is in a default stable state 
01e3 cd ae 00				call se_stable_spi 
01e6			 
01e6			; TODO scan spi bus and gather which storage banks are present 
01e6			 
01e6			; populate store_bank_active  
01e6			; for each ce line activate and attempt to write first byte of bank and read back 
01e6			; if zero is returned then bank is empty 
01e6			;   
01e6			; 
01e6			 
01e6					; init file extent cache to save on slow reads 
01e6			 
01e6			;	ld hl, store_filecache 
01e6			;	ld de, 0 
01e6			;	ld hl,(de)	 
01e6			 
01e6			 
01e6 c9			    ret 
01e7			 
01e7			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
01e7			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
01e7			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
01e7			 
01e7			; INSTRUCTION SET 
01e7			; READ 0000 0011 Read data from memory array beginning at selected address 
01e7			; WRITE 0000 0010 Write data to memory array beginning at selected address 
01e7			; WREN 0000 0110 Set the write enable latch (enable write operations) 
01e7			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
01e7			; RDSR 0000 0101 Read STATUS register 
01e7			; WRSR 0000 0001 Write STATUS register 
01e7			; PE 0100 0010 Page Erase – erase one page in memory array 
01e7			; SE 1101 1000 Sector Erase – erase one sector in memory array 
01e7			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
01e7			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
01e7			 
01e7			; TODO send byte steam for page without setting the address for every single byte 
01e7			; TODO read byte  
01e7			 
01e7			; byte in a 
01e7			; address in hl  
01e7			se_writebyte: 
01e7			        
01e7			    ;   ld c, a 
01e7 f5			        push af 
01e8 e5			        push hl 
01e9			 
01e9			    ; initi write mode 
01e9			    ; 
01e9			    ;CS low 
01e9			 
01e9 3a cf f9		       ld a,(spi_portbyte) 
01ec cd 95 01			call spi_ce_low 
01ef			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01ef d3 80		       out (storage_adata),a 
01f1 32 cf f9		       ld (spi_portbyte), a 
01f4			 
01f4			    ;clock out wren instruction 
01f4			 
01f4 3e 06		    ld a, store_wren_ins 
01f6 cd b9 00		    call spi_send_byte  
01f9			 
01f9			    ;cs high to enable write latch 
01f9			 
01f9 3a cf f9		       ld a,(spi_portbyte) 
01fc cd 84 01			call spi_ce_high 
01ff			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
01ff d3 80		       out (storage_adata),a 
0201 32 cf f9		       ld (spi_portbyte), a 
0204			 
0204 00				nop 
0205			    ; 
0205			    ; intial write data 
0205			    ; 
0205			    ; cs low 
0205			     
0205 3a cf f9		       ld a,(spi_portbyte) 
0208 cd 95 01			call spi_ce_low 
020b			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
020b d3 80		       out (storage_adata),a 
020d 32 cf f9		       ld (spi_portbyte), a 
0210			 
0210			    ; clock out write instruction 
0210			     
0210 3e 02		    ld a, store_write_ins  
0212 cd b9 00		    call spi_send_byte  
0215			 
0215			    ; clock out address (depending on address size) 
0215			     
0215 e1			    pop hl 
0216 7c			    ld a,h    ; address out msb first 
0217 cd b9 00		    call spi_send_byte  
021a 7d			    ld a,l 
021b cd b9 00		    call spi_send_byte  
021e			 
021e			    ; clock out byte(s) for page 
021e			 
021e f1			    pop af 
021f cd b9 00		    call spi_send_byte  
0222			 
0222			    ; end write with ce high 
0222 3a cf f9		       ld a,(spi_portbyte) 
0225			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
0225 cd 84 01			call spi_ce_high 
0228 d3 80		       out (storage_adata),a 
022a 32 cf f9		       ld (spi_portbyte), a 
022d			 
022d				; pause for internal write cycle 
022d 3e 0a			ld a, 10 
022f cd 37 0a			call aDelayInMS 
0232 c9			    ret 
0233			 
0233			; buffer to write in de 
0233			; address in hl  
0233			se_writepage: 
0233			        
0233			    ;   ld c, a 
0233 d5				push de 
0234 e5			        push hl 
0235			 
0235			    ; initi write mode 
0235			    ; 
0235			    ;CS low 
0235			 
0235 3a cf f9		       ld a,(spi_portbyte) 
0238 cd 95 01			call spi_ce_low 
023b			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
023b d3 80		       out (storage_adata),a 
023d 32 cf f9		       ld (spi_portbyte), a 
0240			 
0240			    ;clock out wren instruction 
0240			 
0240 3e 06		    ld a, store_wren_ins 
0242 cd b9 00		    call spi_send_byte  
0245			 
0245			    ;cs high to enable write latch 
0245			 
0245 3a cf f9		       ld a,(spi_portbyte) 
0248 cd 84 01			call spi_ce_high 
024b			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
024b d3 80		       out (storage_adata),a 
024d 32 cf f9		       ld (spi_portbyte), a 
0250			 
0250 00				nop 
0251			    ; 
0251			    ; intial write data 
0251			    ; 
0251			    ; cs low 
0251			     
0251 3a cf f9		       ld a,(spi_portbyte) 
0254			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0254 cd 95 01			call spi_ce_low 
0257 d3 80		       out (storage_adata),a 
0259 32 cf f9		       ld (spi_portbyte), a 
025c			 
025c			    ; clock out write instruction 
025c			     
025c 3e 02		    ld a, store_write_ins  
025e cd b9 00		    call spi_send_byte  
0261			 
0261			    ; clock out address (depending on address size) 
0261			     
0261 e1			    pop hl 
0262 7c			    ld a,h    ; address out msb first 
0263 cd b9 00		    call spi_send_byte  
0266 7d			    ld a,l 
0267 cd b9 00		    call spi_send_byte  
026a			 
026a			    ; clock out byte(s) for page 
026a			 
026a e1				pop hl 
026b 06 40			ld b, STORE_BLOCK_PHY 
026d			.bytewrite: 
026d			 
026d 7e				ld a,(hl) 
026e e5			    push hl 
026f c5				push bc 
0270 cd b9 00		    call spi_send_byte  
0273 c1				pop bc 
0274 e1				pop hl 
0275			 
0275			    ; end write with ce high 
0275 3a cf f9		       ld a,(spi_portbyte) 
0278 cd 84 01			call spi_ce_high 
027b			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
027b d3 80		       out (storage_adata),a 
027d 32 cf f9		       ld (spi_portbyte), a 
0280			 
0280 23				inc hl 
0281 10 ea			djnz .bytewrite 
0283			 
0283				; pause for internal write cycle 
0283 3e 64			ld a, 100 
0285 cd 37 0a			call aDelayInMS 
0288 c9			    ret 
0289			; returns byte in a 
0289			; address in hl  
0289			se_readbyte: 
0289 d5				push de 
028a c5				push bc 
028b			 
028b			    ;   ld c, a 
028b e5			        push hl 
028c			 
028c			    ; initi write mode 
028c			    ; 
028c			    ;CS low 
028c			 
028c 3a cf f9		       ld a,(spi_portbyte) 
028f cd 95 01			call spi_ce_low 
0292			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0292 d3 80		       out (storage_adata),a 
0294 32 cf f9		       ld (spi_portbyte), a 
0297			 
0297			    ;clock out wren instruction 
0297			 
0297 3e 03		    ld a, store_read_ins 
0299 cd b9 00		    call spi_send_byte  
029c			 
029c			 
029c			    ; clock out address (depending on address size) 
029c			     
029c e1			    pop hl 
029d 7c			    ld a,h    ; address out msb first 
029e cd b9 00		    call spi_send_byte  
02a1 7d			    ld a,l 
02a2 cd b9 00		    call spi_send_byte  
02a5			 
02a5			    ; clock in byte(s) for page 
02a5			 
02a5 cd da 00		    call spi_read_byte  
02a8 f5				push af 
02a9			 
02a9			    ; end write with ce high 
02a9 3a cf f9		       ld a,(spi_portbyte) 
02ac			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02ac cd 84 01			call spi_ce_high 
02af d3 80		       out (storage_adata),a 
02b1 32 cf f9		       ld (spi_portbyte), a 
02b4			 
02b4 f1				pop af 
02b5			 
02b5 c1				pop bc 
02b6 d1				pop de 
02b7			 
02b7 c9			    ret 
02b8			 
02b8			if DEBUG_STORESE 
02b8			 
02b8			storageput:  
02b8			 
02b8			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
02b8			 
02b8 21 a5 ef			ld hl,scratch+2 
02bb cd bd 10			call get_word_hl 
02be			 
02be				; stuff it here for the moment as it will be overwritten later anyway 
02be			 
02be 22 c6 f2			ld (os_cur_ptr),hl	 
02c1			 
02c1			 
02c1			; get pointer to start of string 
02c1			 
02c1 21 aa ef			ld hl, scratch+7 
02c4			 
02c4			; loop writing char of string to eeprom 
02c4			 
02c4 7e			.writestr:	ld a,(hl) 
02c5 fe 00				cp 0 
02c7 28 12				jr z, .wsdone		; done writing 
02c9 e5					push hl 
02ca 2a c6 f2				ld hl,(os_cur_ptr) 
02cd cd e7 01				call se_writebyte 
02d0			 
02d0 2a c6 f2				ld hl,(os_cur_ptr)	 ; save next eeprom address 
02d3 23					inc hl 
02d4 22 c6 f2				ld (os_cur_ptr),hl 
02d7			 
02d7					; restore string pointer and get next char 
02d7			 
02d7 e1					pop hl 
02d8 23					inc hl 
02d9 18 e9				jr .writestr 
02db			 
02db			 
02db			 
02db			.wsdone: 
02db			 
02db			 
02db			; when done load first page into a buffer  
02db			 
02db 21 00 80				ld hl,08000h		; start in ram 
02de 22 c6 f2				ld (os_cur_ptr),hl 
02e1 21 00 00				ld hl, 0		 ; start of page 
02e4 22 cb ef				ld (scratch+40),hl	; hang on to it 
02e7			 
02e7 06 80				ld b, 128		; actually get more then one page 
02e9 c5			.wsload:	push bc 
02ea 2a cb ef				ld hl,(scratch+40) 
02ed e5					push hl 
02ee cd 89 02				call se_readbyte 
02f1			 
02f1					; a now as the byte 
02f1			 
02f1 2a c6 f2				ld hl,(os_cur_ptr) 
02f4 77					ld (hl),a 
02f5					; inc next buffer area 
02f5 23					inc hl 
02f6 22 c6 f2				ld (os_cur_ptr),hl 
02f9			 
02f9					; get eeprom position, inc and save for next round 
02f9 e1					pop hl		 
02fa 23					inc hl 
02fb 22 cb ef				ld (scratch+40),hl 
02fe c1					pop bc 
02ff 10 e8				djnz .wsload 
0301			 
0301			; set 'd' pointer to start of buffer 
0301			 
0301 21 00 80				ld hl,08000h 
0304 22 c6 f2				ld (os_cur_ptr),hl 
0307			 
0307			 
0307 c9			ret 
0308			 
0308			 
0308 c9			storageread: ret 
0309			 
0309			 
0309			 
0309			 
0309			 
0309			 
0309			endif 
0309			 
0309			 
0309			 
# End of file firmware_seeprom.asm
0309			else  
0309			   ; create some stubs for the labels  
0309			se_readbyte: ret  
0309			se_writebyte: ret  
0309			storage_init: ret  
0309			  
0309			endif  
0309			  
0309			; use cf card for storage - throwing timeout errors. Hardware or software?????  
0309			;include "firmware_cf.asm"  
0309			  
0309			; load up high level storage hardward abstractions  
0309			include "firmware_storage.asm"  
0309			 
0309			; persisent storage hardware abstraction layer  
0309			 
0309			 
0309			 
0309			; Block 0 on storage is a config state 
0309			 
0309			 
0309			 
0309			; TODO add read phy block and write phy block functions 
0309			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
0309			 
0309			; Abstraction layer  
0309			 
0309			; Logocial block size is same size as physical size - using tape concept 
0309			 
0309			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
0309			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
0309			 
0309			 
0309			 
0309			; Filesystem layout (Logical layout) 
0309			; 
0309			; Block 0 - Bank config  
0309			; 
0309			;      Byte - 0 file id counter 
0309			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0309			;      Byte - 3-20 zero terminated bank label 
0309			; 
0309			; Block 1 > File storage 
0309			; 
0309			;      Byte 0 file id    - block 0 file details 
0309			;      Byte 1 block id - block 0 is file  
0309			;            Byte 2-15 - File name 
0309			; 
0309			;       - to end of block data 
0309			; 
0309			 
0309			 
0309			; Read Block 
0309			; ---------- 
0309			; 
0309			; With current bank 
0309			;  
0309			; Get block number to read 
0309			; Load physical blocks starting at start block into buffer 
0309			 
0309			; de points to buffer to use 
0309			; hl holds logical block number  
0309			 
0309			storage_read_block: 
0309			 
0309				; TODO bank selection 
0309			 
0309				; for each of the physical blocks read it into the buffer 
0309 06 40			ld b, STORE_BLOCK_PHY 
030b			 
030b				if DEBUG_STORESE 
030b d5					push de 
030c				endif 
030c				 
030c			.rl1:    
030c			 
030c				; read physical block at hl into de 
030c			        ; increment hl and de to next read position on exit 
030c			 
030c e5				push hl 
030d d5				push de	 
030e c5				push bc 
030f			;	if DEBUG_STORESE 
030f			;		push af 
030f			;		ld a, 'R' 
030f			;		ld (debug_mark),a 
030f			;		pop af 
030f			;		CALLMONITOR 
030f			;	endif 
030f cd 89 02			call se_readbyte 
0312			;	if DEBUG_STORESE 
0312			;		ld a,(spi_portbyte) 
0312			;		ld l, a 
0312			;		push af 
0312			;		ld a, '1' 
0312			;		ld (debug_mark),a 
0312			;		pop af 
0312			;		CALLMONITOR 
0312			;	endif 
0312 c1				pop bc 
0313 d1				pop de 
0314 e1				pop hl 
0315 12				ld (de),a 
0316 23				inc hl 
0317 13				inc de 
0318			 
0318			;	if DEBUG_STORESE 
0318			;		push af 
0318			;		ld a, 'r' 
0318			;		ld (debug_mark),a 
0318			;		pop af 
0318			;		CALLMONITOR 
0318			;	endif 
0318			 
0318 10 f2			djnz .rl1 
031a			 
031a				if DEBUG_STORESE 
031a					DMARK "SRB" 
031a f5				push af  
031b 3a 2f 03			ld a, (.dmark)  
031e 32 bd fb			ld (debug_mark),a  
0321 3a 30 03			ld a, (.dmark+1)  
0324 32 be fb			ld (debug_mark+1),a  
0327 3a 31 03			ld a, (.dmark+2)  
032a 32 bf fb			ld (debug_mark+2),a  
032d 18 03			jr .pastdmark  
032f ..			.dmark: db "SRB"  
0332 f1			.pastdmark: pop af  
0333			endm  
# End of macro DMARK
0333 d1					pop de 
0334			; 
0334			;		push af 
0334			;		ld a, 'R' 
0334			;		ld (debug_mark),a 
0334			;		pop af 
0334					CALLMONITOR 
0334 cd ec 16			call break_point_state  
0337				endm  
# End of macro CALLMONITOR
0337				endif 
0337 c9				ret	 
0338				 
0338			 
0338			; File Size 
0338			; --------- 
0338			; 
0338			;   hl file id 
0338			; 
0338			;  returns in hl the number of blocks 
0338			 
0338			storage_file_size: 
0338 5d				ld e, l 
0339 16 00			ld d, 0 
033b 21 40 00			ld hl, STORE_BLOCK_PHY 
033e					if DEBUG_FORTH_WORDS 
033e						DMARK "SIZ" 
033e f5				push af  
033f 3a 53 03			ld a, (.dmark)  
0342 32 bd fb			ld (debug_mark),a  
0345 3a 54 03			ld a, (.dmark+1)  
0348 32 be fb			ld (debug_mark+1),a  
034b 3a 55 03			ld a, (.dmark+2)  
034e 32 bf fb			ld (debug_mark+2),a  
0351 18 03			jr .pastdmark  
0353 ..			.dmark: db "SIZ"  
0356 f1			.pastdmark: pop af  
0357			endm  
# End of macro DMARK
0357						CALLMONITOR 
0357 cd ec 16			call break_point_state  
035a				endm  
# End of macro CALLMONITOR
035a					endif 
035a cd 2a 06			call storage_findnextid 
035d			 
035d cd 2f 0d			call ishlzero 
0360			;	ld a, l 
0360			;	add h 
0360			;	cp 0 
0360 c8				ret z			; block not found so EOF 
0361			 
0361 11 e8 f9			ld de, store_page 
0364 cd 09 03			call storage_read_block 
0367			 
0367 3a ea f9			ld a, (store_page+2)	 ; get extent count 
036a 6f				ld l, a 
036b 26 00			ld h, 0 
036d c9			 	ret 
036e			 
036e			 
036e			; Write Block 
036e			; ----------- 
036e			; 
036e			; With current bank 
036e			;  
036e			; Get block number to write 
036e			; Write physical blocks starting at start block from buffer 
036e			  
036e			storage_write_block: 
036e				; TODO bank selection 
036e			 
036e				; for each of the physical blocks read it into the buffer 
036e 06 40			ld b, STORE_BLOCK_PHY 
0370			 
0370				if DEBUG_STORESE 
0370					DMARK "SWB" 
0370 f5				push af  
0371 3a 85 03			ld a, (.dmark)  
0374 32 bd fb			ld (debug_mark),a  
0377 3a 86 03			ld a, (.dmark+1)  
037a 32 be fb			ld (debug_mark+1),a  
037d 3a 87 03			ld a, (.dmark+2)  
0380 32 bf fb			ld (debug_mark+2),a  
0383 18 03			jr .pastdmark  
0385 ..			.dmark: db "SWB"  
0388 f1			.pastdmark: pop af  
0389			endm  
# End of macro DMARK
0389			 
0389					;push af 
0389					;ld a, 'W' 
0389					;ld (debug_mark),a 
0389					;pop af 
0389					CALLMONITOR 
0389 cd ec 16			call break_point_state  
038c				endm  
# End of macro CALLMONITOR
038c				endif 
038c			 
038c			; might not be working 
038c			;	call se_writepage 
038c			 
038c			;	ret 
038c			; 
038c			 
038c			 
038c			 
038c			.wl1:    
038c			 
038c				; read physical block at hl into de 
038c			        ; increment hl and de to next read position on exit 
038c			 
038c e5				push hl 
038d d5				push de	 
038e c5				push bc 
038f 1a				ld a,(de) 
0390				;if DEBUG_STORESE 
0390			;		push af 
0390			;		ld a, 'W' 
0390			;		ld (debug_mark),a 
0390			;		pop af 
0390			;		CALLMONITOR 
0390			;	endif 
0390 cd e7 01			call se_writebyte 
0393			;	call delay250ms 
0393 00				nop 
0394 00				nop 
0395 00				nop 
0396			;	if DEBUG_STORESE 
0396			;		push af 
0396			;		ld a, 'w' 
0396			;		ld (debug_mark),a 
0396			;		pop af 
0396			;		CALLMONITOR 
0396			;	endif 
0396 c1				pop bc 
0397 d1				pop de 
0398 e1				pop hl 
0399 23				inc hl 
039a 13				inc de 
039b			 
039b			 
039b 10 ef			djnz .wl1 
039d			 
039d				if DEBUG_STORESE 
039d					DMARK "SW2" 
039d f5				push af  
039e 3a b2 03			ld a, (.dmark)  
03a1 32 bd fb			ld (debug_mark),a  
03a4 3a b3 03			ld a, (.dmark+1)  
03a7 32 be fb			ld (debug_mark+1),a  
03aa 3a b4 03			ld a, (.dmark+2)  
03ad 32 bf fb			ld (debug_mark+2),a  
03b0 18 03			jr .pastdmark  
03b2 ..			.dmark: db "SW2"  
03b5 f1			.pastdmark: pop af  
03b6			endm  
# End of macro DMARK
03b6			 
03b6					;push af 
03b6					;ld a, 'W' 
03b6					;ld (debug_mark),a 
03b6					;pop af 
03b6					CALLMONITOR 
03b6 cd ec 16			call break_point_state  
03b9				endm  
# End of macro CALLMONITOR
03b9				endif 
03b9 c9				ret	 
03ba			 
03ba			; Init bank 
03ba			; --------- 
03ba			; 
03ba			; With current bank 
03ba			; 
03ba			; Setup block 0 config 
03ba			;     Set 0 file id counter 
03ba			;     Set formatted byte pattern 
03ba			;     Zero out bank label 
03ba			;      
03ba			; For every logical block write 0-1 byte as null 
03ba			 
03ba			storage_get_block_0: 
03ba			 
03ba				; TODO check presence 
03ba			 
03ba				; get block 0 config 
03ba			 
03ba 21 00 00			ld hl, 0 
03bd 11 e8 f9			ld de, store_page 
03c0 cd 09 03			call storage_read_block 
03c3			 
03c3				if DEBUG_STORESE 
03c3					DMARK "SB0" 
03c3 f5				push af  
03c4 3a d8 03			ld a, (.dmark)  
03c7 32 bd fb			ld (debug_mark),a  
03ca 3a d9 03			ld a, (.dmark+1)  
03cd 32 be fb			ld (debug_mark+1),a  
03d0 3a da 03			ld a, (.dmark+2)  
03d3 32 bf fb			ld (debug_mark+2),a  
03d6 18 03			jr .pastdmark  
03d8 ..			.dmark: db "SB0"  
03db f1			.pastdmark: pop af  
03dc			endm  
# End of macro DMARK
03dc 11 e8 f9				ld de, store_page 
03df			;		push af 
03df			;		ld a, 'i' 
03df			;		ld (debug_mark),a 
03df			;		pop af 
03df					CALLMONITOR 
03df cd ec 16			call break_point_state  
03e2				endm  
# End of macro CALLMONITOR
03e2				endif 
03e2			 
03e2				; is this area formatted? 
03e2			 
03e2			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03e2 2a e9 f9			ld hl, (store_page+1) 
03e5 3e 80			ld a,0x80 
03e7 bd				cp l 
03e8 20 22			jr nz, .ininotformatted 
03ea				; do a double check 
03ea 3e 27			ld a, 0x27 
03ec bc				cp h 
03ed 20 1d			jr nz, .ininotformatted 
03ef			 
03ef				; formatted then 
03ef			 
03ef				if DEBUG_STORESE 
03ef					DMARK "SB1" 
03ef f5				push af  
03f0 3a 04 04			ld a, (.dmark)  
03f3 32 bd fb			ld (debug_mark),a  
03f6 3a 05 04			ld a, (.dmark+1)  
03f9 32 be fb			ld (debug_mark+1),a  
03fc 3a 06 04			ld a, (.dmark+2)  
03ff 32 bf fb			ld (debug_mark+2),a  
0402 18 03			jr .pastdmark  
0404 ..			.dmark: db "SB1"  
0407 f1			.pastdmark: pop af  
0408			endm  
# End of macro DMARK
0408					;push af 
0408					;ld a, 'I' 
0408					;ld (debug_mark),a 
0408					;pop af 
0408					CALLMONITOR 
0408 cd ec 16			call break_point_state  
040b				endm  
# End of macro CALLMONITOR
040b				endif 
040b c9				ret 
040c			 
040c			.ininotformatted: 
040c				; bank not formatted so poke various bits to make sure 
040c			 
040c				if DEBUG_STORESE 
040c					DMARK "SB2" 
040c f5				push af  
040d 3a 21 04			ld a, (.dmark)  
0410 32 bd fb			ld (debug_mark),a  
0413 3a 22 04			ld a, (.dmark+1)  
0416 32 be fb			ld (debug_mark+1),a  
0419 3a 23 04			ld a, (.dmark+2)  
041c 32 bf fb			ld (debug_mark+2),a  
041f 18 03			jr .pastdmark  
0421 ..			.dmark: db "SB2"  
0424 f1			.pastdmark: pop af  
0425			endm  
# End of macro DMARK
0425					;push af 
0425					;ld a, 'f' 
0425					;ld (debug_mark),a 
0425					;pop af 
0425					CALLMONITOR 
0425 cd ec 16			call break_point_state  
0428				endm  
# End of macro CALLMONITOR
0428				endif 
0428			 
0428 cd 15 0a			call storage_clear_page 
042b			 
042b 21 e8 f9			ld hl, store_page 
042e 3e 00			ld a, 0 
0430				 
0430 77				ld (hl),a   ; reset file counter 
0431			 
0431 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0434 22 e9 f9		 	ld (store_page+1), hl	 
0437			 
0437				; set default label 
0437			 
0437 21 d3 04			ld hl, .defaultbanklabl 
043a 11 eb f9		 	ld de, store_page+3 
043d 01 0f 00			ld bc, 15 
0440 ed b0			ldir 
0442			 
0442				; Append the current bank id 
0442 21 f4 f9			ld hl, store_page+3+9 
0445 3a cd f9			ld a, (spi_device_id) 
0448 77				ld (hl), a 
0449			 
0449				; save default page 0 
0449			 
0449 21 00 00			ld hl, 0 
044c 11 e8 f9			ld de, store_page 
044f				if DEBUG_STORESE 
044f					DMARK "SB3" 
044f f5				push af  
0450 3a 64 04			ld a, (.dmark)  
0453 32 bd fb			ld (debug_mark),a  
0456 3a 65 04			ld a, (.dmark+1)  
0459 32 be fb			ld (debug_mark+1),a  
045c 3a 66 04			ld a, (.dmark+2)  
045f 32 bf fb			ld (debug_mark+2),a  
0462 18 03			jr .pastdmark  
0464 ..			.dmark: db "SB3"  
0467 f1			.pastdmark: pop af  
0468			endm  
# End of macro DMARK
0468			;		push af 
0468			;		ld a, 'F' 
0468			;		ld (debug_mark),a 
0468			;		pop af 
0468					CALLMONITOR 
0468 cd ec 16			call break_point_state  
046b				endm  
# End of macro CALLMONITOR
046b				endif 
046b cd 6e 03			call storage_write_block 
046e				if DEBUG_STORESE 
046e					DMARK "SB4" 
046e f5				push af  
046f 3a 83 04			ld a, (.dmark)  
0472 32 bd fb			ld (debug_mark),a  
0475 3a 84 04			ld a, (.dmark+1)  
0478 32 be fb			ld (debug_mark+1),a  
047b 3a 85 04			ld a, (.dmark+2)  
047e 32 bf fb			ld (debug_mark+2),a  
0481 18 03			jr .pastdmark  
0483 ..			.dmark: db "SB4"  
0486 f1			.pastdmark: pop af  
0487			endm  
# End of macro DMARK
0487			;		push af 
0487			;		ld a, '>' 
0487			;		ld (debug_mark),a 
0487			;		pop af 
0487					CALLMONITOR 
0487 cd ec 16			call break_point_state  
048a				endm  
# End of macro CALLMONITOR
048a				endif 
048a			 
048a 00				nop 
048b 00				nop 
048c 00				nop 
048d			 
048d				; now set 0 in every page to mark as a free block 
048d			 
048d 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
048f 21 40 00			ld hl, STORE_BLOCK_PHY 
0492			 
0492 3e 00		.setmark1:   	ld a,0 
0494 e5					push hl 
0495 c5					push bc 
0496 cd e7 01				call se_writebyte 
0499 3e 0a			ld a, 10 
049b cd 37 0a			call aDelayInMS 
049e 23				inc hl 
049f cd e7 01				call se_writebyte 
04a2 3e 0a			ld a, 10 
04a4 cd 37 0a			call aDelayInMS 
04a7 2b				dec hl 
04a8 c1					pop bc 
04a9 e1					pop hl 
04aa 3e 40				ld a, STORE_BLOCK_PHY 
04ac cd 06 0d				call addatohl 
04af 10 e1				djnz .setmark1 
04b1			 
04b1 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
04b3 3e 00		.setmark2:   	ld a,0 
04b5 e5					push hl 
04b6 c5					push bc 
04b7 cd e7 01				call se_writebyte 
04ba 3e 0a			ld a, 10 
04bc cd 37 0a			call aDelayInMS 
04bf 23				inc hl 
04c0 cd e7 01				call se_writebyte 
04c3 3e 0a			ld a, 10 
04c5 cd 37 0a			call aDelayInMS 
04c8 2b				dec hl 
04c9 c1					pop bc 
04ca e1					pop hl 
04cb 3e 40				ld a, STORE_BLOCK_PHY 
04cd cd 06 0d				call addatohl 
04d0 10 e1				djnz .setmark2 
04d2			 
04d2					 
04d2			 
04d2			 
04d2 c9				ret 
04d3			 
04d3			 
04d3			 
04d3			 
04d3 .. 00		.defaultbanklabl:   db "BankLabel_",0 
04de			 
04de			 
04de			 
04de			; Label Bank 
04de			; ---------- 
04de			; 
04de			; With current bank 
04de			; Read block 0 
04de			; Set label 
04de			; Write block 0 
04de			 
04de			; label str pointer in hl 
04de			 
04de			storage_label:     
04de			 
04de				if DEBUG_STORESE 
04de					DMARK "LBL" 
04de f5				push af  
04df 3a f3 04			ld a, (.dmark)  
04e2 32 bd fb			ld (debug_mark),a  
04e5 3a f4 04			ld a, (.dmark+1)  
04e8 32 be fb			ld (debug_mark+1),a  
04eb 3a f5 04			ld a, (.dmark+2)  
04ee 32 bf fb			ld (debug_mark+2),a  
04f1 18 03			jr .pastdmark  
04f3 ..			.dmark: db "LBL"  
04f6 f1			.pastdmark: pop af  
04f7			endm  
# End of macro DMARK
04f7					CALLMONITOR 
04f7 cd ec 16			call break_point_state  
04fa				endm  
# End of macro CALLMONITOR
04fa				endif 
04fa			 
04fa e5				push hl 
04fb			 
04fb cd ba 03			call storage_get_block_0 
04fe			 
04fe				; set default label 
04fe			 
04fe e1				pop hl 
04ff			 
04ff 11 eb f9		 	ld de, store_page+3 
0502 01 0f 00			ld bc, 15 
0505				if DEBUG_STORESE 
0505					DMARK "LB3" 
0505 f5				push af  
0506 3a 1a 05			ld a, (.dmark)  
0509 32 bd fb			ld (debug_mark),a  
050c 3a 1b 05			ld a, (.dmark+1)  
050f 32 be fb			ld (debug_mark+1),a  
0512 3a 1c 05			ld a, (.dmark+2)  
0515 32 bf fb			ld (debug_mark+2),a  
0518 18 03			jr .pastdmark  
051a ..			.dmark: db "LB3"  
051d f1			.pastdmark: pop af  
051e			endm  
# End of macro DMARK
051e					CALLMONITOR 
051e cd ec 16			call break_point_state  
0521				endm  
# End of macro CALLMONITOR
0521				endif 
0521 ed b0			ldir 
0523				; save default page 0 
0523			 
0523 21 00 00			ld hl, 0 
0526 11 e8 f9			ld de, store_page 
0529				if DEBUG_STORESE 
0529					DMARK "LBW" 
0529 f5				push af  
052a 3a 3e 05			ld a, (.dmark)  
052d 32 bd fb			ld (debug_mark),a  
0530 3a 3f 05			ld a, (.dmark+1)  
0533 32 be fb			ld (debug_mark+1),a  
0536 3a 40 05			ld a, (.dmark+2)  
0539 32 bf fb			ld (debug_mark+2),a  
053c 18 03			jr .pastdmark  
053e ..			.dmark: db "LBW"  
0541 f1			.pastdmark: pop af  
0542			endm  
# End of macro DMARK
0542					CALLMONITOR 
0542 cd ec 16			call break_point_state  
0545				endm  
# End of macro CALLMONITOR
0545				endif 
0545 cd 6e 03			call storage_write_block 
0548			 
0548 c9				ret 
0549			 
0549			 
0549			 
0549			; Read Block 0 - Config 
0549			; --------------------- 
0549			; 
0549			; With current bank 
0549			; Call presence test 
0549			;    If not present format/init bank  
0549			; Read block 0  
0549			;  
0549			 
0549			 
0549			; Dir 
0549			; --- 
0549			; 
0549			; With current bank 
0549			; Load Block 0 Config 
0549			; Get max file id number 
0549			; For each logical block 
0549			;    Read block read byte 2 
0549			;      if first block of file 
0549			;         Display file name 
0549			;         Display type flags for file 
0549			;        
0549			 
0549			; moving to words as this requires stack control 
0549			 
0549			 
0549			; Delete File 
0549			; ----------- 
0549			; 
0549			; With current bank 
0549			; 
0549			; Load Block 0 Config 
0549			; Get max file id number 
0549			; For each logical block 
0549			;    Read block file id 
0549			;      If first block of file and dont have file id 
0549			;         if file to delete 
0549			;         Save file id 
0549			;         Null file id 
0549			;         Write this block back 
0549			;      If file id is one saved 
0549			;         Null file id 
0549			;         Write this block back 
0549			 
0549			storage_erase: 
0549			 
0549				; hl contains the file id 
0549			 
0549 5d				ld e, l 
054a 16 00			ld d, 0 
054c 21 40 00			ld hl, STORE_BLOCK_PHY 
054f					if DEBUG_FORTH_WORDS 
054f						DMARK "ERA" 
054f f5				push af  
0550 3a 64 05			ld a, (.dmark)  
0553 32 bd fb			ld (debug_mark),a  
0556 3a 65 05			ld a, (.dmark+1)  
0559 32 be fb			ld (debug_mark+1),a  
055c 3a 66 05			ld a, (.dmark+2)  
055f 32 bf fb			ld (debug_mark+2),a  
0562 18 03			jr .pastdmark  
0564 ..			.dmark: db "ERA"  
0567 f1			.pastdmark: pop af  
0568			endm  
# End of macro DMARK
0568						CALLMONITOR 
0568 cd ec 16			call break_point_state  
056b				endm  
# End of macro CALLMONITOR
056b					endif 
056b cd 2a 06			call storage_findnextid 
056e			 
056e e5				push hl 
056f			 
056f				; TODO check file not found 
056f			 
056f 11 e8 f9			ld de, store_page 
0572 cd 09 03			call storage_read_block 
0575			 
0575					if DEBUG_FORTH_WORDS 
0575						DMARK "ER1" 
0575 f5				push af  
0576 3a 8a 05			ld a, (.dmark)  
0579 32 bd fb			ld (debug_mark),a  
057c 3a 8b 05			ld a, (.dmark+1)  
057f 32 be fb			ld (debug_mark+1),a  
0582 3a 8c 05			ld a, (.dmark+2)  
0585 32 bf fb			ld (debug_mark+2),a  
0588 18 03			jr .pastdmark  
058a ..			.dmark: db "ER1"  
058d f1			.pastdmark: pop af  
058e			endm  
# End of macro DMARK
058e						CALLMONITOR 
058e cd ec 16			call break_point_state  
0591				endm  
# End of macro CALLMONITOR
0591					endif 
0591 3a e8 f9			ld a, (store_page)	; get file id 
0594 32 e1 f9			ld (store_tmpid), a 
0597			 
0597 3a ea f9			ld a, (store_page+2)    ; get count of extends 
059a 32 e0 f9			ld (store_tmpext), a 
059d			 
059d				; wipe file header 
059d			 
059d e1				pop hl 
059e 3e 00			ld a, 0 
05a0 32 e8 f9			ld (store_page), a 
05a3 32 e9 f9			ld (store_page+1),a 
05a6 11 e8 f9			ld de, store_page 
05a9					if DEBUG_FORTH_WORDS 
05a9						DMARK "ER2" 
05a9 f5				push af  
05aa 3a be 05			ld a, (.dmark)  
05ad 32 bd fb			ld (debug_mark),a  
05b0 3a bf 05			ld a, (.dmark+1)  
05b3 32 be fb			ld (debug_mark+1),a  
05b6 3a c0 05			ld a, (.dmark+2)  
05b9 32 bf fb			ld (debug_mark+2),a  
05bc 18 03			jr .pastdmark  
05be ..			.dmark: db "ER2"  
05c1 f1			.pastdmark: pop af  
05c2			endm  
# End of macro DMARK
05c2						CALLMONITOR 
05c2 cd ec 16			call break_point_state  
05c5				endm  
# End of macro CALLMONITOR
05c5					endif 
05c5 cd 6e 03			call storage_write_block 
05c8			 
05c8			 
05c8				; wipe file extents 
05c8			 
05c8 3a e0 f9			ld a, (store_tmpext) 
05cb 47				ld b, a 
05cc			 
05cc			.eraext:	  
05cc c5				push bc 
05cd			 
05cd 21 40 00			ld hl, STORE_BLOCK_PHY 
05d0 3a e1 f9			ld a,(store_tmpid) 
05d3 5f				ld e, a 
05d4 50				ld d, b	 
05d5					if DEBUG_FORTH_WORDS 
05d5						DMARK "ER3" 
05d5 f5				push af  
05d6 3a ea 05			ld a, (.dmark)  
05d9 32 bd fb			ld (debug_mark),a  
05dc 3a eb 05			ld a, (.dmark+1)  
05df 32 be fb			ld (debug_mark+1),a  
05e2 3a ec 05			ld a, (.dmark+2)  
05e5 32 bf fb			ld (debug_mark+2),a  
05e8 18 03			jr .pastdmark  
05ea ..			.dmark: db "ER3"  
05ed f1			.pastdmark: pop af  
05ee			endm  
# End of macro DMARK
05ee						CALLMONITOR 
05ee cd ec 16			call break_point_state  
05f1				endm  
# End of macro CALLMONITOR
05f1					endif 
05f1 cd 2a 06			call storage_findnextid 
05f4			 
05f4 e5				push hl 
05f5 11 e8 f9			ld de, store_page 
05f8 cd 09 03			call storage_read_block 
05fb			 
05fb				; free block	 
05fb			 
05fb 3e 00			ld a, 0 
05fd 32 e8 f9			ld (store_page), a 
0600 32 e9 f9			ld (store_page+1),a 
0603 11 e8 f9			ld de, store_page 
0606 e1				pop hl 
0607					if DEBUG_FORTH_WORDS 
0607						DMARK "ER4" 
0607 f5				push af  
0608 3a 1c 06			ld a, (.dmark)  
060b 32 bd fb			ld (debug_mark),a  
060e 3a 1d 06			ld a, (.dmark+1)  
0611 32 be fb			ld (debug_mark+1),a  
0614 3a 1e 06			ld a, (.dmark+2)  
0617 32 bf fb			ld (debug_mark+2),a  
061a 18 03			jr .pastdmark  
061c ..			.dmark: db "ER4"  
061f f1			.pastdmark: pop af  
0620			endm  
# End of macro DMARK
0620						CALLMONITOR 
0620 cd ec 16			call break_point_state  
0623				endm  
# End of macro CALLMONITOR
0623					endif 
0623 cd 6e 03			call storage_write_block 
0626			 
0626 c1				pop bc 
0627 10 a3			djnz .eraext 
0629			 
0629 c9				ret 
062a			 
062a			 
062a			; Find Free Block 
062a			; --------------- 
062a			; 
062a			; With current bank 
062a			;  
062a			; From given starting logical block 
062a			;    Read block  
062a			;    If no file id 
062a			;         Return block id 
062a			 
062a			 
062a			; hl starting page number 
062a			; hl contains free page number or zero if no pages free 
062a			; e contains the file id to locate 
062a			; d contains the block number 
062a			 
062a			; TODO change to find file id and use zero for free block 
062a			 
062a			storage_findnextid: 
062a			 
062a				; now locate first 0 page to mark as a free block 
062a			 
062a 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
062c			;	ld hl, STORE_BLOCK_PHY 
062c			 
062c					if DEBUG_FORTH_WORDS 
062c					DMARK "FNI" 
062c f5				push af  
062d 3a 41 06			ld a, (.dmark)  
0630 32 bd fb			ld (debug_mark),a  
0633 3a 42 06			ld a, (.dmark+1)  
0636 32 be fb			ld (debug_mark+1),a  
0639 3a 43 06			ld a, (.dmark+2)  
063c 32 bf fb			ld (debug_mark+2),a  
063f 18 03			jr .pastdmark  
0641 ..			.dmark: db "FNI"  
0644 f1			.pastdmark: pop af  
0645			endm  
# End of macro DMARK
0645						CALLMONITOR 
0645 cd ec 16			call break_point_state  
0648				endm  
# End of macro CALLMONITOR
0648					endif 
0648			.ff1:   	 
0648 e5					push hl 
0649 c5					push bc 
064a d5					push de 
064b cd 89 02				call se_readbyte 
064e 5f					ld e,a 
064f 23					inc hl 
0650 cd 89 02				call se_readbyte 
0653 57					ld d, a 
0654 e1					pop hl 
0655 e5					push hl 
0656 cd 24 0d				call cmp16 
0659 28 49				jr z, .fffound 
065b			 
065b d1					pop de 
065c c1					pop bc 
065d e1					pop hl 
065e			 
065e					; is found? 
065e					;cp e 
065e					;ret z 
065e			 
065e 3e 40				ld a, STORE_BLOCK_PHY 
0660 cd 06 0d				call addatohl 
0663 10 e3				djnz .ff1 
0665			 
0665 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0667			.ff2:   	 
0667			 
0667 e5					push hl 
0668 c5					push bc 
0669 d5					push de 
066a cd 89 02				call se_readbyte 
066d 5f					ld e,a 
066e 23					inc hl 
066f cd 89 02				call se_readbyte 
0672 57					ld d, a 
0673			 
0673 e1					pop hl 
0674 e5					push hl 
0675 cd 24 0d				call cmp16 
0678 28 2a				jr z, .fffound 
067a			 
067a d1					pop de 
067b c1					pop bc 
067c e1					pop hl 
067d					; is found? 
067d					;cp e 
067d					;ret z 
067d			 
067d 3e 40				ld a, STORE_BLOCK_PHY 
067f cd 06 0d				call addatohl 
0682 10 e3				djnz .ff2 
0684			 
0684			 
0684					if DEBUG_FORTH_WORDS 
0684					DMARK "FN-" 
0684 f5				push af  
0685 3a 99 06			ld a, (.dmark)  
0688 32 bd fb			ld (debug_mark),a  
068b 3a 9a 06			ld a, (.dmark+1)  
068e 32 be fb			ld (debug_mark+1),a  
0691 3a 9b 06			ld a, (.dmark+2)  
0694 32 bf fb			ld (debug_mark+2),a  
0697 18 03			jr .pastdmark  
0699 ..			.dmark: db "FN-"  
069c f1			.pastdmark: pop af  
069d			endm  
# End of macro DMARK
069d					;	push af 
069d					;	ld a, 'n' 
069d					;	ld (debug_mark),a 
069d					;	pop af 
069d						CALLMONITOR 
069d cd ec 16			call break_point_state  
06a0				endm  
# End of macro CALLMONITOR
06a0					endif 
06a0				; no free marks! 
06a0 21 00 00				ld hl, 0 
06a3 c9				ret 
06a4			.fffound: 
06a4				 
06a4			 
06a4 d1					pop de 
06a5 c1					pop bc 
06a6 e1					pop hl 
06a7					if DEBUG_FORTH_WORDS 
06a7					DMARK "FNF" 
06a7 f5				push af  
06a8 3a bc 06			ld a, (.dmark)  
06ab 32 bd fb			ld (debug_mark),a  
06ae 3a bd 06			ld a, (.dmark+1)  
06b1 32 be fb			ld (debug_mark+1),a  
06b4 3a be 06			ld a, (.dmark+2)  
06b7 32 bf fb			ld (debug_mark+2),a  
06ba 18 03			jr .pastdmark  
06bc ..			.dmark: db "FNF"  
06bf f1			.pastdmark: pop af  
06c0			endm  
# End of macro DMARK
06c0					;	push af 
06c0					;	ld a, 'n' 
06c0					;	ld (debug_mark),a 
06c0					;	pop af 
06c0						CALLMONITOR 
06c0 cd ec 16			call break_point_state  
06c3				endm  
# End of macro CALLMONITOR
06c3					endif 
06c3 c9				ret 
06c4			 
06c4			 
06c4			 
06c4			; Free Space 
06c4			; ---------- 
06c4			; 
06c4			; With current bank 
06c4			; 
06c4			; Set block count to zero 
06c4			; Starting with first logical block 
06c4			;      Find free block  
06c4			;      If block id given, increment block count 
06c4			; 
06c4			;  
06c4			 
06c4			 
06c4			; hl contains count of free blocks 
06c4			 
06c4			storage_freeblocks: 
06c4			 
06c4				; now locate first 0 page to mark as a free block 
06c4			 
06c4 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
06c6 21 40 00			ld hl, STORE_BLOCK_PHY 
06c9 11 00 00			ld de, 0 
06cc			 
06cc			.fb1:   	 
06cc e5					push hl 
06cd c5					push bc 
06ce d5					push de 
06cf cd 89 02				call se_readbyte 
06d2 d1					pop de 
06d3 c1					pop bc 
06d4 e1					pop hl 
06d5			 
06d5					; is free? 
06d5 fe 00				cp 0 
06d7 20 01				jr nz, .ff1cont 
06d9 13					inc de 
06da			 
06da			.ff1cont: 
06da			 
06da			 
06da 3e 40				ld a, STORE_BLOCK_PHY 
06dc cd 06 0d				call addatohl 
06df 10 eb				djnz .fb1 
06e1			 
06e1 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
06e3			.fb2:   	 
06e3 e5					push hl 
06e4 c5					push bc 
06e5 d5					push de 
06e6 cd 89 02				call se_readbyte 
06e9 d1					pop de 
06ea c1					pop bc 
06eb e1					pop hl 
06ec			 
06ec					; is free? 
06ec fe 00				cp 0 
06ee 20 01				jr nz, .ff2cont 
06f0 13					inc de 
06f1			 
06f1			.ff2cont: 
06f1			 
06f1 3e 40				ld a, STORE_BLOCK_PHY 
06f3 cd 06 0d				call addatohl 
06f6 10 eb				djnz .fb2 
06f8			 
06f8 eb				ex de, hl 
06f9 c9				ret 
06fa			 
06fa			; Get File ID 
06fa			; ----------- 
06fa			; 
06fa			; With current bank 
06fa			;  
06fa			; Load Block 0 Config 
06fa			; Get max file id number 
06fa			; For each logical block 
06fa			;    Read block file id 
06fa			;      If first block of file and dont have file id 
06fa			;         if file get id and exit 
06fa			 
06fa			 
06fa			 
06fa			 
06fa			; Create File 
06fa			; ----------- 
06fa			; 
06fa			; With current bank  
06fa			; Load Block 0 Config 
06fa			; Get max file id number 
06fa			; Increment file id number 
06fa			; Save Config 
06fa			; Find free block 
06fa			; Set buffer with file name and file id 
06fa			; Write buffer to free block  
06fa			 
06fa			 
06fa			; hl point to file name 
06fa			; hl returns file id 
06fa			 
06fa			; file format: 
06fa			; byte 0 - file id 
06fa			; byte 1 - extent number 
06fa			; byte 2-> data 
06fa			 
06fa			; format for extent number 0: 
06fa			; 
06fa			; byte 0 - file id 
06fa			; byte 1 - extent 0 
06fa			; byte 2 - extent count 
06fa			; byte 3 -> file name and meta data 
06fa			 
06fa			 
06fa			storage_create: 
06fa				if DEBUG_STORESE 
06fa					DMARK "SCR" 
06fa f5				push af  
06fb 3a 0f 07			ld a, (.dmark)  
06fe 32 bd fb			ld (debug_mark),a  
0701 3a 10 07			ld a, (.dmark+1)  
0704 32 be fb			ld (debug_mark+1),a  
0707 3a 11 07			ld a, (.dmark+2)  
070a 32 bf fb			ld (debug_mark+2),a  
070d 18 03			jr .pastdmark  
070f ..			.dmark: db "SCR"  
0712 f1			.pastdmark: pop af  
0713			endm  
# End of macro DMARK
0713					CALLMONITOR 
0713 cd ec 16			call break_point_state  
0716				endm  
# End of macro CALLMONITOR
0716				endif 
0716			 
0716 e5				push hl		; save file name pointer 
0717			 
0717 cd ba 03			call storage_get_block_0 
071a			 
071a 3a e8 f9			ld a,(store_page)	; get current file id 
071d 3c				inc a 
071e 32 e8 f9			ld (store_page),a 
0721				 
0721 32 e1 f9			ld (store_tmpid),a			; save id 
0724			 
0724 21 00 00			ld hl, 0 
0727 11 e8 f9			ld de, store_page 
072a				if DEBUG_STORESE 
072a					DMARK "SCw" 
072a f5				push af  
072b 3a 3f 07			ld a, (.dmark)  
072e 32 bd fb			ld (debug_mark),a  
0731 3a 40 07			ld a, (.dmark+1)  
0734 32 be fb			ld (debug_mark+1),a  
0737 3a 41 07			ld a, (.dmark+2)  
073a 32 bf fb			ld (debug_mark+2),a  
073d 18 03			jr .pastdmark  
073f ..			.dmark: db "SCw"  
0742 f1			.pastdmark: pop af  
0743			endm  
# End of macro DMARK
0743					CALLMONITOR 
0743 cd ec 16			call break_point_state  
0746				endm  
# End of macro CALLMONITOR
0746				endif 
0746 cd 6e 03			call storage_write_block	 ; save update 
0749			 
0749				if DEBUG_STORESE 
0749 11 e8 f9				ld de, store_page 
074c					DMARK "SCC" 
074c f5				push af  
074d 3a 61 07			ld a, (.dmark)  
0750 32 bd fb			ld (debug_mark),a  
0753 3a 62 07			ld a, (.dmark+1)  
0756 32 be fb			ld (debug_mark+1),a  
0759 3a 63 07			ld a, (.dmark+2)  
075c 32 bf fb			ld (debug_mark+2),a  
075f 18 03			jr .pastdmark  
0761 ..			.dmark: db "SCC"  
0764 f1			.pastdmark: pop af  
0765			endm  
# End of macro DMARK
0765					CALLMONITOR 
0765 cd ec 16			call break_point_state  
0768				endm  
# End of macro CALLMONITOR
0768				endif 
0768				;  
0768				 
0768 21 40 00			ld hl, STORE_BLOCK_PHY 
076b 11 00 00			ld de, 0 
076e cd 2a 06			call storage_findnextid 
0771			 
0771 22 d2 f9			ld (store_tmppageid), hl    ; save page to use  
0774			 
0774				; TODO detect 0 = no spare blocks 
0774			 
0774				; hl now contains the free page to use for the file header page 
0774			 
0774				if DEBUG_STORESE 
0774				DMARK "SCF" 
0774 f5				push af  
0775 3a 89 07			ld a, (.dmark)  
0778 32 bd fb			ld (debug_mark),a  
077b 3a 8a 07			ld a, (.dmark+1)  
077e 32 be fb			ld (debug_mark+1),a  
0781 3a 8b 07			ld a, (.dmark+2)  
0784 32 bf fb			ld (debug_mark+2),a  
0787 18 03			jr .pastdmark  
0789 ..			.dmark: db "SCF"  
078c f1			.pastdmark: pop af  
078d			endm  
# End of macro DMARK
078d					CALLMONITOR 
078d cd ec 16			call break_point_state  
0790				endm  
# End of macro CALLMONITOR
0790				endif 
0790			 
0790 22 d2 f9			ld (store_tmppageid), hl 
0793				 
0793 3a e1 f9			ld a,(store_tmpid)    ; get file id 
0796			;	ld a, (store_filecache)			; save to cache 
0796			 
0796 32 e8 f9			ld (store_page),a    ; set page id 
0799 3e 00			ld a, 0			 ; extent 0 is file header 
079b 32 e9 f9			ld (store_page+1), a   ; set file extent 
079e			 
079e 32 ea f9			ld (store_page+2), a   ; extent count for the file 
07a1			 
07a1			;	inc hl 		; init block 0 of file 
07a1			;	inc hl   		; skip file and extent id 
07a1			 ;       ld a, 0 
07a1			;	ld (hl),a 
07a1			;	ld a, (store_filecache+1)  	; save to cache 
07a1			 
07a1			;	inc hl    ; file name 
07a1				 
07a1				 
07a1 11 eb f9			ld de, store_page+3    ; get buffer for term string to use as file name 
07a4				if DEBUG_STORESE 
07a4					DMARK "SCc" 
07a4 f5				push af  
07a5 3a b9 07			ld a, (.dmark)  
07a8 32 bd fb			ld (debug_mark),a  
07ab 3a ba 07			ld a, (.dmark+1)  
07ae 32 be fb			ld (debug_mark+1),a  
07b1 3a bb 07			ld a, (.dmark+2)  
07b4 32 bf fb			ld (debug_mark+2),a  
07b7 18 03			jr .pastdmark  
07b9 ..			.dmark: db "SCc"  
07bc f1			.pastdmark: pop af  
07bd			endm  
# End of macro DMARK
07bd					CALLMONITOR 
07bd cd ec 16			call break_point_state  
07c0				endm  
# End of macro CALLMONITOR
07c0				endif 
07c0 e1				pop hl    ; get zero term string 
07c1 e5				push hl 
07c2 3e 00			ld a, 0 
07c4 cd 6f 11			call strlent 
07c7 23				inc hl   ; cover zero term 
07c8 06 00			ld b,0 
07ca 4d				ld c,l 
07cb e1				pop hl 
07cc				;ex de, hl 
07cc				if DEBUG_STORESE 
07cc					DMARK "SCa" 
07cc f5				push af  
07cd 3a e1 07			ld a, (.dmark)  
07d0 32 bd fb			ld (debug_mark),a  
07d3 3a e2 07			ld a, (.dmark+1)  
07d6 32 be fb			ld (debug_mark+1),a  
07d9 3a e3 07			ld a, (.dmark+2)  
07dc 32 bf fb			ld (debug_mark+2),a  
07df 18 03			jr .pastdmark  
07e1 ..			.dmark: db "SCa"  
07e4 f1			.pastdmark: pop af  
07e5			endm  
# End of macro DMARK
07e5					;push af 
07e5					;ld a, 'a' 
07e5					;ld (debug_mark),a 
07e5					;pop af 
07e5					CALLMONITOR 
07e5 cd ec 16			call break_point_state  
07e8				endm  
# End of macro CALLMONITOR
07e8				endif 
07e8 ed b0			ldir    ; copy zero term string 
07ea				if DEBUG_STORESE 
07ea					DMARK "SCA" 
07ea f5				push af  
07eb 3a ff 07			ld a, (.dmark)  
07ee 32 bd fb			ld (debug_mark),a  
07f1 3a 00 08			ld a, (.dmark+1)  
07f4 32 be fb			ld (debug_mark+1),a  
07f7 3a 01 08			ld a, (.dmark+2)  
07fa 32 bf fb			ld (debug_mark+2),a  
07fd 18 03			jr .pastdmark  
07ff ..			.dmark: db "SCA"  
0802 f1			.pastdmark: pop af  
0803			endm  
# End of macro DMARK
0803					CALLMONITOR 
0803 cd ec 16			call break_point_state  
0806				endm  
# End of macro CALLMONITOR
0806				endif 
0806			 
0806				; write file header page 
0806			 
0806 2a d2 f9			ld hl,(store_tmppageid) 
0809 11 e8 f9			ld de, store_page 
080c				if DEBUG_STORESE 
080c					DMARK "SCb" 
080c f5				push af  
080d 3a 21 08			ld a, (.dmark)  
0810 32 bd fb			ld (debug_mark),a  
0813 3a 22 08			ld a, (.dmark+1)  
0816 32 be fb			ld (debug_mark+1),a  
0819 3a 23 08			ld a, (.dmark+2)  
081c 32 bf fb			ld (debug_mark+2),a  
081f 18 03			jr .pastdmark  
0821 ..			.dmark: db "SCb"  
0824 f1			.pastdmark: pop af  
0825			endm  
# End of macro DMARK
0825					;push af 
0825					;ld a, 'b' 
0825					;ld (debug_mark),a 
0825					;pop af 
0825					CALLMONITOR 
0825 cd ec 16			call break_point_state  
0828				endm  
# End of macro CALLMONITOR
0828				endif 
0828 cd 6e 03			call storage_write_block 
082b			 
082b 3a e1 f9			ld a, (store_tmpid) 
082e 6f				ld l, a 
082f 26 00			ld h,0 
0831				if DEBUG_STORESE 
0831					DMARK "SCz" 
0831 f5				push af  
0832 3a 46 08			ld a, (.dmark)  
0835 32 bd fb			ld (debug_mark),a  
0838 3a 47 08			ld a, (.dmark+1)  
083b 32 be fb			ld (debug_mark+1),a  
083e 3a 48 08			ld a, (.dmark+2)  
0841 32 bf fb			ld (debug_mark+2),a  
0844 18 03			jr .pastdmark  
0846 ..			.dmark: db "SCz"  
0849 f1			.pastdmark: pop af  
084a			endm  
# End of macro DMARK
084a					CALLMONITOR 
084a cd ec 16			call break_point_state  
084d				endm  
# End of macro CALLMONITOR
084d				endif 
084d c9				ret 
084e				 
084e			 
084e			 
084e			; 
084e			; Read File 
084e			; 
084e			; h - file id to locate 
084e			; l - extent to locate 
084e			; de - pointer to string to read into 
084e			; 
084e			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
084e			storage_read: 
084e d5				push de 
084f			 
084f			; TODO BUG the above push is it popped before the RET Z? 
084f			 
084f			; TODO how to handle multiple part blocks 
084f			 
084f				; locate file extent to read 
084f			 
084f 5c				ld e, h 
0850 55				ld d, l 
0851 21 40 00			ld hl, STORE_BLOCK_PHY 
0854				if DEBUG_STORESE 
0854					DMARK "SRE" 
0854 f5				push af  
0855 3a 69 08			ld a, (.dmark)  
0858 32 bd fb			ld (debug_mark),a  
085b 3a 6a 08			ld a, (.dmark+1)  
085e 32 be fb			ld (debug_mark+1),a  
0861 3a 6b 08			ld a, (.dmark+2)  
0864 32 bf fb			ld (debug_mark+2),a  
0867 18 03			jr .pastdmark  
0869 ..			.dmark: db "SRE"  
086c f1			.pastdmark: pop af  
086d			endm  
# End of macro DMARK
086d					CALLMONITOR 
086d cd ec 16			call break_point_state  
0870				endm  
# End of macro CALLMONITOR
0870				endif 
0870 cd 2a 06			call storage_findnextid 
0873			 
0873				if DEBUG_STORESE 
0873					DMARK "SRf" 
0873 f5				push af  
0874 3a 88 08			ld a, (.dmark)  
0877 32 bd fb			ld (debug_mark),a  
087a 3a 89 08			ld a, (.dmark+1)  
087d 32 be fb			ld (debug_mark+1),a  
0880 3a 8a 08			ld a, (.dmark+2)  
0883 32 bf fb			ld (debug_mark+2),a  
0886 18 03			jr .pastdmark  
0888 ..			.dmark: db "SRf"  
088b f1			.pastdmark: pop af  
088c			endm  
# End of macro DMARK
088c					CALLMONITOR 
088c cd ec 16			call break_point_state  
088f				endm  
# End of macro CALLMONITOR
088f				endif 
088f cd 2f 0d			call ishlzero 
0892			;	ld a, l 
0892			;	add h 
0892			;	cp 0 
0892 c8				ret z			; block not found so EOF 
0893			 
0893				; hl contains page number to load 
0893 d1				pop de   ; get storage 
0894 d5				push de 
0895				if DEBUG_STORESE 
0895					DMARK "SRg" 
0895 f5				push af  
0896 3a aa 08			ld a, (.dmark)  
0899 32 bd fb			ld (debug_mark),a  
089c 3a ab 08			ld a, (.dmark+1)  
089f 32 be fb			ld (debug_mark+1),a  
08a2 3a ac 08			ld a, (.dmark+2)  
08a5 32 bf fb			ld (debug_mark+2),a  
08a8 18 03			jr .pastdmark  
08aa ..			.dmark: db "SRg"  
08ad f1			.pastdmark: pop af  
08ae			endm  
# End of macro DMARK
08ae					CALLMONITOR 
08ae cd ec 16			call break_point_state  
08b1				endm  
# End of macro CALLMONITOR
08b1				endif 
08b1 cd 09 03			call storage_read_block 
08b4			 
08b4			 
08b4			; TODO if block has no zeros then need to read next block  
08b4			 
08b4			 
08b4					 
08b4 e1				pop hl 		 ; return start of data to show as not EOF 
08b5 23				inc hl   ; past file id 
08b6 23				inc hl   ; past ext 
08b7				if DEBUG_STORESE 
08b7					DMARK "SRe" 
08b7 f5				push af  
08b8 3a cc 08			ld a, (.dmark)  
08bb 32 bd fb			ld (debug_mark),a  
08be 3a cd 08			ld a, (.dmark+1)  
08c1 32 be fb			ld (debug_mark+1),a  
08c4 3a ce 08			ld a, (.dmark+2)  
08c7 32 bf fb			ld (debug_mark+2),a  
08ca 18 03			jr .pastdmark  
08cc ..			.dmark: db "SRe"  
08cf f1			.pastdmark: pop af  
08d0			endm  
# End of macro DMARK
08d0					CALLMONITOR 
08d0 cd ec 16			call break_point_state  
08d3				endm  
# End of macro CALLMONITOR
08d3				endif 
08d3 c9					ret 
08d4			 
08d4			 
08d4			 
08d4			; 
08d4			; Append File 
08d4			; 
08d4			; hl - file id to locate 
08d4			; de - pointer to (multi block) string to write 
08d4			 
08d4			 
08d4			storage_append: 
08d4				; hl -  file id to append to 
08d4				; de - string to append 
08d4			 
08d4 d5				push de 
08d5				 
08d5				if DEBUG_STORESE 
08d5					DMARK "AP1" 
08d5 f5				push af  
08d6 3a ea 08			ld a, (.dmark)  
08d9 32 bd fb			ld (debug_mark),a  
08dc 3a eb 08			ld a, (.dmark+1)  
08df 32 be fb			ld (debug_mark+1),a  
08e2 3a ec 08			ld a, (.dmark+2)  
08e5 32 bf fb			ld (debug_mark+2),a  
08e8 18 03			jr .pastdmark  
08ea ..			.dmark: db "AP1"  
08ed f1			.pastdmark: pop af  
08ee			endm  
# End of macro DMARK
08ee					CALLMONITOR 
08ee cd ec 16			call break_point_state  
08f1				endm  
# End of macro CALLMONITOR
08f1				endif 
08f1			 
08f1 7d				ld a, l 
08f2 32 e1 f9			ld (store_tmpid), a 
08f5			 
08f5				; get file header  
08f5			 
08f5 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
08f7 3a e1 f9			ld a, (store_tmpid) 
08fa 5f				ld e, a 
08fb			 
08fb 21 40 00				ld hl, STORE_BLOCK_PHY 
08fe cd 2a 06				call storage_findnextid 
0901			 
0901 22 d2 f9			ld (store_tmppageid), hl 
0904			 
0904				; TODO handle file id not found 
0904			 
0904				if DEBUG_STORESE 
0904					DMARK "AP2" 
0904 f5				push af  
0905 3a 19 09			ld a, (.dmark)  
0908 32 bd fb			ld (debug_mark),a  
090b 3a 1a 09			ld a, (.dmark+1)  
090e 32 be fb			ld (debug_mark+1),a  
0911 3a 1b 09			ld a, (.dmark+2)  
0914 32 bf fb			ld (debug_mark+2),a  
0917 18 03			jr .pastdmark  
0919 ..			.dmark: db "AP2"  
091c f1			.pastdmark: pop af  
091d			endm  
# End of macro DMARK
091d					CALLMONITOR 
091d cd ec 16			call break_point_state  
0920				endm  
# End of macro CALLMONITOR
0920				endif 
0920			 
0920				; update file extent count 
0920			 
0920 11 e8 f9			ld de, store_page 
0923			 
0923 cd 09 03			call storage_read_block 
0926			 
0926				if DEBUG_STORESE 
0926					DMARK "AP3" 
0926 f5				push af  
0927 3a 3b 09			ld a, (.dmark)  
092a 32 bd fb			ld (debug_mark),a  
092d 3a 3c 09			ld a, (.dmark+1)  
0930 32 be fb			ld (debug_mark+1),a  
0933 3a 3d 09			ld a, (.dmark+2)  
0936 32 bf fb			ld (debug_mark+2),a  
0939 18 03			jr .pastdmark  
093b ..			.dmark: db "AP3"  
093e f1			.pastdmark: pop af  
093f			endm  
# End of macro DMARK
093f					CALLMONITOR 
093f cd ec 16			call break_point_state  
0942				endm  
# End of macro CALLMONITOR
0942				endif 
0942			;	ld (store_tmppageid), hl 
0942			 
0942 3a ea f9			ld a, (store_page+2) 
0945 3c				inc a 
0946 32 ea f9			ld (store_page+2), a 
0949 32 e0 f9			ld (store_tmpext), a 
094c				 
094c				if DEBUG_STORESE 
094c					DMARK "AP3" 
094c f5				push af  
094d 3a 61 09			ld a, (.dmark)  
0950 32 bd fb			ld (debug_mark),a  
0953 3a 62 09			ld a, (.dmark+1)  
0956 32 be fb			ld (debug_mark+1),a  
0959 3a 63 09			ld a, (.dmark+2)  
095c 32 bf fb			ld (debug_mark+2),a  
095f 18 03			jr .pastdmark  
0961 ..			.dmark: db "AP3"  
0964 f1			.pastdmark: pop af  
0965			endm  
# End of macro DMARK
0965					CALLMONITOR 
0965 cd ec 16			call break_point_state  
0968				endm  
# End of macro CALLMONITOR
0968				endif 
0968 2a d2 f9			ld hl, (store_tmppageid) 
096b 11 e8 f9			ld de, store_page 
096e cd 6e 03			call storage_write_block 
0971			 
0971				; find free block 
0971			 
0971 11 00 00			ld de, 0			 ; file extent to locate 
0974			 
0974 21 40 00				ld hl, STORE_BLOCK_PHY 
0977 cd 2a 06				call storage_findnextid 
097a			 
097a					; TODO handle no space left 
097a					 
097a 22 d2 f9				ld (store_tmppageid), hl 
097d			 
097d				if DEBUG_STORESE 
097d					DMARK "AP4" 
097d f5				push af  
097e 3a 92 09			ld a, (.dmark)  
0981 32 bd fb			ld (debug_mark),a  
0984 3a 93 09			ld a, (.dmark+1)  
0987 32 be fb			ld (debug_mark+1),a  
098a 3a 94 09			ld a, (.dmark+2)  
098d 32 bf fb			ld (debug_mark+2),a  
0990 18 03			jr .pastdmark  
0992 ..			.dmark: db "AP4"  
0995 f1			.pastdmark: pop af  
0996			endm  
# End of macro DMARK
0996					CALLMONITOR 
0996 cd ec 16			call break_point_state  
0999				endm  
# End of macro CALLMONITOR
0999				endif 
0999					; init the buffer with zeros so we can id if the buffer is full or not 
0999			 
0999 e5					push hl 
099a c5					push bc 
099b			 
099b 21 e8 f9				ld hl, store_page 
099e 06 40				ld b, STORE_BLOCK_PHY 
09a0 3e 00				ld a, 0 
09a2 77			.zeroblock:	ld (hl), a 
09a3 23					inc hl 
09a4 10 fc				djnz .zeroblock 
09a6			 
09a6 c1					pop bc 
09a7 e1					pop hl 
09a8			 
09a8					; construct block 
09a8			 
09a8 3a e1 f9				ld a, (store_tmpid) 
09ab 32 e8 f9				ld (store_page), a   ; file id 
09ae 3a e0 f9				ld a, (store_tmpext)   ; extent for this block 
09b1 32 e9 f9				ld (store_page+1), a 
09b4			 
09b4 e1					pop hl    ; get string to write 
09b5 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
09b7 11 ea f9				ld de, store_page+2 
09ba			 
09ba				if DEBUG_STORESE 
09ba					DMARK "AP5" 
09ba f5				push af  
09bb 3a cf 09			ld a, (.dmark)  
09be 32 bd fb			ld (debug_mark),a  
09c1 3a d0 09			ld a, (.dmark+1)  
09c4 32 be fb			ld (debug_mark+1),a  
09c7 3a d1 09			ld a, (.dmark+2)  
09ca 32 bf fb			ld (debug_mark+2),a  
09cd 18 03			jr .pastdmark  
09cf ..			.dmark: db "AP5"  
09d2 f1			.pastdmark: pop af  
09d3			endm  
# End of macro DMARK
09d3					CALLMONITOR 
09d3 cd ec 16			call break_point_state  
09d6				endm  
# End of macro CALLMONITOR
09d6				endif 
09d6			 
09d6			 
09d6			 
09d6					; fill buffer with data until end of string or full block 
09d6			 
09d6 7e			.appd:		ld a, (hl) 
09d7 12					ld (de), a 
09d8 fe 00				cp 0 
09da 28 04				jr z, .appdone 
09dc 23					inc hl 
09dd 13					inc de 
09de 10 f6				djnz .appd 
09e0			 
09e0 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
09e1 f5					push af   		; save last byte dumped 
09e2			 
09e2			 
09e2 2a d2 f9			ld hl, (store_tmppageid) 
09e5 11 e8 f9			ld de, store_page 
09e8				if DEBUG_STORESE 
09e8					DMARK "AP6" 
09e8 f5				push af  
09e9 3a fd 09			ld a, (.dmark)  
09ec 32 bd fb			ld (debug_mark),a  
09ef 3a fe 09			ld a, (.dmark+1)  
09f2 32 be fb			ld (debug_mark+1),a  
09f5 3a ff 09			ld a, (.dmark+2)  
09f8 32 bf fb			ld (debug_mark+2),a  
09fb 18 03			jr .pastdmark  
09fd ..			.dmark: db "AP6"  
0a00 f1			.pastdmark: pop af  
0a01			endm  
# End of macro DMARK
0a01					CALLMONITOR 
0a01 cd ec 16			call break_point_state  
0a04				endm  
# End of macro CALLMONITOR
0a04				endif 
0a04 cd 6e 03				call storage_write_block 
0a07			 
0a07			 
0a07				; was that a full block of data written? 
0a07				; any more to write out? 
0a07			 
0a07				; if yes then set vars and jump to start of function again 
0a07			 
0a07 f1					pop af 
0a08 d1					pop de 
0a09			 
0a09 fe 00				cp 0		 ; no, string was fully written 
0a0b c8					ret z 
0a0c			 
0a0c					; setup vars for next cycle 
0a0c			 
0a0c 3a e1 f9				ld a, (store_tmpid) 
0a0f 6f					ld l, a 
0a10 26 00				ld h, 0 
0a12			 
0a12 c3 d4 08			 	jp storage_append	 ; yes, need to write out some more 
0a15			 
0a15			 
0a15			 
0a15			 
0a15			 
0a15			 
0a15			 
0a15			if DEBUG_STORECF 
0a15			storageput:	 
0a15					ret 
0a15			storageread: 
0a15					ld hl, store_page 
0a15					ld b, 200 
0a15					ld a,0 
0a15			.src:		ld (hl),a 
0a15					inc hl 
0a15					djnz .src 
0a15					 
0a15			 
0a15					ld de, 0 
0a15					ld bc, 1 
0a15					ld hl, store_page 
0a15					call cfRead 
0a15			 
0a15				call cfGetError 
0a15				ld hl,scratch 
0a15				call hexout 
0a15				ld hl, scratch+2 
0a15				ld a, 0 
0a15				ld (hl),a 
0a15				ld de, scratch 
0a15				ld a,display_row_1 
0a15				call str_at_display 
0a15				call update_display 
0a15			 
0a15					ld hl, store_page 
0a15					ld (os_cur_ptr),hl 
0a15			 
0a15					ret 
0a15			endif 
0a15			 
0a15			 
0a15			; Clear out the main buffer store (used to remove junk before writing a new block) 
0a15			 
0a15			storage_clear_page: 
0a15 e5				push hl 
0a16 d5				push de 
0a17 c5				push bc 
0a18 21 e8 f9			ld hl, store_page 
0a1b 3e 00			ld a, 0 
0a1d 77				ld (hl), a 
0a1e			 
0a1e 11 e9 f9			ld de, store_page+1 
0a21 01 40 00			ld bc, STORE_BLOCK_PHY 
0a24			 
0a24 ed b0			ldir 
0a26				 
0a26 c1				pop bc 
0a27 d1				pop de 
0a28 e1				pop hl 
0a29 c9				ret 
0a2a			 
0a2a			; eof 
# End of file firmware_storage.asm
0a2a			  
0a2a			; support routines for above hardware abstraction layer  
0a2a			  
0a2a			include "firmware_general.asm"        ; general support functions  
0a2a			 
0a2a			; word look up 
0a2a			 
0a2a			; in 
0a2a			; a is the index 
0a2a			; hl is pointer start of array 
0a2a			; 
0a2a			; returns 
0a2a			; hl to the word 
0a2a			; 
0a2a			 
0a2a			table_lookup:  
0a2a d5					push de 
0a2b eb					ex de, hl 
0a2c			 
0a2c 6f					ld l, a 
0a2d 26 00				ld h, 0 
0a2f 29					add hl, hl 
0a30 19					add hl, de 
0a31 7e					ld a, (hl) 
0a32 23					inc hl 
0a33 66					ld h,(hl) 
0a34 6f					ld l, a 
0a35			 
0a35 d1					pop de 
0a36 c9					ret 
0a37			 
0a37			; Delay loops 
0a37			 
0a37			 
0a37			 
0a37			aDelayInMS: 
0a37 c5				push bc 
0a38 47				ld b,a 
0a39			msdelay: 
0a39 c5				push bc 
0a3a				 
0a3a			 
0a3a 01 41 00			ld bc,041h 
0a3d cd 55 0a			call delayloop 
0a40 c1				pop bc 
0a41 05				dec b 
0a42 20 f5			jr nz,msdelay 
0a44			 
0a44			;if CPU_CLOCK_8MHZ 
0a44			;msdelay8: 
0a44			;	push bc 
0a44			;	 
0a44			; 
0a44			;	ld bc,041h 
0a44			;	call delayloop 
0a44			;	pop bc 
0a44			;	dec b 
0a44			;	jr nz,msdelay8 
0a44			;endif 
0a44			 
0a44			 
0a44 c1				pop bc 
0a45 c9				ret 
0a46			 
0a46			 
0a46			delay250ms: 
0a46				;push de 
0a46 01 00 40			ld bc, 04000h 
0a49 c3 55 0a			jp delayloop 
0a4c			delay500ms: 
0a4c				;push de 
0a4c 01 00 80			ld bc, 08000h 
0a4f c3 55 0a			jp delayloop 
0a52			delay1s: 
0a52				;push bc 
0a52			   ; Clobbers A, d and e 
0a52 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0a55			delayloop: 
0a55 c5			    push bc 
0a56			 
0a56			if BASE_CPM 
0a56				ld bc, CPM_DELAY_TUNE 
0a56			.cpmloop: 
0a56				push bc 
0a56			 
0a56			endif 
0a56			 
0a56			 
0a56			 
0a56			delayloopi: 
0a56			;	push bc 
0a56			;.dl: 
0a56 cb 47		    bit     0,a    	; 8 
0a58 cb 47		    bit     0,a    	; 8 
0a5a cb 47		    bit     0,a    	; 8 
0a5c e6 ff		    and     255  	; 7 
0a5e 0b			    dec     bc      	; 6 
0a5f 79			    ld      a,c     	; 4 
0a60 b0			    or      b     	; 4 
0a61 c2 56 0a		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0a64			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0a64				;pop de 
0a64			;pop bc 
0a64			 
0a64			if BASE_CPM 
0a64				pop bc 
0a64				 
0a64			    dec     bc      	; 6 
0a64			    ld      a,c     	; 4 
0a64			    or      b     	; 4 
0a64			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0a64				 
0a64			 
0a64			endif 
0a64			;if CPU_CLOCK_8MHZ 
0a64			;    pop bc 
0a64			;    push bc 
0a64			;.dl8: 
0a64			;    bit     0,a    	; 8 
0a64			;    bit     0,a    	; 8 
0a64			;    bit     0,a    	; 8 
0a64			;    and     255  	; 7 
0a64			;    dec     bc      	; 6 
0a64			;    ld      a,c     	; 4 
0a64			;    or      b     	; 4 
0a64			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0a64			;endif 
0a64			 
0a64			;if CPU_CLOCK_10MHZ 
0a64			;    pop bc 
0a64			;    push bc 
0a64			;.dl8: 
0a64			;    bit     0,a    	; 8 
0a64			;    bit     0,a    	; 8 
0a64			;    bit     0,a    	; 8 
0a64			;    and     255  	; 7 
0a64			;    dec     bc      	; 6 
0a64			;    ld      a,c     	; 4 
0a64			;    or      b     	; 4 
0a64			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0a64			;endif 
0a64 c1			    pop bc 
0a65			 
0a65 c9				ret 
0a66			 
0a66			 
0a66			 
0a66			; eof 
# End of file firmware_general.asm
0a66			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0a66			; display routines that use the physical hardware abstraction layer 
0a66			 
0a66			 
0a66			; information window 
0a66			 
0a66			; pass hl with 1st string to display 
0a66			; pass de with 2nd string to display 
0a66			 
0a66			info_panel: 
0a66 e5				push hl 
0a67			 
0a67 2a 5e fa			ld hl, (display_fb_active) 
0a6a e5				push hl    ; future de destination 
0a6b 21 53 fb				ld hl, display_fb0 
0a6e 22 5e fa				ld (display_fb_active), hl 
0a71			 
0a71 cd d2 0a			call clear_display 
0a74			 
0a74			 
0a74 3e 2d			ld a, display_row_3 + 5 
0a76 cd e5 0a			call str_at_display 
0a79			 
0a79 e1				pop hl 
0a7a d1				pop de 
0a7b			 
0a7b e5				push hl 
0a7c			 
0a7c			 
0a7c 3e 19			ld a, display_row_2 + 5 
0a7e cd e5 0a			call str_at_display 
0a81			 
0a81			 
0a81 cd f5 0a			call update_display 
0a84 cd f4 1b			call next_page_prompt 
0a87 cd d2 0a			call clear_display 
0a8a			 
0a8a				 
0a8a 21 02 fb				ld hl, display_fb1 
0a8d 22 5e fa				ld (display_fb_active), hl 
0a90 cd f5 0a			call update_display 
0a93			 
0a93			 
0a93 c9				ret 
0a94			 
0a94			 
0a94			 
0a94			 
0a94			; TODO windowing? 
0a94			 
0a94			; TODO scroll line up 
0a94			 
0a94			scroll_up: 
0a94			 
0a94 e5				push hl 
0a95 d5				push de 
0a96 c5				push bc 
0a97			 
0a97				; get frame buffer  
0a97			 
0a97 2a 5e fa			ld hl, (display_fb_active) 
0a9a e5				push hl    ; future de destination 
0a9b			 
0a9b 11 14 00			ld  de, display_cols 
0a9e 19				add hl, de 
0a9f			 
0a9f d1				pop de 
0aa0			 
0aa0				;ex de, hl 
0aa0 01 4f 00			ld bc, display_fb_len -1  
0aa3			;if DEBUG_FORTH_WORDS 
0aa3			;	DMARK "SCL" 
0aa3			;	CALLMONITOR 
0aa3			;endif	 
0aa3 ed b0			ldir 
0aa5			 
0aa5				; wipe bottom row 
0aa5			 
0aa5			 
0aa5 2a 5e fa			ld hl, (display_fb_active) 
0aa8 11 50 00			ld de, display_cols*display_rows 
0aab 19				add hl, de 
0aac 06 14			ld b, display_cols 
0aae 3e 20			ld a, ' ' 
0ab0			.scwipe: 
0ab0 77				ld (hl), a 
0ab1 2b				dec hl 
0ab2 10 fc			djnz .scwipe 
0ab4			 
0ab4				;pop hl 
0ab4			 
0ab4 c1				pop bc 
0ab5 d1				pop de 
0ab6 e1				pop hl 
0ab7			 
0ab7 c9				ret 
0ab8			 
0ab8			 
0ab8			;scroll_upo: 
0ab8			;	ld de, display_row_1 
0ab8			 ;	ld hl, display_row_2 
0ab8			;	ld bc, display_cols 
0ab8			;	ldir 
0ab8			;	ld de, display_row_2 
0ab8			 ;	ld hl, display_row_3 
0ab8			;	ld bc, display_cols 
0ab8			;	ldir 
0ab8			;	ld de, display_row_3 
0ab8			 ;	ld hl, display_row_4 
0ab8			;	ld bc, display_cols 
0ab8			;	ldir 
0ab8			 
0ab8			; TODO clear row 4 
0ab8			 
0ab8			;	ret 
0ab8			 
0ab8				 
0ab8			scroll_down: 
0ab8			 
0ab8 e5				push hl 
0ab9 d5				push de 
0aba c5				push bc 
0abb			 
0abb				; get frame buffer  
0abb			 
0abb 2a 5e fa			ld hl, (display_fb_active) 
0abe			 
0abe 11 4f 00			ld de, display_fb_len - 1 
0ac1 19				add hl, de 
0ac2			 
0ac2 e5			push hl    ; future de destination 
0ac3			 
0ac3 11 14 00			ld  de, display_cols 
0ac6 ed 52			sbc hl, de 
0ac8			 
0ac8			 
0ac8 d1				pop de 
0ac9			 
0ac9			;	ex de, hl 
0ac9 01 4f 00			ld bc, display_fb_len -1  
0acc			 
0acc			 
0acc				 
0acc			 
0acc ed b0			ldir 
0ace			 
0ace				; wipe bottom row 
0ace			 
0ace			 
0ace			;	ld hl, (display_fb_active) 
0ace			;;	ld de, display_cols*display_rows 
0ace			;;	add hl, de 
0ace			;	ld b, display_cols 
0ace			;	ld a, ' ' 
0ace			;.scwiped: 
0ace			;	ld (hl), a 
0ace			;	dec hl 
0ace			;	djnz .scwiped 
0ace			 
0ace				;pop hl 
0ace			 
0ace c1				pop bc 
0acf d1				pop de 
0ad0 e1				pop hl 
0ad1			 
0ad1 c9				ret 
0ad2			;scroll_down: 
0ad2			;	ld de, display_row_4 
0ad2			;	ld hl, display_row_3 
0ad2			;	ld bc, display_cols 
0ad2			;	ldir 
0ad2			;	ld de, display_row_3 
0ad2			; 	ld hl, display_row_2 
0ad2			;	ld bc, display_cols 
0ad2			;	ldir 
0ad2			;	ld de, display_row_2 
0ad2			;	ld hl, display_row_1 
0ad2			;	ld bc, display_cols 
0ad2			;	ldir 
0ad2			;;; TODO clear row 1 
0ad2			;	ret 
0ad2			 
0ad2			 
0ad2			 
0ad2			 
0ad2			 
0ad2			; clear active frame buffer 
0ad2			 
0ad2			clear_display: 
0ad2 3e 20			ld a, ' ' 
0ad4 c3 d7 0a			jp fill_display 
0ad7			 
0ad7			; fill active frame buffer with a char in A 
0ad7			 
0ad7			fill_display: 
0ad7 06 50			ld b,display_fb_len 
0ad9 2a 5e fa			ld hl, (display_fb_active) 
0adc 77			.fd1:	ld (hl),a 
0add 23				inc hl 
0ade 10 fc			djnz .fd1 
0ae0 23				inc hl 
0ae1 3e 00			ld a,0 
0ae3 77				ld (hl),a 
0ae4			 
0ae4			 
0ae4 c9				ret 
0ae5			; Write string (DE) at pos (A) to active frame buffer 
0ae5			 
0ae5 2a 5e fa		str_at_display:    ld hl,(display_fb_active) 
0ae8 06 00					ld b,0 
0aea 4f					ld c,a 
0aeb 09					add hl,bc 
0aec 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0aed b7			            OR   A              ;Null terminator? 
0aee c8			            RET  Z              ;Yes, so finished 
0aef 77					ld (hl),a 
0af0 23				inc hl 
0af1 13			            INC  DE             ;Point to next character 
0af2 18 f8		            JR   .sad1     ;Repeat 
0af4 c9					ret 
0af5			 
0af5			; using current frame buffer write to physical display 
0af5			 
0af5			update_display: 
0af5 e5				push hl 
0af6 2a 5e fa			ld hl, (display_fb_active) 
0af9 cd 58 66			call write_display 
0afc e1				pop hl 
0afd c9				ret 
0afe			 
0afe			; TODO scrolling 
0afe			 
0afe			 
0afe			; move cursor right one char 
0afe			cursor_right: 
0afe			 
0afe				; TODO shift right 
0afe				; TODO if beyond max col 
0afe				; TODO       cursor_next_line 
0afe			 
0afe c9				ret 
0aff			 
0aff			 
0aff			cursor_next_line: 
0aff				; TODO first char 
0aff				; TODO line down 
0aff				; TODO if past last row 
0aff				; TODO    scroll up 
0aff			 
0aff c9				ret 
0b00			 
0b00			cursor_left: 
0b00				; TODO shift left 
0b00				; TODO if beyond left  
0b00				; TODO     cursor prev line 
0b00				 
0b00 c9				ret 
0b01			 
0b01			cursor_prev_line: 
0b01				; TODO last char 
0b01				; TODO line up 
0b01				; TODO if past first row 
0b01				; TODO   scroll down 
0b01			 
0b01 c9				ret 
0b02			 
0b02			 
0b02			cout: 
0b02				; A - char 
0b02 c9				ret 
0b03			 
0b03			 
0b03			; Display a menu and allow item selection (optional toggle items) 
0b03			; 
0b03			; format: 
0b03			; hl pointer to word array with zero term for items 
0b03			; e.g.    db item1 
0b03			;         db .... 
0b03			;         db 0 
0b03			; 
0b03			; a = starting menu item  
0b03			; 
0b03			; de = pointer item toggle array   (todo) 
0b03			; 
0b03			; returns item selected in a 1-... 
0b03			; returns 0 if back button pressed 
0b03			; 
0b03			; NOTE: Uses system frame buffer to display 
0b03			; 
0b03			; LEFT, Q = go back 
0b03			; RIGHT, SPACE, CR = select 
0b03			; UP, A - Up 
0b03			; DOWN, Z - Down 
0b03			 
0b03			 
0b03			 
0b03			 
0b03			 
0b03			menu: 
0b03			 
0b03					; keep array pointer 
0b03			 
0b03 22 e6 f9				ld (store_tmp1), hl 
0b06 32 e4 f9				ld (store_tmp2), a 
0b09			 
0b09					; check for key bounce 
0b09			 
0b09			if BASE_KEV 
0b09			 
0b09 cd 0d 68		.mbounce:	call cin 
0b0c fe 00				cp 0 
0b0e 20 f9				jr nz, .mbounce 
0b10			endif 
0b10					; for ease use ex 
0b10			 
0b10					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0b10 21 53 fb				ld hl, display_fb0 
0b13 22 5e fa				ld (display_fb_active), hl 
0b16			 
0b16 cd d2 0a		.mloop:		call clear_display 
0b19 cd f5 0a				call update_display 
0b1c			 
0b1c					; draw selection id '>' at 1 
0b1c			 
0b1c					; init start of list display 
0b1c			 
0b1c 3e 05				ld a, 5 
0b1e 32 e2 f9				ld (store_tmp3), a   ; display row count 
0b21 3a e4 f9				ld a,( store_tmp2) 
0b24 32 e5 f9				ld (store_tmp2+1), a   ; display item count 
0b27			 
0b27					 
0b27			.mitem:	 
0b27			 
0b27			 
0b27 3a e5 f9				ld a,(store_tmp2+1) 
0b2a 6f					ld l, a 
0b2b 26 00				ld h, 0 
0b2d 29					add hl, hl 
0b2e ed 5b e6 f9			ld de, (store_tmp1) 
0b32 19					add hl, de 
0b33 7e					ld a, (hl) 
0b34 23					inc hl 
0b35 66					ld h,(hl) 
0b36 6f					ld l, a 
0b37			 
0b37 cd 2f 0d				call ishlzero 
0b3a 28 1a				jr z, .mdone 
0b3c			 
0b3c eb					ex de, hl 
0b3d 3a e2 f9				ld a, (store_tmp3) 
0b40 cd e5 0a				call str_at_display 
0b43					 
0b43			 
0b43					; next item 
0b43 3a e5 f9				ld a, (store_tmp2+1) 
0b46 3c					inc a 
0b47 32 e5 f9				ld (store_tmp2+1), a   ; display item count 
0b4a			 
0b4a			 		; next row 
0b4a			 
0b4a 3a e2 f9				ld a, (store_tmp3) 
0b4d c6 14				add display_cols 
0b4f 32 e2 f9				ld (store_tmp3), a 
0b52			 
0b52					; at end of screen? 
0b52			 
0b52 fe 10				cp display_rows*4 
0b54 20 d1				jr nz, .mitem 
0b56			 
0b56			 
0b56			.mdone: 
0b56 cd 2f 0d				call ishlzero 
0b59 28 08				jr z, .nodn 
0b5b			 
0b5b 3e 3c				ld a, display_row_4 
0b5d 11 dc 0b				ld de, .mdown 
0b60 cd e5 0a				call str_at_display 
0b63			 
0b63					; draw options to fill the screens with active item on line 1 
0b63					; if current option is 2 or more then display ^ in top 
0b63			 
0b63 3a e4 f9		.nodn:		ld a, (store_tmp2) 
0b66 fe 00				cp 0 
0b68 28 08				jr z, .noup 
0b6a			 
0b6a 3e 00				ld a, 0 
0b6c 11 da 0b				ld de, .mup 
0b6f cd e5 0a				call str_at_display 
0b72			 
0b72 3e 02		.noup:		ld a, 2 
0b74 11 d8 0b				ld de, .msel 
0b77 cd e5 0a				call str_at_display 
0b7a			 
0b7a					; if current option + 1 is not null then display V in bottom 
0b7a					; get key 
0b7a cd f5 0a				call update_display 
0b7d			 
0b7d			 
0b7d					; handle key 
0b7d			 
0b7d cd fc 67				call cin_wait 
0b80			 
0b80 fe 05				cp KEY_UP 
0b82 28 2b				jr z, .mgoup 
0b84 fe 61				cp 'a' 
0b86 28 27				jr z, .mgoup 
0b88 fe 0a				cp KEY_DOWN 
0b8a 28 32				jr z, .mgod 
0b8c fe 7a				cp 'z' 
0b8e 28 2e				jr z, .mgod 
0b90 fe 20				cp ' ' 
0b92 28 34				jr z, .goend 
0b94 fe 0c				cp KEY_RIGHT 
0b96 28 30				jr z, .goend 
0b98 fe 0d				cp KEY_CR 
0b9a 28 2c				jr z, .goend 
0b9c fe 71				cp 'q' 
0b9e 28 0b				jr z, .goback 
0ba0			 
0ba0 fe 0b				cp KEY_LEFT 
0ba2 28 07				jr z, .goback 
0ba4 fe 08				cp KEY_BS 
0ba6 28 03				jr z, .goback 
0ba8 c3 16 0b				jp .mloop 
0bab			 
0bab			.goback: 
0bab 3e 00			ld a, 0 
0bad 18 1d			jr .goend2 
0baf			 
0baf				; move up one 
0baf			.mgoup: 
0baf 3a e4 f9				ld a, (store_tmp2) 
0bb2 fe 00				cp 0 
0bb4 ca 16 0b				jp z, .mloop 
0bb7 3d					dec a 
0bb8 32 e4 f9				ld (store_tmp2), a 
0bbb c3 16 0b				jp .mloop 
0bbe			 
0bbe				; move down one 
0bbe			.mgod: 
0bbe 3a e4 f9				ld a, (store_tmp2) 
0bc1 3c					inc a 
0bc2 32 e4 f9				ld (store_tmp2), a 
0bc5 c3 16 0b				jp .mloop 
0bc8			 
0bc8			 
0bc8			.goend: 
0bc8					; get selected item number 
0bc8			 
0bc8 3a e4 f9				ld a, (store_tmp2) 
0bcb 3c					inc a 
0bcc			 
0bcc			.goend2: 
0bcc f5					push af 
0bcd			 
0bcd					; restore active fb 
0bcd					; TODO BUG assumes fb1 
0bcd			 
0bcd 21 02 fb				ld hl, display_fb1 
0bd0 22 5e fa				ld (display_fb_active), hl 
0bd3			 
0bd3					; restore main regs 
0bd3			 
0bd3			 
0bd3 cd f5 0a				call update_display 
0bd6			 
0bd6 f1					pop af 
0bd7			 
0bd7 c9				ret 
0bd8			 
0bd8 .. 00		.msel:   db ">",0 
0bda .. 00		.mup:   db "^",0 
0bdc .. 00		.mdown:   db "v",0 
0bde			 
0bde			 
0bde			; eof 
0bde			 
# End of file firmware_display.asm
0bde			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0bde			; random number generators 
0bde			 
0bde			 
0bde			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0bde			 
0bde			 
0bde			;-----> Generate a random number 
0bde			; output a=answer 0<=a<=255 
0bde			; all registers are preserved except: af 
0bde			random: 
0bde e5			        push    hl 
0bdf d5			        push    de 
0be0 2a 40 fa		        ld      hl,(randData) 
0be3 ed 5f		        ld      a,r 
0be5 57			        ld      d,a 
0be6 5e			        ld      e,(hl) 
0be7 19			        add     hl,de 
0be8 85			        add     a,l 
0be9 ac			        xor     h 
0bea 22 40 fa		        ld      (randData),hl 
0bed d1			        pop     de 
0bee e1			        pop     hl 
0bef c9			        ret 
0bf0			 
0bf0			 
0bf0			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0bf0			 
0bf0			 
0bf0			 
0bf0			;------LFSR------ 
0bf0			;James Montelongo 
0bf0			;optimized by Spencer Putt 
0bf0			;out: 
0bf0			; a = 8 bit random number 
0bf0			RandLFSR: 
0bf0 21 46 fa		        ld hl,LFSRSeed+4 
0bf3 5e			        ld e,(hl) 
0bf4 23			        inc hl 
0bf5 56			        ld d,(hl) 
0bf6 23			        inc hl 
0bf7 4e			        ld c,(hl) 
0bf8 23			        inc hl 
0bf9 7e			        ld a,(hl) 
0bfa 47			        ld b,a 
0bfb cb 13		        rl e  
0bfd cb 12			rl d 
0bff cb 11		        rl c  
0c01 17				rla 
0c02 cb 13		        rl e  
0c04 cb 12			rl d 
0c06 cb 11		        rl c  
0c08 17				rla 
0c09 cb 13		        rl e  
0c0b cb 12			rl d 
0c0d cb 11		        rl c  
0c0f 17				rla 
0c10 67			        ld h,a 
0c11 cb 13		        rl e  
0c13 cb 12			rl d 
0c15 cb 11		        rl c  
0c17 17				rla 
0c18 a8			        xor b 
0c19 cb 13		        rl e  
0c1b cb 12			rl d 
0c1d ac			        xor h 
0c1e a9			        xor c 
0c1f aa			        xor d 
0c20 21 48 fa		        ld hl,LFSRSeed+6 
0c23 11 49 fa		        ld de,LFSRSeed+7 
0c26 01 07 00		        ld bc,7 
0c29 ed b8		        lddr 
0c2b 12			        ld (de),a 
0c2c c9			        ret 
0c2d			 
0c2d			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0c2d			 
0c2d			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0c2d			 
0c2d			 
0c2d			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0c2d			 
0c2d			prng16: 
0c2d			;Inputs: 
0c2d			;   (seed1) contains a 16-bit seed value 
0c2d			;   (seed2) contains a NON-ZERO 16-bit seed value 
0c2d			;Outputs: 
0c2d			;   HL is the result 
0c2d			;   BC is the result of the LCG, so not that great of quality 
0c2d			;   DE is preserved 
0c2d			;Destroys: 
0c2d			;   AF 
0c2d			;cycle: 4,294,901,760 (almost 4.3 billion) 
0c2d			;160cc 
0c2d			;26 bytes 
0c2d 2a 3a fa		    ld hl,(seed1) 
0c30 44			    ld b,h 
0c31 4d			    ld c,l 
0c32 29			    add hl,hl 
0c33 29			    add hl,hl 
0c34 2c			    inc l 
0c35 09			    add hl,bc 
0c36 22 3a fa		    ld (seed1),hl 
0c39 2a 38 fa		    ld hl,(seed2) 
0c3c 29			    add hl,hl 
0c3d 9f			    sbc a,a 
0c3e e6 2d		    and %00101101 
0c40 ad			    xor l 
0c41 6f			    ld l,a 
0c42 22 38 fa		    ld (seed2),hl 
0c45 09			    add hl,bc 
0c46 c9			    ret 
0c47			 
0c47			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0c47			 
0c47			rand32: 
0c47			;Inputs: 
0c47			;   (seed1_0) holds the lower 16 bits of the first seed 
0c47			;   (seed1_1) holds the upper 16 bits of the first seed 
0c47			;   (seed2_0) holds the lower 16 bits of the second seed 
0c47			;   (seed2_1) holds the upper 16 bits of the second seed 
0c47			;   **NOTE: seed2 must be non-zero 
0c47			;Outputs: 
0c47			;   HL is the result 
0c47			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0c47			;Destroys: 
0c47			;   AF 
0c47			;Tested and passes all CAcert tests 
0c47			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0c47			;it has a period of 18,446,744,069,414,584,320 
0c47			;roughly 18.4 quintillion. 
0c47			;LFSR taps: 0,2,6,7  = 11000101 
0c47			;291cc 
0c47			;seed1_0=$+1 
0c47			;    ld hl,12345 
0c47			;seed1_1=$+1 
0c47			;    ld de,6789 
0c47			;    ld b,h 
0c47			;    ld c,l 
0c47			;    add hl,hl \ rl e \ rl d 
0c47			;    add hl,hl \ rl e \ rl d 
0c47			;    inc l 
0c47			;    add hl,bc 
0c47			;    ld (seed1_0),hl 
0c47			;    ld hl,(seed1_1) 
0c47			;    adc hl,de 
0c47			;    ld (seed1_1),hl 
0c47			;    ex de,hl 
0c47			;seed2_0=$+1 
0c47			;    ld hl,9876 
0c47			;seed2_1=$+1 
0c47			;    ld bc,54321 
0c47			;    add hl,hl \ rl c \ rl b 
0c47			;    ld (seed2_1),bc 
0c47			;    sbc a,a 
0c47			;    and %11000101 
0c47			;    xor l 
0c47			;    ld l,a 
0c47			;    ld (seed2_0),hl 
0c47			;    ex de,hl 
0c47			;    add hl,bc 
0c47			;    ret 
0c47			; 
0c47			 
0c47			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0c47			; 20 bytes, 86 cycles (excluding ret) 
0c47			 
0c47			; returns   hl = pseudorandom number 
0c47			; corrupts   a 
0c47			 
0c47			; generates 16-bit pseudorandom numbers with a period of 65535 
0c47			; using the xorshift method: 
0c47			 
0c47			; hl ^= hl << 7 
0c47			; hl ^= hl >> 9 
0c47			; hl ^= hl << 8 
0c47			 
0c47			; some alternative shift triplets which also perform well are: 
0c47			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0c47			 
0c47			;  org 32768 
0c47			 
0c47			xrnd: 
0c47 2a 3e fa		  ld hl,(xrandc)       ; seed must not be 0 
0c4a 3e 00		  ld a,0 
0c4c bd			  cp l 
0c4d 20 02		  jr nz, .xrnd1 
0c4f 2e 01		  ld l, 1 
0c51			.xrnd1: 
0c51			 
0c51 7c			  ld a,h 
0c52 1f			  rra 
0c53 7d			  ld a,l 
0c54 1f			  rra 
0c55 ac			  xor h 
0c56 67			  ld h,a 
0c57 7d			  ld a,l 
0c58 1f			  rra 
0c59 7c			  ld a,h 
0c5a 1f			  rra 
0c5b ad			  xor l 
0c5c 6f			  ld l,a 
0c5d ac			  xor h 
0c5e 67			  ld h,a 
0c5f			 
0c5f 22 3e fa		  ld (xrandc),hl 
0c62			 
0c62 c9			  ret 
0c63			;  
0c63			 
0c63			 
0c63			;;;; int maths 
0c63			 
0c63			; https://map.grauw.nl/articles/mult_div_shifts.php 
0c63			; Divide 16-bit values (with 16-bit result) 
0c63			; In: Divide BC by divider DE 
0c63			; Out: BC = result, HL = rest 
0c63			; 
0c63			Div16: 
0c63 21 00 00		    ld hl,0 
0c66 78			    ld a,b 
0c67 06 08		    ld b,8 
0c69			Div16_Loop1: 
0c69 17			    rla 
0c6a ed 6a		    adc hl,hl 
0c6c ed 52		    sbc hl,de 
0c6e 30 01		    jr nc,Div16_NoAdd1 
0c70 19			    add hl,de 
0c71			Div16_NoAdd1: 
0c71 10 f6		    djnz Div16_Loop1 
0c73 17			    rla 
0c74 2f			    cpl 
0c75 47			    ld b,a 
0c76 79			    ld a,c 
0c77 48			    ld c,b 
0c78 06 08		    ld b,8 
0c7a			Div16_Loop2: 
0c7a 17			    rla 
0c7b ed 6a		    adc hl,hl 
0c7d ed 52		    sbc hl,de 
0c7f 30 01		    jr nc,Div16_NoAdd2 
0c81 19			    add hl,de 
0c82			Div16_NoAdd2: 
0c82 10 f6		    djnz Div16_Loop2 
0c84 17			    rla 
0c85 2f			    cpl 
0c86 41			    ld b,c 
0c87 4f			    ld c,a 
0c88 c9			ret 
0c89			 
0c89			 
0c89			;http://z80-heaven.wikidot.com/math 
0c89			; 
0c89			;Inputs: 
0c89			;     DE and A are factors 
0c89			;Outputs: 
0c89			;     A is not changed 
0c89			;     B is 0 
0c89			;     C is not changed 
0c89			;     DE is not changed 
0c89			;     HL is the product 
0c89			;Time: 
0c89			;     342+6x 
0c89			; 
0c89			Mult16: 
0c89			 
0c89 06 08		     ld b,8          ;7           7 
0c8b 21 00 00		     ld hl,0         ;10         10 
0c8e 29			       add hl,hl     ;11*8       88 
0c8f 07			       rlca          ;4*8        32 
0c90 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0c92 19			         add hl,de   ;--         -- 
0c93 10 f9		       djnz $-5      ;13*7+8     99 
0c95 c9			ret 
0c96			 
0c96			; 
0c96			; Square root of 16-bit value 
0c96			; In:  HL = value 
0c96			; Out:  D = result (rounded down) 
0c96			; 
0c96			;Sqr16: 
0c96			;    ld de,#0040 
0c96			;    ld a,l 
0c96			;    ld l,h 
0c96			;    ld h,d 
0c96			;    or a 
0c96			;    ld b,8 
0c96			;Sqr16_Loop: 
0c96			;    sbc hl,de 
0c96			;    jr nc,Sqr16_Skip 
0c96			;    add hl,de 
0c96			;Sqr16_Skip: 
0c96			;    ccf 
0c96			;    rl d 
0c96			;    add a,a 
0c96			;    adc hl,hl 
0c96			;    add a,a 
0c96			;    adc hl,hl 
0c96			;    djnz Sqr16_Loop 
0c96			;    ret 
0c96			; 
0c96			; 
0c96			; Divide 8-bit values 
0c96			; In: Divide E by divider C 
0c96			; Out: A = result, B = rest 
0c96			; 
0c96			Div8: 
0c96 af			    xor a 
0c97 06 08		    ld b,8 
0c99			Div8_Loop: 
0c99 cb 13		    rl e 
0c9b 17			    rla 
0c9c 91			    sub c 
0c9d 30 01		    jr nc,Div8_NoAdd 
0c9f 81			    add a,c 
0ca0			Div8_NoAdd: 
0ca0 10 f7		    djnz Div8_Loop 
0ca2 47			    ld b,a 
0ca3 7b			    ld a,e 
0ca4 17			    rla 
0ca5 2f			    cpl 
0ca6 c9			    ret 
0ca7			 
0ca7			; 
0ca7			; Multiply 8-bit value with a 16-bit value (unrolled) 
0ca7			; In: Multiply A with DE 
0ca7			; Out: HL = result 
0ca7			; 
0ca7			Mult12U: 
0ca7 2e 00		    ld l,0 
0ca9 87			    add a,a 
0caa 30 01		    jr nc,Mult12U_NoAdd0 
0cac 19			    add hl,de 
0cad			Mult12U_NoAdd0: 
0cad 29			    add hl,hl 
0cae 87			    add a,a 
0caf 30 01		    jr nc,Mult12U_NoAdd1 
0cb1 19			    add hl,de 
0cb2			Mult12U_NoAdd1: 
0cb2 29			    add hl,hl 
0cb3 87			    add a,a 
0cb4 30 01		    jr nc,Mult12U_NoAdd2 
0cb6 19			    add hl,de 
0cb7			Mult12U_NoAdd2: 
0cb7 29			    add hl,hl 
0cb8 87			    add a,a 
0cb9 30 01		    jr nc,Mult12U_NoAdd3 
0cbb 19			    add hl,de 
0cbc			Mult12U_NoAdd3: 
0cbc 29			    add hl,hl 
0cbd 87			    add a,a 
0cbe 30 01		    jr nc,Mult12U_NoAdd4 
0cc0 19			    add hl,de 
0cc1			Mult12U_NoAdd4: 
0cc1 29			    add hl,hl 
0cc2 87			    add a,a 
0cc3 30 01		    jr nc,Mult12U_NoAdd5 
0cc5 19			    add hl,de 
0cc6			Mult12U_NoAdd5: 
0cc6 29			    add hl,hl 
0cc7 87			    add a,a 
0cc8 30 01		    jr nc,Mult12U_NoAdd6 
0cca 19			    add hl,de 
0ccb			Mult12U_NoAdd6: 
0ccb 29			    add hl,hl 
0ccc 87			    add a,a 
0ccd d0			    ret nc 
0cce 19			    add hl,de 
0ccf c9			    ret 
0cd0			 
0cd0			; 
0cd0			; Multiply 8-bit value with a 16-bit value (right rotating) 
0cd0			; In: Multiply A with DE 
0cd0			;      Put lowest value in A for most efficient calculation 
0cd0			; Out: HL = result 
0cd0			; 
0cd0			Mult12R: 
0cd0 21 00 00		    ld hl,0 
0cd3			Mult12R_Loop: 
0cd3 cb 3f		    srl a 
0cd5 30 01		    jr nc,Mult12R_NoAdd 
0cd7 19			    add hl,de 
0cd8			Mult12R_NoAdd: 
0cd8 cb 23		    sla e 
0cda cb 12		    rl d 
0cdc b7			    or a 
0cdd c2 d3 0c		    jp nz,Mult12R_Loop 
0ce0 c9			    ret 
0ce1			 
0ce1			; 
0ce1			; Multiply 16-bit values (with 32-bit result) 
0ce1			; In: Multiply BC with DE 
0ce1			; Out: BCHL = result 
0ce1			; 
0ce1			Mult32: 
0ce1 79			    ld a,c 
0ce2 48			    ld c,b 
0ce3 21 00 00		    ld hl,0 
0ce6 06 10		    ld b,16 
0ce8			Mult32_Loop: 
0ce8 29			    add hl,hl 
0ce9 17			    rla 
0cea cb 11		    rl c 
0cec 30 07		    jr nc,Mult32_NoAdd 
0cee 19			    add hl,de 
0cef ce 00		    adc a,0 
0cf1 d2 f5 0c		    jp nc,Mult32_NoAdd 
0cf4 0c			    inc c 
0cf5			Mult32_NoAdd: 
0cf5 10 f1		    djnz Mult32_Loop 
0cf7 41			    ld b,c 
0cf8 4f			    ld c,a 
0cf9 c9			    ret 
0cfa			 
0cfa			 
0cfa			 
0cfa			; 
0cfa			; Multiply 8-bit values 
0cfa			; In:  Multiply H with E 
0cfa			; Out: HL = result 
0cfa			; 
0cfa			Mult8: 
0cfa 16 00		    ld d,0 
0cfc 6a			    ld l,d 
0cfd 06 08		    ld b,8 
0cff			Mult8_Loop: 
0cff 29			    add hl,hl 
0d00 30 01		    jr nc,Mult8_NoAdd 
0d02 19			    add hl,de 
0d03			Mult8_NoAdd: 
0d03 10 fa		    djnz Mult8_Loop 
0d05 c9			    ret 
0d06			 
0d06			 
0d06			 
0d06			 
0d06			 
0d06			 
0d06			 
0d06			 
0d06			;;http://z80-heaven.wikidot.com/math 
0d06			;;This divides DE by BC, storing the result in DE, remainder in HL 
0d06			; 
0d06			;DE_Div_BC:          ;1281-2x, x is at most 16 
0d06			;     ld a,16        ;7 
0d06			;     ld hl,0        ;10 
0d06			;     jp $+5         ;10 
0d06			;.DivLoop: 
0d06			;       add hl,bc    ;-- 
0d06			;       dec a        ;64 
0d06			;       jr z,.DivLoopEnd        ;86 
0d06			; 
0d06			;       sla e        ;128 
0d06			;       rl d         ;128 
0d06			;       adc hl,hl    ;240 
0d06			;       sbc hl,bc    ;240 
0d06			;       jr nc,.DivLoop ;23|21 
0d06			;       inc e        ;-- 
0d06			;       jp .DivLoop+1 
0d06			; 
0d06			;.DivLoopEnd: 
0d06			 
0d06			;HL_Div_C: 
0d06			;Inputs: 
0d06			;     HL is the numerator 
0d06			;     C is the denominator 
0d06			;Outputs: 
0d06			;     A is the remainder 
0d06			;     B is 0 
0d06			;     C is not changed 
0d06			;     DE is not changed 
0d06			;     HL is the quotient 
0d06			; 
0d06			;       ld b,16 
0d06			;       xor a 
0d06			;         add hl,hl 
0d06			;         rla 
0d06			;         cp c 
0d06			;         jr c,$+4 
0d06			;           inc l 
0d06			;           sub c 
0d06			;         djnz $-7 
0d06			 
0d06			; https://plutiedev.com/z80-add-8bit-to-16bit 
0d06			 
0d06			addatohl: 
0d06 85			    add   a, l    ; A = A+L 
0d07 6f			    ld    l, a    ; L = A+L 
0d08 8c			    adc   a, h    ; A = A+L+H+carry 
0d09 95			    sub   l       ; A = H+carry 
0d0a 67			    ld    h, a    ; H = H+carry 
0d0b c9			ret 
0d0c			 
0d0c			addatode: 
0d0c 83			    add   a, e    ; A = A+L 
0d0d 5f			    ld    e, a    ; L = A+L 
0d0e 8a			    adc   a, d    ; A = A+L+H+carry 
0d0f 93			    sub   e       ; A = H+carry 
0d10 57			    ld    d, a    ; H = H+carry 
0d11 c9			ret 
0d12			 
0d12			 
0d12			addatobc: 
0d12 81			    add   a, c    ; A = A+L 
0d13 4f			    ld    c, a    ; L = A+L 
0d14 88			    adc   a, b    ; A = A+L+H+carry 
0d15 91			    sub   c       ; A = H+carry 
0d16 47			    ld    b, a    ; H = H+carry 
0d17 c9			ret 
0d18			 
0d18			subafromhl: 
0d18			   ; If A=0 do nothing 
0d18			    ; Otherwise flip A's sign. Since 
0d18			    ; the upper byte becomes -1, also 
0d18			    ; substract 1 from H. 
0d18 ed 44		    neg 
0d1a ca 23 0d		    jp    z, Skip 
0d1d 25			    dec   h 
0d1e			     
0d1e			    ; Now add the low byte as usual 
0d1e			    ; Two's complement takes care of 
0d1e			    ; ensuring the result is correct 
0d1e 85			    add   a, l 
0d1f 6f			    ld    l, a 
0d20 8c			    adc   a, h 
0d21 95			    sub   l 
0d22 67			    ld    h, a 
0d23			Skip: 
0d23 c9				ret 
0d24			 
0d24			 
0d24			; compare hl and de 
0d24			; returns:  
0d24			; if hl = de, z=1, s=0, c0=0 
0d24			; if hl > de, z=0, s=0, c=0 
0d24			; if hl < de, z=0, s=1, c=1 
0d24			cmp16:	 
0d24 b7				or a 
0d25 ed 52			sbc hl,de 
0d27 e0				ret po 
0d28 7c				ld a,h 
0d29 1f				rra 
0d2a ee 40			xor 01000000B 
0d2c 37				scf 
0d2d 8f				adc a,a 
0d2e c9				ret 
0d2f			 
0d2f			 
0d2f			; test if hl contains zero   - A is destroyed 
0d2f			 
0d2f			ishlzero:    
0d2f b7				or a     ; reset flags 
0d30 7c				ld a, h 
0d31 b5				or l        	 
0d32			 
0d32 c9				ret 
0d33			 
0d33			 
0d33			 
0d33			 
0d33			if FORTH_ENABLE_FLOATMATH 
0d33			;include "float/bbcmath.z80" 
0d33			include "float/lpfpcalc.asm" 
0d33			endif 
0d33			 
0d33			 
0d33			; eof 
0d33			 
# End of file firmware_maths.asm
0d33			include "firmware_strings.asm"   ; string handling  
0d33			 
0d33			 
0d33			; TODO string len 
0d33			; input text string, end on cr with zero term 
0d33			; a offset into frame buffer to start prompt 
0d33			; d is max length 
0d33			; e is display size TODO 
0d33			; c is current cursor position 
0d33			; hl is ptr to where string will be stored 
0d33			 
0d33			 
0d33			; TODO check limit of buffer for new inserts 
0d33			; TODO check insert does not push beyond buffer 
0d33			; TODO scroll in a limited display area 
0d33			; TODO scroll whole screen on page wrap 
0d33			 
0d33			 
0d33			; TODO handle KEY_PREVWORD 
0d33			; TODO handle KEY_NEXTWORD 
0d33			; TODO handle KEY_HOME 
0d33			; TODO handle KEY_END 
0d33			; TODO use LCD cursor? 
0d33			 
0d33 32 b6 fb		input_str:    	ld (input_at_pos),a      ; save display position to start 
0d36 81					add c 
0d37 32 b4 fb				ld (input_at_cursor),a	; save draw pos of cursor 
0d3a 22 b9 fb				ld (input_start), hl     ; save ptr to buffer 
0d3d 79					ld a, c 
0d3e cd 06 0d				call addatohl 
0d41 22 bb fb				ld (input_ptr), hl     ; save ptr to point under the cursor 
0d44 7a					ld a,d 
0d45 32 b8 fb			        ld (input_size), a       ; save length of input area 
0d48 79					ld a, c 
0d49 32 a7 fb				ld (input_cursor),a      ; init cursor start position  
0d4c 7b					ld a,e 
0d4d 32 b7 fb			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0d50					 
0d50					 
0d50			 
0d50			;		ld a,(input_ptr) 
0d50			;		ld (input_under_cursor),a 	; save what is under the cursor 
0d50			 
0d50			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0d50					; init cursor shape if not set by the cin routines 
0d50 21 56 fa				ld hl, cursor_shape 
0d53 3e ff				ld a, 255 
0d55 77					ld (hl), a 
0d56 23					inc hl 
0d57 3e 00				ld a, 0 
0d59 77					ld (hl), a 
0d5a			 
0d5a 3e 0f				ld a, CUR_BLINK_RATE 
0d5c 32 b2 fb				ld (input_cur_flash), a 
0d5f 3e 01				ld a, 1 
0d61 32 b1 fb				ld (input_cur_onoff),a 
0d64			 
0d64			;	if DEBUG_INPUT 
0d64			;		push af 
0d64			;		ld a, 'I' 
0d64			;		ld (debug_mark),a 
0d64			;		pop af 
0d64			;		CALLMONITOR 
0d64			;	endif 
0d64			.is1:		; main entry loop 
0d64			 
0d64			 
0d64			 
0d64					; pause 1ms 
0d64			 
0d64 3e 01				ld a, 1 
0d66 cd 37 0a				call aDelayInMS 
0d69			 
0d69					; dec flash counter 
0d69 3a b2 fb				ld a, (input_cur_flash) 
0d6c 3d					dec a 
0d6d 32 b2 fb				ld (input_cur_flash), a 
0d70 fe 00				cp 0 
0d72 20 0d				jr nz, .nochgstate 
0d74			 
0d74			 
0d74					; change state 
0d74 3a b1 fb				ld a,(input_cur_onoff) 
0d77 ed 44				neg 
0d79 32 b1 fb				ld (input_cur_onoff),a 
0d7c			 
0d7c			 
0d7c					; reset on change of state 
0d7c 3e 0f				ld a, CUR_BLINK_RATE 
0d7e 32 b2 fb				ld (input_cur_flash), a 
0d81			 
0d81			.nochgstate: 
0d81					 
0d81					 
0d81			 
0d81					; display cursor  
0d81			 
0d81			;		ld hl, (input_start) 
0d81			;		ld a, (input_cursor) 
0d81			;		call addatohl 
0d81			 
0d81					; get char under cursor and replace with cursor 
0d81 2a bb fb		ld hl, (input_ptr) 
0d84			;		ld a, (hl) 
0d84			;		ld (input_under_cursor),a 
0d84			;		ld a, '_' 
0d84			;		ld (hl), a 
0d84			 
0d84					; display string 
0d84			 
0d84 ed 5b b9 fb			ld de, (input_start) 
0d88 3a b6 fb				ld a, (input_at_pos) 
0d8b cd e5 0a				call str_at_display 
0d8e			;	        call update_display 
0d8e			 
0d8e					; find place to put the cursor 
0d8e			;		add h 
0d8e			;		ld l, display_row_1 
0d8e			;		sub l 
0d8e			; (input_at_pos) 
0d8e					;ld c, a 
0d8e			;		ld a, (input_cursor) 
0d8e			;		ld l, (input_at_pos) 
0d8e			;		;ld b, h 
0d8e			;		add l 
0d8e			;		ld (input_at_cursor),a 
0d8e					;ld l,h 
0d8e			 
0d8e			;		ld h, 0 
0d8e			;		ld l,(input_at_pos) 
0d8e			;		ld a, (input_cursor) 
0d8e			;		call addatohl 
0d8e			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0d8e			;		call subafromhl 
0d8e			;		ld a,l 
0d8e			;		ld (input_at_cursor), a 
0d8e			 
0d8e				if DEBUG_INPUT 
0d8e					ld a, (hardware_diag) 
0d8e					cp 0 
0d8e					jr z, .skip_input_diag 
0d8e			 
0d8e					ld a,(input_at_pos) 
0d8e					ld hl, LFSRSeed 
0d8e					call hexout 
0d8e					ld a, (input_cursor) 
0d8e					ld hl, LFSRSeed+2 
0d8e					call hexout 
0d8e					ld a,(input_at_cursor) 
0d8e					ld hl, LFSRSeed+4 
0d8e					call hexout 
0d8e			 
0d8e					ld a,(input_cur_onoff) 
0d8e					ld hl, LFSRSeed+6 
0d8e					call hexout 
0d8e			 
0d8e					ld a,(input_cur_flash) 
0d8e					ld hl, LFSRSeed+8 
0d8e					call hexout 
0d8e			 
0d8e					ld a,(input_len) 
0d8e					ld hl, LFSRSeed+10 
0d8e					call hexout 
0d8e					ld hl, LFSRSeed+12 
0d8e					ld a, 0 
0d8e					ld (hl),a 
0d8e					ld a, display_row_4 
0d8e					ld de, LFSRSeed 
0d8e					call str_at_display 
0d8e					.skip_input_diag: 
0d8e				endif 
0d8e			 
0d8e					; decide on if we are showing the cursor this time round 
0d8e			 
0d8e 3a b1 fb				ld a, (input_cur_onoff) 
0d91 fe ff				cp 255 
0d93 28 13				jr z, .skipcur 
0d95			 
0d95			 
0d95 3a b4 fb				ld a,(input_at_cursor) 
0d98 11 56 fa				ld de, cursor_shape 
0d9b cd e5 0a				call str_at_display 
0d9e			 
0d9e					; save length of current input string 
0d9e 2a b9 fb				ld hl, (input_start) 
0da1 cd 64 11				call strlenz 
0da4 7d					ld a,l 
0da5 32 ac fb				ld (input_len),a 
0da8			 
0da8			.skipcur: 
0da8			 
0da8 cd f5 0a			        call update_display 
0dab					 
0dab			 
0dab			 
0dab					; wait 
0dab				 
0dab					; TODO loop without wait to flash the cursor and char under cursor	 
0dab cd 0d 68				call cin    ; _wait 
0dae			 
0dae fe 00				cp 0 
0db0 ca 64 0d				jp z, .is1 
0db3			 
0db3					; get ptr to char to input into 
0db3			 
0db3 4f					ld c,a 
0db4 2a b9 fb				ld hl, (input_start) 
0db7 3a a7 fb				ld a, (input_cursor) 
0dba cd 06 0d				call addatohl 
0dbd 22 bb fb				ld (input_ptr), hl 
0dc0 79					ld a,c 
0dc1			 
0dc1					; replace char under cursor 
0dc1			 
0dc1			;		ld hl, (input_ptr) 
0dc1			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0dc1			;		ld (hl), a 
0dc1			 
0dc1			;	if DEBUG_INPUT 
0dc1			;		push af 
0dc1			;		ld a, 'i' 
0dc1			;		ld (debug_mark),a 
0dc1			;		pop af 
0dc1			;		CALLMONITOR 
0dc1			;	endif 
0dc1 fe 0e				cp KEY_HOME 
0dc3 20 0e				jr nz, .iske 
0dc5			 
0dc5 3a b6 fb				ld a, (input_at_pos) 
0dc8 32 b4 fb				ld (input_at_cursor),a 
0dcb 3e 00				ld a, 0 
0dcd 32 a7 fb				ld (input_cursor), a 
0dd0 c3 64 0d				jp .is1 
0dd3					 
0dd3 fe 0f		.iske:		cp KEY_END 
0dd5 20 03				jr nz, .isknw 
0dd7 c3 64 0d				jp .is1 
0dda			 
0dda fe 06		.isknw:		cp KEY_NEXTWORD 
0ddc 20 1b				jr nz, .iskpw 
0dde			 
0dde 2a bb fb		.isknwm:	ld hl, (input_ptr) 
0de1 7e					ld a,(hl)	 
0de2 fe 00				cp 0 
0de4 ca 64 0d				jp z, .is1    ; end of string 
0de7 fe 20				cp ' ' 
0de9 ca 64 0d				jp z, .is1    ; end of word 
0dec 23					inc hl 
0ded 22 bb fb				ld (input_ptr), hl 
0df0 3a b4 fb				ld a, (input_at_cursor) 
0df3 3c					inc a 
0df4 32 b4 fb				ld (input_at_cursor), a 
0df7 18 e5				jr .isknwm 
0df9			 
0df9 fe 07		.iskpw:		cp KEY_PREVWORD 
0dfb 20 1b				jr nz, .iskl 
0dfd			.iskpwm:	 
0dfd 2a bb fb				ld hl, (input_ptr) 
0e00 7e					ld a,(hl)	 
0e01 fe 00				cp 0  
0e03 ca 64 0d				jp z, .is1    ; end of string 
0e06 fe 20				cp ' ' 
0e08 ca 64 0d				jp z, .is1    ; end of word 
0e0b 2b					dec hl 
0e0c 22 bb fb				ld (input_ptr), hl 
0e0f 3a b4 fb				ld a, (input_at_cursor) 
0e12 3d					dec a 
0e13 32 b4 fb				ld (input_at_cursor), a 
0e16 18 e5				jr .iskpwm 
0e18			 
0e18			 
0e18 fe 0b		.iskl:		cp KEY_LEFT 
0e1a 20 27				jr nz, .isk1 
0e1c			 
0e1c 3a a7 fb				ld a, (input_cursor) 
0e1f			 
0e1f fe 00				cp 0 
0e21 ca 64 0d				jp z, .is1 		; at start of line to ignore  
0e24			 
0e24 3d					dec  a 		; TODO check underflow 
0e25 32 a7 fb				ld (input_cursor), a 
0e28			 
0e28 2a bb fb				ld hl, (input_ptr) 
0e2b 2b					dec hl 
0e2c 22 bb fb				ld (input_ptr), hl 
0e2f					 
0e2f 3a b4 fb				ld a, (input_at_cursor) 
0e32 3d					dec a 
0e33 32 b4 fb				ld (input_at_cursor), a 
0e36			 
0e36 3e 01				ld a, 1		; show cursor moving 
0e38 32 b1 fb				ld (input_cur_onoff),a 
0e3b 3e 0f				ld a, CUR_BLINK_RATE 
0e3d 32 b2 fb				ld (input_cur_flash), a 
0e40			 
0e40 c3 64 0d				jp .is1 
0e43			 
0e43 fe 0c		.isk1:		cp KEY_RIGHT 
0e45 20 2a				jr nz, .isk2 
0e47			 
0e47 3a ac fb				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0e4a 5f					ld e,a 
0e4b 3a a7 fb				ld a, (input_cursor) 
0e4e bb					cp e 
0e4f ca 64 0d				jp z, .is1		; at the end of string so dont go right 
0e52			 
0e52 3c					inc  a 		; TODO check overflow 
0e53 32 a7 fb				ld (input_cursor), a 
0e56			 
0e56 3a b4 fb				ld a, (input_at_cursor) 
0e59 3c					inc a 
0e5a 32 b4 fb				ld (input_at_cursor), a 
0e5d			 
0e5d 2a bb fb				ld hl, (input_ptr) 
0e60 23					inc hl 
0e61 22 bb fb				ld (input_ptr), hl 
0e64			 
0e64 3e 01				ld a, 1		; show cursor moving 
0e66 32 b1 fb				ld (input_cur_onoff),a 
0e69 3e 0f				ld a, CUR_BLINK_RATE 
0e6b 32 b2 fb				ld (input_cur_flash), a 
0e6e			 
0e6e c3 64 0d				jp .is1 
0e71			 
0e71 fe 05		.isk2:		cp KEY_UP 
0e73			 
0e73 20 26				jr nz, .isk3 
0e75			 
0e75					; swap last command with the current on 
0e75			 
0e75					; move cursor to start of string 
0e75 2a b9 fb				ld hl, (input_start) 
0e78 22 bb fb				ld (input_ptr), hl 
0e7b			 
0e7b 3a b6 fb				ld a, (input_at_pos) 
0e7e 32 b4 fb				ld (input_at_cursor), a 
0e81			 
0e81 3e 00				ld a, 0 
0e83 32 a7 fb				ld (input_cursor), a 
0e86					 
0e86					; swap input and last command buffers 
0e86			 
0e86 21 ca f2				ld hl, os_cli_cmd 
0e89 11 c9 f3				ld de, os_last_cmd 
0e8c 06 ff				ld b, 255 
0e8e 7e			.swap1:		ld a, (hl) 
0e8f 4f					ld c,a 
0e90 1a					ld a, (de) 
0e91 77					ld (hl), a 
0e92 79					ld a,c 
0e93 12					ld (de),a 
0e94 23					inc hl 
0e95 13					inc de 
0e96 10 f6				djnz .swap1 
0e98			 
0e98			 
0e98			 
0e98			 
0e98			 
0e98 c3 64 0d				jp .is1 
0e9b			 
0e9b fe 08		.isk3:		cp KEY_BS 
0e9d 20 3c				jr nz, .isk4 
0e9f			 
0e9f 3a a7 fb				ld a, (input_cursor) 
0ea2			 
0ea2 fe 00				cp 0 
0ea4 ca 64 0d				jp z, .is1 		; at start of line to ignore  
0ea7			 
0ea7 3d					dec  a 		; TODO check underflow 
0ea8 32 a7 fb				ld (input_cursor), a 
0eab			 
0eab					; hl is source 
0eab					; de needs to be source - 1 
0eab			 
0eab			;		ld a, 0 
0eab			;		dec hl 
0eab			;		ld (hl), a 
0eab			 
0eab 2a bb fb				ld hl, (input_ptr) 
0eae 2b					dec hl 
0eaf 22 bb fb				ld (input_ptr), hl 
0eb2			 
0eb2					; shift all data 
0eb2			 
0eb2 e5					push hl 
0eb3 23					inc hl 
0eb4 d1					pop de 
0eb5 3a ac fb				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0eb8 4f					ld c,a 
0eb9 06 00				ld b,0 
0ebb ed b0				ldir  
0ebd			 
0ebd			 
0ebd			 
0ebd			 
0ebd 3a b4 fb				ld a, (input_at_cursor) 
0ec0 3d					dec a 
0ec1 32 b4 fb				ld (input_at_cursor), a 
0ec4			 
0ec4			 
0ec4 3e 01				ld a, 1		; show cursor moving 
0ec6 32 b1 fb				ld (input_cur_onoff),a 
0ec9 3e 0f				ld a, CUR_BLINK_RATE 
0ecb 32 b2 fb				ld (input_cur_flash), a 
0ece			 
0ece					; remove char 
0ece 3a b4 fb				ld a, (input_at_cursor) 
0ed1 3c					inc a 
0ed2 11 5c 0f				ld de,.iblank 
0ed5 cd e5 0a				call str_at_display 
0ed8			 
0ed8 c3 64 0d				jp .is1 
0edb			 
0edb fe 0d		.isk4:		cp KEY_CR 
0edd 28 6c				jr z, .endinput 
0edf			 
0edf					; else add the key press to the end 
0edf			 
0edf 4f					ld c, a			; save key pressed 
0ee0			 
0ee0 7e					ld a,(hl)		; get what is currently under char 
0ee1			 
0ee1 fe 00				cp 0			; we are at the end of the string 
0ee3 20 2f				jr nz, .onchar 
0ee5					 
0ee5					; add a char to the end of the string 
0ee5				 
0ee5 71					ld (hl),c 
0ee6 23					inc hl 
0ee7			;		ld a,' ' 
0ee7			;		ld (hl),a 
0ee7			;		inc hl 
0ee7 3e 00				ld a,0 
0ee9 77					ld (hl),a 
0eea 2b					dec hl 
0eeb			 
0eeb 3a a7 fb				ld a, (input_cursor) 
0eee 3c					inc a				; TODO check max string length and scroll  
0eef 32 a7 fb				ld (input_cursor), a		; inc cursor pos 
0ef2							 
0ef2 3a b4 fb				ld a, (input_at_cursor) 
0ef5 3c					inc a 
0ef6 32 b4 fb				ld (input_at_cursor), a 
0ef9			 
0ef9 2a bb fb				ld hl, (input_ptr) 
0efc 23					inc hl 
0efd 22 bb fb				ld (input_ptr), hl 
0f00			 
0f00 2a bb fb				ld hl, (input_ptr) 
0f03 23					inc hl 
0f04 22 bb fb				ld (input_ptr), hl 
0f07			;	if DEBUG_INPUT 
0f07			;		push af 
0f07			;		ld a, '+' 
0f07			;		ld (debug_mark),a 
0f07			;		pop af 
0f07			;		CALLMONITOR 
0f07			;	endif 
0f07 3e 01				ld a, 1		; show cursor moving 
0f09 32 b1 fb				ld (input_cur_onoff),a 
0f0c 3e 0f				ld a, CUR_BLINK_RATE 
0f0e 32 b2 fb				ld (input_cur_flash), a 
0f11 c3 64 0d				jp .is1 
0f14					 
0f14			 
0f14			 
0f14					; if on a char then insert 
0f14			.onchar: 
0f14			 
0f14					; TODO over flow check: make sure insert does not blow out buffer 
0f14			 
0f14					; need to do some maths to use lddr 
0f14			 
0f14 e5					push hl   ; save char pos 
0f15 c5					push bc 
0f16			 
0f16 2a b9 fb				ld hl, (input_start) 
0f19 3a ac fb				ld a, (input_len) 
0f1c cd 06 0d				call addatohl  		; end of string 
0f1f 23					inc hl 
0f20 23					inc hl		; past zero term 
0f21 e5					push hl 
0f22 23					inc hl 
0f23 e5					push hl  
0f24			 
0f24								; start and end of lddr set, now how much to move? 
0f24			 
0f24							 
0f24 3a a7 fb				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0f27 47					ld b,a 
0f28 3a ac fb				ld a,(input_len) 
0f2b 5f					ld e,a 
0f2c 90					sub b 
0f2d 3c					inc a		;?? 
0f2e 3c					inc a		;?? 
0f2f 3c					inc a		;?? 
0f30			 
0f30 06 00				ld b,0 
0f32 4f					ld c,a 
0f33			 
0f33				if DEBUG_INPUT 
0f33					push af 
0f33					ld a, 'i' 
0f33					ld (debug_mark),a 
0f33					pop af 
0f33			;		CALLMONITOR 
0f33				endif 
0f33 d1					pop de 
0f34 e1					pop hl 
0f35				if DEBUG_INPUT 
0f35					push af 
0f35					ld a, 'I' 
0f35					ld (debug_mark),a 
0f35					pop af 
0f35			;		CALLMONITOR 
0f35				endif 
0f35 ed b8				lddr 
0f37				 
0f37			 
0f37			 
0f37					; TODO have a key for insert/overwrite mode???? 
0f37 c1					pop bc 
0f38 e1					pop hl 
0f39 71					ld (hl), c		; otherwise overwrite current char 
0f3a					 
0f3a			 
0f3a			 
0f3a			 
0f3a 3a a7 fb				ld a, (input_cursor) 
0f3d 3c					inc  a 		; TODO check overflow 
0f3e 32 a7 fb				ld (input_cursor), a 
0f41			 
0f41 3a b4 fb				ld a, (input_at_cursor) 
0f44 3c					inc a 
0f45 32 b4 fb				ld (input_at_cursor), a 
0f48			 
0f48 c3 64 0d				jp .is1 
0f4b			 
0f4b			.endinput:	; TODO look for end of string 
0f4b			 
0f4b					; add trailing space for end of token 
0f4b			 
0f4b 2a b9 fb				ld hl, (input_start) 
0f4e 3a ac fb				ld a,(input_len) 
0f51 cd 06 0d				call addatohl 
0f54 3e 20				ld a, ' ' 
0f56 77					ld (hl),a 
0f57					; TODO eof of parse marker 
0f57			 
0f57 23					inc hl 
0f58 3e 00				ld a, 0 
0f5a 77					ld (hl),a 
0f5b			 
0f5b			 
0f5b c9					ret 
0f5c			 
0f5c .. 00		.iblank: db " ",0 
0f5e			 
0f5e			 
0f5e 32 b6 fb		input_str_prev:	ld (input_at_pos), a 
0f61 22 b9 fb				ld (input_start), hl 
0f64 3e 01				ld a,1			; add cursor 
0f66 77					ld (hl),a 
0f67 23					inc hl 
0f68 3e 00				ld a,0 
0f6a 77					ld (hl),a 
0f6b 22 bb fb				ld (input_ptr), hl 
0f6e 7a					ld a,d 
0f6f 32 b8 fb				ld (input_size), a 
0f72 3e 00				ld a,0 
0f74 32 a7 fb				ld (input_cursor),a 
0f77			.instr1:	 
0f77			 
0f77					; TODO do block cursor 
0f77					; TODO switch cursor depending on the modifer key 
0f77			 
0f77					; update cursor shape change on key hold 
0f77			 
0f77 2a bb fb				ld hl, (input_ptr) 
0f7a 2b					dec hl 
0f7b 3a 56 fa				ld a,(cursor_shape) 
0f7e 77					ld (hl), a 
0f7f			 
0f7f					; display entered text 
0f7f 3a b6 fb				ld a,(input_at_pos) 
0f82 cd 2b 67		            	CALL fLCD_Pos       ;Position cursor to location in A 
0f85 ed 5b b9 fb	            	LD   de, (input_start) 
0f89 cd 33 67		            	CALL fLCD_Str       ;Display string pointed to by DE 
0f8c			 
0f8c cd 0d 68				call cin 
0f8f fe 00				cp 0 
0f91 28 e4				jr z, .instr1 
0f93			 
0f93					; proecess keyboard controls first 
0f93			 
0f93 2a bb fb				ld hl,(input_ptr) 
0f96			 
0f96 fe 0d				cp KEY_CR	 ; pressing enter ends input 
0f98 28 5a				jr z, .instrcr 
0f9a			 
0f9a fe 08				cp KEY_BS 	; back space 
0f9c 20 0f				jr nz, .instr2 
0f9e					; process back space 
0f9e			 
0f9e					; TODO stop back space if at start of string 
0f9e 2b					dec hl 
0f9f 2b					dec hl ; to over write cursor 
0fa0 3a 56 fa				ld a,(cursor_shape) 
0fa3					;ld a,0 
0fa3 77					ld (hl),a 
0fa4 23					inc hl 
0fa5 3e 20				ld a," " 
0fa7 77					ld (hl),a 
0fa8 22 bb fb				ld (input_ptr),hl 
0fab					 
0fab			 
0fab 18 ca				jr .instr1 
0fad			 
0fad fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
0faf 20 06				jr nz, .instr3 
0fb1 2b					dec hl 
0fb2 22 bb fb				ld (input_ptr),hl 
0fb5 18 c0				jr .instr1 
0fb7				 
0fb7 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
0fb9 20 06				jr nz, .instr4 
0fbb 23					inc hl 
0fbc 22 bb fb				ld (input_ptr),hl 
0fbf 18 b6				jr .instr1 
0fc1			 
0fc1 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
0fc3 20 06				jr nz, .instr5 
0fc5 2b					dec hl 
0fc6 22 bb fb				ld (input_ptr),hl 
0fc9 18 ac				jr .instr1 
0fcb			 
0fcb fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
0fcd 20 06				jr nz, .instr6 
0fcf 2b					dec hl 
0fd0 22 bb fb				ld (input_ptr),hl 
0fd3 18 a2				jr .instr1 
0fd5 fe 05		.instr6:        cp KEY_UP      ; recall last command 
0fd7 20 0b				jr nz, .instrnew 
0fd9			 
0fd9 21 a3 ef			ld hl, scratch 
0fdc 11 c9 f3			ld de, os_last_cmd 
0fdf cd fd 0f			call strcpy 
0fe2 18 93				jr .instr1 
0fe4			 
0fe4			 
0fe4			.instrnew:	; no special key pressed to see if we have room to store it 
0fe4			 
0fe4					; TODO do string size test 
0fe4			 
0fe4 2b					dec hl ; to over write cursor 
0fe5 77					ld (hl),a 
0fe6 23					inc hl 
0fe7 3a 56 fa				ld a,(cursor_shape) 
0fea 77					ld (hl),a 
0feb 23					inc hl 
0fec 3e 00				ld a,0 
0fee 77					ld (hl),a 
0fef			 
0fef 22 bb fb				ld (input_ptr),hl 
0ff2					 
0ff2 18 83				jr .instr1 
0ff4 2b			.instrcr:	dec hl		; remove cursor 
0ff5 3e 20				ld a,' '	; TODO add a trailing space for safety 
0ff7 77					ld (hl),a 
0ff8 23					inc hl 
0ff9 3e 00				ld a,0 
0ffb 77					ld (hl),a 
0ffc			 
0ffc			 
0ffc					; if at end of line scroll up    
0ffc					; TODO detecting only end of line 4 for scroll up  
0ffc			 
0ffc					;ld   
0ffc			 
0ffc c9					ret 
0ffd			 
0ffd			 
0ffd			; strcpy hl = dest, de source 
0ffd			 
0ffd 1a			strcpy:   LD   A, (DE)        ;Get character from string 
0ffe b7			            OR   A              ;Null terminator? 
0fff c8			            RET  Z              ;Yes, so finished 
1000 1a					ld a,(de) 
1001 77					ld (hl),a 
1002 13			            INC  DE             ;Point to next character 
1003 23					inc hl 
1004 18 f7		            JR   strcpy       ;Repeat 
1006 c9					ret 
1007			 
1007			 
1007			; TODO string_at  
1007			; pass string which starts with lcd offset address and then null term string 
1007			 
1007			; TODO string to dec 
1007			; TODO string to hex 
1007			; TODO byte to string hex 
1007			; TODO byte to string dec 
1007			 
1007			 
1007			 
1007			; from z80uartmonitor 
1007			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1007			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
1007			; pass hl for where to put the text 
1007			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1007 c5			hexout:	PUSH BC 
1008 f5					PUSH AF 
1009 47					LD B, A 
100a					; Upper nybble 
100a cb 3f				SRL A 
100c cb 3f				SRL A 
100e cb 3f				SRL A 
1010 cb 3f				SRL A 
1012 cd 22 10				CALL tohex 
1015 77					ld (hl),a 
1016 23					inc hl	 
1017					 
1017					; Lower nybble 
1017 78					LD A, B 
1018 e6 0f				AND 0FH 
101a cd 22 10				CALL tohex 
101d 77					ld (hl),a 
101e 23					inc hl	 
101f					 
101f f1					POP AF 
1020 c1					POP BC 
1021 c9					RET 
1022					 
1022			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1022			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
1022			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1022			tohex: 
1022 e5					PUSH HL 
1023 d5					PUSH DE 
1024 16 00				LD D, 0 
1026 5f					LD E, A 
1027 21 2f 10				LD HL, .DATA 
102a 19					ADD HL, DE 
102b 7e					LD A, (HL) 
102c d1					POP DE 
102d e1					POP HL 
102e c9					RET 
102f			 
102f			.DATA: 
102f 30					DEFB	30h	; 0 
1030 31					DEFB	31h	; 1 
1031 32					DEFB	32h	; 2 
1032 33					DEFB	33h	; 3 
1033 34					DEFB	34h	; 4 
1034 35					DEFB	35h	; 5 
1035 36					DEFB	36h	; 6 
1036 37					DEFB	37h	; 7 
1037 38					DEFB	38h	; 8 
1038 39					DEFB	39h	; 9 
1039 41					DEFB	41h	; A 
103a 42					DEFB	42h	; B 
103b 43					DEFB	43h	; C 
103c 44					DEFB	44h	; D 
103d 45					DEFB	45h	; E 
103e 46					DEFB	46h	; F 
103f			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
103f			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
103f			;;    subtract $30, if result > 9 then subtract $7 more 
103f			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
103f			atohex: 
103f d6 30				SUB $30 
1041 fe 0a				CP 10 
1043 f8					RET M		; If result negative it was 0-9 so we're done 
1044 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
1046 c9					RET		 
1047			 
1047			 
1047			 
1047			 
1047			; Get 2 ASCII characters as hex byte from pointer in hl 
1047			 
1047			BYTERD: 
1047 16 00			LD	D,00h		;Set up 
1049 cd 51 10			CALL	HEXCON		;Get byte and convert to hex 
104c 87				ADD	A,A		;First nibble so 
104d 87				ADD	A,A		;multiply by 16 
104e 87				ADD	A,A		; 
104f 87				ADD	A,A		; 
1050 57				LD	D,A		;Save hi nibble in D 
1051			HEXCON: 
1051 7e				ld a, (hl)		;Get next chr 
1052 23				inc hl 
1053 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
1055 fe 0a			CP	00Ah		;Is it 0-9 ? 
1057 38 02			JR	C,NALPHA	;If so miss next bit 
1059 d6 07			SUB	007h		;Else convert alpha 
105b			NALPHA: 
105b b2				OR	D		;Add hi nibble back 
105c c9				RET			; 
105d			 
105d			 
105d			; 
105d			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
105d			; Since the routines get_byte and therefore get_nibble are called, only valid 
105d			; characters (0-9a-f) are accepted. 
105d			; 
105d			;get_word        push    af 
105d			;                call    get_byte        ; Get the upper byte 
105d			;                ld      h, a 
105d			;                call    get_byte        ; Get the lower byte 
105d			;                ld      l, a 
105d			;                pop     af 
105d			;                ret 
105d			; 
105d			; Get a byte in hexadecimal notation. The result is returned in A. Since 
105d			; the routine get_nibble is used only valid characters are accepted - the  
105d			; input routine only accepts characters 0-9a-f. 
105d			; 
105d c5			get_byte:        push    bc              ; Save contents of B (and C) 
105e 7e					ld a,(hl) 
105f 23					inc hl 
1060 cd 85 10		                call    nibble2val      ; Get upper nibble 
1063 cb 07		                rlc     a 
1065 cb 07		                rlc     a 
1067 cb 07		                rlc     a 
1069 cb 07		                rlc     a 
106b 47			                ld      b, a            ; Save upper four bits 
106c 7e					ld a,(hl) 
106d cd 85 10		                call    nibble2val      ; Get lower nibble 
1070 b0			                or      b               ; Combine both nibbles 
1071 c1			                pop     bc              ; Restore B (and C) 
1072 c9			                ret 
1073			; 
1073			; Get a hexadecimal digit from the serial line. This routine blocks until 
1073			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
1073			; to the serial line interface. The lower 4 bits of A contain the value of  
1073			; that particular digit. 
1073			; 
1073			;get_nibble      ld a,(hl)           ; Read a character 
1073			;                call    to_upper        ; Convert to upper case 
1073			;                call    is_hex          ; Was it a hex digit? 
1073			;                jr      nc, get_nibble  ; No, get another character 
1073			 ;               call    nibble2val      ; Convert nibble to value 
1073			 ;               call    print_nibble 
1073			 ;               ret 
1073			; 
1073			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
1073			; A valid hexadecimal digit is denoted by a set C flag. 
1073			; 
1073			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
1073			;                ret     nc              ; Yes 
1073			;                cp      '0'             ; Less than '0'? 
1073			;                jr      nc, is_hex_1    ; No, continue 
1073			;                ccf                     ; Complement carry (i.e. clear it) 
1073			;                ret 
1073			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
1073			;                ret     c               ; Yes 
1073			;                cp      'A'             ; Less than 'A'? 
1073			;                jr      nc, is_hex_2    ; No, continue 
1073			;                ccf                     ; Yes - clear carry and return 
1073			;                ret 
1073			;is_hex_2        scf                     ; Set carry 
1073			;                ret 
1073			; 
1073			; Convert a single character contained in A to upper case: 
1073			; 
1073 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
1075 d8			                ret     c 
1076 fe 7b		                cp      'z' + 1         ; > 'z'? 
1078 d0			                ret     nc              ; Nothing to do, either 
1079 e6 5f		                and     $5f             ; Convert to upper case 
107b c9			                ret 
107c			 
107c			 
107c			to_lower: 
107c			 
107c			   ; if char is in [A-Z] make it lower case 
107c			 
107c			   ; enter : a = char 
107c			   ; exit  : a = lower case char 
107c			   ; uses  : af 
107c			 
107c fe 41		   cp 'A' 
107e d8			   ret c 
107f			    
107f fe 5b		   cp 'Z'+1 
1081 d0			   ret nc 
1082			    
1082 f6 20		   or $20 
1084 c9			   ret 
1085			 
1085			; 
1085			; Expects a hexadecimal digit (upper case!) in A and returns the 
1085			; corresponding value in A. 
1085			; 
1085 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
1087 38 02		                jr      c, nibble2val_1 ; Yes 
1089 d6 07		                sub     7               ; Adjust for A-F 
108b d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
108d e6 0f		                and     $f              ; Only return lower 4 bits 
108f c9			                ret 
1090			; 
1090			; Print_nibble prints a single hex nibble which is contained in the lower  
1090			; four bits of A: 
1090			; 
1090			;print_nibble    push    af              ; We won't destroy the contents of A 
1090			;                and     $f              ; Just in case... 
1090			;                add     a, '0'             ; If we have a digit we are done here. 
1090			;                cp      '9' + 1         ; Is the result > 9? 
1090			;                jr      c, print_nibble_1 
1090			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1090			;print_nibble_1  call    putc            ; Print the nibble and 
1090			;                pop     af              ; restore the original value of A 
1090			;                ret 
1090			;; 
1090			;; Send a CR/LF pair: 
1090			; 
1090			;crlf            push    af 
1090			;                ld      a, cr 
1090			;                call    putc 
1090			;                ld      a, lf 
1090			;                call    putc 
1090			;                pop     af 
1090			;                ret 
1090			; 
1090			; Print_word prints the four hex digits of a word to the serial line. The  
1090			; word is expected to be in HL. 
1090			; 
1090			;print_word      push    hl 
1090			;                push    af 
1090			;                ld      a, h 
1090			;                call    print_byte 
1090			;                ld      a, l 
1090			;                call    print_byte 
1090			;                pop     af 
1090			;                pop     hl 
1090			;                ret 
1090			; 
1090			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1090			; The byte to be printed is expected to be in A. 
1090			; 
1090			;print_byte      push    af              ; Save the contents of the registers 
1090			;                push    bc 
1090			;                ld      b, a 
1090			;                rrca 
1090			;                rrca 
1090			;                rrca 
1090			;                rrca 
1090			;                call    print_nibble    ; Print high nibble 
1090			;                ld      a, b 
1090			;                call    print_nibble    ; Print low nibble 
1090			;                pop     bc              ; Restore original register contents 
1090			;                pop     af 
1090			;                ret 
1090			 
1090			 
1090			 
1090			 
1090			 
1090			fourehexhl:  
1090 7e				ld a,(hl) 
1091 cd 3f 10			call atohex 
1094 cb 3f				SRL A 
1096 cb 3f				SRL A 
1098 cb 3f				SRL A 
109a cb 3f				SRL A 
109c 47				ld b, a 
109d 23				inc hl 
109e 7e				ld a,(hl) 
109f 23				inc hl 
10a0 cd 3f 10			call atohex 
10a3 80				add b 
10a4 57				ld d,a 
10a5 7e				ld a,(hl) 
10a6 cd 3f 10			call atohex 
10a9 cb 3f				SRL A 
10ab cb 3f				SRL A 
10ad cb 3f				SRL A 
10af cb 3f				SRL A 
10b1 47				ld b, a 
10b2 23				inc hl 
10b3 7e				ld a,(hl) 
10b4 23				inc hl 
10b5 cd 3f 10			call atohex 
10b8 80				add b 
10b9 5f				ld e, a 
10ba d5				push de 
10bb e1				pop hl 
10bc c9				ret 
10bd			 
10bd			; pass hl. returns z set if the byte at hl is a digit 
10bd			;isdigithl:  
10bd			;	push bc 
10bd			;	ld a,(hl) 
10bd			;	cp ':' 
10bd			;	jr nc, .isdf 		; > 
10bd			;	cp '0' 
10bd			;	jr c, .isdf		; < 
10bd			; 
10bd			;	; TODO find a better way to set z 
10bd			; 
10bd			;	ld b,a 
10bd			;	cp b 
10bd			;	pop bc 
10bd			;	ret 
10bd			; 
10bd			;.isdf:	; not digit so clear z 
10bd			; 
10bd			;	; TODO find a better way to unset z 
10bd			; 
10bd			;	ld b,a 
10bd			;	inc b 
10bd			;	cp b 
10bd			; 
10bd			;	pop bc 
10bd			;	ret 
10bd				 
10bd				 
10bd			 
10bd			 
10bd			; pass hl as the four byte address to load 
10bd			 
10bd			get_word_hl:  
10bd e5				push hl 
10be cd 5d 10			call get_byte 
10c1				 
10c1 47				ld b, a 
10c2			 
10c2 e1				pop hl 
10c3 23				inc hl 
10c4 23				inc hl 
10c5			 
10c5			; TODO not able to handle a-f  
10c5 7e				ld a,(hl) 
10c6			;	;cp ':' 
10c6			;	cp 'g' 
10c6			;	jr nc, .single_byte_hl 		; > 
10c6			;	cp 'G' 
10c6			;	jr nc, .single_byte_hl 		; > 
10c6			;	cp '0' 
10c6			;	jr c, .single_byte_hl		; < 
10c6			 
10c6				;call isdigithl 
10c6 fe 00			cp 0 
10c8 28 06			jr z, .single_byte_hl 
10ca			 
10ca			.getwhln:   ; hex word so get next byte 
10ca			 
10ca cd 5d 10			call get_byte 
10cd 6f				ld l, a 
10ce 60				ld h,b 
10cf c9				ret 
10d0 68			.single_byte_hl:   ld l,b 
10d1 26 00				ld h,0 
10d3 c9					ret 
10d4			 
10d4			 
10d4			 
10d4			 
10d4 21 93 19			ld hl,asc+1 
10d7			;	ld a, (hl) 
10d7			;	call nibble2val 
10d7 cd 5d 10			call get_byte 
10da			 
10da			;	call fourehexhl 
10da 32 d7 ef			ld (scratch+52),a 
10dd				 
10dd 21 d5 ef			ld hl,scratch+50 
10e0 22 c6 f2			ld (os_cur_ptr),hl 
10e3			 
10e3 c9				ret 
10e4			 
10e4			 
10e4			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
10e4			 
10e4			; Decimal Unsigned Version 
10e4			 
10e4			;Number in a to decimal ASCII 
10e4			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
10e4			;Example: display a=56 as "056" 
10e4			;input: a = number 
10e4			;Output: a=0,value of a in the screen 
10e4			;destroys af,bc (don't know about hl and de) 
10e4			DispAToASCII: 
10e4 0e 9c			ld	c,-100 
10e6 cd f0 10			call	.Na1 
10e9 0e f6			ld	c,-10 
10eb cd f0 10			call	.Na1 
10ee 0e ff			ld	c,-1 
10f0 06 2f		.Na1:	ld	b,'0'-1 
10f2 04			.Na2:	inc	b 
10f3 81				add	a,c 
10f4 38 fc			jr	c,.Na2 
10f6 91				sub	c		;works as add 100/10/1 
10f7 f5				push af		;safer than ld c,a 
10f8 78				ld	a,b		;char is in b 
10f9			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
10f9 f1				pop af		;safer than ld a,c 
10fa c9				ret 
10fb			 
10fb			; Decimal Signed Version 
10fb			 
10fb			; DispA 
10fb			; -------------------------------------------------------------- 
10fb			; Converts a signed integer value to a zero-terminated ASCII 
10fb			; string representative of that value (using radix 10). 
10fb			; -------------------------------------------------------------- 
10fb			; INPUTS: 
10fb			;     HL     Value to convert (two's complement integer). 
10fb			;     DE     Base address of string destination. (pointer). 
10fb			; -------------------------------------------------------------- 
10fb			; OUTPUTS: 
10fb			;     None 
10fb			; -------------------------------------------------------------- 
10fb			; REGISTERS/MEMORY DESTROYED 
10fb			; AF HL 
10fb			; -------------------------------------------------------------- 
10fb			 
10fb			;DispHLToASCII: 
10fb			;   push    de 
10fb			;   push    bc 
10fb			; 
10fb			;; Detect sign of HL. 
10fb			;    bit    7, h 
10fb			;    jr     z, ._DoConvert 
10fb			; 
10fb			;; HL is negative. Output '-' to string and negate HL. 
10fb			;    ld     a, '-' 
10fb			;    ld     (de), a 
10fb			;    inc    de 
10fb			; 
10fb			;; Negate HL (using two's complement) 
10fb			;    xor    a 
10fb			;    sub    l 
10fb			;    ld     l, a 
10fb			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
10fb			;    sbc    a, h 
10fb			;    ld     h, a 
10fb			; 
10fb			;; Convert HL to digit characters 
10fb			;._DoConvert: 
10fb			;    ld     b, 0     ; B will count character length of number 
10fb			;-   ld     a, 10 
10fb			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
10fb			;    push   af 
10fb			;    inc    b 
10fb			;    ld     a, h 
10fb			;    or     l 
10fb			;    jr     nz, - 
10fb			; 
10fb			;; Retrieve digits from stack 
10fb			;-   pop    af 
10fb			;    or     $30 
10fb			;    ld     (de), a 
10fb			;    inc    de 
10fb			;    djnz   - 
10fb			; 
10fb			;; Terminate string with NULL 
10fb			;    xor    a 
10fb			;    ld     (de), a 
10fb			; 
10fb			;    pop    bc 
10fb			;    pop    de 
10fb			;    ret 
10fb			 
10fb			;Comments 
10fb			; 
10fb			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
10fb			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
10fb			;    Note that the output string will not be fixed-width. 
10fb			; 
10fb			;Example Usage 
10fb			; 
10fb			;    ld    hl, -1004 
10fb			;    ld    de, OP1 
10fb			;    call  DispA 
10fb			;    ld    hl, OP1 
10fb			;    syscall  PutS 
10fb			 
10fb			 
10fb			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
10fb			 
10fb			 
10fb			;Converts an ASCII string to an unsigned 16-bit integer 
10fb			;Quits when it reaches a non-decimal digit 
10fb			 
10fb			string_to_uint16: 
10fb			atoui_16: 
10fb			;Input: 
10fb			;     DE points to the string 
10fb			;Outputs: 
10fb			;     HL is the result 
10fb			;     A is the 8-bit value of the number 
10fb			;     DE points to the byte after the number 
10fb			;Destroys: 
10fb			;     BC 
10fb			;       if the string is non-empty, BC is HL/10 
10fb			;Size:  24 bytes 
10fb			;Speed: 42+d(104+{0,9}) 
10fb			;       d is the number of digits in the number 
10fb			;       max is 640 cycles for a 5 digit number 
10fb			;Assuming no leading zeros: 
10fb			;1 digit:  146cc 
10fb			;2 digit:  250cc 
10fb			;3 digit:  354cc or 363cc (avg: 354.126cc) 
10fb			;4 digit:  458cc or 467cc (avg: 458.27cc) 
10fb			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
10fb			;avg: 544.81158447265625cc (544+13297/16384) 
10fb			;=============================================================== 
10fb 21 00 00		  ld hl,0 
10fe			.u16a: 
10fe 1a			  ld a,(de) 
10ff d6 30		  sub 30h 
1101 fe 0a		  cp 10 
1103 d0			  ret nc 
1104 13			  inc de 
1105 44			  ld b,h 
1106 4d			  ld c,l 
1107 29			  add hl,hl 
1108 29			  add hl,hl 
1109 09			  add hl,bc 
110a 29			  add hl,hl 
110b 85			  add a,l 
110c 6f			  ld l,a 
110d 30 ef		  jr nc,.u16a 
110f 24			  inc h 
1110 c3 fe 10		  jp .u16a 
1113			 
1113			 
1113			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
1113			 
1113			;written by Zeda 
1113			;Converts a 16-bit unsigned integer to an ASCII string. 
1113			 
1113			uitoa_16: 
1113			;Input: 
1113			;   DE is the number to convert 
1113			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
1113			;Output: 
1113			;   HL points to the null-terminated ASCII string 
1113			;      NOTE: This isn't necessarily the same as the input HL. 
1113 d5			  push de 
1114 c5			  push bc 
1115 f5			  push af 
1116 eb			  ex de,hl 
1117			 
1117 01 f0 d8		  ld bc,-10000 
111a 3e 2f		  ld a,'0'-1 
111c 3c			  inc a 
111d 09			  add hl,bc  
111e 38 fc		   jr c,$-2 
1120 12			  ld (de),a 
1121 13			  inc de 
1122			 
1122 01 e8 03		  ld bc,1000 
1125 3e 3a		  ld a,'9'+1 
1127 3d			  dec a  
1128 09			  add hl,bc  
1129 30 fc		   jr nc,$-2 
112b 12			  ld (de),a 
112c 13			  inc de 
112d			 
112d 01 9c ff		  ld bc,-100 
1130 3e 2f		  ld a,'0'-1 
1132 3c			  inc a  
1133 09			  add hl,bc  
1134 38 fc		   jr c,$-2 
1136 12			  ld (de),a 
1137 13			  inc de 
1138			 
1138 7d			  ld a,l 
1139 26 3a		  ld h,'9'+1 
113b 25			  dec h  
113c c6 0a		  add a,10  
113e 30 fb		   jr nc,$-3 
1140 c6 30		  add a,'0' 
1142 eb			  ex de,hl 
1143 72			  ld (hl),d 
1144 23			  inc hl 
1145 77			  ld (hl),a 
1146 23			  inc hl 
1147 36 00		  ld (hl),0 
1149			 
1149			;Now strip the leading zeros 
1149 0e fa		  ld c,-6 
114b 09			  add hl,bc 
114c 3e 30		  ld a,'0' 
114e 23			  inc hl  
114f be			  cp (hl)  
1150 28 fc		  jr z,$-2 
1152			 
1152			;Make sure that the string is non-empty! 
1152 7e			  ld a,(hl) 
1153 b7			  or a 
1154 20 01		  jr nz,.atoub 
1156 2b			  dec hl 
1157			.atoub: 
1157			 
1157 f1			  pop af 
1158 c1			  pop bc 
1159 d1			  pop de 
115a c9			  ret 
115b			 
115b			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
115b			 
115b			toUpper: 
115b			;A is the char. 
115b			;If A is a lowercase letter, this sets it to the matching uppercase 
115b			;18cc or 30cc or 41cc 
115b			;avg: 26.75cc 
115b fe 61		  cp 'a' 
115d d8			  ret c 
115e fe 7b		  cp 'z'+1 
1160 d0			  ret nc 
1161 d6 20		  sub 'a'-'A' 
1163 c9			  ret 
1164			 
1164			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1164			 
1164			; String Length 
1164			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1164			 
1164			; Get the length of the null-terminated string starting at $8000 hl 
1164			;    LD     HL, $8000 
1164			 
1164			strlenz: 
1164			 
1164 af			    XOR    A               ; Zero is the value we are looking for. 
1165 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1166 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1167			                           ; 65, 536 bytes (the entire addressable memory space). 
1167 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1169			 
1169			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1169 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
116a 6f			    LD     L, A             ; number of bytes 
116b ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
116d 2b			    DEC    HL              ; Compensate for null. 
116e c9				ret 
116f			 
116f			; Get the length of the A terminated string starting at $8000 hl 
116f			;    LD     HL, $8000 
116f			 
116f			strlent: 
116f			 
116f			                  ; A is the value we are looking for. 
116f 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1171 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1173			                           ; 65, 536 bytes (the entire addressable memory space). 
1173 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1175			 
1175			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1175 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1177 2e 00		    LD     L, 0             ; number of bytes 
1179 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
117b 2b			    DEC    HL              ; Compensate for null. 
117c c9				ret 
117d			 
117d			 
117d			;Comparing Strings 
117d			 
117d			;IN    HL     Address of string1. 
117d			;      DE     Address of string2. 
117d			 
117d			; doc given but wrong??? 
117d			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
117d			;      carry  Set if string1 > string2, reset if string1 <= string2. 
117d			; tested 
117d			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
117d			 
117d			strcmp_old: 
117d e5			    PUSH   HL 
117e d5			    PUSH   DE 
117f			 
117f 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1180 be			    CP     (HL)            ; (want to minimize work). 
1181 38 01		    JR     C, Str1IsBigger 
1183 7e			    LD     A, (HL) 
1184			 
1184			Str1IsBigger: 
1184 4f			    LD     C, A             ; Put length in BC 
1185 06 00		    LD     B, 0 
1187 13			    INC    DE              ; Increment pointers to meat of string. 
1188 23			    INC    HL 
1189			 
1189			CmpLoop: 
1189 1a			    LD     A, (DE)          ; Compare bytes. 
118a ed a1		    CPI 
118c 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
118e 13			    INC    DE              ; Update pointer. 
118f ea 89 11		    JP     PE, CmpLoop 
1192			 
1192 d1			    POP    DE 
1193 e1			    POP    HL 
1194 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
1195 be			    CP     (HL) 
1196 c9			    RET 
1197			 
1197			NoMatch: 
1197 2b			    DEC    HL 
1198 be			    CP     (HL)            ; Compare again to affect carry. 
1199 d1			    POP    DE 
119a e1			    POP    HL 
119b c9			    RET 
119c			 
119c			;; test strmp 
119c			; 
119c			;ld de, .str1 
119c			;ld hl, .str2 
119c			;call strcmp 
119c			;jr z, .z1 
119c			;;this 
119c			;	if DEBUG_FORTH_WORDS 
119c			;		DMARK "NZ1" 
119c			;		CALLMONITOR 
119c			;	endif 
119c			;.z1: 
119c			; 
119c			;	if DEBUG_FORTH_WORDS 
119c			;		DMARK "ZZ1" 
119c			;		CALLMONITOR 
119c			;	endif 
119c			; 
119c			;ld de, .str1 
119c			;ld hl, .str1 
119c			;call strcmp 
119c			;jr z, .z2 
119c			;;this 
119c			;	if DEBUG_FORTH_WORDS 
119c			;		DMARK "NZ2" 
119c			;		CALLMONITOR 
119c			;	endif 
119c			;.z2: 
119c			; 
119c			;	if DEBUG_FORTH_WORDS 
119c			;		DMARK "ZZ2" 
119c			;		CALLMONITOR 
119c			;	endif 
119c			; 
119c			;ld de, .str1 
119c			;ld hl, .str2 
119c			;call strcmp 
119c			;jr c, .c1 
119c			; 
119c			;	if DEBUG_FORTH_WORDS 
119c			;		DMARK "Nc1" 
119c			;		CALLMONITOR 
119c			;	endif 
119c			;.c1: 
119c			;;this 
119c			;	if DEBUG_FORTH_WORDS 
119c			;		DMARK "cc1" 
119c			;		CALLMONITOR 
119c			;	endif 
119c			; 
119c			;ld de, .str1 
119c			;ld hl, .str1 
119c			;call strcmp 
119c			;jr c, .c2 
119c			;;this 
119c			;	if DEBUG_FORTH_WORDS 
119c			;		DMARK "Nc2" 
119c			;		CALLMONITOR 
119c			;	endif 
119c			;.c2: 
119c			; 
119c			;	if DEBUG_FORTH_WORDS 
119c			;		DMARK "cc2" 
119c			;		CALLMONITOR 
119c			;	endif 
119c			;	NEXTW 
119c			;.str1:   db "string1",0 
119c			;.str2:   db "string2",0 
119c			 
119c			; only care about direct match or not 
119c			; hl and de strings 
119c			; zero set if the same 
119c			 
119c			strcmp: 
119c 1a				ld a, (de) 
119d be				cp (hl) 
119e 28 02			jr z, .ssame 
11a0 b7				or a 
11a1 c9				ret 
11a2			 
11a2			.ssame:  
11a2 fe 00			cp 0 
11a4 c8				ret z 
11a5			 
11a5 23				inc hl 
11a6 13				inc de 
11a7 18 f3			jr strcmp 
11a9				 
11a9				 
11a9			 
11a9			 
11a9			 
11a9			 
11a9			; eof 
11a9			 
11a9			 
11a9			 
11a9			 
11a9			 
11a9			 
# End of file firmware_strings.asm
11a9			include "firmware_memory.asm"   ; malloc and free  
11a9			 
11a9			if DEBUG_FORTH_MALLOC_HIGH 
11a9			.mallocsize: db "Wants malloc >256",0 
11a9			.mallocasize: db "MALLOC gives >256",0 
11a9			.malloczero: db "MALLOC gives zero",0 
11a9			 
11a9			malloc_guard_zerolen: 
11a9				push hl 
11a9				push de 
11a9				push af 
11a9			 
11a9				ld de, 0 
11a9			        call cmp16 
11a9				jr nz, .lowalloz 
11a9			 
11a9				push hl 
11a9				push de 
11a9					ld hl, display_fb0 
11a9					ld (display_fb_active), hl 
11a9				call clear_display 
11a9				ld a, 0 
11a9				ld de, .malloczero 
11a9				call str_at_display 
11a9				call update_display 
11a9				call delay1s 
11a9				call delay1s 
11a9				ld a, 0 
11a9				ld (os_view_disable), a 
11a9			 
11a9				pop de 
11a9				pop hl 
11a9			 
11a9				 
11a9			 
11a9				CALLMONITOR 
11a9			.lowalloz: 
11a9			 
11a9			 
11a9				pop af 
11a9				pop de 
11a9				pop hl 
11a9			ret 
11a9			 
11a9			malloc_guard_entry: 
11a9				push hl 
11a9				push de 
11a9				push af 
11a9			 
11a9			 	or a      ;clear carry flag 
11a9				push hl 
11a9				ld de, 255 
11a9				sbc hl, de 
11a9				jr c, .lowalloc 
11a9			 
11a9				push de 
11a9					ld hl, display_fb0 
11a9					ld (display_fb_active), hl 
11a9				call clear_display 
11a9				ld a, 0 
11a9				ld de, .mallocsize 
11a9				call str_at_display 
11a9				call update_display 
11a9				call delay1s 
11a9				call delay1s 
11a9				ld a, 0 
11a9				ld (os_view_disable), a 
11a9			 
11a9				pop de 
11a9				pop hl 
11a9			 
11a9				 
11a9			 
11a9				CALLMONITOR 
11a9				jr .lowdone 
11a9			.lowalloc: 
11a9			 
11a9			 
11a9				pop hl 
11a9			.lowdone:	pop af 
11a9				pop de 
11a9				pop hl 
11a9			ret 
11a9			 
11a9			malloc_guard_exit: 
11a9				push hl 
11a9				push de 
11a9				push af 
11a9			 
11a9			 	or a      ;clear carry flag 
11a9				push hl 
11a9				ld de, 255 
11a9				sbc hl, de 
11a9				jr c, .lowallocx 
11a9			 
11a9				push de 
11a9					ld hl, display_fb0 
11a9					ld (display_fb_active), hl 
11a9				call clear_display 
11a9				ld a, 0 
11a9				ld de, .mallocasize 
11a9				call str_at_display 
11a9				call update_display 
11a9				call delay1s 
11a9				call delay1s 
11a9				ld a, 0 
11a9				ld (os_view_disable), a 
11a9				pop de 
11a9				pop hl 
11a9			 
11a9				CALLMONITOR 
11a9				jr .lowdonex 
11a9			.lowallocx: 
11a9			 
11a9				pop hl 
11a9			.lowdonex:	pop af 
11a9				pop de 
11a9				pop hl 
11a9			ret 
11a9			endif 
11a9			 
11a9			if MALLOC_2 
11a9			; Z80 Malloc and Free Functions 
11a9			 
11a9			; Malloc Function: 
11a9			; Input: 
11a9			;   HL: Size of block to allocate 
11a9			; Output: 
11a9			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
11a9			 
11a9			malloc: 
11a9				 
11a9			if DEBUG_FORTH_MALLOC_HIGH 
11a9			call malloc_guard_entry 
11a9			endif 
11a9			 
11a9			 
11a9			 
11a9			 
11a9					if DEBUG_FORTH_MALLOC 
11a9						DMARK "mal" 
11a9						CALLMONITOR 
11a9					endif 
11a9			    push af            ; Save AF register 
11a9			    ld a, l            ; Load low byte of size into A 
11a9			    or h               ; Check if size is zero 
11a9			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
11a9			 
11a9			    ; Allocate memory 
11a9			    ld hl, (heap_start) ; Load start of heap into HL 
11a9					if DEBUG_FORTH_MALLOC 
11a9						DMARK "ma1" 
11a9						CALLMONITOR 
11a9					endif 
11a9			    call malloc_internal ; Call internal malloc function 
11a9			    pop af             ; Restore AF register 
11a9			if DEBUG_FORTH_MALLOC_HIGH 
11a9			call malloc_guard_exit 
11a9			call malloc_guard_zerolen 
11a9			endif 
11a9			    ret                ; Return 
11a9			 
11a9			; Free Function: 
11a9			; Input: 
11a9			;   HL: Pointer to memory block to free 
11a9			; Output: 
11a9			;   None 
11a9			 
11a9			free: 
11a9			    push af            ; Save AF register 
11a9			    ld a, l            ; Load low byte of pointer into A 
11a9			    or h               ; Check if pointer is NULL 
11a9			    jp z, free_exit    ; If pointer is NULL, exit 
11a9			 
11a9			    ; Free memory 
11a9			    ld hl, (heap_start) ; Load start of heap into HL 
11a9			    call free_internal  ; Call internal free function 
11a9			    pop af             ; Restore AF register 
11a9			    ret                ; Return 
11a9			 
11a9			; Internal Malloc Function: 
11a9			; Input: 
11a9			;   HL: Size of block to allocate 
11a9			; Output: 
11a9			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
11a9			 
11a9			malloc_internal: 
11a9			    ld bc, 2           ; Number of bytes to allocate for management overhead 
11a9			    add hl, bc         ; Add management overhead to requested size 
11a9			    ex de, hl          ; Save total size in DE, and keep it in HL 
11a9					if DEBUG_FORTH_MALLOC 
11a9						DMARK "ma2" 
11a9						CALLMONITOR 
11a9					endif 
11a9			 
11a9			    ; Search for free memory block 
11a9			    ld de, (heap_end)  ; Load end of heap into DE 
11a9			    ld bc, 0           ; Initialize counter 
11a9			 
11a9					if DEBUG_FORTH_MALLOC 
11a9						DMARK "ma2" 
11a9						CALLMONITOR 
11a9					endif 
11a9			malloc_search_loop: 
11a9			    ; Check if current block is free 
11a9			    ld a, (hl)         ; Load current block's status (free or used) 
11a9			    cp 0               ; Compare with zero (free) 
11a9			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
11a9			 
11a9			    ; Check if current block is large enough 
11a9			    ld a, (hl+1)       ; Load high byte of block size 
11a9			    cp l               ; Compare with low byte of requested size 
11a9			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
11a9			 
11a9			    ld a, (hl+2)       ; Load low byte of block size 
11a9			    cp h               ; Compare with high byte of requested size 
11a9			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
11a9			 
11a9			    ; Mark block as used 
11a9			    ld (hl), 0xFF      ; Set status byte to indicate used block 
11a9			 
11a9			    ; Calculate remaining space in block 
11a9			    ld bc, 0           ; Clear BC 
11a9			    add hl, bc         ; Increment HL to point to start of data block 
11a9			    add hl, de         ; HL = HL + DE (total size) 
11a9			    ld bc, 1           ; Number of bytes to allocate for management overhead 
11a9			    add hl, bc         ; Add management overhead to start of data block 
11a9			 
11a9			    ; Save pointer to allocated block in HL 
11a9			if DEBUG_FORTH_MALLOC_HIGH 
11a9						DMARK "ma5" 
11a9			call malloc_guard_exit 
11a9			call malloc_guard_zerolen 
11a9			endif 
11a9			    ret 
11a9			 
11a9			malloc_skip_block_check: 
11a9			    ; Move to the next block 
11a9			    ld bc, 3           ; Size of management overhead 
11a9			    add hl, bc         ; Move to the next block 
11a9			    inc de             ; Increment counter 
11a9			 
11a9			    ; Check if we have reached the end of heap 
11a9			    ld a, e            ; Load low byte of heap end address 
11a9			    cp (hl)            ; Compare with low byte of current address 
11a9			    jr nz, malloc_search_loop  ; If not equal, continue searching 
11a9			    ld a, d            ; Load high byte of heap end address 
11a9			    cp 0               ; Check if it's zero (end of memory) 
11a9			    jr nz, malloc_search_loop  ; If not zero, continue searching 
11a9			 
11a9			    ; If we reached here, allocation failed 
11a9			    xor a              ; Set result to NULL 
11a9			if DEBUG_FORTH_MALLOC_HIGH 
11a9						DMARK "ma6" 
11a9			call malloc_guard_exit 
11a9			call malloc_guard_zerolen 
11a9			endif 
11a9			    ret 
11a9			malloc_exit: 
11a9			if DEBUG_FORTH_MALLOC_HIGH 
11a9						DMARK "ma7" 
11a9			call malloc_guard_exit 
11a9			call malloc_guard_zerolen 
11a9			endif 
11a9			    ret 
11a9			 
11a9			; Internal Free Function: 
11a9			; Input: 
11a9			;   HL: Pointer to memory block to free 
11a9			; Output: 
11a9			;   None 
11a9			 
11a9			free_internal: 
11a9			    ld de, (heap_start) ; Load start of heap into DE 
11a9			    ld bc, 0            ; Initialize counter 
11a9			 
11a9			free_search_loop: 
11a9			    ; Check if current block contains the pointer 
11a9			    ld a, l             ; Load low byte of pointer 
11a9			    cp (hl+1)           ; Compare with high byte of current block's address 
11a9			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
11a9			    ld a, h             ; Load high byte of pointer 
11a9			    cp (hl+2)           ; Compare with low byte of current block's address 
11a9			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
11a9			 
11a9			    ; Mark block as free 
11a9			    ld (hl), 0          ; Set status byte to indicate free block 
11a9			    ret                 ; Return 
11a9			 
11a9			free_skip_block_check: 
11a9			    ; Move to the next block 
11a9			    ld bc, 3            ; Size of management overhead 
11a9			    add hl, bc          ; Move to the next block 
11a9			    inc de              ; Increment counter 
11a9			 
11a9			    ; Check if we have reached the end of heap 
11a9			    ld a, e             ; Load low byte of heap end address 
11a9			    cp (hl)             ; Compare with low byte of current address 
11a9			    jr nz, free_search_loop  ; If not equal, continue searching 
11a9			    ld a, d             ; Load high byte of heap end address 
11a9			    cp 0                ; Check if it's zero (end of memory) 
11a9			    jr nz, free_search_loop  ; If not zero, continue searching 
11a9			 
11a9			    ; If we reached here, pointer is not found in heap 
11a9			    ret 
11a9			 
11a9			free_exit: 
11a9			    ret                 ; Return 
11a9			 
11a9			; Define heap start and end addresses 
11a9			;heap_start:    .dw 0xC000   ; Start of heap 
11a9			;heap_end:      .dw 0xE000   ; End of heap 
11a9			 
11a9			endif 
11a9			 
11a9			 
11a9			if MALLOC_1 
11a9			 
11a9			 
11a9			 
11a9			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
11a9			 
11a9			;moved to firmware.asm 
11a9			;heap_start        .equ  0x9000      ; Starting address of heap 
11a9			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
11a9			 
11a9			;      .org 0 
11a9			;      jp    main 
11a9			 
11a9			 
11a9			;      .org  0x100 
11a9			;main: 
11a9			;      ld    HL, 0x8100 
11a9			;      ld    SP, HL 
11a9			; 
11a9			;      call  heap_init 
11a9			; 
11a9			;      ; Make some allocations 
11a9			;      ld    HL, 12 
11a9			;      call  malloc            ; Allocates 0x9004 
11a9			; 
11a9			;      ld    HL, 12 
11a9			;      call  malloc            ; Allocates 0x9014 
11a9			; 
11a9			;      ld    HL, 12 
11a9			;      call  malloc            ; Allocates 0x9024 
11a9			; 
11a9			;      ; Free some allocations 
11a9			;      ld    HL, 0x9014 
11a9			;      call  free 
11a9			; 
11a9			;      ld    HL, 0x9004 
11a9			;      call  free 
11a9			; 
11a9			;      ld    HL, 0x9024 
11a9			;      call  free 
11a9			; 
11a9			; 
11a9			;      halt 
11a9			 
11a9			 
11a9			;------------------------------------------------------------------------------ 
11a9			;     heap_init                                                               : 
11a9			;                                                                             : 
11a9			; Description                                                                 : 
11a9			;     Initialise the heap and make it ready for malloc and free operations.   : 
11a9			;                                                                             : 
11a9			;     The heap is maintained as a linked list, starting with an initial       : 
11a9			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
11a9			;     the first free block in the heap. Each block then points to the next    : 
11a9			;     free block within the heap, and the free list ends at the first block   : 
11a9			;     with a null pointer to the next free block.                             : 
11a9			;                                                                             : 
11a9			; Parameters                                                                  : 
11a9			;     Inputs are compile-time only. Two defines which specify the starting    : 
11a9			;     address of the heap and its size are required, along with a memory      : 
11a9			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
11a9			;     principally stores a pointer to the first free block in the heap.       : 
11a9			;                                                                             : 
11a9			; Returns                                                                     : 
11a9			;     Nothing                                                                 : 
11a9			;------------------------------------------------------------------------------ 
11a9			heap_init: 
11a9 e5			      push  HL 
11aa			 
11aa			      ; Initialise free list struct 
11aa 21 0e 80		      ld    HL, heap_start 
11ad 22 0a 80		      ld    (free_list), HL 
11b0 21 00 00		      ld    HL, 0 
11b3 22 0c 80		      ld    (free_list+2), HL 
11b6			 
11b6			      ; Insert first free block at bottom of heap, consumes entire heap 
11b6 21 0a 80		      ld    HL, heap_start+heap_size-4 
11b9 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
11bc 21 fc ff		      ld    HL, heap_size-4 
11bf 22 10 80		      ld    (heap_start+2), HL      ; Block size 
11c2			 
11c2			      ; Insert end of free list block at top of heap - two null words will 
11c2			      ; terminate the free list 
11c2 21 00 00		      ld    HL, 0 
11c5 22 0c 80		      ld    (heap_start+heap_size-2), HL 
11c8 22 0a 80		      ld    (heap_start+heap_size-4), HL 
11cb			 
11cb e1			      pop   HL 
11cc			 
11cc c9			      ret 
11cd			 
11cd			 
11cd			;------------------------------------------------------------------------------ 
11cd			;     malloc                                                                  : 
11cd			;                                                                             : 
11cd			; Description                                                                 : 
11cd			;     Allocates the wanted space from the heap and returns the address of the : 
11cd			;     first useable byte of the allocation.                                   : 
11cd			;                                                                             : 
11cd			;     Allocations can happen in one of two ways:                              : 
11cd			;                                                                             : 
11cd			;     1. A free block may be found which is the exact size wanted. In this    : 
11cd			;        case the block is removed from the free list and retuedn to the      : 
11cd			;        caller.                                                              : 
11cd			;     2. A free block may be found which is larger than the size wanted. In   : 
11cd			;        this case, the larger block is split into two. The first portion of  : 
11cd			;        this block will become the requested space by the malloc call and    : 
11cd			;        is returned to the caller. The second portion becomes a new free     : 
11cd			;        block, and the free list is adjusted to maintain continuity via this : 
11cd			;        newly created block.                                                 : 
11cd			;                                                                             : 
11cd			;     malloc does not set any initial value in the allocated space, the       : 
11cd			;     caller is required to do this as required.                              : 
11cd			;                                                                             : 
11cd			;     This implementation of malloc uses the stack exclusively, and is        : 
11cd			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
11cd			;     advisable to disable interrupts before calling malloc, and recommended  : 
11cd			;     to avoid the use of malloc inside ISRs in general.                      : 
11cd			;                                                                             : 
11cd			;     NOTE: heap_init must be called before malloc and free can be used.      : 
11cd			;                                                                             : 
11cd			; Parameters                                                                  : 
11cd			;     HL  Number of bytes wanted                                              : 
11cd			;                                                                             : 
11cd			; Returns                                                                     : 
11cd			;     HL  Address of the first useable byte of the allocation                 : 
11cd			;                                                                             : 
11cd			; Flags                                                                       : 
11cd			;     Z   Set if the allocation did not succeed, clear otherwise              : 
11cd			;                                                                             : 
11cd			; Stack frame                                                                 : 
11cd			;       |             |                                                       : 
11cd			;       +-------------+                                                       : 
11cd			;       |     BC      |                                                       : 
11cd			;       +-------------+                                                       : 
11cd			;       |     DE      |                                                       : 
11cd			;       +-------------+                                                       : 
11cd			;       |     IX      |                                                       : 
11cd			;       +-------------+                                                       : 
11cd			;       |  prev_free  |                                                       : 
11cd			;   +4  +-------------+                                                       : 
11cd			;       |  this_free  |                                                       : 
11cd			;   +2  +-------------+                                                       : 
11cd			;       |  next_free  |                                                       : 
11cd			;   +0  +-------------+                                                       : 
11cd			;       |             |                                                       : 
11cd			;                                                                             : 
11cd			;------------------------------------------------------------------------------ 
11cd			 
11cd			 
11cd			;malloc: 
11cd			; 
11cd			;	SAVESP ON 1 
11cd			; 
11cd			;	call malloc_code 
11cd			; 
11cd			;	CHECKSP ON 1 
11cd			;	ret 
11cd			 
11cd			 
11cd			malloc: 
11cd c5			      push  BC 
11ce d5			      push  DE 
11cf dd e5		      push  IX 
11d1			if DEBUG_FORTH_MALLOC_HIGH 
11d1			call malloc_guard_entry 
11d1			endif 
11d1			 
11d1					if DEBUG_FORTH_MALLOC 
11d1						DMARK "mal" 
11d1						CALLMONITOR 
11d1					endif 
11d1 7c			      ld    A, H                    ; Exit if no space requested 
11d2 b5			      or    L 
11d3 ca 92 12		      jp    Z, malloc_early_exit 
11d6			 
11d6			;inc hl 
11d6			;inc hl 
11d6			;inc hl 
11d6			; 
11d6			;inc hl 
11d6			;inc hl 
11d6			;inc hl 
11d6			;inc hl 
11d6			;inc hl 
11d6			;inc hl 
11d6			;inc hl 
11d6			;inc hl 
11d6			;inc hl 
11d6			 
11d6			 
11d6			 
11d6			 
11d6					if DEBUG_FORTH_MALLOC 
11d6						DMARK "maA" 
11d6						CALLMONITOR 
11d6					endif 
11d6			      ; Set up stack frame 
11d6 eb			      ex    DE, HL 
11d7 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
11da 39			      add   HL, SP 
11db f9			      ld    SP, HL 
11dc dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
11e0 dd 39		      add   IX, SP 
11e2			 
11e2			      ; Setup initial state 
11e2 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
11e5 19			      add   HL, DE 
11e6			 
11e6 44			      ld    B, H                    ; Move want to BC 
11e7 4d			      ld    C, L 
11e8			 
11e8 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
11eb dd 75 04		      ld    (IX+4), L 
11ee dd 74 05		      ld    (IX+5), H 
11f1			 
11f1 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
11f2 23			      inc   HL 
11f3 56			      ld    D, (HL) 
11f4 dd 73 02		      ld    (IX+2), E 
11f7 dd 72 03		      ld    (IX+3), D 
11fa eb			      ex    DE, HL                  ; this_free ptr into HL 
11fb			 
11fb					if DEBUG_FORTH_MALLOC 
11fb						DMARK "maB" 
11fb						CALLMONITOR 
11fb					endif 
11fb			      ; Loop through free block list to find some space 
11fb			malloc_find_space: 
11fb 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
11fc 23			      inc   HL 
11fd 56			      ld    D, (HL) 
11fe			 
11fe 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
11ff b3			      or    E 
1200 ca 8c 12		      jp    Z, malloc_no_space 
1203			 
1203 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
1206 dd 72 01		      ld    (IX+1), D 
1209			 
1209			      ; Does this block have enough space to make the allocation? 
1209 23			      inc   HL                      ; Load free block size into DE 
120a 5e			      ld    E, (HL) 
120b 23			      inc   HL 
120c 56			      ld    D, (HL) 
120d			 
120d eb			      ex    DE, HL                  ; Check size of block against want 
120e b7			      or    A                       ; Ensure carry flag clear 
120f ed 42		      sbc   HL, BC 
1211 e5			      push  HL                      ; Store the result for later (new block size) 
1212			 
1212 ca 61 12		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1215 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1217			 
1217			      ; this_free block is not big enough, setup ptrs to test next free block 
1217 e1			      pop   HL                      ; Discard previous result 
1218			 
1218 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
121b dd 66 03		      ld    H, (IX+3) 
121e dd 75 04		      ld    (IX+4), L 
1221 dd 74 05		      ld    (IX+5), H 
1224			 
1224 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1227 dd 66 01		      ld    H, (IX+1) 
122a dd 75 02		      ld    (IX+2), L 
122d dd 74 03		      ld    (IX+3), H 
1230			 
1230					if DEBUG_FORTH_MALLOC 
1230						DMARK "MA>" 
1230						CALLMONITOR 
1230					endif 
1230 18 c9		      jr    malloc_find_space 
1232			 
1232			      ; split a bigger block into two - requested size and remaining size 
1232			malloc_alloc_split: 
1232					if DEBUG_FORTH_MALLOC 
1232						DMARK "MAs" 
1232						CALLMONITOR 
1232					endif 
1232 eb			      ex    DE, HL                  ; Calculate address of new free block 
1233 2b			      dec   HL 
1234 2b			      dec   HL 
1235 2b			      dec   HL 
1236 09			      add   HL, BC 
1237			 
1237			      ; Create a new block and point it at next_free 
1237 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
123a dd 56 01		      ld    D, (IX+1) 
123d			 
123d 73			      ld    (HL), E                 ; Store next_free ptr into new block 
123e 23			      inc   HL 
123f 72			      ld    (HL), D 
1240			 
1240 d1			      pop   DE                      ; Store size of new block into new block 
1241 23			      inc   HL 
1242 73			      ld    (HL), E 
1243 23			      inc   HL 
1244 72			      ld    (HL), D 
1245			 
1245			      ; Update this_free ptr to point to new block 
1245 2b			      dec   HL 
1246 2b			      dec   HL 
1247 2b			      dec   HL 
1248			 
1248 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
124b dd 56 03		      ld    D, (IX+3) 
124e			 
124e dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1251 dd 74 03		      ld    (IX+3), H 
1254			 
1254			      ; Modify this_free block to be allocation 
1254 eb			      ex    DE, HL 
1255 af			      xor   A                       ; Null the next block ptr of allocated block 
1256 77			      ld    (HL), A 
1257 23			      inc   HL 
1258 77			      ld    (HL), A 
1259			 
1259 23			      inc   HL                      ; Store want size into allocated block 
125a 71			      ld    (HL), C 
125b 23			      inc   HL 
125c 70			      ld    (HL), B 
125d 23			      inc   HL 
125e e5			      push  HL                      ; Address of allocation to return 
125f			 
125f 18 19		      jr    malloc_update_links 
1261			 
1261			malloc_alloc_fit: 
1261 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1262			 
1262					if DEBUG_FORTH_MALLOC 
1262						DMARK "MAf" 
1262						CALLMONITOR 
1262					endif 
1262			      ; Modify this_free block to be allocation 
1262 eb			      ex    DE, HL 
1263 2b			      dec   HL 
1264 2b			      dec   HL 
1265 2b			      dec   HL 
1266			 
1266 af			      xor   A                       ; Null the next block ptr of allocated block 
1267 77			      ld    (HL), A 
1268 23			      inc   HL 
1269 77			      ld    (HL), A 
126a			 
126a 23			      inc   HL                      ; Store address of allocation to return 
126b 23			      inc   HL 
126c 23			      inc   HL 
126d e5			      push  HL 
126e			 
126e			      ; Copy next_free ptr to this_free, remove allocated block from free list 
126e dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
1271 dd 66 01		      ld    H, (IX+1) 
1274			 
1274 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1277 dd 74 03		      ld    (IX+3), H 
127a			 
127a			 
127a			malloc_update_links: 
127a			      ; Update prev_free ptr to point to this_free 
127a dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
127d dd 66 05		      ld    H, (IX+5) 
1280			 
1280 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1283 dd 56 03		      ld    D, (IX+3) 
1286			 
1286 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1287 23			      inc   HL 
1288 72			      ld    (HL), D 
1289			 
1289					if DEBUG_FORTH_MALLOC 
1289						DMARK "Mul" 
1289						CALLMONITOR 
1289					endif 
1289			      ; Clear the Z flag to indicate successful allocation 
1289 7a			      ld    A, D 
128a b3			      or    E 
128b			 
128b d1			      pop   DE                      ; Address of allocation 
128c					if DEBUG_FORTH_MALLOC 
128c						DMARK "MAu" 
128c						CALLMONITOR 
128c					endif 
128c			 
128c			malloc_no_space: 
128c 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
128f 39			      add   HL, SP 
1290 f9			      ld    SP, HL 
1291			 
1291 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1292					if DEBUG_FORTH_MALLOC 
1292						DMARK "MAN" 
1292						CALLMONITOR 
1292					endif 
1292			 
1292			malloc_early_exit: 
1292					if DEBUG_FORTH_MALLOC 
1292						DMARK "MAx" 
1292						CALLMONITOR 
1292					endif 
1292 dd e1		      pop   IX 
1294 d1			      pop   DE 
1295 c1			      pop   BC 
1296			 
1296			if DEBUG_FORTH_MALLOC_HIGH 
1296			call malloc_guard_exit 
1296			call malloc_guard_zerolen 
1296			endif 
1296 c9			      ret 
1297			 
1297			 
1297			;------------------------------------------------------------------------------ 
1297			;     free                                                                    : 
1297			;                                                                             : 
1297			; Description                                                                 : 
1297			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1297			;     returned by malloc, otherwise the behaviour is undefined.               : 
1297			;                                                                             : 
1297			;     Where possible, directly adjacent free blocks will be merged together   : 
1297			;     into larger blocks to help ensure that the heap does not become         : 
1297			;     excessively fragmented.                                                 : 
1297			;                                                                             : 
1297			;     free does not clear or set any other value into the freed space, and    : 
1297			;     therefore its contents may be visible through subsequent malloc's. The  : 
1297			;     caller should clear the freed space as required.                        : 
1297			;                                                                             : 
1297			;     This implementation of free uses the stack exclusively, and is          : 
1297			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1297			;     advisable to disable interrupts before calling free, and recommended    : 
1297			;     to avoid the use of free inside ISRs in general.                        : 
1297			;                                                                             : 
1297			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1297			;                                                                             : 
1297			; Parameters                                                                  : 
1297			;     HL  Pointer to address of first byte of allocation to be freed          : 
1297			;                                                                             : 
1297			; Returns                                                                     : 
1297			;     Nothing                                                                 : 
1297			;                                                                             : 
1297			; Stack frame                                                                 : 
1297			;       |             |                                                       : 
1297			;       +-------------+                                                       : 
1297			;       |     BC      |                                                       : 
1297			;       +-------------+                                                       : 
1297			;       |     DE      |                                                       : 
1297			;       +-------------+                                                       : 
1297			;       |     IX      |                                                       : 
1297			;       +-------------+                                                       : 
1297			;       |  prev_free  |                                                       : 
1297			;   +2  +-------------+                                                       : 
1297			;       |  next_free  |                                                       : 
1297			;   +0  +-------------+                                                       : 
1297			;       |             |                                                       : 
1297			;                                                                             : 
1297			;------------------------------------------------------------------------------ 
1297			free: 
1297 c5			      push  BC 
1298 d5			      push  DE 
1299 dd e5		      push  IX 
129b			 
129b 7c			      ld    A, H                    ; Exit if ptr is null 
129c b5			      or    L 
129d ca 61 13		      jp    Z, free_early_exit 
12a0			 
12a0			      ; Set up stack frame 
12a0 eb			      ex    DE, HL 
12a1 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
12a4 39			      add   HL, SP 
12a5 f9			      ld    SP, HL 
12a6 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
12aa dd 39		      add   IX, SP 
12ac			 
12ac			      ; The address in HL points to the start of the useable allocated space, 
12ac			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
12ac			      ; address of the block itself. 
12ac eb			      ex    DE, HL 
12ad 11 fc ff		      ld    DE, -4 
12b0 19			      add   HL, DE 
12b1			 
12b1			      ; An allocated block must have a null next block pointer in it 
12b1 7e			      ld    A, (HL) 
12b2 23			      inc   HL 
12b3 b6			      or    (HL) 
12b4 c2 5c 13		      jp    NZ, free_done 
12b7			 
12b7 2b			      dec   HL 
12b8			 
12b8 44			      ld    B, H                    ; Copy HL to BC 
12b9 4d			      ld    C, L 
12ba			 
12ba			      ; Loop through the free list to find the first block with an address 
12ba			      ; higher than the block being freed 
12ba 21 0a 80		      ld    HL, free_list 
12bd			 
12bd			free_find_higher_block: 
12bd 5e			      ld    E, (HL)                 ; Load next ptr from free block 
12be 23			      inc   HL 
12bf 56			      ld    D, (HL) 
12c0 2b			      dec   HL 
12c1			 
12c1 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
12c4 dd 72 01		      ld    (IX+1), D 
12c7 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
12ca dd 74 03		      ld    (IX+3), H 
12cd			 
12cd 78			      ld    A, B                    ; Check if DE is greater than BC 
12ce ba			      cp    D                       ; Compare MSB first 
12cf 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
12d1 30 04		      jr    NC, free_find_higher_block_skip 
12d3 79			      ld    A, C 
12d4 bb			      cp    E                       ; Then compare LSB 
12d5 38 08		      jr    C, free_found_higher_block 
12d7			 
12d7			free_find_higher_block_skip: 
12d7 7a			      ld    A, D                    ; Reached the end of the free list? 
12d8 b3			      or    E 
12d9 ca 5c 13		      jp    Z, free_done 
12dc			 
12dc eb			      ex    DE, HL 
12dd			 
12dd 18 de		      jr    free_find_higher_block 
12df			 
12df			free_found_higher_block: 
12df			      ; Insert freed block between prev and next free blocks 
12df 71			      ld    (HL), C                 ; Point prev free block to freed block 
12e0 23			      inc   HL 
12e1 70			      ld    (HL), B 
12e2			 
12e2 60			      ld    H, B                    ; Point freed block at next free block 
12e3 69			      ld    L, C 
12e4 73			      ld    (HL), E 
12e5 23			      inc   HL 
12e6 72			      ld    (HL), D 
12e7			 
12e7			      ; Check if the freed block is adjacent to the next free block 
12e7 23			      inc   HL                      ; Load size of freed block into HL 
12e8 5e			      ld    E, (HL) 
12e9 23			      inc   HL 
12ea 56			      ld    D, (HL) 
12eb eb			      ex    DE, HL 
12ec			 
12ec 09			      add   HL, BC                  ; Add addr of freed block and its size 
12ed			 
12ed dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
12f0 dd 56 01		      ld    D, (IX+1) 
12f3			 
12f3 b7			      or    A                       ; Clear the carry flag 
12f4 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
12f6 20 22		      jr    NZ, free_check_adjacent_to_prev 
12f8			 
12f8			      ; Freed block is adjacent to next, merge into one bigger block 
12f8 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
12f9 5e			      ld    E, (HL) 
12fa 23			      inc   HL 
12fb 56			      ld    D, (HL) 
12fc e5			      push  HL                      ; Save ptr to next block for later 
12fd			 
12fd 60			      ld    H, B                    ; Store ptr from next block into freed block 
12fe 69			      ld    L, C 
12ff 73			      ld    (HL), E 
1300 23			      inc   HL 
1301 72			      ld    (HL), D 
1302			 
1302 e1			      pop   HL                      ; Restore ptr to next block 
1303 23			      inc   HL                      ; Load size of next block into DE 
1304 5e			      ld    E, (HL) 
1305 23			      inc   HL 
1306 56			      ld    D, (HL) 
1307 d5			      push  DE                      ; Save next block size for later 
1308			 
1308 60			      ld    H, B                    ; Load size of freed block into HL 
1309 69			      ld    L, C 
130a 23			      inc   HL 
130b 23			      inc   HL 
130c 5e			      ld    E, (HL) 
130d 23			      inc   HL 
130e 56			      ld    D, (HL) 
130f eb			      ex    DE, HL 
1310			 
1310 d1			      pop   DE                      ; Restore size of next block 
1311 19			      add   HL, DE                  ; Add sizes of both blocks 
1312 eb			      ex    DE, HL 
1313			 
1313 60			      ld    H, B                    ; Store new bigger size into freed block 
1314 69			      ld    L, C 
1315 23			      inc   HL 
1316 23			      inc   HL 
1317 73			      ld    (HL), E 
1318 23			      inc   HL 
1319 72			      ld    (HL), D 
131a			 
131a			free_check_adjacent_to_prev: 
131a			      ; Check if the freed block is adjacent to the prev free block 
131a dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
131d dd 66 03		      ld    H, (IX+3) 
1320			 
1320 23			      inc   HL                      ; Size of prev free block into DE 
1321 23			      inc   HL 
1322 5e			      ld    E, (HL) 
1323 23			      inc   HL 
1324 56			      ld    D, (HL) 
1325 2b			      dec   HL 
1326 2b			      dec   HL 
1327 2b			      dec   HL 
1328			 
1328 19			      add   HL, DE                  ; Add prev block addr and size 
1329			 
1329 b7			      or    A                       ; Clear the carry flag 
132a ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
132c 20 2e		      jr    NZ, free_done 
132e			 
132e			      ; Freed block is adjacent to prev, merge into one bigger block 
132e 60			      ld    H, B                    ; Load next ptr from freed block into DE 
132f 69			      ld    L, C 
1330 5e			      ld    E, (HL) 
1331 23			      inc   HL 
1332 56			      ld    D, (HL) 
1333 e5			      push  HL                      ; Save freed block ptr for later 
1334			 
1334 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1337 dd 66 03		      ld    H, (IX+3) 
133a 73			      ld    (HL), E 
133b 23			      inc   HL 
133c 72			      ld    (HL), D 
133d			 
133d e1			      pop   HL                      ; Restore freed block ptr 
133e 23			      inc   HL                      ; Load size of freed block into DE 
133f 5e			      ld    E, (HL) 
1340 23			      inc   HL 
1341 56			      ld    D, (HL) 
1342 d5			      push  DE                      ; Save freed block size for later 
1343			 
1343 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1346 dd 66 03		      ld    H, (IX+3) 
1349 23			      inc   HL 
134a 23			      inc   HL 
134b 5e			      ld    E, (HL) 
134c 23			      inc   HL 
134d 56			      ld    D, (HL) 
134e			 
134e e1			      pop   HL                      ; Add sizes of both blocks 
134f 19			      add   HL, DE 
1350 eb			      ex    DE, HL 
1351			 
1351 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1354 dd 66 03		      ld    H, (IX+3) 
1357 23			      inc   HL 
1358 23			      inc   HL 
1359 73			      ld    (HL), E 
135a 23			      inc   HL 
135b 72			      ld    (HL), D 
135c			 
135c			free_done: 
135c 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
135f 39			      add   HL, SP 
1360 f9			      ld    SP, HL 
1361			 
1361			free_early_exit: 
1361 dd e1		      pop   IX 
1363 d1			      pop   DE 
1364 c1			      pop   BC 
1365			 
1365 c9			      ret 
1366			 
1366			; moved to firmware.asm 
1366			; 
1366			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1366			;                  .dw   0 
1366			 
1366			 
1366			endif 
1366			 
1366			 
1366			if MALLOC_3 
1366			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1366			;heap_start        .equ  0x9000      ; Starting address of heap 
1366			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1366			; 
1366			 ;     .org 0 
1366			  ;    jp    main 
1366			; 
1366			; 
1366			 ;     .org  0x100 
1366			;main: 
1366			 ;     ld    HL, 0x8100 
1366			  ;    ld    SP, HL 
1366			; 
1366			;      call  heap_init 
1366			 
1366			      ; Make some allocations 
1366			;      ld    HL, 12 
1366			;      call  malloc            ; Allocates 0x9004 
1366			; 
1366			 ;     ld    HL, 12 
1366			;      call  malloc            ; Allocates 0x9014 
1366			 
1366			;      ld    HL, 12 
1366			;      call  malloc            ; Allocates 0x9024 
1366			 
1366			      ; Free some allocations 
1366			;      ld    HL, 0x9014 
1366			;      call  free 
1366			 
1366			;      ld    HL, 0x9004 
1366			;      call  free 
1366			; 
1366			;      ld    HL, 0x9024 
1366			;      call  free 
1366			 
1366			 
1366			 ;     halt 
1366			 
1366			 
1366			;------------------------------------------------------------------------------ 
1366			;     heap_init                                                               : 
1366			;                                                                             : 
1366			; Description                                                                 : 
1366			;     Initialise the heap and make it ready for malloc and free operations.   : 
1366			;                                                                             : 
1366			;     The heap is maintained as a linked list, starting with an initial       : 
1366			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1366			;     the first free block in the heap. Each block then points to the next    : 
1366			;     free block within the heap, and the free list ends at the first block   : 
1366			;     with a null pointer to the next free block.                             : 
1366			;                                                                             : 
1366			; Parameters                                                                  : 
1366			;     Inputs are compile-time only. Two defines which specify the starting    : 
1366			;     address of the heap and its size are required, along with a memory      : 
1366			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1366			;     principally stores a pointer to the first free block in the heap.       : 
1366			;                                                                             : 
1366			; Returns                                                                     : 
1366			;     Nothing                                                                 : 
1366			;------------------------------------------------------------------------------ 
1366			heap_init: 
1366			      push  HL 
1366			 
1366			      ; Initialise free list struct 
1366			      ld    HL, heap_start 
1366			      ld    (free_list), HL 
1366			      ld    HL, 0 
1366			      ld    (free_list+2), HL 
1366			 
1366			      ; Insert first free block at bottom of heap, consumes entire heap 
1366			      ld    HL, heap_start+heap_size-4 
1366			      ld    (heap_start), HL        ; Next block (end of free list) 
1366			      ld    HL, heap_size-4 
1366			      ld    (heap_start+2), HL      ; Block size 
1366			 
1366			      ; Insert end of free list block at top of heap - two null words will 
1366			      ; terminate the free list 
1366			      ld    HL, 0 
1366			      ld    (heap_start+heap_size-2), HL 
1366			      ld    (heap_start+heap_size-4), HL 
1366			 
1366			      pop   HL 
1366			 
1366			      ret 
1366			 
1366			 
1366			;------------------------------------------------------------------------------ 
1366			;     malloc                                                                  : 
1366			;                                                                             : 
1366			; Description                                                                 : 
1366			;     Allocates the wanted space from the heap and returns the address of the : 
1366			;     first useable byte of the allocation.                                   : 
1366			;                                                                             : 
1366			;     Allocations can happen in one of two ways:                              : 
1366			;                                                                             : 
1366			;     1. A free block may be found which is the exact size wanted. In this    : 
1366			;        case the block is removed from the free list and retuedn to the      : 
1366			;        caller.                                                              : 
1366			;     2. A free block may be found which is larger than the size wanted. In   : 
1366			;        this case, the larger block is split into two. The first portion of  : 
1366			;        this block will become the requested space by the malloc call and    : 
1366			;        is returned to the caller. The second portion becomes a new free     : 
1366			;        block, and the free list is adjusted to maintain continuity via this : 
1366			;        newly created block.                                                 : 
1366			;                                                                             : 
1366			;     malloc does not set any initial value in the allocated space, the       : 
1366			;     caller is required to do this as required.                              : 
1366			;                                                                             : 
1366			;     This implementation of malloc uses the stack exclusively, and is        : 
1366			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1366			;     advisable to disable interrupts before calling malloc, and recommended  : 
1366			;     to avoid the use of malloc inside ISRs in general.                      : 
1366			;                                                                             : 
1366			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1366			;                                                                             : 
1366			; Parameters                                                                  : 
1366			;     HL  Number of bytes wanted                                              : 
1366			;                                                                             : 
1366			; Returns                                                                     : 
1366			;     HL  Address of the first useable byte of the allocation                 : 
1366			;                                                                             : 
1366			; Flags                                                                       : 
1366			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1366			;                                                                             : 
1366			; Stack frame                                                                 : 
1366			;       |             |                                                       : 
1366			;       +-------------+                                                       : 
1366			;       |     BC      |                                                       : 
1366			;       +-------------+                                                       : 
1366			;       |     DE      |                                                       : 
1366			;       +-------------+                                                       : 
1366			;       |     IX      |                                                       : 
1366			;       +-------------+                                                       : 
1366			;       |  prev_free  |                                                       : 
1366			;   +4  +-------------+                                                       : 
1366			;       |  this_free  |                                                       : 
1366			;   +2  +-------------+                                                       : 
1366			;       |  next_free  |                                                       : 
1366			;   +0  +-------------+                                                       : 
1366			;       |             |                                                       : 
1366			;                                                                             : 
1366			;------------------------------------------------------------------------------ 
1366			malloc: 
1366			      push  BC 
1366			      push  DE 
1366			      push  IX 
1366			 
1366			      ld    A, H                    ; Exit if no space requested 
1366			      or    L 
1366			      jp    Z, malloc_early_exit 
1366			 
1366			      ; Set up stack frame 
1366			      ex    DE, HL 
1366			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1366			      add   HL, SP 
1366			      ld    SP, HL 
1366			      ld    IX, 0                   ; Use IX as a frame pointer 
1366			      add   IX, SP 
1366			 
1366			      ; Setup initial state 
1366			      ld    HL, 4                   ; want must also include space used by block struct 
1366			      add   HL, DE 
1366			 
1366			      ld    B, H                    ; Move want to BC 
1366			      ld    C, L 
1366			 
1366			      ld    HL, free_list           ; Store prev_free ptr to stack 
1366			      ld    (IX+4), L 
1366			      ld    (IX+5), H 
1366			 
1366			      ld    E, (HL)                 ; Store this_free ptr to stack 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      ld    (IX+2), E 
1366			      ld    (IX+3), D 
1366			      ex    DE, HL                  ; this_free ptr into HL 
1366			 
1366			      ; Loop through free block list to find some space 
1366			malloc_find_space: 
1366			      ld    E, (HL)                 ; Load next_free ptr into DE 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			 
1366			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1366			      or    E 
1366			      jp    Z, malloc_no_space 
1366			 
1366			      ld    (IX+0), E               ; Store next_free ptr to stack 
1366			      ld    (IX+1), D 
1366			 
1366			      ; Does this block have enough space to make the allocation? 
1366			      inc   HL                      ; Load free block size into DE 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			 
1366			      ex    DE, HL                  ; Check size of block against want 
1366			      or    A                       ; Ensure carry flag clear 
1366			      sbc   HL, BC 
1366			      push  HL                      ; Store the result for later (new block size) 
1366			 
1366			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1366			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1366			 
1366			      ; this_free block is not big enough, setup ptrs to test next free block 
1366			      pop   HL                      ; Discard previous result 
1366			 
1366			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1366			      ld    H, (IX+3) 
1366			      ld    (IX+4), L 
1366			      ld    (IX+5), H 
1366			 
1366			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1366			      ld    H, (IX+1) 
1366			      ld    (IX+2), L 
1366			      ld    (IX+3), H 
1366			 
1366			      jr    malloc_find_space 
1366			 
1366			      ; split a bigger block into two - requested size and remaining size 
1366			malloc_alloc_split: 
1366			      ex    DE, HL                  ; Calculate address of new free block 
1366			      dec   HL 
1366			      dec   HL 
1366			      dec   HL 
1366			      add   HL, BC 
1366			 
1366			      ; Create a new block and point it at next_free 
1366			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1366			      ld    D, (IX+1) 
1366			 
1366			      ld    (HL), E                 ; Store next_free ptr into new block 
1366			      inc   HL 
1366			      ld    (HL), D 
1366			 
1366			      pop   DE                      ; Store size of new block into new block 
1366			      inc   HL 
1366			      ld    (HL), E 
1366			      inc   HL 
1366			      ld    (HL), D 
1366			 
1366			      ; Update this_free ptr to point to new block 
1366			      dec   HL 
1366			      dec   HL 
1366			      dec   HL 
1366			 
1366			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1366			      ld    D, (IX+3) 
1366			 
1366			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1366			      ld    (IX+3), H 
1366			 
1366			      ; Modify this_free block to be allocation 
1366			      ex    DE, HL 
1366			      xor   A                       ; Null the next block ptr of allocated block 
1366			      ld    (HL), A 
1366			      inc   HL 
1366			      ld    (HL), A 
1366			 
1366			      inc   HL                      ; Store want size into allocated block 
1366			      ld    (HL), C 
1366			      inc   HL 
1366			      ld    (HL), B 
1366			      inc   HL 
1366			      push  HL                      ; Address of allocation to return 
1366			 
1366			      jr    malloc_update_links 
1366			 
1366			malloc_alloc_fit: 
1366			      pop   HL                      ; Dont need new block size, want is exact fit 
1366			 
1366			      ; Modify this_free block to be allocation 
1366			      ex    DE, HL 
1366			      dec   HL 
1366			      dec   HL 
1366			      dec   HL 
1366			 
1366			      xor   A                       ; Null the next block ptr of allocated block 
1366			      ld    (HL), A 
1366			      inc   HL 
1366			      ld    (HL), A 
1366			 
1366			      inc   HL                      ; Store address of allocation to return 
1366			      inc   HL 
1366			      inc   HL 
1366			      push  HL 
1366			 
1366			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1366			      ld    L, (IX+0)               ; next_free to HL 
1366			      ld    H, (IX+1) 
1366			 
1366			      ld    (IX+2), L               ; HL to this_free 
1366			      ld    (IX+3), H 
1366			 
1366			 
1366			malloc_update_links: 
1366			      ; Update prev_free ptr to point to this_free 
1366			      ld    L, (IX+4)               ; prev_free ptr to HL 
1366			      ld    H, (IX+5) 
1366			 
1366			      ld    E, (IX+2)               ; this_free ptr to DE 
1366			      ld    D, (IX+3) 
1366			 
1366			      ld    (HL), E                 ; this_free ptr into prev_free 
1366			      inc   HL 
1366			      ld    (HL), D 
1366			 
1366			      ; Clear the Z flag to indicate successful allocation 
1366			      ld    A, D 
1366			      or    E 
1366			 
1366			      pop   DE                      ; Address of allocation 
1366			 
1366			malloc_no_space: 
1366			      ld    HL, 6                   ; Clean up stack frame 
1366			      add   HL, SP 
1366			      ld    SP, HL 
1366			 
1366			      ex    DE, HL                  ; Alloc addr into HL for return 
1366			 
1366			malloc_early_exit: 
1366			      pop   IX 
1366			      pop   DE 
1366			      pop   BC 
1366			 
1366			      ret 
1366			 
1366			 
1366			;------------------------------------------------------------------------------ 
1366			;     free                                                                    : 
1366			;                                                                             : 
1366			; Description                                                                 : 
1366			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1366			;     returned by malloc, otherwise the behaviour is undefined.               : 
1366			;                                                                             : 
1366			;     Where possible, directly adjacent free blocks will be merged together   : 
1366			;     into larger blocks to help ensure that the heap does not become         : 
1366			;     excessively fragmented.                                                 : 
1366			;                                                                             : 
1366			;     free does not clear or set any other value into the freed space, and    : 
1366			;     therefore its contents may be visible through subsequent malloc's. The  : 
1366			;     caller should clear the freed space as required.                        : 
1366			;                                                                             : 
1366			;     This implementation of free uses the stack exclusively, and is          : 
1366			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1366			;     advisable to disable interrupts before calling free, and recommended    : 
1366			;     to avoid the use of free inside ISRs in general.                        : 
1366			;                                                                             : 
1366			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1366			;                                                                             : 
1366			; Parameters                                                                  : 
1366			;     HL  Pointer to address of first byte of allocation to be freed          : 
1366			;                                                                             : 
1366			; Returns                                                                     : 
1366			;     Nothing                                                                 : 
1366			;                                                                             : 
1366			; Stack frame                                                                 : 
1366			;       |             |                                                       : 
1366			;       +-------------+                                                       : 
1366			;       |     BC      |                                                       : 
1366			;       +-------------+                                                       : 
1366			;       |     DE      |                                                       : 
1366			;       +-------------+                                                       : 
1366			;       |     IX      |                                                       : 
1366			;       +-------------+                                                       : 
1366			;       |  prev_free  |                                                       : 
1366			;   +2  +-------------+                                                       : 
1366			;       |  next_free  |                                                       : 
1366			;   +0  +-------------+                                                       : 
1366			;       |             |                                                       : 
1366			;                                                                             : 
1366			;------------------------------------------------------------------------------ 
1366			free: 
1366			      push  BC 
1366			      push  DE 
1366			      push  IX 
1366			 
1366			      ld    A, H                    ; Exit if ptr is null 
1366			      or    L 
1366			      jp    Z, free_early_exit 
1366			 
1366			      ; Set up stack frame 
1366			      ex    DE, HL 
1366			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1366			      add   HL, SP 
1366			      ld    SP, HL 
1366			      ld    IX, 0                   ; Use IX as a frame pointer 
1366			      add   IX, SP 
1366			 
1366			      ; The address in HL points to the start of the useable allocated space, 
1366			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1366			      ; address of the block itself. 
1366			      ex    DE, HL 
1366			      ld    DE, -4 
1366			      add   HL, DE 
1366			 
1366			      ; An allocated block must have a null next block pointer in it 
1366			      ld    A, (HL) 
1366			      inc   HL 
1366			      or    (HL) 
1366			      jp    NZ, free_done 
1366			 
1366			      dec   HL 
1366			 
1366			      ld    B, H                    ; Copy HL to BC 
1366			      ld    C, L 
1366			 
1366			      ; Loop through the free list to find the first block with an address 
1366			      ; higher than the block being freed 
1366			      ld    HL, free_list 
1366			 
1366			free_find_higher_block: 
1366			      ld    E, (HL)                 ; Load next ptr from free block 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      dec   HL 
1366			 
1366			      ld    (IX+0), E               ; Save ptr to next free block 
1366			      ld    (IX+1), D 
1366			      ld    (IX+2), L               ; Save ptr to prev free block 
1366			      ld    (IX+3), H 
1366			 
1366			      ld    A, B                    ; Check if DE is greater than BC 
1366			      cp    D                       ; Compare MSB first 
1366			      jr    Z, $+4                  ; MSB the same, compare LSB 
1366			      jr    NC, free_find_higher_block_skip 
1366			      ld    A, C 
1366			      cp    E                       ; Then compare LSB 
1366			      jr    C, free_found_higher_block 
1366			 
1366			free_find_higher_block_skip: 
1366			      ld    A, D                    ; Reached the end of the free list? 
1366			      or    E 
1366			      jp    Z, free_done 
1366			 
1366			      ex    DE, HL 
1366			 
1366			      jr    free_find_higher_block 
1366			 
1366			free_found_higher_block: 
1366			      ; Insert freed block between prev and next free blocks 
1366			      ld    (HL), C                 ; Point prev free block to freed block 
1366			      inc   HL 
1366			      ld    (HL), B 
1366			 
1366			      ld    H, B                    ; Point freed block at next free block 
1366			      ld    L, C 
1366			      ld    (HL), E 
1366			      inc   HL 
1366			      ld    (HL), D 
1366			 
1366			      ; Check if the freed block is adjacent to the next free block 
1366			      inc   HL                      ; Load size of freed block into HL 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      ex    DE, HL 
1366			 
1366			      add   HL, BC                  ; Add addr of freed block and its size 
1366			 
1366			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1366			      ld    D, (IX+1) 
1366			 
1366			      or    A                       ; Clear the carry flag 
1366			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1366			      jr    NZ, free_check_adjacent_to_prev 
1366			 
1366			      ; Freed block is adjacent to next, merge into one bigger block 
1366			      ex    DE, HL                  ; Load next ptr from next block into DE 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      push  HL                      ; Save ptr to next block for later 
1366			 
1366			      ld    H, B                    ; Store ptr from next block into freed block 
1366			      ld    L, C 
1366			      ld    (HL), E 
1366			      inc   HL 
1366			      ld    (HL), D 
1366			 
1366			      pop   HL                      ; Restore ptr to next block 
1366			      inc   HL                      ; Load size of next block into DE 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      push  DE                      ; Save next block size for later 
1366			 
1366			      ld    H, B                    ; Load size of freed block into HL 
1366			      ld    L, C 
1366			      inc   HL 
1366			      inc   HL 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      ex    DE, HL 
1366			 
1366			      pop   DE                      ; Restore size of next block 
1366			      add   HL, DE                  ; Add sizes of both blocks 
1366			      ex    DE, HL 
1366			 
1366			      ld    H, B                    ; Store new bigger size into freed block 
1366			      ld    L, C 
1366			      inc   HL 
1366			      inc   HL 
1366			      ld    (HL), E 
1366			      inc   HL 
1366			      ld    (HL), D 
1366			 
1366			free_check_adjacent_to_prev: 
1366			      ; Check if the freed block is adjacent to the prev free block 
1366			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1366			      ld    H, (IX+3) 
1366			 
1366			      inc   HL                      ; Size of prev free block into DE 
1366			      inc   HL 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      dec   HL 
1366			      dec   HL 
1366			      dec   HL 
1366			 
1366			      add   HL, DE                  ; Add prev block addr and size 
1366			 
1366			      or    A                       ; Clear the carry flag 
1366			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1366			      jr    NZ, free_done 
1366			 
1366			      ; Freed block is adjacent to prev, merge into one bigger block 
1366			      ld    H, B                    ; Load next ptr from freed block into DE 
1366			      ld    L, C 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      push  HL                      ; Save freed block ptr for later 
1366			 
1366			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1366			      ld    H, (IX+3) 
1366			      ld    (HL), E 
1366			      inc   HL 
1366			      ld    (HL), D 
1366			 
1366			      pop   HL                      ; Restore freed block ptr 
1366			      inc   HL                      ; Load size of freed block into DE 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      push  DE                      ; Save freed block size for later 
1366			 
1366			      ld    L, (IX+2)               ; Load size of prev block into DE 
1366			      ld    H, (IX+3) 
1366			      inc   HL 
1366			      inc   HL 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			 
1366			      pop   HL                      ; Add sizes of both blocks 
1366			      add   HL, DE 
1366			      ex    DE, HL 
1366			 
1366			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1366			      ld    H, (IX+3) 
1366			      inc   HL 
1366			      inc   HL 
1366			      ld    (HL), E 
1366			      inc   HL 
1366			      ld    (HL), D 
1366			 
1366			free_done: 
1366			      ld    HL, 4                   ; Clean up stack frame 
1366			      add   HL, SP 
1366			      ld    SP, HL 
1366			 
1366			free_early_exit: 
1366			      pop   IX 
1366			      pop   DE 
1366			      pop   BC 
1366			 
1366			      ret 
1366			 
1366			 
1366			;      .org 0x8000 
1366			; 
1366			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1366			 ;                 .dw   0 
1366			 
1366			endif 
1366			 
1366			 
1366			if MALLOC_4 
1366			 
1366			; My memory allocation code. Very very simple.... 
1366			; allocate space under 250 chars 
1366			 
1366			heap_init: 
1366				; init start of heap as zero 
1366				;  
1366			 
1366				ld hl, heap_start 
1366				ld a, 0 
1366				ld (hl), a      ; empty block 
1366				inc hl 
1366				ld a, 0 
1366				ld (hl), a      ; length of block 
1366				; write end of list 
1366				inc hl 
1366				ld a,(hl) 
1366				inc hl 
1366				ld a,(hl) 
1366				 
1366			 
1366				; init some malloc vars 
1366			 
1366				ld hl, 0 
1366				ld (free_list), hl       ; store last malloc location 
1366			 
1366				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1366				ld a, 0 
1366				ld (hl), a 
1366			 
1366			 
1366				ld hl, heap_start 
1366				;  
1366				  
1366				ret 
1366			 
1366			 
1366			;    free block marker 
1366			;    requested size  
1366			;    pointer to next block 
1366			;    .... 
1366			;    next block marker 
1366			 
1366			 
1366			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1366			; 
1366			 
1366			 
1366			malloc:  
1366				push de 
1366				push bc 
1366				push af 
1366			 
1366				; hl space required 
1366				 
1366				ld c, l    ; hold space   (TODO only a max of 255) 
1366			 
1366			;	inc c     ; TODO BUG need to fix memory leak on push str 
1366			;	inc c 
1366			;	inc c 
1366			;	inc c 
1366			;	inc c 
1366			;	inc c 
1366			;	inc c 
1366			 
1366			 
1366			 
1366				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1366			 
1366				ld a, (free_list+3) 
1366				cp 0 
1366				jr z, .contheap 
1366			 
1366				ld hl, (free_list)     ; get last alloc 
1366					if DEBUG_FORTH_MALLOC_INT 
1366						DMARK "mrs" 
1366						CALLMONITOR 
1366					endif 
1366				jr .startalloc 
1366			 
1366			.contheap: 
1366				ld hl, heap_start 
1366			 
1366			.startalloc: 
1366			 
1366					if DEBUG_FORTH_MALLOC_INT 
1366						DMARK "mym" 
1366						CALLMONITOR 
1366					endif 
1366			.findblock: 
1366					if DEBUG_FORTH_MALLOC_INT 
1366						DMARK "mmf" 
1366						CALLMONITOR 
1366					endif 
1366			 
1366				ld a,(hl)  
1366				; if byte is zero then clear to use 
1366			 
1366				cp 0 
1366				jr z, .foundemptyblock 
1366			 
1366				; if byte is not clear 
1366				;     then byte is offset to next block 
1366			 
1366				inc hl 
1366				ld a, (hl) ; get size 
1366			.nextblock:	inc hl 
1366					ld e, (hl) 
1366					inc hl 
1366					ld d, (hl) 
1366					ex de, hl 
1366			;	inc hl  ; move past the store space 
1366			;	inc hl  ; move past zero index  
1366			 
1366				; TODO detect no more space 
1366			 
1366				push hl 
1366				ld de, heap_end 
1366				call cmp16 
1366				pop hl 
1366				jr nc, .nospace 
1366			 
1366				jr .findblock 
1366			 
1366			.nospace: ld hl, 0 
1366				jp .exit 
1366			 
1366			 
1366			.foundemptyblock:	 
1366					if DEBUG_FORTH_MALLOC_INT 
1366						DMARK "mme" 
1366						CALLMONITOR 
1366					endif 
1366			 
1366			; TODO has block enough space if reusing??? 
1366			 
1366				;  
1366			 
1366			; see if this block has been previously used 
1366				inc hl 
1366				ld a, (hl) 
1366				dec hl 
1366				cp 0 
1366				jr z, .newblock 
1366			 
1366					if DEBUG_FORTH_MALLOC_INT 
1366						DMARK "meR" 
1366						CALLMONITOR 
1366					endif 
1366			 
1366			; no reusing previously allocated block 
1366			 
1366			; is it smaller than previously used? 
1366				 
1366				inc hl    ; move to size 
1366				ld a, c 
1366				sub (hl)        ; we want c < (hl) 
1366				dec hl    ; move back to marker 
1366			        jr z, .findblock 
1366			 
1366				; update with the new size which should be lower 
1366			 
1366			        ;inc  hl   ; negate next move. move back to size  
1366			 
1366			.newblock: 
1366				; need to be at marker here 
1366			 
1366					if DEBUG_FORTH_MALLOC_INT 
1366						DMARK "meN" 
1366						CALLMONITOR 
1366					endif 
1366			 
1366			 
1366				ld a, c 
1366			 
1366				ld (free_list+3), a	 ; flag resume from last malloc  
1366				ld (free_list), hl    ; save out last location 
1366			 
1366			 
1366				;inc a     ; space for length byte 
1366				ld (hl), a     ; save block in use marker 
1366			 
1366				inc hl   ; move to space marker 
1366				ld (hl), a    ; save new space 
1366			 
1366				inc hl   ; move to start of allocated area 
1366				 
1366			;	push hl     ; save where we are - 1  
1366			 
1366			;	inc hl  ; move past zero index  
1366				; skip space to set down new marker 
1366			 
1366				; provide some extra space for now 
1366			 
1366				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1366				inc a 
1366				inc a 
1366			 
1366				push hl   ; save where we are in the node block 
1366			 
1366				call addatohl 
1366			 
1366				; write linked list point 
1366			 
1366				pop de     ; get our node position 
1366				ex de, hl 
1366			 
1366				ld (hl), e 
1366				inc hl 
1366				ld (hl), d 
1366			 
1366				inc hl 
1366			 
1366				; now at start of allocated data so save pointer 
1366			 
1366				push hl 
1366			 
1366				; jump to position of next node and setup empty header in DE 
1366			 
1366				ex de, hl 
1366			 
1366			;	inc hl ; move past end of block 
1366			 
1366				ld a, 0 
1366				ld (hl), a   ; empty marker 
1366				inc hl 
1366				ld (hl), a   ; size 
1366				inc hl  
1366				ld (hl), a   ; ptr 
1366				inc hl 
1366				ld (hl), a   ; ptr 
1366			 
1366			 
1366				pop hl 
1366			 
1366					if DEBUG_FORTH_MALLOC_INT 
1366						DMARK "mmr" 
1366						CALLMONITOR 
1366					endif 
1366			 
1366			.exit: 
1366				pop af 
1366				pop bc 
1366				pop de  
1366				ret 
1366			 
1366			 
1366			 
1366			 
1366			free:  
1366				push hl 
1366				push af 
1366				; get address in hl 
1366			 
1366					if DEBUG_FORTH_MALLOC_INT 
1366						DMARK "fre" 
1366						CALLMONITOR 
1366					endif 
1366				; data is at hl - move to block count 
1366				dec hl 
1366				dec hl    ; get past pointer 
1366				dec hl 
1366			 
1366				ld a, (hl)    ; need this for a validation check 
1366			 
1366				dec hl    ; move to block marker 
1366			 
1366				; now check that the block count and block marker are the same  
1366			        ; this checks that we are on a malloc node and not random memory 
1366			        ; OK a faint chance this could be a problem but rare - famous last words! 
1366			 
1366				ld c, a 
1366				ld a, (hl)    
1366			 
1366				cp c 
1366				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1366			 
1366				; yes good chance we are on a malloc node 
1366			 
1366				ld a, 0      
1366				ld (hl), a   ; mark as free 
1366			 
1366				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1366			 
1366			.freeignore:  
1366			 
1366				pop af 
1366				pop hl 
1366			 
1366				ret 
1366			 
1366			 
1366			 
1366			endif 
1366			 
1366			; eof 
# End of file firmware_memory.asm
1366			  
1366			; device C  
1366			if SOUND_ENABLE  
1366				include "firmware_sound.asm"  
1366			endif  
1366			  
1366			include "firmware_diags.asm"  
1366			; Hardware diags menu 
1366			 
1366			 
1366			config: 
1366			 
1366 3e 00			ld a, 0 
1368 21 91 13			ld hl, .configmn 
136b cd 03 0b			call menu 
136e			 
136e fe 00			cp 0 
1370 c8				ret z 
1371			 
1371 fe 01			cp 1 
1373 cc d3 14			call z, .savetostore 
1376			 
1376 fe 02			cp 2 
1378 cc 21 14			call z, .selautoload 
137b fe 03			cp 3 
137d cc d1 14			call z, .selbank 
1380 fe 05			cp 5 
1382 cc ae 15			call z, .debug_tog 
1385 fe 06			cp 6 
1387 cc f6 16			call z, .bpsgo 
138a fe 07			cp 7 
138c cc d4 15			call z, hardware_diags 
138f			 
138f 18 d5			jr config 
1391			 
1391			.configmn: 
1391 a1 13			dw .c3 
1393 bd 13			dw .c2 
1395 d2 13			dw .c2b 
1397 e6 13			dw .c4 
1399 ef 13			dw .m4 
139b 0a 14			dw .m4b 
139d 12 14			dw .c1 
139f 00 00			dw 0 
13a1				 
13a1			 
13a1 .. 00		.c3: db "Add User Dictionary To File",0 
13bd .. 00		.c2: db "Select Autoload File",0 
13d2 .. 00		.c2b: db "Select Storage Bank",0 
13e6 .. 00		.c4: db "Settings",0 
13ef .. 00		.m4:   db "Debug & Breakpoints On/Off",0 
140a .. 00		.m4b:   db "Monitor",0 
1412 .. 00		.c1: db "Hardware Diags",0 
1421			 
1421			 
1421			 
1421			; Select auto start 
1421			 
1421			.selautoload: 
1421			 
1421				 
1421				if STORAGE_SE 
1421			 
1421 cd f8 14				call config_dir 
1424 21 a3 ef			        ld hl, scratch 
1427 3e 00				ld a, 0 
1429 cd 03 0b				call menu 
142c			 
142c fe 00				cp 0 
142e c8					ret z 
142f			 
142f 3d					dec a 
1430			 
1430			 
1430					; locate menu option 
1430			 
1430 21 a3 ef				ld hl, scratch 
1433 cd 2a 0a				call table_lookup 
1436			 
1436					if DEBUG_FORTH_WORDS 
1436						DMARK "ALl" 
1436 f5				push af  
1437 3a 4b 14			ld a, (.dmark)  
143a 32 bd fb			ld (debug_mark),a  
143d 3a 4c 14			ld a, (.dmark+1)  
1440 32 be fb			ld (debug_mark+1),a  
1443 3a 4d 14			ld a, (.dmark+2)  
1446 32 bf fb			ld (debug_mark+2),a  
1449 18 03			jr .pastdmark  
144b ..			.dmark: db "ALl"  
144e f1			.pastdmark: pop af  
144f			endm  
# End of macro DMARK
144f						CALLMONITOR 
144f cd ec 16			call break_point_state  
1452				endm  
# End of macro CALLMONITOR
1452					endif 
1452					; with the pointer to the menu it, the byte following the zero term is the file id 
1452			 
1452 3e 00				ld a, 0 
1454 01 32 00				ld bc, 50   ; max of bytes to look at 
1457 ed b1				cpir  
1459			 
1459					if DEBUG_FORTH_WORDS 
1459						DMARK "ALb" 
1459 f5				push af  
145a 3a 6e 14			ld a, (.dmark)  
145d 32 bd fb			ld (debug_mark),a  
1460 3a 6f 14			ld a, (.dmark+1)  
1463 32 be fb			ld (debug_mark+1),a  
1466 3a 70 14			ld a, (.dmark+2)  
1469 32 bf fb			ld (debug_mark+2),a  
146c 18 03			jr .pastdmark  
146e ..			.dmark: db "ALb"  
1471 f1			.pastdmark: pop af  
1472			endm  
# End of macro DMARK
1472						CALLMONITOR 
1472 cd ec 16			call break_point_state  
1475				endm  
# End of macro CALLMONITOR
1475					endif 
1475					;inc hl 
1475			 
1475 7e					ld a, (hl)   ; file id 
1476					 
1476				        ; save bank and file ids 
1476			 
1476 f5					push af 
1477			 
1477			; TODO need to save to block 0 on bank 1	 
1477			 
1477 cd ba 03				call storage_get_block_0 
147a			 
147a					if DEBUG_FORTH_WORDS 
147a						DMARK "AL0" 
147a f5				push af  
147b 3a 8f 14			ld a, (.dmark)  
147e 32 bd fb			ld (debug_mark),a  
1481 3a 90 14			ld a, (.dmark+1)  
1484 32 be fb			ld (debug_mark+1),a  
1487 3a 91 14			ld a, (.dmark+2)  
148a 32 bf fb			ld (debug_mark+2),a  
148d 18 03			jr .pastdmark  
148f ..			.dmark: db "AL0"  
1492 f1			.pastdmark: pop af  
1493			endm  
# End of macro DMARK
1493						CALLMONITOR 
1493 cd ec 16			call break_point_state  
1496				endm  
# End of macro CALLMONITOR
1496					endif 
1496 f1					pop af 
1497			 
1497 32 0c fa				ld (store_page+STORE_0_FILERUN),a 
149a					 
149a					; save bank id 
149a			 
149a 3a ce f9				ld a,(spi_device) 
149d 32 0b fa				ld (store_page+STORE_0_BANKRUN),a 
14a0			 
14a0					; enable auto run of store file 
14a0			 
14a0 3e 01				ld a, 1 
14a2 32 09 fa				ld (store_page+STORE_0_AUTOFILE),a 
14a5			 
14a5					; save buffer 
14a5			 
14a5 21 00 00				ld hl, 0 
14a8 11 e8 f9				ld de, store_page 
14ab					if DEBUG_FORTH_WORDS 
14ab						DMARK "ALw" 
14ab f5				push af  
14ac 3a c0 14			ld a, (.dmark)  
14af 32 bd fb			ld (debug_mark),a  
14b2 3a c1 14			ld a, (.dmark+1)  
14b5 32 be fb			ld (debug_mark+1),a  
14b8 3a c2 14			ld a, (.dmark+2)  
14bb 32 bf fb			ld (debug_mark+2),a  
14be 18 03			jr .pastdmark  
14c0 ..			.dmark: db "ALw"  
14c3 f1			.pastdmark: pop af  
14c4			endm  
# End of macro DMARK
14c4						CALLMONITOR 
14c4 cd ec 16			call break_point_state  
14c7				endm  
# End of macro CALLMONITOR
14c7					endif 
14c7 cd 6e 03			call storage_write_block	 ; save update 
14ca			  
14ca			 
14ca			 
14ca			 
14ca 21 a3 ef				ld hl, scratch 
14cd cd e5 14				call config_fdir 
14d0			 
14d0			 
14d0				endif 
14d0 c9				ret 
14d1			 
14d1			 
14d1			 
14d1			; Select storage bank 
14d1			 
14d1			.selbank: 
14d1			 
14d1				if STORAGE_SE 
14d1				endif 
14d1				 
14d1 c9				ret 
14d2			 
14d2			if STORAGE_SE 
14d2			 
14d2			.config_ldir:   
14d2				; Load storage bank labels into menu array 
14d2			 
14d2				 
14d2			 
14d2			 
14d2 c9				ret 
14d3			 
14d3			 
14d3			endif 
14d3			 
14d3			 
14d3			; Save user words to storage 
14d3			 
14d3			.savetostore: 
14d3			 
14d3				if STORAGE_SE 
14d3			 
14d3 cd f8 14				call config_dir 
14d6 21 a3 ef			        ld hl, scratch 
14d9 3e 00				ld a, 0 
14db cd 03 0b				call menu 
14de					 
14de 21 a3 ef				ld hl, scratch 
14e1 cd e5 14				call config_fdir 
14e4			 
14e4			 
14e4				endif 
14e4			 
14e4 c9				ret 
14e5			 
14e5			 
14e5			 
14e5			if STORAGE_SE 
14e5			 
14e5			config_fdir: 
14e5				; using the scratch dir go through and release the memory allocated for each string 
14e5				 
14e5 21 a3 ef			ld hl, scratch 
14e8 5e			.cfdir:	ld e,(hl) 
14e9 23				inc hl 
14ea 56				ld d,(hl) 
14eb 23				inc hl 
14ec			 
14ec eb				ex de, hl 
14ed cd 2f 0d			call ishlzero 
14f0 c8				ret z     ; return on null pointer 
14f1 cd 97 12			call free 
14f4 eb				ex de, hl 
14f5 18 f1			jr .cfdir 
14f7			 
14f7			 
14f7 c9				ret 
14f8			 
14f8			 
14f8			config_dir: 
14f8			 
14f8				; for the config menus that need to build a directory of storage call this routine 
14f8				; it will construct a menu in scratch to pass to menu 
14f8			 
14f8				; open storage device 
14f8			 
14f8				; execute DIR to build a list of files and their ids into scratch in menu format 
14f8				; once the menu has finished then will need to call config_fdir to release the strings 
14f8				 
14f8				; c = number items 
14f8			 
14f8				 
14f8 cd ba 03			call storage_get_block_0 
14fb			 
14fb 21 e8 f9			ld hl, store_page     ; get current id count 
14fe 46				ld b, (hl) 
14ff 0e 00			ld c, 0    ; count of files   
1501			 
1501			 
1501 21 a3 ef			ld hl, scratch 
1504 22 e4 f9			ld (store_tmp2), hl    ; location to poke strings 
1507			 
1507				; check for empty drive 
1507			 
1507 3e 00			ld a, 0 
1509 b8				cp b 
150a ca a4 15			jp z, .dirdone 
150d			 
150d				 
150d					if DEBUG_FORTH_WORDS 
150d						DMARK "Cdc" 
150d f5				push af  
150e 3a 22 15			ld a, (.dmark)  
1511 32 bd fb			ld (debug_mark),a  
1514 3a 23 15			ld a, (.dmark+1)  
1517 32 be fb			ld (debug_mark+1),a  
151a 3a 24 15			ld a, (.dmark+2)  
151d 32 bf fb			ld (debug_mark+2),a  
1520 18 03			jr .pastdmark  
1522 ..			.dmark: db "Cdc"  
1525 f1			.pastdmark: pop af  
1526			endm  
# End of macro DMARK
1526						CALLMONITOR 
1526 cd ec 16			call break_point_state  
1529				endm  
# End of macro CALLMONITOR
1529					endif 
1529			 
1529			 
1529			.diritem:	 
1529 c5				push bc 
152a				; for each of the current ids do a search for them and if found push to stack 
152a			 
152a 21 40 00				ld hl, STORE_BLOCK_PHY 
152d 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
152f 58					ld e,b 
1530			 
1530 cd 2a 06				call storage_findnextid 
1533			 
1533			 
1533					; if found hl will be non zero 
1533			 
1533 cd 2f 0d				call ishlzero 
1536 28 69				jr z, .dirnotfound 
1538			 
1538					; increase count 
1538			 
1538 c1					pop bc	 
1539 0c					inc c 
153a c5					push bc 
153b					 
153b			 
153b					; get file header and push the file name 
153b			 
153b 11 e8 f9				ld de, store_page 
153e cd 09 03				call storage_read_block 
1541			 
1541					; push file id to stack 
1541				 
1541 3a e8 f9				ld a, (store_page) 
1544 26 00				ld h, 0 
1546 6f					ld l, a 
1547			 
1547					;call forth_push_numhl 
1547					; TODO store id 
1547			 
1547 e5					push hl 
1548			 
1548					; push extent count to stack  
1548				 
1548 21 eb f9				ld hl, store_page+3 
154b			 
154b					; get file name length 
154b			 
154b cd 64 11				call strlenz   
154e			 
154e 23					inc hl   ; cover zero term 
154f 23					inc hl  ; stick the id at the end of the area 
1550			 
1550 e5					push hl 
1551 c1					pop bc    ; move length to bc 
1552			 
1552 cd cd 11				call malloc 
1555			 
1555					; TODO save malloc area to scratch 
1555			 
1555 eb					ex de, hl 
1556 2a e4 f9				ld hl, (store_tmp2) 
1559 73					ld (hl), e 
155a 23					inc hl 
155b 72					ld (hl), d 
155c 23					inc hl 
155d 22 e4 f9				ld (store_tmp2), hl 
1560			 
1560					 
1560			 
1560					;pop hl   ; get source 
1560			;		ex de, hl    ; swap aronund	 
1560			 
1560 21 eb f9				ld hl, store_page+3 
1563					if DEBUG_FORTH_WORDS 
1563						DMARK "CFd" 
1563 f5				push af  
1564 3a 78 15			ld a, (.dmark)  
1567 32 bd fb			ld (debug_mark),a  
156a 3a 79 15			ld a, (.dmark+1)  
156d 32 be fb			ld (debug_mark+1),a  
1570 3a 7a 15			ld a, (.dmark+2)  
1573 32 bf fb			ld (debug_mark+2),a  
1576 18 03			jr .pastdmark  
1578 ..			.dmark: db "CFd"  
157b f1			.pastdmark: pop af  
157c			endm  
# End of macro DMARK
157c						CALLMONITOR 
157c cd ec 16			call break_point_state  
157f				endm  
# End of macro CALLMONITOR
157f					endif 
157f ed b0				ldir 
1581			 
1581					; de is past string, move back one and store id 
1581					 
1581 1b					dec de 
1582			 
1582					; store file id 
1582			 
1582 e1					pop hl 
1583 eb					ex de,hl 
1584 73					ld (hl), e 
1585			 
1585					if DEBUG_FORTH_WORDS 
1585						DMARK "Cdi" 
1585 f5				push af  
1586 3a 9a 15			ld a, (.dmark)  
1589 32 bd fb			ld (debug_mark),a  
158c 3a 9b 15			ld a, (.dmark+1)  
158f 32 be fb			ld (debug_mark+1),a  
1592 3a 9c 15			ld a, (.dmark+2)  
1595 32 bf fb			ld (debug_mark+2),a  
1598 18 03			jr .pastdmark  
159a ..			.dmark: db "Cdi"  
159d f1			.pastdmark: pop af  
159e			endm  
# End of macro DMARK
159e						CALLMONITOR 
159e cd ec 16			call break_point_state  
15a1				endm  
# End of macro CALLMONITOR
15a1					endif 
15a1					 
15a1			.dirnotfound: 
15a1 c1					pop bc     
15a2 10 85				djnz .diritem 
15a4				 
15a4			.dirdone:	 
15a4			 
15a4 3e 00				ld a, 0 
15a6 2a e4 f9				ld hl, (store_tmp2) 
15a9 77					ld (hl), a 
15aa 23					inc hl 
15ab 77					ld (hl), a 
15ac 23					inc hl 
15ad					; push a count of the dir items found 
15ad			 
15ad			;		ld h, 0 
15ad			;		ld l, c 
15ad			 
15ad c9				ret 
15ae			 
15ae			endif 
15ae			 
15ae			 
15ae			; Settings 
15ae			; Run  
15ae			 
15ae			 
15ae			 
15ae			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
15ae			;;hd_menu2:   db "        2: Editor",0   
15ae			;hd_menu2:   db "        2: Editor       6: Menu",0   
15ae			;hd_menu3:   db "        3: Storage",0 
15ae			;hd_menu4:   db "0=quit  4: Debug",0 
15ae			;hd_don:     db "ON",0 
15ae			;hd_doff:     db "OFF",0 
15ae			; 
15ae			; 
15ae			; 
15ae			;hardware_diags_old:       
15ae			; 
15ae			;.diagmenu: 
15ae			;	call clear_display 
15ae			;	ld a, display_row_1 
15ae			;	ld de, hd_menu1 
15ae			;	call str_at_display 
15ae			; 
15ae			;	ld a, display_row_2 
15ae			;	ld de, hd_menu2 
15ae			;	call str_at_display 
15ae			; 
15ae			;	ld a, display_row_3 
15ae			;	ld de, hd_menu3 
15ae			;	call str_at_display 
15ae			; 
15ae			;	ld a,  display_row_4 
15ae			;	ld de, hd_menu4 
15ae			;	call str_at_display 
15ae			; 
15ae			;	; display debug state 
15ae			; 
15ae			;	ld de, hd_don 
15ae			;	ld a, (os_view_disable) 
15ae			;	cp 0 
15ae			;	jr z, .distog 
15ae			;	ld de, hd_doff 
15ae			;.distog: ld a, display_row_4+17 
15ae			;	call str_at_display 
15ae			; 
15ae			;	call update_display 
15ae			; 
15ae			;	call cin_wait 
15ae			; 
15ae			; 
15ae			; 
15ae			;	cp '4' 
15ae			;	jr nz, .diagn1 
15ae			; 
15ae			;	; debug toggle 
15ae			; 
15ae			;	ld a, (os_view_disable) 
15ae			;	ld b, '*' 
15ae			;	cp 0 
15ae			;	jr z, .debtog 
15ae			;	ld b, 0 
15ae			;.debtog:	 
15ae			;	ld a,b 
15ae			;	ld (os_view_disable),a 
15ae			; 
15ae			;.diagn1: cp '0' 
15ae			;	 ret z 
15ae			; 
15ae			;;	cp '1' 
15ae			;;       jp z, matrix	 
15ae			;;   TODO keyboard matrix test 
15ae			; 
15ae			;	cp '2' 
15ae			;	jp z, .diagedit 
15ae			; 
15ae			;;	cp '6' 
15ae			;;	jp z, .menutest 
15ae			;;if ENABLE_BASIC 
15ae			;;	cp '6' 
15ae			;;	jp z, basic 
15ae			;;endif 
15ae			 ; 
15ae			;	jp .diagmenu 
15ae			; 
15ae			; 
15ae			;	ret 
15ae			 
15ae			 
15ae			.debug_tog: 
15ae 21 f5 15			ld hl, .menudebug 
15b1				 
15b1 3a 94 ef			ld a, (os_view_disable) 
15b4 fe 2a			cp '*' 
15b6 20 04			jr nz,.tdon  
15b8 3e 01			ld a, 1 
15ba 18 02			jr .tog1 
15bc 3e 00		.tdon: ld a, 0 
15be			 
15be			.tog1: 
15be cd 03 0b			call menu 
15c1 fe 00			cp 0 
15c3 c8				ret z 
15c4 fe 01			cp 1    ; disable debug 
15c6 28 04			jr z, .dtog0 
15c8 3e 2a			ld a, '*' 
15ca 18 02			jr .dtogset 
15cc 3e 00		.dtog0: ld a, 0 
15ce 32 94 ef		.dtogset:  ld (os_view_disable), a 
15d1 c3 ae 15			jp .debug_tog 
15d4			 
15d4			 
15d4			hardware_diags:       
15d4			 
15d4			.diagm: 
15d4 21 e7 15			ld hl, .menuitems 
15d7 3e 00			ld a, 0 
15d9 cd 03 0b			call menu 
15dc			 
15dc fe 00		         cp 0 
15de c8				 ret z 
15df			 
15df fe 02			cp 2 
15e1 ca 40 16			jp z, .diagedit 
15e4			 
15e4			;	cp '6' 
15e4			;	jp z, .menutest 
15e4			;if ENABLE_BASIC 
15e4			;	cp '6' 
15e4			;	jp z, basic 
15e4			;endif 
15e4			  
15e4 c3 d4 15			jp .diagm 
15e7			 
15e7				 
15e7 fb 15		.menuitems:   	dw .m1 
15e9 06 16				dw .m2 
15eb 0d 16				dw .m3 
15ed 15 16				dw .m5 
15ef 1b 16				dw .m5a 
15f1 24 16				dw .m5b 
15f3 00 00				dw 0 
15f5			 
15f5			.menudebug: 
15f5 2d 16				dw .m6 
15f7 36 16				dw .m7 
15f9 00 00				dw 0 
15fb			 
15fb .. 00		.m1:   db "Key Matrix",0 
1606 .. 00		.m2:   db "Editor",0 
160d .. 00		.m3:   db "Storage",0 
1615 .. 00		.m5:   db "Sound",0 
161b .. 00		.m5a:  db "RAM Test",0 
1624 .. 00		.m5b:  db "LCD Test",0 
162d			 
162d .. 00		.m6:   db "Debug ON",0 
1636 .. 00		.m7:   db "Debug OFF",0 
1640			 
1640			; debug editor 
1640			 
1640			.diagedit: 
1640			 
1640 21 a3 ef			ld hl, scratch 
1643			;	ld bc, 250 
1643			;	ldir 
1643				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1643 3e 00			ld a, 0 
1645 77				ld (hl), a 
1646 23				inc hl 
1647 77				ld (hl), a 
1648 23				inc hl 
1649 77				ld (hl), a 
164a			 
164a cd d2 0a		        call clear_display 
164d cd f5 0a			call update_display 
1650 3e 01			ld a, 1 
1652 32 c3 fb			ld (hardware_diag), a 
1655			.diloop: 
1655 3e 00			ld a, display_row_1 
1657 0e 00			ld c, 0 
1659 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
165b 1e 28			ld e, 40 
165d			 
165d 21 a3 ef			ld hl, scratch	 
1660 cd 33 0d			call input_str 
1663			 
1663 3e 14			ld a, display_row_2 
1665 11 a3 ef			ld de, scratch 
1668 cd e5 0a			call str_at_display 
166b cd f5 0a			call update_display 
166e			 
166e c3 55 16			jp .diloop 
1671			 
1671			 
1671			; pass word in hl 
1671			; a has display location 
1671			display_word_at: 
1671 f5				push af 
1672 e5				push hl 
1673 7c				ld a,h 
1674 21 a8 f2			ld hl, os_word_scratch 
1677 cd 07 10			call hexout 
167a e1				pop hl 
167b 7d				ld a,l 
167c 21 aa f2			ld hl, os_word_scratch+2 
167f cd 07 10			call hexout 
1682 21 ac f2			ld hl, os_word_scratch+4 
1685 3e 00			ld a,0 
1687 77				ld (hl),a 
1688 11 a8 f2			ld de,os_word_scratch 
168b f1				pop af 
168c cd e5 0a				call str_at_display 
168f c9				ret 
1690			 
1690			display_ptr_state: 
1690			 
1690				; to restore afterwards 
1690			 
1690 d5				push de 
1691 c5				push bc 
1692 e5				push hl 
1693 f5				push af 
1694			 
1694				; for use in here 
1694			 
1694			;	push bc 
1694			;	push de 
1694			;	push hl 
1694			;	push af 
1694			 
1694 cd d2 0a			call clear_display 
1697			 
1697 11 6a 18			ld de, .ptrstate 
169a 3e 00			ld a, display_row_1 
169c cd e5 0a			call str_at_display 
169f			 
169f				; display debug step 
169f			 
169f			 
169f 11 bd fb			ld de, debug_mark 
16a2 3e 12			ld a, display_row_1+display_cols-2 
16a4 cd e5 0a			call str_at_display 
16a7			 
16a7				; display a 
16a7 11 74 18			ld de, .ptrcliptr 
16aa 3e 14			ld a, display_row_2 
16ac cd e5 0a			call str_at_display 
16af			 
16af f1				pop af 
16b0 2a ae f9			ld hl,(cli_ptr) 
16b3 3e 1c			ld a, display_row_2+8 
16b5 cd 71 16			call display_word_at 
16b8			 
16b8			 
16b8				; display hl 
16b8			 
16b8			 
16b8 11 7c 18			ld de, .ptrclioptr 
16bb 3e 1e			ld a, display_row_2+10 
16bd cd e5 0a			call str_at_display 
16c0			; 
16c0			;	pop hl 
16c0 3e 21			ld a, display_row_2+13 
16c2 2a ac f9			ld hl,(cli_origptr) 
16c5 cd 71 16			call display_word_at 
16c8			; 
16c8			;	 
16c8			;	; display de 
16c8			 
16c8			;	ld de, .regstatede 
16c8			;	ld a, display_row_3 
16c8			;	call str_at_display 
16c8			 
16c8			;	pop de 
16c8			;	ld h,d 
16c8			;	ld l, e 
16c8			;	ld a, display_row_3+3 
16c8			;	call display_word_at 
16c8			 
16c8			 
16c8				; display bc 
16c8			 
16c8			;	ld de, .regstatebc 
16c8			;	ld a, display_row_3+10 
16c8			;	call str_at_display 
16c8			 
16c8			;	pop bc 
16c8			;	ld h,b 
16c8			;	ld l, c 
16c8			;	ld a, display_row_3+13 
16c8			;	call display_word_at 
16c8			 
16c8			 
16c8				; display dsp 
16c8			 
16c8			;	ld de, .regstatedsp 
16c8			;	ld a, display_row_4 
16c8			;	call str_at_display 
16c8			 
16c8				 
16c8			;	ld hl,(cli_data_sp) 
16c8			;	ld a, display_row_4+4 
16c8			;	call display_word_at 
16c8			 
16c8				; display rsp 
16c8			 
16c8 11 ab 18			ld de, .regstatersp 
16cb 3e 46			ld a, display_row_4+10 
16cd cd e5 0a			call str_at_display 
16d0			 
16d0				 
16d0 2a 94 f9			ld hl,(cli_ret_sp) 
16d3 3e 4a			ld a, display_row_4+14 
16d5 cd 71 16			call display_word_at 
16d8			 
16d8 cd f5 0a			call update_display 
16db			 
16db cd 52 0a			call delay1s 
16de cd 52 0a			call delay1s 
16e1 cd 52 0a			call delay1s 
16e4			 
16e4			 
16e4 cd f4 1b			call next_page_prompt 
16e7			 
16e7				; restore  
16e7			 
16e7 f1				pop af 
16e8 e1				pop hl 
16e9 c1				pop bc 
16ea d1				pop de 
16eb c9				ret 
16ec			 
16ec			break_point_state: 
16ec f5				push af 
16ed			 
16ed				; see if disabled 
16ed			 
16ed 3a 94 ef			ld a, (os_view_disable) 
16f0 fe 2a			cp '*' 
16f2 20 02			jr nz, .bpsgo 
16f4 f1				pop af 
16f5 c9				ret 
16f6			 
16f6			.bpsgo: 
16f6 f1				pop af 
16f7 f5				push af 
16f8 22 90 ef			ld (os_view_hl), hl 
16fb ed 53 8e ef		ld (os_view_de), de 
16ff ed 43 8c ef		ld (os_view_bc), bc 
1703 e5				push hl 
1704 6f				ld l, a 
1705 26 00			ld h, 0 
1707 22 92 ef			ld (os_view_af),hl 
170a			 
170a 21 53 fb				ld hl, display_fb0 
170d 22 5e fa				ld (display_fb_active), hl 
1710 e1				pop hl	 
1711			 
1711 3e 31			ld a, '1' 
1713 fe 2a		.bps1:  cp '*' 
1715 20 03			jr nz, .bps1b 
1717 32 94 ef			ld (os_view_disable),a 
171a fe 31		.bps1b:  cp '1' 
171c 20 14			jr nz, .bps2 
171e			 
171e				; display reg 
171e			 
171e				 
171e			 
171e 3a 92 ef			ld a, (os_view_af) 
1721 2a 90 ef			ld hl, (os_view_hl) 
1724 ed 5b 8e ef		ld de, (os_view_de) 
1728 ed 4b 8c ef		ld bc, (os_view_bc) 
172c cd c6 17			call display_reg_state 
172f c3 b2 17			jp .bpschk 
1732			 
1732 fe 32		.bps2:  cp '2' 
1734 20 08			jr nz, .bps3 
1736				 
1736				; display hl 
1736 2a 90 ef			ld hl, (os_view_hl) 
1739 cd b0 18			call display_dump_at_hl 
173c			 
173c 18 74			jr .bpschk 
173e			 
173e fe 33		.bps3:  cp '3' 
1740 20 08			jr nz, .bps4 
1742			 
1742			        ; display de 
1742 2a 8e ef			ld hl, (os_view_de) 
1745 cd b0 18			call display_dump_at_hl 
1748			 
1748 18 68			jr .bpschk 
174a fe 34		.bps4:  cp '4' 
174c 20 08			jr nz, .bps5 
174e			 
174e			        ; display bc 
174e 2a 8c ef			ld hl, (os_view_bc) 
1751 cd b0 18			call display_dump_at_hl 
1754			 
1754 18 5c			jr .bpschk 
1756 fe 35		.bps5:  cp '5' 
1758 20 08		        jr nz, .bps7 
175a			 
175a				; display cur ptr 
175a 2a ae f9			ld hl, (cli_ptr) 
175d cd b0 18			call display_dump_at_hl 
1760			 
1760 18 50			jr .bpschk 
1762 fe 36		.bps7:  cp '6' 
1764 20 08			jr nz, .bps8b 
1766				 
1766				; display cur orig ptr 
1766 2a ac f9			ld hl, (cli_origptr) 
1769 cd b0 18			call display_dump_at_hl 
176c 18 44			jr .bpschk 
176e fe 37		.bps8b:  cp '7' 
1770 20 08			jr nz, .bps9 
1772				 
1772				; display dsp 
1772 2a 90 f9			ld hl, (cli_data_sp) 
1775 cd b0 18			call display_dump_at_hl 
1778			 
1778 18 38			jr .bpschk 
177a fe 39		.bps9:  cp '9' 
177c 20 05			jr nz, .bps8c 
177e				 
177e				; display SP 
177e			;	ld hl, sp 
177e cd b0 18			call display_dump_at_hl 
1781			 
1781 18 2f			jr .bpschk 
1783 fe 38		.bps8c:  cp '8' 
1785 20 08			jr nz, .bps8d 
1787				 
1787				; display rsp 
1787 2a 94 f9			ld hl, (cli_ret_sp) 
178a cd b0 18			call display_dump_at_hl 
178d			 
178d 18 23			jr .bpschk 
178f fe 23		.bps8d:  cp '#'     ; access monitor sub system 
1791 20 05			jr nz, .bps8 
1793 cd ea 19			call monitor 
1796			 
1796 18 1a			jr .bpschk 
1798 fe 30		.bps8:  cp '0' 
179a 20 16			jr nz, .bpschk 
179c			 
179c 21 02 fb				ld hl, display_fb1 
179f 22 5e fa				ld (display_fb_active), hl 
17a2 cd f5 0a				call update_display 
17a5			 
17a5				;ld a, (os_view_af) 
17a5 2a 90 ef			ld hl, (os_view_hl) 
17a8 ed 5b 8e ef		ld de, (os_view_de) 
17ac ed 4b 8c ef		ld bc, (os_view_bc) 
17b0 f1				pop af 
17b1 c9				ret 
17b2			 
17b2			.bpschk:   
17b2 cd 52 0a			call delay1s 
17b5 3e 4f		ld a,display_row_4 + display_cols - 1 
17b7 11 f2 1b		        ld de, endprg 
17ba cd e5 0a			call str_at_display 
17bd cd f5 0a			call update_display 
17c0 cd fc 67			call cin_wait 
17c3			 
17c3 c3 13 17			jp .bps1 
17c6			 
17c6			 
17c6			display_reg_state: 
17c6			 
17c6				; to restore afterwards 
17c6			 
17c6 d5				push de 
17c7 c5				push bc 
17c8 e5				push hl 
17c9 f5				push af 
17ca			 
17ca				; for use in here 
17ca			 
17ca c5				push bc 
17cb d5				push de 
17cc e5				push hl 
17cd f5				push af 
17ce			 
17ce cd d2 0a			call clear_display 
17d1			 
17d1 11 86 18			ld de, .regstate 
17d4 3e 00			ld a, display_row_1 
17d6 cd e5 0a			call str_at_display 
17d9			 
17d9				; display debug step 
17d9			 
17d9			 
17d9 11 bd fb			ld de, debug_mark 
17dc 3e 11			ld a, display_row_1+display_cols-3 
17de cd e5 0a			call str_at_display 
17e1			 
17e1				; display a 
17e1 11 a2 18			ld de, .regstatea 
17e4 3e 14			ld a, display_row_2 
17e6 cd e5 0a			call str_at_display 
17e9			 
17e9 e1				pop hl 
17ea			;	ld h,0 
17ea			;	ld l, a 
17ea 3e 17			ld a, display_row_2+3 
17ec cd 71 16			call display_word_at 
17ef			 
17ef			 
17ef				; display hl 
17ef			 
17ef			 
17ef 11 96 18			ld de, .regstatehl 
17f2 3e 1e			ld a, display_row_2+10 
17f4 cd e5 0a			call str_at_display 
17f7			 
17f7 e1				pop hl 
17f8 3e 21			ld a, display_row_2+13 
17fa cd 71 16			call display_word_at 
17fd			 
17fd				 
17fd				; display de 
17fd			 
17fd 11 9a 18			ld de, .regstatede 
1800 3e 28			ld a, display_row_3 
1802 cd e5 0a			call str_at_display 
1805			 
1805 e1				pop hl 
1806			;	ld h,d 
1806			;	ld l, e 
1806 3e 2b			ld a, display_row_3+3 
1808 cd 71 16			call display_word_at 
180b			 
180b			 
180b				; display bc 
180b			 
180b 11 9e 18			ld de, .regstatebc 
180e 3e 32			ld a, display_row_3+10 
1810 cd e5 0a			call str_at_display 
1813			 
1813 e1				pop hl 
1814			;	ld h,b 
1814			;	ld l, c 
1814 3e 35			ld a, display_row_3+13 
1816 cd 71 16			call display_word_at 
1819			 
1819			 
1819				; display dsp 
1819			 
1819 11 a6 18			ld de, .regstatedsp 
181c 3e 3c			ld a, display_row_4 
181e cd e5 0a			call str_at_display 
1821			 
1821				 
1821 2a 90 f9			ld hl,(cli_data_sp) 
1824 3e 40			ld a, display_row_4+4 
1826 cd 71 16			call display_word_at 
1829			 
1829				; display rsp 
1829			 
1829 11 ab 18			ld de, .regstatersp 
182c 3e 46			ld a, display_row_4+10 
182e cd e5 0a			call str_at_display 
1831			 
1831				 
1831 2a 94 f9			ld hl,(cli_ret_sp) 
1834 3e 4a			ld a, display_row_4+14 
1836 cd 71 16			call display_word_at 
1839			 
1839 cd f5 0a			call update_display 
183c			 
183c			;	call delay1s 
183c			;	call delay1s 
183c			;	call delay1s 
183c			 
183c			 
183c			;	call next_page_prompt 
183c			 
183c				; restore  
183c			 
183c f1				pop af 
183d e1				pop hl 
183e c1				pop bc 
183f d1				pop de 
1840 c9				ret 
1841			 
1841 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1855 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
186a .. 00		.ptrstate:	db "Ptr State",0 
1874 .. 00		.ptrcliptr:     db "cli_ptr",0 
187c .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1886 .. 00		.regstate:	db "Reg State (1/0)",0 
1896 .. 00		.regstatehl:	db "HL:",0 
189a .. 00		.regstatede:	db "DE:",0 
189e .. 00		.regstatebc:	db "BC:",0 
18a2 .. 00		.regstatea:	db "A :",0 
18a6 .. 00		.regstatedsp:	db "DSP:",0 
18ab .. 00		.regstatersp:	db "RSP:",0 
18b0			 
18b0			display_dump_at_hl: 
18b0 e5				push hl 
18b1 d5				push de 
18b2 c5				push bc 
18b3 f5				push af 
18b4			 
18b4 22 c6 f2			ld (os_cur_ptr),hl	 
18b7 cd d2 0a			call clear_display 
18ba cd fc 1a			call dumpcont 
18bd			;	call delay1s 
18bd			;	call next_page_prompt 
18bd			 
18bd			 
18bd f1				pop af 
18be c1				pop bc 
18bf d1				pop de 
18c0 e1				pop hl 
18c1 c9				ret 
18c2			 
18c2			;if ENABLE_BASIC 
18c2			;	include "nascombasic.asm" 
18c2			;	basic: 
18c2			;	include "forth/FORTH.ASM" 
18c2			;endif 
18c2			 
18c2			; eof 
18c2			 
18c2			 
# End of file firmware_diags.asm
18c2			  
18c2			  
18c2			  
18c2			  
18c2			; eof  
18c2			  
# End of file firmware.asm
18c2			 
18c2			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
18c2			;if BASE_KEV  
18c2			;baseram: equ 08000h 
18c2			;endif 
18c2			 
18c2			;if BASE_SC114 
18c2			;baseram:     equ    endofcode 
18c2			;endif 
18c2			 
18c2			 
18c2			; start system 
18c2			 
18c2			coldstart: 
18c2				; set sp 
18c2				; di/ei 
18c2			 
18c2 f3				di 
18c3 31 fd ff			ld sp, tos 
18c6			;	ei 
18c6			 
18c6			 
18c6				; disable breakpoint by default 
18c6			 
18c6 3e 2a			ld a,'*' 
18c8 32 94 ef			ld (os_view_disable),a 
18cb			 
18cb				; init hardware 
18cb			 
18cb				; init keyboard and screen hardware 
18cb			 
18cb cd 03 00			call hardware_init 
18ce			 
18ce			 
18ce				; detect if any keys are held down to enable breakpoints at start up 
18ce			 
18ce cd 0d 68			call cin  
18d1 fe 00			cp 0 
18d3 28 03			jr z, .nokeys 
18d5			 
18d5				;call hardware_diags 
18d5 cd 66 13			call config 
18d8			 
18d8			;	ld de, .bpen 
18d8			;	ld a, display_row_4 
18d8			;	call str_at_display 
18d8			;	call update_display 
18d8			; 
18d8			;	ld a,0 
18d8			;	ld (os_view_disable),a 
18d8			; 
18d8			;.bpwait: 
18d8			;	call cin 
18d8			;	cp 0 
18d8			;	jr z, .bpwait 
18d8			;	jr .nokeys 
18d8			; 
18d8			; 
18d8			;.bpen:  db "Break points enabled!",0 
18d8			 
18d8			 
18d8			 
18d8			 
18d8			 
18d8			 
18d8			.nokeys: 
18d8			 
18d8			 
18d8				 
18d8			 
18d8			;jp  testkey 
18d8			 
18d8			;call storage_get_block_0 
18d8			; 
18d8			;ld hl, 0 
18d8			;ld de, store_page 
18d8			;call storage_read_block 
18d8			 
18d8				 
18d8			;ld hl, 10 
18d8			;ld de, store_page 
18d8			;call storage_read_block 
18d8			 
18d8			 
18d8			 
18d8			 
18d8			 
18d8			;stop:	nop 
18d8			;	jp stop 
18d8			 
18d8			 
18d8			 
18d8			main: 
18d8 cd d2 0a			call clear_display 
18db cd f5 0a			call update_display 
18de			 
18de			 
18de			 
18de			;	call testlcd 
18de			 
18de			 
18de			 
18de cd ba 1f			call forth_init 
18e1			 
18e1			 
18e1			warmstart: 
18e1 cd 90 1f			call forth_warmstart 
18e4			 
18e4				; run startup word load 
18e4			        ; TODO prevent this running at warmstart after crash  
18e4			 
18e4				if STARTUP_ENABLE 
18e4 cd 48 62				call forth_startup 
18e7			 
18e7					if STORAGE_SE 
18e7 cd 39 65					call forth_autoload 
18ea					endif 
18ea			 
18ea				endif 
18ea			 
18ea				; show free memory after boot 
18ea 11 84 19			ld de, freeram 
18ed 3e 00			ld a, display_row_1 
18ef cd e5 0a			call str_at_display 
18f2			 
18f2			; Or use heap_size word???? 
18f2 21 89 ef			ld hl, heap_end 
18f5 11 0e 80			ld de, heap_start 
18f8 ed 52			sbc hl, de 
18fa e5				push hl 
18fb 7c				ld a,h	         	 
18fc 21 a8 f2			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
18ff cd 07 10			call hexout 
1902 e1			   	pop hl 
1903			 
1903 7d				ld a,l 
1904 21 aa f2			ld hl, os_word_scratch+2 
1907 cd 07 10			call hexout 
190a 21 ac f2			ld hl, os_word_scratch+4 
190d 3e 00			ld a, 0 
190f 77				ld (hl),a 
1910 11 a8 f2			ld de, os_word_scratch 
1913 3e 0d			ld a, display_row_1 + 13 
1915 cd e5 0a			call str_at_display 
1918 cd f5 0a			call update_display 
191b			 
191b			 
191b				;call demo 
191b			 
191b			 
191b				; init scratch input area for cli commands 
191b			 
191b 21 ca f2			ld hl, os_cli_cmd 
191e 3e 00			ld a,0 
1920 77				ld (hl),a 
1921 23				inc hl 
1922 77				ld (hl),a 
1923			 
1923 3e 00			ld a,0 
1925 32 c9 f3			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1928			 
1928 32 c6 f2			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
192b 32 c7 f2			ld (os_cur_ptr+1),a	 
192e			 
192e 32 a8 f2			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1931 32 a9 f2			ld (os_word_scratch+1),a	 
1934				 
1934			 
1934				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1934 21 ca f2			ld hl, os_cli_cmd 
1937			 
1937 3e 00			ld a, 0		 ; init cli input 
1939 77				ld (hl), a 
193a 3e 14			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
193c			cli: 
193c				; show cli prompt 
193c				;push af 
193c				;ld a, 0 
193c				;ld de, prompt 
193c				;call str_at_display 
193c			 
193c				;call update_display 
193c				;pop af 
193c				;inc a 
193c				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
193c 0e 00			ld c, 0 
193e 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1940 1e 28			ld e, 40 
1942			 
1942 21 ca f2			ld hl, os_cli_cmd 
1945			 
1945				STACKFRAME OFF $fefe $9f9f 
1945				if DEBUG_STACK_IMB 
1945					if OFF 
1945						exx 
1945						ld de, $fefe 
1945						ld a, d 
1945						ld hl, curframe 
1945						call hexout 
1945						ld a, e 
1945						ld hl, curframe+2 
1945						call hexout 
1945						ld hl, $fefe 
1945						push hl 
1945						ld hl, $9f9f 
1945						push hl 
1945						exx 
1945					endif 
1945				endif 
1945			endm 
# End of macro STACKFRAME
1945			 
1945 cd 33 0d			call input_str 
1948			 
1948				STACKFRAMECHK OFF $fefe $9f9f 
1948				if DEBUG_STACK_IMB 
1948					if OFF 
1948						exx 
1948						ld hl, $9f9f 
1948						pop de   ; $9f9f 
1948						call cmp16 
1948						jr nz, .spnosame 
1948						ld hl, $fefe 
1948						pop de   ; $fefe 
1948						call cmp16 
1948						jr z, .spfrsame 
1948						.spnosame: call showsperror 
1948						.spfrsame: nop 
1948						exx 
1948					endif 
1948				endif 
1948			endm 
# End of macro STACKFRAMECHK
1948			 
1948				; copy input to last command 
1948			 
1948 21 ca f2			ld hl, os_cli_cmd 
194b 11 c9 f3			ld de, os_last_cmd 
194e 01 ff 00			ld bc, 255 
1951 ed b0			ldir 
1953			 
1953				; wipe current buffer 
1953			 
1953			;	ld a, 0 
1953			;	ld hl, os_cli_cmd 
1953			;	ld de, os_cli_cmd+1 
1953			;	ld bc, 254 
1953			;	ldir 
1953				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1953			;	call strcpy 
1953			;	ld a, 0 
1953			;	ld (hl), a 
1953			;	inc hl 
1953			;	ld (hl), a 
1953			;	inc hl 
1953			;	ld (hl), a 
1953			 
1953				; switch frame buffer to program  
1953			 
1953 21 02 fb				ld hl, display_fb1 
1956 22 5e fa				ld (display_fb_active), hl 
1959			 
1959			;	nop 
1959				STACKFRAME ON $fbfe $8f9f 
1959				if DEBUG_STACK_IMB 
1959					if ON 
1959						exx 
1959						ld de, $fbfe 
1959						ld a, d 
1959						ld hl, curframe 
1959						call hexout 
1959						ld a, e 
1959						ld hl, curframe+2 
1959						call hexout 
1959						ld hl, $fbfe 
1959						push hl 
1959						ld hl, $8f9f 
1959						push hl 
1959						exx 
1959					endif 
1959				endif 
1959			endm 
# End of macro STACKFRAME
1959				; first time into the parser so pass over the current scratch pad 
1959 21 ca f2			ld hl,os_cli_cmd 
195c				; tokenise the entered statement(s) in HL 
195c cd 33 20			call forthparse 
195f			        ; exec forth statements in top of return stack 
195f cd 73 20			call forthexec 
1962				;call forthexec_cleanup 
1962			;	call parsenext 
1962			 
1962				STACKFRAMECHK ON $fbfe $8f9f 
1962				if DEBUG_STACK_IMB 
1962					if ON 
1962						exx 
1962						ld hl, $8f9f 
1962						pop de   ; $8f9f 
1962						call cmp16 
1962						jr nz, .spnosame 
1962						ld hl, $fbfe 
1962						pop de   ; $fbfe 
1962						call cmp16 
1962						jr z, .spfrsame 
1962						.spnosame: call showsperror 
1962						.spfrsame: nop 
1962						exx 
1962					endif 
1962				endif 
1962			endm 
# End of macro STACKFRAMECHK
1962				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1962			 
1962 3e 3c			ld a, display_row_4 
1964 11 96 19			ld de, endprog 
1967			 
1967 cd f5 0a			call update_display		 
196a			 
196a cd f4 1b			call next_page_prompt 
196d			 
196d				; switch frame buffer to cli 
196d			 
196d 21 53 fb				ld hl, display_fb0 
1970 22 5e fa				ld (display_fb_active), hl 
1973			 
1973			 
1973 cd d2 0a		        call clear_display 
1976 cd f5 0a			call update_display		 
1979			 
1979 21 ca f2			ld hl, os_cli_cmd 
197c			 
197c 3e 00			ld a, 0		 ; init cli input 
197e 77				ld (hl), a 
197f			 
197f				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
197f			 
197f				; now on last line 
197f			 
197f				; TODO scroll screen up 
197f			 
197f				; TODO instead just clear screen and place at top of screen 
197f			 
197f			;	ld a, 0 
197f			;	ld (f_cursor_ptr),a 
197f			 
197f				;call clear_display 
197f				;call update_display 
197f			 
197f				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
197f 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1981 c3 3c 19			jp cli 
1984			 
1984 .. 00		freeram: db "Free bytes: $",0 
1992 ..			asc: db "1A2F" 
1996 .. 00		endprog: db "End prog...",0 
19a2			 
19a2			testenter2:   
19a2 21 d5 ef			ld hl,scratch+50 
19a5 22 c6 f2			ld (os_cur_ptr),hl 
19a8 c3 3c 19			jp cli 
19ab			 
19ab			testenter:  
19ab			 
19ab 21 92 19			ld hl,asc 
19ae			;	ld a,(hl) 
19ae			;	call nibble2val 
19ae cd 5d 10			call get_byte 
19b1			 
19b1			 
19b1			;	ld a,(hl) 
19b1			;	call atohex 
19b1			 
19b1			;	call fourehexhl 
19b1 32 d5 ef			ld (scratch+50),a 
19b4			 
19b4			 
19b4			 
19b4 21 94 19			ld hl,asc+2 
19b7			;	ld a, (hl) 
19b7			;	call nibble2val 
19b7 cd 5d 10			call get_byte 
19ba			 
19ba			;	call fourehexhl 
19ba 32 d7 ef			ld (scratch+52),a 
19bd				 
19bd 21 d5 ef			ld hl,scratch+50 
19c0 22 c6 f2			ld (os_cur_ptr),hl 
19c3 c3 3c 19			jp cli 
19c6			 
19c6			enter:	 
19c6 3a a7 ef			ld a,(scratch+4) 
19c9 fe 00			cp 0 
19cb 28 0c			jr z, .entercont 
19cd				; no, not a null term line so has an address to work out.... 
19cd			 
19cd 21 a5 ef			ld hl,scratch+2 
19d0 cd bd 10			call get_word_hl 
19d3			 
19d3 22 c6 f2			ld (os_cur_ptr),hl	 
19d6 c3 3c 19			jp cli 
19d9			 
19d9			 
19d9			.entercont:  
19d9			 
19d9 21 a5 ef			ld hl, scratch+2 
19dc cd 5d 10			call get_byte 
19df			 
19df 2a c6 f2		   	ld hl,(os_cur_ptr) 
19e2 77					ld (hl),a 
19e3 23					inc hl 
19e4 22 c6 f2				ld (os_cur_ptr),hl 
19e7				 
19e7			; get byte  
19e7			 
19e7			 
19e7 c3 3c 19			jp cli 
19ea			 
19ea			 
19ea			; basic monitor support 
19ea			 
19ea			monitor: 
19ea				;  
19ea cd d2 0a			call clear_display 
19ed 3e 00			ld a, 0 
19ef 11 37 1a			ld de, .monprompt 
19f2 cd e5 0a			call str_at_display 
19f5 cd f5 0a			call update_display 
19f8			 
19f8				; get a monitor command 
19f8			 
19f8 0e 00			ld c, 0     ; entry at top left 
19fa 16 64			ld d, 100   ; max buffer size 
19fc 1e 0f			ld e, 15    ; input scroll area 
19fe 3e 00			ld a, 0     ; init string 
1a00 21 a1 f1			ld hl, os_input 
1a03 77				ld (hl), a 
1a04 23				inc hl 
1a05 77				ld (hl), a 
1a06 21 a1 f1			ld hl, os_input 
1a09 3e 01			ld a, 1     ; init string 
1a0b cd 33 0d			call input_str 
1a0e			 
1a0e cd d2 0a		        call clear_display 
1a11 cd f5 0a			call update_display		 
1a14			 
1a14 3a a1 f1			ld a, (os_input) 
1a17 cd 5b 11			call toUpper 
1a1a fe 48		        cp 'H' 
1a1c 28 6f		        jr z, .monhelp 
1a1e fe 44			cp 'D'		; dump 
1a20 ca ae 1a			jp z, .mondump	 
1a23 fe 43			cp 'C'		; dump 
1a25 ca c8 1a			jp z, .moncdump	 
1a28 fe 4d			cp 'M'		; dump 
1a2a ca 39 1a			jp z, .moneditstart 
1a2d fe 55			cp 'U'		; dump 
1a2f 28 14			jr z, .monedit	 
1a31 fe 51			cp 'Q'		; dump 
1a33 c8				ret z	 
1a34			 
1a34			 
1a34				; TODO "S" to access symbol by name and not need the address 
1a34				; TODO "F" to find a string in memory 
1a34			 
1a34 c3 ea 19			jp monitor 
1a37			 
1a37 .. 00		.monprompt: db ">", 0 
1a39			 
1a39			.moneditstart: 
1a39				; get starting address 
1a39			 
1a39 21 a3 f1			ld hl,os_input+2 
1a3c cd bd 10			call get_word_hl 
1a3f			 
1a3f 22 c6 f2			ld (os_cur_ptr),hl	 
1a42			 
1a42 c3 ea 19			jp monitor 
1a45			 
1a45			.monedit: 
1a45				; get byte to load 
1a45			 
1a45 21 a3 f1			ld hl,os_input+2 
1a48 cd 5d 10			call get_byte 
1a4b			 
1a4b				; get address to update 
1a4b 2a c6 f2			ld hl, (os_cur_ptr) 
1a4e			 
1a4e				; update byte 
1a4e			 
1a4e 77				ld (hl), a 
1a4f			 
1a4f				; move to next address and save it 
1a4f			 
1a4f 23				inc hl 
1a50 22 c6 f2			ld (os_cur_ptr),hl	 
1a53			 
1a53 c3 ea 19			jp monitor 
1a56			 
1a56			 
1a56 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1a6a .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1a86 .. 00		.monhelptext3:  db "Q-Quit",0 
1a8d			        
1a8d			.monhelp: 
1a8d 3e 00			ld a, display_row_1 
1a8f 11 56 1a		        ld de, .monhelptext1 
1a92			 
1a92 cd e5 0a			call str_at_display 
1a95 3e 14			ld a, display_row_2 
1a97 11 6a 1a		        ld de, .monhelptext2 
1a9a					 
1a9a cd e5 0a			call str_at_display 
1a9d 3e 28			ld a, display_row_3 
1a9f 11 86 1a		        ld de, .monhelptext3 
1aa2					 
1aa2 cd e5 0a			call str_at_display 
1aa5 cd f5 0a			call update_display		 
1aa8			 
1aa8 cd f4 1b			call next_page_prompt 
1aab c3 ea 19			jp monitor 
1aae			 
1aae			.mondump:    
1aae 21 a3 f1			ld hl,os_input+2 
1ab1 cd bd 10			call get_word_hl 
1ab4			 
1ab4 22 c6 f2			ld (os_cur_ptr),hl	 
1ab7 cd fc 1a			call dumpcont 
1aba 3e 3c			ld a, display_row_4 
1abc 11 96 19			ld de, endprog 
1abf			 
1abf cd f5 0a			call update_display		 
1ac2			 
1ac2 cd f4 1b			call next_page_prompt 
1ac5 c3 ea 19			jp monitor 
1ac8			.moncdump: 
1ac8 cd fc 1a			call dumpcont 
1acb 3e 3c			ld a, display_row_4 
1acd 11 96 19			ld de, endprog 
1ad0			 
1ad0 cd f5 0a			call update_display		 
1ad3			 
1ad3 cd f4 1b			call next_page_prompt 
1ad6 c3 ea 19			jp monitor 
1ad9			 
1ad9			 
1ad9			; TODO symbol access  
1ad9			 
1ad9			.symbols:     ;; A list of symbols that can be called up  
1ad9 53 fb			dw display_fb0 
1adb .. 00			db "fb0",0  
1adf e8 f9		     	dw store_page 
1ae1 .. 00			db "store_page",0 
1aec			 
1aec			 
1aec			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1aec			 
1aec 3a a4 ef			ld a,(scratch+1) 
1aef fe 00			cp 0 
1af1 28 09			jr z, dumpcont 
1af3			 
1af3				; no, not a null term line so has an address to work out.... 
1af3			 
1af3 21 a5 ef			ld hl,scratch+2 
1af6 cd bd 10			call get_word_hl 
1af9			 
1af9 22 c6 f2			ld (os_cur_ptr),hl	 
1afc			 
1afc			 
1afc			 
1afc			dumpcont: 
1afc			 
1afc				; dump bytes at ptr 
1afc			 
1afc			 
1afc 3e 00			ld a, display_row_1 
1afe 2a 5e fa			ld hl, (display_fb_active) 
1b01 cd 06 0d			call addatohl 
1b04 cd 2c 1b			call .dumpbyterow 
1b07			 
1b07 3e 14			ld a, display_row_2 
1b09 2a 5e fa			ld hl, (display_fb_active) 
1b0c cd 06 0d			call addatohl 
1b0f cd 2c 1b			call .dumpbyterow 
1b12			 
1b12			 
1b12 3e 28			ld a, display_row_3 
1b14 2a 5e fa			ld hl, (display_fb_active) 
1b17 cd 06 0d			call addatohl 
1b1a cd 2c 1b			call .dumpbyterow 
1b1d			 
1b1d 3e 3c			ld a, display_row_4 
1b1f 2a 5e fa			ld hl, (display_fb_active) 
1b22 cd 06 0d			call addatohl 
1b25 cd 2c 1b			call .dumpbyterow 
1b28			 
1b28 cd f5 0a			call update_display 
1b2b			;		jp cli 
1b2b c9				ret 
1b2c			 
1b2c			.dumpbyterow: 
1b2c			 
1b2c				;push af 
1b2c			 
1b2c e5				push hl 
1b2d			 
1b2d				; calc where to poke the ascii 
1b2d			if display_cols == 20 
1b2d 3e 10			ld a, 16 
1b2f			else 
1b2f				ld a, 31 
1b2f			endif 
1b2f			 
1b2f cd 06 0d			call addatohl 
1b32 22 a8 f2			ld (os_word_scratch),hl  		; save pos for later 
1b35			 
1b35			 
1b35			; display decoding address 
1b35 2a c6 f2		   	ld hl,(os_cur_ptr) 
1b38			 
1b38 7c				ld a,h 
1b39 e1				pop hl 
1b3a e5				push hl 
1b3b			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1b3b cd 07 10			call hexout 
1b3e 2a c6 f2		   	ld hl,(os_cur_ptr) 
1b41			 
1b41 7d				ld a,l 
1b42 e1				pop hl 
1b43 23				inc hl 
1b44 23				inc hl 
1b45 e5				push hl 
1b46			;	ld hl, os_word_scratch+2 
1b46 cd 07 10			call hexout 
1b49 e1				pop hl 
1b4a 23				inc hl 
1b4b 23				inc hl 
1b4c				;ld hl, os_word_scratch+4 
1b4c 3e 3a			ld a, ':' 
1b4e 77				ld (hl),a 
1b4f 23				inc hl 
1b50				;ld a, 0 
1b50				;ld (hl),a 
1b50				;ld de, os_word_scratch 
1b50				;pop af 
1b50				;push af 
1b50			;		ld a, display_row_2 
1b50			;		call str_at_display 
1b50			;		call update_display 
1b50			 
1b50			 
1b50			;pop af 
1b50			;	add 5 
1b50			 
1b50			if display_cols == 20 
1b50 06 04			ld b, 4 
1b52			else 
1b52				ld b, 8 
1b52			endif	 
1b52			 
1b52			.dumpbyte: 
1b52 c5				push bc 
1b53 e5				push hl 
1b54			 
1b54			 
1b54 2a c6 f2		   	ld hl,(os_cur_ptr) 
1b57 7e					ld a,(hl) 
1b58			 
1b58					; poke the ascii to display 
1b58 2a a8 f2				ld hl,(os_word_scratch) 
1b5b 77					ld (hl),a 
1b5c 23					inc hl 
1b5d 22 a8 f2				ld (os_word_scratch),hl 
1b60			 
1b60					 
1b60			 
1b60			 
1b60 e1					pop hl 
1b61 e5					push hl 
1b62			 
1b62 cd 07 10				call hexout 
1b65			 
1b65					 
1b65 2a c6 f2		   	ld hl,(os_cur_ptr) 
1b68 23				inc hl 
1b69 22 c6 f2		   	ld (os_cur_ptr),hl 
1b6c			 
1b6c e1					pop hl 
1b6d 23					inc hl 
1b6e 23					inc hl 
1b6f 23					inc hl 
1b70			 
1b70			 
1b70			 
1b70					;ld a,0 
1b70					;ld (os_word_scratch+2),a 
1b70					;pop af 
1b70					;push af 
1b70			 
1b70					;ld de, os_word_scratch 
1b70					;call str_at_display 
1b70			;		call update_display 
1b70			;		pop af 
1b70 c1					pop bc 
1b71 c6 03				add 3 
1b73 10 dd			djnz .dumpbyte 
1b75			 
1b75				 
1b75			 
1b75 c9				ret 
1b76			 
1b76			jump:	 
1b76			 
1b76 21 a5 ef			ld hl,scratch+2 
1b79 cd bd 10			call get_word_hl 
1b7c				;ld hl,(scratch+2) 
1b7c				;call fourehexhl 
1b7c			 
1b7c 22 c6 f2			ld (os_cur_ptr),hl	 
1b7f			 
1b7f e9				jp (hl) 
1b80			 
1b80			 
1b80			 
1b80			; TODO implement a basic monitor mode to start with 
1b80			 
1b80			 
1b80			 
1b80			 
1b80			 
1b80			 
1b80			 
1b80			 
1b80			 
1b80			; testing and demo code during development 
1b80			 
1b80			 
1b80 .. 00		str1: db "Enter some text...",0 
1b93 .. 00		clear: db "                    ",0 
1ba8			 
1ba8			demo: 
1ba8			 
1ba8			 
1ba8			 
1ba8			;	call update_display 
1ba8			 
1ba8				; init scratch input area for testing 
1ba8 21 a3 ef			ld hl, scratch	 
1bab 3e 00			ld a,0 
1bad 77				ld (hl),a 
1bae			 
1bae			 
1bae 3e 14		            LD   A, display_row_2 
1bb0			;            CALL fLCD_Pos       ;Position cursor to location in A 
1bb0 11 80 1b		            LD   DE, str1 
1bb3 cd e5 0a			call str_at_display 
1bb6			 
1bb6			;            CALL fLCD_Str       ;Display string pointed to by DE 
1bb6			cloop:	 
1bb6 3e 28		            LD   A, display_row_3 
1bb8			;            CALL fLCD_Pos       ;Position cursor to location in A 
1bb8 11 93 1b		            LD   DE, clear 
1bbb			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1bbb cd e5 0a				call str_at_display 
1bbe 3e 3c			ld a, display_row_4 
1bc0 11 f0 1b			ld de, prompt 
1bc3			 
1bc3 cd e5 0a				call str_at_display 
1bc6 cd f5 0a			call update_display 
1bc9			 
1bc9 3e 55			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1bcb 16 0a			ld d, 10 
1bcd 21 a3 ef			ld hl, scratch	 
1bd0 cd 33 0d			call input_str 
1bd3			 
1bd3			;	call clear_display 
1bd3			;'	call update_display 
1bd3			 
1bd3 3e 00		            LD   A, display_row_1 
1bd5			;            CALL fLCD_Pos       ;Position cursor to location in A 
1bd5 11 93 1b		            LD   DE, clear 
1bd8 cd e5 0a				call str_at_display 
1bdb			;            CALL fLCD_Str       ;Display string pointed to by DE 
1bdb 3e 00		            LD   A, display_row_1 
1bdd			;            CALL fLCD_Pos       ;Position cursor to location in A 
1bdd 11 a3 ef		            LD   DE, scratch 
1be0			;            CALL fLCD_Str       ;Display string pointed to by DE 
1be0 cd e5 0a				call str_at_display 
1be3 cd f5 0a			call update_display 
1be6			 
1be6 3e 00				ld a,0 
1be8 21 a3 ef			ld hl, scratch 
1beb 77				ld (hl),a 
1bec			 
1bec 00				nop 
1bed c3 b6 1b			jp cloop 
1bf0			 
1bf0			 
1bf0			 
1bf0			; OS Prompt 
1bf0			 
1bf0 .. 00		prompt: db ">",0 
1bf2 .. 00		endprg: db "?",0 
1bf4			 
1bf4			 
1bf4			; handy next page prompt 
1bf4			next_page_prompt: 
1bf4 e5				push hl 
1bf5 d5				push de 
1bf6 f5				push af 
1bf7 c5				push bc 
1bf8			 
1bf8 3e 4f			ld a,display_row_4 + display_cols - 1 
1bfa 11 f2 1b		        ld de, endprg 
1bfd cd e5 0a			call str_at_display 
1c00 cd f5 0a			call update_display 
1c03 cd fc 67			call cin_wait 
1c06 c1				pop bc 
1c07 f1				pop af 
1c08 d1				pop de 
1c09 e1				pop hl 
1c0a			 
1c0a			 
1c0a c9				ret 
1c0b			 
1c0b			 
1c0b			; forth parser 
1c0b			 
1c0b			; My forth kernel 
1c0b			include "forth_kernel.asm" 
1c0b			; 
1c0b			; kernel to the forth OS 
1c0b			 
1c0b			DS_TYPE_STR: equ 1     ; string type 
1c0b			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1c0b			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1c0b			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1c0b			 
1c0b			FORTH_PARSEV1: equ 0 
1c0b			FORTH_PARSEV2: equ 0 
1c0b			FORTH_PARSEV3: equ 0 
1c0b			FORTH_PARSEV4: equ 0 
1c0b			FORTH_PARSEV5: equ 1 
1c0b			 
1c0b			;if FORTH_PARSEV5 
1c0b			;	FORTH_END_BUFFER: equ 0 
1c0b			;else 
1c0b			FORTH_END_BUFFER: equ 127 
1c0b			;endif 
1c0b			 
1c0b			FORTH_TRUE: equ 1 
1c0b			FORTH_FALSE: equ 0 
1c0b			 
1c0b			if FORTH_PARSEV4 
1c0b			include "forth_stackops.asm" 
1c0b			endif 
1c0b			 
1c0b			if FORTH_PARSEV5 
1c0b			include "forth_stackopsv5.asm" 
1c0b			 
1c0b			; Stack operations for v5 parser on wards 
1c0b			; * DATA stack 
1c0b			; * LOOP stack 
1c0b			; * RETURN stack 
1c0b			 
1c0b			 
1c0b			 
1c0b			FORTH_CHK_DSP_UNDER: macro 
1c0b				push hl 
1c0b				push de 
1c0b				ld hl,(cli_data_sp) 
1c0b				ld de, cli_data_stack 
1c0b				call cmp16 
1c0b				jp c, fault_dsp_under 
1c0b				pop de 
1c0b				pop hl 
1c0b				endm 
1c0b			 
1c0b			 
1c0b			FORTH_CHK_RSP_UNDER: macro 
1c0b				push hl 
1c0b				push de 
1c0b				ld hl,(cli_ret_sp) 
1c0b				ld de, cli_ret_stack 
1c0b				call cmp16 
1c0b				jp c, fault_rsp_under 
1c0b				pop de 
1c0b				pop hl 
1c0b				endm 
1c0b			 
1c0b			FORTH_CHK_LOOP_UNDER: macro 
1c0b				push hl 
1c0b				push de 
1c0b				ld hl,(cli_loop_sp) 
1c0b				ld de, cli_loop_stack 
1c0b				call cmp16 
1c0b				jp c, fault_loop_under 
1c0b				pop de 
1c0b				pop hl 
1c0b				endm 
1c0b			 
1c0b			FORTH_ERR_TOS_NOTSTR: macro 
1c0b				; TOSO might need more for checks when used 
1c0b				push af 
1c0b				ld a,(hl) 
1c0b				cp DS_TYPE_STR 
1c0b				jp nz, type_faultn   
1c0b				pop af 
1c0b				endm 
1c0b			 
1c0b			FORTH_ERR_TOS_NOTNUM: macro 
1c0b				push af 
1c0b				ld a,(hl) 
1c0b				cp DS_TYPE_INUM 
1c0b				jp nz, type_faultn   
1c0b				pop af 
1c0b				endm 
1c0b			 
1c0b			 
1c0b			; increase data stack pointer and save hl to it 
1c0b				 
1c0b			FORTH_DSP_NEXT: macro 
1c0b				call macro_forth_dsp_next 
1c0b				endm 
1c0b			 
1c0b			 
1c0b			macro_forth_dsp_next: 
1c0b				if DEBUG_FORTH_STACK_GUARD 
1c0b cd 12 63				call check_stacks 
1c0e				endif 
1c0e e5				push hl 
1c0f d5				push de 
1c10 eb				ex de,hl 
1c11 2a 90 f9			ld hl,(cli_data_sp) 
1c14 23				inc hl 
1c15 23				inc hl 
1c16			 
1c16			; PARSEV5 
1c16 23				inc hl 
1c17 22 90 f9			ld (cli_data_sp),hl 
1c1a 73				ld (hl), e 
1c1b 23				inc hl 
1c1c 72				ld (hl), d 
1c1d d1				pop de 
1c1e e1				pop hl 
1c1f				if DEBUG_FORTH_STACK_GUARD 
1c1f cd 12 63				call check_stacks 
1c22				endif 
1c22 c9				ret 
1c23			 
1c23			 
1c23			; increase ret stack pointer and save hl to it 
1c23				 
1c23			FORTH_RSP_NEXT: macro 
1c23				call macro_forth_rsp_next 
1c23				endm 
1c23			 
1c23			macro_forth_rsp_next: 
1c23				if DEBUG_FORTH_STACK_GUARD 
1c23 cd 12 63				call check_stacks 
1c26				endif 
1c26 e5				push hl 
1c27 d5				push de 
1c28 eb				ex de,hl 
1c29 2a 94 f9			ld hl,(cli_ret_sp) 
1c2c 23				inc hl 
1c2d 23				inc hl 
1c2e 22 94 f9			ld (cli_ret_sp),hl 
1c31 73				ld (hl), e 
1c32 23				inc hl 
1c33 72				ld (hl), d 
1c34 d1				pop de 
1c35 e1				pop hl 
1c36				if DEBUG_FORTH_STACK_GUARD 
1c36 cd 12 63				call check_stacks 
1c39				endif 
1c39 c9				ret 
1c3a			 
1c3a			; get current ret stack pointer and save to hl  
1c3a				 
1c3a			FORTH_RSP_TOS: macro 
1c3a				call macro_forth_rsp_tos 
1c3a				endm 
1c3a			 
1c3a			macro_forth_rsp_tos: 
1c3a				;push de 
1c3a 2a 94 f9			ld hl,(cli_ret_sp) 
1c3d cd 75 1c			call loadhlptrtohl 
1c40				;ld e, (hl) 
1c40				;inc hl 
1c40				;ld d, (hl) 
1c40				;ex de, hl 
1c40					if DEBUG_FORTH_WORDS 
1c40			;			DMARK "RST" 
1c40						CALLMONITOR 
1c40 cd ec 16			call break_point_state  
1c43				endm  
# End of macro CALLMONITOR
1c43					endif 
1c43				;pop de 
1c43 c9				ret 
1c44			 
1c44			; pop ret stack pointer 
1c44				 
1c44			FORTH_RSP_POP: macro 
1c44				call macro_forth_rsp_pop 
1c44				endm 
1c44			 
1c44			 
1c44			macro_forth_rsp_pop: 
1c44				if DEBUG_FORTH_STACK_GUARD 
1c44			;		DMARK "RPP" 
1c44 cd 12 63				call check_stacks 
1c47					FORTH_CHK_RSP_UNDER 
1c47 e5				push hl 
1c48 d5				push de 
1c49 2a 94 f9			ld hl,(cli_ret_sp) 
1c4c 11 0e f9			ld de, cli_ret_stack 
1c4f cd 24 0d			call cmp16 
1c52 da 26 64			jp c, fault_rsp_under 
1c55 d1				pop de 
1c56 e1				pop hl 
1c57				endm 
# End of macro FORTH_CHK_RSP_UNDER
1c57				endif 
1c57 e5				push hl 
1c58 2a 94 f9			ld hl,(cli_ret_sp) 
1c5b			 
1c5b			 
1c5b				if FORTH_ENABLE_FREE 
1c5b			 
1c5b					; get pointer 
1c5b			 
1c5b					push de 
1c5b					push hl 
1c5b			 
1c5b					ld e, (hl) 
1c5b					inc hl 
1c5b					ld d, (hl) 
1c5b			 
1c5b					ex de, hl 
1c5b					call free 
1c5b			 
1c5b					pop hl 
1c5b					pop de 
1c5b			 
1c5b			 
1c5b				endif 
1c5b			 
1c5b			 
1c5b 2b				dec hl 
1c5c 2b				dec hl 
1c5d 22 94 f9			ld (cli_ret_sp), hl 
1c60				; do stack underflow checks 
1c60 e1				pop hl 
1c61				if DEBUG_FORTH_STACK_GUARD 
1c61 cd 12 63				call check_stacks 
1c64					FORTH_CHK_RSP_UNDER 
1c64 e5				push hl 
1c65 d5				push de 
1c66 2a 94 f9			ld hl,(cli_ret_sp) 
1c69 11 0e f9			ld de, cli_ret_stack 
1c6c cd 24 0d			call cmp16 
1c6f da 26 64			jp c, fault_rsp_under 
1c72 d1				pop de 
1c73 e1				pop hl 
1c74				endm 
# End of macro FORTH_CHK_RSP_UNDER
1c74				endif 
1c74 c9				ret 
1c75			 
1c75			 
1c75			 
1c75			; routine to load word pointed to by hl into hl 
1c75			 
1c75			loadhlptrtohl: 
1c75			 
1c75 d5				push de 
1c76 5e				ld e, (hl) 
1c77 23				inc hl 
1c78 56				ld d, (hl) 
1c79 eb				ex de, hl 
1c7a d1				pop de 
1c7b			 
1c7b c9				ret 
1c7c			 
1c7c			 
1c7c			 
1c7c			 
1c7c			 
1c7c			; push a number held in HL onto the data stack 
1c7c			; entry point for pushing a value when already in hl used in function above 
1c7c			 
1c7c			forth_push_numhl: 
1c7c			 
1c7c e5				push hl    ; save value to push 
1c7d			 
1c7d			if DEBUG_FORTH_PUSH 
1c7d				; see if disabled 
1c7d			 
1c7d			 
1c7d f5				push af 
1c7e 3a 94 ef			ld a, (os_view_disable) 
1c81 fe 2a			cp '*' 
1c83 28 34			jr z, .pskip2 
1c85 e5				push hl 
1c86 e5			push hl 
1c87 cd d2 0a			call clear_display 
1c8a e1			pop hl 
1c8b 7c				ld a,h 
1c8c 21 a8 f2			ld hl, os_word_scratch 
1c8f cd 07 10			call hexout 
1c92 e1				pop hl 
1c93 7d				ld a,l 
1c94 21 aa f2			ld hl, os_word_scratch+2 
1c97 cd 07 10			call hexout 
1c9a			 
1c9a 21 ac f2			ld hl, os_word_scratch+4 
1c9d 3e 00			ld a,0 
1c9f 77				ld (hl),a 
1ca0 11 a8 f2			ld de,os_word_scratch 
1ca3 3e 14				ld a, display_row_2 
1ca5 cd e5 0a				call str_at_display 
1ca8 11 20 52			ld de, .push_num 
1cab 3e 00			ld a, display_row_1 
1cad			 
1cad cd e5 0a				call str_at_display 
1cb0			 
1cb0			 
1cb0 cd f5 0a			call update_display 
1cb3 cd 52 0a			call delay1s 
1cb6 cd 52 0a			call delay1s 
1cb9			.pskip2:  
1cb9			 
1cb9 f1				pop af 
1cba			endif	 
1cba			 
1cba			 
1cba				FORTH_DSP_NEXT 
1cba cd 0b 1c			call macro_forth_dsp_next 
1cbd				endm 
# End of macro FORTH_DSP_NEXT
1cbd			 
1cbd 2a 90 f9			ld hl, (cli_data_sp) 
1cc0			 
1cc0				; save item type 
1cc0 3e 02			ld a,  DS_TYPE_INUM 
1cc2 77				ld (hl), a 
1cc3 23				inc hl 
1cc4			 
1cc4				; get word off stack 
1cc4 d1				pop de 
1cc5 7b				ld a,e 
1cc6 77				ld (hl), a 
1cc7 23				inc hl 
1cc8 7a				ld a,d 
1cc9 77				ld (hl), a 
1cca			 
1cca			if DEBUG_FORTH_PUSH 
1cca 2b				dec hl 
1ccb 2b				dec hl 
1ccc 2b				dec hl 
1ccd						DMARK "PH5" 
1ccd f5				push af  
1cce 3a e2 1c			ld a, (.dmark)  
1cd1 32 bd fb			ld (debug_mark),a  
1cd4 3a e3 1c			ld a, (.dmark+1)  
1cd7 32 be fb			ld (debug_mark+1),a  
1cda 3a e4 1c			ld a, (.dmark+2)  
1cdd 32 bf fb			ld (debug_mark+2),a  
1ce0 18 03			jr .pastdmark  
1ce2 ..			.dmark: db "PH5"  
1ce5 f1			.pastdmark: pop af  
1ce6			endm  
# End of macro DMARK
1ce6				CALLMONITOR 
1ce6 cd ec 16			call break_point_state  
1ce9				endm  
# End of macro CALLMONITOR
1ce9			endif	 
1ce9			 
1ce9 c9				ret 
1cea			 
1cea			 
1cea			; Push a string to stack pointed to by hl 
1cea			 
1cea			forth_push_str: 
1cea			 
1cea			if DEBUG_FORTH_PUSH 
1cea						DMARK "PSQ" 
1cea f5				push af  
1ceb 3a ff 1c			ld a, (.dmark)  
1cee 32 bd fb			ld (debug_mark),a  
1cf1 3a 00 1d			ld a, (.dmark+1)  
1cf4 32 be fb			ld (debug_mark+1),a  
1cf7 3a 01 1d			ld a, (.dmark+2)  
1cfa 32 bf fb			ld (debug_mark+2),a  
1cfd 18 03			jr .pastdmark  
1cff ..			.dmark: db "PSQ"  
1d02 f1			.pastdmark: pop af  
1d03			endm  
# End of macro DMARK
1d03				CALLMONITOR 
1d03 cd ec 16			call break_point_state  
1d06				endm  
# End of macro CALLMONITOR
1d06			endif	 
1d06			    
1d06 e5				push hl 
1d07 e5				push hl 
1d08			 
1d08			;	ld a, 0   ; find end of string 
1d08 cd 64 11			call strlenz 
1d0b			if DEBUG_FORTH_PUSH 
1d0b						DMARK "PQ2" 
1d0b f5				push af  
1d0c 3a 20 1d			ld a, (.dmark)  
1d0f 32 bd fb			ld (debug_mark),a  
1d12 3a 21 1d			ld a, (.dmark+1)  
1d15 32 be fb			ld (debug_mark+1),a  
1d18 3a 22 1d			ld a, (.dmark+2)  
1d1b 32 bf fb			ld (debug_mark+2),a  
1d1e 18 03			jr .pastdmark  
1d20 ..			.dmark: db "PQ2"  
1d23 f1			.pastdmark: pop af  
1d24			endm  
# End of macro DMARK
1d24				CALLMONITOR 
1d24 cd ec 16			call break_point_state  
1d27				endm  
# End of macro CALLMONITOR
1d27			endif	 
1d27 eb				ex de, hl 
1d28 e1				pop hl   ; get ptr to start of string 
1d29			if DEBUG_FORTH_PUSH 
1d29						DMARK "PQ3" 
1d29 f5				push af  
1d2a 3a 3e 1d			ld a, (.dmark)  
1d2d 32 bd fb			ld (debug_mark),a  
1d30 3a 3f 1d			ld a, (.dmark+1)  
1d33 32 be fb			ld (debug_mark+1),a  
1d36 3a 40 1d			ld a, (.dmark+2)  
1d39 32 bf fb			ld (debug_mark+2),a  
1d3c 18 03			jr .pastdmark  
1d3e ..			.dmark: db "PQ3"  
1d41 f1			.pastdmark: pop af  
1d42			endm  
# End of macro DMARK
1d42				CALLMONITOR 
1d42 cd ec 16			call break_point_state  
1d45				endm  
# End of macro CALLMONITOR
1d45			endif	 
1d45 19				add hl,de 
1d46			if DEBUG_FORTH_PUSH 
1d46						DMARK "PQE" 
1d46 f5				push af  
1d47 3a 5b 1d			ld a, (.dmark)  
1d4a 32 bd fb			ld (debug_mark),a  
1d4d 3a 5c 1d			ld a, (.dmark+1)  
1d50 32 be fb			ld (debug_mark+1),a  
1d53 3a 5d 1d			ld a, (.dmark+2)  
1d56 32 bf fb			ld (debug_mark+2),a  
1d59 18 03			jr .pastdmark  
1d5b ..			.dmark: db "PQE"  
1d5e f1			.pastdmark: pop af  
1d5f			endm  
# End of macro DMARK
1d5f				CALLMONITOR 
1d5f cd ec 16			call break_point_state  
1d62				endm  
# End of macro CALLMONITOR
1d62			endif	 
1d62			 
1d62 2b				dec hl    ; see if there is an optional trailing double quote 
1d63 7e				ld a,(hl) 
1d64 fe 22			cp '"' 
1d66 20 03			jr nz, .strnoq 
1d68 3e 00			ld a, 0      ; get rid of double quote 
1d6a 77				ld (hl), a 
1d6b 23			.strnoq: inc hl 
1d6c			 
1d6c 3e 00			ld a, 0 
1d6e 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1d6f			 
1d6f 13				inc de ; add one for the type string 
1d70 13				inc de ; add one for null term??? 
1d71			 
1d71				; tos is get string pointer again 
1d71				; de contains space to allocate 
1d71				 
1d71 d5				push de 
1d72			 
1d72 eb				ex de, hl 
1d73			 
1d73				;push af 
1d73			 
1d73			if DEBUG_FORTH_PUSH 
1d73						DMARK "PHm" 
1d73 f5				push af  
1d74 3a 88 1d			ld a, (.dmark)  
1d77 32 bd fb			ld (debug_mark),a  
1d7a 3a 89 1d			ld a, (.dmark+1)  
1d7d 32 be fb			ld (debug_mark+1),a  
1d80 3a 8a 1d			ld a, (.dmark+2)  
1d83 32 bf fb			ld (debug_mark+2),a  
1d86 18 03			jr .pastdmark  
1d88 ..			.dmark: db "PHm"  
1d8b f1			.pastdmark: pop af  
1d8c			endm  
# End of macro DMARK
1d8c				CALLMONITOR 
1d8c cd ec 16			call break_point_state  
1d8f				endm  
# End of macro CALLMONITOR
1d8f			endif	 
1d8f cd cd 11			call malloc	; on ret hl now contains allocated memory 
1d92				if DEBUG_FORTH_MALLOC_GUARD 
1d92 cc 78 52				call z,malloc_error 
1d95				endif 
1d95			 
1d95				 
1d95 c1				pop bc    ; get length 
1d96 d1				pop de   ;  get string start    
1d97			 
1d97				; hl has destination from malloc 
1d97			 
1d97 eb				ex de, hl    ; prep for ldir 
1d98			 
1d98 d5				push de   ; save malloc area for DSP later 
1d99				;push hl   ; save malloc area for DSP later 
1d99			 
1d99			if DEBUG_FORTH_PUSH 
1d99						DMARK "PHc" 
1d99 f5				push af  
1d9a 3a ae 1d			ld a, (.dmark)  
1d9d 32 bd fb			ld (debug_mark),a  
1da0 3a af 1d			ld a, (.dmark+1)  
1da3 32 be fb			ld (debug_mark+1),a  
1da6 3a b0 1d			ld a, (.dmark+2)  
1da9 32 bf fb			ld (debug_mark+2),a  
1dac 18 03			jr .pastdmark  
1dae ..			.dmark: db "PHc"  
1db1 f1			.pastdmark: pop af  
1db2			endm  
# End of macro DMARK
1db2				CALLMONITOR 
1db2 cd ec 16			call break_point_state  
1db5				endm  
# End of macro CALLMONITOR
1db5			endif	 
1db5			 
1db5			 
1db5 ed b0			ldir 
1db7			 
1db7			 
1db7				; push malloc to data stack     macro?????  
1db7			 
1db7				FORTH_DSP_NEXT 
1db7 cd 0b 1c			call macro_forth_dsp_next 
1dba				endm 
# End of macro FORTH_DSP_NEXT
1dba			 
1dba				; save value and type 
1dba			 
1dba 2a 90 f9			ld hl, (cli_data_sp) 
1dbd			 
1dbd				; save item type 
1dbd 3e 01			ld a,  DS_TYPE_STR 
1dbf 77				ld (hl), a 
1dc0 23				inc hl 
1dc1			 
1dc1				; get malloc word off stack 
1dc1 d1				pop de 
1dc2 73				ld (hl), e 
1dc3 23				inc hl 
1dc4 72				ld (hl), d 
1dc5			 
1dc5			 
1dc5			 
1dc5			if DEBUG_FORTH_PUSH 
1dc5 2a 90 f9			ld hl, (cli_data_sp) 
1dc8						DMARK "PHS" 
1dc8 f5				push af  
1dc9 3a dd 1d			ld a, (.dmark)  
1dcc 32 bd fb			ld (debug_mark),a  
1dcf 3a de 1d			ld a, (.dmark+1)  
1dd2 32 be fb			ld (debug_mark+1),a  
1dd5 3a df 1d			ld a, (.dmark+2)  
1dd8 32 bf fb			ld (debug_mark+2),a  
1ddb 18 03			jr .pastdmark  
1ddd ..			.dmark: db "PHS"  
1de0 f1			.pastdmark: pop af  
1de1			endm  
# End of macro DMARK
1de1				CALLMONITOR 
1de1 cd ec 16			call break_point_state  
1de4				endm  
# End of macro CALLMONITOR
1de4			;	ex de,hl 
1de4			endif	 
1de4				; in case of spaces, skip the ptr past the copied string 
1de4				;pop af 
1de4				;ld (cli_origptr),hl 
1de4			 
1de4 c9				ret 
1de5			 
1de5			 
1de5			 
1de5			; TODO ascii push input onto stack given hl to start of input 
1de5			 
1de5			; identify type 
1de5			; if starts with a " then a string 
1de5			; otherwise it is a number 
1de5			;  
1de5			; if a string 
1de5			;     scan for ending " to get length of string to malloc for + 1 
1de5			;     malloc 
1de5			;     put pointer to string on stack first byte flags as string 
1de5			; 
1de5			; else a number 
1de5			;    look for number format identifier 
1de5			;    $xx hex 
1de5			;    %xxxxx bin 
1de5			;    xxxxx decimal 
1de5			;    convert number to 16bit word.  
1de5			;    malloc word + 1 with flag to identiy as num 
1de5			;    put pointer to number on stack 
1de5			;   
1de5			;  
1de5			  
1de5			forth_apush: 
1de5				; kernel push 
1de5			 
1de5			if DEBUG_FORTH_PUSH 
1de5						DMARK "PSH" 
1de5 f5				push af  
1de6 3a fa 1d			ld a, (.dmark)  
1de9 32 bd fb			ld (debug_mark),a  
1dec 3a fb 1d			ld a, (.dmark+1)  
1def 32 be fb			ld (debug_mark+1),a  
1df2 3a fc 1d			ld a, (.dmark+2)  
1df5 32 bf fb			ld (debug_mark+2),a  
1df8 18 03			jr .pastdmark  
1dfa ..			.dmark: db "PSH"  
1dfd f1			.pastdmark: pop af  
1dfe			endm  
# End of macro DMARK
1dfe				CALLMONITOR 
1dfe cd ec 16			call break_point_state  
1e01				endm  
# End of macro CALLMONITOR
1e01			endif	 
1e01				; identify input type 
1e01			 
1e01 7e				ld a,(hl) 
1e02 fe 22			cp '"' 
1e04 28 0a			jr z, .fapstr 
1e06 fe 24			cp '$' 
1e08 ca 30 1e			jp z, .faphex 
1e0b fe 25			cp '%' 
1e0d ca 18 1e			jp z, .fapbin 
1e10			;	cp 'b' 
1e10			;	jp z, .fabin 
1e10				; else decimal 
1e10			 
1e10				; TODO do decimal conversion 
1e10				; decimal is stored as a 16bit word 
1e10			 
1e10				; by default everything is a string if type is not detected 
1e10			.fapstr: ; 
1e10 fe 22			cp '"' 
1e12 20 01			jr nz, .strnoqu 
1e14 23				inc hl 
1e15			.strnoqu: 
1e15 c3 ea 1c			jp forth_push_str 
1e18			 
1e18			 
1e18			 
1e18			.fapbin:    ; push a binary string.  
1e18 11 00 00			ld de, 0   ; hold a 16bit value 
1e1b			 
1e1b 23			.fapbinshift:	inc hl  
1e1c 7e				ld a,(hl) 
1e1d fe 00			cp 0     ; done scanning  
1e1f 28 0b			jr z, .fapbdone  	; got it in HL so push  
1e21			 
1e21				; left shift de 
1e21 eb				ex de, hl	 
1e22 29				add hl, hl 
1e23			 
1e23				; is 1 
1e23 fe 31			cp '1' 
1e25 20 02			jr nz, .binzero 
1e27 cb 4d			bit 1, l 
1e29			.binzero: 
1e29 eb				ex de, hl	 ; save current de 
1e2a 18 ef			jr .fapbinshift 
1e2c			 
1e2c			.fapbdone: 
1e2c eb				ex de, hl 
1e2d c3 7c 1c			jp forth_push_numhl 
1e30			 
1e30			 
1e30			.faphex:   ; hex is always stored as a 16bit word 
1e30				; skip number prefix 
1e30 23				inc hl 
1e31				; turn ascii into number 
1e31 cd bd 10			call get_word_hl	; ret 16bit word in hl 
1e34			 
1e34 c3 7c 1c			jp forth_push_numhl 
1e37			 
1e37 00				 nop 
1e38			 
1e38			.fabin:   ; TODO bin conversion 
1e38			 
1e38			 
1e38 c9				ret 
1e39			 
1e39			 
1e39			; get either a string ptr or a 16bit word from the data stack 
1e39			 
1e39			FORTH_DSP: macro 
1e39				call macro_forth_dsp 
1e39				endm 
1e39			 
1e39			macro_forth_dsp: 
1e39				; data stack pointer points to current word on tos 
1e39			 
1e39 2a 90 f9			ld hl,(cli_data_sp) 
1e3c			 
1e3c				if DEBUG_FORTH_PUSH 
1e3c						DMARK "DSP" 
1e3c f5				push af  
1e3d 3a 51 1e			ld a, (.dmark)  
1e40 32 bd fb			ld (debug_mark),a  
1e43 3a 52 1e			ld a, (.dmark+1)  
1e46 32 be fb			ld (debug_mark+1),a  
1e49 3a 53 1e			ld a, (.dmark+2)  
1e4c 32 bf fb			ld (debug_mark+2),a  
1e4f 18 03			jr .pastdmark  
1e51 ..			.dmark: db "DSP"  
1e54 f1			.pastdmark: pop af  
1e55			endm  
# End of macro DMARK
1e55			 
1e55 cd ad 52				call display_data_sp 
1e58				;call break_point_state 
1e58				;rst 030h 
1e58				CALLMONITOR 
1e58 cd ec 16			call break_point_state  
1e5b				endm  
# End of macro CALLMONITOR
1e5b				endif 
1e5b			 
1e5b c9				ret 
1e5c			 
1e5c			; return hl to start of value on stack 
1e5c			 
1e5c			FORTH_DSP_VALUE: macro 
1e5c				call macro_forth_dsp_value 
1e5c				endm 
1e5c			 
1e5c			macro_forth_dsp_value: 
1e5c			 
1e5c				FORTH_DSP 
1e5c cd 39 1e			call macro_forth_dsp 
1e5f				endm 
# End of macro FORTH_DSP
1e5f			 
1e5f d5				push de 
1e60			 
1e60 23				inc hl ; skip type 
1e61			 
1e61 5e				ld e, (hl) 
1e62 23				inc hl 
1e63 56				ld d, (hl) 
1e64 eb				ex de,hl  
1e65			 
1e65 d1				pop de 
1e66			 
1e66 c9				ret 
1e67			 
1e67			; return hl to start of value to second item on stack 
1e67			 
1e67			FORTH_DSP_VALUEM1: macro 
1e67				call macro_forth_dsp_value_m1 
1e67				endm 
1e67			 
1e67			macro_forth_dsp_value_m1: 
1e67			 
1e67				FORTH_DSP 
1e67 cd 39 1e			call macro_forth_dsp 
1e6a				endm 
# End of macro FORTH_DSP
1e6a			 
1e6a 2b				dec hl 
1e6b 2b				dec hl 
1e6c			;	dec hl 
1e6c			 
1e6c d5				push de 
1e6d			 
1e6d 5e				ld e, (hl) 
1e6e 23				inc hl 
1e6f 56				ld d, (hl) 
1e70 eb				ex de,hl  
1e71			 
1e71 d1				pop de 
1e72			 
1e72 c9				ret 
1e73			 
1e73				 
1e73			 
1e73			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1e73			 
1e73			FORTH_DSP_POP: macro 
1e73				call macro_forth_dsp_pop 
1e73				endm 
1e73			 
1e73			 
1e73			; get the tos data type 
1e73			 
1e73			FORTH_DSP_TYPE:   macro 
1e73			 
1e73				;FORTH_DSP_VALUE 
1e73				FORTH_DSP 
1e73				 
1e73				; hl points to value 
1e73				; check type 
1e73			 
1e73				ld a,(hl) 
1e73			 
1e73				endm 
1e73			 
1e73			; load the tos value into hl 
1e73			 
1e73			 
1e73			FORTH_DSP_VALUEHL:  macro 
1e73				call macro_dsp_valuehl 
1e73				endm 
1e73			 
1e73			 
1e73			 
1e73			macro_dsp_valuehl: 
1e73				FORTH_DSP_VALUE 
1e73 cd 5c 1e			call macro_forth_dsp_value 
1e76				endm 
# End of macro FORTH_DSP_VALUE
1e76			 
1e76				;FORTH_ERR_TOS_NOTNUM 
1e76			 
1e76				;inc hl   ; skip type id 
1e76			 
1e76			;	push de 
1e76			; 
1e76			;	ld e, (hl) 
1e76			;	inc hl 
1e76			;	ld d, (hl) 
1e76			;	ex de,hl  
1e76			 
1e76			;	pop de 
1e76			 
1e76				if DEBUG_FORTH_PUSH 
1e76						DMARK "DVL" 
1e76 f5				push af  
1e77 3a 8b 1e			ld a, (.dmark)  
1e7a 32 bd fb			ld (debug_mark),a  
1e7d 3a 8c 1e			ld a, (.dmark+1)  
1e80 32 be fb			ld (debug_mark+1),a  
1e83 3a 8d 1e			ld a, (.dmark+2)  
1e86 32 bf fb			ld (debug_mark+2),a  
1e89 18 03			jr .pastdmark  
1e8b ..			.dmark: db "DVL"  
1e8e f1			.pastdmark: pop af  
1e8f			endm  
# End of macro DMARK
1e8f				CALLMONITOR 
1e8f cd ec 16			call break_point_state  
1e92				endm  
# End of macro CALLMONITOR
1e92				endif 
1e92 c9				ret 
1e93			 
1e93			forth_apushstrhl:      
1e93				; push of string requires use of cli_origptr 
1e93				; bodge use 
1e93			 
1e93				; get current cli_origptr, save, update with temp pointer  
1e93 ed 5b ac f9		ld de, (cli_origptr) 
1e97 22 ac f9			ld (cli_origptr), hl 
1e9a d5				push de 
1e9b cd e5 1d			call forth_apush 
1e9e d1				pop de 
1e9f ed 53 ac f9		ld (cli_origptr), de 
1ea3 c9			        ret	 
1ea4			 
1ea4			 
1ea4			; increase loop stack pointer and save hl to it 
1ea4				 
1ea4			FORTH_LOOP_NEXT: macro 
1ea4				call macro_forth_loop_next 
1ea4				;nop 
1ea4				endm 
1ea4			 
1ea4			macro_forth_loop_next: 
1ea4				if DEBUG_FORTH_STACK_GUARD 
1ea4 cd 12 63				call check_stacks 
1ea7				endif 
1ea7 e5				push hl 
1ea8 d5				push de 
1ea9 eb				ex de,hl 
1eaa 2a 92 f9			ld hl,(cli_loop_sp) 
1ead 23				inc hl 
1eae 23				inc hl 
1eaf					if DEBUG_FORTH_WORDS 
1eaf						DMARK "LNX" 
1eaf f5				push af  
1eb0 3a c4 1e			ld a, (.dmark)  
1eb3 32 bd fb			ld (debug_mark),a  
1eb6 3a c5 1e			ld a, (.dmark+1)  
1eb9 32 be fb			ld (debug_mark+1),a  
1ebc 3a c6 1e			ld a, (.dmark+2)  
1ebf 32 bf fb			ld (debug_mark+2),a  
1ec2 18 03			jr .pastdmark  
1ec4 ..			.dmark: db "LNX"  
1ec7 f1			.pastdmark: pop af  
1ec8			endm  
# End of macro DMARK
1ec8						CALLMONITOR 
1ec8 cd ec 16			call break_point_state  
1ecb				endm  
# End of macro CALLMONITOR
1ecb					endif 
1ecb 22 92 f9			ld (cli_loop_sp),hl 
1ece 73				ld (hl), e 
1ecf 23				inc hl 
1ed0 72				ld (hl), d 
1ed1 d1				pop de    ; been reversed so save a swap on restore 
1ed2 e1				pop hl 
1ed3				if DEBUG_FORTH_STACK_GUARD 
1ed3 cd 12 63				call check_stacks 
1ed6				endif 
1ed6 c9				ret 
1ed7			 
1ed7			; get current ret stack pointer and save to hl  
1ed7				 
1ed7			FORTH_LOOP_TOS: macro 
1ed7				call macro_forth_loop_tos 
1ed7				endm 
1ed7			 
1ed7			macro_forth_loop_tos: 
1ed7 d5				push de 
1ed8 2a 92 f9			ld hl,(cli_loop_sp) 
1edb 5e				ld e, (hl) 
1edc 23				inc hl 
1edd 56				ld d, (hl) 
1ede eb				ex de, hl 
1edf d1				pop de 
1ee0 c9				ret 
1ee1			 
1ee1			; pop loop stack pointer 
1ee1				 
1ee1			FORTH_LOOP_POP: macro 
1ee1				call macro_forth_loop_pop 
1ee1				endm 
1ee1			 
1ee1			 
1ee1			macro_forth_loop_pop: 
1ee1				if DEBUG_FORTH_STACK_GUARD 
1ee1					DMARK "LPP" 
1ee1 f5				push af  
1ee2 3a f6 1e			ld a, (.dmark)  
1ee5 32 bd fb			ld (debug_mark),a  
1ee8 3a f7 1e			ld a, (.dmark+1)  
1eeb 32 be fb			ld (debug_mark+1),a  
1eee 3a f8 1e			ld a, (.dmark+2)  
1ef1 32 bf fb			ld (debug_mark+2),a  
1ef4 18 03			jr .pastdmark  
1ef6 ..			.dmark: db "LPP"  
1ef9 f1			.pastdmark: pop af  
1efa			endm  
# End of macro DMARK
1efa cd 12 63				call check_stacks 
1efd					FORTH_CHK_LOOP_UNDER 
1efd e5				push hl 
1efe d5				push de 
1eff 2a 92 f9			ld hl,(cli_loop_sp) 
1f02 11 0c f7			ld de, cli_loop_stack 
1f05 cd 24 0d			call cmp16 
1f08 da 2c 64			jp c, fault_loop_under 
1f0b d1				pop de 
1f0c e1				pop hl 
1f0d				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1f0d				endif 
1f0d e5				push hl 
1f0e 2a 92 f9			ld hl,(cli_loop_sp) 
1f11 2b				dec hl 
1f12 2b				dec hl 
1f13 22 92 f9			ld (cli_loop_sp), hl 
1f16				; TODO do stack underflow checks 
1f16 e1				pop hl 
1f17				if DEBUG_FORTH_STACK_GUARD 
1f17 cd 12 63				call check_stacks 
1f1a					FORTH_CHK_LOOP_UNDER 
1f1a e5				push hl 
1f1b d5				push de 
1f1c 2a 92 f9			ld hl,(cli_loop_sp) 
1f1f 11 0c f7			ld de, cli_loop_stack 
1f22 cd 24 0d			call cmp16 
1f25 da 2c 64			jp c, fault_loop_under 
1f28 d1				pop de 
1f29 e1				pop hl 
1f2a				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1f2a				endif 
1f2a c9				ret 
1f2b			 
1f2b			macro_forth_dsp_pop: 
1f2b			 
1f2b e5				push hl 
1f2c			 
1f2c				; release malloc data 
1f2c			 
1f2c				if DEBUG_FORTH_STACK_GUARD 
1f2c cd 12 63				call check_stacks 
1f2f					FORTH_CHK_DSP_UNDER 
1f2f e5				push hl 
1f30 d5				push de 
1f31 2a 90 f9			ld hl,(cli_data_sp) 
1f34 11 0a f5			ld de, cli_data_stack 
1f37 cd 24 0d			call cmp16 
1f3a da 20 64			jp c, fault_dsp_under 
1f3d d1				pop de 
1f3e e1				pop hl 
1f3f				endm 
# End of macro FORTH_CHK_DSP_UNDER
1f3f				endif 
1f3f				;ld hl,(cli_data_sp) 
1f3f			if DEBUG_FORTH_DOT 
1f3f				DMARK "DPP" 
1f3f				CALLMONITOR 
1f3f			endif	 
1f3f			 
1f3f			 
1f3f			if FORTH_ENABLE_DSPPOPFREE 
1f3f			 
1f3f				FORTH_DSP 
1f3f cd 39 1e			call macro_forth_dsp 
1f42				endm 
# End of macro FORTH_DSP
1f42			 
1f42 7e				ld a, (hl) 
1f43 fe 01			cp DS_TYPE_STR 
1f45 20 07			jr nz, .skippopfree 
1f47			 
1f47				FORTH_DSP_VALUEHL 
1f47 cd 73 1e			call macro_dsp_valuehl 
1f4a				endm 
# End of macro FORTH_DSP_VALUEHL
1f4a 00				nop 
1f4b			if DEBUG_FORTH_DOT 
1f4b				DMARK "DPf" 
1f4b				CALLMONITOR 
1f4b			endif	 
1f4b cd 97 12			call free 
1f4e			.skippopfree: 
1f4e				 
1f4e			 
1f4e			endif 
1f4e			 
1f4e			if DEBUG_FORTH_DOT_KEY 
1f4e				DMARK "DP2" 
1f4e				CALLMONITOR 
1f4e			endif	 
1f4e			 
1f4e				; move pointer down 
1f4e			 
1f4e 2a 90 f9			ld hl,(cli_data_sp) 
1f51 2b				dec hl 
1f52 2b				dec hl 
1f53			; PARSEV5 
1f53 2b				dec hl 
1f54 22 90 f9			ld (cli_data_sp), hl 
1f57			 
1f57				if DEBUG_FORTH_STACK_GUARD 
1f57 cd 12 63				call check_stacks 
1f5a					FORTH_CHK_DSP_UNDER 
1f5a e5				push hl 
1f5b d5				push de 
1f5c 2a 90 f9			ld hl,(cli_data_sp) 
1f5f 11 0a f5			ld de, cli_data_stack 
1f62 cd 24 0d			call cmp16 
1f65 da 20 64			jp c, fault_dsp_under 
1f68 d1				pop de 
1f69 e1				pop hl 
1f6a				endm 
# End of macro FORTH_CHK_DSP_UNDER
1f6a				endif 
1f6a			 
1f6a e1				pop hl 
1f6b			 
1f6b c9				ret 
1f6c			 
1f6c			getwordathl: 
1f6c				; hl points to an address 
1f6c				; load hl with the word at that address 
1f6c			 
1f6c d5				push de 
1f6d			 
1f6d 5e				ld e, (hl) 
1f6e 23				inc hl 
1f6f 56				ld d, (hl) 
1f70 eb				ex de, hl 
1f71			 
1f71 d1				pop de 
1f72 c9				ret 
1f73			 
1f73			 
1f73			 
1f73			 
1f73			 
1f73			; eof 
1f73			 
# End of file forth_stackopsv5.asm
1f73			endif 
1f73			 
1f73			user_word_eol:  
1f73				; hl contains the pointer to where to create a linked list item from the end 
1f73				; of the user dict to continue on at the system word dict 
1f73				 
1f73				; poke the stub of the word list linked list to repoint to rom words 
1f73			 
1f73				; stub format 
1f73				; db   word id 
1f73				; dw    link to next word 
1f73			        ; db char length of token 
1f73				; db string + 0 term 
1f73				; db exec code....  
1f73			 
1f73 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1f75 77				ld (hl), a		; word id 
1f76 23				inc hl 
1f77			 
1f77 11 3d 21			ld de, sysdict 
1f7a 73				ld (hl), e		; next word link ie system dict 
1f7b 23				inc hl 
1f7c 72				ld (hl), d		; next word link ie system dict 
1f7d 23				inc hl	 
1f7e			 
1f7e			;	ld (hl), sysdict		; next word link ie system dict 
1f7e			;	inc hl 
1f7e			;	inc hl 
1f7e			 
1f7e			;	inc hl 
1f7e			;	inc hl 
1f7e			 
1f7e 3e 02			ld a, 2			; word length is 0 
1f80 77				ld (hl), a	 
1f81 23				inc hl 
1f82			 
1f82 3e 7e			ld a, '~'			; word length is 0 
1f84 77				ld (hl), a	 
1f85 23				inc hl 
1f86 3e 00			ld a, 0			; save empty word 
1f88 77				ld (hl), a 
1f89			 
1f89 c9				ret 
1f8a			 
1f8a				 
1f8a			 
1f8a			forthexec_cleanup: 
1f8a				FORTH_RSP_POP 
1f8a cd 44 1c			call macro_forth_rsp_pop 
1f8d				endm 
# End of macro FORTH_RSP_POP
1f8d c9				ret 
1f8e			 
1f8e			forth_call_hl: 
1f8e				; taking hl 
1f8e e5				push hl 
1f8f c9				ret 
1f90			 
1f90			; this is called to reset Forth system but keep existing uwords etc 
1f90			 
1f90			forth_warmstart: 
1f90				; setup stack over/under flow checks 
1f90				if DEBUG_FORTH_STACK_GUARD 
1f90 cd f8 62				call chk_stk_init 
1f93				endif 
1f93			 
1f93				; init stack pointers  - * these stacks go upwards *  
1f93 21 0e f9			ld hl, cli_ret_stack 
1f96 22 94 f9			ld (cli_ret_sp), hl	 
1f99				; set bottom of stack 
1f99 3e 00			ld a,0 
1f9b 77				ld (hl),a 
1f9c 23				inc hl 
1f9d 77				ld (hl),a 
1f9e			 
1f9e 21 0a f5			ld hl, cli_data_stack 
1fa1 22 90 f9			ld (cli_data_sp), hl	 
1fa4				; set bottom of stack 
1fa4 3e 00			ld a,0 
1fa6 77				ld (hl),a 
1fa7 23				inc hl 
1fa8 77				ld (hl),a 
1fa9			 
1fa9 21 0c f7			ld hl, cli_loop_stack 
1fac 22 92 f9			ld (cli_loop_sp), hl	 
1faf				; set bottom of stack 
1faf 3e 00			ld a,0 
1fb1 77				ld (hl),a 
1fb2 23				inc hl 
1fb3 77				ld (hl),a 
1fb4			 
1fb4				; init extent of current open file 
1fb4			 
1fb4 3e 00			ld a, 0 
1fb6 32 df f9			ld (store_openext), a 
1fb9			 
1fb9 c9				ret 
1fba			 
1fba			 
1fba			; Cold Start - this is called to setup the whole Forth system 
1fba			 
1fba			forth_init: 
1fba			 
1fba				; setup stack over/under flow checks 
1fba			 
1fba			;	if DEBUG_FORTH_STACK_GUARD 
1fba			;		call chk_stk_init 
1fba			;	endif 
1fba			 
1fba				; enable auto display updates (slow.....) 
1fba			 
1fba 3e 01			ld a, 1 
1fbc 32 aa f9			ld (cli_autodisplay), a 
1fbf			 
1fbf			 
1fbf			 
1fbf				; show start up screen 
1fbf			 
1fbf cd d2 0a			call clear_display 
1fc2			 
1fc2 3e 00			ld a,0 
1fc4 32 cc f9			ld (f_cursor_ptr), a 
1fc7			 
1fc7				; set start of word list in start of ram - for use when creating user words 
1fc7			 
1fc7 21 00 80			ld hl, baseram 
1fca 22 a0 f2			ld (os_last_new_uword), hl 
1fcd cd 73 1f			call user_word_eol 
1fd0				 
1fd0			;		call display_data_sp 
1fd0			;		call next_page_prompt 
1fd0			 
1fd0			 
1fd0			 
1fd0			 
1fd0 c9				ret 
1fd1			 
1fd1 .. 00		.bootforth: db " Forth Kernel Init ",0 
1fe5			 
1fe5			; TODO push to stack 
1fe5			 
1fe5			;  
1fe5			 
1fe5			if FORTH_PARSEV2 
1fe5			 
1fe5			 
1fe5				include "forth_parserv2.asm" 
1fe5			 
1fe5			endif 
1fe5			 
1fe5			 
1fe5			; parse cli version 1 
1fe5			 
1fe5			if FORTH_PARSEV1 
1fe5			 
1fe5			 
1fe5			 
1fe5			      include "forth_parserv1.asm" 
1fe5			endif 
1fe5				 
1fe5			if FORTH_PARSEV3 
1fe5			 
1fe5			 
1fe5			 
1fe5			      include "forth_parserv3.asm" 
1fe5				include "forth_wordsv3.asm" 
1fe5			endif 
1fe5			 
1fe5			if FORTH_PARSEV4 
1fe5			 
1fe5			 
1fe5			 
1fe5			      include "forth_parserv4.asm" 
1fe5				include "forth_wordsv4.asm" 
1fe5			endif 
1fe5			 
1fe5			if FORTH_PARSEV5 
1fe5			 
1fe5			 
1fe5			 
1fe5			      include "forth_parserv5.asm" 
1fe5			 
1fe5			 
1fe5			; A better parser without using malloc and string copies all over the place.  
1fe5			; Exec in situ should be faster 
1fe5			 
1fe5			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
1fe5			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
1fe5			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
1fe5			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
1fe5			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
1fe5			WORD_SYS_END: equ 0   ; Opcode for all user words 
1fe5			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
1fe5			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
1fe5			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
1fe5			 
1fe5			; Core word preamble macro 
1fe5			 
1fe5			CWHEAD:   macro nxtword opcode lit len opflags 
1fe5				db WORD_SYS_CORE+opcode             
1fe5				; internal op code number 
1fe5				dw nxtword            
1fe5				; link to next dict word block 
1fe5				db len + 1 
1fe5				; literal length of dict word inc zero term 
1fe5				db lit,0              
1fe5				; literal dict word 
1fe5			        ; TODO db opflags        
1fe5				endm 
1fe5			 
1fe5			 
1fe5			NEXTW: macro  
1fe5				jp macro_next 
1fe5				endm 
1fe5			 
1fe5			macro_next: 
1fe5			if DEBUG_FORTH_PARSE_KEY 
1fe5				DMARK "NXT" 
1fe5				CALLMONITOR 
1fe5			endif	 
1fe5			;	inc hl  ; skip token null term  
1fe5 ed 4b ae f9		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1fe9 ed 5b ac f9		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1fed 2a a4 f2			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1ff0			if DEBUG_FORTH_PARSE_KEY 
1ff0				DMARK "}AA" 
1ff0				CALLMONITOR 
1ff0			endif	 
1ff0 c3 f3 20			jp execnext 
1ff3				;jp exec1 
1ff3			       
1ff3			 
1ff3			 
1ff3			; Another go at the parser to compile  
1ff3			 
1ff3			 
1ff3			; TODO rework parser to change all of the string words to byte tokens 
1ff3			; TODO do a search for  
1ff3			 
1ff3			; TODO first run normal parser to zero term sections 
1ff3			; TODO for each word do a token look up to get the op code 
1ff3			; TODO need some means to flag to the exec that this is a byte code form    
1ff3			 
1ff3			 
1ff3			forthcompile: 
1ff3			 
1ff3			; 
1ff3			; line parse: 
1ff3			;       parse raw input buffer 
1ff3			;       tokenise the words 
1ff3			;       malloc new copy (for looping etc) 
1ff3			;       copy to malloc + current pc in line to start of string and add line term 
1ff3			;       save on new rsp 
1ff3			; 
1ff3			 
1ff3			; hl to point to the line to tokenise 
1ff3			 
1ff3			;	push hl 
1ff3 22 a4 f2			ld (os_tok_ptr), hl  ; save ptr to string 
1ff6			 
1ff6			;	ld a,0		; string term on input 
1ff6			;	call strlent 
1ff6			 
1ff6			;	ld (os_tok_len), hl	 ; save string length 
1ff6			 
1ff6			;if DEBUG_FORTH_TOK 
1ff6			;	ex de,hl		 
1ff6			;endif 
1ff6			 
1ff6			;	pop hl 		; get back string pointer 
1ff6			 
1ff6			if DEBUG_FORTH_TOK 
1ff6						DMARK "TOc" 
1ff6				CALLMONITOR 
1ff6			endif 
1ff6 7e			.cptoken2:    ld a,(hl) 
1ff7 23				inc hl 
1ff8 fe 7f			cp FORTH_END_BUFFER 
1ffa 28 29			jr z, .cptokendone2 
1ffc fe 00			cp 0 
1ffe 28 25			jr z, .cptokendone2 
2000 fe 22			cp '"' 
2002 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
2004 fe 20			cp ' ' 
2006 20 ee			jr nz,  .cptoken2 
2008			 
2008			; TODO consume comments held between ( and ) 
2008			 
2008				; we have a space so change to zero term for dict match later 
2008 2b				dec hl 
2009 3e 00			ld a,0 
200b 77				ld (hl), a 
200c 23				inc hl 
200d 18 e7			jr .cptoken2 
200f				 
200f			 
200f			.cptokenstr2: 
200f				; skip all white space until either eol (because forgot to term) or end double quote 
200f			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
200f				;inc hl ; skip current double quote 
200f 7e				ld a,(hl) 
2010 23				inc hl 
2011 fe 22			cp '"' 
2013 28 e1			jr z, .cptoken2 
2015 fe 7f			cp FORTH_END_BUFFER 
2017 28 0c			jr z, .cptokendone2 
2019 fe 00			cp 0 
201b 28 08			jr z, .cptokendone2 
201d fe 20			cp ' ' 
201f 28 02			jr z, .cptmp2 
2021 18 ec			jr .cptokenstr2 
2023			 
2023			.cptmp2:	; we have a space so change to zero term for dict match later 
2023				;dec hl 
2023				;ld a,"-"	; TODO remove this when working 
2023				;ld (hl), a 
2023				;inc hl 
2023 18 ea			jr .cptokenstr2 
2025			 
2025			.cptokendone2: 
2025				;inc hl 
2025 3e 7f			ld a, FORTH_END_BUFFER 
2027 77				ld (hl),a 
2028 23				inc hl 
2029 3e 21			ld a, '!' 
202b 77				ld (hl),a 
202c			 
202c 2a a4 f2			ld hl,(os_tok_ptr) 
202f			         
202f			if DEBUG_FORTH_TOK 
202f						DMARK "Tc1" 
202f				CALLMONITOR 
202f			endif 
202f			 
202f				; push exec string to top of return stack 
202f				FORTH_RSP_NEXT 
202f cd 23 1c			call macro_forth_rsp_next 
2032				endm 
# End of macro FORTH_RSP_NEXT
2032 c9				ret 
2033			 
2033			; Another go at the parser need to simplify the process 
2033			 
2033			forthparse: 
2033			 
2033			; 
2033			; line parse: 
2033			;       parse raw input buffer 
2033			;       tokenise the words 
2033			;       malloc new copy (for looping etc) 
2033			;       copy to malloc + current pc in line to start of string and add line term 
2033			;       save on new rsp 
2033			; 
2033			 
2033			; hl to point to the line to tokenise 
2033			 
2033			;	push hl 
2033 22 a4 f2			ld (os_tok_ptr), hl  ; save ptr to string 
2036			 
2036			;	ld a,0		; string term on input 
2036			;	call strlent 
2036			 
2036			;	ld (os_tok_len), hl	 ; save string length 
2036			 
2036			;if DEBUG_FORTH_TOK 
2036			;	ex de,hl		 
2036			;endif 
2036			 
2036			;	pop hl 		; get back string pointer 
2036			 
2036			if DEBUG_FORTH_TOK 
2036						DMARK "TOK" 
2036				CALLMONITOR 
2036			endif 
2036 7e			.ptoken2:    ld a,(hl) 
2037 23				inc hl 
2038 fe 7f			cp FORTH_END_BUFFER 
203a 28 29			jr z, .ptokendone2 
203c fe 00			cp 0 
203e 28 25			jr z, .ptokendone2 
2040 fe 22			cp '"' 
2042 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
2044 fe 20			cp ' ' 
2046 20 ee			jr nz,  .ptoken2 
2048			 
2048			; TODO consume comments held between ( and ) 
2048			 
2048				; we have a space so change to zero term for dict match later 
2048 2b				dec hl 
2049 3e 00			ld a,0 
204b 77				ld (hl), a 
204c 23				inc hl 
204d 18 e7			jr .ptoken2 
204f				 
204f			 
204f			.ptokenstr2: 
204f				; skip all white space until either eol (because forgot to term) or end double quote 
204f			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
204f				;inc hl ; skip current double quote 
204f 7e				ld a,(hl) 
2050 23				inc hl 
2051 fe 22			cp '"' 
2053 28 e1			jr z, .ptoken2 
2055 fe 7f			cp FORTH_END_BUFFER 
2057 28 0c			jr z, .ptokendone2 
2059 fe 00			cp 0 
205b 28 08			jr z, .ptokendone2 
205d fe 20			cp ' ' 
205f 28 02			jr z, .ptmp2 
2061 18 ec			jr .ptokenstr2 
2063			 
2063			.ptmp2:	; we have a space so change to zero term for dict match later 
2063				;dec hl 
2063				;ld a,"-"	; TODO remove this when working 
2063				;ld (hl), a 
2063				;inc hl 
2063 18 ea			jr .ptokenstr2 
2065			 
2065			.ptokendone2: 
2065				;inc hl 
2065 3e 7f			ld a, FORTH_END_BUFFER 
2067 77				ld (hl),a 
2068 23				inc hl 
2069 3e 21			ld a, '!' 
206b 77				ld (hl),a 
206c			 
206c 2a a4 f2			ld hl,(os_tok_ptr) 
206f			         
206f			if DEBUG_FORTH_TOK 
206f						DMARK "TK1" 
206f				CALLMONITOR 
206f			endif 
206f			 
206f				; push exec string to top of return stack 
206f				FORTH_RSP_NEXT 
206f cd 23 1c			call macro_forth_rsp_next 
2072				endm 
# End of macro FORTH_RSP_NEXT
2072 c9				ret 
2073			 
2073			; 
2073			;	; malloc size + buffer pointer + if is loop flag 
2073			;	ld hl,(os_tok_len) 		 ; get string length 
2073			; 
2073			;	ld a,l 
2073			; 
2073			;	cp 0			; we dont want to use a null string 
2073			;	ret z 
2073			; 
2073			;;	add 3    ; prefix malloc with buffer for current word ptr 
2073			; 
2073			;	add 5     ; TODO when certain not over writing memory remove 
2073			; 
2073			;		 
2073			; 
2073			;if DEBUG_FORTH_TOK 
2073			;			DMARK "TKE" 
2073			;	CALLMONITOR 
2073			;endif 
2073			; 
2073			;	ld l,a 
2073			;	ld h,0 
2073			;;	push hl   ; save required space for the copy later 
2073			;	call malloc 
2073			;if DEBUG_FORTH_TOK 
2073			;			DMARK "TKM" 
2073			;	CALLMONITOR 
2073			;endif 
2073			;	if DEBUG_FORTH_MALLOC_GUARD 
2073			;		push af 
2073			;		call ishlzero 
2073			;;		ld a, l 
2073			;;		add h 
2073			;;		cp 0 
2073			;		pop af 
2073			;		 
2073			;		call z,malloc_error 
2073			;	endif 
2073			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
2073			; 
2073			; 
2073			;if DEBUG_FORTH_TOK 
2073			;			DMARK "TKR" 
2073			;	CALLMONITOR 
2073			;endif 
2073			; 
2073			;	FORTH_RSP_NEXT 
2073			; 
2073			;	;inc hl	 ; go past current buffer pointer 
2073			;	;inc hl 
2073			;	;inc hl   ; and past if loop flag 
2073			;		; TODO Need to set flag  
2073			; 
2073			;	 
2073			;	 
2073			;	ex de,hl	; malloc is dest 
2073			;	ld hl, (os_tok_len) 
2073			;;	pop bc 
2073			;	ld c, l                
2073			;	ld b,0 
2073			;	ld hl, (os_tok_ptr) 
2073			; 
2073			;if DEBUG_FORTH_TOK 
2073			;			DMARK "TKT" 
2073			;	CALLMONITOR 
2073			;endif 
2073			; 
2073			;	; do str cpy 
2073			; 
2073			;	ldir      ; copy byte in hl to de 
2073			; 
2073			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
2073			; 
2073			;if DEBUG_FORTH_TOK 
2073			; 
2073			;			DMARK "TKY" 
2073			;	CALLMONITOR 
2073			;endif 
2073			;	;ld a,0 
2073			;	;ld a,FORTH_END_BUFFER 
2073			;	ex de, hl 
2073			;	;dec hl			 ; go back over the space delim at the end of word 
2073			;	;ld (hl),a 
2073			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
2073			;	ld a,FORTH_END_BUFFER 
2073			;	ld (hl),a 
2073			;	inc hl 
2073			;	ld a,FORTH_END_BUFFER 
2073			;	ld (hl),a 
2073			; 
2073			;	; init the malloc area data 
2073			;	; set pc for in current area 
2073			;	;ld hl, (os_tok_malloc) 
2073			;	;inc hl 
2073			;	;inc hl 
2073			;	;inc hl 
2073			;	;ex de,hl 
2073			;	;ld hl, (os_tok_malloc) 
2073			;	;ld (hl),e 
2073			;	;inc hl 
2073			;	;ld (hl),d 
2073			; 
2073			; 
2073			;	ld hl,(os_tok_malloc) 
2073			;if DEBUG_FORTH_PARSE_KEY 
2073			;			DMARK "TKU" 
2073			;	CALLMONITOR 
2073			;endif 
2073			; 
2073			;	ret 
2073			 
2073			forthexec: 
2073			 
2073			; line exec: 
2073			; forth parser 
2073			 
2073			; 
2073			;       get current exec line on rsp 
2073			 
2073				FORTH_RSP_TOS 
2073 cd 3a 1c			call macro_forth_rsp_tos 
2076				endm 
# End of macro FORTH_RSP_TOS
2076			 
2076			;       restore current pc - hl points to malloc of data 
2076			 
2076				;ld e, (hl) 
2076				;inc hl 
2076				;ld d, (hl) 
2076				;ex de,hl 
2076			 
2076			 
2076			exec1: 
2076 22 a4 f2			ld (os_tok_ptr), hl 
2079			 
2079				; copy our PC to working vars  
2079 22 ae f9			ld (cli_ptr), hl 
207c 22 ac f9			ld (cli_origptr), hl 
207f			 
207f 7e				ld a,(hl) 
2080 fe 7f			cp FORTH_END_BUFFER 
2082 c8				ret z 
2083			 
2083				; skip any nulls 
2083			 
2083 fe 00			cp 0 
2085 20 03			jr nz, .execword 
2087 23				inc hl 
2088 18 ec			jr exec1 
208a			 
208a			 
208a			.execword: 
208a			 
208a			 
208a			 
208a			if DEBUG_FORTH_PARSE_KEY 
208a						DMARK "KYQ" 
208a				CALLMONITOR 
208a			endif 
208a			;       while at start of word: 
208a			; get start of dict (in user area first) 
208a			 
208a 21 00 80		ld hl, baseram 
208d			;ld hl, sysdict 
208d 22 b0 f9		ld (cli_nextword),hl 
2090			;           match word at pc 
2090			;           exec word 
2090			;           or push to dsp 
2090			;           forward to next token 
2090			;           if line term pop rsp and exit 
2090			;        
2090			 
2090			if DEBUG_FORTH_PARSE_KEY 
2090						DMARK "KYq" 
2090				CALLMONITOR 
2090			endif 
2090			 
2090			; 
2090			; word comp 
2090			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
2090			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
2090			;    move to start of word  
2090			;    compare word to cli_token 
2090			 
2090			.execpnword:	; HL at start of a word in the dictionary to check 
2090			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
2090			;	ld (cli_ptr), hl 
2090			 
2090 2a b0 f9			ld hl,(cli_nextword) 
2093			 
2093 cd 36 21			call forth_tok_next 
2096			; tok next start here 
2096			;	; TODO skip compiled symbol for now 
2096			;	inc hl 
2096			; 
2096			;	; save pointer to next word 
2096			; 
2096			;	; hl now points to the address of the next word pointer  
2096			;	ld e, (hl) 
2096			;	inc hl 
2096			;	ld d, (hl) 
2096			;	inc l 
2096			; 
2096			;	ex de,hl 
2096			;if DEBUG_FORTH_PARSE_NEXTWORD 
2096			;	push bc 
2096			;	ld bc, (cli_nextword) 
2096			;			DMARK "NXW" 
2096			;	CALLMONITOR 
2096			;	pop bc 
2096			;endif 
2096			; tok next end here 
2096 22 b0 f9			ld (cli_nextword), hl     ; save for next check if no match on this word 
2099 eb				ex de, hl 
209a			 
209a			 
209a				; save the pointer of the current token - 1 to check against 
209a				 
209a 22 b4 f9			ld (cli_token), hl   
209d				; TODO maybe remove below save if no debug 
209d				; save token string ptr for any debug later 
209d 23				inc hl  
209e 22 b6 f9			ld (cli_origtoken), hl 
20a1 2b				dec hl 
20a2				; save pointer to the start of the next dictionay word 
20a2 7e				ld a,(hl)   ; get string length 
20a3 47				ld b,a 
20a4			.execpnwordinc:  
20a4 23				inc hl 
20a5 10 fd			djnz .execpnwordinc 
20a7 22 b2 f9			ld (cli_execword), hl      ; save start of this words code 
20aa			 
20aa				; now check the word token against the string being parsed 
20aa			 
20aa 2a b4 f9			ld hl,(cli_token) 
20ad 23				inc hl     ; skip string length (use zero term instead to end) 
20ae 22 b4 f9			ld (cli_token), hl 
20b1			 
20b1			if DEBUG_FORTH_PARSE_KEY 
20b1						DMARK "KY2" 
20b1			endif 
20b1			if DEBUG_FORTH_PARSE_EXEC 
20b1				; see if disabled 
20b1			 
20b1				ld a, (os_view_disable) 
20b1				cp '*' 
20b1				jr z, .skip 
20b1			 
20b1				push hl 
20b1				push hl 
20b1				call clear_display 
20b1				ld de, .compword 
20b1				ld a, display_row_1 
20b1				call str_at_display 
20b1				pop de 
20b1				ld a, display_row_2 
20b1				call str_at_display 
20b1				ld hl,(cli_ptr) 
20b1				ld a,(hl) 
20b1			        ld hl, os_word_scratch 
20b1				ld (hl),a 
20b1				ld a,0 
20b1				inc hl 
20b1				ld (hl),a 	 
20b1				ld de, os_word_scratch 
20b1				ld a, display_row_2+10 
20b1				call str_at_display 
20b1				call update_display 
20b1				ld a, 100 
20b1				call aDelayInMS 
20b1				if DEBUG_FORTH_PARSE_EXEC_SLOW 
20b1				call delay250ms 
20b1				endif 
20b1				pop hl 
20b1			.skip:  
20b1			endif	 
20b1			.execpnchar:    ; compare char between token and string to parse 
20b1			 
20b1			if DEBUG_FORTH_PARSE_KEY 
20b1						DMARK "Ky3" 
20b1			endif 
20b1			if DEBUG_FORTH_PARSE_EXEC 
20b1				; see if disabled 
20b1			 
20b1				ld a, (os_view_disable) 
20b1				cp '*' 
20b1				jr z, .skip2 
20b1			 
20b1			;	call clear_display 
20b1			ld hl,(cli_token) 
20b1			ld a,(hl) 
20b1			ld (os_word_scratch),a 
20b1				ld hl,(cli_ptr) 
20b1			ld a,(hl) 
20b1				ld (os_word_scratch+1),a 
20b1				ld a,0 
20b1				ld (os_word_scratch+2),a 
20b1				ld de,os_word_scratch 
20b1				ld a,display_row_4 
20b1				call str_at_display 
20b1				call update_display 
20b1			.skip2:  
20b1			endif 
20b1 2a b4 f9			ld hl,(cli_token) 
20b4 7e				ld a, (hl)	 ; char in word token 
20b5 23				inc hl 		; move to next char 
20b6 22 b4 f9			ld (cli_token), hl ; and save it 
20b9 47				ld b,a 
20ba			 
20ba 2a ae f9			ld hl,(cli_ptr) ;	get the char from the string to parse 
20bd 7e				ld a,(hl) 
20be 23				inc hl 
20bf 22 ae f9			ld (cli_ptr), hl		; move to next char 
20c2 cd 5b 11			call toUpper 		; make sure the input string matches case 
20c5			 
20c5			if DEBUG_FORTH_PARSE 
20c5			endif 
20c5			 
20c5				; input stream end of token is a space so get rid of it 
20c5			 
20c5			;	cp ' ' 
20c5			;	jr nz, .pnskipspace 
20c5			; 
20c5			;	ld a, 0		; make same term as word token term 
20c5			; 
20c5			;.pnskipspace: 
20c5			 
20c5			if DEBUG_FORTH_PARSE_KEY 
20c5						DMARK "KY7" 
20c5			endif 
20c5 b8				cp b 
20c6 c2 dc 20			jp nz, .execpnskipword	 ; no match so move to next word 
20c9				 
20c9			;    if same 
20c9			;       scan for string terms 0 for token and 32 for input 
20c9			 
20c9				 
20c9			if DEBUG_FORTH_PARSE_KEY 
20c9						DMARK "KY8" 
20c9			endif 
20c9			 
20c9 80				add b			 
20ca fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
20cc							; TODO need to make sure last word in zero term string is accounted for 
20cc 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
20ce			 
20ce			 
20ce				; at end of both strings so both are exact match 
20ce			 
20ce			;       skip ptr for next word 
20ce			 
20ce 2a ae f9			ld hl,(cli_ptr) 	; at input string term 
20d1 23				inc hl			 ; at next char 
20d2 22 ae f9			ld (cli_ptr), hl     ; save for next round of the parser 
20d5 22 ac f9			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
20d8				 
20d8				 
20d8			if DEBUG_FORTH_PARSE_KEY 
20d8						DMARK "KY3" 
20d8			endif 
20d8			 
20d8			 
20d8			 
20d8			;       exec code block 
20d8			if DEBUG_FORTH_JP 
20d8				call clear_display 
20d8				call update_display 
20d8				call delay1s 
20d8				ld hl, (cli_execword)     ; save for next check if no match on this word 
20d8				ld a,h 
20d8				ld hl, os_word_scratch 
20d8				call hexout 
20d8				ld hl, (cli_execword)     ; save for next check if no match on this word 
20d8				ld a,l 
20d8				ld hl, os_word_scratch+2 
20d8				call hexout 
20d8				ld hl, os_word_scratch+4 
20d8				ld a,0 
20d8				ld (hl),a 
20d8				ld de,os_word_scratch 
20d8				call str_at_display 
20d8					ld a, display_row_2 
20d8					call str_at_display 
20d8				ld de, (cli_origtoken) 
20d8				ld a, display_row_1+10 
20d8					call str_at_display 
20d8			 
20d8				ld a,display_row_1 
20d8				ld de, .foundword 
20d8				ld a, display_row_3 
20d8				call str_at_display 
20d8				call update_display 
20d8				call delay1s 
20d8				call delay1s 
20d8				call delay1s 
20d8			endif 
20d8			 
20d8			if DEBUG_FORTH_PARSE_KEY 
20d8						DMARK "KYj" 
20d8			endif 
20d8				; TODO save the word pointer in this exec 
20d8			 
20d8 2a b2 f9			ld hl,(cli_execword) 
20db e9				jp (hl) 
20dc			 
20dc			 
20dc			;    if not same 
20dc			;	scan for zero term 
20dc			;	get ptr for next word 
20dc			;	goto word comp 
20dc			 
20dc			.execpnskipword:	; get pointer to next word 
20dc 2a b0 f9			ld hl,(cli_nextword) 
20df			 
20df 7e				ld a,(hl) 
20e0 fe 00			cp WORD_SYS_END 
20e2			;	cp 0 
20e2 28 09			jr z, .execendofdict			 ; at end of words 
20e4			 
20e4			if DEBUG_FORTH_PARSE_KEY 
20e4						DMARK "KY4" 
20e4			endif 
20e4			if DEBUG_FORTH_PARSE_EXEC 
20e4			 
20e4				; see if disabled 
20e4			 
20e4				ld a, (os_view_disable) 
20e4				cp '*' 
20e4				jr z, .noskip 
20e4			 
20e4			 
20e4				ld de, .nowordfound 
20e4				ld a, display_row_3 
20e4				call str_at_display 
20e4				call update_display 
20e4				ld a, 100 
20e4				call aDelayInMS 
20e4				 
20e4				if DEBUG_FORTH_PARSE_EXEC_SLOW 
20e4					call delay250ms 
20e4				endif 
20e4			.noskip:  
20e4			 
20e4			endif	 
20e4			 
20e4 2a ac f9			ld hl,(cli_origptr) 
20e7 22 ae f9			ld (cli_ptr),hl 
20ea			 
20ea			if DEBUG_FORTH_PARSE_KEY 
20ea						DMARK "KY5" 
20ea			endif 
20ea c3 90 20			jp .execpnword			; else go to next word 
20ed			 
20ed			.execendofdict:  
20ed			 
20ed			if DEBUG_FORTH_PARSE_KEY 
20ed						DMARK "KYe" 
20ed			endif 
20ed			if DEBUG_FORTH_PARSE_EXEC 
20ed				; see if disabled 
20ed			 
20ed				ld a, (os_view_disable) 
20ed				cp '*' 
20ed				jr z, .ispskip 
20ed			 
20ed				call clear_display 
20ed				call update_display 
20ed				call delay1s 
20ed				ld de, (cli_origptr) 
20ed				ld a, display_row_1 
20ed				call str_at_display 
20ed				 
20ed				ld de, .enddict 
20ed				ld a, display_row_3 
20ed				call str_at_display 
20ed				call update_display 
20ed				ld a, 100 
20ed				call aDelayInMS 
20ed				if DEBUG_FORTH_PARSE_EXEC_SLOW 
20ed				call delay1s 
20ed				call delay1s 
20ed				call delay1s 
20ed				endif 
20ed			.ispskip:  
20ed				 
20ed			endif	 
20ed			 
20ed			 
20ed			 
20ed				; if the word is not a keyword then must be a literal so push it to stack 
20ed			 
20ed			; push token to stack to end of word 
20ed			 
20ed				STACKFRAME ON $1efe $2f9f 
20ed				if DEBUG_STACK_IMB 
20ed					if ON 
20ed						exx 
20ed						ld de, $1efe 
20ed						ld a, d 
20ed						ld hl, curframe 
20ed						call hexout 
20ed						ld a, e 
20ed						ld hl, curframe+2 
20ed						call hexout 
20ed						ld hl, $1efe 
20ed						push hl 
20ed						ld hl, $2f9f 
20ed						push hl 
20ed						exx 
20ed					endif 
20ed				endif 
20ed			endm 
# End of macro STACKFRAME
20ed			 
20ed 2a a4 f2		ld hl,(os_tok_ptr) 
20f0 cd e5 1d		call forth_apush 
20f3			 
20f3				STACKFRAMECHK ON $1efe $2f9f 
20f3				if DEBUG_STACK_IMB 
20f3					if ON 
20f3						exx 
20f3						ld hl, $2f9f 
20f3						pop de   ; $2f9f 
20f3						call cmp16 
20f3						jr nz, .spnosame 
20f3						ld hl, $1efe 
20f3						pop de   ; $1efe 
20f3						call cmp16 
20f3						jr z, .spfrsame 
20f3						.spnosame: call showsperror 
20f3						.spfrsame: nop 
20f3						exx 
20f3					endif 
20f3				endif 
20f3			endm 
# End of macro STACKFRAMECHK
20f3			 
20f3			execnext: 
20f3			 
20f3			if DEBUG_FORTH_PARSE_KEY 
20f3						DMARK "KY>" 
20f3			endif 
20f3			; move past token to next word 
20f3			 
20f3 2a a4 f2		ld hl, (os_tok_ptr) 
20f6 3e 00		ld a, 0 
20f8 01 ff 00		ld bc, 255     ; input buffer size 
20fb ed b1		cpir 
20fd			 
20fd			if DEBUG_FORTH_PARSE_KEY 
20fd						DMARK "KY!" 
20fd				CALLMONITOR 
20fd			endif	 
20fd			; TODO this might place hl on the null, so will need to forward on??? 
20fd			;inc hl   ; see if this gets onto the next item 
20fd			 
20fd			 
20fd			; TODO pass a pointer to the buffer to push 
20fd			; TODO call function to push 
20fd			 
20fd			; look for end of input 
20fd			 
20fd			;inc hl 
20fd			;ld a,(hl) 
20fd			;cp FORTH_END_BUFFER 
20fd			;ret z 
20fd			 
20fd			 
20fd c3 76 20		jp exec1 
2100			 
2100			 
2100			 
2100			 
2100			 
2100			 
2100			 
2100			 
2100			 
2100			findnexttok: 
2100			 
2100				; hl is pointer to move 
2100				; de is the token to locate 
2100			 
2100					if DEBUG_FORTH 
2100						DMARK "NTK" 
2100						CALLMONITOR 
2100					endif 
2100 d5				push de 
2101			 
2101			.fnt1:	 
2101				; find first char of token to locate 
2101			 
2101 1a				ld a, (de) 
2102 4f				ld c,a 
2103 7e				ld a,(hl) 
2104 cd 5b 11			call toUpper 
2107					if DEBUG_FORTH 
2107						DMARK "NT1" 
2107						CALLMONITOR 
2107					endif 
2107 b9				cp c 
2108			 
2108 28 03			jr z, .fnt2cmpmorefirst	 
210a			 
210a				; first char not found move to next char 
210a			 
210a 23				inc hl 
210b 18 f4			jr .fnt1 
210d			 
210d			.fnt2cmpmorefirst:	 
210d				; first char of token found.  
210d			 
210d e5				push hl     ; save start of token just in case it is the right one 
210e d9				exx 
210f e1				pop hl        ; save it to hl' 
2110 d9				exx 
2111			 
2111			 
2111			.fnt2cmpmore:	 
2111				; compare the rest 
2111				 
2111 23				inc hl 
2112 13				inc de 
2113				 
2113 1a				ld a, (de) 
2114 4f				ld c,a 
2115 7e				ld a,(hl) 
2116 cd 5b 11			call toUpper 
2119			 
2119					if DEBUG_FORTH 
2119						DMARK "NT2" 
2119						CALLMONITOR 
2119					endif 
2119				; c has the token to find char 
2119				; a has the mem to scan char 
2119			 
2119 b9				cp c 
211a 28 04			jr z,.fntmatch1 
211c			 
211c				; they are not the same 
211c			 
211c					if DEBUG_FORTH 
211c						DMARK "NT3" 
211c						CALLMONITOR 
211c					endif 
211c d1				pop de	; reset de token to look for 
211d d5				push de 
211e 18 e1			jr .fnt1 
2120				 
2120			.fntmatch1: 
2120			 
2120				; is the same char a null which means we might have a full hit? 
2120					if DEBUG_FORTH 
2120						DMARK "NT4" 
2120						CALLMONITOR 
2120					endif 
2120			 
2120 fe 00			cp 0 
2122 28 0b			jr z, .fntmatchyes 
2124			 
2124				; are we at the end of the token to find? 
2124			 
2124					if DEBUG_FORTH 
2124						DMARK "NT5" 
2124						CALLMONITOR 
2124					endif 
2124 3e 00			ld a, 0 
2126 b9				cp c 
2127			 
2127 c2 11 21			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
212a			 
212a					if DEBUG_FORTH 
212a						DMARK "NT6" 
212a						CALLMONITOR 
212a					endif 
212a				; token to find is exhusted but no match to stream 
212a			 
212a				; restore tok pointer and continue on 
212a d1				pop de 
212b d5				push de 
212c c3 01 21			jp .fnt1 
212f			 
212f			 
212f			.fntmatchyes: 
212f			 
212f				; hl now contains the end of the found token 
212f			 
212f				; get rid of saved token pointer to find 
212f			 
212f d1				pop de 
2130			 
2130					if DEBUG_FORTH 
2130						DMARK "NT9" 
2130						CALLMONITOR 
2130					endif 
2130			 
2130				; hl will be on the null term so forward on 
2130			 
2130				; get back the saved start of the token 
2130			 
2130 d9				exx 
2131 e5				push hl     ; save start of token just in case it is the right one 
2132 d9				exx 
2133 e1				pop hl        ; save it to hl 
2134			 
2134 c9				ret 
2135			 
2135			 
2135			; LIST needs to find a specific token   
2135			; FORGET needs to find a spefici token 
2135			 
2135			; SAVE needs to find all tokens by flag 
2135			; WORDS just needs to scan through all  by flag 
2135			; UWORDS needs to scan through all by flag 
2135			 
2135			 
2135			; given hl as pointer to start of dict look up string 
2135			; return hl as pointer to start of word block 
2135			; or 0 if not found 
2135			 
2135			forth_find_tok: 
2135 c9				ret 
2136			 
2136			; given hl as pointer to dict structure 
2136			; move to the next dict block structure 
2136			 
2136			forth_tok_next: 
2136				; hl now points to the address of the next word pointer  
2136				; TODO skip compiled symbol for now 
2136			;	push de 
2136 23				inc hl 
2137 5e				ld e, (hl) 
2138 23				inc hl 
2139 56				ld d, (hl) 
213a 23				inc hl 
213b			 
213b eb				ex de,hl 
213c			if DEBUG_FORTH_PARSE_NEXTWORD 
213c				push bc 
213c				ld bc, (cli_nextword) 
213c						DMARK "NXW" 
213c				CALLMONITOR 
213c				pop bc 
213c			endif 
213c			;	pop de	 
213c c9				ret 
213d			 
213d			 
213d			 
213d			; eof 
# End of file forth_parserv5.asm
213d				include "forth_wordsv4.asm" 
213d			 
213d			; the core word dictionary v4 
213d			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
213d			 
213d			; this is a linked list for each of the system words used 
213d			; user defined words will follow the same format but will be in ram 
213d			 
213d			 
213d			; 
213d			; 
213d			; define linked list: 
213d			; 
213d			; 1. compiled byte op code 
213d			; 2. len of text word 
213d			; 3. text word 
213d			; 4. ptr to next dictionary word 
213d			; 5. asm, calls etc for the word 
213d			; 
213d			;  if 1 == 0 then last word in dict  
213d			;   
213d			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
213d			;  
213d			;  
213d			; create basic standard set of words 
213d			; 
213d			;  
213d			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
213d			; 2DUP 2DROP 2SWAP  
213d			; @ C@ - get byte  
213d			; ! C! - store byte 
213d			; 0< true if less than zero 
213d			; 0= true if zero 
213d			; < >  
213d			; = true if same 
213d			; variables 
213d			 
213d			 
213d			; Hardware specific words I may need 
213d			; 
213d			; IN OUT  
213d			; calls to key util functions 
213d			; calls to hardward abstraction stuff 
213d			; easy control of frame buffers and lcd i/o 
213d			; keyboard  
213d			 
213d			 
213d			;DICT: macro 
213d			; op_code, len, word, next 
213d			;    word: 
213d			;    db op_code 
213d			;    ds word zero term 
213d			;    dw next 
213d			;    endm 
213d			 
213d			 
213d			 
213d			 
213d			; op code 1 is a flag for user define words which are to be handled differently 
213d			 
213d			 
213d			; 
213d			; 
213d			;    TODO on entry to a word this should be the expected environment 
213d			;    hl - tos value if number then held, if string this is the ptr 
213d			;    de -  
213d			 
213d			 
213d			; opcode ranges 
213d			; 0 - end of word dict 
213d			; 255 - user define words 
213d			 
213d			sysdict: 
213d			include "forth_opcodes.asm" 
213d			; op codes for forth keywords 
213d			; free to use code 0  
213d				OPCODE_HEAP: equ  1 
213d				OPCODE_EXEC: equ 2 
213d				OPCODE_DUP: equ 3 
213d				OPCODE_SWAP: equ 4 
213d				OPCODE_COLN: equ 5 
213d				OPCODE_SCOLN: equ 6 
213d				OPCODE_DROP: equ 7 
213d				OPCODE_DUP2: equ 8 
213d				OPCODE_DROP2: equ 9 
213d				OPCODE_SWAP2: equ 10 
213d				OPCODE_AT: equ 11 
213d				OPCODE_CAT: equ 12 
213d				OPCODE_BANG: equ 13 
213d				OPCODE_CBANG: equ 14 
213d				OPCODE_SCALL: equ 15 
213d				OPCODE_DEPTH: equ 16 
213d				OPCODE_OVER: equ 17 
213d				OPCODE_PAUSE: equ 18 
213d				OPCODE_PAUSES: equ 19 
213d				OPCODE_ROT: equ 20 
213d			;free to reuse	OPCODE_WORDS: equ 21 
213d			        OPCODE_NOT: equ 21 
213d				OPCODE_UWORDS: equ 22 
213d				OPCODE_BP: equ 23 
213d				OPCODE_MONITOR: equ 24  
213d				OPCODE_MALLOC: equ 25 
213d				OPCODE_FREE: equ 26 
213d				OPCODE_LIST: equ 27 
213d				OPCODE_FORGET: equ 28 
213d				OPCODE_NOP: equ 29 
213d				OPCODE_COMO: equ 30 
213d				OPCODE_COMC: equ 31 
213d			;free to reuse	OPCODE_ENDCORE: equ 32 
213d				OPCODE_AFTERSOUND: equ 33 
213d				OPCODE_GP2: equ 34 
213d				OPCODE_GP3: equ 35 
213d				OPCODE_GP4: equ 36 
213d				OPCODE_SIN: equ 37 
213d				OPCODE_SOUT: equ 38 
213d				OPCODE_SPIO: equ 39 
213d				OPCODE_SPICEH: equ 40 
213d				OPCODE_SPIOb: equ 41 
213d				OPCODE_SPII: equ 42 
213d				OPCODE_SESEL: equ 43 
213d				OPCODE_CARTDEV: equ 44 
213d			; free to reuse	OPCODE_ENDDEVICE: equ 45 
213d				OPCODE_FB: equ 46 
213d				OPCODE_EMIT: equ 47 
213d				OPCODE_DOTH: equ 48 
213d				OPCODE_DOTF: equ 49 
213d				OPCODE_DOT: equ 50 
213d				OPCODE_CLS: equ 51 
213d				OPCODE_DRAW: equ 52 
213d				OPCODE_DUMP: equ 53 
213d				OPCODE_CDUMP: equ 54 
213d				OPCODE_DAT: equ 55 
213d				OPCODE_HOME: equ 56 
213d				OPCODE_SPACE: equ 57 
213d				OPCODE_SPACES: equ 58 
213d				OPCODE_SCROLL: equ 59 
213d				OPCODE_ATQ: equ 60 
213d				OPCODE_AUTODSP: equ 61 
213d				OPCODE_MENU: equ 62 
213d			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
213d				OPCODE_THEN: equ 64 
213d				OPCODE_ELSE: equ 65 
213d				OPCODE_DO: equ 66 
213d				OPCODE_LOOP: equ 67 
213d				OPCODE_I: equ 68 
213d				OPCODE_DLOOP: equ 69  
213d				OPCODE_REPEAT: equ 70  
213d				OPCODE_UNTIL: equ 71 
213d				OPCODE_ENDFLOW: equ 72 
213d				OPCODE_WAITK: equ 73 
213d				OPCODE_ACCEPT: equ 74 
213d				OPCODE_EDIT: equ 75 
213d			;free to reuse	OPCODE_ENDKEY: equ 76 
213d				OPCODE_LZERO: equ 77 
213d				OPCODE_TZERO: equ 78 
213d				OPCODE_LESS: equ 79 
213d				OPCODE_GT: equ 80 
213d				OPCODE_EQUAL: equ 81  
213d			;free to reuse	OPCODE_ENDLOGIC: equ 82 
213d				OPCODE_NEG: equ 83 
213d				OPCODE_DIV: equ 84 
213d				OPCODE_MUL: equ 85 
213d				OPCODE_MIN: equ 86 
213d				OPCODE_MAX: equ 87 
213d				OPCODE_RND16: equ 88 
213d				OPCODE_RND8: equ 89 
213d				OPCODE_RND: equ 90 
213d			;free to reuse	OPCODE_ENDMATHS: equ 91  
213d				OPCODE_BYNAME: equ 92 
213d				OPCODE_DIR: equ 93 
213d				OPCODE_SAVE: equ 94 
213d				OPCODE_LOAD: equ 95 
213d				OPCODE_BSAVE: equ 96 
213d				OPCODE_BLOAD: equ 97 
213d				OPCODE_SEO: equ 98  
213d				OPCODE_SEI: equ 99 
213d				OPCODE_SFREE: equ 100 
213d				OPCODE_SIZE: equ 101 
213d				OPCODE_CREATE: equ 102 
213d				OPCODE_APPEND: equ 103 
213d				OPCODE_SDEL: equ 104 
213d				OPCODE_OPEN: equ 105 
213d				OPCODE_READ: equ 106 
213d				OPCODE_EOF: equ 106 
213d				OPCODE_FORMAT: equ 107 
213d				OPCODE_LABEL: equ 108 
213d				OPCODE_LABELS: equ 109 
213d			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
213d				OPCODE_UPPER: equ 111 
213d				OPCODE_LOWER: equ 112 
213d				OPCODE_SUBSTR: equ 113 
213d				OPCODE_LEFT: equ 114 
213d				OPCODE_RIGHT: equ 115 
213d				OPCODE_STR2NUM: equ 116 
213d				OPCODE_NUM2STR: equ 117 
213d				OPCODE_CONCAT: equ 118 
213d				OPCODE_FIND: equ 119 
213d				OPCODE_LEN: equ 120 
213d				OPCODE_CHAR: equ 121 
213d			; free to reuse	OPCODE_STRLEN: equ 122 
213d			; free to reuse	OPCODE_ENDSTR: equ 123 
213d				OPCODE_V0S: equ 124 
213d				OPCODE_V0Q: equ 125 
213d				OPCODE_V1S: equ 126 
213d				OPCODE_V1Q: equ 127 
213d				OPCODE_V2S: equ 128 
213d				OPCODE_V2Q: equ 129 
213d				OPCODE_V3S: equ 130 
213d				OPCODE_V3Q: equ 131 
213d			;free to reuse	OPCODE_END: equ 132 
213d				OPCODE_ZDUP: equ 133 
213d			 
213d			; eof 
# End of file forth_opcodes.asm
213d			 
213d			include "forth_words_core.asm" 
213d			 
213d			; | ## Core Words 
213d			 
213d			;if MALLOC_4 
213d			 
213d			.HEAP: 
213d				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
213d 15				db WORD_SYS_CORE+OPCODE_HEAP             
213e 7c 21			dw .EXEC            
2140 05				db 4 + 1 
2141 .. 00			db "HEAP",0              
2146				endm 
# End of macro CWHEAD
2146			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
2146			; | | u1 - Current number of bytes in the heap 
2146			; | | u2 - Remaining bytes left on the heap 
2146			; | |  
2146			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
2146			 
2146			 
2146					if DEBUG_FORTH_WORDS_KEY 
2146						DMARK "HEP" 
2146 f5				push af  
2147 3a 5b 21			ld a, (.dmark)  
214a 32 bd fb			ld (debug_mark),a  
214d 3a 5c 21			ld a, (.dmark+1)  
2150 32 be fb			ld (debug_mark+1),a  
2153 3a 5d 21			ld a, (.dmark+2)  
2156 32 bf fb			ld (debug_mark+2),a  
2159 18 03			jr .pastdmark  
215b ..			.dmark: db "HEP"  
215e f1			.pastdmark: pop af  
215f			endm  
# End of macro DMARK
215f						CALLMONITOR 
215f cd ec 16			call break_point_state  
2162				endm  
# End of macro CALLMONITOR
2162					endif 
2162 2a 0a 80				ld hl, (free_list )      
2165 11 0e 80				ld de, heap_start 
2168			 
2168 ed 52				sbc hl, de  
216a			 
216a cd 7c 1c				call forth_push_numhl 
216d			 
216d			 
216d ed 5b 0a 80			ld de, (free_list )      
2171 21 89 ef				ld hl, heap_end 
2174			 
2174 ed 52				sbc hl, de 
2176			 
2176 cd 7c 1c				call forth_push_numhl 
2179					 
2179			 
2179					 
2179			 
2179			 
2179			 
2179					NEXTW 
2179 c3 e5 1f			jp macro_next 
217c				endm 
# End of macro NEXTW
217c			;endif 
217c			 
217c			.EXEC: 
217c				CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
217c 16				db WORD_SYS_CORE+OPCODE_EXEC             
217d 18 22			dw .STKEXEC            
217f 05				db 4 + 1 
2180 .. 00			db "EXEC",0              
2185				endm 
# End of macro CWHEAD
2185			; | EXEC ( u -- )    Execs the string on TOS as a FORTH expression | CRASHES ON NEXTW 
2185			; | | u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
2185			; | | 
2185			; | |   
2185				STACKFRAME OFF $5efe $5f9f 
2185				if DEBUG_STACK_IMB 
2185					if OFF 
2185						exx 
2185						ld de, $5efe 
2185						ld a, d 
2185						ld hl, curframe 
2185						call hexout 
2185						ld a, e 
2185						ld hl, curframe+2 
2185						call hexout 
2185						ld hl, $5efe 
2185						push hl 
2185						ld hl, $5f9f 
2185						push hl 
2185						exx 
2185					endif 
2185				endif 
2185			endm 
# End of macro STACKFRAME
2185			 
2185					if DEBUG_FORTH_WORDS_KEY 
2185						DMARK "EXE" 
2185 f5				push af  
2186 3a 9a 21			ld a, (.dmark)  
2189 32 bd fb			ld (debug_mark),a  
218c 3a 9b 21			ld a, (.dmark+1)  
218f 32 be fb			ld (debug_mark+1),a  
2192 3a 9c 21			ld a, (.dmark+2)  
2195 32 bf fb			ld (debug_mark+2),a  
2198 18 03			jr .pastdmark  
219a ..			.dmark: db "EXE"  
219d f1			.pastdmark: pop af  
219e			endm  
# End of macro DMARK
219e						CALLMONITOR 
219e cd ec 16			call break_point_state  
21a1				endm  
# End of macro CALLMONITOR
21a1					endif 
21a1			 
21a1				FORTH_DSP_VALUEHL 
21a1 cd 73 1e			call macro_dsp_valuehl 
21a4				endm 
# End of macro FORTH_DSP_VALUEHL
21a4			 
21a4				FORTH_DSP_POP 
21a4 cd 2b 1f			call macro_forth_dsp_pop 
21a7				endm 
# End of macro FORTH_DSP_POP
21a7			 
21a7					if DEBUG_FORTH_WORDS 
21a7						DMARK "EX1" 
21a7 f5				push af  
21a8 3a bc 21			ld a, (.dmark)  
21ab 32 bd fb			ld (debug_mark),a  
21ae 3a bd 21			ld a, (.dmark+1)  
21b1 32 be fb			ld (debug_mark+1),a  
21b4 3a be 21			ld a, (.dmark+2)  
21b7 32 bf fb			ld (debug_mark+2),a  
21ba 18 03			jr .pastdmark  
21bc ..			.dmark: db "EX1"  
21bf f1			.pastdmark: pop af  
21c0			endm  
# End of macro DMARK
21c0						CALLMONITOR 
21c0 cd ec 16			call break_point_state  
21c3				endm  
# End of macro CALLMONITOR
21c3					endif 
21c3			;	ld e,(hl) 
21c3			;	inc hl 
21c3			;	ld d,(hl) 
21c3			;	ex de,hl 
21c3			 
21c3			;		if DEBUG_FORTH_WORDS 
21c3			;			DMARK "EX2" 
21c3			;			CALLMONITOR 
21c3			;		endif 
21c3 e5				push hl 
21c4			 
21c4				;ld a, 0 
21c4				;ld a, FORTH_END_BUFFER 
21c4 cd 64 11			call strlenz 
21c7 23				inc hl   ; include zero term to copy 
21c8 23				inc hl   ; include term 
21c9 23				inc hl   ; include term 
21ca 06 00			ld b,0 
21cc 4d				ld c,l 
21cd e1				pop hl 
21ce 11 a2 f0			ld de, execscratch 
21d1					if DEBUG_FORTH_WORDS 
21d1						DMARK "EX3" 
21d1 f5				push af  
21d2 3a e6 21			ld a, (.dmark)  
21d5 32 bd fb			ld (debug_mark),a  
21d8 3a e7 21			ld a, (.dmark+1)  
21db 32 be fb			ld (debug_mark+1),a  
21de 3a e8 21			ld a, (.dmark+2)  
21e1 32 bf fb			ld (debug_mark+2),a  
21e4 18 03			jr .pastdmark  
21e6 ..			.dmark: db "EX3"  
21e9 f1			.pastdmark: pop af  
21ea			endm  
# End of macro DMARK
21ea						CALLMONITOR 
21ea cd ec 16			call break_point_state  
21ed				endm  
# End of macro CALLMONITOR
21ed					endif 
21ed ed b0			ldir 
21ef			 
21ef			 
21ef 21 a2 f0			ld hl, execscratch 
21f2			 
21f2					if DEBUG_FORTH_WORDS 
21f2						DMARK "EXe" 
21f2 f5				push af  
21f3 3a 07 22			ld a, (.dmark)  
21f6 32 bd fb			ld (debug_mark),a  
21f9 3a 08 22			ld a, (.dmark+1)  
21fc 32 be fb			ld (debug_mark+1),a  
21ff 3a 09 22			ld a, (.dmark+2)  
2202 32 bf fb			ld (debug_mark+2),a  
2205 18 03			jr .pastdmark  
2207 ..			.dmark: db "EXe"  
220a f1			.pastdmark: pop af  
220b			endm  
# End of macro DMARK
220b						CALLMONITOR 
220b cd ec 16			call break_point_state  
220e				endm  
# End of macro CALLMONITOR
220e					endif 
220e			 
220e cd 33 20			call forthparse 
2211 cd 73 20			call forthexec 
2214			;	call forthexec_cleanup 
2214			;	call forthparse 
2214			;	call forthexec 
2214			 
2214				STACKFRAMECHK OFF $5efe $5f9f 
2214				if DEBUG_STACK_IMB 
2214					if OFF 
2214						exx 
2214						ld hl, $5f9f 
2214						pop de   ; $5f9f 
2214						call cmp16 
2214						jr nz, .spnosame 
2214						ld hl, $5efe 
2214						pop de   ; $5efe 
2214						call cmp16 
2214						jr z, .spfrsame 
2214						.spnosame: call showsperror 
2214						.spfrsame: nop 
2214						exx 
2214					endif 
2214				endif 
2214			endm 
# End of macro STACKFRAMECHK
2214			 
2214				; an immediate word so no need to process any more words 
2214 c9				ret 
2215				NEXTW 
2215 c3 e5 1f			jp macro_next 
2218				endm 
# End of macro NEXTW
2218			 
2218			; dead code - old version  
2218			;	FORTH_RSP_NEXT 
2218			 
2218			;  
2218			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
2218			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
2218			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2218			;	push hl 
2218			;	push de 
2218			;	push bc 
2218			; 
2218			; 
2218			;		if DEBUG_FORTH_WORDS_KEY 
2218			;			DMARK "EXR" 
2218			;			CALLMONITOR 
2218			;		endif 
2218			; 
2218			; 
2218			; 
2218			;	;v5 FORTH_DSP_VALUE 
2218			;	FORTH_DSP_VALUEHL 
2218			; 
2218			;	; TODO do string type checks 
2218			; 
2218			;;v5	inc hl   ; skip type 
2218			; 
2218			;	push hl  ; source code  
2218			;		if DEBUG_FORTH_WORDS 
2218			;			DMARK "EX1" 
2218			;			CALLMONITOR 
2218			;		endif 
2218			;	ld a, 0 
2218			;	call strlent 
2218			; 
2218			;	inc hl 
2218			;	inc hl 
2218			;	inc hl 
2218			;	inc hl 
2218			; 
2218			;	push hl    ; size 
2218			; 
2218			;		if DEBUG_FORTH_WORDS 
2218			;			DMARK "EX2" 
2218			;			CALLMONITOR 
2218			;		endif 
2218			;	call malloc 
2218			; 
2218			;	ex de, hl    ; de now contains malloc area 
2218			;	pop bc   	; get byte count 
2218			;	pop hl      ; get string to copy 
2218			; 
2218			;	push de     ; save malloc for free later 
2218			; 
2218			;		if DEBUG_FORTH_WORDS 
2218			;			DMARK "EX3" 
2218			;			CALLMONITOR 
2218			;		endif 
2218			;	ldir       ; duplicate string 
2218			; 
2218			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
2218			;	 
2218			;	; TODO fix the parse would be better than this...  
2218			;	ex de, hl 
2218			;	dec hl 
2218			;	ld a, 0 
2218			;	ld (hl), a 
2218			;	dec hl 
2218			;	ld a, ' ' 
2218			;	ld (hl), a 
2218			;	dec hl 
2218			;	ld (hl), a 
2218			; 
2218			;	dec hl 
2218			;	ld (hl), a 
2218			; 
2218			; 
2218			;	FORTH_DSP_POP  
2218			; 
2218			;	pop hl     
2218			;	push hl    ; save malloc area 
2218			; 
2218			;		if DEBUG_FORTH_WORDS 
2218			;			DMARK "EX4" 
2218			;			CALLMONITOR 
2218			;		endif 
2218			; 
2218			;	call forthparse 
2218			;	call forthexec 
2218			;	 
2218			;	pop hl 
2218			;	if DEBUG_FORTH_WORDS 
2218			;		DMARK "EX5" 
2218			;		CALLMONITOR 
2218			;	endif 
2218			; 
2218			;	if FORTH_ENABLE_FREE 
2218			;	call free 
2218			;	endif 
2218			; 
2218			;	if DEBUG_FORTH_WORDS 
2218			;		DMARK "EX6" 
2218			;		CALLMONITOR 
2218			;	endif 
2218			; 
2218			;	pop bc 
2218			;	pop de 
2218			;	pop hl 
2218			;;	FORTH_RSP_POP	  
2218			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
2218			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
2218			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
2218			; 
2218			;	if DEBUG_FORTH_WORDS 
2218			;		DMARK "EX7" 
2218			;		CALLMONITOR 
2218			;	endif 
2218			;	NEXTW 
2218			 
2218			.STKEXEC: 
2218				CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
2218 3f				db WORD_SYS_CORE+43             
2219 60 23			dw .ZDUP            
221b 08				db 7 + 1 
221c .. 00			db "STKEXEC",0              
2224				endm 
# End of macro CWHEAD
2224			; | STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code | TO TEST 
2224			 
2224			 
2224					if DEBUG_FORTH_WORDS_KEY 
2224						DMARK "STX" 
2224 f5				push af  
2225 3a 39 22			ld a, (.dmark)  
2228 32 bd fb			ld (debug_mark),a  
222b 3a 3a 22			ld a, (.dmark+1)  
222e 32 be fb			ld (debug_mark+1),a  
2231 3a 3b 22			ld a, (.dmark+2)  
2234 32 bf fb			ld (debug_mark+2),a  
2237 18 03			jr .pastdmark  
2239 ..			.dmark: db "STX"  
223c f1			.pastdmark: pop af  
223d			endm  
# End of macro DMARK
223d						CALLMONITOR 
223d cd ec 16			call break_point_state  
2240				endm  
# End of macro CALLMONITOR
2240					endif 
2240			 
2240				FORTH_DSP_VALUEHL 
2240 cd 73 1e			call macro_dsp_valuehl 
2243				endm 
# End of macro FORTH_DSP_VALUEHL
2243			 
2243 22 e6 f9			ld (store_tmp1), hl    ; count 
2246			 
2246				FORTH_DSP_POP 
2246 cd 2b 1f			call macro_forth_dsp_pop 
2249				endm 
# End of macro FORTH_DSP_POP
2249			.stkexec1: 
2249 2a e6 f9			ld hl, (store_tmp1)   ; count 
224c 3e 00			ld a, 0 
224e bd				cp l 
224f c8				ret z 
2250			 
2250 2b				dec hl 
2251 22 e6 f9			ld (store_tmp1), hl    ; count 
2254				 
2254				FORTH_DSP_VALUEHL 
2254 cd 73 1e			call macro_dsp_valuehl 
2257				endm 
# End of macro FORTH_DSP_VALUEHL
2257 e5				push hl 
2258				 
2258					if DEBUG_FORTH_WORDS 
2258						DMARK "EXp" 
2258 f5				push af  
2259 3a 6d 22			ld a, (.dmark)  
225c 32 bd fb			ld (debug_mark),a  
225f 3a 6e 22			ld a, (.dmark+1)  
2262 32 be fb			ld (debug_mark+1),a  
2265 3a 6f 22			ld a, (.dmark+2)  
2268 32 bf fb			ld (debug_mark+2),a  
226b 18 03			jr .pastdmark  
226d ..			.dmark: db "EXp"  
2270 f1			.pastdmark: pop af  
2271			endm  
# End of macro DMARK
2271						CALLMONITOR 
2271 cd ec 16			call break_point_state  
2274				endm  
# End of macro CALLMONITOR
2274					endif 
2274				FORTH_DSP_POP 
2274 cd 2b 1f			call macro_forth_dsp_pop 
2277				endm 
# End of macro FORTH_DSP_POP
2277			 
2277 cd 64 11			call strlenz 
227a 23				inc hl   ; include zero term to copy 
227b 23				inc hl   ; include zero term to copy 
227c 23				inc hl   ; include zero term to copy 
227d 06 00			ld b,0 
227f 4d				ld c,l 
2280 e1				pop hl 
2281 11 a2 f0			ld de, execscratch 
2284					if DEBUG_FORTH_WORDS 
2284						DMARK "EX3" 
2284 f5				push af  
2285 3a 99 22			ld a, (.dmark)  
2288 32 bd fb			ld (debug_mark),a  
228b 3a 9a 22			ld a, (.dmark+1)  
228e 32 be fb			ld (debug_mark+1),a  
2291 3a 9b 22			ld a, (.dmark+2)  
2294 32 bf fb			ld (debug_mark+2),a  
2297 18 03			jr .pastdmark  
2299 ..			.dmark: db "EX3"  
229c f1			.pastdmark: pop af  
229d			endm  
# End of macro DMARK
229d						CALLMONITOR 
229d cd ec 16			call break_point_state  
22a0				endm  
# End of macro CALLMONITOR
22a0					endif 
22a0 ed b0			ldir 
22a2			 
22a2			 
22a2 21 a2 f0			ld hl, execscratch 
22a5			 
22a5					if DEBUG_FORTH_WORDS 
22a5						DMARK "EXP" 
22a5 f5				push af  
22a6 3a ba 22			ld a, (.dmark)  
22a9 32 bd fb			ld (debug_mark),a  
22ac 3a bb 22			ld a, (.dmark+1)  
22af 32 be fb			ld (debug_mark+1),a  
22b2 3a bc 22			ld a, (.dmark+2)  
22b5 32 bf fb			ld (debug_mark+2),a  
22b8 18 03			jr .pastdmark  
22ba ..			.dmark: db "EXP"  
22bd f1			.pastdmark: pop af  
22be			endm  
# End of macro DMARK
22be						CALLMONITOR 
22be cd ec 16			call break_point_state  
22c1				endm  
# End of macro CALLMONITOR
22c1					endif 
22c1			 
22c1 cd 33 20			call forthparse 
22c4 21 a2 f0			ld hl, execscratch 
22c7					if DEBUG_FORTH_WORDS 
22c7						DMARK "EXx" 
22c7 f5				push af  
22c8 3a dc 22			ld a, (.dmark)  
22cb 32 bd fb			ld (debug_mark),a  
22ce 3a dd 22			ld a, (.dmark+1)  
22d1 32 be fb			ld (debug_mark+1),a  
22d4 3a de 22			ld a, (.dmark+2)  
22d7 32 bf fb			ld (debug_mark+2),a  
22da 18 03			jr .pastdmark  
22dc ..			.dmark: db "EXx"  
22df f1			.pastdmark: pop af  
22e0			endm  
# End of macro DMARK
22e0						CALLMONITOR 
22e0 cd ec 16			call break_point_state  
22e3				endm  
# End of macro CALLMONITOR
22e3					endif 
22e3 cd 73 20			call forthexec 
22e6			 
22e6 c3 49 22			jp .stkexec1 
22e9			 
22e9 c9				ret 
22ea			 
22ea			 
22ea			.DUP: 
22ea				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
22ea 17				db WORD_SYS_CORE+OPCODE_DUP             
22eb 60 23			dw .ZDUP            
22ed 04				db 3 + 1 
22ee .. 00			db "DUP",0              
22f2				endm 
# End of macro CWHEAD
22f2			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
22f2			 
22f2					if DEBUG_FORTH_WORDS_KEY 
22f2						DMARK "DUP" 
22f2 f5				push af  
22f3 3a 07 23			ld a, (.dmark)  
22f6 32 bd fb			ld (debug_mark),a  
22f9 3a 08 23			ld a, (.dmark+1)  
22fc 32 be fb			ld (debug_mark+1),a  
22ff 3a 09 23			ld a, (.dmark+2)  
2302 32 bf fb			ld (debug_mark+2),a  
2305 18 03			jr .pastdmark  
2307 ..			.dmark: db "DUP"  
230a f1			.pastdmark: pop af  
230b			endm  
# End of macro DMARK
230b						CALLMONITOR 
230b cd ec 16			call break_point_state  
230e				endm  
# End of macro CALLMONITOR
230e					endif 
230e			 
230e					FORTH_DSP 
230e cd 39 1e			call macro_forth_dsp 
2311				endm 
# End of macro FORTH_DSP
2311			 
2311 7e					ld a, (HL) 
2312 fe 01				cp DS_TYPE_STR 
2314 20 25				jr nz, .dupinum 
2316			 
2316					; push another string 
2316			 
2316					FORTH_DSP_VALUEHL     		 
2316 cd 73 1e			call macro_dsp_valuehl 
2319				endm 
# End of macro FORTH_DSP_VALUEHL
2319			 
2319				if DEBUG_FORTH_WORDS 
2319					DMARK "DUs" 
2319 f5				push af  
231a 3a 2e 23			ld a, (.dmark)  
231d 32 bd fb			ld (debug_mark),a  
2320 3a 2f 23			ld a, (.dmark+1)  
2323 32 be fb			ld (debug_mark+1),a  
2326 3a 30 23			ld a, (.dmark+2)  
2329 32 bf fb			ld (debug_mark+2),a  
232c 18 03			jr .pastdmark  
232e ..			.dmark: db "DUs"  
2331 f1			.pastdmark: pop af  
2332			endm  
# End of macro DMARK
2332					CALLMONITOR 
2332 cd ec 16			call break_point_state  
2335				endm  
# End of macro CALLMONITOR
2335				endif 
2335 cd ea 1c				call forth_push_str 
2338			 
2338					NEXTW 
2338 c3 e5 1f			jp macro_next 
233b				endm 
# End of macro NEXTW
233b			 
233b			 
233b			.dupinum: 
233b					 
233b			 
233b			 
233b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
233b cd 73 1e			call macro_dsp_valuehl 
233e				endm 
# End of macro FORTH_DSP_VALUEHL
233e			 
233e				; TODO add floating point number detection 
233e			 
233e				if DEBUG_FORTH_WORDS 
233e					DMARK "DUi" 
233e f5				push af  
233f 3a 53 23			ld a, (.dmark)  
2342 32 bd fb			ld (debug_mark),a  
2345 3a 54 23			ld a, (.dmark+1)  
2348 32 be fb			ld (debug_mark+1),a  
234b 3a 55 23			ld a, (.dmark+2)  
234e 32 bf fb			ld (debug_mark+2),a  
2351 18 03			jr .pastdmark  
2353 ..			.dmark: db "DUi"  
2356 f1			.pastdmark: pop af  
2357			endm  
# End of macro DMARK
2357					CALLMONITOR 
2357 cd ec 16			call break_point_state  
235a				endm  
# End of macro CALLMONITOR
235a				endif 
235a			 
235a cd 7c 1c				call forth_push_numhl 
235d					NEXTW 
235d c3 e5 1f			jp macro_next 
2360				endm 
# End of macro NEXTW
2360			.ZDUP: 
2360				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
2360 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2361 98 23			dw .SWAP            
2363 05				db 4 + 1 
2364 .. 00			db "?DUP",0              
2369				endm 
# End of macro CWHEAD
2369			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
2369			 
2369					if DEBUG_FORTH_WORDS_KEY 
2369						DMARK "qDU" 
2369 f5				push af  
236a 3a 7e 23			ld a, (.dmark)  
236d 32 bd fb			ld (debug_mark),a  
2370 3a 7f 23			ld a, (.dmark+1)  
2373 32 be fb			ld (debug_mark+1),a  
2376 3a 80 23			ld a, (.dmark+2)  
2379 32 bf fb			ld (debug_mark+2),a  
237c 18 03			jr .pastdmark  
237e ..			.dmark: db "qDU"  
2381 f1			.pastdmark: pop af  
2382			endm  
# End of macro DMARK
2382						CALLMONITOR 
2382 cd ec 16			call break_point_state  
2385				endm  
# End of macro CALLMONITOR
2385					endif 
2385					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2385 cd 73 1e			call macro_dsp_valuehl 
2388				endm 
# End of macro FORTH_DSP_VALUEHL
2388			 
2388 e5					push hl 
2389			 
2389					; is it a zero? 
2389			 
2389 3e 00				ld a, 0 
238b 84					add h 
238c 85					add l 
238d			 
238d e1					pop hl 
238e			 
238e fe 00				cp 0 
2390 28 03				jr z, .dup2orig 
2392			 
2392			 
2392 cd 7c 1c				call forth_push_numhl 
2395			 
2395			 
2395				; TODO add floating point number detection 
2395			 
2395			.dup2orig: 
2395			 
2395					NEXTW 
2395 c3 e5 1f			jp macro_next 
2398				endm 
# End of macro NEXTW
2398			.SWAP: 
2398				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
2398 18				db WORD_SYS_CORE+OPCODE_SWAP             
2399 d7 23			dw .COLN            
239b 05				db 4 + 1 
239c .. 00			db "SWAP",0              
23a1				endm 
# End of macro CWHEAD
23a1			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
23a1					if DEBUG_FORTH_WORDS_KEY 
23a1						DMARK "SWP" 
23a1 f5				push af  
23a2 3a b6 23			ld a, (.dmark)  
23a5 32 bd fb			ld (debug_mark),a  
23a8 3a b7 23			ld a, (.dmark+1)  
23ab 32 be fb			ld (debug_mark+1),a  
23ae 3a b8 23			ld a, (.dmark+2)  
23b1 32 bf fb			ld (debug_mark+2),a  
23b4 18 03			jr .pastdmark  
23b6 ..			.dmark: db "SWP"  
23b9 f1			.pastdmark: pop af  
23ba			endm  
# End of macro DMARK
23ba						CALLMONITOR 
23ba cd ec 16			call break_point_state  
23bd				endm  
# End of macro CALLMONITOR
23bd					endif 
23bd			 
23bd					FORTH_DSP_VALUEHL 
23bd cd 73 1e			call macro_dsp_valuehl 
23c0				endm 
# End of macro FORTH_DSP_VALUEHL
23c0 e5					push hl     ; w2 
23c1			 
23c1					FORTH_DSP_POP 
23c1 cd 2b 1f			call macro_forth_dsp_pop 
23c4				endm 
# End of macro FORTH_DSP_POP
23c4			 
23c4					FORTH_DSP_VALUEHL 
23c4 cd 73 1e			call macro_dsp_valuehl 
23c7				endm 
# End of macro FORTH_DSP_VALUEHL
23c7			 
23c7					FORTH_DSP_POP 
23c7 cd 2b 1f			call macro_forth_dsp_pop 
23ca				endm 
# End of macro FORTH_DSP_POP
23ca			 
23ca d1					pop de     ; w2	, hl = w1 
23cb			 
23cb eb					ex de, hl 
23cc d5					push de 
23cd			 
23cd cd 7c 1c				call forth_push_numhl 
23d0			 
23d0 e1					pop hl 
23d1			 
23d1 cd 7c 1c				call forth_push_numhl 
23d4					 
23d4			 
23d4					NEXTW 
23d4 c3 e5 1f			jp macro_next 
23d7				endm 
# End of macro NEXTW
23d7			.COLN: 
23d7				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
23d7 19				db WORD_SYS_CORE+OPCODE_COLN             
23d8 63 25			dw .SCOLN            
23da 02				db 1 + 1 
23db .. 00			db ":",0              
23dd				endm 
# End of macro CWHEAD
23dd			; | : ( -- )         Create new word | DONE 
23dd			 
23dd					if DEBUG_FORTH_WORDS_KEY 
23dd						DMARK "CLN" 
23dd f5				push af  
23de 3a f2 23			ld a, (.dmark)  
23e1 32 bd fb			ld (debug_mark),a  
23e4 3a f3 23			ld a, (.dmark+1)  
23e7 32 be fb			ld (debug_mark+1),a  
23ea 3a f4 23			ld a, (.dmark+2)  
23ed 32 bf fb			ld (debug_mark+2),a  
23f0 18 03			jr .pastdmark  
23f2 ..			.dmark: db "CLN"  
23f5 f1			.pastdmark: pop af  
23f6			endm  
# End of macro DMARK
23f6						CALLMONITOR 
23f6 cd ec 16			call break_point_state  
23f9				endm  
# End of macro CALLMONITOR
23f9					endif 
23f9				STACKFRAME OFF $8efe $989f 
23f9				if DEBUG_STACK_IMB 
23f9					if OFF 
23f9						exx 
23f9						ld de, $8efe 
23f9						ld a, d 
23f9						ld hl, curframe 
23f9						call hexout 
23f9						ld a, e 
23f9						ld hl, curframe+2 
23f9						call hexout 
23f9						ld hl, $8efe 
23f9						push hl 
23f9						ld hl, $989f 
23f9						push hl 
23f9						exx 
23f9					endif 
23f9				endif 
23f9			endm 
# End of macro STACKFRAME
23f9				; get parser buffer length  of new word 
23f9			 
23f9				 
23f9			 
23f9					; move tok past this to start of name defintition 
23f9					; TODO get word to define 
23f9					; TODO Move past word token 
23f9					; TODO get length of string up to the ';' 
23f9			 
23f9 2a a4 f2			ld hl, (os_tok_ptr) 
23fc 23				inc hl 
23fd 23				inc hl 
23fe			 
23fe 3e 3b			ld a, ';' 
2400 cd 6f 11			call strlent 
2403			 
2403 7d				ld a,l 
2404 32 9f ef			ld (os_new_parse_len), a 
2407			 
2407			 
2407			if DEBUG_FORTH_UWORD 
2407 ed 5b a4 f2		ld de, (os_tok_ptr) 
240b						DMARK ":01" 
240b f5				push af  
240c 3a 20 24			ld a, (.dmark)  
240f 32 bd fb			ld (debug_mark),a  
2412 3a 21 24			ld a, (.dmark+1)  
2415 32 be fb			ld (debug_mark+1),a  
2418 3a 22 24			ld a, (.dmark+2)  
241b 32 bf fb			ld (debug_mark+2),a  
241e 18 03			jr .pastdmark  
2420 ..			.dmark: db ":01"  
2423 f1			.pastdmark: pop af  
2424			endm  
# End of macro DMARK
2424				CALLMONITOR 
2424 cd ec 16			call break_point_state  
2427				endm  
# End of macro CALLMONITOR
2427			endif 
2427			 
2427			; 
2427			;  new word memory layout: 
2427			;  
2427			;    : adg 6666 ;  
2427			; 
2427			;    db   1     ; user defined word  
2427 23				inc hl    
2428			;    dw   sysdict 
2428 23				inc hl 
2429 23				inc hl 
242a			;    db <word len>+1 (for null) 
242a 23				inc hl 
242b			;    db .... <word> 
242b			; 
242b			 
242b 23				inc hl    ; some extras for the word preamble before the above 
242c 23				inc hl 
242d 23				inc hl 
242e 23				inc hl 
242f 23				inc hl 
2430 23				inc hl 
2431 23				inc hl  
2432 23				inc hl 
2433 23				inc hl 
2434 23				inc hl 
2435 23				inc hl 
2436 23				inc hl 
2437 23				inc hl 
2438 23				inc hl     ; TODO how many do we really need?     maybe only 6 
2439			;       exec word buffer 
2439			;	<ptr word>   
2439 23				inc hl 
243a 23				inc hl 
243b			;       <word list><null term> 7F final term 
243b			 
243b			 
243b			if DEBUG_FORTH_UWORD 
243b						DMARK ":02" 
243b f5				push af  
243c 3a 50 24			ld a, (.dmark)  
243f 32 bd fb			ld (debug_mark),a  
2442 3a 51 24			ld a, (.dmark+1)  
2445 32 be fb			ld (debug_mark+1),a  
2448 3a 52 24			ld a, (.dmark+2)  
244b 32 bf fb			ld (debug_mark+2),a  
244e 18 03			jr .pastdmark  
2450 ..			.dmark: db ":02"  
2453 f1			.pastdmark: pop af  
2454			endm  
# End of macro DMARK
2454				CALLMONITOR 
2454 cd ec 16			call break_point_state  
2457				endm  
# End of macro CALLMONITOR
2457			endif 
2457			 
2457				 
2457					; malloc the size 
2457			 
2457 cd cd 11				call malloc 
245a 22 a1 ef				ld (os_new_malloc), hl     ; save malloc start 
245d			 
245d			;    db   1     ; user defined word  
245d 3e 01				ld a, WORD_SYS_UWORD  
245f 77					ld (hl), a 
2460				 
2460 23				inc hl    
2461			;    dw   sysdict 
2461 11 3d 21			ld de, sysdict       ; continue on with the scan to the system dict 
2464 73				ld (hl), e 
2465 23				inc hl 
2466 72				ld (hl), d 
2467 23				inc hl 
2468			 
2468			 
2468			;    Setup dict word 
2468			 
2468 23				inc hl 
2469 22 9b ef			ld (os_new_work_ptr), hl     ; save start of dict word  
246c			 
246c				; 1. get length of dict word 
246c			 
246c			 
246c 2a a4 f2			ld hl, (os_tok_ptr) 
246f 23				inc hl 
2470 23				inc hl    ; position to start of dict word 
2471 3e 00			ld a, 0 
2473 cd 6f 11			call strlent 
2476			 
2476			 
2476 23				inc hl    ; to include null??? 
2477			 
2477				; write length of dict word 
2477			 
2477 ed 5b 9b ef		ld de, (os_new_work_ptr)   ; get dest for copy of word 
247b 1b				dec de 
247c eb				ex de, hl 
247d 73				ld (hl), e 
247e eb				ex de, hl 
247f			 
247f				 
247f			 
247f				; copy  
247f 4d				ld c, l 
2480 06 00			ld b, 0 
2482 ed 5b 9b ef		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2486 2a a4 f2			ld hl, (os_tok_ptr) 
2489 23				inc hl 
248a 23				inc hl    ; position to start of dict word 
248b				 
248b			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
248b				 
248b				; TODO need to convert word to upper case 
248b			 
248b			ucasetok:	 
248b 7e				ld a,(hl) 
248c cd 5b 11			call toUpper 
248f 77				ld (hl),a 
2490 ed a0			ldi 
2492 f2 8b 24		 	jp p, ucasetok 
2495			 
2495			 
2495			 
2495				; de now points to start of where the word body code should be placed 
2495 ed 53 9b ef		ld (os_new_work_ptr), de 
2499				; hl now points to the words to throw at forthexec which needs to be copied 
2499 22 99 ef			ld (os_new_src_ptr), hl 
249c			 
249c				; TODO add 'call to forthexec' 
249c			 
249c			if DEBUG_FORTH_UWORD 
249c c5				push bc 
249d ed 4b a1 ef		ld bc, (os_new_malloc) 
24a1						DMARK ":0x" 
24a1 f5				push af  
24a2 3a b6 24			ld a, (.dmark)  
24a5 32 bd fb			ld (debug_mark),a  
24a8 3a b7 24			ld a, (.dmark+1)  
24ab 32 be fb			ld (debug_mark+1),a  
24ae 3a b8 24			ld a, (.dmark+2)  
24b1 32 bf fb			ld (debug_mark+2),a  
24b4 18 03			jr .pastdmark  
24b6 ..			.dmark: db ":0x"  
24b9 f1			.pastdmark: pop af  
24ba			endm  
# End of macro DMARK
24ba				CALLMONITOR 
24ba cd ec 16			call break_point_state  
24bd				endm  
# End of macro CALLMONITOR
24bd c1				pop bc 
24be			endif 
24be			 
24be			 
24be				; create word preamble which should be: 
24be			 
24be			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
24be			 
24be				;    ld hl, <word code> 
24be				;    jp user_exec 
24be			        ;    <word code bytes> 
24be			 
24be			 
24be			;	inc de     ; TODO ??? or are we already past the word's null 
24be eb				ex de, hl 
24bf			 
24bf 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
24c1			 
24c1 23				inc hl 
24c2 22 95 ef			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
24c5 23				inc hl 
24c6			 
24c6 23				inc hl 
24c7 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
24c9			 
24c9 01 a6 51			ld bc, user_exec 
24cc 23				inc hl 
24cd 71				ld (hl), c     ; poke address of user_exec 
24ce 23				inc hl 
24cf 70				ld (hl), b     
24d0			 ; 
24d0			;	inc hl 
24d0			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
24d0			; 
24d0			; 
24d0			;	ld bc, macro_forth_rsp_next 
24d0			;	inc hl 
24d0			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
24d0			;	inc hl 
24d0			;	ld (hl), b     
24d0			 ; 
24d0			;	inc hl 
24d0			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
24d0			; 
24d0			; 
24d0			;	inc hl 
24d0			;	ld bc, forthexec 
24d0			;	ld (hl), c     ; poke address of forthexec 
24d0			;	inc hl 
24d0			;	ld (hl), b      
24d0			; 
24d0			;	inc hl 
24d0			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
24d0			; 
24d0			;	ld bc, user_dict_next 
24d0			;	inc hl 
24d0			;	ld (hl), c     ; poke address of forthexec 
24d0			;	inc hl 
24d0			;	ld (hl), b      
24d0			 
24d0				; hl is now where we need to copy the word byte data to save this 
24d0			 
24d0 23				inc hl 
24d1 22 97 ef			ld (os_new_exec), hl 
24d4				 
24d4				; copy definition 
24d4			 
24d4 eb				ex de, hl 
24d5			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
24d5			;	inc de    ; skip the PC for this parse 
24d5 3a 9f ef			ld a, (os_new_parse_len) 
24d8 4f				ld c, a 
24d9 06 00			ld b, 0 
24db ed b0			ldir		 ; copy defintion 
24dd			 
24dd			 
24dd				; poke the address of where the new word bytes live for forthexec 
24dd			 
24dd 2a 95 ef			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
24e0			 
24e0 ed 5b 97 ef		ld de, (os_new_exec)      
24e4				 
24e4 73				ld (hl), e 
24e5 23				inc hl 
24e6 72				ld (hl), d 
24e7			 
24e7					; TODO copy last user dict word next link to this word 
24e7					; TODO update last user dict word to point to this word 
24e7			; 
24e7			; hl f923 de 812a ; bc 811a 
24e7			 
24e7			if DEBUG_FORTH_UWORD 
24e7 c5				push bc 
24e8 ed 4b a1 ef		ld bc, (os_new_malloc) 
24ec						DMARK ":0A" 
24ec f5				push af  
24ed 3a 01 25			ld a, (.dmark)  
24f0 32 bd fb			ld (debug_mark),a  
24f3 3a 02 25			ld a, (.dmark+1)  
24f6 32 be fb			ld (debug_mark+1),a  
24f9 3a 03 25			ld a, (.dmark+2)  
24fc 32 bf fb			ld (debug_mark+2),a  
24ff 18 03			jr .pastdmark  
2501 ..			.dmark: db ":0A"  
2504 f1			.pastdmark: pop af  
2505			endm  
# End of macro DMARK
2505				CALLMONITOR 
2505 cd ec 16			call break_point_state  
2508				endm  
# End of macro CALLMONITOR
2508 c1				pop bc 
2509			endif 
2509			if DEBUG_FORTH_UWORD 
2509 c5				push bc 
250a ed 4b a1 ef		ld bc, (os_new_malloc) 
250e 03				inc bc 
250f 03				inc bc 
2510 03				inc bc 
2511 03				inc bc 
2512 03				inc bc 
2513 03				inc bc 
2514 03				inc bc 
2515 03				inc bc 
2516			 
2516						DMARK ":0B" 
2516 f5				push af  
2517 3a 2b 25			ld a, (.dmark)  
251a 32 bd fb			ld (debug_mark),a  
251d 3a 2c 25			ld a, (.dmark+1)  
2520 32 be fb			ld (debug_mark+1),a  
2523 3a 2d 25			ld a, (.dmark+2)  
2526 32 bf fb			ld (debug_mark+2),a  
2529 18 03			jr .pastdmark  
252b ..			.dmark: db ":0B"  
252e f1			.pastdmark: pop af  
252f			endm  
# End of macro DMARK
252f				CALLMONITOR 
252f cd ec 16			call break_point_state  
2532				endm  
# End of macro CALLMONITOR
2532 c1				pop bc 
2533			endif 
2533			 
2533			; update word dict linked list for new word 
2533			 
2533			 
2533 2a a0 f2		ld hl, (os_last_new_uword)		; get the start of the last added uword 
2536 23			inc hl     ; move to next work linked list ptr 
2537			 
2537 ed 5b a1 ef	ld de, (os_new_malloc)		 ; new next word 
253b 73			ld (hl), e 
253c 23			inc hl 
253d 72			ld (hl), d 
253e			 
253e			if DEBUG_FORTH_UWORD 
253e ed 4b a0 f2		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
2542			endif 
2542			 
2542 ed 53 a0 f2	ld (os_last_new_uword), de      ; update last new uword ptr 
2546			 
2546			 
2546			if DEBUG_FORTH_UWORD 
2546						DMARK ":0+" 
2546 f5				push af  
2547 3a 5b 25			ld a, (.dmark)  
254a 32 bd fb			ld (debug_mark),a  
254d 3a 5c 25			ld a, (.dmark+1)  
2550 32 be fb			ld (debug_mark+1),a  
2553 3a 5d 25			ld a, (.dmark+2)  
2556 32 bf fb			ld (debug_mark+2),a  
2559 18 03			jr .pastdmark  
255b ..			.dmark: db ":0+"  
255e f1			.pastdmark: pop af  
255f			endm  
# End of macro DMARK
255f				CALLMONITOR 
255f cd ec 16			call break_point_state  
2562				endm  
# End of macro CALLMONITOR
2562			endif 
2562			 
2562				STACKFRAMECHK OFF $8efe $989f 
2562				if DEBUG_STACK_IMB 
2562					if OFF 
2562						exx 
2562						ld hl, $989f 
2562						pop de   ; $989f 
2562						call cmp16 
2562						jr nz, .spnosame 
2562						ld hl, $8efe 
2562						pop de   ; $8efe 
2562						call cmp16 
2562						jr z, .spfrsame 
2562						.spnosame: call showsperror 
2562						.spfrsame: nop 
2562						exx 
2562					endif 
2562				endif 
2562			endm 
# End of macro STACKFRAMECHK
2562			 
2562 c9			ret    ; dont process any remaining parser tokens as they form new word 
2563			 
2563			 
2563			 
2563			 
2563			;		NEXT 
2563			.SCOLN: 
2563			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
2563 06				db OPCODE_SCOLN 
2564 af 25			dw .DROP 
2566 02				db 2 
2567 .. 00			db ";",0           
2569			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
2569					if DEBUG_FORTH_WORDS_KEY 
2569						DMARK "SCN" 
2569 f5				push af  
256a 3a 7e 25			ld a, (.dmark)  
256d 32 bd fb			ld (debug_mark),a  
2570 3a 7f 25			ld a, (.dmark+1)  
2573 32 be fb			ld (debug_mark+1),a  
2576 3a 80 25			ld a, (.dmark+2)  
2579 32 bf fb			ld (debug_mark+2),a  
257c 18 03			jr .pastdmark  
257e ..			.dmark: db "SCN"  
2581 f1			.pastdmark: pop af  
2582			endm  
# End of macro DMARK
2582						CALLMONITOR 
2582 cd ec 16			call break_point_state  
2585				endm  
# End of macro CALLMONITOR
2585					endif 
2585					FORTH_RSP_TOS 
2585 cd 3a 1c			call macro_forth_rsp_tos 
2588				endm 
# End of macro FORTH_RSP_TOS
2588 e5					push hl 
2589					FORTH_RSP_POP 
2589 cd 44 1c			call macro_forth_rsp_pop 
258c				endm 
# End of macro FORTH_RSP_POP
258c e1					pop hl 
258d			;		ex de,hl 
258d 22 a4 f2				ld (os_tok_ptr),hl 
2590			 
2590			if DEBUG_FORTH_UWORD 
2590						DMARK "SCL" 
2590 f5				push af  
2591 3a a5 25			ld a, (.dmark)  
2594 32 bd fb			ld (debug_mark),a  
2597 3a a6 25			ld a, (.dmark+1)  
259a 32 be fb			ld (debug_mark+1),a  
259d 3a a7 25			ld a, (.dmark+2)  
25a0 32 bf fb			ld (debug_mark+2),a  
25a3 18 03			jr .pastdmark  
25a5 ..			.dmark: db "SCL"  
25a8 f1			.pastdmark: pop af  
25a9			endm  
# End of macro DMARK
25a9				CALLMONITOR 
25a9 cd ec 16			call break_point_state  
25ac				endm  
# End of macro CALLMONITOR
25ac			endif 
25ac					NEXTW 
25ac c3 e5 1f			jp macro_next 
25af				endm 
# End of macro NEXTW
25af			 
25af			.DROP: 
25af				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
25af 1b				db WORD_SYS_CORE+OPCODE_DROP             
25b0 da 25			dw .DUP2            
25b2 05				db 4 + 1 
25b3 .. 00			db "DROP",0              
25b8				endm 
# End of macro CWHEAD
25b8			; | DROP ( w -- )   drop the TOS item   | DONE 
25b8					if DEBUG_FORTH_WORDS_KEY 
25b8						DMARK "DRP" 
25b8 f5				push af  
25b9 3a cd 25			ld a, (.dmark)  
25bc 32 bd fb			ld (debug_mark),a  
25bf 3a ce 25			ld a, (.dmark+1)  
25c2 32 be fb			ld (debug_mark+1),a  
25c5 3a cf 25			ld a, (.dmark+2)  
25c8 32 bf fb			ld (debug_mark+2),a  
25cb 18 03			jr .pastdmark  
25cd ..			.dmark: db "DRP"  
25d0 f1			.pastdmark: pop af  
25d1			endm  
# End of macro DMARK
25d1						CALLMONITOR 
25d1 cd ec 16			call break_point_state  
25d4				endm  
# End of macro CALLMONITOR
25d4					endif 
25d4					FORTH_DSP_POP 
25d4 cd 2b 1f			call macro_forth_dsp_pop 
25d7				endm 
# End of macro FORTH_DSP_POP
25d7					NEXTW 
25d7 c3 e5 1f			jp macro_next 
25da				endm 
# End of macro NEXTW
25da			.DUP2: 
25da				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
25da 1c				db WORD_SYS_CORE+OPCODE_DUP2             
25db 1f 26			dw .DROP2            
25dd 05				db 4 + 1 
25de .. 00			db "2DUP",0              
25e3				endm 
# End of macro CWHEAD
25e3			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
25e3					if DEBUG_FORTH_WORDS_KEY 
25e3						DMARK "2DU" 
25e3 f5				push af  
25e4 3a f8 25			ld a, (.dmark)  
25e7 32 bd fb			ld (debug_mark),a  
25ea 3a f9 25			ld a, (.dmark+1)  
25ed 32 be fb			ld (debug_mark+1),a  
25f0 3a fa 25			ld a, (.dmark+2)  
25f3 32 bf fb			ld (debug_mark+2),a  
25f6 18 03			jr .pastdmark  
25f8 ..			.dmark: db "2DU"  
25fb f1			.pastdmark: pop af  
25fc			endm  
# End of macro DMARK
25fc						CALLMONITOR 
25fc cd ec 16			call break_point_state  
25ff				endm  
# End of macro CALLMONITOR
25ff					endif 
25ff					FORTH_DSP_VALUEHL 
25ff cd 73 1e			call macro_dsp_valuehl 
2602				endm 
# End of macro FORTH_DSP_VALUEHL
2602 e5					push hl      ; 2 
2603			 
2603					FORTH_DSP_POP 
2603 cd 2b 1f			call macro_forth_dsp_pop 
2606				endm 
# End of macro FORTH_DSP_POP
2606					 
2606					FORTH_DSP_VALUEHL 
2606 cd 73 1e			call macro_dsp_valuehl 
2609				endm 
# End of macro FORTH_DSP_VALUEHL
2609			;		push hl      ; 1 
2609			 
2609					FORTH_DSP_POP 
2609 cd 2b 1f			call macro_forth_dsp_pop 
260c				endm 
# End of macro FORTH_DSP_POP
260c			 
260c			;		pop hl       ; 1 
260c d1					pop de       ; 2 
260d			 
260d cd 7c 1c				call forth_push_numhl 
2610 eb					ex de, hl 
2611 cd 7c 1c				call forth_push_numhl 
2614			 
2614					 
2614 eb					ex de, hl 
2615			 
2615 cd 7c 1c				call forth_push_numhl 
2618 eb					ex de, hl 
2619 cd 7c 1c				call forth_push_numhl 
261c			 
261c			 
261c					NEXTW 
261c c3 e5 1f			jp macro_next 
261f				endm 
# End of macro NEXTW
261f			.DROP2: 
261f				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
261f 1d				db WORD_SYS_CORE+OPCODE_DROP2             
2620 4e 26			dw .SWAP2            
2622 06				db 5 + 1 
2623 .. 00			db "2DROP",0              
2629				endm 
# End of macro CWHEAD
2629			; | 2DROP ( w w -- )    Double drop | DONE 
2629					if DEBUG_FORTH_WORDS_KEY 
2629						DMARK "2DR" 
2629 f5				push af  
262a 3a 3e 26			ld a, (.dmark)  
262d 32 bd fb			ld (debug_mark),a  
2630 3a 3f 26			ld a, (.dmark+1)  
2633 32 be fb			ld (debug_mark+1),a  
2636 3a 40 26			ld a, (.dmark+2)  
2639 32 bf fb			ld (debug_mark+2),a  
263c 18 03			jr .pastdmark  
263e ..			.dmark: db "2DR"  
2641 f1			.pastdmark: pop af  
2642			endm  
# End of macro DMARK
2642						CALLMONITOR 
2642 cd ec 16			call break_point_state  
2645				endm  
# End of macro CALLMONITOR
2645					endif 
2645					FORTH_DSP_POP 
2645 cd 2b 1f			call macro_forth_dsp_pop 
2648				endm 
# End of macro FORTH_DSP_POP
2648					FORTH_DSP_POP 
2648 cd 2b 1f			call macro_forth_dsp_pop 
264b				endm 
# End of macro FORTH_DSP_POP
264b					NEXTW 
264b c3 e5 1f			jp macro_next 
264e				endm 
# End of macro NEXTW
264e			.SWAP2: 
264e				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
264e 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
264f 77 26			dw .AT            
2651 06				db 5 + 1 
2652 .. 00			db "2SWAP",0              
2658				endm 
# End of macro CWHEAD
2658			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
2658					if DEBUG_FORTH_WORDS_KEY 
2658						DMARK "2SW" 
2658 f5				push af  
2659 3a 6d 26			ld a, (.dmark)  
265c 32 bd fb			ld (debug_mark),a  
265f 3a 6e 26			ld a, (.dmark+1)  
2662 32 be fb			ld (debug_mark+1),a  
2665 3a 6f 26			ld a, (.dmark+2)  
2668 32 bf fb			ld (debug_mark+2),a  
266b 18 03			jr .pastdmark  
266d ..			.dmark: db "2SW"  
2670 f1			.pastdmark: pop af  
2671			endm  
# End of macro DMARK
2671						CALLMONITOR 
2671 cd ec 16			call break_point_state  
2674				endm  
# End of macro CALLMONITOR
2674					endif 
2674					NEXTW 
2674 c3 e5 1f			jp macro_next 
2677				endm 
# End of macro NEXTW
2677			.AT: 
2677				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
2677 1f				db WORD_SYS_CORE+OPCODE_AT             
2678 a9 26			dw .CAT            
267a 02				db 1 + 1 
267b .. 00			db "@",0              
267d				endm 
# End of macro CWHEAD
267d			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
267d			 
267d					if DEBUG_FORTH_WORDS_KEY 
267d						DMARK "AT." 
267d f5				push af  
267e 3a 92 26			ld a, (.dmark)  
2681 32 bd fb			ld (debug_mark),a  
2684 3a 93 26			ld a, (.dmark+1)  
2687 32 be fb			ld (debug_mark+1),a  
268a 3a 94 26			ld a, (.dmark+2)  
268d 32 bf fb			ld (debug_mark+2),a  
2690 18 03			jr .pastdmark  
2692 ..			.dmark: db "AT."  
2695 f1			.pastdmark: pop af  
2696			endm  
# End of macro DMARK
2696						CALLMONITOR 
2696 cd ec 16			call break_point_state  
2699				endm  
# End of macro CALLMONITOR
2699					endif 
2699			.getbyteat:	 
2699					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2699 cd 73 1e			call macro_dsp_valuehl 
269c				endm 
# End of macro FORTH_DSP_VALUEHL
269c					 
269c			;		push hl 
269c				 
269c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
269c cd 2b 1f			call macro_forth_dsp_pop 
269f				endm 
# End of macro FORTH_DSP_POP
269f			 
269f			;		pop hl 
269f			 
269f 7e					ld a, (hl) 
26a0			 
26a0 6f					ld l, a 
26a1 26 00				ld h, 0 
26a3 cd 7c 1c				call forth_push_numhl 
26a6			 
26a6					NEXTW 
26a6 c3 e5 1f			jp macro_next 
26a9				endm 
# End of macro NEXTW
26a9			.CAT: 
26a9				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
26a9 20				db WORD_SYS_CORE+OPCODE_CAT             
26aa d2 26			dw .BANG            
26ac 03				db 2 + 1 
26ad .. 00			db "C@",0              
26b0				endm 
# End of macro CWHEAD
26b0			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
26b0					if DEBUG_FORTH_WORDS_KEY 
26b0						DMARK "CAA" 
26b0 f5				push af  
26b1 3a c5 26			ld a, (.dmark)  
26b4 32 bd fb			ld (debug_mark),a  
26b7 3a c6 26			ld a, (.dmark+1)  
26ba 32 be fb			ld (debug_mark+1),a  
26bd 3a c7 26			ld a, (.dmark+2)  
26c0 32 bf fb			ld (debug_mark+2),a  
26c3 18 03			jr .pastdmark  
26c5 ..			.dmark: db "CAA"  
26c8 f1			.pastdmark: pop af  
26c9			endm  
# End of macro DMARK
26c9						CALLMONITOR 
26c9 cd ec 16			call break_point_state  
26cc				endm  
# End of macro CALLMONITOR
26cc					endif 
26cc c3 99 26				jp .getbyteat 
26cf					NEXTW 
26cf c3 e5 1f			jp macro_next 
26d2				endm 
# End of macro NEXTW
26d2			.BANG: 
26d2				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
26d2 21				db WORD_SYS_CORE+OPCODE_BANG             
26d3 08 27			dw .CBANG            
26d5 02				db 1 + 1 
26d6 .. 00			db "!",0              
26d8				endm 
# End of macro CWHEAD
26d8			; | ! ( x w -- ) Store x at address w      | DONE 
26d8					if DEBUG_FORTH_WORDS_KEY 
26d8						DMARK "BNG" 
26d8 f5				push af  
26d9 3a ed 26			ld a, (.dmark)  
26dc 32 bd fb			ld (debug_mark),a  
26df 3a ee 26			ld a, (.dmark+1)  
26e2 32 be fb			ld (debug_mark+1),a  
26e5 3a ef 26			ld a, (.dmark+2)  
26e8 32 bf fb			ld (debug_mark+2),a  
26eb 18 03			jr .pastdmark  
26ed ..			.dmark: db "BNG"  
26f0 f1			.pastdmark: pop af  
26f1			endm  
# End of macro DMARK
26f1						CALLMONITOR 
26f1 cd ec 16			call break_point_state  
26f4				endm  
# End of macro CALLMONITOR
26f4					endif 
26f4			 
26f4			.storebyteat:		 
26f4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26f4 cd 73 1e			call macro_dsp_valuehl 
26f7				endm 
# End of macro FORTH_DSP_VALUEHL
26f7					 
26f7 e5					push hl 
26f8				 
26f8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26f8 cd 2b 1f			call macro_forth_dsp_pop 
26fb				endm 
# End of macro FORTH_DSP_POP
26fb			 
26fb					; get byte to poke 
26fb			 
26fb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26fb cd 73 1e			call macro_dsp_valuehl 
26fe				endm 
# End of macro FORTH_DSP_VALUEHL
26fe e5					push hl 
26ff			 
26ff			 
26ff					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26ff cd 2b 1f			call macro_forth_dsp_pop 
2702				endm 
# End of macro FORTH_DSP_POP
2702			 
2702			 
2702 d1					pop de 
2703 e1					pop hl 
2704			 
2704 73					ld (hl),e 
2705			 
2705			 
2705					NEXTW 
2705 c3 e5 1f			jp macro_next 
2708				endm 
# End of macro NEXTW
2708			.CBANG: 
2708				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
2708 22				db WORD_SYS_CORE+OPCODE_CBANG             
2709 31 27			dw .SCALL            
270b 03				db 2 + 1 
270c .. 00			db "C!",0              
270f				endm 
# End of macro CWHEAD
270f			; | C!  ( x w -- ) Store x at address w  | DONE 
270f					if DEBUG_FORTH_WORDS_KEY 
270f						DMARK "CBA" 
270f f5				push af  
2710 3a 24 27			ld a, (.dmark)  
2713 32 bd fb			ld (debug_mark),a  
2716 3a 25 27			ld a, (.dmark+1)  
2719 32 be fb			ld (debug_mark+1),a  
271c 3a 26 27			ld a, (.dmark+2)  
271f 32 bf fb			ld (debug_mark+2),a  
2722 18 03			jr .pastdmark  
2724 ..			.dmark: db "CBA"  
2727 f1			.pastdmark: pop af  
2728			endm  
# End of macro DMARK
2728						CALLMONITOR 
2728 cd ec 16			call break_point_state  
272b				endm  
# End of macro CALLMONITOR
272b					endif 
272b c3 f4 26				jp .storebyteat 
272e					NEXTW 
272e c3 e5 1f			jp macro_next 
2731				endm 
# End of macro NEXTW
2731			.SCALL: 
2731				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
2731 23				db WORD_SYS_CORE+OPCODE_SCALL             
2732 65 27			dw .DEPTH            
2734 05				db 4 + 1 
2735 .. 00			db "CALL",0              
273a				endm 
# End of macro CWHEAD
273a			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
273a					if DEBUG_FORTH_WORDS_KEY 
273a						DMARK "CLL" 
273a f5				push af  
273b 3a 4f 27			ld a, (.dmark)  
273e 32 bd fb			ld (debug_mark),a  
2741 3a 50 27			ld a, (.dmark+1)  
2744 32 be fb			ld (debug_mark+1),a  
2747 3a 51 27			ld a, (.dmark+2)  
274a 32 bf fb			ld (debug_mark+2),a  
274d 18 03			jr .pastdmark  
274f ..			.dmark: db "CLL"  
2752 f1			.pastdmark: pop af  
2753			endm  
# End of macro DMARK
2753						CALLMONITOR 
2753 cd ec 16			call break_point_state  
2756				endm  
# End of macro CALLMONITOR
2756					endif 
2756			 
2756					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2756 cd 73 1e			call macro_dsp_valuehl 
2759				endm 
# End of macro FORTH_DSP_VALUEHL
2759			 
2759			;		push hl 
2759			 
2759					; destroy value TOS 
2759			 
2759					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2759 cd 2b 1f			call macro_forth_dsp_pop 
275c				endm 
# End of macro FORTH_DSP_POP
275c			 
275c						 
275c			;		pop hl 
275c			 
275c					; how to do a call with hl???? save SP? 
275c cd 8e 1f				call forth_call_hl 
275f			 
275f			 
275f					; TODO push value back onto stack for another op etc 
275f			 
275f cd 7c 1c				call forth_push_numhl 
2762					NEXTW 
2762 c3 e5 1f			jp macro_next 
2765				endm 
# End of macro NEXTW
2765			.DEPTH: 
2765				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2765 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2766 a2 27			dw .OVER            
2768 06				db 5 + 1 
2769 .. 00			db "DEPTH",0              
276f				endm 
# End of macro CWHEAD
276f			; | DEPTH ( -- u ) Push count of stack | DONE 
276f					; take current TOS and remove from base value div by two to get count 
276f					if DEBUG_FORTH_WORDS_KEY 
276f						DMARK "DEP" 
276f f5				push af  
2770 3a 84 27			ld a, (.dmark)  
2773 32 bd fb			ld (debug_mark),a  
2776 3a 85 27			ld a, (.dmark+1)  
2779 32 be fb			ld (debug_mark+1),a  
277c 3a 86 27			ld a, (.dmark+2)  
277f 32 bf fb			ld (debug_mark+2),a  
2782 18 03			jr .pastdmark  
2784 ..			.dmark: db "DEP"  
2787 f1			.pastdmark: pop af  
2788			endm  
# End of macro DMARK
2788						CALLMONITOR 
2788 cd ec 16			call break_point_state  
278b				endm  
# End of macro CALLMONITOR
278b					endif 
278b			 
278b			 
278b 2a 90 f9			ld hl, (cli_data_sp) 
278e 11 0a f5			ld de, cli_data_stack 
2791 ed 52			sbc hl,de 
2793				 
2793				; div by size of stack item 
2793			 
2793 5d				ld e,l 
2794 0e 03			ld c, 3 
2796 cd 96 0c			call Div8 
2799			 
2799 6f				ld l,a 
279a 26 00			ld h,0 
279c			 
279c				;srl h 
279c				;rr l 
279c			 
279c cd 7c 1c				call forth_push_numhl 
279f					NEXTW 
279f c3 e5 1f			jp macro_next 
27a2				endm 
# End of macro NEXTW
27a2			.OVER: 
27a2				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
27a2 42				db WORD_SYS_CORE+46             
27a3 e9 27			dw .PAUSE            
27a5 05				db 4 + 1 
27a6 .. 00			db "OVER",0              
27ab				endm 
# End of macro CWHEAD
27ab			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
27ab					if DEBUG_FORTH_WORDS_KEY 
27ab						DMARK "OVR" 
27ab f5				push af  
27ac 3a c0 27			ld a, (.dmark)  
27af 32 bd fb			ld (debug_mark),a  
27b2 3a c1 27			ld a, (.dmark+1)  
27b5 32 be fb			ld (debug_mark+1),a  
27b8 3a c2 27			ld a, (.dmark+2)  
27bb 32 bf fb			ld (debug_mark+2),a  
27be 18 03			jr .pastdmark  
27c0 ..			.dmark: db "OVR"  
27c3 f1			.pastdmark: pop af  
27c4			endm  
# End of macro DMARK
27c4						CALLMONITOR 
27c4 cd ec 16			call break_point_state  
27c7				endm  
# End of macro CALLMONITOR
27c7					endif 
27c7			 
27c7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
27c7 cd 73 1e			call macro_dsp_valuehl 
27ca				endm 
# End of macro FORTH_DSP_VALUEHL
27ca e5					push hl    ; n2 
27cb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
27cb cd 2b 1f			call macro_forth_dsp_pop 
27ce				endm 
# End of macro FORTH_DSP_POP
27ce			 
27ce					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
27ce cd 73 1e			call macro_dsp_valuehl 
27d1				endm 
# End of macro FORTH_DSP_VALUEHL
27d1 e5					push hl    ; n1 
27d2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
27d2 cd 2b 1f			call macro_forth_dsp_pop 
27d5				endm 
# End of macro FORTH_DSP_POP
27d5			 
27d5 d1					pop de     ; n1 
27d6 e1					pop hl     ; n2 
27d7			 
27d7 d5					push de 
27d8 e5					push hl 
27d9 d5					push de 
27da			 
27da					; push back  
27da			 
27da e1					pop hl 
27db cd 7c 1c				call forth_push_numhl 
27de e1					pop hl 
27df cd 7c 1c				call forth_push_numhl 
27e2 e1					pop hl 
27e3 cd 7c 1c				call forth_push_numhl 
27e6					NEXTW 
27e6 c3 e5 1f			jp macro_next 
27e9				endm 
# End of macro NEXTW
27e9			 
27e9			.PAUSE: 
27e9				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
27e9 43				db WORD_SYS_CORE+47             
27ea 1e 28			dw .PAUSES            
27ec 08				db 7 + 1 
27ed .. 00			db "PAUSEMS",0              
27f5				endm 
# End of macro CWHEAD
27f5			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
27f5					if DEBUG_FORTH_WORDS_KEY 
27f5						DMARK "PMS" 
27f5 f5				push af  
27f6 3a 0a 28			ld a, (.dmark)  
27f9 32 bd fb			ld (debug_mark),a  
27fc 3a 0b 28			ld a, (.dmark+1)  
27ff 32 be fb			ld (debug_mark+1),a  
2802 3a 0c 28			ld a, (.dmark+2)  
2805 32 bf fb			ld (debug_mark+2),a  
2808 18 03			jr .pastdmark  
280a ..			.dmark: db "PMS"  
280d f1			.pastdmark: pop af  
280e			endm  
# End of macro DMARK
280e						CALLMONITOR 
280e cd ec 16			call break_point_state  
2811				endm  
# End of macro CALLMONITOR
2811					endif 
2811					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2811 cd 73 1e			call macro_dsp_valuehl 
2814				endm 
# End of macro FORTH_DSP_VALUEHL
2814			;		push hl    ; n2 
2814					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2814 cd 2b 1f			call macro_forth_dsp_pop 
2817				endm 
# End of macro FORTH_DSP_POP
2817			;		pop hl 
2817			 
2817 7d					ld a, l 
2818 cd 37 0a				call aDelayInMS 
281b				       NEXTW 
281b c3 e5 1f			jp macro_next 
281e				endm 
# End of macro NEXTW
281e			.PAUSES:  
281e				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
281e 44				db WORD_SYS_CORE+48             
281f 8d 28			dw .ROT            
2821 06				db 5 + 1 
2822 .. 00			db "PAUSE",0              
2828				endm 
# End of macro CWHEAD
2828			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2828					if DEBUG_FORTH_WORDS_KEY 
2828						DMARK "PAU" 
2828 f5				push af  
2829 3a 3d 28			ld a, (.dmark)  
282c 32 bd fb			ld (debug_mark),a  
282f 3a 3e 28			ld a, (.dmark+1)  
2832 32 be fb			ld (debug_mark+1),a  
2835 3a 3f 28			ld a, (.dmark+2)  
2838 32 bf fb			ld (debug_mark+2),a  
283b 18 03			jr .pastdmark  
283d ..			.dmark: db "PAU"  
2840 f1			.pastdmark: pop af  
2841			endm  
# End of macro DMARK
2841						CALLMONITOR 
2841 cd ec 16			call break_point_state  
2844				endm  
# End of macro CALLMONITOR
2844					endif 
2844					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2844 cd 73 1e			call macro_dsp_valuehl 
2847				endm 
# End of macro FORTH_DSP_VALUEHL
2847			;		push hl    ; n2 
2847					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2847 cd 2b 1f			call macro_forth_dsp_pop 
284a				endm 
# End of macro FORTH_DSP_POP
284a			;		pop hl 
284a 45					ld b, l 
284b					if DEBUG_FORTH_WORDS 
284b						DMARK "PAU" 
284b f5				push af  
284c 3a 60 28			ld a, (.dmark)  
284f 32 bd fb			ld (debug_mark),a  
2852 3a 61 28			ld a, (.dmark+1)  
2855 32 be fb			ld (debug_mark+1),a  
2858 3a 62 28			ld a, (.dmark+2)  
285b 32 bf fb			ld (debug_mark+2),a  
285e 18 03			jr .pastdmark  
2860 ..			.dmark: db "PAU"  
2863 f1			.pastdmark: pop af  
2864			endm  
# End of macro DMARK
2864						CALLMONITOR 
2864 cd ec 16			call break_point_state  
2867				endm  
# End of macro CALLMONITOR
2867					endif 
2867 c5			.pauses1:	push bc 
2868 cd 52 0a				call delay1s 
286b c1					pop bc 
286c					if DEBUG_FORTH_WORDS 
286c						DMARK "PA1" 
286c f5				push af  
286d 3a 81 28			ld a, (.dmark)  
2870 32 bd fb			ld (debug_mark),a  
2873 3a 82 28			ld a, (.dmark+1)  
2876 32 be fb			ld (debug_mark+1),a  
2879 3a 83 28			ld a, (.dmark+2)  
287c 32 bf fb			ld (debug_mark+2),a  
287f 18 03			jr .pastdmark  
2881 ..			.dmark: db "PA1"  
2884 f1			.pastdmark: pop af  
2885			endm  
# End of macro DMARK
2885						CALLMONITOR 
2885 cd ec 16			call break_point_state  
2888				endm  
# End of macro CALLMONITOR
2888					endif 
2888 10 dd				djnz .pauses1 
288a			 
288a				       NEXTW 
288a c3 e5 1f			jp macro_next 
288d				endm 
# End of macro NEXTW
288d			.ROT: 
288d				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
288d 45				db WORD_SYS_CORE+49             
288e db 28			dw .UWORDS            
2890 04				db 3 + 1 
2891 .. 00			db "ROT",0              
2895				endm 
# End of macro CWHEAD
2895			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2895					if DEBUG_FORTH_WORDS_KEY 
2895						DMARK "ROT" 
2895 f5				push af  
2896 3a aa 28			ld a, (.dmark)  
2899 32 bd fb			ld (debug_mark),a  
289c 3a ab 28			ld a, (.dmark+1)  
289f 32 be fb			ld (debug_mark+1),a  
28a2 3a ac 28			ld a, (.dmark+2)  
28a5 32 bf fb			ld (debug_mark+2),a  
28a8 18 03			jr .pastdmark  
28aa ..			.dmark: db "ROT"  
28ad f1			.pastdmark: pop af  
28ae			endm  
# End of macro DMARK
28ae						CALLMONITOR 
28ae cd ec 16			call break_point_state  
28b1				endm  
# End of macro CALLMONITOR
28b1					endif 
28b1			 
28b1					FORTH_DSP_VALUEHL 
28b1 cd 73 1e			call macro_dsp_valuehl 
28b4				endm 
# End of macro FORTH_DSP_VALUEHL
28b4 e5					push hl    ; u3  
28b5			 
28b5					FORTH_DSP_POP 
28b5 cd 2b 1f			call macro_forth_dsp_pop 
28b8				endm 
# End of macro FORTH_DSP_POP
28b8			   
28b8					FORTH_DSP_VALUEHL 
28b8 cd 73 1e			call macro_dsp_valuehl 
28bb				endm 
# End of macro FORTH_DSP_VALUEHL
28bb e5					push hl     ; u2 
28bc			 
28bc					FORTH_DSP_POP 
28bc cd 2b 1f			call macro_forth_dsp_pop 
28bf				endm 
# End of macro FORTH_DSP_POP
28bf			 
28bf					FORTH_DSP_VALUEHL 
28bf cd 73 1e			call macro_dsp_valuehl 
28c2				endm 
# End of macro FORTH_DSP_VALUEHL
28c2 e5					push hl     ; u1 
28c3			 
28c3					FORTH_DSP_POP 
28c3 cd 2b 1f			call macro_forth_dsp_pop 
28c6				endm 
# End of macro FORTH_DSP_POP
28c6			 
28c6 c1					pop bc      ; u1 
28c7 e1					pop hl      ; u2 
28c8 d1					pop de      ; u3 
28c9			 
28c9			 
28c9 c5					push bc 
28ca d5					push de 
28cb e5					push hl 
28cc			 
28cc			 
28cc e1					pop hl 
28cd cd 7c 1c				call forth_push_numhl 
28d0			 
28d0 e1					pop hl 
28d1 cd 7c 1c				call forth_push_numhl 
28d4			 
28d4 e1					pop hl 
28d5 cd 7c 1c				call forth_push_numhl 
28d8					 
28d8			 
28d8			 
28d8			 
28d8			 
28d8			 
28d8				       NEXTW 
28d8 c3 e5 1f			jp macro_next 
28db				endm 
# End of macro NEXTW
28db			 
28db			.UWORDS: 
28db				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
28db 50				db WORD_SYS_CORE+60             
28dc 9d 29			dw .BP            
28de 07				db 6 + 1 
28df .. 00			db "UWORDS",0              
28e6				endm 
# End of macro CWHEAD
28e6			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
28e6			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
28e6			; | | Following the count are the individual words. 
28e6			; | | 
28e6			; | | e.g. UWORDS 
28e6			; | | BOX DIRLIST 2 
28e6			; | |  
28e6			; | | Can be used to save the words to storage via: 
28e6			; | | UWORDS $01 DO $01 APPEND LOOP 
28e6				if DEBUG_FORTH_WORDS_KEY 
28e6					DMARK "UWR" 
28e6 f5				push af  
28e7 3a fb 28			ld a, (.dmark)  
28ea 32 bd fb			ld (debug_mark),a  
28ed 3a fc 28			ld a, (.dmark+1)  
28f0 32 be fb			ld (debug_mark+1),a  
28f3 3a fd 28			ld a, (.dmark+2)  
28f6 32 bf fb			ld (debug_mark+2),a  
28f9 18 03			jr .pastdmark  
28fb ..			.dmark: db "UWR"  
28fe f1			.pastdmark: pop af  
28ff			endm  
# End of macro DMARK
28ff					CALLMONITOR 
28ff cd ec 16			call break_point_state  
2902				endm  
# End of macro CALLMONITOR
2902				endif 
2902 21 00 80				ld hl, baseram 
2905					;ld hl, baseusermem 
2905 01 00 00				ld bc, 0    ; start a counter 
2908			 
2908				; skip dict stub 
2908			 
2908 cd 36 21				call forth_tok_next 
290b			 
290b			 
290b			; while we have words to look for 
290b			 
290b 7e			.douscan:	ld a, (hl)      
290c				if DEBUG_FORTH_WORDS 
290c					DMARK "UWs" 
290c f5				push af  
290d 3a 21 29			ld a, (.dmark)  
2910 32 bd fb			ld (debug_mark),a  
2913 3a 22 29			ld a, (.dmark+1)  
2916 32 be fb			ld (debug_mark+1),a  
2919 3a 23 29			ld a, (.dmark+2)  
291c 32 bf fb			ld (debug_mark+2),a  
291f 18 03			jr .pastdmark  
2921 ..			.dmark: db "UWs"  
2924 f1			.pastdmark: pop af  
2925			endm  
# End of macro DMARK
2925					CALLMONITOR 
2925 cd ec 16			call break_point_state  
2928				endm  
# End of macro CALLMONITOR
2928				endif 
2928 fe 00				cp WORD_SYS_END 
292a 28 4d				jr z, .udone 
292c fe 01				cp WORD_SYS_UWORD 
292e 20 44				jr nz, .nuword 
2930			 
2930				if DEBUG_FORTH_WORDS 
2930					DMARK "UWu" 
2930 f5				push af  
2931 3a 45 29			ld a, (.dmark)  
2934 32 bd fb			ld (debug_mark),a  
2937 3a 46 29			ld a, (.dmark+1)  
293a 32 be fb			ld (debug_mark+1),a  
293d 3a 47 29			ld a, (.dmark+2)  
2940 32 bf fb			ld (debug_mark+2),a  
2943 18 03			jr .pastdmark  
2945 ..			.dmark: db "UWu"  
2948 f1			.pastdmark: pop af  
2949			endm  
# End of macro DMARK
2949					CALLMONITOR 
2949 cd ec 16			call break_point_state  
294c				endm  
# End of macro CALLMONITOR
294c				endif 
294c					; we have a uword so push its name to the stack 
294c			 
294c e5				   	push hl  ; save so we can move to next dict block 
294d			 
294d					; skip opcode 
294d 23					inc hl  
294e					; skip next ptr 
294e 23					inc hl  
294f 23					inc hl 
2950					; skip len 
2950 23					inc hl 
2951				if DEBUG_FORTH_WORDS 
2951					DMARK "UWt" 
2951 f5				push af  
2952 3a 66 29			ld a, (.dmark)  
2955 32 bd fb			ld (debug_mark),a  
2958 3a 67 29			ld a, (.dmark+1)  
295b 32 be fb			ld (debug_mark+1),a  
295e 3a 68 29			ld a, (.dmark+2)  
2961 32 bf fb			ld (debug_mark+2),a  
2964 18 03			jr .pastdmark  
2966 ..			.dmark: db "UWt"  
2969 f1			.pastdmark: pop af  
296a			endm  
# End of macro DMARK
296a					CALLMONITOR 
296a cd ec 16			call break_point_state  
296d				endm  
# End of macro CALLMONITOR
296d				endif 
296d 03					inc bc 
296e			 
296e c5					push bc 
296f cd ea 1c				call forth_push_str 
2972 c1					pop bc 
2973			 
2973 e1					pop hl 	 
2974			 
2974 cd 36 21		.nuword:	call forth_tok_next 
2977 18 92				jr .douscan  
2979			 
2979			.udone:		 ; push count of uwords found 
2979 c5					push bc 
297a e1					pop hl 
297b			 
297b				if DEBUG_FORTH_WORDS 
297b					DMARK "UWc" 
297b f5				push af  
297c 3a 90 29			ld a, (.dmark)  
297f 32 bd fb			ld (debug_mark),a  
2982 3a 91 29			ld a, (.dmark+1)  
2985 32 be fb			ld (debug_mark+1),a  
2988 3a 92 29			ld a, (.dmark+2)  
298b 32 bf fb			ld (debug_mark+2),a  
298e 18 03			jr .pastdmark  
2990 ..			.dmark: db "UWc"  
2993 f1			.pastdmark: pop af  
2994			endm  
# End of macro DMARK
2994					CALLMONITOR 
2994 cd ec 16			call break_point_state  
2997				endm  
# End of macro CALLMONITOR
2997				endif 
2997 cd 7c 1c				call forth_push_numhl 
299a			 
299a			 
299a				       NEXTW 
299a c3 e5 1f			jp macro_next 
299d				endm 
# End of macro NEXTW
299d			 
299d			.BP: 
299d				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
299d 54				db WORD_SYS_CORE+64             
299e d3 29			dw .MONITOR            
29a0 03				db 2 + 1 
29a1 .. 00			db "BP",0              
29a4				endm 
# End of macro CWHEAD
29a4			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
29a4			; | | $00 Will enable the break points within specific code paths 
29a4			; | | $01 Will disable break points 
29a4			; | |  
29a4			; | | By default break points are off. Either the above can be used to enable them 
29a4			; | | or if a key is held down during start up the spashscreen will appear to freeze 
29a4			; | | and on release of the pressed key a message will be disaplayed to notify 
29a4			; | | that break points are enabled. Pressing any key will then continue boot process. 
29a4					; get byte count 
29a4					if DEBUG_FORTH_WORDS_KEY 
29a4						DMARK "BP." 
29a4 f5				push af  
29a5 3a b9 29			ld a, (.dmark)  
29a8 32 bd fb			ld (debug_mark),a  
29ab 3a ba 29			ld a, (.dmark+1)  
29ae 32 be fb			ld (debug_mark+1),a  
29b1 3a bb 29			ld a, (.dmark+2)  
29b4 32 bf fb			ld (debug_mark+2),a  
29b7 18 03			jr .pastdmark  
29b9 ..			.dmark: db "BP."  
29bc f1			.pastdmark: pop af  
29bd			endm  
# End of macro DMARK
29bd						CALLMONITOR 
29bd cd ec 16			call break_point_state  
29c0				endm  
# End of macro CALLMONITOR
29c0					endif 
29c0			 
29c0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29c0 cd 73 1e			call macro_dsp_valuehl 
29c3				endm 
# End of macro FORTH_DSP_VALUEHL
29c3			 
29c3			;		push hl 
29c3			 
29c3					; destroy value TOS 
29c3			 
29c3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29c3 cd 2b 1f			call macro_forth_dsp_pop 
29c6				endm 
# End of macro FORTH_DSP_POP
29c6			 
29c6			;		pop hl 
29c6			 
29c6 3e 00				ld a,0 
29c8 bd					cp l 
29c9 28 02				jr z, .bpset 
29cb 3e 2a				ld a, '*' 
29cd			 
29cd 32 94 ef		.bpset:		ld (os_view_disable), a 
29d0			 
29d0			 
29d0					NEXTW 
29d0 c3 e5 1f			jp macro_next 
29d3				endm 
# End of macro NEXTW
29d3			 
29d3			 
29d3			.MONITOR: 
29d3				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
29d3 55				db WORD_SYS_CORE+65             
29d4 06 2a			dw .MALLOC            
29d6 08				db 7 + 1 
29d7 .. 00			db "MONITOR",0              
29df				endm 
# End of macro CWHEAD
29df			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
29df			; | | At start the current various registers will be displayed with contents. 
29df			; | | Top right corner will show the most recent debug marker seen. 
29df			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
29df			; | | and the return stack pointer (RSP). 
29df			; | | Pressing: 
29df			; | |    1 - Initial screen 
29df			; | |    2 - Display a data dump of HL 
29df			; | |    3 - Display a data dump of DE 
29df			; | |    4 - Display a data dump of BC 
29df			; | |    5 - Display a data dump of HL 
29df			; | |    6 - Display a data dump of DSP 
29df			; | |    7 - Display a data dump of RSP 
29df			; | |    8 - Display a data dump of what is at DSP 
29df			; | |    9 - Display a data dump of what is at RSP 
29df			; | |    0 - Exit monitor and continue running. This will also enable break points 
29df			; | |    * - Disable break points 
29df			; | |    # - Enter traditional monitor mode 
29df			; | | 
29df			; | | Monitor Mode 
29df			; | | ------------ 
29df			; | | A prompt of '>' will be shown for various commands: 
29df			; | |    D xxxx - Display a data dump starting from hex address xxxx 
29df			; | |    C - Continue display a data dump from the last set address 
29df			; | |    M xxxx - Set start of memory edit at address xx 
29df			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
29df			; | |    Q - Return to previous 
29df					if DEBUG_FORTH_WORDS_KEY 
29df						DMARK "MON" 
29df f5				push af  
29e0 3a f4 29			ld a, (.dmark)  
29e3 32 bd fb			ld (debug_mark),a  
29e6 3a f5 29			ld a, (.dmark+1)  
29e9 32 be fb			ld (debug_mark+1),a  
29ec 3a f6 29			ld a, (.dmark+2)  
29ef 32 bf fb			ld (debug_mark+2),a  
29f2 18 03			jr .pastdmark  
29f4 ..			.dmark: db "MON"  
29f7 f1			.pastdmark: pop af  
29f8			endm  
# End of macro DMARK
29f8						CALLMONITOR 
29f8 cd ec 16			call break_point_state  
29fb				endm  
# End of macro CALLMONITOR
29fb					endif 
29fb 3e 00				ld a, 0 
29fd 32 94 ef				ld (os_view_disable), a 
2a00			 
2a00					CALLMONITOR 
2a00 cd ec 16			call break_point_state  
2a03				endm  
# End of macro CALLMONITOR
2a03			 
2a03			;	call monitor 
2a03			 
2a03					NEXTW 
2a03 c3 e5 1f			jp macro_next 
2a06				endm 
# End of macro NEXTW
2a06			 
2a06			 
2a06			.MALLOC: 
2a06				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2a06 56				db WORD_SYS_CORE+66             
2a07 2f 2a			dw .MALLOC2            
2a09 06				db 5 + 1 
2a0a .. 00			db "ALLOT",0              
2a10				endm 
# End of macro CWHEAD
2a10			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2a10					if DEBUG_FORTH_WORDS_KEY 
2a10						DMARK "ALL" 
2a10 f5				push af  
2a11 3a 25 2a			ld a, (.dmark)  
2a14 32 bd fb			ld (debug_mark),a  
2a17 3a 26 2a			ld a, (.dmark+1)  
2a1a 32 be fb			ld (debug_mark+1),a  
2a1d 3a 27 2a			ld a, (.dmark+2)  
2a20 32 bf fb			ld (debug_mark+2),a  
2a23 18 03			jr .pastdmark  
2a25 ..			.dmark: db "ALL"  
2a28 f1			.pastdmark: pop af  
2a29			endm  
# End of macro DMARK
2a29						CALLMONITOR 
2a29 cd ec 16			call break_point_state  
2a2c				endm  
# End of macro CALLMONITOR
2a2c					endif 
2a2c c3 56 2a				jp .mallocc 
2a2f			.MALLOC2: 
2a2f				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2a2f 56				db WORD_SYS_CORE+66             
2a30 6d 2a			dw .FREE            
2a32 07				db 6 + 1 
2a33 .. 00			db "MALLOC",0              
2a3a				endm 
# End of macro CWHEAD
2a3a			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2a3a					; get byte count 
2a3a					if DEBUG_FORTH_WORDS_KEY 
2a3a						DMARK "MAL" 
2a3a f5				push af  
2a3b 3a 4f 2a			ld a, (.dmark)  
2a3e 32 bd fb			ld (debug_mark),a  
2a41 3a 50 2a			ld a, (.dmark+1)  
2a44 32 be fb			ld (debug_mark+1),a  
2a47 3a 51 2a			ld a, (.dmark+2)  
2a4a 32 bf fb			ld (debug_mark+2),a  
2a4d 18 03			jr .pastdmark  
2a4f ..			.dmark: db "MAL"  
2a52 f1			.pastdmark: pop af  
2a53			endm  
# End of macro DMARK
2a53						CALLMONITOR 
2a53 cd ec 16			call break_point_state  
2a56				endm  
# End of macro CALLMONITOR
2a56					endif 
2a56			.mallocc: 
2a56					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a56 cd 73 1e			call macro_dsp_valuehl 
2a59				endm 
# End of macro FORTH_DSP_VALUEHL
2a59			 
2a59			;		push hl 
2a59			 
2a59					; destroy value TOS 
2a59			 
2a59					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a59 cd 2b 1f			call macro_forth_dsp_pop 
2a5c				endm 
# End of macro FORTH_DSP_POP
2a5c			 
2a5c			;		pop hl 
2a5c cd cd 11				call malloc 
2a5f				if DEBUG_FORTH_MALLOC_GUARD 
2a5f f5					push af 
2a60 cd 2f 0d				call ishlzero 
2a63			;		ld a, l 
2a63			;		add h 
2a63			;		cp 0 
2a63 f1					pop af 
2a64					 
2a64 cc 78 52				call z,malloc_error 
2a67				endif 
2a67			 
2a67 cd 7c 1c				call forth_push_numhl 
2a6a					NEXTW 
2a6a c3 e5 1f			jp macro_next 
2a6d				endm 
# End of macro NEXTW
2a6d			 
2a6d			.FREE: 
2a6d				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2a6d 57				db WORD_SYS_CORE+67             
2a6e 9e 2a			dw .LIST            
2a70 05				db 4 + 1 
2a71 .. 00			db "FREE",0              
2a76				endm 
# End of macro CWHEAD
2a76			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2a76					if DEBUG_FORTH_WORDS_KEY 
2a76						DMARK "FRE" 
2a76 f5				push af  
2a77 3a 8b 2a			ld a, (.dmark)  
2a7a 32 bd fb			ld (debug_mark),a  
2a7d 3a 8c 2a			ld a, (.dmark+1)  
2a80 32 be fb			ld (debug_mark+1),a  
2a83 3a 8d 2a			ld a, (.dmark+2)  
2a86 32 bf fb			ld (debug_mark+2),a  
2a89 18 03			jr .pastdmark  
2a8b ..			.dmark: db "FRE"  
2a8e f1			.pastdmark: pop af  
2a8f			endm  
# End of macro DMARK
2a8f						CALLMONITOR 
2a8f cd ec 16			call break_point_state  
2a92				endm  
# End of macro CALLMONITOR
2a92					endif 
2a92					; get address 
2a92			 
2a92					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a92 cd 73 1e			call macro_dsp_valuehl 
2a95				endm 
# End of macro FORTH_DSP_VALUEHL
2a95			 
2a95			;		push hl 
2a95			 
2a95					; destroy value TOS 
2a95			 
2a95					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a95 cd 2b 1f			call macro_forth_dsp_pop 
2a98				endm 
# End of macro FORTH_DSP_POP
2a98			 
2a98			;		pop hl 
2a98			if FORTH_ENABLE_MALLOCFREE 
2a98 cd 97 12				call free 
2a9b			endif 
2a9b					NEXTW 
2a9b c3 e5 1f			jp macro_next 
2a9e				endm 
# End of macro NEXTW
2a9e			.LIST: 
2a9e				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2a9e 5c				db WORD_SYS_CORE+72             
2a9f 61 2c			dw .FORGET            
2aa1 05				db 4 + 1 
2aa2 .. 00			db "LIST",0              
2aa7				endm 
# End of macro CWHEAD
2aa7			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2aa7			; | | The quoted word must be in upper case. 
2aa7				if DEBUG_FORTH_WORDS_KEY 
2aa7					DMARK "LST" 
2aa7 f5				push af  
2aa8 3a bc 2a			ld a, (.dmark)  
2aab 32 bd fb			ld (debug_mark),a  
2aae 3a bd 2a			ld a, (.dmark+1)  
2ab1 32 be fb			ld (debug_mark+1),a  
2ab4 3a be 2a			ld a, (.dmark+2)  
2ab7 32 bf fb			ld (debug_mark+2),a  
2aba 18 03			jr .pastdmark  
2abc ..			.dmark: db "LST"  
2abf f1			.pastdmark: pop af  
2ac0			endm  
# End of macro DMARK
2ac0					CALLMONITOR 
2ac0 cd ec 16			call break_point_state  
2ac3				endm  
# End of macro CALLMONITOR
2ac3				endif 
2ac3			 
2ac3					FORTH_DSP_VALUEHL 
2ac3 cd 73 1e			call macro_dsp_valuehl 
2ac6				endm 
# End of macro FORTH_DSP_VALUEHL
2ac6			 
2ac6 e5					push hl 
2ac7 c1					pop bc 
2ac8			 
2ac8			; Start format of scratch string 
2ac8			 
2ac8 21 a3 ef				ld hl, scratch 
2acb			 
2acb 3e 3a				ld a, ':' 
2acd 77					ld (hl),a 
2ace 23					inc hl 
2acf 3e 20				ld a, ' ' 
2ad1 77					ld (hl), a 
2ad2			 
2ad2					; Get ptr to the word we need to look up 
2ad2			 
2ad2			;		FORTH_DSP_VALUEHL 
2ad2					;v5 FORTH_DSP_VALUE 
2ad2				; TODO type check 
2ad2			;		inc hl    ; Skip type check  
2ad2			;		push hl 
2ad2			;		ex de, hl    ; put into DE 
2ad2			 
2ad2			 
2ad2 21 00 80				ld hl, baseram 
2ad5					;ld hl, baseusermem 
2ad5			 
2ad5 e5			push hl   ; sacreifical push 
2ad6			 
2ad6			.ldouscanm: 
2ad6 e1				pop hl 
2ad7			.ldouscan: 
2ad7				if DEBUG_FORTH_WORDS 
2ad7					DMARK "LSs" 
2ad7 f5				push af  
2ad8 3a ec 2a			ld a, (.dmark)  
2adb 32 bd fb			ld (debug_mark),a  
2ade 3a ed 2a			ld a, (.dmark+1)  
2ae1 32 be fb			ld (debug_mark+1),a  
2ae4 3a ee 2a			ld a, (.dmark+2)  
2ae7 32 bf fb			ld (debug_mark+2),a  
2aea 18 03			jr .pastdmark  
2aec ..			.dmark: db "LSs"  
2aef f1			.pastdmark: pop af  
2af0			endm  
# End of macro DMARK
2af0					CALLMONITOR 
2af0 cd ec 16			call break_point_state  
2af3				endm  
# End of macro CALLMONITOR
2af3				endif 
2af3				; skip dict stub 
2af3 cd 36 21				call forth_tok_next 
2af6			 
2af6			 
2af6			; while we have words to look for 
2af6			 
2af6 7e				ld a, (hl)      
2af7				if DEBUG_FORTH_WORDS 
2af7					DMARK "LSk" 
2af7 f5				push af  
2af8 3a 0c 2b			ld a, (.dmark)  
2afb 32 bd fb			ld (debug_mark),a  
2afe 3a 0d 2b			ld a, (.dmark+1)  
2b01 32 be fb			ld (debug_mark+1),a  
2b04 3a 0e 2b			ld a, (.dmark+2)  
2b07 32 bf fb			ld (debug_mark+2),a  
2b0a 18 03			jr .pastdmark  
2b0c ..			.dmark: db "LSk"  
2b0f f1			.pastdmark: pop af  
2b10			endm  
# End of macro DMARK
2b10					CALLMONITOR 
2b10 cd ec 16			call break_point_state  
2b13				endm  
# End of macro CALLMONITOR
2b13				endif 
2b13 fe 00				cp WORD_SYS_END 
2b15 ca 48 2c				jp z, .lunotfound 
2b18 fe 01				cp WORD_SYS_UWORD 
2b1a c2 d7 2a				jp nz, .ldouscan 
2b1d			 
2b1d				if DEBUG_FORTH_WORDS 
2b1d					DMARK "LSu" 
2b1d f5				push af  
2b1e 3a 32 2b			ld a, (.dmark)  
2b21 32 bd fb			ld (debug_mark),a  
2b24 3a 33 2b			ld a, (.dmark+1)  
2b27 32 be fb			ld (debug_mark+1),a  
2b2a 3a 34 2b			ld a, (.dmark+2)  
2b2d 32 bf fb			ld (debug_mark+2),a  
2b30 18 03			jr .pastdmark  
2b32 ..			.dmark: db "LSu"  
2b35 f1			.pastdmark: pop af  
2b36			endm  
# End of macro DMARK
2b36					CALLMONITOR 
2b36 cd ec 16			call break_point_state  
2b39				endm  
# End of macro CALLMONITOR
2b39				endif 
2b39			 
2b39					; found a uword but is it the one we want... 
2b39			 
2b39 c5					push bc     ; uword to find is on bc 
2b3a d1					pop de 
2b3b			 
2b3b e5					push hl  ; to save the ptr 
2b3c			 
2b3c					; skip opcode 
2b3c 23					inc hl  
2b3d					; skip next ptr 
2b3d 23					inc hl  
2b3e 23					inc hl 
2b3f					; skip len 
2b3f 23					inc hl 
2b40			 
2b40				if DEBUG_FORTH_WORDS 
2b40					DMARK "LSc" 
2b40 f5				push af  
2b41 3a 55 2b			ld a, (.dmark)  
2b44 32 bd fb			ld (debug_mark),a  
2b47 3a 56 2b			ld a, (.dmark+1)  
2b4a 32 be fb			ld (debug_mark+1),a  
2b4d 3a 57 2b			ld a, (.dmark+2)  
2b50 32 bf fb			ld (debug_mark+2),a  
2b53 18 03			jr .pastdmark  
2b55 ..			.dmark: db "LSc"  
2b58 f1			.pastdmark: pop af  
2b59			endm  
# End of macro DMARK
2b59					CALLMONITOR 
2b59 cd ec 16			call break_point_state  
2b5c				endm  
# End of macro CALLMONITOR
2b5c				endif 
2b5c cd 9c 11				call strcmp 
2b5f c2 d6 2a				jp nz, .ldouscanm 
2b62				 
2b62			 
2b62			 
2b62					; we have a uword so push its name to the stack 
2b62			 
2b62			;	   	push hl  ; save so we can move to next dict block 
2b62 e1			pop hl 
2b63			 
2b63				if DEBUG_FORTH_WORDS 
2b63					DMARK "LSm" 
2b63 f5				push af  
2b64 3a 78 2b			ld a, (.dmark)  
2b67 32 bd fb			ld (debug_mark),a  
2b6a 3a 79 2b			ld a, (.dmark+1)  
2b6d 32 be fb			ld (debug_mark+1),a  
2b70 3a 7a 2b			ld a, (.dmark+2)  
2b73 32 bf fb			ld (debug_mark+2),a  
2b76 18 03			jr .pastdmark  
2b78 ..			.dmark: db "LSm"  
2b7b f1			.pastdmark: pop af  
2b7c			endm  
# End of macro DMARK
2b7c					CALLMONITOR 
2b7c cd ec 16			call break_point_state  
2b7f				endm  
# End of macro CALLMONITOR
2b7f				endif 
2b7f			 
2b7f					; skip opcode 
2b7f 23					inc hl  
2b80					; skip next ptr 
2b80 23					inc hl  
2b81 23					inc hl 
2b82					; skip len 
2b82 7e					ld a, (hl)   ; save length to add 
2b83				if DEBUG_FORTH_WORDS 
2b83					DMARK "LS2" 
2b83 f5				push af  
2b84 3a 98 2b			ld a, (.dmark)  
2b87 32 bd fb			ld (debug_mark),a  
2b8a 3a 99 2b			ld a, (.dmark+1)  
2b8d 32 be fb			ld (debug_mark+1),a  
2b90 3a 9a 2b			ld a, (.dmark+2)  
2b93 32 bf fb			ld (debug_mark+2),a  
2b96 18 03			jr .pastdmark  
2b98 ..			.dmark: db "LS2"  
2b9b f1			.pastdmark: pop af  
2b9c			endm  
# End of macro DMARK
2b9c					CALLMONITOR 
2b9c cd ec 16			call break_point_state  
2b9f				endm  
# End of macro CALLMONITOR
2b9f				endif 
2b9f			 
2b9f					; save this location 
2b9f				 
2b9f e5					push hl 
2ba0			 
2ba0 23					inc hl 
2ba1 11 a5 ef				ld de, scratch+2 
2ba4 4f					ld c, a 
2ba5 06 00				ld b, 0 
2ba7			 
2ba7				if DEBUG_FORTH_WORDS 
2ba7					DMARK "LSn" 
2ba7 f5				push af  
2ba8 3a bc 2b			ld a, (.dmark)  
2bab 32 bd fb			ld (debug_mark),a  
2bae 3a bd 2b			ld a, (.dmark+1)  
2bb1 32 be fb			ld (debug_mark+1),a  
2bb4 3a be 2b			ld a, (.dmark+2)  
2bb7 32 bf fb			ld (debug_mark+2),a  
2bba 18 03			jr .pastdmark  
2bbc ..			.dmark: db "LSn"  
2bbf f1			.pastdmark: pop af  
2bc0			endm  
# End of macro DMARK
2bc0					CALLMONITOR 
2bc0 cd ec 16			call break_point_state  
2bc3				endm  
# End of macro CALLMONITOR
2bc3				endif 
2bc3			 
2bc3					; copy uword name to scratch 
2bc3			 
2bc3 ed b0				ldir 
2bc5			 
2bc5 1b					dec de 
2bc6 3e 20				ld a, ' '    ; change null to space 
2bc8 12					ld (de), a 
2bc9			 
2bc9 13					inc de 
2bca			 
2bca d5					push de 
2bcb c1					pop bc     ; move scratch pointer to end of word name and save it 
2bcc			 
2bcc e1					pop hl 
2bcd 7e					ld a, (hl) 
2bce					;inc hl 
2bce					; skip word string 
2bce cd 06 0d				call addatohl 
2bd1			 
2bd1 23					inc hl 
2bd2			 
2bd2				if DEBUG_FORTH_WORDS 
2bd2					DMARK "LS3" 
2bd2 f5				push af  
2bd3 3a e7 2b			ld a, (.dmark)  
2bd6 32 bd fb			ld (debug_mark),a  
2bd9 3a e8 2b			ld a, (.dmark+1)  
2bdc 32 be fb			ld (debug_mark+1),a  
2bdf 3a e9 2b			ld a, (.dmark+2)  
2be2 32 bf fb			ld (debug_mark+2),a  
2be5 18 03			jr .pastdmark  
2be7 ..			.dmark: db "LS3"  
2bea f1			.pastdmark: pop af  
2beb			endm  
# End of macro DMARK
2beb					CALLMONITOR 
2beb cd ec 16			call break_point_state  
2bee				endm  
# End of macro CALLMONITOR
2bee				endif 
2bee					; should now be at the start of the machine code to setup the eval of the uword 
2bee					; now locate the ptr to the string defintion 
2bee			 
2bee					; skip ld hl, 
2bee					; then load the ptr 
2bee			 
2bee 23					inc hl 
2bef 5e					ld e, (hl) 
2bf0 23					inc hl 
2bf1 56					ld d, (hl) 
2bf2 eb					ex de, hl 
2bf3			 
2bf3			 
2bf3				if DEBUG_FORTH_WORDS 
2bf3					DMARK "LSt" 
2bf3 f5				push af  
2bf4 3a 08 2c			ld a, (.dmark)  
2bf7 32 bd fb			ld (debug_mark),a  
2bfa 3a 09 2c			ld a, (.dmark+1)  
2bfd 32 be fb			ld (debug_mark+1),a  
2c00 3a 0a 2c			ld a, (.dmark+2)  
2c03 32 bf fb			ld (debug_mark+2),a  
2c06 18 03			jr .pastdmark  
2c08 ..			.dmark: db "LSt"  
2c0b f1			.pastdmark: pop af  
2c0c			endm  
# End of macro DMARK
2c0c					CALLMONITOR 
2c0c cd ec 16			call break_point_state  
2c0f				endm  
# End of macro CALLMONITOR
2c0f				endif 
2c0f			 
2c0f			; cant push right now due to tokenised strings  
2c0f			 
2c0f			; get the destination of where to copy this definition to. 
2c0f			 
2c0f c5					push bc 
2c10 d1					pop de 
2c11			 
2c11 7e			.listl:         ld a,(hl) 
2c12 fe 00				cp 0 
2c14 28 09				jr z, .lreplsp     ; replace zero with space 
2c16 fe 7f				cp FORTH_END_BUFFER 
2c18 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2c1a				 
2c1a					; just copy this char as is then 
2c1a			 
2c1a 12					ld (de), a 
2c1b			 
2c1b 23			.listnxt:	inc hl 
2c1c 13					inc de 
2c1d 18 f2				jr .listl 
2c1f			 
2c1f 3e 20		.lreplsp:	ld a,' ' 
2c21 12					ld (de), a 
2c22 18 f7				jr .listnxt 
2c24			 
2c24			; close up uword def 
2c24			 
2c24			.listdone: 
2c24 3e 00				ld a, 0 
2c26 12					ld (de), a 
2c27			 
2c27			; now have def so clean up and push to stack 
2c27			 
2c27 21 a3 ef				ld hl, scratch 
2c2a				if DEBUG_FORTH_WORDS 
2c2a					DMARK "Ltp" 
2c2a f5				push af  
2c2b 3a 3f 2c			ld a, (.dmark)  
2c2e 32 bd fb			ld (debug_mark),a  
2c31 3a 40 2c			ld a, (.dmark+1)  
2c34 32 be fb			ld (debug_mark+1),a  
2c37 3a 41 2c			ld a, (.dmark+2)  
2c3a 32 bf fb			ld (debug_mark+2),a  
2c3d 18 03			jr .pastdmark  
2c3f ..			.dmark: db "Ltp"  
2c42 f1			.pastdmark: pop af  
2c43			endm  
# End of macro DMARK
2c43					CALLMONITOR 
2c43 cd ec 16			call break_point_state  
2c46				endm  
# End of macro CALLMONITOR
2c46				endif 
2c46			 
2c46 18 06			jr .listpush 
2c48			 
2c48			;.lnuword:	pop hl 
2c48			;		call forth_tok_next 
2c48			;		jp .ldouscan  
2c48			 
2c48			.lunotfound:		  
2c48			 
2c48			 
2c48					 
2c48					FORTH_DSP_POP 
2c48 cd 2b 1f			call macro_forth_dsp_pop 
2c4b				endm 
# End of macro FORTH_DSP_POP
2c4b 21 54 2c				ld hl, .luno 
2c4e						 
2c4e			 
2c4e			.listpush: 
2c4e cd ea 1c				call forth_push_str 
2c51			 
2c51			 
2c51			 
2c51					NEXTW 
2c51 c3 e5 1f			jp macro_next 
2c54				endm 
# End of macro NEXTW
2c54			 
2c54 .. 00		.luno:    db "Not found",0 
2c5e			 
2c5e			 
2c5e			 
2c5e			 
2c5e			 
2c5e			;		push hl   ; save pointer to start of uword def string 
2c5e			; 
2c5e			;; look for FORTH_EOL_LINE 
2c5e			;		ld a, FORTH_END_BUFFER 
2c5e			;		call strlent 
2c5e			; 
2c5e			;		inc hl		 ; space for coln def 
2c5e			;		inc hl 
2c5e			;		inc hl          ; space for terms 
2c5e			;		inc hl 
2c5e			; 
2c5e			;		ld a, 20   ; TODO get actual length 
2c5e			;		call addatohl    ; include a random amount of room for the uword name 
2c5e			; 
2c5e			;		 
2c5e			;	if DEBUG_FORTH_WORDS 
2c5e			;		DMARK "Lt1" 
2c5e			;		CALLMONITOR 
2c5e			;	endif 
2c5e			;		 
2c5e			; 
2c5e			;; malloc space for the string because we cant change it 
2c5e			; 
2c5e			;		call malloc 
2c5e			;	if DEBUG_FORTH_MALLOC_GUARD 
2c5e			;		push af 
2c5e			;		call ishlzero 
2c5e			;		pop af 
2c5e			;		 
2c5e			;		call z,malloc_error 
2c5e			;	endif 
2c5e			; 
2c5e			;	if DEBUG_FORTH_WORDS 
2c5e			;		DMARK "Lt2" 
2c5e			;		CALLMONITOR 
2c5e			;	endif 
2c5e			;		pop de 
2c5e			;		push hl    ; push the malloc to release later 
2c5e			;		push hl   ;  push back a copy for the later stack push 
2c5e			;		 
2c5e			;; copy the string swapping out the zero terms for spaces 
2c5e			; 
2c5e			;		; de has our source 
2c5e			;		; hl has our dest 
2c5e			; 
2c5e			;; add the coln def 
2c5e			; 
2c5e			;		ld a, ':' 
2c5e			;		ld (hl), a 
2c5e			;		inc hl 
2c5e			;		ld a, ' ' 
2c5e			;		ld (hl), a 
2c5e			;		inc hl 
2c5e			; 
2c5e			;; add the uname word 
2c5e			;		push de   ; save our string for now 
2c5e			;		ex de, hl 
2c5e			; 
2c5e			;		FORTH_DSP_VALUE 
2c5e			;		;v5 FORTH_DSP_VALUE 
2c5e			; 
2c5e			;		inc hl   ; skip type but we know by now this is OK 
2c5e			; 
2c5e			;.luword:	ld a,(hl) 
2c5e			;		cp 0 
2c5e			;		jr z, .luword2 
2c5e			;		ld (de), a 
2c5e			;		inc de 
2c5e			;		inc hl 
2c5e			;		jr .luword 
2c5e			; 
2c5e			;.luword2:	ld a, ' ' 
2c5e			;		ld (de), a 
2c5e			;;		inc hl 
2c5e			;;		inc de 
2c5e			;;		ld (de), a 
2c5e			;;		inc hl 
2c5e			;		inc de 
2c5e			; 
2c5e			;		ex de, hl 
2c5e			;		pop de 
2c5e			;		 
2c5e			;		 
2c5e			; 
2c5e			;; detoken that string and copy it 
2c5e			; 
2c5e			;	if DEBUG_FORTH_WORDS 
2c5e			;		DMARK "Lt2" 
2c5e			;		CALLMONITOR 
2c5e			;	endif 
2c5e			;.ldetok:	ld a, (de) 
2c5e			;		cp FORTH_END_BUFFER 
2c5e			;		jr z, .ldetokend 
2c5e			;		; swap out any zero term for space 
2c5e			;		cp 0 
2c5e			;		jr nz, .ldetoknext 
2c5e			;		ld a, ' ' 
2c5e			; 
2c5e			;	if DEBUG_FORTH_WORDS 
2c5e			;		DMARK "LtS" 
2c5e			;		CALLMONITOR 
2c5e			;	endif 
2c5e			;.ldetoknext:	ld (hl), a 
2c5e			;		inc de 
2c5e			;		inc hl 
2c5e			;		jr .ldetok 
2c5e			; 
2c5e			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2c5e			;		ld (hl), a  
2c5e			; 
2c5e			;; free that temp malloc 
2c5e			; 
2c5e			;		pop hl    
2c5e			; 
2c5e			;	if DEBUG_FORTH_WORDS 
2c5e			;		DMARK "Lt4" 
2c5e			;		CALLMONITOR 
2c5e			;	endif 
2c5e			;		call forth_apushstrhl 
2c5e			; 
2c5e			;		; get rid of temp malloc area 
2c5e			; 
2c5e			;		pop hl 
2c5e			;		call free 
2c5e			; 
2c5e			;		jr .ludone 
2c5e			; 
2c5e			;.lnuword:	pop hl 
2c5e			;		call forth_tok_next 
2c5e			;		jp .ldouscan  
2c5e			; 
2c5e			;.ludone:		 pop hl 
2c5e			; 
2c5e					NEXTW 
2c5e c3 e5 1f			jp macro_next 
2c61				endm 
# End of macro NEXTW
2c61			 
2c61			.FORGET: 
2c61				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2c61 5d				db WORD_SYS_CORE+73             
2c62 da 2c			dw .NOP            
2c64 07				db 6 + 1 
2c65 .. 00			db "FORGET",0              
2c6c				endm 
# End of macro CWHEAD
2c6c			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2c6c			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2c6c			; | |  
2c6c			; | | e.g. "MORE" forget 
2c6c					if DEBUG_FORTH_WORDS_KEY 
2c6c						DMARK "FRG" 
2c6c f5				push af  
2c6d 3a 81 2c			ld a, (.dmark)  
2c70 32 bd fb			ld (debug_mark),a  
2c73 3a 82 2c			ld a, (.dmark+1)  
2c76 32 be fb			ld (debug_mark+1),a  
2c79 3a 83 2c			ld a, (.dmark+2)  
2c7c 32 bf fb			ld (debug_mark+2),a  
2c7f 18 03			jr .pastdmark  
2c81 ..			.dmark: db "FRG"  
2c84 f1			.pastdmark: pop af  
2c85			endm  
# End of macro DMARK
2c85						CALLMONITOR 
2c85 cd ec 16			call break_point_state  
2c88				endm  
# End of macro CALLMONITOR
2c88					endif 
2c88			 
2c88				; find uword 
2c88			        ; update start of word with "_" 
2c88				; replace uword with deleted flag 
2c88			 
2c88			 
2c88			;	if DEBUG_FORTH_WORDS 
2c88			;		DMARK "FOG" 
2c88			;		CALLMONITOR 
2c88			;	endif 
2c88			 
2c88			 
2c88					; Get ptr to the word we need to look up 
2c88			 
2c88					FORTH_DSP_VALUEHL 
2c88 cd 73 1e			call macro_dsp_valuehl 
2c8b				endm 
# End of macro FORTH_DSP_VALUEHL
2c8b					;v5 FORTH_DSP_VALUE 
2c8b				; TODO type check 
2c8b			;		inc hl    ; Skip type check  
2c8b e5					push hl 
2c8c c1					pop bc 
2c8d			;		ex de, hl    ; put into DE 
2c8d			 
2c8d			 
2c8d 21 00 80				ld hl, baseram 
2c90					;ld hl, baseusermem 
2c90			 
2c90				; skip dict stub 
2c90			;	call forth_tok_next 
2c90 e5			push hl   ; sacreifical push 
2c91			 
2c91			.fldouscanm: 
2c91 e1				pop hl 
2c92			.fldouscan: 
2c92			;	if DEBUG_FORTH_WORDS 
2c92			;		DMARK "LSs" 
2c92			;		CALLMONITOR 
2c92			;	endif 
2c92				; skip dict stub 
2c92 cd 36 21				call forth_tok_next 
2c95			 
2c95			 
2c95			; while we have words to look for 
2c95			 
2c95 7e				ld a, (hl)      
2c96			;	if DEBUG_FORTH_WORDS 
2c96			;		DMARK "LSk" 
2c96			;		CALLMONITOR 
2c96			;	endif 
2c96 fe 00				cp WORD_SYS_END 
2c98 ca d4 2c				jp z, .flunotfound 
2c9b fe 01				cp WORD_SYS_UWORD 
2c9d c2 92 2c				jp nz, .fldouscan 
2ca0			 
2ca0			;	if DEBUG_FORTH_WORDS 
2ca0			;		DMARK "LSu" 
2ca0			;		CALLMONITOR 
2ca0			;	endif 
2ca0			 
2ca0					; found a uword but is it the one we want... 
2ca0			 
2ca0 c5					push bc     ; uword to find is on bc 
2ca1 d1					pop de 
2ca2			 
2ca2 e5					push hl  ; to save the ptr 
2ca3			 
2ca3					; skip opcode 
2ca3 23					inc hl  
2ca4					; skip next ptr 
2ca4 23					inc hl  
2ca5 23					inc hl 
2ca6					; skip len 
2ca6 23					inc hl 
2ca7			 
2ca7			;	if DEBUG_FORTH_WORDS 
2ca7			;		DMARK "LSc" 
2ca7			;		CALLMONITOR 
2ca7			;	endif 
2ca7 cd 9c 11				call strcmp 
2caa c2 91 2c				jp nz, .fldouscanm 
2cad			; 
2cad			; 
2cad			;; while we have words to look for 
2cad			; 
2cad			;.fdouscan:	ld a, (hl)      
2cad			;	if DEBUG_FORTH_WORDS 
2cad			;		DMARK "LSs" 
2cad			;		CALLMONITOR 
2cad			;	endif 
2cad			;		cp WORD_SYS_END 
2cad			;		jp z, .fudone 
2cad			;		cp WORD_SYS_UWORD 
2cad			;		jp nz, .fnuword 
2cad			; 
2cad			;	if DEBUG_FORTH_WORDS 
2cad			;		DMARK "FGu" 
2cad			;		CALLMONITOR 
2cad			;	endif 
2cad			; 
2cad			;		; found a uword but is it the one we want... 
2cad			; 
2cad			; 
2cad			;	        pop de   ; get back the dsp name 
2cad			;		push de 
2cad			; 
2cad			;		push hl  ; to save the ptr 
2cad			; 
2cad			;		; skip opcode 
2cad			;		inc hl  
2cad			;		; skip next ptr 
2cad			;		inc hl  
2cad			;		inc hl 
2cad			;		; skip len 
2cad			;		inc hl 
2cad			; 
2cad			;	if DEBUG_FORTH_WORDS 
2cad			;		DMARK "FGc" 
2cad			;		CALLMONITOR 
2cad			;	endif 
2cad			;		call strcmp 
2cad			;		jp nz, .fnuword 
2cad			 
2cad			 
2cad e1			pop hl 
2cae			 
2cae				 
2cae				if DEBUG_FORTH_WORDS 
2cae					DMARK "FGm" 
2cae f5				push af  
2caf 3a c3 2c			ld a, (.dmark)  
2cb2 32 bd fb			ld (debug_mark),a  
2cb5 3a c4 2c			ld a, (.dmark+1)  
2cb8 32 be fb			ld (debug_mark+1),a  
2cbb 3a c5 2c			ld a, (.dmark+2)  
2cbe 32 bf fb			ld (debug_mark+2),a  
2cc1 18 03			jr .pastdmark  
2cc3 ..			.dmark: db "FGm"  
2cc6 f1			.pastdmark: pop af  
2cc7			endm  
# End of macro DMARK
2cc7					CALLMONITOR 
2cc7 cd ec 16			call break_point_state  
2cca				endm  
# End of macro CALLMONITOR
2cca				endif 
2cca			 
2cca			 
2cca			 
2cca					; we have a uword so push its name to the stack 
2cca			 
2cca			;	   	push hl  ; save so we can move to next dict block 
2cca			;pop hl 
2cca			 
2cca					; update opcode to deleted 
2cca 3e 03				ld a, WORD_SYS_DELETED 
2ccc 77					ld (hl), a 
2ccd			 
2ccd 23					inc hl  
2cce					; skip next ptr 
2cce 23					inc hl  
2ccf 23					inc hl 
2cd0					; skip len 
2cd0 23					inc hl 
2cd1			 
2cd1					; TODO change parser to skip deleted words but for now mark it out 
2cd1 3e 5f				ld a, "_" 
2cd3 77					ld  (hl),a 
2cd4			 
2cd4			;		jr .fudone 
2cd4			; 
2cd4			;.fnuword:	pop hl 
2cd4			;		call forth_tok_next 
2cd4			;		jp .fdouscan  
2cd4			 
2cd4			.flunotfound:		  
2cd4			 
2cd4			 
2cd4					 
2cd4					FORTH_DSP_POP 
2cd4 cd 2b 1f			call macro_forth_dsp_pop 
2cd7				endm 
# End of macro FORTH_DSP_POP
2cd7			;		ld hl, .luno 
2cd7			;.fudone:		 pop hl 
2cd7					NEXTW 
2cd7 c3 e5 1f			jp macro_next 
2cda				endm 
# End of macro NEXTW
2cda			.NOP: 
2cda				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2cda 61				db WORD_SYS_CORE+77             
2cdb 01 2d			dw .COMO            
2cdd 04				db 3 + 1 
2cde .. 00			db "NOP",0              
2ce2				endm 
# End of macro CWHEAD
2ce2			; | NOP (  --  ) Do nothing | DONE 
2ce2					if DEBUG_FORTH_WORDS_KEY 
2ce2						DMARK "NOP" 
2ce2 f5				push af  
2ce3 3a f7 2c			ld a, (.dmark)  
2ce6 32 bd fb			ld (debug_mark),a  
2ce9 3a f8 2c			ld a, (.dmark+1)  
2cec 32 be fb			ld (debug_mark+1),a  
2cef 3a f9 2c			ld a, (.dmark+2)  
2cf2 32 bf fb			ld (debug_mark+2),a  
2cf5 18 03			jr .pastdmark  
2cf7 ..			.dmark: db "NOP"  
2cfa f1			.pastdmark: pop af  
2cfb			endm  
# End of macro DMARK
2cfb						CALLMONITOR 
2cfb cd ec 16			call break_point_state  
2cfe				endm  
# End of macro CALLMONITOR
2cfe					endif 
2cfe				       NEXTW 
2cfe c3 e5 1f			jp macro_next 
2d01				endm 
# End of macro NEXTW
2d01			.COMO: 
2d01				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2d01 6e				db WORD_SYS_CORE+90             
2d02 53 2d			dw .COMC            
2d04 02				db 1 + 1 
2d05 .. 00			db "(",0              
2d07				endm 
# End of macro CWHEAD
2d07			; | ( ( -- )  Start of comment | DONE 
2d07			 
2d07			 
2d07 2a a4 f2				ld hl, ( os_tok_ptr) 
2d0a 11 4e 2d			ld de, .closepar 
2d0d					 
2d0d					if DEBUG_FORTH_WORDS 
2d0d						DMARK ").." 
2d0d f5				push af  
2d0e 3a 22 2d			ld a, (.dmark)  
2d11 32 bd fb			ld (debug_mark),a  
2d14 3a 23 2d			ld a, (.dmark+1)  
2d17 32 be fb			ld (debug_mark+1),a  
2d1a 3a 24 2d			ld a, (.dmark+2)  
2d1d 32 bf fb			ld (debug_mark+2),a  
2d20 18 03			jr .pastdmark  
2d22 ..			.dmark: db ").."  
2d25 f1			.pastdmark: pop af  
2d26			endm  
# End of macro DMARK
2d26						CALLMONITOR 
2d26 cd ec 16			call break_point_state  
2d29				endm  
# End of macro CALLMONITOR
2d29					endif 
2d29 cd 00 21			call findnexttok  
2d2c			 
2d2c					if DEBUG_FORTH_WORDS 
2d2c						DMARK "IF5" 
2d2c f5				push af  
2d2d 3a 41 2d			ld a, (.dmark)  
2d30 32 bd fb			ld (debug_mark),a  
2d33 3a 42 2d			ld a, (.dmark+1)  
2d36 32 be fb			ld (debug_mark+1),a  
2d39 3a 43 2d			ld a, (.dmark+2)  
2d3c 32 bf fb			ld (debug_mark+2),a  
2d3f 18 03			jr .pastdmark  
2d41 ..			.dmark: db "IF5"  
2d44 f1			.pastdmark: pop af  
2d45			endm  
# End of macro DMARK
2d45						CALLMONITOR 
2d45 cd ec 16			call break_point_state  
2d48				endm  
# End of macro CALLMONITOR
2d48					endif 
2d48				; replace below with ) exec using tok_ptr 
2d48 22 a4 f2			ld (os_tok_ptr), hl 
2d4b c3 76 20			jp exec1 
2d4e			 
2d4e .. 00			.closepar:   db ")",0 
2d50			 
2d50				       NEXTW 
2d50 c3 e5 1f			jp macro_next 
2d53				endm 
# End of macro NEXTW
2d53			.COMC: 
2d53				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2d53 6f				db WORD_SYS_CORE+91             
2d54 5c 2d			dw .SCRATCH            
2d56 02				db 1 + 1 
2d57 .. 00			db ")",0              
2d59				endm 
# End of macro CWHEAD
2d59			; | ) ( -- )  End of comment |  DONE  
2d59				       NEXTW 
2d59 c3 e5 1f			jp macro_next 
2d5c				endm 
# End of macro NEXTW
2d5c			 
2d5c			.SCRATCH: 
2d5c				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2d5c 6f				db WORD_SYS_CORE+91             
2d5d 97 2d			dw .INC            
2d5f 08				db 7 + 1 
2d60 .. 00			db "SCRATCH",0              
2d68				endm 
# End of macro CWHEAD
2d68			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2d68			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2d68			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2d68			; | |  
2d68			; | | e.g.    : score $00 scratch ; 
2d68			; | |  
2d68			; | | $00 score ! 
2d68			; | | $01 score +! 
2d68			; | |  
2d68			; | | e.g.   : varword $0a scratch ;  
2d68			; | | 
2d68			; | | $8000 varword ! 
2d68					if DEBUG_FORTH_WORDS_KEY 
2d68						DMARK "SCR" 
2d68 f5				push af  
2d69 3a 7d 2d			ld a, (.dmark)  
2d6c 32 bd fb			ld (debug_mark),a  
2d6f 3a 7e 2d			ld a, (.dmark+1)  
2d72 32 be fb			ld (debug_mark+1),a  
2d75 3a 7f 2d			ld a, (.dmark+2)  
2d78 32 bf fb			ld (debug_mark+2),a  
2d7b 18 03			jr .pastdmark  
2d7d ..			.dmark: db "SCR"  
2d80 f1			.pastdmark: pop af  
2d81			endm  
# End of macro DMARK
2d81						CALLMONITOR 
2d81 cd ec 16			call break_point_state  
2d84				endm  
# End of macro CALLMONITOR
2d84					endif 
2d84			 
2d84					FORTH_DSP_VALUEHL 
2d84 cd 73 1e			call macro_dsp_valuehl 
2d87				endm 
# End of macro FORTH_DSP_VALUEHL
2d87				 
2d87					FORTH_DSP_POP 
2d87 cd 2b 1f			call macro_forth_dsp_pop 
2d8a				endm 
# End of macro FORTH_DSP_POP
2d8a			 
2d8a 7d					ld a, l 
2d8b 21 c8 f4				ld hl, os_var_array 
2d8e cd 06 0d				call addatohl 
2d91			 
2d91 cd 7c 1c				call forth_push_numhl 
2d94			 
2d94				       NEXTW 
2d94 c3 e5 1f			jp macro_next 
2d97				endm 
# End of macro NEXTW
2d97			 
2d97			.INC: 
2d97				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2d97 6f				db WORD_SYS_CORE+91             
2d98 eb 2d			dw .DEC            
2d9a 03				db 2 + 1 
2d9b .. 00			db "+!",0              
2d9e				endm 
# End of macro CWHEAD
2d9e			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2d9e					if DEBUG_FORTH_WORDS_KEY 
2d9e						DMARK "+s_" 
2d9e f5				push af  
2d9f 3a b3 2d			ld a, (.dmark)  
2da2 32 bd fb			ld (debug_mark),a  
2da5 3a b4 2d			ld a, (.dmark+1)  
2da8 32 be fb			ld (debug_mark+1),a  
2dab 3a b5 2d			ld a, (.dmark+2)  
2dae 32 bf fb			ld (debug_mark+2),a  
2db1 18 03			jr .pastdmark  
2db3 ..			.dmark: db "+s_"  
2db6 f1			.pastdmark: pop af  
2db7			endm  
# End of macro DMARK
2db7						CALLMONITOR 
2db7 cd ec 16			call break_point_state  
2dba				endm  
# End of macro CALLMONITOR
2dba					endif 
2dba			 
2dba					FORTH_DSP_VALUEHL 
2dba cd 73 1e			call macro_dsp_valuehl 
2dbd				endm 
# End of macro FORTH_DSP_VALUEHL
2dbd			 
2dbd e5					push hl   ; save address 
2dbe			 
2dbe					FORTH_DSP_POP 
2dbe cd 2b 1f			call macro_forth_dsp_pop 
2dc1				endm 
# End of macro FORTH_DSP_POP
2dc1			 
2dc1					FORTH_DSP_VALUEHL 
2dc1 cd 73 1e			call macro_dsp_valuehl 
2dc4				endm 
# End of macro FORTH_DSP_VALUEHL
2dc4			 
2dc4					FORTH_DSP_POP 
2dc4 cd 2b 1f			call macro_forth_dsp_pop 
2dc7				endm 
# End of macro FORTH_DSP_POP
2dc7			 
2dc7					; hl contains value to add to byte at a 
2dc7				 
2dc7 eb					ex de, hl 
2dc8			 
2dc8 e1					pop hl 
2dc9			 
2dc9					if DEBUG_FORTH_WORDS 
2dc9						DMARK "INC" 
2dc9 f5				push af  
2dca 3a de 2d			ld a, (.dmark)  
2dcd 32 bd fb			ld (debug_mark),a  
2dd0 3a df 2d			ld a, (.dmark+1)  
2dd3 32 be fb			ld (debug_mark+1),a  
2dd6 3a e0 2d			ld a, (.dmark+2)  
2dd9 32 bf fb			ld (debug_mark+2),a  
2ddc 18 03			jr .pastdmark  
2dde ..			.dmark: db "INC"  
2de1 f1			.pastdmark: pop af  
2de2			endm  
# End of macro DMARK
2de2						CALLMONITOR 
2de2 cd ec 16			call break_point_state  
2de5				endm  
# End of macro CALLMONITOR
2de5					endif 
2de5			 
2de5 7e					ld a,(hl) 
2de6 83					add e 
2de7 77					ld (hl),a 
2de8			 
2de8			 
2de8			 
2de8				       NEXTW 
2de8 c3 e5 1f			jp macro_next 
2deb				endm 
# End of macro NEXTW
2deb			 
2deb			.DEC: 
2deb				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2deb 6f				db WORD_SYS_CORE+91             
2dec 3c 2e			dw .INC2            
2dee 03				db 2 + 1 
2def .. 00			db "-!",0              
2df2				endm 
# End of macro CWHEAD
2df2			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2df2					if DEBUG_FORTH_WORDS_KEY 
2df2						DMARK "-s_" 
2df2 f5				push af  
2df3 3a 07 2e			ld a, (.dmark)  
2df6 32 bd fb			ld (debug_mark),a  
2df9 3a 08 2e			ld a, (.dmark+1)  
2dfc 32 be fb			ld (debug_mark+1),a  
2dff 3a 09 2e			ld a, (.dmark+2)  
2e02 32 bf fb			ld (debug_mark+2),a  
2e05 18 03			jr .pastdmark  
2e07 ..			.dmark: db "-s_"  
2e0a f1			.pastdmark: pop af  
2e0b			endm  
# End of macro DMARK
2e0b						CALLMONITOR 
2e0b cd ec 16			call break_point_state  
2e0e				endm  
# End of macro CALLMONITOR
2e0e					endif 
2e0e			 
2e0e					FORTH_DSP_VALUEHL 
2e0e cd 73 1e			call macro_dsp_valuehl 
2e11				endm 
# End of macro FORTH_DSP_VALUEHL
2e11			 
2e11 e5					push hl   ; save address 
2e12			 
2e12					FORTH_DSP_POP 
2e12 cd 2b 1f			call macro_forth_dsp_pop 
2e15				endm 
# End of macro FORTH_DSP_POP
2e15			 
2e15					FORTH_DSP_VALUEHL 
2e15 cd 73 1e			call macro_dsp_valuehl 
2e18				endm 
# End of macro FORTH_DSP_VALUEHL
2e18			 
2e18					; hl contains value to add to byte at a 
2e18				 
2e18 eb					ex de, hl 
2e19			 
2e19 e1					pop hl 
2e1a			 
2e1a					if DEBUG_FORTH_WORDS 
2e1a						DMARK "DEC" 
2e1a f5				push af  
2e1b 3a 2f 2e			ld a, (.dmark)  
2e1e 32 bd fb			ld (debug_mark),a  
2e21 3a 30 2e			ld a, (.dmark+1)  
2e24 32 be fb			ld (debug_mark+1),a  
2e27 3a 31 2e			ld a, (.dmark+2)  
2e2a 32 bf fb			ld (debug_mark+2),a  
2e2d 18 03			jr .pastdmark  
2e2f ..			.dmark: db "DEC"  
2e32 f1			.pastdmark: pop af  
2e33			endm  
# End of macro DMARK
2e33						CALLMONITOR 
2e33 cd ec 16			call break_point_state  
2e36				endm  
# End of macro CALLMONITOR
2e36					endif 
2e36			 
2e36 7e					ld a,(hl) 
2e37 93					sub e 
2e38 77					ld (hl),a 
2e39			 
2e39			 
2e39			 
2e39				       NEXTW 
2e39 c3 e5 1f			jp macro_next 
2e3c				endm 
# End of macro NEXTW
2e3c			 
2e3c			.INC2: 
2e3c				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2e3c 6f				db WORD_SYS_CORE+91             
2e3d e6 2e			dw .DEC2            
2e3f 04				db 3 + 1 
2e40 .. 00			db "+2!",0              
2e44				endm 
# End of macro CWHEAD
2e44			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2e44			 
2e44					if DEBUG_FORTH_WORDS_KEY 
2e44						DMARK "+2s" 
2e44 f5				push af  
2e45 3a 59 2e			ld a, (.dmark)  
2e48 32 bd fb			ld (debug_mark),a  
2e4b 3a 5a 2e			ld a, (.dmark+1)  
2e4e 32 be fb			ld (debug_mark+1),a  
2e51 3a 5b 2e			ld a, (.dmark+2)  
2e54 32 bf fb			ld (debug_mark+2),a  
2e57 18 03			jr .pastdmark  
2e59 ..			.dmark: db "+2s"  
2e5c f1			.pastdmark: pop af  
2e5d			endm  
# End of macro DMARK
2e5d						CALLMONITOR 
2e5d cd ec 16			call break_point_state  
2e60				endm  
# End of macro CALLMONITOR
2e60					endif 
2e60			 
2e60					; Address 
2e60			 
2e60					FORTH_DSP_VALUEHL 
2e60 cd 73 1e			call macro_dsp_valuehl 
2e63				endm 
# End of macro FORTH_DSP_VALUEHL
2e63			 
2e63 e5					push hl    ; save address 
2e64			 
2e64					; load content into de 
2e64			 
2e64 5e					ld e,(hl) 
2e65 23					inc hl 
2e66 56					ld d, (hl) 
2e67			 
2e67					if DEBUG_FORTH_WORDS 
2e67						DMARK "+2a" 
2e67 f5				push af  
2e68 3a 7c 2e			ld a, (.dmark)  
2e6b 32 bd fb			ld (debug_mark),a  
2e6e 3a 7d 2e			ld a, (.dmark+1)  
2e71 32 be fb			ld (debug_mark+1),a  
2e74 3a 7e 2e			ld a, (.dmark+2)  
2e77 32 bf fb			ld (debug_mark+2),a  
2e7a 18 03			jr .pastdmark  
2e7c ..			.dmark: db "+2a"  
2e7f f1			.pastdmark: pop af  
2e80			endm  
# End of macro DMARK
2e80						CALLMONITOR 
2e80 cd ec 16			call break_point_state  
2e83				endm  
# End of macro CALLMONITOR
2e83					endif 
2e83			 
2e83					FORTH_DSP_POP 
2e83 cd 2b 1f			call macro_forth_dsp_pop 
2e86				endm 
# End of macro FORTH_DSP_POP
2e86			 
2e86					; Get value to add 
2e86			 
2e86					FORTH_DSP_VALUE 
2e86 cd 5c 1e			call macro_forth_dsp_value 
2e89				endm 
# End of macro FORTH_DSP_VALUE
2e89			 
2e89					if DEBUG_FORTH_WORDS 
2e89						DMARK "+2v" 
2e89 f5				push af  
2e8a 3a 9e 2e			ld a, (.dmark)  
2e8d 32 bd fb			ld (debug_mark),a  
2e90 3a 9f 2e			ld a, (.dmark+1)  
2e93 32 be fb			ld (debug_mark+1),a  
2e96 3a a0 2e			ld a, (.dmark+2)  
2e99 32 bf fb			ld (debug_mark+2),a  
2e9c 18 03			jr .pastdmark  
2e9e ..			.dmark: db "+2v"  
2ea1 f1			.pastdmark: pop af  
2ea2			endm  
# End of macro DMARK
2ea2						CALLMONITOR 
2ea2 cd ec 16			call break_point_state  
2ea5				endm  
# End of macro CALLMONITOR
2ea5					endif 
2ea5			 
2ea5 19					add hl, de 
2ea6			 
2ea6					if DEBUG_FORTH_WORDS 
2ea6						DMARK "+2+" 
2ea6 f5				push af  
2ea7 3a bb 2e			ld a, (.dmark)  
2eaa 32 bd fb			ld (debug_mark),a  
2ead 3a bc 2e			ld a, (.dmark+1)  
2eb0 32 be fb			ld (debug_mark+1),a  
2eb3 3a bd 2e			ld a, (.dmark+2)  
2eb6 32 bf fb			ld (debug_mark+2),a  
2eb9 18 03			jr .pastdmark  
2ebb ..			.dmark: db "+2+"  
2ebe f1			.pastdmark: pop af  
2ebf			endm  
# End of macro DMARK
2ebf						CALLMONITOR 
2ebf cd ec 16			call break_point_state  
2ec2				endm  
# End of macro CALLMONITOR
2ec2					endif 
2ec2			 
2ec2					; move result to de 
2ec2			 
2ec2 eb					ex de, hl 
2ec3			 
2ec3					; Address 
2ec3			 
2ec3 e1					pop hl 
2ec4			 
2ec4					; save it back 
2ec4			 
2ec4 73					ld (hl), e 
2ec5 23					inc hl 
2ec6 72					ld (hl), d 
2ec7			 
2ec7					if DEBUG_FORTH_WORDS 
2ec7						DMARK "+2e" 
2ec7 f5				push af  
2ec8 3a dc 2e			ld a, (.dmark)  
2ecb 32 bd fb			ld (debug_mark),a  
2ece 3a dd 2e			ld a, (.dmark+1)  
2ed1 32 be fb			ld (debug_mark+1),a  
2ed4 3a de 2e			ld a, (.dmark+2)  
2ed7 32 bf fb			ld (debug_mark+2),a  
2eda 18 03			jr .pastdmark  
2edc ..			.dmark: db "+2e"  
2edf f1			.pastdmark: pop af  
2ee0			endm  
# End of macro DMARK
2ee0						CALLMONITOR 
2ee0 cd ec 16			call break_point_state  
2ee3				endm  
# End of macro CALLMONITOR
2ee3					endif 
2ee3			 
2ee3			 
2ee3			 
2ee3			 
2ee3			 
2ee3				       NEXTW 
2ee3 c3 e5 1f			jp macro_next 
2ee6				endm 
# End of macro NEXTW
2ee6			 
2ee6			.DEC2: 
2ee6				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2ee6 6f				db WORD_SYS_CORE+91             
2ee7 92 2f			dw .GET2            
2ee9 04				db 3 + 1 
2eea .. 00			db "-2!",0              
2eee				endm 
# End of macro CWHEAD
2eee			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2eee			 
2eee			 
2eee					if DEBUG_FORTH_WORDS_KEY 
2eee						DMARK "-2s" 
2eee f5				push af  
2eef 3a 03 2f			ld a, (.dmark)  
2ef2 32 bd fb			ld (debug_mark),a  
2ef5 3a 04 2f			ld a, (.dmark+1)  
2ef8 32 be fb			ld (debug_mark+1),a  
2efb 3a 05 2f			ld a, (.dmark+2)  
2efe 32 bf fb			ld (debug_mark+2),a  
2f01 18 03			jr .pastdmark  
2f03 ..			.dmark: db "-2s"  
2f06 f1			.pastdmark: pop af  
2f07			endm  
# End of macro DMARK
2f07						CALLMONITOR 
2f07 cd ec 16			call break_point_state  
2f0a				endm  
# End of macro CALLMONITOR
2f0a					endif 
2f0a			 
2f0a					; Address 
2f0a			 
2f0a					FORTH_DSP_VALUEHL 
2f0a cd 73 1e			call macro_dsp_valuehl 
2f0d				endm 
# End of macro FORTH_DSP_VALUEHL
2f0d			 
2f0d e5					push hl    ; save address 
2f0e			 
2f0e					; load content into de 
2f0e			 
2f0e 5e					ld e,(hl) 
2f0f 23					inc hl 
2f10 56					ld d, (hl) 
2f11			 
2f11					if DEBUG_FORTH_WORDS 
2f11						DMARK "-2a" 
2f11 f5				push af  
2f12 3a 26 2f			ld a, (.dmark)  
2f15 32 bd fb			ld (debug_mark),a  
2f18 3a 27 2f			ld a, (.dmark+1)  
2f1b 32 be fb			ld (debug_mark+1),a  
2f1e 3a 28 2f			ld a, (.dmark+2)  
2f21 32 bf fb			ld (debug_mark+2),a  
2f24 18 03			jr .pastdmark  
2f26 ..			.dmark: db "-2a"  
2f29 f1			.pastdmark: pop af  
2f2a			endm  
# End of macro DMARK
2f2a						CALLMONITOR 
2f2a cd ec 16			call break_point_state  
2f2d				endm  
# End of macro CALLMONITOR
2f2d					endif 
2f2d			 
2f2d					FORTH_DSP_POP 
2f2d cd 2b 1f			call macro_forth_dsp_pop 
2f30				endm 
# End of macro FORTH_DSP_POP
2f30			 
2f30					; Get value to remove 
2f30			 
2f30					FORTH_DSP_VALUE 
2f30 cd 5c 1e			call macro_forth_dsp_value 
2f33				endm 
# End of macro FORTH_DSP_VALUE
2f33			 
2f33					if DEBUG_FORTH_WORDS 
2f33						DMARK "-2v" 
2f33 f5				push af  
2f34 3a 48 2f			ld a, (.dmark)  
2f37 32 bd fb			ld (debug_mark),a  
2f3a 3a 49 2f			ld a, (.dmark+1)  
2f3d 32 be fb			ld (debug_mark+1),a  
2f40 3a 4a 2f			ld a, (.dmark+2)  
2f43 32 bf fb			ld (debug_mark+2),a  
2f46 18 03			jr .pastdmark  
2f48 ..			.dmark: db "-2v"  
2f4b f1			.pastdmark: pop af  
2f4c			endm  
# End of macro DMARK
2f4c						CALLMONITOR 
2f4c cd ec 16			call break_point_state  
2f4f				endm  
# End of macro CALLMONITOR
2f4f					endif 
2f4f			 
2f4f eb					ex de, hl 
2f50 ed 52				sbc hl, de 
2f52			 
2f52					if DEBUG_FORTH_WORDS 
2f52						DMARK "-2d" 
2f52 f5				push af  
2f53 3a 67 2f			ld a, (.dmark)  
2f56 32 bd fb			ld (debug_mark),a  
2f59 3a 68 2f			ld a, (.dmark+1)  
2f5c 32 be fb			ld (debug_mark+1),a  
2f5f 3a 69 2f			ld a, (.dmark+2)  
2f62 32 bf fb			ld (debug_mark+2),a  
2f65 18 03			jr .pastdmark  
2f67 ..			.dmark: db "-2d"  
2f6a f1			.pastdmark: pop af  
2f6b			endm  
# End of macro DMARK
2f6b						CALLMONITOR 
2f6b cd ec 16			call break_point_state  
2f6e				endm  
# End of macro CALLMONITOR
2f6e					endif 
2f6e			 
2f6e					; move result to de 
2f6e			 
2f6e eb					ex de, hl 
2f6f			 
2f6f					; Address 
2f6f			 
2f6f e1					pop hl 
2f70			 
2f70					; save it back 
2f70			 
2f70 73					ld (hl), e 
2f71 23					inc hl 
2f72 72					ld (hl), d 
2f73			 
2f73					if DEBUG_FORTH_WORDS 
2f73						DMARK "-2e" 
2f73 f5				push af  
2f74 3a 88 2f			ld a, (.dmark)  
2f77 32 bd fb			ld (debug_mark),a  
2f7a 3a 89 2f			ld a, (.dmark+1)  
2f7d 32 be fb			ld (debug_mark+1),a  
2f80 3a 8a 2f			ld a, (.dmark+2)  
2f83 32 bf fb			ld (debug_mark+2),a  
2f86 18 03			jr .pastdmark  
2f88 ..			.dmark: db "-2e"  
2f8b f1			.pastdmark: pop af  
2f8c			endm  
# End of macro DMARK
2f8c						CALLMONITOR 
2f8c cd ec 16			call break_point_state  
2f8f				endm  
# End of macro CALLMONITOR
2f8f					endif 
2f8f			 
2f8f			 
2f8f			 
2f8f			 
2f8f			 
2f8f				       NEXTW 
2f8f c3 e5 1f			jp macro_next 
2f92				endm 
# End of macro NEXTW
2f92			.GET2: 
2f92				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2f92 6f				db WORD_SYS_CORE+91             
2f93 c2 2f			dw .BANG2            
2f95 03				db 2 + 1 
2f96 .. 00			db "2@",0              
2f99				endm 
# End of macro CWHEAD
2f99			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2f99					if DEBUG_FORTH_WORDS_KEY 
2f99						DMARK "2A_" 
2f99 f5				push af  
2f9a 3a ae 2f			ld a, (.dmark)  
2f9d 32 bd fb			ld (debug_mark),a  
2fa0 3a af 2f			ld a, (.dmark+1)  
2fa3 32 be fb			ld (debug_mark+1),a  
2fa6 3a b0 2f			ld a, (.dmark+2)  
2fa9 32 bf fb			ld (debug_mark+2),a  
2fac 18 03			jr .pastdmark  
2fae ..			.dmark: db "2A_"  
2fb1 f1			.pastdmark: pop af  
2fb2			endm  
# End of macro DMARK
2fb2						CALLMONITOR 
2fb2 cd ec 16			call break_point_state  
2fb5				endm  
# End of macro CALLMONITOR
2fb5					endif 
2fb5			 
2fb5					FORTH_DSP_VALUEHL 
2fb5 cd 73 1e			call macro_dsp_valuehl 
2fb8				endm 
# End of macro FORTH_DSP_VALUEHL
2fb8			 
2fb8 5e					ld e, (hl) 
2fb9 23					inc hl 
2fba 56					ld d, (hl) 
2fbb			 
2fbb eb					ex de, hl 
2fbc			 
2fbc cd 7c 1c				call forth_push_numhl 
2fbf			 
2fbf				       NEXTW 
2fbf c3 e5 1f			jp macro_next 
2fc2				endm 
# End of macro NEXTW
2fc2			.BANG2: 
2fc2				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2fc2 6f				db WORD_SYS_CORE+91             
2fc3 fa 2f			dw .CONFIG            
2fc5 03				db 2 + 1 
2fc6 .. 00			db "2!",0              
2fc9				endm 
# End of macro CWHEAD
2fc9			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2fc9					if DEBUG_FORTH_WORDS_KEY 
2fc9						DMARK "2S_" 
2fc9 f5				push af  
2fca 3a de 2f			ld a, (.dmark)  
2fcd 32 bd fb			ld (debug_mark),a  
2fd0 3a df 2f			ld a, (.dmark+1)  
2fd3 32 be fb			ld (debug_mark+1),a  
2fd6 3a e0 2f			ld a, (.dmark+2)  
2fd9 32 bf fb			ld (debug_mark+2),a  
2fdc 18 03			jr .pastdmark  
2fde ..			.dmark: db "2S_"  
2fe1 f1			.pastdmark: pop af  
2fe2			endm  
# End of macro DMARK
2fe2						CALLMONITOR 
2fe2 cd ec 16			call break_point_state  
2fe5				endm  
# End of macro CALLMONITOR
2fe5					endif 
2fe5			 
2fe5					FORTH_DSP_VALUEHL 
2fe5 cd 73 1e			call macro_dsp_valuehl 
2fe8				endm 
# End of macro FORTH_DSP_VALUEHL
2fe8			 
2fe8 e5					push hl   ; save address 
2fe9			 
2fe9			 
2fe9					FORTH_DSP_POP 
2fe9 cd 2b 1f			call macro_forth_dsp_pop 
2fec				endm 
# End of macro FORTH_DSP_POP
2fec			 
2fec					 
2fec					FORTH_DSP_VALUEHL 
2fec cd 73 1e			call macro_dsp_valuehl 
2fef				endm 
# End of macro FORTH_DSP_VALUEHL
2fef			 
2fef					FORTH_DSP_POP 
2fef cd 2b 1f			call macro_forth_dsp_pop 
2ff2				endm 
# End of macro FORTH_DSP_POP
2ff2			 
2ff2 eb					ex de, hl    ; value now in de 
2ff3			 
2ff3 e1					pop hl 
2ff4			 
2ff4 73					ld (hl), e 
2ff5			 
2ff5 23					inc hl 
2ff6			 
2ff6 72					ld (hl), d 
2ff7			 
2ff7			 
2ff7				       NEXTW 
2ff7 c3 e5 1f			jp macro_next 
2ffa				endm 
# End of macro NEXTW
2ffa			.CONFIG: 
2ffa				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
2ffa 6f				db WORD_SYS_CORE+91             
2ffb 0b 30			dw .ENDCORE            
2ffd 07				db 6 + 1 
2ffe .. 00			db "CONFIG",0              
3005				endm 
# End of macro CWHEAD
3005			; | CONFIG ( -- )  Access the system configuration menu | TO DO 
3005			 
3005 cd 66 13				call config 
3008					NEXTW 
3008 c3 e5 1f			jp macro_next 
300b				endm 
# End of macro NEXTW
300b			.ENDCORE: 
300b			 
300b			; eof 
300b			 
300b			 
# End of file forth_words_core.asm
300b			include "forth_words_flow.asm" 
300b			 
300b			; | ## Program Flow Words 
300b			 
300b			.IF: 
300b				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
300b 1e				db WORD_SYS_CORE+10             
300c 00 31			dw .THEN            
300e 03				db 2 + 1 
300f .. 00			db "IF",0              
3012				endm 
# End of macro CWHEAD
3012			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
3012			; 
3012					if DEBUG_FORTH_WORDS_KEY 
3012						DMARK "IF." 
3012 f5				push af  
3013 3a 27 30			ld a, (.dmark)  
3016 32 bd fb			ld (debug_mark),a  
3019 3a 28 30			ld a, (.dmark+1)  
301c 32 be fb			ld (debug_mark+1),a  
301f 3a 29 30			ld a, (.dmark+2)  
3022 32 bf fb			ld (debug_mark+2),a  
3025 18 03			jr .pastdmark  
3027 ..			.dmark: db "IF."  
302a f1			.pastdmark: pop af  
302b			endm  
# End of macro DMARK
302b						CALLMONITOR 
302b cd ec 16			call break_point_state  
302e				endm  
# End of macro CALLMONITOR
302e					endif 
302e			; eval TOS 
302e			 
302e				FORTH_DSP_VALUEHL 
302e cd 73 1e			call macro_dsp_valuehl 
3031				endm 
# End of macro FORTH_DSP_VALUEHL
3031			 
3031			;	push hl 
3031				FORTH_DSP_POP 
3031 cd 2b 1f			call macro_forth_dsp_pop 
3034				endm 
# End of macro FORTH_DSP_POP
3034			;	pop hl 
3034			 
3034					if DEBUG_FORTH_WORDS 
3034						DMARK "IF1" 
3034 f5				push af  
3035 3a 49 30			ld a, (.dmark)  
3038 32 bd fb			ld (debug_mark),a  
303b 3a 4a 30			ld a, (.dmark+1)  
303e 32 be fb			ld (debug_mark+1),a  
3041 3a 4b 30			ld a, (.dmark+2)  
3044 32 bf fb			ld (debug_mark+2),a  
3047 18 03			jr .pastdmark  
3049 ..			.dmark: db "IF1"  
304c f1			.pastdmark: pop af  
304d			endm  
# End of macro DMARK
304d						CALLMONITOR 
304d cd ec 16			call break_point_state  
3050				endm  
# End of macro CALLMONITOR
3050					endif 
3050 b7				or a        ; clear carry flag 
3051 11 00 00			ld de, 0 
3054 eb				ex de,hl 
3055 ed 52			sbc hl, de 
3057 c2 e1 30			jp nz, .iftrue 
305a			 
305a					if DEBUG_FORTH_WORDS 
305a						DMARK "IF2" 
305a f5				push af  
305b 3a 6f 30			ld a, (.dmark)  
305e 32 bd fb			ld (debug_mark),a  
3061 3a 70 30			ld a, (.dmark+1)  
3064 32 be fb			ld (debug_mark+1),a  
3067 3a 71 30			ld a, (.dmark+2)  
306a 32 bf fb			ld (debug_mark+2),a  
306d 18 03			jr .pastdmark  
306f ..			.dmark: db "IF2"  
3072 f1			.pastdmark: pop af  
3073			endm  
# End of macro DMARK
3073						CALLMONITOR 
3073 cd ec 16			call break_point_state  
3076				endm  
# End of macro CALLMONITOR
3076					endif 
3076			 
3076			; if not true then skip to THEN 
3076			 
3076				; TODO get tok_ptr 
3076				; TODO consume toks until we get to THEN 
3076			 
3076 2a a4 f2			ld hl, (os_tok_ptr) 
3079					if DEBUG_FORTH_WORDS 
3079						DMARK "IF3" 
3079 f5				push af  
307a 3a 8e 30			ld a, (.dmark)  
307d 32 bd fb			ld (debug_mark),a  
3080 3a 8f 30			ld a, (.dmark+1)  
3083 32 be fb			ld (debug_mark+1),a  
3086 3a 90 30			ld a, (.dmark+2)  
3089 32 bf fb			ld (debug_mark+2),a  
308c 18 03			jr .pastdmark  
308e ..			.dmark: db "IF3"  
3091 f1			.pastdmark: pop af  
3092			endm  
# End of macro DMARK
3092						CALLMONITOR 
3092 cd ec 16			call break_point_state  
3095				endm  
# End of macro CALLMONITOR
3095						 
3095					endif 
3095 11 dc 30			ld de, .ifthen 
3098					if DEBUG_FORTH_WORDS 
3098						DMARK "IF4" 
3098 f5				push af  
3099 3a ad 30			ld a, (.dmark)  
309c 32 bd fb			ld (debug_mark),a  
309f 3a ae 30			ld a, (.dmark+1)  
30a2 32 be fb			ld (debug_mark+1),a  
30a5 3a af 30			ld a, (.dmark+2)  
30a8 32 bf fb			ld (debug_mark+2),a  
30ab 18 03			jr .pastdmark  
30ad ..			.dmark: db "IF4"  
30b0 f1			.pastdmark: pop af  
30b1			endm  
# End of macro DMARK
30b1						CALLMONITOR 
30b1 cd ec 16			call break_point_state  
30b4				endm  
# End of macro CALLMONITOR
30b4					endif 
30b4 cd 00 21			call findnexttok  
30b7			 
30b7					if DEBUG_FORTH_WORDS 
30b7						DMARK "IF5" 
30b7 f5				push af  
30b8 3a cc 30			ld a, (.dmark)  
30bb 32 bd fb			ld (debug_mark),a  
30be 3a cd 30			ld a, (.dmark+1)  
30c1 32 be fb			ld (debug_mark+1),a  
30c4 3a ce 30			ld a, (.dmark+2)  
30c7 32 bf fb			ld (debug_mark+2),a  
30ca 18 03			jr .pastdmark  
30cc ..			.dmark: db "IF5"  
30cf f1			.pastdmark: pop af  
30d0			endm  
# End of macro DMARK
30d0						CALLMONITOR 
30d0 cd ec 16			call break_point_state  
30d3				endm  
# End of macro CALLMONITOR
30d3					endif 
30d3				; TODO replace below with ; exec using tok_ptr 
30d3 22 a4 f2			ld (os_tok_ptr), hl 
30d6 c3 76 20			jp exec1 
30d9				NEXTW 
30d9 c3 e5 1f			jp macro_next 
30dc				endm 
# End of macro NEXTW
30dc			 
30dc .. 00		.ifthen:  db "THEN",0 
30e1			 
30e1			.iftrue:		 
30e1				; Exec next words normally 
30e1			 
30e1				; if true then exec following IF as normal 
30e1					if DEBUG_FORTH_WORDS 
30e1						DMARK "IFT" 
30e1 f5				push af  
30e2 3a f6 30			ld a, (.dmark)  
30e5 32 bd fb			ld (debug_mark),a  
30e8 3a f7 30			ld a, (.dmark+1)  
30eb 32 be fb			ld (debug_mark+1),a  
30ee 3a f8 30			ld a, (.dmark+2)  
30f1 32 bf fb			ld (debug_mark+2),a  
30f4 18 03			jr .pastdmark  
30f6 ..			.dmark: db "IFT"  
30f9 f1			.pastdmark: pop af  
30fa			endm  
# End of macro DMARK
30fa						CALLMONITOR 
30fa cd ec 16			call break_point_state  
30fd				endm  
# End of macro CALLMONITOR
30fd					endif 
30fd			 
30fd					NEXTW 
30fd c3 e5 1f			jp macro_next 
3100				endm 
# End of macro NEXTW
3100			.THEN: 
3100				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
3100 1f				db WORD_SYS_CORE+11             
3101 28 31			dw .ELSE            
3103 05				db 4 + 1 
3104 .. 00			db "THEN",0              
3109				endm 
# End of macro CWHEAD
3109			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
3109					if DEBUG_FORTH_WORDS_KEY 
3109						DMARK "THN" 
3109 f5				push af  
310a 3a 1e 31			ld a, (.dmark)  
310d 32 bd fb			ld (debug_mark),a  
3110 3a 1f 31			ld a, (.dmark+1)  
3113 32 be fb			ld (debug_mark+1),a  
3116 3a 20 31			ld a, (.dmark+2)  
3119 32 bf fb			ld (debug_mark+2),a  
311c 18 03			jr .pastdmark  
311e ..			.dmark: db "THN"  
3121 f1			.pastdmark: pop af  
3122			endm  
# End of macro DMARK
3122						CALLMONITOR 
3122 cd ec 16			call break_point_state  
3125				endm  
# End of macro CALLMONITOR
3125					endif 
3125					NEXTW 
3125 c3 e5 1f			jp macro_next 
3128				endm 
# End of macro NEXTW
3128			.ELSE: 
3128				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
3128 20				db WORD_SYS_CORE+12             
3129 50 31			dw .DO            
312b 03				db 2 + 1 
312c .. 00			db "ELSE",0              
3131				endm 
# End of macro CWHEAD
3131			; | ELSE ( -- ) Not supported - does nothing | TODO 
3131			 
3131					if DEBUG_FORTH_WORDS_KEY 
3131						DMARK "ELS" 
3131 f5				push af  
3132 3a 46 31			ld a, (.dmark)  
3135 32 bd fb			ld (debug_mark),a  
3138 3a 47 31			ld a, (.dmark+1)  
313b 32 be fb			ld (debug_mark+1),a  
313e 3a 48 31			ld a, (.dmark+2)  
3141 32 bf fb			ld (debug_mark+2),a  
3144 18 03			jr .pastdmark  
3146 ..			.dmark: db "ELS"  
3149 f1			.pastdmark: pop af  
314a			endm  
# End of macro DMARK
314a						CALLMONITOR 
314a cd ec 16			call break_point_state  
314d				endm  
# End of macro CALLMONITOR
314d					endif 
314d			 
314d			 
314d					NEXTW 
314d c3 e5 1f			jp macro_next 
3150				endm 
# End of macro NEXTW
3150			.DO: 
3150				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
3150 21				db WORD_SYS_CORE+13             
3151 77 32			dw .LOOP            
3153 03				db 2 + 1 
3154 .. 00			db "DO",0              
3157				endm 
# End of macro CWHEAD
3157			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
3157			 
3157					if DEBUG_FORTH_WORDS_KEY 
3157						DMARK "DO." 
3157 f5				push af  
3158 3a 6c 31			ld a, (.dmark)  
315b 32 bd fb			ld (debug_mark),a  
315e 3a 6d 31			ld a, (.dmark+1)  
3161 32 be fb			ld (debug_mark+1),a  
3164 3a 6e 31			ld a, (.dmark+2)  
3167 32 bf fb			ld (debug_mark+2),a  
316a 18 03			jr .pastdmark  
316c ..			.dmark: db "DO."  
316f f1			.pastdmark: pop af  
3170			endm  
# End of macro DMARK
3170						CALLMONITOR 
3170 cd ec 16			call break_point_state  
3173				endm  
# End of macro CALLMONITOR
3173					endif 
3173			;  push pc to rsp stack past the DO 
3173			 
3173 2a a4 f2				ld hl, (os_tok_ptr) 
3176 23					inc hl   ; D 
3177 23					inc hl  ; O 
3178 23					inc hl   ; null 
3179					if DEBUG_FORTH_WORDS 
3179						DMARK "DO2" 
3179 f5				push af  
317a 3a 8e 31			ld a, (.dmark)  
317d 32 bd fb			ld (debug_mark),a  
3180 3a 8f 31			ld a, (.dmark+1)  
3183 32 be fb			ld (debug_mark+1),a  
3186 3a 90 31			ld a, (.dmark+2)  
3189 32 bf fb			ld (debug_mark+2),a  
318c 18 03			jr .pastdmark  
318e ..			.dmark: db "DO2"  
3191 f1			.pastdmark: pop af  
3192			endm  
# End of macro DMARK
3192						CALLMONITOR 
3192 cd ec 16			call break_point_state  
3195				endm  
# End of macro CALLMONITOR
3195					endif 
3195					FORTH_RSP_NEXT 
3195 cd 23 1c			call macro_forth_rsp_next 
3198				endm 
# End of macro FORTH_RSP_NEXT
3198					if DEBUG_FORTH_WORDS 
3198						DMARK "DO3" 
3198 f5				push af  
3199 3a ad 31			ld a, (.dmark)  
319c 32 bd fb			ld (debug_mark),a  
319f 3a ae 31			ld a, (.dmark+1)  
31a2 32 be fb			ld (debug_mark+1),a  
31a5 3a af 31			ld a, (.dmark+2)  
31a8 32 bf fb			ld (debug_mark+2),a  
31ab 18 03			jr .pastdmark  
31ad ..			.dmark: db "DO3"  
31b0 f1			.pastdmark: pop af  
31b1			endm  
# End of macro DMARK
31b1						CALLMONITOR 
31b1 cd ec 16			call break_point_state  
31b4				endm  
# End of macro CALLMONITOR
31b4					endif 
31b4			 
31b4					;if DEBUG_FORTH_WORDS 
31b4				;		push hl 
31b4			;		endif  
31b4			 
31b4			; get counters from data stack 
31b4			 
31b4			 
31b4					FORTH_DSP_VALUEHL 
31b4 cd 73 1e			call macro_dsp_valuehl 
31b7				endm 
# End of macro FORTH_DSP_VALUEHL
31b7 e5					push hl		 ; hl now has starting counter which needs to be tos 
31b8			 
31b8					if DEBUG_FORTH_WORDS 
31b8						DMARK "DO4" 
31b8 f5				push af  
31b9 3a cd 31			ld a, (.dmark)  
31bc 32 bd fb			ld (debug_mark),a  
31bf 3a ce 31			ld a, (.dmark+1)  
31c2 32 be fb			ld (debug_mark+1),a  
31c5 3a cf 31			ld a, (.dmark+2)  
31c8 32 bf fb			ld (debug_mark+2),a  
31cb 18 03			jr .pastdmark  
31cd ..			.dmark: db "DO4"  
31d0 f1			.pastdmark: pop af  
31d1			endm  
# End of macro DMARK
31d1						CALLMONITOR 
31d1 cd ec 16			call break_point_state  
31d4				endm  
# End of macro CALLMONITOR
31d4					endif 
31d4					FORTH_DSP_POP 
31d4 cd 2b 1f			call macro_forth_dsp_pop 
31d7				endm 
# End of macro FORTH_DSP_POP
31d7			 
31d7					if DEBUG_FORTH_WORDS 
31d7						DMARK "DO5" 
31d7 f5				push af  
31d8 3a ec 31			ld a, (.dmark)  
31db 32 bd fb			ld (debug_mark),a  
31de 3a ed 31			ld a, (.dmark+1)  
31e1 32 be fb			ld (debug_mark+1),a  
31e4 3a ee 31			ld a, (.dmark+2)  
31e7 32 bf fb			ld (debug_mark+2),a  
31ea 18 03			jr .pastdmark  
31ec ..			.dmark: db "DO5"  
31ef f1			.pastdmark: pop af  
31f0			endm  
# End of macro DMARK
31f0						CALLMONITOR 
31f0 cd ec 16			call break_point_state  
31f3				endm  
# End of macro CALLMONITOR
31f3					endif 
31f3			 
31f3					FORTH_DSP_VALUEHL 
31f3 cd 73 1e			call macro_dsp_valuehl 
31f6				endm 
# End of macro FORTH_DSP_VALUEHL
31f6			;		push hl		 ; hl now has starting limit counter 
31f6			 
31f6					if DEBUG_FORTH_WORDS 
31f6						DMARK "DO6" 
31f6 f5				push af  
31f7 3a 0b 32			ld a, (.dmark)  
31fa 32 bd fb			ld (debug_mark),a  
31fd 3a 0c 32			ld a, (.dmark+1)  
3200 32 be fb			ld (debug_mark+1),a  
3203 3a 0d 32			ld a, (.dmark+2)  
3206 32 bf fb			ld (debug_mark+2),a  
3209 18 03			jr .pastdmark  
320b ..			.dmark: db "DO6"  
320e f1			.pastdmark: pop af  
320f			endm  
# End of macro DMARK
320f						CALLMONITOR 
320f cd ec 16			call break_point_state  
3212				endm  
# End of macro CALLMONITOR
3212					endif 
3212					FORTH_DSP_POP 
3212 cd 2b 1f			call macro_forth_dsp_pop 
3215				endm 
# End of macro FORTH_DSP_POP
3215			 
3215			; put counters on the loop stack 
3215			 
3215			;		pop hl			 ; limit counter 
3215 d1					pop de			; start counter 
3216			 
3216					; push limit counter 
3216			 
3216					if DEBUG_FORTH_WORDS 
3216						DMARK "DO7" 
3216 f5				push af  
3217 3a 2b 32			ld a, (.dmark)  
321a 32 bd fb			ld (debug_mark),a  
321d 3a 2c 32			ld a, (.dmark+1)  
3220 32 be fb			ld (debug_mark+1),a  
3223 3a 2d 32			ld a, (.dmark+2)  
3226 32 bf fb			ld (debug_mark+2),a  
3229 18 03			jr .pastdmark  
322b ..			.dmark: db "DO7"  
322e f1			.pastdmark: pop af  
322f			endm  
# End of macro DMARK
322f						CALLMONITOR 
322f cd ec 16			call break_point_state  
3232				endm  
# End of macro CALLMONITOR
3232					endif 
3232					FORTH_LOOP_NEXT 
3232 cd a4 1e			call macro_forth_loop_next 
3235				endm 
# End of macro FORTH_LOOP_NEXT
3235			 
3235					; push start counter 
3235			 
3235 eb					ex de, hl 
3236					if DEBUG_FORTH_WORDS 
3236						DMARK "DO7" 
3236 f5				push af  
3237 3a 4b 32			ld a, (.dmark)  
323a 32 bd fb			ld (debug_mark),a  
323d 3a 4c 32			ld a, (.dmark+1)  
3240 32 be fb			ld (debug_mark+1),a  
3243 3a 4d 32			ld a, (.dmark+2)  
3246 32 bf fb			ld (debug_mark+2),a  
3249 18 03			jr .pastdmark  
324b ..			.dmark: db "DO7"  
324e f1			.pastdmark: pop af  
324f			endm  
# End of macro DMARK
324f						CALLMONITOR 
324f cd ec 16			call break_point_state  
3252				endm  
# End of macro CALLMONITOR
3252					endif 
3252					FORTH_LOOP_NEXT 
3252 cd a4 1e			call macro_forth_loop_next 
3255				endm 
# End of macro FORTH_LOOP_NEXT
3255			 
3255			 
3255					; init first round of I counter 
3255			 
3255 22 c8 f2				ld (os_current_i), hl 
3258			 
3258					if DEBUG_FORTH_WORDS 
3258						DMARK "DO8" 
3258 f5				push af  
3259 3a 6d 32			ld a, (.dmark)  
325c 32 bd fb			ld (debug_mark),a  
325f 3a 6e 32			ld a, (.dmark+1)  
3262 32 be fb			ld (debug_mark+1),a  
3265 3a 6f 32			ld a, (.dmark+2)  
3268 32 bf fb			ld (debug_mark+2),a  
326b 18 03			jr .pastdmark  
326d ..			.dmark: db "DO8"  
3270 f1			.pastdmark: pop af  
3271			endm  
# End of macro DMARK
3271						CALLMONITOR 
3271 cd ec 16			call break_point_state  
3274				endm  
# End of macro CALLMONITOR
3274					endif 
3274			 
3274					NEXTW 
3274 c3 e5 1f			jp macro_next 
3277				endm 
# End of macro NEXTW
3277			.LOOP: 
3277				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
3277 22				db WORD_SYS_CORE+14             
3278 8f 33			dw .I            
327a 05				db 4 + 1 
327b .. 00			db "LOOP",0              
3280				endm 
# End of macro CWHEAD
3280			; | LOOP ( -- ) Increment and test loop counter  | DONE 
3280			 
3280				; pop tos as current loop count to hl 
3280			 
3280				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3280			 
3280				FORTH_LOOP_TOS 
3280 cd d7 1e			call macro_forth_loop_tos 
3283				endm 
# End of macro FORTH_LOOP_TOS
3283 e5				push hl 
3284			 
3284					if DEBUG_FORTH_WORDS_KEY 
3284						DMARK "LOP" 
3284 f5				push af  
3285 3a 99 32			ld a, (.dmark)  
3288 32 bd fb			ld (debug_mark),a  
328b 3a 9a 32			ld a, (.dmark+1)  
328e 32 be fb			ld (debug_mark+1),a  
3291 3a 9b 32			ld a, (.dmark+2)  
3294 32 bf fb			ld (debug_mark+2),a  
3297 18 03			jr .pastdmark  
3299 ..			.dmark: db "LOP"  
329c f1			.pastdmark: pop af  
329d			endm  
# End of macro DMARK
329d						CALLMONITOR 
329d cd ec 16			call break_point_state  
32a0				endm  
# End of macro CALLMONITOR
32a0					endif 
32a0				; next item on the stack is the limit. get it 
32a0			 
32a0			 
32a0				FORTH_LOOP_POP 
32a0 cd e1 1e			call macro_forth_loop_pop 
32a3				endm 
# End of macro FORTH_LOOP_POP
32a3			 
32a3				FORTH_LOOP_TOS 
32a3 cd d7 1e			call macro_forth_loop_tos 
32a6				endm 
# End of macro FORTH_LOOP_TOS
32a6			 
32a6 d1				pop de		 ; de = i, hl = limit 
32a7			 
32a7					if DEBUG_FORTH_WORDS 
32a7						DMARK "LP1" 
32a7 f5				push af  
32a8 3a bc 32			ld a, (.dmark)  
32ab 32 bd fb			ld (debug_mark),a  
32ae 3a bd 32			ld a, (.dmark+1)  
32b1 32 be fb			ld (debug_mark+1),a  
32b4 3a be 32			ld a, (.dmark+2)  
32b7 32 bf fb			ld (debug_mark+2),a  
32ba 18 03			jr .pastdmark  
32bc ..			.dmark: db "LP1"  
32bf f1			.pastdmark: pop af  
32c0			endm  
# End of macro DMARK
32c0						CALLMONITOR 
32c0 cd ec 16			call break_point_state  
32c3				endm  
# End of macro CALLMONITOR
32c3					endif 
32c3			 
32c3				; go back to previous word 
32c3			 
32c3 d5				push de    ; save I for inc later 
32c4			 
32c4			 
32c4				; get limit 
32c4				;  is I at limit? 
32c4			 
32c4			 
32c4					if DEBUG_FORTH_WORDS 
32c4						DMARK "LP1" 
32c4 f5				push af  
32c5 3a d9 32			ld a, (.dmark)  
32c8 32 bd fb			ld (debug_mark),a  
32cb 3a da 32			ld a, (.dmark+1)  
32ce 32 be fb			ld (debug_mark+1),a  
32d1 3a db 32			ld a, (.dmark+2)  
32d4 32 bf fb			ld (debug_mark+2),a  
32d7 18 03			jr .pastdmark  
32d9 ..			.dmark: db "LP1"  
32dc f1			.pastdmark: pop af  
32dd			endm  
# End of macro DMARK
32dd						CALLMONITOR 
32dd cd ec 16			call break_point_state  
32e0				endm  
# End of macro CALLMONITOR
32e0					endif 
32e0			 
32e0 ed 52			sbc hl, de 
32e2			 
32e2			 
32e2				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
32e2			 
32e2 20 26				jr nz, .loopnotdone 
32e4			 
32e4 e1				pop hl   ; get rid of saved I 
32e5				FORTH_LOOP_POP     ; get rid of limit 
32e5 cd e1 1e			call macro_forth_loop_pop 
32e8				endm 
# End of macro FORTH_LOOP_POP
32e8			 
32e8				FORTH_RSP_POP     ; get rid of DO ptr 
32e8 cd 44 1c			call macro_forth_rsp_pop 
32eb				endm 
# End of macro FORTH_RSP_POP
32eb			 
32eb			if DEBUG_FORTH_WORDS 
32eb						DMARK "LP>" 
32eb f5				push af  
32ec 3a 00 33			ld a, (.dmark)  
32ef 32 bd fb			ld (debug_mark),a  
32f2 3a 01 33			ld a, (.dmark+1)  
32f5 32 be fb			ld (debug_mark+1),a  
32f8 3a 02 33			ld a, (.dmark+2)  
32fb 32 bf fb			ld (debug_mark+2),a  
32fe 18 03			jr .pastdmark  
3300 ..			.dmark: db "LP>"  
3303 f1			.pastdmark: pop af  
3304			endm  
# End of macro DMARK
3304				CALLMONITOR 
3304 cd ec 16			call break_point_state  
3307				endm  
# End of macro CALLMONITOR
3307			endif 
3307			 
3307					NEXTW 
3307 c3 e5 1f			jp macro_next 
330a				endm 
# End of macro NEXTW
330a				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
330a			 
330a			.loopnotdone: 
330a			 
330a e1				pop hl    ; get I 
330b 23				inc hl 
330c			 
330c			   	; save new I 
330c			 
330c			 
330c					; set I counter 
330c			 
330c 22 c8 f2				ld (os_current_i), hl 
330f			 
330f					if DEBUG_FORTH_WORDS 
330f						DMARK "LPN" 
330f f5				push af  
3310 3a 24 33			ld a, (.dmark)  
3313 32 bd fb			ld (debug_mark),a  
3316 3a 25 33			ld a, (.dmark+1)  
3319 32 be fb			ld (debug_mark+1),a  
331c 3a 26 33			ld a, (.dmark+2)  
331f 32 bf fb			ld (debug_mark+2),a  
3322 18 03			jr .pastdmark  
3324 ..			.dmark: db "LPN"  
3327 f1			.pastdmark: pop af  
3328			endm  
# End of macro DMARK
3328					CALLMONITOR 
3328 cd ec 16			call break_point_state  
332b				endm  
# End of macro CALLMONITOR
332b					endif 
332b					 
332b				FORTH_LOOP_NEXT 
332b cd a4 1e			call macro_forth_loop_next 
332e				endm 
# End of macro FORTH_LOOP_NEXT
332e			 
332e			 
332e					if DEBUG_FORTH_WORDS 
332e eb						ex de,hl 
332f					endif 
332f			 
332f			;	; get DO ptr 
332f			; 
332f					if DEBUG_FORTH_WORDS 
332f						DMARK "LP7" 
332f f5				push af  
3330 3a 44 33			ld a, (.dmark)  
3333 32 bd fb			ld (debug_mark),a  
3336 3a 45 33			ld a, (.dmark+1)  
3339 32 be fb			ld (debug_mark+1),a  
333c 3a 46 33			ld a, (.dmark+2)  
333f 32 bf fb			ld (debug_mark+2),a  
3342 18 03			jr .pastdmark  
3344 ..			.dmark: db "LP7"  
3347 f1			.pastdmark: pop af  
3348			endm  
# End of macro DMARK
3348					CALLMONITOR 
3348 cd ec 16			call break_point_state  
334b				endm  
# End of macro CALLMONITOR
334b					endif 
334b				FORTH_RSP_TOS 
334b cd 3a 1c			call macro_forth_rsp_tos 
334e				endm 
# End of macro FORTH_RSP_TOS
334e			 
334e					if DEBUG_FORTH_WORDS 
334e						DMARK "LP8" 
334e f5				push af  
334f 3a 63 33			ld a, (.dmark)  
3352 32 bd fb			ld (debug_mark),a  
3355 3a 64 33			ld a, (.dmark+1)  
3358 32 be fb			ld (debug_mark+1),a  
335b 3a 65 33			ld a, (.dmark+2)  
335e 32 bf fb			ld (debug_mark+2),a  
3361 18 03			jr .pastdmark  
3363 ..			.dmark: db "LP8"  
3366 f1			.pastdmark: pop af  
3367			endm  
# End of macro DMARK
3367					CALLMONITOR 
3367 cd ec 16			call break_point_state  
336a				endm  
# End of macro CALLMONITOR
336a					endif 
336a				;push hl 
336a			 
336a				; not going to DO any more 
336a				; get rid of the RSP pointer as DO will add it back in 
336a				;FORTH_RSP_POP 
336a				;pop hl 
336a			 
336a				;ld hl,(cli_ret_sp) 
336a				;ld e, (hl) 
336a				;inc hl 
336a				;ld d, (hl) 
336a				;ex de,hl 
336a 22 a4 f2			ld (os_tok_ptr), hl 
336d					if DEBUG_FORTH_WORDS 
336d						DMARK "LP<" 
336d f5				push af  
336e 3a 82 33			ld a, (.dmark)  
3371 32 bd fb			ld (debug_mark),a  
3374 3a 83 33			ld a, (.dmark+1)  
3377 32 be fb			ld (debug_mark+1),a  
337a 3a 84 33			ld a, (.dmark+2)  
337d 32 bf fb			ld (debug_mark+2),a  
3380 18 03			jr .pastdmark  
3382 ..			.dmark: db "LP<"  
3385 f1			.pastdmark: pop af  
3386			endm  
# End of macro DMARK
3386					CALLMONITOR 
3386 cd ec 16			call break_point_state  
3389				endm  
# End of macro CALLMONITOR
3389				endif 
3389 c3 76 20			jp exec1 
338c			 
338c					 
338c			 
338c			 
338c					NEXTW 
338c c3 e5 1f			jp macro_next 
338f				endm 
# End of macro NEXTW
338f			.I:  
338f			 
338f				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
338f 5e				db WORD_SYS_CORE+74             
3390 ba 33			dw .DLOOP            
3392 02				db 1 + 1 
3393 .. 00			db "I",0              
3395				endm 
# End of macro CWHEAD
3395			; | I ( -- ) Current loop counter | DONE 
3395					if DEBUG_FORTH_WORDS_KEY 
3395						DMARK "I.." 
3395 f5				push af  
3396 3a aa 33			ld a, (.dmark)  
3399 32 bd fb			ld (debug_mark),a  
339c 3a ab 33			ld a, (.dmark+1)  
339f 32 be fb			ld (debug_mark+1),a  
33a2 3a ac 33			ld a, (.dmark+2)  
33a5 32 bf fb			ld (debug_mark+2),a  
33a8 18 03			jr .pastdmark  
33aa ..			.dmark: db "I.."  
33ad f1			.pastdmark: pop af  
33ae			endm  
# End of macro DMARK
33ae						CALLMONITOR 
33ae cd ec 16			call break_point_state  
33b1				endm  
# End of macro CALLMONITOR
33b1					endif 
33b1			 
33b1 2a c8 f2				ld hl,(os_current_i) 
33b4 cd 7c 1c				call forth_push_numhl 
33b7			 
33b7					NEXTW 
33b7 c3 e5 1f			jp macro_next 
33ba				endm 
# End of macro NEXTW
33ba			.DLOOP: 
33ba				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
33ba 5f				db WORD_SYS_CORE+75             
33bb 9b 34			dw .REPEAT            
33bd 06				db 5 + 1 
33be .. 00			db "-LOOP",0              
33c4				endm 
# End of macro CWHEAD
33c4			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
33c4				; pop tos as current loop count to hl 
33c4					if DEBUG_FORTH_WORDS_KEY 
33c4						DMARK "-LP" 
33c4 f5				push af  
33c5 3a d9 33			ld a, (.dmark)  
33c8 32 bd fb			ld (debug_mark),a  
33cb 3a da 33			ld a, (.dmark+1)  
33ce 32 be fb			ld (debug_mark+1),a  
33d1 3a db 33			ld a, (.dmark+2)  
33d4 32 bf fb			ld (debug_mark+2),a  
33d7 18 03			jr .pastdmark  
33d9 ..			.dmark: db "-LP"  
33dc f1			.pastdmark: pop af  
33dd			endm  
# End of macro DMARK
33dd						CALLMONITOR 
33dd cd ec 16			call break_point_state  
33e0				endm  
# End of macro CALLMONITOR
33e0					endif 
33e0			 
33e0				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
33e0			 
33e0				FORTH_LOOP_TOS 
33e0 cd d7 1e			call macro_forth_loop_tos 
33e3				endm 
# End of macro FORTH_LOOP_TOS
33e3 e5				push hl 
33e4			 
33e4					if DEBUG_FORTH_WORDS 
33e4						DMARK "-LP" 
33e4 f5				push af  
33e5 3a f9 33			ld a, (.dmark)  
33e8 32 bd fb			ld (debug_mark),a  
33eb 3a fa 33			ld a, (.dmark+1)  
33ee 32 be fb			ld (debug_mark+1),a  
33f1 3a fb 33			ld a, (.dmark+2)  
33f4 32 bf fb			ld (debug_mark+2),a  
33f7 18 03			jr .pastdmark  
33f9 ..			.dmark: db "-LP"  
33fc f1			.pastdmark: pop af  
33fd			endm  
# End of macro DMARK
33fd						CALLMONITOR 
33fd cd ec 16			call break_point_state  
3400				endm  
# End of macro CALLMONITOR
3400					endif 
3400				; next item on the stack is the limit. get it 
3400			 
3400			 
3400				FORTH_LOOP_POP 
3400 cd e1 1e			call macro_forth_loop_pop 
3403				endm 
# End of macro FORTH_LOOP_POP
3403			 
3403				FORTH_LOOP_TOS 
3403 cd d7 1e			call macro_forth_loop_tos 
3406				endm 
# End of macro FORTH_LOOP_TOS
3406			 
3406 d1				pop de		 ; de = i, hl = limit 
3407			 
3407					if DEBUG_FORTH_WORDS 
3407						DMARK "-L1" 
3407 f5				push af  
3408 3a 1c 34			ld a, (.dmark)  
340b 32 bd fb			ld (debug_mark),a  
340e 3a 1d 34			ld a, (.dmark+1)  
3411 32 be fb			ld (debug_mark+1),a  
3414 3a 1e 34			ld a, (.dmark+2)  
3417 32 bf fb			ld (debug_mark+2),a  
341a 18 03			jr .pastdmark  
341c ..			.dmark: db "-L1"  
341f f1			.pastdmark: pop af  
3420			endm  
# End of macro DMARK
3420						CALLMONITOR 
3420 cd ec 16			call break_point_state  
3423				endm  
# End of macro CALLMONITOR
3423					endif 
3423			 
3423				; go back to previous word 
3423			 
3423 d5				push de    ; save I for inc later 
3424			 
3424			 
3424				; get limit 
3424				;  is I at limit? 
3424			 
3424			 
3424					if DEBUG_FORTH_WORDS 
3424						DMARK "-L1" 
3424 f5				push af  
3425 3a 39 34			ld a, (.dmark)  
3428 32 bd fb			ld (debug_mark),a  
342b 3a 3a 34			ld a, (.dmark+1)  
342e 32 be fb			ld (debug_mark+1),a  
3431 3a 3b 34			ld a, (.dmark+2)  
3434 32 bf fb			ld (debug_mark+2),a  
3437 18 03			jr .pastdmark  
3439 ..			.dmark: db "-L1"  
343c f1			.pastdmark: pop af  
343d			endm  
# End of macro DMARK
343d						CALLMONITOR 
343d cd ec 16			call break_point_state  
3440				endm  
# End of macro CALLMONITOR
3440					endif 
3440			 
3440 ed 52			sbc hl, de 
3442			 
3442			 
3442				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3442			 
3442 20 26				jr nz, .mloopnotdone 
3444			 
3444 e1				pop hl   ; get rid of saved I 
3445				FORTH_LOOP_POP     ; get rid of limit 
3445 cd e1 1e			call macro_forth_loop_pop 
3448				endm 
# End of macro FORTH_LOOP_POP
3448			 
3448				FORTH_RSP_POP     ; get rid of DO ptr 
3448 cd 44 1c			call macro_forth_rsp_pop 
344b				endm 
# End of macro FORTH_RSP_POP
344b			 
344b			if DEBUG_FORTH_WORDS 
344b						DMARK "-L>" 
344b f5				push af  
344c 3a 60 34			ld a, (.dmark)  
344f 32 bd fb			ld (debug_mark),a  
3452 3a 61 34			ld a, (.dmark+1)  
3455 32 be fb			ld (debug_mark+1),a  
3458 3a 62 34			ld a, (.dmark+2)  
345b 32 bf fb			ld (debug_mark+2),a  
345e 18 03			jr .pastdmark  
3460 ..			.dmark: db "-L>"  
3463 f1			.pastdmark: pop af  
3464			endm  
# End of macro DMARK
3464				CALLMONITOR 
3464 cd ec 16			call break_point_state  
3467				endm  
# End of macro CALLMONITOR
3467			endif 
3467			 
3467					NEXTW 
3467 c3 e5 1f			jp macro_next 
346a				endm 
# End of macro NEXTW
346a				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
346a			 
346a			.mloopnotdone: 
346a			 
346a e1				pop hl    ; get I 
346b 2b				dec hl 
346c			 
346c			   	; save new I 
346c			 
346c			 
346c					; set I counter 
346c			 
346c 22 c8 f2				ld (os_current_i), hl 
346f			 
346f					 
346f				FORTH_LOOP_NEXT 
346f cd a4 1e			call macro_forth_loop_next 
3472				endm 
# End of macro FORTH_LOOP_NEXT
3472			 
3472			 
3472					if DEBUG_FORTH_WORDS 
3472 eb						ex de,hl 
3473					endif 
3473			 
3473			;	; get DO ptr 
3473			; 
3473				FORTH_RSP_TOS 
3473 cd 3a 1c			call macro_forth_rsp_tos 
3476				endm 
# End of macro FORTH_RSP_TOS
3476			 
3476				;push hl 
3476			 
3476				; not going to DO any more 
3476				; get rid of the RSP pointer as DO will add it back in 
3476				;FORTH_RSP_POP 
3476				;pop hl 
3476			 
3476			 
3476 22 a4 f2			ld (os_tok_ptr), hl 
3479					if DEBUG_FORTH_WORDS 
3479						DMARK "-L<" 
3479 f5				push af  
347a 3a 8e 34			ld a, (.dmark)  
347d 32 bd fb			ld (debug_mark),a  
3480 3a 8f 34			ld a, (.dmark+1)  
3483 32 be fb			ld (debug_mark+1),a  
3486 3a 90 34			ld a, (.dmark+2)  
3489 32 bf fb			ld (debug_mark+2),a  
348c 18 03			jr .pastdmark  
348e ..			.dmark: db "-L<"  
3491 f1			.pastdmark: pop af  
3492			endm  
# End of macro DMARK
3492					CALLMONITOR 
3492 cd ec 16			call break_point_state  
3495				endm  
# End of macro CALLMONITOR
3495				endif 
3495 c3 76 20			jp exec1 
3498			 
3498					 
3498			 
3498			 
3498			 
3498				NEXTW 
3498 c3 e5 1f			jp macro_next 
349b				endm 
# End of macro NEXTW
349b			 
349b			 
349b			 
349b			 
349b			.REPEAT: 
349b				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
349b 71				db WORD_SYS_CORE+93             
349c ee 34			dw .UNTIL            
349e 06				db 5 + 1 
349f .. 00			db "REPEAT",0              
34a6				endm 
# End of macro CWHEAD
34a6			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
34a6			;  push pc to rsp stack past the REPEAT 
34a6					if DEBUG_FORTH_WORDS_KEY 
34a6						DMARK "REP" 
34a6 f5				push af  
34a7 3a bb 34			ld a, (.dmark)  
34aa 32 bd fb			ld (debug_mark),a  
34ad 3a bc 34			ld a, (.dmark+1)  
34b0 32 be fb			ld (debug_mark+1),a  
34b3 3a bd 34			ld a, (.dmark+2)  
34b6 32 bf fb			ld (debug_mark+2),a  
34b9 18 03			jr .pastdmark  
34bb ..			.dmark: db "REP"  
34be f1			.pastdmark: pop af  
34bf			endm  
# End of macro DMARK
34bf						CALLMONITOR 
34bf cd ec 16			call break_point_state  
34c2				endm  
# End of macro CALLMONITOR
34c2					endif 
34c2			 
34c2 2a a4 f2				ld hl, (os_tok_ptr) 
34c5 23					inc hl   ; R 
34c6 23					inc hl  ; E 
34c7 23					inc hl   ; P 
34c8 23					inc hl   ; E 
34c9 23					inc hl   ; A 
34ca 23					inc hl   ; T 
34cb 23					inc hl   ; zero 
34cc					FORTH_RSP_NEXT 
34cc cd 23 1c			call macro_forth_rsp_next 
34cf				endm 
# End of macro FORTH_RSP_NEXT
34cf			 
34cf			 
34cf					if DEBUG_FORTH_WORDS 
34cf						DMARK "REP" 
34cf f5				push af  
34d0 3a e4 34			ld a, (.dmark)  
34d3 32 bd fb			ld (debug_mark),a  
34d6 3a e5 34			ld a, (.dmark+1)  
34d9 32 be fb			ld (debug_mark+1),a  
34dc 3a e6 34			ld a, (.dmark+2)  
34df 32 bf fb			ld (debug_mark+2),a  
34e2 18 03			jr .pastdmark  
34e4 ..			.dmark: db "REP"  
34e7 f1			.pastdmark: pop af  
34e8			endm  
# End of macro DMARK
34e8						;pop bc    ; TODO BUG ?????? what is this for???? 
34e8						CALLMONITOR 
34e8 cd ec 16			call break_point_state  
34eb				endm  
# End of macro CALLMONITOR
34eb					endif 
34eb			 
34eb					NEXTW 
34eb c3 e5 1f			jp macro_next 
34ee				endm 
# End of macro NEXTW
34ee			;	       NEXTW 
34ee			 
34ee			.UNTIL: 
34ee				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
34ee 72				db WORD_SYS_CORE+94             
34ef 85 35			dw .ENDFLOW            
34f1 06				db 5 + 1 
34f2 .. 00			db "UNTIL",0              
34f8				endm 
# End of macro CWHEAD
34f8			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
34f8			 
34f8				; pop tos as check 
34f8			 
34f8				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
34f8			 
34f8				FORTH_DSP_VALUEHL 
34f8 cd 73 1e			call macro_dsp_valuehl 
34fb				endm 
# End of macro FORTH_DSP_VALUEHL
34fb			 
34fb					if DEBUG_FORTH_WORDS_KEY 
34fb						DMARK "UNT" 
34fb f5				push af  
34fc 3a 10 35			ld a, (.dmark)  
34ff 32 bd fb			ld (debug_mark),a  
3502 3a 11 35			ld a, (.dmark+1)  
3505 32 be fb			ld (debug_mark+1),a  
3508 3a 12 35			ld a, (.dmark+2)  
350b 32 bf fb			ld (debug_mark+2),a  
350e 18 03			jr .pastdmark  
3510 ..			.dmark: db "UNT"  
3513 f1			.pastdmark: pop af  
3514			endm  
# End of macro DMARK
3514						CALLMONITOR 
3514 cd ec 16			call break_point_state  
3517				endm  
# End of macro CALLMONITOR
3517					endif 
3517			 
3517			;	push hl 
3517				FORTH_DSP_POP 
3517 cd 2b 1f			call macro_forth_dsp_pop 
351a				endm 
# End of macro FORTH_DSP_POP
351a			 
351a			;	pop hl 
351a			 
351a				; test if true 
351a			 
351a cd 2f 0d			call ishlzero 
351d			;	ld a,l 
351d			;	add h 
351d			; 
351d			;	cp 0 
351d			 
351d 20 3e			jr nz, .untilnotdone 
351f			 
351f					if DEBUG_FORTH_WORDS 
351f						DMARK "UNf" 
351f f5				push af  
3520 3a 34 35			ld a, (.dmark)  
3523 32 bd fb			ld (debug_mark),a  
3526 3a 35 35			ld a, (.dmark+1)  
3529 32 be fb			ld (debug_mark+1),a  
352c 3a 36 35			ld a, (.dmark+2)  
352f 32 bf fb			ld (debug_mark+2),a  
3532 18 03			jr .pastdmark  
3534 ..			.dmark: db "UNf"  
3537 f1			.pastdmark: pop af  
3538			endm  
# End of macro DMARK
3538						CALLMONITOR 
3538 cd ec 16			call break_point_state  
353b				endm  
# End of macro CALLMONITOR
353b					endif 
353b			 
353b			 
353b			 
353b				FORTH_RSP_POP     ; get rid of DO ptr 
353b cd 44 1c			call macro_forth_rsp_pop 
353e				endm 
# End of macro FORTH_RSP_POP
353e			 
353e			if DEBUG_FORTH_WORDS 
353e						DMARK "UN>" 
353e f5				push af  
353f 3a 53 35			ld a, (.dmark)  
3542 32 bd fb			ld (debug_mark),a  
3545 3a 54 35			ld a, (.dmark+1)  
3548 32 be fb			ld (debug_mark+1),a  
354b 3a 55 35			ld a, (.dmark+2)  
354e 32 bf fb			ld (debug_mark+2),a  
3551 18 03			jr .pastdmark  
3553 ..			.dmark: db "UN>"  
3556 f1			.pastdmark: pop af  
3557			endm  
# End of macro DMARK
3557				CALLMONITOR 
3557 cd ec 16			call break_point_state  
355a				endm  
# End of macro CALLMONITOR
355a			endif 
355a			 
355a					NEXTW 
355a c3 e5 1f			jp macro_next 
355d				endm 
# End of macro NEXTW
355d				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
355d			 
355d			.untilnotdone: 
355d			 
355d			 
355d			;	; get DO ptr 
355d			; 
355d				FORTH_RSP_TOS 
355d cd 3a 1c			call macro_forth_rsp_tos 
3560				endm 
# End of macro FORTH_RSP_TOS
3560			 
3560				;push hl 
3560			 
3560				; not going to DO any more 
3560				; get rid of the RSP pointer as DO will add it back in 
3560				;FORTH_RSP_POP 
3560				;pop hl 
3560			 
3560			 
3560 22 a4 f2			ld (os_tok_ptr), hl 
3563					if DEBUG_FORTH_WORDS 
3563						DMARK "UN<" 
3563 f5				push af  
3564 3a 78 35			ld a, (.dmark)  
3567 32 bd fb			ld (debug_mark),a  
356a 3a 79 35			ld a, (.dmark+1)  
356d 32 be fb			ld (debug_mark+1),a  
3570 3a 7a 35			ld a, (.dmark+2)  
3573 32 bf fb			ld (debug_mark+2),a  
3576 18 03			jr .pastdmark  
3578 ..			.dmark: db "UN<"  
357b f1			.pastdmark: pop af  
357c			endm  
# End of macro DMARK
357c					CALLMONITOR 
357c cd ec 16			call break_point_state  
357f				endm  
# End of macro CALLMONITOR
357f				endif 
357f c3 76 20			jp exec1 
3582			 
3582					 
3582			 
3582			 
3582					NEXTW 
3582 c3 e5 1f			jp macro_next 
3585				endm 
# End of macro NEXTW
3585			 
3585			 
3585			.ENDFLOW: 
3585			 
3585			; eof 
3585			 
# End of file forth_words_flow.asm
3585			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
3585			include "forth_words_logic.asm" 
3585			 
3585			; | ## Logic Words 
3585			 
3585			.NOT: 
3585				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
3585 2d				db WORD_SYS_CORE+25             
3586 cd 35			dw .IS            
3588 04				db 3 + 1 
3589 .. 00			db "NOT",0              
358d				endm 
# End of macro CWHEAD
358d			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
358d					if DEBUG_FORTH_WORDS_KEY 
358d						DMARK "NOT" 
358d f5				push af  
358e 3a a2 35			ld a, (.dmark)  
3591 32 bd fb			ld (debug_mark),a  
3594 3a a3 35			ld a, (.dmark+1)  
3597 32 be fb			ld (debug_mark+1),a  
359a 3a a4 35			ld a, (.dmark+2)  
359d 32 bf fb			ld (debug_mark+2),a  
35a0 18 03			jr .pastdmark  
35a2 ..			.dmark: db "NOT"  
35a5 f1			.pastdmark: pop af  
35a6			endm  
# End of macro DMARK
35a6						CALLMONITOR 
35a6 cd ec 16			call break_point_state  
35a9				endm  
# End of macro CALLMONITOR
35a9					endif 
35a9					FORTH_DSP 
35a9 cd 39 1e			call macro_forth_dsp 
35ac				endm 
# End of macro FORTH_DSP
35ac 7e					ld a,(hl)	; get type of value on TOS 
35ad fe 02				cp DS_TYPE_INUM  
35af 28 03				jr z, .noti 
35b1					NEXTW 
35b1 c3 e5 1f			jp macro_next 
35b4				endm 
# End of macro NEXTW
35b4			.noti:          FORTH_DSP_VALUEHL 
35b4 cd 73 1e			call macro_dsp_valuehl 
35b7				endm 
# End of macro FORTH_DSP_VALUEHL
35b7			;		push hl 
35b7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35b7 cd 2b 1f			call macro_forth_dsp_pop 
35ba				endm 
# End of macro FORTH_DSP_POP
35ba			;		pop hl 
35ba 3e 00				ld a,0 
35bc bd					cp l 
35bd 28 04				jr z, .not2t 
35bf 2e 00				ld l, 0 
35c1 18 02				jr .notip 
35c3			 
35c3 2e ff		.not2t:		ld l, 255 
35c5			 
35c5 26 00		.notip:		ld h, 0	 
35c7			 
35c7 cd 7c 1c				call forth_push_numhl 
35ca					NEXTW 
35ca c3 e5 1f			jp macro_next 
35cd				endm 
# End of macro NEXTW
35cd			 
35cd			.IS: 
35cd				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
35cd 2d				db WORD_SYS_CORE+25             
35ce f3 35			dw .LZERO            
35d0 03				db 2 + 1 
35d1 .. 00			db "IS",0              
35d4				endm 
# End of macro CWHEAD
35d4			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
35d4					if DEBUG_FORTH_WORDS_KEY 
35d4						DMARK "IS." 
35d4 f5				push af  
35d5 3a e9 35			ld a, (.dmark)  
35d8 32 bd fb			ld (debug_mark),a  
35db 3a ea 35			ld a, (.dmark+1)  
35de 32 be fb			ld (debug_mark+1),a  
35e1 3a eb 35			ld a, (.dmark+2)  
35e4 32 bf fb			ld (debug_mark+2),a  
35e7 18 03			jr .pastdmark  
35e9 ..			.dmark: db "IS."  
35ec f1			.pastdmark: pop af  
35ed			endm  
# End of macro DMARK
35ed						CALLMONITOR 
35ed cd ec 16			call break_point_state  
35f0				endm  
# End of macro CALLMONITOR
35f0					endif 
35f0					NEXTW 
35f0 c3 e5 1f			jp macro_next 
35f3				endm 
# End of macro NEXTW
35f3			.LZERO: 
35f3				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
35f3 2d				db WORD_SYS_CORE+25             
35f4 fd 35			dw .TZERO            
35f6 03				db 2 + 1 
35f7 .. 00			db "0<",0              
35fa				endm 
# End of macro CWHEAD
35fa			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
35fa					NEXTW 
35fa c3 e5 1f			jp macro_next 
35fd				endm 
# End of macro NEXTW
35fd			.TZERO: 
35fd				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
35fd 2e				db WORD_SYS_CORE+26             
35fe 44 36			dw .LESS            
3600 03				db 2 + 1 
3601 .. 00			db "0=",0              
3604				endm 
# End of macro CWHEAD
3604			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
3604				; TODO add floating point number detection 
3604					;v5 FORTH_DSP_VALUE 
3604					if DEBUG_FORTH_WORDS_KEY 
3604						DMARK "0=." 
3604 f5				push af  
3605 3a 19 36			ld a, (.dmark)  
3608 32 bd fb			ld (debug_mark),a  
360b 3a 1a 36			ld a, (.dmark+1)  
360e 32 be fb			ld (debug_mark+1),a  
3611 3a 1b 36			ld a, (.dmark+2)  
3614 32 bf fb			ld (debug_mark+2),a  
3617 18 03			jr .pastdmark  
3619 ..			.dmark: db "0=."  
361c f1			.pastdmark: pop af  
361d			endm  
# End of macro DMARK
361d						CALLMONITOR 
361d cd ec 16			call break_point_state  
3620				endm  
# End of macro CALLMONITOR
3620					endif 
3620					FORTH_DSP 
3620 cd 39 1e			call macro_forth_dsp 
3623				endm 
# End of macro FORTH_DSP
3623 7e					ld a,(hl)	; get type of value on TOS 
3624 fe 02				cp DS_TYPE_INUM  
3626 28 00				jr z, .tz_inum 
3628			 
3628				if FORTH_ENABLE_FLOATMATH 
3628					jr .tz_done 
3628			 
3628				endif 
3628					 
3628			 
3628			.tz_inum: 
3628					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3628 cd 73 1e			call macro_dsp_valuehl 
362b				endm 
# End of macro FORTH_DSP_VALUEHL
362b			 
362b			;		push hl 
362b			 
362b					; destroy value TOS 
362b			 
362b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
362b cd 2b 1f			call macro_forth_dsp_pop 
362e				endm 
# End of macro FORTH_DSP_POP
362e			 
362e			;		pop hl 
362e			 
362e 3e 00				ld a,0 
3630			 
3630 bd					cp l 
3631 20 08				jr nz, .tz_notzero 
3633			 
3633 bc					cp h 
3634			 
3634 20 05				jr nz, .tz_notzero 
3636			 
3636			 
3636 21 01 00				ld hl, FORTH_TRUE 
3639 18 03				jr .tz_done 
363b			 
363b 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
363e			 
363e					; push value back onto stack for another op etc 
363e			 
363e			.tz_done: 
363e cd 7c 1c				call forth_push_numhl 
3641			 
3641					NEXTW 
3641 c3 e5 1f			jp macro_next 
3644				endm 
# End of macro NEXTW
3644			.LESS: 
3644				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3644 2f				db WORD_SYS_CORE+27             
3645 ad 36			dw .GT            
3647 02				db 1 + 1 
3648 .. 00			db "<",0              
364a				endm 
# End of macro CWHEAD
364a			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
364a				; TODO add floating point number detection 
364a					if DEBUG_FORTH_WORDS_KEY 
364a						DMARK "LES" 
364a f5				push af  
364b 3a 5f 36			ld a, (.dmark)  
364e 32 bd fb			ld (debug_mark),a  
3651 3a 60 36			ld a, (.dmark+1)  
3654 32 be fb			ld (debug_mark+1),a  
3657 3a 61 36			ld a, (.dmark+2)  
365a 32 bf fb			ld (debug_mark+2),a  
365d 18 03			jr .pastdmark  
365f ..			.dmark: db "LES"  
3662 f1			.pastdmark: pop af  
3663			endm  
# End of macro DMARK
3663						CALLMONITOR 
3663 cd ec 16			call break_point_state  
3666				endm  
# End of macro CALLMONITOR
3666					endif 
3666					FORTH_DSP 
3666 cd 39 1e			call macro_forth_dsp 
3669				endm 
# End of macro FORTH_DSP
3669					;v5 FORTH_DSP_VALUE 
3669 7e					ld a,(hl)	; get type of value on TOS 
366a fe 02				cp DS_TYPE_INUM  
366c 28 00				jr z, .less_inum 
366e			 
366e				if FORTH_ENABLE_FLOATMATH 
366e					jr .less_done 
366e			 
366e				endif 
366e					 
366e			 
366e			.less_inum: 
366e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
366e cd 73 1e			call macro_dsp_valuehl 
3671				endm 
# End of macro FORTH_DSP_VALUEHL
3671			 
3671 e5					push hl  ; u2 
3672			 
3672					; destroy value TOS 
3672			 
3672					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3672 cd 2b 1f			call macro_forth_dsp_pop 
3675				endm 
# End of macro FORTH_DSP_POP
3675			 
3675			 
3675					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3675 cd 73 1e			call macro_dsp_valuehl 
3678				endm 
# End of macro FORTH_DSP_VALUEHL
3678			 
3678 e5					push hl    ; u1 
3679			 
3679					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3679 cd 2b 1f			call macro_forth_dsp_pop 
367c				endm 
# End of macro FORTH_DSP_POP
367c			 
367c			 
367c b7			 or a      ;clear carry flag 
367d 01 00 00		 ld bc, FORTH_FALSE 
3680 e1			  pop hl    ; u1 
3681 d1			  pop de    ; u2 
3682 ed 52		  sbc hl,de 
3684 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
3686			 
3686 01 01 00		 ld bc, FORTH_TRUE 
3689			.lscont:  
3689 c5					push bc 
368a e1					pop hl 
368b			 
368b					if DEBUG_FORTH_WORDS 
368b						DMARK "LT1" 
368b f5				push af  
368c 3a a0 36			ld a, (.dmark)  
368f 32 bd fb			ld (debug_mark),a  
3692 3a a1 36			ld a, (.dmark+1)  
3695 32 be fb			ld (debug_mark+1),a  
3698 3a a2 36			ld a, (.dmark+2)  
369b 32 bf fb			ld (debug_mark+2),a  
369e 18 03			jr .pastdmark  
36a0 ..			.dmark: db "LT1"  
36a3 f1			.pastdmark: pop af  
36a4			endm  
# End of macro DMARK
36a4						CALLMONITOR 
36a4 cd ec 16			call break_point_state  
36a7				endm  
# End of macro CALLMONITOR
36a7					endif 
36a7 cd 7c 1c				call forth_push_numhl 
36aa			 
36aa					NEXTW 
36aa c3 e5 1f			jp macro_next 
36ad				endm 
# End of macro NEXTW
36ad			.GT: 
36ad				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
36ad 30				db WORD_SYS_CORE+28             
36ae 16 37			dw .EQUAL            
36b0 02				db 1 + 1 
36b1 .. 00			db ">",0              
36b3				endm 
# End of macro CWHEAD
36b3			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
36b3				; TODO add floating point number detection 
36b3					if DEBUG_FORTH_WORDS_KEY 
36b3						DMARK "GRT" 
36b3 f5				push af  
36b4 3a c8 36			ld a, (.dmark)  
36b7 32 bd fb			ld (debug_mark),a  
36ba 3a c9 36			ld a, (.dmark+1)  
36bd 32 be fb			ld (debug_mark+1),a  
36c0 3a ca 36			ld a, (.dmark+2)  
36c3 32 bf fb			ld (debug_mark+2),a  
36c6 18 03			jr .pastdmark  
36c8 ..			.dmark: db "GRT"  
36cb f1			.pastdmark: pop af  
36cc			endm  
# End of macro DMARK
36cc						CALLMONITOR 
36cc cd ec 16			call break_point_state  
36cf				endm  
# End of macro CALLMONITOR
36cf					endif 
36cf					FORTH_DSP 
36cf cd 39 1e			call macro_forth_dsp 
36d2				endm 
# End of macro FORTH_DSP
36d2					;FORTH_DSP_VALUE 
36d2 7e					ld a,(hl)	; get type of value on TOS 
36d3 fe 02				cp DS_TYPE_INUM  
36d5 28 00				jr z, .gt_inum 
36d7			 
36d7				if FORTH_ENABLE_FLOATMATH 
36d7					jr .gt_done 
36d7			 
36d7				endif 
36d7					 
36d7			 
36d7			.gt_inum: 
36d7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36d7 cd 73 1e			call macro_dsp_valuehl 
36da				endm 
# End of macro FORTH_DSP_VALUEHL
36da			 
36da e5					push hl  ; u2 
36db			 
36db					; destroy value TOS 
36db			 
36db					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36db cd 2b 1f			call macro_forth_dsp_pop 
36de				endm 
# End of macro FORTH_DSP_POP
36de			 
36de			 
36de					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36de cd 73 1e			call macro_dsp_valuehl 
36e1				endm 
# End of macro FORTH_DSP_VALUEHL
36e1			 
36e1 e5					push hl    ; u1 
36e2			 
36e2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36e2 cd 2b 1f			call macro_forth_dsp_pop 
36e5				endm 
# End of macro FORTH_DSP_POP
36e5			 
36e5			 
36e5 b7			 or a      ;clear carry flag 
36e6 01 00 00		 ld bc, FORTH_FALSE 
36e9 e1			  pop hl    ; u1 
36ea d1			  pop de    ; u2 
36eb ed 52		  sbc hl,de 
36ed 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
36ef			 
36ef 01 01 00		 ld bc, FORTH_TRUE 
36f2			.gtcont:  
36f2 c5					push bc 
36f3 e1					pop hl 
36f4			 
36f4					if DEBUG_FORTH_WORDS 
36f4						DMARK "GT1" 
36f4 f5				push af  
36f5 3a 09 37			ld a, (.dmark)  
36f8 32 bd fb			ld (debug_mark),a  
36fb 3a 0a 37			ld a, (.dmark+1)  
36fe 32 be fb			ld (debug_mark+1),a  
3701 3a 0b 37			ld a, (.dmark+2)  
3704 32 bf fb			ld (debug_mark+2),a  
3707 18 03			jr .pastdmark  
3709 ..			.dmark: db "GT1"  
370c f1			.pastdmark: pop af  
370d			endm  
# End of macro DMARK
370d						CALLMONITOR 
370d cd ec 16			call break_point_state  
3710				endm  
# End of macro CALLMONITOR
3710					endif 
3710 cd 7c 1c				call forth_push_numhl 
3713			 
3713					NEXTW 
3713 c3 e5 1f			jp macro_next 
3716				endm 
# End of macro NEXTW
3716			.EQUAL: 
3716				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3716 31				db WORD_SYS_CORE+29             
3717 81 37			dw .ENDLOGIC            
3719 02				db 1 + 1 
371a .. 00			db "=",0              
371c				endm 
# End of macro CWHEAD
371c			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
371c				; TODO add floating point number detection 
371c					if DEBUG_FORTH_WORDS_KEY 
371c						DMARK "EQ." 
371c f5				push af  
371d 3a 31 37			ld a, (.dmark)  
3720 32 bd fb			ld (debug_mark),a  
3723 3a 32 37			ld a, (.dmark+1)  
3726 32 be fb			ld (debug_mark+1),a  
3729 3a 33 37			ld a, (.dmark+2)  
372c 32 bf fb			ld (debug_mark+2),a  
372f 18 03			jr .pastdmark  
3731 ..			.dmark: db "EQ."  
3734 f1			.pastdmark: pop af  
3735			endm  
# End of macro DMARK
3735						CALLMONITOR 
3735 cd ec 16			call break_point_state  
3738				endm  
# End of macro CALLMONITOR
3738					endif 
3738					FORTH_DSP 
3738 cd 39 1e			call macro_forth_dsp 
373b				endm 
# End of macro FORTH_DSP
373b					;v5 FORTH_DSP_VALUE 
373b 7e					ld a,(hl)	; get type of value on TOS 
373c fe 02				cp DS_TYPE_INUM  
373e 28 00				jr z, .eq_inum 
3740			 
3740				if FORTH_ENABLE_FLOATMATH 
3740					jr .eq_done 
3740			 
3740				endif 
3740					 
3740			 
3740			.eq_inum: 
3740					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3740 cd 73 1e			call macro_dsp_valuehl 
3743				endm 
# End of macro FORTH_DSP_VALUEHL
3743			 
3743 e5					push hl 
3744			 
3744					; destroy value TOS 
3744			 
3744					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3744 cd 2b 1f			call macro_forth_dsp_pop 
3747				endm 
# End of macro FORTH_DSP_POP
3747			 
3747			 
3747					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3747 cd 73 1e			call macro_dsp_valuehl 
374a				endm 
# End of macro FORTH_DSP_VALUEHL
374a			 
374a					; one value on hl get other one back 
374a			 
374a e5					push hl 
374b			 
374b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
374b cd 2b 1f			call macro_forth_dsp_pop 
374e				endm 
# End of macro FORTH_DSP_POP
374e			 
374e 0e 00				ld c, FORTH_FALSE 
3750			 
3750 e1					pop hl 
3751 d1					pop de 
3752			 
3752 7b					ld a, e 
3753 bd					cp l 
3754			 
3754 20 06				jr nz, .eq_done 
3756			 
3756 7a					ld a, d 
3757 bc					cp h 
3758			 
3758 20 02				jr nz, .eq_done 
375a			 
375a 0e 01				ld c, FORTH_TRUE 
375c					 
375c			 
375c			 
375c			.eq_done: 
375c			 
375c					; TODO push value back onto stack for another op etc 
375c			 
375c 26 00				ld h, 0 
375e 69					ld l, c 
375f					if DEBUG_FORTH_WORDS 
375f						DMARK "EQ1" 
375f f5				push af  
3760 3a 74 37			ld a, (.dmark)  
3763 32 bd fb			ld (debug_mark),a  
3766 3a 75 37			ld a, (.dmark+1)  
3769 32 be fb			ld (debug_mark+1),a  
376c 3a 76 37			ld a, (.dmark+2)  
376f 32 bf fb			ld (debug_mark+2),a  
3772 18 03			jr .pastdmark  
3774 ..			.dmark: db "EQ1"  
3777 f1			.pastdmark: pop af  
3778			endm  
# End of macro DMARK
3778						CALLMONITOR 
3778 cd ec 16			call break_point_state  
377b				endm  
# End of macro CALLMONITOR
377b					endif 
377b cd 7c 1c				call forth_push_numhl 
377e			 
377e					NEXTW 
377e c3 e5 1f			jp macro_next 
3781				endm 
# End of macro NEXTW
3781			 
3781			 
3781			.ENDLOGIC: 
3781			; eof 
3781			 
3781			 
# End of file forth_words_logic.asm
3781			include "forth_words_maths.asm" 
3781			 
3781			; | ## Maths Words 
3781			 
3781			.PLUS:	 
3781				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3781 15				db WORD_SYS_CORE+1             
3782 c3 37			dw .NEG            
3784 02				db 1 + 1 
3785 .. 00			db "+",0              
3787				endm 
# End of macro CWHEAD
3787			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3787					if DEBUG_FORTH_WORDS_KEY 
3787						DMARK "PLU" 
3787 f5				push af  
3788 3a 9c 37			ld a, (.dmark)  
378b 32 bd fb			ld (debug_mark),a  
378e 3a 9d 37			ld a, (.dmark+1)  
3791 32 be fb			ld (debug_mark+1),a  
3794 3a 9e 37			ld a, (.dmark+2)  
3797 32 bf fb			ld (debug_mark+2),a  
379a 18 03			jr .pastdmark  
379c ..			.dmark: db "PLU"  
379f f1			.pastdmark: pop af  
37a0			endm  
# End of macro DMARK
37a0						CALLMONITOR 
37a0 cd ec 16			call break_point_state  
37a3				endm  
# End of macro CALLMONITOR
37a3					endif 
37a3					; add top two values and push back result 
37a3			 
37a3					;for v5 FORTH_DSP_VALUE 
37a3					FORTH_DSP 
37a3 cd 39 1e			call macro_forth_dsp 
37a6				endm 
# End of macro FORTH_DSP
37a6 7e					ld a,(hl)	; get type of value on TOS 
37a7 fe 02				cp DS_TYPE_INUM  
37a9 28 03				jr z, .dot_inum 
37ab			 
37ab					NEXTW 
37ab c3 e5 1f			jp macro_next 
37ae				endm 
# End of macro NEXTW
37ae			 
37ae			; float maths 
37ae			 
37ae				if FORTH_ENABLE_FLOATMATH 
37ae						inc hl      ; now at start of numeric as string 
37ae			 
37ae					if DEBUG_FORTH_MATHS 
37ae						DMARK "ADD" 
37ae				CALLMONITOR 
37ae					endif 
37ae			 
37ae					;ld ix, hl 
37ae					call CON 
37ae			 
37ae			 
37ae					push hl 
37ae					 
37ae					 
37ae			 
37ae						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
37ae			 
37ae					; get next number 
37ae			 
37ae						FORTH_DSP_VALUE 
37ae			 
37ae						inc hl      ; now at start of numeric as string 
37ae			 
37ae					;ld ix, hl 
37ae					call CON 
37ae			 
37ae					push hl 
37ae			 
37ae			 
37ae						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37ae			 
37ae						; TODO do add 
37ae			 
37ae						call IADD 
37ae			 
37ae						; TODO get result back as ascii 
37ae			 
37ae						; TODO push result  
37ae			 
37ae			 
37ae			 
37ae						jr .dot_done 
37ae				endif 
37ae			 
37ae			.dot_inum: 
37ae			 
37ae			 
37ae					if DEBUG_FORTH_DOT 
37ae						DMARK "+IT" 
37ae				CALLMONITOR 
37ae					endif 
37ae			 
37ae					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37ae cd 73 1e			call macro_dsp_valuehl 
37b1				endm 
# End of macro FORTH_DSP_VALUEHL
37b1			 
37b1				; TODO add floating point number detection 
37b1			 
37b1 e5					push hl 
37b2			 
37b2					; destroy value TOS 
37b2			 
37b2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37b2 cd 2b 1f			call macro_forth_dsp_pop 
37b5				endm 
# End of macro FORTH_DSP_POP
37b5			 
37b5			 
37b5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37b5 cd 73 1e			call macro_dsp_valuehl 
37b8				endm 
# End of macro FORTH_DSP_VALUEHL
37b8			 
37b8					; one value on hl get other one back 
37b8			 
37b8 d1					pop de 
37b9			 
37b9					; do the add 
37b9			 
37b9 19					add hl,de 
37ba			 
37ba					; save it 
37ba			 
37ba			;		push hl	 
37ba			 
37ba					; 
37ba			 
37ba					; destroy value TOS 
37ba			 
37ba					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37ba cd 2b 1f			call macro_forth_dsp_pop 
37bd				endm 
# End of macro FORTH_DSP_POP
37bd			 
37bd					; TODO push value back onto stack for another op etc 
37bd			 
37bd			;		pop hl 
37bd			 
37bd			.dot_done: 
37bd cd 7c 1c				call forth_push_numhl 
37c0			 
37c0					NEXTW 
37c0 c3 e5 1f			jp macro_next 
37c3				endm 
# End of macro NEXTW
37c3			.NEG: 
37c3			 
37c3				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
37c3 17				db WORD_SYS_CORE+3             
37c4 06 38			dw .DIV            
37c6 02				db 1 + 1 
37c7 .. 00			db "-",0              
37c9				endm 
# End of macro CWHEAD
37c9			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
37c9					if DEBUG_FORTH_WORDS_KEY 
37c9						DMARK "SUB" 
37c9 f5				push af  
37ca 3a de 37			ld a, (.dmark)  
37cd 32 bd fb			ld (debug_mark),a  
37d0 3a df 37			ld a, (.dmark+1)  
37d3 32 be fb			ld (debug_mark+1),a  
37d6 3a e0 37			ld a, (.dmark+2)  
37d9 32 bf fb			ld (debug_mark+2),a  
37dc 18 03			jr .pastdmark  
37de ..			.dmark: db "SUB"  
37e1 f1			.pastdmark: pop af  
37e2			endm  
# End of macro DMARK
37e2						CALLMONITOR 
37e2 cd ec 16			call break_point_state  
37e5				endm  
# End of macro CALLMONITOR
37e5					endif 
37e5			 
37e5			 
37e5				; TODO add floating point number detection 
37e5					; v5 FORTH_DSP_VALUE 
37e5					FORTH_DSP 
37e5 cd 39 1e			call macro_forth_dsp 
37e8				endm 
# End of macro FORTH_DSP
37e8 7e					ld a,(hl)	; get type of value on TOS 
37e9 fe 02				cp DS_TYPE_INUM  
37eb 28 03				jr z, .neg_inum 
37ed			 
37ed					NEXTW 
37ed c3 e5 1f			jp macro_next 
37f0				endm 
# End of macro NEXTW
37f0			 
37f0			; float maths 
37f0			 
37f0				if FORTH_ENABLE_FLOATMATH 
37f0					jr .neg_done 
37f0			 
37f0				endif 
37f0					 
37f0			 
37f0			.neg_inum: 
37f0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37f0 cd 73 1e			call macro_dsp_valuehl 
37f3				endm 
# End of macro FORTH_DSP_VALUEHL
37f3			 
37f3 e5					push hl 
37f4			 
37f4					; destroy value TOS 
37f4			 
37f4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37f4 cd 2b 1f			call macro_forth_dsp_pop 
37f7				endm 
# End of macro FORTH_DSP_POP
37f7			 
37f7			 
37f7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37f7 cd 73 1e			call macro_dsp_valuehl 
37fa				endm 
# End of macro FORTH_DSP_VALUEHL
37fa			 
37fa					; one value on hl get other one back 
37fa			 
37fa d1					pop de 
37fb			 
37fb					; do the sub 
37fb			;		ex de, hl 
37fb			 
37fb ed 52				sbc hl,de 
37fd			 
37fd					; save it 
37fd			 
37fd			;		push hl	 
37fd			 
37fd					; 
37fd			 
37fd					; destroy value TOS 
37fd			 
37fd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37fd cd 2b 1f			call macro_forth_dsp_pop 
3800				endm 
# End of macro FORTH_DSP_POP
3800			 
3800					; TODO push value back onto stack for another op etc 
3800			 
3800			;		pop hl 
3800			 
3800 cd 7c 1c				call forth_push_numhl 
3803			.neg_done: 
3803			 
3803					NEXTW 
3803 c3 e5 1f			jp macro_next 
3806				endm 
# End of macro NEXTW
3806			.DIV: 
3806				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3806 18				db WORD_SYS_CORE+4             
3807 53 38			dw .MUL            
3809 02				db 1 + 1 
380a .. 00			db "/",0              
380c				endm 
# End of macro CWHEAD
380c			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
380c					if DEBUG_FORTH_WORDS_KEY 
380c						DMARK "DIV" 
380c f5				push af  
380d 3a 21 38			ld a, (.dmark)  
3810 32 bd fb			ld (debug_mark),a  
3813 3a 22 38			ld a, (.dmark+1)  
3816 32 be fb			ld (debug_mark+1),a  
3819 3a 23 38			ld a, (.dmark+2)  
381c 32 bf fb			ld (debug_mark+2),a  
381f 18 03			jr .pastdmark  
3821 ..			.dmark: db "DIV"  
3824 f1			.pastdmark: pop af  
3825			endm  
# End of macro DMARK
3825						CALLMONITOR 
3825 cd ec 16			call break_point_state  
3828				endm  
# End of macro CALLMONITOR
3828					endif 
3828				; TODO add floating point number detection 
3828					; v5 FORTH_DSP_VALUE 
3828					FORTH_DSP 
3828 cd 39 1e			call macro_forth_dsp 
382b				endm 
# End of macro FORTH_DSP
382b 7e					ld a,(hl)	; get type of value on TOS 
382c fe 02				cp DS_TYPE_INUM  
382e 28 03				jr z, .div_inum 
3830			 
3830				if FORTH_ENABLE_FLOATMATH 
3830					jr .div_done 
3830			 
3830				endif 
3830					NEXTW 
3830 c3 e5 1f			jp macro_next 
3833				endm 
# End of macro NEXTW
3833			.div_inum: 
3833			 
3833					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3833 cd 73 1e			call macro_dsp_valuehl 
3836				endm 
# End of macro FORTH_DSP_VALUEHL
3836			 
3836 e5					push hl    ; to go to bc 
3837			 
3837					; destroy value TOS 
3837			 
3837					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3837 cd 2b 1f			call macro_forth_dsp_pop 
383a				endm 
# End of macro FORTH_DSP_POP
383a			 
383a			 
383a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
383a cd 73 1e			call macro_dsp_valuehl 
383d				endm 
# End of macro FORTH_DSP_VALUEHL
383d			 
383d					; hl to go to de 
383d			 
383d e5					push hl 
383e			 
383e c1					pop bc 
383f d1					pop de		 
3840			 
3840			 
3840					if DEBUG_FORTH_MATHS 
3840						DMARK "DIV" 
3840				CALLMONITOR 
3840					endif 
3840					; one value on hl but move to a get other one back 
3840			 
3840			        
3840 cd 63 0c			call Div16 
3843			 
3843			;	push af	 
3843 e5				push hl 
3844 c5				push bc 
3845			 
3845					if DEBUG_FORTH_MATHS 
3845						DMARK "DI1" 
3845				CALLMONITOR 
3845					endif 
3845			 
3845					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3845 cd 2b 1f			call macro_forth_dsp_pop 
3848				endm 
# End of macro FORTH_DSP_POP
3848			 
3848			 
3848			 
3848 e1					pop hl    ; result 
3849			 
3849 cd 7c 1c				call forth_push_numhl 
384c			 
384c e1					pop hl    ; reminder 
384d			;		ld h,0 
384d			;		ld l,d 
384d			 
384d cd 7c 1c				call forth_push_numhl 
3850			.div_done: 
3850					NEXTW 
3850 c3 e5 1f			jp macro_next 
3853				endm 
# End of macro NEXTW
3853			.MUL: 
3853				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3853 19				db WORD_SYS_CORE+5             
3854 98 38			dw .MIN            
3856 02				db 1 + 1 
3857 .. 00			db "*",0              
3859				endm 
# End of macro CWHEAD
3859			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3859				; TODO add floating point number detection 
3859					if DEBUG_FORTH_WORDS_KEY 
3859						DMARK "MUL" 
3859 f5				push af  
385a 3a 6e 38			ld a, (.dmark)  
385d 32 bd fb			ld (debug_mark),a  
3860 3a 6f 38			ld a, (.dmark+1)  
3863 32 be fb			ld (debug_mark+1),a  
3866 3a 70 38			ld a, (.dmark+2)  
3869 32 bf fb			ld (debug_mark+2),a  
386c 18 03			jr .pastdmark  
386e ..			.dmark: db "MUL"  
3871 f1			.pastdmark: pop af  
3872			endm  
# End of macro DMARK
3872						CALLMONITOR 
3872 cd ec 16			call break_point_state  
3875				endm  
# End of macro CALLMONITOR
3875					endif 
3875					FORTH_DSP 
3875 cd 39 1e			call macro_forth_dsp 
3878				endm 
# End of macro FORTH_DSP
3878					; v5 FORTH_DSP_VALUE 
3878 7e					ld a,(hl)	; get type of value on TOS 
3879 fe 02				cp DS_TYPE_INUM  
387b 28 03				jr z, .mul_inum 
387d			 
387d				if FORTH_ENABLE_FLOATMATH 
387d					jr .mul_done 
387d			 
387d				endif 
387d			 
387d					NEXTW 
387d c3 e5 1f			jp macro_next 
3880				endm 
# End of macro NEXTW
3880			.mul_inum:	 
3880			 
3880					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3880 cd 73 1e			call macro_dsp_valuehl 
3883				endm 
# End of macro FORTH_DSP_VALUEHL
3883			 
3883 e5					push hl 
3884			 
3884					; destroy value TOS 
3884			 
3884					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3884 cd 2b 1f			call macro_forth_dsp_pop 
3887				endm 
# End of macro FORTH_DSP_POP
3887			 
3887			 
3887					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3887 cd 73 1e			call macro_dsp_valuehl 
388a				endm 
# End of macro FORTH_DSP_VALUEHL
388a			 
388a					; one value on hl but move to a get other one back 
388a			 
388a 7d					ld a, l 
388b			 
388b d1					pop de 
388c			 
388c					; do the mull 
388c			;		ex de, hl 
388c			 
388c cd 89 0c				call Mult16 
388f					; save it 
388f			 
388f			;		push hl	 
388f			 
388f					; 
388f			 
388f					; destroy value TOS 
388f			 
388f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
388f cd 2b 1f			call macro_forth_dsp_pop 
3892				endm 
# End of macro FORTH_DSP_POP
3892			 
3892					; TODO push value back onto stack for another op etc 
3892			 
3892			;		pop hl 
3892			 
3892 cd 7c 1c				call forth_push_numhl 
3895			 
3895			.mul_done: 
3895					NEXTW 
3895 c3 e5 1f			jp macro_next 
3898				endm 
# End of macro NEXTW
3898			 
3898			 
3898			 
3898			 
3898			.MIN: 
3898				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3898 49				db WORD_SYS_CORE+53             
3899 19 39			dw .MAX            
389b 04				db 3 + 1 
389c .. 00			db "MIN",0              
38a0				endm 
# End of macro CWHEAD
38a0			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
38a0					if DEBUG_FORTH_WORDS_KEY 
38a0						DMARK "MIN" 
38a0 f5				push af  
38a1 3a b5 38			ld a, (.dmark)  
38a4 32 bd fb			ld (debug_mark),a  
38a7 3a b6 38			ld a, (.dmark+1)  
38aa 32 be fb			ld (debug_mark+1),a  
38ad 3a b7 38			ld a, (.dmark+2)  
38b0 32 bf fb			ld (debug_mark+2),a  
38b3 18 03			jr .pastdmark  
38b5 ..			.dmark: db "MIN"  
38b8 f1			.pastdmark: pop af  
38b9			endm  
# End of macro DMARK
38b9						CALLMONITOR 
38b9 cd ec 16			call break_point_state  
38bc				endm  
# End of macro CALLMONITOR
38bc					endif 
38bc					; get u2 
38bc			 
38bc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38bc cd 73 1e			call macro_dsp_valuehl 
38bf				endm 
# End of macro FORTH_DSP_VALUEHL
38bf			 
38bf e5					push hl   ; u2 
38c0			 
38c0					; destroy value TOS 
38c0			 
38c0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38c0 cd 2b 1f			call macro_forth_dsp_pop 
38c3				endm 
# End of macro FORTH_DSP_POP
38c3			 
38c3					; get u1 
38c3			 
38c3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38c3 cd 73 1e			call macro_dsp_valuehl 
38c6				endm 
# End of macro FORTH_DSP_VALUEHL
38c6			 
38c6 e5					push hl  ; u1 
38c7			 
38c7					; destroy value TOS 
38c7			 
38c7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38c7 cd 2b 1f			call macro_forth_dsp_pop 
38ca				endm 
# End of macro FORTH_DSP_POP
38ca			 
38ca b7			 or a      ;clear carry flag 
38cb e1			  pop hl    ; u1 
38cc d1			  pop de    ; u2 
38cd e5				push hl   ; saved in case hl is lowest 
38ce ed 52		  sbc hl,de 
38d0 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
38d2			 
38d2 e1				pop hl 
38d3					if DEBUG_FORTH_WORDS 
38d3						DMARK "MIN" 
38d3 f5				push af  
38d4 3a e8 38			ld a, (.dmark)  
38d7 32 bd fb			ld (debug_mark),a  
38da 3a e9 38			ld a, (.dmark+1)  
38dd 32 be fb			ld (debug_mark+1),a  
38e0 3a ea 38			ld a, (.dmark+2)  
38e3 32 bf fb			ld (debug_mark+2),a  
38e6 18 03			jr .pastdmark  
38e8 ..			.dmark: db "MIN"  
38eb f1			.pastdmark: pop af  
38ec			endm  
# End of macro DMARK
38ec						CALLMONITOR 
38ec cd ec 16			call break_point_state  
38ef				endm  
# End of macro CALLMONITOR
38ef					endif 
38ef cd 7c 1c				call forth_push_numhl 
38f2			 
38f2				       NEXTW 
38f2 c3 e5 1f			jp macro_next 
38f5				endm 
# End of macro NEXTW
38f5			 
38f5			.mincont:  
38f5 c1				pop bc   ; tidy up 
38f6 eb				ex de , hl  
38f7					if DEBUG_FORTH_WORDS 
38f7						DMARK "MI1" 
38f7 f5				push af  
38f8 3a 0c 39			ld a, (.dmark)  
38fb 32 bd fb			ld (debug_mark),a  
38fe 3a 0d 39			ld a, (.dmark+1)  
3901 32 be fb			ld (debug_mark+1),a  
3904 3a 0e 39			ld a, (.dmark+2)  
3907 32 bf fb			ld (debug_mark+2),a  
390a 18 03			jr .pastdmark  
390c ..			.dmark: db "MI1"  
390f f1			.pastdmark: pop af  
3910			endm  
# End of macro DMARK
3910						CALLMONITOR 
3910 cd ec 16			call break_point_state  
3913				endm  
# End of macro CALLMONITOR
3913					endif 
3913 cd 7c 1c				call forth_push_numhl 
3916			 
3916				       NEXTW 
3916 c3 e5 1f			jp macro_next 
3919				endm 
# End of macro NEXTW
3919			.MAX: 
3919				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3919 4a				db WORD_SYS_CORE+54             
391a 9a 39			dw .RND16            
391c 04				db 3 + 1 
391d .. 00			db "MAX",0              
3921				endm 
# End of macro CWHEAD
3921			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3921					if DEBUG_FORTH_WORDS_KEY 
3921						DMARK "MAX" 
3921 f5				push af  
3922 3a 36 39			ld a, (.dmark)  
3925 32 bd fb			ld (debug_mark),a  
3928 3a 37 39			ld a, (.dmark+1)  
392b 32 be fb			ld (debug_mark+1),a  
392e 3a 38 39			ld a, (.dmark+2)  
3931 32 bf fb			ld (debug_mark+2),a  
3934 18 03			jr .pastdmark  
3936 ..			.dmark: db "MAX"  
3939 f1			.pastdmark: pop af  
393a			endm  
# End of macro DMARK
393a						CALLMONITOR 
393a cd ec 16			call break_point_state  
393d				endm  
# End of macro CALLMONITOR
393d					endif 
393d					; get u2 
393d			 
393d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
393d cd 73 1e			call macro_dsp_valuehl 
3940				endm 
# End of macro FORTH_DSP_VALUEHL
3940			 
3940 e5					push hl   ; u2 
3941			 
3941					; destroy value TOS 
3941			 
3941					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3941 cd 2b 1f			call macro_forth_dsp_pop 
3944				endm 
# End of macro FORTH_DSP_POP
3944			 
3944					; get u1 
3944			 
3944					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3944 cd 73 1e			call macro_dsp_valuehl 
3947				endm 
# End of macro FORTH_DSP_VALUEHL
3947			 
3947 e5					push hl  ; u1 
3948			 
3948					; destroy value TOS 
3948			 
3948					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3948 cd 2b 1f			call macro_forth_dsp_pop 
394b				endm 
# End of macro FORTH_DSP_POP
394b			 
394b b7			 or a      ;clear carry flag 
394c e1			  pop hl    ; u1 
394d d1			  pop de    ; u2 
394e e5				push hl   ; saved in case hl is lowest 
394f ed 52		  sbc hl,de 
3951 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3953			 
3953 e1				pop hl 
3954					if DEBUG_FORTH_WORDS 
3954						DMARK "MAX" 
3954 f5				push af  
3955 3a 69 39			ld a, (.dmark)  
3958 32 bd fb			ld (debug_mark),a  
395b 3a 6a 39			ld a, (.dmark+1)  
395e 32 be fb			ld (debug_mark+1),a  
3961 3a 6b 39			ld a, (.dmark+2)  
3964 32 bf fb			ld (debug_mark+2),a  
3967 18 03			jr .pastdmark  
3969 ..			.dmark: db "MAX"  
396c f1			.pastdmark: pop af  
396d			endm  
# End of macro DMARK
396d						CALLMONITOR 
396d cd ec 16			call break_point_state  
3970				endm  
# End of macro CALLMONITOR
3970					endif 
3970 cd 7c 1c				call forth_push_numhl 
3973			 
3973				       NEXTW 
3973 c3 e5 1f			jp macro_next 
3976				endm 
# End of macro NEXTW
3976			 
3976			.maxcont:  
3976 c1				pop bc   ; tidy up 
3977 eb				ex de , hl  
3978					if DEBUG_FORTH_WORDS 
3978						DMARK "MA1" 
3978 f5				push af  
3979 3a 8d 39			ld a, (.dmark)  
397c 32 bd fb			ld (debug_mark),a  
397f 3a 8e 39			ld a, (.dmark+1)  
3982 32 be fb			ld (debug_mark+1),a  
3985 3a 8f 39			ld a, (.dmark+2)  
3988 32 bf fb			ld (debug_mark+2),a  
398b 18 03			jr .pastdmark  
398d ..			.dmark: db "MA1"  
3990 f1			.pastdmark: pop af  
3991			endm  
# End of macro DMARK
3991						CALLMONITOR 
3991 cd ec 16			call break_point_state  
3994				endm  
# End of macro CALLMONITOR
3994					endif 
3994 cd 7c 1c				call forth_push_numhl 
3997				       NEXTW 
3997 c3 e5 1f			jp macro_next 
399a				endm 
# End of macro NEXTW
399a			 
399a			.RND16: 
399a				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
399a 4e				db WORD_SYS_CORE+58             
399b c9 39			dw .RND8            
399d 06				db 5 + 1 
399e .. 00			db "RND16",0              
39a4				endm 
# End of macro CWHEAD
39a4			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
39a4					if DEBUG_FORTH_WORDS_KEY 
39a4						DMARK "R16" 
39a4 f5				push af  
39a5 3a b9 39			ld a, (.dmark)  
39a8 32 bd fb			ld (debug_mark),a  
39ab 3a ba 39			ld a, (.dmark+1)  
39ae 32 be fb			ld (debug_mark+1),a  
39b1 3a bb 39			ld a, (.dmark+2)  
39b4 32 bf fb			ld (debug_mark+2),a  
39b7 18 03			jr .pastdmark  
39b9 ..			.dmark: db "R16"  
39bc f1			.pastdmark: pop af  
39bd			endm  
# End of macro DMARK
39bd						CALLMONITOR 
39bd cd ec 16			call break_point_state  
39c0				endm  
# End of macro CALLMONITOR
39c0					endif 
39c0 cd 2d 0c				call prng16  
39c3 cd 7c 1c				call forth_push_numhl 
39c6				       NEXTW 
39c6 c3 e5 1f			jp macro_next 
39c9				endm 
# End of macro NEXTW
39c9			.RND8: 
39c9				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
39c9 60				db WORD_SYS_CORE+76             
39ca fe 39			dw .RND            
39cc 05				db 4 + 1 
39cd .. 00			db "RND8",0              
39d2				endm 
# End of macro CWHEAD
39d2			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
39d2					if DEBUG_FORTH_WORDS_KEY 
39d2						DMARK "RN8" 
39d2 f5				push af  
39d3 3a e7 39			ld a, (.dmark)  
39d6 32 bd fb			ld (debug_mark),a  
39d9 3a e8 39			ld a, (.dmark+1)  
39dc 32 be fb			ld (debug_mark+1),a  
39df 3a e9 39			ld a, (.dmark+2)  
39e2 32 bf fb			ld (debug_mark+2),a  
39e5 18 03			jr .pastdmark  
39e7 ..			.dmark: db "RN8"  
39ea f1			.pastdmark: pop af  
39eb			endm  
# End of macro DMARK
39eb						CALLMONITOR 
39eb cd ec 16			call break_point_state  
39ee				endm  
# End of macro CALLMONITOR
39ee					endif 
39ee 2a 3e fa				ld hl,(xrandc) 
39f1 23					inc hl 
39f2 cd 47 0c				call xrnd 
39f5 6f					ld l,a	 
39f6 26 00				ld h,0 
39f8 cd 7c 1c				call forth_push_numhl 
39fb				       NEXTW 
39fb c3 e5 1f			jp macro_next 
39fe				endm 
# End of macro NEXTW
39fe			.RND: 
39fe				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
39fe 60				db WORD_SYS_CORE+76             
39ff 04 3b			dw .ENDMATHS            
3a01 04				db 3 + 1 
3a02 .. 00			db "RND",0              
3a06				endm 
# End of macro CWHEAD
3a06			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3a06			 
3a06					if DEBUG_FORTH_WORDS_KEY 
3a06						DMARK "RND" 
3a06 f5				push af  
3a07 3a 1b 3a			ld a, (.dmark)  
3a0a 32 bd fb			ld (debug_mark),a  
3a0d 3a 1c 3a			ld a, (.dmark+1)  
3a10 32 be fb			ld (debug_mark+1),a  
3a13 3a 1d 3a			ld a, (.dmark+2)  
3a16 32 bf fb			ld (debug_mark+2),a  
3a19 18 03			jr .pastdmark  
3a1b ..			.dmark: db "RND"  
3a1e f1			.pastdmark: pop af  
3a1f			endm  
# End of macro DMARK
3a1f						CALLMONITOR 
3a1f cd ec 16			call break_point_state  
3a22				endm  
# End of macro CALLMONITOR
3a22					endif 
3a22					 
3a22					FORTH_DSP_VALUEHL    ; upper range 
3a22 cd 73 1e			call macro_dsp_valuehl 
3a25				endm 
# End of macro FORTH_DSP_VALUEHL
3a25			 
3a25 22 42 fa				ld (LFSRSeed), hl	 
3a28			 
3a28					if DEBUG_FORTH_WORDS 
3a28						DMARK "RN1" 
3a28 f5				push af  
3a29 3a 3d 3a			ld a, (.dmark)  
3a2c 32 bd fb			ld (debug_mark),a  
3a2f 3a 3e 3a			ld a, (.dmark+1)  
3a32 32 be fb			ld (debug_mark+1),a  
3a35 3a 3f 3a			ld a, (.dmark+2)  
3a38 32 bf fb			ld (debug_mark+2),a  
3a3b 18 03			jr .pastdmark  
3a3d ..			.dmark: db "RN1"  
3a40 f1			.pastdmark: pop af  
3a41			endm  
# End of macro DMARK
3a41						CALLMONITOR 
3a41 cd ec 16			call break_point_state  
3a44				endm  
# End of macro CALLMONITOR
3a44					endif 
3a44					FORTH_DSP_POP 
3a44 cd 2b 1f			call macro_forth_dsp_pop 
3a47				endm 
# End of macro FORTH_DSP_POP
3a47			 
3a47					FORTH_DSP_VALUEHL    ; low range 
3a47 cd 73 1e			call macro_dsp_valuehl 
3a4a				endm 
# End of macro FORTH_DSP_VALUEHL
3a4a			 
3a4a					if DEBUG_FORTH_WORDS 
3a4a						DMARK "RN2" 
3a4a f5				push af  
3a4b 3a 5f 3a			ld a, (.dmark)  
3a4e 32 bd fb			ld (debug_mark),a  
3a51 3a 60 3a			ld a, (.dmark+1)  
3a54 32 be fb			ld (debug_mark+1),a  
3a57 3a 61 3a			ld a, (.dmark+2)  
3a5a 32 bf fb			ld (debug_mark+2),a  
3a5d 18 03			jr .pastdmark  
3a5f ..			.dmark: db "RN2"  
3a62 f1			.pastdmark: pop af  
3a63			endm  
# End of macro DMARK
3a63						CALLMONITOR 
3a63 cd ec 16			call break_point_state  
3a66				endm  
# End of macro CALLMONITOR
3a66					endif 
3a66 22 44 fa				ld (LFSRSeed+2), hl 
3a69			 
3a69					FORTH_DSP_POP 
3a69 cd 2b 1f			call macro_forth_dsp_pop 
3a6c				endm 
# End of macro FORTH_DSP_POP
3a6c			 
3a6c e5					push hl 
3a6d			 
3a6d e1			.inrange:	pop hl 
3a6e cd 2d 0c				call prng16  
3a71					if DEBUG_FORTH_WORDS 
3a71						DMARK "RN3" 
3a71 f5				push af  
3a72 3a 86 3a			ld a, (.dmark)  
3a75 32 bd fb			ld (debug_mark),a  
3a78 3a 87 3a			ld a, (.dmark+1)  
3a7b 32 be fb			ld (debug_mark+1),a  
3a7e 3a 88 3a			ld a, (.dmark+2)  
3a81 32 bf fb			ld (debug_mark+2),a  
3a84 18 03			jr .pastdmark  
3a86 ..			.dmark: db "RN3"  
3a89 f1			.pastdmark: pop af  
3a8a			endm  
# End of macro DMARK
3a8a						CALLMONITOR 
3a8a cd ec 16			call break_point_state  
3a8d				endm  
# End of macro CALLMONITOR
3a8d					endif 
3a8d					 
3a8d					; if the range is 8bit knock out the high byte 
3a8d			 
3a8d ed 5b 42 fa			ld de, (LFSRSeed)     ; check high level 
3a91			 
3a91 3e 00				ld a, 0 
3a93 ba					cp d  
3a94 20 1e				jr nz, .hirange 
3a96 26 00				ld h, 0   ; knock it down to 8bit 
3a98			 
3a98					if DEBUG_FORTH_WORDS 
3a98						DMARK "RNk" 
3a98 f5				push af  
3a99 3a ad 3a			ld a, (.dmark)  
3a9c 32 bd fb			ld (debug_mark),a  
3a9f 3a ae 3a			ld a, (.dmark+1)  
3aa2 32 be fb			ld (debug_mark+1),a  
3aa5 3a af 3a			ld a, (.dmark+2)  
3aa8 32 bf fb			ld (debug_mark+2),a  
3aab 18 03			jr .pastdmark  
3aad ..			.dmark: db "RNk"  
3ab0 f1			.pastdmark: pop af  
3ab1			endm  
# End of macro DMARK
3ab1						CALLMONITOR 
3ab1 cd ec 16			call break_point_state  
3ab4				endm  
# End of macro CALLMONITOR
3ab4					endif 
3ab4			.hirange:   
3ab4 e5					push hl  
3ab5 b7					or a  
3ab6 ed 52		                sbc hl, de 
3ab8			 
3ab8					;call cmp16 
3ab8			 
3ab8 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3aba e1					pop hl 
3abb e5					push hl 
3abc			 
3abc					if DEBUG_FORTH_WORDS 
3abc						DMARK "RN4" 
3abc f5				push af  
3abd 3a d1 3a			ld a, (.dmark)  
3ac0 32 bd fb			ld (debug_mark),a  
3ac3 3a d2 3a			ld a, (.dmark+1)  
3ac6 32 be fb			ld (debug_mark+1),a  
3ac9 3a d3 3a			ld a, (.dmark+2)  
3acc 32 bf fb			ld (debug_mark+2),a  
3acf 18 03			jr .pastdmark  
3ad1 ..			.dmark: db "RN4"  
3ad4 f1			.pastdmark: pop af  
3ad5			endm  
# End of macro DMARK
3ad5						CALLMONITOR 
3ad5 cd ec 16			call break_point_state  
3ad8				endm  
# End of macro CALLMONITOR
3ad8					endif 
3ad8 ed 5b 44 fa			ld de, (LFSRSeed+2)   ; check low range 
3adc					;call cmp16 
3adc				 
3adc b7					or a  
3add ed 52		                sbc hl, de 
3adf 38 8c				jr c, .inrange 
3ae1			 
3ae1 e1					pop hl 
3ae2					 
3ae2					if DEBUG_FORTH_WORDS 
3ae2						DMARK "RNd" 
3ae2 f5				push af  
3ae3 3a f7 3a			ld a, (.dmark)  
3ae6 32 bd fb			ld (debug_mark),a  
3ae9 3a f8 3a			ld a, (.dmark+1)  
3aec 32 be fb			ld (debug_mark+1),a  
3aef 3a f9 3a			ld a, (.dmark+2)  
3af2 32 bf fb			ld (debug_mark+2),a  
3af5 18 03			jr .pastdmark  
3af7 ..			.dmark: db "RNd"  
3afa f1			.pastdmark: pop af  
3afb			endm  
# End of macro DMARK
3afb						CALLMONITOR 
3afb cd ec 16			call break_point_state  
3afe				endm  
# End of macro CALLMONITOR
3afe					endif 
3afe			 
3afe			 
3afe cd 7c 1c				call forth_push_numhl 
3b01				       NEXTW 
3b01 c3 e5 1f			jp macro_next 
3b04				endm 
# End of macro NEXTW
3b04			 
3b04			.ENDMATHS: 
3b04			 
3b04			; eof 
3b04			 
# End of file forth_words_maths.asm
3b04			include "forth_words_display.asm" 
3b04			 
3b04			; | ## Display Words 
3b04			 
3b04			.ATP: 
3b04				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3b04 62				db WORD_SYS_CORE+78             
3b05 7b 3b			dw .FB            
3b07 04				db 3 + 1 
3b08 .. 00			db "AT?",0              
3b0c				endm 
# End of macro CWHEAD
3b0c			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3b0c					if DEBUG_FORTH_WORDS_KEY 
3b0c						DMARK "AT?" 
3b0c f5				push af  
3b0d 3a 21 3b			ld a, (.dmark)  
3b10 32 bd fb			ld (debug_mark),a  
3b13 3a 22 3b			ld a, (.dmark+1)  
3b16 32 be fb			ld (debug_mark+1),a  
3b19 3a 23 3b			ld a, (.dmark+2)  
3b1c 32 bf fb			ld (debug_mark+2),a  
3b1f 18 03			jr .pastdmark  
3b21 ..			.dmark: db "AT?"  
3b24 f1			.pastdmark: pop af  
3b25			endm  
# End of macro DMARK
3b25						CALLMONITOR 
3b25 cd ec 16			call break_point_state  
3b28				endm  
# End of macro CALLMONITOR
3b28					endif 
3b28 3a cc f9				ld a, (f_cursor_ptr) 
3b2b			 
3b2b			if DEBUG_FORTH_WORDS 
3b2b				DMARK "AT?" 
3b2b f5				push af  
3b2c 3a 40 3b			ld a, (.dmark)  
3b2f 32 bd fb			ld (debug_mark),a  
3b32 3a 41 3b			ld a, (.dmark+1)  
3b35 32 be fb			ld (debug_mark+1),a  
3b38 3a 42 3b			ld a, (.dmark+2)  
3b3b 32 bf fb			ld (debug_mark+2),a  
3b3e 18 03			jr .pastdmark  
3b40 ..			.dmark: db "AT?"  
3b43 f1			.pastdmark: pop af  
3b44			endm  
# End of macro DMARK
3b44				CALLMONITOR 
3b44 cd ec 16			call break_point_state  
3b47				endm  
# End of macro CALLMONITOR
3b47			endif	 
3b47					; count the number of rows 
3b47			 
3b47 06 00				ld b, 0 
3b49 4f			.atpr:		ld c, a    ; save in case we go below zero 
3b4a d6 14				sub display_cols 
3b4c f2 52 3b				jp p, .atprunder 
3b4f 04					inc b 
3b50 18 f7				jr .atpr 
3b52			.atprunder:	 
3b52			if DEBUG_FORTH_WORDS 
3b52				DMARK "A?2" 
3b52 f5				push af  
3b53 3a 67 3b			ld a, (.dmark)  
3b56 32 bd fb			ld (debug_mark),a  
3b59 3a 68 3b			ld a, (.dmark+1)  
3b5c 32 be fb			ld (debug_mark+1),a  
3b5f 3a 69 3b			ld a, (.dmark+2)  
3b62 32 bf fb			ld (debug_mark+2),a  
3b65 18 03			jr .pastdmark  
3b67 ..			.dmark: db "A?2"  
3b6a f1			.pastdmark: pop af  
3b6b			endm  
# End of macro DMARK
3b6b				CALLMONITOR 
3b6b cd ec 16			call break_point_state  
3b6e				endm  
# End of macro CALLMONITOR
3b6e			endif	 
3b6e 26 00				ld h, 0 
3b70 69					ld l, c 
3b71 cd 7c 1c				call forth_push_numhl 
3b74 68					ld l, b  
3b75 cd 7c 1c				call forth_push_numhl 
3b78			 
3b78			 
3b78				NEXTW 
3b78 c3 e5 1f			jp macro_next 
3b7b				endm 
# End of macro NEXTW
3b7b			 
3b7b			.FB: 
3b7b				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3b7b 1b				db WORD_SYS_CORE+7             
3b7c c9 3b			dw .EMIT            
3b7e 03				db 2 + 1 
3b7f .. 00			db "FB",0              
3b82				endm 
# End of macro CWHEAD
3b82			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3b82			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3b82			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3b82			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3b82					if DEBUG_FORTH_WORDS_KEY 
3b82						DMARK "FB." 
3b82 f5				push af  
3b83 3a 97 3b			ld a, (.dmark)  
3b86 32 bd fb			ld (debug_mark),a  
3b89 3a 98 3b			ld a, (.dmark+1)  
3b8c 32 be fb			ld (debug_mark+1),a  
3b8f 3a 99 3b			ld a, (.dmark+2)  
3b92 32 bf fb			ld (debug_mark+2),a  
3b95 18 03			jr .pastdmark  
3b97 ..			.dmark: db "FB."  
3b9a f1			.pastdmark: pop af  
3b9b			endm  
# End of macro DMARK
3b9b						CALLMONITOR 
3b9b cd ec 16			call break_point_state  
3b9e				endm  
# End of macro CALLMONITOR
3b9e					endif 
3b9e			 
3b9e					FORTH_DSP_VALUEHL 
3b9e cd 73 1e			call macro_dsp_valuehl 
3ba1				endm 
# End of macro FORTH_DSP_VALUEHL
3ba1			 
3ba1 7d					ld a, l 
3ba2 fe 01				cp 1 
3ba4 20 05				jr nz, .fbn1 
3ba6 21 02 fb				ld hl, display_fb1 
3ba9 18 15				jr .fbset 
3bab fe 02		.fbn1:		cp 2 
3bad 20 05				jr nz, .fbn2 
3baf 21 60 fa				ld hl, display_fb2 
3bb2 18 0c				jr .fbset 
3bb4 fe 03		.fbn2:		cp 3 
3bb6 20 05				jr nz, .fbn3 
3bb8 21 b1 fa				ld hl, display_fb3 
3bbb 18 03				jr .fbset 
3bbd			.fbn3:		 ; if invalid number select first 
3bbd 21 02 fb				ld hl, display_fb1 
3bc0 22 5e fa		.fbset:		ld (display_fb_active), hl 
3bc3			 
3bc3					FORTH_DSP_POP 
3bc3 cd 2b 1f			call macro_forth_dsp_pop 
3bc6				endm 
# End of macro FORTH_DSP_POP
3bc6			 
3bc6					NEXTW 
3bc6 c3 e5 1f			jp macro_next 
3bc9				endm 
# End of macro NEXTW
3bc9			 
3bc9			 
3bc9			.EMIT: 
3bc9				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3bc9 1b				db WORD_SYS_CORE+7             
3bca 1a 3c			dw .DOTH            
3bcc 05				db 4 + 1 
3bcd .. 00			db "EMIT",0              
3bd2				endm 
# End of macro CWHEAD
3bd2			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3bd2					; get value off TOS and display it 
3bd2			 
3bd2					if DEBUG_FORTH_WORDS_KEY 
3bd2						DMARK "EMT" 
3bd2 f5				push af  
3bd3 3a e7 3b			ld a, (.dmark)  
3bd6 32 bd fb			ld (debug_mark),a  
3bd9 3a e8 3b			ld a, (.dmark+1)  
3bdc 32 be fb			ld (debug_mark+1),a  
3bdf 3a e9 3b			ld a, (.dmark+2)  
3be2 32 bf fb			ld (debug_mark+2),a  
3be5 18 03			jr .pastdmark  
3be7 ..			.dmark: db "EMT"  
3bea f1			.pastdmark: pop af  
3beb			endm  
# End of macro DMARK
3beb						CALLMONITOR 
3beb cd ec 16			call break_point_state  
3bee				endm  
# End of macro CALLMONITOR
3bee					endif 
3bee			 
3bee					FORTH_DSP_VALUEHL 
3bee cd 73 1e			call macro_dsp_valuehl 
3bf1				endm 
# End of macro FORTH_DSP_VALUEHL
3bf1			 
3bf1 7d					ld a,l 
3bf2			 
3bf2					; TODO write to display 
3bf2			 
3bf2 32 a1 f1				ld (os_input), a 
3bf5 3e 00				ld a, 0 
3bf7 32 a2 f1				ld (os_input+1), a 
3bfa					 
3bfa 3a cc f9				ld a, (f_cursor_ptr) 
3bfd 11 a1 f1				ld de, os_input 
3c00 cd e5 0a				call str_at_display 
3c03			 
3c03			 
3c03 3a aa f9				ld a,(cli_autodisplay) 
3c06 fe 00				cp 0 
3c08 28 03				jr z, .enoupdate 
3c0a cd f5 0a						call update_display 
3c0d					.enoupdate: 
3c0d			 
3c0d 3a cc f9				ld a, (f_cursor_ptr) 
3c10 3c					inc a 
3c11 32 cc f9				ld (f_cursor_ptr), a   ; save new pos 
3c14			 
3c14			 
3c14					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c14 cd 2b 1f			call macro_forth_dsp_pop 
3c17				endm 
# End of macro FORTH_DSP_POP
3c17			  
3c17			 
3c17					NEXTW 
3c17 c3 e5 1f			jp macro_next 
3c1a				endm 
# End of macro NEXTW
3c1a			.DOTH: 
3c1a				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3c1a 1c				db WORD_SYS_CORE+8             
3c1b 4a 3c			dw .DOTF            
3c1d 03				db 2 + 1 
3c1e .. 00			db ".-",0              
3c21				endm 
# End of macro CWHEAD
3c21			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3c21					; get value off TOS and display it 
3c21					if DEBUG_FORTH_WORDS_KEY 
3c21						DMARK "DTD" 
3c21 f5				push af  
3c22 3a 36 3c			ld a, (.dmark)  
3c25 32 bd fb			ld (debug_mark),a  
3c28 3a 37 3c			ld a, (.dmark+1)  
3c2b 32 be fb			ld (debug_mark+1),a  
3c2e 3a 38 3c			ld a, (.dmark+2)  
3c31 32 bf fb			ld (debug_mark+2),a  
3c34 18 03			jr .pastdmark  
3c36 ..			.dmark: db "DTD"  
3c39 f1			.pastdmark: pop af  
3c3a			endm  
# End of macro DMARK
3c3a						CALLMONITOR 
3c3a cd ec 16			call break_point_state  
3c3d				endm  
# End of macro CALLMONITOR
3c3d					endif 
3c3d 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3c3f 3e 00			ld a, 0 
3c41 32 ab f9			ld (cli_mvdot), a 
3c44 c3 a1 3c			jp .dotgo 
3c47				NEXTW 
3c47 c3 e5 1f			jp macro_next 
3c4a				endm 
# End of macro NEXTW
3c4a			.DOTF: 
3c4a				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3c4a 1c				db WORD_SYS_CORE+8             
3c4b 78 3c			dw .DOT            
3c4d 03				db 2 + 1 
3c4e .. 00			db ".>",0              
3c51				endm 
# End of macro CWHEAD
3c51			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3c51					; get value off TOS and display it 
3c51			        ; TODO BUG adds extra spaces 
3c51			        ; TODO BUG handle numerics? 
3c51					if DEBUG_FORTH_WORDS_KEY 
3c51						DMARK "DTC" 
3c51 f5				push af  
3c52 3a 66 3c			ld a, (.dmark)  
3c55 32 bd fb			ld (debug_mark),a  
3c58 3a 67 3c			ld a, (.dmark+1)  
3c5b 32 be fb			ld (debug_mark+1),a  
3c5e 3a 68 3c			ld a, (.dmark+2)  
3c61 32 bf fb			ld (debug_mark+2),a  
3c64 18 03			jr .pastdmark  
3c66 ..			.dmark: db "DTC"  
3c69 f1			.pastdmark: pop af  
3c6a			endm  
# End of macro DMARK
3c6a						CALLMONITOR 
3c6a cd ec 16			call break_point_state  
3c6d				endm  
# End of macro CALLMONITOR
3c6d					endif 
3c6d 3e 01			ld a, 1 
3c6f 32 ab f9			ld (cli_mvdot), a 
3c72 c3 a1 3c			jp .dotgo 
3c75				NEXTW 
3c75 c3 e5 1f			jp macro_next 
3c78				endm 
# End of macro NEXTW
3c78			 
3c78			.DOT: 
3c78				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3c78 1c				db WORD_SYS_CORE+8             
3c79 04 3d			dw .CLS            
3c7b 02				db 1 + 1 
3c7c .. 00			db ".",0              
3c7e				endm 
# End of macro CWHEAD
3c7e			        ; | . ( u -- ) Display TOS | DONE 
3c7e					; get value off TOS and display it 
3c7e			 
3c7e					if DEBUG_FORTH_WORDS_KEY 
3c7e						DMARK "DOT" 
3c7e f5				push af  
3c7f 3a 93 3c			ld a, (.dmark)  
3c82 32 bd fb			ld (debug_mark),a  
3c85 3a 94 3c			ld a, (.dmark+1)  
3c88 32 be fb			ld (debug_mark+1),a  
3c8b 3a 95 3c			ld a, (.dmark+2)  
3c8e 32 bf fb			ld (debug_mark+2),a  
3c91 18 03			jr .pastdmark  
3c93 ..			.dmark: db "DOT"  
3c96 f1			.pastdmark: pop af  
3c97			endm  
# End of macro DMARK
3c97						CALLMONITOR 
3c97 cd ec 16			call break_point_state  
3c9a				endm  
# End of macro CALLMONITOR
3c9a					endif 
3c9a 3e 00			ld a, 0 
3c9c 32 ab f9			ld (cli_mvdot), a 
3c9f 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3ca1				 
3ca1			 
3ca1			.dotgo: 
3ca1			 
3ca1			; move up type to on stack for parserv5 
3ca1					FORTH_DSP 
3ca1 cd 39 1e			call macro_forth_dsp 
3ca4				endm 
# End of macro FORTH_DSP
3ca4				;FORTH_DSP_VALUE  
3ca4			 
3ca4			if DEBUG_FORTH_DOT 
3ca4				DMARK "DOT" 
3ca4				CALLMONITOR 
3ca4			endif	 
3ca4			;		.print: 
3ca4			 
3ca4 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3ca5 23				inc hl   ; position to the actual value 
3ca6 fe 01			cp DS_TYPE_STR 
3ca8 20 06			jr nz, .dotnum1  
3caa			 
3caa			; display string 
3caa				FORTH_DSP_VALUE  
3caa cd 5c 1e			call macro_forth_dsp_value 
3cad				endm 
# End of macro FORTH_DSP_VALUE
3cad eb				ex de,hl 
3cae 18 11			jr .dotwrite 
3cb0			 
3cb0			.dotnum1: 
3cb0 fe 02			cp DS_TYPE_INUM 
3cb2 20 0c			jr nz, .dotflot 
3cb4			 
3cb4			 
3cb4			; display number 
3cb4			 
3cb4			;	push hl 
3cb4			;	call clear_display 
3cb4			;	pop hl 
3cb4			 
3cb4 5e				ld e, (hl) 
3cb5 23				inc hl 
3cb6 56				ld d, (hl) 
3cb7 21 a3 ef			ld hl, scratch 
3cba			if DEBUG_FORTH_DOT 
3cba				DMARK "DT1" 
3cba				CALLMONITOR 
3cba			endif	 
3cba			 
3cba cd 13 11			call uitoa_16 
3cbd eb				ex de,hl 
3cbe			 
3cbe			if DEBUG_FORTH_DOT 
3cbe				DMARK "DT2" 
3cbe				CALLMONITOR 
3cbe			endif	 
3cbe			 
3cbe			;	ld de, os_word_scratch 
3cbe 18 01			jr .dotwrite 
3cc0			 
3cc0 00			.dotflot:   nop 
3cc1			; TODO print floating point number 
3cc1			 
3cc1			.dotwrite:		 
3cc1			 
3cc1					; if c is set then set all '-' to spaces 
3cc1					; need to also take into account .>  
3cc1			 
3cc1 3e 01				ld a, 1 
3cc3 b9					cp c 
3cc4 20 13				jr nz, .nodashswap 
3cc6			 
3cc6					; DE has the string to write, working with HL 
3cc6			 
3cc6 06 ff				ld b, 255 
3cc8 d5					push de 
3cc9 e1					pop hl 
3cca			 
3cca			if DEBUG_FORTH_DOT 
3cca				DMARK "DT-" 
3cca				CALLMONITOR 
3cca			endif	 
3cca 7e			.dashscan:	ld a, (hl) 
3ccb fe 00				cp 0 
3ccd 28 0a				jr z, .nodashswap 
3ccf fe 2d				cp '-' 
3cd1 20 03				jr nz, .dashskip 
3cd3 3e 20				ld a, ' ' 
3cd5 77					ld (hl), a 
3cd6 23			.dashskip:	inc hl 
3cd7			if DEBUG_FORTH_DOT 
3cd7				DMARK "D-2" 
3cd7				CALLMONITOR 
3cd7			endif	 
3cd7 10 f1				djnz .dashscan 
3cd9			 
3cd9			if DEBUG_FORTH_DOT 
3cd9				DMARK "D-1" 
3cd9				CALLMONITOR 
3cd9			endif	 
3cd9			 
3cd9			.nodashswap: 
3cd9			 
3cd9 e5					push hl   ; save string start in case we need to advance print 
3cda			 
3cda 3a cc f9				ld a, (f_cursor_ptr) 
3cdd cd e5 0a				call str_at_display 
3ce0 3a aa f9				ld a,(cli_autodisplay) 
3ce3 fe 00				cp 0 
3ce5 28 03				jr z, .noupdate 
3ce7 cd f5 0a						call update_display 
3cea					.noupdate: 
3cea			 
3cea			 
3cea					; see if we need to advance the print position 
3cea			 
3cea e1					pop hl   ; get back string 
3ceb			 
3ceb 3a ab f9				ld a, (cli_mvdot) 
3cee			if DEBUG_FORTH_DOT 
3cee					ld e,a 
3cee				DMARK "D>1" 
3cee				CALLMONITOR 
3cee			endif	 
3cee fe 00				cp 0 
3cf0 28 0c				jr z, .noadv 
3cf2					; yes, lets advance the print position 
3cf2 3e 00				ld a, 0 
3cf4 cd 6f 11				call strlent 
3cf7 3a cc f9				ld a, (f_cursor_ptr) 
3cfa 85					add a,l 
3cfb					;call addatohl 
3cfb					;ld a, l 
3cfb 32 cc f9				ld (f_cursor_ptr), a   ; save new pos 
3cfe			 
3cfe			if DEBUG_FORTH_DOT 
3cfe				DMARK "D->" 
3cfe				CALLMONITOR 
3cfe			endif	 
3cfe			 
3cfe			.noadv:	 
3cfe			 
3cfe					if DEBUG_FORTH_DOT_WAIT 
3cfe							call next_page_prompt 
3cfe					endif	 
3cfe			; TODO this pop off the stack causes a crash. i dont know why 
3cfe			 
3cfe			 
3cfe			if DEBUG_FORTH_DOT 
3cfe				DMARK "DTh" 
3cfe				CALLMONITOR 
3cfe			endif	 
3cfe			 
3cfe					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cfe cd 2b 1f			call macro_forth_dsp_pop 
3d01				endm 
# End of macro FORTH_DSP_POP
3d01			 
3d01			if DEBUG_FORTH_DOT 
3d01				DMARK "DTi" 
3d01				CALLMONITOR 
3d01			endif	 
3d01			 
3d01			 
3d01					NEXTW 
3d01 c3 e5 1f			jp macro_next 
3d04				endm 
# End of macro NEXTW
3d04			 
3d04			.CLS: 
3d04				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3d04 35				db WORD_SYS_CORE+33             
3d05 31 3d			dw .DRAW            
3d07 04				db 3 + 1 
3d08 .. 00			db "CLS",0              
3d0c				endm 
# End of macro CWHEAD
3d0c			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3d0c					if DEBUG_FORTH_WORDS_KEY 
3d0c						DMARK "CLS" 
3d0c f5				push af  
3d0d 3a 21 3d			ld a, (.dmark)  
3d10 32 bd fb			ld (debug_mark),a  
3d13 3a 22 3d			ld a, (.dmark+1)  
3d16 32 be fb			ld (debug_mark+1),a  
3d19 3a 23 3d			ld a, (.dmark+2)  
3d1c 32 bf fb			ld (debug_mark+2),a  
3d1f 18 03			jr .pastdmark  
3d21 ..			.dmark: db "CLS"  
3d24 f1			.pastdmark: pop af  
3d25			endm  
# End of macro DMARK
3d25						CALLMONITOR 
3d25 cd ec 16			call break_point_state  
3d28				endm  
# End of macro CALLMONITOR
3d28					endif 
3d28 cd d2 0a				call clear_display 
3d2b c3 3f 3e				jp .home		; and home cursor 
3d2e					NEXTW 
3d2e c3 e5 1f			jp macro_next 
3d31				endm 
# End of macro NEXTW
3d31			 
3d31			.DRAW: 
3d31				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3d31 36				db WORD_SYS_CORE+34             
3d32 5c 3d			dw .DUMP            
3d34 05				db 4 + 1 
3d35 .. 00			db "DRAW",0              
3d3a				endm 
# End of macro CWHEAD
3d3a			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3d3a					if DEBUG_FORTH_WORDS_KEY 
3d3a						DMARK "DRW" 
3d3a f5				push af  
3d3b 3a 4f 3d			ld a, (.dmark)  
3d3e 32 bd fb			ld (debug_mark),a  
3d41 3a 50 3d			ld a, (.dmark+1)  
3d44 32 be fb			ld (debug_mark+1),a  
3d47 3a 51 3d			ld a, (.dmark+2)  
3d4a 32 bf fb			ld (debug_mark+2),a  
3d4d 18 03			jr .pastdmark  
3d4f ..			.dmark: db "DRW"  
3d52 f1			.pastdmark: pop af  
3d53			endm  
# End of macro DMARK
3d53						CALLMONITOR 
3d53 cd ec 16			call break_point_state  
3d56				endm  
# End of macro CALLMONITOR
3d56					endif 
3d56 cd f5 0a				call update_display 
3d59					NEXTW 
3d59 c3 e5 1f			jp macro_next 
3d5c				endm 
# End of macro NEXTW
3d5c			 
3d5c			.DUMP: 
3d5c				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3d5c 37				db WORD_SYS_CORE+35             
3d5d 94 3d			dw .CDUMP            
3d5f 05				db 4 + 1 
3d60 .. 00			db "DUMP",0              
3d65				endm 
# End of macro CWHEAD
3d65			; | DUMP ( x -- ) With address x display dump   | DONE 
3d65			; TODO pop address to use off of the stack 
3d65					if DEBUG_FORTH_WORDS_KEY 
3d65						DMARK "DUM" 
3d65 f5				push af  
3d66 3a 7a 3d			ld a, (.dmark)  
3d69 32 bd fb			ld (debug_mark),a  
3d6c 3a 7b 3d			ld a, (.dmark+1)  
3d6f 32 be fb			ld (debug_mark+1),a  
3d72 3a 7c 3d			ld a, (.dmark+2)  
3d75 32 bf fb			ld (debug_mark+2),a  
3d78 18 03			jr .pastdmark  
3d7a ..			.dmark: db "DUM"  
3d7d f1			.pastdmark: pop af  
3d7e			endm  
# End of macro DMARK
3d7e						CALLMONITOR 
3d7e cd ec 16			call break_point_state  
3d81				endm  
# End of macro CALLMONITOR
3d81					endif 
3d81 cd d2 0a				call clear_display 
3d84			 
3d84					; get address 
3d84			 
3d84					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d84 cd 73 1e			call macro_dsp_valuehl 
3d87				endm 
# End of macro FORTH_DSP_VALUEHL
3d87				 
3d87					; save it for cdump 
3d87			 
3d87 22 c6 f2				ld (os_cur_ptr),hl 
3d8a			 
3d8a					; destroy value TOS 
3d8a			 
3d8a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d8a cd 2b 1f			call macro_forth_dsp_pop 
3d8d				endm 
# End of macro FORTH_DSP_POP
3d8d			 
3d8d cd fc 1a				call dumpcont	; skip old style of param parsing	 
3d90 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3d91					NEXTW 
3d91 c3 e5 1f			jp macro_next 
3d94				endm 
# End of macro NEXTW
3d94			.CDUMP: 
3d94				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3d94 38				db WORD_SYS_CORE+36             
3d95 c4 3d			dw .DAT            
3d97 06				db 5 + 1 
3d98 .. 00			db "CDUMP",0              
3d9e				endm 
# End of macro CWHEAD
3d9e			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3d9e					if DEBUG_FORTH_WORDS_KEY 
3d9e						DMARK "CDP" 
3d9e f5				push af  
3d9f 3a b3 3d			ld a, (.dmark)  
3da2 32 bd fb			ld (debug_mark),a  
3da5 3a b4 3d			ld a, (.dmark+1)  
3da8 32 be fb			ld (debug_mark+1),a  
3dab 3a b5 3d			ld a, (.dmark+2)  
3dae 32 bf fb			ld (debug_mark+2),a  
3db1 18 03			jr .pastdmark  
3db3 ..			.dmark: db "CDP"  
3db6 f1			.pastdmark: pop af  
3db7			endm  
# End of macro DMARK
3db7						CALLMONITOR 
3db7 cd ec 16			call break_point_state  
3dba				endm  
# End of macro CALLMONITOR
3dba					endif 
3dba cd d2 0a				call clear_display 
3dbd cd fc 1a				call dumpcont	 
3dc0 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3dc1					NEXTW 
3dc1 c3 e5 1f			jp macro_next 
3dc4				endm 
# End of macro NEXTW
3dc4			 
3dc4			 
3dc4			 
3dc4			 
3dc4			.DAT: 
3dc4				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3dc4 3d				db WORD_SYS_CORE+41             
3dc5 1a 3e			dw .HOME            
3dc7 03				db 2 + 1 
3dc8 .. 00			db "AT",0              
3dcb				endm 
# End of macro CWHEAD
3dcb			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3dcb					if DEBUG_FORTH_WORDS_KEY 
3dcb						DMARK "AT." 
3dcb f5				push af  
3dcc 3a e0 3d			ld a, (.dmark)  
3dcf 32 bd fb			ld (debug_mark),a  
3dd2 3a e1 3d			ld a, (.dmark+1)  
3dd5 32 be fb			ld (debug_mark+1),a  
3dd8 3a e2 3d			ld a, (.dmark+2)  
3ddb 32 bf fb			ld (debug_mark+2),a  
3dde 18 03			jr .pastdmark  
3de0 ..			.dmark: db "AT."  
3de3 f1			.pastdmark: pop af  
3de4			endm  
# End of macro DMARK
3de4						CALLMONITOR 
3de4 cd ec 16			call break_point_state  
3de7				endm  
# End of macro CALLMONITOR
3de7					endif 
3de7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3de7 cd 73 1e			call macro_dsp_valuehl 
3dea				endm 
# End of macro FORTH_DSP_VALUEHL
3dea			 
3dea			 
3dea					; TODO save cursor row 
3dea 7d					ld a,l 
3deb fe 02				cp 2 
3ded 20 04				jr nz, .crow3 
3def 3e 14				ld a, display_row_2 
3df1 18 12				jr .ccol1 
3df3 fe 03		.crow3:		cp 3 
3df5 20 04				jr nz, .crow4 
3df7 3e 28				ld a, display_row_3 
3df9 18 0a				jr .ccol1 
3dfb fe 04		.crow4:		cp 4 
3dfd 20 04				jr nz, .crow1 
3dff 3e 3c				ld a, display_row_4 
3e01 18 02				jr .ccol1 
3e03 3e 00		.crow1:		ld a,display_row_1 
3e05 f5			.ccol1:		push af			; got row offset 
3e06 6f					ld l,a 
3e07 26 00				ld h,0 
3e09					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e09 cd 2b 1f			call macro_forth_dsp_pop 
3e0c				endm 
# End of macro FORTH_DSP_POP
3e0c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e0c cd 73 1e			call macro_dsp_valuehl 
3e0f				endm 
# End of macro FORTH_DSP_VALUEHL
3e0f					; TODO save cursor col 
3e0f f1					pop af 
3e10 85					add l		; add col offset 
3e11 32 cc f9				ld (f_cursor_ptr), a 
3e14					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e14 cd 2b 1f			call macro_forth_dsp_pop 
3e17				endm 
# End of macro FORTH_DSP_POP
3e17			 
3e17					; calculate  
3e17			 
3e17					NEXTW 
3e17 c3 e5 1f			jp macro_next 
3e1a				endm 
# End of macro NEXTW
3e1a			 
3e1a			 
3e1a			.HOME: 
3e1a				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3e1a 41				db WORD_SYS_CORE+45             
3e1b 47 3e			dw .SPACE            
3e1d 05				db 4 + 1 
3e1e .. 00			db "HOME",0              
3e23				endm 
# End of macro CWHEAD
3e23			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3e23					if DEBUG_FORTH_WORDS_KEY 
3e23						DMARK "HOM" 
3e23 f5				push af  
3e24 3a 38 3e			ld a, (.dmark)  
3e27 32 bd fb			ld (debug_mark),a  
3e2a 3a 39 3e			ld a, (.dmark+1)  
3e2d 32 be fb			ld (debug_mark+1),a  
3e30 3a 3a 3e			ld a, (.dmark+2)  
3e33 32 bf fb			ld (debug_mark+2),a  
3e36 18 03			jr .pastdmark  
3e38 ..			.dmark: db "HOM"  
3e3b f1			.pastdmark: pop af  
3e3c			endm  
# End of macro DMARK
3e3c						CALLMONITOR 
3e3c cd ec 16			call break_point_state  
3e3f				endm  
# End of macro CALLMONITOR
3e3f					endif 
3e3f 3e 00		.home:		ld a, 0		; and home cursor 
3e41 32 cc f9				ld (f_cursor_ptr), a 
3e44					NEXTW 
3e44 c3 e5 1f			jp macro_next 
3e47				endm 
# End of macro NEXTW
3e47			 
3e47			 
3e47			.SPACE: 
3e47				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3e47 46				db WORD_SYS_CORE+50             
3e48 75 3e			dw .SPACES            
3e4a 03				db 2 + 1 
3e4b .. 00			db "BL",0              
3e4e				endm 
# End of macro CWHEAD
3e4e			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3e4e					if DEBUG_FORTH_WORDS_KEY 
3e4e						DMARK "BL." 
3e4e f5				push af  
3e4f 3a 63 3e			ld a, (.dmark)  
3e52 32 bd fb			ld (debug_mark),a  
3e55 3a 64 3e			ld a, (.dmark+1)  
3e58 32 be fb			ld (debug_mark+1),a  
3e5b 3a 65 3e			ld a, (.dmark+2)  
3e5e 32 bf fb			ld (debug_mark+2),a  
3e61 18 03			jr .pastdmark  
3e63 ..			.dmark: db "BL."  
3e66 f1			.pastdmark: pop af  
3e67			endm  
# End of macro DMARK
3e67						CALLMONITOR 
3e67 cd ec 16			call break_point_state  
3e6a				endm  
# End of macro CALLMONITOR
3e6a					endif 
3e6a 21 73 3e				ld hl, .blstr 
3e6d cd ea 1c				call forth_push_str 
3e70					 
3e70				       NEXTW 
3e70 c3 e5 1f			jp macro_next 
3e73				endm 
# End of macro NEXTW
3e73			 
3e73 .. 00		.blstr: db " ", 0 
3e75			 
3e75			.SPACES: 
3e75				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3e75 47				db WORD_SYS_CORE+51             
3e76 10 3f			dw .SCROLL            
3e78 07				db 6 + 1 
3e79 .. 00			db "SPACES",0              
3e80				endm 
# End of macro CWHEAD
3e80			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
3e80					if DEBUG_FORTH_WORDS_KEY 
3e80						DMARK "SPS" 
3e80 f5				push af  
3e81 3a 95 3e			ld a, (.dmark)  
3e84 32 bd fb			ld (debug_mark),a  
3e87 3a 96 3e			ld a, (.dmark+1)  
3e8a 32 be fb			ld (debug_mark+1),a  
3e8d 3a 97 3e			ld a, (.dmark+2)  
3e90 32 bf fb			ld (debug_mark+2),a  
3e93 18 03			jr .pastdmark  
3e95 ..			.dmark: db "SPS"  
3e98 f1			.pastdmark: pop af  
3e99			endm  
# End of macro DMARK
3e99						CALLMONITOR 
3e99 cd ec 16			call break_point_state  
3e9c				endm  
# End of macro CALLMONITOR
3e9c					endif 
3e9c			 
3e9c			 
3e9c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e9c cd 73 1e			call macro_dsp_valuehl 
3e9f				endm 
# End of macro FORTH_DSP_VALUEHL
3e9f			 
3e9f			;		push hl    ; u 
3e9f					if DEBUG_FORTH_WORDS 
3e9f						DMARK "SPA" 
3e9f f5				push af  
3ea0 3a b4 3e			ld a, (.dmark)  
3ea3 32 bd fb			ld (debug_mark),a  
3ea6 3a b5 3e			ld a, (.dmark+1)  
3ea9 32 be fb			ld (debug_mark+1),a  
3eac 3a b6 3e			ld a, (.dmark+2)  
3eaf 32 bf fb			ld (debug_mark+2),a  
3eb2 18 03			jr .pastdmark  
3eb4 ..			.dmark: db "SPA"  
3eb7 f1			.pastdmark: pop af  
3eb8			endm  
# End of macro DMARK
3eb8						CALLMONITOR 
3eb8 cd ec 16			call break_point_state  
3ebb				endm  
# End of macro CALLMONITOR
3ebb					endif 
3ebb			 
3ebb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ebb cd 2b 1f			call macro_forth_dsp_pop 
3ebe				endm 
# End of macro FORTH_DSP_POP
3ebe			;		pop hl 
3ebe 4d					ld c, l 
3ebf 06 00				ld b, 0 
3ec1 21 a3 ef				ld hl, scratch  
3ec4			 
3ec4					if DEBUG_FORTH_WORDS 
3ec4						DMARK "SP2" 
3ec4 f5				push af  
3ec5 3a d9 3e			ld a, (.dmark)  
3ec8 32 bd fb			ld (debug_mark),a  
3ecb 3a da 3e			ld a, (.dmark+1)  
3ece 32 be fb			ld (debug_mark+1),a  
3ed1 3a db 3e			ld a, (.dmark+2)  
3ed4 32 bf fb			ld (debug_mark+2),a  
3ed7 18 03			jr .pastdmark  
3ed9 ..			.dmark: db "SP2"  
3edc f1			.pastdmark: pop af  
3edd			endm  
# End of macro DMARK
3edd						CALLMONITOR 
3edd cd ec 16			call break_point_state  
3ee0				endm  
# End of macro CALLMONITOR
3ee0					endif 
3ee0 3e 20				ld a, ' ' 
3ee2 c5			.spaces1:	push bc 
3ee3 77					ld (hl),a 
3ee4 23					inc hl 
3ee5 c1					pop bc 
3ee6 10 fa				djnz .spaces1 
3ee8 3e 00				ld a,0 
3eea 77					ld (hl),a 
3eeb 21 a3 ef				ld hl, scratch 
3eee					if DEBUG_FORTH_WORDS 
3eee						DMARK "SP3" 
3eee f5				push af  
3eef 3a 03 3f			ld a, (.dmark)  
3ef2 32 bd fb			ld (debug_mark),a  
3ef5 3a 04 3f			ld a, (.dmark+1)  
3ef8 32 be fb			ld (debug_mark+1),a  
3efb 3a 05 3f			ld a, (.dmark+2)  
3efe 32 bf fb			ld (debug_mark+2),a  
3f01 18 03			jr .pastdmark  
3f03 ..			.dmark: db "SP3"  
3f06 f1			.pastdmark: pop af  
3f07			endm  
# End of macro DMARK
3f07						CALLMONITOR 
3f07 cd ec 16			call break_point_state  
3f0a				endm  
# End of macro CALLMONITOR
3f0a					endif 
3f0a cd e5 1d				call forth_apush 
3f0d			 
3f0d				       NEXTW 
3f0d c3 e5 1f			jp macro_next 
3f10				endm 
# End of macro NEXTW
3f10			 
3f10			 
3f10			 
3f10			.SCROLL: 
3f10				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
3f10 53				db WORD_SYS_CORE+63             
3f11 3d 3f			dw .SCROLLD            
3f13 07				db 6 + 1 
3f14 .. 00			db "SCROLL",0              
3f1b				endm 
# End of macro CWHEAD
3f1b			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
3f1b					if DEBUG_FORTH_WORDS_KEY 
3f1b						DMARK "SCR" 
3f1b f5				push af  
3f1c 3a 30 3f			ld a, (.dmark)  
3f1f 32 bd fb			ld (debug_mark),a  
3f22 3a 31 3f			ld a, (.dmark+1)  
3f25 32 be fb			ld (debug_mark+1),a  
3f28 3a 32 3f			ld a, (.dmark+2)  
3f2b 32 bf fb			ld (debug_mark+2),a  
3f2e 18 03			jr .pastdmark  
3f30 ..			.dmark: db "SCR"  
3f33 f1			.pastdmark: pop af  
3f34			endm  
# End of macro DMARK
3f34						CALLMONITOR 
3f34 cd ec 16			call break_point_state  
3f37				endm  
# End of macro CALLMONITOR
3f37					endif 
3f37			 
3f37 cd 94 0a			call scroll_up 
3f3a			;	call update_display 
3f3a			 
3f3a					NEXTW 
3f3a c3 e5 1f			jp macro_next 
3f3d				endm 
# End of macro NEXTW
3f3d			 
3f3d			 
3f3d			 
3f3d			;		; get dir 
3f3d			; 
3f3d			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f3d			; 
3f3d			;		push hl 
3f3d			; 
3f3d			;		; destroy value TOS 
3f3d			; 
3f3d			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f3d			; 
3f3d			;		; get count 
3f3d			; 
3f3d			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f3d			; 
3f3d			;		push hl 
3f3d			; 
3f3d			;		; destroy value TOS 
3f3d			; 
3f3d			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f3d			; 
3f3d			;		; one value on hl get other one back 
3f3d			; 
3f3d			;		pop bc    ; count 
3f3d			; 
3f3d			;		pop de   ; dir 
3f3d			; 
3f3d			; 
3f3d			;		ld b, c 
3f3d			; 
3f3d			;.scrolldir:     push bc 
3f3d			;		push de 
3f3d			; 
3f3d			;		ld a, 0 
3f3d			;		cp e 
3f3d			;		jr z, .scrollup  
3f3d			;		call scroll_down 
3f3d			;		jr .scrollnext 
3f3d			;.scrollup:	call scroll_up 
3f3d			; 
3f3d			;		 
3f3d			;.scrollnext: 
3f3d			;		pop de 
3f3d			;		pop bc 
3f3d			;		djnz .scrolldir 
3f3d			; 
3f3d			; 
3f3d			; 
3f3d			; 
3f3d			; 
3f3d			;		NEXTW 
3f3d			 
3f3d			.SCROLLD: 
3f3d				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
3f3d 53				db WORD_SYS_CORE+63             
3f3e 6b 3f			dw .ATQ            
3f40 08				db 7 + 1 
3f41 .. 00			db "SCROLLD",0              
3f49				endm 
# End of macro CWHEAD
3f49			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
3f49					if DEBUG_FORTH_WORDS_KEY 
3f49						DMARK "SCD" 
3f49 f5				push af  
3f4a 3a 5e 3f			ld a, (.dmark)  
3f4d 32 bd fb			ld (debug_mark),a  
3f50 3a 5f 3f			ld a, (.dmark+1)  
3f53 32 be fb			ld (debug_mark+1),a  
3f56 3a 60 3f			ld a, (.dmark+2)  
3f59 32 bf fb			ld (debug_mark+2),a  
3f5c 18 03			jr .pastdmark  
3f5e ..			.dmark: db "SCD"  
3f61 f1			.pastdmark: pop af  
3f62			endm  
# End of macro DMARK
3f62						CALLMONITOR 
3f62 cd ec 16			call break_point_state  
3f65				endm  
# End of macro CALLMONITOR
3f65					endif 
3f65			 
3f65 cd b8 0a			call scroll_down 
3f68			;	call update_display 
3f68			 
3f68					NEXTW 
3f68 c3 e5 1f			jp macro_next 
3f6b				endm 
# End of macro NEXTW
3f6b			 
3f6b			 
3f6b			.ATQ: 
3f6b				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
3f6b 62				db WORD_SYS_CORE+78             
3f6c c9 3f			dw .AUTODSP            
3f6e 04				db 3 + 1 
3f6f .. 00			db "AT@",0              
3f73				endm 
# End of macro CWHEAD
3f73			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
3f73					if DEBUG_FORTH_WORDS_KEY 
3f73						DMARK "ATA" 
3f73 f5				push af  
3f74 3a 88 3f			ld a, (.dmark)  
3f77 32 bd fb			ld (debug_mark),a  
3f7a 3a 89 3f			ld a, (.dmark+1)  
3f7d 32 be fb			ld (debug_mark+1),a  
3f80 3a 8a 3f			ld a, (.dmark+2)  
3f83 32 bf fb			ld (debug_mark+2),a  
3f86 18 03			jr .pastdmark  
3f88 ..			.dmark: db "ATA"  
3f8b f1			.pastdmark: pop af  
3f8c			endm  
# End of macro DMARK
3f8c						CALLMONITOR 
3f8c cd ec 16			call break_point_state  
3f8f				endm  
# End of macro CALLMONITOR
3f8f					endif 
3f8f			 
3f8f			 
3f8f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f8f cd 73 1e			call macro_dsp_valuehl 
3f92				endm 
# End of macro FORTH_DSP_VALUEHL
3f92			 
3f92					; TODO save cursor row 
3f92 7d					ld a,l 
3f93 fe 02				cp 2 
3f95 20 04				jr nz, .crow3aq 
3f97 3e 14				ld a, display_row_2 
3f99 18 12				jr .ccol1aq 
3f9b fe 03		.crow3aq:		cp 3 
3f9d 20 04				jr nz, .crow4aq 
3f9f 3e 28				ld a, display_row_3 
3fa1 18 0a				jr .ccol1aq 
3fa3 fe 04		.crow4aq:		cp 4 
3fa5 20 04				jr nz, .crow1aq 
3fa7 3e 3c				ld a, display_row_4 
3fa9 18 02				jr .ccol1aq 
3fab 3e 00		.crow1aq:		ld a,display_row_1 
3fad f5			.ccol1aq:		push af			; got row offset 
3fae 6f					ld l,a 
3faf 26 00				ld h,0 
3fb1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3fb1 cd 2b 1f			call macro_forth_dsp_pop 
3fb4				endm 
# End of macro FORTH_DSP_POP
3fb4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3fb4 cd 73 1e			call macro_dsp_valuehl 
3fb7				endm 
# End of macro FORTH_DSP_VALUEHL
3fb7					; TODO save cursor col 
3fb7 f1					pop af 
3fb8 85					add l		; add col offset 
3fb9			 
3fb9					; add current frame buffer address 
3fb9 2a 5e fa				ld hl, (display_fb_active) 
3fbc cd 06 0d				call addatohl 
3fbf			 
3fbf			 
3fbf			 
3fbf			 
3fbf					; get char frame buffer location offset in hl 
3fbf			 
3fbf 7e					ld a,(hl) 
3fc0 26 00				ld h, 0 
3fc2 6f					ld l, a 
3fc3			 
3fc3 cd 7c 1c				call forth_push_numhl 
3fc6			 
3fc6			 
3fc6					NEXTW 
3fc6 c3 e5 1f			jp macro_next 
3fc9				endm 
# End of macro NEXTW
3fc9			 
3fc9			.AUTODSP: 
3fc9				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
3fc9 63				db WORD_SYS_CORE+79             
3fca df 3f			dw .MENU            
3fcc 05				db 4 + 1 
3fcd .. 00			db "ADSP",0              
3fd2				endm 
# End of macro CWHEAD
3fd2			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
3fd2			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
3fd2			 
3fd2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3fd2 cd 73 1e			call macro_dsp_valuehl 
3fd5				endm 
# End of macro FORTH_DSP_VALUEHL
3fd5			 
3fd5			;		push hl 
3fd5			 
3fd5					; destroy value TOS 
3fd5			 
3fd5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3fd5 cd 2b 1f			call macro_forth_dsp_pop 
3fd8				endm 
# End of macro FORTH_DSP_POP
3fd8			 
3fd8			;		pop hl 
3fd8			 
3fd8 7d					ld a,l 
3fd9 32 aa f9				ld (cli_autodisplay), a 
3fdc				       NEXTW 
3fdc c3 e5 1f			jp macro_next 
3fdf				endm 
# End of macro NEXTW
3fdf			 
3fdf			.MENU: 
3fdf				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
3fdf 70				db WORD_SYS_CORE+92             
3fe0 88 40			dw .ENDDISPLAY            
3fe2 05				db 4 + 1 
3fe3 .. 00			db "MENU",0              
3fe8				endm 
# End of macro CWHEAD
3fe8			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
3fe8			 
3fe8			;		; get number of items on the stack 
3fe8			; 
3fe8				 
3fe8					FORTH_DSP_VALUEHL 
3fe8 cd 73 1e			call macro_dsp_valuehl 
3feb				endm 
# End of macro FORTH_DSP_VALUEHL
3feb				 
3feb					if DEBUG_FORTH_WORDS_KEY 
3feb						DMARK "MNU" 
3feb f5				push af  
3fec 3a 00 40			ld a, (.dmark)  
3fef 32 bd fb			ld (debug_mark),a  
3ff2 3a 01 40			ld a, (.dmark+1)  
3ff5 32 be fb			ld (debug_mark+1),a  
3ff8 3a 02 40			ld a, (.dmark+2)  
3ffb 32 bf fb			ld (debug_mark+2),a  
3ffe 18 03			jr .pastdmark  
4000 ..			.dmark: db "MNU"  
4003 f1			.pastdmark: pop af  
4004			endm  
# End of macro DMARK
4004						CALLMONITOR 
4004 cd ec 16			call break_point_state  
4007				endm  
# End of macro CALLMONITOR
4007					endif 
4007			 
4007 45					ld b, l	 
4008 05					dec b 
4009			 
4009					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4009 cd 2b 1f			call macro_forth_dsp_pop 
400c				endm 
# End of macro FORTH_DSP_POP
400c			 
400c			 
400c					; go directly through the stack to pluck out the string pointers and build an array 
400c			 
400c			;		FORTH_DSP 
400c			 
400c					; hl contains top most stack item 
400c				 
400c 11 a3 ef				ld de, scratch 
400f			 
400f			.mbuild: 
400f			 
400f					FORTH_DSP_VALUEHL 
400f cd 73 1e			call macro_dsp_valuehl 
4012				endm 
# End of macro FORTH_DSP_VALUEHL
4012			 
4012					if DEBUG_FORTH_WORDS 
4012						DMARK "MN3" 
4012 f5				push af  
4013 3a 27 40			ld a, (.dmark)  
4016 32 bd fb			ld (debug_mark),a  
4019 3a 28 40			ld a, (.dmark+1)  
401c 32 be fb			ld (debug_mark+1),a  
401f 3a 29 40			ld a, (.dmark+2)  
4022 32 bf fb			ld (debug_mark+2),a  
4025 18 03			jr .pastdmark  
4027 ..			.dmark: db "MN3"  
402a f1			.pastdmark: pop af  
402b			endm  
# End of macro DMARK
402b						CALLMONITOR 
402b cd ec 16			call break_point_state  
402e				endm  
# End of macro CALLMONITOR
402e					endif 
402e eb					ex de, hl 
402f 73					ld (hl), e 
4030 23					inc hl 
4031 72					ld (hl), d 
4032 23					inc hl 
4033 eb					ex de, hl 
4034			 
4034					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4034 cd 2b 1f			call macro_forth_dsp_pop 
4037				endm 
# End of macro FORTH_DSP_POP
4037			 
4037 10 d6				djnz .mbuild 
4039			 
4039					; done add term 
4039			 
4039 eb					ex de, hl 
403a 36 00				ld (hl), 0 
403c 23					inc hl 
403d 36 00				ld (hl), 0 
403f			 
403f				 
403f					 
403f 21 a3 ef				ld hl, scratch 
4042			 
4042					if DEBUG_FORTH_WORDS 
4042						DMARK "MNx" 
4042 f5				push af  
4043 3a 57 40			ld a, (.dmark)  
4046 32 bd fb			ld (debug_mark),a  
4049 3a 58 40			ld a, (.dmark+1)  
404c 32 be fb			ld (debug_mark+1),a  
404f 3a 59 40			ld a, (.dmark+2)  
4052 32 bf fb			ld (debug_mark+2),a  
4055 18 03			jr .pastdmark  
4057 ..			.dmark: db "MNx"  
405a f1			.pastdmark: pop af  
405b			endm  
# End of macro DMARK
405b						CALLMONITOR 
405b cd ec 16			call break_point_state  
405e				endm  
# End of macro CALLMONITOR
405e					endif 
405e			 
405e			 
405e			 
405e 3e 00				ld a, 0 
4060 cd 03 0b				call menu 
4063			 
4063			 
4063 6f					ld l, a 
4064 26 00				ld h, 0 
4066			 
4066					if DEBUG_FORTH_WORDS 
4066						DMARK "MNr" 
4066 f5				push af  
4067 3a 7b 40			ld a, (.dmark)  
406a 32 bd fb			ld (debug_mark),a  
406d 3a 7c 40			ld a, (.dmark+1)  
4070 32 be fb			ld (debug_mark+1),a  
4073 3a 7d 40			ld a, (.dmark+2)  
4076 32 bf fb			ld (debug_mark+2),a  
4079 18 03			jr .pastdmark  
407b ..			.dmark: db "MNr"  
407e f1			.pastdmark: pop af  
407f			endm  
# End of macro DMARK
407f						CALLMONITOR 
407f cd ec 16			call break_point_state  
4082				endm  
# End of macro CALLMONITOR
4082					endif 
4082			 
4082 cd 7c 1c				call forth_push_numhl 
4085			 
4085			 
4085			 
4085			 
4085				       NEXTW 
4085 c3 e5 1f			jp macro_next 
4088				endm 
# End of macro NEXTW
4088			 
4088			 
4088			.ENDDISPLAY: 
4088			 
4088			; eof 
# End of file forth_words_display.asm
4088			include "forth_words_str.asm" 
4088			 
4088			; | ## String Words 
4088			 
4088			.PTR:   
4088			 
4088				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
4088 48				db WORD_SYS_CORE+52             
4089 b5 40			dw .STYPE            
408b 04				db 3 + 1 
408c .. 00			db "PTR",0              
4090				endm 
# End of macro CWHEAD
4090			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
4090			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
4090			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
4090			 
4090					if DEBUG_FORTH_WORDS_KEY 
4090						DMARK "PTR" 
4090 f5				push af  
4091 3a a5 40			ld a, (.dmark)  
4094 32 bd fb			ld (debug_mark),a  
4097 3a a6 40			ld a, (.dmark+1)  
409a 32 be fb			ld (debug_mark+1),a  
409d 3a a7 40			ld a, (.dmark+2)  
40a0 32 bf fb			ld (debug_mark+2),a  
40a3 18 03			jr .pastdmark  
40a5 ..			.dmark: db "PTR"  
40a8 f1			.pastdmark: pop af  
40a9			endm  
# End of macro DMARK
40a9						CALLMONITOR 
40a9 cd ec 16			call break_point_state  
40ac				endm  
# End of macro CALLMONITOR
40ac					endif 
40ac					FORTH_DSP_VALUEHL 
40ac cd 73 1e			call macro_dsp_valuehl 
40af				endm 
# End of macro FORTH_DSP_VALUEHL
40af cd 7c 1c				call forth_push_numhl 
40b2			 
40b2			 
40b2					NEXTW 
40b2 c3 e5 1f			jp macro_next 
40b5				endm 
# End of macro NEXTW
40b5			.STYPE: 
40b5				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
40b5 48				db WORD_SYS_CORE+52             
40b6 04 41			dw .UPPER            
40b8 06				db 5 + 1 
40b9 .. 00			db "STYPE",0              
40bf				endm 
# End of macro CWHEAD
40bf			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
40bf					if DEBUG_FORTH_WORDS_KEY 
40bf						DMARK "STY" 
40bf f5				push af  
40c0 3a d4 40			ld a, (.dmark)  
40c3 32 bd fb			ld (debug_mark),a  
40c6 3a d5 40			ld a, (.dmark+1)  
40c9 32 be fb			ld (debug_mark+1),a  
40cc 3a d6 40			ld a, (.dmark+2)  
40cf 32 bf fb			ld (debug_mark+2),a  
40d2 18 03			jr .pastdmark  
40d4 ..			.dmark: db "STY"  
40d7 f1			.pastdmark: pop af  
40d8			endm  
# End of macro DMARK
40d8						CALLMONITOR 
40d8 cd ec 16			call break_point_state  
40db				endm  
# End of macro CALLMONITOR
40db					endif 
40db					FORTH_DSP 
40db cd 39 1e			call macro_forth_dsp 
40de				endm 
# End of macro FORTH_DSP
40de					;v5 FORTH_DSP_VALUE 
40de			 
40de 7e					ld a, (hl) 
40df			 
40df f5					push af 
40e0			 
40e0			; Dont destroy TOS		FORTH_DSP_POP 
40e0			 
40e0 f1					pop af 
40e1			 
40e1 fe 01				cp DS_TYPE_STR 
40e3 28 09				jr z, .typestr 
40e5			 
40e5 fe 02				cp DS_TYPE_INUM 
40e7 28 0a				jr z, .typeinum 
40e9			 
40e9 21 02 41				ld hl, .tna 
40ec 18 0a				jr .tpush 
40ee			 
40ee 21 fe 40		.typestr:	ld hl, .tstr 
40f1 18 05				jr .tpush 
40f3 21 00 41		.typeinum:	ld hl, .tinum 
40f6 18 00				jr .tpush 
40f8			 
40f8			.tpush: 
40f8			 
40f8 cd ea 1c				call forth_push_str 
40fb			 
40fb					NEXTW 
40fb c3 e5 1f			jp macro_next 
40fe				endm 
# End of macro NEXTW
40fe .. 00		.tstr:	db "s",0 
4100 .. 00		.tinum:  db "i",0 
4102 .. 00		.tna:   db "?", 0 
4104			 
4104			 
4104			.UPPER: 
4104				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
4104 48				db WORD_SYS_CORE+52             
4105 3f 41			dw .LOWER            
4107 06				db 5 + 1 
4108 .. 00			db "UPPER",0              
410e				endm 
# End of macro CWHEAD
410e			; | UPPER ( s -- s ) Upper case string s  | DONE 
410e					if DEBUG_FORTH_WORDS_KEY 
410e						DMARK "UPR" 
410e f5				push af  
410f 3a 23 41			ld a, (.dmark)  
4112 32 bd fb			ld (debug_mark),a  
4115 3a 24 41			ld a, (.dmark+1)  
4118 32 be fb			ld (debug_mark+1),a  
411b 3a 25 41			ld a, (.dmark+2)  
411e 32 bf fb			ld (debug_mark+2),a  
4121 18 03			jr .pastdmark  
4123 ..			.dmark: db "UPR"  
4126 f1			.pastdmark: pop af  
4127			endm  
# End of macro DMARK
4127						CALLMONITOR 
4127 cd ec 16			call break_point_state  
412a				endm  
# End of macro CALLMONITOR
412a					endif 
412a			 
412a					FORTH_DSP 
412a cd 39 1e			call macro_forth_dsp 
412d				endm 
# End of macro FORTH_DSP
412d					 
412d			; TODO check is string type 
412d			 
412d					FORTH_DSP_VALUEHL 
412d cd 73 1e			call macro_dsp_valuehl 
4130				endm 
# End of macro FORTH_DSP_VALUEHL
4130			; get pointer to string in hl 
4130			 
4130 7e			.toup:		ld a, (hl) 
4131 fe 00				cp 0 
4133 28 07				jr z, .toupdone 
4135			 
4135 cd 73 10				call to_upper 
4138			 
4138 77					ld (hl), a 
4139 23					inc hl 
413a 18 f4				jr .toup 
413c			 
413c					 
413c			 
413c			 
413c			; for each char convert to upper 
413c					 
413c			.toupdone: 
413c			 
413c			 
413c					NEXTW 
413c c3 e5 1f			jp macro_next 
413f				endm 
# End of macro NEXTW
413f			.LOWER: 
413f				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
413f 48				db WORD_SYS_CORE+52             
4140 7a 41			dw .TCASE            
4142 06				db 5 + 1 
4143 .. 00			db "LOWER",0              
4149				endm 
# End of macro CWHEAD
4149			; | LOWER ( s -- s ) Lower case string s  | DONE 
4149					if DEBUG_FORTH_WORDS_KEY 
4149						DMARK "LWR" 
4149 f5				push af  
414a 3a 5e 41			ld a, (.dmark)  
414d 32 bd fb			ld (debug_mark),a  
4150 3a 5f 41			ld a, (.dmark+1)  
4153 32 be fb			ld (debug_mark+1),a  
4156 3a 60 41			ld a, (.dmark+2)  
4159 32 bf fb			ld (debug_mark+2),a  
415c 18 03			jr .pastdmark  
415e ..			.dmark: db "LWR"  
4161 f1			.pastdmark: pop af  
4162			endm  
# End of macro DMARK
4162						CALLMONITOR 
4162 cd ec 16			call break_point_state  
4165				endm  
# End of macro CALLMONITOR
4165					endif 
4165			 
4165					FORTH_DSP 
4165 cd 39 1e			call macro_forth_dsp 
4168				endm 
# End of macro FORTH_DSP
4168					 
4168			; TODO check is string type 
4168			 
4168					FORTH_DSP_VALUEHL 
4168 cd 73 1e			call macro_dsp_valuehl 
416b				endm 
# End of macro FORTH_DSP_VALUEHL
416b			; get pointer to string in hl 
416b			 
416b 7e			.tolow:		ld a, (hl) 
416c fe 00				cp 0 
416e 28 07				jr z, .tolowdone 
4170			 
4170 cd 7c 10				call to_lower 
4173			 
4173 77					ld (hl), a 
4174 23					inc hl 
4175 18 f4				jr .tolow 
4177			 
4177					 
4177			 
4177			 
4177			; for each char convert to low 
4177					 
4177			.tolowdone: 
4177					NEXTW 
4177 c3 e5 1f			jp macro_next 
417a				endm 
# End of macro NEXTW
417a			.TCASE: 
417a				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
417a 48				db WORD_SYS_CORE+52             
417b b0 42			dw .SUBSTR            
417d 06				db 5 + 1 
417e .. 00			db "TCASE",0              
4184				endm 
# End of macro CWHEAD
4184			; | TCASE ( s -- s ) Title case string s  | DONE 
4184					if DEBUG_FORTH_WORDS_KEY 
4184						DMARK "TCS" 
4184 f5				push af  
4185 3a 99 41			ld a, (.dmark)  
4188 32 bd fb			ld (debug_mark),a  
418b 3a 9a 41			ld a, (.dmark+1)  
418e 32 be fb			ld (debug_mark+1),a  
4191 3a 9b 41			ld a, (.dmark+2)  
4194 32 bf fb			ld (debug_mark+2),a  
4197 18 03			jr .pastdmark  
4199 ..			.dmark: db "TCS"  
419c f1			.pastdmark: pop af  
419d			endm  
# End of macro DMARK
419d						CALLMONITOR 
419d cd ec 16			call break_point_state  
41a0				endm  
# End of macro CALLMONITOR
41a0					endif 
41a0			 
41a0					FORTH_DSP 
41a0 cd 39 1e			call macro_forth_dsp 
41a3				endm 
# End of macro FORTH_DSP
41a3					 
41a3			; TODO check is string type 
41a3			 
41a3					FORTH_DSP_VALUEHL 
41a3 cd 73 1e			call macro_dsp_valuehl 
41a6				endm 
# End of macro FORTH_DSP_VALUEHL
41a6			; get pointer to string in hl 
41a6			 
41a6					if DEBUG_FORTH_WORDS 
41a6						DMARK "TC1" 
41a6 f5				push af  
41a7 3a bb 41			ld a, (.dmark)  
41aa 32 bd fb			ld (debug_mark),a  
41ad 3a bc 41			ld a, (.dmark+1)  
41b0 32 be fb			ld (debug_mark+1),a  
41b3 3a bd 41			ld a, (.dmark+2)  
41b6 32 bf fb			ld (debug_mark+2),a  
41b9 18 03			jr .pastdmark  
41bb ..			.dmark: db "TC1"  
41be f1			.pastdmark: pop af  
41bf			endm  
# End of macro DMARK
41bf						CALLMONITOR 
41bf cd ec 16			call break_point_state  
41c2				endm  
# End of macro CALLMONITOR
41c2					endif 
41c2			 
41c2					; first time in turn to upper case first char 
41c2			 
41c2 7e					ld a, (hl) 
41c3 c3 4d 42				jp .totsiptou 
41c6			 
41c6			 
41c6 7e			.tot:		ld a, (hl) 
41c7 fe 00				cp 0 
41c9 ca 91 42				jp z, .totdone 
41cc			 
41cc					if DEBUG_FORTH_WORDS 
41cc						DMARK "TC2" 
41cc f5				push af  
41cd 3a e1 41			ld a, (.dmark)  
41d0 32 bd fb			ld (debug_mark),a  
41d3 3a e2 41			ld a, (.dmark+1)  
41d6 32 be fb			ld (debug_mark+1),a  
41d9 3a e3 41			ld a, (.dmark+2)  
41dc 32 bf fb			ld (debug_mark+2),a  
41df 18 03			jr .pastdmark  
41e1 ..			.dmark: db "TC2"  
41e4 f1			.pastdmark: pop af  
41e5			endm  
# End of macro DMARK
41e5						CALLMONITOR 
41e5 cd ec 16			call break_point_state  
41e8				endm  
# End of macro CALLMONITOR
41e8					endif 
41e8					; check to see if current char is a space 
41e8			 
41e8 fe 20				cp ' ' 
41ea 28 21				jr z, .totsp 
41ec cd 7c 10				call to_lower 
41ef					if DEBUG_FORTH_WORDS 
41ef						DMARK "TC3" 
41ef f5				push af  
41f0 3a 04 42			ld a, (.dmark)  
41f3 32 bd fb			ld (debug_mark),a  
41f6 3a 05 42			ld a, (.dmark+1)  
41f9 32 be fb			ld (debug_mark+1),a  
41fc 3a 06 42			ld a, (.dmark+2)  
41ff 32 bf fb			ld (debug_mark+2),a  
4202 18 03			jr .pastdmark  
4204 ..			.dmark: db "TC3"  
4207 f1			.pastdmark: pop af  
4208			endm  
# End of macro DMARK
4208						CALLMONITOR 
4208 cd ec 16			call break_point_state  
420b				endm  
# End of macro CALLMONITOR
420b					endif 
420b 18 63				jr .totnxt 
420d			 
420d			.totsp:         ; on a space, find next char which should be upper 
420d			 
420d					if DEBUG_FORTH_WORDS 
420d						DMARK "TC4" 
420d f5				push af  
420e 3a 22 42			ld a, (.dmark)  
4211 32 bd fb			ld (debug_mark),a  
4214 3a 23 42			ld a, (.dmark+1)  
4217 32 be fb			ld (debug_mark+1),a  
421a 3a 24 42			ld a, (.dmark+2)  
421d 32 bf fb			ld (debug_mark+2),a  
4220 18 03			jr .pastdmark  
4222 ..			.dmark: db "TC4"  
4225 f1			.pastdmark: pop af  
4226			endm  
# End of macro DMARK
4226						CALLMONITOR 
4226 cd ec 16			call break_point_state  
4229				endm  
# End of macro CALLMONITOR
4229					endif 
4229					;; 
4229			 
4229 fe 20				cp ' ' 
422b 20 20				jr nz, .totsiptou 
422d 23					inc hl 
422e 7e					ld a, (hl) 
422f					if DEBUG_FORTH_WORDS 
422f						DMARK "TC5" 
422f f5				push af  
4230 3a 44 42			ld a, (.dmark)  
4233 32 bd fb			ld (debug_mark),a  
4236 3a 45 42			ld a, (.dmark+1)  
4239 32 be fb			ld (debug_mark+1),a  
423c 3a 46 42			ld a, (.dmark+2)  
423f 32 bf fb			ld (debug_mark+2),a  
4242 18 03			jr .pastdmark  
4244 ..			.dmark: db "TC5"  
4247 f1			.pastdmark: pop af  
4248			endm  
# End of macro DMARK
4248						CALLMONITOR 
4248 cd ec 16			call break_point_state  
424b				endm  
# End of macro CALLMONITOR
424b					endif 
424b 18 c0				jr .totsp 
424d fe 00		.totsiptou:    cp 0 
424f 28 40				jr z, .totdone 
4251					; not space and not zero term so upper case it 
4251 cd 73 10				call to_upper 
4254			 
4254					if DEBUG_FORTH_WORDS 
4254						DMARK "TC6" 
4254 f5				push af  
4255 3a 69 42			ld a, (.dmark)  
4258 32 bd fb			ld (debug_mark),a  
425b 3a 6a 42			ld a, (.dmark+1)  
425e 32 be fb			ld (debug_mark+1),a  
4261 3a 6b 42			ld a, (.dmark+2)  
4264 32 bf fb			ld (debug_mark+2),a  
4267 18 03			jr .pastdmark  
4269 ..			.dmark: db "TC6"  
426c f1			.pastdmark: pop af  
426d			endm  
# End of macro DMARK
426d						CALLMONITOR 
426d cd ec 16			call break_point_state  
4270				endm  
# End of macro CALLMONITOR
4270					endif 
4270			 
4270			 
4270			.totnxt: 
4270			 
4270 77					ld (hl), a 
4271 23					inc hl 
4272					if DEBUG_FORTH_WORDS 
4272						DMARK "TC7" 
4272 f5				push af  
4273 3a 87 42			ld a, (.dmark)  
4276 32 bd fb			ld (debug_mark),a  
4279 3a 88 42			ld a, (.dmark+1)  
427c 32 be fb			ld (debug_mark+1),a  
427f 3a 89 42			ld a, (.dmark+2)  
4282 32 bf fb			ld (debug_mark+2),a  
4285 18 03			jr .pastdmark  
4287 ..			.dmark: db "TC7"  
428a f1			.pastdmark: pop af  
428b			endm  
# End of macro DMARK
428b						CALLMONITOR 
428b cd ec 16			call break_point_state  
428e				endm  
# End of macro CALLMONITOR
428e					endif 
428e c3 c6 41				jp .tot 
4291			 
4291					 
4291			 
4291			 
4291			; for each char convert to low 
4291					 
4291			.totdone: 
4291					if DEBUG_FORTH_WORDS 
4291						DMARK "TCd" 
4291 f5				push af  
4292 3a a6 42			ld a, (.dmark)  
4295 32 bd fb			ld (debug_mark),a  
4298 3a a7 42			ld a, (.dmark+1)  
429b 32 be fb			ld (debug_mark+1),a  
429e 3a a8 42			ld a, (.dmark+2)  
42a1 32 bf fb			ld (debug_mark+2),a  
42a4 18 03			jr .pastdmark  
42a6 ..			.dmark: db "TCd"  
42a9 f1			.pastdmark: pop af  
42aa			endm  
# End of macro DMARK
42aa						CALLMONITOR 
42aa cd ec 16			call break_point_state  
42ad				endm  
# End of macro CALLMONITOR
42ad					endif 
42ad					NEXTW 
42ad c3 e5 1f			jp macro_next 
42b0				endm 
# End of macro NEXTW
42b0			 
42b0			.SUBSTR: 
42b0				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
42b0 48				db WORD_SYS_CORE+52             
42b1 0e 43			dw .LEFT            
42b3 07				db 6 + 1 
42b4 .. 00			db "SUBSTR",0              
42bb				endm 
# End of macro CWHEAD
42bb			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
42bb			 
42bb					if DEBUG_FORTH_WORDS_KEY 
42bb						DMARK "SST" 
42bb f5				push af  
42bc 3a d0 42			ld a, (.dmark)  
42bf 32 bd fb			ld (debug_mark),a  
42c2 3a d1 42			ld a, (.dmark+1)  
42c5 32 be fb			ld (debug_mark+1),a  
42c8 3a d2 42			ld a, (.dmark+2)  
42cb 32 bf fb			ld (debug_mark+2),a  
42ce 18 03			jr .pastdmark  
42d0 ..			.dmark: db "SST"  
42d3 f1			.pastdmark: pop af  
42d4			endm  
# End of macro DMARK
42d4						CALLMONITOR 
42d4 cd ec 16			call break_point_state  
42d7				endm  
# End of macro CALLMONITOR
42d7					endif 
42d7			; TODO check string type 
42d7					FORTH_DSP_VALUEHL 
42d7 cd 73 1e			call macro_dsp_valuehl 
42da				endm 
# End of macro FORTH_DSP_VALUEHL
42da			 
42da e5					push hl      ; string length 
42db			 
42db					FORTH_DSP_POP 
42db cd 2b 1f			call macro_forth_dsp_pop 
42de				endm 
# End of macro FORTH_DSP_POP
42de			 
42de					FORTH_DSP_VALUEHL 
42de cd 73 1e			call macro_dsp_valuehl 
42e1				endm 
# End of macro FORTH_DSP_VALUEHL
42e1			 
42e1 e5					push hl     ; start char 
42e2			 
42e2					FORTH_DSP_POP 
42e2 cd 2b 1f			call macro_forth_dsp_pop 
42e5				endm 
# End of macro FORTH_DSP_POP
42e5			 
42e5			 
42e5					FORTH_DSP_VALUE 
42e5 cd 5c 1e			call macro_forth_dsp_value 
42e8				endm 
# End of macro FORTH_DSP_VALUE
42e8			 
42e8 d1					pop de    ; get start post offset 
42e9			 
42e9 19					add hl, de    ; starting offset 
42ea			 
42ea c1					pop bc 
42eb c5					push bc      ; grab size of string 
42ec			 
42ec e5					push hl    ; save string start  
42ed			 
42ed 26 00				ld h, 0 
42ef 69					ld l, c 
42f0 23					inc hl 
42f1 23					inc hl 
42f2			 
42f2 cd cd 11				call malloc 
42f5				if DEBUG_FORTH_MALLOC_GUARD 
42f5 cc 78 52				call z,malloc_error 
42f8				endif 
42f8			 
42f8 eb					ex de, hl      ; save malloc area for string copy 
42f9 e1					pop hl    ; get back source 
42fa c1					pop bc    ; get length of string back 
42fb			 
42fb d5					push de    ; save malloc area for after we push 
42fc ed b0				ldir     ; copy substr 
42fe			 
42fe			 
42fe eb					ex de, hl 
42ff 3e 00				ld a, 0 
4301 77					ld (hl), a   ; term substr 
4302			 
4302					 
4302 e1					pop hl    ; get malloc so we can push it 
4303 e5					push hl   ; save so we can free it afterwards 
4304			 
4304 cd ea 1c				call forth_push_str 
4307			 
4307 e1					pop hl 
4308 cd 97 12				call free 
430b			 
430b					 
430b					 
430b			 
430b			 
430b					NEXTW 
430b c3 e5 1f			jp macro_next 
430e				endm 
# End of macro NEXTW
430e			 
430e			.LEFT: 
430e				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
430e 48				db WORD_SYS_CORE+52             
430f 36 43			dw .RIGHT            
4311 05				db 4 + 1 
4312 .. 00			db "LEFT",0              
4317				endm 
# End of macro CWHEAD
4317			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
4317					if DEBUG_FORTH_WORDS_KEY 
4317						DMARK "LEF" 
4317 f5				push af  
4318 3a 2c 43			ld a, (.dmark)  
431b 32 bd fb			ld (debug_mark),a  
431e 3a 2d 43			ld a, (.dmark+1)  
4321 32 be fb			ld (debug_mark+1),a  
4324 3a 2e 43			ld a, (.dmark+2)  
4327 32 bf fb			ld (debug_mark+2),a  
432a 18 03			jr .pastdmark  
432c ..			.dmark: db "LEF"  
432f f1			.pastdmark: pop af  
4330			endm  
# End of macro DMARK
4330						CALLMONITOR 
4330 cd ec 16			call break_point_state  
4333				endm  
# End of macro CALLMONITOR
4333					endif 
4333			 
4333					NEXTW 
4333 c3 e5 1f			jp macro_next 
4336				endm 
# End of macro NEXTW
4336			.RIGHT: 
4336				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
4336 48				db WORD_SYS_CORE+52             
4337 5f 43			dw .STR2NUM            
4339 06				db 5 + 1 
433a .. 00			db "RIGHT",0              
4340				endm 
# End of macro CWHEAD
4340			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
4340					if DEBUG_FORTH_WORDS_KEY 
4340						DMARK "RIG" 
4340 f5				push af  
4341 3a 55 43			ld a, (.dmark)  
4344 32 bd fb			ld (debug_mark),a  
4347 3a 56 43			ld a, (.dmark+1)  
434a 32 be fb			ld (debug_mark+1),a  
434d 3a 57 43			ld a, (.dmark+2)  
4350 32 bf fb			ld (debug_mark+2),a  
4353 18 03			jr .pastdmark  
4355 ..			.dmark: db "RIG"  
4358 f1			.pastdmark: pop af  
4359			endm  
# End of macro DMARK
4359						CALLMONITOR 
4359 cd ec 16			call break_point_state  
435c				endm  
# End of macro CALLMONITOR
435c					endif 
435c			 
435c					NEXTW 
435c c3 e5 1f			jp macro_next 
435f				endm 
# End of macro NEXTW
435f			 
435f			 
435f			.STR2NUM: 
435f				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
435f 48				db WORD_SYS_CORE+52             
4360 eb 43			dw .NUM2STR            
4362 08				db 7 + 1 
4363 .. 00			db "STR2NUM",0              
436b				endm 
# End of macro CWHEAD
436b			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
436b			 
436b			 
436b			; TODO STR type check to do 
436b					if DEBUG_FORTH_WORDS_KEY 
436b						DMARK "S2N" 
436b f5				push af  
436c 3a 80 43			ld a, (.dmark)  
436f 32 bd fb			ld (debug_mark),a  
4372 3a 81 43			ld a, (.dmark+1)  
4375 32 be fb			ld (debug_mark+1),a  
4378 3a 82 43			ld a, (.dmark+2)  
437b 32 bf fb			ld (debug_mark+2),a  
437e 18 03			jr .pastdmark  
4380 ..			.dmark: db "S2N"  
4383 f1			.pastdmark: pop af  
4384			endm  
# End of macro DMARK
4384						CALLMONITOR 
4384 cd ec 16			call break_point_state  
4387				endm  
# End of macro CALLMONITOR
4387					endif 
4387			 
4387					;FORTH_DSP 
4387					FORTH_DSP_VALUE 
4387 cd 5c 1e			call macro_forth_dsp_value 
438a				endm 
# End of macro FORTH_DSP_VALUE
438a					;inc hl 
438a			 
438a eb					ex de, hl 
438b					if DEBUG_FORTH_WORDS 
438b						DMARK "S2a" 
438b f5				push af  
438c 3a a0 43			ld a, (.dmark)  
438f 32 bd fb			ld (debug_mark),a  
4392 3a a1 43			ld a, (.dmark+1)  
4395 32 be fb			ld (debug_mark+1),a  
4398 3a a2 43			ld a, (.dmark+2)  
439b 32 bf fb			ld (debug_mark+2),a  
439e 18 03			jr .pastdmark  
43a0 ..			.dmark: db "S2a"  
43a3 f1			.pastdmark: pop af  
43a4			endm  
# End of macro DMARK
43a4						CALLMONITOR 
43a4 cd ec 16			call break_point_state  
43a7				endm  
# End of macro CALLMONITOR
43a7					endif 
43a7 cd fb 10				call string_to_uint16 
43aa			 
43aa					if DEBUG_FORTH_WORDS 
43aa						DMARK "S2b" 
43aa f5				push af  
43ab 3a bf 43			ld a, (.dmark)  
43ae 32 bd fb			ld (debug_mark),a  
43b1 3a c0 43			ld a, (.dmark+1)  
43b4 32 be fb			ld (debug_mark+1),a  
43b7 3a c1 43			ld a, (.dmark+2)  
43ba 32 bf fb			ld (debug_mark+2),a  
43bd 18 03			jr .pastdmark  
43bf ..			.dmark: db "S2b"  
43c2 f1			.pastdmark: pop af  
43c3			endm  
# End of macro DMARK
43c3						CALLMONITOR 
43c3 cd ec 16			call break_point_state  
43c6				endm  
# End of macro CALLMONITOR
43c6					endif 
43c6			;		push hl 
43c6					FORTH_DSP_POP 
43c6 cd 2b 1f			call macro_forth_dsp_pop 
43c9				endm 
# End of macro FORTH_DSP_POP
43c9			;		pop hl 
43c9					 
43c9					if DEBUG_FORTH_WORDS 
43c9						DMARK "S2b" 
43c9 f5				push af  
43ca 3a de 43			ld a, (.dmark)  
43cd 32 bd fb			ld (debug_mark),a  
43d0 3a df 43			ld a, (.dmark+1)  
43d3 32 be fb			ld (debug_mark+1),a  
43d6 3a e0 43			ld a, (.dmark+2)  
43d9 32 bf fb			ld (debug_mark+2),a  
43dc 18 03			jr .pastdmark  
43de ..			.dmark: db "S2b"  
43e1 f1			.pastdmark: pop af  
43e2			endm  
# End of macro DMARK
43e2						CALLMONITOR 
43e2 cd ec 16			call break_point_state  
43e5				endm  
# End of macro CALLMONITOR
43e5					endif 
43e5 cd 7c 1c				call forth_push_numhl	 
43e8			 
43e8				 
43e8				       NEXTW 
43e8 c3 e5 1f			jp macro_next 
43eb				endm 
# End of macro NEXTW
43eb			.NUM2STR: 
43eb				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
43eb 48				db WORD_SYS_CORE+52             
43ec fa 43			dw .CONCAT            
43ee 08				db 7 + 1 
43ef .. 00			db "NUM2STR",0              
43f7				endm 
# End of macro CWHEAD
43f7			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
43f7			 
43f7			;		; malloc a string to target 
43f7			;		ld hl, 10     ; TODO max string size should be fine 
43f7			;		call malloc 
43f7			;		push hl    ; save malloc location 
43f7			; 
43f7			; 
43f7			;; TODO check int type 
43f7			;		FORTH_DSP_VALUEHL 
43f7			;		ld a, l 
43f7			;		call DispAToASCII   
43f7			;;TODO need to chage above call to dump into string 
43f7			; 
43f7			; 
43f7			 
43f7				       NEXTW 
43f7 c3 e5 1f			jp macro_next 
43fa				endm 
# End of macro NEXTW
43fa			 
43fa			.CONCAT: 
43fa				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
43fa 48				db WORD_SYS_CORE+52             
43fb ad 44			dw .FIND            
43fd 07				db 6 + 1 
43fe .. 00			db "CONCAT",0              
4405				endm 
# End of macro CWHEAD
4405			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
4405			 
4405			; TODO check string type 
4405			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
4405			 
4405					if DEBUG_FORTH_WORDS_KEY 
4405						DMARK "CON" 
4405 f5				push af  
4406 3a 1a 44			ld a, (.dmark)  
4409 32 bd fb			ld (debug_mark),a  
440c 3a 1b 44			ld a, (.dmark+1)  
440f 32 be fb			ld (debug_mark+1),a  
4412 3a 1c 44			ld a, (.dmark+2)  
4415 32 bf fb			ld (debug_mark+2),a  
4418 18 03			jr .pastdmark  
441a ..			.dmark: db "CON"  
441d f1			.pastdmark: pop af  
441e			endm  
# End of macro DMARK
441e						CALLMONITOR 
441e cd ec 16			call break_point_state  
4421				endm  
# End of macro CALLMONITOR
4421					endif 
4421			 
4421			 
4421					FORTH_DSP_VALUE 
4421 cd 5c 1e			call macro_forth_dsp_value 
4424				endm 
# End of macro FORTH_DSP_VALUE
4424 e5					push hl   ; s2 
4425			 
4425					FORTH_DSP_POP 
4425 cd 2b 1f			call macro_forth_dsp_pop 
4428				endm 
# End of macro FORTH_DSP_POP
4428			 
4428					FORTH_DSP_VALUE 
4428 cd 5c 1e			call macro_forth_dsp_value 
442b				endm 
# End of macro FORTH_DSP_VALUE
442b			 
442b e5					push hl   ; s1 
442c			 
442c					FORTH_DSP_POP 
442c cd 2b 1f			call macro_forth_dsp_pop 
442f				endm 
# End of macro FORTH_DSP_POP
442f					 
442f			 
442f					; copy s1 
442f			 
442f				 
442f					; save ptr 
442f e1					pop hl  
4430 e5					push hl 
4431 3e 00				ld a, 0 
4433 cd 6f 11				call strlent 
4436					;inc hl    ; zer0 
4436 06 00				ld b, 0 
4438 4d					ld c, l 
4439 e1					pop hl		 
443a 11 a3 ef				ld de, scratch	 
443d					if DEBUG_FORTH_WORDS 
443d						DMARK "CO1" 
443d f5				push af  
443e 3a 52 44			ld a, (.dmark)  
4441 32 bd fb			ld (debug_mark),a  
4444 3a 53 44			ld a, (.dmark+1)  
4447 32 be fb			ld (debug_mark+1),a  
444a 3a 54 44			ld a, (.dmark+2)  
444d 32 bf fb			ld (debug_mark+2),a  
4450 18 03			jr .pastdmark  
4452 ..			.dmark: db "CO1"  
4455 f1			.pastdmark: pop af  
4456			endm  
# End of macro DMARK
4456						CALLMONITOR 
4456 cd ec 16			call break_point_state  
4459				endm  
# End of macro CALLMONITOR
4459					endif 
4459 ed b0				ldir 
445b			 
445b e1					pop hl 
445c e5					push hl 
445d d5					push de 
445e			 
445e			 
445e 3e 00				ld a, 0 
4460 cd 6f 11				call strlent 
4463 23					inc hl    ; zer0 
4464 23					inc hl 
4465 06 00				ld b, 0 
4467 4d					ld c, l 
4468 d1					pop de 
4469 e1					pop hl		 
446a					if DEBUG_FORTH_WORDS 
446a						DMARK "CO2" 
446a f5				push af  
446b 3a 7f 44			ld a, (.dmark)  
446e 32 bd fb			ld (debug_mark),a  
4471 3a 80 44			ld a, (.dmark+1)  
4474 32 be fb			ld (debug_mark+1),a  
4477 3a 81 44			ld a, (.dmark+2)  
447a 32 bf fb			ld (debug_mark+2),a  
447d 18 03			jr .pastdmark  
447f ..			.dmark: db "CO2"  
4482 f1			.pastdmark: pop af  
4483			endm  
# End of macro DMARK
4483						CALLMONITOR 
4483 cd ec 16			call break_point_state  
4486				endm  
# End of macro CALLMONITOR
4486					endif 
4486 ed b0				ldir 
4488			 
4488			 
4488			 
4488 21 a3 ef				ld hl, scratch 
448b					if DEBUG_FORTH_WORDS 
448b						DMARK "CO5" 
448b f5				push af  
448c 3a a0 44			ld a, (.dmark)  
448f 32 bd fb			ld (debug_mark),a  
4492 3a a1 44			ld a, (.dmark+1)  
4495 32 be fb			ld (debug_mark+1),a  
4498 3a a2 44			ld a, (.dmark+2)  
449b 32 bf fb			ld (debug_mark+2),a  
449e 18 03			jr .pastdmark  
44a0 ..			.dmark: db "CO5"  
44a3 f1			.pastdmark: pop af  
44a4			endm  
# End of macro DMARK
44a4						CALLMONITOR 
44a4 cd ec 16			call break_point_state  
44a7				endm  
# End of macro CALLMONITOR
44a7					endif 
44a7			 
44a7 cd ea 1c				call forth_push_str 
44aa			 
44aa			 
44aa			 
44aa			 
44aa				       NEXTW 
44aa c3 e5 1f			jp macro_next 
44ad				endm 
# End of macro NEXTW
44ad			 
44ad			 
44ad			.FIND: 
44ad				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
44ad 4b				db WORD_SYS_CORE+55             
44ae 6b 45			dw .LEN            
44b0 05				db 4 + 1 
44b1 .. 00			db "FIND",0              
44b6				endm 
# End of macro CWHEAD
44b6			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
44b6			 
44b6					if DEBUG_FORTH_WORDS_KEY 
44b6						DMARK "FND" 
44b6 f5				push af  
44b7 3a cb 44			ld a, (.dmark)  
44ba 32 bd fb			ld (debug_mark),a  
44bd 3a cc 44			ld a, (.dmark+1)  
44c0 32 be fb			ld (debug_mark+1),a  
44c3 3a cd 44			ld a, (.dmark+2)  
44c6 32 bf fb			ld (debug_mark+2),a  
44c9 18 03			jr .pastdmark  
44cb ..			.dmark: db "FND"  
44ce f1			.pastdmark: pop af  
44cf			endm  
# End of macro DMARK
44cf						CALLMONITOR 
44cf cd ec 16			call break_point_state  
44d2				endm  
# End of macro CALLMONITOR
44d2					endif 
44d2			 
44d2			; TODO check string type 
44d2					FORTH_DSP_VALUE 
44d2 cd 5c 1e			call macro_forth_dsp_value 
44d5				endm 
# End of macro FORTH_DSP_VALUE
44d5			 
44d5 e5					push hl    
44d6 7e					ld a,(hl)    ; char to find   
44d7			; TODO change char to substr 
44d7			 
44d7 f5					push af 
44d8					 
44d8			 
44d8			 
44d8					if DEBUG_FORTH_WORDS 
44d8						DMARK "FN1" 
44d8 f5				push af  
44d9 3a ed 44			ld a, (.dmark)  
44dc 32 bd fb			ld (debug_mark),a  
44df 3a ee 44			ld a, (.dmark+1)  
44e2 32 be fb			ld (debug_mark+1),a  
44e5 3a ef 44			ld a, (.dmark+2)  
44e8 32 bf fb			ld (debug_mark+2),a  
44eb 18 03			jr .pastdmark  
44ed ..			.dmark: db "FN1"  
44f0 f1			.pastdmark: pop af  
44f1			endm  
# End of macro DMARK
44f1						CALLMONITOR 
44f1 cd ec 16			call break_point_state  
44f4				endm  
# End of macro CALLMONITOR
44f4					endif 
44f4			 
44f4					FORTH_DSP_POP 
44f4 cd 2b 1f			call macro_forth_dsp_pop 
44f7				endm 
# End of macro FORTH_DSP_POP
44f7			 
44f7					; string to search 
44f7			 
44f7					FORTH_DSP_VALUE 
44f7 cd 5c 1e			call macro_forth_dsp_value 
44fa				endm 
# End of macro FORTH_DSP_VALUE
44fa			 
44fa d1					pop de  ; d is char to find  
44fb			 
44fb					if DEBUG_FORTH_WORDS 
44fb						DMARK "FN2" 
44fb f5				push af  
44fc 3a 10 45			ld a, (.dmark)  
44ff 32 bd fb			ld (debug_mark),a  
4502 3a 11 45			ld a, (.dmark+1)  
4505 32 be fb			ld (debug_mark+1),a  
4508 3a 12 45			ld a, (.dmark+2)  
450b 32 bf fb			ld (debug_mark+2),a  
450e 18 03			jr .pastdmark  
4510 ..			.dmark: db "FN2"  
4513 f1			.pastdmark: pop af  
4514			endm  
# End of macro DMARK
4514						CALLMONITOR 
4514 cd ec 16			call break_point_state  
4517				endm  
# End of macro CALLMONITOR
4517					endif 
4517					 
4517 01 00 00				ld bc, 0 
451a 7e			.findchar:      ld a,(hl) 
451b fe 00				cp 0   		 
451d 28 27				jr z, .finddone     
451f ba					cp d 
4520 28 20				jr z, .foundchar 
4522 03					inc bc 
4523 23					inc hl 
4524					if DEBUG_FORTH_WORDS 
4524						DMARK "FN3" 
4524 f5				push af  
4525 3a 39 45			ld a, (.dmark)  
4528 32 bd fb			ld (debug_mark),a  
452b 3a 3a 45			ld a, (.dmark+1)  
452e 32 be fb			ld (debug_mark+1),a  
4531 3a 3b 45			ld a, (.dmark+2)  
4534 32 bf fb			ld (debug_mark+2),a  
4537 18 03			jr .pastdmark  
4539 ..			.dmark: db "FN3"  
453c f1			.pastdmark: pop af  
453d			endm  
# End of macro DMARK
453d						CALLMONITOR 
453d cd ec 16			call break_point_state  
4540				endm  
# End of macro CALLMONITOR
4540					endif 
4540 18 d8				jr .findchar 
4542			 
4542			 
4542 c5			.foundchar:	push bc 
4543 e1					pop hl 
4544 18 03				jr .findexit 
4546			 
4546			 
4546							 
4546			 
4546			.finddone:     ; got to end of string with no find 
4546 21 00 00				ld hl, 0 
4549			.findexit: 
4549			 
4549					if DEBUG_FORTH_WORDS 
4549						DMARK "FNd" 
4549 f5				push af  
454a 3a 5e 45			ld a, (.dmark)  
454d 32 bd fb			ld (debug_mark),a  
4550 3a 5f 45			ld a, (.dmark+1)  
4553 32 be fb			ld (debug_mark+1),a  
4556 3a 60 45			ld a, (.dmark+2)  
4559 32 bf fb			ld (debug_mark+2),a  
455c 18 03			jr .pastdmark  
455e ..			.dmark: db "FNd"  
4561 f1			.pastdmark: pop af  
4562			endm  
# End of macro DMARK
4562						CALLMONITOR 
4562 cd ec 16			call break_point_state  
4565				endm  
# End of macro CALLMONITOR
4565					endif 
4565 cd 7c 1c			call forth_push_numhl 
4568			 
4568				       NEXTW 
4568 c3 e5 1f			jp macro_next 
456b				endm 
# End of macro NEXTW
456b			 
456b			.LEN: 
456b				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
456b 4c				db WORD_SYS_CORE+56             
456c a0 45			dw .CHAR            
456e 06				db 5 + 1 
456f .. 00			db "COUNT",0              
4575				endm 
# End of macro CWHEAD
4575			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
4575			 
4575					if DEBUG_FORTH_WORDS_KEY 
4575						DMARK "CNT" 
4575 f5				push af  
4576 3a 8a 45			ld a, (.dmark)  
4579 32 bd fb			ld (debug_mark),a  
457c 3a 8b 45			ld a, (.dmark+1)  
457f 32 be fb			ld (debug_mark+1),a  
4582 3a 8c 45			ld a, (.dmark+2)  
4585 32 bf fb			ld (debug_mark+2),a  
4588 18 03			jr .pastdmark  
458a ..			.dmark: db "CNT"  
458d f1			.pastdmark: pop af  
458e			endm  
# End of macro DMARK
458e						CALLMONITOR 
458e cd ec 16			call break_point_state  
4591				endm  
# End of macro CALLMONITOR
4591					endif 
4591			; TODO check string type 
4591					FORTH_DSP 
4591 cd 39 1e			call macro_forth_dsp 
4594				endm 
# End of macro FORTH_DSP
4594					;v5FORTH_DSP_VALUE 
4594			 
4594 23					inc hl 
4595			 
4595 3e 00				ld a, 0 
4597 cd 6f 11				call strlent 
459a			 
459a cd 7c 1c				call forth_push_numhl 
459d			 
459d			 
459d			 
459d				       NEXTW 
459d c3 e5 1f			jp macro_next 
45a0				endm 
# End of macro NEXTW
45a0			.CHAR: 
45a0				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
45a0 4d				db WORD_SYS_CORE+57             
45a1 d6 45			dw .ENDSTR            
45a3 05				db 4 + 1 
45a4 .. 00			db "CHAR",0              
45a9				endm 
# End of macro CWHEAD
45a9			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
45a9					if DEBUG_FORTH_WORDS_KEY 
45a9						DMARK "CHR" 
45a9 f5				push af  
45aa 3a be 45			ld a, (.dmark)  
45ad 32 bd fb			ld (debug_mark),a  
45b0 3a bf 45			ld a, (.dmark+1)  
45b3 32 be fb			ld (debug_mark+1),a  
45b6 3a c0 45			ld a, (.dmark+2)  
45b9 32 bf fb			ld (debug_mark+2),a  
45bc 18 03			jr .pastdmark  
45be ..			.dmark: db "CHR"  
45c1 f1			.pastdmark: pop af  
45c2			endm  
# End of macro DMARK
45c2						CALLMONITOR 
45c2 cd ec 16			call break_point_state  
45c5				endm  
# End of macro CALLMONITOR
45c5					endif 
45c5					FORTH_DSP 
45c5 cd 39 1e			call macro_forth_dsp 
45c8				endm 
# End of macro FORTH_DSP
45c8					;v5 FORTH_DSP_VALUE 
45c8 23					inc hl      ; now at start of numeric as string 
45c9			 
45c9			;		push hl 
45c9			 
45c9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
45c9 cd 2b 1f			call macro_forth_dsp_pop 
45cc				endm 
# End of macro FORTH_DSP_POP
45cc			 
45cc			;		pop hl 
45cc			 
45cc					; push the content of a onto the stack as a value 
45cc			 
45cc 7e					ld a,(hl)   ; get char 
45cd 26 00				ld h,0 
45cf 6f					ld l,a 
45d0 cd 7c 1c				call forth_push_numhl 
45d3			 
45d3				       NEXTW 
45d3 c3 e5 1f			jp macro_next 
45d6				endm 
# End of macro NEXTW
45d6			 
45d6			 
45d6			 
45d6			 
45d6			.ENDSTR: 
45d6			; eof 
45d6			 
# End of file forth_words_str.asm
45d6			include "forth_words_key.asm" 
45d6			 
45d6			; | ## Keyboard Words 
45d6			 
45d6			.KEY: 
45d6				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
45d6 3e				db WORD_SYS_CORE+42             
45d7 06 46			dw .WAITK            
45d9 04				db 3 + 1 
45da .. 00			db "KEY",0              
45de				endm 
# End of macro CWHEAD
45de			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
45de			 
45de					if DEBUG_FORTH_WORDS_KEY 
45de						DMARK "KEY" 
45de f5				push af  
45df 3a f3 45			ld a, (.dmark)  
45e2 32 bd fb			ld (debug_mark),a  
45e5 3a f4 45			ld a, (.dmark+1)  
45e8 32 be fb			ld (debug_mark+1),a  
45eb 3a f5 45			ld a, (.dmark+2)  
45ee 32 bf fb			ld (debug_mark+2),a  
45f1 18 03			jr .pastdmark  
45f3 ..			.dmark: db "KEY"  
45f6 f1			.pastdmark: pop af  
45f7			endm  
# End of macro DMARK
45f7						CALLMONITOR 
45f7 cd ec 16			call break_point_state  
45fa				endm  
# End of macro CALLMONITOR
45fa					endif 
45fa			; TODO currently waits 
45fa cd 0d 68				call cin 
45fd					;call cin_wait 
45fd 6f					ld l, a 
45fe 26 00				ld h, 0 
4600 cd 7c 1c				call forth_push_numhl 
4603					NEXTW 
4603 c3 e5 1f			jp macro_next 
4606				endm 
# End of macro NEXTW
4606			.WAITK: 
4606				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4606 3f				db WORD_SYS_CORE+43             
4607 38 46			dw .ACCEPT            
4609 06				db 5 + 1 
460a .. 00			db "WAITK",0              
4610				endm 
# End of macro CWHEAD
4610			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4610					if DEBUG_FORTH_WORDS_KEY 
4610						DMARK "WAI" 
4610 f5				push af  
4611 3a 25 46			ld a, (.dmark)  
4614 32 bd fb			ld (debug_mark),a  
4617 3a 26 46			ld a, (.dmark+1)  
461a 32 be fb			ld (debug_mark+1),a  
461d 3a 27 46			ld a, (.dmark+2)  
4620 32 bf fb			ld (debug_mark+2),a  
4623 18 03			jr .pastdmark  
4625 ..			.dmark: db "WAI"  
4628 f1			.pastdmark: pop af  
4629			endm  
# End of macro DMARK
4629						CALLMONITOR 
4629 cd ec 16			call break_point_state  
462c				endm  
# End of macro CALLMONITOR
462c					endif 
462c cd fc 67				call cin_wait 
462f 6f					ld l, a 
4630 26 00				ld h, 0 
4632 cd 7c 1c				call forth_push_numhl 
4635					NEXTW 
4635 c3 e5 1f			jp macro_next 
4638				endm 
# End of macro NEXTW
4638			.ACCEPT: 
4638				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4638 40				db WORD_SYS_CORE+44             
4639 96 46			dw .EDIT            
463b 07				db 6 + 1 
463c .. 00			db "ACCEPT",0              
4643				endm 
# End of macro CWHEAD
4643			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
4643					; TODO crashes on push 
4643					if DEBUG_FORTH_WORDS_KEY 
4643						DMARK "ACC" 
4643 f5				push af  
4644 3a 58 46			ld a, (.dmark)  
4647 32 bd fb			ld (debug_mark),a  
464a 3a 59 46			ld a, (.dmark+1)  
464d 32 be fb			ld (debug_mark+1),a  
4650 3a 5a 46			ld a, (.dmark+2)  
4653 32 bf fb			ld (debug_mark+2),a  
4656 18 03			jr .pastdmark  
4658 ..			.dmark: db "ACC"  
465b f1			.pastdmark: pop af  
465c			endm  
# End of macro DMARK
465c						CALLMONITOR 
465c cd ec 16			call break_point_state  
465f				endm  
# End of macro CALLMONITOR
465f					endif 
465f 21 a1 f1				ld hl, os_input 
4662 3e 00				ld a, 0 
4664 77					ld (hl),a 
4665 3a cc f9				ld a,(f_cursor_ptr) 
4668 16 64				ld d, 100 
466a 0e 00				ld c, 0 
466c 1e 28				ld e, 40 
466e cd 33 0d				call input_str 
4671					; TODO perhaps do a type check and wrap in quotes if not a number 
4671 21 a1 f1				ld hl, os_input 
4674					if DEBUG_FORTH_WORDS 
4674						DMARK "AC1" 
4674 f5				push af  
4675 3a 89 46			ld a, (.dmark)  
4678 32 bd fb			ld (debug_mark),a  
467b 3a 8a 46			ld a, (.dmark+1)  
467e 32 be fb			ld (debug_mark+1),a  
4681 3a 8b 46			ld a, (.dmark+2)  
4684 32 bf fb			ld (debug_mark+2),a  
4687 18 03			jr .pastdmark  
4689 ..			.dmark: db "AC1"  
468c f1			.pastdmark: pop af  
468d			endm  
# End of macro DMARK
468d						CALLMONITOR 
468d cd ec 16			call break_point_state  
4690				endm  
# End of macro CALLMONITOR
4690					endif 
4690 cd ea 1c				call forth_push_str 
4693					NEXTW 
4693 c3 e5 1f			jp macro_next 
4696				endm 
# End of macro NEXTW
4696			 
4696			.EDIT: 
4696				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
4696 40				db WORD_SYS_CORE+44             
4697 1f 47			dw .ENDKEY            
4699 05				db 4 + 1 
469a .. 00			db "EDIT",0              
469f				endm 
# End of macro CWHEAD
469f			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
469f			 
469f					; TODO does not copy from stack 
469f					if DEBUG_FORTH_WORDS_KEY 
469f						DMARK "EDT" 
469f f5				push af  
46a0 3a b4 46			ld a, (.dmark)  
46a3 32 bd fb			ld (debug_mark),a  
46a6 3a b5 46			ld a, (.dmark+1)  
46a9 32 be fb			ld (debug_mark+1),a  
46ac 3a b6 46			ld a, (.dmark+2)  
46af 32 bf fb			ld (debug_mark+2),a  
46b2 18 03			jr .pastdmark  
46b4 ..			.dmark: db "EDT"  
46b7 f1			.pastdmark: pop af  
46b8			endm  
# End of macro DMARK
46b8						CALLMONITOR 
46b8 cd ec 16			call break_point_state  
46bb				endm  
# End of macro CALLMONITOR
46bb					endif 
46bb			 
46bb					FORTH_DSP 
46bb cd 39 1e			call macro_forth_dsp 
46be				endm 
# End of macro FORTH_DSP
46be					;v5 FORTH_DSP_VALUE 
46be 23					inc hl    ; TODO do type check 
46bf			 
46bf e5					push hl 
46c0 3e 00				ld a, 0 
46c2 cd 6f 11				call strlent 
46c5 23					inc hl 
46c6			 
46c6 06 00				ld b, 0 
46c8 4d					ld c, l 
46c9			 
46c9 e1					pop hl 
46ca 11 a1 f1				ld de, os_input 
46cd					if DEBUG_FORTH_WORDS_KEY 
46cd						DMARK "EDc" 
46cd f5				push af  
46ce 3a e2 46			ld a, (.dmark)  
46d1 32 bd fb			ld (debug_mark),a  
46d4 3a e3 46			ld a, (.dmark+1)  
46d7 32 be fb			ld (debug_mark+1),a  
46da 3a e4 46			ld a, (.dmark+2)  
46dd 32 bf fb			ld (debug_mark+2),a  
46e0 18 03			jr .pastdmark  
46e2 ..			.dmark: db "EDc"  
46e5 f1			.pastdmark: pop af  
46e6			endm  
# End of macro DMARK
46e6						CALLMONITOR 
46e6 cd ec 16			call break_point_state  
46e9				endm  
# End of macro CALLMONITOR
46e9					endif 
46e9 ed b0				ldir 
46eb			 
46eb			 
46eb 21 a1 f1				ld hl, os_input 
46ee					;ld a, 0 
46ee					;ld (hl),a 
46ee 3a cc f9				ld a,(f_cursor_ptr) 
46f1 16 64				ld d, 100 
46f3 0e 00				ld c, 0 
46f5 1e 28				ld e, 40 
46f7 cd 33 0d				call input_str 
46fa					; TODO perhaps do a type check and wrap in quotes if not a number 
46fa 21 a1 f1				ld hl, os_input 
46fd					if DEBUG_FORTH_WORDS 
46fd						DMARK "ED1" 
46fd f5				push af  
46fe 3a 12 47			ld a, (.dmark)  
4701 32 bd fb			ld (debug_mark),a  
4704 3a 13 47			ld a, (.dmark+1)  
4707 32 be fb			ld (debug_mark+1),a  
470a 3a 14 47			ld a, (.dmark+2)  
470d 32 bf fb			ld (debug_mark+2),a  
4710 18 03			jr .pastdmark  
4712 ..			.dmark: db "ED1"  
4715 f1			.pastdmark: pop af  
4716			endm  
# End of macro DMARK
4716						CALLMONITOR 
4716 cd ec 16			call break_point_state  
4719				endm  
# End of macro CALLMONITOR
4719					endif 
4719 cd ea 1c				call forth_push_str 
471c					NEXTW 
471c c3 e5 1f			jp macro_next 
471f				endm 
# End of macro NEXTW
471f			 
471f			 
471f			 
471f			.ENDKEY: 
471f			; eof 
471f			 
# End of file forth_words_key.asm
471f			 
471f			if STORAGE_SE 
471f			   	include "forth_words_storage.asm" 
471f			 
471f			; | ## Fixed Storage Words 
471f			 
471f			 
471f			.BREAD: 
471f			  
471f				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
471f 3a				db WORD_SYS_CORE+38             
4720 98 47			dw .BWRITE            
4722 06				db 5 + 1 
4723 .. 00			db "BREAD",0              
4729				endm 
# End of macro CWHEAD
4729			; | BREAD ( u -- u ) With the current bank, read a block from block address u (1-512) and push to stack  | DONE 
4729				 
4729					if DEBUG_FORTH_WORDS_KEY 
4729						DMARK "BRD" 
4729 f5				push af  
472a 3a 3e 47			ld a, (.dmark)  
472d 32 bd fb			ld (debug_mark),a  
4730 3a 3f 47			ld a, (.dmark+1)  
4733 32 be fb			ld (debug_mark+1),a  
4736 3a 40 47			ld a, (.dmark+2)  
4739 32 bf fb			ld (debug_mark+2),a  
473c 18 03			jr .pastdmark  
473e ..			.dmark: db "BRD"  
4741 f1			.pastdmark: pop af  
4742			endm  
# End of macro DMARK
4742						CALLMONITOR 
4742 cd ec 16			call break_point_state  
4745				endm  
# End of macro CALLMONITOR
4745					endif 
4745			 
4745				FORTH_DSP_VALUEHL 
4745 cd 73 1e			call macro_dsp_valuehl 
4748				endm 
# End of macro FORTH_DSP_VALUEHL
4748			 
4748				FORTH_DSP_POP 
4748 cd 2b 1f			call macro_forth_dsp_pop 
474b				endm 
# End of macro FORTH_DSP_POP
474b			 
474b				; calc block address 
474b			 
474b eb				ex de, hl 
474c 3e 40			ld a, STORE_BLOCK_PHY 
474e cd 89 0c			call Mult16 
4751			 
4751			 
4751 11 e8 f9			ld de, store_page 
4754			 
4754					if DEBUG_FORTH_WORDS 
4754						DMARK "BR1" 
4754 f5				push af  
4755 3a 69 47			ld a, (.dmark)  
4758 32 bd fb			ld (debug_mark),a  
475b 3a 6a 47			ld a, (.dmark+1)  
475e 32 be fb			ld (debug_mark+1),a  
4761 3a 6b 47			ld a, (.dmark+2)  
4764 32 bf fb			ld (debug_mark+2),a  
4767 18 03			jr .pastdmark  
4769 ..			.dmark: db "BR1"  
476c f1			.pastdmark: pop af  
476d			endm  
# End of macro DMARK
476d						CALLMONITOR 
476d cd ec 16			call break_point_state  
4770				endm  
# End of macro CALLMONITOR
4770					endif 
4770			 
4770 cd 09 03			call storage_read_block 
4773			 
4773 21 ea f9		        ld hl, store_page+2 
4776					if DEBUG_FORTH_WORDS 
4776						DMARK "BR2" 
4776 f5				push af  
4777 3a 8b 47			ld a, (.dmark)  
477a 32 bd fb			ld (debug_mark),a  
477d 3a 8c 47			ld a, (.dmark+1)  
4780 32 be fb			ld (debug_mark+1),a  
4783 3a 8d 47			ld a, (.dmark+2)  
4786 32 bf fb			ld (debug_mark+2),a  
4789 18 03			jr .pastdmark  
478b ..			.dmark: db "BR2"  
478e f1			.pastdmark: pop af  
478f			endm  
# End of macro DMARK
478f						CALLMONITOR 
478f cd ec 16			call break_point_state  
4792				endm  
# End of macro CALLMONITOR
4792					endif 
4792 cd ea 1c			call forth_push_str 
4795			 
4795			 
4795					NEXTW 
4795 c3 e5 1f			jp macro_next 
4798				endm 
# End of macro NEXTW
4798			.BWRITE: 
4798				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
4798 3a				db WORD_SYS_CORE+38             
4799 2d 48			dw .BUPD            
479b 07				db 6 + 1 
479c .. 00			db "BWRITE",0              
47a3				endm 
# End of macro CWHEAD
47a3			; | BWRITE ( s u -- ) With the current bank, write the string s to address u | DONE 
47a3			 
47a3					if DEBUG_FORTH_WORDS_KEY 
47a3						DMARK "BWR" 
47a3 f5				push af  
47a4 3a b8 47			ld a, (.dmark)  
47a7 32 bd fb			ld (debug_mark),a  
47aa 3a b9 47			ld a, (.dmark+1)  
47ad 32 be fb			ld (debug_mark+1),a  
47b0 3a ba 47			ld a, (.dmark+2)  
47b3 32 bf fb			ld (debug_mark+2),a  
47b6 18 03			jr .pastdmark  
47b8 ..			.dmark: db "BWR"  
47bb f1			.pastdmark: pop af  
47bc			endm  
# End of macro DMARK
47bc						CALLMONITOR 
47bc cd ec 16			call break_point_state  
47bf				endm  
# End of macro CALLMONITOR
47bf					endif 
47bf			 
47bf				FORTH_DSP_VALUEHL 
47bf cd 73 1e			call macro_dsp_valuehl 
47c2				endm 
# End of macro FORTH_DSP_VALUEHL
47c2			 
47c2				; calc block address 
47c2			 
47c2 eb				ex de, hl 
47c3 3e 40			ld a, STORE_BLOCK_PHY 
47c5 cd 89 0c			call Mult16 
47c8			 
47c8 e5				push hl         ; address 
47c9			 
47c9				FORTH_DSP_POP 
47c9 cd 2b 1f			call macro_forth_dsp_pop 
47cc				endm 
# End of macro FORTH_DSP_POP
47cc			 
47cc				FORTH_DSP_VALUEHL 
47cc cd 73 1e			call macro_dsp_valuehl 
47cf				endm 
# End of macro FORTH_DSP_VALUEHL
47cf			 
47cf				FORTH_DSP_POP 
47cf cd 2b 1f			call macro_forth_dsp_pop 
47d2				endm 
# End of macro FORTH_DSP_POP
47d2			 
47d2 cd 15 0a			call storage_clear_page 
47d5			 
47d5				; copy string to store page 
47d5			 
47d5 e5				push hl     ; save string address 
47d6			 
47d6 3e 00			ld a, 0 
47d8 cd 6f 11			call strlent 
47db			 
47db 23				inc hl 
47dc			 
47dc 4d				ld c, l 
47dd 06 00			ld b, 0 
47df			 
47df e1				pop hl 
47e0 11 ea f9			ld de, store_page + 2 
47e3					if DEBUG_FORTH_WORDS 
47e3						DMARK "BW1" 
47e3 f5				push af  
47e4 3a f8 47			ld a, (.dmark)  
47e7 32 bd fb			ld (debug_mark),a  
47ea 3a f9 47			ld a, (.dmark+1)  
47ed 32 be fb			ld (debug_mark+1),a  
47f0 3a fa 47			ld a, (.dmark+2)  
47f3 32 bf fb			ld (debug_mark+2),a  
47f6 18 03			jr .pastdmark  
47f8 ..			.dmark: db "BW1"  
47fb f1			.pastdmark: pop af  
47fc			endm  
# End of macro DMARK
47fc						CALLMONITOR 
47fc cd ec 16			call break_point_state  
47ff				endm  
# End of macro CALLMONITOR
47ff					endif 
47ff ed b0			ldir 
4801			 
4801			 
4801				; poke the start of the block with flags to prevent high level file ops hitting the block 
4801			 
4801 21 ff ff			ld hl, $ffff 
4804			 
4804 22 e8 f9			ld (store_page), hl	 
4807				 
4807 e1				pop hl    ; get address 
4808 11 e8 f9			ld de, store_page 
480b			 
480b					if DEBUG_FORTH_WORDS 
480b						DMARK "BW2" 
480b f5				push af  
480c 3a 20 48			ld a, (.dmark)  
480f 32 bd fb			ld (debug_mark),a  
4812 3a 21 48			ld a, (.dmark+1)  
4815 32 be fb			ld (debug_mark+1),a  
4818 3a 22 48			ld a, (.dmark+2)  
481b 32 bf fb			ld (debug_mark+2),a  
481e 18 03			jr .pastdmark  
4820 ..			.dmark: db "BW2"  
4823 f1			.pastdmark: pop af  
4824			endm  
# End of macro DMARK
4824						CALLMONITOR 
4824 cd ec 16			call break_point_state  
4827				endm  
# End of macro CALLMONITOR
4827					endif 
4827			 
4827 cd 6e 03			call storage_write_block 
482a			 
482a					NEXTW 
482a c3 e5 1f			jp macro_next 
482d				endm 
# End of macro NEXTW
482d			 
482d			.BUPD: 
482d				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
482d 3a				db WORD_SYS_CORE+38             
482e 83 48			dw .BYID            
4830 05				db 4 + 1 
4831 .. 00			db "BUPD",0              
4836				endm 
# End of macro CWHEAD
4836			; | BUPD ( u -- ) Write the contents of the current file system storage buffer directly to address u | DONE 
4836			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
4836			; | | or completely different file system structure. 
4836			 
4836					if DEBUG_FORTH_WORDS_KEY 
4836						DMARK "BUD" 
4836 f5				push af  
4837 3a 4b 48			ld a, (.dmark)  
483a 32 bd fb			ld (debug_mark),a  
483d 3a 4c 48			ld a, (.dmark+1)  
4840 32 be fb			ld (debug_mark+1),a  
4843 3a 4d 48			ld a, (.dmark+2)  
4846 32 bf fb			ld (debug_mark+2),a  
4849 18 03			jr .pastdmark  
484b ..			.dmark: db "BUD"  
484e f1			.pastdmark: pop af  
484f			endm  
# End of macro DMARK
484f						CALLMONITOR 
484f cd ec 16			call break_point_state  
4852				endm  
# End of macro CALLMONITOR
4852					endif 
4852			 
4852				FORTH_DSP_VALUEHL 
4852 cd 73 1e			call macro_dsp_valuehl 
4855				endm 
# End of macro FORTH_DSP_VALUEHL
4855			 
4855				; calc block address 
4855			 
4855 eb				ex de, hl 
4856 3e 40			ld a, STORE_BLOCK_PHY 
4858 cd 89 0c			call Mult16 
485b			 
485b				FORTH_DSP_POP 
485b cd 2b 1f			call macro_forth_dsp_pop 
485e				endm 
# End of macro FORTH_DSP_POP
485e			 
485e			 
485e 11 e8 f9			ld de, store_page 
4861			 
4861					if DEBUG_FORTH_WORDS 
4861						DMARK "BUe" 
4861 f5				push af  
4862 3a 76 48			ld a, (.dmark)  
4865 32 bd fb			ld (debug_mark),a  
4868 3a 77 48			ld a, (.dmark+1)  
486b 32 be fb			ld (debug_mark+1),a  
486e 3a 78 48			ld a, (.dmark+2)  
4871 32 bf fb			ld (debug_mark+2),a  
4874 18 03			jr .pastdmark  
4876 ..			.dmark: db "BUe"  
4879 f1			.pastdmark: pop af  
487a			endm  
# End of macro DMARK
487a						CALLMONITOR 
487a cd ec 16			call break_point_state  
487d				endm  
# End of macro CALLMONITOR
487d					endif 
487d			 
487d cd 6e 03			call storage_write_block 
4880			 
4880					NEXTW 
4880 c3 e5 1f			jp macro_next 
4883				endm 
# End of macro NEXTW
4883			 
4883			.BYID: 
4883			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
4883			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
4883			; 
4883			;		 
4883			;		if DEBUG_FORTH_WORDS_KEY 
4883			;			DMARK "BYID" 
4883			;			CALLMONITOR 
4883			;		endif 
4883			; 
4883			;		; get direct address 
4883			; 
4883			;		FORTH_DSP_VALUEHL 
4883			; 
4883			;		FORTH_DSP_POP 
4883			; 
4883			;	; calc block address 
4883			; 
4883			;	ex de, hl 
4883			;	ld a, STORE_BLOCK_PHY 
4883			;	call Mult16 
4883			;	;	do BREAD with number as param 
4883			;	; push the file name	 
4883			;	ld de, store_page 
4883			;	call storage_read_block 
4883			 ;       ld hl, store_page+2 
4883			; 
4883			; 
4883			;		NEXTW 
4883			;.BYNAME: 
4883			;	CWHEAD .DIR 38 "BYNAME" 6 WORD_FLAG_CODE 
4883			;; > BYNAME ( s -- u ) Get the file ID in the current BANK of the file named s > TODO 
4883			;		NEXTW 
4883			; 
4883			.DIR: 
4883				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
4883 3a				db WORD_SYS_CORE+38             
4884 87 49			dw .SAVE            
4886 04				db 3 + 1 
4887 .. 00			db "DIR",0              
488b				endm 
# End of macro CWHEAD
488b			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
488b			 
488b					if DEBUG_FORTH_WORDS_KEY 
488b						DMARK "DIR" 
488b f5				push af  
488c 3a a0 48			ld a, (.dmark)  
488f 32 bd fb			ld (debug_mark),a  
4892 3a a1 48			ld a, (.dmark+1)  
4895 32 be fb			ld (debug_mark+1),a  
4898 3a a2 48			ld a, (.dmark+2)  
489b 32 bf fb			ld (debug_mark+2),a  
489e 18 03			jr .pastdmark  
48a0 ..			.dmark: db "DIR"  
48a3 f1			.pastdmark: pop af  
48a4			endm  
# End of macro DMARK
48a4						CALLMONITOR 
48a4 cd ec 16			call break_point_state  
48a7				endm  
# End of macro CALLMONITOR
48a7					endif 
48a7 cd ba 03			call storage_get_block_0 
48aa			 
48aa 21 e8 f9			ld hl, store_page     ; get current id count 
48ad 46				ld b, (hl) 
48ae 0e 00			ld c, 0    ; count of files   
48b0					if DEBUG_FORTH_WORDS 
48b0						DMARK "DI1" 
48b0 f5				push af  
48b1 3a c5 48			ld a, (.dmark)  
48b4 32 bd fb			ld (debug_mark),a  
48b7 3a c6 48			ld a, (.dmark+1)  
48ba 32 be fb			ld (debug_mark+1),a  
48bd 3a c7 48			ld a, (.dmark+2)  
48c0 32 bf fb			ld (debug_mark+2),a  
48c3 18 03			jr .pastdmark  
48c5 ..			.dmark: db "DI1"  
48c8 f1			.pastdmark: pop af  
48c9			endm  
# End of macro DMARK
48c9						CALLMONITOR 
48c9 cd ec 16			call break_point_state  
48cc				endm  
# End of macro CALLMONITOR
48cc					endif 
48cc			 
48cc				; check for empty drive 
48cc			 
48cc 3e 00			ld a, 0 
48ce b8				cp b 
48cf ca 3d 49			jp z, .dirdone 
48d2			 
48d2				; for each of the current ids do a search for them and if found push to stack 
48d2			 
48d2 c5			.diritem:	push bc 
48d3 21 40 00				ld hl, STORE_BLOCK_PHY 
48d6 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
48d8 58					ld e,b 
48d9			 
48d9			;		if DEBUG_FORTH_WORDS 
48d9			;			DMARK "DI2" 
48d9			;			CALLMONITOR 
48d9			;		endif 
48d9			 
48d9 cd 2a 06				call storage_findnextid 
48dc			 
48dc			;		if DEBUG_FORTH_WORDS 
48dc			;			DMARK "DI3" 
48dc			;			CALLMONITOR 
48dc			;		endif 
48dc			 
48dc					; if found hl will be non zero 
48dc			 
48dc cd 2f 0d				call ishlzero 
48df			;		ld a, l 
48df			;		add h 
48df			; 
48df			;		cp 0 
48df 28 59				jr z, .dirnotfound 
48e1			 
48e1					; increase count 
48e1			 
48e1 c1					pop bc	 
48e2 0c					inc c 
48e3 c5					push bc 
48e4					 
48e4			 
48e4					; get file header and push the file name 
48e4			 
48e4 11 e8 f9				ld de, store_page 
48e7 cd 09 03				call storage_read_block 
48ea			 
48ea					; push file id to stack 
48ea				 
48ea 3a e8 f9				ld a, (store_page) 
48ed 26 00				ld h, 0 
48ef 6f					ld l, a 
48f0 cd 7c 1c				call forth_push_numhl 
48f3			 
48f3					; push extent count to stack  
48f3				 
48f3 3a ea f9				ld a, (store_page+2) 
48f6 26 00				ld h, 0 
48f8 6f					ld l, a 
48f9 cd 7c 1c				call forth_push_numhl 
48fc			 
48fc					; push file name 
48fc			 
48fc 21 eb f9				ld hl, store_page+3 
48ff					if DEBUG_FORTH_WORDS 
48ff						DMARK "DI5" 
48ff f5				push af  
4900 3a 14 49			ld a, (.dmark)  
4903 32 bd fb			ld (debug_mark),a  
4906 3a 15 49			ld a, (.dmark+1)  
4909 32 be fb			ld (debug_mark+1),a  
490c 3a 16 49			ld a, (.dmark+2)  
490f 32 bf fb			ld (debug_mark+2),a  
4912 18 03			jr .pastdmark  
4914 ..			.dmark: db "DI5"  
4917 f1			.pastdmark: pop af  
4918			endm  
# End of macro DMARK
4918						CALLMONITOR 
4918 cd ec 16			call break_point_state  
491b				endm  
# End of macro CALLMONITOR
491b					endif 
491b cd ea 1c				call forth_push_str 
491e					if DEBUG_FORTH_WORDS 
491e						DMARK "DI6" 
491e f5				push af  
491f 3a 33 49			ld a, (.dmark)  
4922 32 bd fb			ld (debug_mark),a  
4925 3a 34 49			ld a, (.dmark+1)  
4928 32 be fb			ld (debug_mark+1),a  
492b 3a 35 49			ld a, (.dmark+2)  
492e 32 bf fb			ld (debug_mark+2),a  
4931 18 03			jr .pastdmark  
4933 ..			.dmark: db "DI6"  
4936 f1			.pastdmark: pop af  
4937			endm  
# End of macro DMARK
4937						CALLMONITOR 
4937 cd ec 16			call break_point_state  
493a				endm  
# End of macro CALLMONITOR
493a					endif 
493a			.dirnotfound: 
493a c1					pop bc     
493b 10 95				djnz .diritem 
493d				 
493d			.dirdone:	 
493d					if DEBUG_FORTH_WORDS 
493d						DMARK "DI7" 
493d f5				push af  
493e 3a 52 49			ld a, (.dmark)  
4941 32 bd fb			ld (debug_mark),a  
4944 3a 53 49			ld a, (.dmark+1)  
4947 32 be fb			ld (debug_mark+1),a  
494a 3a 54 49			ld a, (.dmark+2)  
494d 32 bf fb			ld (debug_mark+2),a  
4950 18 03			jr .pastdmark  
4952 ..			.dmark: db "DI7"  
4955 f1			.pastdmark: pop af  
4956			endm  
# End of macro DMARK
4956						CALLMONITOR 
4956 cd ec 16			call break_point_state  
4959				endm  
# End of macro CALLMONITOR
4959					endif 
4959			 
4959					; push a count of the dir items found 
4959			 
4959 26 00				ld h, 0 
495b 69					ld l, c 
495c cd 7c 1c				call forth_push_numhl 
495f			 
495f					; push the bank label 
495f			 
495f cd ba 03				call storage_get_block_0 
4962			 
4962				 
4962 21 eb f9		 		ld hl, store_page+3 
4965			 
4965					if DEBUG_FORTH_WORDS 
4965						DMARK "DI8" 
4965 f5				push af  
4966 3a 7a 49			ld a, (.dmark)  
4969 32 bd fb			ld (debug_mark),a  
496c 3a 7b 49			ld a, (.dmark+1)  
496f 32 be fb			ld (debug_mark+1),a  
4972 3a 7c 49			ld a, (.dmark+2)  
4975 32 bf fb			ld (debug_mark+2),a  
4978 18 03			jr .pastdmark  
497a ..			.dmark: db "DI8"  
497d f1			.pastdmark: pop af  
497e			endm  
# End of macro DMARK
497e						CALLMONITOR 
497e cd ec 16			call break_point_state  
4981				endm  
# End of macro CALLMONITOR
4981					endif 
4981 cd ea 1c				call forth_push_str 
4984			 
4984			 
4984				 
4984					NEXTW 
4984 c3 e5 1f			jp macro_next 
4987				endm 
# End of macro NEXTW
4987			.SAVE: 
4987			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
4987			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
4987			;		NEXTW 
4987			;.LOAD: 
4987			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
4987			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
4987			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
4987			;; > > The LOAD command can not be used in any user words or compound lines. 
4987			; 
4987			;		; store_openext use it. If zero it is EOF 
4987			; 
4987			;		; read block from current stream id 
4987			;		; if the block does not contain zero term keep reading blocks until zero found 
4987			;		; push the block to stack 
4987			;		; save the block id to stream 
4987			; 
4987			; 
4987			;		FORTH_DSP_VALUEHL 
4987			; 
4987			;;		push hl 
4987			; 
4987			;	if DEBUG_STORESE 
4987			;		DMARK "LOA" 
4987			;		CALLMONITOR 
4987			;	endif 
4987			;		FORTH_DSP_POP 
4987			; 
4987			;;		pop hl 
4987			; 
4987			;		ld h, l 
4987			;		ld l, 0 
4987			; 
4987			;		push hl     ; stack holds current file id and extent to work with 
4987			; 
4987			; 
4987			;		ld de, store_page      ; get block zero of file 
4987			;	if DEBUG_STORESE 
4987			;		DMARK "LO0" 
4987			;		CALLMONITOR 
4987			;	endif 
4987			;		call storage_read 
4987			; 
4987			;		ld a, (store_page+2)    ; max extents for this file 
4987			;		ld  (store_openmaxext),a   ; get our limit 
4987			; 
4987			;	if DEBUG_STORESE 
4987			;		DMARK "LOE" 
4987			;		CALLMONITOR 
4987			;	endif 
4987			; 
4987			;; TODO dont know why max extents are not present 
4987			;;		cp 0 
4987			;;		jp z, .loadeof     ; dont read past eof 
4987			; 
4987			;;		ld a, 1   ; start from the head of the file 
4987			; 
4987			;.loadline:	pop hl 
4987			;		inc hl 
4987			;		ld  a, (store_openmaxext)   ; get our limit 
4987			;	if DEBUG_STORESE 
4987			;		DMARK "LOx" 
4987			;		CALLMONITOR 
4987			;	endif 
4987			;		inc a 
4987			;		cp l 
4987			;		jp z, .loadeof 
4987			;		push hl    ; save current extent 
4987			; 
4987			;		ld de, store_page 
4987			; 
4987			;	if DEBUG_STORESE 
4987			;		DMARK "LO1" 
4987			;		CALLMONITOR 
4987			;	endif 
4987			;		call storage_read 
4987			; 
4987			;	if DEBUG_STORESE 
4987			;		DMARK "LO2" 
4987			;		CALLMONITOR 
4987			;	endif 
4987			;	call ishlzero 
4987			;	ld a, l 
4987			;	add h 
4987			;	cp 0 
4987			;	jr z, .loadeof 
4987			; 
4987			;	; not eof so hl should point to data to exec 
4987			; 
4987			;	; will need to add the FORTH_END_BUFFER flag 
4987			 ; 
4987			;	ld hl, store_page+2 
4987			;	ld bc, 255 
4987			;	ld a, 0 
4987			;	cpir 
4987			;	if DEBUG_STORESE 
4987			;		DMARK "LOt" 
4987			;		CALLMONITOR 
4987			;	endif 
4987			;	dec hl 
4987			;	ld a, ' ' 
4987			;	ld (hl), a 
4987			;	inc hl 
4987			;	ld (hl), a 
4987			;	inc hl 
4987			;	ld (hl), a 
4987			;	inc hl 
4987			;	ld a, FORTH_END_BUFFER 
4987			;	ld (hl), a 
4987			; 
4987			;	; TODO handle more than a single block read 
4987			; 
4987			; 
4987			;	ld hl, store_page+2 
4987			; 
4987			;	ld (os_tok_ptr), hl 
4987			; 
4987			;	if DEBUG_STORESE 
4987			;		DMARK "LO3" 
4987			;		CALLMONITOR 
4987			;	endif 
4987			; 
4987			;	call forthparse 
4987			;	call forthexec 
4987			;	call forthexec_cleanup 
4987			; 
4987			;	; go to next extent 
4987			; 
4987			;	; get next block  or mark as eof 
4987			;	jp .loadline 
4987			; 
4987			; 
4987			; 
4987			;	       NEXTW 
4987			;.loadeof:	ld a, 0 
4987			;		ld (store_openext), a 
4987			; 
4987			;	if DEBUG_STORESE 
4987			;		DMARK "LOF" 
4987			;		CALLMONITOR 
4987			;	endif 
4987			;		ret 
4987			;		;NEXTW 
4987			;.BSAVE:   
4987			; 
4987			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
4987			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
4987			;		NEXTW 
4987			;.BLOAD: 
4987			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
4987			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
4987			;		NEXTW 
4987			;;;; counter gap 
4987			 
4987			 
4987			.SEO: 
4987				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
4987 64				db WORD_SYS_CORE+80             
4988 a6 49			dw .SEI            
498a 04				db 3 + 1 
498b .. 00			db "SEO",0              
498f				endm 
# End of macro CWHEAD
498f			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
498f			 
498f					; get port 
498f			 
498f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
498f cd 73 1e			call macro_dsp_valuehl 
4992				endm 
# End of macro FORTH_DSP_VALUEHL
4992			 
4992 e5					push hl    ; u2 - byte 
4993			 
4993					; destroy value TOS 
4993			 
4993					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4993 cd 2b 1f			call macro_forth_dsp_pop 
4996				endm 
# End of macro FORTH_DSP_POP
4996			 
4996					; get byte to send 
4996			 
4996					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4996 cd 73 1e			call macro_dsp_valuehl 
4999				endm 
# End of macro FORTH_DSP_VALUEHL
4999			 
4999 e5					push hl    ; u1 - addr 
499a			 
499a					; destroy value TOS 
499a			 
499a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
499a cd 2b 1f			call macro_forth_dsp_pop 
499d				endm 
# End of macro FORTH_DSP_POP
499d			 
499d					; one value on hl get other one back 
499d			 
499d d1					pop de   ; u1 - byte 
499e			 
499e e1					pop hl   ; u2 - addr 
499f			 
499f					; TODO Send SPI byte 
499f			 
499f			 
499f 7b					ld a, e 
49a0 cd e7 01				call se_writebyte 
49a3			 
49a3					 
49a3			 
49a3					NEXTW 
49a3 c3 e5 1f			jp macro_next 
49a6				endm 
# End of macro NEXTW
49a6			 
49a6			.SEI: 
49a6				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
49a6 65				db WORD_SYS_CORE+81             
49a7 c0 49			dw .SFREE            
49a9 04				db 3 + 1 
49aa .. 00			db "SEI",0              
49ae				endm 
# End of macro CWHEAD
49ae			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
49ae			 
49ae					; get port 
49ae			 
49ae					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
49ae cd 73 1e			call macro_dsp_valuehl 
49b1				endm 
# End of macro FORTH_DSP_VALUEHL
49b1			 
49b1			;		push hl 
49b1			 
49b1					; destroy value TOS 
49b1			 
49b1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
49b1 cd 2b 1f			call macro_forth_dsp_pop 
49b4				endm 
# End of macro FORTH_DSP_POP
49b4			 
49b4					; one value on hl get other one back 
49b4			 
49b4			;		pop hl 
49b4			 
49b4			 
49b4					; TODO Get SPI byte 
49b4			 
49b4 cd 89 02				call se_readbyte 
49b7			 
49b7 26 00				ld h, 0 
49b9 6f					ld l, a 
49ba cd 7c 1c				call forth_push_numhl 
49bd			 
49bd					NEXTW 
49bd c3 e5 1f			jp macro_next 
49c0				endm 
# End of macro NEXTW
49c0			 
49c0			.SFREE: 
49c0				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
49c0 67				db WORD_SYS_CORE+83             
49c1 ef 49			dw .SIZE            
49c3 06				db 5 + 1 
49c4 .. 00			db "FFREE",0              
49ca				endm 
# End of macro CWHEAD
49ca			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
49ca					if DEBUG_FORTH_WORDS_KEY 
49ca						DMARK "FFR" 
49ca f5				push af  
49cb 3a df 49			ld a, (.dmark)  
49ce 32 bd fb			ld (debug_mark),a  
49d1 3a e0 49			ld a, (.dmark+1)  
49d4 32 be fb			ld (debug_mark+1),a  
49d7 3a e1 49			ld a, (.dmark+2)  
49da 32 bf fb			ld (debug_mark+2),a  
49dd 18 03			jr .pastdmark  
49df ..			.dmark: db "FFR"  
49e2 f1			.pastdmark: pop af  
49e3			endm  
# End of macro DMARK
49e3						CALLMONITOR 
49e3 cd ec 16			call break_point_state  
49e6				endm  
# End of macro CALLMONITOR
49e6					endif 
49e6			 
49e6 cd c4 06				call storage_freeblocks 
49e9			 
49e9 cd 7c 1c				call forth_push_numhl 
49ec			 
49ec				       NEXTW 
49ec c3 e5 1f			jp macro_next 
49ef				endm 
# End of macro NEXTW
49ef			.SIZE: 
49ef				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
49ef 67				db WORD_SYS_CORE+83             
49f0 23 4a			dw .CREATE            
49f2 05				db 4 + 1 
49f3 .. 00			db "SIZE",0              
49f8				endm 
# End of macro CWHEAD
49f8			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
49f8					if DEBUG_FORTH_WORDS_KEY 
49f8						DMARK "SIZ" 
49f8 f5				push af  
49f9 3a 0d 4a			ld a, (.dmark)  
49fc 32 bd fb			ld (debug_mark),a  
49ff 3a 0e 4a			ld a, (.dmark+1)  
4a02 32 be fb			ld (debug_mark+1),a  
4a05 3a 0f 4a			ld a, (.dmark+2)  
4a08 32 bf fb			ld (debug_mark+2),a  
4a0b 18 03			jr .pastdmark  
4a0d ..			.dmark: db "SIZ"  
4a10 f1			.pastdmark: pop af  
4a11			endm  
# End of macro DMARK
4a11						CALLMONITOR 
4a11 cd ec 16			call break_point_state  
4a14				endm  
# End of macro CALLMONITOR
4a14					endif 
4a14			 
4a14					FORTH_DSP_VALUEHL 
4a14 cd 73 1e			call macro_dsp_valuehl 
4a17				endm 
# End of macro FORTH_DSP_VALUEHL
4a17			;		push hl 
4a17					FORTH_DSP_POP 
4a17 cd 2b 1f			call macro_forth_dsp_pop 
4a1a				endm 
# End of macro FORTH_DSP_POP
4a1a			;		pop hl 
4a1a cd 38 03				call storage_file_size 
4a1d			 
4a1d cd 7c 1c				call forth_push_numhl 
4a20			  
4a20			 
4a20				       NEXTW 
4a20 c3 e5 1f			jp macro_next 
4a23				endm 
# End of macro NEXTW
4a23			 
4a23			.CREATE: 
4a23				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
4a23 68				db WORD_SYS_CORE+84             
4a24 91 4a			dw .APPEND            
4a26 07				db 6 + 1 
4a27 .. 00			db "CREATE",0              
4a2e				endm 
# End of macro CWHEAD
4a2e			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
4a2e			; | | e.g.  
4a2e			; | | TestProgram CREATE 
4a2e			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
4a2e			; | |  
4a2e			; | | Max file IDs are 255. 
4a2e			; | |  
4a2e					 
4a2e					if DEBUG_FORTH_WORDS_KEY 
4a2e						DMARK "CRT" 
4a2e f5				push af  
4a2f 3a 43 4a			ld a, (.dmark)  
4a32 32 bd fb			ld (debug_mark),a  
4a35 3a 44 4a			ld a, (.dmark+1)  
4a38 32 be fb			ld (debug_mark+1),a  
4a3b 3a 45 4a			ld a, (.dmark+2)  
4a3e 32 bf fb			ld (debug_mark+2),a  
4a41 18 03			jr .pastdmark  
4a43 ..			.dmark: db "CRT"  
4a46 f1			.pastdmark: pop af  
4a47			endm  
# End of macro DMARK
4a47						CALLMONITOR 
4a47 cd ec 16			call break_point_state  
4a4a				endm  
# End of macro CALLMONITOR
4a4a					endif 
4a4a			;		call storage_get_block_0 
4a4a			 
4a4a					; TODO pop hl 
4a4a			 
4a4a					;v5 FORTH_DSP_VALUE 
4a4a					FORTH_DSP_VALUE 
4a4a cd 5c 1e			call macro_forth_dsp_value 
4a4d				endm 
# End of macro FORTH_DSP_VALUE
4a4d			 
4a4d				if DEBUG_STORESE 
4a4d					DMARK "CR1" 
4a4d f5				push af  
4a4e 3a 62 4a			ld a, (.dmark)  
4a51 32 bd fb			ld (debug_mark),a  
4a54 3a 63 4a			ld a, (.dmark+1)  
4a57 32 be fb			ld (debug_mark+1),a  
4a5a 3a 64 4a			ld a, (.dmark+2)  
4a5d 32 bf fb			ld (debug_mark+2),a  
4a60 18 03			jr .pastdmark  
4a62 ..			.dmark: db "CR1"  
4a65 f1			.pastdmark: pop af  
4a66			endm  
# End of macro DMARK
4a66					CALLMONITOR 
4a66 cd ec 16			call break_point_state  
4a69				endm  
# End of macro CALLMONITOR
4a69				endif 
4a69			;		push hl 
4a69			;		FORTH_DSP_POP 
4a69			;		pop hl 
4a69			 
4a69			;		inc hl   ; move past the type marker 
4a69			 
4a69 cd fa 06				call storage_create 
4a6c			 
4a6c				if DEBUG_STORESE 
4a6c					DMARK "CT1" 
4a6c f5				push af  
4a6d 3a 81 4a			ld a, (.dmark)  
4a70 32 bd fb			ld (debug_mark),a  
4a73 3a 82 4a			ld a, (.dmark+1)  
4a76 32 be fb			ld (debug_mark+1),a  
4a79 3a 83 4a			ld a, (.dmark+2)  
4a7c 32 bf fb			ld (debug_mark+2),a  
4a7f 18 03			jr .pastdmark  
4a81 ..			.dmark: db "CT1"  
4a84 f1			.pastdmark: pop af  
4a85			endm  
# End of macro DMARK
4a85					CALLMONITOR 
4a85 cd ec 16			call break_point_state  
4a88				endm  
# End of macro CALLMONITOR
4a88				endif 
4a88			;		push hl 
4a88					FORTH_DSP_POP 
4a88 cd 2b 1f			call macro_forth_dsp_pop 
4a8b				endm 
# End of macro FORTH_DSP_POP
4a8b			;		pop hl 
4a8b					; push file id to stack 
4a8b cd 7c 1c				call forth_push_numhl 
4a8e			 
4a8e			 
4a8e			 
4a8e				       NEXTW 
4a8e c3 e5 1f			jp macro_next 
4a91				endm 
# End of macro NEXTW
4a91			 
4a91			.APPEND: 
4a91				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
4a91 69				db WORD_SYS_CORE+85             
4a92 22 4b			dw .SDEL            
4a94 07				db 6 + 1 
4a95 .. 00			db "APPEND",0              
4a9c				endm 
# End of macro CWHEAD
4a9c			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
4a9c			; | | e.g. 
4a9c			; | | Test CREATE      -> $01 
4a9c			; | | "A string to add to file" $01 APPEND 
4a9c			; | |  
4a9c			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
4a9c					if DEBUG_FORTH_WORDS_KEY 
4a9c						DMARK "APP" 
4a9c f5				push af  
4a9d 3a b1 4a			ld a, (.dmark)  
4aa0 32 bd fb			ld (debug_mark),a  
4aa3 3a b2 4a			ld a, (.dmark+1)  
4aa6 32 be fb			ld (debug_mark+1),a  
4aa9 3a b3 4a			ld a, (.dmark+2)  
4aac 32 bf fb			ld (debug_mark+2),a  
4aaf 18 03			jr .pastdmark  
4ab1 ..			.dmark: db "APP"  
4ab4 f1			.pastdmark: pop af  
4ab5			endm  
# End of macro DMARK
4ab5						CALLMONITOR 
4ab5 cd ec 16			call break_point_state  
4ab8				endm  
# End of macro CALLMONITOR
4ab8					endif 
4ab8			 
4ab8					FORTH_DSP_VALUEHL 
4ab8 cd 73 1e			call macro_dsp_valuehl 
4abb				endm 
# End of macro FORTH_DSP_VALUEHL
4abb e5					push hl 	; save file id 
4abc			 
4abc				if DEBUG_STORESE 
4abc					DMARK "AP1" 
4abc f5				push af  
4abd 3a d1 4a			ld a, (.dmark)  
4ac0 32 bd fb			ld (debug_mark),a  
4ac3 3a d2 4a			ld a, (.dmark+1)  
4ac6 32 be fb			ld (debug_mark+1),a  
4ac9 3a d3 4a			ld a, (.dmark+2)  
4acc 32 bf fb			ld (debug_mark+2),a  
4acf 18 03			jr .pastdmark  
4ad1 ..			.dmark: db "AP1"  
4ad4 f1			.pastdmark: pop af  
4ad5			endm  
# End of macro DMARK
4ad5					CALLMONITOR 
4ad5 cd ec 16			call break_point_state  
4ad8				endm  
# End of macro CALLMONITOR
4ad8				endif 
4ad8					FORTH_DSP_POP 
4ad8 cd 2b 1f			call macro_forth_dsp_pop 
4adb				endm 
# End of macro FORTH_DSP_POP
4adb			 
4adb					FORTH_DSP_VALUEHL 
4adb cd 73 1e			call macro_dsp_valuehl 
4ade				endm 
# End of macro FORTH_DSP_VALUEHL
4ade					;v5 FORTH_DSP_VALUE 
4ade e5					push hl 	; save ptr to string to save 
4adf			 
4adf				if DEBUG_STORESE 
4adf					DMARK "AP1" 
4adf f5				push af  
4ae0 3a f4 4a			ld a, (.dmark)  
4ae3 32 bd fb			ld (debug_mark),a  
4ae6 3a f5 4a			ld a, (.dmark+1)  
4ae9 32 be fb			ld (debug_mark+1),a  
4aec 3a f6 4a			ld a, (.dmark+2)  
4aef 32 bf fb			ld (debug_mark+2),a  
4af2 18 03			jr .pastdmark  
4af4 ..			.dmark: db "AP1"  
4af7 f1			.pastdmark: pop af  
4af8			endm  
# End of macro DMARK
4af8					CALLMONITOR 
4af8 cd ec 16			call break_point_state  
4afb				endm  
# End of macro CALLMONITOR
4afb				endif 
4afb					FORTH_DSP_POP 
4afb cd 2b 1f			call macro_forth_dsp_pop 
4afe				endm 
# End of macro FORTH_DSP_POP
4afe			 
4afe d1					pop de 
4aff e1					pop hl 
4b00				if DEBUG_STORESE 
4b00					DMARK "AP2" 
4b00 f5				push af  
4b01 3a 15 4b			ld a, (.dmark)  
4b04 32 bd fb			ld (debug_mark),a  
4b07 3a 16 4b			ld a, (.dmark+1)  
4b0a 32 be fb			ld (debug_mark+1),a  
4b0d 3a 17 4b			ld a, (.dmark+2)  
4b10 32 bf fb			ld (debug_mark+2),a  
4b13 18 03			jr .pastdmark  
4b15 ..			.dmark: db "AP2"  
4b18 f1			.pastdmark: pop af  
4b19			endm  
# End of macro DMARK
4b19					CALLMONITOR 
4b19 cd ec 16			call break_point_state  
4b1c				endm  
# End of macro CALLMONITOR
4b1c				endif 
4b1c					;inc de ; skip var type indicator 
4b1c			 
4b1c					; TODO how to append numerics???? 
4b1c			 
4b1c cd d4 08				call storage_append		 
4b1f			 
4b1f				       NEXTW 
4b1f c3 e5 1f			jp macro_next 
4b22				endm 
# End of macro NEXTW
4b22			.SDEL: 
4b22				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
4b22 6a				db WORD_SYS_CORE+86             
4b23 6e 4b			dw .OPEN            
4b25 05				db 4 + 1 
4b26 .. 00			db "ERA",0              
4b2a				endm 
# End of macro CWHEAD
4b2a			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
4b2a					FORTH_DSP_VALUEHL 
4b2a cd 73 1e			call macro_dsp_valuehl 
4b2d				endm 
# End of macro FORTH_DSP_VALUEHL
4b2d			;		push hl 	; save file id 
4b2d			 
4b2d					if DEBUG_FORTH_WORDS_KEY 
4b2d						DMARK "ERA" 
4b2d f5				push af  
4b2e 3a 42 4b			ld a, (.dmark)  
4b31 32 bd fb			ld (debug_mark),a  
4b34 3a 43 4b			ld a, (.dmark+1)  
4b37 32 be fb			ld (debug_mark+1),a  
4b3a 3a 44 4b			ld a, (.dmark+2)  
4b3d 32 bf fb			ld (debug_mark+2),a  
4b40 18 03			jr .pastdmark  
4b42 ..			.dmark: db "ERA"  
4b45 f1			.pastdmark: pop af  
4b46			endm  
# End of macro DMARK
4b46						CALLMONITOR 
4b46 cd ec 16			call break_point_state  
4b49				endm  
# End of macro CALLMONITOR
4b49					endif 
4b49				if DEBUG_STORESE 
4b49					DMARK "ER1" 
4b49 f5				push af  
4b4a 3a 5e 4b			ld a, (.dmark)  
4b4d 32 bd fb			ld (debug_mark),a  
4b50 3a 5f 4b			ld a, (.dmark+1)  
4b53 32 be fb			ld (debug_mark+1),a  
4b56 3a 60 4b			ld a, (.dmark+2)  
4b59 32 bf fb			ld (debug_mark+2),a  
4b5c 18 03			jr .pastdmark  
4b5e ..			.dmark: db "ER1"  
4b61 f1			.pastdmark: pop af  
4b62			endm  
# End of macro DMARK
4b62					CALLMONITOR 
4b62 cd ec 16			call break_point_state  
4b65				endm  
# End of macro CALLMONITOR
4b65				endif 
4b65					FORTH_DSP_POP 
4b65 cd 2b 1f			call macro_forth_dsp_pop 
4b68				endm 
# End of macro FORTH_DSP_POP
4b68			 
4b68			;		pop hl 
4b68			 
4b68 cd 49 05				call storage_erase 
4b6b				       NEXTW 
4b6b c3 e5 1f			jp macro_next 
4b6e				endm 
# End of macro NEXTW
4b6e			 
4b6e			.OPEN: 
4b6e				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
4b6e 6b				db WORD_SYS_CORE+87             
4b6f f5 4b			dw .READ            
4b71 05				db 4 + 1 
4b72 .. 00			db "OPEN",0              
4b77				endm 
# End of macro CWHEAD
4b77			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
4b77			; | | e.g. 
4b77			; | | $01 OPEN $01 DO $01 READ . LOOP 
4b77			 
4b77					if DEBUG_FORTH_WORDS_KEY 
4b77						DMARK "OPN" 
4b77 f5				push af  
4b78 3a 8c 4b			ld a, (.dmark)  
4b7b 32 bd fb			ld (debug_mark),a  
4b7e 3a 8d 4b			ld a, (.dmark+1)  
4b81 32 be fb			ld (debug_mark+1),a  
4b84 3a 8e 4b			ld a, (.dmark+2)  
4b87 32 bf fb			ld (debug_mark+2),a  
4b8a 18 03			jr .pastdmark  
4b8c ..			.dmark: db "OPN"  
4b8f f1			.pastdmark: pop af  
4b90			endm  
# End of macro DMARK
4b90						CALLMONITOR 
4b90 cd ec 16			call break_point_state  
4b93				endm  
# End of macro CALLMONITOR
4b93					endif 
4b93					; TODO handle multiple file opens 
4b93			 
4b93 3e 01			       	ld a, 1 
4b95 32 df f9				ld (store_openext), a 
4b98			 
4b98					; get max extents for this file 
4b98				 
4b98								 
4b98					FORTH_DSP_VALUEHL 
4b98 cd 73 1e			call macro_dsp_valuehl 
4b9b				endm 
# End of macro FORTH_DSP_VALUEHL
4b9b			 
4b9b 65					ld h, l 
4b9c 2e 00				ld l, 0 
4b9e			 
4b9e				if DEBUG_STORESE 
4b9e					DMARK "OPN" 
4b9e f5				push af  
4b9f 3a b3 4b			ld a, (.dmark)  
4ba2 32 bd fb			ld (debug_mark),a  
4ba5 3a b4 4b			ld a, (.dmark+1)  
4ba8 32 be fb			ld (debug_mark+1),a  
4bab 3a b5 4b			ld a, (.dmark+2)  
4bae 32 bf fb			ld (debug_mark+2),a  
4bb1 18 03			jr .pastdmark  
4bb3 ..			.dmark: db "OPN"  
4bb6 f1			.pastdmark: pop af  
4bb7			endm  
# End of macro DMARK
4bb7					CALLMONITOR 
4bb7 cd ec 16			call break_point_state  
4bba				endm  
# End of macro CALLMONITOR
4bba				endif 
4bba			;		push hl 
4bba					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
4bba cd 2b 1f			call macro_forth_dsp_pop 
4bbd				endm 
# End of macro FORTH_DSP_POP
4bbd			;		pop hl 
4bbd						 
4bbd 11 e8 f9				ld de, store_page      ; get block zero of file 
4bc0 cd 4e 08				call storage_read 
4bc3			 
4bc3			 
4bc3 3a ea f9				ld a, (store_page+2)    ; max extents for this file 
4bc6 32 de f9				ld  (store_openmaxext), a   ; get our limit and push 
4bc9					 
4bc9				if DEBUG_STORESE 
4bc9					DMARK "OPx" 
4bc9 f5				push af  
4bca 3a de 4b			ld a, (.dmark)  
4bcd 32 bd fb			ld (debug_mark),a  
4bd0 3a df 4b			ld a, (.dmark+1)  
4bd3 32 be fb			ld (debug_mark+1),a  
4bd6 3a e0 4b			ld a, (.dmark+2)  
4bd9 32 bf fb			ld (debug_mark+2),a  
4bdc 18 03			jr .pastdmark  
4bde ..			.dmark: db "OPx"  
4be1 f1			.pastdmark: pop af  
4be2			endm  
# End of macro DMARK
4be2					CALLMONITOR 
4be2 cd ec 16			call break_point_state  
4be5				endm  
# End of macro CALLMONITOR
4be5				endif 
4be5 fe 00				cp 0 
4be7 20 03				jr nz, .skipopeneof 
4be9					; have opened an empty file 
4be9					 
4be9 32 df f9				ld (store_openext), a 
4bec			 
4bec			.skipopeneof: 
4bec			 
4bec 6f					ld l, a 
4bed 26 00				ld h, 0 
4bef cd 7c 1c				call forth_push_numhl 
4bf2			 
4bf2			 
4bf2				       NEXTW 
4bf2 c3 e5 1f			jp macro_next 
4bf5				endm 
# End of macro NEXTW
4bf5			.READ: 
4bf5				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
4bf5 6c				db WORD_SYS_CORE+88             
4bf6 3c 4d			dw .EOF            
4bf8 05				db 4 + 1 
4bf9 .. 00			db "READ",0              
4bfe				endm 
# End of macro CWHEAD
4bfe			; | READ ( n -- n  )  Reads next page of file id and push to stack | DONE 
4bfe			; | | e.g. 
4bfe			; | | $01 OPEN $01 DO $01 READ . LOOP 
4bfe			 
4bfe					if DEBUG_FORTH_WORDS_KEY 
4bfe						DMARK "REA" 
4bfe f5				push af  
4bff 3a 13 4c			ld a, (.dmark)  
4c02 32 bd fb			ld (debug_mark),a  
4c05 3a 14 4c			ld a, (.dmark+1)  
4c08 32 be fb			ld (debug_mark+1),a  
4c0b 3a 15 4c			ld a, (.dmark+2)  
4c0e 32 bf fb			ld (debug_mark+2),a  
4c11 18 03			jr .pastdmark  
4c13 ..			.dmark: db "REA"  
4c16 f1			.pastdmark: pop af  
4c17			endm  
# End of macro DMARK
4c17						CALLMONITOR 
4c17 cd ec 16			call break_point_state  
4c1a				endm  
# End of macro CALLMONITOR
4c1a					endif 
4c1a					; store_openext use it. If zero it is EOF 
4c1a			 
4c1a					; read block from current stream id 
4c1a					; if the block does not contain zero term keep reading blocks until zero found 
4c1a					; push the block to stack 
4c1a					; save the block id to stream 
4c1a			 
4c1a			 
4c1a					FORTH_DSP_VALUEHL 
4c1a cd 73 1e			call macro_dsp_valuehl 
4c1d				endm 
# End of macro FORTH_DSP_VALUEHL
4c1d			 
4c1d			;		push hl 
4c1d			 
4c1d				if DEBUG_STORESE 
4c1d					DMARK "REA" 
4c1d f5				push af  
4c1e 3a 32 4c			ld a, (.dmark)  
4c21 32 bd fb			ld (debug_mark),a  
4c24 3a 33 4c			ld a, (.dmark+1)  
4c27 32 be fb			ld (debug_mark+1),a  
4c2a 3a 34 4c			ld a, (.dmark+2)  
4c2d 32 bf fb			ld (debug_mark+2),a  
4c30 18 03			jr .pastdmark  
4c32 ..			.dmark: db "REA"  
4c35 f1			.pastdmark: pop af  
4c36			endm  
# End of macro DMARK
4c36					CALLMONITOR 
4c36 cd ec 16			call break_point_state  
4c39				endm  
# End of macro CALLMONITOR
4c39				endif 
4c39					FORTH_DSP_POP 
4c39 cd 2b 1f			call macro_forth_dsp_pop 
4c3c				endm 
# End of macro FORTH_DSP_POP
4c3c			 
4c3c			;		pop hl 
4c3c				 
4c3c 65					ld h,l 
4c3d			 
4c3d 3a df f9				ld a, (store_openext) 
4c40 6f					ld l, a 
4c41					 
4c41 fe 00				cp 0 
4c43 ca 0e 4d				jp z, .ateof     ; dont read past eof 
4c46			 
4c46			 
4c46 11 e8 f9				ld de, store_page 
4c49				if DEBUG_STORESE 
4c49					DMARK "RE1" 
4c49 f5				push af  
4c4a 3a 5e 4c			ld a, (.dmark)  
4c4d 32 bd fb			ld (debug_mark),a  
4c50 3a 5f 4c			ld a, (.dmark+1)  
4c53 32 be fb			ld (debug_mark+1),a  
4c56 3a 60 4c			ld a, (.dmark+2)  
4c59 32 bf fb			ld (debug_mark+2),a  
4c5c 18 03			jr .pastdmark  
4c5e ..			.dmark: db "RE1"  
4c61 f1			.pastdmark: pop af  
4c62			endm  
# End of macro DMARK
4c62					CALLMONITOR 
4c62 cd ec 16			call break_point_state  
4c65				endm  
# End of macro CALLMONITOR
4c65				endif 
4c65 cd 4e 08				call storage_read 
4c68			 
4c68				if DEBUG_STORESE 
4c68					DMARK "RE2" 
4c68 f5				push af  
4c69 3a 7d 4c			ld a, (.dmark)  
4c6c 32 bd fb			ld (debug_mark),a  
4c6f 3a 7e 4c			ld a, (.dmark+1)  
4c72 32 be fb			ld (debug_mark+1),a  
4c75 3a 7f 4c			ld a, (.dmark+2)  
4c78 32 bf fb			ld (debug_mark+2),a  
4c7b 18 03			jr .pastdmark  
4c7d ..			.dmark: db "RE2"  
4c80 f1			.pastdmark: pop af  
4c81			endm  
# End of macro DMARK
4c81					CALLMONITOR 
4c81 cd ec 16			call break_point_state  
4c84				endm  
# End of macro CALLMONITOR
4c84				endif 
4c84 cd 2f 0d			call ishlzero 
4c87			;	ld a, l 
4c87			;	add h 
4c87			;	cp 0 
4c87 ca 14 4d			jp z, .readeof 
4c8a			 
4c8a				; not eof so hl should point to data to push to stack 
4c8a			 
4c8a				if DEBUG_STORESE 
4c8a					DMARK "RE3" 
4c8a f5				push af  
4c8b 3a 9f 4c			ld a, (.dmark)  
4c8e 32 bd fb			ld (debug_mark),a  
4c91 3a a0 4c			ld a, (.dmark+1)  
4c94 32 be fb			ld (debug_mark+1),a  
4c97 3a a1 4c			ld a, (.dmark+2)  
4c9a 32 bf fb			ld (debug_mark+2),a  
4c9d 18 03			jr .pastdmark  
4c9f ..			.dmark: db "RE3"  
4ca2 f1			.pastdmark: pop af  
4ca3			endm  
# End of macro DMARK
4ca3					CALLMONITOR 
4ca3 cd ec 16			call break_point_state  
4ca6				endm  
# End of macro CALLMONITOR
4ca6				endif 
4ca6 cd ea 1c			call forth_push_str 
4ca9			 
4ca9				if DEBUG_STORESE 
4ca9					DMARK "RE4" 
4ca9 f5				push af  
4caa 3a be 4c			ld a, (.dmark)  
4cad 32 bd fb			ld (debug_mark),a  
4cb0 3a bf 4c			ld a, (.dmark+1)  
4cb3 32 be fb			ld (debug_mark+1),a  
4cb6 3a c0 4c			ld a, (.dmark+2)  
4cb9 32 bf fb			ld (debug_mark+2),a  
4cbc 18 03			jr .pastdmark  
4cbe ..			.dmark: db "RE4"  
4cc1 f1			.pastdmark: pop af  
4cc2			endm  
# End of macro DMARK
4cc2					CALLMONITOR 
4cc2 cd ec 16			call break_point_state  
4cc5				endm  
# End of macro CALLMONITOR
4cc5				endif 
4cc5				; get next block  or mark as eof 
4cc5			 
4cc5 3a de f9			ld a, (store_openmaxext)   ; get our limit 
4cc8 4f				ld c, a	 
4cc9 3a df f9			ld a, (store_openext) 
4ccc			 
4ccc				if DEBUG_STORESE 
4ccc					DMARK "RE5" 
4ccc f5				push af  
4ccd 3a e1 4c			ld a, (.dmark)  
4cd0 32 bd fb			ld (debug_mark),a  
4cd3 3a e2 4c			ld a, (.dmark+1)  
4cd6 32 be fb			ld (debug_mark+1),a  
4cd9 3a e3 4c			ld a, (.dmark+2)  
4cdc 32 bf fb			ld (debug_mark+2),a  
4cdf 18 03			jr .pastdmark  
4ce1 ..			.dmark: db "RE5"  
4ce4 f1			.pastdmark: pop af  
4ce5			endm  
# End of macro DMARK
4ce5					CALLMONITOR 
4ce5 cd ec 16			call break_point_state  
4ce8				endm  
# End of macro CALLMONITOR
4ce8				endif 
4ce8 b9				cp c 
4ce9 28 29			jr z, .readeof     ; at last extent 
4ceb			 
4ceb 3c					inc a 
4cec 32 df f9				ld (store_openext), a 
4cef			 
4cef				if DEBUG_STORESE 
4cef					DMARK "RE6" 
4cef f5				push af  
4cf0 3a 04 4d			ld a, (.dmark)  
4cf3 32 bd fb			ld (debug_mark),a  
4cf6 3a 05 4d			ld a, (.dmark+1)  
4cf9 32 be fb			ld (debug_mark+1),a  
4cfc 3a 06 4d			ld a, (.dmark+2)  
4cff 32 bf fb			ld (debug_mark+2),a  
4d02 18 03			jr .pastdmark  
4d04 ..			.dmark: db "RE6"  
4d07 f1			.pastdmark: pop af  
4d08			endm  
# End of macro DMARK
4d08					CALLMONITOR 
4d08 cd ec 16			call break_point_state  
4d0b				endm  
# End of macro CALLMONITOR
4d0b				endif 
4d0b			 
4d0b			 
4d0b				       NEXTW 
4d0b c3 e5 1f			jp macro_next 
4d0e				endm 
# End of macro NEXTW
4d0e			.ateof: 
4d0e 21 38 4d				ld hl, .showeof 
4d11 cd ea 1c				call forth_push_str 
4d14 3e 00		.readeof:	ld a, 0 
4d16 32 df f9				ld (store_openext), a 
4d19			 
4d19					 
4d19				if DEBUG_STORESE 
4d19					DMARK "REF" 
4d19 f5				push af  
4d1a 3a 2e 4d			ld a, (.dmark)  
4d1d 32 bd fb			ld (debug_mark),a  
4d20 3a 2f 4d			ld a, (.dmark+1)  
4d23 32 be fb			ld (debug_mark+1),a  
4d26 3a 30 4d			ld a, (.dmark+2)  
4d29 32 bf fb			ld (debug_mark+2),a  
4d2c 18 03			jr .pastdmark  
4d2e ..			.dmark: db "REF"  
4d31 f1			.pastdmark: pop af  
4d32			endm  
# End of macro DMARK
4d32					CALLMONITOR 
4d32 cd ec 16			call break_point_state  
4d35				endm  
# End of macro CALLMONITOR
4d35				endif 
4d35				       NEXTW 
4d35 c3 e5 1f			jp macro_next 
4d38				endm 
# End of macro NEXTW
4d38			 
4d38 .. 00		.showeof:   db "eof", 0 
4d3c			 
4d3c			 
4d3c			.EOF: 
4d3c				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
4d3c 6d				db WORD_SYS_CORE+89             
4d3d 7d 4d			dw .FORMAT            
4d3f 04				db 3 + 1 
4d40 .. 00			db "EOF",0              
4d44				endm 
# End of macro CWHEAD
4d44			; | EOF ( n -- u )  Returns EOF logical state of file id n - CURRENTLY n IS IGNORED AND ONLY ONE STREAM IS SUPPORTED | DONE 
4d44			; | | e.g. 
4d44			; | | $01 OPEN REPEAT $01 READ $01 EOF $00 IF LOOP 
4d44					; TODO if current block id for stream is zero then push true else false 
4d44			 
4d44					if DEBUG_FORTH_WORDS_KEY 
4d44						DMARK "EOF" 
4d44 f5				push af  
4d45 3a 59 4d			ld a, (.dmark)  
4d48 32 bd fb			ld (debug_mark),a  
4d4b 3a 5a 4d			ld a, (.dmark+1)  
4d4e 32 be fb			ld (debug_mark+1),a  
4d51 3a 5b 4d			ld a, (.dmark+2)  
4d54 32 bf fb			ld (debug_mark+2),a  
4d57 18 03			jr .pastdmark  
4d59 ..			.dmark: db "EOF"  
4d5c f1			.pastdmark: pop af  
4d5d			endm  
# End of macro DMARK
4d5d						CALLMONITOR 
4d5d cd ec 16			call break_point_state  
4d60				endm  
# End of macro CALLMONITOR
4d60					endif 
4d60			 
4d60					; TODO handlue multiple file streams 
4d60			 
4d60					FORTH_DSP_POP     ; for now just get rid of stream id 
4d60 cd 2b 1f			call macro_forth_dsp_pop 
4d63				endm 
# End of macro FORTH_DSP_POP
4d63			 
4d63 2e 01				ld l, 1 
4d65 3a de f9				ld a, (store_openmaxext) 
4d68 fe 00				cp 0 
4d6a 28 09				jr  z, .eofdone   ; empty file 
4d6c 3a df f9				ld a, (store_openext) 
4d6f fe 00				cp 0 
4d71 28 02				jr  z, .eofdone 
4d73 2e 00				ld l, 0 
4d75 26 00		.eofdone:	ld h, 0 
4d77 cd 7c 1c				call forth_push_numhl 
4d7a			 
4d7a			 
4d7a				       NEXTW 
4d7a c3 e5 1f			jp macro_next 
4d7d				endm 
# End of macro NEXTW
4d7d			 
4d7d			.FORMAT: 
4d7d				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
4d7d 6d				db WORD_SYS_CORE+89             
4d7e ce 4d			dw .LABEL            
4d80 07				db 6 + 1 
4d81 .. 00			db "FORMAT",0              
4d88				endm 
# End of macro CWHEAD
4d88			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
4d88					; TODO if current block id for stream is zero then push true else false 
4d88				 
4d88				if DEBUG_STORESE 
4d88					DMARK "FOR" 
4d88 f5				push af  
4d89 3a 9d 4d			ld a, (.dmark)  
4d8c 32 bd fb			ld (debug_mark),a  
4d8f 3a 9e 4d			ld a, (.dmark+1)  
4d92 32 be fb			ld (debug_mark+1),a  
4d95 3a 9f 4d			ld a, (.dmark+2)  
4d98 32 bf fb			ld (debug_mark+2),a  
4d9b 18 03			jr .pastdmark  
4d9d ..			.dmark: db "FOR"  
4da0 f1			.pastdmark: pop af  
4da1			endm  
# End of macro DMARK
4da1					CALLMONITOR 
4da1 cd ec 16			call break_point_state  
4da4				endm  
# End of macro CALLMONITOR
4da4				endif 
4da4					; Wipes the bank check flags to cause a reformat on next block 0 read 
4da4			 
4da4 21 01 00				ld hl, 1 
4da7 3e 00				ld a, 0 
4da9 cd e7 01				call se_writebyte 
4dac			 
4dac				if DEBUG_STORESE 
4dac					DMARK "FO0" 
4dac f5				push af  
4dad 3a c1 4d			ld a, (.dmark)  
4db0 32 bd fb			ld (debug_mark),a  
4db3 3a c2 4d			ld a, (.dmark+1)  
4db6 32 be fb			ld (debug_mark+1),a  
4db9 3a c3 4d			ld a, (.dmark+2)  
4dbc 32 bf fb			ld (debug_mark+2),a  
4dbf 18 03			jr .pastdmark  
4dc1 ..			.dmark: db "FO0"  
4dc4 f1			.pastdmark: pop af  
4dc5			endm  
# End of macro DMARK
4dc5					CALLMONITOR 
4dc5 cd ec 16			call break_point_state  
4dc8				endm  
# End of macro CALLMONITOR
4dc8				endif 
4dc8					; force bank init 
4dc8			 
4dc8 cd ba 03				call storage_get_block_0 
4dcb					 
4dcb				       NEXTW 
4dcb c3 e5 1f			jp macro_next 
4dce				endm 
# End of macro NEXTW
4dce			.LABEL: 
4dce				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
4dce 6d				db WORD_SYS_CORE+89             
4dcf 1c 4e			dw .STOREPAGE            
4dd1 06				db 5 + 1 
4dd2 .. 00			db "LABEL",0              
4dd8				endm 
# End of macro CWHEAD
4dd8			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
4dd8					; TODO test to see if bank is selected 
4dd8				 
4dd8					if DEBUG_FORTH_WORDS_KEY 
4dd8						DMARK "LBL" 
4dd8 f5				push af  
4dd9 3a ed 4d			ld a, (.dmark)  
4ddc 32 bd fb			ld (debug_mark),a  
4ddf 3a ee 4d			ld a, (.dmark+1)  
4de2 32 be fb			ld (debug_mark+1),a  
4de5 3a ef 4d			ld a, (.dmark+2)  
4de8 32 bf fb			ld (debug_mark+2),a  
4deb 18 03			jr .pastdmark  
4ded ..			.dmark: db "LBL"  
4df0 f1			.pastdmark: pop af  
4df1			endm  
# End of macro DMARK
4df1						CALLMONITOR 
4df1 cd ec 16			call break_point_state  
4df4				endm  
# End of macro CALLMONITOR
4df4					endif 
4df4			;	if DEBUG_STORESE 
4df4			;		DMARK "LBL" 
4df4			;		CALLMONITOR 
4df4			;	endif 
4df4					FORTH_DSP_VALUEHL 
4df4 cd 73 1e			call macro_dsp_valuehl 
4df7				endm 
# End of macro FORTH_DSP_VALUEHL
4df7					;v5FORTH_DSP_VALUE 
4df7					 
4df7			;		push hl 
4df7					FORTH_DSP_POP 
4df7 cd 2b 1f			call macro_forth_dsp_pop 
4dfa				endm 
# End of macro FORTH_DSP_POP
4dfa			;		pop hl 
4dfa			 
4dfa			;v5		inc hl   ; move past the type marker 
4dfa			 
4dfa				if DEBUG_STORESE 
4dfa					DMARK "LBl" 
4dfa f5				push af  
4dfb 3a 0f 4e			ld a, (.dmark)  
4dfe 32 bd fb			ld (debug_mark),a  
4e01 3a 10 4e			ld a, (.dmark+1)  
4e04 32 be fb			ld (debug_mark+1),a  
4e07 3a 11 4e			ld a, (.dmark+2)  
4e0a 32 bf fb			ld (debug_mark+2),a  
4e0d 18 03			jr .pastdmark  
4e0f ..			.dmark: db "LBl"  
4e12 f1			.pastdmark: pop af  
4e13			endm  
# End of macro DMARK
4e13					CALLMONITOR 
4e13 cd ec 16			call break_point_state  
4e16				endm  
# End of macro CALLMONITOR
4e16				endif 
4e16 cd de 04				call storage_label 
4e19			 
4e19				       NEXTW 
4e19 c3 e5 1f			jp macro_next 
4e1c				endm 
# End of macro NEXTW
4e1c			.STOREPAGE: 
4e1c				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
4e1c 6d				db WORD_SYS_CORE+89             
4e1d 4f 4e			dw .LABELS            
4e1f 0a				db 9 + 1 
4e20 .. 00			db "STOREPAGE",0              
4e2a				endm 
# End of macro CWHEAD
4e2a			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
4e2a					; TODO test to see if bank is selected 
4e2a				 
4e2a					if DEBUG_FORTH_WORDS_KEY 
4e2a						DMARK "STP" 
4e2a f5				push af  
4e2b 3a 3f 4e			ld a, (.dmark)  
4e2e 32 bd fb			ld (debug_mark),a  
4e31 3a 40 4e			ld a, (.dmark+1)  
4e34 32 be fb			ld (debug_mark+1),a  
4e37 3a 41 4e			ld a, (.dmark+2)  
4e3a 32 bf fb			ld (debug_mark+2),a  
4e3d 18 03			jr .pastdmark  
4e3f ..			.dmark: db "STP"  
4e42 f1			.pastdmark: pop af  
4e43			endm  
# End of macro DMARK
4e43						CALLMONITOR 
4e43 cd ec 16			call break_point_state  
4e46				endm  
# End of macro CALLMONITOR
4e46					endif 
4e46			;	if DEBUG_STORESE 
4e46			;		DMARK "STP" 
4e46			;		CALLMONITOR 
4e46			;	endif 
4e46			 
4e46 21 e8 f9			ld hl, store_page 
4e49 cd 7c 1c			call forth_push_numhl 
4e4c			 
4e4c			 
4e4c				       NEXTW 
4e4c c3 e5 1f			jp macro_next 
4e4f				endm 
# End of macro NEXTW
4e4f			.LABELS: 
4e4f				CWHEAD .ENDSTORAGE 89 "LABELS" 6 WORD_FLAG_CODE 
4e4f 6d				db WORD_SYS_CORE+89             
4e50 d9 4e			dw .ENDSTORAGE            
4e52 07				db 6 + 1 
4e53 .. 00			db "LABELS",0              
4e5a				endm 
# End of macro CWHEAD
4e5a			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | TO TEST 
4e5a					;  
4e5a			 
4e5a					; save the current device selected to restore afterwards 
4e5a				 
4e5a 3a ce f9				ld a, (spi_device) 
4e5d f5					push af 
4e5e			 
4e5e			 
4e5e					; run through each of the banks 
4e5e			 
4e5e 21 01 00				ld hl, 1 
4e61 cd 7c 1c				call forth_push_numhl 
4e64 3e ff				ld a, SPI_CE_HIGH 
4e66 cb 87				res SPI_CE0, a 
4e68 32 ce f9				ld (spi_device), a 
4e6b cd ba 03				call storage_get_block_0 
4e6e 21 eb f9				ld hl, store_page+3 
4e71 cd ea 1c				call forth_push_str 
4e74			 
4e74					 
4e74 21 02 00				ld hl, 2 
4e77 cd 7c 1c				call forth_push_numhl 
4e7a 3e ff				ld a, SPI_CE_HIGH 
4e7c cb 8f				res SPI_CE1, a 
4e7e 32 ce f9				ld (spi_device), a 
4e81 cd ba 03				call storage_get_block_0 
4e84 21 eb f9				ld hl, store_page+3 
4e87 cd ea 1c				call forth_push_str 
4e8a			 
4e8a					 
4e8a 21 03 00				ld hl, 3 
4e8d cd 7c 1c				call forth_push_numhl 
4e90 3e ff				ld a, SPI_CE_HIGH 
4e92 cb 97				res SPI_CE2, a 
4e94 32 ce f9				ld (spi_device), a 
4e97 cd ba 03				call storage_get_block_0 
4e9a 21 eb f9				ld hl, store_page+3 
4e9d cd ea 1c				call forth_push_str 
4ea0			 
4ea0			 
4ea0 21 04 00				ld hl, 4 
4ea3 cd 7c 1c				call forth_push_numhl 
4ea6 3e ff				ld a, SPI_CE_HIGH 
4ea8 cb 9f				res SPI_CE3, a 
4eaa 32 ce f9				ld (spi_device), a 
4ead cd ba 03				call storage_get_block_0 
4eb0 21 eb f9				ld hl, store_page+3 
4eb3 cd ea 1c				call forth_push_str 
4eb6			 
4eb6					 
4eb6			 
4eb6 21 05 00				ld hl, 5 
4eb9 cd 7c 1c				call forth_push_numhl 
4ebc 3e ff				ld a, SPI_CE_HIGH 
4ebe cb a7				res SPI_CE4, a 
4ec0 32 ce f9				ld (spi_device), a 
4ec3 cd ba 03				call storage_get_block_0 
4ec6 21 eb f9				ld hl, store_page+3 
4ec9 cd ea 1c				call forth_push_str 
4ecc			 
4ecc					 
4ecc					; push fixed count of storage devices (on board) for now 
4ecc			 
4ecc 21 05 00				ld hl, 5 
4ecf cd 7c 1c				call forth_push_numhl 
4ed2			 
4ed2					; restore selected device  
4ed2				 
4ed2 f1					pop af 
4ed3 32 ce f9				ld (spi_device), a 
4ed6			 
4ed6				       NEXTW 
4ed6 c3 e5 1f			jp macro_next 
4ed9				endm 
# End of macro NEXTW
4ed9			 
4ed9			.ENDSTORAGE: 
4ed9			; eof 
# End of file forth_words_storage.asm
4ed9			endif 
4ed9				include "forth_words_device.asm" 
4ed9			; Device related words 
4ed9			 
4ed9			; | ## Device Words 
4ed9			 
4ed9			if SOUND_ENABLE 
4ed9			.NOTE: 
4ed9				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
4ed9			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
4ed9					if DEBUG_FORTH_WORDS_KEY 
4ed9						DMARK "NTE" 
4ed9						CALLMONITOR 
4ed9					endif 
4ed9			 
4ed9				 
4ed9			 
4ed9					NEXTW 
4ed9			.AFTERSOUND: 
4ed9			endif 
4ed9			 
4ed9			 
4ed9			USE_GPIO: equ 0 
4ed9			 
4ed9			if USE_GPIO 
4ed9			.GP1: 
4ed9				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
4ed9			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
4ed9					NEXTW 
4ed9			.GP2: 
4ed9				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
4ed9			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
4ed9			 
4ed9					NEXTW 
4ed9			 
4ed9			.GP3: 
4ed9				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
4ed9			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
4ed9			 
4ed9					NEXTW 
4ed9			 
4ed9			.GP4: 
4ed9				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
4ed9			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
4ed9			 
4ed9					NEXTW 
4ed9			.SIN: 
4ed9			 
4ed9			 
4ed9			endif 
4ed9			 
4ed9			 
4ed9				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
4ed9 33				db WORD_SYS_CORE+31             
4eda 0e 4f			dw .SOUT            
4edc 03				db 2 + 1 
4edd .. 00			db "IN",0              
4ee0				endm 
# End of macro CWHEAD
4ee0			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
4ee0					if DEBUG_FORTH_WORDS_KEY 
4ee0						DMARK "IN." 
4ee0 f5				push af  
4ee1 3a f5 4e			ld a, (.dmark)  
4ee4 32 bd fb			ld (debug_mark),a  
4ee7 3a f6 4e			ld a, (.dmark+1)  
4eea 32 be fb			ld (debug_mark+1),a  
4eed 3a f7 4e			ld a, (.dmark+2)  
4ef0 32 bf fb			ld (debug_mark+2),a  
4ef3 18 03			jr .pastdmark  
4ef5 ..			.dmark: db "IN."  
4ef8 f1			.pastdmark: pop af  
4ef9			endm  
# End of macro DMARK
4ef9						CALLMONITOR 
4ef9 cd ec 16			call break_point_state  
4efc				endm  
# End of macro CALLMONITOR
4efc					endif 
4efc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4efc cd 73 1e			call macro_dsp_valuehl 
4eff				endm 
# End of macro FORTH_DSP_VALUEHL
4eff			 
4eff e5					push hl 
4f00			 
4f00					; destroy value TOS 
4f00			 
4f00					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4f00 cd 2b 1f			call macro_forth_dsp_pop 
4f03				endm 
# End of macro FORTH_DSP_POP
4f03			 
4f03					; one value on hl get other one back 
4f03			 
4f03 c1					pop bc 
4f04			 
4f04					; do the sub 
4f04			;		ex de, hl 
4f04			 
4f04 ed 68				in l,(c) 
4f06			 
4f06					; save it 
4f06			 
4f06 26 00				ld h,0 
4f08			 
4f08					; TODO push value back onto stack for another op etc 
4f08			 
4f08 cd 7c 1c				call forth_push_numhl 
4f0b					NEXTW 
4f0b c3 e5 1f			jp macro_next 
4f0e				endm 
# End of macro NEXTW
4f0e			.SOUT: 
4f0e				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
4f0e 34				db WORD_SYS_CORE+32             
4f0f 61 4f			dw .SPIO            
4f11 04				db 3 + 1 
4f12 .. 00			db "OUT",0              
4f16				endm 
# End of macro CWHEAD
4f16			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
4f16					if DEBUG_FORTH_WORDS_KEY 
4f16						DMARK "OUT" 
4f16 f5				push af  
4f17 3a 2b 4f			ld a, (.dmark)  
4f1a 32 bd fb			ld (debug_mark),a  
4f1d 3a 2c 4f			ld a, (.dmark+1)  
4f20 32 be fb			ld (debug_mark+1),a  
4f23 3a 2d 4f			ld a, (.dmark+2)  
4f26 32 bf fb			ld (debug_mark+2),a  
4f29 18 03			jr .pastdmark  
4f2b ..			.dmark: db "OUT"  
4f2e f1			.pastdmark: pop af  
4f2f			endm  
# End of macro DMARK
4f2f						CALLMONITOR 
4f2f cd ec 16			call break_point_state  
4f32				endm  
# End of macro CALLMONITOR
4f32					endif 
4f32			 
4f32					; get port 
4f32			 
4f32					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4f32 cd 73 1e			call macro_dsp_valuehl 
4f35				endm 
# End of macro FORTH_DSP_VALUEHL
4f35			 
4f35 e5					push hl 
4f36			 
4f36					; destroy value TOS 
4f36			 
4f36					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4f36 cd 2b 1f			call macro_forth_dsp_pop 
4f39				endm 
# End of macro FORTH_DSP_POP
4f39			 
4f39					; get byte to send 
4f39			 
4f39					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4f39 cd 73 1e			call macro_dsp_valuehl 
4f3c				endm 
# End of macro FORTH_DSP_VALUEHL
4f3c			 
4f3c			;		push hl 
4f3c			 
4f3c					; destroy value TOS 
4f3c			 
4f3c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4f3c cd 2b 1f			call macro_forth_dsp_pop 
4f3f				endm 
# End of macro FORTH_DSP_POP
4f3f			 
4f3f					; one value on hl get other one back 
4f3f			 
4f3f			;		pop hl 
4f3f			 
4f3f c1					pop bc 
4f40			 
4f40					if DEBUG_FORTH_WORDS 
4f40						DMARK "OUT" 
4f40 f5				push af  
4f41 3a 55 4f			ld a, (.dmark)  
4f44 32 bd fb			ld (debug_mark),a  
4f47 3a 56 4f			ld a, (.dmark+1)  
4f4a 32 be fb			ld (debug_mark+1),a  
4f4d 3a 57 4f			ld a, (.dmark+2)  
4f50 32 bf fb			ld (debug_mark+2),a  
4f53 18 03			jr .pastdmark  
4f55 ..			.dmark: db "OUT"  
4f58 f1			.pastdmark: pop af  
4f59			endm  
# End of macro DMARK
4f59						CALLMONITOR 
4f59 cd ec 16			call break_point_state  
4f5c				endm  
# End of macro CALLMONITOR
4f5c					endif 
4f5c			 
4f5c ed 69				out (c), l 
4f5e			 
4f5e					NEXTW 
4f5e c3 e5 1f			jp macro_next 
4f61				endm 
# End of macro NEXTW
4f61			 
4f61			 
4f61			.SPIO: 
4f61			 
4f61			if STORAGE_SE 
4f61				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
4f61 51				db WORD_SYS_CORE+61             
4f62 72 4f			dw .SPICEH            
4f64 07				db 6 + 1 
4f65 .. 00			db "SPICEL",0              
4f6c				endm 
# End of macro CWHEAD
4f6c			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
4f6c			 
4f6c cd 95 01				call spi_ce_low 
4f6f			    NEXTW 
4f6f c3 e5 1f			jp macro_next 
4f72				endm 
# End of macro NEXTW
4f72			 
4f72			.SPICEH: 
4f72				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
4f72 51				db WORD_SYS_CORE+61             
4f73 83 4f			dw .SPIOb            
4f75 07				db 6 + 1 
4f76 .. 00			db "SPICEH",0              
4f7d				endm 
# End of macro CWHEAD
4f7d			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
4f7d			 
4f7d cd 84 01				call spi_ce_high 
4f80			    NEXTW 
4f80 c3 e5 1f			jp macro_next 
4f83				endm 
# End of macro NEXTW
4f83			 
4f83			 
4f83			.SPIOb: 
4f83			 
4f83				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
4f83 51				db WORD_SYS_CORE+61             
4f84 99 4f			dw .SPII            
4f86 05				db 4 + 1 
4f87 .. 00			db "SPIO",0              
4f8c				endm 
# End of macro CWHEAD
4f8c			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
4f8c			 
4f8c					; get port 
4f8c			 
4f8c			 
4f8c					; get byte to send 
4f8c			 
4f8c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4f8c cd 73 1e			call macro_dsp_valuehl 
4f8f				endm 
# End of macro FORTH_DSP_VALUEHL
4f8f			 
4f8f			;		push hl    ; u1  
4f8f			 
4f8f					; destroy value TOS 
4f8f			 
4f8f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4f8f cd 2b 1f			call macro_forth_dsp_pop 
4f92				endm 
# End of macro FORTH_DSP_POP
4f92			 
4f92					; one value on hl get other one back 
4f92			 
4f92			;		pop hl   ; u2 - addr 
4f92			 
4f92					; TODO Send SPI byte 
4f92			 
4f92 7d					ld a, l 
4f93 cd b9 00				call spi_send_byte 
4f96			 
4f96					NEXTW 
4f96 c3 e5 1f			jp macro_next 
4f99				endm 
# End of macro NEXTW
4f99			 
4f99			.SPII: 
4f99				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
4f99 52				db WORD_SYS_CORE+62             
4f9a ae 4f			dw .SESEL            
4f9c 06				db 5 + 1 
4f9d .. 00			db "SPII",0              
4fa2				endm 
# End of macro CWHEAD
4fa2			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
4fa2			 
4fa2					; TODO Get SPI byte 
4fa2			 
4fa2 cd da 00				call spi_read_byte 
4fa5			 
4fa5 26 00				ld h, 0 
4fa7 6f					ld l, a 
4fa8 cd 7c 1c				call forth_push_numhl 
4fab			 
4fab					NEXTW 
4fab c3 e5 1f			jp macro_next 
4fae				endm 
# End of macro NEXTW
4fae			 
4fae			 
4fae			 
4fae			.SESEL: 
4fae				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
4fae 66				db WORD_SYS_CORE+82             
4faf 52 50			dw .CARTDEV            
4fb1 05				db 4 + 1 
4fb2 .. 00			db "BANK",0              
4fb7				endm 
# End of macro CWHEAD
4fb7			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
4fb7					if DEBUG_FORTH_WORDS_KEY 
4fb7						DMARK "BNK" 
4fb7 f5				push af  
4fb8 3a cc 4f			ld a, (.dmark)  
4fbb 32 bd fb			ld (debug_mark),a  
4fbe 3a cd 4f			ld a, (.dmark+1)  
4fc1 32 be fb			ld (debug_mark+1),a  
4fc4 3a ce 4f			ld a, (.dmark+2)  
4fc7 32 bf fb			ld (debug_mark+2),a  
4fca 18 03			jr .pastdmark  
4fcc ..			.dmark: db "BNK"  
4fcf f1			.pastdmark: pop af  
4fd0			endm  
# End of macro DMARK
4fd0						CALLMONITOR 
4fd0 cd ec 16			call break_point_state  
4fd3				endm  
# End of macro CALLMONITOR
4fd3					endif 
4fd3			 
4fd3 3e ff				ld a, 255 
4fd5 32 d1 f9				ld (spi_cartdev), a 
4fd8			 
4fd8					; get bank 
4fd8			 
4fd8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4fd8 cd 73 1e			call macro_dsp_valuehl 
4fdb				endm 
# End of macro FORTH_DSP_VALUEHL
4fdb			 
4fdb			;		push hl 
4fdb			 
4fdb					; destroy value TOS 
4fdb			 
4fdb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4fdb cd 2b 1f			call macro_forth_dsp_pop 
4fde				endm 
# End of macro FORTH_DSP_POP
4fde			 
4fde					; one value on hl get other one back 
4fde			 
4fde			;		pop hl 
4fde			 
4fde			 
4fde 0e ff				ld c, SPI_CE_HIGH 
4fe0 06 30				ld b, '0'    ; human readable bank number 
4fe2			 
4fe2 7d					ld a, l 
4fe3			 
4fe3					if DEBUG_FORTH_WORDS 
4fe3						DMARK "BNK" 
4fe3 f5				push af  
4fe4 3a f8 4f			ld a, (.dmark)  
4fe7 32 bd fb			ld (debug_mark),a  
4fea 3a f9 4f			ld a, (.dmark+1)  
4fed 32 be fb			ld (debug_mark+1),a  
4ff0 3a fa 4f			ld a, (.dmark+2)  
4ff3 32 bf fb			ld (debug_mark+2),a  
4ff6 18 03			jr .pastdmark  
4ff8 ..			.dmark: db "BNK"  
4ffb f1			.pastdmark: pop af  
4ffc			endm  
# End of macro DMARK
4ffc						CALLMONITOR 
4ffc cd ec 16			call break_point_state  
4fff				endm  
# End of macro CALLMONITOR
4fff					endif 
4fff			 
4fff					; active low 
4fff			 
4fff fe 00				cp 0 
5001 28 28				jr z, .bset 
5003 fe 01				cp 1 
5005 20 04				jr nz, .b2 
5007 cb 81				res 0, c 
5009 06 31				ld b, '1'    ; human readable bank number 
500b fe 02		.b2:		cp 2 
500d 20 04				jr nz, .b3 
500f cb 89				res 1, c 
5011 06 32				ld b, '2'    ; human readable bank number 
5013 fe 03		.b3:		cp 3 
5015 20 04				jr nz, .b4 
5017 cb 91				res 2, c 
5019 06 33				ld b, '3'    ; human readable bank number 
501b fe 04		.b4:		cp 4 
501d 20 04				jr nz, .b5 
501f cb 99				res 3, c 
5021 06 34				ld b, '4'    ; human readable bank number 
5023 fe 05		.b5:		cp 5 
5025 20 04				jr nz, .bset 
5027 cb a1				res 4, c 
5029 06 35				ld b, '5'    ; human readable bank number 
502b			 
502b			.bset: 
502b 79					ld a, c 
502c 32 ce f9				ld (spi_device),a 
502f 78					ld a, b 
5030 32 cd f9				ld (spi_device_id),a 
5033					if DEBUG_FORTH_WORDS 
5033						DMARK "BN2" 
5033 f5				push af  
5034 3a 48 50			ld a, (.dmark)  
5037 32 bd fb			ld (debug_mark),a  
503a 3a 49 50			ld a, (.dmark+1)  
503d 32 be fb			ld (debug_mark+1),a  
5040 3a 4a 50			ld a, (.dmark+2)  
5043 32 bf fb			ld (debug_mark+2),a  
5046 18 03			jr .pastdmark  
5048 ..			.dmark: db "BN2"  
504b f1			.pastdmark: pop af  
504c			endm  
# End of macro DMARK
504c						CALLMONITOR 
504c cd ec 16			call break_point_state  
504f				endm  
# End of macro CALLMONITOR
504f					endif 
504f			 
504f					NEXTW 
504f c3 e5 1f			jp macro_next 
5052				endm 
# End of macro NEXTW
5052			 
5052			.CARTDEV: 
5052				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
5052 66				db WORD_SYS_CORE+82             
5053 fb 50			dw .ENDDEVICE            
5055 08				db 7 + 1 
5056 .. 00			db "CARTDEV",0              
505e				endm 
# End of macro CWHEAD
505e			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
505e					if DEBUG_FORTH_WORDS_KEY 
505e						DMARK "CDV" 
505e f5				push af  
505f 3a 73 50			ld a, (.dmark)  
5062 32 bd fb			ld (debug_mark),a  
5065 3a 74 50			ld a, (.dmark+1)  
5068 32 be fb			ld (debug_mark+1),a  
506b 3a 75 50			ld a, (.dmark+2)  
506e 32 bf fb			ld (debug_mark+2),a  
5071 18 03			jr .pastdmark  
5073 ..			.dmark: db "CDV"  
5076 f1			.pastdmark: pop af  
5077			endm  
# End of macro DMARK
5077						CALLMONITOR 
5077 cd ec 16			call break_point_state  
507a				endm  
# End of macro CALLMONITOR
507a					endif 
507a			 
507a					; disable se storage bank selection 
507a			 
507a 3e ff				ld a, SPI_CE_HIGH		; ce high 
507c 32 ce f9				ld (spi_device), a 
507f			 
507f					; get bank 
507f			 
507f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
507f cd 73 1e			call macro_dsp_valuehl 
5082				endm 
# End of macro FORTH_DSP_VALUEHL
5082			 
5082			;		push hl 
5082			 
5082					; destroy value TOS 
5082			 
5082					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5082 cd 2b 1f			call macro_forth_dsp_pop 
5085				endm 
# End of macro FORTH_DSP_POP
5085			 
5085					; one value on hl get other one back 
5085			 
5085			;		pop hl 
5085			 
5085					; active low 
5085			 
5085 0e ff				ld c, 255 
5087			 
5087 7d					ld a, l 
5088					if DEBUG_FORTH_WORDS 
5088						DMARK "CDV" 
5088 f5				push af  
5089 3a 9d 50			ld a, (.dmark)  
508c 32 bd fb			ld (debug_mark),a  
508f 3a 9e 50			ld a, (.dmark+1)  
5092 32 be fb			ld (debug_mark+1),a  
5095 3a 9f 50			ld a, (.dmark+2)  
5098 32 bf fb			ld (debug_mark+2),a  
509b 18 03			jr .pastdmark  
509d ..			.dmark: db "CDV"  
50a0 f1			.pastdmark: pop af  
50a1			endm  
# End of macro DMARK
50a1						CALLMONITOR 
50a1 cd ec 16			call break_point_state  
50a4				endm  
# End of macro CALLMONITOR
50a4					endif 
50a4 fe 00				cp 0 
50a6 28 30				jr z, .cset 
50a8 fe 01				cp 1 
50aa 20 02				jr nz, .c2 
50ac cb 81				res 0, c 
50ae fe 02		.c2:		cp 2 
50b0 20 02				jr nz, .c3 
50b2 cb 89				res 1, c 
50b4 fe 03		.c3:		cp 3 
50b6 20 02				jr nz, .c4 
50b8 cb 91				res 2, c 
50ba fe 04		.c4:		cp 4 
50bc 20 02				jr nz, .c5 
50be cb 99				res 3, c 
50c0 fe 05		.c5:		cp 5 
50c2 20 02				jr nz, .c6 
50c4 cb a1				res 4, c 
50c6 fe 06		.c6:		cp 6 
50c8 20 02				jr nz, .c7 
50ca cb a9				res 5, c 
50cc fe 07		.c7:		cp 7 
50ce 20 02				jr nz, .c8 
50d0 cb b1				res 6, c 
50d2 fe 08		.c8:		cp 8 
50d4 20 02				jr nz, .cset 
50d6 cb b9				res 7, c 
50d8 79			.cset:		ld a, c 
50d9 32 d1 f9				ld (spi_cartdev),a 
50dc			 
50dc					if DEBUG_FORTH_WORDS 
50dc						DMARK "CD2" 
50dc f5				push af  
50dd 3a f1 50			ld a, (.dmark)  
50e0 32 bd fb			ld (debug_mark),a  
50e3 3a f2 50			ld a, (.dmark+1)  
50e6 32 be fb			ld (debug_mark+1),a  
50e9 3a f3 50			ld a, (.dmark+2)  
50ec 32 bf fb			ld (debug_mark+2),a  
50ef 18 03			jr .pastdmark  
50f1 ..			.dmark: db "CD2"  
50f4 f1			.pastdmark: pop af  
50f5			endm  
# End of macro DMARK
50f5						CALLMONITOR 
50f5 cd ec 16			call break_point_state  
50f8				endm  
# End of macro CALLMONITOR
50f8					endif 
50f8					NEXTW 
50f8 c3 e5 1f			jp macro_next 
50fb				endm 
# End of macro NEXTW
50fb			endif 
50fb			 
50fb			.ENDDEVICE: 
50fb			; eof 
50fb			 
# End of file forth_words_device.asm
50fb			 
50fb			; var handler 
50fb			 
50fb			 
50fb			.VARS: 
50fb				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
50fb 78				db WORD_SYS_CORE+100             
50fc 13 51			dw .V0Q            
50fe 04				db 3 + 1 
50ff .. 00			db "V0!",0              
5103				endm 
# End of macro CWHEAD
5103			;| V0! ( u1 -- )  Store value to v0  | DONE 
5103			 
5103					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5103 cd 73 1e			call macro_dsp_valuehl 
5106				endm 
# End of macro FORTH_DSP_VALUEHL
5106			 
5106 11 96 f9				ld de, cli_var_array 
5109			 
5109 eb					ex de, hl 
510a 73					ld (hl), e 
510b 23					inc hl 
510c 72					ld (hl), d 
510d			 
510d					; destroy value TOS 
510d			 
510d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
510d cd 2b 1f			call macro_forth_dsp_pop 
5110				endm 
# End of macro FORTH_DSP_POP
5110			 
5110				       NEXTW 
5110 c3 e5 1f			jp macro_next 
5113				endm 
# End of macro NEXTW
5113			.V0Q: 
5113				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
5113 79				db WORD_SYS_CORE+101             
5114 24 51			dw .V1S            
5116 04				db 3 + 1 
5117 .. 00			db "V0@",0              
511b				endm 
# End of macro CWHEAD
511b			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
511b 2a 96 f9				ld hl, (cli_var_array) 
511e cd 7c 1c				call forth_push_numhl 
5121			 
5121				       NEXTW 
5121 c3 e5 1f			jp macro_next 
5124				endm 
# End of macro NEXTW
5124			.V1S: 
5124				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
5124 7a				db WORD_SYS_CORE+102             
5125 3c 51			dw .V1Q            
5127 04				db 3 + 1 
5128 .. 00			db "V1!",0              
512c				endm 
# End of macro CWHEAD
512c			;| V1! ( u1 -- )  Store value to v1 | DONE 
512c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
512c cd 73 1e			call macro_dsp_valuehl 
512f				endm 
# End of macro FORTH_DSP_VALUEHL
512f			 
512f 11 98 f9				ld de, cli_var_array+2 
5132				 
5132 eb					ex de, hl 
5133 73					ld (hl), e 
5134 23					inc hl 
5135 72					ld (hl), d 
5136			 
5136					; destroy value TOS 
5136			 
5136					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5136 cd 2b 1f			call macro_forth_dsp_pop 
5139				endm 
# End of macro FORTH_DSP_POP
5139				       NEXTW 
5139 c3 e5 1f			jp macro_next 
513c				endm 
# End of macro NEXTW
513c			.V1Q: 
513c				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
513c 7b				db WORD_SYS_CORE+103             
513d 4d 51			dw .V2S            
513f 04				db 3 + 1 
5140 .. 00			db "V1@",0              
5144				endm 
# End of macro CWHEAD
5144			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
5144 2a 98 f9				ld hl, (cli_var_array+2) 
5147 cd 7c 1c				call forth_push_numhl 
514a				       NEXTW 
514a c3 e5 1f			jp macro_next 
514d				endm 
# End of macro NEXTW
514d			.V2S: 
514d				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
514d 7c				db WORD_SYS_CORE+104             
514e 65 51			dw .V2Q            
5150 04				db 3 + 1 
5151 .. 00			db "V2!",0              
5155				endm 
# End of macro CWHEAD
5155			;| V2! ( u1 -- )  Store value to v2 | DONE 
5155					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5155 cd 73 1e			call macro_dsp_valuehl 
5158				endm 
# End of macro FORTH_DSP_VALUEHL
5158			 
5158 11 9a f9				ld de, cli_var_array+4 
515b				 
515b eb					ex de, hl 
515c 73					ld (hl), e 
515d 23					inc hl 
515e 72					ld (hl), d 
515f			 
515f					; destroy value TOS 
515f			 
515f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
515f cd 2b 1f			call macro_forth_dsp_pop 
5162				endm 
# End of macro FORTH_DSP_POP
5162				       NEXTW 
5162 c3 e5 1f			jp macro_next 
5165				endm 
# End of macro NEXTW
5165			.V2Q: 
5165				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
5165 7d				db WORD_SYS_CORE+105             
5166 76 51			dw .V3S            
5168 04				db 3 + 1 
5169 .. 00			db "V2@",0              
516d				endm 
# End of macro CWHEAD
516d			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
516d 2a 9a f9				ld hl, (cli_var_array+4) 
5170 cd 7c 1c				call forth_push_numhl 
5173				       NEXTW 
5173 c3 e5 1f			jp macro_next 
5176				endm 
# End of macro NEXTW
5176			.V3S: 
5176				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
5176 7c				db WORD_SYS_CORE+104             
5177 8e 51			dw .V3Q            
5179 04				db 3 + 1 
517a .. 00			db "V3!",0              
517e				endm 
# End of macro CWHEAD
517e			;| V3! ( u1 -- )  Store value to v3 | DONE 
517e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
517e cd 73 1e			call macro_dsp_valuehl 
5181				endm 
# End of macro FORTH_DSP_VALUEHL
5181			 
5181 11 9c f9				ld de, cli_var_array+6 
5184				 
5184 eb					ex de, hl 
5185 73					ld (hl), e 
5186 23					inc hl 
5187 72					ld (hl), d 
5188			 
5188					; destroy value TOS 
5188			 
5188					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5188 cd 2b 1f			call macro_forth_dsp_pop 
518b				endm 
# End of macro FORTH_DSP_POP
518b				       NEXTW 
518b c3 e5 1f			jp macro_next 
518e				endm 
# End of macro NEXTW
518e			.V3Q: 
518e				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
518e 7d				db WORD_SYS_CORE+105             
518f 9f 51			dw .END            
5191 04				db 3 + 1 
5192 .. 00			db "V3@",0              
5196				endm 
# End of macro CWHEAD
5196			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
5196 2a 9c f9				ld hl, (cli_var_array+6) 
5199 cd 7c 1c				call forth_push_numhl 
519c				       NEXTW 
519c c3 e5 1f			jp macro_next 
519f				endm 
# End of macro NEXTW
519f			 
519f			 
519f			 
519f			 
519f			 
519f			; end of dict marker 
519f			 
519f 00			.END:    db WORD_SYS_END 
51a0 00 00			dw 0 
51a2 00				db 0 
51a3			 
51a3			; use to jp here for user dict words to save on macro expansion  
51a3			 
51a3			user_dict_next: 
51a3				NEXTW 
51a3 c3 e5 1f			jp macro_next 
51a6				endm 
# End of macro NEXTW
51a6			 
51a6			 
51a6			user_exec: 
51a6				;    ld hl, <word code> 
51a6				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
51a6				;    call forthexec 
51a6				;    jp user_dict_next   (NEXT) 
51a6			        ;    <word code bytes> 
51a6 eb				ex de, hl 
51a7 2a a4 f2			ld hl,(os_tok_ptr) 
51aa				 
51aa				FORTH_RSP_NEXT 
51aa cd 23 1c			call macro_forth_rsp_next 
51ad				endm 
# End of macro FORTH_RSP_NEXT
51ad			 
51ad			if DEBUG_FORTH_UWORD 
51ad						DMARK "UEX" 
51ad f5				push af  
51ae 3a c2 51			ld a, (.dmark)  
51b1 32 bd fb			ld (debug_mark),a  
51b4 3a c3 51			ld a, (.dmark+1)  
51b7 32 be fb			ld (debug_mark+1),a  
51ba 3a c4 51			ld a, (.dmark+2)  
51bd 32 bf fb			ld (debug_mark+2),a  
51c0 18 03			jr .pastdmark  
51c2 ..			.dmark: db "UEX"  
51c5 f1			.pastdmark: pop af  
51c6			endm  
# End of macro DMARK
51c6				CALLMONITOR 
51c6 cd ec 16			call break_point_state  
51c9				endm  
# End of macro CALLMONITOR
51c9			endif 
51c9			 
51c9			 
51c9			 
51c9 eb				ex de, hl 
51ca 22 a4 f2			ld (os_tok_ptr), hl 
51cd				 
51cd				; Don't use next - Skips the first word in uword. 
51cd			 
51cd c3 76 20			jp exec1 
51d0			;	NEXT 
51d0			 
51d0			 
51d0			; eof 
# End of file forth_wordsv4.asm
51d0			endif 
51d0			;;;;;;;;;;;;;; Debug code 
51d0			 
51d0			 
51d0			;if DEBUG_FORTH_PARSE 
51d0 .. 00		.nowordfound: db "No match",0 
51d9 .. 00		.compword:	db "Comparing word ",0 
51e9 .. 00		.nextwordat:	db "Next word at",0 
51f6 .. 00		.charmatch:	db "Char match",0 
5201			;endif 
5201			if DEBUG_FORTH_JP 
5201			.foundword:	db "Word match. Exec..",0 
5201			endif 
5201			;if DEBUG_FORTH_PUSH 
5201 .. 00		.enddict:	db "Dict end. Push.",0 
5211 .. 00		.push_str:	db "Pushing string",0 
5220 .. 00		.push_num:	db "Pushing number",0 
522f .. 00		.data_sp:	db "SP:",0 
5233 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
5245 .. 00		.wordinde:	db "Word in DE (3/0):",0 
5257 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
5269			;endif 
5269			;if DEBUG_FORTH_MALLOC 
5269 .. 00		.push_malloc:	db "Malloc address",0 
5278			;endif 
5278			 
5278			 
5278			 
5278			; display malloc address and current data stack pointer  
5278			 
5278			malloc_error: 
5278 d5				push de 
5279 f5				push af 
527a e5				push hl 
527b cd d2 0a			call clear_display 
527e 11 a0 52			ld de, .mallocerr 
5281 3e 00			ld a,0 
5283			;	ld de,os_word_scratch 
5283 cd e5 0a			call str_at_display 
5286 3e 11			ld a, display_row_1+17 
5288 11 bd fb			ld de, debug_mark 
528b cd e5 0a			call str_at_display 
528e cd f5 0a			call update_display 
5291				;call break_point_state 
5291 cd fc 67			call cin_wait 
5294			 
5294 3e 20			ld a, ' ' 
5296 32 94 ef			ld (os_view_disable), a 
5299 e1				pop hl 
529a f1				pop af 
529b d1				pop de	 
529c				CALLMONITOR 
529c cd ec 16			call break_point_state  
529f				endm  
# End of macro CALLMONITOR
529f c9				ret 
52a0			 
52a0 .. 00		.mallocerr: 	db "Malloc Error",0 
52ad			;if DEBUG_FORTH_PUSH 
52ad			display_data_sp: 
52ad f5				push af 
52ae			 
52ae				; see if disabled 
52ae			 
52ae 3a 94 ef			ld a, (os_view_disable) 
52b1 fe 2a			cp '*' 
52b3 28 67			jr z, .skipdsp 
52b5			 
52b5 e5				push hl 
52b6 e5				push hl 
52b7 e5			push hl 
52b8 cd d2 0a			call clear_display 
52bb e1			pop hl 
52bc 7c				ld a,h 
52bd 21 a8 f2			ld hl, os_word_scratch 
52c0 cd 07 10			call hexout 
52c3 e1				pop hl 
52c4 7d				ld a,l 
52c5 21 aa f2			ld hl, os_word_scratch+2 
52c8 cd 07 10			call hexout 
52cb 21 ac f2			ld hl, os_word_scratch+4 
52ce 3e 00			ld a,0 
52d0 77				ld (hl),a 
52d1 11 a8 f2			ld de,os_word_scratch 
52d4 3e 14				ld a, display_row_2 
52d6 cd e5 0a				call str_at_display 
52d9 11 33 52			ld de, .wordinhl 
52dc 3e 00			ld a, display_row_1 
52de			 
52de cd e5 0a				call str_at_display 
52e1 11 bd fb			ld de, debug_mark 
52e4 3e 11			ld a, display_row_1+17 
52e6			 
52e6 cd e5 0a				call str_at_display 
52e9			 
52e9				; display current data stack pointer 
52e9 11 2f 52			ld de,.data_sp 
52ec 3e 1c				ld a, display_row_2 + 8 
52ee cd e5 0a				call str_at_display 
52f1			 
52f1 2a 90 f9			ld hl,(cli_data_sp) 
52f4 e5				push hl 
52f5 7c				ld a,h 
52f6 21 a8 f2			ld hl, os_word_scratch 
52f9 cd 07 10			call hexout 
52fc e1				pop hl 
52fd 7d				ld a,l 
52fe 21 aa f2			ld hl, os_word_scratch+2 
5301 cd 07 10			call hexout 
5304 21 ac f2			ld hl, os_word_scratch+4 
5307 3e 00			ld a,0 
5309 77				ld (hl),a 
530a 11 a8 f2			ld de,os_word_scratch 
530d 3e 1f				ld a, display_row_2 + 11 
530f cd e5 0a				call str_at_display 
5312			 
5312			 
5312 cd f5 0a			call update_display 
5315 cd 52 0a			call delay1s 
5318 cd 52 0a			call delay1s 
531b e1				pop hl 
531c			.skipdsp: 
531c f1				pop af 
531d c9				ret 
531e			 
531e			display_data_malloc: 
531e			 
531e f5				push af 
531f e5				push hl 
5320 e5				push hl 
5321 e5			push hl 
5322 cd d2 0a			call clear_display 
5325 e1			pop hl 
5326 7c				ld a,h 
5327 21 a8 f2			ld hl, os_word_scratch 
532a cd 07 10			call hexout 
532d e1				pop hl 
532e 7d				ld a,l 
532f 21 aa f2			ld hl, os_word_scratch+2 
5332 cd 07 10			call hexout 
5335 21 ac f2			ld hl, os_word_scratch+4 
5338 3e 00			ld a,0 
533a 77				ld (hl),a 
533b 11 a8 f2			ld de,os_word_scratch 
533e 3e 14				ld a, display_row_2 
5340 cd e5 0a				call str_at_display 
5343 11 69 52			ld de, .push_malloc 
5346 3e 00			ld a, display_row_1 
5348			 
5348 cd e5 0a				call str_at_display 
534b			 
534b				; display current data stack pointer 
534b 11 2f 52			ld de,.data_sp 
534e 3e 1c				ld a, display_row_2 + 8 
5350 cd e5 0a				call str_at_display 
5353			 
5353 2a 90 f9			ld hl,(cli_data_sp) 
5356 e5				push hl 
5357 7c				ld a,h 
5358 21 a8 f2			ld hl, os_word_scratch 
535b cd 07 10			call hexout 
535e e1				pop hl 
535f 7d				ld a,l 
5360 21 aa f2			ld hl, os_word_scratch+2 
5363 cd 07 10			call hexout 
5366 21 ac f2			ld hl, os_word_scratch+4 
5369 3e 00			ld a,0 
536b 77				ld (hl),a 
536c 11 a8 f2			ld de,os_word_scratch 
536f 3e 1f				ld a, display_row_2 + 11 
5371 cd e5 0a				call str_at_display 
5374			 
5374 cd f5 0a			call update_display 
5377 cd 52 0a			call delay1s 
537a cd 52 0a			call delay1s 
537d e1				pop hl 
537e f1				pop af 
537f c9				ret 
5380			;endif 
5380			 
5380			include "forth_autostart.asm" 
5380			; list of commands to perform at system start up 
5380			 
5380			startcmds: 
5380			;	dw test11 
5380			;	dw test12 
5380			;	dw test13 
5380			;	dw test14 
5380			;	dw test15 
5380			;	dw test16 
5380			;	dw test17 
5380			;	dw ifthtest1 
5380			;	dw ifthtest2 
5380			;	dw ifthtest3 
5380			;	dw mmtest1 
5380			;	dw mmtest2 
5380			;	dw mmtest3 
5380			;	dw mmtest4 
5380			;	dw mmtest5 
5380			;	dw mmtest6 
5380			;	dw iftest1 
5380			;	dw iftest2 
5380			;	dw iftest3 
5380			;	dw looptest1 
5380			;	dw looptest2 
5380			;	dw test1 
5380			;	dw test2 
5380			;	dw test3 
5380			;	dw test4 
5380			;	dw game2r 
5380			;	dw game2b1 
5380			;	dw game2b2 
5380			 
5380				; start up words that are actually useful 
5380			 
5380 de 53			dw clrstack 
5382 11 54			dw type 
5384 d2 55			dw stest 
5386 35 54			dw strncpy 
5388 73 55			dw list 
538a 96 54			dw start1 
538c a8 54			dw start2 
538e			;	dw start3 
538e bb 54			dw start3b 
5390 13 55			dw start3c 
5392			 
5392				; (unit) testing words 
5392			 
5392 49 56			dw mtesta 
5394 fe 56			dw mtestb 
5396 a1 57			dw mtestc 
5398 56 58			dw mtestd 
539a fa 58			dw mteste 
539c			 
539c				; demo/game words 
539c			 
539c 06 60		        dw game3w 
539e 34 60		        dw game3p 
53a0 52 60		        dw game3sc 
53a2 83 60		        dw game3vsi 
53a4 af 60		        dw game3vs 
53a6				 
53a6 f9 5d			dw game2b 
53a8 67 5e			dw game2bf 
53aa b1 5e			dw game2mba 
53ac 47 5f			dw game2mbas 
53ae 89 5f			dw game2mb 
53b0			 
53b0 ba 5a			dw game1 
53b2 cb 5a			dw game1a 
53b4 2d 5b			dw game1b 
53b6 62 5b			dw game1c 
53b8 98 5b			dw game1d 
53ba c9 5b			dw game1s 
53bc dd 5b			dw game1t 
53be f2 5b			dw game1f 
53c0 26 5c			dw game1z 
53c2 6a 5c			dw game1zz 
53c4			 
53c4 b0 59			dw test5 
53c6 e8 59			dw test6 
53c8 20 5a			dw test7 
53ca 34 5a			dw test8 
53cc 60 5a			dw test9 
53ce 76 5a			dw test10 
53d0				 
53d0 41 5d		        dw ssv5 
53d2 25 5d		        dw ssv4 
53d4 09 5d		        dw ssv3 
53d6 d3 5c		        dw ssv2 
53d8 5a 5d		        dw ssv1 
53da a2 5d		        dw ssv1cpm 
53dc			;	dw keyup 
53dc			;	dw keydown 
53dc			;	dw keyleft 
53dc			;	dw keyright 
53dc			;	dw 	keyf1 
53dc			;	dw keyf2 
53dc			;	dw keyf3 
53dc			;	dw keyf4 
53dc			;	dw keyf5 
53dc			;	dw keyf6 
53dc			;	dw keyf7 
53dc			;	dw keyf8 
53dc			;	dw keyf9 
53dc			;	dw keyf10 
53dc			;	dw keyf11 
53dc			;	dw keyf12 
53dc			;	dw keytab 
53dc			;	dw keycr 
53dc			;	dw keyhome 
53dc			;	dw keyend 
53dc			;	dw keybs 
53dc 00 00			db 0, 0	 
53de			 
53de			 
53de			; clear stack  
53de			 
53de .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
5411			 
5411			; type ( addr count - ) 
5411 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
5435			 
5435			; some direct memory words 
5435			; strncpy ( len t f -- t ) 
5435			 
5435 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
5496			 
5496 .. 00		start1:     	db ": bpon $0000 bp ;",0 
54a8 .. 00		start2:     	db ": bpoff $0001 bp ;",0 
54bb			;start3:         db ": dirlist ir cls drop dup $00 > if $01 do .> BL .> .> BL .> .> BL .> loop then nop ;",0 
54bb .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 i at . $01 i at . $04 i at . loop then nop ;",0 
5513 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
5573			 
5573			 
5573			; a handy word to list items on the stack 
5573			 
5573 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> accept drop depth 0= not until nop ;",0 
55d2			 
55d2			 
55d2			; test stack  
55d2			; rnd8 stest 
55d2			 
55d2 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
5649			 
5649			; random malloc and free cycles 
5649			 
5649 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
56fe			 
56fe			; fixed malloc and free cycles 
56fe			 
56fe .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
57a1			 
57a1			; fixed double string push and drop cycle  
57a1			 
57a1 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
5856			 
5856			; consistent fixed string push and drop cycle  
5856			 
5856 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
58fa			 
58fa .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
59b0			 
59b0			;test1:		db ": aa 1 2 3 ;", 0 
59b0			;test2:     	db "111 aa 888 999",0 
59b0			;test3:     	db ": bb 77 ;",0 
59b0			;test4:     	db "$02 $01 do i . loop bb",0 
59b0			 
59b0 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
59e8 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
5a20 .. 00		test7:     	db ": box hline vline ;",0 
5a34 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
5a60 .. 00		test9:     	db ": sw $01 adsp world ;",0 
5a76 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
5a9b .. 00		test11:     	db "hello create .",0 
5aaa .. 00		test12:     	db "hello2 create .",0 
5aba			 
5aba			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
5aba			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
5aba			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
5aba			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
5aba			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
5aba			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
5aba			 
5aba			;iftest1:     	db "$0001 IF cls .",0 
5aba			;iftest2:     	db "$0000 IF cls .",0 
5aba			;iftest3:     	db "$0002 $0003 - IF cls .",0 
5aba			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
5aba			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
5aba			 
5aba			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5aba			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5aba			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5aba			 
5aba			 
5aba			 
5aba			; a small guess the number game 
5aba			 
5aba .. 00		game1:          db ": gsn rnd8 v1! ;",0 
5acb .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
5b2d			 
5b2d .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
5b62 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
5b98 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
5bc9 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
5bdd .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
5bf2 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5c26 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
5c6a			 
5c6a			; Using 'ga' save a high score across multiple runs using external storage 
5c6a			 
5c6a .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
5cd3			 
5cd3			 
5cd3			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
5cd3			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
5cd3			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
5cd3			 
5cd3			; simple screen saver to test code memory reuse to destruction 
5cd3			 
5cd3 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
5d09 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
5d25 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
5d41 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
5d5a .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
5da2 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
5df9			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
5df9			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
5df9			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
5df9			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
5df9			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
5df9			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
5df9			 
5df9			 
5df9			 
5df9			; minesweeper/battleship finding game 
5df9			; draws a game board of random ship/mine positions 
5df9			; user enters coords to see if it hits on 
5df9			; game ends when all are hit 
5df9			; when hit or miss says how many may be in the area 
5df9			 
5df9			; setup the game board and then hide it 
5df9 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
5e67 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
5eb1			; prompt for where to target 
5eb1 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
5f47 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
5f6c			; TODO see if the entered coords hits or misses pushes char hit of miss 
5f6c .. 00		game2mbht:      db ": mbckht nop ;",0 
5f7b .. 00		game2mbms:      db ": mbcms nop ;",0 
5f89			; TODO how many might be near by 
5f89 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
6006			 
6006			; Game 3 
6006			 
6006			; Vert scroller ski game - avoid the trees! 
6006			 
6006			; v0 score (ie turns) 
6006			; v1 player pos 
6006			; v2 left wall 
6006			; v3 right wall 
6006			 
6006			; Draw side walls randomly 
6006			 
6006 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
6034			 
6034			; Draw player 
6034 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
6052			 
6052			; TODO Get Key 
6052			 
6052			; TODO Move left right 
6052			 
6052			; scroll and move walls a bit 
6052			 
6052 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
6083			 
6083			; main game loop 
6083			 
6083 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
60af .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
60ee			 
60ee			; key board defs 
60ee			 
60ee .. 00		keyup:       db ": keyup $05 ;",0 
60fc .. 00		keydown:       db ": keydown $0a ;",0 
610c .. 00		keyleft:       db ": keyleft $0b ;",0 
611c .. 00		keyright:       db ": keyright $0c ;",0 
612d .. 00		keyf1:       db ": keyf1 $10 ;",0 
613b .. 00		keyf2:       db ": keyf2 $11 ;",0 
6149 .. 00		keyf3:       db ": keyf3 $12 ;",0 
6157 .. 00		keyf4:       db ": keyf4 $13 ;",0 
6165 .. 00		keyf5:       db ": keyf5 $14 ;",0 
6173 .. 00		keyf6:       db ": keyf6 $15 ;",0 
6181 .. 00		keyf7:       db ": keyf7 $16 ;",0 
618f .. 00		keyf8:       db ": keyf8 $17 ;",0 
619d .. 00		keyf9:       db ": keyf9 $18 ;",0 
61ab .. 00		keyf10:       db ": keyf10 $19 ;",0 
61ba .. 00		keyf11:       db ": keyf11 $1a ;",0 
61c9 .. 00		keyf12:       db ": keyf12 $1b ;",0 
61d8			 
61d8 .. 00		keytab:       db ": keytab $09 ;",0 
61e7 .. 00		keycr:       db ": keycr $0d ;",0 
61f5 .. 00		keyhome:       db ": keyhome $0e ;",0 
6205 .. 00		keyend:       db ": keyend $0f ;",0 
6214 .. 00		keybs:       db ": keybs $08 ;",0 
6222			 
6222			   
6222			 
6222			 
6222			 
6222			; eof 
# End of file forth_autostart.asm
6222			 
6222 .. 00		sprompt1: db "Startup load...",0 
6232 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
6248			 
6248			 
6248			 
6248			 
6248			forth_startup: 
6248 21 80 53			ld hl, startcmds 
624b 3e 00			ld a, 0 
624d 32 c9 f3			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
6250			 
6250 e5			.start1:	push hl 
6251 cd d2 0a			call clear_display 
6254 11 22 62			ld de, sprompt1 
6257 3e 00		        ld a, display_row_1 
6259 cd e5 0a			call str_at_display 
625c 11 32 62			ld de, sprompt2 
625f 3e 14		        ld a, display_row_2 
6261 cd e5 0a			call str_at_display 
6264 e1				pop hl 
6265 e5				push hl 
6266 5e				ld e,(hl) 
6267 23				inc hl 
6268 56				ld d,(hl) 
6269 3e 28		        ld a, display_row_3 
626b cd e5 0a			call str_at_display 
626e cd f5 0a			call update_display 
6271			 
6271			 
6271 3a c9 f3			ld a, (os_last_cmd) 
6274 fe 00			cp 0 
6276 28 05			jr z, .startprompt 
6278 cd 46 0a			call delay250ms 
627b 18 24			jr .startdo 
627d				 
627d				 
627d			 
627d			.startprompt: 
627d			 
627d 3e 4f			ld a,display_row_4 + display_cols - 1 
627f 11 f2 1b		        ld de, endprg 
6282 cd e5 0a			call str_at_display 
6285 cd f5 0a			call update_display 
6288 cd 52 0a			call delay1s 
628b cd fc 67			call cin_wait 
628e						 
628e fe 2a			cp '*' 
6290 28 5e			jr z, .startupend1 
6292 fe 23			cp '#' 
6294 20 07			jr nz, .startno 
6296 3e 01			ld a, 1 
6298 32 c9 f3			ld (os_last_cmd),a 
629b 18 04			jr .startdo 
629d fe 31		.startno:	cp '1' 
629f 28 3a			jr z,.startnxt  
62a1			 
62a1				; exec startup line 
62a1			.startdo:	 
62a1 e1				pop hl 
62a2 e5				push hl 
62a3				 
62a3 5e				ld e,(hl) 
62a4 23				inc hl 
62a5 56				ld d,(hl) 
62a6 eb				ex de,hl 
62a7			 
62a7 e5				push hl 
62a8			 
62a8 3e 00			ld a, 0 
62aa				;ld a, FORTH_END_BUFFER 
62aa cd 6f 11			call strlent 
62ad 23				inc hl   ; include zero term to copy 
62ae 06 00			ld b,0 
62b0 4d				ld c,l 
62b1 e1				pop hl 
62b2 11 a3 ef			ld de, scratch 
62b5 ed b0			ldir 
62b7			 
62b7			 
62b7 21 a3 ef			ld hl, scratch 
62ba cd 33 20			call forthparse 
62bd cd 73 20			call forthexec 
62c0 cd 8a 1f			call forthexec_cleanup 
62c3			 
62c3 3e 3c			ld a, display_row_4 
62c5 11 96 19			ld de, endprog 
62c8			 
62c8 cd f5 0a			call update_display		 
62cb			 
62cb 3a c9 f3			ld a, (os_last_cmd) 
62ce fe 00			cp 0 
62d0 20 09			jr nz, .startnxt 
62d2 cd f4 1b			call next_page_prompt 
62d5 cd d2 0a		        call clear_display 
62d8 cd f5 0a			call update_display		 
62db			 
62db				; move onto next startup line? 
62db			.startnxt: 
62db			 
62db cd 46 0a			call delay250ms 
62de e1				pop hl 
62df			 
62df 23				inc hl 
62e0 23				inc hl 
62e1			 
62e1 e5				push hl 
62e2 5e				ld e, (hl) 
62e3 23				inc hl 
62e4 56				ld d, (hl) 
62e5 e1				pop hl 
62e6				; TODO replace 0 test 
62e6			 
62e6 eb				ex de, hl 
62e7 cd 2f 0d			call ishlzero 
62ea			;	ld a,e 
62ea			;	add d 
62ea			;	cp 0    ; any left to do? 
62ea eb				ex de, hl 
62eb c2 50 62			jp nz, .start1 
62ee 18 01			jr .startupend 
62f0			 
62f0 e1			.startupend1: pop hl 
62f1			.startupend: 
62f1			 
62f1 cd d2 0a			call clear_display 
62f4 cd f5 0a			call update_display 
62f7 c9				ret 
62f8			 
62f8			 
62f8			; stack over and underflow checks 
62f8			 
62f8			; init the words to detect the under/overflow 
62f8			 
62f8			chk_stk_init: 
62f8				; a vague random number to check so we dont get any "lucky" hits 
62f8 3e 2d			ld a, 45 
62fa 6f				ld l, a 
62fb 00				nop 
62fc 3e 17			ld a, 23 
62fe 67				ld h, a 
62ff			 
62ff 22 8a ef			ld (chk_word), hl     ; the word we need to check against 
6302			 
6302			;	ld (chk_stund), hl	; stack points.... 
6302 22 fd fb			ld (chk_stovr), hl 
6305 22 8e f9			ld (chk_ret_und), hl 
6308 22 0c f9			ld (chk_ret_ovr), hl 
630b 22 0a f7			ld (chk_loop_ovr), hl 
630e 22 08 f5			ld (chk_data_ovr), hl 
6311 c9				ret 
6312				 
6312			check_stacks: 
6312				; check all stack words 
6312			 
6312 e5				push hl 
6313 d5				push de 
6314			 
6314			;	ld de,(chk_word) 
6314			;	ld hl, (chk_stund)	; stack points.... 
6314			;	if DEBUG_STK_FAULT 
6314			;		DMARK "FAa" 
6314			;		CALLMONITOR 
6314			;	endif 
6314			;	call cmp16 
6314			;	jp z, .chk_faulta 
6314			; 
6314			;	ld de, sfaultsu 
6314			;	jp .chk_fault 
6314			 
6314 2a fd fb		.chk_faulta: ld hl, (chk_stovr) 
6317 ed 5b 8a ef		ld de,(chk_word) 
631b				if DEBUG_STK_FAULT 
631b					DMARK "FAb" 
631b					CALLMONITOR 
631b				endif 
631b cd 24 0d			call cmp16 
631e 28 06			jr z, .chk_fault1 
6320 11 c1 63			ld de, sfaultso 
6323 c3 75 63			jp .chk_fault 
6326			.chk_fault1:  
6326 2a 8e f9			ld hl, (chk_ret_und) 
6329 ed 5b 8a ef		ld de,(chk_word) 
632d				if DEBUG_STK_FAULT 
632d					DMARK "FAU" 
632d					CALLMONITOR 
632d				endif 
632d cd 24 0d			call cmp16 
6330 ca 39 63			jp z, .chk_fault2 
6333 11 d1 63			ld de, sfaultru 
6336 c3 75 63			jp .chk_fault 
6339			.chk_fault2:  
6339 2a 0c f9			ld hl, (chk_ret_ovr) 
633c ed 5b 8a ef		ld de,(chk_word) 
6340				if DEBUG_STK_FAULT 
6340					DMARK "FA1" 
6340					CALLMONITOR 
6340				endif 
6340 cd 24 0d			call cmp16 
6343 ca 4c 63			jp z, .chk_fault3 
6346 11 df 63			ld de, sfaultro 
6349 c3 75 63			jp .chk_fault 
634c			.chk_fault3:  
634c 2a 0a f7			ld hl, (chk_loop_ovr) 
634f ed 5b 8a ef		ld de,(chk_word) 
6353				if DEBUG_STK_FAULT 
6353					DMARK "FA2" 
6353					CALLMONITOR 
6353				endif 
6353 cd 24 0d			call cmp16 
6356 ca 5f 63			jp z, .chk_fault4 
6359 11 f9 63			ld de, sfaultlo 
635c c3 75 63			jp .chk_fault 
635f			.chk_fault4:  
635f 2a 08 f5			ld hl, (chk_data_ovr) 
6362 ed 5b 8a ef		ld de,(chk_word) 
6366				if DEBUG_STK_FAULT 
6366					DMARK "FA3" 
6366					CALLMONITOR 
6366				endif 
6366 cd 24 0d			call cmp16 
6369 ca 72 63			jp z, .chk_fault5 
636c 11 13 64			ld de, sfaultdo 
636f c3 75 63			jp .chk_fault 
6372			 
6372			 
6372			.chk_fault5:  
6372 d1				pop de 
6373 e1				pop hl 
6374			 
6374 c9				ret 
6375			 
6375 cd d2 0a		.chk_fault: 	call clear_display 
6378 3e 14				ld a, display_row_2 
637a cd e5 0a				call str_at_display 
637d 11 a3 63				   ld de, .stackfault 
6380 3e 00				ld a, display_row_1 
6382 cd e5 0a				call str_at_display 
6385 11 bd fb				    ld de, debug_mark 
6388 3e 11				ld a, display_row_1+17 
638a cd e5 0a				call str_at_display 
638d cd f5 0a				call update_display 
6390			 
6390				; prompt before entering montior for investigating issue 
6390			 
6390 3e 3c			ld a, display_row_4 
6392 11 96 19			ld de, endprog 
6395			 
6395 cd f5 0a			call update_display		 
6398			 
6398 cd f4 1b			call next_page_prompt 
639b			 
639b d1				pop de 
639c e1				pop hl 
639d cd ea 19				call monitor 
63a0 c3 e1 18				jp warmstart 
63a3					;jp 0 
63a3					;halt 
63a3			 
63a3			 
63a3			 
63a3 .. 00		.stackfault: 	db "Stack fault:",0 
63b0			 
63b0 .. 00		sfaultsu: 	db	"Stack under flow",0 
63c1 .. 00		sfaultso: 	db	"Stack over flow",0 
63d1 .. 00		sfaultru:	db "RTS underflow",0 
63df .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
63f9 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
6413 .. 00		sfaultdo:	db "DTS overflow", 0 
6420			 
6420			 
6420			fault_dsp_under: 
6420 11 32 64			ld de, .dsp_under 
6423 c3 e2 64			jp .show_fault 
6426			 
6426			fault_rsp_under: 
6426 11 40 64			ld de, .rsp_under 
6429 c3 e2 64			jp .show_fault 
642c			fault_loop_under: 
642c 11 4e 64			ld de, .loop_under 
642f c3 e2 64			jp .show_fault 
6432			 
6432 .. 00		.dsp_under: db "DSP Underflow",0 
6440 .. 00		.rsp_under: db "RSP Underflow",0 
644e .. 00		.loop_under: db "LOOP Underflow",0 
645d			 
645d			 
645d d5			type_faultn: 	push de 
645e e5					push hl 
645f cd d2 0a				call clear_display 
6462 11 89 64				   ld de, .typefaultn 
6465 3e 00				ld a, display_row_1 
6467 cd e5 0a				call str_at_display 
646a 11 bd fb				    ld de, debug_mark 
646d 3e 11				ld a, display_row_1+17 
646f cd e5 0a				call str_at_display 
6472 cd f5 0a				call update_display 
6475			 
6475				; prompt before entering montior for investigating issue 
6475			 
6475 3e 3c			ld a, display_row_4 
6477 11 96 19			ld de, endprog 
647a			 
647a cd f5 0a			call update_display		 
647d			 
647d cd f4 1b			call next_page_prompt 
6480			 
6480 e5					push hl 
6481 d5					push de 
6482 cd ea 19				call monitor 
6485 c3 e1 18				jp warmstart 
6488 76					halt 
6489			 
6489			 
6489 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
64a0			 
64a0 d5			type_faults: 	push de 
64a1 e5					push hl 
64a2 cd d2 0a				call clear_display 
64a5 11 cb 64				   ld de, .typefaults 
64a8 3e 00				ld a, display_row_1 
64aa cd e5 0a				call str_at_display 
64ad 11 bd fb				    ld de, debug_mark 
64b0 3e 11				ld a, display_row_1+17 
64b2 cd e5 0a				call str_at_display 
64b5 cd f5 0a				call update_display 
64b8			 
64b8				; prompt before entering montior for investigating issue 
64b8			 
64b8 3e 3c			ld a, display_row_4 
64ba 11 96 19			ld de, endprog 
64bd			 
64bd cd f5 0a			call update_display		 
64c0			 
64c0 cd f4 1b			call next_page_prompt 
64c3			 
64c3 e1					pop hl 
64c4 d1					pop de 
64c5 cd ea 19				call monitor 
64c8 c3 e1 18				jp warmstart 
64cb			 
64cb			 
64cb .. 00		.typefaults: db "STR Type Expected TOS!",0 
64e2			 
64e2			.show_fault: 	 
64e2 d5					push de 
64e3 cd d2 0a				call clear_display 
64e6 d1					pop de 
64e7 3e 00				ld a, display_row_1 
64e9 cd e5 0a				call str_at_display 
64ec 11 bd fb				    ld de, debug_mark 
64ef 3e 11				ld a, display_row_1+17 
64f1 cd e5 0a				call str_at_display 
64f4 cd f5 0a				call update_display 
64f7			 
64f7				; prompt before entering montior for investigating issue 
64f7			 
64f7 3e 3c			ld a, display_row_4 
64f9 11 96 19			ld de, endprog 
64fc			 
64fc cd f5 0a			call update_display		 
64ff			 
64ff cd f4 1b			call next_page_prompt 
6502			 
6502 e1					pop hl 
6503 d1					pop de 
6504 cd ea 19				call monitor 
6507			; do a dump to cli and not warmstart so we preserve all of the uwords.  
6507			; TODO Make optional fault restart to cli or warm boot? 
6507					;jp warmstart 
6507 c3 3c 19				jp cli 
650a 76					halt 
650b			 
650b			; handle the auto run of code from files in storage 
650b			 
650b			 
650b			if STORAGE_SE 
650b			 
650b .. 00		sprompt3: db "Loading from start-up file?:",0 
6528 .. 00		sprompt4: db "(Y=Any key/N=No)",0 
6539			 
6539			 
6539			forth_autoload: 
6539			 
6539				; load block 0 of store 1 
6539				 
6539 3e fe			ld a, $fe      ; bit 0 clear 
653b 32 ce f9			ld (spi_device), a 
653e			 
653e cd ba 03			call storage_get_block_0 
6541			 
6541 3a 09 fa			ld a, (store_page+STORE_0_AUTOFILE) 
6544			 
6544 fe 00			cp 0 
6546 c8				ret z     ; auto start not enabled 
6547			 
6547 cd d2 0a			call clear_display 
654a			 
654a				; set bank 
654a			 
654a 3a 0b fa				ld a, (store_page+STORE_0_BANKRUN) 
654d 32 ce f9				ld (spi_device), a 
6550			 
6550				; get file id to load from and get the file name to display 
6550			 
6550 3a 0c fa				ld a, (store_page+STORE_0_FILERUN) 
6553			 
6553 2e 00				ld l, 0 
6555 67					ld h, a 
6556 11 e8 f9				ld de, store_page 
6559			 
6559					if DEBUG_FORTH_WORDS 
6559						DMARK "ASp" 
6559 f5				push af  
655a 3a 6e 65			ld a, (.dmark)  
655d 32 bd fb			ld (debug_mark),a  
6560 3a 6f 65			ld a, (.dmark+1)  
6563 32 be fb			ld (debug_mark+1),a  
6566 3a 70 65			ld a, (.dmark+2)  
6569 32 bf fb			ld (debug_mark+2),a  
656c 18 03			jr .pastdmark  
656e ..			.dmark: db "ASp"  
6571 f1			.pastdmark: pop af  
6572			endm  
# End of macro DMARK
6572						CALLMONITOR 
6572 cd ec 16			call break_point_state  
6575				endm  
# End of macro CALLMONITOR
6575					endif 
6575 cd 4e 08				call storage_read 
6578			 
6578					if DEBUG_FORTH_WORDS 
6578						DMARK "ASr" 
6578 f5				push af  
6579 3a 8d 65			ld a, (.dmark)  
657c 32 bd fb			ld (debug_mark),a  
657f 3a 8e 65			ld a, (.dmark+1)  
6582 32 be fb			ld (debug_mark+1),a  
6585 3a 8f 65			ld a, (.dmark+2)  
6588 32 bf fb			ld (debug_mark+2),a  
658b 18 03			jr .pastdmark  
658d ..			.dmark: db "ASr"  
6590 f1			.pastdmark: pop af  
6591			endm  
# End of macro DMARK
6591						CALLMONITOR 
6591 cd ec 16			call break_point_state  
6594				endm  
# End of macro CALLMONITOR
6594					endif 
6594			 
6594 cd 2f 0d				call ishlzero 
6597 c8					ret z             ; file not found 
6598			 
6598 3e 1e				ld a, display_row_2 + 10 
659a 11 eb f9				ld de, store_page+3 
659d cd e5 0a				call str_at_display 
65a0				 
65a0			; 
65a0			 
65a0 3e 05			ld a, display_row_1+5 
65a2 11 0b 65			ld de, sprompt3 
65a5 cd e5 0a			call str_at_display 
65a8 3e 37			ld a, display_row_3+15 
65aa 11 28 65			ld de, sprompt4 
65ad cd e5 0a			call str_at_display 
65b0			 
65b0 cd f5 0a			call update_display 
65b3			 
65b3 cd fc 67			call cin_wait 
65b6 fe 6e			cp 'n' 
65b8 c8				ret z 
65b9 fe 4e			cp 'N' 
65bb c8				ret z 
65bc			 
65bc cd 52 0a			call delay1s 
65bf			 
65bf 3a ea f9			ld a, (store_page+2) 
65c2 32 de f9			ld (store_openmaxext), a    ; save count of ext 
65c5 3e 01			ld a, 1  
65c7 32 df f9			ld (store_openext), a    ; save count of ext 
65ca			 
65ca			.autof:  
65ca 6f				ld l , a 
65cb				 
65cb 3a e8 f9			ld a, (store_page) 
65ce 67				ld h, a	 
65cf 11 e8 f9			ld de, store_page 
65d2					if DEBUG_FORTH_WORDS 
65d2						DMARK "ASl" 
65d2 f5				push af  
65d3 3a e7 65			ld a, (.dmark)  
65d6 32 bd fb			ld (debug_mark),a  
65d9 3a e8 65			ld a, (.dmark+1)  
65dc 32 be fb			ld (debug_mark+1),a  
65df 3a e9 65			ld a, (.dmark+2)  
65e2 32 bf fb			ld (debug_mark+2),a  
65e5 18 03			jr .pastdmark  
65e7 ..			.dmark: db "ASl"  
65ea f1			.pastdmark: pop af  
65eb			endm  
# End of macro DMARK
65eb						CALLMONITOR 
65eb cd ec 16			call break_point_state  
65ee				endm  
# End of macro CALLMONITOR
65ee					endif 
65ee cd 4e 08				call storage_read 
65f1 cd 2f 0d			call ishlzero 
65f4 28 23			jr z, .autofdone 
65f6			 
65f6 11 ea f9			ld de, store_page+2 
65f9 3e 3c			ld a, display_row_4 
65fb cd e5 0a			call str_at_display 
65fe			 
65fe cd f5 0a			call update_display 
6601 cd 46 0a			call delay250ms 
6604			 
6604			 
6604			 
6604 21 ea f9			ld hl, store_page+2 
6607 cd 33 20			call forthparse 
660a cd 73 20			call forthexec 
660d cd 8a 1f			call forthexec_cleanup 
6610			 
6610				 
6610 3a df f9			ld a, (store_openext) 
6613 3c				inc a 
6614 32 df f9			ld (store_openext), a    ; save count of ext 
6617			 
6617 18 b1			jr .autof 
6619			 
6619			.autofdone: 
6619			 
6619					if DEBUG_FORTH_WORDS 
6619						DMARK "ASx" 
6619 f5				push af  
661a 3a 2e 66			ld a, (.dmark)  
661d 32 bd fb			ld (debug_mark),a  
6620 3a 2f 66			ld a, (.dmark+1)  
6623 32 be fb			ld (debug_mark+1),a  
6626 3a 30 66			ld a, (.dmark+2)  
6629 32 bf fb			ld (debug_mark+2),a  
662c 18 03			jr .pastdmark  
662e ..			.dmark: db "ASx"  
6631 f1			.pastdmark: pop af  
6632			endm  
# End of macro DMARK
6632						CALLMONITOR 
6632 cd ec 16			call break_point_state  
6635				endm  
# End of macro CALLMONITOR
6635					endif 
6635 cd d2 0a			call clear_display 
6638 c9				ret 
6639			 
6639			 
6639			 
6639			endif 
6639			 
6639			 
6639			; eof 
# End of file forth_kernel.asm
6639			;include "nascombasic.asm" 
6639			 
6639			 
6639			; find out where the code ends if loaded into RAM (for SC114) 
6639			;endofcode:  
6639			;	nop 
6639			 
6639			 
6639			; eof 
6639			 
# End of file main.asm
6639			include "firmware_lcd_4x20.asm" 
6639			; **********************************************************************  
6639			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
6639			; **********************************************************************  
6639			;  
6639			; **  Written as a Small Computer Monitor App  
6639			; **  www.scc.me.uk  
6639			;  
6639			; History  
6639			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
6639			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
6639			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
6639			;  
6639			; **********************************************************************  
6639			;  
6639			; This program is an example of one of the methods of interfacing an   
6639			; alphanumeric LCD module.   
6639			;  
6639			; In this example the display is connected to either a Z80 PIO or a   
6639			; simple 8-bit output port.   
6639			;  
6639			; This interfacing method uses 4-bit data mode and uses time delays  
6639			; rather than polling the display's ready status. As a result the   
6639			; interface only requires 6 simple output lines:  
6639			;   Output bit 0 = not used  
6639			;   Output bit 1 = not used  
6639			;   Output bit 2 = RS         High = data, Low = instruction  
6639			;   Output bit 3 = E          Active high  
6639			;   Output bit 4 = DB4  
6639			;   Output bit 5 = DB5  
6639			;   Output bit 6 = DB6  
6639			;   Output bit 7 = DB7  
6639			; Display's R/W is connected to 0v so it is always in write mode  
6639			;  
6639			; This set up should work with any system supporting the RC2014 bus  
6639			  
6639			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
6639			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
6639			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
6639			;  
6639			; **********************************************************************  
6639			  
6639			; **********************************************************************  
6639			; **  Constants  
6639			; **********************************************************************  
6639			; LCD constants required by LCD support module  
6639			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
6639			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
6639			kLCDBitE:   EQU 3              ;Port bit for LCD E signal  
6639			kLCDWidth:  EQU display_cols             ;Width in characters  
6639			  
6639			; **********************************************************************  
6639			; **  Code library usage  
6639			; **********************************************************************  
6639			  
6639			; send character to current cursor position  
6639			; wraps and/or scrolls screen automatically  
6639			  
6639			  
6639			lcd_init:  
6639			  
6639			; SCMonAPI functions used  
6639			  
6639			; Alphanumeric LCD functions used  
6639			; no need to specify specific functions for this module  
6639			  
6639 3e cf		            LD   A, 11001111b  
663b d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
663d 3e 00		            LD   A, 00000000b  
663f d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
6641			  
6641			; Initialise alphanumeric LCD module  
6641 cd ba 66		            CALL fLCD_Init      ;Initialise LCD module  
6644			  
6644 c9				ret  
6645			  
6645			;  
6645			;;  
6645			; lcd functions  
6645			;  
6645			;  
6645			  
6645			; what is at cursor position   
6645			  
6645			;get_cursor:	ld de, (cursor_row)   ;  row + col  
6645			;		call curptr  
6645			;		ret  
6645			  
6645			  
6645			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
6645			  
6645			curptr:  
6645 c5				push bc  
6646 21 53 fb			ld hl, display_fb0  
6649			cpr:	  
6649				; loop for cursor whole row  
6649 0e 14			ld c, display_cols  
664b 23			cpr1:	inc hl  
664c 0d				dec c  
664d 20 fc			jr nz, cpr1  
664f 05				dec b  
6650 20 f7			jr nz, cpr  
6652			  
6652				; add col	  
6652			  
6652 23			cpr2:	inc hl  
6653 1d				dec e  
6654 20 fc			jr nz, cpr2  
6656			  
6656 c1				pop bc  
6657 c9				ret  
6658				  
6658			  
6658			  
6658			  
6658			  
6658			; write the frame buffer given in hl to hardware   
6658 22 5b fa		write_display: ld (display_write_tmp), hl 	   
665b 3e 00			ld a, kLCD_Line1  
665d cd 2b 67		            CALL fLCD_Pos       ;Position cursor to location in A  
6660 06 14			ld b, display_cols  
6662 ed 5b 5b fa		ld de, (display_write_tmp)  
6666 cd b2 66			call write_len_string  
6669				  
6669				  
6669 2a 5b fa			ld hl, (display_write_tmp)  
666c 11 14 00			ld de, display_cols  
666f 19				add hl,de  
6670 22 5b fa			ld (display_write_tmp),hl  
6673			  
6673				  
6673 3e 40			ld a, kLCD_Line2  
6675 cd 2b 67		            CALL fLCD_Pos       ;Position cursor to location in A  
6678 06 14			ld b, display_cols  
667a ed 5b 5b fa		ld de, (display_write_tmp)  
667e cd b2 66			call write_len_string  
6681				  
6681 2a 5b fa			ld hl, (display_write_tmp)  
6684 11 14 00			ld de, display_cols  
6687 19				add hl,de  
6688 22 5b fa			ld (display_write_tmp),hl  
668b			  
668b				  
668b 3e 14			ld a, kLCD_Line3  
668d cd 2b 67		            CALL fLCD_Pos       ;Position cursor to location in A  
6690 06 14			ld b, display_cols  
6692 ed 5b 5b fa		ld de, (display_write_tmp)  
6696 cd b2 66			call write_len_string  
6699				  
6699 2a 5b fa			ld hl, (display_write_tmp)  
669c 11 14 00			ld de, display_cols  
669f 19				add hl,de  
66a0 22 5b fa			ld (display_write_tmp),hl  
66a3			  
66a3				  
66a3 3e 54			ld a, kLCD_Line4  
66a5 cd 2b 67		            CALL fLCD_Pos       ;Position cursor to location in A  
66a8 06 14			ld b, display_cols  
66aa ed 5b 5b fa		ld de, (display_write_tmp)  
66ae cd b2 66			call write_len_string  
66b1 c9					ret  
66b2				  
66b2				; write out a fixed length string given in b from de  
66b2			  
66b2 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
66b3 cd 04 67		            CALL fLCD_Data      ;Write character to display  
66b6 13				inc de  
66b7 10 f9			djnz write_len_string  
66b9 c9				ret  
66ba			  
66ba			; Some other things to do  
66ba			;            LD   A, kLCD_Clear ;Display clear  
66ba			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
66ba			;            LD   A, kLCD_Under ;Display on with underscore cursor  
66ba			;            LD   A, kLCD_On     ;Display on with no cursor  
66ba			;            ;LD   A, kLCD_Off   ;Display off  
66ba			;            CALL fLCD_Inst      ;Send instruction to display  
66ba			;  
66ba			;  
66ba			;            halt  
66ba			;  
66ba			;  
66ba			;MsgHello:   DB  "Hello World!",0  
66ba			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
66ba			  
66ba			; Custom characters 5 pixels wide by 8 pixels high  
66ba			; Up to 8 custom characters can be defined  
66ba			;BitMaps:      
66ba			;; Character 0x00 = Battery icon  
66ba			;            DB  01110b  
66ba			;            DB  11011b  
66ba			;            DB  10001b  
66ba			;            DB  10001b  
66ba			;            DB  11111b  
66ba			;            DB  11111b  
66ba			;            DB  11111b  
66ba			;            DB  11111b  
66ba			;; Character 0x01 = Bluetooth icon  
66ba			;            DB  01100b  
66ba			;            DB  01010b  
66ba			;            DB  11100b  
66ba			;            DB  01000b  
66ba			;            DB  11100b  
66ba			;            DB  01010b  
66ba			;            DB  01100b  
66ba			;            DB  00000b  
66ba			;  
66ba			  
66ba			  
66ba			; **********************************************************************  
66ba			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
66ba			; **********************************************************************  
66ba			;  
66ba			; **  Written as a Small Computer Monitor App   
66ba			; **  Version 0.1 SCC 2018-05-16  
66ba			; **  www.scc.me.uk  
66ba			;  
66ba			; **********************************************************************  
66ba			;  
66ba			; This module provides support for alphanumeric LCD modules using with  
66ba			; *  HD44780 (or compatible) controller  
66ba			; *  5 x 7 pixel fonts  
66ba			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
66ba			; *  Interface via six digital outputs to the display (see below)  
66ba			;  
66ba			; LCD module pinout:  
66ba			;   1  Vss   0v supply  
66ba			;   2  Vdd   5v supply  
66ba			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
66ba			;   4  RS    High = data, Low = instruction  
66ba			;   5  R/W   High = Read, Low = Write  
66ba			;   6  E     Enable signal (active high)  
66ba			;   7  DB0   Data bit 0  
66ba			;   8  DB1   Data bit 1  
66ba			;   9  DB2   Data bit 2  
66ba			;  10  DB3   Data bit 3  
66ba			;  11  DB4   Data bit 4  
66ba			;  12  DB5   Data bit 5  
66ba			;  13  DB6   Data bit 6  
66ba			;  14  DB7   Data bit 7  
66ba			;  15  A     Backlight anode (+)  
66ba			;  16  K     Backlight cathode (-)  
66ba			;  
66ba			; This interfacing method uses 4-bit data mode and uses time delays  
66ba			; rather than polling the display's ready status. As a result the   
66ba			; interface only requires 6 simple output lines:  
66ba			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
66ba			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
66ba			;   LCD DB4 = Microcomputer output port bit 4  
66ba			;   LCD DB5 = Microcomputer output port bit 5  
66ba			;   LCD DB6 = Microcomputer output port bit 6  
66ba			;   LCD DB7 = Microcomputer output port bit 7  
66ba			; Display's R/W is connected to 0v so it is always in write mode  
66ba			; All 6 connections must be on the same port address <kLCDPrt>  
66ba			; This method also allows a decent length of cable from micro to LCD  
66ba			;  
66ba			; **********************************************************************  
66ba			;  
66ba			; To include the code for any given function provided by this module,   
66ba			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
66ba			; the parent source file.  
66ba			; For example:  #REQUIRES   uHexPrefix  
66ba			;  
66ba			; Also #INCLUDE this file at some point after the #REQUIRES statements  
66ba			; in the parent source file.  
66ba			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
66ba			;  
66ba			; These are the function names provided by this module:  
66ba			; fLCD_Init                     ;Initialise LCD  
66ba			; fLCD_Inst                     ;Send instruction to LCD  
66ba			; fLCD_Data                     ;Send data byte to LCD  
66ba			; fLCD_Pos                      ;Position cursor  
66ba			; fLCD_Str                      ;Display string  
66ba			; fLCD_Def                      ;Define custom character  
66ba			;  
66ba			; **********************************************************************  
66ba			;  
66ba			; Requires SCMonAPI.asm to also be included in the project  
66ba			;  
66ba			  
66ba			  
66ba			; **********************************************************************  
66ba			; **  Constants  
66ba			; **********************************************************************  
66ba			  
66ba			; Constants that must be defined externally  
66ba			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
66ba			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
66ba			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
66ba			;kLCDWidth: EQU 20             ;Width in characters  
66ba			  
66ba			; general line offsets in any frame buffer  
66ba			  
66ba			  
66ba			display_row_1: equ 0  
66ba			display_row_2: equ display_row_1+display_cols  
66ba			display_row_3: equ display_row_2 + display_cols  
66ba			display_row_4: equ display_row_3 + display_cols  
66ba			;display_row_4_eol:   
66ba			  
66ba			  
66ba			; Cursor position values for the start of each line  
66ba			kLCD_Line1: EQU 0x00   
66ba			kLCD_Line2: EQU 0x40    
66ba			kLCD_Line3: EQU kLCD_Line1+kLCDWidth  
66ba			kLCD_Line4: EQU kLCD_Line2+kLCDWidth   
66ba			  
66ba			; Instructions to send as A register to fLCD_Inst  
66ba			kLCD_Clear: EQU 00000001b     ;LCD clear  
66ba			kLCD_Off:   EQU 00001000b     ;LCD off  
66ba			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
66ba			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
66ba			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
66ba			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
66ba			  
66ba			; Constants used by this code module  
66ba			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
66ba			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
66ba			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
66ba			  
66ba			  
66ba			  
66ba			; **********************************************************************  
66ba			; **  LCD support functions  
66ba			; **********************************************************************  
66ba			  
66ba			; Initialise alphanumeric LCD module  
66ba			; LCD control register codes:  
66ba			;   DL   0 = 4-bit mode        1 = 8-bit mode  
66ba			;   N    0 = 1-line mode       1 = 2-line mode  
66ba			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
66ba			;   D    0 = Display off       1 = Display on  
66ba			;   C    0 = Cursor off        1 = Cursor on  
66ba			;   B    0 = Blinking off      1 = Blinking on  
66ba			;   ID   0 = Decrement mode    1 = Increment mode  
66ba			;   SH   0 = Entire shift off  1 = Entire shift on  
66ba 3e 28		fLCD_Init:  LD   A, 40  
66bc cd 71 67		            CALL LCDDelay       ;Delay 40ms after power up  
66bf			; For reliable reset set 8-bit mode - 3 times  
66bf cd 5b 67		            CALL WrFn8bit       ;Function = 8-bit mode  
66c2 cd 5b 67		            CALL WrFn8bit       ;Function = 8-bit mode  
66c5 cd 5b 67		            CALL WrFn8bit       ;Function = 8-bit mode  
66c8			; Set 4-bit mode  
66c8 cd 57 67		            CALL WrFn4bit       ;Function = 4-bit mode  
66cb cd 6f 67		            CALL LCDDelay1      ;Delay 37 us or more  
66ce			; Function set  
66ce 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
66d0 cd e3 66		            CALL fLCD_Inst      ;2 line, display on  
66d3			; Display On/Off control  
66d3 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
66d5 cd e3 66		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
66d8			; Display Clear  
66d8 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
66da cd e3 66		            CALL fLCD_Inst      ;Clear display  
66dd			; Entry mode  
66dd 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
66df cd e3 66		            CALL fLCD_Inst      ;Increment mode, shift off  
66e2			; Display module now initialised  
66e2 c9			            RET  
66e3			; ok to here  
66e3			  
66e3			; Write instruction to LCD  
66e3			;   On entry: A = Instruction byte to be written  
66e3			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
66e3 f5			fLCD_Inst:  PUSH AF  
66e4 f5			            PUSH AF  
66e5 cd f7 66		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
66e8 f1			            POP  AF  
66e9 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
66ea 17			            RLA  
66eb 17			            RLA  
66ec 17			            RLA  
66ed cd f7 66		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
66f0 3e 02		            LD   A, 2  
66f2 cd 71 67		            CALL LCDDelay       ;Delay 2 ms to complete   
66f5 f1			            POP  AF  
66f6 c9			            RET  
66f7 e6 f0		Wr4bits:   AND  0xF0           ;Mask so we only have D4 to D7  
66f9 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
66fb cb df		            SET  kLCDBitE, A  
66fd d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
66ff cb 9f		            RES  kLCDBitE, A  
6701 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6703 c9			            RET  
6704			  
6704			  
6704			; Write data to LCD  
6704			;   On entry: A = Data byte to be written  
6704			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6704 f5			fLCD_Data:  PUSH AF  
6705 f5			            PUSH AF  
6706 cd 18 67		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
6709 f1			            POP  AF  
670a 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
670b 17			            RLA  
670c 17			            RLA  
670d 17			            RLA  
670e cd 18 67		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
6711 3e 96		            LD   A, 150  
6713 3d			Wait:      DEC  A              ;Wait a while to allow data   
6714 20 fd		            JR   NZ, Wait      ;  write to complete  
6716 f1			            POP  AF  
6717 c9			            RET  
6718 e6 f0		Wr4bitsa:   AND  0xF0           ;Mask so we only have D4 to D7  
671a cb d7		            SET  kLCDBitRS, A  
671c d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
671e cb df		            SET  kLCDBitE, A  
6720 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
6722 cb 9f		            RES  kLCDBitE, A  
6724 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
6726 cb 97		            RES  kLCDBitRS, A  
6728 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
672a c9			            RET  
672b			  
672b			  
672b			; Position cursor to specified location  
672b			;   On entry: A = Cursor position  
672b			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
672b f5			fLCD_Pos:   PUSH AF  
672c f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
672e cd e3 66		            CALL fLCD_Inst      ;Write instruction to LCD  
6731 f1			            POP  AF  
6732 c9			            RET  
6733			  
6733			  
6733			; Output text string to LCD  
6733			;   On entry: DE = Pointer to null terminated text string  
6733			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
6733 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
6734 b7			            OR   A              ;Null terminator?  
6735 c8			            RET  Z              ;Yes, so finished  
6736 cd 04 67		            CALL fLCD_Data      ;Write character to display  
6739 13			            INC  DE             ;Point to next character  
673a 18 f7		            JR   fLCD_Str       ;Repeat  
673c c9					ret  
673d			  
673d			; Define custom character  
673d			;   On entry: A = Character number (0 to 7)  
673d			;             DE = Pointer to character bitmap data  
673d			;   On exit:  A = Next character number  
673d			;             DE = Next location following bitmap  
673d			;             BC HL IX IY I AF' BC' DE' HL' preserved  
673d			; Character is   
673d c5			fLCD_Def:   PUSH BC  
673e f5			            PUSH AF  
673f 07			            RLCA                ;Calculate location  
6740 07			            RLCA                ;  for bitmap data  
6741 07			            RLCA                ;  = 8 x CharacterNumber  
6742 f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
6744 cd e3 66		            CALL fLCD_Inst      ;Write instruction to LCD  
6747 06 00		            LD   B, 0  
6749 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
674a cd 04 67		            CALL fLCD_Data      ;Write byte to display  
674d 13			            INC  DE             ;Point to next byte  
674e 04			            INC  B              ;Count bytes  
674f cb 58		            BIT  3, B           ;Finish all 8 bytes?  
6751 28 f6		            JR   Z, Loop       ;No, so repeat  
6753 f1			            POP  AF  
6754 3c			            INC  A              ;Increment character number  
6755 c1			            POP  BC  
6756 c9			            RET  
6757			  
6757			  
6757			; **********************************************************************  
6757			; **  Private functions  
6757			; **********************************************************************  
6757			  
6757			; Write function to LCD  
6757			;   On entry: A = Function byte to be written  
6757			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6757 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
6759 18 02		            JR   WrFunc  
675b 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
675d f5			WrFunc:     PUSH AF  
675e d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6760 cb df		            SET  kLCDBitE, A  
6762 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6764 cb 9f		            RES  kLCDBitE, A  
6766 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6768 3e 05		            LD   A, 5  
676a cd 71 67		            CALL LCDDelay       ;Delay 5 ms to complete  
676d f1			            POP  AF  
676e c9			            RET  
676f			  
676f			  
676f			; Delay in milliseconds  
676f			;   On entry: A = Number of milliseconds delay  
676f			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
676f 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
6771 d5			LCDDelay:   PUSH DE  
6772 5f			            LD   E, A           ;Delay by 'A' ms  
6773 16 00		            LD   D, 0  
6775 cd 37 0a		            CALL aDelayInMS  
6778 d1			            POP  DE  
6779 c9			            RET  
677a			  
677a			  
677a			  
677a			  
677a			; eof  
677a			  
# End of file firmware_lcd_4x20.asm
677a			include "firmware_key_4x4.asm" 
677a			  
677a			  
677a			; bit mask for each scan column and row for teing the matrix  
677a			  
677a			; out   
677a 80 40 20 10	key_row_bitmask:    db 128, 64, 32, 16  
677e			; in  
677e 01 02 04 08	key_col_bitmask:    db 1, 2, 4, 8  
6782			  
6782			; row/col to character map  
6782			  
6782			; char, state use   123xxsss   - bit 8,7,6 this key selects specified state, s is this key is member of that state  
6782			;    
6782			  
6782			; physical key matrix map to face of key  
6782			  
6782			  
6782			;      	1	2	3	A  
6782			;   	abc”	def&	ghi$	s1  
6782			;			  
6782			;	4	5	6	B  
6782			; 	jkl,	mno.	pqr:	s2  
6782			;			  
6782			; 	7	8	9	C  
6782			;	stu;	vwx@	yz?!	s3  
6782			;			  
6782			; 	*	0	#	D  
6782			; 	shift lck '	Space < >	Enter ( )	s4  
6782			;       tab bs 		  
6782			  
6782			  
6782			  
6782			  
6782			key_init:  
6782			  
6782			; SCMonAPI functions used  
6782			  
6782			; Alphanumeric LCD functions used  
6782			; no need to specify specific functions for this module  
6782			  
6782			  
6782 3e cf		            LD   A, 11001111b  
6784 d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
6786			;            LD   A, 00000000b  
6786 3e 0f		            LD   A, 00001111b  
6788 d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
678a			  
678a			  
678a				; TODO Configure cursor shapes  
678a			  
678a				; Load cursor shapes   
678a 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
678c 11 9c 67		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
678f 06 02		            LD   B, 2           ;Number of characters to define  
6791 cd 3d 67		.DefLoop:   CALL fLCD_Def       ;Define custom character  
6794 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
6796			  
6796 3e 01				ld a, 1  
6798 32 56 fa			ld (cursor_shape),a  
679b c9				ret  
679c			  
679c			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
679c			; Up to 8 custom characters can be defined  
679c			.cursor_shapes:      
679c			;; Character 0x00 = Normal  
679c 1f			            DB  11111b  
679d 1f			            DB  11111b  
679e 1f			            DB  11111b  
679f 1f			            DB  11111b  
67a0 1f			            DB  11111b  
67a1 1f			            DB  11111b  
67a2 1f			            DB  11111b  
67a3 1f			            DB  11111b  
67a4			;; Character 0x01 = Modifier  
67a4 1f			            DB  11111b  
67a5 1b			            DB  11011b  
67a6 1b			            DB  11011b  
67a7 1b			            DB  11011b  
67a8 1b			            DB  11011b  
67a9 1f			            DB  11111b  
67aa 1b			            DB  11011b  
67ab 1f			            DB  11111b  
67ac			  
67ac			  
67ac			  
67ac			  
67ac			; Display custom character 0  
67ac			;            LD   A, kLCD_Line1+14  
67ac			;            CALL fLCD_Pos       ;Position cursor to location in A  
67ac			;            LD   A, 0  
67ac			;            CALL fLCD_Data      ;Write character in A at cursor  
67ac			  
67ac			; Display custom character 1  
67ac			;            LD   A, kLCD_Line2+14  
67ac			;            CALL fLCD_Pos      ;Position cursor to location in A  
67ac			;            LD   A, 1  
67ac			;            CALL fLCD_Data     ;Write character in A at cursor  
67ac			  
67ac			; keyboard scanning   
67ac			  
67ac			  
67ac			; key_rows: equ 4  
67ac			; key_cols: equ 4  
67ac			; keyscan_table: edu ( tos-stacksize-(key_rows*key_cols))  
67ac			  
67ac			; key_scanr: equ key_row_bitmask  
67ac			; key_scanc: equ key_col_bitmask  
67ac			  
67ac			; key_char_map: equ key_map  
67ac			  
67ac			  
67ac			  
67ac			; character in from keyboard  
67ac			  
67ac ..			.matrix_to_char: db "D#0*C987B654A321"  
67bc			  
67bc			  
67bc			; map the physical key to a char dependant on state  
67bc			  
67bc			.key_map_fa:   
67bc			  
67bc ..					db 'D'  
67bd 0d					db KEY_CR    ; cr  
67be ..					db ' '  
67bf 04					db  KEY_SHIFTLOCK   ; TODO Shift lock  
67c0 ..					db 'C'  
67c1 ..					db 'y'  
67c2 ..					db 'v'  
67c3 ..					db 's'  
67c4 ..					db 'B'  
67c5 ..					db 'p'  
67c6 ..					db 'm'  
67c7 ..					db 'j'  
67c8 ..					db 'A'  
67c9 ..					db 'g'  
67ca ..					db 'd'  
67cb ..					db 'a'  
67cc			  
67cc			.key_map_fb:  
67cc			  
67cc ..					db 'A'  
67cd ..					db '+'   
67ce ..					db '<'  
67cf ..					db  "'"    
67d0			  
67d0 ..					db 'A'  
67d1 ..					db 'z'  
67d2 ..					db 'w'  
67d3 ..					db 't'  
67d4 ..					db 'A'  
67d5 ..					db 'q'  
67d6 ..					db 'n'  
67d7 ..					db 'k'  
67d8 ..					db 'A'  
67d9 ..					db 'h'  
67da ..					db 'e'  
67db ..			 		db 'b'  
67dc			  
67dc			.key_map_fc:   
67dc			  
67dc			  
67dc ..					db 'A'  
67dd ..					db '-'   
67de ..					db '>'  
67df ..					db  '='   	  
67e0 ..					db 'A'  
67e1 ..					db '?'  
67e2 ..					db 'x'  
67e3 ..					db 'u'  
67e4 ..					db 'A'  
67e5 ..					db 'r'  
67e6 ..					db 'o'  
67e7 ..					db 'l'  
67e8 ..					db 'A'  
67e9 ..					db 'i'  
67ea ..					db 'f'  
67eb ..					db 'c'  
67ec			  
67ec				  
67ec			.key_map_fd:  
67ec			  
67ec ..					db 'A'  
67ed ..					db '/'   
67ee ..					db '%'   
67ef 08					db KEY_BS  ; back space  
67f0 ..					db 'A'  
67f1 ..					db '!'  
67f2 ..					db '@'  
67f3 ..					db ';'  
67f4 ..					db 'A'  
67f5 ..					db ':'  
67f6 ..					db '.'  
67f7 ..					db ','  
67f8 ..					db 'A'  
67f9 ..					db '$'  
67fa ..					db '&'  
67fb ..				 	db '"'  
67fc			  
67fc					  
67fc				  
67fc			  
67fc			; add cin and cin_wait  
67fc			  
67fc cd 0d 68		cin_wait: 	call cin  
67ff fe 00			cp 0  
6801 28 f9			jr z, cin_wait   ; block until key press  
6803			  
6803 f5				push af   ; save key pressed  
6804			  
6804 cd 0d 68		.cin_wait1:	call cin  
6807 fe 00			cp 0  
6809 20 f9			jr nz, .cin_wait1  	; wait for key release  
680b			  
680b f1				pop af   ; get key  
680c c9				ret  
680d			  
680d			  
680d cd 1e 68		cin: 	call .mtoc  
6810			  
6810				; no key held  
6810 fe 00			cp 0  
6812 c8				ret z  
6813			  
6813				; stop key bounce  
6813			  
6813			;	ld (key_held),a		 ; save it  
6813 47				ld b, a  
6814			  
6814 c5			.cina1:	push bc  
6815 cd 1e 68			call .mtoc  
6818 c1				pop bc  
6819 b8				cp b  
681a 28 f8			jr z, .cina1  
681c 78				ld a,b		  
681d c9				ret  
681e			  
681e			; detect keyboard modifier key press and apply new overlay to the face key held  
681e			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
681e			  
681e			;.cin_map_modifier:   
681e			;	ld a, (hl)  
681e			;	and 255  
681e			;	ret NZ		; modifier key not flagged  
681e			;  
681e			;	; get key face  
681e			;  
681e			;	ld b,(key_face_held)  
681e			;  
681e			;	ld b, key_cols * key_rows  
681e			;  
681e			;	push de  
681e			;	pop hl  
681e			;  
681e			;.mmod1: ld a,(hl)   ; get map test  
681e			;	cp b  
681e			;	jr z, .mmod2  
681e			;  
681e			;  
681e			;  
681e			;.mmod2: inc hl    ;   
681e			;  
681e			;	  
681e			;  
681e			;	  
681e			;  
681e			;	ld hl,key_actual_pressed  
681e			;	ld (hl),a,  
681e			;	ret  
681e			  
681e				  
681e			  
681e			; map matrix key held to char on face of key  
681e			  
681e			.mtoc:  
681e			  
681e			  
681e				; TODO optimise the code....  
681e			  
681e			; scan keyboard row 1  
681e 3e 80			ld a, 128  
6820 21 d3 fb			ld hl, keyscan_table  
6823 cd 05 69			call .rowscan  
6826			  
6826				   
6826			  
6826 3e 40			ld a, 64  
6828 21 d7 fb			ld hl, keyscan_table+key_cols  
682b cd 05 69			call .rowscan  
682e			  
682e			  
682e			  
682e			  
682e 3e 20			ld a, 32  
6830 21 db fb			ld hl, keyscan_table+(key_cols*2)  
6833 cd 05 69			call .rowscan  
6836			  
6836			  
6836			  
6836 3e 10			ld a, 16  
6838 21 df fb			ld hl, keyscan_table+(key_cols*3)  
683b cd 05 69			call .rowscan  
683e			  
683e			  
683e				; flag if key D is held down and remove from reporting  
683e 01 ec 67			ld bc, .key_map_fd    
6841 21 d3 fb			ld hl, keyscan_table  
6844 11 c5 fb			ld de, key_fd  
6847 cd 97 68			call .key_shift_hold  
684a fe ff			cp 255  
684c 28 33			jr z, .cinmap  
684e				; flag if key C is held down and remove from reporting  
684e 01 dc 67			ld bc, .key_map_fc    
6851 21 d7 fb			ld hl, keyscan_table+key_cols  
6854 11 c6 fb			ld de, key_fc  
6857 cd 97 68			call .key_shift_hold  
685a fe ff			cp 255  
685c 28 23			jr z, .cinmap  
685e				; flag if key B is held down and remove from reporting  
685e 01 cc 67			ld bc, .key_map_fb    
6861 21 db fb			ld hl, keyscan_table+(key_cols*2)  
6864 11 c7 fb			ld de, key_fb  
6867 cd 97 68			call .key_shift_hold  
686a fe ff			cp 255  
686c 28 13			jr z, .cinmap  
686e				; flag if key A is held down and remove from reporting  
686e 01 bc 67			ld bc, .key_map_fa    
6871 21 df fb			ld hl, keyscan_table+(key_cols*3)  
6874 11 c8 fb			ld de, key_fa  
6877 cd 97 68			call .key_shift_hold  
687a fe ff			cp 255  
687c 28 03			jr z, .cinmap  
687e			  
687e 11 ac 67			ld de, .matrix_to_char  
6881			  
6881			  
6881			.cinmap:   
6881				if DEBUG_KEY  
6881			            LD   A, kLCD_Line4  
6881			            CALL fLCD_Pos       ;Position cursor to location in A  
6881					push de  
6881			            LD   DE, keyscan_table  
6881			            CALL fLCD_Str       ;Display string pointed to by DE  
6881					pop de  
6881				endif  
6881			  
6881				; scan key matrix table for any held key  
6881			  
6881				; de holds either the default matrix or one selected above  
6881			  
6881 21 d3 fb			ld hl, keyscan_table  
6884 06 10			ld b,key_cols*key_rows  
6886			  
6886 7e			.cin1:	ld a,(hl)  
6887 fe 23			cp '#'  
6889 28 08			jr z, .cinhit  
688b 23				inc hl  
688c 13				inc de  
688d 05				dec b  
688e 20 f6			jr nz, .cin1  
6890				; no key found held  
6890 3e 00			ld a,0  
6892 c9				ret  
6893 d5			.cinhit: push de  
6894 e1				pop hl  
6895 7e				ld a,(hl)  
6896 c9				ret  
6897			  
6897			; flag a control key is held   
6897			; hl is key pin, de is flag indicator  
6897			  
6897			.key_shift_hold:  
6897 c5				push bc  
6898 3e 01			ld a, 1  
689a 32 56 fa			ld (cursor_shape),a  
689d 06 00			ld b, 0  
689f 7e				ld a, (hl)  
68a0 fe 2e			cp '.'  
68a2 28 0a			jr z, .key_shift1  
68a4 06 ff			ld b, 255  
68a6 3e 2b			ld a, '+'    ; hide key from later scans  
68a8 77				ld (hl),a  
68a9 3e 02			ld a, 2  
68ab 32 56 fa			ld (cursor_shape),a  
68ae			.key_shift1:  
68ae				; write flag indicator  
68ae 78				ld a,b  
68af 12				ld (de),a  
68b0			  
68b0 d1				pop de    ; de now holds the key map ptr  
68b1 c9				ret  
68b2			  
68b2				  
68b2				  
68b2			  
68b2			  
68b2			  
68b2			  
68b2			  
68b2			  
68b2			  
68b2			  
68b2			  
68b2			  
68b2 c9				ret  
68b3			  
68b3			;	push hl  
68b3			;	push de  
68b3			;	push bc  
68b3			;	call keyscan  
68b3			;	; map key matrix to ascii value of key face  
68b3			;  
68b3			;	ld hl, key_face_map  
68b3			;	ld de, keyscan_table  
68b3			;  
68b3			;	; get how many keys to look at  
68b3			;	ld b, keyscan_table_len  
68b3			;	  
68b3			;  
68b3			;	; at this stage fall out on first key hit  
68b3			;	; TODO handle multiple key press  
68b3			;  
68b3			;map1:	ld a,(hl)  
68b3			;	cp '#'  
68b3			;	jr z, keyhit  
68b3			;	inc hl  
68b3			;	inc de  
68b3			;	dec b  
68b3			;	jr nz, map1  
68b3			;nohit:	ld a, 0  
68b3			;	jr keydone  
68b3			;keyhit: push de  
68b3			;	pop hl  
68b3			;	ld a,(hl)  
68b3			;keydone:  
68b3			;	push bc  
68b3			;	push de  
68b3			; 	push hl  
68b3			;	ret   
68b3			;  
68b3			  
68b3			  
68b3			  
68b3			  
68b3			; scan physical key matrix  
68b3			  
68b3			  
68b3			;keyscan:  
68b3			;  
68b3			;; for each key_row use keyscanr bit mask for out  
68b3			;; then read in for keyscanc bitmask  
68b3			;; save result of row scan to keyscantable  
68b3			;  
68b3			;; scan keyboard row 1  
68b3			;  
68b3			;	ld b, key_rows  
68b3			;	ld hl, key_scanr  
68b3			;	ld de, keyscan_table  
68b3			;  
68b3			;rowloop:  
68b3			;  
68b3			;	ld a,(hl)		; out bit mask to energise keyboard row  
68b3			;	call rowscan  
68b3			;	inc hl  
68b3			;	dec b  
68b3			;	jr nz, rowloop  
68b3			;  
68b3			;	ret  
68b3			;  
68b3			;  
68b3			;; pass a out bitmask, b row number  
68b3			;arowscan:   
68b3			;	push bc  
68b3			;  
68b3			;	ld d, b  
68b3			;  
68b3			;	; calculate buffer location for this row  
68b3			;  
68b3			;	ld hl, keyscan_table	  
68b3			;kbufr:  ld e, key_cols  
68b3			;kbufc:	inc hl  
68b3			;	dec e  
68b3			;	jr nz, kbufc  
68b3			;	dec d  
68b3			;	jr nz, kbufr  
68b3			;  
68b3			;	; energise row and read columns  
68b3			;  
68b3			;	out (portbdata),a  
68b3			;	in a,(portbdata)  
68b3			;	ld c,a  
68b3			;  
68b3			;  
68b3			;	; save buffer loc  
68b3			;  
68b3			;	ld (keybufptr), hl  
68b3			;  
68b3			;	ld hl, key_scanc  
68b3			;	ld d, key_cols  
68b3			;  
68b3			;	; for each column check each bit mask  
68b3			;  
68b3			;colloop:  
68b3			;	  
68b3			;  
68b3			;	; reset flags for the row   
68b3			;  
68b3			;	ld b,'.'  
68b3			;	and (hl)  
68b3			;	jr z, maskskip  
68b3			;	ld b,'#'  
68b3			;maskskip:  
68b3			;	; save  key state  
68b3			;	push hl  
68b3			;	ld hl, (keybufptr)  
68b3			;	ld (hl), b  
68b3			;	inc hl  
68b3			;	ld (keybufptr), hl  
68b3			;  
68b3			;	; move to next bit mask  
68b3			;	pop hl  
68b3			;	inc hl  
68b3			;  
68b3			;	dec d  
68b3			;	jr nz, colloop  
68b3			;  
68b3			;	ret  
68b3			;  
68b3			;  
68b3			;;  
68b3			; lcd functions  
68b3			;  
68b3			;  
68b3			  
68b3			;if DEBUG_KEY_MATRIX  
68b3			  
68b3			; test function to display hardware view of matrix state  
68b3			  
68b3			matrix:  
68b3			  
68b3			  
68b3			  
68b3			; scan keyboard row 1  
68b3 3e 80			ld a, 128  
68b5 21 f8 fb			ld hl, keyscan_table_row1  
68b8 cd 05 69			call .rowscan  
68bb			  
68bb 3e 40			ld a, 64  
68bd 21 f3 fb			ld hl, keyscan_table_row2  
68c0 cd 05 69			call .rowscan  
68c3			  
68c3 3e 20			ld a, 32  
68c5 21 ee fb			ld hl, keyscan_table_row3  
68c8 cd 05 69			call .rowscan  
68cb			  
68cb 3e 10			ld a, 16  
68cd 21 e9 fb			ld hl, keyscan_table_row4  
68d0 cd 05 69			call .rowscan  
68d3			  
68d3			; Display text on first line  
68d3 3e 00		            LD   A, kLCD_Line1  
68d5 cd 2b 67		            CALL fLCD_Pos       ;Position cursor to location in A  
68d8 11 f8 fb		            LD   DE, keyscan_table_row1  
68db			            ;LD   DE, MsgHello  
68db cd 33 67		            CALL fLCD_Str       ;Display string pointed to by DE  
68de			  
68de			; Display text on second line  
68de 3e 40		            LD   A, kLCD_Line2  
68e0 cd 2b 67		            CALL fLCD_Pos       ;Position cursor to location in A  
68e3 11 f3 fb		            LD   DE, keyscan_table_row2  
68e6 cd 33 67		            CALL fLCD_Str       ;Display string pointed to by DE  
68e9 3e 14		            LD   A, kLCD_Line3  
68eb cd 2b 67		            CALL fLCD_Pos       ;Position cursor to location in A  
68ee 11 ee fb		            LD   DE, keyscan_table_row3  
68f1 cd 33 67		            CALL fLCD_Str       ;Display string pointed to by DE  
68f4 3e 54		            LD   A, kLCD_Line4  
68f6 cd 2b 67		            CALL fLCD_Pos       ;Position cursor to location in A  
68f9 11 e9 fb		            LD   DE, keyscan_table_row4  
68fc cd 33 67		            CALL fLCD_Str       ;Display string pointed to by DE  
68ff			  
68ff cd 46 0a			call delay250ms  
6902 c3 b3 68			jp matrix  
6905			  
6905			; pass de as row display flags  
6905			.rowscan:   
6905 d3 c1			out (portbdata),a  
6907 db c1			in a,(portbdata)  
6909 4f				ld c,a  
690a				; reset flags for the row   
690a 06 2e			ld b,'.'  
690c e6 01			and 1  
690e 28 02			jr z, .p1on  
6910 06 23			ld b,'#'  
6912			.p1on:  
6912 70				ld (hl), b  
6913 23				inc hl  
6914			  
6914 06 2e			ld b,'.'  
6916 79				ld a,c  
6917 e6 02			and 2  
6919			;	bit 0,a  
6919 28 02			jr z, .p2on  
691b 06 23			ld b,'#'  
691d			.p2on:  
691d 70				ld (hl), b  
691e 23				inc hl  
691f			;  
691f 06 2e			ld b,'.'  
6921 79				ld a,c  
6922 e6 04			and 4  
6924			;;	bit 0,a  
6924 28 02			jr z, .p3on  
6926 06 23			ld b,'#'  
6928			.p3on:  
6928 70				ld (hl), b  
6929 23				inc hl  
692a			;;  
692a 06 2e			ld b,'.'  
692c			;;	bit 0,a  
692c 79				ld a,c  
692d e6 08			and 8  
692f 28 02			jr z, .p4on  
6931 06 23			ld b,'#'  
6933			.p4on:  
6933 70				ld (hl), b  
6934 23				inc hl  
6935			  
6935			; zero term  
6935 06 00			ld b,0  
6937 70				ld (hl), b  
6938			  
6938 c9			.rscandone: ret  
6939			  
6939			  
6939			  
6939			;endif  
6939			  
6939			  
6939			; eof  
# End of file firmware_key_4x4.asm
# End of file os_mini.asm
6939
