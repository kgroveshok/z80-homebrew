# File os_mini.asm
0000			; 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ 0 
0000			CPU_CLOCK_10MHZ: equ 0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			tos:	equ 0fffdh 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
0000			 
0000			 
0000			; Full OS but with the small 4x4 keypad 
0000			 
0000			display_rows: equ 4     ; move out to mini and mega files 
0000			display_cols: equ 20 
0000			 
0000			key_rows: equ 4     ; TODO move out to mini and mega 
0000			key_cols: equ 4    ; TODO move out to mini and mega 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 a9 15			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			;        nop  
0003			;        nop 
0003			;;	org 05h		; null out bdos call 
0003			; 
0003			;        nop  
0003			;        nop  
0003			;        nop 
0003			;;	org 08h 
0003			;;; 
0003			;;	jp cin		; rst 8 - char in 
0003			;;; 
0003			; 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;	org 010h 
0003			;; 
0003			;	jp cout		; rest 010h  - char out 
0003			;; 
0003			;	org 01bh   
0003			; 
0003			;	;jp  		; rst 01bh   - write string to display 
0003			;	jp str_at_display 
0003			; 
0003			; 
0003			;	org 020h 
0003			; 
0003			;	; jp		 ; rst 020h - read char at screen location 
0003			; 
0003			;	org 028h 
0003			 
0003				; jp		 ; rst 028h  - storage i/o 
0003			 
0003			; 	org 030h 
0003			;	jp break_point_state 
0003			  
0003			; $30  
0003			; org 038h 
0003			; $38 
0003			 
0003			; TODO any more important entry points to add to jump table for easier coding use? 
0003			 
0003			 
0003			include "firmware.asm" 
0003			  
0003			; main constants (used here and in firmware)  
0003			  
0003			; TODO have page 0 of storage as bios  
0003			  
0003			Device_A: equ 0h  
0003			Device_B: equ 040h          ; Sound  
0003			  
0003			if BASE_KEV  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_SC114  
0003			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			; TODO fixup for CPM  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			Device_D: equ 0c0h             ; Keyboard and LCD  
0003			  
0003			; Odd specific debug points for testing hardware dev  
0003			  
0003			DEBUG_SOUND: equ 1  
0003			DEBUG_STK_FAULT: equ 0  
0003			DEBUG_INPUT: equ 0     ; Debug input entry code  
0003			DEBUG_KEYCINWAIT: equ 0  
0003			DEBUG_KEYCIN: equ 0  
0003			DEBUG_KEY: equ 0  
0003			DEBUG_KEY_MATRIX: equ 0  
0003			DEBUG_STORECF: equ 0  
0003			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
0003			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
0003			DEBUG_SPI: equ 0    ; low level spi tests  
0003			  
0003			; Enable many break points  
0003			  
0003			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
0003			DEBUG_FORTH_JP: equ 0    ; 4  
0003			DEBUG_FORTH_MALLOC: equ 0  
0003			DEBUG_FORTH_MALLOC_INT: equ 0  
0003			DEBUG_FORTH_DOT: equ 0  
0003			DEBUG_FORTH_DOT_WAIT: equ 0  
0003			DEBUG_FORTH_MATHS: equ 0  
0003			DEBUG_FORTH_TOK: equ 0    ; 4  
0003			DEBUG_FORTH_PARSE: equ 0    ; 3  
0003			DEBUG_FORTH: equ 0  ;2  
0003			DEBUG_FORTH_WORDS: equ 1   ; 1  
0003			DEBUG_FORTH_PUSH: equ 0   ; 1  
0003			DEBUG_FORTH_UWORD: equ 1   ; 1  
0003			  
0003			; Enable key point breakpoints  
0003			  
0003			DEBUG_FORTH_DOT_KEY: equ 0  
0003			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
0003			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
0003			  
0003			; Debug stack imbalances  
0003			  
0003			ON: equ 1  
0003			OFF: equ 0  
0003			  
0003			DEBUG_STACK_IMB: equ 0  
0003			STACK_IMB_STORE: equ 20  
0003			  
0003			; House keeping and protections  
0003			  
0003			DEBUG_FORTH_STACK_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
0003			FORTH_ENABLE_FREE: equ 0  
0003			FORTH_ENABLE_MALLOCFREE: equ 1  
0003			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
0003			FORTH_ENABLE_FLOATMATH: equ 0  
0003			  
0003			  
0003			CALLMONITOR: macro  
0003				call break_point_state  
0003				endm  
0003			  
0003			MALLOC_1: equ 1        ; from dk88   
0003			MALLOC_2: equ 0           ; broke  
0003			MALLOC_3: equ 0           ; really broke  
0003			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
0003			  
0003			if BASE_KEV   
0003			stacksize: equ 512*2  
0003			  
0003			STACK_RET_SIZE: equ 128  
0003			STACK_LOOP_SIZE: equ 512  
0003			STACK_DATA_SIZE: equ 512  
0003			endif  
0003			if BASE_SC114  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			;if STORAGE_SE == 0  
0003			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
0003			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
0003			;endif  
0003			  
0003			; Blocks where directory table is held  
0003			  
0003			; Reducing the number of entries increases the max file size  
0003			  
0003			;STORE_DIR_START: equ 1  
0003			;STORE_DIR_END: equ 33  
0003			  
0003			; Blocks from where file data is stored  
0003			  
0003			;STORE_DATA_START: equ STORE_DIR_END + 1  
0003			  
0003			; Block indicators (<32 are data files)  
0003			  
0003			;STORE_BLOCK_CFG: equ $8f       ; config block  
0003			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
0003			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
0003			;STORE_BLOCK_FREE: equ $85       ; data block free  
0003			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
0003			  
0003			  
0003			  
0003			; Directory entry flags  
0003			  
0003			;STORE_DIR_FREE: equ 0  
0003			;STORE_DIR_FILE:  equ 1  
0003			  
0003			; Structure offsets to directory entries  
0003			;STORE_DE_FLAG: equ 0  
0003			;STORE_DE_MAXEXT: equ 1  
0003			;STORE_DE_FILENAME: equ 2  
0003			  
0003			; Structure offsets to block 0  
0003			  
0003			;STORE_BK0_ISFOR: equ 1  
0003			;STORE_BK0_LABEL: equ 3  
0003			  
0003			; memory allocation   
0003			  
0003			chk_stund: equ tos+2           ; underflow check word  
0003			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
0003			  
0003			; keyscan table needs rows x cols buffer  
0003			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
0003			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
0003			  
0003			keyscan_table_row1: equ chk_stovr -key_cols-1  
0003			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
0003			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
0003			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
0003			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
0003			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
0003			keyscan_scancol: equ keyscan_table-key_cols  
0003			;keyscan_table_len: equ key_rows*key_cols  
0003			;keybufptr: equ keyscan_table - 2  
0003			;keysymbol: equ keybufptr - 1  
0003			key_held: equ keyscan_scancol-1	; currently held  
0003			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
0003			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
0003			key_fa: equ key_repeat_ct -1 ;  
0003			key_fb: equ key_fa -1 ;  
0003			key_fc: equ key_fb -1 ;  
0003			key_fd: equ key_fc -1 ;  
0003			key_face_held: equ key_fd - 1   
0003			  
0003			; flag for enabling/disabling various hardware diags   
0003			  
0003			hardware_diag: equ key_face_held - 1  
0003			  
0003			; hardware config switches  
0003			; TODO add bitmasks on includes for hardware  
0003			; high byte for expansion ids  
0003			;     0000 0000  no card inserted  
0003			;     0000 0001  storage card inserted  
0003			;     0000 0010  spi sd card active  
0003			  
0003			;       
0003			; low byte:  
0003			;     0000 0001   4x4 keypad  
0003			;     0000 0010   full keyboard  
0003			;     0000 0011   spi/ext keyboard  
0003			;     0000 0100   20x4 lcd  
0003			;     0000 1000   40x4 lcd  
0003			;     0000 1100   spi/ext display  
0003			;     0001 0000   ide interface available  
0003			  
0003			hardware_word: equ hardware_diag - 2  
0003			  
0003			; debug marker - optional display of debug point on the debug screens  
0003			  
0003			debug_mark: equ hardware_word - 4  
0003			  
0003			; input_str vars  
0003			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
0003			input_start:  equ input_ptr - 2    ; ptr to the start of string   
0003			input_size: equ input_start -1  ; number of chars  
0003			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
0003			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
0003			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
0003			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
0003			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
0003			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
0003			input_len: equ input_cur_onoff - 5 ; length of current input  
0003			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
0003			  
0003			CUR_BLINK_RATE: equ 15  
0003			  
0003			key_actual_pressed: equ input_cursor - 1   
0003			key_symbol: equ key_actual_pressed - 1   
0003			key_shift: equ key_symbol - 1   
0003			  
0003			; Display allocation  
0003			  
0003			;display_rows: equ 4     ; move out to mini and mega files  
0003			;display_cols: equ 20  
0003			  
0003			display_fb_len: equ display_rows*display_cols  
0003			  
0003			; primary frame buffer     
0003			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
0003			; working frame buffers  
0003			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
0003			display_fb3: equ  display_fb1-display_fb_len - 1  
0003			display_fb2: equ  display_fb3-display_fb_len - 1  
0003			;  
0003			; pointer to active frame buffer  
0003			display_fb_active: equ display_fb2 - 2  
0003			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
0003			display_write_tmp: equ display_lcde1e2 - 2  
0003			  
0003			  
0003			;  
0003			  
0003			;; can load into de directory  
0003			cursor_col: equ display_write_tmp-1  
0003			cursor_row: equ cursor_col-1  
0003			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
0003			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
0003			  
0003			; maths vars  
0003			  
0003			LFSRSeed: equ cursor_shape -20   
0003			randData: equ LFSRSeed - 2  
0003			xrandc: equ randData - 2  
0003			stackstore: equ xrandc - 2  
0003			seed1: equ  stackstore -2   
0003			seed2: equ seed1 - 2  
0003			  
0003			; cf storage vars  
0003			  
0003			iErrorNum:  equ seed2-1         ;Error number  
0003			iErrorReg:  equ iErrorNum -1              ;Error register  
0003			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
0003			  
0003			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
0003			  
0003			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
0003			  
0003			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
0003			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
0003			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
0003			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
0003			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
0003			store_tmpid: equ store_tmp3 - 1		; page temp id  
0003			store_tmpext: equ store_tmpid - 1		; file extent temp  
0003			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
0003			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
0003			store_filecache: equ store_openmaxext+(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
0003			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
0003			;  
0003			; spi vars  
0003			  
0003			  
0003			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
0003			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
0003			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
0003			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
0003			  
0003			;;;;; forth cli params  
0003			  
0003			; TODO use a different frame buffer for forth???  
0003			  
0003			f_cursor_ptr:  equ spi_device - 1  ; offset into frame buffer for any . or EMIT output  
0003			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
0003			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
0003			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
0003			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
0003			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
0003			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
0003			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
0003			  
0003			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
0003			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
0003			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
0003			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
0003			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
0003			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
0003			  
0003			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
0003			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
0003			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
0003			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
0003			chk_data_ovr: equ cli_data_stack -2; overflow check word  
0003			  
0003			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
0003			  
0003			; os/forth token vars  
0003			  
0003			os_last_cmd: equ os_var_array-255  
0003			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
0003			os_current_i: equ os_cli_cmd-2  
0003			os_cur_ptr: equ os_current_i-2  
0003			os_word_scratch: equ os_cur_ptr-30  
0003			os_tok_len: equ os_word_scratch - 2  
0003			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
0003			os_tok_malloc: equ os_tok_ptr - 2  
0003			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
0003			os_input: equ os_last_new_uword-255  
0003			execscratch: equ os_input-255        ; exec cmd eval buffer  
0003			scratch: equ execscratch-255  
0003			  
0003			  
0003			; temp locations for new word processing to save on adding more   
0003			  
0003			os_new_malloc: equ os_input  
0003			os_new_parse_len: equ os_new_malloc + 2  
0003			os_new_word_len: equ os_new_parse_len + 2  
0003			os_new_work_ptr: equ os_new_word_len + 2  
0003			os_new_src_ptr: equ os_new_work_ptr + 2  
0003			os_new_exec: equ os_new_src_ptr + 2  
0003			os_new_exec_ptr: equ os_new_exec + 2  
0003			  
0003			; resume memory alloocations....  
0003			  
0003			os_view_disable: equ scratch - 1  
0003			os_view_af: equ os_view_disable - 2  
0003			os_view_hl: equ os_view_af -2  
0003			os_view_de: equ os_view_hl - 2  
0003			os_view_bc: equ os_view_de - 2  
0003			  
0003			; stack checksum word  
0003			if DEBUG_STACK_IMB  
0003				curframe: equ  os_view_de - 5  
0003				store_sp: equ curframe - (STACK_IMB_STORE*4)  
0003				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			else  
0003				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			endif  
0003			  
0003			; with data stack could see memory filled with junk. need some memory management   
0003			; malloc and free entry points added  
0003			  
0003			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
0003			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			;heap_end: equ free_list-1  ; Starting address of heap  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			heap_end: equ chk_word-1  ; Starting address of heap  
0003			  
0003			  
0003			;if BASE_KEV   
0003			;heap_start: equ 0800eh  ; Starting address of heap  
0003			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;heap_start: equ baseram+15  ; Starting address of heap  
0003			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;endif  
0003			  
0003			  
0003			;;;;  
0003			  
0003			  
0003			; change below to point to last memory alloc above  
0003			topusermem:  equ   heap_start  
0003			  
0003			;if BASE_KEV   
0003			;baseusermem: equ 08000h  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;;aseusermem:     equ    12  
0003			;baseusermem:     equ    prompt  
0003			;;baseusermem:     equ    endofcode  
0003			;endif  
0003			  
0003			  
0003			; **********************************************************************  
0003			; **  Constants  
0003			; **********************************************************************  
0003			  
0003			; Constants used by this code module  
0003			kDataReg:   EQU Device_D           ;PIO port A data register  
0003			kContReg:   EQU Device_D+2           ;PIO port A control register  
0003			  
0003			  
0003			portbdata:  equ Device_D+1    ; port b data  
0003			portbctl:   equ Device_D+3    ; port b control  
0003			  
0003			  
0003			;KEY_SHIFT:   equ 5  
0003			;KEY_SYMBOLSHIFT:  equ 6  
0003			  
0003			KEY_SHIFTLOCK: equ 4  
0003			  
0003			  
0003			KEY_UP: equ 5  
0003			KEY_NEXTWORD: equ 6  
0003			KEY_PREVWORD: equ 7  
0003			KEY_BS: equ 8  
0003			KEY_TAB:  equ 9  
0003			KEY_DOWN: equ 10  
0003			KEY_LEFT: equ 11  
0003			KEY_RIGHT: equ 12  
0003			KEY_CR:   equ 13  
0003			KEY_HOME: equ 14  
0003			KEY_END: equ 15  
0003			  
0003			KEY_F1: equ 16  
0003			KEY_F2: equ 17  
0003			KEY_F3: equ 18  
0003			KEY_F4: equ 19  
0003			  
0003			KEY_F5: equ 20  
0003			KEY_F6: equ 21  
0003			KEY_F7: equ 22  
0003			KEY_F8: equ 23  
0003			  
0003			KEY_F9: equ 24  
0003			KEY_F10: equ 25  
0003			KEY_F11: equ 26  
0003			KEY_F12: equ 27  
0003			  
0003			;if DEBUG_KEY  
0003			;	KEY_MATRIX_NO_PRESS: equ '.'  
0003			;	KEY_SHIFT:   equ '.'  
0003			;	KEY_SYMBOLSHIFT:  equ '.'  
0003			;else  
0003				KEY_SHIFT:   equ '~'  
0003				KEY_SYMBOLSHIFT:  equ '~'  
0003				KEY_MATRIX_NO_PRESS: equ '~'  
0003			;endi  
0003			  
0003			  
0003			  
0003			  
0003			; Macro to make adding debug marks easier  
0003			  
0003			DMARK: macro str  
0003				push af  
0003				ld a, (.dmark)  
0003				ld (debug_mark),a  
0003				ld a, (.dmark+1)  
0003				ld (debug_mark+1),a  
0003				ld a, (.dmark+2)  
0003				ld (debug_mark+2),a  
0003				jr .pastdmark  
0003			.dmark: db str  
0003			.pastdmark: pop af  
0003			  
0003			endm  
0003			  
0003			  
0003			; macro to detect for stack imbalances  
0003			  
0003			include "stackimbal.asm"  
0003			; Macro and code to detect stock imbalances 
0003			 
0003			SPPUSH: equ 0 
0003			 
0003			; Add a stack frame which can be checked before return 
0003			 
0003			STACKFRAME: macro onoff frame1 frame2 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003						exx 
0003			 
0003						ld de, frame1 
0003						ld a, d 
0003						ld hl, curframe 
0003						call hexout 
0003						ld a, e 
0003						ld hl, curframe+2 
0003						call hexout 
0003			  
0003						ld hl, frame1 
0003						push hl 
0003						ld hl, frame2 
0003						push hl 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			endm 
0003			 
0003			STACKFRAMECHK: macro onoff frame1 frame2 
0003			 
0003					 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						exx 
0003						; check stack frame SP 
0003			 
0003						ld hl, frame2 
0003						pop de   ; frame2 
0003			 
0003						call cmp16 
0003						jr nz, .spnosame 
0003						 
0003			 
0003						ld hl, frame1 
0003						pop de   ; frame1 
0003			 
0003						call cmp16 
0003						jr z, .spfrsame 
0003			 
0003						.spnosame: call showsperror 
0003			 
0003						.spfrsame: nop 
0003			 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			 
0003			 
0003			endm 
0003			 
0003			 
0003			; for a sub routine, wrap SP collection and comparisons 
0003			 
0003			; Usage: 
0003			; 
0003			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
0003			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
0003			 
0003			SAVESP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003			 
0003						ld (store_sp+(storeword*4)), sp 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			CHECKSP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003			 
0003						; save SP after last save 
0003				 
0003						ld (store_sp+(storeword*4)+2), sp 
0003			 
0003						push hl 
0003						ld hl, store_sp+(storeword*4) 
0003						call check_stack_sp  
0003						pop hl 
0003			 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			if DEBUG_STACK_IMB 
0003			 
0003			check_stack_sp: 
0003					push de 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					push de 
0003			 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					pop hl 
0003			 
0003			 
0003					; check to see if the same 
0003			 
0003					call cmp16 
0003					jr z, .spsame 
0003			 
0003					; not same 
0003			 
0003					call showsperror 
0003			.spsame: 
0003			 
0003					pop de 
0003			 
0003					ret 
0003			 
0003			.sperr:  db "Stack imbalance",0 
0003			 
0003			 
0003			showsperror: 
0003			 
0003			 
0003				push hl 
0003				push af 
0003				push de 
0003				call clear_display 
0003				ld de, .sperr 
0003				ld a,0 
0003			;	ld de,os_word_scratch 
0003				call str_at_display 
0003				ld a, display_row_1+17 
0003				ld de, debug_mark 
0003				call str_at_display 
0003				ld a, 0 
0003				ld (curframe+4),a 
0003				ld hl, curframe 
0003				ld de, os_word_scratch 
0003				ld a, display_row_4 
0003				call str_at_display 
0003				call update_display 
0003				;call break_point_state 
0003				call cin_wait 
0003			 
0003				ld a, ' ' 
0003				ld (os_view_disable), a 
0003				pop de	 
0003				pop af 
0003				pop hl 
0003				CALLMONITOR 
0003				ret 
0003			 
0003			endif 
0003			 
0003			 
0003			 
0003			; eof 
# End of file stackimbal.asm
0003			  
0003			;TODO macro to calc col and row offset into screen  
0003			  
0003			  
0003			  
0003			hardware_init:  
0003			  
0003 3e 00				ld a, 0  
0005 32 c3 fb				ld (hardware_diag), a  
0008			  
0008					; clear all the buffers  
0008			  
0008 21 02 fb				ld hl, display_fb1  
000b 22 5e fa				ld (display_fb_active), hl  
000e			  
000e cd b6 0a				call clear_display  
0011			  
0011 21 60 fa				ld hl, display_fb2  
0014 22 5e fa				ld (display_fb_active), hl  
0017			  
0017 cd b6 0a				call clear_display  
001a			  
001a					; init primary frame buffer area  
001a 21 53 fb				ld hl, display_fb0  
001d 22 5e fa				ld (display_fb_active), hl  
0020			  
0020 cd b6 0a				call clear_display  
0023			  
0023			  
0023 cd 3a 61				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0026			  
0026 cd 83 62			call key_init  
0029 cd c9 01			call storage_init  
002c			  
002c				; setup malloc functions  
002c			  
002c				if MALLOC_1  
002c cd b2 10				call  heap_init  
002f				endif  
002f				if MALLOC_4  
002f					call  heap_init  
002f				endif  
002f			  
002f				; init sound hardware if present  
002f			  
002f				if SOUND_ENABLE  
002f					call sound_init  
002f				endif  
002f			  
002f				; lcd test sequence  
002f					  
002f cd d9 0a			call update_display  
0032 cd 3a 0a			call delay1s  
0035 3e 2b			ld a,'+'  
0037 cd bb 0a			call fill_display  
003a cd d9 0a			call update_display  
003d cd 3a 0a			call delay1s  
0040 3e 2a			ld a,'*'  
0042 cd bb 0a			call fill_display  
0045 cd d9 0a			call update_display  
0048 cd 3a 0a			call delay1s  
004b 3e 2d			ld a,'-'  
004d cd bb 0a			call fill_display  
0050 cd d9 0a			call update_display  
0053 cd 3a 0a			call delay1s  
0056			  
0056			; boot splash screen  
0056			if display_cols == 20	  
0056 3e 00		        ld a, display_row_1    
0058			else  
0058			        ld a, display_row_1 +10   
0058			endif  
0058 11 89 00			ld de, bootmsg  
005b cd c9 0a			call str_at_display  
005e cd d9 0a			call update_display  
0061			  
0061			  
0061 cd 3a 0a			call delay1s  
0064 cd 3a 0a			call delay1s  
0067			if display_cols == 20	  
0067 3e 2a		            LD   A, display_row_3+2  
0069			else  
0069			            LD   A, display_row_3+12  
0069			endif  
0069 11 9e 00			ld de, bootmsg1  
006c cd c9 0a			call str_at_display  
006f cd d9 0a			call update_display  
0072 cd 3a 0a			call delay1s  
0075 cd 3a 0a			call delay1s  
0078			  
0078			;	ld a, display_row_4+3  
0078			;	ld de, bootmsg2  
0078			;	call str_at_display  
0078			;	call update_display  
0078			;	call delay1s  
0078			;	call delay1s  
0078			  
0078			; debug mark setup  
0078			  
0078 3e 5f		ld a, '_'  
007a 32 bd fb		ld (debug_mark),a  
007d 32 be fb		ld (debug_mark+1),a  
0080 32 bf fb		ld (debug_mark+2),a  
0083 3e 00		ld a,0  
0085 32 c0 fb		ld (debug_mark+3),a  
0088			  
0088 c9					ret  
0089			  
0089			  
0089 .. 00		bootmsg:	db "z80-homebrew OS v1.5",0  
009e .. 00		bootmsg1:	db "by Kevin Groves",0  
00ae			;bootmsg2:	db "Firmware v0.1",0  
00ae			  
00ae			; a 4x20 lcd  
00ae			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00ae			  
00ae			;if display_cols == 20  
00ae			;	include "firmware_lcd_4x20.asm"  
00ae			;endif  
00ae			  
00ae			;if display_cols == 40  
00ae			;	include "firmware_lcd_4x40.asm"  
00ae			;endif  
00ae			  
00ae			;  
00ae			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00ae			; TODO abstract the bit bang video out interface for dual display  
00ae			; TODO wire video out to tx pin on rc2014 bus  
00ae			  
00ae			; must supply cin, and cin_wait for low level hardware abstraction   
00ae			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00ae			; test scancode  
00ae			  
00ae			;;;;;  
00ae			;;;  
00ae			; Moved out to mini and maxi versions  
00ae			;  
00ae			; include "firmware_key_4x4.asm"  
00ae			; using existing 4 wire x 4 resistor array for input  
00ae			;include "firmware_key_4x10.asm"  
00ae			; need to mod the board for 5 rows due to resistor array  
00ae			;include "firmware_key_5x10.asm"  
00ae			  
00ae			; storage hardware interface  
00ae			  
00ae			; use microchip serial eeprom for storage  
00ae			  
00ae			  
00ae			if STORAGE_SE  
00ae				include "firmware_spi.asm"  
00ae			; my spi protocol (used by storage) 
00ae			 
00ae			; SPI pins 
00ae			 
00ae			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00ae			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00ae			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00ae			 
00ae			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00ae			; chip pin 4 gnd 
00ae			 
00ae			 
00ae			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00ae			SPI_CE1: equ 1      ;    port a1 pin 14  
00ae			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00ae			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00ae			SPI_CE4: equ 4      ; port a4     pin 10 
00ae			 
00ae			; active low AND masks 
00ae			 
00ae			;SPI_CE0_MASK: equ    255-1 
00ae			;SPI_CE1_MASK: equ   255-2 
00ae			;SPI_CE2_MASK: equ   255-4 
00ae			;SPI_CE3_MASK: equ   255-8 
00ae			;SPI_CE4_MASK: equ   255-16 
00ae			SPI_CE_HIGH:  equ 255 
00ae			 
00ae			 
00ae			 
00ae			 
00ae			; TODO store port id for spi device ie dev c 
00ae			; TODO store pin for SO 
00ae			; TODO store pin for SI 
00ae			; TODO store pin for SCLK 
00ae			 
00ae			; 
00ae			 
00ae			; ensure that spi bus is in a stable state with default pins  
00ae			 
00ae			se_stable_spi:   
00ae			 
00ae				 ; set DI high, CE high , SCLK low 
00ae				;ld a, SPI_DI | SPI_CE0 
00ae 3e 07			ld a, SPI_DI  
00b0 cd 84 01			call spi_ce_high 
00b3 d3 80			 out (storage_adata),a 
00b5 32 e3 f9			ld (spi_portbyte),a 
00b8			 
00b8				if DEBUG_SPI 
00b8					push hl 
00b8					ld l, a 
00b8					DMARK "SPI" 
00b8					CALLMONITOR 
00b8					pop hl 
00b8				endif 
00b8 c9				ret 
00b9			 
00b9			; byte to send in a 
00b9			 
00b9			spi_send_byte: 
00b9				; save byte to send for bit mask shift out 
00b9 4f			        ld c,a 
00ba 3a e3 f9			ld a,(spi_portbyte) 
00bd				  
00bd				; clock out	each bit of the byte msb first 
00bd			 
00bd 06 08			ld b, 8 
00bf			.ssb1: 
00bf				; clear so bit  
00bf cb bf			res SPI_DI, a 
00c1 cb 11			rl c 
00c3				; if bit 7 is set then carry is set 
00c3 30 02			jr nc, .ssb2 
00c5 cb ff			set SPI_DI,a 
00c7			.ssb2:  ; output bit to ensure it is stable 
00c7 d3 80			out (storage_adata),a 
00c9 00				nop 
00ca				; clock bit high 
00ca cb ef			set SPI_SCLK,a 
00cc d3 80			out (storage_adata),a 
00ce 00				nop 
00cf				; then low 
00cf cb af			res SPI_SCLK,a 
00d1 d3 80			out (storage_adata),a 
00d3 00				nop 
00d4 10 e9			djnz .ssb1 
00d6			 
00d6 32 e3 f9			ld (spi_portbyte),a 
00d9 c9				ret 
00da			 
00da			; TODO low level get byte into A on spi 
00da			 
00da			spi_read_byte:  
00da			 
00da				; save byte to send for bit mask shift out 
00da 0e 00		    ld c,0 
00dc 3a e3 f9			ld a,(spi_portbyte) 
00df				  
00df				; clock out	each bit of the byte msb first 
00df			 
00df			 
00df				; clock bit high 
00df cb ef			set SPI_SCLK,a 
00e1 d3 80			out (storage_adata),a 
00e3 00				nop 
00e4			 
00e4			    ; read DO  
00e4			 
00e4 cb f9		    set 7,c 
00e6 db 80			in a,(storage_adata) 
00e8 cb 77		    bit SPI_DO,a 
00ea 20 02		    jr nz, .b7 
00ec cb b9		    res 7,c 
00ee			.b7: 
00ee				; then low 
00ee cb af			res SPI_SCLK,a 
00f0 d3 80			out (storage_adata),a 
00f2 00				nop 
00f3			     
00f3			 
00f3				; clock bit high 
00f3 cb ef			set SPI_SCLK,a 
00f5 d3 80			out (storage_adata),a 
00f7 00				nop 
00f8			 
00f8			    ; read DO  
00f8			 
00f8 cb f1		    set 6,c 
00fa db 80			in a,(storage_adata) 
00fc cb 77		    bit SPI_DO,a 
00fe 20 02		    jr nz, .b6 
0100 cb b1		    res 6,c 
0102			.b6: 
0102				; then low 
0102 cb af			res SPI_SCLK,a 
0104 d3 80			out (storage_adata),a 
0106 00				nop 
0107			 
0107				; clock bit high 
0107 cb ef			set SPI_SCLK,a 
0109 d3 80			out (storage_adata),a 
010b 00				nop 
010c			 
010c			 
010c			    ; read DO  
010c			 
010c cb e9		    set 5,c 
010e db 80			in a,(storage_adata) 
0110 cb 77		    bit SPI_DO,a 
0112 20 02		    jr nz, .b5 
0114 cb a9		    res 5,c 
0116			.b5: 
0116				; then low 
0116 cb af			res SPI_SCLK,a 
0118 d3 80			out (storage_adata),a 
011a 00				nop 
011b				; clock bit high 
011b cb ef			set SPI_SCLK,a 
011d d3 80			out (storage_adata),a 
011f 00				nop 
0120			 
0120			    ; read DO  
0120			 
0120 cb e1		    set 4,c 
0122 db 80			in a,(storage_adata) 
0124 cb 77		    bit SPI_DO,a 
0126 20 02		    jr nz, .b4 
0128 cb a1		    res 4,c 
012a			.b4: 
012a				; then low 
012a cb af			res SPI_SCLK,a 
012c d3 80			out (storage_adata),a 
012e 00				nop 
012f				; clock bit high 
012f cb ef			set SPI_SCLK,a 
0131 d3 80			out (storage_adata),a 
0133 00				nop 
0134			 
0134			    ; read DO  
0134			 
0134 cb d9		    set 3,c 
0136 db 80			in a,(storage_adata) 
0138 cb 77		    bit SPI_DO,a 
013a 20 02		    jr nz, .b3 
013c cb 99		    res 3,c 
013e			.b3: 
013e				; then low 
013e cb af			res SPI_SCLK,a 
0140 d3 80			out (storage_adata),a 
0142 00				nop 
0143				; clock bit high 
0143 cb ef			set SPI_SCLK,a 
0145 d3 80			out (storage_adata),a 
0147 00				nop 
0148			 
0148			    ; read DO  
0148			 
0148 cb d1		    set 2,c 
014a db 80			in a,(storage_adata) 
014c cb 77		    bit SPI_DO,a 
014e 20 02		    jr nz, .b2 
0150 cb 91		    res 2,c 
0152			.b2: 
0152				; then low 
0152 cb af			res SPI_SCLK,a 
0154 d3 80			out (storage_adata),a 
0156 00				nop 
0157				; clock bit high 
0157 cb ef			set SPI_SCLK,a 
0159 d3 80			out (storage_adata),a 
015b 00				nop 
015c			 
015c			    ; read DO  
015c			 
015c cb c9		    set 1,c 
015e db 80			in a,(storage_adata) 
0160 cb 77		    bit SPI_DO,a 
0162 20 02		    jr nz, .b1 
0164 cb 89		    res 1,c 
0166			.b1: 
0166				; then low 
0166 cb af			res SPI_SCLK,a 
0168 d3 80			out (storage_adata),a 
016a 00				nop 
016b				; clock bit high 
016b cb ef			set SPI_SCLK,a 
016d d3 80			out (storage_adata),a 
016f 00				nop 
0170			 
0170			    ; read DO  
0170			 
0170 cb c1		    set 0,c 
0172 db 80			in a,(storage_adata) 
0174 cb 77		    bit SPI_DO,a 
0176 20 02		    jr nz, .b0 
0178 cb 81		    res 0,c 
017a			.b0: 
017a				; then low 
017a cb af			res SPI_SCLK,a 
017c d3 80			out (storage_adata),a 
017e 00				nop 
017f			 
017f			 
017f 32 e3 f9			ld (spi_portbyte),a 
0182			 
0182			    ; return byte 
0182 79			    ld a,c 
0183			 
0183			 
0183 c9				ret 
0184			 
0184			 
0184			 
0184			spi_ce_high: 
0184			 
0184				if DEBUG_SPI_HARD_CE0 
0184			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0184					ret 
0184			 
0184				endif 
0184			 
0184			 
0184 f5				push af 
0185			 
0185				; send direct ce to port b 
0185 3e ff			ld a, 255 
0187 d3 81			out (storage_bdata), a 
0189			 
0189 f1				pop af 
018a			 
018a				; for port a that shares with spi lines AND the mask 
018a			  
018a				if DEBUG_SPI 
018a					push hl 
018a					ld h, a 
018a				endif 
018a			;	ld c, SPI_CE_HIGH 
018a			;	and c 
018a cb c7			set SPI_CE0, a 
018c cb cf			set SPI_CE1, a 
018e cb d7			set SPI_CE2, a 
0190 cb df			set SPI_CE3, a 
0192 cb e7			set SPI_CE4, a 
0194			 
0194				if DEBUG_SPI 
0194					ld l, a 
0194					DMARK "CEh" 
0194					CALLMONITOR 
0194					pop hl 
0194				endif 
0194 c9				ret 
0195			 
0195			 
0195			spi_ce_low: 
0195			 
0195				if DEBUG_SPI_HARD_CE0 
0195			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0195					ret 
0195			 
0195				endif 
0195			 
0195 c5				push bc 
0196 f5				push af 
0197			 
0197				; send direct ce to port b 
0197 3a e5 f9			ld a, (spi_cartdev) 
019a d3 81			out (storage_bdata), a 
019c			 
019c			 
019c			 
019c				; for port a that shares with spi lines AND the mask 
019c			 
019c 3a e2 f9			ld a, (spi_device)  
019f 4f				ld c, a 
01a0			 
01a0 f1				pop af 
01a1			 
01a1				; detect CEx 
01a1			 
01a1				if DEBUG_SPI 
01a1					push hl 
01a1					ld h, a 
01a1				endif 
01a1			 
01a1 cb 41			bit SPI_CE0, c 
01a3 20 04			jr nz, .cel1 
01a5 cb 87			res SPI_CE0, a 
01a7 18 1e			jr .celn 
01a9			.cel1: 
01a9 cb 49			bit SPI_CE1, c 
01ab 20 04			jr nz, .cel2 
01ad cb 8f			res SPI_CE1, a 
01af 18 16			jr .celn 
01b1			.cel2: 
01b1 cb 51			bit SPI_CE2, c 
01b3 20 04			jr nz, .cel3 
01b5 cb 97			res SPI_CE2, a 
01b7 18 0e			jr .celn 
01b9			.cel3: 
01b9 cb 59			bit SPI_CE3, c 
01bb 20 04			jr nz, .cel4 
01bd cb 9f			res SPI_CE3, a 
01bf 18 06			jr .celn 
01c1			.cel4: 
01c1 cb 61			bit SPI_CE4, c 
01c3 20 02			jr nz, .celn 
01c5 cb a7			res SPI_CE4, a 
01c7			.celn: 
01c7			 
01c7			 
01c7			 
01c7			;	add c 
01c7			 
01c7				if DEBUG_SPI 
01c7					ld l, a 
01c7					DMARK "CEl" 
01c7					CALLMONITOR 
01c7					pop hl 
01c7				endif 
01c7 c1				pop bc 
01c8 c9				ret 
01c9			 
01c9			 
01c9			 
01c9			; eof 
01c9			 
01c9			 
01c9			 
01c9			 
01c9			 
# End of file firmware_spi.asm
01c9				include "firmware_seeprom.asm"  
01c9			; 
01c9			; persisent storage interface via microchip serial eeprom 
01c9			 
01c9			; port a pio 2 
01c9			; pa 7 - si 
01c9			; pa 6 - sclk  
01c9			; pa 5 - so 
01c9			; pa 4 - cs 
01c9			; pa 3 - cs 
01c9			; pa 2 - cs 
01c9			; pa 1 - cs 
01c9			; pa 0 - cs 
01c9			; 
01c9			; TODO get block 
01c9			; TODO save block 
01c9			; TODO load file 
01c9			; TODO save file 
01c9			; TODO get dir  
01c9			 
01c9			;  
01c9			storage_adata: equ Device_C    ; device c port a - onboard storage 
01c9			storage_actl: equ Device_C+2     ; device c port a 
01c9			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
01c9			storage_bctl: equ Device_C+3     ; device c port b 
01c9			 
01c9			 
01c9			; TODO move these to hardware driver file 
01c9			 
01c9			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
01c9			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
01c9			; storage bank file system format 
01c9			; 
01c9			; first page of bank: 
01c9			; 	addr 0 - status check 
01c9			;       addr 1 - write protect flag 
01c9			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
01c9			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
01c9			;         TODO see if scanning whole of for available next file id is fast enough 
01c9			;	addr 4 > zero term string of bank label 
01c9			; 
01c9			;        
01c9			;  
01c9			; first page of any file: 
01c9			;      byte 0 - file id  
01c9			;      byte 1-17 - fixed file name  
01c9			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
01c9			; 
01c9			; other pages of any file: 
01c9			;      byte 0 - file id 
01c9			;      byte 1> - file data 
01c9			; 
01c9			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
01c9			;  
01c9			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
01c9			 
01c9			 
01c9			;storage_so_bit: 5 
01c9			;storage_si_bit: 7 
01c9			;storage_sclk_bit: 6 
01c9			  
01c9			 
01c9			; init storage pio 
01c9			 
01c9			storage_init: 
01c9			 
01c9 3e cf		            LD   A, 11001111b 
01cb d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
01cd 3e 00		            LD   A, 00000000b 
01cf cb f7			set SPI_DO,a 
01d1			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
01d1 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
01d3			 
01d3 3e cf		            LD   A, 11001111b 
01d5 d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
01d7 3e 00		            LD   A, 00000000b 
01d9 d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
01db			 
01db				; set all external spi devices off 
01db 3e 00			ld a, 0 
01dd 32 e2 f9			ld (spi_device), a 
01e0 32 e5 f9			ld (spi_cartdev), a 
01e3			 
01e3					; ensure the spi bus is in a default stable state 
01e3 cd ae 00				call se_stable_spi 
01e6			 
01e6			; TODO scan spi bus and gather which storage banks are present 
01e6			 
01e6			; populate store_bank_active  
01e6			; for each ce line activate and attempt to write first byte of bank and read back 
01e6			; if zero is returned then bank is empty 
01e6			;   
01e6			; 
01e6			 
01e6					; init file extent cache to save on slow reads 
01e6			 
01e6			;	ld hl, store_filecache 
01e6			;	ld de, 0 
01e6			;	ld hl,(de)	 
01e6			 
01e6			 
01e6 c9			    ret 
01e7			 
01e7			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
01e7			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
01e7			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
01e7			 
01e7			; INSTRUCTION SET 
01e7			; READ 0000 0011 Read data from memory array beginning at selected address 
01e7			; WRITE 0000 0010 Write data to memory array beginning at selected address 
01e7			; WREN 0000 0110 Set the write enable latch (enable write operations) 
01e7			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
01e7			; RDSR 0000 0101 Read STATUS register 
01e7			; WRSR 0000 0001 Write STATUS register 
01e7			; PE 0100 0010 Page Erase – erase one page in memory array 
01e7			; SE 1101 1000 Sector Erase – erase one sector in memory array 
01e7			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
01e7			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
01e7			 
01e7			; TODO send byte steam for page without setting the address for every single byte 
01e7			; TODO read byte  
01e7			 
01e7			; byte in a 
01e7			; address in hl  
01e7			se_writebyte: 
01e7			        
01e7			    ;   ld c, a 
01e7 f5			        push af 
01e8 e5			        push hl 
01e9			 
01e9			    ; initi write mode 
01e9			    ; 
01e9			    ;CS low 
01e9			 
01e9 3a e3 f9		       ld a,(spi_portbyte) 
01ec cd 95 01			call spi_ce_low 
01ef			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01ef d3 80		       out (storage_adata),a 
01f1 32 e3 f9		       ld (spi_portbyte), a 
01f4			 
01f4			    ;clock out wren instruction 
01f4			 
01f4 3e 06		    ld a, store_wren_ins 
01f6 cd b9 00		    call spi_send_byte  
01f9			 
01f9			    ;cs high to enable write latch 
01f9			 
01f9 3a e3 f9		       ld a,(spi_portbyte) 
01fc cd 84 01			call spi_ce_high 
01ff			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
01ff d3 80		       out (storage_adata),a 
0201 32 e3 f9		       ld (spi_portbyte), a 
0204			 
0204 00				nop 
0205			    ; 
0205			    ; intial write data 
0205			    ; 
0205			    ; cs low 
0205			     
0205 3a e3 f9		       ld a,(spi_portbyte) 
0208 cd 95 01			call spi_ce_low 
020b			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
020b d3 80		       out (storage_adata),a 
020d 32 e3 f9		       ld (spi_portbyte), a 
0210			 
0210			    ; clock out write instruction 
0210			     
0210 3e 02		    ld a, store_write_ins  
0212 cd b9 00		    call spi_send_byte  
0215			 
0215			    ; clock out address (depending on address size) 
0215			     
0215 e1			    pop hl 
0216 7c			    ld a,h    ; address out msb first 
0217 cd b9 00		    call spi_send_byte  
021a 7d			    ld a,l 
021b cd b9 00		    call spi_send_byte  
021e			 
021e			    ; clock out byte(s) for page 
021e			 
021e f1			    pop af 
021f cd b9 00		    call spi_send_byte  
0222			 
0222			    ; end write with ce high 
0222 3a e3 f9		       ld a,(spi_portbyte) 
0225			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
0225 cd 84 01			call spi_ce_high 
0228 d3 80		       out (storage_adata),a 
022a 32 e3 f9		       ld (spi_portbyte), a 
022d			 
022d				; pause for internal write cycle 
022d 3e 0a			ld a, 10 
022f cd 1f 0a			call aDelayInMS 
0232 c9			    ret 
0233			 
0233			; buffer to write in de 
0233			; address in hl  
0233			se_writepage: 
0233			        
0233			    ;   ld c, a 
0233 d5				push de 
0234 e5			        push hl 
0235			 
0235			    ; initi write mode 
0235			    ; 
0235			    ;CS low 
0235			 
0235 3a e3 f9		       ld a,(spi_portbyte) 
0238 cd 95 01			call spi_ce_low 
023b			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
023b d3 80		       out (storage_adata),a 
023d 32 e3 f9		       ld (spi_portbyte), a 
0240			 
0240			    ;clock out wren instruction 
0240			 
0240 3e 06		    ld a, store_wren_ins 
0242 cd b9 00		    call spi_send_byte  
0245			 
0245			    ;cs high to enable write latch 
0245			 
0245 3a e3 f9		       ld a,(spi_portbyte) 
0248 cd 84 01			call spi_ce_high 
024b			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
024b d3 80		       out (storage_adata),a 
024d 32 e3 f9		       ld (spi_portbyte), a 
0250			 
0250 00				nop 
0251			    ; 
0251			    ; intial write data 
0251			    ; 
0251			    ; cs low 
0251			     
0251 3a e3 f9		       ld a,(spi_portbyte) 
0254			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0254 cd 95 01			call spi_ce_low 
0257 d3 80		       out (storage_adata),a 
0259 32 e3 f9		       ld (spi_portbyte), a 
025c			 
025c			    ; clock out write instruction 
025c			     
025c 3e 02		    ld a, store_write_ins  
025e cd b9 00		    call spi_send_byte  
0261			 
0261			    ; clock out address (depending on address size) 
0261			     
0261 e1			    pop hl 
0262 7c			    ld a,h    ; address out msb first 
0263 cd b9 00		    call spi_send_byte  
0266 7d			    ld a,l 
0267 cd b9 00		    call spi_send_byte  
026a			 
026a			    ; clock out byte(s) for page 
026a			 
026a e1				pop hl 
026b 06 40			ld b, STORE_BLOCK_PHY 
026d			.bytewrite: 
026d			 
026d 7e				ld a,(hl) 
026e e5			    push hl 
026f c5				push bc 
0270 cd b9 00		    call spi_send_byte  
0273 c1				pop bc 
0274 e1				pop hl 
0275			 
0275			    ; end write with ce high 
0275 3a e3 f9		       ld a,(spi_portbyte) 
0278 cd 84 01			call spi_ce_high 
027b			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
027b d3 80		       out (storage_adata),a 
027d 32 e3 f9		       ld (spi_portbyte), a 
0280			 
0280 23				inc hl 
0281 10 ea			djnz .bytewrite 
0283			 
0283				; pause for internal write cycle 
0283 3e 64			ld a, 100 
0285 cd 1f 0a			call aDelayInMS 
0288 c9			    ret 
0289			; returns byte in a 
0289			; address in hl  
0289			se_readbyte: 
0289 d5				push de 
028a c5				push bc 
028b			 
028b			    ;   ld c, a 
028b e5			        push hl 
028c			 
028c			    ; initi write mode 
028c			    ; 
028c			    ;CS low 
028c			 
028c 3a e3 f9		       ld a,(spi_portbyte) 
028f cd 95 01			call spi_ce_low 
0292			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0292 d3 80		       out (storage_adata),a 
0294 32 e3 f9		       ld (spi_portbyte), a 
0297			 
0297			    ;clock out wren instruction 
0297			 
0297 3e 03		    ld a, store_read_ins 
0299 cd b9 00		    call spi_send_byte  
029c			 
029c			 
029c			    ; clock out address (depending on address size) 
029c			     
029c e1			    pop hl 
029d 7c			    ld a,h    ; address out msb first 
029e cd b9 00		    call spi_send_byte  
02a1 7d			    ld a,l 
02a2 cd b9 00		    call spi_send_byte  
02a5			 
02a5			    ; clock in byte(s) for page 
02a5			 
02a5 cd da 00		    call spi_read_byte  
02a8 f5				push af 
02a9			 
02a9			    ; end write with ce high 
02a9 3a e3 f9		       ld a,(spi_portbyte) 
02ac			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02ac cd 84 01			call spi_ce_high 
02af d3 80		       out (storage_adata),a 
02b1 32 e3 f9		       ld (spi_portbyte), a 
02b4			 
02b4 f1				pop af 
02b5			 
02b5 c1				pop bc 
02b6 d1				pop de 
02b7			 
02b7 c9			    ret 
02b8			 
02b8			if DEBUG_STORESE 
02b8			 
02b8			storageput:  
02b8			 
02b8			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
02b8			 
02b8 21 ba ef			ld hl,scratch+2 
02bb cd c6 0f			call get_word_hl 
02be			 
02be				; stuff it here for the moment as it will be overwritten later anyway 
02be			 
02be 22 db f2			ld (os_cur_ptr),hl	 
02c1			 
02c1			 
02c1			; get pointer to start of string 
02c1			 
02c1 21 bf ef			ld hl, scratch+7 
02c4			 
02c4			; loop writing char of string to eeprom 
02c4			 
02c4 7e			.writestr:	ld a,(hl) 
02c5 fe 00				cp 0 
02c7 28 12				jr z, .wsdone		; done writing 
02c9 e5					push hl 
02ca 2a db f2				ld hl,(os_cur_ptr) 
02cd cd e7 01				call se_writebyte 
02d0			 
02d0 2a db f2				ld hl,(os_cur_ptr)	 ; save next eeprom address 
02d3 23					inc hl 
02d4 22 db f2				ld (os_cur_ptr),hl 
02d7			 
02d7					; restore string pointer and get next char 
02d7			 
02d7 e1					pop hl 
02d8 23					inc hl 
02d9 18 e9				jr .writestr 
02db			 
02db			 
02db			 
02db			.wsdone: 
02db			 
02db			 
02db			; when done load first page into a buffer  
02db			 
02db 21 00 80				ld hl,08000h		; start in ram 
02de 22 db f2				ld (os_cur_ptr),hl 
02e1 21 00 00				ld hl, 0		 ; start of page 
02e4 22 e0 ef				ld (scratch+40),hl	; hang on to it 
02e7			 
02e7 06 80				ld b, 128		; actually get more then one page 
02e9 c5			.wsload:	push bc 
02ea 2a e0 ef				ld hl,(scratch+40) 
02ed e5					push hl 
02ee cd 89 02				call se_readbyte 
02f1			 
02f1					; a now as the byte 
02f1			 
02f1 2a db f2				ld hl,(os_cur_ptr) 
02f4 77					ld (hl),a 
02f5					; inc next buffer area 
02f5 23					inc hl 
02f6 22 db f2				ld (os_cur_ptr),hl 
02f9			 
02f9					; get eeprom position, inc and save for next round 
02f9 e1					pop hl		 
02fa 23					inc hl 
02fb 22 e0 ef				ld (scratch+40),hl 
02fe c1					pop bc 
02ff 10 e8				djnz .wsload 
0301			 
0301			; set 'd' pointer to start of buffer 
0301			 
0301 21 00 80				ld hl,08000h 
0304 22 db f2				ld (os_cur_ptr),hl 
0307			 
0307			 
0307 c9			ret 
0308			 
0308			 
0308 c9			storageread: ret 
0309			 
0309			 
0309			 
0309			 
0309			 
0309			 
0309			endif 
0309			 
0309			 
0309			 
# End of file firmware_seeprom.asm
0309			else  
0309			   ; create some stubs for the labels  
0309			se_readbyte: ret  
0309			se_writebyte: ret  
0309			storage_init: ret  
0309			  
0309			endif  
0309			  
0309			; use cf card for storage - throwing timeout errors. Hardware or software?????  
0309			;include "firmware_cf.asm"  
0309			  
0309			; load up high level storage hardward abstractions  
0309			include "firmware_storage.asm"  
0309			 
0309			; persisent storage hardware abstraction layer  
0309			 
0309			 
0309			 
0309			; Block 0 on storage is a config state 
0309			 
0309			 
0309			 
0309			; TODO add read phy block and write phy block functions 
0309			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
0309			 
0309			; Abstraction layer  
0309			 
0309			; Logocial block size is same size as physical size - using tape concept 
0309			 
0309			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
0309			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
0309			 
0309			 
0309			 
0309			; Filesystem layout (Logical layout) 
0309			; 
0309			; Block 0 - Bank config  
0309			; 
0309			;      Byte - 0 file id counter 
0309			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0309			;      Byte - 3-20 zero terminated bank label 
0309			; 
0309			; Block 1 > File storage 
0309			; 
0309			;      Byte 0 file id    - block 0 file details 
0309			;      Byte 1 block id - block 0 is file  
0309			;            Byte 2-15 - File name 
0309			; 
0309			;       - to end of block data 
0309			; 
0309			 
0309			 
0309			; Read Block 
0309			; ---------- 
0309			; 
0309			; With current bank 
0309			;  
0309			; Get block number to read 
0309			; Load physical blocks starting at start block into buffer 
0309			 
0309			; de points to buffer to use 
0309			; hl holds logical block number  
0309			 
0309			storage_read_block: 
0309			 
0309				; TODO bank selection 
0309			 
0309				; for each of the physical blocks read it into the buffer 
0309 06 40			ld b, STORE_BLOCK_PHY 
030b			 
030b				if DEBUG_STORESE 
030b d5					push de 
030c				endif 
030c				 
030c			.rl1:    
030c			 
030c				; read physical block at hl into de 
030c			        ; increment hl and de to next read position on exit 
030c			 
030c e5				push hl 
030d d5				push de	 
030e c5				push bc 
030f			;	if DEBUG_STORESE 
030f			;		push af 
030f			;		ld a, 'R' 
030f			;		ld (debug_mark),a 
030f			;		pop af 
030f			;		CALLMONITOR 
030f			;	endif 
030f cd 89 02			call se_readbyte 
0312			;	if DEBUG_STORESE 
0312			;		ld a,(spi_portbyte) 
0312			;		ld l, a 
0312			;		push af 
0312			;		ld a, '1' 
0312			;		ld (debug_mark),a 
0312			;		pop af 
0312			;		CALLMONITOR 
0312			;	endif 
0312 c1				pop bc 
0313 d1				pop de 
0314 e1				pop hl 
0315 12				ld (de),a 
0316 23				inc hl 
0317 13				inc de 
0318			 
0318			;	if DEBUG_STORESE 
0318			;		push af 
0318			;		ld a, 'r' 
0318			;		ld (debug_mark),a 
0318			;		pop af 
0318			;		CALLMONITOR 
0318			;	endif 
0318			 
0318 10 f2			djnz .rl1 
031a			 
031a				if DEBUG_STORESE 
031a					DMARK "SRB" 
031a f5				push af  
031b 3a 2f 03			ld a, (.dmark)  
031e 32 bd fb			ld (debug_mark),a  
0321 3a 30 03			ld a, (.dmark+1)  
0324 32 be fb			ld (debug_mark+1),a  
0327 3a 31 03			ld a, (.dmark+2)  
032a 32 bf fb			ld (debug_mark+2),a  
032d 18 03			jr .pastdmark  
032f ..			.dmark: db "SRB"  
0332 f1			.pastdmark: pop af  
0333			endm  
# End of macro DMARK
0333 d1					pop de 
0334			; 
0334			;		push af 
0334			;		ld a, 'R' 
0334			;		ld (debug_mark),a 
0334			;		pop af 
0334					CALLMONITOR 
0334 cd d3 13			call break_point_state  
0337				endm  
# End of macro CALLMONITOR
0337				endif 
0337 c9				ret	 
0338				 
0338			 
0338			; File Size 
0338			; --------- 
0338			; 
0338			;   hl file id 
0338			; 
0338			;  returns in hl the number of blocks 
0338			 
0338			storage_file_size: 
0338 5d				ld e, l 
0339 16 00			ld d, 0 
033b 21 40 00			ld hl, STORE_BLOCK_PHY 
033e					if DEBUG_FORTH_WORDS 
033e						DMARK "SIZ" 
033e f5				push af  
033f 3a 53 03			ld a, (.dmark)  
0342 32 bd fb			ld (debug_mark),a  
0345 3a 54 03			ld a, (.dmark+1)  
0348 32 be fb			ld (debug_mark+1),a  
034b 3a 55 03			ld a, (.dmark+2)  
034e 32 bf fb			ld (debug_mark+2),a  
0351 18 03			jr .pastdmark  
0353 ..			.dmark: db "SIZ"  
0356 f1			.pastdmark: pop af  
0357			endm  
# End of macro DMARK
0357						CALLMONITOR 
0357 cd d3 13			call break_point_state  
035a				endm  
# End of macro CALLMONITOR
035a					endif 
035a cd 1f 06			call storage_findnextid 
035d			 
035d cd 38 0c			call ishlzero 
0360			;	ld a, l 
0360			;	add h 
0360			;	cp 0 
0360 c8				ret z			; block not found so EOF 
0361			 
0361 11 e8 f9			ld de, store_page 
0364 cd 09 03			call storage_read_block 
0367			 
0367 3a ea f9			ld a, (store_page+2)	 ; get extent count 
036a 6f				ld l, a 
036b 26 00			ld h, 0 
036d c9			 	ret 
036e			 
036e			 
036e			; Write Block 
036e			; ----------- 
036e			; 
036e			; With current bank 
036e			;  
036e			; Get block number to write 
036e			; Write physical blocks starting at start block from buffer 
036e			  
036e			storage_write_block: 
036e				; TODO bank selection 
036e			 
036e				; for each of the physical blocks read it into the buffer 
036e 06 40			ld b, STORE_BLOCK_PHY 
0370			 
0370				if DEBUG_STORESE 
0370					DMARK "SWB" 
0370 f5				push af  
0371 3a 85 03			ld a, (.dmark)  
0374 32 bd fb			ld (debug_mark),a  
0377 3a 86 03			ld a, (.dmark+1)  
037a 32 be fb			ld (debug_mark+1),a  
037d 3a 87 03			ld a, (.dmark+2)  
0380 32 bf fb			ld (debug_mark+2),a  
0383 18 03			jr .pastdmark  
0385 ..			.dmark: db "SWB"  
0388 f1			.pastdmark: pop af  
0389			endm  
# End of macro DMARK
0389			 
0389					;push af 
0389					;ld a, 'W' 
0389					;ld (debug_mark),a 
0389					;pop af 
0389					CALLMONITOR 
0389 cd d3 13			call break_point_state  
038c				endm  
# End of macro CALLMONITOR
038c				endif 
038c			 
038c			; might not be working 
038c			;	call se_writepage 
038c			 
038c			;	ret 
038c			; 
038c			 
038c			 
038c			 
038c			.wl1:    
038c			 
038c				; read physical block at hl into de 
038c			        ; increment hl and de to next read position on exit 
038c			 
038c e5				push hl 
038d d5				push de	 
038e c5				push bc 
038f 1a				ld a,(de) 
0390				;if DEBUG_STORESE 
0390			;		push af 
0390			;		ld a, 'W' 
0390			;		ld (debug_mark),a 
0390			;		pop af 
0390			;		CALLMONITOR 
0390			;	endif 
0390 cd e7 01			call se_writebyte 
0393			;	call delay250ms 
0393 00				nop 
0394 00				nop 
0395 00				nop 
0396			;	if DEBUG_STORESE 
0396			;		push af 
0396			;		ld a, 'w' 
0396			;		ld (debug_mark),a 
0396			;		pop af 
0396			;		CALLMONITOR 
0396			;	endif 
0396 c1				pop bc 
0397 d1				pop de 
0398 e1				pop hl 
0399 23				inc hl 
039a 13				inc de 
039b			 
039b			 
039b 10 ef			djnz .wl1 
039d			 
039d				if DEBUG_STORESE 
039d					DMARK "SW2" 
039d f5				push af  
039e 3a b2 03			ld a, (.dmark)  
03a1 32 bd fb			ld (debug_mark),a  
03a4 3a b3 03			ld a, (.dmark+1)  
03a7 32 be fb			ld (debug_mark+1),a  
03aa 3a b4 03			ld a, (.dmark+2)  
03ad 32 bf fb			ld (debug_mark+2),a  
03b0 18 03			jr .pastdmark  
03b2 ..			.dmark: db "SW2"  
03b5 f1			.pastdmark: pop af  
03b6			endm  
# End of macro DMARK
03b6			 
03b6					;push af 
03b6					;ld a, 'W' 
03b6					;ld (debug_mark),a 
03b6					;pop af 
03b6					CALLMONITOR 
03b6 cd d3 13			call break_point_state  
03b9				endm  
# End of macro CALLMONITOR
03b9				endif 
03b9 c9				ret	 
03ba			 
03ba			; Init bank 
03ba			; --------- 
03ba			; 
03ba			; With current bank 
03ba			; 
03ba			; Setup block 0 config 
03ba			;     Set 0 file id counter 
03ba			;     Set formatted byte pattern 
03ba			;     Zero out bank label 
03ba			;      
03ba			; For every logical block write 0-1 byte as null 
03ba			 
03ba			storage_get_block_0: 
03ba			 
03ba				; TODO check presence 
03ba			 
03ba				; get block 0 config 
03ba			 
03ba 21 00 00			ld hl, 0 
03bd 11 e8 f9			ld de, store_page 
03c0 cd 09 03			call storage_read_block 
03c3			 
03c3				if DEBUG_STORESE 
03c3					DMARK "SB0" 
03c3 f5				push af  
03c4 3a d8 03			ld a, (.dmark)  
03c7 32 bd fb			ld (debug_mark),a  
03ca 3a d9 03			ld a, (.dmark+1)  
03cd 32 be fb			ld (debug_mark+1),a  
03d0 3a da 03			ld a, (.dmark+2)  
03d3 32 bf fb			ld (debug_mark+2),a  
03d6 18 03			jr .pastdmark  
03d8 ..			.dmark: db "SB0"  
03db f1			.pastdmark: pop af  
03dc			endm  
# End of macro DMARK
03dc 11 e8 f9				ld de, store_page 
03df			;		push af 
03df			;		ld a, 'i' 
03df			;		ld (debug_mark),a 
03df			;		pop af 
03df					CALLMONITOR 
03df cd d3 13			call break_point_state  
03e2				endm  
# End of macro CALLMONITOR
03e2				endif 
03e2			 
03e2				; is this area formatted? 
03e2			 
03e2			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03e2 2a e9 f9			ld hl, (store_page+1) 
03e5 3e 80			ld a,0x80 
03e7 bd				cp l 
03e8 20 22			jr nz, .ininotformatted 
03ea				; do a double check 
03ea 3e 27			ld a, 0x27 
03ec bc				cp h 
03ed 20 1d			jr nz, .ininotformatted 
03ef			 
03ef				; formatted then 
03ef			 
03ef				if DEBUG_STORESE 
03ef					DMARK "SB1" 
03ef f5				push af  
03f0 3a 04 04			ld a, (.dmark)  
03f3 32 bd fb			ld (debug_mark),a  
03f6 3a 05 04			ld a, (.dmark+1)  
03f9 32 be fb			ld (debug_mark+1),a  
03fc 3a 06 04			ld a, (.dmark+2)  
03ff 32 bf fb			ld (debug_mark+2),a  
0402 18 03			jr .pastdmark  
0404 ..			.dmark: db "SB1"  
0407 f1			.pastdmark: pop af  
0408			endm  
# End of macro DMARK
0408					;push af 
0408					;ld a, 'I' 
0408					;ld (debug_mark),a 
0408					;pop af 
0408					CALLMONITOR 
0408 cd d3 13			call break_point_state  
040b				endm  
# End of macro CALLMONITOR
040b				endif 
040b c9				ret 
040c			 
040c			.ininotformatted: 
040c				; bank not formatted so poke various bits to make sure 
040c			 
040c				if DEBUG_STORESE 
040c					DMARK "SB2" 
040c f5				push af  
040d 3a 21 04			ld a, (.dmark)  
0410 32 bd fb			ld (debug_mark),a  
0413 3a 22 04			ld a, (.dmark+1)  
0416 32 be fb			ld (debug_mark+1),a  
0419 3a 23 04			ld a, (.dmark+2)  
041c 32 bf fb			ld (debug_mark+2),a  
041f 18 03			jr .pastdmark  
0421 ..			.dmark: db "SB2"  
0424 f1			.pastdmark: pop af  
0425			endm  
# End of macro DMARK
0425					;push af 
0425					;ld a, 'f' 
0425					;ld (debug_mark),a 
0425					;pop af 
0425					CALLMONITOR 
0425 cd d3 13			call break_point_state  
0428				endm  
# End of macro CALLMONITOR
0428				endif 
0428			 
0428 21 e8 f9			ld hl, store_page 
042b 3e 00			ld a, 0 
042d				 
042d 77				ld (hl),a   ; reset file counter 
042e			 
042e 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0431 22 e9 f9		 	ld (store_page+1), hl	 
0434			 
0434				; set default label 
0434			 
0434 21 c9 04			ld hl, .defaultbanklabl 
0437 11 eb f9		 	ld de, store_page+3 
043a 01 0f 00			ld bc, 15 
043d ed b0			ldir 
043f			 
043f				; save default page 0 
043f			 
043f 21 00 00			ld hl, 0 
0442 11 e8 f9			ld de, store_page 
0445				if DEBUG_STORESE 
0445					DMARK "SB3" 
0445 f5				push af  
0446 3a 5a 04			ld a, (.dmark)  
0449 32 bd fb			ld (debug_mark),a  
044c 3a 5b 04			ld a, (.dmark+1)  
044f 32 be fb			ld (debug_mark+1),a  
0452 3a 5c 04			ld a, (.dmark+2)  
0455 32 bf fb			ld (debug_mark+2),a  
0458 18 03			jr .pastdmark  
045a ..			.dmark: db "SB3"  
045d f1			.pastdmark: pop af  
045e			endm  
# End of macro DMARK
045e			;		push af 
045e			;		ld a, 'F' 
045e			;		ld (debug_mark),a 
045e			;		pop af 
045e					CALLMONITOR 
045e cd d3 13			call break_point_state  
0461				endm  
# End of macro CALLMONITOR
0461				endif 
0461 cd 6e 03			call storage_write_block 
0464				if DEBUG_STORESE 
0464					DMARK "SB4" 
0464 f5				push af  
0465 3a 79 04			ld a, (.dmark)  
0468 32 bd fb			ld (debug_mark),a  
046b 3a 7a 04			ld a, (.dmark+1)  
046e 32 be fb			ld (debug_mark+1),a  
0471 3a 7b 04			ld a, (.dmark+2)  
0474 32 bf fb			ld (debug_mark+2),a  
0477 18 03			jr .pastdmark  
0479 ..			.dmark: db "SB4"  
047c f1			.pastdmark: pop af  
047d			endm  
# End of macro DMARK
047d			;		push af 
047d			;		ld a, '>' 
047d			;		ld (debug_mark),a 
047d			;		pop af 
047d					CALLMONITOR 
047d cd d3 13			call break_point_state  
0480				endm  
# End of macro CALLMONITOR
0480				endif 
0480			 
0480 00				nop 
0481 00				nop 
0482 00				nop 
0483			 
0483				; now set 0 in every page to mark as a free block 
0483			 
0483 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0485 21 40 00			ld hl, STORE_BLOCK_PHY 
0488			 
0488 3e 00		.setmark1:   	ld a,0 
048a e5					push hl 
048b c5					push bc 
048c cd e7 01				call se_writebyte 
048f 3e 0a			ld a, 10 
0491 cd 1f 0a			call aDelayInMS 
0494 23				inc hl 
0495 cd e7 01				call se_writebyte 
0498 3e 0a			ld a, 10 
049a cd 1f 0a			call aDelayInMS 
049d 2b				dec hl 
049e c1					pop bc 
049f e1					pop hl 
04a0 3e 40				ld a, STORE_BLOCK_PHY 
04a2 cd 0f 0c				call addatohl 
04a5 10 e1				djnz .setmark1 
04a7			 
04a7 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
04a9 3e 00		.setmark2:   	ld a,0 
04ab e5					push hl 
04ac c5					push bc 
04ad cd e7 01				call se_writebyte 
04b0 3e 0a			ld a, 10 
04b2 cd 1f 0a			call aDelayInMS 
04b5 23				inc hl 
04b6 cd e7 01				call se_writebyte 
04b9 3e 0a			ld a, 10 
04bb cd 1f 0a			call aDelayInMS 
04be 2b				dec hl 
04bf c1					pop bc 
04c0 e1					pop hl 
04c1 3e 40				ld a, STORE_BLOCK_PHY 
04c3 cd 0f 0c				call addatohl 
04c6 10 e1				djnz .setmark2 
04c8			 
04c8					 
04c8			 
04c8			 
04c8 c9				ret 
04c9			 
04c9			 
04c9			 
04c9			 
04c9 .. 00		.defaultbanklabl:   db "BankLabel",0 
04d3			 
04d3			 
04d3			 
04d3			; Label Bank 
04d3			; ---------- 
04d3			; 
04d3			; With current bank 
04d3			; Read block 0 
04d3			; Set label 
04d3			; Write block 0 
04d3			 
04d3			; label str pointer in hl 
04d3			 
04d3			storage_label:     
04d3			 
04d3				if DEBUG_STORESE 
04d3					DMARK "LBL" 
04d3 f5				push af  
04d4 3a e8 04			ld a, (.dmark)  
04d7 32 bd fb			ld (debug_mark),a  
04da 3a e9 04			ld a, (.dmark+1)  
04dd 32 be fb			ld (debug_mark+1),a  
04e0 3a ea 04			ld a, (.dmark+2)  
04e3 32 bf fb			ld (debug_mark+2),a  
04e6 18 03			jr .pastdmark  
04e8 ..			.dmark: db "LBL"  
04eb f1			.pastdmark: pop af  
04ec			endm  
# End of macro DMARK
04ec					CALLMONITOR 
04ec cd d3 13			call break_point_state  
04ef				endm  
# End of macro CALLMONITOR
04ef				endif 
04ef			 
04ef e5				push hl 
04f0			 
04f0 cd ba 03			call storage_get_block_0 
04f3			 
04f3				; set default label 
04f3			 
04f3 e1				pop hl 
04f4			 
04f4 11 eb f9		 	ld de, store_page+3 
04f7 01 0f 00			ld bc, 15 
04fa				if DEBUG_STORESE 
04fa					DMARK "LB3" 
04fa f5				push af  
04fb 3a 0f 05			ld a, (.dmark)  
04fe 32 bd fb			ld (debug_mark),a  
0501 3a 10 05			ld a, (.dmark+1)  
0504 32 be fb			ld (debug_mark+1),a  
0507 3a 11 05			ld a, (.dmark+2)  
050a 32 bf fb			ld (debug_mark+2),a  
050d 18 03			jr .pastdmark  
050f ..			.dmark: db "LB3"  
0512 f1			.pastdmark: pop af  
0513			endm  
# End of macro DMARK
0513					CALLMONITOR 
0513 cd d3 13			call break_point_state  
0516				endm  
# End of macro CALLMONITOR
0516				endif 
0516 ed b0			ldir 
0518				; save default page 0 
0518			 
0518 21 00 00			ld hl, 0 
051b 11 e8 f9			ld de, store_page 
051e				if DEBUG_STORESE 
051e					DMARK "LBW" 
051e f5				push af  
051f 3a 33 05			ld a, (.dmark)  
0522 32 bd fb			ld (debug_mark),a  
0525 3a 34 05			ld a, (.dmark+1)  
0528 32 be fb			ld (debug_mark+1),a  
052b 3a 35 05			ld a, (.dmark+2)  
052e 32 bf fb			ld (debug_mark+2),a  
0531 18 03			jr .pastdmark  
0533 ..			.dmark: db "LBW"  
0536 f1			.pastdmark: pop af  
0537			endm  
# End of macro DMARK
0537					CALLMONITOR 
0537 cd d3 13			call break_point_state  
053a				endm  
# End of macro CALLMONITOR
053a				endif 
053a cd 6e 03			call storage_write_block 
053d			 
053d c9				ret 
053e			 
053e			 
053e			 
053e			; Read Block 0 - Config 
053e			; --------------------- 
053e			; 
053e			; With current bank 
053e			; Call presence test 
053e			;    If not present format/init bank  
053e			; Read block 0  
053e			;  
053e			 
053e			 
053e			; Dir 
053e			; --- 
053e			; 
053e			; With current bank 
053e			; Load Block 0 Config 
053e			; Get max file id number 
053e			; For each logical block 
053e			;    Read block read byte 2 
053e			;      if first block of file 
053e			;         Display file name 
053e			;         Display type flags for file 
053e			;        
053e			 
053e			; moving to words as this requires stack control 
053e			 
053e			 
053e			; Delete File 
053e			; ----------- 
053e			; 
053e			; With current bank 
053e			; 
053e			; Load Block 0 Config 
053e			; Get max file id number 
053e			; For each logical block 
053e			;    Read block file id 
053e			;      If first block of file and dont have file id 
053e			;         if file to delete 
053e			;         Save file id 
053e			;         Null file id 
053e			;         Write this block back 
053e			;      If file id is one saved 
053e			;         Null file id 
053e			;         Write this block back 
053e			 
053e			storage_erase: 
053e			 
053e				; hl contains the file id 
053e			 
053e 5d				ld e, l 
053f 16 00			ld d, 0 
0541 21 40 00			ld hl, STORE_BLOCK_PHY 
0544					if DEBUG_FORTH_WORDS 
0544						DMARK "ERA" 
0544 f5				push af  
0545 3a 59 05			ld a, (.dmark)  
0548 32 bd fb			ld (debug_mark),a  
054b 3a 5a 05			ld a, (.dmark+1)  
054e 32 be fb			ld (debug_mark+1),a  
0551 3a 5b 05			ld a, (.dmark+2)  
0554 32 bf fb			ld (debug_mark+2),a  
0557 18 03			jr .pastdmark  
0559 ..			.dmark: db "ERA"  
055c f1			.pastdmark: pop af  
055d			endm  
# End of macro DMARK
055d						CALLMONITOR 
055d cd d3 13			call break_point_state  
0560				endm  
# End of macro CALLMONITOR
0560					endif 
0560 cd 1f 06			call storage_findnextid 
0563			 
0563 e5				push hl 
0564			 
0564				; TODO check file not found 
0564			 
0564 11 e8 f9			ld de, store_page 
0567 cd 09 03			call storage_read_block 
056a			 
056a					if DEBUG_FORTH_WORDS 
056a						DMARK "ER1" 
056a f5				push af  
056b 3a 7f 05			ld a, (.dmark)  
056e 32 bd fb			ld (debug_mark),a  
0571 3a 80 05			ld a, (.dmark+1)  
0574 32 be fb			ld (debug_mark+1),a  
0577 3a 81 05			ld a, (.dmark+2)  
057a 32 bf fb			ld (debug_mark+2),a  
057d 18 03			jr .pastdmark  
057f ..			.dmark: db "ER1"  
0582 f1			.pastdmark: pop af  
0583			endm  
# End of macro DMARK
0583						CALLMONITOR 
0583 cd d3 13			call break_point_state  
0586				endm  
# End of macro CALLMONITOR
0586					endif 
0586 3a e8 f9			ld a, (store_page)	; get file id 
0589 32 e1 f9			ld (store_tmpid), a 
058c			 
058c 3a ea f9			ld a, (store_page+2)    ; get count of extends 
058f 32 e0 f9			ld (store_tmpext), a 
0592			 
0592				; wipe file header 
0592			 
0592 e1				pop hl 
0593 3e 00			ld a, 0 
0595 32 e8 f9			ld (store_page), a 
0598 32 e9 f9			ld (store_page+1),a 
059b 11 e8 f9			ld de, store_page 
059e					if DEBUG_FORTH_WORDS 
059e						DMARK "ER2" 
059e f5				push af  
059f 3a b3 05			ld a, (.dmark)  
05a2 32 bd fb			ld (debug_mark),a  
05a5 3a b4 05			ld a, (.dmark+1)  
05a8 32 be fb			ld (debug_mark+1),a  
05ab 3a b5 05			ld a, (.dmark+2)  
05ae 32 bf fb			ld (debug_mark+2),a  
05b1 18 03			jr .pastdmark  
05b3 ..			.dmark: db "ER2"  
05b6 f1			.pastdmark: pop af  
05b7			endm  
# End of macro DMARK
05b7						CALLMONITOR 
05b7 cd d3 13			call break_point_state  
05ba				endm  
# End of macro CALLMONITOR
05ba					endif 
05ba cd 6e 03			call storage_write_block 
05bd			 
05bd			 
05bd				; wipe file extents 
05bd			 
05bd 3a e0 f9			ld a, (store_tmpext) 
05c0 47				ld b, a 
05c1			 
05c1			.eraext:	  
05c1 c5				push bc 
05c2			 
05c2 21 40 00			ld hl, STORE_BLOCK_PHY 
05c5 3a e1 f9			ld a,(store_tmpid) 
05c8 5f				ld e, a 
05c9 50				ld d, b	 
05ca					if DEBUG_FORTH_WORDS 
05ca						DMARK "ER3" 
05ca f5				push af  
05cb 3a df 05			ld a, (.dmark)  
05ce 32 bd fb			ld (debug_mark),a  
05d1 3a e0 05			ld a, (.dmark+1)  
05d4 32 be fb			ld (debug_mark+1),a  
05d7 3a e1 05			ld a, (.dmark+2)  
05da 32 bf fb			ld (debug_mark+2),a  
05dd 18 03			jr .pastdmark  
05df ..			.dmark: db "ER3"  
05e2 f1			.pastdmark: pop af  
05e3			endm  
# End of macro DMARK
05e3						CALLMONITOR 
05e3 cd d3 13			call break_point_state  
05e6				endm  
# End of macro CALLMONITOR
05e6					endif 
05e6 cd 1f 06			call storage_findnextid 
05e9			 
05e9 e5				push hl 
05ea 11 e8 f9			ld de, store_page 
05ed cd 09 03			call storage_read_block 
05f0			 
05f0				; free block	 
05f0			 
05f0 3e 00			ld a, 0 
05f2 32 e8 f9			ld (store_page), a 
05f5 32 e9 f9			ld (store_page+1),a 
05f8 11 e8 f9			ld de, store_page 
05fb e1				pop hl 
05fc					if DEBUG_FORTH_WORDS 
05fc						DMARK "ER4" 
05fc f5				push af  
05fd 3a 11 06			ld a, (.dmark)  
0600 32 bd fb			ld (debug_mark),a  
0603 3a 12 06			ld a, (.dmark+1)  
0606 32 be fb			ld (debug_mark+1),a  
0609 3a 13 06			ld a, (.dmark+2)  
060c 32 bf fb			ld (debug_mark+2),a  
060f 18 03			jr .pastdmark  
0611 ..			.dmark: db "ER4"  
0614 f1			.pastdmark: pop af  
0615			endm  
# End of macro DMARK
0615						CALLMONITOR 
0615 cd d3 13			call break_point_state  
0618				endm  
# End of macro CALLMONITOR
0618					endif 
0618 cd 6e 03			call storage_write_block 
061b			 
061b c1				pop bc 
061c 10 a3			djnz .eraext 
061e			 
061e c9				ret 
061f			 
061f			 
061f			; Find Free Block 
061f			; --------------- 
061f			; 
061f			; With current bank 
061f			;  
061f			; From given starting logical block 
061f			;    Read block  
061f			;    If no file id 
061f			;         Return block id 
061f			 
061f			 
061f			; hl starting page number 
061f			; hl contains free page number or zero if no pages free 
061f			; e contains the file id to locate 
061f			; d contains the block number 
061f			 
061f			; TODO change to find file id and use zero for free block 
061f			 
061f			storage_findnextid: 
061f			 
061f				; now locate first 0 page to mark as a free block 
061f			 
061f 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0621			;	ld hl, STORE_BLOCK_PHY 
0621			 
0621					if DEBUG_FORTH_WORDS 
0621					DMARK "FNI" 
0621 f5				push af  
0622 3a 36 06			ld a, (.dmark)  
0625 32 bd fb			ld (debug_mark),a  
0628 3a 37 06			ld a, (.dmark+1)  
062b 32 be fb			ld (debug_mark+1),a  
062e 3a 38 06			ld a, (.dmark+2)  
0631 32 bf fb			ld (debug_mark+2),a  
0634 18 03			jr .pastdmark  
0636 ..			.dmark: db "FNI"  
0639 f1			.pastdmark: pop af  
063a			endm  
# End of macro DMARK
063a						CALLMONITOR 
063a cd d3 13			call break_point_state  
063d				endm  
# End of macro CALLMONITOR
063d					endif 
063d			.ff1:   	 
063d e5					push hl 
063e c5					push bc 
063f d5					push de 
0640 cd 89 02				call se_readbyte 
0643 5f					ld e,a 
0644 23					inc hl 
0645 cd 89 02				call se_readbyte 
0648 57					ld d, a 
0649 e1					pop hl 
064a e5					push hl 
064b cd 2d 0c				call cmp16 
064e 28 49				jr z, .fffound 
0650			 
0650 d1					pop de 
0651 c1					pop bc 
0652 e1					pop hl 
0653			 
0653					; is found? 
0653					;cp e 
0653					;ret z 
0653			 
0653 3e 40				ld a, STORE_BLOCK_PHY 
0655 cd 0f 0c				call addatohl 
0658 10 e3				djnz .ff1 
065a			 
065a 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
065c			.ff2:   	 
065c			 
065c e5					push hl 
065d c5					push bc 
065e d5					push de 
065f cd 89 02				call se_readbyte 
0662 5f					ld e,a 
0663 23					inc hl 
0664 cd 89 02				call se_readbyte 
0667 57					ld d, a 
0668			 
0668 e1					pop hl 
0669 e5					push hl 
066a cd 2d 0c				call cmp16 
066d 28 2a				jr z, .fffound 
066f			 
066f d1					pop de 
0670 c1					pop bc 
0671 e1					pop hl 
0672					; is found? 
0672					;cp e 
0672					;ret z 
0672			 
0672 3e 40				ld a, STORE_BLOCK_PHY 
0674 cd 0f 0c				call addatohl 
0677 10 e3				djnz .ff2 
0679			 
0679			 
0679					if DEBUG_FORTH_WORDS 
0679					DMARK "FN-" 
0679 f5				push af  
067a 3a 8e 06			ld a, (.dmark)  
067d 32 bd fb			ld (debug_mark),a  
0680 3a 8f 06			ld a, (.dmark+1)  
0683 32 be fb			ld (debug_mark+1),a  
0686 3a 90 06			ld a, (.dmark+2)  
0689 32 bf fb			ld (debug_mark+2),a  
068c 18 03			jr .pastdmark  
068e ..			.dmark: db "FN-"  
0691 f1			.pastdmark: pop af  
0692			endm  
# End of macro DMARK
0692					;	push af 
0692					;	ld a, 'n' 
0692					;	ld (debug_mark),a 
0692					;	pop af 
0692						CALLMONITOR 
0692 cd d3 13			call break_point_state  
0695				endm  
# End of macro CALLMONITOR
0695					endif 
0695				; no free marks! 
0695 21 00 00				ld hl, 0 
0698 c9				ret 
0699			.fffound: 
0699				 
0699			 
0699 d1					pop de 
069a c1					pop bc 
069b e1					pop hl 
069c					if DEBUG_FORTH_WORDS 
069c					DMARK "FNF" 
069c f5				push af  
069d 3a b1 06			ld a, (.dmark)  
06a0 32 bd fb			ld (debug_mark),a  
06a3 3a b2 06			ld a, (.dmark+1)  
06a6 32 be fb			ld (debug_mark+1),a  
06a9 3a b3 06			ld a, (.dmark+2)  
06ac 32 bf fb			ld (debug_mark+2),a  
06af 18 03			jr .pastdmark  
06b1 ..			.dmark: db "FNF"  
06b4 f1			.pastdmark: pop af  
06b5			endm  
# End of macro DMARK
06b5					;	push af 
06b5					;	ld a, 'n' 
06b5					;	ld (debug_mark),a 
06b5					;	pop af 
06b5						CALLMONITOR 
06b5 cd d3 13			call break_point_state  
06b8				endm  
# End of macro CALLMONITOR
06b8					endif 
06b8 c9				ret 
06b9			 
06b9			 
06b9			 
06b9			; Free Space 
06b9			; ---------- 
06b9			; 
06b9			; With current bank 
06b9			; 
06b9			; Set block count to zero 
06b9			; Starting with first logical block 
06b9			;      Find free block  
06b9			;      If block id given, increment block count 
06b9			; 
06b9			;  
06b9			 
06b9			 
06b9			; hl contains count of free blocks 
06b9			 
06b9			storage_freeblocks: 
06b9			 
06b9				; now locate first 0 page to mark as a free block 
06b9			 
06b9 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
06bb 21 40 00			ld hl, STORE_BLOCK_PHY 
06be 11 00 00			ld de, 0 
06c1			 
06c1			.fb1:   	 
06c1 e5					push hl 
06c2 c5					push bc 
06c3 d5					push de 
06c4 cd 89 02				call se_readbyte 
06c7 d1					pop de 
06c8 c1					pop bc 
06c9 e1					pop hl 
06ca			 
06ca					; is free? 
06ca fe 00				cp 0 
06cc 20 01				jr nz, .ff1cont 
06ce 13					inc de 
06cf			 
06cf			.ff1cont: 
06cf			 
06cf			 
06cf 3e 40				ld a, STORE_BLOCK_PHY 
06d1 cd 0f 0c				call addatohl 
06d4 10 eb				djnz .fb1 
06d6			 
06d6 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
06d8			.fb2:   	 
06d8 e5					push hl 
06d9 c5					push bc 
06da d5					push de 
06db cd 89 02				call se_readbyte 
06de d1					pop de 
06df c1					pop bc 
06e0 e1					pop hl 
06e1			 
06e1					; is free? 
06e1 fe 00				cp 0 
06e3 20 01				jr nz, .ff2cont 
06e5 13					inc de 
06e6			 
06e6			.ff2cont: 
06e6			 
06e6 3e 40				ld a, STORE_BLOCK_PHY 
06e8 cd 0f 0c				call addatohl 
06eb 10 eb				djnz .fb2 
06ed			 
06ed eb				ex de, hl 
06ee c9				ret 
06ef			 
06ef			; Get File ID 
06ef			; ----------- 
06ef			; 
06ef			; With current bank 
06ef			;  
06ef			; Load Block 0 Config 
06ef			; Get max file id number 
06ef			; For each logical block 
06ef			;    Read block file id 
06ef			;      If first block of file and dont have file id 
06ef			;         if file get id and exit 
06ef			 
06ef			 
06ef			 
06ef			 
06ef			; Create File 
06ef			; ----------- 
06ef			; 
06ef			; With current bank  
06ef			; Load Block 0 Config 
06ef			; Get max file id number 
06ef			; Increment file id number 
06ef			; Save Config 
06ef			; Find free block 
06ef			; Set buffer with file name and file id 
06ef			; Write buffer to free block  
06ef			 
06ef			 
06ef			; hl point to file name 
06ef			; hl returns file id 
06ef			 
06ef			; file format: 
06ef			; byte 0 - file id 
06ef			; byte 1 - extent number 
06ef			; byte 2-> data 
06ef			 
06ef			; format for extent number 0: 
06ef			; 
06ef			; byte 0 - file id 
06ef			; byte 1 - extent 0 
06ef			; byte 2 - extent count 
06ef			; byte 3 -> file name and meta data 
06ef			 
06ef			 
06ef			storage_create: 
06ef				if DEBUG_STORESE 
06ef					DMARK "SCR" 
06ef f5				push af  
06f0 3a 04 07			ld a, (.dmark)  
06f3 32 bd fb			ld (debug_mark),a  
06f6 3a 05 07			ld a, (.dmark+1)  
06f9 32 be fb			ld (debug_mark+1),a  
06fc 3a 06 07			ld a, (.dmark+2)  
06ff 32 bf fb			ld (debug_mark+2),a  
0702 18 03			jr .pastdmark  
0704 ..			.dmark: db "SCR"  
0707 f1			.pastdmark: pop af  
0708			endm  
# End of macro DMARK
0708					CALLMONITOR 
0708 cd d3 13			call break_point_state  
070b				endm  
# End of macro CALLMONITOR
070b				endif 
070b			 
070b e5				push hl		; save file name pointer 
070c			 
070c cd ba 03			call storage_get_block_0 
070f			 
070f 3a e8 f9			ld a,(store_page)	; get current file id 
0712 3c				inc a 
0713 32 e8 f9			ld (store_page),a 
0716				 
0716 32 e1 f9			ld (store_tmpid),a			; save id 
0719			 
0719 21 00 00			ld hl, 0 
071c 11 e8 f9			ld de, store_page 
071f				if DEBUG_STORESE 
071f					DMARK "SCw" 
071f f5				push af  
0720 3a 34 07			ld a, (.dmark)  
0723 32 bd fb			ld (debug_mark),a  
0726 3a 35 07			ld a, (.dmark+1)  
0729 32 be fb			ld (debug_mark+1),a  
072c 3a 36 07			ld a, (.dmark+2)  
072f 32 bf fb			ld (debug_mark+2),a  
0732 18 03			jr .pastdmark  
0734 ..			.dmark: db "SCw"  
0737 f1			.pastdmark: pop af  
0738			endm  
# End of macro DMARK
0738					CALLMONITOR 
0738 cd d3 13			call break_point_state  
073b				endm  
# End of macro CALLMONITOR
073b				endif 
073b cd 6e 03			call storage_write_block	 ; save update 
073e			 
073e				if DEBUG_STORESE 
073e 11 e8 f9				ld de, store_page 
0741					DMARK "SCC" 
0741 f5				push af  
0742 3a 56 07			ld a, (.dmark)  
0745 32 bd fb			ld (debug_mark),a  
0748 3a 57 07			ld a, (.dmark+1)  
074b 32 be fb			ld (debug_mark+1),a  
074e 3a 58 07			ld a, (.dmark+2)  
0751 32 bf fb			ld (debug_mark+2),a  
0754 18 03			jr .pastdmark  
0756 ..			.dmark: db "SCC"  
0759 f1			.pastdmark: pop af  
075a			endm  
# End of macro DMARK
075a					CALLMONITOR 
075a cd d3 13			call break_point_state  
075d				endm  
# End of macro CALLMONITOR
075d				endif 
075d				;  
075d				 
075d 21 40 00			ld hl, STORE_BLOCK_PHY 
0760 11 00 00			ld de, 0 
0763 cd 1f 06			call storage_findnextid 
0766			 
0766 22 e6 f9			ld (store_tmppageid), hl    ; save page to use  
0769			 
0769				; TODO detect 0 = no spare blocks 
0769			 
0769				; hl now contains the free page to use for the file header page 
0769			 
0769				if DEBUG_STORESE 
0769				DMARK "SCF" 
0769 f5				push af  
076a 3a 7e 07			ld a, (.dmark)  
076d 32 bd fb			ld (debug_mark),a  
0770 3a 7f 07			ld a, (.dmark+1)  
0773 32 be fb			ld (debug_mark+1),a  
0776 3a 80 07			ld a, (.dmark+2)  
0779 32 bf fb			ld (debug_mark+2),a  
077c 18 03			jr .pastdmark  
077e ..			.dmark: db "SCF"  
0781 f1			.pastdmark: pop af  
0782			endm  
# End of macro DMARK
0782					CALLMONITOR 
0782 cd d3 13			call break_point_state  
0785				endm  
# End of macro CALLMONITOR
0785				endif 
0785			 
0785 22 e6 f9			ld (store_tmppageid), hl 
0788				 
0788 3a e1 f9			ld a,(store_tmpid)    ; get file id 
078b			;	ld a, (store_filecache)			; save to cache 
078b			 
078b 32 e8 f9			ld (store_page),a    ; set page id 
078e 3e 00			ld a, 0			 ; extent 0 is file header 
0790 32 e9 f9			ld (store_page+1), a   ; set file extent 
0793			 
0793 32 ea f9			ld (store_page+2), a   ; extent count for the file 
0796			 
0796			;	inc hl 		; init block 0 of file 
0796			;	inc hl   		; skip file and extent id 
0796			 ;       ld a, 0 
0796			;	ld (hl),a 
0796			;	ld a, (store_filecache+1)  	; save to cache 
0796			 
0796			;	inc hl    ; file name 
0796				 
0796				 
0796 11 eb f9			ld de, store_page+3    ; get buffer for term string to use as file name 
0799				if DEBUG_STORESE 
0799					DMARK "SCc" 
0799 f5				push af  
079a 3a ae 07			ld a, (.dmark)  
079d 32 bd fb			ld (debug_mark),a  
07a0 3a af 07			ld a, (.dmark+1)  
07a3 32 be fb			ld (debug_mark+1),a  
07a6 3a b0 07			ld a, (.dmark+2)  
07a9 32 bf fb			ld (debug_mark+2),a  
07ac 18 03			jr .pastdmark  
07ae ..			.dmark: db "SCc"  
07b1 f1			.pastdmark: pop af  
07b2			endm  
# End of macro DMARK
07b2					CALLMONITOR 
07b2 cd d3 13			call break_point_state  
07b5				endm  
# End of macro CALLMONITOR
07b5				endif 
07b5 e1				pop hl    ; get zero term string 
07b6 e5				push hl 
07b7 3e 00			ld a, 0 
07b9 cd 78 10			call strlent 
07bc 23				inc hl   ; cover zero term 
07bd 06 00			ld b,0 
07bf 4d				ld c,l 
07c0 e1				pop hl 
07c1				;ex de, hl 
07c1				if DEBUG_STORESE 
07c1					DMARK "SCa" 
07c1 f5				push af  
07c2 3a d6 07			ld a, (.dmark)  
07c5 32 bd fb			ld (debug_mark),a  
07c8 3a d7 07			ld a, (.dmark+1)  
07cb 32 be fb			ld (debug_mark+1),a  
07ce 3a d8 07			ld a, (.dmark+2)  
07d1 32 bf fb			ld (debug_mark+2),a  
07d4 18 03			jr .pastdmark  
07d6 ..			.dmark: db "SCa"  
07d9 f1			.pastdmark: pop af  
07da			endm  
# End of macro DMARK
07da					;push af 
07da					;ld a, 'a' 
07da					;ld (debug_mark),a 
07da					;pop af 
07da					CALLMONITOR 
07da cd d3 13			call break_point_state  
07dd				endm  
# End of macro CALLMONITOR
07dd				endif 
07dd ed b0			ldir    ; copy zero term string 
07df				if DEBUG_STORESE 
07df					DMARK "SCA" 
07df f5				push af  
07e0 3a f4 07			ld a, (.dmark)  
07e3 32 bd fb			ld (debug_mark),a  
07e6 3a f5 07			ld a, (.dmark+1)  
07e9 32 be fb			ld (debug_mark+1),a  
07ec 3a f6 07			ld a, (.dmark+2)  
07ef 32 bf fb			ld (debug_mark+2),a  
07f2 18 03			jr .pastdmark  
07f4 ..			.dmark: db "SCA"  
07f7 f1			.pastdmark: pop af  
07f8			endm  
# End of macro DMARK
07f8					CALLMONITOR 
07f8 cd d3 13			call break_point_state  
07fb				endm  
# End of macro CALLMONITOR
07fb				endif 
07fb			 
07fb				; write file header page 
07fb			 
07fb 2a e6 f9			ld hl,(store_tmppageid) 
07fe 11 e8 f9			ld de, store_page 
0801				if DEBUG_STORESE 
0801					DMARK "SCb" 
0801 f5				push af  
0802 3a 16 08			ld a, (.dmark)  
0805 32 bd fb			ld (debug_mark),a  
0808 3a 17 08			ld a, (.dmark+1)  
080b 32 be fb			ld (debug_mark+1),a  
080e 3a 18 08			ld a, (.dmark+2)  
0811 32 bf fb			ld (debug_mark+2),a  
0814 18 03			jr .pastdmark  
0816 ..			.dmark: db "SCb"  
0819 f1			.pastdmark: pop af  
081a			endm  
# End of macro DMARK
081a					;push af 
081a					;ld a, 'b' 
081a					;ld (debug_mark),a 
081a					;pop af 
081a					CALLMONITOR 
081a cd d3 13			call break_point_state  
081d				endm  
# End of macro CALLMONITOR
081d				endif 
081d cd 6e 03			call storage_write_block 
0820			 
0820 3a e1 f9			ld a, (store_tmpid) 
0823 6f				ld l, a 
0824 26 00			ld h,0 
0826				if DEBUG_STORESE 
0826					DMARK "SCz" 
0826 f5				push af  
0827 3a 3b 08			ld a, (.dmark)  
082a 32 bd fb			ld (debug_mark),a  
082d 3a 3c 08			ld a, (.dmark+1)  
0830 32 be fb			ld (debug_mark+1),a  
0833 3a 3d 08			ld a, (.dmark+2)  
0836 32 bf fb			ld (debug_mark+2),a  
0839 18 03			jr .pastdmark  
083b ..			.dmark: db "SCz"  
083e f1			.pastdmark: pop af  
083f			endm  
# End of macro DMARK
083f					CALLMONITOR 
083f cd d3 13			call break_point_state  
0842				endm  
# End of macro CALLMONITOR
0842				endif 
0842 c9				ret 
0843				 
0843			 
0843			 
0843			; 
0843			; Read File 
0843			; 
0843			; h - file id to locate 
0843			; l - extent to locate 
0843			; de - pointer to string to read into 
0843			; 
0843			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
0843			storage_read: 
0843 d5				push de 
0844			 
0844			; TODO BUG the above push is it popped before the RET Z? 
0844			 
0844			; TODO how to handle multiple part blocks 
0844			 
0844				; locate file extent to read 
0844			 
0844 5c				ld e, h 
0845 55				ld d, l 
0846 21 40 00			ld hl, STORE_BLOCK_PHY 
0849				if DEBUG_STORESE 
0849					DMARK "SRE" 
0849 f5				push af  
084a 3a 5e 08			ld a, (.dmark)  
084d 32 bd fb			ld (debug_mark),a  
0850 3a 5f 08			ld a, (.dmark+1)  
0853 32 be fb			ld (debug_mark+1),a  
0856 3a 60 08			ld a, (.dmark+2)  
0859 32 bf fb			ld (debug_mark+2),a  
085c 18 03			jr .pastdmark  
085e ..			.dmark: db "SRE"  
0861 f1			.pastdmark: pop af  
0862			endm  
# End of macro DMARK
0862					CALLMONITOR 
0862 cd d3 13			call break_point_state  
0865				endm  
# End of macro CALLMONITOR
0865				endif 
0865 cd 1f 06			call storage_findnextid 
0868			 
0868				if DEBUG_STORESE 
0868					DMARK "SRf" 
0868 f5				push af  
0869 3a 7d 08			ld a, (.dmark)  
086c 32 bd fb			ld (debug_mark),a  
086f 3a 7e 08			ld a, (.dmark+1)  
0872 32 be fb			ld (debug_mark+1),a  
0875 3a 7f 08			ld a, (.dmark+2)  
0878 32 bf fb			ld (debug_mark+2),a  
087b 18 03			jr .pastdmark  
087d ..			.dmark: db "SRf"  
0880 f1			.pastdmark: pop af  
0881			endm  
# End of macro DMARK
0881					CALLMONITOR 
0881 cd d3 13			call break_point_state  
0884				endm  
# End of macro CALLMONITOR
0884				endif 
0884 cd 38 0c			call ishlzero 
0887			;	ld a, l 
0887			;	add h 
0887			;	cp 0 
0887 c8				ret z			; block not found so EOF 
0888			 
0888				; hl contains page number to load 
0888 d1				pop de   ; get storage 
0889 d5				push de 
088a				if DEBUG_STORESE 
088a					DMARK "SRg" 
088a f5				push af  
088b 3a 9f 08			ld a, (.dmark)  
088e 32 bd fb			ld (debug_mark),a  
0891 3a a0 08			ld a, (.dmark+1)  
0894 32 be fb			ld (debug_mark+1),a  
0897 3a a1 08			ld a, (.dmark+2)  
089a 32 bf fb			ld (debug_mark+2),a  
089d 18 03			jr .pastdmark  
089f ..			.dmark: db "SRg"  
08a2 f1			.pastdmark: pop af  
08a3			endm  
# End of macro DMARK
08a3					CALLMONITOR 
08a3 cd d3 13			call break_point_state  
08a6				endm  
# End of macro CALLMONITOR
08a6				endif 
08a6 cd 09 03			call storage_read_block 
08a9			 
08a9			 
08a9			; TODO if block has no zeros then need to read next block  
08a9			 
08a9			 
08a9					 
08a9 e1				pop hl 		 ; return start of data to show as not EOF 
08aa 23				inc hl   ; past file id 
08ab 23				inc hl   ; past ext 
08ac				if DEBUG_STORESE 
08ac					DMARK "SRe" 
08ac f5				push af  
08ad 3a c1 08			ld a, (.dmark)  
08b0 32 bd fb			ld (debug_mark),a  
08b3 3a c2 08			ld a, (.dmark+1)  
08b6 32 be fb			ld (debug_mark+1),a  
08b9 3a c3 08			ld a, (.dmark+2)  
08bc 32 bf fb			ld (debug_mark+2),a  
08bf 18 03			jr .pastdmark  
08c1 ..			.dmark: db "SRe"  
08c4 f1			.pastdmark: pop af  
08c5			endm  
# End of macro DMARK
08c5					CALLMONITOR 
08c5 cd d3 13			call break_point_state  
08c8				endm  
# End of macro CALLMONITOR
08c8				endif 
08c8 c9					ret 
08c9			 
08c9			 
08c9			 
08c9			; 
08c9			; Append File 
08c9			; 
08c9			; hl - file id to locate 
08c9			; de - pointer to (multi block) string to write 
08c9			 
08c9			 
08c9			storage_append: 
08c9				; hl -  file id to append to 
08c9				; de - string to append 
08c9			 
08c9 d5				push de 
08ca				 
08ca				if DEBUG_STORESE 
08ca					DMARK "AP1" 
08ca f5				push af  
08cb 3a df 08			ld a, (.dmark)  
08ce 32 bd fb			ld (debug_mark),a  
08d1 3a e0 08			ld a, (.dmark+1)  
08d4 32 be fb			ld (debug_mark+1),a  
08d7 3a e1 08			ld a, (.dmark+2)  
08da 32 bf fb			ld (debug_mark+2),a  
08dd 18 03			jr .pastdmark  
08df ..			.dmark: db "AP1"  
08e2 f1			.pastdmark: pop af  
08e3			endm  
# End of macro DMARK
08e3					CALLMONITOR 
08e3 cd d3 13			call break_point_state  
08e6				endm  
# End of macro CALLMONITOR
08e6				endif 
08e6			 
08e6 7d				ld a, l 
08e7 32 e1 f9			ld (store_tmpid), a 
08ea			 
08ea				; get file header  
08ea			 
08ea 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
08ec 3a e1 f9			ld a, (store_tmpid) 
08ef 5f				ld e, a 
08f0			 
08f0 21 40 00				ld hl, STORE_BLOCK_PHY 
08f3 cd 1f 06				call storage_findnextid 
08f6			 
08f6 22 e6 f9			ld (store_tmppageid), hl 
08f9			 
08f9				; TODO handle file id not found 
08f9			 
08f9				if DEBUG_STORESE 
08f9					DMARK "AP2" 
08f9 f5				push af  
08fa 3a 0e 09			ld a, (.dmark)  
08fd 32 bd fb			ld (debug_mark),a  
0900 3a 0f 09			ld a, (.dmark+1)  
0903 32 be fb			ld (debug_mark+1),a  
0906 3a 10 09			ld a, (.dmark+2)  
0909 32 bf fb			ld (debug_mark+2),a  
090c 18 03			jr .pastdmark  
090e ..			.dmark: db "AP2"  
0911 f1			.pastdmark: pop af  
0912			endm  
# End of macro DMARK
0912					CALLMONITOR 
0912 cd d3 13			call break_point_state  
0915				endm  
# End of macro CALLMONITOR
0915				endif 
0915			 
0915				; update file extent count 
0915			 
0915 11 e8 f9			ld de, store_page 
0918			 
0918 cd 09 03			call storage_read_block 
091b			 
091b				if DEBUG_STORESE 
091b					DMARK "AP3" 
091b f5				push af  
091c 3a 30 09			ld a, (.dmark)  
091f 32 bd fb			ld (debug_mark),a  
0922 3a 31 09			ld a, (.dmark+1)  
0925 32 be fb			ld (debug_mark+1),a  
0928 3a 32 09			ld a, (.dmark+2)  
092b 32 bf fb			ld (debug_mark+2),a  
092e 18 03			jr .pastdmark  
0930 ..			.dmark: db "AP3"  
0933 f1			.pastdmark: pop af  
0934			endm  
# End of macro DMARK
0934					CALLMONITOR 
0934 cd d3 13			call break_point_state  
0937				endm  
# End of macro CALLMONITOR
0937				endif 
0937			;	ld (store_tmppageid), hl 
0937			 
0937 3a ea f9			ld a, (store_page+2) 
093a 3c				inc a 
093b 32 ea f9			ld (store_page+2), a 
093e 32 e0 f9			ld (store_tmpext), a 
0941				 
0941				if DEBUG_STORESE 
0941					DMARK "AP3" 
0941 f5				push af  
0942 3a 56 09			ld a, (.dmark)  
0945 32 bd fb			ld (debug_mark),a  
0948 3a 57 09			ld a, (.dmark+1)  
094b 32 be fb			ld (debug_mark+1),a  
094e 3a 58 09			ld a, (.dmark+2)  
0951 32 bf fb			ld (debug_mark+2),a  
0954 18 03			jr .pastdmark  
0956 ..			.dmark: db "AP3"  
0959 f1			.pastdmark: pop af  
095a			endm  
# End of macro DMARK
095a					CALLMONITOR 
095a cd d3 13			call break_point_state  
095d				endm  
# End of macro CALLMONITOR
095d				endif 
095d 2a e6 f9			ld hl, (store_tmppageid) 
0960 11 e8 f9			ld de, store_page 
0963 cd 6e 03			call storage_write_block 
0966			 
0966				; find free block 
0966			 
0966 11 00 00			ld de, 0			 ; file extent to locate 
0969			 
0969 21 40 00				ld hl, STORE_BLOCK_PHY 
096c cd 1f 06				call storage_findnextid 
096f			 
096f					; TODO handle no space left 
096f					 
096f 22 e6 f9				ld (store_tmppageid), hl 
0972			 
0972				if DEBUG_STORESE 
0972					DMARK "AP4" 
0972 f5				push af  
0973 3a 87 09			ld a, (.dmark)  
0976 32 bd fb			ld (debug_mark),a  
0979 3a 88 09			ld a, (.dmark+1)  
097c 32 be fb			ld (debug_mark+1),a  
097f 3a 89 09			ld a, (.dmark+2)  
0982 32 bf fb			ld (debug_mark+2),a  
0985 18 03			jr .pastdmark  
0987 ..			.dmark: db "AP4"  
098a f1			.pastdmark: pop af  
098b			endm  
# End of macro DMARK
098b					CALLMONITOR 
098b cd d3 13			call break_point_state  
098e				endm  
# End of macro CALLMONITOR
098e				endif 
098e					; init the buffer with zeros so we can id if the buffer is full or not 
098e			 
098e e5					push hl 
098f c5					push bc 
0990			 
0990 21 e8 f9				ld hl, store_page 
0993 06 40				ld b, STORE_BLOCK_PHY 
0995 3e 00				ld a, 0 
0997 77			.zeroblock:	ld (hl), a 
0998 23					inc hl 
0999 10 fc				djnz .zeroblock 
099b			 
099b c1					pop bc 
099c e1					pop hl 
099d			 
099d					; construct block 
099d			 
099d 3a e1 f9				ld a, (store_tmpid) 
09a0 32 e8 f9				ld (store_page), a   ; file id 
09a3 3a e0 f9				ld a, (store_tmpext)   ; extent for this block 
09a6 32 e9 f9				ld (store_page+1), a 
09a9			 
09a9 e1					pop hl    ; get string to write 
09aa 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
09ac 11 ea f9				ld de, store_page+2 
09af			 
09af				if DEBUG_STORESE 
09af					DMARK "AP5" 
09af f5				push af  
09b0 3a c4 09			ld a, (.dmark)  
09b3 32 bd fb			ld (debug_mark),a  
09b6 3a c5 09			ld a, (.dmark+1)  
09b9 32 be fb			ld (debug_mark+1),a  
09bc 3a c6 09			ld a, (.dmark+2)  
09bf 32 bf fb			ld (debug_mark+2),a  
09c2 18 03			jr .pastdmark  
09c4 ..			.dmark: db "AP5"  
09c7 f1			.pastdmark: pop af  
09c8			endm  
# End of macro DMARK
09c8					CALLMONITOR 
09c8 cd d3 13			call break_point_state  
09cb				endm  
# End of macro CALLMONITOR
09cb				endif 
09cb			 
09cb			 
09cb			 
09cb					; fill buffer with data until end of string or full block 
09cb			 
09cb 7e			.appd:		ld a, (hl) 
09cc 12					ld (de), a 
09cd fe 00				cp 0 
09cf 28 04				jr z, .appdone 
09d1 23					inc hl 
09d2 13					inc de 
09d3 10 f6				djnz .appd 
09d5			 
09d5 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
09d6 f5					push af   		; save last byte dumped 
09d7			 
09d7			 
09d7 2a e6 f9			ld hl, (store_tmppageid) 
09da 11 e8 f9			ld de, store_page 
09dd				if DEBUG_STORESE 
09dd					DMARK "AP6" 
09dd f5				push af  
09de 3a f2 09			ld a, (.dmark)  
09e1 32 bd fb			ld (debug_mark),a  
09e4 3a f3 09			ld a, (.dmark+1)  
09e7 32 be fb			ld (debug_mark+1),a  
09ea 3a f4 09			ld a, (.dmark+2)  
09ed 32 bf fb			ld (debug_mark+2),a  
09f0 18 03			jr .pastdmark  
09f2 ..			.dmark: db "AP6"  
09f5 f1			.pastdmark: pop af  
09f6			endm  
# End of macro DMARK
09f6					CALLMONITOR 
09f6 cd d3 13			call break_point_state  
09f9				endm  
# End of macro CALLMONITOR
09f9				endif 
09f9 cd 6e 03				call storage_write_block 
09fc			 
09fc			 
09fc				; was that a full block of data written? 
09fc				; any more to write out? 
09fc			 
09fc				; if yes then set vars and jump to start of function again 
09fc			 
09fc f1					pop af 
09fd d1					pop de 
09fe			 
09fe fe 00				cp 0		 ; no, string was fully written 
0a00 c8					ret z 
0a01			 
0a01					; setup vars for next cycle 
0a01			 
0a01 3a e1 f9				ld a, (store_tmpid) 
0a04 6f					ld l, a 
0a05 26 00				ld h, 0 
0a07			 
0a07 c3 c9 08			 	jp storage_append	 ; yes, need to write out some more 
0a0a			 
0a0a			 
0a0a			 
0a0a			 
0a0a			 
0a0a			 
0a0a			 
0a0a			if DEBUG_STORECF 
0a0a			storageput:	 
0a0a					ret 
0a0a			storageread: 
0a0a					ld hl, store_page 
0a0a					ld b, 200 
0a0a					ld a,0 
0a0a			.src:		ld (hl),a 
0a0a					inc hl 
0a0a					djnz .src 
0a0a					 
0a0a			 
0a0a					ld de, 0 
0a0a					ld bc, 1 
0a0a					ld hl, store_page 
0a0a					call cfRead 
0a0a			 
0a0a				call cfGetError 
0a0a				ld hl,scratch 
0a0a				call hexout 
0a0a				ld hl, scratch+2 
0a0a				ld a, 0 
0a0a				ld (hl),a 
0a0a				ld de, scratch 
0a0a				ld a,display_row_1 
0a0a				call str_at_display 
0a0a				call update_display 
0a0a			 
0a0a					ld hl, store_page 
0a0a					ld (os_cur_ptr),hl 
0a0a			 
0a0a					ret 
0a0a			endif 
0a0a			 
0a0a			 
0a0a			; Clear out the main buffer store (used to remove junk before writing a new block) 
0a0a			 
0a0a			storage_clear_page: 
0a0a e5				push hl 
0a0b d5				push de 
0a0c c5				push bc 
0a0d 21 e8 f9			ld hl, store_page 
0a10 3e 00			ld a, 0 
0a12 77				ld (hl), a 
0a13			 
0a13 11 e9 f9			ld de, store_page+1 
0a16 01 40 00			ld bc, STORE_BLOCK_PHY 
0a19			 
0a19 ed b0			ldir 
0a1b				 
0a1b c1				pop bc 
0a1c d1				pop de 
0a1d e1				pop hl 
0a1e c9				ret 
0a1f			 
0a1f			; eof 
# End of file firmware_storage.asm
0a1f			  
0a1f			; support routines for above hardware abstraction layer  
0a1f			  
0a1f			include "firmware_general.asm"        ; general support functions  
0a1f			 
0a1f			 
0a1f			 
0a1f			; Delay loops 
0a1f			 
0a1f			 
0a1f			 
0a1f			aDelayInMS: 
0a1f c5				push bc 
0a20 47				ld b,a 
0a21			msdelay: 
0a21 c5				push bc 
0a22				 
0a22			 
0a22 01 41 00			ld bc,041h 
0a25 cd 3d 0a			call delayloop 
0a28 c1				pop bc 
0a29 05				dec b 
0a2a 20 f5			jr nz,msdelay 
0a2c			 
0a2c			;if CPU_CLOCK_8MHZ 
0a2c			;msdelay8: 
0a2c			;	push bc 
0a2c			;	 
0a2c			; 
0a2c			;	ld bc,041h 
0a2c			;	call delayloop 
0a2c			;	pop bc 
0a2c			;	dec b 
0a2c			;	jr nz,msdelay8 
0a2c			;endif 
0a2c			 
0a2c			 
0a2c c1				pop bc 
0a2d c9				ret 
0a2e			 
0a2e			 
0a2e			delay250ms: 
0a2e				;push de 
0a2e 01 00 40			ld bc, 04000h 
0a31 c3 3d 0a			jp delayloop 
0a34			delay500ms: 
0a34				;push de 
0a34 01 00 80			ld bc, 08000h 
0a37 c3 3d 0a			jp delayloop 
0a3a			delay1s: 
0a3a				;push bc 
0a3a			   ; Clobbers A, d and e 
0a3a 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0a3d			delayloop: 
0a3d c5			    push bc 
0a3e			 
0a3e			if BASE_CPM 
0a3e				ld bc, CPM_DELAY_TUNE 
0a3e			.cpmloop: 
0a3e				push bc 
0a3e			 
0a3e			endif 
0a3e			 
0a3e			 
0a3e			 
0a3e			delayloopi: 
0a3e			;	push bc 
0a3e			;.dl: 
0a3e cb 47		    bit     0,a    	; 8 
0a40 cb 47		    bit     0,a    	; 8 
0a42 cb 47		    bit     0,a    	; 8 
0a44 e6 ff		    and     255  	; 7 
0a46 0b			    dec     bc      	; 6 
0a47 79			    ld      a,c     	; 4 
0a48 b0			    or      b     	; 4 
0a49 c2 3e 0a		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0a4c			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0a4c				;pop de 
0a4c			;pop bc 
0a4c			 
0a4c			if BASE_CPM 
0a4c				pop bc 
0a4c				 
0a4c			    dec     bc      	; 6 
0a4c			    ld      a,c     	; 4 
0a4c			    or      b     	; 4 
0a4c			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0a4c				 
0a4c			 
0a4c			endif 
0a4c			;if CPU_CLOCK_8MHZ 
0a4c			;    pop bc 
0a4c			;    push bc 
0a4c			;.dl8: 
0a4c			;    bit     0,a    	; 8 
0a4c			;    bit     0,a    	; 8 
0a4c			;    bit     0,a    	; 8 
0a4c			;    and     255  	; 7 
0a4c			;    dec     bc      	; 6 
0a4c			;    ld      a,c     	; 4 
0a4c			;    or      b     	; 4 
0a4c			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0a4c			;endif 
0a4c			 
0a4c			;if CPU_CLOCK_10MHZ 
0a4c			;    pop bc 
0a4c			;    push bc 
0a4c			;.dl8: 
0a4c			;    bit     0,a    	; 8 
0a4c			;    bit     0,a    	; 8 
0a4c			;    bit     0,a    	; 8 
0a4c			;    and     255  	; 7 
0a4c			;    dec     bc      	; 6 
0a4c			;    ld      a,c     	; 4 
0a4c			;    or      b     	; 4 
0a4c			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0a4c			;endif 
0a4c c1			    pop bc 
0a4d			 
0a4d c9				ret 
0a4e			 
0a4e			 
0a4e			 
0a4e			; eof 
# End of file firmware_general.asm
0a4e			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0a4e			; display routines that use the physical hardware abstraction layer 
0a4e			 
0a4e			 
0a4e			; TODO windowing? 
0a4e			 
0a4e			; TODO scroll line up 
0a4e			 
0a4e			scroll_up: 
0a4e			 
0a4e e5				push hl 
0a4f d5				push de 
0a50 c5				push bc 
0a51			 
0a51				; get frame buffer  
0a51			 
0a51 2a 5e fa			ld hl, (display_fb_active) 
0a54 e5				push hl    ; future de destination 
0a55			 
0a55 11 14 00			ld  de, display_cols 
0a58 19				add hl, de 
0a59			 
0a59 d1				pop de 
0a5a			 
0a5a				;ex de, hl 
0a5a 01 4f 00			ld bc, display_fb_len -1  
0a5d			;if DEBUG_FORTH_WORDS 
0a5d			;	DMARK "SCL" 
0a5d			;	CALLMONITOR 
0a5d			;endif	 
0a5d ed b0			ldir 
0a5f			 
0a5f				; wipe bottom row 
0a5f			 
0a5f			 
0a5f 2a 5e fa			ld hl, (display_fb_active) 
0a62 11 50 00			ld de, display_cols*display_rows 
0a65 19				add hl, de 
0a66 06 14			ld b, display_cols 
0a68 3e 20			ld a, ' ' 
0a6a			.scwipe: 
0a6a 77				ld (hl), a 
0a6b 2b				dec hl 
0a6c 10 fc			djnz .scwipe 
0a6e			 
0a6e				;pop hl 
0a6e			 
0a6e c1				pop bc 
0a6f d1				pop de 
0a70 e1				pop hl 
0a71			 
0a71 c9				ret 
0a72			 
0a72			 
0a72			scroll_upo: 
0a72 11 00 00			ld de, display_row_1 
0a75 21 14 00		 	ld hl, display_row_2 
0a78 01 14 00			ld bc, display_cols 
0a7b ed b0			ldir 
0a7d 11 14 00			ld de, display_row_2 
0a80 21 28 00		 	ld hl, display_row_3 
0a83 01 14 00			ld bc, display_cols 
0a86 ed b0			ldir 
0a88 11 28 00			ld de, display_row_3 
0a8b 21 3c 00		 	ld hl, display_row_4 
0a8e 01 14 00			ld bc, display_cols 
0a91 ed b0			ldir 
0a93			 
0a93			; TODO clear row 4 
0a93			 
0a93 c9				ret 
0a94				 
0a94			scroll_down: 
0a94 11 3c 00			ld de, display_row_4 
0a97 21 28 00		 	ld hl, display_row_3 
0a9a 01 14 00			ld bc, display_cols 
0a9d ed b0			ldir 
0a9f 11 28 00			ld de, display_row_3 
0aa2 21 14 00		 	ld hl, display_row_2 
0aa5 01 14 00			ld bc, display_cols 
0aa8 ed b0			ldir 
0aaa 11 14 00			ld de, display_row_2 
0aad 21 00 00		 	ld hl, display_row_1 
0ab0 01 14 00			ld bc, display_cols 
0ab3 ed b0			ldir 
0ab5			; TODO clear row 1 
0ab5 c9				ret 
0ab6			 
0ab6			 
0ab6			 
0ab6			 
0ab6			 
0ab6			; clear active frame buffer 
0ab6			 
0ab6			clear_display: 
0ab6 3e 20			ld a, ' ' 
0ab8 c3 bb 0a			jp fill_display 
0abb			 
0abb			; fill active frame buffer with a char in A 
0abb			 
0abb			fill_display: 
0abb 06 50			ld b,display_fb_len 
0abd 2a 5e fa			ld hl, (display_fb_active) 
0ac0 77			.fd1:	ld (hl),a 
0ac1 23				inc hl 
0ac2 10 fc			djnz .fd1 
0ac4 23				inc hl 
0ac5 3e 00			ld a,0 
0ac7 77				ld (hl),a 
0ac8			 
0ac8			 
0ac8 c9				ret 
0ac9			; Write string (DE) at pos (A) to active frame buffer 
0ac9			 
0ac9 2a 5e fa		str_at_display:    ld hl,(display_fb_active) 
0acc 06 00					ld b,0 
0ace 4f					ld c,a 
0acf 09					add hl,bc 
0ad0 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0ad1 b7			            OR   A              ;Null terminator? 
0ad2 c8			            RET  Z              ;Yes, so finished 
0ad3 77					ld (hl),a 
0ad4 23				inc hl 
0ad5 13			            INC  DE             ;Point to next character 
0ad6 18 f8		            JR   .sad1     ;Repeat 
0ad8 c9					ret 
0ad9			 
0ad9			; using current frame buffer write to physical display 
0ad9			 
0ad9			update_display: 
0ad9 e5				push hl 
0ada 2a 5e fa			ld hl, (display_fb_active) 
0add cd 59 61			call write_display 
0ae0 e1				pop hl 
0ae1 c9				ret 
0ae2			 
0ae2			; TODO scrolling 
0ae2			 
0ae2			 
0ae2			; move cursor right one char 
0ae2			cursor_right: 
0ae2			 
0ae2				; TODO shift right 
0ae2				; TODO if beyond max col 
0ae2				; TODO       cursor_next_line 
0ae2			 
0ae2 c9				ret 
0ae3			 
0ae3			 
0ae3			cursor_next_line: 
0ae3				; TODO first char 
0ae3				; TODO line down 
0ae3				; TODO if past last row 
0ae3				; TODO    scroll up 
0ae3			 
0ae3 c9				ret 
0ae4			 
0ae4			cursor_left: 
0ae4				; TODO shift left 
0ae4				; TODO if beyond left  
0ae4				; TODO     cursor prev line 
0ae4				 
0ae4 c9				ret 
0ae5			 
0ae5			cursor_prev_line: 
0ae5				; TODO last char 
0ae5				; TODO line up 
0ae5				; TODO if past first row 
0ae5				; TODO   scroll down 
0ae5			 
0ae5 c9				ret 
0ae6			 
0ae6			 
0ae6			cout: 
0ae6				; A - char 
0ae6 c9				ret 
0ae7			 
0ae7			; eof 
0ae7			 
# End of file firmware_display.asm
0ae7			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0ae7			; random number generators 
0ae7			 
0ae7			 
0ae7			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0ae7			 
0ae7			 
0ae7			;-----> Generate a random number 
0ae7			; output a=answer 0<=a<=255 
0ae7			; all registers are preserved except: af 
0ae7			random: 
0ae7 e5			        push    hl 
0ae8 d5			        push    de 
0ae9 2a 40 fa		        ld      hl,(randData) 
0aec ed 5f		        ld      a,r 
0aee 57			        ld      d,a 
0aef 5e			        ld      e,(hl) 
0af0 19			        add     hl,de 
0af1 85			        add     a,l 
0af2 ac			        xor     h 
0af3 22 40 fa		        ld      (randData),hl 
0af6 d1			        pop     de 
0af7 e1			        pop     hl 
0af8 c9			        ret 
0af9			 
0af9			 
0af9			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0af9			 
0af9			 
0af9			 
0af9			;------LFSR------ 
0af9			;James Montelongo 
0af9			;optimized by Spencer Putt 
0af9			;out: 
0af9			; a = 8 bit random number 
0af9			RandLFSR: 
0af9 21 46 fa		        ld hl,LFSRSeed+4 
0afc 5e			        ld e,(hl) 
0afd 23			        inc hl 
0afe 56			        ld d,(hl) 
0aff 23			        inc hl 
0b00 4e			        ld c,(hl) 
0b01 23			        inc hl 
0b02 7e			        ld a,(hl) 
0b03 47			        ld b,a 
0b04 cb 13		        rl e  
0b06 cb 12			rl d 
0b08 cb 11		        rl c  
0b0a 17				rla 
0b0b cb 13		        rl e  
0b0d cb 12			rl d 
0b0f cb 11		        rl c  
0b11 17				rla 
0b12 cb 13		        rl e  
0b14 cb 12			rl d 
0b16 cb 11		        rl c  
0b18 17				rla 
0b19 67			        ld h,a 
0b1a cb 13		        rl e  
0b1c cb 12			rl d 
0b1e cb 11		        rl c  
0b20 17				rla 
0b21 a8			        xor b 
0b22 cb 13		        rl e  
0b24 cb 12			rl d 
0b26 ac			        xor h 
0b27 a9			        xor c 
0b28 aa			        xor d 
0b29 21 48 fa		        ld hl,LFSRSeed+6 
0b2c 11 49 fa		        ld de,LFSRSeed+7 
0b2f 01 07 00		        ld bc,7 
0b32 ed b8		        lddr 
0b34 12			        ld (de),a 
0b35 c9			        ret 
0b36			 
0b36			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0b36			 
0b36			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0b36			 
0b36			 
0b36			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0b36			 
0b36			prng16: 
0b36			;Inputs: 
0b36			;   (seed1) contains a 16-bit seed value 
0b36			;   (seed2) contains a NON-ZERO 16-bit seed value 
0b36			;Outputs: 
0b36			;   HL is the result 
0b36			;   BC is the result of the LCG, so not that great of quality 
0b36			;   DE is preserved 
0b36			;Destroys: 
0b36			;   AF 
0b36			;cycle: 4,294,901,760 (almost 4.3 billion) 
0b36			;160cc 
0b36			;26 bytes 
0b36 2a 3a fa		    ld hl,(seed1) 
0b39 44			    ld b,h 
0b3a 4d			    ld c,l 
0b3b 29			    add hl,hl 
0b3c 29			    add hl,hl 
0b3d 2c			    inc l 
0b3e 09			    add hl,bc 
0b3f 22 3a fa		    ld (seed1),hl 
0b42 2a 38 fa		    ld hl,(seed2) 
0b45 29			    add hl,hl 
0b46 9f			    sbc a,a 
0b47 e6 2d		    and %00101101 
0b49 ad			    xor l 
0b4a 6f			    ld l,a 
0b4b 22 38 fa		    ld (seed2),hl 
0b4e 09			    add hl,bc 
0b4f c9			    ret 
0b50			 
0b50			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0b50			 
0b50			rand32: 
0b50			;Inputs: 
0b50			;   (seed1_0) holds the lower 16 bits of the first seed 
0b50			;   (seed1_1) holds the upper 16 bits of the first seed 
0b50			;   (seed2_0) holds the lower 16 bits of the second seed 
0b50			;   (seed2_1) holds the upper 16 bits of the second seed 
0b50			;   **NOTE: seed2 must be non-zero 
0b50			;Outputs: 
0b50			;   HL is the result 
0b50			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0b50			;Destroys: 
0b50			;   AF 
0b50			;Tested and passes all CAcert tests 
0b50			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0b50			;it has a period of 18,446,744,069,414,584,320 
0b50			;roughly 18.4 quintillion. 
0b50			;LFSR taps: 0,2,6,7  = 11000101 
0b50			;291cc 
0b50			;seed1_0=$+1 
0b50			;    ld hl,12345 
0b50			;seed1_1=$+1 
0b50			;    ld de,6789 
0b50			;    ld b,h 
0b50			;    ld c,l 
0b50			;    add hl,hl \ rl e \ rl d 
0b50			;    add hl,hl \ rl e \ rl d 
0b50			;    inc l 
0b50			;    add hl,bc 
0b50			;    ld (seed1_0),hl 
0b50			;    ld hl,(seed1_1) 
0b50			;    adc hl,de 
0b50			;    ld (seed1_1),hl 
0b50			;    ex de,hl 
0b50			;seed2_0=$+1 
0b50			;    ld hl,9876 
0b50			;seed2_1=$+1 
0b50			;    ld bc,54321 
0b50			;    add hl,hl \ rl c \ rl b 
0b50			;    ld (seed2_1),bc 
0b50			;    sbc a,a 
0b50			;    and %11000101 
0b50			;    xor l 
0b50			;    ld l,a 
0b50			;    ld (seed2_0),hl 
0b50			;    ex de,hl 
0b50			;    add hl,bc 
0b50			;    ret 
0b50			; 
0b50			 
0b50			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0b50			; 20 bytes, 86 cycles (excluding ret) 
0b50			 
0b50			; returns   hl = pseudorandom number 
0b50			; corrupts   a 
0b50			 
0b50			; generates 16-bit pseudorandom numbers with a period of 65535 
0b50			; using the xorshift method: 
0b50			 
0b50			; hl ^= hl << 7 
0b50			; hl ^= hl >> 9 
0b50			; hl ^= hl << 8 
0b50			 
0b50			; some alternative shift triplets which also perform well are: 
0b50			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0b50			 
0b50			;  org 32768 
0b50			 
0b50			xrnd: 
0b50 2a 3e fa		  ld hl,(xrandc)       ; seed must not be 0 
0b53 3e 00		  ld a,0 
0b55 bd			  cp l 
0b56 20 02		  jr nz, .xrnd1 
0b58 2e 01		  ld l, 1 
0b5a			.xrnd1: 
0b5a			 
0b5a 7c			  ld a,h 
0b5b 1f			  rra 
0b5c 7d			  ld a,l 
0b5d 1f			  rra 
0b5e ac			  xor h 
0b5f 67			  ld h,a 
0b60 7d			  ld a,l 
0b61 1f			  rra 
0b62 7c			  ld a,h 
0b63 1f			  rra 
0b64 ad			  xor l 
0b65 6f			  ld l,a 
0b66 ac			  xor h 
0b67 67			  ld h,a 
0b68			 
0b68 22 3e fa		  ld (xrandc),hl 
0b6b			 
0b6b c9			  ret 
0b6c			;  
0b6c			 
0b6c			 
0b6c			;;;; int maths 
0b6c			 
0b6c			; https://map.grauw.nl/articles/mult_div_shifts.php 
0b6c			; Divide 16-bit values (with 16-bit result) 
0b6c			; In: Divide BC by divider DE 
0b6c			; Out: BC = result, HL = rest 
0b6c			; 
0b6c			Div16: 
0b6c 21 00 00		    ld hl,0 
0b6f 78			    ld a,b 
0b70 06 08		    ld b,8 
0b72			Div16_Loop1: 
0b72 17			    rla 
0b73 ed 6a		    adc hl,hl 
0b75 ed 52		    sbc hl,de 
0b77 30 01		    jr nc,Div16_NoAdd1 
0b79 19			    add hl,de 
0b7a			Div16_NoAdd1: 
0b7a 10 f6		    djnz Div16_Loop1 
0b7c 17			    rla 
0b7d 2f			    cpl 
0b7e 47			    ld b,a 
0b7f 79			    ld a,c 
0b80 48			    ld c,b 
0b81 06 08		    ld b,8 
0b83			Div16_Loop2: 
0b83 17			    rla 
0b84 ed 6a		    adc hl,hl 
0b86 ed 52		    sbc hl,de 
0b88 30 01		    jr nc,Div16_NoAdd2 
0b8a 19			    add hl,de 
0b8b			Div16_NoAdd2: 
0b8b 10 f6		    djnz Div16_Loop2 
0b8d 17			    rla 
0b8e 2f			    cpl 
0b8f 41			    ld b,c 
0b90 4f			    ld c,a 
0b91 c9			ret 
0b92			 
0b92			 
0b92			;http://z80-heaven.wikidot.com/math 
0b92			; 
0b92			;Inputs: 
0b92			;     DE and A are factors 
0b92			;Outputs: 
0b92			;     A is not changed 
0b92			;     B is 0 
0b92			;     C is not changed 
0b92			;     DE is not changed 
0b92			;     HL is the product 
0b92			;Time: 
0b92			;     342+6x 
0b92			; 
0b92			Mult16: 
0b92			 
0b92 06 08		     ld b,8          ;7           7 
0b94 21 00 00		     ld hl,0         ;10         10 
0b97 29			       add hl,hl     ;11*8       88 
0b98 07			       rlca          ;4*8        32 
0b99 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0b9b 19			         add hl,de   ;--         -- 
0b9c 10 f9		       djnz $-5      ;13*7+8     99 
0b9e c9			ret 
0b9f			 
0b9f			; 
0b9f			; Square root of 16-bit value 
0b9f			; In:  HL = value 
0b9f			; Out:  D = result (rounded down) 
0b9f			; 
0b9f			;Sqr16: 
0b9f			;    ld de,#0040 
0b9f			;    ld a,l 
0b9f			;    ld l,h 
0b9f			;    ld h,d 
0b9f			;    or a 
0b9f			;    ld b,8 
0b9f			;Sqr16_Loop: 
0b9f			;    sbc hl,de 
0b9f			;    jr nc,Sqr16_Skip 
0b9f			;    add hl,de 
0b9f			;Sqr16_Skip: 
0b9f			;    ccf 
0b9f			;    rl d 
0b9f			;    add a,a 
0b9f			;    adc hl,hl 
0b9f			;    add a,a 
0b9f			;    adc hl,hl 
0b9f			;    djnz Sqr16_Loop 
0b9f			;    ret 
0b9f			; 
0b9f			; 
0b9f			; Divide 8-bit values 
0b9f			; In: Divide E by divider C 
0b9f			; Out: A = result, B = rest 
0b9f			; 
0b9f			Div8: 
0b9f af			    xor a 
0ba0 06 08		    ld b,8 
0ba2			Div8_Loop: 
0ba2 cb 13		    rl e 
0ba4 17			    rla 
0ba5 91			    sub c 
0ba6 30 01		    jr nc,Div8_NoAdd 
0ba8 81			    add a,c 
0ba9			Div8_NoAdd: 
0ba9 10 f7		    djnz Div8_Loop 
0bab 47			    ld b,a 
0bac 7b			    ld a,e 
0bad 17			    rla 
0bae 2f			    cpl 
0baf c9			    ret 
0bb0			 
0bb0			; 
0bb0			; Multiply 8-bit value with a 16-bit value (unrolled) 
0bb0			; In: Multiply A with DE 
0bb0			; Out: HL = result 
0bb0			; 
0bb0			Mult12U: 
0bb0 2e 00		    ld l,0 
0bb2 87			    add a,a 
0bb3 30 01		    jr nc,Mult12U_NoAdd0 
0bb5 19			    add hl,de 
0bb6			Mult12U_NoAdd0: 
0bb6 29			    add hl,hl 
0bb7 87			    add a,a 
0bb8 30 01		    jr nc,Mult12U_NoAdd1 
0bba 19			    add hl,de 
0bbb			Mult12U_NoAdd1: 
0bbb 29			    add hl,hl 
0bbc 87			    add a,a 
0bbd 30 01		    jr nc,Mult12U_NoAdd2 
0bbf 19			    add hl,de 
0bc0			Mult12U_NoAdd2: 
0bc0 29			    add hl,hl 
0bc1 87			    add a,a 
0bc2 30 01		    jr nc,Mult12U_NoAdd3 
0bc4 19			    add hl,de 
0bc5			Mult12U_NoAdd3: 
0bc5 29			    add hl,hl 
0bc6 87			    add a,a 
0bc7 30 01		    jr nc,Mult12U_NoAdd4 
0bc9 19			    add hl,de 
0bca			Mult12U_NoAdd4: 
0bca 29			    add hl,hl 
0bcb 87			    add a,a 
0bcc 30 01		    jr nc,Mult12U_NoAdd5 
0bce 19			    add hl,de 
0bcf			Mult12U_NoAdd5: 
0bcf 29			    add hl,hl 
0bd0 87			    add a,a 
0bd1 30 01		    jr nc,Mult12U_NoAdd6 
0bd3 19			    add hl,de 
0bd4			Mult12U_NoAdd6: 
0bd4 29			    add hl,hl 
0bd5 87			    add a,a 
0bd6 d0			    ret nc 
0bd7 19			    add hl,de 
0bd8 c9			    ret 
0bd9			 
0bd9			; 
0bd9			; Multiply 8-bit value with a 16-bit value (right rotating) 
0bd9			; In: Multiply A with DE 
0bd9			;      Put lowest value in A for most efficient calculation 
0bd9			; Out: HL = result 
0bd9			; 
0bd9			Mult12R: 
0bd9 21 00 00		    ld hl,0 
0bdc			Mult12R_Loop: 
0bdc cb 3f		    srl a 
0bde 30 01		    jr nc,Mult12R_NoAdd 
0be0 19			    add hl,de 
0be1			Mult12R_NoAdd: 
0be1 cb 23		    sla e 
0be3 cb 12		    rl d 
0be5 b7			    or a 
0be6 c2 dc 0b		    jp nz,Mult12R_Loop 
0be9 c9			    ret 
0bea			 
0bea			; 
0bea			; Multiply 16-bit values (with 32-bit result) 
0bea			; In: Multiply BC with DE 
0bea			; Out: BCHL = result 
0bea			; 
0bea			Mult32: 
0bea 79			    ld a,c 
0beb 48			    ld c,b 
0bec 21 00 00		    ld hl,0 
0bef 06 10		    ld b,16 
0bf1			Mult32_Loop: 
0bf1 29			    add hl,hl 
0bf2 17			    rla 
0bf3 cb 11		    rl c 
0bf5 30 07		    jr nc,Mult32_NoAdd 
0bf7 19			    add hl,de 
0bf8 ce 00		    adc a,0 
0bfa d2 fe 0b		    jp nc,Mult32_NoAdd 
0bfd 0c			    inc c 
0bfe			Mult32_NoAdd: 
0bfe 10 f1		    djnz Mult32_Loop 
0c00 41			    ld b,c 
0c01 4f			    ld c,a 
0c02 c9			    ret 
0c03			 
0c03			 
0c03			 
0c03			; 
0c03			; Multiply 8-bit values 
0c03			; In:  Multiply H with E 
0c03			; Out: HL = result 
0c03			; 
0c03			Mult8: 
0c03 16 00		    ld d,0 
0c05 6a			    ld l,d 
0c06 06 08		    ld b,8 
0c08			Mult8_Loop: 
0c08 29			    add hl,hl 
0c09 30 01		    jr nc,Mult8_NoAdd 
0c0b 19			    add hl,de 
0c0c			Mult8_NoAdd: 
0c0c 10 fa		    djnz Mult8_Loop 
0c0e c9			    ret 
0c0f			 
0c0f			 
0c0f			 
0c0f			 
0c0f			 
0c0f			 
0c0f			 
0c0f			 
0c0f			;;http://z80-heaven.wikidot.com/math 
0c0f			;;This divides DE by BC, storing the result in DE, remainder in HL 
0c0f			; 
0c0f			;DE_Div_BC:          ;1281-2x, x is at most 16 
0c0f			;     ld a,16        ;7 
0c0f			;     ld hl,0        ;10 
0c0f			;     jp $+5         ;10 
0c0f			;.DivLoop: 
0c0f			;       add hl,bc    ;-- 
0c0f			;       dec a        ;64 
0c0f			;       jr z,.DivLoopEnd        ;86 
0c0f			; 
0c0f			;       sla e        ;128 
0c0f			;       rl d         ;128 
0c0f			;       adc hl,hl    ;240 
0c0f			;       sbc hl,bc    ;240 
0c0f			;       jr nc,.DivLoop ;23|21 
0c0f			;       inc e        ;-- 
0c0f			;       jp .DivLoop+1 
0c0f			; 
0c0f			;.DivLoopEnd: 
0c0f			 
0c0f			;HL_Div_C: 
0c0f			;Inputs: 
0c0f			;     HL is the numerator 
0c0f			;     C is the denominator 
0c0f			;Outputs: 
0c0f			;     A is the remainder 
0c0f			;     B is 0 
0c0f			;     C is not changed 
0c0f			;     DE is not changed 
0c0f			;     HL is the quotient 
0c0f			; 
0c0f			;       ld b,16 
0c0f			;       xor a 
0c0f			;         add hl,hl 
0c0f			;         rla 
0c0f			;         cp c 
0c0f			;         jr c,$+4 
0c0f			;           inc l 
0c0f			;           sub c 
0c0f			;         djnz $-7 
0c0f			 
0c0f			; https://plutiedev.com/z80-add-8bit-to-16bit 
0c0f			 
0c0f			addatohl: 
0c0f 85			    add   a, l    ; A = A+L 
0c10 6f			    ld    l, a    ; L = A+L 
0c11 8c			    adc   a, h    ; A = A+L+H+carry 
0c12 95			    sub   l       ; A = H+carry 
0c13 67			    ld    h, a    ; H = H+carry 
0c14 c9			ret 
0c15			 
0c15			addatode: 
0c15 83			    add   a, e    ; A = A+L 
0c16 5f			    ld    e, a    ; L = A+L 
0c17 8a			    adc   a, d    ; A = A+L+H+carry 
0c18 93			    sub   e       ; A = H+carry 
0c19 57			    ld    d, a    ; H = H+carry 
0c1a c9			ret 
0c1b			 
0c1b			 
0c1b			addatobc: 
0c1b 81			    add   a, c    ; A = A+L 
0c1c 4f			    ld    c, a    ; L = A+L 
0c1d 88			    adc   a, b    ; A = A+L+H+carry 
0c1e 91			    sub   c       ; A = H+carry 
0c1f 47			    ld    b, a    ; H = H+carry 
0c20 c9			ret 
0c21			 
0c21			subafromhl: 
0c21			   ; If A=0 do nothing 
0c21			    ; Otherwise flip A's sign. Since 
0c21			    ; the upper byte becomes -1, also 
0c21			    ; substract 1 from H. 
0c21 ed 44		    neg 
0c23 ca 2c 0c		    jp    z, Skip 
0c26 25			    dec   h 
0c27			     
0c27			    ; Now add the low byte as usual 
0c27			    ; Two's complement takes care of 
0c27			    ; ensuring the result is correct 
0c27 85			    add   a, l 
0c28 6f			    ld    l, a 
0c29 8c			    adc   a, h 
0c2a 95			    sub   l 
0c2b 67			    ld    h, a 
0c2c			Skip: 
0c2c c9				ret 
0c2d			 
0c2d			 
0c2d			; compare hl and de 
0c2d			; returns:  
0c2d			; if hl = de, z=1, s=0, c0=0 
0c2d			; if hl > de, z=0, s=0, c=0 
0c2d			; if hl < de, z=0, s=1, c=1 
0c2d			cmp16:	 
0c2d b7				or a 
0c2e ed 52			sbc hl,de 
0c30 e0				ret po 
0c31 7c				ld a,h 
0c32 1f				rra 
0c33 ee 40			xor 01000000B 
0c35 37				scf 
0c36 8f				adc a,a 
0c37 c9				ret 
0c38			 
0c38			 
0c38			; test if hl contains zero   - A is destroyed 
0c38			 
0c38			ishlzero:    
0c38 b7				or a     ; reset flags 
0c39 7c				ld a, h 
0c3a b5				or l        	 
0c3b			 
0c3b c9				ret 
0c3c			 
0c3c			 
0c3c			 
0c3c			 
0c3c			if FORTH_ENABLE_FLOATMATH 
0c3c			;include "float/bbcmath.z80" 
0c3c			include "float/lpfpcalc.asm" 
0c3c			endif 
0c3c			 
0c3c			 
0c3c			; eof 
0c3c			 
# End of file firmware_maths.asm
0c3c			include "firmware_strings.asm"   ; string handling  
0c3c			 
0c3c			 
0c3c			; TODO string len 
0c3c			; input text string, end on cr with zero term 
0c3c			; a offset into frame buffer to start prompt 
0c3c			; d is max length 
0c3c			; e is display size TODO 
0c3c			; c is current cursor position 
0c3c			; hl is ptr to where string will be stored 
0c3c			 
0c3c			 
0c3c			; TODO check limit of buffer for new inserts 
0c3c			; TODO check insert does not push beyond buffer 
0c3c			; TODO scroll in a limited display area 
0c3c			; TODO scroll whole screen on page wrap 
0c3c			 
0c3c			 
0c3c			; TODO handle KEY_PREVWORD 
0c3c			; TODO handle KEY_NEXTWORD 
0c3c			; TODO handle KEY_HOME 
0c3c			; TODO handle KEY_END 
0c3c			; TODO use LCD cursor? 
0c3c			 
0c3c 32 b6 fb		input_str:    	ld (input_at_pos),a      ; save display position to start 
0c3f 81					add c 
0c40 32 b4 fb				ld (input_at_cursor),a	; save draw pos of cursor 
0c43 22 b9 fb				ld (input_start), hl     ; save ptr to buffer 
0c46 79					ld a, c 
0c47 cd 0f 0c				call addatohl 
0c4a 22 bb fb				ld (input_ptr), hl     ; save ptr to point under the cursor 
0c4d 7a					ld a,d 
0c4e 32 b8 fb			        ld (input_size), a       ; save length of input area 
0c51 79					ld a, c 
0c52 32 a7 fb				ld (input_cursor),a      ; init cursor start position  
0c55 7b					ld a,e 
0c56 32 b7 fb			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0c59					 
0c59					 
0c59			 
0c59			;		ld a,(input_ptr) 
0c59			;		ld (input_under_cursor),a 	; save what is under the cursor 
0c59			 
0c59			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0c59					; init cursor shape if not set by the cin routines 
0c59 21 56 fa				ld hl, cursor_shape 
0c5c 3e ff				ld a, 255 
0c5e 77					ld (hl), a 
0c5f 23					inc hl 
0c60 3e 00				ld a, 0 
0c62 77					ld (hl), a 
0c63			 
0c63 3e 0f				ld a, CUR_BLINK_RATE 
0c65 32 b2 fb				ld (input_cur_flash), a 
0c68 3e 01				ld a, 1 
0c6a 32 b1 fb				ld (input_cur_onoff),a 
0c6d			 
0c6d			;	if DEBUG_INPUT 
0c6d			;		push af 
0c6d			;		ld a, 'I' 
0c6d			;		ld (debug_mark),a 
0c6d			;		pop af 
0c6d			;		CALLMONITOR 
0c6d			;	endif 
0c6d			.is1:		; main entry loop 
0c6d			 
0c6d			 
0c6d			 
0c6d					; pause 1ms 
0c6d			 
0c6d 3e 01				ld a, 1 
0c6f cd 1f 0a				call aDelayInMS 
0c72			 
0c72					; dec flash counter 
0c72 3a b2 fb				ld a, (input_cur_flash) 
0c75 3d					dec a 
0c76 32 b2 fb				ld (input_cur_flash), a 
0c79 fe 00				cp 0 
0c7b 20 0d				jr nz, .nochgstate 
0c7d			 
0c7d			 
0c7d					; change state 
0c7d 3a b1 fb				ld a,(input_cur_onoff) 
0c80 ed 44				neg 
0c82 32 b1 fb				ld (input_cur_onoff),a 
0c85			 
0c85			 
0c85					; reset on change of state 
0c85 3e 0f				ld a, CUR_BLINK_RATE 
0c87 32 b2 fb				ld (input_cur_flash), a 
0c8a			 
0c8a			.nochgstate: 
0c8a					 
0c8a					 
0c8a			 
0c8a					; display cursor  
0c8a			 
0c8a			;		ld hl, (input_start) 
0c8a			;		ld a, (input_cursor) 
0c8a			;		call addatohl 
0c8a			 
0c8a					; get char under cursor and replace with cursor 
0c8a 2a bb fb		ld hl, (input_ptr) 
0c8d			;		ld a, (hl) 
0c8d			;		ld (input_under_cursor),a 
0c8d			;		ld a, '_' 
0c8d			;		ld (hl), a 
0c8d			 
0c8d					; display string 
0c8d			 
0c8d ed 5b b9 fb			ld de, (input_start) 
0c91 3a b6 fb				ld a, (input_at_pos) 
0c94 cd c9 0a				call str_at_display 
0c97			;	        call update_display 
0c97			 
0c97					; find place to put the cursor 
0c97			;		add h 
0c97			;		ld l, display_row_1 
0c97			;		sub l 
0c97			; (input_at_pos) 
0c97					;ld c, a 
0c97			;		ld a, (input_cursor) 
0c97			;		ld l, (input_at_pos) 
0c97			;		;ld b, h 
0c97			;		add l 
0c97			;		ld (input_at_cursor),a 
0c97					;ld l,h 
0c97			 
0c97			;		ld h, 0 
0c97			;		ld l,(input_at_pos) 
0c97			;		ld a, (input_cursor) 
0c97			;		call addatohl 
0c97			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0c97			;		call subafromhl 
0c97			;		ld a,l 
0c97			;		ld (input_at_cursor), a 
0c97			 
0c97				if DEBUG_INPUT 
0c97					ld a, (hardware_diag) 
0c97					cp 0 
0c97					jr z, .skip_input_diag 
0c97			 
0c97					ld a,(input_at_pos) 
0c97					ld hl, LFSRSeed 
0c97					call hexout 
0c97					ld a, (input_cursor) 
0c97					ld hl, LFSRSeed+2 
0c97					call hexout 
0c97					ld a,(input_at_cursor) 
0c97					ld hl, LFSRSeed+4 
0c97					call hexout 
0c97			 
0c97					ld a,(input_cur_onoff) 
0c97					ld hl, LFSRSeed+6 
0c97					call hexout 
0c97			 
0c97					ld a,(input_cur_flash) 
0c97					ld hl, LFSRSeed+8 
0c97					call hexout 
0c97			 
0c97					ld a,(input_len) 
0c97					ld hl, LFSRSeed+10 
0c97					call hexout 
0c97					ld hl, LFSRSeed+12 
0c97					ld a, 0 
0c97					ld (hl),a 
0c97					ld a, display_row_4 
0c97					ld de, LFSRSeed 
0c97					call str_at_display 
0c97					.skip_input_diag: 
0c97				endif 
0c97			 
0c97					; decide on if we are showing the cursor this time round 
0c97			 
0c97 3a b1 fb				ld a, (input_cur_onoff) 
0c9a fe ff				cp 255 
0c9c 28 13				jr z, .skipcur 
0c9e			 
0c9e			 
0c9e 3a b4 fb				ld a,(input_at_cursor) 
0ca1 11 56 fa				ld de, cursor_shape 
0ca4 cd c9 0a				call str_at_display 
0ca7			 
0ca7					; save length of current input string 
0ca7 2a b9 fb				ld hl, (input_start) 
0caa cd 6d 10				call strlenz 
0cad 7d					ld a,l 
0cae 32 ac fb				ld (input_len),a 
0cb1			 
0cb1			.skipcur: 
0cb1			 
0cb1 cd d9 0a			        call update_display 
0cb4					 
0cb4			 
0cb4			 
0cb4					; wait 
0cb4				 
0cb4					; TODO loop without wait to flash the cursor and char under cursor	 
0cb4 cd 0e 63				call cin    ; _wait 
0cb7			 
0cb7 fe 00				cp 0 
0cb9 ca 6d 0c				jp z, .is1 
0cbc			 
0cbc					; get ptr to char to input into 
0cbc			 
0cbc 4f					ld c,a 
0cbd 2a b9 fb				ld hl, (input_start) 
0cc0 3a a7 fb				ld a, (input_cursor) 
0cc3 cd 0f 0c				call addatohl 
0cc6 22 bb fb				ld (input_ptr), hl 
0cc9 79					ld a,c 
0cca			 
0cca					; replace char under cursor 
0cca			 
0cca			;		ld hl, (input_ptr) 
0cca			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0cca			;		ld (hl), a 
0cca			 
0cca			;	if DEBUG_INPUT 
0cca			;		push af 
0cca			;		ld a, 'i' 
0cca			;		ld (debug_mark),a 
0cca			;		pop af 
0cca			;		CALLMONITOR 
0cca			;	endif 
0cca fe 0e				cp KEY_HOME 
0ccc 20 0e				jr nz, .iske 
0cce			 
0cce 3a b6 fb				ld a, (input_at_pos) 
0cd1 32 b4 fb				ld (input_at_cursor),a 
0cd4 3e 00				ld a, 0 
0cd6 32 a7 fb				ld (input_cursor), a 
0cd9 c3 6d 0c				jp .is1 
0cdc					 
0cdc fe 0f		.iske:		cp KEY_END 
0cde 20 03				jr nz, .isknw 
0ce0 c3 6d 0c				jp .is1 
0ce3			 
0ce3 fe 06		.isknw:		cp KEY_NEXTWORD 
0ce5 20 1b				jr nz, .iskpw 
0ce7			 
0ce7 2a bb fb		.isknwm:	ld hl, (input_ptr) 
0cea 7e					ld a,(hl)	 
0ceb fe 00				cp 0 
0ced ca 6d 0c				jp z, .is1    ; end of string 
0cf0 fe 20				cp ' ' 
0cf2 ca 6d 0c				jp z, .is1    ; end of word 
0cf5 23					inc hl 
0cf6 22 bb fb				ld (input_ptr), hl 
0cf9 3a b4 fb				ld a, (input_at_cursor) 
0cfc 3c					inc a 
0cfd 32 b4 fb				ld (input_at_cursor), a 
0d00 18 e5				jr .isknwm 
0d02			 
0d02 fe 07		.iskpw:		cp KEY_PREVWORD 
0d04 20 1b				jr nz, .iskl 
0d06			.iskpwm:	 
0d06 2a bb fb				ld hl, (input_ptr) 
0d09 7e					ld a,(hl)	 
0d0a fe 00				cp 0  
0d0c ca 6d 0c				jp z, .is1    ; end of string 
0d0f fe 20				cp ' ' 
0d11 ca 6d 0c				jp z, .is1    ; end of word 
0d14 2b					dec hl 
0d15 22 bb fb				ld (input_ptr), hl 
0d18 3a b4 fb				ld a, (input_at_cursor) 
0d1b 3d					dec a 
0d1c 32 b4 fb				ld (input_at_cursor), a 
0d1f 18 e5				jr .iskpwm 
0d21			 
0d21			 
0d21 fe 0b		.iskl:		cp KEY_LEFT 
0d23 20 27				jr nz, .isk1 
0d25			 
0d25 3a a7 fb				ld a, (input_cursor) 
0d28			 
0d28 fe 00				cp 0 
0d2a ca 6d 0c				jp z, .is1 		; at start of line to ignore  
0d2d			 
0d2d 3d					dec  a 		; TODO check underflow 
0d2e 32 a7 fb				ld (input_cursor), a 
0d31			 
0d31 2a bb fb				ld hl, (input_ptr) 
0d34 2b					dec hl 
0d35 22 bb fb				ld (input_ptr), hl 
0d38					 
0d38 3a b4 fb				ld a, (input_at_cursor) 
0d3b 3d					dec a 
0d3c 32 b4 fb				ld (input_at_cursor), a 
0d3f			 
0d3f 3e 01				ld a, 1		; show cursor moving 
0d41 32 b1 fb				ld (input_cur_onoff),a 
0d44 3e 0f				ld a, CUR_BLINK_RATE 
0d46 32 b2 fb				ld (input_cur_flash), a 
0d49			 
0d49 c3 6d 0c				jp .is1 
0d4c			 
0d4c fe 0c		.isk1:		cp KEY_RIGHT 
0d4e 20 2a				jr nz, .isk2 
0d50			 
0d50 3a ac fb				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0d53 5f					ld e,a 
0d54 3a a7 fb				ld a, (input_cursor) 
0d57 bb					cp e 
0d58 ca 6d 0c				jp z, .is1		; at the end of string so dont go right 
0d5b			 
0d5b 3c					inc  a 		; TODO check overflow 
0d5c 32 a7 fb				ld (input_cursor), a 
0d5f			 
0d5f 3a b4 fb				ld a, (input_at_cursor) 
0d62 3c					inc a 
0d63 32 b4 fb				ld (input_at_cursor), a 
0d66			 
0d66 2a bb fb				ld hl, (input_ptr) 
0d69 23					inc hl 
0d6a 22 bb fb				ld (input_ptr), hl 
0d6d			 
0d6d 3e 01				ld a, 1		; show cursor moving 
0d6f 32 b1 fb				ld (input_cur_onoff),a 
0d72 3e 0f				ld a, CUR_BLINK_RATE 
0d74 32 b2 fb				ld (input_cur_flash), a 
0d77			 
0d77 c3 6d 0c				jp .is1 
0d7a			 
0d7a fe 05		.isk2:		cp KEY_UP 
0d7c			 
0d7c 20 26				jr nz, .isk3 
0d7e			 
0d7e					; swap last command with the current on 
0d7e			 
0d7e					; move cursor to start of string 
0d7e 2a b9 fb				ld hl, (input_start) 
0d81 22 bb fb				ld (input_ptr), hl 
0d84			 
0d84 3a b6 fb				ld a, (input_at_pos) 
0d87 32 b4 fb				ld (input_at_cursor), a 
0d8a			 
0d8a 3e 00				ld a, 0 
0d8c 32 a7 fb				ld (input_cursor), a 
0d8f					 
0d8f					; swap input and last command buffers 
0d8f			 
0d8f 21 df f2				ld hl, os_cli_cmd 
0d92 11 de f3				ld de, os_last_cmd 
0d95 06 ff				ld b, 255 
0d97 7e			.swap1:		ld a, (hl) 
0d98 4f					ld c,a 
0d99 1a					ld a, (de) 
0d9a 77					ld (hl), a 
0d9b 79					ld a,c 
0d9c 12					ld (de),a 
0d9d 23					inc hl 
0d9e 13					inc de 
0d9f 10 f6				djnz .swap1 
0da1			 
0da1			 
0da1			 
0da1			 
0da1			 
0da1 c3 6d 0c				jp .is1 
0da4			 
0da4 fe 08		.isk3:		cp KEY_BS 
0da6 20 3c				jr nz, .isk4 
0da8			 
0da8 3a a7 fb				ld a, (input_cursor) 
0dab			 
0dab fe 00				cp 0 
0dad ca 6d 0c				jp z, .is1 		; at start of line to ignore  
0db0			 
0db0 3d					dec  a 		; TODO check underflow 
0db1 32 a7 fb				ld (input_cursor), a 
0db4			 
0db4					; hl is source 
0db4					; de needs to be source - 1 
0db4			 
0db4			;		ld a, 0 
0db4			;		dec hl 
0db4			;		ld (hl), a 
0db4			 
0db4 2a bb fb				ld hl, (input_ptr) 
0db7 2b					dec hl 
0db8 22 bb fb				ld (input_ptr), hl 
0dbb			 
0dbb					; shift all data 
0dbb			 
0dbb e5					push hl 
0dbc 23					inc hl 
0dbd d1					pop de 
0dbe 3a ac fb				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0dc1 4f					ld c,a 
0dc2 06 00				ld b,0 
0dc4 ed b0				ldir  
0dc6			 
0dc6			 
0dc6			 
0dc6			 
0dc6 3a b4 fb				ld a, (input_at_cursor) 
0dc9 3d					dec a 
0dca 32 b4 fb				ld (input_at_cursor), a 
0dcd			 
0dcd			 
0dcd 3e 01				ld a, 1		; show cursor moving 
0dcf 32 b1 fb				ld (input_cur_onoff),a 
0dd2 3e 0f				ld a, CUR_BLINK_RATE 
0dd4 32 b2 fb				ld (input_cur_flash), a 
0dd7			 
0dd7					; remove char 
0dd7 3a b4 fb				ld a, (input_at_cursor) 
0dda 3c					inc a 
0ddb 11 65 0e				ld de,.iblank 
0dde cd c9 0a				call str_at_display 
0de1			 
0de1 c3 6d 0c				jp .is1 
0de4			 
0de4 fe 0d		.isk4:		cp KEY_CR 
0de6 28 6c				jr z, .endinput 
0de8			 
0de8					; else add the key press to the end 
0de8			 
0de8 4f					ld c, a			; save key pressed 
0de9			 
0de9 7e					ld a,(hl)		; get what is currently under char 
0dea			 
0dea fe 00				cp 0			; we are at the end of the string 
0dec 20 2f				jr nz, .onchar 
0dee					 
0dee					; add a char to the end of the string 
0dee				 
0dee 71					ld (hl),c 
0def 23					inc hl 
0df0			;		ld a,' ' 
0df0			;		ld (hl),a 
0df0			;		inc hl 
0df0 3e 00				ld a,0 
0df2 77					ld (hl),a 
0df3 2b					dec hl 
0df4			 
0df4 3a a7 fb				ld a, (input_cursor) 
0df7 3c					inc a				; TODO check max string length and scroll  
0df8 32 a7 fb				ld (input_cursor), a		; inc cursor pos 
0dfb							 
0dfb 3a b4 fb				ld a, (input_at_cursor) 
0dfe 3c					inc a 
0dff 32 b4 fb				ld (input_at_cursor), a 
0e02			 
0e02 2a bb fb				ld hl, (input_ptr) 
0e05 23					inc hl 
0e06 22 bb fb				ld (input_ptr), hl 
0e09			 
0e09 2a bb fb				ld hl, (input_ptr) 
0e0c 23					inc hl 
0e0d 22 bb fb				ld (input_ptr), hl 
0e10			;	if DEBUG_INPUT 
0e10			;		push af 
0e10			;		ld a, '+' 
0e10			;		ld (debug_mark),a 
0e10			;		pop af 
0e10			;		CALLMONITOR 
0e10			;	endif 
0e10 3e 01				ld a, 1		; show cursor moving 
0e12 32 b1 fb				ld (input_cur_onoff),a 
0e15 3e 0f				ld a, CUR_BLINK_RATE 
0e17 32 b2 fb				ld (input_cur_flash), a 
0e1a c3 6d 0c				jp .is1 
0e1d					 
0e1d			 
0e1d			 
0e1d					; if on a char then insert 
0e1d			.onchar: 
0e1d			 
0e1d					; TODO over flow check: make sure insert does not blow out buffer 
0e1d			 
0e1d					; need to do some maths to use lddr 
0e1d			 
0e1d e5					push hl   ; save char pos 
0e1e c5					push bc 
0e1f			 
0e1f 2a b9 fb				ld hl, (input_start) 
0e22 3a ac fb				ld a, (input_len) 
0e25 cd 0f 0c				call addatohl  		; end of string 
0e28 23					inc hl 
0e29 23					inc hl		; past zero term 
0e2a e5					push hl 
0e2b 23					inc hl 
0e2c e5					push hl  
0e2d			 
0e2d								; start and end of lddr set, now how much to move? 
0e2d			 
0e2d							 
0e2d 3a a7 fb				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0e30 47					ld b,a 
0e31 3a ac fb				ld a,(input_len) 
0e34 5f					ld e,a 
0e35 90					sub b 
0e36 3c					inc a		;?? 
0e37 3c					inc a		;?? 
0e38 3c					inc a		;?? 
0e39			 
0e39 06 00				ld b,0 
0e3b 4f					ld c,a 
0e3c			 
0e3c				if DEBUG_INPUT 
0e3c					push af 
0e3c					ld a, 'i' 
0e3c					ld (debug_mark),a 
0e3c					pop af 
0e3c			;		CALLMONITOR 
0e3c				endif 
0e3c d1					pop de 
0e3d e1					pop hl 
0e3e				if DEBUG_INPUT 
0e3e					push af 
0e3e					ld a, 'I' 
0e3e					ld (debug_mark),a 
0e3e					pop af 
0e3e			;		CALLMONITOR 
0e3e				endif 
0e3e ed b8				lddr 
0e40				 
0e40			 
0e40			 
0e40					; TODO have a key for insert/overwrite mode???? 
0e40 c1					pop bc 
0e41 e1					pop hl 
0e42 71					ld (hl), c		; otherwise overwrite current char 
0e43					 
0e43			 
0e43			 
0e43			 
0e43 3a a7 fb				ld a, (input_cursor) 
0e46 3c					inc  a 		; TODO check overflow 
0e47 32 a7 fb				ld (input_cursor), a 
0e4a			 
0e4a 3a b4 fb				ld a, (input_at_cursor) 
0e4d 3c					inc a 
0e4e 32 b4 fb				ld (input_at_cursor), a 
0e51			 
0e51 c3 6d 0c				jp .is1 
0e54			 
0e54			.endinput:	; TODO look for end of string 
0e54			 
0e54					; add trailing space for end of token 
0e54			 
0e54 2a b9 fb				ld hl, (input_start) 
0e57 3a ac fb				ld a,(input_len) 
0e5a cd 0f 0c				call addatohl 
0e5d 3e 20				ld a, ' ' 
0e5f 77					ld (hl),a 
0e60					; TODO eof of parse marker 
0e60			 
0e60 23					inc hl 
0e61 3e 00				ld a, 0 
0e63 77					ld (hl),a 
0e64			 
0e64			 
0e64 c9					ret 
0e65			 
0e65 .. 00		.iblank: db " ",0 
0e67			 
0e67			 
0e67 32 b6 fb		input_str_prev:	ld (input_at_pos), a 
0e6a 22 b9 fb				ld (input_start), hl 
0e6d 3e 01				ld a,1			; add cursor 
0e6f 77					ld (hl),a 
0e70 23					inc hl 
0e71 3e 00				ld a,0 
0e73 77					ld (hl),a 
0e74 22 bb fb				ld (input_ptr), hl 
0e77 7a					ld a,d 
0e78 32 b8 fb				ld (input_size), a 
0e7b 3e 00				ld a,0 
0e7d 32 a7 fb				ld (input_cursor),a 
0e80			.instr1:	 
0e80			 
0e80					; TODO do block cursor 
0e80					; TODO switch cursor depending on the modifer key 
0e80			 
0e80					; update cursor shape change on key hold 
0e80			 
0e80 2a bb fb				ld hl, (input_ptr) 
0e83 2b					dec hl 
0e84 3a 56 fa				ld a,(cursor_shape) 
0e87 77					ld (hl), a 
0e88			 
0e88					; display entered text 
0e88 3a b6 fb				ld a,(input_at_pos) 
0e8b cd 2c 62		            	CALL fLCD_Pos       ;Position cursor to location in A 
0e8e ed 5b b9 fb	            	LD   de, (input_start) 
0e92 cd 34 62		            	CALL fLCD_Str       ;Display string pointed to by DE 
0e95			 
0e95 cd 0e 63				call cin 
0e98 fe 00				cp 0 
0e9a 28 e4				jr z, .instr1 
0e9c			 
0e9c					; proecess keyboard controls first 
0e9c			 
0e9c 2a bb fb				ld hl,(input_ptr) 
0e9f			 
0e9f fe 0d				cp KEY_CR	 ; pressing enter ends input 
0ea1 28 5a				jr z, .instrcr 
0ea3			 
0ea3 fe 08				cp KEY_BS 	; back space 
0ea5 20 0f				jr nz, .instr2 
0ea7					; process back space 
0ea7			 
0ea7					; TODO stop back space if at start of string 
0ea7 2b					dec hl 
0ea8 2b					dec hl ; to over write cursor 
0ea9 3a 56 fa				ld a,(cursor_shape) 
0eac					;ld a,0 
0eac 77					ld (hl),a 
0ead 23					inc hl 
0eae 3e 20				ld a," " 
0eb0 77					ld (hl),a 
0eb1 22 bb fb				ld (input_ptr),hl 
0eb4					 
0eb4			 
0eb4 18 ca				jr .instr1 
0eb6			 
0eb6 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
0eb8 20 06				jr nz, .instr3 
0eba 2b					dec hl 
0ebb 22 bb fb				ld (input_ptr),hl 
0ebe 18 c0				jr .instr1 
0ec0				 
0ec0 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
0ec2 20 06				jr nz, .instr4 
0ec4 23					inc hl 
0ec5 22 bb fb				ld (input_ptr),hl 
0ec8 18 b6				jr .instr1 
0eca			 
0eca fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
0ecc 20 06				jr nz, .instr5 
0ece 2b					dec hl 
0ecf 22 bb fb				ld (input_ptr),hl 
0ed2 18 ac				jr .instr1 
0ed4			 
0ed4 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
0ed6 20 06				jr nz, .instr6 
0ed8 2b					dec hl 
0ed9 22 bb fb				ld (input_ptr),hl 
0edc 18 a2				jr .instr1 
0ede fe 05		.instr6:        cp KEY_UP      ; recall last command 
0ee0 20 0b				jr nz, .instrnew 
0ee2			 
0ee2 21 b8 ef			ld hl, scratch 
0ee5 11 de f3			ld de, os_last_cmd 
0ee8 cd 06 0f			call strcpy 
0eeb 18 93				jr .instr1 
0eed			 
0eed			 
0eed			.instrnew:	; no special key pressed to see if we have room to store it 
0eed			 
0eed					; TODO do string size test 
0eed			 
0eed 2b					dec hl ; to over write cursor 
0eee 77					ld (hl),a 
0eef 23					inc hl 
0ef0 3a 56 fa				ld a,(cursor_shape) 
0ef3 77					ld (hl),a 
0ef4 23					inc hl 
0ef5 3e 00				ld a,0 
0ef7 77					ld (hl),a 
0ef8			 
0ef8 22 bb fb				ld (input_ptr),hl 
0efb					 
0efb 18 83				jr .instr1 
0efd 2b			.instrcr:	dec hl		; remove cursor 
0efe 3e 20				ld a,' '	; TODO add a trailing space for safety 
0f00 77					ld (hl),a 
0f01 23					inc hl 
0f02 3e 00				ld a,0 
0f04 77					ld (hl),a 
0f05			 
0f05			 
0f05					; if at end of line scroll up    
0f05					; TODO detecting only end of line 4 for scroll up  
0f05			 
0f05					;ld   
0f05			 
0f05 c9					ret 
0f06			 
0f06			 
0f06			; strcpy hl = dest, de source 
0f06			 
0f06 1a			strcpy:   LD   A, (DE)        ;Get character from string 
0f07 b7			            OR   A              ;Null terminator? 
0f08 c8			            RET  Z              ;Yes, so finished 
0f09 1a					ld a,(de) 
0f0a 77					ld (hl),a 
0f0b 13			            INC  DE             ;Point to next character 
0f0c 23					inc hl 
0f0d 18 f7		            JR   strcpy       ;Repeat 
0f0f c9					ret 
0f10			 
0f10			 
0f10			; TODO string_at  
0f10			; pass string which starts with lcd offset address and then null term string 
0f10			 
0f10			; TODO string to dec 
0f10			; TODO string to hex 
0f10			; TODO byte to string hex 
0f10			; TODO byte to string dec 
0f10			 
0f10			 
0f10			 
0f10			; from z80uartmonitor 
0f10			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0f10			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
0f10			; pass hl for where to put the text 
0f10			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0f10 c5			hexout:	PUSH BC 
0f11 f5					PUSH AF 
0f12 47					LD B, A 
0f13					; Upper nybble 
0f13 cb 3f				SRL A 
0f15 cb 3f				SRL A 
0f17 cb 3f				SRL A 
0f19 cb 3f				SRL A 
0f1b cd 2b 0f				CALL tohex 
0f1e 77					ld (hl),a 
0f1f 23					inc hl	 
0f20					 
0f20					; Lower nybble 
0f20 78					LD A, B 
0f21 e6 0f				AND 0FH 
0f23 cd 2b 0f				CALL tohex 
0f26 77					ld (hl),a 
0f27 23					inc hl	 
0f28					 
0f28 f1					POP AF 
0f29 c1					POP BC 
0f2a c9					RET 
0f2b					 
0f2b			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0f2b			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
0f2b			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0f2b			tohex: 
0f2b e5					PUSH HL 
0f2c d5					PUSH DE 
0f2d 16 00				LD D, 0 
0f2f 5f					LD E, A 
0f30 21 38 0f				LD HL, .DATA 
0f33 19					ADD HL, DE 
0f34 7e					LD A, (HL) 
0f35 d1					POP DE 
0f36 e1					POP HL 
0f37 c9					RET 
0f38			 
0f38			.DATA: 
0f38 30					DEFB	30h	; 0 
0f39 31					DEFB	31h	; 1 
0f3a 32					DEFB	32h	; 2 
0f3b 33					DEFB	33h	; 3 
0f3c 34					DEFB	34h	; 4 
0f3d 35					DEFB	35h	; 5 
0f3e 36					DEFB	36h	; 6 
0f3f 37					DEFB	37h	; 7 
0f40 38					DEFB	38h	; 8 
0f41 39					DEFB	39h	; 9 
0f42 41					DEFB	41h	; A 
0f43 42					DEFB	42h	; B 
0f44 43					DEFB	43h	; C 
0f45 44					DEFB	44h	; D 
0f46 45					DEFB	45h	; E 
0f47 46					DEFB	46h	; F 
0f48			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0f48			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
0f48			;;    subtract $30, if result > 9 then subtract $7 more 
0f48			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0f48			atohex: 
0f48 d6 30				SUB $30 
0f4a fe 0a				CP 10 
0f4c f8					RET M		; If result negative it was 0-9 so we're done 
0f4d d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
0f4f c9					RET		 
0f50			 
0f50			 
0f50			 
0f50			 
0f50			; Get 2 ASCII characters as hex byte from pointer in hl 
0f50			 
0f50			BYTERD: 
0f50 16 00			LD	D,00h		;Set up 
0f52 cd 5a 0f			CALL	HEXCON		;Get byte and convert to hex 
0f55 87				ADD	A,A		;First nibble so 
0f56 87				ADD	A,A		;multiply by 16 
0f57 87				ADD	A,A		; 
0f58 87				ADD	A,A		; 
0f59 57				LD	D,A		;Save hi nibble in D 
0f5a			HEXCON: 
0f5a 7e				ld a, (hl)		;Get next chr 
0f5b 23				inc hl 
0f5c d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
0f5e fe 0a			CP	00Ah		;Is it 0-9 ? 
0f60 38 02			JR	C,NALPHA	;If so miss next bit 
0f62 d6 07			SUB	007h		;Else convert alpha 
0f64			NALPHA: 
0f64 b2				OR	D		;Add hi nibble back 
0f65 c9				RET			; 
0f66			 
0f66			 
0f66			; 
0f66			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
0f66			; Since the routines get_byte and therefore get_nibble are called, only valid 
0f66			; characters (0-9a-f) are accepted. 
0f66			; 
0f66			;get_word        push    af 
0f66			;                call    get_byte        ; Get the upper byte 
0f66			;                ld      h, a 
0f66			;                call    get_byte        ; Get the lower byte 
0f66			;                ld      l, a 
0f66			;                pop     af 
0f66			;                ret 
0f66			; 
0f66			; Get a byte in hexadecimal notation. The result is returned in A. Since 
0f66			; the routine get_nibble is used only valid characters are accepted - the  
0f66			; input routine only accepts characters 0-9a-f. 
0f66			; 
0f66 c5			get_byte:        push    bc              ; Save contents of B (and C) 
0f67 7e					ld a,(hl) 
0f68 23					inc hl 
0f69 cd 8e 0f		                call    nibble2val      ; Get upper nibble 
0f6c cb 07		                rlc     a 
0f6e cb 07		                rlc     a 
0f70 cb 07		                rlc     a 
0f72 cb 07		                rlc     a 
0f74 47			                ld      b, a            ; Save upper four bits 
0f75 7e					ld a,(hl) 
0f76 cd 8e 0f		                call    nibble2val      ; Get lower nibble 
0f79 b0			                or      b               ; Combine both nibbles 
0f7a c1			                pop     bc              ; Restore B (and C) 
0f7b c9			                ret 
0f7c			; 
0f7c			; Get a hexadecimal digit from the serial line. This routine blocks until 
0f7c			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
0f7c			; to the serial line interface. The lower 4 bits of A contain the value of  
0f7c			; that particular digit. 
0f7c			; 
0f7c			;get_nibble      ld a,(hl)           ; Read a character 
0f7c			;                call    to_upper        ; Convert to upper case 
0f7c			;                call    is_hex          ; Was it a hex digit? 
0f7c			;                jr      nc, get_nibble  ; No, get another character 
0f7c			 ;               call    nibble2val      ; Convert nibble to value 
0f7c			 ;               call    print_nibble 
0f7c			 ;               ret 
0f7c			; 
0f7c			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
0f7c			; A valid hexadecimal digit is denoted by a set C flag. 
0f7c			; 
0f7c			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
0f7c			;                ret     nc              ; Yes 
0f7c			;                cp      '0'             ; Less than '0'? 
0f7c			;                jr      nc, is_hex_1    ; No, continue 
0f7c			;                ccf                     ; Complement carry (i.e. clear it) 
0f7c			;                ret 
0f7c			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
0f7c			;                ret     c               ; Yes 
0f7c			;                cp      'A'             ; Less than 'A'? 
0f7c			;                jr      nc, is_hex_2    ; No, continue 
0f7c			;                ccf                     ; Yes - clear carry and return 
0f7c			;                ret 
0f7c			;is_hex_2        scf                     ; Set carry 
0f7c			;                ret 
0f7c			; 
0f7c			; Convert a single character contained in A to upper case: 
0f7c			; 
0f7c fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
0f7e d8			                ret     c 
0f7f fe 7b		                cp      'z' + 1         ; > 'z'? 
0f81 d0			                ret     nc              ; Nothing to do, either 
0f82 e6 5f		                and     $5f             ; Convert to upper case 
0f84 c9			                ret 
0f85			 
0f85			 
0f85			to_lower: 
0f85			 
0f85			   ; if char is in [A-Z] make it lower case 
0f85			 
0f85			   ; enter : a = char 
0f85			   ; exit  : a = lower case char 
0f85			   ; uses  : af 
0f85			 
0f85 fe 41		   cp 'A' 
0f87 d8			   ret c 
0f88			    
0f88 fe 5b		   cp 'Z'+1 
0f8a d0			   ret nc 
0f8b			    
0f8b f6 20		   or $20 
0f8d c9			   ret 
0f8e			 
0f8e			; 
0f8e			; Expects a hexadecimal digit (upper case!) in A and returns the 
0f8e			; corresponding value in A. 
0f8e			; 
0f8e fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
0f90 38 02		                jr      c, nibble2val_1 ; Yes 
0f92 d6 07		                sub     7               ; Adjust for A-F 
0f94 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
0f96 e6 0f		                and     $f              ; Only return lower 4 bits 
0f98 c9			                ret 
0f99			; 
0f99			; Print_nibble prints a single hex nibble which is contained in the lower  
0f99			; four bits of A: 
0f99			; 
0f99			;print_nibble    push    af              ; We won't destroy the contents of A 
0f99			;                and     $f              ; Just in case... 
0f99			;                add     a, '0'             ; If we have a digit we are done here. 
0f99			;                cp      '9' + 1         ; Is the result > 9? 
0f99			;                jr      c, print_nibble_1 
0f99			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
0f99			;print_nibble_1  call    putc            ; Print the nibble and 
0f99			;                pop     af              ; restore the original value of A 
0f99			;                ret 
0f99			;; 
0f99			;; Send a CR/LF pair: 
0f99			; 
0f99			;crlf            push    af 
0f99			;                ld      a, cr 
0f99			;                call    putc 
0f99			;                ld      a, lf 
0f99			;                call    putc 
0f99			;                pop     af 
0f99			;                ret 
0f99			; 
0f99			; Print_word prints the four hex digits of a word to the serial line. The  
0f99			; word is expected to be in HL. 
0f99			; 
0f99			;print_word      push    hl 
0f99			;                push    af 
0f99			;                ld      a, h 
0f99			;                call    print_byte 
0f99			;                ld      a, l 
0f99			;                call    print_byte 
0f99			;                pop     af 
0f99			;                pop     hl 
0f99			;                ret 
0f99			; 
0f99			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
0f99			; The byte to be printed is expected to be in A. 
0f99			; 
0f99			;print_byte      push    af              ; Save the contents of the registers 
0f99			;                push    bc 
0f99			;                ld      b, a 
0f99			;                rrca 
0f99			;                rrca 
0f99			;                rrca 
0f99			;                rrca 
0f99			;                call    print_nibble    ; Print high nibble 
0f99			;                ld      a, b 
0f99			;                call    print_nibble    ; Print low nibble 
0f99			;                pop     bc              ; Restore original register contents 
0f99			;                pop     af 
0f99			;                ret 
0f99			 
0f99			 
0f99			 
0f99			 
0f99			 
0f99			fourehexhl:  
0f99 7e				ld a,(hl) 
0f9a cd 48 0f			call atohex 
0f9d cb 3f				SRL A 
0f9f cb 3f				SRL A 
0fa1 cb 3f				SRL A 
0fa3 cb 3f				SRL A 
0fa5 47				ld b, a 
0fa6 23				inc hl 
0fa7 7e				ld a,(hl) 
0fa8 23				inc hl 
0fa9 cd 48 0f			call atohex 
0fac 80				add b 
0fad 57				ld d,a 
0fae 7e				ld a,(hl) 
0faf cd 48 0f			call atohex 
0fb2 cb 3f				SRL A 
0fb4 cb 3f				SRL A 
0fb6 cb 3f				SRL A 
0fb8 cb 3f				SRL A 
0fba 47				ld b, a 
0fbb 23				inc hl 
0fbc 7e				ld a,(hl) 
0fbd 23				inc hl 
0fbe cd 48 0f			call atohex 
0fc1 80				add b 
0fc2 5f				ld e, a 
0fc3 d5				push de 
0fc4 e1				pop hl 
0fc5 c9				ret 
0fc6			 
0fc6			; pass hl. returns z set if the byte at hl is a digit 
0fc6			;isdigithl:  
0fc6			;	push bc 
0fc6			;	ld a,(hl) 
0fc6			;	cp ':' 
0fc6			;	jr nc, .isdf 		; > 
0fc6			;	cp '0' 
0fc6			;	jr c, .isdf		; < 
0fc6			; 
0fc6			;	; TODO find a better way to set z 
0fc6			; 
0fc6			;	ld b,a 
0fc6			;	cp b 
0fc6			;	pop bc 
0fc6			;	ret 
0fc6			; 
0fc6			;.isdf:	; not digit so clear z 
0fc6			; 
0fc6			;	; TODO find a better way to unset z 
0fc6			; 
0fc6			;	ld b,a 
0fc6			;	inc b 
0fc6			;	cp b 
0fc6			; 
0fc6			;	pop bc 
0fc6			;	ret 
0fc6				 
0fc6				 
0fc6			 
0fc6			 
0fc6			; pass hl as the four byte address to load 
0fc6			 
0fc6			get_word_hl:  
0fc6 e5				push hl 
0fc7 cd 66 0f			call get_byte 
0fca				 
0fca 47				ld b, a 
0fcb			 
0fcb e1				pop hl 
0fcc 23				inc hl 
0fcd 23				inc hl 
0fce			 
0fce			; TODO not able to handle a-f  
0fce 7e				ld a,(hl) 
0fcf			;	;cp ':' 
0fcf			;	cp 'g' 
0fcf			;	jr nc, .single_byte_hl 		; > 
0fcf			;	cp 'G' 
0fcf			;	jr nc, .single_byte_hl 		; > 
0fcf			;	cp '0' 
0fcf			;	jr c, .single_byte_hl		; < 
0fcf			 
0fcf				;call isdigithl 
0fcf fe 00			cp 0 
0fd1 28 06			jr z, .single_byte_hl 
0fd3			 
0fd3			.getwhln:   ; hex word so get next byte 
0fd3			 
0fd3 cd 66 0f			call get_byte 
0fd6 6f				ld l, a 
0fd7 60				ld h,b 
0fd8 c9				ret 
0fd9 68			.single_byte_hl:   ld l,b 
0fda 26 00				ld h,0 
0fdc c9					ret 
0fdd			 
0fdd			 
0fdd			 
0fdd			 
0fdd 21 84 16			ld hl,asc+1 
0fe0			;	ld a, (hl) 
0fe0			;	call nibble2val 
0fe0 cd 66 0f			call get_byte 
0fe3			 
0fe3			;	call fourehexhl 
0fe3 32 ec ef			ld (scratch+52),a 
0fe6				 
0fe6 21 ea ef			ld hl,scratch+50 
0fe9 22 db f2			ld (os_cur_ptr),hl 
0fec			 
0fec c9				ret 
0fed			 
0fed			 
0fed			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
0fed			 
0fed			; Decimal Unsigned Version 
0fed			 
0fed			;Number in a to decimal ASCII 
0fed			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
0fed			;Example: display a=56 as "056" 
0fed			;input: a = number 
0fed			;Output: a=0,value of a in the screen 
0fed			;destroys af,bc (don't know about hl and de) 
0fed			DispAToASCII: 
0fed 0e 9c			ld	c,-100 
0fef cd f9 0f			call	.Na1 
0ff2 0e f6			ld	c,-10 
0ff4 cd f9 0f			call	.Na1 
0ff7 0e ff			ld	c,-1 
0ff9 06 2f		.Na1:	ld	b,'0'-1 
0ffb 04			.Na2:	inc	b 
0ffc 81				add	a,c 
0ffd 38 fc			jr	c,.Na2 
0fff 91				sub	c		;works as add 100/10/1 
1000 f5				push af		;safer than ld c,a 
1001 78				ld	a,b		;char is in b 
1002			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
1002 f1				pop af		;safer than ld a,c 
1003 c9				ret 
1004			 
1004			; Decimal Signed Version 
1004			 
1004			; DispA 
1004			; -------------------------------------------------------------- 
1004			; Converts a signed integer value to a zero-terminated ASCII 
1004			; string representative of that value (using radix 10). 
1004			; -------------------------------------------------------------- 
1004			; INPUTS: 
1004			;     HL     Value to convert (two's complement integer). 
1004			;     DE     Base address of string destination. (pointer). 
1004			; -------------------------------------------------------------- 
1004			; OUTPUTS: 
1004			;     None 
1004			; -------------------------------------------------------------- 
1004			; REGISTERS/MEMORY DESTROYED 
1004			; AF HL 
1004			; -------------------------------------------------------------- 
1004			 
1004			;DispHLToASCII: 
1004			;   push    de 
1004			;   push    bc 
1004			; 
1004			;; Detect sign of HL. 
1004			;    bit    7, h 
1004			;    jr     z, ._DoConvert 
1004			; 
1004			;; HL is negative. Output '-' to string and negate HL. 
1004			;    ld     a, '-' 
1004			;    ld     (de), a 
1004			;    inc    de 
1004			; 
1004			;; Negate HL (using two's complement) 
1004			;    xor    a 
1004			;    sub    l 
1004			;    ld     l, a 
1004			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
1004			;    sbc    a, h 
1004			;    ld     h, a 
1004			; 
1004			;; Convert HL to digit characters 
1004			;._DoConvert: 
1004			;    ld     b, 0     ; B will count character length of number 
1004			;-   ld     a, 10 
1004			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
1004			;    push   af 
1004			;    inc    b 
1004			;    ld     a, h 
1004			;    or     l 
1004			;    jr     nz, - 
1004			; 
1004			;; Retrieve digits from stack 
1004			;-   pop    af 
1004			;    or     $30 
1004			;    ld     (de), a 
1004			;    inc    de 
1004			;    djnz   - 
1004			; 
1004			;; Terminate string with NULL 
1004			;    xor    a 
1004			;    ld     (de), a 
1004			; 
1004			;    pop    bc 
1004			;    pop    de 
1004			;    ret 
1004			 
1004			;Comments 
1004			; 
1004			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
1004			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
1004			;    Note that the output string will not be fixed-width. 
1004			; 
1004			;Example Usage 
1004			; 
1004			;    ld    hl, -1004 
1004			;    ld    de, OP1 
1004			;    call  DispA 
1004			;    ld    hl, OP1 
1004			;    syscall  PutS 
1004			 
1004			 
1004			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
1004			 
1004			 
1004			;Converts an ASCII string to an unsigned 16-bit integer 
1004			;Quits when it reaches a non-decimal digit 
1004			 
1004			string_to_uint16: 
1004			atoui_16: 
1004			;Input: 
1004			;     DE points to the string 
1004			;Outputs: 
1004			;     HL is the result 
1004			;     A is the 8-bit value of the number 
1004			;     DE points to the byte after the number 
1004			;Destroys: 
1004			;     BC 
1004			;       if the string is non-empty, BC is HL/10 
1004			;Size:  24 bytes 
1004			;Speed: 42+d(104+{0,9}) 
1004			;       d is the number of digits in the number 
1004			;       max is 640 cycles for a 5 digit number 
1004			;Assuming no leading zeros: 
1004			;1 digit:  146cc 
1004			;2 digit:  250cc 
1004			;3 digit:  354cc or 363cc (avg: 354.126cc) 
1004			;4 digit:  458cc or 467cc (avg: 458.27cc) 
1004			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
1004			;avg: 544.81158447265625cc (544+13297/16384) 
1004			;=============================================================== 
1004 21 00 00		  ld hl,0 
1007			.u16a: 
1007 1a			  ld a,(de) 
1008 d6 30		  sub 30h 
100a fe 0a		  cp 10 
100c d0			  ret nc 
100d 13			  inc de 
100e 44			  ld b,h 
100f 4d			  ld c,l 
1010 29			  add hl,hl 
1011 29			  add hl,hl 
1012 09			  add hl,bc 
1013 29			  add hl,hl 
1014 85			  add a,l 
1015 6f			  ld l,a 
1016 30 ef		  jr nc,.u16a 
1018 24			  inc h 
1019 c3 07 10		  jp .u16a 
101c			 
101c			 
101c			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
101c			 
101c			;written by Zeda 
101c			;Converts a 16-bit unsigned integer to an ASCII string. 
101c			 
101c			uitoa_16: 
101c			;Input: 
101c			;   DE is the number to convert 
101c			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
101c			;Output: 
101c			;   HL points to the null-terminated ASCII string 
101c			;      NOTE: This isn't necessarily the same as the input HL. 
101c d5			  push de 
101d c5			  push bc 
101e f5			  push af 
101f eb			  ex de,hl 
1020			 
1020 01 f0 d8		  ld bc,-10000 
1023 3e 2f		  ld a,'0'-1 
1025 3c			  inc a 
1026 09			  add hl,bc  
1027 38 fc		   jr c,$-2 
1029 12			  ld (de),a 
102a 13			  inc de 
102b			 
102b 01 e8 03		  ld bc,1000 
102e 3e 3a		  ld a,'9'+1 
1030 3d			  dec a  
1031 09			  add hl,bc  
1032 30 fc		   jr nc,$-2 
1034 12			  ld (de),a 
1035 13			  inc de 
1036			 
1036 01 9c ff		  ld bc,-100 
1039 3e 2f		  ld a,'0'-1 
103b 3c			  inc a  
103c 09			  add hl,bc  
103d 38 fc		   jr c,$-2 
103f 12			  ld (de),a 
1040 13			  inc de 
1041			 
1041 7d			  ld a,l 
1042 26 3a		  ld h,'9'+1 
1044 25			  dec h  
1045 c6 0a		  add a,10  
1047 30 fb		   jr nc,$-3 
1049 c6 30		  add a,'0' 
104b eb			  ex de,hl 
104c 72			  ld (hl),d 
104d 23			  inc hl 
104e 77			  ld (hl),a 
104f 23			  inc hl 
1050 36 00		  ld (hl),0 
1052			 
1052			;Now strip the leading zeros 
1052 0e fa		  ld c,-6 
1054 09			  add hl,bc 
1055 3e 30		  ld a,'0' 
1057 23			  inc hl  
1058 be			  cp (hl)  
1059 28 fc		  jr z,$-2 
105b			 
105b			;Make sure that the string is non-empty! 
105b 7e			  ld a,(hl) 
105c b7			  or a 
105d 20 01		  jr nz,.atoub 
105f 2b			  dec hl 
1060			.atoub: 
1060			 
1060 f1			  pop af 
1061 c1			  pop bc 
1062 d1			  pop de 
1063 c9			  ret 
1064			 
1064			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
1064			 
1064			toUpper: 
1064			;A is the char. 
1064			;If A is a lowercase letter, this sets it to the matching uppercase 
1064			;18cc or 30cc or 41cc 
1064			;avg: 26.75cc 
1064 fe 61		  cp 'a' 
1066 d8			  ret c 
1067 fe 7b		  cp 'z'+1 
1069 d0			  ret nc 
106a d6 20		  sub 'a'-'A' 
106c c9			  ret 
106d			 
106d			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
106d			 
106d			; String Length 
106d			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
106d			 
106d			; Get the length of the null-terminated string starting at $8000 hl 
106d			;    LD     HL, $8000 
106d			 
106d			strlenz: 
106d			 
106d af			    XOR    A               ; Zero is the value we are looking for. 
106e 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
106f 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1070			                           ; 65, 536 bytes (the entire addressable memory space). 
1070 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1072			 
1072			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1072 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
1073 6f			    LD     L, A             ; number of bytes 
1074 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1076 2b			    DEC    HL              ; Compensate for null. 
1077 c9				ret 
1078			 
1078			; Get the length of the A terminated string starting at $8000 hl 
1078			;    LD     HL, $8000 
1078			 
1078			strlent: 
1078			 
1078			                  ; A is the value we are looking for. 
1078 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
107a 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
107c			                           ; 65, 536 bytes (the entire addressable memory space). 
107c ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
107e			 
107e			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
107e 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1080 2e 00		    LD     L, 0             ; number of bytes 
1082 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1084 2b			    DEC    HL              ; Compensate for null. 
1085 c9				ret 
1086			 
1086			 
1086			;Comparing Strings 
1086			 
1086			;IN    HL     Address of string1. 
1086			;      DE     Address of string2. 
1086			 
1086			; doc given but wrong??? 
1086			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
1086			;      carry  Set if string1 > string2, reset if string1 <= string2. 
1086			; tested 
1086			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
1086			 
1086			strcmp_old: 
1086 e5			    PUSH   HL 
1087 d5			    PUSH   DE 
1088			 
1088 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1089 be			    CP     (HL)            ; (want to minimize work). 
108a 38 01		    JR     C, Str1IsBigger 
108c 7e			    LD     A, (HL) 
108d			 
108d			Str1IsBigger: 
108d 4f			    LD     C, A             ; Put length in BC 
108e 06 00		    LD     B, 0 
1090 13			    INC    DE              ; Increment pointers to meat of string. 
1091 23			    INC    HL 
1092			 
1092			CmpLoop: 
1092 1a			    LD     A, (DE)          ; Compare bytes. 
1093 ed a1		    CPI 
1095 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
1097 13			    INC    DE              ; Update pointer. 
1098 ea 92 10		    JP     PE, CmpLoop 
109b			 
109b d1			    POP    DE 
109c e1			    POP    HL 
109d 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
109e be			    CP     (HL) 
109f c9			    RET 
10a0			 
10a0			NoMatch: 
10a0 2b			    DEC    HL 
10a1 be			    CP     (HL)            ; Compare again to affect carry. 
10a2 d1			    POP    DE 
10a3 e1			    POP    HL 
10a4 c9			    RET 
10a5			 
10a5			;; test strmp 
10a5			; 
10a5			;ld de, .str1 
10a5			;ld hl, .str2 
10a5			;call strcmp 
10a5			;jr z, .z1 
10a5			;;this 
10a5			;	if DEBUG_FORTH_WORDS 
10a5			;		DMARK "NZ1" 
10a5			;		CALLMONITOR 
10a5			;	endif 
10a5			;.z1: 
10a5			; 
10a5			;	if DEBUG_FORTH_WORDS 
10a5			;		DMARK "ZZ1" 
10a5			;		CALLMONITOR 
10a5			;	endif 
10a5			; 
10a5			;ld de, .str1 
10a5			;ld hl, .str1 
10a5			;call strcmp 
10a5			;jr z, .z2 
10a5			;;this 
10a5			;	if DEBUG_FORTH_WORDS 
10a5			;		DMARK "NZ2" 
10a5			;		CALLMONITOR 
10a5			;	endif 
10a5			;.z2: 
10a5			; 
10a5			;	if DEBUG_FORTH_WORDS 
10a5			;		DMARK "ZZ2" 
10a5			;		CALLMONITOR 
10a5			;	endif 
10a5			; 
10a5			;ld de, .str1 
10a5			;ld hl, .str2 
10a5			;call strcmp 
10a5			;jr c, .c1 
10a5			; 
10a5			;	if DEBUG_FORTH_WORDS 
10a5			;		DMARK "Nc1" 
10a5			;		CALLMONITOR 
10a5			;	endif 
10a5			;.c1: 
10a5			;;this 
10a5			;	if DEBUG_FORTH_WORDS 
10a5			;		DMARK "cc1" 
10a5			;		CALLMONITOR 
10a5			;	endif 
10a5			; 
10a5			;ld de, .str1 
10a5			;ld hl, .str1 
10a5			;call strcmp 
10a5			;jr c, .c2 
10a5			;;this 
10a5			;	if DEBUG_FORTH_WORDS 
10a5			;		DMARK "Nc2" 
10a5			;		CALLMONITOR 
10a5			;	endif 
10a5			;.c2: 
10a5			; 
10a5			;	if DEBUG_FORTH_WORDS 
10a5			;		DMARK "cc2" 
10a5			;		CALLMONITOR 
10a5			;	endif 
10a5			;	NEXTW 
10a5			;.str1:   db "string1",0 
10a5			;.str2:   db "string2",0 
10a5			 
10a5			; only care about direct match or not 
10a5			; hl and de strings 
10a5			; zero set if the same 
10a5			 
10a5			strcmp: 
10a5 1a				ld a, (de) 
10a6 be				cp (hl) 
10a7 28 02			jr z, .ssame 
10a9 b7				or a 
10aa c9				ret 
10ab			 
10ab			.ssame:  
10ab fe 00			cp 0 
10ad c8				ret z 
10ae			 
10ae 23				inc hl 
10af 13				inc de 
10b0 18 f3			jr strcmp 
10b2				 
10b2				 
10b2			 
10b2			 
10b2			 
10b2			 
10b2			; eof 
10b2			 
10b2			 
10b2			 
10b2			 
10b2			 
10b2			 
# End of file firmware_strings.asm
10b2			include "firmware_memory.asm"   ; malloc and free  
10b2			 
10b2			if DEBUG_FORTH_MALLOC_HIGH 
10b2			.mallocsize: db "Wants malloc >256",0 
10b2			.mallocasize: db "MALLOC gives >256",0 
10b2			.malloczero: db "MALLOC gives zero",0 
10b2			 
10b2			malloc_guard_zerolen: 
10b2				push hl 
10b2				push de 
10b2				push af 
10b2			 
10b2				ld de, 0 
10b2			        call cmp16 
10b2				jr nz, .lowalloz 
10b2			 
10b2				push hl 
10b2				push de 
10b2					ld hl, display_fb0 
10b2					ld (display_fb_active), hl 
10b2				call clear_display 
10b2				ld a, 0 
10b2				ld de, .malloczero 
10b2				call str_at_display 
10b2				call update_display 
10b2				call delay1s 
10b2				call delay1s 
10b2				ld a, 0 
10b2				ld (os_view_disable), a 
10b2			 
10b2				pop de 
10b2				pop hl 
10b2			 
10b2				 
10b2			 
10b2				CALLMONITOR 
10b2			.lowalloz: 
10b2			 
10b2			 
10b2				pop af 
10b2				pop de 
10b2				pop hl 
10b2			ret 
10b2			 
10b2			malloc_guard_entry: 
10b2				push hl 
10b2				push de 
10b2				push af 
10b2			 
10b2			 	or a      ;clear carry flag 
10b2				push hl 
10b2				ld de, 255 
10b2				sbc hl, de 
10b2				jr c, .lowalloc 
10b2			 
10b2				push de 
10b2					ld hl, display_fb0 
10b2					ld (display_fb_active), hl 
10b2				call clear_display 
10b2				ld a, 0 
10b2				ld de, .mallocsize 
10b2				call str_at_display 
10b2				call update_display 
10b2				call delay1s 
10b2				call delay1s 
10b2				ld a, 0 
10b2				ld (os_view_disable), a 
10b2			 
10b2				pop de 
10b2				pop hl 
10b2			 
10b2				 
10b2			 
10b2				CALLMONITOR 
10b2				jr .lowdone 
10b2			.lowalloc: 
10b2			 
10b2			 
10b2				pop hl 
10b2			.lowdone:	pop af 
10b2				pop de 
10b2				pop hl 
10b2			ret 
10b2			 
10b2			malloc_guard_exit: 
10b2				push hl 
10b2				push de 
10b2				push af 
10b2			 
10b2			 	or a      ;clear carry flag 
10b2				push hl 
10b2				ld de, 255 
10b2				sbc hl, de 
10b2				jr c, .lowallocx 
10b2			 
10b2				push de 
10b2					ld hl, display_fb0 
10b2					ld (display_fb_active), hl 
10b2				call clear_display 
10b2				ld a, 0 
10b2				ld de, .mallocasize 
10b2				call str_at_display 
10b2				call update_display 
10b2				call delay1s 
10b2				call delay1s 
10b2				ld a, 0 
10b2				ld (os_view_disable), a 
10b2				pop de 
10b2				pop hl 
10b2			 
10b2				CALLMONITOR 
10b2				jr .lowdonex 
10b2			.lowallocx: 
10b2			 
10b2				pop hl 
10b2			.lowdonex:	pop af 
10b2				pop de 
10b2				pop hl 
10b2			ret 
10b2			endif 
10b2			 
10b2			if MALLOC_2 
10b2			; Z80 Malloc and Free Functions 
10b2			 
10b2			; Malloc Function: 
10b2			; Input: 
10b2			;   HL: Size of block to allocate 
10b2			; Output: 
10b2			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
10b2			 
10b2			malloc: 
10b2				 
10b2			if DEBUG_FORTH_MALLOC_HIGH 
10b2			call malloc_guard_entry 
10b2			endif 
10b2			 
10b2			 
10b2			 
10b2			 
10b2					if DEBUG_FORTH_MALLOC 
10b2						DMARK "mal" 
10b2						CALLMONITOR 
10b2					endif 
10b2			    push af            ; Save AF register 
10b2			    ld a, l            ; Load low byte of size into A 
10b2			    or h               ; Check if size is zero 
10b2			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
10b2			 
10b2			    ; Allocate memory 
10b2			    ld hl, (heap_start) ; Load start of heap into HL 
10b2					if DEBUG_FORTH_MALLOC 
10b2						DMARK "ma1" 
10b2						CALLMONITOR 
10b2					endif 
10b2			    call malloc_internal ; Call internal malloc function 
10b2			    pop af             ; Restore AF register 
10b2			if DEBUG_FORTH_MALLOC_HIGH 
10b2			call malloc_guard_exit 
10b2			call malloc_guard_zerolen 
10b2			endif 
10b2			    ret                ; Return 
10b2			 
10b2			; Free Function: 
10b2			; Input: 
10b2			;   HL: Pointer to memory block to free 
10b2			; Output: 
10b2			;   None 
10b2			 
10b2			free: 
10b2			    push af            ; Save AF register 
10b2			    ld a, l            ; Load low byte of pointer into A 
10b2			    or h               ; Check if pointer is NULL 
10b2			    jp z, free_exit    ; If pointer is NULL, exit 
10b2			 
10b2			    ; Free memory 
10b2			    ld hl, (heap_start) ; Load start of heap into HL 
10b2			    call free_internal  ; Call internal free function 
10b2			    pop af             ; Restore AF register 
10b2			    ret                ; Return 
10b2			 
10b2			; Internal Malloc Function: 
10b2			; Input: 
10b2			;   HL: Size of block to allocate 
10b2			; Output: 
10b2			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
10b2			 
10b2			malloc_internal: 
10b2			    ld bc, 2           ; Number of bytes to allocate for management overhead 
10b2			    add hl, bc         ; Add management overhead to requested size 
10b2			    ex de, hl          ; Save total size in DE, and keep it in HL 
10b2					if DEBUG_FORTH_MALLOC 
10b2						DMARK "ma2" 
10b2						CALLMONITOR 
10b2					endif 
10b2			 
10b2			    ; Search for free memory block 
10b2			    ld de, (heap_end)  ; Load end of heap into DE 
10b2			    ld bc, 0           ; Initialize counter 
10b2			 
10b2					if DEBUG_FORTH_MALLOC 
10b2						DMARK "ma2" 
10b2						CALLMONITOR 
10b2					endif 
10b2			malloc_search_loop: 
10b2			    ; Check if current block is free 
10b2			    ld a, (hl)         ; Load current block's status (free or used) 
10b2			    cp 0               ; Compare with zero (free) 
10b2			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
10b2			 
10b2			    ; Check if current block is large enough 
10b2			    ld a, (hl+1)       ; Load high byte of block size 
10b2			    cp l               ; Compare with low byte of requested size 
10b2			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
10b2			 
10b2			    ld a, (hl+2)       ; Load low byte of block size 
10b2			    cp h               ; Compare with high byte of requested size 
10b2			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
10b2			 
10b2			    ; Mark block as used 
10b2			    ld (hl), 0xFF      ; Set status byte to indicate used block 
10b2			 
10b2			    ; Calculate remaining space in block 
10b2			    ld bc, 0           ; Clear BC 
10b2			    add hl, bc         ; Increment HL to point to start of data block 
10b2			    add hl, de         ; HL = HL + DE (total size) 
10b2			    ld bc, 1           ; Number of bytes to allocate for management overhead 
10b2			    add hl, bc         ; Add management overhead to start of data block 
10b2			 
10b2			    ; Save pointer to allocated block in HL 
10b2			if DEBUG_FORTH_MALLOC_HIGH 
10b2						DMARK "ma5" 
10b2			call malloc_guard_exit 
10b2			call malloc_guard_zerolen 
10b2			endif 
10b2			    ret 
10b2			 
10b2			malloc_skip_block_check: 
10b2			    ; Move to the next block 
10b2			    ld bc, 3           ; Size of management overhead 
10b2			    add hl, bc         ; Move to the next block 
10b2			    inc de             ; Increment counter 
10b2			 
10b2			    ; Check if we have reached the end of heap 
10b2			    ld a, e            ; Load low byte of heap end address 
10b2			    cp (hl)            ; Compare with low byte of current address 
10b2			    jr nz, malloc_search_loop  ; If not equal, continue searching 
10b2			    ld a, d            ; Load high byte of heap end address 
10b2			    cp 0               ; Check if it's zero (end of memory) 
10b2			    jr nz, malloc_search_loop  ; If not zero, continue searching 
10b2			 
10b2			    ; If we reached here, allocation failed 
10b2			    xor a              ; Set result to NULL 
10b2			if DEBUG_FORTH_MALLOC_HIGH 
10b2						DMARK "ma6" 
10b2			call malloc_guard_exit 
10b2			call malloc_guard_zerolen 
10b2			endif 
10b2			    ret 
10b2			malloc_exit: 
10b2			if DEBUG_FORTH_MALLOC_HIGH 
10b2						DMARK "ma7" 
10b2			call malloc_guard_exit 
10b2			call malloc_guard_zerolen 
10b2			endif 
10b2			    ret 
10b2			 
10b2			; Internal Free Function: 
10b2			; Input: 
10b2			;   HL: Pointer to memory block to free 
10b2			; Output: 
10b2			;   None 
10b2			 
10b2			free_internal: 
10b2			    ld de, (heap_start) ; Load start of heap into DE 
10b2			    ld bc, 0            ; Initialize counter 
10b2			 
10b2			free_search_loop: 
10b2			    ; Check if current block contains the pointer 
10b2			    ld a, l             ; Load low byte of pointer 
10b2			    cp (hl+1)           ; Compare with high byte of current block's address 
10b2			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
10b2			    ld a, h             ; Load high byte of pointer 
10b2			    cp (hl+2)           ; Compare with low byte of current block's address 
10b2			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
10b2			 
10b2			    ; Mark block as free 
10b2			    ld (hl), 0          ; Set status byte to indicate free block 
10b2			    ret                 ; Return 
10b2			 
10b2			free_skip_block_check: 
10b2			    ; Move to the next block 
10b2			    ld bc, 3            ; Size of management overhead 
10b2			    add hl, bc          ; Move to the next block 
10b2			    inc de              ; Increment counter 
10b2			 
10b2			    ; Check if we have reached the end of heap 
10b2			    ld a, e             ; Load low byte of heap end address 
10b2			    cp (hl)             ; Compare with low byte of current address 
10b2			    jr nz, free_search_loop  ; If not equal, continue searching 
10b2			    ld a, d             ; Load high byte of heap end address 
10b2			    cp 0                ; Check if it's zero (end of memory) 
10b2			    jr nz, free_search_loop  ; If not zero, continue searching 
10b2			 
10b2			    ; If we reached here, pointer is not found in heap 
10b2			    ret 
10b2			 
10b2			free_exit: 
10b2			    ret                 ; Return 
10b2			 
10b2			; Define heap start and end addresses 
10b2			;heap_start:    .dw 0xC000   ; Start of heap 
10b2			;heap_end:      .dw 0xE000   ; End of heap 
10b2			 
10b2			endif 
10b2			 
10b2			 
10b2			if MALLOC_1 
10b2			 
10b2			 
10b2			 
10b2			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
10b2			 
10b2			;moved to firmware.asm 
10b2			;heap_start        .equ  0x9000      ; Starting address of heap 
10b2			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
10b2			 
10b2			;      .org 0 
10b2			;      jp    main 
10b2			 
10b2			 
10b2			;      .org  0x100 
10b2			;main: 
10b2			;      ld    HL, 0x8100 
10b2			;      ld    SP, HL 
10b2			; 
10b2			;      call  heap_init 
10b2			; 
10b2			;      ; Make some allocations 
10b2			;      ld    HL, 12 
10b2			;      call  malloc            ; Allocates 0x9004 
10b2			; 
10b2			;      ld    HL, 12 
10b2			;      call  malloc            ; Allocates 0x9014 
10b2			; 
10b2			;      ld    HL, 12 
10b2			;      call  malloc            ; Allocates 0x9024 
10b2			; 
10b2			;      ; Free some allocations 
10b2			;      ld    HL, 0x9014 
10b2			;      call  free 
10b2			; 
10b2			;      ld    HL, 0x9004 
10b2			;      call  free 
10b2			; 
10b2			;      ld    HL, 0x9024 
10b2			;      call  free 
10b2			; 
10b2			; 
10b2			;      halt 
10b2			 
10b2			 
10b2			;------------------------------------------------------------------------------ 
10b2			;     heap_init                                                               : 
10b2			;                                                                             : 
10b2			; Description                                                                 : 
10b2			;     Initialise the heap and make it ready for malloc and free operations.   : 
10b2			;                                                                             : 
10b2			;     The heap is maintained as a linked list, starting with an initial       : 
10b2			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
10b2			;     the first free block in the heap. Each block then points to the next    : 
10b2			;     free block within the heap, and the free list ends at the first block   : 
10b2			;     with a null pointer to the next free block.                             : 
10b2			;                                                                             : 
10b2			; Parameters                                                                  : 
10b2			;     Inputs are compile-time only. Two defines which specify the starting    : 
10b2			;     address of the heap and its size are required, along with a memory      : 
10b2			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
10b2			;     principally stores a pointer to the first free block in the heap.       : 
10b2			;                                                                             : 
10b2			; Returns                                                                     : 
10b2			;     Nothing                                                                 : 
10b2			;------------------------------------------------------------------------------ 
10b2			heap_init: 
10b2 e5			      push  HL 
10b3			 
10b3			      ; Initialise free list struct 
10b3 21 0e 80		      ld    HL, heap_start 
10b6 22 0a 80		      ld    (free_list), HL 
10b9 21 00 00		      ld    HL, 0 
10bc 22 0c 80		      ld    (free_list+2), HL 
10bf			 
10bf			      ; Insert first free block at bottom of heap, consumes entire heap 
10bf 21 0a 80		      ld    HL, heap_start+heap_size-4 
10c2 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
10c5 21 fc ff		      ld    HL, heap_size-4 
10c8 22 10 80		      ld    (heap_start+2), HL      ; Block size 
10cb			 
10cb			      ; Insert end of free list block at top of heap - two null words will 
10cb			      ; terminate the free list 
10cb 21 00 00		      ld    HL, 0 
10ce 22 0c 80		      ld    (heap_start+heap_size-2), HL 
10d1 22 0a 80		      ld    (heap_start+heap_size-4), HL 
10d4			 
10d4 e1			      pop   HL 
10d5			 
10d5 c9			      ret 
10d6			 
10d6			 
10d6			;------------------------------------------------------------------------------ 
10d6			;     malloc                                                                  : 
10d6			;                                                                             : 
10d6			; Description                                                                 : 
10d6			;     Allocates the wanted space from the heap and returns the address of the : 
10d6			;     first useable byte of the allocation.                                   : 
10d6			;                                                                             : 
10d6			;     Allocations can happen in one of two ways:                              : 
10d6			;                                                                             : 
10d6			;     1. A free block may be found which is the exact size wanted. In this    : 
10d6			;        case the block is removed from the free list and retuedn to the      : 
10d6			;        caller.                                                              : 
10d6			;     2. A free block may be found which is larger than the size wanted. In   : 
10d6			;        this case, the larger block is split into two. The first portion of  : 
10d6			;        this block will become the requested space by the malloc call and    : 
10d6			;        is returned to the caller. The second portion becomes a new free     : 
10d6			;        block, and the free list is adjusted to maintain continuity via this : 
10d6			;        newly created block.                                                 : 
10d6			;                                                                             : 
10d6			;     malloc does not set any initial value in the allocated space, the       : 
10d6			;     caller is required to do this as required.                              : 
10d6			;                                                                             : 
10d6			;     This implementation of malloc uses the stack exclusively, and is        : 
10d6			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
10d6			;     advisable to disable interrupts before calling malloc, and recommended  : 
10d6			;     to avoid the use of malloc inside ISRs in general.                      : 
10d6			;                                                                             : 
10d6			;     NOTE: heap_init must be called before malloc and free can be used.      : 
10d6			;                                                                             : 
10d6			; Parameters                                                                  : 
10d6			;     HL  Number of bytes wanted                                              : 
10d6			;                                                                             : 
10d6			; Returns                                                                     : 
10d6			;     HL  Address of the first useable byte of the allocation                 : 
10d6			;                                                                             : 
10d6			; Flags                                                                       : 
10d6			;     Z   Set if the allocation did not succeed, clear otherwise              : 
10d6			;                                                                             : 
10d6			; Stack frame                                                                 : 
10d6			;       |             |                                                       : 
10d6			;       +-------------+                                                       : 
10d6			;       |     BC      |                                                       : 
10d6			;       +-------------+                                                       : 
10d6			;       |     DE      |                                                       : 
10d6			;       +-------------+                                                       : 
10d6			;       |     IX      |                                                       : 
10d6			;       +-------------+                                                       : 
10d6			;       |  prev_free  |                                                       : 
10d6			;   +4  +-------------+                                                       : 
10d6			;       |  this_free  |                                                       : 
10d6			;   +2  +-------------+                                                       : 
10d6			;       |  next_free  |                                                       : 
10d6			;   +0  +-------------+                                                       : 
10d6			;       |             |                                                       : 
10d6			;                                                                             : 
10d6			;------------------------------------------------------------------------------ 
10d6			 
10d6			 
10d6			;malloc: 
10d6			; 
10d6			;	SAVESP ON 1 
10d6			; 
10d6			;	call malloc_code 
10d6			; 
10d6			;	CHECKSP ON 1 
10d6			;	ret 
10d6			 
10d6			 
10d6			malloc: 
10d6 c5			      push  BC 
10d7 d5			      push  DE 
10d8 dd e5		      push  IX 
10da			if DEBUG_FORTH_MALLOC_HIGH 
10da			call malloc_guard_entry 
10da			endif 
10da			 
10da					if DEBUG_FORTH_MALLOC 
10da						DMARK "mal" 
10da						CALLMONITOR 
10da					endif 
10da 7c			      ld    A, H                    ; Exit if no space requested 
10db b5			      or    L 
10dc ca 9b 11		      jp    Z, malloc_early_exit 
10df			 
10df			;inc hl 
10df			;inc hl 
10df			;inc hl 
10df			; 
10df			;inc hl 
10df			;inc hl 
10df			;inc hl 
10df			;inc hl 
10df			;inc hl 
10df			;inc hl 
10df			;inc hl 
10df			;inc hl 
10df			;inc hl 
10df			 
10df			 
10df			 
10df			 
10df					if DEBUG_FORTH_MALLOC 
10df						DMARK "maA" 
10df						CALLMONITOR 
10df					endif 
10df			      ; Set up stack frame 
10df eb			      ex    DE, HL 
10e0 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
10e3 39			      add   HL, SP 
10e4 f9			      ld    SP, HL 
10e5 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
10e9 dd 39		      add   IX, SP 
10eb			 
10eb			      ; Setup initial state 
10eb 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
10ee 19			      add   HL, DE 
10ef			 
10ef 44			      ld    B, H                    ; Move want to BC 
10f0 4d			      ld    C, L 
10f1			 
10f1 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
10f4 dd 75 04		      ld    (IX+4), L 
10f7 dd 74 05		      ld    (IX+5), H 
10fa			 
10fa 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
10fb 23			      inc   HL 
10fc 56			      ld    D, (HL) 
10fd dd 73 02		      ld    (IX+2), E 
1100 dd 72 03		      ld    (IX+3), D 
1103 eb			      ex    DE, HL                  ; this_free ptr into HL 
1104			 
1104					if DEBUG_FORTH_MALLOC 
1104						DMARK "maB" 
1104						CALLMONITOR 
1104					endif 
1104			      ; Loop through free block list to find some space 
1104			malloc_find_space: 
1104 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
1105 23			      inc   HL 
1106 56			      ld    D, (HL) 
1107			 
1107 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1108 b3			      or    E 
1109 ca 95 11		      jp    Z, malloc_no_space 
110c			 
110c dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
110f dd 72 01		      ld    (IX+1), D 
1112			 
1112			      ; Does this block have enough space to make the allocation? 
1112 23			      inc   HL                      ; Load free block size into DE 
1113 5e			      ld    E, (HL) 
1114 23			      inc   HL 
1115 56			      ld    D, (HL) 
1116			 
1116 eb			      ex    DE, HL                  ; Check size of block against want 
1117 b7			      or    A                       ; Ensure carry flag clear 
1118 ed 42		      sbc   HL, BC 
111a e5			      push  HL                      ; Store the result for later (new block size) 
111b			 
111b ca 6a 11		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
111e 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1120			 
1120			      ; this_free block is not big enough, setup ptrs to test next free block 
1120 e1			      pop   HL                      ; Discard previous result 
1121			 
1121 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1124 dd 66 03		      ld    H, (IX+3) 
1127 dd 75 04		      ld    (IX+4), L 
112a dd 74 05		      ld    (IX+5), H 
112d			 
112d dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1130 dd 66 01		      ld    H, (IX+1) 
1133 dd 75 02		      ld    (IX+2), L 
1136 dd 74 03		      ld    (IX+3), H 
1139			 
1139					if DEBUG_FORTH_MALLOC 
1139						DMARK "MA>" 
1139						CALLMONITOR 
1139					endif 
1139 18 c9		      jr    malloc_find_space 
113b			 
113b			      ; split a bigger block into two - requested size and remaining size 
113b			malloc_alloc_split: 
113b					if DEBUG_FORTH_MALLOC 
113b						DMARK "MAs" 
113b						CALLMONITOR 
113b					endif 
113b eb			      ex    DE, HL                  ; Calculate address of new free block 
113c 2b			      dec   HL 
113d 2b			      dec   HL 
113e 2b			      dec   HL 
113f 09			      add   HL, BC 
1140			 
1140			      ; Create a new block and point it at next_free 
1140 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
1143 dd 56 01		      ld    D, (IX+1) 
1146			 
1146 73			      ld    (HL), E                 ; Store next_free ptr into new block 
1147 23			      inc   HL 
1148 72			      ld    (HL), D 
1149			 
1149 d1			      pop   DE                      ; Store size of new block into new block 
114a 23			      inc   HL 
114b 73			      ld    (HL), E 
114c 23			      inc   HL 
114d 72			      ld    (HL), D 
114e			 
114e			      ; Update this_free ptr to point to new block 
114e 2b			      dec   HL 
114f 2b			      dec   HL 
1150 2b			      dec   HL 
1151			 
1151 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1154 dd 56 03		      ld    D, (IX+3) 
1157			 
1157 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
115a dd 74 03		      ld    (IX+3), H 
115d			 
115d			      ; Modify this_free block to be allocation 
115d eb			      ex    DE, HL 
115e af			      xor   A                       ; Null the next block ptr of allocated block 
115f 77			      ld    (HL), A 
1160 23			      inc   HL 
1161 77			      ld    (HL), A 
1162			 
1162 23			      inc   HL                      ; Store want size into allocated block 
1163 71			      ld    (HL), C 
1164 23			      inc   HL 
1165 70			      ld    (HL), B 
1166 23			      inc   HL 
1167 e5			      push  HL                      ; Address of allocation to return 
1168			 
1168 18 19		      jr    malloc_update_links 
116a			 
116a			malloc_alloc_fit: 
116a e1			      pop   HL                      ; Dont need new block size, want is exact fit 
116b			 
116b					if DEBUG_FORTH_MALLOC 
116b						DMARK "MAf" 
116b						CALLMONITOR 
116b					endif 
116b			      ; Modify this_free block to be allocation 
116b eb			      ex    DE, HL 
116c 2b			      dec   HL 
116d 2b			      dec   HL 
116e 2b			      dec   HL 
116f			 
116f af			      xor   A                       ; Null the next block ptr of allocated block 
1170 77			      ld    (HL), A 
1171 23			      inc   HL 
1172 77			      ld    (HL), A 
1173			 
1173 23			      inc   HL                      ; Store address of allocation to return 
1174 23			      inc   HL 
1175 23			      inc   HL 
1176 e5			      push  HL 
1177			 
1177			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1177 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
117a dd 66 01		      ld    H, (IX+1) 
117d			 
117d dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1180 dd 74 03		      ld    (IX+3), H 
1183			 
1183			 
1183			malloc_update_links: 
1183			      ; Update prev_free ptr to point to this_free 
1183 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1186 dd 66 05		      ld    H, (IX+5) 
1189			 
1189 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
118c dd 56 03		      ld    D, (IX+3) 
118f			 
118f 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1190 23			      inc   HL 
1191 72			      ld    (HL), D 
1192			 
1192					if DEBUG_FORTH_MALLOC 
1192						DMARK "Mul" 
1192						CALLMONITOR 
1192					endif 
1192			      ; Clear the Z flag to indicate successful allocation 
1192 7a			      ld    A, D 
1193 b3			      or    E 
1194			 
1194 d1			      pop   DE                      ; Address of allocation 
1195					if DEBUG_FORTH_MALLOC 
1195						DMARK "MAu" 
1195						CALLMONITOR 
1195					endif 
1195			 
1195			malloc_no_space: 
1195 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
1198 39			      add   HL, SP 
1199 f9			      ld    SP, HL 
119a			 
119a eb			      ex    DE, HL                  ; Alloc addr into HL for return 
119b					if DEBUG_FORTH_MALLOC 
119b						DMARK "MAN" 
119b						CALLMONITOR 
119b					endif 
119b			 
119b			malloc_early_exit: 
119b					if DEBUG_FORTH_MALLOC 
119b						DMARK "MAx" 
119b						CALLMONITOR 
119b					endif 
119b dd e1		      pop   IX 
119d d1			      pop   DE 
119e c1			      pop   BC 
119f			 
119f			if DEBUG_FORTH_MALLOC_HIGH 
119f			call malloc_guard_exit 
119f			call malloc_guard_zerolen 
119f			endif 
119f c9			      ret 
11a0			 
11a0			 
11a0			;------------------------------------------------------------------------------ 
11a0			;     free                                                                    : 
11a0			;                                                                             : 
11a0			; Description                                                                 : 
11a0			;     Return the space pointed to by HL to the heap. HL must be an address as : 
11a0			;     returned by malloc, otherwise the behaviour is undefined.               : 
11a0			;                                                                             : 
11a0			;     Where possible, directly adjacent free blocks will be merged together   : 
11a0			;     into larger blocks to help ensure that the heap does not become         : 
11a0			;     excessively fragmented.                                                 : 
11a0			;                                                                             : 
11a0			;     free does not clear or set any other value into the freed space, and    : 
11a0			;     therefore its contents may be visible through subsequent malloc's. The  : 
11a0			;     caller should clear the freed space as required.                        : 
11a0			;                                                                             : 
11a0			;     This implementation of free uses the stack exclusively, and is          : 
11a0			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
11a0			;     advisable to disable interrupts before calling free, and recommended    : 
11a0			;     to avoid the use of free inside ISRs in general.                        : 
11a0			;                                                                             : 
11a0			;     NOTE: heap_init must be called before malloc and free can be used.      : 
11a0			;                                                                             : 
11a0			; Parameters                                                                  : 
11a0			;     HL  Pointer to address of first byte of allocation to be freed          : 
11a0			;                                                                             : 
11a0			; Returns                                                                     : 
11a0			;     Nothing                                                                 : 
11a0			;                                                                             : 
11a0			; Stack frame                                                                 : 
11a0			;       |             |                                                       : 
11a0			;       +-------------+                                                       : 
11a0			;       |     BC      |                                                       : 
11a0			;       +-------------+                                                       : 
11a0			;       |     DE      |                                                       : 
11a0			;       +-------------+                                                       : 
11a0			;       |     IX      |                                                       : 
11a0			;       +-------------+                                                       : 
11a0			;       |  prev_free  |                                                       : 
11a0			;   +2  +-------------+                                                       : 
11a0			;       |  next_free  |                                                       : 
11a0			;   +0  +-------------+                                                       : 
11a0			;       |             |                                                       : 
11a0			;                                                                             : 
11a0			;------------------------------------------------------------------------------ 
11a0			free: 
11a0 c5			      push  BC 
11a1 d5			      push  DE 
11a2 dd e5		      push  IX 
11a4			 
11a4 7c			      ld    A, H                    ; Exit if ptr is null 
11a5 b5			      or    L 
11a6 ca 6a 12		      jp    Z, free_early_exit 
11a9			 
11a9			      ; Set up stack frame 
11a9 eb			      ex    DE, HL 
11aa 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
11ad 39			      add   HL, SP 
11ae f9			      ld    SP, HL 
11af dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
11b3 dd 39		      add   IX, SP 
11b5			 
11b5			      ; The address in HL points to the start of the useable allocated space, 
11b5			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
11b5			      ; address of the block itself. 
11b5 eb			      ex    DE, HL 
11b6 11 fc ff		      ld    DE, -4 
11b9 19			      add   HL, DE 
11ba			 
11ba			      ; An allocated block must have a null next block pointer in it 
11ba 7e			      ld    A, (HL) 
11bb 23			      inc   HL 
11bc b6			      or    (HL) 
11bd c2 65 12		      jp    NZ, free_done 
11c0			 
11c0 2b			      dec   HL 
11c1			 
11c1 44			      ld    B, H                    ; Copy HL to BC 
11c2 4d			      ld    C, L 
11c3			 
11c3			      ; Loop through the free list to find the first block with an address 
11c3			      ; higher than the block being freed 
11c3 21 0a 80		      ld    HL, free_list 
11c6			 
11c6			free_find_higher_block: 
11c6 5e			      ld    E, (HL)                 ; Load next ptr from free block 
11c7 23			      inc   HL 
11c8 56			      ld    D, (HL) 
11c9 2b			      dec   HL 
11ca			 
11ca dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
11cd dd 72 01		      ld    (IX+1), D 
11d0 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
11d3 dd 74 03		      ld    (IX+3), H 
11d6			 
11d6 78			      ld    A, B                    ; Check if DE is greater than BC 
11d7 ba			      cp    D                       ; Compare MSB first 
11d8 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
11da 30 04		      jr    NC, free_find_higher_block_skip 
11dc 79			      ld    A, C 
11dd bb			      cp    E                       ; Then compare LSB 
11de 38 08		      jr    C, free_found_higher_block 
11e0			 
11e0			free_find_higher_block_skip: 
11e0 7a			      ld    A, D                    ; Reached the end of the free list? 
11e1 b3			      or    E 
11e2 ca 65 12		      jp    Z, free_done 
11e5			 
11e5 eb			      ex    DE, HL 
11e6			 
11e6 18 de		      jr    free_find_higher_block 
11e8			 
11e8			free_found_higher_block: 
11e8			      ; Insert freed block between prev and next free blocks 
11e8 71			      ld    (HL), C                 ; Point prev free block to freed block 
11e9 23			      inc   HL 
11ea 70			      ld    (HL), B 
11eb			 
11eb 60			      ld    H, B                    ; Point freed block at next free block 
11ec 69			      ld    L, C 
11ed 73			      ld    (HL), E 
11ee 23			      inc   HL 
11ef 72			      ld    (HL), D 
11f0			 
11f0			      ; Check if the freed block is adjacent to the next free block 
11f0 23			      inc   HL                      ; Load size of freed block into HL 
11f1 5e			      ld    E, (HL) 
11f2 23			      inc   HL 
11f3 56			      ld    D, (HL) 
11f4 eb			      ex    DE, HL 
11f5			 
11f5 09			      add   HL, BC                  ; Add addr of freed block and its size 
11f6			 
11f6 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
11f9 dd 56 01		      ld    D, (IX+1) 
11fc			 
11fc b7			      or    A                       ; Clear the carry flag 
11fd ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
11ff 20 22		      jr    NZ, free_check_adjacent_to_prev 
1201			 
1201			      ; Freed block is adjacent to next, merge into one bigger block 
1201 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
1202 5e			      ld    E, (HL) 
1203 23			      inc   HL 
1204 56			      ld    D, (HL) 
1205 e5			      push  HL                      ; Save ptr to next block for later 
1206			 
1206 60			      ld    H, B                    ; Store ptr from next block into freed block 
1207 69			      ld    L, C 
1208 73			      ld    (HL), E 
1209 23			      inc   HL 
120a 72			      ld    (HL), D 
120b			 
120b e1			      pop   HL                      ; Restore ptr to next block 
120c 23			      inc   HL                      ; Load size of next block into DE 
120d 5e			      ld    E, (HL) 
120e 23			      inc   HL 
120f 56			      ld    D, (HL) 
1210 d5			      push  DE                      ; Save next block size for later 
1211			 
1211 60			      ld    H, B                    ; Load size of freed block into HL 
1212 69			      ld    L, C 
1213 23			      inc   HL 
1214 23			      inc   HL 
1215 5e			      ld    E, (HL) 
1216 23			      inc   HL 
1217 56			      ld    D, (HL) 
1218 eb			      ex    DE, HL 
1219			 
1219 d1			      pop   DE                      ; Restore size of next block 
121a 19			      add   HL, DE                  ; Add sizes of both blocks 
121b eb			      ex    DE, HL 
121c			 
121c 60			      ld    H, B                    ; Store new bigger size into freed block 
121d 69			      ld    L, C 
121e 23			      inc   HL 
121f 23			      inc   HL 
1220 73			      ld    (HL), E 
1221 23			      inc   HL 
1222 72			      ld    (HL), D 
1223			 
1223			free_check_adjacent_to_prev: 
1223			      ; Check if the freed block is adjacent to the prev free block 
1223 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
1226 dd 66 03		      ld    H, (IX+3) 
1229			 
1229 23			      inc   HL                      ; Size of prev free block into DE 
122a 23			      inc   HL 
122b 5e			      ld    E, (HL) 
122c 23			      inc   HL 
122d 56			      ld    D, (HL) 
122e 2b			      dec   HL 
122f 2b			      dec   HL 
1230 2b			      dec   HL 
1231			 
1231 19			      add   HL, DE                  ; Add prev block addr and size 
1232			 
1232 b7			      or    A                       ; Clear the carry flag 
1233 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1235 20 2e		      jr    NZ, free_done 
1237			 
1237			      ; Freed block is adjacent to prev, merge into one bigger block 
1237 60			      ld    H, B                    ; Load next ptr from freed block into DE 
1238 69			      ld    L, C 
1239 5e			      ld    E, (HL) 
123a 23			      inc   HL 
123b 56			      ld    D, (HL) 
123c e5			      push  HL                      ; Save freed block ptr for later 
123d			 
123d dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1240 dd 66 03		      ld    H, (IX+3) 
1243 73			      ld    (HL), E 
1244 23			      inc   HL 
1245 72			      ld    (HL), D 
1246			 
1246 e1			      pop   HL                      ; Restore freed block ptr 
1247 23			      inc   HL                      ; Load size of freed block into DE 
1248 5e			      ld    E, (HL) 
1249 23			      inc   HL 
124a 56			      ld    D, (HL) 
124b d5			      push  DE                      ; Save freed block size for later 
124c			 
124c dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
124f dd 66 03		      ld    H, (IX+3) 
1252 23			      inc   HL 
1253 23			      inc   HL 
1254 5e			      ld    E, (HL) 
1255 23			      inc   HL 
1256 56			      ld    D, (HL) 
1257			 
1257 e1			      pop   HL                      ; Add sizes of both blocks 
1258 19			      add   HL, DE 
1259 eb			      ex    DE, HL 
125a			 
125a dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
125d dd 66 03		      ld    H, (IX+3) 
1260 23			      inc   HL 
1261 23			      inc   HL 
1262 73			      ld    (HL), E 
1263 23			      inc   HL 
1264 72			      ld    (HL), D 
1265			 
1265			free_done: 
1265 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
1268 39			      add   HL, SP 
1269 f9			      ld    SP, HL 
126a			 
126a			free_early_exit: 
126a dd e1		      pop   IX 
126c d1			      pop   DE 
126d c1			      pop   BC 
126e			 
126e c9			      ret 
126f			 
126f			; moved to firmware.asm 
126f			; 
126f			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
126f			;                  .dw   0 
126f			 
126f			 
126f			endif 
126f			 
126f			 
126f			if MALLOC_3 
126f			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
126f			;heap_start        .equ  0x9000      ; Starting address of heap 
126f			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
126f			; 
126f			 ;     .org 0 
126f			  ;    jp    main 
126f			; 
126f			; 
126f			 ;     .org  0x100 
126f			;main: 
126f			 ;     ld    HL, 0x8100 
126f			  ;    ld    SP, HL 
126f			; 
126f			;      call  heap_init 
126f			 
126f			      ; Make some allocations 
126f			;      ld    HL, 12 
126f			;      call  malloc            ; Allocates 0x9004 
126f			; 
126f			 ;     ld    HL, 12 
126f			;      call  malloc            ; Allocates 0x9014 
126f			 
126f			;      ld    HL, 12 
126f			;      call  malloc            ; Allocates 0x9024 
126f			 
126f			      ; Free some allocations 
126f			;      ld    HL, 0x9014 
126f			;      call  free 
126f			 
126f			;      ld    HL, 0x9004 
126f			;      call  free 
126f			; 
126f			;      ld    HL, 0x9024 
126f			;      call  free 
126f			 
126f			 
126f			 ;     halt 
126f			 
126f			 
126f			;------------------------------------------------------------------------------ 
126f			;     heap_init                                                               : 
126f			;                                                                             : 
126f			; Description                                                                 : 
126f			;     Initialise the heap and make it ready for malloc and free operations.   : 
126f			;                                                                             : 
126f			;     The heap is maintained as a linked list, starting with an initial       : 
126f			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
126f			;     the first free block in the heap. Each block then points to the next    : 
126f			;     free block within the heap, and the free list ends at the first block   : 
126f			;     with a null pointer to the next free block.                             : 
126f			;                                                                             : 
126f			; Parameters                                                                  : 
126f			;     Inputs are compile-time only. Two defines which specify the starting    : 
126f			;     address of the heap and its size are required, along with a memory      : 
126f			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
126f			;     principally stores a pointer to the first free block in the heap.       : 
126f			;                                                                             : 
126f			; Returns                                                                     : 
126f			;     Nothing                                                                 : 
126f			;------------------------------------------------------------------------------ 
126f			heap_init: 
126f			      push  HL 
126f			 
126f			      ; Initialise free list struct 
126f			      ld    HL, heap_start 
126f			      ld    (free_list), HL 
126f			      ld    HL, 0 
126f			      ld    (free_list+2), HL 
126f			 
126f			      ; Insert first free block at bottom of heap, consumes entire heap 
126f			      ld    HL, heap_start+heap_size-4 
126f			      ld    (heap_start), HL        ; Next block (end of free list) 
126f			      ld    HL, heap_size-4 
126f			      ld    (heap_start+2), HL      ; Block size 
126f			 
126f			      ; Insert end of free list block at top of heap - two null words will 
126f			      ; terminate the free list 
126f			      ld    HL, 0 
126f			      ld    (heap_start+heap_size-2), HL 
126f			      ld    (heap_start+heap_size-4), HL 
126f			 
126f			      pop   HL 
126f			 
126f			      ret 
126f			 
126f			 
126f			;------------------------------------------------------------------------------ 
126f			;     malloc                                                                  : 
126f			;                                                                             : 
126f			; Description                                                                 : 
126f			;     Allocates the wanted space from the heap and returns the address of the : 
126f			;     first useable byte of the allocation.                                   : 
126f			;                                                                             : 
126f			;     Allocations can happen in one of two ways:                              : 
126f			;                                                                             : 
126f			;     1. A free block may be found which is the exact size wanted. In this    : 
126f			;        case the block is removed from the free list and retuedn to the      : 
126f			;        caller.                                                              : 
126f			;     2. A free block may be found which is larger than the size wanted. In   : 
126f			;        this case, the larger block is split into two. The first portion of  : 
126f			;        this block will become the requested space by the malloc call and    : 
126f			;        is returned to the caller. The second portion becomes a new free     : 
126f			;        block, and the free list is adjusted to maintain continuity via this : 
126f			;        newly created block.                                                 : 
126f			;                                                                             : 
126f			;     malloc does not set any initial value in the allocated space, the       : 
126f			;     caller is required to do this as required.                              : 
126f			;                                                                             : 
126f			;     This implementation of malloc uses the stack exclusively, and is        : 
126f			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
126f			;     advisable to disable interrupts before calling malloc, and recommended  : 
126f			;     to avoid the use of malloc inside ISRs in general.                      : 
126f			;                                                                             : 
126f			;     NOTE: heap_init must be called before malloc and free can be used.      : 
126f			;                                                                             : 
126f			; Parameters                                                                  : 
126f			;     HL  Number of bytes wanted                                              : 
126f			;                                                                             : 
126f			; Returns                                                                     : 
126f			;     HL  Address of the first useable byte of the allocation                 : 
126f			;                                                                             : 
126f			; Flags                                                                       : 
126f			;     Z   Set if the allocation did not succeed, clear otherwise              : 
126f			;                                                                             : 
126f			; Stack frame                                                                 : 
126f			;       |             |                                                       : 
126f			;       +-------------+                                                       : 
126f			;       |     BC      |                                                       : 
126f			;       +-------------+                                                       : 
126f			;       |     DE      |                                                       : 
126f			;       +-------------+                                                       : 
126f			;       |     IX      |                                                       : 
126f			;       +-------------+                                                       : 
126f			;       |  prev_free  |                                                       : 
126f			;   +4  +-------------+                                                       : 
126f			;       |  this_free  |                                                       : 
126f			;   +2  +-------------+                                                       : 
126f			;       |  next_free  |                                                       : 
126f			;   +0  +-------------+                                                       : 
126f			;       |             |                                                       : 
126f			;                                                                             : 
126f			;------------------------------------------------------------------------------ 
126f			malloc: 
126f			      push  BC 
126f			      push  DE 
126f			      push  IX 
126f			 
126f			      ld    A, H                    ; Exit if no space requested 
126f			      or    L 
126f			      jp    Z, malloc_early_exit 
126f			 
126f			      ; Set up stack frame 
126f			      ex    DE, HL 
126f			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
126f			      add   HL, SP 
126f			      ld    SP, HL 
126f			      ld    IX, 0                   ; Use IX as a frame pointer 
126f			      add   IX, SP 
126f			 
126f			      ; Setup initial state 
126f			      ld    HL, 4                   ; want must also include space used by block struct 
126f			      add   HL, DE 
126f			 
126f			      ld    B, H                    ; Move want to BC 
126f			      ld    C, L 
126f			 
126f			      ld    HL, free_list           ; Store prev_free ptr to stack 
126f			      ld    (IX+4), L 
126f			      ld    (IX+5), H 
126f			 
126f			      ld    E, (HL)                 ; Store this_free ptr to stack 
126f			      inc   HL 
126f			      ld    D, (HL) 
126f			      ld    (IX+2), E 
126f			      ld    (IX+3), D 
126f			      ex    DE, HL                  ; this_free ptr into HL 
126f			 
126f			      ; Loop through free block list to find some space 
126f			malloc_find_space: 
126f			      ld    E, (HL)                 ; Load next_free ptr into DE 
126f			      inc   HL 
126f			      ld    D, (HL) 
126f			 
126f			      ld    A, D                    ; Check for null next_free ptr - end of free list 
126f			      or    E 
126f			      jp    Z, malloc_no_space 
126f			 
126f			      ld    (IX+0), E               ; Store next_free ptr to stack 
126f			      ld    (IX+1), D 
126f			 
126f			      ; Does this block have enough space to make the allocation? 
126f			      inc   HL                      ; Load free block size into DE 
126f			      ld    E, (HL) 
126f			      inc   HL 
126f			      ld    D, (HL) 
126f			 
126f			      ex    DE, HL                  ; Check size of block against want 
126f			      or    A                       ; Ensure carry flag clear 
126f			      sbc   HL, BC 
126f			      push  HL                      ; Store the result for later (new block size) 
126f			 
126f			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
126f			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
126f			 
126f			      ; this_free block is not big enough, setup ptrs to test next free block 
126f			      pop   HL                      ; Discard previous result 
126f			 
126f			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
126f			      ld    H, (IX+3) 
126f			      ld    (IX+4), L 
126f			      ld    (IX+5), H 
126f			 
126f			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
126f			      ld    H, (IX+1) 
126f			      ld    (IX+2), L 
126f			      ld    (IX+3), H 
126f			 
126f			      jr    malloc_find_space 
126f			 
126f			      ; split a bigger block into two - requested size and remaining size 
126f			malloc_alloc_split: 
126f			      ex    DE, HL                  ; Calculate address of new free block 
126f			      dec   HL 
126f			      dec   HL 
126f			      dec   HL 
126f			      add   HL, BC 
126f			 
126f			      ; Create a new block and point it at next_free 
126f			      ld    E, (IX+0)               ; Load next_free ptr into DE 
126f			      ld    D, (IX+1) 
126f			 
126f			      ld    (HL), E                 ; Store next_free ptr into new block 
126f			      inc   HL 
126f			      ld    (HL), D 
126f			 
126f			      pop   DE                      ; Store size of new block into new block 
126f			      inc   HL 
126f			      ld    (HL), E 
126f			      inc   HL 
126f			      ld    (HL), D 
126f			 
126f			      ; Update this_free ptr to point to new block 
126f			      dec   HL 
126f			      dec   HL 
126f			      dec   HL 
126f			 
126f			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
126f			      ld    D, (IX+3) 
126f			 
126f			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
126f			      ld    (IX+3), H 
126f			 
126f			      ; Modify this_free block to be allocation 
126f			      ex    DE, HL 
126f			      xor   A                       ; Null the next block ptr of allocated block 
126f			      ld    (HL), A 
126f			      inc   HL 
126f			      ld    (HL), A 
126f			 
126f			      inc   HL                      ; Store want size into allocated block 
126f			      ld    (HL), C 
126f			      inc   HL 
126f			      ld    (HL), B 
126f			      inc   HL 
126f			      push  HL                      ; Address of allocation to return 
126f			 
126f			      jr    malloc_update_links 
126f			 
126f			malloc_alloc_fit: 
126f			      pop   HL                      ; Dont need new block size, want is exact fit 
126f			 
126f			      ; Modify this_free block to be allocation 
126f			      ex    DE, HL 
126f			      dec   HL 
126f			      dec   HL 
126f			      dec   HL 
126f			 
126f			      xor   A                       ; Null the next block ptr of allocated block 
126f			      ld    (HL), A 
126f			      inc   HL 
126f			      ld    (HL), A 
126f			 
126f			      inc   HL                      ; Store address of allocation to return 
126f			      inc   HL 
126f			      inc   HL 
126f			      push  HL 
126f			 
126f			      ; Copy next_free ptr to this_free, remove allocated block from free list 
126f			      ld    L, (IX+0)               ; next_free to HL 
126f			      ld    H, (IX+1) 
126f			 
126f			      ld    (IX+2), L               ; HL to this_free 
126f			      ld    (IX+3), H 
126f			 
126f			 
126f			malloc_update_links: 
126f			      ; Update prev_free ptr to point to this_free 
126f			      ld    L, (IX+4)               ; prev_free ptr to HL 
126f			      ld    H, (IX+5) 
126f			 
126f			      ld    E, (IX+2)               ; this_free ptr to DE 
126f			      ld    D, (IX+3) 
126f			 
126f			      ld    (HL), E                 ; this_free ptr into prev_free 
126f			      inc   HL 
126f			      ld    (HL), D 
126f			 
126f			      ; Clear the Z flag to indicate successful allocation 
126f			      ld    A, D 
126f			      or    E 
126f			 
126f			      pop   DE                      ; Address of allocation 
126f			 
126f			malloc_no_space: 
126f			      ld    HL, 6                   ; Clean up stack frame 
126f			      add   HL, SP 
126f			      ld    SP, HL 
126f			 
126f			      ex    DE, HL                  ; Alloc addr into HL for return 
126f			 
126f			malloc_early_exit: 
126f			      pop   IX 
126f			      pop   DE 
126f			      pop   BC 
126f			 
126f			      ret 
126f			 
126f			 
126f			;------------------------------------------------------------------------------ 
126f			;     free                                                                    : 
126f			;                                                                             : 
126f			; Description                                                                 : 
126f			;     Return the space pointed to by HL to the heap. HL must be an address as : 
126f			;     returned by malloc, otherwise the behaviour is undefined.               : 
126f			;                                                                             : 
126f			;     Where possible, directly adjacent free blocks will be merged together   : 
126f			;     into larger blocks to help ensure that the heap does not become         : 
126f			;     excessively fragmented.                                                 : 
126f			;                                                                             : 
126f			;     free does not clear or set any other value into the freed space, and    : 
126f			;     therefore its contents may be visible through subsequent malloc's. The  : 
126f			;     caller should clear the freed space as required.                        : 
126f			;                                                                             : 
126f			;     This implementation of free uses the stack exclusively, and is          : 
126f			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
126f			;     advisable to disable interrupts before calling free, and recommended    : 
126f			;     to avoid the use of free inside ISRs in general.                        : 
126f			;                                                                             : 
126f			;     NOTE: heap_init must be called before malloc and free can be used.      : 
126f			;                                                                             : 
126f			; Parameters                                                                  : 
126f			;     HL  Pointer to address of first byte of allocation to be freed          : 
126f			;                                                                             : 
126f			; Returns                                                                     : 
126f			;     Nothing                                                                 : 
126f			;                                                                             : 
126f			; Stack frame                                                                 : 
126f			;       |             |                                                       : 
126f			;       +-------------+                                                       : 
126f			;       |     BC      |                                                       : 
126f			;       +-------------+                                                       : 
126f			;       |     DE      |                                                       : 
126f			;       +-------------+                                                       : 
126f			;       |     IX      |                                                       : 
126f			;       +-------------+                                                       : 
126f			;       |  prev_free  |                                                       : 
126f			;   +2  +-------------+                                                       : 
126f			;       |  next_free  |                                                       : 
126f			;   +0  +-------------+                                                       : 
126f			;       |             |                                                       : 
126f			;                                                                             : 
126f			;------------------------------------------------------------------------------ 
126f			free: 
126f			      push  BC 
126f			      push  DE 
126f			      push  IX 
126f			 
126f			      ld    A, H                    ; Exit if ptr is null 
126f			      or    L 
126f			      jp    Z, free_early_exit 
126f			 
126f			      ; Set up stack frame 
126f			      ex    DE, HL 
126f			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
126f			      add   HL, SP 
126f			      ld    SP, HL 
126f			      ld    IX, 0                   ; Use IX as a frame pointer 
126f			      add   IX, SP 
126f			 
126f			      ; The address in HL points to the start of the useable allocated space, 
126f			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
126f			      ; address of the block itself. 
126f			      ex    DE, HL 
126f			      ld    DE, -4 
126f			      add   HL, DE 
126f			 
126f			      ; An allocated block must have a null next block pointer in it 
126f			      ld    A, (HL) 
126f			      inc   HL 
126f			      or    (HL) 
126f			      jp    NZ, free_done 
126f			 
126f			      dec   HL 
126f			 
126f			      ld    B, H                    ; Copy HL to BC 
126f			      ld    C, L 
126f			 
126f			      ; Loop through the free list to find the first block with an address 
126f			      ; higher than the block being freed 
126f			      ld    HL, free_list 
126f			 
126f			free_find_higher_block: 
126f			      ld    E, (HL)                 ; Load next ptr from free block 
126f			      inc   HL 
126f			      ld    D, (HL) 
126f			      dec   HL 
126f			 
126f			      ld    (IX+0), E               ; Save ptr to next free block 
126f			      ld    (IX+1), D 
126f			      ld    (IX+2), L               ; Save ptr to prev free block 
126f			      ld    (IX+3), H 
126f			 
126f			      ld    A, B                    ; Check if DE is greater than BC 
126f			      cp    D                       ; Compare MSB first 
126f			      jr    Z, $+4                  ; MSB the same, compare LSB 
126f			      jr    NC, free_find_higher_block_skip 
126f			      ld    A, C 
126f			      cp    E                       ; Then compare LSB 
126f			      jr    C, free_found_higher_block 
126f			 
126f			free_find_higher_block_skip: 
126f			      ld    A, D                    ; Reached the end of the free list? 
126f			      or    E 
126f			      jp    Z, free_done 
126f			 
126f			      ex    DE, HL 
126f			 
126f			      jr    free_find_higher_block 
126f			 
126f			free_found_higher_block: 
126f			      ; Insert freed block between prev and next free blocks 
126f			      ld    (HL), C                 ; Point prev free block to freed block 
126f			      inc   HL 
126f			      ld    (HL), B 
126f			 
126f			      ld    H, B                    ; Point freed block at next free block 
126f			      ld    L, C 
126f			      ld    (HL), E 
126f			      inc   HL 
126f			      ld    (HL), D 
126f			 
126f			      ; Check if the freed block is adjacent to the next free block 
126f			      inc   HL                      ; Load size of freed block into HL 
126f			      ld    E, (HL) 
126f			      inc   HL 
126f			      ld    D, (HL) 
126f			      ex    DE, HL 
126f			 
126f			      add   HL, BC                  ; Add addr of freed block and its size 
126f			 
126f			      ld    E, (IX+0)               ; Load addr of next free block into DE 
126f			      ld    D, (IX+1) 
126f			 
126f			      or    A                       ; Clear the carry flag 
126f			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
126f			      jr    NZ, free_check_adjacent_to_prev 
126f			 
126f			      ; Freed block is adjacent to next, merge into one bigger block 
126f			      ex    DE, HL                  ; Load next ptr from next block into DE 
126f			      ld    E, (HL) 
126f			      inc   HL 
126f			      ld    D, (HL) 
126f			      push  HL                      ; Save ptr to next block for later 
126f			 
126f			      ld    H, B                    ; Store ptr from next block into freed block 
126f			      ld    L, C 
126f			      ld    (HL), E 
126f			      inc   HL 
126f			      ld    (HL), D 
126f			 
126f			      pop   HL                      ; Restore ptr to next block 
126f			      inc   HL                      ; Load size of next block into DE 
126f			      ld    E, (HL) 
126f			      inc   HL 
126f			      ld    D, (HL) 
126f			      push  DE                      ; Save next block size for later 
126f			 
126f			      ld    H, B                    ; Load size of freed block into HL 
126f			      ld    L, C 
126f			      inc   HL 
126f			      inc   HL 
126f			      ld    E, (HL) 
126f			      inc   HL 
126f			      ld    D, (HL) 
126f			      ex    DE, HL 
126f			 
126f			      pop   DE                      ; Restore size of next block 
126f			      add   HL, DE                  ; Add sizes of both blocks 
126f			      ex    DE, HL 
126f			 
126f			      ld    H, B                    ; Store new bigger size into freed block 
126f			      ld    L, C 
126f			      inc   HL 
126f			      inc   HL 
126f			      ld    (HL), E 
126f			      inc   HL 
126f			      ld    (HL), D 
126f			 
126f			free_check_adjacent_to_prev: 
126f			      ; Check if the freed block is adjacent to the prev free block 
126f			      ld    L, (IX+2)               ; Prev free block ptr into HL 
126f			      ld    H, (IX+3) 
126f			 
126f			      inc   HL                      ; Size of prev free block into DE 
126f			      inc   HL 
126f			      ld    E, (HL) 
126f			      inc   HL 
126f			      ld    D, (HL) 
126f			      dec   HL 
126f			      dec   HL 
126f			      dec   HL 
126f			 
126f			      add   HL, DE                  ; Add prev block addr and size 
126f			 
126f			      or    A                       ; Clear the carry flag 
126f			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
126f			      jr    NZ, free_done 
126f			 
126f			      ; Freed block is adjacent to prev, merge into one bigger block 
126f			      ld    H, B                    ; Load next ptr from freed block into DE 
126f			      ld    L, C 
126f			      ld    E, (HL) 
126f			      inc   HL 
126f			      ld    D, (HL) 
126f			      push  HL                      ; Save freed block ptr for later 
126f			 
126f			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
126f			      ld    H, (IX+3) 
126f			      ld    (HL), E 
126f			      inc   HL 
126f			      ld    (HL), D 
126f			 
126f			      pop   HL                      ; Restore freed block ptr 
126f			      inc   HL                      ; Load size of freed block into DE 
126f			      ld    E, (HL) 
126f			      inc   HL 
126f			      ld    D, (HL) 
126f			      push  DE                      ; Save freed block size for later 
126f			 
126f			      ld    L, (IX+2)               ; Load size of prev block into DE 
126f			      ld    H, (IX+3) 
126f			      inc   HL 
126f			      inc   HL 
126f			      ld    E, (HL) 
126f			      inc   HL 
126f			      ld    D, (HL) 
126f			 
126f			      pop   HL                      ; Add sizes of both blocks 
126f			      add   HL, DE 
126f			      ex    DE, HL 
126f			 
126f			      ld    L, (IX+2)               ; Store new bigger size into prev block 
126f			      ld    H, (IX+3) 
126f			      inc   HL 
126f			      inc   HL 
126f			      ld    (HL), E 
126f			      inc   HL 
126f			      ld    (HL), D 
126f			 
126f			free_done: 
126f			      ld    HL, 4                   ; Clean up stack frame 
126f			      add   HL, SP 
126f			      ld    SP, HL 
126f			 
126f			free_early_exit: 
126f			      pop   IX 
126f			      pop   DE 
126f			      pop   BC 
126f			 
126f			      ret 
126f			 
126f			 
126f			;      .org 0x8000 
126f			; 
126f			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
126f			 ;                 .dw   0 
126f			 
126f			endif 
126f			 
126f			 
126f			if MALLOC_4 
126f			 
126f			; My memory allocation code. Very very simple.... 
126f			; allocate space under 250 chars 
126f			 
126f			heap_init: 
126f				; init start of heap as zero 
126f				;  
126f			 
126f				ld hl, heap_start 
126f				ld a, 0 
126f				ld (hl), a      ; empty block 
126f				inc hl 
126f				ld a, 0 
126f				ld (hl), a      ; length of block 
126f				; write end of list 
126f				inc hl 
126f				ld a,(hl) 
126f				inc hl 
126f				ld a,(hl) 
126f				 
126f			 
126f				; init some malloc vars 
126f			 
126f				ld hl, 0 
126f				ld (free_list), hl       ; store last malloc location 
126f			 
126f				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
126f				ld a, 0 
126f				ld (hl), a 
126f			 
126f			 
126f				ld hl, heap_start 
126f				;  
126f				  
126f				ret 
126f			 
126f			 
126f			;    free block marker 
126f			;    requested size  
126f			;    pointer to next block 
126f			;    .... 
126f			;    next block marker 
126f			 
126f			 
126f			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
126f			; 
126f			 
126f			 
126f			malloc:  
126f				push de 
126f				push bc 
126f				push af 
126f			 
126f				; hl space required 
126f				 
126f				ld c, l    ; hold space   (TODO only a max of 255) 
126f			 
126f			;	inc c     ; TODO BUG need to fix memory leak on push str 
126f			;	inc c 
126f			;	inc c 
126f			;	inc c 
126f			;	inc c 
126f			;	inc c 
126f			;	inc c 
126f			 
126f			 
126f			 
126f				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
126f			 
126f				ld a, (free_list+3) 
126f				cp 0 
126f				jr z, .contheap 
126f			 
126f				ld hl, (free_list)     ; get last alloc 
126f					if DEBUG_FORTH_MALLOC_INT 
126f						DMARK "mrs" 
126f						CALLMONITOR 
126f					endif 
126f				jr .startalloc 
126f			 
126f			.contheap: 
126f				ld hl, heap_start 
126f			 
126f			.startalloc: 
126f			 
126f					if DEBUG_FORTH_MALLOC_INT 
126f						DMARK "mym" 
126f						CALLMONITOR 
126f					endif 
126f			.findblock: 
126f					if DEBUG_FORTH_MALLOC_INT 
126f						DMARK "mmf" 
126f						CALLMONITOR 
126f					endif 
126f			 
126f				ld a,(hl)  
126f				; if byte is zero then clear to use 
126f			 
126f				cp 0 
126f				jr z, .foundemptyblock 
126f			 
126f				; if byte is not clear 
126f				;     then byte is offset to next block 
126f			 
126f				inc hl 
126f				ld a, (hl) ; get size 
126f			.nextblock:	inc hl 
126f					ld e, (hl) 
126f					inc hl 
126f					ld d, (hl) 
126f					ex de, hl 
126f			;	inc hl  ; move past the store space 
126f			;	inc hl  ; move past zero index  
126f			 
126f				; TODO detect no more space 
126f			 
126f				push hl 
126f				ld de, heap_end 
126f				call cmp16 
126f				pop hl 
126f				jr nc, .nospace 
126f			 
126f				jr .findblock 
126f			 
126f			.nospace: ld hl, 0 
126f				jp .exit 
126f			 
126f			 
126f			.foundemptyblock:	 
126f					if DEBUG_FORTH_MALLOC_INT 
126f						DMARK "mme" 
126f						CALLMONITOR 
126f					endif 
126f			 
126f			; TODO has block enough space if reusing??? 
126f			 
126f				;  
126f			 
126f			; see if this block has been previously used 
126f				inc hl 
126f				ld a, (hl) 
126f				dec hl 
126f				cp 0 
126f				jr z, .newblock 
126f			 
126f					if DEBUG_FORTH_MALLOC_INT 
126f						DMARK "meR" 
126f						CALLMONITOR 
126f					endif 
126f			 
126f			; no reusing previously allocated block 
126f			 
126f			; is it smaller than previously used? 
126f				 
126f				inc hl    ; move to size 
126f				ld a, c 
126f				sub (hl)        ; we want c < (hl) 
126f				dec hl    ; move back to marker 
126f			        jr z, .findblock 
126f			 
126f				; update with the new size which should be lower 
126f			 
126f			        ;inc  hl   ; negate next move. move back to size  
126f			 
126f			.newblock: 
126f				; need to be at marker here 
126f			 
126f					if DEBUG_FORTH_MALLOC_INT 
126f						DMARK "meN" 
126f						CALLMONITOR 
126f					endif 
126f			 
126f			 
126f				ld a, c 
126f			 
126f				ld (free_list+3), a	 ; flag resume from last malloc  
126f				ld (free_list), hl    ; save out last location 
126f			 
126f			 
126f				;inc a     ; space for length byte 
126f				ld (hl), a     ; save block in use marker 
126f			 
126f				inc hl   ; move to space marker 
126f				ld (hl), a    ; save new space 
126f			 
126f				inc hl   ; move to start of allocated area 
126f				 
126f			;	push hl     ; save where we are - 1  
126f			 
126f			;	inc hl  ; move past zero index  
126f				; skip space to set down new marker 
126f			 
126f				; provide some extra space for now 
126f			 
126f				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
126f				inc a 
126f				inc a 
126f			 
126f				push hl   ; save where we are in the node block 
126f			 
126f				call addatohl 
126f			 
126f				; write linked list point 
126f			 
126f				pop de     ; get our node position 
126f				ex de, hl 
126f			 
126f				ld (hl), e 
126f				inc hl 
126f				ld (hl), d 
126f			 
126f				inc hl 
126f			 
126f				; now at start of allocated data so save pointer 
126f			 
126f				push hl 
126f			 
126f				; jump to position of next node and setup empty header in DE 
126f			 
126f				ex de, hl 
126f			 
126f			;	inc hl ; move past end of block 
126f			 
126f				ld a, 0 
126f				ld (hl), a   ; empty marker 
126f				inc hl 
126f				ld (hl), a   ; size 
126f				inc hl  
126f				ld (hl), a   ; ptr 
126f				inc hl 
126f				ld (hl), a   ; ptr 
126f			 
126f			 
126f				pop hl 
126f			 
126f					if DEBUG_FORTH_MALLOC_INT 
126f						DMARK "mmr" 
126f						CALLMONITOR 
126f					endif 
126f			 
126f			.exit: 
126f				pop af 
126f				pop bc 
126f				pop de  
126f				ret 
126f			 
126f			 
126f			 
126f			 
126f			free:  
126f				push hl 
126f				push af 
126f				; get address in hl 
126f			 
126f					if DEBUG_FORTH_MALLOC_INT 
126f						DMARK "fre" 
126f						CALLMONITOR 
126f					endif 
126f				; data is at hl - move to block count 
126f				dec hl 
126f				dec hl    ; get past pointer 
126f				dec hl 
126f			 
126f				ld a, (hl)    ; need this for a validation check 
126f			 
126f				dec hl    ; move to block marker 
126f			 
126f				; now check that the block count and block marker are the same  
126f			        ; this checks that we are on a malloc node and not random memory 
126f			        ; OK a faint chance this could be a problem but rare - famous last words! 
126f			 
126f				ld c, a 
126f				ld a, (hl)    
126f			 
126f				cp c 
126f				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
126f			 
126f				; yes good chance we are on a malloc node 
126f			 
126f				ld a, 0      
126f				ld (hl), a   ; mark as free 
126f			 
126f				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
126f			 
126f			.freeignore:  
126f			 
126f				pop af 
126f				pop hl 
126f			 
126f				ret 
126f			 
126f			 
126f			 
126f			endif 
126f			 
126f			; eof 
# End of file firmware_memory.asm
126f			  
126f			; device C  
126f			if SOUND_ENABLE  
126f				include "firmware_sound.asm"  
126f			endif  
126f			  
126f			include "firmware_diags.asm"  
126f			; Hardware diags menu 
126f			 
126f			 
126f .. 00		hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
1290 .. 00		hd_menu2:   db "        2: Editor",0   
12a2			;hd_menu2:   db "        2: Editor       6: BASIC",0   
12a2 .. 00		hd_menu3:   db "        3: Storage",0 
12b5 .. 00		hd_menu4:   db "0=quit  4: Debug",0 
12c6 .. 00		hd_don:     db "ON",0 
12c9 .. 00		hd_doff:     db "OFF",0 
12cd			 
12cd			 
12cd			 
12cd			hardware_diags:       
12cd			 
12cd			.diagmenu: 
12cd cd b6 0a			call clear_display 
12d0 3e 00			ld a, display_row_1 
12d2 11 6f 12			ld de, hd_menu1 
12d5 cd c9 0a			call str_at_display 
12d8			 
12d8 3e 14			ld a, display_row_2 
12da 11 90 12			ld de, hd_menu2 
12dd cd c9 0a			call str_at_display 
12e0			 
12e0 3e 28			ld a, display_row_3 
12e2 11 a2 12			ld de, hd_menu3 
12e5 cd c9 0a			call str_at_display 
12e8			 
12e8 3e 3c			ld a,  display_row_4 
12ea 11 b5 12			ld de, hd_menu4 
12ed cd c9 0a			call str_at_display 
12f0			 
12f0				; display debug state 
12f0			 
12f0 11 c6 12			ld de, hd_don 
12f3 3a b7 ef			ld a, (os_view_disable) 
12f6 fe 00			cp 0 
12f8 28 03			jr z, .distog 
12fa 11 c9 12			ld de, hd_doff 
12fd 3e 4d		.distog: ld a, display_row_4+17 
12ff cd c9 0a			call str_at_display 
1302			 
1302 cd d9 0a			call update_display 
1305			 
1305 cd fd 62			call cin_wait 
1308			 
1308			 
1308			 
1308 fe 34			cp '4' 
130a 20 0f			jr nz, .diagn1 
130c			 
130c				; debug toggle 
130c			 
130c 3a b7 ef			ld a, (os_view_disable) 
130f 06 2a			ld b, '*' 
1311 fe 00			cp 0 
1313 28 02			jr z, .debtog 
1315 06 00			ld b, 0 
1317			.debtog:	 
1317 78				ld a,b 
1318 32 b7 ef			ld (os_view_disable),a 
131b			 
131b fe 30		.diagn1: cp '0' 
131d c8				 ret z 
131e			 
131e			;	cp '1' 
131e			;       jp z, matrix	 
131e			;   TODO keyboard matrix test 
131e			 
131e fe 32			cp '2' 
1320 ca 27 13			jp z, .diagedit 
1323			 
1323			;if ENABLE_BASIC 
1323			;	cp '6' 
1323			;	jp z, basic 
1323			;endif 
1323			  
1323 c3 cd 12			jp .diagmenu 
1326			 
1326			 
1326 c9				ret 
1327			 
1327			; debug editor 
1327			 
1327			.diagedit: 
1327			 
1327 21 b8 ef			ld hl, scratch 
132a			;	ld bc, 250 
132a			;	ldir 
132a				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
132a 3e 00			ld a, 0 
132c 77				ld (hl), a 
132d 23				inc hl 
132e 77				ld (hl), a 
132f 23				inc hl 
1330 77				ld (hl), a 
1331			 
1331 cd b6 0a		        call clear_display 
1334 cd d9 0a			call update_display 
1337 3e 01			ld a, 1 
1339 32 c3 fb			ld (hardware_diag), a 
133c			.diloop: 
133c 3e 00			ld a, display_row_1 
133e 0e 00			ld c, 0 
1340 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1342 1e 28			ld e, 40 
1344			 
1344 21 b8 ef			ld hl, scratch	 
1347 cd 3c 0c			call input_str 
134a			 
134a 3e 14			ld a, display_row_2 
134c 11 b8 ef			ld de, scratch 
134f cd c9 0a			call str_at_display 
1352 cd d9 0a			call update_display 
1355			 
1355 c3 3c 13			jp .diloop 
1358			 
1358			 
1358			; pass word in hl 
1358			; a has display location 
1358			display_word_at: 
1358 f5				push af 
1359 e5				push hl 
135a 7c				ld a,h 
135b 21 bd f2			ld hl, os_word_scratch 
135e cd 10 0f			call hexout 
1361 e1				pop hl 
1362 7d				ld a,l 
1363 21 bf f2			ld hl, os_word_scratch+2 
1366 cd 10 0f			call hexout 
1369 21 c1 f2			ld hl, os_word_scratch+4 
136c 3e 00			ld a,0 
136e 77				ld (hl),a 
136f 11 bd f2			ld de,os_word_scratch 
1372 f1				pop af 
1373 cd c9 0a				call str_at_display 
1376 c9				ret 
1377			 
1377			display_ptr_state: 
1377			 
1377				; to restore afterwards 
1377			 
1377 d5				push de 
1378 c5				push bc 
1379 e5				push hl 
137a f5				push af 
137b			 
137b				; for use in here 
137b			 
137b			;	push bc 
137b			;	push de 
137b			;	push hl 
137b			;	push af 
137b			 
137b cd b6 0a			call clear_display 
137e			 
137e 11 51 15			ld de, .ptrstate 
1381 3e 00			ld a, display_row_1 
1383 cd c9 0a			call str_at_display 
1386			 
1386				; display debug step 
1386			 
1386			 
1386 11 bd fb			ld de, debug_mark 
1389 3e 12			ld a, display_row_1+display_cols-2 
138b cd c9 0a			call str_at_display 
138e			 
138e				; display a 
138e 11 5b 15			ld de, .ptrcliptr 
1391 3e 14			ld a, display_row_2 
1393 cd c9 0a			call str_at_display 
1396			 
1396 f1				pop af 
1397 2a c3 f9			ld hl,(cli_ptr) 
139a 3e 1c			ld a, display_row_2+8 
139c cd 58 13			call display_word_at 
139f			 
139f			 
139f				; display hl 
139f			 
139f			 
139f 11 63 15			ld de, .ptrclioptr 
13a2 3e 1e			ld a, display_row_2+10 
13a4 cd c9 0a			call str_at_display 
13a7			; 
13a7			;	pop hl 
13a7 3e 21			ld a, display_row_2+13 
13a9 2a c1 f9			ld hl,(cli_origptr) 
13ac cd 58 13			call display_word_at 
13af			; 
13af			;	 
13af			;	; display de 
13af			 
13af			;	ld de, .regstatede 
13af			;	ld a, display_row_3 
13af			;	call str_at_display 
13af			 
13af			;	pop de 
13af			;	ld h,d 
13af			;	ld l, e 
13af			;	ld a, display_row_3+3 
13af			;	call display_word_at 
13af			 
13af			 
13af				; display bc 
13af			 
13af			;	ld de, .regstatebc 
13af			;	ld a, display_row_3+10 
13af			;	call str_at_display 
13af			 
13af			;	pop bc 
13af			;	ld h,b 
13af			;	ld l, c 
13af			;	ld a, display_row_3+13 
13af			;	call display_word_at 
13af			 
13af			 
13af				; display dsp 
13af			 
13af			;	ld de, .regstatedsp 
13af			;	ld a, display_row_4 
13af			;	call str_at_display 
13af			 
13af				 
13af			;	ld hl,(cli_data_sp) 
13af			;	ld a, display_row_4+4 
13af			;	call display_word_at 
13af			 
13af				; display rsp 
13af			 
13af 11 92 15			ld de, .regstatersp 
13b2 3e 46			ld a, display_row_4+10 
13b4 cd c9 0a			call str_at_display 
13b7			 
13b7				 
13b7 2a a9 f9			ld hl,(cli_ret_sp) 
13ba 3e 4a			ld a, display_row_4+14 
13bc cd 58 13			call display_word_at 
13bf			 
13bf cd d9 0a			call update_display 
13c2			 
13c2 cd 3a 0a			call delay1s 
13c5 cd 3a 0a			call delay1s 
13c8 cd 3a 0a			call delay1s 
13cb			 
13cb			 
13cb cd e5 18			call next_page_prompt 
13ce			 
13ce				; restore  
13ce			 
13ce f1				pop af 
13cf e1				pop hl 
13d0 c1				pop bc 
13d1 d1				pop de 
13d2 c9				ret 
13d3			 
13d3			break_point_state: 
13d3 f5				push af 
13d4			 
13d4				; see if disabled 
13d4			 
13d4 3a b7 ef			ld a, (os_view_disable) 
13d7 fe 2a			cp '*' 
13d9 20 02			jr nz, .bpsgo 
13db f1				pop af 
13dc c9				ret 
13dd			 
13dd			.bpsgo: 
13dd f1				pop af 
13de f5				push af 
13df 22 b3 ef			ld (os_view_hl), hl 
13e2 ed 53 b1 ef		ld (os_view_de), de 
13e6 ed 43 af ef		ld (os_view_bc), bc 
13ea e5				push hl 
13eb 6f				ld l, a 
13ec 26 00			ld h, 0 
13ee 22 b5 ef			ld (os_view_af),hl 
13f1			 
13f1 21 53 fb				ld hl, display_fb0 
13f4 22 5e fa				ld (display_fb_active), hl 
13f7 e1				pop hl	 
13f8			 
13f8 3e 31			ld a, '1' 
13fa fe 2a		.bps1:  cp '*' 
13fc 20 03			jr nz, .bps1b 
13fe 32 b7 ef			ld (os_view_disable),a 
1401 fe 31		.bps1b:  cp '1' 
1403 20 14			jr nz, .bps2 
1405			 
1405				; display reg 
1405			 
1405				 
1405			 
1405 3a b5 ef			ld a, (os_view_af) 
1408 2a b3 ef			ld hl, (os_view_hl) 
140b ed 5b b1 ef		ld de, (os_view_de) 
140f ed 4b af ef		ld bc, (os_view_bc) 
1413 cd ad 14			call display_reg_state 
1416 c3 99 14			jp .bpschk 
1419			 
1419 fe 32		.bps2:  cp '2' 
141b 20 08			jr nz, .bps3 
141d				 
141d				; display hl 
141d 2a b3 ef			ld hl, (os_view_hl) 
1420 cd 97 15			call display_dump_at_hl 
1423			 
1423 18 74			jr .bpschk 
1425			 
1425 fe 33		.bps3:  cp '3' 
1427 20 08			jr nz, .bps4 
1429			 
1429			        ; display de 
1429 2a b1 ef			ld hl, (os_view_de) 
142c cd 97 15			call display_dump_at_hl 
142f			 
142f 18 68			jr .bpschk 
1431 fe 34		.bps4:  cp '4' 
1433 20 08			jr nz, .bps5 
1435			 
1435			        ; display bc 
1435 2a af ef			ld hl, (os_view_bc) 
1438 cd 97 15			call display_dump_at_hl 
143b			 
143b 18 5c			jr .bpschk 
143d fe 35		.bps5:  cp '5' 
143f 20 08		        jr nz, .bps7 
1441			 
1441				; display cur ptr 
1441 2a c3 f9			ld hl, (cli_ptr) 
1444 cd 97 15			call display_dump_at_hl 
1447			 
1447 18 50			jr .bpschk 
1449 fe 36		.bps7:  cp '6' 
144b 20 08			jr nz, .bps8b 
144d				 
144d				; display cur orig ptr 
144d 2a c1 f9			ld hl, (cli_origptr) 
1450 cd 97 15			call display_dump_at_hl 
1453 18 44			jr .bpschk 
1455 fe 37		.bps8b:  cp '7' 
1457 20 08			jr nz, .bps9 
1459				 
1459				; display dsp 
1459 2a a5 f9			ld hl, (cli_data_sp) 
145c cd 97 15			call display_dump_at_hl 
145f			 
145f 18 38			jr .bpschk 
1461 fe 39		.bps9:  cp '9' 
1463 20 05			jr nz, .bps8c 
1465				 
1465				; display SP 
1465			;	ld hl, sp 
1465 cd 97 15			call display_dump_at_hl 
1468			 
1468 18 2f			jr .bpschk 
146a fe 38		.bps8c:  cp '8' 
146c 20 08			jr nz, .bps8d 
146e				 
146e				; display rsp 
146e 2a a9 f9			ld hl, (cli_ret_sp) 
1471 cd 97 15			call display_dump_at_hl 
1474			 
1474 18 23			jr .bpschk 
1476 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
1478 20 05			jr nz, .bps8 
147a cd db 16			call monitor 
147d			 
147d 18 1a			jr .bpschk 
147f fe 30		.bps8:  cp '0' 
1481 20 16			jr nz, .bpschk 
1483			 
1483 21 02 fb				ld hl, display_fb1 
1486 22 5e fa				ld (display_fb_active), hl 
1489 cd d9 0a				call update_display 
148c			 
148c				;ld a, (os_view_af) 
148c 2a b3 ef			ld hl, (os_view_hl) 
148f ed 5b b1 ef		ld de, (os_view_de) 
1493 ed 4b af ef		ld bc, (os_view_bc) 
1497 f1				pop af 
1498 c9				ret 
1499			 
1499			.bpschk:   
1499 cd 3a 0a			call delay1s 
149c 3e 4f		ld a,display_row_4 + display_cols - 1 
149e 11 e3 18		        ld de, endprg 
14a1 cd c9 0a			call str_at_display 
14a4 cd d9 0a			call update_display 
14a7 cd fd 62			call cin_wait 
14aa			 
14aa c3 fa 13			jp .bps1 
14ad			 
14ad			 
14ad			display_reg_state: 
14ad			 
14ad				; to restore afterwards 
14ad			 
14ad d5				push de 
14ae c5				push bc 
14af e5				push hl 
14b0 f5				push af 
14b1			 
14b1				; for use in here 
14b1			 
14b1 c5				push bc 
14b2 d5				push de 
14b3 e5				push hl 
14b4 f5				push af 
14b5			 
14b5 cd b6 0a			call clear_display 
14b8			 
14b8 11 6d 15			ld de, .regstate 
14bb 3e 00			ld a, display_row_1 
14bd cd c9 0a			call str_at_display 
14c0			 
14c0				; display debug step 
14c0			 
14c0			 
14c0 11 bd fb			ld de, debug_mark 
14c3 3e 11			ld a, display_row_1+display_cols-3 
14c5 cd c9 0a			call str_at_display 
14c8			 
14c8				; display a 
14c8 11 89 15			ld de, .regstatea 
14cb 3e 14			ld a, display_row_2 
14cd cd c9 0a			call str_at_display 
14d0			 
14d0 e1				pop hl 
14d1			;	ld h,0 
14d1			;	ld l, a 
14d1 3e 17			ld a, display_row_2+3 
14d3 cd 58 13			call display_word_at 
14d6			 
14d6			 
14d6				; display hl 
14d6			 
14d6			 
14d6 11 7d 15			ld de, .regstatehl 
14d9 3e 1e			ld a, display_row_2+10 
14db cd c9 0a			call str_at_display 
14de			 
14de e1				pop hl 
14df 3e 21			ld a, display_row_2+13 
14e1 cd 58 13			call display_word_at 
14e4			 
14e4				 
14e4				; display de 
14e4			 
14e4 11 81 15			ld de, .regstatede 
14e7 3e 28			ld a, display_row_3 
14e9 cd c9 0a			call str_at_display 
14ec			 
14ec e1				pop hl 
14ed			;	ld h,d 
14ed			;	ld l, e 
14ed 3e 2b			ld a, display_row_3+3 
14ef cd 58 13			call display_word_at 
14f2			 
14f2			 
14f2				; display bc 
14f2			 
14f2 11 85 15			ld de, .regstatebc 
14f5 3e 32			ld a, display_row_3+10 
14f7 cd c9 0a			call str_at_display 
14fa			 
14fa e1				pop hl 
14fb			;	ld h,b 
14fb			;	ld l, c 
14fb 3e 35			ld a, display_row_3+13 
14fd cd 58 13			call display_word_at 
1500			 
1500			 
1500				; display dsp 
1500			 
1500 11 8d 15			ld de, .regstatedsp 
1503 3e 3c			ld a, display_row_4 
1505 cd c9 0a			call str_at_display 
1508			 
1508				 
1508 2a a5 f9			ld hl,(cli_data_sp) 
150b 3e 40			ld a, display_row_4+4 
150d cd 58 13			call display_word_at 
1510			 
1510				; display rsp 
1510			 
1510 11 92 15			ld de, .regstatersp 
1513 3e 46			ld a, display_row_4+10 
1515 cd c9 0a			call str_at_display 
1518			 
1518				 
1518 2a a9 f9			ld hl,(cli_ret_sp) 
151b 3e 4a			ld a, display_row_4+14 
151d cd 58 13			call display_word_at 
1520			 
1520 cd d9 0a			call update_display 
1523			 
1523			;	call delay1s 
1523			;	call delay1s 
1523			;	call delay1s 
1523			 
1523			 
1523			;	call next_page_prompt 
1523			 
1523				; restore  
1523			 
1523 f1				pop af 
1524 e1				pop hl 
1525 c1				pop bc 
1526 d1				pop de 
1527 c9				ret 
1528			 
1528 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
153c .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1551 .. 00		.ptrstate:	db "Ptr State",0 
155b .. 00		.ptrcliptr:     db "cli_ptr",0 
1563 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
156d .. 00		.regstate:	db "Reg State (1/0)",0 
157d .. 00		.regstatehl:	db "HL:",0 
1581 .. 00		.regstatede:	db "DE:",0 
1585 .. 00		.regstatebc:	db "BC:",0 
1589 .. 00		.regstatea:	db "A :",0 
158d .. 00		.regstatedsp:	db "DSP:",0 
1592 .. 00		.regstatersp:	db "RSP:",0 
1597			 
1597			display_dump_at_hl: 
1597 e5				push hl 
1598 d5				push de 
1599 c5				push bc 
159a f5				push af 
159b			 
159b 22 db f2			ld (os_cur_ptr),hl	 
159e cd b6 0a			call clear_display 
15a1 cd ed 17			call dumpcont 
15a4			;	call delay1s 
15a4			;	call next_page_prompt 
15a4			 
15a4			 
15a4 f1				pop af 
15a5 c1				pop bc 
15a6 d1				pop de 
15a7 e1				pop hl 
15a8 c9				ret 
15a9			 
15a9			;if ENABLE_BASIC 
15a9			;	include "nascombasic.asm" 
15a9			;	basic: 
15a9			;	include "forth/FORTH.ASM" 
15a9			;endif 
15a9			 
15a9			; eof 
15a9			 
15a9			 
# End of file firmware_diags.asm
15a9			  
15a9			  
15a9			  
15a9			  
15a9			; eof  
15a9			  
# End of file firmware.asm
15a9			 
15a9			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
15a9			;if BASE_KEV  
15a9			;baseram: equ 08000h 
15a9			;endif 
15a9			 
15a9			;if BASE_SC114 
15a9			;baseram:     equ    endofcode 
15a9			;endif 
15a9			 
15a9			 
15a9			; start system 
15a9			 
15a9			coldstart: 
15a9				; set sp 
15a9				; di/ei 
15a9			 
15a9 f3				di 
15aa 31 fd ff			ld sp, tos 
15ad			;	ei 
15ad			 
15ad			 
15ad				; disable breakpoint by default 
15ad			 
15ad 3e 2a			ld a,'*' 
15af 32 b7 ef			ld (os_view_disable),a 
15b2			 
15b2				; init hardware 
15b2			 
15b2				; init keyboard and screen hardware 
15b2			 
15b2 cd 03 00			call hardware_init 
15b5			 
15b5			 
15b5				; detect if any keys are held down to enable breakpoints at start up 
15b5			 
15b5 cd 0e 63			call cin  
15b8 fe 00			cp 0 
15ba 28 03			jr z, .nokeys 
15bc			 
15bc cd cd 12			call hardware_diags 
15bf			 
15bf			;	ld de, .bpen 
15bf			;	ld a, display_row_4 
15bf			;	call str_at_display 
15bf			;	call update_display 
15bf			; 
15bf			;	ld a,0 
15bf			;	ld (os_view_disable),a 
15bf			; 
15bf			;.bpwait: 
15bf			;	call cin 
15bf			;	cp 0 
15bf			;	jr z, .bpwait 
15bf			;	jr .nokeys 
15bf			; 
15bf			; 
15bf			;.bpen:  db "Break points enabled!",0 
15bf			 
15bf			 
15bf			 
15bf			 
15bf			 
15bf			 
15bf			.nokeys: 
15bf			 
15bf			 
15bf				 
15bf			 
15bf			;jp  testkey 
15bf			 
15bf			;call storage_get_block_0 
15bf			; 
15bf			;ld hl, 0 
15bf			;ld de, store_page 
15bf			;call storage_read_block 
15bf			 
15bf				 
15bf			;ld hl, 10 
15bf			;ld de, store_page 
15bf			;call storage_read_block 
15bf			 
15bf			 
15bf			 
15bf			 
15bf			 
15bf			;stop:	nop 
15bf			;	jp stop 
15bf			 
15bf			 
15bf			 
15bf			main: 
15bf cd b6 0a			call clear_display 
15c2 cd d9 0a			call update_display 
15c5			 
15c5			 
15c5			 
15c5			;	call testlcd 
15c5			 
15c5			 
15c5			 
15c5 cd 33 1b			call forth_init 
15c8			 
15c8			 
15c8			warmstart: 
15c8 cd 09 1b			call forth_warmstart 
15cb			 
15cb				; run startup word load 
15cb			        ; TODO prevent this running at warmstart after crash  
15cb			 
15cb				if STARTUP_ENABLE 
15cb cd 77 5e				call forth_startup 
15ce				endif 
15ce			 
15ce				; show free memory after boot 
15ce 11 75 16			ld de, freeram 
15d1 3e 00			ld a, display_row_1 
15d3 cd c9 0a			call str_at_display 
15d6			 
15d6			; Or use heap_size word???? 
15d6 21 ac ef			ld hl, heap_end 
15d9 11 0e 80			ld de, heap_start 
15dc ed 52			sbc hl, de 
15de e5				push hl 
15df 7c				ld a,h	         	 
15e0 21 bd f2			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
15e3 cd 10 0f			call hexout 
15e6 e1			   	pop hl 
15e7			 
15e7 7d				ld a,l 
15e8 21 bf f2			ld hl, os_word_scratch+2 
15eb cd 10 0f			call hexout 
15ee 21 c1 f2			ld hl, os_word_scratch+4 
15f1 3e 00			ld a, 0 
15f3 77				ld (hl),a 
15f4 11 bd f2			ld de, os_word_scratch 
15f7 3e 0d			ld a, display_row_1 + 13 
15f9 cd c9 0a			call str_at_display 
15fc cd d9 0a			call update_display 
15ff			 
15ff			 
15ff				;call demo 
15ff			 
15ff			 
15ff				; init scratch input area for cli commands 
15ff			 
15ff 21 df f2			ld hl, os_cli_cmd 
1602 3e 00			ld a,0 
1604 77				ld (hl),a 
1605 23				inc hl 
1606 77				ld (hl),a 
1607			 
1607 3e 00			ld a,0 
1609 32 de f3			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
160c			 
160c 32 db f2			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
160f 32 dc f2			ld (os_cur_ptr+1),a	 
1612			 
1612 32 bd f2			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1615 32 be f2			ld (os_word_scratch+1),a	 
1618				 
1618			 
1618				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1618 21 df f2			ld hl, os_cli_cmd 
161b			 
161b 3e 00			ld a, 0		 ; init cli input 
161d 77				ld (hl), a 
161e 3e 14			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1620			cli: 
1620				; show cli prompt 
1620				;push af 
1620				;ld a, 0 
1620				;ld de, prompt 
1620				;call str_at_display 
1620			 
1620				;call update_display 
1620				;pop af 
1620				;inc a 
1620				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1620 0e 00			ld c, 0 
1622 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1624 1e 28			ld e, 40 
1626			 
1626 21 df f2			ld hl, os_cli_cmd 
1629			 
1629				STACKFRAME OFF $fefe $9f9f 
1629				if DEBUG_STACK_IMB 
1629					if OFF 
1629						exx 
1629						ld de, $fefe 
1629						ld a, d 
1629						ld hl, curframe 
1629						call hexout 
1629						ld a, e 
1629						ld hl, curframe+2 
1629						call hexout 
1629						ld hl, $fefe 
1629						push hl 
1629						ld hl, $9f9f 
1629						push hl 
1629						exx 
1629					endif 
1629				endif 
1629			endm 
# End of macro STACKFRAME
1629			 
1629 cd 3c 0c			call input_str 
162c			 
162c				STACKFRAMECHK OFF $fefe $9f9f 
162c				if DEBUG_STACK_IMB 
162c					if OFF 
162c						exx 
162c						ld hl, $9f9f 
162c						pop de   ; $9f9f 
162c						call cmp16 
162c						jr nz, .spnosame 
162c						ld hl, $fefe 
162c						pop de   ; $fefe 
162c						call cmp16 
162c						jr z, .spfrsame 
162c						.spnosame: call showsperror 
162c						.spfrsame: nop 
162c						exx 
162c					endif 
162c				endif 
162c			endm 
# End of macro STACKFRAMECHK
162c			 
162c				; copy input to last command 
162c			 
162c 21 df f2			ld hl, os_cli_cmd 
162f 11 de f3			ld de, os_last_cmd 
1632 01 ff 00			ld bc, 255 
1635 ed b0			ldir 
1637			 
1637				; wipe current buffer 
1637			 
1637 3e 00			ld a, 0 
1639 21 df f2			ld hl, os_cli_cmd 
163c 11 e0 f2			ld de, os_cli_cmd+1 
163f 01 fe 00			ld bc, 254 
1642 ed b0			ldir 
1644				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1644			;	call strcpy 
1644			;	ld a, 0 
1644			;	ld (hl), a 
1644			;	inc hl 
1644			;	ld (hl), a 
1644			;	inc hl 
1644			;	ld (hl), a 
1644			 
1644				; switch frame buffer to program  
1644			 
1644 21 02 fb				ld hl, display_fb1 
1647 22 5e fa				ld (display_fb_active), hl 
164a			 
164a			;	nop 
164a				STACKFRAME ON $fbfe $8f9f 
164a				if DEBUG_STACK_IMB 
164a					if ON 
164a						exx 
164a						ld de, $fbfe 
164a						ld a, d 
164a						ld hl, curframe 
164a						call hexout 
164a						ld a, e 
164a						ld hl, curframe+2 
164a						call hexout 
164a						ld hl, $fbfe 
164a						push hl 
164a						ld hl, $8f9f 
164a						push hl 
164a						exx 
164a					endif 
164a				endif 
164a			endm 
# End of macro STACKFRAME
164a				; first time into the parser so pass over the current scratch pad 
164a 21 df f2			ld hl,os_cli_cmd 
164d				; tokenise the entered statement(s) in HL 
164d cd ac 1b			call forthparse 
1650			        ; exec forth statements in top of return stack 
1650 cd ec 1b			call forthexec 
1653				;call forthexec_cleanup 
1653			;	call parsenext 
1653			 
1653				STACKFRAMECHK ON $fbfe $8f9f 
1653				if DEBUG_STACK_IMB 
1653					if ON 
1653						exx 
1653						ld hl, $8f9f 
1653						pop de   ; $8f9f 
1653						call cmp16 
1653						jr nz, .spnosame 
1653						ld hl, $fbfe 
1653						pop de   ; $fbfe 
1653						call cmp16 
1653						jr z, .spfrsame 
1653						.spnosame: call showsperror 
1653						.spfrsame: nop 
1653						exx 
1653					endif 
1653				endif 
1653			endm 
# End of macro STACKFRAMECHK
1653				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1653			 
1653 3e 3c			ld a, display_row_4 
1655 11 87 16			ld de, endprog 
1658			 
1658 cd d9 0a			call update_display		 
165b			 
165b cd e5 18			call next_page_prompt 
165e			 
165e				; switch frame buffer to cli 
165e			 
165e 21 53 fb				ld hl, display_fb0 
1661 22 5e fa				ld (display_fb_active), hl 
1664			 
1664			 
1664 cd b6 0a		        call clear_display 
1667 cd d9 0a			call update_display		 
166a			 
166a 21 df f2			ld hl, os_cli_cmd 
166d			 
166d 3e 00			ld a, 0		 ; init cli input 
166f 77				ld (hl), a 
1670			 
1670				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1670			 
1670				; now on last line 
1670			 
1670				; TODO scroll screen up 
1670			 
1670				; TODO instead just clear screen and place at top of screen 
1670			 
1670			;	ld a, 0 
1670			;	ld (f_cursor_ptr),a 
1670			 
1670				;call clear_display 
1670				;call update_display 
1670			 
1670				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1670 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1672 c3 20 16			jp cli 
1675			 
1675 .. 00		freeram: db "Free bytes: $",0 
1683 ..			asc: db "1A2F" 
1687 .. 00		endprog: db "End prog...",0 
1693			 
1693			testenter2:   
1693 21 ea ef			ld hl,scratch+50 
1696 22 db f2			ld (os_cur_ptr),hl 
1699 c3 20 16			jp cli 
169c			 
169c			testenter:  
169c			 
169c 21 83 16			ld hl,asc 
169f			;	ld a,(hl) 
169f			;	call nibble2val 
169f cd 66 0f			call get_byte 
16a2			 
16a2			 
16a2			;	ld a,(hl) 
16a2			;	call atohex 
16a2			 
16a2			;	call fourehexhl 
16a2 32 ea ef			ld (scratch+50),a 
16a5			 
16a5			 
16a5			 
16a5 21 85 16			ld hl,asc+2 
16a8			;	ld a, (hl) 
16a8			;	call nibble2val 
16a8 cd 66 0f			call get_byte 
16ab			 
16ab			;	call fourehexhl 
16ab 32 ec ef			ld (scratch+52),a 
16ae				 
16ae 21 ea ef			ld hl,scratch+50 
16b1 22 db f2			ld (os_cur_ptr),hl 
16b4 c3 20 16			jp cli 
16b7			 
16b7			enter:	 
16b7 3a bc ef			ld a,(scratch+4) 
16ba fe 00			cp 0 
16bc 28 0c			jr z, .entercont 
16be				; no, not a null term line so has an address to work out.... 
16be			 
16be 21 ba ef			ld hl,scratch+2 
16c1 cd c6 0f			call get_word_hl 
16c4			 
16c4 22 db f2			ld (os_cur_ptr),hl	 
16c7 c3 20 16			jp cli 
16ca			 
16ca			 
16ca			.entercont:  
16ca			 
16ca 21 ba ef			ld hl, scratch+2 
16cd cd 66 0f			call get_byte 
16d0			 
16d0 2a db f2		   	ld hl,(os_cur_ptr) 
16d3 77					ld (hl),a 
16d4 23					inc hl 
16d5 22 db f2				ld (os_cur_ptr),hl 
16d8				 
16d8			; get byte  
16d8			 
16d8			 
16d8 c3 20 16			jp cli 
16db			 
16db			 
16db			; basic monitor support 
16db			 
16db			monitor: 
16db				;  
16db cd b6 0a			call clear_display 
16de 3e 00			ld a, 0 
16e0 11 28 17			ld de, .monprompt 
16e3 cd c9 0a			call str_at_display 
16e6 cd d9 0a			call update_display 
16e9			 
16e9				; get a monitor command 
16e9			 
16e9 0e 00			ld c, 0     ; entry at top left 
16eb 16 64			ld d, 100   ; max buffer size 
16ed 1e 0f			ld e, 15    ; input scroll area 
16ef 3e 00			ld a, 0     ; init string 
16f1 21 b6 f1			ld hl, os_input 
16f4 77				ld (hl), a 
16f5 23				inc hl 
16f6 77				ld (hl), a 
16f7 21 b6 f1			ld hl, os_input 
16fa 3e 01			ld a, 1     ; init string 
16fc cd 3c 0c			call input_str 
16ff			 
16ff cd b6 0a		        call clear_display 
1702 cd d9 0a			call update_display		 
1705			 
1705 3a b6 f1			ld a, (os_input) 
1708 cd 64 10			call toUpper 
170b fe 48		        cp 'H' 
170d 28 6f		        jr z, .monhelp 
170f fe 44			cp 'D'		; dump 
1711 ca 9f 17			jp z, .mondump	 
1714 fe 43			cp 'C'		; dump 
1716 ca b9 17			jp z, .moncdump	 
1719 fe 4d			cp 'M'		; dump 
171b ca 2a 17			jp z, .moneditstart 
171e fe 55			cp 'U'		; dump 
1720 28 14			jr z, .monedit	 
1722 fe 51			cp 'Q'		; dump 
1724 c8				ret z	 
1725			 
1725			 
1725				; TODO "S" to access symbol by name and not need the address 
1725				; TODO "F" to find a string in memory 
1725			 
1725 c3 db 16			jp monitor 
1728			 
1728 .. 00		.monprompt: db ">", 0 
172a			 
172a			.moneditstart: 
172a				; get starting address 
172a			 
172a 21 b8 f1			ld hl,os_input+2 
172d cd c6 0f			call get_word_hl 
1730			 
1730 22 db f2			ld (os_cur_ptr),hl	 
1733			 
1733 c3 db 16			jp monitor 
1736			 
1736			.monedit: 
1736				; get byte to load 
1736			 
1736 21 b8 f1			ld hl,os_input+2 
1739 cd 66 0f			call get_byte 
173c			 
173c				; get address to update 
173c 2a db f2			ld hl, (os_cur_ptr) 
173f			 
173f				; update byte 
173f			 
173f 77				ld (hl), a 
1740			 
1740				; move to next address and save it 
1740			 
1740 23				inc hl 
1741 22 db f2			ld (os_cur_ptr),hl	 
1744			 
1744 c3 db 16			jp monitor 
1747			 
1747			 
1747 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
175b .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1777 .. 00		.monhelptext3:  db "Q-Quit",0 
177e			        
177e			.monhelp: 
177e 3e 00			ld a, display_row_1 
1780 11 47 17		        ld de, .monhelptext1 
1783			 
1783 cd c9 0a			call str_at_display 
1786 3e 14			ld a, display_row_2 
1788 11 5b 17		        ld de, .monhelptext2 
178b					 
178b cd c9 0a			call str_at_display 
178e 3e 28			ld a, display_row_3 
1790 11 77 17		        ld de, .monhelptext3 
1793					 
1793 cd c9 0a			call str_at_display 
1796 cd d9 0a			call update_display		 
1799			 
1799 cd e5 18			call next_page_prompt 
179c c3 db 16			jp monitor 
179f			 
179f			.mondump:    
179f 21 b8 f1			ld hl,os_input+2 
17a2 cd c6 0f			call get_word_hl 
17a5			 
17a5 22 db f2			ld (os_cur_ptr),hl	 
17a8 cd ed 17			call dumpcont 
17ab 3e 3c			ld a, display_row_4 
17ad 11 87 16			ld de, endprog 
17b0			 
17b0 cd d9 0a			call update_display		 
17b3			 
17b3 cd e5 18			call next_page_prompt 
17b6 c3 db 16			jp monitor 
17b9			.moncdump: 
17b9 cd ed 17			call dumpcont 
17bc 3e 3c			ld a, display_row_4 
17be 11 87 16			ld de, endprog 
17c1			 
17c1 cd d9 0a			call update_display		 
17c4			 
17c4 cd e5 18			call next_page_prompt 
17c7 c3 db 16			jp monitor 
17ca			 
17ca			 
17ca			; TODO symbol access  
17ca			 
17ca			.symbols:     ;; A list of symbols that can be called up  
17ca 53 fb			dw display_fb0 
17cc .. 00			db "fb0",0  
17d0 e8 f9		     	dw store_page 
17d2 .. 00			db "store_page",0 
17dd			 
17dd			 
17dd			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
17dd			 
17dd 3a b9 ef			ld a,(scratch+1) 
17e0 fe 00			cp 0 
17e2 28 09			jr z, dumpcont 
17e4			 
17e4				; no, not a null term line so has an address to work out.... 
17e4			 
17e4 21 ba ef			ld hl,scratch+2 
17e7 cd c6 0f			call get_word_hl 
17ea			 
17ea 22 db f2			ld (os_cur_ptr),hl	 
17ed			 
17ed			 
17ed			 
17ed			dumpcont: 
17ed			 
17ed				; dump bytes at ptr 
17ed			 
17ed			 
17ed 3e 00			ld a, display_row_1 
17ef 2a 5e fa			ld hl, (display_fb_active) 
17f2 cd 0f 0c			call addatohl 
17f5 cd 1d 18			call .dumpbyterow 
17f8			 
17f8 3e 14			ld a, display_row_2 
17fa 2a 5e fa			ld hl, (display_fb_active) 
17fd cd 0f 0c			call addatohl 
1800 cd 1d 18			call .dumpbyterow 
1803			 
1803			 
1803 3e 28			ld a, display_row_3 
1805 2a 5e fa			ld hl, (display_fb_active) 
1808 cd 0f 0c			call addatohl 
180b cd 1d 18			call .dumpbyterow 
180e			 
180e 3e 3c			ld a, display_row_4 
1810 2a 5e fa			ld hl, (display_fb_active) 
1813 cd 0f 0c			call addatohl 
1816 cd 1d 18			call .dumpbyterow 
1819			 
1819 cd d9 0a			call update_display 
181c			;		jp cli 
181c c9				ret 
181d			 
181d			.dumpbyterow: 
181d			 
181d				;push af 
181d			 
181d e5				push hl 
181e			 
181e				; calc where to poke the ascii 
181e			if display_cols == 20 
181e 3e 10			ld a, 16 
1820			else 
1820				ld a, 31 
1820			endif 
1820			 
1820 cd 0f 0c			call addatohl 
1823 22 bd f2			ld (os_word_scratch),hl  		; save pos for later 
1826			 
1826			 
1826			; display decoding address 
1826 2a db f2		   	ld hl,(os_cur_ptr) 
1829			 
1829 7c				ld a,h 
182a e1				pop hl 
182b e5				push hl 
182c			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
182c cd 10 0f			call hexout 
182f 2a db f2		   	ld hl,(os_cur_ptr) 
1832			 
1832 7d				ld a,l 
1833 e1				pop hl 
1834 23				inc hl 
1835 23				inc hl 
1836 e5				push hl 
1837			;	ld hl, os_word_scratch+2 
1837 cd 10 0f			call hexout 
183a e1				pop hl 
183b 23				inc hl 
183c 23				inc hl 
183d				;ld hl, os_word_scratch+4 
183d 3e 3a			ld a, ':' 
183f 77				ld (hl),a 
1840 23				inc hl 
1841				;ld a, 0 
1841				;ld (hl),a 
1841				;ld de, os_word_scratch 
1841				;pop af 
1841				;push af 
1841			;		ld a, display_row_2 
1841			;		call str_at_display 
1841			;		call update_display 
1841			 
1841			 
1841			;pop af 
1841			;	add 5 
1841			 
1841			if display_cols == 20 
1841 06 04			ld b, 4 
1843			else 
1843				ld b, 8 
1843			endif	 
1843			 
1843			.dumpbyte: 
1843 c5				push bc 
1844 e5				push hl 
1845			 
1845			 
1845 2a db f2		   	ld hl,(os_cur_ptr) 
1848 7e					ld a,(hl) 
1849			 
1849					; poke the ascii to display 
1849 2a bd f2				ld hl,(os_word_scratch) 
184c 77					ld (hl),a 
184d 23					inc hl 
184e 22 bd f2				ld (os_word_scratch),hl 
1851			 
1851					 
1851			 
1851			 
1851 e1					pop hl 
1852 e5					push hl 
1853			 
1853 cd 10 0f				call hexout 
1856			 
1856					 
1856 2a db f2		   	ld hl,(os_cur_ptr) 
1859 23				inc hl 
185a 22 db f2		   	ld (os_cur_ptr),hl 
185d			 
185d e1					pop hl 
185e 23					inc hl 
185f 23					inc hl 
1860 23					inc hl 
1861			 
1861			 
1861			 
1861					;ld a,0 
1861					;ld (os_word_scratch+2),a 
1861					;pop af 
1861					;push af 
1861			 
1861					;ld de, os_word_scratch 
1861					;call str_at_display 
1861			;		call update_display 
1861			;		pop af 
1861 c1					pop bc 
1862 c6 03				add 3 
1864 10 dd			djnz .dumpbyte 
1866			 
1866				 
1866			 
1866 c9				ret 
1867			 
1867			jump:	 
1867			 
1867 21 ba ef			ld hl,scratch+2 
186a cd c6 0f			call get_word_hl 
186d				;ld hl,(scratch+2) 
186d				;call fourehexhl 
186d			 
186d 22 db f2			ld (os_cur_ptr),hl	 
1870			 
1870 e9				jp (hl) 
1871			 
1871			 
1871			 
1871			; TODO implement a basic monitor mode to start with 
1871			 
1871			 
1871			 
1871			 
1871			 
1871			 
1871			 
1871			 
1871			 
1871			; testing and demo code during development 
1871			 
1871			 
1871 .. 00		str1: db "Enter some text...",0 
1884 .. 00		clear: db "                    ",0 
1899			 
1899			demo: 
1899			 
1899			 
1899			 
1899			;	call update_display 
1899			 
1899				; init scratch input area for testing 
1899 21 b8 ef			ld hl, scratch	 
189c 3e 00			ld a,0 
189e 77				ld (hl),a 
189f			 
189f			 
189f 3e 14		            LD   A, display_row_2 
18a1			;            CALL fLCD_Pos       ;Position cursor to location in A 
18a1 11 71 18		            LD   DE, str1 
18a4 cd c9 0a			call str_at_display 
18a7			 
18a7			;            CALL fLCD_Str       ;Display string pointed to by DE 
18a7			cloop:	 
18a7 3e 28		            LD   A, display_row_3 
18a9			;            CALL fLCD_Pos       ;Position cursor to location in A 
18a9 11 84 18		            LD   DE, clear 
18ac			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
18ac cd c9 0a				call str_at_display 
18af 3e 3c			ld a, display_row_4 
18b1 11 e1 18			ld de, prompt 
18b4			 
18b4 cd c9 0a				call str_at_display 
18b7 cd d9 0a			call update_display 
18ba			 
18ba 3e 55			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
18bc 16 0a			ld d, 10 
18be 21 b8 ef			ld hl, scratch	 
18c1 cd 3c 0c			call input_str 
18c4			 
18c4			;	call clear_display 
18c4			;'	call update_display 
18c4			 
18c4 3e 00		            LD   A, display_row_1 
18c6			;            CALL fLCD_Pos       ;Position cursor to location in A 
18c6 11 84 18		            LD   DE, clear 
18c9 cd c9 0a				call str_at_display 
18cc			;            CALL fLCD_Str       ;Display string pointed to by DE 
18cc 3e 00		            LD   A, display_row_1 
18ce			;            CALL fLCD_Pos       ;Position cursor to location in A 
18ce 11 b8 ef		            LD   DE, scratch 
18d1			;            CALL fLCD_Str       ;Display string pointed to by DE 
18d1 cd c9 0a				call str_at_display 
18d4 cd d9 0a			call update_display 
18d7			 
18d7 3e 00				ld a,0 
18d9 21 b8 ef			ld hl, scratch 
18dc 77				ld (hl),a 
18dd			 
18dd 00				nop 
18de c3 a7 18			jp cloop 
18e1			 
18e1			 
18e1			 
18e1			; OS Prompt 
18e1			 
18e1 .. 00		prompt: db ">",0 
18e3 .. 00		endprg: db "?",0 
18e5			 
18e5			 
18e5			; handy next page prompt 
18e5			next_page_prompt: 
18e5 e5				push hl 
18e6 d5				push de 
18e7 f5				push af 
18e8 c5				push bc 
18e9			 
18e9 3e 4f			ld a,display_row_4 + display_cols - 1 
18eb 11 e3 18		        ld de, endprg 
18ee cd c9 0a			call str_at_display 
18f1 cd d9 0a			call update_display 
18f4 cd fd 62			call cin_wait 
18f7 c1				pop bc 
18f8 f1				pop af 
18f9 d1				pop de 
18fa e1				pop hl 
18fb			 
18fb			 
18fb c9				ret 
18fc			 
18fc			 
18fc			; forth parser 
18fc			 
18fc			; My forth kernel 
18fc			include "forth_kernel.asm" 
18fc			; 
18fc			; kernel to the forth OS 
18fc			 
18fc			DS_TYPE_STR: equ 1     ; string type 
18fc			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
18fc			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
18fc			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
18fc			 
18fc			FORTH_PARSEV1: equ 0 
18fc			FORTH_PARSEV2: equ 0 
18fc			FORTH_PARSEV3: equ 0 
18fc			FORTH_PARSEV4: equ 0 
18fc			FORTH_PARSEV5: equ 1 
18fc			 
18fc			;if FORTH_PARSEV5 
18fc			;	FORTH_END_BUFFER: equ 0 
18fc			;else 
18fc			FORTH_END_BUFFER: equ 127 
18fc			;endif 
18fc			 
18fc			FORTH_TRUE: equ 1 
18fc			FORTH_FALSE: equ 0 
18fc			 
18fc			if FORTH_PARSEV4 
18fc			include "forth_stackops.asm" 
18fc			endif 
18fc			 
18fc			if FORTH_PARSEV5 
18fc			include "forth_stackopsv5.asm" 
18fc			 
18fc			; Stack operations for v5 parser on wards 
18fc			; * DATA stack 
18fc			; * LOOP stack 
18fc			; * RETURN stack 
18fc			 
18fc			 
18fc			 
18fc			FORTH_CHK_DSP_UNDER: macro 
18fc				push hl 
18fc				push de 
18fc				ld hl,(cli_data_sp) 
18fc				ld de, cli_data_stack 
18fc				call cmp16 
18fc				jp c, fault_dsp_under 
18fc				pop de 
18fc				pop hl 
18fc				endm 
18fc			 
18fc			 
18fc			FORTH_CHK_RSP_UNDER: macro 
18fc				push hl 
18fc				push de 
18fc				ld hl,(cli_ret_sp) 
18fc				ld de, cli_ret_stack 
18fc				call cmp16 
18fc				jp c, fault_rsp_under 
18fc				pop de 
18fc				pop hl 
18fc				endm 
18fc			 
18fc			FORTH_CHK_LOOP_UNDER: macro 
18fc				push hl 
18fc				push de 
18fc				ld hl,(cli_loop_sp) 
18fc				ld de, cli_loop_stack 
18fc				call cmp16 
18fc				jp c, fault_loop_under 
18fc				pop de 
18fc				pop hl 
18fc				endm 
18fc			 
18fc			FORTH_ERR_TOS_NOTSTR: macro 
18fc				; TOSO might need more for checks when used 
18fc				push af 
18fc				ld a,(hl) 
18fc				cp DS_TYPE_STR 
18fc				jp nz, type_faultn   
18fc				pop af 
18fc				endm 
18fc			 
18fc			FORTH_ERR_TOS_NOTNUM: macro 
18fc				push af 
18fc				ld a,(hl) 
18fc				cp DS_TYPE_INUM 
18fc				jp nz, type_faultn   
18fc				pop af 
18fc				endm 
18fc			 
18fc			 
18fc			; increase data stack pointer and save hl to it 
18fc				 
18fc			FORTH_DSP_NEXT: macro 
18fc				call macro_forth_dsp_next 
18fc				endm 
18fc			 
18fc			 
18fc			macro_forth_dsp_next: 
18fc				if DEBUG_FORTH_STACK_GUARD 
18fc cd 41 5f				call check_stacks 
18ff				endif 
18ff e5				push hl 
1900 d5				push de 
1901 eb				ex de,hl 
1902 2a a5 f9			ld hl,(cli_data_sp) 
1905 23				inc hl 
1906 23				inc hl 
1907			 
1907			; PARSEV5 
1907 23				inc hl 
1908 22 a5 f9			ld (cli_data_sp),hl 
190b 73				ld (hl), e 
190c 23				inc hl 
190d 72				ld (hl), d 
190e d1				pop de 
190f e1				pop hl 
1910				if DEBUG_FORTH_STACK_GUARD 
1910 cd 41 5f				call check_stacks 
1913				endif 
1913 c9				ret 
1914			 
1914			 
1914			; increase ret stack pointer and save hl to it 
1914				 
1914			FORTH_RSP_NEXT: macro 
1914				call macro_forth_rsp_next 
1914				endm 
1914			 
1914			macro_forth_rsp_next: 
1914				if DEBUG_FORTH_STACK_GUARD 
1914 cd 41 5f				call check_stacks 
1917				endif 
1917 e5				push hl 
1918 d5				push de 
1919 eb				ex de,hl 
191a 2a a9 f9			ld hl,(cli_ret_sp) 
191d 23				inc hl 
191e 23				inc hl 
191f 22 a9 f9			ld (cli_ret_sp),hl 
1922 73				ld (hl), e 
1923 23				inc hl 
1924 72				ld (hl), d 
1925 d1				pop de 
1926 e1				pop hl 
1927				if DEBUG_FORTH_STACK_GUARD 
1927 cd 41 5f				call check_stacks 
192a				endif 
192a c9				ret 
192b			 
192b			; get current ret stack pointer and save to hl  
192b				 
192b			FORTH_RSP_TOS: macro 
192b				call macro_forth_rsp_tos 
192b				endm 
192b			 
192b			macro_forth_rsp_tos: 
192b				;push de 
192b 2a a9 f9			ld hl,(cli_ret_sp) 
192e cd 66 19			call loadhlptrtohl 
1931				;ld e, (hl) 
1931				;inc hl 
1931				;ld d, (hl) 
1931				;ex de, hl 
1931					if DEBUG_FORTH_WORDS 
1931			;			DMARK "RST" 
1931						CALLMONITOR 
1931 cd d3 13			call break_point_state  
1934				endm  
# End of macro CALLMONITOR
1934					endif 
1934				;pop de 
1934 c9				ret 
1935			 
1935			; pop ret stack pointer 
1935				 
1935			FORTH_RSP_POP: macro 
1935				call macro_forth_rsp_pop 
1935				endm 
1935			 
1935			 
1935			macro_forth_rsp_pop: 
1935				if DEBUG_FORTH_STACK_GUARD 
1935			;		DMARK "RPP" 
1935 cd 41 5f				call check_stacks 
1938					FORTH_CHK_RSP_UNDER 
1938 e5				push hl 
1939 d5				push de 
193a 2a a9 f9			ld hl,(cli_ret_sp) 
193d 11 23 f9			ld de, cli_ret_stack 
1940 cd 2d 0c			call cmp16 
1943 da 55 60			jp c, fault_rsp_under 
1946 d1				pop de 
1947 e1				pop hl 
1948				endm 
# End of macro FORTH_CHK_RSP_UNDER
1948				endif 
1948 e5				push hl 
1949 2a a9 f9			ld hl,(cli_ret_sp) 
194c			 
194c			 
194c				if FORTH_ENABLE_FREE 
194c			 
194c					; get pointer 
194c			 
194c					push de 
194c					push hl 
194c			 
194c					ld e, (hl) 
194c					inc hl 
194c					ld d, (hl) 
194c			 
194c					ex de, hl 
194c					call free 
194c			 
194c					pop hl 
194c					pop de 
194c			 
194c			 
194c				endif 
194c			 
194c			 
194c 2b				dec hl 
194d 2b				dec hl 
194e 22 a9 f9			ld (cli_ret_sp), hl 
1951				; do stack underflow checks 
1951 e1				pop hl 
1952				if DEBUG_FORTH_STACK_GUARD 
1952 cd 41 5f				call check_stacks 
1955					FORTH_CHK_RSP_UNDER 
1955 e5				push hl 
1956 d5				push de 
1957 2a a9 f9			ld hl,(cli_ret_sp) 
195a 11 23 f9			ld de, cli_ret_stack 
195d cd 2d 0c			call cmp16 
1960 da 55 60			jp c, fault_rsp_under 
1963 d1				pop de 
1964 e1				pop hl 
1965				endm 
# End of macro FORTH_CHK_RSP_UNDER
1965				endif 
1965 c9				ret 
1966			 
1966			 
1966			 
1966			; routine to load word pointed to by hl into hl 
1966			 
1966			loadhlptrtohl: 
1966			 
1966 d5				push de 
1967 5e				ld e, (hl) 
1968 23				inc hl 
1969 56				ld d, (hl) 
196a eb				ex de, hl 
196b d1				pop de 
196c			 
196c c9				ret 
196d			 
196d			 
196d			 
196d			 
196d			 
196d			; push a number held in HL onto the data stack 
196d			; entry point for pushing a value when already in hl used in function above 
196d			 
196d			forth_push_numhl: 
196d			 
196d e5				push hl    ; save value to push 
196e			 
196e			if DEBUG_FORTH_PUSH 
196e				; see if disabled 
196e			 
196e			 
196e				push af 
196e				ld a, (os_view_disable) 
196e				cp '*' 
196e				jr z, .pskip2 
196e				push hl 
196e			push hl 
196e				call clear_display 
196e			pop hl 
196e				ld a,h 
196e				ld hl, os_word_scratch 
196e				call hexout 
196e				pop hl 
196e				ld a,l 
196e				ld hl, os_word_scratch+2 
196e				call hexout 
196e			 
196e				ld hl, os_word_scratch+4 
196e				ld a,0 
196e				ld (hl),a 
196e				ld de,os_word_scratch 
196e					ld a, display_row_2 
196e					call str_at_display 
196e				ld de, .push_num 
196e				ld a, display_row_1 
196e			 
196e					call str_at_display 
196e			 
196e			 
196e				call update_display 
196e				call delay1s 
196e				call delay1s 
196e			.pskip2:  
196e			 
196e				pop af 
196e			endif	 
196e			 
196e			 
196e				FORTH_DSP_NEXT 
196e cd fc 18			call macro_forth_dsp_next 
1971				endm 
# End of macro FORTH_DSP_NEXT
1971			 
1971 2a a5 f9			ld hl, (cli_data_sp) 
1974			 
1974				; save item type 
1974 3e 02			ld a,  DS_TYPE_INUM 
1976 77				ld (hl), a 
1977 23				inc hl 
1978			 
1978				; get word off stack 
1978 d1				pop de 
1979 7b				ld a,e 
197a 77				ld (hl), a 
197b 23				inc hl 
197c 7a				ld a,d 
197d 77				ld (hl), a 
197e			 
197e			if DEBUG_FORTH_PUSH 
197e				dec hl 
197e				dec hl 
197e				dec hl 
197e						DMARK "PH5" 
197e				CALLMONITOR 
197e			endif	 
197e			 
197e c9				ret 
197f			 
197f			 
197f			; Push a string to stack pointed to by hl 
197f			 
197f			forth_push_str: 
197f			 
197f			if DEBUG_FORTH_PUSH 
197f						DMARK "PSQ" 
197f				CALLMONITOR 
197f			endif	 
197f			    
197f e5				push hl 
1980 e5				push hl 
1981			 
1981 3e 00			ld a, 0   ; find end of string 
1983 cd 78 10			call strlent       
1986			if DEBUG_FORTH_PUSH 
1986						DMARK "PQ2" 
1986				CALLMONITOR 
1986			endif	 
1986 eb				ex de, hl 
1987 e1				pop hl   ; get ptr to start of string 
1988			if DEBUG_FORTH_PUSH 
1988						DMARK "PQ3" 
1988				CALLMONITOR 
1988			endif	 
1988 19				add hl,de 
1989			if DEBUG_FORTH_PUSH 
1989						DMARK "PQE" 
1989				CALLMONITOR 
1989			endif	 
1989			 
1989 2b				dec hl    ; see if there is an optional trailing double quote 
198a 7e				ld a,(hl) 
198b fe 22			cp '"' 
198d 20 03			jr nz, .strnoq 
198f 3e 00			ld a, 0      ; get rid of double quote 
1991 77				ld (hl), a 
1992 23			.strnoq: inc hl 
1993			 
1993 3e 00			ld a, 0 
1995 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1996			 
1996 13				inc de ; add one for the type string 
1997 13				inc de ; add one for null term??? 
1998			 
1998				; tos is get string pointer again 
1998				; de contains space to allocate 
1998				 
1998 d5				push de 
1999			 
1999 eb				ex de, hl 
199a			 
199a				;push af 
199a			 
199a			if DEBUG_FORTH_PUSH 
199a						DMARK "PHm" 
199a				CALLMONITOR 
199a			endif	 
199a cd d6 10			call malloc	; on ret hl now contains allocated memory 
199d				if DEBUG_FORTH_MALLOC_GUARD 
199d cc a7 4e				call z,malloc_error 
19a0				endif 
19a0			 
19a0				 
19a0 c1				pop bc    ; get length 
19a1 d1				pop de   ;  get string start    
19a2			 
19a2				; hl has destination from malloc 
19a2			 
19a2 eb				ex de, hl    ; prep for ldir 
19a3			 
19a3 e5				push hl   ; save malloc area for DSP later 
19a4			 
19a4			if DEBUG_FORTH_PUSH 
19a4						DMARK "PHc" 
19a4				CALLMONITOR 
19a4			endif	 
19a4			 
19a4			 
19a4 ed b0			ldir 
19a6			 
19a6			 
19a6				; push malloc to data stack     macro?????  
19a6			 
19a6				FORTH_DSP_NEXT 
19a6 cd fc 18			call macro_forth_dsp_next 
19a9				endm 
# End of macro FORTH_DSP_NEXT
19a9			 
19a9				; save value and type 
19a9			 
19a9 2a a5 f9			ld hl, (cli_data_sp) 
19ac			 
19ac				; save item type 
19ac 3e 01			ld a,  DS_TYPE_STR 
19ae 77				ld (hl), a 
19af 23				inc hl 
19b0			 
19b0				; get malloc word off stack 
19b0 d1				pop de 
19b1 73				ld (hl), e 
19b2 23				inc hl 
19b3 72				ld (hl), d 
19b4			 
19b4			 
19b4			 
19b4			if DEBUG_FORTH_PUSH 
19b4				ld hl, (cli_data_sp) 
19b4						DMARK "PHS" 
19b4				CALLMONITOR 
19b4			;	ex de,hl 
19b4			endif	 
19b4				; in case of spaces, skip the ptr past the copied string 
19b4				;pop af 
19b4				;ld (cli_origptr),hl 
19b4			 
19b4 c9				ret 
19b5			 
19b5			 
19b5			 
19b5			; TODO ascii push input onto stack given hl to start of input 
19b5			 
19b5			; identify type 
19b5			; if starts with a " then a string 
19b5			; otherwise it is a number 
19b5			;  
19b5			; if a string 
19b5			;     scan for ending " to get length of string to malloc for + 1 
19b5			;     malloc 
19b5			;     put pointer to string on stack first byte flags as string 
19b5			; 
19b5			; else a number 
19b5			;    look for number format identifier 
19b5			;    $xx hex 
19b5			;    %xxxxx bin 
19b5			;    xxxxx decimal 
19b5			;    convert number to 16bit word.  
19b5			;    malloc word + 1 with flag to identiy as num 
19b5			;    put pointer to number on stack 
19b5			;   
19b5			;  
19b5			  
19b5			forth_apush: 
19b5				; kernel push 
19b5			 
19b5			if DEBUG_FORTH_PUSH 
19b5						DMARK "PSH" 
19b5				CALLMONITOR 
19b5			endif	 
19b5				; identify input type 
19b5			 
19b5 7e				ld a,(hl) 
19b6 fe 22			cp '"' 
19b8 28 0a			jr z, .fapstr 
19ba fe 24			cp '$' 
19bc ca e4 19			jp z, .faphex 
19bf fe 25			cp '%' 
19c1 ca cc 19			jp z, .fapbin 
19c4			;	cp 'b' 
19c4			;	jp z, .fabin 
19c4				; else decimal 
19c4			 
19c4				; TODO do decimal conversion 
19c4				; decimal is stored as a 16bit word 
19c4			 
19c4				; by default everything is a string if type is not detected 
19c4			.fapstr: ; 
19c4 fe 22			cp '"' 
19c6 20 01			jr nz, .strnoqu 
19c8 23				inc hl 
19c9			.strnoqu: 
19c9 c3 7f 19			jp forth_push_str 
19cc			 
19cc			 
19cc			 
19cc			.fapbin:    ; push a binary string.  
19cc 11 00 00			ld de, 0   ; hold a 16bit value 
19cf			 
19cf 23			.fapbinshift:	inc hl  
19d0 7e				ld a,(hl) 
19d1 fe 00			cp 0     ; done scanning  
19d3 28 0b			jr z, .fapbdone  	; got it in HL so push  
19d5			 
19d5				; left shift de 
19d5 eb				ex de, hl	 
19d6 29				add hl, hl 
19d7			 
19d7				; is 1 
19d7 fe 31			cp '1' 
19d9 20 02			jr nz, .binzero 
19db cb 4d			bit 1, l 
19dd			.binzero: 
19dd eb				ex de, hl	 ; save current de 
19de 18 ef			jr .fapbinshift 
19e0			 
19e0			.fapbdone: 
19e0 eb				ex de, hl 
19e1 c3 6d 19			jp forth_push_numhl 
19e4			 
19e4			 
19e4			.faphex:   ; hex is always stored as a 16bit word 
19e4				; skip number prefix 
19e4 23				inc hl 
19e5				; turn ascii into number 
19e5 cd c6 0f			call get_word_hl	; ret 16bit word in hl 
19e8			 
19e8 c3 6d 19			jp forth_push_numhl 
19eb			 
19eb 00				 nop 
19ec			 
19ec			.fabin:   ; TODO bin conversion 
19ec			 
19ec			 
19ec c9				ret 
19ed			 
19ed			 
19ed			; get either a string ptr or a 16bit word from the data stack 
19ed			 
19ed			FORTH_DSP: macro 
19ed				call macro_forth_dsp 
19ed				endm 
19ed			 
19ed			macro_forth_dsp: 
19ed				; data stack pointer points to current word on tos 
19ed			 
19ed 2a a5 f9			ld hl,(cli_data_sp) 
19f0			 
19f0				if DEBUG_FORTH_PUSH 
19f0						DMARK "DSP" 
19f0			 
19f0					call display_data_sp 
19f0				;call break_point_state 
19f0				;rst 030h 
19f0				CALLMONITOR 
19f0				endif 
19f0			 
19f0 c9				ret 
19f1			 
19f1			; return hl to start of value on stack 
19f1			 
19f1			FORTH_DSP_VALUE: macro 
19f1				call macro_forth_dsp_value 
19f1				endm 
19f1			 
19f1			macro_forth_dsp_value: 
19f1			 
19f1				FORTH_DSP 
19f1 cd ed 19			call macro_forth_dsp 
19f4				endm 
# End of macro FORTH_DSP
19f4			 
19f4 d5				push de 
19f5			 
19f5 23				inc hl ; skip type 
19f6			 
19f6 5e				ld e, (hl) 
19f7 23				inc hl 
19f8 56				ld d, (hl) 
19f9 eb				ex de,hl  
19fa			 
19fa d1				pop de 
19fb			 
19fb c9				ret 
19fc			 
19fc			; return hl to start of value to second item on stack 
19fc			 
19fc			FORTH_DSP_VALUEM1: macro 
19fc				call macro_forth_dsp_value_m1 
19fc				endm 
19fc			 
19fc			macro_forth_dsp_value_m1: 
19fc			 
19fc				FORTH_DSP 
19fc cd ed 19			call macro_forth_dsp 
19ff				endm 
# End of macro FORTH_DSP
19ff			 
19ff 2b				dec hl 
1a00 2b				dec hl 
1a01			;	dec hl 
1a01			 
1a01 d5				push de 
1a02			 
1a02 5e				ld e, (hl) 
1a03 23				inc hl 
1a04 56				ld d, (hl) 
1a05 eb				ex de,hl  
1a06			 
1a06 d1				pop de 
1a07			 
1a07 c9				ret 
1a08			 
1a08				 
1a08			 
1a08			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1a08			 
1a08			FORTH_DSP_POP: macro 
1a08				call macro_forth_dsp_pop 
1a08				endm 
1a08			 
1a08			 
1a08			; get the tos data type 
1a08			 
1a08			FORTH_DSP_TYPE:   macro 
1a08			 
1a08				;FORTH_DSP_VALUE 
1a08				FORTH_DSP 
1a08				 
1a08				; hl points to value 
1a08				; check type 
1a08			 
1a08				ld a,(hl) 
1a08			 
1a08				endm 
1a08			 
1a08			; load the tos value into hl 
1a08			 
1a08			 
1a08			FORTH_DSP_VALUEHL:  macro 
1a08				call macro_dsp_valuehl 
1a08				endm 
1a08			 
1a08			 
1a08			 
1a08			macro_dsp_valuehl: 
1a08				FORTH_DSP_VALUE 
1a08 cd f1 19			call macro_forth_dsp_value 
1a0b				endm 
# End of macro FORTH_DSP_VALUE
1a0b			 
1a0b				;FORTH_ERR_TOS_NOTNUM 
1a0b			 
1a0b				;inc hl   ; skip type id 
1a0b			 
1a0b			;	push de 
1a0b			; 
1a0b			;	ld e, (hl) 
1a0b			;	inc hl 
1a0b			;	ld d, (hl) 
1a0b			;	ex de,hl  
1a0b			 
1a0b			;	pop de 
1a0b			 
1a0b				if DEBUG_FORTH_PUSH 
1a0b						DMARK "DVL" 
1a0b				CALLMONITOR 
1a0b				endif 
1a0b c9				ret 
1a0c			 
1a0c			forth_apushstrhl:      
1a0c				; push of string requires use of cli_origptr 
1a0c				; bodge use 
1a0c			 
1a0c				; get current cli_origptr, save, update with temp pointer  
1a0c ed 5b c1 f9		ld de, (cli_origptr) 
1a10 22 c1 f9			ld (cli_origptr), hl 
1a13 d5				push de 
1a14 cd b5 19			call forth_apush 
1a17 d1				pop de 
1a18 ed 53 c1 f9		ld (cli_origptr), de 
1a1c c9			        ret	 
1a1d			 
1a1d			 
1a1d			; increase loop stack pointer and save hl to it 
1a1d				 
1a1d			FORTH_LOOP_NEXT: macro 
1a1d				call macro_forth_loop_next 
1a1d				;nop 
1a1d				endm 
1a1d			 
1a1d			macro_forth_loop_next: 
1a1d				if DEBUG_FORTH_STACK_GUARD 
1a1d cd 41 5f				call check_stacks 
1a20				endif 
1a20 e5				push hl 
1a21 d5				push de 
1a22 eb				ex de,hl 
1a23 2a a7 f9			ld hl,(cli_loop_sp) 
1a26 23				inc hl 
1a27 23				inc hl 
1a28					if DEBUG_FORTH_WORDS 
1a28						DMARK "LNX" 
1a28 f5				push af  
1a29 3a 3d 1a			ld a, (.dmark)  
1a2c 32 bd fb			ld (debug_mark),a  
1a2f 3a 3e 1a			ld a, (.dmark+1)  
1a32 32 be fb			ld (debug_mark+1),a  
1a35 3a 3f 1a			ld a, (.dmark+2)  
1a38 32 bf fb			ld (debug_mark+2),a  
1a3b 18 03			jr .pastdmark  
1a3d ..			.dmark: db "LNX"  
1a40 f1			.pastdmark: pop af  
1a41			endm  
# End of macro DMARK
1a41						CALLMONITOR 
1a41 cd d3 13			call break_point_state  
1a44				endm  
# End of macro CALLMONITOR
1a44					endif 
1a44 22 a7 f9			ld (cli_loop_sp),hl 
1a47 73				ld (hl), e 
1a48 23				inc hl 
1a49 72				ld (hl), d 
1a4a d1				pop de    ; been reversed so save a swap on restore 
1a4b e1				pop hl 
1a4c				if DEBUG_FORTH_STACK_GUARD 
1a4c cd 41 5f				call check_stacks 
1a4f				endif 
1a4f c9				ret 
1a50			 
1a50			; get current ret stack pointer and save to hl  
1a50				 
1a50			FORTH_LOOP_TOS: macro 
1a50				call macro_forth_loop_tos 
1a50				endm 
1a50			 
1a50			macro_forth_loop_tos: 
1a50 d5				push de 
1a51 2a a7 f9			ld hl,(cli_loop_sp) 
1a54 5e				ld e, (hl) 
1a55 23				inc hl 
1a56 56				ld d, (hl) 
1a57 eb				ex de, hl 
1a58 d1				pop de 
1a59 c9				ret 
1a5a			 
1a5a			; pop loop stack pointer 
1a5a				 
1a5a			FORTH_LOOP_POP: macro 
1a5a				call macro_forth_loop_pop 
1a5a				endm 
1a5a			 
1a5a			 
1a5a			macro_forth_loop_pop: 
1a5a				if DEBUG_FORTH_STACK_GUARD 
1a5a					DMARK "LPP" 
1a5a f5				push af  
1a5b 3a 6f 1a			ld a, (.dmark)  
1a5e 32 bd fb			ld (debug_mark),a  
1a61 3a 70 1a			ld a, (.dmark+1)  
1a64 32 be fb			ld (debug_mark+1),a  
1a67 3a 71 1a			ld a, (.dmark+2)  
1a6a 32 bf fb			ld (debug_mark+2),a  
1a6d 18 03			jr .pastdmark  
1a6f ..			.dmark: db "LPP"  
1a72 f1			.pastdmark: pop af  
1a73			endm  
# End of macro DMARK
1a73 cd 41 5f				call check_stacks 
1a76					FORTH_CHK_LOOP_UNDER 
1a76 e5				push hl 
1a77 d5				push de 
1a78 2a a7 f9			ld hl,(cli_loop_sp) 
1a7b 11 21 f7			ld de, cli_loop_stack 
1a7e cd 2d 0c			call cmp16 
1a81 da 5b 60			jp c, fault_loop_under 
1a84 d1				pop de 
1a85 e1				pop hl 
1a86				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1a86				endif 
1a86 e5				push hl 
1a87 2a a7 f9			ld hl,(cli_loop_sp) 
1a8a 2b				dec hl 
1a8b 2b				dec hl 
1a8c 22 a7 f9			ld (cli_loop_sp), hl 
1a8f				; TODO do stack underflow checks 
1a8f e1				pop hl 
1a90				if DEBUG_FORTH_STACK_GUARD 
1a90 cd 41 5f				call check_stacks 
1a93					FORTH_CHK_LOOP_UNDER 
1a93 e5				push hl 
1a94 d5				push de 
1a95 2a a7 f9			ld hl,(cli_loop_sp) 
1a98 11 21 f7			ld de, cli_loop_stack 
1a9b cd 2d 0c			call cmp16 
1a9e da 5b 60			jp c, fault_loop_under 
1aa1 d1				pop de 
1aa2 e1				pop hl 
1aa3				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1aa3				endif 
1aa3 c9				ret 
1aa4			 
1aa4			macro_forth_dsp_pop: 
1aa4			 
1aa4 e5				push hl 
1aa5			 
1aa5				; release malloc data 
1aa5			 
1aa5				if DEBUG_FORTH_STACK_GUARD 
1aa5 cd 41 5f				call check_stacks 
1aa8					FORTH_CHK_DSP_UNDER 
1aa8 e5				push hl 
1aa9 d5				push de 
1aaa 2a a5 f9			ld hl,(cli_data_sp) 
1aad 11 1f f5			ld de, cli_data_stack 
1ab0 cd 2d 0c			call cmp16 
1ab3 da 4f 60			jp c, fault_dsp_under 
1ab6 d1				pop de 
1ab7 e1				pop hl 
1ab8				endm 
# End of macro FORTH_CHK_DSP_UNDER
1ab8				endif 
1ab8				;ld hl,(cli_data_sp) 
1ab8			if DEBUG_FORTH_DOT 
1ab8				DMARK "DPP" 
1ab8				CALLMONITOR 
1ab8			endif	 
1ab8			 
1ab8			 
1ab8			if FORTH_ENABLE_DSPPOPFREE 
1ab8			 
1ab8				FORTH_DSP 
1ab8 cd ed 19			call macro_forth_dsp 
1abb				endm 
# End of macro FORTH_DSP
1abb			 
1abb 7e				ld a, (hl) 
1abc fe 01			cp DS_TYPE_STR 
1abe 20 07			jr nz, .skippopfree 
1ac0			 
1ac0				FORTH_DSP_VALUEHL 
1ac0 cd 08 1a			call macro_dsp_valuehl 
1ac3				endm 
# End of macro FORTH_DSP_VALUEHL
1ac3 00				nop 
1ac4			if DEBUG_FORTH_DOT 
1ac4				DMARK "DPf" 
1ac4				CALLMONITOR 
1ac4			endif	 
1ac4 cd a0 11			call free 
1ac7			.skippopfree: 
1ac7				 
1ac7			 
1ac7			endif 
1ac7			 
1ac7			if DEBUG_FORTH_DOT_KEY 
1ac7				DMARK "DP2" 
1ac7				CALLMONITOR 
1ac7			endif	 
1ac7			 
1ac7				; move pointer down 
1ac7			 
1ac7 2a a5 f9			ld hl,(cli_data_sp) 
1aca 2b				dec hl 
1acb 2b				dec hl 
1acc			; PARSEV5 
1acc 2b				dec hl 
1acd 22 a5 f9			ld (cli_data_sp), hl 
1ad0			 
1ad0				if DEBUG_FORTH_STACK_GUARD 
1ad0 cd 41 5f				call check_stacks 
1ad3					FORTH_CHK_DSP_UNDER 
1ad3 e5				push hl 
1ad4 d5				push de 
1ad5 2a a5 f9			ld hl,(cli_data_sp) 
1ad8 11 1f f5			ld de, cli_data_stack 
1adb cd 2d 0c			call cmp16 
1ade da 4f 60			jp c, fault_dsp_under 
1ae1 d1				pop de 
1ae2 e1				pop hl 
1ae3				endm 
# End of macro FORTH_CHK_DSP_UNDER
1ae3				endif 
1ae3			 
1ae3 e1				pop hl 
1ae4			 
1ae4 c9				ret 
1ae5			 
1ae5			getwordathl: 
1ae5				; hl points to an address 
1ae5				; load hl with the word at that address 
1ae5			 
1ae5 d5				push de 
1ae6			 
1ae6 5e				ld e, (hl) 
1ae7 23				inc hl 
1ae8 56				ld d, (hl) 
1ae9 eb				ex de, hl 
1aea			 
1aea d1				pop de 
1aeb c9				ret 
1aec			 
1aec			 
1aec			 
1aec			 
1aec			 
1aec			; eof 
1aec			 
# End of file forth_stackopsv5.asm
1aec			endif 
1aec			 
1aec			user_word_eol:  
1aec				; hl contains the pointer to where to create a linked list item from the end 
1aec				; of the user dict to continue on at the system word dict 
1aec				 
1aec				; poke the stub of the word list linked list to repoint to rom words 
1aec			 
1aec				; stub format 
1aec				; db   word id 
1aec				; dw    link to next word 
1aec			        ; db char length of token 
1aec				; db string + 0 term 
1aec				; db exec code....  
1aec			 
1aec 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1aee 77				ld (hl), a		; word id 
1aef 23				inc hl 
1af0			 
1af0 11 b6 1c			ld de, sysdict 
1af3 73				ld (hl), e		; next word link ie system dict 
1af4 23				inc hl 
1af5 72				ld (hl), d		; next word link ie system dict 
1af6 23				inc hl	 
1af7			 
1af7			;	ld (hl), sysdict		; next word link ie system dict 
1af7			;	inc hl 
1af7			;	inc hl 
1af7			 
1af7			;	inc hl 
1af7			;	inc hl 
1af7			 
1af7 3e 02			ld a, 2			; word length is 0 
1af9 77				ld (hl), a	 
1afa 23				inc hl 
1afb			 
1afb 3e 7e			ld a, '~'			; word length is 0 
1afd 77				ld (hl), a	 
1afe 23				inc hl 
1aff 3e 00			ld a, 0			; save empty word 
1b01 77				ld (hl), a 
1b02			 
1b02 c9				ret 
1b03			 
1b03				 
1b03			 
1b03			forthexec_cleanup: 
1b03				FORTH_RSP_POP 
1b03 cd 35 19			call macro_forth_rsp_pop 
1b06				endm 
# End of macro FORTH_RSP_POP
1b06 c9				ret 
1b07			 
1b07			forth_call_hl: 
1b07				; taking hl 
1b07 e5				push hl 
1b08 c9				ret 
1b09			 
1b09			; this is called to reset Forth system but keep existing uwords etc 
1b09			 
1b09			forth_warmstart: 
1b09				; setup stack over/under flow checks 
1b09				if DEBUG_FORTH_STACK_GUARD 
1b09 cd 27 5f				call chk_stk_init 
1b0c				endif 
1b0c			 
1b0c				; init stack pointers  - * these stacks go upwards *  
1b0c 21 23 f9			ld hl, cli_ret_stack 
1b0f 22 a9 f9			ld (cli_ret_sp), hl	 
1b12				; set bottom of stack 
1b12 3e 00			ld a,0 
1b14 77				ld (hl),a 
1b15 23				inc hl 
1b16 77				ld (hl),a 
1b17			 
1b17 21 1f f5			ld hl, cli_data_stack 
1b1a 22 a5 f9			ld (cli_data_sp), hl	 
1b1d				; set bottom of stack 
1b1d 3e 00			ld a,0 
1b1f 77				ld (hl),a 
1b20 23				inc hl 
1b21 77				ld (hl),a 
1b22			 
1b22 21 21 f7			ld hl, cli_loop_stack 
1b25 22 a7 f9			ld (cli_loop_sp), hl	 
1b28				; set bottom of stack 
1b28 3e 00			ld a,0 
1b2a 77				ld (hl),a 
1b2b 23				inc hl 
1b2c 77				ld (hl),a 
1b2d			 
1b2d				; init extent of current open file 
1b2d			 
1b2d 3e 00			ld a, 0 
1b2f 32 df f9			ld (store_openext), a 
1b32			 
1b32 c9				ret 
1b33			 
1b33			 
1b33			; Cold Start - this is called to setup the whole Forth system 
1b33			 
1b33			forth_init: 
1b33			 
1b33				; setup stack over/under flow checks 
1b33			 
1b33			;	if DEBUG_FORTH_STACK_GUARD 
1b33			;		call chk_stk_init 
1b33			;	endif 
1b33			 
1b33				; enable auto display updates (slow.....) 
1b33			 
1b33 3e 01			ld a, 1 
1b35 32 bf f9			ld (cli_autodisplay), a 
1b38			 
1b38			 
1b38			 
1b38				; show start up screen 
1b38			 
1b38 cd b6 0a			call clear_display 
1b3b			 
1b3b 3e 00			ld a,0 
1b3d 32 e1 f9			ld (f_cursor_ptr), a 
1b40			 
1b40				; set start of word list in start of ram - for use when creating user words 
1b40			 
1b40 21 00 80			ld hl, baseram 
1b43 22 b5 f2			ld (os_last_new_uword), hl 
1b46 cd ec 1a			call user_word_eol 
1b49				 
1b49			;		call display_data_sp 
1b49			;		call next_page_prompt 
1b49			 
1b49			 
1b49			 
1b49			 
1b49 c9				ret 
1b4a			 
1b4a .. 00		.bootforth: db " Forth Kernel Init ",0 
1b5e			 
1b5e			; TODO push to stack 
1b5e			 
1b5e			;  
1b5e			 
1b5e			if FORTH_PARSEV2 
1b5e			 
1b5e			 
1b5e				include "forth_parserv2.asm" 
1b5e			 
1b5e			endif 
1b5e			 
1b5e			 
1b5e			; parse cli version 1 
1b5e			 
1b5e			if FORTH_PARSEV1 
1b5e			 
1b5e			 
1b5e			 
1b5e			      include "forth_parserv1.asm" 
1b5e			endif 
1b5e				 
1b5e			if FORTH_PARSEV3 
1b5e			 
1b5e			 
1b5e			 
1b5e			      include "forth_parserv3.asm" 
1b5e				include "forth_wordsv3.asm" 
1b5e			endif 
1b5e			 
1b5e			if FORTH_PARSEV4 
1b5e			 
1b5e			 
1b5e			 
1b5e			      include "forth_parserv4.asm" 
1b5e				include "forth_wordsv4.asm" 
1b5e			endif 
1b5e			 
1b5e			if FORTH_PARSEV5 
1b5e			 
1b5e			 
1b5e			 
1b5e			      include "forth_parserv5.asm" 
1b5e			 
1b5e			 
1b5e			; A better parser without using malloc and string copies all over the place.  
1b5e			; Exec in situ should be faster 
1b5e			 
1b5e			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
1b5e			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
1b5e			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
1b5e			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
1b5e			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
1b5e			WORD_SYS_END: equ 0   ; Opcode for all user words 
1b5e			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
1b5e			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
1b5e			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
1b5e			 
1b5e			; Core word preamble macro 
1b5e			 
1b5e			CWHEAD:   macro nxtword opcode lit len opflags 
1b5e				db WORD_SYS_CORE+opcode             
1b5e				; internal op code number 
1b5e				dw nxtword            
1b5e				; link to next dict word block 
1b5e				db len + 1 
1b5e				; literal length of dict word inc zero term 
1b5e				db lit,0              
1b5e				; literal dict word 
1b5e			        ; TODO db opflags        
1b5e				endm 
1b5e			 
1b5e			 
1b5e			NEXTW: macro  
1b5e				jp macro_next 
1b5e				endm 
1b5e			 
1b5e			macro_next: 
1b5e			if DEBUG_FORTH_PARSE_KEY 
1b5e				DMARK "NXT" 
1b5e				CALLMONITOR 
1b5e			endif	 
1b5e			;	inc hl  ; skip token null term  
1b5e ed 4b c3 f9		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1b62 ed 5b c1 f9		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1b66 2a b9 f2			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1b69			if DEBUG_FORTH_PARSE_KEY 
1b69				DMARK "}AA" 
1b69				CALLMONITOR 
1b69			endif	 
1b69 c3 6c 1c			jp execnext 
1b6c				;jp exec1 
1b6c			       
1b6c			 
1b6c			 
1b6c			; Another go at the parser to compile  
1b6c			 
1b6c			 
1b6c			; TODO rework parser to change all of the string words to byte tokens 
1b6c			; TODO do a search for  
1b6c			 
1b6c			; TODO first run normal parser to zero term sections 
1b6c			; TODO for each word do a token look up to get the op code 
1b6c			; TODO need some means to flag to the exec that this is a byte code form    
1b6c			 
1b6c			 
1b6c			forthcompile: 
1b6c			 
1b6c			; 
1b6c			; line parse: 
1b6c			;       parse raw input buffer 
1b6c			;       tokenise the words 
1b6c			;       malloc new copy (for looping etc) 
1b6c			;       copy to malloc + current pc in line to start of string and add line term 
1b6c			;       save on new rsp 
1b6c			; 
1b6c			 
1b6c			; hl to point to the line to tokenise 
1b6c			 
1b6c			;	push hl 
1b6c 22 b9 f2			ld (os_tok_ptr), hl  ; save ptr to string 
1b6f			 
1b6f			;	ld a,0		; string term on input 
1b6f			;	call strlent 
1b6f			 
1b6f			;	ld (os_tok_len), hl	 ; save string length 
1b6f			 
1b6f			;if DEBUG_FORTH_TOK 
1b6f			;	ex de,hl		 
1b6f			;endif 
1b6f			 
1b6f			;	pop hl 		; get back string pointer 
1b6f			 
1b6f			if DEBUG_FORTH_TOK 
1b6f						DMARK "TOc" 
1b6f				CALLMONITOR 
1b6f			endif 
1b6f 7e			.cptoken2:    ld a,(hl) 
1b70 23				inc hl 
1b71 fe 7f			cp FORTH_END_BUFFER 
1b73 28 29			jr z, .cptokendone2 
1b75 fe 00			cp 0 
1b77 28 25			jr z, .cptokendone2 
1b79 fe 22			cp '"' 
1b7b 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
1b7d fe 20			cp ' ' 
1b7f 20 ee			jr nz,  .cptoken2 
1b81			 
1b81			; TODO consume comments held between ( and ) 
1b81			 
1b81				; we have a space so change to zero term for dict match later 
1b81 2b				dec hl 
1b82 3e 00			ld a,0 
1b84 77				ld (hl), a 
1b85 23				inc hl 
1b86 18 e7			jr .cptoken2 
1b88				 
1b88			 
1b88			.cptokenstr2: 
1b88				; skip all white space until either eol (because forgot to term) or end double quote 
1b88			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1b88				;inc hl ; skip current double quote 
1b88 7e				ld a,(hl) 
1b89 23				inc hl 
1b8a fe 22			cp '"' 
1b8c 28 e1			jr z, .cptoken2 
1b8e fe 7f			cp FORTH_END_BUFFER 
1b90 28 0c			jr z, .cptokendone2 
1b92 fe 00			cp 0 
1b94 28 08			jr z, .cptokendone2 
1b96 fe 20			cp ' ' 
1b98 28 02			jr z, .cptmp2 
1b9a 18 ec			jr .cptokenstr2 
1b9c			 
1b9c			.cptmp2:	; we have a space so change to zero term for dict match later 
1b9c				;dec hl 
1b9c				;ld a,"-"	; TODO remove this when working 
1b9c				;ld (hl), a 
1b9c				;inc hl 
1b9c 18 ea			jr .cptokenstr2 
1b9e			 
1b9e			.cptokendone2: 
1b9e				;inc hl 
1b9e 3e 7f			ld a, FORTH_END_BUFFER 
1ba0 77				ld (hl),a 
1ba1 23				inc hl 
1ba2 3e 21			ld a, '!' 
1ba4 77				ld (hl),a 
1ba5			 
1ba5 2a b9 f2			ld hl,(os_tok_ptr) 
1ba8			         
1ba8			if DEBUG_FORTH_TOK 
1ba8						DMARK "Tc1" 
1ba8				CALLMONITOR 
1ba8			endif 
1ba8			 
1ba8				; push exec string to top of return stack 
1ba8				FORTH_RSP_NEXT 
1ba8 cd 14 19			call macro_forth_rsp_next 
1bab				endm 
# End of macro FORTH_RSP_NEXT
1bab c9				ret 
1bac			 
1bac			; Another go at the parser need to simplify the process 
1bac			 
1bac			forthparse: 
1bac			 
1bac			; 
1bac			; line parse: 
1bac			;       parse raw input buffer 
1bac			;       tokenise the words 
1bac			;       malloc new copy (for looping etc) 
1bac			;       copy to malloc + current pc in line to start of string and add line term 
1bac			;       save on new rsp 
1bac			; 
1bac			 
1bac			; hl to point to the line to tokenise 
1bac			 
1bac			;	push hl 
1bac 22 b9 f2			ld (os_tok_ptr), hl  ; save ptr to string 
1baf			 
1baf			;	ld a,0		; string term on input 
1baf			;	call strlent 
1baf			 
1baf			;	ld (os_tok_len), hl	 ; save string length 
1baf			 
1baf			;if DEBUG_FORTH_TOK 
1baf			;	ex de,hl		 
1baf			;endif 
1baf			 
1baf			;	pop hl 		; get back string pointer 
1baf			 
1baf			if DEBUG_FORTH_TOK 
1baf						DMARK "TOK" 
1baf				CALLMONITOR 
1baf			endif 
1baf 7e			.ptoken2:    ld a,(hl) 
1bb0 23				inc hl 
1bb1 fe 7f			cp FORTH_END_BUFFER 
1bb3 28 29			jr z, .ptokendone2 
1bb5 fe 00			cp 0 
1bb7 28 25			jr z, .ptokendone2 
1bb9 fe 22			cp '"' 
1bbb 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
1bbd fe 20			cp ' ' 
1bbf 20 ee			jr nz,  .ptoken2 
1bc1			 
1bc1			; TODO consume comments held between ( and ) 
1bc1			 
1bc1				; we have a space so change to zero term for dict match later 
1bc1 2b				dec hl 
1bc2 3e 00			ld a,0 
1bc4 77				ld (hl), a 
1bc5 23				inc hl 
1bc6 18 e7			jr .ptoken2 
1bc8				 
1bc8			 
1bc8			.ptokenstr2: 
1bc8				; skip all white space until either eol (because forgot to term) or end double quote 
1bc8			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1bc8				;inc hl ; skip current double quote 
1bc8 7e				ld a,(hl) 
1bc9 23				inc hl 
1bca fe 22			cp '"' 
1bcc 28 e1			jr z, .ptoken2 
1bce fe 7f			cp FORTH_END_BUFFER 
1bd0 28 0c			jr z, .ptokendone2 
1bd2 fe 00			cp 0 
1bd4 28 08			jr z, .ptokendone2 
1bd6 fe 20			cp ' ' 
1bd8 28 02			jr z, .ptmp2 
1bda 18 ec			jr .ptokenstr2 
1bdc			 
1bdc			.ptmp2:	; we have a space so change to zero term for dict match later 
1bdc				;dec hl 
1bdc				;ld a,"-"	; TODO remove this when working 
1bdc				;ld (hl), a 
1bdc				;inc hl 
1bdc 18 ea			jr .ptokenstr2 
1bde			 
1bde			.ptokendone2: 
1bde				;inc hl 
1bde 3e 7f			ld a, FORTH_END_BUFFER 
1be0 77				ld (hl),a 
1be1 23				inc hl 
1be2 3e 21			ld a, '!' 
1be4 77				ld (hl),a 
1be5			 
1be5 2a b9 f2			ld hl,(os_tok_ptr) 
1be8			         
1be8			if DEBUG_FORTH_TOK 
1be8						DMARK "TK1" 
1be8				CALLMONITOR 
1be8			endif 
1be8			 
1be8				; push exec string to top of return stack 
1be8				FORTH_RSP_NEXT 
1be8 cd 14 19			call macro_forth_rsp_next 
1beb				endm 
# End of macro FORTH_RSP_NEXT
1beb c9				ret 
1bec			 
1bec			; 
1bec			;	; malloc size + buffer pointer + if is loop flag 
1bec			;	ld hl,(os_tok_len) 		 ; get string length 
1bec			; 
1bec			;	ld a,l 
1bec			; 
1bec			;	cp 0			; we dont want to use a null string 
1bec			;	ret z 
1bec			; 
1bec			;;	add 3    ; prefix malloc with buffer for current word ptr 
1bec			; 
1bec			;	add 5     ; TODO when certain not over writing memory remove 
1bec			; 
1bec			;		 
1bec			; 
1bec			;if DEBUG_FORTH_TOK 
1bec			;			DMARK "TKE" 
1bec			;	CALLMONITOR 
1bec			;endif 
1bec			; 
1bec			;	ld l,a 
1bec			;	ld h,0 
1bec			;;	push hl   ; save required space for the copy later 
1bec			;	call malloc 
1bec			;if DEBUG_FORTH_TOK 
1bec			;			DMARK "TKM" 
1bec			;	CALLMONITOR 
1bec			;endif 
1bec			;	if DEBUG_FORTH_MALLOC_GUARD 
1bec			;		push af 
1bec			;		call ishlzero 
1bec			;;		ld a, l 
1bec			;;		add h 
1bec			;;		cp 0 
1bec			;		pop af 
1bec			;		 
1bec			;		call z,malloc_error 
1bec			;	endif 
1bec			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
1bec			; 
1bec			; 
1bec			;if DEBUG_FORTH_TOK 
1bec			;			DMARK "TKR" 
1bec			;	CALLMONITOR 
1bec			;endif 
1bec			; 
1bec			;	FORTH_RSP_NEXT 
1bec			; 
1bec			;	;inc hl	 ; go past current buffer pointer 
1bec			;	;inc hl 
1bec			;	;inc hl   ; and past if loop flag 
1bec			;		; TODO Need to set flag  
1bec			; 
1bec			;	 
1bec			;	 
1bec			;	ex de,hl	; malloc is dest 
1bec			;	ld hl, (os_tok_len) 
1bec			;;	pop bc 
1bec			;	ld c, l                
1bec			;	ld b,0 
1bec			;	ld hl, (os_tok_ptr) 
1bec			; 
1bec			;if DEBUG_FORTH_TOK 
1bec			;			DMARK "TKT" 
1bec			;	CALLMONITOR 
1bec			;endif 
1bec			; 
1bec			;	; do str cpy 
1bec			; 
1bec			;	ldir      ; copy byte in hl to de 
1bec			; 
1bec			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
1bec			; 
1bec			;if DEBUG_FORTH_TOK 
1bec			; 
1bec			;			DMARK "TKY" 
1bec			;	CALLMONITOR 
1bec			;endif 
1bec			;	;ld a,0 
1bec			;	;ld a,FORTH_END_BUFFER 
1bec			;	ex de, hl 
1bec			;	;dec hl			 ; go back over the space delim at the end of word 
1bec			;	;ld (hl),a 
1bec			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
1bec			;	ld a,FORTH_END_BUFFER 
1bec			;	ld (hl),a 
1bec			;	inc hl 
1bec			;	ld a,FORTH_END_BUFFER 
1bec			;	ld (hl),a 
1bec			; 
1bec			;	; init the malloc area data 
1bec			;	; set pc for in current area 
1bec			;	;ld hl, (os_tok_malloc) 
1bec			;	;inc hl 
1bec			;	;inc hl 
1bec			;	;inc hl 
1bec			;	;ex de,hl 
1bec			;	;ld hl, (os_tok_malloc) 
1bec			;	;ld (hl),e 
1bec			;	;inc hl 
1bec			;	;ld (hl),d 
1bec			; 
1bec			; 
1bec			;	ld hl,(os_tok_malloc) 
1bec			;if DEBUG_FORTH_PARSE_KEY 
1bec			;			DMARK "TKU" 
1bec			;	CALLMONITOR 
1bec			;endif 
1bec			; 
1bec			;	ret 
1bec			 
1bec			forthexec: 
1bec			 
1bec			; line exec: 
1bec			; forth parser 
1bec			 
1bec			; 
1bec			;       get current exec line on rsp 
1bec			 
1bec				FORTH_RSP_TOS 
1bec cd 2b 19			call macro_forth_rsp_tos 
1bef				endm 
# End of macro FORTH_RSP_TOS
1bef			 
1bef			;       restore current pc - hl points to malloc of data 
1bef			 
1bef				;ld e, (hl) 
1bef				;inc hl 
1bef				;ld d, (hl) 
1bef				;ex de,hl 
1bef			 
1bef			 
1bef			exec1: 
1bef 22 b9 f2			ld (os_tok_ptr), hl 
1bf2			 
1bf2				; copy our PC to working vars  
1bf2 22 c3 f9			ld (cli_ptr), hl 
1bf5 22 c1 f9			ld (cli_origptr), hl 
1bf8			 
1bf8 7e				ld a,(hl) 
1bf9 fe 7f			cp FORTH_END_BUFFER 
1bfb c8				ret z 
1bfc			 
1bfc				; skip any nulls 
1bfc			 
1bfc fe 00			cp 0 
1bfe 20 03			jr nz, .execword 
1c00 23				inc hl 
1c01 18 ec			jr exec1 
1c03			 
1c03			 
1c03			.execword: 
1c03			 
1c03			 
1c03			 
1c03			if DEBUG_FORTH_PARSE_KEY 
1c03						DMARK "KYQ" 
1c03				CALLMONITOR 
1c03			endif 
1c03			;       while at start of word: 
1c03			; get start of dict (in user area first) 
1c03			 
1c03 21 00 80		ld hl, baseram 
1c06			;ld hl, sysdict 
1c06 22 c5 f9		ld (cli_nextword),hl 
1c09			;           match word at pc 
1c09			;           exec word 
1c09			;           or push to dsp 
1c09			;           forward to next token 
1c09			;           if line term pop rsp and exit 
1c09			;        
1c09			 
1c09			if DEBUG_FORTH_PARSE_KEY 
1c09						DMARK "KYq" 
1c09				CALLMONITOR 
1c09			endif 
1c09			 
1c09			; 
1c09			; word comp 
1c09			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
1c09			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
1c09			;    move to start of word  
1c09			;    compare word to cli_token 
1c09			 
1c09			.execpnword:	; HL at start of a word in the dictionary to check 
1c09			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
1c09			;	ld (cli_ptr), hl 
1c09			 
1c09 2a c5 f9			ld hl,(cli_nextword) 
1c0c			 
1c0c cd af 1c			call forth_tok_next 
1c0f			; tok next start here 
1c0f			;	; TODO skip compiled symbol for now 
1c0f			;	inc hl 
1c0f			; 
1c0f			;	; save pointer to next word 
1c0f			; 
1c0f			;	; hl now points to the address of the next word pointer  
1c0f			;	ld e, (hl) 
1c0f			;	inc hl 
1c0f			;	ld d, (hl) 
1c0f			;	inc l 
1c0f			; 
1c0f			;	ex de,hl 
1c0f			;if DEBUG_FORTH_PARSE_NEXTWORD 
1c0f			;	push bc 
1c0f			;	ld bc, (cli_nextword) 
1c0f			;			DMARK "NXW" 
1c0f			;	CALLMONITOR 
1c0f			;	pop bc 
1c0f			;endif 
1c0f			; tok next end here 
1c0f 22 c5 f9			ld (cli_nextword), hl     ; save for next check if no match on this word 
1c12 eb				ex de, hl 
1c13			 
1c13			 
1c13				; save the pointer of the current token - 1 to check against 
1c13				 
1c13 22 c9 f9			ld (cli_token), hl   
1c16				; TODO maybe remove below save if no debug 
1c16				; save token string ptr for any debug later 
1c16 23				inc hl  
1c17 22 cb f9			ld (cli_origtoken), hl 
1c1a 2b				dec hl 
1c1b				; save pointer to the start of the next dictionay word 
1c1b 7e				ld a,(hl)   ; get string length 
1c1c 47				ld b,a 
1c1d			.execpnwordinc:  
1c1d 23				inc hl 
1c1e 10 fd			djnz .execpnwordinc 
1c20 22 c7 f9			ld (cli_execword), hl      ; save start of this words code 
1c23			 
1c23				; now check the word token against the string being parsed 
1c23			 
1c23 2a c9 f9			ld hl,(cli_token) 
1c26 23				inc hl     ; skip string length (use zero term instead to end) 
1c27 22 c9 f9			ld (cli_token), hl 
1c2a			 
1c2a			if DEBUG_FORTH_PARSE_KEY 
1c2a						DMARK "KY2" 
1c2a			endif 
1c2a			if DEBUG_FORTH_PARSE_EXEC 
1c2a				; see if disabled 
1c2a			 
1c2a				ld a, (os_view_disable) 
1c2a				cp '*' 
1c2a				jr z, .skip 
1c2a			 
1c2a				push hl 
1c2a				push hl 
1c2a				call clear_display 
1c2a				ld de, .compword 
1c2a				ld a, display_row_1 
1c2a				call str_at_display 
1c2a				pop de 
1c2a				ld a, display_row_2 
1c2a				call str_at_display 
1c2a				ld hl,(cli_ptr) 
1c2a				ld a,(hl) 
1c2a			        ld hl, os_word_scratch 
1c2a				ld (hl),a 
1c2a				ld a,0 
1c2a				inc hl 
1c2a				ld (hl),a 	 
1c2a				ld de, os_word_scratch 
1c2a				ld a, display_row_2+10 
1c2a				call str_at_display 
1c2a				call update_display 
1c2a				ld a, 100 
1c2a				call aDelayInMS 
1c2a				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1c2a				call delay250ms 
1c2a				endif 
1c2a				pop hl 
1c2a			.skip:  
1c2a			endif	 
1c2a			.execpnchar:    ; compare char between token and string to parse 
1c2a			 
1c2a			if DEBUG_FORTH_PARSE_KEY 
1c2a						DMARK "Ky3" 
1c2a			endif 
1c2a			if DEBUG_FORTH_PARSE_EXEC 
1c2a				; see if disabled 
1c2a			 
1c2a				ld a, (os_view_disable) 
1c2a				cp '*' 
1c2a				jr z, .skip2 
1c2a			 
1c2a			;	call clear_display 
1c2a			ld hl,(cli_token) 
1c2a			ld a,(hl) 
1c2a			ld (os_word_scratch),a 
1c2a				ld hl,(cli_ptr) 
1c2a			ld a,(hl) 
1c2a				ld (os_word_scratch+1),a 
1c2a				ld a,0 
1c2a				ld (os_word_scratch+2),a 
1c2a				ld de,os_word_scratch 
1c2a				ld a,display_row_4 
1c2a				call str_at_display 
1c2a				call update_display 
1c2a			.skip2:  
1c2a			endif 
1c2a 2a c9 f9			ld hl,(cli_token) 
1c2d 7e				ld a, (hl)	 ; char in word token 
1c2e 23				inc hl 		; move to next char 
1c2f 22 c9 f9			ld (cli_token), hl ; and save it 
1c32 47				ld b,a 
1c33			 
1c33 2a c3 f9			ld hl,(cli_ptr) ;	get the char from the string to parse 
1c36 7e				ld a,(hl) 
1c37 23				inc hl 
1c38 22 c3 f9			ld (cli_ptr), hl		; move to next char 
1c3b cd 64 10			call toUpper 		; make sure the input string matches case 
1c3e			 
1c3e			if DEBUG_FORTH_PARSE 
1c3e			endif 
1c3e			 
1c3e				; input stream end of token is a space so get rid of it 
1c3e			 
1c3e			;	cp ' ' 
1c3e			;	jr nz, .pnskipspace 
1c3e			; 
1c3e			;	ld a, 0		; make same term as word token term 
1c3e			; 
1c3e			;.pnskipspace: 
1c3e			 
1c3e			if DEBUG_FORTH_PARSE_KEY 
1c3e						DMARK "KY7" 
1c3e			endif 
1c3e b8				cp b 
1c3f c2 55 1c			jp nz, .execpnskipword	 ; no match so move to next word 
1c42				 
1c42			;    if same 
1c42			;       scan for string terms 0 for token and 32 for input 
1c42			 
1c42				 
1c42			if DEBUG_FORTH_PARSE_KEY 
1c42						DMARK "KY8" 
1c42			endif 
1c42			 
1c42 80				add b			 
1c43 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
1c45							; TODO need to make sure last word in zero term string is accounted for 
1c45 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
1c47			 
1c47			 
1c47				; at end of both strings so both are exact match 
1c47			 
1c47			;       skip ptr for next word 
1c47			 
1c47 2a c3 f9			ld hl,(cli_ptr) 	; at input string term 
1c4a 23				inc hl			 ; at next char 
1c4b 22 c3 f9			ld (cli_ptr), hl     ; save for next round of the parser 
1c4e 22 c1 f9			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
1c51				 
1c51				 
1c51			if DEBUG_FORTH_PARSE_KEY 
1c51						DMARK "KY3" 
1c51			endif 
1c51			 
1c51			 
1c51			 
1c51			;       exec code block 
1c51			if DEBUG_FORTH_JP 
1c51				call clear_display 
1c51				call update_display 
1c51				call delay1s 
1c51				ld hl, (cli_execword)     ; save for next check if no match on this word 
1c51				ld a,h 
1c51				ld hl, os_word_scratch 
1c51				call hexout 
1c51				ld hl, (cli_execword)     ; save for next check if no match on this word 
1c51				ld a,l 
1c51				ld hl, os_word_scratch+2 
1c51				call hexout 
1c51				ld hl, os_word_scratch+4 
1c51				ld a,0 
1c51				ld (hl),a 
1c51				ld de,os_word_scratch 
1c51				call str_at_display 
1c51					ld a, display_row_2 
1c51					call str_at_display 
1c51				ld de, (cli_origtoken) 
1c51				ld a, display_row_1+10 
1c51					call str_at_display 
1c51			 
1c51				ld a,display_row_1 
1c51				ld de, .foundword 
1c51				ld a, display_row_3 
1c51				call str_at_display 
1c51				call update_display 
1c51				call delay1s 
1c51				call delay1s 
1c51				call delay1s 
1c51			endif 
1c51			 
1c51			if DEBUG_FORTH_PARSE_KEY 
1c51						DMARK "KYj" 
1c51			endif 
1c51				; TODO save the word pointer in this exec 
1c51			 
1c51 2a c7 f9			ld hl,(cli_execword) 
1c54 e9				jp (hl) 
1c55			 
1c55			 
1c55			;    if not same 
1c55			;	scan for zero term 
1c55			;	get ptr for next word 
1c55			;	goto word comp 
1c55			 
1c55			.execpnskipword:	; get pointer to next word 
1c55 2a c5 f9			ld hl,(cli_nextword) 
1c58			 
1c58 7e				ld a,(hl) 
1c59 fe 00			cp WORD_SYS_END 
1c5b			;	cp 0 
1c5b 28 09			jr z, .execendofdict			 ; at end of words 
1c5d			 
1c5d			if DEBUG_FORTH_PARSE_KEY 
1c5d						DMARK "KY4" 
1c5d			endif 
1c5d			if DEBUG_FORTH_PARSE_EXEC 
1c5d			 
1c5d				; see if disabled 
1c5d			 
1c5d				ld a, (os_view_disable) 
1c5d				cp '*' 
1c5d				jr z, .noskip 
1c5d			 
1c5d			 
1c5d				ld de, .nowordfound 
1c5d				ld a, display_row_3 
1c5d				call str_at_display 
1c5d				call update_display 
1c5d				ld a, 100 
1c5d				call aDelayInMS 
1c5d				 
1c5d				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1c5d					call delay250ms 
1c5d				endif 
1c5d			.noskip:  
1c5d			 
1c5d			endif	 
1c5d			 
1c5d 2a c1 f9			ld hl,(cli_origptr) 
1c60 22 c3 f9			ld (cli_ptr),hl 
1c63			 
1c63			if DEBUG_FORTH_PARSE_KEY 
1c63						DMARK "KY5" 
1c63			endif 
1c63 c3 09 1c			jp .execpnword			; else go to next word 
1c66			 
1c66			.execendofdict:  
1c66			 
1c66			if DEBUG_FORTH_PARSE_KEY 
1c66						DMARK "KYe" 
1c66			endif 
1c66			if DEBUG_FORTH_PARSE_EXEC 
1c66				; see if disabled 
1c66			 
1c66				ld a, (os_view_disable) 
1c66				cp '*' 
1c66				jr z, .ispskip 
1c66			 
1c66				call clear_display 
1c66				call update_display 
1c66				call delay1s 
1c66				ld de, (cli_origptr) 
1c66				ld a, display_row_1 
1c66				call str_at_display 
1c66				 
1c66				ld de, .enddict 
1c66				ld a, display_row_3 
1c66				call str_at_display 
1c66				call update_display 
1c66				ld a, 100 
1c66				call aDelayInMS 
1c66				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1c66				call delay1s 
1c66				call delay1s 
1c66				call delay1s 
1c66				endif 
1c66			.ispskip:  
1c66				 
1c66			endif	 
1c66			 
1c66			 
1c66			 
1c66				; if the word is not a keyword then must be a literal so push it to stack 
1c66			 
1c66			; push token to stack to end of word 
1c66			 
1c66				STACKFRAME ON $1efe $2f9f 
1c66				if DEBUG_STACK_IMB 
1c66					if ON 
1c66						exx 
1c66						ld de, $1efe 
1c66						ld a, d 
1c66						ld hl, curframe 
1c66						call hexout 
1c66						ld a, e 
1c66						ld hl, curframe+2 
1c66						call hexout 
1c66						ld hl, $1efe 
1c66						push hl 
1c66						ld hl, $2f9f 
1c66						push hl 
1c66						exx 
1c66					endif 
1c66				endif 
1c66			endm 
# End of macro STACKFRAME
1c66			 
1c66 2a b9 f2		ld hl,(os_tok_ptr) 
1c69 cd b5 19		call forth_apush 
1c6c			 
1c6c				STACKFRAMECHK ON $1efe $2f9f 
1c6c				if DEBUG_STACK_IMB 
1c6c					if ON 
1c6c						exx 
1c6c						ld hl, $2f9f 
1c6c						pop de   ; $2f9f 
1c6c						call cmp16 
1c6c						jr nz, .spnosame 
1c6c						ld hl, $1efe 
1c6c						pop de   ; $1efe 
1c6c						call cmp16 
1c6c						jr z, .spfrsame 
1c6c						.spnosame: call showsperror 
1c6c						.spfrsame: nop 
1c6c						exx 
1c6c					endif 
1c6c				endif 
1c6c			endm 
# End of macro STACKFRAMECHK
1c6c			 
1c6c			execnext: 
1c6c			 
1c6c			if DEBUG_FORTH_PARSE_KEY 
1c6c						DMARK "KY>" 
1c6c			endif 
1c6c			; move past token to next word 
1c6c			 
1c6c 2a b9 f2		ld hl, (os_tok_ptr) 
1c6f 3e 00		ld a, 0 
1c71 01 ff 00		ld bc, 255     ; input buffer size 
1c74 ed b1		cpir 
1c76			 
1c76			if DEBUG_FORTH_PARSE_KEY 
1c76						DMARK "KY!" 
1c76				CALLMONITOR 
1c76			endif	 
1c76			; TODO this might place hl on the null, so will need to forward on??? 
1c76			;inc hl   ; see if this gets onto the next item 
1c76			 
1c76			 
1c76			; TODO pass a pointer to the buffer to push 
1c76			; TODO call function to push 
1c76			 
1c76			; look for end of input 
1c76			 
1c76			;inc hl 
1c76			;ld a,(hl) 
1c76			;cp FORTH_END_BUFFER 
1c76			;ret z 
1c76			 
1c76			 
1c76 c3 ef 1b		jp exec1 
1c79			 
1c79			 
1c79			 
1c79			 
1c79			 
1c79			 
1c79			 
1c79			 
1c79			 
1c79			findnexttok: 
1c79			 
1c79				; hl is pointer to move 
1c79				; de is the token to locate 
1c79			 
1c79					if DEBUG_FORTH 
1c79						DMARK "NTK" 
1c79						CALLMONITOR 
1c79					endif 
1c79 d5				push de 
1c7a			 
1c7a			.fnt1:	 
1c7a				; find first char of token to locate 
1c7a			 
1c7a 1a				ld a, (de) 
1c7b 4f				ld c,a 
1c7c 7e				ld a,(hl) 
1c7d cd 64 10			call toUpper 
1c80					if DEBUG_FORTH 
1c80						DMARK "NT1" 
1c80						CALLMONITOR 
1c80					endif 
1c80 b9				cp c 
1c81			 
1c81 28 03			jr z, .fnt2cmpmorefirst	 
1c83			 
1c83				; first char not found move to next char 
1c83			 
1c83 23				inc hl 
1c84 18 f4			jr .fnt1 
1c86			 
1c86			.fnt2cmpmorefirst:	 
1c86				; first char of token found.  
1c86			 
1c86 e5				push hl     ; save start of token just in case it is the right one 
1c87 d9				exx 
1c88 e1				pop hl        ; save it to hl' 
1c89 d9				exx 
1c8a			 
1c8a			 
1c8a			.fnt2cmpmore:	 
1c8a				; compare the rest 
1c8a				 
1c8a 23				inc hl 
1c8b 13				inc de 
1c8c				 
1c8c 1a				ld a, (de) 
1c8d 4f				ld c,a 
1c8e 7e				ld a,(hl) 
1c8f cd 64 10			call toUpper 
1c92			 
1c92					if DEBUG_FORTH 
1c92						DMARK "NT2" 
1c92						CALLMONITOR 
1c92					endif 
1c92				; c has the token to find char 
1c92				; a has the mem to scan char 
1c92			 
1c92 b9				cp c 
1c93 28 04			jr z,.fntmatch1 
1c95			 
1c95				; they are not the same 
1c95			 
1c95					if DEBUG_FORTH 
1c95						DMARK "NT3" 
1c95						CALLMONITOR 
1c95					endif 
1c95 d1				pop de	; reset de token to look for 
1c96 d5				push de 
1c97 18 e1			jr .fnt1 
1c99				 
1c99			.fntmatch1: 
1c99			 
1c99				; is the same char a null which means we might have a full hit? 
1c99					if DEBUG_FORTH 
1c99						DMARK "NT4" 
1c99						CALLMONITOR 
1c99					endif 
1c99			 
1c99 fe 00			cp 0 
1c9b 28 0b			jr z, .fntmatchyes 
1c9d			 
1c9d				; are we at the end of the token to find? 
1c9d			 
1c9d					if DEBUG_FORTH 
1c9d						DMARK "NT5" 
1c9d						CALLMONITOR 
1c9d					endif 
1c9d 3e 00			ld a, 0 
1c9f b9				cp c 
1ca0			 
1ca0 c2 8a 1c			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
1ca3			 
1ca3					if DEBUG_FORTH 
1ca3						DMARK "NT6" 
1ca3						CALLMONITOR 
1ca3					endif 
1ca3				; token to find is exhusted but no match to stream 
1ca3			 
1ca3				; restore tok pointer and continue on 
1ca3 d1				pop de 
1ca4 d5				push de 
1ca5 c3 7a 1c			jp .fnt1 
1ca8			 
1ca8			 
1ca8			.fntmatchyes: 
1ca8			 
1ca8				; hl now contains the end of the found token 
1ca8			 
1ca8				; get rid of saved token pointer to find 
1ca8			 
1ca8 d1				pop de 
1ca9			 
1ca9					if DEBUG_FORTH 
1ca9						DMARK "NT9" 
1ca9						CALLMONITOR 
1ca9					endif 
1ca9			 
1ca9				; hl will be on the null term so forward on 
1ca9			 
1ca9				; get back the saved start of the token 
1ca9			 
1ca9 d9				exx 
1caa e5				push hl     ; save start of token just in case it is the right one 
1cab d9				exx 
1cac e1				pop hl        ; save it to hl 
1cad			 
1cad c9				ret 
1cae			 
1cae			 
1cae			; LIST needs to find a specific token   
1cae			; FORGET needs to find a spefici token 
1cae			 
1cae			; SAVE needs to find all tokens by flag 
1cae			; WORDS just needs to scan through all  by flag 
1cae			; UWORDS needs to scan through all by flag 
1cae			 
1cae			 
1cae			; given hl as pointer to start of dict look up string 
1cae			; return hl as pointer to start of word block 
1cae			; or 0 if not found 
1cae			 
1cae			forth_find_tok: 
1cae c9				ret 
1caf			 
1caf			; given hl as pointer to dict structure 
1caf			; move to the next dict block structure 
1caf			 
1caf			forth_tok_next: 
1caf				; hl now points to the address of the next word pointer  
1caf				; TODO skip compiled symbol for now 
1caf			;	push de 
1caf 23				inc hl 
1cb0 5e				ld e, (hl) 
1cb1 23				inc hl 
1cb2 56				ld d, (hl) 
1cb3 23				inc hl 
1cb4			 
1cb4 eb				ex de,hl 
1cb5			if DEBUG_FORTH_PARSE_NEXTWORD 
1cb5				push bc 
1cb5				ld bc, (cli_nextword) 
1cb5						DMARK "NXW" 
1cb5				CALLMONITOR 
1cb5				pop bc 
1cb5			endif 
1cb5			;	pop de	 
1cb5 c9				ret 
1cb6			 
1cb6			 
1cb6			 
1cb6			; eof 
# End of file forth_parserv5.asm
1cb6				include "forth_wordsv4.asm" 
1cb6			 
1cb6			; the core word dictionary v4 
1cb6			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
1cb6			 
1cb6			; this is a linked list for each of the system words used 
1cb6			; user defined words will follow the same format but will be in ram 
1cb6			 
1cb6			 
1cb6			; 
1cb6			; 
1cb6			; define linked list: 
1cb6			; 
1cb6			; 1. compiled byte op code 
1cb6			; 2. len of text word 
1cb6			; 3. text word 
1cb6			; 4. ptr to next dictionary word 
1cb6			; 5. asm, calls etc for the word 
1cb6			; 
1cb6			;  if 1 == 0 then last word in dict  
1cb6			;   
1cb6			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
1cb6			;  
1cb6			;  
1cb6			; create basic standard set of words 
1cb6			; 
1cb6			;  
1cb6			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
1cb6			; 2DUP 2DROP 2SWAP  
1cb6			; @ C@ - get byte  
1cb6			; ! C! - store byte 
1cb6			; 0< true if less than zero 
1cb6			; 0= true if zero 
1cb6			; < >  
1cb6			; = true if same 
1cb6			; variables 
1cb6			 
1cb6			 
1cb6			; Hardware specific words I may need 
1cb6			; 
1cb6			; IN OUT  
1cb6			; calls to key util functions 
1cb6			; calls to hardward abstraction stuff 
1cb6			; easy control of frame buffers and lcd i/o 
1cb6			; keyboard  
1cb6			 
1cb6			 
1cb6			;DICT: macro 
1cb6			; op_code, len, word, next 
1cb6			;    word: 
1cb6			;    db op_code 
1cb6			;    ds word zero term 
1cb6			;    dw next 
1cb6			;    endm 
1cb6			 
1cb6			 
1cb6			 
1cb6			 
1cb6			; op code 1 is a flag for user define words which are to be handled differently 
1cb6			 
1cb6			 
1cb6			; 
1cb6			; 
1cb6			;    TODO on entry to a word this should be the expected environment 
1cb6			;    hl - tos value if number then held, if string this is the ptr 
1cb6			;    de -  
1cb6			 
1cb6			 
1cb6			; opcode ranges 
1cb6			; 0 - end of word dict 
1cb6			; 255 - user define words 
1cb6			 
1cb6			sysdict: 
1cb6			include "forth_opcodes.asm" 
1cb6			; op codes for forth keywords 
1cb6			; free to use code 0  
1cb6				OPCODE_HEAP: equ  1 
1cb6				OPCODE_EXEC: equ 2 
1cb6				OPCODE_DUP: equ 3 
1cb6				OPCODE_SWAP: equ 4 
1cb6				OPCODE_COLN: equ 5 
1cb6				OPCODE_SCOLN: equ 6 
1cb6				OPCODE_DROP: equ 7 
1cb6				OPCODE_DUP2: equ 8 
1cb6				OPCODE_DROP2: equ 9 
1cb6				OPCODE_SWAP2: equ 10 
1cb6				OPCODE_AT: equ 11 
1cb6				OPCODE_CAT: equ 12 
1cb6				OPCODE_BANG: equ 13 
1cb6				OPCODE_CBANG: equ 14 
1cb6				OPCODE_SCALL: equ 15 
1cb6				OPCODE_DEPTH: equ 16 
1cb6				OPCODE_OVER: equ 17 
1cb6				OPCODE_PAUSE: equ 18 
1cb6				OPCODE_PAUSES: equ 19 
1cb6				OPCODE_ROT: equ 20 
1cb6			;free to reuse	OPCODE_WORDS: equ 21 
1cb6			        OPCODE_NOT: equ 21 
1cb6				OPCODE_UWORDS: equ 22 
1cb6				OPCODE_BP: equ 23 
1cb6				OPCODE_MONITOR: equ 24  
1cb6				OPCODE_MALLOC: equ 25 
1cb6				OPCODE_FREE: equ 26 
1cb6				OPCODE_LIST: equ 27 
1cb6				OPCODE_FORGET: equ 28 
1cb6				OPCODE_NOP: equ 29 
1cb6				OPCODE_COMO: equ 30 
1cb6				OPCODE_COMC: equ 31 
1cb6			;free to reuse	OPCODE_ENDCORE: equ 32 
1cb6				OPCODE_AFTERSOUND: equ 33 
1cb6				OPCODE_GP2: equ 34 
1cb6				OPCODE_GP3: equ 35 
1cb6				OPCODE_GP4: equ 36 
1cb6				OPCODE_SIN: equ 37 
1cb6				OPCODE_SOUT: equ 38 
1cb6				OPCODE_SPIO: equ 39 
1cb6				OPCODE_SPICEH: equ 40 
1cb6				OPCODE_SPIOb: equ 41 
1cb6				OPCODE_SPII: equ 42 
1cb6				OPCODE_SESEL: equ 43 
1cb6				OPCODE_CARTDEV: equ 44 
1cb6			; free to reuse	OPCODE_ENDDEVICE: equ 45 
1cb6				OPCODE_FB: equ 46 
1cb6				OPCODE_EMIT: equ 47 
1cb6				OPCODE_DOTH: equ 48 
1cb6				OPCODE_DOTF: equ 49 
1cb6				OPCODE_DOT: equ 50 
1cb6				OPCODE_CLS: equ 51 
1cb6				OPCODE_DRAW: equ 52 
1cb6				OPCODE_DUMP: equ 53 
1cb6				OPCODE_CDUMP: equ 54 
1cb6				OPCODE_DAT: equ 55 
1cb6				OPCODE_HOME: equ 56 
1cb6				OPCODE_SPACE: equ 57 
1cb6				OPCODE_SPACES: equ 58 
1cb6				OPCODE_SCROLL: equ 59 
1cb6				OPCODE_ATQ: equ 60 
1cb6				OPCODE_AUTODSP: equ 61 
1cb6				OPCODE_MENU: equ 62 
1cb6			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
1cb6				OPCODE_THEN: equ 64 
1cb6				OPCODE_ELSE: equ 65 
1cb6				OPCODE_DO: equ 66 
1cb6				OPCODE_LOOP: equ 67 
1cb6				OPCODE_I: equ 68 
1cb6				OPCODE_DLOOP: equ 69  
1cb6				OPCODE_REPEAT: equ 70  
1cb6				OPCODE_UNTIL: equ 71 
1cb6				OPCODE_ENDFLOW: equ 72 
1cb6				OPCODE_WAITK: equ 73 
1cb6				OPCODE_ACCEPT: equ 74 
1cb6				OPCODE_EDIT: equ 75 
1cb6			;free to reuse	OPCODE_ENDKEY: equ 76 
1cb6				OPCODE_LZERO: equ 77 
1cb6				OPCODE_TZERO: equ 78 
1cb6				OPCODE_LESS: equ 79 
1cb6				OPCODE_GT: equ 80 
1cb6				OPCODE_EQUAL: equ 81  
1cb6			;free to reuse	OPCODE_ENDLOGIC: equ 82 
1cb6				OPCODE_NEG: equ 83 
1cb6				OPCODE_DIV: equ 84 
1cb6				OPCODE_MUL: equ 85 
1cb6				OPCODE_MIN: equ 86 
1cb6				OPCODE_MAX: equ 87 
1cb6				OPCODE_RND16: equ 88 
1cb6				OPCODE_RND8: equ 89 
1cb6				OPCODE_RND: equ 90 
1cb6			;free to reuse	OPCODE_ENDMATHS: equ 91  
1cb6				OPCODE_BYNAME: equ 92 
1cb6				OPCODE_DIR: equ 93 
1cb6				OPCODE_SAVE: equ 94 
1cb6				OPCODE_LOAD: equ 95 
1cb6				OPCODE_BSAVE: equ 96 
1cb6				OPCODE_BLOAD: equ 97 
1cb6				OPCODE_SEO: equ 98  
1cb6				OPCODE_SEI: equ 99 
1cb6				OPCODE_SFREE: equ 100 
1cb6				OPCODE_SIZE: equ 101 
1cb6				OPCODE_CREATE: equ 102 
1cb6				OPCODE_APPEND: equ 103 
1cb6				OPCODE_SDEL: equ 104 
1cb6				OPCODE_OPEN: equ 105 
1cb6				OPCODE_READ: equ 106 
1cb6				OPCODE_EOF: equ 106 
1cb6				OPCODE_FORMAT: equ 107 
1cb6				OPCODE_LABEL: equ 108 
1cb6				OPCODE_LABELS: equ 109 
1cb6			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
1cb6				OPCODE_UPPER: equ 111 
1cb6				OPCODE_LOWER: equ 112 
1cb6				OPCODE_SUBSTR: equ 113 
1cb6				OPCODE_LEFT: equ 114 
1cb6				OPCODE_RIGHT: equ 115 
1cb6				OPCODE_STR2NUM: equ 116 
1cb6				OPCODE_NUM2STR: equ 117 
1cb6				OPCODE_CONCAT: equ 118 
1cb6				OPCODE_FIND: equ 119 
1cb6				OPCODE_LEN: equ 120 
1cb6				OPCODE_CHAR: equ 121 
1cb6			; free to reuse	OPCODE_STRLEN: equ 122 
1cb6			; free to reuse	OPCODE_ENDSTR: equ 123 
1cb6				OPCODE_V0S: equ 124 
1cb6				OPCODE_V0Q: equ 125 
1cb6				OPCODE_V1S: equ 126 
1cb6				OPCODE_V1Q: equ 127 
1cb6				OPCODE_V2S: equ 128 
1cb6				OPCODE_V2Q: equ 129 
1cb6				OPCODE_V3S: equ 130 
1cb6				OPCODE_V3Q: equ 131 
1cb6			;free to reuse	OPCODE_END: equ 132 
1cb6				OPCODE_ZDUP: equ 133 
1cb6			 
1cb6			; eof 
# End of file forth_opcodes.asm
1cb6			 
1cb6			include "forth_words_core.asm" 
1cb6			 
1cb6			; | ## Core Words 
1cb6			 
1cb6			;if MALLOC_4 
1cb6			 
1cb6			.HEAP: 
1cb6				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
1cb6 15				db WORD_SYS_CORE+OPCODE_HEAP             
1cb7 f5 1c			dw .EXEC            
1cb9 05				db 4 + 1 
1cba .. 00			db "HEAP",0              
1cbf				endm 
# End of macro CWHEAD
1cbf			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
1cbf			; | | u1 - Current number of bytes in the heap 
1cbf			; | | u2 - Remaining bytes left on the heap 
1cbf			; | |  
1cbf			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
1cbf			 
1cbf			 
1cbf					if DEBUG_FORTH_WORDS_KEY 
1cbf						DMARK "HEP" 
1cbf f5				push af  
1cc0 3a d4 1c			ld a, (.dmark)  
1cc3 32 bd fb			ld (debug_mark),a  
1cc6 3a d5 1c			ld a, (.dmark+1)  
1cc9 32 be fb			ld (debug_mark+1),a  
1ccc 3a d6 1c			ld a, (.dmark+2)  
1ccf 32 bf fb			ld (debug_mark+2),a  
1cd2 18 03			jr .pastdmark  
1cd4 ..			.dmark: db "HEP"  
1cd7 f1			.pastdmark: pop af  
1cd8			endm  
# End of macro DMARK
1cd8						CALLMONITOR 
1cd8 cd d3 13			call break_point_state  
1cdb				endm  
# End of macro CALLMONITOR
1cdb					endif 
1cdb 2a 0a 80				ld hl, (free_list )      
1cde 11 0e 80				ld de, heap_start 
1ce1			 
1ce1 ed 52				sbc hl, de  
1ce3			 
1ce3 cd 6d 19				call forth_push_numhl 
1ce6			 
1ce6			 
1ce6 ed 5b 0a 80			ld de, (free_list )      
1cea 21 ac ef				ld hl, heap_end 
1ced			 
1ced ed 52				sbc hl, de 
1cef			 
1cef cd 6d 19				call forth_push_numhl 
1cf2					 
1cf2			 
1cf2					 
1cf2			 
1cf2			 
1cf2			 
1cf2					NEXTW 
1cf2 c3 5e 1b			jp macro_next 
1cf5				endm 
# End of macro NEXTW
1cf5			;endif 
1cf5			 
1cf5			.EXEC: 
1cf5				CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
1cf5 16				db WORD_SYS_CORE+OPCODE_EXEC             
1cf6 91 1d			dw .STKEXEC            
1cf8 05				db 4 + 1 
1cf9 .. 00			db "EXEC",0              
1cfe				endm 
# End of macro CWHEAD
1cfe			; | EXEC ( u -- )    Execs the string on TOS as a FORTH expression | CRASHES ON NEXTW 
1cfe			; | | u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
1cfe			; | | 
1cfe			; | |   
1cfe				STACKFRAME OFF $5efe $5f9f 
1cfe				if DEBUG_STACK_IMB 
1cfe					if OFF 
1cfe						exx 
1cfe						ld de, $5efe 
1cfe						ld a, d 
1cfe						ld hl, curframe 
1cfe						call hexout 
1cfe						ld a, e 
1cfe						ld hl, curframe+2 
1cfe						call hexout 
1cfe						ld hl, $5efe 
1cfe						push hl 
1cfe						ld hl, $5f9f 
1cfe						push hl 
1cfe						exx 
1cfe					endif 
1cfe				endif 
1cfe			endm 
# End of macro STACKFRAME
1cfe			 
1cfe					if DEBUG_FORTH_WORDS_KEY 
1cfe						DMARK "EXE" 
1cfe f5				push af  
1cff 3a 13 1d			ld a, (.dmark)  
1d02 32 bd fb			ld (debug_mark),a  
1d05 3a 14 1d			ld a, (.dmark+1)  
1d08 32 be fb			ld (debug_mark+1),a  
1d0b 3a 15 1d			ld a, (.dmark+2)  
1d0e 32 bf fb			ld (debug_mark+2),a  
1d11 18 03			jr .pastdmark  
1d13 ..			.dmark: db "EXE"  
1d16 f1			.pastdmark: pop af  
1d17			endm  
# End of macro DMARK
1d17						CALLMONITOR 
1d17 cd d3 13			call break_point_state  
1d1a				endm  
# End of macro CALLMONITOR
1d1a					endif 
1d1a			 
1d1a				FORTH_DSP_VALUEHL 
1d1a cd 08 1a			call macro_dsp_valuehl 
1d1d				endm 
# End of macro FORTH_DSP_VALUEHL
1d1d			 
1d1d				FORTH_DSP_POP 
1d1d cd a4 1a			call macro_forth_dsp_pop 
1d20				endm 
# End of macro FORTH_DSP_POP
1d20			 
1d20					if DEBUG_FORTH_WORDS 
1d20						DMARK "EX1" 
1d20 f5				push af  
1d21 3a 35 1d			ld a, (.dmark)  
1d24 32 bd fb			ld (debug_mark),a  
1d27 3a 36 1d			ld a, (.dmark+1)  
1d2a 32 be fb			ld (debug_mark+1),a  
1d2d 3a 37 1d			ld a, (.dmark+2)  
1d30 32 bf fb			ld (debug_mark+2),a  
1d33 18 03			jr .pastdmark  
1d35 ..			.dmark: db "EX1"  
1d38 f1			.pastdmark: pop af  
1d39			endm  
# End of macro DMARK
1d39						CALLMONITOR 
1d39 cd d3 13			call break_point_state  
1d3c				endm  
# End of macro CALLMONITOR
1d3c					endif 
1d3c			;	ld e,(hl) 
1d3c			;	inc hl 
1d3c			;	ld d,(hl) 
1d3c			;	ex de,hl 
1d3c			 
1d3c			;		if DEBUG_FORTH_WORDS 
1d3c			;			DMARK "EX2" 
1d3c			;			CALLMONITOR 
1d3c			;		endif 
1d3c e5				push hl 
1d3d			 
1d3d				;ld a, 0 
1d3d				;ld a, FORTH_END_BUFFER 
1d3d cd 6d 10			call strlenz 
1d40 23				inc hl   ; include zero term to copy 
1d41 23				inc hl   ; include term 
1d42 23				inc hl   ; include term 
1d43 06 00			ld b,0 
1d45 4d				ld c,l 
1d46 e1				pop hl 
1d47 11 b7 f0			ld de, execscratch 
1d4a					if DEBUG_FORTH_WORDS 
1d4a						DMARK "EX3" 
1d4a f5				push af  
1d4b 3a 5f 1d			ld a, (.dmark)  
1d4e 32 bd fb			ld (debug_mark),a  
1d51 3a 60 1d			ld a, (.dmark+1)  
1d54 32 be fb			ld (debug_mark+1),a  
1d57 3a 61 1d			ld a, (.dmark+2)  
1d5a 32 bf fb			ld (debug_mark+2),a  
1d5d 18 03			jr .pastdmark  
1d5f ..			.dmark: db "EX3"  
1d62 f1			.pastdmark: pop af  
1d63			endm  
# End of macro DMARK
1d63						CALLMONITOR 
1d63 cd d3 13			call break_point_state  
1d66				endm  
# End of macro CALLMONITOR
1d66					endif 
1d66 ed b0			ldir 
1d68			 
1d68			 
1d68 21 b7 f0			ld hl, execscratch 
1d6b			 
1d6b					if DEBUG_FORTH_WORDS 
1d6b						DMARK "EXe" 
1d6b f5				push af  
1d6c 3a 80 1d			ld a, (.dmark)  
1d6f 32 bd fb			ld (debug_mark),a  
1d72 3a 81 1d			ld a, (.dmark+1)  
1d75 32 be fb			ld (debug_mark+1),a  
1d78 3a 82 1d			ld a, (.dmark+2)  
1d7b 32 bf fb			ld (debug_mark+2),a  
1d7e 18 03			jr .pastdmark  
1d80 ..			.dmark: db "EXe"  
1d83 f1			.pastdmark: pop af  
1d84			endm  
# End of macro DMARK
1d84						CALLMONITOR 
1d84 cd d3 13			call break_point_state  
1d87				endm  
# End of macro CALLMONITOR
1d87					endif 
1d87			 
1d87 cd ac 1b			call forthparse 
1d8a cd ec 1b			call forthexec 
1d8d			;	call forthexec_cleanup 
1d8d			;	call forthparse 
1d8d			;	call forthexec 
1d8d			 
1d8d				STACKFRAMECHK OFF $5efe $5f9f 
1d8d				if DEBUG_STACK_IMB 
1d8d					if OFF 
1d8d						exx 
1d8d						ld hl, $5f9f 
1d8d						pop de   ; $5f9f 
1d8d						call cmp16 
1d8d						jr nz, .spnosame 
1d8d						ld hl, $5efe 
1d8d						pop de   ; $5efe 
1d8d						call cmp16 
1d8d						jr z, .spfrsame 
1d8d						.spnosame: call showsperror 
1d8d						.spfrsame: nop 
1d8d						exx 
1d8d					endif 
1d8d				endif 
1d8d			endm 
# End of macro STACKFRAMECHK
1d8d			 
1d8d				; an immediate word so no need to process any more words 
1d8d c9				ret 
1d8e				NEXTW 
1d8e c3 5e 1b			jp macro_next 
1d91				endm 
# End of macro NEXTW
1d91			 
1d91			; dead code - old version  
1d91			;	FORTH_RSP_NEXT 
1d91			 
1d91			;  
1d91			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1d91			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1d91			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1d91			;	push hl 
1d91			;	push de 
1d91			;	push bc 
1d91			; 
1d91			; 
1d91			;		if DEBUG_FORTH_WORDS_KEY 
1d91			;			DMARK "EXR" 
1d91			;			CALLMONITOR 
1d91			;		endif 
1d91			; 
1d91			; 
1d91			; 
1d91			;	;v5 FORTH_DSP_VALUE 
1d91			;	FORTH_DSP_VALUEHL 
1d91			; 
1d91			;	; TODO do string type checks 
1d91			; 
1d91			;;v5	inc hl   ; skip type 
1d91			; 
1d91			;	push hl  ; source code  
1d91			;		if DEBUG_FORTH_WORDS 
1d91			;			DMARK "EX1" 
1d91			;			CALLMONITOR 
1d91			;		endif 
1d91			;	ld a, 0 
1d91			;	call strlent 
1d91			; 
1d91			;	inc hl 
1d91			;	inc hl 
1d91			;	inc hl 
1d91			;	inc hl 
1d91			; 
1d91			;	push hl    ; size 
1d91			; 
1d91			;		if DEBUG_FORTH_WORDS 
1d91			;			DMARK "EX2" 
1d91			;			CALLMONITOR 
1d91			;		endif 
1d91			;	call malloc 
1d91			; 
1d91			;	ex de, hl    ; de now contains malloc area 
1d91			;	pop bc   	; get byte count 
1d91			;	pop hl      ; get string to copy 
1d91			; 
1d91			;	push de     ; save malloc for free later 
1d91			; 
1d91			;		if DEBUG_FORTH_WORDS 
1d91			;			DMARK "EX3" 
1d91			;			CALLMONITOR 
1d91			;		endif 
1d91			;	ldir       ; duplicate string 
1d91			; 
1d91			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
1d91			;	 
1d91			;	; TODO fix the parse would be better than this...  
1d91			;	ex de, hl 
1d91			;	dec hl 
1d91			;	ld a, 0 
1d91			;	ld (hl), a 
1d91			;	dec hl 
1d91			;	ld a, ' ' 
1d91			;	ld (hl), a 
1d91			;	dec hl 
1d91			;	ld (hl), a 
1d91			; 
1d91			;	dec hl 
1d91			;	ld (hl), a 
1d91			; 
1d91			; 
1d91			;	FORTH_DSP_POP  
1d91			; 
1d91			;	pop hl     
1d91			;	push hl    ; save malloc area 
1d91			; 
1d91			;		if DEBUG_FORTH_WORDS 
1d91			;			DMARK "EX4" 
1d91			;			CALLMONITOR 
1d91			;		endif 
1d91			; 
1d91			;	call forthparse 
1d91			;	call forthexec 
1d91			;	 
1d91			;	pop hl 
1d91			;	if DEBUG_FORTH_WORDS 
1d91			;		DMARK "EX5" 
1d91			;		CALLMONITOR 
1d91			;	endif 
1d91			; 
1d91			;	if FORTH_ENABLE_FREE 
1d91			;	call free 
1d91			;	endif 
1d91			; 
1d91			;	if DEBUG_FORTH_WORDS 
1d91			;		DMARK "EX6" 
1d91			;		CALLMONITOR 
1d91			;	endif 
1d91			; 
1d91			;	pop bc 
1d91			;	pop de 
1d91			;	pop hl 
1d91			;;	FORTH_RSP_POP	  
1d91			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
1d91			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
1d91			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
1d91			; 
1d91			;	if DEBUG_FORTH_WORDS 
1d91			;		DMARK "EX7" 
1d91			;		CALLMONITOR 
1d91			;	endif 
1d91			;	NEXTW 
1d91			 
1d91			.STKEXEC: 
1d91				CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
1d91 3f				db WORD_SYS_CORE+43             
1d92 d9 1e			dw .ZDUP            
1d94 08				db 7 + 1 
1d95 .. 00			db "STKEXEC",0              
1d9d				endm 
# End of macro CWHEAD
1d9d			; | STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code | TO TEST 
1d9d			 
1d9d			 
1d9d					if DEBUG_FORTH_WORDS_KEY 
1d9d						DMARK "STX" 
1d9d f5				push af  
1d9e 3a b2 1d			ld a, (.dmark)  
1da1 32 bd fb			ld (debug_mark),a  
1da4 3a b3 1d			ld a, (.dmark+1)  
1da7 32 be fb			ld (debug_mark+1),a  
1daa 3a b4 1d			ld a, (.dmark+2)  
1dad 32 bf fb			ld (debug_mark+2),a  
1db0 18 03			jr .pastdmark  
1db2 ..			.dmark: db "STX"  
1db5 f1			.pastdmark: pop af  
1db6			endm  
# End of macro DMARK
1db6						CALLMONITOR 
1db6 cd d3 13			call break_point_state  
1db9				endm  
# End of macro CALLMONITOR
1db9					endif 
1db9			 
1db9				FORTH_DSP_VALUEHL 
1db9 cd 08 1a			call macro_dsp_valuehl 
1dbc				endm 
# End of macro FORTH_DSP_VALUEHL
1dbc			 
1dbc 22 e6 f9			ld (store_tmp1), hl    ; count 
1dbf			 
1dbf				FORTH_DSP_POP 
1dbf cd a4 1a			call macro_forth_dsp_pop 
1dc2				endm 
# End of macro FORTH_DSP_POP
1dc2			.stkexec1: 
1dc2 2a e6 f9			ld hl, (store_tmp1)   ; count 
1dc5 3e 00			ld a, 0 
1dc7 bd				cp l 
1dc8 c8				ret z 
1dc9			 
1dc9 2b				dec hl 
1dca 22 e6 f9			ld (store_tmp1), hl    ; count 
1dcd				 
1dcd				FORTH_DSP_VALUEHL 
1dcd cd 08 1a			call macro_dsp_valuehl 
1dd0				endm 
# End of macro FORTH_DSP_VALUEHL
1dd0 e5				push hl 
1dd1				 
1dd1					if DEBUG_FORTH_WORDS 
1dd1						DMARK "EXp" 
1dd1 f5				push af  
1dd2 3a e6 1d			ld a, (.dmark)  
1dd5 32 bd fb			ld (debug_mark),a  
1dd8 3a e7 1d			ld a, (.dmark+1)  
1ddb 32 be fb			ld (debug_mark+1),a  
1dde 3a e8 1d			ld a, (.dmark+2)  
1de1 32 bf fb			ld (debug_mark+2),a  
1de4 18 03			jr .pastdmark  
1de6 ..			.dmark: db "EXp"  
1de9 f1			.pastdmark: pop af  
1dea			endm  
# End of macro DMARK
1dea						CALLMONITOR 
1dea cd d3 13			call break_point_state  
1ded				endm  
# End of macro CALLMONITOR
1ded					endif 
1ded				FORTH_DSP_POP 
1ded cd a4 1a			call macro_forth_dsp_pop 
1df0				endm 
# End of macro FORTH_DSP_POP
1df0			 
1df0 cd 6d 10			call strlenz 
1df3 23				inc hl   ; include zero term to copy 
1df4 23				inc hl   ; include zero term to copy 
1df5 23				inc hl   ; include zero term to copy 
1df6 06 00			ld b,0 
1df8 4d				ld c,l 
1df9 e1				pop hl 
1dfa 11 b7 f0			ld de, execscratch 
1dfd					if DEBUG_FORTH_WORDS 
1dfd						DMARK "EX3" 
1dfd f5				push af  
1dfe 3a 12 1e			ld a, (.dmark)  
1e01 32 bd fb			ld (debug_mark),a  
1e04 3a 13 1e			ld a, (.dmark+1)  
1e07 32 be fb			ld (debug_mark+1),a  
1e0a 3a 14 1e			ld a, (.dmark+2)  
1e0d 32 bf fb			ld (debug_mark+2),a  
1e10 18 03			jr .pastdmark  
1e12 ..			.dmark: db "EX3"  
1e15 f1			.pastdmark: pop af  
1e16			endm  
# End of macro DMARK
1e16						CALLMONITOR 
1e16 cd d3 13			call break_point_state  
1e19				endm  
# End of macro CALLMONITOR
1e19					endif 
1e19 ed b0			ldir 
1e1b			 
1e1b			 
1e1b 21 b7 f0			ld hl, execscratch 
1e1e			 
1e1e					if DEBUG_FORTH_WORDS 
1e1e						DMARK "EXP" 
1e1e f5				push af  
1e1f 3a 33 1e			ld a, (.dmark)  
1e22 32 bd fb			ld (debug_mark),a  
1e25 3a 34 1e			ld a, (.dmark+1)  
1e28 32 be fb			ld (debug_mark+1),a  
1e2b 3a 35 1e			ld a, (.dmark+2)  
1e2e 32 bf fb			ld (debug_mark+2),a  
1e31 18 03			jr .pastdmark  
1e33 ..			.dmark: db "EXP"  
1e36 f1			.pastdmark: pop af  
1e37			endm  
# End of macro DMARK
1e37						CALLMONITOR 
1e37 cd d3 13			call break_point_state  
1e3a				endm  
# End of macro CALLMONITOR
1e3a					endif 
1e3a			 
1e3a cd ac 1b			call forthparse 
1e3d 21 b7 f0			ld hl, execscratch 
1e40					if DEBUG_FORTH_WORDS 
1e40						DMARK "EXx" 
1e40 f5				push af  
1e41 3a 55 1e			ld a, (.dmark)  
1e44 32 bd fb			ld (debug_mark),a  
1e47 3a 56 1e			ld a, (.dmark+1)  
1e4a 32 be fb			ld (debug_mark+1),a  
1e4d 3a 57 1e			ld a, (.dmark+2)  
1e50 32 bf fb			ld (debug_mark+2),a  
1e53 18 03			jr .pastdmark  
1e55 ..			.dmark: db "EXx"  
1e58 f1			.pastdmark: pop af  
1e59			endm  
# End of macro DMARK
1e59						CALLMONITOR 
1e59 cd d3 13			call break_point_state  
1e5c				endm  
# End of macro CALLMONITOR
1e5c					endif 
1e5c cd ec 1b			call forthexec 
1e5f			 
1e5f c3 c2 1d			jp .stkexec1 
1e62			 
1e62 c9				ret 
1e63			 
1e63			 
1e63			.DUP: 
1e63				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
1e63 17				db WORD_SYS_CORE+OPCODE_DUP             
1e64 d9 1e			dw .ZDUP            
1e66 04				db 3 + 1 
1e67 .. 00			db "DUP",0              
1e6b				endm 
# End of macro CWHEAD
1e6b			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
1e6b			 
1e6b					if DEBUG_FORTH_WORDS_KEY 
1e6b						DMARK "DUP" 
1e6b f5				push af  
1e6c 3a 80 1e			ld a, (.dmark)  
1e6f 32 bd fb			ld (debug_mark),a  
1e72 3a 81 1e			ld a, (.dmark+1)  
1e75 32 be fb			ld (debug_mark+1),a  
1e78 3a 82 1e			ld a, (.dmark+2)  
1e7b 32 bf fb			ld (debug_mark+2),a  
1e7e 18 03			jr .pastdmark  
1e80 ..			.dmark: db "DUP"  
1e83 f1			.pastdmark: pop af  
1e84			endm  
# End of macro DMARK
1e84						CALLMONITOR 
1e84 cd d3 13			call break_point_state  
1e87				endm  
# End of macro CALLMONITOR
1e87					endif 
1e87			 
1e87					FORTH_DSP 
1e87 cd ed 19			call macro_forth_dsp 
1e8a				endm 
# End of macro FORTH_DSP
1e8a			 
1e8a 7e					ld a, (HL) 
1e8b fe 01				cp DS_TYPE_STR 
1e8d 20 25				jr nz, .dupinum 
1e8f			 
1e8f					; push another string 
1e8f			 
1e8f					FORTH_DSP_VALUEHL     		 
1e8f cd 08 1a			call macro_dsp_valuehl 
1e92				endm 
# End of macro FORTH_DSP_VALUEHL
1e92			 
1e92				if DEBUG_FORTH_WORDS 
1e92					DMARK "DUs" 
1e92 f5				push af  
1e93 3a a7 1e			ld a, (.dmark)  
1e96 32 bd fb			ld (debug_mark),a  
1e99 3a a8 1e			ld a, (.dmark+1)  
1e9c 32 be fb			ld (debug_mark+1),a  
1e9f 3a a9 1e			ld a, (.dmark+2)  
1ea2 32 bf fb			ld (debug_mark+2),a  
1ea5 18 03			jr .pastdmark  
1ea7 ..			.dmark: db "DUs"  
1eaa f1			.pastdmark: pop af  
1eab			endm  
# End of macro DMARK
1eab					CALLMONITOR 
1eab cd d3 13			call break_point_state  
1eae				endm  
# End of macro CALLMONITOR
1eae				endif 
1eae cd 7f 19				call forth_push_str 
1eb1			 
1eb1					NEXTW 
1eb1 c3 5e 1b			jp macro_next 
1eb4				endm 
# End of macro NEXTW
1eb4			 
1eb4			 
1eb4			.dupinum: 
1eb4					 
1eb4			 
1eb4			 
1eb4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
1eb4 cd 08 1a			call macro_dsp_valuehl 
1eb7				endm 
# End of macro FORTH_DSP_VALUEHL
1eb7			 
1eb7				; TODO add floating point number detection 
1eb7			 
1eb7				if DEBUG_FORTH_WORDS 
1eb7					DMARK "DUi" 
1eb7 f5				push af  
1eb8 3a cc 1e			ld a, (.dmark)  
1ebb 32 bd fb			ld (debug_mark),a  
1ebe 3a cd 1e			ld a, (.dmark+1)  
1ec1 32 be fb			ld (debug_mark+1),a  
1ec4 3a ce 1e			ld a, (.dmark+2)  
1ec7 32 bf fb			ld (debug_mark+2),a  
1eca 18 03			jr .pastdmark  
1ecc ..			.dmark: db "DUi"  
1ecf f1			.pastdmark: pop af  
1ed0			endm  
# End of macro DMARK
1ed0					CALLMONITOR 
1ed0 cd d3 13			call break_point_state  
1ed3				endm  
# End of macro CALLMONITOR
1ed3				endif 
1ed3			 
1ed3 cd 6d 19				call forth_push_numhl 
1ed6					NEXTW 
1ed6 c3 5e 1b			jp macro_next 
1ed9				endm 
# End of macro NEXTW
1ed9			.ZDUP: 
1ed9				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
1ed9 99				db WORD_SYS_CORE+OPCODE_ZDUP             
1eda 11 1f			dw .SWAP            
1edc 05				db 4 + 1 
1edd .. 00			db "?DUP",0              
1ee2				endm 
# End of macro CWHEAD
1ee2			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
1ee2			 
1ee2					if DEBUG_FORTH_WORDS_KEY 
1ee2						DMARK "qDU" 
1ee2 f5				push af  
1ee3 3a f7 1e			ld a, (.dmark)  
1ee6 32 bd fb			ld (debug_mark),a  
1ee9 3a f8 1e			ld a, (.dmark+1)  
1eec 32 be fb			ld (debug_mark+1),a  
1eef 3a f9 1e			ld a, (.dmark+2)  
1ef2 32 bf fb			ld (debug_mark+2),a  
1ef5 18 03			jr .pastdmark  
1ef7 ..			.dmark: db "qDU"  
1efa f1			.pastdmark: pop af  
1efb			endm  
# End of macro DMARK
1efb						CALLMONITOR 
1efb cd d3 13			call break_point_state  
1efe				endm  
# End of macro CALLMONITOR
1efe					endif 
1efe					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
1efe cd 08 1a			call macro_dsp_valuehl 
1f01				endm 
# End of macro FORTH_DSP_VALUEHL
1f01			 
1f01 e5					push hl 
1f02			 
1f02					; is it a zero? 
1f02			 
1f02 3e 00				ld a, 0 
1f04 84					add h 
1f05 85					add l 
1f06			 
1f06 e1					pop hl 
1f07			 
1f07 fe 00				cp 0 
1f09 28 03				jr z, .dup2orig 
1f0b			 
1f0b			 
1f0b cd 6d 19				call forth_push_numhl 
1f0e			 
1f0e			 
1f0e				; TODO add floating point number detection 
1f0e			 
1f0e			.dup2orig: 
1f0e			 
1f0e					NEXTW 
1f0e c3 5e 1b			jp macro_next 
1f11				endm 
# End of macro NEXTW
1f11			.SWAP: 
1f11				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
1f11 18				db WORD_SYS_CORE+OPCODE_SWAP             
1f12 50 1f			dw .COLN            
1f14 05				db 4 + 1 
1f15 .. 00			db "SWAP",0              
1f1a				endm 
# End of macro CWHEAD
1f1a			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
1f1a					if DEBUG_FORTH_WORDS_KEY 
1f1a						DMARK "SWP" 
1f1a f5				push af  
1f1b 3a 2f 1f			ld a, (.dmark)  
1f1e 32 bd fb			ld (debug_mark),a  
1f21 3a 30 1f			ld a, (.dmark+1)  
1f24 32 be fb			ld (debug_mark+1),a  
1f27 3a 31 1f			ld a, (.dmark+2)  
1f2a 32 bf fb			ld (debug_mark+2),a  
1f2d 18 03			jr .pastdmark  
1f2f ..			.dmark: db "SWP"  
1f32 f1			.pastdmark: pop af  
1f33			endm  
# End of macro DMARK
1f33						CALLMONITOR 
1f33 cd d3 13			call break_point_state  
1f36				endm  
# End of macro CALLMONITOR
1f36					endif 
1f36			 
1f36					FORTH_DSP_VALUEHL 
1f36 cd 08 1a			call macro_dsp_valuehl 
1f39				endm 
# End of macro FORTH_DSP_VALUEHL
1f39 e5					push hl     ; w2 
1f3a			 
1f3a					FORTH_DSP_POP 
1f3a cd a4 1a			call macro_forth_dsp_pop 
1f3d				endm 
# End of macro FORTH_DSP_POP
1f3d			 
1f3d					FORTH_DSP_VALUEHL 
1f3d cd 08 1a			call macro_dsp_valuehl 
1f40				endm 
# End of macro FORTH_DSP_VALUEHL
1f40			 
1f40					FORTH_DSP_POP 
1f40 cd a4 1a			call macro_forth_dsp_pop 
1f43				endm 
# End of macro FORTH_DSP_POP
1f43			 
1f43 d1					pop de     ; w2	, hl = w1 
1f44			 
1f44 eb					ex de, hl 
1f45 d5					push de 
1f46			 
1f46 cd 6d 19				call forth_push_numhl 
1f49			 
1f49 e1					pop hl 
1f4a			 
1f4a cd 6d 19				call forth_push_numhl 
1f4d					 
1f4d			 
1f4d					NEXTW 
1f4d c3 5e 1b			jp macro_next 
1f50				endm 
# End of macro NEXTW
1f50			.COLN: 
1f50				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
1f50 19				db WORD_SYS_CORE+OPCODE_COLN             
1f51 dc 20			dw .SCOLN            
1f53 02				db 1 + 1 
1f54 .. 00			db ":",0              
1f56				endm 
# End of macro CWHEAD
1f56			; | : ( -- )         Create new word | DONE 
1f56			 
1f56					if DEBUG_FORTH_WORDS_KEY 
1f56						DMARK "CLN" 
1f56 f5				push af  
1f57 3a 6b 1f			ld a, (.dmark)  
1f5a 32 bd fb			ld (debug_mark),a  
1f5d 3a 6c 1f			ld a, (.dmark+1)  
1f60 32 be fb			ld (debug_mark+1),a  
1f63 3a 6d 1f			ld a, (.dmark+2)  
1f66 32 bf fb			ld (debug_mark+2),a  
1f69 18 03			jr .pastdmark  
1f6b ..			.dmark: db "CLN"  
1f6e f1			.pastdmark: pop af  
1f6f			endm  
# End of macro DMARK
1f6f						CALLMONITOR 
1f6f cd d3 13			call break_point_state  
1f72				endm  
# End of macro CALLMONITOR
1f72					endif 
1f72				STACKFRAME OFF $8efe $989f 
1f72				if DEBUG_STACK_IMB 
1f72					if OFF 
1f72						exx 
1f72						ld de, $8efe 
1f72						ld a, d 
1f72						ld hl, curframe 
1f72						call hexout 
1f72						ld a, e 
1f72						ld hl, curframe+2 
1f72						call hexout 
1f72						ld hl, $8efe 
1f72						push hl 
1f72						ld hl, $989f 
1f72						push hl 
1f72						exx 
1f72					endif 
1f72				endif 
1f72			endm 
# End of macro STACKFRAME
1f72				; get parser buffer length  of new word 
1f72			 
1f72				 
1f72			 
1f72					; move tok past this to start of name defintition 
1f72					; TODO get word to define 
1f72					; TODO Move past word token 
1f72					; TODO get length of string up to the ';' 
1f72			 
1f72 2a b9 f2			ld hl, (os_tok_ptr) 
1f75 23				inc hl 
1f76 23				inc hl 
1f77			 
1f77 3e 3b			ld a, ';' 
1f79 cd 78 10			call strlent 
1f7c			 
1f7c 7d				ld a,l 
1f7d 32 b8 f1			ld (os_new_parse_len), a 
1f80			 
1f80			 
1f80			if DEBUG_FORTH_UWORD 
1f80 ed 5b b9 f2		ld de, (os_tok_ptr) 
1f84						DMARK ":01" 
1f84 f5				push af  
1f85 3a 99 1f			ld a, (.dmark)  
1f88 32 bd fb			ld (debug_mark),a  
1f8b 3a 9a 1f			ld a, (.dmark+1)  
1f8e 32 be fb			ld (debug_mark+1),a  
1f91 3a 9b 1f			ld a, (.dmark+2)  
1f94 32 bf fb			ld (debug_mark+2),a  
1f97 18 03			jr .pastdmark  
1f99 ..			.dmark: db ":01"  
1f9c f1			.pastdmark: pop af  
1f9d			endm  
# End of macro DMARK
1f9d				CALLMONITOR 
1f9d cd d3 13			call break_point_state  
1fa0				endm  
# End of macro CALLMONITOR
1fa0			endif 
1fa0			 
1fa0			; 
1fa0			;  new word memory layout: 
1fa0			;  
1fa0			;    : adg 6666 ;  
1fa0			; 
1fa0			;    db   1     ; user defined word  
1fa0 23				inc hl    
1fa1			;    dw   sysdict 
1fa1 23				inc hl 
1fa2 23				inc hl 
1fa3			;    db <word len>+1 (for null) 
1fa3 23				inc hl 
1fa4			;    db .... <word> 
1fa4			; 
1fa4			 
1fa4 23				inc hl    ; some extras for the word preamble before the above 
1fa5 23				inc hl 
1fa6 23				inc hl 
1fa7 23				inc hl 
1fa8 23				inc hl 
1fa9 23				inc hl 
1faa 23				inc hl  
1fab 23				inc hl 
1fac 23				inc hl 
1fad 23				inc hl 
1fae 23				inc hl 
1faf 23				inc hl 
1fb0 23				inc hl 
1fb1 23				inc hl     ; TODO how many do we really need?     maybe only 6 
1fb2			;       exec word buffer 
1fb2			;	<ptr word>   
1fb2 23				inc hl 
1fb3 23				inc hl 
1fb4			;       <word list><null term> 7F final term 
1fb4			 
1fb4			 
1fb4			if DEBUG_FORTH_UWORD 
1fb4						DMARK ":02" 
1fb4 f5				push af  
1fb5 3a c9 1f			ld a, (.dmark)  
1fb8 32 bd fb			ld (debug_mark),a  
1fbb 3a ca 1f			ld a, (.dmark+1)  
1fbe 32 be fb			ld (debug_mark+1),a  
1fc1 3a cb 1f			ld a, (.dmark+2)  
1fc4 32 bf fb			ld (debug_mark+2),a  
1fc7 18 03			jr .pastdmark  
1fc9 ..			.dmark: db ":02"  
1fcc f1			.pastdmark: pop af  
1fcd			endm  
# End of macro DMARK
1fcd				CALLMONITOR 
1fcd cd d3 13			call break_point_state  
1fd0				endm  
# End of macro CALLMONITOR
1fd0			endif 
1fd0			 
1fd0				 
1fd0					; malloc the size 
1fd0			 
1fd0 cd d6 10				call malloc 
1fd3 22 b6 f1				ld (os_new_malloc), hl     ; save malloc start 
1fd6			 
1fd6			;    db   1     ; user defined word  
1fd6 3e 01				ld a, WORD_SYS_UWORD  
1fd8 77					ld (hl), a 
1fd9				 
1fd9 23				inc hl    
1fda			;    dw   sysdict 
1fda 11 b6 1c			ld de, sysdict       ; continue on with the scan to the system dict 
1fdd 73				ld (hl), e 
1fde 23				inc hl 
1fdf 72				ld (hl), d 
1fe0 23				inc hl 
1fe1			 
1fe1			 
1fe1			;    Setup dict word 
1fe1			 
1fe1 23				inc hl 
1fe2 22 bc f1			ld (os_new_work_ptr), hl     ; save start of dict word  
1fe5			 
1fe5				; 1. get length of dict word 
1fe5			 
1fe5			 
1fe5 2a b9 f2			ld hl, (os_tok_ptr) 
1fe8 23				inc hl 
1fe9 23				inc hl    ; position to start of dict word 
1fea 3e 00			ld a, 0 
1fec cd 78 10			call strlent 
1fef			 
1fef			 
1fef 23				inc hl    ; to include null??? 
1ff0			 
1ff0				; write length of dict word 
1ff0			 
1ff0 ed 5b bc f1		ld de, (os_new_work_ptr)   ; get dest for copy of word 
1ff4 1b				dec de 
1ff5 eb				ex de, hl 
1ff6 73				ld (hl), e 
1ff7 eb				ex de, hl 
1ff8			 
1ff8				 
1ff8			 
1ff8				; copy  
1ff8 4d				ld c, l 
1ff9 06 00			ld b, 0 
1ffb ed 5b bc f1		ld de, (os_new_work_ptr)   ; get dest for copy of word 
1fff 2a b9 f2			ld hl, (os_tok_ptr) 
2002 23				inc hl 
2003 23				inc hl    ; position to start of dict word 
2004				 
2004			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
2004				 
2004				; TODO need to convert word to upper case 
2004			 
2004			ucasetok:	 
2004 7e				ld a,(hl) 
2005 cd 64 10			call toUpper 
2008 77				ld (hl),a 
2009 ed a0			ldi 
200b f2 04 20		 	jp p, ucasetok 
200e			 
200e			 
200e			 
200e				; de now points to start of where the word body code should be placed 
200e ed 53 bc f1		ld (os_new_work_ptr), de 
2012				; hl now points to the words to throw at forthexec which needs to be copied 
2012 22 be f1			ld (os_new_src_ptr), hl 
2015			 
2015				; TODO add 'call to forthexec' 
2015			 
2015			if DEBUG_FORTH_UWORD 
2015 c5				push bc 
2016 ed 4b b6 f1		ld bc, (os_new_malloc) 
201a						DMARK ":0x" 
201a f5				push af  
201b 3a 2f 20			ld a, (.dmark)  
201e 32 bd fb			ld (debug_mark),a  
2021 3a 30 20			ld a, (.dmark+1)  
2024 32 be fb			ld (debug_mark+1),a  
2027 3a 31 20			ld a, (.dmark+2)  
202a 32 bf fb			ld (debug_mark+2),a  
202d 18 03			jr .pastdmark  
202f ..			.dmark: db ":0x"  
2032 f1			.pastdmark: pop af  
2033			endm  
# End of macro DMARK
2033				CALLMONITOR 
2033 cd d3 13			call break_point_state  
2036				endm  
# End of macro CALLMONITOR
2036 c1				pop bc 
2037			endif 
2037			 
2037			 
2037				; create word preamble which should be: 
2037			 
2037			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
2037			 
2037				;    ld hl, <word code> 
2037				;    jp user_exec 
2037			        ;    <word code bytes> 
2037			 
2037			 
2037			;	inc de     ; TODO ??? or are we already past the word's null 
2037 eb				ex de, hl 
2038			 
2038 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
203a			 
203a 23				inc hl 
203b 22 c2 f1			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
203e 23				inc hl 
203f			 
203f 23				inc hl 
2040 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
2042			 
2042 01 d5 4d			ld bc, user_exec 
2045 23				inc hl 
2046 71				ld (hl), c     ; poke address of user_exec 
2047 23				inc hl 
2048 70				ld (hl), b     
2049			 ; 
2049			;	inc hl 
2049			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2049			; 
2049			; 
2049			;	ld bc, macro_forth_rsp_next 
2049			;	inc hl 
2049			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
2049			;	inc hl 
2049			;	ld (hl), b     
2049			 ; 
2049			;	inc hl 
2049			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2049			; 
2049			; 
2049			;	inc hl 
2049			;	ld bc, forthexec 
2049			;	ld (hl), c     ; poke address of forthexec 
2049			;	inc hl 
2049			;	ld (hl), b      
2049			; 
2049			;	inc hl 
2049			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
2049			; 
2049			;	ld bc, user_dict_next 
2049			;	inc hl 
2049			;	ld (hl), c     ; poke address of forthexec 
2049			;	inc hl 
2049			;	ld (hl), b      
2049			 
2049				; hl is now where we need to copy the word byte data to save this 
2049			 
2049 23				inc hl 
204a 22 c0 f1			ld (os_new_exec), hl 
204d				 
204d				; copy definition 
204d			 
204d eb				ex de, hl 
204e			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
204e			;	inc de    ; skip the PC for this parse 
204e 3a b8 f1			ld a, (os_new_parse_len) 
2051 4f				ld c, a 
2052 06 00			ld b, 0 
2054 ed b0			ldir		 ; copy defintion 
2056			 
2056			 
2056				; poke the address of where the new word bytes live for forthexec 
2056			 
2056 2a c2 f1			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
2059			 
2059 ed 5b c0 f1		ld de, (os_new_exec)      
205d				 
205d 73				ld (hl), e 
205e 23				inc hl 
205f 72				ld (hl), d 
2060			 
2060					; TODO copy last user dict word next link to this word 
2060					; TODO update last user dict word to point to this word 
2060			; 
2060			; hl f923 de 812a ; bc 811a 
2060			 
2060			if DEBUG_FORTH_UWORD 
2060 c5				push bc 
2061 ed 4b b6 f1		ld bc, (os_new_malloc) 
2065						DMARK ":0A" 
2065 f5				push af  
2066 3a 7a 20			ld a, (.dmark)  
2069 32 bd fb			ld (debug_mark),a  
206c 3a 7b 20			ld a, (.dmark+1)  
206f 32 be fb			ld (debug_mark+1),a  
2072 3a 7c 20			ld a, (.dmark+2)  
2075 32 bf fb			ld (debug_mark+2),a  
2078 18 03			jr .pastdmark  
207a ..			.dmark: db ":0A"  
207d f1			.pastdmark: pop af  
207e			endm  
# End of macro DMARK
207e				CALLMONITOR 
207e cd d3 13			call break_point_state  
2081				endm  
# End of macro CALLMONITOR
2081 c1				pop bc 
2082			endif 
2082			if DEBUG_FORTH_UWORD 
2082 c5				push bc 
2083 ed 4b b6 f1		ld bc, (os_new_malloc) 
2087 03				inc bc 
2088 03				inc bc 
2089 03				inc bc 
208a 03				inc bc 
208b 03				inc bc 
208c 03				inc bc 
208d 03				inc bc 
208e 03				inc bc 
208f			 
208f						DMARK ":0B" 
208f f5				push af  
2090 3a a4 20			ld a, (.dmark)  
2093 32 bd fb			ld (debug_mark),a  
2096 3a a5 20			ld a, (.dmark+1)  
2099 32 be fb			ld (debug_mark+1),a  
209c 3a a6 20			ld a, (.dmark+2)  
209f 32 bf fb			ld (debug_mark+2),a  
20a2 18 03			jr .pastdmark  
20a4 ..			.dmark: db ":0B"  
20a7 f1			.pastdmark: pop af  
20a8			endm  
# End of macro DMARK
20a8				CALLMONITOR 
20a8 cd d3 13			call break_point_state  
20ab				endm  
# End of macro CALLMONITOR
20ab c1				pop bc 
20ac			endif 
20ac			 
20ac			; update word dict linked list for new word 
20ac			 
20ac			 
20ac 2a b5 f2		ld hl, (os_last_new_uword)		; get the start of the last added uword 
20af 23			inc hl     ; move to next work linked list ptr 
20b0			 
20b0 ed 5b b6 f1	ld de, (os_new_malloc)		 ; new next word 
20b4 73			ld (hl), e 
20b5 23			inc hl 
20b6 72			ld (hl), d 
20b7			 
20b7			if DEBUG_FORTH_UWORD 
20b7 ed 4b b5 f2		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
20bb			endif 
20bb			 
20bb ed 53 b5 f2	ld (os_last_new_uword), de      ; update last new uword ptr 
20bf			 
20bf			 
20bf			if DEBUG_FORTH_UWORD 
20bf						DMARK ":0+" 
20bf f5				push af  
20c0 3a d4 20			ld a, (.dmark)  
20c3 32 bd fb			ld (debug_mark),a  
20c6 3a d5 20			ld a, (.dmark+1)  
20c9 32 be fb			ld (debug_mark+1),a  
20cc 3a d6 20			ld a, (.dmark+2)  
20cf 32 bf fb			ld (debug_mark+2),a  
20d2 18 03			jr .pastdmark  
20d4 ..			.dmark: db ":0+"  
20d7 f1			.pastdmark: pop af  
20d8			endm  
# End of macro DMARK
20d8				CALLMONITOR 
20d8 cd d3 13			call break_point_state  
20db				endm  
# End of macro CALLMONITOR
20db			endif 
20db			 
20db				STACKFRAMECHK OFF $8efe $989f 
20db				if DEBUG_STACK_IMB 
20db					if OFF 
20db						exx 
20db						ld hl, $989f 
20db						pop de   ; $989f 
20db						call cmp16 
20db						jr nz, .spnosame 
20db						ld hl, $8efe 
20db						pop de   ; $8efe 
20db						call cmp16 
20db						jr z, .spfrsame 
20db						.spnosame: call showsperror 
20db						.spfrsame: nop 
20db						exx 
20db					endif 
20db				endif 
20db			endm 
# End of macro STACKFRAMECHK
20db			 
20db c9			ret    ; dont process any remaining parser tokens as they form new word 
20dc			 
20dc			 
20dc			 
20dc			 
20dc			;		NEXT 
20dc			.SCOLN: 
20dc			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
20dc 06				db OPCODE_SCOLN 
20dd 28 21			dw .DROP 
20df 02				db 2 
20e0 .. 00			db ";",0           
20e2			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
20e2					if DEBUG_FORTH_WORDS_KEY 
20e2						DMARK "SCN" 
20e2 f5				push af  
20e3 3a f7 20			ld a, (.dmark)  
20e6 32 bd fb			ld (debug_mark),a  
20e9 3a f8 20			ld a, (.dmark+1)  
20ec 32 be fb			ld (debug_mark+1),a  
20ef 3a f9 20			ld a, (.dmark+2)  
20f2 32 bf fb			ld (debug_mark+2),a  
20f5 18 03			jr .pastdmark  
20f7 ..			.dmark: db "SCN"  
20fa f1			.pastdmark: pop af  
20fb			endm  
# End of macro DMARK
20fb						CALLMONITOR 
20fb cd d3 13			call break_point_state  
20fe				endm  
# End of macro CALLMONITOR
20fe					endif 
20fe					FORTH_RSP_TOS 
20fe cd 2b 19			call macro_forth_rsp_tos 
2101				endm 
# End of macro FORTH_RSP_TOS
2101 e5					push hl 
2102					FORTH_RSP_POP 
2102 cd 35 19			call macro_forth_rsp_pop 
2105				endm 
# End of macro FORTH_RSP_POP
2105 e1					pop hl 
2106			;		ex de,hl 
2106 22 b9 f2				ld (os_tok_ptr),hl 
2109			 
2109			if DEBUG_FORTH_UWORD 
2109						DMARK "SCL" 
2109 f5				push af  
210a 3a 1e 21			ld a, (.dmark)  
210d 32 bd fb			ld (debug_mark),a  
2110 3a 1f 21			ld a, (.dmark+1)  
2113 32 be fb			ld (debug_mark+1),a  
2116 3a 20 21			ld a, (.dmark+2)  
2119 32 bf fb			ld (debug_mark+2),a  
211c 18 03			jr .pastdmark  
211e ..			.dmark: db "SCL"  
2121 f1			.pastdmark: pop af  
2122			endm  
# End of macro DMARK
2122				CALLMONITOR 
2122 cd d3 13			call break_point_state  
2125				endm  
# End of macro CALLMONITOR
2125			endif 
2125					NEXTW 
2125 c3 5e 1b			jp macro_next 
2128				endm 
# End of macro NEXTW
2128			 
2128			.DROP: 
2128				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
2128 1b				db WORD_SYS_CORE+OPCODE_DROP             
2129 53 21			dw .DUP2            
212b 05				db 4 + 1 
212c .. 00			db "DROP",0              
2131				endm 
# End of macro CWHEAD
2131			; | DROP ( w -- )   drop the TOS item   | DONE 
2131					if DEBUG_FORTH_WORDS_KEY 
2131						DMARK "DRP" 
2131 f5				push af  
2132 3a 46 21			ld a, (.dmark)  
2135 32 bd fb			ld (debug_mark),a  
2138 3a 47 21			ld a, (.dmark+1)  
213b 32 be fb			ld (debug_mark+1),a  
213e 3a 48 21			ld a, (.dmark+2)  
2141 32 bf fb			ld (debug_mark+2),a  
2144 18 03			jr .pastdmark  
2146 ..			.dmark: db "DRP"  
2149 f1			.pastdmark: pop af  
214a			endm  
# End of macro DMARK
214a						CALLMONITOR 
214a cd d3 13			call break_point_state  
214d				endm  
# End of macro CALLMONITOR
214d					endif 
214d					FORTH_DSP_POP 
214d cd a4 1a			call macro_forth_dsp_pop 
2150				endm 
# End of macro FORTH_DSP_POP
2150					NEXTW 
2150 c3 5e 1b			jp macro_next 
2153				endm 
# End of macro NEXTW
2153			.DUP2: 
2153				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
2153 1c				db WORD_SYS_CORE+OPCODE_DUP2             
2154 98 21			dw .DROP2            
2156 05				db 4 + 1 
2157 .. 00			db "2DUP",0              
215c				endm 
# End of macro CWHEAD
215c			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
215c					if DEBUG_FORTH_WORDS_KEY 
215c						DMARK "2DU" 
215c f5				push af  
215d 3a 71 21			ld a, (.dmark)  
2160 32 bd fb			ld (debug_mark),a  
2163 3a 72 21			ld a, (.dmark+1)  
2166 32 be fb			ld (debug_mark+1),a  
2169 3a 73 21			ld a, (.dmark+2)  
216c 32 bf fb			ld (debug_mark+2),a  
216f 18 03			jr .pastdmark  
2171 ..			.dmark: db "2DU"  
2174 f1			.pastdmark: pop af  
2175			endm  
# End of macro DMARK
2175						CALLMONITOR 
2175 cd d3 13			call break_point_state  
2178				endm  
# End of macro CALLMONITOR
2178					endif 
2178					FORTH_DSP_VALUEHL 
2178 cd 08 1a			call macro_dsp_valuehl 
217b				endm 
# End of macro FORTH_DSP_VALUEHL
217b e5					push hl      ; 2 
217c			 
217c					FORTH_DSP_POP 
217c cd a4 1a			call macro_forth_dsp_pop 
217f				endm 
# End of macro FORTH_DSP_POP
217f					 
217f					FORTH_DSP_VALUEHL 
217f cd 08 1a			call macro_dsp_valuehl 
2182				endm 
# End of macro FORTH_DSP_VALUEHL
2182			;		push hl      ; 1 
2182			 
2182					FORTH_DSP_POP 
2182 cd a4 1a			call macro_forth_dsp_pop 
2185				endm 
# End of macro FORTH_DSP_POP
2185			 
2185			;		pop hl       ; 1 
2185 d1					pop de       ; 2 
2186			 
2186 cd 6d 19				call forth_push_numhl 
2189 eb					ex de, hl 
218a cd 6d 19				call forth_push_numhl 
218d			 
218d					 
218d eb					ex de, hl 
218e			 
218e cd 6d 19				call forth_push_numhl 
2191 eb					ex de, hl 
2192 cd 6d 19				call forth_push_numhl 
2195			 
2195			 
2195					NEXTW 
2195 c3 5e 1b			jp macro_next 
2198				endm 
# End of macro NEXTW
2198			.DROP2: 
2198				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
2198 1d				db WORD_SYS_CORE+OPCODE_DROP2             
2199 c7 21			dw .SWAP2            
219b 06				db 5 + 1 
219c .. 00			db "2DROP",0              
21a2				endm 
# End of macro CWHEAD
21a2			; | 2DROP ( w w -- )    Double drop | DONE 
21a2					if DEBUG_FORTH_WORDS_KEY 
21a2						DMARK "2DR" 
21a2 f5				push af  
21a3 3a b7 21			ld a, (.dmark)  
21a6 32 bd fb			ld (debug_mark),a  
21a9 3a b8 21			ld a, (.dmark+1)  
21ac 32 be fb			ld (debug_mark+1),a  
21af 3a b9 21			ld a, (.dmark+2)  
21b2 32 bf fb			ld (debug_mark+2),a  
21b5 18 03			jr .pastdmark  
21b7 ..			.dmark: db "2DR"  
21ba f1			.pastdmark: pop af  
21bb			endm  
# End of macro DMARK
21bb						CALLMONITOR 
21bb cd d3 13			call break_point_state  
21be				endm  
# End of macro CALLMONITOR
21be					endif 
21be					FORTH_DSP_POP 
21be cd a4 1a			call macro_forth_dsp_pop 
21c1				endm 
# End of macro FORTH_DSP_POP
21c1					FORTH_DSP_POP 
21c1 cd a4 1a			call macro_forth_dsp_pop 
21c4				endm 
# End of macro FORTH_DSP_POP
21c4					NEXTW 
21c4 c3 5e 1b			jp macro_next 
21c7				endm 
# End of macro NEXTW
21c7			.SWAP2: 
21c7				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
21c7 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
21c8 f0 21			dw .AT            
21ca 06				db 5 + 1 
21cb .. 00			db "2SWAP",0              
21d1				endm 
# End of macro CWHEAD
21d1			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
21d1					if DEBUG_FORTH_WORDS_KEY 
21d1						DMARK "2SW" 
21d1 f5				push af  
21d2 3a e6 21			ld a, (.dmark)  
21d5 32 bd fb			ld (debug_mark),a  
21d8 3a e7 21			ld a, (.dmark+1)  
21db 32 be fb			ld (debug_mark+1),a  
21de 3a e8 21			ld a, (.dmark+2)  
21e1 32 bf fb			ld (debug_mark+2),a  
21e4 18 03			jr .pastdmark  
21e6 ..			.dmark: db "2SW"  
21e9 f1			.pastdmark: pop af  
21ea			endm  
# End of macro DMARK
21ea						CALLMONITOR 
21ea cd d3 13			call break_point_state  
21ed				endm  
# End of macro CALLMONITOR
21ed					endif 
21ed					NEXTW 
21ed c3 5e 1b			jp macro_next 
21f0				endm 
# End of macro NEXTW
21f0			.AT: 
21f0				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
21f0 1f				db WORD_SYS_CORE+OPCODE_AT             
21f1 22 22			dw .CAT            
21f3 02				db 1 + 1 
21f4 .. 00			db "@",0              
21f6				endm 
# End of macro CWHEAD
21f6			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
21f6			 
21f6					if DEBUG_FORTH_WORDS_KEY 
21f6						DMARK "AT." 
21f6 f5				push af  
21f7 3a 0b 22			ld a, (.dmark)  
21fa 32 bd fb			ld (debug_mark),a  
21fd 3a 0c 22			ld a, (.dmark+1)  
2200 32 be fb			ld (debug_mark+1),a  
2203 3a 0d 22			ld a, (.dmark+2)  
2206 32 bf fb			ld (debug_mark+2),a  
2209 18 03			jr .pastdmark  
220b ..			.dmark: db "AT."  
220e f1			.pastdmark: pop af  
220f			endm  
# End of macro DMARK
220f						CALLMONITOR 
220f cd d3 13			call break_point_state  
2212				endm  
# End of macro CALLMONITOR
2212					endif 
2212			.getbyteat:	 
2212					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2212 cd 08 1a			call macro_dsp_valuehl 
2215				endm 
# End of macro FORTH_DSP_VALUEHL
2215					 
2215			;		push hl 
2215				 
2215					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2215 cd a4 1a			call macro_forth_dsp_pop 
2218				endm 
# End of macro FORTH_DSP_POP
2218			 
2218			;		pop hl 
2218			 
2218 7e					ld a, (hl) 
2219			 
2219 6f					ld l, a 
221a 26 00				ld h, 0 
221c cd 6d 19				call forth_push_numhl 
221f			 
221f					NEXTW 
221f c3 5e 1b			jp macro_next 
2222				endm 
# End of macro NEXTW
2222			.CAT: 
2222				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
2222 20				db WORD_SYS_CORE+OPCODE_CAT             
2223 4b 22			dw .BANG            
2225 03				db 2 + 1 
2226 .. 00			db "C@",0              
2229				endm 
# End of macro CWHEAD
2229			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
2229					if DEBUG_FORTH_WORDS_KEY 
2229						DMARK "CAA" 
2229 f5				push af  
222a 3a 3e 22			ld a, (.dmark)  
222d 32 bd fb			ld (debug_mark),a  
2230 3a 3f 22			ld a, (.dmark+1)  
2233 32 be fb			ld (debug_mark+1),a  
2236 3a 40 22			ld a, (.dmark+2)  
2239 32 bf fb			ld (debug_mark+2),a  
223c 18 03			jr .pastdmark  
223e ..			.dmark: db "CAA"  
2241 f1			.pastdmark: pop af  
2242			endm  
# End of macro DMARK
2242						CALLMONITOR 
2242 cd d3 13			call break_point_state  
2245				endm  
# End of macro CALLMONITOR
2245					endif 
2245 c3 12 22				jp .getbyteat 
2248					NEXTW 
2248 c3 5e 1b			jp macro_next 
224b				endm 
# End of macro NEXTW
224b			.BANG: 
224b				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
224b 21				db WORD_SYS_CORE+OPCODE_BANG             
224c 81 22			dw .CBANG            
224e 02				db 1 + 1 
224f .. 00			db "!",0              
2251				endm 
# End of macro CWHEAD
2251			; | ! ( x w -- ) Store x at address w      | DONE 
2251					if DEBUG_FORTH_WORDS_KEY 
2251						DMARK "BNG" 
2251 f5				push af  
2252 3a 66 22			ld a, (.dmark)  
2255 32 bd fb			ld (debug_mark),a  
2258 3a 67 22			ld a, (.dmark+1)  
225b 32 be fb			ld (debug_mark+1),a  
225e 3a 68 22			ld a, (.dmark+2)  
2261 32 bf fb			ld (debug_mark+2),a  
2264 18 03			jr .pastdmark  
2266 ..			.dmark: db "BNG"  
2269 f1			.pastdmark: pop af  
226a			endm  
# End of macro DMARK
226a						CALLMONITOR 
226a cd d3 13			call break_point_state  
226d				endm  
# End of macro CALLMONITOR
226d					endif 
226d			 
226d			.storebyteat:		 
226d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
226d cd 08 1a			call macro_dsp_valuehl 
2270				endm 
# End of macro FORTH_DSP_VALUEHL
2270					 
2270 e5					push hl 
2271				 
2271					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2271 cd a4 1a			call macro_forth_dsp_pop 
2274				endm 
# End of macro FORTH_DSP_POP
2274			 
2274					; get byte to poke 
2274			 
2274					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2274 cd 08 1a			call macro_dsp_valuehl 
2277				endm 
# End of macro FORTH_DSP_VALUEHL
2277 e5					push hl 
2278			 
2278			 
2278					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2278 cd a4 1a			call macro_forth_dsp_pop 
227b				endm 
# End of macro FORTH_DSP_POP
227b			 
227b			 
227b d1					pop de 
227c e1					pop hl 
227d			 
227d 73					ld (hl),e 
227e			 
227e			 
227e					NEXTW 
227e c3 5e 1b			jp macro_next 
2281				endm 
# End of macro NEXTW
2281			.CBANG: 
2281				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
2281 22				db WORD_SYS_CORE+OPCODE_CBANG             
2282 aa 22			dw .SCALL            
2284 03				db 2 + 1 
2285 .. 00			db "C!",0              
2288				endm 
# End of macro CWHEAD
2288			; | C!  ( x w -- ) Store x at address w  | DONE 
2288					if DEBUG_FORTH_WORDS_KEY 
2288						DMARK "CBA" 
2288 f5				push af  
2289 3a 9d 22			ld a, (.dmark)  
228c 32 bd fb			ld (debug_mark),a  
228f 3a 9e 22			ld a, (.dmark+1)  
2292 32 be fb			ld (debug_mark+1),a  
2295 3a 9f 22			ld a, (.dmark+2)  
2298 32 bf fb			ld (debug_mark+2),a  
229b 18 03			jr .pastdmark  
229d ..			.dmark: db "CBA"  
22a0 f1			.pastdmark: pop af  
22a1			endm  
# End of macro DMARK
22a1						CALLMONITOR 
22a1 cd d3 13			call break_point_state  
22a4				endm  
# End of macro CALLMONITOR
22a4					endif 
22a4 c3 6d 22				jp .storebyteat 
22a7					NEXTW 
22a7 c3 5e 1b			jp macro_next 
22aa				endm 
# End of macro NEXTW
22aa			.SCALL: 
22aa				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
22aa 23				db WORD_SYS_CORE+OPCODE_SCALL             
22ab de 22			dw .DEPTH            
22ad 05				db 4 + 1 
22ae .. 00			db "CALL",0              
22b3				endm 
# End of macro CWHEAD
22b3			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
22b3					if DEBUG_FORTH_WORDS_KEY 
22b3						DMARK "CLL" 
22b3 f5				push af  
22b4 3a c8 22			ld a, (.dmark)  
22b7 32 bd fb			ld (debug_mark),a  
22ba 3a c9 22			ld a, (.dmark+1)  
22bd 32 be fb			ld (debug_mark+1),a  
22c0 3a ca 22			ld a, (.dmark+2)  
22c3 32 bf fb			ld (debug_mark+2),a  
22c6 18 03			jr .pastdmark  
22c8 ..			.dmark: db "CLL"  
22cb f1			.pastdmark: pop af  
22cc			endm  
# End of macro DMARK
22cc						CALLMONITOR 
22cc cd d3 13			call break_point_state  
22cf				endm  
# End of macro CALLMONITOR
22cf					endif 
22cf			 
22cf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
22cf cd 08 1a			call macro_dsp_valuehl 
22d2				endm 
# End of macro FORTH_DSP_VALUEHL
22d2			 
22d2			;		push hl 
22d2			 
22d2					; destroy value TOS 
22d2			 
22d2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
22d2 cd a4 1a			call macro_forth_dsp_pop 
22d5				endm 
# End of macro FORTH_DSP_POP
22d5			 
22d5						 
22d5			;		pop hl 
22d5			 
22d5					; how to do a call with hl???? save SP? 
22d5 cd 07 1b				call forth_call_hl 
22d8			 
22d8			 
22d8					; TODO push value back onto stack for another op etc 
22d8			 
22d8 cd 6d 19				call forth_push_numhl 
22db					NEXTW 
22db c3 5e 1b			jp macro_next 
22de				endm 
# End of macro NEXTW
22de			.DEPTH: 
22de				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
22de 24				db WORD_SYS_CORE+OPCODE_DEPTH             
22df 1b 23			dw .OVER            
22e1 06				db 5 + 1 
22e2 .. 00			db "DEPTH",0              
22e8				endm 
# End of macro CWHEAD
22e8			; | DEPTH ( -- u ) Push count of stack | DONE 
22e8					; take current TOS and remove from base value div by two to get count 
22e8					if DEBUG_FORTH_WORDS_KEY 
22e8						DMARK "DEP" 
22e8 f5				push af  
22e9 3a fd 22			ld a, (.dmark)  
22ec 32 bd fb			ld (debug_mark),a  
22ef 3a fe 22			ld a, (.dmark+1)  
22f2 32 be fb			ld (debug_mark+1),a  
22f5 3a ff 22			ld a, (.dmark+2)  
22f8 32 bf fb			ld (debug_mark+2),a  
22fb 18 03			jr .pastdmark  
22fd ..			.dmark: db "DEP"  
2300 f1			.pastdmark: pop af  
2301			endm  
# End of macro DMARK
2301						CALLMONITOR 
2301 cd d3 13			call break_point_state  
2304				endm  
# End of macro CALLMONITOR
2304					endif 
2304			 
2304			 
2304 2a a5 f9			ld hl, (cli_data_sp) 
2307 11 1f f5			ld de, cli_data_stack 
230a ed 52			sbc hl,de 
230c				 
230c				; div by size of stack item 
230c			 
230c 5d				ld e,l 
230d 0e 03			ld c, 3 
230f cd 9f 0b			call Div8 
2312			 
2312 6f				ld l,a 
2313 26 00			ld h,0 
2315			 
2315				;srl h 
2315				;rr l 
2315			 
2315 cd 6d 19				call forth_push_numhl 
2318					NEXTW 
2318 c3 5e 1b			jp macro_next 
231b				endm 
# End of macro NEXTW
231b			.OVER: 
231b				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
231b 42				db WORD_SYS_CORE+46             
231c 62 23			dw .PAUSE            
231e 05				db 4 + 1 
231f .. 00			db "OVER",0              
2324				endm 
# End of macro CWHEAD
2324			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
2324					if DEBUG_FORTH_WORDS_KEY 
2324						DMARK "OVR" 
2324 f5				push af  
2325 3a 39 23			ld a, (.dmark)  
2328 32 bd fb			ld (debug_mark),a  
232b 3a 3a 23			ld a, (.dmark+1)  
232e 32 be fb			ld (debug_mark+1),a  
2331 3a 3b 23			ld a, (.dmark+2)  
2334 32 bf fb			ld (debug_mark+2),a  
2337 18 03			jr .pastdmark  
2339 ..			.dmark: db "OVR"  
233c f1			.pastdmark: pop af  
233d			endm  
# End of macro DMARK
233d						CALLMONITOR 
233d cd d3 13			call break_point_state  
2340				endm  
# End of macro CALLMONITOR
2340					endif 
2340			 
2340					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2340 cd 08 1a			call macro_dsp_valuehl 
2343				endm 
# End of macro FORTH_DSP_VALUEHL
2343 e5					push hl    ; n2 
2344					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2344 cd a4 1a			call macro_forth_dsp_pop 
2347				endm 
# End of macro FORTH_DSP_POP
2347			 
2347					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2347 cd 08 1a			call macro_dsp_valuehl 
234a				endm 
# End of macro FORTH_DSP_VALUEHL
234a e5					push hl    ; n1 
234b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
234b cd a4 1a			call macro_forth_dsp_pop 
234e				endm 
# End of macro FORTH_DSP_POP
234e			 
234e d1					pop de     ; n1 
234f e1					pop hl     ; n2 
2350			 
2350 d5					push de 
2351 e5					push hl 
2352 d5					push de 
2353			 
2353					; push back  
2353			 
2353 e1					pop hl 
2354 cd 6d 19				call forth_push_numhl 
2357 e1					pop hl 
2358 cd 6d 19				call forth_push_numhl 
235b e1					pop hl 
235c cd 6d 19				call forth_push_numhl 
235f					NEXTW 
235f c3 5e 1b			jp macro_next 
2362				endm 
# End of macro NEXTW
2362			 
2362			.PAUSE: 
2362				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2362 43				db WORD_SYS_CORE+47             
2363 97 23			dw .PAUSES            
2365 08				db 7 + 1 
2366 .. 00			db "PAUSEMS",0              
236e				endm 
# End of macro CWHEAD
236e			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
236e					if DEBUG_FORTH_WORDS_KEY 
236e						DMARK "PMS" 
236e f5				push af  
236f 3a 83 23			ld a, (.dmark)  
2372 32 bd fb			ld (debug_mark),a  
2375 3a 84 23			ld a, (.dmark+1)  
2378 32 be fb			ld (debug_mark+1),a  
237b 3a 85 23			ld a, (.dmark+2)  
237e 32 bf fb			ld (debug_mark+2),a  
2381 18 03			jr .pastdmark  
2383 ..			.dmark: db "PMS"  
2386 f1			.pastdmark: pop af  
2387			endm  
# End of macro DMARK
2387						CALLMONITOR 
2387 cd d3 13			call break_point_state  
238a				endm  
# End of macro CALLMONITOR
238a					endif 
238a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
238a cd 08 1a			call macro_dsp_valuehl 
238d				endm 
# End of macro FORTH_DSP_VALUEHL
238d			;		push hl    ; n2 
238d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
238d cd a4 1a			call macro_forth_dsp_pop 
2390				endm 
# End of macro FORTH_DSP_POP
2390			;		pop hl 
2390			 
2390 7d					ld a, l 
2391 cd 1f 0a				call aDelayInMS 
2394				       NEXTW 
2394 c3 5e 1b			jp macro_next 
2397				endm 
# End of macro NEXTW
2397			.PAUSES:  
2397				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
2397 44				db WORD_SYS_CORE+48             
2398 06 24			dw .ROT            
239a 06				db 5 + 1 
239b .. 00			db "PAUSE",0              
23a1				endm 
# End of macro CWHEAD
23a1			; | PAUSE ( n -- )  Pause for n seconds | DONE 
23a1					if DEBUG_FORTH_WORDS_KEY 
23a1						DMARK "PAU" 
23a1 f5				push af  
23a2 3a b6 23			ld a, (.dmark)  
23a5 32 bd fb			ld (debug_mark),a  
23a8 3a b7 23			ld a, (.dmark+1)  
23ab 32 be fb			ld (debug_mark+1),a  
23ae 3a b8 23			ld a, (.dmark+2)  
23b1 32 bf fb			ld (debug_mark+2),a  
23b4 18 03			jr .pastdmark  
23b6 ..			.dmark: db "PAU"  
23b9 f1			.pastdmark: pop af  
23ba			endm  
# End of macro DMARK
23ba						CALLMONITOR 
23ba cd d3 13			call break_point_state  
23bd				endm  
# End of macro CALLMONITOR
23bd					endif 
23bd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
23bd cd 08 1a			call macro_dsp_valuehl 
23c0				endm 
# End of macro FORTH_DSP_VALUEHL
23c0			;		push hl    ; n2 
23c0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
23c0 cd a4 1a			call macro_forth_dsp_pop 
23c3				endm 
# End of macro FORTH_DSP_POP
23c3			;		pop hl 
23c3 45					ld b, l 
23c4					if DEBUG_FORTH_WORDS 
23c4						DMARK "PAU" 
23c4 f5				push af  
23c5 3a d9 23			ld a, (.dmark)  
23c8 32 bd fb			ld (debug_mark),a  
23cb 3a da 23			ld a, (.dmark+1)  
23ce 32 be fb			ld (debug_mark+1),a  
23d1 3a db 23			ld a, (.dmark+2)  
23d4 32 bf fb			ld (debug_mark+2),a  
23d7 18 03			jr .pastdmark  
23d9 ..			.dmark: db "PAU"  
23dc f1			.pastdmark: pop af  
23dd			endm  
# End of macro DMARK
23dd						CALLMONITOR 
23dd cd d3 13			call break_point_state  
23e0				endm  
# End of macro CALLMONITOR
23e0					endif 
23e0 c5			.pauses1:	push bc 
23e1 cd 3a 0a				call delay1s 
23e4 c1					pop bc 
23e5					if DEBUG_FORTH_WORDS 
23e5						DMARK "PA1" 
23e5 f5				push af  
23e6 3a fa 23			ld a, (.dmark)  
23e9 32 bd fb			ld (debug_mark),a  
23ec 3a fb 23			ld a, (.dmark+1)  
23ef 32 be fb			ld (debug_mark+1),a  
23f2 3a fc 23			ld a, (.dmark+2)  
23f5 32 bf fb			ld (debug_mark+2),a  
23f8 18 03			jr .pastdmark  
23fa ..			.dmark: db "PA1"  
23fd f1			.pastdmark: pop af  
23fe			endm  
# End of macro DMARK
23fe						CALLMONITOR 
23fe cd d3 13			call break_point_state  
2401				endm  
# End of macro CALLMONITOR
2401					endif 
2401 10 dd				djnz .pauses1 
2403			 
2403				       NEXTW 
2403 c3 5e 1b			jp macro_next 
2406				endm 
# End of macro NEXTW
2406			.ROT: 
2406				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2406 45				db WORD_SYS_CORE+49             
2407 54 24			dw .UWORDS            
2409 04				db 3 + 1 
240a .. 00			db "ROT",0              
240e				endm 
# End of macro CWHEAD
240e			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
240e					if DEBUG_FORTH_WORDS_KEY 
240e						DMARK "ROT" 
240e f5				push af  
240f 3a 23 24			ld a, (.dmark)  
2412 32 bd fb			ld (debug_mark),a  
2415 3a 24 24			ld a, (.dmark+1)  
2418 32 be fb			ld (debug_mark+1),a  
241b 3a 25 24			ld a, (.dmark+2)  
241e 32 bf fb			ld (debug_mark+2),a  
2421 18 03			jr .pastdmark  
2423 ..			.dmark: db "ROT"  
2426 f1			.pastdmark: pop af  
2427			endm  
# End of macro DMARK
2427						CALLMONITOR 
2427 cd d3 13			call break_point_state  
242a				endm  
# End of macro CALLMONITOR
242a					endif 
242a			 
242a					FORTH_DSP_VALUEHL 
242a cd 08 1a			call macro_dsp_valuehl 
242d				endm 
# End of macro FORTH_DSP_VALUEHL
242d e5					push hl    ; u3  
242e			 
242e					FORTH_DSP_POP 
242e cd a4 1a			call macro_forth_dsp_pop 
2431				endm 
# End of macro FORTH_DSP_POP
2431			   
2431					FORTH_DSP_VALUEHL 
2431 cd 08 1a			call macro_dsp_valuehl 
2434				endm 
# End of macro FORTH_DSP_VALUEHL
2434 e5					push hl     ; u2 
2435			 
2435					FORTH_DSP_POP 
2435 cd a4 1a			call macro_forth_dsp_pop 
2438				endm 
# End of macro FORTH_DSP_POP
2438			 
2438					FORTH_DSP_VALUEHL 
2438 cd 08 1a			call macro_dsp_valuehl 
243b				endm 
# End of macro FORTH_DSP_VALUEHL
243b e5					push hl     ; u1 
243c			 
243c					FORTH_DSP_POP 
243c cd a4 1a			call macro_forth_dsp_pop 
243f				endm 
# End of macro FORTH_DSP_POP
243f			 
243f c1					pop bc      ; u1 
2440 e1					pop hl      ; u2 
2441 d1					pop de      ; u3 
2442			 
2442			 
2442 c5					push bc 
2443 d5					push de 
2444 e5					push hl 
2445			 
2445			 
2445 e1					pop hl 
2446 cd 6d 19				call forth_push_numhl 
2449			 
2449 e1					pop hl 
244a cd 6d 19				call forth_push_numhl 
244d			 
244d e1					pop hl 
244e cd 6d 19				call forth_push_numhl 
2451					 
2451			 
2451			 
2451			 
2451			 
2451			 
2451				       NEXTW 
2451 c3 5e 1b			jp macro_next 
2454				endm 
# End of macro NEXTW
2454			 
2454			.UWORDS: 
2454				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2454 50				db WORD_SYS_CORE+60             
2455 16 25			dw .BP            
2457 07				db 6 + 1 
2458 .. 00			db "UWORDS",0              
245f				endm 
# End of macro CWHEAD
245f			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
245f			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
245f			; | | Following the count are the individual words. 
245f			; | | 
245f			; | | e.g. UWORDS 
245f			; | | BOX DIRLIST 2 
245f			; | |  
245f			; | | Can be used to save the words to storage via: 
245f			; | | UWORDS $01 DO $01 APPEND LOOP 
245f				if DEBUG_FORTH_WORDS_KEY 
245f					DMARK "UWR" 
245f f5				push af  
2460 3a 74 24			ld a, (.dmark)  
2463 32 bd fb			ld (debug_mark),a  
2466 3a 75 24			ld a, (.dmark+1)  
2469 32 be fb			ld (debug_mark+1),a  
246c 3a 76 24			ld a, (.dmark+2)  
246f 32 bf fb			ld (debug_mark+2),a  
2472 18 03			jr .pastdmark  
2474 ..			.dmark: db "UWR"  
2477 f1			.pastdmark: pop af  
2478			endm  
# End of macro DMARK
2478					CALLMONITOR 
2478 cd d3 13			call break_point_state  
247b				endm  
# End of macro CALLMONITOR
247b				endif 
247b 21 00 80				ld hl, baseram 
247e					;ld hl, baseusermem 
247e 01 00 00				ld bc, 0    ; start a counter 
2481			 
2481				; skip dict stub 
2481			 
2481 cd af 1c				call forth_tok_next 
2484			 
2484			 
2484			; while we have words to look for 
2484			 
2484 7e			.douscan:	ld a, (hl)      
2485				if DEBUG_FORTH_WORDS 
2485					DMARK "UWs" 
2485 f5				push af  
2486 3a 9a 24			ld a, (.dmark)  
2489 32 bd fb			ld (debug_mark),a  
248c 3a 9b 24			ld a, (.dmark+1)  
248f 32 be fb			ld (debug_mark+1),a  
2492 3a 9c 24			ld a, (.dmark+2)  
2495 32 bf fb			ld (debug_mark+2),a  
2498 18 03			jr .pastdmark  
249a ..			.dmark: db "UWs"  
249d f1			.pastdmark: pop af  
249e			endm  
# End of macro DMARK
249e					CALLMONITOR 
249e cd d3 13			call break_point_state  
24a1				endm  
# End of macro CALLMONITOR
24a1				endif 
24a1 fe 00				cp WORD_SYS_END 
24a3 28 4d				jr z, .udone 
24a5 fe 01				cp WORD_SYS_UWORD 
24a7 20 44				jr nz, .nuword 
24a9			 
24a9				if DEBUG_FORTH_WORDS 
24a9					DMARK "UWu" 
24a9 f5				push af  
24aa 3a be 24			ld a, (.dmark)  
24ad 32 bd fb			ld (debug_mark),a  
24b0 3a bf 24			ld a, (.dmark+1)  
24b3 32 be fb			ld (debug_mark+1),a  
24b6 3a c0 24			ld a, (.dmark+2)  
24b9 32 bf fb			ld (debug_mark+2),a  
24bc 18 03			jr .pastdmark  
24be ..			.dmark: db "UWu"  
24c1 f1			.pastdmark: pop af  
24c2			endm  
# End of macro DMARK
24c2					CALLMONITOR 
24c2 cd d3 13			call break_point_state  
24c5				endm  
# End of macro CALLMONITOR
24c5				endif 
24c5					; we have a uword so push its name to the stack 
24c5			 
24c5 e5				   	push hl  ; save so we can move to next dict block 
24c6			 
24c6					; skip opcode 
24c6 23					inc hl  
24c7					; skip next ptr 
24c7 23					inc hl  
24c8 23					inc hl 
24c9					; skip len 
24c9 23					inc hl 
24ca				if DEBUG_FORTH_WORDS 
24ca					DMARK "UWt" 
24ca f5				push af  
24cb 3a df 24			ld a, (.dmark)  
24ce 32 bd fb			ld (debug_mark),a  
24d1 3a e0 24			ld a, (.dmark+1)  
24d4 32 be fb			ld (debug_mark+1),a  
24d7 3a e1 24			ld a, (.dmark+2)  
24da 32 bf fb			ld (debug_mark+2),a  
24dd 18 03			jr .pastdmark  
24df ..			.dmark: db "UWt"  
24e2 f1			.pastdmark: pop af  
24e3			endm  
# End of macro DMARK
24e3					CALLMONITOR 
24e3 cd d3 13			call break_point_state  
24e6				endm  
# End of macro CALLMONITOR
24e6				endif 
24e6 03					inc bc 
24e7			 
24e7 c5					push bc 
24e8 cd 7f 19				call forth_push_str 
24eb c1					pop bc 
24ec			 
24ec e1					pop hl 	 
24ed			 
24ed cd af 1c		.nuword:	call forth_tok_next 
24f0 18 92				jr .douscan  
24f2			 
24f2			.udone:		 ; push count of uwords found 
24f2 c5					push bc 
24f3 e1					pop hl 
24f4			 
24f4				if DEBUG_FORTH_WORDS 
24f4					DMARK "UWc" 
24f4 f5				push af  
24f5 3a 09 25			ld a, (.dmark)  
24f8 32 bd fb			ld (debug_mark),a  
24fb 3a 0a 25			ld a, (.dmark+1)  
24fe 32 be fb			ld (debug_mark+1),a  
2501 3a 0b 25			ld a, (.dmark+2)  
2504 32 bf fb			ld (debug_mark+2),a  
2507 18 03			jr .pastdmark  
2509 ..			.dmark: db "UWc"  
250c f1			.pastdmark: pop af  
250d			endm  
# End of macro DMARK
250d					CALLMONITOR 
250d cd d3 13			call break_point_state  
2510				endm  
# End of macro CALLMONITOR
2510				endif 
2510 cd 6d 19				call forth_push_numhl 
2513			 
2513			 
2513				       NEXTW 
2513 c3 5e 1b			jp macro_next 
2516				endm 
# End of macro NEXTW
2516			 
2516			.BP: 
2516				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2516 54				db WORD_SYS_CORE+64             
2517 4c 25			dw .MONITOR            
2519 03				db 2 + 1 
251a .. 00			db "BP",0              
251d				endm 
# End of macro CWHEAD
251d			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
251d			; | | $00 Will enable the break points within specific code paths 
251d			; | | $01 Will disable break points 
251d			; | |  
251d			; | | By default break points are off. Either the above can be used to enable them 
251d			; | | or if a key is held down during start up the spashscreen will appear to freeze 
251d			; | | and on release of the pressed key a message will be disaplayed to notify 
251d			; | | that break points are enabled. Pressing any key will then continue boot process. 
251d					; get byte count 
251d					if DEBUG_FORTH_WORDS_KEY 
251d						DMARK "BP." 
251d f5				push af  
251e 3a 32 25			ld a, (.dmark)  
2521 32 bd fb			ld (debug_mark),a  
2524 3a 33 25			ld a, (.dmark+1)  
2527 32 be fb			ld (debug_mark+1),a  
252a 3a 34 25			ld a, (.dmark+2)  
252d 32 bf fb			ld (debug_mark+2),a  
2530 18 03			jr .pastdmark  
2532 ..			.dmark: db "BP."  
2535 f1			.pastdmark: pop af  
2536			endm  
# End of macro DMARK
2536						CALLMONITOR 
2536 cd d3 13			call break_point_state  
2539				endm  
# End of macro CALLMONITOR
2539					endif 
2539			 
2539					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2539 cd 08 1a			call macro_dsp_valuehl 
253c				endm 
# End of macro FORTH_DSP_VALUEHL
253c			 
253c			;		push hl 
253c			 
253c					; destroy value TOS 
253c			 
253c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
253c cd a4 1a			call macro_forth_dsp_pop 
253f				endm 
# End of macro FORTH_DSP_POP
253f			 
253f			;		pop hl 
253f			 
253f 3e 00				ld a,0 
2541 bd					cp l 
2542 28 02				jr z, .bpset 
2544 3e 2a				ld a, '*' 
2546			 
2546 32 b7 ef		.bpset:		ld (os_view_disable), a 
2549			 
2549			 
2549					NEXTW 
2549 c3 5e 1b			jp macro_next 
254c				endm 
# End of macro NEXTW
254c			 
254c			 
254c			.MONITOR: 
254c				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
254c 55				db WORD_SYS_CORE+65             
254d 7f 25			dw .MALLOC            
254f 08				db 7 + 1 
2550 .. 00			db "MONITOR",0              
2558				endm 
# End of macro CWHEAD
2558			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2558			; | | At start the current various registers will be displayed with contents. 
2558			; | | Top right corner will show the most recent debug marker seen. 
2558			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2558			; | | and the return stack pointer (RSP). 
2558			; | | Pressing: 
2558			; | |    1 - Initial screen 
2558			; | |    2 - Display a data dump of HL 
2558			; | |    3 - Display a data dump of DE 
2558			; | |    4 - Display a data dump of BC 
2558			; | |    5 - Display a data dump of HL 
2558			; | |    6 - Display a data dump of DSP 
2558			; | |    7 - Display a data dump of RSP 
2558			; | |    8 - Display a data dump of what is at DSP 
2558			; | |    9 - Display a data dump of what is at RSP 
2558			; | |    0 - Exit monitor and continue running. This will also enable break points 
2558			; | |    * - Disable break points 
2558			; | |    # - Enter traditional monitor mode 
2558			; | | 
2558			; | | Monitor Mode 
2558			; | | ------------ 
2558			; | | A prompt of '>' will be shown for various commands: 
2558			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2558			; | |    C - Continue display a data dump from the last set address 
2558			; | |    M xxxx - Set start of memory edit at address xx 
2558			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2558			; | |    Q - Return to previous 
2558					if DEBUG_FORTH_WORDS_KEY 
2558						DMARK "MON" 
2558 f5				push af  
2559 3a 6d 25			ld a, (.dmark)  
255c 32 bd fb			ld (debug_mark),a  
255f 3a 6e 25			ld a, (.dmark+1)  
2562 32 be fb			ld (debug_mark+1),a  
2565 3a 6f 25			ld a, (.dmark+2)  
2568 32 bf fb			ld (debug_mark+2),a  
256b 18 03			jr .pastdmark  
256d ..			.dmark: db "MON"  
2570 f1			.pastdmark: pop af  
2571			endm  
# End of macro DMARK
2571						CALLMONITOR 
2571 cd d3 13			call break_point_state  
2574				endm  
# End of macro CALLMONITOR
2574					endif 
2574 3e 00				ld a, 0 
2576 32 b7 ef				ld (os_view_disable), a 
2579			 
2579					CALLMONITOR 
2579 cd d3 13			call break_point_state  
257c				endm  
# End of macro CALLMONITOR
257c			 
257c			;	call monitor 
257c			 
257c					NEXTW 
257c c3 5e 1b			jp macro_next 
257f				endm 
# End of macro NEXTW
257f			 
257f			 
257f			.MALLOC: 
257f				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
257f 56				db WORD_SYS_CORE+66             
2580 a8 25			dw .MALLOC2            
2582 06				db 5 + 1 
2583 .. 00			db "ALLOT",0              
2589				endm 
# End of macro CWHEAD
2589			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2589					if DEBUG_FORTH_WORDS_KEY 
2589						DMARK "ALL" 
2589 f5				push af  
258a 3a 9e 25			ld a, (.dmark)  
258d 32 bd fb			ld (debug_mark),a  
2590 3a 9f 25			ld a, (.dmark+1)  
2593 32 be fb			ld (debug_mark+1),a  
2596 3a a0 25			ld a, (.dmark+2)  
2599 32 bf fb			ld (debug_mark+2),a  
259c 18 03			jr .pastdmark  
259e ..			.dmark: db "ALL"  
25a1 f1			.pastdmark: pop af  
25a2			endm  
# End of macro DMARK
25a2						CALLMONITOR 
25a2 cd d3 13			call break_point_state  
25a5				endm  
# End of macro CALLMONITOR
25a5					endif 
25a5 c3 cf 25				jp .mallocc 
25a8			.MALLOC2: 
25a8				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
25a8 56				db WORD_SYS_CORE+66             
25a9 e6 25			dw .FREE            
25ab 07				db 6 + 1 
25ac .. 00			db "MALLOC",0              
25b3				endm 
# End of macro CWHEAD
25b3			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
25b3					; get byte count 
25b3					if DEBUG_FORTH_WORDS_KEY 
25b3						DMARK "MAL" 
25b3 f5				push af  
25b4 3a c8 25			ld a, (.dmark)  
25b7 32 bd fb			ld (debug_mark),a  
25ba 3a c9 25			ld a, (.dmark+1)  
25bd 32 be fb			ld (debug_mark+1),a  
25c0 3a ca 25			ld a, (.dmark+2)  
25c3 32 bf fb			ld (debug_mark+2),a  
25c6 18 03			jr .pastdmark  
25c8 ..			.dmark: db "MAL"  
25cb f1			.pastdmark: pop af  
25cc			endm  
# End of macro DMARK
25cc						CALLMONITOR 
25cc cd d3 13			call break_point_state  
25cf				endm  
# End of macro CALLMONITOR
25cf					endif 
25cf			.mallocc: 
25cf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25cf cd 08 1a			call macro_dsp_valuehl 
25d2				endm 
# End of macro FORTH_DSP_VALUEHL
25d2			 
25d2			;		push hl 
25d2			 
25d2					; destroy value TOS 
25d2			 
25d2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25d2 cd a4 1a			call macro_forth_dsp_pop 
25d5				endm 
# End of macro FORTH_DSP_POP
25d5			 
25d5			;		pop hl 
25d5 cd d6 10				call malloc 
25d8				if DEBUG_FORTH_MALLOC_GUARD 
25d8 f5					push af 
25d9 cd 38 0c				call ishlzero 
25dc			;		ld a, l 
25dc			;		add h 
25dc			;		cp 0 
25dc f1					pop af 
25dd					 
25dd cc a7 4e				call z,malloc_error 
25e0				endif 
25e0			 
25e0 cd 6d 19				call forth_push_numhl 
25e3					NEXTW 
25e3 c3 5e 1b			jp macro_next 
25e6				endm 
# End of macro NEXTW
25e6			 
25e6			.FREE: 
25e6				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
25e6 57				db WORD_SYS_CORE+67             
25e7 17 26			dw .LIST            
25e9 05				db 4 + 1 
25ea .. 00			db "FREE",0              
25ef				endm 
# End of macro CWHEAD
25ef			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
25ef					if DEBUG_FORTH_WORDS_KEY 
25ef						DMARK "FRE" 
25ef f5				push af  
25f0 3a 04 26			ld a, (.dmark)  
25f3 32 bd fb			ld (debug_mark),a  
25f6 3a 05 26			ld a, (.dmark+1)  
25f9 32 be fb			ld (debug_mark+1),a  
25fc 3a 06 26			ld a, (.dmark+2)  
25ff 32 bf fb			ld (debug_mark+2),a  
2602 18 03			jr .pastdmark  
2604 ..			.dmark: db "FRE"  
2607 f1			.pastdmark: pop af  
2608			endm  
# End of macro DMARK
2608						CALLMONITOR 
2608 cd d3 13			call break_point_state  
260b				endm  
# End of macro CALLMONITOR
260b					endif 
260b					; get address 
260b			 
260b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
260b cd 08 1a			call macro_dsp_valuehl 
260e				endm 
# End of macro FORTH_DSP_VALUEHL
260e			 
260e			;		push hl 
260e			 
260e					; destroy value TOS 
260e			 
260e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
260e cd a4 1a			call macro_forth_dsp_pop 
2611				endm 
# End of macro FORTH_DSP_POP
2611			 
2611			;		pop hl 
2611			if FORTH_ENABLE_MALLOCFREE 
2611 cd a0 11				call free 
2614			endif 
2614					NEXTW 
2614 c3 5e 1b			jp macro_next 
2617				endm 
# End of macro NEXTW
2617			.LIST: 
2617				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2617 5c				db WORD_SYS_CORE+72             
2618 da 27			dw .FORGET            
261a 05				db 4 + 1 
261b .. 00			db "LIST",0              
2620				endm 
# End of macro CWHEAD
2620			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2620			; | | The quoted word must be in upper case. 
2620				if DEBUG_FORTH_WORDS_KEY 
2620					DMARK "LST" 
2620 f5				push af  
2621 3a 35 26			ld a, (.dmark)  
2624 32 bd fb			ld (debug_mark),a  
2627 3a 36 26			ld a, (.dmark+1)  
262a 32 be fb			ld (debug_mark+1),a  
262d 3a 37 26			ld a, (.dmark+2)  
2630 32 bf fb			ld (debug_mark+2),a  
2633 18 03			jr .pastdmark  
2635 ..			.dmark: db "LST"  
2638 f1			.pastdmark: pop af  
2639			endm  
# End of macro DMARK
2639					CALLMONITOR 
2639 cd d3 13			call break_point_state  
263c				endm  
# End of macro CALLMONITOR
263c				endif 
263c			 
263c					FORTH_DSP_VALUEHL 
263c cd 08 1a			call macro_dsp_valuehl 
263f				endm 
# End of macro FORTH_DSP_VALUEHL
263f			 
263f e5					push hl 
2640 c1					pop bc 
2641			 
2641			; Start format of scratch string 
2641			 
2641 21 b8 ef				ld hl, scratch 
2644			 
2644 3e 3a				ld a, ':' 
2646 77					ld (hl),a 
2647 23					inc hl 
2648 3e 20				ld a, ' ' 
264a 77					ld (hl), a 
264b			 
264b					; Get ptr to the word we need to look up 
264b			 
264b			;		FORTH_DSP_VALUEHL 
264b					;v5 FORTH_DSP_VALUE 
264b				; TODO type check 
264b			;		inc hl    ; Skip type check  
264b			;		push hl 
264b			;		ex de, hl    ; put into DE 
264b			 
264b			 
264b 21 00 80				ld hl, baseram 
264e					;ld hl, baseusermem 
264e			 
264e e5			push hl   ; sacreifical push 
264f			 
264f			.ldouscanm: 
264f e1				pop hl 
2650			.ldouscan: 
2650				if DEBUG_FORTH_WORDS 
2650					DMARK "LSs" 
2650 f5				push af  
2651 3a 65 26			ld a, (.dmark)  
2654 32 bd fb			ld (debug_mark),a  
2657 3a 66 26			ld a, (.dmark+1)  
265a 32 be fb			ld (debug_mark+1),a  
265d 3a 67 26			ld a, (.dmark+2)  
2660 32 bf fb			ld (debug_mark+2),a  
2663 18 03			jr .pastdmark  
2665 ..			.dmark: db "LSs"  
2668 f1			.pastdmark: pop af  
2669			endm  
# End of macro DMARK
2669					CALLMONITOR 
2669 cd d3 13			call break_point_state  
266c				endm  
# End of macro CALLMONITOR
266c				endif 
266c				; skip dict stub 
266c cd af 1c				call forth_tok_next 
266f			 
266f			 
266f			; while we have words to look for 
266f			 
266f 7e				ld a, (hl)      
2670				if DEBUG_FORTH_WORDS 
2670					DMARK "LSk" 
2670 f5				push af  
2671 3a 85 26			ld a, (.dmark)  
2674 32 bd fb			ld (debug_mark),a  
2677 3a 86 26			ld a, (.dmark+1)  
267a 32 be fb			ld (debug_mark+1),a  
267d 3a 87 26			ld a, (.dmark+2)  
2680 32 bf fb			ld (debug_mark+2),a  
2683 18 03			jr .pastdmark  
2685 ..			.dmark: db "LSk"  
2688 f1			.pastdmark: pop af  
2689			endm  
# End of macro DMARK
2689					CALLMONITOR 
2689 cd d3 13			call break_point_state  
268c				endm  
# End of macro CALLMONITOR
268c				endif 
268c fe 00				cp WORD_SYS_END 
268e ca c1 27				jp z, .lunotfound 
2691 fe 01				cp WORD_SYS_UWORD 
2693 c2 50 26				jp nz, .ldouscan 
2696			 
2696				if DEBUG_FORTH_WORDS 
2696					DMARK "LSu" 
2696 f5				push af  
2697 3a ab 26			ld a, (.dmark)  
269a 32 bd fb			ld (debug_mark),a  
269d 3a ac 26			ld a, (.dmark+1)  
26a0 32 be fb			ld (debug_mark+1),a  
26a3 3a ad 26			ld a, (.dmark+2)  
26a6 32 bf fb			ld (debug_mark+2),a  
26a9 18 03			jr .pastdmark  
26ab ..			.dmark: db "LSu"  
26ae f1			.pastdmark: pop af  
26af			endm  
# End of macro DMARK
26af					CALLMONITOR 
26af cd d3 13			call break_point_state  
26b2				endm  
# End of macro CALLMONITOR
26b2				endif 
26b2			 
26b2					; found a uword but is it the one we want... 
26b2			 
26b2 c5					push bc     ; uword to find is on bc 
26b3 d1					pop de 
26b4			 
26b4 e5					push hl  ; to save the ptr 
26b5			 
26b5					; skip opcode 
26b5 23					inc hl  
26b6					; skip next ptr 
26b6 23					inc hl  
26b7 23					inc hl 
26b8					; skip len 
26b8 23					inc hl 
26b9			 
26b9				if DEBUG_FORTH_WORDS 
26b9					DMARK "LSc" 
26b9 f5				push af  
26ba 3a ce 26			ld a, (.dmark)  
26bd 32 bd fb			ld (debug_mark),a  
26c0 3a cf 26			ld a, (.dmark+1)  
26c3 32 be fb			ld (debug_mark+1),a  
26c6 3a d0 26			ld a, (.dmark+2)  
26c9 32 bf fb			ld (debug_mark+2),a  
26cc 18 03			jr .pastdmark  
26ce ..			.dmark: db "LSc"  
26d1 f1			.pastdmark: pop af  
26d2			endm  
# End of macro DMARK
26d2					CALLMONITOR 
26d2 cd d3 13			call break_point_state  
26d5				endm  
# End of macro CALLMONITOR
26d5				endif 
26d5 cd a5 10				call strcmp 
26d8 c2 4f 26				jp nz, .ldouscanm 
26db				 
26db			 
26db			 
26db					; we have a uword so push its name to the stack 
26db			 
26db			;	   	push hl  ; save so we can move to next dict block 
26db e1			pop hl 
26dc			 
26dc				if DEBUG_FORTH_WORDS 
26dc					DMARK "LSm" 
26dc f5				push af  
26dd 3a f1 26			ld a, (.dmark)  
26e0 32 bd fb			ld (debug_mark),a  
26e3 3a f2 26			ld a, (.dmark+1)  
26e6 32 be fb			ld (debug_mark+1),a  
26e9 3a f3 26			ld a, (.dmark+2)  
26ec 32 bf fb			ld (debug_mark+2),a  
26ef 18 03			jr .pastdmark  
26f1 ..			.dmark: db "LSm"  
26f4 f1			.pastdmark: pop af  
26f5			endm  
# End of macro DMARK
26f5					CALLMONITOR 
26f5 cd d3 13			call break_point_state  
26f8				endm  
# End of macro CALLMONITOR
26f8				endif 
26f8			 
26f8					; skip opcode 
26f8 23					inc hl  
26f9					; skip next ptr 
26f9 23					inc hl  
26fa 23					inc hl 
26fb					; skip len 
26fb 7e					ld a, (hl)   ; save length to add 
26fc				if DEBUG_FORTH_WORDS 
26fc					DMARK "LS2" 
26fc f5				push af  
26fd 3a 11 27			ld a, (.dmark)  
2700 32 bd fb			ld (debug_mark),a  
2703 3a 12 27			ld a, (.dmark+1)  
2706 32 be fb			ld (debug_mark+1),a  
2709 3a 13 27			ld a, (.dmark+2)  
270c 32 bf fb			ld (debug_mark+2),a  
270f 18 03			jr .pastdmark  
2711 ..			.dmark: db "LS2"  
2714 f1			.pastdmark: pop af  
2715			endm  
# End of macro DMARK
2715					CALLMONITOR 
2715 cd d3 13			call break_point_state  
2718				endm  
# End of macro CALLMONITOR
2718				endif 
2718			 
2718					; save this location 
2718				 
2718 e5					push hl 
2719			 
2719 23					inc hl 
271a 11 ba ef				ld de, scratch+2 
271d 4f					ld c, a 
271e 06 00				ld b, 0 
2720			 
2720				if DEBUG_FORTH_WORDS 
2720					DMARK "LSn" 
2720 f5				push af  
2721 3a 35 27			ld a, (.dmark)  
2724 32 bd fb			ld (debug_mark),a  
2727 3a 36 27			ld a, (.dmark+1)  
272a 32 be fb			ld (debug_mark+1),a  
272d 3a 37 27			ld a, (.dmark+2)  
2730 32 bf fb			ld (debug_mark+2),a  
2733 18 03			jr .pastdmark  
2735 ..			.dmark: db "LSn"  
2738 f1			.pastdmark: pop af  
2739			endm  
# End of macro DMARK
2739					CALLMONITOR 
2739 cd d3 13			call break_point_state  
273c				endm  
# End of macro CALLMONITOR
273c				endif 
273c			 
273c					; copy uword name to scratch 
273c			 
273c ed b0				ldir 
273e			 
273e 1b					dec de 
273f 3e 20				ld a, ' '    ; change null to space 
2741 12					ld (de), a 
2742			 
2742 13					inc de 
2743			 
2743 d5					push de 
2744 c1					pop bc     ; move scratch pointer to end of word name and save it 
2745			 
2745 e1					pop hl 
2746 7e					ld a, (hl) 
2747					;inc hl 
2747					; skip word string 
2747 cd 0f 0c				call addatohl 
274a			 
274a 23					inc hl 
274b			 
274b				if DEBUG_FORTH_WORDS 
274b					DMARK "LS3" 
274b f5				push af  
274c 3a 60 27			ld a, (.dmark)  
274f 32 bd fb			ld (debug_mark),a  
2752 3a 61 27			ld a, (.dmark+1)  
2755 32 be fb			ld (debug_mark+1),a  
2758 3a 62 27			ld a, (.dmark+2)  
275b 32 bf fb			ld (debug_mark+2),a  
275e 18 03			jr .pastdmark  
2760 ..			.dmark: db "LS3"  
2763 f1			.pastdmark: pop af  
2764			endm  
# End of macro DMARK
2764					CALLMONITOR 
2764 cd d3 13			call break_point_state  
2767				endm  
# End of macro CALLMONITOR
2767				endif 
2767					; should now be at the start of the machine code to setup the eval of the uword 
2767					; now locate the ptr to the string defintion 
2767			 
2767					; skip ld hl, 
2767					; then load the ptr 
2767			 
2767 23					inc hl 
2768 5e					ld e, (hl) 
2769 23					inc hl 
276a 56					ld d, (hl) 
276b eb					ex de, hl 
276c			 
276c			 
276c				if DEBUG_FORTH_WORDS 
276c					DMARK "LSt" 
276c f5				push af  
276d 3a 81 27			ld a, (.dmark)  
2770 32 bd fb			ld (debug_mark),a  
2773 3a 82 27			ld a, (.dmark+1)  
2776 32 be fb			ld (debug_mark+1),a  
2779 3a 83 27			ld a, (.dmark+2)  
277c 32 bf fb			ld (debug_mark+2),a  
277f 18 03			jr .pastdmark  
2781 ..			.dmark: db "LSt"  
2784 f1			.pastdmark: pop af  
2785			endm  
# End of macro DMARK
2785					CALLMONITOR 
2785 cd d3 13			call break_point_state  
2788				endm  
# End of macro CALLMONITOR
2788				endif 
2788			 
2788			; cant push right now due to tokenised strings  
2788			 
2788			; get the destination of where to copy this definition to. 
2788			 
2788 c5					push bc 
2789 d1					pop de 
278a			 
278a 7e			.listl:         ld a,(hl) 
278b fe 00				cp 0 
278d 28 09				jr z, .lreplsp     ; replace zero with space 
278f fe 7f				cp FORTH_END_BUFFER 
2791 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2793				 
2793					; just copy this char as is then 
2793			 
2793 12					ld (de), a 
2794			 
2794 23			.listnxt:	inc hl 
2795 13					inc de 
2796 18 f2				jr .listl 
2798			 
2798 3e 20		.lreplsp:	ld a,' ' 
279a 12					ld (de), a 
279b 18 f7				jr .listnxt 
279d			 
279d			; close up uword def 
279d			 
279d			.listdone: 
279d 3e 00				ld a, 0 
279f 12					ld (de), a 
27a0			 
27a0			; now have def so clean up and push to stack 
27a0			 
27a0 21 b8 ef				ld hl, scratch 
27a3				if DEBUG_FORTH_WORDS 
27a3					DMARK "Ltp" 
27a3 f5				push af  
27a4 3a b8 27			ld a, (.dmark)  
27a7 32 bd fb			ld (debug_mark),a  
27aa 3a b9 27			ld a, (.dmark+1)  
27ad 32 be fb			ld (debug_mark+1),a  
27b0 3a ba 27			ld a, (.dmark+2)  
27b3 32 bf fb			ld (debug_mark+2),a  
27b6 18 03			jr .pastdmark  
27b8 ..			.dmark: db "Ltp"  
27bb f1			.pastdmark: pop af  
27bc			endm  
# End of macro DMARK
27bc					CALLMONITOR 
27bc cd d3 13			call break_point_state  
27bf				endm  
# End of macro CALLMONITOR
27bf				endif 
27bf			 
27bf 18 06			jr .listpush 
27c1			 
27c1			;.lnuword:	pop hl 
27c1			;		call forth_tok_next 
27c1			;		jp .ldouscan  
27c1			 
27c1			.lunotfound:		  
27c1			 
27c1			 
27c1					 
27c1					FORTH_DSP_POP 
27c1 cd a4 1a			call macro_forth_dsp_pop 
27c4				endm 
# End of macro FORTH_DSP_POP
27c4 21 cd 27				ld hl, .luno 
27c7						 
27c7			 
27c7			.listpush: 
27c7 cd 7f 19				call forth_push_str 
27ca			 
27ca			 
27ca			 
27ca					NEXTW 
27ca c3 5e 1b			jp macro_next 
27cd				endm 
# End of macro NEXTW
27cd			 
27cd .. 00		.luno:    db "Not found",0 
27d7			 
27d7			 
27d7			 
27d7			 
27d7			 
27d7			;		push hl   ; save pointer to start of uword def string 
27d7			; 
27d7			;; look for FORTH_EOL_LINE 
27d7			;		ld a, FORTH_END_BUFFER 
27d7			;		call strlent 
27d7			; 
27d7			;		inc hl		 ; space for coln def 
27d7			;		inc hl 
27d7			;		inc hl          ; space for terms 
27d7			;		inc hl 
27d7			; 
27d7			;		ld a, 20   ; TODO get actual length 
27d7			;		call addatohl    ; include a random amount of room for the uword name 
27d7			; 
27d7			;		 
27d7			;	if DEBUG_FORTH_WORDS 
27d7			;		DMARK "Lt1" 
27d7			;		CALLMONITOR 
27d7			;	endif 
27d7			;		 
27d7			; 
27d7			;; malloc space for the string because we cant change it 
27d7			; 
27d7			;		call malloc 
27d7			;	if DEBUG_FORTH_MALLOC_GUARD 
27d7			;		push af 
27d7			;		call ishlzero 
27d7			;		pop af 
27d7			;		 
27d7			;		call z,malloc_error 
27d7			;	endif 
27d7			; 
27d7			;	if DEBUG_FORTH_WORDS 
27d7			;		DMARK "Lt2" 
27d7			;		CALLMONITOR 
27d7			;	endif 
27d7			;		pop de 
27d7			;		push hl    ; push the malloc to release later 
27d7			;		push hl   ;  push back a copy for the later stack push 
27d7			;		 
27d7			;; copy the string swapping out the zero terms for spaces 
27d7			; 
27d7			;		; de has our source 
27d7			;		; hl has our dest 
27d7			; 
27d7			;; add the coln def 
27d7			; 
27d7			;		ld a, ':' 
27d7			;		ld (hl), a 
27d7			;		inc hl 
27d7			;		ld a, ' ' 
27d7			;		ld (hl), a 
27d7			;		inc hl 
27d7			; 
27d7			;; add the uname word 
27d7			;		push de   ; save our string for now 
27d7			;		ex de, hl 
27d7			; 
27d7			;		FORTH_DSP_VALUE 
27d7			;		;v5 FORTH_DSP_VALUE 
27d7			; 
27d7			;		inc hl   ; skip type but we know by now this is OK 
27d7			; 
27d7			;.luword:	ld a,(hl) 
27d7			;		cp 0 
27d7			;		jr z, .luword2 
27d7			;		ld (de), a 
27d7			;		inc de 
27d7			;		inc hl 
27d7			;		jr .luword 
27d7			; 
27d7			;.luword2:	ld a, ' ' 
27d7			;		ld (de), a 
27d7			;;		inc hl 
27d7			;;		inc de 
27d7			;;		ld (de), a 
27d7			;;		inc hl 
27d7			;		inc de 
27d7			; 
27d7			;		ex de, hl 
27d7			;		pop de 
27d7			;		 
27d7			;		 
27d7			; 
27d7			;; detoken that string and copy it 
27d7			; 
27d7			;	if DEBUG_FORTH_WORDS 
27d7			;		DMARK "Lt2" 
27d7			;		CALLMONITOR 
27d7			;	endif 
27d7			;.ldetok:	ld a, (de) 
27d7			;		cp FORTH_END_BUFFER 
27d7			;		jr z, .ldetokend 
27d7			;		; swap out any zero term for space 
27d7			;		cp 0 
27d7			;		jr nz, .ldetoknext 
27d7			;		ld a, ' ' 
27d7			; 
27d7			;	if DEBUG_FORTH_WORDS 
27d7			;		DMARK "LtS" 
27d7			;		CALLMONITOR 
27d7			;	endif 
27d7			;.ldetoknext:	ld (hl), a 
27d7			;		inc de 
27d7			;		inc hl 
27d7			;		jr .ldetok 
27d7			; 
27d7			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
27d7			;		ld (hl), a  
27d7			; 
27d7			;; free that temp malloc 
27d7			; 
27d7			;		pop hl    
27d7			; 
27d7			;	if DEBUG_FORTH_WORDS 
27d7			;		DMARK "Lt4" 
27d7			;		CALLMONITOR 
27d7			;	endif 
27d7			;		call forth_apushstrhl 
27d7			; 
27d7			;		; get rid of temp malloc area 
27d7			; 
27d7			;		pop hl 
27d7			;		call free 
27d7			; 
27d7			;		jr .ludone 
27d7			; 
27d7			;.lnuword:	pop hl 
27d7			;		call forth_tok_next 
27d7			;		jp .ldouscan  
27d7			; 
27d7			;.ludone:		 pop hl 
27d7			; 
27d7					NEXTW 
27d7 c3 5e 1b			jp macro_next 
27da				endm 
# End of macro NEXTW
27da			 
27da			.FORGET: 
27da				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
27da 5d				db WORD_SYS_CORE+73             
27db 53 28			dw .NOP            
27dd 07				db 6 + 1 
27de .. 00			db "FORGET",0              
27e5				endm 
# End of macro CWHEAD
27e5			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
27e5			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
27e5			; | |  
27e5			; | | e.g. "MORE" forget 
27e5					if DEBUG_FORTH_WORDS_KEY 
27e5						DMARK "FRG" 
27e5 f5				push af  
27e6 3a fa 27			ld a, (.dmark)  
27e9 32 bd fb			ld (debug_mark),a  
27ec 3a fb 27			ld a, (.dmark+1)  
27ef 32 be fb			ld (debug_mark+1),a  
27f2 3a fc 27			ld a, (.dmark+2)  
27f5 32 bf fb			ld (debug_mark+2),a  
27f8 18 03			jr .pastdmark  
27fa ..			.dmark: db "FRG"  
27fd f1			.pastdmark: pop af  
27fe			endm  
# End of macro DMARK
27fe						CALLMONITOR 
27fe cd d3 13			call break_point_state  
2801				endm  
# End of macro CALLMONITOR
2801					endif 
2801			 
2801				; find uword 
2801			        ; update start of word with "_" 
2801				; replace uword with deleted flag 
2801			 
2801			 
2801			;	if DEBUG_FORTH_WORDS 
2801			;		DMARK "FOG" 
2801			;		CALLMONITOR 
2801			;	endif 
2801			 
2801			 
2801					; Get ptr to the word we need to look up 
2801			 
2801					FORTH_DSP_VALUEHL 
2801 cd 08 1a			call macro_dsp_valuehl 
2804				endm 
# End of macro FORTH_DSP_VALUEHL
2804					;v5 FORTH_DSP_VALUE 
2804				; TODO type check 
2804			;		inc hl    ; Skip type check  
2804 e5					push hl 
2805 c1					pop bc 
2806			;		ex de, hl    ; put into DE 
2806			 
2806			 
2806 21 00 80				ld hl, baseram 
2809					;ld hl, baseusermem 
2809			 
2809				; skip dict stub 
2809			;	call forth_tok_next 
2809 e5			push hl   ; sacreifical push 
280a			 
280a			.fldouscanm: 
280a e1				pop hl 
280b			.fldouscan: 
280b			;	if DEBUG_FORTH_WORDS 
280b			;		DMARK "LSs" 
280b			;		CALLMONITOR 
280b			;	endif 
280b				; skip dict stub 
280b cd af 1c				call forth_tok_next 
280e			 
280e			 
280e			; while we have words to look for 
280e			 
280e 7e				ld a, (hl)      
280f			;	if DEBUG_FORTH_WORDS 
280f			;		DMARK "LSk" 
280f			;		CALLMONITOR 
280f			;	endif 
280f fe 00				cp WORD_SYS_END 
2811 ca 4d 28				jp z, .flunotfound 
2814 fe 01				cp WORD_SYS_UWORD 
2816 c2 0b 28				jp nz, .fldouscan 
2819			 
2819			;	if DEBUG_FORTH_WORDS 
2819			;		DMARK "LSu" 
2819			;		CALLMONITOR 
2819			;	endif 
2819			 
2819					; found a uword but is it the one we want... 
2819			 
2819 c5					push bc     ; uword to find is on bc 
281a d1					pop de 
281b			 
281b e5					push hl  ; to save the ptr 
281c			 
281c					; skip opcode 
281c 23					inc hl  
281d					; skip next ptr 
281d 23					inc hl  
281e 23					inc hl 
281f					; skip len 
281f 23					inc hl 
2820			 
2820			;	if DEBUG_FORTH_WORDS 
2820			;		DMARK "LSc" 
2820			;		CALLMONITOR 
2820			;	endif 
2820 cd a5 10				call strcmp 
2823 c2 0a 28				jp nz, .fldouscanm 
2826			; 
2826			; 
2826			;; while we have words to look for 
2826			; 
2826			;.fdouscan:	ld a, (hl)      
2826			;	if DEBUG_FORTH_WORDS 
2826			;		DMARK "LSs" 
2826			;		CALLMONITOR 
2826			;	endif 
2826			;		cp WORD_SYS_END 
2826			;		jp z, .fudone 
2826			;		cp WORD_SYS_UWORD 
2826			;		jp nz, .fnuword 
2826			; 
2826			;	if DEBUG_FORTH_WORDS 
2826			;		DMARK "FGu" 
2826			;		CALLMONITOR 
2826			;	endif 
2826			; 
2826			;		; found a uword but is it the one we want... 
2826			; 
2826			; 
2826			;	        pop de   ; get back the dsp name 
2826			;		push de 
2826			; 
2826			;		push hl  ; to save the ptr 
2826			; 
2826			;		; skip opcode 
2826			;		inc hl  
2826			;		; skip next ptr 
2826			;		inc hl  
2826			;		inc hl 
2826			;		; skip len 
2826			;		inc hl 
2826			; 
2826			;	if DEBUG_FORTH_WORDS 
2826			;		DMARK "FGc" 
2826			;		CALLMONITOR 
2826			;	endif 
2826			;		call strcmp 
2826			;		jp nz, .fnuword 
2826			 
2826			 
2826 e1			pop hl 
2827			 
2827				 
2827				if DEBUG_FORTH_WORDS 
2827					DMARK "FGm" 
2827 f5				push af  
2828 3a 3c 28			ld a, (.dmark)  
282b 32 bd fb			ld (debug_mark),a  
282e 3a 3d 28			ld a, (.dmark+1)  
2831 32 be fb			ld (debug_mark+1),a  
2834 3a 3e 28			ld a, (.dmark+2)  
2837 32 bf fb			ld (debug_mark+2),a  
283a 18 03			jr .pastdmark  
283c ..			.dmark: db "FGm"  
283f f1			.pastdmark: pop af  
2840			endm  
# End of macro DMARK
2840					CALLMONITOR 
2840 cd d3 13			call break_point_state  
2843				endm  
# End of macro CALLMONITOR
2843				endif 
2843			 
2843			 
2843			 
2843					; we have a uword so push its name to the stack 
2843			 
2843			;	   	push hl  ; save so we can move to next dict block 
2843			;pop hl 
2843			 
2843					; update opcode to deleted 
2843 3e 03				ld a, WORD_SYS_DELETED 
2845 77					ld (hl), a 
2846			 
2846 23					inc hl  
2847					; skip next ptr 
2847 23					inc hl  
2848 23					inc hl 
2849					; skip len 
2849 23					inc hl 
284a			 
284a					; TODO change parser to skip deleted words but for now mark it out 
284a 3e 5f				ld a, "_" 
284c 77					ld  (hl),a 
284d			 
284d			;		jr .fudone 
284d			; 
284d			;.fnuword:	pop hl 
284d			;		call forth_tok_next 
284d			;		jp .fdouscan  
284d			 
284d			.flunotfound:		  
284d			 
284d			 
284d					 
284d					FORTH_DSP_POP 
284d cd a4 1a			call macro_forth_dsp_pop 
2850				endm 
# End of macro FORTH_DSP_POP
2850			;		ld hl, .luno 
2850			;.fudone:		 pop hl 
2850					NEXTW 
2850 c3 5e 1b			jp macro_next 
2853				endm 
# End of macro NEXTW
2853			.NOP: 
2853				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2853 61				db WORD_SYS_CORE+77             
2854 7a 28			dw .COMO            
2856 04				db 3 + 1 
2857 .. 00			db "NOP",0              
285b				endm 
# End of macro CWHEAD
285b			; | NOP (  --  ) Do nothing | DONE 
285b					if DEBUG_FORTH_WORDS_KEY 
285b						DMARK "NOP" 
285b f5				push af  
285c 3a 70 28			ld a, (.dmark)  
285f 32 bd fb			ld (debug_mark),a  
2862 3a 71 28			ld a, (.dmark+1)  
2865 32 be fb			ld (debug_mark+1),a  
2868 3a 72 28			ld a, (.dmark+2)  
286b 32 bf fb			ld (debug_mark+2),a  
286e 18 03			jr .pastdmark  
2870 ..			.dmark: db "NOP"  
2873 f1			.pastdmark: pop af  
2874			endm  
# End of macro DMARK
2874						CALLMONITOR 
2874 cd d3 13			call break_point_state  
2877				endm  
# End of macro CALLMONITOR
2877					endif 
2877				       NEXTW 
2877 c3 5e 1b			jp macro_next 
287a				endm 
# End of macro NEXTW
287a			.COMO: 
287a				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
287a 6e				db WORD_SYS_CORE+90             
287b cc 28			dw .COMC            
287d 02				db 1 + 1 
287e .. 00			db "(",0              
2880				endm 
# End of macro CWHEAD
2880			; | ( ( -- )  Start of comment | DONE 
2880			 
2880			 
2880 2a b9 f2				ld hl, ( os_tok_ptr) 
2883 11 c7 28			ld de, .closepar 
2886					 
2886					if DEBUG_FORTH_WORDS 
2886						DMARK ").." 
2886 f5				push af  
2887 3a 9b 28			ld a, (.dmark)  
288a 32 bd fb			ld (debug_mark),a  
288d 3a 9c 28			ld a, (.dmark+1)  
2890 32 be fb			ld (debug_mark+1),a  
2893 3a 9d 28			ld a, (.dmark+2)  
2896 32 bf fb			ld (debug_mark+2),a  
2899 18 03			jr .pastdmark  
289b ..			.dmark: db ").."  
289e f1			.pastdmark: pop af  
289f			endm  
# End of macro DMARK
289f						CALLMONITOR 
289f cd d3 13			call break_point_state  
28a2				endm  
# End of macro CALLMONITOR
28a2					endif 
28a2 cd 79 1c			call findnexttok  
28a5			 
28a5					if DEBUG_FORTH_WORDS 
28a5						DMARK "IF5" 
28a5 f5				push af  
28a6 3a ba 28			ld a, (.dmark)  
28a9 32 bd fb			ld (debug_mark),a  
28ac 3a bb 28			ld a, (.dmark+1)  
28af 32 be fb			ld (debug_mark+1),a  
28b2 3a bc 28			ld a, (.dmark+2)  
28b5 32 bf fb			ld (debug_mark+2),a  
28b8 18 03			jr .pastdmark  
28ba ..			.dmark: db "IF5"  
28bd f1			.pastdmark: pop af  
28be			endm  
# End of macro DMARK
28be						CALLMONITOR 
28be cd d3 13			call break_point_state  
28c1				endm  
# End of macro CALLMONITOR
28c1					endif 
28c1				; replace below with ) exec using tok_ptr 
28c1 22 b9 f2			ld (os_tok_ptr), hl 
28c4 c3 ef 1b			jp exec1 
28c7			 
28c7 .. 00			.closepar:   db ")",0 
28c9			 
28c9				       NEXTW 
28c9 c3 5e 1b			jp macro_next 
28cc				endm 
# End of macro NEXTW
28cc			.COMC: 
28cc				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
28cc 6f				db WORD_SYS_CORE+91             
28cd d5 28			dw .SCRATCH            
28cf 02				db 1 + 1 
28d0 .. 00			db ")",0              
28d2				endm 
# End of macro CWHEAD
28d2			; | ) ( -- )  End of comment |  DONE  
28d2				       NEXTW 
28d2 c3 5e 1b			jp macro_next 
28d5				endm 
# End of macro NEXTW
28d5			 
28d5			.SCRATCH: 
28d5				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
28d5 6f				db WORD_SYS_CORE+91             
28d6 10 29			dw .INC            
28d8 08				db 7 + 1 
28d9 .. 00			db "SCRATCH",0              
28e1				endm 
# End of macro CWHEAD
28e1			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
28e1			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
28e1			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
28e1			; | |  
28e1			; | | e.g.    : score $00 scratch ; 
28e1			; | |  
28e1			; | | $00 score ! 
28e1			; | | $01 score +! 
28e1			; | |  
28e1			; | | e.g.   : varword $0a scratch ;  
28e1			; | | 
28e1			; | | $8000 varword ! 
28e1					if DEBUG_FORTH_WORDS_KEY 
28e1						DMARK "SCR" 
28e1 f5				push af  
28e2 3a f6 28			ld a, (.dmark)  
28e5 32 bd fb			ld (debug_mark),a  
28e8 3a f7 28			ld a, (.dmark+1)  
28eb 32 be fb			ld (debug_mark+1),a  
28ee 3a f8 28			ld a, (.dmark+2)  
28f1 32 bf fb			ld (debug_mark+2),a  
28f4 18 03			jr .pastdmark  
28f6 ..			.dmark: db "SCR"  
28f9 f1			.pastdmark: pop af  
28fa			endm  
# End of macro DMARK
28fa						CALLMONITOR 
28fa cd d3 13			call break_point_state  
28fd				endm  
# End of macro CALLMONITOR
28fd					endif 
28fd			 
28fd					FORTH_DSP_VALUEHL 
28fd cd 08 1a			call macro_dsp_valuehl 
2900				endm 
# End of macro FORTH_DSP_VALUEHL
2900				 
2900					FORTH_DSP_POP 
2900 cd a4 1a			call macro_forth_dsp_pop 
2903				endm 
# End of macro FORTH_DSP_POP
2903			 
2903 7d					ld a, l 
2904 21 dd f4				ld hl, os_var_array 
2907 cd 0f 0c				call addatohl 
290a			 
290a cd 6d 19				call forth_push_numhl 
290d			 
290d				       NEXTW 
290d c3 5e 1b			jp macro_next 
2910				endm 
# End of macro NEXTW
2910			 
2910			.INC: 
2910				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2910 6f				db WORD_SYS_CORE+91             
2911 64 29			dw .DEC            
2913 03				db 2 + 1 
2914 .. 00			db "+!",0              
2917				endm 
# End of macro CWHEAD
2917			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2917					if DEBUG_FORTH_WORDS_KEY 
2917						DMARK "+s_" 
2917 f5				push af  
2918 3a 2c 29			ld a, (.dmark)  
291b 32 bd fb			ld (debug_mark),a  
291e 3a 2d 29			ld a, (.dmark+1)  
2921 32 be fb			ld (debug_mark+1),a  
2924 3a 2e 29			ld a, (.dmark+2)  
2927 32 bf fb			ld (debug_mark+2),a  
292a 18 03			jr .pastdmark  
292c ..			.dmark: db "+s_"  
292f f1			.pastdmark: pop af  
2930			endm  
# End of macro DMARK
2930						CALLMONITOR 
2930 cd d3 13			call break_point_state  
2933				endm  
# End of macro CALLMONITOR
2933					endif 
2933			 
2933					FORTH_DSP_VALUEHL 
2933 cd 08 1a			call macro_dsp_valuehl 
2936				endm 
# End of macro FORTH_DSP_VALUEHL
2936			 
2936 e5					push hl   ; save address 
2937			 
2937					FORTH_DSP_POP 
2937 cd a4 1a			call macro_forth_dsp_pop 
293a				endm 
# End of macro FORTH_DSP_POP
293a			 
293a					FORTH_DSP_VALUEHL 
293a cd 08 1a			call macro_dsp_valuehl 
293d				endm 
# End of macro FORTH_DSP_VALUEHL
293d			 
293d					FORTH_DSP_POP 
293d cd a4 1a			call macro_forth_dsp_pop 
2940				endm 
# End of macro FORTH_DSP_POP
2940			 
2940					; hl contains value to add to byte at a 
2940				 
2940 eb					ex de, hl 
2941			 
2941 e1					pop hl 
2942			 
2942					if DEBUG_FORTH_WORDS 
2942						DMARK "INC" 
2942 f5				push af  
2943 3a 57 29			ld a, (.dmark)  
2946 32 bd fb			ld (debug_mark),a  
2949 3a 58 29			ld a, (.dmark+1)  
294c 32 be fb			ld (debug_mark+1),a  
294f 3a 59 29			ld a, (.dmark+2)  
2952 32 bf fb			ld (debug_mark+2),a  
2955 18 03			jr .pastdmark  
2957 ..			.dmark: db "INC"  
295a f1			.pastdmark: pop af  
295b			endm  
# End of macro DMARK
295b						CALLMONITOR 
295b cd d3 13			call break_point_state  
295e				endm  
# End of macro CALLMONITOR
295e					endif 
295e			 
295e 7e					ld a,(hl) 
295f 83					add e 
2960 77					ld (hl),a 
2961			 
2961			 
2961			 
2961				       NEXTW 
2961 c3 5e 1b			jp macro_next 
2964				endm 
# End of macro NEXTW
2964			 
2964			.DEC: 
2964				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2964 6f				db WORD_SYS_CORE+91             
2965 b5 29			dw .INC2            
2967 03				db 2 + 1 
2968 .. 00			db "-!",0              
296b				endm 
# End of macro CWHEAD
296b			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
296b					if DEBUG_FORTH_WORDS_KEY 
296b						DMARK "-s_" 
296b f5				push af  
296c 3a 80 29			ld a, (.dmark)  
296f 32 bd fb			ld (debug_mark),a  
2972 3a 81 29			ld a, (.dmark+1)  
2975 32 be fb			ld (debug_mark+1),a  
2978 3a 82 29			ld a, (.dmark+2)  
297b 32 bf fb			ld (debug_mark+2),a  
297e 18 03			jr .pastdmark  
2980 ..			.dmark: db "-s_"  
2983 f1			.pastdmark: pop af  
2984			endm  
# End of macro DMARK
2984						CALLMONITOR 
2984 cd d3 13			call break_point_state  
2987				endm  
# End of macro CALLMONITOR
2987					endif 
2987			 
2987					FORTH_DSP_VALUEHL 
2987 cd 08 1a			call macro_dsp_valuehl 
298a				endm 
# End of macro FORTH_DSP_VALUEHL
298a			 
298a e5					push hl   ; save address 
298b			 
298b					FORTH_DSP_POP 
298b cd a4 1a			call macro_forth_dsp_pop 
298e				endm 
# End of macro FORTH_DSP_POP
298e			 
298e					FORTH_DSP_VALUEHL 
298e cd 08 1a			call macro_dsp_valuehl 
2991				endm 
# End of macro FORTH_DSP_VALUEHL
2991			 
2991					; hl contains value to add to byte at a 
2991				 
2991 eb					ex de, hl 
2992			 
2992 e1					pop hl 
2993			 
2993					if DEBUG_FORTH_WORDS 
2993						DMARK "DEC" 
2993 f5				push af  
2994 3a a8 29			ld a, (.dmark)  
2997 32 bd fb			ld (debug_mark),a  
299a 3a a9 29			ld a, (.dmark+1)  
299d 32 be fb			ld (debug_mark+1),a  
29a0 3a aa 29			ld a, (.dmark+2)  
29a3 32 bf fb			ld (debug_mark+2),a  
29a6 18 03			jr .pastdmark  
29a8 ..			.dmark: db "DEC"  
29ab f1			.pastdmark: pop af  
29ac			endm  
# End of macro DMARK
29ac						CALLMONITOR 
29ac cd d3 13			call break_point_state  
29af				endm  
# End of macro CALLMONITOR
29af					endif 
29af			 
29af 7e					ld a,(hl) 
29b0 93					sub e 
29b1 77					ld (hl),a 
29b2			 
29b2			 
29b2			 
29b2				       NEXTW 
29b2 c3 5e 1b			jp macro_next 
29b5				endm 
# End of macro NEXTW
29b5			 
29b5			.INC2: 
29b5				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
29b5 6f				db WORD_SYS_CORE+91             
29b6 5f 2a			dw .DEC2            
29b8 04				db 3 + 1 
29b9 .. 00			db "+2!",0              
29bd				endm 
# End of macro CWHEAD
29bd			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
29bd			 
29bd					if DEBUG_FORTH_WORDS_KEY 
29bd						DMARK "+2s" 
29bd f5				push af  
29be 3a d2 29			ld a, (.dmark)  
29c1 32 bd fb			ld (debug_mark),a  
29c4 3a d3 29			ld a, (.dmark+1)  
29c7 32 be fb			ld (debug_mark+1),a  
29ca 3a d4 29			ld a, (.dmark+2)  
29cd 32 bf fb			ld (debug_mark+2),a  
29d0 18 03			jr .pastdmark  
29d2 ..			.dmark: db "+2s"  
29d5 f1			.pastdmark: pop af  
29d6			endm  
# End of macro DMARK
29d6						CALLMONITOR 
29d6 cd d3 13			call break_point_state  
29d9				endm  
# End of macro CALLMONITOR
29d9					endif 
29d9			 
29d9					; Address 
29d9			 
29d9					FORTH_DSP_VALUEHL 
29d9 cd 08 1a			call macro_dsp_valuehl 
29dc				endm 
# End of macro FORTH_DSP_VALUEHL
29dc			 
29dc e5					push hl    ; save address 
29dd			 
29dd					; load content into de 
29dd			 
29dd 5e					ld e,(hl) 
29de 23					inc hl 
29df 56					ld d, (hl) 
29e0			 
29e0					if DEBUG_FORTH_WORDS 
29e0						DMARK "+2a" 
29e0 f5				push af  
29e1 3a f5 29			ld a, (.dmark)  
29e4 32 bd fb			ld (debug_mark),a  
29e7 3a f6 29			ld a, (.dmark+1)  
29ea 32 be fb			ld (debug_mark+1),a  
29ed 3a f7 29			ld a, (.dmark+2)  
29f0 32 bf fb			ld (debug_mark+2),a  
29f3 18 03			jr .pastdmark  
29f5 ..			.dmark: db "+2a"  
29f8 f1			.pastdmark: pop af  
29f9			endm  
# End of macro DMARK
29f9						CALLMONITOR 
29f9 cd d3 13			call break_point_state  
29fc				endm  
# End of macro CALLMONITOR
29fc					endif 
29fc			 
29fc					FORTH_DSP_POP 
29fc cd a4 1a			call macro_forth_dsp_pop 
29ff				endm 
# End of macro FORTH_DSP_POP
29ff			 
29ff					; Get value to add 
29ff			 
29ff					FORTH_DSP_VALUE 
29ff cd f1 19			call macro_forth_dsp_value 
2a02				endm 
# End of macro FORTH_DSP_VALUE
2a02			 
2a02					if DEBUG_FORTH_WORDS 
2a02						DMARK "+2v" 
2a02 f5				push af  
2a03 3a 17 2a			ld a, (.dmark)  
2a06 32 bd fb			ld (debug_mark),a  
2a09 3a 18 2a			ld a, (.dmark+1)  
2a0c 32 be fb			ld (debug_mark+1),a  
2a0f 3a 19 2a			ld a, (.dmark+2)  
2a12 32 bf fb			ld (debug_mark+2),a  
2a15 18 03			jr .pastdmark  
2a17 ..			.dmark: db "+2v"  
2a1a f1			.pastdmark: pop af  
2a1b			endm  
# End of macro DMARK
2a1b						CALLMONITOR 
2a1b cd d3 13			call break_point_state  
2a1e				endm  
# End of macro CALLMONITOR
2a1e					endif 
2a1e			 
2a1e 19					add hl, de 
2a1f			 
2a1f					if DEBUG_FORTH_WORDS 
2a1f						DMARK "+2+" 
2a1f f5				push af  
2a20 3a 34 2a			ld a, (.dmark)  
2a23 32 bd fb			ld (debug_mark),a  
2a26 3a 35 2a			ld a, (.dmark+1)  
2a29 32 be fb			ld (debug_mark+1),a  
2a2c 3a 36 2a			ld a, (.dmark+2)  
2a2f 32 bf fb			ld (debug_mark+2),a  
2a32 18 03			jr .pastdmark  
2a34 ..			.dmark: db "+2+"  
2a37 f1			.pastdmark: pop af  
2a38			endm  
# End of macro DMARK
2a38						CALLMONITOR 
2a38 cd d3 13			call break_point_state  
2a3b				endm  
# End of macro CALLMONITOR
2a3b					endif 
2a3b			 
2a3b					; move result to de 
2a3b			 
2a3b eb					ex de, hl 
2a3c			 
2a3c					; Address 
2a3c			 
2a3c e1					pop hl 
2a3d			 
2a3d					; save it back 
2a3d			 
2a3d 73					ld (hl), e 
2a3e 23					inc hl 
2a3f 72					ld (hl), d 
2a40			 
2a40					if DEBUG_FORTH_WORDS 
2a40						DMARK "+2e" 
2a40 f5				push af  
2a41 3a 55 2a			ld a, (.dmark)  
2a44 32 bd fb			ld (debug_mark),a  
2a47 3a 56 2a			ld a, (.dmark+1)  
2a4a 32 be fb			ld (debug_mark+1),a  
2a4d 3a 57 2a			ld a, (.dmark+2)  
2a50 32 bf fb			ld (debug_mark+2),a  
2a53 18 03			jr .pastdmark  
2a55 ..			.dmark: db "+2e"  
2a58 f1			.pastdmark: pop af  
2a59			endm  
# End of macro DMARK
2a59						CALLMONITOR 
2a59 cd d3 13			call break_point_state  
2a5c				endm  
# End of macro CALLMONITOR
2a5c					endif 
2a5c			 
2a5c			 
2a5c			 
2a5c			 
2a5c			 
2a5c				       NEXTW 
2a5c c3 5e 1b			jp macro_next 
2a5f				endm 
# End of macro NEXTW
2a5f			 
2a5f			.DEC2: 
2a5f				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2a5f 6f				db WORD_SYS_CORE+91             
2a60 0b 2b			dw .GET2            
2a62 04				db 3 + 1 
2a63 .. 00			db "-2!",0              
2a67				endm 
# End of macro CWHEAD
2a67			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2a67			 
2a67			 
2a67					if DEBUG_FORTH_WORDS_KEY 
2a67						DMARK "-2s" 
2a67 f5				push af  
2a68 3a 7c 2a			ld a, (.dmark)  
2a6b 32 bd fb			ld (debug_mark),a  
2a6e 3a 7d 2a			ld a, (.dmark+1)  
2a71 32 be fb			ld (debug_mark+1),a  
2a74 3a 7e 2a			ld a, (.dmark+2)  
2a77 32 bf fb			ld (debug_mark+2),a  
2a7a 18 03			jr .pastdmark  
2a7c ..			.dmark: db "-2s"  
2a7f f1			.pastdmark: pop af  
2a80			endm  
# End of macro DMARK
2a80						CALLMONITOR 
2a80 cd d3 13			call break_point_state  
2a83				endm  
# End of macro CALLMONITOR
2a83					endif 
2a83			 
2a83					; Address 
2a83			 
2a83					FORTH_DSP_VALUEHL 
2a83 cd 08 1a			call macro_dsp_valuehl 
2a86				endm 
# End of macro FORTH_DSP_VALUEHL
2a86			 
2a86 e5					push hl    ; save address 
2a87			 
2a87					; load content into de 
2a87			 
2a87 5e					ld e,(hl) 
2a88 23					inc hl 
2a89 56					ld d, (hl) 
2a8a			 
2a8a					if DEBUG_FORTH_WORDS 
2a8a						DMARK "-2a" 
2a8a f5				push af  
2a8b 3a 9f 2a			ld a, (.dmark)  
2a8e 32 bd fb			ld (debug_mark),a  
2a91 3a a0 2a			ld a, (.dmark+1)  
2a94 32 be fb			ld (debug_mark+1),a  
2a97 3a a1 2a			ld a, (.dmark+2)  
2a9a 32 bf fb			ld (debug_mark+2),a  
2a9d 18 03			jr .pastdmark  
2a9f ..			.dmark: db "-2a"  
2aa2 f1			.pastdmark: pop af  
2aa3			endm  
# End of macro DMARK
2aa3						CALLMONITOR 
2aa3 cd d3 13			call break_point_state  
2aa6				endm  
# End of macro CALLMONITOR
2aa6					endif 
2aa6			 
2aa6					FORTH_DSP_POP 
2aa6 cd a4 1a			call macro_forth_dsp_pop 
2aa9				endm 
# End of macro FORTH_DSP_POP
2aa9			 
2aa9					; Get value to remove 
2aa9			 
2aa9					FORTH_DSP_VALUE 
2aa9 cd f1 19			call macro_forth_dsp_value 
2aac				endm 
# End of macro FORTH_DSP_VALUE
2aac			 
2aac					if DEBUG_FORTH_WORDS 
2aac						DMARK "-2v" 
2aac f5				push af  
2aad 3a c1 2a			ld a, (.dmark)  
2ab0 32 bd fb			ld (debug_mark),a  
2ab3 3a c2 2a			ld a, (.dmark+1)  
2ab6 32 be fb			ld (debug_mark+1),a  
2ab9 3a c3 2a			ld a, (.dmark+2)  
2abc 32 bf fb			ld (debug_mark+2),a  
2abf 18 03			jr .pastdmark  
2ac1 ..			.dmark: db "-2v"  
2ac4 f1			.pastdmark: pop af  
2ac5			endm  
# End of macro DMARK
2ac5						CALLMONITOR 
2ac5 cd d3 13			call break_point_state  
2ac8				endm  
# End of macro CALLMONITOR
2ac8					endif 
2ac8			 
2ac8 eb					ex de, hl 
2ac9 ed 52				sbc hl, de 
2acb			 
2acb					if DEBUG_FORTH_WORDS 
2acb						DMARK "-2d" 
2acb f5				push af  
2acc 3a e0 2a			ld a, (.dmark)  
2acf 32 bd fb			ld (debug_mark),a  
2ad2 3a e1 2a			ld a, (.dmark+1)  
2ad5 32 be fb			ld (debug_mark+1),a  
2ad8 3a e2 2a			ld a, (.dmark+2)  
2adb 32 bf fb			ld (debug_mark+2),a  
2ade 18 03			jr .pastdmark  
2ae0 ..			.dmark: db "-2d"  
2ae3 f1			.pastdmark: pop af  
2ae4			endm  
# End of macro DMARK
2ae4						CALLMONITOR 
2ae4 cd d3 13			call break_point_state  
2ae7				endm  
# End of macro CALLMONITOR
2ae7					endif 
2ae7			 
2ae7					; move result to de 
2ae7			 
2ae7 eb					ex de, hl 
2ae8			 
2ae8					; Address 
2ae8			 
2ae8 e1					pop hl 
2ae9			 
2ae9					; save it back 
2ae9			 
2ae9 73					ld (hl), e 
2aea 23					inc hl 
2aeb 72					ld (hl), d 
2aec			 
2aec					if DEBUG_FORTH_WORDS 
2aec						DMARK "-2e" 
2aec f5				push af  
2aed 3a 01 2b			ld a, (.dmark)  
2af0 32 bd fb			ld (debug_mark),a  
2af3 3a 02 2b			ld a, (.dmark+1)  
2af6 32 be fb			ld (debug_mark+1),a  
2af9 3a 03 2b			ld a, (.dmark+2)  
2afc 32 bf fb			ld (debug_mark+2),a  
2aff 18 03			jr .pastdmark  
2b01 ..			.dmark: db "-2e"  
2b04 f1			.pastdmark: pop af  
2b05			endm  
# End of macro DMARK
2b05						CALLMONITOR 
2b05 cd d3 13			call break_point_state  
2b08				endm  
# End of macro CALLMONITOR
2b08					endif 
2b08			 
2b08			 
2b08			 
2b08			 
2b08			 
2b08				       NEXTW 
2b08 c3 5e 1b			jp macro_next 
2b0b				endm 
# End of macro NEXTW
2b0b			.GET2: 
2b0b				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2b0b 6f				db WORD_SYS_CORE+91             
2b0c 3b 2b			dw .BANG2            
2b0e 03				db 2 + 1 
2b0f .. 00			db "2@",0              
2b12				endm 
# End of macro CWHEAD
2b12			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2b12					if DEBUG_FORTH_WORDS_KEY 
2b12						DMARK "2A_" 
2b12 f5				push af  
2b13 3a 27 2b			ld a, (.dmark)  
2b16 32 bd fb			ld (debug_mark),a  
2b19 3a 28 2b			ld a, (.dmark+1)  
2b1c 32 be fb			ld (debug_mark+1),a  
2b1f 3a 29 2b			ld a, (.dmark+2)  
2b22 32 bf fb			ld (debug_mark+2),a  
2b25 18 03			jr .pastdmark  
2b27 ..			.dmark: db "2A_"  
2b2a f1			.pastdmark: pop af  
2b2b			endm  
# End of macro DMARK
2b2b						CALLMONITOR 
2b2b cd d3 13			call break_point_state  
2b2e				endm  
# End of macro CALLMONITOR
2b2e					endif 
2b2e			 
2b2e					FORTH_DSP_VALUEHL 
2b2e cd 08 1a			call macro_dsp_valuehl 
2b31				endm 
# End of macro FORTH_DSP_VALUEHL
2b31			 
2b31 5e					ld e, (hl) 
2b32 23					inc hl 
2b33 56					ld d, (hl) 
2b34			 
2b34 eb					ex de, hl 
2b35			 
2b35 cd 6d 19				call forth_push_numhl 
2b38			 
2b38				       NEXTW 
2b38 c3 5e 1b			jp macro_next 
2b3b				endm 
# End of macro NEXTW
2b3b			.BANG2: 
2b3b				CWHEAD .ENDCORE 91 "2!" 2 WORD_FLAG_CODE 
2b3b 6f				db WORD_SYS_CORE+91             
2b3c 73 2b			dw .ENDCORE            
2b3e 03				db 2 + 1 
2b3f .. 00			db "2!",0              
2b42				endm 
# End of macro CWHEAD
2b42			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2b42					if DEBUG_FORTH_WORDS_KEY 
2b42						DMARK "2S_" 
2b42 f5				push af  
2b43 3a 57 2b			ld a, (.dmark)  
2b46 32 bd fb			ld (debug_mark),a  
2b49 3a 58 2b			ld a, (.dmark+1)  
2b4c 32 be fb			ld (debug_mark+1),a  
2b4f 3a 59 2b			ld a, (.dmark+2)  
2b52 32 bf fb			ld (debug_mark+2),a  
2b55 18 03			jr .pastdmark  
2b57 ..			.dmark: db "2S_"  
2b5a f1			.pastdmark: pop af  
2b5b			endm  
# End of macro DMARK
2b5b						CALLMONITOR 
2b5b cd d3 13			call break_point_state  
2b5e				endm  
# End of macro CALLMONITOR
2b5e					endif 
2b5e			 
2b5e					FORTH_DSP_VALUEHL 
2b5e cd 08 1a			call macro_dsp_valuehl 
2b61				endm 
# End of macro FORTH_DSP_VALUEHL
2b61			 
2b61 e5					push hl   ; save address 
2b62			 
2b62			 
2b62					FORTH_DSP_POP 
2b62 cd a4 1a			call macro_forth_dsp_pop 
2b65				endm 
# End of macro FORTH_DSP_POP
2b65			 
2b65					 
2b65					FORTH_DSP_VALUEHL 
2b65 cd 08 1a			call macro_dsp_valuehl 
2b68				endm 
# End of macro FORTH_DSP_VALUEHL
2b68			 
2b68					FORTH_DSP_POP 
2b68 cd a4 1a			call macro_forth_dsp_pop 
2b6b				endm 
# End of macro FORTH_DSP_POP
2b6b			 
2b6b eb					ex de, hl    ; value now in de 
2b6c			 
2b6c e1					pop hl 
2b6d			 
2b6d 73					ld (hl), e 
2b6e			 
2b6e 23					inc hl 
2b6f			 
2b6f 72					ld (hl), d 
2b70			 
2b70			 
2b70				       NEXTW 
2b70 c3 5e 1b			jp macro_next 
2b73				endm 
# End of macro NEXTW
2b73			.ENDCORE: 
2b73			 
2b73			; eof 
2b73			 
2b73			 
# End of file forth_words_core.asm
2b73			include "forth_words_flow.asm" 
2b73			 
2b73			; | ## Program Flow Words 
2b73			 
2b73			.IF: 
2b73				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2b73 1e				db WORD_SYS_CORE+10             
2b74 68 2c			dw .THEN            
2b76 03				db 2 + 1 
2b77 .. 00			db "IF",0              
2b7a				endm 
# End of macro CWHEAD
2b7a			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2b7a			; 
2b7a					if DEBUG_FORTH_WORDS_KEY 
2b7a						DMARK "IF." 
2b7a f5				push af  
2b7b 3a 8f 2b			ld a, (.dmark)  
2b7e 32 bd fb			ld (debug_mark),a  
2b81 3a 90 2b			ld a, (.dmark+1)  
2b84 32 be fb			ld (debug_mark+1),a  
2b87 3a 91 2b			ld a, (.dmark+2)  
2b8a 32 bf fb			ld (debug_mark+2),a  
2b8d 18 03			jr .pastdmark  
2b8f ..			.dmark: db "IF."  
2b92 f1			.pastdmark: pop af  
2b93			endm  
# End of macro DMARK
2b93						CALLMONITOR 
2b93 cd d3 13			call break_point_state  
2b96				endm  
# End of macro CALLMONITOR
2b96					endif 
2b96			; eval TOS 
2b96			 
2b96				FORTH_DSP_VALUEHL 
2b96 cd 08 1a			call macro_dsp_valuehl 
2b99				endm 
# End of macro FORTH_DSP_VALUEHL
2b99			 
2b99			;	push hl 
2b99				FORTH_DSP_POP 
2b99 cd a4 1a			call macro_forth_dsp_pop 
2b9c				endm 
# End of macro FORTH_DSP_POP
2b9c			;	pop hl 
2b9c			 
2b9c					if DEBUG_FORTH_WORDS 
2b9c						DMARK "IF1" 
2b9c f5				push af  
2b9d 3a b1 2b			ld a, (.dmark)  
2ba0 32 bd fb			ld (debug_mark),a  
2ba3 3a b2 2b			ld a, (.dmark+1)  
2ba6 32 be fb			ld (debug_mark+1),a  
2ba9 3a b3 2b			ld a, (.dmark+2)  
2bac 32 bf fb			ld (debug_mark+2),a  
2baf 18 03			jr .pastdmark  
2bb1 ..			.dmark: db "IF1"  
2bb4 f1			.pastdmark: pop af  
2bb5			endm  
# End of macro DMARK
2bb5						CALLMONITOR 
2bb5 cd d3 13			call break_point_state  
2bb8				endm  
# End of macro CALLMONITOR
2bb8					endif 
2bb8 b7				or a        ; clear carry flag 
2bb9 11 00 00			ld de, 0 
2bbc eb				ex de,hl 
2bbd ed 52			sbc hl, de 
2bbf c2 49 2c			jp nz, .iftrue 
2bc2			 
2bc2					if DEBUG_FORTH_WORDS 
2bc2						DMARK "IF2" 
2bc2 f5				push af  
2bc3 3a d7 2b			ld a, (.dmark)  
2bc6 32 bd fb			ld (debug_mark),a  
2bc9 3a d8 2b			ld a, (.dmark+1)  
2bcc 32 be fb			ld (debug_mark+1),a  
2bcf 3a d9 2b			ld a, (.dmark+2)  
2bd2 32 bf fb			ld (debug_mark+2),a  
2bd5 18 03			jr .pastdmark  
2bd7 ..			.dmark: db "IF2"  
2bda f1			.pastdmark: pop af  
2bdb			endm  
# End of macro DMARK
2bdb						CALLMONITOR 
2bdb cd d3 13			call break_point_state  
2bde				endm  
# End of macro CALLMONITOR
2bde					endif 
2bde			 
2bde			; if not true then skip to THEN 
2bde			 
2bde				; TODO get tok_ptr 
2bde				; TODO consume toks until we get to THEN 
2bde			 
2bde 2a b9 f2			ld hl, (os_tok_ptr) 
2be1					if DEBUG_FORTH_WORDS 
2be1						DMARK "IF3" 
2be1 f5				push af  
2be2 3a f6 2b			ld a, (.dmark)  
2be5 32 bd fb			ld (debug_mark),a  
2be8 3a f7 2b			ld a, (.dmark+1)  
2beb 32 be fb			ld (debug_mark+1),a  
2bee 3a f8 2b			ld a, (.dmark+2)  
2bf1 32 bf fb			ld (debug_mark+2),a  
2bf4 18 03			jr .pastdmark  
2bf6 ..			.dmark: db "IF3"  
2bf9 f1			.pastdmark: pop af  
2bfa			endm  
# End of macro DMARK
2bfa						CALLMONITOR 
2bfa cd d3 13			call break_point_state  
2bfd				endm  
# End of macro CALLMONITOR
2bfd						 
2bfd					endif 
2bfd 11 44 2c			ld de, .ifthen 
2c00					if DEBUG_FORTH_WORDS 
2c00						DMARK "IF4" 
2c00 f5				push af  
2c01 3a 15 2c			ld a, (.dmark)  
2c04 32 bd fb			ld (debug_mark),a  
2c07 3a 16 2c			ld a, (.dmark+1)  
2c0a 32 be fb			ld (debug_mark+1),a  
2c0d 3a 17 2c			ld a, (.dmark+2)  
2c10 32 bf fb			ld (debug_mark+2),a  
2c13 18 03			jr .pastdmark  
2c15 ..			.dmark: db "IF4"  
2c18 f1			.pastdmark: pop af  
2c19			endm  
# End of macro DMARK
2c19						CALLMONITOR 
2c19 cd d3 13			call break_point_state  
2c1c				endm  
# End of macro CALLMONITOR
2c1c					endif 
2c1c cd 79 1c			call findnexttok  
2c1f			 
2c1f					if DEBUG_FORTH_WORDS 
2c1f						DMARK "IF5" 
2c1f f5				push af  
2c20 3a 34 2c			ld a, (.dmark)  
2c23 32 bd fb			ld (debug_mark),a  
2c26 3a 35 2c			ld a, (.dmark+1)  
2c29 32 be fb			ld (debug_mark+1),a  
2c2c 3a 36 2c			ld a, (.dmark+2)  
2c2f 32 bf fb			ld (debug_mark+2),a  
2c32 18 03			jr .pastdmark  
2c34 ..			.dmark: db "IF5"  
2c37 f1			.pastdmark: pop af  
2c38			endm  
# End of macro DMARK
2c38						CALLMONITOR 
2c38 cd d3 13			call break_point_state  
2c3b				endm  
# End of macro CALLMONITOR
2c3b					endif 
2c3b				; TODO replace below with ; exec using tok_ptr 
2c3b 22 b9 f2			ld (os_tok_ptr), hl 
2c3e c3 ef 1b			jp exec1 
2c41				NEXTW 
2c41 c3 5e 1b			jp macro_next 
2c44				endm 
# End of macro NEXTW
2c44			 
2c44 .. 00		.ifthen:  db "THEN",0 
2c49			 
2c49			.iftrue:		 
2c49				; Exec next words normally 
2c49			 
2c49				; if true then exec following IF as normal 
2c49					if DEBUG_FORTH_WORDS 
2c49						DMARK "IFT" 
2c49 f5				push af  
2c4a 3a 5e 2c			ld a, (.dmark)  
2c4d 32 bd fb			ld (debug_mark),a  
2c50 3a 5f 2c			ld a, (.dmark+1)  
2c53 32 be fb			ld (debug_mark+1),a  
2c56 3a 60 2c			ld a, (.dmark+2)  
2c59 32 bf fb			ld (debug_mark+2),a  
2c5c 18 03			jr .pastdmark  
2c5e ..			.dmark: db "IFT"  
2c61 f1			.pastdmark: pop af  
2c62			endm  
# End of macro DMARK
2c62						CALLMONITOR 
2c62 cd d3 13			call break_point_state  
2c65				endm  
# End of macro CALLMONITOR
2c65					endif 
2c65			 
2c65					NEXTW 
2c65 c3 5e 1b			jp macro_next 
2c68				endm 
# End of macro NEXTW
2c68			.THEN: 
2c68				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
2c68 1f				db WORD_SYS_CORE+11             
2c69 90 2c			dw .ELSE            
2c6b 05				db 4 + 1 
2c6c .. 00			db "THEN",0              
2c71				endm 
# End of macro CWHEAD
2c71			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
2c71					if DEBUG_FORTH_WORDS_KEY 
2c71						DMARK "THN" 
2c71 f5				push af  
2c72 3a 86 2c			ld a, (.dmark)  
2c75 32 bd fb			ld (debug_mark),a  
2c78 3a 87 2c			ld a, (.dmark+1)  
2c7b 32 be fb			ld (debug_mark+1),a  
2c7e 3a 88 2c			ld a, (.dmark+2)  
2c81 32 bf fb			ld (debug_mark+2),a  
2c84 18 03			jr .pastdmark  
2c86 ..			.dmark: db "THN"  
2c89 f1			.pastdmark: pop af  
2c8a			endm  
# End of macro DMARK
2c8a						CALLMONITOR 
2c8a cd d3 13			call break_point_state  
2c8d				endm  
# End of macro CALLMONITOR
2c8d					endif 
2c8d					NEXTW 
2c8d c3 5e 1b			jp macro_next 
2c90				endm 
# End of macro NEXTW
2c90			.ELSE: 
2c90				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
2c90 20				db WORD_SYS_CORE+12             
2c91 b8 2c			dw .DO            
2c93 03				db 2 + 1 
2c94 .. 00			db "ELSE",0              
2c99				endm 
# End of macro CWHEAD
2c99			; | ELSE ( -- ) Not supported - does nothing | TODO 
2c99			 
2c99					if DEBUG_FORTH_WORDS_KEY 
2c99						DMARK "ELS" 
2c99 f5				push af  
2c9a 3a ae 2c			ld a, (.dmark)  
2c9d 32 bd fb			ld (debug_mark),a  
2ca0 3a af 2c			ld a, (.dmark+1)  
2ca3 32 be fb			ld (debug_mark+1),a  
2ca6 3a b0 2c			ld a, (.dmark+2)  
2ca9 32 bf fb			ld (debug_mark+2),a  
2cac 18 03			jr .pastdmark  
2cae ..			.dmark: db "ELS"  
2cb1 f1			.pastdmark: pop af  
2cb2			endm  
# End of macro DMARK
2cb2						CALLMONITOR 
2cb2 cd d3 13			call break_point_state  
2cb5				endm  
# End of macro CALLMONITOR
2cb5					endif 
2cb5			 
2cb5			 
2cb5					NEXTW 
2cb5 c3 5e 1b			jp macro_next 
2cb8				endm 
# End of macro NEXTW
2cb8			.DO: 
2cb8				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
2cb8 21				db WORD_SYS_CORE+13             
2cb9 df 2d			dw .LOOP            
2cbb 03				db 2 + 1 
2cbc .. 00			db "DO",0              
2cbf				endm 
# End of macro CWHEAD
2cbf			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
2cbf			 
2cbf					if DEBUG_FORTH_WORDS_KEY 
2cbf						DMARK "DO." 
2cbf f5				push af  
2cc0 3a d4 2c			ld a, (.dmark)  
2cc3 32 bd fb			ld (debug_mark),a  
2cc6 3a d5 2c			ld a, (.dmark+1)  
2cc9 32 be fb			ld (debug_mark+1),a  
2ccc 3a d6 2c			ld a, (.dmark+2)  
2ccf 32 bf fb			ld (debug_mark+2),a  
2cd2 18 03			jr .pastdmark  
2cd4 ..			.dmark: db "DO."  
2cd7 f1			.pastdmark: pop af  
2cd8			endm  
# End of macro DMARK
2cd8						CALLMONITOR 
2cd8 cd d3 13			call break_point_state  
2cdb				endm  
# End of macro CALLMONITOR
2cdb					endif 
2cdb			;  push pc to rsp stack past the DO 
2cdb			 
2cdb 2a b9 f2				ld hl, (os_tok_ptr) 
2cde 23					inc hl   ; D 
2cdf 23					inc hl  ; O 
2ce0 23					inc hl   ; null 
2ce1					if DEBUG_FORTH_WORDS 
2ce1						DMARK "DO2" 
2ce1 f5				push af  
2ce2 3a f6 2c			ld a, (.dmark)  
2ce5 32 bd fb			ld (debug_mark),a  
2ce8 3a f7 2c			ld a, (.dmark+1)  
2ceb 32 be fb			ld (debug_mark+1),a  
2cee 3a f8 2c			ld a, (.dmark+2)  
2cf1 32 bf fb			ld (debug_mark+2),a  
2cf4 18 03			jr .pastdmark  
2cf6 ..			.dmark: db "DO2"  
2cf9 f1			.pastdmark: pop af  
2cfa			endm  
# End of macro DMARK
2cfa						CALLMONITOR 
2cfa cd d3 13			call break_point_state  
2cfd				endm  
# End of macro CALLMONITOR
2cfd					endif 
2cfd					FORTH_RSP_NEXT 
2cfd cd 14 19			call macro_forth_rsp_next 
2d00				endm 
# End of macro FORTH_RSP_NEXT
2d00					if DEBUG_FORTH_WORDS 
2d00						DMARK "DO3" 
2d00 f5				push af  
2d01 3a 15 2d			ld a, (.dmark)  
2d04 32 bd fb			ld (debug_mark),a  
2d07 3a 16 2d			ld a, (.dmark+1)  
2d0a 32 be fb			ld (debug_mark+1),a  
2d0d 3a 17 2d			ld a, (.dmark+2)  
2d10 32 bf fb			ld (debug_mark+2),a  
2d13 18 03			jr .pastdmark  
2d15 ..			.dmark: db "DO3"  
2d18 f1			.pastdmark: pop af  
2d19			endm  
# End of macro DMARK
2d19						CALLMONITOR 
2d19 cd d3 13			call break_point_state  
2d1c				endm  
# End of macro CALLMONITOR
2d1c					endif 
2d1c			 
2d1c					;if DEBUG_FORTH_WORDS 
2d1c				;		push hl 
2d1c			;		endif  
2d1c			 
2d1c			; get counters from data stack 
2d1c			 
2d1c			 
2d1c					FORTH_DSP_VALUEHL 
2d1c cd 08 1a			call macro_dsp_valuehl 
2d1f				endm 
# End of macro FORTH_DSP_VALUEHL
2d1f e5					push hl		 ; hl now has starting counter which needs to be tos 
2d20			 
2d20					if DEBUG_FORTH_WORDS 
2d20						DMARK "DO4" 
2d20 f5				push af  
2d21 3a 35 2d			ld a, (.dmark)  
2d24 32 bd fb			ld (debug_mark),a  
2d27 3a 36 2d			ld a, (.dmark+1)  
2d2a 32 be fb			ld (debug_mark+1),a  
2d2d 3a 37 2d			ld a, (.dmark+2)  
2d30 32 bf fb			ld (debug_mark+2),a  
2d33 18 03			jr .pastdmark  
2d35 ..			.dmark: db "DO4"  
2d38 f1			.pastdmark: pop af  
2d39			endm  
# End of macro DMARK
2d39						CALLMONITOR 
2d39 cd d3 13			call break_point_state  
2d3c				endm  
# End of macro CALLMONITOR
2d3c					endif 
2d3c					FORTH_DSP_POP 
2d3c cd a4 1a			call macro_forth_dsp_pop 
2d3f				endm 
# End of macro FORTH_DSP_POP
2d3f			 
2d3f					if DEBUG_FORTH_WORDS 
2d3f						DMARK "DO5" 
2d3f f5				push af  
2d40 3a 54 2d			ld a, (.dmark)  
2d43 32 bd fb			ld (debug_mark),a  
2d46 3a 55 2d			ld a, (.dmark+1)  
2d49 32 be fb			ld (debug_mark+1),a  
2d4c 3a 56 2d			ld a, (.dmark+2)  
2d4f 32 bf fb			ld (debug_mark+2),a  
2d52 18 03			jr .pastdmark  
2d54 ..			.dmark: db "DO5"  
2d57 f1			.pastdmark: pop af  
2d58			endm  
# End of macro DMARK
2d58						CALLMONITOR 
2d58 cd d3 13			call break_point_state  
2d5b				endm  
# End of macro CALLMONITOR
2d5b					endif 
2d5b			 
2d5b					FORTH_DSP_VALUEHL 
2d5b cd 08 1a			call macro_dsp_valuehl 
2d5e				endm 
# End of macro FORTH_DSP_VALUEHL
2d5e			;		push hl		 ; hl now has starting limit counter 
2d5e			 
2d5e					if DEBUG_FORTH_WORDS 
2d5e						DMARK "DO6" 
2d5e f5				push af  
2d5f 3a 73 2d			ld a, (.dmark)  
2d62 32 bd fb			ld (debug_mark),a  
2d65 3a 74 2d			ld a, (.dmark+1)  
2d68 32 be fb			ld (debug_mark+1),a  
2d6b 3a 75 2d			ld a, (.dmark+2)  
2d6e 32 bf fb			ld (debug_mark+2),a  
2d71 18 03			jr .pastdmark  
2d73 ..			.dmark: db "DO6"  
2d76 f1			.pastdmark: pop af  
2d77			endm  
# End of macro DMARK
2d77						CALLMONITOR 
2d77 cd d3 13			call break_point_state  
2d7a				endm  
# End of macro CALLMONITOR
2d7a					endif 
2d7a					FORTH_DSP_POP 
2d7a cd a4 1a			call macro_forth_dsp_pop 
2d7d				endm 
# End of macro FORTH_DSP_POP
2d7d			 
2d7d			; put counters on the loop stack 
2d7d			 
2d7d			;		pop hl			 ; limit counter 
2d7d d1					pop de			; start counter 
2d7e			 
2d7e					; push limit counter 
2d7e			 
2d7e					if DEBUG_FORTH_WORDS 
2d7e						DMARK "DO7" 
2d7e f5				push af  
2d7f 3a 93 2d			ld a, (.dmark)  
2d82 32 bd fb			ld (debug_mark),a  
2d85 3a 94 2d			ld a, (.dmark+1)  
2d88 32 be fb			ld (debug_mark+1),a  
2d8b 3a 95 2d			ld a, (.dmark+2)  
2d8e 32 bf fb			ld (debug_mark+2),a  
2d91 18 03			jr .pastdmark  
2d93 ..			.dmark: db "DO7"  
2d96 f1			.pastdmark: pop af  
2d97			endm  
# End of macro DMARK
2d97						CALLMONITOR 
2d97 cd d3 13			call break_point_state  
2d9a				endm  
# End of macro CALLMONITOR
2d9a					endif 
2d9a					FORTH_LOOP_NEXT 
2d9a cd 1d 1a			call macro_forth_loop_next 
2d9d				endm 
# End of macro FORTH_LOOP_NEXT
2d9d			 
2d9d					; push start counter 
2d9d			 
2d9d eb					ex de, hl 
2d9e					if DEBUG_FORTH_WORDS 
2d9e						DMARK "DO7" 
2d9e f5				push af  
2d9f 3a b3 2d			ld a, (.dmark)  
2da2 32 bd fb			ld (debug_mark),a  
2da5 3a b4 2d			ld a, (.dmark+1)  
2da8 32 be fb			ld (debug_mark+1),a  
2dab 3a b5 2d			ld a, (.dmark+2)  
2dae 32 bf fb			ld (debug_mark+2),a  
2db1 18 03			jr .pastdmark  
2db3 ..			.dmark: db "DO7"  
2db6 f1			.pastdmark: pop af  
2db7			endm  
# End of macro DMARK
2db7						CALLMONITOR 
2db7 cd d3 13			call break_point_state  
2dba				endm  
# End of macro CALLMONITOR
2dba					endif 
2dba					FORTH_LOOP_NEXT 
2dba cd 1d 1a			call macro_forth_loop_next 
2dbd				endm 
# End of macro FORTH_LOOP_NEXT
2dbd			 
2dbd			 
2dbd					; init first round of I counter 
2dbd			 
2dbd 22 dd f2				ld (os_current_i), hl 
2dc0			 
2dc0					if DEBUG_FORTH_WORDS 
2dc0						DMARK "DO8" 
2dc0 f5				push af  
2dc1 3a d5 2d			ld a, (.dmark)  
2dc4 32 bd fb			ld (debug_mark),a  
2dc7 3a d6 2d			ld a, (.dmark+1)  
2dca 32 be fb			ld (debug_mark+1),a  
2dcd 3a d7 2d			ld a, (.dmark+2)  
2dd0 32 bf fb			ld (debug_mark+2),a  
2dd3 18 03			jr .pastdmark  
2dd5 ..			.dmark: db "DO8"  
2dd8 f1			.pastdmark: pop af  
2dd9			endm  
# End of macro DMARK
2dd9						CALLMONITOR 
2dd9 cd d3 13			call break_point_state  
2ddc				endm  
# End of macro CALLMONITOR
2ddc					endif 
2ddc			 
2ddc					NEXTW 
2ddc c3 5e 1b			jp macro_next 
2ddf				endm 
# End of macro NEXTW
2ddf			.LOOP: 
2ddf				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
2ddf 22				db WORD_SYS_CORE+14             
2de0 f7 2e			dw .I            
2de2 05				db 4 + 1 
2de3 .. 00			db "LOOP",0              
2de8				endm 
# End of macro CWHEAD
2de8			; | LOOP ( -- ) Increment and test loop counter  | DONE 
2de8			 
2de8				; pop tos as current loop count to hl 
2de8			 
2de8				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
2de8			 
2de8				FORTH_LOOP_TOS 
2de8 cd 50 1a			call macro_forth_loop_tos 
2deb				endm 
# End of macro FORTH_LOOP_TOS
2deb e5				push hl 
2dec			 
2dec					if DEBUG_FORTH_WORDS_KEY 
2dec						DMARK "LOP" 
2dec f5				push af  
2ded 3a 01 2e			ld a, (.dmark)  
2df0 32 bd fb			ld (debug_mark),a  
2df3 3a 02 2e			ld a, (.dmark+1)  
2df6 32 be fb			ld (debug_mark+1),a  
2df9 3a 03 2e			ld a, (.dmark+2)  
2dfc 32 bf fb			ld (debug_mark+2),a  
2dff 18 03			jr .pastdmark  
2e01 ..			.dmark: db "LOP"  
2e04 f1			.pastdmark: pop af  
2e05			endm  
# End of macro DMARK
2e05						CALLMONITOR 
2e05 cd d3 13			call break_point_state  
2e08				endm  
# End of macro CALLMONITOR
2e08					endif 
2e08				; next item on the stack is the limit. get it 
2e08			 
2e08			 
2e08				FORTH_LOOP_POP 
2e08 cd 5a 1a			call macro_forth_loop_pop 
2e0b				endm 
# End of macro FORTH_LOOP_POP
2e0b			 
2e0b				FORTH_LOOP_TOS 
2e0b cd 50 1a			call macro_forth_loop_tos 
2e0e				endm 
# End of macro FORTH_LOOP_TOS
2e0e			 
2e0e d1				pop de		 ; de = i, hl = limit 
2e0f			 
2e0f					if DEBUG_FORTH_WORDS 
2e0f						DMARK "LP1" 
2e0f f5				push af  
2e10 3a 24 2e			ld a, (.dmark)  
2e13 32 bd fb			ld (debug_mark),a  
2e16 3a 25 2e			ld a, (.dmark+1)  
2e19 32 be fb			ld (debug_mark+1),a  
2e1c 3a 26 2e			ld a, (.dmark+2)  
2e1f 32 bf fb			ld (debug_mark+2),a  
2e22 18 03			jr .pastdmark  
2e24 ..			.dmark: db "LP1"  
2e27 f1			.pastdmark: pop af  
2e28			endm  
# End of macro DMARK
2e28						CALLMONITOR 
2e28 cd d3 13			call break_point_state  
2e2b				endm  
# End of macro CALLMONITOR
2e2b					endif 
2e2b			 
2e2b				; go back to previous word 
2e2b			 
2e2b d5				push de    ; save I for inc later 
2e2c			 
2e2c			 
2e2c				; get limit 
2e2c				;  is I at limit? 
2e2c			 
2e2c			 
2e2c					if DEBUG_FORTH_WORDS 
2e2c						DMARK "LP1" 
2e2c f5				push af  
2e2d 3a 41 2e			ld a, (.dmark)  
2e30 32 bd fb			ld (debug_mark),a  
2e33 3a 42 2e			ld a, (.dmark+1)  
2e36 32 be fb			ld (debug_mark+1),a  
2e39 3a 43 2e			ld a, (.dmark+2)  
2e3c 32 bf fb			ld (debug_mark+2),a  
2e3f 18 03			jr .pastdmark  
2e41 ..			.dmark: db "LP1"  
2e44 f1			.pastdmark: pop af  
2e45			endm  
# End of macro DMARK
2e45						CALLMONITOR 
2e45 cd d3 13			call break_point_state  
2e48				endm  
# End of macro CALLMONITOR
2e48					endif 
2e48			 
2e48 ed 52			sbc hl, de 
2e4a			 
2e4a			 
2e4a				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
2e4a			 
2e4a 20 26				jr nz, .loopnotdone 
2e4c			 
2e4c e1				pop hl   ; get rid of saved I 
2e4d				FORTH_LOOP_POP     ; get rid of limit 
2e4d cd 5a 1a			call macro_forth_loop_pop 
2e50				endm 
# End of macro FORTH_LOOP_POP
2e50			 
2e50				FORTH_RSP_POP     ; get rid of DO ptr 
2e50 cd 35 19			call macro_forth_rsp_pop 
2e53				endm 
# End of macro FORTH_RSP_POP
2e53			 
2e53			if DEBUG_FORTH_WORDS 
2e53						DMARK "LP>" 
2e53 f5				push af  
2e54 3a 68 2e			ld a, (.dmark)  
2e57 32 bd fb			ld (debug_mark),a  
2e5a 3a 69 2e			ld a, (.dmark+1)  
2e5d 32 be fb			ld (debug_mark+1),a  
2e60 3a 6a 2e			ld a, (.dmark+2)  
2e63 32 bf fb			ld (debug_mark+2),a  
2e66 18 03			jr .pastdmark  
2e68 ..			.dmark: db "LP>"  
2e6b f1			.pastdmark: pop af  
2e6c			endm  
# End of macro DMARK
2e6c				CALLMONITOR 
2e6c cd d3 13			call break_point_state  
2e6f				endm  
# End of macro CALLMONITOR
2e6f			endif 
2e6f			 
2e6f					NEXTW 
2e6f c3 5e 1b			jp macro_next 
2e72				endm 
# End of macro NEXTW
2e72				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
2e72			 
2e72			.loopnotdone: 
2e72			 
2e72 e1				pop hl    ; get I 
2e73 23				inc hl 
2e74			 
2e74			   	; save new I 
2e74			 
2e74			 
2e74					; set I counter 
2e74			 
2e74 22 dd f2				ld (os_current_i), hl 
2e77			 
2e77					if DEBUG_FORTH_WORDS 
2e77						DMARK "LPN" 
2e77 f5				push af  
2e78 3a 8c 2e			ld a, (.dmark)  
2e7b 32 bd fb			ld (debug_mark),a  
2e7e 3a 8d 2e			ld a, (.dmark+1)  
2e81 32 be fb			ld (debug_mark+1),a  
2e84 3a 8e 2e			ld a, (.dmark+2)  
2e87 32 bf fb			ld (debug_mark+2),a  
2e8a 18 03			jr .pastdmark  
2e8c ..			.dmark: db "LPN"  
2e8f f1			.pastdmark: pop af  
2e90			endm  
# End of macro DMARK
2e90					CALLMONITOR 
2e90 cd d3 13			call break_point_state  
2e93				endm  
# End of macro CALLMONITOR
2e93					endif 
2e93					 
2e93				FORTH_LOOP_NEXT 
2e93 cd 1d 1a			call macro_forth_loop_next 
2e96				endm 
# End of macro FORTH_LOOP_NEXT
2e96			 
2e96			 
2e96					if DEBUG_FORTH_WORDS 
2e96 eb						ex de,hl 
2e97					endif 
2e97			 
2e97			;	; get DO ptr 
2e97			; 
2e97					if DEBUG_FORTH_WORDS 
2e97						DMARK "LP7" 
2e97 f5				push af  
2e98 3a ac 2e			ld a, (.dmark)  
2e9b 32 bd fb			ld (debug_mark),a  
2e9e 3a ad 2e			ld a, (.dmark+1)  
2ea1 32 be fb			ld (debug_mark+1),a  
2ea4 3a ae 2e			ld a, (.dmark+2)  
2ea7 32 bf fb			ld (debug_mark+2),a  
2eaa 18 03			jr .pastdmark  
2eac ..			.dmark: db "LP7"  
2eaf f1			.pastdmark: pop af  
2eb0			endm  
# End of macro DMARK
2eb0					CALLMONITOR 
2eb0 cd d3 13			call break_point_state  
2eb3				endm  
# End of macro CALLMONITOR
2eb3					endif 
2eb3				FORTH_RSP_TOS 
2eb3 cd 2b 19			call macro_forth_rsp_tos 
2eb6				endm 
# End of macro FORTH_RSP_TOS
2eb6			 
2eb6					if DEBUG_FORTH_WORDS 
2eb6						DMARK "LP8" 
2eb6 f5				push af  
2eb7 3a cb 2e			ld a, (.dmark)  
2eba 32 bd fb			ld (debug_mark),a  
2ebd 3a cc 2e			ld a, (.dmark+1)  
2ec0 32 be fb			ld (debug_mark+1),a  
2ec3 3a cd 2e			ld a, (.dmark+2)  
2ec6 32 bf fb			ld (debug_mark+2),a  
2ec9 18 03			jr .pastdmark  
2ecb ..			.dmark: db "LP8"  
2ece f1			.pastdmark: pop af  
2ecf			endm  
# End of macro DMARK
2ecf					CALLMONITOR 
2ecf cd d3 13			call break_point_state  
2ed2				endm  
# End of macro CALLMONITOR
2ed2					endif 
2ed2				;push hl 
2ed2			 
2ed2				; not going to DO any more 
2ed2				; get rid of the RSP pointer as DO will add it back in 
2ed2				;FORTH_RSP_POP 
2ed2				;pop hl 
2ed2			 
2ed2				;ld hl,(cli_ret_sp) 
2ed2				;ld e, (hl) 
2ed2				;inc hl 
2ed2				;ld d, (hl) 
2ed2				;ex de,hl 
2ed2 22 b9 f2			ld (os_tok_ptr), hl 
2ed5					if DEBUG_FORTH_WORDS 
2ed5						DMARK "LP<" 
2ed5 f5				push af  
2ed6 3a ea 2e			ld a, (.dmark)  
2ed9 32 bd fb			ld (debug_mark),a  
2edc 3a eb 2e			ld a, (.dmark+1)  
2edf 32 be fb			ld (debug_mark+1),a  
2ee2 3a ec 2e			ld a, (.dmark+2)  
2ee5 32 bf fb			ld (debug_mark+2),a  
2ee8 18 03			jr .pastdmark  
2eea ..			.dmark: db "LP<"  
2eed f1			.pastdmark: pop af  
2eee			endm  
# End of macro DMARK
2eee					CALLMONITOR 
2eee cd d3 13			call break_point_state  
2ef1				endm  
# End of macro CALLMONITOR
2ef1				endif 
2ef1 c3 ef 1b			jp exec1 
2ef4			 
2ef4					 
2ef4			 
2ef4			 
2ef4					NEXTW 
2ef4 c3 5e 1b			jp macro_next 
2ef7				endm 
# End of macro NEXTW
2ef7			.I:  
2ef7			 
2ef7				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
2ef7 5e				db WORD_SYS_CORE+74             
2ef8 22 2f			dw .DLOOP            
2efa 02				db 1 + 1 
2efb .. 00			db "I",0              
2efd				endm 
# End of macro CWHEAD
2efd			; | I ( -- ) Current loop counter | DONE 
2efd					if DEBUG_FORTH_WORDS_KEY 
2efd						DMARK "I.." 
2efd f5				push af  
2efe 3a 12 2f			ld a, (.dmark)  
2f01 32 bd fb			ld (debug_mark),a  
2f04 3a 13 2f			ld a, (.dmark+1)  
2f07 32 be fb			ld (debug_mark+1),a  
2f0a 3a 14 2f			ld a, (.dmark+2)  
2f0d 32 bf fb			ld (debug_mark+2),a  
2f10 18 03			jr .pastdmark  
2f12 ..			.dmark: db "I.."  
2f15 f1			.pastdmark: pop af  
2f16			endm  
# End of macro DMARK
2f16						CALLMONITOR 
2f16 cd d3 13			call break_point_state  
2f19				endm  
# End of macro CALLMONITOR
2f19					endif 
2f19			 
2f19 2a dd f2				ld hl,(os_current_i) 
2f1c cd 6d 19				call forth_push_numhl 
2f1f			 
2f1f					NEXTW 
2f1f c3 5e 1b			jp macro_next 
2f22				endm 
# End of macro NEXTW
2f22			.DLOOP: 
2f22				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
2f22 5f				db WORD_SYS_CORE+75             
2f23 03 30			dw .REPEAT            
2f25 06				db 5 + 1 
2f26 .. 00			db "-LOOP",0              
2f2c				endm 
# End of macro CWHEAD
2f2c			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
2f2c				; pop tos as current loop count to hl 
2f2c					if DEBUG_FORTH_WORDS_KEY 
2f2c						DMARK "-LP" 
2f2c f5				push af  
2f2d 3a 41 2f			ld a, (.dmark)  
2f30 32 bd fb			ld (debug_mark),a  
2f33 3a 42 2f			ld a, (.dmark+1)  
2f36 32 be fb			ld (debug_mark+1),a  
2f39 3a 43 2f			ld a, (.dmark+2)  
2f3c 32 bf fb			ld (debug_mark+2),a  
2f3f 18 03			jr .pastdmark  
2f41 ..			.dmark: db "-LP"  
2f44 f1			.pastdmark: pop af  
2f45			endm  
# End of macro DMARK
2f45						CALLMONITOR 
2f45 cd d3 13			call break_point_state  
2f48				endm  
# End of macro CALLMONITOR
2f48					endif 
2f48			 
2f48				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
2f48			 
2f48				FORTH_LOOP_TOS 
2f48 cd 50 1a			call macro_forth_loop_tos 
2f4b				endm 
# End of macro FORTH_LOOP_TOS
2f4b e5				push hl 
2f4c			 
2f4c					if DEBUG_FORTH_WORDS 
2f4c						DMARK "-LP" 
2f4c f5				push af  
2f4d 3a 61 2f			ld a, (.dmark)  
2f50 32 bd fb			ld (debug_mark),a  
2f53 3a 62 2f			ld a, (.dmark+1)  
2f56 32 be fb			ld (debug_mark+1),a  
2f59 3a 63 2f			ld a, (.dmark+2)  
2f5c 32 bf fb			ld (debug_mark+2),a  
2f5f 18 03			jr .pastdmark  
2f61 ..			.dmark: db "-LP"  
2f64 f1			.pastdmark: pop af  
2f65			endm  
# End of macro DMARK
2f65						CALLMONITOR 
2f65 cd d3 13			call break_point_state  
2f68				endm  
# End of macro CALLMONITOR
2f68					endif 
2f68				; next item on the stack is the limit. get it 
2f68			 
2f68			 
2f68				FORTH_LOOP_POP 
2f68 cd 5a 1a			call macro_forth_loop_pop 
2f6b				endm 
# End of macro FORTH_LOOP_POP
2f6b			 
2f6b				FORTH_LOOP_TOS 
2f6b cd 50 1a			call macro_forth_loop_tos 
2f6e				endm 
# End of macro FORTH_LOOP_TOS
2f6e			 
2f6e d1				pop de		 ; de = i, hl = limit 
2f6f			 
2f6f					if DEBUG_FORTH_WORDS 
2f6f						DMARK "-L1" 
2f6f f5				push af  
2f70 3a 84 2f			ld a, (.dmark)  
2f73 32 bd fb			ld (debug_mark),a  
2f76 3a 85 2f			ld a, (.dmark+1)  
2f79 32 be fb			ld (debug_mark+1),a  
2f7c 3a 86 2f			ld a, (.dmark+2)  
2f7f 32 bf fb			ld (debug_mark+2),a  
2f82 18 03			jr .pastdmark  
2f84 ..			.dmark: db "-L1"  
2f87 f1			.pastdmark: pop af  
2f88			endm  
# End of macro DMARK
2f88						CALLMONITOR 
2f88 cd d3 13			call break_point_state  
2f8b				endm  
# End of macro CALLMONITOR
2f8b					endif 
2f8b			 
2f8b				; go back to previous word 
2f8b			 
2f8b d5				push de    ; save I for inc later 
2f8c			 
2f8c			 
2f8c				; get limit 
2f8c				;  is I at limit? 
2f8c			 
2f8c			 
2f8c					if DEBUG_FORTH_WORDS 
2f8c						DMARK "-L1" 
2f8c f5				push af  
2f8d 3a a1 2f			ld a, (.dmark)  
2f90 32 bd fb			ld (debug_mark),a  
2f93 3a a2 2f			ld a, (.dmark+1)  
2f96 32 be fb			ld (debug_mark+1),a  
2f99 3a a3 2f			ld a, (.dmark+2)  
2f9c 32 bf fb			ld (debug_mark+2),a  
2f9f 18 03			jr .pastdmark  
2fa1 ..			.dmark: db "-L1"  
2fa4 f1			.pastdmark: pop af  
2fa5			endm  
# End of macro DMARK
2fa5						CALLMONITOR 
2fa5 cd d3 13			call break_point_state  
2fa8				endm  
# End of macro CALLMONITOR
2fa8					endif 
2fa8			 
2fa8 ed 52			sbc hl, de 
2faa			 
2faa			 
2faa				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
2faa			 
2faa 20 26				jr nz, .mloopnotdone 
2fac			 
2fac e1				pop hl   ; get rid of saved I 
2fad				FORTH_LOOP_POP     ; get rid of limit 
2fad cd 5a 1a			call macro_forth_loop_pop 
2fb0				endm 
# End of macro FORTH_LOOP_POP
2fb0			 
2fb0				FORTH_RSP_POP     ; get rid of DO ptr 
2fb0 cd 35 19			call macro_forth_rsp_pop 
2fb3				endm 
# End of macro FORTH_RSP_POP
2fb3			 
2fb3			if DEBUG_FORTH_WORDS 
2fb3						DMARK "-L>" 
2fb3 f5				push af  
2fb4 3a c8 2f			ld a, (.dmark)  
2fb7 32 bd fb			ld (debug_mark),a  
2fba 3a c9 2f			ld a, (.dmark+1)  
2fbd 32 be fb			ld (debug_mark+1),a  
2fc0 3a ca 2f			ld a, (.dmark+2)  
2fc3 32 bf fb			ld (debug_mark+2),a  
2fc6 18 03			jr .pastdmark  
2fc8 ..			.dmark: db "-L>"  
2fcb f1			.pastdmark: pop af  
2fcc			endm  
# End of macro DMARK
2fcc				CALLMONITOR 
2fcc cd d3 13			call break_point_state  
2fcf				endm  
# End of macro CALLMONITOR
2fcf			endif 
2fcf			 
2fcf					NEXTW 
2fcf c3 5e 1b			jp macro_next 
2fd2				endm 
# End of macro NEXTW
2fd2				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
2fd2			 
2fd2			.mloopnotdone: 
2fd2			 
2fd2 e1				pop hl    ; get I 
2fd3 2b				dec hl 
2fd4			 
2fd4			   	; save new I 
2fd4			 
2fd4			 
2fd4					; set I counter 
2fd4			 
2fd4 22 dd f2				ld (os_current_i), hl 
2fd7			 
2fd7					 
2fd7				FORTH_LOOP_NEXT 
2fd7 cd 1d 1a			call macro_forth_loop_next 
2fda				endm 
# End of macro FORTH_LOOP_NEXT
2fda			 
2fda			 
2fda					if DEBUG_FORTH_WORDS 
2fda eb						ex de,hl 
2fdb					endif 
2fdb			 
2fdb			;	; get DO ptr 
2fdb			; 
2fdb				FORTH_RSP_TOS 
2fdb cd 2b 19			call macro_forth_rsp_tos 
2fde				endm 
# End of macro FORTH_RSP_TOS
2fde			 
2fde				;push hl 
2fde			 
2fde				; not going to DO any more 
2fde				; get rid of the RSP pointer as DO will add it back in 
2fde				;FORTH_RSP_POP 
2fde				;pop hl 
2fde			 
2fde			 
2fde 22 b9 f2			ld (os_tok_ptr), hl 
2fe1					if DEBUG_FORTH_WORDS 
2fe1						DMARK "-L<" 
2fe1 f5				push af  
2fe2 3a f6 2f			ld a, (.dmark)  
2fe5 32 bd fb			ld (debug_mark),a  
2fe8 3a f7 2f			ld a, (.dmark+1)  
2feb 32 be fb			ld (debug_mark+1),a  
2fee 3a f8 2f			ld a, (.dmark+2)  
2ff1 32 bf fb			ld (debug_mark+2),a  
2ff4 18 03			jr .pastdmark  
2ff6 ..			.dmark: db "-L<"  
2ff9 f1			.pastdmark: pop af  
2ffa			endm  
# End of macro DMARK
2ffa					CALLMONITOR 
2ffa cd d3 13			call break_point_state  
2ffd				endm  
# End of macro CALLMONITOR
2ffd				endif 
2ffd c3 ef 1b			jp exec1 
3000			 
3000					 
3000			 
3000			 
3000			 
3000				NEXTW 
3000 c3 5e 1b			jp macro_next 
3003				endm 
# End of macro NEXTW
3003			 
3003			 
3003			 
3003			 
3003			.REPEAT: 
3003				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
3003 71				db WORD_SYS_CORE+93             
3004 56 30			dw .UNTIL            
3006 06				db 5 + 1 
3007 .. 00			db "REPEAT",0              
300e				endm 
# End of macro CWHEAD
300e			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
300e			;  push pc to rsp stack past the REPEAT 
300e					if DEBUG_FORTH_WORDS_KEY 
300e						DMARK "REP" 
300e f5				push af  
300f 3a 23 30			ld a, (.dmark)  
3012 32 bd fb			ld (debug_mark),a  
3015 3a 24 30			ld a, (.dmark+1)  
3018 32 be fb			ld (debug_mark+1),a  
301b 3a 25 30			ld a, (.dmark+2)  
301e 32 bf fb			ld (debug_mark+2),a  
3021 18 03			jr .pastdmark  
3023 ..			.dmark: db "REP"  
3026 f1			.pastdmark: pop af  
3027			endm  
# End of macro DMARK
3027						CALLMONITOR 
3027 cd d3 13			call break_point_state  
302a				endm  
# End of macro CALLMONITOR
302a					endif 
302a			 
302a 2a b9 f2				ld hl, (os_tok_ptr) 
302d 23					inc hl   ; R 
302e 23					inc hl  ; E 
302f 23					inc hl   ; P 
3030 23					inc hl   ; E 
3031 23					inc hl   ; A 
3032 23					inc hl   ; T 
3033 23					inc hl   ; zero 
3034					FORTH_RSP_NEXT 
3034 cd 14 19			call macro_forth_rsp_next 
3037				endm 
# End of macro FORTH_RSP_NEXT
3037			 
3037			 
3037					if DEBUG_FORTH_WORDS 
3037						DMARK "REP" 
3037 f5				push af  
3038 3a 4c 30			ld a, (.dmark)  
303b 32 bd fb			ld (debug_mark),a  
303e 3a 4d 30			ld a, (.dmark+1)  
3041 32 be fb			ld (debug_mark+1),a  
3044 3a 4e 30			ld a, (.dmark+2)  
3047 32 bf fb			ld (debug_mark+2),a  
304a 18 03			jr .pastdmark  
304c ..			.dmark: db "REP"  
304f f1			.pastdmark: pop af  
3050			endm  
# End of macro DMARK
3050						;pop bc    ; TODO BUG ?????? what is this for???? 
3050						CALLMONITOR 
3050 cd d3 13			call break_point_state  
3053				endm  
# End of macro CALLMONITOR
3053					endif 
3053			 
3053					NEXTW 
3053 c3 5e 1b			jp macro_next 
3056				endm 
# End of macro NEXTW
3056			;	       NEXTW 
3056			 
3056			.UNTIL: 
3056				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
3056 72				db WORD_SYS_CORE+94             
3057 ed 30			dw .ENDFLOW            
3059 06				db 5 + 1 
305a .. 00			db "UNTIL",0              
3060				endm 
# End of macro CWHEAD
3060			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
3060			 
3060				; pop tos as check 
3060			 
3060				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3060			 
3060				FORTH_DSP_VALUEHL 
3060 cd 08 1a			call macro_dsp_valuehl 
3063				endm 
# End of macro FORTH_DSP_VALUEHL
3063			 
3063					if DEBUG_FORTH_WORDS_KEY 
3063						DMARK "UNT" 
3063 f5				push af  
3064 3a 78 30			ld a, (.dmark)  
3067 32 bd fb			ld (debug_mark),a  
306a 3a 79 30			ld a, (.dmark+1)  
306d 32 be fb			ld (debug_mark+1),a  
3070 3a 7a 30			ld a, (.dmark+2)  
3073 32 bf fb			ld (debug_mark+2),a  
3076 18 03			jr .pastdmark  
3078 ..			.dmark: db "UNT"  
307b f1			.pastdmark: pop af  
307c			endm  
# End of macro DMARK
307c						CALLMONITOR 
307c cd d3 13			call break_point_state  
307f				endm  
# End of macro CALLMONITOR
307f					endif 
307f			 
307f			;	push hl 
307f				FORTH_DSP_POP 
307f cd a4 1a			call macro_forth_dsp_pop 
3082				endm 
# End of macro FORTH_DSP_POP
3082			 
3082			;	pop hl 
3082			 
3082				; test if true 
3082			 
3082 cd 38 0c			call ishlzero 
3085			;	ld a,l 
3085			;	add h 
3085			; 
3085			;	cp 0 
3085			 
3085 20 3e			jr nz, .untilnotdone 
3087			 
3087					if DEBUG_FORTH_WORDS 
3087						DMARK "UNf" 
3087 f5				push af  
3088 3a 9c 30			ld a, (.dmark)  
308b 32 bd fb			ld (debug_mark),a  
308e 3a 9d 30			ld a, (.dmark+1)  
3091 32 be fb			ld (debug_mark+1),a  
3094 3a 9e 30			ld a, (.dmark+2)  
3097 32 bf fb			ld (debug_mark+2),a  
309a 18 03			jr .pastdmark  
309c ..			.dmark: db "UNf"  
309f f1			.pastdmark: pop af  
30a0			endm  
# End of macro DMARK
30a0						CALLMONITOR 
30a0 cd d3 13			call break_point_state  
30a3				endm  
# End of macro CALLMONITOR
30a3					endif 
30a3			 
30a3			 
30a3			 
30a3				FORTH_RSP_POP     ; get rid of DO ptr 
30a3 cd 35 19			call macro_forth_rsp_pop 
30a6				endm 
# End of macro FORTH_RSP_POP
30a6			 
30a6			if DEBUG_FORTH_WORDS 
30a6						DMARK "UN>" 
30a6 f5				push af  
30a7 3a bb 30			ld a, (.dmark)  
30aa 32 bd fb			ld (debug_mark),a  
30ad 3a bc 30			ld a, (.dmark+1)  
30b0 32 be fb			ld (debug_mark+1),a  
30b3 3a bd 30			ld a, (.dmark+2)  
30b6 32 bf fb			ld (debug_mark+2),a  
30b9 18 03			jr .pastdmark  
30bb ..			.dmark: db "UN>"  
30be f1			.pastdmark: pop af  
30bf			endm  
# End of macro DMARK
30bf				CALLMONITOR 
30bf cd d3 13			call break_point_state  
30c2				endm  
# End of macro CALLMONITOR
30c2			endif 
30c2			 
30c2					NEXTW 
30c2 c3 5e 1b			jp macro_next 
30c5				endm 
# End of macro NEXTW
30c5				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
30c5			 
30c5			.untilnotdone: 
30c5			 
30c5			 
30c5			;	; get DO ptr 
30c5			; 
30c5				FORTH_RSP_TOS 
30c5 cd 2b 19			call macro_forth_rsp_tos 
30c8				endm 
# End of macro FORTH_RSP_TOS
30c8			 
30c8				;push hl 
30c8			 
30c8				; not going to DO any more 
30c8				; get rid of the RSP pointer as DO will add it back in 
30c8				;FORTH_RSP_POP 
30c8				;pop hl 
30c8			 
30c8			 
30c8 22 b9 f2			ld (os_tok_ptr), hl 
30cb					if DEBUG_FORTH_WORDS 
30cb						DMARK "UN<" 
30cb f5				push af  
30cc 3a e0 30			ld a, (.dmark)  
30cf 32 bd fb			ld (debug_mark),a  
30d2 3a e1 30			ld a, (.dmark+1)  
30d5 32 be fb			ld (debug_mark+1),a  
30d8 3a e2 30			ld a, (.dmark+2)  
30db 32 bf fb			ld (debug_mark+2),a  
30de 18 03			jr .pastdmark  
30e0 ..			.dmark: db "UN<"  
30e3 f1			.pastdmark: pop af  
30e4			endm  
# End of macro DMARK
30e4					CALLMONITOR 
30e4 cd d3 13			call break_point_state  
30e7				endm  
# End of macro CALLMONITOR
30e7				endif 
30e7 c3 ef 1b			jp exec1 
30ea			 
30ea					 
30ea			 
30ea			 
30ea					NEXTW 
30ea c3 5e 1b			jp macro_next 
30ed				endm 
# End of macro NEXTW
30ed			 
30ed			 
30ed			.ENDFLOW: 
30ed			 
30ed			; eof 
30ed			 
# End of file forth_words_flow.asm
30ed			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
30ed			include "forth_words_logic.asm" 
30ed			 
30ed			; | ## Logic Words 
30ed			 
30ed			.NOT: 
30ed				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
30ed 2d				db WORD_SYS_CORE+25             
30ee 35 31			dw .IS            
30f0 04				db 3 + 1 
30f1 .. 00			db "NOT",0              
30f5				endm 
# End of macro CWHEAD
30f5			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
30f5					if DEBUG_FORTH_WORDS_KEY 
30f5						DMARK "NOT" 
30f5 f5				push af  
30f6 3a 0a 31			ld a, (.dmark)  
30f9 32 bd fb			ld (debug_mark),a  
30fc 3a 0b 31			ld a, (.dmark+1)  
30ff 32 be fb			ld (debug_mark+1),a  
3102 3a 0c 31			ld a, (.dmark+2)  
3105 32 bf fb			ld (debug_mark+2),a  
3108 18 03			jr .pastdmark  
310a ..			.dmark: db "NOT"  
310d f1			.pastdmark: pop af  
310e			endm  
# End of macro DMARK
310e						CALLMONITOR 
310e cd d3 13			call break_point_state  
3111				endm  
# End of macro CALLMONITOR
3111					endif 
3111					FORTH_DSP 
3111 cd ed 19			call macro_forth_dsp 
3114				endm 
# End of macro FORTH_DSP
3114 7e					ld a,(hl)	; get type of value on TOS 
3115 fe 02				cp DS_TYPE_INUM  
3117 28 03				jr z, .noti 
3119					NEXTW 
3119 c3 5e 1b			jp macro_next 
311c				endm 
# End of macro NEXTW
311c			.noti:          FORTH_DSP_VALUEHL 
311c cd 08 1a			call macro_dsp_valuehl 
311f				endm 
# End of macro FORTH_DSP_VALUEHL
311f			;		push hl 
311f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
311f cd a4 1a			call macro_forth_dsp_pop 
3122				endm 
# End of macro FORTH_DSP_POP
3122			;		pop hl 
3122 3e 00				ld a,0 
3124 bd					cp l 
3125 28 04				jr z, .not2t 
3127 2e 00				ld l, 0 
3129 18 02				jr .notip 
312b			 
312b 2e ff		.not2t:		ld l, 255 
312d			 
312d 26 00		.notip:		ld h, 0	 
312f			 
312f cd 6d 19				call forth_push_numhl 
3132					NEXTW 
3132 c3 5e 1b			jp macro_next 
3135				endm 
# End of macro NEXTW
3135			 
3135			.IS: 
3135				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
3135 2d				db WORD_SYS_CORE+25             
3136 5b 31			dw .LZERO            
3138 03				db 2 + 1 
3139 .. 00			db "IS",0              
313c				endm 
# End of macro CWHEAD
313c			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
313c					if DEBUG_FORTH_WORDS_KEY 
313c						DMARK "IS." 
313c f5				push af  
313d 3a 51 31			ld a, (.dmark)  
3140 32 bd fb			ld (debug_mark),a  
3143 3a 52 31			ld a, (.dmark+1)  
3146 32 be fb			ld (debug_mark+1),a  
3149 3a 53 31			ld a, (.dmark+2)  
314c 32 bf fb			ld (debug_mark+2),a  
314f 18 03			jr .pastdmark  
3151 ..			.dmark: db "IS."  
3154 f1			.pastdmark: pop af  
3155			endm  
# End of macro DMARK
3155						CALLMONITOR 
3155 cd d3 13			call break_point_state  
3158				endm  
# End of macro CALLMONITOR
3158					endif 
3158					NEXTW 
3158 c3 5e 1b			jp macro_next 
315b				endm 
# End of macro NEXTW
315b			.LZERO: 
315b				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
315b 2d				db WORD_SYS_CORE+25             
315c 65 31			dw .TZERO            
315e 03				db 2 + 1 
315f .. 00			db "0<",0              
3162				endm 
# End of macro CWHEAD
3162			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
3162					NEXTW 
3162 c3 5e 1b			jp macro_next 
3165				endm 
# End of macro NEXTW
3165			.TZERO: 
3165				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
3165 2e				db WORD_SYS_CORE+26             
3166 ac 31			dw .LESS            
3168 03				db 2 + 1 
3169 .. 00			db "0=",0              
316c				endm 
# End of macro CWHEAD
316c			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
316c				; TODO add floating point number detection 
316c					;v5 FORTH_DSP_VALUE 
316c					if DEBUG_FORTH_WORDS_KEY 
316c						DMARK "0=." 
316c f5				push af  
316d 3a 81 31			ld a, (.dmark)  
3170 32 bd fb			ld (debug_mark),a  
3173 3a 82 31			ld a, (.dmark+1)  
3176 32 be fb			ld (debug_mark+1),a  
3179 3a 83 31			ld a, (.dmark+2)  
317c 32 bf fb			ld (debug_mark+2),a  
317f 18 03			jr .pastdmark  
3181 ..			.dmark: db "0=."  
3184 f1			.pastdmark: pop af  
3185			endm  
# End of macro DMARK
3185						CALLMONITOR 
3185 cd d3 13			call break_point_state  
3188				endm  
# End of macro CALLMONITOR
3188					endif 
3188					FORTH_DSP 
3188 cd ed 19			call macro_forth_dsp 
318b				endm 
# End of macro FORTH_DSP
318b 7e					ld a,(hl)	; get type of value on TOS 
318c fe 02				cp DS_TYPE_INUM  
318e 28 00				jr z, .tz_inum 
3190			 
3190				if FORTH_ENABLE_FLOATMATH 
3190					jr .tz_done 
3190			 
3190				endif 
3190					 
3190			 
3190			.tz_inum: 
3190					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3190 cd 08 1a			call macro_dsp_valuehl 
3193				endm 
# End of macro FORTH_DSP_VALUEHL
3193			 
3193			;		push hl 
3193			 
3193					; destroy value TOS 
3193			 
3193					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3193 cd a4 1a			call macro_forth_dsp_pop 
3196				endm 
# End of macro FORTH_DSP_POP
3196			 
3196			;		pop hl 
3196			 
3196 3e 00				ld a,0 
3198			 
3198 bd					cp l 
3199 20 08				jr nz, .tz_notzero 
319b			 
319b bc					cp h 
319c			 
319c 20 05				jr nz, .tz_notzero 
319e			 
319e			 
319e 21 01 00				ld hl, FORTH_TRUE 
31a1 18 03				jr .tz_done 
31a3			 
31a3 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
31a6			 
31a6					; push value back onto stack for another op etc 
31a6			 
31a6			.tz_done: 
31a6 cd 6d 19				call forth_push_numhl 
31a9			 
31a9					NEXTW 
31a9 c3 5e 1b			jp macro_next 
31ac				endm 
# End of macro NEXTW
31ac			.LESS: 
31ac				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
31ac 2f				db WORD_SYS_CORE+27             
31ad 15 32			dw .GT            
31af 02				db 1 + 1 
31b0 .. 00			db "<",0              
31b2				endm 
# End of macro CWHEAD
31b2			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
31b2				; TODO add floating point number detection 
31b2					if DEBUG_FORTH_WORDS_KEY 
31b2						DMARK "LES" 
31b2 f5				push af  
31b3 3a c7 31			ld a, (.dmark)  
31b6 32 bd fb			ld (debug_mark),a  
31b9 3a c8 31			ld a, (.dmark+1)  
31bc 32 be fb			ld (debug_mark+1),a  
31bf 3a c9 31			ld a, (.dmark+2)  
31c2 32 bf fb			ld (debug_mark+2),a  
31c5 18 03			jr .pastdmark  
31c7 ..			.dmark: db "LES"  
31ca f1			.pastdmark: pop af  
31cb			endm  
# End of macro DMARK
31cb						CALLMONITOR 
31cb cd d3 13			call break_point_state  
31ce				endm  
# End of macro CALLMONITOR
31ce					endif 
31ce					FORTH_DSP 
31ce cd ed 19			call macro_forth_dsp 
31d1				endm 
# End of macro FORTH_DSP
31d1					;v5 FORTH_DSP_VALUE 
31d1 7e					ld a,(hl)	; get type of value on TOS 
31d2 fe 02				cp DS_TYPE_INUM  
31d4 28 00				jr z, .less_inum 
31d6			 
31d6				if FORTH_ENABLE_FLOATMATH 
31d6					jr .less_done 
31d6			 
31d6				endif 
31d6					 
31d6			 
31d6			.less_inum: 
31d6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
31d6 cd 08 1a			call macro_dsp_valuehl 
31d9				endm 
# End of macro FORTH_DSP_VALUEHL
31d9			 
31d9 e5					push hl  ; u2 
31da			 
31da					; destroy value TOS 
31da			 
31da					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
31da cd a4 1a			call macro_forth_dsp_pop 
31dd				endm 
# End of macro FORTH_DSP_POP
31dd			 
31dd			 
31dd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
31dd cd 08 1a			call macro_dsp_valuehl 
31e0				endm 
# End of macro FORTH_DSP_VALUEHL
31e0			 
31e0 e5					push hl    ; u1 
31e1			 
31e1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
31e1 cd a4 1a			call macro_forth_dsp_pop 
31e4				endm 
# End of macro FORTH_DSP_POP
31e4			 
31e4			 
31e4 b7			 or a      ;clear carry flag 
31e5 01 00 00		 ld bc, FORTH_FALSE 
31e8 e1			  pop hl    ; u1 
31e9 d1			  pop de    ; u2 
31ea ed 52		  sbc hl,de 
31ec 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
31ee			 
31ee 01 01 00		 ld bc, FORTH_TRUE 
31f1			.lscont:  
31f1 c5					push bc 
31f2 e1					pop hl 
31f3			 
31f3					if DEBUG_FORTH_WORDS 
31f3						DMARK "LT1" 
31f3 f5				push af  
31f4 3a 08 32			ld a, (.dmark)  
31f7 32 bd fb			ld (debug_mark),a  
31fa 3a 09 32			ld a, (.dmark+1)  
31fd 32 be fb			ld (debug_mark+1),a  
3200 3a 0a 32			ld a, (.dmark+2)  
3203 32 bf fb			ld (debug_mark+2),a  
3206 18 03			jr .pastdmark  
3208 ..			.dmark: db "LT1"  
320b f1			.pastdmark: pop af  
320c			endm  
# End of macro DMARK
320c						CALLMONITOR 
320c cd d3 13			call break_point_state  
320f				endm  
# End of macro CALLMONITOR
320f					endif 
320f cd 6d 19				call forth_push_numhl 
3212			 
3212					NEXTW 
3212 c3 5e 1b			jp macro_next 
3215				endm 
# End of macro NEXTW
3215			.GT: 
3215				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
3215 30				db WORD_SYS_CORE+28             
3216 7e 32			dw .EQUAL            
3218 02				db 1 + 1 
3219 .. 00			db ">",0              
321b				endm 
# End of macro CWHEAD
321b			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
321b				; TODO add floating point number detection 
321b					if DEBUG_FORTH_WORDS_KEY 
321b						DMARK "GRT" 
321b f5				push af  
321c 3a 30 32			ld a, (.dmark)  
321f 32 bd fb			ld (debug_mark),a  
3222 3a 31 32			ld a, (.dmark+1)  
3225 32 be fb			ld (debug_mark+1),a  
3228 3a 32 32			ld a, (.dmark+2)  
322b 32 bf fb			ld (debug_mark+2),a  
322e 18 03			jr .pastdmark  
3230 ..			.dmark: db "GRT"  
3233 f1			.pastdmark: pop af  
3234			endm  
# End of macro DMARK
3234						CALLMONITOR 
3234 cd d3 13			call break_point_state  
3237				endm  
# End of macro CALLMONITOR
3237					endif 
3237					FORTH_DSP 
3237 cd ed 19			call macro_forth_dsp 
323a				endm 
# End of macro FORTH_DSP
323a					;FORTH_DSP_VALUE 
323a 7e					ld a,(hl)	; get type of value on TOS 
323b fe 02				cp DS_TYPE_INUM  
323d 28 00				jr z, .gt_inum 
323f			 
323f				if FORTH_ENABLE_FLOATMATH 
323f					jr .gt_done 
323f			 
323f				endif 
323f					 
323f			 
323f			.gt_inum: 
323f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
323f cd 08 1a			call macro_dsp_valuehl 
3242				endm 
# End of macro FORTH_DSP_VALUEHL
3242			 
3242 e5					push hl  ; u2 
3243			 
3243					; destroy value TOS 
3243			 
3243					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3243 cd a4 1a			call macro_forth_dsp_pop 
3246				endm 
# End of macro FORTH_DSP_POP
3246			 
3246			 
3246					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3246 cd 08 1a			call macro_dsp_valuehl 
3249				endm 
# End of macro FORTH_DSP_VALUEHL
3249			 
3249 e5					push hl    ; u1 
324a			 
324a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
324a cd a4 1a			call macro_forth_dsp_pop 
324d				endm 
# End of macro FORTH_DSP_POP
324d			 
324d			 
324d b7			 or a      ;clear carry flag 
324e 01 00 00		 ld bc, FORTH_FALSE 
3251 e1			  pop hl    ; u1 
3252 d1			  pop de    ; u2 
3253 ed 52		  sbc hl,de 
3255 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
3257			 
3257 01 01 00		 ld bc, FORTH_TRUE 
325a			.gtcont:  
325a c5					push bc 
325b e1					pop hl 
325c			 
325c					if DEBUG_FORTH_WORDS 
325c						DMARK "GT1" 
325c f5				push af  
325d 3a 71 32			ld a, (.dmark)  
3260 32 bd fb			ld (debug_mark),a  
3263 3a 72 32			ld a, (.dmark+1)  
3266 32 be fb			ld (debug_mark+1),a  
3269 3a 73 32			ld a, (.dmark+2)  
326c 32 bf fb			ld (debug_mark+2),a  
326f 18 03			jr .pastdmark  
3271 ..			.dmark: db "GT1"  
3274 f1			.pastdmark: pop af  
3275			endm  
# End of macro DMARK
3275						CALLMONITOR 
3275 cd d3 13			call break_point_state  
3278				endm  
# End of macro CALLMONITOR
3278					endif 
3278 cd 6d 19				call forth_push_numhl 
327b			 
327b					NEXTW 
327b c3 5e 1b			jp macro_next 
327e				endm 
# End of macro NEXTW
327e			.EQUAL: 
327e				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
327e 31				db WORD_SYS_CORE+29             
327f e9 32			dw .ENDLOGIC            
3281 02				db 1 + 1 
3282 .. 00			db "=",0              
3284				endm 
# End of macro CWHEAD
3284			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3284				; TODO add floating point number detection 
3284					if DEBUG_FORTH_WORDS_KEY 
3284						DMARK "EQ." 
3284 f5				push af  
3285 3a 99 32			ld a, (.dmark)  
3288 32 bd fb			ld (debug_mark),a  
328b 3a 9a 32			ld a, (.dmark+1)  
328e 32 be fb			ld (debug_mark+1),a  
3291 3a 9b 32			ld a, (.dmark+2)  
3294 32 bf fb			ld (debug_mark+2),a  
3297 18 03			jr .pastdmark  
3299 ..			.dmark: db "EQ."  
329c f1			.pastdmark: pop af  
329d			endm  
# End of macro DMARK
329d						CALLMONITOR 
329d cd d3 13			call break_point_state  
32a0				endm  
# End of macro CALLMONITOR
32a0					endif 
32a0					FORTH_DSP 
32a0 cd ed 19			call macro_forth_dsp 
32a3				endm 
# End of macro FORTH_DSP
32a3					;v5 FORTH_DSP_VALUE 
32a3 7e					ld a,(hl)	; get type of value on TOS 
32a4 fe 02				cp DS_TYPE_INUM  
32a6 28 00				jr z, .eq_inum 
32a8			 
32a8				if FORTH_ENABLE_FLOATMATH 
32a8					jr .eq_done 
32a8			 
32a8				endif 
32a8					 
32a8			 
32a8			.eq_inum: 
32a8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
32a8 cd 08 1a			call macro_dsp_valuehl 
32ab				endm 
# End of macro FORTH_DSP_VALUEHL
32ab			 
32ab e5					push hl 
32ac			 
32ac					; destroy value TOS 
32ac			 
32ac					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
32ac cd a4 1a			call macro_forth_dsp_pop 
32af				endm 
# End of macro FORTH_DSP_POP
32af			 
32af			 
32af					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
32af cd 08 1a			call macro_dsp_valuehl 
32b2				endm 
# End of macro FORTH_DSP_VALUEHL
32b2			 
32b2					; one value on hl get other one back 
32b2			 
32b2 e5					push hl 
32b3			 
32b3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
32b3 cd a4 1a			call macro_forth_dsp_pop 
32b6				endm 
# End of macro FORTH_DSP_POP
32b6			 
32b6 0e 00				ld c, FORTH_FALSE 
32b8			 
32b8 e1					pop hl 
32b9 d1					pop de 
32ba			 
32ba 7b					ld a, e 
32bb bd					cp l 
32bc			 
32bc 20 06				jr nz, .eq_done 
32be			 
32be 7a					ld a, d 
32bf bc					cp h 
32c0			 
32c0 20 02				jr nz, .eq_done 
32c2			 
32c2 0e 01				ld c, FORTH_TRUE 
32c4					 
32c4			 
32c4			 
32c4			.eq_done: 
32c4			 
32c4					; TODO push value back onto stack for another op etc 
32c4			 
32c4 26 00				ld h, 0 
32c6 69					ld l, c 
32c7					if DEBUG_FORTH_WORDS 
32c7						DMARK "EQ1" 
32c7 f5				push af  
32c8 3a dc 32			ld a, (.dmark)  
32cb 32 bd fb			ld (debug_mark),a  
32ce 3a dd 32			ld a, (.dmark+1)  
32d1 32 be fb			ld (debug_mark+1),a  
32d4 3a de 32			ld a, (.dmark+2)  
32d7 32 bf fb			ld (debug_mark+2),a  
32da 18 03			jr .pastdmark  
32dc ..			.dmark: db "EQ1"  
32df f1			.pastdmark: pop af  
32e0			endm  
# End of macro DMARK
32e0						CALLMONITOR 
32e0 cd d3 13			call break_point_state  
32e3				endm  
# End of macro CALLMONITOR
32e3					endif 
32e3 cd 6d 19				call forth_push_numhl 
32e6			 
32e6					NEXTW 
32e6 c3 5e 1b			jp macro_next 
32e9				endm 
# End of macro NEXTW
32e9			 
32e9			 
32e9			.ENDLOGIC: 
32e9			; eof 
32e9			 
32e9			 
# End of file forth_words_logic.asm
32e9			include "forth_words_maths.asm" 
32e9			 
32e9			; | ## Maths Words 
32e9			 
32e9			.PLUS:	 
32e9				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
32e9 15				db WORD_SYS_CORE+1             
32ea 2b 33			dw .NEG            
32ec 02				db 1 + 1 
32ed .. 00			db "+",0              
32ef				endm 
# End of macro CWHEAD
32ef			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
32ef					if DEBUG_FORTH_WORDS_KEY 
32ef						DMARK "PLU" 
32ef f5				push af  
32f0 3a 04 33			ld a, (.dmark)  
32f3 32 bd fb			ld (debug_mark),a  
32f6 3a 05 33			ld a, (.dmark+1)  
32f9 32 be fb			ld (debug_mark+1),a  
32fc 3a 06 33			ld a, (.dmark+2)  
32ff 32 bf fb			ld (debug_mark+2),a  
3302 18 03			jr .pastdmark  
3304 ..			.dmark: db "PLU"  
3307 f1			.pastdmark: pop af  
3308			endm  
# End of macro DMARK
3308						CALLMONITOR 
3308 cd d3 13			call break_point_state  
330b				endm  
# End of macro CALLMONITOR
330b					endif 
330b					; add top two values and push back result 
330b			 
330b					;for v5 FORTH_DSP_VALUE 
330b					FORTH_DSP 
330b cd ed 19			call macro_forth_dsp 
330e				endm 
# End of macro FORTH_DSP
330e 7e					ld a,(hl)	; get type of value on TOS 
330f fe 02				cp DS_TYPE_INUM  
3311 28 03				jr z, .dot_inum 
3313			 
3313					NEXTW 
3313 c3 5e 1b			jp macro_next 
3316				endm 
# End of macro NEXTW
3316			 
3316			; float maths 
3316			 
3316				if FORTH_ENABLE_FLOATMATH 
3316						inc hl      ; now at start of numeric as string 
3316			 
3316					if DEBUG_FORTH_MATHS 
3316						DMARK "ADD" 
3316				CALLMONITOR 
3316					endif 
3316			 
3316					;ld ix, hl 
3316					call CON 
3316			 
3316			 
3316					push hl 
3316					 
3316					 
3316			 
3316						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
3316			 
3316					; get next number 
3316			 
3316						FORTH_DSP_VALUE 
3316			 
3316						inc hl      ; now at start of numeric as string 
3316			 
3316					;ld ix, hl 
3316					call CON 
3316			 
3316					push hl 
3316			 
3316			 
3316						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3316			 
3316						; TODO do add 
3316			 
3316						call IADD 
3316			 
3316						; TODO get result back as ascii 
3316			 
3316						; TODO push result  
3316			 
3316			 
3316			 
3316						jr .dot_done 
3316				endif 
3316			 
3316			.dot_inum: 
3316			 
3316			 
3316					if DEBUG_FORTH_DOT 
3316						DMARK "+IT" 
3316				CALLMONITOR 
3316					endif 
3316			 
3316					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3316 cd 08 1a			call macro_dsp_valuehl 
3319				endm 
# End of macro FORTH_DSP_VALUEHL
3319			 
3319				; TODO add floating point number detection 
3319			 
3319 e5					push hl 
331a			 
331a					; destroy value TOS 
331a			 
331a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
331a cd a4 1a			call macro_forth_dsp_pop 
331d				endm 
# End of macro FORTH_DSP_POP
331d			 
331d			 
331d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
331d cd 08 1a			call macro_dsp_valuehl 
3320				endm 
# End of macro FORTH_DSP_VALUEHL
3320			 
3320					; one value on hl get other one back 
3320			 
3320 d1					pop de 
3321			 
3321					; do the add 
3321			 
3321 19					add hl,de 
3322			 
3322					; save it 
3322			 
3322			;		push hl	 
3322			 
3322					; 
3322			 
3322					; destroy value TOS 
3322			 
3322					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3322 cd a4 1a			call macro_forth_dsp_pop 
3325				endm 
# End of macro FORTH_DSP_POP
3325			 
3325					; TODO push value back onto stack for another op etc 
3325			 
3325			;		pop hl 
3325			 
3325			.dot_done: 
3325 cd 6d 19				call forth_push_numhl 
3328			 
3328					NEXTW 
3328 c3 5e 1b			jp macro_next 
332b				endm 
# End of macro NEXTW
332b			.NEG: 
332b			 
332b				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
332b 17				db WORD_SYS_CORE+3             
332c 6e 33			dw .DIV            
332e 02				db 1 + 1 
332f .. 00			db "-",0              
3331				endm 
# End of macro CWHEAD
3331			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3331					if DEBUG_FORTH_WORDS_KEY 
3331						DMARK "SUB" 
3331 f5				push af  
3332 3a 46 33			ld a, (.dmark)  
3335 32 bd fb			ld (debug_mark),a  
3338 3a 47 33			ld a, (.dmark+1)  
333b 32 be fb			ld (debug_mark+1),a  
333e 3a 48 33			ld a, (.dmark+2)  
3341 32 bf fb			ld (debug_mark+2),a  
3344 18 03			jr .pastdmark  
3346 ..			.dmark: db "SUB"  
3349 f1			.pastdmark: pop af  
334a			endm  
# End of macro DMARK
334a						CALLMONITOR 
334a cd d3 13			call break_point_state  
334d				endm  
# End of macro CALLMONITOR
334d					endif 
334d			 
334d			 
334d				; TODO add floating point number detection 
334d					; v5 FORTH_DSP_VALUE 
334d					FORTH_DSP 
334d cd ed 19			call macro_forth_dsp 
3350				endm 
# End of macro FORTH_DSP
3350 7e					ld a,(hl)	; get type of value on TOS 
3351 fe 02				cp DS_TYPE_INUM  
3353 28 03				jr z, .neg_inum 
3355			 
3355					NEXTW 
3355 c3 5e 1b			jp macro_next 
3358				endm 
# End of macro NEXTW
3358			 
3358			; float maths 
3358			 
3358				if FORTH_ENABLE_FLOATMATH 
3358					jr .neg_done 
3358			 
3358				endif 
3358					 
3358			 
3358			.neg_inum: 
3358					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3358 cd 08 1a			call macro_dsp_valuehl 
335b				endm 
# End of macro FORTH_DSP_VALUEHL
335b			 
335b e5					push hl 
335c			 
335c					; destroy value TOS 
335c			 
335c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
335c cd a4 1a			call macro_forth_dsp_pop 
335f				endm 
# End of macro FORTH_DSP_POP
335f			 
335f			 
335f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
335f cd 08 1a			call macro_dsp_valuehl 
3362				endm 
# End of macro FORTH_DSP_VALUEHL
3362			 
3362					; one value on hl get other one back 
3362			 
3362 d1					pop de 
3363			 
3363					; do the sub 
3363			;		ex de, hl 
3363			 
3363 ed 52				sbc hl,de 
3365			 
3365					; save it 
3365			 
3365			;		push hl	 
3365			 
3365					; 
3365			 
3365					; destroy value TOS 
3365			 
3365					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3365 cd a4 1a			call macro_forth_dsp_pop 
3368				endm 
# End of macro FORTH_DSP_POP
3368			 
3368					; TODO push value back onto stack for another op etc 
3368			 
3368			;		pop hl 
3368			 
3368 cd 6d 19				call forth_push_numhl 
336b			.neg_done: 
336b			 
336b					NEXTW 
336b c3 5e 1b			jp macro_next 
336e				endm 
# End of macro NEXTW
336e			.DIV: 
336e				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
336e 18				db WORD_SYS_CORE+4             
336f bb 33			dw .MUL            
3371 02				db 1 + 1 
3372 .. 00			db "/",0              
3374				endm 
# End of macro CWHEAD
3374			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3374					if DEBUG_FORTH_WORDS_KEY 
3374						DMARK "DIV" 
3374 f5				push af  
3375 3a 89 33			ld a, (.dmark)  
3378 32 bd fb			ld (debug_mark),a  
337b 3a 8a 33			ld a, (.dmark+1)  
337e 32 be fb			ld (debug_mark+1),a  
3381 3a 8b 33			ld a, (.dmark+2)  
3384 32 bf fb			ld (debug_mark+2),a  
3387 18 03			jr .pastdmark  
3389 ..			.dmark: db "DIV"  
338c f1			.pastdmark: pop af  
338d			endm  
# End of macro DMARK
338d						CALLMONITOR 
338d cd d3 13			call break_point_state  
3390				endm  
# End of macro CALLMONITOR
3390					endif 
3390				; TODO add floating point number detection 
3390					; v5 FORTH_DSP_VALUE 
3390					FORTH_DSP 
3390 cd ed 19			call macro_forth_dsp 
3393				endm 
# End of macro FORTH_DSP
3393 7e					ld a,(hl)	; get type of value on TOS 
3394 fe 02				cp DS_TYPE_INUM  
3396 28 03				jr z, .div_inum 
3398			 
3398				if FORTH_ENABLE_FLOATMATH 
3398					jr .div_done 
3398			 
3398				endif 
3398					NEXTW 
3398 c3 5e 1b			jp macro_next 
339b				endm 
# End of macro NEXTW
339b			.div_inum: 
339b			 
339b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
339b cd 08 1a			call macro_dsp_valuehl 
339e				endm 
# End of macro FORTH_DSP_VALUEHL
339e			 
339e e5					push hl    ; to go to bc 
339f			 
339f					; destroy value TOS 
339f			 
339f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
339f cd a4 1a			call macro_forth_dsp_pop 
33a2				endm 
# End of macro FORTH_DSP_POP
33a2			 
33a2			 
33a2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
33a2 cd 08 1a			call macro_dsp_valuehl 
33a5				endm 
# End of macro FORTH_DSP_VALUEHL
33a5			 
33a5					; hl to go to de 
33a5			 
33a5 e5					push hl 
33a6			 
33a6 c1					pop bc 
33a7 d1					pop de		 
33a8			 
33a8			 
33a8					if DEBUG_FORTH_MATHS 
33a8						DMARK "DIV" 
33a8				CALLMONITOR 
33a8					endif 
33a8					; one value on hl but move to a get other one back 
33a8			 
33a8			        
33a8 cd 6c 0b			call Div16 
33ab			 
33ab			;	push af	 
33ab e5				push hl 
33ac c5				push bc 
33ad			 
33ad					if DEBUG_FORTH_MATHS 
33ad						DMARK "DI1" 
33ad				CALLMONITOR 
33ad					endif 
33ad			 
33ad					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
33ad cd a4 1a			call macro_forth_dsp_pop 
33b0				endm 
# End of macro FORTH_DSP_POP
33b0			 
33b0			 
33b0			 
33b0 e1					pop hl    ; result 
33b1			 
33b1 cd 6d 19				call forth_push_numhl 
33b4			 
33b4 e1					pop hl    ; reminder 
33b5			;		ld h,0 
33b5			;		ld l,d 
33b5			 
33b5 cd 6d 19				call forth_push_numhl 
33b8			.div_done: 
33b8					NEXTW 
33b8 c3 5e 1b			jp macro_next 
33bb				endm 
# End of macro NEXTW
33bb			.MUL: 
33bb				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
33bb 19				db WORD_SYS_CORE+5             
33bc 00 34			dw .MIN            
33be 02				db 1 + 1 
33bf .. 00			db "*",0              
33c1				endm 
# End of macro CWHEAD
33c1			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
33c1				; TODO add floating point number detection 
33c1					if DEBUG_FORTH_WORDS_KEY 
33c1						DMARK "MUL" 
33c1 f5				push af  
33c2 3a d6 33			ld a, (.dmark)  
33c5 32 bd fb			ld (debug_mark),a  
33c8 3a d7 33			ld a, (.dmark+1)  
33cb 32 be fb			ld (debug_mark+1),a  
33ce 3a d8 33			ld a, (.dmark+2)  
33d1 32 bf fb			ld (debug_mark+2),a  
33d4 18 03			jr .pastdmark  
33d6 ..			.dmark: db "MUL"  
33d9 f1			.pastdmark: pop af  
33da			endm  
# End of macro DMARK
33da						CALLMONITOR 
33da cd d3 13			call break_point_state  
33dd				endm  
# End of macro CALLMONITOR
33dd					endif 
33dd					FORTH_DSP 
33dd cd ed 19			call macro_forth_dsp 
33e0				endm 
# End of macro FORTH_DSP
33e0					; v5 FORTH_DSP_VALUE 
33e0 7e					ld a,(hl)	; get type of value on TOS 
33e1 fe 02				cp DS_TYPE_INUM  
33e3 28 03				jr z, .mul_inum 
33e5			 
33e5				if FORTH_ENABLE_FLOATMATH 
33e5					jr .mul_done 
33e5			 
33e5				endif 
33e5			 
33e5					NEXTW 
33e5 c3 5e 1b			jp macro_next 
33e8				endm 
# End of macro NEXTW
33e8			.mul_inum:	 
33e8			 
33e8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
33e8 cd 08 1a			call macro_dsp_valuehl 
33eb				endm 
# End of macro FORTH_DSP_VALUEHL
33eb			 
33eb e5					push hl 
33ec			 
33ec					; destroy value TOS 
33ec			 
33ec					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
33ec cd a4 1a			call macro_forth_dsp_pop 
33ef				endm 
# End of macro FORTH_DSP_POP
33ef			 
33ef			 
33ef					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
33ef cd 08 1a			call macro_dsp_valuehl 
33f2				endm 
# End of macro FORTH_DSP_VALUEHL
33f2			 
33f2					; one value on hl but move to a get other one back 
33f2			 
33f2 7d					ld a, l 
33f3			 
33f3 d1					pop de 
33f4			 
33f4					; do the mull 
33f4			;		ex de, hl 
33f4			 
33f4 cd 92 0b				call Mult16 
33f7					; save it 
33f7			 
33f7			;		push hl	 
33f7			 
33f7					; 
33f7			 
33f7					; destroy value TOS 
33f7			 
33f7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
33f7 cd a4 1a			call macro_forth_dsp_pop 
33fa				endm 
# End of macro FORTH_DSP_POP
33fa			 
33fa					; TODO push value back onto stack for another op etc 
33fa			 
33fa			;		pop hl 
33fa			 
33fa cd 6d 19				call forth_push_numhl 
33fd			 
33fd			.mul_done: 
33fd					NEXTW 
33fd c3 5e 1b			jp macro_next 
3400				endm 
# End of macro NEXTW
3400			 
3400			 
3400			 
3400			 
3400			.MIN: 
3400				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3400 49				db WORD_SYS_CORE+53             
3401 81 34			dw .MAX            
3403 04				db 3 + 1 
3404 .. 00			db "MIN",0              
3408				endm 
# End of macro CWHEAD
3408			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3408					if DEBUG_FORTH_WORDS_KEY 
3408						DMARK "MIN" 
3408 f5				push af  
3409 3a 1d 34			ld a, (.dmark)  
340c 32 bd fb			ld (debug_mark),a  
340f 3a 1e 34			ld a, (.dmark+1)  
3412 32 be fb			ld (debug_mark+1),a  
3415 3a 1f 34			ld a, (.dmark+2)  
3418 32 bf fb			ld (debug_mark+2),a  
341b 18 03			jr .pastdmark  
341d ..			.dmark: db "MIN"  
3420 f1			.pastdmark: pop af  
3421			endm  
# End of macro DMARK
3421						CALLMONITOR 
3421 cd d3 13			call break_point_state  
3424				endm  
# End of macro CALLMONITOR
3424					endif 
3424					; get u2 
3424			 
3424					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3424 cd 08 1a			call macro_dsp_valuehl 
3427				endm 
# End of macro FORTH_DSP_VALUEHL
3427			 
3427 e5					push hl   ; u2 
3428			 
3428					; destroy value TOS 
3428			 
3428					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3428 cd a4 1a			call macro_forth_dsp_pop 
342b				endm 
# End of macro FORTH_DSP_POP
342b			 
342b					; get u1 
342b			 
342b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
342b cd 08 1a			call macro_dsp_valuehl 
342e				endm 
# End of macro FORTH_DSP_VALUEHL
342e			 
342e e5					push hl  ; u1 
342f			 
342f					; destroy value TOS 
342f			 
342f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
342f cd a4 1a			call macro_forth_dsp_pop 
3432				endm 
# End of macro FORTH_DSP_POP
3432			 
3432 b7			 or a      ;clear carry flag 
3433 e1			  pop hl    ; u1 
3434 d1			  pop de    ; u2 
3435 e5				push hl   ; saved in case hl is lowest 
3436 ed 52		  sbc hl,de 
3438 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
343a			 
343a e1				pop hl 
343b					if DEBUG_FORTH_WORDS 
343b						DMARK "MIN" 
343b f5				push af  
343c 3a 50 34			ld a, (.dmark)  
343f 32 bd fb			ld (debug_mark),a  
3442 3a 51 34			ld a, (.dmark+1)  
3445 32 be fb			ld (debug_mark+1),a  
3448 3a 52 34			ld a, (.dmark+2)  
344b 32 bf fb			ld (debug_mark+2),a  
344e 18 03			jr .pastdmark  
3450 ..			.dmark: db "MIN"  
3453 f1			.pastdmark: pop af  
3454			endm  
# End of macro DMARK
3454						CALLMONITOR 
3454 cd d3 13			call break_point_state  
3457				endm  
# End of macro CALLMONITOR
3457					endif 
3457 cd 6d 19				call forth_push_numhl 
345a			 
345a				       NEXTW 
345a c3 5e 1b			jp macro_next 
345d				endm 
# End of macro NEXTW
345d			 
345d			.mincont:  
345d c1				pop bc   ; tidy up 
345e eb				ex de , hl  
345f					if DEBUG_FORTH_WORDS 
345f						DMARK "MI1" 
345f f5				push af  
3460 3a 74 34			ld a, (.dmark)  
3463 32 bd fb			ld (debug_mark),a  
3466 3a 75 34			ld a, (.dmark+1)  
3469 32 be fb			ld (debug_mark+1),a  
346c 3a 76 34			ld a, (.dmark+2)  
346f 32 bf fb			ld (debug_mark+2),a  
3472 18 03			jr .pastdmark  
3474 ..			.dmark: db "MI1"  
3477 f1			.pastdmark: pop af  
3478			endm  
# End of macro DMARK
3478						CALLMONITOR 
3478 cd d3 13			call break_point_state  
347b				endm  
# End of macro CALLMONITOR
347b					endif 
347b cd 6d 19				call forth_push_numhl 
347e			 
347e				       NEXTW 
347e c3 5e 1b			jp macro_next 
3481				endm 
# End of macro NEXTW
3481			.MAX: 
3481				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3481 4a				db WORD_SYS_CORE+54             
3482 02 35			dw .RND16            
3484 04				db 3 + 1 
3485 .. 00			db "MAX",0              
3489				endm 
# End of macro CWHEAD
3489			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3489					if DEBUG_FORTH_WORDS_KEY 
3489						DMARK "MAX" 
3489 f5				push af  
348a 3a 9e 34			ld a, (.dmark)  
348d 32 bd fb			ld (debug_mark),a  
3490 3a 9f 34			ld a, (.dmark+1)  
3493 32 be fb			ld (debug_mark+1),a  
3496 3a a0 34			ld a, (.dmark+2)  
3499 32 bf fb			ld (debug_mark+2),a  
349c 18 03			jr .pastdmark  
349e ..			.dmark: db "MAX"  
34a1 f1			.pastdmark: pop af  
34a2			endm  
# End of macro DMARK
34a2						CALLMONITOR 
34a2 cd d3 13			call break_point_state  
34a5				endm  
# End of macro CALLMONITOR
34a5					endif 
34a5					; get u2 
34a5			 
34a5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
34a5 cd 08 1a			call macro_dsp_valuehl 
34a8				endm 
# End of macro FORTH_DSP_VALUEHL
34a8			 
34a8 e5					push hl   ; u2 
34a9			 
34a9					; destroy value TOS 
34a9			 
34a9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34a9 cd a4 1a			call macro_forth_dsp_pop 
34ac				endm 
# End of macro FORTH_DSP_POP
34ac			 
34ac					; get u1 
34ac			 
34ac					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
34ac cd 08 1a			call macro_dsp_valuehl 
34af				endm 
# End of macro FORTH_DSP_VALUEHL
34af			 
34af e5					push hl  ; u1 
34b0			 
34b0					; destroy value TOS 
34b0			 
34b0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34b0 cd a4 1a			call macro_forth_dsp_pop 
34b3				endm 
# End of macro FORTH_DSP_POP
34b3			 
34b3 b7			 or a      ;clear carry flag 
34b4 e1			  pop hl    ; u1 
34b5 d1			  pop de    ; u2 
34b6 e5				push hl   ; saved in case hl is lowest 
34b7 ed 52		  sbc hl,de 
34b9 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
34bb			 
34bb e1				pop hl 
34bc					if DEBUG_FORTH_WORDS 
34bc						DMARK "MAX" 
34bc f5				push af  
34bd 3a d1 34			ld a, (.dmark)  
34c0 32 bd fb			ld (debug_mark),a  
34c3 3a d2 34			ld a, (.dmark+1)  
34c6 32 be fb			ld (debug_mark+1),a  
34c9 3a d3 34			ld a, (.dmark+2)  
34cc 32 bf fb			ld (debug_mark+2),a  
34cf 18 03			jr .pastdmark  
34d1 ..			.dmark: db "MAX"  
34d4 f1			.pastdmark: pop af  
34d5			endm  
# End of macro DMARK
34d5						CALLMONITOR 
34d5 cd d3 13			call break_point_state  
34d8				endm  
# End of macro CALLMONITOR
34d8					endif 
34d8 cd 6d 19				call forth_push_numhl 
34db			 
34db				       NEXTW 
34db c3 5e 1b			jp macro_next 
34de				endm 
# End of macro NEXTW
34de			 
34de			.maxcont:  
34de c1				pop bc   ; tidy up 
34df eb				ex de , hl  
34e0					if DEBUG_FORTH_WORDS 
34e0						DMARK "MA1" 
34e0 f5				push af  
34e1 3a f5 34			ld a, (.dmark)  
34e4 32 bd fb			ld (debug_mark),a  
34e7 3a f6 34			ld a, (.dmark+1)  
34ea 32 be fb			ld (debug_mark+1),a  
34ed 3a f7 34			ld a, (.dmark+2)  
34f0 32 bf fb			ld (debug_mark+2),a  
34f3 18 03			jr .pastdmark  
34f5 ..			.dmark: db "MA1"  
34f8 f1			.pastdmark: pop af  
34f9			endm  
# End of macro DMARK
34f9						CALLMONITOR 
34f9 cd d3 13			call break_point_state  
34fc				endm  
# End of macro CALLMONITOR
34fc					endif 
34fc cd 6d 19				call forth_push_numhl 
34ff				       NEXTW 
34ff c3 5e 1b			jp macro_next 
3502				endm 
# End of macro NEXTW
3502			 
3502			.RND16: 
3502				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3502 4e				db WORD_SYS_CORE+58             
3503 31 35			dw .RND8            
3505 06				db 5 + 1 
3506 .. 00			db "RND16",0              
350c				endm 
# End of macro CWHEAD
350c			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
350c					if DEBUG_FORTH_WORDS_KEY 
350c						DMARK "R16" 
350c f5				push af  
350d 3a 21 35			ld a, (.dmark)  
3510 32 bd fb			ld (debug_mark),a  
3513 3a 22 35			ld a, (.dmark+1)  
3516 32 be fb			ld (debug_mark+1),a  
3519 3a 23 35			ld a, (.dmark+2)  
351c 32 bf fb			ld (debug_mark+2),a  
351f 18 03			jr .pastdmark  
3521 ..			.dmark: db "R16"  
3524 f1			.pastdmark: pop af  
3525			endm  
# End of macro DMARK
3525						CALLMONITOR 
3525 cd d3 13			call break_point_state  
3528				endm  
# End of macro CALLMONITOR
3528					endif 
3528 cd 36 0b				call prng16  
352b cd 6d 19				call forth_push_numhl 
352e				       NEXTW 
352e c3 5e 1b			jp macro_next 
3531				endm 
# End of macro NEXTW
3531			.RND8: 
3531				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3531 60				db WORD_SYS_CORE+76             
3532 66 35			dw .RND            
3534 05				db 4 + 1 
3535 .. 00			db "RND8",0              
353a				endm 
# End of macro CWHEAD
353a			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
353a					if DEBUG_FORTH_WORDS_KEY 
353a						DMARK "RN8" 
353a f5				push af  
353b 3a 4f 35			ld a, (.dmark)  
353e 32 bd fb			ld (debug_mark),a  
3541 3a 50 35			ld a, (.dmark+1)  
3544 32 be fb			ld (debug_mark+1),a  
3547 3a 51 35			ld a, (.dmark+2)  
354a 32 bf fb			ld (debug_mark+2),a  
354d 18 03			jr .pastdmark  
354f ..			.dmark: db "RN8"  
3552 f1			.pastdmark: pop af  
3553			endm  
# End of macro DMARK
3553						CALLMONITOR 
3553 cd d3 13			call break_point_state  
3556				endm  
# End of macro CALLMONITOR
3556					endif 
3556 2a 3e fa				ld hl,(xrandc) 
3559 23					inc hl 
355a cd 50 0b				call xrnd 
355d 6f					ld l,a	 
355e 26 00				ld h,0 
3560 cd 6d 19				call forth_push_numhl 
3563				       NEXTW 
3563 c3 5e 1b			jp macro_next 
3566				endm 
# End of macro NEXTW
3566			.RND: 
3566				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3566 60				db WORD_SYS_CORE+76             
3567 6c 36			dw .ENDMATHS            
3569 04				db 3 + 1 
356a .. 00			db "RND",0              
356e				endm 
# End of macro CWHEAD
356e			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
356e			 
356e					if DEBUG_FORTH_WORDS_KEY 
356e						DMARK "RND" 
356e f5				push af  
356f 3a 83 35			ld a, (.dmark)  
3572 32 bd fb			ld (debug_mark),a  
3575 3a 84 35			ld a, (.dmark+1)  
3578 32 be fb			ld (debug_mark+1),a  
357b 3a 85 35			ld a, (.dmark+2)  
357e 32 bf fb			ld (debug_mark+2),a  
3581 18 03			jr .pastdmark  
3583 ..			.dmark: db "RND"  
3586 f1			.pastdmark: pop af  
3587			endm  
# End of macro DMARK
3587						CALLMONITOR 
3587 cd d3 13			call break_point_state  
358a				endm  
# End of macro CALLMONITOR
358a					endif 
358a					 
358a					FORTH_DSP_VALUEHL    ; upper range 
358a cd 08 1a			call macro_dsp_valuehl 
358d				endm 
# End of macro FORTH_DSP_VALUEHL
358d			 
358d 22 42 fa				ld (LFSRSeed), hl	 
3590			 
3590					if DEBUG_FORTH_WORDS 
3590						DMARK "RN1" 
3590 f5				push af  
3591 3a a5 35			ld a, (.dmark)  
3594 32 bd fb			ld (debug_mark),a  
3597 3a a6 35			ld a, (.dmark+1)  
359a 32 be fb			ld (debug_mark+1),a  
359d 3a a7 35			ld a, (.dmark+2)  
35a0 32 bf fb			ld (debug_mark+2),a  
35a3 18 03			jr .pastdmark  
35a5 ..			.dmark: db "RN1"  
35a8 f1			.pastdmark: pop af  
35a9			endm  
# End of macro DMARK
35a9						CALLMONITOR 
35a9 cd d3 13			call break_point_state  
35ac				endm  
# End of macro CALLMONITOR
35ac					endif 
35ac					FORTH_DSP_POP 
35ac cd a4 1a			call macro_forth_dsp_pop 
35af				endm 
# End of macro FORTH_DSP_POP
35af			 
35af					FORTH_DSP_VALUEHL    ; low range 
35af cd 08 1a			call macro_dsp_valuehl 
35b2				endm 
# End of macro FORTH_DSP_VALUEHL
35b2			 
35b2					if DEBUG_FORTH_WORDS 
35b2						DMARK "RN2" 
35b2 f5				push af  
35b3 3a c7 35			ld a, (.dmark)  
35b6 32 bd fb			ld (debug_mark),a  
35b9 3a c8 35			ld a, (.dmark+1)  
35bc 32 be fb			ld (debug_mark+1),a  
35bf 3a c9 35			ld a, (.dmark+2)  
35c2 32 bf fb			ld (debug_mark+2),a  
35c5 18 03			jr .pastdmark  
35c7 ..			.dmark: db "RN2"  
35ca f1			.pastdmark: pop af  
35cb			endm  
# End of macro DMARK
35cb						CALLMONITOR 
35cb cd d3 13			call break_point_state  
35ce				endm  
# End of macro CALLMONITOR
35ce					endif 
35ce 22 44 fa				ld (LFSRSeed+2), hl 
35d1			 
35d1					FORTH_DSP_POP 
35d1 cd a4 1a			call macro_forth_dsp_pop 
35d4				endm 
# End of macro FORTH_DSP_POP
35d4			 
35d4 e5					push hl 
35d5			 
35d5 e1			.inrange:	pop hl 
35d6 cd 36 0b				call prng16  
35d9					if DEBUG_FORTH_WORDS 
35d9						DMARK "RN3" 
35d9 f5				push af  
35da 3a ee 35			ld a, (.dmark)  
35dd 32 bd fb			ld (debug_mark),a  
35e0 3a ef 35			ld a, (.dmark+1)  
35e3 32 be fb			ld (debug_mark+1),a  
35e6 3a f0 35			ld a, (.dmark+2)  
35e9 32 bf fb			ld (debug_mark+2),a  
35ec 18 03			jr .pastdmark  
35ee ..			.dmark: db "RN3"  
35f1 f1			.pastdmark: pop af  
35f2			endm  
# End of macro DMARK
35f2						CALLMONITOR 
35f2 cd d3 13			call break_point_state  
35f5				endm  
# End of macro CALLMONITOR
35f5					endif 
35f5					 
35f5					; if the range is 8bit knock out the high byte 
35f5			 
35f5 ed 5b 42 fa			ld de, (LFSRSeed)     ; check high level 
35f9			 
35f9 3e 00				ld a, 0 
35fb ba					cp d  
35fc 20 1e				jr nz, .hirange 
35fe 26 00				ld h, 0   ; knock it down to 8bit 
3600			 
3600					if DEBUG_FORTH_WORDS 
3600						DMARK "RNk" 
3600 f5				push af  
3601 3a 15 36			ld a, (.dmark)  
3604 32 bd fb			ld (debug_mark),a  
3607 3a 16 36			ld a, (.dmark+1)  
360a 32 be fb			ld (debug_mark+1),a  
360d 3a 17 36			ld a, (.dmark+2)  
3610 32 bf fb			ld (debug_mark+2),a  
3613 18 03			jr .pastdmark  
3615 ..			.dmark: db "RNk"  
3618 f1			.pastdmark: pop af  
3619			endm  
# End of macro DMARK
3619						CALLMONITOR 
3619 cd d3 13			call break_point_state  
361c				endm  
# End of macro CALLMONITOR
361c					endif 
361c			.hirange:   
361c e5					push hl  
361d b7					or a  
361e ed 52		                sbc hl, de 
3620			 
3620					;call cmp16 
3620			 
3620 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3622 e1					pop hl 
3623 e5					push hl 
3624			 
3624					if DEBUG_FORTH_WORDS 
3624						DMARK "RN4" 
3624 f5				push af  
3625 3a 39 36			ld a, (.dmark)  
3628 32 bd fb			ld (debug_mark),a  
362b 3a 3a 36			ld a, (.dmark+1)  
362e 32 be fb			ld (debug_mark+1),a  
3631 3a 3b 36			ld a, (.dmark+2)  
3634 32 bf fb			ld (debug_mark+2),a  
3637 18 03			jr .pastdmark  
3639 ..			.dmark: db "RN4"  
363c f1			.pastdmark: pop af  
363d			endm  
# End of macro DMARK
363d						CALLMONITOR 
363d cd d3 13			call break_point_state  
3640				endm  
# End of macro CALLMONITOR
3640					endif 
3640 ed 5b 44 fa			ld de, (LFSRSeed+2)   ; check low range 
3644					;call cmp16 
3644				 
3644 b7					or a  
3645 ed 52		                sbc hl, de 
3647 38 8c				jr c, .inrange 
3649			 
3649 e1					pop hl 
364a					 
364a					if DEBUG_FORTH_WORDS 
364a						DMARK "RNd" 
364a f5				push af  
364b 3a 5f 36			ld a, (.dmark)  
364e 32 bd fb			ld (debug_mark),a  
3651 3a 60 36			ld a, (.dmark+1)  
3654 32 be fb			ld (debug_mark+1),a  
3657 3a 61 36			ld a, (.dmark+2)  
365a 32 bf fb			ld (debug_mark+2),a  
365d 18 03			jr .pastdmark  
365f ..			.dmark: db "RNd"  
3662 f1			.pastdmark: pop af  
3663			endm  
# End of macro DMARK
3663						CALLMONITOR 
3663 cd d3 13			call break_point_state  
3666				endm  
# End of macro CALLMONITOR
3666					endif 
3666			 
3666			 
3666 cd 6d 19				call forth_push_numhl 
3669				       NEXTW 
3669 c3 5e 1b			jp macro_next 
366c				endm 
# End of macro NEXTW
366c			 
366c			.ENDMATHS: 
366c			 
366c			; eof 
366c			 
# End of file forth_words_maths.asm
366c			include "forth_words_display.asm" 
366c			 
366c			; | ## Display Words 
366c			 
366c			.ATP: 
366c				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
366c 62				db WORD_SYS_CORE+78             
366d e3 36			dw .FB            
366f 04				db 3 + 1 
3670 .. 00			db "AT?",0              
3674				endm 
# End of macro CWHEAD
3674			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3674					if DEBUG_FORTH_WORDS_KEY 
3674						DMARK "AT?" 
3674 f5				push af  
3675 3a 89 36			ld a, (.dmark)  
3678 32 bd fb			ld (debug_mark),a  
367b 3a 8a 36			ld a, (.dmark+1)  
367e 32 be fb			ld (debug_mark+1),a  
3681 3a 8b 36			ld a, (.dmark+2)  
3684 32 bf fb			ld (debug_mark+2),a  
3687 18 03			jr .pastdmark  
3689 ..			.dmark: db "AT?"  
368c f1			.pastdmark: pop af  
368d			endm  
# End of macro DMARK
368d						CALLMONITOR 
368d cd d3 13			call break_point_state  
3690				endm  
# End of macro CALLMONITOR
3690					endif 
3690 3a e1 f9				ld a, (f_cursor_ptr) 
3693			 
3693			if DEBUG_FORTH_WORDS 
3693				DMARK "AT?" 
3693 f5				push af  
3694 3a a8 36			ld a, (.dmark)  
3697 32 bd fb			ld (debug_mark),a  
369a 3a a9 36			ld a, (.dmark+1)  
369d 32 be fb			ld (debug_mark+1),a  
36a0 3a aa 36			ld a, (.dmark+2)  
36a3 32 bf fb			ld (debug_mark+2),a  
36a6 18 03			jr .pastdmark  
36a8 ..			.dmark: db "AT?"  
36ab f1			.pastdmark: pop af  
36ac			endm  
# End of macro DMARK
36ac				CALLMONITOR 
36ac cd d3 13			call break_point_state  
36af				endm  
# End of macro CALLMONITOR
36af			endif	 
36af					; count the number of rows 
36af			 
36af 06 00				ld b, 0 
36b1 4f			.atpr:		ld c, a    ; save in case we go below zero 
36b2 d6 14				sub display_cols 
36b4 f2 ba 36				jp p, .atprunder 
36b7 04					inc b 
36b8 18 f7				jr .atpr 
36ba			.atprunder:	 
36ba			if DEBUG_FORTH_WORDS 
36ba				DMARK "A?2" 
36ba f5				push af  
36bb 3a cf 36			ld a, (.dmark)  
36be 32 bd fb			ld (debug_mark),a  
36c1 3a d0 36			ld a, (.dmark+1)  
36c4 32 be fb			ld (debug_mark+1),a  
36c7 3a d1 36			ld a, (.dmark+2)  
36ca 32 bf fb			ld (debug_mark+2),a  
36cd 18 03			jr .pastdmark  
36cf ..			.dmark: db "A?2"  
36d2 f1			.pastdmark: pop af  
36d3			endm  
# End of macro DMARK
36d3				CALLMONITOR 
36d3 cd d3 13			call break_point_state  
36d6				endm  
# End of macro CALLMONITOR
36d6			endif	 
36d6 26 00				ld h, 0 
36d8 69					ld l, c 
36d9 cd 6d 19				call forth_push_numhl 
36dc 68					ld l, b  
36dd cd 6d 19				call forth_push_numhl 
36e0			 
36e0			 
36e0				NEXTW 
36e0 c3 5e 1b			jp macro_next 
36e3				endm 
# End of macro NEXTW
36e3			 
36e3			.FB: 
36e3				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
36e3 1b				db WORD_SYS_CORE+7             
36e4 31 37			dw .EMIT            
36e6 03				db 2 + 1 
36e7 .. 00			db "FB",0              
36ea				endm 
# End of macro CWHEAD
36ea			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
36ea			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
36ea			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
36ea			; | | If automatic display is off then updates will not be shown until DRAW is used. 
36ea					if DEBUG_FORTH_WORDS_KEY 
36ea						DMARK "FB." 
36ea f5				push af  
36eb 3a ff 36			ld a, (.dmark)  
36ee 32 bd fb			ld (debug_mark),a  
36f1 3a 00 37			ld a, (.dmark+1)  
36f4 32 be fb			ld (debug_mark+1),a  
36f7 3a 01 37			ld a, (.dmark+2)  
36fa 32 bf fb			ld (debug_mark+2),a  
36fd 18 03			jr .pastdmark  
36ff ..			.dmark: db "FB."  
3702 f1			.pastdmark: pop af  
3703			endm  
# End of macro DMARK
3703						CALLMONITOR 
3703 cd d3 13			call break_point_state  
3706				endm  
# End of macro CALLMONITOR
3706					endif 
3706			 
3706					FORTH_DSP_VALUEHL 
3706 cd 08 1a			call macro_dsp_valuehl 
3709				endm 
# End of macro FORTH_DSP_VALUEHL
3709			 
3709 7d					ld a, l 
370a fe 01				cp 1 
370c 20 05				jr nz, .fbn1 
370e 21 02 fb				ld hl, display_fb1 
3711 18 15				jr .fbset 
3713 fe 02		.fbn1:		cp 2 
3715 20 05				jr nz, .fbn2 
3717 21 60 fa				ld hl, display_fb2 
371a 18 0c				jr .fbset 
371c fe 03		.fbn2:		cp 3 
371e 20 05				jr nz, .fbn3 
3720 21 b1 fa				ld hl, display_fb3 
3723 18 03				jr .fbset 
3725			.fbn3:		 ; if invalid number select first 
3725 21 02 fb				ld hl, display_fb1 
3728 22 5e fa		.fbset:		ld (display_fb_active), hl 
372b			 
372b					FORTH_DSP_POP 
372b cd a4 1a			call macro_forth_dsp_pop 
372e				endm 
# End of macro FORTH_DSP_POP
372e			 
372e					NEXTW 
372e c3 5e 1b			jp macro_next 
3731				endm 
# End of macro NEXTW
3731			 
3731			 
3731			.EMIT: 
3731				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3731 1b				db WORD_SYS_CORE+7             
3732 82 37			dw .DOTH            
3734 05				db 4 + 1 
3735 .. 00			db "EMIT",0              
373a				endm 
# End of macro CWHEAD
373a			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
373a					; get value off TOS and display it 
373a			 
373a					if DEBUG_FORTH_WORDS_KEY 
373a						DMARK "EMT" 
373a f5				push af  
373b 3a 4f 37			ld a, (.dmark)  
373e 32 bd fb			ld (debug_mark),a  
3741 3a 50 37			ld a, (.dmark+1)  
3744 32 be fb			ld (debug_mark+1),a  
3747 3a 51 37			ld a, (.dmark+2)  
374a 32 bf fb			ld (debug_mark+2),a  
374d 18 03			jr .pastdmark  
374f ..			.dmark: db "EMT"  
3752 f1			.pastdmark: pop af  
3753			endm  
# End of macro DMARK
3753						CALLMONITOR 
3753 cd d3 13			call break_point_state  
3756				endm  
# End of macro CALLMONITOR
3756					endif 
3756			 
3756					FORTH_DSP_VALUEHL 
3756 cd 08 1a			call macro_dsp_valuehl 
3759				endm 
# End of macro FORTH_DSP_VALUEHL
3759			 
3759 7d					ld a,l 
375a			 
375a					; TODO write to display 
375a			 
375a 32 b6 f1				ld (os_input), a 
375d 3e 00				ld a, 0 
375f 32 b7 f1				ld (os_input+1), a 
3762					 
3762 3a e1 f9				ld a, (f_cursor_ptr) 
3765 11 b6 f1				ld de, os_input 
3768 cd c9 0a				call str_at_display 
376b			 
376b			 
376b 3a bf f9				ld a,(cli_autodisplay) 
376e fe 00				cp 0 
3770 28 03				jr z, .enoupdate 
3772 cd d9 0a						call update_display 
3775					.enoupdate: 
3775			 
3775 3a e1 f9				ld a, (f_cursor_ptr) 
3778 3c					inc a 
3779 32 e1 f9				ld (f_cursor_ptr), a   ; save new pos 
377c			 
377c			 
377c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
377c cd a4 1a			call macro_forth_dsp_pop 
377f				endm 
# End of macro FORTH_DSP_POP
377f			  
377f			 
377f					NEXTW 
377f c3 5e 1b			jp macro_next 
3782				endm 
# End of macro NEXTW
3782			.DOTH: 
3782				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3782 1c				db WORD_SYS_CORE+8             
3783 b2 37			dw .DOTF            
3785 03				db 2 + 1 
3786 .. 00			db ".-",0              
3789				endm 
# End of macro CWHEAD
3789			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3789					; get value off TOS and display it 
3789					if DEBUG_FORTH_WORDS_KEY 
3789						DMARK "DTD" 
3789 f5				push af  
378a 3a 9e 37			ld a, (.dmark)  
378d 32 bd fb			ld (debug_mark),a  
3790 3a 9f 37			ld a, (.dmark+1)  
3793 32 be fb			ld (debug_mark+1),a  
3796 3a a0 37			ld a, (.dmark+2)  
3799 32 bf fb			ld (debug_mark+2),a  
379c 18 03			jr .pastdmark  
379e ..			.dmark: db "DTD"  
37a1 f1			.pastdmark: pop af  
37a2			endm  
# End of macro DMARK
37a2						CALLMONITOR 
37a2 cd d3 13			call break_point_state  
37a5				endm  
# End of macro CALLMONITOR
37a5					endif 
37a5 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
37a7 3e 00			ld a, 0 
37a9 32 c0 f9			ld (cli_mvdot), a 
37ac c3 09 38			jp .dotgo 
37af				NEXTW 
37af c3 5e 1b			jp macro_next 
37b2				endm 
# End of macro NEXTW
37b2			.DOTF: 
37b2				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
37b2 1c				db WORD_SYS_CORE+8             
37b3 e0 37			dw .DOT            
37b5 03				db 2 + 1 
37b6 .. 00			db ".>",0              
37b9				endm 
# End of macro CWHEAD
37b9			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
37b9					; get value off TOS and display it 
37b9			        ; TODO BUG adds extra spaces 
37b9			        ; TODO BUG handle numerics? 
37b9					if DEBUG_FORTH_WORDS_KEY 
37b9						DMARK "DTC" 
37b9 f5				push af  
37ba 3a ce 37			ld a, (.dmark)  
37bd 32 bd fb			ld (debug_mark),a  
37c0 3a cf 37			ld a, (.dmark+1)  
37c3 32 be fb			ld (debug_mark+1),a  
37c6 3a d0 37			ld a, (.dmark+2)  
37c9 32 bf fb			ld (debug_mark+2),a  
37cc 18 03			jr .pastdmark  
37ce ..			.dmark: db "DTC"  
37d1 f1			.pastdmark: pop af  
37d2			endm  
# End of macro DMARK
37d2						CALLMONITOR 
37d2 cd d3 13			call break_point_state  
37d5				endm  
# End of macro CALLMONITOR
37d5					endif 
37d5 3e 01			ld a, 1 
37d7 32 c0 f9			ld (cli_mvdot), a 
37da c3 09 38			jp .dotgo 
37dd				NEXTW 
37dd c3 5e 1b			jp macro_next 
37e0				endm 
# End of macro NEXTW
37e0			 
37e0			.DOT: 
37e0				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
37e0 1c				db WORD_SYS_CORE+8             
37e1 6c 38			dw .CLS            
37e3 02				db 1 + 1 
37e4 .. 00			db ".",0              
37e6				endm 
# End of macro CWHEAD
37e6			        ; | . ( u -- ) Display TOS | DONE 
37e6					; get value off TOS and display it 
37e6			 
37e6					if DEBUG_FORTH_WORDS_KEY 
37e6						DMARK "DOT" 
37e6 f5				push af  
37e7 3a fb 37			ld a, (.dmark)  
37ea 32 bd fb			ld (debug_mark),a  
37ed 3a fc 37			ld a, (.dmark+1)  
37f0 32 be fb			ld (debug_mark+1),a  
37f3 3a fd 37			ld a, (.dmark+2)  
37f6 32 bf fb			ld (debug_mark+2),a  
37f9 18 03			jr .pastdmark  
37fb ..			.dmark: db "DOT"  
37fe f1			.pastdmark: pop af  
37ff			endm  
# End of macro DMARK
37ff						CALLMONITOR 
37ff cd d3 13			call break_point_state  
3802				endm  
# End of macro CALLMONITOR
3802					endif 
3802 3e 00			ld a, 0 
3804 32 c0 f9			ld (cli_mvdot), a 
3807 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3809				 
3809			 
3809			.dotgo: 
3809			 
3809			; move up type to on stack for parserv5 
3809					FORTH_DSP 
3809 cd ed 19			call macro_forth_dsp 
380c				endm 
# End of macro FORTH_DSP
380c				;FORTH_DSP_VALUE  
380c			 
380c			if DEBUG_FORTH_DOT 
380c				DMARK "DOT" 
380c				CALLMONITOR 
380c			endif	 
380c			;		.print: 
380c			 
380c 7e				ld a,(hl)  ; work out what type of value is on the TOS 
380d 23				inc hl   ; position to the actual value 
380e fe 01			cp DS_TYPE_STR 
3810 20 06			jr nz, .dotnum1  
3812			 
3812			; display string 
3812				FORTH_DSP_VALUE  
3812 cd f1 19			call macro_forth_dsp_value 
3815				endm 
# End of macro FORTH_DSP_VALUE
3815 eb				ex de,hl 
3816 18 11			jr .dotwrite 
3818			 
3818			.dotnum1: 
3818 fe 02			cp DS_TYPE_INUM 
381a 20 0c			jr nz, .dotflot 
381c			 
381c			 
381c			; display number 
381c			 
381c			;	push hl 
381c			;	call clear_display 
381c			;	pop hl 
381c			 
381c 5e				ld e, (hl) 
381d 23				inc hl 
381e 56				ld d, (hl) 
381f 21 b8 ef			ld hl, scratch 
3822			if DEBUG_FORTH_DOT 
3822				DMARK "DT1" 
3822				CALLMONITOR 
3822			endif	 
3822			 
3822 cd 1c 10			call uitoa_16 
3825 eb				ex de,hl 
3826			 
3826			if DEBUG_FORTH_DOT 
3826				DMARK "DT2" 
3826				CALLMONITOR 
3826			endif	 
3826			 
3826			;	ld de, os_word_scratch 
3826 18 01			jr .dotwrite 
3828			 
3828 00			.dotflot:   nop 
3829			; TODO print floating point number 
3829			 
3829			.dotwrite:		 
3829			 
3829					; if c is set then set all '-' to spaces 
3829					; need to also take into account .>  
3829			 
3829 3e 01				ld a, 1 
382b b9					cp c 
382c 20 13				jr nz, .nodashswap 
382e			 
382e					; DE has the string to write, working with HL 
382e			 
382e 06 ff				ld b, 255 
3830 d5					push de 
3831 e1					pop hl 
3832			 
3832			if DEBUG_FORTH_DOT 
3832				DMARK "DT-" 
3832				CALLMONITOR 
3832			endif	 
3832 7e			.dashscan:	ld a, (hl) 
3833 fe 00				cp 0 
3835 28 0a				jr z, .nodashswap 
3837 fe 2d				cp '-' 
3839 20 03				jr nz, .dashskip 
383b 3e 20				ld a, ' ' 
383d 77					ld (hl), a 
383e 23			.dashskip:	inc hl 
383f			if DEBUG_FORTH_DOT 
383f				DMARK "D-2" 
383f				CALLMONITOR 
383f			endif	 
383f 10 f1				djnz .dashscan 
3841			 
3841			if DEBUG_FORTH_DOT 
3841				DMARK "D-1" 
3841				CALLMONITOR 
3841			endif	 
3841			 
3841			.nodashswap: 
3841			 
3841 e5					push hl   ; save string start in case we need to advance print 
3842			 
3842 3a e1 f9				ld a, (f_cursor_ptr) 
3845 cd c9 0a				call str_at_display 
3848 3a bf f9				ld a,(cli_autodisplay) 
384b fe 00				cp 0 
384d 28 03				jr z, .noupdate 
384f cd d9 0a						call update_display 
3852					.noupdate: 
3852			 
3852			 
3852					; see if we need to advance the print position 
3852			 
3852 e1					pop hl   ; get back string 
3853			 
3853 3a c0 f9				ld a, (cli_mvdot) 
3856			if DEBUG_FORTH_DOT 
3856					ld e,a 
3856				DMARK "D>1" 
3856				CALLMONITOR 
3856			endif	 
3856 fe 00				cp 0 
3858 28 0c				jr z, .noadv 
385a					; yes, lets advance the print position 
385a 3e 00				ld a, 0 
385c cd 78 10				call strlent 
385f 3a e1 f9				ld a, (f_cursor_ptr) 
3862 85					add a,l 
3863					;call addatohl 
3863					;ld a, l 
3863 32 e1 f9				ld (f_cursor_ptr), a   ; save new pos 
3866			 
3866			if DEBUG_FORTH_DOT 
3866				DMARK "D->" 
3866				CALLMONITOR 
3866			endif	 
3866			 
3866			.noadv:	 
3866			 
3866					if DEBUG_FORTH_DOT_WAIT 
3866							call next_page_prompt 
3866					endif	 
3866			; TODO this pop off the stack causes a crash. i dont know why 
3866			 
3866			 
3866			if DEBUG_FORTH_DOT 
3866				DMARK "DTh" 
3866				CALLMONITOR 
3866			endif	 
3866			 
3866					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3866 cd a4 1a			call macro_forth_dsp_pop 
3869				endm 
# End of macro FORTH_DSP_POP
3869			 
3869			if DEBUG_FORTH_DOT 
3869				DMARK "DTi" 
3869				CALLMONITOR 
3869			endif	 
3869			 
3869			 
3869					NEXTW 
3869 c3 5e 1b			jp macro_next 
386c				endm 
# End of macro NEXTW
386c			 
386c			.CLS: 
386c				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
386c 35				db WORD_SYS_CORE+33             
386d 99 38			dw .DRAW            
386f 04				db 3 + 1 
3870 .. 00			db "CLS",0              
3874				endm 
# End of macro CWHEAD
3874			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3874					if DEBUG_FORTH_WORDS_KEY 
3874						DMARK "CLS" 
3874 f5				push af  
3875 3a 89 38			ld a, (.dmark)  
3878 32 bd fb			ld (debug_mark),a  
387b 3a 8a 38			ld a, (.dmark+1)  
387e 32 be fb			ld (debug_mark+1),a  
3881 3a 8b 38			ld a, (.dmark+2)  
3884 32 bf fb			ld (debug_mark+2),a  
3887 18 03			jr .pastdmark  
3889 ..			.dmark: db "CLS"  
388c f1			.pastdmark: pop af  
388d			endm  
# End of macro DMARK
388d						CALLMONITOR 
388d cd d3 13			call break_point_state  
3890				endm  
# End of macro CALLMONITOR
3890					endif 
3890 cd b6 0a				call clear_display 
3893 c3 a7 39				jp .home		; and home cursor 
3896					NEXTW 
3896 c3 5e 1b			jp macro_next 
3899				endm 
# End of macro NEXTW
3899			 
3899			.DRAW: 
3899				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3899 36				db WORD_SYS_CORE+34             
389a c4 38			dw .DUMP            
389c 05				db 4 + 1 
389d .. 00			db "DRAW",0              
38a2				endm 
# End of macro CWHEAD
38a2			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
38a2					if DEBUG_FORTH_WORDS_KEY 
38a2						DMARK "DRW" 
38a2 f5				push af  
38a3 3a b7 38			ld a, (.dmark)  
38a6 32 bd fb			ld (debug_mark),a  
38a9 3a b8 38			ld a, (.dmark+1)  
38ac 32 be fb			ld (debug_mark+1),a  
38af 3a b9 38			ld a, (.dmark+2)  
38b2 32 bf fb			ld (debug_mark+2),a  
38b5 18 03			jr .pastdmark  
38b7 ..			.dmark: db "DRW"  
38ba f1			.pastdmark: pop af  
38bb			endm  
# End of macro DMARK
38bb						CALLMONITOR 
38bb cd d3 13			call break_point_state  
38be				endm  
# End of macro CALLMONITOR
38be					endif 
38be cd d9 0a				call update_display 
38c1					NEXTW 
38c1 c3 5e 1b			jp macro_next 
38c4				endm 
# End of macro NEXTW
38c4			 
38c4			.DUMP: 
38c4				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
38c4 37				db WORD_SYS_CORE+35             
38c5 fc 38			dw .CDUMP            
38c7 05				db 4 + 1 
38c8 .. 00			db "DUMP",0              
38cd				endm 
# End of macro CWHEAD
38cd			; | DUMP ( x -- ) With address x display dump   | DONE 
38cd			; TODO pop address to use off of the stack 
38cd					if DEBUG_FORTH_WORDS_KEY 
38cd						DMARK "DUM" 
38cd f5				push af  
38ce 3a e2 38			ld a, (.dmark)  
38d1 32 bd fb			ld (debug_mark),a  
38d4 3a e3 38			ld a, (.dmark+1)  
38d7 32 be fb			ld (debug_mark+1),a  
38da 3a e4 38			ld a, (.dmark+2)  
38dd 32 bf fb			ld (debug_mark+2),a  
38e0 18 03			jr .pastdmark  
38e2 ..			.dmark: db "DUM"  
38e5 f1			.pastdmark: pop af  
38e6			endm  
# End of macro DMARK
38e6						CALLMONITOR 
38e6 cd d3 13			call break_point_state  
38e9				endm  
# End of macro CALLMONITOR
38e9					endif 
38e9 cd b6 0a				call clear_display 
38ec			 
38ec					; get address 
38ec			 
38ec					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38ec cd 08 1a			call macro_dsp_valuehl 
38ef				endm 
# End of macro FORTH_DSP_VALUEHL
38ef				 
38ef					; save it for cdump 
38ef			 
38ef 22 db f2				ld (os_cur_ptr),hl 
38f2			 
38f2					; destroy value TOS 
38f2			 
38f2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38f2 cd a4 1a			call macro_forth_dsp_pop 
38f5				endm 
# End of macro FORTH_DSP_POP
38f5			 
38f5 cd ed 17				call dumpcont	; skip old style of param parsing	 
38f8 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
38f9					NEXTW 
38f9 c3 5e 1b			jp macro_next 
38fc				endm 
# End of macro NEXTW
38fc			.CDUMP: 
38fc				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
38fc 38				db WORD_SYS_CORE+36             
38fd 2c 39			dw .DAT            
38ff 06				db 5 + 1 
3900 .. 00			db "CDUMP",0              
3906				endm 
# End of macro CWHEAD
3906			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3906					if DEBUG_FORTH_WORDS_KEY 
3906						DMARK "CDP" 
3906 f5				push af  
3907 3a 1b 39			ld a, (.dmark)  
390a 32 bd fb			ld (debug_mark),a  
390d 3a 1c 39			ld a, (.dmark+1)  
3910 32 be fb			ld (debug_mark+1),a  
3913 3a 1d 39			ld a, (.dmark+2)  
3916 32 bf fb			ld (debug_mark+2),a  
3919 18 03			jr .pastdmark  
391b ..			.dmark: db "CDP"  
391e f1			.pastdmark: pop af  
391f			endm  
# End of macro DMARK
391f						CALLMONITOR 
391f cd d3 13			call break_point_state  
3922				endm  
# End of macro CALLMONITOR
3922					endif 
3922 cd b6 0a				call clear_display 
3925 cd ed 17				call dumpcont	 
3928 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3929					NEXTW 
3929 c3 5e 1b			jp macro_next 
392c				endm 
# End of macro NEXTW
392c			 
392c			 
392c			 
392c			 
392c			.DAT: 
392c				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
392c 3d				db WORD_SYS_CORE+41             
392d 82 39			dw .HOME            
392f 03				db 2 + 1 
3930 .. 00			db "AT",0              
3933				endm 
# End of macro CWHEAD
3933			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3933					if DEBUG_FORTH_WORDS_KEY 
3933						DMARK "AT." 
3933 f5				push af  
3934 3a 48 39			ld a, (.dmark)  
3937 32 bd fb			ld (debug_mark),a  
393a 3a 49 39			ld a, (.dmark+1)  
393d 32 be fb			ld (debug_mark+1),a  
3940 3a 4a 39			ld a, (.dmark+2)  
3943 32 bf fb			ld (debug_mark+2),a  
3946 18 03			jr .pastdmark  
3948 ..			.dmark: db "AT."  
394b f1			.pastdmark: pop af  
394c			endm  
# End of macro DMARK
394c						CALLMONITOR 
394c cd d3 13			call break_point_state  
394f				endm  
# End of macro CALLMONITOR
394f					endif 
394f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
394f cd 08 1a			call macro_dsp_valuehl 
3952				endm 
# End of macro FORTH_DSP_VALUEHL
3952			 
3952			 
3952					; TODO save cursor row 
3952 7d					ld a,l 
3953 fe 02				cp 2 
3955 20 04				jr nz, .crow3 
3957 3e 14				ld a, display_row_2 
3959 18 12				jr .ccol1 
395b fe 03		.crow3:		cp 3 
395d 20 04				jr nz, .crow4 
395f 3e 28				ld a, display_row_3 
3961 18 0a				jr .ccol1 
3963 fe 04		.crow4:		cp 4 
3965 20 04				jr nz, .crow1 
3967 3e 3c				ld a, display_row_4 
3969 18 02				jr .ccol1 
396b 3e 00		.crow1:		ld a,display_row_1 
396d f5			.ccol1:		push af			; got row offset 
396e 6f					ld l,a 
396f 26 00				ld h,0 
3971					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3971 cd a4 1a			call macro_forth_dsp_pop 
3974				endm 
# End of macro FORTH_DSP_POP
3974					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3974 cd 08 1a			call macro_dsp_valuehl 
3977				endm 
# End of macro FORTH_DSP_VALUEHL
3977					; TODO save cursor col 
3977 f1					pop af 
3978 85					add l		; add col offset 
3979 32 e1 f9				ld (f_cursor_ptr), a 
397c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
397c cd a4 1a			call macro_forth_dsp_pop 
397f				endm 
# End of macro FORTH_DSP_POP
397f			 
397f					; calculate  
397f			 
397f					NEXTW 
397f c3 5e 1b			jp macro_next 
3982				endm 
# End of macro NEXTW
3982			 
3982			 
3982			.HOME: 
3982				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3982 41				db WORD_SYS_CORE+45             
3983 af 39			dw .SPACE            
3985 05				db 4 + 1 
3986 .. 00			db "HOME",0              
398b				endm 
# End of macro CWHEAD
398b			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
398b					if DEBUG_FORTH_WORDS_KEY 
398b						DMARK "HOM" 
398b f5				push af  
398c 3a a0 39			ld a, (.dmark)  
398f 32 bd fb			ld (debug_mark),a  
3992 3a a1 39			ld a, (.dmark+1)  
3995 32 be fb			ld (debug_mark+1),a  
3998 3a a2 39			ld a, (.dmark+2)  
399b 32 bf fb			ld (debug_mark+2),a  
399e 18 03			jr .pastdmark  
39a0 ..			.dmark: db "HOM"  
39a3 f1			.pastdmark: pop af  
39a4			endm  
# End of macro DMARK
39a4						CALLMONITOR 
39a4 cd d3 13			call break_point_state  
39a7				endm  
# End of macro CALLMONITOR
39a7					endif 
39a7 3e 00		.home:		ld a, 0		; and home cursor 
39a9 32 e1 f9				ld (f_cursor_ptr), a 
39ac					NEXTW 
39ac c3 5e 1b			jp macro_next 
39af				endm 
# End of macro NEXTW
39af			 
39af			 
39af			.SPACE: 
39af				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
39af 46				db WORD_SYS_CORE+50             
39b0 dd 39			dw .SPACES            
39b2 03				db 2 + 1 
39b3 .. 00			db "BL",0              
39b6				endm 
# End of macro CWHEAD
39b6			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
39b6					if DEBUG_FORTH_WORDS_KEY 
39b6						DMARK "BL." 
39b6 f5				push af  
39b7 3a cb 39			ld a, (.dmark)  
39ba 32 bd fb			ld (debug_mark),a  
39bd 3a cc 39			ld a, (.dmark+1)  
39c0 32 be fb			ld (debug_mark+1),a  
39c3 3a cd 39			ld a, (.dmark+2)  
39c6 32 bf fb			ld (debug_mark+2),a  
39c9 18 03			jr .pastdmark  
39cb ..			.dmark: db "BL."  
39ce f1			.pastdmark: pop af  
39cf			endm  
# End of macro DMARK
39cf						CALLMONITOR 
39cf cd d3 13			call break_point_state  
39d2				endm  
# End of macro CALLMONITOR
39d2					endif 
39d2 21 db 39				ld hl, .blstr 
39d5 cd 7f 19				call forth_push_str 
39d8					 
39d8				       NEXTW 
39d8 c3 5e 1b			jp macro_next 
39db				endm 
# End of macro NEXTW
39db			 
39db .. 00		.blstr: db " ", 0 
39dd			 
39dd			.SPACES: 
39dd				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
39dd 47				db WORD_SYS_CORE+51             
39de 78 3a			dw .SCROLL            
39e0 07				db 6 + 1 
39e1 .. 00			db "SPACES",0              
39e8				endm 
# End of macro CWHEAD
39e8			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
39e8					if DEBUG_FORTH_WORDS_KEY 
39e8						DMARK "SPS" 
39e8 f5				push af  
39e9 3a fd 39			ld a, (.dmark)  
39ec 32 bd fb			ld (debug_mark),a  
39ef 3a fe 39			ld a, (.dmark+1)  
39f2 32 be fb			ld (debug_mark+1),a  
39f5 3a ff 39			ld a, (.dmark+2)  
39f8 32 bf fb			ld (debug_mark+2),a  
39fb 18 03			jr .pastdmark  
39fd ..			.dmark: db "SPS"  
3a00 f1			.pastdmark: pop af  
3a01			endm  
# End of macro DMARK
3a01						CALLMONITOR 
3a01 cd d3 13			call break_point_state  
3a04				endm  
# End of macro CALLMONITOR
3a04					endif 
3a04			 
3a04			 
3a04					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a04 cd 08 1a			call macro_dsp_valuehl 
3a07				endm 
# End of macro FORTH_DSP_VALUEHL
3a07			 
3a07			;		push hl    ; u 
3a07					if DEBUG_FORTH_WORDS 
3a07						DMARK "SPA" 
3a07 f5				push af  
3a08 3a 1c 3a			ld a, (.dmark)  
3a0b 32 bd fb			ld (debug_mark),a  
3a0e 3a 1d 3a			ld a, (.dmark+1)  
3a11 32 be fb			ld (debug_mark+1),a  
3a14 3a 1e 3a			ld a, (.dmark+2)  
3a17 32 bf fb			ld (debug_mark+2),a  
3a1a 18 03			jr .pastdmark  
3a1c ..			.dmark: db "SPA"  
3a1f f1			.pastdmark: pop af  
3a20			endm  
# End of macro DMARK
3a20						CALLMONITOR 
3a20 cd d3 13			call break_point_state  
3a23				endm  
# End of macro CALLMONITOR
3a23					endif 
3a23			 
3a23					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a23 cd a4 1a			call macro_forth_dsp_pop 
3a26				endm 
# End of macro FORTH_DSP_POP
3a26			;		pop hl 
3a26 4d					ld c, l 
3a27 06 00				ld b, 0 
3a29 21 b8 ef				ld hl, scratch  
3a2c			 
3a2c					if DEBUG_FORTH_WORDS 
3a2c						DMARK "SP2" 
3a2c f5				push af  
3a2d 3a 41 3a			ld a, (.dmark)  
3a30 32 bd fb			ld (debug_mark),a  
3a33 3a 42 3a			ld a, (.dmark+1)  
3a36 32 be fb			ld (debug_mark+1),a  
3a39 3a 43 3a			ld a, (.dmark+2)  
3a3c 32 bf fb			ld (debug_mark+2),a  
3a3f 18 03			jr .pastdmark  
3a41 ..			.dmark: db "SP2"  
3a44 f1			.pastdmark: pop af  
3a45			endm  
# End of macro DMARK
3a45						CALLMONITOR 
3a45 cd d3 13			call break_point_state  
3a48				endm  
# End of macro CALLMONITOR
3a48					endif 
3a48 3e 20				ld a, ' ' 
3a4a c5			.spaces1:	push bc 
3a4b 77					ld (hl),a 
3a4c 23					inc hl 
3a4d c1					pop bc 
3a4e 10 fa				djnz .spaces1 
3a50 3e 00				ld a,0 
3a52 77					ld (hl),a 
3a53 21 b8 ef				ld hl, scratch 
3a56					if DEBUG_FORTH_WORDS 
3a56						DMARK "SP3" 
3a56 f5				push af  
3a57 3a 6b 3a			ld a, (.dmark)  
3a5a 32 bd fb			ld (debug_mark),a  
3a5d 3a 6c 3a			ld a, (.dmark+1)  
3a60 32 be fb			ld (debug_mark+1),a  
3a63 3a 6d 3a			ld a, (.dmark+2)  
3a66 32 bf fb			ld (debug_mark+2),a  
3a69 18 03			jr .pastdmark  
3a6b ..			.dmark: db "SP3"  
3a6e f1			.pastdmark: pop af  
3a6f			endm  
# End of macro DMARK
3a6f						CALLMONITOR 
3a6f cd d3 13			call break_point_state  
3a72				endm  
# End of macro CALLMONITOR
3a72					endif 
3a72 cd b5 19				call forth_apush 
3a75			 
3a75				       NEXTW 
3a75 c3 5e 1b			jp macro_next 
3a78				endm 
# End of macro NEXTW
3a78			 
3a78			 
3a78			 
3a78			.SCROLL: 
3a78				CWHEAD .ATQ 63 "SCROLL" 6 WORD_FLAG_CODE 
3a78 53				db WORD_SYS_CORE+63             
3a79 a5 3a			dw .ATQ            
3a7b 07				db 6 + 1 
3a7c .. 00			db "SCROLL",0              
3a83				endm 
# End of macro CWHEAD
3a83			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
3a83					if DEBUG_FORTH_WORDS_KEY 
3a83						DMARK "SCR" 
3a83 f5				push af  
3a84 3a 98 3a			ld a, (.dmark)  
3a87 32 bd fb			ld (debug_mark),a  
3a8a 3a 99 3a			ld a, (.dmark+1)  
3a8d 32 be fb			ld (debug_mark+1),a  
3a90 3a 9a 3a			ld a, (.dmark+2)  
3a93 32 bf fb			ld (debug_mark+2),a  
3a96 18 03			jr .pastdmark  
3a98 ..			.dmark: db "SCR"  
3a9b f1			.pastdmark: pop af  
3a9c			endm  
# End of macro DMARK
3a9c						CALLMONITOR 
3a9c cd d3 13			call break_point_state  
3a9f				endm  
# End of macro CALLMONITOR
3a9f					endif 
3a9f			 
3a9f cd 4e 0a			call scroll_up 
3aa2			;	call update_display 
3aa2			 
3aa2					NEXTW 
3aa2 c3 5e 1b			jp macro_next 
3aa5				endm 
# End of macro NEXTW
3aa5			 
3aa5			 
3aa5			 
3aa5			;		; get dir 
3aa5			; 
3aa5			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3aa5			; 
3aa5			;		push hl 
3aa5			; 
3aa5			;		; destroy value TOS 
3aa5			; 
3aa5			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3aa5			; 
3aa5			;		; get count 
3aa5			; 
3aa5			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3aa5			; 
3aa5			;		push hl 
3aa5			; 
3aa5			;		; destroy value TOS 
3aa5			; 
3aa5			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3aa5			; 
3aa5			;		; one value on hl get other one back 
3aa5			; 
3aa5			;		pop bc    ; count 
3aa5			; 
3aa5			;		pop de   ; dir 
3aa5			; 
3aa5			; 
3aa5			;		ld b, c 
3aa5			; 
3aa5			;.scrolldir:     push bc 
3aa5			;		push de 
3aa5			; 
3aa5			;		ld a, 0 
3aa5			;		cp e 
3aa5			;		jr z, .scrollup  
3aa5			;		call scroll_down 
3aa5			;		jr .scrollnext 
3aa5			;.scrollup:	call scroll_up 
3aa5			; 
3aa5			;		 
3aa5			;.scrollnext: 
3aa5			;		pop de 
3aa5			;		pop bc 
3aa5			;		djnz .scrolldir 
3aa5			; 
3aa5			; 
3aa5			; 
3aa5			; 
3aa5			; 
3aa5			;		NEXTW 
3aa5			 
3aa5			 
3aa5			 
3aa5			 
3aa5			.ATQ: 
3aa5				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
3aa5 62				db WORD_SYS_CORE+78             
3aa6 03 3b			dw .AUTODSP            
3aa8 04				db 3 + 1 
3aa9 .. 00			db "AT@",0              
3aad				endm 
# End of macro CWHEAD
3aad			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
3aad					if DEBUG_FORTH_WORDS_KEY 
3aad						DMARK "ATA" 
3aad f5				push af  
3aae 3a c2 3a			ld a, (.dmark)  
3ab1 32 bd fb			ld (debug_mark),a  
3ab4 3a c3 3a			ld a, (.dmark+1)  
3ab7 32 be fb			ld (debug_mark+1),a  
3aba 3a c4 3a			ld a, (.dmark+2)  
3abd 32 bf fb			ld (debug_mark+2),a  
3ac0 18 03			jr .pastdmark  
3ac2 ..			.dmark: db "ATA"  
3ac5 f1			.pastdmark: pop af  
3ac6			endm  
# End of macro DMARK
3ac6						CALLMONITOR 
3ac6 cd d3 13			call break_point_state  
3ac9				endm  
# End of macro CALLMONITOR
3ac9					endif 
3ac9			 
3ac9			 
3ac9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ac9 cd 08 1a			call macro_dsp_valuehl 
3acc				endm 
# End of macro FORTH_DSP_VALUEHL
3acc			 
3acc					; TODO save cursor row 
3acc 7d					ld a,l 
3acd fe 02				cp 2 
3acf 20 04				jr nz, .crow3aq 
3ad1 3e 14				ld a, display_row_2 
3ad3 18 12				jr .ccol1aq 
3ad5 fe 03		.crow3aq:		cp 3 
3ad7 20 04				jr nz, .crow4aq 
3ad9 3e 28				ld a, display_row_3 
3adb 18 0a				jr .ccol1aq 
3add fe 04		.crow4aq:		cp 4 
3adf 20 04				jr nz, .crow1aq 
3ae1 3e 3c				ld a, display_row_4 
3ae3 18 02				jr .ccol1aq 
3ae5 3e 00		.crow1aq:		ld a,display_row_1 
3ae7 f5			.ccol1aq:		push af			; got row offset 
3ae8 6f					ld l,a 
3ae9 26 00				ld h,0 
3aeb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3aeb cd a4 1a			call macro_forth_dsp_pop 
3aee				endm 
# End of macro FORTH_DSP_POP
3aee					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3aee cd 08 1a			call macro_dsp_valuehl 
3af1				endm 
# End of macro FORTH_DSP_VALUEHL
3af1					; TODO save cursor col 
3af1 f1					pop af 
3af2 85					add l		; add col offset 
3af3			 
3af3					; add current frame buffer address 
3af3 2a 5e fa				ld hl, (display_fb_active) 
3af6 cd 0f 0c				call addatohl 
3af9			 
3af9			 
3af9			 
3af9			 
3af9					; get char frame buffer location offset in hl 
3af9			 
3af9 7e					ld a,(hl) 
3afa 26 00				ld h, 0 
3afc 6f					ld l, a 
3afd			 
3afd cd 6d 19				call forth_push_numhl 
3b00			 
3b00			 
3b00					NEXTW 
3b00 c3 5e 1b			jp macro_next 
3b03				endm 
# End of macro NEXTW
3b03			 
3b03			.AUTODSP: 
3b03				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
3b03 63				db WORD_SYS_CORE+79             
3b04 19 3b			dw .MENU            
3b06 05				db 4 + 1 
3b07 .. 00			db "ADSP",0              
3b0c				endm 
# End of macro CWHEAD
3b0c			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
3b0c			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
3b0c			 
3b0c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b0c cd 08 1a			call macro_dsp_valuehl 
3b0f				endm 
# End of macro FORTH_DSP_VALUEHL
3b0f			 
3b0f			;		push hl 
3b0f			 
3b0f					; destroy value TOS 
3b0f			 
3b0f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b0f cd a4 1a			call macro_forth_dsp_pop 
3b12				endm 
# End of macro FORTH_DSP_POP
3b12			 
3b12			;		pop hl 
3b12			 
3b12 7d					ld a,l 
3b13 32 bf f9				ld (cli_autodisplay), a 
3b16				       NEXTW 
3b16 c3 5e 1b			jp macro_next 
3b19				endm 
# End of macro NEXTW
3b19			 
3b19			.MENU: 
3b19				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
3b19 70				db WORD_SYS_CORE+92             
3b1a 25 3b			dw .ENDDISPLAY            
3b1c 05				db 4 + 1 
3b1d .. 00			db "MENU",0              
3b22				endm 
# End of macro CWHEAD
3b22			; | MENU ( u1....ux n ut -- n ) Create a menu. Ut is the title, n is the number of menu items on stack. Push number selection to TOS | TODO 
3b22			 
3b22					; get the title address and save it 
3b22			 
3b22			;		FORTH_DSP_VALUEHL 
3b22			;		push hl 
3b22			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b22			; 
3b22			;		; get number of items on the stack 
3b22			; 
3b22			;	 
3b22			;		FORTH_DSP_VALUEHL 
3b22			;		push hl 
3b22			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b22			 
3b22			 
3b22			 
3b22			 
3b22				       NEXTW 
3b22 c3 5e 1b			jp macro_next 
3b25				endm 
# End of macro NEXTW
3b25			 
3b25			 
3b25			.ENDDISPLAY: 
3b25			 
3b25			; eof 
# End of file forth_words_display.asm
3b25			include "forth_words_str.asm" 
3b25			 
3b25			; | ## String Words 
3b25			 
3b25			.PTR:   
3b25			 
3b25				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
3b25 48				db WORD_SYS_CORE+52             
3b26 52 3b			dw .STYPE            
3b28 04				db 3 + 1 
3b29 .. 00			db "PTR",0              
3b2d				endm 
# End of macro CWHEAD
3b2d			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
3b2d			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
3b2d			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
3b2d			 
3b2d					if DEBUG_FORTH_WORDS_KEY 
3b2d						DMARK "PTR" 
3b2d f5				push af  
3b2e 3a 42 3b			ld a, (.dmark)  
3b31 32 bd fb			ld (debug_mark),a  
3b34 3a 43 3b			ld a, (.dmark+1)  
3b37 32 be fb			ld (debug_mark+1),a  
3b3a 3a 44 3b			ld a, (.dmark+2)  
3b3d 32 bf fb			ld (debug_mark+2),a  
3b40 18 03			jr .pastdmark  
3b42 ..			.dmark: db "PTR"  
3b45 f1			.pastdmark: pop af  
3b46			endm  
# End of macro DMARK
3b46						CALLMONITOR 
3b46 cd d3 13			call break_point_state  
3b49				endm  
# End of macro CALLMONITOR
3b49					endif 
3b49					FORTH_DSP_VALUEHL 
3b49 cd 08 1a			call macro_dsp_valuehl 
3b4c				endm 
# End of macro FORTH_DSP_VALUEHL
3b4c cd 6d 19				call forth_push_numhl 
3b4f			 
3b4f			 
3b4f					NEXTW 
3b4f c3 5e 1b			jp macro_next 
3b52				endm 
# End of macro NEXTW
3b52			.STYPE: 
3b52				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
3b52 48				db WORD_SYS_CORE+52             
3b53 a1 3b			dw .UPPER            
3b55 06				db 5 + 1 
3b56 .. 00			db "STYPE",0              
3b5c				endm 
# End of macro CWHEAD
3b5c			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
3b5c					if DEBUG_FORTH_WORDS_KEY 
3b5c						DMARK "STY" 
3b5c f5				push af  
3b5d 3a 71 3b			ld a, (.dmark)  
3b60 32 bd fb			ld (debug_mark),a  
3b63 3a 72 3b			ld a, (.dmark+1)  
3b66 32 be fb			ld (debug_mark+1),a  
3b69 3a 73 3b			ld a, (.dmark+2)  
3b6c 32 bf fb			ld (debug_mark+2),a  
3b6f 18 03			jr .pastdmark  
3b71 ..			.dmark: db "STY"  
3b74 f1			.pastdmark: pop af  
3b75			endm  
# End of macro DMARK
3b75						CALLMONITOR 
3b75 cd d3 13			call break_point_state  
3b78				endm  
# End of macro CALLMONITOR
3b78					endif 
3b78					FORTH_DSP 
3b78 cd ed 19			call macro_forth_dsp 
3b7b				endm 
# End of macro FORTH_DSP
3b7b					;v5 FORTH_DSP_VALUE 
3b7b			 
3b7b 7e					ld a, (hl) 
3b7c			 
3b7c f5					push af 
3b7d			 
3b7d			; Dont destroy TOS		FORTH_DSP_POP 
3b7d			 
3b7d f1					pop af 
3b7e			 
3b7e fe 01				cp DS_TYPE_STR 
3b80 28 09				jr z, .typestr 
3b82			 
3b82 fe 02				cp DS_TYPE_INUM 
3b84 28 0a				jr z, .typeinum 
3b86			 
3b86 21 9f 3b				ld hl, .tna 
3b89 18 0a				jr .tpush 
3b8b			 
3b8b 21 9b 3b		.typestr:	ld hl, .tstr 
3b8e 18 05				jr .tpush 
3b90 21 9d 3b		.typeinum:	ld hl, .tinum 
3b93 18 00				jr .tpush 
3b95			 
3b95			.tpush: 
3b95			 
3b95 cd 7f 19				call forth_push_str 
3b98			 
3b98					NEXTW 
3b98 c3 5e 1b			jp macro_next 
3b9b				endm 
# End of macro NEXTW
3b9b .. 00		.tstr:	db "s",0 
3b9d .. 00		.tinum:  db "i",0 
3b9f .. 00		.tna:   db "?", 0 
3ba1			 
3ba1			 
3ba1			.UPPER: 
3ba1				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
3ba1 48				db WORD_SYS_CORE+52             
3ba2 dc 3b			dw .LOWER            
3ba4 06				db 5 + 1 
3ba5 .. 00			db "UPPER",0              
3bab				endm 
# End of macro CWHEAD
3bab			; | UPPER ( s -- s ) Upper case string s  | DONE 
3bab					if DEBUG_FORTH_WORDS_KEY 
3bab						DMARK "UPR" 
3bab f5				push af  
3bac 3a c0 3b			ld a, (.dmark)  
3baf 32 bd fb			ld (debug_mark),a  
3bb2 3a c1 3b			ld a, (.dmark+1)  
3bb5 32 be fb			ld (debug_mark+1),a  
3bb8 3a c2 3b			ld a, (.dmark+2)  
3bbb 32 bf fb			ld (debug_mark+2),a  
3bbe 18 03			jr .pastdmark  
3bc0 ..			.dmark: db "UPR"  
3bc3 f1			.pastdmark: pop af  
3bc4			endm  
# End of macro DMARK
3bc4						CALLMONITOR 
3bc4 cd d3 13			call break_point_state  
3bc7				endm  
# End of macro CALLMONITOR
3bc7					endif 
3bc7			 
3bc7					FORTH_DSP 
3bc7 cd ed 19			call macro_forth_dsp 
3bca				endm 
# End of macro FORTH_DSP
3bca					 
3bca			; TODO check is string type 
3bca			 
3bca					FORTH_DSP_VALUEHL 
3bca cd 08 1a			call macro_dsp_valuehl 
3bcd				endm 
# End of macro FORTH_DSP_VALUEHL
3bcd			; get pointer to string in hl 
3bcd			 
3bcd 7e			.toup:		ld a, (hl) 
3bce fe 00				cp 0 
3bd0 28 07				jr z, .toupdone 
3bd2			 
3bd2 cd 7c 0f				call to_upper 
3bd5			 
3bd5 77					ld (hl), a 
3bd6 23					inc hl 
3bd7 18 f4				jr .toup 
3bd9			 
3bd9					 
3bd9			 
3bd9			 
3bd9			; for each char convert to upper 
3bd9					 
3bd9			.toupdone: 
3bd9			 
3bd9			 
3bd9					NEXTW 
3bd9 c3 5e 1b			jp macro_next 
3bdc				endm 
# End of macro NEXTW
3bdc			.LOWER: 
3bdc				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
3bdc 48				db WORD_SYS_CORE+52             
3bdd 17 3c			dw .TCASE            
3bdf 06				db 5 + 1 
3be0 .. 00			db "LOWER",0              
3be6				endm 
# End of macro CWHEAD
3be6			; | LOWER ( s -- s ) Lower case string s  | DONE 
3be6					if DEBUG_FORTH_WORDS_KEY 
3be6						DMARK "LWR" 
3be6 f5				push af  
3be7 3a fb 3b			ld a, (.dmark)  
3bea 32 bd fb			ld (debug_mark),a  
3bed 3a fc 3b			ld a, (.dmark+1)  
3bf0 32 be fb			ld (debug_mark+1),a  
3bf3 3a fd 3b			ld a, (.dmark+2)  
3bf6 32 bf fb			ld (debug_mark+2),a  
3bf9 18 03			jr .pastdmark  
3bfb ..			.dmark: db "LWR"  
3bfe f1			.pastdmark: pop af  
3bff			endm  
# End of macro DMARK
3bff						CALLMONITOR 
3bff cd d3 13			call break_point_state  
3c02				endm  
# End of macro CALLMONITOR
3c02					endif 
3c02			 
3c02					FORTH_DSP 
3c02 cd ed 19			call macro_forth_dsp 
3c05				endm 
# End of macro FORTH_DSP
3c05					 
3c05			; TODO check is string type 
3c05			 
3c05					FORTH_DSP_VALUEHL 
3c05 cd 08 1a			call macro_dsp_valuehl 
3c08				endm 
# End of macro FORTH_DSP_VALUEHL
3c08			; get pointer to string in hl 
3c08			 
3c08 7e			.tolow:		ld a, (hl) 
3c09 fe 00				cp 0 
3c0b 28 07				jr z, .tolowdone 
3c0d			 
3c0d cd 85 0f				call to_lower 
3c10			 
3c10 77					ld (hl), a 
3c11 23					inc hl 
3c12 18 f4				jr .tolow 
3c14			 
3c14					 
3c14			 
3c14			 
3c14			; for each char convert to low 
3c14					 
3c14			.tolowdone: 
3c14					NEXTW 
3c14 c3 5e 1b			jp macro_next 
3c17				endm 
# End of macro NEXTW
3c17			.TCASE: 
3c17				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
3c17 48				db WORD_SYS_CORE+52             
3c18 4d 3d			dw .SUBSTR            
3c1a 06				db 5 + 1 
3c1b .. 00			db "TCASE",0              
3c21				endm 
# End of macro CWHEAD
3c21			; | TCASE ( s -- s ) Title case string s  | DONE 
3c21					if DEBUG_FORTH_WORDS_KEY 
3c21						DMARK "TCS" 
3c21 f5				push af  
3c22 3a 36 3c			ld a, (.dmark)  
3c25 32 bd fb			ld (debug_mark),a  
3c28 3a 37 3c			ld a, (.dmark+1)  
3c2b 32 be fb			ld (debug_mark+1),a  
3c2e 3a 38 3c			ld a, (.dmark+2)  
3c31 32 bf fb			ld (debug_mark+2),a  
3c34 18 03			jr .pastdmark  
3c36 ..			.dmark: db "TCS"  
3c39 f1			.pastdmark: pop af  
3c3a			endm  
# End of macro DMARK
3c3a						CALLMONITOR 
3c3a cd d3 13			call break_point_state  
3c3d				endm  
# End of macro CALLMONITOR
3c3d					endif 
3c3d			 
3c3d					FORTH_DSP 
3c3d cd ed 19			call macro_forth_dsp 
3c40				endm 
# End of macro FORTH_DSP
3c40					 
3c40			; TODO check is string type 
3c40			 
3c40					FORTH_DSP_VALUEHL 
3c40 cd 08 1a			call macro_dsp_valuehl 
3c43				endm 
# End of macro FORTH_DSP_VALUEHL
3c43			; get pointer to string in hl 
3c43			 
3c43					if DEBUG_FORTH_WORDS 
3c43						DMARK "TC1" 
3c43 f5				push af  
3c44 3a 58 3c			ld a, (.dmark)  
3c47 32 bd fb			ld (debug_mark),a  
3c4a 3a 59 3c			ld a, (.dmark+1)  
3c4d 32 be fb			ld (debug_mark+1),a  
3c50 3a 5a 3c			ld a, (.dmark+2)  
3c53 32 bf fb			ld (debug_mark+2),a  
3c56 18 03			jr .pastdmark  
3c58 ..			.dmark: db "TC1"  
3c5b f1			.pastdmark: pop af  
3c5c			endm  
# End of macro DMARK
3c5c						CALLMONITOR 
3c5c cd d3 13			call break_point_state  
3c5f				endm  
# End of macro CALLMONITOR
3c5f					endif 
3c5f			 
3c5f					; first time in turn to upper case first char 
3c5f			 
3c5f 7e					ld a, (hl) 
3c60 c3 ea 3c				jp .totsiptou 
3c63			 
3c63			 
3c63 7e			.tot:		ld a, (hl) 
3c64 fe 00				cp 0 
3c66 ca 2e 3d				jp z, .totdone 
3c69			 
3c69					if DEBUG_FORTH_WORDS 
3c69						DMARK "TC2" 
3c69 f5				push af  
3c6a 3a 7e 3c			ld a, (.dmark)  
3c6d 32 bd fb			ld (debug_mark),a  
3c70 3a 7f 3c			ld a, (.dmark+1)  
3c73 32 be fb			ld (debug_mark+1),a  
3c76 3a 80 3c			ld a, (.dmark+2)  
3c79 32 bf fb			ld (debug_mark+2),a  
3c7c 18 03			jr .pastdmark  
3c7e ..			.dmark: db "TC2"  
3c81 f1			.pastdmark: pop af  
3c82			endm  
# End of macro DMARK
3c82						CALLMONITOR 
3c82 cd d3 13			call break_point_state  
3c85				endm  
# End of macro CALLMONITOR
3c85					endif 
3c85					; check to see if current char is a space 
3c85			 
3c85 fe 20				cp ' ' 
3c87 28 21				jr z, .totsp 
3c89 cd 85 0f				call to_lower 
3c8c					if DEBUG_FORTH_WORDS 
3c8c						DMARK "TC3" 
3c8c f5				push af  
3c8d 3a a1 3c			ld a, (.dmark)  
3c90 32 bd fb			ld (debug_mark),a  
3c93 3a a2 3c			ld a, (.dmark+1)  
3c96 32 be fb			ld (debug_mark+1),a  
3c99 3a a3 3c			ld a, (.dmark+2)  
3c9c 32 bf fb			ld (debug_mark+2),a  
3c9f 18 03			jr .pastdmark  
3ca1 ..			.dmark: db "TC3"  
3ca4 f1			.pastdmark: pop af  
3ca5			endm  
# End of macro DMARK
3ca5						CALLMONITOR 
3ca5 cd d3 13			call break_point_state  
3ca8				endm  
# End of macro CALLMONITOR
3ca8					endif 
3ca8 18 63				jr .totnxt 
3caa			 
3caa			.totsp:         ; on a space, find next char which should be upper 
3caa			 
3caa					if DEBUG_FORTH_WORDS 
3caa						DMARK "TC4" 
3caa f5				push af  
3cab 3a bf 3c			ld a, (.dmark)  
3cae 32 bd fb			ld (debug_mark),a  
3cb1 3a c0 3c			ld a, (.dmark+1)  
3cb4 32 be fb			ld (debug_mark+1),a  
3cb7 3a c1 3c			ld a, (.dmark+2)  
3cba 32 bf fb			ld (debug_mark+2),a  
3cbd 18 03			jr .pastdmark  
3cbf ..			.dmark: db "TC4"  
3cc2 f1			.pastdmark: pop af  
3cc3			endm  
# End of macro DMARK
3cc3						CALLMONITOR 
3cc3 cd d3 13			call break_point_state  
3cc6				endm  
# End of macro CALLMONITOR
3cc6					endif 
3cc6					;; 
3cc6			 
3cc6 fe 20				cp ' ' 
3cc8 20 20				jr nz, .totsiptou 
3cca 23					inc hl 
3ccb 7e					ld a, (hl) 
3ccc					if DEBUG_FORTH_WORDS 
3ccc						DMARK "TC5" 
3ccc f5				push af  
3ccd 3a e1 3c			ld a, (.dmark)  
3cd0 32 bd fb			ld (debug_mark),a  
3cd3 3a e2 3c			ld a, (.dmark+1)  
3cd6 32 be fb			ld (debug_mark+1),a  
3cd9 3a e3 3c			ld a, (.dmark+2)  
3cdc 32 bf fb			ld (debug_mark+2),a  
3cdf 18 03			jr .pastdmark  
3ce1 ..			.dmark: db "TC5"  
3ce4 f1			.pastdmark: pop af  
3ce5			endm  
# End of macro DMARK
3ce5						CALLMONITOR 
3ce5 cd d3 13			call break_point_state  
3ce8				endm  
# End of macro CALLMONITOR
3ce8					endif 
3ce8 18 c0				jr .totsp 
3cea fe 00		.totsiptou:    cp 0 
3cec 28 40				jr z, .totdone 
3cee					; not space and not zero term so upper case it 
3cee cd 7c 0f				call to_upper 
3cf1			 
3cf1					if DEBUG_FORTH_WORDS 
3cf1						DMARK "TC6" 
3cf1 f5				push af  
3cf2 3a 06 3d			ld a, (.dmark)  
3cf5 32 bd fb			ld (debug_mark),a  
3cf8 3a 07 3d			ld a, (.dmark+1)  
3cfb 32 be fb			ld (debug_mark+1),a  
3cfe 3a 08 3d			ld a, (.dmark+2)  
3d01 32 bf fb			ld (debug_mark+2),a  
3d04 18 03			jr .pastdmark  
3d06 ..			.dmark: db "TC6"  
3d09 f1			.pastdmark: pop af  
3d0a			endm  
# End of macro DMARK
3d0a						CALLMONITOR 
3d0a cd d3 13			call break_point_state  
3d0d				endm  
# End of macro CALLMONITOR
3d0d					endif 
3d0d			 
3d0d			 
3d0d			.totnxt: 
3d0d			 
3d0d 77					ld (hl), a 
3d0e 23					inc hl 
3d0f					if DEBUG_FORTH_WORDS 
3d0f						DMARK "TC7" 
3d0f f5				push af  
3d10 3a 24 3d			ld a, (.dmark)  
3d13 32 bd fb			ld (debug_mark),a  
3d16 3a 25 3d			ld a, (.dmark+1)  
3d19 32 be fb			ld (debug_mark+1),a  
3d1c 3a 26 3d			ld a, (.dmark+2)  
3d1f 32 bf fb			ld (debug_mark+2),a  
3d22 18 03			jr .pastdmark  
3d24 ..			.dmark: db "TC7"  
3d27 f1			.pastdmark: pop af  
3d28			endm  
# End of macro DMARK
3d28						CALLMONITOR 
3d28 cd d3 13			call break_point_state  
3d2b				endm  
# End of macro CALLMONITOR
3d2b					endif 
3d2b c3 63 3c				jp .tot 
3d2e			 
3d2e					 
3d2e			 
3d2e			 
3d2e			; for each char convert to low 
3d2e					 
3d2e			.totdone: 
3d2e					if DEBUG_FORTH_WORDS 
3d2e						DMARK "TCd" 
3d2e f5				push af  
3d2f 3a 43 3d			ld a, (.dmark)  
3d32 32 bd fb			ld (debug_mark),a  
3d35 3a 44 3d			ld a, (.dmark+1)  
3d38 32 be fb			ld (debug_mark+1),a  
3d3b 3a 45 3d			ld a, (.dmark+2)  
3d3e 32 bf fb			ld (debug_mark+2),a  
3d41 18 03			jr .pastdmark  
3d43 ..			.dmark: db "TCd"  
3d46 f1			.pastdmark: pop af  
3d47			endm  
# End of macro DMARK
3d47						CALLMONITOR 
3d47 cd d3 13			call break_point_state  
3d4a				endm  
# End of macro CALLMONITOR
3d4a					endif 
3d4a					NEXTW 
3d4a c3 5e 1b			jp macro_next 
3d4d				endm 
# End of macro NEXTW
3d4d			 
3d4d			.SUBSTR: 
3d4d				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
3d4d 48				db WORD_SYS_CORE+52             
3d4e ab 3d			dw .LEFT            
3d50 07				db 6 + 1 
3d51 .. 00			db "SUBSTR",0              
3d58				endm 
# End of macro CWHEAD
3d58			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
3d58			 
3d58					if DEBUG_FORTH_WORDS_KEY 
3d58						DMARK "SST" 
3d58 f5				push af  
3d59 3a 6d 3d			ld a, (.dmark)  
3d5c 32 bd fb			ld (debug_mark),a  
3d5f 3a 6e 3d			ld a, (.dmark+1)  
3d62 32 be fb			ld (debug_mark+1),a  
3d65 3a 6f 3d			ld a, (.dmark+2)  
3d68 32 bf fb			ld (debug_mark+2),a  
3d6b 18 03			jr .pastdmark  
3d6d ..			.dmark: db "SST"  
3d70 f1			.pastdmark: pop af  
3d71			endm  
# End of macro DMARK
3d71						CALLMONITOR 
3d71 cd d3 13			call break_point_state  
3d74				endm  
# End of macro CALLMONITOR
3d74					endif 
3d74			; TODO check string type 
3d74					FORTH_DSP_VALUEHL 
3d74 cd 08 1a			call macro_dsp_valuehl 
3d77				endm 
# End of macro FORTH_DSP_VALUEHL
3d77			 
3d77 e5					push hl      ; string length 
3d78			 
3d78					FORTH_DSP_POP 
3d78 cd a4 1a			call macro_forth_dsp_pop 
3d7b				endm 
# End of macro FORTH_DSP_POP
3d7b			 
3d7b					FORTH_DSP_VALUEHL 
3d7b cd 08 1a			call macro_dsp_valuehl 
3d7e				endm 
# End of macro FORTH_DSP_VALUEHL
3d7e			 
3d7e e5					push hl     ; start char 
3d7f			 
3d7f					FORTH_DSP_POP 
3d7f cd a4 1a			call macro_forth_dsp_pop 
3d82				endm 
# End of macro FORTH_DSP_POP
3d82			 
3d82			 
3d82					FORTH_DSP_VALUE 
3d82 cd f1 19			call macro_forth_dsp_value 
3d85				endm 
# End of macro FORTH_DSP_VALUE
3d85			 
3d85 d1					pop de    ; get start post offset 
3d86			 
3d86 19					add hl, de    ; starting offset 
3d87			 
3d87 c1					pop bc 
3d88 c5					push bc      ; grab size of string 
3d89			 
3d89 e5					push hl    ; save string start  
3d8a			 
3d8a 26 00				ld h, 0 
3d8c 69					ld l, c 
3d8d 23					inc hl 
3d8e 23					inc hl 
3d8f			 
3d8f cd d6 10				call malloc 
3d92				if DEBUG_FORTH_MALLOC_GUARD 
3d92 cc a7 4e				call z,malloc_error 
3d95				endif 
3d95			 
3d95 eb					ex de, hl      ; save malloc area for string copy 
3d96 e1					pop hl    ; get back source 
3d97 c1					pop bc    ; get length of string back 
3d98			 
3d98 d5					push de    ; save malloc area for after we push 
3d99 ed b0				ldir     ; copy substr 
3d9b			 
3d9b			 
3d9b eb					ex de, hl 
3d9c 3e 00				ld a, 0 
3d9e 77					ld (hl), a   ; term substr 
3d9f			 
3d9f					 
3d9f e1					pop hl    ; get malloc so we can push it 
3da0 e5					push hl   ; save so we can free it afterwards 
3da1			 
3da1 cd 7f 19				call forth_push_str 
3da4			 
3da4 e1					pop hl 
3da5 cd a0 11				call free 
3da8			 
3da8					 
3da8					 
3da8			 
3da8			 
3da8					NEXTW 
3da8 c3 5e 1b			jp macro_next 
3dab				endm 
# End of macro NEXTW
3dab			 
3dab			.LEFT: 
3dab				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
3dab 48				db WORD_SYS_CORE+52             
3dac d3 3d			dw .RIGHT            
3dae 05				db 4 + 1 
3daf .. 00			db "LEFT",0              
3db4				endm 
# End of macro CWHEAD
3db4			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
3db4					if DEBUG_FORTH_WORDS_KEY 
3db4						DMARK "LEF" 
3db4 f5				push af  
3db5 3a c9 3d			ld a, (.dmark)  
3db8 32 bd fb			ld (debug_mark),a  
3dbb 3a ca 3d			ld a, (.dmark+1)  
3dbe 32 be fb			ld (debug_mark+1),a  
3dc1 3a cb 3d			ld a, (.dmark+2)  
3dc4 32 bf fb			ld (debug_mark+2),a  
3dc7 18 03			jr .pastdmark  
3dc9 ..			.dmark: db "LEF"  
3dcc f1			.pastdmark: pop af  
3dcd			endm  
# End of macro DMARK
3dcd						CALLMONITOR 
3dcd cd d3 13			call break_point_state  
3dd0				endm  
# End of macro CALLMONITOR
3dd0					endif 
3dd0			 
3dd0					NEXTW 
3dd0 c3 5e 1b			jp macro_next 
3dd3				endm 
# End of macro NEXTW
3dd3			.RIGHT: 
3dd3				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
3dd3 48				db WORD_SYS_CORE+52             
3dd4 fc 3d			dw .STR2NUM            
3dd6 06				db 5 + 1 
3dd7 .. 00			db "RIGHT",0              
3ddd				endm 
# End of macro CWHEAD
3ddd			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
3ddd					if DEBUG_FORTH_WORDS_KEY 
3ddd						DMARK "RIG" 
3ddd f5				push af  
3dde 3a f2 3d			ld a, (.dmark)  
3de1 32 bd fb			ld (debug_mark),a  
3de4 3a f3 3d			ld a, (.dmark+1)  
3de7 32 be fb			ld (debug_mark+1),a  
3dea 3a f4 3d			ld a, (.dmark+2)  
3ded 32 bf fb			ld (debug_mark+2),a  
3df0 18 03			jr .pastdmark  
3df2 ..			.dmark: db "RIG"  
3df5 f1			.pastdmark: pop af  
3df6			endm  
# End of macro DMARK
3df6						CALLMONITOR 
3df6 cd d3 13			call break_point_state  
3df9				endm  
# End of macro CALLMONITOR
3df9					endif 
3df9			 
3df9					NEXTW 
3df9 c3 5e 1b			jp macro_next 
3dfc				endm 
# End of macro NEXTW
3dfc			 
3dfc			 
3dfc			.STR2NUM: 
3dfc				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
3dfc 48				db WORD_SYS_CORE+52             
3dfd 88 3e			dw .NUM2STR            
3dff 08				db 7 + 1 
3e00 .. 00			db "STR2NUM",0              
3e08				endm 
# End of macro CWHEAD
3e08			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
3e08			 
3e08			 
3e08			; TODO STR type check to do 
3e08					if DEBUG_FORTH_WORDS_KEY 
3e08						DMARK "S2N" 
3e08 f5				push af  
3e09 3a 1d 3e			ld a, (.dmark)  
3e0c 32 bd fb			ld (debug_mark),a  
3e0f 3a 1e 3e			ld a, (.dmark+1)  
3e12 32 be fb			ld (debug_mark+1),a  
3e15 3a 1f 3e			ld a, (.dmark+2)  
3e18 32 bf fb			ld (debug_mark+2),a  
3e1b 18 03			jr .pastdmark  
3e1d ..			.dmark: db "S2N"  
3e20 f1			.pastdmark: pop af  
3e21			endm  
# End of macro DMARK
3e21						CALLMONITOR 
3e21 cd d3 13			call break_point_state  
3e24				endm  
# End of macro CALLMONITOR
3e24					endif 
3e24			 
3e24					;FORTH_DSP 
3e24					FORTH_DSP_VALUE 
3e24 cd f1 19			call macro_forth_dsp_value 
3e27				endm 
# End of macro FORTH_DSP_VALUE
3e27					;inc hl 
3e27			 
3e27 eb					ex de, hl 
3e28					if DEBUG_FORTH_WORDS 
3e28						DMARK "S2a" 
3e28 f5				push af  
3e29 3a 3d 3e			ld a, (.dmark)  
3e2c 32 bd fb			ld (debug_mark),a  
3e2f 3a 3e 3e			ld a, (.dmark+1)  
3e32 32 be fb			ld (debug_mark+1),a  
3e35 3a 3f 3e			ld a, (.dmark+2)  
3e38 32 bf fb			ld (debug_mark+2),a  
3e3b 18 03			jr .pastdmark  
3e3d ..			.dmark: db "S2a"  
3e40 f1			.pastdmark: pop af  
3e41			endm  
# End of macro DMARK
3e41						CALLMONITOR 
3e41 cd d3 13			call break_point_state  
3e44				endm  
# End of macro CALLMONITOR
3e44					endif 
3e44 cd 04 10				call string_to_uint16 
3e47			 
3e47					if DEBUG_FORTH_WORDS 
3e47						DMARK "S2b" 
3e47 f5				push af  
3e48 3a 5c 3e			ld a, (.dmark)  
3e4b 32 bd fb			ld (debug_mark),a  
3e4e 3a 5d 3e			ld a, (.dmark+1)  
3e51 32 be fb			ld (debug_mark+1),a  
3e54 3a 5e 3e			ld a, (.dmark+2)  
3e57 32 bf fb			ld (debug_mark+2),a  
3e5a 18 03			jr .pastdmark  
3e5c ..			.dmark: db "S2b"  
3e5f f1			.pastdmark: pop af  
3e60			endm  
# End of macro DMARK
3e60						CALLMONITOR 
3e60 cd d3 13			call break_point_state  
3e63				endm  
# End of macro CALLMONITOR
3e63					endif 
3e63			;		push hl 
3e63					FORTH_DSP_POP 
3e63 cd a4 1a			call macro_forth_dsp_pop 
3e66				endm 
# End of macro FORTH_DSP_POP
3e66			;		pop hl 
3e66					 
3e66					if DEBUG_FORTH_WORDS 
3e66						DMARK "S2b" 
3e66 f5				push af  
3e67 3a 7b 3e			ld a, (.dmark)  
3e6a 32 bd fb			ld (debug_mark),a  
3e6d 3a 7c 3e			ld a, (.dmark+1)  
3e70 32 be fb			ld (debug_mark+1),a  
3e73 3a 7d 3e			ld a, (.dmark+2)  
3e76 32 bf fb			ld (debug_mark+2),a  
3e79 18 03			jr .pastdmark  
3e7b ..			.dmark: db "S2b"  
3e7e f1			.pastdmark: pop af  
3e7f			endm  
# End of macro DMARK
3e7f						CALLMONITOR 
3e7f cd d3 13			call break_point_state  
3e82				endm  
# End of macro CALLMONITOR
3e82					endif 
3e82 cd 6d 19				call forth_push_numhl	 
3e85			 
3e85				 
3e85				       NEXTW 
3e85 c3 5e 1b			jp macro_next 
3e88				endm 
# End of macro NEXTW
3e88			.NUM2STR: 
3e88				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
3e88 48				db WORD_SYS_CORE+52             
3e89 97 3e			dw .CONCAT            
3e8b 08				db 7 + 1 
3e8c .. 00			db "NUM2STR",0              
3e94				endm 
# End of macro CWHEAD
3e94			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
3e94			 
3e94			;		; malloc a string to target 
3e94			;		ld hl, 10     ; TODO max string size should be fine 
3e94			;		call malloc 
3e94			;		push hl    ; save malloc location 
3e94			; 
3e94			; 
3e94			;; TODO check int type 
3e94			;		FORTH_DSP_VALUEHL 
3e94			;		ld a, l 
3e94			;		call DispAToASCII   
3e94			;;TODO need to chage above call to dump into string 
3e94			; 
3e94			; 
3e94			 
3e94				       NEXTW 
3e94 c3 5e 1b			jp macro_next 
3e97				endm 
# End of macro NEXTW
3e97			 
3e97			.CONCAT: 
3e97				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
3e97 48				db WORD_SYS_CORE+52             
3e98 4a 3f			dw .FIND            
3e9a 07				db 6 + 1 
3e9b .. 00			db "CONCAT",0              
3ea2				endm 
# End of macro CWHEAD
3ea2			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
3ea2			 
3ea2			; TODO check string type 
3ea2			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
3ea2			 
3ea2					if DEBUG_FORTH_WORDS_KEY 
3ea2						DMARK "CON" 
3ea2 f5				push af  
3ea3 3a b7 3e			ld a, (.dmark)  
3ea6 32 bd fb			ld (debug_mark),a  
3ea9 3a b8 3e			ld a, (.dmark+1)  
3eac 32 be fb			ld (debug_mark+1),a  
3eaf 3a b9 3e			ld a, (.dmark+2)  
3eb2 32 bf fb			ld (debug_mark+2),a  
3eb5 18 03			jr .pastdmark  
3eb7 ..			.dmark: db "CON"  
3eba f1			.pastdmark: pop af  
3ebb			endm  
# End of macro DMARK
3ebb						CALLMONITOR 
3ebb cd d3 13			call break_point_state  
3ebe				endm  
# End of macro CALLMONITOR
3ebe					endif 
3ebe			 
3ebe			 
3ebe					FORTH_DSP_VALUE 
3ebe cd f1 19			call macro_forth_dsp_value 
3ec1				endm 
# End of macro FORTH_DSP_VALUE
3ec1 e5					push hl   ; s2 
3ec2			 
3ec2					FORTH_DSP_POP 
3ec2 cd a4 1a			call macro_forth_dsp_pop 
3ec5				endm 
# End of macro FORTH_DSP_POP
3ec5			 
3ec5					FORTH_DSP_VALUE 
3ec5 cd f1 19			call macro_forth_dsp_value 
3ec8				endm 
# End of macro FORTH_DSP_VALUE
3ec8			 
3ec8 e5					push hl   ; s1 
3ec9			 
3ec9					FORTH_DSP_POP 
3ec9 cd a4 1a			call macro_forth_dsp_pop 
3ecc				endm 
# End of macro FORTH_DSP_POP
3ecc					 
3ecc			 
3ecc					; copy s1 
3ecc			 
3ecc				 
3ecc					; save ptr 
3ecc e1					pop hl  
3ecd e5					push hl 
3ece 3e 00				ld a, 0 
3ed0 cd 78 10				call strlent 
3ed3					;inc hl    ; zer0 
3ed3 06 00				ld b, 0 
3ed5 4d					ld c, l 
3ed6 e1					pop hl		 
3ed7 11 b8 ef				ld de, scratch	 
3eda					if DEBUG_FORTH_WORDS 
3eda						DMARK "CO1" 
3eda f5				push af  
3edb 3a ef 3e			ld a, (.dmark)  
3ede 32 bd fb			ld (debug_mark),a  
3ee1 3a f0 3e			ld a, (.dmark+1)  
3ee4 32 be fb			ld (debug_mark+1),a  
3ee7 3a f1 3e			ld a, (.dmark+2)  
3eea 32 bf fb			ld (debug_mark+2),a  
3eed 18 03			jr .pastdmark  
3eef ..			.dmark: db "CO1"  
3ef2 f1			.pastdmark: pop af  
3ef3			endm  
# End of macro DMARK
3ef3						CALLMONITOR 
3ef3 cd d3 13			call break_point_state  
3ef6				endm  
# End of macro CALLMONITOR
3ef6					endif 
3ef6 ed b0				ldir 
3ef8			 
3ef8 e1					pop hl 
3ef9 e5					push hl 
3efa d5					push de 
3efb			 
3efb			 
3efb 3e 00				ld a, 0 
3efd cd 78 10				call strlent 
3f00 23					inc hl    ; zer0 
3f01 23					inc hl 
3f02 06 00				ld b, 0 
3f04 4d					ld c, l 
3f05 d1					pop de 
3f06 e1					pop hl		 
3f07					if DEBUG_FORTH_WORDS 
3f07						DMARK "CO2" 
3f07 f5				push af  
3f08 3a 1c 3f			ld a, (.dmark)  
3f0b 32 bd fb			ld (debug_mark),a  
3f0e 3a 1d 3f			ld a, (.dmark+1)  
3f11 32 be fb			ld (debug_mark+1),a  
3f14 3a 1e 3f			ld a, (.dmark+2)  
3f17 32 bf fb			ld (debug_mark+2),a  
3f1a 18 03			jr .pastdmark  
3f1c ..			.dmark: db "CO2"  
3f1f f1			.pastdmark: pop af  
3f20			endm  
# End of macro DMARK
3f20						CALLMONITOR 
3f20 cd d3 13			call break_point_state  
3f23				endm  
# End of macro CALLMONITOR
3f23					endif 
3f23 ed b0				ldir 
3f25			 
3f25			 
3f25			 
3f25 21 b8 ef				ld hl, scratch 
3f28					if DEBUG_FORTH_WORDS 
3f28						DMARK "CO5" 
3f28 f5				push af  
3f29 3a 3d 3f			ld a, (.dmark)  
3f2c 32 bd fb			ld (debug_mark),a  
3f2f 3a 3e 3f			ld a, (.dmark+1)  
3f32 32 be fb			ld (debug_mark+1),a  
3f35 3a 3f 3f			ld a, (.dmark+2)  
3f38 32 bf fb			ld (debug_mark+2),a  
3f3b 18 03			jr .pastdmark  
3f3d ..			.dmark: db "CO5"  
3f40 f1			.pastdmark: pop af  
3f41			endm  
# End of macro DMARK
3f41						CALLMONITOR 
3f41 cd d3 13			call break_point_state  
3f44				endm  
# End of macro CALLMONITOR
3f44					endif 
3f44			 
3f44 cd 7f 19				call forth_push_str 
3f47			 
3f47			 
3f47			 
3f47			 
3f47				       NEXTW 
3f47 c3 5e 1b			jp macro_next 
3f4a				endm 
# End of macro NEXTW
3f4a			 
3f4a			 
3f4a			.FIND: 
3f4a				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
3f4a 4b				db WORD_SYS_CORE+55             
3f4b 08 40			dw .LEN            
3f4d 05				db 4 + 1 
3f4e .. 00			db "FIND",0              
3f53				endm 
# End of macro CWHEAD
3f53			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
3f53			 
3f53					if DEBUG_FORTH_WORDS_KEY 
3f53						DMARK "FND" 
3f53 f5				push af  
3f54 3a 68 3f			ld a, (.dmark)  
3f57 32 bd fb			ld (debug_mark),a  
3f5a 3a 69 3f			ld a, (.dmark+1)  
3f5d 32 be fb			ld (debug_mark+1),a  
3f60 3a 6a 3f			ld a, (.dmark+2)  
3f63 32 bf fb			ld (debug_mark+2),a  
3f66 18 03			jr .pastdmark  
3f68 ..			.dmark: db "FND"  
3f6b f1			.pastdmark: pop af  
3f6c			endm  
# End of macro DMARK
3f6c						CALLMONITOR 
3f6c cd d3 13			call break_point_state  
3f6f				endm  
# End of macro CALLMONITOR
3f6f					endif 
3f6f			 
3f6f			; TODO check string type 
3f6f					FORTH_DSP_VALUE 
3f6f cd f1 19			call macro_forth_dsp_value 
3f72				endm 
# End of macro FORTH_DSP_VALUE
3f72			 
3f72 e5					push hl    
3f73 7e					ld a,(hl)    ; char to find   
3f74			; TODO change char to substr 
3f74			 
3f74 f5					push af 
3f75					 
3f75			 
3f75			 
3f75					if DEBUG_FORTH_WORDS 
3f75						DMARK "FN1" 
3f75 f5				push af  
3f76 3a 8a 3f			ld a, (.dmark)  
3f79 32 bd fb			ld (debug_mark),a  
3f7c 3a 8b 3f			ld a, (.dmark+1)  
3f7f 32 be fb			ld (debug_mark+1),a  
3f82 3a 8c 3f			ld a, (.dmark+2)  
3f85 32 bf fb			ld (debug_mark+2),a  
3f88 18 03			jr .pastdmark  
3f8a ..			.dmark: db "FN1"  
3f8d f1			.pastdmark: pop af  
3f8e			endm  
# End of macro DMARK
3f8e						CALLMONITOR 
3f8e cd d3 13			call break_point_state  
3f91				endm  
# End of macro CALLMONITOR
3f91					endif 
3f91			 
3f91					FORTH_DSP_POP 
3f91 cd a4 1a			call macro_forth_dsp_pop 
3f94				endm 
# End of macro FORTH_DSP_POP
3f94			 
3f94					; string to search 
3f94			 
3f94					FORTH_DSP_VALUE 
3f94 cd f1 19			call macro_forth_dsp_value 
3f97				endm 
# End of macro FORTH_DSP_VALUE
3f97			 
3f97 d1					pop de  ; d is char to find  
3f98			 
3f98					if DEBUG_FORTH_WORDS 
3f98						DMARK "FN2" 
3f98 f5				push af  
3f99 3a ad 3f			ld a, (.dmark)  
3f9c 32 bd fb			ld (debug_mark),a  
3f9f 3a ae 3f			ld a, (.dmark+1)  
3fa2 32 be fb			ld (debug_mark+1),a  
3fa5 3a af 3f			ld a, (.dmark+2)  
3fa8 32 bf fb			ld (debug_mark+2),a  
3fab 18 03			jr .pastdmark  
3fad ..			.dmark: db "FN2"  
3fb0 f1			.pastdmark: pop af  
3fb1			endm  
# End of macro DMARK
3fb1						CALLMONITOR 
3fb1 cd d3 13			call break_point_state  
3fb4				endm  
# End of macro CALLMONITOR
3fb4					endif 
3fb4					 
3fb4 01 00 00				ld bc, 0 
3fb7 7e			.findchar:      ld a,(hl) 
3fb8 fe 00				cp 0   		 
3fba 28 27				jr z, .finddone     
3fbc ba					cp d 
3fbd 28 20				jr z, .foundchar 
3fbf 03					inc bc 
3fc0 23					inc hl 
3fc1					if DEBUG_FORTH_WORDS 
3fc1						DMARK "FN3" 
3fc1 f5				push af  
3fc2 3a d6 3f			ld a, (.dmark)  
3fc5 32 bd fb			ld (debug_mark),a  
3fc8 3a d7 3f			ld a, (.dmark+1)  
3fcb 32 be fb			ld (debug_mark+1),a  
3fce 3a d8 3f			ld a, (.dmark+2)  
3fd1 32 bf fb			ld (debug_mark+2),a  
3fd4 18 03			jr .pastdmark  
3fd6 ..			.dmark: db "FN3"  
3fd9 f1			.pastdmark: pop af  
3fda			endm  
# End of macro DMARK
3fda						CALLMONITOR 
3fda cd d3 13			call break_point_state  
3fdd				endm  
# End of macro CALLMONITOR
3fdd					endif 
3fdd 18 d8				jr .findchar 
3fdf			 
3fdf			 
3fdf c5			.foundchar:	push bc 
3fe0 e1					pop hl 
3fe1 18 03				jr .findexit 
3fe3			 
3fe3			 
3fe3							 
3fe3			 
3fe3			.finddone:     ; got to end of string with no find 
3fe3 21 00 00				ld hl, 0 
3fe6			.findexit: 
3fe6			 
3fe6					if DEBUG_FORTH_WORDS 
3fe6						DMARK "FNd" 
3fe6 f5				push af  
3fe7 3a fb 3f			ld a, (.dmark)  
3fea 32 bd fb			ld (debug_mark),a  
3fed 3a fc 3f			ld a, (.dmark+1)  
3ff0 32 be fb			ld (debug_mark+1),a  
3ff3 3a fd 3f			ld a, (.dmark+2)  
3ff6 32 bf fb			ld (debug_mark+2),a  
3ff9 18 03			jr .pastdmark  
3ffb ..			.dmark: db "FNd"  
3ffe f1			.pastdmark: pop af  
3fff			endm  
# End of macro DMARK
3fff						CALLMONITOR 
3fff cd d3 13			call break_point_state  
4002				endm  
# End of macro CALLMONITOR
4002					endif 
4002 cd 6d 19			call forth_push_numhl 
4005			 
4005				       NEXTW 
4005 c3 5e 1b			jp macro_next 
4008				endm 
# End of macro NEXTW
4008			 
4008			.LEN: 
4008				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
4008 4c				db WORD_SYS_CORE+56             
4009 3d 40			dw .CHAR            
400b 06				db 5 + 1 
400c .. 00			db "COUNT",0              
4012				endm 
# End of macro CWHEAD
4012			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
4012			 
4012					if DEBUG_FORTH_WORDS_KEY 
4012						DMARK "CNT" 
4012 f5				push af  
4013 3a 27 40			ld a, (.dmark)  
4016 32 bd fb			ld (debug_mark),a  
4019 3a 28 40			ld a, (.dmark+1)  
401c 32 be fb			ld (debug_mark+1),a  
401f 3a 29 40			ld a, (.dmark+2)  
4022 32 bf fb			ld (debug_mark+2),a  
4025 18 03			jr .pastdmark  
4027 ..			.dmark: db "CNT"  
402a f1			.pastdmark: pop af  
402b			endm  
# End of macro DMARK
402b						CALLMONITOR 
402b cd d3 13			call break_point_state  
402e				endm  
# End of macro CALLMONITOR
402e					endif 
402e			; TODO check string type 
402e					FORTH_DSP 
402e cd ed 19			call macro_forth_dsp 
4031				endm 
# End of macro FORTH_DSP
4031					;v5FORTH_DSP_VALUE 
4031			 
4031 23					inc hl 
4032			 
4032 3e 00				ld a, 0 
4034 cd 78 10				call strlent 
4037			 
4037 cd 6d 19				call forth_push_numhl 
403a			 
403a			 
403a			 
403a				       NEXTW 
403a c3 5e 1b			jp macro_next 
403d				endm 
# End of macro NEXTW
403d			.CHAR: 
403d				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
403d 4d				db WORD_SYS_CORE+57             
403e 73 40			dw .ENDSTR            
4040 05				db 4 + 1 
4041 .. 00			db "CHAR",0              
4046				endm 
# End of macro CWHEAD
4046			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
4046					if DEBUG_FORTH_WORDS_KEY 
4046						DMARK "CHR" 
4046 f5				push af  
4047 3a 5b 40			ld a, (.dmark)  
404a 32 bd fb			ld (debug_mark),a  
404d 3a 5c 40			ld a, (.dmark+1)  
4050 32 be fb			ld (debug_mark+1),a  
4053 3a 5d 40			ld a, (.dmark+2)  
4056 32 bf fb			ld (debug_mark+2),a  
4059 18 03			jr .pastdmark  
405b ..			.dmark: db "CHR"  
405e f1			.pastdmark: pop af  
405f			endm  
# End of macro DMARK
405f						CALLMONITOR 
405f cd d3 13			call break_point_state  
4062				endm  
# End of macro CALLMONITOR
4062					endif 
4062					FORTH_DSP 
4062 cd ed 19			call macro_forth_dsp 
4065				endm 
# End of macro FORTH_DSP
4065					;v5 FORTH_DSP_VALUE 
4065 23					inc hl      ; now at start of numeric as string 
4066			 
4066			;		push hl 
4066			 
4066					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4066 cd a4 1a			call macro_forth_dsp_pop 
4069				endm 
# End of macro FORTH_DSP_POP
4069			 
4069			;		pop hl 
4069			 
4069					; push the content of a onto the stack as a value 
4069			 
4069 7e					ld a,(hl)   ; get char 
406a 26 00				ld h,0 
406c 6f					ld l,a 
406d cd 6d 19				call forth_push_numhl 
4070			 
4070				       NEXTW 
4070 c3 5e 1b			jp macro_next 
4073				endm 
# End of macro NEXTW
4073			 
4073			 
4073			 
4073			 
4073			.ENDSTR: 
4073			; eof 
4073			 
# End of file forth_words_str.asm
4073			include "forth_words_key.asm" 
4073			 
4073			; | ## Keyboard Words 
4073			 
4073			.KEY: 
4073				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
4073 3e				db WORD_SYS_CORE+42             
4074 a3 40			dw .WAITK            
4076 04				db 3 + 1 
4077 .. 00			db "KEY",0              
407b				endm 
# End of macro CWHEAD
407b			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
407b			 
407b					if DEBUG_FORTH_WORDS_KEY 
407b						DMARK "KEY" 
407b f5				push af  
407c 3a 90 40			ld a, (.dmark)  
407f 32 bd fb			ld (debug_mark),a  
4082 3a 91 40			ld a, (.dmark+1)  
4085 32 be fb			ld (debug_mark+1),a  
4088 3a 92 40			ld a, (.dmark+2)  
408b 32 bf fb			ld (debug_mark+2),a  
408e 18 03			jr .pastdmark  
4090 ..			.dmark: db "KEY"  
4093 f1			.pastdmark: pop af  
4094			endm  
# End of macro DMARK
4094						CALLMONITOR 
4094 cd d3 13			call break_point_state  
4097				endm  
# End of macro CALLMONITOR
4097					endif 
4097			; TODO currently waits 
4097 cd 0e 63				call cin 
409a					;call cin_wait 
409a 6f					ld l, a 
409b 26 00				ld h, 0 
409d cd 6d 19				call forth_push_numhl 
40a0					NEXTW 
40a0 c3 5e 1b			jp macro_next 
40a3				endm 
# End of macro NEXTW
40a3			.WAITK: 
40a3				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
40a3 3f				db WORD_SYS_CORE+43             
40a4 d5 40			dw .ACCEPT            
40a6 06				db 5 + 1 
40a7 .. 00			db "WAITK",0              
40ad				endm 
# End of macro CWHEAD
40ad			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
40ad					if DEBUG_FORTH_WORDS_KEY 
40ad						DMARK "WAI" 
40ad f5				push af  
40ae 3a c2 40			ld a, (.dmark)  
40b1 32 bd fb			ld (debug_mark),a  
40b4 3a c3 40			ld a, (.dmark+1)  
40b7 32 be fb			ld (debug_mark+1),a  
40ba 3a c4 40			ld a, (.dmark+2)  
40bd 32 bf fb			ld (debug_mark+2),a  
40c0 18 03			jr .pastdmark  
40c2 ..			.dmark: db "WAI"  
40c5 f1			.pastdmark: pop af  
40c6			endm  
# End of macro DMARK
40c6						CALLMONITOR 
40c6 cd d3 13			call break_point_state  
40c9				endm  
# End of macro CALLMONITOR
40c9					endif 
40c9 cd fd 62				call cin_wait 
40cc 6f					ld l, a 
40cd 26 00				ld h, 0 
40cf cd 6d 19				call forth_push_numhl 
40d2					NEXTW 
40d2 c3 5e 1b			jp macro_next 
40d5				endm 
# End of macro NEXTW
40d5			.ACCEPT: 
40d5				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
40d5 40				db WORD_SYS_CORE+44             
40d6 33 41			dw .EDIT            
40d8 07				db 6 + 1 
40d9 .. 00			db "ACCEPT",0              
40e0				endm 
# End of macro CWHEAD
40e0			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
40e0					; TODO crashes on push 
40e0					if DEBUG_FORTH_WORDS_KEY 
40e0						DMARK "ACC" 
40e0 f5				push af  
40e1 3a f5 40			ld a, (.dmark)  
40e4 32 bd fb			ld (debug_mark),a  
40e7 3a f6 40			ld a, (.dmark+1)  
40ea 32 be fb			ld (debug_mark+1),a  
40ed 3a f7 40			ld a, (.dmark+2)  
40f0 32 bf fb			ld (debug_mark+2),a  
40f3 18 03			jr .pastdmark  
40f5 ..			.dmark: db "ACC"  
40f8 f1			.pastdmark: pop af  
40f9			endm  
# End of macro DMARK
40f9						CALLMONITOR 
40f9 cd d3 13			call break_point_state  
40fc				endm  
# End of macro CALLMONITOR
40fc					endif 
40fc 21 b6 f1				ld hl, os_input 
40ff 3e 00				ld a, 0 
4101 77					ld (hl),a 
4102 3a e1 f9				ld a,(f_cursor_ptr) 
4105 16 64				ld d, 100 
4107 0e 00				ld c, 0 
4109 1e 28				ld e, 40 
410b cd 3c 0c				call input_str 
410e					; TODO perhaps do a type check and wrap in quotes if not a number 
410e 21 b6 f1				ld hl, os_input 
4111					if DEBUG_FORTH_WORDS 
4111						DMARK "AC1" 
4111 f5				push af  
4112 3a 26 41			ld a, (.dmark)  
4115 32 bd fb			ld (debug_mark),a  
4118 3a 27 41			ld a, (.dmark+1)  
411b 32 be fb			ld (debug_mark+1),a  
411e 3a 28 41			ld a, (.dmark+2)  
4121 32 bf fb			ld (debug_mark+2),a  
4124 18 03			jr .pastdmark  
4126 ..			.dmark: db "AC1"  
4129 f1			.pastdmark: pop af  
412a			endm  
# End of macro DMARK
412a						CALLMONITOR 
412a cd d3 13			call break_point_state  
412d				endm  
# End of macro CALLMONITOR
412d					endif 
412d cd 7f 19				call forth_push_str 
4130					NEXTW 
4130 c3 5e 1b			jp macro_next 
4133				endm 
# End of macro NEXTW
4133			 
4133			.EDIT: 
4133				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
4133 40				db WORD_SYS_CORE+44             
4134 bc 41			dw .ENDKEY            
4136 05				db 4 + 1 
4137 .. 00			db "EDIT",0              
413c				endm 
# End of macro CWHEAD
413c			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
413c			 
413c					; TODO does not copy from stack 
413c					if DEBUG_FORTH_WORDS_KEY 
413c						DMARK "EDT" 
413c f5				push af  
413d 3a 51 41			ld a, (.dmark)  
4140 32 bd fb			ld (debug_mark),a  
4143 3a 52 41			ld a, (.dmark+1)  
4146 32 be fb			ld (debug_mark+1),a  
4149 3a 53 41			ld a, (.dmark+2)  
414c 32 bf fb			ld (debug_mark+2),a  
414f 18 03			jr .pastdmark  
4151 ..			.dmark: db "EDT"  
4154 f1			.pastdmark: pop af  
4155			endm  
# End of macro DMARK
4155						CALLMONITOR 
4155 cd d3 13			call break_point_state  
4158				endm  
# End of macro CALLMONITOR
4158					endif 
4158			 
4158					FORTH_DSP 
4158 cd ed 19			call macro_forth_dsp 
415b				endm 
# End of macro FORTH_DSP
415b					;v5 FORTH_DSP_VALUE 
415b 23					inc hl    ; TODO do type check 
415c			 
415c e5					push hl 
415d 3e 00				ld a, 0 
415f cd 78 10				call strlent 
4162 23					inc hl 
4163			 
4163 06 00				ld b, 0 
4165 4d					ld c, l 
4166			 
4166 e1					pop hl 
4167 11 b6 f1				ld de, os_input 
416a					if DEBUG_FORTH_WORDS_KEY 
416a						DMARK "EDc" 
416a f5				push af  
416b 3a 7f 41			ld a, (.dmark)  
416e 32 bd fb			ld (debug_mark),a  
4171 3a 80 41			ld a, (.dmark+1)  
4174 32 be fb			ld (debug_mark+1),a  
4177 3a 81 41			ld a, (.dmark+2)  
417a 32 bf fb			ld (debug_mark+2),a  
417d 18 03			jr .pastdmark  
417f ..			.dmark: db "EDc"  
4182 f1			.pastdmark: pop af  
4183			endm  
# End of macro DMARK
4183						CALLMONITOR 
4183 cd d3 13			call break_point_state  
4186				endm  
# End of macro CALLMONITOR
4186					endif 
4186 ed b0				ldir 
4188			 
4188			 
4188 21 b6 f1				ld hl, os_input 
418b					;ld a, 0 
418b					;ld (hl),a 
418b 3a e1 f9				ld a,(f_cursor_ptr) 
418e 16 64				ld d, 100 
4190 0e 00				ld c, 0 
4192 1e 28				ld e, 40 
4194 cd 3c 0c				call input_str 
4197					; TODO perhaps do a type check and wrap in quotes if not a number 
4197 21 b6 f1				ld hl, os_input 
419a					if DEBUG_FORTH_WORDS 
419a						DMARK "ED1" 
419a f5				push af  
419b 3a af 41			ld a, (.dmark)  
419e 32 bd fb			ld (debug_mark),a  
41a1 3a b0 41			ld a, (.dmark+1)  
41a4 32 be fb			ld (debug_mark+1),a  
41a7 3a b1 41			ld a, (.dmark+2)  
41aa 32 bf fb			ld (debug_mark+2),a  
41ad 18 03			jr .pastdmark  
41af ..			.dmark: db "ED1"  
41b2 f1			.pastdmark: pop af  
41b3			endm  
# End of macro DMARK
41b3						CALLMONITOR 
41b3 cd d3 13			call break_point_state  
41b6				endm  
# End of macro CALLMONITOR
41b6					endif 
41b6 cd 7f 19				call forth_push_str 
41b9					NEXTW 
41b9 c3 5e 1b			jp macro_next 
41bc				endm 
# End of macro NEXTW
41bc			 
41bc			 
41bc			 
41bc			.ENDKEY: 
41bc			; eof 
41bc			 
# End of file forth_words_key.asm
41bc			 
41bc			if STORAGE_SE 
41bc			   	include "forth_words_storage.asm" 
41bc			 
41bc			; | ## Fixed Storage Words 
41bc			 
41bc			 
41bc			.BREAD: 
41bc			  
41bc				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
41bc 3a				db WORD_SYS_CORE+38             
41bd 35 42			dw .BWRITE            
41bf 06				db 5 + 1 
41c0 .. 00			db "BREAD",0              
41c6				endm 
# End of macro CWHEAD
41c6			; | BREAD ( u -- u ) With the current bank, read a block from block address u (1-512) and push to stack  | TO TEST 
41c6				 
41c6					if DEBUG_FORTH_WORDS_KEY 
41c6						DMARK "BRD" 
41c6 f5				push af  
41c7 3a db 41			ld a, (.dmark)  
41ca 32 bd fb			ld (debug_mark),a  
41cd 3a dc 41			ld a, (.dmark+1)  
41d0 32 be fb			ld (debug_mark+1),a  
41d3 3a dd 41			ld a, (.dmark+2)  
41d6 32 bf fb			ld (debug_mark+2),a  
41d9 18 03			jr .pastdmark  
41db ..			.dmark: db "BRD"  
41de f1			.pastdmark: pop af  
41df			endm  
# End of macro DMARK
41df						CALLMONITOR 
41df cd d3 13			call break_point_state  
41e2				endm  
# End of macro CALLMONITOR
41e2					endif 
41e2			 
41e2				FORTH_DSP_VALUEHL 
41e2 cd 08 1a			call macro_dsp_valuehl 
41e5				endm 
# End of macro FORTH_DSP_VALUEHL
41e5			 
41e5				FORTH_DSP_POP 
41e5 cd a4 1a			call macro_forth_dsp_pop 
41e8				endm 
# End of macro FORTH_DSP_POP
41e8			 
41e8				; calc block address 
41e8			 
41e8 eb				ex de, hl 
41e9 3e 40			ld a, STORE_BLOCK_PHY 
41eb cd 92 0b			call Mult16 
41ee			 
41ee			 
41ee 11 e8 f9			ld de, store_page 
41f1			 
41f1					if DEBUG_FORTH_WORDS 
41f1						DMARK "BR1" 
41f1 f5				push af  
41f2 3a 06 42			ld a, (.dmark)  
41f5 32 bd fb			ld (debug_mark),a  
41f8 3a 07 42			ld a, (.dmark+1)  
41fb 32 be fb			ld (debug_mark+1),a  
41fe 3a 08 42			ld a, (.dmark+2)  
4201 32 bf fb			ld (debug_mark+2),a  
4204 18 03			jr .pastdmark  
4206 ..			.dmark: db "BR1"  
4209 f1			.pastdmark: pop af  
420a			endm  
# End of macro DMARK
420a						CALLMONITOR 
420a cd d3 13			call break_point_state  
420d				endm  
# End of macro CALLMONITOR
420d					endif 
420d			 
420d cd 09 03			call storage_read_block 
4210			 
4210 21 ea f9		        ld hl, store_page+2 
4213					if DEBUG_FORTH_WORDS 
4213						DMARK "BR2" 
4213 f5				push af  
4214 3a 28 42			ld a, (.dmark)  
4217 32 bd fb			ld (debug_mark),a  
421a 3a 29 42			ld a, (.dmark+1)  
421d 32 be fb			ld (debug_mark+1),a  
4220 3a 2a 42			ld a, (.dmark+2)  
4223 32 bf fb			ld (debug_mark+2),a  
4226 18 03			jr .pastdmark  
4228 ..			.dmark: db "BR2"  
422b f1			.pastdmark: pop af  
422c			endm  
# End of macro DMARK
422c						CALLMONITOR 
422c cd d3 13			call break_point_state  
422f				endm  
# End of macro CALLMONITOR
422f					endif 
422f cd 7f 19			call forth_push_str 
4232			 
4232			 
4232					NEXTW 
4232 c3 5e 1b			jp macro_next 
4235				endm 
# End of macro NEXTW
4235			.BWRITE: 
4235				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
4235 3a				db WORD_SYS_CORE+38             
4236 ca 42			dw .BUPD            
4238 07				db 6 + 1 
4239 .. 00			db "BWRITE",0              
4240				endm 
# End of macro CWHEAD
4240			; | BWRITE ( s u -- ) With the current bank, write the string s to address u | TO TEST 
4240			 
4240					if DEBUG_FORTH_WORDS_KEY 
4240						DMARK "BWR" 
4240 f5				push af  
4241 3a 55 42			ld a, (.dmark)  
4244 32 bd fb			ld (debug_mark),a  
4247 3a 56 42			ld a, (.dmark+1)  
424a 32 be fb			ld (debug_mark+1),a  
424d 3a 57 42			ld a, (.dmark+2)  
4250 32 bf fb			ld (debug_mark+2),a  
4253 18 03			jr .pastdmark  
4255 ..			.dmark: db "BWR"  
4258 f1			.pastdmark: pop af  
4259			endm  
# End of macro DMARK
4259						CALLMONITOR 
4259 cd d3 13			call break_point_state  
425c				endm  
# End of macro CALLMONITOR
425c					endif 
425c			 
425c				FORTH_DSP_VALUEHL 
425c cd 08 1a			call macro_dsp_valuehl 
425f				endm 
# End of macro FORTH_DSP_VALUEHL
425f			 
425f				; calc block address 
425f			 
425f eb				ex de, hl 
4260 3e 40			ld a, STORE_BLOCK_PHY 
4262 cd 92 0b			call Mult16 
4265			 
4265 e5				push hl         ; address 
4266			 
4266				FORTH_DSP_POP 
4266 cd a4 1a			call macro_forth_dsp_pop 
4269				endm 
# End of macro FORTH_DSP_POP
4269			 
4269				FORTH_DSP_VALUEHL 
4269 cd 08 1a			call macro_dsp_valuehl 
426c				endm 
# End of macro FORTH_DSP_VALUEHL
426c			 
426c				FORTH_DSP_POP 
426c cd a4 1a			call macro_forth_dsp_pop 
426f				endm 
# End of macro FORTH_DSP_POP
426f			 
426f cd 0a 0a			call storage_clear_page 
4272			 
4272				; copy string to store page 
4272			 
4272 e5				push hl     ; save string address 
4273			 
4273 3e 00			ld a, 0 
4275 cd 78 10			call strlent 
4278			 
4278 23				inc hl 
4279			 
4279 4d				ld c, l 
427a 06 00			ld b, 0 
427c			 
427c e1				pop hl 
427d 11 ea f9			ld de, store_page + 2 
4280					if DEBUG_FORTH_WORDS 
4280						DMARK "BW1" 
4280 f5				push af  
4281 3a 95 42			ld a, (.dmark)  
4284 32 bd fb			ld (debug_mark),a  
4287 3a 96 42			ld a, (.dmark+1)  
428a 32 be fb			ld (debug_mark+1),a  
428d 3a 97 42			ld a, (.dmark+2)  
4290 32 bf fb			ld (debug_mark+2),a  
4293 18 03			jr .pastdmark  
4295 ..			.dmark: db "BW1"  
4298 f1			.pastdmark: pop af  
4299			endm  
# End of macro DMARK
4299						CALLMONITOR 
4299 cd d3 13			call break_point_state  
429c				endm  
# End of macro CALLMONITOR
429c					endif 
429c ed b0			ldir 
429e			 
429e			 
429e				; poke the start of the block with flags to prevent high level file ops hitting the block 
429e			 
429e 21 ff ff			ld hl, $ffff 
42a1			 
42a1 22 e8 f9			ld (store_page), hl	 
42a4				 
42a4 e1				pop hl    ; get address 
42a5 11 e8 f9			ld de, store_page 
42a8			 
42a8					if DEBUG_FORTH_WORDS 
42a8						DMARK "BW2" 
42a8 f5				push af  
42a9 3a bd 42			ld a, (.dmark)  
42ac 32 bd fb			ld (debug_mark),a  
42af 3a be 42			ld a, (.dmark+1)  
42b2 32 be fb			ld (debug_mark+1),a  
42b5 3a bf 42			ld a, (.dmark+2)  
42b8 32 bf fb			ld (debug_mark+2),a  
42bb 18 03			jr .pastdmark  
42bd ..			.dmark: db "BW2"  
42c0 f1			.pastdmark: pop af  
42c1			endm  
# End of macro DMARK
42c1						CALLMONITOR 
42c1 cd d3 13			call break_point_state  
42c4				endm  
# End of macro CALLMONITOR
42c4					endif 
42c4			 
42c4 cd 6e 03			call storage_write_block 
42c7			 
42c7					NEXTW 
42c7 c3 5e 1b			jp macro_next 
42ca				endm 
# End of macro NEXTW
42ca			 
42ca			.BUPD: 
42ca				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
42ca 3a				db WORD_SYS_CORE+38             
42cb 20 43			dw .BYID            
42cd 05				db 4 + 1 
42ce .. 00			db "BUPD",0              
42d3				endm 
# End of macro CWHEAD
42d3			; | BUPD ( u -- ) Write the contents of the current file system storage buffer directly to address u | TO TEST 
42d3			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
42d3			; | | or completely different file system structure. 
42d3			 
42d3					if DEBUG_FORTH_WORDS_KEY 
42d3						DMARK "BUD" 
42d3 f5				push af  
42d4 3a e8 42			ld a, (.dmark)  
42d7 32 bd fb			ld (debug_mark),a  
42da 3a e9 42			ld a, (.dmark+1)  
42dd 32 be fb			ld (debug_mark+1),a  
42e0 3a ea 42			ld a, (.dmark+2)  
42e3 32 bf fb			ld (debug_mark+2),a  
42e6 18 03			jr .pastdmark  
42e8 ..			.dmark: db "BUD"  
42eb f1			.pastdmark: pop af  
42ec			endm  
# End of macro DMARK
42ec						CALLMONITOR 
42ec cd d3 13			call break_point_state  
42ef				endm  
# End of macro CALLMONITOR
42ef					endif 
42ef			 
42ef				FORTH_DSP_VALUEHL 
42ef cd 08 1a			call macro_dsp_valuehl 
42f2				endm 
# End of macro FORTH_DSP_VALUEHL
42f2			 
42f2				; calc block address 
42f2			 
42f2 eb				ex de, hl 
42f3 3e 40			ld a, STORE_BLOCK_PHY 
42f5 cd 92 0b			call Mult16 
42f8			 
42f8				FORTH_DSP_POP 
42f8 cd a4 1a			call macro_forth_dsp_pop 
42fb				endm 
# End of macro FORTH_DSP_POP
42fb			 
42fb			 
42fb 11 e8 f9			ld de, store_page 
42fe			 
42fe					if DEBUG_FORTH_WORDS 
42fe						DMARK "BUe" 
42fe f5				push af  
42ff 3a 13 43			ld a, (.dmark)  
4302 32 bd fb			ld (debug_mark),a  
4305 3a 14 43			ld a, (.dmark+1)  
4308 32 be fb			ld (debug_mark+1),a  
430b 3a 15 43			ld a, (.dmark+2)  
430e 32 bf fb			ld (debug_mark+2),a  
4311 18 03			jr .pastdmark  
4313 ..			.dmark: db "BUe"  
4316 f1			.pastdmark: pop af  
4317			endm  
# End of macro DMARK
4317						CALLMONITOR 
4317 cd d3 13			call break_point_state  
431a				endm  
# End of macro CALLMONITOR
431a					endif 
431a			 
431a cd 6e 03			call storage_write_block 
431d			 
431d					NEXTW 
431d c3 5e 1b			jp macro_next 
4320				endm 
# End of macro NEXTW
4320			 
4320			.BYID: 
4320				CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
4320 3a				db WORD_SYS_CORE+38             
4321 2c 43			dw .BYNAME            
4323 05				db 4 + 1 
4324 .. 00			db "BYID",0              
4329				endm 
# End of macro CWHEAD
4329			; | BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u | TODO 
4329					NEXTW 
4329 c3 5e 1b			jp macro_next 
432c				endm 
# End of macro NEXTW
432c			.BYNAME: 
432c				CWHEAD .DIR 38 "BYNAME" 6 WORD_FLAG_CODE 
432c 3a				db WORD_SYS_CORE+38             
432d 3a 43			dw .DIR            
432f 07				db 6 + 1 
4330 .. 00			db "BYNAME",0              
4337				endm 
# End of macro CWHEAD
4337			; | BYNAME ( s -- u ) Get the file ID in the current BANK of the file named s | TODO 
4337					NEXTW 
4337 c3 5e 1b			jp macro_next 
433a				endm 
# End of macro NEXTW
433a			 
433a			.DIR: 
433a				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
433a 3a				db WORD_SYS_CORE+38             
433b 3e 44			dw .SAVE            
433d 04				db 3 + 1 
433e .. 00			db "DIR",0              
4342				endm 
# End of macro CWHEAD
4342			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
4342			 
4342					if DEBUG_FORTH_WORDS_KEY 
4342						DMARK "DIR" 
4342 f5				push af  
4343 3a 57 43			ld a, (.dmark)  
4346 32 bd fb			ld (debug_mark),a  
4349 3a 58 43			ld a, (.dmark+1)  
434c 32 be fb			ld (debug_mark+1),a  
434f 3a 59 43			ld a, (.dmark+2)  
4352 32 bf fb			ld (debug_mark+2),a  
4355 18 03			jr .pastdmark  
4357 ..			.dmark: db "DIR"  
435a f1			.pastdmark: pop af  
435b			endm  
# End of macro DMARK
435b						CALLMONITOR 
435b cd d3 13			call break_point_state  
435e				endm  
# End of macro CALLMONITOR
435e					endif 
435e cd ba 03			call storage_get_block_0 
4361			 
4361 21 e8 f9			ld hl, store_page     ; get current id count 
4364 46				ld b, (hl) 
4365 0e 00			ld c, 0    ; count of files   
4367					if DEBUG_FORTH_WORDS 
4367						DMARK "DI1" 
4367 f5				push af  
4368 3a 7c 43			ld a, (.dmark)  
436b 32 bd fb			ld (debug_mark),a  
436e 3a 7d 43			ld a, (.dmark+1)  
4371 32 be fb			ld (debug_mark+1),a  
4374 3a 7e 43			ld a, (.dmark+2)  
4377 32 bf fb			ld (debug_mark+2),a  
437a 18 03			jr .pastdmark  
437c ..			.dmark: db "DI1"  
437f f1			.pastdmark: pop af  
4380			endm  
# End of macro DMARK
4380						CALLMONITOR 
4380 cd d3 13			call break_point_state  
4383				endm  
# End of macro CALLMONITOR
4383					endif 
4383			 
4383				; check for empty drive 
4383			 
4383 3e 00			ld a, 0 
4385 b8				cp b 
4386 ca f4 43			jp z, .dirdone 
4389			 
4389				; for each of the current ids do a search for them and if found push to stack 
4389			 
4389 c5			.diritem:	push bc 
438a 21 40 00				ld hl, STORE_BLOCK_PHY 
438d 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
438f 58					ld e,b 
4390			 
4390			;		if DEBUG_FORTH_WORDS 
4390			;			DMARK "DI2" 
4390			;			CALLMONITOR 
4390			;		endif 
4390			 
4390 cd 1f 06				call storage_findnextid 
4393			 
4393			;		if DEBUG_FORTH_WORDS 
4393			;			DMARK "DI3" 
4393			;			CALLMONITOR 
4393			;		endif 
4393			 
4393					; if found hl will be non zero 
4393			 
4393 cd 38 0c				call ishlzero 
4396			;		ld a, l 
4396			;		add h 
4396			; 
4396			;		cp 0 
4396 28 59				jr z, .dirnotfound 
4398			 
4398					; increase count 
4398			 
4398 c1					pop bc	 
4399 0c					inc c 
439a c5					push bc 
439b					 
439b			 
439b					; get file header and push the file name 
439b			 
439b 11 e8 f9				ld de, store_page 
439e cd 09 03				call storage_read_block 
43a1			 
43a1					; push file id to stack 
43a1				 
43a1 3a e8 f9				ld a, (store_page) 
43a4 26 00				ld h, 0 
43a6 6f					ld l, a 
43a7 cd 6d 19				call forth_push_numhl 
43aa			 
43aa					; push extent count to stack  
43aa				 
43aa 3a ea f9				ld a, (store_page+2) 
43ad 26 00				ld h, 0 
43af 6f					ld l, a 
43b0 cd 6d 19				call forth_push_numhl 
43b3			 
43b3					; push file name 
43b3			 
43b3 21 eb f9				ld hl, store_page+3 
43b6					if DEBUG_FORTH_WORDS 
43b6						DMARK "DI5" 
43b6 f5				push af  
43b7 3a cb 43			ld a, (.dmark)  
43ba 32 bd fb			ld (debug_mark),a  
43bd 3a cc 43			ld a, (.dmark+1)  
43c0 32 be fb			ld (debug_mark+1),a  
43c3 3a cd 43			ld a, (.dmark+2)  
43c6 32 bf fb			ld (debug_mark+2),a  
43c9 18 03			jr .pastdmark  
43cb ..			.dmark: db "DI5"  
43ce f1			.pastdmark: pop af  
43cf			endm  
# End of macro DMARK
43cf						CALLMONITOR 
43cf cd d3 13			call break_point_state  
43d2				endm  
# End of macro CALLMONITOR
43d2					endif 
43d2 cd 7f 19				call forth_push_str 
43d5					if DEBUG_FORTH_WORDS 
43d5						DMARK "DI6" 
43d5 f5				push af  
43d6 3a ea 43			ld a, (.dmark)  
43d9 32 bd fb			ld (debug_mark),a  
43dc 3a eb 43			ld a, (.dmark+1)  
43df 32 be fb			ld (debug_mark+1),a  
43e2 3a ec 43			ld a, (.dmark+2)  
43e5 32 bf fb			ld (debug_mark+2),a  
43e8 18 03			jr .pastdmark  
43ea ..			.dmark: db "DI6"  
43ed f1			.pastdmark: pop af  
43ee			endm  
# End of macro DMARK
43ee						CALLMONITOR 
43ee cd d3 13			call break_point_state  
43f1				endm  
# End of macro CALLMONITOR
43f1					endif 
43f1			.dirnotfound: 
43f1 c1					pop bc     
43f2 10 95				djnz .diritem 
43f4				 
43f4			.dirdone:	 
43f4					if DEBUG_FORTH_WORDS 
43f4						DMARK "DI7" 
43f4 f5				push af  
43f5 3a 09 44			ld a, (.dmark)  
43f8 32 bd fb			ld (debug_mark),a  
43fb 3a 0a 44			ld a, (.dmark+1)  
43fe 32 be fb			ld (debug_mark+1),a  
4401 3a 0b 44			ld a, (.dmark+2)  
4404 32 bf fb			ld (debug_mark+2),a  
4407 18 03			jr .pastdmark  
4409 ..			.dmark: db "DI7"  
440c f1			.pastdmark: pop af  
440d			endm  
# End of macro DMARK
440d						CALLMONITOR 
440d cd d3 13			call break_point_state  
4410				endm  
# End of macro CALLMONITOR
4410					endif 
4410			 
4410					; push a count of the dir items found 
4410			 
4410 26 00				ld h, 0 
4412 69					ld l, c 
4413 cd 6d 19				call forth_push_numhl 
4416			 
4416					; push the bank label 
4416			 
4416 cd ba 03				call storage_get_block_0 
4419			 
4419				 
4419 21 eb f9		 		ld hl, store_page+3 
441c			 
441c					if DEBUG_FORTH_WORDS 
441c						DMARK "DI8" 
441c f5				push af  
441d 3a 31 44			ld a, (.dmark)  
4420 32 bd fb			ld (debug_mark),a  
4423 3a 32 44			ld a, (.dmark+1)  
4426 32 be fb			ld (debug_mark+1),a  
4429 3a 33 44			ld a, (.dmark+2)  
442c 32 bf fb			ld (debug_mark+2),a  
442f 18 03			jr .pastdmark  
4431 ..			.dmark: db "DI8"  
4434 f1			.pastdmark: pop af  
4435			endm  
# End of macro DMARK
4435						CALLMONITOR 
4435 cd d3 13			call break_point_state  
4438				endm  
# End of macro CALLMONITOR
4438					endif 
4438 cd 7f 19				call forth_push_str 
443b			 
443b			 
443b				 
443b					NEXTW 
443b c3 5e 1b			jp macro_next 
443e				endm 
# End of macro NEXTW
443e			.SAVE: 
443e				CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
443e 3b				db WORD_SYS_CORE+39             
443f 4a 44			dw .LOAD            
4441 05				db 4 + 1 
4442 .. 00			db "SAVE",0              
4447				endm 
# End of macro CWHEAD
4447			; | SAVE  ( w u -- )    Save user word memory to file name w on bank u | TODO 
4447					NEXTW 
4447 c3 5e 1b			jp macro_next 
444a				endm 
# End of macro NEXTW
444a			.LOAD: 
444a				CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
444a 3c				db WORD_SYS_CORE+40             
444b ac 45			dw .BSAVE            
444d 05				db 4 + 1 
444e .. 00			db "LOAD",0              
4453				endm 
# End of macro CWHEAD
4453			; | LOAD ( u -- )    Load user word memory from file id on current bank | TODO 
4453			; | | The indivdual records being loaded can be both uword word difintions or interactive commands. 
4453			; | | The LOAD command can not be used in any user words or compound lines. 
4453			 
4453					; store_openext use it. If zero it is EOF 
4453			 
4453					; read block from current stream id 
4453					; if the block does not contain zero term keep reading blocks until zero found 
4453					; push the block to stack 
4453					; save the block id to stream 
4453			 
4453			 
4453					FORTH_DSP_VALUEHL 
4453 cd 08 1a			call macro_dsp_valuehl 
4456				endm 
# End of macro FORTH_DSP_VALUEHL
4456			 
4456			;		push hl 
4456			 
4456				if DEBUG_STORESE 
4456					DMARK "LOA" 
4456 f5				push af  
4457 3a 6b 44			ld a, (.dmark)  
445a 32 bd fb			ld (debug_mark),a  
445d 3a 6c 44			ld a, (.dmark+1)  
4460 32 be fb			ld (debug_mark+1),a  
4463 3a 6d 44			ld a, (.dmark+2)  
4466 32 bf fb			ld (debug_mark+2),a  
4469 18 03			jr .pastdmark  
446b ..			.dmark: db "LOA"  
446e f1			.pastdmark: pop af  
446f			endm  
# End of macro DMARK
446f					CALLMONITOR 
446f cd d3 13			call break_point_state  
4472				endm  
# End of macro CALLMONITOR
4472				endif 
4472					FORTH_DSP_POP 
4472 cd a4 1a			call macro_forth_dsp_pop 
4475				endm 
# End of macro FORTH_DSP_POP
4475			 
4475			;		pop hl 
4475			 
4475 65					ld h, l 
4476 2e 00				ld l, 0 
4478			 
4478 e5					push hl     ; stack holds current file id and extent to work with 
4479			 
4479			 
4479 11 e8 f9				ld de, store_page      ; get block zero of file 
447c				if DEBUG_STORESE 
447c					DMARK "LO0" 
447c f5				push af  
447d 3a 91 44			ld a, (.dmark)  
4480 32 bd fb			ld (debug_mark),a  
4483 3a 92 44			ld a, (.dmark+1)  
4486 32 be fb			ld (debug_mark+1),a  
4489 3a 93 44			ld a, (.dmark+2)  
448c 32 bf fb			ld (debug_mark+2),a  
448f 18 03			jr .pastdmark  
4491 ..			.dmark: db "LO0"  
4494 f1			.pastdmark: pop af  
4495			endm  
# End of macro DMARK
4495					CALLMONITOR 
4495 cd d3 13			call break_point_state  
4498				endm  
# End of macro CALLMONITOR
4498				endif 
4498 cd 43 08				call storage_read 
449b			 
449b 3a ea f9				ld a, (store_page+2)    ; max extents for this file 
449e 32 de f9				ld  (store_openmaxext),a   ; get our limit 
44a1			 
44a1				if DEBUG_STORESE 
44a1					DMARK "LOE" 
44a1 f5				push af  
44a2 3a b6 44			ld a, (.dmark)  
44a5 32 bd fb			ld (debug_mark),a  
44a8 3a b7 44			ld a, (.dmark+1)  
44ab 32 be fb			ld (debug_mark+1),a  
44ae 3a b8 44			ld a, (.dmark+2)  
44b1 32 bf fb			ld (debug_mark+2),a  
44b4 18 03			jr .pastdmark  
44b6 ..			.dmark: db "LOE"  
44b9 f1			.pastdmark: pop af  
44ba			endm  
# End of macro DMARK
44ba					CALLMONITOR 
44ba cd d3 13			call break_point_state  
44bd				endm  
# End of macro CALLMONITOR
44bd				endif 
44bd			 
44bd			; TODO dont know why max extents are not present 
44bd			;		cp 0 
44bd			;		jp z, .loadeof     ; dont read past eof 
44bd			 
44bd			;		ld a, 1   ; start from the head of the file 
44bd			 
44bd e1			.loadline:	pop hl 
44be 23					inc hl 
44bf 3a de f9				ld  a, (store_openmaxext)   ; get our limit 
44c2				if DEBUG_STORESE 
44c2					DMARK "LOx" 
44c2 f5				push af  
44c3 3a d7 44			ld a, (.dmark)  
44c6 32 bd fb			ld (debug_mark),a  
44c9 3a d8 44			ld a, (.dmark+1)  
44cc 32 be fb			ld (debug_mark+1),a  
44cf 3a d9 44			ld a, (.dmark+2)  
44d2 32 bf fb			ld (debug_mark+2),a  
44d5 18 03			jr .pastdmark  
44d7 ..			.dmark: db "LOx"  
44da f1			.pastdmark: pop af  
44db			endm  
# End of macro DMARK
44db					CALLMONITOR 
44db cd d3 13			call break_point_state  
44de				endm  
# End of macro CALLMONITOR
44de				endif 
44de 3c					inc a 
44df bd					cp l 
44e0 ca 8a 45				jp z, .loadeof 
44e3 e5					push hl    ; save current extent 
44e4			 
44e4 11 e8 f9				ld de, store_page 
44e7			 
44e7				if DEBUG_STORESE 
44e7					DMARK "LO1" 
44e7 f5				push af  
44e8 3a fc 44			ld a, (.dmark)  
44eb 32 bd fb			ld (debug_mark),a  
44ee 3a fd 44			ld a, (.dmark+1)  
44f1 32 be fb			ld (debug_mark+1),a  
44f4 3a fe 44			ld a, (.dmark+2)  
44f7 32 bf fb			ld (debug_mark+2),a  
44fa 18 03			jr .pastdmark  
44fc ..			.dmark: db "LO1"  
44ff f1			.pastdmark: pop af  
4500			endm  
# End of macro DMARK
4500					CALLMONITOR 
4500 cd d3 13			call break_point_state  
4503				endm  
# End of macro CALLMONITOR
4503				endif 
4503 cd 43 08				call storage_read 
4506			 
4506				if DEBUG_STORESE 
4506					DMARK "LO2" 
4506 f5				push af  
4507 3a 1b 45			ld a, (.dmark)  
450a 32 bd fb			ld (debug_mark),a  
450d 3a 1c 45			ld a, (.dmark+1)  
4510 32 be fb			ld (debug_mark+1),a  
4513 3a 1d 45			ld a, (.dmark+2)  
4516 32 bf fb			ld (debug_mark+2),a  
4519 18 03			jr .pastdmark  
451b ..			.dmark: db "LO2"  
451e f1			.pastdmark: pop af  
451f			endm  
# End of macro DMARK
451f					CALLMONITOR 
451f cd d3 13			call break_point_state  
4522				endm  
# End of macro CALLMONITOR
4522				endif 
4522 cd 38 0c			call ishlzero 
4525			;	ld a, l 
4525			;	add h 
4525			;	cp 0 
4525 28 63			jr z, .loadeof 
4527			 
4527				; not eof so hl should point to data to exec 
4527			 
4527				; will need to add the FORTH_END_BUFFER flag 
4527			  
4527 21 ea f9			ld hl, store_page+2 
452a 01 ff 00			ld bc, 255 
452d 3e 00			ld a, 0 
452f ed b1			cpir 
4531				if DEBUG_STORESE 
4531					DMARK "LOt" 
4531 f5				push af  
4532 3a 46 45			ld a, (.dmark)  
4535 32 bd fb			ld (debug_mark),a  
4538 3a 47 45			ld a, (.dmark+1)  
453b 32 be fb			ld (debug_mark+1),a  
453e 3a 48 45			ld a, (.dmark+2)  
4541 32 bf fb			ld (debug_mark+2),a  
4544 18 03			jr .pastdmark  
4546 ..			.dmark: db "LOt"  
4549 f1			.pastdmark: pop af  
454a			endm  
# End of macro DMARK
454a					CALLMONITOR 
454a cd d3 13			call break_point_state  
454d				endm  
# End of macro CALLMONITOR
454d				endif 
454d 2b				dec hl 
454e 3e 20			ld a, ' ' 
4550 77				ld (hl), a 
4551 23				inc hl 
4552 77				ld (hl), a 
4553 23				inc hl 
4554 77				ld (hl), a 
4555 23				inc hl 
4556 3e 7f			ld a, FORTH_END_BUFFER 
4558 77				ld (hl), a 
4559			 
4559				; TODO handle more than a single block read 
4559			 
4559			 
4559 21 ea f9			ld hl, store_page+2 
455c			 
455c 22 b9 f2			ld (os_tok_ptr), hl 
455f			 
455f				if DEBUG_STORESE 
455f					DMARK "LO3" 
455f f5				push af  
4560 3a 74 45			ld a, (.dmark)  
4563 32 bd fb			ld (debug_mark),a  
4566 3a 75 45			ld a, (.dmark+1)  
4569 32 be fb			ld (debug_mark+1),a  
456c 3a 76 45			ld a, (.dmark+2)  
456f 32 bf fb			ld (debug_mark+2),a  
4572 18 03			jr .pastdmark  
4574 ..			.dmark: db "LO3"  
4577 f1			.pastdmark: pop af  
4578			endm  
# End of macro DMARK
4578					CALLMONITOR 
4578 cd d3 13			call break_point_state  
457b				endm  
# End of macro CALLMONITOR
457b				endif 
457b			 
457b cd ac 1b			call forthparse 
457e cd ec 1b			call forthexec 
4581 cd 03 1b			call forthexec_cleanup 
4584			 
4584				; go to next extent 
4584			 
4584				; get next block  or mark as eof 
4584 c3 bd 44			jp .loadline 
4587			 
4587			 
4587			 
4587				       NEXTW 
4587 c3 5e 1b			jp macro_next 
458a				endm 
# End of macro NEXTW
458a 3e 00		.loadeof:	ld a, 0 
458c 32 df f9				ld (store_openext), a 
458f			 
458f				if DEBUG_STORESE 
458f					DMARK "LOF" 
458f f5				push af  
4590 3a a4 45			ld a, (.dmark)  
4593 32 bd fb			ld (debug_mark),a  
4596 3a a5 45			ld a, (.dmark+1)  
4599 32 be fb			ld (debug_mark+1),a  
459c 3a a6 45			ld a, (.dmark+2)  
459f 32 bf fb			ld (debug_mark+2),a  
45a2 18 03			jr .pastdmark  
45a4 ..			.dmark: db "LOF"  
45a7 f1			.pastdmark: pop af  
45a8			endm  
# End of macro DMARK
45a8					CALLMONITOR 
45a8 cd d3 13			call break_point_state  
45ab				endm  
# End of macro CALLMONITOR
45ab				endif 
45ab c9					ret 
45ac					;NEXTW 
45ac			.BSAVE:   
45ac			 
45ac				CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
45ac 5a				db WORD_SYS_CORE+70             
45ad b9 45			dw .BLOAD            
45af 06				db 5 + 1 
45b0 .. 00			db "BSAVE",0              
45b6				endm 
# End of macro CWHEAD
45b6			; | BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes | TODO 
45b6					NEXTW 
45b6 c3 5e 1b			jp macro_next 
45b9				endm 
# End of macro NEXTW
45b9			.BLOAD: 
45b9				CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
45b9 5b				db WORD_SYS_CORE+71             
45ba c6 45			dw .SEO            
45bc 06				db 5 + 1 
45bd .. 00			db "BLOAD",0              
45c3				endm 
# End of macro CWHEAD
45c3			; | BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u | TODO 
45c3					NEXTW 
45c3 c3 5e 1b			jp macro_next 
45c6				endm 
# End of macro NEXTW
45c6			;;;; counter gap 
45c6			 
45c6			 
45c6			.SEO: 
45c6				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
45c6 64				db WORD_SYS_CORE+80             
45c7 e5 45			dw .SEI            
45c9 04				db 3 + 1 
45ca .. 00			db "SEO",0              
45ce				endm 
# End of macro CWHEAD
45ce			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
45ce			 
45ce					; get port 
45ce			 
45ce					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
45ce cd 08 1a			call macro_dsp_valuehl 
45d1				endm 
# End of macro FORTH_DSP_VALUEHL
45d1			 
45d1 e5					push hl    ; u2 - byte 
45d2			 
45d2					; destroy value TOS 
45d2			 
45d2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
45d2 cd a4 1a			call macro_forth_dsp_pop 
45d5				endm 
# End of macro FORTH_DSP_POP
45d5			 
45d5					; get byte to send 
45d5			 
45d5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
45d5 cd 08 1a			call macro_dsp_valuehl 
45d8				endm 
# End of macro FORTH_DSP_VALUEHL
45d8			 
45d8 e5					push hl    ; u1 - addr 
45d9			 
45d9					; destroy value TOS 
45d9			 
45d9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
45d9 cd a4 1a			call macro_forth_dsp_pop 
45dc				endm 
# End of macro FORTH_DSP_POP
45dc			 
45dc					; one value on hl get other one back 
45dc			 
45dc d1					pop de   ; u1 - byte 
45dd			 
45dd e1					pop hl   ; u2 - addr 
45de			 
45de					; TODO Send SPI byte 
45de			 
45de			 
45de 7b					ld a, e 
45df cd e7 01				call se_writebyte 
45e2			 
45e2					 
45e2			 
45e2					NEXTW 
45e2 c3 5e 1b			jp macro_next 
45e5				endm 
# End of macro NEXTW
45e5			 
45e5			.SEI: 
45e5				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
45e5 65				db WORD_SYS_CORE+81             
45e6 ff 45			dw .SFREE            
45e8 04				db 3 + 1 
45e9 .. 00			db "SEI",0              
45ed				endm 
# End of macro CWHEAD
45ed			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
45ed			 
45ed					; get port 
45ed			 
45ed					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
45ed cd 08 1a			call macro_dsp_valuehl 
45f0				endm 
# End of macro FORTH_DSP_VALUEHL
45f0			 
45f0			;		push hl 
45f0			 
45f0					; destroy value TOS 
45f0			 
45f0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
45f0 cd a4 1a			call macro_forth_dsp_pop 
45f3				endm 
# End of macro FORTH_DSP_POP
45f3			 
45f3					; one value on hl get other one back 
45f3			 
45f3			;		pop hl 
45f3			 
45f3			 
45f3					; TODO Get SPI byte 
45f3			 
45f3 cd 89 02				call se_readbyte 
45f6			 
45f6 26 00				ld h, 0 
45f8 6f					ld l, a 
45f9 cd 6d 19				call forth_push_numhl 
45fc			 
45fc					NEXTW 
45fc c3 5e 1b			jp macro_next 
45ff				endm 
# End of macro NEXTW
45ff			 
45ff			.SFREE: 
45ff				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
45ff 67				db WORD_SYS_CORE+83             
4600 2e 46			dw .SIZE            
4602 06				db 5 + 1 
4603 .. 00			db "FFREE",0              
4609				endm 
# End of macro CWHEAD
4609			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
4609					if DEBUG_FORTH_WORDS_KEY 
4609						DMARK "FFR" 
4609 f5				push af  
460a 3a 1e 46			ld a, (.dmark)  
460d 32 bd fb			ld (debug_mark),a  
4610 3a 1f 46			ld a, (.dmark+1)  
4613 32 be fb			ld (debug_mark+1),a  
4616 3a 20 46			ld a, (.dmark+2)  
4619 32 bf fb			ld (debug_mark+2),a  
461c 18 03			jr .pastdmark  
461e ..			.dmark: db "FFR"  
4621 f1			.pastdmark: pop af  
4622			endm  
# End of macro DMARK
4622						CALLMONITOR 
4622 cd d3 13			call break_point_state  
4625				endm  
# End of macro CALLMONITOR
4625					endif 
4625			 
4625 cd b9 06				call storage_freeblocks 
4628			 
4628 cd 6d 19				call forth_push_numhl 
462b			 
462b				       NEXTW 
462b c3 5e 1b			jp macro_next 
462e				endm 
# End of macro NEXTW
462e			.SIZE: 
462e				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
462e 67				db WORD_SYS_CORE+83             
462f 62 46			dw .CREATE            
4631 05				db 4 + 1 
4632 .. 00			db "SIZE",0              
4637				endm 
# End of macro CWHEAD
4637			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
4637					if DEBUG_FORTH_WORDS_KEY 
4637						DMARK "SIZ" 
4637 f5				push af  
4638 3a 4c 46			ld a, (.dmark)  
463b 32 bd fb			ld (debug_mark),a  
463e 3a 4d 46			ld a, (.dmark+1)  
4641 32 be fb			ld (debug_mark+1),a  
4644 3a 4e 46			ld a, (.dmark+2)  
4647 32 bf fb			ld (debug_mark+2),a  
464a 18 03			jr .pastdmark  
464c ..			.dmark: db "SIZ"  
464f f1			.pastdmark: pop af  
4650			endm  
# End of macro DMARK
4650						CALLMONITOR 
4650 cd d3 13			call break_point_state  
4653				endm  
# End of macro CALLMONITOR
4653					endif 
4653			 
4653					FORTH_DSP_VALUEHL 
4653 cd 08 1a			call macro_dsp_valuehl 
4656				endm 
# End of macro FORTH_DSP_VALUEHL
4656			;		push hl 
4656					FORTH_DSP_POP 
4656 cd a4 1a			call macro_forth_dsp_pop 
4659				endm 
# End of macro FORTH_DSP_POP
4659			;		pop hl 
4659 cd 38 03				call storage_file_size 
465c			 
465c cd 6d 19				call forth_push_numhl 
465f			  
465f			 
465f				       NEXTW 
465f c3 5e 1b			jp macro_next 
4662				endm 
# End of macro NEXTW
4662			 
4662			.CREATE: 
4662				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
4662 68				db WORD_SYS_CORE+84             
4663 d0 46			dw .APPEND            
4665 07				db 6 + 1 
4666 .. 00			db "CREATE",0              
466d				endm 
# End of macro CWHEAD
466d			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | TO TEST 
466d			; | | e.g.  
466d			; | | TestProgram CREATE 
466d			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
466d			; | |  
466d			; | | Max file IDs are 255. 
466d			; | |  
466d					 
466d					if DEBUG_FORTH_WORDS_KEY 
466d						DMARK "CRT" 
466d f5				push af  
466e 3a 82 46			ld a, (.dmark)  
4671 32 bd fb			ld (debug_mark),a  
4674 3a 83 46			ld a, (.dmark+1)  
4677 32 be fb			ld (debug_mark+1),a  
467a 3a 84 46			ld a, (.dmark+2)  
467d 32 bf fb			ld (debug_mark+2),a  
4680 18 03			jr .pastdmark  
4682 ..			.dmark: db "CRT"  
4685 f1			.pastdmark: pop af  
4686			endm  
# End of macro DMARK
4686						CALLMONITOR 
4686 cd d3 13			call break_point_state  
4689				endm  
# End of macro CALLMONITOR
4689					endif 
4689			;		call storage_get_block_0 
4689			 
4689					; TODO pop hl 
4689			 
4689					;v5 FORTH_DSP_VALUE 
4689					FORTH_DSP_VALUE 
4689 cd f1 19			call macro_forth_dsp_value 
468c				endm 
# End of macro FORTH_DSP_VALUE
468c			 
468c				if DEBUG_STORESE 
468c					DMARK "CR1" 
468c f5				push af  
468d 3a a1 46			ld a, (.dmark)  
4690 32 bd fb			ld (debug_mark),a  
4693 3a a2 46			ld a, (.dmark+1)  
4696 32 be fb			ld (debug_mark+1),a  
4699 3a a3 46			ld a, (.dmark+2)  
469c 32 bf fb			ld (debug_mark+2),a  
469f 18 03			jr .pastdmark  
46a1 ..			.dmark: db "CR1"  
46a4 f1			.pastdmark: pop af  
46a5			endm  
# End of macro DMARK
46a5					CALLMONITOR 
46a5 cd d3 13			call break_point_state  
46a8				endm  
# End of macro CALLMONITOR
46a8				endif 
46a8			;		push hl 
46a8			;		FORTH_DSP_POP 
46a8			;		pop hl 
46a8			 
46a8			;		inc hl   ; move past the type marker 
46a8			 
46a8 cd ef 06				call storage_create 
46ab			 
46ab				if DEBUG_STORESE 
46ab					DMARK "CT1" 
46ab f5				push af  
46ac 3a c0 46			ld a, (.dmark)  
46af 32 bd fb			ld (debug_mark),a  
46b2 3a c1 46			ld a, (.dmark+1)  
46b5 32 be fb			ld (debug_mark+1),a  
46b8 3a c2 46			ld a, (.dmark+2)  
46bb 32 bf fb			ld (debug_mark+2),a  
46be 18 03			jr .pastdmark  
46c0 ..			.dmark: db "CT1"  
46c3 f1			.pastdmark: pop af  
46c4			endm  
# End of macro DMARK
46c4					CALLMONITOR 
46c4 cd d3 13			call break_point_state  
46c7				endm  
# End of macro CALLMONITOR
46c7				endif 
46c7			;		push hl 
46c7					FORTH_DSP_POP 
46c7 cd a4 1a			call macro_forth_dsp_pop 
46ca				endm 
# End of macro FORTH_DSP_POP
46ca			;		pop hl 
46ca					; push file id to stack 
46ca cd 6d 19				call forth_push_numhl 
46cd			 
46cd			 
46cd			 
46cd				       NEXTW 
46cd c3 5e 1b			jp macro_next 
46d0				endm 
# End of macro NEXTW
46d0			 
46d0			.APPEND: 
46d0				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
46d0 69				db WORD_SYS_CORE+85             
46d1 61 47			dw .SDEL            
46d3 07				db 6 + 1 
46d4 .. 00			db "APPEND",0              
46db				endm 
# End of macro CWHEAD
46db			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | TO TEST 
46db			; | | e.g. 
46db			; | | Test CREATE      -> $01 
46db			; | | "A string to add to file" $01 APPEND 
46db			; | |  
46db			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
46db					if DEBUG_FORTH_WORDS_KEY 
46db						DMARK "APP" 
46db f5				push af  
46dc 3a f0 46			ld a, (.dmark)  
46df 32 bd fb			ld (debug_mark),a  
46e2 3a f1 46			ld a, (.dmark+1)  
46e5 32 be fb			ld (debug_mark+1),a  
46e8 3a f2 46			ld a, (.dmark+2)  
46eb 32 bf fb			ld (debug_mark+2),a  
46ee 18 03			jr .pastdmark  
46f0 ..			.dmark: db "APP"  
46f3 f1			.pastdmark: pop af  
46f4			endm  
# End of macro DMARK
46f4						CALLMONITOR 
46f4 cd d3 13			call break_point_state  
46f7				endm  
# End of macro CALLMONITOR
46f7					endif 
46f7			 
46f7					FORTH_DSP_VALUEHL 
46f7 cd 08 1a			call macro_dsp_valuehl 
46fa				endm 
# End of macro FORTH_DSP_VALUEHL
46fa e5					push hl 	; save file id 
46fb			 
46fb				if DEBUG_STORESE 
46fb					DMARK "AP1" 
46fb f5				push af  
46fc 3a 10 47			ld a, (.dmark)  
46ff 32 bd fb			ld (debug_mark),a  
4702 3a 11 47			ld a, (.dmark+1)  
4705 32 be fb			ld (debug_mark+1),a  
4708 3a 12 47			ld a, (.dmark+2)  
470b 32 bf fb			ld (debug_mark+2),a  
470e 18 03			jr .pastdmark  
4710 ..			.dmark: db "AP1"  
4713 f1			.pastdmark: pop af  
4714			endm  
# End of macro DMARK
4714					CALLMONITOR 
4714 cd d3 13			call break_point_state  
4717				endm  
# End of macro CALLMONITOR
4717				endif 
4717					FORTH_DSP_POP 
4717 cd a4 1a			call macro_forth_dsp_pop 
471a				endm 
# End of macro FORTH_DSP_POP
471a			 
471a					FORTH_DSP_VALUEHL 
471a cd 08 1a			call macro_dsp_valuehl 
471d				endm 
# End of macro FORTH_DSP_VALUEHL
471d					;v5 FORTH_DSP_VALUE 
471d e5					push hl 	; save ptr to string to save 
471e			 
471e				if DEBUG_STORESE 
471e					DMARK "AP1" 
471e f5				push af  
471f 3a 33 47			ld a, (.dmark)  
4722 32 bd fb			ld (debug_mark),a  
4725 3a 34 47			ld a, (.dmark+1)  
4728 32 be fb			ld (debug_mark+1),a  
472b 3a 35 47			ld a, (.dmark+2)  
472e 32 bf fb			ld (debug_mark+2),a  
4731 18 03			jr .pastdmark  
4733 ..			.dmark: db "AP1"  
4736 f1			.pastdmark: pop af  
4737			endm  
# End of macro DMARK
4737					CALLMONITOR 
4737 cd d3 13			call break_point_state  
473a				endm  
# End of macro CALLMONITOR
473a				endif 
473a					FORTH_DSP_POP 
473a cd a4 1a			call macro_forth_dsp_pop 
473d				endm 
# End of macro FORTH_DSP_POP
473d			 
473d d1					pop de 
473e e1					pop hl 
473f				if DEBUG_STORESE 
473f					DMARK "AP2" 
473f f5				push af  
4740 3a 54 47			ld a, (.dmark)  
4743 32 bd fb			ld (debug_mark),a  
4746 3a 55 47			ld a, (.dmark+1)  
4749 32 be fb			ld (debug_mark+1),a  
474c 3a 56 47			ld a, (.dmark+2)  
474f 32 bf fb			ld (debug_mark+2),a  
4752 18 03			jr .pastdmark  
4754 ..			.dmark: db "AP2"  
4757 f1			.pastdmark: pop af  
4758			endm  
# End of macro DMARK
4758					CALLMONITOR 
4758 cd d3 13			call break_point_state  
475b				endm  
# End of macro CALLMONITOR
475b				endif 
475b					;inc de ; skip var type indicator 
475b			 
475b					; TODO how to append numerics???? 
475b			 
475b cd c9 08				call storage_append		 
475e			 
475e				       NEXTW 
475e c3 5e 1b			jp macro_next 
4761				endm 
# End of macro NEXTW
4761			.SDEL: 
4761				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
4761 6a				db WORD_SYS_CORE+86             
4762 ad 47			dw .OPEN            
4764 05				db 4 + 1 
4765 .. 00			db "ERA",0              
4769				endm 
# End of macro CWHEAD
4769			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
4769					FORTH_DSP_VALUEHL 
4769 cd 08 1a			call macro_dsp_valuehl 
476c				endm 
# End of macro FORTH_DSP_VALUEHL
476c			;		push hl 	; save file id 
476c			 
476c					if DEBUG_FORTH_WORDS_KEY 
476c						DMARK "ERA" 
476c f5				push af  
476d 3a 81 47			ld a, (.dmark)  
4770 32 bd fb			ld (debug_mark),a  
4773 3a 82 47			ld a, (.dmark+1)  
4776 32 be fb			ld (debug_mark+1),a  
4779 3a 83 47			ld a, (.dmark+2)  
477c 32 bf fb			ld (debug_mark+2),a  
477f 18 03			jr .pastdmark  
4781 ..			.dmark: db "ERA"  
4784 f1			.pastdmark: pop af  
4785			endm  
# End of macro DMARK
4785						CALLMONITOR 
4785 cd d3 13			call break_point_state  
4788				endm  
# End of macro CALLMONITOR
4788					endif 
4788				if DEBUG_STORESE 
4788					DMARK "ER1" 
4788 f5				push af  
4789 3a 9d 47			ld a, (.dmark)  
478c 32 bd fb			ld (debug_mark),a  
478f 3a 9e 47			ld a, (.dmark+1)  
4792 32 be fb			ld (debug_mark+1),a  
4795 3a 9f 47			ld a, (.dmark+2)  
4798 32 bf fb			ld (debug_mark+2),a  
479b 18 03			jr .pastdmark  
479d ..			.dmark: db "ER1"  
47a0 f1			.pastdmark: pop af  
47a1			endm  
# End of macro DMARK
47a1					CALLMONITOR 
47a1 cd d3 13			call break_point_state  
47a4				endm  
# End of macro CALLMONITOR
47a4				endif 
47a4					FORTH_DSP_POP 
47a4 cd a4 1a			call macro_forth_dsp_pop 
47a7				endm 
# End of macro FORTH_DSP_POP
47a7			 
47a7			;		pop hl 
47a7			 
47a7 cd 3e 05				call storage_erase 
47aa				       NEXTW 
47aa c3 5e 1b			jp macro_next 
47ad				endm 
# End of macro NEXTW
47ad			 
47ad			.OPEN: 
47ad				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
47ad 6b				db WORD_SYS_CORE+87             
47ae 34 48			dw .READ            
47b0 05				db 4 + 1 
47b1 .. 00			db "OPEN",0              
47b6				endm 
# End of macro CWHEAD
47b6			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
47b6			; | | e.g. 
47b6			; | | $01 OPEN $01 DO $01 READ . LOOP 
47b6			 
47b6					if DEBUG_FORTH_WORDS_KEY 
47b6						DMARK "OPN" 
47b6 f5				push af  
47b7 3a cb 47			ld a, (.dmark)  
47ba 32 bd fb			ld (debug_mark),a  
47bd 3a cc 47			ld a, (.dmark+1)  
47c0 32 be fb			ld (debug_mark+1),a  
47c3 3a cd 47			ld a, (.dmark+2)  
47c6 32 bf fb			ld (debug_mark+2),a  
47c9 18 03			jr .pastdmark  
47cb ..			.dmark: db "OPN"  
47ce f1			.pastdmark: pop af  
47cf			endm  
# End of macro DMARK
47cf						CALLMONITOR 
47cf cd d3 13			call break_point_state  
47d2				endm  
# End of macro CALLMONITOR
47d2					endif 
47d2					; TODO handle multiple file opens 
47d2			 
47d2 3e 01			       	ld a, 1 
47d4 32 df f9				ld (store_openext), a 
47d7			 
47d7					; get max extents for this file 
47d7				 
47d7								 
47d7					FORTH_DSP_VALUEHL 
47d7 cd 08 1a			call macro_dsp_valuehl 
47da				endm 
# End of macro FORTH_DSP_VALUEHL
47da			 
47da 65					ld h, l 
47db 2e 00				ld l, 0 
47dd			 
47dd				if DEBUG_STORESE 
47dd					DMARK "OPN" 
47dd f5				push af  
47de 3a f2 47			ld a, (.dmark)  
47e1 32 bd fb			ld (debug_mark),a  
47e4 3a f3 47			ld a, (.dmark+1)  
47e7 32 be fb			ld (debug_mark+1),a  
47ea 3a f4 47			ld a, (.dmark+2)  
47ed 32 bf fb			ld (debug_mark+2),a  
47f0 18 03			jr .pastdmark  
47f2 ..			.dmark: db "OPN"  
47f5 f1			.pastdmark: pop af  
47f6			endm  
# End of macro DMARK
47f6					CALLMONITOR 
47f6 cd d3 13			call break_point_state  
47f9				endm  
# End of macro CALLMONITOR
47f9				endif 
47f9			;		push hl 
47f9					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
47f9 cd a4 1a			call macro_forth_dsp_pop 
47fc				endm 
# End of macro FORTH_DSP_POP
47fc			;		pop hl 
47fc						 
47fc 11 e8 f9				ld de, store_page      ; get block zero of file 
47ff cd 43 08				call storage_read 
4802			 
4802			 
4802 3a ea f9				ld a, (store_page+2)    ; max extents for this file 
4805 32 de f9				ld  (store_openmaxext), a   ; get our limit and push 
4808					 
4808				if DEBUG_STORESE 
4808					DMARK "OPx" 
4808 f5				push af  
4809 3a 1d 48			ld a, (.dmark)  
480c 32 bd fb			ld (debug_mark),a  
480f 3a 1e 48			ld a, (.dmark+1)  
4812 32 be fb			ld (debug_mark+1),a  
4815 3a 1f 48			ld a, (.dmark+2)  
4818 32 bf fb			ld (debug_mark+2),a  
481b 18 03			jr .pastdmark  
481d ..			.dmark: db "OPx"  
4820 f1			.pastdmark: pop af  
4821			endm  
# End of macro DMARK
4821					CALLMONITOR 
4821 cd d3 13			call break_point_state  
4824				endm  
# End of macro CALLMONITOR
4824				endif 
4824 fe 00				cp 0 
4826 20 03				jr nz, .skipopeneof 
4828					; have opened an empty file 
4828					 
4828 32 df f9				ld (store_openext), a 
482b			 
482b			.skipopeneof: 
482b			 
482b 6f					ld l, a 
482c 26 00				ld h, 0 
482e cd 6d 19				call forth_push_numhl 
4831			 
4831			 
4831				       NEXTW 
4831 c3 5e 1b			jp macro_next 
4834				endm 
# End of macro NEXTW
4834			.READ: 
4834				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
4834 6c				db WORD_SYS_CORE+88             
4835 7b 49			dw .EOF            
4837 05				db 4 + 1 
4838 .. 00			db "READ",0              
483d				endm 
# End of macro CWHEAD
483d			; | READ ( n -- n  )  Reads next page of file id and push to stack | DONE 
483d			; | | e.g. 
483d			; | | $01 OPEN $01 DO $01 READ . LOOP 
483d			 
483d					if DEBUG_FORTH_WORDS_KEY 
483d						DMARK "REA" 
483d f5				push af  
483e 3a 52 48			ld a, (.dmark)  
4841 32 bd fb			ld (debug_mark),a  
4844 3a 53 48			ld a, (.dmark+1)  
4847 32 be fb			ld (debug_mark+1),a  
484a 3a 54 48			ld a, (.dmark+2)  
484d 32 bf fb			ld (debug_mark+2),a  
4850 18 03			jr .pastdmark  
4852 ..			.dmark: db "REA"  
4855 f1			.pastdmark: pop af  
4856			endm  
# End of macro DMARK
4856						CALLMONITOR 
4856 cd d3 13			call break_point_state  
4859				endm  
# End of macro CALLMONITOR
4859					endif 
4859					; store_openext use it. If zero it is EOF 
4859			 
4859					; read block from current stream id 
4859					; if the block does not contain zero term keep reading blocks until zero found 
4859					; push the block to stack 
4859					; save the block id to stream 
4859			 
4859			 
4859					FORTH_DSP_VALUEHL 
4859 cd 08 1a			call macro_dsp_valuehl 
485c				endm 
# End of macro FORTH_DSP_VALUEHL
485c			 
485c			;		push hl 
485c			 
485c				if DEBUG_STORESE 
485c					DMARK "REA" 
485c f5				push af  
485d 3a 71 48			ld a, (.dmark)  
4860 32 bd fb			ld (debug_mark),a  
4863 3a 72 48			ld a, (.dmark+1)  
4866 32 be fb			ld (debug_mark+1),a  
4869 3a 73 48			ld a, (.dmark+2)  
486c 32 bf fb			ld (debug_mark+2),a  
486f 18 03			jr .pastdmark  
4871 ..			.dmark: db "REA"  
4874 f1			.pastdmark: pop af  
4875			endm  
# End of macro DMARK
4875					CALLMONITOR 
4875 cd d3 13			call break_point_state  
4878				endm  
# End of macro CALLMONITOR
4878				endif 
4878					FORTH_DSP_POP 
4878 cd a4 1a			call macro_forth_dsp_pop 
487b				endm 
# End of macro FORTH_DSP_POP
487b			 
487b			;		pop hl 
487b				 
487b 65					ld h,l 
487c			 
487c 3a df f9				ld a, (store_openext) 
487f 6f					ld l, a 
4880					 
4880 fe 00				cp 0 
4882 ca 4d 49				jp z, .ateof     ; dont read past eof 
4885			 
4885			 
4885 11 e8 f9				ld de, store_page 
4888				if DEBUG_STORESE 
4888					DMARK "RE1" 
4888 f5				push af  
4889 3a 9d 48			ld a, (.dmark)  
488c 32 bd fb			ld (debug_mark),a  
488f 3a 9e 48			ld a, (.dmark+1)  
4892 32 be fb			ld (debug_mark+1),a  
4895 3a 9f 48			ld a, (.dmark+2)  
4898 32 bf fb			ld (debug_mark+2),a  
489b 18 03			jr .pastdmark  
489d ..			.dmark: db "RE1"  
48a0 f1			.pastdmark: pop af  
48a1			endm  
# End of macro DMARK
48a1					CALLMONITOR 
48a1 cd d3 13			call break_point_state  
48a4				endm  
# End of macro CALLMONITOR
48a4				endif 
48a4 cd 43 08				call storage_read 
48a7			 
48a7				if DEBUG_STORESE 
48a7					DMARK "RE2" 
48a7 f5				push af  
48a8 3a bc 48			ld a, (.dmark)  
48ab 32 bd fb			ld (debug_mark),a  
48ae 3a bd 48			ld a, (.dmark+1)  
48b1 32 be fb			ld (debug_mark+1),a  
48b4 3a be 48			ld a, (.dmark+2)  
48b7 32 bf fb			ld (debug_mark+2),a  
48ba 18 03			jr .pastdmark  
48bc ..			.dmark: db "RE2"  
48bf f1			.pastdmark: pop af  
48c0			endm  
# End of macro DMARK
48c0					CALLMONITOR 
48c0 cd d3 13			call break_point_state  
48c3				endm  
# End of macro CALLMONITOR
48c3				endif 
48c3 cd 38 0c			call ishlzero 
48c6			;	ld a, l 
48c6			;	add h 
48c6			;	cp 0 
48c6 ca 53 49			jp z, .readeof 
48c9			 
48c9				; not eof so hl should point to data to push to stack 
48c9			 
48c9				if DEBUG_STORESE 
48c9					DMARK "RE3" 
48c9 f5				push af  
48ca 3a de 48			ld a, (.dmark)  
48cd 32 bd fb			ld (debug_mark),a  
48d0 3a df 48			ld a, (.dmark+1)  
48d3 32 be fb			ld (debug_mark+1),a  
48d6 3a e0 48			ld a, (.dmark+2)  
48d9 32 bf fb			ld (debug_mark+2),a  
48dc 18 03			jr .pastdmark  
48de ..			.dmark: db "RE3"  
48e1 f1			.pastdmark: pop af  
48e2			endm  
# End of macro DMARK
48e2					CALLMONITOR 
48e2 cd d3 13			call break_point_state  
48e5				endm  
# End of macro CALLMONITOR
48e5				endif 
48e5 cd 7f 19			call forth_push_str 
48e8			 
48e8				if DEBUG_STORESE 
48e8					DMARK "RE4" 
48e8 f5				push af  
48e9 3a fd 48			ld a, (.dmark)  
48ec 32 bd fb			ld (debug_mark),a  
48ef 3a fe 48			ld a, (.dmark+1)  
48f2 32 be fb			ld (debug_mark+1),a  
48f5 3a ff 48			ld a, (.dmark+2)  
48f8 32 bf fb			ld (debug_mark+2),a  
48fb 18 03			jr .pastdmark  
48fd ..			.dmark: db "RE4"  
4900 f1			.pastdmark: pop af  
4901			endm  
# End of macro DMARK
4901					CALLMONITOR 
4901 cd d3 13			call break_point_state  
4904				endm  
# End of macro CALLMONITOR
4904				endif 
4904				; get next block  or mark as eof 
4904			 
4904 3a de f9			ld a, (store_openmaxext)   ; get our limit 
4907 4f				ld c, a	 
4908 3a df f9			ld a, (store_openext) 
490b			 
490b				if DEBUG_STORESE 
490b					DMARK "RE5" 
490b f5				push af  
490c 3a 20 49			ld a, (.dmark)  
490f 32 bd fb			ld (debug_mark),a  
4912 3a 21 49			ld a, (.dmark+1)  
4915 32 be fb			ld (debug_mark+1),a  
4918 3a 22 49			ld a, (.dmark+2)  
491b 32 bf fb			ld (debug_mark+2),a  
491e 18 03			jr .pastdmark  
4920 ..			.dmark: db "RE5"  
4923 f1			.pastdmark: pop af  
4924			endm  
# End of macro DMARK
4924					CALLMONITOR 
4924 cd d3 13			call break_point_state  
4927				endm  
# End of macro CALLMONITOR
4927				endif 
4927 b9				cp c 
4928 28 29			jr z, .readeof     ; at last extent 
492a			 
492a 3c					inc a 
492b 32 df f9				ld (store_openext), a 
492e			 
492e				if DEBUG_STORESE 
492e					DMARK "RE6" 
492e f5				push af  
492f 3a 43 49			ld a, (.dmark)  
4932 32 bd fb			ld (debug_mark),a  
4935 3a 44 49			ld a, (.dmark+1)  
4938 32 be fb			ld (debug_mark+1),a  
493b 3a 45 49			ld a, (.dmark+2)  
493e 32 bf fb			ld (debug_mark+2),a  
4941 18 03			jr .pastdmark  
4943 ..			.dmark: db "RE6"  
4946 f1			.pastdmark: pop af  
4947			endm  
# End of macro DMARK
4947					CALLMONITOR 
4947 cd d3 13			call break_point_state  
494a				endm  
# End of macro CALLMONITOR
494a				endif 
494a			 
494a			 
494a				       NEXTW 
494a c3 5e 1b			jp macro_next 
494d				endm 
# End of macro NEXTW
494d			.ateof: 
494d 21 77 49				ld hl, .showeof 
4950 cd 7f 19				call forth_push_str 
4953 3e 00		.readeof:	ld a, 0 
4955 32 df f9				ld (store_openext), a 
4958			 
4958					 
4958				if DEBUG_STORESE 
4958					DMARK "REF" 
4958 f5				push af  
4959 3a 6d 49			ld a, (.dmark)  
495c 32 bd fb			ld (debug_mark),a  
495f 3a 6e 49			ld a, (.dmark+1)  
4962 32 be fb			ld (debug_mark+1),a  
4965 3a 6f 49			ld a, (.dmark+2)  
4968 32 bf fb			ld (debug_mark+2),a  
496b 18 03			jr .pastdmark  
496d ..			.dmark: db "REF"  
4970 f1			.pastdmark: pop af  
4971			endm  
# End of macro DMARK
4971					CALLMONITOR 
4971 cd d3 13			call break_point_state  
4974				endm  
# End of macro CALLMONITOR
4974				endif 
4974				       NEXTW 
4974 c3 5e 1b			jp macro_next 
4977				endm 
# End of macro NEXTW
4977			 
4977 .. 00		.showeof:   db "eof", 0 
497b			 
497b			 
497b			.EOF: 
497b				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
497b 6d				db WORD_SYS_CORE+89             
497c bc 49			dw .FORMAT            
497e 04				db 3 + 1 
497f .. 00			db "EOF",0              
4983				endm 
# End of macro CWHEAD
4983			; | EOF ( n -- u )  Returns EOF logical state of file id n - CURRENTLY n IS IGNORED AND ONLY ONE STREAM IS SUPPORTED | DONE 
4983			; | | e.g. 
4983			; | | $01 OPEN REPEAT $01 READ $01 EOF $00 IF LOOP 
4983					; TODO if current block id for stream is zero then push true else false 
4983			 
4983					if DEBUG_FORTH_WORDS_KEY 
4983						DMARK "EOF" 
4983 f5				push af  
4984 3a 98 49			ld a, (.dmark)  
4987 32 bd fb			ld (debug_mark),a  
498a 3a 99 49			ld a, (.dmark+1)  
498d 32 be fb			ld (debug_mark+1),a  
4990 3a 9a 49			ld a, (.dmark+2)  
4993 32 bf fb			ld (debug_mark+2),a  
4996 18 03			jr .pastdmark  
4998 ..			.dmark: db "EOF"  
499b f1			.pastdmark: pop af  
499c			endm  
# End of macro DMARK
499c						CALLMONITOR 
499c cd d3 13			call break_point_state  
499f				endm  
# End of macro CALLMONITOR
499f					endif 
499f			 
499f					; TODO handlue multiple file streams 
499f			 
499f					FORTH_DSP_POP     ; for now just get rid of stream id 
499f cd a4 1a			call macro_forth_dsp_pop 
49a2				endm 
# End of macro FORTH_DSP_POP
49a2			 
49a2 2e 01				ld l, 1 
49a4 3a de f9				ld a, (store_openmaxext) 
49a7 fe 00				cp 0 
49a9 28 09				jr  z, .eofdone   ; empty file 
49ab 3a df f9				ld a, (store_openext) 
49ae fe 00				cp 0 
49b0 28 02				jr  z, .eofdone 
49b2 2e 00				ld l, 0 
49b4 26 00		.eofdone:	ld h, 0 
49b6 cd 6d 19				call forth_push_numhl 
49b9			 
49b9			 
49b9				       NEXTW 
49b9 c3 5e 1b			jp macro_next 
49bc				endm 
# End of macro NEXTW
49bc			 
49bc			.FORMAT: 
49bc				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
49bc 6d				db WORD_SYS_CORE+89             
49bd 0d 4a			dw .LABEL            
49bf 07				db 6 + 1 
49c0 .. 00			db "FORMAT",0              
49c7				endm 
# End of macro CWHEAD
49c7			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
49c7					; TODO if current block id for stream is zero then push true else false 
49c7				 
49c7				if DEBUG_STORESE 
49c7					DMARK "FOR" 
49c7 f5				push af  
49c8 3a dc 49			ld a, (.dmark)  
49cb 32 bd fb			ld (debug_mark),a  
49ce 3a dd 49			ld a, (.dmark+1)  
49d1 32 be fb			ld (debug_mark+1),a  
49d4 3a de 49			ld a, (.dmark+2)  
49d7 32 bf fb			ld (debug_mark+2),a  
49da 18 03			jr .pastdmark  
49dc ..			.dmark: db "FOR"  
49df f1			.pastdmark: pop af  
49e0			endm  
# End of macro DMARK
49e0					CALLMONITOR 
49e0 cd d3 13			call break_point_state  
49e3				endm  
# End of macro CALLMONITOR
49e3				endif 
49e3					; Wipes the bank check flags to cause a reformat on next block 0 read 
49e3			 
49e3 21 01 00				ld hl, 1 
49e6 3e 00				ld a, 0 
49e8 cd e7 01				call se_writebyte 
49eb			 
49eb				if DEBUG_STORESE 
49eb					DMARK "FO0" 
49eb f5				push af  
49ec 3a 00 4a			ld a, (.dmark)  
49ef 32 bd fb			ld (debug_mark),a  
49f2 3a 01 4a			ld a, (.dmark+1)  
49f5 32 be fb			ld (debug_mark+1),a  
49f8 3a 02 4a			ld a, (.dmark+2)  
49fb 32 bf fb			ld (debug_mark+2),a  
49fe 18 03			jr .pastdmark  
4a00 ..			.dmark: db "FO0"  
4a03 f1			.pastdmark: pop af  
4a04			endm  
# End of macro DMARK
4a04					CALLMONITOR 
4a04 cd d3 13			call break_point_state  
4a07				endm  
# End of macro CALLMONITOR
4a07				endif 
4a07					; force bank init 
4a07			 
4a07 cd ba 03				call storage_get_block_0 
4a0a					 
4a0a				       NEXTW 
4a0a c3 5e 1b			jp macro_next 
4a0d				endm 
# End of macro NEXTW
4a0d			.LABEL: 
4a0d				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
4a0d 6d				db WORD_SYS_CORE+89             
4a0e 5b 4a			dw .STOREPAGE            
4a10 06				db 5 + 1 
4a11 .. 00			db "LABEL",0              
4a17				endm 
# End of macro CWHEAD
4a17			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
4a17					; TODO test to see if bank is selected 
4a17				 
4a17					if DEBUG_FORTH_WORDS_KEY 
4a17						DMARK "LBL" 
4a17 f5				push af  
4a18 3a 2c 4a			ld a, (.dmark)  
4a1b 32 bd fb			ld (debug_mark),a  
4a1e 3a 2d 4a			ld a, (.dmark+1)  
4a21 32 be fb			ld (debug_mark+1),a  
4a24 3a 2e 4a			ld a, (.dmark+2)  
4a27 32 bf fb			ld (debug_mark+2),a  
4a2a 18 03			jr .pastdmark  
4a2c ..			.dmark: db "LBL"  
4a2f f1			.pastdmark: pop af  
4a30			endm  
# End of macro DMARK
4a30						CALLMONITOR 
4a30 cd d3 13			call break_point_state  
4a33				endm  
# End of macro CALLMONITOR
4a33					endif 
4a33			;	if DEBUG_STORESE 
4a33			;		DMARK "LBL" 
4a33			;		CALLMONITOR 
4a33			;	endif 
4a33					FORTH_DSP_VALUEHL 
4a33 cd 08 1a			call macro_dsp_valuehl 
4a36				endm 
# End of macro FORTH_DSP_VALUEHL
4a36					;v5FORTH_DSP_VALUE 
4a36					 
4a36			;		push hl 
4a36					FORTH_DSP_POP 
4a36 cd a4 1a			call macro_forth_dsp_pop 
4a39				endm 
# End of macro FORTH_DSP_POP
4a39			;		pop hl 
4a39			 
4a39			;v5		inc hl   ; move past the type marker 
4a39			 
4a39				if DEBUG_STORESE 
4a39					DMARK "LBl" 
4a39 f5				push af  
4a3a 3a 4e 4a			ld a, (.dmark)  
4a3d 32 bd fb			ld (debug_mark),a  
4a40 3a 4f 4a			ld a, (.dmark+1)  
4a43 32 be fb			ld (debug_mark+1),a  
4a46 3a 50 4a			ld a, (.dmark+2)  
4a49 32 bf fb			ld (debug_mark+2),a  
4a4c 18 03			jr .pastdmark  
4a4e ..			.dmark: db "LBl"  
4a51 f1			.pastdmark: pop af  
4a52			endm  
# End of macro DMARK
4a52					CALLMONITOR 
4a52 cd d3 13			call break_point_state  
4a55				endm  
# End of macro CALLMONITOR
4a55				endif 
4a55 cd d3 04				call storage_label 
4a58			 
4a58				       NEXTW 
4a58 c3 5e 1b			jp macro_next 
4a5b				endm 
# End of macro NEXTW
4a5b			.STOREPAGE: 
4a5b				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
4a5b 6d				db WORD_SYS_CORE+89             
4a5c 8e 4a			dw .LABELS            
4a5e 0a				db 9 + 1 
4a5f .. 00			db "STOREPAGE",0              
4a69				endm 
# End of macro CWHEAD
4a69			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
4a69					; TODO test to see if bank is selected 
4a69				 
4a69					if DEBUG_FORTH_WORDS_KEY 
4a69						DMARK "STP" 
4a69 f5				push af  
4a6a 3a 7e 4a			ld a, (.dmark)  
4a6d 32 bd fb			ld (debug_mark),a  
4a70 3a 7f 4a			ld a, (.dmark+1)  
4a73 32 be fb			ld (debug_mark+1),a  
4a76 3a 80 4a			ld a, (.dmark+2)  
4a79 32 bf fb			ld (debug_mark+2),a  
4a7c 18 03			jr .pastdmark  
4a7e ..			.dmark: db "STP"  
4a81 f1			.pastdmark: pop af  
4a82			endm  
# End of macro DMARK
4a82						CALLMONITOR 
4a82 cd d3 13			call break_point_state  
4a85				endm  
# End of macro CALLMONITOR
4a85					endif 
4a85			;	if DEBUG_STORESE 
4a85			;		DMARK "STP" 
4a85			;		CALLMONITOR 
4a85			;	endif 
4a85			 
4a85 21 e8 f9			ld hl, store_page 
4a88 cd 6d 19			call forth_push_numhl 
4a8b			 
4a8b			 
4a8b				       NEXTW 
4a8b c3 5e 1b			jp macro_next 
4a8e				endm 
# End of macro NEXTW
4a8e			.LABELS: 
4a8e				CWHEAD .ENDSTORAGE 89 "LABELS" 6 WORD_FLAG_CODE 
4a8e 6d				db WORD_SYS_CORE+89             
4a8f 18 4b			dw .ENDSTORAGE            
4a91 07				db 6 + 1 
4a92 .. 00			db "LABELS",0              
4a99				endm 
# End of macro CWHEAD
4a99			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | TO TEST 
4a99					;  
4a99			 
4a99					; save the current device selected to restore afterwards 
4a99				 
4a99 3a e2 f9				ld a, (spi_device) 
4a9c f5					push af 
4a9d			 
4a9d			 
4a9d					; run through each of the banks 
4a9d			 
4a9d 21 01 00				ld hl, 1 
4aa0 cd 6d 19				call forth_push_numhl 
4aa3 3e ff				ld a, SPI_CE_HIGH 
4aa5 cb 87				res SPI_CE0, a 
4aa7 32 e2 f9				ld (spi_device), a 
4aaa cd ba 03				call storage_get_block_0 
4aad 21 eb f9				ld hl, store_page+3 
4ab0 cd 7f 19				call forth_push_str 
4ab3			 
4ab3					 
4ab3 21 02 00				ld hl, 2 
4ab6 cd 6d 19				call forth_push_numhl 
4ab9 3e ff				ld a, SPI_CE_HIGH 
4abb cb 8f				res SPI_CE1, a 
4abd 32 e2 f9				ld (spi_device), a 
4ac0 cd ba 03				call storage_get_block_0 
4ac3 21 eb f9				ld hl, store_page+3 
4ac6 cd 7f 19				call forth_push_str 
4ac9			 
4ac9					 
4ac9 21 03 00				ld hl, 3 
4acc cd 6d 19				call forth_push_numhl 
4acf 3e ff				ld a, SPI_CE_HIGH 
4ad1 cb 97				res SPI_CE2, a 
4ad3 32 e2 f9				ld (spi_device), a 
4ad6 cd ba 03				call storage_get_block_0 
4ad9 21 eb f9				ld hl, store_page+3 
4adc cd 7f 19				call forth_push_str 
4adf			 
4adf			 
4adf 21 04 00				ld hl, 4 
4ae2 cd 6d 19				call forth_push_numhl 
4ae5 3e ff				ld a, SPI_CE_HIGH 
4ae7 cb 9f				res SPI_CE3, a 
4ae9 32 e2 f9				ld (spi_device), a 
4aec cd ba 03				call storage_get_block_0 
4aef 21 eb f9				ld hl, store_page+3 
4af2 cd 7f 19				call forth_push_str 
4af5			 
4af5					 
4af5			 
4af5 21 05 00				ld hl, 5 
4af8 cd 6d 19				call forth_push_numhl 
4afb 3e ff				ld a, SPI_CE_HIGH 
4afd cb a7				res SPI_CE4, a 
4aff 32 e2 f9				ld (spi_device), a 
4b02 cd ba 03				call storage_get_block_0 
4b05 21 eb f9				ld hl, store_page+3 
4b08 cd 7f 19				call forth_push_str 
4b0b			 
4b0b					 
4b0b					; push fixed count of storage devices (on board) for now 
4b0b			 
4b0b 21 05 00				ld hl, 5 
4b0e cd 6d 19				call forth_push_numhl 
4b11			 
4b11					; restore selected device  
4b11				 
4b11 f1					pop af 
4b12 32 e2 f9				ld (spi_device), a 
4b15			 
4b15				       NEXTW 
4b15 c3 5e 1b			jp macro_next 
4b18				endm 
# End of macro NEXTW
4b18			 
4b18			.ENDSTORAGE: 
4b18			; eof 
# End of file forth_words_storage.asm
4b18			endif 
4b18				include "forth_words_device.asm" 
4b18			; Device related words 
4b18			 
4b18			; | ## Device Words 
4b18			 
4b18			if SOUND_ENABLE 
4b18			.NOTE: 
4b18				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
4b18			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
4b18					if DEBUG_FORTH_WORDS_KEY 
4b18						DMARK "NTE" 
4b18						CALLMONITOR 
4b18					endif 
4b18			 
4b18				 
4b18			 
4b18					NEXTW 
4b18			.AFTERSOUND: 
4b18			endif 
4b18			 
4b18			 
4b18			USE_GPIO: equ 0 
4b18			 
4b18			if USE_GPIO 
4b18			.GP1: 
4b18				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
4b18			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
4b18					NEXTW 
4b18			.GP2: 
4b18				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
4b18			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
4b18			 
4b18					NEXTW 
4b18			 
4b18			.GP3: 
4b18				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
4b18			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
4b18			 
4b18					NEXTW 
4b18			 
4b18			.GP4: 
4b18				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
4b18			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
4b18			 
4b18					NEXTW 
4b18			.SIN: 
4b18			 
4b18			 
4b18			endif 
4b18			 
4b18			 
4b18				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
4b18 33				db WORD_SYS_CORE+31             
4b19 4d 4b			dw .SOUT            
4b1b 03				db 2 + 1 
4b1c .. 00			db "IN",0              
4b1f				endm 
# End of macro CWHEAD
4b1f			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
4b1f					if DEBUG_FORTH_WORDS_KEY 
4b1f						DMARK "IN." 
4b1f f5				push af  
4b20 3a 34 4b			ld a, (.dmark)  
4b23 32 bd fb			ld (debug_mark),a  
4b26 3a 35 4b			ld a, (.dmark+1)  
4b29 32 be fb			ld (debug_mark+1),a  
4b2c 3a 36 4b			ld a, (.dmark+2)  
4b2f 32 bf fb			ld (debug_mark+2),a  
4b32 18 03			jr .pastdmark  
4b34 ..			.dmark: db "IN."  
4b37 f1			.pastdmark: pop af  
4b38			endm  
# End of macro DMARK
4b38						CALLMONITOR 
4b38 cd d3 13			call break_point_state  
4b3b				endm  
# End of macro CALLMONITOR
4b3b					endif 
4b3b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b3b cd 08 1a			call macro_dsp_valuehl 
4b3e				endm 
# End of macro FORTH_DSP_VALUEHL
4b3e			 
4b3e e5					push hl 
4b3f			 
4b3f					; destroy value TOS 
4b3f			 
4b3f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b3f cd a4 1a			call macro_forth_dsp_pop 
4b42				endm 
# End of macro FORTH_DSP_POP
4b42			 
4b42					; one value on hl get other one back 
4b42			 
4b42 c1					pop bc 
4b43			 
4b43					; do the sub 
4b43			;		ex de, hl 
4b43			 
4b43 ed 68				in l,(c) 
4b45			 
4b45					; save it 
4b45			 
4b45 26 00				ld h,0 
4b47			 
4b47					; TODO push value back onto stack for another op etc 
4b47			 
4b47 cd 6d 19				call forth_push_numhl 
4b4a					NEXTW 
4b4a c3 5e 1b			jp macro_next 
4b4d				endm 
# End of macro NEXTW
4b4d			.SOUT: 
4b4d				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
4b4d 34				db WORD_SYS_CORE+32             
4b4e a0 4b			dw .SPIO            
4b50 04				db 3 + 1 
4b51 .. 00			db "OUT",0              
4b55				endm 
# End of macro CWHEAD
4b55			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
4b55					if DEBUG_FORTH_WORDS_KEY 
4b55						DMARK "OUT" 
4b55 f5				push af  
4b56 3a 6a 4b			ld a, (.dmark)  
4b59 32 bd fb			ld (debug_mark),a  
4b5c 3a 6b 4b			ld a, (.dmark+1)  
4b5f 32 be fb			ld (debug_mark+1),a  
4b62 3a 6c 4b			ld a, (.dmark+2)  
4b65 32 bf fb			ld (debug_mark+2),a  
4b68 18 03			jr .pastdmark  
4b6a ..			.dmark: db "OUT"  
4b6d f1			.pastdmark: pop af  
4b6e			endm  
# End of macro DMARK
4b6e						CALLMONITOR 
4b6e cd d3 13			call break_point_state  
4b71				endm  
# End of macro CALLMONITOR
4b71					endif 
4b71			 
4b71					; get port 
4b71			 
4b71					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b71 cd 08 1a			call macro_dsp_valuehl 
4b74				endm 
# End of macro FORTH_DSP_VALUEHL
4b74			 
4b74 e5					push hl 
4b75			 
4b75					; destroy value TOS 
4b75			 
4b75					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b75 cd a4 1a			call macro_forth_dsp_pop 
4b78				endm 
# End of macro FORTH_DSP_POP
4b78			 
4b78					; get byte to send 
4b78			 
4b78					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b78 cd 08 1a			call macro_dsp_valuehl 
4b7b				endm 
# End of macro FORTH_DSP_VALUEHL
4b7b			 
4b7b			;		push hl 
4b7b			 
4b7b					; destroy value TOS 
4b7b			 
4b7b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b7b cd a4 1a			call macro_forth_dsp_pop 
4b7e				endm 
# End of macro FORTH_DSP_POP
4b7e			 
4b7e					; one value on hl get other one back 
4b7e			 
4b7e			;		pop hl 
4b7e			 
4b7e c1					pop bc 
4b7f			 
4b7f					if DEBUG_FORTH_WORDS 
4b7f						DMARK "OUT" 
4b7f f5				push af  
4b80 3a 94 4b			ld a, (.dmark)  
4b83 32 bd fb			ld (debug_mark),a  
4b86 3a 95 4b			ld a, (.dmark+1)  
4b89 32 be fb			ld (debug_mark+1),a  
4b8c 3a 96 4b			ld a, (.dmark+2)  
4b8f 32 bf fb			ld (debug_mark+2),a  
4b92 18 03			jr .pastdmark  
4b94 ..			.dmark: db "OUT"  
4b97 f1			.pastdmark: pop af  
4b98			endm  
# End of macro DMARK
4b98						CALLMONITOR 
4b98 cd d3 13			call break_point_state  
4b9b				endm  
# End of macro CALLMONITOR
4b9b					endif 
4b9b			 
4b9b ed 69				out (c), l 
4b9d			 
4b9d					NEXTW 
4b9d c3 5e 1b			jp macro_next 
4ba0				endm 
# End of macro NEXTW
4ba0			 
4ba0			 
4ba0			.SPIO: 
4ba0			 
4ba0			if STORAGE_SE 
4ba0				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
4ba0 51				db WORD_SYS_CORE+61             
4ba1 b1 4b			dw .SPICEH            
4ba3 07				db 6 + 1 
4ba4 .. 00			db "SPICEL",0              
4bab				endm 
# End of macro CWHEAD
4bab			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
4bab			 
4bab cd 95 01				call spi_ce_low 
4bae			    NEXTW 
4bae c3 5e 1b			jp macro_next 
4bb1				endm 
# End of macro NEXTW
4bb1			 
4bb1			.SPICEH: 
4bb1				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
4bb1 51				db WORD_SYS_CORE+61             
4bb2 c2 4b			dw .SPIOb            
4bb4 07				db 6 + 1 
4bb5 .. 00			db "SPICEH",0              
4bbc				endm 
# End of macro CWHEAD
4bbc			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
4bbc			 
4bbc cd 84 01				call spi_ce_high 
4bbf			    NEXTW 
4bbf c3 5e 1b			jp macro_next 
4bc2				endm 
# End of macro NEXTW
4bc2			 
4bc2			 
4bc2			.SPIOb: 
4bc2			 
4bc2				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
4bc2 51				db WORD_SYS_CORE+61             
4bc3 d8 4b			dw .SPII            
4bc5 05				db 4 + 1 
4bc6 .. 00			db "SPIO",0              
4bcb				endm 
# End of macro CWHEAD
4bcb			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
4bcb			 
4bcb					; get port 
4bcb			 
4bcb			 
4bcb					; get byte to send 
4bcb			 
4bcb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4bcb cd 08 1a			call macro_dsp_valuehl 
4bce				endm 
# End of macro FORTH_DSP_VALUEHL
4bce			 
4bce			;		push hl    ; u1  
4bce			 
4bce					; destroy value TOS 
4bce			 
4bce					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4bce cd a4 1a			call macro_forth_dsp_pop 
4bd1				endm 
# End of macro FORTH_DSP_POP
4bd1			 
4bd1					; one value on hl get other one back 
4bd1			 
4bd1			;		pop hl   ; u2 - addr 
4bd1			 
4bd1					; TODO Send SPI byte 
4bd1			 
4bd1 7d					ld a, l 
4bd2 cd b9 00				call spi_send_byte 
4bd5			 
4bd5					NEXTW 
4bd5 c3 5e 1b			jp macro_next 
4bd8				endm 
# End of macro NEXTW
4bd8			 
4bd8			.SPII: 
4bd8				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
4bd8 52				db WORD_SYS_CORE+62             
4bd9 ed 4b			dw .SESEL            
4bdb 06				db 5 + 1 
4bdc .. 00			db "SPII",0              
4be1				endm 
# End of macro CWHEAD
4be1			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
4be1			 
4be1					; TODO Get SPI byte 
4be1			 
4be1 cd da 00				call spi_read_byte 
4be4			 
4be4 26 00				ld h, 0 
4be6 6f					ld l, a 
4be7 cd 6d 19				call forth_push_numhl 
4bea			 
4bea					NEXTW 
4bea c3 5e 1b			jp macro_next 
4bed				endm 
# End of macro NEXTW
4bed			 
4bed			 
4bed			 
4bed			.SESEL: 
4bed				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
4bed 66				db WORD_SYS_CORE+82             
4bee 81 4c			dw .CARTDEV            
4bf0 05				db 4 + 1 
4bf1 .. 00			db "BANK",0              
4bf6				endm 
# End of macro CWHEAD
4bf6			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
4bf6					if DEBUG_FORTH_WORDS_KEY 
4bf6						DMARK "BNK" 
4bf6 f5				push af  
4bf7 3a 0b 4c			ld a, (.dmark)  
4bfa 32 bd fb			ld (debug_mark),a  
4bfd 3a 0c 4c			ld a, (.dmark+1)  
4c00 32 be fb			ld (debug_mark+1),a  
4c03 3a 0d 4c			ld a, (.dmark+2)  
4c06 32 bf fb			ld (debug_mark+2),a  
4c09 18 03			jr .pastdmark  
4c0b ..			.dmark: db "BNK"  
4c0e f1			.pastdmark: pop af  
4c0f			endm  
# End of macro DMARK
4c0f						CALLMONITOR 
4c0f cd d3 13			call break_point_state  
4c12				endm  
# End of macro CALLMONITOR
4c12					endif 
4c12			 
4c12 3e ff				ld a, 255 
4c14 32 e5 f9				ld (spi_cartdev), a 
4c17			 
4c17					; get bank 
4c17			 
4c17					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4c17 cd 08 1a			call macro_dsp_valuehl 
4c1a				endm 
# End of macro FORTH_DSP_VALUEHL
4c1a			 
4c1a			;		push hl 
4c1a			 
4c1a					; destroy value TOS 
4c1a			 
4c1a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c1a cd a4 1a			call macro_forth_dsp_pop 
4c1d				endm 
# End of macro FORTH_DSP_POP
4c1d			 
4c1d					; one value on hl get other one back 
4c1d			 
4c1d			;		pop hl 
4c1d			 
4c1d			 
4c1d 0e ff				ld c, SPI_CE_HIGH 
4c1f			 
4c1f 7d					ld a, l 
4c20			 
4c20					if DEBUG_FORTH_WORDS 
4c20						DMARK "BNK" 
4c20 f5				push af  
4c21 3a 35 4c			ld a, (.dmark)  
4c24 32 bd fb			ld (debug_mark),a  
4c27 3a 36 4c			ld a, (.dmark+1)  
4c2a 32 be fb			ld (debug_mark+1),a  
4c2d 3a 37 4c			ld a, (.dmark+2)  
4c30 32 bf fb			ld (debug_mark+2),a  
4c33 18 03			jr .pastdmark  
4c35 ..			.dmark: db "BNK"  
4c38 f1			.pastdmark: pop af  
4c39			endm  
# End of macro DMARK
4c39						CALLMONITOR 
4c39 cd d3 13			call break_point_state  
4c3c				endm  
# End of macro CALLMONITOR
4c3c					endif 
4c3c			 
4c3c					; active low 
4c3c			 
4c3c fe 00				cp 0 
4c3e 28 1e				jr z, .bset 
4c40 fe 01				cp 1 
4c42 20 02				jr nz, .b2 
4c44 cb 81				res 0, c 
4c46 fe 02		.b2:		cp 2 
4c48 20 02				jr nz, .b3 
4c4a cb 89				res 1, c 
4c4c fe 03		.b3:		cp 3 
4c4e 20 02				jr nz, .b4 
4c50 cb 91				res 2, c 
4c52 fe 04		.b4:		cp 4 
4c54 20 02				jr nz, .b5 
4c56 cb 99				res 3, c 
4c58 fe 05		.b5:		cp 5 
4c5a 20 02				jr nz, .bset 
4c5c cb a1				res 4, c 
4c5e			 
4c5e			.bset: 
4c5e 79					ld a, c 
4c5f 32 e2 f9				ld (spi_device),a 
4c62					if DEBUG_FORTH_WORDS 
4c62						DMARK "BN2" 
4c62 f5				push af  
4c63 3a 77 4c			ld a, (.dmark)  
4c66 32 bd fb			ld (debug_mark),a  
4c69 3a 78 4c			ld a, (.dmark+1)  
4c6c 32 be fb			ld (debug_mark+1),a  
4c6f 3a 79 4c			ld a, (.dmark+2)  
4c72 32 bf fb			ld (debug_mark+2),a  
4c75 18 03			jr .pastdmark  
4c77 ..			.dmark: db "BN2"  
4c7a f1			.pastdmark: pop af  
4c7b			endm  
# End of macro DMARK
4c7b						CALLMONITOR 
4c7b cd d3 13			call break_point_state  
4c7e				endm  
# End of macro CALLMONITOR
4c7e					endif 
4c7e			 
4c7e					NEXTW 
4c7e c3 5e 1b			jp macro_next 
4c81				endm 
# End of macro NEXTW
4c81			 
4c81			.CARTDEV: 
4c81				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
4c81 66				db WORD_SYS_CORE+82             
4c82 2a 4d			dw .ENDDEVICE            
4c84 08				db 7 + 1 
4c85 .. 00			db "CARTDEV",0              
4c8d				endm 
# End of macro CWHEAD
4c8d			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
4c8d					if DEBUG_FORTH_WORDS_KEY 
4c8d						DMARK "CDV" 
4c8d f5				push af  
4c8e 3a a2 4c			ld a, (.dmark)  
4c91 32 bd fb			ld (debug_mark),a  
4c94 3a a3 4c			ld a, (.dmark+1)  
4c97 32 be fb			ld (debug_mark+1),a  
4c9a 3a a4 4c			ld a, (.dmark+2)  
4c9d 32 bf fb			ld (debug_mark+2),a  
4ca0 18 03			jr .pastdmark  
4ca2 ..			.dmark: db "CDV"  
4ca5 f1			.pastdmark: pop af  
4ca6			endm  
# End of macro DMARK
4ca6						CALLMONITOR 
4ca6 cd d3 13			call break_point_state  
4ca9				endm  
# End of macro CALLMONITOR
4ca9					endif 
4ca9			 
4ca9					; disable se storage bank selection 
4ca9			 
4ca9 3e ff				ld a, SPI_CE_HIGH		; ce high 
4cab 32 e2 f9				ld (spi_device), a 
4cae			 
4cae					; get bank 
4cae			 
4cae					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4cae cd 08 1a			call macro_dsp_valuehl 
4cb1				endm 
# End of macro FORTH_DSP_VALUEHL
4cb1			 
4cb1			;		push hl 
4cb1			 
4cb1					; destroy value TOS 
4cb1			 
4cb1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4cb1 cd a4 1a			call macro_forth_dsp_pop 
4cb4				endm 
# End of macro FORTH_DSP_POP
4cb4			 
4cb4					; one value on hl get other one back 
4cb4			 
4cb4			;		pop hl 
4cb4			 
4cb4					; active low 
4cb4			 
4cb4 0e ff				ld c, 255 
4cb6			 
4cb6 7d					ld a, l 
4cb7					if DEBUG_FORTH_WORDS 
4cb7						DMARK "CDV" 
4cb7 f5				push af  
4cb8 3a cc 4c			ld a, (.dmark)  
4cbb 32 bd fb			ld (debug_mark),a  
4cbe 3a cd 4c			ld a, (.dmark+1)  
4cc1 32 be fb			ld (debug_mark+1),a  
4cc4 3a ce 4c			ld a, (.dmark+2)  
4cc7 32 bf fb			ld (debug_mark+2),a  
4cca 18 03			jr .pastdmark  
4ccc ..			.dmark: db "CDV"  
4ccf f1			.pastdmark: pop af  
4cd0			endm  
# End of macro DMARK
4cd0						CALLMONITOR 
4cd0 cd d3 13			call break_point_state  
4cd3				endm  
# End of macro CALLMONITOR
4cd3					endif 
4cd3 fe 00				cp 0 
4cd5 28 30				jr z, .cset 
4cd7 fe 01				cp 1 
4cd9 20 02				jr nz, .c2 
4cdb cb 81				res 0, c 
4cdd fe 02		.c2:		cp 2 
4cdf 20 02				jr nz, .c3 
4ce1 cb 89				res 1, c 
4ce3 fe 03		.c3:		cp 3 
4ce5 20 02				jr nz, .c4 
4ce7 cb 91				res 2, c 
4ce9 fe 04		.c4:		cp 4 
4ceb 20 02				jr nz, .c5 
4ced cb 99				res 3, c 
4cef fe 05		.c5:		cp 5 
4cf1 20 02				jr nz, .c6 
4cf3 cb a1				res 4, c 
4cf5 fe 06		.c6:		cp 6 
4cf7 20 02				jr nz, .c7 
4cf9 cb a9				res 5, c 
4cfb fe 07		.c7:		cp 7 
4cfd 20 02				jr nz, .c8 
4cff cb b1				res 6, c 
4d01 fe 08		.c8:		cp 8 
4d03 20 02				jr nz, .cset 
4d05 cb b9				res 7, c 
4d07 79			.cset:		ld a, c 
4d08 32 e5 f9				ld (spi_cartdev),a 
4d0b			 
4d0b					if DEBUG_FORTH_WORDS 
4d0b						DMARK "CD2" 
4d0b f5				push af  
4d0c 3a 20 4d			ld a, (.dmark)  
4d0f 32 bd fb			ld (debug_mark),a  
4d12 3a 21 4d			ld a, (.dmark+1)  
4d15 32 be fb			ld (debug_mark+1),a  
4d18 3a 22 4d			ld a, (.dmark+2)  
4d1b 32 bf fb			ld (debug_mark+2),a  
4d1e 18 03			jr .pastdmark  
4d20 ..			.dmark: db "CD2"  
4d23 f1			.pastdmark: pop af  
4d24			endm  
# End of macro DMARK
4d24						CALLMONITOR 
4d24 cd d3 13			call break_point_state  
4d27				endm  
# End of macro CALLMONITOR
4d27					endif 
4d27					NEXTW 
4d27 c3 5e 1b			jp macro_next 
4d2a				endm 
# End of macro NEXTW
4d2a			endif 
4d2a			 
4d2a			.ENDDEVICE: 
4d2a			; eof 
4d2a			 
# End of file forth_words_device.asm
4d2a			 
4d2a			; var handler 
4d2a			 
4d2a			 
4d2a			.VARS: 
4d2a				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
4d2a 78				db WORD_SYS_CORE+100             
4d2b 42 4d			dw .V0Q            
4d2d 04				db 3 + 1 
4d2e .. 00			db "V0!",0              
4d32				endm 
# End of macro CWHEAD
4d32			;| V0! ( u1 -- )  Store value to v0  | DONE 
4d32			 
4d32					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4d32 cd 08 1a			call macro_dsp_valuehl 
4d35				endm 
# End of macro FORTH_DSP_VALUEHL
4d35			 
4d35 11 ab f9				ld de, cli_var_array 
4d38			 
4d38 eb					ex de, hl 
4d39 73					ld (hl), e 
4d3a 23					inc hl 
4d3b 72					ld (hl), d 
4d3c			 
4d3c					; destroy value TOS 
4d3c			 
4d3c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4d3c cd a4 1a			call macro_forth_dsp_pop 
4d3f				endm 
# End of macro FORTH_DSP_POP
4d3f			 
4d3f				       NEXTW 
4d3f c3 5e 1b			jp macro_next 
4d42				endm 
# End of macro NEXTW
4d42			.V0Q: 
4d42				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
4d42 79				db WORD_SYS_CORE+101             
4d43 53 4d			dw .V1S            
4d45 04				db 3 + 1 
4d46 .. 00			db "V0@",0              
4d4a				endm 
# End of macro CWHEAD
4d4a			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
4d4a 2a ab f9				ld hl, (cli_var_array) 
4d4d cd 6d 19				call forth_push_numhl 
4d50			 
4d50				       NEXTW 
4d50 c3 5e 1b			jp macro_next 
4d53				endm 
# End of macro NEXTW
4d53			.V1S: 
4d53				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
4d53 7a				db WORD_SYS_CORE+102             
4d54 6b 4d			dw .V1Q            
4d56 04				db 3 + 1 
4d57 .. 00			db "V1!",0              
4d5b				endm 
# End of macro CWHEAD
4d5b			;| V1! ( u1 -- )  Store value to v1 | DONE 
4d5b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4d5b cd 08 1a			call macro_dsp_valuehl 
4d5e				endm 
# End of macro FORTH_DSP_VALUEHL
4d5e			 
4d5e 11 ad f9				ld de, cli_var_array+2 
4d61				 
4d61 eb					ex de, hl 
4d62 73					ld (hl), e 
4d63 23					inc hl 
4d64 72					ld (hl), d 
4d65			 
4d65					; destroy value TOS 
4d65			 
4d65					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4d65 cd a4 1a			call macro_forth_dsp_pop 
4d68				endm 
# End of macro FORTH_DSP_POP
4d68				       NEXTW 
4d68 c3 5e 1b			jp macro_next 
4d6b				endm 
# End of macro NEXTW
4d6b			.V1Q: 
4d6b				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
4d6b 7b				db WORD_SYS_CORE+103             
4d6c 7c 4d			dw .V2S            
4d6e 04				db 3 + 1 
4d6f .. 00			db "V1@",0              
4d73				endm 
# End of macro CWHEAD
4d73			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
4d73 2a ad f9				ld hl, (cli_var_array+2) 
4d76 cd 6d 19				call forth_push_numhl 
4d79				       NEXTW 
4d79 c3 5e 1b			jp macro_next 
4d7c				endm 
# End of macro NEXTW
4d7c			.V2S: 
4d7c				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
4d7c 7c				db WORD_SYS_CORE+104             
4d7d 94 4d			dw .V2Q            
4d7f 04				db 3 + 1 
4d80 .. 00			db "V2!",0              
4d84				endm 
# End of macro CWHEAD
4d84			;| V2! ( u1 -- )  Store value to v2 | DONE 
4d84					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4d84 cd 08 1a			call macro_dsp_valuehl 
4d87				endm 
# End of macro FORTH_DSP_VALUEHL
4d87			 
4d87 11 af f9				ld de, cli_var_array+4 
4d8a				 
4d8a eb					ex de, hl 
4d8b 73					ld (hl), e 
4d8c 23					inc hl 
4d8d 72					ld (hl), d 
4d8e			 
4d8e					; destroy value TOS 
4d8e			 
4d8e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4d8e cd a4 1a			call macro_forth_dsp_pop 
4d91				endm 
# End of macro FORTH_DSP_POP
4d91				       NEXTW 
4d91 c3 5e 1b			jp macro_next 
4d94				endm 
# End of macro NEXTW
4d94			.V2Q: 
4d94				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
4d94 7d				db WORD_SYS_CORE+105             
4d95 a5 4d			dw .V3S            
4d97 04				db 3 + 1 
4d98 .. 00			db "V2@",0              
4d9c				endm 
# End of macro CWHEAD
4d9c			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
4d9c 2a af f9				ld hl, (cli_var_array+4) 
4d9f cd 6d 19				call forth_push_numhl 
4da2				       NEXTW 
4da2 c3 5e 1b			jp macro_next 
4da5				endm 
# End of macro NEXTW
4da5			.V3S: 
4da5				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
4da5 7c				db WORD_SYS_CORE+104             
4da6 bd 4d			dw .V3Q            
4da8 04				db 3 + 1 
4da9 .. 00			db "V3!",0              
4dad				endm 
# End of macro CWHEAD
4dad			;| V3! ( u1 -- )  Store value to v3 | DONE 
4dad					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4dad cd 08 1a			call macro_dsp_valuehl 
4db0				endm 
# End of macro FORTH_DSP_VALUEHL
4db0			 
4db0 11 b1 f9				ld de, cli_var_array+6 
4db3				 
4db3 eb					ex de, hl 
4db4 73					ld (hl), e 
4db5 23					inc hl 
4db6 72					ld (hl), d 
4db7			 
4db7					; destroy value TOS 
4db7			 
4db7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4db7 cd a4 1a			call macro_forth_dsp_pop 
4dba				endm 
# End of macro FORTH_DSP_POP
4dba				       NEXTW 
4dba c3 5e 1b			jp macro_next 
4dbd				endm 
# End of macro NEXTW
4dbd			.V3Q: 
4dbd				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
4dbd 7d				db WORD_SYS_CORE+105             
4dbe ce 4d			dw .END            
4dc0 04				db 3 + 1 
4dc1 .. 00			db "V3@",0              
4dc5				endm 
# End of macro CWHEAD
4dc5			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
4dc5 2a b1 f9				ld hl, (cli_var_array+6) 
4dc8 cd 6d 19				call forth_push_numhl 
4dcb				       NEXTW 
4dcb c3 5e 1b			jp macro_next 
4dce				endm 
# End of macro NEXTW
4dce			 
4dce			 
4dce			 
4dce			 
4dce			 
4dce			; end of dict marker 
4dce			 
4dce 00			.END:    db WORD_SYS_END 
4dcf 00 00			dw 0 
4dd1 00				db 0 
4dd2			 
4dd2			; use to jp here for user dict words to save on macro expansion  
4dd2			 
4dd2			user_dict_next: 
4dd2				NEXTW 
4dd2 c3 5e 1b			jp macro_next 
4dd5				endm 
# End of macro NEXTW
4dd5			 
4dd5			 
4dd5			user_exec: 
4dd5				;    ld hl, <word code> 
4dd5				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
4dd5				;    call forthexec 
4dd5				;    jp user_dict_next   (NEXT) 
4dd5			        ;    <word code bytes> 
4dd5 eb				ex de, hl 
4dd6 2a b9 f2			ld hl,(os_tok_ptr) 
4dd9				 
4dd9				FORTH_RSP_NEXT 
4dd9 cd 14 19			call macro_forth_rsp_next 
4ddc				endm 
# End of macro FORTH_RSP_NEXT
4ddc			 
4ddc			if DEBUG_FORTH_UWORD 
4ddc						DMARK "UEX" 
4ddc f5				push af  
4ddd 3a f1 4d			ld a, (.dmark)  
4de0 32 bd fb			ld (debug_mark),a  
4de3 3a f2 4d			ld a, (.dmark+1)  
4de6 32 be fb			ld (debug_mark+1),a  
4de9 3a f3 4d			ld a, (.dmark+2)  
4dec 32 bf fb			ld (debug_mark+2),a  
4def 18 03			jr .pastdmark  
4df1 ..			.dmark: db "UEX"  
4df4 f1			.pastdmark: pop af  
4df5			endm  
# End of macro DMARK
4df5				CALLMONITOR 
4df5 cd d3 13			call break_point_state  
4df8				endm  
# End of macro CALLMONITOR
4df8			endif 
4df8			 
4df8			 
4df8			 
4df8 eb				ex de, hl 
4df9 22 b9 f2			ld (os_tok_ptr), hl 
4dfc				 
4dfc				; Don't use next - Skips the first word in uword. 
4dfc			 
4dfc c3 ef 1b			jp exec1 
4dff			;	NEXT 
4dff			 
4dff			 
4dff			; eof 
# End of file forth_wordsv4.asm
4dff			endif 
4dff			;;;;;;;;;;;;;; Debug code 
4dff			 
4dff			 
4dff			;if DEBUG_FORTH_PARSE 
4dff .. 00		.nowordfound: db "No match",0 
4e08 .. 00		.compword:	db "Comparing word ",0 
4e18 .. 00		.nextwordat:	db "Next word at",0 
4e25 .. 00		.charmatch:	db "Char match",0 
4e30			;endif 
4e30			if DEBUG_FORTH_JP 
4e30			.foundword:	db "Word match. Exec..",0 
4e30			endif 
4e30			;if DEBUG_FORTH_PUSH 
4e30 .. 00		.enddict:	db "Dict end. Push.",0 
4e40 .. 00		.push_str:	db "Pushing string",0 
4e4f .. 00		.push_num:	db "Pushing number",0 
4e5e .. 00		.data_sp:	db "SP:",0 
4e62 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
4e74 .. 00		.wordinde:	db "Word in DE (3/0):",0 
4e86 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
4e98			;endif 
4e98			;if DEBUG_FORTH_MALLOC 
4e98 .. 00		.push_malloc:	db "Malloc address",0 
4ea7			;endif 
4ea7			 
4ea7			 
4ea7			 
4ea7			; display malloc address and current data stack pointer  
4ea7			 
4ea7			malloc_error: 
4ea7 d5				push de 
4ea8 f5				push af 
4ea9 e5				push hl 
4eaa cd b6 0a			call clear_display 
4ead 11 cf 4e			ld de, .mallocerr 
4eb0 3e 00			ld a,0 
4eb2			;	ld de,os_word_scratch 
4eb2 cd c9 0a			call str_at_display 
4eb5 3e 11			ld a, display_row_1+17 
4eb7 11 bd fb			ld de, debug_mark 
4eba cd c9 0a			call str_at_display 
4ebd cd d9 0a			call update_display 
4ec0				;call break_point_state 
4ec0 cd fd 62			call cin_wait 
4ec3			 
4ec3 3e 20			ld a, ' ' 
4ec5 32 b7 ef			ld (os_view_disable), a 
4ec8 e1				pop hl 
4ec9 f1				pop af 
4eca d1				pop de	 
4ecb				CALLMONITOR 
4ecb cd d3 13			call break_point_state  
4ece				endm  
# End of macro CALLMONITOR
4ece c9				ret 
4ecf			 
4ecf .. 00		.mallocerr: 	db "Malloc Error",0 
4edc			;if DEBUG_FORTH_PUSH 
4edc			display_data_sp: 
4edc f5				push af 
4edd			 
4edd				; see if disabled 
4edd			 
4edd 3a b7 ef			ld a, (os_view_disable) 
4ee0 fe 2a			cp '*' 
4ee2 28 67			jr z, .skipdsp 
4ee4			 
4ee4 e5				push hl 
4ee5 e5				push hl 
4ee6 e5			push hl 
4ee7 cd b6 0a			call clear_display 
4eea e1			pop hl 
4eeb 7c				ld a,h 
4eec 21 bd f2			ld hl, os_word_scratch 
4eef cd 10 0f			call hexout 
4ef2 e1				pop hl 
4ef3 7d				ld a,l 
4ef4 21 bf f2			ld hl, os_word_scratch+2 
4ef7 cd 10 0f			call hexout 
4efa 21 c1 f2			ld hl, os_word_scratch+4 
4efd 3e 00			ld a,0 
4eff 77				ld (hl),a 
4f00 11 bd f2			ld de,os_word_scratch 
4f03 3e 14				ld a, display_row_2 
4f05 cd c9 0a				call str_at_display 
4f08 11 62 4e			ld de, .wordinhl 
4f0b 3e 00			ld a, display_row_1 
4f0d			 
4f0d cd c9 0a				call str_at_display 
4f10 11 bd fb			ld de, debug_mark 
4f13 3e 11			ld a, display_row_1+17 
4f15			 
4f15 cd c9 0a				call str_at_display 
4f18			 
4f18				; display current data stack pointer 
4f18 11 5e 4e			ld de,.data_sp 
4f1b 3e 1c				ld a, display_row_2 + 8 
4f1d cd c9 0a				call str_at_display 
4f20			 
4f20 2a a5 f9			ld hl,(cli_data_sp) 
4f23 e5				push hl 
4f24 7c				ld a,h 
4f25 21 bd f2			ld hl, os_word_scratch 
4f28 cd 10 0f			call hexout 
4f2b e1				pop hl 
4f2c 7d				ld a,l 
4f2d 21 bf f2			ld hl, os_word_scratch+2 
4f30 cd 10 0f			call hexout 
4f33 21 c1 f2			ld hl, os_word_scratch+4 
4f36 3e 00			ld a,0 
4f38 77				ld (hl),a 
4f39 11 bd f2			ld de,os_word_scratch 
4f3c 3e 1f				ld a, display_row_2 + 11 
4f3e cd c9 0a				call str_at_display 
4f41			 
4f41			 
4f41 cd d9 0a			call update_display 
4f44 cd 3a 0a			call delay1s 
4f47 cd 3a 0a			call delay1s 
4f4a e1				pop hl 
4f4b			.skipdsp: 
4f4b f1				pop af 
4f4c c9				ret 
4f4d			 
4f4d			display_data_malloc: 
4f4d			 
4f4d f5				push af 
4f4e e5				push hl 
4f4f e5				push hl 
4f50 e5			push hl 
4f51 cd b6 0a			call clear_display 
4f54 e1			pop hl 
4f55 7c				ld a,h 
4f56 21 bd f2			ld hl, os_word_scratch 
4f59 cd 10 0f			call hexout 
4f5c e1				pop hl 
4f5d 7d				ld a,l 
4f5e 21 bf f2			ld hl, os_word_scratch+2 
4f61 cd 10 0f			call hexout 
4f64 21 c1 f2			ld hl, os_word_scratch+4 
4f67 3e 00			ld a,0 
4f69 77				ld (hl),a 
4f6a 11 bd f2			ld de,os_word_scratch 
4f6d 3e 14				ld a, display_row_2 
4f6f cd c9 0a				call str_at_display 
4f72 11 98 4e			ld de, .push_malloc 
4f75 3e 00			ld a, display_row_1 
4f77			 
4f77 cd c9 0a				call str_at_display 
4f7a			 
4f7a				; display current data stack pointer 
4f7a 11 5e 4e			ld de,.data_sp 
4f7d 3e 1c				ld a, display_row_2 + 8 
4f7f cd c9 0a				call str_at_display 
4f82			 
4f82 2a a5 f9			ld hl,(cli_data_sp) 
4f85 e5				push hl 
4f86 7c				ld a,h 
4f87 21 bd f2			ld hl, os_word_scratch 
4f8a cd 10 0f			call hexout 
4f8d e1				pop hl 
4f8e 7d				ld a,l 
4f8f 21 bf f2			ld hl, os_word_scratch+2 
4f92 cd 10 0f			call hexout 
4f95 21 c1 f2			ld hl, os_word_scratch+4 
4f98 3e 00			ld a,0 
4f9a 77				ld (hl),a 
4f9b 11 bd f2			ld de,os_word_scratch 
4f9e 3e 1f				ld a, display_row_2 + 11 
4fa0 cd c9 0a				call str_at_display 
4fa3			 
4fa3 cd d9 0a			call update_display 
4fa6 cd 3a 0a			call delay1s 
4fa9 cd 3a 0a			call delay1s 
4fac e1				pop hl 
4fad f1				pop af 
4fae c9				ret 
4faf			;endif 
4faf			 
4faf			include "forth_autostart.asm" 
4faf			; list of commands to perform at system start up 
4faf			 
4faf			startcmds: 
4faf			;	dw test11 
4faf			;	dw test12 
4faf			;	dw test13 
4faf			;	dw test14 
4faf			;	dw test15 
4faf			;	dw test16 
4faf			;	dw test17 
4faf			;	dw ifthtest1 
4faf			;	dw ifthtest2 
4faf			;	dw ifthtest3 
4faf			;	dw mmtest1 
4faf			;	dw mmtest2 
4faf			;	dw mmtest3 
4faf			;	dw mmtest4 
4faf			;	dw mmtest5 
4faf			;	dw mmtest6 
4faf			;	dw iftest1 
4faf			;	dw iftest2 
4faf			;	dw iftest3 
4faf			;	dw looptest1 
4faf			;	dw looptest2 
4faf			;	dw test1 
4faf			;	dw test2 
4faf			;	dw test3 
4faf			;	dw test4 
4faf			;	dw game2r 
4faf			;	dw game2b1 
4faf			;	dw game2b2 
4faf			 
4faf				; start up words that are actually useful 
4faf			 
4faf 0d 50			dw clrstack 
4fb1 40 50			dw type 
4fb3 01 52			dw stest 
4fb5 64 50			dw strncpy 
4fb7 a2 51			dw list 
4fb9 c5 50			dw start1 
4fbb d7 50			dw start2 
4fbd			;	dw start3 
4fbd ea 50			dw start3b 
4fbf 42 51			dw start3c 
4fc1			 
4fc1				; (unit) testing words 
4fc1			 
4fc1 78 52			dw mtesta 
4fc3 2d 53			dw mtestb 
4fc5 d0 53			dw mtestc 
4fc7 85 54			dw mtestd 
4fc9 29 55			dw mteste 
4fcb			 
4fcb				; demo/game words 
4fcb			 
4fcb 35 5c		        dw game3w 
4fcd 63 5c		        dw game3p 
4fcf 81 5c		        dw game3sc 
4fd1 b2 5c		        dw game3vsi 
4fd3 de 5c		        dw game3vs 
4fd5				 
4fd5 28 5a			dw game2b 
4fd7 96 5a			dw game2bf 
4fd9 e0 5a			dw game2mba 
4fdb 76 5b			dw game2mbas 
4fdd b8 5b			dw game2mb 
4fdf			 
4fdf e9 56			dw game1 
4fe1 fa 56			dw game1a 
4fe3 5c 57			dw game1b 
4fe5 91 57			dw game1c 
4fe7 c7 57			dw game1d 
4fe9 f8 57			dw game1s 
4feb 0c 58			dw game1t 
4fed 21 58			dw game1f 
4fef 55 58			dw game1z 
4ff1 99 58			dw game1zz 
4ff3			 
4ff3 df 55			dw test5 
4ff5 17 56			dw test6 
4ff7 4f 56			dw test7 
4ff9 63 56			dw test8 
4ffb 8f 56			dw test9 
4ffd a5 56			dw test10 
4fff				 
4fff 70 59		        dw ssv5 
5001 54 59		        dw ssv4 
5003 38 59		        dw ssv3 
5005 02 59		        dw ssv2 
5007 89 59		        dw ssv1 
5009 d1 59		        dw ssv1cpm 
500b			;	dw keyup 
500b			;	dw keydown 
500b			;	dw keyleft 
500b			;	dw keyright 
500b			;	dw 	keyf1 
500b			;	dw keyf2 
500b			;	dw keyf3 
500b			;	dw keyf4 
500b			;	dw keyf5 
500b			;	dw keyf6 
500b			;	dw keyf7 
500b			;	dw keyf8 
500b			;	dw keyf9 
500b			;	dw keyf10 
500b			;	dw keyf11 
500b			;	dw keyf12 
500b			;	dw keytab 
500b			;	dw keycr 
500b			;	dw keyhome 
500b			;	dw keyend 
500b			;	dw keybs 
500b 00 00			db 0, 0	 
500d			 
500d			 
500d			; clear stack  
500d			 
500d .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
5040			 
5040			; type ( addr count - ) 
5040 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
5064			 
5064			; some direct memory words 
5064			; strncpy ( len t f -- t ) 
5064			 
5064 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
50c5			 
50c5 .. 00		start1:     	db ": bpon $0000 bp ;",0 
50d7 .. 00		start2:     	db ": bpoff $0001 bp ;",0 
50ea			;start3:         db ": dirlist ir cls drop dup $00 > if $01 do .> BL .> .> BL .> .> BL .> loop then nop ;",0 
50ea .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 i at . $01 i at . $04 i at . loop then nop ;",0 
5142 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
51a2			 
51a2			 
51a2			; a handy word to list items on the stack 
51a2			 
51a2 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> accept drop depth 0= not until nop ;",0 
5201			 
5201			 
5201			; test stack  
5201			; rnd8 stest 
5201			 
5201 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
5278			 
5278			; random malloc and free cycles 
5278			 
5278 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
532d			 
532d			; fixed malloc and free cycles 
532d			 
532d .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
53d0			 
53d0			; fixed double string push and drop cycle  
53d0			 
53d0 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
5485			 
5485			; consistent fixed string push and drop cycle  
5485			 
5485 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5529			 
5529 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
55df			 
55df			;test1:		db ": aa 1 2 3 ;", 0 
55df			;test2:     	db "111 aa 888 999",0 
55df			;test3:     	db ": bb 77 ;",0 
55df			;test4:     	db "$02 $01 do i . loop bb",0 
55df			 
55df .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
5617 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
564f .. 00		test7:     	db ": box hline vline ;",0 
5663 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
568f .. 00		test9:     	db ": sw $01 adsp world ;",0 
56a5 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
56ca .. 00		test11:     	db "hello create .",0 
56d9 .. 00		test12:     	db "hello2 create .",0 
56e9			 
56e9			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
56e9			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
56e9			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
56e9			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
56e9			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
56e9			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
56e9			 
56e9			;iftest1:     	db "$0001 IF cls .",0 
56e9			;iftest2:     	db "$0000 IF cls .",0 
56e9			;iftest3:     	db "$0002 $0003 - IF cls .",0 
56e9			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
56e9			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
56e9			 
56e9			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
56e9			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
56e9			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
56e9			 
56e9			 
56e9			 
56e9			; a small guess the number game 
56e9			 
56e9 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
56fa .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
575c			 
575c .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
5791 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
57c7 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
57f8 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
580c .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
5821 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5855 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
5899			 
5899			; Using 'ga' save a high score across multiple runs using external storage 
5899			 
5899 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
5902			 
5902			 
5902			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
5902			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
5902			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
5902			 
5902			; simple screen saver to test code memory reuse to destruction 
5902			 
5902 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
5938 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
5954 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
5970 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
5989 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
59d1 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
5a28			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
5a28			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
5a28			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
5a28			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
5a28			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
5a28			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
5a28			 
5a28			 
5a28			 
5a28			; minesweeper/battleship finding game 
5a28			; draws a game board of random ship/mine positions 
5a28			; user enters coords to see if it hits on 
5a28			; game ends when all are hit 
5a28			; when hit or miss says how many may be in the area 
5a28			 
5a28			; setup the game board and then hide it 
5a28 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
5a96 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
5ae0			; prompt for where to target 
5ae0 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
5b76 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
5b9b			; TODO see if the entered coords hits or misses pushes char hit of miss 
5b9b .. 00		game2mbht:      db ": mbckht nop ;",0 
5baa .. 00		game2mbms:      db ": mbcms nop ;",0 
5bb8			; TODO how many might be near by 
5bb8 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
5c35			 
5c35			; Game 3 
5c35			 
5c35			; Vert scroller ski game - avoid the trees! 
5c35			 
5c35			; v0 score (ie turns) 
5c35			; v1 player pos 
5c35			; v2 left wall 
5c35			; v3 right wall 
5c35			 
5c35			; Draw side walls randomly 
5c35			 
5c35 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
5c63			 
5c63			; Draw player 
5c63 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
5c81			 
5c81			; TODO Get Key 
5c81			 
5c81			; TODO Move left right 
5c81			 
5c81			; scroll and move walls a bit 
5c81			 
5c81 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
5cb2			 
5cb2			; main game loop 
5cb2			 
5cb2 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
5cde .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
5d1d			 
5d1d			; key board defs 
5d1d			 
5d1d .. 00		keyup:       db ": keyup $05 ;",0 
5d2b .. 00		keydown:       db ": keydown $0a ;",0 
5d3b .. 00		keyleft:       db ": keyleft $0b ;",0 
5d4b .. 00		keyright:       db ": keyright $0c ;",0 
5d5c .. 00		keyf1:       db ": keyf1 $10 ;",0 
5d6a .. 00		keyf2:       db ": keyf2 $11 ;",0 
5d78 .. 00		keyf3:       db ": keyf3 $12 ;",0 
5d86 .. 00		keyf4:       db ": keyf4 $13 ;",0 
5d94 .. 00		keyf5:       db ": keyf5 $14 ;",0 
5da2 .. 00		keyf6:       db ": keyf6 $15 ;",0 
5db0 .. 00		keyf7:       db ": keyf7 $16 ;",0 
5dbe .. 00		keyf8:       db ": keyf8 $17 ;",0 
5dcc .. 00		keyf9:       db ": keyf9 $18 ;",0 
5dda .. 00		keyf10:       db ": keyf10 $19 ;",0 
5de9 .. 00		keyf11:       db ": keyf11 $1a ;",0 
5df8 .. 00		keyf12:       db ": keyf12 $1b ;",0 
5e07			 
5e07 .. 00		keytab:       db ": keytab $09 ;",0 
5e16 .. 00		keycr:       db ": keycr $0d ;",0 
5e24 .. 00		keyhome:       db ": keyhome $0e ;",0 
5e34 .. 00		keyend:       db ": keyend $0f ;",0 
5e43 .. 00		keybs:       db ": keybs $08 ;",0 
5e51			 
5e51			   
5e51			 
5e51			 
5e51			 
5e51			; eof 
# End of file forth_autostart.asm
5e51			 
5e51 .. 00		sprompt1: db "Startup load...",0 
5e61 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
5e77			 
5e77			forth_startup: 
5e77 21 af 4f			ld hl, startcmds 
5e7a 3e 00			ld a, 0 
5e7c 32 de f3			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
5e7f			 
5e7f e5			.start1:	push hl 
5e80 cd b6 0a			call clear_display 
5e83 11 51 5e			ld de, sprompt1 
5e86 3e 00		        ld a, display_row_1 
5e88 cd c9 0a			call str_at_display 
5e8b 11 61 5e			ld de, sprompt2 
5e8e 3e 14		        ld a, display_row_2 
5e90 cd c9 0a			call str_at_display 
5e93 e1				pop hl 
5e94 e5				push hl 
5e95 5e				ld e,(hl) 
5e96 23				inc hl 
5e97 56				ld d,(hl) 
5e98 3e 28		        ld a, display_row_3 
5e9a cd c9 0a			call str_at_display 
5e9d cd d9 0a			call update_display 
5ea0			 
5ea0			 
5ea0 3a de f3			ld a, (os_last_cmd) 
5ea3 fe 00			cp 0 
5ea5 28 05			jr z, .startprompt 
5ea7 cd 2e 0a			call delay250ms 
5eaa 18 24			jr .startdo 
5eac				 
5eac				 
5eac			 
5eac			.startprompt: 
5eac			 
5eac 3e 4f			ld a,display_row_4 + display_cols - 1 
5eae 11 e3 18		        ld de, endprg 
5eb1 cd c9 0a			call str_at_display 
5eb4 cd d9 0a			call update_display 
5eb7 cd 3a 0a			call delay1s 
5eba cd fd 62			call cin_wait 
5ebd						 
5ebd fe 2a			cp '*' 
5ebf 28 5e			jr z, .startupend1 
5ec1 fe 23			cp '#' 
5ec3 20 07			jr nz, .startno 
5ec5 3e 01			ld a, 1 
5ec7 32 de f3			ld (os_last_cmd),a 
5eca 18 04			jr .startdo 
5ecc fe 31		.startno:	cp '1' 
5ece 28 3a			jr z,.startnxt  
5ed0			 
5ed0				; exec startup line 
5ed0			.startdo:	 
5ed0 e1				pop hl 
5ed1 e5				push hl 
5ed2				 
5ed2 5e				ld e,(hl) 
5ed3 23				inc hl 
5ed4 56				ld d,(hl) 
5ed5 eb				ex de,hl 
5ed6			 
5ed6 e5				push hl 
5ed7			 
5ed7 3e 00			ld a, 0 
5ed9				;ld a, FORTH_END_BUFFER 
5ed9 cd 78 10			call strlent 
5edc 23				inc hl   ; include zero term to copy 
5edd 06 00			ld b,0 
5edf 4d				ld c,l 
5ee0 e1				pop hl 
5ee1 11 b8 ef			ld de, scratch 
5ee4 ed b0			ldir 
5ee6			 
5ee6			 
5ee6 21 b8 ef			ld hl, scratch 
5ee9 cd ac 1b			call forthparse 
5eec cd ec 1b			call forthexec 
5eef cd 03 1b			call forthexec_cleanup 
5ef2			 
5ef2 3e 3c			ld a, display_row_4 
5ef4 11 87 16			ld de, endprog 
5ef7			 
5ef7 cd d9 0a			call update_display		 
5efa			 
5efa 3a de f3			ld a, (os_last_cmd) 
5efd fe 00			cp 0 
5eff 20 09			jr nz, .startnxt 
5f01 cd e5 18			call next_page_prompt 
5f04 cd b6 0a		        call clear_display 
5f07 cd d9 0a			call update_display		 
5f0a			 
5f0a				; move onto next startup line? 
5f0a			.startnxt: 
5f0a			 
5f0a cd 2e 0a			call delay250ms 
5f0d e1				pop hl 
5f0e			 
5f0e 23				inc hl 
5f0f 23				inc hl 
5f10			 
5f10 e5				push hl 
5f11 5e				ld e, (hl) 
5f12 23				inc hl 
5f13 56				ld d, (hl) 
5f14 e1				pop hl 
5f15				; TODO replace 0 test 
5f15			 
5f15 eb				ex de, hl 
5f16 cd 38 0c			call ishlzero 
5f19			;	ld a,e 
5f19			;	add d 
5f19			;	cp 0    ; any left to do? 
5f19 eb				ex de, hl 
5f1a c2 7f 5e			jp nz, .start1 
5f1d 18 01			jr .startupend 
5f1f			 
5f1f e1			.startupend1: pop hl 
5f20			.startupend: 
5f20			 
5f20 cd b6 0a			call clear_display 
5f23 cd d9 0a			call update_display 
5f26 c9				ret 
5f27			 
5f27			 
5f27			; stack over and underflow checks 
5f27			 
5f27			; init the words to detect the under/overflow 
5f27			 
5f27			chk_stk_init: 
5f27				; a vague random number to check so we dont get any "lucky" hits 
5f27 3e 2d			ld a, 45 
5f29 6f				ld l, a 
5f2a 00				nop 
5f2b 3e 17			ld a, 23 
5f2d 67				ld h, a 
5f2e			 
5f2e 22 ad ef			ld (chk_word), hl     ; the word we need to check against 
5f31			 
5f31			;	ld (chk_stund), hl	; stack points.... 
5f31 22 fd fb			ld (chk_stovr), hl 
5f34 22 a3 f9			ld (chk_ret_und), hl 
5f37 22 21 f9			ld (chk_ret_ovr), hl 
5f3a 22 1f f7			ld (chk_loop_ovr), hl 
5f3d 22 1d f5			ld (chk_data_ovr), hl 
5f40 c9				ret 
5f41				 
5f41			check_stacks: 
5f41				; check all stack words 
5f41			 
5f41 e5				push hl 
5f42 d5				push de 
5f43			 
5f43			;	ld de,(chk_word) 
5f43			;	ld hl, (chk_stund)	; stack points.... 
5f43			;	if DEBUG_STK_FAULT 
5f43			;		DMARK "FAa" 
5f43			;		CALLMONITOR 
5f43			;	endif 
5f43			;	call cmp16 
5f43			;	jp z, .chk_faulta 
5f43			; 
5f43			;	ld de, sfaultsu 
5f43			;	jp .chk_fault 
5f43			 
5f43 2a fd fb		.chk_faulta: ld hl, (chk_stovr) 
5f46 ed 5b ad ef		ld de,(chk_word) 
5f4a				if DEBUG_STK_FAULT 
5f4a					DMARK "FAb" 
5f4a					CALLMONITOR 
5f4a				endif 
5f4a cd 2d 0c			call cmp16 
5f4d 28 06			jr z, .chk_fault1 
5f4f 11 f0 5f			ld de, sfaultso 
5f52 c3 a4 5f			jp .chk_fault 
5f55			.chk_fault1:  
5f55 2a a3 f9			ld hl, (chk_ret_und) 
5f58 ed 5b ad ef		ld de,(chk_word) 
5f5c				if DEBUG_STK_FAULT 
5f5c					DMARK "FAU" 
5f5c					CALLMONITOR 
5f5c				endif 
5f5c cd 2d 0c			call cmp16 
5f5f ca 68 5f			jp z, .chk_fault2 
5f62 11 00 60			ld de, sfaultru 
5f65 c3 a4 5f			jp .chk_fault 
5f68			.chk_fault2:  
5f68 2a 21 f9			ld hl, (chk_ret_ovr) 
5f6b ed 5b ad ef		ld de,(chk_word) 
5f6f				if DEBUG_STK_FAULT 
5f6f					DMARK "FA1" 
5f6f					CALLMONITOR 
5f6f				endif 
5f6f cd 2d 0c			call cmp16 
5f72 ca 7b 5f			jp z, .chk_fault3 
5f75 11 0e 60			ld de, sfaultro 
5f78 c3 a4 5f			jp .chk_fault 
5f7b			.chk_fault3:  
5f7b 2a 1f f7			ld hl, (chk_loop_ovr) 
5f7e ed 5b ad ef		ld de,(chk_word) 
5f82				if DEBUG_STK_FAULT 
5f82					DMARK "FA2" 
5f82					CALLMONITOR 
5f82				endif 
5f82 cd 2d 0c			call cmp16 
5f85 ca 8e 5f			jp z, .chk_fault4 
5f88 11 28 60			ld de, sfaultlo 
5f8b c3 a4 5f			jp .chk_fault 
5f8e			.chk_fault4:  
5f8e 2a 1d f5			ld hl, (chk_data_ovr) 
5f91 ed 5b ad ef		ld de,(chk_word) 
5f95				if DEBUG_STK_FAULT 
5f95					DMARK "FA3" 
5f95					CALLMONITOR 
5f95				endif 
5f95 cd 2d 0c			call cmp16 
5f98 ca a1 5f			jp z, .chk_fault5 
5f9b 11 42 60			ld de, sfaultdo 
5f9e c3 a4 5f			jp .chk_fault 
5fa1			 
5fa1			 
5fa1			.chk_fault5:  
5fa1 d1				pop de 
5fa2 e1				pop hl 
5fa3			 
5fa3 c9				ret 
5fa4			 
5fa4 cd b6 0a		.chk_fault: 	call clear_display 
5fa7 3e 14				ld a, display_row_2 
5fa9 cd c9 0a				call str_at_display 
5fac 11 d2 5f				   ld de, .stackfault 
5faf 3e 00				ld a, display_row_1 
5fb1 cd c9 0a				call str_at_display 
5fb4 11 bd fb				    ld de, debug_mark 
5fb7 3e 11				ld a, display_row_1+17 
5fb9 cd c9 0a				call str_at_display 
5fbc cd d9 0a				call update_display 
5fbf			 
5fbf				; prompt before entering montior for investigating issue 
5fbf			 
5fbf 3e 3c			ld a, display_row_4 
5fc1 11 87 16			ld de, endprog 
5fc4			 
5fc4 cd d9 0a			call update_display		 
5fc7			 
5fc7 cd e5 18			call next_page_prompt 
5fca			 
5fca d1				pop de 
5fcb e1				pop hl 
5fcc cd db 16				call monitor 
5fcf c3 c8 15				jp warmstart 
5fd2					;jp 0 
5fd2					;halt 
5fd2			 
5fd2			 
5fd2			 
5fd2 .. 00		.stackfault: 	db "Stack fault:",0 
5fdf			 
5fdf .. 00		sfaultsu: 	db	"Stack under flow",0 
5ff0 .. 00		sfaultso: 	db	"Stack over flow",0 
6000 .. 00		sfaultru:	db "RTS underflow",0 
600e .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
6028 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
6042 .. 00		sfaultdo:	db "DTS overflow", 0 
604f			 
604f			 
604f			fault_dsp_under: 
604f 11 61 60			ld de, .dsp_under 
6052 c3 11 61			jp .show_fault 
6055			 
6055			fault_rsp_under: 
6055 11 6f 60			ld de, .rsp_under 
6058 c3 11 61			jp .show_fault 
605b			fault_loop_under: 
605b 11 7d 60			ld de, .loop_under 
605e c3 11 61			jp .show_fault 
6061			 
6061 .. 00		.dsp_under: db "DSP Underflow",0 
606f .. 00		.rsp_under: db "RSP Underflow",0 
607d .. 00		.loop_under: db "LOOP Underflow",0 
608c			 
608c			 
608c d5			type_faultn: 	push de 
608d e5					push hl 
608e cd b6 0a				call clear_display 
6091 11 b8 60				   ld de, .typefaultn 
6094 3e 00				ld a, display_row_1 
6096 cd c9 0a				call str_at_display 
6099 11 bd fb				    ld de, debug_mark 
609c 3e 11				ld a, display_row_1+17 
609e cd c9 0a				call str_at_display 
60a1 cd d9 0a				call update_display 
60a4			 
60a4				; prompt before entering montior for investigating issue 
60a4			 
60a4 3e 3c			ld a, display_row_4 
60a6 11 87 16			ld de, endprog 
60a9			 
60a9 cd d9 0a			call update_display		 
60ac			 
60ac cd e5 18			call next_page_prompt 
60af			 
60af e5					push hl 
60b0 d5					push de 
60b1 cd db 16				call monitor 
60b4 c3 c8 15				jp warmstart 
60b7 76					halt 
60b8			 
60b8			 
60b8 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
60cf			 
60cf d5			type_faults: 	push de 
60d0 e5					push hl 
60d1 cd b6 0a				call clear_display 
60d4 11 fa 60				   ld de, .typefaults 
60d7 3e 00				ld a, display_row_1 
60d9 cd c9 0a				call str_at_display 
60dc 11 bd fb				    ld de, debug_mark 
60df 3e 11				ld a, display_row_1+17 
60e1 cd c9 0a				call str_at_display 
60e4 cd d9 0a				call update_display 
60e7			 
60e7				; prompt before entering montior for investigating issue 
60e7			 
60e7 3e 3c			ld a, display_row_4 
60e9 11 87 16			ld de, endprog 
60ec			 
60ec cd d9 0a			call update_display		 
60ef			 
60ef cd e5 18			call next_page_prompt 
60f2			 
60f2 e1					pop hl 
60f3 d1					pop de 
60f4 cd db 16				call monitor 
60f7 c3 c8 15				jp warmstart 
60fa			 
60fa			 
60fa .. 00		.typefaults: db "STR Type Expected TOS!",0 
6111			 
6111			.show_fault: 	 
6111 d5					push de 
6112 cd b6 0a				call clear_display 
6115 d1					pop de 
6116 3e 00				ld a, display_row_1 
6118 cd c9 0a				call str_at_display 
611b 11 bd fb				    ld de, debug_mark 
611e 3e 11				ld a, display_row_1+17 
6120 cd c9 0a				call str_at_display 
6123 cd d9 0a				call update_display 
6126			 
6126				; prompt before entering montior for investigating issue 
6126			 
6126 3e 3c			ld a, display_row_4 
6128 11 87 16			ld de, endprog 
612b			 
612b cd d9 0a			call update_display		 
612e			 
612e cd e5 18			call next_page_prompt 
6131			 
6131 e1					pop hl 
6132 d1					pop de 
6133 cd db 16				call monitor 
6136			; do a dump to cli and not warmstart so we preserve all of the uwords.  
6136			; TODO Make optional fault restart to cli or warm boot? 
6136					;jp warmstart 
6136 c3 20 16				jp cli 
6139 76					halt 
613a			; eof 
# End of file forth_kernel.asm
613a			;include "nascombasic.asm" 
613a			 
613a			 
613a			; find out where the code ends if loaded into RAM (for SC114) 
613a			;endofcode:  
613a			;	nop 
613a			 
613a			 
613a			; eof 
613a			 
# End of file main.asm
613a			include "firmware_lcd_4x20.asm" 
613a			; **********************************************************************  
613a			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
613a			; **********************************************************************  
613a			;  
613a			; **  Written as a Small Computer Monitor App  
613a			; **  www.scc.me.uk  
613a			;  
613a			; History  
613a			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
613a			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
613a			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
613a			;  
613a			; **********************************************************************  
613a			;  
613a			; This program is an example of one of the methods of interfacing an   
613a			; alphanumeric LCD module.   
613a			;  
613a			; In this example the display is connected to either a Z80 PIO or a   
613a			; simple 8-bit output port.   
613a			;  
613a			; This interfacing method uses 4-bit data mode and uses time delays  
613a			; rather than polling the display's ready status. As a result the   
613a			; interface only requires 6 simple output lines:  
613a			;   Output bit 0 = not used  
613a			;   Output bit 1 = not used  
613a			;   Output bit 2 = RS         High = data, Low = instruction  
613a			;   Output bit 3 = E          Active high  
613a			;   Output bit 4 = DB4  
613a			;   Output bit 5 = DB5  
613a			;   Output bit 6 = DB6  
613a			;   Output bit 7 = DB7  
613a			; Display's R/W is connected to 0v so it is always in write mode  
613a			;  
613a			; This set up should work with any system supporting the RC2014 bus  
613a			  
613a			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
613a			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
613a			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
613a			;  
613a			; **********************************************************************  
613a			  
613a			; **********************************************************************  
613a			; **  Constants  
613a			; **********************************************************************  
613a			; LCD constants required by LCD support module  
613a			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
613a			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
613a			kLCDBitE:   EQU 3              ;Port bit for LCD E signal  
613a			kLCDWidth:  EQU display_cols             ;Width in characters  
613a			  
613a			; **********************************************************************  
613a			; **  Code library usage  
613a			; **********************************************************************  
613a			  
613a			; send character to current cursor position  
613a			; wraps and/or scrolls screen automatically  
613a			  
613a			  
613a			lcd_init:  
613a			  
613a			; SCMonAPI functions used  
613a			  
613a			; Alphanumeric LCD functions used  
613a			; no need to specify specific functions for this module  
613a			  
613a 3e cf		            LD   A, 11001111b  
613c d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
613e 3e 00		            LD   A, 00000000b  
6140 d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
6142			  
6142			; Initialise alphanumeric LCD module  
6142 cd bb 61		            CALL fLCD_Init      ;Initialise LCD module  
6145			  
6145 c9				ret  
6146			  
6146			;  
6146			;;  
6146			; lcd functions  
6146			;  
6146			;  
6146			  
6146			; what is at cursor position   
6146			  
6146			;get_cursor:	ld de, (cursor_row)   ;  row + col  
6146			;		call curptr  
6146			;		ret  
6146			  
6146			  
6146			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
6146			  
6146			curptr:  
6146 c5				push bc  
6147 21 53 fb			ld hl, display_fb0  
614a			cpr:	  
614a				; loop for cursor whole row  
614a 0e 14			ld c, display_cols  
614c 23			cpr1:	inc hl  
614d 0d				dec c  
614e 20 fc			jr nz, cpr1  
6150 05				dec b  
6151 20 f7			jr nz, cpr  
6153			  
6153				; add col	  
6153			  
6153 23			cpr2:	inc hl  
6154 1d				dec e  
6155 20 fc			jr nz, cpr2  
6157			  
6157 c1				pop bc  
6158 c9				ret  
6159				  
6159			  
6159			  
6159			  
6159			  
6159			; write the frame buffer given in hl to hardware   
6159 22 5b fa		write_display: ld (display_write_tmp), hl 	   
615c 3e 00			ld a, kLCD_Line1  
615e cd 2c 62		            CALL fLCD_Pos       ;Position cursor to location in A  
6161 06 14			ld b, display_cols  
6163 ed 5b 5b fa		ld de, (display_write_tmp)  
6167 cd b3 61			call write_len_string  
616a				  
616a				  
616a 2a 5b fa			ld hl, (display_write_tmp)  
616d 11 14 00			ld de, display_cols  
6170 19				add hl,de  
6171 22 5b fa			ld (display_write_tmp),hl  
6174			  
6174				  
6174 3e 40			ld a, kLCD_Line2  
6176 cd 2c 62		            CALL fLCD_Pos       ;Position cursor to location in A  
6179 06 14			ld b, display_cols  
617b ed 5b 5b fa		ld de, (display_write_tmp)  
617f cd b3 61			call write_len_string  
6182				  
6182 2a 5b fa			ld hl, (display_write_tmp)  
6185 11 14 00			ld de, display_cols  
6188 19				add hl,de  
6189 22 5b fa			ld (display_write_tmp),hl  
618c			  
618c				  
618c 3e 14			ld a, kLCD_Line3  
618e cd 2c 62		            CALL fLCD_Pos       ;Position cursor to location in A  
6191 06 14			ld b, display_cols  
6193 ed 5b 5b fa		ld de, (display_write_tmp)  
6197 cd b3 61			call write_len_string  
619a				  
619a 2a 5b fa			ld hl, (display_write_tmp)  
619d 11 14 00			ld de, display_cols  
61a0 19				add hl,de  
61a1 22 5b fa			ld (display_write_tmp),hl  
61a4			  
61a4				  
61a4 3e 54			ld a, kLCD_Line4  
61a6 cd 2c 62		            CALL fLCD_Pos       ;Position cursor to location in A  
61a9 06 14			ld b, display_cols  
61ab ed 5b 5b fa		ld de, (display_write_tmp)  
61af cd b3 61			call write_len_string  
61b2 c9					ret  
61b3				  
61b3				; write out a fixed length string given in b from de  
61b3			  
61b3 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
61b4 cd 05 62		            CALL fLCD_Data      ;Write character to display  
61b7 13				inc de  
61b8 10 f9			djnz write_len_string  
61ba c9				ret  
61bb			  
61bb			; Some other things to do  
61bb			;            LD   A, kLCD_Clear ;Display clear  
61bb			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
61bb			;            LD   A, kLCD_Under ;Display on with underscore cursor  
61bb			;            LD   A, kLCD_On     ;Display on with no cursor  
61bb			;            ;LD   A, kLCD_Off   ;Display off  
61bb			;            CALL fLCD_Inst      ;Send instruction to display  
61bb			;  
61bb			;  
61bb			;            halt  
61bb			;  
61bb			;  
61bb			;MsgHello:   DB  "Hello World!",0  
61bb			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
61bb			  
61bb			; Custom characters 5 pixels wide by 8 pixels high  
61bb			; Up to 8 custom characters can be defined  
61bb			;BitMaps:      
61bb			;; Character 0x00 = Battery icon  
61bb			;            DB  01110b  
61bb			;            DB  11011b  
61bb			;            DB  10001b  
61bb			;            DB  10001b  
61bb			;            DB  11111b  
61bb			;            DB  11111b  
61bb			;            DB  11111b  
61bb			;            DB  11111b  
61bb			;; Character 0x01 = Bluetooth icon  
61bb			;            DB  01100b  
61bb			;            DB  01010b  
61bb			;            DB  11100b  
61bb			;            DB  01000b  
61bb			;            DB  11100b  
61bb			;            DB  01010b  
61bb			;            DB  01100b  
61bb			;            DB  00000b  
61bb			;  
61bb			  
61bb			  
61bb			; **********************************************************************  
61bb			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
61bb			; **********************************************************************  
61bb			;  
61bb			; **  Written as a Small Computer Monitor App   
61bb			; **  Version 0.1 SCC 2018-05-16  
61bb			; **  www.scc.me.uk  
61bb			;  
61bb			; **********************************************************************  
61bb			;  
61bb			; This module provides support for alphanumeric LCD modules using with  
61bb			; *  HD44780 (or compatible) controller  
61bb			; *  5 x 7 pixel fonts  
61bb			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
61bb			; *  Interface via six digital outputs to the display (see below)  
61bb			;  
61bb			; LCD module pinout:  
61bb			;   1  Vss   0v supply  
61bb			;   2  Vdd   5v supply  
61bb			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
61bb			;   4  RS    High = data, Low = instruction  
61bb			;   5  R/W   High = Read, Low = Write  
61bb			;   6  E     Enable signal (active high)  
61bb			;   7  DB0   Data bit 0  
61bb			;   8  DB1   Data bit 1  
61bb			;   9  DB2   Data bit 2  
61bb			;  10  DB3   Data bit 3  
61bb			;  11  DB4   Data bit 4  
61bb			;  12  DB5   Data bit 5  
61bb			;  13  DB6   Data bit 6  
61bb			;  14  DB7   Data bit 7  
61bb			;  15  A     Backlight anode (+)  
61bb			;  16  K     Backlight cathode (-)  
61bb			;  
61bb			; This interfacing method uses 4-bit data mode and uses time delays  
61bb			; rather than polling the display's ready status. As a result the   
61bb			; interface only requires 6 simple output lines:  
61bb			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
61bb			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
61bb			;   LCD DB4 = Microcomputer output port bit 4  
61bb			;   LCD DB5 = Microcomputer output port bit 5  
61bb			;   LCD DB6 = Microcomputer output port bit 6  
61bb			;   LCD DB7 = Microcomputer output port bit 7  
61bb			; Display's R/W is connected to 0v so it is always in write mode  
61bb			; All 6 connections must be on the same port address <kLCDPrt>  
61bb			; This method also allows a decent length of cable from micro to LCD  
61bb			;  
61bb			; **********************************************************************  
61bb			;  
61bb			; To include the code for any given function provided by this module,   
61bb			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
61bb			; the parent source file.  
61bb			; For example:  #REQUIRES   uHexPrefix  
61bb			;  
61bb			; Also #INCLUDE this file at some point after the #REQUIRES statements  
61bb			; in the parent source file.  
61bb			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
61bb			;  
61bb			; These are the function names provided by this module:  
61bb			; fLCD_Init                     ;Initialise LCD  
61bb			; fLCD_Inst                     ;Send instruction to LCD  
61bb			; fLCD_Data                     ;Send data byte to LCD  
61bb			; fLCD_Pos                      ;Position cursor  
61bb			; fLCD_Str                      ;Display string  
61bb			; fLCD_Def                      ;Define custom character  
61bb			;  
61bb			; **********************************************************************  
61bb			;  
61bb			; Requires SCMonAPI.asm to also be included in the project  
61bb			;  
61bb			  
61bb			  
61bb			; **********************************************************************  
61bb			; **  Constants  
61bb			; **********************************************************************  
61bb			  
61bb			; Constants that must be defined externally  
61bb			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
61bb			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
61bb			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
61bb			;kLCDWidth: EQU 20             ;Width in characters  
61bb			  
61bb			; general line offsets in any frame buffer  
61bb			  
61bb			  
61bb			display_row_1: equ 0  
61bb			display_row_2: equ display_row_1+display_cols  
61bb			display_row_3: equ display_row_2 + display_cols  
61bb			display_row_4: equ display_row_3 + display_cols  
61bb			;display_row_4_eol:   
61bb			  
61bb			  
61bb			; Cursor position values for the start of each line  
61bb			kLCD_Line1: EQU 0x00   
61bb			kLCD_Line2: EQU 0x40    
61bb			kLCD_Line3: EQU kLCD_Line1+kLCDWidth  
61bb			kLCD_Line4: EQU kLCD_Line2+kLCDWidth   
61bb			  
61bb			; Instructions to send as A register to fLCD_Inst  
61bb			kLCD_Clear: EQU 00000001b     ;LCD clear  
61bb			kLCD_Off:   EQU 00001000b     ;LCD off  
61bb			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
61bb			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
61bb			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
61bb			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
61bb			  
61bb			; Constants used by this code module  
61bb			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
61bb			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
61bb			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
61bb			  
61bb			  
61bb			  
61bb			; **********************************************************************  
61bb			; **  LCD support functions  
61bb			; **********************************************************************  
61bb			  
61bb			; Initialise alphanumeric LCD module  
61bb			; LCD control register codes:  
61bb			;   DL   0 = 4-bit mode        1 = 8-bit mode  
61bb			;   N    0 = 1-line mode       1 = 2-line mode  
61bb			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
61bb			;   D    0 = Display off       1 = Display on  
61bb			;   C    0 = Cursor off        1 = Cursor on  
61bb			;   B    0 = Blinking off      1 = Blinking on  
61bb			;   ID   0 = Decrement mode    1 = Increment mode  
61bb			;   SH   0 = Entire shift off  1 = Entire shift on  
61bb 3e 28		fLCD_Init:  LD   A, 40  
61bd cd 72 62		            CALL LCDDelay       ;Delay 40ms after power up  
61c0			; For reliable reset set 8-bit mode - 3 times  
61c0 cd 5c 62		            CALL WrFn8bit       ;Function = 8-bit mode  
61c3 cd 5c 62		            CALL WrFn8bit       ;Function = 8-bit mode  
61c6 cd 5c 62		            CALL WrFn8bit       ;Function = 8-bit mode  
61c9			; Set 4-bit mode  
61c9 cd 58 62		            CALL WrFn4bit       ;Function = 4-bit mode  
61cc cd 70 62		            CALL LCDDelay1      ;Delay 37 us or more  
61cf			; Function set  
61cf 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
61d1 cd e4 61		            CALL fLCD_Inst      ;2 line, display on  
61d4			; Display On/Off control  
61d4 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
61d6 cd e4 61		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
61d9			; Display Clear  
61d9 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
61db cd e4 61		            CALL fLCD_Inst      ;Clear display  
61de			; Entry mode  
61de 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
61e0 cd e4 61		            CALL fLCD_Inst      ;Increment mode, shift off  
61e3			; Display module now initialised  
61e3 c9			            RET  
61e4			; ok to here  
61e4			  
61e4			; Write instruction to LCD  
61e4			;   On entry: A = Instruction byte to be written  
61e4			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
61e4 f5			fLCD_Inst:  PUSH AF  
61e5 f5			            PUSH AF  
61e6 cd f8 61		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
61e9 f1			            POP  AF  
61ea 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
61eb 17			            RLA  
61ec 17			            RLA  
61ed 17			            RLA  
61ee cd f8 61		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
61f1 3e 02		            LD   A, 2  
61f3 cd 72 62		            CALL LCDDelay       ;Delay 2 ms to complete   
61f6 f1			            POP  AF  
61f7 c9			            RET  
61f8 e6 f0		Wr4bits:   AND  0xF0           ;Mask so we only have D4 to D7  
61fa d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
61fc cb df		            SET  kLCDBitE, A  
61fe d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6200 cb 9f		            RES  kLCDBitE, A  
6202 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6204 c9			            RET  
6205			  
6205			  
6205			; Write data to LCD  
6205			;   On entry: A = Data byte to be written  
6205			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6205 f5			fLCD_Data:  PUSH AF  
6206 f5			            PUSH AF  
6207 cd 19 62		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
620a f1			            POP  AF  
620b 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
620c 17			            RLA  
620d 17			            RLA  
620e 17			            RLA  
620f cd 19 62		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
6212 3e 96		            LD   A, 150  
6214 3d			Wait:      DEC  A              ;Wait a while to allow data   
6215 20 fd		            JR   NZ, Wait      ;  write to complete  
6217 f1			            POP  AF  
6218 c9			            RET  
6219 e6 f0		Wr4bitsa:   AND  0xF0           ;Mask so we only have D4 to D7  
621b cb d7		            SET  kLCDBitRS, A  
621d d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
621f cb df		            SET  kLCDBitE, A  
6221 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
6223 cb 9f		            RES  kLCDBitE, A  
6225 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
6227 cb 97		            RES  kLCDBitRS, A  
6229 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
622b c9			            RET  
622c			  
622c			  
622c			; Position cursor to specified location  
622c			;   On entry: A = Cursor position  
622c			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
622c f5			fLCD_Pos:   PUSH AF  
622d f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
622f cd e4 61		            CALL fLCD_Inst      ;Write instruction to LCD  
6232 f1			            POP  AF  
6233 c9			            RET  
6234			  
6234			  
6234			; Output text string to LCD  
6234			;   On entry: DE = Pointer to null terminated text string  
6234			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
6234 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
6235 b7			            OR   A              ;Null terminator?  
6236 c8			            RET  Z              ;Yes, so finished  
6237 cd 05 62		            CALL fLCD_Data      ;Write character to display  
623a 13			            INC  DE             ;Point to next character  
623b 18 f7		            JR   fLCD_Str       ;Repeat  
623d c9					ret  
623e			  
623e			; Define custom character  
623e			;   On entry: A = Character number (0 to 7)  
623e			;             DE = Pointer to character bitmap data  
623e			;   On exit:  A = Next character number  
623e			;             DE = Next location following bitmap  
623e			;             BC HL IX IY I AF' BC' DE' HL' preserved  
623e			; Character is   
623e c5			fLCD_Def:   PUSH BC  
623f f5			            PUSH AF  
6240 07			            RLCA                ;Calculate location  
6241 07			            RLCA                ;  for bitmap data  
6242 07			            RLCA                ;  = 8 x CharacterNumber  
6243 f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
6245 cd e4 61		            CALL fLCD_Inst      ;Write instruction to LCD  
6248 06 00		            LD   B, 0  
624a 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
624b cd 05 62		            CALL fLCD_Data      ;Write byte to display  
624e 13			            INC  DE             ;Point to next byte  
624f 04			            INC  B              ;Count bytes  
6250 cb 58		            BIT  3, B           ;Finish all 8 bytes?  
6252 28 f6		            JR   Z, Loop       ;No, so repeat  
6254 f1			            POP  AF  
6255 3c			            INC  A              ;Increment character number  
6256 c1			            POP  BC  
6257 c9			            RET  
6258			  
6258			  
6258			; **********************************************************************  
6258			; **  Private functions  
6258			; **********************************************************************  
6258			  
6258			; Write function to LCD  
6258			;   On entry: A = Function byte to be written  
6258			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6258 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
625a 18 02		            JR   WrFunc  
625c 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
625e f5			WrFunc:     PUSH AF  
625f d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6261 cb df		            SET  kLCDBitE, A  
6263 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6265 cb 9f		            RES  kLCDBitE, A  
6267 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6269 3e 05		            LD   A, 5  
626b cd 72 62		            CALL LCDDelay       ;Delay 5 ms to complete  
626e f1			            POP  AF  
626f c9			            RET  
6270			  
6270			  
6270			; Delay in milliseconds  
6270			;   On entry: A = Number of milliseconds delay  
6270			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6270 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
6272 d5			LCDDelay:   PUSH DE  
6273 5f			            LD   E, A           ;Delay by 'A' ms  
6274 16 00		            LD   D, 0  
6276 cd 1f 0a		            CALL aDelayInMS  
6279 d1			            POP  DE  
627a c9			            RET  
627b			  
627b			  
627b			  
627b			  
627b			; eof  
627b			  
# End of file firmware_lcd_4x20.asm
627b			include "firmware_key_4x4.asm" 
627b			  
627b			  
627b			; bit mask for each scan column and row for teing the matrix  
627b			  
627b			; out   
627b 80 40 20 10	key_row_bitmask:    db 128, 64, 32, 16  
627f			; in  
627f 01 02 04 08	key_col_bitmask:    db 1, 2, 4, 8  
6283			  
6283			; row/col to character map  
6283			  
6283			; char, state use   123xxsss   - bit 8,7,6 this key selects specified state, s is this key is member of that state  
6283			;    
6283			  
6283			; physical key matrix map to face of key  
6283			  
6283			  
6283			;      	1	2	3	A  
6283			;   	abc”	def&	ghi$	s1  
6283			;			  
6283			;	4	5	6	B  
6283			; 	jkl,	mno.	pqr:	s2  
6283			;			  
6283			; 	7	8	9	C  
6283			;	stu;	vwx@	yz?!	s3  
6283			;			  
6283			; 	*	0	#	D  
6283			; 	shift lck '	Space < >	Enter ( )	s4  
6283			;       tab bs 		  
6283			  
6283			  
6283			  
6283			  
6283			key_init:  
6283			  
6283			; SCMonAPI functions used  
6283			  
6283			; Alphanumeric LCD functions used  
6283			; no need to specify specific functions for this module  
6283			  
6283			  
6283 3e cf		            LD   A, 11001111b  
6285 d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
6287			;            LD   A, 00000000b  
6287 3e 0f		            LD   A, 00001111b  
6289 d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
628b			  
628b			  
628b				; TODO Configure cursor shapes  
628b			  
628b				; Load cursor shapes   
628b 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
628d 11 9d 62		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
6290 06 02		            LD   B, 2           ;Number of characters to define  
6292 cd 3e 62		.DefLoop:   CALL fLCD_Def       ;Define custom character  
6295 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
6297			  
6297 3e 01				ld a, 1  
6299 32 56 fa			ld (cursor_shape),a  
629c c9				ret  
629d			  
629d			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
629d			; Up to 8 custom characters can be defined  
629d			.cursor_shapes:      
629d			;; Character 0x00 = Normal  
629d 1f			            DB  11111b  
629e 1f			            DB  11111b  
629f 1f			            DB  11111b  
62a0 1f			            DB  11111b  
62a1 1f			            DB  11111b  
62a2 1f			            DB  11111b  
62a3 1f			            DB  11111b  
62a4 1f			            DB  11111b  
62a5			;; Character 0x01 = Modifier  
62a5 1f			            DB  11111b  
62a6 1b			            DB  11011b  
62a7 1b			            DB  11011b  
62a8 1b			            DB  11011b  
62a9 1b			            DB  11011b  
62aa 1f			            DB  11111b  
62ab 1b			            DB  11011b  
62ac 1f			            DB  11111b  
62ad			  
62ad			  
62ad			  
62ad			  
62ad			; Display custom character 0  
62ad			;            LD   A, kLCD_Line1+14  
62ad			;            CALL fLCD_Pos       ;Position cursor to location in A  
62ad			;            LD   A, 0  
62ad			;            CALL fLCD_Data      ;Write character in A at cursor  
62ad			  
62ad			; Display custom character 1  
62ad			;            LD   A, kLCD_Line2+14  
62ad			;            CALL fLCD_Pos      ;Position cursor to location in A  
62ad			;            LD   A, 1  
62ad			;            CALL fLCD_Data     ;Write character in A at cursor  
62ad			  
62ad			; keyboard scanning   
62ad			  
62ad			  
62ad			; key_rows: equ 4  
62ad			; key_cols: equ 4  
62ad			; keyscan_table: edu ( tos-stacksize-(key_rows*key_cols))  
62ad			  
62ad			; key_scanr: equ key_row_bitmask  
62ad			; key_scanc: equ key_col_bitmask  
62ad			  
62ad			; key_char_map: equ key_map  
62ad			  
62ad			  
62ad			  
62ad			; character in from keyboard  
62ad			  
62ad ..			.matrix_to_char: db "D#0*C987B654A321"  
62bd			  
62bd			  
62bd			; map the physical key to a char dependant on state  
62bd			  
62bd			.key_map_fa:   
62bd			  
62bd ..					db 'D'  
62be 0d					db KEY_CR    ; cr  
62bf ..					db ' '  
62c0 04					db  KEY_SHIFTLOCK   ; TODO Shift lock  
62c1 ..					db 'C'  
62c2 ..					db 'y'  
62c3 ..					db 'v'  
62c4 ..					db 's'  
62c5 ..					db 'B'  
62c6 ..					db 'p'  
62c7 ..					db 'm'  
62c8 ..					db 'j'  
62c9 ..					db 'A'  
62ca ..					db 'g'  
62cb ..					db 'd'  
62cc ..					db 'a'  
62cd			  
62cd			.key_map_fb:  
62cd			  
62cd ..					db 'A'  
62ce ..					db '+'   
62cf ..					db '<'  
62d0 ..					db  "'"    
62d1			  
62d1 ..					db 'A'  
62d2 ..					db 'z'  
62d3 ..					db 'w'  
62d4 ..					db 't'  
62d5 ..					db 'A'  
62d6 ..					db 'q'  
62d7 ..					db 'n'  
62d8 ..					db 'k'  
62d9 ..					db 'A'  
62da ..					db 'h'  
62db ..					db 'e'  
62dc ..			 		db 'b'  
62dd			  
62dd			.key_map_fc:   
62dd			  
62dd			  
62dd ..					db 'A'  
62de ..					db '-'   
62df ..					db '>'  
62e0 ..					db  '='   	  
62e1 ..					db 'A'  
62e2 ..					db '?'  
62e3 ..					db 'x'  
62e4 ..					db 'u'  
62e5 ..					db 'A'  
62e6 ..					db 'r'  
62e7 ..					db 'o'  
62e8 ..					db 'l'  
62e9 ..					db 'A'  
62ea ..					db 'i'  
62eb ..					db 'f'  
62ec ..					db 'c'  
62ed			  
62ed				  
62ed			.key_map_fd:  
62ed			  
62ed ..					db 'A'  
62ee ..					db '/'   
62ef ..					db '%'   
62f0 08					db KEY_BS  ; back space  
62f1 ..					db 'A'  
62f2 ..					db '!'  
62f3 ..					db '@'  
62f4 ..					db ';'  
62f5 ..					db 'A'  
62f6 ..					db ':'  
62f7 ..					db '.'  
62f8 ..					db ','  
62f9 ..					db 'A'  
62fa ..					db '$'  
62fb ..					db '&'  
62fc ..				 	db '"'  
62fd			  
62fd					  
62fd				  
62fd			  
62fd			; add cin and cin_wait  
62fd			  
62fd cd 0e 63		cin_wait: 	call cin  
6300 fe 00			cp 0  
6302 28 f9			jr z, cin_wait   ; block until key press  
6304			  
6304 f5				push af   ; save key pressed  
6305			  
6305 cd 0e 63		.cin_wait1:	call cin  
6308 fe 00			cp 0  
630a 20 f9			jr nz, .cin_wait1  	; wait for key release  
630c			  
630c f1				pop af   ; get key  
630d c9				ret  
630e			  
630e			  
630e cd 1f 63		cin: 	call .mtoc  
6311			  
6311				; no key held  
6311 fe 00			cp 0  
6313 c8				ret z  
6314			  
6314				; stop key bounce  
6314			  
6314			;	ld (key_held),a		 ; save it  
6314 47				ld b, a  
6315			  
6315 c5			.cina1:	push bc  
6316 cd 1f 63			call .mtoc  
6319 c1				pop bc  
631a b8				cp b  
631b 28 f8			jr z, .cina1  
631d 78				ld a,b		  
631e c9				ret  
631f			  
631f			; detect keyboard modifier key press and apply new overlay to the face key held  
631f			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
631f			  
631f			;.cin_map_modifier:   
631f			;	ld a, (hl)  
631f			;	and 255  
631f			;	ret NZ		; modifier key not flagged  
631f			;  
631f			;	; get key face  
631f			;  
631f			;	ld b,(key_face_held)  
631f			;  
631f			;	ld b, key_cols * key_rows  
631f			;  
631f			;	push de  
631f			;	pop hl  
631f			;  
631f			;.mmod1: ld a,(hl)   ; get map test  
631f			;	cp b  
631f			;	jr z, .mmod2  
631f			;  
631f			;  
631f			;  
631f			;.mmod2: inc hl    ;   
631f			;  
631f			;	  
631f			;  
631f			;	  
631f			;  
631f			;	ld hl,key_actual_pressed  
631f			;	ld (hl),a,  
631f			;	ret  
631f			  
631f				  
631f			  
631f			; map matrix key held to char on face of key  
631f			  
631f			.mtoc:  
631f			  
631f			  
631f				; TODO optimise the code....  
631f			  
631f			; scan keyboard row 1  
631f 3e 80			ld a, 128  
6321 21 d3 fb			ld hl, keyscan_table  
6324 cd 06 64			call .rowscan  
6327			  
6327				   
6327			  
6327 3e 40			ld a, 64  
6329 21 d7 fb			ld hl, keyscan_table+key_cols  
632c cd 06 64			call .rowscan  
632f			  
632f			  
632f			  
632f			  
632f 3e 20			ld a, 32  
6331 21 db fb			ld hl, keyscan_table+(key_cols*2)  
6334 cd 06 64			call .rowscan  
6337			  
6337			  
6337			  
6337 3e 10			ld a, 16  
6339 21 df fb			ld hl, keyscan_table+(key_cols*3)  
633c cd 06 64			call .rowscan  
633f			  
633f			  
633f				; flag if key D is held down and remove from reporting  
633f 01 ed 62			ld bc, .key_map_fd    
6342 21 d3 fb			ld hl, keyscan_table  
6345 11 c5 fb			ld de, key_fd  
6348 cd 98 63			call .key_shift_hold  
634b fe ff			cp 255  
634d 28 33			jr z, .cinmap  
634f				; flag if key C is held down and remove from reporting  
634f 01 dd 62			ld bc, .key_map_fc    
6352 21 d7 fb			ld hl, keyscan_table+key_cols  
6355 11 c6 fb			ld de, key_fc  
6358 cd 98 63			call .key_shift_hold  
635b fe ff			cp 255  
635d 28 23			jr z, .cinmap  
635f				; flag if key B is held down and remove from reporting  
635f 01 cd 62			ld bc, .key_map_fb    
6362 21 db fb			ld hl, keyscan_table+(key_cols*2)  
6365 11 c7 fb			ld de, key_fb  
6368 cd 98 63			call .key_shift_hold  
636b fe ff			cp 255  
636d 28 13			jr z, .cinmap  
636f				; flag if key A is held down and remove from reporting  
636f 01 bd 62			ld bc, .key_map_fa    
6372 21 df fb			ld hl, keyscan_table+(key_cols*3)  
6375 11 c8 fb			ld de, key_fa  
6378 cd 98 63			call .key_shift_hold  
637b fe ff			cp 255  
637d 28 03			jr z, .cinmap  
637f			  
637f 11 ad 62			ld de, .matrix_to_char  
6382			  
6382			  
6382			.cinmap:   
6382				if DEBUG_KEY  
6382			            LD   A, kLCD_Line4  
6382			            CALL fLCD_Pos       ;Position cursor to location in A  
6382					push de  
6382			            LD   DE, keyscan_table  
6382			            CALL fLCD_Str       ;Display string pointed to by DE  
6382					pop de  
6382				endif  
6382			  
6382				; scan key matrix table for any held key  
6382			  
6382				; de holds either the default matrix or one selected above  
6382			  
6382 21 d3 fb			ld hl, keyscan_table  
6385 06 10			ld b,key_cols*key_rows  
6387			  
6387 7e			.cin1:	ld a,(hl)  
6388 fe 23			cp '#'  
638a 28 08			jr z, .cinhit  
638c 23				inc hl  
638d 13				inc de  
638e 05				dec b  
638f 20 f6			jr nz, .cin1  
6391				; no key found held  
6391 3e 00			ld a,0  
6393 c9				ret  
6394 d5			.cinhit: push de  
6395 e1				pop hl  
6396 7e				ld a,(hl)  
6397 c9				ret  
6398			  
6398			; flag a control key is held   
6398			; hl is key pin, de is flag indicator  
6398			  
6398			.key_shift_hold:  
6398 c5				push bc  
6399 3e 01			ld a, 1  
639b 32 56 fa			ld (cursor_shape),a  
639e 06 00			ld b, 0  
63a0 7e				ld a, (hl)  
63a1 fe 2e			cp '.'  
63a3 28 0a			jr z, .key_shift1  
63a5 06 ff			ld b, 255  
63a7 3e 2b			ld a, '+'    ; hide key from later scans  
63a9 77				ld (hl),a  
63aa 3e 02			ld a, 2  
63ac 32 56 fa			ld (cursor_shape),a  
63af			.key_shift1:  
63af				; write flag indicator  
63af 78				ld a,b  
63b0 12				ld (de),a  
63b1			  
63b1 d1				pop de    ; de now holds the key map ptr  
63b2 c9				ret  
63b3			  
63b3				  
63b3				  
63b3			  
63b3			  
63b3			  
63b3			  
63b3			  
63b3			  
63b3			  
63b3			  
63b3			  
63b3			  
63b3 c9				ret  
63b4			  
63b4			;	push hl  
63b4			;	push de  
63b4			;	push bc  
63b4			;	call keyscan  
63b4			;	; map key matrix to ascii value of key face  
63b4			;  
63b4			;	ld hl, key_face_map  
63b4			;	ld de, keyscan_table  
63b4			;  
63b4			;	; get how many keys to look at  
63b4			;	ld b, keyscan_table_len  
63b4			;	  
63b4			;  
63b4			;	; at this stage fall out on first key hit  
63b4			;	; TODO handle multiple key press  
63b4			;  
63b4			;map1:	ld a,(hl)  
63b4			;	cp '#'  
63b4			;	jr z, keyhit  
63b4			;	inc hl  
63b4			;	inc de  
63b4			;	dec b  
63b4			;	jr nz, map1  
63b4			;nohit:	ld a, 0  
63b4			;	jr keydone  
63b4			;keyhit: push de  
63b4			;	pop hl  
63b4			;	ld a,(hl)  
63b4			;keydone:  
63b4			;	push bc  
63b4			;	push de  
63b4			; 	push hl  
63b4			;	ret   
63b4			;  
63b4			  
63b4			  
63b4			  
63b4			  
63b4			; scan physical key matrix  
63b4			  
63b4			  
63b4			;keyscan:  
63b4			;  
63b4			;; for each key_row use keyscanr bit mask for out  
63b4			;; then read in for keyscanc bitmask  
63b4			;; save result of row scan to keyscantable  
63b4			;  
63b4			;; scan keyboard row 1  
63b4			;  
63b4			;	ld b, key_rows  
63b4			;	ld hl, key_scanr  
63b4			;	ld de, keyscan_table  
63b4			;  
63b4			;rowloop:  
63b4			;  
63b4			;	ld a,(hl)		; out bit mask to energise keyboard row  
63b4			;	call rowscan  
63b4			;	inc hl  
63b4			;	dec b  
63b4			;	jr nz, rowloop  
63b4			;  
63b4			;	ret  
63b4			;  
63b4			;  
63b4			;; pass a out bitmask, b row number  
63b4			;arowscan:   
63b4			;	push bc  
63b4			;  
63b4			;	ld d, b  
63b4			;  
63b4			;	; calculate buffer location for this row  
63b4			;  
63b4			;	ld hl, keyscan_table	  
63b4			;kbufr:  ld e, key_cols  
63b4			;kbufc:	inc hl  
63b4			;	dec e  
63b4			;	jr nz, kbufc  
63b4			;	dec d  
63b4			;	jr nz, kbufr  
63b4			;  
63b4			;	; energise row and read columns  
63b4			;  
63b4			;	out (portbdata),a  
63b4			;	in a,(portbdata)  
63b4			;	ld c,a  
63b4			;  
63b4			;  
63b4			;	; save buffer loc  
63b4			;  
63b4			;	ld (keybufptr), hl  
63b4			;  
63b4			;	ld hl, key_scanc  
63b4			;	ld d, key_cols  
63b4			;  
63b4			;	; for each column check each bit mask  
63b4			;  
63b4			;colloop:  
63b4			;	  
63b4			;  
63b4			;	; reset flags for the row   
63b4			;  
63b4			;	ld b,'.'  
63b4			;	and (hl)  
63b4			;	jr z, maskskip  
63b4			;	ld b,'#'  
63b4			;maskskip:  
63b4			;	; save  key state  
63b4			;	push hl  
63b4			;	ld hl, (keybufptr)  
63b4			;	ld (hl), b  
63b4			;	inc hl  
63b4			;	ld (keybufptr), hl  
63b4			;  
63b4			;	; move to next bit mask  
63b4			;	pop hl  
63b4			;	inc hl  
63b4			;  
63b4			;	dec d  
63b4			;	jr nz, colloop  
63b4			;  
63b4			;	ret  
63b4			;  
63b4			;  
63b4			;;  
63b4			; lcd functions  
63b4			;  
63b4			;  
63b4			  
63b4			;if DEBUG_KEY_MATRIX  
63b4			  
63b4			; test function to display hardware view of matrix state  
63b4			  
63b4			matrix:  
63b4			  
63b4			  
63b4			  
63b4			; scan keyboard row 1  
63b4 3e 80			ld a, 128  
63b6 21 f8 fb			ld hl, keyscan_table_row1  
63b9 cd 06 64			call .rowscan  
63bc			  
63bc 3e 40			ld a, 64  
63be 21 f3 fb			ld hl, keyscan_table_row2  
63c1 cd 06 64			call .rowscan  
63c4			  
63c4 3e 20			ld a, 32  
63c6 21 ee fb			ld hl, keyscan_table_row3  
63c9 cd 06 64			call .rowscan  
63cc			  
63cc 3e 10			ld a, 16  
63ce 21 e9 fb			ld hl, keyscan_table_row4  
63d1 cd 06 64			call .rowscan  
63d4			  
63d4			; Display text on first line  
63d4 3e 00		            LD   A, kLCD_Line1  
63d6 cd 2c 62		            CALL fLCD_Pos       ;Position cursor to location in A  
63d9 11 f8 fb		            LD   DE, keyscan_table_row1  
63dc			            ;LD   DE, MsgHello  
63dc cd 34 62		            CALL fLCD_Str       ;Display string pointed to by DE  
63df			  
63df			; Display text on second line  
63df 3e 40		            LD   A, kLCD_Line2  
63e1 cd 2c 62		            CALL fLCD_Pos       ;Position cursor to location in A  
63e4 11 f3 fb		            LD   DE, keyscan_table_row2  
63e7 cd 34 62		            CALL fLCD_Str       ;Display string pointed to by DE  
63ea 3e 14		            LD   A, kLCD_Line3  
63ec cd 2c 62		            CALL fLCD_Pos       ;Position cursor to location in A  
63ef 11 ee fb		            LD   DE, keyscan_table_row3  
63f2 cd 34 62		            CALL fLCD_Str       ;Display string pointed to by DE  
63f5 3e 54		            LD   A, kLCD_Line4  
63f7 cd 2c 62		            CALL fLCD_Pos       ;Position cursor to location in A  
63fa 11 e9 fb		            LD   DE, keyscan_table_row4  
63fd cd 34 62		            CALL fLCD_Str       ;Display string pointed to by DE  
6400			  
6400 cd 2e 0a			call delay250ms  
6403 c3 b4 63			jp matrix  
6406			  
6406			; pass de as row display flags  
6406			.rowscan:   
6406 d3 c1			out (portbdata),a  
6408 db c1			in a,(portbdata)  
640a 4f				ld c,a  
640b				; reset flags for the row   
640b 06 2e			ld b,'.'  
640d e6 01			and 1  
640f 28 02			jr z, .p1on  
6411 06 23			ld b,'#'  
6413			.p1on:  
6413 70				ld (hl), b  
6414 23				inc hl  
6415			  
6415 06 2e			ld b,'.'  
6417 79				ld a,c  
6418 e6 02			and 2  
641a			;	bit 0,a  
641a 28 02			jr z, .p2on  
641c 06 23			ld b,'#'  
641e			.p2on:  
641e 70				ld (hl), b  
641f 23				inc hl  
6420			;  
6420 06 2e			ld b,'.'  
6422 79				ld a,c  
6423 e6 04			and 4  
6425			;;	bit 0,a  
6425 28 02			jr z, .p3on  
6427 06 23			ld b,'#'  
6429			.p3on:  
6429 70				ld (hl), b  
642a 23				inc hl  
642b			;;  
642b 06 2e			ld b,'.'  
642d			;;	bit 0,a  
642d 79				ld a,c  
642e e6 08			and 8  
6430 28 02			jr z, .p4on  
6432 06 23			ld b,'#'  
6434			.p4on:  
6434 70				ld (hl), b  
6435 23				inc hl  
6436			  
6436			; zero term  
6436 06 00			ld b,0  
6438 70				ld (hl), b  
6439			  
6439 c9			.rscandone: ret  
643a			  
643a			  
643a			  
643a			;endif  
643a			  
643a			  
643a			; eof  
# End of file firmware_key_4x4.asm
# End of file os_mini.asm
643a
