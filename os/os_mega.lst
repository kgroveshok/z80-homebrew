# File os_mega.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 0 
0000			STARTUP_V2: equ 1 
0000			 
0000			tos:	equ 0fffdh 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			  
0000			; now handled by SPI support 
0000			SOUND_ENABLE: equ 0    
0000			 
0000			; Number of bytes available in heap   TODO make all of user ram 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 19 1d			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			 
0003 .. 00		buildtime: db   "Build: 00/00/00 00:00:00",0 
001c			 
001c			 
001c			 
001c			;        nop  
001c			;        nop 
001c			;;	org 05h		; null out bdos call 
001c			; 
001c			;        nop  
001c			;        nop  
001c			;        nop 
001c			;;	org 08h 
001c			;;; 
001c			;;	jp cin		; rst 8 - char in 
001c			;;; 
001c			; 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;	org 010h 
001c			;; 
001c			;	jp cout		; rest 010h  - char out 
001c			;; 
001c			;	org 01bh   
001c			; 
001c			;	;jp  		; rst 01bh   - write string to display 
001c			;	jp str_at_display 
001c			; 
001c			; 
001c			;	org 020h 
001c			; 
001c			;	; jp		 ; rst 020h - read char at screen location 
001c			; 
001c			;	org 028h 
001c			 
001c				; jp		 ; rst 028h  - storage i/o 
001c			 
001c			; 	org 030h 
001c			;	jp break_point_state 
001c			  
001c			; $30  
001c			; org 038h 
001c			; $38 
001c			 
001c			; TODO any more important entry points to add to jump table for easier coding use? 
001c			 
001c			if BASE_KEV = 1  
001c			 
001c				; need to be at $66 for nmi support 
001c 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0022 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0028 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
002e 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0034 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
003a 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0040 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0046 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
004c 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0052 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0058 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
005e 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0064 00 ff			db 0,255 
0066 c3 4f 76			jp nmi 
0069			endif 
0069			 
0069			include "firmware.asm" 
0069			  
0069			; main constants (used here and in firmware)  
0069			  
0069			; TODO have page 0 of storage as bios  
0069			  
0069			Device_A: equ 0h  
0069			Device_B: equ 040h          ; Sound  
0069			  
0069			if BASE_KEV  
0069			Device_C: equ 080h          ; Storage and ext cart devices  
0069			endif  
0069			  
0069			if BASE_SC114  
0069			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
0069			endif  
0069			  
0069			if BASE_CPM  
0069			; TODO fixup for CPM  
0069			Device_C: equ 080h          ; Storage and ext cart devices  
0069			endif  
0069			  
0069			Device_D: equ 0c0h             ; Keyboard and LCD  
0069			  
0069			; Odd specific debug points for testing hardware dev  
0069			  
0069			DEBUG_SOUND: equ 0       
0069			DEBUG_STK_FAULT: equ 0  
0069			DEBUG_INPUT: equ 0     ; Debug input entry code  
0069			DEBUG_KEYCINWAIT: equ 0  
0069			DEBUG_KEYCIN: equ 0  
0069			DEBUG_KEY: equ 0  
0069			DEBUG_KEY_MATRIX: equ 0  
0069			DEBUG_STORECF: equ 0  
0069			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
0069			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
0069			DEBUG_SPI: equ 0    ; low level spi tests  
0069			  
0069			; Enable many break points  
0069			  
0069			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
0069			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
0069			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
0069			DEBUG_FORTH_JP: equ 0    ; 4  
0069			DEBUG_FORTH_MALLOC: equ 0  
0069			DEBUG_FORTH_MALLOC_INT: equ 0  
0069			DEBUG_FORTH_DOT: equ 1  
0069			DEBUG_FORTH_DOT_WAIT: equ 0  
0069			DEBUG_FORTH_MATHS: equ 0  
0069			DEBUG_FORTH_TOK: equ 0    ; 4  
0069			DEBUG_FORTH_PARSE: equ 0    ; 3  
0069			DEBUG_FORTH: equ 0  ;2  
0069			DEBUG_FORTH_WORDS: equ 1   ; 1  
0069			DEBUG_FORTH_PUSH: equ 1   ; 1  
0069			DEBUG_FORTH_UWORD: equ 1   ; 1  
0069			  
0069			; Enable key point breakpoints  
0069			  
0069			DEBUG_FORTH_DOT_KEY: equ 0  
0069			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
0069			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
0069			  
0069			; Debug stack imbalances  
0069			  
0069			ON: equ 1  
0069			OFF: equ 0  
0069			  
0069			DEBUG_STACK_IMB: equ 0  
0069			STACK_IMB_STORE: equ 20  
0069			  
0069			; House keeping and protections  
0069			  
0069			DEBUG_FORTH_STACK_GUARD: equ 1  
0069			DEBUG_FORTH_MALLOC_GUARD: equ 1  
0069			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
0069			FORTH_ENABLE_FREE: equ 0  
0069			FORTH_ENABLE_MALLOCFREE: equ 1  
0069			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
0069			FORTH_ENABLE_FLOATMATH: equ 0  
0069			  
0069			  
0069			CALLMONITOR: macro  
0069			;	call break_point_state  
0069			; now use the break point debug vector  
0069				call debug_vector  
0069				endm  
0069			  
0069			MALLOC_1: equ 1        ; from dk88   
0069			MALLOC_2: equ 0           ; broke  
0069			MALLOC_3: equ 0           ; really broke  
0069			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
0069			  
0069			if BASE_KEV   
0069			stacksize: equ 256  
0069			  
0069			STACK_RET_SIZE: equ 64  
0069			STACK_LOOP_SIZE: equ 128  
0069			STACK_DATA_SIZE: equ 512  
0069			endif  
0069			if BASE_SC114  
0069			;tos:	equ 0f000h  
0069			stacksize: equ 256  
0069			STACK_RET_SIZE: equ 64  
0069			STACK_LOOP_SIZE: equ 128  
0069			STACK_DATA_SIZE: equ 256  
0069			endif  
0069			  
0069			if BASE_CPM  
0069			;tos:	equ 0f000h  
0069			stacksize: equ 256  
0069			STACK_RET_SIZE: equ 64  
0069			STACK_LOOP_SIZE: equ 128  
0069			STACK_DATA_SIZE: equ 256  
0069			endif  
0069			  
0069			;if STORAGE_SE == 0  
0069			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
0069			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
0069			;endif  
0069			  
0069			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
0069			  
0069			STORE_0_AUTORUN: equ $20  
0069			  
0069			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
0069			  
0069			STORE_0_AUTOFILE: equ $21  
0069			STORE_0_BANKRUN: equ $23  
0069			STORE_0_FILERUN: equ $24  
0069			  
0069			; Block 0 offsets for settings  
0069			  
0069			; if set then skip prompt for start up and accept all  
0069			  
0069			STORE_0_QUICKSTART: equ $25  
0069			  
0069			; Blocks where directory table is held  
0069			  
0069			; Reducing the number of entries increases the max file size  
0069			  
0069			;STORE_DIR_START: equ 1  
0069			;STORE_DIR_END: equ 33  
0069			  
0069			; Blocks from where file data is stored  
0069			  
0069			;STORE_DATA_START: equ STORE_DIR_END + 1  
0069			  
0069			; Block indicators (<32 are data files)  
0069			  
0069			;STORE_BLOCK_CFG: equ $8f       ; config block  
0069			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
0069			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
0069			;STORE_BLOCK_FREE: equ $85       ; data block free  
0069			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
0069			  
0069			  
0069			  
0069			; Directory entry flags  
0069			  
0069			;STORE_DIR_FREE: equ 0  
0069			;STORE_DIR_FILE:  equ 1  
0069			  
0069			; Structure offsets to directory entries  
0069			;STORE_DE_FLAG: equ 0  
0069			;STORE_DE_MAXEXT: equ 1  
0069			;STORE_DE_FILENAME: equ 2  
0069			  
0069			; Structure offsets to block 0  
0069			  
0069			;STORE_BK0_ISFOR: equ 1  
0069			;STORE_BK0_LABEL: equ 3  
0069			  
0069			; memory allocation   
0069			  
0069			chk_stund: equ tos+2           ; underflow check word  
0069			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
0069			  
0069			; keyscan table needs rows x cols buffer  
0069			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
0069			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
0069			  
0069			keyscan_table_row1: equ chk_stovr -key_cols-1  
0069			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
0069			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
0069			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
0069			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
0069			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
0069			keyscan_scancol: equ keyscan_table-key_cols  
0069			;keyscan_table_len: equ key_rows*key_cols  
0069			;keybufptr: equ keyscan_table - 2  
0069			;keysymbol: equ keybufptr - 1  
0069			key_held: equ keyscan_scancol-1	; currently held  
0069			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
0069			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
0069			key_fa: equ key_repeat_ct -1 ;  
0069			key_fb: equ key_fa -1 ;  
0069			key_fc: equ key_fb -1 ;  
0069			key_fd: equ key_fc -1 ;  
0069			key_face_held: equ key_fd - 1   
0069			  
0069			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
0069			  
0069			hardware_config: equ key_face_held - 10  
0069			  
0069			; hardware config switches  
0069			; TODO add bitmasks on includes for hardware  
0069			; high byte for expansion ids  
0069			;     0000 0000  no card inserted  
0069			;     0000 0001  storage card inserted  
0069			;     0000 0010  spi sd card active  
0069			  
0069			;       
0069			; low byte:  
0069			;     0000 0001   4x4 keypad  
0069			;     0000 0010   full keyboard  
0069			;     0000 0011   spi/ext keyboard  
0069			;     0000 0100   20x4 lcd  
0069			;     0000 1000   40x4 lcd  
0069			;     0000 1100   spi/ext display  
0069			;     0001 0000   ide interface available  
0069			  
0069			hardware_word: equ hardware_config - 2  
0069			  
0069			; debug marker - optional display of debug point on the debug screens  
0069			  
0069			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
0069			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
0069			  
0069			debug_mark: equ debug_vector - 4  
0069			  
0069			; input_str vars  
0069			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
0069			input_start:  equ input_ptr - 2    ; ptr to the start of string   
0069			input_size: equ input_start -1  ; number of chars  
0069			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
0069			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
0069			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
0069			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
0069			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
0069			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
0069			input_len: equ input_cur_onoff - 5 ; length of current input  
0069			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
0069			  
0069			CUR_BLINK_RATE: equ 15  
0069			  
0069			key_actual_pressed: equ input_cursor - 1   
0069			key_symbol: equ key_actual_pressed - 1   
0069			key_shift: equ key_symbol - 1   
0069			  
0069			; Display allocation  
0069			  
0069			;display_rows: equ 4     ; move out to mini and mega files  
0069			;display_cols: equ 20  
0069			  
0069			display_fb_len: equ display_rows*display_cols  
0069			  
0069			; primary frame buffer     
0069			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
0069			; working frame buffers  
0069			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
0069			display_fb3: equ  display_fb1-display_fb_len - 1  
0069			display_fb2: equ  display_fb3-display_fb_len - 1  
0069			;  
0069			; pointer to active frame buffer  
0069			display_fb_active: equ display_fb2 - 2  
0069			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
0069			display_write_tmp: equ display_lcde1e2 - 2  
0069			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
0069			  
0069			;  
0069			  
0069			;; can load into de directory  
0069			cursor_col: equ display_active-1  
0069			cursor_row: equ cursor_col-1  
0069			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
0069			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
0069			  
0069			; maths vars  
0069			  
0069			LFSRSeed: equ cursor_shape -20   
0069			randData: equ LFSRSeed - 2  
0069			xrandc: equ randData - 2  
0069			stackstore: equ xrandc - 2  
0069			seed1: equ  stackstore -2   
0069			seed2: equ seed1 - 2  
0069			  
0069			; cf storage vars  
0069			  
0069			iErrorNum:  equ seed2-1         ;Error number  
0069			iErrorReg:  equ iErrorNum -1              ;Error register  
0069			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
0069			  
0069			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
0069			  
0069			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
0069			  
0069			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
0069			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
0069			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
0069			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
0069			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
0069			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
0069			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
0069			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
0069			store_tmpid: equ store_tmp3 - 1		; page temp id  
0069			store_tmpext: equ store_tmpid - 1		; file extent temp  
0069			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
0069			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
0069			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
0069			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
0069			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
0069			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
0069			;  
0069			; spi vars  
0069			  
0069			  
0069			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
0069			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
0069			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
0069			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
0069			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
0069			spi_device_id: equ spi_device - 1    ; human readable bank number  
0069			  
0069			;;;;; forth cli params  
0069			  
0069			; TODO use a different frame buffer for forth???  
0069			  
0069			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
0069			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
0069			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
0069			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
0069			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
0069			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
0069			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
0069			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
0069			  
0069			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
0069			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
0069			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
0069			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
0069			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
0069			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
0069			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
0069			  
0069			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
0069			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0069			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
0069			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0069			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
0069			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
0069			chk_data_ovr: equ cli_data_stack -2; overflow check word  
0069			  
0069			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
0069			  
0069			; os/forth token vars  
0069			  
0069			os_last_cmd: equ os_var_array-255  
0069			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
0069			os_current_i: equ os_cli_cmd-2  
0069			os_cur_ptr: equ os_current_i-2  
0069			os_word_scratch: equ os_cur_ptr-30  
0069			os_tok_len: equ os_word_scratch - 2  
0069			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
0069			os_tok_malloc: equ os_tok_ptr - 2  
0069			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
0069			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
0069			execscratch: equ os_input-255        ; exec cmd eval buffer  
0069			scratch: equ execscratch-255  
0069			  
0069			  
0069			; temp locations for new word processing to save on adding more   
0069			  
0069			os_new_malloc: equ scratch-2  
0069			os_new_parse_len: equ os_new_malloc - 2  
0069			os_new_word_len: equ os_new_parse_len - 2  
0069			os_new_work_ptr: equ os_new_word_len - 2  
0069			os_new_src_ptr: equ os_new_work_ptr - 2  
0069			os_new_exec: equ os_new_src_ptr - 2  
0069			os_new_exec_ptr: equ os_new_exec - 2  
0069			  
0069			; resume memory alloocations....  
0069			  
0069			;os_view_disable: equ os_new_exec_ptr - 1  
0069			os_view_af: equ os_new_exec_ptr - 2  
0069			os_view_hl: equ os_view_af -2  
0069			os_view_de: equ os_view_hl - 2  
0069			os_view_bc: equ os_view_de - 2  
0069			  
0069			; stack checksum word  
0069			if DEBUG_STACK_IMB  
0069				curframe: equ  os_view_de - 5  
0069				store_sp: equ curframe - (STACK_IMB_STORE*4)  
0069				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0069			else  
0069				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0069			endif  
0069			  
0069			; with data stack could see memory filled with junk. need some memory management   
0069			; malloc and free entry points added  
0069			  
0069			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
0069			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
0069			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
0069			;heap_end: equ free_list-1  ; Starting address of heap  
0069			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0069			  
0069			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0069			heap_end: equ chk_word-1  ; Starting address of heap  
0069			  
0069			  
0069			;if BASE_KEV   
0069			;heap_start: equ 0800eh  ; Starting address of heap  
0069			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
0069			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
0069			;endif  
0069			  
0069			;if BASE_SC114  
0069			;heap_start: equ baseram+15  ; Starting address of heap  
0069			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
0069			;endif  
0069			  
0069			  
0069			;;;;  
0069			  
0069			  
0069			; change below to point to last memory alloc above  
0069			topusermem:  equ   heap_start  
0069			  
0069			;if BASE_KEV   
0069			;baseusermem: equ 08000h  
0069			;endif  
0069			  
0069			;if BASE_SC114  
0069			;;aseusermem:     equ    12  
0069			;baseusermem:     equ    prompt  
0069			;;baseusermem:     equ    endofcode  
0069			;endif  
0069			  
0069			  
0069			; **********************************************************************  
0069			; **  Constants  
0069			; **********************************************************************  
0069			  
0069			; Constants used by this code module  
0069			kDataReg:   EQU Device_D           ;PIO port A data register  
0069			kContReg:   EQU Device_D+2           ;PIO port A control register  
0069			  
0069			  
0069			portbdata:  equ Device_D+1    ; port b data  
0069			portbctl:   equ Device_D+3    ; port b control  
0069			  
0069			  
0069			;KEY_SHIFT:   equ 5  
0069			;KEY_SYMBOLSHIFT:  equ 6  
0069			  
0069			KEY_SHIFTLOCK: equ 4  
0069			  
0069			  
0069			KEY_UP: equ 5  
0069			KEY_NEXTWORD: equ 6  
0069			KEY_PREVWORD: equ 7  
0069			KEY_BS: equ 8  
0069			KEY_TAB:  equ 9  
0069			KEY_DOWN: equ 10  
0069			KEY_LEFT: equ 11  
0069			KEY_RIGHT: equ 12  
0069			KEY_CR:   equ 13  
0069			KEY_HOME: equ 14  
0069			KEY_END: equ 15  
0069			  
0069			KEY_F1: equ 16  
0069			KEY_F2: equ 17  
0069			KEY_F3: equ 18  
0069			KEY_F4: equ 19  
0069			  
0069			KEY_F5: equ 20  
0069			KEY_F6: equ 21  
0069			KEY_F7: equ 22  
0069			KEY_F8: equ 23  
0069			  
0069			KEY_F9: equ 24  
0069			KEY_F10: equ 25  
0069			KEY_F11: equ 26  
0069			KEY_F12: equ 27  
0069			  
0069			;if DEBUG_KEY  
0069			;	KEY_MATRIX_NO_PRESS: equ '.'  
0069			;	KEY_SHIFT:   equ '.'  
0069			;	KEY_SYMBOLSHIFT:  equ '.'  
0069			;else  
0069				KEY_SHIFT:   equ '~'  
0069				KEY_SYMBOLSHIFT:  equ '~'  
0069				KEY_MATRIX_NO_PRESS: equ '~'  
0069			;endi  
0069			  
0069			  
0069			  
0069			  
0069			; Macro to make adding debug marks easier  
0069			  
0069			DMARK: macro str  
0069				push af  
0069				ld a, (.dmark)  
0069				ld (debug_mark),a  
0069				ld a, (.dmark+1)  
0069				ld (debug_mark+1),a  
0069				ld a, (.dmark+2)  
0069				ld (debug_mark+2),a  
0069				jr .pastdmark  
0069			.dmark: db str  
0069			.pastdmark: pop af  
0069			  
0069			endm  
0069			  
0069			  
0069			; macro to detect for stack imbalances  
0069			  
0069			include "stackimbal.asm"  
0069			; Macro and code to detect stock imbalances 
0069			 
0069			SPPUSH: equ 0 
0069			 
0069			; Add a stack frame which can be checked before return 
0069			 
0069			STACKFRAME: macro onoff frame1 frame2 
0069			 
0069				if DEBUG_STACK_IMB 
0069					if onoff 
0069						; save current SP 
0069						exx 
0069			 
0069						ld de, frame1 
0069						ld a, d 
0069						ld hl, curframe 
0069						call hexout 
0069						ld a, e 
0069						ld hl, curframe+2 
0069						call hexout 
0069			  
0069						ld hl, frame1 
0069						push hl 
0069						ld hl, frame2 
0069						push hl 
0069						exx 
0069					endif 
0069					 
0069				endif 
0069			endm 
0069			 
0069			STACKFRAMECHK: macro onoff frame1 frame2 
0069			 
0069					 
0069				if DEBUG_STACK_IMB 
0069					if onoff 
0069						exx 
0069						; check stack frame SP 
0069			 
0069						ld hl, frame2 
0069						pop de   ; frame2 
0069			 
0069						call cmp16 
0069						jr nz, .spnosame 
0069						 
0069			 
0069						ld hl, frame1 
0069						pop de   ; frame1 
0069			 
0069						call cmp16 
0069						jr z, .spfrsame 
0069			 
0069						.spnosame: call showsperror 
0069			 
0069						.spfrsame: nop 
0069			 
0069						exx 
0069					endif 
0069					 
0069				endif 
0069			 
0069			 
0069			endm 
0069			 
0069			 
0069			; for a sub routine, wrap SP collection and comparisons 
0069			 
0069			; Usage: 
0069			; 
0069			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
0069			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
0069			 
0069			SAVESP: macro onoff storeword 
0069			 
0069				if DEBUG_STACK_IMB 
0069					if onoff 
0069						; save current SP 
0069			 
0069						ld (store_sp+(storeword*4)), sp 
0069			 
0069					endif 
0069					 
0069				endif 
0069			 
0069			endm 
0069			 
0069			CHECKSP: macro onoff storeword 
0069			 
0069				if DEBUG_STACK_IMB 
0069					if onoff 
0069			 
0069						; save SP after last save 
0069				 
0069						ld (store_sp+(storeword*4)+2), sp 
0069			 
0069						push hl 
0069						ld hl, store_sp+(storeword*4) 
0069						call check_stack_sp  
0069						pop hl 
0069			 
0069			 
0069					endif 
0069					 
0069				endif 
0069			 
0069			endm 
0069			 
0069			if DEBUG_STACK_IMB 
0069			 
0069			check_stack_sp: 
0069					push de 
0069			 
0069					ld e, (hl) 
0069					inc hl 
0069					ld d, (hl) 
0069					inc hl 
0069			 
0069					push de 
0069			 
0069			 
0069					ld e, (hl) 
0069					inc hl 
0069					ld d, (hl) 
0069					inc hl 
0069			 
0069					pop hl 
0069			 
0069			 
0069					; check to see if the same 
0069			 
0069					call cmp16 
0069					jr z, .spsame 
0069			 
0069					; not same 
0069			 
0069					call showsperror 
0069			.spsame: 
0069			 
0069					pop de 
0069			 
0069					ret 
0069			 
0069			.sperr:  db "Stack imbalance",0 
0069			 
0069			 
0069			showsperror: 
0069			 
0069			 
0069				push hl 
0069				push af 
0069				push de 
0069				call clear_display 
0069				ld de, .sperr 
0069				ld a,0 
0069			;	ld de,os_word_scratch 
0069				call str_at_display 
0069				ld a, display_row_1+17 
0069				ld de, debug_mark 
0069				call str_at_display 
0069				ld a, 0 
0069				ld (curframe+4),a 
0069				ld hl, curframe 
0069				ld de, os_word_scratch 
0069				ld a, display_row_4 
0069				call str_at_display 
0069				call update_display 
0069				;call break_point_state 
0069				call cin_wait 
0069			 
0069			;	ld a, ' ' 
0069			;	ld (os_view_disable), a 
0069				call bp_on 
0069				pop de	 
0069				pop af 
0069				pop hl 
0069				CALLMONITOR 
0069				ret 
0069			 
0069			endif 
0069			 
0069			 
0069			 
0069			; eof 
# End of file stackimbal.asm
0069			  
0069			;TODO macro to calc col and row offset into screen  
0069			  
0069			  
0069			  
0069			hardware_init:  
0069			  
0069				  
0069			  
0069					;ld a, 0  
0069					;ld (hardware_diag), a  
0069			  
0069					; clear all the buffers  
0069			  
0069 21 0d fd				ld hl, display_fb1  
006c 22 c9 fb				ld (display_fb_active), hl  
006f			  
006f cd 9c 0d				call clear_display  
0072			  
0072 21 cb fb				ld hl, display_fb2  
0075 22 c9 fb				ld (display_fb_active), hl  
0078			  
0078 cd 9c 0d				call clear_display  
007b			  
007b					; init primary frame buffer area  
007b 21 ae fd				ld hl, display_fb0  
007e 22 c9 fb				ld (display_fb_active), hl  
0081			  
0081 cd 9c 0d				call clear_display  
0084			  
0084			  
0084 cd 5c 76				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0087			  
0087 cd f3 78			call key_init  
008a cd 48 02			call storage_init  
008d			  
008d				; setup malloc functions  
008d			  
008d				if MALLOC_1  
008d cd 73 14				call  heap_init  
0090				endif  
0090				if MALLOC_4  
0090					call  heap_init  
0090				endif  
0090			  
0090				; init sound hardware if present  
0090			  
0090				if SOUND_ENABLE  
0090					call sound_init  
0090				endif  
0090			  
0090				; lcd test sequence  
0090					  
0090 cd bf 0d			call update_display  
0093 cd df 0c			call delay1s  
0096 3e 2b			ld a,'+'  
0098 cd a1 0d			call fill_display  
009b cd bf 0d			call update_display  
009e cd df 0c			call delay1s  
00a1 3e 2a			ld a,'*'  
00a3 cd a1 0d			call fill_display  
00a6 cd bf 0d			call update_display  
00a9 cd df 0c			call delay1s  
00ac 3e 2d			ld a,'-'  
00ae cd a1 0d			call fill_display  
00b1 cd bf 0d			call update_display  
00b4 cd df 0c			call delay1s  
00b7			  
00b7			; boot splash screen  
00b7			if display_cols == 20	  
00b7			        ld a, display_row_1    
00b7			else  
00b7 3e 0a		        ld a, display_row_1 +10   
00b9			endif  
00b9 11 11 1c			ld de, prom_bootmsg  
00bc cd af 0d			call str_at_display  
00bf cd bf 0d			call update_display  
00c2			  
00c2			  
00c2 cd df 0c			call delay1s  
00c5 cd df 0c			call delay1s  
00c8			if display_cols == 20	  
00c8			            LD   A, display_row_3+2  
00c8			else  
00c8 3e 5c		            LD   A, display_row_3+12  
00ca			endif  
00ca 11 26 1c			ld de, prom_bootmsg1  
00cd cd af 0d			call str_at_display  
00d0 cd bf 0d			call update_display  
00d3 cd df 0c			call delay1s  
00d6 cd df 0c			call delay1s  
00d9			  
00d9			;	ld a, display_row_4+3  
00d9			;	ld de, bootmsg2  
00d9			;	call str_at_display  
00d9			;	call update_display  
00d9			;	call delay1s  
00d9			;	call delay1s  
00d9			  
00d9			; debug mark setup  
00d9			  
00d9 3e 5f		ld a, '_'  
00db 32 68 fe		ld (debug_mark),a  
00de 32 69 fe		ld (debug_mark+1),a  
00e1 32 6a fe		ld (debug_mark+2),a  
00e4 3e 00		ld a,0  
00e6 32 6b fe		ld (debug_mark+3),a  
00e9			  
00e9 c9					ret  
00ea			  
00ea			  
00ea			;bootmsg2:	db "Firmware v0.1",0  
00ea			  
00ea			; a 4x20 lcd  
00ea			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00ea			  
00ea			;if display_cols == 20  
00ea			;	include "firmware_lcd_4x20.asm"  
00ea			;endif  
00ea			  
00ea			;if display_cols == 40  
00ea			;	include "firmware_lcd_4x40.asm"  
00ea			;endif  
00ea			  
00ea			;  
00ea			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00ea			; TODO abstract the bit bang video out interface for dual display  
00ea			; TODO wire video out to tx pin on rc2014 bus  
00ea			  
00ea			; must supply cin, and cin_wait for low level hardware abstraction   
00ea			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00ea			; test scancode  
00ea			  
00ea			;;;;;  
00ea			;;;  
00ea			; Moved out to mini and maxi versions  
00ea			;  
00ea			; include "firmware_key_4x4.asm"  
00ea			; using existing 4 wire x 4 resistor array for input  
00ea			;include "firmware_key_4x10.asm"  
00ea			; need to mod the board for 5 rows due to resistor array  
00ea			;include "firmware_key_5x10.asm"  
00ea			  
00ea			; storage hardware interface  
00ea			  
00ea			; use microchip serial eeprom for storage  
00ea			  
00ea			  
00ea			if STORAGE_SE  
00ea				include "firmware_spi.asm"  
00ea			; my spi protocol (used by storage) 
00ea			 
00ea			; SPI pins 
00ea			 
00ea			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00ea			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00ea			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00ea			 
00ea			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00ea			; chip pin 4 gnd 
00ea			 
00ea			 
00ea			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00ea			SPI_CE1: equ 1      ;    port a1 pin 14  
00ea			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00ea			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00ea			SPI_CE4: equ 4      ; port a4     pin 10 
00ea			 
00ea			; active low AND masks 
00ea			 
00ea			;SPI_CE0_MASK: equ    255-1 
00ea			;SPI_CE1_MASK: equ   255-2 
00ea			;SPI_CE2_MASK: equ   255-4 
00ea			;SPI_CE3_MASK: equ   255-8 
00ea			;SPI_CE4_MASK: equ   255-16 
00ea			SPI_CE_HIGH:  equ 255 
00ea			 
00ea			 
00ea			 
00ea			;  Perform SCLK wait pulse 
00ea			 
00ea			spi_clk: 
00ea f5				push af 
00eb 3a 61 fa			ld a, (spi_clktime) 
00ee fe 00			cp 0 
00f0 28 03			jr z, .scskip 
00f2 cd c4 0c			call aDelayInMS 
00f5			.scskip: 
00f5 f1				pop af 
00f6 c9				ret 
00f7			 
00f7			 
00f7			 
00f7			; TODO store port id for spi device ie dev c 
00f7			; TODO store pin for SO 
00f7			; TODO store pin for SI 
00f7			; TODO store pin for SCLK 
00f7			 
00f7			; 
00f7			 
00f7			; ensure that spi bus is in a stable state with default pins  
00f7			 
00f7			se_stable_spi:   
00f7			 
00f7				 ; set DI high, CE high , SCLK low 
00f7				;ld a, SPI_DI | SPI_CE0 
00f7 3e 07			ld a, SPI_DI  
00f9 cd 03 02			call spi_ce_high 
00fc d3 80			 out (storage_adata),a 
00fe 32 5e fa			ld (spi_portbyte),a 
0101			 
0101				if DEBUG_SPI 
0101					push hl 
0101					ld l, a 
0101					DMARK "SPI" 
0101					CALLMONITOR 
0101					pop hl 
0101				endif 
0101 c9				ret 
0102			 
0102			; byte to send in a 
0102			 
0102			spi_send_byte: 
0102				; save byte to send for bit mask shift out 
0102 4f			        ld c,a 
0103 3a 5e fa			ld a,(spi_portbyte) 
0106				  
0106				; clock out	each bit of the byte msb first 
0106			 
0106 06 08			ld b, 8 
0108			.ssb1: 
0108				; clear so bit  
0108 cb bf			res SPI_DI, a 
010a cb 11			rl c 
010c				; if bit 7 is set then carry is set 
010c 30 02			jr nc, .ssb2 
010e cb ff			set SPI_DI,a 
0110			.ssb2:  ; output bit to ensure it is stable 
0110 d3 80			out (storage_adata),a 
0112 00				nop 
0113				; clock bit high 
0113 cb ef			set SPI_SCLK,a 
0115 d3 80			out (storage_adata),a 
0117 00				nop 
0118 cd ea 00			call spi_clk 
011b				; then low 
011b cb af			res SPI_SCLK,a 
011d d3 80			out (storage_adata),a 
011f 00				nop 
0120 cd ea 00			call spi_clk 
0123 10 e3			djnz .ssb1 
0125			 
0125 32 5e fa			ld (spi_portbyte),a 
0128 c9				ret 
0129			 
0129			; TODO low level get byte into A on spi 
0129			 
0129			spi_read_byte:  
0129			 
0129				; save byte to send for bit mask shift out 
0129 0e 00		    ld c,0 
012b 3a 5e fa			ld a,(spi_portbyte) 
012e				  
012e				; clock out	each bit of the byte msb first 
012e			 
012e			 
012e				; clock bit high 
012e cb ef			set SPI_SCLK,a 
0130 d3 80			out (storage_adata),a 
0132 00				nop 
0133 cd ea 00			call spi_clk 
0136			 
0136			    ; read DO  
0136			 
0136 cb f9		    set 7,c 
0138 db 80			in a,(storage_adata) 
013a cb 77		    bit SPI_DO,a 
013c 20 02		    jr nz, .b7 
013e cb b9		    res 7,c 
0140			.b7: 
0140				; then low 
0140 cb af			res SPI_SCLK,a 
0142 d3 80			out (storage_adata),a 
0144 00				nop 
0145 cd ea 00			call spi_clk 
0148			     
0148			 
0148				; clock bit high 
0148 cb ef			set SPI_SCLK,a 
014a d3 80			out (storage_adata),a 
014c 00				nop 
014d cd ea 00			call spi_clk 
0150			 
0150			    ; read DO  
0150			 
0150 cb f1		    set 6,c 
0152 db 80			in a,(storage_adata) 
0154 cb 77		    bit SPI_DO,a 
0156 20 02		    jr nz, .b6 
0158 cb b1		    res 6,c 
015a			.b6: 
015a				; then low 
015a cb af			res SPI_SCLK,a 
015c d3 80			out (storage_adata),a 
015e 00				nop 
015f cd ea 00			call spi_clk 
0162			 
0162				; clock bit high 
0162 cb ef			set SPI_SCLK,a 
0164 d3 80			out (storage_adata),a 
0166 00				nop 
0167 cd ea 00			call spi_clk 
016a			 
016a			 
016a			    ; read DO  
016a			 
016a cb e9		    set 5,c 
016c db 80			in a,(storage_adata) 
016e cb 77		    bit SPI_DO,a 
0170 20 02		    jr nz, .b5 
0172 cb a9		    res 5,c 
0174			.b5: 
0174				; then low 
0174 cb af			res SPI_SCLK,a 
0176 d3 80			out (storage_adata),a 
0178 00				nop 
0179 cd ea 00			call spi_clk 
017c				; clock bit high 
017c cb ef			set SPI_SCLK,a 
017e d3 80			out (storage_adata),a 
0180 00				nop 
0181 cd ea 00			call spi_clk 
0184			 
0184			    ; read DO  
0184			 
0184 cb e1		    set 4,c 
0186 db 80			in a,(storage_adata) 
0188 cb 77		    bit SPI_DO,a 
018a 20 02		    jr nz, .b4 
018c cb a1		    res 4,c 
018e			.b4: 
018e				; then low 
018e cb af			res SPI_SCLK,a 
0190 d3 80			out (storage_adata),a 
0192 00				nop 
0193 cd ea 00			call spi_clk 
0196				; clock bit high 
0196 cb ef			set SPI_SCLK,a 
0198 d3 80			out (storage_adata),a 
019a 00				nop 
019b cd ea 00			call spi_clk 
019e			 
019e			    ; read DO  
019e			 
019e cb d9		    set 3,c 
01a0 db 80			in a,(storage_adata) 
01a2 cb 77		    bit SPI_DO,a 
01a4 20 02		    jr nz, .b3 
01a6 cb 99		    res 3,c 
01a8			.b3: 
01a8				; then low 
01a8 cb af			res SPI_SCLK,a 
01aa d3 80			out (storage_adata),a 
01ac 00				nop 
01ad cd ea 00			call spi_clk 
01b0				; clock bit high 
01b0 cb ef			set SPI_SCLK,a 
01b2 d3 80			out (storage_adata),a 
01b4 00				nop 
01b5 cd ea 00			call spi_clk 
01b8			 
01b8			    ; read DO  
01b8			 
01b8 cb d1		    set 2,c 
01ba db 80			in a,(storage_adata) 
01bc cb 77		    bit SPI_DO,a 
01be 20 02		    jr nz, .b2 
01c0 cb 91		    res 2,c 
01c2			.b2: 
01c2				; then low 
01c2 cb af			res SPI_SCLK,a 
01c4 d3 80			out (storage_adata),a 
01c6 00				nop 
01c7 cd ea 00			call spi_clk 
01ca				; clock bit high 
01ca cb ef			set SPI_SCLK,a 
01cc d3 80			out (storage_adata),a 
01ce 00				nop 
01cf cd ea 00			call spi_clk 
01d2			 
01d2			    ; read DO  
01d2			 
01d2 cb c9		    set 1,c 
01d4 db 80			in a,(storage_adata) 
01d6 cb 77		    bit SPI_DO,a 
01d8 20 02		    jr nz, .b1 
01da cb 89		    res 1,c 
01dc			.b1: 
01dc				; then low 
01dc cb af			res SPI_SCLK,a 
01de d3 80			out (storage_adata),a 
01e0 00				nop 
01e1 cd ea 00			call spi_clk 
01e4				; clock bit high 
01e4 cb ef			set SPI_SCLK,a 
01e6 d3 80			out (storage_adata),a 
01e8 00				nop 
01e9 cd ea 00			call spi_clk 
01ec			 
01ec			    ; read DO  
01ec			 
01ec cb c1		    set 0,c 
01ee db 80			in a,(storage_adata) 
01f0 cb 77		    bit SPI_DO,a 
01f2 20 02		    jr nz, .b0 
01f4 cb 81		    res 0,c 
01f6			.b0: 
01f6				; then low 
01f6 cb af			res SPI_SCLK,a 
01f8 d3 80			out (storage_adata),a 
01fa 00				nop 
01fb cd ea 00			call spi_clk 
01fe			 
01fe			 
01fe 32 5e fa			ld (spi_portbyte),a 
0201			 
0201			    ; return byte 
0201 79			    ld a,c 
0202			 
0202			 
0202 c9				ret 
0203			 
0203			 
0203			 
0203			spi_ce_high: 
0203			 
0203				if DEBUG_SPI_HARD_CE0 
0203			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0203					ret 
0203			 
0203				endif 
0203			 
0203			 
0203 f5				push af 
0204			 
0204				; send direct ce to port b 
0204 3e ff			ld a, 255 
0206 d3 81			out (storage_bdata), a 
0208			 
0208 f1				pop af 
0209			 
0209				; for port a that shares with spi lines AND the mask 
0209			  
0209				if DEBUG_SPI 
0209					push hl 
0209					ld h, a 
0209				endif 
0209			;	ld c, SPI_CE_HIGH 
0209			;	and c 
0209 cb c7			set SPI_CE0, a 
020b cb cf			set SPI_CE1, a 
020d cb d7			set SPI_CE2, a 
020f cb df			set SPI_CE3, a 
0211 cb e7			set SPI_CE4, a 
0213			 
0213				if DEBUG_SPI 
0213					ld l, a 
0213					DMARK "CEh" 
0213					CALLMONITOR 
0213					pop hl 
0213				endif 
0213 c9				ret 
0214			 
0214			 
0214			spi_ce_low: 
0214			 
0214				if DEBUG_SPI_HARD_CE0 
0214			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0214					ret 
0214			 
0214				endif 
0214			 
0214 c5				push bc 
0215 f5				push af 
0216			 
0216				; send direct ce to port b 
0216 3a 60 fa			ld a, (spi_cartdev) 
0219 d3 81			out (storage_bdata), a 
021b			 
021b			 
021b			 
021b				; for port a that shares with spi lines AND the mask 
021b			 
021b 3a 5d fa			ld a, (spi_device)  
021e 4f				ld c, a 
021f			 
021f f1				pop af 
0220			 
0220				; detect CEx 
0220			 
0220				if DEBUG_SPI 
0220					push hl 
0220					ld h, a 
0220				endif 
0220			 
0220 cb 41			bit SPI_CE0, c 
0222 20 04			jr nz, .cel1 
0224 cb 87			res SPI_CE0, a 
0226 18 1e			jr .celn 
0228			.cel1: 
0228 cb 49			bit SPI_CE1, c 
022a 20 04			jr nz, .cel2 
022c cb 8f			res SPI_CE1, a 
022e 18 16			jr .celn 
0230			.cel2: 
0230 cb 51			bit SPI_CE2, c 
0232 20 04			jr nz, .cel3 
0234 cb 97			res SPI_CE2, a 
0236 18 0e			jr .celn 
0238			.cel3: 
0238 cb 59			bit SPI_CE3, c 
023a 20 04			jr nz, .cel4 
023c cb 9f			res SPI_CE3, a 
023e 18 06			jr .celn 
0240			.cel4: 
0240 cb 61			bit SPI_CE4, c 
0242 20 02			jr nz, .celn 
0244 cb a7			res SPI_CE4, a 
0246			.celn: 
0246			 
0246			 
0246			 
0246			;	add c 
0246			 
0246				if DEBUG_SPI 
0246					ld l, a 
0246					DMARK "CEl" 
0246					CALLMONITOR 
0246					pop hl 
0246				endif 
0246 c1				pop bc 
0247 c9				ret 
0248			 
0248			 
0248			 
0248			; eof 
0248			 
0248			 
0248			 
0248			 
0248			 
# End of file firmware_spi.asm
0248				include "firmware_seeprom.asm"  
0248			; 
0248			; persisent storage interface via microchip serial eeprom 
0248			 
0248			; port a pio 2 
0248			; pa 7 - si 
0248			; pa 6 - sclk  
0248			; pa 5 - so 
0248			; pa 4 - cs 
0248			; pa 3 - cs 
0248			; pa 2 - cs 
0248			; pa 1 - cs 
0248			; pa 0 - cs 
0248			; 
0248			; TODO get block 
0248			; TODO save block 
0248			; TODO load file 
0248			; TODO save file 
0248			; TODO get dir  
0248			 
0248			;  
0248			storage_adata: equ Device_C    ; device c port a - onboard storage 
0248			storage_actl: equ Device_C+2     ; device c port a 
0248			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
0248			storage_bctl: equ Device_C+3     ; device c port b 
0248			 
0248			 
0248			; TODO move these to hardware driver file 
0248			 
0248			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
0248			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
0248			; storage bank file system format 
0248			; 
0248			; first page of bank: 
0248			; 	addr 0 - status check 
0248			;       addr 1 - write protect flag 
0248			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
0248			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
0248			;         TODO see if scanning whole of for available next file id is fast enough 
0248			;	addr 4 > zero term string of bank label 
0248			; 
0248			;        
0248			;  
0248			; first page of any file: 
0248			;      byte 0 - file id  
0248			;      byte 1-17 - fixed file name  
0248			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
0248			; 
0248			; other pages of any file: 
0248			;      byte 0 - file id 
0248			;      byte 1> - file data 
0248			; 
0248			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
0248			;  
0248			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
0248			 
0248			 
0248			;storage_so_bit: 5 
0248			;storage_si_bit: 7 
0248			;storage_sclk_bit: 6 
0248			  
0248			 
0248			; init storage pio 
0248			 
0248			storage_init: 
0248			 
0248			 
0248					; set default SPI clk pulse time as disabled 
0248			 
0248 3e 00				ld a, 0 
024a 32 61 fa				ld (spi_clktime), a 
024d			 
024d					; init hardware 
024d			 
024d 3e cf		            LD   A, 11001111b 
024f d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
0251 3e 00		            LD   A, 00000000b 
0253 cb f7			set SPI_DO,a 
0255			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
0255 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
0257			 
0257 3e cf		            LD   A, 11001111b 
0259 d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
025b 3e 00		            LD   A, 00000000b 
025d d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
025f			 
025f				; set all external spi devices off  
025f 3e ff			ld a, 255 
0261 32 5d fa			ld (spi_device), a 
0264 32 60 fa			ld (spi_cartdev), a 
0267			 
0267					; ensure the spi bus is in a default stable state 
0267 cd f7 00				call se_stable_spi 
026a			 
026a			; TODO scan spi bus and gather which storage banks are present 
026a			 
026a			; populate store_bank_active  
026a			; for each ce line activate and attempt to write first byte of bank and read back 
026a			; if zero is returned then bank is empty 
026a			;   
026a			; 
026a			 
026a					; init file extent cache to save on slow reads 
026a			 
026a			;	ld hl, store_filecache 
026a			;	ld de, 0 
026a			;	ld hl,(de)	 
026a			 
026a			 
026a c9			    ret 
026b			 
026b			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
026b			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
026b			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
026b			 
026b			; INSTRUCTION SET 
026b			; READ 0000 0011 Read data from memory array beginning at selected address 
026b			; WRITE 0000 0010 Write data to memory array beginning at selected address 
026b			; WREN 0000 0110 Set the write enable latch (enable write operations) 
026b			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
026b			; RDSR 0000 0101 Read STATUS register 
026b			; WRSR 0000 0001 Write STATUS register 
026b			; PE 0100 0010 Page Erase – erase one page in memory array 
026b			; SE 1101 1000 Sector Erase – erase one sector in memory array 
026b			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
026b			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
026b			 
026b			; TODO send byte steam for page without setting the address for every single byte 
026b			; TODO read byte  
026b			 
026b			; byte in a 
026b			; address in hl  
026b			se_writebyte: 
026b			        
026b			    ;   ld c, a 
026b f5			        push af 
026c e5			        push hl 
026d			 
026d			    ; initi write mode 
026d			    ; 
026d			    ;CS low 
026d			 
026d 3a 5e fa		       ld a,(spi_portbyte) 
0270 cd 14 02			call spi_ce_low 
0273			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0273 d3 80		       out (storage_adata),a 
0275 32 5e fa		       ld (spi_portbyte), a 
0278			 
0278			    ;clock out wren instruction 
0278			 
0278 3e 06		    ld a, store_wren_ins 
027a cd 02 01		    call spi_send_byte  
027d			 
027d			    ;cs high to enable write latch 
027d			 
027d 3a 5e fa		       ld a,(spi_portbyte) 
0280 cd 03 02			call spi_ce_high 
0283			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0283 d3 80		       out (storage_adata),a 
0285 32 5e fa		       ld (spi_portbyte), a 
0288			 
0288 00				nop 
0289			    ; 
0289			    ; intial write data 
0289			    ; 
0289			    ; cs low 
0289			     
0289 3a 5e fa		       ld a,(spi_portbyte) 
028c cd 14 02			call spi_ce_low 
028f			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
028f d3 80		       out (storage_adata),a 
0291 32 5e fa		       ld (spi_portbyte), a 
0294			 
0294			    ; clock out write instruction 
0294			     
0294 3e 02		    ld a, store_write_ins  
0296 cd 02 01		    call spi_send_byte  
0299			 
0299			    ; clock out address (depending on address size) 
0299			     
0299 e1			    pop hl 
029a 7c			    ld a,h    ; address out msb first 
029b cd 02 01		    call spi_send_byte  
029e 7d			    ld a,l 
029f cd 02 01		    call spi_send_byte  
02a2			 
02a2			    ; clock out byte(s) for page 
02a2			 
02a2 f1			    pop af 
02a3 cd 02 01		    call spi_send_byte  
02a6			 
02a6			    ; end write with ce high 
02a6 3a 5e fa		       ld a,(spi_portbyte) 
02a9			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02a9 cd 03 02			call spi_ce_high 
02ac d3 80		       out (storage_adata),a 
02ae 32 5e fa		       ld (spi_portbyte), a 
02b1			 
02b1				; pause for internal write cycle 
02b1 3e 0a			ld a, 10 
02b3 cd c4 0c			call aDelayInMS 
02b6 c9			    ret 
02b7			 
02b7			; buffer to write in de 
02b7			; address in hl  
02b7			se_writepage: 
02b7			        
02b7			    ;   ld c, a 
02b7 d5				push de 
02b8 e5			        push hl 
02b9			 
02b9			    ; initi write mode 
02b9			    ; 
02b9			    ;CS low 
02b9			 
02b9 3a 5e fa		       ld a,(spi_portbyte) 
02bc cd 14 02			call spi_ce_low 
02bf			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02bf d3 80		       out (storage_adata),a 
02c1 32 5e fa		       ld (spi_portbyte), a 
02c4			 
02c4			    ;clock out wren instruction 
02c4			 
02c4 3e 06		    ld a, store_wren_ins 
02c6 cd 02 01		    call spi_send_byte  
02c9			 
02c9			    ;cs high to enable write latch 
02c9			 
02c9 3a 5e fa		       ld a,(spi_portbyte) 
02cc cd 03 02			call spi_ce_high 
02cf			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
02cf d3 80		       out (storage_adata),a 
02d1 32 5e fa		       ld (spi_portbyte), a 
02d4			 
02d4 00				nop 
02d5			    ; 
02d5			    ; intial write data 
02d5			    ; 
02d5			    ; cs low 
02d5			     
02d5 3a 5e fa		       ld a,(spi_portbyte) 
02d8			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02d8 cd 14 02			call spi_ce_low 
02db d3 80		       out (storage_adata),a 
02dd 32 5e fa		       ld (spi_portbyte), a 
02e0			 
02e0			    ; clock out write instruction 
02e0			     
02e0 3e 02		    ld a, store_write_ins  
02e2 cd 02 01		    call spi_send_byte  
02e5			 
02e5			    ; clock out address (depending on address size) 
02e5			     
02e5 e1			    pop hl 
02e6 7c			    ld a,h    ; address out msb first 
02e7 cd 02 01		    call spi_send_byte  
02ea 7d			    ld a,l 
02eb cd 02 01		    call spi_send_byte  
02ee			 
02ee			    ; clock out byte(s) for page 
02ee			 
02ee e1				pop hl 
02ef 06 40			ld b, STORE_BLOCK_PHY 
02f1			.bytewrite: 
02f1			 
02f1 7e				ld a,(hl) 
02f2 e5			    push hl 
02f3 c5				push bc 
02f4 cd 02 01		    call spi_send_byte  
02f7 c1				pop bc 
02f8 e1				pop hl 
02f9			 
02f9			    ; end write with ce high 
02f9 3a 5e fa		       ld a,(spi_portbyte) 
02fc cd 03 02			call spi_ce_high 
02ff			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02ff d3 80		       out (storage_adata),a 
0301 32 5e fa		       ld (spi_portbyte), a 
0304			 
0304 23				inc hl 
0305 10 ea			djnz .bytewrite 
0307			 
0307				; pause for internal write cycle 
0307 3e 64			ld a, 100 
0309 cd c4 0c			call aDelayInMS 
030c c9			    ret 
030d			; returns byte in a 
030d			; address in hl  
030d			se_readbyte: 
030d d5				push de 
030e c5				push bc 
030f			 
030f			    ;   ld c, a 
030f e5			        push hl 
0310			 
0310			    ; initi write mode 
0310			    ; 
0310			    ;CS low 
0310			 
0310 3a 5e fa		       ld a,(spi_portbyte) 
0313 cd 14 02			call spi_ce_low 
0316			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0316 d3 80		       out (storage_adata),a 
0318 32 5e fa		       ld (spi_portbyte), a 
031b			 
031b			    ;clock out wren instruction 
031b			 
031b 3e 03		    ld a, store_read_ins 
031d cd 02 01		    call spi_send_byte  
0320			 
0320			 
0320			    ; clock out address (depending on address size) 
0320			     
0320 e1			    pop hl 
0321 7c			    ld a,h    ; address out msb first 
0322 cd 02 01		    call spi_send_byte  
0325 7d			    ld a,l 
0326 cd 02 01		    call spi_send_byte  
0329			 
0329			    ; clock in byte(s) for page 
0329			 
0329 cd 29 01		    call spi_read_byte  
032c f5				push af 
032d			 
032d			    ; end write with ce high 
032d 3a 5e fa		       ld a,(spi_portbyte) 
0330			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
0330 cd 03 02			call spi_ce_high 
0333 d3 80		       out (storage_adata),a 
0335 32 5e fa		       ld (spi_portbyte), a 
0338			 
0338 f1				pop af 
0339			 
0339 c1				pop bc 
033a d1				pop de 
033b			 
033b c9			    ret 
033c			 
033c			if DEBUG_STORESE 
033c			 
033c			storageput:  
033c			 
033c			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
033c			 
033c 21 c0 f1			ld hl,scratch+2 
033f cd 87 13			call get_word_hl 
0342			 
0342				; stuff it here for the moment as it will be overwritten later anyway 
0342			 
0342 22 e1 f4			ld (os_cur_ptr),hl	 
0345			 
0345			 
0345			; get pointer to start of string 
0345			 
0345 21 c5 f1			ld hl, scratch+7 
0348			 
0348			; loop writing char of string to eeprom 
0348			 
0348 7e			.writestr:	ld a,(hl) 
0349 fe 00				cp 0 
034b 28 12				jr z, .wsdone		; done writing 
034d e5					push hl 
034e 2a e1 f4				ld hl,(os_cur_ptr) 
0351 cd 6b 02				call se_writebyte 
0354			 
0354 2a e1 f4				ld hl,(os_cur_ptr)	 ; save next eeprom address 
0357 23					inc hl 
0358 22 e1 f4				ld (os_cur_ptr),hl 
035b			 
035b					; restore string pointer and get next char 
035b			 
035b e1					pop hl 
035c 23					inc hl 
035d 18 e9				jr .writestr 
035f			 
035f			 
035f			 
035f			.wsdone: 
035f			 
035f			 
035f			; when done load first page into a buffer  
035f			 
035f 21 00 80				ld hl,08000h		; start in ram 
0362 22 e1 f4				ld (os_cur_ptr),hl 
0365 21 00 00				ld hl, 0		 ; start of page 
0368 22 e6 f1				ld (scratch+40),hl	; hang on to it 
036b			 
036b 06 80				ld b, 128		; actually get more then one page 
036d c5			.wsload:	push bc 
036e 2a e6 f1				ld hl,(scratch+40) 
0371 e5					push hl 
0372 cd 0d 03				call se_readbyte 
0375			 
0375					; a now as the byte 
0375			 
0375 2a e1 f4				ld hl,(os_cur_ptr) 
0378 77					ld (hl),a 
0379					; inc next buffer area 
0379 23					inc hl 
037a 22 e1 f4				ld (os_cur_ptr),hl 
037d			 
037d					; get eeprom position, inc and save for next round 
037d e1					pop hl		 
037e 23					inc hl 
037f 22 e6 f1				ld (scratch+40),hl 
0382 c1					pop bc 
0383 10 e8				djnz .wsload 
0385			 
0385			; set 'd' pointer to start of buffer 
0385			 
0385 21 00 80				ld hl,08000h 
0388 22 e1 f4				ld (os_cur_ptr),hl 
038b			 
038b			 
038b c9			ret 
038c			 
038c			 
038c c9			storageread: ret 
038d			 
038d			 
038d			 
038d			 
038d			 
038d			 
038d			endif 
038d			 
038d			 
038d			 
# End of file firmware_seeprom.asm
038d			else  
038d			   ; create some stubs for the labels  
038d			se_readbyte: ret  
038d			se_writebyte: ret  
038d			storage_init: ret  
038d			  
038d			endif  
038d			  
038d			; use cf card for storage - throwing timeout errors. Hardware or software?????  
038d			;include "firmware_cf.asm"  
038d			  
038d			; load up high level storage hardward abstractions  
038d			include "firmware_storage.asm"  
038d			 
038d			; persisent storage hardware abstraction layer  
038d			 
038d			 
038d			 
038d			; Block 0 on storage is a config state 
038d			 
038d			 
038d			 
038d			; TODO add read phy block and write phy block functions 
038d			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
038d			 
038d			; Abstraction layer  
038d			 
038d			; Logocial block size is same size as physical size - using tape concept 
038d			 
038d			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
038d			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
038d			 
038d			 
038d			 
038d			; Filesystem layout (Logical layout) 
038d			; 
038d			; Block 0 - Bank config  
038d			; 
038d			;      Byte - 0 file id counter 
038d			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
038d			;      Byte - 3-20 zero terminated bank label 
038d			; 
038d			; Block 1 > File storage 
038d			; 
038d			;      Byte 0 file id    - block 0 file details 
038d			;      Byte 1 block id - block 0 is file  
038d			;            Byte 2-15 - File name 
038d			; 
038d			;       - to end of block data 
038d			; 
038d			 
038d			; Get ID for the file named in pointer held HL 
038d			; Returns ID in HL = 255 if no file found 
038d			 
038d			storage_getid: 
038d			 
038d 22 70 fa			ld (store_tmp1), hl 
0390			 
0390				if DEBUG_STORESE 
0390					DMARK "SGI" 
0390 f5				push af  
0391 3a a5 03			ld a, (.dmark)  
0394 32 68 fe			ld (debug_mark),a  
0397 3a a6 03			ld a, (.dmark+1)  
039a 32 69 fe			ld (debug_mark+1),a  
039d 3a a7 03			ld a, (.dmark+2)  
03a0 32 6a fe			ld (debug_mark+2),a  
03a3 18 03			jr .pastdmark  
03a5 ..			.dmark: db "SGI"  
03a8 f1			.pastdmark: pop af  
03a9			endm  
# End of macro DMARK
03a9					CALLMONITOR 
03a9 cd 6c fe			call debug_vector  
03ac				endm  
# End of macro CALLMONITOR
03ac				endif 
03ac				; get block 0 and set counter for number of files to scan 
03ac			 
03ac cd 17 05			call storage_get_block_0 
03af			 
03af 3a 77 fa			ld a, (store_page) 
03b2 47				ld b, a 
03b3			 
03b3				; get extent 0 of each file id 
03b3			 
03b3				if DEBUG_STORESE 
03b3					DMARK "SGc" 
03b3 f5				push af  
03b4 3a c8 03			ld a, (.dmark)  
03b7 32 68 fe			ld (debug_mark),a  
03ba 3a c9 03			ld a, (.dmark+1)  
03bd 32 69 fe			ld (debug_mark+1),a  
03c0 3a ca 03			ld a, (.dmark+2)  
03c3 32 6a fe			ld (debug_mark+2),a  
03c6 18 03			jr .pastdmark  
03c8 ..			.dmark: db "SGc"  
03cb f1			.pastdmark: pop af  
03cc			endm  
# End of macro DMARK
03cc					CALLMONITOR 
03cc cd 6c fe			call debug_vector  
03cf				endm  
# End of macro CALLMONITOR
03cf				endif 
03cf 60			.getloop:	ld h, b 
03d0 2e 00				ld l, 0 
03d2 c5					push bc 
03d3			 
03d3 11 77 fa				ld de, store_page 
03d6				if DEBUG_STORESE 
03d6					DMARK "SGr" 
03d6 f5				push af  
03d7 3a eb 03			ld a, (.dmark)  
03da 32 68 fe			ld (debug_mark),a  
03dd 3a ec 03			ld a, (.dmark+1)  
03e0 32 69 fe			ld (debug_mark+1),a  
03e3 3a ed 03			ld a, (.dmark+2)  
03e6 32 6a fe			ld (debug_mark+2),a  
03e9 18 03			jr .pastdmark  
03eb ..			.dmark: db "SGr"  
03ee f1			.pastdmark: pop af  
03ef			endm  
# End of macro DMARK
03ef					CALLMONITOR 
03ef cd 6c fe			call debug_vector  
03f2				endm  
# End of macro CALLMONITOR
03f2				endif 
03f2 cd bf 09				call storage_read 
03f5 cd f9 0f				call ishlzero 
03f8 28 2d				jr z, .gap 
03fa					 
03fa					; have a file name read. Is it one we want. 
03fa			 
03fa 2a 70 fa				ld hl, (store_tmp1) 
03fd 11 7a fa				ld de, store_page+3   ; file name 
0400			 
0400				if DEBUG_STORESE 
0400					DMARK "SGc" 
0400 f5				push af  
0401 3a 15 04			ld a, (.dmark)  
0404 32 68 fe			ld (debug_mark),a  
0407 3a 16 04			ld a, (.dmark+1)  
040a 32 69 fe			ld (debug_mark+1),a  
040d 3a 17 04			ld a, (.dmark+2)  
0410 32 6a fe			ld (debug_mark+2),a  
0413 18 03			jr .pastdmark  
0415 ..			.dmark: db "SGc"  
0418 f1			.pastdmark: pop af  
0419			endm  
# End of macro DMARK
0419					CALLMONITOR 
0419 cd 6c fe			call debug_vector  
041c				endm  
# End of macro CALLMONITOR
041c				endif 
041c cd 66 14				call strcmp 
041f 20 06				jr nz, .gap   ; not this one 
0421			 
0421 c1				        pop bc 
0422			 
0422 26 00				ld h, 0 
0424 68					ld l, b 
0425 18 22				jr .getdone 
0427						 
0427			 
0427			 
0427			 
0427			.gap: 
0427				if DEBUG_STORESE 
0427					DMARK "SGg" 
0427 f5				push af  
0428 3a 3c 04			ld a, (.dmark)  
042b 32 68 fe			ld (debug_mark),a  
042e 3a 3d 04			ld a, (.dmark+1)  
0431 32 69 fe			ld (debug_mark+1),a  
0434 3a 3e 04			ld a, (.dmark+2)  
0437 32 6a fe			ld (debug_mark+2),a  
043a 18 03			jr .pastdmark  
043c ..			.dmark: db "SGg"  
043f f1			.pastdmark: pop af  
0440			endm  
# End of macro DMARK
0440					CALLMONITOR 
0440 cd 6c fe			call debug_vector  
0443				endm  
# End of macro CALLMONITOR
0443				endif 
0443			 
0443 c1					pop bc 
0444 10 89				djnz .getloop 
0446 21 ff 00				ld hl, 255 
0449			.getdone: 
0449			 
0449				if DEBUG_STORESE 
0449					DMARK "SGe" 
0449 f5				push af  
044a 3a 5e 04			ld a, (.dmark)  
044d 32 68 fe			ld (debug_mark),a  
0450 3a 5f 04			ld a, (.dmark+1)  
0453 32 69 fe			ld (debug_mark+1),a  
0456 3a 60 04			ld a, (.dmark+2)  
0459 32 6a fe			ld (debug_mark+2),a  
045c 18 03			jr .pastdmark  
045e ..			.dmark: db "SGe"  
0461 f1			.pastdmark: pop af  
0462			endm  
# End of macro DMARK
0462					CALLMONITOR 
0462 cd 6c fe			call debug_vector  
0465				endm  
# End of macro CALLMONITOR
0465				endif 
0465			 
0465 c9				ret 
0466			 
0466			 
0466			 
0466			 
0466			 
0466			 
0466			 
0466			 
0466			; Read Block 
0466			; ---------- 
0466			; 
0466			; With current bank 
0466			;  
0466			; Get block number to read 
0466			; Load physical blocks starting at start block into buffer 
0466			 
0466			; de points to buffer to use 
0466			; hl holds logical block number  
0466			 
0466			storage_read_block: 
0466			 
0466				; TODO bank selection 
0466			 
0466				; for each of the physical blocks read it into the buffer 
0466 06 40			ld b, STORE_BLOCK_PHY 
0468			 
0468				if DEBUG_STORESE 
0468 d5					push de 
0469				endif 
0469				 
0469			.rl1:    
0469			 
0469				; read physical block at hl into de 
0469			        ; increment hl and de to next read position on exit 
0469			 
0469 e5				push hl 
046a d5				push de	 
046b c5				push bc 
046c			;	if DEBUG_STORESE 
046c			;		push af 
046c			;		ld a, 'R' 
046c			;		ld (debug_mark),a 
046c			;		pop af 
046c			;		CALLMONITOR 
046c			;	endif 
046c cd 0d 03			call se_readbyte 
046f			;	if DEBUG_STORESE 
046f			;		ld a,(spi_portbyte) 
046f			;		ld l, a 
046f			;		push af 
046f			;		ld a, '1' 
046f			;		ld (debug_mark),a 
046f			;		pop af 
046f			;		CALLMONITOR 
046f			;	endif 
046f c1				pop bc 
0470 d1				pop de 
0471 e1				pop hl 
0472 12				ld (de),a 
0473 23				inc hl 
0474 13				inc de 
0475			 
0475			;	if DEBUG_STORESE 
0475			;		push af 
0475			;		ld a, 'r' 
0475			;		ld (debug_mark),a 
0475			;		pop af 
0475			;		CALLMONITOR 
0475			;	endif 
0475			 
0475 10 f2			djnz .rl1 
0477			 
0477				if DEBUG_STORESE 
0477					DMARK "SRB" 
0477 f5				push af  
0478 3a 8c 04			ld a, (.dmark)  
047b 32 68 fe			ld (debug_mark),a  
047e 3a 8d 04			ld a, (.dmark+1)  
0481 32 69 fe			ld (debug_mark+1),a  
0484 3a 8e 04			ld a, (.dmark+2)  
0487 32 6a fe			ld (debug_mark+2),a  
048a 18 03			jr .pastdmark  
048c ..			.dmark: db "SRB"  
048f f1			.pastdmark: pop af  
0490			endm  
# End of macro DMARK
0490 d1					pop de 
0491			; 
0491			;		push af 
0491			;		ld a, 'R' 
0491			;		ld (debug_mark),a 
0491			;		pop af 
0491					CALLMONITOR 
0491 cd 6c fe			call debug_vector  
0494				endm  
# End of macro CALLMONITOR
0494				endif 
0494 c9				ret	 
0495				 
0495			 
0495			; File Size 
0495			; --------- 
0495			; 
0495			;   hl file id 
0495			; 
0495			;  returns in hl the number of blocks 
0495			 
0495			storage_file_size: 
0495 5d				ld e, l 
0496 16 00			ld d, 0 
0498 21 40 00			ld hl, STORE_BLOCK_PHY 
049b					if DEBUG_FORTH_WORDS 
049b						DMARK "SIZ" 
049b f5				push af  
049c 3a b0 04			ld a, (.dmark)  
049f 32 68 fe			ld (debug_mark),a  
04a2 3a b1 04			ld a, (.dmark+1)  
04a5 32 69 fe			ld (debug_mark+1),a  
04a8 3a b2 04			ld a, (.dmark+2)  
04ab 32 6a fe			ld (debug_mark+2),a  
04ae 18 03			jr .pastdmark  
04b0 ..			.dmark: db "SIZ"  
04b3 f1			.pastdmark: pop af  
04b4			endm  
# End of macro DMARK
04b4						CALLMONITOR 
04b4 cd 6c fe			call debug_vector  
04b7				endm  
# End of macro CALLMONITOR
04b7					endif 
04b7 cd 99 07			call storage_findnextid 
04ba			 
04ba cd f9 0f			call ishlzero 
04bd			;	ld a, l 
04bd			;	add h 
04bd			;	cp 0 
04bd c8				ret z			; block not found so EOF 
04be			 
04be 11 77 fa			ld de, store_page 
04c1 cd 66 04			call storage_read_block 
04c4			 
04c4 3a 79 fa			ld a, (store_page+2)	 ; get extent count 
04c7 6f				ld l, a 
04c8 26 00			ld h, 0 
04ca c9			 	ret 
04cb			 
04cb			 
04cb			; Write Block 
04cb			; ----------- 
04cb			; 
04cb			; With current bank 
04cb			;  
04cb			; Get block number to write 
04cb			; Write physical blocks starting at start block from buffer 
04cb			  
04cb			storage_write_block: 
04cb				; TODO bank selection 
04cb			 
04cb				; for each of the physical blocks read it into the buffer 
04cb 06 40			ld b, STORE_BLOCK_PHY 
04cd			 
04cd				if DEBUG_STORESE 
04cd					DMARK "SWB" 
04cd f5				push af  
04ce 3a e2 04			ld a, (.dmark)  
04d1 32 68 fe			ld (debug_mark),a  
04d4 3a e3 04			ld a, (.dmark+1)  
04d7 32 69 fe			ld (debug_mark+1),a  
04da 3a e4 04			ld a, (.dmark+2)  
04dd 32 6a fe			ld (debug_mark+2),a  
04e0 18 03			jr .pastdmark  
04e2 ..			.dmark: db "SWB"  
04e5 f1			.pastdmark: pop af  
04e6			endm  
# End of macro DMARK
04e6			 
04e6					;push af 
04e6					;ld a, 'W' 
04e6					;ld (debug_mark),a 
04e6					;pop af 
04e6					CALLMONITOR 
04e6 cd 6c fe			call debug_vector  
04e9				endm  
# End of macro CALLMONITOR
04e9				endif 
04e9			 
04e9			; might not be working 
04e9			;	call se_writepage 
04e9			 
04e9			;	ret 
04e9			; 
04e9			 
04e9			 
04e9			 
04e9			.wl1:    
04e9			 
04e9				; read physical block at hl into de 
04e9			        ; increment hl and de to next read position on exit 
04e9			 
04e9 e5				push hl 
04ea d5				push de	 
04eb c5				push bc 
04ec 1a				ld a,(de) 
04ed				;if DEBUG_STORESE 
04ed			;		push af 
04ed			;		ld a, 'W' 
04ed			;		ld (debug_mark),a 
04ed			;		pop af 
04ed			;		CALLMONITOR 
04ed			;	endif 
04ed cd 6b 02			call se_writebyte 
04f0			;	call delay250ms 
04f0 00				nop 
04f1 00				nop 
04f2 00				nop 
04f3			;	if DEBUG_STORESE 
04f3			;		push af 
04f3			;		ld a, 'w' 
04f3			;		ld (debug_mark),a 
04f3			;		pop af 
04f3			;		CALLMONITOR 
04f3			;	endif 
04f3 c1				pop bc 
04f4 d1				pop de 
04f5 e1				pop hl 
04f6 23				inc hl 
04f7 13				inc de 
04f8			 
04f8			 
04f8 10 ef			djnz .wl1 
04fa			 
04fa				if DEBUG_STORESE 
04fa					DMARK "SW2" 
04fa f5				push af  
04fb 3a 0f 05			ld a, (.dmark)  
04fe 32 68 fe			ld (debug_mark),a  
0501 3a 10 05			ld a, (.dmark+1)  
0504 32 69 fe			ld (debug_mark+1),a  
0507 3a 11 05			ld a, (.dmark+2)  
050a 32 6a fe			ld (debug_mark+2),a  
050d 18 03			jr .pastdmark  
050f ..			.dmark: db "SW2"  
0512 f1			.pastdmark: pop af  
0513			endm  
# End of macro DMARK
0513			 
0513					;push af 
0513					;ld a, 'W' 
0513					;ld (debug_mark),a 
0513					;pop af 
0513					CALLMONITOR 
0513 cd 6c fe			call debug_vector  
0516				endm  
# End of macro CALLMONITOR
0516				endif 
0516 c9				ret	 
0517			 
0517			; Init bank 
0517			; --------- 
0517			; 
0517			; With current bank 
0517			; 
0517			; Setup block 0 config 
0517			;     Set 0 file id counter 
0517			;     Set formatted byte pattern 
0517			;     Zero out bank label 
0517			;      
0517			; For every logical block write 0-1 byte as null 
0517			 
0517			storage_get_block_0: 
0517			 
0517				; TODO check presence 
0517			 
0517				; get block 0 config 
0517			 
0517 21 00 00			ld hl, 0 
051a 11 77 fa			ld de, store_page 
051d cd 66 04			call storage_read_block 
0520			 
0520				if DEBUG_STORESE 
0520					DMARK "SB0" 
0520 f5				push af  
0521 3a 35 05			ld a, (.dmark)  
0524 32 68 fe			ld (debug_mark),a  
0527 3a 36 05			ld a, (.dmark+1)  
052a 32 69 fe			ld (debug_mark+1),a  
052d 3a 37 05			ld a, (.dmark+2)  
0530 32 6a fe			ld (debug_mark+2),a  
0533 18 03			jr .pastdmark  
0535 ..			.dmark: db "SB0"  
0538 f1			.pastdmark: pop af  
0539			endm  
# End of macro DMARK
0539 11 77 fa				ld de, store_page 
053c			;		push af 
053c			;		ld a, 'i' 
053c			;		ld (debug_mark),a 
053c			;		pop af 
053c					CALLMONITOR 
053c cd 6c fe			call debug_vector  
053f				endm  
# End of macro CALLMONITOR
053f				endif 
053f			 
053f				; is this area formatted? 
053f			 
053f			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
053f 2a 78 fa			ld hl, (store_page+1) 
0542 3e 80			ld a,0x80 
0544 bd				cp l 
0545 20 22			jr nz, .ininotformatted 
0547				; do a double check 
0547 3e 27			ld a, 0x27 
0549 bc				cp h 
054a 20 1d			jr nz, .ininotformatted 
054c			 
054c				; formatted then 
054c			 
054c				if DEBUG_STORESE 
054c					DMARK "SB1" 
054c f5				push af  
054d 3a 61 05			ld a, (.dmark)  
0550 32 68 fe			ld (debug_mark),a  
0553 3a 62 05			ld a, (.dmark+1)  
0556 32 69 fe			ld (debug_mark+1),a  
0559 3a 63 05			ld a, (.dmark+2)  
055c 32 6a fe			ld (debug_mark+2),a  
055f 18 03			jr .pastdmark  
0561 ..			.dmark: db "SB1"  
0564 f1			.pastdmark: pop af  
0565			endm  
# End of macro DMARK
0565					;push af 
0565					;ld a, 'I' 
0565					;ld (debug_mark),a 
0565					;pop af 
0565					CALLMONITOR 
0565 cd 6c fe			call debug_vector  
0568				endm  
# End of macro CALLMONITOR
0568				endif 
0568 c9				ret 
0569			 
0569			.ininotformatted: 
0569				; bank not formatted so poke various bits to make sure 
0569			 
0569				if DEBUG_STORESE 
0569					DMARK "SB2" 
0569 f5				push af  
056a 3a 7e 05			ld a, (.dmark)  
056d 32 68 fe			ld (debug_mark),a  
0570 3a 7f 05			ld a, (.dmark+1)  
0573 32 69 fe			ld (debug_mark+1),a  
0576 3a 80 05			ld a, (.dmark+2)  
0579 32 6a fe			ld (debug_mark+2),a  
057c 18 03			jr .pastdmark  
057e ..			.dmark: db "SB2"  
0581 f1			.pastdmark: pop af  
0582			endm  
# End of macro DMARK
0582					;push af 
0582					;ld a, 'f' 
0582					;ld (debug_mark),a 
0582					;pop af 
0582					CALLMONITOR 
0582 cd 6c fe			call debug_vector  
0585				endm  
# End of macro CALLMONITOR
0585				endif 
0585			 
0585 cd a2 0c			call storage_clear_page 
0588			 
0588 21 77 fa			ld hl, store_page 
058b 3e 00			ld a, 0 
058d				 
058d 77				ld (hl),a   ; reset file counter 
058e			 
058e 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0591 22 78 fa		 	ld (store_page+1), hl	 
0594			 
0594				; set default label 
0594			 
0594 21 30 06			ld hl, .defaultbanklabl 
0597 11 7a fa		 	ld de, store_page+3 
059a 01 0f 00			ld bc, 15 
059d ed b0			ldir 
059f			 
059f				; Append the current bank id 
059f 21 83 fa			ld hl, store_page+3+9 
05a2 3a 5c fa			ld a, (spi_device_id) 
05a5 77				ld (hl), a 
05a6			 
05a6				; save default page 0 
05a6			 
05a6 21 00 00			ld hl, 0 
05a9 11 77 fa			ld de, store_page 
05ac				if DEBUG_STORESE 
05ac					DMARK "SB3" 
05ac f5				push af  
05ad 3a c1 05			ld a, (.dmark)  
05b0 32 68 fe			ld (debug_mark),a  
05b3 3a c2 05			ld a, (.dmark+1)  
05b6 32 69 fe			ld (debug_mark+1),a  
05b9 3a c3 05			ld a, (.dmark+2)  
05bc 32 6a fe			ld (debug_mark+2),a  
05bf 18 03			jr .pastdmark  
05c1 ..			.dmark: db "SB3"  
05c4 f1			.pastdmark: pop af  
05c5			endm  
# End of macro DMARK
05c5			;		push af 
05c5			;		ld a, 'F' 
05c5			;		ld (debug_mark),a 
05c5			;		pop af 
05c5					CALLMONITOR 
05c5 cd 6c fe			call debug_vector  
05c8				endm  
# End of macro CALLMONITOR
05c8				endif 
05c8 cd cb 04			call storage_write_block 
05cb				if DEBUG_STORESE 
05cb					DMARK "SB4" 
05cb f5				push af  
05cc 3a e0 05			ld a, (.dmark)  
05cf 32 68 fe			ld (debug_mark),a  
05d2 3a e1 05			ld a, (.dmark+1)  
05d5 32 69 fe			ld (debug_mark+1),a  
05d8 3a e2 05			ld a, (.dmark+2)  
05db 32 6a fe			ld (debug_mark+2),a  
05de 18 03			jr .pastdmark  
05e0 ..			.dmark: db "SB4"  
05e3 f1			.pastdmark: pop af  
05e4			endm  
# End of macro DMARK
05e4			;		push af 
05e4			;		ld a, '>' 
05e4			;		ld (debug_mark),a 
05e4			;		pop af 
05e4					CALLMONITOR 
05e4 cd 6c fe			call debug_vector  
05e7				endm  
# End of macro CALLMONITOR
05e7				endif 
05e7			 
05e7 00				nop 
05e8 00				nop 
05e9 00				nop 
05ea			 
05ea				; now set 0 in every page to mark as a free block 
05ea			 
05ea 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05ec 21 40 00			ld hl, STORE_BLOCK_PHY 
05ef			 
05ef 3e 00		.setmark1:   	ld a,0 
05f1 e5					push hl 
05f2 c5					push bc 
05f3 cd 6b 02				call se_writebyte 
05f6 3e 0a			ld a, 10 
05f8 cd c4 0c			call aDelayInMS 
05fb 23				inc hl 
05fc cd 6b 02				call se_writebyte 
05ff 3e 0a			ld a, 10 
0601 cd c4 0c			call aDelayInMS 
0604 2b				dec hl 
0605 c1					pop bc 
0606 e1					pop hl 
0607 3e 40				ld a, STORE_BLOCK_PHY 
0609 cd d0 0f				call addatohl 
060c 10 e1				djnz .setmark1 
060e			 
060e 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0610 3e 00		.setmark2:   	ld a,0 
0612 e5					push hl 
0613 c5					push bc 
0614 cd 6b 02				call se_writebyte 
0617 3e 0a			ld a, 10 
0619 cd c4 0c			call aDelayInMS 
061c 23				inc hl 
061d cd 6b 02				call se_writebyte 
0620 3e 0a			ld a, 10 
0622 cd c4 0c			call aDelayInMS 
0625 2b				dec hl 
0626 c1					pop bc 
0627 e1					pop hl 
0628 3e 40				ld a, STORE_BLOCK_PHY 
062a cd d0 0f				call addatohl 
062d 10 e1				djnz .setmark2 
062f			 
062f					 
062f			 
062f			 
062f c9				ret 
0630			 
0630			 
0630			 
0630			 
0630 .. 00		.defaultbanklabl:   db "BankLabel_",0 
063b			 
063b			 
063b			 
063b			; Label Bank 
063b			; ---------- 
063b			; 
063b			; With current bank 
063b			; Read block 0 
063b			; Set label 
063b			; Write block 0 
063b			 
063b			; label str pointer in hl 
063b			 
063b			storage_label:     
063b			 
063b				if DEBUG_STORESE 
063b					DMARK "LBL" 
063b f5				push af  
063c 3a 50 06			ld a, (.dmark)  
063f 32 68 fe			ld (debug_mark),a  
0642 3a 51 06			ld a, (.dmark+1)  
0645 32 69 fe			ld (debug_mark+1),a  
0648 3a 52 06			ld a, (.dmark+2)  
064b 32 6a fe			ld (debug_mark+2),a  
064e 18 03			jr .pastdmark  
0650 ..			.dmark: db "LBL"  
0653 f1			.pastdmark: pop af  
0654			endm  
# End of macro DMARK
0654					CALLMONITOR 
0654 cd 6c fe			call debug_vector  
0657				endm  
# End of macro CALLMONITOR
0657				endif 
0657			 
0657 e5				push hl 
0658			 
0658 cd 17 05			call storage_get_block_0 
065b			 
065b				; set default label 
065b			 
065b e1				pop hl 
065c			 
065c 11 7a fa		 	ld de, store_page+3 
065f 01 0f 00			ld bc, 15 
0662				if DEBUG_STORESE 
0662					DMARK "LB3" 
0662 f5				push af  
0663 3a 77 06			ld a, (.dmark)  
0666 32 68 fe			ld (debug_mark),a  
0669 3a 78 06			ld a, (.dmark+1)  
066c 32 69 fe			ld (debug_mark+1),a  
066f 3a 79 06			ld a, (.dmark+2)  
0672 32 6a fe			ld (debug_mark+2),a  
0675 18 03			jr .pastdmark  
0677 ..			.dmark: db "LB3"  
067a f1			.pastdmark: pop af  
067b			endm  
# End of macro DMARK
067b					CALLMONITOR 
067b cd 6c fe			call debug_vector  
067e				endm  
# End of macro CALLMONITOR
067e				endif 
067e ed b0			ldir 
0680				; save default page 0 
0680			 
0680 21 00 00			ld hl, 0 
0683 11 77 fa			ld de, store_page 
0686				if DEBUG_STORESE 
0686					DMARK "LBW" 
0686 f5				push af  
0687 3a 9b 06			ld a, (.dmark)  
068a 32 68 fe			ld (debug_mark),a  
068d 3a 9c 06			ld a, (.dmark+1)  
0690 32 69 fe			ld (debug_mark+1),a  
0693 3a 9d 06			ld a, (.dmark+2)  
0696 32 6a fe			ld (debug_mark+2),a  
0699 18 03			jr .pastdmark  
069b ..			.dmark: db "LBW"  
069e f1			.pastdmark: pop af  
069f			endm  
# End of macro DMARK
069f					CALLMONITOR 
069f cd 6c fe			call debug_vector  
06a2				endm  
# End of macro CALLMONITOR
06a2				endif 
06a2 cd cb 04			call storage_write_block 
06a5			 
06a5 c9				ret 
06a6			 
06a6			 
06a6			 
06a6			; Read Block 0 - Config 
06a6			; --------------------- 
06a6			; 
06a6			; With current bank 
06a6			; Call presence test 
06a6			;    If not present format/init bank  
06a6			; Read block 0  
06a6			;  
06a6			 
06a6			 
06a6			; Dir 
06a6			; --- 
06a6			; 
06a6			; With current bank 
06a6			; Load Block 0 Config 
06a6			; Get max file id number 
06a6			; For each logical block 
06a6			;    Read block read byte 2 
06a6			;      if first block of file 
06a6			;         Display file name 
06a6			;         Display type flags for file 
06a6			;        
06a6			 
06a6			; moving to words as this requires stack control 
06a6			 
06a6			 
06a6			; Delete File 
06a6			; ----------- 
06a6			; 
06a6			; With current bank 
06a6			; 
06a6			; Load Block 0 Config 
06a6			; Get max file id number 
06a6			; For each logical block 
06a6			;    Read block file id 
06a6			;      If first block of file and dont have file id 
06a6			;         if file to delete 
06a6			;         Save file id 
06a6			;         Null file id 
06a6			;         Write this block back 
06a6			;      If file id is one saved 
06a6			;         Null file id 
06a6			;         Write this block back 
06a6			 
06a6			 
06a6			.se_done: 
06a6 e1				pop hl 
06a7 c9				ret 
06a8			 
06a8			storage_erase: 
06a8			 
06a8				; hl contains the file id 
06a8			 
06a8 5d				ld e, l 
06a9 16 00			ld d, 0 
06ab 21 40 00			ld hl, STORE_BLOCK_PHY 
06ae					if DEBUG_FORTH_WORDS 
06ae						DMARK "ERA" 
06ae f5				push af  
06af 3a c3 06			ld a, (.dmark)  
06b2 32 68 fe			ld (debug_mark),a  
06b5 3a c4 06			ld a, (.dmark+1)  
06b8 32 69 fe			ld (debug_mark+1),a  
06bb 3a c5 06			ld a, (.dmark+2)  
06be 32 6a fe			ld (debug_mark+2),a  
06c1 18 03			jr .pastdmark  
06c3 ..			.dmark: db "ERA"  
06c6 f1			.pastdmark: pop af  
06c7			endm  
# End of macro DMARK
06c7						CALLMONITOR 
06c7 cd 6c fe			call debug_vector  
06ca				endm  
# End of macro CALLMONITOR
06ca					endif 
06ca cd 99 07			call storage_findnextid 
06cd cd f9 0f			call ishlzero 
06d0 c8				ret z 
06d1			 
06d1 e5				push hl 
06d2			 
06d2				; TODO check file not found 
06d2			 
06d2 11 77 fa			ld de, store_page 
06d5 cd 66 04			call storage_read_block 
06d8			 
06d8 cd f9 0f			call ishlzero 
06db ca a6 06			jp z,.se_done 
06de			 
06de					if DEBUG_FORTH_WORDS 
06de						DMARK "ER1" 
06de f5				push af  
06df 3a f3 06			ld a, (.dmark)  
06e2 32 68 fe			ld (debug_mark),a  
06e5 3a f4 06			ld a, (.dmark+1)  
06e8 32 69 fe			ld (debug_mark+1),a  
06eb 3a f5 06			ld a, (.dmark+2)  
06ee 32 6a fe			ld (debug_mark+2),a  
06f1 18 03			jr .pastdmark  
06f3 ..			.dmark: db "ER1"  
06f6 f1			.pastdmark: pop af  
06f7			endm  
# End of macro DMARK
06f7						CALLMONITOR 
06f7 cd 6c fe			call debug_vector  
06fa				endm  
# End of macro CALLMONITOR
06fa					endif 
06fa 3a 77 fa			ld a, (store_page)	; get file id 
06fd 32 6b fa			ld (store_tmpid), a 
0700			 
0700 3a 79 fa			ld a, (store_page+2)    ; get count of extends 
0703 32 6a fa			ld (store_tmpext), a 
0706			 
0706				; wipe file header 
0706			 
0706 e1				pop hl 
0707 3e 00			ld a, 0 
0709 32 77 fa			ld (store_page), a 
070c 32 78 fa			ld (store_page+1),a 
070f 11 77 fa			ld de, store_page 
0712					if DEBUG_FORTH_WORDS 
0712						DMARK "ER2" 
0712 f5				push af  
0713 3a 27 07			ld a, (.dmark)  
0716 32 68 fe			ld (debug_mark),a  
0719 3a 28 07			ld a, (.dmark+1)  
071c 32 69 fe			ld (debug_mark+1),a  
071f 3a 29 07			ld a, (.dmark+2)  
0722 32 6a fe			ld (debug_mark+2),a  
0725 18 03			jr .pastdmark  
0727 ..			.dmark: db "ER2"  
072a f1			.pastdmark: pop af  
072b			endm  
# End of macro DMARK
072b						CALLMONITOR 
072b cd 6c fe			call debug_vector  
072e				endm  
# End of macro CALLMONITOR
072e					endif 
072e cd cb 04			call storage_write_block 
0731			 
0731			 
0731				; wipe file extents 
0731			 
0731 3a 6a fa			ld a, (store_tmpext) 
0734 47				ld b, a 
0735			 
0735			.eraext:	  
0735 c5				push bc 
0736			 
0736 21 40 00			ld hl, STORE_BLOCK_PHY 
0739 3a 6b fa			ld a,(store_tmpid) 
073c 5f				ld e, a 
073d 50				ld d, b	 
073e					if DEBUG_FORTH_WORDS 
073e						DMARK "ER3" 
073e f5				push af  
073f 3a 53 07			ld a, (.dmark)  
0742 32 68 fe			ld (debug_mark),a  
0745 3a 54 07			ld a, (.dmark+1)  
0748 32 69 fe			ld (debug_mark+1),a  
074b 3a 55 07			ld a, (.dmark+2)  
074e 32 6a fe			ld (debug_mark+2),a  
0751 18 03			jr .pastdmark  
0753 ..			.dmark: db "ER3"  
0756 f1			.pastdmark: pop af  
0757			endm  
# End of macro DMARK
0757						CALLMONITOR 
0757 cd 6c fe			call debug_vector  
075a				endm  
# End of macro CALLMONITOR
075a					endif 
075a cd 99 07			call storage_findnextid 
075d cd f9 0f			call ishlzero 
0760 ca a6 06			jp z,.se_done 
0763			 
0763 e5				push hl 
0764 11 77 fa			ld de, store_page 
0767 cd 66 04			call storage_read_block 
076a			 
076a				; free block	 
076a			 
076a 3e 00			ld a, 0 
076c 32 77 fa			ld (store_page), a 
076f 32 78 fa			ld (store_page+1),a 
0772 11 77 fa			ld de, store_page 
0775 e1				pop hl 
0776					if DEBUG_FORTH_WORDS 
0776						DMARK "ER4" 
0776 f5				push af  
0777 3a 8b 07			ld a, (.dmark)  
077a 32 68 fe			ld (debug_mark),a  
077d 3a 8c 07			ld a, (.dmark+1)  
0780 32 69 fe			ld (debug_mark+1),a  
0783 3a 8d 07			ld a, (.dmark+2)  
0786 32 6a fe			ld (debug_mark+2),a  
0789 18 03			jr .pastdmark  
078b ..			.dmark: db "ER4"  
078e f1			.pastdmark: pop af  
078f			endm  
# End of macro DMARK
078f						CALLMONITOR 
078f cd 6c fe			call debug_vector  
0792				endm  
# End of macro CALLMONITOR
0792					endif 
0792 cd cb 04			call storage_write_block 
0795			 
0795 c1				pop bc 
0796 10 9d			djnz .eraext 
0798			 
0798 c9				ret 
0799			 
0799			 
0799			; Find Free Block 
0799			; --------------- 
0799			; 
0799			; With current bank 
0799			;  
0799			; From given starting logical block 
0799			;    Read block  
0799			;    If no file id 
0799			;         Return block id 
0799			 
0799			 
0799			; hl starting page number 
0799			; hl contains free page number or zero if no pages free 
0799			; e contains the file id to locate 
0799			; d contains the block number 
0799			 
0799			; TODO change to find file id and use zero for free block 
0799			 
0799			storage_findnextid: 
0799			 
0799				; now locate first 0 page to mark as a free block 
0799			 
0799 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
079b			;	ld hl, STORE_BLOCK_PHY 
079b			 
079b					if DEBUG_FORTH_WORDS 
079b					DMARK "FNI" 
079b f5				push af  
079c 3a b0 07			ld a, (.dmark)  
079f 32 68 fe			ld (debug_mark),a  
07a2 3a b1 07			ld a, (.dmark+1)  
07a5 32 69 fe			ld (debug_mark+1),a  
07a8 3a b2 07			ld a, (.dmark+2)  
07ab 32 6a fe			ld (debug_mark+2),a  
07ae 18 03			jr .pastdmark  
07b0 ..			.dmark: db "FNI"  
07b3 f1			.pastdmark: pop af  
07b4			endm  
# End of macro DMARK
07b4						CALLMONITOR 
07b4 cd 6c fe			call debug_vector  
07b7				endm  
# End of macro CALLMONITOR
07b7					endif 
07b7			.ff1:   	 
07b7 e5					push hl 
07b8 c5					push bc 
07b9 d5					push de 
07ba cd 0d 03				call se_readbyte 
07bd 5f					ld e,a 
07be 23					inc hl 
07bf cd 0d 03				call se_readbyte 
07c2 57					ld d, a 
07c3 e1					pop hl 
07c4 e5					push hl 
07c5 cd ee 0f				call cmp16 
07c8 28 49				jr z, .fffound 
07ca			 
07ca d1					pop de 
07cb c1					pop bc 
07cc e1					pop hl 
07cd			 
07cd					; is found? 
07cd					;cp e 
07cd					;ret z 
07cd			 
07cd 3e 40				ld a, STORE_BLOCK_PHY 
07cf cd d0 0f				call addatohl 
07d2 10 e3				djnz .ff1 
07d4			 
07d4 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07d6			.ff2:   	 
07d6			 
07d6 e5					push hl 
07d7 c5					push bc 
07d8 d5					push de 
07d9 cd 0d 03				call se_readbyte 
07dc 5f					ld e,a 
07dd 23					inc hl 
07de cd 0d 03				call se_readbyte 
07e1 57					ld d, a 
07e2			 
07e2 e1					pop hl 
07e3 e5					push hl 
07e4 cd ee 0f				call cmp16 
07e7 28 2a				jr z, .fffound 
07e9			 
07e9 d1					pop de 
07ea c1					pop bc 
07eb e1					pop hl 
07ec					; is found? 
07ec					;cp e 
07ec					;ret z 
07ec			 
07ec 3e 40				ld a, STORE_BLOCK_PHY 
07ee cd d0 0f				call addatohl 
07f1 10 e3				djnz .ff2 
07f3			 
07f3			 
07f3					if DEBUG_FORTH_WORDS 
07f3					DMARK "FN-" 
07f3 f5				push af  
07f4 3a 08 08			ld a, (.dmark)  
07f7 32 68 fe			ld (debug_mark),a  
07fa 3a 09 08			ld a, (.dmark+1)  
07fd 32 69 fe			ld (debug_mark+1),a  
0800 3a 0a 08			ld a, (.dmark+2)  
0803 32 6a fe			ld (debug_mark+2),a  
0806 18 03			jr .pastdmark  
0808 ..			.dmark: db "FN-"  
080b f1			.pastdmark: pop af  
080c			endm  
# End of macro DMARK
080c					;	push af 
080c					;	ld a, 'n' 
080c					;	ld (debug_mark),a 
080c					;	pop af 
080c						CALLMONITOR 
080c cd 6c fe			call debug_vector  
080f				endm  
# End of macro CALLMONITOR
080f					endif 
080f				; no free marks! 
080f 21 00 00				ld hl, 0 
0812 c9				ret 
0813			.fffound: 
0813				 
0813			 
0813 d1					pop de 
0814 c1					pop bc 
0815 e1					pop hl 
0816					if DEBUG_FORTH_WORDS 
0816					DMARK "FNF" 
0816 f5				push af  
0817 3a 2b 08			ld a, (.dmark)  
081a 32 68 fe			ld (debug_mark),a  
081d 3a 2c 08			ld a, (.dmark+1)  
0820 32 69 fe			ld (debug_mark+1),a  
0823 3a 2d 08			ld a, (.dmark+2)  
0826 32 6a fe			ld (debug_mark+2),a  
0829 18 03			jr .pastdmark  
082b ..			.dmark: db "FNF"  
082e f1			.pastdmark: pop af  
082f			endm  
# End of macro DMARK
082f					;	push af 
082f					;	ld a, 'n' 
082f					;	ld (debug_mark),a 
082f					;	pop af 
082f						CALLMONITOR 
082f cd 6c fe			call debug_vector  
0832				endm  
# End of macro CALLMONITOR
0832					endif 
0832 c9				ret 
0833			 
0833			 
0833			 
0833			; Free Space 
0833			; ---------- 
0833			; 
0833			; With current bank 
0833			; 
0833			; Set block count to zero 
0833			; Starting with first logical block 
0833			;      Find free block  
0833			;      If block id given, increment block count 
0833			; 
0833			;  
0833			 
0833			 
0833			; hl contains count of free blocks 
0833			 
0833			storage_freeblocks: 
0833			 
0833				; now locate first 0 page to mark as a free block 
0833			 
0833 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0835 21 40 00			ld hl, STORE_BLOCK_PHY 
0838 11 00 00			ld de, 0 
083b			 
083b			.fb1:   	 
083b e5					push hl 
083c c5					push bc 
083d d5					push de 
083e cd 0d 03				call se_readbyte 
0841 d1					pop de 
0842 c1					pop bc 
0843 e1					pop hl 
0844			 
0844					; is free? 
0844 fe 00				cp 0 
0846 20 01				jr nz, .ff1cont 
0848 13					inc de 
0849			 
0849			.ff1cont: 
0849			 
0849			 
0849 3e 40				ld a, STORE_BLOCK_PHY 
084b cd d0 0f				call addatohl 
084e 10 eb				djnz .fb1 
0850			 
0850 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0852			.fb2:   	 
0852 e5					push hl 
0853 c5					push bc 
0854 d5					push de 
0855 cd 0d 03				call se_readbyte 
0858 d1					pop de 
0859 c1					pop bc 
085a e1					pop hl 
085b			 
085b					; is free? 
085b fe 00				cp 0 
085d 20 01				jr nz, .ff2cont 
085f 13					inc de 
0860			 
0860			.ff2cont: 
0860			 
0860 3e 40				ld a, STORE_BLOCK_PHY 
0862 cd d0 0f				call addatohl 
0865 10 eb				djnz .fb2 
0867			 
0867 eb				ex de, hl 
0868 c9				ret 
0869			 
0869			; Get File ID 
0869			; ----------- 
0869			; 
0869			; With current bank 
0869			;  
0869			; Load Block 0 Config 
0869			; Get max file id number 
0869			; For each logical block 
0869			;    Read block file id 
0869			;      If first block of file and dont have file id 
0869			;         if file get id and exit 
0869			 
0869			 
0869			 
0869			 
0869			; Create File 
0869			; ----------- 
0869			; 
0869			; With current bank  
0869			; Load Block 0 Config 
0869			; Get max file id number 
0869			; Increment file id number 
0869			; Save Config 
0869			; Find free block 
0869			; Set buffer with file name and file id 
0869			; Write buffer to free block  
0869			 
0869			 
0869			; hl point to file name 
0869			; hl returns file id 
0869			 
0869			; file format: 
0869			; byte 0 - file id 
0869			; byte 1 - extent number 
0869			; byte 2-> data 
0869			 
0869			; format for extent number 0: 
0869			; 
0869			; byte 0 - file id 
0869			; byte 1 - extent 0 
0869			; byte 2 - extent count 
0869			; byte 3 -> file name and meta data 
0869			 
0869			 
0869			storage_create: 
0869				if DEBUG_STORESE 
0869					DMARK "SCR" 
0869 f5				push af  
086a 3a 7e 08			ld a, (.dmark)  
086d 32 68 fe			ld (debug_mark),a  
0870 3a 7f 08			ld a, (.dmark+1)  
0873 32 69 fe			ld (debug_mark+1),a  
0876 3a 80 08			ld a, (.dmark+2)  
0879 32 6a fe			ld (debug_mark+2),a  
087c 18 03			jr .pastdmark  
087e ..			.dmark: db "SCR"  
0881 f1			.pastdmark: pop af  
0882			endm  
# End of macro DMARK
0882					CALLMONITOR 
0882 cd 6c fe			call debug_vector  
0885				endm  
# End of macro CALLMONITOR
0885				endif 
0885			 
0885 e5				push hl		; save file name pointer 
0886			 
0886 cd 17 05			call storage_get_block_0 
0889			 
0889 3a 77 fa			ld a,(store_page)	; get current file id 
088c 3c				inc a 
088d 32 77 fa			ld (store_page),a 
0890				 
0890 32 6b fa			ld (store_tmpid),a			; save id 
0893			 
0893 21 00 00			ld hl, 0 
0896 11 77 fa			ld de, store_page 
0899				if DEBUG_STORESE 
0899					DMARK "SCw" 
0899 f5				push af  
089a 3a ae 08			ld a, (.dmark)  
089d 32 68 fe			ld (debug_mark),a  
08a0 3a af 08			ld a, (.dmark+1)  
08a3 32 69 fe			ld (debug_mark+1),a  
08a6 3a b0 08			ld a, (.dmark+2)  
08a9 32 6a fe			ld (debug_mark+2),a  
08ac 18 03			jr .pastdmark  
08ae ..			.dmark: db "SCw"  
08b1 f1			.pastdmark: pop af  
08b2			endm  
# End of macro DMARK
08b2					CALLMONITOR 
08b2 cd 6c fe			call debug_vector  
08b5				endm  
# End of macro CALLMONITOR
08b5				endif 
08b5 cd cb 04			call storage_write_block	 ; save update 
08b8			 
08b8				if DEBUG_STORESE 
08b8 11 77 fa				ld de, store_page 
08bb					DMARK "SCC" 
08bb f5				push af  
08bc 3a d0 08			ld a, (.dmark)  
08bf 32 68 fe			ld (debug_mark),a  
08c2 3a d1 08			ld a, (.dmark+1)  
08c5 32 69 fe			ld (debug_mark+1),a  
08c8 3a d2 08			ld a, (.dmark+2)  
08cb 32 6a fe			ld (debug_mark+2),a  
08ce 18 03			jr .pastdmark  
08d0 ..			.dmark: db "SCC"  
08d3 f1			.pastdmark: pop af  
08d4			endm  
# End of macro DMARK
08d4					CALLMONITOR 
08d4 cd 6c fe			call debug_vector  
08d7				endm  
# End of macro CALLMONITOR
08d7				endif 
08d7				;  
08d7				 
08d7 21 40 00			ld hl, STORE_BLOCK_PHY 
08da 11 00 00			ld de, 0 
08dd cd 99 07			call storage_findnextid 
08e0			 
08e0 22 62 fa			ld (store_tmppageid), hl    ; save page to use  
08e3			 
08e3				; TODO detect 0 = no spare blocks 
08e3			 
08e3				; hl now contains the free page to use for the file header page 
08e3			 
08e3				if DEBUG_STORESE 
08e3				DMARK "SCF" 
08e3 f5				push af  
08e4 3a f8 08			ld a, (.dmark)  
08e7 32 68 fe			ld (debug_mark),a  
08ea 3a f9 08			ld a, (.dmark+1)  
08ed 32 69 fe			ld (debug_mark+1),a  
08f0 3a fa 08			ld a, (.dmark+2)  
08f3 32 6a fe			ld (debug_mark+2),a  
08f6 18 03			jr .pastdmark  
08f8 ..			.dmark: db "SCF"  
08fb f1			.pastdmark: pop af  
08fc			endm  
# End of macro DMARK
08fc					CALLMONITOR 
08fc cd 6c fe			call debug_vector  
08ff				endm  
# End of macro CALLMONITOR
08ff				endif 
08ff			 
08ff 22 62 fa			ld (store_tmppageid), hl 
0902				 
0902 3a 6b fa			ld a,(store_tmpid)    ; get file id 
0905			;	ld a, (store_filecache)			; save to cache 
0905			 
0905 32 77 fa			ld (store_page),a    ; set page id 
0908 3e 00			ld a, 0			 ; extent 0 is file header 
090a 32 78 fa			ld (store_page+1), a   ; set file extent 
090d			 
090d 32 79 fa			ld (store_page+2), a   ; extent count for the file 
0910			 
0910			;	inc hl 		; init block 0 of file 
0910			;	inc hl   		; skip file and extent id 
0910			 ;       ld a, 0 
0910			;	ld (hl),a 
0910			;	ld a, (store_filecache+1)  	; save to cache 
0910			 
0910			;	inc hl    ; file name 
0910				 
0910				 
0910 11 7a fa			ld de, store_page+3    ; get buffer for term string to use as file name 
0913				if DEBUG_STORESE 
0913					DMARK "SCc" 
0913 f5				push af  
0914 3a 28 09			ld a, (.dmark)  
0917 32 68 fe			ld (debug_mark),a  
091a 3a 29 09			ld a, (.dmark+1)  
091d 32 69 fe			ld (debug_mark+1),a  
0920 3a 2a 09			ld a, (.dmark+2)  
0923 32 6a fe			ld (debug_mark+2),a  
0926 18 03			jr .pastdmark  
0928 ..			.dmark: db "SCc"  
092b f1			.pastdmark: pop af  
092c			endm  
# End of macro DMARK
092c					CALLMONITOR 
092c cd 6c fe			call debug_vector  
092f				endm  
# End of macro CALLMONITOR
092f				endif 
092f e1				pop hl    ; get zero term string 
0930 e5				push hl 
0931 3e 00			ld a, 0 
0933 cd 39 14			call strlent 
0936 23				inc hl   ; cover zero term 
0937 06 00			ld b,0 
0939 4d				ld c,l 
093a e1				pop hl 
093b				;ex de, hl 
093b				if DEBUG_STORESE 
093b					DMARK "SCa" 
093b f5				push af  
093c 3a 50 09			ld a, (.dmark)  
093f 32 68 fe			ld (debug_mark),a  
0942 3a 51 09			ld a, (.dmark+1)  
0945 32 69 fe			ld (debug_mark+1),a  
0948 3a 52 09			ld a, (.dmark+2)  
094b 32 6a fe			ld (debug_mark+2),a  
094e 18 03			jr .pastdmark  
0950 ..			.dmark: db "SCa"  
0953 f1			.pastdmark: pop af  
0954			endm  
# End of macro DMARK
0954					;push af 
0954					;ld a, 'a' 
0954					;ld (debug_mark),a 
0954					;pop af 
0954					CALLMONITOR 
0954 cd 6c fe			call debug_vector  
0957				endm  
# End of macro CALLMONITOR
0957				endif 
0957 ed b0			ldir    ; copy zero term string 
0959				if DEBUG_STORESE 
0959					DMARK "SCA" 
0959 f5				push af  
095a 3a 6e 09			ld a, (.dmark)  
095d 32 68 fe			ld (debug_mark),a  
0960 3a 6f 09			ld a, (.dmark+1)  
0963 32 69 fe			ld (debug_mark+1),a  
0966 3a 70 09			ld a, (.dmark+2)  
0969 32 6a fe			ld (debug_mark+2),a  
096c 18 03			jr .pastdmark  
096e ..			.dmark: db "SCA"  
0971 f1			.pastdmark: pop af  
0972			endm  
# End of macro DMARK
0972					CALLMONITOR 
0972 cd 6c fe			call debug_vector  
0975				endm  
# End of macro CALLMONITOR
0975				endif 
0975			 
0975				; write file header page 
0975			 
0975 2a 62 fa			ld hl,(store_tmppageid) 
0978 11 77 fa			ld de, store_page 
097b				if DEBUG_STORESE 
097b					DMARK "SCb" 
097b f5				push af  
097c 3a 90 09			ld a, (.dmark)  
097f 32 68 fe			ld (debug_mark),a  
0982 3a 91 09			ld a, (.dmark+1)  
0985 32 69 fe			ld (debug_mark+1),a  
0988 3a 92 09			ld a, (.dmark+2)  
098b 32 6a fe			ld (debug_mark+2),a  
098e 18 03			jr .pastdmark  
0990 ..			.dmark: db "SCb"  
0993 f1			.pastdmark: pop af  
0994			endm  
# End of macro DMARK
0994					;push af 
0994					;ld a, 'b' 
0994					;ld (debug_mark),a 
0994					;pop af 
0994					CALLMONITOR 
0994 cd 6c fe			call debug_vector  
0997				endm  
# End of macro CALLMONITOR
0997				endif 
0997 cd cb 04			call storage_write_block 
099a			 
099a 3a 6b fa			ld a, (store_tmpid) 
099d 6f				ld l, a 
099e 26 00			ld h,0 
09a0				if DEBUG_STORESE 
09a0					DMARK "SCz" 
09a0 f5				push af  
09a1 3a b5 09			ld a, (.dmark)  
09a4 32 68 fe			ld (debug_mark),a  
09a7 3a b6 09			ld a, (.dmark+1)  
09aa 32 69 fe			ld (debug_mark+1),a  
09ad 3a b7 09			ld a, (.dmark+2)  
09b0 32 6a fe			ld (debug_mark+2),a  
09b3 18 03			jr .pastdmark  
09b5 ..			.dmark: db "SCz"  
09b8 f1			.pastdmark: pop af  
09b9			endm  
# End of macro DMARK
09b9					CALLMONITOR 
09b9 cd 6c fe			call debug_vector  
09bc				endm  
# End of macro CALLMONITOR
09bc				endif 
09bc c9				ret 
09bd				 
09bd			 
09bd			 
09bd			; 
09bd			; Read File 
09bd			; 
09bd			; h - file id to locate 
09bd			; l - extent to locate 
09bd			; de - pointer to string to read into 
09bd			; 
09bd			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
09bd			 
09bd			.sr_fail: 
09bd d1				pop de 
09be c9				ret 
09bf			 
09bf			storage_read: 
09bf			 
09bf			 
09bf d5				push de 
09c0			 
09c0			; TODO BUG the above push is it popped before the RET Z? 
09c0			 
09c0			; TODO how to handle multiple part blocks 
09c0			 
09c0				; locate file extent to read 
09c0			 
09c0 5c				ld e, h 
09c1 55				ld d, l 
09c2			 
09c2			.srext: 
09c2 22 75 fa			ld (store_readptr), hl     ; save the current extent to load 
09c5 ed 53 73 fa		ld (store_readbuf), de     ; save the current buffer to load in to 
09c9			 
09c9 21 40 00			ld hl, STORE_BLOCK_PHY 
09cc				if DEBUG_STORESE 
09cc					DMARK "sre" 
09cc f5				push af  
09cd 3a e1 09			ld a, (.dmark)  
09d0 32 68 fe			ld (debug_mark),a  
09d3 3a e2 09			ld a, (.dmark+1)  
09d6 32 69 fe			ld (debug_mark+1),a  
09d9 3a e3 09			ld a, (.dmark+2)  
09dc 32 6a fe			ld (debug_mark+2),a  
09df 18 03			jr .pastdmark  
09e1 ..			.dmark: db "sre"  
09e4 f1			.pastdmark: pop af  
09e5			endm  
# End of macro DMARK
09e5					CALLMONITOR 
09e5 cd 6c fe			call debug_vector  
09e8				endm  
# End of macro CALLMONITOR
09e8				endif 
09e8 cd 99 07			call storage_findnextid 
09eb			 
09eb				if DEBUG_STORESE 
09eb					DMARK "srf" 
09eb f5				push af  
09ec 3a 00 0a			ld a, (.dmark)  
09ef 32 68 fe			ld (debug_mark),a  
09f2 3a 01 0a			ld a, (.dmark+1)  
09f5 32 69 fe			ld (debug_mark+1),a  
09f8 3a 02 0a			ld a, (.dmark+2)  
09fb 32 6a fe			ld (debug_mark+2),a  
09fe 18 03			jr .pastdmark  
0a00 ..			.dmark: db "srf"  
0a03 f1			.pastdmark: pop af  
0a04			endm  
# End of macro DMARK
0a04					CALLMONITOR 
0a04 cd 6c fe			call debug_vector  
0a07				endm  
# End of macro CALLMONITOR
0a07				endif 
0a07 cd f9 0f			call ishlzero 
0a0a			;	ld a, l 
0a0a			;	add h 
0a0a			;	cp 0 
0a0a 28 b1			jr z,.sr_fail			; block not found so EOF 
0a0c			 
0a0c				; save current address for use by higher level words etc 
0a0c			 
0a0c 22 68 fa			ld (store_openaddr),hl 
0a0f			 
0a0f			 
0a0f				; hl contains page number to load 
0a0f d1				pop de   ; get storage 
0a10 ed 53 73 fa		ld (store_readbuf), de     ; current buffer to load in to 
0a14 d5				push de 
0a15				if DEBUG_STORESE 
0a15					DMARK "srg" 
0a15 f5				push af  
0a16 3a 2a 0a			ld a, (.dmark)  
0a19 32 68 fe			ld (debug_mark),a  
0a1c 3a 2b 0a			ld a, (.dmark+1)  
0a1f 32 69 fe			ld (debug_mark+1),a  
0a22 3a 2c 0a			ld a, (.dmark+2)  
0a25 32 6a fe			ld (debug_mark+2),a  
0a28 18 03			jr .pastdmark  
0a2a ..			.dmark: db "srg"  
0a2d f1			.pastdmark: pop af  
0a2e			endm  
# End of macro DMARK
0a2e					CALLMONITOR 
0a2e cd 6c fe			call debug_vector  
0a31				endm  
# End of macro CALLMONITOR
0a31				endif 
0a31 cd 66 04			call storage_read_block 
0a34			 
0a34				; if this a continuation read??? 
0a34			 
0a34 2a 73 fa			ld hl, (store_readbuf)     ; current buffer to load in to 
0a37			 
0a37 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a39 cd d0 0f			call addatohl 
0a3c 7e				ld a,(hl) 
0a3d fe 00			cp 0 
0a3f 28 02			jr z, .markiscont 
0a41 3e ff			ld a, 255 
0a43			 
0a43			.markiscont: 
0a43 32 6a fa			ld (store_readcont), a 
0a46			 
0a46				if DEBUG_STORESE 
0a46					DMARK "srC" 
0a46 f5				push af  
0a47 3a 5b 0a			ld a, (.dmark)  
0a4a 32 68 fe			ld (debug_mark),a  
0a4d 3a 5c 0a			ld a, (.dmark+1)  
0a50 32 69 fe			ld (debug_mark+1),a  
0a53 3a 5d 0a			ld a, (.dmark+2)  
0a56 32 6a fe			ld (debug_mark+2),a  
0a59 18 03			jr .pastdmark  
0a5b ..			.dmark: db "srC"  
0a5e f1			.pastdmark: pop af  
0a5f			endm  
# End of macro DMARK
0a5f					CALLMONITOR 
0a5f cd 6c fe			call debug_vector  
0a62				endm  
# End of macro CALLMONITOR
0a62				endif 
0a62				; only short reads enabled 
0a62			 
0a62 3a 72 fa			ld a, (store_longread) 
0a65 fe 00			cp 0 
0a67 ca 34 0b			jp z, .readdone 
0a6a			 
0a6a			; TODO if block has no zeros then need to read next block  
0a6a			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
0a6a			; check last byte of physical block. 
0a6a			; if not zero then the next block needs to be loaded 
0a6a			 
0a6a			 
0a6a 2a 73 fa			ld hl, (store_readbuf)     ; current buffer to load in to 
0a6d			 
0a6d 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a6f cd d0 0f			call addatohl 
0a72				;dec hl 
0a72 7e				ld a,(hl) 
0a73				if DEBUG_STORESE 
0a73					DMARK "sr?" 
0a73 f5				push af  
0a74 3a 88 0a			ld a, (.dmark)  
0a77 32 68 fe			ld (debug_mark),a  
0a7a 3a 89 0a			ld a, (.dmark+1)  
0a7d 32 69 fe			ld (debug_mark+1),a  
0a80 3a 8a 0a			ld a, (.dmark+2)  
0a83 32 6a fe			ld (debug_mark+2),a  
0a86 18 03			jr .pastdmark  
0a88 ..			.dmark: db "sr?"  
0a8b f1			.pastdmark: pop af  
0a8c			endm  
# End of macro DMARK
0a8c					CALLMONITOR 
0a8c cd 6c fe			call debug_vector  
0a8f				endm  
# End of macro CALLMONITOR
0a8f				endif 
0a8f fe 00			cp 0 
0a91 ca 34 0b			jp z, .readdone 
0a94			 
0a94				; last byte is not zero so there is more in the next extent. Load it on the end.	 
0a94			 
0a94 23				inc hl 
0a95			 
0a95 22 73 fa			ld (store_readbuf), hl     ; save the current buffer to load in to 
0a98			 
0a98 ed 5b 75 fa		ld de, (store_readptr)     ; save the current extent to load 
0a9c			 
0a9c eb				ex de, hl 
0a9d			 
0a9d				; next ext 
0a9d			 
0a9d 23				inc hl 
0a9e 22 75 fa			ld  (store_readptr), hl     ; save the current extent to load 
0aa1			 
0aa1				if DEBUG_STORESE 
0aa1					DMARK "sF2" 
0aa1 f5				push af  
0aa2 3a b6 0a			ld a, (.dmark)  
0aa5 32 68 fe			ld (debug_mark),a  
0aa8 3a b7 0a			ld a, (.dmark+1)  
0aab 32 69 fe			ld (debug_mark+1),a  
0aae 3a b8 0a			ld a, (.dmark+2)  
0ab1 32 6a fe			ld (debug_mark+2),a  
0ab4 18 03			jr .pastdmark  
0ab6 ..			.dmark: db "sF2"  
0ab9 f1			.pastdmark: pop af  
0aba			endm  
# End of macro DMARK
0aba					CALLMONITOR 
0aba cd 6c fe			call debug_vector  
0abd				endm  
# End of macro CALLMONITOR
0abd				endif 
0abd			 
0abd				; get and load block 
0abd			 
0abd cd 99 07			call storage_findnextid 
0ac0			 
0ac0				if DEBUG_STORESE 
0ac0					DMARK "sf2" 
0ac0 f5				push af  
0ac1 3a d5 0a			ld a, (.dmark)  
0ac4 32 68 fe			ld (debug_mark),a  
0ac7 3a d6 0a			ld a, (.dmark+1)  
0aca 32 69 fe			ld (debug_mark+1),a  
0acd 3a d7 0a			ld a, (.dmark+2)  
0ad0 32 6a fe			ld (debug_mark+2),a  
0ad3 18 03			jr .pastdmark  
0ad5 ..			.dmark: db "sf2"  
0ad8 f1			.pastdmark: pop af  
0ad9			endm  
# End of macro DMARK
0ad9					CALLMONITOR 
0ad9 cd 6c fe			call debug_vector  
0adc				endm  
# End of macro CALLMONITOR
0adc				endif 
0adc cd f9 0f			call ishlzero 
0adf			;	ld a, l 
0adf			;	add h 
0adf			;	cp 0 
0adf ca bd 09			jp z,.sr_fail			; block not found so EOF 
0ae2				 
0ae2				; save current address for use by higher level words etc 
0ae2			 
0ae2 22 68 fa			ld (store_openaddr),hl 
0ae5			 
0ae5 cd 66 04			call storage_read_block 
0ae8			 
0ae8				; on a continuation block, we now have the file id and ext in the middle of the block 
0ae8				; we need to pull everything back  
0ae8			 
0ae8 ed 5b 73 fa		ld de, (store_readbuf)     ; current buffer to nudge into 
0aec 2a 73 fa			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0aef 23				inc hl 
0af0 23				inc hl     ; skip id and ext 
0af1 01 40 00			ld bc, STORE_BLOCK_PHY 
0af4				if DEBUG_STORESE 
0af4					DMARK "SR<" 
0af4 f5				push af  
0af5 3a 09 0b			ld a, (.dmark)  
0af8 32 68 fe			ld (debug_mark),a  
0afb 3a 0a 0b			ld a, (.dmark+1)  
0afe 32 69 fe			ld (debug_mark+1),a  
0b01 3a 0b 0b			ld a, (.dmark+2)  
0b04 32 6a fe			ld (debug_mark+2),a  
0b07 18 03			jr .pastdmark  
0b09 ..			.dmark: db "SR<"  
0b0c f1			.pastdmark: pop af  
0b0d			endm  
# End of macro DMARK
0b0d					CALLMONITOR 
0b0d cd 6c fe			call debug_vector  
0b10				endm  
# End of macro CALLMONITOR
0b10				endif 
0b10 ed b0			ldir     ; copy data 
0b12			 
0b12				; move the pointer back and pretend we have a full buffer for next recheck 
0b12			 
0b12 1b				dec de 
0b13 1b				dec de 
0b14			 
0b14			; TODO do pop below now short circuit loop????? 
0b14 c1				pop bc     ; get rid of spare de on stack 
0b15				if DEBUG_STORESE 
0b15					DMARK "SR>" 
0b15 f5				push af  
0b16 3a 2a 0b			ld a, (.dmark)  
0b19 32 68 fe			ld (debug_mark),a  
0b1c 3a 2b 0b			ld a, (.dmark+1)  
0b1f 32 69 fe			ld (debug_mark+1),a  
0b22 3a 2c 0b			ld a, (.dmark+2)  
0b25 32 6a fe			ld (debug_mark+2),a  
0b28 18 03			jr .pastdmark  
0b2a ..			.dmark: db "SR>"  
0b2d f1			.pastdmark: pop af  
0b2e			endm  
# End of macro DMARK
0b2e					CALLMONITOR 
0b2e cd 6c fe			call debug_vector  
0b31				endm  
# End of macro CALLMONITOR
0b31				endif 
0b31 c3 c2 09			jp .srext 
0b34			 
0b34			 
0b34			 
0b34			 
0b34			 
0b34			.readdone:		 
0b34 e1				pop hl 		 ; return start of data to show as not EOF 
0b35 23				inc hl   ; past file id 
0b36 23				inc hl   ; past ext 
0b37				if DEBUG_STORESE 
0b37					DMARK "SRe" 
0b37 f5				push af  
0b38 3a 4c 0b			ld a, (.dmark)  
0b3b 32 68 fe			ld (debug_mark),a  
0b3e 3a 4d 0b			ld a, (.dmark+1)  
0b41 32 69 fe			ld (debug_mark+1),a  
0b44 3a 4e 0b			ld a, (.dmark+2)  
0b47 32 6a fe			ld (debug_mark+2),a  
0b4a 18 03			jr .pastdmark  
0b4c ..			.dmark: db "SRe"  
0b4f f1			.pastdmark: pop af  
0b50			endm  
# End of macro DMARK
0b50					CALLMONITOR 
0b50 cd 6c fe			call debug_vector  
0b53				endm  
# End of macro CALLMONITOR
0b53				endif 
0b53 c9					ret 
0b54			 
0b54			 
0b54			 
0b54			; 
0b54			; Append File 
0b54			; 
0b54			; hl - file id to locate 
0b54			; de - pointer to (multi block) string to write 
0b54			 
0b54			.sa_notfound: 
0b54 d1				pop de 
0b55 c9				ret 
0b56			 
0b56			 
0b56			storage_append: 
0b56				; hl -  file id to append to 
0b56				; de - string to append 
0b56			 
0b56 d5				push de 
0b57				 
0b57				if DEBUG_STORESE 
0b57					DMARK "AP1" 
0b57 f5				push af  
0b58 3a 6c 0b			ld a, (.dmark)  
0b5b 32 68 fe			ld (debug_mark),a  
0b5e 3a 6d 0b			ld a, (.dmark+1)  
0b61 32 69 fe			ld (debug_mark+1),a  
0b64 3a 6e 0b			ld a, (.dmark+2)  
0b67 32 6a fe			ld (debug_mark+2),a  
0b6a 18 03			jr .pastdmark  
0b6c ..			.dmark: db "AP1"  
0b6f f1			.pastdmark: pop af  
0b70			endm  
# End of macro DMARK
0b70					CALLMONITOR 
0b70 cd 6c fe			call debug_vector  
0b73				endm  
# End of macro CALLMONITOR
0b73				endif 
0b73			 
0b73 7d				ld a, l 
0b74 32 6b fa			ld (store_tmpid), a 
0b77			 
0b77				; get file header  
0b77			 
0b77 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
0b79 3a 6b fa			ld a, (store_tmpid) 
0b7c 5f				ld e, a 
0b7d			 
0b7d 21 40 00				ld hl, STORE_BLOCK_PHY 
0b80 cd 99 07				call storage_findnextid 
0b83			 
0b83 cd f9 0f			call ishlzero 
0b86 28 cc			jr z, .sa_notfound 
0b88			 
0b88 22 62 fa			ld (store_tmppageid), hl 
0b8b			 
0b8b				; TODO handle file id not found 
0b8b			 
0b8b				if DEBUG_STORESE 
0b8b					DMARK "AP2" 
0b8b f5				push af  
0b8c 3a a0 0b			ld a, (.dmark)  
0b8f 32 68 fe			ld (debug_mark),a  
0b92 3a a1 0b			ld a, (.dmark+1)  
0b95 32 69 fe			ld (debug_mark+1),a  
0b98 3a a2 0b			ld a, (.dmark+2)  
0b9b 32 6a fe			ld (debug_mark+2),a  
0b9e 18 03			jr .pastdmark  
0ba0 ..			.dmark: db "AP2"  
0ba3 f1			.pastdmark: pop af  
0ba4			endm  
# End of macro DMARK
0ba4					CALLMONITOR 
0ba4 cd 6c fe			call debug_vector  
0ba7				endm  
# End of macro CALLMONITOR
0ba7				endif 
0ba7			 
0ba7				; update file extent count 
0ba7			 
0ba7 11 77 fa			ld de, store_page 
0baa			 
0baa cd 66 04			call storage_read_block 
0bad			 
0bad				if DEBUG_STORESE 
0bad					DMARK "AP3" 
0bad f5				push af  
0bae 3a c2 0b			ld a, (.dmark)  
0bb1 32 68 fe			ld (debug_mark),a  
0bb4 3a c3 0b			ld a, (.dmark+1)  
0bb7 32 69 fe			ld (debug_mark+1),a  
0bba 3a c4 0b			ld a, (.dmark+2)  
0bbd 32 6a fe			ld (debug_mark+2),a  
0bc0 18 03			jr .pastdmark  
0bc2 ..			.dmark: db "AP3"  
0bc5 f1			.pastdmark: pop af  
0bc6			endm  
# End of macro DMARK
0bc6					CALLMONITOR 
0bc6 cd 6c fe			call debug_vector  
0bc9				endm  
# End of macro CALLMONITOR
0bc9				endif 
0bc9			;	ld (store_tmppageid), hl 
0bc9			 
0bc9 3a 79 fa			ld a, (store_page+2) 
0bcc 3c				inc a 
0bcd 32 79 fa			ld (store_page+2), a 
0bd0 32 6a fa			ld (store_tmpext), a 
0bd3				 
0bd3				if DEBUG_STORESE 
0bd3					DMARK "AP3" 
0bd3 f5				push af  
0bd4 3a e8 0b			ld a, (.dmark)  
0bd7 32 68 fe			ld (debug_mark),a  
0bda 3a e9 0b			ld a, (.dmark+1)  
0bdd 32 69 fe			ld (debug_mark+1),a  
0be0 3a ea 0b			ld a, (.dmark+2)  
0be3 32 6a fe			ld (debug_mark+2),a  
0be6 18 03			jr .pastdmark  
0be8 ..			.dmark: db "AP3"  
0beb f1			.pastdmark: pop af  
0bec			endm  
# End of macro DMARK
0bec					CALLMONITOR 
0bec cd 6c fe			call debug_vector  
0bef				endm  
# End of macro CALLMONITOR
0bef				endif 
0bef 2a 62 fa			ld hl, (store_tmppageid) 
0bf2 11 77 fa			ld de, store_page 
0bf5 cd cb 04			call storage_write_block 
0bf8			 
0bf8				; find free block 
0bf8			 
0bf8 11 00 00			ld de, 0			 ; file extent to locate 
0bfb			 
0bfb 21 40 00				ld hl, STORE_BLOCK_PHY 
0bfe cd 99 07				call storage_findnextid 
0c01 cd f9 0f			call ishlzero 
0c04 ca 54 0b			jp z, .sa_notfound 
0c07			 
0c07					; TODO handle no space left 
0c07					 
0c07 22 62 fa				ld (store_tmppageid), hl 
0c0a			 
0c0a				if DEBUG_STORESE 
0c0a					DMARK "AP4" 
0c0a f5				push af  
0c0b 3a 1f 0c			ld a, (.dmark)  
0c0e 32 68 fe			ld (debug_mark),a  
0c11 3a 20 0c			ld a, (.dmark+1)  
0c14 32 69 fe			ld (debug_mark+1),a  
0c17 3a 21 0c			ld a, (.dmark+2)  
0c1a 32 6a fe			ld (debug_mark+2),a  
0c1d 18 03			jr .pastdmark  
0c1f ..			.dmark: db "AP4"  
0c22 f1			.pastdmark: pop af  
0c23			endm  
# End of macro DMARK
0c23					CALLMONITOR 
0c23 cd 6c fe			call debug_vector  
0c26				endm  
# End of macro CALLMONITOR
0c26				endif 
0c26					; init the buffer with zeros so we can id if the buffer is full or not 
0c26			 
0c26 e5					push hl 
0c27 c5					push bc 
0c28			 
0c28 21 77 fa				ld hl, store_page 
0c2b 06 40				ld b, STORE_BLOCK_PHY 
0c2d 3e 00				ld a, 0 
0c2f 77			.zeroblock:	ld (hl), a 
0c30 23					inc hl 
0c31 10 fc				djnz .zeroblock 
0c33			 
0c33 c1					pop bc 
0c34 e1					pop hl 
0c35			 
0c35					; construct block 
0c35			 
0c35 3a 6b fa				ld a, (store_tmpid) 
0c38 32 77 fa				ld (store_page), a   ; file id 
0c3b 3a 6a fa				ld a, (store_tmpext)   ; extent for this block 
0c3e 32 78 fa				ld (store_page+1), a 
0c41			 
0c41 e1					pop hl    ; get string to write 
0c42 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0c44 11 79 fa				ld de, store_page+2 
0c47			 
0c47				if DEBUG_STORESE 
0c47					DMARK "AP5" 
0c47 f5				push af  
0c48 3a 5c 0c			ld a, (.dmark)  
0c4b 32 68 fe			ld (debug_mark),a  
0c4e 3a 5d 0c			ld a, (.dmark+1)  
0c51 32 69 fe			ld (debug_mark+1),a  
0c54 3a 5e 0c			ld a, (.dmark+2)  
0c57 32 6a fe			ld (debug_mark+2),a  
0c5a 18 03			jr .pastdmark  
0c5c ..			.dmark: db "AP5"  
0c5f f1			.pastdmark: pop af  
0c60			endm  
# End of macro DMARK
0c60					CALLMONITOR 
0c60 cd 6c fe			call debug_vector  
0c63				endm  
# End of macro CALLMONITOR
0c63				endif 
0c63			 
0c63			 
0c63			 
0c63					; fill buffer with data until end of string or full block 
0c63			 
0c63 7e			.appd:		ld a, (hl) 
0c64 12					ld (de), a 
0c65 fe 00				cp 0 
0c67 28 04				jr z, .appdone 
0c69 23					inc hl 
0c6a 13					inc de 
0c6b 10 f6				djnz .appd 
0c6d			 
0c6d e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0c6e f5					push af   		; save last byte dumped 
0c6f			 
0c6f			 
0c6f 2a 62 fa			ld hl, (store_tmppageid) 
0c72 11 77 fa			ld de, store_page 
0c75				if DEBUG_STORESE 
0c75					DMARK "AP6" 
0c75 f5				push af  
0c76 3a 8a 0c			ld a, (.dmark)  
0c79 32 68 fe			ld (debug_mark),a  
0c7c 3a 8b 0c			ld a, (.dmark+1)  
0c7f 32 69 fe			ld (debug_mark+1),a  
0c82 3a 8c 0c			ld a, (.dmark+2)  
0c85 32 6a fe			ld (debug_mark+2),a  
0c88 18 03			jr .pastdmark  
0c8a ..			.dmark: db "AP6"  
0c8d f1			.pastdmark: pop af  
0c8e			endm  
# End of macro DMARK
0c8e					CALLMONITOR 
0c8e cd 6c fe			call debug_vector  
0c91				endm  
# End of macro CALLMONITOR
0c91				endif 
0c91 cd cb 04				call storage_write_block 
0c94			 
0c94			 
0c94				; was that a full block of data written? 
0c94				; any more to write out? 
0c94			 
0c94				; if yes then set vars and jump to start of function again 
0c94			 
0c94 f1					pop af 
0c95 d1					pop de 
0c96			 
0c96 fe 00				cp 0		 ; no, string was fully written 
0c98 c8					ret z 
0c99			 
0c99					; setup vars for next cycle 
0c99			 
0c99 3a 6b fa				ld a, (store_tmpid) 
0c9c 6f					ld l, a 
0c9d 26 00				ld h, 0 
0c9f			 
0c9f c3 56 0b			 	jp storage_append	 ; yes, need to write out some more 
0ca2			 
0ca2			 
0ca2			 
0ca2			 
0ca2			 
0ca2			 
0ca2			 
0ca2			if DEBUG_STORECF 
0ca2			storageput:	 
0ca2					ret 
0ca2			storageread: 
0ca2					ld hl, store_page 
0ca2					ld b, 200 
0ca2					ld a,0 
0ca2			.src:		ld (hl),a 
0ca2					inc hl 
0ca2					djnz .src 
0ca2					 
0ca2			 
0ca2					ld de, 0 
0ca2					ld bc, 1 
0ca2					ld hl, store_page 
0ca2					call cfRead 
0ca2			 
0ca2				call cfGetError 
0ca2				ld hl,scratch 
0ca2				call hexout 
0ca2				ld hl, scratch+2 
0ca2				ld a, 0 
0ca2				ld (hl),a 
0ca2				ld de, scratch 
0ca2				ld a,display_row_1 
0ca2				call str_at_display 
0ca2				call update_display 
0ca2			 
0ca2					ld hl, store_page 
0ca2					ld (os_cur_ptr),hl 
0ca2			 
0ca2					ret 
0ca2			endif 
0ca2			 
0ca2			 
0ca2			; Clear out the main buffer store (used to remove junk before writing a new block) 
0ca2			 
0ca2			storage_clear_page: 
0ca2 e5				push hl 
0ca3 d5				push de 
0ca4 c5				push bc 
0ca5 21 77 fa			ld hl, store_page 
0ca8 3e 00			ld a, 0 
0caa 77				ld (hl), a 
0cab			 
0cab 11 78 fa			ld de, store_page+1 
0cae 01 19 01			ld bc, STORE_BLOCK_LOG+1 
0cb1			 
0cb1 ed b0			ldir 
0cb3				 
0cb3 c1				pop bc 
0cb4 d1				pop de 
0cb5 e1				pop hl 
0cb6 c9				ret 
0cb7			 
0cb7			; eof 
# End of file firmware_storage.asm
0cb7			  
0cb7			; support routines for above hardware abstraction layer  
0cb7			  
0cb7			include "firmware_general.asm"        ; general support functions  
0cb7			 
0cb7			; word look up 
0cb7			 
0cb7			; in 
0cb7			; a is the index 
0cb7			; hl is pointer start of array 
0cb7			; 
0cb7			; returns 
0cb7			; hl to the word 
0cb7			; 
0cb7			 
0cb7			table_lookup:  
0cb7 d5					push de 
0cb8 eb					ex de, hl 
0cb9			 
0cb9 6f					ld l, a 
0cba 26 00				ld h, 0 
0cbc 29					add hl, hl 
0cbd 19					add hl, de 
0cbe 7e					ld a, (hl) 
0cbf 23					inc hl 
0cc0 66					ld h,(hl) 
0cc1 6f					ld l, a 
0cc2			 
0cc2 d1					pop de 
0cc3 c9					ret 
0cc4			 
0cc4			; Delay loops 
0cc4			 
0cc4			 
0cc4			 
0cc4			aDelayInMS: 
0cc4 c5				push bc 
0cc5 47				ld b,a 
0cc6			msdelay: 
0cc6 c5				push bc 
0cc7				 
0cc7			 
0cc7 01 41 00			ld bc,041h 
0cca cd e2 0c			call delayloop 
0ccd c1				pop bc 
0cce 05				dec b 
0ccf 20 f5			jr nz,msdelay 
0cd1			 
0cd1			;if CPU_CLOCK_8MHZ 
0cd1			;msdelay8: 
0cd1			;	push bc 
0cd1			;	 
0cd1			; 
0cd1			;	ld bc,041h 
0cd1			;	call delayloop 
0cd1			;	pop bc 
0cd1			;	dec b 
0cd1			;	jr nz,msdelay8 
0cd1			;endif 
0cd1			 
0cd1			 
0cd1 c1				pop bc 
0cd2 c9				ret 
0cd3			 
0cd3			 
0cd3			delay250ms: 
0cd3				;push de 
0cd3 01 00 40			ld bc, 04000h 
0cd6 c3 e2 0c			jp delayloop 
0cd9			delay500ms: 
0cd9				;push de 
0cd9 01 00 80			ld bc, 08000h 
0cdc c3 e2 0c			jp delayloop 
0cdf			delay1s: 
0cdf				;push bc 
0cdf			   ; Clobbers A, d and e 
0cdf 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0ce2			delayloop: 
0ce2 c5			    push bc 
0ce3			 
0ce3			if BASE_CPM 
0ce3				ld bc, CPM_DELAY_TUNE 
0ce3			.cpmloop: 
0ce3				push bc 
0ce3			 
0ce3			endif 
0ce3			 
0ce3			 
0ce3			 
0ce3			delayloopi: 
0ce3			;	push bc 
0ce3			;.dl: 
0ce3 cb 47		    bit     0,a    	; 8 
0ce5 cb 47		    bit     0,a    	; 8 
0ce7 cb 47		    bit     0,a    	; 8 
0ce9 e6 ff		    and     255  	; 7 
0ceb 0b			    dec     bc      	; 6 
0cec 79			    ld      a,c     	; 4 
0ced b0			    or      b     	; 4 
0cee c2 e3 0c		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0cf1			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0cf1				;pop de 
0cf1			;pop bc 
0cf1			 
0cf1			if BASE_CPM 
0cf1				pop bc 
0cf1				 
0cf1			    dec     bc      	; 6 
0cf1			    ld      a,c     	; 4 
0cf1			    or      b     	; 4 
0cf1			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0cf1				 
0cf1			 
0cf1			endif 
0cf1			;if CPU_CLOCK_8MHZ 
0cf1			;    pop bc 
0cf1			;    push bc 
0cf1			;.dl8: 
0cf1			;    bit     0,a    	; 8 
0cf1			;    bit     0,a    	; 8 
0cf1			;    bit     0,a    	; 8 
0cf1			;    and     255  	; 7 
0cf1			;    dec     bc      	; 6 
0cf1			;    ld      a,c     	; 4 
0cf1			;    or      b     	; 4 
0cf1			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0cf1			;endif 
0cf1			 
0cf1			;if CPU_CLOCK_10MHZ 
0cf1			;    pop bc 
0cf1			;    push bc 
0cf1			;.dl8: 
0cf1			;    bit     0,a    	; 8 
0cf1			;    bit     0,a    	; 8 
0cf1			;    bit     0,a    	; 8 
0cf1			;    and     255  	; 7 
0cf1			;    dec     bc      	; 6 
0cf1			;    ld      a,c     	; 4 
0cf1			;    or      b     	; 4 
0cf1			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0cf1			;endif 
0cf1 c1			    pop bc 
0cf2			 
0cf2 c9				ret 
0cf3			 
0cf3			 
0cf3			 
0cf3			; eof 
# End of file firmware_general.asm
0cf3			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0cf3			; display routines that use the physical hardware abstraction layer 
0cf3			 
0cf3			 
0cf3			; Display an activity indicator 
0cf3			; Each call returns the new char pointed to in hl 
0cf3			 
0cf3			active: 
0cf3 3a c3 fb			ld a, (display_active) 
0cf6 fe 06			cp 6 
0cf8			 
0cf8 20 02			jr nz, .sne 
0cfa				; gone past the last one reset sequence 
0cfa 3e ff			ld a, 255 
0cfc			 
0cfc			.sne:   
0cfc				; get the next char in seq 
0cfc 3c				inc a 
0cfd 32 c3 fb			ld (display_active), a 
0d00			 
0d00				; look up the string in the table 
0d00 21 17 0d			ld hl, actseq 
0d03 cb 27			sla a 
0d05 cd d0 0f			call addatohl 
0d08 cd 33 24			call loadwordinhl 
0d0b			 
0d0b				; forth will write the to string when pushing so move from rom to ram 
0d0b			 
0d0b 11 c4 fb			ld de, display_active+1 
0d0e 01 02 00			ld bc, 2 
0d11 ed b0			ldir 
0d13			 
0d13 21 c4 fb			ld hl, display_active+1 
0d16 c9				ret 
0d17				 
0d17				 
0d17			 
0d17			 
0d17			;db "|/-\|-\" 
0d17			 
0d17			actseq: 
0d17			 
0d17 25 0d		dw spin0 
0d19 27 0d		dw spin1 
0d1b 29 0d		dw spin2 
0d1d 2b 0d		dw spin3 
0d1f 29 0d		dw spin2 
0d21 27 0d		dw spin1 
0d23 25 0d		dw spin0 
0d25			 
0d25 .. 00		spin0: db " ", 0 
0d27 .. 00		spin1: db "-", 0 
0d29 .. 00		spin2: db "+", 0 
0d2b .. 00		spin3: db "#", 0 
0d2d			 
0d2d			 
0d2d			; information window 
0d2d			 
0d2d			; pass hl with 1st string to display 
0d2d			; pass de with 2nd string to display 
0d2d			 
0d2d			info_panel: 
0d2d e5				push hl 
0d2e			 
0d2e 2a c9 fb			ld hl, (display_fb_active) 
0d31 e5				push hl    ; future de destination 
0d32 21 ae fd				ld hl, display_fb0 
0d35 22 c9 fb				ld (display_fb_active), hl 
0d38			 
0d38			;	call clear_display 
0d38			 
0d38				if BASE_CPM 
0d38				ld a, '.' 
0d38				else 
0d38 3e a5			ld a, 165 
0d3a				endif 
0d3a cd a1 0d			call fill_display 
0d3d			 
0d3d			 
0d3d 3e 55			ld a, display_row_3 + 5 
0d3f cd af 0d			call str_at_display 
0d42			 
0d42 e1				pop hl 
0d43 d1				pop de 
0d44			 
0d44 e5				push hl 
0d45			 
0d45			 
0d45 3e 2d			ld a, display_row_2 + 5 
0d47 cd af 0d			call str_at_display 
0d4a			 
0d4a			 
0d4a cd bf 0d			call update_display 
0d4d cd 7c 20			call next_page_prompt 
0d50 cd 9c 0d			call clear_display 
0d53			 
0d53				 
0d53 21 0d fd				ld hl, display_fb1 
0d56 22 c9 fb				ld (display_fb_active), hl 
0d59 cd bf 0d			call update_display 
0d5c			 
0d5c e1				pop hl 
0d5d			 
0d5d c9				ret 
0d5e			 
0d5e			 
0d5e			 
0d5e			 
0d5e			; TODO windowing? 
0d5e			 
0d5e			; TODO scroll line up 
0d5e			 
0d5e			scroll_up: 
0d5e			 
0d5e e5				push hl 
0d5f d5				push de 
0d60 c5				push bc 
0d61			 
0d61				; get frame buffer  
0d61			 
0d61 2a c9 fb			ld hl, (display_fb_active) 
0d64 e5				push hl    ; future de destination 
0d65			 
0d65 11 28 00			ld  de, display_cols 
0d68 19				add hl, de 
0d69			 
0d69 d1				pop de 
0d6a			 
0d6a				;ex de, hl 
0d6a 01 9f 00			ld bc, display_fb_len -1  
0d6d			;if DEBUG_FORTH_WORDS 
0d6d			;	DMARK "SCL" 
0d6d			;	CALLMONITOR 
0d6d			;endif	 
0d6d ed b0			ldir 
0d6f			 
0d6f				; wipe bottom row 
0d6f			 
0d6f			 
0d6f 2a c9 fb			ld hl, (display_fb_active) 
0d72 11 a0 00			ld de, display_cols*display_rows 
0d75 19				add hl, de 
0d76 06 28			ld b, display_cols 
0d78 3e 20			ld a, ' ' 
0d7a			.scwipe: 
0d7a 77				ld (hl), a 
0d7b 2b				dec hl 
0d7c 10 fc			djnz .scwipe 
0d7e			 
0d7e				;pop hl 
0d7e			 
0d7e c1				pop bc 
0d7f d1				pop de 
0d80 e1				pop hl 
0d81			 
0d81 c9				ret 
0d82			 
0d82			 
0d82			;scroll_upo: 
0d82			;	ld de, display_row_1 
0d82			 ;	ld hl, display_row_2 
0d82			;	ld bc, display_cols 
0d82			;	ldir 
0d82			;	ld de, display_row_2 
0d82			 ;	ld hl, display_row_3 
0d82			;	ld bc, display_cols 
0d82			;	ldir 
0d82			;	ld de, display_row_3 
0d82			 ;	ld hl, display_row_4 
0d82			;	ld bc, display_cols 
0d82			;	ldir 
0d82			 
0d82			; TODO clear row 4 
0d82			 
0d82			;	ret 
0d82			 
0d82				 
0d82			scroll_down: 
0d82			 
0d82 e5				push hl 
0d83 d5				push de 
0d84 c5				push bc 
0d85			 
0d85				; get frame buffer  
0d85			 
0d85 2a c9 fb			ld hl, (display_fb_active) 
0d88			 
0d88 11 9f 00			ld de, display_fb_len - 1 
0d8b 19				add hl, de 
0d8c			 
0d8c e5			push hl    ; future de destination 
0d8d			 
0d8d 11 28 00			ld  de, display_cols 
0d90 ed 52			sbc hl, de 
0d92			 
0d92			 
0d92 d1				pop de 
0d93			 
0d93			;	ex de, hl 
0d93 01 9f 00			ld bc, display_fb_len -1  
0d96			 
0d96			 
0d96				 
0d96			 
0d96 ed b0			ldir 
0d98			 
0d98				; wipe bottom row 
0d98			 
0d98			 
0d98			;	ld hl, (display_fb_active) 
0d98			;;	ld de, display_cols*display_rows 
0d98			;;	add hl, de 
0d98			;	ld b, display_cols 
0d98			;	ld a, ' ' 
0d98			;.scwiped: 
0d98			;	ld (hl), a 
0d98			;	dec hl 
0d98			;	djnz .scwiped 
0d98			 
0d98				;pop hl 
0d98			 
0d98 c1				pop bc 
0d99 d1				pop de 
0d9a e1				pop hl 
0d9b			 
0d9b c9				ret 
0d9c			;scroll_down: 
0d9c			;	ld de, display_row_4 
0d9c			;	ld hl, display_row_3 
0d9c			;	ld bc, display_cols 
0d9c			;	ldir 
0d9c			;	ld de, display_row_3 
0d9c			; 	ld hl, display_row_2 
0d9c			;	ld bc, display_cols 
0d9c			;	ldir 
0d9c			;	ld de, display_row_2 
0d9c			;	ld hl, display_row_1 
0d9c			;	ld bc, display_cols 
0d9c			;	ldir 
0d9c			;;; TODO clear row 1 
0d9c			;	ret 
0d9c			 
0d9c			 
0d9c			 
0d9c			 
0d9c			 
0d9c			; clear active frame buffer 
0d9c			 
0d9c			clear_display: 
0d9c 3e 20			ld a, ' ' 
0d9e c3 a1 0d			jp fill_display 
0da1			 
0da1			; fill active frame buffer with a char in A 
0da1			 
0da1			fill_display: 
0da1 06 a0			ld b,display_fb_len 
0da3 2a c9 fb			ld hl, (display_fb_active) 
0da6 77			.fd1:	ld (hl),a 
0da7 23				inc hl 
0da8 10 fc			djnz .fd1 
0daa 23				inc hl 
0dab 3e 00			ld a,0 
0dad 77				ld (hl),a 
0dae			 
0dae			 
0dae c9				ret 
0daf			; Write string (DE) at pos (A) to active frame buffer 
0daf			 
0daf 2a c9 fb		str_at_display:    ld hl,(display_fb_active) 
0db2 06 00					ld b,0 
0db4 4f					ld c,a 
0db5 09					add hl,bc 
0db6 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0db7 b7			            OR   A              ;Null terminator? 
0db8 c8			            RET  Z              ;Yes, so finished 
0db9 77					ld (hl),a 
0dba 23				inc hl 
0dbb 13			            INC  DE             ;Point to next character 
0dbc 18 f8		            JR   .sad1     ;Repeat 
0dbe c9					ret 
0dbf			 
0dbf			; using current frame buffer write to physical display 
0dbf			 
0dbf			update_display: 
0dbf e5				push hl 
0dc0 2a c9 fb			ld hl, (display_fb_active) 
0dc3 cd 88 76			call write_display 
0dc6 e1				pop hl 
0dc7 c9				ret 
0dc8			 
0dc8			; TODO scrolling 
0dc8			 
0dc8			 
0dc8			; move cursor right one char 
0dc8			cursor_right: 
0dc8			 
0dc8				; TODO shift right 
0dc8				; TODO if beyond max col 
0dc8				; TODO       cursor_next_line 
0dc8			 
0dc8 c9				ret 
0dc9			 
0dc9			 
0dc9			cursor_next_line: 
0dc9				; TODO first char 
0dc9				; TODO line down 
0dc9				; TODO if past last row 
0dc9				; TODO    scroll up 
0dc9			 
0dc9 c9				ret 
0dca			 
0dca			cursor_left: 
0dca				; TODO shift left 
0dca				; TODO if beyond left  
0dca				; TODO     cursor prev line 
0dca				 
0dca c9				ret 
0dcb			 
0dcb			cursor_prev_line: 
0dcb				; TODO last char 
0dcb				; TODO line up 
0dcb				; TODO if past first row 
0dcb				; TODO   scroll down 
0dcb			 
0dcb c9				ret 
0dcc			 
0dcc			 
0dcc			cout: 
0dcc				; A - char 
0dcc c9				ret 
0dcd			 
0dcd			 
0dcd			; Display a menu and allow item selection (optional toggle items) 
0dcd			; 
0dcd			; format: 
0dcd			; hl pointer to word array with zero term for items 
0dcd			; e.g.    db item1 
0dcd			;         db .... 
0dcd			;         db 0 
0dcd			; 
0dcd			; a = starting menu item  
0dcd			; 
0dcd			; de = pointer item toggle array   (todo) 
0dcd			; 
0dcd			; returns item selected in a 1-... 
0dcd			; returns 0 if back button pressed 
0dcd			; 
0dcd			; NOTE: Uses system frame buffer to display 
0dcd			; 
0dcd			; LEFT, Q = go back 
0dcd			; RIGHT, SPACE, CR = select 
0dcd			; UP, A - Up 
0dcd			; DOWN, Z - Down 
0dcd			 
0dcd			 
0dcd			 
0dcd			 
0dcd			 
0dcd			menu: 
0dcd			 
0dcd					; keep array pointer 
0dcd			 
0dcd 22 70 fa				ld (store_tmp1), hl 
0dd0 32 6e fa				ld (store_tmp2), a 
0dd3			 
0dd3					; check for key bounce 
0dd3			 
0dd3			if BASE_KEV 
0dd3			 
0dd3 cd d3 79		.mbounce:	call cin 
0dd6 fe 00				cp 0 
0dd8 20 f9				jr nz, .mbounce 
0dda			endif 
0dda					; for ease use ex 
0dda			 
0dda					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0dda 21 ae fd				ld hl, display_fb0 
0ddd 22 c9 fb				ld (display_fb_active), hl 
0de0			 
0de0 cd 9c 0d		.mloop:		call clear_display 
0de3 cd bf 0d				call update_display 
0de6			 
0de6					; draw selection id '>' at 1 
0de6			 
0de6					; init start of list display 
0de6			 
0de6 3e 05				ld a, 5 
0de8 32 6c fa				ld (store_tmp3), a   ; display row count 
0deb 3a 6e fa				ld a,( store_tmp2) 
0dee 32 6f fa				ld (store_tmp2+1), a   ; display item count 
0df1			 
0df1					 
0df1			.mitem:	 
0df1			 
0df1			 
0df1 3a 6f fa				ld a,(store_tmp2+1) 
0df4 6f					ld l, a 
0df5 26 00				ld h, 0 
0df7 29					add hl, hl 
0df8 ed 5b 70 fa			ld de, (store_tmp1) 
0dfc 19					add hl, de 
0dfd 7e					ld a, (hl) 
0dfe 23					inc hl 
0dff 66					ld h,(hl) 
0e00 6f					ld l, a 
0e01			 
0e01 cd f9 0f				call ishlzero 
0e04 28 1a				jr z, .mdone 
0e06			 
0e06 eb					ex de, hl 
0e07 3a 6c fa				ld a, (store_tmp3) 
0e0a cd af 0d				call str_at_display 
0e0d					 
0e0d			 
0e0d					; next item 
0e0d 3a 6f fa				ld a, (store_tmp2+1) 
0e10 3c					inc a 
0e11 32 6f fa				ld (store_tmp2+1), a   ; display item count 
0e14			 
0e14			 		; next row 
0e14			 
0e14 3a 6c fa				ld a, (store_tmp3) 
0e17 c6 28				add display_cols 
0e19 32 6c fa				ld (store_tmp3), a 
0e1c			 
0e1c					; at end of screen? 
0e1c			 
0e1c fe 10				cp display_rows*4 
0e1e 20 d1				jr nz, .mitem 
0e20			 
0e20			 
0e20			.mdone: 
0e20 cd f9 0f				call ishlzero 
0e23 28 08				jr z, .nodn 
0e25			 
0e25 3e 78				ld a, display_row_4 
0e27 11 a6 0e				ld de, .mdown 
0e2a cd af 0d				call str_at_display 
0e2d			 
0e2d					; draw options to fill the screens with active item on line 1 
0e2d					; if current option is 2 or more then display ^ in top 
0e2d			 
0e2d 3a 6e fa		.nodn:		ld a, (store_tmp2) 
0e30 fe 00				cp 0 
0e32 28 08				jr z, .noup 
0e34			 
0e34 3e 00				ld a, 0 
0e36 11 a4 0e				ld de, .mup 
0e39 cd af 0d				call str_at_display 
0e3c			 
0e3c 3e 02		.noup:		ld a, 2 
0e3e 11 a2 0e				ld de, .msel 
0e41 cd af 0d				call str_at_display 
0e44			 
0e44					; if current option + 1 is not null then display V in bottom 
0e44					; get key 
0e44 cd bf 0d				call update_display 
0e47			 
0e47			 
0e47					; handle key 
0e47			 
0e47 cd c2 79				call cin_wait 
0e4a			 
0e4a fe 05				cp KEY_UP 
0e4c 28 2b				jr z, .mgoup 
0e4e fe 61				cp 'a' 
0e50 28 27				jr z, .mgoup 
0e52 fe 0a				cp KEY_DOWN 
0e54 28 32				jr z, .mgod 
0e56 fe 7a				cp 'z' 
0e58 28 2e				jr z, .mgod 
0e5a fe 20				cp ' ' 
0e5c 28 34				jr z, .goend 
0e5e fe 0c				cp KEY_RIGHT 
0e60 28 30				jr z, .goend 
0e62 fe 0d				cp KEY_CR 
0e64 28 2c				jr z, .goend 
0e66 fe 71				cp 'q' 
0e68 28 0b				jr z, .goback 
0e6a			 
0e6a fe 0b				cp KEY_LEFT 
0e6c 28 07				jr z, .goback 
0e6e fe 08				cp KEY_BS 
0e70 28 03				jr z, .goback 
0e72 c3 e0 0d				jp .mloop 
0e75			 
0e75			.goback: 
0e75 3e 00			ld a, 0 
0e77 18 1d			jr .goend2 
0e79			 
0e79				; move up one 
0e79			.mgoup: 
0e79 3a 6e fa				ld a, (store_tmp2) 
0e7c fe 00				cp 0 
0e7e ca e0 0d				jp z, .mloop 
0e81 3d					dec a 
0e82 32 6e fa				ld (store_tmp2), a 
0e85 c3 e0 0d				jp .mloop 
0e88			 
0e88				; move down one 
0e88			.mgod: 
0e88 3a 6e fa				ld a, (store_tmp2) 
0e8b 3c					inc a 
0e8c 32 6e fa				ld (store_tmp2), a 
0e8f c3 e0 0d				jp .mloop 
0e92			 
0e92			 
0e92			.goend: 
0e92					; get selected item number 
0e92			 
0e92 3a 6e fa				ld a, (store_tmp2) 
0e95 3c					inc a 
0e96			 
0e96			.goend2: 
0e96 f5					push af 
0e97			 
0e97					; restore active fb 
0e97					; TODO BUG assumes fb1 
0e97			 
0e97 21 0d fd				ld hl, display_fb1 
0e9a 22 c9 fb				ld (display_fb_active), hl 
0e9d			 
0e9d					; restore main regs 
0e9d			 
0e9d			 
0e9d cd bf 0d				call update_display 
0ea0			 
0ea0 f1					pop af 
0ea1			 
0ea1 c9				ret 
0ea2			 
0ea2 .. 00		.msel:   db ">",0 
0ea4 .. 00		.mup:   db "^",0 
0ea6 .. 00		.mdown:   db "v",0 
0ea8			 
0ea8			 
0ea8			; eof 
0ea8			 
# End of file firmware_display.asm
0ea8			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0ea8			; random number generators 
0ea8			 
0ea8			 
0ea8			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0ea8			 
0ea8			 
0ea8			;-----> Generate a random number 
0ea8			; output a=answer 0<=a<=255 
0ea8			; all registers are preserved except: af 
0ea8			random: 
0ea8 e5			        push    hl 
0ea9 d5			        push    de 
0eaa 2a a8 fb		        ld      hl,(randData) 
0ead ed 5f		        ld      a,r 
0eaf 57			        ld      d,a 
0eb0 5e			        ld      e,(hl) 
0eb1 19			        add     hl,de 
0eb2 85			        add     a,l 
0eb3 ac			        xor     h 
0eb4 22 a8 fb		        ld      (randData),hl 
0eb7 d1			        pop     de 
0eb8 e1			        pop     hl 
0eb9 c9			        ret 
0eba			 
0eba			 
0eba			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0eba			 
0eba			 
0eba			 
0eba			;------LFSR------ 
0eba			;James Montelongo 
0eba			;optimized by Spencer Putt 
0eba			;out: 
0eba			; a = 8 bit random number 
0eba			RandLFSR: 
0eba 21 ae fb		        ld hl,LFSRSeed+4 
0ebd 5e			        ld e,(hl) 
0ebe 23			        inc hl 
0ebf 56			        ld d,(hl) 
0ec0 23			        inc hl 
0ec1 4e			        ld c,(hl) 
0ec2 23			        inc hl 
0ec3 7e			        ld a,(hl) 
0ec4 47			        ld b,a 
0ec5 cb 13		        rl e  
0ec7 cb 12			rl d 
0ec9 cb 11		        rl c  
0ecb 17				rla 
0ecc cb 13		        rl e  
0ece cb 12			rl d 
0ed0 cb 11		        rl c  
0ed2 17				rla 
0ed3 cb 13		        rl e  
0ed5 cb 12			rl d 
0ed7 cb 11		        rl c  
0ed9 17				rla 
0eda 67			        ld h,a 
0edb cb 13		        rl e  
0edd cb 12			rl d 
0edf cb 11		        rl c  
0ee1 17				rla 
0ee2 a8			        xor b 
0ee3 cb 13		        rl e  
0ee5 cb 12			rl d 
0ee7 ac			        xor h 
0ee8 a9			        xor c 
0ee9 aa			        xor d 
0eea 21 b0 fb		        ld hl,LFSRSeed+6 
0eed 11 b1 fb		        ld de,LFSRSeed+7 
0ef0 01 07 00		        ld bc,7 
0ef3 ed b8		        lddr 
0ef5 12			        ld (de),a 
0ef6 c9			        ret 
0ef7			 
0ef7			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0ef7			 
0ef7			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0ef7			 
0ef7			 
0ef7			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0ef7			 
0ef7			prng16: 
0ef7			;Inputs: 
0ef7			;   (seed1) contains a 16-bit seed value 
0ef7			;   (seed2) contains a NON-ZERO 16-bit seed value 
0ef7			;Outputs: 
0ef7			;   HL is the result 
0ef7			;   BC is the result of the LCG, so not that great of quality 
0ef7			;   DE is preserved 
0ef7			;Destroys: 
0ef7			;   AF 
0ef7			;cycle: 4,294,901,760 (almost 4.3 billion) 
0ef7			;160cc 
0ef7			;26 bytes 
0ef7 2a a2 fb		    ld hl,(seed1) 
0efa 44			    ld b,h 
0efb 4d			    ld c,l 
0efc 29			    add hl,hl 
0efd 29			    add hl,hl 
0efe 2c			    inc l 
0eff 09			    add hl,bc 
0f00 22 a2 fb		    ld (seed1),hl 
0f03 2a a0 fb		    ld hl,(seed2) 
0f06 29			    add hl,hl 
0f07 9f			    sbc a,a 
0f08 e6 2d		    and %00101101 
0f0a ad			    xor l 
0f0b 6f			    ld l,a 
0f0c 22 a0 fb		    ld (seed2),hl 
0f0f 09			    add hl,bc 
0f10 c9			    ret 
0f11			 
0f11			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0f11			 
0f11			rand32: 
0f11			;Inputs: 
0f11			;   (seed1_0) holds the lower 16 bits of the first seed 
0f11			;   (seed1_1) holds the upper 16 bits of the first seed 
0f11			;   (seed2_0) holds the lower 16 bits of the second seed 
0f11			;   (seed2_1) holds the upper 16 bits of the second seed 
0f11			;   **NOTE: seed2 must be non-zero 
0f11			;Outputs: 
0f11			;   HL is the result 
0f11			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0f11			;Destroys: 
0f11			;   AF 
0f11			;Tested and passes all CAcert tests 
0f11			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0f11			;it has a period of 18,446,744,069,414,584,320 
0f11			;roughly 18.4 quintillion. 
0f11			;LFSR taps: 0,2,6,7  = 11000101 
0f11			;291cc 
0f11			;seed1_0=$+1 
0f11			;    ld hl,12345 
0f11			;seed1_1=$+1 
0f11			;    ld de,6789 
0f11			;    ld b,h 
0f11			;    ld c,l 
0f11			;    add hl,hl \ rl e \ rl d 
0f11			;    add hl,hl \ rl e \ rl d 
0f11			;    inc l 
0f11			;    add hl,bc 
0f11			;    ld (seed1_0),hl 
0f11			;    ld hl,(seed1_1) 
0f11			;    adc hl,de 
0f11			;    ld (seed1_1),hl 
0f11			;    ex de,hl 
0f11			;seed2_0=$+1 
0f11			;    ld hl,9876 
0f11			;seed2_1=$+1 
0f11			;    ld bc,54321 
0f11			;    add hl,hl \ rl c \ rl b 
0f11			;    ld (seed2_1),bc 
0f11			;    sbc a,a 
0f11			;    and %11000101 
0f11			;    xor l 
0f11			;    ld l,a 
0f11			;    ld (seed2_0),hl 
0f11			;    ex de,hl 
0f11			;    add hl,bc 
0f11			;    ret 
0f11			; 
0f11			 
0f11			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0f11			; 20 bytes, 86 cycles (excluding ret) 
0f11			 
0f11			; returns   hl = pseudorandom number 
0f11			; corrupts   a 
0f11			 
0f11			; generates 16-bit pseudorandom numbers with a period of 65535 
0f11			; using the xorshift method: 
0f11			 
0f11			; hl ^= hl << 7 
0f11			; hl ^= hl >> 9 
0f11			; hl ^= hl << 8 
0f11			 
0f11			; some alternative shift triplets which also perform well are: 
0f11			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0f11			 
0f11			;  org 32768 
0f11			 
0f11			xrnd: 
0f11 2a a6 fb		  ld hl,(xrandc)       ; seed must not be 0 
0f14 3e 00		  ld a,0 
0f16 bd			  cp l 
0f17 20 02		  jr nz, .xrnd1 
0f19 2e 01		  ld l, 1 
0f1b			.xrnd1: 
0f1b			 
0f1b 7c			  ld a,h 
0f1c 1f			  rra 
0f1d 7d			  ld a,l 
0f1e 1f			  rra 
0f1f ac			  xor h 
0f20 67			  ld h,a 
0f21 7d			  ld a,l 
0f22 1f			  rra 
0f23 7c			  ld a,h 
0f24 1f			  rra 
0f25 ad			  xor l 
0f26 6f			  ld l,a 
0f27 ac			  xor h 
0f28 67			  ld h,a 
0f29			 
0f29 22 a6 fb		  ld (xrandc),hl 
0f2c			 
0f2c c9			  ret 
0f2d			;  
0f2d			 
0f2d			 
0f2d			;;;; int maths 
0f2d			 
0f2d			; https://map.grauw.nl/articles/mult_div_shifts.php 
0f2d			; Divide 16-bit values (with 16-bit result) 
0f2d			; In: Divide BC by divider DE 
0f2d			; Out: BC = result, HL = rest 
0f2d			; 
0f2d			Div16: 
0f2d 21 00 00		    ld hl,0 
0f30 78			    ld a,b 
0f31 06 08		    ld b,8 
0f33			Div16_Loop1: 
0f33 17			    rla 
0f34 ed 6a		    adc hl,hl 
0f36 ed 52		    sbc hl,de 
0f38 30 01		    jr nc,Div16_NoAdd1 
0f3a 19			    add hl,de 
0f3b			Div16_NoAdd1: 
0f3b 10 f6		    djnz Div16_Loop1 
0f3d 17			    rla 
0f3e 2f			    cpl 
0f3f 47			    ld b,a 
0f40 79			    ld a,c 
0f41 48			    ld c,b 
0f42 06 08		    ld b,8 
0f44			Div16_Loop2: 
0f44 17			    rla 
0f45 ed 6a		    adc hl,hl 
0f47 ed 52		    sbc hl,de 
0f49 30 01		    jr nc,Div16_NoAdd2 
0f4b 19			    add hl,de 
0f4c			Div16_NoAdd2: 
0f4c 10 f6		    djnz Div16_Loop2 
0f4e 17			    rla 
0f4f 2f			    cpl 
0f50 41			    ld b,c 
0f51 4f			    ld c,a 
0f52 c9			ret 
0f53			 
0f53			 
0f53			;http://z80-heaven.wikidot.com/math 
0f53			; 
0f53			;Inputs: 
0f53			;     DE and A are factors 
0f53			;Outputs: 
0f53			;     A is not changed 
0f53			;     B is 0 
0f53			;     C is not changed 
0f53			;     DE is not changed 
0f53			;     HL is the product 
0f53			;Time: 
0f53			;     342+6x 
0f53			; 
0f53			Mult16: 
0f53			 
0f53 06 08		     ld b,8          ;7           7 
0f55 21 00 00		     ld hl,0         ;10         10 
0f58 29			       add hl,hl     ;11*8       88 
0f59 07			       rlca          ;4*8        32 
0f5a 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0f5c 19			         add hl,de   ;--         -- 
0f5d 10 f9		       djnz $-5      ;13*7+8     99 
0f5f c9			ret 
0f60			 
0f60			; 
0f60			; Square root of 16-bit value 
0f60			; In:  HL = value 
0f60			; Out:  D = result (rounded down) 
0f60			; 
0f60			;Sqr16: 
0f60			;    ld de,#0040 
0f60			;    ld a,l 
0f60			;    ld l,h 
0f60			;    ld h,d 
0f60			;    or a 
0f60			;    ld b,8 
0f60			;Sqr16_Loop: 
0f60			;    sbc hl,de 
0f60			;    jr nc,Sqr16_Skip 
0f60			;    add hl,de 
0f60			;Sqr16_Skip: 
0f60			;    ccf 
0f60			;    rl d 
0f60			;    add a,a 
0f60			;    adc hl,hl 
0f60			;    add a,a 
0f60			;    adc hl,hl 
0f60			;    djnz Sqr16_Loop 
0f60			;    ret 
0f60			; 
0f60			; 
0f60			; Divide 8-bit values 
0f60			; In: Divide E by divider C 
0f60			; Out: A = result, B = rest 
0f60			; 
0f60			Div8: 
0f60 af			    xor a 
0f61 06 08		    ld b,8 
0f63			Div8_Loop: 
0f63 cb 13		    rl e 
0f65 17			    rla 
0f66 91			    sub c 
0f67 30 01		    jr nc,Div8_NoAdd 
0f69 81			    add a,c 
0f6a			Div8_NoAdd: 
0f6a 10 f7		    djnz Div8_Loop 
0f6c 47			    ld b,a 
0f6d 7b			    ld a,e 
0f6e 17			    rla 
0f6f 2f			    cpl 
0f70 c9			    ret 
0f71			 
0f71			; 
0f71			; Multiply 8-bit value with a 16-bit value (unrolled) 
0f71			; In: Multiply A with DE 
0f71			; Out: HL = result 
0f71			; 
0f71			Mult12U: 
0f71 2e 00		    ld l,0 
0f73 87			    add a,a 
0f74 30 01		    jr nc,Mult12U_NoAdd0 
0f76 19			    add hl,de 
0f77			Mult12U_NoAdd0: 
0f77 29			    add hl,hl 
0f78 87			    add a,a 
0f79 30 01		    jr nc,Mult12U_NoAdd1 
0f7b 19			    add hl,de 
0f7c			Mult12U_NoAdd1: 
0f7c 29			    add hl,hl 
0f7d 87			    add a,a 
0f7e 30 01		    jr nc,Mult12U_NoAdd2 
0f80 19			    add hl,de 
0f81			Mult12U_NoAdd2: 
0f81 29			    add hl,hl 
0f82 87			    add a,a 
0f83 30 01		    jr nc,Mult12U_NoAdd3 
0f85 19			    add hl,de 
0f86			Mult12U_NoAdd3: 
0f86 29			    add hl,hl 
0f87 87			    add a,a 
0f88 30 01		    jr nc,Mult12U_NoAdd4 
0f8a 19			    add hl,de 
0f8b			Mult12U_NoAdd4: 
0f8b 29			    add hl,hl 
0f8c 87			    add a,a 
0f8d 30 01		    jr nc,Mult12U_NoAdd5 
0f8f 19			    add hl,de 
0f90			Mult12U_NoAdd5: 
0f90 29			    add hl,hl 
0f91 87			    add a,a 
0f92 30 01		    jr nc,Mult12U_NoAdd6 
0f94 19			    add hl,de 
0f95			Mult12U_NoAdd6: 
0f95 29			    add hl,hl 
0f96 87			    add a,a 
0f97 d0			    ret nc 
0f98 19			    add hl,de 
0f99 c9			    ret 
0f9a			 
0f9a			; 
0f9a			; Multiply 8-bit value with a 16-bit value (right rotating) 
0f9a			; In: Multiply A with DE 
0f9a			;      Put lowest value in A for most efficient calculation 
0f9a			; Out: HL = result 
0f9a			; 
0f9a			Mult12R: 
0f9a 21 00 00		    ld hl,0 
0f9d			Mult12R_Loop: 
0f9d cb 3f		    srl a 
0f9f 30 01		    jr nc,Mult12R_NoAdd 
0fa1 19			    add hl,de 
0fa2			Mult12R_NoAdd: 
0fa2 cb 23		    sla e 
0fa4 cb 12		    rl d 
0fa6 b7			    or a 
0fa7 c2 9d 0f		    jp nz,Mult12R_Loop 
0faa c9			    ret 
0fab			 
0fab			; 
0fab			; Multiply 16-bit values (with 32-bit result) 
0fab			; In: Multiply BC with DE 
0fab			; Out: BCHL = result 
0fab			; 
0fab			Mult32: 
0fab 79			    ld a,c 
0fac 48			    ld c,b 
0fad 21 00 00		    ld hl,0 
0fb0 06 10		    ld b,16 
0fb2			Mult32_Loop: 
0fb2 29			    add hl,hl 
0fb3 17			    rla 
0fb4 cb 11		    rl c 
0fb6 30 07		    jr nc,Mult32_NoAdd 
0fb8 19			    add hl,de 
0fb9 ce 00		    adc a,0 
0fbb d2 bf 0f		    jp nc,Mult32_NoAdd 
0fbe 0c			    inc c 
0fbf			Mult32_NoAdd: 
0fbf 10 f1		    djnz Mult32_Loop 
0fc1 41			    ld b,c 
0fc2 4f			    ld c,a 
0fc3 c9			    ret 
0fc4			 
0fc4			 
0fc4			 
0fc4			; 
0fc4			; Multiply 8-bit values 
0fc4			; In:  Multiply H with E 
0fc4			; Out: HL = result 
0fc4			; 
0fc4			Mult8: 
0fc4 16 00		    ld d,0 
0fc6 6a			    ld l,d 
0fc7 06 08		    ld b,8 
0fc9			Mult8_Loop: 
0fc9 29			    add hl,hl 
0fca 30 01		    jr nc,Mult8_NoAdd 
0fcc 19			    add hl,de 
0fcd			Mult8_NoAdd: 
0fcd 10 fa		    djnz Mult8_Loop 
0fcf c9			    ret 
0fd0			 
0fd0			 
0fd0			 
0fd0			 
0fd0			 
0fd0			 
0fd0			 
0fd0			 
0fd0			;;http://z80-heaven.wikidot.com/math 
0fd0			;;This divides DE by BC, storing the result in DE, remainder in HL 
0fd0			; 
0fd0			;DE_Div_BC:          ;1281-2x, x is at most 16 
0fd0			;     ld a,16        ;7 
0fd0			;     ld hl,0        ;10 
0fd0			;     jp $+5         ;10 
0fd0			;.DivLoop: 
0fd0			;       add hl,bc    ;-- 
0fd0			;       dec a        ;64 
0fd0			;       jr z,.DivLoopEnd        ;86 
0fd0			; 
0fd0			;       sla e        ;128 
0fd0			;       rl d         ;128 
0fd0			;       adc hl,hl    ;240 
0fd0			;       sbc hl,bc    ;240 
0fd0			;       jr nc,.DivLoop ;23|21 
0fd0			;       inc e        ;-- 
0fd0			;       jp .DivLoop+1 
0fd0			; 
0fd0			;.DivLoopEnd: 
0fd0			 
0fd0			;HL_Div_C: 
0fd0			;Inputs: 
0fd0			;     HL is the numerator 
0fd0			;     C is the denominator 
0fd0			;Outputs: 
0fd0			;     A is the remainder 
0fd0			;     B is 0 
0fd0			;     C is not changed 
0fd0			;     DE is not changed 
0fd0			;     HL is the quotient 
0fd0			; 
0fd0			;       ld b,16 
0fd0			;       xor a 
0fd0			;         add hl,hl 
0fd0			;         rla 
0fd0			;         cp c 
0fd0			;         jr c,$+4 
0fd0			;           inc l 
0fd0			;           sub c 
0fd0			;         djnz $-7 
0fd0			 
0fd0			; https://plutiedev.com/z80-add-8bit-to-16bit 
0fd0			 
0fd0			addatohl: 
0fd0 85			    add   a, l    ; A = A+L 
0fd1 6f			    ld    l, a    ; L = A+L 
0fd2 8c			    adc   a, h    ; A = A+L+H+carry 
0fd3 95			    sub   l       ; A = H+carry 
0fd4 67			    ld    h, a    ; H = H+carry 
0fd5 c9			ret 
0fd6			 
0fd6			addatode: 
0fd6 83			    add   a, e    ; A = A+L 
0fd7 5f			    ld    e, a    ; L = A+L 
0fd8 8a			    adc   a, d    ; A = A+L+H+carry 
0fd9 93			    sub   e       ; A = H+carry 
0fda 57			    ld    d, a    ; H = H+carry 
0fdb c9			ret 
0fdc			 
0fdc			 
0fdc			addatobc: 
0fdc 81			    add   a, c    ; A = A+L 
0fdd 4f			    ld    c, a    ; L = A+L 
0fde 88			    adc   a, b    ; A = A+L+H+carry 
0fdf 91			    sub   c       ; A = H+carry 
0fe0 47			    ld    b, a    ; H = H+carry 
0fe1 c9			ret 
0fe2			 
0fe2			subafromhl: 
0fe2			   ; If A=0 do nothing 
0fe2			    ; Otherwise flip A's sign. Since 
0fe2			    ; the upper byte becomes -1, also 
0fe2			    ; substract 1 from H. 
0fe2 ed 44		    neg 
0fe4 ca ed 0f		    jp    z, Skip 
0fe7 25			    dec   h 
0fe8			     
0fe8			    ; Now add the low byte as usual 
0fe8			    ; Two's complement takes care of 
0fe8			    ; ensuring the result is correct 
0fe8 85			    add   a, l 
0fe9 6f			    ld    l, a 
0fea 8c			    adc   a, h 
0feb 95			    sub   l 
0fec 67			    ld    h, a 
0fed			Skip: 
0fed c9				ret 
0fee			 
0fee			 
0fee			; compare hl and de 
0fee			; returns:  
0fee			; if hl = de, z=1, s=0, c0=0 
0fee			; if hl > de, z=0, s=0, c=0 
0fee			; if hl < de, z=0, s=1, c=1 
0fee			cmp16:	 
0fee b7				or a 
0fef ed 52			sbc hl,de 
0ff1 e0				ret po 
0ff2 7c				ld a,h 
0ff3 1f				rra 
0ff4 ee 40			xor 01000000B 
0ff6 37				scf 
0ff7 8f				adc a,a 
0ff8 c9				ret 
0ff9			 
0ff9			 
0ff9			; test if hl contains zero   - A is destroyed 
0ff9			 
0ff9			ishlzero:    
0ff9 b7				or a     ; reset flags 
0ffa 7c				ld a, h 
0ffb b5				or l        	 
0ffc			 
0ffc c9				ret 
0ffd			 
0ffd			 
0ffd			 
0ffd			 
0ffd			if FORTH_ENABLE_FLOATMATH 
0ffd			;include "float/bbcmath.z80" 
0ffd			include "float/lpfpcalc.asm" 
0ffd			endif 
0ffd			 
0ffd			 
0ffd			; eof 
0ffd			 
# End of file firmware_maths.asm
0ffd			include "firmware_strings.asm"   ; string handling  
0ffd			 
0ffd			 
0ffd			; TODO string len 
0ffd			; input text string, end on cr with zero term 
0ffd			; a offset into frame buffer to start prompt 
0ffd			; d is max length 
0ffd			; e is display size TODO 
0ffd			; c is current cursor position 
0ffd			; hl is ptr to where string will be stored 
0ffd			 
0ffd			 
0ffd			; TODO check limit of buffer for new inserts 
0ffd			; TODO check insert does not push beyond buffer 
0ffd			; TODO scroll in a limited display area 
0ffd			; TODO scroll whole screen on page wrap 
0ffd			 
0ffd			 
0ffd			; TODO handle KEY_PREVWORD 
0ffd			; TODO handle KEY_NEXTWORD 
0ffd			; TODO handle KEY_HOME 
0ffd			; TODO handle KEY_END 
0ffd			; TODO use LCD cursor? 
0ffd			 
0ffd 32 61 fe		input_str:    	ld (input_at_pos),a      ; save display position to start 
1000 81					add c 
1001 32 5f fe				ld (input_at_cursor),a	; save draw pos of cursor 
1004 22 64 fe				ld (input_start), hl     ; save ptr to buffer 
1007 79					ld a, c 
1008 cd d0 0f				call addatohl 
100b 22 66 fe				ld (input_ptr), hl     ; save ptr to point under the cursor 
100e 7a					ld a,d 
100f 32 63 fe			        ld (input_size), a       ; save length of input area 
1012 79					ld a, c 
1013 32 52 fe				ld (input_cursor),a      ; init cursor start position  
1016 7b					ld a,e 
1017 32 62 fe			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
101a					 
101a					 
101a			 
101a			;		ld a,(input_ptr) 
101a			;		ld (input_under_cursor),a 	; save what is under the cursor 
101a			 
101a			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
101a					; init cursor shape if not set by the cin routines 
101a 21 be fb				ld hl, cursor_shape 
101d 3e ff				ld a, 255 
101f 77					ld (hl), a 
1020 23					inc hl 
1021 3e 00				ld a, 0 
1023 77					ld (hl), a 
1024			 
1024 3e 0f				ld a, CUR_BLINK_RATE 
1026 32 5d fe				ld (input_cur_flash), a 
1029 3e 01				ld a, 1 
102b 32 5c fe				ld (input_cur_onoff),a 
102e			 
102e			;	if DEBUG_INPUT 
102e			;		push af 
102e			;		ld a, 'I' 
102e			;		ld (debug_mark),a 
102e			;		pop af 
102e			;		CALLMONITOR 
102e			;	endif 
102e			.is1:		; main entry loop 
102e			 
102e			 
102e			 
102e					; pause 1ms 
102e			 
102e 3e 01				ld a, 1 
1030 cd c4 0c				call aDelayInMS 
1033			 
1033					; dec flash counter 
1033 3a 5d fe				ld a, (input_cur_flash) 
1036 3d					dec a 
1037 32 5d fe				ld (input_cur_flash), a 
103a fe 00				cp 0 
103c 20 0d				jr nz, .nochgstate 
103e			 
103e			 
103e					; change state 
103e 3a 5c fe				ld a,(input_cur_onoff) 
1041 ed 44				neg 
1043 32 5c fe				ld (input_cur_onoff),a 
1046			 
1046			 
1046					; reset on change of state 
1046 3e 0f				ld a, CUR_BLINK_RATE 
1048 32 5d fe				ld (input_cur_flash), a 
104b			 
104b			.nochgstate: 
104b					 
104b					 
104b			 
104b					; display cursor  
104b			 
104b			;		ld hl, (input_start) 
104b			;		ld a, (input_cursor) 
104b			;		call addatohl 
104b			 
104b					; get char under cursor and replace with cursor 
104b 2a 66 fe		ld hl, (input_ptr) 
104e			;		ld a, (hl) 
104e			;		ld (input_under_cursor),a 
104e			;		ld a, '_' 
104e			;		ld (hl), a 
104e			 
104e					; display string 
104e			 
104e ed 5b 64 fe			ld de, (input_start) 
1052 3a 61 fe				ld a, (input_at_pos) 
1055 cd af 0d				call str_at_display 
1058			;	        call update_display 
1058			 
1058					; find place to put the cursor 
1058			;		add h 
1058			;		ld l, display_row_1 
1058			;		sub l 
1058			; (input_at_pos) 
1058					;ld c, a 
1058			;		ld a, (input_cursor) 
1058			;		ld l, (input_at_pos) 
1058			;		;ld b, h 
1058			;		add l 
1058			;		ld (input_at_cursor),a 
1058					;ld l,h 
1058			 
1058			;		ld h, 0 
1058			;		ld l,(input_at_pos) 
1058			;		ld a, (input_cursor) 
1058			;		call addatohl 
1058			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
1058			;		call subafromhl 
1058			;		ld a,l 
1058			;		ld (input_at_cursor), a 
1058			 
1058				if DEBUG_INPUT 
1058					ld a, (hardware_diag) 
1058					cp 0 
1058					jr z, .skip_input_diag 
1058			 
1058					ld a,(input_at_pos) 
1058					ld hl, LFSRSeed 
1058					call hexout 
1058					ld a, (input_cursor) 
1058					ld hl, LFSRSeed+2 
1058					call hexout 
1058					ld a,(input_at_cursor) 
1058					ld hl, LFSRSeed+4 
1058					call hexout 
1058			 
1058					ld a,(input_cur_onoff) 
1058					ld hl, LFSRSeed+6 
1058					call hexout 
1058			 
1058					ld a,(input_cur_flash) 
1058					ld hl, LFSRSeed+8 
1058					call hexout 
1058			 
1058					ld a,(input_len) 
1058					ld hl, LFSRSeed+10 
1058					call hexout 
1058					ld hl, LFSRSeed+12 
1058					ld a, 0 
1058					ld (hl),a 
1058					ld a, display_row_4 
1058					ld de, LFSRSeed 
1058					call str_at_display 
1058					.skip_input_diag: 
1058				endif 
1058			 
1058					; decide on if we are showing the cursor this time round 
1058			 
1058 3a 5c fe				ld a, (input_cur_onoff) 
105b fe ff				cp 255 
105d 28 13				jr z, .skipcur 
105f			 
105f			 
105f 3a 5f fe				ld a,(input_at_cursor) 
1062 11 be fb				ld de, cursor_shape 
1065 cd af 0d				call str_at_display 
1068			 
1068					; save length of current input string 
1068 2a 64 fe				ld hl, (input_start) 
106b cd 2e 14				call strlenz 
106e 7d					ld a,l 
106f 32 57 fe				ld (input_len),a 
1072			 
1072			.skipcur: 
1072			 
1072 cd bf 0d			        call update_display 
1075					 
1075			 
1075			 
1075					; wait 
1075				 
1075					; TODO loop without wait to flash the cursor and char under cursor	 
1075 cd d3 79				call cin    ; _wait 
1078			 
1078 fe 00				cp 0 
107a ca 2e 10				jp z, .is1 
107d			 
107d					; get ptr to char to input into 
107d			 
107d 4f					ld c,a 
107e 2a 64 fe				ld hl, (input_start) 
1081 3a 52 fe				ld a, (input_cursor) 
1084 cd d0 0f				call addatohl 
1087 22 66 fe				ld (input_ptr), hl 
108a 79					ld a,c 
108b			 
108b					; replace char under cursor 
108b			 
108b			;		ld hl, (input_ptr) 
108b			;		ld a, (input_under_cursor) 	; get what is under the cursor 
108b			;		ld (hl), a 
108b			 
108b			;	if DEBUG_INPUT 
108b			;		push af 
108b			;		ld a, 'i' 
108b			;		ld (debug_mark),a 
108b			;		pop af 
108b			;		CALLMONITOR 
108b			;	endif 
108b fe 0e				cp KEY_HOME 
108d 20 0e				jr nz, .iske 
108f			 
108f 3a 61 fe				ld a, (input_at_pos) 
1092 32 5f fe				ld (input_at_cursor),a 
1095 3e 00				ld a, 0 
1097 32 52 fe				ld (input_cursor), a 
109a c3 2e 10				jp .is1 
109d					 
109d fe 0f		.iske:		cp KEY_END 
109f 20 03				jr nz, .isknw 
10a1 c3 2e 10				jp .is1 
10a4			 
10a4 fe 06		.isknw:		cp KEY_NEXTWORD 
10a6 20 1b				jr nz, .iskpw 
10a8			 
10a8 2a 66 fe		.isknwm:	ld hl, (input_ptr) 
10ab 7e					ld a,(hl)	 
10ac fe 00				cp 0 
10ae ca 2e 10				jp z, .is1    ; end of string 
10b1 fe 20				cp ' ' 
10b3 ca 2e 10				jp z, .is1    ; end of word 
10b6 23					inc hl 
10b7 22 66 fe				ld (input_ptr), hl 
10ba 3a 5f fe				ld a, (input_at_cursor) 
10bd 3c					inc a 
10be 32 5f fe				ld (input_at_cursor), a 
10c1 18 e5				jr .isknwm 
10c3			 
10c3 fe 07		.iskpw:		cp KEY_PREVWORD 
10c5 20 1b				jr nz, .iskl 
10c7			.iskpwm:	 
10c7 2a 66 fe				ld hl, (input_ptr) 
10ca 7e					ld a,(hl)	 
10cb fe 00				cp 0  
10cd ca 2e 10				jp z, .is1    ; end of string 
10d0 fe 20				cp ' ' 
10d2 ca 2e 10				jp z, .is1    ; end of word 
10d5 2b					dec hl 
10d6 22 66 fe				ld (input_ptr), hl 
10d9 3a 5f fe				ld a, (input_at_cursor) 
10dc 3d					dec a 
10dd 32 5f fe				ld (input_at_cursor), a 
10e0 18 e5				jr .iskpwm 
10e2			 
10e2			 
10e2 fe 0b		.iskl:		cp KEY_LEFT 
10e4 20 27				jr nz, .isk1 
10e6			 
10e6 3a 52 fe				ld a, (input_cursor) 
10e9			 
10e9 fe 00				cp 0 
10eb ca 2e 10				jp z, .is1 		; at start of line to ignore  
10ee			 
10ee 3d					dec  a 		; TODO check underflow 
10ef 32 52 fe				ld (input_cursor), a 
10f2			 
10f2 2a 66 fe				ld hl, (input_ptr) 
10f5 2b					dec hl 
10f6 22 66 fe				ld (input_ptr), hl 
10f9					 
10f9 3a 5f fe				ld a, (input_at_cursor) 
10fc 3d					dec a 
10fd 32 5f fe				ld (input_at_cursor), a 
1100			 
1100 3e 01				ld a, 1		; show cursor moving 
1102 32 5c fe				ld (input_cur_onoff),a 
1105 3e 0f				ld a, CUR_BLINK_RATE 
1107 32 5d fe				ld (input_cur_flash), a 
110a			 
110a c3 2e 10				jp .is1 
110d			 
110d fe 0c		.isk1:		cp KEY_RIGHT 
110f 20 2a				jr nz, .isk2 
1111			 
1111 3a 57 fe				ld a,(input_len)		; TODO BUG why cant i load e direct? 
1114 5f					ld e,a 
1115 3a 52 fe				ld a, (input_cursor) 
1118 bb					cp e 
1119 ca 2e 10				jp z, .is1		; at the end of string so dont go right 
111c			 
111c 3c					inc  a 		; TODO check overflow 
111d 32 52 fe				ld (input_cursor), a 
1120			 
1120 3a 5f fe				ld a, (input_at_cursor) 
1123 3c					inc a 
1124 32 5f fe				ld (input_at_cursor), a 
1127			 
1127 2a 66 fe				ld hl, (input_ptr) 
112a 23					inc hl 
112b 22 66 fe				ld (input_ptr), hl 
112e			 
112e 3e 01				ld a, 1		; show cursor moving 
1130 32 5c fe				ld (input_cur_onoff),a 
1133 3e 0f				ld a, CUR_BLINK_RATE 
1135 32 5d fe				ld (input_cur_flash), a 
1138			 
1138 c3 2e 10				jp .is1 
113b			 
113b fe 05		.isk2:		cp KEY_UP 
113d			 
113d 20 26				jr nz, .isk3 
113f			 
113f					; swap last command with the current on 
113f			 
113f					; move cursor to start of string 
113f 2a 64 fe				ld hl, (input_start) 
1142 22 66 fe				ld (input_ptr), hl 
1145			 
1145 3a 61 fe				ld a, (input_at_pos) 
1148 32 5f fe				ld (input_at_cursor), a 
114b			 
114b 3e 00				ld a, 0 
114d 32 52 fe				ld (input_cursor), a 
1150					 
1150					; swap input and last command buffers 
1150			 
1150 21 e5 f4				ld hl, os_cli_cmd 
1153 11 e4 f5				ld de, os_last_cmd 
1156 06 ff				ld b, 255 
1158 7e			.swap1:		ld a, (hl) 
1159 4f					ld c,a 
115a 1a					ld a, (de) 
115b 77					ld (hl), a 
115c 79					ld a,c 
115d 12					ld (de),a 
115e 23					inc hl 
115f 13					inc de 
1160 10 f6				djnz .swap1 
1162			 
1162			 
1162			 
1162			 
1162			 
1162 c3 2e 10				jp .is1 
1165			 
1165 fe 08		.isk3:		cp KEY_BS 
1167 20 3c				jr nz, .isk4 
1169			 
1169 3a 52 fe				ld a, (input_cursor) 
116c			 
116c fe 00				cp 0 
116e ca 2e 10				jp z, .is1 		; at start of line to ignore  
1171			 
1171 3d					dec  a 		; TODO check underflow 
1172 32 52 fe				ld (input_cursor), a 
1175			 
1175					; hl is source 
1175					; de needs to be source - 1 
1175			 
1175			;		ld a, 0 
1175			;		dec hl 
1175			;		ld (hl), a 
1175			 
1175 2a 66 fe				ld hl, (input_ptr) 
1178 2b					dec hl 
1179 22 66 fe				ld (input_ptr), hl 
117c			 
117c					; shift all data 
117c			 
117c e5					push hl 
117d 23					inc hl 
117e d1					pop de 
117f 3a 57 fe				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
1182 4f					ld c,a 
1183 06 00				ld b,0 
1185 ed b0				ldir  
1187			 
1187			 
1187			 
1187			 
1187 3a 5f fe				ld a, (input_at_cursor) 
118a 3d					dec a 
118b 32 5f fe				ld (input_at_cursor), a 
118e			 
118e			 
118e 3e 01				ld a, 1		; show cursor moving 
1190 32 5c fe				ld (input_cur_onoff),a 
1193 3e 0f				ld a, CUR_BLINK_RATE 
1195 32 5d fe				ld (input_cur_flash), a 
1198			 
1198					; remove char 
1198 3a 5f fe				ld a, (input_at_cursor) 
119b 3c					inc a 
119c 11 26 12				ld de,.iblank 
119f cd af 0d				call str_at_display 
11a2			 
11a2 c3 2e 10				jp .is1 
11a5			 
11a5 fe 0d		.isk4:		cp KEY_CR 
11a7 28 6c				jr z, .endinput 
11a9			 
11a9					; else add the key press to the end 
11a9			 
11a9 4f					ld c, a			; save key pressed 
11aa			 
11aa 7e					ld a,(hl)		; get what is currently under char 
11ab			 
11ab fe 00				cp 0			; we are at the end of the string 
11ad 20 2f				jr nz, .onchar 
11af					 
11af					; add a char to the end of the string 
11af				 
11af 71					ld (hl),c 
11b0 23					inc hl 
11b1			;		ld a,' ' 
11b1			;		ld (hl),a 
11b1			;		inc hl 
11b1 3e 00				ld a,0 
11b3 77					ld (hl),a 
11b4 2b					dec hl 
11b5			 
11b5 3a 52 fe				ld a, (input_cursor) 
11b8 3c					inc a				; TODO check max string length and scroll  
11b9 32 52 fe				ld (input_cursor), a		; inc cursor pos 
11bc							 
11bc 3a 5f fe				ld a, (input_at_cursor) 
11bf 3c					inc a 
11c0 32 5f fe				ld (input_at_cursor), a 
11c3			 
11c3 2a 66 fe				ld hl, (input_ptr) 
11c6 23					inc hl 
11c7 22 66 fe				ld (input_ptr), hl 
11ca			 
11ca 2a 66 fe				ld hl, (input_ptr) 
11cd 23					inc hl 
11ce 22 66 fe				ld (input_ptr), hl 
11d1			;	if DEBUG_INPUT 
11d1			;		push af 
11d1			;		ld a, '+' 
11d1			;		ld (debug_mark),a 
11d1			;		pop af 
11d1			;		CALLMONITOR 
11d1			;	endif 
11d1 3e 01				ld a, 1		; show cursor moving 
11d3 32 5c fe				ld (input_cur_onoff),a 
11d6 3e 0f				ld a, CUR_BLINK_RATE 
11d8 32 5d fe				ld (input_cur_flash), a 
11db c3 2e 10				jp .is1 
11de					 
11de			 
11de			 
11de					; if on a char then insert 
11de			.onchar: 
11de			 
11de					; TODO over flow check: make sure insert does not blow out buffer 
11de			 
11de					; need to do some maths to use lddr 
11de			 
11de e5					push hl   ; save char pos 
11df c5					push bc 
11e0			 
11e0 2a 64 fe				ld hl, (input_start) 
11e3 3a 57 fe				ld a, (input_len) 
11e6 cd d0 0f				call addatohl  		; end of string 
11e9 23					inc hl 
11ea 23					inc hl		; past zero term 
11eb e5					push hl 
11ec 23					inc hl 
11ed e5					push hl  
11ee			 
11ee								; start and end of lddr set, now how much to move? 
11ee			 
11ee							 
11ee 3a 52 fe				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
11f1 47					ld b,a 
11f2 3a 57 fe				ld a,(input_len) 
11f5 5f					ld e,a 
11f6 90					sub b 
11f7 3c					inc a		;?? 
11f8 3c					inc a		;?? 
11f9 3c					inc a		;?? 
11fa			 
11fa 06 00				ld b,0 
11fc 4f					ld c,a 
11fd			 
11fd				if DEBUG_INPUT 
11fd					push af 
11fd					ld a, 'i' 
11fd					ld (debug_mark),a 
11fd					pop af 
11fd			;		CALLMONITOR 
11fd				endif 
11fd d1					pop de 
11fe e1					pop hl 
11ff				if DEBUG_INPUT 
11ff					push af 
11ff					ld a, 'I' 
11ff					ld (debug_mark),a 
11ff					pop af 
11ff			;		CALLMONITOR 
11ff				endif 
11ff ed b8				lddr 
1201				 
1201			 
1201			 
1201					; TODO have a key for insert/overwrite mode???? 
1201 c1					pop bc 
1202 e1					pop hl 
1203 71					ld (hl), c		; otherwise overwrite current char 
1204					 
1204			 
1204			 
1204			 
1204 3a 52 fe				ld a, (input_cursor) 
1207 3c					inc  a 		; TODO check overflow 
1208 32 52 fe				ld (input_cursor), a 
120b			 
120b 3a 5f fe				ld a, (input_at_cursor) 
120e 3c					inc a 
120f 32 5f fe				ld (input_at_cursor), a 
1212			 
1212 c3 2e 10				jp .is1 
1215			 
1215			.endinput:	; TODO look for end of string 
1215			 
1215					; add trailing space for end of token 
1215			 
1215 2a 64 fe				ld hl, (input_start) 
1218 3a 57 fe				ld a,(input_len) 
121b cd d0 0f				call addatohl 
121e 3e 20				ld a, ' ' 
1220 77					ld (hl),a 
1221					; TODO eof of parse marker 
1221			 
1221 23					inc hl 
1222 3e 00				ld a, 0 
1224 77					ld (hl),a 
1225			 
1225			 
1225 c9					ret 
1226			 
1226 .. 00		.iblank: db " ",0 
1228			 
1228			 
1228 32 61 fe		input_str_prev:	ld (input_at_pos), a 
122b 22 64 fe				ld (input_start), hl 
122e 3e 01				ld a,1			; add cursor 
1230 77					ld (hl),a 
1231 23					inc hl 
1232 3e 00				ld a,0 
1234 77					ld (hl),a 
1235 22 66 fe				ld (input_ptr), hl 
1238 7a					ld a,d 
1239 32 63 fe				ld (input_size), a 
123c 3e 00				ld a,0 
123e 32 52 fe				ld (input_cursor),a 
1241			.instr1:	 
1241			 
1241					; TODO do block cursor 
1241					; TODO switch cursor depending on the modifer key 
1241			 
1241					; update cursor shape change on key hold 
1241			 
1241 2a 66 fe				ld hl, (input_ptr) 
1244 2b					dec hl 
1245 3a be fb				ld a,(cursor_shape) 
1248 77					ld (hl), a 
1249			 
1249					; display entered text 
1249 3a 61 fe				ld a,(input_at_pos) 
124c cd 97 77		            	CALL fLCD_Pos       ;Position cursor to location in A 
124f ed 5b 64 fe	            	LD   de, (input_start) 
1253 cd b9 77		            	CALL fLCD_Str       ;Display string pointed to by DE 
1256			 
1256 cd d3 79				call cin 
1259 fe 00				cp 0 
125b 28 e4				jr z, .instr1 
125d			 
125d					; proecess keyboard controls first 
125d			 
125d 2a 66 fe				ld hl,(input_ptr) 
1260			 
1260 fe 0d				cp KEY_CR	 ; pressing enter ends input 
1262 28 5a				jr z, .instrcr 
1264			 
1264 fe 08				cp KEY_BS 	; back space 
1266 20 0f				jr nz, .instr2 
1268					; process back space 
1268			 
1268					; TODO stop back space if at start of string 
1268 2b					dec hl 
1269 2b					dec hl ; to over write cursor 
126a 3a be fb				ld a,(cursor_shape) 
126d					;ld a,0 
126d 77					ld (hl),a 
126e 23					inc hl 
126f 3e 20				ld a," " 
1271 77					ld (hl),a 
1272 22 66 fe				ld (input_ptr),hl 
1275					 
1275			 
1275 18 ca				jr .instr1 
1277			 
1277 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
1279 20 06				jr nz, .instr3 
127b 2b					dec hl 
127c 22 66 fe				ld (input_ptr),hl 
127f 18 c0				jr .instr1 
1281				 
1281 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
1283 20 06				jr nz, .instr4 
1285 23					inc hl 
1286 22 66 fe				ld (input_ptr),hl 
1289 18 b6				jr .instr1 
128b			 
128b fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
128d 20 06				jr nz, .instr5 
128f 2b					dec hl 
1290 22 66 fe				ld (input_ptr),hl 
1293 18 ac				jr .instr1 
1295			 
1295 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
1297 20 06				jr nz, .instr6 
1299 2b					dec hl 
129a 22 66 fe				ld (input_ptr),hl 
129d 18 a2				jr .instr1 
129f fe 05		.instr6:        cp KEY_UP      ; recall last command 
12a1 20 0b				jr nz, .instrnew 
12a3			 
12a3 21 be f1			ld hl, scratch 
12a6 11 e4 f5			ld de, os_last_cmd 
12a9 cd c7 12			call strcpy 
12ac 18 93				jr .instr1 
12ae			 
12ae			 
12ae			.instrnew:	; no special key pressed to see if we have room to store it 
12ae			 
12ae					; TODO do string size test 
12ae			 
12ae 2b					dec hl ; to over write cursor 
12af 77					ld (hl),a 
12b0 23					inc hl 
12b1 3a be fb				ld a,(cursor_shape) 
12b4 77					ld (hl),a 
12b5 23					inc hl 
12b6 3e 00				ld a,0 
12b8 77					ld (hl),a 
12b9			 
12b9 22 66 fe				ld (input_ptr),hl 
12bc					 
12bc 18 83				jr .instr1 
12be 2b			.instrcr:	dec hl		; remove cursor 
12bf 3e 20				ld a,' '	; TODO add a trailing space for safety 
12c1 77					ld (hl),a 
12c2 23					inc hl 
12c3 3e 00				ld a,0 
12c5 77					ld (hl),a 
12c6			 
12c6			 
12c6					; if at end of line scroll up    
12c6					; TODO detecting only end of line 4 for scroll up  
12c6			 
12c6					;ld   
12c6			 
12c6 c9					ret 
12c7			 
12c7			 
12c7			; strcpy hl = dest, de source 
12c7			 
12c7 1a			strcpy:   LD   A, (DE)        ;Get character from string 
12c8 b7			            OR   A              ;Null terminator? 
12c9 c8			            RET  Z              ;Yes, so finished 
12ca 1a					ld a,(de) 
12cb 77					ld (hl),a 
12cc 13			            INC  DE             ;Point to next character 
12cd 23					inc hl 
12ce 18 f7		            JR   strcpy       ;Repeat 
12d0 c9					ret 
12d1			 
12d1			 
12d1			; TODO string_at  
12d1			; pass string which starts with lcd offset address and then null term string 
12d1			 
12d1			; TODO string to dec 
12d1			; TODO string to hex 
12d1			; TODO byte to string hex 
12d1			; TODO byte to string dec 
12d1			 
12d1			 
12d1			 
12d1			; from z80uartmonitor 
12d1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
12d1			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
12d1			; pass hl for where to put the text 
12d1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
12d1 c5			hexout:	PUSH BC 
12d2 f5					PUSH AF 
12d3 47					LD B, A 
12d4					; Upper nybble 
12d4 cb 3f				SRL A 
12d6 cb 3f				SRL A 
12d8 cb 3f				SRL A 
12da cb 3f				SRL A 
12dc cd ec 12				CALL tohex 
12df 77					ld (hl),a 
12e0 23					inc hl	 
12e1					 
12e1					; Lower nybble 
12e1 78					LD A, B 
12e2 e6 0f				AND 0FH 
12e4 cd ec 12				CALL tohex 
12e7 77					ld (hl),a 
12e8 23					inc hl	 
12e9					 
12e9 f1					POP AF 
12ea c1					POP BC 
12eb c9					RET 
12ec					 
12ec			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
12ec			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
12ec			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
12ec			tohex: 
12ec e5					PUSH HL 
12ed d5					PUSH DE 
12ee 16 00				LD D, 0 
12f0 5f					LD E, A 
12f1 21 f9 12				LD HL, .DATA 
12f4 19					ADD HL, DE 
12f5 7e					LD A, (HL) 
12f6 d1					POP DE 
12f7 e1					POP HL 
12f8 c9					RET 
12f9			 
12f9			.DATA: 
12f9 30					DEFB	30h	; 0 
12fa 31					DEFB	31h	; 1 
12fb 32					DEFB	32h	; 2 
12fc 33					DEFB	33h	; 3 
12fd 34					DEFB	34h	; 4 
12fe 35					DEFB	35h	; 5 
12ff 36					DEFB	36h	; 6 
1300 37					DEFB	37h	; 7 
1301 38					DEFB	38h	; 8 
1302 39					DEFB	39h	; 9 
1303 41					DEFB	41h	; A 
1304 42					DEFB	42h	; B 
1305 43					DEFB	43h	; C 
1306 44					DEFB	44h	; D 
1307 45					DEFB	45h	; E 
1308 46					DEFB	46h	; F 
1309			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1309			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1309			;;    subtract $30, if result > 9 then subtract $7 more 
1309			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1309			atohex: 
1309 d6 30				SUB $30 
130b fe 0a				CP 10 
130d f8					RET M		; If result negative it was 0-9 so we're done 
130e d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
1310 c9					RET		 
1311			 
1311			 
1311			 
1311			 
1311			; Get 2 ASCII characters as hex byte from pointer in hl 
1311			 
1311			BYTERD: 
1311 16 00			LD	D,00h		;Set up 
1313 cd 1b 13			CALL	HEXCON		;Get byte and convert to hex 
1316 87				ADD	A,A		;First nibble so 
1317 87				ADD	A,A		;multiply by 16 
1318 87				ADD	A,A		; 
1319 87				ADD	A,A		; 
131a 57				LD	D,A		;Save hi nibble in D 
131b			HEXCON: 
131b 7e				ld a, (hl)		;Get next chr 
131c 23				inc hl 
131d d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
131f fe 0a			CP	00Ah		;Is it 0-9 ? 
1321 38 02			JR	C,NALPHA	;If so miss next bit 
1323 d6 07			SUB	007h		;Else convert alpha 
1325			NALPHA: 
1325 b2				OR	D		;Add hi nibble back 
1326 c9				RET			; 
1327			 
1327			 
1327			; 
1327			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
1327			; Since the routines get_byte and therefore get_nibble are called, only valid 
1327			; characters (0-9a-f) are accepted. 
1327			; 
1327			;get_word        push    af 
1327			;                call    get_byte        ; Get the upper byte 
1327			;                ld      h, a 
1327			;                call    get_byte        ; Get the lower byte 
1327			;                ld      l, a 
1327			;                pop     af 
1327			;                ret 
1327			; 
1327			; Get a byte in hexadecimal notation. The result is returned in A. Since 
1327			; the routine get_nibble is used only valid characters are accepted - the  
1327			; input routine only accepts characters 0-9a-f. 
1327			; 
1327 c5			get_byte:        push    bc              ; Save contents of B (and C) 
1328 7e					ld a,(hl) 
1329 23					inc hl 
132a cd 4f 13		                call    nibble2val      ; Get upper nibble 
132d cb 07		                rlc     a 
132f cb 07		                rlc     a 
1331 cb 07		                rlc     a 
1333 cb 07		                rlc     a 
1335 47			                ld      b, a            ; Save upper four bits 
1336 7e					ld a,(hl) 
1337 cd 4f 13		                call    nibble2val      ; Get lower nibble 
133a b0			                or      b               ; Combine both nibbles 
133b c1			                pop     bc              ; Restore B (and C) 
133c c9			                ret 
133d			; 
133d			; Get a hexadecimal digit from the serial line. This routine blocks until 
133d			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
133d			; to the serial line interface. The lower 4 bits of A contain the value of  
133d			; that particular digit. 
133d			; 
133d			;get_nibble      ld a,(hl)           ; Read a character 
133d			;                call    to_upper        ; Convert to upper case 
133d			;                call    is_hex          ; Was it a hex digit? 
133d			;                jr      nc, get_nibble  ; No, get another character 
133d			 ;               call    nibble2val      ; Convert nibble to value 
133d			 ;               call    print_nibble 
133d			 ;               ret 
133d			; 
133d			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
133d			; A valid hexadecimal digit is denoted by a set C flag. 
133d			; 
133d			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
133d			;                ret     nc              ; Yes 
133d			;                cp      '0'             ; Less than '0'? 
133d			;                jr      nc, is_hex_1    ; No, continue 
133d			;                ccf                     ; Complement carry (i.e. clear it) 
133d			;                ret 
133d			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
133d			;                ret     c               ; Yes 
133d			;                cp      'A'             ; Less than 'A'? 
133d			;                jr      nc, is_hex_2    ; No, continue 
133d			;                ccf                     ; Yes - clear carry and return 
133d			;                ret 
133d			;is_hex_2        scf                     ; Set carry 
133d			;                ret 
133d			; 
133d			; Convert a single character contained in A to upper case: 
133d			; 
133d fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
133f d8			                ret     c 
1340 fe 7b		                cp      'z' + 1         ; > 'z'? 
1342 d0			                ret     nc              ; Nothing to do, either 
1343 e6 5f		                and     $5f             ; Convert to upper case 
1345 c9			                ret 
1346			 
1346			 
1346			to_lower: 
1346			 
1346			   ; if char is in [A-Z] make it lower case 
1346			 
1346			   ; enter : a = char 
1346			   ; exit  : a = lower case char 
1346			   ; uses  : af 
1346			 
1346 fe 41		   cp 'A' 
1348 d8			   ret c 
1349			    
1349 fe 5b		   cp 'Z'+1 
134b d0			   ret nc 
134c			    
134c f6 20		   or $20 
134e c9			   ret 
134f			 
134f			; 
134f			; Expects a hexadecimal digit (upper case!) in A and returns the 
134f			; corresponding value in A. 
134f			; 
134f fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
1351 38 02		                jr      c, nibble2val_1 ; Yes 
1353 d6 07		                sub     7               ; Adjust for A-F 
1355 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
1357 e6 0f		                and     $f              ; Only return lower 4 bits 
1359 c9			                ret 
135a			; 
135a			; Print_nibble prints a single hex nibble which is contained in the lower  
135a			; four bits of A: 
135a			; 
135a			;print_nibble    push    af              ; We won't destroy the contents of A 
135a			;                and     $f              ; Just in case... 
135a			;                add     a, '0'             ; If we have a digit we are done here. 
135a			;                cp      '9' + 1         ; Is the result > 9? 
135a			;                jr      c, print_nibble_1 
135a			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
135a			;print_nibble_1  call    putc            ; Print the nibble and 
135a			;                pop     af              ; restore the original value of A 
135a			;                ret 
135a			;; 
135a			;; Send a CR/LF pair: 
135a			; 
135a			;crlf            push    af 
135a			;                ld      a, cr 
135a			;                call    putc 
135a			;                ld      a, lf 
135a			;                call    putc 
135a			;                pop     af 
135a			;                ret 
135a			; 
135a			; Print_word prints the four hex digits of a word to the serial line. The  
135a			; word is expected to be in HL. 
135a			; 
135a			;print_word      push    hl 
135a			;                push    af 
135a			;                ld      a, h 
135a			;                call    print_byte 
135a			;                ld      a, l 
135a			;                call    print_byte 
135a			;                pop     af 
135a			;                pop     hl 
135a			;                ret 
135a			; 
135a			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
135a			; The byte to be printed is expected to be in A. 
135a			; 
135a			;print_byte      push    af              ; Save the contents of the registers 
135a			;                push    bc 
135a			;                ld      b, a 
135a			;                rrca 
135a			;                rrca 
135a			;                rrca 
135a			;                rrca 
135a			;                call    print_nibble    ; Print high nibble 
135a			;                ld      a, b 
135a			;                call    print_nibble    ; Print low nibble 
135a			;                pop     bc              ; Restore original register contents 
135a			;                pop     af 
135a			;                ret 
135a			 
135a			 
135a			 
135a			 
135a			 
135a			fourehexhl:  
135a 7e				ld a,(hl) 
135b cd 09 13			call atohex 
135e cb 3f				SRL A 
1360 cb 3f				SRL A 
1362 cb 3f				SRL A 
1364 cb 3f				SRL A 
1366 47				ld b, a 
1367 23				inc hl 
1368 7e				ld a,(hl) 
1369 23				inc hl 
136a cd 09 13			call atohex 
136d 80				add b 
136e 57				ld d,a 
136f 7e				ld a,(hl) 
1370 cd 09 13			call atohex 
1373 cb 3f				SRL A 
1375 cb 3f				SRL A 
1377 cb 3f				SRL A 
1379 cb 3f				SRL A 
137b 47				ld b, a 
137c 23				inc hl 
137d 7e				ld a,(hl) 
137e 23				inc hl 
137f cd 09 13			call atohex 
1382 80				add b 
1383 5f				ld e, a 
1384 d5				push de 
1385 e1				pop hl 
1386 c9				ret 
1387			 
1387			; pass hl. returns z set if the byte at hl is a digit 
1387			;isdigithl:  
1387			;	push bc 
1387			;	ld a,(hl) 
1387			;	cp ':' 
1387			;	jr nc, .isdf 		; > 
1387			;	cp '0' 
1387			;	jr c, .isdf		; < 
1387			; 
1387			;	; TODO find a better way to set z 
1387			; 
1387			;	ld b,a 
1387			;	cp b 
1387			;	pop bc 
1387			;	ret 
1387			; 
1387			;.isdf:	; not digit so clear z 
1387			; 
1387			;	; TODO find a better way to unset z 
1387			; 
1387			;	ld b,a 
1387			;	inc b 
1387			;	cp b 
1387			; 
1387			;	pop bc 
1387			;	ret 
1387				 
1387				 
1387			 
1387			 
1387			; pass hl as the four byte address to load 
1387			 
1387			get_word_hl:  
1387 e5				push hl 
1388 cd 27 13			call get_byte 
138b				 
138b 47				ld b, a 
138c			 
138c e1				pop hl 
138d 23				inc hl 
138e 23				inc hl 
138f			 
138f			; TODO not able to handle a-f  
138f 7e				ld a,(hl) 
1390			;	;cp ':' 
1390			;	cp 'g' 
1390			;	jr nc, .single_byte_hl 		; > 
1390			;	cp 'G' 
1390			;	jr nc, .single_byte_hl 		; > 
1390			;	cp '0' 
1390			;	jr c, .single_byte_hl		; < 
1390			 
1390				;call isdigithl 
1390 fe 00			cp 0 
1392 28 06			jr z, .single_byte_hl 
1394			 
1394			.getwhln:   ; hex word so get next byte 
1394			 
1394 cd 27 13			call get_byte 
1397 6f				ld l, a 
1398 60				ld h,b 
1399 c9				ret 
139a 68			.single_byte_hl:   ld l,b 
139b 26 00				ld h,0 
139d c9					ret 
139e			 
139e			 
139e			 
139e			 
139e 21 f3 1d			ld hl,asc+1 
13a1			;	ld a, (hl) 
13a1			;	call nibble2val 
13a1 cd 27 13			call get_byte 
13a4			 
13a4			;	call fourehexhl 
13a4 32 f2 f1			ld (scratch+52),a 
13a7				 
13a7 21 f0 f1			ld hl,scratch+50 
13aa 22 e1 f4			ld (os_cur_ptr),hl 
13ad			 
13ad c9				ret 
13ae			 
13ae			 
13ae			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
13ae			 
13ae			; Decimal Unsigned Version 
13ae			 
13ae			;Number in a to decimal ASCII 
13ae			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
13ae			;Example: display a=56 as "056" 
13ae			;input: a = number 
13ae			;Output: a=0,value of a in the screen 
13ae			;destroys af,bc (don't know about hl and de) 
13ae			DispAToASCII: 
13ae 0e 9c			ld	c,-100 
13b0 cd ba 13			call	.Na1 
13b3 0e f6			ld	c,-10 
13b5 cd ba 13			call	.Na1 
13b8 0e ff			ld	c,-1 
13ba 06 2f		.Na1:	ld	b,'0'-1 
13bc 04			.Na2:	inc	b 
13bd 81				add	a,c 
13be 38 fc			jr	c,.Na2 
13c0 91				sub	c		;works as add 100/10/1 
13c1 f5				push af		;safer than ld c,a 
13c2 78				ld	a,b		;char is in b 
13c3			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
13c3 f1				pop af		;safer than ld a,c 
13c4 c9				ret 
13c5			 
13c5			; Decimal Signed Version 
13c5			 
13c5			; DispA 
13c5			; -------------------------------------------------------------- 
13c5			; Converts a signed integer value to a zero-terminated ASCII 
13c5			; string representative of that value (using radix 10). 
13c5			; -------------------------------------------------------------- 
13c5			; INPUTS: 
13c5			;     HL     Value to convert (two's complement integer). 
13c5			;     DE     Base address of string destination. (pointer). 
13c5			; -------------------------------------------------------------- 
13c5			; OUTPUTS: 
13c5			;     None 
13c5			; -------------------------------------------------------------- 
13c5			; REGISTERS/MEMORY DESTROYED 
13c5			; AF HL 
13c5			; -------------------------------------------------------------- 
13c5			 
13c5			;DispHLToASCII: 
13c5			;   push    de 
13c5			;   push    bc 
13c5			; 
13c5			;; Detect sign of HL. 
13c5			;    bit    7, h 
13c5			;    jr     z, ._DoConvert 
13c5			; 
13c5			;; HL is negative. Output '-' to string and negate HL. 
13c5			;    ld     a, '-' 
13c5			;    ld     (de), a 
13c5			;    inc    de 
13c5			; 
13c5			;; Negate HL (using two's complement) 
13c5			;    xor    a 
13c5			;    sub    l 
13c5			;    ld     l, a 
13c5			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
13c5			;    sbc    a, h 
13c5			;    ld     h, a 
13c5			; 
13c5			;; Convert HL to digit characters 
13c5			;._DoConvert: 
13c5			;    ld     b, 0     ; B will count character length of number 
13c5			;-   ld     a, 10 
13c5			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
13c5			;    push   af 
13c5			;    inc    b 
13c5			;    ld     a, h 
13c5			;    or     l 
13c5			;    jr     nz, - 
13c5			; 
13c5			;; Retrieve digits from stack 
13c5			;-   pop    af 
13c5			;    or     $30 
13c5			;    ld     (de), a 
13c5			;    inc    de 
13c5			;    djnz   - 
13c5			; 
13c5			;; Terminate string with NULL 
13c5			;    xor    a 
13c5			;    ld     (de), a 
13c5			; 
13c5			;    pop    bc 
13c5			;    pop    de 
13c5			;    ret 
13c5			 
13c5			;Comments 
13c5			; 
13c5			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
13c5			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
13c5			;    Note that the output string will not be fixed-width. 
13c5			; 
13c5			;Example Usage 
13c5			; 
13c5			;    ld    hl, -1004 
13c5			;    ld    de, OP1 
13c5			;    call  DispA 
13c5			;    ld    hl, OP1 
13c5			;    syscall  PutS 
13c5			 
13c5			 
13c5			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
13c5			 
13c5			 
13c5			;Converts an ASCII string to an unsigned 16-bit integer 
13c5			;Quits when it reaches a non-decimal digit 
13c5			 
13c5			string_to_uint16: 
13c5			atoui_16: 
13c5			;Input: 
13c5			;     DE points to the string 
13c5			;Outputs: 
13c5			;     HL is the result 
13c5			;     A is the 8-bit value of the number 
13c5			;     DE points to the byte after the number 
13c5			;Destroys: 
13c5			;     BC 
13c5			;       if the string is non-empty, BC is HL/10 
13c5			;Size:  24 bytes 
13c5			;Speed: 42+d(104+{0,9}) 
13c5			;       d is the number of digits in the number 
13c5			;       max is 640 cycles for a 5 digit number 
13c5			;Assuming no leading zeros: 
13c5			;1 digit:  146cc 
13c5			;2 digit:  250cc 
13c5			;3 digit:  354cc or 363cc (avg: 354.126cc) 
13c5			;4 digit:  458cc or 467cc (avg: 458.27cc) 
13c5			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
13c5			;avg: 544.81158447265625cc (544+13297/16384) 
13c5			;=============================================================== 
13c5 21 00 00		  ld hl,0 
13c8			.u16a: 
13c8 1a			  ld a,(de) 
13c9 d6 30		  sub 30h 
13cb fe 0a		  cp 10 
13cd d0			  ret nc 
13ce 13			  inc de 
13cf 44			  ld b,h 
13d0 4d			  ld c,l 
13d1 29			  add hl,hl 
13d2 29			  add hl,hl 
13d3 09			  add hl,bc 
13d4 29			  add hl,hl 
13d5 85			  add a,l 
13d6 6f			  ld l,a 
13d7 30 ef		  jr nc,.u16a 
13d9 24			  inc h 
13da c3 c8 13		  jp .u16a 
13dd			 
13dd			 
13dd			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
13dd			 
13dd			;written by Zeda 
13dd			;Converts a 16-bit unsigned integer to an ASCII string. 
13dd			 
13dd			uitoa_16: 
13dd			;Input: 
13dd			;   DE is the number to convert 
13dd			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
13dd			;Output: 
13dd			;   HL points to the null-terminated ASCII string 
13dd			;      NOTE: This isn't necessarily the same as the input HL. 
13dd d5			  push de 
13de c5			  push bc 
13df f5			  push af 
13e0 eb			  ex de,hl 
13e1			 
13e1 01 f0 d8		  ld bc,-10000 
13e4 3e 2f		  ld a,'0'-1 
13e6 3c			  inc a 
13e7 09			  add hl,bc  
13e8 38 fc		   jr c,$-2 
13ea 12			  ld (de),a 
13eb 13			  inc de 
13ec			 
13ec 01 e8 03		  ld bc,1000 
13ef 3e 3a		  ld a,'9'+1 
13f1 3d			  dec a  
13f2 09			  add hl,bc  
13f3 30 fc		   jr nc,$-2 
13f5 12			  ld (de),a 
13f6 13			  inc de 
13f7			 
13f7 01 9c ff		  ld bc,-100 
13fa 3e 2f		  ld a,'0'-1 
13fc 3c			  inc a  
13fd 09			  add hl,bc  
13fe 38 fc		   jr c,$-2 
1400 12			  ld (de),a 
1401 13			  inc de 
1402			 
1402 7d			  ld a,l 
1403 26 3a		  ld h,'9'+1 
1405 25			  dec h  
1406 c6 0a		  add a,10  
1408 30 fb		   jr nc,$-3 
140a c6 30		  add a,'0' 
140c eb			  ex de,hl 
140d 72			  ld (hl),d 
140e 23			  inc hl 
140f 77			  ld (hl),a 
1410 23			  inc hl 
1411 36 00		  ld (hl),0 
1413			 
1413			;Now strip the leading zeros 
1413 0e fa		  ld c,-6 
1415 09			  add hl,bc 
1416 3e 30		  ld a,'0' 
1418 23			  inc hl  
1419 be			  cp (hl)  
141a 28 fc		  jr z,$-2 
141c			 
141c			;Make sure that the string is non-empty! 
141c 7e			  ld a,(hl) 
141d b7			  or a 
141e 20 01		  jr nz,.atoub 
1420 2b			  dec hl 
1421			.atoub: 
1421			 
1421 f1			  pop af 
1422 c1			  pop bc 
1423 d1			  pop de 
1424 c9			  ret 
1425			 
1425			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
1425			 
1425			toUpper: 
1425			;A is the char. 
1425			;If A is a lowercase letter, this sets it to the matching uppercase 
1425			;18cc or 30cc or 41cc 
1425			;avg: 26.75cc 
1425 fe 61		  cp 'a' 
1427 d8			  ret c 
1428 fe 7b		  cp 'z'+1 
142a d0			  ret nc 
142b d6 20		  sub 'a'-'A' 
142d c9			  ret 
142e			 
142e			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
142e			 
142e			; String Length 
142e			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
142e			 
142e			; Get the length of the null-terminated string starting at $8000 hl 
142e			;    LD     HL, $8000 
142e			 
142e			strlenz: 
142e			 
142e af			    XOR    A               ; Zero is the value we are looking for. 
142f 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1430 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1431			                           ; 65, 536 bytes (the entire addressable memory space). 
1431 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1433			 
1433			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1433 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
1434 6f			    LD     L, A             ; number of bytes 
1435 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1437 2b			    DEC    HL              ; Compensate for null. 
1438 c9				ret 
1439			 
1439			; Get the length of the A terminated string starting at $8000 hl 
1439			;    LD     HL, $8000 
1439			 
1439			strlent: 
1439			 
1439			                  ; A is the value we are looking for. 
1439 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
143b 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
143d			                           ; 65, 536 bytes (the entire addressable memory space). 
143d ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
143f			 
143f			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
143f 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1441 2e 00		    LD     L, 0             ; number of bytes 
1443 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1445 2b			    DEC    HL              ; Compensate for null. 
1446 c9				ret 
1447			 
1447			 
1447			;Comparing Strings 
1447			 
1447			;IN    HL     Address of string1. 
1447			;      DE     Address of string2. 
1447			 
1447			; doc given but wrong??? 
1447			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
1447			;      carry  Set if string1 > string2, reset if string1 <= string2. 
1447			; tested 
1447			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
1447			 
1447			strcmp_old: 
1447 e5			    PUSH   HL 
1448 d5			    PUSH   DE 
1449			 
1449 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
144a be			    CP     (HL)            ; (want to minimize work). 
144b 38 01		    JR     C, Str1IsBigger 
144d 7e			    LD     A, (HL) 
144e			 
144e			Str1IsBigger: 
144e 4f			    LD     C, A             ; Put length in BC 
144f 06 00		    LD     B, 0 
1451 13			    INC    DE              ; Increment pointers to meat of string. 
1452 23			    INC    HL 
1453			 
1453			CmpLoop: 
1453 1a			    LD     A, (DE)          ; Compare bytes. 
1454 ed a1		    CPI 
1456 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
1458 13			    INC    DE              ; Update pointer. 
1459 ea 53 14		    JP     PE, CmpLoop 
145c			 
145c d1			    POP    DE 
145d e1			    POP    HL 
145e 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
145f be			    CP     (HL) 
1460 c9			    RET 
1461			 
1461			NoMatch: 
1461 2b			    DEC    HL 
1462 be			    CP     (HL)            ; Compare again to affect carry. 
1463 d1			    POP    DE 
1464 e1			    POP    HL 
1465 c9			    RET 
1466			 
1466			;; test strmp 
1466			; 
1466			;ld de, .str1 
1466			;ld hl, .str2 
1466			;call strcmp 
1466			;jr z, .z1 
1466			;;this 
1466			;	if DEBUG_FORTH_WORDS 
1466			;		DMARK "NZ1" 
1466			;		CALLMONITOR 
1466			;	endif 
1466			;.z1: 
1466			; 
1466			;	if DEBUG_FORTH_WORDS 
1466			;		DMARK "ZZ1" 
1466			;		CALLMONITOR 
1466			;	endif 
1466			; 
1466			;ld de, .str1 
1466			;ld hl, .str1 
1466			;call strcmp 
1466			;jr z, .z2 
1466			;;this 
1466			;	if DEBUG_FORTH_WORDS 
1466			;		DMARK "NZ2" 
1466			;		CALLMONITOR 
1466			;	endif 
1466			;.z2: 
1466			; 
1466			;	if DEBUG_FORTH_WORDS 
1466			;		DMARK "ZZ2" 
1466			;		CALLMONITOR 
1466			;	endif 
1466			; 
1466			;ld de, .str1 
1466			;ld hl, .str2 
1466			;call strcmp 
1466			;jr c, .c1 
1466			; 
1466			;	if DEBUG_FORTH_WORDS 
1466			;		DMARK "Nc1" 
1466			;		CALLMONITOR 
1466			;	endif 
1466			;.c1: 
1466			;;this 
1466			;	if DEBUG_FORTH_WORDS 
1466			;		DMARK "cc1" 
1466			;		CALLMONITOR 
1466			;	endif 
1466			; 
1466			;ld de, .str1 
1466			;ld hl, .str1 
1466			;call strcmp 
1466			;jr c, .c2 
1466			;;this 
1466			;	if DEBUG_FORTH_WORDS 
1466			;		DMARK "Nc2" 
1466			;		CALLMONITOR 
1466			;	endif 
1466			;.c2: 
1466			; 
1466			;	if DEBUG_FORTH_WORDS 
1466			;		DMARK "cc2" 
1466			;		CALLMONITOR 
1466			;	endif 
1466			;	NEXTW 
1466			;.str1:   db "string1",0 
1466			;.str2:   db "string2",0 
1466			 
1466			; only care about direct match or not 
1466			; hl and de strings 
1466			; zero set if the same 
1466			 
1466			strcmp: 
1466 1a				ld a, (de) 
1467 be				cp (hl) 
1468 28 02			jr z, .ssame 
146a b7				or a 
146b c9				ret 
146c			 
146c			.ssame:  
146c fe 00			cp 0 
146e c8				ret z 
146f			 
146f 23				inc hl 
1470 13				inc de 
1471 18 f3			jr strcmp 
1473				 
1473				 
1473			 
1473			 
1473			 
1473			 
1473			; eof 
1473			 
1473			 
1473			 
1473			 
1473			 
1473			 
# End of file firmware_strings.asm
1473			include "firmware_memory.asm"   ; malloc and free  
1473			 
1473			if DEBUG_FORTH_MALLOC_HIGH 
1473			.mallocsize: db "Wants malloc >256",0 
1473			.mallocasize: db "MALLOC gives >256",0 
1473			.malloczero: db "MALLOC gives zero",0 
1473			 
1473			malloc_guard_zerolen: 
1473				push hl 
1473				push de 
1473				push af 
1473			 
1473				ld de, 0 
1473			        call cmp16 
1473				jr nz, .lowalloz 
1473			 
1473				push hl 
1473				push de 
1473					ld hl, display_fb0 
1473					ld (display_fb_active), hl 
1473				call clear_display 
1473				ld a, 0 
1473				ld de, .malloczero 
1473				call str_at_display 
1473				call update_display 
1473				call delay1s 
1473				call delay1s 
1473				call bp_on 
1473			;	ld a, 0 
1473			;	ld (os_view_disable), a 
1473			 
1473				pop de 
1473				pop hl 
1473			 
1473				 
1473			 
1473				CALLMONITOR 
1473			.lowalloz: 
1473			 
1473			 
1473				pop af 
1473				pop de 
1473				pop hl 
1473			ret 
1473			 
1473			malloc_guard_entry: 
1473				push hl 
1473				push de 
1473				push af 
1473			 
1473			 	or a      ;clear carry flag 
1473				push hl 
1473				ld de, 255 
1473				sbc hl, de 
1473				jr c, .lowalloc 
1473			 
1473				push de 
1473					ld hl, display_fb0 
1473					ld (display_fb_active), hl 
1473				call clear_display 
1473				ld a, 0 
1473				ld de, .mallocsize 
1473				call str_at_display 
1473				call update_display 
1473				call delay1s 
1473				call delay1s 
1473			;	ld a, 0 
1473			;	ld (os_view_disable), a 
1473				call bp_on 
1473			 
1473				pop de 
1473				pop hl 
1473			 
1473				 
1473			 
1473				CALLMONITOR 
1473				jr .lowdone 
1473			.lowalloc: 
1473			 
1473			 
1473				pop hl 
1473			.lowdone:	pop af 
1473				pop de 
1473				pop hl 
1473			ret 
1473			 
1473			malloc_guard_exit: 
1473				push hl 
1473				push de 
1473				push af 
1473			 
1473			 	or a      ;clear carry flag 
1473				push hl 
1473				ld de, 255 
1473				sbc hl, de 
1473				jr c, .lowallocx 
1473			 
1473				push de 
1473					ld hl, display_fb0 
1473					ld (display_fb_active), hl 
1473				call clear_display 
1473				ld a, 0 
1473				ld de, .mallocasize 
1473				call str_at_display 
1473				call update_display 
1473				call delay1s 
1473				call delay1s 
1473			;	ld a, 0 
1473			;	ld (os_view_disable), a 
1473				call bp_on 
1473				pop de 
1473				pop hl 
1473			 
1473				CALLMONITOR 
1473				jr .lowdonex 
1473			.lowallocx: 
1473			 
1473				pop hl 
1473			.lowdonex:	pop af 
1473				pop de 
1473				pop hl 
1473			ret 
1473			endif 
1473			 
1473			if MALLOC_2 
1473			; Z80 Malloc and Free Functions 
1473			 
1473			; Malloc Function: 
1473			; Input: 
1473			;   HL: Size of block to allocate 
1473			; Output: 
1473			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1473			 
1473			malloc: 
1473				 
1473			if DEBUG_FORTH_MALLOC_HIGH 
1473			call malloc_guard_entry 
1473			endif 
1473			 
1473			 
1473			 
1473			 
1473					if DEBUG_FORTH_MALLOC 
1473						DMARK "mal" 
1473						CALLMONITOR 
1473					endif 
1473			    push af            ; Save AF register 
1473			    ld a, l            ; Load low byte of size into A 
1473			    or h               ; Check if size is zero 
1473			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
1473			 
1473			    ; Allocate memory 
1473			    ld hl, (heap_start) ; Load start of heap into HL 
1473					if DEBUG_FORTH_MALLOC 
1473						DMARK "ma1" 
1473						CALLMONITOR 
1473					endif 
1473			    call malloc_internal ; Call internal malloc function 
1473			    pop af             ; Restore AF register 
1473			if DEBUG_FORTH_MALLOC_HIGH 
1473			call malloc_guard_exit 
1473			call malloc_guard_zerolen 
1473			endif 
1473			    ret                ; Return 
1473			 
1473			; Free Function: 
1473			; Input: 
1473			;   HL: Pointer to memory block to free 
1473			; Output: 
1473			;   None 
1473			 
1473			free: 
1473			    push af            ; Save AF register 
1473			    ld a, l            ; Load low byte of pointer into A 
1473			    or h               ; Check if pointer is NULL 
1473			    jp z, free_exit    ; If pointer is NULL, exit 
1473			 
1473			    ; Free memory 
1473			    ld hl, (heap_start) ; Load start of heap into HL 
1473			    call free_internal  ; Call internal free function 
1473			    pop af             ; Restore AF register 
1473			    ret                ; Return 
1473			 
1473			; Internal Malloc Function: 
1473			; Input: 
1473			;   HL: Size of block to allocate 
1473			; Output: 
1473			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1473			 
1473			malloc_internal: 
1473			    ld bc, 2           ; Number of bytes to allocate for management overhead 
1473			    add hl, bc         ; Add management overhead to requested size 
1473			    ex de, hl          ; Save total size in DE, and keep it in HL 
1473					if DEBUG_FORTH_MALLOC 
1473						DMARK "ma2" 
1473						CALLMONITOR 
1473					endif 
1473			 
1473			    ; Search for free memory block 
1473			    ld de, (heap_end)  ; Load end of heap into DE 
1473			    ld bc, 0           ; Initialize counter 
1473			 
1473					if DEBUG_FORTH_MALLOC 
1473						DMARK "ma2" 
1473						CALLMONITOR 
1473					endif 
1473			malloc_search_loop: 
1473			    ; Check if current block is free 
1473			    ld a, (hl)         ; Load current block's status (free or used) 
1473			    cp 0               ; Compare with zero (free) 
1473			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
1473			 
1473			    ; Check if current block is large enough 
1473			    ld a, (hl+1)       ; Load high byte of block size 
1473			    cp l               ; Compare with low byte of requested size 
1473			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
1473			 
1473			    ld a, (hl+2)       ; Load low byte of block size 
1473			    cp h               ; Compare with high byte of requested size 
1473			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
1473			 
1473			    ; Mark block as used 
1473			    ld (hl), 0xFF      ; Set status byte to indicate used block 
1473			 
1473			    ; Calculate remaining space in block 
1473			    ld bc, 0           ; Clear BC 
1473			    add hl, bc         ; Increment HL to point to start of data block 
1473			    add hl, de         ; HL = HL + DE (total size) 
1473			    ld bc, 1           ; Number of bytes to allocate for management overhead 
1473			    add hl, bc         ; Add management overhead to start of data block 
1473			 
1473			    ; Save pointer to allocated block in HL 
1473			if DEBUG_FORTH_MALLOC_HIGH 
1473						DMARK "ma5" 
1473			call malloc_guard_exit 
1473			call malloc_guard_zerolen 
1473			endif 
1473			    ret 
1473			 
1473			malloc_skip_block_check: 
1473			    ; Move to the next block 
1473			    ld bc, 3           ; Size of management overhead 
1473			    add hl, bc         ; Move to the next block 
1473			    inc de             ; Increment counter 
1473			 
1473			    ; Check if we have reached the end of heap 
1473			    ld a, e            ; Load low byte of heap end address 
1473			    cp (hl)            ; Compare with low byte of current address 
1473			    jr nz, malloc_search_loop  ; If not equal, continue searching 
1473			    ld a, d            ; Load high byte of heap end address 
1473			    cp 0               ; Check if it's zero (end of memory) 
1473			    jr nz, malloc_search_loop  ; If not zero, continue searching 
1473			 
1473			    ; If we reached here, allocation failed 
1473			    xor a              ; Set result to NULL 
1473			if DEBUG_FORTH_MALLOC_HIGH 
1473						DMARK "ma6" 
1473			call malloc_guard_exit 
1473			call malloc_guard_zerolen 
1473			endif 
1473			    ret 
1473			malloc_exit: 
1473			if DEBUG_FORTH_MALLOC_HIGH 
1473						DMARK "ma7" 
1473			call malloc_guard_exit 
1473			call malloc_guard_zerolen 
1473			endif 
1473			    ret 
1473			 
1473			; Internal Free Function: 
1473			; Input: 
1473			;   HL: Pointer to memory block to free 
1473			; Output: 
1473			;   None 
1473			 
1473			free_internal: 
1473			    ld de, (heap_start) ; Load start of heap into DE 
1473			    ld bc, 0            ; Initialize counter 
1473			 
1473			free_search_loop: 
1473			    ; Check if current block contains the pointer 
1473			    ld a, l             ; Load low byte of pointer 
1473			    cp (hl+1)           ; Compare with high byte of current block's address 
1473			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1473			    ld a, h             ; Load high byte of pointer 
1473			    cp (hl+2)           ; Compare with low byte of current block's address 
1473			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1473			 
1473			    ; Mark block as free 
1473			    ld (hl), 0          ; Set status byte to indicate free block 
1473			    ret                 ; Return 
1473			 
1473			free_skip_block_check: 
1473			    ; Move to the next block 
1473			    ld bc, 3            ; Size of management overhead 
1473			    add hl, bc          ; Move to the next block 
1473			    inc de              ; Increment counter 
1473			 
1473			    ; Check if we have reached the end of heap 
1473			    ld a, e             ; Load low byte of heap end address 
1473			    cp (hl)             ; Compare with low byte of current address 
1473			    jr nz, free_search_loop  ; If not equal, continue searching 
1473			    ld a, d             ; Load high byte of heap end address 
1473			    cp 0                ; Check if it's zero (end of memory) 
1473			    jr nz, free_search_loop  ; If not zero, continue searching 
1473			 
1473			    ; If we reached here, pointer is not found in heap 
1473			    ret 
1473			 
1473			free_exit: 
1473			    ret                 ; Return 
1473			 
1473			; Define heap start and end addresses 
1473			;heap_start:    .dw 0xC000   ; Start of heap 
1473			;heap_end:      .dw 0xE000   ; End of heap 
1473			 
1473			endif 
1473			 
1473			 
1473			if MALLOC_1 
1473			 
1473			 
1473			 
1473			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
1473			 
1473			;moved to firmware.asm 
1473			;heap_start        .equ  0x9000      ; Starting address of heap 
1473			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1473			 
1473			;      .org 0 
1473			;      jp    main 
1473			 
1473			 
1473			;      .org  0x100 
1473			;main: 
1473			;      ld    HL, 0x8100 
1473			;      ld    SP, HL 
1473			; 
1473			;      call  heap_init 
1473			; 
1473			;      ; Make some allocations 
1473			;      ld    HL, 12 
1473			;      call  malloc            ; Allocates 0x9004 
1473			; 
1473			;      ld    HL, 12 
1473			;      call  malloc            ; Allocates 0x9014 
1473			; 
1473			;      ld    HL, 12 
1473			;      call  malloc            ; Allocates 0x9024 
1473			; 
1473			;      ; Free some allocations 
1473			;      ld    HL, 0x9014 
1473			;      call  free 
1473			; 
1473			;      ld    HL, 0x9004 
1473			;      call  free 
1473			; 
1473			;      ld    HL, 0x9024 
1473			;      call  free 
1473			; 
1473			; 
1473			;      halt 
1473			 
1473			 
1473			;------------------------------------------------------------------------------ 
1473			;     heap_init                                                               : 
1473			;                                                                             : 
1473			; Description                                                                 : 
1473			;     Initialise the heap and make it ready for malloc and free operations.   : 
1473			;                                                                             : 
1473			;     The heap is maintained as a linked list, starting with an initial       : 
1473			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1473			;     the first free block in the heap. Each block then points to the next    : 
1473			;     free block within the heap, and the free list ends at the first block   : 
1473			;     with a null pointer to the next free block.                             : 
1473			;                                                                             : 
1473			; Parameters                                                                  : 
1473			;     Inputs are compile-time only. Two defines which specify the starting    : 
1473			;     address of the heap and its size are required, along with a memory      : 
1473			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1473			;     principally stores a pointer to the first free block in the heap.       : 
1473			;                                                                             : 
1473			; Returns                                                                     : 
1473			;     Nothing                                                                 : 
1473			;------------------------------------------------------------------------------ 
1473			heap_init: 
1473 e5			      push  HL 
1474			 
1474			      ; Initialise free list struct 
1474 21 0e 80		      ld    HL, heap_start 
1477 22 0a 80		      ld    (free_list), HL 
147a 21 00 00		      ld    HL, 0 
147d 22 0c 80		      ld    (free_list+2), HL 
1480			 
1480			      ; Insert first free block at bottom of heap, consumes entire heap 
1480 21 a1 f1		      ld    HL, heap_start+heap_size-4 
1483 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
1486 21 93 71		      ld    HL, heap_size-4 
1489 22 10 80		      ld    (heap_start+2), HL      ; Block size 
148c			 
148c			      ; Insert end of free list block at top of heap - two null words will 
148c			      ; terminate the free list 
148c 21 00 00		      ld    HL, 0 
148f 22 a3 f1		      ld    (heap_start+heap_size-2), HL 
1492 22 a1 f1		      ld    (heap_start+heap_size-4), HL 
1495			 
1495 e1			      pop   HL 
1496			 
1496 c9			      ret 
1497			 
1497			 
1497			;------------------------------------------------------------------------------ 
1497			;     malloc                                                                  : 
1497			;                                                                             : 
1497			; Description                                                                 : 
1497			;     Allocates the wanted space from the heap and returns the address of the : 
1497			;     first useable byte of the allocation.                                   : 
1497			;                                                                             : 
1497			;     Allocations can happen in one of two ways:                              : 
1497			;                                                                             : 
1497			;     1. A free block may be found which is the exact size wanted. In this    : 
1497			;        case the block is removed from the free list and retuedn to the      : 
1497			;        caller.                                                              : 
1497			;     2. A free block may be found which is larger than the size wanted. In   : 
1497			;        this case, the larger block is split into two. The first portion of  : 
1497			;        this block will become the requested space by the malloc call and    : 
1497			;        is returned to the caller. The second portion becomes a new free     : 
1497			;        block, and the free list is adjusted to maintain continuity via this : 
1497			;        newly created block.                                                 : 
1497			;                                                                             : 
1497			;     malloc does not set any initial value in the allocated space, the       : 
1497			;     caller is required to do this as required.                              : 
1497			;                                                                             : 
1497			;     This implementation of malloc uses the stack exclusively, and is        : 
1497			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1497			;     advisable to disable interrupts before calling malloc, and recommended  : 
1497			;     to avoid the use of malloc inside ISRs in general.                      : 
1497			;                                                                             : 
1497			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1497			;                                                                             : 
1497			; Parameters                                                                  : 
1497			;     HL  Number of bytes wanted                                              : 
1497			;                                                                             : 
1497			; Returns                                                                     : 
1497			;     HL  Address of the first useable byte of the allocation                 : 
1497			;                                                                             : 
1497			; Flags                                                                       : 
1497			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1497			;                                                                             : 
1497			; Stack frame                                                                 : 
1497			;       |             |                                                       : 
1497			;       +-------------+                                                       : 
1497			;       |     BC      |                                                       : 
1497			;       +-------------+                                                       : 
1497			;       |     DE      |                                                       : 
1497			;       +-------------+                                                       : 
1497			;       |     IX      |                                                       : 
1497			;       +-------------+                                                       : 
1497			;       |  prev_free  |                                                       : 
1497			;   +4  +-------------+                                                       : 
1497			;       |  this_free  |                                                       : 
1497			;   +2  +-------------+                                                       : 
1497			;       |  next_free  |                                                       : 
1497			;   +0  +-------------+                                                       : 
1497			;       |             |                                                       : 
1497			;                                                                             : 
1497			;------------------------------------------------------------------------------ 
1497			 
1497			 
1497			;malloc: 
1497			; 
1497			;	SAVESP ON 1 
1497			; 
1497			;	call malloc_code 
1497			; 
1497			;	CHECKSP ON 1 
1497			;	ret 
1497			 
1497			 
1497			malloc: 
1497 c5			      push  BC 
1498 d5			      push  DE 
1499 dd e5		      push  IX 
149b			if DEBUG_FORTH_MALLOC_HIGH 
149b			call malloc_guard_entry 
149b			endif 
149b			 
149b					if DEBUG_FORTH_MALLOC 
149b						DMARK "mal" 
149b						CALLMONITOR 
149b					endif 
149b 7c			      ld    A, H                    ; Exit if no space requested 
149c b5			      or    L 
149d ca 5c 15		      jp    Z, malloc_early_exit 
14a0			 
14a0			;inc hl 
14a0			;inc hl 
14a0			;inc hl 
14a0			; 
14a0			;inc hl 
14a0			;inc hl 
14a0			;inc hl 
14a0			;inc hl 
14a0			;inc hl 
14a0			;inc hl 
14a0			;inc hl 
14a0			;inc hl 
14a0			;inc hl 
14a0			 
14a0			 
14a0			 
14a0			 
14a0					if DEBUG_FORTH_MALLOC 
14a0						DMARK "maA" 
14a0						CALLMONITOR 
14a0					endif 
14a0			      ; Set up stack frame 
14a0 eb			      ex    DE, HL 
14a1 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
14a4 39			      add   HL, SP 
14a5 f9			      ld    SP, HL 
14a6 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
14aa dd 39		      add   IX, SP 
14ac			 
14ac			      ; Setup initial state 
14ac 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
14af 19			      add   HL, DE 
14b0			 
14b0 44			      ld    B, H                    ; Move want to BC 
14b1 4d			      ld    C, L 
14b2			 
14b2 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
14b5 dd 75 04		      ld    (IX+4), L 
14b8 dd 74 05		      ld    (IX+5), H 
14bb			 
14bb 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
14bc 23			      inc   HL 
14bd 56			      ld    D, (HL) 
14be dd 73 02		      ld    (IX+2), E 
14c1 dd 72 03		      ld    (IX+3), D 
14c4 eb			      ex    DE, HL                  ; this_free ptr into HL 
14c5			 
14c5					if DEBUG_FORTH_MALLOC 
14c5						DMARK "maB" 
14c5						CALLMONITOR 
14c5					endif 
14c5			      ; Loop through free block list to find some space 
14c5			malloc_find_space: 
14c5 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
14c6 23			      inc   HL 
14c7 56			      ld    D, (HL) 
14c8			 
14c8 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
14c9 b3			      or    E 
14ca ca 56 15		      jp    Z, malloc_no_space 
14cd			 
14cd dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
14d0 dd 72 01		      ld    (IX+1), D 
14d3			 
14d3			      ; Does this block have enough space to make the allocation? 
14d3 23			      inc   HL                      ; Load free block size into DE 
14d4 5e			      ld    E, (HL) 
14d5 23			      inc   HL 
14d6 56			      ld    D, (HL) 
14d7			 
14d7 eb			      ex    DE, HL                  ; Check size of block against want 
14d8 b7			      or    A                       ; Ensure carry flag clear 
14d9 ed 42		      sbc   HL, BC 
14db e5			      push  HL                      ; Store the result for later (new block size) 
14dc			 
14dc ca 2b 15		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
14df 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
14e1			 
14e1			      ; this_free block is not big enough, setup ptrs to test next free block 
14e1 e1			      pop   HL                      ; Discard previous result 
14e2			 
14e2 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
14e5 dd 66 03		      ld    H, (IX+3) 
14e8 dd 75 04		      ld    (IX+4), L 
14eb dd 74 05		      ld    (IX+5), H 
14ee			 
14ee dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
14f1 dd 66 01		      ld    H, (IX+1) 
14f4 dd 75 02		      ld    (IX+2), L 
14f7 dd 74 03		      ld    (IX+3), H 
14fa			 
14fa					if DEBUG_FORTH_MALLOC 
14fa						DMARK "MA>" 
14fa						CALLMONITOR 
14fa					endif 
14fa 18 c9		      jr    malloc_find_space 
14fc			 
14fc			      ; split a bigger block into two - requested size and remaining size 
14fc			malloc_alloc_split: 
14fc					if DEBUG_FORTH_MALLOC 
14fc						DMARK "MAs" 
14fc						CALLMONITOR 
14fc					endif 
14fc eb			      ex    DE, HL                  ; Calculate address of new free block 
14fd 2b			      dec   HL 
14fe 2b			      dec   HL 
14ff 2b			      dec   HL 
1500 09			      add   HL, BC 
1501			 
1501			      ; Create a new block and point it at next_free 
1501 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
1504 dd 56 01		      ld    D, (IX+1) 
1507			 
1507 73			      ld    (HL), E                 ; Store next_free ptr into new block 
1508 23			      inc   HL 
1509 72			      ld    (HL), D 
150a			 
150a d1			      pop   DE                      ; Store size of new block into new block 
150b 23			      inc   HL 
150c 73			      ld    (HL), E 
150d 23			      inc   HL 
150e 72			      ld    (HL), D 
150f			 
150f			      ; Update this_free ptr to point to new block 
150f 2b			      dec   HL 
1510 2b			      dec   HL 
1511 2b			      dec   HL 
1512			 
1512 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1515 dd 56 03		      ld    D, (IX+3) 
1518			 
1518 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
151b dd 74 03		      ld    (IX+3), H 
151e			 
151e			      ; Modify this_free block to be allocation 
151e eb			      ex    DE, HL 
151f af			      xor   A                       ; Null the next block ptr of allocated block 
1520 77			      ld    (HL), A 
1521 23			      inc   HL 
1522 77			      ld    (HL), A 
1523			 
1523 23			      inc   HL                      ; Store want size into allocated block 
1524 71			      ld    (HL), C 
1525 23			      inc   HL 
1526 70			      ld    (HL), B 
1527 23			      inc   HL 
1528 e5			      push  HL                      ; Address of allocation to return 
1529			 
1529 18 19		      jr    malloc_update_links 
152b			 
152b			malloc_alloc_fit: 
152b e1			      pop   HL                      ; Dont need new block size, want is exact fit 
152c			 
152c					if DEBUG_FORTH_MALLOC 
152c						DMARK "MAf" 
152c						CALLMONITOR 
152c					endif 
152c			      ; Modify this_free block to be allocation 
152c eb			      ex    DE, HL 
152d 2b			      dec   HL 
152e 2b			      dec   HL 
152f 2b			      dec   HL 
1530			 
1530 af			      xor   A                       ; Null the next block ptr of allocated block 
1531 77			      ld    (HL), A 
1532 23			      inc   HL 
1533 77			      ld    (HL), A 
1534			 
1534 23			      inc   HL                      ; Store address of allocation to return 
1535 23			      inc   HL 
1536 23			      inc   HL 
1537 e5			      push  HL 
1538			 
1538			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1538 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
153b dd 66 01		      ld    H, (IX+1) 
153e			 
153e dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1541 dd 74 03		      ld    (IX+3), H 
1544			 
1544			 
1544			malloc_update_links: 
1544			      ; Update prev_free ptr to point to this_free 
1544 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1547 dd 66 05		      ld    H, (IX+5) 
154a			 
154a dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
154d dd 56 03		      ld    D, (IX+3) 
1550			 
1550 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1551 23			      inc   HL 
1552 72			      ld    (HL), D 
1553			 
1553					if DEBUG_FORTH_MALLOC 
1553						DMARK "Mul" 
1553						CALLMONITOR 
1553					endif 
1553			      ; Clear the Z flag to indicate successful allocation 
1553 7a			      ld    A, D 
1554 b3			      or    E 
1555			 
1555 d1			      pop   DE                      ; Address of allocation 
1556					if DEBUG_FORTH_MALLOC 
1556						DMARK "MAu" 
1556						CALLMONITOR 
1556					endif 
1556			 
1556			malloc_no_space: 
1556 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
1559 39			      add   HL, SP 
155a f9			      ld    SP, HL 
155b			 
155b eb			      ex    DE, HL                  ; Alloc addr into HL for return 
155c					if DEBUG_FORTH_MALLOC 
155c						DMARK "MAN" 
155c						CALLMONITOR 
155c					endif 
155c			 
155c			malloc_early_exit: 
155c					if DEBUG_FORTH_MALLOC 
155c						DMARK "MAx" 
155c						CALLMONITOR 
155c					endif 
155c dd e1		      pop   IX 
155e d1			      pop   DE 
155f c1			      pop   BC 
1560			 
1560			if DEBUG_FORTH_MALLOC_HIGH 
1560			call malloc_guard_exit 
1560			call malloc_guard_zerolen 
1560			endif 
1560 c9			      ret 
1561			 
1561			 
1561			;------------------------------------------------------------------------------ 
1561			;     free                                                                    : 
1561			;                                                                             : 
1561			; Description                                                                 : 
1561			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1561			;     returned by malloc, otherwise the behaviour is undefined.               : 
1561			;                                                                             : 
1561			;     Where possible, directly adjacent free blocks will be merged together   : 
1561			;     into larger blocks to help ensure that the heap does not become         : 
1561			;     excessively fragmented.                                                 : 
1561			;                                                                             : 
1561			;     free does not clear or set any other value into the freed space, and    : 
1561			;     therefore its contents may be visible through subsequent malloc's. The  : 
1561			;     caller should clear the freed space as required.                        : 
1561			;                                                                             : 
1561			;     This implementation of free uses the stack exclusively, and is          : 
1561			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1561			;     advisable to disable interrupts before calling free, and recommended    : 
1561			;     to avoid the use of free inside ISRs in general.                        : 
1561			;                                                                             : 
1561			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1561			;                                                                             : 
1561			; Parameters                                                                  : 
1561			;     HL  Pointer to address of first byte of allocation to be freed          : 
1561			;                                                                             : 
1561			; Returns                                                                     : 
1561			;     Nothing                                                                 : 
1561			;                                                                             : 
1561			; Stack frame                                                                 : 
1561			;       |             |                                                       : 
1561			;       +-------------+                                                       : 
1561			;       |     BC      |                                                       : 
1561			;       +-------------+                                                       : 
1561			;       |     DE      |                                                       : 
1561			;       +-------------+                                                       : 
1561			;       |     IX      |                                                       : 
1561			;       +-------------+                                                       : 
1561			;       |  prev_free  |                                                       : 
1561			;   +2  +-------------+                                                       : 
1561			;       |  next_free  |                                                       : 
1561			;   +0  +-------------+                                                       : 
1561			;       |             |                                                       : 
1561			;                                                                             : 
1561			;------------------------------------------------------------------------------ 
1561			free: 
1561 c5			      push  BC 
1562 d5			      push  DE 
1563 dd e5		      push  IX 
1565			 
1565 7c			      ld    A, H                    ; Exit if ptr is null 
1566 b5			      or    L 
1567 ca 2b 16		      jp    Z, free_early_exit 
156a			 
156a			      ; Set up stack frame 
156a eb			      ex    DE, HL 
156b 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
156e 39			      add   HL, SP 
156f f9			      ld    SP, HL 
1570 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1574 dd 39		      add   IX, SP 
1576			 
1576			      ; The address in HL points to the start of the useable allocated space, 
1576			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1576			      ; address of the block itself. 
1576 eb			      ex    DE, HL 
1577 11 fc ff		      ld    DE, -4 
157a 19			      add   HL, DE 
157b			 
157b			      ; An allocated block must have a null next block pointer in it 
157b 7e			      ld    A, (HL) 
157c 23			      inc   HL 
157d b6			      or    (HL) 
157e c2 26 16		      jp    NZ, free_done 
1581			 
1581 2b			      dec   HL 
1582			 
1582 44			      ld    B, H                    ; Copy HL to BC 
1583 4d			      ld    C, L 
1584			 
1584			      ; Loop through the free list to find the first block with an address 
1584			      ; higher than the block being freed 
1584 21 0a 80		      ld    HL, free_list 
1587			 
1587			free_find_higher_block: 
1587 5e			      ld    E, (HL)                 ; Load next ptr from free block 
1588 23			      inc   HL 
1589 56			      ld    D, (HL) 
158a 2b			      dec   HL 
158b			 
158b dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
158e dd 72 01		      ld    (IX+1), D 
1591 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
1594 dd 74 03		      ld    (IX+3), H 
1597			 
1597 78			      ld    A, B                    ; Check if DE is greater than BC 
1598 ba			      cp    D                       ; Compare MSB first 
1599 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
159b 30 04		      jr    NC, free_find_higher_block_skip 
159d 79			      ld    A, C 
159e bb			      cp    E                       ; Then compare LSB 
159f 38 08		      jr    C, free_found_higher_block 
15a1			 
15a1			free_find_higher_block_skip: 
15a1 7a			      ld    A, D                    ; Reached the end of the free list? 
15a2 b3			      or    E 
15a3 ca 26 16		      jp    Z, free_done 
15a6			 
15a6 eb			      ex    DE, HL 
15a7			 
15a7 18 de		      jr    free_find_higher_block 
15a9			 
15a9			free_found_higher_block: 
15a9			      ; Insert freed block between prev and next free blocks 
15a9 71			      ld    (HL), C                 ; Point prev free block to freed block 
15aa 23			      inc   HL 
15ab 70			      ld    (HL), B 
15ac			 
15ac 60			      ld    H, B                    ; Point freed block at next free block 
15ad 69			      ld    L, C 
15ae 73			      ld    (HL), E 
15af 23			      inc   HL 
15b0 72			      ld    (HL), D 
15b1			 
15b1			      ; Check if the freed block is adjacent to the next free block 
15b1 23			      inc   HL                      ; Load size of freed block into HL 
15b2 5e			      ld    E, (HL) 
15b3 23			      inc   HL 
15b4 56			      ld    D, (HL) 
15b5 eb			      ex    DE, HL 
15b6			 
15b6 09			      add   HL, BC                  ; Add addr of freed block and its size 
15b7			 
15b7 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
15ba dd 56 01		      ld    D, (IX+1) 
15bd			 
15bd b7			      or    A                       ; Clear the carry flag 
15be ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
15c0 20 22		      jr    NZ, free_check_adjacent_to_prev 
15c2			 
15c2			      ; Freed block is adjacent to next, merge into one bigger block 
15c2 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
15c3 5e			      ld    E, (HL) 
15c4 23			      inc   HL 
15c5 56			      ld    D, (HL) 
15c6 e5			      push  HL                      ; Save ptr to next block for later 
15c7			 
15c7 60			      ld    H, B                    ; Store ptr from next block into freed block 
15c8 69			      ld    L, C 
15c9 73			      ld    (HL), E 
15ca 23			      inc   HL 
15cb 72			      ld    (HL), D 
15cc			 
15cc e1			      pop   HL                      ; Restore ptr to next block 
15cd 23			      inc   HL                      ; Load size of next block into DE 
15ce 5e			      ld    E, (HL) 
15cf 23			      inc   HL 
15d0 56			      ld    D, (HL) 
15d1 d5			      push  DE                      ; Save next block size for later 
15d2			 
15d2 60			      ld    H, B                    ; Load size of freed block into HL 
15d3 69			      ld    L, C 
15d4 23			      inc   HL 
15d5 23			      inc   HL 
15d6 5e			      ld    E, (HL) 
15d7 23			      inc   HL 
15d8 56			      ld    D, (HL) 
15d9 eb			      ex    DE, HL 
15da			 
15da d1			      pop   DE                      ; Restore size of next block 
15db 19			      add   HL, DE                  ; Add sizes of both blocks 
15dc eb			      ex    DE, HL 
15dd			 
15dd 60			      ld    H, B                    ; Store new bigger size into freed block 
15de 69			      ld    L, C 
15df 23			      inc   HL 
15e0 23			      inc   HL 
15e1 73			      ld    (HL), E 
15e2 23			      inc   HL 
15e3 72			      ld    (HL), D 
15e4			 
15e4			free_check_adjacent_to_prev: 
15e4			      ; Check if the freed block is adjacent to the prev free block 
15e4 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
15e7 dd 66 03		      ld    H, (IX+3) 
15ea			 
15ea 23			      inc   HL                      ; Size of prev free block into DE 
15eb 23			      inc   HL 
15ec 5e			      ld    E, (HL) 
15ed 23			      inc   HL 
15ee 56			      ld    D, (HL) 
15ef 2b			      dec   HL 
15f0 2b			      dec   HL 
15f1 2b			      dec   HL 
15f2			 
15f2 19			      add   HL, DE                  ; Add prev block addr and size 
15f3			 
15f3 b7			      or    A                       ; Clear the carry flag 
15f4 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
15f6 20 2e		      jr    NZ, free_done 
15f8			 
15f8			      ; Freed block is adjacent to prev, merge into one bigger block 
15f8 60			      ld    H, B                    ; Load next ptr from freed block into DE 
15f9 69			      ld    L, C 
15fa 5e			      ld    E, (HL) 
15fb 23			      inc   HL 
15fc 56			      ld    D, (HL) 
15fd e5			      push  HL                      ; Save freed block ptr for later 
15fe			 
15fe dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1601 dd 66 03		      ld    H, (IX+3) 
1604 73			      ld    (HL), E 
1605 23			      inc   HL 
1606 72			      ld    (HL), D 
1607			 
1607 e1			      pop   HL                      ; Restore freed block ptr 
1608 23			      inc   HL                      ; Load size of freed block into DE 
1609 5e			      ld    E, (HL) 
160a 23			      inc   HL 
160b 56			      ld    D, (HL) 
160c d5			      push  DE                      ; Save freed block size for later 
160d			 
160d dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1610 dd 66 03		      ld    H, (IX+3) 
1613 23			      inc   HL 
1614 23			      inc   HL 
1615 5e			      ld    E, (HL) 
1616 23			      inc   HL 
1617 56			      ld    D, (HL) 
1618			 
1618 e1			      pop   HL                      ; Add sizes of both blocks 
1619 19			      add   HL, DE 
161a eb			      ex    DE, HL 
161b			 
161b dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
161e dd 66 03		      ld    H, (IX+3) 
1621 23			      inc   HL 
1622 23			      inc   HL 
1623 73			      ld    (HL), E 
1624 23			      inc   HL 
1625 72			      ld    (HL), D 
1626			 
1626			free_done: 
1626 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
1629 39			      add   HL, SP 
162a f9			      ld    SP, HL 
162b			 
162b			free_early_exit: 
162b dd e1		      pop   IX 
162d d1			      pop   DE 
162e c1			      pop   BC 
162f			 
162f c9			      ret 
1630			 
1630			; moved to firmware.asm 
1630			; 
1630			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1630			;                  .dw   0 
1630			 
1630			 
1630			endif 
1630			 
1630			 
1630			if MALLOC_3 
1630			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1630			;heap_start        .equ  0x9000      ; Starting address of heap 
1630			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1630			; 
1630			 ;     .org 0 
1630			  ;    jp    main 
1630			; 
1630			; 
1630			 ;     .org  0x100 
1630			;main: 
1630			 ;     ld    HL, 0x8100 
1630			  ;    ld    SP, HL 
1630			; 
1630			;      call  heap_init 
1630			 
1630			      ; Make some allocations 
1630			;      ld    HL, 12 
1630			;      call  malloc            ; Allocates 0x9004 
1630			; 
1630			 ;     ld    HL, 12 
1630			;      call  malloc            ; Allocates 0x9014 
1630			 
1630			;      ld    HL, 12 
1630			;      call  malloc            ; Allocates 0x9024 
1630			 
1630			      ; Free some allocations 
1630			;      ld    HL, 0x9014 
1630			;      call  free 
1630			 
1630			;      ld    HL, 0x9004 
1630			;      call  free 
1630			; 
1630			;      ld    HL, 0x9024 
1630			;      call  free 
1630			 
1630			 
1630			 ;     halt 
1630			 
1630			 
1630			;------------------------------------------------------------------------------ 
1630			;     heap_init                                                               : 
1630			;                                                                             : 
1630			; Description                                                                 : 
1630			;     Initialise the heap and make it ready for malloc and free operations.   : 
1630			;                                                                             : 
1630			;     The heap is maintained as a linked list, starting with an initial       : 
1630			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1630			;     the first free block in the heap. Each block then points to the next    : 
1630			;     free block within the heap, and the free list ends at the first block   : 
1630			;     with a null pointer to the next free block.                             : 
1630			;                                                                             : 
1630			; Parameters                                                                  : 
1630			;     Inputs are compile-time only. Two defines which specify the starting    : 
1630			;     address of the heap and its size are required, along with a memory      : 
1630			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1630			;     principally stores a pointer to the first free block in the heap.       : 
1630			;                                                                             : 
1630			; Returns                                                                     : 
1630			;     Nothing                                                                 : 
1630			;------------------------------------------------------------------------------ 
1630			heap_init: 
1630			      push  HL 
1630			 
1630			      ; Initialise free list struct 
1630			      ld    HL, heap_start 
1630			      ld    (free_list), HL 
1630			      ld    HL, 0 
1630			      ld    (free_list+2), HL 
1630			 
1630			      ; Insert first free block at bottom of heap, consumes entire heap 
1630			      ld    HL, heap_start+heap_size-4 
1630			      ld    (heap_start), HL        ; Next block (end of free list) 
1630			      ld    HL, heap_size-4 
1630			      ld    (heap_start+2), HL      ; Block size 
1630			 
1630			      ; Insert end of free list block at top of heap - two null words will 
1630			      ; terminate the free list 
1630			      ld    HL, 0 
1630			      ld    (heap_start+heap_size-2), HL 
1630			      ld    (heap_start+heap_size-4), HL 
1630			 
1630			      pop   HL 
1630			 
1630			      ret 
1630			 
1630			 
1630			;------------------------------------------------------------------------------ 
1630			;     malloc                                                                  : 
1630			;                                                                             : 
1630			; Description                                                                 : 
1630			;     Allocates the wanted space from the heap and returns the address of the : 
1630			;     first useable byte of the allocation.                                   : 
1630			;                                                                             : 
1630			;     Allocations can happen in one of two ways:                              : 
1630			;                                                                             : 
1630			;     1. A free block may be found which is the exact size wanted. In this    : 
1630			;        case the block is removed from the free list and retuedn to the      : 
1630			;        caller.                                                              : 
1630			;     2. A free block may be found which is larger than the size wanted. In   : 
1630			;        this case, the larger block is split into two. The first portion of  : 
1630			;        this block will become the requested space by the malloc call and    : 
1630			;        is returned to the caller. The second portion becomes a new free     : 
1630			;        block, and the free list is adjusted to maintain continuity via this : 
1630			;        newly created block.                                                 : 
1630			;                                                                             : 
1630			;     malloc does not set any initial value in the allocated space, the       : 
1630			;     caller is required to do this as required.                              : 
1630			;                                                                             : 
1630			;     This implementation of malloc uses the stack exclusively, and is        : 
1630			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1630			;     advisable to disable interrupts before calling malloc, and recommended  : 
1630			;     to avoid the use of malloc inside ISRs in general.                      : 
1630			;                                                                             : 
1630			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1630			;                                                                             : 
1630			; Parameters                                                                  : 
1630			;     HL  Number of bytes wanted                                              : 
1630			;                                                                             : 
1630			; Returns                                                                     : 
1630			;     HL  Address of the first useable byte of the allocation                 : 
1630			;                                                                             : 
1630			; Flags                                                                       : 
1630			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1630			;                                                                             : 
1630			; Stack frame                                                                 : 
1630			;       |             |                                                       : 
1630			;       +-------------+                                                       : 
1630			;       |     BC      |                                                       : 
1630			;       +-------------+                                                       : 
1630			;       |     DE      |                                                       : 
1630			;       +-------------+                                                       : 
1630			;       |     IX      |                                                       : 
1630			;       +-------------+                                                       : 
1630			;       |  prev_free  |                                                       : 
1630			;   +4  +-------------+                                                       : 
1630			;       |  this_free  |                                                       : 
1630			;   +2  +-------------+                                                       : 
1630			;       |  next_free  |                                                       : 
1630			;   +0  +-------------+                                                       : 
1630			;       |             |                                                       : 
1630			;                                                                             : 
1630			;------------------------------------------------------------------------------ 
1630			malloc: 
1630			      push  BC 
1630			      push  DE 
1630			      push  IX 
1630			 
1630			      ld    A, H                    ; Exit if no space requested 
1630			      or    L 
1630			      jp    Z, malloc_early_exit 
1630			 
1630			      ; Set up stack frame 
1630			      ex    DE, HL 
1630			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1630			      add   HL, SP 
1630			      ld    SP, HL 
1630			      ld    IX, 0                   ; Use IX as a frame pointer 
1630			      add   IX, SP 
1630			 
1630			      ; Setup initial state 
1630			      ld    HL, 4                   ; want must also include space used by block struct 
1630			      add   HL, DE 
1630			 
1630			      ld    B, H                    ; Move want to BC 
1630			      ld    C, L 
1630			 
1630			      ld    HL, free_list           ; Store prev_free ptr to stack 
1630			      ld    (IX+4), L 
1630			      ld    (IX+5), H 
1630			 
1630			      ld    E, (HL)                 ; Store this_free ptr to stack 
1630			      inc   HL 
1630			      ld    D, (HL) 
1630			      ld    (IX+2), E 
1630			      ld    (IX+3), D 
1630			      ex    DE, HL                  ; this_free ptr into HL 
1630			 
1630			      ; Loop through free block list to find some space 
1630			malloc_find_space: 
1630			      ld    E, (HL)                 ; Load next_free ptr into DE 
1630			      inc   HL 
1630			      ld    D, (HL) 
1630			 
1630			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1630			      or    E 
1630			      jp    Z, malloc_no_space 
1630			 
1630			      ld    (IX+0), E               ; Store next_free ptr to stack 
1630			      ld    (IX+1), D 
1630			 
1630			      ; Does this block have enough space to make the allocation? 
1630			      inc   HL                      ; Load free block size into DE 
1630			      ld    E, (HL) 
1630			      inc   HL 
1630			      ld    D, (HL) 
1630			 
1630			      ex    DE, HL                  ; Check size of block against want 
1630			      or    A                       ; Ensure carry flag clear 
1630			      sbc   HL, BC 
1630			      push  HL                      ; Store the result for later (new block size) 
1630			 
1630			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1630			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1630			 
1630			      ; this_free block is not big enough, setup ptrs to test next free block 
1630			      pop   HL                      ; Discard previous result 
1630			 
1630			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1630			      ld    H, (IX+3) 
1630			      ld    (IX+4), L 
1630			      ld    (IX+5), H 
1630			 
1630			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1630			      ld    H, (IX+1) 
1630			      ld    (IX+2), L 
1630			      ld    (IX+3), H 
1630			 
1630			      jr    malloc_find_space 
1630			 
1630			      ; split a bigger block into two - requested size and remaining size 
1630			malloc_alloc_split: 
1630			      ex    DE, HL                  ; Calculate address of new free block 
1630			      dec   HL 
1630			      dec   HL 
1630			      dec   HL 
1630			      add   HL, BC 
1630			 
1630			      ; Create a new block and point it at next_free 
1630			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1630			      ld    D, (IX+1) 
1630			 
1630			      ld    (HL), E                 ; Store next_free ptr into new block 
1630			      inc   HL 
1630			      ld    (HL), D 
1630			 
1630			      pop   DE                      ; Store size of new block into new block 
1630			      inc   HL 
1630			      ld    (HL), E 
1630			      inc   HL 
1630			      ld    (HL), D 
1630			 
1630			      ; Update this_free ptr to point to new block 
1630			      dec   HL 
1630			      dec   HL 
1630			      dec   HL 
1630			 
1630			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1630			      ld    D, (IX+3) 
1630			 
1630			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1630			      ld    (IX+3), H 
1630			 
1630			      ; Modify this_free block to be allocation 
1630			      ex    DE, HL 
1630			      xor   A                       ; Null the next block ptr of allocated block 
1630			      ld    (HL), A 
1630			      inc   HL 
1630			      ld    (HL), A 
1630			 
1630			      inc   HL                      ; Store want size into allocated block 
1630			      ld    (HL), C 
1630			      inc   HL 
1630			      ld    (HL), B 
1630			      inc   HL 
1630			      push  HL                      ; Address of allocation to return 
1630			 
1630			      jr    malloc_update_links 
1630			 
1630			malloc_alloc_fit: 
1630			      pop   HL                      ; Dont need new block size, want is exact fit 
1630			 
1630			      ; Modify this_free block to be allocation 
1630			      ex    DE, HL 
1630			      dec   HL 
1630			      dec   HL 
1630			      dec   HL 
1630			 
1630			      xor   A                       ; Null the next block ptr of allocated block 
1630			      ld    (HL), A 
1630			      inc   HL 
1630			      ld    (HL), A 
1630			 
1630			      inc   HL                      ; Store address of allocation to return 
1630			      inc   HL 
1630			      inc   HL 
1630			      push  HL 
1630			 
1630			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1630			      ld    L, (IX+0)               ; next_free to HL 
1630			      ld    H, (IX+1) 
1630			 
1630			      ld    (IX+2), L               ; HL to this_free 
1630			      ld    (IX+3), H 
1630			 
1630			 
1630			malloc_update_links: 
1630			      ; Update prev_free ptr to point to this_free 
1630			      ld    L, (IX+4)               ; prev_free ptr to HL 
1630			      ld    H, (IX+5) 
1630			 
1630			      ld    E, (IX+2)               ; this_free ptr to DE 
1630			      ld    D, (IX+3) 
1630			 
1630			      ld    (HL), E                 ; this_free ptr into prev_free 
1630			      inc   HL 
1630			      ld    (HL), D 
1630			 
1630			      ; Clear the Z flag to indicate successful allocation 
1630			      ld    A, D 
1630			      or    E 
1630			 
1630			      pop   DE                      ; Address of allocation 
1630			 
1630			malloc_no_space: 
1630			      ld    HL, 6                   ; Clean up stack frame 
1630			      add   HL, SP 
1630			      ld    SP, HL 
1630			 
1630			      ex    DE, HL                  ; Alloc addr into HL for return 
1630			 
1630			malloc_early_exit: 
1630			      pop   IX 
1630			      pop   DE 
1630			      pop   BC 
1630			 
1630			      ret 
1630			 
1630			 
1630			;------------------------------------------------------------------------------ 
1630			;     free                                                                    : 
1630			;                                                                             : 
1630			; Description                                                                 : 
1630			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1630			;     returned by malloc, otherwise the behaviour is undefined.               : 
1630			;                                                                             : 
1630			;     Where possible, directly adjacent free blocks will be merged together   : 
1630			;     into larger blocks to help ensure that the heap does not become         : 
1630			;     excessively fragmented.                                                 : 
1630			;                                                                             : 
1630			;     free does not clear or set any other value into the freed space, and    : 
1630			;     therefore its contents may be visible through subsequent malloc's. The  : 
1630			;     caller should clear the freed space as required.                        : 
1630			;                                                                             : 
1630			;     This implementation of free uses the stack exclusively, and is          : 
1630			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1630			;     advisable to disable interrupts before calling free, and recommended    : 
1630			;     to avoid the use of free inside ISRs in general.                        : 
1630			;                                                                             : 
1630			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1630			;                                                                             : 
1630			; Parameters                                                                  : 
1630			;     HL  Pointer to address of first byte of allocation to be freed          : 
1630			;                                                                             : 
1630			; Returns                                                                     : 
1630			;     Nothing                                                                 : 
1630			;                                                                             : 
1630			; Stack frame                                                                 : 
1630			;       |             |                                                       : 
1630			;       +-------------+                                                       : 
1630			;       |     BC      |                                                       : 
1630			;       +-------------+                                                       : 
1630			;       |     DE      |                                                       : 
1630			;       +-------------+                                                       : 
1630			;       |     IX      |                                                       : 
1630			;       +-------------+                                                       : 
1630			;       |  prev_free  |                                                       : 
1630			;   +2  +-------------+                                                       : 
1630			;       |  next_free  |                                                       : 
1630			;   +0  +-------------+                                                       : 
1630			;       |             |                                                       : 
1630			;                                                                             : 
1630			;------------------------------------------------------------------------------ 
1630			free: 
1630			      push  BC 
1630			      push  DE 
1630			      push  IX 
1630			 
1630			      ld    A, H                    ; Exit if ptr is null 
1630			      or    L 
1630			      jp    Z, free_early_exit 
1630			 
1630			      ; Set up stack frame 
1630			      ex    DE, HL 
1630			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1630			      add   HL, SP 
1630			      ld    SP, HL 
1630			      ld    IX, 0                   ; Use IX as a frame pointer 
1630			      add   IX, SP 
1630			 
1630			      ; The address in HL points to the start of the useable allocated space, 
1630			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1630			      ; address of the block itself. 
1630			      ex    DE, HL 
1630			      ld    DE, -4 
1630			      add   HL, DE 
1630			 
1630			      ; An allocated block must have a null next block pointer in it 
1630			      ld    A, (HL) 
1630			      inc   HL 
1630			      or    (HL) 
1630			      jp    NZ, free_done 
1630			 
1630			      dec   HL 
1630			 
1630			      ld    B, H                    ; Copy HL to BC 
1630			      ld    C, L 
1630			 
1630			      ; Loop through the free list to find the first block with an address 
1630			      ; higher than the block being freed 
1630			      ld    HL, free_list 
1630			 
1630			free_find_higher_block: 
1630			      ld    E, (HL)                 ; Load next ptr from free block 
1630			      inc   HL 
1630			      ld    D, (HL) 
1630			      dec   HL 
1630			 
1630			      ld    (IX+0), E               ; Save ptr to next free block 
1630			      ld    (IX+1), D 
1630			      ld    (IX+2), L               ; Save ptr to prev free block 
1630			      ld    (IX+3), H 
1630			 
1630			      ld    A, B                    ; Check if DE is greater than BC 
1630			      cp    D                       ; Compare MSB first 
1630			      jr    Z, $+4                  ; MSB the same, compare LSB 
1630			      jr    NC, free_find_higher_block_skip 
1630			      ld    A, C 
1630			      cp    E                       ; Then compare LSB 
1630			      jr    C, free_found_higher_block 
1630			 
1630			free_find_higher_block_skip: 
1630			      ld    A, D                    ; Reached the end of the free list? 
1630			      or    E 
1630			      jp    Z, free_done 
1630			 
1630			      ex    DE, HL 
1630			 
1630			      jr    free_find_higher_block 
1630			 
1630			free_found_higher_block: 
1630			      ; Insert freed block between prev and next free blocks 
1630			      ld    (HL), C                 ; Point prev free block to freed block 
1630			      inc   HL 
1630			      ld    (HL), B 
1630			 
1630			      ld    H, B                    ; Point freed block at next free block 
1630			      ld    L, C 
1630			      ld    (HL), E 
1630			      inc   HL 
1630			      ld    (HL), D 
1630			 
1630			      ; Check if the freed block is adjacent to the next free block 
1630			      inc   HL                      ; Load size of freed block into HL 
1630			      ld    E, (HL) 
1630			      inc   HL 
1630			      ld    D, (HL) 
1630			      ex    DE, HL 
1630			 
1630			      add   HL, BC                  ; Add addr of freed block and its size 
1630			 
1630			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1630			      ld    D, (IX+1) 
1630			 
1630			      or    A                       ; Clear the carry flag 
1630			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1630			      jr    NZ, free_check_adjacent_to_prev 
1630			 
1630			      ; Freed block is adjacent to next, merge into one bigger block 
1630			      ex    DE, HL                  ; Load next ptr from next block into DE 
1630			      ld    E, (HL) 
1630			      inc   HL 
1630			      ld    D, (HL) 
1630			      push  HL                      ; Save ptr to next block for later 
1630			 
1630			      ld    H, B                    ; Store ptr from next block into freed block 
1630			      ld    L, C 
1630			      ld    (HL), E 
1630			      inc   HL 
1630			      ld    (HL), D 
1630			 
1630			      pop   HL                      ; Restore ptr to next block 
1630			      inc   HL                      ; Load size of next block into DE 
1630			      ld    E, (HL) 
1630			      inc   HL 
1630			      ld    D, (HL) 
1630			      push  DE                      ; Save next block size for later 
1630			 
1630			      ld    H, B                    ; Load size of freed block into HL 
1630			      ld    L, C 
1630			      inc   HL 
1630			      inc   HL 
1630			      ld    E, (HL) 
1630			      inc   HL 
1630			      ld    D, (HL) 
1630			      ex    DE, HL 
1630			 
1630			      pop   DE                      ; Restore size of next block 
1630			      add   HL, DE                  ; Add sizes of both blocks 
1630			      ex    DE, HL 
1630			 
1630			      ld    H, B                    ; Store new bigger size into freed block 
1630			      ld    L, C 
1630			      inc   HL 
1630			      inc   HL 
1630			      ld    (HL), E 
1630			      inc   HL 
1630			      ld    (HL), D 
1630			 
1630			free_check_adjacent_to_prev: 
1630			      ; Check if the freed block is adjacent to the prev free block 
1630			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1630			      ld    H, (IX+3) 
1630			 
1630			      inc   HL                      ; Size of prev free block into DE 
1630			      inc   HL 
1630			      ld    E, (HL) 
1630			      inc   HL 
1630			      ld    D, (HL) 
1630			      dec   HL 
1630			      dec   HL 
1630			      dec   HL 
1630			 
1630			      add   HL, DE                  ; Add prev block addr and size 
1630			 
1630			      or    A                       ; Clear the carry flag 
1630			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1630			      jr    NZ, free_done 
1630			 
1630			      ; Freed block is adjacent to prev, merge into one bigger block 
1630			      ld    H, B                    ; Load next ptr from freed block into DE 
1630			      ld    L, C 
1630			      ld    E, (HL) 
1630			      inc   HL 
1630			      ld    D, (HL) 
1630			      push  HL                      ; Save freed block ptr for later 
1630			 
1630			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1630			      ld    H, (IX+3) 
1630			      ld    (HL), E 
1630			      inc   HL 
1630			      ld    (HL), D 
1630			 
1630			      pop   HL                      ; Restore freed block ptr 
1630			      inc   HL                      ; Load size of freed block into DE 
1630			      ld    E, (HL) 
1630			      inc   HL 
1630			      ld    D, (HL) 
1630			      push  DE                      ; Save freed block size for later 
1630			 
1630			      ld    L, (IX+2)               ; Load size of prev block into DE 
1630			      ld    H, (IX+3) 
1630			      inc   HL 
1630			      inc   HL 
1630			      ld    E, (HL) 
1630			      inc   HL 
1630			      ld    D, (HL) 
1630			 
1630			      pop   HL                      ; Add sizes of both blocks 
1630			      add   HL, DE 
1630			      ex    DE, HL 
1630			 
1630			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1630			      ld    H, (IX+3) 
1630			      inc   HL 
1630			      inc   HL 
1630			      ld    (HL), E 
1630			      inc   HL 
1630			      ld    (HL), D 
1630			 
1630			free_done: 
1630			      ld    HL, 4                   ; Clean up stack frame 
1630			      add   HL, SP 
1630			      ld    SP, HL 
1630			 
1630			free_early_exit: 
1630			      pop   IX 
1630			      pop   DE 
1630			      pop   BC 
1630			 
1630			      ret 
1630			 
1630			 
1630			;      .org 0x8000 
1630			; 
1630			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1630			 ;                 .dw   0 
1630			 
1630			endif 
1630			 
1630			 
1630			if MALLOC_4 
1630			 
1630			; My memory allocation code. Very very simple.... 
1630			; allocate space under 250 chars 
1630			 
1630			heap_init: 
1630				; init start of heap as zero 
1630				;  
1630			 
1630				ld hl, heap_start 
1630				ld a, 0 
1630				ld (hl), a      ; empty block 
1630				inc hl 
1630				ld a, 0 
1630				ld (hl), a      ; length of block 
1630				; write end of list 
1630				inc hl 
1630				ld a,(hl) 
1630				inc hl 
1630				ld a,(hl) 
1630				 
1630			 
1630				; init some malloc vars 
1630			 
1630				ld hl, 0 
1630				ld (free_list), hl       ; store last malloc location 
1630			 
1630				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1630				ld a, 0 
1630				ld (hl), a 
1630			 
1630			 
1630				ld hl, heap_start 
1630				;  
1630				  
1630				ret 
1630			 
1630			 
1630			;    free block marker 
1630			;    requested size  
1630			;    pointer to next block 
1630			;    .... 
1630			;    next block marker 
1630			 
1630			 
1630			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1630			; 
1630			 
1630			 
1630			malloc:  
1630				push de 
1630				push bc 
1630				push af 
1630			 
1630				; hl space required 
1630				 
1630				ld c, l    ; hold space   (TODO only a max of 255) 
1630			 
1630			;	inc c     ; TODO BUG need to fix memory leak on push str 
1630			;	inc c 
1630			;	inc c 
1630			;	inc c 
1630			;	inc c 
1630			;	inc c 
1630			;	inc c 
1630			 
1630			 
1630			 
1630				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1630			 
1630				ld a, (free_list+3) 
1630				cp 0 
1630				jr z, .contheap 
1630			 
1630				ld hl, (free_list)     ; get last alloc 
1630					if DEBUG_FORTH_MALLOC_INT 
1630						DMARK "mrs" 
1630						CALLMONITOR 
1630					endif 
1630				jr .startalloc 
1630			 
1630			.contheap: 
1630				ld hl, heap_start 
1630			 
1630			.startalloc: 
1630			 
1630					if DEBUG_FORTH_MALLOC_INT 
1630						DMARK "mym" 
1630						CALLMONITOR 
1630					endif 
1630			.findblock: 
1630					if DEBUG_FORTH_MALLOC_INT 
1630						DMARK "mmf" 
1630						CALLMONITOR 
1630					endif 
1630			 
1630				ld a,(hl)  
1630				; if byte is zero then clear to use 
1630			 
1630				cp 0 
1630				jr z, .foundemptyblock 
1630			 
1630				; if byte is not clear 
1630				;     then byte is offset to next block 
1630			 
1630				inc hl 
1630				ld a, (hl) ; get size 
1630			.nextblock:	inc hl 
1630					ld e, (hl) 
1630					inc hl 
1630					ld d, (hl) 
1630					ex de, hl 
1630			;	inc hl  ; move past the store space 
1630			;	inc hl  ; move past zero index  
1630			 
1630				; TODO detect no more space 
1630			 
1630				push hl 
1630				ld de, heap_end 
1630				call cmp16 
1630				pop hl 
1630				jr nc, .nospace 
1630			 
1630				jr .findblock 
1630			 
1630			.nospace: ld hl, 0 
1630				jp .exit 
1630			 
1630			 
1630			.foundemptyblock:	 
1630					if DEBUG_FORTH_MALLOC_INT 
1630						DMARK "mme" 
1630						CALLMONITOR 
1630					endif 
1630			 
1630			; TODO has block enough space if reusing??? 
1630			 
1630				;  
1630			 
1630			; see if this block has been previously used 
1630				inc hl 
1630				ld a, (hl) 
1630				dec hl 
1630				cp 0 
1630				jr z, .newblock 
1630			 
1630					if DEBUG_FORTH_MALLOC_INT 
1630						DMARK "meR" 
1630						CALLMONITOR 
1630					endif 
1630			 
1630			; no reusing previously allocated block 
1630			 
1630			; is it smaller than previously used? 
1630				 
1630				inc hl    ; move to size 
1630				ld a, c 
1630				sub (hl)        ; we want c < (hl) 
1630				dec hl    ; move back to marker 
1630			        jr z, .findblock 
1630			 
1630				; update with the new size which should be lower 
1630			 
1630			        ;inc  hl   ; negate next move. move back to size  
1630			 
1630			.newblock: 
1630				; need to be at marker here 
1630			 
1630					if DEBUG_FORTH_MALLOC_INT 
1630						DMARK "meN" 
1630						CALLMONITOR 
1630					endif 
1630			 
1630			 
1630				ld a, c 
1630			 
1630				ld (free_list+3), a	 ; flag resume from last malloc  
1630				ld (free_list), hl    ; save out last location 
1630			 
1630			 
1630				;inc a     ; space for length byte 
1630				ld (hl), a     ; save block in use marker 
1630			 
1630				inc hl   ; move to space marker 
1630				ld (hl), a    ; save new space 
1630			 
1630				inc hl   ; move to start of allocated area 
1630				 
1630			;	push hl     ; save where we are - 1  
1630			 
1630			;	inc hl  ; move past zero index  
1630				; skip space to set down new marker 
1630			 
1630				; provide some extra space for now 
1630			 
1630				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1630				inc a 
1630				inc a 
1630			 
1630				push hl   ; save where we are in the node block 
1630			 
1630				call addatohl 
1630			 
1630				; write linked list point 
1630			 
1630				pop de     ; get our node position 
1630				ex de, hl 
1630			 
1630				ld (hl), e 
1630				inc hl 
1630				ld (hl), d 
1630			 
1630				inc hl 
1630			 
1630				; now at start of allocated data so save pointer 
1630			 
1630				push hl 
1630			 
1630				; jump to position of next node and setup empty header in DE 
1630			 
1630				ex de, hl 
1630			 
1630			;	inc hl ; move past end of block 
1630			 
1630				ld a, 0 
1630				ld (hl), a   ; empty marker 
1630				inc hl 
1630				ld (hl), a   ; size 
1630				inc hl  
1630				ld (hl), a   ; ptr 
1630				inc hl 
1630				ld (hl), a   ; ptr 
1630			 
1630			 
1630				pop hl 
1630			 
1630					if DEBUG_FORTH_MALLOC_INT 
1630						DMARK "mmr" 
1630						CALLMONITOR 
1630					endif 
1630			 
1630			.exit: 
1630				pop af 
1630				pop bc 
1630				pop de  
1630				ret 
1630			 
1630			 
1630			 
1630			 
1630			free:  
1630				push hl 
1630				push af 
1630				; get address in hl 
1630			 
1630					if DEBUG_FORTH_MALLOC_INT 
1630						DMARK "fre" 
1630						CALLMONITOR 
1630					endif 
1630				; data is at hl - move to block count 
1630				dec hl 
1630				dec hl    ; get past pointer 
1630				dec hl 
1630			 
1630				ld a, (hl)    ; need this for a validation check 
1630			 
1630				dec hl    ; move to block marker 
1630			 
1630				; now check that the block count and block marker are the same  
1630			        ; this checks that we are on a malloc node and not random memory 
1630			        ; OK a faint chance this could be a problem but rare - famous last words! 
1630			 
1630				ld c, a 
1630				ld a, (hl)    
1630			 
1630				cp c 
1630				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1630			 
1630				; yes good chance we are on a malloc node 
1630			 
1630				ld a, 0      
1630				ld (hl), a   ; mark as free 
1630			 
1630				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1630			 
1630			.freeignore:  
1630			 
1630				pop af 
1630				pop hl 
1630			 
1630				ret 
1630			 
1630			 
1630			 
1630			endif 
1630			 
1630			; eof 
# End of file firmware_memory.asm
1630			  
1630			; device C  
1630			; Now handled by SPI  
1630			;if SOUND_ENABLE  
1630			;	include "firmware_sound.asm"  
1630			;endif  
1630			  
1630			include "firmware_diags.asm"  
1630			; Hardware diags menu 
1630			 
1630			 
1630			config: 
1630			 
1630 3e 00			ld a, 0 
1632 21 5b 16			ld hl, .configmn 
1635 cd cd 0d			call menu 
1638			 
1638 fe 00			cp 0 
163a c8				ret z 
163b			 
163b			;	cp 1 
163b			;	call z, .savetostore 
163b			 
163b fe 01			cp 1 
163d			if STARTUP_V1 
163d				call z, .selautoload 
163d			endif 
163d			 
163d			if STARTUP_V2 
163d cc 69 16			call z, .enautoload 
1640			endif 
1640 fe 02			cp 2 
1642 cc 80 16			call z, .disautoload 
1645			;	cp 3 
1645			;	call z, .selbank 
1645 fe 03			cp 3 
1647 cc fa 18			call z, .debug_tog 
164a fe 04			cp 4 
164c cc 48 1a			call z, .bpsgo 
164f fe 05			cp 5 
1651 cc 23 19			call z, hardware_diags 
1654			if STARTUP_V2 
1654 fe 06			cp 6 
1656 cc ac 16			call z, create_startup 
1659			endif 
1659 18 d5			jr config 
165b			 
165b			.configmn: 
165b			;	dw prom_c3 
165b 36 1c			dw prom_c2 
165d 4c 1c			dw prom_c2a 
165f			;	dw prom_c2b 
165f			;	dw prom_c4 
165f bb 1c			dw prom_m4 
1661 d6 1c			dw prom_m4b 
1663 de 1c			dw prom_c1 
1665			if STARTUP_V2 
1665 ed 1c			dw prom_c9 
1667			endif 
1667 00 00			dw 0 
1669				 
1669			 
1669			if STARTUP_V2 
1669			.enautoload: 
1669				if STORAGE_SE 
1669 3e fe			ld a, $fe      ; bit 0 clear 
166b 32 5d fa			ld (spi_device), a 
166e			 
166e cd 17 05			call storage_get_block_0 
1671			 
1671 3e 01			ld a, 1 
1673 32 98 fa			ld (store_page+STORE_0_AUTOFILE), a 
1676			 
1676 21 00 00				ld hl, 0 
1679 11 77 fa				ld de, store_page 
167c cd cb 04			call storage_write_block	 ; save update 
167f				else 
167f			 
167f				ld hl, prom_notav 
167f				ld de, prom_empty 
167f				call info_panel 
167f				endif 
167f			 
167f			 
167f c9				ret 
1680			endif 
1680			 
1680			.disautoload: 
1680				if STORAGE_SE 
1680 3e fe			ld a, $fe      ; bit 0 clear 
1682 32 5d fa			ld (spi_device), a 
1685			 
1685 cd 17 05			call storage_get_block_0 
1688			 
1688 3e 00			ld a, 0 
168a 32 98 fa			ld (store_page+STORE_0_AUTOFILE), a 
168d			 
168d 21 00 00				ld hl, 0 
1690 11 77 fa				ld de, store_page 
1693 cd cb 04			call storage_write_block	 ; save update 
1696				else 
1696			 
1696				ld hl, prom_notav 
1696				ld de, prom_empty 
1696				call info_panel 
1696				endif 
1696			 
1696			 
1696 c9				ret 
1697			 
1697			if STARTUP_V1 
1697			 
1697			; Select auto start 
1697			 
1697			.selautoload: 
1697			 
1697				 
1697				if STORAGE_SE 
1697			 
1697					call config_dir 
1697				        ld hl, scratch 
1697					ld a, 0 
1697					call menu 
1697			 
1697					cp 0 
1697					ret z 
1697			 
1697					dec a 
1697			 
1697			 
1697					; locate menu option 
1697			 
1697					ld hl, scratch 
1697					call table_lookup 
1697			 
1697					if DEBUG_FORTH_WORDS 
1697						DMARK "ALl" 
1697						CALLMONITOR 
1697					endif 
1697					; with the pointer to the menu it, the byte following the zero term is the file id 
1697			 
1697					ld a, 0 
1697					ld bc, 50   ; max of bytes to look at 
1697					cpir  
1697			 
1697					if DEBUG_FORTH_WORDS 
1697						DMARK "ALb" 
1697						CALLMONITOR 
1697					endif 
1697					;inc hl 
1697			 
1697					ld a, (hl)   ; file id 
1697					 
1697				        ; save bank and file ids 
1697			 
1697					push af 
1697			 
1697			; TODO need to save to block 0 on bank 1	 
1697			 
1697					call storage_get_block_0 
1697			 
1697					if DEBUG_FORTH_WORDS 
1697						DMARK "AL0" 
1697						CALLMONITOR 
1697					endif 
1697					pop af 
1697			 
1697					ld (store_page+STORE_0_FILERUN),a 
1697					 
1697					; save bank id 
1697			 
1697					ld a,(spi_device) 
1697					ld (store_page+STORE_0_BANKRUN),a 
1697			 
1697					; enable auto run of store file 
1697			 
1697					ld a, 1 
1697					ld (store_page+STORE_0_AUTOFILE),a 
1697			 
1697					; save buffer 
1697			 
1697					ld hl, 0 
1697					ld de, store_page 
1697					if DEBUG_FORTH_WORDS 
1697						DMARK "ALw" 
1697						CALLMONITOR 
1697					endif 
1697				call storage_write_block	 ; save update 
1697			  
1697			 
1697			 
1697			 
1697					ld hl, scratch 
1697					call config_fdir 
1697			 
1697				else 
1697			 
1697				ld hl, prom_notav 
1697				ld de, prom_empty 
1697				call info_panel 
1697			 
1697				endif 
1697				ret 
1697			endif 
1697			 
1697			 
1697			; Select storage bank 
1697			 
1697			.selbank: 
1697			 
1697			;	if STORAGE_SE 
1697			;	else 
1697			 
1697 21 02 1d			ld hl, prom_notav 
169a 11 18 1d			ld de, prom_empty 
169d cd 2d 0d			call info_panel 
16a0			;	endif 
16a0				 
16a0 c9				ret 
16a1			 
16a1			if STORAGE_SE 
16a1			 
16a1			.config_ldir:   
16a1				; Load storage bank labels into menu array 
16a1			 
16a1				 
16a1			 
16a1			 
16a1 c9				ret 
16a2			 
16a2			 
16a2			endif 
16a2			 
16a2			 
16a2			; Save user words to storage 
16a2			 
16a2			.savetostore: 
16a2			 
16a2			;	if STORAGE_SE 
16a2			; 
16a2			;		call config_dir 
16a2			;	        ld hl, scratch 
16a2			;		ld a, 0 
16a2			;		call menu 
16a2			;		 
16a2			;		ld hl, scratch 
16a2			;		call config_fdir 
16a2			; 
16a2			;	else 
16a2			 
16a2 21 02 1d			ld hl, prom_notav 
16a5 11 18 1d			ld de, prom_empty 
16a8 cd 2d 0d			call info_panel 
16ab			 
16ab			;	endif 
16ab			 
16ab c9				ret 
16ac			 
16ac			if STARTUP_V2 
16ac			 
16ac			create_startup: 
16ac			 
16ac 3e 00			ld a, 0 
16ae 21 21 18			ld hl, .crstart 
16b1 cd cd 0d			call menu 
16b4			 
16b4 fe 00			cp 0 
16b6 c8				ret z 
16b7			 
16b7 fe 01			cp 1 
16b9 cc e6 16			call z, .genlsword 
16bc fe 02			cp 2 
16be cc f0 16			call z, .genedword 
16c1			 
16c1 fe 03			cp 3 
16c3 cc fa 16			call z, .gendemword 
16c6			 
16c6 fe 04			cp 4 
16c8 cc 04 17			call z, .genutlword 
16cb fe 05			cp 5 
16cd cc 0e 17			call z, .genspiword 
16d0 fe 06			cp 6 
16d2 cc 18 17			call z, .genkeyword 
16d5 fe 07			cp 7 
16d7 cc dc 16			call z, .gensoundword 
16da 18 d0			jr create_startup 
16dc			 
16dc			.gensoundword: 
16dc 21 a6 1c			ld hl, crs_sound 
16df 11 65 17			ld de, .soundworddef 
16e2 cd 22 17			call .genfile 
16e5 c9				ret 
16e6			.genlsword: 
16e6 21 63 1c			ld hl, crs_s1 
16e9 11 8d 17			ld de, .lsworddef 
16ec cd 22 17			call .genfile 
16ef c9				ret 
16f0			 
16f0			.genedword: 
16f0 11 91 17			ld de, .edworddef 
16f3 21 6c 1c			ld hl, crs_s2 
16f6 cd 22 17			call .genfile 
16f9 c9				ret 
16fa			 
16fa			.gendemword: 
16fa 11 99 17			ld de, .demoworddef 
16fd 21 75 1c			ld hl, crs_s3 
1700 cd 22 17			call .genfile 
1703 c9				ret 
1704			 
1704			.genutlword: 
1704 21 84 1c			ld hl, crs_s4 
1707 11 79 17			ld de, .utilwordef 
170a cd 22 17			call .genfile 
170d c9				ret 
170e			.genspiword: 
170e 21 8b 1c			ld hl, crs_s5 
1711 11 df 17			ld de, .spiworddef 
1714 cd 22 17			call .genfile 
1717 c9				ret 
1718			.genkeyword: 
1718 21 97 1c			ld hl, crs_s6 
171b 11 f5 17			ld de, .keyworddef 
171e cd 22 17			call .genfile 
1721 c9				ret 
1722			 
1722			; hl - points to file name 
1722			; de - points to strings to add to file 
1722			 
1722			.genfile: 
1722 e5				push hl 
1723 d5				push de 
1724			 
1724 cd 9c 0d			call clear_display 
1727 3e 00			ld a, display_row_1 
1729 11 54 17			ld de, .genfiletxt 
172c cd af 0d			call str_at_display 
172f cd bf 0d			call update_display 
1732			 
1732 d1				pop de 
1733 e1				pop hl 
1734			 
1734			 
1734 d5				push de 
1735 cd 69 08			call storage_create 
1738				; id in hl 
1738 d1				pop de   ; table of strings to add 
1739			 
1739			.genloop: 
1739			 
1739 e5				push hl ; save id for next time around 
173a d5				push de ; save de for next time around 
173b			 
173b eb				ex de, hl 
173c cd 33 24			call loadwordinhl 
173f eb				ex de, hl 
1740			 
1740				; need hl to be the id 
1740				; need de to be the string ptr 
1740				 
1740 cd 56 0b			call storage_append 
1743			 
1743 d1				pop de 
1744 e1				pop hl 
1745			 
1745 13				inc de 
1746 13				inc de 
1747			 
1747 1a				ld a,(de) 
1748 fe 00			cp 0 
174a 20 ed			jr nz, .genloop 
174c 13				inc de 
174d 1a				ld a, (de) 
174e 1b				dec de 
174f fe 00			cp 0 
1751 20 e6			jr nz, .genloop	 
1753			 
1753 c9				ret 
1754			 
1754 .. 00		.genfiletxt:  db "Creating file...",0 
1765			 
1765			.soundworddef: 
1765 11 6a			dw sound1 
1767 35 6a			dw sound2 
1769 65 6a			dw sound3 
176b 8a 6a			dw sound4 
176d 97 6a			dw sound5 
176f a4 6a			dw sound6 
1771 b1 6a			dw sound7 
1773 be 6a			dw sound8 
1775 d6 6a			dw sound9 
1777 00 00			dw 0 
1779			 
1779			.utilwordef: 
1779 62 63			dw strncpy 
177b 3d 63			dw type 
177d 09 63			dw clrstack 
177f c2 62			dw longread 
1781 c3 63			dw start1 
1783 d3 63			dw start2 
1785 e4 63			dw start3b 
1787 5f 64			dw start3c 
1789 bf 64			dw list 
178b 00 00			dw 0 
178d			 
178d			.lsworddef: 
178d e4 63			dw start3b 
178f 00 00			dw 0 
1791			 
1791			.edworddef: 
1791 4b 5f			dw edit1 
1793 6c 5f			dw edit2 
1795 a1 5f			dw edit3 
1797 00 00			dw 0 
1799			 
1799			.demoworddef: 
1799 07 69			dw test5 
179b 3f 69			dw test6 
179d 77 69			dw test7 
179f 8b 69			dw test8 
17a1 b7 69			dw test9 
17a3 cd 69			dw test10 
17a5 ed 6a			dw game1 
17a7 fe 6a			dw game1a 
17a9 60 6b			dw game1b 
17ab 95 6b			dw game1c 
17ad cb 6b			dw game1d 
17af fc 6b			dw game1s 
17b1 10 6c			dw game1t 
17b3 25 6c			dw game1f 
17b5 59 6c			dw game1z 
17b7 9d 6c			dw game1zz 
17b9 06 6d			dw ssv2 
17bb 3c 6d			dw ssv3 
17bd 58 6d			dw ssv4 
17bf 74 6d			dw ssv5 
17c1 8d 6d			dw ssv1 
17c3 d5 6d			dw ssv1cpm	 
17c5 2c 6e			dw game2b 
17c7 9a 6e			dw game2bf 
17c9 e4 6e			dw game2mba 
17cb 7a 6f			dw game2mbas	 
17cd 9f 6f			dw game2mbht 
17cf ae 6f			dw game2mbms 
17d1 bc 6f			dw game2mb 
17d3 39 70			dw game3w 
17d5 67 70			dw game3p 
17d7 85 70			dw game3sc 
17d9 b6 70			dw game3vsi 
17db e2 70			dw game3vs 
17dd 00 00			dw 0 
17df			 
17df			 
17df			.spiworddef: 
17df			 
17df d9 5f		    dw spi1 
17e1 32 60		    dw spi2 
17e3 c0 60		    dw spi3 
17e5 68 60		    dw spi4 
17e7 93 60		    dw spi5 
17e9 26 61		    dw spi6 
17eb 7b 61		    dw spi7 
17ed			 
17ed d3 61		    dw spi8 
17ef f2 61		    dw spi9 
17f1 4a 62		    dw spi10 
17f3 00 00		    dw 0 
17f5			 
17f5			.keyworddef: 
17f5			 
17f5 21 71			dw keyup 
17f7 2f 71			dw keydown 
17f9 3f 71			dw keyleft 
17fb 4f 71			dw keyright 
17fd 60 71			dw 	keyf1 
17ff 6e 71			dw keyf2 
1801 7c 71			dw keyf3 
1803 8a 71			dw keyf4 
1805 98 71			dw keyf5 
1807 a6 71			dw keyf6 
1809 b4 71			dw keyf7 
180b c2 71			dw keyf8 
180d d0 71			dw keyf9 
180f de 71			dw keyf10 
1811 ed 71			dw keyf11 
1813 fc 71			dw keyf12 
1815 0b 72			dw keytab 
1817 1a 72			dw keycr 
1819 28 72			dw keyhome 
181b 38 72			dw keyend 
181d 47 72			dw keybs 
181f 00 00			dw 0 
1821			 
1821			.crstart: 
1821 63 1c			dw crs_s1 
1823 6c 1c			dw crs_s2 
1825 75 1c			dw crs_s3 
1827 84 1c			dw crs_s4 
1829 8b 1c			dw crs_s5 
182b 97 1c			dw crs_s6 
182d a6 1c			dw crs_sound 
182f 00 00			dw 0 
1831			 
1831			endif 
1831			 
1831			 
1831			if STORAGE_SE 
1831			 
1831			config_fdir: 
1831				; using the scratch dir go through and release the memory allocated for each string 
1831				 
1831 21 be f1			ld hl, scratch 
1834 5e			.cfdir:	ld e,(hl) 
1835 23				inc hl 
1836 56				ld d,(hl) 
1837 23				inc hl 
1838			 
1838 eb				ex de, hl 
1839 cd f9 0f			call ishlzero 
183c c8				ret z     ; return on null pointer 
183d cd 61 15			call free 
1840 eb				ex de, hl 
1841 18 f1			jr .cfdir 
1843			 
1843			 
1843 c9				ret 
1844			 
1844			 
1844			config_dir: 
1844			 
1844				; for the config menus that need to build a directory of storage call this routine 
1844				; it will construct a menu in scratch to pass to menu 
1844			 
1844				; open storage device 
1844			 
1844				; execute DIR to build a list of files and their ids into scratch in menu format 
1844				; once the menu has finished then will need to call config_fdir to release the strings 
1844				 
1844				; c = number items 
1844			 
1844				 
1844 cd 17 05			call storage_get_block_0 
1847			 
1847 21 77 fa			ld hl, store_page     ; get current id count 
184a 46				ld b, (hl) 
184b 0e 00			ld c, 0    ; count of files   
184d			 
184d			 
184d 21 be f1			ld hl, scratch 
1850 22 6e fa			ld (store_tmp2), hl    ; location to poke strings 
1853			 
1853				; check for empty drive 
1853			 
1853 3e 00			ld a, 0 
1855 b8				cp b 
1856 ca f0 18			jp z, .dirdone 
1859			 
1859				 
1859					if DEBUG_FORTH_WORDS 
1859						DMARK "Cdc" 
1859 f5				push af  
185a 3a 6e 18			ld a, (.dmark)  
185d 32 68 fe			ld (debug_mark),a  
1860 3a 6f 18			ld a, (.dmark+1)  
1863 32 69 fe			ld (debug_mark+1),a  
1866 3a 70 18			ld a, (.dmark+2)  
1869 32 6a fe			ld (debug_mark+2),a  
186c 18 03			jr .pastdmark  
186e ..			.dmark: db "Cdc"  
1871 f1			.pastdmark: pop af  
1872			endm  
# End of macro DMARK
1872						CALLMONITOR 
1872 cd 6c fe			call debug_vector  
1875				endm  
# End of macro CALLMONITOR
1875					endif 
1875			 
1875			 
1875			.diritem:	 
1875 c5				push bc 
1876				; for each of the current ids do a search for them and if found push to stack 
1876			 
1876 21 40 00				ld hl, STORE_BLOCK_PHY 
1879 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
187b 58					ld e,b 
187c			 
187c cd 99 07				call storage_findnextid 
187f			 
187f			 
187f					; if found hl will be non zero 
187f			 
187f cd f9 0f				call ishlzero 
1882 28 69				jr z, .dirnotfound 
1884			 
1884					; increase count 
1884			 
1884 c1					pop bc	 
1885 0c					inc c 
1886 c5					push bc 
1887					 
1887			 
1887					; get file header and push the file name 
1887			 
1887 11 77 fa				ld de, store_page 
188a cd 66 04				call storage_read_block 
188d			 
188d					; push file id to stack 
188d				 
188d 3a 77 fa				ld a, (store_page) 
1890 26 00				ld h, 0 
1892 6f					ld l, a 
1893			 
1893					;call forth_push_numhl 
1893					; TODO store id 
1893			 
1893 e5					push hl 
1894			 
1894					; push extent count to stack  
1894				 
1894 21 7a fa				ld hl, store_page+3 
1897			 
1897					; get file name length 
1897			 
1897 cd 2e 14				call strlenz   
189a			 
189a 23					inc hl   ; cover zero term 
189b 23					inc hl  ; stick the id at the end of the area 
189c			 
189c e5					push hl 
189d c1					pop bc    ; move length to bc 
189e			 
189e cd 97 14				call malloc 
18a1			 
18a1					; TODO save malloc area to scratch 
18a1			 
18a1 eb					ex de, hl 
18a2 2a 6e fa				ld hl, (store_tmp2) 
18a5 73					ld (hl), e 
18a6 23					inc hl 
18a7 72					ld (hl), d 
18a8 23					inc hl 
18a9 22 6e fa				ld (store_tmp2), hl 
18ac			 
18ac					 
18ac			 
18ac					;pop hl   ; get source 
18ac			;		ex de, hl    ; swap aronund	 
18ac			 
18ac 21 7a fa				ld hl, store_page+3 
18af					if DEBUG_FORTH_WORDS 
18af						DMARK "CFd" 
18af f5				push af  
18b0 3a c4 18			ld a, (.dmark)  
18b3 32 68 fe			ld (debug_mark),a  
18b6 3a c5 18			ld a, (.dmark+1)  
18b9 32 69 fe			ld (debug_mark+1),a  
18bc 3a c6 18			ld a, (.dmark+2)  
18bf 32 6a fe			ld (debug_mark+2),a  
18c2 18 03			jr .pastdmark  
18c4 ..			.dmark: db "CFd"  
18c7 f1			.pastdmark: pop af  
18c8			endm  
# End of macro DMARK
18c8						CALLMONITOR 
18c8 cd 6c fe			call debug_vector  
18cb				endm  
# End of macro CALLMONITOR
18cb					endif 
18cb ed b0				ldir 
18cd			 
18cd					; de is past string, move back one and store id 
18cd					 
18cd 1b					dec de 
18ce			 
18ce					; store file id 
18ce			 
18ce e1					pop hl 
18cf eb					ex de,hl 
18d0 73					ld (hl), e 
18d1			 
18d1					if DEBUG_FORTH_WORDS 
18d1						DMARK "Cdi" 
18d1 f5				push af  
18d2 3a e6 18			ld a, (.dmark)  
18d5 32 68 fe			ld (debug_mark),a  
18d8 3a e7 18			ld a, (.dmark+1)  
18db 32 69 fe			ld (debug_mark+1),a  
18de 3a e8 18			ld a, (.dmark+2)  
18e1 32 6a fe			ld (debug_mark+2),a  
18e4 18 03			jr .pastdmark  
18e6 ..			.dmark: db "Cdi"  
18e9 f1			.pastdmark: pop af  
18ea			endm  
# End of macro DMARK
18ea						CALLMONITOR 
18ea cd 6c fe			call debug_vector  
18ed				endm  
# End of macro CALLMONITOR
18ed					endif 
18ed					 
18ed			.dirnotfound: 
18ed c1					pop bc     
18ee 10 85				djnz .diritem 
18f0				 
18f0			.dirdone:	 
18f0			 
18f0 3e 00				ld a, 0 
18f2 2a 6e fa				ld hl, (store_tmp2) 
18f5 77					ld (hl), a 
18f6 23					inc hl 
18f7 77					ld (hl), a 
18f8 23					inc hl 
18f9					; push a count of the dir items found 
18f9			 
18f9			;		ld h, 0 
18f9			;		ld l, c 
18f9			 
18f9 c9				ret 
18fa			 
18fa			endif 
18fa			 
18fa			 
18fa			; Settings 
18fa			; Run  
18fa			 
18fa			 
18fa			 
18fa			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
18fa			;;hd_menu2:   db "        2: Editor",0   
18fa			;hd_menu2:   db "        2: Editor       6: Menu",0   
18fa			;hd_menu3:   db "        3: Storage",0 
18fa			;hd_menu4:   db "0=quit  4: Debug",0 
18fa			;hd_don:     db "ON",0 
18fa			;hd_doff:     db "OFF",0 
18fa			; 
18fa			; 
18fa			; 
18fa			;hardware_diags_old:       
18fa			; 
18fa			;.diagmenu: 
18fa			;	call clear_display 
18fa			;	ld a, display_row_1 
18fa			;	ld de, hd_menu1 
18fa			;	call str_at_display 
18fa			; 
18fa			;	ld a, display_row_2 
18fa			;	ld de, hd_menu2 
18fa			;	call str_at_display 
18fa			; 
18fa			;	ld a, display_row_3 
18fa			;	ld de, hd_menu3 
18fa			;	call str_at_display 
18fa			; 
18fa			;	ld a,  display_row_4 
18fa			;	ld de, hd_menu4 
18fa			;	call str_at_display 
18fa			; 
18fa			;	; display debug state 
18fa			; 
18fa			;	ld de, hd_don 
18fa			;	ld a, (os_view_disable) 
18fa			;	cp 0 
18fa			;	jr z, .distog 
18fa			;	ld de, hd_doff 
18fa			;.distog: ld a, display_row_4+17 
18fa			;	call str_at_display 
18fa			; 
18fa			;	call update_display 
18fa			; 
18fa			;	call cin_wait 
18fa			; 
18fa			; 
18fa			; 
18fa			;	cp '4' 
18fa			;	jr nz, .diagn1 
18fa			; 
18fa			;	; debug toggle 
18fa			; 
18fa			;	ld a, (os_view_disable) 
18fa			;	ld b, '*' 
18fa			;	cp 0 
18fa			;	jr z, .debtog 
18fa			;	ld b, 0 
18fa			;.debtog:	 
18fa			;	ld a,b 
18fa			;	ld (os_view_disable),a 
18fa			; 
18fa			;.diagn1: cp '0' 
18fa			;	 ret z 
18fa			; 
18fa			;;	cp '1' 
18fa			;;       jp z, matrix	 
18fa			;;   TODO keyboard matrix test 
18fa			; 
18fa			;	cp '2' 
18fa			;	jp z, .diagedit 
18fa			; 
18fa			;;	cp '6' 
18fa			;;	jp z, .menutest 
18fa			;;if ENABLE_BASIC 
18fa			;;	cp '6' 
18fa			;;	jp z, basic 
18fa			;;endif 
18fa			 ; 
18fa			;	jp .diagmenu 
18fa			; 
18fa			; 
18fa			;	ret 
18fa			 
18fa			 
18fa			.debug_tog: 
18fa 21 44 19			ld hl, .menudebug 
18fd				 
18fd			;	ld a, (os_view_disable) 
18fd			;	cp '*' 
18fd 3a 6c fe			ld a,(debug_vector) 
1900 fe c9			cp $C9   ; RET 
1902 20 04			jr nz,.tdon  
1904 3e 01			ld a, 1 
1906 18 02			jr .tog1 
1908 3e 00		.tdon: ld a, 0 
190a			 
190a			.tog1: 
190a cd cd 0d			call menu 
190d fe 00			cp 0 
190f c8				ret z 
1910 fe 01			cp 1    ; disable debug 
1912 28 04			jr z, .dtog0 
1914 3e 2a			ld a, '*' 
1916 18 05			jr .dtogset 
1918			.dtog0:  
1918				;ld a, 0 
1918 cd 36 1a			call bp_on 
191b 18 dd			jr .debug_tog 
191d			.dtogset:  
191d				; ld (os_view_disable), a 
191d cd 42 1a			call bp_off 
1920 c3 fa 18			jp .debug_tog 
1923			 
1923			 
1923			hardware_diags:       
1923			 
1923			.diagm: 
1923 21 36 19			ld hl, .menuitems 
1926 3e 00			ld a, 0 
1928 cd cd 0d			call menu 
192b			 
192b fe 00		         cp 0 
192d c8				 ret z 
192e			 
192e fe 02			cp 2 
1930 ca 8f 19			jp z, .diagedit 
1933			 
1933			;	cp '6' 
1933			;	jp z, .menutest 
1933			;if ENABLE_BASIC 
1933			;	cp '6' 
1933			;	jp z, basic 
1933			;endif 
1933			  
1933 c3 23 19			jp .diagm 
1936			 
1936				 
1936 4a 19		.menuitems:   	dw .m1 
1938 55 19				dw .m2 
193a 5c 19				dw .m3 
193c 64 19				dw .m5 
193e 6a 19				dw .m5a 
1940 73 19				dw .m5b 
1942 00 00				dw 0 
1944			 
1944			.menudebug: 
1944 7c 19				dw .m6 
1946 85 19				dw .m7 
1948 00 00				dw 0 
194a			 
194a .. 00		.m1:   db "Key Matrix",0 
1955 .. 00		.m2:   db "Editor",0 
195c .. 00		.m3:   db "Storage",0 
1964 .. 00		.m5:   db "Sound",0 
196a .. 00		.m5a:  db "RAM Test",0 
1973 .. 00		.m5b:  db "LCD Test",0 
197c			 
197c .. 00		.m6:   db "Debug ON",0 
1985 .. 00		.m7:   db "Debug OFF",0 
198f			 
198f			; debug editor 
198f			 
198f			.diagedit: 
198f			 
198f 21 be f1			ld hl, scratch 
1992			;	ld bc, 250 
1992			;	ldir 
1992				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1992 3e 00			ld a, 0 
1994 77				ld (hl), a 
1995 23				inc hl 
1996 77				ld (hl), a 
1997 23				inc hl 
1998 77				ld (hl), a 
1999			 
1999 cd 9c 0d		        call clear_display 
199c cd bf 0d			call update_display 
199f				;ld a, 1 
199f				;ld (hardware_diag), a 
199f			.diloop: 
199f 3e 00			ld a, display_row_1 
19a1 0e 00			ld c, 0 
19a3 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
19a5 1e 28			ld e, 40 
19a7			 
19a7 21 be f1			ld hl, scratch	 
19aa cd fd 0f			call input_str 
19ad			 
19ad 3e 28			ld a, display_row_2 
19af 11 be f1			ld de, scratch 
19b2 cd af 0d			call str_at_display 
19b5 cd bf 0d			call update_display 
19b8			 
19b8 c3 9f 19			jp .diloop 
19bb			 
19bb			 
19bb			; pass word in hl 
19bb			; a has display location 
19bb			display_word_at: 
19bb f5				push af 
19bc e5				push hl 
19bd 7c				ld a,h 
19be 21 c3 f4			ld hl, os_word_scratch 
19c1 cd d1 12			call hexout 
19c4 e1				pop hl 
19c5 7d				ld a,l 
19c6 21 c5 f4			ld hl, os_word_scratch+2 
19c9 cd d1 12			call hexout 
19cc 21 c7 f4			ld hl, os_word_scratch+4 
19cf 3e 00			ld a,0 
19d1 77				ld (hl),a 
19d2 11 c3 f4			ld de,os_word_scratch 
19d5 f1				pop af 
19d6 cd af 0d				call str_at_display 
19d9 c9				ret 
19da			 
19da			display_ptr_state: 
19da			 
19da				; to restore afterwards 
19da			 
19da d5				push de 
19db c5				push bc 
19dc e5				push hl 
19dd f5				push af 
19de			 
19de				; for use in here 
19de			 
19de			;	push bc 
19de			;	push de 
19de			;	push hl 
19de			;	push af 
19de			 
19de cd 9c 0d			call clear_display 
19e1			 
19e1 11 b9 1b			ld de, .ptrstate 
19e4 3e 00			ld a, display_row_1 
19e6 cd af 0d			call str_at_display 
19e9			 
19e9				; display debug step 
19e9			 
19e9			 
19e9 11 68 fe			ld de, debug_mark 
19ec 3e 26			ld a, display_row_1+display_cols-2 
19ee cd af 0d			call str_at_display 
19f1			 
19f1				; display a 
19f1 11 c3 1b			ld de, .ptrcliptr 
19f4 3e 28			ld a, display_row_2 
19f6 cd af 0d			call str_at_display 
19f9			 
19f9 f1				pop af 
19fa 2a 3d fa			ld hl,(cli_ptr) 
19fd 3e 30			ld a, display_row_2+8 
19ff cd bb 19			call display_word_at 
1a02			 
1a02			 
1a02				; display hl 
1a02			 
1a02			 
1a02 11 cb 1b			ld de, .ptrclioptr 
1a05 3e 32			ld a, display_row_2+10 
1a07 cd af 0d			call str_at_display 
1a0a			; 
1a0a			;	pop hl 
1a0a 3e 35			ld a, display_row_2+13 
1a0c 2a 3b fa			ld hl,(cli_origptr) 
1a0f cd bb 19			call display_word_at 
1a12			; 
1a12			;	 
1a12			;	; display de 
1a12			 
1a12			;	ld de, .regstatede 
1a12			;	ld a, display_row_3 
1a12			;	call str_at_display 
1a12			 
1a12			;	pop de 
1a12			;	ld h,d 
1a12			;	ld l, e 
1a12			;	ld a, display_row_3+3 
1a12			;	call display_word_at 
1a12			 
1a12			 
1a12				; display bc 
1a12			 
1a12			;	ld de, .regstatebc 
1a12			;	ld a, display_row_3+10 
1a12			;	call str_at_display 
1a12			 
1a12			;	pop bc 
1a12			;	ld h,b 
1a12			;	ld l, c 
1a12			;	ld a, display_row_3+13 
1a12			;	call display_word_at 
1a12			 
1a12			 
1a12				; display dsp 
1a12			 
1a12			;	ld de, .regstatedsp 
1a12			;	ld a, display_row_4 
1a12			;	call str_at_display 
1a12			 
1a12				 
1a12			;	ld hl,(cli_data_sp) 
1a12			;	ld a, display_row_4+4 
1a12			;	call display_word_at 
1a12			 
1a12				; display rsp 
1a12			 
1a12 11 fa 1b			ld de, .regstatersp 
1a15 3e 82			ld a, display_row_4+10 
1a17 cd af 0d			call str_at_display 
1a1a			 
1a1a				 
1a1a 2a ef f9			ld hl,(cli_ret_sp) 
1a1d 3e 86			ld a, display_row_4+14 
1a1f cd bb 19			call display_word_at 
1a22			 
1a22 cd bf 0d			call update_display 
1a25			 
1a25 cd df 0c			call delay1s 
1a28 cd df 0c			call delay1s 
1a2b cd df 0c			call delay1s 
1a2e			 
1a2e			 
1a2e cd 7c 20			call next_page_prompt 
1a31			 
1a31				; restore  
1a31			 
1a31 f1				pop af 
1a32 e1				pop hl 
1a33 c1				pop bc 
1a34 d1				pop de 
1a35 c9				ret 
1a36			 
1a36			; Update the break point vector so that the user can hook a new routine 
1a36			 
1a36			bp_on: 
1a36 3e c3			ld a, $c3    ; JP 
1a38 32 6c fe			ld (debug_vector), a 
1a3b 21 48 1a			ld hl, break_point_state 
1a3e 22 6d fe			ld (debug_vector+1), hl 
1a41 c9				ret 
1a42			 
1a42			bp_off: 
1a42 3e c9			ld a, $c9    ; RET 
1a44 32 6c fe			ld (debug_vector), a 
1a47 c9				ret 
1a48			 
1a48			 
1a48			break_point_state: 
1a48			;	push af 
1a48			; 
1a48			;	; see if disabled 
1a48			; 
1a48			;	ld a, (os_view_disable) 
1a48			;	cp '*' 
1a48			;	jr nz, .bpsgo 
1a48			;	pop af 
1a48			;	ret 
1a48			 
1a48			.bpsgo: 
1a48			;	pop af 
1a48 f5				push af 
1a49 22 ac f1			ld (os_view_hl), hl 
1a4c ed 53 aa f1		ld (os_view_de), de 
1a50 ed 43 a8 f1		ld (os_view_bc), bc 
1a54 e5				push hl 
1a55 6f				ld l, a 
1a56 26 00			ld h, 0 
1a58 22 ae f1			ld (os_view_af),hl 
1a5b			 
1a5b 21 ae fd				ld hl, display_fb0 
1a5e 22 c9 fb				ld (display_fb_active), hl 
1a61 e1				pop hl	 
1a62			 
1a62 3e 31			ld a, '1' 
1a64 fe 2a		.bps1:  cp '*' 
1a66 cc 42 1a			call z, bp_off 
1a69			;	jr nz, .bps1b 
1a69			;	ld (os_view_disable),a 
1a69 fe 31		.bps1b:  cp '1' 
1a6b 20 14			jr nz, .bps2 
1a6d			 
1a6d				; display reg 
1a6d			 
1a6d				 
1a6d			 
1a6d 3a ae f1			ld a, (os_view_af) 
1a70 2a ac f1			ld hl, (os_view_hl) 
1a73 ed 5b aa f1		ld de, (os_view_de) 
1a77 ed 4b a8 f1		ld bc, (os_view_bc) 
1a7b cd 15 1b			call display_reg_state 
1a7e c3 01 1b			jp .bpschk 
1a81			 
1a81 fe 32		.bps2:  cp '2' 
1a83 20 08			jr nz, .bps3 
1a85				 
1a85				; display hl 
1a85 2a ac f1			ld hl, (os_view_hl) 
1a88 cd ff 1b			call display_dump_at_hl 
1a8b			 
1a8b 18 74			jr .bpschk 
1a8d			 
1a8d fe 33		.bps3:  cp '3' 
1a8f 20 08			jr nz, .bps4 
1a91			 
1a91			        ; display de 
1a91 2a aa f1			ld hl, (os_view_de) 
1a94 cd ff 1b			call display_dump_at_hl 
1a97			 
1a97 18 68			jr .bpschk 
1a99 fe 34		.bps4:  cp '4' 
1a9b 20 08			jr nz, .bps5 
1a9d			 
1a9d			        ; display bc 
1a9d 2a a8 f1			ld hl, (os_view_bc) 
1aa0 cd ff 1b			call display_dump_at_hl 
1aa3			 
1aa3 18 5c			jr .bpschk 
1aa5 fe 35		.bps5:  cp '5' 
1aa7 20 08		        jr nz, .bps7 
1aa9			 
1aa9				; display cur ptr 
1aa9 2a 3d fa			ld hl, (cli_ptr) 
1aac cd ff 1b			call display_dump_at_hl 
1aaf			 
1aaf 18 50			jr .bpschk 
1ab1 fe 36		.bps7:  cp '6' 
1ab3 20 08			jr nz, .bps8b 
1ab5				 
1ab5				; display cur orig ptr 
1ab5 2a 3b fa			ld hl, (cli_origptr) 
1ab8 cd ff 1b			call display_dump_at_hl 
1abb 18 44			jr .bpschk 
1abd fe 37		.bps8b:  cp '7' 
1abf 20 08			jr nz, .bps9 
1ac1				 
1ac1				; display dsp 
1ac1 2a eb f9			ld hl, (cli_data_sp) 
1ac4 cd ff 1b			call display_dump_at_hl 
1ac7			 
1ac7 18 38			jr .bpschk 
1ac9 fe 39		.bps9:  cp '9' 
1acb 20 05			jr nz, .bps8c 
1acd				 
1acd				; display SP 
1acd			;	ld hl, sp 
1acd cd ff 1b			call display_dump_at_hl 
1ad0			 
1ad0 18 2f			jr .bpschk 
1ad2 fe 38		.bps8c:  cp '8' 
1ad4 20 08			jr nz, .bps8d 
1ad6				 
1ad6				; display rsp 
1ad6 2a ef f9			ld hl, (cli_ret_sp) 
1ad9 cd ff 1b			call display_dump_at_hl 
1adc			 
1adc 18 23			jr .bpschk 
1ade fe 23		.bps8d:  cp '#'     ; access monitor sub system 
1ae0 20 05			jr nz, .bps8 
1ae2 cd 4a 1e			call monitor 
1ae5			 
1ae5 18 1a			jr .bpschk 
1ae7 fe 30		.bps8:  cp '0' 
1ae9 20 16			jr nz, .bpschk 
1aeb			 
1aeb 21 0d fd				ld hl, display_fb1 
1aee 22 c9 fb				ld (display_fb_active), hl 
1af1 cd bf 0d				call update_display 
1af4			 
1af4				;ld a, (os_view_af) 
1af4 2a ac f1			ld hl, (os_view_hl) 
1af7 ed 5b aa f1		ld de, (os_view_de) 
1afb ed 4b a8 f1		ld bc, (os_view_bc) 
1aff f1				pop af 
1b00 c9				ret 
1b01			 
1b01			.bpschk:   
1b01 cd df 0c			call delay1s 
1b04 3e 9f		ld a,display_row_4 + display_cols - 1 
1b06 11 7a 20		        ld de, endprg 
1b09 cd af 0d			call str_at_display 
1b0c cd bf 0d			call update_display 
1b0f cd c2 79			call cin_wait 
1b12			 
1b12 c3 64 1a			jp .bps1 
1b15			 
1b15			 
1b15			display_reg_state: 
1b15			 
1b15				; to restore afterwards 
1b15			 
1b15 d5				push de 
1b16 c5				push bc 
1b17 e5				push hl 
1b18 f5				push af 
1b19			 
1b19				; for use in here 
1b19			 
1b19 c5				push bc 
1b1a d5				push de 
1b1b e5				push hl 
1b1c f5				push af 
1b1d			 
1b1d cd 9c 0d			call clear_display 
1b20			 
1b20 11 d5 1b			ld de, .regstate 
1b23 3e 00			ld a, display_row_1 
1b25 cd af 0d			call str_at_display 
1b28			 
1b28				; display debug step 
1b28			 
1b28			 
1b28 11 68 fe			ld de, debug_mark 
1b2b 3e 25			ld a, display_row_1+display_cols-3 
1b2d cd af 0d			call str_at_display 
1b30			 
1b30				; display a 
1b30 11 f1 1b			ld de, .regstatea 
1b33 3e 28			ld a, display_row_2 
1b35 cd af 0d			call str_at_display 
1b38			 
1b38 e1				pop hl 
1b39			;	ld h,0 
1b39			;	ld l, a 
1b39 3e 2b			ld a, display_row_2+3 
1b3b cd bb 19			call display_word_at 
1b3e			 
1b3e			 
1b3e				; display hl 
1b3e			 
1b3e			 
1b3e 11 e5 1b			ld de, .regstatehl 
1b41 3e 32			ld a, display_row_2+10 
1b43 cd af 0d			call str_at_display 
1b46			 
1b46 e1				pop hl 
1b47 3e 35			ld a, display_row_2+13 
1b49 cd bb 19			call display_word_at 
1b4c			 
1b4c				 
1b4c				; display de 
1b4c			 
1b4c 11 e9 1b			ld de, .regstatede 
1b4f 3e 50			ld a, display_row_3 
1b51 cd af 0d			call str_at_display 
1b54			 
1b54 e1				pop hl 
1b55			;	ld h,d 
1b55			;	ld l, e 
1b55 3e 53			ld a, display_row_3+3 
1b57 cd bb 19			call display_word_at 
1b5a			 
1b5a			 
1b5a				; display bc 
1b5a			 
1b5a 11 ed 1b			ld de, .regstatebc 
1b5d 3e 5a			ld a, display_row_3+10 
1b5f cd af 0d			call str_at_display 
1b62			 
1b62 e1				pop hl 
1b63			;	ld h,b 
1b63			;	ld l, c 
1b63 3e 5d			ld a, display_row_3+13 
1b65 cd bb 19			call display_word_at 
1b68			 
1b68			 
1b68				; display dsp 
1b68			 
1b68 11 f5 1b			ld de, .regstatedsp 
1b6b 3e 78			ld a, display_row_4 
1b6d cd af 0d			call str_at_display 
1b70			 
1b70				 
1b70 2a eb f9			ld hl,(cli_data_sp) 
1b73 3e 7c			ld a, display_row_4+4 
1b75 cd bb 19			call display_word_at 
1b78			 
1b78				; display rsp 
1b78			 
1b78 11 fa 1b			ld de, .regstatersp 
1b7b 3e 82			ld a, display_row_4+10 
1b7d cd af 0d			call str_at_display 
1b80			 
1b80				 
1b80 2a ef f9			ld hl,(cli_ret_sp) 
1b83 3e 86			ld a, display_row_4+14 
1b85 cd bb 19			call display_word_at 
1b88			 
1b88 cd bf 0d			call update_display 
1b8b			 
1b8b			;	call delay1s 
1b8b			;	call delay1s 
1b8b			;	call delay1s 
1b8b			 
1b8b			 
1b8b			;	call next_page_prompt 
1b8b			 
1b8b				; restore  
1b8b			 
1b8b f1				pop af 
1b8c e1				pop hl 
1b8d c1				pop bc 
1b8e d1				pop de 
1b8f c9				ret 
1b90			 
1b90 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1ba4 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1bb9 .. 00		.ptrstate:	db "Ptr State",0 
1bc3 .. 00		.ptrcliptr:     db "cli_ptr",0 
1bcb .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1bd5 .. 00		.regstate:	db "Reg State (1/0)",0 
1be5 .. 00		.regstatehl:	db "HL:",0 
1be9 .. 00		.regstatede:	db "DE:",0 
1bed .. 00		.regstatebc:	db "BC:",0 
1bf1 .. 00		.regstatea:	db "A :",0 
1bf5 .. 00		.regstatedsp:	db "DSP:",0 
1bfa .. 00		.regstatersp:	db "RSP:",0 
1bff			 
1bff			display_dump_at_hl: 
1bff e5				push hl 
1c00 d5				push de 
1c01 c5				push bc 
1c02 f5				push af 
1c03			 
1c03 22 e1 f4			ld (os_cur_ptr),hl	 
1c06 cd 9c 0d			call clear_display 
1c09 cd 84 1f			call dumpcont 
1c0c			;	call delay1s 
1c0c			;	call next_page_prompt 
1c0c			 
1c0c			 
1c0c f1				pop af 
1c0d c1				pop bc 
1c0e d1				pop de 
1c0f e1				pop hl 
1c10 c9				ret 
1c11			 
1c11			;if ENABLE_BASIC 
1c11			;	include "nascombasic.asm" 
1c11			;	basic: 
1c11			;	include "forth/FORTH.ASM" 
1c11			;endif 
1c11			 
1c11			; eof 
1c11			 
1c11			 
# End of file firmware_diags.asm
1c11			  
1c11			include "firmware_prompts.asm"  
1c11			; Prompts  
1c11			 
1c11			; boot messages 
1c11			 
1c11 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
1c26 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
1c36			 
1c36			 
1c36			; config menus 
1c36			 
1c36			;prom_c3: db "Add Dictionary To File",0 
1c36			 
1c36			if STARTUP_V1 
1c36			prom_c2: db "Select Autoload File",0 
1c36			prom_c2a: db "Disable Autoload File", 0 
1c36			endif 
1c36			 
1c36			if STARTUP_V2 
1c36 .. 00		prom_c2: db "Enable Autoload Files",0 
1c4c .. 00		prom_c2a: db "Disable Autoload Files", 0 
1c63			 
1c63 .. 00		crs_s1: db "*ls-word", 0 
1c6c .. 00		crs_s2: db "*ed-word", 0 
1c75 .. 00		crs_s3: db "*Demo-Programs", 0 
1c84 .. 00		crs_s4: db "*Utils", 0 
1c8b .. 00		crs_s5: db "*SPI-Addons", 0 
1c97 .. 00		crs_s6: db "*Key-constants", 0 
1ca6 .. 00		crs_sound: db "*Sound-Util", 0 
1cb2			 
1cb2			 
1cb2			 
1cb2			endif 
1cb2			;prom_c2b: db "Select Storage Bank",0 
1cb2 .. 00		prom_c4: db "Settings",0 
1cbb .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
1cd6 .. 00		prom_m4b:   db "Monitor",0 
1cde .. 00		prom_c1: db "Hardware Diags",0 
1ced			 
1ced			 
1ced			if STARTUP_V2 
1ced .. 00		prom_c9: db "Create Startup Files",0 
1d02			endif 
1d02			 
1d02 .. 00		prom_notav:    db "Feature not available",0 
1d18 .. 00		prom_empty:    db "",0 
1d19			 
1d19			; eof 
1d19			 
# End of file firmware_prompts.asm
1d19			  
1d19			  
1d19			; eof  
1d19			  
# End of file firmware.asm
1d19			 
1d19			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1d19			;if BASE_KEV  
1d19			;baseram: equ 08000h 
1d19			;endif 
1d19			 
1d19			;if BASE_SC114 
1d19			;baseram:     equ    endofcode 
1d19			;endif 
1d19			 
1d19			 
1d19			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
1d19			 
1d19			; start system 
1d19			 
1d19			coldstart: 
1d19				; set sp 
1d19				; di/ei 
1d19			 
1d19 f3				di 
1d1a 31 fd ff			ld sp, tos 
1d1d cd 49 76			call init_nmi 
1d20			;	ei 
1d20			 
1d20				; init spinner 
1d20 3e 00			ld a,0 
1d22 32 c3 fb			ld (display_active), a 
1d25			 
1d25				; disable breakpoint by default 
1d25			 
1d25				;ld a,'*' 
1d25			;	ld a,' ' 
1d25			;	ld (os_view_disable),a 
1d25			 
1d25				; set break point vector as new break point on or off 
1d25 cd 42 1a			call bp_off 
1d28			 
1d28				; init hardware 
1d28			 
1d28				; init keyboard and screen hardware 
1d28			 
1d28 cd 69 00			call hardware_init 
1d2b			 
1d2b			 
1d2b cd df 0c			call delay1s 
1d2e 3e 58			ld a, display_row_3+8 
1d30 11 03 00			ld de, buildtime 
1d33 cd af 0d			call str_at_display 
1d36 cd bf 0d			call update_display 
1d39			 
1d39 cd df 0c			call delay1s 
1d3c cd df 0c			call delay1s 
1d3f cd df 0c			call delay1s 
1d42			 
1d42				; detect if any keys are held down to enable breakpoints at start up 
1d42			 
1d42 cd d3 79			call cin  
1d45 fe 00			cp 0 
1d47 28 03			jr z, .nokeys 
1d49			 
1d49				;call hardware_diags 
1d49 cd 30 16			call config 
1d4c			 
1d4c			;	ld de, .bpen 
1d4c			;	ld a, display_row_4 
1d4c			;	call str_at_display 
1d4c			;	call update_display 
1d4c			; 
1d4c			;	ld a,0 
1d4c			;	ld (os_view_disable),a 
1d4c			; 
1d4c			;.bpwait: 
1d4c			;	call cin 
1d4c			;	cp 0 
1d4c			;	jr z, .bpwait 
1d4c			;	jr .nokeys 
1d4c			; 
1d4c			; 
1d4c			;.bpen:  db "Break points enabled!",0 
1d4c			 
1d4c			 
1d4c			 
1d4c			 
1d4c			 
1d4c			 
1d4c			.nokeys: 
1d4c			 
1d4c			 
1d4c				 
1d4c			 
1d4c			;jp  testkey 
1d4c			 
1d4c			;call storage_get_block_0 
1d4c			; 
1d4c			;ld hl, 0 
1d4c			;ld de, store_page 
1d4c			;call storage_read_block 
1d4c			 
1d4c				 
1d4c			;ld hl, 10 
1d4c			;ld de, store_page 
1d4c			;call storage_read_block 
1d4c			 
1d4c			 
1d4c			 
1d4c			 
1d4c			 
1d4c			;stop:	nop 
1d4c			;	jp stop 
1d4c			 
1d4c			 
1d4c			 
1d4c			main: 
1d4c cd 9c 0d			call clear_display 
1d4f cd bf 0d			call update_display 
1d52			 
1d52			 
1d52			 
1d52			;	call testlcd 
1d52			 
1d52			 
1d52			 
1d52 cd 81 24			call forth_init 
1d55			 
1d55			 
1d55			warmstart: 
1d55 cd 57 24			call forth_warmstart 
1d58			 
1d58				; run startup word load 
1d58			        ; TODO prevent this running at warmstart after crash  
1d58			 
1d58				if STARTUP_ENABLE 
1d58			 
1d58					if STARTUP_V1 
1d58			 
1d58						if STORAGE_SE 
1d58							call forth_autoload 
1d58						endif 
1d58						call forth_startup 
1d58					endif 
1d58			 
1d58					if STARTUP_V2 
1d58			 
1d58						if STORAGE_SE 
1d58 cd 77 74						call forth_autoload 
1d5b						else 
1d5b							call forth_startup 
1d5b						endif 
1d5b			 
1d5b			 
1d5b					endif 
1d5b			 
1d5b				endif 
1d5b			 
1d5b				; show free memory after boot 
1d5b 11 e5 1d			ld de, freeram 
1d5e 3e 00			ld a, display_row_1 
1d60 cd af 0d			call str_at_display 
1d63			 
1d63			; Or use heap_size word???? 
1d63 21 a5 f1			ld hl, heap_end 
1d66 11 0e 80			ld de, heap_start 
1d69 ed 52			sbc hl, de 
1d6b				;push hl 
1d6b				;ld a,h	         	 
1d6b				;ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1d6b				;call hexout 
1d6b			   	;pop hl 
1d6b			; 
1d6b			;	ld a,l 
1d6b			;	ld hl, os_word_scratch+2 
1d6b			;	call hexout 
1d6b			;	ld hl, os_word_scratch+4 
1d6b			;	ld a, 0 
1d6b			;	ld (hl),a 
1d6b			 
1d6b 21 c3 f4			ld hl, os_word_scratch 
1d6e cd dd 13			call uitoa_16 
1d71			 
1d71			 
1d71 11 c3 f4			ld de, os_word_scratch 
1d74 3e 0d			ld a, display_row_1 + 13 
1d76 cd af 0d			call str_at_display 
1d79 cd bf 0d			call update_display 
1d7c			 
1d7c			 
1d7c				;call demo 
1d7c			 
1d7c			 
1d7c				; init scratch input area for cli commands 
1d7c			 
1d7c 21 e5 f4			ld hl, os_cli_cmd 
1d7f 3e 00			ld a,0 
1d81 77				ld (hl),a 
1d82 23				inc hl 
1d83 77				ld (hl),a 
1d84			 
1d84 3e 00			ld a,0 
1d86 32 e4 f5			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1d89			 
1d89 32 e1 f4			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1d8c 32 e2 f4			ld (os_cur_ptr+1),a	 
1d8f			 
1d8f 32 c3 f4			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1d92 32 c4 f4			ld (os_word_scratch+1),a	 
1d95				 
1d95			 
1d95				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1d95 21 e5 f4			ld hl, os_cli_cmd 
1d98			 
1d98 3e 00			ld a, 0		 ; init cli input 
1d9a 77				ld (hl), a 
1d9b 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1d9d			cli: 
1d9d				; show cli prompt 
1d9d				;push af 
1d9d				;ld a, 0 
1d9d				;ld de, prompt 
1d9d				;call str_at_display 
1d9d			 
1d9d				;call update_display 
1d9d				;pop af 
1d9d				;inc a 
1d9d				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1d9d 0e 00			ld c, 0 
1d9f 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1da1 1e 28			ld e, 40 
1da3			 
1da3 21 e5 f4			ld hl, os_cli_cmd 
1da6			 
1da6				STACKFRAME OFF $fefe $9f9f 
1da6				if DEBUG_STACK_IMB 
1da6					if OFF 
1da6						exx 
1da6						ld de, $fefe 
1da6						ld a, d 
1da6						ld hl, curframe 
1da6						call hexout 
1da6						ld a, e 
1da6						ld hl, curframe+2 
1da6						call hexout 
1da6						ld hl, $fefe 
1da6						push hl 
1da6						ld hl, $9f9f 
1da6						push hl 
1da6						exx 
1da6					endif 
1da6				endif 
1da6			endm 
# End of macro STACKFRAME
1da6			 
1da6 cd fd 0f			call input_str 
1da9			 
1da9				STACKFRAMECHK OFF $fefe $9f9f 
1da9				if DEBUG_STACK_IMB 
1da9					if OFF 
1da9						exx 
1da9						ld hl, $9f9f 
1da9						pop de   ; $9f9f 
1da9						call cmp16 
1da9						jr nz, .spnosame 
1da9						ld hl, $fefe 
1da9						pop de   ; $fefe 
1da9						call cmp16 
1da9						jr z, .spfrsame 
1da9						.spnosame: call showsperror 
1da9						.spfrsame: nop 
1da9						exx 
1da9					endif 
1da9				endif 
1da9			endm 
# End of macro STACKFRAMECHK
1da9			 
1da9				; copy input to last command 
1da9			 
1da9 21 e5 f4			ld hl, os_cli_cmd 
1dac 11 e4 f5			ld de, os_last_cmd 
1daf 01 ff 00			ld bc, 255 
1db2 ed b0			ldir 
1db4			 
1db4				; wipe current buffer 
1db4			 
1db4			;	ld a, 0 
1db4			;	ld hl, os_cli_cmd 
1db4			;	ld de, os_cli_cmd+1 
1db4			;	ld bc, 254 
1db4			;	ldir 
1db4				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1db4			;	call strcpy 
1db4			;	ld a, 0 
1db4			;	ld (hl), a 
1db4			;	inc hl 
1db4			;	ld (hl), a 
1db4			;	inc hl 
1db4			;	ld (hl), a 
1db4			 
1db4				; switch frame buffer to program  
1db4			 
1db4 21 0d fd				ld hl, display_fb1 
1db7 22 c9 fb				ld (display_fb_active), hl 
1dba			 
1dba			;	nop 
1dba				STACKFRAME ON $fbfe $8f9f 
1dba				if DEBUG_STACK_IMB 
1dba					if ON 
1dba						exx 
1dba						ld de, $fbfe 
1dba						ld a, d 
1dba						ld hl, curframe 
1dba						call hexout 
1dba						ld a, e 
1dba						ld hl, curframe+2 
1dba						call hexout 
1dba						ld hl, $fbfe 
1dba						push hl 
1dba						ld hl, $8f9f 
1dba						push hl 
1dba						exx 
1dba					endif 
1dba				endif 
1dba			endm 
# End of macro STACKFRAME
1dba				; first time into the parser so pass over the current scratch pad 
1dba 21 e5 f4			ld hl,os_cli_cmd 
1dbd				; tokenise the entered statement(s) in HL 
1dbd cd ff 24			call forthparse 
1dc0			        ; exec forth statements in top of return stack 
1dc0 cd 3f 25			call forthexec 
1dc3				;call forthexec_cleanup 
1dc3			;	call parsenext 
1dc3			 
1dc3				STACKFRAMECHK ON $fbfe $8f9f 
1dc3				if DEBUG_STACK_IMB 
1dc3					if ON 
1dc3						exx 
1dc3						ld hl, $8f9f 
1dc3						pop de   ; $8f9f 
1dc3						call cmp16 
1dc3						jr nz, .spnosame 
1dc3						ld hl, $fbfe 
1dc3						pop de   ; $fbfe 
1dc3						call cmp16 
1dc3						jr z, .spfrsame 
1dc3						.spnosame: call showsperror 
1dc3						.spfrsame: nop 
1dc3						exx 
1dc3					endif 
1dc3				endif 
1dc3			endm 
# End of macro STACKFRAMECHK
1dc3				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1dc3			 
1dc3 3e 78			ld a, display_row_4 
1dc5 11 f6 1d			ld de, endprog 
1dc8			 
1dc8 cd bf 0d			call update_display		 
1dcb			 
1dcb cd 7c 20			call next_page_prompt 
1dce			 
1dce				; switch frame buffer to cli 
1dce			 
1dce 21 ae fd				ld hl, display_fb0 
1dd1 22 c9 fb				ld (display_fb_active), hl 
1dd4			 
1dd4			 
1dd4 cd 9c 0d		        call clear_display 
1dd7 cd bf 0d			call update_display		 
1dda			 
1dda 21 e5 f4			ld hl, os_cli_cmd 
1ddd			 
1ddd 3e 00			ld a, 0		 ; init cli input 
1ddf 77				ld (hl), a 
1de0			 
1de0				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1de0			 
1de0				; now on last line 
1de0			 
1de0				; TODO scroll screen up 
1de0			 
1de0				; TODO instead just clear screen and place at top of screen 
1de0			 
1de0			;	ld a, 0 
1de0			;	ld (f_cursor_ptr),a 
1de0			 
1de0				;call clear_display 
1de0				;call update_display 
1de0			 
1de0				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1de0 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1de2 c3 9d 1d			jp cli 
1de5			 
1de5 .. 00		freeram: db "Free bytes: ",0 
1df2 ..			asc: db "1A2F" 
1df6 .. 00		endprog: db "End prog...",0 
1e02			 
1e02			testenter2:   
1e02 21 f0 f1			ld hl,scratch+50 
1e05 22 e1 f4			ld (os_cur_ptr),hl 
1e08 c3 9d 1d			jp cli 
1e0b			 
1e0b			testenter:  
1e0b			 
1e0b 21 f2 1d			ld hl,asc 
1e0e			;	ld a,(hl) 
1e0e			;	call nibble2val 
1e0e cd 27 13			call get_byte 
1e11			 
1e11			 
1e11			;	ld a,(hl) 
1e11			;	call atohex 
1e11			 
1e11			;	call fourehexhl 
1e11 32 f0 f1			ld (scratch+50),a 
1e14			 
1e14			 
1e14			 
1e14 21 f4 1d			ld hl,asc+2 
1e17			;	ld a, (hl) 
1e17			;	call nibble2val 
1e17 cd 27 13			call get_byte 
1e1a			 
1e1a			;	call fourehexhl 
1e1a 32 f2 f1			ld (scratch+52),a 
1e1d				 
1e1d 21 f0 f1			ld hl,scratch+50 
1e20 22 e1 f4			ld (os_cur_ptr),hl 
1e23 c3 9d 1d			jp cli 
1e26			 
1e26			enter:	 
1e26 3a c2 f1			ld a,(scratch+4) 
1e29 fe 00			cp 0 
1e2b 28 0c			jr z, .entercont 
1e2d				; no, not a null term line so has an address to work out.... 
1e2d			 
1e2d 21 c0 f1			ld hl,scratch+2 
1e30 cd 87 13			call get_word_hl 
1e33			 
1e33 22 e1 f4			ld (os_cur_ptr),hl	 
1e36 c3 9d 1d			jp cli 
1e39			 
1e39			 
1e39			.entercont:  
1e39			 
1e39 21 c0 f1			ld hl, scratch+2 
1e3c cd 27 13			call get_byte 
1e3f			 
1e3f 2a e1 f4		   	ld hl,(os_cur_ptr) 
1e42 77					ld (hl),a 
1e43 23					inc hl 
1e44 22 e1 f4				ld (os_cur_ptr),hl 
1e47				 
1e47			; get byte  
1e47			 
1e47			 
1e47 c3 9d 1d			jp cli 
1e4a			 
1e4a			 
1e4a			; basic monitor support 
1e4a			 
1e4a			monitor: 
1e4a				;  
1e4a cd 9c 0d			call clear_display 
1e4d 3e 00			ld a, 0 
1e4f 11 9e 1e			ld de, .monprompt 
1e52 cd af 0d			call str_at_display 
1e55 cd bf 0d			call update_display 
1e58			 
1e58				; get a monitor command 
1e58			 
1e58 0e 00			ld c, 0     ; entry at top left 
1e5a 16 64			ld d, 100   ; max buffer size 
1e5c 1e 0f			ld e, 15    ; input scroll area 
1e5e 3e 00			ld a, 0     ; init string 
1e60 21 bc f3			ld hl, os_input 
1e63 77				ld (hl), a 
1e64 23				inc hl 
1e65 77				ld (hl), a 
1e66 21 bc f3			ld hl, os_input 
1e69 3e 01			ld a, 1     ; init string 
1e6b cd fd 0f			call input_str 
1e6e			 
1e6e cd 9c 0d		        call clear_display 
1e71 cd bf 0d			call update_display		 
1e74			 
1e74 3a bc f3			ld a, (os_input) 
1e77 cd 25 14			call toUpper 
1e7a fe 48		        cp 'H' 
1e7c ca 03 1f		        jp z, .monhelp 
1e7f fe 44			cp 'D'		; dump 
1e81 ca 36 1f			jp z, .mondump	 
1e84 fe 43			cp 'C'		; dump 
1e86 ca 50 1f			jp z, .moncdump	 
1e89 fe 4d			cp 'M'		; dump 
1e8b ca a0 1e			jp z, .moneditstart 
1e8e fe 55			cp 'U'		; dump 
1e90 ca ac 1e			jp z, .monedit	 
1e93 fe 47			cp 'G'		; dump 
1e95 ca 2c 1f			jp z, .monjump 
1e98 fe 51			cp 'Q'		; dump 
1e9a c8				ret z	 
1e9b			 
1e9b			 
1e9b				; TODO "S" to access symbol by name and not need the address 
1e9b				; TODO "F" to find a string in memory 
1e9b			 
1e9b c3 4a 1e			jp monitor 
1e9e			 
1e9e .. 00		.monprompt: db ">", 0 
1ea0			 
1ea0			.moneditstart: 
1ea0				; get starting address 
1ea0			 
1ea0 21 be f3			ld hl,os_input+2 
1ea3 cd 87 13			call get_word_hl 
1ea6			 
1ea6 22 e1 f4			ld (os_cur_ptr),hl	 
1ea9			 
1ea9 c3 4a 1e			jp monitor 
1eac			 
1eac			.monedit: 
1eac				; get byte to load 
1eac			 
1eac 21 be f3			ld hl,os_input+2 
1eaf cd 27 13			call get_byte 
1eb2			 
1eb2				; get address to update 
1eb2 2a e1 f4			ld hl, (os_cur_ptr) 
1eb5			 
1eb5				; update byte 
1eb5			 
1eb5 77				ld (hl), a 
1eb6			 
1eb6				; move to next address and save it 
1eb6			 
1eb6 23				inc hl 
1eb7 22 e1 f4			ld (os_cur_ptr),hl	 
1eba			 
1eba c3 4a 1e			jp monitor 
1ebd			 
1ebd			 
1ebd .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1ed1 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1eed .. 00		.monhelptext3:  db "G-Call address",0 
1efc .. 00		.monhelptext4:  db "Q-Quit",0 
1f03			        
1f03			.monhelp: 
1f03 3e 00			ld a, display_row_1 
1f05 11 bd 1e		        ld de, .monhelptext1 
1f08			 
1f08 cd af 0d			call str_at_display 
1f0b 3e 28			ld a, display_row_2 
1f0d 11 d1 1e		        ld de, .monhelptext2 
1f10					 
1f10 cd af 0d			call str_at_display 
1f13 3e 50			ld a, display_row_3 
1f15 11 ed 1e		        ld de, .monhelptext3 
1f18					 
1f18 cd af 0d			call str_at_display 
1f1b 3e 78			ld a, display_row_4 
1f1d 11 fc 1e		        ld de, .monhelptext4 
1f20 cd af 0d			call str_at_display 
1f23			 
1f23 cd bf 0d			call update_display		 
1f26			 
1f26 cd 7c 20			call next_page_prompt 
1f29 c3 4a 1e			jp monitor 
1f2c			 
1f2c			.monjump:    
1f2c 21 be f3			ld hl,os_input+2 
1f2f cd 87 13			call get_word_hl 
1f32			 
1f32 e9				jp (hl) 
1f33 c3 4a 1e			jp monitor 
1f36			 
1f36			.mondump:    
1f36 21 be f3			ld hl,os_input+2 
1f39 cd 87 13			call get_word_hl 
1f3c			 
1f3c 22 e1 f4			ld (os_cur_ptr),hl	 
1f3f cd 84 1f			call dumpcont 
1f42 3e 78			ld a, display_row_4 
1f44 11 f6 1d			ld de, endprog 
1f47			 
1f47 cd bf 0d			call update_display		 
1f4a			 
1f4a cd 7c 20			call next_page_prompt 
1f4d c3 4a 1e			jp monitor 
1f50			.moncdump: 
1f50 cd 84 1f			call dumpcont 
1f53 3e 78			ld a, display_row_4 
1f55 11 f6 1d			ld de, endprog 
1f58			 
1f58 cd bf 0d			call update_display		 
1f5b			 
1f5b cd 7c 20			call next_page_prompt 
1f5e c3 4a 1e			jp monitor 
1f61			 
1f61			 
1f61			; TODO symbol access  
1f61			 
1f61			.symbols:     ;; A list of symbols that can be called up  
1f61 ae fd			dw display_fb0 
1f63 .. 00			db "fb0",0  
1f67 77 fa		     	dw store_page 
1f69 .. 00			db "store_page",0 
1f74			 
1f74			 
1f74			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1f74			 
1f74 3a bf f1			ld a,(scratch+1) 
1f77 fe 00			cp 0 
1f79 28 09			jr z, dumpcont 
1f7b			 
1f7b				; no, not a null term line so has an address to work out.... 
1f7b			 
1f7b 21 c0 f1			ld hl,scratch+2 
1f7e cd 87 13			call get_word_hl 
1f81			 
1f81 22 e1 f4			ld (os_cur_ptr),hl	 
1f84			 
1f84			 
1f84			 
1f84			dumpcont: 
1f84			 
1f84				; dump bytes at ptr 
1f84			 
1f84			 
1f84 3e 00			ld a, display_row_1 
1f86 2a c9 fb			ld hl, (display_fb_active) 
1f89 cd d0 0f			call addatohl 
1f8c cd b4 1f			call .dumpbyterow 
1f8f			 
1f8f 3e 28			ld a, display_row_2 
1f91 2a c9 fb			ld hl, (display_fb_active) 
1f94 cd d0 0f			call addatohl 
1f97 cd b4 1f			call .dumpbyterow 
1f9a			 
1f9a			 
1f9a 3e 50			ld a, display_row_3 
1f9c 2a c9 fb			ld hl, (display_fb_active) 
1f9f cd d0 0f			call addatohl 
1fa2 cd b4 1f			call .dumpbyterow 
1fa5			 
1fa5 3e 78			ld a, display_row_4 
1fa7 2a c9 fb			ld hl, (display_fb_active) 
1faa cd d0 0f			call addatohl 
1fad cd b4 1f			call .dumpbyterow 
1fb0			 
1fb0 cd bf 0d			call update_display 
1fb3			;		jp cli 
1fb3 c9				ret 
1fb4			 
1fb4			.dumpbyterow: 
1fb4			 
1fb4				;push af 
1fb4			 
1fb4 e5				push hl 
1fb5			 
1fb5				; calc where to poke the ascii 
1fb5			if display_cols == 20 
1fb5				ld a, 16 
1fb5			else 
1fb5 3e 1f			ld a, 31 
1fb7			endif 
1fb7			 
1fb7 cd d0 0f			call addatohl 
1fba 22 c3 f4			ld (os_word_scratch),hl  		; save pos for later 
1fbd			 
1fbd			 
1fbd			; display decoding address 
1fbd 2a e1 f4		   	ld hl,(os_cur_ptr) 
1fc0			 
1fc0 7c				ld a,h 
1fc1 e1				pop hl 
1fc2 e5				push hl 
1fc3			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1fc3 cd d1 12			call hexout 
1fc6 2a e1 f4		   	ld hl,(os_cur_ptr) 
1fc9			 
1fc9 7d				ld a,l 
1fca e1				pop hl 
1fcb 23				inc hl 
1fcc 23				inc hl 
1fcd e5				push hl 
1fce			;	ld hl, os_word_scratch+2 
1fce cd d1 12			call hexout 
1fd1 e1				pop hl 
1fd2 23				inc hl 
1fd3 23				inc hl 
1fd4				;ld hl, os_word_scratch+4 
1fd4 3e 3a			ld a, ':' 
1fd6 77				ld (hl),a 
1fd7 23				inc hl 
1fd8				;ld a, 0 
1fd8				;ld (hl),a 
1fd8				;ld de, os_word_scratch 
1fd8				;pop af 
1fd8				;push af 
1fd8			;		ld a, display_row_2 
1fd8			;		call str_at_display 
1fd8			;		call update_display 
1fd8			 
1fd8			 
1fd8			;pop af 
1fd8			;	add 5 
1fd8			 
1fd8			if display_cols == 20 
1fd8				ld b, 4 
1fd8			else 
1fd8 06 08			ld b, 8 
1fda			endif	 
1fda			 
1fda			.dumpbyte: 
1fda c5				push bc 
1fdb e5				push hl 
1fdc			 
1fdc			 
1fdc 2a e1 f4		   	ld hl,(os_cur_ptr) 
1fdf 7e					ld a,(hl) 
1fe0			 
1fe0					; poke the ascii to display 
1fe0 2a c3 f4				ld hl,(os_word_scratch) 
1fe3 77					ld (hl),a 
1fe4 23					inc hl 
1fe5 22 c3 f4				ld (os_word_scratch),hl 
1fe8			 
1fe8					 
1fe8			 
1fe8			 
1fe8 e1					pop hl 
1fe9 e5					push hl 
1fea			 
1fea cd d1 12				call hexout 
1fed			 
1fed					 
1fed 2a e1 f4		   	ld hl,(os_cur_ptr) 
1ff0 23				inc hl 
1ff1 22 e1 f4		   	ld (os_cur_ptr),hl 
1ff4			 
1ff4 e1					pop hl 
1ff5 23					inc hl 
1ff6 23					inc hl 
1ff7 23					inc hl 
1ff8			 
1ff8			 
1ff8			 
1ff8					;ld a,0 
1ff8					;ld (os_word_scratch+2),a 
1ff8					;pop af 
1ff8					;push af 
1ff8			 
1ff8					;ld de, os_word_scratch 
1ff8					;call str_at_display 
1ff8			;		call update_display 
1ff8			;		pop af 
1ff8 c1					pop bc 
1ff9 c6 03				add 3 
1ffb 10 dd			djnz .dumpbyte 
1ffd			 
1ffd				 
1ffd			 
1ffd c9				ret 
1ffe			 
1ffe			jump:	 
1ffe			 
1ffe 21 c0 f1			ld hl,scratch+2 
2001 cd 87 13			call get_word_hl 
2004				;ld hl,(scratch+2) 
2004				;call fourehexhl 
2004			 
2004 22 e1 f4			ld (os_cur_ptr),hl	 
2007			 
2007 e9				jp (hl) 
2008			 
2008			 
2008			 
2008			; TODO implement a basic monitor mode to start with 
2008			 
2008			 
2008			 
2008			 
2008			 
2008			 
2008			 
2008			 
2008			 
2008			; testing and demo code during development 
2008			 
2008			 
2008 .. 00		str1: db "Enter some text...",0 
201b .. 00		clear: db "                    ",0 
2030			 
2030			demo: 
2030			 
2030			 
2030			 
2030			;	call update_display 
2030			 
2030				; init scratch input area for testing 
2030 21 be f1			ld hl, scratch	 
2033 3e 00			ld a,0 
2035 77				ld (hl),a 
2036			 
2036			 
2036 3e 28		            LD   A, display_row_2 
2038			;            CALL fLCD_Pos       ;Position cursor to location in A 
2038 11 08 20		            LD   DE, str1 
203b cd af 0d			call str_at_display 
203e			 
203e			;            CALL fLCD_Str       ;Display string pointed to by DE 
203e			cloop:	 
203e 3e 50		            LD   A, display_row_3 
2040			;            CALL fLCD_Pos       ;Position cursor to location in A 
2040 11 1b 20		            LD   DE, clear 
2043			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
2043 cd af 0d				call str_at_display 
2046 3e 78			ld a, display_row_4 
2048 11 78 20			ld de, prompt 
204b			 
204b cd af 0d				call str_at_display 
204e cd bf 0d			call update_display 
2051			 
2051 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
2053 16 0a			ld d, 10 
2055 21 be f1			ld hl, scratch	 
2058 cd fd 0f			call input_str 
205b			 
205b			;	call clear_display 
205b			;'	call update_display 
205b			 
205b 3e 00		            LD   A, display_row_1 
205d			;            CALL fLCD_Pos       ;Position cursor to location in A 
205d 11 1b 20		            LD   DE, clear 
2060 cd af 0d				call str_at_display 
2063			;            CALL fLCD_Str       ;Display string pointed to by DE 
2063 3e 00		            LD   A, display_row_1 
2065			;            CALL fLCD_Pos       ;Position cursor to location in A 
2065 11 be f1		            LD   DE, scratch 
2068			;            CALL fLCD_Str       ;Display string pointed to by DE 
2068 cd af 0d				call str_at_display 
206b cd bf 0d			call update_display 
206e			 
206e 3e 00				ld a,0 
2070 21 be f1			ld hl, scratch 
2073 77				ld (hl),a 
2074			 
2074 00				nop 
2075 c3 3e 20			jp cloop 
2078			 
2078			 
2078			 
2078			; OS Prompt 
2078			 
2078 .. 00		prompt: db ">",0 
207a .. 00		endprg: db "?",0 
207c			 
207c			 
207c			; handy next page prompt 
207c			next_page_prompt: 
207c e5				push hl 
207d d5				push de 
207e f5				push af 
207f c5				push bc 
2080			 
2080 3e 9f			ld a,display_row_4 + display_cols - 1 
2082 11 7a 20		        ld de, endprg 
2085 cd af 0d			call str_at_display 
2088 cd bf 0d			call update_display 
208b cd c2 79			call cin_wait 
208e c1				pop bc 
208f f1				pop af 
2090 d1				pop de 
2091 e1				pop hl 
2092			 
2092			 
2092 c9				ret 
2093			 
2093			 
2093			; forth parser 
2093			 
2093			; My forth kernel 
2093			include "forth_kernel.asm" 
2093			; 
2093			; kernel to the forth OS 
2093			 
2093			DS_TYPE_STR: equ 1     ; string type 
2093			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
2093			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
2093			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
2093			 
2093			FORTH_PARSEV1: equ 0 
2093			FORTH_PARSEV2: equ 0 
2093			FORTH_PARSEV3: equ 0 
2093			FORTH_PARSEV4: equ 0 
2093			FORTH_PARSEV5: equ 1 
2093			 
2093			;if FORTH_PARSEV5 
2093			;	FORTH_END_BUFFER: equ 0 
2093			;else 
2093			FORTH_END_BUFFER: equ 127 
2093			;endif 
2093			 
2093			FORTH_TRUE: equ 1 
2093			FORTH_FALSE: equ 0 
2093			 
2093			if FORTH_PARSEV4 
2093			include "forth_stackops.asm" 
2093			endif 
2093			 
2093			if FORTH_PARSEV5 
2093			include "forth_stackopsv5.asm" 
2093			 
2093			; Stack operations for v5 parser on wards 
2093			; * DATA stack 
2093			; * LOOP stack 
2093			; * RETURN stack 
2093			 
2093			 
2093			 
2093			FORTH_CHK_DSP_UNDER: macro 
2093				push hl 
2093				push de 
2093				ld hl,(cli_data_sp) 
2093				ld de, cli_data_stack 
2093				call cmp16 
2093				jp c, fault_dsp_under 
2093				pop de 
2093				pop hl 
2093				endm 
2093			 
2093			 
2093			FORTH_CHK_RSP_UNDER: macro 
2093				push hl 
2093				push de 
2093				ld hl,(cli_ret_sp) 
2093				ld de, cli_ret_stack 
2093				call cmp16 
2093				jp c, fault_rsp_under 
2093				pop de 
2093				pop hl 
2093				endm 
2093			 
2093			FORTH_CHK_LOOP_UNDER: macro 
2093				push hl 
2093				push de 
2093				ld hl,(cli_loop_sp) 
2093				ld de, cli_loop_stack 
2093				call cmp16 
2093				jp c, fault_loop_under 
2093				pop de 
2093				pop hl 
2093				endm 
2093			 
2093			FORTH_ERR_TOS_NOTSTR: macro 
2093				; TOSO might need more for checks when used 
2093				push af 
2093				ld a,(hl) 
2093				cp DS_TYPE_STR 
2093				jp nz, type_faultn   
2093				pop af 
2093				endm 
2093			 
2093			FORTH_ERR_TOS_NOTNUM: macro 
2093				push af 
2093				ld a,(hl) 
2093				cp DS_TYPE_INUM 
2093				jp nz, type_faultn   
2093				pop af 
2093				endm 
2093			 
2093			 
2093			; increase data stack pointer and save hl to it 
2093				 
2093			FORTH_DSP_NEXT: macro 
2093				call macro_forth_dsp_next 
2093				endm 
2093			 
2093			 
2093			macro_forth_dsp_next: 
2093				if DEBUG_FORTH_STACK_GUARD 
2093 cd 6f 72				call check_stacks 
2096				endif 
2096 e5				push hl 
2097 d5				push de 
2098 eb				ex de,hl 
2099 2a eb f9			ld hl,(cli_data_sp) 
209c 23				inc hl 
209d 23				inc hl 
209e			 
209e			; PARSEV5 
209e 23				inc hl 
209f 22 eb f9			ld (cli_data_sp),hl 
20a2 73				ld (hl), e 
20a3 23				inc hl 
20a4 72				ld (hl), d 
20a5 d1				pop de 
20a6 e1				pop hl 
20a7				if DEBUG_FORTH_STACK_GUARD 
20a7 cd 6f 72				call check_stacks 
20aa				endif 
20aa c9				ret 
20ab			 
20ab			 
20ab			; increase ret stack pointer and save hl to it 
20ab				 
20ab			FORTH_RSP_NEXT: macro 
20ab				call macro_forth_rsp_next 
20ab				endm 
20ab			 
20ab			macro_forth_rsp_next: 
20ab				if DEBUG_FORTH_STACK_GUARD 
20ab cd 6f 72				call check_stacks 
20ae				endif 
20ae e5				push hl 
20af d5				push de 
20b0 eb				ex de,hl 
20b1 2a ef f9			ld hl,(cli_ret_sp) 
20b4 23				inc hl 
20b5 23				inc hl 
20b6 22 ef f9			ld (cli_ret_sp),hl 
20b9 73				ld (hl), e 
20ba 23				inc hl 
20bb 72				ld (hl), d 
20bc d1				pop de 
20bd e1				pop hl 
20be				if DEBUG_FORTH_STACK_GUARD 
20be cd 6f 72				call check_stacks 
20c1				endif 
20c1 c9				ret 
20c2			 
20c2			; get current ret stack pointer and save to hl  
20c2				 
20c2			FORTH_RSP_TOS: macro 
20c2				call macro_forth_rsp_tos 
20c2				endm 
20c2			 
20c2			macro_forth_rsp_tos: 
20c2				;push de 
20c2 2a ef f9			ld hl,(cli_ret_sp) 
20c5 cd fd 20			call loadhlptrtohl 
20c8				;ld e, (hl) 
20c8				;inc hl 
20c8				;ld d, (hl) 
20c8				;ex de, hl 
20c8					if DEBUG_FORTH_WORDS 
20c8			;			DMARK "RST" 
20c8						CALLMONITOR 
20c8 cd 6c fe			call debug_vector  
20cb				endm  
# End of macro CALLMONITOR
20cb					endif 
20cb				;pop de 
20cb c9				ret 
20cc			 
20cc			; pop ret stack pointer 
20cc				 
20cc			FORTH_RSP_POP: macro 
20cc				call macro_forth_rsp_pop 
20cc				endm 
20cc			 
20cc			 
20cc			macro_forth_rsp_pop: 
20cc				if DEBUG_FORTH_STACK_GUARD 
20cc			;		DMARK "RPP" 
20cc cd 6f 72				call check_stacks 
20cf					FORTH_CHK_RSP_UNDER 
20cf e5				push hl 
20d0 d5				push de 
20d1 2a ef f9			ld hl,(cli_ret_sp) 
20d4 11 a9 f9			ld de, cli_ret_stack 
20d7 cd ee 0f			call cmp16 
20da da 83 73			jp c, fault_rsp_under 
20dd d1				pop de 
20de e1				pop hl 
20df				endm 
# End of macro FORTH_CHK_RSP_UNDER
20df				endif 
20df e5				push hl 
20e0 2a ef f9			ld hl,(cli_ret_sp) 
20e3			 
20e3			 
20e3				if FORTH_ENABLE_FREE 
20e3			 
20e3					; get pointer 
20e3			 
20e3					push de 
20e3					push hl 
20e3			 
20e3					ld e, (hl) 
20e3					inc hl 
20e3					ld d, (hl) 
20e3			 
20e3					ex de, hl 
20e3					call free 
20e3			 
20e3					pop hl 
20e3					pop de 
20e3			 
20e3			 
20e3				endif 
20e3			 
20e3			 
20e3 2b				dec hl 
20e4 2b				dec hl 
20e5 22 ef f9			ld (cli_ret_sp), hl 
20e8				; do stack underflow checks 
20e8 e1				pop hl 
20e9				if DEBUG_FORTH_STACK_GUARD 
20e9 cd 6f 72				call check_stacks 
20ec					FORTH_CHK_RSP_UNDER 
20ec e5				push hl 
20ed d5				push de 
20ee 2a ef f9			ld hl,(cli_ret_sp) 
20f1 11 a9 f9			ld de, cli_ret_stack 
20f4 cd ee 0f			call cmp16 
20f7 da 83 73			jp c, fault_rsp_under 
20fa d1				pop de 
20fb e1				pop hl 
20fc				endm 
# End of macro FORTH_CHK_RSP_UNDER
20fc				endif 
20fc c9				ret 
20fd			 
20fd			 
20fd			 
20fd			; routine to load word pointed to by hl into hl 
20fd			 
20fd			loadhlptrtohl: 
20fd			 
20fd d5				push de 
20fe 5e				ld e, (hl) 
20ff 23				inc hl 
2100 56				ld d, (hl) 
2101 eb				ex de, hl 
2102 d1				pop de 
2103			 
2103 c9				ret 
2104			 
2104			 
2104			 
2104			 
2104			 
2104			; push a number held in HL onto the data stack 
2104			; entry point for pushing a value when already in hl used in function above 
2104			 
2104			forth_push_numhl: 
2104			 
2104 e5				push hl    ; save value to push 
2105			 
2105			if DEBUG_FORTH_PUSH 
2105				; see if disabled 
2105			 
2105			 
2105 f5				push af 
2106 3a 6c fe			ld a,(debug_vector) 
2109 fe c9			cp $c9   ; ret 
210b			;	ld a, (os_view_disable) 
210b			;	cp '*' 
210b 28 34			jr z, .pskip2 
210d e5				push hl 
210e e5			push hl 
210f cd 9c 0d			call clear_display 
2112 e1			pop hl 
2113 7c				ld a,h 
2114 21 c3 f4			ld hl, os_word_scratch 
2117 cd d1 12			call hexout 
211a e1				pop hl 
211b 7d				ld a,l 
211c 21 c5 f4			ld hl, os_word_scratch+2 
211f cd d1 12			call hexout 
2122			 
2122 21 c7 f4			ld hl, os_word_scratch+4 
2125 3e 00			ld a,0 
2127 77				ld (hl),a 
2128 11 c3 f4			ld de,os_word_scratch 
212b 3e 28				ld a, display_row_2 
212d cd af 0d				call str_at_display 
2130 11 ab 5d			ld de, .push_num 
2133 3e 00			ld a, display_row_1 
2135			 
2135 cd af 0d				call str_at_display 
2138			 
2138			 
2138 cd bf 0d			call update_display 
213b cd df 0c			call delay1s 
213e cd df 0c			call delay1s 
2141			.pskip2:  
2141			 
2141 f1				pop af 
2142			endif	 
2142			 
2142			 
2142				FORTH_DSP_NEXT 
2142 cd 93 20			call macro_forth_dsp_next 
2145				endm 
# End of macro FORTH_DSP_NEXT
2145			 
2145 2a eb f9			ld hl, (cli_data_sp) 
2148			 
2148				; save item type 
2148 3e 02			ld a,  DS_TYPE_INUM 
214a 77				ld (hl), a 
214b 23				inc hl 
214c			 
214c				; get word off stack 
214c d1				pop de 
214d 7b				ld a,e 
214e 77				ld (hl), a 
214f 23				inc hl 
2150 7a				ld a,d 
2151 77				ld (hl), a 
2152			 
2152			if DEBUG_FORTH_PUSH 
2152 2b				dec hl 
2153 2b				dec hl 
2154 2b				dec hl 
2155						DMARK "PH5" 
2155 f5				push af  
2156 3a 6a 21			ld a, (.dmark)  
2159 32 68 fe			ld (debug_mark),a  
215c 3a 6b 21			ld a, (.dmark+1)  
215f 32 69 fe			ld (debug_mark+1),a  
2162 3a 6c 21			ld a, (.dmark+2)  
2165 32 6a fe			ld (debug_mark+2),a  
2168 18 03			jr .pastdmark  
216a ..			.dmark: db "PH5"  
216d f1			.pastdmark: pop af  
216e			endm  
# End of macro DMARK
216e				CALLMONITOR 
216e cd 6c fe			call debug_vector  
2171				endm  
# End of macro CALLMONITOR
2171			endif	 
2171			 
2171 c9				ret 
2172			 
2172			 
2172			; Push a string to stack pointed to by hl 
2172			 
2172			forth_push_str: 
2172			 
2172			if DEBUG_FORTH_PUSH 
2172						DMARK "PSQ" 
2172 f5				push af  
2173 3a 87 21			ld a, (.dmark)  
2176 32 68 fe			ld (debug_mark),a  
2179 3a 88 21			ld a, (.dmark+1)  
217c 32 69 fe			ld (debug_mark+1),a  
217f 3a 89 21			ld a, (.dmark+2)  
2182 32 6a fe			ld (debug_mark+2),a  
2185 18 03			jr .pastdmark  
2187 ..			.dmark: db "PSQ"  
218a f1			.pastdmark: pop af  
218b			endm  
# End of macro DMARK
218b				CALLMONITOR 
218b cd 6c fe			call debug_vector  
218e				endm  
# End of macro CALLMONITOR
218e			endif	 
218e			    
218e e5				push hl 
218f e5				push hl 
2190			 
2190			;	ld a, 0   ; find end of string 
2190 cd 2e 14			call strlenz 
2193			if DEBUG_FORTH_PUSH 
2193						DMARK "PQ2" 
2193 f5				push af  
2194 3a a8 21			ld a, (.dmark)  
2197 32 68 fe			ld (debug_mark),a  
219a 3a a9 21			ld a, (.dmark+1)  
219d 32 69 fe			ld (debug_mark+1),a  
21a0 3a aa 21			ld a, (.dmark+2)  
21a3 32 6a fe			ld (debug_mark+2),a  
21a6 18 03			jr .pastdmark  
21a8 ..			.dmark: db "PQ2"  
21ab f1			.pastdmark: pop af  
21ac			endm  
# End of macro DMARK
21ac				CALLMONITOR 
21ac cd 6c fe			call debug_vector  
21af				endm  
# End of macro CALLMONITOR
21af			endif	 
21af eb				ex de, hl 
21b0 e1				pop hl   ; get ptr to start of string 
21b1			if DEBUG_FORTH_PUSH 
21b1						DMARK "PQ3" 
21b1 f5				push af  
21b2 3a c6 21			ld a, (.dmark)  
21b5 32 68 fe			ld (debug_mark),a  
21b8 3a c7 21			ld a, (.dmark+1)  
21bb 32 69 fe			ld (debug_mark+1),a  
21be 3a c8 21			ld a, (.dmark+2)  
21c1 32 6a fe			ld (debug_mark+2),a  
21c4 18 03			jr .pastdmark  
21c6 ..			.dmark: db "PQ3"  
21c9 f1			.pastdmark: pop af  
21ca			endm  
# End of macro DMARK
21ca				CALLMONITOR 
21ca cd 6c fe			call debug_vector  
21cd				endm  
# End of macro CALLMONITOR
21cd			endif	 
21cd 19				add hl,de 
21ce			if DEBUG_FORTH_PUSH 
21ce						DMARK "PQE" 
21ce f5				push af  
21cf 3a e3 21			ld a, (.dmark)  
21d2 32 68 fe			ld (debug_mark),a  
21d5 3a e4 21			ld a, (.dmark+1)  
21d8 32 69 fe			ld (debug_mark+1),a  
21db 3a e5 21			ld a, (.dmark+2)  
21de 32 6a fe			ld (debug_mark+2),a  
21e1 18 03			jr .pastdmark  
21e3 ..			.dmark: db "PQE"  
21e6 f1			.pastdmark: pop af  
21e7			endm  
# End of macro DMARK
21e7				CALLMONITOR 
21e7 cd 6c fe			call debug_vector  
21ea				endm  
# End of macro CALLMONITOR
21ea			endif	 
21ea			 
21ea 2b				dec hl    ; see if there is an optional trailing double quote 
21eb 7e				ld a,(hl) 
21ec fe 22			cp '"' 
21ee 20 03			jr nz, .strnoq 
21f0 3e 00			ld a, 0      ; get rid of double quote 
21f2 77				ld (hl), a 
21f3 23			.strnoq: inc hl 
21f4			 
21f4 3e 00			ld a, 0 
21f6 77				ld (hl), a     ; add null term and get rid of trailing double quote 
21f7			 
21f7 13				inc de ; add one for the type string 
21f8 13				inc de ; add one for null term??? 
21f9			 
21f9				; tos is get string pointer again 
21f9				; de contains space to allocate 
21f9				 
21f9 d5				push de 
21fa			 
21fa eb				ex de, hl 
21fb			 
21fb				;push af 
21fb			 
21fb			if DEBUG_FORTH_PUSH 
21fb						DMARK "PHm" 
21fb f5				push af  
21fc 3a 10 22			ld a, (.dmark)  
21ff 32 68 fe			ld (debug_mark),a  
2202 3a 11 22			ld a, (.dmark+1)  
2205 32 69 fe			ld (debug_mark+1),a  
2208 3a 12 22			ld a, (.dmark+2)  
220b 32 6a fe			ld (debug_mark+2),a  
220e 18 03			jr .pastdmark  
2210 ..			.dmark: db "PHm"  
2213 f1			.pastdmark: pop af  
2214			endm  
# End of macro DMARK
2214				CALLMONITOR 
2214 cd 6c fe			call debug_vector  
2217				endm  
# End of macro CALLMONITOR
2217			endif	 
2217 cd 97 14			call malloc	; on ret hl now contains allocated memory 
221a				if DEBUG_FORTH_MALLOC_GUARD 
221a cc 03 5e				call z,malloc_error 
221d				endif 
221d			 
221d				 
221d c1				pop bc    ; get length 
221e d1				pop de   ;  get string start    
221f			 
221f				; hl has destination from malloc 
221f			 
221f eb				ex de, hl    ; prep for ldir 
2220			 
2220 d5				push de   ; save malloc area for DSP later 
2221				;push hl   ; save malloc area for DSP later 
2221			 
2221			if DEBUG_FORTH_PUSH 
2221						DMARK "PHc" 
2221 f5				push af  
2222 3a 36 22			ld a, (.dmark)  
2225 32 68 fe			ld (debug_mark),a  
2228 3a 37 22			ld a, (.dmark+1)  
222b 32 69 fe			ld (debug_mark+1),a  
222e 3a 38 22			ld a, (.dmark+2)  
2231 32 6a fe			ld (debug_mark+2),a  
2234 18 03			jr .pastdmark  
2236 ..			.dmark: db "PHc"  
2239 f1			.pastdmark: pop af  
223a			endm  
# End of macro DMARK
223a				CALLMONITOR 
223a cd 6c fe			call debug_vector  
223d				endm  
# End of macro CALLMONITOR
223d			endif	 
223d			 
223d			 
223d ed b0			ldir 
223f			 
223f			 
223f				; push malloc to data stack     macro?????  
223f			 
223f				FORTH_DSP_NEXT 
223f cd 93 20			call macro_forth_dsp_next 
2242				endm 
# End of macro FORTH_DSP_NEXT
2242			 
2242				; save value and type 
2242			 
2242 2a eb f9			ld hl, (cli_data_sp) 
2245			 
2245				; save item type 
2245 3e 01			ld a,  DS_TYPE_STR 
2247 77				ld (hl), a 
2248 23				inc hl 
2249			 
2249				; get malloc word off stack 
2249 d1				pop de 
224a 73				ld (hl), e 
224b 23				inc hl 
224c 72				ld (hl), d 
224d			 
224d			 
224d			 
224d			if DEBUG_FORTH_PUSH 
224d 2a eb f9			ld hl, (cli_data_sp) 
2250						DMARK "PHS" 
2250 f5				push af  
2251 3a 65 22			ld a, (.dmark)  
2254 32 68 fe			ld (debug_mark),a  
2257 3a 66 22			ld a, (.dmark+1)  
225a 32 69 fe			ld (debug_mark+1),a  
225d 3a 67 22			ld a, (.dmark+2)  
2260 32 6a fe			ld (debug_mark+2),a  
2263 18 03			jr .pastdmark  
2265 ..			.dmark: db "PHS"  
2268 f1			.pastdmark: pop af  
2269			endm  
# End of macro DMARK
2269				CALLMONITOR 
2269 cd 6c fe			call debug_vector  
226c				endm  
# End of macro CALLMONITOR
226c			;	ex de,hl 
226c			endif	 
226c				; in case of spaces, skip the ptr past the copied string 
226c				;pop af 
226c				;ld (cli_origptr),hl 
226c			 
226c c9				ret 
226d			 
226d			 
226d			 
226d			; TODO ascii push input onto stack given hl to start of input 
226d			 
226d			; identify type 
226d			; if starts with a " then a string 
226d			; otherwise it is a number 
226d			;  
226d			; if a string 
226d			;     scan for ending " to get length of string to malloc for + 1 
226d			;     malloc 
226d			;     put pointer to string on stack first byte flags as string 
226d			; 
226d			; else a number 
226d			;    look for number format identifier 
226d			;    $xx hex 
226d			;    %xxxxx bin 
226d			;    xxxxx decimal 
226d			;    convert number to 16bit word.  
226d			;    malloc word + 1 with flag to identiy as num 
226d			;    put pointer to number on stack 
226d			;   
226d			;  
226d			  
226d			forth_apush: 
226d				; kernel push 
226d			 
226d			if DEBUG_FORTH_PUSH 
226d						DMARK "PSH" 
226d f5				push af  
226e 3a 82 22			ld a, (.dmark)  
2271 32 68 fe			ld (debug_mark),a  
2274 3a 83 22			ld a, (.dmark+1)  
2277 32 69 fe			ld (debug_mark+1),a  
227a 3a 84 22			ld a, (.dmark+2)  
227d 32 6a fe			ld (debug_mark+2),a  
2280 18 03			jr .pastdmark  
2282 ..			.dmark: db "PSH"  
2285 f1			.pastdmark: pop af  
2286			endm  
# End of macro DMARK
2286				CALLMONITOR 
2286 cd 6c fe			call debug_vector  
2289				endm  
# End of macro CALLMONITOR
2289			endif	 
2289				; identify input type 
2289			 
2289 7e				ld a,(hl) 
228a fe 22			cp '"' 
228c 28 0a			jr z, .fapstr 
228e fe 24			cp '$' 
2290 ca b8 22			jp z, .faphex 
2293 fe 25			cp '%' 
2295 ca a0 22			jp z, .fapbin 
2298			;	cp 'b' 
2298			;	jp z, .fabin 
2298				; else decimal 
2298			 
2298				; TODO do decimal conversion 
2298				; decimal is stored as a 16bit word 
2298			 
2298				; by default everything is a string if type is not detected 
2298			.fapstr: ; 
2298 fe 22			cp '"' 
229a 20 01			jr nz, .strnoqu 
229c 23				inc hl 
229d			.strnoqu: 
229d c3 72 21			jp forth_push_str 
22a0			 
22a0			 
22a0			 
22a0			.fapbin:    ; push a binary string.  
22a0 11 00 00			ld de, 0   ; hold a 16bit value 
22a3			 
22a3 23			.fapbinshift:	inc hl  
22a4 7e				ld a,(hl) 
22a5 fe 00			cp 0     ; done scanning  
22a7 28 0b			jr z, .fapbdone  	; got it in HL so push  
22a9			 
22a9				; left shift de 
22a9 eb				ex de, hl	 
22aa 29				add hl, hl 
22ab			 
22ab				; is 1 
22ab fe 31			cp '1' 
22ad 20 02			jr nz, .binzero 
22af cb 4d			bit 1, l 
22b1			.binzero: 
22b1 eb				ex de, hl	 ; save current de 
22b2 18 ef			jr .fapbinshift 
22b4			 
22b4			.fapbdone: 
22b4 eb				ex de, hl 
22b5 c3 04 21			jp forth_push_numhl 
22b8			 
22b8			 
22b8			.faphex:   ; hex is always stored as a 16bit word 
22b8				; skip number prefix 
22b8 23				inc hl 
22b9				; turn ascii into number 
22b9 cd 87 13			call get_word_hl	; ret 16bit word in hl 
22bc			 
22bc c3 04 21			jp forth_push_numhl 
22bf			 
22bf 00				 nop 
22c0			 
22c0			.fabin:   ; TODO bin conversion 
22c0			 
22c0			 
22c0 c9				ret 
22c1			 
22c1			 
22c1			; get either a string ptr or a 16bit word from the data stack 
22c1			 
22c1			FORTH_DSP: macro 
22c1				call macro_forth_dsp 
22c1				endm 
22c1			 
22c1			macro_forth_dsp: 
22c1				; data stack pointer points to current word on tos 
22c1			 
22c1 2a eb f9			ld hl,(cli_data_sp) 
22c4			 
22c4				if DEBUG_FORTH_PUSH 
22c4						DMARK "DSP" 
22c4 f5				push af  
22c5 3a d9 22			ld a, (.dmark)  
22c8 32 68 fe			ld (debug_mark),a  
22cb 3a da 22			ld a, (.dmark+1)  
22ce 32 69 fe			ld (debug_mark+1),a  
22d1 3a db 22			ld a, (.dmark+2)  
22d4 32 6a fe			ld (debug_mark+2),a  
22d7 18 03			jr .pastdmark  
22d9 ..			.dmark: db "DSP"  
22dc f1			.pastdmark: pop af  
22dd			endm  
# End of macro DMARK
22dd			 
22dd cd 36 5e				call display_data_sp 
22e0				;call break_point_state 
22e0				;rst 030h 
22e0				CALLMONITOR 
22e0 cd 6c fe			call debug_vector  
22e3				endm  
# End of macro CALLMONITOR
22e3				endif 
22e3			 
22e3 c9				ret 
22e4			 
22e4			; return hl to start of value on stack 
22e4			 
22e4			FORTH_DSP_VALUE: macro 
22e4				call macro_forth_dsp_value 
22e4				endm 
22e4			 
22e4			macro_forth_dsp_value: 
22e4			 
22e4				FORTH_DSP 
22e4 cd c1 22			call macro_forth_dsp 
22e7				endm 
# End of macro FORTH_DSP
22e7			 
22e7 d5				push de 
22e8			 
22e8 23				inc hl ; skip type 
22e9			 
22e9 5e				ld e, (hl) 
22ea 23				inc hl 
22eb 56				ld d, (hl) 
22ec eb				ex de,hl  
22ed			 
22ed d1				pop de 
22ee			 
22ee c9				ret 
22ef			 
22ef			; return hl to start of value to second item on stack 
22ef			 
22ef			FORTH_DSP_VALUEM1: macro 
22ef				call macro_forth_dsp_value_m1 
22ef				endm 
22ef			 
22ef			macro_forth_dsp_value_m1: 
22ef			 
22ef				FORTH_DSP 
22ef cd c1 22			call macro_forth_dsp 
22f2				endm 
# End of macro FORTH_DSP
22f2			 
22f2 2b				dec hl 
22f3 2b				dec hl 
22f4			;	dec hl 
22f4			 
22f4 d5				push de 
22f5			 
22f5 5e				ld e, (hl) 
22f6 23				inc hl 
22f7 56				ld d, (hl) 
22f8 eb				ex de,hl  
22f9			 
22f9 d1				pop de 
22fa			 
22fa c9				ret 
22fb			 
22fb				 
22fb			 
22fb			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
22fb			 
22fb			FORTH_DSP_POP: macro 
22fb				call macro_forth_dsp_pop 
22fb				endm 
22fb			 
22fb			 
22fb			; get the tos data type 
22fb			 
22fb			FORTH_DSP_TYPE:   macro 
22fb			 
22fb				;FORTH_DSP_VALUE 
22fb				FORTH_DSP 
22fb				 
22fb				; hl points to value 
22fb				; check type 
22fb			 
22fb				ld a,(hl) 
22fb			 
22fb				endm 
22fb			 
22fb			; load the tos value into hl 
22fb			 
22fb			 
22fb			FORTH_DSP_VALUEHL:  macro 
22fb				call macro_dsp_valuehl 
22fb				endm 
22fb			 
22fb			 
22fb			 
22fb			macro_dsp_valuehl: 
22fb				FORTH_DSP_VALUE 
22fb cd e4 22			call macro_forth_dsp_value 
22fe				endm 
# End of macro FORTH_DSP_VALUE
22fe			 
22fe				;FORTH_ERR_TOS_NOTNUM 
22fe			 
22fe				;inc hl   ; skip type id 
22fe			 
22fe			;	push de 
22fe			; 
22fe			;	ld e, (hl) 
22fe			;	inc hl 
22fe			;	ld d, (hl) 
22fe			;	ex de,hl  
22fe			 
22fe			;	pop de 
22fe			 
22fe				if DEBUG_FORTH_PUSH 
22fe						DMARK "DVL" 
22fe f5				push af  
22ff 3a 13 23			ld a, (.dmark)  
2302 32 68 fe			ld (debug_mark),a  
2305 3a 14 23			ld a, (.dmark+1)  
2308 32 69 fe			ld (debug_mark+1),a  
230b 3a 15 23			ld a, (.dmark+2)  
230e 32 6a fe			ld (debug_mark+2),a  
2311 18 03			jr .pastdmark  
2313 ..			.dmark: db "DVL"  
2316 f1			.pastdmark: pop af  
2317			endm  
# End of macro DMARK
2317				CALLMONITOR 
2317 cd 6c fe			call debug_vector  
231a				endm  
# End of macro CALLMONITOR
231a				endif 
231a c9				ret 
231b			 
231b			forth_apushstrhl:      
231b				; push of string requires use of cli_origptr 
231b				; bodge use 
231b			 
231b				; get current cli_origptr, save, update with temp pointer  
231b ed 5b 3b fa		ld de, (cli_origptr) 
231f 22 3b fa			ld (cli_origptr), hl 
2322 d5				push de 
2323 cd 6d 22			call forth_apush 
2326 d1				pop de 
2327 ed 53 3b fa		ld (cli_origptr), de 
232b c9			        ret	 
232c			 
232c			 
232c			; increase loop stack pointer and save hl to it 
232c				 
232c			FORTH_LOOP_NEXT: macro 
232c				call macro_forth_loop_next 
232c				;nop 
232c				endm 
232c			 
232c			macro_forth_loop_next: 
232c				if DEBUG_FORTH_STACK_GUARD 
232c cd 6f 72				call check_stacks 
232f				endif 
232f e5				push hl 
2330 d5				push de 
2331 eb				ex de,hl 
2332 2a ed f9			ld hl,(cli_loop_sp) 
2335 23				inc hl 
2336 23				inc hl 
2337					if DEBUG_FORTH_WORDS 
2337						DMARK "LNX" 
2337 f5				push af  
2338 3a 4c 23			ld a, (.dmark)  
233b 32 68 fe			ld (debug_mark),a  
233e 3a 4d 23			ld a, (.dmark+1)  
2341 32 69 fe			ld (debug_mark+1),a  
2344 3a 4e 23			ld a, (.dmark+2)  
2347 32 6a fe			ld (debug_mark+2),a  
234a 18 03			jr .pastdmark  
234c ..			.dmark: db "LNX"  
234f f1			.pastdmark: pop af  
2350			endm  
# End of macro DMARK
2350						CALLMONITOR 
2350 cd 6c fe			call debug_vector  
2353				endm  
# End of macro CALLMONITOR
2353					endif 
2353 22 ed f9			ld (cli_loop_sp),hl 
2356 73				ld (hl), e 
2357 23				inc hl 
2358 72				ld (hl), d 
2359 d1				pop de    ; been reversed so save a swap on restore 
235a e1				pop hl 
235b				if DEBUG_FORTH_STACK_GUARD 
235b cd 6f 72				call check_stacks 
235e				endif 
235e c9				ret 
235f			 
235f			; get current ret stack pointer and save to hl  
235f				 
235f			FORTH_LOOP_TOS: macro 
235f				call macro_forth_loop_tos 
235f				endm 
235f			 
235f			macro_forth_loop_tos: 
235f d5				push de 
2360 2a ed f9			ld hl,(cli_loop_sp) 
2363 5e				ld e, (hl) 
2364 23				inc hl 
2365 56				ld d, (hl) 
2366 eb				ex de, hl 
2367 d1				pop de 
2368 c9				ret 
2369			 
2369			; pop loop stack pointer 
2369				 
2369			FORTH_LOOP_POP: macro 
2369				call macro_forth_loop_pop 
2369				endm 
2369			 
2369			 
2369			macro_forth_loop_pop: 
2369				if DEBUG_FORTH_STACK_GUARD 
2369					DMARK "LPP" 
2369 f5				push af  
236a 3a 7e 23			ld a, (.dmark)  
236d 32 68 fe			ld (debug_mark),a  
2370 3a 7f 23			ld a, (.dmark+1)  
2373 32 69 fe			ld (debug_mark+1),a  
2376 3a 80 23			ld a, (.dmark+2)  
2379 32 6a fe			ld (debug_mark+2),a  
237c 18 03			jr .pastdmark  
237e ..			.dmark: db "LPP"  
2381 f1			.pastdmark: pop af  
2382			endm  
# End of macro DMARK
2382 cd 6f 72				call check_stacks 
2385					FORTH_CHK_LOOP_UNDER 
2385 e5				push hl 
2386 d5				push de 
2387 2a ed f9			ld hl,(cli_loop_sp) 
238a 11 27 f9			ld de, cli_loop_stack 
238d cd ee 0f			call cmp16 
2390 da 89 73			jp c, fault_loop_under 
2393 d1				pop de 
2394 e1				pop hl 
2395				endm 
# End of macro FORTH_CHK_LOOP_UNDER
2395				endif 
2395 e5				push hl 
2396 2a ed f9			ld hl,(cli_loop_sp) 
2399 2b				dec hl 
239a 2b				dec hl 
239b 22 ed f9			ld (cli_loop_sp), hl 
239e				; TODO do stack underflow checks 
239e e1				pop hl 
239f				if DEBUG_FORTH_STACK_GUARD 
239f cd 6f 72				call check_stacks 
23a2					FORTH_CHK_LOOP_UNDER 
23a2 e5				push hl 
23a3 d5				push de 
23a4 2a ed f9			ld hl,(cli_loop_sp) 
23a7 11 27 f9			ld de, cli_loop_stack 
23aa cd ee 0f			call cmp16 
23ad da 89 73			jp c, fault_loop_under 
23b0 d1				pop de 
23b1 e1				pop hl 
23b2				endm 
# End of macro FORTH_CHK_LOOP_UNDER
23b2				endif 
23b2 c9				ret 
23b3			 
23b3			macro_forth_dsp_pop: 
23b3			 
23b3 e5				push hl 
23b4			 
23b4				; release malloc data 
23b4			 
23b4				if DEBUG_FORTH_STACK_GUARD 
23b4 cd 6f 72				call check_stacks 
23b7					FORTH_CHK_DSP_UNDER 
23b7 e5				push hl 
23b8 d5				push de 
23b9 2a eb f9			ld hl,(cli_data_sp) 
23bc 11 25 f7			ld de, cli_data_stack 
23bf cd ee 0f			call cmp16 
23c2 da 7d 73			jp c, fault_dsp_under 
23c5 d1				pop de 
23c6 e1				pop hl 
23c7				endm 
# End of macro FORTH_CHK_DSP_UNDER
23c7				endif 
23c7				;ld hl,(cli_data_sp) 
23c7			if DEBUG_FORTH_DOT 
23c7				DMARK "DPP" 
23c7 f5				push af  
23c8 3a dc 23			ld a, (.dmark)  
23cb 32 68 fe			ld (debug_mark),a  
23ce 3a dd 23			ld a, (.dmark+1)  
23d1 32 69 fe			ld (debug_mark+1),a  
23d4 3a de 23			ld a, (.dmark+2)  
23d7 32 6a fe			ld (debug_mark+2),a  
23da 18 03			jr .pastdmark  
23dc ..			.dmark: db "DPP"  
23df f1			.pastdmark: pop af  
23e0			endm  
# End of macro DMARK
23e0				CALLMONITOR 
23e0 cd 6c fe			call debug_vector  
23e3				endm  
# End of macro CALLMONITOR
23e3			endif	 
23e3			 
23e3			 
23e3			if FORTH_ENABLE_DSPPOPFREE 
23e3			 
23e3				FORTH_DSP 
23e3 cd c1 22			call macro_forth_dsp 
23e6				endm 
# End of macro FORTH_DSP
23e6			 
23e6 7e				ld a, (hl) 
23e7 fe 01			cp DS_TYPE_STR 
23e9 20 23			jr nz, .skippopfree 
23eb			 
23eb				FORTH_DSP_VALUEHL 
23eb cd fb 22			call macro_dsp_valuehl 
23ee				endm 
# End of macro FORTH_DSP_VALUEHL
23ee 00				nop 
23ef			if DEBUG_FORTH_DOT 
23ef				DMARK "DPf" 
23ef f5				push af  
23f0 3a 04 24			ld a, (.dmark)  
23f3 32 68 fe			ld (debug_mark),a  
23f6 3a 05 24			ld a, (.dmark+1)  
23f9 32 69 fe			ld (debug_mark+1),a  
23fc 3a 06 24			ld a, (.dmark+2)  
23ff 32 6a fe			ld (debug_mark+2),a  
2402 18 03			jr .pastdmark  
2404 ..			.dmark: db "DPf"  
2407 f1			.pastdmark: pop af  
2408			endm  
# End of macro DMARK
2408				CALLMONITOR 
2408 cd 6c fe			call debug_vector  
240b				endm  
# End of macro CALLMONITOR
240b			endif	 
240b cd 61 15			call free 
240e			.skippopfree: 
240e				 
240e			 
240e			endif 
240e			 
240e			if DEBUG_FORTH_DOT_KEY 
240e				DMARK "DP2" 
240e				CALLMONITOR 
240e			endif	 
240e			 
240e				; move pointer down 
240e			 
240e 2a eb f9			ld hl,(cli_data_sp) 
2411 2b				dec hl 
2412 2b				dec hl 
2413			; PARSEV5 
2413 2b				dec hl 
2414 22 eb f9			ld (cli_data_sp), hl 
2417			 
2417				if DEBUG_FORTH_STACK_GUARD 
2417 cd 6f 72				call check_stacks 
241a					FORTH_CHK_DSP_UNDER 
241a e5				push hl 
241b d5				push de 
241c 2a eb f9			ld hl,(cli_data_sp) 
241f 11 25 f7			ld de, cli_data_stack 
2422 cd ee 0f			call cmp16 
2425 da 7d 73			jp c, fault_dsp_under 
2428 d1				pop de 
2429 e1				pop hl 
242a				endm 
# End of macro FORTH_CHK_DSP_UNDER
242a				endif 
242a			 
242a e1				pop hl 
242b			 
242b c9				ret 
242c			 
242c			getwordathl: 
242c				; hl points to an address 
242c				; load hl with the word at that address 
242c			 
242c d5				push de 
242d			 
242d 5e				ld e, (hl) 
242e 23				inc hl 
242f 56				ld d, (hl) 
2430 eb				ex de, hl 
2431			 
2431 d1				pop de 
2432 c9				ret 
2433			 
2433			 
2433			 
2433			 
2433			 
2433			; eof 
2433			 
# End of file forth_stackopsv5.asm
2433			endif 
2433			 
2433			loadwordinhl:	 
2433			 
2433 d5				push de 
2434			 
2434 5e				ld e, (hl) 
2435 23				inc hl 
2436 56				ld d, (hl) 
2437 eb				ex de,hl  
2438			 
2438 d1				pop de 
2439			 
2439 c9				ret 
243a			 
243a			user_word_eol:  
243a				; hl contains the pointer to where to create a linked list item from the end 
243a				; of the user dict to continue on at the system word dict 
243a				 
243a				; poke the stub of the word list linked list to repoint to rom words 
243a			 
243a				; stub format 
243a				; db   word id 
243a				; dw    link to next word 
243a			        ; db char length of token 
243a				; db string + 0 term 
243a				; db exec code....  
243a			 
243a 3e 00			ld a, WORD_SYS_ROOT     ; root word 
243c 77				ld (hl), a		; word id 
243d 23				inc hl 
243e			 
243e 11 09 26			ld de, sysdict 
2441 73				ld (hl), e		; next word link ie system dict 
2442 23				inc hl 
2443 72				ld (hl), d		; next word link ie system dict 
2444 23				inc hl	 
2445			 
2445			;	ld (hl), sysdict		; next word link ie system dict 
2445			;	inc hl 
2445			;	inc hl 
2445			 
2445			;	inc hl 
2445			;	inc hl 
2445			 
2445 3e 02			ld a, 2			; word length is 0 
2447 77				ld (hl), a	 
2448 23				inc hl 
2449			 
2449 3e 7e			ld a, '~'			; word length is 0 
244b 77				ld (hl), a	 
244c 23				inc hl 
244d 3e 00			ld a, 0			; save empty word 
244f 77				ld (hl), a 
2450			 
2450 c9				ret 
2451			 
2451				 
2451			 
2451			forthexec_cleanup: 
2451				FORTH_RSP_POP 
2451 cd cc 20			call macro_forth_rsp_pop 
2454				endm 
# End of macro FORTH_RSP_POP
2454 c9				ret 
2455			 
2455			forth_call_hl: 
2455				; taking hl 
2455 e5				push hl 
2456 c9				ret 
2457			 
2457			; this is called to reset Forth system but keep existing uwords etc 
2457			 
2457			forth_warmstart: 
2457				; setup stack over/under flow checks 
2457				if DEBUG_FORTH_STACK_GUARD 
2457 cd 55 72				call chk_stk_init 
245a				endif 
245a			 
245a				; init stack pointers  - * these stacks go upwards *  
245a 21 a9 f9			ld hl, cli_ret_stack 
245d 22 ef f9			ld (cli_ret_sp), hl	 
2460				; set bottom of stack 
2460 3e 00			ld a,0 
2462 77				ld (hl),a 
2463 23				inc hl 
2464 77				ld (hl),a 
2465			 
2465 21 25 f7			ld hl, cli_data_stack 
2468 22 eb f9			ld (cli_data_sp), hl	 
246b				; set bottom of stack 
246b 3e 00			ld a,0 
246d 77				ld (hl),a 
246e 23				inc hl 
246f 77				ld (hl),a 
2470			 
2470 21 27 f9			ld hl, cli_loop_stack 
2473 22 ed f9			ld (cli_loop_sp), hl	 
2476				; set bottom of stack 
2476 3e 00			ld a,0 
2478 77				ld (hl),a 
2479 23				inc hl 
247a 77				ld (hl),a 
247b			 
247b				; init extent of current open file 
247b			 
247b 3e 00			ld a, 0 
247d 32 67 fa			ld (store_openext), a 
2480			 
2480 c9				ret 
2481			 
2481			 
2481			 
2481			; Cold Start - this is called to setup the whole Forth system 
2481			 
2481			forth_init: 
2481			 
2481				; setup stack over/under flow checks 
2481			 
2481			;	if DEBUG_FORTH_STACK_GUARD 
2481			;		call chk_stk_init 
2481			;	endif 
2481			 
2481				; enable auto display updates (slow.....) 
2481			 
2481 3e 01			ld a, 1 
2483 32 39 fa			ld (cli_autodisplay), a 
2486			 
2486				; if storage is in use disable long reads for now 
2486 3e 00			ld a, 0 
2488 32 72 fa			ld (store_longread), a 
248b			 
248b			 
248b				; show start up screen 
248b			 
248b cd 9c 0d			call clear_display 
248e			 
248e 3e 00			ld a,0 
2490 32 5b fa			ld (f_cursor_ptr), a 
2493			 
2493				; set start of word list in start of ram - for use when creating user words 
2493			 
2493 21 00 80			ld hl, baseram 
2496 22 bb f4			ld (os_last_new_uword), hl 
2499 cd 3a 24			call user_word_eol 
249c				 
249c			;		call display_data_sp 
249c			;		call next_page_prompt 
249c			 
249c			 
249c			 
249c			 
249c c9				ret 
249d			 
249d .. 00		.bootforth: db " Forth Kernel Init ",0 
24b1			 
24b1			; TODO push to stack 
24b1			 
24b1			;  
24b1			 
24b1			if FORTH_PARSEV2 
24b1			 
24b1			 
24b1				include "forth_parserv2.asm" 
24b1			 
24b1			endif 
24b1			 
24b1			 
24b1			; parse cli version 1 
24b1			 
24b1			if FORTH_PARSEV1 
24b1			 
24b1			 
24b1			 
24b1			      include "forth_parserv1.asm" 
24b1			endif 
24b1				 
24b1			if FORTH_PARSEV3 
24b1			 
24b1			 
24b1			 
24b1			      include "forth_parserv3.asm" 
24b1				include "forth_wordsv3.asm" 
24b1			endif 
24b1			 
24b1			if FORTH_PARSEV4 
24b1			 
24b1			 
24b1			 
24b1			      include "forth_parserv4.asm" 
24b1				include "forth_wordsv4.asm" 
24b1			endif 
24b1			 
24b1			if FORTH_PARSEV5 
24b1			 
24b1			 
24b1			 
24b1			      include "forth_parserv5.asm" 
24b1			 
24b1			 
24b1			; A better parser without using malloc and string copies all over the place.  
24b1			; Exec in situ should be faster 
24b1			 
24b1			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
24b1			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
24b1			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
24b1			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
24b1			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
24b1			WORD_SYS_END: equ 0   ; Opcode for all user words 
24b1			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
24b1			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
24b1			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
24b1			 
24b1			; Core word preamble macro 
24b1			 
24b1			CWHEAD:   macro nxtword opcode lit len opflags 
24b1				db WORD_SYS_CORE+opcode             
24b1				; internal op code number 
24b1				dw nxtword            
24b1				; link to next dict word block 
24b1				db len + 1 
24b1				; literal length of dict word inc zero term 
24b1				db lit,0              
24b1				; literal dict word 
24b1			        ; TODO db opflags        
24b1				endm 
24b1			 
24b1			 
24b1			NEXTW: macro  
24b1				jp macro_next 
24b1				endm 
24b1			 
24b1			macro_next: 
24b1			if DEBUG_FORTH_PARSE_KEY 
24b1				DMARK "NXT" 
24b1				CALLMONITOR 
24b1			endif	 
24b1			;	inc hl  ; skip token null term  
24b1 ed 4b 3d fa		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
24b5 ed 5b 3b fa		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
24b9 2a bf f4			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
24bc			if DEBUG_FORTH_PARSE_KEY 
24bc				DMARK "}AA" 
24bc				CALLMONITOR 
24bc			endif	 
24bc c3 bf 25			jp execnext 
24bf				;jp exec1 
24bf			       
24bf			 
24bf			 
24bf			; Another go at the parser to compile  
24bf			 
24bf			 
24bf			; TODO rework parser to change all of the string words to byte tokens 
24bf			; TODO do a search for  
24bf			 
24bf			; TODO first run normal parser to zero term sections 
24bf			; TODO for each word do a token look up to get the op code 
24bf			; TODO need some means to flag to the exec that this is a byte code form    
24bf			 
24bf			 
24bf			forthcompile: 
24bf			 
24bf			; 
24bf			; line parse: 
24bf			;       parse raw input buffer 
24bf			;       tokenise the words 
24bf			;       malloc new copy (for looping etc) 
24bf			;       copy to malloc + current pc in line to start of string and add line term 
24bf			;       save on new rsp 
24bf			; 
24bf			 
24bf			; hl to point to the line to tokenise 
24bf			 
24bf			;	push hl 
24bf 22 bf f4			ld (os_tok_ptr), hl  ; save ptr to string 
24c2			 
24c2			;	ld a,0		; string term on input 
24c2			;	call strlent 
24c2			 
24c2			;	ld (os_tok_len), hl	 ; save string length 
24c2			 
24c2			;if DEBUG_FORTH_TOK 
24c2			;	ex de,hl		 
24c2			;endif 
24c2			 
24c2			;	pop hl 		; get back string pointer 
24c2			 
24c2			if DEBUG_FORTH_TOK 
24c2						DMARK "TOc" 
24c2				CALLMONITOR 
24c2			endif 
24c2 7e			.cptoken2:    ld a,(hl) 
24c3 23				inc hl 
24c4 fe 7f			cp FORTH_END_BUFFER 
24c6 28 29			jr z, .cptokendone2 
24c8 fe 00			cp 0 
24ca 28 25			jr z, .cptokendone2 
24cc fe 22			cp '"' 
24ce 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
24d0 fe 20			cp ' ' 
24d2 20 ee			jr nz,  .cptoken2 
24d4			 
24d4			; TODO consume comments held between ( and ) 
24d4			 
24d4				; we have a space so change to zero term for dict match later 
24d4 2b				dec hl 
24d5 3e 00			ld a,0 
24d7 77				ld (hl), a 
24d8 23				inc hl 
24d9 18 e7			jr .cptoken2 
24db				 
24db			 
24db			.cptokenstr2: 
24db				; skip all white space until either eol (because forgot to term) or end double quote 
24db			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
24db				;inc hl ; skip current double quote 
24db 7e				ld a,(hl) 
24dc 23				inc hl 
24dd fe 22			cp '"' 
24df 28 e1			jr z, .cptoken2 
24e1 fe 7f			cp FORTH_END_BUFFER 
24e3 28 0c			jr z, .cptokendone2 
24e5 fe 00			cp 0 
24e7 28 08			jr z, .cptokendone2 
24e9 fe 20			cp ' ' 
24eb 28 02			jr z, .cptmp2 
24ed 18 ec			jr .cptokenstr2 
24ef			 
24ef			.cptmp2:	; we have a space so change to zero term for dict match later 
24ef				;dec hl 
24ef				;ld a,"-"	; TODO remove this when working 
24ef				;ld (hl), a 
24ef				;inc hl 
24ef 18 ea			jr .cptokenstr2 
24f1			 
24f1			.cptokendone2: 
24f1				;inc hl 
24f1 3e 7f			ld a, FORTH_END_BUFFER 
24f3 77				ld (hl),a 
24f4 23				inc hl 
24f5 3e 21			ld a, '!' 
24f7 77				ld (hl),a 
24f8			 
24f8 2a bf f4			ld hl,(os_tok_ptr) 
24fb			         
24fb			if DEBUG_FORTH_TOK 
24fb						DMARK "Tc1" 
24fb				CALLMONITOR 
24fb			endif 
24fb			 
24fb				; push exec string to top of return stack 
24fb				FORTH_RSP_NEXT 
24fb cd ab 20			call macro_forth_rsp_next 
24fe				endm 
# End of macro FORTH_RSP_NEXT
24fe c9				ret 
24ff			 
24ff			; Another go at the parser need to simplify the process 
24ff			 
24ff			forthparse: 
24ff			 
24ff			; 
24ff			; line parse: 
24ff			;       parse raw input buffer 
24ff			;       tokenise the words 
24ff			;       malloc new copy (for looping etc) 
24ff			;       copy to malloc + current pc in line to start of string and add line term 
24ff			;       save on new rsp 
24ff			; 
24ff			 
24ff			; hl to point to the line to tokenise 
24ff			 
24ff			;	push hl 
24ff 22 bf f4			ld (os_tok_ptr), hl  ; save ptr to string 
2502			 
2502			;	ld a,0		; string term on input 
2502			;	call strlent 
2502			 
2502			;	ld (os_tok_len), hl	 ; save string length 
2502			 
2502			;if DEBUG_FORTH_TOK 
2502			;	ex de,hl		 
2502			;endif 
2502			 
2502			;	pop hl 		; get back string pointer 
2502			 
2502			if DEBUG_FORTH_TOK 
2502						DMARK "TOK" 
2502				CALLMONITOR 
2502			endif 
2502 7e			.ptoken2:    ld a,(hl) 
2503 23				inc hl 
2504 fe 7f			cp FORTH_END_BUFFER 
2506 28 29			jr z, .ptokendone2 
2508 fe 00			cp 0 
250a 28 25			jr z, .ptokendone2 
250c fe 22			cp '"' 
250e 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
2510 fe 20			cp ' ' 
2512 20 ee			jr nz,  .ptoken2 
2514			 
2514			; TODO consume comments held between ( and ) 
2514			 
2514				; we have a space so change to zero term for dict match later 
2514 2b				dec hl 
2515 3e 00			ld a,0 
2517 77				ld (hl), a 
2518 23				inc hl 
2519 18 e7			jr .ptoken2 
251b				 
251b			 
251b			.ptokenstr2: 
251b				; skip all white space until either eol (because forgot to term) or end double quote 
251b			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
251b				;inc hl ; skip current double quote 
251b 7e				ld a,(hl) 
251c 23				inc hl 
251d fe 22			cp '"' 
251f 28 e1			jr z, .ptoken2 
2521 fe 7f			cp FORTH_END_BUFFER 
2523 28 0c			jr z, .ptokendone2 
2525 fe 00			cp 0 
2527 28 08			jr z, .ptokendone2 
2529 fe 20			cp ' ' 
252b 28 02			jr z, .ptmp2 
252d 18 ec			jr .ptokenstr2 
252f			 
252f			.ptmp2:	; we have a space so change to zero term for dict match later 
252f				;dec hl 
252f				;ld a,"-"	; TODO remove this when working 
252f				;ld (hl), a 
252f				;inc hl 
252f 18 ea			jr .ptokenstr2 
2531			 
2531			.ptokendone2: 
2531				;inc hl 
2531 3e 7f			ld a, FORTH_END_BUFFER 
2533 77				ld (hl),a 
2534 23				inc hl 
2535 3e 21			ld a, '!' 
2537 77				ld (hl),a 
2538			 
2538 2a bf f4			ld hl,(os_tok_ptr) 
253b			         
253b			if DEBUG_FORTH_TOK 
253b						DMARK "TK1" 
253b				CALLMONITOR 
253b			endif 
253b			 
253b				; push exec string to top of return stack 
253b				FORTH_RSP_NEXT 
253b cd ab 20			call macro_forth_rsp_next 
253e				endm 
# End of macro FORTH_RSP_NEXT
253e c9				ret 
253f			 
253f			; 
253f			;	; malloc size + buffer pointer + if is loop flag 
253f			;	ld hl,(os_tok_len) 		 ; get string length 
253f			; 
253f			;	ld a,l 
253f			; 
253f			;	cp 0			; we dont want to use a null string 
253f			;	ret z 
253f			; 
253f			;;	add 3    ; prefix malloc with buffer for current word ptr 
253f			; 
253f			;	add 5     ; TODO when certain not over writing memory remove 
253f			; 
253f			;		 
253f			; 
253f			;if DEBUG_FORTH_TOK 
253f			;			DMARK "TKE" 
253f			;	CALLMONITOR 
253f			;endif 
253f			; 
253f			;	ld l,a 
253f			;	ld h,0 
253f			;;	push hl   ; save required space for the copy later 
253f			;	call malloc 
253f			;if DEBUG_FORTH_TOK 
253f			;			DMARK "TKM" 
253f			;	CALLMONITOR 
253f			;endif 
253f			;	if DEBUG_FORTH_MALLOC_GUARD 
253f			;		push af 
253f			;		call ishlzero 
253f			;;		ld a, l 
253f			;;		add h 
253f			;;		cp 0 
253f			;		pop af 
253f			;		 
253f			;		call z,malloc_error 
253f			;	endif 
253f			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
253f			; 
253f			; 
253f			;if DEBUG_FORTH_TOK 
253f			;			DMARK "TKR" 
253f			;	CALLMONITOR 
253f			;endif 
253f			; 
253f			;	FORTH_RSP_NEXT 
253f			; 
253f			;	;inc hl	 ; go past current buffer pointer 
253f			;	;inc hl 
253f			;	;inc hl   ; and past if loop flag 
253f			;		; TODO Need to set flag  
253f			; 
253f			;	 
253f			;	 
253f			;	ex de,hl	; malloc is dest 
253f			;	ld hl, (os_tok_len) 
253f			;;	pop bc 
253f			;	ld c, l                
253f			;	ld b,0 
253f			;	ld hl, (os_tok_ptr) 
253f			; 
253f			;if DEBUG_FORTH_TOK 
253f			;			DMARK "TKT" 
253f			;	CALLMONITOR 
253f			;endif 
253f			; 
253f			;	; do str cpy 
253f			; 
253f			;	ldir      ; copy byte in hl to de 
253f			; 
253f			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
253f			; 
253f			;if DEBUG_FORTH_TOK 
253f			; 
253f			;			DMARK "TKY" 
253f			;	CALLMONITOR 
253f			;endif 
253f			;	;ld a,0 
253f			;	;ld a,FORTH_END_BUFFER 
253f			;	ex de, hl 
253f			;	;dec hl			 ; go back over the space delim at the end of word 
253f			;	;ld (hl),a 
253f			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
253f			;	ld a,FORTH_END_BUFFER 
253f			;	ld (hl),a 
253f			;	inc hl 
253f			;	ld a,FORTH_END_BUFFER 
253f			;	ld (hl),a 
253f			; 
253f			;	; init the malloc area data 
253f			;	; set pc for in current area 
253f			;	;ld hl, (os_tok_malloc) 
253f			;	;inc hl 
253f			;	;inc hl 
253f			;	;inc hl 
253f			;	;ex de,hl 
253f			;	;ld hl, (os_tok_malloc) 
253f			;	;ld (hl),e 
253f			;	;inc hl 
253f			;	;ld (hl),d 
253f			; 
253f			; 
253f			;	ld hl,(os_tok_malloc) 
253f			;if DEBUG_FORTH_PARSE_KEY 
253f			;			DMARK "TKU" 
253f			;	CALLMONITOR 
253f			;endif 
253f			; 
253f			;	ret 
253f			 
253f			forthexec: 
253f			 
253f			; line exec: 
253f			; forth parser 
253f			 
253f			; 
253f			;       get current exec line on rsp 
253f			 
253f				FORTH_RSP_TOS 
253f cd c2 20			call macro_forth_rsp_tos 
2542				endm 
# End of macro FORTH_RSP_TOS
2542			 
2542			;       restore current pc - hl points to malloc of data 
2542			 
2542				;ld e, (hl) 
2542				;inc hl 
2542				;ld d, (hl) 
2542				;ex de,hl 
2542			 
2542			 
2542			exec1: 
2542 22 bf f4			ld (os_tok_ptr), hl 
2545			 
2545				; copy our PC to working vars  
2545 22 3d fa			ld (cli_ptr), hl 
2548 22 3b fa			ld (cli_origptr), hl 
254b			 
254b 7e				ld a,(hl) 
254c fe 7f			cp FORTH_END_BUFFER 
254e c8				ret z 
254f			 
254f				; skip any nulls 
254f			 
254f fe 00			cp 0 
2551 20 03			jr nz, .execword 
2553 23				inc hl 
2554 18 ec			jr exec1 
2556			 
2556			 
2556			.execword: 
2556			 
2556			 
2556			 
2556			if DEBUG_FORTH_PARSE_KEY 
2556						DMARK "KYQ" 
2556				CALLMONITOR 
2556			endif 
2556			;       while at start of word: 
2556			; get start of dict (in user area first) 
2556			 
2556 21 00 80		ld hl, baseram 
2559			;ld hl, sysdict 
2559 22 3f fa		ld (cli_nextword),hl 
255c			;           match word at pc 
255c			;           exec word 
255c			;           or push to dsp 
255c			;           forward to next token 
255c			;           if line term pop rsp and exit 
255c			;        
255c			 
255c			if DEBUG_FORTH_PARSE_KEY 
255c						DMARK "KYq" 
255c				CALLMONITOR 
255c			endif 
255c			 
255c			; 
255c			; word comp 
255c			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
255c			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
255c			;    move to start of word  
255c			;    compare word to cli_token 
255c			 
255c			.execpnword:	; HL at start of a word in the dictionary to check 
255c			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
255c			;	ld (cli_ptr), hl 
255c			 
255c 2a 3f fa			ld hl,(cli_nextword) 
255f			 
255f cd 02 26			call forth_tok_next 
2562			; tok next start here 
2562			;	; TODO skip compiled symbol for now 
2562			;	inc hl 
2562			; 
2562			;	; save pointer to next word 
2562			; 
2562			;	; hl now points to the address of the next word pointer  
2562			;	ld e, (hl) 
2562			;	inc hl 
2562			;	ld d, (hl) 
2562			;	inc l 
2562			; 
2562			;	ex de,hl 
2562			;if DEBUG_FORTH_PARSE_NEXTWORD 
2562			;	push bc 
2562			;	ld bc, (cli_nextword) 
2562			;			DMARK "NXW" 
2562			;	CALLMONITOR 
2562			;	pop bc 
2562			;endif 
2562			; tok next end here 
2562 22 3f fa			ld (cli_nextword), hl     ; save for next check if no match on this word 
2565 eb				ex de, hl 
2566			 
2566			 
2566				; save the pointer of the current token - 1 to check against 
2566				 
2566 22 43 fa			ld (cli_token), hl   
2569				; TODO maybe remove below save if no debug 
2569				; save token string ptr for any debug later 
2569 23				inc hl  
256a 22 45 fa			ld (cli_origtoken), hl 
256d 2b				dec hl 
256e				; save pointer to the start of the next dictionay word 
256e 7e				ld a,(hl)   ; get string length 
256f 47				ld b,a 
2570			.execpnwordinc:  
2570 23				inc hl 
2571 10 fd			djnz .execpnwordinc 
2573 22 41 fa			ld (cli_execword), hl      ; save start of this words code 
2576			 
2576				; now check the word token against the string being parsed 
2576			 
2576 2a 43 fa			ld hl,(cli_token) 
2579 23				inc hl     ; skip string length (use zero term instead to end) 
257a 22 43 fa			ld (cli_token), hl 
257d			 
257d			if DEBUG_FORTH_PARSE_KEY 
257d						DMARK "KY2" 
257d			endif 
257d			if DEBUG_FORTH_PARSE_EXEC 
257d				; see if disabled 
257d			 
257d			;	ld a, (os_view_disable) 
257d			;	cp '*' 
257d				ld a, (debug_vector) 
257d				cp $c9   ; RET  
257d				jr z, .skip 
257d			 
257d				push hl 
257d				push hl 
257d				call clear_display 
257d				ld de, .compword 
257d				ld a, display_row_1 
257d				call str_at_display 
257d				pop de 
257d				ld a, display_row_2 
257d				call str_at_display 
257d				ld hl,(cli_ptr) 
257d				ld a,(hl) 
257d			        ld hl, os_word_scratch 
257d				ld (hl),a 
257d				ld a,0 
257d				inc hl 
257d				ld (hl),a 	 
257d				ld de, os_word_scratch 
257d				ld a, display_row_2+10 
257d				call str_at_display 
257d				call update_display 
257d				ld a, 100 
257d				call aDelayInMS 
257d				if DEBUG_FORTH_PARSE_EXEC_SLOW 
257d				call delay250ms 
257d				endif 
257d				pop hl 
257d			.skip:  
257d			endif	 
257d			.execpnchar:    ; compare char between token and string to parse 
257d			 
257d			if DEBUG_FORTH_PARSE_KEY 
257d						DMARK "Ky3" 
257d			endif 
257d			if DEBUG_FORTH_PARSE_EXEC 
257d				; see if disabled 
257d			 
257d			;	ld a, (os_view_disable) 
257d			;	cp '*' 
257d				ld a, (debug_vector) 
257d				cp $C9  ; RET 
257d				jr z, .skip2 
257d			 
257d			;	call clear_display 
257d			ld hl,(cli_token) 
257d			ld a,(hl) 
257d			ld (os_word_scratch),a 
257d				ld hl,(cli_ptr) 
257d			ld a,(hl) 
257d				ld (os_word_scratch+1),a 
257d				ld a,0 
257d				ld (os_word_scratch+2),a 
257d				ld de,os_word_scratch 
257d				ld a,display_row_4 
257d				call str_at_display 
257d				call update_display 
257d			.skip2:  
257d			endif 
257d 2a 43 fa			ld hl,(cli_token) 
2580 7e				ld a, (hl)	 ; char in word token 
2581 23				inc hl 		; move to next char 
2582 22 43 fa			ld (cli_token), hl ; and save it 
2585 47				ld b,a 
2586			 
2586 2a 3d fa			ld hl,(cli_ptr) ;	get the char from the string to parse 
2589 7e				ld a,(hl) 
258a 23				inc hl 
258b 22 3d fa			ld (cli_ptr), hl		; move to next char 
258e cd 25 14			call toUpper 		; make sure the input string matches case 
2591			 
2591			if DEBUG_FORTH_PARSE 
2591			endif 
2591			 
2591				; input stream end of token is a space so get rid of it 
2591			 
2591			;	cp ' ' 
2591			;	jr nz, .pnskipspace 
2591			; 
2591			;	ld a, 0		; make same term as word token term 
2591			; 
2591			;.pnskipspace: 
2591			 
2591			if DEBUG_FORTH_PARSE_KEY 
2591						DMARK "KY7" 
2591			endif 
2591 b8				cp b 
2592 c2 a8 25			jp nz, .execpnskipword	 ; no match so move to next word 
2595				 
2595			;    if same 
2595			;       scan for string terms 0 for token and 32 for input 
2595			 
2595				 
2595			if DEBUG_FORTH_PARSE_KEY 
2595						DMARK "KY8" 
2595			endif 
2595			 
2595 80				add b			 
2596 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
2598							; TODO need to make sure last word in zero term string is accounted for 
2598 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
259a			 
259a			 
259a				; at end of both strings so both are exact match 
259a			 
259a			;       skip ptr for next word 
259a			 
259a 2a 3d fa			ld hl,(cli_ptr) 	; at input string term 
259d 23				inc hl			 ; at next char 
259e 22 3d fa			ld (cli_ptr), hl     ; save for next round of the parser 
25a1 22 3b fa			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
25a4				 
25a4				 
25a4			if DEBUG_FORTH_PARSE_KEY 
25a4						DMARK "KY3" 
25a4			endif 
25a4			 
25a4			 
25a4			 
25a4			;       exec code block 
25a4			if DEBUG_FORTH_JP 
25a4				call clear_display 
25a4				call update_display 
25a4				call delay1s 
25a4				ld hl, (cli_execword)     ; save for next check if no match on this word 
25a4				ld a,h 
25a4				ld hl, os_word_scratch 
25a4				call hexout 
25a4				ld hl, (cli_execword)     ; save for next check if no match on this word 
25a4				ld a,l 
25a4				ld hl, os_word_scratch+2 
25a4				call hexout 
25a4				ld hl, os_word_scratch+4 
25a4				ld a,0 
25a4				ld (hl),a 
25a4				ld de,os_word_scratch 
25a4				call str_at_display 
25a4					ld a, display_row_2 
25a4					call str_at_display 
25a4				ld de, (cli_origtoken) 
25a4				ld a, display_row_1+10 
25a4					call str_at_display 
25a4			 
25a4				ld a,display_row_1 
25a4				ld de, .foundword 
25a4				ld a, display_row_3 
25a4				call str_at_display 
25a4				call update_display 
25a4				call delay1s 
25a4				call delay1s 
25a4				call delay1s 
25a4			endif 
25a4			 
25a4			if DEBUG_FORTH_PARSE_KEY 
25a4						DMARK "KYj" 
25a4			endif 
25a4				; TODO save the word pointer in this exec 
25a4			 
25a4 2a 41 fa			ld hl,(cli_execword) 
25a7 e9				jp (hl) 
25a8			 
25a8			 
25a8			;    if not same 
25a8			;	scan for zero term 
25a8			;	get ptr for next word 
25a8			;	goto word comp 
25a8			 
25a8			.execpnskipword:	; get pointer to next word 
25a8 2a 3f fa			ld hl,(cli_nextword) 
25ab			 
25ab 7e				ld a,(hl) 
25ac fe 00			cp WORD_SYS_END 
25ae			;	cp 0 
25ae 28 09			jr z, .execendofdict			 ; at end of words 
25b0			 
25b0			if DEBUG_FORTH_PARSE_KEY 
25b0						DMARK "KY4" 
25b0			endif 
25b0			if DEBUG_FORTH_PARSE_EXEC 
25b0			 
25b0				; see if disabled 
25b0			 
25b0			;	ld a, (os_view_disable) 
25b0			;	cp '*' 
25b0				ld a,(debug_vector) 
25b0				cp $c9   ; RET 
25b0				jr z, .noskip 
25b0			 
25b0			 
25b0				ld de, .nowordfound 
25b0				ld a, display_row_3 
25b0				call str_at_display 
25b0				call update_display 
25b0				ld a, 100 
25b0				call aDelayInMS 
25b0				 
25b0				if DEBUG_FORTH_PARSE_EXEC_SLOW 
25b0					call delay250ms 
25b0				endif 
25b0			.noskip:  
25b0			 
25b0			endif	 
25b0			 
25b0 2a 3b fa			ld hl,(cli_origptr) 
25b3 22 3d fa			ld (cli_ptr),hl 
25b6			 
25b6			if DEBUG_FORTH_PARSE_KEY 
25b6						DMARK "KY5" 
25b6			endif 
25b6 c3 5c 25			jp .execpnword			; else go to next word 
25b9			 
25b9			.execendofdict:  
25b9			 
25b9			if DEBUG_FORTH_PARSE_KEY 
25b9						DMARK "KYe" 
25b9			endif 
25b9			if DEBUG_FORTH_PARSE_EXEC 
25b9				; see if disabled 
25b9			 
25b9			;	ld a, (os_view_disable) 
25b9			;	cp '*' 
25b9				ld a,(debug_vector) 
25b9				cp $c9   ; ret 
25b9				jr z, .ispskip 
25b9			 
25b9				call clear_display 
25b9				call update_display 
25b9				call delay1s 
25b9				ld de, (cli_origptr) 
25b9				ld a, display_row_1 
25b9				call str_at_display 
25b9				 
25b9				ld de, .enddict 
25b9				ld a, display_row_3 
25b9				call str_at_display 
25b9				call update_display 
25b9				ld a, 100 
25b9				call aDelayInMS 
25b9				if DEBUG_FORTH_PARSE_EXEC_SLOW 
25b9				call delay1s 
25b9				call delay1s 
25b9				call delay1s 
25b9				endif 
25b9			.ispskip:  
25b9				 
25b9			endif	 
25b9			 
25b9			 
25b9			 
25b9				; if the word is not a keyword then must be a literal so push it to stack 
25b9			 
25b9			; push token to stack to end of word 
25b9			 
25b9				STACKFRAME ON $1efe $2f9f 
25b9				if DEBUG_STACK_IMB 
25b9					if ON 
25b9						exx 
25b9						ld de, $1efe 
25b9						ld a, d 
25b9						ld hl, curframe 
25b9						call hexout 
25b9						ld a, e 
25b9						ld hl, curframe+2 
25b9						call hexout 
25b9						ld hl, $1efe 
25b9						push hl 
25b9						ld hl, $2f9f 
25b9						push hl 
25b9						exx 
25b9					endif 
25b9				endif 
25b9			endm 
# End of macro STACKFRAME
25b9			 
25b9 2a bf f4		ld hl,(os_tok_ptr) 
25bc cd 6d 22		call forth_apush 
25bf			 
25bf				STACKFRAMECHK ON $1efe $2f9f 
25bf				if DEBUG_STACK_IMB 
25bf					if ON 
25bf						exx 
25bf						ld hl, $2f9f 
25bf						pop de   ; $2f9f 
25bf						call cmp16 
25bf						jr nz, .spnosame 
25bf						ld hl, $1efe 
25bf						pop de   ; $1efe 
25bf						call cmp16 
25bf						jr z, .spfrsame 
25bf						.spnosame: call showsperror 
25bf						.spfrsame: nop 
25bf						exx 
25bf					endif 
25bf				endif 
25bf			endm 
# End of macro STACKFRAMECHK
25bf			 
25bf			execnext: 
25bf			 
25bf			if DEBUG_FORTH_PARSE_KEY 
25bf						DMARK "KY>" 
25bf			endif 
25bf			; move past token to next word 
25bf			 
25bf 2a bf f4		ld hl, (os_tok_ptr) 
25c2 3e 00		ld a, 0 
25c4 01 ff 00		ld bc, 255     ; input buffer size 
25c7 ed b1		cpir 
25c9			 
25c9			if DEBUG_FORTH_PARSE_KEY 
25c9						DMARK "KY!" 
25c9				CALLMONITOR 
25c9			endif	 
25c9			; TODO this might place hl on the null, so will need to forward on??? 
25c9			;inc hl   ; see if this gets onto the next item 
25c9			 
25c9			 
25c9			; TODO pass a pointer to the buffer to push 
25c9			; TODO call function to push 
25c9			 
25c9			; look for end of input 
25c9			 
25c9			;inc hl 
25c9			;ld a,(hl) 
25c9			;cp FORTH_END_BUFFER 
25c9			;ret z 
25c9			 
25c9			 
25c9 c3 42 25		jp exec1 
25cc			 
25cc			 
25cc			 
25cc			 
25cc			 
25cc			 
25cc			 
25cc			 
25cc			 
25cc			findnexttok: 
25cc			 
25cc				; hl is pointer to move 
25cc				; de is the token to locate 
25cc			 
25cc					if DEBUG_FORTH 
25cc						DMARK "NTK" 
25cc						CALLMONITOR 
25cc					endif 
25cc d5				push de 
25cd			 
25cd			.fnt1:	 
25cd				; find first char of token to locate 
25cd			 
25cd 1a				ld a, (de) 
25ce 4f				ld c,a 
25cf 7e				ld a,(hl) 
25d0 cd 25 14			call toUpper 
25d3					if DEBUG_FORTH 
25d3						DMARK "NT1" 
25d3						CALLMONITOR 
25d3					endif 
25d3 b9				cp c 
25d4			 
25d4 28 03			jr z, .fnt2cmpmorefirst	 
25d6			 
25d6				; first char not found move to next char 
25d6			 
25d6 23				inc hl 
25d7 18 f4			jr .fnt1 
25d9			 
25d9			.fnt2cmpmorefirst:	 
25d9				; first char of token found.  
25d9			 
25d9 e5				push hl     ; save start of token just in case it is the right one 
25da d9				exx 
25db e1				pop hl        ; save it to hl' 
25dc d9				exx 
25dd			 
25dd			 
25dd			.fnt2cmpmore:	 
25dd				; compare the rest 
25dd				 
25dd 23				inc hl 
25de 13				inc de 
25df				 
25df 1a				ld a, (de) 
25e0 4f				ld c,a 
25e1 7e				ld a,(hl) 
25e2 cd 25 14			call toUpper 
25e5			 
25e5					if DEBUG_FORTH 
25e5						DMARK "NT2" 
25e5						CALLMONITOR 
25e5					endif 
25e5				; c has the token to find char 
25e5				; a has the mem to scan char 
25e5			 
25e5 b9				cp c 
25e6 28 04			jr z,.fntmatch1 
25e8			 
25e8				; they are not the same 
25e8			 
25e8					if DEBUG_FORTH 
25e8						DMARK "NT3" 
25e8						CALLMONITOR 
25e8					endif 
25e8 d1				pop de	; reset de token to look for 
25e9 d5				push de 
25ea 18 e1			jr .fnt1 
25ec				 
25ec			.fntmatch1: 
25ec			 
25ec				; is the same char a null which means we might have a full hit? 
25ec					if DEBUG_FORTH 
25ec						DMARK "NT4" 
25ec						CALLMONITOR 
25ec					endif 
25ec			 
25ec fe 00			cp 0 
25ee 28 0b			jr z, .fntmatchyes 
25f0			 
25f0				; are we at the end of the token to find? 
25f0			 
25f0					if DEBUG_FORTH 
25f0						DMARK "NT5" 
25f0						CALLMONITOR 
25f0					endif 
25f0 3e 00			ld a, 0 
25f2 b9				cp c 
25f3			 
25f3 c2 dd 25			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
25f6			 
25f6					if DEBUG_FORTH 
25f6						DMARK "NT6" 
25f6						CALLMONITOR 
25f6					endif 
25f6				; token to find is exhusted but no match to stream 
25f6			 
25f6				; restore tok pointer and continue on 
25f6 d1				pop de 
25f7 d5				push de 
25f8 c3 cd 25			jp .fnt1 
25fb			 
25fb			 
25fb			.fntmatchyes: 
25fb			 
25fb				; hl now contains the end of the found token 
25fb			 
25fb				; get rid of saved token pointer to find 
25fb			 
25fb d1				pop de 
25fc			 
25fc					if DEBUG_FORTH 
25fc						DMARK "NT9" 
25fc						CALLMONITOR 
25fc					endif 
25fc			 
25fc				; hl will be on the null term so forward on 
25fc			 
25fc				; get back the saved start of the token 
25fc			 
25fc d9				exx 
25fd e5				push hl     ; save start of token just in case it is the right one 
25fe d9				exx 
25ff e1				pop hl        ; save it to hl 
2600			 
2600 c9				ret 
2601			 
2601			 
2601			; LIST needs to find a specific token   
2601			; FORGET needs to find a spefici token 
2601			 
2601			; SAVE needs to find all tokens by flag 
2601			; WORDS just needs to scan through all  by flag 
2601			; UWORDS needs to scan through all by flag 
2601			 
2601			 
2601			; given hl as pointer to start of dict look up string 
2601			; return hl as pointer to start of word block 
2601			; or 0 if not found 
2601			 
2601			forth_find_tok: 
2601 c9				ret 
2602			 
2602			; given hl as pointer to dict structure 
2602			; move to the next dict block structure 
2602			 
2602			forth_tok_next: 
2602				; hl now points to the address of the next word pointer  
2602				; TODO skip compiled symbol for now 
2602			;	push de 
2602 23				inc hl 
2603 5e				ld e, (hl) 
2604 23				inc hl 
2605 56				ld d, (hl) 
2606 23				inc hl 
2607			 
2607 eb				ex de,hl 
2608			if DEBUG_FORTH_PARSE_NEXTWORD 
2608				push bc 
2608				ld bc, (cli_nextword) 
2608						DMARK "NXW" 
2608				CALLMONITOR 
2608				pop bc 
2608			endif 
2608			;	pop de	 
2608 c9				ret 
2609			 
2609			 
2609			 
2609			; eof 
# End of file forth_parserv5.asm
2609				include "forth_wordsv4.asm" 
2609			 
2609			; the core word dictionary v4 
2609			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
2609			 
2609			; this is a linked list for each of the system words used 
2609			; user defined words will follow the same format but will be in ram 
2609			 
2609			 
2609			; 
2609			; 
2609			; define linked list: 
2609			; 
2609			; 1. compiled byte op code 
2609			; 2. len of text word 
2609			; 3. text word 
2609			; 4. ptr to next dictionary word 
2609			; 5. asm, calls etc for the word 
2609			; 
2609			;  if 1 == 0 then last word in dict  
2609			;   
2609			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
2609			;  
2609			;  
2609			; create basic standard set of words 
2609			; 
2609			;  
2609			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
2609			; 2DUP 2DROP 2SWAP  
2609			; @ C@ - get byte  
2609			; ! C! - store byte 
2609			; 0< true if less than zero 
2609			; 0= true if zero 
2609			; < >  
2609			; = true if same 
2609			; variables 
2609			 
2609			 
2609			; Hardware specific words I may need 
2609			; 
2609			; IN OUT  
2609			; calls to key util functions 
2609			; calls to hardward abstraction stuff 
2609			; easy control of frame buffers and lcd i/o 
2609			; keyboard  
2609			 
2609			 
2609			;DICT: macro 
2609			; op_code, len, word, next 
2609			;    word: 
2609			;    db op_code 
2609			;    ds word zero term 
2609			;    dw next 
2609			;    endm 
2609			 
2609			 
2609			 
2609			 
2609			; op code 1 is a flag for user define words which are to be handled differently 
2609			 
2609			 
2609			; 
2609			; 
2609			;    TODO on entry to a word this should be the expected environment 
2609			;    hl - tos value if number then held, if string this is the ptr 
2609			;    de -  
2609			 
2609			 
2609			; opcode ranges 
2609			; 0 - end of word dict 
2609			; 255 - user define words 
2609			 
2609			sysdict: 
2609			include "forth_opcodes.asm" 
2609			; op codes for forth keywords 
2609			; free to use code 0  
2609				OPCODE_HEAP: equ  1 
2609				OPCODE_EXEC: equ 2 
2609				OPCODE_DUP: equ 3 
2609				OPCODE_SWAP: equ 4 
2609				OPCODE_COLN: equ 5 
2609				OPCODE_SCOLN: equ 6 
2609				OPCODE_DROP: equ 7 
2609				OPCODE_DUP2: equ 8 
2609				OPCODE_DROP2: equ 9 
2609				OPCODE_SWAP2: equ 10 
2609				OPCODE_AT: equ 11 
2609				OPCODE_CAT: equ 12 
2609				OPCODE_BANG: equ 13 
2609				OPCODE_CBANG: equ 14 
2609				OPCODE_SCALL: equ 15 
2609				OPCODE_DEPTH: equ 16 
2609				OPCODE_OVER: equ 17 
2609				OPCODE_PAUSE: equ 18 
2609				OPCODE_PAUSES: equ 19 
2609				OPCODE_ROT: equ 20 
2609			;free to reuse	OPCODE_WORDS: equ 21 
2609			        OPCODE_NOT: equ 21 
2609				OPCODE_UWORDS: equ 22 
2609				OPCODE_BP: equ 23 
2609				OPCODE_MONITOR: equ 24  
2609				OPCODE_MALLOC: equ 25 
2609				OPCODE_FREE: equ 26 
2609				OPCODE_LIST: equ 27 
2609				OPCODE_FORGET: equ 28 
2609				OPCODE_NOP: equ 29 
2609				OPCODE_COMO: equ 30 
2609				OPCODE_COMC: equ 31 
2609			;free to reuse	OPCODE_ENDCORE: equ 32 
2609				OPCODE_AFTERSOUND: equ 33 
2609				OPCODE_GP2: equ 34 
2609				OPCODE_GP3: equ 35 
2609				OPCODE_GP4: equ 36 
2609				OPCODE_SIN: equ 37 
2609				OPCODE_SOUT: equ 38 
2609				OPCODE_SPIO: equ 39 
2609				OPCODE_SPICEH: equ 40 
2609				OPCODE_SPIOb: equ 41 
2609				OPCODE_SPII: equ 42 
2609				OPCODE_SESEL: equ 43 
2609				OPCODE_CARTDEV: equ 44 
2609			; free to reuse	OPCODE_ENDDEVICE: equ 45 
2609				OPCODE_FB: equ 46 
2609				OPCODE_EMIT: equ 47 
2609				OPCODE_DOTH: equ 48 
2609				OPCODE_DOTF: equ 49 
2609				OPCODE_DOT: equ 50 
2609				OPCODE_CLS: equ 51 
2609				OPCODE_DRAW: equ 52 
2609				OPCODE_DUMP: equ 53 
2609				OPCODE_CDUMP: equ 54 
2609				OPCODE_DAT: equ 55 
2609				OPCODE_HOME: equ 56 
2609				OPCODE_SPACE: equ 57 
2609				OPCODE_SPACES: equ 58 
2609				OPCODE_SCROLL: equ 59 
2609				OPCODE_ATQ: equ 60 
2609				OPCODE_AUTODSP: equ 61 
2609				OPCODE_MENU: equ 62 
2609			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
2609				OPCODE_THEN: equ 64 
2609				OPCODE_ELSE: equ 65 
2609				OPCODE_DO: equ 66 
2609				OPCODE_LOOP: equ 67 
2609				OPCODE_I: equ 68 
2609				OPCODE_DLOOP: equ 69  
2609				OPCODE_REPEAT: equ 70  
2609				OPCODE_UNTIL: equ 71 
2609				OPCODE_ENDFLOW: equ 72 
2609				OPCODE_WAITK: equ 73 
2609				OPCODE_ACCEPT: equ 74 
2609				OPCODE_EDIT: equ 75 
2609			;free to reuse	OPCODE_ENDKEY: equ 76 
2609				OPCODE_LZERO: equ 77 
2609				OPCODE_TZERO: equ 78 
2609				OPCODE_LESS: equ 79 
2609				OPCODE_GT: equ 80 
2609				OPCODE_EQUAL: equ 81  
2609			;free to reuse	OPCODE_ENDLOGIC: equ 82 
2609				OPCODE_NEG: equ 83 
2609				OPCODE_DIV: equ 84 
2609				OPCODE_MUL: equ 85 
2609				OPCODE_MIN: equ 86 
2609				OPCODE_MAX: equ 87 
2609				OPCODE_RND16: equ 88 
2609				OPCODE_RND8: equ 89 
2609				OPCODE_RND: equ 90 
2609			;free to reuse	OPCODE_ENDMATHS: equ 91  
2609				OPCODE_BYNAME: equ 92 
2609				OPCODE_DIR: equ 93 
2609				OPCODE_SAVE: equ 94 
2609				OPCODE_LOAD: equ 95 
2609				OPCODE_BSAVE: equ 96 
2609				OPCODE_BLOAD: equ 97 
2609				OPCODE_SEO: equ 98  
2609				OPCODE_SEI: equ 99 
2609				OPCODE_SFREE: equ 100 
2609				OPCODE_SIZE: equ 101 
2609				OPCODE_CREATE: equ 102 
2609				OPCODE_APPEND: equ 103 
2609				OPCODE_SDEL: equ 104 
2609				OPCODE_OPEN: equ 105 
2609				OPCODE_READ: equ 106 
2609				OPCODE_EOF: equ 106 
2609				OPCODE_FORMAT: equ 107 
2609				OPCODE_LABEL: equ 108 
2609				OPCODE_LABELS: equ 109 
2609			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
2609				OPCODE_UPPER: equ 111 
2609				OPCODE_LOWER: equ 112 
2609				OPCODE_SUBSTR: equ 113 
2609				OPCODE_LEFT: equ 114 
2609				OPCODE_RIGHT: equ 115 
2609				OPCODE_STR2NUM: equ 116 
2609				OPCODE_NUM2STR: equ 117 
2609				OPCODE_CONCAT: equ 118 
2609				OPCODE_FIND: equ 119 
2609				OPCODE_LEN: equ 120 
2609				OPCODE_CHAR: equ 121 
2609			; free to reuse	OPCODE_STRLEN: equ 122 
2609			; free to reuse	OPCODE_ENDSTR: equ 123 
2609				OPCODE_V0S: equ 124 
2609				OPCODE_V0Q: equ 125 
2609				OPCODE_V1S: equ 126 
2609				OPCODE_V1Q: equ 127 
2609				OPCODE_V2S: equ 128 
2609				OPCODE_V2Q: equ 129 
2609				OPCODE_V3S: equ 130 
2609				OPCODE_V3Q: equ 131 
2609			;free to reuse	OPCODE_END: equ 132 
2609				OPCODE_ZDUP: equ 133 
2609			 
2609			; eof 
# End of file forth_opcodes.asm
2609			 
2609			include "forth_words_core.asm" 
2609			 
2609			; | ## Core Words 
2609			 
2609			;if MALLOC_4 
2609			 
2609			.HEAP: 
2609				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
2609 15				db WORD_SYS_CORE+OPCODE_HEAP             
260a 48 26			dw .EXEC            
260c 05				db 4 + 1 
260d .. 00			db "HEAP",0              
2612				endm 
# End of macro CWHEAD
2612			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
2612			; | | u1 - Current number of bytes in the heap 
2612			; | | u2 - Remaining bytes left on the heap 
2612			; | |  
2612			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
2612			 
2612			 
2612					if DEBUG_FORTH_WORDS_KEY 
2612						DMARK "HEP" 
2612 f5				push af  
2613 3a 27 26			ld a, (.dmark)  
2616 32 68 fe			ld (debug_mark),a  
2619 3a 28 26			ld a, (.dmark+1)  
261c 32 69 fe			ld (debug_mark+1),a  
261f 3a 29 26			ld a, (.dmark+2)  
2622 32 6a fe			ld (debug_mark+2),a  
2625 18 03			jr .pastdmark  
2627 ..			.dmark: db "HEP"  
262a f1			.pastdmark: pop af  
262b			endm  
# End of macro DMARK
262b						CALLMONITOR 
262b cd 6c fe			call debug_vector  
262e				endm  
# End of macro CALLMONITOR
262e					endif 
262e 2a 0a 80				ld hl, (free_list )      
2631 11 0e 80				ld de, heap_start 
2634			 
2634 ed 52				sbc hl, de  
2636			 
2636 cd 04 21				call forth_push_numhl 
2639			 
2639			 
2639 ed 5b 0a 80			ld de, (free_list )      
263d 21 a5 f1				ld hl, heap_end 
2640			 
2640 ed 52				sbc hl, de 
2642			 
2642 cd 04 21				call forth_push_numhl 
2645					 
2645			 
2645					 
2645			 
2645			 
2645			 
2645					NEXTW 
2645 c3 b1 24			jp macro_next 
2648				endm 
# End of macro NEXTW
2648			;endif 
2648			 
2648			.EXEC: 
2648			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
2648			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
2648			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
2648			;; > > 
2648			;; > >   
2648			;	STACKFRAME OFF $5efe $5f9f 
2648			; 
2648			;		if DEBUG_FORTH_WORDS_KEY 
2648			;			DMARK "EXE" 
2648			;			CALLMONITOR 
2648			;		endif 
2648			; 
2648			;	FORTH_DSP_VALUEHL 
2648			; 
2648			;	FORTH_DSP_POP 
2648			; 
2648			;		if DEBUG_FORTH_WORDS 
2648			;			DMARK "EX1" 
2648			;			CALLMONITOR 
2648			;		endif 
2648			;;	ld e,(hl) 
2648			;;	inc hl 
2648			;;	ld d,(hl) 
2648			;;	ex de,hl 
2648			; 
2648			;;		if DEBUG_FORTH_WORDS 
2648			;;			DMARK "EX2" 
2648			;;			CALLMONITOR 
2648			;;		endif 
2648			;	push hl 
2648			; 
2648			;	;ld a, 0 
2648			;	;ld a, FORTH_END_BUFFER 
2648			;	call strlenz 
2648			;	inc hl   ; include zero term to copy 
2648			;	inc hl   ; include term 
2648			;	inc hl   ; include term 
2648			;	ld b,0 
2648			;	ld c,l 
2648			;	pop hl 
2648			;	ld de, execscratch 
2648			;		if DEBUG_FORTH_WORDS 
2648			;			DMARK "EX3" 
2648			;			CALLMONITOR 
2648			;		endif 
2648			;	ldir 
2648			; 
2648			; 
2648			;	ld hl, execscratch 
2648			; 
2648			;		if DEBUG_FORTH_WORDS 
2648			;			DMARK "EXe" 
2648			;			CALLMONITOR 
2648			;		endif 
2648			; 
2648			;	call forthparse 
2648			;	call forthexec 
2648			;;	call forthexec_cleanup 
2648			;;	call forthparse 
2648			;;	call forthexec 
2648			; 
2648			;	STACKFRAMECHK OFF $5efe $5f9f 
2648			; 
2648			;	; an immediate word so no need to process any more words 
2648			;	ret 
2648			;	NEXTW 
2648			 
2648			; dead code - old version  
2648			;	FORTH_RSP_NEXT 
2648			 
2648			;  
2648			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
2648			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
2648			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2648			;	push hl 
2648			;	push de 
2648			;	push bc 
2648			; 
2648			; 
2648			;		if DEBUG_FORTH_WORDS_KEY 
2648			;			DMARK "EXR" 
2648			;			CALLMONITOR 
2648			;		endif 
2648			; 
2648			; 
2648			; 
2648			;	;v5 FORTH_DSP_VALUE 
2648			;	FORTH_DSP_VALUEHL 
2648			; 
2648			;	; TODO do string type checks 
2648			; 
2648			;;v5	inc hl   ; skip type 
2648			; 
2648			;	push hl  ; source code  
2648			;		if DEBUG_FORTH_WORDS 
2648			;			DMARK "EX1" 
2648			;			CALLMONITOR 
2648			;		endif 
2648			;	ld a, 0 
2648			;	call strlent 
2648			; 
2648			;	inc hl 
2648			;	inc hl 
2648			;	inc hl 
2648			;	inc hl 
2648			; 
2648			;	push hl    ; size 
2648			; 
2648			;		if DEBUG_FORTH_WORDS 
2648			;			DMARK "EX2" 
2648			;			CALLMONITOR 
2648			;		endif 
2648			;	call malloc 
2648			; 
2648			;	ex de, hl    ; de now contains malloc area 
2648			;	pop bc   	; get byte count 
2648			;	pop hl      ; get string to copy 
2648			; 
2648			;	push de     ; save malloc for free later 
2648			; 
2648			;		if DEBUG_FORTH_WORDS 
2648			;			DMARK "EX3" 
2648			;			CALLMONITOR 
2648			;		endif 
2648			;	ldir       ; duplicate string 
2648			; 
2648			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
2648			;	 
2648			;	; TODO fix the parse would be better than this...  
2648			;	ex de, hl 
2648			;	dec hl 
2648			;	ld a, 0 
2648			;	ld (hl), a 
2648			;	dec hl 
2648			;	ld a, ' ' 
2648			;	ld (hl), a 
2648			;	dec hl 
2648			;	ld (hl), a 
2648			; 
2648			;	dec hl 
2648			;	ld (hl), a 
2648			; 
2648			; 
2648			;	FORTH_DSP_POP  
2648			; 
2648			;	pop hl     
2648			;	push hl    ; save malloc area 
2648			; 
2648			;		if DEBUG_FORTH_WORDS 
2648			;			DMARK "EX4" 
2648			;			CALLMONITOR 
2648			;		endif 
2648			; 
2648			;	call forthparse 
2648			;	call forthexec 
2648			;	 
2648			;	pop hl 
2648			;	if DEBUG_FORTH_WORDS 
2648			;		DMARK "EX5" 
2648			;		CALLMONITOR 
2648			;	endif 
2648			; 
2648			;	if FORTH_ENABLE_FREE 
2648			;	call free 
2648			;	endif 
2648			; 
2648			;	if DEBUG_FORTH_WORDS 
2648			;		DMARK "EX6" 
2648			;		CALLMONITOR 
2648			;	endif 
2648			; 
2648			;	pop bc 
2648			;	pop de 
2648			;	pop hl 
2648			;;	FORTH_RSP_POP	  
2648			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
2648			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
2648			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
2648			; 
2648			;	if DEBUG_FORTH_WORDS 
2648			;		DMARK "EX7" 
2648			;		CALLMONITOR 
2648			;	endif 
2648			;	NEXTW 
2648			 
2648			;.STKEXEC: 
2648			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
2648			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
2648			; 
2648			; 
2648			;		if DEBUG_FORTH_WORDS_KEY 
2648			;			DMARK "STX" 
2648			;			CALLMONITOR 
2648			;		endif 
2648			; 
2648			;	FORTH_DSP_VALUEHL 
2648			; 
2648			;	ld (store_tmp1), hl    ; count 
2648			; 
2648			;	FORTH_DSP_POP 
2648			;.stkexec1: 
2648			;	ld hl, (store_tmp1)   ; count 
2648			;	ld a, 0 
2648			;	cp l 
2648			;	ret z 
2648			; 
2648			;	dec hl 
2648			;	ld (store_tmp1), hl    ; count 
2648			;	 
2648			;	FORTH_DSP_VALUEHL 
2648			;	push hl 
2648			;	 
2648			;		if DEBUG_FORTH_WORDS 
2648			;			DMARK "EXp" 
2648			;			CALLMONITOR 
2648			;		endif 
2648			;	FORTH_DSP_POP 
2648			; 
2648			;	call strlenz 
2648			;	inc hl   ; include zero term to copy 
2648			;	inc hl   ; include zero term to copy 
2648			;	inc hl   ; include zero term to copy 
2648			;	ld b,0 
2648			;	ld c,l 
2648			;	pop hl 
2648			;	ld de, execscratch 
2648			;		if DEBUG_FORTH_WORDS 
2648			;			DMARK "EX3" 
2648			;			CALLMONITOR 
2648			;		endif 
2648			;	ldir 
2648			; 
2648			; 
2648			;	ld hl, execscratch 
2648			; 
2648			;		if DEBUG_FORTH_WORDS 
2648			;			DMARK "EXP" 
2648			;			CALLMONITOR 
2648			;		endif 
2648			; 
2648			;	call forthparse 
2648			;	ld hl, execscratch 
2648			;		if DEBUG_FORTH_WORDS 
2648			;			DMARK "EXx" 
2648			;			CALLMONITOR 
2648			;		endif 
2648			;	call forthexec 
2648			; 
2648			;	jp .stkexec1 
2648			; 
2648			;	ret 
2648			 
2648			 
2648			.DUP: 
2648				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
2648 17				db WORD_SYS_CORE+OPCODE_DUP             
2649 be 26			dw .ZDUP            
264b 04				db 3 + 1 
264c .. 00			db "DUP",0              
2650				endm 
# End of macro CWHEAD
2650			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
2650			 
2650					if DEBUG_FORTH_WORDS_KEY 
2650						DMARK "DUP" 
2650 f5				push af  
2651 3a 65 26			ld a, (.dmark)  
2654 32 68 fe			ld (debug_mark),a  
2657 3a 66 26			ld a, (.dmark+1)  
265a 32 69 fe			ld (debug_mark+1),a  
265d 3a 67 26			ld a, (.dmark+2)  
2660 32 6a fe			ld (debug_mark+2),a  
2663 18 03			jr .pastdmark  
2665 ..			.dmark: db "DUP"  
2668 f1			.pastdmark: pop af  
2669			endm  
# End of macro DMARK
2669						CALLMONITOR 
2669 cd 6c fe			call debug_vector  
266c				endm  
# End of macro CALLMONITOR
266c					endif 
266c			 
266c					FORTH_DSP 
266c cd c1 22			call macro_forth_dsp 
266f				endm 
# End of macro FORTH_DSP
266f			 
266f 7e					ld a, (HL) 
2670 fe 01				cp DS_TYPE_STR 
2672 20 25				jr nz, .dupinum 
2674			 
2674					; push another string 
2674			 
2674					FORTH_DSP_VALUEHL     		 
2674 cd fb 22			call macro_dsp_valuehl 
2677				endm 
# End of macro FORTH_DSP_VALUEHL
2677			 
2677				if DEBUG_FORTH_WORDS 
2677					DMARK "DUs" 
2677 f5				push af  
2678 3a 8c 26			ld a, (.dmark)  
267b 32 68 fe			ld (debug_mark),a  
267e 3a 8d 26			ld a, (.dmark+1)  
2681 32 69 fe			ld (debug_mark+1),a  
2684 3a 8e 26			ld a, (.dmark+2)  
2687 32 6a fe			ld (debug_mark+2),a  
268a 18 03			jr .pastdmark  
268c ..			.dmark: db "DUs"  
268f f1			.pastdmark: pop af  
2690			endm  
# End of macro DMARK
2690					CALLMONITOR 
2690 cd 6c fe			call debug_vector  
2693				endm  
# End of macro CALLMONITOR
2693				endif 
2693 cd 72 21				call forth_push_str 
2696			 
2696					NEXTW 
2696 c3 b1 24			jp macro_next 
2699				endm 
# End of macro NEXTW
2699			 
2699			 
2699			.dupinum: 
2699					 
2699			 
2699			 
2699					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2699 cd fb 22			call macro_dsp_valuehl 
269c				endm 
# End of macro FORTH_DSP_VALUEHL
269c			 
269c				; TODO add floating point number detection 
269c			 
269c				if DEBUG_FORTH_WORDS 
269c					DMARK "DUi" 
269c f5				push af  
269d 3a b1 26			ld a, (.dmark)  
26a0 32 68 fe			ld (debug_mark),a  
26a3 3a b2 26			ld a, (.dmark+1)  
26a6 32 69 fe			ld (debug_mark+1),a  
26a9 3a b3 26			ld a, (.dmark+2)  
26ac 32 6a fe			ld (debug_mark+2),a  
26af 18 03			jr .pastdmark  
26b1 ..			.dmark: db "DUi"  
26b4 f1			.pastdmark: pop af  
26b5			endm  
# End of macro DMARK
26b5					CALLMONITOR 
26b5 cd 6c fe			call debug_vector  
26b8				endm  
# End of macro CALLMONITOR
26b8				endif 
26b8			 
26b8 cd 04 21				call forth_push_numhl 
26bb					NEXTW 
26bb c3 b1 24			jp macro_next 
26be				endm 
# End of macro NEXTW
26be			.ZDUP: 
26be				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
26be 99				db WORD_SYS_CORE+OPCODE_ZDUP             
26bf f6 26			dw .SWAP            
26c1 05				db 4 + 1 
26c2 .. 00			db "?DUP",0              
26c7				endm 
# End of macro CWHEAD
26c7			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
26c7			 
26c7					if DEBUG_FORTH_WORDS_KEY 
26c7						DMARK "qDU" 
26c7 f5				push af  
26c8 3a dc 26			ld a, (.dmark)  
26cb 32 68 fe			ld (debug_mark),a  
26ce 3a dd 26			ld a, (.dmark+1)  
26d1 32 69 fe			ld (debug_mark+1),a  
26d4 3a de 26			ld a, (.dmark+2)  
26d7 32 6a fe			ld (debug_mark+2),a  
26da 18 03			jr .pastdmark  
26dc ..			.dmark: db "qDU"  
26df f1			.pastdmark: pop af  
26e0			endm  
# End of macro DMARK
26e0						CALLMONITOR 
26e0 cd 6c fe			call debug_vector  
26e3				endm  
# End of macro CALLMONITOR
26e3					endif 
26e3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26e3 cd fb 22			call macro_dsp_valuehl 
26e6				endm 
# End of macro FORTH_DSP_VALUEHL
26e6			 
26e6 e5					push hl 
26e7			 
26e7					; is it a zero? 
26e7			 
26e7 3e 00				ld a, 0 
26e9 84					add h 
26ea 85					add l 
26eb			 
26eb e1					pop hl 
26ec			 
26ec fe 00				cp 0 
26ee 28 03				jr z, .dup2orig 
26f0			 
26f0			 
26f0 cd 04 21				call forth_push_numhl 
26f3			 
26f3			 
26f3				; TODO add floating point number detection 
26f3			 
26f3			.dup2orig: 
26f3			 
26f3					NEXTW 
26f3 c3 b1 24			jp macro_next 
26f6				endm 
# End of macro NEXTW
26f6			.SWAP: 
26f6				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
26f6 18				db WORD_SYS_CORE+OPCODE_SWAP             
26f7 35 27			dw .COLN            
26f9 05				db 4 + 1 
26fa .. 00			db "SWAP",0              
26ff				endm 
# End of macro CWHEAD
26ff			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
26ff					if DEBUG_FORTH_WORDS_KEY 
26ff						DMARK "SWP" 
26ff f5				push af  
2700 3a 14 27			ld a, (.dmark)  
2703 32 68 fe			ld (debug_mark),a  
2706 3a 15 27			ld a, (.dmark+1)  
2709 32 69 fe			ld (debug_mark+1),a  
270c 3a 16 27			ld a, (.dmark+2)  
270f 32 6a fe			ld (debug_mark+2),a  
2712 18 03			jr .pastdmark  
2714 ..			.dmark: db "SWP"  
2717 f1			.pastdmark: pop af  
2718			endm  
# End of macro DMARK
2718						CALLMONITOR 
2718 cd 6c fe			call debug_vector  
271b				endm  
# End of macro CALLMONITOR
271b					endif 
271b			 
271b					FORTH_DSP_VALUEHL 
271b cd fb 22			call macro_dsp_valuehl 
271e				endm 
# End of macro FORTH_DSP_VALUEHL
271e e5					push hl     ; w2 
271f			 
271f					FORTH_DSP_POP 
271f cd b3 23			call macro_forth_dsp_pop 
2722				endm 
# End of macro FORTH_DSP_POP
2722			 
2722					FORTH_DSP_VALUEHL 
2722 cd fb 22			call macro_dsp_valuehl 
2725				endm 
# End of macro FORTH_DSP_VALUEHL
2725			 
2725					FORTH_DSP_POP 
2725 cd b3 23			call macro_forth_dsp_pop 
2728				endm 
# End of macro FORTH_DSP_POP
2728			 
2728 d1					pop de     ; w2	, hl = w1 
2729			 
2729 eb					ex de, hl 
272a d5					push de 
272b			 
272b cd 04 21				call forth_push_numhl 
272e			 
272e e1					pop hl 
272f			 
272f cd 04 21				call forth_push_numhl 
2732					 
2732			 
2732					NEXTW 
2732 c3 b1 24			jp macro_next 
2735				endm 
# End of macro NEXTW
2735			.COLN: 
2735				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
2735 19				db WORD_SYS_CORE+OPCODE_COLN             
2736 c1 28			dw .SCOLN            
2738 02				db 1 + 1 
2739 .. 00			db ":",0              
273b				endm 
# End of macro CWHEAD
273b			; | : ( -- )         Create new word | DONE 
273b			 
273b					if DEBUG_FORTH_WORDS_KEY 
273b						DMARK "CLN" 
273b f5				push af  
273c 3a 50 27			ld a, (.dmark)  
273f 32 68 fe			ld (debug_mark),a  
2742 3a 51 27			ld a, (.dmark+1)  
2745 32 69 fe			ld (debug_mark+1),a  
2748 3a 52 27			ld a, (.dmark+2)  
274b 32 6a fe			ld (debug_mark+2),a  
274e 18 03			jr .pastdmark  
2750 ..			.dmark: db "CLN"  
2753 f1			.pastdmark: pop af  
2754			endm  
# End of macro DMARK
2754						CALLMONITOR 
2754 cd 6c fe			call debug_vector  
2757				endm  
# End of macro CALLMONITOR
2757					endif 
2757				STACKFRAME OFF $8efe $989f 
2757				if DEBUG_STACK_IMB 
2757					if OFF 
2757						exx 
2757						ld de, $8efe 
2757						ld a, d 
2757						ld hl, curframe 
2757						call hexout 
2757						ld a, e 
2757						ld hl, curframe+2 
2757						call hexout 
2757						ld hl, $8efe 
2757						push hl 
2757						ld hl, $989f 
2757						push hl 
2757						exx 
2757					endif 
2757				endif 
2757			endm 
# End of macro STACKFRAME
2757				; get parser buffer length  of new word 
2757			 
2757				 
2757			 
2757					; move tok past this to start of name defintition 
2757					; TODO get word to define 
2757					; TODO Move past word token 
2757					; TODO get length of string up to the ';' 
2757			 
2757 2a bf f4			ld hl, (os_tok_ptr) 
275a 23				inc hl 
275b 23				inc hl 
275c			 
275c 3e 3b			ld a, ';' 
275e cd 39 14			call strlent 
2761			 
2761 7d				ld a,l 
2762 32 ba f1			ld (os_new_parse_len), a 
2765			 
2765			 
2765			if DEBUG_FORTH_UWORD 
2765 ed 5b bf f4		ld de, (os_tok_ptr) 
2769						DMARK ":01" 
2769 f5				push af  
276a 3a 7e 27			ld a, (.dmark)  
276d 32 68 fe			ld (debug_mark),a  
2770 3a 7f 27			ld a, (.dmark+1)  
2773 32 69 fe			ld (debug_mark+1),a  
2776 3a 80 27			ld a, (.dmark+2)  
2779 32 6a fe			ld (debug_mark+2),a  
277c 18 03			jr .pastdmark  
277e ..			.dmark: db ":01"  
2781 f1			.pastdmark: pop af  
2782			endm  
# End of macro DMARK
2782				CALLMONITOR 
2782 cd 6c fe			call debug_vector  
2785				endm  
# End of macro CALLMONITOR
2785			endif 
2785			 
2785			; 
2785			;  new word memory layout: 
2785			;  
2785			;    : adg 6666 ;  
2785			; 
2785			;    db   1     ; user defined word  
2785 23				inc hl    
2786			;    dw   sysdict 
2786 23				inc hl 
2787 23				inc hl 
2788			;    db <word len>+1 (for null) 
2788 23				inc hl 
2789			;    db .... <word> 
2789			; 
2789			 
2789 23				inc hl    ; some extras for the word preamble before the above 
278a 23				inc hl 
278b 23				inc hl 
278c 23				inc hl 
278d 23				inc hl 
278e 23				inc hl 
278f 23				inc hl  
2790 23				inc hl 
2791 23				inc hl 
2792 23				inc hl 
2793 23				inc hl 
2794 23				inc hl 
2795 23				inc hl 
2796 23				inc hl     ; TODO how many do we really need?     maybe only 6 
2797			;       exec word buffer 
2797			;	<ptr word>   
2797 23				inc hl 
2798 23				inc hl 
2799			;       <word list><null term> 7F final term 
2799			 
2799			 
2799			if DEBUG_FORTH_UWORD 
2799						DMARK ":02" 
2799 f5				push af  
279a 3a ae 27			ld a, (.dmark)  
279d 32 68 fe			ld (debug_mark),a  
27a0 3a af 27			ld a, (.dmark+1)  
27a3 32 69 fe			ld (debug_mark+1),a  
27a6 3a b0 27			ld a, (.dmark+2)  
27a9 32 6a fe			ld (debug_mark+2),a  
27ac 18 03			jr .pastdmark  
27ae ..			.dmark: db ":02"  
27b1 f1			.pastdmark: pop af  
27b2			endm  
# End of macro DMARK
27b2				CALLMONITOR 
27b2 cd 6c fe			call debug_vector  
27b5				endm  
# End of macro CALLMONITOR
27b5			endif 
27b5			 
27b5				 
27b5					; malloc the size 
27b5			 
27b5 cd 97 14				call malloc 
27b8 22 bc f1				ld (os_new_malloc), hl     ; save malloc start 
27bb			 
27bb			;    db   1     ; user defined word  
27bb 3e 01				ld a, WORD_SYS_UWORD  
27bd 77					ld (hl), a 
27be				 
27be 23				inc hl    
27bf			;    dw   sysdict 
27bf 11 09 26			ld de, sysdict       ; continue on with the scan to the system dict 
27c2 73				ld (hl), e 
27c3 23				inc hl 
27c4 72				ld (hl), d 
27c5 23				inc hl 
27c6			 
27c6			 
27c6			;    Setup dict word 
27c6			 
27c6 23				inc hl 
27c7 22 b6 f1			ld (os_new_work_ptr), hl     ; save start of dict word  
27ca			 
27ca				; 1. get length of dict word 
27ca			 
27ca			 
27ca 2a bf f4			ld hl, (os_tok_ptr) 
27cd 23				inc hl 
27ce 23				inc hl    ; position to start of dict word 
27cf 3e 00			ld a, 0 
27d1 cd 39 14			call strlent 
27d4			 
27d4			 
27d4 23				inc hl    ; to include null??? 
27d5			 
27d5				; write length of dict word 
27d5			 
27d5 ed 5b b6 f1		ld de, (os_new_work_ptr)   ; get dest for copy of word 
27d9 1b				dec de 
27da eb				ex de, hl 
27db 73				ld (hl), e 
27dc eb				ex de, hl 
27dd			 
27dd				 
27dd			 
27dd				; copy  
27dd 4d				ld c, l 
27de 06 00			ld b, 0 
27e0 ed 5b b6 f1		ld de, (os_new_work_ptr)   ; get dest for copy of word 
27e4 2a bf f4			ld hl, (os_tok_ptr) 
27e7 23				inc hl 
27e8 23				inc hl    ; position to start of dict word 
27e9				 
27e9			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
27e9				 
27e9				; TODO need to convert word to upper case 
27e9			 
27e9			ucasetok:	 
27e9 7e				ld a,(hl) 
27ea cd 25 14			call toUpper 
27ed 77				ld (hl),a 
27ee ed a0			ldi 
27f0 f2 e9 27		 	jp p, ucasetok 
27f3			 
27f3			 
27f3			 
27f3				; de now points to start of where the word body code should be placed 
27f3 ed 53 b6 f1		ld (os_new_work_ptr), de 
27f7				; hl now points to the words to throw at forthexec which needs to be copied 
27f7 22 b4 f1			ld (os_new_src_ptr), hl 
27fa			 
27fa				; TODO add 'call to forthexec' 
27fa			 
27fa			if DEBUG_FORTH_UWORD 
27fa c5				push bc 
27fb ed 4b bc f1		ld bc, (os_new_malloc) 
27ff						DMARK ":0x" 
27ff f5				push af  
2800 3a 14 28			ld a, (.dmark)  
2803 32 68 fe			ld (debug_mark),a  
2806 3a 15 28			ld a, (.dmark+1)  
2809 32 69 fe			ld (debug_mark+1),a  
280c 3a 16 28			ld a, (.dmark+2)  
280f 32 6a fe			ld (debug_mark+2),a  
2812 18 03			jr .pastdmark  
2814 ..			.dmark: db ":0x"  
2817 f1			.pastdmark: pop af  
2818			endm  
# End of macro DMARK
2818				CALLMONITOR 
2818 cd 6c fe			call debug_vector  
281b				endm  
# End of macro CALLMONITOR
281b c1				pop bc 
281c			endif 
281c			 
281c			 
281c				; create word preamble which should be: 
281c			 
281c			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
281c			 
281c				;    ld hl, <word code> 
281c				;    jp user_exec 
281c			        ;    <word code bytes> 
281c			 
281c			 
281c			;	inc de     ; TODO ??? or are we already past the word's null 
281c eb				ex de, hl 
281d			 
281d 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
281f			 
281f 23				inc hl 
2820 22 b0 f1			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
2823 23				inc hl 
2824			 
2824 23				inc hl 
2825 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
2827			 
2827 01 31 5d			ld bc, user_exec 
282a 23				inc hl 
282b 71				ld (hl), c     ; poke address of user_exec 
282c 23				inc hl 
282d 70				ld (hl), b     
282e			 ; 
282e			;	inc hl 
282e			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
282e			; 
282e			; 
282e			;	ld bc, macro_forth_rsp_next 
282e			;	inc hl 
282e			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
282e			;	inc hl 
282e			;	ld (hl), b     
282e			 ; 
282e			;	inc hl 
282e			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
282e			; 
282e			; 
282e			;	inc hl 
282e			;	ld bc, forthexec 
282e			;	ld (hl), c     ; poke address of forthexec 
282e			;	inc hl 
282e			;	ld (hl), b      
282e			; 
282e			;	inc hl 
282e			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
282e			; 
282e			;	ld bc, user_dict_next 
282e			;	inc hl 
282e			;	ld (hl), c     ; poke address of forthexec 
282e			;	inc hl 
282e			;	ld (hl), b      
282e			 
282e				; hl is now where we need to copy the word byte data to save this 
282e			 
282e 23				inc hl 
282f 22 b2 f1			ld (os_new_exec), hl 
2832				 
2832				; copy definition 
2832			 
2832 eb				ex de, hl 
2833			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
2833			;	inc de    ; skip the PC for this parse 
2833 3a ba f1			ld a, (os_new_parse_len) 
2836 4f				ld c, a 
2837 06 00			ld b, 0 
2839 ed b0			ldir		 ; copy defintion 
283b			 
283b			 
283b				; poke the address of where the new word bytes live for forthexec 
283b			 
283b 2a b0 f1			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
283e			 
283e ed 5b b2 f1		ld de, (os_new_exec)      
2842				 
2842 73				ld (hl), e 
2843 23				inc hl 
2844 72				ld (hl), d 
2845			 
2845					; TODO copy last user dict word next link to this word 
2845					; TODO update last user dict word to point to this word 
2845			; 
2845			; hl f923 de 812a ; bc 811a 
2845			 
2845			if DEBUG_FORTH_UWORD 
2845 c5				push bc 
2846 ed 4b bc f1		ld bc, (os_new_malloc) 
284a						DMARK ":0A" 
284a f5				push af  
284b 3a 5f 28			ld a, (.dmark)  
284e 32 68 fe			ld (debug_mark),a  
2851 3a 60 28			ld a, (.dmark+1)  
2854 32 69 fe			ld (debug_mark+1),a  
2857 3a 61 28			ld a, (.dmark+2)  
285a 32 6a fe			ld (debug_mark+2),a  
285d 18 03			jr .pastdmark  
285f ..			.dmark: db ":0A"  
2862 f1			.pastdmark: pop af  
2863			endm  
# End of macro DMARK
2863				CALLMONITOR 
2863 cd 6c fe			call debug_vector  
2866				endm  
# End of macro CALLMONITOR
2866 c1				pop bc 
2867			endif 
2867			if DEBUG_FORTH_UWORD 
2867 c5				push bc 
2868 ed 4b bc f1		ld bc, (os_new_malloc) 
286c 03				inc bc 
286d 03				inc bc 
286e 03				inc bc 
286f 03				inc bc 
2870 03				inc bc 
2871 03				inc bc 
2872 03				inc bc 
2873 03				inc bc 
2874			 
2874						DMARK ":0B" 
2874 f5				push af  
2875 3a 89 28			ld a, (.dmark)  
2878 32 68 fe			ld (debug_mark),a  
287b 3a 8a 28			ld a, (.dmark+1)  
287e 32 69 fe			ld (debug_mark+1),a  
2881 3a 8b 28			ld a, (.dmark+2)  
2884 32 6a fe			ld (debug_mark+2),a  
2887 18 03			jr .pastdmark  
2889 ..			.dmark: db ":0B"  
288c f1			.pastdmark: pop af  
288d			endm  
# End of macro DMARK
288d				CALLMONITOR 
288d cd 6c fe			call debug_vector  
2890				endm  
# End of macro CALLMONITOR
2890 c1				pop bc 
2891			endif 
2891			 
2891			; update word dict linked list for new word 
2891			 
2891			 
2891 2a bb f4		ld hl, (os_last_new_uword)		; get the start of the last added uword 
2894 23			inc hl     ; move to next work linked list ptr 
2895			 
2895 ed 5b bc f1	ld de, (os_new_malloc)		 ; new next word 
2899 73			ld (hl), e 
289a 23			inc hl 
289b 72			ld (hl), d 
289c			 
289c			if DEBUG_FORTH_UWORD 
289c ed 4b bb f4		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
28a0			endif 
28a0			 
28a0 ed 53 bb f4	ld (os_last_new_uword), de      ; update last new uword ptr 
28a4			 
28a4			 
28a4			if DEBUG_FORTH_UWORD 
28a4						DMARK ":0+" 
28a4 f5				push af  
28a5 3a b9 28			ld a, (.dmark)  
28a8 32 68 fe			ld (debug_mark),a  
28ab 3a ba 28			ld a, (.dmark+1)  
28ae 32 69 fe			ld (debug_mark+1),a  
28b1 3a bb 28			ld a, (.dmark+2)  
28b4 32 6a fe			ld (debug_mark+2),a  
28b7 18 03			jr .pastdmark  
28b9 ..			.dmark: db ":0+"  
28bc f1			.pastdmark: pop af  
28bd			endm  
# End of macro DMARK
28bd				CALLMONITOR 
28bd cd 6c fe			call debug_vector  
28c0				endm  
# End of macro CALLMONITOR
28c0			endif 
28c0			 
28c0				STACKFRAMECHK OFF $8efe $989f 
28c0				if DEBUG_STACK_IMB 
28c0					if OFF 
28c0						exx 
28c0						ld hl, $989f 
28c0						pop de   ; $989f 
28c0						call cmp16 
28c0						jr nz, .spnosame 
28c0						ld hl, $8efe 
28c0						pop de   ; $8efe 
28c0						call cmp16 
28c0						jr z, .spfrsame 
28c0						.spnosame: call showsperror 
28c0						.spfrsame: nop 
28c0						exx 
28c0					endif 
28c0				endif 
28c0			endm 
# End of macro STACKFRAMECHK
28c0			 
28c0 c9			ret    ; dont process any remaining parser tokens as they form new word 
28c1			 
28c1			 
28c1			 
28c1			 
28c1			;		NEXT 
28c1			.SCOLN: 
28c1			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
28c1 06				db OPCODE_SCOLN 
28c2 0d 29			dw .DROP 
28c4 02				db 2 
28c5 .. 00			db ";",0           
28c7			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
28c7					if DEBUG_FORTH_WORDS_KEY 
28c7						DMARK "SCN" 
28c7 f5				push af  
28c8 3a dc 28			ld a, (.dmark)  
28cb 32 68 fe			ld (debug_mark),a  
28ce 3a dd 28			ld a, (.dmark+1)  
28d1 32 69 fe			ld (debug_mark+1),a  
28d4 3a de 28			ld a, (.dmark+2)  
28d7 32 6a fe			ld (debug_mark+2),a  
28da 18 03			jr .pastdmark  
28dc ..			.dmark: db "SCN"  
28df f1			.pastdmark: pop af  
28e0			endm  
# End of macro DMARK
28e0						CALLMONITOR 
28e0 cd 6c fe			call debug_vector  
28e3				endm  
# End of macro CALLMONITOR
28e3					endif 
28e3					FORTH_RSP_TOS 
28e3 cd c2 20			call macro_forth_rsp_tos 
28e6				endm 
# End of macro FORTH_RSP_TOS
28e6 e5					push hl 
28e7					FORTH_RSP_POP 
28e7 cd cc 20			call macro_forth_rsp_pop 
28ea				endm 
# End of macro FORTH_RSP_POP
28ea e1					pop hl 
28eb			;		ex de,hl 
28eb 22 bf f4				ld (os_tok_ptr),hl 
28ee			 
28ee			if DEBUG_FORTH_UWORD 
28ee						DMARK "SCL" 
28ee f5				push af  
28ef 3a 03 29			ld a, (.dmark)  
28f2 32 68 fe			ld (debug_mark),a  
28f5 3a 04 29			ld a, (.dmark+1)  
28f8 32 69 fe			ld (debug_mark+1),a  
28fb 3a 05 29			ld a, (.dmark+2)  
28fe 32 6a fe			ld (debug_mark+2),a  
2901 18 03			jr .pastdmark  
2903 ..			.dmark: db "SCL"  
2906 f1			.pastdmark: pop af  
2907			endm  
# End of macro DMARK
2907				CALLMONITOR 
2907 cd 6c fe			call debug_vector  
290a				endm  
# End of macro CALLMONITOR
290a			endif 
290a					NEXTW 
290a c3 b1 24			jp macro_next 
290d				endm 
# End of macro NEXTW
290d			 
290d			.DROP: 
290d				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
290d 1b				db WORD_SYS_CORE+OPCODE_DROP             
290e 38 29			dw .DUP2            
2910 05				db 4 + 1 
2911 .. 00			db "DROP",0              
2916				endm 
# End of macro CWHEAD
2916			; | DROP ( w -- )   drop the TOS item   | DONE 
2916					if DEBUG_FORTH_WORDS_KEY 
2916						DMARK "DRP" 
2916 f5				push af  
2917 3a 2b 29			ld a, (.dmark)  
291a 32 68 fe			ld (debug_mark),a  
291d 3a 2c 29			ld a, (.dmark+1)  
2920 32 69 fe			ld (debug_mark+1),a  
2923 3a 2d 29			ld a, (.dmark+2)  
2926 32 6a fe			ld (debug_mark+2),a  
2929 18 03			jr .pastdmark  
292b ..			.dmark: db "DRP"  
292e f1			.pastdmark: pop af  
292f			endm  
# End of macro DMARK
292f						CALLMONITOR 
292f cd 6c fe			call debug_vector  
2932				endm  
# End of macro CALLMONITOR
2932					endif 
2932					FORTH_DSP_POP 
2932 cd b3 23			call macro_forth_dsp_pop 
2935				endm 
# End of macro FORTH_DSP_POP
2935					NEXTW 
2935 c3 b1 24			jp macro_next 
2938				endm 
# End of macro NEXTW
2938			.DUP2: 
2938				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
2938 1c				db WORD_SYS_CORE+OPCODE_DUP2             
2939 7d 29			dw .DROP2            
293b 05				db 4 + 1 
293c .. 00			db "2DUP",0              
2941				endm 
# End of macro CWHEAD
2941			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
2941					if DEBUG_FORTH_WORDS_KEY 
2941						DMARK "2DU" 
2941 f5				push af  
2942 3a 56 29			ld a, (.dmark)  
2945 32 68 fe			ld (debug_mark),a  
2948 3a 57 29			ld a, (.dmark+1)  
294b 32 69 fe			ld (debug_mark+1),a  
294e 3a 58 29			ld a, (.dmark+2)  
2951 32 6a fe			ld (debug_mark+2),a  
2954 18 03			jr .pastdmark  
2956 ..			.dmark: db "2DU"  
2959 f1			.pastdmark: pop af  
295a			endm  
# End of macro DMARK
295a						CALLMONITOR 
295a cd 6c fe			call debug_vector  
295d				endm  
# End of macro CALLMONITOR
295d					endif 
295d					FORTH_DSP_VALUEHL 
295d cd fb 22			call macro_dsp_valuehl 
2960				endm 
# End of macro FORTH_DSP_VALUEHL
2960 e5					push hl      ; 2 
2961			 
2961					FORTH_DSP_POP 
2961 cd b3 23			call macro_forth_dsp_pop 
2964				endm 
# End of macro FORTH_DSP_POP
2964					 
2964					FORTH_DSP_VALUEHL 
2964 cd fb 22			call macro_dsp_valuehl 
2967				endm 
# End of macro FORTH_DSP_VALUEHL
2967			;		push hl      ; 1 
2967			 
2967					FORTH_DSP_POP 
2967 cd b3 23			call macro_forth_dsp_pop 
296a				endm 
# End of macro FORTH_DSP_POP
296a			 
296a			;		pop hl       ; 1 
296a d1					pop de       ; 2 
296b			 
296b cd 04 21				call forth_push_numhl 
296e eb					ex de, hl 
296f cd 04 21				call forth_push_numhl 
2972			 
2972					 
2972 eb					ex de, hl 
2973			 
2973 cd 04 21				call forth_push_numhl 
2976 eb					ex de, hl 
2977 cd 04 21				call forth_push_numhl 
297a			 
297a			 
297a					NEXTW 
297a c3 b1 24			jp macro_next 
297d				endm 
# End of macro NEXTW
297d			.DROP2: 
297d				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
297d 1d				db WORD_SYS_CORE+OPCODE_DROP2             
297e ac 29			dw .SWAP2            
2980 06				db 5 + 1 
2981 .. 00			db "2DROP",0              
2987				endm 
# End of macro CWHEAD
2987			; | 2DROP ( w w -- )    Double drop | DONE 
2987					if DEBUG_FORTH_WORDS_KEY 
2987						DMARK "2DR" 
2987 f5				push af  
2988 3a 9c 29			ld a, (.dmark)  
298b 32 68 fe			ld (debug_mark),a  
298e 3a 9d 29			ld a, (.dmark+1)  
2991 32 69 fe			ld (debug_mark+1),a  
2994 3a 9e 29			ld a, (.dmark+2)  
2997 32 6a fe			ld (debug_mark+2),a  
299a 18 03			jr .pastdmark  
299c ..			.dmark: db "2DR"  
299f f1			.pastdmark: pop af  
29a0			endm  
# End of macro DMARK
29a0						CALLMONITOR 
29a0 cd 6c fe			call debug_vector  
29a3				endm  
# End of macro CALLMONITOR
29a3					endif 
29a3					FORTH_DSP_POP 
29a3 cd b3 23			call macro_forth_dsp_pop 
29a6				endm 
# End of macro FORTH_DSP_POP
29a6					FORTH_DSP_POP 
29a6 cd b3 23			call macro_forth_dsp_pop 
29a9				endm 
# End of macro FORTH_DSP_POP
29a9					NEXTW 
29a9 c3 b1 24			jp macro_next 
29ac				endm 
# End of macro NEXTW
29ac			.SWAP2: 
29ac				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
29ac 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
29ad d5 29			dw .AT            
29af 06				db 5 + 1 
29b0 .. 00			db "2SWAP",0              
29b6				endm 
# End of macro CWHEAD
29b6			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
29b6					if DEBUG_FORTH_WORDS_KEY 
29b6						DMARK "2SW" 
29b6 f5				push af  
29b7 3a cb 29			ld a, (.dmark)  
29ba 32 68 fe			ld (debug_mark),a  
29bd 3a cc 29			ld a, (.dmark+1)  
29c0 32 69 fe			ld (debug_mark+1),a  
29c3 3a cd 29			ld a, (.dmark+2)  
29c6 32 6a fe			ld (debug_mark+2),a  
29c9 18 03			jr .pastdmark  
29cb ..			.dmark: db "2SW"  
29ce f1			.pastdmark: pop af  
29cf			endm  
# End of macro DMARK
29cf						CALLMONITOR 
29cf cd 6c fe			call debug_vector  
29d2				endm  
# End of macro CALLMONITOR
29d2					endif 
29d2					NEXTW 
29d2 c3 b1 24			jp macro_next 
29d5				endm 
# End of macro NEXTW
29d5			.AT: 
29d5				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
29d5 1f				db WORD_SYS_CORE+OPCODE_AT             
29d6 07 2a			dw .CAT            
29d8 02				db 1 + 1 
29d9 .. 00			db "@",0              
29db				endm 
# End of macro CWHEAD
29db			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
29db			 
29db					if DEBUG_FORTH_WORDS_KEY 
29db						DMARK "AT." 
29db f5				push af  
29dc 3a f0 29			ld a, (.dmark)  
29df 32 68 fe			ld (debug_mark),a  
29e2 3a f1 29			ld a, (.dmark+1)  
29e5 32 69 fe			ld (debug_mark+1),a  
29e8 3a f2 29			ld a, (.dmark+2)  
29eb 32 6a fe			ld (debug_mark+2),a  
29ee 18 03			jr .pastdmark  
29f0 ..			.dmark: db "AT."  
29f3 f1			.pastdmark: pop af  
29f4			endm  
# End of macro DMARK
29f4						CALLMONITOR 
29f4 cd 6c fe			call debug_vector  
29f7				endm  
# End of macro CALLMONITOR
29f7					endif 
29f7			.getbyteat:	 
29f7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29f7 cd fb 22			call macro_dsp_valuehl 
29fa				endm 
# End of macro FORTH_DSP_VALUEHL
29fa					 
29fa			;		push hl 
29fa				 
29fa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29fa cd b3 23			call macro_forth_dsp_pop 
29fd				endm 
# End of macro FORTH_DSP_POP
29fd			 
29fd			;		pop hl 
29fd			 
29fd 7e					ld a, (hl) 
29fe			 
29fe 6f					ld l, a 
29ff 26 00				ld h, 0 
2a01 cd 04 21				call forth_push_numhl 
2a04			 
2a04					NEXTW 
2a04 c3 b1 24			jp macro_next 
2a07				endm 
# End of macro NEXTW
2a07			.CAT: 
2a07				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
2a07 20				db WORD_SYS_CORE+OPCODE_CAT             
2a08 30 2a			dw .BANG            
2a0a 03				db 2 + 1 
2a0b .. 00			db "C@",0              
2a0e				endm 
# End of macro CWHEAD
2a0e			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
2a0e					if DEBUG_FORTH_WORDS_KEY 
2a0e						DMARK "CAA" 
2a0e f5				push af  
2a0f 3a 23 2a			ld a, (.dmark)  
2a12 32 68 fe			ld (debug_mark),a  
2a15 3a 24 2a			ld a, (.dmark+1)  
2a18 32 69 fe			ld (debug_mark+1),a  
2a1b 3a 25 2a			ld a, (.dmark+2)  
2a1e 32 6a fe			ld (debug_mark+2),a  
2a21 18 03			jr .pastdmark  
2a23 ..			.dmark: db "CAA"  
2a26 f1			.pastdmark: pop af  
2a27			endm  
# End of macro DMARK
2a27						CALLMONITOR 
2a27 cd 6c fe			call debug_vector  
2a2a				endm  
# End of macro CALLMONITOR
2a2a					endif 
2a2a c3 f7 29				jp .getbyteat 
2a2d					NEXTW 
2a2d c3 b1 24			jp macro_next 
2a30				endm 
# End of macro NEXTW
2a30			.BANG: 
2a30				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
2a30 21				db WORD_SYS_CORE+OPCODE_BANG             
2a31 66 2a			dw .CBANG            
2a33 02				db 1 + 1 
2a34 .. 00			db "!",0              
2a36				endm 
# End of macro CWHEAD
2a36			; | ! ( x w -- ) Store x at address w      | DONE 
2a36					if DEBUG_FORTH_WORDS_KEY 
2a36						DMARK "BNG" 
2a36 f5				push af  
2a37 3a 4b 2a			ld a, (.dmark)  
2a3a 32 68 fe			ld (debug_mark),a  
2a3d 3a 4c 2a			ld a, (.dmark+1)  
2a40 32 69 fe			ld (debug_mark+1),a  
2a43 3a 4d 2a			ld a, (.dmark+2)  
2a46 32 6a fe			ld (debug_mark+2),a  
2a49 18 03			jr .pastdmark  
2a4b ..			.dmark: db "BNG"  
2a4e f1			.pastdmark: pop af  
2a4f			endm  
# End of macro DMARK
2a4f						CALLMONITOR 
2a4f cd 6c fe			call debug_vector  
2a52				endm  
# End of macro CALLMONITOR
2a52					endif 
2a52			 
2a52			.storebyteat:		 
2a52					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a52 cd fb 22			call macro_dsp_valuehl 
2a55				endm 
# End of macro FORTH_DSP_VALUEHL
2a55					 
2a55 e5					push hl 
2a56				 
2a56					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a56 cd b3 23			call macro_forth_dsp_pop 
2a59				endm 
# End of macro FORTH_DSP_POP
2a59			 
2a59					; get byte to poke 
2a59			 
2a59					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a59 cd fb 22			call macro_dsp_valuehl 
2a5c				endm 
# End of macro FORTH_DSP_VALUEHL
2a5c e5					push hl 
2a5d			 
2a5d			 
2a5d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a5d cd b3 23			call macro_forth_dsp_pop 
2a60				endm 
# End of macro FORTH_DSP_POP
2a60			 
2a60			 
2a60 d1					pop de 
2a61 e1					pop hl 
2a62			 
2a62 73					ld (hl),e 
2a63			 
2a63			 
2a63					NEXTW 
2a63 c3 b1 24			jp macro_next 
2a66				endm 
# End of macro NEXTW
2a66			.CBANG: 
2a66				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
2a66 22				db WORD_SYS_CORE+OPCODE_CBANG             
2a67 8f 2a			dw .SCALL            
2a69 03				db 2 + 1 
2a6a .. 00			db "C!",0              
2a6d				endm 
# End of macro CWHEAD
2a6d			; | C!  ( x w -- ) Store x at address w  | DONE 
2a6d					if DEBUG_FORTH_WORDS_KEY 
2a6d						DMARK "CBA" 
2a6d f5				push af  
2a6e 3a 82 2a			ld a, (.dmark)  
2a71 32 68 fe			ld (debug_mark),a  
2a74 3a 83 2a			ld a, (.dmark+1)  
2a77 32 69 fe			ld (debug_mark+1),a  
2a7a 3a 84 2a			ld a, (.dmark+2)  
2a7d 32 6a fe			ld (debug_mark+2),a  
2a80 18 03			jr .pastdmark  
2a82 ..			.dmark: db "CBA"  
2a85 f1			.pastdmark: pop af  
2a86			endm  
# End of macro DMARK
2a86						CALLMONITOR 
2a86 cd 6c fe			call debug_vector  
2a89				endm  
# End of macro CALLMONITOR
2a89					endif 
2a89 c3 52 2a				jp .storebyteat 
2a8c					NEXTW 
2a8c c3 b1 24			jp macro_next 
2a8f				endm 
# End of macro NEXTW
2a8f			.SCALL: 
2a8f				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
2a8f 23				db WORD_SYS_CORE+OPCODE_SCALL             
2a90 c3 2a			dw .DEPTH            
2a92 05				db 4 + 1 
2a93 .. 00			db "CALL",0              
2a98				endm 
# End of macro CWHEAD
2a98			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
2a98					if DEBUG_FORTH_WORDS_KEY 
2a98						DMARK "CLL" 
2a98 f5				push af  
2a99 3a ad 2a			ld a, (.dmark)  
2a9c 32 68 fe			ld (debug_mark),a  
2a9f 3a ae 2a			ld a, (.dmark+1)  
2aa2 32 69 fe			ld (debug_mark+1),a  
2aa5 3a af 2a			ld a, (.dmark+2)  
2aa8 32 6a fe			ld (debug_mark+2),a  
2aab 18 03			jr .pastdmark  
2aad ..			.dmark: db "CLL"  
2ab0 f1			.pastdmark: pop af  
2ab1			endm  
# End of macro DMARK
2ab1						CALLMONITOR 
2ab1 cd 6c fe			call debug_vector  
2ab4				endm  
# End of macro CALLMONITOR
2ab4					endif 
2ab4			 
2ab4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2ab4 cd fb 22			call macro_dsp_valuehl 
2ab7				endm 
# End of macro FORTH_DSP_VALUEHL
2ab7			 
2ab7			;		push hl 
2ab7			 
2ab7					; destroy value TOS 
2ab7			 
2ab7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2ab7 cd b3 23			call macro_forth_dsp_pop 
2aba				endm 
# End of macro FORTH_DSP_POP
2aba			 
2aba						 
2aba			;		pop hl 
2aba			 
2aba					; how to do a call with hl???? save SP? 
2aba cd 55 24				call forth_call_hl 
2abd			 
2abd			 
2abd					; TODO push value back onto stack for another op etc 
2abd			 
2abd cd 04 21				call forth_push_numhl 
2ac0					NEXTW 
2ac0 c3 b1 24			jp macro_next 
2ac3				endm 
# End of macro NEXTW
2ac3			.DEPTH: 
2ac3				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2ac3 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2ac4 00 2b			dw .OVER            
2ac6 06				db 5 + 1 
2ac7 .. 00			db "DEPTH",0              
2acd				endm 
# End of macro CWHEAD
2acd			; | DEPTH ( -- u ) Push count of stack | DONE 
2acd					; take current TOS and remove from base value div by two to get count 
2acd					if DEBUG_FORTH_WORDS_KEY 
2acd						DMARK "DEP" 
2acd f5				push af  
2ace 3a e2 2a			ld a, (.dmark)  
2ad1 32 68 fe			ld (debug_mark),a  
2ad4 3a e3 2a			ld a, (.dmark+1)  
2ad7 32 69 fe			ld (debug_mark+1),a  
2ada 3a e4 2a			ld a, (.dmark+2)  
2add 32 6a fe			ld (debug_mark+2),a  
2ae0 18 03			jr .pastdmark  
2ae2 ..			.dmark: db "DEP"  
2ae5 f1			.pastdmark: pop af  
2ae6			endm  
# End of macro DMARK
2ae6						CALLMONITOR 
2ae6 cd 6c fe			call debug_vector  
2ae9				endm  
# End of macro CALLMONITOR
2ae9					endif 
2ae9			 
2ae9			 
2ae9 2a eb f9			ld hl, (cli_data_sp) 
2aec 11 25 f7			ld de, cli_data_stack 
2aef ed 52			sbc hl,de 
2af1				 
2af1				; div by size of stack item 
2af1			 
2af1 5d				ld e,l 
2af2 0e 03			ld c, 3 
2af4 cd 60 0f			call Div8 
2af7			 
2af7 6f				ld l,a 
2af8 26 00			ld h,0 
2afa			 
2afa				;srl h 
2afa				;rr l 
2afa			 
2afa cd 04 21				call forth_push_numhl 
2afd					NEXTW 
2afd c3 b1 24			jp macro_next 
2b00				endm 
# End of macro NEXTW
2b00			.OVER: 
2b00				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2b00 42				db WORD_SYS_CORE+46             
2b01 47 2b			dw .PAUSE            
2b03 05				db 4 + 1 
2b04 .. 00			db "OVER",0              
2b09				endm 
# End of macro CWHEAD
2b09			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
2b09					if DEBUG_FORTH_WORDS_KEY 
2b09						DMARK "OVR" 
2b09 f5				push af  
2b0a 3a 1e 2b			ld a, (.dmark)  
2b0d 32 68 fe			ld (debug_mark),a  
2b10 3a 1f 2b			ld a, (.dmark+1)  
2b13 32 69 fe			ld (debug_mark+1),a  
2b16 3a 20 2b			ld a, (.dmark+2)  
2b19 32 6a fe			ld (debug_mark+2),a  
2b1c 18 03			jr .pastdmark  
2b1e ..			.dmark: db "OVR"  
2b21 f1			.pastdmark: pop af  
2b22			endm  
# End of macro DMARK
2b22						CALLMONITOR 
2b22 cd 6c fe			call debug_vector  
2b25				endm  
# End of macro CALLMONITOR
2b25					endif 
2b25			 
2b25					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b25 cd fb 22			call macro_dsp_valuehl 
2b28				endm 
# End of macro FORTH_DSP_VALUEHL
2b28 e5					push hl    ; n2 
2b29					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b29 cd b3 23			call macro_forth_dsp_pop 
2b2c				endm 
# End of macro FORTH_DSP_POP
2b2c			 
2b2c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b2c cd fb 22			call macro_dsp_valuehl 
2b2f				endm 
# End of macro FORTH_DSP_VALUEHL
2b2f e5					push hl    ; n1 
2b30					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b30 cd b3 23			call macro_forth_dsp_pop 
2b33				endm 
# End of macro FORTH_DSP_POP
2b33			 
2b33 d1					pop de     ; n1 
2b34 e1					pop hl     ; n2 
2b35			 
2b35 d5					push de 
2b36 e5					push hl 
2b37 d5					push de 
2b38			 
2b38					; push back  
2b38			 
2b38 e1					pop hl 
2b39 cd 04 21				call forth_push_numhl 
2b3c e1					pop hl 
2b3d cd 04 21				call forth_push_numhl 
2b40 e1					pop hl 
2b41 cd 04 21				call forth_push_numhl 
2b44					NEXTW 
2b44 c3 b1 24			jp macro_next 
2b47				endm 
# End of macro NEXTW
2b47			 
2b47			.PAUSE: 
2b47				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2b47 43				db WORD_SYS_CORE+47             
2b48 7c 2b			dw .PAUSES            
2b4a 08				db 7 + 1 
2b4b .. 00			db "PAUSEMS",0              
2b53				endm 
# End of macro CWHEAD
2b53			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
2b53					if DEBUG_FORTH_WORDS_KEY 
2b53						DMARK "PMS" 
2b53 f5				push af  
2b54 3a 68 2b			ld a, (.dmark)  
2b57 32 68 fe			ld (debug_mark),a  
2b5a 3a 69 2b			ld a, (.dmark+1)  
2b5d 32 69 fe			ld (debug_mark+1),a  
2b60 3a 6a 2b			ld a, (.dmark+2)  
2b63 32 6a fe			ld (debug_mark+2),a  
2b66 18 03			jr .pastdmark  
2b68 ..			.dmark: db "PMS"  
2b6b f1			.pastdmark: pop af  
2b6c			endm  
# End of macro DMARK
2b6c						CALLMONITOR 
2b6c cd 6c fe			call debug_vector  
2b6f				endm  
# End of macro CALLMONITOR
2b6f					endif 
2b6f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b6f cd fb 22			call macro_dsp_valuehl 
2b72				endm 
# End of macro FORTH_DSP_VALUEHL
2b72			;		push hl    ; n2 
2b72					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b72 cd b3 23			call macro_forth_dsp_pop 
2b75				endm 
# End of macro FORTH_DSP_POP
2b75			;		pop hl 
2b75			 
2b75 7d					ld a, l 
2b76 cd c4 0c				call aDelayInMS 
2b79				       NEXTW 
2b79 c3 b1 24			jp macro_next 
2b7c				endm 
# End of macro NEXTW
2b7c			.PAUSES:  
2b7c				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
2b7c 44				db WORD_SYS_CORE+48             
2b7d eb 2b			dw .ROT            
2b7f 06				db 5 + 1 
2b80 .. 00			db "PAUSE",0              
2b86				endm 
# End of macro CWHEAD
2b86			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2b86					if DEBUG_FORTH_WORDS_KEY 
2b86						DMARK "PAU" 
2b86 f5				push af  
2b87 3a 9b 2b			ld a, (.dmark)  
2b8a 32 68 fe			ld (debug_mark),a  
2b8d 3a 9c 2b			ld a, (.dmark+1)  
2b90 32 69 fe			ld (debug_mark+1),a  
2b93 3a 9d 2b			ld a, (.dmark+2)  
2b96 32 6a fe			ld (debug_mark+2),a  
2b99 18 03			jr .pastdmark  
2b9b ..			.dmark: db "PAU"  
2b9e f1			.pastdmark: pop af  
2b9f			endm  
# End of macro DMARK
2b9f						CALLMONITOR 
2b9f cd 6c fe			call debug_vector  
2ba2				endm  
# End of macro CALLMONITOR
2ba2					endif 
2ba2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2ba2 cd fb 22			call macro_dsp_valuehl 
2ba5				endm 
# End of macro FORTH_DSP_VALUEHL
2ba5			;		push hl    ; n2 
2ba5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2ba5 cd b3 23			call macro_forth_dsp_pop 
2ba8				endm 
# End of macro FORTH_DSP_POP
2ba8			;		pop hl 
2ba8 45					ld b, l 
2ba9					if DEBUG_FORTH_WORDS 
2ba9						DMARK "PAU" 
2ba9 f5				push af  
2baa 3a be 2b			ld a, (.dmark)  
2bad 32 68 fe			ld (debug_mark),a  
2bb0 3a bf 2b			ld a, (.dmark+1)  
2bb3 32 69 fe			ld (debug_mark+1),a  
2bb6 3a c0 2b			ld a, (.dmark+2)  
2bb9 32 6a fe			ld (debug_mark+2),a  
2bbc 18 03			jr .pastdmark  
2bbe ..			.dmark: db "PAU"  
2bc1 f1			.pastdmark: pop af  
2bc2			endm  
# End of macro DMARK
2bc2						CALLMONITOR 
2bc2 cd 6c fe			call debug_vector  
2bc5				endm  
# End of macro CALLMONITOR
2bc5					endif 
2bc5 c5			.pauses1:	push bc 
2bc6 cd df 0c				call delay1s 
2bc9 c1					pop bc 
2bca					if DEBUG_FORTH_WORDS 
2bca						DMARK "PA1" 
2bca f5				push af  
2bcb 3a df 2b			ld a, (.dmark)  
2bce 32 68 fe			ld (debug_mark),a  
2bd1 3a e0 2b			ld a, (.dmark+1)  
2bd4 32 69 fe			ld (debug_mark+1),a  
2bd7 3a e1 2b			ld a, (.dmark+2)  
2bda 32 6a fe			ld (debug_mark+2),a  
2bdd 18 03			jr .pastdmark  
2bdf ..			.dmark: db "PA1"  
2be2 f1			.pastdmark: pop af  
2be3			endm  
# End of macro DMARK
2be3						CALLMONITOR 
2be3 cd 6c fe			call debug_vector  
2be6				endm  
# End of macro CALLMONITOR
2be6					endif 
2be6 10 dd				djnz .pauses1 
2be8			 
2be8				       NEXTW 
2be8 c3 b1 24			jp macro_next 
2beb				endm 
# End of macro NEXTW
2beb			.ROT: 
2beb				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2beb 45				db WORD_SYS_CORE+49             
2bec 39 2c			dw .UWORDS            
2bee 04				db 3 + 1 
2bef .. 00			db "ROT",0              
2bf3				endm 
# End of macro CWHEAD
2bf3			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2bf3					if DEBUG_FORTH_WORDS_KEY 
2bf3						DMARK "ROT" 
2bf3 f5				push af  
2bf4 3a 08 2c			ld a, (.dmark)  
2bf7 32 68 fe			ld (debug_mark),a  
2bfa 3a 09 2c			ld a, (.dmark+1)  
2bfd 32 69 fe			ld (debug_mark+1),a  
2c00 3a 0a 2c			ld a, (.dmark+2)  
2c03 32 6a fe			ld (debug_mark+2),a  
2c06 18 03			jr .pastdmark  
2c08 ..			.dmark: db "ROT"  
2c0b f1			.pastdmark: pop af  
2c0c			endm  
# End of macro DMARK
2c0c						CALLMONITOR 
2c0c cd 6c fe			call debug_vector  
2c0f				endm  
# End of macro CALLMONITOR
2c0f					endif 
2c0f			 
2c0f					FORTH_DSP_VALUEHL 
2c0f cd fb 22			call macro_dsp_valuehl 
2c12				endm 
# End of macro FORTH_DSP_VALUEHL
2c12 e5					push hl    ; u3  
2c13			 
2c13					FORTH_DSP_POP 
2c13 cd b3 23			call macro_forth_dsp_pop 
2c16				endm 
# End of macro FORTH_DSP_POP
2c16			   
2c16					FORTH_DSP_VALUEHL 
2c16 cd fb 22			call macro_dsp_valuehl 
2c19				endm 
# End of macro FORTH_DSP_VALUEHL
2c19 e5					push hl     ; u2 
2c1a			 
2c1a					FORTH_DSP_POP 
2c1a cd b3 23			call macro_forth_dsp_pop 
2c1d				endm 
# End of macro FORTH_DSP_POP
2c1d			 
2c1d					FORTH_DSP_VALUEHL 
2c1d cd fb 22			call macro_dsp_valuehl 
2c20				endm 
# End of macro FORTH_DSP_VALUEHL
2c20 e5					push hl     ; u1 
2c21			 
2c21					FORTH_DSP_POP 
2c21 cd b3 23			call macro_forth_dsp_pop 
2c24				endm 
# End of macro FORTH_DSP_POP
2c24			 
2c24 c1					pop bc      ; u1 
2c25 e1					pop hl      ; u2 
2c26 d1					pop de      ; u3 
2c27			 
2c27			 
2c27 c5					push bc 
2c28 d5					push de 
2c29 e5					push hl 
2c2a			 
2c2a			 
2c2a e1					pop hl 
2c2b cd 04 21				call forth_push_numhl 
2c2e			 
2c2e e1					pop hl 
2c2f cd 04 21				call forth_push_numhl 
2c32			 
2c32 e1					pop hl 
2c33 cd 04 21				call forth_push_numhl 
2c36					 
2c36			 
2c36			 
2c36			 
2c36			 
2c36			 
2c36				       NEXTW 
2c36 c3 b1 24			jp macro_next 
2c39				endm 
# End of macro NEXTW
2c39			 
2c39			.UWORDS: 
2c39				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2c39 50				db WORD_SYS_CORE+60             
2c3a fb 2c			dw .BP            
2c3c 07				db 6 + 1 
2c3d .. 00			db "UWORDS",0              
2c44				endm 
# End of macro CWHEAD
2c44			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2c44			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2c44			; | | Following the count are the individual words. 
2c44			; | | 
2c44			; | | e.g. UWORDS 
2c44			; | | BOX DIRLIST 2 
2c44			; | |  
2c44			; | | Can be used to save the words to storage via: 
2c44			; | | UWORDS $01 DO $01 APPEND LOOP 
2c44				if DEBUG_FORTH_WORDS_KEY 
2c44					DMARK "UWR" 
2c44 f5				push af  
2c45 3a 59 2c			ld a, (.dmark)  
2c48 32 68 fe			ld (debug_mark),a  
2c4b 3a 5a 2c			ld a, (.dmark+1)  
2c4e 32 69 fe			ld (debug_mark+1),a  
2c51 3a 5b 2c			ld a, (.dmark+2)  
2c54 32 6a fe			ld (debug_mark+2),a  
2c57 18 03			jr .pastdmark  
2c59 ..			.dmark: db "UWR"  
2c5c f1			.pastdmark: pop af  
2c5d			endm  
# End of macro DMARK
2c5d					CALLMONITOR 
2c5d cd 6c fe			call debug_vector  
2c60				endm  
# End of macro CALLMONITOR
2c60				endif 
2c60 21 00 80				ld hl, baseram 
2c63					;ld hl, baseusermem 
2c63 01 00 00				ld bc, 0    ; start a counter 
2c66			 
2c66				; skip dict stub 
2c66			 
2c66 cd 02 26				call forth_tok_next 
2c69			 
2c69			 
2c69			; while we have words to look for 
2c69			 
2c69 7e			.douscan:	ld a, (hl)      
2c6a				if DEBUG_FORTH_WORDS 
2c6a					DMARK "UWs" 
2c6a f5				push af  
2c6b 3a 7f 2c			ld a, (.dmark)  
2c6e 32 68 fe			ld (debug_mark),a  
2c71 3a 80 2c			ld a, (.dmark+1)  
2c74 32 69 fe			ld (debug_mark+1),a  
2c77 3a 81 2c			ld a, (.dmark+2)  
2c7a 32 6a fe			ld (debug_mark+2),a  
2c7d 18 03			jr .pastdmark  
2c7f ..			.dmark: db "UWs"  
2c82 f1			.pastdmark: pop af  
2c83			endm  
# End of macro DMARK
2c83					CALLMONITOR 
2c83 cd 6c fe			call debug_vector  
2c86				endm  
# End of macro CALLMONITOR
2c86				endif 
2c86 fe 00				cp WORD_SYS_END 
2c88 28 4d				jr z, .udone 
2c8a fe 01				cp WORD_SYS_UWORD 
2c8c 20 44				jr nz, .nuword 
2c8e			 
2c8e				if DEBUG_FORTH_WORDS 
2c8e					DMARK "UWu" 
2c8e f5				push af  
2c8f 3a a3 2c			ld a, (.dmark)  
2c92 32 68 fe			ld (debug_mark),a  
2c95 3a a4 2c			ld a, (.dmark+1)  
2c98 32 69 fe			ld (debug_mark+1),a  
2c9b 3a a5 2c			ld a, (.dmark+2)  
2c9e 32 6a fe			ld (debug_mark+2),a  
2ca1 18 03			jr .pastdmark  
2ca3 ..			.dmark: db "UWu"  
2ca6 f1			.pastdmark: pop af  
2ca7			endm  
# End of macro DMARK
2ca7					CALLMONITOR 
2ca7 cd 6c fe			call debug_vector  
2caa				endm  
# End of macro CALLMONITOR
2caa				endif 
2caa					; we have a uword so push its name to the stack 
2caa			 
2caa e5				   	push hl  ; save so we can move to next dict block 
2cab			 
2cab					; skip opcode 
2cab 23					inc hl  
2cac					; skip next ptr 
2cac 23					inc hl  
2cad 23					inc hl 
2cae					; skip len 
2cae 23					inc hl 
2caf				if DEBUG_FORTH_WORDS 
2caf					DMARK "UWt" 
2caf f5				push af  
2cb0 3a c4 2c			ld a, (.dmark)  
2cb3 32 68 fe			ld (debug_mark),a  
2cb6 3a c5 2c			ld a, (.dmark+1)  
2cb9 32 69 fe			ld (debug_mark+1),a  
2cbc 3a c6 2c			ld a, (.dmark+2)  
2cbf 32 6a fe			ld (debug_mark+2),a  
2cc2 18 03			jr .pastdmark  
2cc4 ..			.dmark: db "UWt"  
2cc7 f1			.pastdmark: pop af  
2cc8			endm  
# End of macro DMARK
2cc8					CALLMONITOR 
2cc8 cd 6c fe			call debug_vector  
2ccb				endm  
# End of macro CALLMONITOR
2ccb				endif 
2ccb 03					inc bc 
2ccc			 
2ccc c5					push bc 
2ccd cd 72 21				call forth_push_str 
2cd0 c1					pop bc 
2cd1			 
2cd1 e1					pop hl 	 
2cd2			 
2cd2 cd 02 26		.nuword:	call forth_tok_next 
2cd5 18 92				jr .douscan  
2cd7			 
2cd7			.udone:		 ; push count of uwords found 
2cd7 c5					push bc 
2cd8 e1					pop hl 
2cd9			 
2cd9				if DEBUG_FORTH_WORDS 
2cd9					DMARK "UWc" 
2cd9 f5				push af  
2cda 3a ee 2c			ld a, (.dmark)  
2cdd 32 68 fe			ld (debug_mark),a  
2ce0 3a ef 2c			ld a, (.dmark+1)  
2ce3 32 69 fe			ld (debug_mark+1),a  
2ce6 3a f0 2c			ld a, (.dmark+2)  
2ce9 32 6a fe			ld (debug_mark+2),a  
2cec 18 03			jr .pastdmark  
2cee ..			.dmark: db "UWc"  
2cf1 f1			.pastdmark: pop af  
2cf2			endm  
# End of macro DMARK
2cf2					CALLMONITOR 
2cf2 cd 6c fe			call debug_vector  
2cf5				endm  
# End of macro CALLMONITOR
2cf5				endif 
2cf5 cd 04 21				call forth_push_numhl 
2cf8			 
2cf8			 
2cf8				       NEXTW 
2cf8 c3 b1 24			jp macro_next 
2cfb				endm 
# End of macro NEXTW
2cfb			 
2cfb			.BP: 
2cfb				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2cfb 54				db WORD_SYS_CORE+64             
2cfc 35 2d			dw .MONITOR            
2cfe 03				db 2 + 1 
2cff .. 00			db "BP",0              
2d02				endm 
# End of macro CWHEAD
2d02			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2d02			; | | $00 Will enable the break points within specific code paths 
2d02			; | | $01 Will disable break points 
2d02			; | |  
2d02			; | | By default break points are off. Either the above can be used to enable them 
2d02			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2d02			; | | and on release of the pressed key a message will be disaplayed to notify 
2d02			; | | that break points are enabled. Pressing any key will then continue boot process. 
2d02					; get byte count 
2d02					if DEBUG_FORTH_WORDS_KEY 
2d02						DMARK "BP." 
2d02 f5				push af  
2d03 3a 17 2d			ld a, (.dmark)  
2d06 32 68 fe			ld (debug_mark),a  
2d09 3a 18 2d			ld a, (.dmark+1)  
2d0c 32 69 fe			ld (debug_mark+1),a  
2d0f 3a 19 2d			ld a, (.dmark+2)  
2d12 32 6a fe			ld (debug_mark+2),a  
2d15 18 03			jr .pastdmark  
2d17 ..			.dmark: db "BP."  
2d1a f1			.pastdmark: pop af  
2d1b			endm  
# End of macro DMARK
2d1b						CALLMONITOR 
2d1b cd 6c fe			call debug_vector  
2d1e				endm  
# End of macro CALLMONITOR
2d1e					endif 
2d1e			 
2d1e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2d1e cd fb 22			call macro_dsp_valuehl 
2d21				endm 
# End of macro FORTH_DSP_VALUEHL
2d21			 
2d21			;		push hl 
2d21			 
2d21					; destroy value TOS 
2d21			 
2d21					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2d21 cd b3 23			call macro_forth_dsp_pop 
2d24				endm 
# End of macro FORTH_DSP_POP
2d24			 
2d24			;		pop hl 
2d24			 
2d24 3e 00				ld a,0 
2d26 bd					cp l 
2d27 28 06				jr z, .bpset 
2d29			;		ld a, '*' 
2d29 cd 42 1a				call bp_off 
2d2c					NEXTW 
2d2c c3 b1 24			jp macro_next 
2d2f				endm 
# End of macro NEXTW
2d2f			 
2d2f			.bpset:	 
2d2f					;	ld (os_view_disable), a 
2d2f cd 36 1a				call bp_on 
2d32			 
2d32			 
2d32					NEXTW 
2d32 c3 b1 24			jp macro_next 
2d35				endm 
# End of macro NEXTW
2d35			 
2d35			 
2d35			.MONITOR: 
2d35				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2d35 55				db WORD_SYS_CORE+65             
2d36 66 2d			dw .MALLOC            
2d38 08				db 7 + 1 
2d39 .. 00			db "MONITOR",0              
2d41				endm 
# End of macro CWHEAD
2d41			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2d41			; | | At start the current various registers will be displayed with contents. 
2d41			; | | Top right corner will show the most recent debug marker seen. 
2d41			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2d41			; | | and the return stack pointer (RSP). 
2d41			; | | Pressing: 
2d41			; | |    1 - Initial screen 
2d41			; | |    2 - Display a data dump of HL 
2d41			; | |    3 - Display a data dump of DE 
2d41			; | |    4 - Display a data dump of BC 
2d41			; | |    5 - Display a data dump of HL 
2d41			; | |    6 - Display a data dump of DSP 
2d41			; | |    7 - Display a data dump of RSP 
2d41			; | |    8 - Display a data dump of what is at DSP 
2d41			; | |    9 - Display a data dump of what is at RSP 
2d41			; | |    0 - Exit monitor and continue running. This will also enable break points 
2d41			; | |    * - Disable break points 
2d41			; | |    # - Enter traditional monitor mode 
2d41			; | | 
2d41			; | | Monitor Mode 
2d41			; | | ------------ 
2d41			; | | A prompt of '>' will be shown for various commands: 
2d41			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2d41			; | |    C - Continue display a data dump from the last set address 
2d41			; | |    M xxxx - Set start of memory edit at address xx 
2d41			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2d41			; | |    Q - Return to previous 
2d41					if DEBUG_FORTH_WORDS_KEY 
2d41						DMARK "MON" 
2d41 f5				push af  
2d42 3a 56 2d			ld a, (.dmark)  
2d45 32 68 fe			ld (debug_mark),a  
2d48 3a 57 2d			ld a, (.dmark+1)  
2d4b 32 69 fe			ld (debug_mark+1),a  
2d4e 3a 58 2d			ld a, (.dmark+2)  
2d51 32 6a fe			ld (debug_mark+2),a  
2d54 18 03			jr .pastdmark  
2d56 ..			.dmark: db "MON"  
2d59 f1			.pastdmark: pop af  
2d5a			endm  
# End of macro DMARK
2d5a						CALLMONITOR 
2d5a cd 6c fe			call debug_vector  
2d5d				endm  
# End of macro CALLMONITOR
2d5d					endif 
2d5d			;		ld a, 0 
2d5d			;		ld (os_view_disable), a 
2d5d cd 36 1a				call bp_on 
2d60			 
2d60					CALLMONITOR 
2d60 cd 6c fe			call debug_vector  
2d63				endm  
# End of macro CALLMONITOR
2d63			 
2d63			;	call monitor 
2d63			 
2d63					NEXTW 
2d63 c3 b1 24			jp macro_next 
2d66				endm 
# End of macro NEXTW
2d66			 
2d66			 
2d66			.MALLOC: 
2d66				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2d66 56				db WORD_SYS_CORE+66             
2d67 8f 2d			dw .MALLOC2            
2d69 06				db 5 + 1 
2d6a .. 00			db "ALLOT",0              
2d70				endm 
# End of macro CWHEAD
2d70			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2d70					if DEBUG_FORTH_WORDS_KEY 
2d70						DMARK "ALL" 
2d70 f5				push af  
2d71 3a 85 2d			ld a, (.dmark)  
2d74 32 68 fe			ld (debug_mark),a  
2d77 3a 86 2d			ld a, (.dmark+1)  
2d7a 32 69 fe			ld (debug_mark+1),a  
2d7d 3a 87 2d			ld a, (.dmark+2)  
2d80 32 6a fe			ld (debug_mark+2),a  
2d83 18 03			jr .pastdmark  
2d85 ..			.dmark: db "ALL"  
2d88 f1			.pastdmark: pop af  
2d89			endm  
# End of macro DMARK
2d89						CALLMONITOR 
2d89 cd 6c fe			call debug_vector  
2d8c				endm  
# End of macro CALLMONITOR
2d8c					endif 
2d8c c3 b6 2d				jp .mallocc 
2d8f			.MALLOC2: 
2d8f				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2d8f 56				db WORD_SYS_CORE+66             
2d90 cd 2d			dw .FREE            
2d92 07				db 6 + 1 
2d93 .. 00			db "MALLOC",0              
2d9a				endm 
# End of macro CWHEAD
2d9a			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2d9a					; get byte count 
2d9a					if DEBUG_FORTH_WORDS_KEY 
2d9a						DMARK "MAL" 
2d9a f5				push af  
2d9b 3a af 2d			ld a, (.dmark)  
2d9e 32 68 fe			ld (debug_mark),a  
2da1 3a b0 2d			ld a, (.dmark+1)  
2da4 32 69 fe			ld (debug_mark+1),a  
2da7 3a b1 2d			ld a, (.dmark+2)  
2daa 32 6a fe			ld (debug_mark+2),a  
2dad 18 03			jr .pastdmark  
2daf ..			.dmark: db "MAL"  
2db2 f1			.pastdmark: pop af  
2db3			endm  
# End of macro DMARK
2db3						CALLMONITOR 
2db3 cd 6c fe			call debug_vector  
2db6				endm  
# End of macro CALLMONITOR
2db6					endif 
2db6			.mallocc: 
2db6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2db6 cd fb 22			call macro_dsp_valuehl 
2db9				endm 
# End of macro FORTH_DSP_VALUEHL
2db9			 
2db9			;		push hl 
2db9			 
2db9					; destroy value TOS 
2db9			 
2db9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2db9 cd b3 23			call macro_forth_dsp_pop 
2dbc				endm 
# End of macro FORTH_DSP_POP
2dbc			 
2dbc			;		pop hl 
2dbc cd 97 14				call malloc 
2dbf				if DEBUG_FORTH_MALLOC_GUARD 
2dbf f5					push af 
2dc0 cd f9 0f				call ishlzero 
2dc3			;		ld a, l 
2dc3			;		add h 
2dc3			;		cp 0 
2dc3 f1					pop af 
2dc4					 
2dc4 cc 03 5e				call z,malloc_error 
2dc7				endif 
2dc7			 
2dc7 cd 04 21				call forth_push_numhl 
2dca					NEXTW 
2dca c3 b1 24			jp macro_next 
2dcd				endm 
# End of macro NEXTW
2dcd			 
2dcd			.FREE: 
2dcd				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2dcd 57				db WORD_SYS_CORE+67             
2dce fe 2d			dw .LIST            
2dd0 05				db 4 + 1 
2dd1 .. 00			db "FREE",0              
2dd6				endm 
# End of macro CWHEAD
2dd6			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2dd6					if DEBUG_FORTH_WORDS_KEY 
2dd6						DMARK "FRE" 
2dd6 f5				push af  
2dd7 3a eb 2d			ld a, (.dmark)  
2dda 32 68 fe			ld (debug_mark),a  
2ddd 3a ec 2d			ld a, (.dmark+1)  
2de0 32 69 fe			ld (debug_mark+1),a  
2de3 3a ed 2d			ld a, (.dmark+2)  
2de6 32 6a fe			ld (debug_mark+2),a  
2de9 18 03			jr .pastdmark  
2deb ..			.dmark: db "FRE"  
2dee f1			.pastdmark: pop af  
2def			endm  
# End of macro DMARK
2def						CALLMONITOR 
2def cd 6c fe			call debug_vector  
2df2				endm  
# End of macro CALLMONITOR
2df2					endif 
2df2					; get address 
2df2			 
2df2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2df2 cd fb 22			call macro_dsp_valuehl 
2df5				endm 
# End of macro FORTH_DSP_VALUEHL
2df5			 
2df5			;		push hl 
2df5			 
2df5					; destroy value TOS 
2df5			 
2df5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2df5 cd b3 23			call macro_forth_dsp_pop 
2df8				endm 
# End of macro FORTH_DSP_POP
2df8			 
2df8			;		pop hl 
2df8			if FORTH_ENABLE_MALLOCFREE 
2df8 cd 61 15				call free 
2dfb			endif 
2dfb					NEXTW 
2dfb c3 b1 24			jp macro_next 
2dfe				endm 
# End of macro NEXTW
2dfe			.LIST: 
2dfe				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2dfe 5c				db WORD_SYS_CORE+72             
2dff ec 2f			dw .FORGET            
2e01 05				db 4 + 1 
2e02 .. 00			db "LIST",0              
2e07				endm 
# End of macro CWHEAD
2e07			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2e07			; | | The quoted word must be in upper case. 
2e07				if DEBUG_FORTH_WORDS_KEY 
2e07					DMARK "LST" 
2e07 f5				push af  
2e08 3a 1c 2e			ld a, (.dmark)  
2e0b 32 68 fe			ld (debug_mark),a  
2e0e 3a 1d 2e			ld a, (.dmark+1)  
2e11 32 69 fe			ld (debug_mark+1),a  
2e14 3a 1e 2e			ld a, (.dmark+2)  
2e17 32 6a fe			ld (debug_mark+2),a  
2e1a 18 03			jr .pastdmark  
2e1c ..			.dmark: db "LST"  
2e1f f1			.pastdmark: pop af  
2e20			endm  
# End of macro DMARK
2e20					CALLMONITOR 
2e20 cd 6c fe			call debug_vector  
2e23				endm  
# End of macro CALLMONITOR
2e23				endif 
2e23			 
2e23					FORTH_DSP_VALUEHL 
2e23 cd fb 22			call macro_dsp_valuehl 
2e26				endm 
# End of macro FORTH_DSP_VALUEHL
2e26			 
2e26 e5					push hl 
2e27					FORTH_DSP_POP 
2e27 cd b3 23			call macro_forth_dsp_pop 
2e2a				endm 
# End of macro FORTH_DSP_POP
2e2a c1					pop bc 
2e2b			 
2e2b			; Start format of scratch string 
2e2b			 
2e2b 21 be f1				ld hl, scratch 
2e2e			 
2e2e 3e 3a				ld a, ':' 
2e30 77					ld (hl),a 
2e31 23					inc hl 
2e32 3e 20				ld a, ' ' 
2e34 77					ld (hl), a 
2e35			 
2e35					; Get ptr to the word we need to look up 
2e35			 
2e35			;		FORTH_DSP_VALUEHL 
2e35					;v5 FORTH_DSP_VALUE 
2e35				; TODO type check 
2e35			;		inc hl    ; Skip type check  
2e35			;		push hl 
2e35			;		ex de, hl    ; put into DE 
2e35			 
2e35			 
2e35 21 00 80				ld hl, baseram 
2e38					;ld hl, baseusermem 
2e38			 
2e38 e5			push hl   ; sacreifical push 
2e39			 
2e39			.ldouscanm: 
2e39 e1				pop hl 
2e3a			.ldouscan: 
2e3a				if DEBUG_FORTH_WORDS 
2e3a					DMARK "LSs" 
2e3a f5				push af  
2e3b 3a 4f 2e			ld a, (.dmark)  
2e3e 32 68 fe			ld (debug_mark),a  
2e41 3a 50 2e			ld a, (.dmark+1)  
2e44 32 69 fe			ld (debug_mark+1),a  
2e47 3a 51 2e			ld a, (.dmark+2)  
2e4a 32 6a fe			ld (debug_mark+2),a  
2e4d 18 03			jr .pastdmark  
2e4f ..			.dmark: db "LSs"  
2e52 f1			.pastdmark: pop af  
2e53			endm  
# End of macro DMARK
2e53					CALLMONITOR 
2e53 cd 6c fe			call debug_vector  
2e56				endm  
# End of macro CALLMONITOR
2e56				endif 
2e56				; skip dict stub 
2e56 cd 02 26				call forth_tok_next 
2e59			 
2e59			 
2e59			; while we have words to look for 
2e59			 
2e59 7e				ld a, (hl)      
2e5a				if DEBUG_FORTH_WORDS 
2e5a					DMARK "LSk" 
2e5a f5				push af  
2e5b 3a 6f 2e			ld a, (.dmark)  
2e5e 32 68 fe			ld (debug_mark),a  
2e61 3a 70 2e			ld a, (.dmark+1)  
2e64 32 69 fe			ld (debug_mark+1),a  
2e67 3a 71 2e			ld a, (.dmark+2)  
2e6a 32 6a fe			ld (debug_mark+2),a  
2e6d 18 03			jr .pastdmark  
2e6f ..			.dmark: db "LSk"  
2e72 f1			.pastdmark: pop af  
2e73			endm  
# End of macro DMARK
2e73					CALLMONITOR 
2e73 cd 6c fe			call debug_vector  
2e76				endm  
# End of macro CALLMONITOR
2e76				endif 
2e76					;cp WORD_SYS_END 
2e76					;jp z, .lunotfound 
2e76			 
2e76					; if we hit non uwords then gone too far 
2e76 fe 01				cp WORD_SYS_UWORD 
2e78 c2 a8 2f				jp nz, .lunotfound 
2e7b			 
2e7b				if DEBUG_FORTH_WORDS 
2e7b					DMARK "LSu" 
2e7b f5				push af  
2e7c 3a 90 2e			ld a, (.dmark)  
2e7f 32 68 fe			ld (debug_mark),a  
2e82 3a 91 2e			ld a, (.dmark+1)  
2e85 32 69 fe			ld (debug_mark+1),a  
2e88 3a 92 2e			ld a, (.dmark+2)  
2e8b 32 6a fe			ld (debug_mark+2),a  
2e8e 18 03			jr .pastdmark  
2e90 ..			.dmark: db "LSu"  
2e93 f1			.pastdmark: pop af  
2e94			endm  
# End of macro DMARK
2e94					CALLMONITOR 
2e94 cd 6c fe			call debug_vector  
2e97				endm  
# End of macro CALLMONITOR
2e97				endif 
2e97			 
2e97					; found a uword but is it the one we want... 
2e97			 
2e97 c5					push bc     ; uword to find is on bc 
2e98 d1					pop de 
2e99			 
2e99 e5					push hl  ; to save the ptr 
2e9a			 
2e9a					; skip opcode 
2e9a 23					inc hl  
2e9b					; skip next ptr 
2e9b 23					inc hl  
2e9c 23					inc hl 
2e9d					; skip len 
2e9d 23					inc hl 
2e9e			 
2e9e				if DEBUG_FORTH_WORDS 
2e9e					DMARK "LSc" 
2e9e f5				push af  
2e9f 3a b3 2e			ld a, (.dmark)  
2ea2 32 68 fe			ld (debug_mark),a  
2ea5 3a b4 2e			ld a, (.dmark+1)  
2ea8 32 69 fe			ld (debug_mark+1),a  
2eab 3a b5 2e			ld a, (.dmark+2)  
2eae 32 6a fe			ld (debug_mark+2),a  
2eb1 18 03			jr .pastdmark  
2eb3 ..			.dmark: db "LSc"  
2eb6 f1			.pastdmark: pop af  
2eb7			endm  
# End of macro DMARK
2eb7					CALLMONITOR 
2eb7 cd 6c fe			call debug_vector  
2eba				endm  
# End of macro CALLMONITOR
2eba				endif 
2eba cd 66 14				call strcmp 
2ebd c2 39 2e				jp nz, .ldouscanm 
2ec0				 
2ec0			 
2ec0			 
2ec0					; we have a uword so push its name to the stack 
2ec0			 
2ec0			;	   	push hl  ; save so we can move to next dict block 
2ec0 e1			pop hl 
2ec1			 
2ec1				if DEBUG_FORTH_WORDS 
2ec1					DMARK "LSm" 
2ec1 f5				push af  
2ec2 3a d6 2e			ld a, (.dmark)  
2ec5 32 68 fe			ld (debug_mark),a  
2ec8 3a d7 2e			ld a, (.dmark+1)  
2ecb 32 69 fe			ld (debug_mark+1),a  
2ece 3a d8 2e			ld a, (.dmark+2)  
2ed1 32 6a fe			ld (debug_mark+2),a  
2ed4 18 03			jr .pastdmark  
2ed6 ..			.dmark: db "LSm"  
2ed9 f1			.pastdmark: pop af  
2eda			endm  
# End of macro DMARK
2eda					CALLMONITOR 
2eda cd 6c fe			call debug_vector  
2edd				endm  
# End of macro CALLMONITOR
2edd				endif 
2edd			 
2edd					; skip opcode 
2edd 23					inc hl  
2ede					; skip next ptr 
2ede 23					inc hl  
2edf 23					inc hl 
2ee0					; skip len 
2ee0 7e					ld a, (hl)   ; save length to add 
2ee1				if DEBUG_FORTH_WORDS 
2ee1					DMARK "LS2" 
2ee1 f5				push af  
2ee2 3a f6 2e			ld a, (.dmark)  
2ee5 32 68 fe			ld (debug_mark),a  
2ee8 3a f7 2e			ld a, (.dmark+1)  
2eeb 32 69 fe			ld (debug_mark+1),a  
2eee 3a f8 2e			ld a, (.dmark+2)  
2ef1 32 6a fe			ld (debug_mark+2),a  
2ef4 18 03			jr .pastdmark  
2ef6 ..			.dmark: db "LS2"  
2ef9 f1			.pastdmark: pop af  
2efa			endm  
# End of macro DMARK
2efa					CALLMONITOR 
2efa cd 6c fe			call debug_vector  
2efd				endm  
# End of macro CALLMONITOR
2efd				endif 
2efd			 
2efd					; save this location 
2efd				 
2efd e5					push hl 
2efe			 
2efe 23					inc hl 
2eff 11 c0 f1				ld de, scratch+2 
2f02 4f					ld c, a 
2f03 06 00				ld b, 0 
2f05			 
2f05				if DEBUG_FORTH_WORDS 
2f05					DMARK "LSn" 
2f05 f5				push af  
2f06 3a 1a 2f			ld a, (.dmark)  
2f09 32 68 fe			ld (debug_mark),a  
2f0c 3a 1b 2f			ld a, (.dmark+1)  
2f0f 32 69 fe			ld (debug_mark+1),a  
2f12 3a 1c 2f			ld a, (.dmark+2)  
2f15 32 6a fe			ld (debug_mark+2),a  
2f18 18 03			jr .pastdmark  
2f1a ..			.dmark: db "LSn"  
2f1d f1			.pastdmark: pop af  
2f1e			endm  
# End of macro DMARK
2f1e					CALLMONITOR 
2f1e cd 6c fe			call debug_vector  
2f21				endm  
# End of macro CALLMONITOR
2f21				endif 
2f21			 
2f21					; copy uword name to scratch 
2f21			 
2f21 ed b0				ldir 
2f23			 
2f23 1b					dec de 
2f24 3e 20				ld a, ' '    ; change null to space 
2f26 12					ld (de), a 
2f27			 
2f27 13					inc de 
2f28			 
2f28 d5					push de 
2f29 c1					pop bc     ; move scratch pointer to end of word name and save it 
2f2a			 
2f2a e1					pop hl 
2f2b 7e					ld a, (hl) 
2f2c					;inc hl 
2f2c					; skip word string 
2f2c cd d0 0f				call addatohl 
2f2f			 
2f2f 23					inc hl 
2f30			 
2f30				if DEBUG_FORTH_WORDS 
2f30					DMARK "LS3" 
2f30 f5				push af  
2f31 3a 45 2f			ld a, (.dmark)  
2f34 32 68 fe			ld (debug_mark),a  
2f37 3a 46 2f			ld a, (.dmark+1)  
2f3a 32 69 fe			ld (debug_mark+1),a  
2f3d 3a 47 2f			ld a, (.dmark+2)  
2f40 32 6a fe			ld (debug_mark+2),a  
2f43 18 03			jr .pastdmark  
2f45 ..			.dmark: db "LS3"  
2f48 f1			.pastdmark: pop af  
2f49			endm  
# End of macro DMARK
2f49					CALLMONITOR 
2f49 cd 6c fe			call debug_vector  
2f4c				endm  
# End of macro CALLMONITOR
2f4c				endif 
2f4c					; should now be at the start of the machine code to setup the eval of the uword 
2f4c					; now locate the ptr to the string defintion 
2f4c			 
2f4c					; skip ld hl, 
2f4c					; then load the ptr 
2f4c			; TODO use get from hl ptr 
2f4c 23					inc hl 
2f4d 5e					ld e, (hl) 
2f4e 23					inc hl 
2f4f 56					ld d, (hl) 
2f50 eb					ex de, hl 
2f51			 
2f51			 
2f51				if DEBUG_FORTH_WORDS 
2f51					DMARK "LSt" 
2f51 f5				push af  
2f52 3a 66 2f			ld a, (.dmark)  
2f55 32 68 fe			ld (debug_mark),a  
2f58 3a 67 2f			ld a, (.dmark+1)  
2f5b 32 69 fe			ld (debug_mark+1),a  
2f5e 3a 68 2f			ld a, (.dmark+2)  
2f61 32 6a fe			ld (debug_mark+2),a  
2f64 18 03			jr .pastdmark  
2f66 ..			.dmark: db "LSt"  
2f69 f1			.pastdmark: pop af  
2f6a			endm  
# End of macro DMARK
2f6a					CALLMONITOR 
2f6a cd 6c fe			call debug_vector  
2f6d				endm  
# End of macro CALLMONITOR
2f6d				endif 
2f6d			 
2f6d			; cant push right now due to tokenised strings  
2f6d			 
2f6d			; get the destination of where to copy this definition to. 
2f6d			 
2f6d c5					push bc 
2f6e d1					pop de 
2f6f			 
2f6f 7e			.listl:         ld a,(hl) 
2f70 fe 00				cp 0 
2f72 28 09				jr z, .lreplsp     ; replace zero with space 
2f74					;cp FORTH_END_BUFFER 
2f74 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2f76 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2f78				 
2f78					; just copy this char as is then 
2f78			 
2f78 12					ld (de), a 
2f79			 
2f79 23			.listnxt:	inc hl 
2f7a 13					inc de 
2f7b 18 f2				jr .listl 
2f7d			 
2f7d 3e 20		.lreplsp:	ld a,' ' 
2f7f 12					ld (de), a 
2f80 18 f7				jr .listnxt 
2f82			 
2f82			; close up uword def 
2f82			 
2f82			.listdone: 
2f82 12					ld (de), a 
2f83 13					inc de 
2f84 3e 00				ld a, 0 
2f86 12					ld (de), a 
2f87			 
2f87			; now have def so clean up and push to stack 
2f87			 
2f87 21 be f1				ld hl, scratch 
2f8a				if DEBUG_FORTH_WORDS 
2f8a					DMARK "Ltp" 
2f8a f5				push af  
2f8b 3a 9f 2f			ld a, (.dmark)  
2f8e 32 68 fe			ld (debug_mark),a  
2f91 3a a0 2f			ld a, (.dmark+1)  
2f94 32 69 fe			ld (debug_mark+1),a  
2f97 3a a1 2f			ld a, (.dmark+2)  
2f9a 32 6a fe			ld (debug_mark+2),a  
2f9d 18 03			jr .pastdmark  
2f9f ..			.dmark: db "Ltp"  
2fa2 f1			.pastdmark: pop af  
2fa3			endm  
# End of macro DMARK
2fa3					CALLMONITOR 
2fa3 cd 6c fe			call debug_vector  
2fa6				endm  
# End of macro CALLMONITOR
2fa6				endif 
2fa6			 
2fa6 18 1f			jr .listpush 
2fa8			 
2fa8			;.lnuword:	pop hl 
2fa8			;		call forth_tok_next 
2fa8			;		jp .ldouscan  
2fa8			 
2fa8			.lunotfound:		  
2fa8			 
2fa8				if DEBUG_FORTH_WORDS 
2fa8					DMARK "LSn" 
2fa8 f5				push af  
2fa9 3a bd 2f			ld a, (.dmark)  
2fac 32 68 fe			ld (debug_mark),a  
2faf 3a be 2f			ld a, (.dmark+1)  
2fb2 32 69 fe			ld (debug_mark+1),a  
2fb5 3a bf 2f			ld a, (.dmark+2)  
2fb8 32 6a fe			ld (debug_mark+2),a  
2fbb 18 03			jr .pastdmark  
2fbd ..			.dmark: db "LSn"  
2fc0 f1			.pastdmark: pop af  
2fc1			endm  
# End of macro DMARK
2fc1					CALLMONITOR 
2fc1 cd 6c fe			call debug_vector  
2fc4				endm  
# End of macro CALLMONITOR
2fc4				endif 
2fc4			 
2fc4					 
2fc4			;		FORTH_DSP_POP 
2fc4			;		ld hl, .luno 
2fc4			 
2fc4					NEXTW			 
2fc4 c3 b1 24			jp macro_next 
2fc7				endm 
# End of macro NEXTW
2fc7			 
2fc7			.listpush: 
2fc7				if DEBUG_FORTH_WORDS 
2fc7					DMARK "LS>" 
2fc7 f5				push af  
2fc8 3a dc 2f			ld a, (.dmark)  
2fcb 32 68 fe			ld (debug_mark),a  
2fce 3a dd 2f			ld a, (.dmark+1)  
2fd1 32 69 fe			ld (debug_mark+1),a  
2fd4 3a de 2f			ld a, (.dmark+2)  
2fd7 32 6a fe			ld (debug_mark+2),a  
2fda 18 03			jr .pastdmark  
2fdc ..			.dmark: db "LS>"  
2fdf f1			.pastdmark: pop af  
2fe0			endm  
# End of macro DMARK
2fe0					CALLMONITOR 
2fe0 cd 6c fe			call debug_vector  
2fe3				endm  
# End of macro CALLMONITOR
2fe3				endif 
2fe3 cd 72 21				call forth_push_str 
2fe6			 
2fe6			 
2fe6			 
2fe6					NEXTW 
2fe6 c3 b1 24			jp macro_next 
2fe9				endm 
# End of macro NEXTW
2fe9			 
2fe9			;.luno:    db "Word not found",0 
2fe9			 
2fe9			 
2fe9			 
2fe9			 
2fe9			 
2fe9			;		push hl   ; save pointer to start of uword def string 
2fe9			; 
2fe9			;; look for FORTH_EOL_LINE 
2fe9			;		ld a, FORTH_END_BUFFER 
2fe9			;		call strlent 
2fe9			; 
2fe9			;		inc hl		 ; space for coln def 
2fe9			;		inc hl 
2fe9			;		inc hl          ; space for terms 
2fe9			;		inc hl 
2fe9			; 
2fe9			;		ld a, 20   ; TODO get actual length 
2fe9			;		call addatohl    ; include a random amount of room for the uword name 
2fe9			; 
2fe9			;		 
2fe9			;	if DEBUG_FORTH_WORDS 
2fe9			;		DMARK "Lt1" 
2fe9			;		CALLMONITOR 
2fe9			;	endif 
2fe9			;		 
2fe9			; 
2fe9			;; malloc space for the string because we cant change it 
2fe9			; 
2fe9			;		call malloc 
2fe9			;	if DEBUG_FORTH_MALLOC_GUARD 
2fe9			;		push af 
2fe9			;		call ishlzero 
2fe9			;		pop af 
2fe9			;		 
2fe9			;		call z,malloc_error 
2fe9			;	endif 
2fe9			; 
2fe9			;	if DEBUG_FORTH_WORDS 
2fe9			;		DMARK "Lt2" 
2fe9			;		CALLMONITOR 
2fe9			;	endif 
2fe9			;		pop de 
2fe9			;		push hl    ; push the malloc to release later 
2fe9			;		push hl   ;  push back a copy for the later stack push 
2fe9			;		 
2fe9			;; copy the string swapping out the zero terms for spaces 
2fe9			; 
2fe9			;		; de has our source 
2fe9			;		; hl has our dest 
2fe9			; 
2fe9			;; add the coln def 
2fe9			; 
2fe9			;		ld a, ':' 
2fe9			;		ld (hl), a 
2fe9			;		inc hl 
2fe9			;		ld a, ' ' 
2fe9			;		ld (hl), a 
2fe9			;		inc hl 
2fe9			; 
2fe9			;; add the uname word 
2fe9			;		push de   ; save our string for now 
2fe9			;		ex de, hl 
2fe9			; 
2fe9			;		FORTH_DSP_VALUE 
2fe9			;		;v5 FORTH_DSP_VALUE 
2fe9			; 
2fe9			;		inc hl   ; skip type but we know by now this is OK 
2fe9			; 
2fe9			;.luword:	ld a,(hl) 
2fe9			;		cp 0 
2fe9			;		jr z, .luword2 
2fe9			;		ld (de), a 
2fe9			;		inc de 
2fe9			;		inc hl 
2fe9			;		jr .luword 
2fe9			; 
2fe9			;.luword2:	ld a, ' ' 
2fe9			;		ld (de), a 
2fe9			;;		inc hl 
2fe9			;;		inc de 
2fe9			;;		ld (de), a 
2fe9			;;		inc hl 
2fe9			;		inc de 
2fe9			; 
2fe9			;		ex de, hl 
2fe9			;		pop de 
2fe9			;		 
2fe9			;		 
2fe9			; 
2fe9			;; detoken that string and copy it 
2fe9			; 
2fe9			;	if DEBUG_FORTH_WORDS 
2fe9			;		DMARK "Lt2" 
2fe9			;		CALLMONITOR 
2fe9			;	endif 
2fe9			;.ldetok:	ld a, (de) 
2fe9			;		cp FORTH_END_BUFFER 
2fe9			;		jr z, .ldetokend 
2fe9			;		; swap out any zero term for space 
2fe9			;		cp 0 
2fe9			;		jr nz, .ldetoknext 
2fe9			;		ld a, ' ' 
2fe9			; 
2fe9			;	if DEBUG_FORTH_WORDS 
2fe9			;		DMARK "LtS" 
2fe9			;		CALLMONITOR 
2fe9			;	endif 
2fe9			;.ldetoknext:	ld (hl), a 
2fe9			;		inc de 
2fe9			;		inc hl 
2fe9			;		jr .ldetok 
2fe9			; 
2fe9			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2fe9			;		ld (hl), a  
2fe9			; 
2fe9			;; free that temp malloc 
2fe9			; 
2fe9			;		pop hl    
2fe9			; 
2fe9			;	if DEBUG_FORTH_WORDS 
2fe9			;		DMARK "Lt4" 
2fe9			;		CALLMONITOR 
2fe9			;	endif 
2fe9			;		call forth_apushstrhl 
2fe9			; 
2fe9			;		; get rid of temp malloc area 
2fe9			; 
2fe9			;		pop hl 
2fe9			;		call free 
2fe9			; 
2fe9			;		jr .ludone 
2fe9			; 
2fe9			;.lnuword:	pop hl 
2fe9			;		call forth_tok_next 
2fe9			;		jp .ldouscan  
2fe9			; 
2fe9			;.ludone:		 pop hl 
2fe9			; 
2fe9					NEXTW 
2fe9 c3 b1 24			jp macro_next 
2fec				endm 
# End of macro NEXTW
2fec			 
2fec			.FORGET: 
2fec				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2fec 5d				db WORD_SYS_CORE+73             
2fed 65 30			dw .NOP            
2fef 07				db 6 + 1 
2ff0 .. 00			db "FORGET",0              
2ff7				endm 
# End of macro CWHEAD
2ff7			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2ff7			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2ff7			; | |  
2ff7			; | | e.g. "MORE" forget 
2ff7					if DEBUG_FORTH_WORDS_KEY 
2ff7						DMARK "FRG" 
2ff7 f5				push af  
2ff8 3a 0c 30			ld a, (.dmark)  
2ffb 32 68 fe			ld (debug_mark),a  
2ffe 3a 0d 30			ld a, (.dmark+1)  
3001 32 69 fe			ld (debug_mark+1),a  
3004 3a 0e 30			ld a, (.dmark+2)  
3007 32 6a fe			ld (debug_mark+2),a  
300a 18 03			jr .pastdmark  
300c ..			.dmark: db "FRG"  
300f f1			.pastdmark: pop af  
3010			endm  
# End of macro DMARK
3010						CALLMONITOR 
3010 cd 6c fe			call debug_vector  
3013				endm  
# End of macro CALLMONITOR
3013					endif 
3013			 
3013				; find uword 
3013			        ; update start of word with "_" 
3013				; replace uword with deleted flag 
3013			 
3013			 
3013			;	if DEBUG_FORTH_WORDS 
3013			;		DMARK "FOG" 
3013			;		CALLMONITOR 
3013			;	endif 
3013			 
3013			 
3013					; Get ptr to the word we need to look up 
3013			 
3013					FORTH_DSP_VALUEHL 
3013 cd fb 22			call macro_dsp_valuehl 
3016				endm 
# End of macro FORTH_DSP_VALUEHL
3016					;v5 FORTH_DSP_VALUE 
3016				; TODO type check 
3016			;		inc hl    ; Skip type check  
3016 e5					push hl 
3017 c1					pop bc 
3018			;		ex de, hl    ; put into DE 
3018			 
3018			 
3018 21 00 80				ld hl, baseram 
301b					;ld hl, baseusermem 
301b			 
301b				; skip dict stub 
301b			;	call forth_tok_next 
301b e5			push hl   ; sacreifical push 
301c			 
301c			.fldouscanm: 
301c e1				pop hl 
301d			.fldouscan: 
301d			;	if DEBUG_FORTH_WORDS 
301d			;		DMARK "LSs" 
301d			;		CALLMONITOR 
301d			;	endif 
301d				; skip dict stub 
301d cd 02 26				call forth_tok_next 
3020			 
3020			 
3020			; while we have words to look for 
3020			 
3020 7e				ld a, (hl)      
3021			;	if DEBUG_FORTH_WORDS 
3021			;		DMARK "LSk" 
3021			;		CALLMONITOR 
3021			;	endif 
3021 fe 00				cp WORD_SYS_END 
3023 ca 5f 30				jp z, .flunotfound 
3026 fe 01				cp WORD_SYS_UWORD 
3028 c2 1d 30				jp nz, .fldouscan 
302b			 
302b			;	if DEBUG_FORTH_WORDS 
302b			;		DMARK "LSu" 
302b			;		CALLMONITOR 
302b			;	endif 
302b			 
302b					; found a uword but is it the one we want... 
302b			 
302b c5					push bc     ; uword to find is on bc 
302c d1					pop de 
302d			 
302d e5					push hl  ; to save the ptr 
302e			 
302e					; skip opcode 
302e 23					inc hl  
302f					; skip next ptr 
302f 23					inc hl  
3030 23					inc hl 
3031					; skip len 
3031 23					inc hl 
3032			 
3032			;	if DEBUG_FORTH_WORDS 
3032			;		DMARK "LSc" 
3032			;		CALLMONITOR 
3032			;	endif 
3032 cd 66 14				call strcmp 
3035 c2 1c 30				jp nz, .fldouscanm 
3038			; 
3038			; 
3038			;; while we have words to look for 
3038			; 
3038			;.fdouscan:	ld a, (hl)      
3038			;	if DEBUG_FORTH_WORDS 
3038			;		DMARK "LSs" 
3038			;		CALLMONITOR 
3038			;	endif 
3038			;		cp WORD_SYS_END 
3038			;		jp z, .fudone 
3038			;		cp WORD_SYS_UWORD 
3038			;		jp nz, .fnuword 
3038			; 
3038			;	if DEBUG_FORTH_WORDS 
3038			;		DMARK "FGu" 
3038			;		CALLMONITOR 
3038			;	endif 
3038			; 
3038			;		; found a uword but is it the one we want... 
3038			; 
3038			; 
3038			;	        pop de   ; get back the dsp name 
3038			;		push de 
3038			; 
3038			;		push hl  ; to save the ptr 
3038			; 
3038			;		; skip opcode 
3038			;		inc hl  
3038			;		; skip next ptr 
3038			;		inc hl  
3038			;		inc hl 
3038			;		; skip len 
3038			;		inc hl 
3038			; 
3038			;	if DEBUG_FORTH_WORDS 
3038			;		DMARK "FGc" 
3038			;		CALLMONITOR 
3038			;	endif 
3038			;		call strcmp 
3038			;		jp nz, .fnuword 
3038			 
3038			 
3038 e1			pop hl 
3039			 
3039				 
3039				if DEBUG_FORTH_WORDS 
3039					DMARK "FGm" 
3039 f5				push af  
303a 3a 4e 30			ld a, (.dmark)  
303d 32 68 fe			ld (debug_mark),a  
3040 3a 4f 30			ld a, (.dmark+1)  
3043 32 69 fe			ld (debug_mark+1),a  
3046 3a 50 30			ld a, (.dmark+2)  
3049 32 6a fe			ld (debug_mark+2),a  
304c 18 03			jr .pastdmark  
304e ..			.dmark: db "FGm"  
3051 f1			.pastdmark: pop af  
3052			endm  
# End of macro DMARK
3052					CALLMONITOR 
3052 cd 6c fe			call debug_vector  
3055				endm  
# End of macro CALLMONITOR
3055				endif 
3055			 
3055			 
3055			 
3055					; we have a uword so push its name to the stack 
3055			 
3055			;	   	push hl  ; save so we can move to next dict block 
3055			;pop hl 
3055			 
3055					; update opcode to deleted 
3055 3e 03				ld a, WORD_SYS_DELETED 
3057 77					ld (hl), a 
3058			 
3058 23					inc hl  
3059					; skip next ptr 
3059 23					inc hl  
305a 23					inc hl 
305b					; skip len 
305b 23					inc hl 
305c			 
305c					; TODO change parser to skip deleted words but for now mark it out 
305c 3e 5f				ld a, "_" 
305e 77					ld  (hl),a 
305f			 
305f			;		jr .fudone 
305f			; 
305f			;.fnuword:	pop hl 
305f			;		call forth_tok_next 
305f			;		jp .fdouscan  
305f			 
305f			.flunotfound:		  
305f			 
305f			 
305f					 
305f					FORTH_DSP_POP 
305f cd b3 23			call macro_forth_dsp_pop 
3062				endm 
# End of macro FORTH_DSP_POP
3062			;		ld hl, .luno 
3062			;.fudone:		 pop hl 
3062					NEXTW 
3062 c3 b1 24			jp macro_next 
3065				endm 
# End of macro NEXTW
3065			.NOP: 
3065				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
3065 61				db WORD_SYS_CORE+77             
3066 8c 30			dw .COMO            
3068 04				db 3 + 1 
3069 .. 00			db "NOP",0              
306d				endm 
# End of macro CWHEAD
306d			; | NOP (  --  ) Do nothing | DONE 
306d					if DEBUG_FORTH_WORDS_KEY 
306d						DMARK "NOP" 
306d f5				push af  
306e 3a 82 30			ld a, (.dmark)  
3071 32 68 fe			ld (debug_mark),a  
3074 3a 83 30			ld a, (.dmark+1)  
3077 32 69 fe			ld (debug_mark+1),a  
307a 3a 84 30			ld a, (.dmark+2)  
307d 32 6a fe			ld (debug_mark+2),a  
3080 18 03			jr .pastdmark  
3082 ..			.dmark: db "NOP"  
3085 f1			.pastdmark: pop af  
3086			endm  
# End of macro DMARK
3086						CALLMONITOR 
3086 cd 6c fe			call debug_vector  
3089				endm  
# End of macro CALLMONITOR
3089					endif 
3089				       NEXTW 
3089 c3 b1 24			jp macro_next 
308c				endm 
# End of macro NEXTW
308c			.COMO: 
308c				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
308c 6e				db WORD_SYS_CORE+90             
308d de 30			dw .COMC            
308f 02				db 1 + 1 
3090 .. 00			db "(",0              
3092				endm 
# End of macro CWHEAD
3092			; | ( ( -- )  Start of comment | DONE 
3092			 
3092			 
3092 2a bf f4				ld hl, ( os_tok_ptr) 
3095 11 d9 30			ld de, .closepar 
3098					 
3098					if DEBUG_FORTH_WORDS 
3098						DMARK ").." 
3098 f5				push af  
3099 3a ad 30			ld a, (.dmark)  
309c 32 68 fe			ld (debug_mark),a  
309f 3a ae 30			ld a, (.dmark+1)  
30a2 32 69 fe			ld (debug_mark+1),a  
30a5 3a af 30			ld a, (.dmark+2)  
30a8 32 6a fe			ld (debug_mark+2),a  
30ab 18 03			jr .pastdmark  
30ad ..			.dmark: db ").."  
30b0 f1			.pastdmark: pop af  
30b1			endm  
# End of macro DMARK
30b1						CALLMONITOR 
30b1 cd 6c fe			call debug_vector  
30b4				endm  
# End of macro CALLMONITOR
30b4					endif 
30b4 cd cc 25			call findnexttok  
30b7			 
30b7					if DEBUG_FORTH_WORDS 
30b7						DMARK "IF5" 
30b7 f5				push af  
30b8 3a cc 30			ld a, (.dmark)  
30bb 32 68 fe			ld (debug_mark),a  
30be 3a cd 30			ld a, (.dmark+1)  
30c1 32 69 fe			ld (debug_mark+1),a  
30c4 3a ce 30			ld a, (.dmark+2)  
30c7 32 6a fe			ld (debug_mark+2),a  
30ca 18 03			jr .pastdmark  
30cc ..			.dmark: db "IF5"  
30cf f1			.pastdmark: pop af  
30d0			endm  
# End of macro DMARK
30d0						CALLMONITOR 
30d0 cd 6c fe			call debug_vector  
30d3				endm  
# End of macro CALLMONITOR
30d3					endif 
30d3				; replace below with ) exec using tok_ptr 
30d3 22 bf f4			ld (os_tok_ptr), hl 
30d6 c3 42 25			jp exec1 
30d9			 
30d9 .. 00			.closepar:   db ")",0 
30db			 
30db				       NEXTW 
30db c3 b1 24			jp macro_next 
30de				endm 
# End of macro NEXTW
30de			.COMC: 
30de				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
30de 6f				db WORD_SYS_CORE+91             
30df e7 30			dw .SCRATCH            
30e1 02				db 1 + 1 
30e2 .. 00			db ")",0              
30e4				endm 
# End of macro CWHEAD
30e4			; | ) ( -- )  End of comment |  DONE  
30e4				       NEXTW 
30e4 c3 b1 24			jp macro_next 
30e7				endm 
# End of macro NEXTW
30e7			 
30e7			.SCRATCH: 
30e7				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
30e7 6f				db WORD_SYS_CORE+91             
30e8 22 31			dw .INC            
30ea 08				db 7 + 1 
30eb .. 00			db "SCRATCH",0              
30f3				endm 
# End of macro CWHEAD
30f3			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
30f3			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
30f3			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
30f3			; | |  
30f3			; | | e.g.    : score $00 scratch ; 
30f3			; | |  
30f3			; | | $00 score ! 
30f3			; | | $01 score +! 
30f3			; | |  
30f3			; | | e.g.   : varword $0a scratch ;  
30f3			; | | 
30f3			; | | $8000 varword ! 
30f3					if DEBUG_FORTH_WORDS_KEY 
30f3						DMARK "SCR" 
30f3 f5				push af  
30f4 3a 08 31			ld a, (.dmark)  
30f7 32 68 fe			ld (debug_mark),a  
30fa 3a 09 31			ld a, (.dmark+1)  
30fd 32 69 fe			ld (debug_mark+1),a  
3100 3a 0a 31			ld a, (.dmark+2)  
3103 32 6a fe			ld (debug_mark+2),a  
3106 18 03			jr .pastdmark  
3108 ..			.dmark: db "SCR"  
310b f1			.pastdmark: pop af  
310c			endm  
# End of macro DMARK
310c						CALLMONITOR 
310c cd 6c fe			call debug_vector  
310f				endm  
# End of macro CALLMONITOR
310f					endif 
310f			 
310f					FORTH_DSP_VALUEHL 
310f cd fb 22			call macro_dsp_valuehl 
3112				endm 
# End of macro FORTH_DSP_VALUEHL
3112				 
3112					FORTH_DSP_POP 
3112 cd b3 23			call macro_forth_dsp_pop 
3115				endm 
# End of macro FORTH_DSP_POP
3115			 
3115 7d					ld a, l 
3116 21 e3 f6				ld hl, os_var_array 
3119 cd d0 0f				call addatohl 
311c			 
311c cd 04 21				call forth_push_numhl 
311f			 
311f				       NEXTW 
311f c3 b1 24			jp macro_next 
3122				endm 
# End of macro NEXTW
3122			 
3122			.INC: 
3122				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
3122 6f				db WORD_SYS_CORE+91             
3123 76 31			dw .DEC            
3125 03				db 2 + 1 
3126 .. 00			db "+!",0              
3129				endm 
# End of macro CWHEAD
3129			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
3129					if DEBUG_FORTH_WORDS_KEY 
3129						DMARK "+s_" 
3129 f5				push af  
312a 3a 3e 31			ld a, (.dmark)  
312d 32 68 fe			ld (debug_mark),a  
3130 3a 3f 31			ld a, (.dmark+1)  
3133 32 69 fe			ld (debug_mark+1),a  
3136 3a 40 31			ld a, (.dmark+2)  
3139 32 6a fe			ld (debug_mark+2),a  
313c 18 03			jr .pastdmark  
313e ..			.dmark: db "+s_"  
3141 f1			.pastdmark: pop af  
3142			endm  
# End of macro DMARK
3142						CALLMONITOR 
3142 cd 6c fe			call debug_vector  
3145				endm  
# End of macro CALLMONITOR
3145					endif 
3145			 
3145					FORTH_DSP_VALUEHL 
3145 cd fb 22			call macro_dsp_valuehl 
3148				endm 
# End of macro FORTH_DSP_VALUEHL
3148			 
3148 e5					push hl   ; save address 
3149			 
3149					FORTH_DSP_POP 
3149 cd b3 23			call macro_forth_dsp_pop 
314c				endm 
# End of macro FORTH_DSP_POP
314c			 
314c					FORTH_DSP_VALUEHL 
314c cd fb 22			call macro_dsp_valuehl 
314f				endm 
# End of macro FORTH_DSP_VALUEHL
314f			 
314f					FORTH_DSP_POP 
314f cd b3 23			call macro_forth_dsp_pop 
3152				endm 
# End of macro FORTH_DSP_POP
3152			 
3152					; hl contains value to add to byte at a 
3152				 
3152 eb					ex de, hl 
3153			 
3153 e1					pop hl 
3154			 
3154					if DEBUG_FORTH_WORDS 
3154						DMARK "INC" 
3154 f5				push af  
3155 3a 69 31			ld a, (.dmark)  
3158 32 68 fe			ld (debug_mark),a  
315b 3a 6a 31			ld a, (.dmark+1)  
315e 32 69 fe			ld (debug_mark+1),a  
3161 3a 6b 31			ld a, (.dmark+2)  
3164 32 6a fe			ld (debug_mark+2),a  
3167 18 03			jr .pastdmark  
3169 ..			.dmark: db "INC"  
316c f1			.pastdmark: pop af  
316d			endm  
# End of macro DMARK
316d						CALLMONITOR 
316d cd 6c fe			call debug_vector  
3170				endm  
# End of macro CALLMONITOR
3170					endif 
3170			 
3170 7e					ld a,(hl) 
3171 83					add e 
3172 77					ld (hl),a 
3173			 
3173			 
3173			 
3173				       NEXTW 
3173 c3 b1 24			jp macro_next 
3176				endm 
# End of macro NEXTW
3176			 
3176			.DEC: 
3176				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
3176 6f				db WORD_SYS_CORE+91             
3177 c7 31			dw .INC2            
3179 03				db 2 + 1 
317a .. 00			db "-!",0              
317d				endm 
# End of macro CWHEAD
317d			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
317d					if DEBUG_FORTH_WORDS_KEY 
317d						DMARK "-s_" 
317d f5				push af  
317e 3a 92 31			ld a, (.dmark)  
3181 32 68 fe			ld (debug_mark),a  
3184 3a 93 31			ld a, (.dmark+1)  
3187 32 69 fe			ld (debug_mark+1),a  
318a 3a 94 31			ld a, (.dmark+2)  
318d 32 6a fe			ld (debug_mark+2),a  
3190 18 03			jr .pastdmark  
3192 ..			.dmark: db "-s_"  
3195 f1			.pastdmark: pop af  
3196			endm  
# End of macro DMARK
3196						CALLMONITOR 
3196 cd 6c fe			call debug_vector  
3199				endm  
# End of macro CALLMONITOR
3199					endif 
3199			 
3199					FORTH_DSP_VALUEHL 
3199 cd fb 22			call macro_dsp_valuehl 
319c				endm 
# End of macro FORTH_DSP_VALUEHL
319c			 
319c e5					push hl   ; save address 
319d			 
319d					FORTH_DSP_POP 
319d cd b3 23			call macro_forth_dsp_pop 
31a0				endm 
# End of macro FORTH_DSP_POP
31a0			 
31a0					FORTH_DSP_VALUEHL 
31a0 cd fb 22			call macro_dsp_valuehl 
31a3				endm 
# End of macro FORTH_DSP_VALUEHL
31a3			 
31a3					; hl contains value to add to byte at a 
31a3				 
31a3 eb					ex de, hl 
31a4			 
31a4 e1					pop hl 
31a5			 
31a5					if DEBUG_FORTH_WORDS 
31a5						DMARK "DEC" 
31a5 f5				push af  
31a6 3a ba 31			ld a, (.dmark)  
31a9 32 68 fe			ld (debug_mark),a  
31ac 3a bb 31			ld a, (.dmark+1)  
31af 32 69 fe			ld (debug_mark+1),a  
31b2 3a bc 31			ld a, (.dmark+2)  
31b5 32 6a fe			ld (debug_mark+2),a  
31b8 18 03			jr .pastdmark  
31ba ..			.dmark: db "DEC"  
31bd f1			.pastdmark: pop af  
31be			endm  
# End of macro DMARK
31be						CALLMONITOR 
31be cd 6c fe			call debug_vector  
31c1				endm  
# End of macro CALLMONITOR
31c1					endif 
31c1			 
31c1 7e					ld a,(hl) 
31c2 93					sub e 
31c3 77					ld (hl),a 
31c4			 
31c4			 
31c4			 
31c4				       NEXTW 
31c4 c3 b1 24			jp macro_next 
31c7				endm 
# End of macro NEXTW
31c7			 
31c7			.INC2: 
31c7				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
31c7 6f				db WORD_SYS_CORE+91             
31c8 71 32			dw .DEC2            
31ca 04				db 3 + 1 
31cb .. 00			db "+2!",0              
31cf				endm 
# End of macro CWHEAD
31cf			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
31cf			 
31cf					if DEBUG_FORTH_WORDS_KEY 
31cf						DMARK "+2s" 
31cf f5				push af  
31d0 3a e4 31			ld a, (.dmark)  
31d3 32 68 fe			ld (debug_mark),a  
31d6 3a e5 31			ld a, (.dmark+1)  
31d9 32 69 fe			ld (debug_mark+1),a  
31dc 3a e6 31			ld a, (.dmark+2)  
31df 32 6a fe			ld (debug_mark+2),a  
31e2 18 03			jr .pastdmark  
31e4 ..			.dmark: db "+2s"  
31e7 f1			.pastdmark: pop af  
31e8			endm  
# End of macro DMARK
31e8						CALLMONITOR 
31e8 cd 6c fe			call debug_vector  
31eb				endm  
# End of macro CALLMONITOR
31eb					endif 
31eb			 
31eb					; Address 
31eb			 
31eb					FORTH_DSP_VALUEHL 
31eb cd fb 22			call macro_dsp_valuehl 
31ee				endm 
# End of macro FORTH_DSP_VALUEHL
31ee			 
31ee e5					push hl    ; save address 
31ef			 
31ef					; load content into de 
31ef			 
31ef 5e					ld e,(hl) 
31f0 23					inc hl 
31f1 56					ld d, (hl) 
31f2			 
31f2					if DEBUG_FORTH_WORDS 
31f2						DMARK "+2a" 
31f2 f5				push af  
31f3 3a 07 32			ld a, (.dmark)  
31f6 32 68 fe			ld (debug_mark),a  
31f9 3a 08 32			ld a, (.dmark+1)  
31fc 32 69 fe			ld (debug_mark+1),a  
31ff 3a 09 32			ld a, (.dmark+2)  
3202 32 6a fe			ld (debug_mark+2),a  
3205 18 03			jr .pastdmark  
3207 ..			.dmark: db "+2a"  
320a f1			.pastdmark: pop af  
320b			endm  
# End of macro DMARK
320b						CALLMONITOR 
320b cd 6c fe			call debug_vector  
320e				endm  
# End of macro CALLMONITOR
320e					endif 
320e			 
320e					FORTH_DSP_POP 
320e cd b3 23			call macro_forth_dsp_pop 
3211				endm 
# End of macro FORTH_DSP_POP
3211			 
3211					; Get value to add 
3211			 
3211					FORTH_DSP_VALUE 
3211 cd e4 22			call macro_forth_dsp_value 
3214				endm 
# End of macro FORTH_DSP_VALUE
3214			 
3214					if DEBUG_FORTH_WORDS 
3214						DMARK "+2v" 
3214 f5				push af  
3215 3a 29 32			ld a, (.dmark)  
3218 32 68 fe			ld (debug_mark),a  
321b 3a 2a 32			ld a, (.dmark+1)  
321e 32 69 fe			ld (debug_mark+1),a  
3221 3a 2b 32			ld a, (.dmark+2)  
3224 32 6a fe			ld (debug_mark+2),a  
3227 18 03			jr .pastdmark  
3229 ..			.dmark: db "+2v"  
322c f1			.pastdmark: pop af  
322d			endm  
# End of macro DMARK
322d						CALLMONITOR 
322d cd 6c fe			call debug_vector  
3230				endm  
# End of macro CALLMONITOR
3230					endif 
3230			 
3230 19					add hl, de 
3231			 
3231					if DEBUG_FORTH_WORDS 
3231						DMARK "+2+" 
3231 f5				push af  
3232 3a 46 32			ld a, (.dmark)  
3235 32 68 fe			ld (debug_mark),a  
3238 3a 47 32			ld a, (.dmark+1)  
323b 32 69 fe			ld (debug_mark+1),a  
323e 3a 48 32			ld a, (.dmark+2)  
3241 32 6a fe			ld (debug_mark+2),a  
3244 18 03			jr .pastdmark  
3246 ..			.dmark: db "+2+"  
3249 f1			.pastdmark: pop af  
324a			endm  
# End of macro DMARK
324a						CALLMONITOR 
324a cd 6c fe			call debug_vector  
324d				endm  
# End of macro CALLMONITOR
324d					endif 
324d			 
324d					; move result to de 
324d			 
324d eb					ex de, hl 
324e			 
324e					; Address 
324e			 
324e e1					pop hl 
324f			 
324f					; save it back 
324f			 
324f 73					ld (hl), e 
3250 23					inc hl 
3251 72					ld (hl), d 
3252			 
3252					if DEBUG_FORTH_WORDS 
3252						DMARK "+2e" 
3252 f5				push af  
3253 3a 67 32			ld a, (.dmark)  
3256 32 68 fe			ld (debug_mark),a  
3259 3a 68 32			ld a, (.dmark+1)  
325c 32 69 fe			ld (debug_mark+1),a  
325f 3a 69 32			ld a, (.dmark+2)  
3262 32 6a fe			ld (debug_mark+2),a  
3265 18 03			jr .pastdmark  
3267 ..			.dmark: db "+2e"  
326a f1			.pastdmark: pop af  
326b			endm  
# End of macro DMARK
326b						CALLMONITOR 
326b cd 6c fe			call debug_vector  
326e				endm  
# End of macro CALLMONITOR
326e					endif 
326e			 
326e			 
326e			 
326e			 
326e			 
326e				       NEXTW 
326e c3 b1 24			jp macro_next 
3271				endm 
# End of macro NEXTW
3271			 
3271			.DEC2: 
3271				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
3271 6f				db WORD_SYS_CORE+91             
3272 1d 33			dw .GET2            
3274 04				db 3 + 1 
3275 .. 00			db "-2!",0              
3279				endm 
# End of macro CWHEAD
3279			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
3279			 
3279			 
3279					if DEBUG_FORTH_WORDS_KEY 
3279						DMARK "-2s" 
3279 f5				push af  
327a 3a 8e 32			ld a, (.dmark)  
327d 32 68 fe			ld (debug_mark),a  
3280 3a 8f 32			ld a, (.dmark+1)  
3283 32 69 fe			ld (debug_mark+1),a  
3286 3a 90 32			ld a, (.dmark+2)  
3289 32 6a fe			ld (debug_mark+2),a  
328c 18 03			jr .pastdmark  
328e ..			.dmark: db "-2s"  
3291 f1			.pastdmark: pop af  
3292			endm  
# End of macro DMARK
3292						CALLMONITOR 
3292 cd 6c fe			call debug_vector  
3295				endm  
# End of macro CALLMONITOR
3295					endif 
3295			 
3295					; Address 
3295			 
3295					FORTH_DSP_VALUEHL 
3295 cd fb 22			call macro_dsp_valuehl 
3298				endm 
# End of macro FORTH_DSP_VALUEHL
3298			 
3298 e5					push hl    ; save address 
3299			 
3299					; load content into de 
3299			 
3299 5e					ld e,(hl) 
329a 23					inc hl 
329b 56					ld d, (hl) 
329c			 
329c					if DEBUG_FORTH_WORDS 
329c						DMARK "-2a" 
329c f5				push af  
329d 3a b1 32			ld a, (.dmark)  
32a0 32 68 fe			ld (debug_mark),a  
32a3 3a b2 32			ld a, (.dmark+1)  
32a6 32 69 fe			ld (debug_mark+1),a  
32a9 3a b3 32			ld a, (.dmark+2)  
32ac 32 6a fe			ld (debug_mark+2),a  
32af 18 03			jr .pastdmark  
32b1 ..			.dmark: db "-2a"  
32b4 f1			.pastdmark: pop af  
32b5			endm  
# End of macro DMARK
32b5						CALLMONITOR 
32b5 cd 6c fe			call debug_vector  
32b8				endm  
# End of macro CALLMONITOR
32b8					endif 
32b8			 
32b8					FORTH_DSP_POP 
32b8 cd b3 23			call macro_forth_dsp_pop 
32bb				endm 
# End of macro FORTH_DSP_POP
32bb			 
32bb					; Get value to remove 
32bb			 
32bb					FORTH_DSP_VALUE 
32bb cd e4 22			call macro_forth_dsp_value 
32be				endm 
# End of macro FORTH_DSP_VALUE
32be			 
32be					if DEBUG_FORTH_WORDS 
32be						DMARK "-2v" 
32be f5				push af  
32bf 3a d3 32			ld a, (.dmark)  
32c2 32 68 fe			ld (debug_mark),a  
32c5 3a d4 32			ld a, (.dmark+1)  
32c8 32 69 fe			ld (debug_mark+1),a  
32cb 3a d5 32			ld a, (.dmark+2)  
32ce 32 6a fe			ld (debug_mark+2),a  
32d1 18 03			jr .pastdmark  
32d3 ..			.dmark: db "-2v"  
32d6 f1			.pastdmark: pop af  
32d7			endm  
# End of macro DMARK
32d7						CALLMONITOR 
32d7 cd 6c fe			call debug_vector  
32da				endm  
# End of macro CALLMONITOR
32da					endif 
32da			 
32da eb					ex de, hl 
32db ed 52				sbc hl, de 
32dd			 
32dd					if DEBUG_FORTH_WORDS 
32dd						DMARK "-2d" 
32dd f5				push af  
32de 3a f2 32			ld a, (.dmark)  
32e1 32 68 fe			ld (debug_mark),a  
32e4 3a f3 32			ld a, (.dmark+1)  
32e7 32 69 fe			ld (debug_mark+1),a  
32ea 3a f4 32			ld a, (.dmark+2)  
32ed 32 6a fe			ld (debug_mark+2),a  
32f0 18 03			jr .pastdmark  
32f2 ..			.dmark: db "-2d"  
32f5 f1			.pastdmark: pop af  
32f6			endm  
# End of macro DMARK
32f6						CALLMONITOR 
32f6 cd 6c fe			call debug_vector  
32f9				endm  
# End of macro CALLMONITOR
32f9					endif 
32f9			 
32f9					; move result to de 
32f9			 
32f9 eb					ex de, hl 
32fa			 
32fa					; Address 
32fa			 
32fa e1					pop hl 
32fb			 
32fb					; save it back 
32fb			 
32fb 73					ld (hl), e 
32fc 23					inc hl 
32fd 72					ld (hl), d 
32fe			 
32fe					if DEBUG_FORTH_WORDS 
32fe						DMARK "-2e" 
32fe f5				push af  
32ff 3a 13 33			ld a, (.dmark)  
3302 32 68 fe			ld (debug_mark),a  
3305 3a 14 33			ld a, (.dmark+1)  
3308 32 69 fe			ld (debug_mark+1),a  
330b 3a 15 33			ld a, (.dmark+2)  
330e 32 6a fe			ld (debug_mark+2),a  
3311 18 03			jr .pastdmark  
3313 ..			.dmark: db "-2e"  
3316 f1			.pastdmark: pop af  
3317			endm  
# End of macro DMARK
3317						CALLMONITOR 
3317 cd 6c fe			call debug_vector  
331a				endm  
# End of macro CALLMONITOR
331a					endif 
331a			 
331a			 
331a			 
331a			 
331a			 
331a				       NEXTW 
331a c3 b1 24			jp macro_next 
331d				endm 
# End of macro NEXTW
331d			.GET2: 
331d				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
331d 6f				db WORD_SYS_CORE+91             
331e 4d 33			dw .BANG2            
3320 03				db 2 + 1 
3321 .. 00			db "2@",0              
3324				endm 
# End of macro CWHEAD
3324			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
3324					if DEBUG_FORTH_WORDS_KEY 
3324						DMARK "2A_" 
3324 f5				push af  
3325 3a 39 33			ld a, (.dmark)  
3328 32 68 fe			ld (debug_mark),a  
332b 3a 3a 33			ld a, (.dmark+1)  
332e 32 69 fe			ld (debug_mark+1),a  
3331 3a 3b 33			ld a, (.dmark+2)  
3334 32 6a fe			ld (debug_mark+2),a  
3337 18 03			jr .pastdmark  
3339 ..			.dmark: db "2A_"  
333c f1			.pastdmark: pop af  
333d			endm  
# End of macro DMARK
333d						CALLMONITOR 
333d cd 6c fe			call debug_vector  
3340				endm  
# End of macro CALLMONITOR
3340					endif 
3340			 
3340					FORTH_DSP_VALUEHL 
3340 cd fb 22			call macro_dsp_valuehl 
3343				endm 
# End of macro FORTH_DSP_VALUEHL
3343			 
3343 5e					ld e, (hl) 
3344 23					inc hl 
3345 56					ld d, (hl) 
3346			 
3346 eb					ex de, hl 
3347			 
3347 cd 04 21				call forth_push_numhl 
334a			 
334a				       NEXTW 
334a c3 b1 24			jp macro_next 
334d				endm 
# End of macro NEXTW
334d			.BANG2: 
334d				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
334d 6f				db WORD_SYS_CORE+91             
334e 85 33			dw .CONFIG            
3350 03				db 2 + 1 
3351 .. 00			db "2!",0              
3354				endm 
# End of macro CWHEAD
3354			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
3354					if DEBUG_FORTH_WORDS_KEY 
3354						DMARK "2S_" 
3354 f5				push af  
3355 3a 69 33			ld a, (.dmark)  
3358 32 68 fe			ld (debug_mark),a  
335b 3a 6a 33			ld a, (.dmark+1)  
335e 32 69 fe			ld (debug_mark+1),a  
3361 3a 6b 33			ld a, (.dmark+2)  
3364 32 6a fe			ld (debug_mark+2),a  
3367 18 03			jr .pastdmark  
3369 ..			.dmark: db "2S_"  
336c f1			.pastdmark: pop af  
336d			endm  
# End of macro DMARK
336d						CALLMONITOR 
336d cd 6c fe			call debug_vector  
3370				endm  
# End of macro CALLMONITOR
3370					endif 
3370			 
3370					FORTH_DSP_VALUEHL 
3370 cd fb 22			call macro_dsp_valuehl 
3373				endm 
# End of macro FORTH_DSP_VALUEHL
3373			 
3373 e5					push hl   ; save address 
3374			 
3374			 
3374					FORTH_DSP_POP 
3374 cd b3 23			call macro_forth_dsp_pop 
3377				endm 
# End of macro FORTH_DSP_POP
3377			 
3377					 
3377					FORTH_DSP_VALUEHL 
3377 cd fb 22			call macro_dsp_valuehl 
337a				endm 
# End of macro FORTH_DSP_VALUEHL
337a			 
337a					FORTH_DSP_POP 
337a cd b3 23			call macro_forth_dsp_pop 
337d				endm 
# End of macro FORTH_DSP_POP
337d			 
337d eb					ex de, hl    ; value now in de 
337e			 
337e e1					pop hl 
337f			 
337f 73					ld (hl), e 
3380			 
3380 23					inc hl 
3381			 
3381 72					ld (hl), d 
3382			 
3382			 
3382				       NEXTW 
3382 c3 b1 24			jp macro_next 
3385				endm 
# End of macro NEXTW
3385			.CONFIG: 
3385				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
3385 6f				db WORD_SYS_CORE+91             
3386 96 33			dw .ADTOS            
3388 07				db 6 + 1 
3389 .. 00			db "CONFIG",0              
3390				endm 
# End of macro CWHEAD
3390			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
3390			 
3390 cd 30 16				call config 
3393					NEXTW 
3393 c3 b1 24			jp macro_next 
3396				endm 
# End of macro NEXTW
3396			 
3396			.ADTOS: 
3396				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
3396 6f				db WORD_SYS_CORE+91             
3397 ac 33			dw .SBTOS            
3399 03				db 2 + 1 
339a .. 00			db "1+",0              
339d				endm 
# End of macro CWHEAD
339d			; | 1+ ( u -- u )  Increment value on TOS | DONE 
339d			 
339d					FORTH_DSP_VALUEHL 
339d cd fb 22			call macro_dsp_valuehl 
33a0				endm 
# End of macro FORTH_DSP_VALUEHL
33a0 e5					push hl 
33a1			 
33a1					FORTH_DSP_POP 
33a1 cd b3 23			call macro_forth_dsp_pop 
33a4				endm 
# End of macro FORTH_DSP_POP
33a4 e1					pop hl 
33a5			 
33a5 23					inc hl 
33a6 cd 04 21				call forth_push_numhl 
33a9					 
33a9					NEXTW 
33a9 c3 b1 24			jp macro_next 
33ac				endm 
# End of macro NEXTW
33ac			.SBTOS: 
33ac				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
33ac 6f				db WORD_SYS_CORE+91             
33ad c2 33			dw .ADSTORE            
33af 03				db 2 + 1 
33b0 .. 00			db "1-",0              
33b3				endm 
# End of macro CWHEAD
33b3			; | 1- ( u -- u )  Decrement value on TOS | DONE 
33b3			 
33b3					FORTH_DSP_VALUEHL 
33b3 cd fb 22			call macro_dsp_valuehl 
33b6				endm 
# End of macro FORTH_DSP_VALUEHL
33b6 e5					push hl 
33b7			 
33b7					FORTH_DSP_POP 
33b7 cd b3 23			call macro_forth_dsp_pop 
33ba				endm 
# End of macro FORTH_DSP_POP
33ba e1					pop hl 
33bb			 
33bb 2b					dec hl 
33bc cd 04 21				call forth_push_numhl 
33bf					 
33bf					NEXTW 
33bf c3 b1 24			jp macro_next 
33c2				endm 
# End of macro NEXTW
33c2			.ADSTORE: 
33c2				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
33c2 6f				db WORD_SYS_CORE+91             
33c3 d8 33			dw .ADWSTORE            
33c5 04				db 3 + 1 
33c6 .. 00			db "1+!",0              
33ca				endm 
# End of macro CWHEAD
33ca			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
33ca			 
33ca					FORTH_DSP_VALUEHL 
33ca cd fb 22			call macro_dsp_valuehl 
33cd				endm 
# End of macro FORTH_DSP_VALUEHL
33cd e5					push hl 
33ce			 
33ce					FORTH_DSP_POP 
33ce cd b3 23			call macro_forth_dsp_pop 
33d1				endm 
# End of macro FORTH_DSP_POP
33d1 e1					pop hl 
33d2			 
33d2 7e					ld a, (hl) 
33d3 3c					inc a 
33d4 77					ld (hl), a 
33d5					 
33d5					NEXTW 
33d5 c3 b1 24			jp macro_next 
33d8				endm 
# End of macro NEXTW
33d8			.ADWSTORE: 
33d8				CWHEAD .ENDCORE 91 "1+2!" 4 WORD_FLAG_CODE 
33d8 6f				db WORD_SYS_CORE+91             
33d9 f6 33			dw .ENDCORE            
33db 05				db 4 + 1 
33dc .. 00			db "1+2!",0              
33e1				endm 
# End of macro CWHEAD
33e1			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
33e1			 
33e1					FORTH_DSP_VALUEHL 
33e1 cd fb 22			call macro_dsp_valuehl 
33e4				endm 
# End of macro FORTH_DSP_VALUEHL
33e4 e5					push hl 
33e5			 
33e5					FORTH_DSP_POP 
33e5 cd b3 23			call macro_forth_dsp_pop 
33e8				endm 
# End of macro FORTH_DSP_POP
33e8 e1					pop hl 
33e9			 
33e9 e5					push hl 
33ea			 
33ea cd 33 24				call loadwordinhl 
33ed 23					inc hl 
33ee			 
33ee d1					pop de 
33ef eb					ex de, hl 
33f0 73					ld (hl), e 
33f1 23					inc hl 
33f2 72					ld (hl), d 
33f3					 
33f3					NEXTW 
33f3 c3 b1 24			jp macro_next 
33f6				endm 
# End of macro NEXTW
33f6			.ENDCORE: 
33f6			 
33f6			; eof 
33f6			 
33f6			 
# End of file forth_words_core.asm
33f6			include "forth_words_flow.asm" 
33f6			 
33f6			; | ## Program Flow Words 
33f6			 
33f6			.IF: 
33f6				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
33f6 1e				db WORD_SYS_CORE+10             
33f7 eb 34			dw .THEN            
33f9 03				db 2 + 1 
33fa .. 00			db "IF",0              
33fd				endm 
# End of macro CWHEAD
33fd			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
33fd			; 
33fd					if DEBUG_FORTH_WORDS_KEY 
33fd						DMARK "IF." 
33fd f5				push af  
33fe 3a 12 34			ld a, (.dmark)  
3401 32 68 fe			ld (debug_mark),a  
3404 3a 13 34			ld a, (.dmark+1)  
3407 32 69 fe			ld (debug_mark+1),a  
340a 3a 14 34			ld a, (.dmark+2)  
340d 32 6a fe			ld (debug_mark+2),a  
3410 18 03			jr .pastdmark  
3412 ..			.dmark: db "IF."  
3415 f1			.pastdmark: pop af  
3416			endm  
# End of macro DMARK
3416						CALLMONITOR 
3416 cd 6c fe			call debug_vector  
3419				endm  
# End of macro CALLMONITOR
3419					endif 
3419			; eval TOS 
3419			 
3419				FORTH_DSP_VALUEHL 
3419 cd fb 22			call macro_dsp_valuehl 
341c				endm 
# End of macro FORTH_DSP_VALUEHL
341c			 
341c			;	push hl 
341c				FORTH_DSP_POP 
341c cd b3 23			call macro_forth_dsp_pop 
341f				endm 
# End of macro FORTH_DSP_POP
341f			;	pop hl 
341f			 
341f					if DEBUG_FORTH_WORDS 
341f						DMARK "IF1" 
341f f5				push af  
3420 3a 34 34			ld a, (.dmark)  
3423 32 68 fe			ld (debug_mark),a  
3426 3a 35 34			ld a, (.dmark+1)  
3429 32 69 fe			ld (debug_mark+1),a  
342c 3a 36 34			ld a, (.dmark+2)  
342f 32 6a fe			ld (debug_mark+2),a  
3432 18 03			jr .pastdmark  
3434 ..			.dmark: db "IF1"  
3437 f1			.pastdmark: pop af  
3438			endm  
# End of macro DMARK
3438						CALLMONITOR 
3438 cd 6c fe			call debug_vector  
343b				endm  
# End of macro CALLMONITOR
343b					endif 
343b b7				or a        ; clear carry flag 
343c 11 00 00			ld de, 0 
343f eb				ex de,hl 
3440 ed 52			sbc hl, de 
3442 c2 cc 34			jp nz, .iftrue 
3445			 
3445					if DEBUG_FORTH_WORDS 
3445						DMARK "IF2" 
3445 f5				push af  
3446 3a 5a 34			ld a, (.dmark)  
3449 32 68 fe			ld (debug_mark),a  
344c 3a 5b 34			ld a, (.dmark+1)  
344f 32 69 fe			ld (debug_mark+1),a  
3452 3a 5c 34			ld a, (.dmark+2)  
3455 32 6a fe			ld (debug_mark+2),a  
3458 18 03			jr .pastdmark  
345a ..			.dmark: db "IF2"  
345d f1			.pastdmark: pop af  
345e			endm  
# End of macro DMARK
345e						CALLMONITOR 
345e cd 6c fe			call debug_vector  
3461				endm  
# End of macro CALLMONITOR
3461					endif 
3461			 
3461			; if not true then skip to THEN 
3461			 
3461				; TODO get tok_ptr 
3461				; TODO consume toks until we get to THEN 
3461			 
3461 2a bf f4			ld hl, (os_tok_ptr) 
3464					if DEBUG_FORTH_WORDS 
3464						DMARK "IF3" 
3464 f5				push af  
3465 3a 79 34			ld a, (.dmark)  
3468 32 68 fe			ld (debug_mark),a  
346b 3a 7a 34			ld a, (.dmark+1)  
346e 32 69 fe			ld (debug_mark+1),a  
3471 3a 7b 34			ld a, (.dmark+2)  
3474 32 6a fe			ld (debug_mark+2),a  
3477 18 03			jr .pastdmark  
3479 ..			.dmark: db "IF3"  
347c f1			.pastdmark: pop af  
347d			endm  
# End of macro DMARK
347d						CALLMONITOR 
347d cd 6c fe			call debug_vector  
3480				endm  
# End of macro CALLMONITOR
3480						 
3480					endif 
3480 11 c7 34			ld de, .ifthen 
3483					if DEBUG_FORTH_WORDS 
3483						DMARK "IF4" 
3483 f5				push af  
3484 3a 98 34			ld a, (.dmark)  
3487 32 68 fe			ld (debug_mark),a  
348a 3a 99 34			ld a, (.dmark+1)  
348d 32 69 fe			ld (debug_mark+1),a  
3490 3a 9a 34			ld a, (.dmark+2)  
3493 32 6a fe			ld (debug_mark+2),a  
3496 18 03			jr .pastdmark  
3498 ..			.dmark: db "IF4"  
349b f1			.pastdmark: pop af  
349c			endm  
# End of macro DMARK
349c						CALLMONITOR 
349c cd 6c fe			call debug_vector  
349f				endm  
# End of macro CALLMONITOR
349f					endif 
349f cd cc 25			call findnexttok  
34a2			 
34a2					if DEBUG_FORTH_WORDS 
34a2						DMARK "IF5" 
34a2 f5				push af  
34a3 3a b7 34			ld a, (.dmark)  
34a6 32 68 fe			ld (debug_mark),a  
34a9 3a b8 34			ld a, (.dmark+1)  
34ac 32 69 fe			ld (debug_mark+1),a  
34af 3a b9 34			ld a, (.dmark+2)  
34b2 32 6a fe			ld (debug_mark+2),a  
34b5 18 03			jr .pastdmark  
34b7 ..			.dmark: db "IF5"  
34ba f1			.pastdmark: pop af  
34bb			endm  
# End of macro DMARK
34bb						CALLMONITOR 
34bb cd 6c fe			call debug_vector  
34be				endm  
# End of macro CALLMONITOR
34be					endif 
34be				; TODO replace below with ; exec using tok_ptr 
34be 22 bf f4			ld (os_tok_ptr), hl 
34c1 c3 42 25			jp exec1 
34c4				NEXTW 
34c4 c3 b1 24			jp macro_next 
34c7				endm 
# End of macro NEXTW
34c7			 
34c7 .. 00		.ifthen:  db "THEN",0 
34cc			 
34cc			.iftrue:		 
34cc				; Exec next words normally 
34cc			 
34cc				; if true then exec following IF as normal 
34cc					if DEBUG_FORTH_WORDS 
34cc						DMARK "IFT" 
34cc f5				push af  
34cd 3a e1 34			ld a, (.dmark)  
34d0 32 68 fe			ld (debug_mark),a  
34d3 3a e2 34			ld a, (.dmark+1)  
34d6 32 69 fe			ld (debug_mark+1),a  
34d9 3a e3 34			ld a, (.dmark+2)  
34dc 32 6a fe			ld (debug_mark+2),a  
34df 18 03			jr .pastdmark  
34e1 ..			.dmark: db "IFT"  
34e4 f1			.pastdmark: pop af  
34e5			endm  
# End of macro DMARK
34e5						CALLMONITOR 
34e5 cd 6c fe			call debug_vector  
34e8				endm  
# End of macro CALLMONITOR
34e8					endif 
34e8			 
34e8					NEXTW 
34e8 c3 b1 24			jp macro_next 
34eb				endm 
# End of macro NEXTW
34eb			.THEN: 
34eb				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
34eb 1f				db WORD_SYS_CORE+11             
34ec 13 35			dw .ELSE            
34ee 05				db 4 + 1 
34ef .. 00			db "THEN",0              
34f4				endm 
# End of macro CWHEAD
34f4			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
34f4					if DEBUG_FORTH_WORDS_KEY 
34f4						DMARK "THN" 
34f4 f5				push af  
34f5 3a 09 35			ld a, (.dmark)  
34f8 32 68 fe			ld (debug_mark),a  
34fb 3a 0a 35			ld a, (.dmark+1)  
34fe 32 69 fe			ld (debug_mark+1),a  
3501 3a 0b 35			ld a, (.dmark+2)  
3504 32 6a fe			ld (debug_mark+2),a  
3507 18 03			jr .pastdmark  
3509 ..			.dmark: db "THN"  
350c f1			.pastdmark: pop af  
350d			endm  
# End of macro DMARK
350d						CALLMONITOR 
350d cd 6c fe			call debug_vector  
3510				endm  
# End of macro CALLMONITOR
3510					endif 
3510					NEXTW 
3510 c3 b1 24			jp macro_next 
3513				endm 
# End of macro NEXTW
3513			.ELSE: 
3513				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
3513 20				db WORD_SYS_CORE+12             
3514 3b 35			dw .DO            
3516 03				db 2 + 1 
3517 .. 00			db "ELSE",0              
351c				endm 
# End of macro CWHEAD
351c			; | ELSE ( -- ) Not supported - does nothing | TODO 
351c			 
351c					if DEBUG_FORTH_WORDS_KEY 
351c						DMARK "ELS" 
351c f5				push af  
351d 3a 31 35			ld a, (.dmark)  
3520 32 68 fe			ld (debug_mark),a  
3523 3a 32 35			ld a, (.dmark+1)  
3526 32 69 fe			ld (debug_mark+1),a  
3529 3a 33 35			ld a, (.dmark+2)  
352c 32 6a fe			ld (debug_mark+2),a  
352f 18 03			jr .pastdmark  
3531 ..			.dmark: db "ELS"  
3534 f1			.pastdmark: pop af  
3535			endm  
# End of macro DMARK
3535						CALLMONITOR 
3535 cd 6c fe			call debug_vector  
3538				endm  
# End of macro CALLMONITOR
3538					endif 
3538			 
3538			 
3538					NEXTW 
3538 c3 b1 24			jp macro_next 
353b				endm 
# End of macro NEXTW
353b			.DO: 
353b				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
353b 21				db WORD_SYS_CORE+13             
353c 62 36			dw .LOOP            
353e 03				db 2 + 1 
353f .. 00			db "DO",0              
3542				endm 
# End of macro CWHEAD
3542			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
3542			 
3542					if DEBUG_FORTH_WORDS_KEY 
3542						DMARK "DO." 
3542 f5				push af  
3543 3a 57 35			ld a, (.dmark)  
3546 32 68 fe			ld (debug_mark),a  
3549 3a 58 35			ld a, (.dmark+1)  
354c 32 69 fe			ld (debug_mark+1),a  
354f 3a 59 35			ld a, (.dmark+2)  
3552 32 6a fe			ld (debug_mark+2),a  
3555 18 03			jr .pastdmark  
3557 ..			.dmark: db "DO."  
355a f1			.pastdmark: pop af  
355b			endm  
# End of macro DMARK
355b						CALLMONITOR 
355b cd 6c fe			call debug_vector  
355e				endm  
# End of macro CALLMONITOR
355e					endif 
355e			;  push pc to rsp stack past the DO 
355e			 
355e 2a bf f4				ld hl, (os_tok_ptr) 
3561 23					inc hl   ; D 
3562 23					inc hl  ; O 
3563 23					inc hl   ; null 
3564					if DEBUG_FORTH_WORDS 
3564						DMARK "DO2" 
3564 f5				push af  
3565 3a 79 35			ld a, (.dmark)  
3568 32 68 fe			ld (debug_mark),a  
356b 3a 7a 35			ld a, (.dmark+1)  
356e 32 69 fe			ld (debug_mark+1),a  
3571 3a 7b 35			ld a, (.dmark+2)  
3574 32 6a fe			ld (debug_mark+2),a  
3577 18 03			jr .pastdmark  
3579 ..			.dmark: db "DO2"  
357c f1			.pastdmark: pop af  
357d			endm  
# End of macro DMARK
357d						CALLMONITOR 
357d cd 6c fe			call debug_vector  
3580				endm  
# End of macro CALLMONITOR
3580					endif 
3580					FORTH_RSP_NEXT 
3580 cd ab 20			call macro_forth_rsp_next 
3583				endm 
# End of macro FORTH_RSP_NEXT
3583					if DEBUG_FORTH_WORDS 
3583						DMARK "DO3" 
3583 f5				push af  
3584 3a 98 35			ld a, (.dmark)  
3587 32 68 fe			ld (debug_mark),a  
358a 3a 99 35			ld a, (.dmark+1)  
358d 32 69 fe			ld (debug_mark+1),a  
3590 3a 9a 35			ld a, (.dmark+2)  
3593 32 6a fe			ld (debug_mark+2),a  
3596 18 03			jr .pastdmark  
3598 ..			.dmark: db "DO3"  
359b f1			.pastdmark: pop af  
359c			endm  
# End of macro DMARK
359c						CALLMONITOR 
359c cd 6c fe			call debug_vector  
359f				endm  
# End of macro CALLMONITOR
359f					endif 
359f			 
359f					;if DEBUG_FORTH_WORDS 
359f				;		push hl 
359f			;		endif  
359f			 
359f			; get counters from data stack 
359f			 
359f			 
359f					FORTH_DSP_VALUEHL 
359f cd fb 22			call macro_dsp_valuehl 
35a2				endm 
# End of macro FORTH_DSP_VALUEHL
35a2 e5					push hl		 ; hl now has starting counter which needs to be tos 
35a3			 
35a3					if DEBUG_FORTH_WORDS 
35a3						DMARK "DO4" 
35a3 f5				push af  
35a4 3a b8 35			ld a, (.dmark)  
35a7 32 68 fe			ld (debug_mark),a  
35aa 3a b9 35			ld a, (.dmark+1)  
35ad 32 69 fe			ld (debug_mark+1),a  
35b0 3a ba 35			ld a, (.dmark+2)  
35b3 32 6a fe			ld (debug_mark+2),a  
35b6 18 03			jr .pastdmark  
35b8 ..			.dmark: db "DO4"  
35bb f1			.pastdmark: pop af  
35bc			endm  
# End of macro DMARK
35bc						CALLMONITOR 
35bc cd 6c fe			call debug_vector  
35bf				endm  
# End of macro CALLMONITOR
35bf					endif 
35bf					FORTH_DSP_POP 
35bf cd b3 23			call macro_forth_dsp_pop 
35c2				endm 
# End of macro FORTH_DSP_POP
35c2			 
35c2					if DEBUG_FORTH_WORDS 
35c2						DMARK "DO5" 
35c2 f5				push af  
35c3 3a d7 35			ld a, (.dmark)  
35c6 32 68 fe			ld (debug_mark),a  
35c9 3a d8 35			ld a, (.dmark+1)  
35cc 32 69 fe			ld (debug_mark+1),a  
35cf 3a d9 35			ld a, (.dmark+2)  
35d2 32 6a fe			ld (debug_mark+2),a  
35d5 18 03			jr .pastdmark  
35d7 ..			.dmark: db "DO5"  
35da f1			.pastdmark: pop af  
35db			endm  
# End of macro DMARK
35db						CALLMONITOR 
35db cd 6c fe			call debug_vector  
35de				endm  
# End of macro CALLMONITOR
35de					endif 
35de			 
35de					FORTH_DSP_VALUEHL 
35de cd fb 22			call macro_dsp_valuehl 
35e1				endm 
# End of macro FORTH_DSP_VALUEHL
35e1			;		push hl		 ; hl now has starting limit counter 
35e1			 
35e1					if DEBUG_FORTH_WORDS 
35e1						DMARK "DO6" 
35e1 f5				push af  
35e2 3a f6 35			ld a, (.dmark)  
35e5 32 68 fe			ld (debug_mark),a  
35e8 3a f7 35			ld a, (.dmark+1)  
35eb 32 69 fe			ld (debug_mark+1),a  
35ee 3a f8 35			ld a, (.dmark+2)  
35f1 32 6a fe			ld (debug_mark+2),a  
35f4 18 03			jr .pastdmark  
35f6 ..			.dmark: db "DO6"  
35f9 f1			.pastdmark: pop af  
35fa			endm  
# End of macro DMARK
35fa						CALLMONITOR 
35fa cd 6c fe			call debug_vector  
35fd				endm  
# End of macro CALLMONITOR
35fd					endif 
35fd					FORTH_DSP_POP 
35fd cd b3 23			call macro_forth_dsp_pop 
3600				endm 
# End of macro FORTH_DSP_POP
3600			 
3600			; put counters on the loop stack 
3600			 
3600			;		pop hl			 ; limit counter 
3600 d1					pop de			; start counter 
3601			 
3601					; push limit counter 
3601			 
3601					if DEBUG_FORTH_WORDS 
3601						DMARK "DO7" 
3601 f5				push af  
3602 3a 16 36			ld a, (.dmark)  
3605 32 68 fe			ld (debug_mark),a  
3608 3a 17 36			ld a, (.dmark+1)  
360b 32 69 fe			ld (debug_mark+1),a  
360e 3a 18 36			ld a, (.dmark+2)  
3611 32 6a fe			ld (debug_mark+2),a  
3614 18 03			jr .pastdmark  
3616 ..			.dmark: db "DO7"  
3619 f1			.pastdmark: pop af  
361a			endm  
# End of macro DMARK
361a						CALLMONITOR 
361a cd 6c fe			call debug_vector  
361d				endm  
# End of macro CALLMONITOR
361d					endif 
361d					FORTH_LOOP_NEXT 
361d cd 2c 23			call macro_forth_loop_next 
3620				endm 
# End of macro FORTH_LOOP_NEXT
3620			 
3620					; push start counter 
3620			 
3620 eb					ex de, hl 
3621					if DEBUG_FORTH_WORDS 
3621						DMARK "DO7" 
3621 f5				push af  
3622 3a 36 36			ld a, (.dmark)  
3625 32 68 fe			ld (debug_mark),a  
3628 3a 37 36			ld a, (.dmark+1)  
362b 32 69 fe			ld (debug_mark+1),a  
362e 3a 38 36			ld a, (.dmark+2)  
3631 32 6a fe			ld (debug_mark+2),a  
3634 18 03			jr .pastdmark  
3636 ..			.dmark: db "DO7"  
3639 f1			.pastdmark: pop af  
363a			endm  
# End of macro DMARK
363a						CALLMONITOR 
363a cd 6c fe			call debug_vector  
363d				endm  
# End of macro CALLMONITOR
363d					endif 
363d					FORTH_LOOP_NEXT 
363d cd 2c 23			call macro_forth_loop_next 
3640				endm 
# End of macro FORTH_LOOP_NEXT
3640			 
3640			 
3640					; init first round of I counter 
3640			 
3640 22 e3 f4				ld (os_current_i), hl 
3643			 
3643					if DEBUG_FORTH_WORDS 
3643						DMARK "DO8" 
3643 f5				push af  
3644 3a 58 36			ld a, (.dmark)  
3647 32 68 fe			ld (debug_mark),a  
364a 3a 59 36			ld a, (.dmark+1)  
364d 32 69 fe			ld (debug_mark+1),a  
3650 3a 5a 36			ld a, (.dmark+2)  
3653 32 6a fe			ld (debug_mark+2),a  
3656 18 03			jr .pastdmark  
3658 ..			.dmark: db "DO8"  
365b f1			.pastdmark: pop af  
365c			endm  
# End of macro DMARK
365c						CALLMONITOR 
365c cd 6c fe			call debug_vector  
365f				endm  
# End of macro CALLMONITOR
365f					endif 
365f			 
365f					NEXTW 
365f c3 b1 24			jp macro_next 
3662				endm 
# End of macro NEXTW
3662			.LOOP: 
3662				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
3662 22				db WORD_SYS_CORE+14             
3663 7a 37			dw .I            
3665 05				db 4 + 1 
3666 .. 00			db "LOOP",0              
366b				endm 
# End of macro CWHEAD
366b			; | LOOP ( -- ) Increment and test loop counter  | DONE 
366b			 
366b				; pop tos as current loop count to hl 
366b			 
366b				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
366b			 
366b				FORTH_LOOP_TOS 
366b cd 5f 23			call macro_forth_loop_tos 
366e				endm 
# End of macro FORTH_LOOP_TOS
366e e5				push hl 
366f			 
366f					if DEBUG_FORTH_WORDS_KEY 
366f						DMARK "LOP" 
366f f5				push af  
3670 3a 84 36			ld a, (.dmark)  
3673 32 68 fe			ld (debug_mark),a  
3676 3a 85 36			ld a, (.dmark+1)  
3679 32 69 fe			ld (debug_mark+1),a  
367c 3a 86 36			ld a, (.dmark+2)  
367f 32 6a fe			ld (debug_mark+2),a  
3682 18 03			jr .pastdmark  
3684 ..			.dmark: db "LOP"  
3687 f1			.pastdmark: pop af  
3688			endm  
# End of macro DMARK
3688						CALLMONITOR 
3688 cd 6c fe			call debug_vector  
368b				endm  
# End of macro CALLMONITOR
368b					endif 
368b				; next item on the stack is the limit. get it 
368b			 
368b			 
368b				FORTH_LOOP_POP 
368b cd 69 23			call macro_forth_loop_pop 
368e				endm 
# End of macro FORTH_LOOP_POP
368e			 
368e				FORTH_LOOP_TOS 
368e cd 5f 23			call macro_forth_loop_tos 
3691				endm 
# End of macro FORTH_LOOP_TOS
3691			 
3691 d1				pop de		 ; de = i, hl = limit 
3692			 
3692					if DEBUG_FORTH_WORDS 
3692						DMARK "LP1" 
3692 f5				push af  
3693 3a a7 36			ld a, (.dmark)  
3696 32 68 fe			ld (debug_mark),a  
3699 3a a8 36			ld a, (.dmark+1)  
369c 32 69 fe			ld (debug_mark+1),a  
369f 3a a9 36			ld a, (.dmark+2)  
36a2 32 6a fe			ld (debug_mark+2),a  
36a5 18 03			jr .pastdmark  
36a7 ..			.dmark: db "LP1"  
36aa f1			.pastdmark: pop af  
36ab			endm  
# End of macro DMARK
36ab						CALLMONITOR 
36ab cd 6c fe			call debug_vector  
36ae				endm  
# End of macro CALLMONITOR
36ae					endif 
36ae			 
36ae				; go back to previous word 
36ae			 
36ae d5				push de    ; save I for inc later 
36af			 
36af			 
36af				; get limit 
36af				;  is I at limit? 
36af			 
36af			 
36af					if DEBUG_FORTH_WORDS 
36af						DMARK "LP1" 
36af f5				push af  
36b0 3a c4 36			ld a, (.dmark)  
36b3 32 68 fe			ld (debug_mark),a  
36b6 3a c5 36			ld a, (.dmark+1)  
36b9 32 69 fe			ld (debug_mark+1),a  
36bc 3a c6 36			ld a, (.dmark+2)  
36bf 32 6a fe			ld (debug_mark+2),a  
36c2 18 03			jr .pastdmark  
36c4 ..			.dmark: db "LP1"  
36c7 f1			.pastdmark: pop af  
36c8			endm  
# End of macro DMARK
36c8						CALLMONITOR 
36c8 cd 6c fe			call debug_vector  
36cb				endm  
# End of macro CALLMONITOR
36cb					endif 
36cb			 
36cb ed 52			sbc hl, de 
36cd			 
36cd			 
36cd				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
36cd			 
36cd 20 26				jr nz, .loopnotdone 
36cf			 
36cf e1				pop hl   ; get rid of saved I 
36d0				FORTH_LOOP_POP     ; get rid of limit 
36d0 cd 69 23			call macro_forth_loop_pop 
36d3				endm 
# End of macro FORTH_LOOP_POP
36d3			 
36d3				FORTH_RSP_POP     ; get rid of DO ptr 
36d3 cd cc 20			call macro_forth_rsp_pop 
36d6				endm 
# End of macro FORTH_RSP_POP
36d6			 
36d6			if DEBUG_FORTH_WORDS 
36d6						DMARK "LP>" 
36d6 f5				push af  
36d7 3a eb 36			ld a, (.dmark)  
36da 32 68 fe			ld (debug_mark),a  
36dd 3a ec 36			ld a, (.dmark+1)  
36e0 32 69 fe			ld (debug_mark+1),a  
36e3 3a ed 36			ld a, (.dmark+2)  
36e6 32 6a fe			ld (debug_mark+2),a  
36e9 18 03			jr .pastdmark  
36eb ..			.dmark: db "LP>"  
36ee f1			.pastdmark: pop af  
36ef			endm  
# End of macro DMARK
36ef				CALLMONITOR 
36ef cd 6c fe			call debug_vector  
36f2				endm  
# End of macro CALLMONITOR
36f2			endif 
36f2			 
36f2					NEXTW 
36f2 c3 b1 24			jp macro_next 
36f5				endm 
# End of macro NEXTW
36f5				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
36f5			 
36f5			.loopnotdone: 
36f5			 
36f5 e1				pop hl    ; get I 
36f6 23				inc hl 
36f7			 
36f7			   	; save new I 
36f7			 
36f7			 
36f7					; set I counter 
36f7			 
36f7 22 e3 f4				ld (os_current_i), hl 
36fa			 
36fa					if DEBUG_FORTH_WORDS 
36fa						DMARK "LPN" 
36fa f5				push af  
36fb 3a 0f 37			ld a, (.dmark)  
36fe 32 68 fe			ld (debug_mark),a  
3701 3a 10 37			ld a, (.dmark+1)  
3704 32 69 fe			ld (debug_mark+1),a  
3707 3a 11 37			ld a, (.dmark+2)  
370a 32 6a fe			ld (debug_mark+2),a  
370d 18 03			jr .pastdmark  
370f ..			.dmark: db "LPN"  
3712 f1			.pastdmark: pop af  
3713			endm  
# End of macro DMARK
3713					CALLMONITOR 
3713 cd 6c fe			call debug_vector  
3716				endm  
# End of macro CALLMONITOR
3716					endif 
3716					 
3716				FORTH_LOOP_NEXT 
3716 cd 2c 23			call macro_forth_loop_next 
3719				endm 
# End of macro FORTH_LOOP_NEXT
3719			 
3719			 
3719					if DEBUG_FORTH_WORDS 
3719 eb						ex de,hl 
371a					endif 
371a			 
371a			;	; get DO ptr 
371a			; 
371a					if DEBUG_FORTH_WORDS 
371a						DMARK "LP7" 
371a f5				push af  
371b 3a 2f 37			ld a, (.dmark)  
371e 32 68 fe			ld (debug_mark),a  
3721 3a 30 37			ld a, (.dmark+1)  
3724 32 69 fe			ld (debug_mark+1),a  
3727 3a 31 37			ld a, (.dmark+2)  
372a 32 6a fe			ld (debug_mark+2),a  
372d 18 03			jr .pastdmark  
372f ..			.dmark: db "LP7"  
3732 f1			.pastdmark: pop af  
3733			endm  
# End of macro DMARK
3733					CALLMONITOR 
3733 cd 6c fe			call debug_vector  
3736				endm  
# End of macro CALLMONITOR
3736					endif 
3736				FORTH_RSP_TOS 
3736 cd c2 20			call macro_forth_rsp_tos 
3739				endm 
# End of macro FORTH_RSP_TOS
3739			 
3739					if DEBUG_FORTH_WORDS 
3739						DMARK "LP8" 
3739 f5				push af  
373a 3a 4e 37			ld a, (.dmark)  
373d 32 68 fe			ld (debug_mark),a  
3740 3a 4f 37			ld a, (.dmark+1)  
3743 32 69 fe			ld (debug_mark+1),a  
3746 3a 50 37			ld a, (.dmark+2)  
3749 32 6a fe			ld (debug_mark+2),a  
374c 18 03			jr .pastdmark  
374e ..			.dmark: db "LP8"  
3751 f1			.pastdmark: pop af  
3752			endm  
# End of macro DMARK
3752					CALLMONITOR 
3752 cd 6c fe			call debug_vector  
3755				endm  
# End of macro CALLMONITOR
3755					endif 
3755				;push hl 
3755			 
3755				; not going to DO any more 
3755				; get rid of the RSP pointer as DO will add it back in 
3755				;FORTH_RSP_POP 
3755				;pop hl 
3755			 
3755				;ld hl,(cli_ret_sp) 
3755				;ld e, (hl) 
3755				;inc hl 
3755				;ld d, (hl) 
3755				;ex de,hl 
3755 22 bf f4			ld (os_tok_ptr), hl 
3758					if DEBUG_FORTH_WORDS 
3758						DMARK "LP<" 
3758 f5				push af  
3759 3a 6d 37			ld a, (.dmark)  
375c 32 68 fe			ld (debug_mark),a  
375f 3a 6e 37			ld a, (.dmark+1)  
3762 32 69 fe			ld (debug_mark+1),a  
3765 3a 6f 37			ld a, (.dmark+2)  
3768 32 6a fe			ld (debug_mark+2),a  
376b 18 03			jr .pastdmark  
376d ..			.dmark: db "LP<"  
3770 f1			.pastdmark: pop af  
3771			endm  
# End of macro DMARK
3771					CALLMONITOR 
3771 cd 6c fe			call debug_vector  
3774				endm  
# End of macro CALLMONITOR
3774				endif 
3774 c3 42 25			jp exec1 
3777			 
3777					 
3777			 
3777			 
3777					NEXTW 
3777 c3 b1 24			jp macro_next 
377a				endm 
# End of macro NEXTW
377a			.I:  
377a			 
377a				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
377a 5e				db WORD_SYS_CORE+74             
377b a5 37			dw .DLOOP            
377d 02				db 1 + 1 
377e .. 00			db "I",0              
3780				endm 
# End of macro CWHEAD
3780			; | I ( -- ) Current loop counter | DONE 
3780					if DEBUG_FORTH_WORDS_KEY 
3780						DMARK "I.." 
3780 f5				push af  
3781 3a 95 37			ld a, (.dmark)  
3784 32 68 fe			ld (debug_mark),a  
3787 3a 96 37			ld a, (.dmark+1)  
378a 32 69 fe			ld (debug_mark+1),a  
378d 3a 97 37			ld a, (.dmark+2)  
3790 32 6a fe			ld (debug_mark+2),a  
3793 18 03			jr .pastdmark  
3795 ..			.dmark: db "I.."  
3798 f1			.pastdmark: pop af  
3799			endm  
# End of macro DMARK
3799						CALLMONITOR 
3799 cd 6c fe			call debug_vector  
379c				endm  
# End of macro CALLMONITOR
379c					endif 
379c			 
379c 2a e3 f4				ld hl,(os_current_i) 
379f cd 04 21				call forth_push_numhl 
37a2			 
37a2					NEXTW 
37a2 c3 b1 24			jp macro_next 
37a5				endm 
# End of macro NEXTW
37a5			.DLOOP: 
37a5				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
37a5 5f				db WORD_SYS_CORE+75             
37a6 86 38			dw .REPEAT            
37a8 06				db 5 + 1 
37a9 .. 00			db "-LOOP",0              
37af				endm 
# End of macro CWHEAD
37af			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
37af				; pop tos as current loop count to hl 
37af					if DEBUG_FORTH_WORDS_KEY 
37af						DMARK "-LP" 
37af f5				push af  
37b0 3a c4 37			ld a, (.dmark)  
37b3 32 68 fe			ld (debug_mark),a  
37b6 3a c5 37			ld a, (.dmark+1)  
37b9 32 69 fe			ld (debug_mark+1),a  
37bc 3a c6 37			ld a, (.dmark+2)  
37bf 32 6a fe			ld (debug_mark+2),a  
37c2 18 03			jr .pastdmark  
37c4 ..			.dmark: db "-LP"  
37c7 f1			.pastdmark: pop af  
37c8			endm  
# End of macro DMARK
37c8						CALLMONITOR 
37c8 cd 6c fe			call debug_vector  
37cb				endm  
# End of macro CALLMONITOR
37cb					endif 
37cb			 
37cb				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
37cb			 
37cb				FORTH_LOOP_TOS 
37cb cd 5f 23			call macro_forth_loop_tos 
37ce				endm 
# End of macro FORTH_LOOP_TOS
37ce e5				push hl 
37cf			 
37cf					if DEBUG_FORTH_WORDS 
37cf						DMARK "-LP" 
37cf f5				push af  
37d0 3a e4 37			ld a, (.dmark)  
37d3 32 68 fe			ld (debug_mark),a  
37d6 3a e5 37			ld a, (.dmark+1)  
37d9 32 69 fe			ld (debug_mark+1),a  
37dc 3a e6 37			ld a, (.dmark+2)  
37df 32 6a fe			ld (debug_mark+2),a  
37e2 18 03			jr .pastdmark  
37e4 ..			.dmark: db "-LP"  
37e7 f1			.pastdmark: pop af  
37e8			endm  
# End of macro DMARK
37e8						CALLMONITOR 
37e8 cd 6c fe			call debug_vector  
37eb				endm  
# End of macro CALLMONITOR
37eb					endif 
37eb				; next item on the stack is the limit. get it 
37eb			 
37eb			 
37eb				FORTH_LOOP_POP 
37eb cd 69 23			call macro_forth_loop_pop 
37ee				endm 
# End of macro FORTH_LOOP_POP
37ee			 
37ee				FORTH_LOOP_TOS 
37ee cd 5f 23			call macro_forth_loop_tos 
37f1				endm 
# End of macro FORTH_LOOP_TOS
37f1			 
37f1 d1				pop de		 ; de = i, hl = limit 
37f2			 
37f2					if DEBUG_FORTH_WORDS 
37f2						DMARK "-L1" 
37f2 f5				push af  
37f3 3a 07 38			ld a, (.dmark)  
37f6 32 68 fe			ld (debug_mark),a  
37f9 3a 08 38			ld a, (.dmark+1)  
37fc 32 69 fe			ld (debug_mark+1),a  
37ff 3a 09 38			ld a, (.dmark+2)  
3802 32 6a fe			ld (debug_mark+2),a  
3805 18 03			jr .pastdmark  
3807 ..			.dmark: db "-L1"  
380a f1			.pastdmark: pop af  
380b			endm  
# End of macro DMARK
380b						CALLMONITOR 
380b cd 6c fe			call debug_vector  
380e				endm  
# End of macro CALLMONITOR
380e					endif 
380e			 
380e				; go back to previous word 
380e			 
380e d5				push de    ; save I for inc later 
380f			 
380f			 
380f				; get limit 
380f				;  is I at limit? 
380f			 
380f			 
380f					if DEBUG_FORTH_WORDS 
380f						DMARK "-L1" 
380f f5				push af  
3810 3a 24 38			ld a, (.dmark)  
3813 32 68 fe			ld (debug_mark),a  
3816 3a 25 38			ld a, (.dmark+1)  
3819 32 69 fe			ld (debug_mark+1),a  
381c 3a 26 38			ld a, (.dmark+2)  
381f 32 6a fe			ld (debug_mark+2),a  
3822 18 03			jr .pastdmark  
3824 ..			.dmark: db "-L1"  
3827 f1			.pastdmark: pop af  
3828			endm  
# End of macro DMARK
3828						CALLMONITOR 
3828 cd 6c fe			call debug_vector  
382b				endm  
# End of macro CALLMONITOR
382b					endif 
382b			 
382b ed 52			sbc hl, de 
382d			 
382d			 
382d				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
382d			 
382d 20 26				jr nz, .mloopnotdone 
382f			 
382f e1				pop hl   ; get rid of saved I 
3830				FORTH_LOOP_POP     ; get rid of limit 
3830 cd 69 23			call macro_forth_loop_pop 
3833				endm 
# End of macro FORTH_LOOP_POP
3833			 
3833				FORTH_RSP_POP     ; get rid of DO ptr 
3833 cd cc 20			call macro_forth_rsp_pop 
3836				endm 
# End of macro FORTH_RSP_POP
3836			 
3836			if DEBUG_FORTH_WORDS 
3836						DMARK "-L>" 
3836 f5				push af  
3837 3a 4b 38			ld a, (.dmark)  
383a 32 68 fe			ld (debug_mark),a  
383d 3a 4c 38			ld a, (.dmark+1)  
3840 32 69 fe			ld (debug_mark+1),a  
3843 3a 4d 38			ld a, (.dmark+2)  
3846 32 6a fe			ld (debug_mark+2),a  
3849 18 03			jr .pastdmark  
384b ..			.dmark: db "-L>"  
384e f1			.pastdmark: pop af  
384f			endm  
# End of macro DMARK
384f				CALLMONITOR 
384f cd 6c fe			call debug_vector  
3852				endm  
# End of macro CALLMONITOR
3852			endif 
3852			 
3852					NEXTW 
3852 c3 b1 24			jp macro_next 
3855				endm 
# End of macro NEXTW
3855				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3855			 
3855			.mloopnotdone: 
3855			 
3855 e1				pop hl    ; get I 
3856 2b				dec hl 
3857			 
3857			   	; save new I 
3857			 
3857			 
3857					; set I counter 
3857			 
3857 22 e3 f4				ld (os_current_i), hl 
385a			 
385a					 
385a				FORTH_LOOP_NEXT 
385a cd 2c 23			call macro_forth_loop_next 
385d				endm 
# End of macro FORTH_LOOP_NEXT
385d			 
385d			 
385d					if DEBUG_FORTH_WORDS 
385d eb						ex de,hl 
385e					endif 
385e			 
385e			;	; get DO ptr 
385e			; 
385e				FORTH_RSP_TOS 
385e cd c2 20			call macro_forth_rsp_tos 
3861				endm 
# End of macro FORTH_RSP_TOS
3861			 
3861				;push hl 
3861			 
3861				; not going to DO any more 
3861				; get rid of the RSP pointer as DO will add it back in 
3861				;FORTH_RSP_POP 
3861				;pop hl 
3861			 
3861			 
3861 22 bf f4			ld (os_tok_ptr), hl 
3864					if DEBUG_FORTH_WORDS 
3864						DMARK "-L<" 
3864 f5				push af  
3865 3a 79 38			ld a, (.dmark)  
3868 32 68 fe			ld (debug_mark),a  
386b 3a 7a 38			ld a, (.dmark+1)  
386e 32 69 fe			ld (debug_mark+1),a  
3871 3a 7b 38			ld a, (.dmark+2)  
3874 32 6a fe			ld (debug_mark+2),a  
3877 18 03			jr .pastdmark  
3879 ..			.dmark: db "-L<"  
387c f1			.pastdmark: pop af  
387d			endm  
# End of macro DMARK
387d					CALLMONITOR 
387d cd 6c fe			call debug_vector  
3880				endm  
# End of macro CALLMONITOR
3880				endif 
3880 c3 42 25			jp exec1 
3883			 
3883					 
3883			 
3883			 
3883			 
3883				NEXTW 
3883 c3 b1 24			jp macro_next 
3886				endm 
# End of macro NEXTW
3886			 
3886			 
3886			 
3886			 
3886			.REPEAT: 
3886				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
3886 71				db WORD_SYS_CORE+93             
3887 d9 38			dw .UNTIL            
3889 06				db 5 + 1 
388a .. 00			db "REPEAT",0              
3891				endm 
# End of macro CWHEAD
3891			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
3891			;  push pc to rsp stack past the REPEAT 
3891					if DEBUG_FORTH_WORDS_KEY 
3891						DMARK "REP" 
3891 f5				push af  
3892 3a a6 38			ld a, (.dmark)  
3895 32 68 fe			ld (debug_mark),a  
3898 3a a7 38			ld a, (.dmark+1)  
389b 32 69 fe			ld (debug_mark+1),a  
389e 3a a8 38			ld a, (.dmark+2)  
38a1 32 6a fe			ld (debug_mark+2),a  
38a4 18 03			jr .pastdmark  
38a6 ..			.dmark: db "REP"  
38a9 f1			.pastdmark: pop af  
38aa			endm  
# End of macro DMARK
38aa						CALLMONITOR 
38aa cd 6c fe			call debug_vector  
38ad				endm  
# End of macro CALLMONITOR
38ad					endif 
38ad			 
38ad 2a bf f4				ld hl, (os_tok_ptr) 
38b0 23					inc hl   ; R 
38b1 23					inc hl  ; E 
38b2 23					inc hl   ; P 
38b3 23					inc hl   ; E 
38b4 23					inc hl   ; A 
38b5 23					inc hl   ; T 
38b6 23					inc hl   ; zero 
38b7					FORTH_RSP_NEXT 
38b7 cd ab 20			call macro_forth_rsp_next 
38ba				endm 
# End of macro FORTH_RSP_NEXT
38ba			 
38ba			 
38ba					if DEBUG_FORTH_WORDS 
38ba						DMARK "REP" 
38ba f5				push af  
38bb 3a cf 38			ld a, (.dmark)  
38be 32 68 fe			ld (debug_mark),a  
38c1 3a d0 38			ld a, (.dmark+1)  
38c4 32 69 fe			ld (debug_mark+1),a  
38c7 3a d1 38			ld a, (.dmark+2)  
38ca 32 6a fe			ld (debug_mark+2),a  
38cd 18 03			jr .pastdmark  
38cf ..			.dmark: db "REP"  
38d2 f1			.pastdmark: pop af  
38d3			endm  
# End of macro DMARK
38d3						;pop bc    ; TODO BUG ?????? what is this for???? 
38d3						CALLMONITOR 
38d3 cd 6c fe			call debug_vector  
38d6				endm  
# End of macro CALLMONITOR
38d6					endif 
38d6			 
38d6					NEXTW 
38d6 c3 b1 24			jp macro_next 
38d9				endm 
# End of macro NEXTW
38d9			;	       NEXTW 
38d9			 
38d9			.UNTIL: 
38d9				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
38d9 72				db WORD_SYS_CORE+94             
38da 70 39			dw .ENDFLOW            
38dc 06				db 5 + 1 
38dd .. 00			db "UNTIL",0              
38e3				endm 
# End of macro CWHEAD
38e3			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
38e3			 
38e3				; pop tos as check 
38e3			 
38e3				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
38e3			 
38e3				FORTH_DSP_VALUEHL 
38e3 cd fb 22			call macro_dsp_valuehl 
38e6				endm 
# End of macro FORTH_DSP_VALUEHL
38e6			 
38e6					if DEBUG_FORTH_WORDS_KEY 
38e6						DMARK "UNT" 
38e6 f5				push af  
38e7 3a fb 38			ld a, (.dmark)  
38ea 32 68 fe			ld (debug_mark),a  
38ed 3a fc 38			ld a, (.dmark+1)  
38f0 32 69 fe			ld (debug_mark+1),a  
38f3 3a fd 38			ld a, (.dmark+2)  
38f6 32 6a fe			ld (debug_mark+2),a  
38f9 18 03			jr .pastdmark  
38fb ..			.dmark: db "UNT"  
38fe f1			.pastdmark: pop af  
38ff			endm  
# End of macro DMARK
38ff						CALLMONITOR 
38ff cd 6c fe			call debug_vector  
3902				endm  
# End of macro CALLMONITOR
3902					endif 
3902			 
3902			;	push hl 
3902				FORTH_DSP_POP 
3902 cd b3 23			call macro_forth_dsp_pop 
3905				endm 
# End of macro FORTH_DSP_POP
3905			 
3905			;	pop hl 
3905			 
3905				; test if true 
3905			 
3905 cd f9 0f			call ishlzero 
3908			;	ld a,l 
3908			;	add h 
3908			; 
3908			;	cp 0 
3908			 
3908 20 3e			jr nz, .untilnotdone 
390a			 
390a					if DEBUG_FORTH_WORDS 
390a						DMARK "UNf" 
390a f5				push af  
390b 3a 1f 39			ld a, (.dmark)  
390e 32 68 fe			ld (debug_mark),a  
3911 3a 20 39			ld a, (.dmark+1)  
3914 32 69 fe			ld (debug_mark+1),a  
3917 3a 21 39			ld a, (.dmark+2)  
391a 32 6a fe			ld (debug_mark+2),a  
391d 18 03			jr .pastdmark  
391f ..			.dmark: db "UNf"  
3922 f1			.pastdmark: pop af  
3923			endm  
# End of macro DMARK
3923						CALLMONITOR 
3923 cd 6c fe			call debug_vector  
3926				endm  
# End of macro CALLMONITOR
3926					endif 
3926			 
3926			 
3926			 
3926				FORTH_RSP_POP     ; get rid of DO ptr 
3926 cd cc 20			call macro_forth_rsp_pop 
3929				endm 
# End of macro FORTH_RSP_POP
3929			 
3929			if DEBUG_FORTH_WORDS 
3929						DMARK "UN>" 
3929 f5				push af  
392a 3a 3e 39			ld a, (.dmark)  
392d 32 68 fe			ld (debug_mark),a  
3930 3a 3f 39			ld a, (.dmark+1)  
3933 32 69 fe			ld (debug_mark+1),a  
3936 3a 40 39			ld a, (.dmark+2)  
3939 32 6a fe			ld (debug_mark+2),a  
393c 18 03			jr .pastdmark  
393e ..			.dmark: db "UN>"  
3941 f1			.pastdmark: pop af  
3942			endm  
# End of macro DMARK
3942				CALLMONITOR 
3942 cd 6c fe			call debug_vector  
3945				endm  
# End of macro CALLMONITOR
3945			endif 
3945			 
3945					NEXTW 
3945 c3 b1 24			jp macro_next 
3948				endm 
# End of macro NEXTW
3948				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3948			 
3948			.untilnotdone: 
3948			 
3948			 
3948			;	; get DO ptr 
3948			; 
3948				FORTH_RSP_TOS 
3948 cd c2 20			call macro_forth_rsp_tos 
394b				endm 
# End of macro FORTH_RSP_TOS
394b			 
394b				;push hl 
394b			 
394b				; not going to DO any more 
394b				; get rid of the RSP pointer as DO will add it back in 
394b				;FORTH_RSP_POP 
394b				;pop hl 
394b			 
394b			 
394b 22 bf f4			ld (os_tok_ptr), hl 
394e					if DEBUG_FORTH_WORDS 
394e						DMARK "UN<" 
394e f5				push af  
394f 3a 63 39			ld a, (.dmark)  
3952 32 68 fe			ld (debug_mark),a  
3955 3a 64 39			ld a, (.dmark+1)  
3958 32 69 fe			ld (debug_mark+1),a  
395b 3a 65 39			ld a, (.dmark+2)  
395e 32 6a fe			ld (debug_mark+2),a  
3961 18 03			jr .pastdmark  
3963 ..			.dmark: db "UN<"  
3966 f1			.pastdmark: pop af  
3967			endm  
# End of macro DMARK
3967					CALLMONITOR 
3967 cd 6c fe			call debug_vector  
396a				endm  
# End of macro CALLMONITOR
396a				endif 
396a c3 42 25			jp exec1 
396d			 
396d					 
396d			 
396d			 
396d					NEXTW 
396d c3 b1 24			jp macro_next 
3970				endm 
# End of macro NEXTW
3970			 
3970			 
3970			.ENDFLOW: 
3970			 
3970			; eof 
3970			 
# End of file forth_words_flow.asm
3970			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
3970			include "forth_words_logic.asm" 
3970			 
3970			; | ## Logic Words 
3970			 
3970			.NOT: 
3970				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
3970 2d				db WORD_SYS_CORE+25             
3971 b8 39			dw .IS            
3973 04				db 3 + 1 
3974 .. 00			db "NOT",0              
3978				endm 
# End of macro CWHEAD
3978			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
3978					if DEBUG_FORTH_WORDS_KEY 
3978						DMARK "NOT" 
3978 f5				push af  
3979 3a 8d 39			ld a, (.dmark)  
397c 32 68 fe			ld (debug_mark),a  
397f 3a 8e 39			ld a, (.dmark+1)  
3982 32 69 fe			ld (debug_mark+1),a  
3985 3a 8f 39			ld a, (.dmark+2)  
3988 32 6a fe			ld (debug_mark+2),a  
398b 18 03			jr .pastdmark  
398d ..			.dmark: db "NOT"  
3990 f1			.pastdmark: pop af  
3991			endm  
# End of macro DMARK
3991						CALLMONITOR 
3991 cd 6c fe			call debug_vector  
3994				endm  
# End of macro CALLMONITOR
3994					endif 
3994					FORTH_DSP 
3994 cd c1 22			call macro_forth_dsp 
3997				endm 
# End of macro FORTH_DSP
3997 7e					ld a,(hl)	; get type of value on TOS 
3998 fe 02				cp DS_TYPE_INUM  
399a 28 03				jr z, .noti 
399c					NEXTW 
399c c3 b1 24			jp macro_next 
399f				endm 
# End of macro NEXTW
399f			.noti:          FORTH_DSP_VALUEHL 
399f cd fb 22			call macro_dsp_valuehl 
39a2				endm 
# End of macro FORTH_DSP_VALUEHL
39a2			;		push hl 
39a2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39a2 cd b3 23			call macro_forth_dsp_pop 
39a5				endm 
# End of macro FORTH_DSP_POP
39a5			;		pop hl 
39a5 3e 00				ld a,0 
39a7 bd					cp l 
39a8 28 04				jr z, .not2t 
39aa 2e 00				ld l, 0 
39ac 18 02				jr .notip 
39ae			 
39ae 2e ff		.not2t:		ld l, 255 
39b0			 
39b0 26 00		.notip:		ld h, 0	 
39b2			 
39b2 cd 04 21				call forth_push_numhl 
39b5					NEXTW 
39b5 c3 b1 24			jp macro_next 
39b8				endm 
# End of macro NEXTW
39b8			 
39b8			.IS: 
39b8				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
39b8 2d				db WORD_SYS_CORE+25             
39b9 de 39			dw .LZERO            
39bb 03				db 2 + 1 
39bc .. 00			db "IS",0              
39bf				endm 
# End of macro CWHEAD
39bf			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
39bf					if DEBUG_FORTH_WORDS_KEY 
39bf						DMARK "IS." 
39bf f5				push af  
39c0 3a d4 39			ld a, (.dmark)  
39c3 32 68 fe			ld (debug_mark),a  
39c6 3a d5 39			ld a, (.dmark+1)  
39c9 32 69 fe			ld (debug_mark+1),a  
39cc 3a d6 39			ld a, (.dmark+2)  
39cf 32 6a fe			ld (debug_mark+2),a  
39d2 18 03			jr .pastdmark  
39d4 ..			.dmark: db "IS."  
39d7 f1			.pastdmark: pop af  
39d8			endm  
# End of macro DMARK
39d8						CALLMONITOR 
39d8 cd 6c fe			call debug_vector  
39db				endm  
# End of macro CALLMONITOR
39db					endif 
39db					NEXTW 
39db c3 b1 24			jp macro_next 
39de				endm 
# End of macro NEXTW
39de			.LZERO: 
39de				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
39de 2d				db WORD_SYS_CORE+25             
39df e8 39			dw .TZERO            
39e1 03				db 2 + 1 
39e2 .. 00			db "0<",0              
39e5				endm 
# End of macro CWHEAD
39e5			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
39e5					NEXTW 
39e5 c3 b1 24			jp macro_next 
39e8				endm 
# End of macro NEXTW
39e8			.TZERO: 
39e8				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
39e8 2e				db WORD_SYS_CORE+26             
39e9 2f 3a			dw .LESS            
39eb 03				db 2 + 1 
39ec .. 00			db "0=",0              
39ef				endm 
# End of macro CWHEAD
39ef			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
39ef				; TODO add floating point number detection 
39ef					;v5 FORTH_DSP_VALUE 
39ef					if DEBUG_FORTH_WORDS_KEY 
39ef						DMARK "0=." 
39ef f5				push af  
39f0 3a 04 3a			ld a, (.dmark)  
39f3 32 68 fe			ld (debug_mark),a  
39f6 3a 05 3a			ld a, (.dmark+1)  
39f9 32 69 fe			ld (debug_mark+1),a  
39fc 3a 06 3a			ld a, (.dmark+2)  
39ff 32 6a fe			ld (debug_mark+2),a  
3a02 18 03			jr .pastdmark  
3a04 ..			.dmark: db "0=."  
3a07 f1			.pastdmark: pop af  
3a08			endm  
# End of macro DMARK
3a08						CALLMONITOR 
3a08 cd 6c fe			call debug_vector  
3a0b				endm  
# End of macro CALLMONITOR
3a0b					endif 
3a0b					FORTH_DSP 
3a0b cd c1 22			call macro_forth_dsp 
3a0e				endm 
# End of macro FORTH_DSP
3a0e 7e					ld a,(hl)	; get type of value on TOS 
3a0f fe 02				cp DS_TYPE_INUM  
3a11 28 00				jr z, .tz_inum 
3a13			 
3a13				if FORTH_ENABLE_FLOATMATH 
3a13					jr .tz_done 
3a13			 
3a13				endif 
3a13					 
3a13			 
3a13			.tz_inum: 
3a13					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a13 cd fb 22			call macro_dsp_valuehl 
3a16				endm 
# End of macro FORTH_DSP_VALUEHL
3a16			 
3a16			;		push hl 
3a16			 
3a16					; destroy value TOS 
3a16			 
3a16					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a16 cd b3 23			call macro_forth_dsp_pop 
3a19				endm 
# End of macro FORTH_DSP_POP
3a19			 
3a19			;		pop hl 
3a19			 
3a19 3e 00				ld a,0 
3a1b			 
3a1b bd					cp l 
3a1c 20 08				jr nz, .tz_notzero 
3a1e			 
3a1e bc					cp h 
3a1f			 
3a1f 20 05				jr nz, .tz_notzero 
3a21			 
3a21			 
3a21 21 01 00				ld hl, FORTH_TRUE 
3a24 18 03				jr .tz_done 
3a26			 
3a26 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
3a29			 
3a29					; push value back onto stack for another op etc 
3a29			 
3a29			.tz_done: 
3a29 cd 04 21				call forth_push_numhl 
3a2c			 
3a2c					NEXTW 
3a2c c3 b1 24			jp macro_next 
3a2f				endm 
# End of macro NEXTW
3a2f			.LESS: 
3a2f				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3a2f 2f				db WORD_SYS_CORE+27             
3a30 98 3a			dw .GT            
3a32 02				db 1 + 1 
3a33 .. 00			db "<",0              
3a35				endm 
# End of macro CWHEAD
3a35			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3a35				; TODO add floating point number detection 
3a35					if DEBUG_FORTH_WORDS_KEY 
3a35						DMARK "LES" 
3a35 f5				push af  
3a36 3a 4a 3a			ld a, (.dmark)  
3a39 32 68 fe			ld (debug_mark),a  
3a3c 3a 4b 3a			ld a, (.dmark+1)  
3a3f 32 69 fe			ld (debug_mark+1),a  
3a42 3a 4c 3a			ld a, (.dmark+2)  
3a45 32 6a fe			ld (debug_mark+2),a  
3a48 18 03			jr .pastdmark  
3a4a ..			.dmark: db "LES"  
3a4d f1			.pastdmark: pop af  
3a4e			endm  
# End of macro DMARK
3a4e						CALLMONITOR 
3a4e cd 6c fe			call debug_vector  
3a51				endm  
# End of macro CALLMONITOR
3a51					endif 
3a51					FORTH_DSP 
3a51 cd c1 22			call macro_forth_dsp 
3a54				endm 
# End of macro FORTH_DSP
3a54					;v5 FORTH_DSP_VALUE 
3a54 7e					ld a,(hl)	; get type of value on TOS 
3a55 fe 02				cp DS_TYPE_INUM  
3a57 28 00				jr z, .less_inum 
3a59			 
3a59				if FORTH_ENABLE_FLOATMATH 
3a59					jr .less_done 
3a59			 
3a59				endif 
3a59					 
3a59			 
3a59			.less_inum: 
3a59					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a59 cd fb 22			call macro_dsp_valuehl 
3a5c				endm 
# End of macro FORTH_DSP_VALUEHL
3a5c			 
3a5c e5					push hl  ; u2 
3a5d			 
3a5d					; destroy value TOS 
3a5d			 
3a5d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a5d cd b3 23			call macro_forth_dsp_pop 
3a60				endm 
# End of macro FORTH_DSP_POP
3a60			 
3a60			 
3a60					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a60 cd fb 22			call macro_dsp_valuehl 
3a63				endm 
# End of macro FORTH_DSP_VALUEHL
3a63			 
3a63 e5					push hl    ; u1 
3a64			 
3a64					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a64 cd b3 23			call macro_forth_dsp_pop 
3a67				endm 
# End of macro FORTH_DSP_POP
3a67			 
3a67			 
3a67 b7			 or a      ;clear carry flag 
3a68 01 00 00		 ld bc, FORTH_FALSE 
3a6b e1			  pop hl    ; u1 
3a6c d1			  pop de    ; u2 
3a6d ed 52		  sbc hl,de 
3a6f 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
3a71			 
3a71 01 01 00		 ld bc, FORTH_TRUE 
3a74			.lscont:  
3a74 c5					push bc 
3a75 e1					pop hl 
3a76			 
3a76					if DEBUG_FORTH_WORDS 
3a76						DMARK "LT1" 
3a76 f5				push af  
3a77 3a 8b 3a			ld a, (.dmark)  
3a7a 32 68 fe			ld (debug_mark),a  
3a7d 3a 8c 3a			ld a, (.dmark+1)  
3a80 32 69 fe			ld (debug_mark+1),a  
3a83 3a 8d 3a			ld a, (.dmark+2)  
3a86 32 6a fe			ld (debug_mark+2),a  
3a89 18 03			jr .pastdmark  
3a8b ..			.dmark: db "LT1"  
3a8e f1			.pastdmark: pop af  
3a8f			endm  
# End of macro DMARK
3a8f						CALLMONITOR 
3a8f cd 6c fe			call debug_vector  
3a92				endm  
# End of macro CALLMONITOR
3a92					endif 
3a92 cd 04 21				call forth_push_numhl 
3a95			 
3a95					NEXTW 
3a95 c3 b1 24			jp macro_next 
3a98				endm 
# End of macro NEXTW
3a98			.GT: 
3a98				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
3a98 30				db WORD_SYS_CORE+28             
3a99 01 3b			dw .EQUAL            
3a9b 02				db 1 + 1 
3a9c .. 00			db ">",0              
3a9e				endm 
# End of macro CWHEAD
3a9e			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
3a9e				; TODO add floating point number detection 
3a9e					if DEBUG_FORTH_WORDS_KEY 
3a9e						DMARK "GRT" 
3a9e f5				push af  
3a9f 3a b3 3a			ld a, (.dmark)  
3aa2 32 68 fe			ld (debug_mark),a  
3aa5 3a b4 3a			ld a, (.dmark+1)  
3aa8 32 69 fe			ld (debug_mark+1),a  
3aab 3a b5 3a			ld a, (.dmark+2)  
3aae 32 6a fe			ld (debug_mark+2),a  
3ab1 18 03			jr .pastdmark  
3ab3 ..			.dmark: db "GRT"  
3ab6 f1			.pastdmark: pop af  
3ab7			endm  
# End of macro DMARK
3ab7						CALLMONITOR 
3ab7 cd 6c fe			call debug_vector  
3aba				endm  
# End of macro CALLMONITOR
3aba					endif 
3aba					FORTH_DSP 
3aba cd c1 22			call macro_forth_dsp 
3abd				endm 
# End of macro FORTH_DSP
3abd					;FORTH_DSP_VALUE 
3abd 7e					ld a,(hl)	; get type of value on TOS 
3abe fe 02				cp DS_TYPE_INUM  
3ac0 28 00				jr z, .gt_inum 
3ac2			 
3ac2				if FORTH_ENABLE_FLOATMATH 
3ac2					jr .gt_done 
3ac2			 
3ac2				endif 
3ac2					 
3ac2			 
3ac2			.gt_inum: 
3ac2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ac2 cd fb 22			call macro_dsp_valuehl 
3ac5				endm 
# End of macro FORTH_DSP_VALUEHL
3ac5			 
3ac5 e5					push hl  ; u2 
3ac6			 
3ac6					; destroy value TOS 
3ac6			 
3ac6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ac6 cd b3 23			call macro_forth_dsp_pop 
3ac9				endm 
# End of macro FORTH_DSP_POP
3ac9			 
3ac9			 
3ac9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ac9 cd fb 22			call macro_dsp_valuehl 
3acc				endm 
# End of macro FORTH_DSP_VALUEHL
3acc			 
3acc e5					push hl    ; u1 
3acd			 
3acd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3acd cd b3 23			call macro_forth_dsp_pop 
3ad0				endm 
# End of macro FORTH_DSP_POP
3ad0			 
3ad0			 
3ad0 b7			 or a      ;clear carry flag 
3ad1 01 00 00		 ld bc, FORTH_FALSE 
3ad4 e1			  pop hl    ; u1 
3ad5 d1			  pop de    ; u2 
3ad6 ed 52		  sbc hl,de 
3ad8 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
3ada			 
3ada 01 01 00		 ld bc, FORTH_TRUE 
3add			.gtcont:  
3add c5					push bc 
3ade e1					pop hl 
3adf			 
3adf					if DEBUG_FORTH_WORDS 
3adf						DMARK "GT1" 
3adf f5				push af  
3ae0 3a f4 3a			ld a, (.dmark)  
3ae3 32 68 fe			ld (debug_mark),a  
3ae6 3a f5 3a			ld a, (.dmark+1)  
3ae9 32 69 fe			ld (debug_mark+1),a  
3aec 3a f6 3a			ld a, (.dmark+2)  
3aef 32 6a fe			ld (debug_mark+2),a  
3af2 18 03			jr .pastdmark  
3af4 ..			.dmark: db "GT1"  
3af7 f1			.pastdmark: pop af  
3af8			endm  
# End of macro DMARK
3af8						CALLMONITOR 
3af8 cd 6c fe			call debug_vector  
3afb				endm  
# End of macro CALLMONITOR
3afb					endif 
3afb cd 04 21				call forth_push_numhl 
3afe			 
3afe					NEXTW 
3afe c3 b1 24			jp macro_next 
3b01				endm 
# End of macro NEXTW
3b01			.EQUAL: 
3b01				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3b01 31				db WORD_SYS_CORE+29             
3b02 6c 3b			dw .ENDLOGIC            
3b04 02				db 1 + 1 
3b05 .. 00			db "=",0              
3b07				endm 
# End of macro CWHEAD
3b07			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3b07				; TODO add floating point number detection 
3b07					if DEBUG_FORTH_WORDS_KEY 
3b07						DMARK "EQ." 
3b07 f5				push af  
3b08 3a 1c 3b			ld a, (.dmark)  
3b0b 32 68 fe			ld (debug_mark),a  
3b0e 3a 1d 3b			ld a, (.dmark+1)  
3b11 32 69 fe			ld (debug_mark+1),a  
3b14 3a 1e 3b			ld a, (.dmark+2)  
3b17 32 6a fe			ld (debug_mark+2),a  
3b1a 18 03			jr .pastdmark  
3b1c ..			.dmark: db "EQ."  
3b1f f1			.pastdmark: pop af  
3b20			endm  
# End of macro DMARK
3b20						CALLMONITOR 
3b20 cd 6c fe			call debug_vector  
3b23				endm  
# End of macro CALLMONITOR
3b23					endif 
3b23					FORTH_DSP 
3b23 cd c1 22			call macro_forth_dsp 
3b26				endm 
# End of macro FORTH_DSP
3b26					;v5 FORTH_DSP_VALUE 
3b26 7e					ld a,(hl)	; get type of value on TOS 
3b27 fe 02				cp DS_TYPE_INUM  
3b29 28 00				jr z, .eq_inum 
3b2b			 
3b2b				if FORTH_ENABLE_FLOATMATH 
3b2b					jr .eq_done 
3b2b			 
3b2b				endif 
3b2b					 
3b2b			 
3b2b			.eq_inum: 
3b2b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b2b cd fb 22			call macro_dsp_valuehl 
3b2e				endm 
# End of macro FORTH_DSP_VALUEHL
3b2e			 
3b2e e5					push hl 
3b2f			 
3b2f					; destroy value TOS 
3b2f			 
3b2f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b2f cd b3 23			call macro_forth_dsp_pop 
3b32				endm 
# End of macro FORTH_DSP_POP
3b32			 
3b32			 
3b32					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b32 cd fb 22			call macro_dsp_valuehl 
3b35				endm 
# End of macro FORTH_DSP_VALUEHL
3b35			 
3b35					; one value on hl get other one back 
3b35			 
3b35 e5					push hl 
3b36			 
3b36					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b36 cd b3 23			call macro_forth_dsp_pop 
3b39				endm 
# End of macro FORTH_DSP_POP
3b39			 
3b39 0e 00				ld c, FORTH_FALSE 
3b3b			 
3b3b e1					pop hl 
3b3c d1					pop de 
3b3d			 
3b3d 7b					ld a, e 
3b3e bd					cp l 
3b3f			 
3b3f 20 06				jr nz, .eq_done 
3b41			 
3b41 7a					ld a, d 
3b42 bc					cp h 
3b43			 
3b43 20 02				jr nz, .eq_done 
3b45			 
3b45 0e 01				ld c, FORTH_TRUE 
3b47					 
3b47			 
3b47			 
3b47			.eq_done: 
3b47			 
3b47					; TODO push value back onto stack for another op etc 
3b47			 
3b47 26 00				ld h, 0 
3b49 69					ld l, c 
3b4a					if DEBUG_FORTH_WORDS 
3b4a						DMARK "EQ1" 
3b4a f5				push af  
3b4b 3a 5f 3b			ld a, (.dmark)  
3b4e 32 68 fe			ld (debug_mark),a  
3b51 3a 60 3b			ld a, (.dmark+1)  
3b54 32 69 fe			ld (debug_mark+1),a  
3b57 3a 61 3b			ld a, (.dmark+2)  
3b5a 32 6a fe			ld (debug_mark+2),a  
3b5d 18 03			jr .pastdmark  
3b5f ..			.dmark: db "EQ1"  
3b62 f1			.pastdmark: pop af  
3b63			endm  
# End of macro DMARK
3b63						CALLMONITOR 
3b63 cd 6c fe			call debug_vector  
3b66				endm  
# End of macro CALLMONITOR
3b66					endif 
3b66 cd 04 21				call forth_push_numhl 
3b69			 
3b69					NEXTW 
3b69 c3 b1 24			jp macro_next 
3b6c				endm 
# End of macro NEXTW
3b6c			 
3b6c			 
3b6c			.ENDLOGIC: 
3b6c			; eof 
3b6c			 
3b6c			 
# End of file forth_words_logic.asm
3b6c			include "forth_words_maths.asm" 
3b6c			 
3b6c			; | ## Maths Words 
3b6c			 
3b6c			.PLUS:	 
3b6c				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3b6c 15				db WORD_SYS_CORE+1             
3b6d ca 3b			dw .NEG            
3b6f 02				db 1 + 1 
3b70 .. 00			db "+",0              
3b72				endm 
# End of macro CWHEAD
3b72			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3b72					if DEBUG_FORTH_WORDS_KEY 
3b72						DMARK "PLU" 
3b72 f5				push af  
3b73 3a 87 3b			ld a, (.dmark)  
3b76 32 68 fe			ld (debug_mark),a  
3b79 3a 88 3b			ld a, (.dmark+1)  
3b7c 32 69 fe			ld (debug_mark+1),a  
3b7f 3a 89 3b			ld a, (.dmark+2)  
3b82 32 6a fe			ld (debug_mark+2),a  
3b85 18 03			jr .pastdmark  
3b87 ..			.dmark: db "PLU"  
3b8a f1			.pastdmark: pop af  
3b8b			endm  
# End of macro DMARK
3b8b						CALLMONITOR 
3b8b cd 6c fe			call debug_vector  
3b8e				endm  
# End of macro CALLMONITOR
3b8e					endif 
3b8e					; add top two values and push back result 
3b8e			 
3b8e					;for v5 FORTH_DSP_VALUE 
3b8e					FORTH_DSP 
3b8e cd c1 22			call macro_forth_dsp 
3b91				endm 
# End of macro FORTH_DSP
3b91 7e					ld a,(hl)	; get type of value on TOS 
3b92 fe 02				cp DS_TYPE_INUM  
3b94 28 03				jr z, .dot_inum 
3b96			 
3b96					NEXTW 
3b96 c3 b1 24			jp macro_next 
3b99				endm 
# End of macro NEXTW
3b99			 
3b99			; float maths 
3b99			 
3b99				if FORTH_ENABLE_FLOATMATH 
3b99						inc hl      ; now at start of numeric as string 
3b99			 
3b99					if DEBUG_FORTH_MATHS 
3b99						DMARK "ADD" 
3b99				CALLMONITOR 
3b99					endif 
3b99			 
3b99					;ld ix, hl 
3b99					call CON 
3b99			 
3b99			 
3b99					push hl 
3b99					 
3b99					 
3b99			 
3b99						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
3b99			 
3b99					; get next number 
3b99			 
3b99						FORTH_DSP_VALUE 
3b99			 
3b99						inc hl      ; now at start of numeric as string 
3b99			 
3b99					;ld ix, hl 
3b99					call CON 
3b99			 
3b99					push hl 
3b99			 
3b99			 
3b99						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b99			 
3b99						; TODO do add 
3b99			 
3b99						call IADD 
3b99			 
3b99						; TODO get result back as ascii 
3b99			 
3b99						; TODO push result  
3b99			 
3b99			 
3b99			 
3b99						jr .dot_done 
3b99				endif 
3b99			 
3b99			.dot_inum: 
3b99			 
3b99			 
3b99					if DEBUG_FORTH_DOT 
3b99						DMARK "+IT" 
3b99 f5				push af  
3b9a 3a ae 3b			ld a, (.dmark)  
3b9d 32 68 fe			ld (debug_mark),a  
3ba0 3a af 3b			ld a, (.dmark+1)  
3ba3 32 69 fe			ld (debug_mark+1),a  
3ba6 3a b0 3b			ld a, (.dmark+2)  
3ba9 32 6a fe			ld (debug_mark+2),a  
3bac 18 03			jr .pastdmark  
3bae ..			.dmark: db "+IT"  
3bb1 f1			.pastdmark: pop af  
3bb2			endm  
# End of macro DMARK
3bb2				CALLMONITOR 
3bb2 cd 6c fe			call debug_vector  
3bb5				endm  
# End of macro CALLMONITOR
3bb5					endif 
3bb5			 
3bb5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3bb5 cd fb 22			call macro_dsp_valuehl 
3bb8				endm 
# End of macro FORTH_DSP_VALUEHL
3bb8			 
3bb8				; TODO add floating point number detection 
3bb8			 
3bb8 e5					push hl 
3bb9			 
3bb9					; destroy value TOS 
3bb9			 
3bb9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bb9 cd b3 23			call macro_forth_dsp_pop 
3bbc				endm 
# End of macro FORTH_DSP_POP
3bbc			 
3bbc			 
3bbc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3bbc cd fb 22			call macro_dsp_valuehl 
3bbf				endm 
# End of macro FORTH_DSP_VALUEHL
3bbf			 
3bbf					; one value on hl get other one back 
3bbf			 
3bbf d1					pop de 
3bc0			 
3bc0					; do the add 
3bc0			 
3bc0 19					add hl,de 
3bc1			 
3bc1					; save it 
3bc1			 
3bc1			;		push hl	 
3bc1			 
3bc1					; 
3bc1			 
3bc1					; destroy value TOS 
3bc1			 
3bc1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bc1 cd b3 23			call macro_forth_dsp_pop 
3bc4				endm 
# End of macro FORTH_DSP_POP
3bc4			 
3bc4					; TODO push value back onto stack for another op etc 
3bc4			 
3bc4			;		pop hl 
3bc4			 
3bc4			.dot_done: 
3bc4 cd 04 21				call forth_push_numhl 
3bc7			 
3bc7					NEXTW 
3bc7 c3 b1 24			jp macro_next 
3bca				endm 
# End of macro NEXTW
3bca			.NEG: 
3bca			 
3bca				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
3bca 17				db WORD_SYS_CORE+3             
3bcb 0d 3c			dw .DIV            
3bcd 02				db 1 + 1 
3bce .. 00			db "-",0              
3bd0				endm 
# End of macro CWHEAD
3bd0			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3bd0					if DEBUG_FORTH_WORDS_KEY 
3bd0						DMARK "SUB" 
3bd0 f5				push af  
3bd1 3a e5 3b			ld a, (.dmark)  
3bd4 32 68 fe			ld (debug_mark),a  
3bd7 3a e6 3b			ld a, (.dmark+1)  
3bda 32 69 fe			ld (debug_mark+1),a  
3bdd 3a e7 3b			ld a, (.dmark+2)  
3be0 32 6a fe			ld (debug_mark+2),a  
3be3 18 03			jr .pastdmark  
3be5 ..			.dmark: db "SUB"  
3be8 f1			.pastdmark: pop af  
3be9			endm  
# End of macro DMARK
3be9						CALLMONITOR 
3be9 cd 6c fe			call debug_vector  
3bec				endm  
# End of macro CALLMONITOR
3bec					endif 
3bec			 
3bec			 
3bec				; TODO add floating point number detection 
3bec					; v5 FORTH_DSP_VALUE 
3bec					FORTH_DSP 
3bec cd c1 22			call macro_forth_dsp 
3bef				endm 
# End of macro FORTH_DSP
3bef 7e					ld a,(hl)	; get type of value on TOS 
3bf0 fe 02				cp DS_TYPE_INUM  
3bf2 28 03				jr z, .neg_inum 
3bf4			 
3bf4					NEXTW 
3bf4 c3 b1 24			jp macro_next 
3bf7				endm 
# End of macro NEXTW
3bf7			 
3bf7			; float maths 
3bf7			 
3bf7				if FORTH_ENABLE_FLOATMATH 
3bf7					jr .neg_done 
3bf7			 
3bf7				endif 
3bf7					 
3bf7			 
3bf7			.neg_inum: 
3bf7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3bf7 cd fb 22			call macro_dsp_valuehl 
3bfa				endm 
# End of macro FORTH_DSP_VALUEHL
3bfa			 
3bfa e5					push hl 
3bfb			 
3bfb					; destroy value TOS 
3bfb			 
3bfb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bfb cd b3 23			call macro_forth_dsp_pop 
3bfe				endm 
# End of macro FORTH_DSP_POP
3bfe			 
3bfe			 
3bfe					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3bfe cd fb 22			call macro_dsp_valuehl 
3c01				endm 
# End of macro FORTH_DSP_VALUEHL
3c01			 
3c01					; one value on hl get other one back 
3c01			 
3c01 d1					pop de 
3c02			 
3c02					; do the sub 
3c02			;		ex de, hl 
3c02			 
3c02 ed 52				sbc hl,de 
3c04			 
3c04					; save it 
3c04			 
3c04			;		push hl	 
3c04			 
3c04					; 
3c04			 
3c04					; destroy value TOS 
3c04			 
3c04					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c04 cd b3 23			call macro_forth_dsp_pop 
3c07				endm 
# End of macro FORTH_DSP_POP
3c07			 
3c07					; TODO push value back onto stack for another op etc 
3c07			 
3c07			;		pop hl 
3c07			 
3c07 cd 04 21				call forth_push_numhl 
3c0a			.neg_done: 
3c0a			 
3c0a					NEXTW 
3c0a c3 b1 24			jp macro_next 
3c0d				endm 
# End of macro NEXTW
3c0d			.DIV: 
3c0d				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3c0d 18				db WORD_SYS_CORE+4             
3c0e 5a 3c			dw .MUL            
3c10 02				db 1 + 1 
3c11 .. 00			db "/",0              
3c13				endm 
# End of macro CWHEAD
3c13			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3c13					if DEBUG_FORTH_WORDS_KEY 
3c13						DMARK "DIV" 
3c13 f5				push af  
3c14 3a 28 3c			ld a, (.dmark)  
3c17 32 68 fe			ld (debug_mark),a  
3c1a 3a 29 3c			ld a, (.dmark+1)  
3c1d 32 69 fe			ld (debug_mark+1),a  
3c20 3a 2a 3c			ld a, (.dmark+2)  
3c23 32 6a fe			ld (debug_mark+2),a  
3c26 18 03			jr .pastdmark  
3c28 ..			.dmark: db "DIV"  
3c2b f1			.pastdmark: pop af  
3c2c			endm  
# End of macro DMARK
3c2c						CALLMONITOR 
3c2c cd 6c fe			call debug_vector  
3c2f				endm  
# End of macro CALLMONITOR
3c2f					endif 
3c2f				; TODO add floating point number detection 
3c2f					; v5 FORTH_DSP_VALUE 
3c2f					FORTH_DSP 
3c2f cd c1 22			call macro_forth_dsp 
3c32				endm 
# End of macro FORTH_DSP
3c32 7e					ld a,(hl)	; get type of value on TOS 
3c33 fe 02				cp DS_TYPE_INUM  
3c35 28 03				jr z, .div_inum 
3c37			 
3c37				if FORTH_ENABLE_FLOATMATH 
3c37					jr .div_done 
3c37			 
3c37				endif 
3c37					NEXTW 
3c37 c3 b1 24			jp macro_next 
3c3a				endm 
# End of macro NEXTW
3c3a			.div_inum: 
3c3a			 
3c3a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c3a cd fb 22			call macro_dsp_valuehl 
3c3d				endm 
# End of macro FORTH_DSP_VALUEHL
3c3d			 
3c3d e5					push hl    ; to go to bc 
3c3e			 
3c3e					; destroy value TOS 
3c3e			 
3c3e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c3e cd b3 23			call macro_forth_dsp_pop 
3c41				endm 
# End of macro FORTH_DSP_POP
3c41			 
3c41			 
3c41					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c41 cd fb 22			call macro_dsp_valuehl 
3c44				endm 
# End of macro FORTH_DSP_VALUEHL
3c44			 
3c44					; hl to go to de 
3c44			 
3c44 e5					push hl 
3c45			 
3c45 c1					pop bc 
3c46 d1					pop de		 
3c47			 
3c47			 
3c47					if DEBUG_FORTH_MATHS 
3c47						DMARK "DIV" 
3c47				CALLMONITOR 
3c47					endif 
3c47					; one value on hl but move to a get other one back 
3c47			 
3c47			        
3c47 cd 2d 0f			call Div16 
3c4a			 
3c4a			;	push af	 
3c4a e5				push hl 
3c4b c5				push bc 
3c4c			 
3c4c					if DEBUG_FORTH_MATHS 
3c4c						DMARK "DI1" 
3c4c				CALLMONITOR 
3c4c					endif 
3c4c			 
3c4c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c4c cd b3 23			call macro_forth_dsp_pop 
3c4f				endm 
# End of macro FORTH_DSP_POP
3c4f			 
3c4f			 
3c4f			 
3c4f e1					pop hl    ; result 
3c50			 
3c50 cd 04 21				call forth_push_numhl 
3c53			 
3c53 e1					pop hl    ; reminder 
3c54			;		ld h,0 
3c54			;		ld l,d 
3c54			 
3c54 cd 04 21				call forth_push_numhl 
3c57			.div_done: 
3c57					NEXTW 
3c57 c3 b1 24			jp macro_next 
3c5a				endm 
# End of macro NEXTW
3c5a			.MUL: 
3c5a				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3c5a 19				db WORD_SYS_CORE+5             
3c5b 9f 3c			dw .MIN            
3c5d 02				db 1 + 1 
3c5e .. 00			db "*",0              
3c60				endm 
# End of macro CWHEAD
3c60			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3c60				; TODO add floating point number detection 
3c60					if DEBUG_FORTH_WORDS_KEY 
3c60						DMARK "MUL" 
3c60 f5				push af  
3c61 3a 75 3c			ld a, (.dmark)  
3c64 32 68 fe			ld (debug_mark),a  
3c67 3a 76 3c			ld a, (.dmark+1)  
3c6a 32 69 fe			ld (debug_mark+1),a  
3c6d 3a 77 3c			ld a, (.dmark+2)  
3c70 32 6a fe			ld (debug_mark+2),a  
3c73 18 03			jr .pastdmark  
3c75 ..			.dmark: db "MUL"  
3c78 f1			.pastdmark: pop af  
3c79			endm  
# End of macro DMARK
3c79						CALLMONITOR 
3c79 cd 6c fe			call debug_vector  
3c7c				endm  
# End of macro CALLMONITOR
3c7c					endif 
3c7c					FORTH_DSP 
3c7c cd c1 22			call macro_forth_dsp 
3c7f				endm 
# End of macro FORTH_DSP
3c7f					; v5 FORTH_DSP_VALUE 
3c7f 7e					ld a,(hl)	; get type of value on TOS 
3c80 fe 02				cp DS_TYPE_INUM  
3c82 28 03				jr z, .mul_inum 
3c84			 
3c84				if FORTH_ENABLE_FLOATMATH 
3c84					jr .mul_done 
3c84			 
3c84				endif 
3c84			 
3c84					NEXTW 
3c84 c3 b1 24			jp macro_next 
3c87				endm 
# End of macro NEXTW
3c87			.mul_inum:	 
3c87			 
3c87					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c87 cd fb 22			call macro_dsp_valuehl 
3c8a				endm 
# End of macro FORTH_DSP_VALUEHL
3c8a			 
3c8a e5					push hl 
3c8b			 
3c8b					; destroy value TOS 
3c8b			 
3c8b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c8b cd b3 23			call macro_forth_dsp_pop 
3c8e				endm 
# End of macro FORTH_DSP_POP
3c8e			 
3c8e			 
3c8e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c8e cd fb 22			call macro_dsp_valuehl 
3c91				endm 
# End of macro FORTH_DSP_VALUEHL
3c91			 
3c91					; one value on hl but move to a get other one back 
3c91			 
3c91 7d					ld a, l 
3c92			 
3c92 d1					pop de 
3c93			 
3c93					; do the mull 
3c93			;		ex de, hl 
3c93			 
3c93 cd 53 0f				call Mult16 
3c96					; save it 
3c96			 
3c96			;		push hl	 
3c96			 
3c96					; 
3c96			 
3c96					; destroy value TOS 
3c96			 
3c96					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c96 cd b3 23			call macro_forth_dsp_pop 
3c99				endm 
# End of macro FORTH_DSP_POP
3c99			 
3c99					; TODO push value back onto stack for another op etc 
3c99			 
3c99			;		pop hl 
3c99			 
3c99 cd 04 21				call forth_push_numhl 
3c9c			 
3c9c			.mul_done: 
3c9c					NEXTW 
3c9c c3 b1 24			jp macro_next 
3c9f				endm 
# End of macro NEXTW
3c9f			 
3c9f			 
3c9f			 
3c9f			 
3c9f			.MIN: 
3c9f				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3c9f 49				db WORD_SYS_CORE+53             
3ca0 20 3d			dw .MAX            
3ca2 04				db 3 + 1 
3ca3 .. 00			db "MIN",0              
3ca7				endm 
# End of macro CWHEAD
3ca7			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3ca7					if DEBUG_FORTH_WORDS_KEY 
3ca7						DMARK "MIN" 
3ca7 f5				push af  
3ca8 3a bc 3c			ld a, (.dmark)  
3cab 32 68 fe			ld (debug_mark),a  
3cae 3a bd 3c			ld a, (.dmark+1)  
3cb1 32 69 fe			ld (debug_mark+1),a  
3cb4 3a be 3c			ld a, (.dmark+2)  
3cb7 32 6a fe			ld (debug_mark+2),a  
3cba 18 03			jr .pastdmark  
3cbc ..			.dmark: db "MIN"  
3cbf f1			.pastdmark: pop af  
3cc0			endm  
# End of macro DMARK
3cc0						CALLMONITOR 
3cc0 cd 6c fe			call debug_vector  
3cc3				endm  
# End of macro CALLMONITOR
3cc3					endif 
3cc3					; get u2 
3cc3			 
3cc3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3cc3 cd fb 22			call macro_dsp_valuehl 
3cc6				endm 
# End of macro FORTH_DSP_VALUEHL
3cc6			 
3cc6 e5					push hl   ; u2 
3cc7			 
3cc7					; destroy value TOS 
3cc7			 
3cc7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cc7 cd b3 23			call macro_forth_dsp_pop 
3cca				endm 
# End of macro FORTH_DSP_POP
3cca			 
3cca					; get u1 
3cca			 
3cca					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3cca cd fb 22			call macro_dsp_valuehl 
3ccd				endm 
# End of macro FORTH_DSP_VALUEHL
3ccd			 
3ccd e5					push hl  ; u1 
3cce			 
3cce					; destroy value TOS 
3cce			 
3cce					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cce cd b3 23			call macro_forth_dsp_pop 
3cd1				endm 
# End of macro FORTH_DSP_POP
3cd1			 
3cd1 b7			 or a      ;clear carry flag 
3cd2 e1			  pop hl    ; u1 
3cd3 d1			  pop de    ; u2 
3cd4 e5				push hl   ; saved in case hl is lowest 
3cd5 ed 52		  sbc hl,de 
3cd7 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3cd9			 
3cd9 e1				pop hl 
3cda					if DEBUG_FORTH_WORDS 
3cda						DMARK "MIN" 
3cda f5				push af  
3cdb 3a ef 3c			ld a, (.dmark)  
3cde 32 68 fe			ld (debug_mark),a  
3ce1 3a f0 3c			ld a, (.dmark+1)  
3ce4 32 69 fe			ld (debug_mark+1),a  
3ce7 3a f1 3c			ld a, (.dmark+2)  
3cea 32 6a fe			ld (debug_mark+2),a  
3ced 18 03			jr .pastdmark  
3cef ..			.dmark: db "MIN"  
3cf2 f1			.pastdmark: pop af  
3cf3			endm  
# End of macro DMARK
3cf3						CALLMONITOR 
3cf3 cd 6c fe			call debug_vector  
3cf6				endm  
# End of macro CALLMONITOR
3cf6					endif 
3cf6 cd 04 21				call forth_push_numhl 
3cf9			 
3cf9				       NEXTW 
3cf9 c3 b1 24			jp macro_next 
3cfc				endm 
# End of macro NEXTW
3cfc			 
3cfc			.mincont:  
3cfc c1				pop bc   ; tidy up 
3cfd eb				ex de , hl  
3cfe					if DEBUG_FORTH_WORDS 
3cfe						DMARK "MI1" 
3cfe f5				push af  
3cff 3a 13 3d			ld a, (.dmark)  
3d02 32 68 fe			ld (debug_mark),a  
3d05 3a 14 3d			ld a, (.dmark+1)  
3d08 32 69 fe			ld (debug_mark+1),a  
3d0b 3a 15 3d			ld a, (.dmark+2)  
3d0e 32 6a fe			ld (debug_mark+2),a  
3d11 18 03			jr .pastdmark  
3d13 ..			.dmark: db "MI1"  
3d16 f1			.pastdmark: pop af  
3d17			endm  
# End of macro DMARK
3d17						CALLMONITOR 
3d17 cd 6c fe			call debug_vector  
3d1a				endm  
# End of macro CALLMONITOR
3d1a					endif 
3d1a cd 04 21				call forth_push_numhl 
3d1d			 
3d1d				       NEXTW 
3d1d c3 b1 24			jp macro_next 
3d20				endm 
# End of macro NEXTW
3d20			.MAX: 
3d20				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3d20 4a				db WORD_SYS_CORE+54             
3d21 a1 3d			dw .RND16            
3d23 04				db 3 + 1 
3d24 .. 00			db "MAX",0              
3d28				endm 
# End of macro CWHEAD
3d28			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3d28					if DEBUG_FORTH_WORDS_KEY 
3d28						DMARK "MAX" 
3d28 f5				push af  
3d29 3a 3d 3d			ld a, (.dmark)  
3d2c 32 68 fe			ld (debug_mark),a  
3d2f 3a 3e 3d			ld a, (.dmark+1)  
3d32 32 69 fe			ld (debug_mark+1),a  
3d35 3a 3f 3d			ld a, (.dmark+2)  
3d38 32 6a fe			ld (debug_mark+2),a  
3d3b 18 03			jr .pastdmark  
3d3d ..			.dmark: db "MAX"  
3d40 f1			.pastdmark: pop af  
3d41			endm  
# End of macro DMARK
3d41						CALLMONITOR 
3d41 cd 6c fe			call debug_vector  
3d44				endm  
# End of macro CALLMONITOR
3d44					endif 
3d44					; get u2 
3d44			 
3d44					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d44 cd fb 22			call macro_dsp_valuehl 
3d47				endm 
# End of macro FORTH_DSP_VALUEHL
3d47			 
3d47 e5					push hl   ; u2 
3d48			 
3d48					; destroy value TOS 
3d48			 
3d48					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d48 cd b3 23			call macro_forth_dsp_pop 
3d4b				endm 
# End of macro FORTH_DSP_POP
3d4b			 
3d4b					; get u1 
3d4b			 
3d4b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d4b cd fb 22			call macro_dsp_valuehl 
3d4e				endm 
# End of macro FORTH_DSP_VALUEHL
3d4e			 
3d4e e5					push hl  ; u1 
3d4f			 
3d4f					; destroy value TOS 
3d4f			 
3d4f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d4f cd b3 23			call macro_forth_dsp_pop 
3d52				endm 
# End of macro FORTH_DSP_POP
3d52			 
3d52 b7			 or a      ;clear carry flag 
3d53 e1			  pop hl    ; u1 
3d54 d1			  pop de    ; u2 
3d55 e5				push hl   ; saved in case hl is lowest 
3d56 ed 52		  sbc hl,de 
3d58 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3d5a			 
3d5a e1				pop hl 
3d5b					if DEBUG_FORTH_WORDS 
3d5b						DMARK "MAX" 
3d5b f5				push af  
3d5c 3a 70 3d			ld a, (.dmark)  
3d5f 32 68 fe			ld (debug_mark),a  
3d62 3a 71 3d			ld a, (.dmark+1)  
3d65 32 69 fe			ld (debug_mark+1),a  
3d68 3a 72 3d			ld a, (.dmark+2)  
3d6b 32 6a fe			ld (debug_mark+2),a  
3d6e 18 03			jr .pastdmark  
3d70 ..			.dmark: db "MAX"  
3d73 f1			.pastdmark: pop af  
3d74			endm  
# End of macro DMARK
3d74						CALLMONITOR 
3d74 cd 6c fe			call debug_vector  
3d77				endm  
# End of macro CALLMONITOR
3d77					endif 
3d77 cd 04 21				call forth_push_numhl 
3d7a			 
3d7a				       NEXTW 
3d7a c3 b1 24			jp macro_next 
3d7d				endm 
# End of macro NEXTW
3d7d			 
3d7d			.maxcont:  
3d7d c1				pop bc   ; tidy up 
3d7e eb				ex de , hl  
3d7f					if DEBUG_FORTH_WORDS 
3d7f						DMARK "MA1" 
3d7f f5				push af  
3d80 3a 94 3d			ld a, (.dmark)  
3d83 32 68 fe			ld (debug_mark),a  
3d86 3a 95 3d			ld a, (.dmark+1)  
3d89 32 69 fe			ld (debug_mark+1),a  
3d8c 3a 96 3d			ld a, (.dmark+2)  
3d8f 32 6a fe			ld (debug_mark+2),a  
3d92 18 03			jr .pastdmark  
3d94 ..			.dmark: db "MA1"  
3d97 f1			.pastdmark: pop af  
3d98			endm  
# End of macro DMARK
3d98						CALLMONITOR 
3d98 cd 6c fe			call debug_vector  
3d9b				endm  
# End of macro CALLMONITOR
3d9b					endif 
3d9b cd 04 21				call forth_push_numhl 
3d9e				       NEXTW 
3d9e c3 b1 24			jp macro_next 
3da1				endm 
# End of macro NEXTW
3da1			 
3da1			.RND16: 
3da1				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3da1 4e				db WORD_SYS_CORE+58             
3da2 d0 3d			dw .RND8            
3da4 06				db 5 + 1 
3da5 .. 00			db "RND16",0              
3dab				endm 
# End of macro CWHEAD
3dab			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3dab					if DEBUG_FORTH_WORDS_KEY 
3dab						DMARK "R16" 
3dab f5				push af  
3dac 3a c0 3d			ld a, (.dmark)  
3daf 32 68 fe			ld (debug_mark),a  
3db2 3a c1 3d			ld a, (.dmark+1)  
3db5 32 69 fe			ld (debug_mark+1),a  
3db8 3a c2 3d			ld a, (.dmark+2)  
3dbb 32 6a fe			ld (debug_mark+2),a  
3dbe 18 03			jr .pastdmark  
3dc0 ..			.dmark: db "R16"  
3dc3 f1			.pastdmark: pop af  
3dc4			endm  
# End of macro DMARK
3dc4						CALLMONITOR 
3dc4 cd 6c fe			call debug_vector  
3dc7				endm  
# End of macro CALLMONITOR
3dc7					endif 
3dc7 cd f7 0e				call prng16  
3dca cd 04 21				call forth_push_numhl 
3dcd				       NEXTW 
3dcd c3 b1 24			jp macro_next 
3dd0				endm 
# End of macro NEXTW
3dd0			.RND8: 
3dd0				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3dd0 60				db WORD_SYS_CORE+76             
3dd1 05 3e			dw .RND            
3dd3 05				db 4 + 1 
3dd4 .. 00			db "RND8",0              
3dd9				endm 
# End of macro CWHEAD
3dd9			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3dd9					if DEBUG_FORTH_WORDS_KEY 
3dd9						DMARK "RN8" 
3dd9 f5				push af  
3dda 3a ee 3d			ld a, (.dmark)  
3ddd 32 68 fe			ld (debug_mark),a  
3de0 3a ef 3d			ld a, (.dmark+1)  
3de3 32 69 fe			ld (debug_mark+1),a  
3de6 3a f0 3d			ld a, (.dmark+2)  
3de9 32 6a fe			ld (debug_mark+2),a  
3dec 18 03			jr .pastdmark  
3dee ..			.dmark: db "RN8"  
3df1 f1			.pastdmark: pop af  
3df2			endm  
# End of macro DMARK
3df2						CALLMONITOR 
3df2 cd 6c fe			call debug_vector  
3df5				endm  
# End of macro CALLMONITOR
3df5					endif 
3df5 2a a6 fb				ld hl,(xrandc) 
3df8 23					inc hl 
3df9 cd 11 0f				call xrnd 
3dfc 6f					ld l,a	 
3dfd 26 00				ld h,0 
3dff cd 04 21				call forth_push_numhl 
3e02				       NEXTW 
3e02 c3 b1 24			jp macro_next 
3e05				endm 
# End of macro NEXTW
3e05			.RND: 
3e05				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3e05 60				db WORD_SYS_CORE+76             
3e06 0b 3f			dw .ENDMATHS            
3e08 04				db 3 + 1 
3e09 .. 00			db "RND",0              
3e0d				endm 
# End of macro CWHEAD
3e0d			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3e0d			 
3e0d					if DEBUG_FORTH_WORDS_KEY 
3e0d						DMARK "RND" 
3e0d f5				push af  
3e0e 3a 22 3e			ld a, (.dmark)  
3e11 32 68 fe			ld (debug_mark),a  
3e14 3a 23 3e			ld a, (.dmark+1)  
3e17 32 69 fe			ld (debug_mark+1),a  
3e1a 3a 24 3e			ld a, (.dmark+2)  
3e1d 32 6a fe			ld (debug_mark+2),a  
3e20 18 03			jr .pastdmark  
3e22 ..			.dmark: db "RND"  
3e25 f1			.pastdmark: pop af  
3e26			endm  
# End of macro DMARK
3e26						CALLMONITOR 
3e26 cd 6c fe			call debug_vector  
3e29				endm  
# End of macro CALLMONITOR
3e29					endif 
3e29					 
3e29					FORTH_DSP_VALUEHL    ; upper range 
3e29 cd fb 22			call macro_dsp_valuehl 
3e2c				endm 
# End of macro FORTH_DSP_VALUEHL
3e2c			 
3e2c 22 aa fb				ld (LFSRSeed), hl	 
3e2f			 
3e2f					if DEBUG_FORTH_WORDS 
3e2f						DMARK "RN1" 
3e2f f5				push af  
3e30 3a 44 3e			ld a, (.dmark)  
3e33 32 68 fe			ld (debug_mark),a  
3e36 3a 45 3e			ld a, (.dmark+1)  
3e39 32 69 fe			ld (debug_mark+1),a  
3e3c 3a 46 3e			ld a, (.dmark+2)  
3e3f 32 6a fe			ld (debug_mark+2),a  
3e42 18 03			jr .pastdmark  
3e44 ..			.dmark: db "RN1"  
3e47 f1			.pastdmark: pop af  
3e48			endm  
# End of macro DMARK
3e48						CALLMONITOR 
3e48 cd 6c fe			call debug_vector  
3e4b				endm  
# End of macro CALLMONITOR
3e4b					endif 
3e4b					FORTH_DSP_POP 
3e4b cd b3 23			call macro_forth_dsp_pop 
3e4e				endm 
# End of macro FORTH_DSP_POP
3e4e			 
3e4e					FORTH_DSP_VALUEHL    ; low range 
3e4e cd fb 22			call macro_dsp_valuehl 
3e51				endm 
# End of macro FORTH_DSP_VALUEHL
3e51			 
3e51					if DEBUG_FORTH_WORDS 
3e51						DMARK "RN2" 
3e51 f5				push af  
3e52 3a 66 3e			ld a, (.dmark)  
3e55 32 68 fe			ld (debug_mark),a  
3e58 3a 67 3e			ld a, (.dmark+1)  
3e5b 32 69 fe			ld (debug_mark+1),a  
3e5e 3a 68 3e			ld a, (.dmark+2)  
3e61 32 6a fe			ld (debug_mark+2),a  
3e64 18 03			jr .pastdmark  
3e66 ..			.dmark: db "RN2"  
3e69 f1			.pastdmark: pop af  
3e6a			endm  
# End of macro DMARK
3e6a						CALLMONITOR 
3e6a cd 6c fe			call debug_vector  
3e6d				endm  
# End of macro CALLMONITOR
3e6d					endif 
3e6d 22 ac fb				ld (LFSRSeed+2), hl 
3e70			 
3e70					FORTH_DSP_POP 
3e70 cd b3 23			call macro_forth_dsp_pop 
3e73				endm 
# End of macro FORTH_DSP_POP
3e73			 
3e73 e5					push hl 
3e74			 
3e74 e1			.inrange:	pop hl 
3e75 cd f7 0e				call prng16  
3e78					if DEBUG_FORTH_WORDS 
3e78						DMARK "RN3" 
3e78 f5				push af  
3e79 3a 8d 3e			ld a, (.dmark)  
3e7c 32 68 fe			ld (debug_mark),a  
3e7f 3a 8e 3e			ld a, (.dmark+1)  
3e82 32 69 fe			ld (debug_mark+1),a  
3e85 3a 8f 3e			ld a, (.dmark+2)  
3e88 32 6a fe			ld (debug_mark+2),a  
3e8b 18 03			jr .pastdmark  
3e8d ..			.dmark: db "RN3"  
3e90 f1			.pastdmark: pop af  
3e91			endm  
# End of macro DMARK
3e91						CALLMONITOR 
3e91 cd 6c fe			call debug_vector  
3e94				endm  
# End of macro CALLMONITOR
3e94					endif 
3e94					 
3e94					; if the range is 8bit knock out the high byte 
3e94			 
3e94 ed 5b aa fb			ld de, (LFSRSeed)     ; check high level 
3e98			 
3e98 3e 00				ld a, 0 
3e9a ba					cp d  
3e9b 20 1e				jr nz, .hirange 
3e9d 26 00				ld h, 0   ; knock it down to 8bit 
3e9f			 
3e9f					if DEBUG_FORTH_WORDS 
3e9f						DMARK "RNk" 
3e9f f5				push af  
3ea0 3a b4 3e			ld a, (.dmark)  
3ea3 32 68 fe			ld (debug_mark),a  
3ea6 3a b5 3e			ld a, (.dmark+1)  
3ea9 32 69 fe			ld (debug_mark+1),a  
3eac 3a b6 3e			ld a, (.dmark+2)  
3eaf 32 6a fe			ld (debug_mark+2),a  
3eb2 18 03			jr .pastdmark  
3eb4 ..			.dmark: db "RNk"  
3eb7 f1			.pastdmark: pop af  
3eb8			endm  
# End of macro DMARK
3eb8						CALLMONITOR 
3eb8 cd 6c fe			call debug_vector  
3ebb				endm  
# End of macro CALLMONITOR
3ebb					endif 
3ebb			.hirange:   
3ebb e5					push hl  
3ebc b7					or a  
3ebd ed 52		                sbc hl, de 
3ebf			 
3ebf					;call cmp16 
3ebf			 
3ebf 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3ec1 e1					pop hl 
3ec2 e5					push hl 
3ec3			 
3ec3					if DEBUG_FORTH_WORDS 
3ec3						DMARK "RN4" 
3ec3 f5				push af  
3ec4 3a d8 3e			ld a, (.dmark)  
3ec7 32 68 fe			ld (debug_mark),a  
3eca 3a d9 3e			ld a, (.dmark+1)  
3ecd 32 69 fe			ld (debug_mark+1),a  
3ed0 3a da 3e			ld a, (.dmark+2)  
3ed3 32 6a fe			ld (debug_mark+2),a  
3ed6 18 03			jr .pastdmark  
3ed8 ..			.dmark: db "RN4"  
3edb f1			.pastdmark: pop af  
3edc			endm  
# End of macro DMARK
3edc						CALLMONITOR 
3edc cd 6c fe			call debug_vector  
3edf				endm  
# End of macro CALLMONITOR
3edf					endif 
3edf ed 5b ac fb			ld de, (LFSRSeed+2)   ; check low range 
3ee3					;call cmp16 
3ee3				 
3ee3 b7					or a  
3ee4 ed 52		                sbc hl, de 
3ee6 38 8c				jr c, .inrange 
3ee8			 
3ee8 e1					pop hl 
3ee9					 
3ee9					if DEBUG_FORTH_WORDS 
3ee9						DMARK "RNd" 
3ee9 f5				push af  
3eea 3a fe 3e			ld a, (.dmark)  
3eed 32 68 fe			ld (debug_mark),a  
3ef0 3a ff 3e			ld a, (.dmark+1)  
3ef3 32 69 fe			ld (debug_mark+1),a  
3ef6 3a 00 3f			ld a, (.dmark+2)  
3ef9 32 6a fe			ld (debug_mark+2),a  
3efc 18 03			jr .pastdmark  
3efe ..			.dmark: db "RNd"  
3f01 f1			.pastdmark: pop af  
3f02			endm  
# End of macro DMARK
3f02						CALLMONITOR 
3f02 cd 6c fe			call debug_vector  
3f05				endm  
# End of macro CALLMONITOR
3f05					endif 
3f05			 
3f05			 
3f05 cd 04 21				call forth_push_numhl 
3f08				       NEXTW 
3f08 c3 b1 24			jp macro_next 
3f0b				endm 
# End of macro NEXTW
3f0b			 
3f0b			.ENDMATHS: 
3f0b			 
3f0b			; eof 
3f0b			 
# End of file forth_words_maths.asm
3f0b			include "forth_words_display.asm" 
3f0b			 
3f0b			; | ## Display Words 
3f0b			 
3f0b			.ACT: 
3f0b			 
3f0b				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
3f0b 62				db WORD_SYS_CORE+78             
3f0c 57 3f			dw .INFO            
3f0e 07				db 6 + 1 
3f0f .. 00			db "ACTIVE",0              
3f16				endm 
# End of macro CWHEAD
3f16			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
3f16			;  
3f16			; | | e.g. $ff $00 do active . $01 pause loop 
3f16			 
3f16					if DEBUG_FORTH_WORDS_KEY 
3f16						DMARK "ACT" 
3f16 f5				push af  
3f17 3a 2b 3f			ld a, (.dmark)  
3f1a 32 68 fe			ld (debug_mark),a  
3f1d 3a 2c 3f			ld a, (.dmark+1)  
3f20 32 69 fe			ld (debug_mark+1),a  
3f23 3a 2d 3f			ld a, (.dmark+2)  
3f26 32 6a fe			ld (debug_mark+2),a  
3f29 18 03			jr .pastdmark  
3f2b ..			.dmark: db "ACT"  
3f2e f1			.pastdmark: pop af  
3f2f			endm  
# End of macro DMARK
3f2f						CALLMONITOR 
3f2f cd 6c fe			call debug_vector  
3f32				endm  
# End of macro CALLMONITOR
3f32					endif 
3f32 cd f3 0c				call active 
3f35					if DEBUG_FORTH_WORDS 
3f35						DMARK "ACp" 
3f35 f5				push af  
3f36 3a 4a 3f			ld a, (.dmark)  
3f39 32 68 fe			ld (debug_mark),a  
3f3c 3a 4b 3f			ld a, (.dmark+1)  
3f3f 32 69 fe			ld (debug_mark+1),a  
3f42 3a 4c 3f			ld a, (.dmark+2)  
3f45 32 6a fe			ld (debug_mark+2),a  
3f48 18 03			jr .pastdmark  
3f4a ..			.dmark: db "ACp"  
3f4d f1			.pastdmark: pop af  
3f4e			endm  
# End of macro DMARK
3f4e						CALLMONITOR 
3f4e cd 6c fe			call debug_vector  
3f51				endm  
# End of macro CALLMONITOR
3f51					endif 
3f51 cd 72 21				call forth_push_str 
3f54			 
3f54					NEXTW 
3f54 c3 b1 24			jp macro_next 
3f57				endm 
# End of macro NEXTW
3f57			.INFO: 
3f57			 
3f57				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3f57 62				db WORD_SYS_CORE+78             
3f58 74 3f			dw .ATP            
3f5a 05				db 4 + 1 
3f5b .. 00			db "INFO",0              
3f60				endm 
# End of macro CWHEAD
3f60			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3f60					FORTH_DSP_VALUEHL 
3f60 cd fb 22			call macro_dsp_valuehl 
3f63				endm 
# End of macro FORTH_DSP_VALUEHL
3f63			 
3f63					FORTH_DSP_POP 
3f63 cd b3 23			call macro_forth_dsp_pop 
3f66				endm 
# End of macro FORTH_DSP_POP
3f66			 
3f66 e5					push hl 
3f67			 
3f67					FORTH_DSP_VALUEHL 
3f67 cd fb 22			call macro_dsp_valuehl 
3f6a				endm 
# End of macro FORTH_DSP_VALUEHL
3f6a			 
3f6a					FORTH_DSP_POP 
3f6a cd b3 23			call macro_forth_dsp_pop 
3f6d				endm 
# End of macro FORTH_DSP_POP
3f6d			 
3f6d d1					pop de 
3f6e			 
3f6e cd 2d 0d				call info_panel 
3f71			 
3f71			 
3f71					NEXTW 
3f71 c3 b1 24			jp macro_next 
3f74				endm 
# End of macro NEXTW
3f74			.ATP: 
3f74				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3f74 62				db WORD_SYS_CORE+78             
3f75 eb 3f			dw .FB            
3f77 04				db 3 + 1 
3f78 .. 00			db "AT?",0              
3f7c				endm 
# End of macro CWHEAD
3f7c			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3f7c					if DEBUG_FORTH_WORDS_KEY 
3f7c						DMARK "AT?" 
3f7c f5				push af  
3f7d 3a 91 3f			ld a, (.dmark)  
3f80 32 68 fe			ld (debug_mark),a  
3f83 3a 92 3f			ld a, (.dmark+1)  
3f86 32 69 fe			ld (debug_mark+1),a  
3f89 3a 93 3f			ld a, (.dmark+2)  
3f8c 32 6a fe			ld (debug_mark+2),a  
3f8f 18 03			jr .pastdmark  
3f91 ..			.dmark: db "AT?"  
3f94 f1			.pastdmark: pop af  
3f95			endm  
# End of macro DMARK
3f95						CALLMONITOR 
3f95 cd 6c fe			call debug_vector  
3f98				endm  
# End of macro CALLMONITOR
3f98					endif 
3f98 3a 5b fa				ld a, (f_cursor_ptr) 
3f9b			 
3f9b			if DEBUG_FORTH_WORDS 
3f9b				DMARK "AT?" 
3f9b f5				push af  
3f9c 3a b0 3f			ld a, (.dmark)  
3f9f 32 68 fe			ld (debug_mark),a  
3fa2 3a b1 3f			ld a, (.dmark+1)  
3fa5 32 69 fe			ld (debug_mark+1),a  
3fa8 3a b2 3f			ld a, (.dmark+2)  
3fab 32 6a fe			ld (debug_mark+2),a  
3fae 18 03			jr .pastdmark  
3fb0 ..			.dmark: db "AT?"  
3fb3 f1			.pastdmark: pop af  
3fb4			endm  
# End of macro DMARK
3fb4				CALLMONITOR 
3fb4 cd 6c fe			call debug_vector  
3fb7				endm  
# End of macro CALLMONITOR
3fb7			endif	 
3fb7					; count the number of rows 
3fb7			 
3fb7 06 00				ld b, 0 
3fb9 4f			.atpr:		ld c, a    ; save in case we go below zero 
3fba d6 28				sub display_cols 
3fbc f2 c2 3f				jp p, .atprunder 
3fbf 04					inc b 
3fc0 18 f7				jr .atpr 
3fc2			.atprunder:	 
3fc2			if DEBUG_FORTH_WORDS 
3fc2				DMARK "A?2" 
3fc2 f5				push af  
3fc3 3a d7 3f			ld a, (.dmark)  
3fc6 32 68 fe			ld (debug_mark),a  
3fc9 3a d8 3f			ld a, (.dmark+1)  
3fcc 32 69 fe			ld (debug_mark+1),a  
3fcf 3a d9 3f			ld a, (.dmark+2)  
3fd2 32 6a fe			ld (debug_mark+2),a  
3fd5 18 03			jr .pastdmark  
3fd7 ..			.dmark: db "A?2"  
3fda f1			.pastdmark: pop af  
3fdb			endm  
# End of macro DMARK
3fdb				CALLMONITOR 
3fdb cd 6c fe			call debug_vector  
3fde				endm  
# End of macro CALLMONITOR
3fde			endif	 
3fde 26 00				ld h, 0 
3fe0 69					ld l, c 
3fe1 cd 04 21				call forth_push_numhl 
3fe4 68					ld l, b  
3fe5 cd 04 21				call forth_push_numhl 
3fe8			 
3fe8			 
3fe8				NEXTW 
3fe8 c3 b1 24			jp macro_next 
3feb				endm 
# End of macro NEXTW
3feb			 
3feb			.FB: 
3feb				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3feb 1b				db WORD_SYS_CORE+7             
3fec 39 40			dw .EMIT            
3fee 03				db 2 + 1 
3fef .. 00			db "FB",0              
3ff2				endm 
# End of macro CWHEAD
3ff2			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3ff2			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3ff2			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3ff2			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3ff2					if DEBUG_FORTH_WORDS_KEY 
3ff2						DMARK "FB." 
3ff2 f5				push af  
3ff3 3a 07 40			ld a, (.dmark)  
3ff6 32 68 fe			ld (debug_mark),a  
3ff9 3a 08 40			ld a, (.dmark+1)  
3ffc 32 69 fe			ld (debug_mark+1),a  
3fff 3a 09 40			ld a, (.dmark+2)  
4002 32 6a fe			ld (debug_mark+2),a  
4005 18 03			jr .pastdmark  
4007 ..			.dmark: db "FB."  
400a f1			.pastdmark: pop af  
400b			endm  
# End of macro DMARK
400b						CALLMONITOR 
400b cd 6c fe			call debug_vector  
400e				endm  
# End of macro CALLMONITOR
400e					endif 
400e			 
400e					FORTH_DSP_VALUEHL 
400e cd fb 22			call macro_dsp_valuehl 
4011				endm 
# End of macro FORTH_DSP_VALUEHL
4011			 
4011 7d					ld a, l 
4012 fe 01				cp 1 
4014 20 05				jr nz, .fbn1 
4016 21 0d fd				ld hl, display_fb1 
4019 18 15				jr .fbset 
401b fe 02		.fbn1:		cp 2 
401d 20 05				jr nz, .fbn2 
401f 21 cb fb				ld hl, display_fb2 
4022 18 0c				jr .fbset 
4024 fe 03		.fbn2:		cp 3 
4026 20 05				jr nz, .fbn3 
4028 21 6c fc				ld hl, display_fb3 
402b 18 03				jr .fbset 
402d			.fbn3:		 ; if invalid number select first 
402d 21 0d fd				ld hl, display_fb1 
4030 22 c9 fb		.fbset:		ld (display_fb_active), hl 
4033			 
4033					FORTH_DSP_POP 
4033 cd b3 23			call macro_forth_dsp_pop 
4036				endm 
# End of macro FORTH_DSP_POP
4036			 
4036					NEXTW 
4036 c3 b1 24			jp macro_next 
4039				endm 
# End of macro NEXTW
4039			 
4039			 
4039			.EMIT: 
4039				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
4039 1b				db WORD_SYS_CORE+7             
403a 8a 40			dw .DOTH            
403c 05				db 4 + 1 
403d .. 00			db "EMIT",0              
4042				endm 
# End of macro CWHEAD
4042			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
4042					; get value off TOS and display it 
4042			 
4042					if DEBUG_FORTH_WORDS_KEY 
4042						DMARK "EMT" 
4042 f5				push af  
4043 3a 57 40			ld a, (.dmark)  
4046 32 68 fe			ld (debug_mark),a  
4049 3a 58 40			ld a, (.dmark+1)  
404c 32 69 fe			ld (debug_mark+1),a  
404f 3a 59 40			ld a, (.dmark+2)  
4052 32 6a fe			ld (debug_mark+2),a  
4055 18 03			jr .pastdmark  
4057 ..			.dmark: db "EMT"  
405a f1			.pastdmark: pop af  
405b			endm  
# End of macro DMARK
405b						CALLMONITOR 
405b cd 6c fe			call debug_vector  
405e				endm  
# End of macro CALLMONITOR
405e					endif 
405e			 
405e					FORTH_DSP_VALUEHL 
405e cd fb 22			call macro_dsp_valuehl 
4061				endm 
# End of macro FORTH_DSP_VALUEHL
4061			 
4061 7d					ld a,l 
4062			 
4062					; TODO write to display 
4062			 
4062 32 bc f3				ld (os_input), a 
4065 3e 00				ld a, 0 
4067 32 bd f3				ld (os_input+1), a 
406a					 
406a 3a 5b fa				ld a, (f_cursor_ptr) 
406d 11 bc f3				ld de, os_input 
4070 cd af 0d				call str_at_display 
4073			 
4073			 
4073 3a 39 fa				ld a,(cli_autodisplay) 
4076 fe 00				cp 0 
4078 28 03				jr z, .enoupdate 
407a cd bf 0d						call update_display 
407d					.enoupdate: 
407d			 
407d 3a 5b fa				ld a, (f_cursor_ptr) 
4080 3c					inc a 
4081 32 5b fa				ld (f_cursor_ptr), a   ; save new pos 
4084			 
4084			 
4084					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4084 cd b3 23			call macro_forth_dsp_pop 
4087				endm 
# End of macro FORTH_DSP_POP
4087			  
4087			 
4087					NEXTW 
4087 c3 b1 24			jp macro_next 
408a				endm 
# End of macro NEXTW
408a			.DOTH: 
408a				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
408a 1c				db WORD_SYS_CORE+8             
408b ba 40			dw .DOTF            
408d 03				db 2 + 1 
408e .. 00			db ".-",0              
4091				endm 
# End of macro CWHEAD
4091			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
4091					; get value off TOS and display it 
4091					if DEBUG_FORTH_WORDS_KEY 
4091						DMARK "DTD" 
4091 f5				push af  
4092 3a a6 40			ld a, (.dmark)  
4095 32 68 fe			ld (debug_mark),a  
4098 3a a7 40			ld a, (.dmark+1)  
409b 32 69 fe			ld (debug_mark+1),a  
409e 3a a8 40			ld a, (.dmark+2)  
40a1 32 6a fe			ld (debug_mark+2),a  
40a4 18 03			jr .pastdmark  
40a6 ..			.dmark: db "DTD"  
40a9 f1			.pastdmark: pop af  
40aa			endm  
# End of macro DMARK
40aa						CALLMONITOR 
40aa cd 6c fe			call debug_vector  
40ad				endm  
# End of macro CALLMONITOR
40ad					endif 
40ad 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
40af 3e 00			ld a, 0 
40b1 32 3a fa			ld (cli_mvdot), a 
40b4 c3 11 41			jp .dotgo 
40b7				NEXTW 
40b7 c3 b1 24			jp macro_next 
40ba				endm 
# End of macro NEXTW
40ba			.DOTF: 
40ba				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
40ba 1c				db WORD_SYS_CORE+8             
40bb e8 40			dw .DOT            
40bd 03				db 2 + 1 
40be .. 00			db ".>",0              
40c1				endm 
# End of macro CWHEAD
40c1			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
40c1					; get value off TOS and display it 
40c1			        ; TODO BUG adds extra spaces 
40c1			        ; TODO BUG handle numerics? 
40c1					if DEBUG_FORTH_WORDS_KEY 
40c1						DMARK "DTC" 
40c1 f5				push af  
40c2 3a d6 40			ld a, (.dmark)  
40c5 32 68 fe			ld (debug_mark),a  
40c8 3a d7 40			ld a, (.dmark+1)  
40cb 32 69 fe			ld (debug_mark+1),a  
40ce 3a d8 40			ld a, (.dmark+2)  
40d1 32 6a fe			ld (debug_mark+2),a  
40d4 18 03			jr .pastdmark  
40d6 ..			.dmark: db "DTC"  
40d9 f1			.pastdmark: pop af  
40da			endm  
# End of macro DMARK
40da						CALLMONITOR 
40da cd 6c fe			call debug_vector  
40dd				endm  
# End of macro CALLMONITOR
40dd					endif 
40dd 3e 01			ld a, 1 
40df 32 3a fa			ld (cli_mvdot), a 
40e2 c3 11 41			jp .dotgo 
40e5				NEXTW 
40e5 c3 b1 24			jp macro_next 
40e8				endm 
# End of macro NEXTW
40e8			 
40e8			.DOT: 
40e8				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
40e8 1c				db WORD_SYS_CORE+8             
40e9 c4 42			dw .CLS            
40eb 02				db 1 + 1 
40ec .. 00			db ".",0              
40ee				endm 
# End of macro CWHEAD
40ee			        ; | . ( u -- ) Display TOS | DONE 
40ee					; get value off TOS and display it 
40ee			 
40ee					if DEBUG_FORTH_WORDS_KEY 
40ee						DMARK "DOT" 
40ee f5				push af  
40ef 3a 03 41			ld a, (.dmark)  
40f2 32 68 fe			ld (debug_mark),a  
40f5 3a 04 41			ld a, (.dmark+1)  
40f8 32 69 fe			ld (debug_mark+1),a  
40fb 3a 05 41			ld a, (.dmark+2)  
40fe 32 6a fe			ld (debug_mark+2),a  
4101 18 03			jr .pastdmark  
4103 ..			.dmark: db "DOT"  
4106 f1			.pastdmark: pop af  
4107			endm  
# End of macro DMARK
4107						CALLMONITOR 
4107 cd 6c fe			call debug_vector  
410a				endm  
# End of macro CALLMONITOR
410a					endif 
410a 3e 00			ld a, 0 
410c 32 3a fa			ld (cli_mvdot), a 
410f 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
4111				 
4111			 
4111			.dotgo: 
4111			 
4111			; move up type to on stack for parserv5 
4111					FORTH_DSP 
4111 cd c1 22			call macro_forth_dsp 
4114				endm 
# End of macro FORTH_DSP
4114				;FORTH_DSP_VALUE  
4114			 
4114			if DEBUG_FORTH_DOT 
4114				DMARK "DOT" 
4114 f5				push af  
4115 3a 29 41			ld a, (.dmark)  
4118 32 68 fe			ld (debug_mark),a  
411b 3a 2a 41			ld a, (.dmark+1)  
411e 32 69 fe			ld (debug_mark+1),a  
4121 3a 2b 41			ld a, (.dmark+2)  
4124 32 6a fe			ld (debug_mark+2),a  
4127 18 03			jr .pastdmark  
4129 ..			.dmark: db "DOT"  
412c f1			.pastdmark: pop af  
412d			endm  
# End of macro DMARK
412d				CALLMONITOR 
412d cd 6c fe			call debug_vector  
4130				endm  
# End of macro CALLMONITOR
4130			endif	 
4130			;		.print: 
4130			 
4130 7e				ld a,(hl)  ; work out what type of value is on the TOS 
4131 23				inc hl   ; position to the actual value 
4132 fe 01			cp DS_TYPE_STR 
4134 20 06			jr nz, .dotnum1  
4136			 
4136			; display string 
4136				FORTH_DSP_VALUE  
4136 cd e4 22			call macro_forth_dsp_value 
4139				endm 
# End of macro FORTH_DSP_VALUE
4139 eb				ex de,hl 
413a 18 49			jr .dotwrite 
413c			 
413c			.dotnum1: 
413c fe 02			cp DS_TYPE_INUM 
413e 20 44			jr nz, .dotflot 
4140			 
4140			 
4140			; display number 
4140			 
4140			;	push hl 
4140			;	call clear_display 
4140			;	pop hl 
4140			 
4140 5e				ld e, (hl) 
4141 23				inc hl 
4142 56				ld d, (hl) 
4143 21 be f1			ld hl, scratch 
4146			if DEBUG_FORTH_DOT 
4146				DMARK "DT1" 
4146 f5				push af  
4147 3a 5b 41			ld a, (.dmark)  
414a 32 68 fe			ld (debug_mark),a  
414d 3a 5c 41			ld a, (.dmark+1)  
4150 32 69 fe			ld (debug_mark+1),a  
4153 3a 5d 41			ld a, (.dmark+2)  
4156 32 6a fe			ld (debug_mark+2),a  
4159 18 03			jr .pastdmark  
415b ..			.dmark: db "DT1"  
415e f1			.pastdmark: pop af  
415f			endm  
# End of macro DMARK
415f				CALLMONITOR 
415f cd 6c fe			call debug_vector  
4162				endm  
# End of macro CALLMONITOR
4162			endif	 
4162			 
4162 cd dd 13			call uitoa_16 
4165 eb				ex de,hl 
4166			 
4166			if DEBUG_FORTH_DOT 
4166				DMARK "DT2" 
4166 f5				push af  
4167 3a 7b 41			ld a, (.dmark)  
416a 32 68 fe			ld (debug_mark),a  
416d 3a 7c 41			ld a, (.dmark+1)  
4170 32 69 fe			ld (debug_mark+1),a  
4173 3a 7d 41			ld a, (.dmark+2)  
4176 32 6a fe			ld (debug_mark+2),a  
4179 18 03			jr .pastdmark  
417b ..			.dmark: db "DT2"  
417e f1			.pastdmark: pop af  
417f			endm  
# End of macro DMARK
417f				CALLMONITOR 
417f cd 6c fe			call debug_vector  
4182				endm  
# End of macro CALLMONITOR
4182			endif	 
4182			 
4182			;	ld de, os_word_scratch 
4182 18 01			jr .dotwrite 
4184			 
4184 00			.dotflot:   nop 
4185			; TODO print floating point number 
4185			 
4185			.dotwrite:		 
4185			 
4185					; if c is set then set all '-' to spaces 
4185					; need to also take into account .>  
4185			 
4185 3e 01				ld a, 1 
4187 b9					cp c 
4188 20 67				jr nz, .nodashswap 
418a			 
418a					; DE has the string to write, working with HL 
418a			 
418a 06 ff				ld b, 255 
418c d5					push de 
418d e1					pop hl 
418e			 
418e			if DEBUG_FORTH_DOT 
418e				DMARK "DT-" 
418e f5				push af  
418f 3a a3 41			ld a, (.dmark)  
4192 32 68 fe			ld (debug_mark),a  
4195 3a a4 41			ld a, (.dmark+1)  
4198 32 69 fe			ld (debug_mark+1),a  
419b 3a a5 41			ld a, (.dmark+2)  
419e 32 6a fe			ld (debug_mark+2),a  
41a1 18 03			jr .pastdmark  
41a3 ..			.dmark: db "DT-"  
41a6 f1			.pastdmark: pop af  
41a7			endm  
# End of macro DMARK
41a7				CALLMONITOR 
41a7 cd 6c fe			call debug_vector  
41aa				endm  
# End of macro CALLMONITOR
41aa			endif	 
41aa 7e			.dashscan:	ld a, (hl) 
41ab fe 00				cp 0 
41ad 28 42				jr z, .nodashswap 
41af fe 2d				cp '-' 
41b1 20 03				jr nz, .dashskip 
41b3 3e 20				ld a, ' ' 
41b5 77					ld (hl), a 
41b6 23			.dashskip:	inc hl 
41b7			if DEBUG_FORTH_DOT 
41b7				DMARK "D-2" 
41b7 f5				push af  
41b8 3a cc 41			ld a, (.dmark)  
41bb 32 68 fe			ld (debug_mark),a  
41be 3a cd 41			ld a, (.dmark+1)  
41c1 32 69 fe			ld (debug_mark+1),a  
41c4 3a ce 41			ld a, (.dmark+2)  
41c7 32 6a fe			ld (debug_mark+2),a  
41ca 18 03			jr .pastdmark  
41cc ..			.dmark: db "D-2"  
41cf f1			.pastdmark: pop af  
41d0			endm  
# End of macro DMARK
41d0				CALLMONITOR 
41d0 cd 6c fe			call debug_vector  
41d3				endm  
# End of macro CALLMONITOR
41d3			endif	 
41d3 10 d5				djnz .dashscan 
41d5			 
41d5			if DEBUG_FORTH_DOT 
41d5				DMARK "D-1" 
41d5 f5				push af  
41d6 3a ea 41			ld a, (.dmark)  
41d9 32 68 fe			ld (debug_mark),a  
41dc 3a eb 41			ld a, (.dmark+1)  
41df 32 69 fe			ld (debug_mark+1),a  
41e2 3a ec 41			ld a, (.dmark+2)  
41e5 32 6a fe			ld (debug_mark+2),a  
41e8 18 03			jr .pastdmark  
41ea ..			.dmark: db "D-1"  
41ed f1			.pastdmark: pop af  
41ee			endm  
# End of macro DMARK
41ee				CALLMONITOR 
41ee cd 6c fe			call debug_vector  
41f1				endm  
# End of macro CALLMONITOR
41f1			endif	 
41f1			 
41f1			.nodashswap: 
41f1			 
41f1			if DEBUG_FORTH_DOT 
41f1				DMARK "D-o" 
41f1 f5				push af  
41f2 3a 06 42			ld a, (.dmark)  
41f5 32 68 fe			ld (debug_mark),a  
41f8 3a 07 42			ld a, (.dmark+1)  
41fb 32 69 fe			ld (debug_mark+1),a  
41fe 3a 08 42			ld a, (.dmark+2)  
4201 32 6a fe			ld (debug_mark+2),a  
4204 18 03			jr .pastdmark  
4206 ..			.dmark: db "D-o"  
4209 f1			.pastdmark: pop af  
420a			endm  
# End of macro DMARK
420a				CALLMONITOR 
420a cd 6c fe			call debug_vector  
420d				endm  
# End of macro CALLMONITOR
420d			endif	 
420d			 
420d d5					push de   ; save string start in case we need to advance print 
420e			 
420e 3a 5b fa				ld a, (f_cursor_ptr) 
4211 cd af 0d				call str_at_display 
4214 3a 39 fa				ld a,(cli_autodisplay) 
4217 fe 00				cp 0 
4219 28 03				jr z, .noupdate 
421b cd bf 0d						call update_display 
421e					.noupdate: 
421e			 
421e			 
421e					; see if we need to advance the print position 
421e			 
421e e1					pop hl   ; get back string 
421f			;		ex de,hl 
421f			 
421f 3a 3a fa				ld a, (cli_mvdot) 
4222			if DEBUG_FORTH_DOT 
4222			;		ld e,a 
4222				DMARK "D>1" 
4222 f5				push af  
4223 3a 37 42			ld a, (.dmark)  
4226 32 68 fe			ld (debug_mark),a  
4229 3a 38 42			ld a, (.dmark+1)  
422c 32 69 fe			ld (debug_mark+1),a  
422f 3a 39 42			ld a, (.dmark+2)  
4232 32 6a fe			ld (debug_mark+2),a  
4235 18 03			jr .pastdmark  
4237 ..			.dmark: db "D>1"  
423a f1			.pastdmark: pop af  
423b			endm  
# End of macro DMARK
423b				CALLMONITOR 
423b cd 6c fe			call debug_vector  
423e				endm  
# End of macro CALLMONITOR
423e			endif	 
423e fe 00				cp 0 
4240 28 44				jr z, .noadv 
4242					; yes, lets advance the print position 
4242 3e 00				ld a, 0 
4244 cd 39 14				call strlent 
4247			if DEBUG_FORTH_DOT 
4247				DMARK "D-?" 
4247 f5				push af  
4248 3a 5c 42			ld a, (.dmark)  
424b 32 68 fe			ld (debug_mark),a  
424e 3a 5d 42			ld a, (.dmark+1)  
4251 32 69 fe			ld (debug_mark+1),a  
4254 3a 5e 42			ld a, (.dmark+2)  
4257 32 6a fe			ld (debug_mark+2),a  
425a 18 03			jr .pastdmark  
425c ..			.dmark: db "D-?"  
425f f1			.pastdmark: pop af  
4260			endm  
# End of macro DMARK
4260				CALLMONITOR 
4260 cd 6c fe			call debug_vector  
4263				endm  
# End of macro CALLMONITOR
4263			endif	 
4263 3a 5b fa				ld a, (f_cursor_ptr) 
4266 85					add a,l 
4267					;call addatohl 
4267					;ld a, l 
4267 32 5b fa				ld (f_cursor_ptr), a   ; save new pos 
426a			 
426a			if DEBUG_FORTH_DOT 
426a				DMARK "D->" 
426a f5				push af  
426b 3a 7f 42			ld a, (.dmark)  
426e 32 68 fe			ld (debug_mark),a  
4271 3a 80 42			ld a, (.dmark+1)  
4274 32 69 fe			ld (debug_mark+1),a  
4277 3a 81 42			ld a, (.dmark+2)  
427a 32 6a fe			ld (debug_mark+2),a  
427d 18 03			jr .pastdmark  
427f ..			.dmark: db "D->"  
4282 f1			.pastdmark: pop af  
4283			endm  
# End of macro DMARK
4283				CALLMONITOR 
4283 cd 6c fe			call debug_vector  
4286				endm  
# End of macro CALLMONITOR
4286			endif	 
4286			 
4286			.noadv:	 
4286			 
4286					if DEBUG_FORTH_DOT_WAIT 
4286							call next_page_prompt 
4286					endif	 
4286			; TODO this pop off the stack causes a crash. i dont know why 
4286			 
4286			 
4286			if DEBUG_FORTH_DOT 
4286				DMARK "DTh" 
4286 f5				push af  
4287 3a 9b 42			ld a, (.dmark)  
428a 32 68 fe			ld (debug_mark),a  
428d 3a 9c 42			ld a, (.dmark+1)  
4290 32 69 fe			ld (debug_mark+1),a  
4293 3a 9d 42			ld a, (.dmark+2)  
4296 32 6a fe			ld (debug_mark+2),a  
4299 18 03			jr .pastdmark  
429b ..			.dmark: db "DTh"  
429e f1			.pastdmark: pop af  
429f			endm  
# End of macro DMARK
429f				CALLMONITOR 
429f cd 6c fe			call debug_vector  
42a2				endm  
# End of macro CALLMONITOR
42a2			endif	 
42a2			 
42a2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
42a2 cd b3 23			call macro_forth_dsp_pop 
42a5				endm 
# End of macro FORTH_DSP_POP
42a5			 
42a5			if DEBUG_FORTH_DOT 
42a5				DMARK "DTi" 
42a5 f5				push af  
42a6 3a ba 42			ld a, (.dmark)  
42a9 32 68 fe			ld (debug_mark),a  
42ac 3a bb 42			ld a, (.dmark+1)  
42af 32 69 fe			ld (debug_mark+1),a  
42b2 3a bc 42			ld a, (.dmark+2)  
42b5 32 6a fe			ld (debug_mark+2),a  
42b8 18 03			jr .pastdmark  
42ba ..			.dmark: db "DTi"  
42bd f1			.pastdmark: pop af  
42be			endm  
# End of macro DMARK
42be				CALLMONITOR 
42be cd 6c fe			call debug_vector  
42c1				endm  
# End of macro CALLMONITOR
42c1			endif	 
42c1			 
42c1			 
42c1					NEXTW 
42c1 c3 b1 24			jp macro_next 
42c4				endm 
# End of macro NEXTW
42c4			 
42c4			.CLS: 
42c4				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
42c4 35				db WORD_SYS_CORE+33             
42c5 f1 42			dw .DRAW            
42c7 04				db 3 + 1 
42c8 .. 00			db "CLS",0              
42cc				endm 
# End of macro CWHEAD
42cc			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
42cc					if DEBUG_FORTH_WORDS_KEY 
42cc						DMARK "CLS" 
42cc f5				push af  
42cd 3a e1 42			ld a, (.dmark)  
42d0 32 68 fe			ld (debug_mark),a  
42d3 3a e2 42			ld a, (.dmark+1)  
42d6 32 69 fe			ld (debug_mark+1),a  
42d9 3a e3 42			ld a, (.dmark+2)  
42dc 32 6a fe			ld (debug_mark+2),a  
42df 18 03			jr .pastdmark  
42e1 ..			.dmark: db "CLS"  
42e4 f1			.pastdmark: pop af  
42e5			endm  
# End of macro DMARK
42e5						CALLMONITOR 
42e5 cd 6c fe			call debug_vector  
42e8				endm  
# End of macro CALLMONITOR
42e8					endif 
42e8 cd 9c 0d				call clear_display 
42eb c3 ff 43				jp .home		; and home cursor 
42ee					NEXTW 
42ee c3 b1 24			jp macro_next 
42f1				endm 
# End of macro NEXTW
42f1			 
42f1			.DRAW: 
42f1				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
42f1 36				db WORD_SYS_CORE+34             
42f2 1c 43			dw .DUMP            
42f4 05				db 4 + 1 
42f5 .. 00			db "DRAW",0              
42fa				endm 
# End of macro CWHEAD
42fa			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
42fa					if DEBUG_FORTH_WORDS_KEY 
42fa						DMARK "DRW" 
42fa f5				push af  
42fb 3a 0f 43			ld a, (.dmark)  
42fe 32 68 fe			ld (debug_mark),a  
4301 3a 10 43			ld a, (.dmark+1)  
4304 32 69 fe			ld (debug_mark+1),a  
4307 3a 11 43			ld a, (.dmark+2)  
430a 32 6a fe			ld (debug_mark+2),a  
430d 18 03			jr .pastdmark  
430f ..			.dmark: db "DRW"  
4312 f1			.pastdmark: pop af  
4313			endm  
# End of macro DMARK
4313						CALLMONITOR 
4313 cd 6c fe			call debug_vector  
4316				endm  
# End of macro CALLMONITOR
4316					endif 
4316 cd bf 0d				call update_display 
4319					NEXTW 
4319 c3 b1 24			jp macro_next 
431c				endm 
# End of macro NEXTW
431c			 
431c			.DUMP: 
431c				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
431c 37				db WORD_SYS_CORE+35             
431d 54 43			dw .CDUMP            
431f 05				db 4 + 1 
4320 .. 00			db "DUMP",0              
4325				endm 
# End of macro CWHEAD
4325			; | DUMP ( x -- ) With address x display dump   | DONE 
4325			; TODO pop address to use off of the stack 
4325					if DEBUG_FORTH_WORDS_KEY 
4325						DMARK "DUM" 
4325 f5				push af  
4326 3a 3a 43			ld a, (.dmark)  
4329 32 68 fe			ld (debug_mark),a  
432c 3a 3b 43			ld a, (.dmark+1)  
432f 32 69 fe			ld (debug_mark+1),a  
4332 3a 3c 43			ld a, (.dmark+2)  
4335 32 6a fe			ld (debug_mark+2),a  
4338 18 03			jr .pastdmark  
433a ..			.dmark: db "DUM"  
433d f1			.pastdmark: pop af  
433e			endm  
# End of macro DMARK
433e						CALLMONITOR 
433e cd 6c fe			call debug_vector  
4341				endm  
# End of macro CALLMONITOR
4341					endif 
4341 cd 9c 0d				call clear_display 
4344			 
4344					; get address 
4344			 
4344					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4344 cd fb 22			call macro_dsp_valuehl 
4347				endm 
# End of macro FORTH_DSP_VALUEHL
4347				 
4347					; save it for cdump 
4347			 
4347 22 e1 f4				ld (os_cur_ptr),hl 
434a			 
434a					; destroy value TOS 
434a			 
434a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
434a cd b3 23			call macro_forth_dsp_pop 
434d				endm 
# End of macro FORTH_DSP_POP
434d			 
434d cd 84 1f				call dumpcont	; skip old style of param parsing	 
4350 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
4351					NEXTW 
4351 c3 b1 24			jp macro_next 
4354				endm 
# End of macro NEXTW
4354			.CDUMP: 
4354				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
4354 38				db WORD_SYS_CORE+36             
4355 84 43			dw .DAT            
4357 06				db 5 + 1 
4358 .. 00			db "CDUMP",0              
435e				endm 
# End of macro CWHEAD
435e			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
435e					if DEBUG_FORTH_WORDS_KEY 
435e						DMARK "CDP" 
435e f5				push af  
435f 3a 73 43			ld a, (.dmark)  
4362 32 68 fe			ld (debug_mark),a  
4365 3a 74 43			ld a, (.dmark+1)  
4368 32 69 fe			ld (debug_mark+1),a  
436b 3a 75 43			ld a, (.dmark+2)  
436e 32 6a fe			ld (debug_mark+2),a  
4371 18 03			jr .pastdmark  
4373 ..			.dmark: db "CDP"  
4376 f1			.pastdmark: pop af  
4377			endm  
# End of macro DMARK
4377						CALLMONITOR 
4377 cd 6c fe			call debug_vector  
437a				endm  
# End of macro CALLMONITOR
437a					endif 
437a cd 9c 0d				call clear_display 
437d cd 84 1f				call dumpcont	 
4380 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
4381					NEXTW 
4381 c3 b1 24			jp macro_next 
4384				endm 
# End of macro NEXTW
4384			 
4384			 
4384			 
4384			 
4384			.DAT: 
4384				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
4384 3d				db WORD_SYS_CORE+41             
4385 da 43			dw .HOME            
4387 03				db 2 + 1 
4388 .. 00			db "AT",0              
438b				endm 
# End of macro CWHEAD
438b			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
438b					if DEBUG_FORTH_WORDS_KEY 
438b						DMARK "AT." 
438b f5				push af  
438c 3a a0 43			ld a, (.dmark)  
438f 32 68 fe			ld (debug_mark),a  
4392 3a a1 43			ld a, (.dmark+1)  
4395 32 69 fe			ld (debug_mark+1),a  
4398 3a a2 43			ld a, (.dmark+2)  
439b 32 6a fe			ld (debug_mark+2),a  
439e 18 03			jr .pastdmark  
43a0 ..			.dmark: db "AT."  
43a3 f1			.pastdmark: pop af  
43a4			endm  
# End of macro DMARK
43a4						CALLMONITOR 
43a4 cd 6c fe			call debug_vector  
43a7				endm  
# End of macro CALLMONITOR
43a7					endif 
43a7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
43a7 cd fb 22			call macro_dsp_valuehl 
43aa				endm 
# End of macro FORTH_DSP_VALUEHL
43aa			 
43aa			 
43aa					; TODO save cursor row 
43aa 7d					ld a,l 
43ab fe 02				cp 2 
43ad 20 04				jr nz, .crow3 
43af 3e 28				ld a, display_row_2 
43b1 18 12				jr .ccol1 
43b3 fe 03		.crow3:		cp 3 
43b5 20 04				jr nz, .crow4 
43b7 3e 50				ld a, display_row_3 
43b9 18 0a				jr .ccol1 
43bb fe 04		.crow4:		cp 4 
43bd 20 04				jr nz, .crow1 
43bf 3e 78				ld a, display_row_4 
43c1 18 02				jr .ccol1 
43c3 3e 00		.crow1:		ld a,display_row_1 
43c5 f5			.ccol1:		push af			; got row offset 
43c6 6f					ld l,a 
43c7 26 00				ld h,0 
43c9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
43c9 cd b3 23			call macro_forth_dsp_pop 
43cc				endm 
# End of macro FORTH_DSP_POP
43cc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
43cc cd fb 22			call macro_dsp_valuehl 
43cf				endm 
# End of macro FORTH_DSP_VALUEHL
43cf					; TODO save cursor col 
43cf f1					pop af 
43d0 85					add l		; add col offset 
43d1 32 5b fa				ld (f_cursor_ptr), a 
43d4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
43d4 cd b3 23			call macro_forth_dsp_pop 
43d7				endm 
# End of macro FORTH_DSP_POP
43d7			 
43d7					; calculate  
43d7			 
43d7					NEXTW 
43d7 c3 b1 24			jp macro_next 
43da				endm 
# End of macro NEXTW
43da			 
43da			 
43da			.HOME: 
43da				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
43da 41				db WORD_SYS_CORE+45             
43db 07 44			dw .SPACE            
43dd 05				db 4 + 1 
43de .. 00			db "HOME",0              
43e3				endm 
# End of macro CWHEAD
43e3			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
43e3					if DEBUG_FORTH_WORDS_KEY 
43e3						DMARK "HOM" 
43e3 f5				push af  
43e4 3a f8 43			ld a, (.dmark)  
43e7 32 68 fe			ld (debug_mark),a  
43ea 3a f9 43			ld a, (.dmark+1)  
43ed 32 69 fe			ld (debug_mark+1),a  
43f0 3a fa 43			ld a, (.dmark+2)  
43f3 32 6a fe			ld (debug_mark+2),a  
43f6 18 03			jr .pastdmark  
43f8 ..			.dmark: db "HOM"  
43fb f1			.pastdmark: pop af  
43fc			endm  
# End of macro DMARK
43fc						CALLMONITOR 
43fc cd 6c fe			call debug_vector  
43ff				endm  
# End of macro CALLMONITOR
43ff					endif 
43ff 3e 00		.home:		ld a, 0		; and home cursor 
4401 32 5b fa				ld (f_cursor_ptr), a 
4404					NEXTW 
4404 c3 b1 24			jp macro_next 
4407				endm 
# End of macro NEXTW
4407			 
4407			 
4407			.SPACE: 
4407				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
4407 46				db WORD_SYS_CORE+50             
4408 3d 44			dw .SPACES            
440a 03				db 2 + 1 
440b .. 00			db "BL",0              
440e				endm 
# End of macro CWHEAD
440e			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
440e					if DEBUG_FORTH_WORDS_KEY 
440e						DMARK "BL." 
440e f5				push af  
440f 3a 23 44			ld a, (.dmark)  
4412 32 68 fe			ld (debug_mark),a  
4415 3a 24 44			ld a, (.dmark+1)  
4418 32 69 fe			ld (debug_mark+1),a  
441b 3a 25 44			ld a, (.dmark+2)  
441e 32 6a fe			ld (debug_mark+2),a  
4421 18 03			jr .pastdmark  
4423 ..			.dmark: db "BL."  
4426 f1			.pastdmark: pop af  
4427			endm  
# End of macro DMARK
4427						CALLMONITOR 
4427 cd 6c fe			call debug_vector  
442a				endm  
# End of macro CALLMONITOR
442a					endif 
442a 3e 20				ld a, " " 
442c 32 be f1				ld (scratch),a 
442f 3e 00				ld a, 0 
4431 32 bf f1				ld (scratch+1),a 
4434 21 be f1				ld hl, scratch 
4437 cd 72 21				call forth_push_str 
443a					 
443a				       NEXTW 
443a c3 b1 24			jp macro_next 
443d				endm 
# End of macro NEXTW
443d			 
443d			;.blstr: db " ", 0 
443d			 
443d			.SPACES: 
443d				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
443d 47				db WORD_SYS_CORE+51             
443e d8 44			dw .SCROLL            
4440 07				db 6 + 1 
4441 .. 00			db "SPACES",0              
4448				endm 
# End of macro CWHEAD
4448			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
4448					if DEBUG_FORTH_WORDS_KEY 
4448						DMARK "SPS" 
4448 f5				push af  
4449 3a 5d 44			ld a, (.dmark)  
444c 32 68 fe			ld (debug_mark),a  
444f 3a 5e 44			ld a, (.dmark+1)  
4452 32 69 fe			ld (debug_mark+1),a  
4455 3a 5f 44			ld a, (.dmark+2)  
4458 32 6a fe			ld (debug_mark+2),a  
445b 18 03			jr .pastdmark  
445d ..			.dmark: db "SPS"  
4460 f1			.pastdmark: pop af  
4461			endm  
# End of macro DMARK
4461						CALLMONITOR 
4461 cd 6c fe			call debug_vector  
4464				endm  
# End of macro CALLMONITOR
4464					endif 
4464			 
4464			 
4464					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4464 cd fb 22			call macro_dsp_valuehl 
4467				endm 
# End of macro FORTH_DSP_VALUEHL
4467			 
4467 e5					push hl    ; u 
4468					if DEBUG_FORTH_WORDS 
4468						DMARK "SPA" 
4468 f5				push af  
4469 3a 7d 44			ld a, (.dmark)  
446c 32 68 fe			ld (debug_mark),a  
446f 3a 7e 44			ld a, (.dmark+1)  
4472 32 69 fe			ld (debug_mark+1),a  
4475 3a 7f 44			ld a, (.dmark+2)  
4478 32 6a fe			ld (debug_mark+2),a  
447b 18 03			jr .pastdmark  
447d ..			.dmark: db "SPA"  
4480 f1			.pastdmark: pop af  
4481			endm  
# End of macro DMARK
4481						CALLMONITOR 
4481 cd 6c fe			call debug_vector  
4484				endm  
# End of macro CALLMONITOR
4484					endif 
4484			 
4484					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4484 cd b3 23			call macro_forth_dsp_pop 
4487				endm 
# End of macro FORTH_DSP_POP
4487 e1					pop hl 
4488 0e 00				ld c, 0 
448a 45					ld b, l 
448b 21 be f1				ld hl, scratch  
448e			 
448e					if DEBUG_FORTH_WORDS 
448e						DMARK "SP2" 
448e f5				push af  
448f 3a a3 44			ld a, (.dmark)  
4492 32 68 fe			ld (debug_mark),a  
4495 3a a4 44			ld a, (.dmark+1)  
4498 32 69 fe			ld (debug_mark+1),a  
449b 3a a5 44			ld a, (.dmark+2)  
449e 32 6a fe			ld (debug_mark+2),a  
44a1 18 03			jr .pastdmark  
44a3 ..			.dmark: db "SP2"  
44a6 f1			.pastdmark: pop af  
44a7			endm  
# End of macro DMARK
44a7						CALLMONITOR 
44a7 cd 6c fe			call debug_vector  
44aa				endm  
# End of macro CALLMONITOR
44aa					endif 
44aa 3e 20				ld a, ' ' 
44ac			.spaces1:	 
44ac 77					ld (hl),a 
44ad 23					inc hl 
44ae					 
44ae 10 fc				djnz .spaces1 
44b0 3e 00				ld a,0 
44b2 77					ld (hl),a 
44b3 21 be f1				ld hl, scratch 
44b6					if DEBUG_FORTH_WORDS 
44b6						DMARK "SP3" 
44b6 f5				push af  
44b7 3a cb 44			ld a, (.dmark)  
44ba 32 68 fe			ld (debug_mark),a  
44bd 3a cc 44			ld a, (.dmark+1)  
44c0 32 69 fe			ld (debug_mark+1),a  
44c3 3a cd 44			ld a, (.dmark+2)  
44c6 32 6a fe			ld (debug_mark+2),a  
44c9 18 03			jr .pastdmark  
44cb ..			.dmark: db "SP3"  
44ce f1			.pastdmark: pop af  
44cf			endm  
# End of macro DMARK
44cf						CALLMONITOR 
44cf cd 6c fe			call debug_vector  
44d2				endm  
# End of macro CALLMONITOR
44d2					endif 
44d2 cd 72 21				call forth_push_str 
44d5			 
44d5				       NEXTW 
44d5 c3 b1 24			jp macro_next 
44d8				endm 
# End of macro NEXTW
44d8			 
44d8			 
44d8			 
44d8			.SCROLL: 
44d8				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
44d8 53				db WORD_SYS_CORE+63             
44d9 05 45			dw .SCROLLD            
44db 07				db 6 + 1 
44dc .. 00			db "SCROLL",0              
44e3				endm 
# End of macro CWHEAD
44e3			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
44e3					if DEBUG_FORTH_WORDS_KEY 
44e3						DMARK "SCR" 
44e3 f5				push af  
44e4 3a f8 44			ld a, (.dmark)  
44e7 32 68 fe			ld (debug_mark),a  
44ea 3a f9 44			ld a, (.dmark+1)  
44ed 32 69 fe			ld (debug_mark+1),a  
44f0 3a fa 44			ld a, (.dmark+2)  
44f3 32 6a fe			ld (debug_mark+2),a  
44f6 18 03			jr .pastdmark  
44f8 ..			.dmark: db "SCR"  
44fb f1			.pastdmark: pop af  
44fc			endm  
# End of macro DMARK
44fc						CALLMONITOR 
44fc cd 6c fe			call debug_vector  
44ff				endm  
# End of macro CALLMONITOR
44ff					endif 
44ff			 
44ff cd 5e 0d			call scroll_up 
4502			;	call update_display 
4502			 
4502					NEXTW 
4502 c3 b1 24			jp macro_next 
4505				endm 
# End of macro NEXTW
4505			 
4505			 
4505			 
4505			;		; get dir 
4505			; 
4505			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4505			; 
4505			;		push hl 
4505			; 
4505			;		; destroy value TOS 
4505			; 
4505			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4505			; 
4505			;		; get count 
4505			; 
4505			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4505			; 
4505			;		push hl 
4505			; 
4505			;		; destroy value TOS 
4505			; 
4505			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4505			; 
4505			;		; one value on hl get other one back 
4505			; 
4505			;		pop bc    ; count 
4505			; 
4505			;		pop de   ; dir 
4505			; 
4505			; 
4505			;		ld b, c 
4505			; 
4505			;.scrolldir:     push bc 
4505			;		push de 
4505			; 
4505			;		ld a, 0 
4505			;		cp e 
4505			;		jr z, .scrollup  
4505			;		call scroll_down 
4505			;		jr .scrollnext 
4505			;.scrollup:	call scroll_up 
4505			; 
4505			;		 
4505			;.scrollnext: 
4505			;		pop de 
4505			;		pop bc 
4505			;		djnz .scrolldir 
4505			; 
4505			; 
4505			; 
4505			; 
4505			; 
4505			;		NEXTW 
4505			 
4505			.SCROLLD: 
4505				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
4505 53				db WORD_SYS_CORE+63             
4506 33 45			dw .ATQ            
4508 08				db 7 + 1 
4509 .. 00			db "SCROLLD",0              
4511				endm 
# End of macro CWHEAD
4511			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
4511					if DEBUG_FORTH_WORDS_KEY 
4511						DMARK "SCD" 
4511 f5				push af  
4512 3a 26 45			ld a, (.dmark)  
4515 32 68 fe			ld (debug_mark),a  
4518 3a 27 45			ld a, (.dmark+1)  
451b 32 69 fe			ld (debug_mark+1),a  
451e 3a 28 45			ld a, (.dmark+2)  
4521 32 6a fe			ld (debug_mark+2),a  
4524 18 03			jr .pastdmark  
4526 ..			.dmark: db "SCD"  
4529 f1			.pastdmark: pop af  
452a			endm  
# End of macro DMARK
452a						CALLMONITOR 
452a cd 6c fe			call debug_vector  
452d				endm  
# End of macro CALLMONITOR
452d					endif 
452d			 
452d cd 82 0d			call scroll_down 
4530			;	call update_display 
4530			 
4530					NEXTW 
4530 c3 b1 24			jp macro_next 
4533				endm 
# End of macro NEXTW
4533			 
4533			 
4533			.ATQ: 
4533				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
4533 62				db WORD_SYS_CORE+78             
4534 91 45			dw .AUTODSP            
4536 04				db 3 + 1 
4537 .. 00			db "AT@",0              
453b				endm 
# End of macro CWHEAD
453b			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
453b					if DEBUG_FORTH_WORDS_KEY 
453b						DMARK "ATA" 
453b f5				push af  
453c 3a 50 45			ld a, (.dmark)  
453f 32 68 fe			ld (debug_mark),a  
4542 3a 51 45			ld a, (.dmark+1)  
4545 32 69 fe			ld (debug_mark+1),a  
4548 3a 52 45			ld a, (.dmark+2)  
454b 32 6a fe			ld (debug_mark+2),a  
454e 18 03			jr .pastdmark  
4550 ..			.dmark: db "ATA"  
4553 f1			.pastdmark: pop af  
4554			endm  
# End of macro DMARK
4554						CALLMONITOR 
4554 cd 6c fe			call debug_vector  
4557				endm  
# End of macro CALLMONITOR
4557					endif 
4557			 
4557			 
4557					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4557 cd fb 22			call macro_dsp_valuehl 
455a				endm 
# End of macro FORTH_DSP_VALUEHL
455a			 
455a					; TODO save cursor row 
455a 7d					ld a,l 
455b fe 02				cp 2 
455d 20 04				jr nz, .crow3aq 
455f 3e 28				ld a, display_row_2 
4561 18 12				jr .ccol1aq 
4563 fe 03		.crow3aq:		cp 3 
4565 20 04				jr nz, .crow4aq 
4567 3e 50				ld a, display_row_3 
4569 18 0a				jr .ccol1aq 
456b fe 04		.crow4aq:		cp 4 
456d 20 04				jr nz, .crow1aq 
456f 3e 78				ld a, display_row_4 
4571 18 02				jr .ccol1aq 
4573 3e 00		.crow1aq:		ld a,display_row_1 
4575 f5			.ccol1aq:		push af			; got row offset 
4576 6f					ld l,a 
4577 26 00				ld h,0 
4579					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4579 cd b3 23			call macro_forth_dsp_pop 
457c				endm 
# End of macro FORTH_DSP_POP
457c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
457c cd fb 22			call macro_dsp_valuehl 
457f				endm 
# End of macro FORTH_DSP_VALUEHL
457f					; TODO save cursor col 
457f f1					pop af 
4580 85					add l		; add col offset 
4581			 
4581					; add current frame buffer address 
4581 2a c9 fb				ld hl, (display_fb_active) 
4584 cd d0 0f				call addatohl 
4587			 
4587			 
4587			 
4587			 
4587					; get char frame buffer location offset in hl 
4587			 
4587 7e					ld a,(hl) 
4588 26 00				ld h, 0 
458a 6f					ld l, a 
458b			 
458b cd 04 21				call forth_push_numhl 
458e			 
458e			 
458e					NEXTW 
458e c3 b1 24			jp macro_next 
4591				endm 
# End of macro NEXTW
4591			 
4591			.AUTODSP: 
4591				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
4591 63				db WORD_SYS_CORE+79             
4592 a7 45			dw .MENU            
4594 05				db 4 + 1 
4595 .. 00			db "ADSP",0              
459a				endm 
# End of macro CWHEAD
459a			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
459a			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
459a			 
459a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
459a cd fb 22			call macro_dsp_valuehl 
459d				endm 
# End of macro FORTH_DSP_VALUEHL
459d			 
459d			;		push hl 
459d			 
459d					; destroy value TOS 
459d			 
459d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
459d cd b3 23			call macro_forth_dsp_pop 
45a0				endm 
# End of macro FORTH_DSP_POP
45a0			 
45a0			;		pop hl 
45a0			 
45a0 7d					ld a,l 
45a1 32 39 fa				ld (cli_autodisplay), a 
45a4				       NEXTW 
45a4 c3 b1 24			jp macro_next 
45a7				endm 
# End of macro NEXTW
45a7			 
45a7			.MENU: 
45a7				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
45a7 70				db WORD_SYS_CORE+92             
45a8 50 46			dw .ENDDISPLAY            
45aa 05				db 4 + 1 
45ab .. 00			db "MENU",0              
45b0				endm 
# End of macro CWHEAD
45b0			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
45b0			 
45b0			;		; get number of items on the stack 
45b0			; 
45b0				 
45b0					FORTH_DSP_VALUEHL 
45b0 cd fb 22			call macro_dsp_valuehl 
45b3				endm 
# End of macro FORTH_DSP_VALUEHL
45b3				 
45b3					if DEBUG_FORTH_WORDS_KEY 
45b3						DMARK "MNU" 
45b3 f5				push af  
45b4 3a c8 45			ld a, (.dmark)  
45b7 32 68 fe			ld (debug_mark),a  
45ba 3a c9 45			ld a, (.dmark+1)  
45bd 32 69 fe			ld (debug_mark+1),a  
45c0 3a ca 45			ld a, (.dmark+2)  
45c3 32 6a fe			ld (debug_mark+2),a  
45c6 18 03			jr .pastdmark  
45c8 ..			.dmark: db "MNU"  
45cb f1			.pastdmark: pop af  
45cc			endm  
# End of macro DMARK
45cc						CALLMONITOR 
45cc cd 6c fe			call debug_vector  
45cf				endm  
# End of macro CALLMONITOR
45cf					endif 
45cf			 
45cf 45					ld b, l	 
45d0 05					dec b 
45d1			 
45d1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
45d1 cd b3 23			call macro_forth_dsp_pop 
45d4				endm 
# End of macro FORTH_DSP_POP
45d4			 
45d4			 
45d4					; go directly through the stack to pluck out the string pointers and build an array 
45d4			 
45d4			;		FORTH_DSP 
45d4			 
45d4					; hl contains top most stack item 
45d4				 
45d4 11 be f1				ld de, scratch 
45d7			 
45d7			.mbuild: 
45d7			 
45d7					FORTH_DSP_VALUEHL 
45d7 cd fb 22			call macro_dsp_valuehl 
45da				endm 
# End of macro FORTH_DSP_VALUEHL
45da			 
45da					if DEBUG_FORTH_WORDS 
45da						DMARK "MN3" 
45da f5				push af  
45db 3a ef 45			ld a, (.dmark)  
45de 32 68 fe			ld (debug_mark),a  
45e1 3a f0 45			ld a, (.dmark+1)  
45e4 32 69 fe			ld (debug_mark+1),a  
45e7 3a f1 45			ld a, (.dmark+2)  
45ea 32 6a fe			ld (debug_mark+2),a  
45ed 18 03			jr .pastdmark  
45ef ..			.dmark: db "MN3"  
45f2 f1			.pastdmark: pop af  
45f3			endm  
# End of macro DMARK
45f3						CALLMONITOR 
45f3 cd 6c fe			call debug_vector  
45f6				endm  
# End of macro CALLMONITOR
45f6					endif 
45f6 eb					ex de, hl 
45f7 73					ld (hl), e 
45f8 23					inc hl 
45f9 72					ld (hl), d 
45fa 23					inc hl 
45fb eb					ex de, hl 
45fc			 
45fc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
45fc cd b3 23			call macro_forth_dsp_pop 
45ff				endm 
# End of macro FORTH_DSP_POP
45ff			 
45ff 10 d6				djnz .mbuild 
4601			 
4601					; done add term 
4601			 
4601 eb					ex de, hl 
4602 36 00				ld (hl), 0 
4604 23					inc hl 
4605 36 00				ld (hl), 0 
4607			 
4607				 
4607					 
4607 21 be f1				ld hl, scratch 
460a			 
460a					if DEBUG_FORTH_WORDS 
460a						DMARK "MNx" 
460a f5				push af  
460b 3a 1f 46			ld a, (.dmark)  
460e 32 68 fe			ld (debug_mark),a  
4611 3a 20 46			ld a, (.dmark+1)  
4614 32 69 fe			ld (debug_mark+1),a  
4617 3a 21 46			ld a, (.dmark+2)  
461a 32 6a fe			ld (debug_mark+2),a  
461d 18 03			jr .pastdmark  
461f ..			.dmark: db "MNx"  
4622 f1			.pastdmark: pop af  
4623			endm  
# End of macro DMARK
4623						CALLMONITOR 
4623 cd 6c fe			call debug_vector  
4626				endm  
# End of macro CALLMONITOR
4626					endif 
4626			 
4626			 
4626			 
4626 3e 00				ld a, 0 
4628 cd cd 0d				call menu 
462b			 
462b			 
462b 6f					ld l, a 
462c 26 00				ld h, 0 
462e			 
462e					if DEBUG_FORTH_WORDS 
462e						DMARK "MNr" 
462e f5				push af  
462f 3a 43 46			ld a, (.dmark)  
4632 32 68 fe			ld (debug_mark),a  
4635 3a 44 46			ld a, (.dmark+1)  
4638 32 69 fe			ld (debug_mark+1),a  
463b 3a 45 46			ld a, (.dmark+2)  
463e 32 6a fe			ld (debug_mark+2),a  
4641 18 03			jr .pastdmark  
4643 ..			.dmark: db "MNr"  
4646 f1			.pastdmark: pop af  
4647			endm  
# End of macro DMARK
4647						CALLMONITOR 
4647 cd 6c fe			call debug_vector  
464a				endm  
# End of macro CALLMONITOR
464a					endif 
464a			 
464a cd 04 21				call forth_push_numhl 
464d			 
464d			 
464d			 
464d			 
464d				       NEXTW 
464d c3 b1 24			jp macro_next 
4650				endm 
# End of macro NEXTW
4650			 
4650			 
4650			.ENDDISPLAY: 
4650			 
4650			; eof 
# End of file forth_words_display.asm
4650			include "forth_words_str.asm" 
4650			 
4650			; | ## String Words 
4650			 
4650			.PTR:   
4650			 
4650				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
4650 48				db WORD_SYS_CORE+52             
4651 7d 46			dw .STYPE            
4653 04				db 3 + 1 
4654 .. 00			db "PTR",0              
4658				endm 
# End of macro CWHEAD
4658			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
4658			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
4658			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
4658			 
4658					if DEBUG_FORTH_WORDS_KEY 
4658						DMARK "PTR" 
4658 f5				push af  
4659 3a 6d 46			ld a, (.dmark)  
465c 32 68 fe			ld (debug_mark),a  
465f 3a 6e 46			ld a, (.dmark+1)  
4662 32 69 fe			ld (debug_mark+1),a  
4665 3a 6f 46			ld a, (.dmark+2)  
4668 32 6a fe			ld (debug_mark+2),a  
466b 18 03			jr .pastdmark  
466d ..			.dmark: db "PTR"  
4670 f1			.pastdmark: pop af  
4671			endm  
# End of macro DMARK
4671						CALLMONITOR 
4671 cd 6c fe			call debug_vector  
4674				endm  
# End of macro CALLMONITOR
4674					endif 
4674					FORTH_DSP_VALUEHL 
4674 cd fb 22			call macro_dsp_valuehl 
4677				endm 
# End of macro FORTH_DSP_VALUEHL
4677 cd 04 21				call forth_push_numhl 
467a			 
467a			 
467a					NEXTW 
467a c3 b1 24			jp macro_next 
467d				endm 
# End of macro NEXTW
467d			.STYPE: 
467d				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
467d 48				db WORD_SYS_CORE+52             
467e cc 46			dw .UPPER            
4680 06				db 5 + 1 
4681 .. 00			db "STYPE",0              
4687				endm 
# End of macro CWHEAD
4687			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
4687					if DEBUG_FORTH_WORDS_KEY 
4687						DMARK "STY" 
4687 f5				push af  
4688 3a 9c 46			ld a, (.dmark)  
468b 32 68 fe			ld (debug_mark),a  
468e 3a 9d 46			ld a, (.dmark+1)  
4691 32 69 fe			ld (debug_mark+1),a  
4694 3a 9e 46			ld a, (.dmark+2)  
4697 32 6a fe			ld (debug_mark+2),a  
469a 18 03			jr .pastdmark  
469c ..			.dmark: db "STY"  
469f f1			.pastdmark: pop af  
46a0			endm  
# End of macro DMARK
46a0						CALLMONITOR 
46a0 cd 6c fe			call debug_vector  
46a3				endm  
# End of macro CALLMONITOR
46a3					endif 
46a3					FORTH_DSP 
46a3 cd c1 22			call macro_forth_dsp 
46a6				endm 
# End of macro FORTH_DSP
46a6					;v5 FORTH_DSP_VALUE 
46a6			 
46a6 7e					ld a, (hl) 
46a7			 
46a7 f5					push af 
46a8			 
46a8			; Dont destroy TOS		FORTH_DSP_POP 
46a8			 
46a8 f1					pop af 
46a9			 
46a9 fe 01				cp DS_TYPE_STR 
46ab 28 09				jr z, .typestr 
46ad			 
46ad fe 02				cp DS_TYPE_INUM 
46af 28 0a				jr z, .typeinum 
46b1			 
46b1 21 ca 46				ld hl, .tna 
46b4 18 0a				jr .tpush 
46b6			 
46b6 21 c6 46		.typestr:	ld hl, .tstr 
46b9 18 05				jr .tpush 
46bb 21 c8 46		.typeinum:	ld hl, .tinum 
46be 18 00				jr .tpush 
46c0			 
46c0			.tpush: 
46c0			 
46c0 cd 72 21				call forth_push_str 
46c3			 
46c3					NEXTW 
46c3 c3 b1 24			jp macro_next 
46c6				endm 
# End of macro NEXTW
46c6 .. 00		.tstr:	db "s",0 
46c8 .. 00		.tinum:  db "i",0 
46ca .. 00		.tna:   db "?", 0 
46cc			 
46cc			 
46cc			.UPPER: 
46cc				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
46cc 48				db WORD_SYS_CORE+52             
46cd 07 47			dw .LOWER            
46cf 06				db 5 + 1 
46d0 .. 00			db "UPPER",0              
46d6				endm 
# End of macro CWHEAD
46d6			; | UPPER ( s -- s ) Upper case string s  | DONE 
46d6					if DEBUG_FORTH_WORDS_KEY 
46d6						DMARK "UPR" 
46d6 f5				push af  
46d7 3a eb 46			ld a, (.dmark)  
46da 32 68 fe			ld (debug_mark),a  
46dd 3a ec 46			ld a, (.dmark+1)  
46e0 32 69 fe			ld (debug_mark+1),a  
46e3 3a ed 46			ld a, (.dmark+2)  
46e6 32 6a fe			ld (debug_mark+2),a  
46e9 18 03			jr .pastdmark  
46eb ..			.dmark: db "UPR"  
46ee f1			.pastdmark: pop af  
46ef			endm  
# End of macro DMARK
46ef						CALLMONITOR 
46ef cd 6c fe			call debug_vector  
46f2				endm  
# End of macro CALLMONITOR
46f2					endif 
46f2			 
46f2					FORTH_DSP 
46f2 cd c1 22			call macro_forth_dsp 
46f5				endm 
# End of macro FORTH_DSP
46f5					 
46f5			; TODO check is string type 
46f5			 
46f5					FORTH_DSP_VALUEHL 
46f5 cd fb 22			call macro_dsp_valuehl 
46f8				endm 
# End of macro FORTH_DSP_VALUEHL
46f8			; get pointer to string in hl 
46f8			 
46f8 7e			.toup:		ld a, (hl) 
46f9 fe 00				cp 0 
46fb 28 07				jr z, .toupdone 
46fd			 
46fd cd 3d 13				call to_upper 
4700			 
4700 77					ld (hl), a 
4701 23					inc hl 
4702 18 f4				jr .toup 
4704			 
4704					 
4704			 
4704			 
4704			; for each char convert to upper 
4704					 
4704			.toupdone: 
4704			 
4704			 
4704					NEXTW 
4704 c3 b1 24			jp macro_next 
4707				endm 
# End of macro NEXTW
4707			.LOWER: 
4707				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
4707 48				db WORD_SYS_CORE+52             
4708 42 47			dw .TCASE            
470a 06				db 5 + 1 
470b .. 00			db "LOWER",0              
4711				endm 
# End of macro CWHEAD
4711			; | LOWER ( s -- s ) Lower case string s  | DONE 
4711					if DEBUG_FORTH_WORDS_KEY 
4711						DMARK "LWR" 
4711 f5				push af  
4712 3a 26 47			ld a, (.dmark)  
4715 32 68 fe			ld (debug_mark),a  
4718 3a 27 47			ld a, (.dmark+1)  
471b 32 69 fe			ld (debug_mark+1),a  
471e 3a 28 47			ld a, (.dmark+2)  
4721 32 6a fe			ld (debug_mark+2),a  
4724 18 03			jr .pastdmark  
4726 ..			.dmark: db "LWR"  
4729 f1			.pastdmark: pop af  
472a			endm  
# End of macro DMARK
472a						CALLMONITOR 
472a cd 6c fe			call debug_vector  
472d				endm  
# End of macro CALLMONITOR
472d					endif 
472d			 
472d					FORTH_DSP 
472d cd c1 22			call macro_forth_dsp 
4730				endm 
# End of macro FORTH_DSP
4730					 
4730			; TODO check is string type 
4730			 
4730					FORTH_DSP_VALUEHL 
4730 cd fb 22			call macro_dsp_valuehl 
4733				endm 
# End of macro FORTH_DSP_VALUEHL
4733			; get pointer to string in hl 
4733			 
4733 7e			.tolow:		ld a, (hl) 
4734 fe 00				cp 0 
4736 28 07				jr z, .tolowdone 
4738			 
4738 cd 46 13				call to_lower 
473b			 
473b 77					ld (hl), a 
473c 23					inc hl 
473d 18 f4				jr .tolow 
473f			 
473f					 
473f			 
473f			 
473f			; for each char convert to low 
473f					 
473f			.tolowdone: 
473f					NEXTW 
473f c3 b1 24			jp macro_next 
4742				endm 
# End of macro NEXTW
4742			.TCASE: 
4742				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
4742 48				db WORD_SYS_CORE+52             
4743 78 48			dw .SUBSTR            
4745 06				db 5 + 1 
4746 .. 00			db "TCASE",0              
474c				endm 
# End of macro CWHEAD
474c			; | TCASE ( s -- s ) Title case string s  | DONE 
474c					if DEBUG_FORTH_WORDS_KEY 
474c						DMARK "TCS" 
474c f5				push af  
474d 3a 61 47			ld a, (.dmark)  
4750 32 68 fe			ld (debug_mark),a  
4753 3a 62 47			ld a, (.dmark+1)  
4756 32 69 fe			ld (debug_mark+1),a  
4759 3a 63 47			ld a, (.dmark+2)  
475c 32 6a fe			ld (debug_mark+2),a  
475f 18 03			jr .pastdmark  
4761 ..			.dmark: db "TCS"  
4764 f1			.pastdmark: pop af  
4765			endm  
# End of macro DMARK
4765						CALLMONITOR 
4765 cd 6c fe			call debug_vector  
4768				endm  
# End of macro CALLMONITOR
4768					endif 
4768			 
4768					FORTH_DSP 
4768 cd c1 22			call macro_forth_dsp 
476b				endm 
# End of macro FORTH_DSP
476b					 
476b			; TODO check is string type 
476b			 
476b					FORTH_DSP_VALUEHL 
476b cd fb 22			call macro_dsp_valuehl 
476e				endm 
# End of macro FORTH_DSP_VALUEHL
476e			; get pointer to string in hl 
476e			 
476e					if DEBUG_FORTH_WORDS 
476e						DMARK "TC1" 
476e f5				push af  
476f 3a 83 47			ld a, (.dmark)  
4772 32 68 fe			ld (debug_mark),a  
4775 3a 84 47			ld a, (.dmark+1)  
4778 32 69 fe			ld (debug_mark+1),a  
477b 3a 85 47			ld a, (.dmark+2)  
477e 32 6a fe			ld (debug_mark+2),a  
4781 18 03			jr .pastdmark  
4783 ..			.dmark: db "TC1"  
4786 f1			.pastdmark: pop af  
4787			endm  
# End of macro DMARK
4787						CALLMONITOR 
4787 cd 6c fe			call debug_vector  
478a				endm  
# End of macro CALLMONITOR
478a					endif 
478a			 
478a					; first time in turn to upper case first char 
478a			 
478a 7e					ld a, (hl) 
478b c3 15 48				jp .totsiptou 
478e			 
478e			 
478e 7e			.tot:		ld a, (hl) 
478f fe 00				cp 0 
4791 ca 59 48				jp z, .totdone 
4794			 
4794					if DEBUG_FORTH_WORDS 
4794						DMARK "TC2" 
4794 f5				push af  
4795 3a a9 47			ld a, (.dmark)  
4798 32 68 fe			ld (debug_mark),a  
479b 3a aa 47			ld a, (.dmark+1)  
479e 32 69 fe			ld (debug_mark+1),a  
47a1 3a ab 47			ld a, (.dmark+2)  
47a4 32 6a fe			ld (debug_mark+2),a  
47a7 18 03			jr .pastdmark  
47a9 ..			.dmark: db "TC2"  
47ac f1			.pastdmark: pop af  
47ad			endm  
# End of macro DMARK
47ad						CALLMONITOR 
47ad cd 6c fe			call debug_vector  
47b0				endm  
# End of macro CALLMONITOR
47b0					endif 
47b0					; check to see if current char is a space 
47b0			 
47b0 fe 20				cp ' ' 
47b2 28 21				jr z, .totsp 
47b4 cd 46 13				call to_lower 
47b7					if DEBUG_FORTH_WORDS 
47b7						DMARK "TC3" 
47b7 f5				push af  
47b8 3a cc 47			ld a, (.dmark)  
47bb 32 68 fe			ld (debug_mark),a  
47be 3a cd 47			ld a, (.dmark+1)  
47c1 32 69 fe			ld (debug_mark+1),a  
47c4 3a ce 47			ld a, (.dmark+2)  
47c7 32 6a fe			ld (debug_mark+2),a  
47ca 18 03			jr .pastdmark  
47cc ..			.dmark: db "TC3"  
47cf f1			.pastdmark: pop af  
47d0			endm  
# End of macro DMARK
47d0						CALLMONITOR 
47d0 cd 6c fe			call debug_vector  
47d3				endm  
# End of macro CALLMONITOR
47d3					endif 
47d3 18 63				jr .totnxt 
47d5			 
47d5			.totsp:         ; on a space, find next char which should be upper 
47d5			 
47d5					if DEBUG_FORTH_WORDS 
47d5						DMARK "TC4" 
47d5 f5				push af  
47d6 3a ea 47			ld a, (.dmark)  
47d9 32 68 fe			ld (debug_mark),a  
47dc 3a eb 47			ld a, (.dmark+1)  
47df 32 69 fe			ld (debug_mark+1),a  
47e2 3a ec 47			ld a, (.dmark+2)  
47e5 32 6a fe			ld (debug_mark+2),a  
47e8 18 03			jr .pastdmark  
47ea ..			.dmark: db "TC4"  
47ed f1			.pastdmark: pop af  
47ee			endm  
# End of macro DMARK
47ee						CALLMONITOR 
47ee cd 6c fe			call debug_vector  
47f1				endm  
# End of macro CALLMONITOR
47f1					endif 
47f1					;; 
47f1			 
47f1 fe 20				cp ' ' 
47f3 20 20				jr nz, .totsiptou 
47f5 23					inc hl 
47f6 7e					ld a, (hl) 
47f7					if DEBUG_FORTH_WORDS 
47f7						DMARK "TC5" 
47f7 f5				push af  
47f8 3a 0c 48			ld a, (.dmark)  
47fb 32 68 fe			ld (debug_mark),a  
47fe 3a 0d 48			ld a, (.dmark+1)  
4801 32 69 fe			ld (debug_mark+1),a  
4804 3a 0e 48			ld a, (.dmark+2)  
4807 32 6a fe			ld (debug_mark+2),a  
480a 18 03			jr .pastdmark  
480c ..			.dmark: db "TC5"  
480f f1			.pastdmark: pop af  
4810			endm  
# End of macro DMARK
4810						CALLMONITOR 
4810 cd 6c fe			call debug_vector  
4813				endm  
# End of macro CALLMONITOR
4813					endif 
4813 18 c0				jr .totsp 
4815 fe 00		.totsiptou:    cp 0 
4817 28 40				jr z, .totdone 
4819					; not space and not zero term so upper case it 
4819 cd 3d 13				call to_upper 
481c			 
481c					if DEBUG_FORTH_WORDS 
481c						DMARK "TC6" 
481c f5				push af  
481d 3a 31 48			ld a, (.dmark)  
4820 32 68 fe			ld (debug_mark),a  
4823 3a 32 48			ld a, (.dmark+1)  
4826 32 69 fe			ld (debug_mark+1),a  
4829 3a 33 48			ld a, (.dmark+2)  
482c 32 6a fe			ld (debug_mark+2),a  
482f 18 03			jr .pastdmark  
4831 ..			.dmark: db "TC6"  
4834 f1			.pastdmark: pop af  
4835			endm  
# End of macro DMARK
4835						CALLMONITOR 
4835 cd 6c fe			call debug_vector  
4838				endm  
# End of macro CALLMONITOR
4838					endif 
4838			 
4838			 
4838			.totnxt: 
4838			 
4838 77					ld (hl), a 
4839 23					inc hl 
483a					if DEBUG_FORTH_WORDS 
483a						DMARK "TC7" 
483a f5				push af  
483b 3a 4f 48			ld a, (.dmark)  
483e 32 68 fe			ld (debug_mark),a  
4841 3a 50 48			ld a, (.dmark+1)  
4844 32 69 fe			ld (debug_mark+1),a  
4847 3a 51 48			ld a, (.dmark+2)  
484a 32 6a fe			ld (debug_mark+2),a  
484d 18 03			jr .pastdmark  
484f ..			.dmark: db "TC7"  
4852 f1			.pastdmark: pop af  
4853			endm  
# End of macro DMARK
4853						CALLMONITOR 
4853 cd 6c fe			call debug_vector  
4856				endm  
# End of macro CALLMONITOR
4856					endif 
4856 c3 8e 47				jp .tot 
4859			 
4859					 
4859			 
4859			 
4859			; for each char convert to low 
4859					 
4859			.totdone: 
4859					if DEBUG_FORTH_WORDS 
4859						DMARK "TCd" 
4859 f5				push af  
485a 3a 6e 48			ld a, (.dmark)  
485d 32 68 fe			ld (debug_mark),a  
4860 3a 6f 48			ld a, (.dmark+1)  
4863 32 69 fe			ld (debug_mark+1),a  
4866 3a 70 48			ld a, (.dmark+2)  
4869 32 6a fe			ld (debug_mark+2),a  
486c 18 03			jr .pastdmark  
486e ..			.dmark: db "TCd"  
4871 f1			.pastdmark: pop af  
4872			endm  
# End of macro DMARK
4872						CALLMONITOR 
4872 cd 6c fe			call debug_vector  
4875				endm  
# End of macro CALLMONITOR
4875					endif 
4875					NEXTW 
4875 c3 b1 24			jp macro_next 
4878				endm 
# End of macro NEXTW
4878			 
4878			.SUBSTR: 
4878				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
4878 48				db WORD_SYS_CORE+52             
4879 d6 48			dw .LEFT            
487b 07				db 6 + 1 
487c .. 00			db "SUBSTR",0              
4883				endm 
# End of macro CWHEAD
4883			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
4883			 
4883					if DEBUG_FORTH_WORDS_KEY 
4883						DMARK "SST" 
4883 f5				push af  
4884 3a 98 48			ld a, (.dmark)  
4887 32 68 fe			ld (debug_mark),a  
488a 3a 99 48			ld a, (.dmark+1)  
488d 32 69 fe			ld (debug_mark+1),a  
4890 3a 9a 48			ld a, (.dmark+2)  
4893 32 6a fe			ld (debug_mark+2),a  
4896 18 03			jr .pastdmark  
4898 ..			.dmark: db "SST"  
489b f1			.pastdmark: pop af  
489c			endm  
# End of macro DMARK
489c						CALLMONITOR 
489c cd 6c fe			call debug_vector  
489f				endm  
# End of macro CALLMONITOR
489f					endif 
489f			; TODO check string type 
489f					FORTH_DSP_VALUEHL 
489f cd fb 22			call macro_dsp_valuehl 
48a2				endm 
# End of macro FORTH_DSP_VALUEHL
48a2			 
48a2 e5					push hl      ; string length 
48a3			 
48a3					FORTH_DSP_POP 
48a3 cd b3 23			call macro_forth_dsp_pop 
48a6				endm 
# End of macro FORTH_DSP_POP
48a6			 
48a6					FORTH_DSP_VALUEHL 
48a6 cd fb 22			call macro_dsp_valuehl 
48a9				endm 
# End of macro FORTH_DSP_VALUEHL
48a9			 
48a9 e5					push hl     ; start char 
48aa			 
48aa					FORTH_DSP_POP 
48aa cd b3 23			call macro_forth_dsp_pop 
48ad				endm 
# End of macro FORTH_DSP_POP
48ad			 
48ad			 
48ad					FORTH_DSP_VALUE 
48ad cd e4 22			call macro_forth_dsp_value 
48b0				endm 
# End of macro FORTH_DSP_VALUE
48b0			 
48b0 d1					pop de    ; get start post offset 
48b1			 
48b1 19					add hl, de    ; starting offset 
48b2			 
48b2 c1					pop bc 
48b3 c5					push bc      ; grab size of string 
48b4			 
48b4 e5					push hl    ; save string start  
48b5			 
48b5 26 00				ld h, 0 
48b7 69					ld l, c 
48b8 23					inc hl 
48b9 23					inc hl 
48ba			 
48ba cd 97 14				call malloc 
48bd				if DEBUG_FORTH_MALLOC_GUARD 
48bd cc 03 5e				call z,malloc_error 
48c0				endif 
48c0			 
48c0 eb					ex de, hl      ; save malloc area for string copy 
48c1 e1					pop hl    ; get back source 
48c2 c1					pop bc    ; get length of string back 
48c3			 
48c3 d5					push de    ; save malloc area for after we push 
48c4 ed b0				ldir     ; copy substr 
48c6			 
48c6			 
48c6 eb					ex de, hl 
48c7 3e 00				ld a, 0 
48c9 77					ld (hl), a   ; term substr 
48ca			 
48ca					 
48ca e1					pop hl    ; get malloc so we can push it 
48cb e5					push hl   ; save so we can free it afterwards 
48cc			 
48cc cd 72 21				call forth_push_str 
48cf			 
48cf e1					pop hl 
48d0 cd 61 15				call free 
48d3			 
48d3					 
48d3					 
48d3			 
48d3			 
48d3					NEXTW 
48d3 c3 b1 24			jp macro_next 
48d6				endm 
# End of macro NEXTW
48d6			 
48d6			.LEFT: 
48d6				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
48d6 48				db WORD_SYS_CORE+52             
48d7 fe 48			dw .RIGHT            
48d9 05				db 4 + 1 
48da .. 00			db "LEFT",0              
48df				endm 
# End of macro CWHEAD
48df			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
48df					if DEBUG_FORTH_WORDS_KEY 
48df						DMARK "LEF" 
48df f5				push af  
48e0 3a f4 48			ld a, (.dmark)  
48e3 32 68 fe			ld (debug_mark),a  
48e6 3a f5 48			ld a, (.dmark+1)  
48e9 32 69 fe			ld (debug_mark+1),a  
48ec 3a f6 48			ld a, (.dmark+2)  
48ef 32 6a fe			ld (debug_mark+2),a  
48f2 18 03			jr .pastdmark  
48f4 ..			.dmark: db "LEF"  
48f7 f1			.pastdmark: pop af  
48f8			endm  
# End of macro DMARK
48f8						CALLMONITOR 
48f8 cd 6c fe			call debug_vector  
48fb				endm  
# End of macro CALLMONITOR
48fb					endif 
48fb			 
48fb					NEXTW 
48fb c3 b1 24			jp macro_next 
48fe				endm 
# End of macro NEXTW
48fe			.RIGHT: 
48fe				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
48fe 48				db WORD_SYS_CORE+52             
48ff 27 49			dw .STR2NUM            
4901 06				db 5 + 1 
4902 .. 00			db "RIGHT",0              
4908				endm 
# End of macro CWHEAD
4908			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
4908					if DEBUG_FORTH_WORDS_KEY 
4908						DMARK "RIG" 
4908 f5				push af  
4909 3a 1d 49			ld a, (.dmark)  
490c 32 68 fe			ld (debug_mark),a  
490f 3a 1e 49			ld a, (.dmark+1)  
4912 32 69 fe			ld (debug_mark+1),a  
4915 3a 1f 49			ld a, (.dmark+2)  
4918 32 6a fe			ld (debug_mark+2),a  
491b 18 03			jr .pastdmark  
491d ..			.dmark: db "RIG"  
4920 f1			.pastdmark: pop af  
4921			endm  
# End of macro DMARK
4921						CALLMONITOR 
4921 cd 6c fe			call debug_vector  
4924				endm  
# End of macro CALLMONITOR
4924					endif 
4924			 
4924					NEXTW 
4924 c3 b1 24			jp macro_next 
4927				endm 
# End of macro NEXTW
4927			 
4927			 
4927			.STR2NUM: 
4927				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
4927 48				db WORD_SYS_CORE+52             
4928 b3 49			dw .NUM2STR            
492a 08				db 7 + 1 
492b .. 00			db "STR2NUM",0              
4933				endm 
# End of macro CWHEAD
4933			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
4933			 
4933			 
4933			; TODO STR type check to do 
4933					if DEBUG_FORTH_WORDS_KEY 
4933						DMARK "S2N" 
4933 f5				push af  
4934 3a 48 49			ld a, (.dmark)  
4937 32 68 fe			ld (debug_mark),a  
493a 3a 49 49			ld a, (.dmark+1)  
493d 32 69 fe			ld (debug_mark+1),a  
4940 3a 4a 49			ld a, (.dmark+2)  
4943 32 6a fe			ld (debug_mark+2),a  
4946 18 03			jr .pastdmark  
4948 ..			.dmark: db "S2N"  
494b f1			.pastdmark: pop af  
494c			endm  
# End of macro DMARK
494c						CALLMONITOR 
494c cd 6c fe			call debug_vector  
494f				endm  
# End of macro CALLMONITOR
494f					endif 
494f			 
494f					;FORTH_DSP 
494f					FORTH_DSP_VALUE 
494f cd e4 22			call macro_forth_dsp_value 
4952				endm 
# End of macro FORTH_DSP_VALUE
4952					;inc hl 
4952			 
4952 eb					ex de, hl 
4953					if DEBUG_FORTH_WORDS 
4953						DMARK "S2a" 
4953 f5				push af  
4954 3a 68 49			ld a, (.dmark)  
4957 32 68 fe			ld (debug_mark),a  
495a 3a 69 49			ld a, (.dmark+1)  
495d 32 69 fe			ld (debug_mark+1),a  
4960 3a 6a 49			ld a, (.dmark+2)  
4963 32 6a fe			ld (debug_mark+2),a  
4966 18 03			jr .pastdmark  
4968 ..			.dmark: db "S2a"  
496b f1			.pastdmark: pop af  
496c			endm  
# End of macro DMARK
496c						CALLMONITOR 
496c cd 6c fe			call debug_vector  
496f				endm  
# End of macro CALLMONITOR
496f					endif 
496f cd c5 13				call string_to_uint16 
4972			 
4972					if DEBUG_FORTH_WORDS 
4972						DMARK "S2b" 
4972 f5				push af  
4973 3a 87 49			ld a, (.dmark)  
4976 32 68 fe			ld (debug_mark),a  
4979 3a 88 49			ld a, (.dmark+1)  
497c 32 69 fe			ld (debug_mark+1),a  
497f 3a 89 49			ld a, (.dmark+2)  
4982 32 6a fe			ld (debug_mark+2),a  
4985 18 03			jr .pastdmark  
4987 ..			.dmark: db "S2b"  
498a f1			.pastdmark: pop af  
498b			endm  
# End of macro DMARK
498b						CALLMONITOR 
498b cd 6c fe			call debug_vector  
498e				endm  
# End of macro CALLMONITOR
498e					endif 
498e			;		push hl 
498e					FORTH_DSP_POP 
498e cd b3 23			call macro_forth_dsp_pop 
4991				endm 
# End of macro FORTH_DSP_POP
4991			;		pop hl 
4991					 
4991					if DEBUG_FORTH_WORDS 
4991						DMARK "S2b" 
4991 f5				push af  
4992 3a a6 49			ld a, (.dmark)  
4995 32 68 fe			ld (debug_mark),a  
4998 3a a7 49			ld a, (.dmark+1)  
499b 32 69 fe			ld (debug_mark+1),a  
499e 3a a8 49			ld a, (.dmark+2)  
49a1 32 6a fe			ld (debug_mark+2),a  
49a4 18 03			jr .pastdmark  
49a6 ..			.dmark: db "S2b"  
49a9 f1			.pastdmark: pop af  
49aa			endm  
# End of macro DMARK
49aa						CALLMONITOR 
49aa cd 6c fe			call debug_vector  
49ad				endm  
# End of macro CALLMONITOR
49ad					endif 
49ad cd 04 21				call forth_push_numhl	 
49b0			 
49b0				 
49b0				       NEXTW 
49b0 c3 b1 24			jp macro_next 
49b3				endm 
# End of macro NEXTW
49b3			.NUM2STR: 
49b3				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
49b3 48				db WORD_SYS_CORE+52             
49b4 c2 49			dw .CONCAT            
49b6 08				db 7 + 1 
49b7 .. 00			db "NUM2STR",0              
49bf				endm 
# End of macro CWHEAD
49bf			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
49bf			 
49bf			;		; malloc a string to target 
49bf			;		ld hl, 10     ; TODO max string size should be fine 
49bf			;		call malloc 
49bf			;		push hl    ; save malloc location 
49bf			; 
49bf			; 
49bf			;; TODO check int type 
49bf			;		FORTH_DSP_VALUEHL 
49bf			;		ld a, l 
49bf			;		call DispAToASCII   
49bf			;;TODO need to chage above call to dump into string 
49bf			; 
49bf			; 
49bf			 
49bf				       NEXTW 
49bf c3 b1 24			jp macro_next 
49c2				endm 
# End of macro NEXTW
49c2			 
49c2			.CONCAT: 
49c2				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
49c2 48				db WORD_SYS_CORE+52             
49c3 75 4a			dw .FIND            
49c5 07				db 6 + 1 
49c6 .. 00			db "CONCAT",0              
49cd				endm 
# End of macro CWHEAD
49cd			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
49cd			 
49cd			; TODO check string type 
49cd			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
49cd			 
49cd					if DEBUG_FORTH_WORDS_KEY 
49cd						DMARK "CON" 
49cd f5				push af  
49ce 3a e2 49			ld a, (.dmark)  
49d1 32 68 fe			ld (debug_mark),a  
49d4 3a e3 49			ld a, (.dmark+1)  
49d7 32 69 fe			ld (debug_mark+1),a  
49da 3a e4 49			ld a, (.dmark+2)  
49dd 32 6a fe			ld (debug_mark+2),a  
49e0 18 03			jr .pastdmark  
49e2 ..			.dmark: db "CON"  
49e5 f1			.pastdmark: pop af  
49e6			endm  
# End of macro DMARK
49e6						CALLMONITOR 
49e6 cd 6c fe			call debug_vector  
49e9				endm  
# End of macro CALLMONITOR
49e9					endif 
49e9			 
49e9			 
49e9					FORTH_DSP_VALUE 
49e9 cd e4 22			call macro_forth_dsp_value 
49ec				endm 
# End of macro FORTH_DSP_VALUE
49ec e5					push hl   ; s2 
49ed			 
49ed					FORTH_DSP_POP 
49ed cd b3 23			call macro_forth_dsp_pop 
49f0				endm 
# End of macro FORTH_DSP_POP
49f0			 
49f0					FORTH_DSP_VALUE 
49f0 cd e4 22			call macro_forth_dsp_value 
49f3				endm 
# End of macro FORTH_DSP_VALUE
49f3			 
49f3 e5					push hl   ; s1 
49f4			 
49f4					FORTH_DSP_POP 
49f4 cd b3 23			call macro_forth_dsp_pop 
49f7				endm 
# End of macro FORTH_DSP_POP
49f7					 
49f7			 
49f7					; copy s1 
49f7			 
49f7				 
49f7					; save ptr 
49f7 e1					pop hl  
49f8 e5					push hl 
49f9 3e 00				ld a, 0 
49fb cd 39 14				call strlent 
49fe					;inc hl    ; zer0 
49fe 06 00				ld b, 0 
4a00 4d					ld c, l 
4a01 e1					pop hl		 
4a02 11 be f1				ld de, scratch	 
4a05					if DEBUG_FORTH_WORDS 
4a05						DMARK "CO1" 
4a05 f5				push af  
4a06 3a 1a 4a			ld a, (.dmark)  
4a09 32 68 fe			ld (debug_mark),a  
4a0c 3a 1b 4a			ld a, (.dmark+1)  
4a0f 32 69 fe			ld (debug_mark+1),a  
4a12 3a 1c 4a			ld a, (.dmark+2)  
4a15 32 6a fe			ld (debug_mark+2),a  
4a18 18 03			jr .pastdmark  
4a1a ..			.dmark: db "CO1"  
4a1d f1			.pastdmark: pop af  
4a1e			endm  
# End of macro DMARK
4a1e						CALLMONITOR 
4a1e cd 6c fe			call debug_vector  
4a21				endm  
# End of macro CALLMONITOR
4a21					endif 
4a21 ed b0				ldir 
4a23			 
4a23 e1					pop hl 
4a24 e5					push hl 
4a25 d5					push de 
4a26			 
4a26			 
4a26 3e 00				ld a, 0 
4a28 cd 39 14				call strlent 
4a2b 23					inc hl    ; zer0 
4a2c 23					inc hl 
4a2d 06 00				ld b, 0 
4a2f 4d					ld c, l 
4a30 d1					pop de 
4a31 e1					pop hl		 
4a32					if DEBUG_FORTH_WORDS 
4a32						DMARK "CO2" 
4a32 f5				push af  
4a33 3a 47 4a			ld a, (.dmark)  
4a36 32 68 fe			ld (debug_mark),a  
4a39 3a 48 4a			ld a, (.dmark+1)  
4a3c 32 69 fe			ld (debug_mark+1),a  
4a3f 3a 49 4a			ld a, (.dmark+2)  
4a42 32 6a fe			ld (debug_mark+2),a  
4a45 18 03			jr .pastdmark  
4a47 ..			.dmark: db "CO2"  
4a4a f1			.pastdmark: pop af  
4a4b			endm  
# End of macro DMARK
4a4b						CALLMONITOR 
4a4b cd 6c fe			call debug_vector  
4a4e				endm  
# End of macro CALLMONITOR
4a4e					endif 
4a4e ed b0				ldir 
4a50			 
4a50			 
4a50			 
4a50 21 be f1				ld hl, scratch 
4a53					if DEBUG_FORTH_WORDS 
4a53						DMARK "CO5" 
4a53 f5				push af  
4a54 3a 68 4a			ld a, (.dmark)  
4a57 32 68 fe			ld (debug_mark),a  
4a5a 3a 69 4a			ld a, (.dmark+1)  
4a5d 32 69 fe			ld (debug_mark+1),a  
4a60 3a 6a 4a			ld a, (.dmark+2)  
4a63 32 6a fe			ld (debug_mark+2),a  
4a66 18 03			jr .pastdmark  
4a68 ..			.dmark: db "CO5"  
4a6b f1			.pastdmark: pop af  
4a6c			endm  
# End of macro DMARK
4a6c						CALLMONITOR 
4a6c cd 6c fe			call debug_vector  
4a6f				endm  
# End of macro CALLMONITOR
4a6f					endif 
4a6f			 
4a6f cd 72 21				call forth_push_str 
4a72			 
4a72			 
4a72			 
4a72			 
4a72				       NEXTW 
4a72 c3 b1 24			jp macro_next 
4a75				endm 
# End of macro NEXTW
4a75			 
4a75			 
4a75			.FIND: 
4a75				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
4a75 4b				db WORD_SYS_CORE+55             
4a76 33 4b			dw .LEN            
4a78 05				db 4 + 1 
4a79 .. 00			db "FIND",0              
4a7e				endm 
# End of macro CWHEAD
4a7e			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
4a7e			 
4a7e					if DEBUG_FORTH_WORDS_KEY 
4a7e						DMARK "FND" 
4a7e f5				push af  
4a7f 3a 93 4a			ld a, (.dmark)  
4a82 32 68 fe			ld (debug_mark),a  
4a85 3a 94 4a			ld a, (.dmark+1)  
4a88 32 69 fe			ld (debug_mark+1),a  
4a8b 3a 95 4a			ld a, (.dmark+2)  
4a8e 32 6a fe			ld (debug_mark+2),a  
4a91 18 03			jr .pastdmark  
4a93 ..			.dmark: db "FND"  
4a96 f1			.pastdmark: pop af  
4a97			endm  
# End of macro DMARK
4a97						CALLMONITOR 
4a97 cd 6c fe			call debug_vector  
4a9a				endm  
# End of macro CALLMONITOR
4a9a					endif 
4a9a			 
4a9a			; TODO check string type 
4a9a					FORTH_DSP_VALUE 
4a9a cd e4 22			call macro_forth_dsp_value 
4a9d				endm 
# End of macro FORTH_DSP_VALUE
4a9d			 
4a9d e5					push hl    
4a9e 7e					ld a,(hl)    ; char to find   
4a9f			; TODO change char to substr 
4a9f			 
4a9f f5					push af 
4aa0					 
4aa0			 
4aa0			 
4aa0					if DEBUG_FORTH_WORDS 
4aa0						DMARK "FN1" 
4aa0 f5				push af  
4aa1 3a b5 4a			ld a, (.dmark)  
4aa4 32 68 fe			ld (debug_mark),a  
4aa7 3a b6 4a			ld a, (.dmark+1)  
4aaa 32 69 fe			ld (debug_mark+1),a  
4aad 3a b7 4a			ld a, (.dmark+2)  
4ab0 32 6a fe			ld (debug_mark+2),a  
4ab3 18 03			jr .pastdmark  
4ab5 ..			.dmark: db "FN1"  
4ab8 f1			.pastdmark: pop af  
4ab9			endm  
# End of macro DMARK
4ab9						CALLMONITOR 
4ab9 cd 6c fe			call debug_vector  
4abc				endm  
# End of macro CALLMONITOR
4abc					endif 
4abc			 
4abc					FORTH_DSP_POP 
4abc cd b3 23			call macro_forth_dsp_pop 
4abf				endm 
# End of macro FORTH_DSP_POP
4abf			 
4abf					; string to search 
4abf			 
4abf					FORTH_DSP_VALUE 
4abf cd e4 22			call macro_forth_dsp_value 
4ac2				endm 
# End of macro FORTH_DSP_VALUE
4ac2			 
4ac2 d1					pop de  ; d is char to find  
4ac3			 
4ac3					if DEBUG_FORTH_WORDS 
4ac3						DMARK "FN2" 
4ac3 f5				push af  
4ac4 3a d8 4a			ld a, (.dmark)  
4ac7 32 68 fe			ld (debug_mark),a  
4aca 3a d9 4a			ld a, (.dmark+1)  
4acd 32 69 fe			ld (debug_mark+1),a  
4ad0 3a da 4a			ld a, (.dmark+2)  
4ad3 32 6a fe			ld (debug_mark+2),a  
4ad6 18 03			jr .pastdmark  
4ad8 ..			.dmark: db "FN2"  
4adb f1			.pastdmark: pop af  
4adc			endm  
# End of macro DMARK
4adc						CALLMONITOR 
4adc cd 6c fe			call debug_vector  
4adf				endm  
# End of macro CALLMONITOR
4adf					endif 
4adf					 
4adf 01 00 00				ld bc, 0 
4ae2 7e			.findchar:      ld a,(hl) 
4ae3 fe 00				cp 0   		 
4ae5 28 27				jr z, .finddone     
4ae7 ba					cp d 
4ae8 28 20				jr z, .foundchar 
4aea 03					inc bc 
4aeb 23					inc hl 
4aec					if DEBUG_FORTH_WORDS 
4aec						DMARK "FN3" 
4aec f5				push af  
4aed 3a 01 4b			ld a, (.dmark)  
4af0 32 68 fe			ld (debug_mark),a  
4af3 3a 02 4b			ld a, (.dmark+1)  
4af6 32 69 fe			ld (debug_mark+1),a  
4af9 3a 03 4b			ld a, (.dmark+2)  
4afc 32 6a fe			ld (debug_mark+2),a  
4aff 18 03			jr .pastdmark  
4b01 ..			.dmark: db "FN3"  
4b04 f1			.pastdmark: pop af  
4b05			endm  
# End of macro DMARK
4b05						CALLMONITOR 
4b05 cd 6c fe			call debug_vector  
4b08				endm  
# End of macro CALLMONITOR
4b08					endif 
4b08 18 d8				jr .findchar 
4b0a			 
4b0a			 
4b0a c5			.foundchar:	push bc 
4b0b e1					pop hl 
4b0c 18 03				jr .findexit 
4b0e			 
4b0e			 
4b0e							 
4b0e			 
4b0e			.finddone:     ; got to end of string with no find 
4b0e 21 00 00				ld hl, 0 
4b11			.findexit: 
4b11			 
4b11					if DEBUG_FORTH_WORDS 
4b11						DMARK "FNd" 
4b11 f5				push af  
4b12 3a 26 4b			ld a, (.dmark)  
4b15 32 68 fe			ld (debug_mark),a  
4b18 3a 27 4b			ld a, (.dmark+1)  
4b1b 32 69 fe			ld (debug_mark+1),a  
4b1e 3a 28 4b			ld a, (.dmark+2)  
4b21 32 6a fe			ld (debug_mark+2),a  
4b24 18 03			jr .pastdmark  
4b26 ..			.dmark: db "FNd"  
4b29 f1			.pastdmark: pop af  
4b2a			endm  
# End of macro DMARK
4b2a						CALLMONITOR 
4b2a cd 6c fe			call debug_vector  
4b2d				endm  
# End of macro CALLMONITOR
4b2d					endif 
4b2d cd 04 21			call forth_push_numhl 
4b30			 
4b30				       NEXTW 
4b30 c3 b1 24			jp macro_next 
4b33				endm 
# End of macro NEXTW
4b33			 
4b33			.LEN: 
4b33				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
4b33 4c				db WORD_SYS_CORE+56             
4b34 9d 4b			dw .ASC            
4b36 06				db 5 + 1 
4b37 .. 00			db "COUNT",0              
4b3d				endm 
# End of macro CWHEAD
4b3d			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
4b3d			 
4b3d					if DEBUG_FORTH_WORDS_KEY 
4b3d						DMARK "CNT" 
4b3d f5				push af  
4b3e 3a 52 4b			ld a, (.dmark)  
4b41 32 68 fe			ld (debug_mark),a  
4b44 3a 53 4b			ld a, (.dmark+1)  
4b47 32 69 fe			ld (debug_mark+1),a  
4b4a 3a 54 4b			ld a, (.dmark+2)  
4b4d 32 6a fe			ld (debug_mark+2),a  
4b50 18 03			jr .pastdmark  
4b52 ..			.dmark: db "CNT"  
4b55 f1			.pastdmark: pop af  
4b56			endm  
# End of macro DMARK
4b56						CALLMONITOR 
4b56 cd 6c fe			call debug_vector  
4b59				endm  
# End of macro CALLMONITOR
4b59					endif 
4b59			; TODO check string type 
4b59					FORTH_DSP_VALUE 
4b59 cd e4 22			call macro_forth_dsp_value 
4b5c				endm 
# End of macro FORTH_DSP_VALUE
4b5c			 
4b5c			 
4b5c					if DEBUG_FORTH_WORDS 
4b5c						DMARK "CN?" 
4b5c f5				push af  
4b5d 3a 71 4b			ld a, (.dmark)  
4b60 32 68 fe			ld (debug_mark),a  
4b63 3a 72 4b			ld a, (.dmark+1)  
4b66 32 69 fe			ld (debug_mark+1),a  
4b69 3a 73 4b			ld a, (.dmark+2)  
4b6c 32 6a fe			ld (debug_mark+2),a  
4b6f 18 03			jr .pastdmark  
4b71 ..			.dmark: db "CN?"  
4b74 f1			.pastdmark: pop af  
4b75			endm  
# End of macro DMARK
4b75						CALLMONITOR 
4b75 cd 6c fe			call debug_vector  
4b78				endm  
# End of macro CALLMONITOR
4b78					endif 
4b78 cd 2e 14				call strlenz 
4b7b					if DEBUG_FORTH_WORDS 
4b7b						DMARK "CNl" 
4b7b f5				push af  
4b7c 3a 90 4b			ld a, (.dmark)  
4b7f 32 68 fe			ld (debug_mark),a  
4b82 3a 91 4b			ld a, (.dmark+1)  
4b85 32 69 fe			ld (debug_mark+1),a  
4b88 3a 92 4b			ld a, (.dmark+2)  
4b8b 32 6a fe			ld (debug_mark+2),a  
4b8e 18 03			jr .pastdmark  
4b90 ..			.dmark: db "CNl"  
4b93 f1			.pastdmark: pop af  
4b94			endm  
# End of macro DMARK
4b94						CALLMONITOR 
4b94 cd 6c fe			call debug_vector  
4b97				endm  
# End of macro CALLMONITOR
4b97					endif 
4b97			 
4b97 cd 04 21				call forth_push_numhl 
4b9a			 
4b9a			 
4b9a			 
4b9a				       NEXTW 
4b9a c3 b1 24			jp macro_next 
4b9d				endm 
# End of macro NEXTW
4b9d			.ASC: 
4b9d				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
4b9d 4d				db WORD_SYS_CORE+57             
4b9e 0b 4c			dw .CHR            
4ba0 04				db 3 + 1 
4ba1 .. 00			db "ASC",0              
4ba5				endm 
# End of macro CWHEAD
4ba5			; | ASC ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
4ba5					if DEBUG_FORTH_WORDS_KEY 
4ba5						DMARK "ASC" 
4ba5 f5				push af  
4ba6 3a ba 4b			ld a, (.dmark)  
4ba9 32 68 fe			ld (debug_mark),a  
4bac 3a bb 4b			ld a, (.dmark+1)  
4baf 32 69 fe			ld (debug_mark+1),a  
4bb2 3a bc 4b			ld a, (.dmark+2)  
4bb5 32 6a fe			ld (debug_mark+2),a  
4bb8 18 03			jr .pastdmark  
4bba ..			.dmark: db "ASC"  
4bbd f1			.pastdmark: pop af  
4bbe			endm  
# End of macro DMARK
4bbe						CALLMONITOR 
4bbe cd 6c fe			call debug_vector  
4bc1				endm  
# End of macro CALLMONITOR
4bc1					endif 
4bc1					FORTH_DSP_VALUE 
4bc1 cd e4 22			call macro_forth_dsp_value 
4bc4				endm 
# End of macro FORTH_DSP_VALUE
4bc4					;v5 FORTH_DSP_VALUE 
4bc4			;		inc hl      ; now at start of numeric as string 
4bc4			 
4bc4 e5					push hl 
4bc5			 
4bc5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4bc5 cd b3 23			call macro_forth_dsp_pop 
4bc8				endm 
# End of macro FORTH_DSP_POP
4bc8			 
4bc8 e1					pop hl 
4bc9			 
4bc9					if DEBUG_FORTH_WORDS 
4bc9						DMARK "AS1" 
4bc9 f5				push af  
4bca 3a de 4b			ld a, (.dmark)  
4bcd 32 68 fe			ld (debug_mark),a  
4bd0 3a df 4b			ld a, (.dmark+1)  
4bd3 32 69 fe			ld (debug_mark+1),a  
4bd6 3a e0 4b			ld a, (.dmark+2)  
4bd9 32 6a fe			ld (debug_mark+2),a  
4bdc 18 03			jr .pastdmark  
4bde ..			.dmark: db "AS1"  
4be1 f1			.pastdmark: pop af  
4be2			endm  
# End of macro DMARK
4be2						CALLMONITOR 
4be2 cd 6c fe			call debug_vector  
4be5				endm  
# End of macro CALLMONITOR
4be5					endif 
4be5					; push the content of a onto the stack as a value 
4be5			 
4be5 7e					ld a,(hl)   ; get char 
4be6 26 00				ld h,0 
4be8 6f					ld l,a 
4be9					if DEBUG_FORTH_WORDS 
4be9						DMARK "AS2" 
4be9 f5				push af  
4bea 3a fe 4b			ld a, (.dmark)  
4bed 32 68 fe			ld (debug_mark),a  
4bf0 3a ff 4b			ld a, (.dmark+1)  
4bf3 32 69 fe			ld (debug_mark+1),a  
4bf6 3a 00 4c			ld a, (.dmark+2)  
4bf9 32 6a fe			ld (debug_mark+2),a  
4bfc 18 03			jr .pastdmark  
4bfe ..			.dmark: db "AS2"  
4c01 f1			.pastdmark: pop af  
4c02			endm  
# End of macro DMARK
4c02						CALLMONITOR 
4c02 cd 6c fe			call debug_vector  
4c05				endm  
# End of macro CALLMONITOR
4c05					endif 
4c05 cd 04 21				call forth_push_numhl 
4c08			 
4c08				       NEXTW 
4c08 c3 b1 24			jp macro_next 
4c0b				endm 
# End of macro NEXTW
4c0b			 
4c0b			.CHR: 
4c0b				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
4c0b 4d				db WORD_SYS_CORE+57             
4c0c 47 4c			dw .ENDSTR            
4c0e 04				db 3 + 1 
4c0f .. 00			db "CHR",0              
4c13				endm 
# End of macro CWHEAD
4c13			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
4c13					if DEBUG_FORTH_WORDS_KEY 
4c13						DMARK "CHR" 
4c13 f5				push af  
4c14 3a 28 4c			ld a, (.dmark)  
4c17 32 68 fe			ld (debug_mark),a  
4c1a 3a 29 4c			ld a, (.dmark+1)  
4c1d 32 69 fe			ld (debug_mark+1),a  
4c20 3a 2a 4c			ld a, (.dmark+2)  
4c23 32 6a fe			ld (debug_mark+2),a  
4c26 18 03			jr .pastdmark  
4c28 ..			.dmark: db "CHR"  
4c2b f1			.pastdmark: pop af  
4c2c			endm  
# End of macro DMARK
4c2c						CALLMONITOR 
4c2c cd 6c fe			call debug_vector  
4c2f				endm  
# End of macro CALLMONITOR
4c2f					endif 
4c2f					FORTH_DSP_VALUEHL 
4c2f cd fb 22			call macro_dsp_valuehl 
4c32				endm 
# End of macro FORTH_DSP_VALUEHL
4c32			 
4c32					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c32 cd b3 23			call macro_forth_dsp_pop 
4c35				endm 
# End of macro FORTH_DSP_POP
4c35			 
4c35					; save asci byte as a zero term string and push string 
4c35			 
4c35 7d					ld a,l 
4c36 32 be f1				ld (scratch), a 
4c39			 
4c39 3e 00				ld a, 0 
4c3b 32 bf f1				ld (scratch+1), a 
4c3e			 
4c3e 21 be f1				ld hl, scratch 
4c41 cd 72 21				call forth_push_str 
4c44			 
4c44			 
4c44				       NEXTW 
4c44 c3 b1 24			jp macro_next 
4c47				endm 
# End of macro NEXTW
4c47			 
4c47			 
4c47			 
4c47			 
4c47			.ENDSTR: 
4c47			; eof 
4c47			 
# End of file forth_words_str.asm
4c47			include "forth_words_key.asm" 
4c47			 
4c47			; | ## Keyboard Words 
4c47			 
4c47			.KEY: 
4c47				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
4c47 3e				db WORD_SYS_CORE+42             
4c48 77 4c			dw .WAITK            
4c4a 04				db 3 + 1 
4c4b .. 00			db "KEY",0              
4c4f				endm 
# End of macro CWHEAD
4c4f			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
4c4f			 
4c4f					if DEBUG_FORTH_WORDS_KEY 
4c4f						DMARK "KEY" 
4c4f f5				push af  
4c50 3a 64 4c			ld a, (.dmark)  
4c53 32 68 fe			ld (debug_mark),a  
4c56 3a 65 4c			ld a, (.dmark+1)  
4c59 32 69 fe			ld (debug_mark+1),a  
4c5c 3a 66 4c			ld a, (.dmark+2)  
4c5f 32 6a fe			ld (debug_mark+2),a  
4c62 18 03			jr .pastdmark  
4c64 ..			.dmark: db "KEY"  
4c67 f1			.pastdmark: pop af  
4c68			endm  
# End of macro DMARK
4c68						CALLMONITOR 
4c68 cd 6c fe			call debug_vector  
4c6b				endm  
# End of macro CALLMONITOR
4c6b					endif 
4c6b			; TODO currently waits 
4c6b cd d3 79				call cin 
4c6e					;call cin_wait 
4c6e 6f					ld l, a 
4c6f 26 00				ld h, 0 
4c71 cd 04 21				call forth_push_numhl 
4c74					NEXTW 
4c74 c3 b1 24			jp macro_next 
4c77				endm 
# End of macro NEXTW
4c77			.WAITK: 
4c77				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4c77 3f				db WORD_SYS_CORE+43             
4c78 a9 4c			dw .ACCEPT            
4c7a 06				db 5 + 1 
4c7b .. 00			db "WAITK",0              
4c81				endm 
# End of macro CWHEAD
4c81			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4c81					if DEBUG_FORTH_WORDS_KEY 
4c81						DMARK "WAI" 
4c81 f5				push af  
4c82 3a 96 4c			ld a, (.dmark)  
4c85 32 68 fe			ld (debug_mark),a  
4c88 3a 97 4c			ld a, (.dmark+1)  
4c8b 32 69 fe			ld (debug_mark+1),a  
4c8e 3a 98 4c			ld a, (.dmark+2)  
4c91 32 6a fe			ld (debug_mark+2),a  
4c94 18 03			jr .pastdmark  
4c96 ..			.dmark: db "WAI"  
4c99 f1			.pastdmark: pop af  
4c9a			endm  
# End of macro DMARK
4c9a						CALLMONITOR 
4c9a cd 6c fe			call debug_vector  
4c9d				endm  
# End of macro CALLMONITOR
4c9d					endif 
4c9d cd c2 79				call cin_wait 
4ca0 6f					ld l, a 
4ca1 26 00				ld h, 0 
4ca3 cd 04 21				call forth_push_numhl 
4ca6					NEXTW 
4ca6 c3 b1 24			jp macro_next 
4ca9				endm 
# End of macro NEXTW
4ca9			.ACCEPT: 
4ca9				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4ca9 40				db WORD_SYS_CORE+44             
4caa 07 4d			dw .EDIT            
4cac 07				db 6 + 1 
4cad .. 00			db "ACCEPT",0              
4cb4				endm 
# End of macro CWHEAD
4cb4			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
4cb4					; TODO crashes on push 
4cb4					if DEBUG_FORTH_WORDS_KEY 
4cb4						DMARK "ACC" 
4cb4 f5				push af  
4cb5 3a c9 4c			ld a, (.dmark)  
4cb8 32 68 fe			ld (debug_mark),a  
4cbb 3a ca 4c			ld a, (.dmark+1)  
4cbe 32 69 fe			ld (debug_mark+1),a  
4cc1 3a cb 4c			ld a, (.dmark+2)  
4cc4 32 6a fe			ld (debug_mark+2),a  
4cc7 18 03			jr .pastdmark  
4cc9 ..			.dmark: db "ACC"  
4ccc f1			.pastdmark: pop af  
4ccd			endm  
# End of macro DMARK
4ccd						CALLMONITOR 
4ccd cd 6c fe			call debug_vector  
4cd0				endm  
# End of macro CALLMONITOR
4cd0					endif 
4cd0 21 bc f3				ld hl, os_input 
4cd3 3e 00				ld a, 0 
4cd5 77					ld (hl),a 
4cd6 3a 5b fa				ld a,(f_cursor_ptr) 
4cd9 16 64				ld d, 100 
4cdb 0e 00				ld c, 0 
4cdd 1e 28				ld e, 40 
4cdf cd fd 0f				call input_str 
4ce2					; TODO perhaps do a type check and wrap in quotes if not a number 
4ce2 21 bc f3				ld hl, os_input 
4ce5					if DEBUG_FORTH_WORDS 
4ce5						DMARK "AC1" 
4ce5 f5				push af  
4ce6 3a fa 4c			ld a, (.dmark)  
4ce9 32 68 fe			ld (debug_mark),a  
4cec 3a fb 4c			ld a, (.dmark+1)  
4cef 32 69 fe			ld (debug_mark+1),a  
4cf2 3a fc 4c			ld a, (.dmark+2)  
4cf5 32 6a fe			ld (debug_mark+2),a  
4cf8 18 03			jr .pastdmark  
4cfa ..			.dmark: db "AC1"  
4cfd f1			.pastdmark: pop af  
4cfe			endm  
# End of macro DMARK
4cfe						CALLMONITOR 
4cfe cd 6c fe			call debug_vector  
4d01				endm  
# End of macro CALLMONITOR
4d01					endif 
4d01 cd 72 21				call forth_push_str 
4d04					NEXTW 
4d04 c3 b1 24			jp macro_next 
4d07				endm 
# End of macro NEXTW
4d07			 
4d07			.EDIT: 
4d07				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
4d07 40				db WORD_SYS_CORE+44             
4d08 a9 4d			dw .DEDIT            
4d0a 05				db 4 + 1 
4d0b .. 00			db "EDIT",0              
4d10				endm 
# End of macro CWHEAD
4d10			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4d10			 
4d10					; TODO does not copy from stack 
4d10					if DEBUG_FORTH_WORDS_KEY 
4d10						DMARK "EDT" 
4d10 f5				push af  
4d11 3a 25 4d			ld a, (.dmark)  
4d14 32 68 fe			ld (debug_mark),a  
4d17 3a 26 4d			ld a, (.dmark+1)  
4d1a 32 69 fe			ld (debug_mark+1),a  
4d1d 3a 27 4d			ld a, (.dmark+2)  
4d20 32 6a fe			ld (debug_mark+2),a  
4d23 18 03			jr .pastdmark  
4d25 ..			.dmark: db "EDT"  
4d28 f1			.pastdmark: pop af  
4d29			endm  
# End of macro DMARK
4d29						CALLMONITOR 
4d29 cd 6c fe			call debug_vector  
4d2c				endm  
# End of macro CALLMONITOR
4d2c					endif 
4d2c			 
4d2c					;FORTH_DSP 
4d2c					FORTH_DSP_VALUEHL 
4d2c cd fb 22			call macro_dsp_valuehl 
4d2f				endm 
# End of macro FORTH_DSP_VALUEHL
4d2f			;		inc hl    ; TODO do type check 
4d2f			 
4d2f			;		call get_word_hl 
4d2f e5					push hl 
4d30					if DEBUG_FORTH_WORDS 
4d30						DMARK "EDp" 
4d30 f5				push af  
4d31 3a 45 4d			ld a, (.dmark)  
4d34 32 68 fe			ld (debug_mark),a  
4d37 3a 46 4d			ld a, (.dmark+1)  
4d3a 32 69 fe			ld (debug_mark+1),a  
4d3d 3a 47 4d			ld a, (.dmark+2)  
4d40 32 6a fe			ld (debug_mark+2),a  
4d43 18 03			jr .pastdmark  
4d45 ..			.dmark: db "EDp"  
4d48 f1			.pastdmark: pop af  
4d49			endm  
# End of macro DMARK
4d49						CALLMONITOR 
4d49 cd 6c fe			call debug_vector  
4d4c				endm  
# End of macro CALLMONITOR
4d4c					endif 
4d4c				;	ld a, 0 
4d4c cd 2e 14				call strlenz 
4d4f 23					inc hl 
4d50			 
4d50 06 00				ld b, 0 
4d52 4d					ld c, l 
4d53			 
4d53 e1					pop hl 
4d54 11 bc f3				ld de, os_input 
4d57					if DEBUG_FORTH_WORDS_KEY 
4d57						DMARK "EDc" 
4d57 f5				push af  
4d58 3a 6c 4d			ld a, (.dmark)  
4d5b 32 68 fe			ld (debug_mark),a  
4d5e 3a 6d 4d			ld a, (.dmark+1)  
4d61 32 69 fe			ld (debug_mark+1),a  
4d64 3a 6e 4d			ld a, (.dmark+2)  
4d67 32 6a fe			ld (debug_mark+2),a  
4d6a 18 03			jr .pastdmark  
4d6c ..			.dmark: db "EDc"  
4d6f f1			.pastdmark: pop af  
4d70			endm  
# End of macro DMARK
4d70						CALLMONITOR 
4d70 cd 6c fe			call debug_vector  
4d73				endm  
# End of macro CALLMONITOR
4d73					endif 
4d73 ed b0				ldir 
4d75			 
4d75			 
4d75 21 bc f3				ld hl, os_input 
4d78					;ld a, 0 
4d78					;ld (hl),a 
4d78 3a 5b fa				ld a,(f_cursor_ptr) 
4d7b 16 64				ld d, 100 
4d7d 0e 00				ld c, 0 
4d7f 1e 28				ld e, 40 
4d81 cd fd 0f				call input_str 
4d84					; TODO perhaps do a type check and wrap in quotes if not a number 
4d84 21 bc f3				ld hl, os_input 
4d87					if DEBUG_FORTH_WORDS 
4d87						DMARK "ED1" 
4d87 f5				push af  
4d88 3a 9c 4d			ld a, (.dmark)  
4d8b 32 68 fe			ld (debug_mark),a  
4d8e 3a 9d 4d			ld a, (.dmark+1)  
4d91 32 69 fe			ld (debug_mark+1),a  
4d94 3a 9e 4d			ld a, (.dmark+2)  
4d97 32 6a fe			ld (debug_mark+2),a  
4d9a 18 03			jr .pastdmark  
4d9c ..			.dmark: db "ED1"  
4d9f f1			.pastdmark: pop af  
4da0			endm  
# End of macro DMARK
4da0						CALLMONITOR 
4da0 cd 6c fe			call debug_vector  
4da3				endm  
# End of macro CALLMONITOR
4da3					endif 
4da3 cd 72 21				call forth_push_str 
4da6					NEXTW 
4da6 c3 b1 24			jp macro_next 
4da9				endm 
# End of macro NEXTW
4da9			 
4da9			.DEDIT: 
4da9				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
4da9 40				db WORD_SYS_CORE+44             
4daa 0b 4e			dw .ENDKEY            
4dac 06				db 5 + 1 
4dad .. 00			db "DEDIT",0              
4db3				endm 
# End of macro CWHEAD
4db3			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
4db3			 
4db3					; TODO does not copy from stack 
4db3					if DEBUG_FORTH_WORDS_KEY 
4db3						DMARK "DED" 
4db3 f5				push af  
4db4 3a c8 4d			ld a, (.dmark)  
4db7 32 68 fe			ld (debug_mark),a  
4dba 3a c9 4d			ld a, (.dmark+1)  
4dbd 32 69 fe			ld (debug_mark+1),a  
4dc0 3a ca 4d			ld a, (.dmark+2)  
4dc3 32 6a fe			ld (debug_mark+2),a  
4dc6 18 03			jr .pastdmark  
4dc8 ..			.dmark: db "DED"  
4dcb f1			.pastdmark: pop af  
4dcc			endm  
# End of macro DMARK
4dcc						CALLMONITOR 
4dcc cd 6c fe			call debug_vector  
4dcf				endm  
# End of macro CALLMONITOR
4dcf					endif 
4dcf			 
4dcf					;FORTH_DSP 
4dcf					FORTH_DSP_VALUEHL 
4dcf cd fb 22			call macro_dsp_valuehl 
4dd2				endm 
# End of macro FORTH_DSP_VALUEHL
4dd2			;		inc hl    ; TODO do type check 
4dd2			 
4dd2			;		call get_word_hl 
4dd2 e5					push hl 
4dd3 e5					push hl 
4dd4					FORTH_DSP_POP 
4dd4 cd b3 23			call macro_forth_dsp_pop 
4dd7				endm 
# End of macro FORTH_DSP_POP
4dd7 e1					pop hl 
4dd8					if DEBUG_FORTH_WORDS 
4dd8						DMARK "EDp" 
4dd8 f5				push af  
4dd9 3a ed 4d			ld a, (.dmark)  
4ddc 32 68 fe			ld (debug_mark),a  
4ddf 3a ee 4d			ld a, (.dmark+1)  
4de2 32 69 fe			ld (debug_mark+1),a  
4de5 3a ef 4d			ld a, (.dmark+2)  
4de8 32 6a fe			ld (debug_mark+2),a  
4deb 18 03			jr .pastdmark  
4ded ..			.dmark: db "EDp"  
4df0 f1			.pastdmark: pop af  
4df1			endm  
# End of macro DMARK
4df1						CALLMONITOR 
4df1 cd 6c fe			call debug_vector  
4df4				endm  
# End of macro CALLMONITOR
4df4					endif 
4df4				;	ld a, 0 
4df4 cd 2e 14				call strlenz 
4df7 23					inc hl 
4df8			 
4df8 06 00				ld b, 0 
4dfa 4d					ld c, l 
4dfb			 
4dfb e1					pop hl 
4dfc			 
4dfc					;ld a, 0 
4dfc					;ld (hl),a 
4dfc 3a 5b fa				ld a,(f_cursor_ptr) 
4dff 16 64				ld d, 100 
4e01 0e 00				ld c, 0 
4e03 1e 28				ld e, 40 
4e05 cd fd 0f				call input_str 
4e08					; TODO perhaps do a type check and wrap in quotes if not a number 
4e08					NEXTW 
4e08 c3 b1 24			jp macro_next 
4e0b				endm 
# End of macro NEXTW
4e0b			 
4e0b			 
4e0b			.ENDKEY: 
4e0b			; eof 
4e0b			 
# End of file forth_words_key.asm
4e0b			include "forth_words_const.asm" 
4e0b			 
4e0b			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
4e0b			 
4e0b			 
4e0b			.SPITIME: 
4e0b				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
4e0b 77				db WORD_SYS_CORE+99             
4e0c 20 4e			dw .VA            
4e0e 08				db 7 + 1 
4e0f .. 00			db "SPITIME",0              
4e17				endm 
# End of macro CWHEAD
4e17			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack 
4e17			; 
4e17			; | If using BANK devices then leave as is. 
4e17			; | Only really useful for the CARTDEV where other devices may be too far or slow. In particular 
4e17			; | the multiplexing of the PicoSPINet device which might not be running fast enough for all of the nodes 
4e17			 
4e17 21 61 fa				ld hl, spi_clktime  
4e1a cd 04 21				call forth_push_numhl 
4e1d			 
4e1d					NEXTW 
4e1d c3 b1 24			jp macro_next 
4e20				endm 
# End of macro NEXTW
4e20			 
4e20			 
4e20			.VA: 
4e20				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
4e20 77				db WORD_SYS_CORE+99             
4e21 30 4e			dw .SYMBOL            
4e23 03				db 2 + 1 
4e24 .. 00			db "VA",0              
4e27				endm 
# End of macro CWHEAD
4e27			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 
4e27 21 25 fa				ld hl, cli_var_array 
4e2a cd 04 21				call forth_push_numhl 
4e2d			 
4e2d					NEXTW 
4e2d c3 b1 24			jp macro_next 
4e30				endm 
# End of macro NEXTW
4e30			 
4e30			.SYMBOL: 
4e30				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
4e30 77				db WORD_SYS_CORE+99             
4e31 3a 4f			dw .ENDCONST            
4e33 07				db 6 + 1 
4e34 .. 00			db "SYMBOL",0              
4e3b				endm 
# End of macro CWHEAD
4e3b			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
4e3b			; | 
4e3b			; | The value is the number reference and the final address is pushed to stack 
4e3b			 
4e3b			; | dw sym_table 
4e3b			; | dw nmi_vector 
4e3b			; | dw cli_autodisplay 
4e3b			; | dw cli_data_sp 
4e3b			; | dw cli_data_stack 
4e3b			; | dw cli_loop_sp 
4e3b			; | dw cli_loop_stack 
4e3b			; | dw cli_var_array 
4e3b			; | dw cursor_col 
4e3b			; | dw cursor_ptr 
4e3b			; | ; 10 
4e3b			; | dw cursor_row 
4e3b			; | dw debug_mark 
4e3b			; | dw display_fb0 
4e3b			; | dw display_fb1 
4e3b			; | dw display_fb2 
4e3b			; | dw display_fb3 
4e3b			; | dw display_fb_active 
4e3b			; | dw execscratch 
4e3b			; | dw f_cursor_ptr 
4e3b			; | dw hardware_word 
4e3b			; | ;20 
4e3b			; | dw input_at_cursor 
4e3b			; | dw input_at_pos 
4e3b			; | dw input_cur_flash 
4e3b			; | dw input_cur_onoff 
4e3b			; | dw input_cursor 
4e3b			; | dw input_display_size 
4e3b			; | dw input_len 
4e3b			; | dw input_ptr 
4e3b			; | dw input_size 
4e3b			; | dw input_start 
4e3b			; | ; 30 
4e3b			; | dw input_str 
4e3b			; | dw input_under_cursor 
4e3b			; | dw os_cli_cmd 
4e3b			; | dw os_cur_ptr 
4e3b			; | dw os_current_i 
4e3b			; | dw os_input 
4e3b			; | dw os_last_cmd 
4e3b			; | dw os_last_new_uword 
4e3b			; | dw debug_vector 
4e3b			; | dw os_view_hl 
4e3b			; | ;40 
4e3b			; | dw os_word_scratch 
4e3b			; | dw portbctl 
4e3b			; | dw portbdata 
4e3b			; | dw spi_cartdev 
4e3b			; | dw spi_cartdev2 
4e3b			; | dw spi_clktime 
4e3b			; | dw spi_device 
4e3b			; | dw spi_device_id 
4e3b			; | dw spi_portbyte 
4e3b			; | dw stackstore 
4e3b			; | ; 50 
4e3b			; | if STORAGE_SE 
4e3b			; | dw storage_actl 
4e3b			; | dw storage_adata 
4e3b			; | else 
4e3b			; | dw 0 
4e3b			; | dw 0 
4e3b			; | endif 
4e3b			; | dw storage_append 
4e3b			; | if STORAGE_SE 
4e3b			; | dw storage_bctl 
4e3b			; | else 
4e3b			; | dw 0 
4e3b			; | endif 
4e3b			; | dw store_bank_active 
4e3b			; | dw store_filecache 
4e3b			; | dw store_longread 
4e3b			; | dw store_openaddr 
4e3b			; | dw store_openext 
4e3b			; | dw store_openmaxext 
4e3b			; | ; 60 
4e3b			; | dw store_page 
4e3b			; | dw store_readbuf 
4e3b			; | dw store_readcont 
4e3b			; | dw store_readptr 
4e3b			; | dw store_tmpext 
4e3b			; | dw store_tmpid 
4e3b			; | dw store_tmppageid 
4e3b			; | dw malloc 
4e3b			; | dw free 
4e3b			; | dw cin 
4e3b			; | ; 70 
4e3b			; | dw cin_wait 
4e3b			; | dw forth_push_numhl 
4e3b			; | dw forth_push_str 
4e3b			 
4e3b					if DEBUG_FORTH_WORDS_KEY 
4e3b						DMARK "SYM" 
4e3b f5				push af  
4e3c 3a 50 4e			ld a, (.dmark)  
4e3f 32 68 fe			ld (debug_mark),a  
4e42 3a 51 4e			ld a, (.dmark+1)  
4e45 32 69 fe			ld (debug_mark+1),a  
4e48 3a 52 4e			ld a, (.dmark+2)  
4e4b 32 6a fe			ld (debug_mark+2),a  
4e4e 18 03			jr .pastdmark  
4e50 ..			.dmark: db "SYM"  
4e53 f1			.pastdmark: pop af  
4e54			endm  
# End of macro DMARK
4e54						CALLMONITOR 
4e54 cd 6c fe			call debug_vector  
4e57				endm  
# End of macro CALLMONITOR
4e57					endif 
4e57			 
4e57					FORTH_DSP_VALUEHL 
4e57 cd fb 22			call macro_dsp_valuehl 
4e5a				endm 
# End of macro FORTH_DSP_VALUEHL
4e5a			 
4e5a 7d					ld a, l     
4e5b			 
4e5b			 
4e5b					if DEBUG_FORTH_WORDS 
4e5b						DMARK "SY1" 
4e5b f5				push af  
4e5c 3a 70 4e			ld a, (.dmark)  
4e5f 32 68 fe			ld (debug_mark),a  
4e62 3a 71 4e			ld a, (.dmark+1)  
4e65 32 69 fe			ld (debug_mark+1),a  
4e68 3a 72 4e			ld a, (.dmark+2)  
4e6b 32 6a fe			ld (debug_mark+2),a  
4e6e 18 03			jr .pastdmark  
4e70 ..			.dmark: db "SY1"  
4e73 f1			.pastdmark: pop af  
4e74			endm  
# End of macro DMARK
4e74						CALLMONITOR 
4e74 cd 6c fe			call debug_vector  
4e77				endm  
# End of macro CALLMONITOR
4e77					endif 
4e77					 
4e77 f5					push af	 
4e78					FORTH_DSP_POP 
4e78 cd b3 23			call macro_forth_dsp_pop 
4e7b				endm 
# End of macro FORTH_DSP_POP
4e7b f1					pop af 
4e7c			 
4e7c cb 27				sla a  
4e7e				 
4e7e					 
4e7e					if DEBUG_FORTH_WORDS 
4e7e						DMARK "SY" 
4e7e f5				push af  
4e7f 3a 93 4e			ld a, (.dmark)  
4e82 32 68 fe			ld (debug_mark),a  
4e85 3a 94 4e			ld a, (.dmark+1)  
4e88 32 69 fe			ld (debug_mark+1),a  
4e8b 3a 95 4e			ld a, (.dmark+2)  
4e8e 32 6a fe			ld (debug_mark+2),a  
4e91 18 02			jr .pastdmark  
4e93 ..			.dmark: db "SY"  
4e95 f1			.pastdmark: pop af  
4e96			endm  
# End of macro DMARK
4e96						CALLMONITOR 
4e96 cd 6c fe			call debug_vector  
4e99				endm  
# End of macro CALLMONITOR
4e99					endif 
4e99			 
4e99 21 a8 4e				ld hl, sym_table 
4e9c cd d0 0f				call addatohl 
4e9f cd 33 24				call loadwordinhl 
4ea2 cd 04 21				call forth_push_numhl 
4ea5			 
4ea5			 
4ea5				       NEXTW 
4ea5 c3 b1 24			jp macro_next 
4ea8				endm 
# End of macro NEXTW
4ea8			 
4ea8			sym_table: 
4ea8			 
4ea8			; 0 
4ea8 a8 4e		dw sym_table 
4eaa 6f fe		dw nmi_vector 
4eac 39 fa		dw cli_autodisplay 
4eae eb f9		dw cli_data_sp 
4eb0 25 f7		dw cli_data_stack 
4eb2 ed f9		dw cli_loop_sp 
4eb4 27 f9		dw cli_loop_stack 
4eb6 25 fa		dw cli_var_array 
4eb8 c2 fb		dw cursor_col 
4eba c0 fb		dw cursor_ptr 
4ebc			; 10 
4ebc c1 fb		dw cursor_row 
4ebe 68 fe		dw debug_mark 
4ec0 ae fd		dw display_fb0 
4ec2 0d fd		dw display_fb1 
4ec4 cb fb		dw display_fb2 
4ec6 6c fc		dw display_fb3 
4ec8 c9 fb		dw display_fb_active 
4eca bd f2		dw execscratch 
4ecc 5b fa		dw f_cursor_ptr 
4ece 72 fe		dw hardware_word 
4ed0			;20 
4ed0 5f fe		dw input_at_cursor 
4ed2 61 fe		dw input_at_pos 
4ed4 5d fe		dw input_cur_flash 
4ed6 5c fe		dw input_cur_onoff 
4ed8 52 fe		dw input_cursor 
4eda 62 fe		dw input_display_size 
4edc 57 fe		dw input_len 
4ede 66 fe		dw input_ptr 
4ee0 63 fe		dw input_size 
4ee2 64 fe		dw input_start 
4ee4			; 30 
4ee4 fd 0f		dw input_str 
4ee6 60 fe		dw input_under_cursor 
4ee8 e5 f4		dw os_cli_cmd 
4eea e1 f4		dw os_cur_ptr 
4eec e3 f4		dw os_current_i 
4eee bc f3		dw os_input 
4ef0 e4 f5		dw os_last_cmd 
4ef2 bb f4		dw os_last_new_uword 
4ef4 6c fe		dw debug_vector 
4ef6 ac f1		dw os_view_hl 
4ef8			;40 
4ef8 c3 f4		dw os_word_scratch 
4efa c3 00		dw portbctl 
4efc c1 00		dw portbdata 
4efe 60 fa		dw spi_cartdev 
4f00 5f fa		dw spi_cartdev2 
4f02 61 fa		dw spi_clktime 
4f04 5d fa		dw spi_device 
4f06 5c fa		dw spi_device_id 
4f08 5e fa		dw spi_portbyte 
4f0a a4 fb		dw stackstore 
4f0c			; 50 
4f0c			if STORAGE_SE 
4f0c 82 00		dw storage_actl 
4f0e 80 00		dw storage_adata 
4f10			else 
4f10			dw 0 
4f10			dw 0 
4f10			endif 
4f10 56 0b		dw storage_append 
4f12			if STORAGE_SE 
4f12 83 00		dw storage_bctl 
4f14			else 
4f14			dw 0 
4f14			endif 
4f14 90 fb		dw store_bank_active 
4f16 64 fa		dw store_filecache 
4f18 72 fa		dw store_longread 
4f1a 68 fa		dw store_openaddr 
4f1c 67 fa		dw store_openext 
4f1e 66 fa		dw store_openmaxext 
4f20			; 60 
4f20 77 fa		dw store_page 
4f22 73 fa		dw store_readbuf 
4f24 6a fa		dw store_readcont 
4f26 75 fa		dw store_readptr 
4f28 6a fa		dw store_tmpext 
4f2a 6b fa		dw store_tmpid 
4f2c 62 fa		dw store_tmppageid 
4f2e 97 14		dw malloc 
4f30 61 15		dw free 
4f32 d3 79		dw cin 
4f34			; 70 
4f34 c2 79		dw cin_wait 
4f36 04 21		dw forth_push_numhl 
4f38 72 21		dw forth_push_str 
4f3a			 
4f3a			 
4f3a			.ENDCONST: 
4f3a			 
4f3a			; eof 
4f3a			 
4f3a			 
# End of file forth_words_const.asm
4f3a			 
4f3a			if STORAGE_SE 
4f3a			   	include "forth_words_storage.asm" 
4f3a			 
4f3a			; | ## Fixed Storage Words 
4f3a			 
4f3a			.RENAME: 
4f3a			  
4f3a				CWHEAD .RECORD 38 "RENAME" 6 WORD_FLAG_CODE 
4f3a 3a				db WORD_SYS_CORE+38             
4f3b 30 50			dw .RECORD            
4f3d 07				db 6 + 1 
4f3e .. 00			db "RENAME",0              
4f45				endm 
# End of macro CWHEAD
4f45			; | RENAME ( s id -- ) With the current bank, rename the file id with the new label s  | DONE 
4f45			; | | Compatible with PicoSPINet  
4f45					if DEBUG_FORTH_WORDS_KEY 
4f45						DMARK "REN" 
4f45 f5				push af  
4f46 3a 5a 4f			ld a, (.dmark)  
4f49 32 68 fe			ld (debug_mark),a  
4f4c 3a 5b 4f			ld a, (.dmark+1)  
4f4f 32 69 fe			ld (debug_mark+1),a  
4f52 3a 5c 4f			ld a, (.dmark+2)  
4f55 32 6a fe			ld (debug_mark+2),a  
4f58 18 03			jr .pastdmark  
4f5a ..			.dmark: db "REN"  
4f5d f1			.pastdmark: pop af  
4f5e			endm  
# End of macro DMARK
4f5e						CALLMONITOR 
4f5e cd 6c fe			call debug_vector  
4f61				endm  
# End of macro CALLMONITOR
4f61					endif 
4f61			 
4f61			 
4f61					; preserve some internal vars used by other file handing routines 
4f61			 
4f61 2a 68 fa				ld hl, (store_openaddr) 
4f64 e5					push hl 
4f65 3a 6a fa				ld a, (store_readcont) 
4f68 f5					push af 
4f69			 
4f69					FORTH_DSP_VALUEHL 
4f69 cd fb 22			call macro_dsp_valuehl 
4f6c				endm 
# End of macro FORTH_DSP_VALUEHL
4f6c			 
4f6c					; move ext and id around for the file header 
4f6c			 
4f6c 65					ld h, l 
4f6d 2e 00				ld l, 0 
4f6f			 
4f6f e5					push hl    ; id 
4f70			 
4f70					FORTH_DSP_POP 
4f70 cd b3 23			call macro_forth_dsp_pop 
4f73				endm 
# End of macro FORTH_DSP_POP
4f73			 
4f73					; Locate the file header 
4f73			 
4f73 e1					pop hl 
4f74 e5					push hl 
4f75 11 77 fa				ld de, store_page      ; get block zero of file 
4f78					if DEBUG_FORTH_WORDS 
4f78						DMARK "REr" 
4f78 f5				push af  
4f79 3a 8d 4f			ld a, (.dmark)  
4f7c 32 68 fe			ld (debug_mark),a  
4f7f 3a 8e 4f			ld a, (.dmark+1)  
4f82 32 69 fe			ld (debug_mark+1),a  
4f85 3a 8f 4f			ld a, (.dmark+2)  
4f88 32 6a fe			ld (debug_mark+2),a  
4f8b 18 03			jr .pastdmark  
4f8d ..			.dmark: db "REr"  
4f90 f1			.pastdmark: pop af  
4f91			endm  
# End of macro DMARK
4f91						CALLMONITOR 
4f91 cd 6c fe			call debug_vector  
4f94				endm  
# End of macro CALLMONITOR
4f94					endif 
4f94 cd bf 09				call storage_read 
4f97			 
4f97 cd f9 0f			call ishlzero 
4f9a 20 05			jr nz, .rnfound 
4f9c			 
4f9c				; file does not exist so indicate with 255 extents in use 
4f9c			 
4f9c 3e ff			ld a, 255 
4f9e e1				pop hl ; clear dup hl 
4f9f 18 7b			jr .skiprneof 
4fa1			 
4fa1			 
4fa1			.rnfound: 
4fa1					; file found so rename 
4fa1			 
4fa1					FORTH_DSP_VALUEHL 
4fa1 cd fb 22			call macro_dsp_valuehl 
4fa4				endm 
# End of macro FORTH_DSP_VALUEHL
4fa4			 
4fa4 e5				push hl 
4fa5 3e 00			ld a, 0 
4fa7 cd 39 14			call strlent 
4faa 23				inc hl   ; cover zero term 
4fab 06 00			ld b,0 
4fad 4d				ld c,l 
4fae e1				pop hl 
4faf 11 7a fa				ld de, store_page + 3 
4fb2 ed b0				ldir 
4fb4			 
4fb4 11 77 fa				ld de, store_page 
4fb7					if DEBUG_FORTH_WORDS 
4fb7						DMARK "RER" 
4fb7 f5				push af  
4fb8 3a cc 4f			ld a, (.dmark)  
4fbb 32 68 fe			ld (debug_mark),a  
4fbe 3a cd 4f			ld a, (.dmark+1)  
4fc1 32 69 fe			ld (debug_mark+1),a  
4fc4 3a ce 4f			ld a, (.dmark+2)  
4fc7 32 6a fe			ld (debug_mark+2),a  
4fca 18 03			jr .pastdmark  
4fcc ..			.dmark: db "RER"  
4fcf f1			.pastdmark: pop af  
4fd0			endm  
# End of macro DMARK
4fd0						CALLMONITOR 
4fd0 cd 6c fe			call debug_vector  
4fd3				endm  
# End of macro CALLMONITOR
4fd3					endif 
4fd3			 
4fd3 e1					pop hl    ; get orig file id and mangle it for find id 
4fd4 55					ld d, l 
4fd5 5c					ld e, h 
4fd6			 
4fd6 21 00 00				ld hl, 0 
4fd9					if DEBUG_FORTH_WORDS 
4fd9						DMARK "REf" 
4fd9 f5				push af  
4fda 3a ee 4f			ld a, (.dmark)  
4fdd 32 68 fe			ld (debug_mark),a  
4fe0 3a ef 4f			ld a, (.dmark+1)  
4fe3 32 69 fe			ld (debug_mark+1),a  
4fe6 3a f0 4f			ld a, (.dmark+2)  
4fe9 32 6a fe			ld (debug_mark+2),a  
4fec 18 03			jr .pastdmark  
4fee ..			.dmark: db "REf"  
4ff1 f1			.pastdmark: pop af  
4ff2			endm  
# End of macro DMARK
4ff2						CALLMONITOR 
4ff2 cd 6c fe			call debug_vector  
4ff5				endm  
# End of macro CALLMONITOR
4ff5					endif 
4ff5 cd 99 07				call storage_findnextid 
4ff8 11 77 fa				ld de, store_page 
4ffb					if DEBUG_FORTH_WORDS 
4ffb						DMARK "REw" 
4ffb f5				push af  
4ffc 3a 10 50			ld a, (.dmark)  
4fff 32 68 fe			ld (debug_mark),a  
5002 3a 11 50			ld a, (.dmark+1)  
5005 32 69 fe			ld (debug_mark+1),a  
5008 3a 12 50			ld a, (.dmark+2)  
500b 32 6a fe			ld (debug_mark+2),a  
500e 18 03			jr .pastdmark  
5010 ..			.dmark: db "REw"  
5013 f1			.pastdmark: pop af  
5014			endm  
# End of macro DMARK
5014						CALLMONITOR 
5014 cd 6c fe			call debug_vector  
5017				endm  
# End of macro CALLMONITOR
5017					endif 
5017 cd cb 04				call storage_write_block 
501a			 
501a 3e 00				ld a, 0 
501c			.skiprneof: 
501c					; drop file name 
501c					FORTH_DSP_POP 
501c cd b3 23			call macro_forth_dsp_pop 
501f				endm 
# End of macro FORTH_DSP_POP
501f			 
501f 6f					ld l, a 
5020 26 00				ld h, 0 
5022 cd 04 21				call forth_push_numhl 
5025			 
5025			 
5025 f1					pop af 
5026 32 6a fa				ld (store_readcont),a 
5029 e1					pop hl 
502a 22 68 fa				ld (store_openaddr), hl 
502d						 
502d				NEXTW 
502d c3 b1 24			jp macro_next 
5030				endm 
# End of macro NEXTW
5030			.RECORD: 
5030			  
5030				CWHEAD .BREAD 38 "RECORD" 6 WORD_FLAG_CODE 
5030 3a				db WORD_SYS_CORE+38             
5031 d4 50			dw .BREAD            
5033 07				db 6 + 1 
5034 .. 00			db "RECORD",0              
503b				endm 
# End of macro CWHEAD
503b			; | RECORD ( u id -- s ) With the current bank, read record number u from file id and push to stack  | DONE 
503b			; | | Compatible with PicoSPINet  
503b			 
503b					if DEBUG_FORTH_WORDS_KEY 
503b						DMARK "REC" 
503b f5				push af  
503c 3a 50 50			ld a, (.dmark)  
503f 32 68 fe			ld (debug_mark),a  
5042 3a 51 50			ld a, (.dmark+1)  
5045 32 69 fe			ld (debug_mark+1),a  
5048 3a 52 50			ld a, (.dmark+2)  
504b 32 6a fe			ld (debug_mark+2),a  
504e 18 03			jr .pastdmark  
5050 ..			.dmark: db "REC"  
5053 f1			.pastdmark: pop af  
5054			endm  
# End of macro DMARK
5054						CALLMONITOR 
5054 cd 6c fe			call debug_vector  
5057				endm  
# End of macro CALLMONITOR
5057					endif 
5057			 
5057					FORTH_DSP_VALUEHL 
5057 cd fb 22			call macro_dsp_valuehl 
505a				endm 
# End of macro FORTH_DSP_VALUEHL
505a			 
505a e5					push hl    ; id 
505b			 
505b					FORTH_DSP_POP 
505b cd b3 23			call macro_forth_dsp_pop 
505e				endm 
# End of macro FORTH_DSP_POP
505e			 
505e					FORTH_DSP_VALUEHL 
505e cd fb 22			call macro_dsp_valuehl 
5061				endm 
# End of macro FORTH_DSP_VALUEHL
5061			 
5061					FORTH_DSP_POP 
5061 cd b3 23			call macro_forth_dsp_pop 
5064				endm 
# End of macro FORTH_DSP_POP
5064			 
5064 d1					pop de     ; get file id 
5065			 
5065					; e = file id 
5065					; l = file extent 
5065			 
5065			 
5065					; construct request to access file extent 
5065			 
5065			;		ld a, e 
5065 63					ld h, e 
5066					 
5066					 
5066					 
5066			 
5066					; e has id 
5066			 
5066 11 77 fa			ld de, store_page 
5069					if DEBUG_FORTH_WORDS 
5069						DMARK "REr" 
5069 f5				push af  
506a 3a 7e 50			ld a, (.dmark)  
506d 32 68 fe			ld (debug_mark),a  
5070 3a 7f 50			ld a, (.dmark+1)  
5073 32 69 fe			ld (debug_mark+1),a  
5076 3a 80 50			ld a, (.dmark+2)  
5079 32 6a fe			ld (debug_mark+2),a  
507c 18 03			jr .pastdmark  
507e ..			.dmark: db "REr"  
5081 f1			.pastdmark: pop af  
5082			endm  
# End of macro DMARK
5082						CALLMONITOR 
5082 cd 6c fe			call debug_vector  
5085				endm  
# End of macro CALLMONITOR
5085					endif 
5085 cd bf 09				call storage_read 
5088 cd f9 0f			call ishlzero 
508b 28 22			jr z, .recnotfound 
508d			 
508d			 
508d					if DEBUG_FORTH_WORDS 
508d						DMARK "REe" 
508d f5				push af  
508e 3a a2 50			ld a, (.dmark)  
5091 32 68 fe			ld (debug_mark),a  
5094 3a a3 50			ld a, (.dmark+1)  
5097 32 69 fe			ld (debug_mark+1),a  
509a 3a a4 50			ld a, (.dmark+2)  
509d 32 6a fe			ld (debug_mark+2),a  
50a0 18 03			jr .pastdmark  
50a2 ..			.dmark: db "REe"  
50a5 f1			.pastdmark: pop af  
50a6			endm  
# End of macro DMARK
50a6						CALLMONITOR 
50a6 cd 6c fe			call debug_vector  
50a9				endm  
# End of macro CALLMONITOR
50a9					endif 
50a9 cd 72 21			call forth_push_str 
50ac			 
50ac					NEXTW 
50ac c3 b1 24			jp macro_next 
50af				endm 
# End of macro NEXTW
50af			 
50af			.recnotfound: 
50af					if DEBUG_FORTH_WORDS 
50af						DMARK "REf" 
50af f5				push af  
50b0 3a c4 50			ld a, (.dmark)  
50b3 32 68 fe			ld (debug_mark),a  
50b6 3a c5 50			ld a, (.dmark+1)  
50b9 32 69 fe			ld (debug_mark+1),a  
50bc 3a c6 50			ld a, (.dmark+2)  
50bf 32 6a fe			ld (debug_mark+2),a  
50c2 18 03			jr .pastdmark  
50c4 ..			.dmark: db "REf"  
50c7 f1			.pastdmark: pop af  
50c8			endm  
# End of macro DMARK
50c8						CALLMONITOR 
50c8 cd 6c fe			call debug_vector  
50cb				endm  
# End of macro CALLMONITOR
50cb					endif 
50cb 21 ff 00			ld hl, 255 
50ce cd 04 21			call forth_push_numhl 
50d1				NEXTW 
50d1 c3 b1 24			jp macro_next 
50d4				endm 
# End of macro NEXTW
50d4			 
50d4			 
50d4			.BREAD: 
50d4			  
50d4				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
50d4 3a				db WORD_SYS_CORE+38             
50d5 57 51			dw .BWRITE            
50d7 06				db 5 + 1 
50d8 .. 00			db "BREAD",0              
50de				endm 
# End of macro CWHEAD
50de			; | BREAD ( u -- u ) Lowlevel storage word. With the current bank, read a block from page id u (1-512) and push to stack  | DONE 
50de			; | | Compatible with PicoSPINet  
50de				 
50de					if DEBUG_FORTH_WORDS_KEY 
50de						DMARK "BRD" 
50de f5				push af  
50df 3a f3 50			ld a, (.dmark)  
50e2 32 68 fe			ld (debug_mark),a  
50e5 3a f4 50			ld a, (.dmark+1)  
50e8 32 69 fe			ld (debug_mark+1),a  
50eb 3a f5 50			ld a, (.dmark+2)  
50ee 32 6a fe			ld (debug_mark+2),a  
50f1 18 03			jr .pastdmark  
50f3 ..			.dmark: db "BRD"  
50f6 f1			.pastdmark: pop af  
50f7			endm  
# End of macro DMARK
50f7						CALLMONITOR 
50f7 cd 6c fe			call debug_vector  
50fa				endm  
# End of macro CALLMONITOR
50fa					endif 
50fa			 
50fa				FORTH_DSP_VALUEHL 
50fa cd fb 22			call macro_dsp_valuehl 
50fd				endm 
# End of macro FORTH_DSP_VALUEHL
50fd			 
50fd				FORTH_DSP_POP 
50fd cd b3 23			call macro_forth_dsp_pop 
5100				endm 
# End of macro FORTH_DSP_POP
5100			 
5100				; calc block address 
5100			 
5100 eb				ex de, hl 
5101 3e 40			ld a, STORE_BLOCK_PHY 
5103 cd 53 0f			call Mult16 
5106			 
5106			 
5106 11 77 fa			ld de, store_page 
5109			 
5109					if DEBUG_FORTH_WORDS 
5109						DMARK "BR1" 
5109 f5				push af  
510a 3a 1e 51			ld a, (.dmark)  
510d 32 68 fe			ld (debug_mark),a  
5110 3a 1f 51			ld a, (.dmark+1)  
5113 32 69 fe			ld (debug_mark+1),a  
5116 3a 20 51			ld a, (.dmark+2)  
5119 32 6a fe			ld (debug_mark+2),a  
511c 18 03			jr .pastdmark  
511e ..			.dmark: db "BR1"  
5121 f1			.pastdmark: pop af  
5122			endm  
# End of macro DMARK
5122						CALLMONITOR 
5122 cd 6c fe			call debug_vector  
5125				endm  
# End of macro CALLMONITOR
5125					endif 
5125			 
5125 cd 66 04			call storage_read_block 
5128			 
5128 cd f9 0f			call ishlzero 
512b 20 05			jr nz, .brfound 
512d			 
512d cd 04 21			call forth_push_numhl 
5130 18 22			jr .brdone 
5132			 
5132			 
5132			.brfound: 
5132 21 79 fa		        ld hl, store_page+2 
5135			 
5135					if DEBUG_FORTH_WORDS 
5135						DMARK "BR2" 
5135 f5				push af  
5136 3a 4a 51			ld a, (.dmark)  
5139 32 68 fe			ld (debug_mark),a  
513c 3a 4b 51			ld a, (.dmark+1)  
513f 32 69 fe			ld (debug_mark+1),a  
5142 3a 4c 51			ld a, (.dmark+2)  
5145 32 6a fe			ld (debug_mark+2),a  
5148 18 03			jr .pastdmark  
514a ..			.dmark: db "BR2"  
514d f1			.pastdmark: pop af  
514e			endm  
# End of macro DMARK
514e						CALLMONITOR 
514e cd 6c fe			call debug_vector  
5151				endm  
# End of macro CALLMONITOR
5151					endif 
5151			 
5151 cd 72 21			call forth_push_str 
5154			 
5154			 
5154			.brdone: 
5154			 
5154					NEXTW 
5154 c3 b1 24			jp macro_next 
5157				endm 
# End of macro NEXTW
5157			.BWRITE: 
5157				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
5157 3a				db WORD_SYS_CORE+38             
5158 ec 51			dw .BUPD            
515a 07				db 6 + 1 
515b .. 00			db "BWRITE",0              
5162				endm 
# End of macro CWHEAD
5162			; | BWRITE ( s u -- ) Lowlevel storage word. With the current bank, write the string s to page id u | DONE 
5162			; | | Compatible with PicoSPINet  
5162			 
5162					if DEBUG_FORTH_WORDS_KEY 
5162						DMARK "BWR" 
5162 f5				push af  
5163 3a 77 51			ld a, (.dmark)  
5166 32 68 fe			ld (debug_mark),a  
5169 3a 78 51			ld a, (.dmark+1)  
516c 32 69 fe			ld (debug_mark+1),a  
516f 3a 79 51			ld a, (.dmark+2)  
5172 32 6a fe			ld (debug_mark+2),a  
5175 18 03			jr .pastdmark  
5177 ..			.dmark: db "BWR"  
517a f1			.pastdmark: pop af  
517b			endm  
# End of macro DMARK
517b						CALLMONITOR 
517b cd 6c fe			call debug_vector  
517e				endm  
# End of macro CALLMONITOR
517e					endif 
517e			 
517e				FORTH_DSP_VALUEHL 
517e cd fb 22			call macro_dsp_valuehl 
5181				endm 
# End of macro FORTH_DSP_VALUEHL
5181			 
5181				; calc block address 
5181			 
5181 eb				ex de, hl 
5182 3e 40			ld a, STORE_BLOCK_PHY 
5184 cd 53 0f			call Mult16 
5187			 
5187 e5				push hl         ; address 
5188			 
5188				FORTH_DSP_POP 
5188 cd b3 23			call macro_forth_dsp_pop 
518b				endm 
# End of macro FORTH_DSP_POP
518b			 
518b				FORTH_DSP_VALUEHL 
518b cd fb 22			call macro_dsp_valuehl 
518e				endm 
# End of macro FORTH_DSP_VALUEHL
518e			 
518e				FORTH_DSP_POP 
518e cd b3 23			call macro_forth_dsp_pop 
5191				endm 
# End of macro FORTH_DSP_POP
5191			 
5191 cd a2 0c			call storage_clear_page 
5194			 
5194				; copy string to store page 
5194			 
5194 e5				push hl     ; save string address 
5195			 
5195 3e 00			ld a, 0 
5197 cd 39 14			call strlent 
519a			 
519a 23				inc hl 
519b			 
519b 4d				ld c, l 
519c 06 00			ld b, 0 
519e			 
519e e1				pop hl 
519f 11 79 fa			ld de, store_page + 2 
51a2					if DEBUG_FORTH_WORDS 
51a2						DMARK "BW1" 
51a2 f5				push af  
51a3 3a b7 51			ld a, (.dmark)  
51a6 32 68 fe			ld (debug_mark),a  
51a9 3a b8 51			ld a, (.dmark+1)  
51ac 32 69 fe			ld (debug_mark+1),a  
51af 3a b9 51			ld a, (.dmark+2)  
51b2 32 6a fe			ld (debug_mark+2),a  
51b5 18 03			jr .pastdmark  
51b7 ..			.dmark: db "BW1"  
51ba f1			.pastdmark: pop af  
51bb			endm  
# End of macro DMARK
51bb						CALLMONITOR 
51bb cd 6c fe			call debug_vector  
51be				endm  
# End of macro CALLMONITOR
51be					endif 
51be ed b0			ldir 
51c0			 
51c0			 
51c0				; poke the start of the block with flags to prevent high level file ops hitting the block 
51c0			 
51c0 21 ff ff			ld hl, $ffff 
51c3			 
51c3 22 77 fa			ld (store_page), hl	 
51c6				 
51c6 e1				pop hl    ; get address 
51c7 11 77 fa			ld de, store_page 
51ca			 
51ca					if DEBUG_FORTH_WORDS 
51ca						DMARK "BW2" 
51ca f5				push af  
51cb 3a df 51			ld a, (.dmark)  
51ce 32 68 fe			ld (debug_mark),a  
51d1 3a e0 51			ld a, (.dmark+1)  
51d4 32 69 fe			ld (debug_mark+1),a  
51d7 3a e1 51			ld a, (.dmark+2)  
51da 32 6a fe			ld (debug_mark+2),a  
51dd 18 03			jr .pastdmark  
51df ..			.dmark: db "BW2"  
51e2 f1			.pastdmark: pop af  
51e3			endm  
# End of macro DMARK
51e3						CALLMONITOR 
51e3 cd 6c fe			call debug_vector  
51e6				endm  
# End of macro CALLMONITOR
51e6					endif 
51e6			 
51e6 cd cb 04			call storage_write_block 
51e9			 
51e9					NEXTW 
51e9 c3 b1 24			jp macro_next 
51ec				endm 
# End of macro NEXTW
51ec			 
51ec			.BUPD: 
51ec				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
51ec 3a				db WORD_SYS_CORE+38             
51ed 42 52			dw .BYID            
51ef 05				db 4 + 1 
51f0 .. 00			db "BUPD",0              
51f5				endm 
# End of macro CWHEAD
51f5			; | BUPD ( u -- ) Lowlevel storage word. Write the contents of the current file system storage buffer directly to page id u | DONE 
51f5			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
51f5			; | | or completely different file system structure. 
51f5			; | | Compatible with PicoSPINet  
51f5			 
51f5					if DEBUG_FORTH_WORDS_KEY 
51f5						DMARK "BUD" 
51f5 f5				push af  
51f6 3a 0a 52			ld a, (.dmark)  
51f9 32 68 fe			ld (debug_mark),a  
51fc 3a 0b 52			ld a, (.dmark+1)  
51ff 32 69 fe			ld (debug_mark+1),a  
5202 3a 0c 52			ld a, (.dmark+2)  
5205 32 6a fe			ld (debug_mark+2),a  
5208 18 03			jr .pastdmark  
520a ..			.dmark: db "BUD"  
520d f1			.pastdmark: pop af  
520e			endm  
# End of macro DMARK
520e						CALLMONITOR 
520e cd 6c fe			call debug_vector  
5211				endm  
# End of macro CALLMONITOR
5211					endif 
5211			 
5211				FORTH_DSP_VALUEHL 
5211 cd fb 22			call macro_dsp_valuehl 
5214				endm 
# End of macro FORTH_DSP_VALUEHL
5214			 
5214				; calc block address 
5214			 
5214 eb				ex de, hl 
5215 3e 40			ld a, STORE_BLOCK_PHY 
5217 cd 53 0f			call Mult16 
521a			 
521a				FORTH_DSP_POP 
521a cd b3 23			call macro_forth_dsp_pop 
521d				endm 
# End of macro FORTH_DSP_POP
521d			 
521d			 
521d 11 77 fa			ld de, store_page 
5220			 
5220					if DEBUG_FORTH_WORDS 
5220						DMARK "BUe" 
5220 f5				push af  
5221 3a 35 52			ld a, (.dmark)  
5224 32 68 fe			ld (debug_mark),a  
5227 3a 36 52			ld a, (.dmark+1)  
522a 32 69 fe			ld (debug_mark+1),a  
522d 3a 37 52			ld a, (.dmark+2)  
5230 32 6a fe			ld (debug_mark+2),a  
5233 18 03			jr .pastdmark  
5235 ..			.dmark: db "BUe"  
5238 f1			.pastdmark: pop af  
5239			endm  
# End of macro DMARK
5239						CALLMONITOR 
5239 cd 6c fe			call debug_vector  
523c				endm  
# End of macro CALLMONITOR
523c					endif 
523c			 
523c cd cb 04			call storage_write_block 
523f			 
523f					NEXTW 
523f c3 b1 24			jp macro_next 
5242				endm 
# End of macro NEXTW
5242			 
5242			.BYID: 
5242			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
5242			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
5242			; 
5242			;		 
5242			;		if DEBUG_FORTH_WORDS_KEY 
5242			;			DMARK "BYID" 
5242			;			CALLMONITOR 
5242			;		endif 
5242			; 
5242			;		; get direct address 
5242			; 
5242			;		FORTH_DSP_VALUEHL 
5242			; 
5242			;		FORTH_DSP_POP 
5242			; 
5242			;	; calc block address 
5242			; 
5242			;	ex de, hl 
5242			;	ld a, STORE_BLOCK_PHY 
5242			;	call Mult16 
5242			;	;	do BREAD with number as param 
5242			;	; push the file name	 
5242			;	ld de, store_page 
5242			;	call storage_read_block 
5242			 ;       ld hl, store_page+2 
5242			; 
5242			; 
5242			;		NEXTW 
5242			;.BYNAME: 
5242				CWHEAD .DIR 38 "GETID" 5 WORD_FLAG_CODE 
5242 3a				db WORD_SYS_CORE+38             
5243 5b 52			dw .DIR            
5245 06				db 5 + 1 
5246 .. 00			db "GETID",0              
524c				endm 
# End of macro CWHEAD
524c			; | GETID ( s -- u ) Get the file ID in the current BANK of the file named s | DONE 
524c			; | | Compatible with PicoSPINet  
524c			 
524c					; get pointer to file name to seek 
524c			 
524c					FORTH_DSP_VALUEHL 
524c cd fb 22			call macro_dsp_valuehl 
524f				endm 
# End of macro FORTH_DSP_VALUEHL
524f			 
524f			 
524f cd 8d 03				call storage_getid  
5252			 
5252					FORTH_DSP_POP 
5252 cd b3 23			call macro_forth_dsp_pop 
5255				endm 
# End of macro FORTH_DSP_POP
5255			 
5255 cd 04 21				call forth_push_numhl 
5258			 
5258					NEXTW 
5258 c3 b1 24			jp macro_next 
525b				endm 
# End of macro NEXTW
525b			; 
525b			.DIR: 
525b				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
525b 3a				db WORD_SYS_CORE+38             
525c 5f 53			dw .SAVE            
525e 04				db 3 + 1 
525f .. 00			db "DIR",0              
5263				endm 
# End of macro CWHEAD
5263			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
5263			; | | Compatible with PicoSPINet  
5263			 
5263					if DEBUG_FORTH_WORDS_KEY 
5263						DMARK "DIR" 
5263 f5				push af  
5264 3a 78 52			ld a, (.dmark)  
5267 32 68 fe			ld (debug_mark),a  
526a 3a 79 52			ld a, (.dmark+1)  
526d 32 69 fe			ld (debug_mark+1),a  
5270 3a 7a 52			ld a, (.dmark+2)  
5273 32 6a fe			ld (debug_mark+2),a  
5276 18 03			jr .pastdmark  
5278 ..			.dmark: db "DIR"  
527b f1			.pastdmark: pop af  
527c			endm  
# End of macro DMARK
527c						CALLMONITOR 
527c cd 6c fe			call debug_vector  
527f				endm  
# End of macro CALLMONITOR
527f					endif 
527f cd 17 05			call storage_get_block_0 
5282			 
5282 21 77 fa			ld hl, store_page     ; get current id count 
5285 46				ld b, (hl) 
5286 0e 00			ld c, 0    ; count of files   
5288					if DEBUG_FORTH_WORDS 
5288						DMARK "DI1" 
5288 f5				push af  
5289 3a 9d 52			ld a, (.dmark)  
528c 32 68 fe			ld (debug_mark),a  
528f 3a 9e 52			ld a, (.dmark+1)  
5292 32 69 fe			ld (debug_mark+1),a  
5295 3a 9f 52			ld a, (.dmark+2)  
5298 32 6a fe			ld (debug_mark+2),a  
529b 18 03			jr .pastdmark  
529d ..			.dmark: db "DI1"  
52a0 f1			.pastdmark: pop af  
52a1			endm  
# End of macro DMARK
52a1						CALLMONITOR 
52a1 cd 6c fe			call debug_vector  
52a4				endm  
# End of macro CALLMONITOR
52a4					endif 
52a4			 
52a4				; check for empty drive 
52a4			 
52a4 3e 00			ld a, 0 
52a6 b8				cp b 
52a7 ca 15 53			jp z, .dirdone 
52aa			 
52aa				; for each of the current ids do a search for them and if found push to stack 
52aa			 
52aa c5			.diritem:	push bc 
52ab 21 40 00				ld hl, STORE_BLOCK_PHY 
52ae 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
52b0 58					ld e,b 
52b1			 
52b1			;		if DEBUG_FORTH_WORDS 
52b1			;			DMARK "DI2" 
52b1			;			CALLMONITOR 
52b1			;		endif 
52b1			 
52b1 cd 99 07				call storage_findnextid 
52b4			 
52b4			;		if DEBUG_FORTH_WORDS 
52b4			;			DMARK "DI3" 
52b4			;			CALLMONITOR 
52b4			;		endif 
52b4			 
52b4					; if found hl will be non zero 
52b4			 
52b4 cd f9 0f				call ishlzero 
52b7			;		ld a, l 
52b7			;		add h 
52b7			; 
52b7			;		cp 0 
52b7 28 59				jr z, .dirnotfound 
52b9			 
52b9					; increase count 
52b9			 
52b9 c1					pop bc	 
52ba 0c					inc c 
52bb c5					push bc 
52bc					 
52bc			 
52bc					; get file header and push the file name 
52bc			 
52bc 11 77 fa				ld de, store_page 
52bf cd 66 04				call storage_read_block 
52c2			 
52c2					; push file id to stack 
52c2				 
52c2 3a 77 fa				ld a, (store_page) 
52c5 26 00				ld h, 0 
52c7 6f					ld l, a 
52c8 cd 04 21				call forth_push_numhl 
52cb			 
52cb					; push extent count to stack  
52cb				 
52cb 3a 79 fa				ld a, (store_page+2) 
52ce 26 00				ld h, 0 
52d0 6f					ld l, a 
52d1 cd 04 21				call forth_push_numhl 
52d4			 
52d4					; push file name 
52d4			 
52d4 21 7a fa				ld hl, store_page+3 
52d7					if DEBUG_FORTH_WORDS 
52d7						DMARK "DI5" 
52d7 f5				push af  
52d8 3a ec 52			ld a, (.dmark)  
52db 32 68 fe			ld (debug_mark),a  
52de 3a ed 52			ld a, (.dmark+1)  
52e1 32 69 fe			ld (debug_mark+1),a  
52e4 3a ee 52			ld a, (.dmark+2)  
52e7 32 6a fe			ld (debug_mark+2),a  
52ea 18 03			jr .pastdmark  
52ec ..			.dmark: db "DI5"  
52ef f1			.pastdmark: pop af  
52f0			endm  
# End of macro DMARK
52f0						CALLMONITOR 
52f0 cd 6c fe			call debug_vector  
52f3				endm  
# End of macro CALLMONITOR
52f3					endif 
52f3 cd 72 21				call forth_push_str 
52f6					if DEBUG_FORTH_WORDS 
52f6						DMARK "DI6" 
52f6 f5				push af  
52f7 3a 0b 53			ld a, (.dmark)  
52fa 32 68 fe			ld (debug_mark),a  
52fd 3a 0c 53			ld a, (.dmark+1)  
5300 32 69 fe			ld (debug_mark+1),a  
5303 3a 0d 53			ld a, (.dmark+2)  
5306 32 6a fe			ld (debug_mark+2),a  
5309 18 03			jr .pastdmark  
530b ..			.dmark: db "DI6"  
530e f1			.pastdmark: pop af  
530f			endm  
# End of macro DMARK
530f						CALLMONITOR 
530f cd 6c fe			call debug_vector  
5312				endm  
# End of macro CALLMONITOR
5312					endif 
5312			.dirnotfound: 
5312 c1					pop bc     
5313 10 95				djnz .diritem 
5315				 
5315			.dirdone:	 
5315					if DEBUG_FORTH_WORDS 
5315						DMARK "DI7" 
5315 f5				push af  
5316 3a 2a 53			ld a, (.dmark)  
5319 32 68 fe			ld (debug_mark),a  
531c 3a 2b 53			ld a, (.dmark+1)  
531f 32 69 fe			ld (debug_mark+1),a  
5322 3a 2c 53			ld a, (.dmark+2)  
5325 32 6a fe			ld (debug_mark+2),a  
5328 18 03			jr .pastdmark  
532a ..			.dmark: db "DI7"  
532d f1			.pastdmark: pop af  
532e			endm  
# End of macro DMARK
532e						CALLMONITOR 
532e cd 6c fe			call debug_vector  
5331				endm  
# End of macro CALLMONITOR
5331					endif 
5331			 
5331					; push a count of the dir items found 
5331			 
5331 26 00				ld h, 0 
5333 69					ld l, c 
5334 cd 04 21				call forth_push_numhl 
5337			 
5337					; push the bank label 
5337			 
5337 cd 17 05				call storage_get_block_0 
533a			 
533a				 
533a 21 7a fa		 		ld hl, store_page+3 
533d			 
533d					if DEBUG_FORTH_WORDS 
533d						DMARK "DI8" 
533d f5				push af  
533e 3a 52 53			ld a, (.dmark)  
5341 32 68 fe			ld (debug_mark),a  
5344 3a 53 53			ld a, (.dmark+1)  
5347 32 69 fe			ld (debug_mark+1),a  
534a 3a 54 53			ld a, (.dmark+2)  
534d 32 6a fe			ld (debug_mark+2),a  
5350 18 03			jr .pastdmark  
5352 ..			.dmark: db "DI8"  
5355 f1			.pastdmark: pop af  
5356			endm  
# End of macro DMARK
5356						CALLMONITOR 
5356 cd 6c fe			call debug_vector  
5359				endm  
# End of macro CALLMONITOR
5359					endif 
5359 cd 72 21				call forth_push_str 
535c			 
535c			 
535c				 
535c					NEXTW 
535c c3 b1 24			jp macro_next 
535f				endm 
# End of macro NEXTW
535f			.SAVE: 
535f			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
535f			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
535f			;		NEXTW 
535f			;.LOAD: 
535f			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
535f			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
535f			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
535f			;; > > The LOAD command can not be used in any user words or compound lines. 
535f			; 
535f			;		; store_openext use it. If zero it is EOF 
535f			; 
535f			;		; read block from current stream id 
535f			;		; if the block does not contain zero term keep reading blocks until zero found 
535f			;		; push the block to stack 
535f			;		; save the block id to stream 
535f			; 
535f			; 
535f			;		FORTH_DSP_VALUEHL 
535f			; 
535f			;;		push hl 
535f			; 
535f			;	if DEBUG_STORESE 
535f			;		DMARK "LOA" 
535f			;		CALLMONITOR 
535f			;	endif 
535f			;		FORTH_DSP_POP 
535f			; 
535f			;;		pop hl 
535f			; 
535f			;		ld h, l 
535f			;		ld l, 0 
535f			; 
535f			;		push hl     ; stack holds current file id and extent to work with 
535f			; 
535f			; 
535f			;		ld de, store_page      ; get block zero of file 
535f			;	if DEBUG_STORESE 
535f			;		DMARK "LO0" 
535f			;		CALLMONITOR 
535f			;	endif 
535f			;		call storage_read 
535f			; 
535f			;		ld a, (store_page+2)    ; max extents for this file 
535f			;		ld  (store_openmaxext),a   ; get our limit 
535f			; 
535f			;	if DEBUG_STORESE 
535f			;		DMARK "LOE" 
535f			;		CALLMONITOR 
535f			;	endif 
535f			; 
535f			;; TODO dont know why max extents are not present 
535f			;;		cp 0 
535f			;;		jp z, .loadeof     ; dont read past eof 
535f			; 
535f			;;		ld a, 1   ; start from the head of the file 
535f			; 
535f			;.loadline:	pop hl 
535f			;		inc hl 
535f			;		ld  a, (store_openmaxext)   ; get our limit 
535f			;	if DEBUG_STORESE 
535f			;		DMARK "LOx" 
535f			;		CALLMONITOR 
535f			;	endif 
535f			;		inc a 
535f			;		cp l 
535f			;		jp z, .loadeof 
535f			;		push hl    ; save current extent 
535f			; 
535f			;		ld de, store_page 
535f			; 
535f			;	if DEBUG_STORESE 
535f			;		DMARK "LO1" 
535f			;		CALLMONITOR 
535f			;	endif 
535f			;		call storage_read 
535f			; 
535f			;	if DEBUG_STORESE 
535f			;		DMARK "LO2" 
535f			;		CALLMONITOR 
535f			;	endif 
535f			;	call ishlzero 
535f			;	ld a, l 
535f			;	add h 
535f			;	cp 0 
535f			;	jr z, .loadeof 
535f			; 
535f			;	; not eof so hl should point to data to exec 
535f			; 
535f			;	; will need to add the FORTH_END_BUFFER flag 
535f			 ; 
535f			;	ld hl, store_page+2 
535f			;	ld bc, 255 
535f			;	ld a, 0 
535f			;	cpir 
535f			;	if DEBUG_STORESE 
535f			;		DMARK "LOt" 
535f			;		CALLMONITOR 
535f			;	endif 
535f			;	dec hl 
535f			;	ld a, ' ' 
535f			;	ld (hl), a 
535f			;	inc hl 
535f			;	ld (hl), a 
535f			;	inc hl 
535f			;	ld (hl), a 
535f			;	inc hl 
535f			;	ld a, FORTH_END_BUFFER 
535f			;	ld (hl), a 
535f			; 
535f			;	; TODO handle more than a single block read 
535f			; 
535f			; 
535f			;	ld hl, store_page+2 
535f			; 
535f			;	ld (os_tok_ptr), hl 
535f			; 
535f			;	if DEBUG_STORESE 
535f			;		DMARK "LO3" 
535f			;		CALLMONITOR 
535f			;	endif 
535f			; 
535f			;	call forthparse 
535f			;	call forthexec 
535f			;	call forthexec_cleanup 
535f			; 
535f			;	; go to next extent 
535f			; 
535f			;	; get next block  or mark as eof 
535f			;	jp .loadline 
535f			; 
535f			; 
535f			; 
535f			;	       NEXTW 
535f			;.loadeof:	ld a, 0 
535f			;		ld (store_openext), a 
535f			; 
535f			;	if DEBUG_STORESE 
535f			;		DMARK "LOF" 
535f			;		CALLMONITOR 
535f			;	endif 
535f			;		ret 
535f			;		;NEXTW 
535f			;.BSAVE:   
535f			; 
535f			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
535f			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
535f			;		NEXTW 
535f			;.BLOAD: 
535f			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
535f			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
535f			;		NEXTW 
535f			;;;; counter gap 
535f			 
535f			 
535f			.SEO: 
535f				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
535f 64				db WORD_SYS_CORE+80             
5360 7e 53			dw .SEI            
5362 04				db 3 + 1 
5363 .. 00			db "SEO",0              
5367				endm 
# End of macro CWHEAD
5367			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
5367			 
5367					; get port 
5367			 
5367					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5367 cd fb 22			call macro_dsp_valuehl 
536a				endm 
# End of macro FORTH_DSP_VALUEHL
536a			 
536a e5					push hl    ; u2 - byte 
536b			 
536b					; destroy value TOS 
536b			 
536b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
536b cd b3 23			call macro_forth_dsp_pop 
536e				endm 
# End of macro FORTH_DSP_POP
536e			 
536e					; get byte to send 
536e			 
536e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
536e cd fb 22			call macro_dsp_valuehl 
5371				endm 
# End of macro FORTH_DSP_VALUEHL
5371			 
5371 e5					push hl    ; u1 - addr 
5372			 
5372					; destroy value TOS 
5372			 
5372					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5372 cd b3 23			call macro_forth_dsp_pop 
5375				endm 
# End of macro FORTH_DSP_POP
5375			 
5375					; one value on hl get other one back 
5375			 
5375 d1					pop de   ; u1 - byte 
5376			 
5376 e1					pop hl   ; u2 - addr 
5377			 
5377					; TODO Send SPI byte 
5377			 
5377			 
5377 7b					ld a, e 
5378 cd 6b 02				call se_writebyte 
537b			 
537b					 
537b			 
537b					NEXTW 
537b c3 b1 24			jp macro_next 
537e				endm 
# End of macro NEXTW
537e			 
537e			.SEI: 
537e				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
537e 65				db WORD_SYS_CORE+81             
537f 98 53			dw .SFREE            
5381 04				db 3 + 1 
5382 .. 00			db "SEI",0              
5386				endm 
# End of macro CWHEAD
5386			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
5386			 
5386					; get port 
5386			 
5386					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5386 cd fb 22			call macro_dsp_valuehl 
5389				endm 
# End of macro FORTH_DSP_VALUEHL
5389			 
5389			;		push hl 
5389			 
5389					; destroy value TOS 
5389			 
5389					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5389 cd b3 23			call macro_forth_dsp_pop 
538c				endm 
# End of macro FORTH_DSP_POP
538c			 
538c					; one value on hl get other one back 
538c			 
538c			;		pop hl 
538c			 
538c			 
538c					; TODO Get SPI byte 
538c			 
538c cd 0d 03				call se_readbyte 
538f			 
538f 26 00				ld h, 0 
5391 6f					ld l, a 
5392 cd 04 21				call forth_push_numhl 
5395			 
5395					NEXTW 
5395 c3 b1 24			jp macro_next 
5398				endm 
# End of macro NEXTW
5398			 
5398			.SFREE: 
5398				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
5398 67				db WORD_SYS_CORE+83             
5399 c7 53			dw .SIZE            
539b 06				db 5 + 1 
539c .. 00			db "FFREE",0              
53a2				endm 
# End of macro CWHEAD
53a2			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
53a2			; | | Compatible with PicoSPINet  
53a2					if DEBUG_FORTH_WORDS_KEY 
53a2						DMARK "FFR" 
53a2 f5				push af  
53a3 3a b7 53			ld a, (.dmark)  
53a6 32 68 fe			ld (debug_mark),a  
53a9 3a b8 53			ld a, (.dmark+1)  
53ac 32 69 fe			ld (debug_mark+1),a  
53af 3a b9 53			ld a, (.dmark+2)  
53b2 32 6a fe			ld (debug_mark+2),a  
53b5 18 03			jr .pastdmark  
53b7 ..			.dmark: db "FFR"  
53ba f1			.pastdmark: pop af  
53bb			endm  
# End of macro DMARK
53bb						CALLMONITOR 
53bb cd 6c fe			call debug_vector  
53be				endm  
# End of macro CALLMONITOR
53be					endif 
53be			 
53be cd 33 08				call storage_freeblocks 
53c1			 
53c1 cd 04 21				call forth_push_numhl 
53c4			 
53c4				       NEXTW 
53c4 c3 b1 24			jp macro_next 
53c7				endm 
# End of macro NEXTW
53c7			.SIZE: 
53c7				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
53c7 67				db WORD_SYS_CORE+83             
53c8 fb 53			dw .CREATE            
53ca 05				db 4 + 1 
53cb .. 00			db "SIZE",0              
53d0				endm 
# End of macro CWHEAD
53d0			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
53d0			; | | Compatible with PicoSPINet  
53d0					if DEBUG_FORTH_WORDS_KEY 
53d0						DMARK "SIZ" 
53d0 f5				push af  
53d1 3a e5 53			ld a, (.dmark)  
53d4 32 68 fe			ld (debug_mark),a  
53d7 3a e6 53			ld a, (.dmark+1)  
53da 32 69 fe			ld (debug_mark+1),a  
53dd 3a e7 53			ld a, (.dmark+2)  
53e0 32 6a fe			ld (debug_mark+2),a  
53e3 18 03			jr .pastdmark  
53e5 ..			.dmark: db "SIZ"  
53e8 f1			.pastdmark: pop af  
53e9			endm  
# End of macro DMARK
53e9						CALLMONITOR 
53e9 cd 6c fe			call debug_vector  
53ec				endm  
# End of macro CALLMONITOR
53ec					endif 
53ec			 
53ec					FORTH_DSP_VALUEHL 
53ec cd fb 22			call macro_dsp_valuehl 
53ef				endm 
# End of macro FORTH_DSP_VALUEHL
53ef			;		push hl 
53ef					FORTH_DSP_POP 
53ef cd b3 23			call macro_forth_dsp_pop 
53f2				endm 
# End of macro FORTH_DSP_POP
53f2			;		pop hl 
53f2 cd 95 04				call storage_file_size 
53f5			 
53f5 cd 04 21				call forth_push_numhl 
53f8			  
53f8			 
53f8				       NEXTW 
53f8 c3 b1 24			jp macro_next 
53fb				endm 
# End of macro NEXTW
53fb			 
53fb			.CREATE: 
53fb				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
53fb 68				db WORD_SYS_CORE+84             
53fc 69 54			dw .APPEND            
53fe 07				db 6 + 1 
53ff .. 00			db "CREATE",0              
5406				endm 
# End of macro CWHEAD
5406			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
5406			; | | e.g.  
5406			; | | TestProgram CREATE 
5406			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
5406			; | |  
5406			; | | Max file IDs are 255. 
5406			; | |  
5406			; | | Compatible with PicoSPINet  
5406					 
5406					if DEBUG_FORTH_WORDS_KEY 
5406						DMARK "CRT" 
5406 f5				push af  
5407 3a 1b 54			ld a, (.dmark)  
540a 32 68 fe			ld (debug_mark),a  
540d 3a 1c 54			ld a, (.dmark+1)  
5410 32 69 fe			ld (debug_mark+1),a  
5413 3a 1d 54			ld a, (.dmark+2)  
5416 32 6a fe			ld (debug_mark+2),a  
5419 18 03			jr .pastdmark  
541b ..			.dmark: db "CRT"  
541e f1			.pastdmark: pop af  
541f			endm  
# End of macro DMARK
541f						CALLMONITOR 
541f cd 6c fe			call debug_vector  
5422				endm  
# End of macro CALLMONITOR
5422					endif 
5422			;		call storage_get_block_0 
5422			 
5422					; TODO pop hl 
5422			 
5422					;v5 FORTH_DSP_VALUE 
5422					FORTH_DSP_VALUE 
5422 cd e4 22			call macro_forth_dsp_value 
5425				endm 
# End of macro FORTH_DSP_VALUE
5425			 
5425				if DEBUG_STORESE 
5425					DMARK "CR1" 
5425 f5				push af  
5426 3a 3a 54			ld a, (.dmark)  
5429 32 68 fe			ld (debug_mark),a  
542c 3a 3b 54			ld a, (.dmark+1)  
542f 32 69 fe			ld (debug_mark+1),a  
5432 3a 3c 54			ld a, (.dmark+2)  
5435 32 6a fe			ld (debug_mark+2),a  
5438 18 03			jr .pastdmark  
543a ..			.dmark: db "CR1"  
543d f1			.pastdmark: pop af  
543e			endm  
# End of macro DMARK
543e					CALLMONITOR 
543e cd 6c fe			call debug_vector  
5441				endm  
# End of macro CALLMONITOR
5441				endif 
5441			;		push hl 
5441			;		FORTH_DSP_POP 
5441			;		pop hl 
5441			 
5441			;		inc hl   ; move past the type marker 
5441			 
5441 cd 69 08				call storage_create 
5444			 
5444				if DEBUG_STORESE 
5444					DMARK "CT1" 
5444 f5				push af  
5445 3a 59 54			ld a, (.dmark)  
5448 32 68 fe			ld (debug_mark),a  
544b 3a 5a 54			ld a, (.dmark+1)  
544e 32 69 fe			ld (debug_mark+1),a  
5451 3a 5b 54			ld a, (.dmark+2)  
5454 32 6a fe			ld (debug_mark+2),a  
5457 18 03			jr .pastdmark  
5459 ..			.dmark: db "CT1"  
545c f1			.pastdmark: pop af  
545d			endm  
# End of macro DMARK
545d					CALLMONITOR 
545d cd 6c fe			call debug_vector  
5460				endm  
# End of macro CALLMONITOR
5460				endif 
5460			;		push hl 
5460					FORTH_DSP_POP 
5460 cd b3 23			call macro_forth_dsp_pop 
5463				endm 
# End of macro FORTH_DSP_POP
5463			;		pop hl 
5463					; push file id to stack 
5463 cd 04 21				call forth_push_numhl 
5466			 
5466			 
5466			 
5466				       NEXTW 
5466 c3 b1 24			jp macro_next 
5469				endm 
# End of macro NEXTW
5469			 
5469			.APPEND: 
5469				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
5469 69				db WORD_SYS_CORE+85             
546a fa 54			dw .SDEL            
546c 07				db 6 + 1 
546d .. 00			db "APPEND",0              
5474				endm 
# End of macro CWHEAD
5474			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
5474			; | | e.g. 
5474			; | | Test CREATE      -> $01 
5474			; | | "A string to add to file" $01 APPEND 
5474			; | |  
5474			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
5474			; | | Compatible with PicoSPINet  
5474					if DEBUG_FORTH_WORDS_KEY 
5474						DMARK "APP" 
5474 f5				push af  
5475 3a 89 54			ld a, (.dmark)  
5478 32 68 fe			ld (debug_mark),a  
547b 3a 8a 54			ld a, (.dmark+1)  
547e 32 69 fe			ld (debug_mark+1),a  
5481 3a 8b 54			ld a, (.dmark+2)  
5484 32 6a fe			ld (debug_mark+2),a  
5487 18 03			jr .pastdmark  
5489 ..			.dmark: db "APP"  
548c f1			.pastdmark: pop af  
548d			endm  
# End of macro DMARK
548d						CALLMONITOR 
548d cd 6c fe			call debug_vector  
5490				endm  
# End of macro CALLMONITOR
5490					endif 
5490			 
5490					FORTH_DSP_VALUEHL 
5490 cd fb 22			call macro_dsp_valuehl 
5493				endm 
# End of macro FORTH_DSP_VALUEHL
5493 e5					push hl 	; save file id 
5494			 
5494				if DEBUG_STORESE 
5494					DMARK "AP1" 
5494 f5				push af  
5495 3a a9 54			ld a, (.dmark)  
5498 32 68 fe			ld (debug_mark),a  
549b 3a aa 54			ld a, (.dmark+1)  
549e 32 69 fe			ld (debug_mark+1),a  
54a1 3a ab 54			ld a, (.dmark+2)  
54a4 32 6a fe			ld (debug_mark+2),a  
54a7 18 03			jr .pastdmark  
54a9 ..			.dmark: db "AP1"  
54ac f1			.pastdmark: pop af  
54ad			endm  
# End of macro DMARK
54ad					CALLMONITOR 
54ad cd 6c fe			call debug_vector  
54b0				endm  
# End of macro CALLMONITOR
54b0				endif 
54b0					FORTH_DSP_POP 
54b0 cd b3 23			call macro_forth_dsp_pop 
54b3				endm 
# End of macro FORTH_DSP_POP
54b3			 
54b3					FORTH_DSP_VALUEHL 
54b3 cd fb 22			call macro_dsp_valuehl 
54b6				endm 
# End of macro FORTH_DSP_VALUEHL
54b6					;v5 FORTH_DSP_VALUE 
54b6 e5					push hl 	; save ptr to string to save 
54b7			 
54b7				if DEBUG_STORESE 
54b7					DMARK "AP1" 
54b7 f5				push af  
54b8 3a cc 54			ld a, (.dmark)  
54bb 32 68 fe			ld (debug_mark),a  
54be 3a cd 54			ld a, (.dmark+1)  
54c1 32 69 fe			ld (debug_mark+1),a  
54c4 3a ce 54			ld a, (.dmark+2)  
54c7 32 6a fe			ld (debug_mark+2),a  
54ca 18 03			jr .pastdmark  
54cc ..			.dmark: db "AP1"  
54cf f1			.pastdmark: pop af  
54d0			endm  
# End of macro DMARK
54d0					CALLMONITOR 
54d0 cd 6c fe			call debug_vector  
54d3				endm  
# End of macro CALLMONITOR
54d3				endif 
54d3					FORTH_DSP_POP 
54d3 cd b3 23			call macro_forth_dsp_pop 
54d6				endm 
# End of macro FORTH_DSP_POP
54d6			 
54d6 d1					pop de 
54d7 e1					pop hl 
54d8				if DEBUG_STORESE 
54d8					DMARK "AP2" 
54d8 f5				push af  
54d9 3a ed 54			ld a, (.dmark)  
54dc 32 68 fe			ld (debug_mark),a  
54df 3a ee 54			ld a, (.dmark+1)  
54e2 32 69 fe			ld (debug_mark+1),a  
54e5 3a ef 54			ld a, (.dmark+2)  
54e8 32 6a fe			ld (debug_mark+2),a  
54eb 18 03			jr .pastdmark  
54ed ..			.dmark: db "AP2"  
54f0 f1			.pastdmark: pop af  
54f1			endm  
# End of macro DMARK
54f1					CALLMONITOR 
54f1 cd 6c fe			call debug_vector  
54f4				endm  
# End of macro CALLMONITOR
54f4				endif 
54f4					;inc de ; skip var type indicator 
54f4			 
54f4					; TODO how to append numerics???? 
54f4			 
54f4 cd 56 0b				call storage_append		 
54f7			 
54f7				       NEXTW 
54f7 c3 b1 24			jp macro_next 
54fa				endm 
# End of macro NEXTW
54fa			.SDEL: 
54fa				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
54fa 6a				db WORD_SYS_CORE+86             
54fb 46 55			dw .OPEN            
54fd 05				db 4 + 1 
54fe .. 00			db "ERA",0              
5502				endm 
# End of macro CWHEAD
5502			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
5502			; | | Compatible with PicoSPINet  
5502					FORTH_DSP_VALUEHL 
5502 cd fb 22			call macro_dsp_valuehl 
5505				endm 
# End of macro FORTH_DSP_VALUEHL
5505			;		push hl 	; save file id 
5505			 
5505					if DEBUG_FORTH_WORDS_KEY 
5505						DMARK "ERA" 
5505 f5				push af  
5506 3a 1a 55			ld a, (.dmark)  
5509 32 68 fe			ld (debug_mark),a  
550c 3a 1b 55			ld a, (.dmark+1)  
550f 32 69 fe			ld (debug_mark+1),a  
5512 3a 1c 55			ld a, (.dmark+2)  
5515 32 6a fe			ld (debug_mark+2),a  
5518 18 03			jr .pastdmark  
551a ..			.dmark: db "ERA"  
551d f1			.pastdmark: pop af  
551e			endm  
# End of macro DMARK
551e						CALLMONITOR 
551e cd 6c fe			call debug_vector  
5521				endm  
# End of macro CALLMONITOR
5521					endif 
5521				if DEBUG_STORESE 
5521					DMARK "ER1" 
5521 f5				push af  
5522 3a 36 55			ld a, (.dmark)  
5525 32 68 fe			ld (debug_mark),a  
5528 3a 37 55			ld a, (.dmark+1)  
552b 32 69 fe			ld (debug_mark+1),a  
552e 3a 38 55			ld a, (.dmark+2)  
5531 32 6a fe			ld (debug_mark+2),a  
5534 18 03			jr .pastdmark  
5536 ..			.dmark: db "ER1"  
5539 f1			.pastdmark: pop af  
553a			endm  
# End of macro DMARK
553a					CALLMONITOR 
553a cd 6c fe			call debug_vector  
553d				endm  
# End of macro CALLMONITOR
553d				endif 
553d					FORTH_DSP_POP 
553d cd b3 23			call macro_forth_dsp_pop 
5540				endm 
# End of macro FORTH_DSP_POP
5540			 
5540			;		pop hl 
5540			 
5540 cd a8 06				call storage_erase 
5543				       NEXTW 
5543 c3 b1 24			jp macro_next 
5546				endm 
# End of macro NEXTW
5546			 
5546			.OPEN: 
5546				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
5546 6b				db WORD_SYS_CORE+87             
5547 da 55			dw .READ            
5549 05				db 4 + 1 
554a .. 00			db "OPEN",0              
554f				endm 
# End of macro CWHEAD
554f			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
554f			; | | e.g. 
554f			; | | $01 OPEN $01 DO $01 READ . LOOP 
554f			; | | 
554f			; | | Will return with 255 blocks if the file does not exist 
554f			; | | Compatible with PicoSPINet  
554f			 
554f					if DEBUG_FORTH_WORDS_KEY 
554f						DMARK "OPN" 
554f f5				push af  
5550 3a 64 55			ld a, (.dmark)  
5553 32 68 fe			ld (debug_mark),a  
5556 3a 65 55			ld a, (.dmark+1)  
5559 32 69 fe			ld (debug_mark+1),a  
555c 3a 66 55			ld a, (.dmark+2)  
555f 32 6a fe			ld (debug_mark+2),a  
5562 18 03			jr .pastdmark  
5564 ..			.dmark: db "OPN"  
5567 f1			.pastdmark: pop af  
5568			endm  
# End of macro DMARK
5568						CALLMONITOR 
5568 cd 6c fe			call debug_vector  
556b				endm  
# End of macro CALLMONITOR
556b					endif 
556b					; TODO handle multiple file opens 
556b			 
556b 3e 01			       	ld a, 1 
556d 32 67 fa				ld (store_openext), a 
5570			 
5570					; get max extents for this file 
5570				 
5570								 
5570					FORTH_DSP_VALUEHL 
5570 cd fb 22			call macro_dsp_valuehl 
5573				endm 
# End of macro FORTH_DSP_VALUEHL
5573			 
5573 65					ld h, l 
5574 2e 00				ld l, 0 
5576			 
5576					; store file id 
5576			 
5576 7c					ld a, h 
5577 32 64 fa				ld (store_filecache), a 
557a			 
557a				if DEBUG_STORESE 
557a					DMARK "OPN" 
557a f5				push af  
557b 3a 8f 55			ld a, (.dmark)  
557e 32 68 fe			ld (debug_mark),a  
5581 3a 90 55			ld a, (.dmark+1)  
5584 32 69 fe			ld (debug_mark+1),a  
5587 3a 91 55			ld a, (.dmark+2)  
558a 32 6a fe			ld (debug_mark+2),a  
558d 18 03			jr .pastdmark  
558f ..			.dmark: db "OPN"  
5592 f1			.pastdmark: pop af  
5593			endm  
# End of macro DMARK
5593					CALLMONITOR 
5593 cd 6c fe			call debug_vector  
5596				endm  
# End of macro CALLMONITOR
5596				endif 
5596			;		push hl 
5596					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
5596 cd b3 23			call macro_forth_dsp_pop 
5599				endm 
# End of macro FORTH_DSP_POP
5599			;		pop hl 
5599						 
5599 11 77 fa				ld de, store_page      ; get block zero of file 
559c cd bf 09				call storage_read 
559f cd f9 0f			call ishlzero 
55a2 20 04			jr nz, .opfound 
55a4			 
55a4				; file does not exist so indicate with 255 extents in use 
55a4			 
55a4 3e ff			ld a, 255 
55a6 18 29			jr .skipopeneof 
55a8			 
55a8			 
55a8			.opfound: 
55a8			 
55a8			 
55a8 3a 79 fa				ld a, (store_page+2)    ; max extents for this file 
55ab 32 66 fa				ld  (store_openmaxext), a   ; get our limit and push 
55ae					 
55ae				if DEBUG_STORESE 
55ae					DMARK "OPx" 
55ae f5				push af  
55af 3a c3 55			ld a, (.dmark)  
55b2 32 68 fe			ld (debug_mark),a  
55b5 3a c4 55			ld a, (.dmark+1)  
55b8 32 69 fe			ld (debug_mark+1),a  
55bb 3a c5 55			ld a, (.dmark+2)  
55be 32 6a fe			ld (debug_mark+2),a  
55c1 18 03			jr .pastdmark  
55c3 ..			.dmark: db "OPx"  
55c6 f1			.pastdmark: pop af  
55c7			endm  
# End of macro DMARK
55c7					CALLMONITOR 
55c7 cd 6c fe			call debug_vector  
55ca				endm  
# End of macro CALLMONITOR
55ca				endif 
55ca fe 00				cp 0 
55cc 20 03				jr nz, .skipopeneof 
55ce					; have opened an empty file 
55ce					 
55ce 32 67 fa				ld (store_openext), a 
55d1			 
55d1			.skipopeneof: 
55d1			 
55d1 6f					ld l, a 
55d2 26 00				ld h, 0 
55d4 cd 04 21				call forth_push_numhl 
55d7			 
55d7			 
55d7				       NEXTW 
55d7 c3 b1 24			jp macro_next 
55da				endm 
# End of macro NEXTW
55da			.READ: 
55da				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
55da 6c				db WORD_SYS_CORE+88             
55db 04 57			dw .EOF            
55dd 05				db 4 + 1 
55de .. 00			db "READ",0              
55e3				endm 
# End of macro CWHEAD
55e3			; | READ ( -- n  )  Reads next page of current file id and push to stack | DONE 
55e3			; | | e.g. 
55e3			; | | $01 OPEN $01 DO READ . LOOP 
55e3			; | | 
55e3			; | | As this word only reads one 64 byte block in at a time, if the APPEND word has created extra blocks for the excess, this READ 
55e3			; | | word is unaware so the long string needs to be joined if the string is a full. A single block read might be what you want, 
55e3			; | | but if not then writing a word to join blocks will be required. The upshot is a full string will be 62 bytes as the first 
55e3			; | | two bytes contain the file id and extent. 
55e3			; | |  
55e3			; | | Note: There is a flag that enables/disables long block reads called 'store_longread' and a poke of a non-zero value will 
55e3			; | | enable the code to automatically read futher blocks if full. It is BUGGY so don't use for now. 
55e3			; | | Compatible with PicoSPINet  
55e3			 
55e3					if DEBUG_FORTH_WORDS_KEY 
55e3						DMARK "REA" 
55e3 f5				push af  
55e4 3a f8 55			ld a, (.dmark)  
55e7 32 68 fe			ld (debug_mark),a  
55ea 3a f9 55			ld a, (.dmark+1)  
55ed 32 69 fe			ld (debug_mark+1),a  
55f0 3a fa 55			ld a, (.dmark+2)  
55f3 32 6a fe			ld (debug_mark+2),a  
55f6 18 03			jr .pastdmark  
55f8 ..			.dmark: db "REA"  
55fb f1			.pastdmark: pop af  
55fc			endm  
# End of macro DMARK
55fc						CALLMONITOR 
55fc cd 6c fe			call debug_vector  
55ff				endm  
# End of macro CALLMONITOR
55ff					endif 
55ff					; store_openext use it. If zero it is EOF 
55ff			 
55ff					; read block from current stream id 
55ff					; if the block does not contain zero term keep reading blocks until zero found 
55ff					; push the block to stack 
55ff					; save the block id to stream 
55ff			 
55ff			 
55ff cd 31 57				call .testeof 
5602 3e 01				ld a, 1 
5604 bd					cp l 
5605 ca e0 56				jp z, .ateof 
5608			 
5608			 
5608			;		FORTH_DSP_VALUEHL 
5608			 
5608			;		push hl 
5608			 
5608			;	if DEBUG_STORESE 
5608			;		DMARK "REA" 
5608			;		CALLMONITOR 
5608			;	endif 
5608			;		FORTH_DSP_POP 
5608			 
5608			;		pop hl 
5608				 
5608 3a 64 fa				ld a, (store_filecache) 
560b 67					ld h,a 
560c			 
560c 3a 67 fa				ld a, (store_openext) 
560f 6f					ld l, a 
5610					 
5610 fe 00				cp 0 
5612 ca e0 56				jp z, .ateof     ; dont read past eof 
5615			 
5615 cd a2 0c				call storage_clear_page 
5618			 
5618 11 77 fa				ld de, store_page 
561b				if DEBUG_STORESE 
561b					DMARK "RE1" 
561b f5				push af  
561c 3a 30 56			ld a, (.dmark)  
561f 32 68 fe			ld (debug_mark),a  
5622 3a 31 56			ld a, (.dmark+1)  
5625 32 69 fe			ld (debug_mark+1),a  
5628 3a 32 56			ld a, (.dmark+2)  
562b 32 6a fe			ld (debug_mark+2),a  
562e 18 03			jr .pastdmark  
5630 ..			.dmark: db "RE1"  
5633 f1			.pastdmark: pop af  
5634			endm  
# End of macro DMARK
5634					CALLMONITOR 
5634 cd 6c fe			call debug_vector  
5637				endm  
# End of macro CALLMONITOR
5637				endif 
5637 cd bf 09				call storage_read 
563a			 
563a				if DEBUG_STORESE 
563a					DMARK "RE2" 
563a f5				push af  
563b 3a 4f 56			ld a, (.dmark)  
563e 32 68 fe			ld (debug_mark),a  
5641 3a 50 56			ld a, (.dmark+1)  
5644 32 69 fe			ld (debug_mark+1),a  
5647 3a 51 56			ld a, (.dmark+2)  
564a 32 6a fe			ld (debug_mark+2),a  
564d 18 03			jr .pastdmark  
564f ..			.dmark: db "RE2"  
5652 f1			.pastdmark: pop af  
5653			endm  
# End of macro DMARK
5653					CALLMONITOR 
5653 cd 6c fe			call debug_vector  
5656				endm  
# End of macro CALLMONITOR
5656				endif 
5656 cd f9 0f			call ishlzero 
5659			;	ld a, l 
5659			;	add h 
5659			;	cp 0 
5659 ca e0 56			jp z, .readeof 
565c			 
565c				; not eof so hl should point to data to push to stack 
565c			 
565c				if DEBUG_STORESE 
565c					DMARK "RE3" 
565c f5				push af  
565d 3a 71 56			ld a, (.dmark)  
5660 32 68 fe			ld (debug_mark),a  
5663 3a 72 56			ld a, (.dmark+1)  
5666 32 69 fe			ld (debug_mark+1),a  
5669 3a 73 56			ld a, (.dmark+2)  
566c 32 6a fe			ld (debug_mark+2),a  
566f 18 03			jr .pastdmark  
5671 ..			.dmark: db "RE3"  
5674 f1			.pastdmark: pop af  
5675			endm  
# End of macro DMARK
5675					CALLMONITOR 
5675 cd 6c fe			call debug_vector  
5678				endm  
# End of macro CALLMONITOR
5678				endif 
5678 cd 72 21			call forth_push_str 
567b			 
567b				if DEBUG_STORESE 
567b					DMARK "RE4" 
567b f5				push af  
567c 3a 90 56			ld a, (.dmark)  
567f 32 68 fe			ld (debug_mark),a  
5682 3a 91 56			ld a, (.dmark+1)  
5685 32 69 fe			ld (debug_mark+1),a  
5688 3a 92 56			ld a, (.dmark+2)  
568b 32 6a fe			ld (debug_mark+2),a  
568e 18 03			jr .pastdmark  
5690 ..			.dmark: db "RE4"  
5693 f1			.pastdmark: pop af  
5694			endm  
# End of macro DMARK
5694					CALLMONITOR 
5694 cd 6c fe			call debug_vector  
5697				endm  
# End of macro CALLMONITOR
5697				endif 
5697				; get next block  or mark as eof 
5697			 
5697 3a 66 fa			ld a, (store_openmaxext)   ; get our limit 
569a 4f				ld c, a	 
569b 3a 67 fa			ld a, (store_openext) 
569e			 
569e				if DEBUG_STORESE 
569e					DMARK "RE5" 
569e f5				push af  
569f 3a b3 56			ld a, (.dmark)  
56a2 32 68 fe			ld (debug_mark),a  
56a5 3a b4 56			ld a, (.dmark+1)  
56a8 32 69 fe			ld (debug_mark+1),a  
56ab 3a b5 56			ld a, (.dmark+2)  
56ae 32 6a fe			ld (debug_mark+2),a  
56b1 18 03			jr .pastdmark  
56b3 ..			.dmark: db "RE5"  
56b6 f1			.pastdmark: pop af  
56b7			endm  
# End of macro DMARK
56b7					CALLMONITOR 
56b7 cd 6c fe			call debug_vector  
56ba				endm  
# End of macro CALLMONITOR
56ba				endif 
56ba b9				cp c 
56bb 28 23			jr z, .readeof     ; at last extent 
56bd			 
56bd 3c					inc a 
56be 32 67 fa				ld (store_openext), a 
56c1			 
56c1				if DEBUG_STORESE 
56c1					DMARK "RE6" 
56c1 f5				push af  
56c2 3a d6 56			ld a, (.dmark)  
56c5 32 68 fe			ld (debug_mark),a  
56c8 3a d7 56			ld a, (.dmark+1)  
56cb 32 69 fe			ld (debug_mark+1),a  
56ce 3a d8 56			ld a, (.dmark+2)  
56d1 32 6a fe			ld (debug_mark+2),a  
56d4 18 03			jr .pastdmark  
56d6 ..			.dmark: db "RE6"  
56d9 f1			.pastdmark: pop af  
56da			endm  
# End of macro DMARK
56da					CALLMONITOR 
56da cd 6c fe			call debug_vector  
56dd				endm  
# End of macro CALLMONITOR
56dd				endif 
56dd			 
56dd			 
56dd				       NEXTW 
56dd c3 b1 24			jp macro_next 
56e0				endm 
# End of macro NEXTW
56e0			.ateof: 
56e0				;	ld hl, .showeof 
56e0				;	call forth_push_str 
56e0 3e 00		.readeof:	ld a, 0 
56e2 32 67 fa				ld (store_openext), a 
56e5			 
56e5					 
56e5				if DEBUG_STORESE 
56e5					DMARK "REF" 
56e5 f5				push af  
56e6 3a fa 56			ld a, (.dmark)  
56e9 32 68 fe			ld (debug_mark),a  
56ec 3a fb 56			ld a, (.dmark+1)  
56ef 32 69 fe			ld (debug_mark+1),a  
56f2 3a fc 56			ld a, (.dmark+2)  
56f5 32 6a fe			ld (debug_mark+2),a  
56f8 18 03			jr .pastdmark  
56fa ..			.dmark: db "REF"  
56fd f1			.pastdmark: pop af  
56fe			endm  
# End of macro DMARK
56fe					CALLMONITOR 
56fe cd 6c fe			call debug_vector  
5701				endm  
# End of macro CALLMONITOR
5701				endif 
5701				       NEXTW 
5701 c3 b1 24			jp macro_next 
5704				endm 
# End of macro NEXTW
5704			 
5704			;.showeof:   db "eof", 0 
5704			 
5704			 
5704			.EOF: 
5704				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
5704 6d				db WORD_SYS_CORE+89             
5705 46 57			dw .FORMAT            
5707 04				db 3 + 1 
5708 .. 00			db "EOF",0              
570c				endm 
# End of macro CWHEAD
570c			; | EOF ( -- u )  Returns EOF logical state of current open file id | DONE 
570c			; | | e.g. 
570c			; | | $01 OPEN REPEAT READ EOF $00 IF LOOP 
570c			; | | Compatible with PicoSPINet  
570c					; TODO if current block id for stream is zero then push true else false 
570c			 
570c					if DEBUG_FORTH_WORDS_KEY 
570c						DMARK "EOF" 
570c f5				push af  
570d 3a 21 57			ld a, (.dmark)  
5710 32 68 fe			ld (debug_mark),a  
5713 3a 22 57			ld a, (.dmark+1)  
5716 32 69 fe			ld (debug_mark+1),a  
5719 3a 23 57			ld a, (.dmark+2)  
571c 32 6a fe			ld (debug_mark+2),a  
571f 18 03			jr .pastdmark  
5721 ..			.dmark: db "EOF"  
5724 f1			.pastdmark: pop af  
5725			endm  
# End of macro DMARK
5725						CALLMONITOR 
5725 cd 6c fe			call debug_vector  
5728				endm  
# End of macro CALLMONITOR
5728					endif 
5728			 
5728					; TODO handlue multiple file streams 
5728			 
5728			;		FORTH_iDSP_POP     ; for now just get rid of stream id 
5728 cd 31 57				call .testeof 
572b cd 04 21				call forth_push_numhl 
572e			 
572e			 
572e				       NEXTW 
572e c3 b1 24			jp macro_next 
5731				endm 
# End of macro NEXTW
5731			 
5731			.testeof: 
5731 2e 01				ld l, 1 
5733 3a 66 fa				ld a, (store_openmaxext) 
5736 fe 00				cp 0 
5738 28 09				jr  z, .eofdone   ; empty file 
573a 3a 67 fa				ld a, (store_openext) 
573d fe 00				cp 0 
573f 28 02				jr  z, .eofdone 
5741 2e 00				ld l, 0 
5743 26 00		.eofdone:	ld h, 0 
5745 c9					ret 
5746			 
5746			 
5746			 
5746			 
5746			.FORMAT: 
5746				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
5746 6d				db WORD_SYS_CORE+89             
5747 97 57			dw .LABEL            
5749 07				db 6 + 1 
574a .. 00			db "FORMAT",0              
5751				endm 
# End of macro CWHEAD
5751			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
5751			; | | Compatible with PicoSPINet  
5751					; TODO if current block id for stream is zero then push true else false 
5751				 
5751				if DEBUG_STORESE 
5751					DMARK "FOR" 
5751 f5				push af  
5752 3a 66 57			ld a, (.dmark)  
5755 32 68 fe			ld (debug_mark),a  
5758 3a 67 57			ld a, (.dmark+1)  
575b 32 69 fe			ld (debug_mark+1),a  
575e 3a 68 57			ld a, (.dmark+2)  
5761 32 6a fe			ld (debug_mark+2),a  
5764 18 03			jr .pastdmark  
5766 ..			.dmark: db "FOR"  
5769 f1			.pastdmark: pop af  
576a			endm  
# End of macro DMARK
576a					CALLMONITOR 
576a cd 6c fe			call debug_vector  
576d				endm  
# End of macro CALLMONITOR
576d				endif 
576d					; Wipes the bank check flags to cause a reformat on next block 0 read 
576d			 
576d 21 01 00				ld hl, 1 
5770 3e 00				ld a, 0 
5772 cd 6b 02				call se_writebyte 
5775			 
5775				if DEBUG_STORESE 
5775					DMARK "FO0" 
5775 f5				push af  
5776 3a 8a 57			ld a, (.dmark)  
5779 32 68 fe			ld (debug_mark),a  
577c 3a 8b 57			ld a, (.dmark+1)  
577f 32 69 fe			ld (debug_mark+1),a  
5782 3a 8c 57			ld a, (.dmark+2)  
5785 32 6a fe			ld (debug_mark+2),a  
5788 18 03			jr .pastdmark  
578a ..			.dmark: db "FO0"  
578d f1			.pastdmark: pop af  
578e			endm  
# End of macro DMARK
578e					CALLMONITOR 
578e cd 6c fe			call debug_vector  
5791				endm  
# End of macro CALLMONITOR
5791				endif 
5791					; force bank init 
5791			 
5791 cd 17 05				call storage_get_block_0 
5794					 
5794				       NEXTW 
5794 c3 b1 24			jp macro_next 
5797				endm 
# End of macro NEXTW
5797			.LABEL: 
5797				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
5797 6d				db WORD_SYS_CORE+89             
5798 e5 57			dw .STOREPAGE            
579a 06				db 5 + 1 
579b .. 00			db "LABEL",0              
57a1				endm 
# End of macro CWHEAD
57a1			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
57a1			; | | Compatible with PicoSPINet  
57a1					; TODO test to see if bank is selected 
57a1				 
57a1					if DEBUG_FORTH_WORDS_KEY 
57a1						DMARK "LBL" 
57a1 f5				push af  
57a2 3a b6 57			ld a, (.dmark)  
57a5 32 68 fe			ld (debug_mark),a  
57a8 3a b7 57			ld a, (.dmark+1)  
57ab 32 69 fe			ld (debug_mark+1),a  
57ae 3a b8 57			ld a, (.dmark+2)  
57b1 32 6a fe			ld (debug_mark+2),a  
57b4 18 03			jr .pastdmark  
57b6 ..			.dmark: db "LBL"  
57b9 f1			.pastdmark: pop af  
57ba			endm  
# End of macro DMARK
57ba						CALLMONITOR 
57ba cd 6c fe			call debug_vector  
57bd				endm  
# End of macro CALLMONITOR
57bd					endif 
57bd			;	if DEBUG_STORESE 
57bd			;		DMARK "LBL" 
57bd			;		CALLMONITOR 
57bd			;	endif 
57bd					FORTH_DSP_VALUEHL 
57bd cd fb 22			call macro_dsp_valuehl 
57c0				endm 
# End of macro FORTH_DSP_VALUEHL
57c0					;v5FORTH_DSP_VALUE 
57c0					 
57c0			;		push hl 
57c0					FORTH_DSP_POP 
57c0 cd b3 23			call macro_forth_dsp_pop 
57c3				endm 
# End of macro FORTH_DSP_POP
57c3			;		pop hl 
57c3			 
57c3			;v5		inc hl   ; move past the type marker 
57c3			 
57c3				if DEBUG_STORESE 
57c3					DMARK "LBl" 
57c3 f5				push af  
57c4 3a d8 57			ld a, (.dmark)  
57c7 32 68 fe			ld (debug_mark),a  
57ca 3a d9 57			ld a, (.dmark+1)  
57cd 32 69 fe			ld (debug_mark+1),a  
57d0 3a da 57			ld a, (.dmark+2)  
57d3 32 6a fe			ld (debug_mark+2),a  
57d6 18 03			jr .pastdmark  
57d8 ..			.dmark: db "LBl"  
57db f1			.pastdmark: pop af  
57dc			endm  
# End of macro DMARK
57dc					CALLMONITOR 
57dc cd 6c fe			call debug_vector  
57df				endm  
# End of macro CALLMONITOR
57df				endif 
57df cd 3b 06				call storage_label 
57e2			 
57e2				       NEXTW 
57e2 c3 b1 24			jp macro_next 
57e5				endm 
# End of macro NEXTW
57e5			.STOREPAGE: 
57e5				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
57e5 6d				db WORD_SYS_CORE+89             
57e6 18 58			dw .LABELS            
57e8 0a				db 9 + 1 
57e9 .. 00			db "STOREPAGE",0              
57f3				endm 
# End of macro CWHEAD
57f3			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
57f3			; | | Compatible with PicoSPINet  
57f3					; TODO test to see if bank is selected 
57f3				 
57f3					if DEBUG_FORTH_WORDS_KEY 
57f3						DMARK "STP" 
57f3 f5				push af  
57f4 3a 08 58			ld a, (.dmark)  
57f7 32 68 fe			ld (debug_mark),a  
57fa 3a 09 58			ld a, (.dmark+1)  
57fd 32 69 fe			ld (debug_mark+1),a  
5800 3a 0a 58			ld a, (.dmark+2)  
5803 32 6a fe			ld (debug_mark+2),a  
5806 18 03			jr .pastdmark  
5808 ..			.dmark: db "STP"  
580b f1			.pastdmark: pop af  
580c			endm  
# End of macro DMARK
580c						CALLMONITOR 
580c cd 6c fe			call debug_vector  
580f				endm  
# End of macro CALLMONITOR
580f					endif 
580f			;	if DEBUG_STORESE 
580f			;		DMARK "STP" 
580f			;		CALLMONITOR 
580f			;	endif 
580f			 
580f 21 77 fa			ld hl, store_page 
5812 cd 04 21			call forth_push_numhl 
5815			 
5815			 
5815				       NEXTW 
5815 c3 b1 24			jp macro_next 
5818				endm 
# End of macro NEXTW
5818			.LABELS: 
5818				CWHEAD .SCONST1 89 "LABELS" 6 WORD_FLAG_CODE 
5818 6d				db WORD_SYS_CORE+89             
5819 a2 58			dw .SCONST1            
581b 07				db 6 + 1 
581c .. 00			db "LABELS",0              
5823				endm 
# End of macro CWHEAD
5823			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | TO TEST 
5823			; | | *NOT* Compatible with PicoSPINet  
5823					;  
5823			 
5823					; save the current device selected to restore afterwards 
5823				 
5823 3a 5d fa				ld a, (spi_device) 
5826 f5					push af 
5827			 
5827			 
5827					; run through each of the banks 
5827			 
5827 21 01 00				ld hl, 1 
582a cd 04 21				call forth_push_numhl 
582d 3e ff				ld a, SPI_CE_HIGH 
582f cb 87				res SPI_CE0, a 
5831 32 5d fa				ld (spi_device), a 
5834 cd 17 05				call storage_get_block_0 
5837 21 7a fa				ld hl, store_page+3 
583a cd 72 21				call forth_push_str 
583d			 
583d					 
583d 21 02 00				ld hl, 2 
5840 cd 04 21				call forth_push_numhl 
5843 3e ff				ld a, SPI_CE_HIGH 
5845 cb 8f				res SPI_CE1, a 
5847 32 5d fa				ld (spi_device), a 
584a cd 17 05				call storage_get_block_0 
584d 21 7a fa				ld hl, store_page+3 
5850 cd 72 21				call forth_push_str 
5853			 
5853					 
5853 21 03 00				ld hl, 3 
5856 cd 04 21				call forth_push_numhl 
5859 3e ff				ld a, SPI_CE_HIGH 
585b cb 97				res SPI_CE2, a 
585d 32 5d fa				ld (spi_device), a 
5860 cd 17 05				call storage_get_block_0 
5863 21 7a fa				ld hl, store_page+3 
5866 cd 72 21				call forth_push_str 
5869			 
5869			 
5869 21 04 00				ld hl, 4 
586c cd 04 21				call forth_push_numhl 
586f 3e ff				ld a, SPI_CE_HIGH 
5871 cb 9f				res SPI_CE3, a 
5873 32 5d fa				ld (spi_device), a 
5876 cd 17 05				call storage_get_block_0 
5879 21 7a fa				ld hl, store_page+3 
587c cd 72 21				call forth_push_str 
587f			 
587f					 
587f			 
587f 21 05 00				ld hl, 5 
5882 cd 04 21				call forth_push_numhl 
5885 3e ff				ld a, SPI_CE_HIGH 
5887 cb a7				res SPI_CE4, a 
5889 32 5d fa				ld (spi_device), a 
588c cd 17 05				call storage_get_block_0 
588f 21 7a fa				ld hl, store_page+3 
5892 cd 72 21				call forth_push_str 
5895			 
5895					 
5895					; push fixed count of storage devices (on board) for now 
5895			 
5895 21 05 00				ld hl, 5 
5898 cd 04 21				call forth_push_numhl 
589b			 
589b					; restore selected device  
589b				 
589b f1					pop af 
589c 32 5d fa				ld (spi_device), a 
589f			 
589f				       NEXTW 
589f c3 b1 24			jp macro_next 
58a2				endm 
# End of macro NEXTW
58a2			 
58a2			.SCONST1: 
58a2				CWHEAD .SCONST2 89 "FILEID" 6 WORD_FLAG_CODE 
58a2 6d				db WORD_SYS_CORE+89             
58a3 b9 58			dw .SCONST2            
58a5 07				db 6 + 1 
58a6 .. 00			db "FILEID",0              
58ad				endm 
# End of macro CWHEAD
58ad			; | FILEID (  -- u1  )  Pushes currently open file ID to stack | DONE 
58ad			; | | Compatible with PicoSPINet  
58ad 3a 64 fa				ld a, (store_filecache) 
58b0 26 00				ld h, 0 
58b2 6f					ld l, a 
58b3 cd 04 21				call forth_push_numhl 
58b6					NEXTW 
58b6 c3 b1 24			jp macro_next 
58b9				endm 
# End of macro NEXTW
58b9			.SCONST2: 
58b9				CWHEAD .SCONST3 89 "FILEEXT" 7 WORD_FLAG_CODE 
58b9 6d				db WORD_SYS_CORE+89             
58ba d1 58			dw .SCONST3            
58bc 08				db 7 + 1 
58bd .. 00			db "FILEEXT",0              
58c5				endm 
# End of macro CWHEAD
58c5			; | FILEEXT (  -- u1  )  Pushes the currently read file extent of the file to stack | DONE 
58c5			; | | Compatible with PicoSPINet  
58c5 3a 67 fa				ld a, (store_openext) 
58c8 26 00				ld h, 0 
58ca 6f					ld l, a 
58cb cd 04 21				call forth_push_numhl 
58ce					NEXTW 
58ce c3 b1 24			jp macro_next 
58d1				endm 
# End of macro NEXTW
58d1			.SCONST3: 
58d1				CWHEAD .SCONST4 89 "FILEMAX" 7 WORD_FLAG_CODE 
58d1 6d				db WORD_SYS_CORE+89             
58d2 e9 58			dw .SCONST4            
58d4 08				db 7 + 1 
58d5 .. 00			db "FILEMAX",0              
58dd				endm 
# End of macro CWHEAD
58dd			; | FILEMAXEXT (  -- u1  )  Pushes the maximum file extent of the currenlty open file to stack | DONE 
58dd			; | | Compatible with PicoSPINet  
58dd 3a 66 fa				ld a, (store_openmaxext) 
58e0 26 00				ld h, 0 
58e2 6f					ld l, a 
58e3 cd 04 21				call forth_push_numhl 
58e6					NEXTW 
58e6 c3 b1 24			jp macro_next 
58e9				endm 
# End of macro NEXTW
58e9			.SCONST4: 
58e9				CWHEAD .SCONST5 89 "FILEADDR" 8 WORD_FLAG_CODE 
58e9 6d				db WORD_SYS_CORE+89             
58ea ff 58			dw .SCONST5            
58ec 09				db 8 + 1 
58ed .. 00			db "FILEADDR",0              
58f6				endm 
# End of macro CWHEAD
58f6			; | FILEADDR (  -- u1  )  Pushes the address of the block accessed for the currenlty open file to stack | DONE 
58f6			; | | Compatible with PicoSPINet  
58f6 2a 68 fa				ld hl, (store_openaddr) 
58f9 cd 04 21				call forth_push_numhl 
58fc					NEXTW 
58fc c3 b1 24			jp macro_next 
58ff				endm 
# End of macro NEXTW
58ff			.SCONST5: 
58ff				CWHEAD .SCONST6 89 "FILEPAGE" 8 WORD_FLAG_CODE 
58ff 6d				db WORD_SYS_CORE+89             
5900 20 59			dw .SCONST6            
5902 09				db 8 + 1 
5903 .. 00			db "FILEPAGE",0              
590c				endm 
# End of macro CWHEAD
590c			; | FILEPAGE (  -- u1  )  Pushes the page id block accessed for the currenlty open file to stack | DONE 
590c			; | | Compatible with PicoSPINet  
590c 2a 68 fa				ld hl, (store_openaddr) 
590f e5					push hl 
5910 c1					pop bc 
5911 16 00				ld d, 0 
5913 1e 40				ld e, STORE_BLOCK_PHY 
5915 cd 2d 0f				call Div16 
5918 c5					push bc 
5919 e1					pop hl 
591a cd 04 21				call forth_push_numhl 
591d					NEXTW 
591d c3 b1 24			jp macro_next 
5920				endm 
# End of macro NEXTW
5920			.SCONST6: 
5920				CWHEAD .ENDSTORAGE 89 "READCONT" 8 WORD_FLAG_CODE 
5920 6d				db WORD_SYS_CORE+89             
5921 39 59			dw .ENDSTORAGE            
5923 09				db 8 + 1 
5924 .. 00			db "READCONT",0              
592d				endm 
# End of macro CWHEAD
592d			; | READCONT (  -- u1  )  Pushes the READ continuation flag to stack | DONE 
592d			; | | If the most recent READ results in a full buffer load then this flag is set and will indicate that 
592d			; | | a further read should, if applicable, be CONCAT to the previous read. 
592d			; | | Compatible with PicoSPINet  
592d 3a 6a fa				ld a, (store_readcont) 
5930 26 00				ld h, 0 
5932 6f					ld l, a 
5933 cd 04 21				call forth_push_numhl 
5936					NEXTW 
5936 c3 b1 24			jp macro_next 
5939				endm 
# End of macro NEXTW
5939			.ENDSTORAGE: 
5939			; eof 
# End of file forth_words_storage.asm
5939			endif 
5939				include "forth_words_device.asm" 
5939			; Device related words 
5939			 
5939			; | ## Device Words 
5939			 
5939			;if SOUND_ENABLE 
5939			;.NOTE: 
5939			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
5939			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
5939			;		if DEBUG_FORTH_WORDS_KEY 
5939			;			DMARK "NTE" 
5939			;			CALLMONITOR 
5939			;		endif 
5939			; 
5939			;	 
5939			; 
5939			;		NEXTW 
5939			;.AFTERSOUND: 
5939			;endif 
5939			 
5939			 
5939			USE_GPIO: equ 0 
5939			 
5939			if USE_GPIO 
5939			.GP1: 
5939				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
5939			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
5939					NEXTW 
5939			.GP2: 
5939				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
5939			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
5939			 
5939					NEXTW 
5939			 
5939			.GP3: 
5939				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
5939			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
5939			 
5939					NEXTW 
5939			 
5939			.GP4: 
5939				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
5939			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
5939			 
5939					NEXTW 
5939			.SIN: 
5939			 
5939			 
5939			endif 
5939			 
5939			 
5939				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
5939 33				db WORD_SYS_CORE+31             
593a 6e 59			dw .SOUT            
593c 03				db 2 + 1 
593d .. 00			db "IN",0              
5940				endm 
# End of macro CWHEAD
5940			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
5940					if DEBUG_FORTH_WORDS_KEY 
5940						DMARK "IN." 
5940 f5				push af  
5941 3a 55 59			ld a, (.dmark)  
5944 32 68 fe			ld (debug_mark),a  
5947 3a 56 59			ld a, (.dmark+1)  
594a 32 69 fe			ld (debug_mark+1),a  
594d 3a 57 59			ld a, (.dmark+2)  
5950 32 6a fe			ld (debug_mark+2),a  
5953 18 03			jr .pastdmark  
5955 ..			.dmark: db "IN."  
5958 f1			.pastdmark: pop af  
5959			endm  
# End of macro DMARK
5959						CALLMONITOR 
5959 cd 6c fe			call debug_vector  
595c				endm  
# End of macro CALLMONITOR
595c					endif 
595c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
595c cd fb 22			call macro_dsp_valuehl 
595f				endm 
# End of macro FORTH_DSP_VALUEHL
595f			 
595f e5					push hl 
5960			 
5960					; destroy value TOS 
5960			 
5960					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5960 cd b3 23			call macro_forth_dsp_pop 
5963				endm 
# End of macro FORTH_DSP_POP
5963			 
5963					; one value on hl get other one back 
5963			 
5963 c1					pop bc 
5964			 
5964					; do the sub 
5964			;		ex de, hl 
5964			 
5964 ed 68				in l,(c) 
5966			 
5966					; save it 
5966			 
5966 26 00				ld h,0 
5968			 
5968					; TODO push value back onto stack for another op etc 
5968			 
5968 cd 04 21				call forth_push_numhl 
596b					NEXTW 
596b c3 b1 24			jp macro_next 
596e				endm 
# End of macro NEXTW
596e			.SOUT: 
596e				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
596e 34				db WORD_SYS_CORE+32             
596f c1 59			dw .SPIO            
5971 04				db 3 + 1 
5972 .. 00			db "OUT",0              
5976				endm 
# End of macro CWHEAD
5976			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
5976					if DEBUG_FORTH_WORDS_KEY 
5976						DMARK "OUT" 
5976 f5				push af  
5977 3a 8b 59			ld a, (.dmark)  
597a 32 68 fe			ld (debug_mark),a  
597d 3a 8c 59			ld a, (.dmark+1)  
5980 32 69 fe			ld (debug_mark+1),a  
5983 3a 8d 59			ld a, (.dmark+2)  
5986 32 6a fe			ld (debug_mark+2),a  
5989 18 03			jr .pastdmark  
598b ..			.dmark: db "OUT"  
598e f1			.pastdmark: pop af  
598f			endm  
# End of macro DMARK
598f						CALLMONITOR 
598f cd 6c fe			call debug_vector  
5992				endm  
# End of macro CALLMONITOR
5992					endif 
5992			 
5992					; get port 
5992			 
5992					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5992 cd fb 22			call macro_dsp_valuehl 
5995				endm 
# End of macro FORTH_DSP_VALUEHL
5995			 
5995 e5					push hl 
5996			 
5996					; destroy value TOS 
5996			 
5996					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5996 cd b3 23			call macro_forth_dsp_pop 
5999				endm 
# End of macro FORTH_DSP_POP
5999			 
5999					; get byte to send 
5999			 
5999					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5999 cd fb 22			call macro_dsp_valuehl 
599c				endm 
# End of macro FORTH_DSP_VALUEHL
599c			 
599c			;		push hl 
599c			 
599c					; destroy value TOS 
599c			 
599c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
599c cd b3 23			call macro_forth_dsp_pop 
599f				endm 
# End of macro FORTH_DSP_POP
599f			 
599f					; one value on hl get other one back 
599f			 
599f			;		pop hl 
599f			 
599f c1					pop bc 
59a0			 
59a0					if DEBUG_FORTH_WORDS 
59a0						DMARK "OUT" 
59a0 f5				push af  
59a1 3a b5 59			ld a, (.dmark)  
59a4 32 68 fe			ld (debug_mark),a  
59a7 3a b6 59			ld a, (.dmark+1)  
59aa 32 69 fe			ld (debug_mark+1),a  
59ad 3a b7 59			ld a, (.dmark+2)  
59b0 32 6a fe			ld (debug_mark+2),a  
59b3 18 03			jr .pastdmark  
59b5 ..			.dmark: db "OUT"  
59b8 f1			.pastdmark: pop af  
59b9			endm  
# End of macro DMARK
59b9						CALLMONITOR 
59b9 cd 6c fe			call debug_vector  
59bc				endm  
# End of macro CALLMONITOR
59bc					endif 
59bc			 
59bc ed 69				out (c), l 
59be			 
59be					NEXTW 
59be c3 b1 24			jp macro_next 
59c1				endm 
# End of macro NEXTW
59c1			 
59c1			 
59c1			.SPIO: 
59c1			 
59c1			if STORAGE_SE 
59c1				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
59c1 51				db WORD_SYS_CORE+61             
59c2 d2 59			dw .SPICEH            
59c4 07				db 6 + 1 
59c5 .. 00			db "SPICEL",0              
59cc				endm 
# End of macro CWHEAD
59cc			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
59cc			 
59cc cd 14 02				call spi_ce_low 
59cf			    NEXTW 
59cf c3 b1 24			jp macro_next 
59d2				endm 
# End of macro NEXTW
59d2			 
59d2			.SPICEH: 
59d2				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
59d2 51				db WORD_SYS_CORE+61             
59d3 e3 59			dw .SPIOb            
59d5 07				db 6 + 1 
59d6 .. 00			db "SPICEH",0              
59dd				endm 
# End of macro CWHEAD
59dd			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
59dd			 
59dd cd 03 02				call spi_ce_high 
59e0			    NEXTW 
59e0 c3 b1 24			jp macro_next 
59e3				endm 
# End of macro NEXTW
59e3			 
59e3			 
59e3			.SPIOb: 
59e3			 
59e3				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
59e3 51				db WORD_SYS_CORE+61             
59e4 15 5a			dw .SPII            
59e6 05				db 4 + 1 
59e7 .. 00			db "SPIO",0              
59ec				endm 
# End of macro CWHEAD
59ec			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
59ec			 
59ec					if DEBUG_FORTH_WORDS_KEY 
59ec						DMARK "SPo" 
59ec f5				push af  
59ed 3a 01 5a			ld a, (.dmark)  
59f0 32 68 fe			ld (debug_mark),a  
59f3 3a 02 5a			ld a, (.dmark+1)  
59f6 32 69 fe			ld (debug_mark+1),a  
59f9 3a 03 5a			ld a, (.dmark+2)  
59fc 32 6a fe			ld (debug_mark+2),a  
59ff 18 03			jr .pastdmark  
5a01 ..			.dmark: db "SPo"  
5a04 f1			.pastdmark: pop af  
5a05			endm  
# End of macro DMARK
5a05						CALLMONITOR 
5a05 cd 6c fe			call debug_vector  
5a08				endm  
# End of macro CALLMONITOR
5a08					endif 
5a08					; get port 
5a08			 
5a08			 
5a08					; get byte to send 
5a08			 
5a08					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5a08 cd fb 22			call macro_dsp_valuehl 
5a0b				endm 
# End of macro FORTH_DSP_VALUEHL
5a0b			 
5a0b			;		push hl    ; u1  
5a0b			 
5a0b					; destroy value TOS 
5a0b			 
5a0b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5a0b cd b3 23			call macro_forth_dsp_pop 
5a0e				endm 
# End of macro FORTH_DSP_POP
5a0e			 
5a0e					; one value on hl get other one back 
5a0e			 
5a0e			;		pop hl   ; u2 - addr 
5a0e			 
5a0e					; TODO Send SPI byte 
5a0e			 
5a0e			;		push hl 
5a0e			;		call spi_ce_low 
5a0e			;		pop hl 
5a0e 7d					ld a, l 
5a0f cd 02 01				call spi_send_byte 
5a12			;		call spi_ce_high 
5a12			 
5a12					NEXTW 
5a12 c3 b1 24			jp macro_next 
5a15				endm 
# End of macro NEXTW
5a15			 
5a15			.SPII: 
5a15				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
5a15 52				db WORD_SYS_CORE+62             
5a16 7e 5a			dw .SESEL            
5a18 06				db 5 + 1 
5a19 .. 00			db "SPII",0              
5a1e				endm 
# End of macro CWHEAD
5a1e			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
5a1e					if DEBUG_FORTH_WORDS_KEY 
5a1e						DMARK "SPi" 
5a1e f5				push af  
5a1f 3a 33 5a			ld a, (.dmark)  
5a22 32 68 fe			ld (debug_mark),a  
5a25 3a 34 5a			ld a, (.dmark+1)  
5a28 32 69 fe			ld (debug_mark+1),a  
5a2b 3a 35 5a			ld a, (.dmark+2)  
5a2e 32 6a fe			ld (debug_mark+2),a  
5a31 18 03			jr .pastdmark  
5a33 ..			.dmark: db "SPi"  
5a36 f1			.pastdmark: pop af  
5a37			endm  
# End of macro DMARK
5a37						CALLMONITOR 
5a37 cd 6c fe			call debug_vector  
5a3a				endm  
# End of macro CALLMONITOR
5a3a					endif 
5a3a			 
5a3a					; TODO Get SPI byte 
5a3a			 
5a3a cd 29 01				call spi_read_byte 
5a3d			 
5a3d					if DEBUG_FORTH_WORDS 
5a3d						DMARK "Si2" 
5a3d f5				push af  
5a3e 3a 52 5a			ld a, (.dmark)  
5a41 32 68 fe			ld (debug_mark),a  
5a44 3a 53 5a			ld a, (.dmark+1)  
5a47 32 69 fe			ld (debug_mark+1),a  
5a4a 3a 54 5a			ld a, (.dmark+2)  
5a4d 32 6a fe			ld (debug_mark+2),a  
5a50 18 03			jr .pastdmark  
5a52 ..			.dmark: db "Si2"  
5a55 f1			.pastdmark: pop af  
5a56			endm  
# End of macro DMARK
5a56						CALLMONITOR 
5a56 cd 6c fe			call debug_vector  
5a59				endm  
# End of macro CALLMONITOR
5a59					endif 
5a59 26 00				ld h, 0 
5a5b 6f					ld l, a 
5a5c					if DEBUG_FORTH_WORDS 
5a5c						DMARK "Si3" 
5a5c f5				push af  
5a5d 3a 71 5a			ld a, (.dmark)  
5a60 32 68 fe			ld (debug_mark),a  
5a63 3a 72 5a			ld a, (.dmark+1)  
5a66 32 69 fe			ld (debug_mark+1),a  
5a69 3a 73 5a			ld a, (.dmark+2)  
5a6c 32 6a fe			ld (debug_mark+2),a  
5a6f 18 03			jr .pastdmark  
5a71 ..			.dmark: db "Si3"  
5a74 f1			.pastdmark: pop af  
5a75			endm  
# End of macro DMARK
5a75						CALLMONITOR 
5a75 cd 6c fe			call debug_vector  
5a78				endm  
# End of macro CALLMONITOR
5a78					endif 
5a78 cd 04 21				call forth_push_numhl 
5a7b			 
5a7b					NEXTW 
5a7b c3 b1 24			jp macro_next 
5a7e				endm 
# End of macro NEXTW
5a7e			 
5a7e			 
5a7e			 
5a7e			.SESEL: 
5a7e				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
5a7e 66				db WORD_SYS_CORE+82             
5a7f 27 5b			dw .CARTDEV            
5a81 05				db 4 + 1 
5a82 .. 00			db "BANK",0              
5a87				endm 
# End of macro CWHEAD
5a87			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
5a87					if DEBUG_FORTH_WORDS_KEY 
5a87						DMARK "BNK" 
5a87 f5				push af  
5a88 3a 9c 5a			ld a, (.dmark)  
5a8b 32 68 fe			ld (debug_mark),a  
5a8e 3a 9d 5a			ld a, (.dmark+1)  
5a91 32 69 fe			ld (debug_mark+1),a  
5a94 3a 9e 5a			ld a, (.dmark+2)  
5a97 32 6a fe			ld (debug_mark+2),a  
5a9a 18 03			jr .pastdmark  
5a9c ..			.dmark: db "BNK"  
5a9f f1			.pastdmark: pop af  
5aa0			endm  
# End of macro DMARK
5aa0						CALLMONITOR 
5aa0 cd 6c fe			call debug_vector  
5aa3				endm  
# End of macro CALLMONITOR
5aa3					endif 
5aa3			 
5aa3 3e ff				ld a, 255 
5aa5 32 60 fa				ld (spi_cartdev), a 
5aa8			 
5aa8					; get bank 
5aa8			 
5aa8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5aa8 cd fb 22			call macro_dsp_valuehl 
5aab				endm 
# End of macro FORTH_DSP_VALUEHL
5aab			 
5aab			;		push hl 
5aab			 
5aab					; destroy value TOS 
5aab			 
5aab					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5aab cd b3 23			call macro_forth_dsp_pop 
5aae				endm 
# End of macro FORTH_DSP_POP
5aae			 
5aae					; one value on hl get other one back 
5aae			 
5aae			;		pop hl 
5aae			 
5aae			 
5aae 0e ff				ld c, SPI_CE_HIGH 
5ab0 06 30				ld b, '0'    ; human readable bank number 
5ab2			 
5ab2 7d					ld a, l 
5ab3			 
5ab3					if DEBUG_FORTH_WORDS 
5ab3						DMARK "BNK" 
5ab3 f5				push af  
5ab4 3a c8 5a			ld a, (.dmark)  
5ab7 32 68 fe			ld (debug_mark),a  
5aba 3a c9 5a			ld a, (.dmark+1)  
5abd 32 69 fe			ld (debug_mark+1),a  
5ac0 3a ca 5a			ld a, (.dmark+2)  
5ac3 32 6a fe			ld (debug_mark+2),a  
5ac6 18 03			jr .pastdmark  
5ac8 ..			.dmark: db "BNK"  
5acb f1			.pastdmark: pop af  
5acc			endm  
# End of macro DMARK
5acc						CALLMONITOR 
5acc cd 6c fe			call debug_vector  
5acf				endm  
# End of macro CALLMONITOR
5acf					endif 
5acf			 
5acf					; active low 
5acf			 
5acf fe 00				cp 0 
5ad1 28 28				jr z, .bset 
5ad3 fe 01				cp 1 
5ad5 20 04				jr nz, .b2 
5ad7 cb 81				res 0, c 
5ad9 06 31				ld b, '1'    ; human readable bank number 
5adb fe 02		.b2:		cp 2 
5add 20 04				jr nz, .b3 
5adf cb 89				res 1, c 
5ae1 06 32				ld b, '2'    ; human readable bank number 
5ae3 fe 03		.b3:		cp 3 
5ae5 20 04				jr nz, .b4 
5ae7 cb 91				res 2, c 
5ae9 06 33				ld b, '3'    ; human readable bank number 
5aeb fe 04		.b4:		cp 4 
5aed 20 04				jr nz, .b5 
5aef cb 99				res 3, c 
5af1 06 34				ld b, '4'    ; human readable bank number 
5af3 fe 05		.b5:		cp 5 
5af5 20 04				jr nz, .bset 
5af7 cb a1				res 4, c 
5af9 06 35				ld b, '5'    ; human readable bank number 
5afb			 
5afb			.bset: 
5afb 79					ld a, c 
5afc 32 5d fa				ld (spi_device),a 
5aff 78					ld a, b 
5b00 32 5c fa				ld (spi_device_id),a 
5b03					if DEBUG_FORTH_WORDS 
5b03						DMARK "BN2" 
5b03 f5				push af  
5b04 3a 18 5b			ld a, (.dmark)  
5b07 32 68 fe			ld (debug_mark),a  
5b0a 3a 19 5b			ld a, (.dmark+1)  
5b0d 32 69 fe			ld (debug_mark+1),a  
5b10 3a 1a 5b			ld a, (.dmark+2)  
5b13 32 6a fe			ld (debug_mark+2),a  
5b16 18 03			jr .pastdmark  
5b18 ..			.dmark: db "BN2"  
5b1b f1			.pastdmark: pop af  
5b1c			endm  
# End of macro DMARK
5b1c						CALLMONITOR 
5b1c cd 6c fe			call debug_vector  
5b1f				endm  
# End of macro CALLMONITOR
5b1f					endif 
5b1f			 
5b1f					; set default SPI clk pulse time as disabled for BANK use 
5b1f			 
5b1f 3e 00				ld a, 0 
5b21 32 61 fa				ld (spi_clktime), a 
5b24			 
5b24					NEXTW 
5b24 c3 b1 24			jp macro_next 
5b27				endm 
# End of macro NEXTW
5b27			 
5b27			.CARTDEV: 
5b27				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
5b27 66				db WORD_SYS_CORE+82             
5b28 d5 5b			dw .ENDDEVICE            
5b2a 08				db 7 + 1 
5b2b .. 00			db "CARTDEV",0              
5b33				endm 
# End of macro CWHEAD
5b33			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
5b33					if DEBUG_FORTH_WORDS_KEY 
5b33						DMARK "CDV" 
5b33 f5				push af  
5b34 3a 48 5b			ld a, (.dmark)  
5b37 32 68 fe			ld (debug_mark),a  
5b3a 3a 49 5b			ld a, (.dmark+1)  
5b3d 32 69 fe			ld (debug_mark+1),a  
5b40 3a 4a 5b			ld a, (.dmark+2)  
5b43 32 6a fe			ld (debug_mark+2),a  
5b46 18 03			jr .pastdmark  
5b48 ..			.dmark: db "CDV"  
5b4b f1			.pastdmark: pop af  
5b4c			endm  
# End of macro DMARK
5b4c						CALLMONITOR 
5b4c cd 6c fe			call debug_vector  
5b4f				endm  
# End of macro CALLMONITOR
5b4f					endif 
5b4f			 
5b4f					; disable se storage bank selection 
5b4f			 
5b4f 3e ff				ld a, SPI_CE_HIGH		; ce high 
5b51 32 5d fa				ld (spi_device), a 
5b54			 
5b54					; get bank 
5b54			 
5b54					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5b54 cd fb 22			call macro_dsp_valuehl 
5b57				endm 
# End of macro FORTH_DSP_VALUEHL
5b57			 
5b57			;		push hl 
5b57			 
5b57					; destroy value TOS 
5b57			 
5b57					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5b57 cd b3 23			call macro_forth_dsp_pop 
5b5a				endm 
# End of macro FORTH_DSP_POP
5b5a			 
5b5a					; one value on hl get other one back 
5b5a			 
5b5a			;		pop hl 
5b5a			 
5b5a					; active low 
5b5a			 
5b5a 0e ff				ld c, 255 
5b5c			 
5b5c 7d					ld a, l 
5b5d					if DEBUG_FORTH_WORDS 
5b5d						DMARK "CDV" 
5b5d f5				push af  
5b5e 3a 72 5b			ld a, (.dmark)  
5b61 32 68 fe			ld (debug_mark),a  
5b64 3a 73 5b			ld a, (.dmark+1)  
5b67 32 69 fe			ld (debug_mark+1),a  
5b6a 3a 74 5b			ld a, (.dmark+2)  
5b6d 32 6a fe			ld (debug_mark+2),a  
5b70 18 03			jr .pastdmark  
5b72 ..			.dmark: db "CDV"  
5b75 f1			.pastdmark: pop af  
5b76			endm  
# End of macro DMARK
5b76						CALLMONITOR 
5b76 cd 6c fe			call debug_vector  
5b79				endm  
# End of macro CALLMONITOR
5b79					endif 
5b79 fe 00				cp 0 
5b7b 28 30				jr z, .cset 
5b7d fe 01				cp 1 
5b7f 20 02				jr nz, .c2 
5b81 cb 81				res 0, c 
5b83 fe 02		.c2:		cp 2 
5b85 20 02				jr nz, .c3 
5b87 cb 89				res 1, c 
5b89 fe 03		.c3:		cp 3 
5b8b 20 02				jr nz, .c4 
5b8d cb 91				res 2, c 
5b8f fe 04		.c4:		cp 4 
5b91 20 02				jr nz, .c5 
5b93 cb 99				res 3, c 
5b95 fe 05		.c5:		cp 5 
5b97 20 02				jr nz, .c6 
5b99 cb a1				res 4, c 
5b9b fe 06		.c6:		cp 6 
5b9d 20 02				jr nz, .c7 
5b9f cb a9				res 5, c 
5ba1 fe 07		.c7:		cp 7 
5ba3 20 02				jr nz, .c8 
5ba5 cb b1				res 6, c 
5ba7 fe 08		.c8:		cp 8 
5ba9 20 02				jr nz, .cset 
5bab cb b9				res 7, c 
5bad 79			.cset:		ld a, c 
5bae 32 60 fa				ld (spi_cartdev),a 
5bb1			 
5bb1					if DEBUG_FORTH_WORDS 
5bb1						DMARK "CD2" 
5bb1 f5				push af  
5bb2 3a c6 5b			ld a, (.dmark)  
5bb5 32 68 fe			ld (debug_mark),a  
5bb8 3a c7 5b			ld a, (.dmark+1)  
5bbb 32 69 fe			ld (debug_mark+1),a  
5bbe 3a c8 5b			ld a, (.dmark+2)  
5bc1 32 6a fe			ld (debug_mark+2),a  
5bc4 18 03			jr .pastdmark  
5bc6 ..			.dmark: db "CD2"  
5bc9 f1			.pastdmark: pop af  
5bca			endm  
# End of macro DMARK
5bca						CALLMONITOR 
5bca cd 6c fe			call debug_vector  
5bcd				endm  
# End of macro CALLMONITOR
5bcd					endif 
5bcd			 
5bcd					; set default SPI clk pulse time as 10ms for CARTDEV use 
5bcd			 
5bcd 3e 0a				ld a, $0a 
5bcf 32 61 fa				ld (spi_clktime), a 
5bd2					NEXTW 
5bd2 c3 b1 24			jp macro_next 
5bd5				endm 
# End of macro NEXTW
5bd5			endif 
5bd5			 
5bd5			.ENDDEVICE: 
5bd5			; eof 
5bd5			 
# End of file forth_words_device.asm
5bd5			 
5bd5			; var handler 
5bd5			 
5bd5			 
5bd5			.VARS: 
5bd5				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
5bd5 77				db WORD_SYS_CORE+99             
5bd6 86 5c			dw .V0            
5bd8 04				db 3 + 1 
5bd9 .. 00			db "VAR",0              
5bdd				endm 
# End of macro CWHEAD
5bdd			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
5bdd			;| 
5bdd			;| The variable name should consist of a single letter. e.g. "a" 
5bdd			;! If a full string is passed then only the first char is looked at 
5bdd			;| Any other char could exceed bounds checks!  
5bdd			 
5bdd					if DEBUG_FORTH_WORDS_KEY 
5bdd						DMARK "VAR" 
5bdd f5				push af  
5bde 3a f2 5b			ld a, (.dmark)  
5be1 32 68 fe			ld (debug_mark),a  
5be4 3a f3 5b			ld a, (.dmark+1)  
5be7 32 69 fe			ld (debug_mark+1),a  
5bea 3a f4 5b			ld a, (.dmark+2)  
5bed 32 6a fe			ld (debug_mark+2),a  
5bf0 18 03			jr .pastdmark  
5bf2 ..			.dmark: db "VAR"  
5bf5 f1			.pastdmark: pop af  
5bf6			endm  
# End of macro DMARK
5bf6						CALLMONITOR 
5bf6 cd 6c fe			call debug_vector  
5bf9				endm  
# End of macro CALLMONITOR
5bf9					endif 
5bf9			 
5bf9					FORTH_DSP_VALUEHL 
5bf9 cd fb 22			call macro_dsp_valuehl 
5bfc				endm 
# End of macro FORTH_DSP_VALUEHL
5bfc			 
5bfc 7e					ld a, (hl)    ; get first char on of the string 
5bfd			 
5bfd			 
5bfd					if DEBUG_FORTH_WORDS 
5bfd						DMARK "VR1" 
5bfd f5				push af  
5bfe 3a 12 5c			ld a, (.dmark)  
5c01 32 68 fe			ld (debug_mark),a  
5c04 3a 13 5c			ld a, (.dmark+1)  
5c07 32 69 fe			ld (debug_mark+1),a  
5c0a 3a 14 5c			ld a, (.dmark+2)  
5c0d 32 6a fe			ld (debug_mark+2),a  
5c10 18 03			jr .pastdmark  
5c12 ..			.dmark: db "VR1"  
5c15 f1			.pastdmark: pop af  
5c16			endm  
# End of macro DMARK
5c16						CALLMONITOR 
5c16 cd 6c fe			call debug_vector  
5c19				endm  
# End of macro CALLMONITOR
5c19					endif 
5c19					 
5c19 f5					push af	 
5c1a					FORTH_DSP_POP 
5c1a cd b3 23			call macro_forth_dsp_pop 
5c1d				endm 
# End of macro FORTH_DSP_POP
5c1d f1					pop af 
5c1e			 
5c1e					; convert to upper 
5c1e			 
5c1e cd 3d 13				call to_upper 
5c21					if DEBUG_FORTH_WORDS 
5c21						DMARK "Vaa" 
5c21 f5				push af  
5c22 3a 36 5c			ld a, (.dmark)  
5c25 32 68 fe			ld (debug_mark),a  
5c28 3a 37 5c			ld a, (.dmark+1)  
5c2b 32 69 fe			ld (debug_mark+1),a  
5c2e 3a 38 5c			ld a, (.dmark+2)  
5c31 32 6a fe			ld (debug_mark+2),a  
5c34 18 03			jr .pastdmark  
5c36 ..			.dmark: db "Vaa"  
5c39 f1			.pastdmark: pop af  
5c3a			endm  
# End of macro DMARK
5c3a						CALLMONITOR 
5c3a cd 6c fe			call debug_vector  
5c3d				endm  
# End of macro CALLMONITOR
5c3d					endif 
5c3d 06 41				ld b, 'A' 
5c3f 90					sub b			; set offset 
5c40					if DEBUG_FORTH_WORDS 
5c40						DMARK "Vbb" 
5c40 f5				push af  
5c41 3a 55 5c			ld a, (.dmark)  
5c44 32 68 fe			ld (debug_mark),a  
5c47 3a 56 5c			ld a, (.dmark+1)  
5c4a 32 69 fe			ld (debug_mark+1),a  
5c4d 3a 57 5c			ld a, (.dmark+2)  
5c50 32 6a fe			ld (debug_mark+2),a  
5c53 18 03			jr .pastdmark  
5c55 ..			.dmark: db "Vbb"  
5c58 f1			.pastdmark: pop af  
5c59			endm  
# End of macro DMARK
5c59						CALLMONITOR 
5c59 cd 6c fe			call debug_vector  
5c5c				endm  
# End of macro CALLMONITOR
5c5c					endif 
5c5c cb 27				sla a  
5c5e				 
5c5e					 
5c5e					if DEBUG_FORTH_WORDS 
5c5e						DMARK "VR2" 
5c5e f5				push af  
5c5f 3a 73 5c			ld a, (.dmark)  
5c62 32 68 fe			ld (debug_mark),a  
5c65 3a 74 5c			ld a, (.dmark+1)  
5c68 32 69 fe			ld (debug_mark+1),a  
5c6b 3a 75 5c			ld a, (.dmark+2)  
5c6e 32 6a fe			ld (debug_mark+2),a  
5c71 18 03			jr .pastdmark  
5c73 ..			.dmark: db "VR2"  
5c76 f1			.pastdmark: pop af  
5c77			endm  
# End of macro DMARK
5c77						CALLMONITOR 
5c77 cd 6c fe			call debug_vector  
5c7a				endm  
# End of macro CALLMONITOR
5c7a					endif 
5c7a			 
5c7a 21 f1 f9				ld hl, cli_var_array2 
5c7d cd d0 0f				call addatohl 
5c80 cd 04 21				call forth_push_numhl 
5c83			 
5c83			 
5c83				       NEXTW 
5c83 c3 b1 24			jp macro_next 
5c86				endm 
# End of macro NEXTW
5c86			.V0: 
5c86				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
5c86 78				db WORD_SYS_CORE+100             
5c87 9e 5c			dw .V0Q            
5c89 04				db 3 + 1 
5c8a .. 00			db "V0!",0              
5c8e				endm 
# End of macro CWHEAD
5c8e			;| V0! ( u1 -- )  Store value to v0  | DONE 
5c8e			 
5c8e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5c8e cd fb 22			call macro_dsp_valuehl 
5c91				endm 
# End of macro FORTH_DSP_VALUEHL
5c91			 
5c91 11 25 fa				ld de, cli_var_array 
5c94			 
5c94 eb					ex de, hl 
5c95 73					ld (hl), e 
5c96 23					inc hl 
5c97 72					ld (hl), d 
5c98			 
5c98					; destroy value TOS 
5c98			 
5c98					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5c98 cd b3 23			call macro_forth_dsp_pop 
5c9b				endm 
# End of macro FORTH_DSP_POP
5c9b			 
5c9b				       NEXTW 
5c9b c3 b1 24			jp macro_next 
5c9e				endm 
# End of macro NEXTW
5c9e			.V0Q: 
5c9e				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
5c9e 79				db WORD_SYS_CORE+101             
5c9f af 5c			dw .V1S            
5ca1 04				db 3 + 1 
5ca2 .. 00			db "V0@",0              
5ca6				endm 
# End of macro CWHEAD
5ca6			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
5ca6 2a 25 fa				ld hl, (cli_var_array) 
5ca9 cd 04 21				call forth_push_numhl 
5cac			 
5cac				       NEXTW 
5cac c3 b1 24			jp macro_next 
5caf				endm 
# End of macro NEXTW
5caf			.V1S: 
5caf				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
5caf 7a				db WORD_SYS_CORE+102             
5cb0 c7 5c			dw .V1Q            
5cb2 04				db 3 + 1 
5cb3 .. 00			db "V1!",0              
5cb7				endm 
# End of macro CWHEAD
5cb7			;| V1! ( u1 -- )  Store value to v1 | DONE 
5cb7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5cb7 cd fb 22			call macro_dsp_valuehl 
5cba				endm 
# End of macro FORTH_DSP_VALUEHL
5cba			 
5cba 11 27 fa				ld de, cli_var_array+2 
5cbd				 
5cbd eb					ex de, hl 
5cbe 73					ld (hl), e 
5cbf 23					inc hl 
5cc0 72					ld (hl), d 
5cc1			 
5cc1					; destroy value TOS 
5cc1			 
5cc1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5cc1 cd b3 23			call macro_forth_dsp_pop 
5cc4				endm 
# End of macro FORTH_DSP_POP
5cc4				       NEXTW 
5cc4 c3 b1 24			jp macro_next 
5cc7				endm 
# End of macro NEXTW
5cc7			.V1Q: 
5cc7				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
5cc7 7b				db WORD_SYS_CORE+103             
5cc8 d8 5c			dw .V2S            
5cca 04				db 3 + 1 
5ccb .. 00			db "V1@",0              
5ccf				endm 
# End of macro CWHEAD
5ccf			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
5ccf 2a 27 fa				ld hl, (cli_var_array+2) 
5cd2 cd 04 21				call forth_push_numhl 
5cd5				       NEXTW 
5cd5 c3 b1 24			jp macro_next 
5cd8				endm 
# End of macro NEXTW
5cd8			.V2S: 
5cd8				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
5cd8 7c				db WORD_SYS_CORE+104             
5cd9 f0 5c			dw .V2Q            
5cdb 04				db 3 + 1 
5cdc .. 00			db "V2!",0              
5ce0				endm 
# End of macro CWHEAD
5ce0			;| V2! ( u1 -- )  Store value to v2 | DONE 
5ce0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5ce0 cd fb 22			call macro_dsp_valuehl 
5ce3				endm 
# End of macro FORTH_DSP_VALUEHL
5ce3			 
5ce3 11 29 fa				ld de, cli_var_array+4 
5ce6				 
5ce6 eb					ex de, hl 
5ce7 73					ld (hl), e 
5ce8 23					inc hl 
5ce9 72					ld (hl), d 
5cea			 
5cea					; destroy value TOS 
5cea			 
5cea					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5cea cd b3 23			call macro_forth_dsp_pop 
5ced				endm 
# End of macro FORTH_DSP_POP
5ced				       NEXTW 
5ced c3 b1 24			jp macro_next 
5cf0				endm 
# End of macro NEXTW
5cf0			.V2Q: 
5cf0				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
5cf0 7d				db WORD_SYS_CORE+105             
5cf1 01 5d			dw .V3S            
5cf3 04				db 3 + 1 
5cf4 .. 00			db "V2@",0              
5cf8				endm 
# End of macro CWHEAD
5cf8			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
5cf8 2a 29 fa				ld hl, (cli_var_array+4) 
5cfb cd 04 21				call forth_push_numhl 
5cfe				       NEXTW 
5cfe c3 b1 24			jp macro_next 
5d01				endm 
# End of macro NEXTW
5d01			.V3S: 
5d01				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
5d01 7c				db WORD_SYS_CORE+104             
5d02 19 5d			dw .V3Q            
5d04 04				db 3 + 1 
5d05 .. 00			db "V3!",0              
5d09				endm 
# End of macro CWHEAD
5d09			;| V3! ( u1 -- )  Store value to v3 | DONE 
5d09					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5d09 cd fb 22			call macro_dsp_valuehl 
5d0c				endm 
# End of macro FORTH_DSP_VALUEHL
5d0c			 
5d0c 11 2b fa				ld de, cli_var_array+6 
5d0f				 
5d0f eb					ex de, hl 
5d10 73					ld (hl), e 
5d11 23					inc hl 
5d12 72					ld (hl), d 
5d13			 
5d13					; destroy value TOS 
5d13			 
5d13					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5d13 cd b3 23			call macro_forth_dsp_pop 
5d16				endm 
# End of macro FORTH_DSP_POP
5d16				       NEXTW 
5d16 c3 b1 24			jp macro_next 
5d19				endm 
# End of macro NEXTW
5d19			.V3Q: 
5d19				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
5d19 7d				db WORD_SYS_CORE+105             
5d1a 2a 5d			dw .END            
5d1c 04				db 3 + 1 
5d1d .. 00			db "V3@",0              
5d21				endm 
# End of macro CWHEAD
5d21			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
5d21 2a 2b fa				ld hl, (cli_var_array+6) 
5d24 cd 04 21				call forth_push_numhl 
5d27				       NEXTW 
5d27 c3 b1 24			jp macro_next 
5d2a				endm 
# End of macro NEXTW
5d2a			 
5d2a			 
5d2a			 
5d2a			 
5d2a			 
5d2a			; end of dict marker 
5d2a			 
5d2a 00			.END:    db WORD_SYS_END 
5d2b 00 00			dw 0 
5d2d 00				db 0 
5d2e			 
5d2e			; use to jp here for user dict words to save on macro expansion  
5d2e			 
5d2e			user_dict_next: 
5d2e				NEXTW 
5d2e c3 b1 24			jp macro_next 
5d31				endm 
# End of macro NEXTW
5d31			 
5d31			 
5d31			user_exec: 
5d31				;    ld hl, <word code> 
5d31				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
5d31				;    call forthexec 
5d31				;    jp user_dict_next   (NEXT) 
5d31			        ;    <word code bytes> 
5d31 eb				ex de, hl 
5d32 2a bf f4			ld hl,(os_tok_ptr) 
5d35				 
5d35				FORTH_RSP_NEXT 
5d35 cd ab 20			call macro_forth_rsp_next 
5d38				endm 
# End of macro FORTH_RSP_NEXT
5d38			 
5d38			if DEBUG_FORTH_UWORD 
5d38						DMARK "UEX" 
5d38 f5				push af  
5d39 3a 4d 5d			ld a, (.dmark)  
5d3c 32 68 fe			ld (debug_mark),a  
5d3f 3a 4e 5d			ld a, (.dmark+1)  
5d42 32 69 fe			ld (debug_mark+1),a  
5d45 3a 4f 5d			ld a, (.dmark+2)  
5d48 32 6a fe			ld (debug_mark+2),a  
5d4b 18 03			jr .pastdmark  
5d4d ..			.dmark: db "UEX"  
5d50 f1			.pastdmark: pop af  
5d51			endm  
# End of macro DMARK
5d51				CALLMONITOR 
5d51 cd 6c fe			call debug_vector  
5d54				endm  
# End of macro CALLMONITOR
5d54			endif 
5d54			 
5d54			 
5d54			 
5d54 eb				ex de, hl 
5d55 22 bf f4			ld (os_tok_ptr), hl 
5d58				 
5d58				; Don't use next - Skips the first word in uword. 
5d58			 
5d58 c3 42 25			jp exec1 
5d5b			;	NEXT 
5d5b			 
5d5b			 
5d5b			; eof 
# End of file forth_wordsv4.asm
5d5b			endif 
5d5b			;;;;;;;;;;;;;; Debug code 
5d5b			 
5d5b			 
5d5b			;if DEBUG_FORTH_PARSE 
5d5b .. 00		.nowordfound: db "No match",0 
5d64 .. 00		.compword:	db "Comparing word ",0 
5d74 .. 00		.nextwordat:	db "Next word at",0 
5d81 .. 00		.charmatch:	db "Char match",0 
5d8c			;endif 
5d8c			if DEBUG_FORTH_JP 
5d8c			.foundword:	db "Word match. Exec..",0 
5d8c			endif 
5d8c			;if DEBUG_FORTH_PUSH 
5d8c .. 00		.enddict:	db "Dict end. Push.",0 
5d9c .. 00		.push_str:	db "Pushing string",0 
5dab .. 00		.push_num:	db "Pushing number",0 
5dba .. 00		.data_sp:	db "SP:",0 
5dbe .. 00		.wordinhl:	db "Word in HL (2/0):",0 
5dd0 .. 00		.wordinde:	db "Word in DE (3/0):",0 
5de2 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
5df4			;endif 
5df4			;if DEBUG_FORTH_MALLOC 
5df4 .. 00		.push_malloc:	db "Malloc address",0 
5e03			;endif 
5e03			 
5e03			 
5e03			 
5e03			; display malloc address and current data stack pointer  
5e03			 
5e03			malloc_error: 
5e03 d5				push de 
5e04 f5				push af 
5e05 e5				push hl 
5e06 cd 9c 0d			call clear_display 
5e09 11 29 5e			ld de, .mallocerr 
5e0c 3e 00			ld a,0 
5e0e			;	ld de,os_word_scratch 
5e0e cd af 0d			call str_at_display 
5e11 3e 11			ld a, display_row_1+17 
5e13 11 68 fe			ld de, debug_mark 
5e16 cd af 0d			call str_at_display 
5e19 cd bf 0d			call update_display 
5e1c				;call break_point_state 
5e1c cd c2 79			call cin_wait 
5e1f			 
5e1f			;	ld a, ' ' 
5e1f			;	ld (os_view_disable), a 
5e1f cd 36 1a			call bp_on 
5e22 e1				pop hl 
5e23 f1				pop af 
5e24 d1				pop de	 
5e25				CALLMONITOR 
5e25 cd 6c fe			call debug_vector  
5e28				endm  
# End of macro CALLMONITOR
5e28 c9				ret 
5e29			 
5e29 .. 00		.mallocerr: 	db "Malloc Error",0 
5e36			;if DEBUG_FORTH_PUSH 
5e36			display_data_sp: 
5e36 f5				push af 
5e37			 
5e37				; see if disabled 
5e37			 
5e37			 
5e37 3a 6c fe			ld a, (debug_vector) 
5e3a fe c9			cp $C9  ; RET 
5e3c				;ld a, (os_view_disable) 
5e3c				;cp '*' 
5e3c 28 67			jr z, .skipdsp 
5e3e			 
5e3e e5				push hl 
5e3f e5				push hl 
5e40 e5			push hl 
5e41 cd 9c 0d			call clear_display 
5e44 e1			pop hl 
5e45 7c				ld a,h 
5e46 21 c3 f4			ld hl, os_word_scratch 
5e49 cd d1 12			call hexout 
5e4c e1				pop hl 
5e4d 7d				ld a,l 
5e4e 21 c5 f4			ld hl, os_word_scratch+2 
5e51 cd d1 12			call hexout 
5e54 21 c7 f4			ld hl, os_word_scratch+4 
5e57 3e 00			ld a,0 
5e59 77				ld (hl),a 
5e5a 11 c3 f4			ld de,os_word_scratch 
5e5d 3e 28				ld a, display_row_2 
5e5f cd af 0d				call str_at_display 
5e62 11 be 5d			ld de, .wordinhl 
5e65 3e 00			ld a, display_row_1 
5e67			 
5e67 cd af 0d				call str_at_display 
5e6a 11 68 fe			ld de, debug_mark 
5e6d 3e 11			ld a, display_row_1+17 
5e6f			 
5e6f cd af 0d				call str_at_display 
5e72			 
5e72				; display current data stack pointer 
5e72 11 ba 5d			ld de,.data_sp 
5e75 3e 30				ld a, display_row_2 + 8 
5e77 cd af 0d				call str_at_display 
5e7a			 
5e7a 2a eb f9			ld hl,(cli_data_sp) 
5e7d e5				push hl 
5e7e 7c				ld a,h 
5e7f 21 c3 f4			ld hl, os_word_scratch 
5e82 cd d1 12			call hexout 
5e85 e1				pop hl 
5e86 7d				ld a,l 
5e87 21 c5 f4			ld hl, os_word_scratch+2 
5e8a cd d1 12			call hexout 
5e8d 21 c7 f4			ld hl, os_word_scratch+4 
5e90 3e 00			ld a,0 
5e92 77				ld (hl),a 
5e93 11 c3 f4			ld de,os_word_scratch 
5e96 3e 33				ld a, display_row_2 + 11 
5e98 cd af 0d				call str_at_display 
5e9b			 
5e9b			 
5e9b cd bf 0d			call update_display 
5e9e cd df 0c			call delay1s 
5ea1 cd df 0c			call delay1s 
5ea4 e1				pop hl 
5ea5			.skipdsp: 
5ea5 f1				pop af 
5ea6 c9				ret 
5ea7			 
5ea7			display_data_malloc: 
5ea7			 
5ea7 f5				push af 
5ea8 e5				push hl 
5ea9 e5				push hl 
5eaa e5			push hl 
5eab cd 9c 0d			call clear_display 
5eae e1			pop hl 
5eaf 7c				ld a,h 
5eb0 21 c3 f4			ld hl, os_word_scratch 
5eb3 cd d1 12			call hexout 
5eb6 e1				pop hl 
5eb7 7d				ld a,l 
5eb8 21 c5 f4			ld hl, os_word_scratch+2 
5ebb cd d1 12			call hexout 
5ebe 21 c7 f4			ld hl, os_word_scratch+4 
5ec1 3e 00			ld a,0 
5ec3 77				ld (hl),a 
5ec4 11 c3 f4			ld de,os_word_scratch 
5ec7 3e 28				ld a, display_row_2 
5ec9 cd af 0d				call str_at_display 
5ecc 11 f4 5d			ld de, .push_malloc 
5ecf 3e 00			ld a, display_row_1 
5ed1			 
5ed1 cd af 0d				call str_at_display 
5ed4			 
5ed4				; display current data stack pointer 
5ed4 11 ba 5d			ld de,.data_sp 
5ed7 3e 30				ld a, display_row_2 + 8 
5ed9 cd af 0d				call str_at_display 
5edc			 
5edc 2a eb f9			ld hl,(cli_data_sp) 
5edf e5				push hl 
5ee0 7c				ld a,h 
5ee1 21 c3 f4			ld hl, os_word_scratch 
5ee4 cd d1 12			call hexout 
5ee7 e1				pop hl 
5ee8 7d				ld a,l 
5ee9 21 c5 f4			ld hl, os_word_scratch+2 
5eec cd d1 12			call hexout 
5eef 21 c7 f4			ld hl, os_word_scratch+4 
5ef2 3e 00			ld a,0 
5ef4 77				ld (hl),a 
5ef5 11 c3 f4			ld de,os_word_scratch 
5ef8 3e 33				ld a, display_row_2 + 11 
5efa cd af 0d				call str_at_display 
5efd			 
5efd cd bf 0d			call update_display 
5f00 cd df 0c			call delay1s 
5f03 cd df 0c			call delay1s 
5f06 e1				pop hl 
5f07 f1				pop af 
5f08 c9				ret 
5f09			;endif 
5f09			 
5f09			include "forth_autostart.asm" 
5f09			; list of commands to perform at system start up 
5f09			 
5f09			startcmds: 
5f09			;	dw test11 
5f09			;	dw test12 
5f09			;	dw test13 
5f09			;	dw test14 
5f09			;	dw test15 
5f09			;	dw test16 
5f09			;	dw test17 
5f09			;	dw ifthtest1 
5f09			;	dw ifthtest2 
5f09			;	dw ifthtest3 
5f09			;	dw mmtest1 
5f09			;	dw mmtest2 
5f09			;	dw mmtest3 
5f09			;	dw mmtest4 
5f09			;	dw mmtest5 
5f09			;	dw mmtest6 
5f09			;	dw iftest1 
5f09			;	dw iftest2 
5f09			;	dw iftest3 
5f09			;	dw looptest1 
5f09			;	dw looptest2 
5f09			;	dw test1 
5f09			;	dw test2 
5f09			;	dw test3 
5f09			;	dw test4 
5f09			;	dw game2r 
5f09			;	dw game2b1 
5f09			;	dw game2b2 
5f09			 
5f09				; start up words that are actually useful 
5f09			 
5f09			;    dw spi1 
5f09			;    dw spi2 
5f09			;    dw spi3 
5f09			;    dw spi4 
5f09			;    dw spi5 
5f09			;    dw spi6 
5f09			;    dw spi7 
5f09			; 
5f09			;    dw spi8 
5f09			;    dw spi9 
5f09			;    dw spi10 
5f09			 
5f09			; file editor 
5f09			;	dw edit1 
5f09			;	dw edit2 
5f09			;	dw edit3 
5f09			 
5f09			;	dw longread 
5f09 09 63			dw clrstack 
5f0b 3d 63			dw type 
5f0d			;	dw stest 
5f0d 62 63			dw strncpy 
5f0f			;	dw list 
5f0f c3 63			dw start1 
5f11 d3 63			dw start2 
5f13			;	dw start3 
5f13			;	dw start3b 
5f13			;	dw start3c 
5f13			 
5f13				; (unit) testing words 
5f13			 
5f13			;	dw mtesta 
5f13			;	dw mtestb 
5f13			;	dw mtestc 
5f13			;	dw mtestd 
5f13			;	dw mteste 
5f13			 
5f13				; demo/game words 
5f13			 
5f13			;        dw game3w 
5f13			;        dw game3p 
5f13			;        dw game3sc 
5f13			;        dw game3vsi 
5f13			;        dw game3vs 
5f13				 
5f13 2c 6e			dw game2b 
5f15 9a 6e			dw game2bf 
5f17 e4 6e			dw game2mba 
5f19 7a 6f			dw game2mbas 
5f1b bc 6f			dw game2mb 
5f1d			 
5f1d ed 6a			dw game1 
5f1f fe 6a			dw game1a 
5f21 60 6b			dw game1b 
5f23 95 6b			dw game1c 
5f25 cb 6b			dw game1d 
5f27 fc 6b			dw game1s 
5f29 10 6c			dw game1t 
5f2b 25 6c			dw game1f 
5f2d 59 6c			dw game1z 
5f2f 9d 6c			dw game1zz 
5f31			 
5f31 07 69			dw test5 
5f33 3f 69			dw test6 
5f35 77 69			dw test7 
5f37 8b 69			dw test8 
5f39 b7 69			dw test9 
5f3b cd 69			dw test10 
5f3d				 
5f3d 74 6d		        dw ssv5 
5f3f 58 6d		        dw ssv4 
5f41 3c 6d		        dw ssv3 
5f43 06 6d		        dw ssv2 
5f45 8d 6d		        dw ssv1 
5f47 d5 6d		        dw ssv1cpm 
5f49			;	dw keyup 
5f49			;	dw keydown 
5f49			;	dw keyleft 
5f49			;	dw keyright 
5f49			;	dw 	keyf1 
5f49			;	dw keyf2 
5f49			;	dw keyf3 
5f49			;	dw keyf4 
5f49			;	dw keyf5 
5f49			;	dw keyf6 
5f49			;	dw keyf7 
5f49			;	dw keyf8 
5f49			;	dw keyf9 
5f49			;	dw keyf10 
5f49			;	dw keyf11 
5f49			;	dw keyf12 
5f49			;	dw keytab 
5f49			;	dw keycr 
5f49			;	dw keyhome 
5f49			;	dw keyend 
5f49			;	dw keybs 
5f49 00 00			db 0, 0	 
5f4b			 
5f4b			 
5f4b			; File Editor 
5f4b			 
5f4b			; ( id - ) use 'e' to edit the displayed line 
5f4b .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
5f6c .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
5fa1			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
5fa1 .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
5fd9			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
5fd9			 
5fd9			; SPI Net support words 
5fd9			 
5fd9			; v0! = node to send to 
5fd9			; ( str count - ) 
5fd9 .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
6032			 
6032			; spiputchr ( char node - ) 
6032 .. 00		spi2:       db ": spiputchr spicel $10 spio spio ptr @ spio spiceh ; ",0 
6068			 
6068			; spigetchr ( - n ) 
6068 .. 00		spi4:       db ": spigetchr spicel $11 spio spii spiceh ; ", 0 
6093			 
6093			; getnode ( - n ) 
6093 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
60c0			 
60c0			; ( str node - )  
60c0 .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
6126			; store string ( str i - ) 
6126			 
6126			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
6126 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
617b			 
617b			; get string ( addr i -  )    TO FIX 
617b			 
617b .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
61d3			 
61d3			 
61d3			; NETCHAT (TODO) 
61d3			; Program to allow two nodes to chat with eachother 
61d3			; 
61d3			; v0 - target node 
61d3			;  
61d3			; accept input at 0,0 
61d3			; if input is string send spitype to target node 
61d3			; starting at row 2,0 , while spigetchr is not zero ->  
61d3			; 
61d3			; 
61d3			; TODO add paging of get request 
61d3			 
61d3			; ( node - ) 
61d3 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
61f2 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
624a .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
62c2			 
62c2			 
62c2			; Long read of currently open file 
62c2 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
6309			 
6309			; clear stack  
6309			 
6309 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
633d			 
633d			; type ( addr count - ) 
633d .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
6362			 
6362			; some direct memory words 
6362			; strncpy ( len t f -- t ) 
6362			 
6362 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
63c3			 
63c3 .. 00		start1:     	db ": bpon $00 bp ;",0 
63d3 .. 00		start2:     	db ": bpoff $01 bp ;",0 
63e4 .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
645f .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
64bf			 
64bf			 
64bf			; a handy word to list items on the stack 
64bf			 
64bf .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
6529			 
6529			 
6529			; test stack  
6529			; rnd8 stest 
6529			 
6529 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
65a0			 
65a0			; random malloc and free cycles 
65a0			 
65a0 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
6655			 
6655			; fixed malloc and free cycles 
6655			 
6655 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
66f8			 
66f8			; fixed double string push and drop cycle  
66f8			 
66f8 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
67ad			 
67ad			; consistent fixed string push and drop cycle  
67ad			 
67ad .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
6851			 
6851 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
6907			 
6907			;test1:		db ": aa 1 2 3 ;", 0 
6907			;test2:     	db "111 aa 888 999",0 
6907			;test3:     	db ": bb 77 ;",0 
6907			;test4:     	db "$02 $01 do i . loop bb",0 
6907			 
6907 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
693f .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
6977 .. 00		test7:     	db ": box hline vline ;",0 
698b .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
69b7 .. 00		test9:     	db ": sw $01 adsp world ;",0 
69cd .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
69f2 .. 00		test11:     	db "hello create .",0 
6a01 .. 00		test12:     	db "hello2 create .",0 
6a11			 
6a11			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
6a11			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
6a11			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
6a11			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
6a11			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
6a11			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
6a11			 
6a11			;iftest1:     	db "$0001 IF cls .",0 
6a11			;iftest2:     	db "$0000 IF cls .",0 
6a11			;iftest3:     	db "$0002 $0003 - IF cls .",0 
6a11			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
6a11			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
6a11			 
6a11			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
6a11			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
6a11			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
6a11			 
6a11			 
6a11 .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
6a35 .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
6a65 .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
6a8a .. 00		sound4: db ": cha $00 ; ",0 
6a97 .. 00		sound5: db ": chb $20 ; ",0 
6aa4 .. 00		sound6: db ": chc $40 ; ",0 
6ab1 .. 00		sound7: db ": chd $60 ; ",0 
6abe .. 00		sound8: db ": cnote $80 + + note ; ", 0 
6ad6 .. 00		sound9: db ": cvol $90 + + note ; ", 0 
6aed			 
6aed			 
6aed			 
6aed			 
6aed			; a small guess the number game 
6aed			 
6aed .. 00		game1:          db ": gsn rnd8 v1! ;",0 
6afe .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
6b60			 
6b60 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
6b95 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
6bcb .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
6bfc .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
6c10 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
6c25 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
6c59 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
6c9d			 
6c9d			; Using 'ga' save a high score across multiple runs using external storage 
6c9d			 
6c9d .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
6d06			 
6d06			 
6d06			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
6d06			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
6d06			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
6d06			 
6d06			; simple screen saver to test code memory reuse to destruction 
6d06			 
6d06 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
6d3c .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
6d58 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
6d74 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
6d8d .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
6dd5 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
6e2c			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
6e2c			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
6e2c			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
6e2c			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
6e2c			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
6e2c			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
6e2c			 
6e2c			 
6e2c			 
6e2c			; minesweeper/battleship finding game 
6e2c			; draws a game board of random ship/mine positions 
6e2c			; user enters coords to see if it hits on 
6e2c			; game ends when all are hit 
6e2c			; when hit or miss says how many may be in the area 
6e2c			 
6e2c			; setup the game board and then hide it 
6e2c .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
6e9a .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
6ee4			; prompt for where to target 
6ee4 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
6f7a .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
6f9f			; TODO see if the entered coords hits or misses pushes char hit of miss 
6f9f .. 00		game2mbht:      db ": mbckht nop ;",0 
6fae .. 00		game2mbms:      db ": mbcms nop ;",0 
6fbc			; TODO how many might be near by 
6fbc .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
7039			 
7039			; Game 3 
7039			 
7039			; Vert scroller ski game - avoid the trees! 
7039			 
7039			; v0 score (ie turns) 
7039			; v1 player pos 
7039			; v2 left wall 
7039			; v3 right wall 
7039			 
7039			; Draw side walls randomly 
7039			 
7039 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
7067			 
7067			; Draw player 
7067 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
7085			 
7085			; TODO Get Key 
7085			 
7085			; TODO Move left right 
7085			 
7085			; scroll and move walls a bit 
7085			 
7085 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
70b6			 
70b6			; main game loop 
70b6			 
70b6 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
70e2 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
7121			 
7121			; key board defs 
7121			 
7121 .. 00		keyup:       db ": keyup $05 ;",0 
712f .. 00		keydown:       db ": keydown $0a ;",0 
713f .. 00		keyleft:       db ": keyleft $0b ;",0 
714f .. 00		keyright:       db ": keyright $0c ;",0 
7160 .. 00		keyf1:       db ": keyf1 $10 ;",0 
716e .. 00		keyf2:       db ": keyf2 $11 ;",0 
717c .. 00		keyf3:       db ": keyf3 $12 ;",0 
718a .. 00		keyf4:       db ": keyf4 $13 ;",0 
7198 .. 00		keyf5:       db ": keyf5 $14 ;",0 
71a6 .. 00		keyf6:       db ": keyf6 $15 ;",0 
71b4 .. 00		keyf7:       db ": keyf7 $16 ;",0 
71c2 .. 00		keyf8:       db ": keyf8 $17 ;",0 
71d0 .. 00		keyf9:       db ": keyf9 $18 ;",0 
71de .. 00		keyf10:       db ": keyf10 $19 ;",0 
71ed .. 00		keyf11:       db ": keyf11 $1a ;",0 
71fc .. 00		keyf12:       db ": keyf12 $1b ;",0 
720b			 
720b .. 00		keytab:       db ": keytab $09 ;",0 
721a .. 00		keycr:       db ": keycr $0d ;",0 
7228 .. 00		keyhome:       db ": keyhome $0e ;",0 
7238 .. 00		keyend:       db ": keyend $0f ;",0 
7247 .. 00		keybs:       db ": keybs $08 ;",0 
7255			 
7255			   
7255			 
7255			 
7255			 
7255			; eof 
# End of file forth_autostart.asm
7255			 
7255			 
7255			 
7255			; stack over and underflow checks 
7255			 
7255			; init the words to detect the under/overflow 
7255			 
7255			chk_stk_init: 
7255				; a vague random number to check so we dont get any "lucky" hits 
7255 3e 2d			ld a, 45 
7257 6f				ld l, a 
7258 00				nop 
7259 3e 17			ld a, 23 
725b 67				ld h, a 
725c			 
725c 22 a6 f1			ld (chk_word), hl     ; the word we need to check against 
725f			 
725f			;	ld (chk_stund), hl	; stack points.... 
725f 22 fd fe			ld (chk_stovr), hl 
7262 22 e9 f9			ld (chk_ret_und), hl 
7265 22 a7 f9			ld (chk_ret_ovr), hl 
7268 22 25 f9			ld (chk_loop_ovr), hl 
726b 22 23 f7			ld (chk_data_ovr), hl 
726e c9				ret 
726f				 
726f			check_stacks: 
726f				; check all stack words 
726f			 
726f e5				push hl 
7270 d5				push de 
7271			 
7271			;	ld de,(chk_word) 
7271			;	ld hl, (chk_stund)	; stack points.... 
7271			;	if DEBUG_STK_FAULT 
7271			;		DMARK "FAa" 
7271			;		CALLMONITOR 
7271			;	endif 
7271			;	call cmp16 
7271			;	jp z, .chk_faulta 
7271			; 
7271			;	ld de, sfaultsu 
7271			;	jp .chk_fault 
7271			 
7271 2a fd fe		.chk_faulta: ld hl, (chk_stovr) 
7274 ed 5b a6 f1		ld de,(chk_word) 
7278				if DEBUG_STK_FAULT 
7278					DMARK "FAb" 
7278					CALLMONITOR 
7278				endif 
7278 cd ee 0f			call cmp16 
727b 28 06			jr z, .chk_fault1 
727d 11 1e 73			ld de, sfaultso 
7280 c3 d2 72			jp .chk_fault 
7283			.chk_fault1:  
7283 2a e9 f9			ld hl, (chk_ret_und) 
7286 ed 5b a6 f1		ld de,(chk_word) 
728a				if DEBUG_STK_FAULT 
728a					DMARK "FAU" 
728a					CALLMONITOR 
728a				endif 
728a cd ee 0f			call cmp16 
728d ca 96 72			jp z, .chk_fault2 
7290 11 2e 73			ld de, sfaultru 
7293 c3 d2 72			jp .chk_fault 
7296			.chk_fault2:  
7296 2a a7 f9			ld hl, (chk_ret_ovr) 
7299 ed 5b a6 f1		ld de,(chk_word) 
729d				if DEBUG_STK_FAULT 
729d					DMARK "FA1" 
729d					CALLMONITOR 
729d				endif 
729d cd ee 0f			call cmp16 
72a0 ca a9 72			jp z, .chk_fault3 
72a3 11 3c 73			ld de, sfaultro 
72a6 c3 d2 72			jp .chk_fault 
72a9			.chk_fault3:  
72a9 2a 25 f9			ld hl, (chk_loop_ovr) 
72ac ed 5b a6 f1		ld de,(chk_word) 
72b0				if DEBUG_STK_FAULT 
72b0					DMARK "FA2" 
72b0					CALLMONITOR 
72b0				endif 
72b0 cd ee 0f			call cmp16 
72b3 ca bc 72			jp z, .chk_fault4 
72b6 11 56 73			ld de, sfaultlo 
72b9 c3 d2 72			jp .chk_fault 
72bc			.chk_fault4:  
72bc 2a 23 f7			ld hl, (chk_data_ovr) 
72bf ed 5b a6 f1		ld de,(chk_word) 
72c3				if DEBUG_STK_FAULT 
72c3					DMARK "FA3" 
72c3					CALLMONITOR 
72c3				endif 
72c3 cd ee 0f			call cmp16 
72c6 ca cf 72			jp z, .chk_fault5 
72c9 11 70 73			ld de, sfaultdo 
72cc c3 d2 72			jp .chk_fault 
72cf			 
72cf			 
72cf			.chk_fault5:  
72cf d1				pop de 
72d0 e1				pop hl 
72d1			 
72d1 c9				ret 
72d2			 
72d2 cd 9c 0d		.chk_fault: 	call clear_display 
72d5 3e 28				ld a, display_row_2 
72d7 cd af 0d				call str_at_display 
72da 11 00 73				   ld de, .stackfault 
72dd 3e 00				ld a, display_row_1 
72df cd af 0d				call str_at_display 
72e2 11 68 fe				    ld de, debug_mark 
72e5 3e 11				ld a, display_row_1+17 
72e7 cd af 0d				call str_at_display 
72ea cd bf 0d				call update_display 
72ed			 
72ed				; prompt before entering montior for investigating issue 
72ed			 
72ed 3e 78			ld a, display_row_4 
72ef 11 f6 1d			ld de, endprog 
72f2			 
72f2 cd bf 0d			call update_display		 
72f5			 
72f5 cd 7c 20			call next_page_prompt 
72f8			 
72f8 d1				pop de 
72f9 e1				pop hl 
72fa cd 4a 1e				call monitor 
72fd c3 55 1d				jp warmstart 
7300					;jp 0 
7300					;halt 
7300			 
7300			 
7300			 
7300 .. 00		.stackfault: 	db "Stack fault:",0 
730d			 
730d .. 00		sfaultsu: 	db	"Stack under flow",0 
731e .. 00		sfaultso: 	db	"Stack over flow",0 
732e .. 00		sfaultru:	db "RTS underflow",0 
733c .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
7356 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
7370 .. 00		sfaultdo:	db "DTS overflow", 0 
737d			 
737d			 
737d			fault_dsp_under: 
737d 11 8f 73			ld de, .dsp_under 
7380 c3 3f 74			jp .show_fault 
7383			 
7383			fault_rsp_under: 
7383 11 9d 73			ld de, .rsp_under 
7386 c3 3f 74			jp .show_fault 
7389			fault_loop_under: 
7389 11 ab 73			ld de, .loop_under 
738c c3 3f 74			jp .show_fault 
738f			 
738f .. 00		.dsp_under: db "DSP Underflow",0 
739d .. 00		.rsp_under: db "RSP Underflow",0 
73ab .. 00		.loop_under: db "LOOP Underflow",0 
73ba			 
73ba			 
73ba d5			type_faultn: 	push de 
73bb e5					push hl 
73bc cd 9c 0d				call clear_display 
73bf 11 e6 73				   ld de, .typefaultn 
73c2 3e 00				ld a, display_row_1 
73c4 cd af 0d				call str_at_display 
73c7 11 68 fe				    ld de, debug_mark 
73ca 3e 11				ld a, display_row_1+17 
73cc cd af 0d				call str_at_display 
73cf cd bf 0d				call update_display 
73d2			 
73d2				; prompt before entering montior for investigating issue 
73d2			 
73d2 3e 78			ld a, display_row_4 
73d4 11 f6 1d			ld de, endprog 
73d7			 
73d7 cd bf 0d			call update_display		 
73da			 
73da cd 7c 20			call next_page_prompt 
73dd			 
73dd e5					push hl 
73de d5					push de 
73df cd 4a 1e				call monitor 
73e2 c3 55 1d				jp warmstart 
73e5 76					halt 
73e6			 
73e6			 
73e6 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
73fd			 
73fd d5			type_faults: 	push de 
73fe e5					push hl 
73ff cd 9c 0d				call clear_display 
7402 11 28 74				   ld de, .typefaults 
7405 3e 00				ld a, display_row_1 
7407 cd af 0d				call str_at_display 
740a 11 68 fe				    ld de, debug_mark 
740d 3e 11				ld a, display_row_1+17 
740f cd af 0d				call str_at_display 
7412 cd bf 0d				call update_display 
7415			 
7415				; prompt before entering montior for investigating issue 
7415			 
7415 3e 78			ld a, display_row_4 
7417 11 f6 1d			ld de, endprog 
741a			 
741a cd bf 0d			call update_display		 
741d			 
741d cd 7c 20			call next_page_prompt 
7420			 
7420 e1					pop hl 
7421 d1					pop de 
7422 cd 4a 1e				call monitor 
7425 c3 55 1d				jp warmstart 
7428			 
7428			 
7428 .. 00		.typefaults: db "STR Type Expected TOS!",0 
743f			 
743f			.show_fault: 	 
743f d5					push de 
7440 cd 9c 0d				call clear_display 
7443 d1					pop de 
7444 3e 00				ld a, display_row_1 
7446 cd af 0d				call str_at_display 
7449 11 68 fe				    ld de, debug_mark 
744c 3e 11				ld a, display_row_1+17 
744e cd af 0d				call str_at_display 
7451 cd bf 0d				call update_display 
7454			 
7454				; prompt before entering montior for investigating issue 
7454			 
7454 3e 78			ld a, display_row_4 
7456 11 f6 1d			ld de, endprog 
7459			 
7459 cd bf 0d			call update_display		 
745c			 
745c cd 7c 20			call next_page_prompt 
745f			 
745f e1					pop hl 
7460 d1					pop de 
7461 cd 4a 1e				call monitor 
7464			; do a dump to cli and not warmstart so we preserve all of the uwords.  
7464			; TODO Make optional fault restart to cli or warm boot? 
7464					;jp warmstart 
7464 c3 9d 1d				jp cli 
7467 76					halt 
7468			 
7468			; handle the auto run of code from files in storage 
7468			 
7468			 
7468			include "forth_startup.asm" 
7468			; Which startup method to use? 
7468			; 
7468			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
7468			; followed by loading of a list of scripts in eeprom 
7468			 
7468			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
7468			; from eeprom 
7468			 
7468			; Select with define in main stubs 
7468			 
7468			if STARTUP_V1 
7468				include "forth_startupv1.asm" 
7468			endif 
7468			if STARTUP_V2 
7468				include "forth_startupv2.asm" 
7468			; Version 2 of the startup  
7468			;  
7468			; Auto load any files in bank 1 that start with a '*' 
7468			; If no se storage then revert to using eprom 
7468			 
7468			 
7468			if STORAGE_SE = 0 
7468			 
7468			sprompt1: db "Startup load...",0 
7468			sprompt2: db "Run? 1=No *=End #=All",0 
7468			 
7468			 
7468			 
7468			 
7468			forth_startup: 
7468				ld hl, startcmds 
7468				ld a, 0 
7468				ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
7468			 
7468			.start1:	push hl 
7468				call clear_display 
7468				ld de, sprompt1 
7468			        ld a, display_row_1 
7468				call str_at_display 
7468				ld de, sprompt2 
7468			        ld a, display_row_2 
7468				call str_at_display 
7468				pop hl 
7468				push hl 
7468				ld e,(hl) 
7468				inc hl 
7468				ld d,(hl) 
7468			        ld a, display_row_3 
7468				call str_at_display 
7468				call update_display 
7468			 
7468			 
7468				ld a, (os_last_cmd) 
7468				cp 0 
7468				jr z, .startprompt 
7468				call delay250ms 
7468				jr .startdo 
7468				 
7468				 
7468			 
7468			.startprompt: 
7468			 
7468				ld a,display_row_4 + display_cols - 1 
7468			        ld de, endprg 
7468				call str_at_display 
7468				call update_display 
7468				call delay1s 
7468				call cin_wait 
7468						 
7468				cp '*' 
7468				jr z, .startupend1 
7468				cp '#' 
7468				jr nz, .startno 
7468				ld a, 1 
7468				ld (os_last_cmd),a 
7468				jr .startdo 
7468			.startno:	cp '1' 
7468				jr z,.startnxt  
7468			 
7468				; exec startup line 
7468			.startdo:	 
7468				pop hl 
7468				push hl 
7468				 
7468				ld e,(hl) 
7468				inc hl 
7468				ld d,(hl) 
7468				ex de,hl 
7468			 
7468				push hl 
7468			 
7468				ld a, 0 
7468				;ld a, FORTH_END_BUFFER 
7468				call strlent 
7468				inc hl   ; include zero term to copy 
7468				ld b,0 
7468				ld c,l 
7468				pop hl 
7468				ld de, scratch 
7468				ldir 
7468			 
7468			 
7468				ld hl, scratch 
7468				call forthparse 
7468				call forthexec 
7468				call forthexec_cleanup 
7468			 
7468				ld a, display_row_4 
7468				ld de, endprog 
7468			 
7468				call update_display		 
7468			 
7468				ld a, (os_last_cmd) 
7468				cp 0 
7468				jr nz, .startnxt 
7468				call next_page_prompt 
7468			        call clear_display 
7468				call update_display		 
7468			 
7468				; move onto next startup line? 
7468			.startnxt: 
7468			 
7468				call delay250ms 
7468				pop hl 
7468			 
7468				inc hl 
7468				inc hl 
7468			 
7468				push hl 
7468				ld e, (hl) 
7468				inc hl 
7468				ld d, (hl) 
7468				pop hl 
7468				; TODO replace 0 test 
7468			 
7468				ex de, hl 
7468				call ishlzero 
7468			;	ld a,e 
7468			;	add d 
7468			;	cp 0    ; any left to do? 
7468				ex de, hl 
7468				jp nz, .start1 
7468				jr .startupend 
7468			 
7468			.startupend1: pop hl 
7468			.startupend: 
7468			 
7468				call clear_display 
7468				call update_display 
7468				ret 
7468			endif 
7468			 
7468			 
7468			if STORAGE_SE 
7468			 
7468			;sprompt3: db "Loading from start-up file:",0 
7468 .. 00		sprompt3: db "  Searching...",0 
7477			;sprompt4: db "(Any key to stop)",0 
7477			 
7477			 
7477			forth_autoload: 
7477			 
7477				; load block 0 of store 1 
7477				 
7477 3e fe			ld a, $fe      ; bit 0 clear 
7479 32 5d fa			ld (spi_device), a 
747c			 
747c cd 17 05			call storage_get_block_0 
747f			 
747f 3a 98 fa			ld a, (store_page+STORE_0_AUTOFILE) 
7482			 
7482 fe 00			cp 0 
7484 c8				ret z     ; auto start not enabled 
7485			 
7485 cd 9c 0d			call clear_display 
7488			 
7488				; set bank 
7488			 
7488 3a 9a fa				ld a, (store_page+STORE_0_BANKRUN) 
748b 32 5d fa				ld (spi_device), a 
748e			 
748e			 
748e				; generate a directory of bank 1 and search for flagged files 
748e			 
748e					if DEBUG_FORTH_WORDS_KEY 
748e						DMARK "DIR" 
748e f5				push af  
748f 3a a3 74			ld a, (.dmark)  
7492 32 68 fe			ld (debug_mark),a  
7495 3a a4 74			ld a, (.dmark+1)  
7498 32 69 fe			ld (debug_mark+1),a  
749b 3a a5 74			ld a, (.dmark+2)  
749e 32 6a fe			ld (debug_mark+2),a  
74a1 18 03			jr .pastdmark  
74a3 ..			.dmark: db "DIR"  
74a6 f1			.pastdmark: pop af  
74a7			endm  
# End of macro DMARK
74a7						CALLMONITOR 
74a7 cd 6c fe			call debug_vector  
74aa				endm  
# End of macro CALLMONITOR
74aa					endif 
74aa			 
74aa cd 17 05			call storage_get_block_0 
74ad			 
74ad 21 77 fa			ld hl, store_page     ; get current id count 
74b0 46				ld b, (hl) 
74b1 0e 00			ld c, 0    ; count of files   
74b3					if DEBUG_FORTH_WORDS 
74b3						DMARK "DI1" 
74b3 f5				push af  
74b4 3a c8 74			ld a, (.dmark)  
74b7 32 68 fe			ld (debug_mark),a  
74ba 3a c9 74			ld a, (.dmark+1)  
74bd 32 69 fe			ld (debug_mark+1),a  
74c0 3a ca 74			ld a, (.dmark+2)  
74c3 32 6a fe			ld (debug_mark+2),a  
74c6 18 03			jr .pastdmark  
74c8 ..			.dmark: db "DI1"  
74cb f1			.pastdmark: pop af  
74cc			endm  
# End of macro DMARK
74cc						CALLMONITOR 
74cc cd 6c fe			call debug_vector  
74cf				endm  
# End of macro CALLMONITOR
74cf					endif 
74cf			 
74cf				; check for empty drive 
74cf			 
74cf 3e 00			ld a, 0 
74d1 b8				cp b 
74d2 ca 1f 75			jp z, .dirdone 
74d5			 
74d5				; for each of the current ids do a search for them and if found push to stack 
74d5			 
74d5 c5			.diritem:	push bc 
74d6 21 40 00				ld hl, STORE_BLOCK_PHY 
74d9 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
74db 58					ld e,b 
74dc			 
74dc d5					push de 
74dd e5					push hl 
74de cd 9c 0d			call clear_display 
74e1 3e 32			ld a, display_row_2 + 10 
74e3 11 68 74			ld de, sprompt3 
74e6 cd af 0d			call str_at_display 
74e9 cd f3 0c			call active 
74ec eb				ex de, hl 
74ed 3e 2f			ld a, display_row_2 + 7 
74ef cd af 0d			call str_at_display 
74f2 cd bf 0d			call update_display 
74f5 e1				pop hl 
74f6 d1				pop de 
74f7			 
74f7			;		if DEBUG_FORTH_WORDS 
74f7			;			DMARK "DI2" 
74f7			;			CALLMONITOR 
74f7			;		endif 
74f7			 
74f7 cd 99 07				call storage_findnextid 
74fa			 
74fa			;		if DEBUG_FORTH_WORDS 
74fa			;			DMARK "DI3" 
74fa			;			CALLMONITOR 
74fa			;		endif 
74fa			 
74fa					; if found hl will be non zero 
74fa			 
74fa cd f9 0f				call ishlzero 
74fd			;		ld a, l 
74fd			;		add h 
74fd			; 
74fd			;		cp 0 
74fd 28 1d				jr z, .dirnotfound 
74ff			 
74ff					; increase count 
74ff			 
74ff c1					pop bc	 
7500 0c					inc c 
7501 c5					push bc 
7502					 
7502			 
7502					; get file header and push the file name 
7502			 
7502 11 77 fa				ld de, store_page 
7505 cd 66 04				call storage_read_block 
7508			 
7508					; push file id to stack 
7508				 
7508			 
7508					; is this a file we want to run? 
7508			 
7508 21 7a fa				ld hl, store_page+3 
750b 7e					ld a,(hl) 
750c fe 2a				cp '*' 
750e 20 0c				jr nz,  .dirnotfound 
7510					 
7510			 
7510			 
7510 3a 77 fa				ld a, (store_page) 
7513 d5					push de 
7514 e5					push hl 
7515 c5					push bc 
7516 cd 42 75				call .autorunf 
7519 c1					pop bc 
751a e1					pop hl 
751b d1					pop de 
751c			 
751c			 
751c			 
751c				; save this extent 
751c			 
751c					; push file name 
751c			;display file name to run 
751c			 
751c			;		ld hl, store_page+3 
751c			;		if DEBUG_FORTH_WORDS 
751c			;			DMARK "DI5" 
751c			;			CALLMONITOR 
751c			;		endif 
751c			; 
751c			;		 
751c			; 
751c			;		call forth_push_str 
751c			;		if DEBUG_FORTH_WORDS 
751c			;			DMARK "DI6" 
751c			;			CALLMONITOR 
751c			;		endif 
751c			.dirnotfound: 
751c c1					pop bc     
751d 10 b6				djnz .diritem 
751f				 
751f			.dirdone:	 
751f					if DEBUG_FORTH_WORDS 
751f						DMARK "DI7" 
751f f5				push af  
7520 3a 34 75			ld a, (.dmark)  
7523 32 68 fe			ld (debug_mark),a  
7526 3a 35 75			ld a, (.dmark+1)  
7529 32 69 fe			ld (debug_mark+1),a  
752c 3a 36 75			ld a, (.dmark+2)  
752f 32 6a fe			ld (debug_mark+2),a  
7532 18 03			jr .pastdmark  
7534 ..			.dmark: db "DI7"  
7537 f1			.pastdmark: pop af  
7538			endm  
# End of macro DMARK
7538						CALLMONITOR 
7538 cd 6c fe			call debug_vector  
753b				endm  
# End of macro CALLMONITOR
753b					endif 
753b			 
753b cd 9c 0d				call clear_display 
753e cd bf 0d				call update_display 
7541			 
7541 c9					ret 
7542			 
7542			 
7542			 
7542			 
7542			 
7542			.autorunf: 
7542			 
7542			 
7542				; get file id to load from and get the file name to display 
7542			 
7542			;		ld a, (store_page+STORE_0_FILERUN) 
7542			 
7542 2e 00				ld l, 0 
7544 67					ld h, a 
7545 11 77 fa				ld de, store_page 
7548			 
7548					if DEBUG_FORTH_WORDS 
7548						DMARK "ASp" 
7548 f5				push af  
7549 3a 5d 75			ld a, (.dmark)  
754c 32 68 fe			ld (debug_mark),a  
754f 3a 5e 75			ld a, (.dmark+1)  
7552 32 69 fe			ld (debug_mark+1),a  
7555 3a 5f 75			ld a, (.dmark+2)  
7558 32 6a fe			ld (debug_mark+2),a  
755b 18 03			jr .pastdmark  
755d ..			.dmark: db "ASp"  
7560 f1			.pastdmark: pop af  
7561			endm  
# End of macro DMARK
7561						CALLMONITOR 
7561 cd 6c fe			call debug_vector  
7564				endm  
# End of macro CALLMONITOR
7564					endif 
7564 cd bf 09				call storage_read 
7567			 
7567					if DEBUG_FORTH_WORDS 
7567						DMARK "ASr" 
7567 f5				push af  
7568 3a 7c 75			ld a, (.dmark)  
756b 32 68 fe			ld (debug_mark),a  
756e 3a 7d 75			ld a, (.dmark+1)  
7571 32 69 fe			ld (debug_mark+1),a  
7574 3a 7e 75			ld a, (.dmark+2)  
7577 32 6a fe			ld (debug_mark+2),a  
757a 18 03			jr .pastdmark  
757c ..			.dmark: db "ASr"  
757f f1			.pastdmark: pop af  
7580			endm  
# End of macro DMARK
7580						CALLMONITOR 
7580 cd 6c fe			call debug_vector  
7583				endm  
# End of macro CALLMONITOR
7583					endif 
7583			 
7583 cd f9 0f				call ishlzero 
7586 c8					ret z             ; file not found 
7587			 
7587					; display file name we are loading 
7587			 
7587 cd 9c 0d				call clear_display 
758a			 
758a 3e 32				ld a, display_row_2 + 10 
758c 11 7a fa				ld de, store_page+3 
758f cd af 0d				call str_at_display 
7592				 
7592			; 
7592			 
7592			;	ld a, display_row_1+5 
7592			;	ld de, sprompt3 
7592			;	call str_at_display 
7592			;	ld a, display_row_2+7 
7592			;	call active 
7592			;	ex de, hl 
7592			;;	ld de, sprompt4 
7592			;	call str_at_display 
7592			; 
7592 cd bf 0d			call update_display 
7595			 
7595			;	call cin_wait 
7595			;	cp 'n' 
7595			;	ret z 
7595			;	cp 'N' 
7595			;	ret z 
7595			 
7595			;	call delay1s 
7595			 
7595 3a 79 fa			ld a, (store_page+2) 
7598 32 66 fa			ld (store_openmaxext), a    ; save count of ext 
759b 3e 01			ld a, 1  
759d 32 67 fa			ld (store_openext), a    ; save count of ext 
75a0			 
75a0			.autof: 
75a0				; begin to read a line from file 
75a0			 
75a0 21 e5 f4			ld hl, os_cli_cmd 
75a3 22 e3 f6			ld (os_var_array), hl     ; somewhere to hold the line construction pointer 
75a6			  
75a6			.readext: 
75a6 3a 67 fa			ld a, (store_openext) 
75a9 6f				ld l , a 
75aa				 
75aa 3a 77 fa			ld a, (store_page) 
75ad 67				ld h, a	 
75ae 11 77 fa			ld de, store_page 
75b1					if DEBUG_FORTH_WORDS 
75b1						DMARK "ASl" 
75b1 f5				push af  
75b2 3a c6 75			ld a, (.dmark)  
75b5 32 68 fe			ld (debug_mark),a  
75b8 3a c7 75			ld a, (.dmark+1)  
75bb 32 69 fe			ld (debug_mark+1),a  
75be 3a c8 75			ld a, (.dmark+2)  
75c1 32 6a fe			ld (debug_mark+2),a  
75c4 18 03			jr .pastdmark  
75c6 ..			.dmark: db "ASl"  
75c9 f1			.pastdmark: pop af  
75ca			endm  
# End of macro DMARK
75ca						CALLMONITOR 
75ca cd 6c fe			call debug_vector  
75cd				endm  
# End of macro CALLMONITOR
75cd					endif 
75cd cd bf 09				call storage_read 
75d0 cd f9 0f			call ishlzero 
75d3 c8				ret z 
75d4			 
75d4			; TODO copy to exec buffer 
75d4			; check (store_readcont) if 0 then exec, if not then load on the end of the exec buffer until 0 
75d4			 
75d4				; copy the record buffer to the cli buffer 
75d4			 
75d4 ed 5b e3 f6		ld de, (os_var_array) 
75d8 21 79 fa			ld hl, store_page+2 
75db			;	ex de, hl 
75db 01 3e 00			ld bc, STORE_BLOCK_PHY-2   ; two for the file ids 
75de ed b0			ldir 
75e0 ed 53 e3 f6		ld (os_var_array), de 
75e4				 
75e4 3a 67 fa			ld a, (store_openext) 
75e7 3c				inc a 
75e8 32 67 fa			ld (store_openext), a    ; save count of ext 
75eb			 
75eb			 
75eb			; check (store_readcont) if 0 then exec, if not then load on the end of the exec buffer until 0 
75eb				 
75eb 3a 6a fa			ld a, (store_readcont) 
75ee fe 00			cp 0 
75f0 20 b4			jr nz, .readext 
75f2			 
75f2			;	jr z, .autoend 
75f2			 
75f2					if DEBUG_FORTH_WORDS 
75f2						DMARK "ASc" 
75f2 f5				push af  
75f3 3a 07 76			ld a, (.dmark)  
75f6 32 68 fe			ld (debug_mark),a  
75f9 3a 08 76			ld a, (.dmark+1)  
75fc 32 69 fe			ld (debug_mark+1),a  
75ff 3a 09 76			ld a, (.dmark+2)  
7602 32 6a fe			ld (debug_mark+2),a  
7605 18 03			jr .pastdmark  
7607 ..			.dmark: db "ASc"  
760a f1			.pastdmark: pop af  
760b			endm  
# End of macro DMARK
760b						CALLMONITOR 
760b cd 6c fe			call debug_vector  
760e				endm  
# End of macro CALLMONITOR
760e					endif 
760e e5				push hl	 
760f d5				push de 
7610 cd f3 0c			call active 
7613 eb				ex de, hl 
7614 3e 2f			ld a, display_row_2 + 7 
7616 cd af 0d			call str_at_display 
7619			 
7619 cd bf 0d			call update_display 
761c d1				pop de  
761d e1				pop hl 
761e			;	call delay250ms 
761e			 
761e			 
761e			 
761e			 
761e			.autoexec: 
761e			 
761e			 
761e 21 e5 f4			ld hl, os_cli_cmd 
7621					if DEBUG_FORTH_WORDS 
7621						DMARK "ASx" 
7621 f5				push af  
7622 3a 36 76			ld a, (.dmark)  
7625 32 68 fe			ld (debug_mark),a  
7628 3a 37 76			ld a, (.dmark+1)  
762b 32 69 fe			ld (debug_mark+1),a  
762e 3a 38 76			ld a, (.dmark+2)  
7631 32 6a fe			ld (debug_mark+2),a  
7634 18 03			jr .pastdmark  
7636 ..			.dmark: db "ASx"  
7639 f1			.pastdmark: pop af  
763a			endm  
# End of macro DMARK
763a						CALLMONITOR 
763a cd 6c fe			call debug_vector  
763d				endm  
# End of macro CALLMONITOR
763d					endif 
763d cd ff 24			call forthparse 
7640 cd 3f 25			call forthexec 
7643 cd 51 24			call forthexec_cleanup 
7646			 
7646			 
7646			 
7646 c3 a0 75			jp .autof 
7649			;.autofdone: 
7649			; 
7649			;		if DEBUG_FORTH_WORDS 
7649			;			DMARK "ASx" 
7649			;			CALLMONITOR 
7649			;		endif 
7649			;;	call clear_display 
7649			;	ret 
7649			 
7649			 
7649			 
7649			endif 
# End of file forth_startupv2.asm
7649			endif 
7649			 
# End of file forth_startup.asm
7649			 
7649			; eof 
# End of file forth_kernel.asm
7649			;include "nascombasic.asm" 
7649			 
7649			 
7649			; find out where the code ends if loaded into RAM (for SC114) 
7649			;endofcode:  
7649			;	nop 
7649			 
7649			 
7649			; jump to nmi vector 
7649			 
7649			init_nmi: 
7649 3e c9			ld a, $c9   ; RET 
764b 32 6f fe			ld (nmi_vector), a 
764e c9				ret 
764f			nmi: 
764f e5				push hl 
7650 d5				push de 
7651 c5				push bc 
7652 f5				push af 
7653 cd 6f fe			call nmi_vector 
7656 f5				push af 
7657 c5				push bc 
7658 d5				push de 
7659 e5				push hl 
765a ed 4d			reti 
765c			 
765c			 
765c			; eof 
765c			 
# End of file main.asm
765c			include "firmware_lcd_4x40.asm" 
765c			; **********************************************************************  
765c			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
765c			; **********************************************************************  
765c			;  
765c			; **  Written as a Small Computer Monitor App  
765c			; **  www.scc.me.uk  
765c			;  
765c			; History  
765c			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
765c			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
765c			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
765c			;  
765c			; **********************************************************************  
765c			;  
765c			; This program is an example of one of the methods of interfacing an   
765c			; alphanumeric LCD module.   
765c			;  
765c			; In this example the display is connected to either a Z80 PIO or a   
765c			; simple 8-bit output port.   
765c			;  
765c			; This interfacing method uses 4-bit data mode and uses time delays  
765c			; rather than polling the display's ready status. As a result the   
765c			; interface only requires 6 simple output lines:  
765c			;   Output bit 0 = not used  
765c			;   Output bit 1 = not used  
765c			;   Output bit 2 = RS         High = data, Low = instruction  
765c			;   Output bit 3 = E          Active high  
765c			;   Output bit 4 = DB4  
765c			;   Output bit 5 = DB5  
765c			;   Output bit 6 = DB6  
765c			;   Output bit 7 = DB7  
765c			; Display's R/W is connected to 0v so it is always in write mode  
765c			;  
765c			; This set up should work with any system supporting the RC2014 bus  
765c			  
765c			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
765c			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
765c			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
765c			;  
765c			; **********************************************************************  
765c			  
765c			; Additonal for 4x40. E1 and E2 instead of just E   
765c			; TODO swipe vidout signal on port a to activate E2  
765c			  
765c			; **********************************************************************  
765c			; **  Constants  
765c			; **********************************************************************  
765c			; LCD constants required by LCD support module  
765c			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
765c			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
765c			kLCDBitE:   EQU 3              ;Port bit for LCD E signal             
765c			kLCDBitE2:   EQU 0              ;Port bit for LCD E2 signal            VIDOUT  
765c			; TODO Decide which E is being set  
765c			kLCDWidth:  EQU display_cols             ;Width in characters  
765c			  
765c			; **********************************************************************  
765c			; **  Code library usage  
765c			; **********************************************************************  
765c			  
765c			; send character to current cursor position  
765c			; wraps and/or scrolls screen automatically  
765c			  
765c			  
765c			  
765c			lcd_init:  
765c			  
765c			; SCMonAPI functions used  
765c			  
765c			; Alphanumeric LCD functions used  
765c			; no need to specify specific functions for this module  
765c			  
765c 3e cf		            LD   A, 11001111b  
765e d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
7660 3e 00		            LD   A, 00000000b  
7662 d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
7664			  
7664			; Initialise alphanumeric LCD module  
7664 3e 00				ld a, 0  
7666 32 c8 fb				ld (display_lcde1e2), a  
7669 cd ea 76		            CALL fLCD_Init      ;Initialise LCD module  
766c 3e 01				ld a, 1  
766e 32 c8 fb				ld (display_lcde1e2), a  
7671 cd ea 76		            CALL fLCD_Init      ;Initialise LCD module  
7674			  
7674 c9				ret  
7675			  
7675			;  
7675			;;  
7675			; lcd functions  
7675			;  
7675			;  
7675			  
7675			; what is at cursor position   
7675			  
7675			;get_cursor:	ld de, (cursor_row)   ;  row + col  
7675			;		call curptr  
7675			;		ret  
7675			  
7675			  
7675			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
7675			  
7675			curptr:  
7675 c5				push bc  
7676 21 ae fd			ld hl, display_fb0  
7679			cpr:	  
7679				; loop for cursor whole row  
7679 0e 28			ld c, display_cols  
767b 23			cpr1:	inc hl  
767c 0d				dec c  
767d 20 fc			jr nz, cpr1  
767f 05				dec b  
7680 20 f7			jr nz, cpr  
7682			  
7682				; add col	  
7682			  
7682 23			cpr2:	inc hl  
7683 1d				dec e  
7684 20 fc			jr nz, cpr2  
7686			  
7686 c1				pop bc  
7687 c9				ret  
7688				  
7688			  
7688			  
7688			  
7688			  
7688			; write the frame buffer given in hl to hardware   
7688 22 c6 fb		write_display: ld (display_write_tmp), hl 	   
768b 3e 00			ld a, kLCD_Line1  
768d cd 97 77		            CALL fLCD_Pos       ;Position cursor to location in A  
7690 06 28			ld b, display_cols  
7692 ed 5b c6 fb		ld de, (display_write_tmp)  
7696 cd e2 76			call write_len_string  
7699				  
7699				  
7699 2a c6 fb			ld hl, (display_write_tmp)  
769c 11 28 00			ld de, display_cols  
769f 19				add hl,de  
76a0 22 c6 fb			ld (display_write_tmp),hl  
76a3			  
76a3				  
76a3 3e 28			ld a, kLCD_Line2  
76a5 cd 97 77		            CALL fLCD_Pos       ;Position cursor to location in A  
76a8 06 28			ld b, display_cols  
76aa ed 5b c6 fb		ld de, (display_write_tmp)  
76ae cd e2 76			call write_len_string  
76b1				  
76b1 2a c6 fb			ld hl, (display_write_tmp)  
76b4 11 28 00			ld de, display_cols  
76b7 19				add hl,de  
76b8 22 c6 fb			ld (display_write_tmp),hl  
76bb			  
76bb				  
76bb 3e 50			ld a, kLCD_Line3  
76bd cd 97 77		            CALL fLCD_Pos       ;Position cursor to location in A  
76c0 06 28			ld b, display_cols  
76c2 ed 5b c6 fb		ld de, (display_write_tmp)  
76c6 cd e2 76			call write_len_string  
76c9				  
76c9 2a c6 fb			ld hl, (display_write_tmp)  
76cc 11 28 00			ld de, display_cols  
76cf 19				add hl,de  
76d0 22 c6 fb			ld (display_write_tmp),hl  
76d3			  
76d3				  
76d3 3e 78			ld a, kLCD_Line4  
76d5 cd 97 77		            CALL fLCD_Pos       ;Position cursor to location in A  
76d8 06 28			ld b, display_cols  
76da ed 5b c6 fb		ld de, (display_write_tmp)  
76de cd e2 76			call write_len_string  
76e1 c9					ret  
76e2				  
76e2				; write out a fixed length string given in b from de  
76e2			  
76e2 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
76e3 cd 4f 77		            CALL fLCD_Data      ;Write character to display  
76e6 13				inc de  
76e7 10 f9			djnz write_len_string  
76e9 c9				ret  
76ea			  
76ea			; Some other things to do  
76ea			;            LD   A, kLCD_Clear ;Display clear  
76ea			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
76ea			;            LD   A, kLCD_Under ;Display on with underscore cursor  
76ea			;            LD   A, kLCD_On     ;Display on with no cursor  
76ea			;            ;LD   A, kLCD_Off   ;Display off  
76ea			;            CALL fLCD_Inst      ;Send instruction to display  
76ea			;  
76ea			;  
76ea			;            halt  
76ea			;  
76ea			;  
76ea			;MsgHello:   DB  "Hello World!",0  
76ea			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
76ea			  
76ea			; Custom characters 5 pixels wide by 8 pixels high  
76ea			; Up to 8 custom characters can be defined  
76ea			;BitMaps:      
76ea			;; Character 0x00 = Battery icon  
76ea			;            DB  01110b  
76ea			;            DB  11011b  
76ea			;            DB  10001b  
76ea			;            DB  10001b  
76ea			;            DB  11111b  
76ea			;            DB  11111b  
76ea			;            DB  11111b  
76ea			;            DB  11111b  
76ea			;; Character 0x01 = Bluetooth icon  
76ea			;            DB  01100b  
76ea			;            DB  01010b  
76ea			;            DB  11100b  
76ea			;            DB  01000b  
76ea			;            DB  11100b  
76ea			;            DB  01010b  
76ea			;            DB  01100b  
76ea			;            DB  00000b  
76ea			;  
76ea			  
76ea			  
76ea			; **********************************************************************  
76ea			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
76ea			; **********************************************************************  
76ea			;  
76ea			; **  Written as a Small Computer Monitor App   
76ea			; **  Version 0.1 SCC 2018-05-16  
76ea			; **  www.scc.me.uk  
76ea			;  
76ea			; **********************************************************************  
76ea			;  
76ea			; This module provides support for alphanumeric LCD modules using with  
76ea			; *  HD44780 (or compatible) controller  
76ea			; *  5 x 7 pixel fonts  
76ea			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
76ea			; *  Interface via six digital outputs to the display (see below)  
76ea			;  
76ea			; LCD module pinout:  
76ea			;   1  Vss   0v supply  
76ea			;   2  Vdd   5v supply  
76ea			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
76ea			;   4  RS    High = data, Low = instruction  
76ea			;   5  R/W   High = Read, Low = Write  
76ea			;   6  E     Enable signal (active high)  
76ea			;   7  DB0   Data bit 0  
76ea			;   8  DB1   Data bit 1  
76ea			;   9  DB2   Data bit 2  
76ea			;  10  DB3   Data bit 3  
76ea			;  11  DB4   Data bit 4  
76ea			;  12  DB5   Data bit 5  
76ea			;  13  DB6   Data bit 6  
76ea			;  14  DB7   Data bit 7  
76ea			;  15  A     Backlight anode (+)  
76ea			;  16  K     Backlight cathode (-)  
76ea			;  
76ea			; This interfacing method uses 4-bit data mode and uses time delays  
76ea			; rather than polling the display's ready status. As a result the   
76ea			; interface only requires 6 simple output lines:  
76ea			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
76ea			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
76ea			;   LCD DB4 = Microcomputer output port bit 4  
76ea			;   LCD DB5 = Microcomputer output port bit 5  
76ea			;   LCD DB6 = Microcomputer output port bit 6  
76ea			;   LCD DB7 = Microcomputer output port bit 7  
76ea			; Display's R/W is connected to 0v so it is always in write mode  
76ea			; All 6 connections must be on the same port address <kLCDPrt>  
76ea			; This method also allows a decent length of cable from micro to LCD  
76ea			;  
76ea			; **********************************************************************  
76ea			;  
76ea			; To include the code for any given function provided by this module,   
76ea			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
76ea			; the parent source file.  
76ea			; For example:  #REQUIRES   uHexPrefix  
76ea			;  
76ea			; Also #INCLUDE this file at some point after the #REQUIRES statements  
76ea			; in the parent source file.  
76ea			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
76ea			;  
76ea			; These are the function names provided by this module:  
76ea			; fLCD_Init                     ;Initialise LCD  
76ea			; fLCD_Inst                     ;Send instruction to LCD  
76ea			; fLCD_Data                     ;Send data byte to LCD  
76ea			; fLCD_Pos                      ;Position cursor  
76ea			; fLCD_Str                      ;Display string  
76ea			; fLCD_Def                      ;Define custom character  
76ea			;  
76ea			; **********************************************************************  
76ea			;  
76ea			; Requires SCMonAPI.asm to also be included in the project  
76ea			;  
76ea			  
76ea			  
76ea			; **********************************************************************  
76ea			; **  Constants  
76ea			; **********************************************************************  
76ea			  
76ea			; Constants that must be defined externally  
76ea			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
76ea			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
76ea			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
76ea			;kLCDWidth: EQU 20             ;Width in characters  
76ea			  
76ea			; general line offsets in any frame buffer  
76ea			  
76ea			  
76ea			display_row_1: equ 0  
76ea			display_row_2: equ display_row_1+display_cols  
76ea			display_row_3: equ display_row_2 + display_cols  
76ea			display_row_4: equ display_row_3 + display_cols  
76ea			;display_row_4_eol:   
76ea			  
76ea			  
76ea			; Cursor position values for the start of each line  
76ea			  
76ea			; E  
76ea			kLCD_Line1: EQU 0x00   
76ea			kLCD_Line2: EQU kLCD_Line1+kLCDWidth  
76ea			; E1  
76ea			kLCD_Line3: EQU kLCD_Line2+kLCDWidth  
76ea			kLCD_Line4: EQU kLCD_Line3+kLCDWidth   
76ea			  
76ea			; Instructions to send as A register to fLCD_Inst  
76ea			kLCD_Clear: EQU 00000001b     ;LCD clear  
76ea			kLCD_Off:   EQU 00001000b     ;LCD off  
76ea			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
76ea			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
76ea			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
76ea			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
76ea			  
76ea			; Constants used by this code module  
76ea			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
76ea			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
76ea			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
76ea			  
76ea			  
76ea			  
76ea			; **********************************************************************  
76ea			; **  LCD support functions  
76ea			; **********************************************************************  
76ea			  
76ea			; Initialise alphanumeric LCD module  
76ea			; LCD control register codes:  
76ea			;   DL   0 = 4-bit mode        1 = 8-bit mode  
76ea			;   N    0 = 1-line mode       1 = 2-line mode  
76ea			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
76ea			;   D    0 = Display off       1 = Display on  
76ea			;   C    0 = Cursor off        1 = Cursor on  
76ea			;   B    0 = Blinking off      1 = Blinking on  
76ea			;   ID   0 = Decrement mode    1 = Increment mode  
76ea			;   SH   0 = Entire shift off  1 = Entire shift on  
76ea 3e 28		fLCD_Init:  LD   A, 40  
76ec cd 11 78		            CALL LCDDelay       ;Delay 40ms after power up  
76ef			; For reliable reset set 8-bit mode - 3 times  
76ef cd e1 77		            CALL WrFn8bit       ;Function = 8-bit mode  
76f2 cd e1 77		            CALL WrFn8bit       ;Function = 8-bit mode  
76f5 cd e1 77		            CALL WrFn8bit       ;Function = 8-bit mode  
76f8			; Set 4-bit mode  
76f8 cd dd 77		            CALL WrFn4bit       ;Function = 4-bit mode  
76fb cd 0f 78		            CALL LCDDelay1      ;Delay 37 us or more  
76fe			; Function set  
76fe 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
7700 cd 13 77		            CALL fLCD_Inst      ;2 line, display on  
7703			; Display On/Off control  
7703 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
7705 cd 13 77		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
7708			; Display Clear  
7708 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
770a cd 13 77		            CALL fLCD_Inst      ;Clear display  
770d			; Entry mode  
770d 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
770f cd 13 77		            CALL fLCD_Inst      ;Increment mode, shift off  
7712			; Display module now initialised  
7712 c9			            RET  
7713			; ok to here  
7713			  
7713			; Write instruction to LCD  
7713			;   On entry: A = Instruction byte to be written  
7713			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7713 f5			fLCD_Inst:  PUSH AF  
7714 f5			            PUSH AF  
7715 cd 27 77		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
7718 f1			            POP  AF  
7719 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
771a 17			            RLA  
771b 17			            RLA  
771c 17			            RLA  
771d cd 27 77		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
7720 3e 02		            LD   A, 2  
7722 cd 11 78		            CALL LCDDelay       ;Delay 2 ms to complete   
7725 f1			            POP  AF  
7726 c9			            RET  
7727			Wr4bits:   
7727 f5					push af  
7728 3a c8 fb				ld a, (display_lcde1e2)  
772b fe 00				cp 0     ; e  
772d 20 10				jr nz, .wea2	  
772f f1					pop af  
7730 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7732 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7734 cb df		            SET  kLCDBitE, A	    ; TODO decide which E is being set  
7736 cb 87		            res  kLCDBitE2, A	    ; TODO decide which E is being set  
7738 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
773a cb 9f		            RES  kLCDBitE, A        ; TODO decide which E is being set  
773c d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
773e c9			            RET  
773f f1			.wea2:		pop af  
7740 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7742 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7744 cb c7		            SET  kLCDBitE2, A	    ; TODO decide which E is being set  
7746 cb 9f		            res  kLCDBitE, A	    ; TODO decide which E is being set  
7748 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
774a cb 87		            RES  kLCDBitE2, A        ; TODO decide which E is being set  
774c d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
774e c9			            RET  
774f			  
774f			  
774f			; Write data to LCD  
774f			;   On entry: A = Data byte to be written  
774f			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
774f f5			fLCD_Data:  PUSH AF  
7750 f5			            PUSH AF  
7751 cd 63 77		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
7754 f1			            POP  AF  
7755 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
7756 17			            RLA  
7757 17			            RLA  
7758 17			            RLA  
7759 cd 63 77		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
775c 3e 96		            LD   A, 150  
775e 3d			Wait:      DEC  A              ;Wait a while to allow data   
775f 20 fd		            JR   NZ, Wait      ;  write to complete  
7761 f1			            POP  AF  
7762 c9			            RET  
7763			Wr4bitsa:     
7763 f5					push af  
7764 3a c8 fb				ld a, (display_lcde1e2)  
7767 fe 00				cp 0     ; e1  
7769 20 16				jr nz, .we2	  
776b f1					pop af  
776c e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
776e cb d7		            SET  kLCDBitRS, A  
7770 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7772 cb df		            SET  kLCDBitE, A      ; TODO Decide which E is being set  
7774 cb 87		            res  kLCDBitE2, A      ; TODO Decide which E is being set  
7776 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
7778 cb 9f		            RES  kLCDBitE, A       ; TODO Decide which E is being set  
777a d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
777c cb 97		            RES  kLCDBitRS, A  
777e d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7780 c9			            RET  
7781 f1			.we2:		pop af  
7782 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7784 cb d7		            SET  kLCDBitRS, A  
7786 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7788 cb c7		            SET  kLCDBitE2, A      ; TODO Decide which E is being set  
778a cb 9f		            res  kLCDBitE, A      ; TODO Decide which E is being set  
778c d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
778e cb 87		            RES  kLCDBitE2, A       ; TODO Decide which E is being set  
7790 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7792 cb 97		            RES  kLCDBitRS, A  
7794 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7796 c9			            RET  
7797			  
7797			  
7797			; Position cursor to specified location  
7797			;   On entry: A = Cursor position  
7797			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7797 f5			fLCD_Pos:   PUSH AF  
7798					; at this point set the E1 or E2 flag depending on position  
7798			  
7798 c5					push bc  
7799			;		push af  
7799 06 00				ld b, 0  
779b 4f					ld c, a  
779c 3e 4f				ld a, kLCD_Line3-1  
779e b7			 		or a      ;clear carry flag  
779f 99					sbc a,c    ; TODO may need to sub 80 from a to put in context of current frame    
77a0 38 04				jr c, .pe1  
77a2			  
77a2					; E selection  
77a2 cb 80				res 0, b         ; bit 0 unset e  
77a4			;		pop af    ; before line 3 so recover orig pos  
77a4			;		ld c, a    ; save for poking back  
77a4 18 06				jr .peset	          
77a6			.pe1:          	; E2 selection  
77a6 cb c0				set 0, b         ; bit 0 set e1  
77a8 79					ld a, c  
77a9 de 4f				sbc a, kLCD_Line3-1  
77ab 4f					ld c, a	         ; save caculated offset  
77ac			;		pop af     ; bin this original value now we have calculated form  
77ac			  
77ac			.peset:		; set bit  
77ac 78					ld a, b  
77ad 32 c8 fb				ld (display_lcde1e2), a 	  
77b0 79					ld a, c  
77b1 c1					pop bc  
77b2			  
77b2 f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
77b4 cd 13 77		            CALL fLCD_Inst      ;Write instruction to LCD  
77b7 f1			            POP  AF  
77b8 c9			            RET  
77b9			  
77b9			  
77b9			; Output text string to LCD  
77b9			;   On entry: DE = Pointer to null terminated text string  
77b9			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
77b9 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
77ba b7			            OR   A              ;Null terminator?  
77bb c8			            RET  Z              ;Yes, so finished  
77bc cd 4f 77		            CALL fLCD_Data      ;Write character to display  
77bf 13			            INC  DE             ;Point to next character  
77c0 18 f7		            JR   fLCD_Str       ;Repeat  
77c2 c9					ret  
77c3			  
77c3			; Define custom character  
77c3			;   On entry: A = Character number (0 to 7)  
77c3			;             DE = Pointer to character bitmap data  
77c3			;   On exit:  A = Next character number  
77c3			;             DE = Next location following bitmap  
77c3			;             BC HL IX IY I AF' BC' DE' HL' preserved  
77c3			; Character is   
77c3 c5			fLCD_Def:   PUSH BC  
77c4 f5			            PUSH AF  
77c5 07			            RLCA                ;Calculate location  
77c6 07			            RLCA                ;  for bitmap data  
77c7 07			            RLCA                ;  = 8 x CharacterNumber  
77c8 f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
77ca cd 13 77		            CALL fLCD_Inst      ;Write instruction to LCD  
77cd 06 00		            LD   B, 0  
77cf 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
77d0 cd 4f 77		            CALL fLCD_Data      ;Write byte to display  
77d3 13			            INC  DE             ;Point to next byte  
77d4 04			            INC  B              ;Count bytes  
77d5 cb 58		            BIT  3, B           ;Finish all 8 bytes?  
77d7 28 f6		            JR   Z, Loop       ;No, so repeat  
77d9 f1			            POP  AF  
77da 3c			            INC  A              ;Increment character number  
77db c1			            POP  BC  
77dc c9			            RET  
77dd			  
77dd			  
77dd			; **********************************************************************  
77dd			; **  Private functions  
77dd			; **********************************************************************  
77dd			  
77dd			; Write function to LCD  
77dd			;   On entry: A = Function byte to be written  
77dd			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
77dd 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
77df 18 02		            JR   WrFunc  
77e1 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
77e3 f5			WrFunc:     PUSH AF  
77e4 f5					push af  
77e5 3a c8 fb				ld a, (display_lcde1e2)  
77e8 fe 00				cp 0     ; e1  
77ea 20 0f				jr nz, .wfea2	  
77ec f1					pop af  
77ed d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
77ef cb df		            SET  kLCDBitE, A     ; TODO Decide which E is being set  
77f1 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
77f3 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
77f5 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
77f7 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
77f9 18 0d			jr .wfskip  
77fb f1			.wfea2:		pop af  
77fc d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
77fe cb c7		            SET  kLCDBitE2, A     ; TODO Decide which E is being set  
7800 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
7802 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
7804 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
7806 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7808 3e 05		.wfskip:            LD  A, 5  
780a cd 11 78		            CALL LCDDelay       ;Delay 5 ms to complete  
780d f1			            POP  AF  
780e c9			            RET  
780f			  
780f			  
780f			; Delay in milliseconds  
780f			;   On entry: A = Number of milliseconds delay  
780f			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
780f 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
7811 d5			LCDDelay:   PUSH DE  
7812 5f			            LD   E, A           ;Delay by 'A' ms  
7813 16 00		            LD   D, 0  
7815 cd c4 0c		            CALL aDelayInMS  
7818 d1			            POP  DE  
7819 c9			            RET  
781a			  
781a			  
781a			testlcd:  
781a 3e 00			ld a, kLCD_Line1  
781c cd 97 77			call fLCD_Pos  
781f 06 28			ld b, 40  
7821 11 4f 78			ld de, .ttext1  
7824 cd e2 76			call write_len_string  
7827			  
7827 3e 28			ld a, kLCD_Line2  
7829 cd 97 77			call fLCD_Pos  
782c 06 28			ld b, 40  
782e 11 78 78			ld de, .ttext2  
7831 cd e2 76			call write_len_string  
7834 3e 50			ld a, kLCD_Line3  
7836 cd 97 77			call fLCD_Pos  
7839 06 28			ld b, 40  
783b 11 a1 78			ld de, .ttext3  
783e cd e2 76			call write_len_string  
7841 3e 78			ld a, kLCD_Line4  
7843 cd 97 77			call fLCD_Pos  
7846 06 28			ld b, 40  
7848 11 ca 78			ld de, .ttext4  
784b cd e2 76			call write_len_string  
784e			  
784e 76				halt  
784f			  
784f			  
784f .. 00		.ttext1: db "A234567890123456789012345678901234567890",0  
7878 .. 00		.ttext2: db "B234567890123456789012345678901234567890",0  
78a1 .. 00		.ttext3: db "C234567890123456789012345678901234567890",0  
78ca .. 00		.ttext4: db "D234567890123456789012345678901234567890",0  
78f3			   
78f3			  
78f3			  
78f3			; eof  
78f3			  
# End of file firmware_lcd_4x40.asm
78f3			;include "firmware_lcd_4x20.asm" 
78f3			include "firmware_key_5x10.asm" 
78f3			; 5 x 10 decade counter scanner  
78f3			  
78f3			  
78f3			; TODO do cursor shape change for shift keys  
78f3			; TODO hard coded positions for the shift keys. Change to work like 4x4 and detect and then hide them  
78f3			  
78f3			  
78f3			; bit mask for each scan column and row for teing the matrix  
78f3			  
78f3			  
78f3			key_init:  
78f3			  
78f3			; SCMonAPI functions used  
78f3			  
78f3			; Alphanumeric LCD functions used  
78f3			; no need to specify specific functions for this module  
78f3			  
78f3			  
78f3 3e cf		            LD   A, 11001111b  
78f5 d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
78f7			;            LD   A, 00000000b  
78f7 3e 1f		            LD   A, 00011111b  
78f9 d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
78fb			  
78fb			  
78fb				; TODO Configure cursor shapes  
78fb			  
78fb				; Load cursor shapes   
78fb 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
78fd 11 0d 79		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
7900 06 02		            LD   B, 2           ;Number of characters to define  
7902 cd c3 77		.DefLoop:   CALL fLCD_Def       ;Define custom character  
7905 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
7907			  
7907 3e 01				ld a, 1  
7909 32 be fb			ld (cursor_shape),a  
790c c9				ret  
790d			  
790d			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
790d			; Up to 8 custom characters can be defined  
790d			.cursor_shapes:      
790d			;; Character 0x00 = Normal  
790d 1f			            DB  11111b  
790e 1f			            DB  11111b  
790f 1f			            DB  11111b  
7910 1f			            DB  11111b  
7911 1f			            DB  11111b  
7912 1f			            DB  11111b  
7913 1f			            DB  11111b  
7914 1f			            DB  11111b  
7915			;; Character 0x01 = Modifier  
7915 1f			            DB  11111b  
7916 1b			            DB  11011b  
7917 1b			            DB  11011b  
7918 1b			            DB  11011b  
7919 1b			            DB  11011b  
791a 1f			            DB  11111b  
791b 1b			            DB  11011b  
791c 1f			            DB  11111b  
791d			  
791d			  
791d			  
791d			  
791d			; Display custom character 0  
791d			;            LD   A, kLCD_Line1+14  
791d			;            CALL fLCD_Pos       ;Position cursor to location in A  
791d			;            LD   A, 0  
791d			;            CALL fLCD_Data      ;Write character in A at cursor  
791d			  
791d			; Display custom character 1  
791d			;            LD   A, kLCD_Line2+14  
791d			;            CALL fLCD_Pos      ;Position cursor to location in A  
791d			;            LD   A, 1  
791d			;            CALL fLCD_Data     ;Write character in A at cursor  
791d			  
791d			; keyboard scanning   
791d			  
791d			; character in from keyboard  
791d			  
791d			; mapping for the pcb layout  
791d			  
791d			.matrix_to_char:  
791d .. 08 05 0a 00			db "1357890",KEY_BS,KEY_UP,KEY_DOWN,0  
7928 .. 0b 0c 00			db "qweryiop",KEY_LEFT,KEY_RIGHT,0  
7933 7e .. 0d 00			db KEY_SYMBOLSHIFT,"asdfghjk",KEY_CR,0  
793e 7e .. 7e 00			db KEY_SHIFT,"zxcvbnm ",KEY_SHIFT,0  
7949 .. 10 11 12 .. 13 00			db "246tu",KEY_F1,KEY_F2,KEY_F3,"l",KEY_F4,0  
7954			.matrix_to_shift:  
7954			  
7954 .. 08 05 0a 00			db "!#%&*()",KEY_BS,KEY_UP,KEY_DOWN,0  
795f .. 07 06 00			db "QWERYIOP",KEY_PREVWORD,KEY_NEXTWORD,0  
796a 7e .. 0d 00			db KEY_SYMBOLSHIFT,"ASDFGHJK",KEY_CR,0  
7975 7e .. 7e 00			db KEY_SHIFT,"ZXCVBNM|",KEY_SHIFT,0  
7980 .. .. 14 15 16 .. 17 00			db '"',"$^TU",KEY_F5,KEY_F6,KEY_F7,"L",KEY_F8,0  
798b			  
798b			.matrix_to_symbolshift:  
798b			  
798b fc ed .. f7 08 05 0a 00			db 252,237,"5789",247,KEY_BS,KEY_UP,KEY_DOWN,0  
7996 .. b0 0e 0f 00			db "-+/=_?~",176,KEY_HOME,KEY_END,0  
79a1 7e .. a5 7c db ff 0d 00			db KEY_SYMBOLSHIFT,"[]{}",165,124,219,255,KEY_CR,0  
79ac			;		db KEY_SHIFT,"<>,.:;'\\",KEY_SHIFT,0  
79ac 7e .. 5c 7e 00	    	 	db KEY_SHIFT,"<>,.:;'",92, KEY_SHIFT,0  
79b7 .. f6 eb 7d 7e 18 19 1a df 1b 00			db "@",246,235,125,126,KEY_F9,KEY_F10,KEY_F11,223,KEY_F12,0  
79c2			  
79c2			  
79c2			  
79c2			; mapping for a simple straight through breadboard layout  
79c2			  
79c2			;.matrix_to_char:  
79c2			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
79c2			;		db KEY_SHIFT,"zxcvbnm ",KEY_SYMBOLSHIFT,0  
79c2			;		db "asdfghjkl",KEY_CR,0  
79c2			;		db "qwertyuiop",0  
79c2			;		 db "1234567890",0  
79c2			;.matrix_to_shift:  
79c2			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_HOME, KEY_END,0  
79c2			;		db KEY_SHIFT,"ZXCVBNM",KEY_BS,KEY_SYMBOLSHIFT,0  
79c2			;		db "ASDFGHJKL",KEY_CR,0  
79c2			;		db "QWERTYUIOP",0  
79c2			;		 db "!",'"',"#$%^&*()",0  
79c2			;.matrix_to_symbolshift:  
79c2			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
79c2			;		db KEY_SHIFT,"<>:;b,.",KEY_BS,KEY_SYMBOLSHIFT,0  
79c2			;		db "_?*fghjk=",KEY_CR,0  
79c2			;		db "-/+*[]{}@#",0  
79c2			;		 db "1234567890",0  
79c2			  
79c2			;.matrix_to_char: db "D#0*C987B654A321"  
79c2			  
79c2			  
79c2				  
79c2			  
79c2			; add cin and cin_wait  
79c2			  
79c2 cd d3 79		cin_wait: 	call cin  
79c5						if DEBUG_KEYCINWAIT  
79c5							push af  
79c5							  
79c5							ld hl,key_repeat_ct  
79c5							ld (hl),a  
79c5							inc hl  
79c5							call hexout  
79c5							ld hl,key_repeat_ct+3  
79c5							ld a,0  
79c5							ld (hl),a  
79c5			  
79c5							    LD   A, kLCD_Line1+11  
79c5							    CALL fLCD_Pos       ;Position cursor to location in A  
79c5							    LD   DE, key_repeat_ct  
79c5							    ;LD   DE, MsgHello  
79c5							    CALL fLCD_Str       ;Display string pointed to by DE  
79c5			  
79c5			  
79c5			  
79c5							pop af  
79c5						endif  
79c5 fe 00			cp 0  
79c7 28 f9			jr z, cin_wait   ; block until key press  
79c9			  
79c9							if DEBUG_KEYCINWAIT  
79c9								push af  
79c9			  
79c9								ld a, 'A'	  
79c9								ld hl,key_repeat_ct  
79c9								ld (hl),a  
79c9								inc hl  
79c9								ld a,0  
79c9								ld (hl),a  
79c9			  
79c9								    LD   A, kLCD_Line2+11  
79c9								    CALL fLCD_Pos       ;Position cursor to location in A  
79c9								    LD   DE, key_repeat_ct  
79c9								    ;LD   DE, MsgHello  
79c9								    CALL fLCD_Str       ;Display string pointed to by DE  
79c9			  
79c9							call delay500ms  
79c9			  
79c9								pop af  
79c9							endif  
79c9 f5				push af   ; save key pressed  
79ca			  
79ca			.cin_wait1:	  
79ca							if DEBUG_KEYCINWAIT  
79ca								push af  
79ca			  
79ca								ld a, 'b'	  
79ca								ld hl,key_repeat_ct  
79ca								ld (hl),a  
79ca								inc hl  
79ca								ld a,0  
79ca								ld (hl),a  
79ca			  
79ca								    LD   A, kLCD_Line2+11  
79ca								    CALL fLCD_Pos       ;Position cursor to location in A  
79ca								    LD   DE, key_repeat_ct  
79ca								    ;LD   DE, MsgHello  
79ca								    CALL fLCD_Str       ;Display string pointed to by DE  
79ca			  
79ca			  
79ca							call delay500ms  
79ca			  
79ca								pop af  
79ca							endif  
79ca			  
79ca cd d3 79		call cin  
79cd fe 00			cp 0  
79cf 20 f9			jr nz, .cin_wait1  	; wait for key release  
79d1			if DEBUG_KEYCINWAIT  
79d1				push af  
79d1			  
79d1				ld a, '3'	  
79d1				ld hl,key_repeat_ct  
79d1				ld (hl),a  
79d1				inc hl  
79d1				ld a,0  
79d1				ld (hl),a  
79d1			  
79d1			            LD   A, kLCD_Line2+11  
79d1			            CALL fLCD_Pos       ;Position cursor to location in A  
79d1			            LD   DE, key_repeat_ct  
79d1			            ;LD   DE, MsgHello  
79d1			            CALL fLCD_Str       ;Display string pointed to by DE  
79d1			  
79d1			  
79d1			call delay500ms  
79d1			  
79d1				pop af  
79d1			endif  
79d1			  
79d1 f1				pop af   ; get key  
79d2 c9				ret  
79d3			  
79d3			  
79d3 cd e7 79		cin: 	call .mtoc  
79d6			  
79d6			if DEBUG_KEYCIN  
79d6				push af  
79d6				  
79d6				ld hl,key_repeat_ct  
79d6				ld (hl),a  
79d6				inc hl  
79d6				call hexout  
79d6				ld hl,key_repeat_ct+3  
79d6				ld a,0  
79d6				ld (hl),a  
79d6			  
79d6			            LD   A, kLCD_Line3+15  
79d6			            CALL fLCD_Pos       ;Position cursor to location in A  
79d6			            LD   DE, key_repeat_ct  
79d6			            ;LD   DE, MsgHello  
79d6			            CALL fLCD_Str       ;Display string pointed to by DE  
79d6			  
79d6			  
79d6			call delay500ms  
79d6			  
79d6				pop af  
79d6			endif  
79d6			  
79d6			  
79d6				; no key held  
79d6 fe 00			cp 0  
79d8 c8				ret z  
79d9			  
79d9			if DEBUG_KEYCIN  
79d9				push af  
79d9			  
79d9				ld a, '1'	  
79d9				ld hl,key_repeat_ct  
79d9				ld (hl),a  
79d9				inc hl  
79d9				ld a,0  
79d9				ld (hl),a  
79d9			  
79d9			            LD   A, kLCD_Line4+15  
79d9			            CALL fLCD_Pos       ;Position cursor to location in A  
79d9			            LD   DE, key_repeat_ct  
79d9			            ;LD   DE, MsgHello  
79d9			            CALL fLCD_Str       ;Display string pointed to by DE  
79d9			  
79d9			  
79d9			call delay500ms  
79d9			  
79d9				pop af  
79d9			endif  
79d9			  
79d9				; stop key bounce  
79d9			  
79d9 32 88 fe			ld (key_held),a		 ; save it  
79dc 47				ld b, a  
79dd			  
79dd c5			.cina1:	push bc  
79de			if DEBUG_KEYCIN  
79de				push af  
79de			  
79de				ld hl,key_repeat_ct  
79de				inc hl  
79de				call hexout  
79de				ld hl,key_repeat_ct+3  
79de				ld a,0  
79de				ld (hl),a  
79de				ld hl,key_repeat_ct  
79de				ld a, '2'	  
79de				ld (hl),a  
79de			  
79de			            LD   A, kLCD_Line4+15  
79de			            CALL fLCD_Pos       ;Position cursor to location in A  
79de			            LD   DE, key_repeat_ct  
79de			            ;LD   DE, MsgHello  
79de			            CALL fLCD_Str       ;Display string pointed to by DE  
79de			  
79de				pop af  
79de			endif  
79de cd e7 79			call .mtoc  
79e1 c1				pop bc  
79e2 b8				cp b  
79e3 28 f8			jr z, .cina1  
79e5 78				ld a,b		  
79e6			if DEBUG_KEYCIN  
79e6				push af  
79e6			  
79e6				ld hl,key_repeat_ct  
79e6				inc hl  
79e6				call hexout  
79e6				ld hl,key_repeat_ct+3  
79e6				ld a,0  
79e6				ld (hl),a  
79e6				ld hl,key_repeat_ct  
79e6				ld a, '3'	  
79e6				ld (hl),a  
79e6			  
79e6			            LD   A, kLCD_Line4+15  
79e6			            CALL fLCD_Pos       ;Position cursor to location in A  
79e6			            LD   DE, key_repeat_ct  
79e6			            ;LD   DE, MsgHello  
79e6			            CALL fLCD_Str       ;Display string pointed to by DE  
79e6			  
79e6				pop af  
79e6			endif  
79e6 c9				ret  
79e7			  
79e7			; detect keyboard modifier key press and apply new overlay to the face key held  
79e7			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
79e7			  
79e7			;.cin_map_modifier:   
79e7			;	ld a, (hl)  
79e7			;	and 255  
79e7			;	ret NZ		; modifier key not flagged  
79e7			;  
79e7			;	; get key face  
79e7			;  
79e7			;	ld b,(key_face_held)  
79e7			;  
79e7			;	ld b, key_cols * key_rows  
79e7			;  
79e7			;	push de  
79e7			;	pop hl  
79e7			;  
79e7			;.mmod1: ld a,(hl)   ; get map test  
79e7			;	cp b  
79e7			;	jr z, .mmod2  
79e7			;  
79e7			;  
79e7			;  
79e7			;.mmod2: inc hl    ;   
79e7			;  
79e7			;	  
79e7			;  
79e7			;	  
79e7			;  
79e7			;	ld hl,key_actual_pressed  
79e7			;	ld (hl),a,  
79e7			;	ret  
79e7			  
79e7			; map matrix key held to char on face of key  
79e7			  
79e7			.mtoc:  
79e7			  
79e7			; test decade counter strobes  
79e7			  
79e7			;.decadetest1:  
79e7			  
79e7			; reset counter  
79e7			;ld a, 128  
79e7			;out (portbdata),a  
79e7			  
79e7			  
79e7			;ld b, 5  
79e7			;.dec1:  
79e7			;ld a, 0  
79e7			;out (portbdata),a  
79e7			;call delay1s  
79e7			  
79e7			;ld a, 32  
79e7			;out (portbdata),a  
79e7			;call delay1s  
79e7			;call delay1s  
79e7			;call delay1s  
79e7			;  
79e7			;ld a, 64+32  
79e7			;out (portbdata),a  
79e7			;call delay1s  
79e7			;;djnz .dec1  
79e7			;  
79e7			;jp .decadetest1  
79e7			  
79e7			  
79e7			  
79e7			  
79e7			  
79e7			  
79e7			  
79e7			  
79e7			  
79e7			  
79e7				; scan keyboard matrix and generate raw scan map  
79e7 cd 7a 7a			call matrix  
79ea			  
79ea				; reuse c bit 0 left modifer button - ie shift  
79ea			        ; reuse c bit 1 for right modifer button - ie symbol shift  
79ea				; both can be used with their other mappings and if seen together can do extra mappings (forth keywords????)  
79ea			  
79ea 0e 00			ld c, 0  
79ec			  
79ec				; TODO set flags for modifer key presses   
79ec				; TODO do a search for modifer key...  
79ec			  
79ec				;ld hl,keyscan_table_row4  
79ec 21 e7 fe			ld hl,keyscan_table_row2  
79ef			  
79ef 7e				ld a, (hl)  
79f0 fe 23			cp '#'  
79f2 20 07			jr nz, .nextmodcheck  
79f4 cb c1			set 0, c  
79f6 21 54 79			ld hl, .matrix_to_shift  
79f9 18 21			jr .dokeymap  
79fb				; TODO for now igonre  
79fb			.nextmodcheck:  
79fb 21 dc fe			ld hl,keyscan_table_row3  
79fe			  
79fe 7e				ld a, (hl)  
79ff fe 23			cp '#'  
7a01 20 07			jr nz, .nextmodcheck2  
7a03 cb c9			set 1, c   
7a05 21 8b 79			ld hl, .matrix_to_symbolshift  
7a08 18 12			jr .dokeymap  
7a0a			.nextmodcheck2:  
7a0a 21 f0 fe			ld hl,keyscan_table_row2+9    ; right shift  
7a0d			  
7a0d 7e				ld a, (hl)  
7a0e fe 23			cp '#'  
7a10 20 07			jr nz, .donemodcheck  
7a12 cb c9			set 1, c   
7a14 21 54 79			ld hl, .matrix_to_shift  
7a17 18 03			jr .dokeymap  
7a19			  
7a19				; no modifer found so just map to normal keys  
7a19				; get mtoc map matrix to respective keys  
7a19			;	ld hl, .matrix_to_char  
7a19			;	ld hl, .matrix_to_char  
7a19			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
7a19			;	ld a, KEY_SHIFT  
7a19			;	call findchar  
7a19			;  
7a19			;	; got offset to key modifer in b  
7a19			;  
7a19			;	ld hl,keyscan_table_row5  
7a19			;  
7a19			;	ld a,b  
7a19			;	call addatohl  
7a19			;	ld a,(hl)  
7a19			;  
7a19			;	cp '#'  
7a19			;	jr nz, .nextmodcheck  
7a19			;	set 0, c  
7a19			;	ld hl, .matrix_to_char  
7a19			;	jr .dokeymap  
7a19			;	; TODO for now igonre  
7a19			;.nextmodcheck:  
7a19			;	ld hl, .matrix_to_symbolshift  
7a19			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
7a19			;	ld a, KEY_SYMBOLSHIFT  
7a19			;	call findchar  
7a19			;  
7a19			;  
7a19			;	; got offset to key modifer in b  
7a19			;  
7a19			;	ld hl,keyscan_table_row5  
7a19			;  
7a19			;	ld a,b  
7a19			;	call addatohl  
7a19			;	ld a,(hl)  
7a19			;  
7a19			;	cp '#'  
7a19			;	jr nz, .donemodcheck  
7a19			;	set 1, c   
7a19			;	ld hl, .matrix_to_symbolshift  
7a19			;	jr .dokeymap  
7a19			  
7a19			  
7a19			  
7a19			.donemodcheck:  
7a19				; no modifer found so just map to normal keys  
7a19				; get mtoc map matrix to respective keys  
7a19 21 1d 79			ld hl, .matrix_to_char  
7a1c			  
7a1c			.dokeymap:  
7a1c				;ld (key_fa), c   
7a1c cd 35 7a			call .mapkeys  
7a1f			  
7a1f			  
7a1f			if DEBUG_KEY  
7a1f			  
7a1f			; Display text on first line  
7a1f			            LD   A, kLCD_Line1  
7a1f			            CALL fLCD_Pos       ;Position cursor to location in A  
7a1f			            LD   DE, keyscan_table_row1  
7a1f			            ;LD   DE, MsgHello  
7a1f			            CALL fLCD_Str       ;Display string pointed to by DE  
7a1f			  
7a1f			; Display text on second line  
7a1f			            LD   A, kLCD_Line2  
7a1f			            CALL fLCD_Pos       ;Position cursor to location in A  
7a1f			            LD   DE, keyscan_table_row2  
7a1f			            CALL fLCD_Str       ;Display string pointed to by DE  
7a1f			            LD   A, kLCD_Line3  
7a1f			            CALL fLCD_Pos       ;Position cursor to location in A  
7a1f			            LD   DE, keyscan_table_row3  
7a1f			            CALL fLCD_Str       ;Display string pointed to by DE  
7a1f			            LD   A, kLCD_Line4  
7a1f			            CALL fLCD_Pos       ;Position cursor to location in A  
7a1f			            LD   DE, keyscan_table_row4  
7a1f			            CALL fLCD_Str       ;Display string pointed to by DE  
7a1f			            LD   A, kLCD_Line1+10  
7a1f			            CALL fLCD_Pos       ;Position cursor to location in A  
7a1f			            LD   DE, keyscan_table_row5  
7a1f			            CALL fLCD_Str       ;Display string pointed to by DE  
7a1f			  
7a1f				;call delay250ms  
7a1f			endif  
7a1f			;	jp testkey  
7a1f			  
7a1f			; get first char reported  
7a1f			  
7a1f 21 c6 fe			ld hl,keyscan_table_row5  
7a22			  
7a22				;ld b, 46   ; 30 keys to remap + 8 nulls   
7a22 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
7a24			.findkey:  
7a24 7e				ld a,(hl)  
7a25 fe 00			cp 0  
7a27 28 04			jr z, .nextkey  
7a29 fe 7e			cp KEY_MATRIX_NO_PRESS  
7a2b 20 06			jr nz, .foundkey  
7a2d			.nextkey:  
7a2d 23				inc hl  
7a2e 10 f4			djnz .findkey  
7a30 3e 00			ld a,0  
7a32 c9				ret  
7a33			.foundkey:  
7a33 7e				ld a,(hl)  
7a34 c9				ret  
7a35				  
7a35			  
7a35			; convert the raw key map given hl for destination key  
7a35			.mapkeys:  
7a35 11 c6 fe			ld de,keyscan_table_row5  
7a38			  
7a38 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
7a3a			.remap:  
7a3a 1a				ld a,(de)  
7a3b fe 23			cp '#'  
7a3d 20 02			jr nz, .remapnext  
7a3f				;CALLMONITOR  
7a3f 7e				ld a,(hl)  
7a40 12				ld (de),a  
7a41			  
7a41			  
7a41			  
7a41			.remapnext:  
7a41 23				inc hl  
7a42 13				inc de  
7a43 10 f5			djnz .remap  
7a45				  
7a45 c9				ret  
7a46			  
7a46			  
7a46			  
7a46			.mtocold2:  
7a46			  
7a46			;	; flag if key D is held down and remove from reporting  
7a46			;	ld bc, .key_map_fd    
7a46			;	ld hl, keyscan_table  
7a46			;	ld de, key_fd  
7a46			;	call .key_shift_hold  
7a46			;	cp 255  
7a46			;	jr z, .cinmap  
7a46			;	; flag if key C is held down and remove from reporting  
7a46			;	ld bc, .key_map_fc    
7a46			;	ld hl, keyscan_table+key_cols  
7a46			;	ld de, key_fc  
7a46			;	call .key_shift_hold  
7a46			;	cp 255  
7a46			;	jr z, .cinmap  
7a46			;	; flag if key B is held down and remove from reporting  
7a46			;	ld bc, .key_map_fb    
7a46			;	ld hl, keyscan_table+(key_cols*2)  
7a46			;	ld de, key_fb  
7a46			;	call .key_shift_hold  
7a46			;	cp 255  
7a46			;	jr z, .cinmap  
7a46			;	; flag if key A is held down and remove from reporting  
7a46			;	ld bc, .key_map_fa    
7a46			;	ld hl, keyscan_table+(key_cols*3)  
7a46			;	ld de, key_fa  
7a46			;	call .key_shift_hold  
7a46			;	cp 255  
7a46			;	jr z, .cinmap  
7a46			  
7a46 11 1d 79			ld de, .matrix_to_char  
7a49			  
7a49			  
7a49			.cinmap1:   
7a49				if DEBUG_KEY  
7a49			            LD   A, kLCD_Line4  
7a49			            CALL fLCD_Pos       ;Position cursor to location in A  
7a49					push de  
7a49			            LD   DE, keyscan_table  
7a49			            CALL fLCD_Str       ;Display string pointed to by DE  
7a49					pop de  
7a49				endif  
7a49			  
7a49				; scan key matrix table for any held key  
7a49			  
7a49				; de holds either the default matrix or one selected above  
7a49			  
7a49 21 93 fe			ld hl, keyscan_table  
7a4c 06 32			ld b,key_cols*key_rows  
7a4e			  
7a4e 7e			.cin11:	ld a,(hl)  
7a4f fe 23			cp '#'  
7a51 28 08			jr z, .cinhit1  
7a53 23				inc hl  
7a54 13				inc de  
7a55 05				dec b  
7a56 20 f6			jr nz, .cin11  
7a58				; no key found held  
7a58 3e 00			ld a,0  
7a5a c9				ret  
7a5b d5			.cinhit1: push de  
7a5c e1				pop hl  
7a5d 7e				ld a,(hl)  
7a5e c9				ret  
7a5f			  
7a5f			; flag a control key is held   
7a5f			; hl is key pin, de is flag indicator  
7a5f			  
7a5f			.key_shift_hold1:  
7a5f c5				push bc  
7a60 3e 01			ld a, 1  
7a62 32 be fb			ld (cursor_shape),a  
7a65 06 00			ld b, 0  
7a67 7e				ld a, (hl)  
7a68 fe 2e			cp '.'  
7a6a 28 0a			jr z, .key_shift11  
7a6c 06 ff			ld b, 255  
7a6e 3e 2b			ld a, '+'    ; hide key from later scans  
7a70 77				ld (hl),a  
7a71 3e 02			ld a, 2  
7a73 32 be fb			ld (cursor_shape),a  
7a76			.key_shift11:  
7a76				; write flag indicator  
7a76 78				ld a,b  
7a77 12				ld (de),a  
7a78			  
7a78 d1				pop de    ; de now holds the key map ptr  
7a79 c9				ret  
7a7a			  
7a7a				  
7a7a			  
7a7a			; scans keyboard matrix and flags key press in memory array	  
7a7a				  
7a7a			matrix:  
7a7a				;call matrix  
7a7a				; TODO optimise the code....  
7a7a			  
7a7a			  
7a7a			;ld hl, keyscan_table_row1  
7a7a			;ld de, keyscan_table_row1+1  
7a7a			;ld bc,46  
7a7a			;ld a,KEY_MATRIX_NO_PRESS  
7a7a			;ldir  
7a7a			  
7a7a			  
7a7a			  
7a7a			; reset counter  
7a7a 3e 80		ld a, 128  
7a7c d3 c1		out (portbdata),a  
7a7e			  
7a7e 06 0a		ld b, 10  
7a80 0e 00		ld c, 0       ; current clock toggle  
7a82			  
7a82			.colscan:  
7a82			  
7a82			; set current column  
7a82			; disable clock enable and set clock low  
7a82			  
7a82			;ld a, 0  
7a82			;out (portbdata),a  
7a82			  
7a82			; For each column scan for switches  
7a82			  
7a82 c5			push bc  
7a83 21 89 fe		ld hl, keyscan_scancol  
7a86 cd 8f 7b		call .rowscan  
7a89 c1			pop bc  
7a8a			  
7a8a			  
7a8a			; get back current column  
7a8a			  
7a8a			; translate the row scan  
7a8a			  
7a8a			;   
7a8a			; row 1  
7a8a			  
7a8a 78			ld a,b  
7a8b			  
7a8b 21 fc fe		LD   hl, keyscan_table_row1+10  
7a8e			  
7a8e cd e2 0f		call subafromhl  
7a91			;call addatohl  
7a91			  
7a91 11 89 fe		ld de, keyscan_scancol  
7a94			  
7a94 1a			ld a,(de)  
7a95 77			ld (hl),a  
7a96			  
7a96			  
7a96			  
7a96			  
7a96			; row 2  
7a96			  
7a96 78			ld a,b  
7a97			  
7a97 21 f1 fe		LD   hl, keyscan_table_row2+10  
7a9a			  
7a9a			;call addatohl  
7a9a cd e2 0f		call subafromhl  
7a9d			  
7a9d			  
7a9d 11 8a fe		ld de, keyscan_scancol+1  
7aa0			  
7aa0 1a			ld a,(de)  
7aa1 77			ld (hl),a  
7aa2			  
7aa2			  
7aa2			; row 3  
7aa2			  
7aa2 78			ld a,b  
7aa3			  
7aa3 21 e6 fe		LD   hl, keyscan_table_row3+10  
7aa6			  
7aa6			;call addatohl  
7aa6 cd e2 0f		call subafromhl  
7aa9			  
7aa9 11 8b fe		ld de, keyscan_scancol+2  
7aac			  
7aac 1a			ld a,(de)  
7aad 77			ld (hl),a  
7aae			  
7aae			  
7aae			  
7aae			; row 4  
7aae			  
7aae 78			ld a,b  
7aaf			  
7aaf 21 db fe		LD   hl, keyscan_table_row4+10  
7ab2			  
7ab2			;call addatohl  
7ab2 cd e2 0f		call subafromhl  
7ab5			  
7ab5 11 8c fe		ld de, keyscan_scancol+3  
7ab8			  
7ab8 1a			ld a,(de)  
7ab9 77			ld (hl),a  
7aba			  
7aba			; row 5  
7aba			  
7aba 78			ld a,b  
7abb			  
7abb 21 d0 fe		LD   hl, keyscan_table_row5+10  
7abe			  
7abe			;call addatohl  
7abe cd e2 0f		call subafromhl  
7ac1			  
7ac1 11 8d fe		ld de, keyscan_scancol+4  
7ac4			  
7ac4 1a			ld a,(de)  
7ac5 77			ld (hl),a  
7ac6			  
7ac6			; handshake next column  
7ac6			  
7ac6			  
7ac6 3e 40		ld a, 64  
7ac8 d3 c1		out (portbdata),a  
7aca			  
7aca 3e 00		ld a, 0  
7acc d3 c1		out (portbdata),a  
7ace			  
7ace			; toggle clk and move to next column  
7ace			;ld a, 64  
7ace			;cp c  
7ace			;  
7ace			;jr z, .coltoglow  
7ace			;ld c, a  
7ace			;jr .coltog  
7ace			;.coltoglow:  
7ace			;ld c, 0  
7ace			;.coltog:  
7ace			;ld a, c  
7ace			;out (portbdata),a  
7ace			  
7ace 10 b2		djnz .colscan  
7ad0			  
7ad0 3e 0a		ld a,10  
7ad2 21 f2 fe		LD   hl, keyscan_table_row1  
7ad5 cd d0 0f		call addatohl  
7ad8 3e 00		ld a, 0  
7ada 77			ld (hl), a  
7adb			  
7adb			  
7adb 3e 0a		ld a,10  
7add 21 e7 fe		LD   hl, keyscan_table_row2  
7ae0 cd d0 0f		call addatohl  
7ae3 3e 00		ld a, 0  
7ae5 77			ld (hl), a  
7ae6			  
7ae6 3e 0a		ld a,10  
7ae8 21 dc fe		LD   hl, keyscan_table_row3  
7aeb cd d0 0f		call addatohl  
7aee 3e 00		ld a, 0  
7af0 77			ld (hl), a  
7af1			  
7af1 3e 0a		ld a,10  
7af3 21 d1 fe		LD   hl, keyscan_table_row4  
7af6 cd d0 0f		call addatohl  
7af9 3e 00		ld a, 0  
7afb 77			ld (hl), a  
7afc			  
7afc 3e 0a		ld a,10  
7afe 21 c6 fe		LD   hl, keyscan_table_row5  
7b01 cd d0 0f		call addatohl  
7b04 3e 00		ld a, 0  
7b06 77			ld (hl), a  
7b07			  
7b07			if DEBUG_KEY_MATRIX  
7b07			  
7b07			; Display text on first line  
7b07			            LD   A, kLCD_Line1  
7b07			            CALL fLCD_Pos       ;Position cursor to location in A  
7b07			            LD   DE, keyscan_table_row1  
7b07			            ;LD   DE, MsgHello  
7b07			            CALL fLCD_Str       ;Display string pointed to by DE  
7b07			  
7b07			; Display text on second line  
7b07			            LD   A, kLCD_Line2  
7b07			            CALL fLCD_Pos       ;Position cursor to location in A  
7b07			            LD   DE, keyscan_table_row2  
7b07			            CALL fLCD_Str       ;Display string pointed to by DE  
7b07			            LD   A, kLCD_Line3  
7b07			            CALL fLCD_Pos       ;Position cursor to location in A  
7b07			            LD   DE, keyscan_table_row3  
7b07			            CALL fLCD_Str       ;Display string pointed to by DE  
7b07			            LD   A, kLCD_Line4  
7b07			            CALL fLCD_Pos       ;Position cursor to location in A  
7b07			            LD   DE, keyscan_table_row4  
7b07			            CALL fLCD_Str       ;Display string pointed to by DE  
7b07			            LD   A, kLCD_Line4+10  
7b07			            CALL fLCD_Pos       ;Position cursor to location in A  
7b07			            LD   DE, keyscan_table_row5  
7b07			            CALL fLCD_Str       ;Display string pointed to by DE  
7b07			  
7b07			;call delay250ms  
7b07				jp matrix  
7b07			endif  
7b07 c9			ret  
7b08			  
7b08			; using decade counter....  
7b08			  
7b08			  
7b08			; TODO reset decade counter to start of scan  
7b08			  
7b08			; reset 15  
7b08			; clock 14  
7b08			; ce 13  
7b08			  
7b08			; 1 - q5  
7b08			; 2 - q1  
7b08			; 3 - q0  
7b08			; 4 - q2  
7b08			; 5 - q6  
7b08			; 6 - q7  
7b08			; 7 - q3  
7b08			; 8 - vss  
7b08			; 9 - q8  
7b08			; 10 - q4  
7b08			; 11 - q9  
7b08			; 12 - cout  
7b08			; 16 - vdd  
7b08			  
7b08			; clock      ce       reset     output  
7b08			; 0          x        0         n  
7b08			; x          1        0         n  
7b08			; x          x        1         q0  
7b08			; rising     0        0         n+1  
7b08			; falling    x        0         n  
7b08			; x          rising   0         n  
7b08			; 1          falling  0         x+1  
7b08			;  
7b08			; x = dont care, if n < 5 carry = 1 otherwise 0  
7b08			  
7b08			;   
7b08			; reset   
7b08			; 13=0, 14=0, 15=1 .. 15=0  
7b08			;  
7b08			; handshake line  
7b08			; 14=1.... read line 14=0  
7b08			  
7b08			  
7b08			  
7b08			  
7b08			  
7b08			; TODO hand shake clock for next column scan  
7b08			; TODO detect each row  
7b08			  
7b08			  
7b08			  
7b08			  
7b08			; reset 128  
7b08			; clock 64  
7b08			; ce 32  
7b08			  
7b08			  
7b08			.cyclestart:  
7b08			  
7b08			; reset counter  
7b08 3e 80		ld a, 128  
7b0a d3 c1		out (portbdata),a  
7b0c			  
7b0c			; loop leds  
7b0c 06 0a		ld b,10  
7b0e			  
7b0e			.cycle1:  
7b0e c5			push bc  
7b0f 3e 00		ld a, 0  
7b11 d3 c1		out (portbdata),a  
7b13 cd d3 0c		call delay250ms  
7b16			  
7b16 3e 40		ld a, 64  
7b18 d3 c1		out (portbdata),a  
7b1a cd d3 0c		call delay250ms  
7b1d			  
7b1d 3e 00		ld a, 0  
7b1f d3 c1		out (portbdata),a  
7b21 cd d3 0c		call delay250ms  
7b24			  
7b24 c1			pop bc  
7b25 10 e7		djnz .cycle1  
7b27			  
7b27			  
7b27 18 df		jr .cyclestart  
7b29			  
7b29			  
7b29			  
7b29			  
7b29			  
7b29			  
7b29			  
7b29			  
7b29			  
7b29			; map matrix key held to char on face of key  
7b29			  
7b29			;.mtocold:  
7b29			;  
7b29			;  
7b29			;; reset counter  
7b29			;ld a, 128  
7b29			;out (portbdata),a  
7b29			;  
7b29			;  
7b29			;; scan keyboard row 1  
7b29			;ld a, 0  
7b29			;out (portbdata),a  
7b29			;;ld a, 64  
7b29			;;out (portbdata),a  
7b29			;  
7b29			;  
7b29			;	ld a, 128  
7b29			;	ld hl, keyscan_table  
7b29			;	call .rowscan  
7b29			;  
7b29			;;ld a, 0  
7b29			;;out (portbdata),a  
7b29			;ld a, 64  
7b29			;out (portbdata),a  
7b29			;  
7b29			;	ld a, 64  
7b29			;	ld hl, keyscan_table+key_cols  
7b29			;	call .rowscan  
7b29			;  
7b29			;ld a, 0  
7b29			;out (portbdata),a  
7b29			;;ld a, 64  
7b29			;;out (portbdata),a  
7b29			;	ld a, 32  
7b29			;	ld hl, keyscan_table+(key_cols*2)  
7b29			;	call .rowscan  
7b29			;  
7b29			;  
7b29			;;ld a, 0  
7b29			;;out (portbdata),a  
7b29			;ld a, 64  
7b29			;out (portbdata),a  
7b29			;  
7b29			;	ld a, 16  
7b29			;	ld hl, keyscan_table+(key_cols*3)  
7b29			;	call .rowscan  
7b29			;  
7b29			;  
7b29			;	; flag if key D is held down and remove from reporting  
7b29			;	ld bc, .key_map_fd    
7b29			;	ld hl, keyscan_table  
7b29			;	ld de, key_fd  
7b29			;	call .key_shift_hold  
7b29			;	cp 255  
7b29			;	jr z, .cinmap  
7b29			;	; flag if key C is held down and remove from reporting  
7b29			;	ld bc, .key_map_fc    
7b29			;	ld hl, keyscan_table+key_cols  
7b29			;	ld de, key_fc  
7b29			;	call .key_shift_hold  
7b29			;	cp 255  
7b29			;	jr z, .cinmap  
7b29			;	; flag if key B is held down and remove from reporting  
7b29			;	ld bc, .key_map_fb    
7b29			;	ld hl, keyscan_table+(key_cols*2)  
7b29			;	ld de, key_fb  
7b29			;	call .key_shift_hold  
7b29			;	cp 255  
7b29			;	jr z, .cinmap  
7b29			;	; flag if key A is held down and remove from reporting  
7b29			;	ld bc, .key_map_fa    
7b29			;	ld hl, keyscan_table+(key_cols*3)  
7b29			;	ld de, key_fa  
7b29			;	call .key_shift_hold  
7b29			;	cp 255  
7b29			;	jr z, .cinmap  
7b29			;  
7b29			;	ld de, .matrix_to_char  
7b29			;  
7b29			;  
7b29			;.cinmap:   
7b29			;	if DEBUG_KEY  
7b29			;            LD   A, kLCD_Line4  
7b29			;            CALL fLCD_Pos       ;Position cursor to location in A  
7b29			;		push de  
7b29			;            LD   DE, keyscan_table  
7b29			;            CALL fLCD_Str       ;Display string pointed to by DE  
7b29			;		pop de  
7b29			;	endif  
7b29			  
7b29				; scan key matrix table for any held key  
7b29			  
7b29				; de holds either the default matrix or one selected above  
7b29			  
7b29			;	ld hl, keyscan_table  
7b29			;	ld b,key_cols*key_rows  
7b29			;  
7b29			;.cin1:	ld a,(hl)  
7b29			;	cp '#'  
7b29			;	jr z, .cinhit  
7b29			;	inc hl  
7b29			;	inc de  
7b29			;	dec b  
7b29			;	jr nz, .cin1  
7b29			;	; no key found held  
7b29			;	ld a,0  
7b29			;	ret  
7b29			;.cinhit: push de  
7b29			;	pop hl  
7b29			;	ld a,(hl)  
7b29			;	ret  
7b29			  
7b29			; flag a control key is held   
7b29			; hl is key pin, de is flag indicator  
7b29			  
7b29			;.key_shift_hold:  
7b29			;	push bc  
7b29			;	ld a, 1  
7b29			;	ld (cursor_shape),a  
7b29			;	ld b, 0  
7b29			;	ld a, (hl)  
7b29			;	cp '.'  
7b29			;	jr z, .key_shift1  
7b29			;	ld b, 255  
7b29			;	ld a, '+'    ; hide key from later scans  
7b29			;	ld (hl),a  
7b29			;	ld a, 2  
7b29			;	ld (cursor_shape),a  
7b29			;.key_shift1:  
7b29			;	; write flag indicator  
7b29			;	ld a,b  
7b29			;	ld (de),a  
7b29			;  
7b29			;	pop de    ; de now holds the key map ptr  
7b29			;	ret  
7b29			  
7b29				  
7b29				  
7b29			  
7b29			  
7b29			  
7b29			  
7b29			  
7b29			  
7b29			  
7b29			  
7b29			  
7b29			  
7b29			  
7b29			;	push hl  
7b29			;	push de  
7b29			;	push bc  
7b29			;	call keyscan  
7b29			;	; map key matrix to ascii value of key face  
7b29			;  
7b29			;	ld hl, key_face_map  
7b29			;	ld de, keyscan_table  
7b29			;  
7b29			;	; get how many keys to look at  
7b29			;	ld b, keyscan_table_len  
7b29			;	  
7b29			;  
7b29			;	; at this stage fall out on first key hit  
7b29			;	; TODO handle multiple key press  
7b29			;  
7b29			;map1:	ld a,(hl)  
7b29			;	cp '#'  
7b29			;	jr z, keyhit  
7b29			;	inc hl  
7b29			;	inc de  
7b29			;	dec b  
7b29			;	jr nz, map1  
7b29			;nohit:	ld a, 0  
7b29			;	jr keydone  
7b29			;keyhit: push de  
7b29			;	pop hl  
7b29			;	ld a,(hl)  
7b29			;keydone:  
7b29			;	push bc  
7b29			;	push de  
7b29			; 	push hl  
7b29			;	ret   
7b29			;  
7b29			  
7b29			  
7b29			  
7b29			  
7b29			; scan physical key matrix  
7b29			  
7b29			  
7b29			;keyscan:  
7b29			;  
7b29			;; for each key_row use keyscanr bit mask for out  
7b29			;; then read in for keyscanc bitmask  
7b29			;; save result of row scan to keyscantable  
7b29			;  
7b29			;; scan keyboard row 1  
7b29			;  
7b29			;	ld b, key_rows  
7b29			;	ld hl, key_scanr  
7b29			;	ld de, keyscan_table  
7b29			;  
7b29			;rowloop:  
7b29			;  
7b29			;	ld a,(hl)		; out bit mask to energise keyboard row  
7b29			;	call rowscan  
7b29			;	inc hl  
7b29			;	dec b  
7b29			;	jr nz, rowloop  
7b29			;  
7b29			;	ret  
7b29			;  
7b29			;  
7b29			;; pass a out bitmask, b row number  
7b29			;arowscan:   
7b29			;	push bc  
7b29			;  
7b29			;	ld d, b  
7b29			;  
7b29			;	; calculate buffer location for this row  
7b29			;  
7b29			;	ld hl, keyscan_table	  
7b29			;kbufr:  ld e, key_cols  
7b29			;kbufc:	inc hl  
7b29			;	dec e  
7b29			;	jr nz, kbufc  
7b29			;	dec d  
7b29			;	jr nz, kbufr  
7b29			;  
7b29			;	; energise row and read columns  
7b29			;  
7b29			;	out (portbdata),a  
7b29			;	in a,(portbdata)  
7b29			;	ld c,a  
7b29			;  
7b29			;  
7b29			;	; save buffer loc  
7b29			;  
7b29			;	ld (keybufptr), hl  
7b29			;  
7b29			;	ld hl, key_scanc  
7b29			;	ld d, key_cols  
7b29			;  
7b29			;	; for each column check each bit mask  
7b29			;  
7b29			;colloop:  
7b29			;	  
7b29			;  
7b29			;	; reset flags for the row   
7b29			;  
7b29			;	ld b,'.'  
7b29			;	and (hl)  
7b29			;	jr z, maskskip  
7b29			;	ld b,'#'  
7b29			;maskskip:  
7b29			;	; save  key state  
7b29			;	push hl  
7b29			;	ld hl, (keybufptr)  
7b29			;	ld (hl), b  
7b29			;	inc hl  
7b29			;	ld (keybufptr), hl  
7b29			;  
7b29			;	; move to next bit mask  
7b29			;	pop hl  
7b29			;	inc hl  
7b29			;  
7b29			;	dec d  
7b29			;	jr nz, colloop  
7b29			;  
7b29			;	ret  
7b29			;  
7b29			;  
7b29			;;  
7b29			; lcd functions  
7b29			;  
7b29			;  
7b29			  
7b29			;if DEBUG_KEY_MATRIX  
7b29			  
7b29			; test function to display hardware view of matrix state  
7b29			  
7b29			matrixold:  
7b29			  
7b29			  
7b29			  
7b29			; reset counter  
7b29 3e 80		ld a, 128  
7b2b d3 c1		out (portbdata),a  
7b2d			; scan keyboard row 1  
7b2d 3e 00		ld a, 0  
7b2f d3 c1		out (portbdata),a  
7b31			;ld a, 64  
7b31			;out (portbdata),a  
7b31 3e 80			ld a, 128  
7b33 21 f2 fe			ld hl, keyscan_table_row1  
7b36 cd 8f 7b			call .rowscan  
7b39			  
7b39			;ld a, 0  
7b39			;out (portbdata),a  
7b39 3e 40		ld a, 64  
7b3b d3 c1		out (portbdata),a  
7b3d 3e 40			ld a, 64  
7b3f 21 e7 fe			ld hl, keyscan_table_row2  
7b42 cd 8f 7b			call .rowscan  
7b45			  
7b45 3e 00		ld a, 0  
7b47 d3 c1		out (portbdata),a  
7b49			;ld a, 64  
7b49			;out (portbdata),a  
7b49 3e 20			ld a, 32  
7b4b 21 dc fe			ld hl, keyscan_table_row3  
7b4e cd 8f 7b			call .rowscan  
7b51			  
7b51			;ld a, 0  
7b51			;out (portbdata),a  
7b51 3e 40		ld a, 64  
7b53 d3 c1		out (portbdata),a  
7b55 3e 10			ld a, 16  
7b57 21 d1 fe			ld hl, keyscan_table_row4  
7b5a cd 8f 7b			call .rowscan  
7b5d			  
7b5d			; Display text on first line  
7b5d 3e 00		            LD   A, kLCD_Line1  
7b5f cd 97 77		            CALL fLCD_Pos       ;Position cursor to location in A  
7b62 11 f2 fe		            LD   DE, keyscan_table_row1  
7b65			            ;LD   DE, MsgHello  
7b65 cd b9 77		            CALL fLCD_Str       ;Display string pointed to by DE  
7b68			  
7b68			; Display text on second line  
7b68 3e 28		            LD   A, kLCD_Line2  
7b6a cd 97 77		            CALL fLCD_Pos       ;Position cursor to location in A  
7b6d 11 e7 fe		            LD   DE, keyscan_table_row2  
7b70 cd b9 77		            CALL fLCD_Str       ;Display string pointed to by DE  
7b73 3e 50		            LD   A, kLCD_Line3  
7b75 cd 97 77		            CALL fLCD_Pos       ;Position cursor to location in A  
7b78 11 dc fe		            LD   DE, keyscan_table_row3  
7b7b cd b9 77		            CALL fLCD_Str       ;Display string pointed to by DE  
7b7e 3e 78		            LD   A, kLCD_Line4  
7b80 cd 97 77		            CALL fLCD_Pos       ;Position cursor to location in A  
7b83 11 d1 fe		            LD   DE, keyscan_table_row4  
7b86 cd b9 77		            CALL fLCD_Str       ;Display string pointed to by DE  
7b89			  
7b89 cd d3 0c			call delay250ms  
7b8c c3 7a 7a			jp matrix  
7b8f			  
7b8f			; pass de as row display flags  
7b8f			.rowscan:   
7b8f			;	out (portbdata),a  
7b8f db c1			in a,(portbdata)  
7b91 4f				ld c,a  
7b92				; reset flags for the row   
7b92 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7b94 e6 01			and 1  
7b96 28 02			jr z, .p1on  
7b98 06 23			ld b,'#'  
7b9a			.p1on:  
7b9a 70				ld (hl), b  
7b9b 23				inc hl  
7b9c			  
7b9c 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7b9e 79				ld a,c  
7b9f e6 02			and 2  
7ba1			;	bit 0,a  
7ba1 28 02			jr z, .p2on  
7ba3 06 23			ld b,'#'  
7ba5			.p2on:  
7ba5 70				ld (hl), b  
7ba6 23				inc hl  
7ba7			;  
7ba7 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7ba9 79				ld a,c  
7baa e6 04			and 4  
7bac			;;	bit 0,a  
7bac 28 02			jr z, .p3on  
7bae 06 23			ld b,'#'  
7bb0			.p3on:  
7bb0 70				ld (hl), b  
7bb1 23				inc hl  
7bb2			;;  
7bb2 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7bb4			;;	bit 0,a  
7bb4 79				ld a,c  
7bb5 e6 08			and 8  
7bb7 28 02			jr z, .p4on  
7bb9 06 23			ld b,'#'  
7bbb			.p4on:  
7bbb 70				ld (hl), b  
7bbc 23				inc hl  
7bbd			  
7bbd 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7bbf			;;	bit 0,a  
7bbf 79				ld a,c  
7bc0 e6 10			and 16  
7bc2 28 02			jr z, .p5on  
7bc4 06 23			ld b,'#'  
7bc6			.p5on:  
7bc6 70				ld (hl), b  
7bc7 23				inc hl  
7bc8			; zero term  
7bc8 06 00			ld b,0  
7bca 70				ld (hl), b  
7bcb			  
7bcb c9			.rscandone: ret  
7bcc			  
7bcc			;addatohl:  
7bcc			;  
7bcc			 ;add   a, l    ; A = A+L  
7bcc			  ;  ld    l, a    ; L = A+L  
7bcc			   ; adc   a, h    ; A = A+L+H+carry  
7bcc			   ; sub   l       ; A = H+carry  
7bcc			   ; ld    h, a    ; H = H+carry  
7bcc			  
7bcc			;ret  
7bcc			; eof  
# End of file firmware_key_5x10.asm
7bcc			;include "firmware_key_4x10.asm" 
7bcc			 
7bcc			heap_size:    equ heap_end - heap_start 
7bcc			;eof 
# End of file os_mega.asm
7bcc
