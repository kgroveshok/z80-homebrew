# File os_mega.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			tos:	equ 0fffdh 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			SOUND_ENABLE: equ 1 
0000			 
0000			; Number of bytes available in heap   TODO make all of user ram 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 23 19			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			;        nop  
0003			;        nop 
0003			;;	org 05h		; null out bdos call 
0003			; 
0003			;        nop  
0003			;        nop  
0003			;        nop 
0003			;;	org 08h 
0003			;;; 
0003			;;	jp cin		; rst 8 - char in 
0003			;;; 
0003			; 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;	org 010h 
0003			;; 
0003			;	jp cout		; rest 010h  - char out 
0003			;; 
0003			;	org 01bh   
0003			; 
0003			;	;jp  		; rst 01bh   - write string to display 
0003			;	jp str_at_display 
0003			; 
0003			; 
0003			;	org 020h 
0003			; 
0003			;	; jp		 ; rst 020h - read char at screen location 
0003			; 
0003			;	org 028h 
0003			 
0003				; jp		 ; rst 028h  - storage i/o 
0003			 
0003			; 	org 030h 
0003			;	jp break_point_state 
0003			  
0003			; $30  
0003			; org 038h 
0003			; $38 
0003			 
0003			; TODO any more important entry points to add to jump table for easier coding use? 
0003			 
0003			 
0003			include "firmware.asm" 
0003			  
0003			; main constants (used here and in firmware)  
0003			  
0003			; TODO have page 0 of storage as bios  
0003			  
0003			Device_A: equ 0h  
0003			Device_B: equ 040h          ; Sound  
0003			  
0003			if BASE_KEV  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_SC114  
0003			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			; TODO fixup for CPM  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			Device_D: equ 0c0h             ; Keyboard and LCD  
0003			  
0003			; Odd specific debug points for testing hardware dev  
0003			  
0003			DEBUG_SOUND: equ 1  
0003			DEBUG_STK_FAULT: equ 0  
0003			DEBUG_INPUT: equ 0     ; Debug input entry code  
0003			DEBUG_KEYCINWAIT: equ 0  
0003			DEBUG_KEYCIN: equ 0  
0003			DEBUG_KEY: equ 0  
0003			DEBUG_KEY_MATRIX: equ 0  
0003			DEBUG_STORECF: equ 0  
0003			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
0003			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
0003			DEBUG_SPI: equ 0    ; low level spi tests  
0003			  
0003			; Enable many break points  
0003			  
0003			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
0003			DEBUG_FORTH_JP: equ 0    ; 4  
0003			DEBUG_FORTH_MALLOC: equ 0  
0003			DEBUG_FORTH_MALLOC_INT: equ 0  
0003			DEBUG_FORTH_DOT: equ 0  
0003			DEBUG_FORTH_DOT_WAIT: equ 0  
0003			DEBUG_FORTH_MATHS: equ 0  
0003			DEBUG_FORTH_TOK: equ 0    ; 4  
0003			DEBUG_FORTH_PARSE: equ 0    ; 3  
0003			DEBUG_FORTH: equ 0  ;2  
0003			DEBUG_FORTH_WORDS: equ 1   ; 1  
0003			DEBUG_FORTH_PUSH: equ 1   ; 1  
0003			DEBUG_FORTH_UWORD: equ 1   ; 1  
0003			  
0003			; Enable key point breakpoints  
0003			  
0003			DEBUG_FORTH_DOT_KEY: equ 0  
0003			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
0003			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
0003			  
0003			; Debug stack imbalances  
0003			  
0003			ON: equ 1  
0003			OFF: equ 0  
0003			  
0003			DEBUG_STACK_IMB: equ 0  
0003			STACK_IMB_STORE: equ 20  
0003			  
0003			; House keeping and protections  
0003			  
0003			DEBUG_FORTH_STACK_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
0003			FORTH_ENABLE_FREE: equ 0  
0003			FORTH_ENABLE_MALLOCFREE: equ 1  
0003			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
0003			FORTH_ENABLE_FLOATMATH: equ 0  
0003			  
0003			  
0003			CALLMONITOR: macro  
0003				call break_point_state  
0003				endm  
0003			  
0003			MALLOC_1: equ 1        ; from dk88   
0003			MALLOC_2: equ 0           ; broke  
0003			MALLOC_3: equ 0           ; really broke  
0003			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
0003			  
0003			if BASE_KEV   
0003			stacksize: equ 512*2  
0003			  
0003			STACK_RET_SIZE: equ 128  
0003			STACK_LOOP_SIZE: equ 512  
0003			STACK_DATA_SIZE: equ 512  
0003			endif  
0003			if BASE_SC114  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			;if STORAGE_SE == 0  
0003			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
0003			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
0003			;endif  
0003			  
0003			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
0003			  
0003			STORE_0_AUTOFILE: equ $21  
0003			STORE_0_BANKRUN: equ $23  
0003			STORE_0_FILERUN: equ $24  
0003			  
0003			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
0003			  
0003			STORE_0_AUTORUN: equ $20  
0003			  
0003			; Blocks where directory table is held  
0003			  
0003			; Reducing the number of entries increases the max file size  
0003			  
0003			;STORE_DIR_START: equ 1  
0003			;STORE_DIR_END: equ 33  
0003			  
0003			; Blocks from where file data is stored  
0003			  
0003			;STORE_DATA_START: equ STORE_DIR_END + 1  
0003			  
0003			; Block indicators (<32 are data files)  
0003			  
0003			;STORE_BLOCK_CFG: equ $8f       ; config block  
0003			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
0003			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
0003			;STORE_BLOCK_FREE: equ $85       ; data block free  
0003			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
0003			  
0003			  
0003			  
0003			; Directory entry flags  
0003			  
0003			;STORE_DIR_FREE: equ 0  
0003			;STORE_DIR_FILE:  equ 1  
0003			  
0003			; Structure offsets to directory entries  
0003			;STORE_DE_FLAG: equ 0  
0003			;STORE_DE_MAXEXT: equ 1  
0003			;STORE_DE_FILENAME: equ 2  
0003			  
0003			; Structure offsets to block 0  
0003			  
0003			;STORE_BK0_ISFOR: equ 1  
0003			;STORE_BK0_LABEL: equ 3  
0003			  
0003			; memory allocation   
0003			  
0003			chk_stund: equ tos+2           ; underflow check word  
0003			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
0003			  
0003			; keyscan table needs rows x cols buffer  
0003			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
0003			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
0003			  
0003			keyscan_table_row1: equ chk_stovr -key_cols-1  
0003			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
0003			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
0003			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
0003			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
0003			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
0003			keyscan_scancol: equ keyscan_table-key_cols  
0003			;keyscan_table_len: equ key_rows*key_cols  
0003			;keybufptr: equ keyscan_table - 2  
0003			;keysymbol: equ keybufptr - 1  
0003			key_held: equ keyscan_scancol-1	; currently held  
0003			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
0003			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
0003			key_fa: equ key_repeat_ct -1 ;  
0003			key_fb: equ key_fa -1 ;  
0003			key_fc: equ key_fb -1 ;  
0003			key_fd: equ key_fc -1 ;  
0003			key_face_held: equ key_fd - 1   
0003			  
0003			; flag for enabling/disabling various hardware diags   
0003			  
0003			hardware_diag: equ key_face_held - 1  
0003			  
0003			; hardware config switches  
0003			; TODO add bitmasks on includes for hardware  
0003			; high byte for expansion ids  
0003			;     0000 0000  no card inserted  
0003			;     0000 0001  storage card inserted  
0003			;     0000 0010  spi sd card active  
0003			  
0003			;       
0003			; low byte:  
0003			;     0000 0001   4x4 keypad  
0003			;     0000 0010   full keyboard  
0003			;     0000 0011   spi/ext keyboard  
0003			;     0000 0100   20x4 lcd  
0003			;     0000 1000   40x4 lcd  
0003			;     0000 1100   spi/ext display  
0003			;     0001 0000   ide interface available  
0003			  
0003			hardware_word: equ hardware_diag - 2  
0003			  
0003			; debug marker - optional display of debug point on the debug screens  
0003			  
0003			debug_mark: equ hardware_word - 4  
0003			  
0003			; input_str vars  
0003			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
0003			input_start:  equ input_ptr - 2    ; ptr to the start of string   
0003			input_size: equ input_start -1  ; number of chars  
0003			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
0003			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
0003			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
0003			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
0003			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
0003			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
0003			input_len: equ input_cur_onoff - 5 ; length of current input  
0003			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
0003			  
0003			CUR_BLINK_RATE: equ 15  
0003			  
0003			key_actual_pressed: equ input_cursor - 1   
0003			key_symbol: equ key_actual_pressed - 1   
0003			key_shift: equ key_symbol - 1   
0003			  
0003			; Display allocation  
0003			  
0003			;display_rows: equ 4     ; move out to mini and mega files  
0003			;display_cols: equ 20  
0003			  
0003			display_fb_len: equ display_rows*display_cols  
0003			  
0003			; primary frame buffer     
0003			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
0003			; working frame buffers  
0003			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
0003			display_fb3: equ  display_fb1-display_fb_len - 1  
0003			display_fb2: equ  display_fb3-display_fb_len - 1  
0003			;  
0003			; pointer to active frame buffer  
0003			display_fb_active: equ display_fb2 - 2  
0003			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
0003			display_write_tmp: equ display_lcde1e2 - 2  
0003			  
0003			  
0003			;  
0003			  
0003			;; can load into de directory  
0003			cursor_col: equ display_write_tmp-1  
0003			cursor_row: equ cursor_col-1  
0003			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
0003			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
0003			  
0003			; maths vars  
0003			  
0003			LFSRSeed: equ cursor_shape -20   
0003			randData: equ LFSRSeed - 2  
0003			xrandc: equ randData - 2  
0003			stackstore: equ xrandc - 2  
0003			seed1: equ  stackstore -2   
0003			seed2: equ seed1 - 2  
0003			  
0003			; cf storage vars  
0003			  
0003			iErrorNum:  equ seed2-1         ;Error number  
0003			iErrorReg:  equ iErrorNum -1              ;Error register  
0003			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
0003			  
0003			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
0003			  
0003			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
0003			  
0003			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
0003			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
0003			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
0003			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
0003			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
0003			store_tmpid: equ store_tmp3 - 1		; page temp id  
0003			store_tmpext: equ store_tmpid - 1		; file extent temp  
0003			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
0003			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
0003			store_filecache: equ store_openmaxext-(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
0003			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
0003			;  
0003			; spi vars  
0003			  
0003			  
0003			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
0003			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
0003			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
0003			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
0003			spi_device_id: equ spi_device - 1    ; human readable bank number  
0003			  
0003			;;;;; forth cli params  
0003			  
0003			; TODO use a different frame buffer for forth???  
0003			  
0003			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
0003			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
0003			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
0003			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
0003			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
0003			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
0003			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
0003			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
0003			  
0003			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
0003			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
0003			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
0003			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
0003			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
0003			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
0003			  
0003			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
0003			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
0003			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
0003			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
0003			chk_data_ovr: equ cli_data_stack -2; overflow check word  
0003			  
0003			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
0003			  
0003			; os/forth token vars  
0003			  
0003			os_last_cmd: equ os_var_array-255  
0003			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
0003			os_current_i: equ os_cli_cmd-2  
0003			os_cur_ptr: equ os_current_i-2  
0003			os_word_scratch: equ os_cur_ptr-30  
0003			os_tok_len: equ os_word_scratch - 2  
0003			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
0003			os_tok_malloc: equ os_tok_ptr - 2  
0003			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
0003			os_input: equ os_last_new_uword-255  
0003			execscratch: equ os_input-255        ; exec cmd eval buffer  
0003			scratch: equ execscratch-255  
0003			  
0003			  
0003			; temp locations for new word processing to save on adding more   
0003			  
0003			os_new_malloc: equ scratch-2  
0003			os_new_parse_len: equ os_new_malloc - 2  
0003			os_new_word_len: equ os_new_parse_len - 2  
0003			os_new_work_ptr: equ os_new_word_len - 2  
0003			os_new_src_ptr: equ os_new_work_ptr - 2  
0003			os_new_exec: equ os_new_src_ptr - 2  
0003			os_new_exec_ptr: equ os_new_exec - 2  
0003			  
0003			; resume memory alloocations....  
0003			  
0003			os_view_disable: equ os_new_exec_ptr - 1  
0003			os_view_af: equ os_view_disable - 2  
0003			os_view_hl: equ os_view_af -2  
0003			os_view_de: equ os_view_hl - 2  
0003			os_view_bc: equ os_view_de - 2  
0003			  
0003			; stack checksum word  
0003			if DEBUG_STACK_IMB  
0003				curframe: equ  os_view_de - 5  
0003				store_sp: equ curframe - (STACK_IMB_STORE*4)  
0003				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			else  
0003				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			endif  
0003			  
0003			; with data stack could see memory filled with junk. need some memory management   
0003			; malloc and free entry points added  
0003			  
0003			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
0003			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			;heap_end: equ free_list-1  ; Starting address of heap  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			heap_end: equ chk_word-1  ; Starting address of heap  
0003			  
0003			  
0003			;if BASE_KEV   
0003			;heap_start: equ 0800eh  ; Starting address of heap  
0003			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;heap_start: equ baseram+15  ; Starting address of heap  
0003			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;endif  
0003			  
0003			  
0003			;;;;  
0003			  
0003			  
0003			; change below to point to last memory alloc above  
0003			topusermem:  equ   heap_start  
0003			  
0003			;if BASE_KEV   
0003			;baseusermem: equ 08000h  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;;aseusermem:     equ    12  
0003			;baseusermem:     equ    prompt  
0003			;;baseusermem:     equ    endofcode  
0003			;endif  
0003			  
0003			  
0003			; **********************************************************************  
0003			; **  Constants  
0003			; **********************************************************************  
0003			  
0003			; Constants used by this code module  
0003			kDataReg:   EQU Device_D           ;PIO port A data register  
0003			kContReg:   EQU Device_D+2           ;PIO port A control register  
0003			  
0003			  
0003			portbdata:  equ Device_D+1    ; port b data  
0003			portbctl:   equ Device_D+3    ; port b control  
0003			  
0003			  
0003			;KEY_SHIFT:   equ 5  
0003			;KEY_SYMBOLSHIFT:  equ 6  
0003			  
0003			KEY_SHIFTLOCK: equ 4  
0003			  
0003			  
0003			KEY_UP: equ 5  
0003			KEY_NEXTWORD: equ 6  
0003			KEY_PREVWORD: equ 7  
0003			KEY_BS: equ 8  
0003			KEY_TAB:  equ 9  
0003			KEY_DOWN: equ 10  
0003			KEY_LEFT: equ 11  
0003			KEY_RIGHT: equ 12  
0003			KEY_CR:   equ 13  
0003			KEY_HOME: equ 14  
0003			KEY_END: equ 15  
0003			  
0003			KEY_F1: equ 16  
0003			KEY_F2: equ 17  
0003			KEY_F3: equ 18  
0003			KEY_F4: equ 19  
0003			  
0003			KEY_F5: equ 20  
0003			KEY_F6: equ 21  
0003			KEY_F7: equ 22  
0003			KEY_F8: equ 23  
0003			  
0003			KEY_F9: equ 24  
0003			KEY_F10: equ 25  
0003			KEY_F11: equ 26  
0003			KEY_F12: equ 27  
0003			  
0003			;if DEBUG_KEY  
0003			;	KEY_MATRIX_NO_PRESS: equ '.'  
0003			;	KEY_SHIFT:   equ '.'  
0003			;	KEY_SYMBOLSHIFT:  equ '.'  
0003			;else  
0003				KEY_SHIFT:   equ '~'  
0003				KEY_SYMBOLSHIFT:  equ '~'  
0003				KEY_MATRIX_NO_PRESS: equ '~'  
0003			;endi  
0003			  
0003			  
0003			  
0003			  
0003			; Macro to make adding debug marks easier  
0003			  
0003			DMARK: macro str  
0003				push af  
0003				ld a, (.dmark)  
0003				ld (debug_mark),a  
0003				ld a, (.dmark+1)  
0003				ld (debug_mark+1),a  
0003				ld a, (.dmark+2)  
0003				ld (debug_mark+2),a  
0003				jr .pastdmark  
0003			.dmark: db str  
0003			.pastdmark: pop af  
0003			  
0003			endm  
0003			  
0003			  
0003			; macro to detect for stack imbalances  
0003			  
0003			include "stackimbal.asm"  
0003			; Macro and code to detect stock imbalances 
0003			 
0003			SPPUSH: equ 0 
0003			 
0003			; Add a stack frame which can be checked before return 
0003			 
0003			STACKFRAME: macro onoff frame1 frame2 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003						exx 
0003			 
0003						ld de, frame1 
0003						ld a, d 
0003						ld hl, curframe 
0003						call hexout 
0003						ld a, e 
0003						ld hl, curframe+2 
0003						call hexout 
0003			  
0003						ld hl, frame1 
0003						push hl 
0003						ld hl, frame2 
0003						push hl 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			endm 
0003			 
0003			STACKFRAMECHK: macro onoff frame1 frame2 
0003			 
0003					 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						exx 
0003						; check stack frame SP 
0003			 
0003						ld hl, frame2 
0003						pop de   ; frame2 
0003			 
0003						call cmp16 
0003						jr nz, .spnosame 
0003						 
0003			 
0003						ld hl, frame1 
0003						pop de   ; frame1 
0003			 
0003						call cmp16 
0003						jr z, .spfrsame 
0003			 
0003						.spnosame: call showsperror 
0003			 
0003						.spfrsame: nop 
0003			 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			 
0003			 
0003			endm 
0003			 
0003			 
0003			; for a sub routine, wrap SP collection and comparisons 
0003			 
0003			; Usage: 
0003			; 
0003			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
0003			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
0003			 
0003			SAVESP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003			 
0003						ld (store_sp+(storeword*4)), sp 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			CHECKSP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003			 
0003						; save SP after last save 
0003				 
0003						ld (store_sp+(storeword*4)+2), sp 
0003			 
0003						push hl 
0003						ld hl, store_sp+(storeword*4) 
0003						call check_stack_sp  
0003						pop hl 
0003			 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			if DEBUG_STACK_IMB 
0003			 
0003			check_stack_sp: 
0003					push de 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					push de 
0003			 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					pop hl 
0003			 
0003			 
0003					; check to see if the same 
0003			 
0003					call cmp16 
0003					jr z, .spsame 
0003			 
0003					; not same 
0003			 
0003					call showsperror 
0003			.spsame: 
0003			 
0003					pop de 
0003			 
0003					ret 
0003			 
0003			.sperr:  db "Stack imbalance",0 
0003			 
0003			 
0003			showsperror: 
0003			 
0003			 
0003				push hl 
0003				push af 
0003				push de 
0003				call clear_display 
0003				ld de, .sperr 
0003				ld a,0 
0003			;	ld de,os_word_scratch 
0003				call str_at_display 
0003				ld a, display_row_1+17 
0003				ld de, debug_mark 
0003				call str_at_display 
0003				ld a, 0 
0003				ld (curframe+4),a 
0003				ld hl, curframe 
0003				ld de, os_word_scratch 
0003				ld a, display_row_4 
0003				call str_at_display 
0003				call update_display 
0003				;call break_point_state 
0003				call cin_wait 
0003			 
0003				ld a, ' ' 
0003				ld (os_view_disable), a 
0003				pop de	 
0003				pop af 
0003				pop hl 
0003				CALLMONITOR 
0003				ret 
0003			 
0003			endif 
0003			 
0003			 
0003			 
0003			; eof 
# End of file stackimbal.asm
0003			  
0003			;TODO macro to calc col and row offset into screen  
0003			  
0003			  
0003			  
0003			hardware_init:  
0003			  
0003 3e 00				ld a, 0  
0005 32 7d fb				ld (hardware_diag), a  
0008			  
0008					; clear all the buffers  
0008			  
0008 21 1c fa				ld hl, display_fb1  
000b 22 d8 f8				ld (display_fb_active), hl  
000e			  
000e cd d5 0a				call clear_display  
0011			  
0011 21 da f8				ld hl, display_fb2  
0014 22 d8 f8				ld (display_fb_active), hl  
0017			  
0017 cd d5 0a				call clear_display  
001a			  
001a					; init primary frame buffer area  
001a 21 bd fa				ld hl, display_fb0  
001d 22 d8 f8				ld (display_fb_active), hl  
0020			  
0020 cd d5 0a				call clear_display  
0023			  
0023			  
0023 cd 4f 65				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0026			  
0026 cd e6 67			call key_init  
0029 cd cc 01			call storage_init  
002c			  
002c				; setup malloc functions  
002c			  
002c				if MALLOC_1  
002c cd ac 11				call  heap_init  
002f				endif  
002f				if MALLOC_4  
002f					call  heap_init  
002f				endif  
002f			  
002f				; init sound hardware if present  
002f			  
002f				if SOUND_ENABLE  
002f cd 69 13				call sound_init  
0032				endif  
0032			  
0032				; lcd test sequence  
0032					  
0032 cd f8 0a			call update_display  
0035 cd 55 0a			call delay1s  
0038 3e 2b			ld a,'+'  
003a cd da 0a			call fill_display  
003d cd f8 0a			call update_display  
0040 cd 55 0a			call delay1s  
0043 3e 2a			ld a,'*'  
0045 cd da 0a			call fill_display  
0048 cd f8 0a			call update_display  
004b cd 55 0a			call delay1s  
004e 3e 2d			ld a,'-'  
0050 cd da 0a			call fill_display  
0053 cd f8 0a			call update_display  
0056 cd 55 0a			call delay1s  
0059			  
0059			; boot splash screen  
0059			if display_cols == 20	  
0059			        ld a, display_row_1    
0059			else  
0059 3e 0a		        ld a, display_row_1 +10   
005b			endif  
005b 11 8c 00			ld de, bootmsg  
005e cd e8 0a			call str_at_display  
0061 cd f8 0a			call update_display  
0064			  
0064			  
0064 cd 55 0a			call delay1s  
0067 cd 55 0a			call delay1s  
006a			if display_cols == 20	  
006a			            LD   A, display_row_3+2  
006a			else  
006a 3e 5c		            LD   A, display_row_3+12  
006c			endif  
006c 11 a1 00			ld de, bootmsg1  
006f cd e8 0a			call str_at_display  
0072 cd f8 0a			call update_display  
0075 cd 55 0a			call delay1s  
0078 cd 55 0a			call delay1s  
007b			  
007b			;	ld a, display_row_4+3  
007b			;	ld de, bootmsg2  
007b			;	call str_at_display  
007b			;	call update_display  
007b			;	call delay1s  
007b			;	call delay1s  
007b			  
007b			; debug mark setup  
007b			  
007b 3e 5f		ld a, '_'  
007d 32 77 fb		ld (debug_mark),a  
0080 32 78 fb		ld (debug_mark+1),a  
0083 32 79 fb		ld (debug_mark+2),a  
0086 3e 00		ld a,0  
0088 32 7a fb		ld (debug_mark+3),a  
008b			  
008b c9					ret  
008c			  
008c			  
008c .. 00		bootmsg:	db "z80-homebrew OS v1.5",0  
00a1 .. 00		bootmsg1:	db "by Kevin Groves",0  
00b1			;bootmsg2:	db "Firmware v0.1",0  
00b1			  
00b1			; a 4x20 lcd  
00b1			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00b1			  
00b1			;if display_cols == 20  
00b1			;	include "firmware_lcd_4x20.asm"  
00b1			;endif  
00b1			  
00b1			;if display_cols == 40  
00b1			;	include "firmware_lcd_4x40.asm"  
00b1			;endif  
00b1			  
00b1			;  
00b1			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00b1			; TODO abstract the bit bang video out interface for dual display  
00b1			; TODO wire video out to tx pin on rc2014 bus  
00b1			  
00b1			; must supply cin, and cin_wait for low level hardware abstraction   
00b1			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00b1			; test scancode  
00b1			  
00b1			;;;;;  
00b1			;;;  
00b1			; Moved out to mini and maxi versions  
00b1			;  
00b1			; include "firmware_key_4x4.asm"  
00b1			; using existing 4 wire x 4 resistor array for input  
00b1			;include "firmware_key_4x10.asm"  
00b1			; need to mod the board for 5 rows due to resistor array  
00b1			;include "firmware_key_5x10.asm"  
00b1			  
00b1			; storage hardware interface  
00b1			  
00b1			; use microchip serial eeprom for storage  
00b1			  
00b1			  
00b1			if STORAGE_SE  
00b1				include "firmware_spi.asm"  
00b1			; my spi protocol (used by storage) 
00b1			 
00b1			; SPI pins 
00b1			 
00b1			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00b1			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00b1			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00b1			 
00b1			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00b1			; chip pin 4 gnd 
00b1			 
00b1			 
00b1			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00b1			SPI_CE1: equ 1      ;    port a1 pin 14  
00b1			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00b1			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00b1			SPI_CE4: equ 4      ; port a4     pin 10 
00b1			 
00b1			; active low AND masks 
00b1			 
00b1			;SPI_CE0_MASK: equ    255-1 
00b1			;SPI_CE1_MASK: equ   255-2 
00b1			;SPI_CE2_MASK: equ   255-4 
00b1			;SPI_CE3_MASK: equ   255-8 
00b1			;SPI_CE4_MASK: equ   255-16 
00b1			SPI_CE_HIGH:  equ 255 
00b1			 
00b1			 
00b1			 
00b1			 
00b1			; TODO store port id for spi device ie dev c 
00b1			; TODO store pin for SO 
00b1			; TODO store pin for SI 
00b1			; TODO store pin for SCLK 
00b1			 
00b1			; 
00b1			 
00b1			; ensure that spi bus is in a stable state with default pins  
00b1			 
00b1			se_stable_spi:   
00b1			 
00b1				 ; set DI high, CE high , SCLK low 
00b1				;ld a, SPI_DI | SPI_CE0 
00b1 3e 07			ld a, SPI_DI  
00b3 cd 87 01			call spi_ce_high 
00b6 d3 80			 out (storage_adata),a 
00b8 32 49 f8			ld (spi_portbyte),a 
00bb			 
00bb				if DEBUG_SPI 
00bb					push hl 
00bb					ld l, a 
00bb					DMARK "SPI" 
00bb					CALLMONITOR 
00bb					pop hl 
00bb				endif 
00bb c9				ret 
00bc			 
00bc			; byte to send in a 
00bc			 
00bc			spi_send_byte: 
00bc				; save byte to send for bit mask shift out 
00bc 4f			        ld c,a 
00bd 3a 49 f8			ld a,(spi_portbyte) 
00c0				  
00c0				; clock out	each bit of the byte msb first 
00c0			 
00c0 06 08			ld b, 8 
00c2			.ssb1: 
00c2				; clear so bit  
00c2 cb bf			res SPI_DI, a 
00c4 cb 11			rl c 
00c6				; if bit 7 is set then carry is set 
00c6 30 02			jr nc, .ssb2 
00c8 cb ff			set SPI_DI,a 
00ca			.ssb2:  ; output bit to ensure it is stable 
00ca d3 80			out (storage_adata),a 
00cc 00				nop 
00cd				; clock bit high 
00cd cb ef			set SPI_SCLK,a 
00cf d3 80			out (storage_adata),a 
00d1 00				nop 
00d2				; then low 
00d2 cb af			res SPI_SCLK,a 
00d4 d3 80			out (storage_adata),a 
00d6 00				nop 
00d7 10 e9			djnz .ssb1 
00d9			 
00d9 32 49 f8			ld (spi_portbyte),a 
00dc c9				ret 
00dd			 
00dd			; TODO low level get byte into A on spi 
00dd			 
00dd			spi_read_byte:  
00dd			 
00dd				; save byte to send for bit mask shift out 
00dd 0e 00		    ld c,0 
00df 3a 49 f8			ld a,(spi_portbyte) 
00e2				  
00e2				; clock out	each bit of the byte msb first 
00e2			 
00e2			 
00e2				; clock bit high 
00e2 cb ef			set SPI_SCLK,a 
00e4 d3 80			out (storage_adata),a 
00e6 00				nop 
00e7			 
00e7			    ; read DO  
00e7			 
00e7 cb f9		    set 7,c 
00e9 db 80			in a,(storage_adata) 
00eb cb 77		    bit SPI_DO,a 
00ed 20 02		    jr nz, .b7 
00ef cb b9		    res 7,c 
00f1			.b7: 
00f1				; then low 
00f1 cb af			res SPI_SCLK,a 
00f3 d3 80			out (storage_adata),a 
00f5 00				nop 
00f6			     
00f6			 
00f6				; clock bit high 
00f6 cb ef			set SPI_SCLK,a 
00f8 d3 80			out (storage_adata),a 
00fa 00				nop 
00fb			 
00fb			    ; read DO  
00fb			 
00fb cb f1		    set 6,c 
00fd db 80			in a,(storage_adata) 
00ff cb 77		    bit SPI_DO,a 
0101 20 02		    jr nz, .b6 
0103 cb b1		    res 6,c 
0105			.b6: 
0105				; then low 
0105 cb af			res SPI_SCLK,a 
0107 d3 80			out (storage_adata),a 
0109 00				nop 
010a			 
010a				; clock bit high 
010a cb ef			set SPI_SCLK,a 
010c d3 80			out (storage_adata),a 
010e 00				nop 
010f			 
010f			 
010f			    ; read DO  
010f			 
010f cb e9		    set 5,c 
0111 db 80			in a,(storage_adata) 
0113 cb 77		    bit SPI_DO,a 
0115 20 02		    jr nz, .b5 
0117 cb a9		    res 5,c 
0119			.b5: 
0119				; then low 
0119 cb af			res SPI_SCLK,a 
011b d3 80			out (storage_adata),a 
011d 00				nop 
011e				; clock bit high 
011e cb ef			set SPI_SCLK,a 
0120 d3 80			out (storage_adata),a 
0122 00				nop 
0123			 
0123			    ; read DO  
0123			 
0123 cb e1		    set 4,c 
0125 db 80			in a,(storage_adata) 
0127 cb 77		    bit SPI_DO,a 
0129 20 02		    jr nz, .b4 
012b cb a1		    res 4,c 
012d			.b4: 
012d				; then low 
012d cb af			res SPI_SCLK,a 
012f d3 80			out (storage_adata),a 
0131 00				nop 
0132				; clock bit high 
0132 cb ef			set SPI_SCLK,a 
0134 d3 80			out (storage_adata),a 
0136 00				nop 
0137			 
0137			    ; read DO  
0137			 
0137 cb d9		    set 3,c 
0139 db 80			in a,(storage_adata) 
013b cb 77		    bit SPI_DO,a 
013d 20 02		    jr nz, .b3 
013f cb 99		    res 3,c 
0141			.b3: 
0141				; then low 
0141 cb af			res SPI_SCLK,a 
0143 d3 80			out (storage_adata),a 
0145 00				nop 
0146				; clock bit high 
0146 cb ef			set SPI_SCLK,a 
0148 d3 80			out (storage_adata),a 
014a 00				nop 
014b			 
014b			    ; read DO  
014b			 
014b cb d1		    set 2,c 
014d db 80			in a,(storage_adata) 
014f cb 77		    bit SPI_DO,a 
0151 20 02		    jr nz, .b2 
0153 cb 91		    res 2,c 
0155			.b2: 
0155				; then low 
0155 cb af			res SPI_SCLK,a 
0157 d3 80			out (storage_adata),a 
0159 00				nop 
015a				; clock bit high 
015a cb ef			set SPI_SCLK,a 
015c d3 80			out (storage_adata),a 
015e 00				nop 
015f			 
015f			    ; read DO  
015f			 
015f cb c9		    set 1,c 
0161 db 80			in a,(storage_adata) 
0163 cb 77		    bit SPI_DO,a 
0165 20 02		    jr nz, .b1 
0167 cb 89		    res 1,c 
0169			.b1: 
0169				; then low 
0169 cb af			res SPI_SCLK,a 
016b d3 80			out (storage_adata),a 
016d 00				nop 
016e				; clock bit high 
016e cb ef			set SPI_SCLK,a 
0170 d3 80			out (storage_adata),a 
0172 00				nop 
0173			 
0173			    ; read DO  
0173			 
0173 cb c1		    set 0,c 
0175 db 80			in a,(storage_adata) 
0177 cb 77		    bit SPI_DO,a 
0179 20 02		    jr nz, .b0 
017b cb 81		    res 0,c 
017d			.b0: 
017d				; then low 
017d cb af			res SPI_SCLK,a 
017f d3 80			out (storage_adata),a 
0181 00				nop 
0182			 
0182			 
0182 32 49 f8			ld (spi_portbyte),a 
0185			 
0185			    ; return byte 
0185 79			    ld a,c 
0186			 
0186			 
0186 c9				ret 
0187			 
0187			 
0187			 
0187			spi_ce_high: 
0187			 
0187				if DEBUG_SPI_HARD_CE0 
0187			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0187					ret 
0187			 
0187				endif 
0187			 
0187			 
0187 f5				push af 
0188			 
0188				; send direct ce to port b 
0188 3e ff			ld a, 255 
018a d3 81			out (storage_bdata), a 
018c			 
018c f1				pop af 
018d			 
018d				; for port a that shares with spi lines AND the mask 
018d			  
018d				if DEBUG_SPI 
018d					push hl 
018d					ld h, a 
018d				endif 
018d			;	ld c, SPI_CE_HIGH 
018d			;	and c 
018d cb c7			set SPI_CE0, a 
018f cb cf			set SPI_CE1, a 
0191 cb d7			set SPI_CE2, a 
0193 cb df			set SPI_CE3, a 
0195 cb e7			set SPI_CE4, a 
0197			 
0197				if DEBUG_SPI 
0197					ld l, a 
0197					DMARK "CEh" 
0197					CALLMONITOR 
0197					pop hl 
0197				endif 
0197 c9				ret 
0198			 
0198			 
0198			spi_ce_low: 
0198			 
0198				if DEBUG_SPI_HARD_CE0 
0198			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0198					ret 
0198			 
0198				endif 
0198			 
0198 c5				push bc 
0199 f5				push af 
019a			 
019a				; send direct ce to port b 
019a 3a 4b f8			ld a, (spi_cartdev) 
019d d3 81			out (storage_bdata), a 
019f			 
019f			 
019f			 
019f				; for port a that shares with spi lines AND the mask 
019f			 
019f 3a 48 f8			ld a, (spi_device)  
01a2 4f				ld c, a 
01a3			 
01a3 f1				pop af 
01a4			 
01a4				; detect CEx 
01a4			 
01a4				if DEBUG_SPI 
01a4					push hl 
01a4					ld h, a 
01a4				endif 
01a4			 
01a4 cb 41			bit SPI_CE0, c 
01a6 20 04			jr nz, .cel1 
01a8 cb 87			res SPI_CE0, a 
01aa 18 1e			jr .celn 
01ac			.cel1: 
01ac cb 49			bit SPI_CE1, c 
01ae 20 04			jr nz, .cel2 
01b0 cb 8f			res SPI_CE1, a 
01b2 18 16			jr .celn 
01b4			.cel2: 
01b4 cb 51			bit SPI_CE2, c 
01b6 20 04			jr nz, .cel3 
01b8 cb 97			res SPI_CE2, a 
01ba 18 0e			jr .celn 
01bc			.cel3: 
01bc cb 59			bit SPI_CE3, c 
01be 20 04			jr nz, .cel4 
01c0 cb 9f			res SPI_CE3, a 
01c2 18 06			jr .celn 
01c4			.cel4: 
01c4 cb 61			bit SPI_CE4, c 
01c6 20 02			jr nz, .celn 
01c8 cb a7			res SPI_CE4, a 
01ca			.celn: 
01ca			 
01ca			 
01ca			 
01ca			;	add c 
01ca			 
01ca				if DEBUG_SPI 
01ca					ld l, a 
01ca					DMARK "CEl" 
01ca					CALLMONITOR 
01ca					pop hl 
01ca				endif 
01ca c1				pop bc 
01cb c9				ret 
01cc			 
01cc			 
01cc			 
01cc			; eof 
01cc			 
01cc			 
01cc			 
01cc			 
01cc			 
# End of file firmware_spi.asm
01cc				include "firmware_seeprom.asm"  
01cc			; 
01cc			; persisent storage interface via microchip serial eeprom 
01cc			 
01cc			; port a pio 2 
01cc			; pa 7 - si 
01cc			; pa 6 - sclk  
01cc			; pa 5 - so 
01cc			; pa 4 - cs 
01cc			; pa 3 - cs 
01cc			; pa 2 - cs 
01cc			; pa 1 - cs 
01cc			; pa 0 - cs 
01cc			; 
01cc			; TODO get block 
01cc			; TODO save block 
01cc			; TODO load file 
01cc			; TODO save file 
01cc			; TODO get dir  
01cc			 
01cc			;  
01cc			storage_adata: equ Device_C    ; device c port a - onboard storage 
01cc			storage_actl: equ Device_C+2     ; device c port a 
01cc			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
01cc			storage_bctl: equ Device_C+3     ; device c port b 
01cc			 
01cc			 
01cc			; TODO move these to hardware driver file 
01cc			 
01cc			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
01cc			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
01cc			; storage bank file system format 
01cc			; 
01cc			; first page of bank: 
01cc			; 	addr 0 - status check 
01cc			;       addr 1 - write protect flag 
01cc			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
01cc			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
01cc			;         TODO see if scanning whole of for available next file id is fast enough 
01cc			;	addr 4 > zero term string of bank label 
01cc			; 
01cc			;        
01cc			;  
01cc			; first page of any file: 
01cc			;      byte 0 - file id  
01cc			;      byte 1-17 - fixed file name  
01cc			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
01cc			; 
01cc			; other pages of any file: 
01cc			;      byte 0 - file id 
01cc			;      byte 1> - file data 
01cc			; 
01cc			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
01cc			;  
01cc			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
01cc			 
01cc			 
01cc			;storage_so_bit: 5 
01cc			;storage_si_bit: 7 
01cc			;storage_sclk_bit: 6 
01cc			  
01cc			 
01cc			; init storage pio 
01cc			 
01cc			storage_init: 
01cc			 
01cc 3e cf		            LD   A, 11001111b 
01ce d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
01d0 3e 00		            LD   A, 00000000b 
01d2 cb f7			set SPI_DO,a 
01d4			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
01d4 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
01d6			 
01d6 3e cf		            LD   A, 11001111b 
01d8 d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
01da 3e 00		            LD   A, 00000000b 
01dc d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
01de			 
01de				; set all external spi devices off 
01de 3e 00			ld a, 0 
01e0 32 48 f8			ld (spi_device), a 
01e3 32 4b f8			ld (spi_cartdev), a 
01e6			 
01e6					; ensure the spi bus is in a default stable state 
01e6 cd b1 00				call se_stable_spi 
01e9			 
01e9			; TODO scan spi bus and gather which storage banks are present 
01e9			 
01e9			; populate store_bank_active  
01e9			; for each ce line activate and attempt to write first byte of bank and read back 
01e9			; if zero is returned then bank is empty 
01e9			;   
01e9			; 
01e9			 
01e9					; init file extent cache to save on slow reads 
01e9			 
01e9			;	ld hl, store_filecache 
01e9			;	ld de, 0 
01e9			;	ld hl,(de)	 
01e9			 
01e9			 
01e9 c9			    ret 
01ea			 
01ea			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
01ea			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
01ea			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
01ea			 
01ea			; INSTRUCTION SET 
01ea			; READ 0000 0011 Read data from memory array beginning at selected address 
01ea			; WRITE 0000 0010 Write data to memory array beginning at selected address 
01ea			; WREN 0000 0110 Set the write enable latch (enable write operations) 
01ea			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
01ea			; RDSR 0000 0101 Read STATUS register 
01ea			; WRSR 0000 0001 Write STATUS register 
01ea			; PE 0100 0010 Page Erase – erase one page in memory array 
01ea			; SE 1101 1000 Sector Erase – erase one sector in memory array 
01ea			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
01ea			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
01ea			 
01ea			; TODO send byte steam for page without setting the address for every single byte 
01ea			; TODO read byte  
01ea			 
01ea			; byte in a 
01ea			; address in hl  
01ea			se_writebyte: 
01ea			        
01ea			    ;   ld c, a 
01ea f5			        push af 
01eb e5			        push hl 
01ec			 
01ec			    ; initi write mode 
01ec			    ; 
01ec			    ;CS low 
01ec			 
01ec 3a 49 f8		       ld a,(spi_portbyte) 
01ef cd 98 01			call spi_ce_low 
01f2			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01f2 d3 80		       out (storage_adata),a 
01f4 32 49 f8		       ld (spi_portbyte), a 
01f7			 
01f7			    ;clock out wren instruction 
01f7			 
01f7 3e 06		    ld a, store_wren_ins 
01f9 cd bc 00		    call spi_send_byte  
01fc			 
01fc			    ;cs high to enable write latch 
01fc			 
01fc 3a 49 f8		       ld a,(spi_portbyte) 
01ff cd 87 01			call spi_ce_high 
0202			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0202 d3 80		       out (storage_adata),a 
0204 32 49 f8		       ld (spi_portbyte), a 
0207			 
0207 00				nop 
0208			    ; 
0208			    ; intial write data 
0208			    ; 
0208			    ; cs low 
0208			     
0208 3a 49 f8		       ld a,(spi_portbyte) 
020b cd 98 01			call spi_ce_low 
020e			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
020e d3 80		       out (storage_adata),a 
0210 32 49 f8		       ld (spi_portbyte), a 
0213			 
0213			    ; clock out write instruction 
0213			     
0213 3e 02		    ld a, store_write_ins  
0215 cd bc 00		    call spi_send_byte  
0218			 
0218			    ; clock out address (depending on address size) 
0218			     
0218 e1			    pop hl 
0219 7c			    ld a,h    ; address out msb first 
021a cd bc 00		    call spi_send_byte  
021d 7d			    ld a,l 
021e cd bc 00		    call spi_send_byte  
0221			 
0221			    ; clock out byte(s) for page 
0221			 
0221 f1			    pop af 
0222 cd bc 00		    call spi_send_byte  
0225			 
0225			    ; end write with ce high 
0225 3a 49 f8		       ld a,(spi_portbyte) 
0228			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
0228 cd 87 01			call spi_ce_high 
022b d3 80		       out (storage_adata),a 
022d 32 49 f8		       ld (spi_portbyte), a 
0230			 
0230				; pause for internal write cycle 
0230 3e 0a			ld a, 10 
0232 cd 3a 0a			call aDelayInMS 
0235 c9			    ret 
0236			 
0236			; buffer to write in de 
0236			; address in hl  
0236			se_writepage: 
0236			        
0236			    ;   ld c, a 
0236 d5				push de 
0237 e5			        push hl 
0238			 
0238			    ; initi write mode 
0238			    ; 
0238			    ;CS low 
0238			 
0238 3a 49 f8		       ld a,(spi_portbyte) 
023b cd 98 01			call spi_ce_low 
023e			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
023e d3 80		       out (storage_adata),a 
0240 32 49 f8		       ld (spi_portbyte), a 
0243			 
0243			    ;clock out wren instruction 
0243			 
0243 3e 06		    ld a, store_wren_ins 
0245 cd bc 00		    call spi_send_byte  
0248			 
0248			    ;cs high to enable write latch 
0248			 
0248 3a 49 f8		       ld a,(spi_portbyte) 
024b cd 87 01			call spi_ce_high 
024e			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
024e d3 80		       out (storage_adata),a 
0250 32 49 f8		       ld (spi_portbyte), a 
0253			 
0253 00				nop 
0254			    ; 
0254			    ; intial write data 
0254			    ; 
0254			    ; cs low 
0254			     
0254 3a 49 f8		       ld a,(spi_portbyte) 
0257			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0257 cd 98 01			call spi_ce_low 
025a d3 80		       out (storage_adata),a 
025c 32 49 f8		       ld (spi_portbyte), a 
025f			 
025f			    ; clock out write instruction 
025f			     
025f 3e 02		    ld a, store_write_ins  
0261 cd bc 00		    call spi_send_byte  
0264			 
0264			    ; clock out address (depending on address size) 
0264			     
0264 e1			    pop hl 
0265 7c			    ld a,h    ; address out msb first 
0266 cd bc 00		    call spi_send_byte  
0269 7d			    ld a,l 
026a cd bc 00		    call spi_send_byte  
026d			 
026d			    ; clock out byte(s) for page 
026d			 
026d e1				pop hl 
026e 06 40			ld b, STORE_BLOCK_PHY 
0270			.bytewrite: 
0270			 
0270 7e				ld a,(hl) 
0271 e5			    push hl 
0272 c5				push bc 
0273 cd bc 00		    call spi_send_byte  
0276 c1				pop bc 
0277 e1				pop hl 
0278			 
0278			    ; end write with ce high 
0278 3a 49 f8		       ld a,(spi_portbyte) 
027b cd 87 01			call spi_ce_high 
027e			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
027e d3 80		       out (storage_adata),a 
0280 32 49 f8		       ld (spi_portbyte), a 
0283			 
0283 23				inc hl 
0284 10 ea			djnz .bytewrite 
0286			 
0286				; pause for internal write cycle 
0286 3e 64			ld a, 100 
0288 cd 3a 0a			call aDelayInMS 
028b c9			    ret 
028c			; returns byte in a 
028c			; address in hl  
028c			se_readbyte: 
028c d5				push de 
028d c5				push bc 
028e			 
028e			    ;   ld c, a 
028e e5			        push hl 
028f			 
028f			    ; initi write mode 
028f			    ; 
028f			    ;CS low 
028f			 
028f 3a 49 f8		       ld a,(spi_portbyte) 
0292 cd 98 01			call spi_ce_low 
0295			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0295 d3 80		       out (storage_adata),a 
0297 32 49 f8		       ld (spi_portbyte), a 
029a			 
029a			    ;clock out wren instruction 
029a			 
029a 3e 03		    ld a, store_read_ins 
029c cd bc 00		    call spi_send_byte  
029f			 
029f			 
029f			    ; clock out address (depending on address size) 
029f			     
029f e1			    pop hl 
02a0 7c			    ld a,h    ; address out msb first 
02a1 cd bc 00		    call spi_send_byte  
02a4 7d			    ld a,l 
02a5 cd bc 00		    call spi_send_byte  
02a8			 
02a8			    ; clock in byte(s) for page 
02a8			 
02a8 cd dd 00		    call spi_read_byte  
02ab f5				push af 
02ac			 
02ac			    ; end write with ce high 
02ac 3a 49 f8		       ld a,(spi_portbyte) 
02af			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02af cd 87 01			call spi_ce_high 
02b2 d3 80		       out (storage_adata),a 
02b4 32 49 f8		       ld (spi_portbyte), a 
02b7			 
02b7 f1				pop af 
02b8			 
02b8 c1				pop bc 
02b9 d1				pop de 
02ba			 
02ba c9			    ret 
02bb			 
02bb			if DEBUG_STORESE 
02bb			 
02bb			storageput:  
02bb			 
02bb			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
02bb			 
02bb 21 1f ee			ld hl,scratch+2 
02be cd c0 10			call get_word_hl 
02c1			 
02c1				; stuff it here for the moment as it will be overwritten later anyway 
02c1			 
02c1 22 40 f1			ld (os_cur_ptr),hl	 
02c4			 
02c4			 
02c4			; get pointer to start of string 
02c4			 
02c4 21 24 ee			ld hl, scratch+7 
02c7			 
02c7			; loop writing char of string to eeprom 
02c7			 
02c7 7e			.writestr:	ld a,(hl) 
02c8 fe 00				cp 0 
02ca 28 12				jr z, .wsdone		; done writing 
02cc e5					push hl 
02cd 2a 40 f1				ld hl,(os_cur_ptr) 
02d0 cd ea 01				call se_writebyte 
02d3			 
02d3 2a 40 f1				ld hl,(os_cur_ptr)	 ; save next eeprom address 
02d6 23					inc hl 
02d7 22 40 f1				ld (os_cur_ptr),hl 
02da			 
02da					; restore string pointer and get next char 
02da			 
02da e1					pop hl 
02db 23					inc hl 
02dc 18 e9				jr .writestr 
02de			 
02de			 
02de			 
02de			.wsdone: 
02de			 
02de			 
02de			; when done load first page into a buffer  
02de			 
02de 21 00 80				ld hl,08000h		; start in ram 
02e1 22 40 f1				ld (os_cur_ptr),hl 
02e4 21 00 00				ld hl, 0		 ; start of page 
02e7 22 45 ee				ld (scratch+40),hl	; hang on to it 
02ea			 
02ea 06 80				ld b, 128		; actually get more then one page 
02ec c5			.wsload:	push bc 
02ed 2a 45 ee				ld hl,(scratch+40) 
02f0 e5					push hl 
02f1 cd 8c 02				call se_readbyte 
02f4			 
02f4					; a now as the byte 
02f4			 
02f4 2a 40 f1				ld hl,(os_cur_ptr) 
02f7 77					ld (hl),a 
02f8					; inc next buffer area 
02f8 23					inc hl 
02f9 22 40 f1				ld (os_cur_ptr),hl 
02fc			 
02fc					; get eeprom position, inc and save for next round 
02fc e1					pop hl		 
02fd 23					inc hl 
02fe 22 45 ee				ld (scratch+40),hl 
0301 c1					pop bc 
0302 10 e8				djnz .wsload 
0304			 
0304			; set 'd' pointer to start of buffer 
0304			 
0304 21 00 80				ld hl,08000h 
0307 22 40 f1				ld (os_cur_ptr),hl 
030a			 
030a			 
030a c9			ret 
030b			 
030b			 
030b c9			storageread: ret 
030c			 
030c			 
030c			 
030c			 
030c			 
030c			 
030c			endif 
030c			 
030c			 
030c			 
# End of file firmware_seeprom.asm
030c			else  
030c			   ; create some stubs for the labels  
030c			se_readbyte: ret  
030c			se_writebyte: ret  
030c			storage_init: ret  
030c			  
030c			endif  
030c			  
030c			; use cf card for storage - throwing timeout errors. Hardware or software?????  
030c			;include "firmware_cf.asm"  
030c			  
030c			; load up high level storage hardward abstractions  
030c			include "firmware_storage.asm"  
030c			 
030c			; persisent storage hardware abstraction layer  
030c			 
030c			 
030c			 
030c			; Block 0 on storage is a config state 
030c			 
030c			 
030c			 
030c			; TODO add read phy block and write phy block functions 
030c			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
030c			 
030c			; Abstraction layer  
030c			 
030c			; Logocial block size is same size as physical size - using tape concept 
030c			 
030c			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
030c			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
030c			 
030c			 
030c			 
030c			; Filesystem layout (Logical layout) 
030c			; 
030c			; Block 0 - Bank config  
030c			; 
030c			;      Byte - 0 file id counter 
030c			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
030c			;      Byte - 3-20 zero terminated bank label 
030c			; 
030c			; Block 1 > File storage 
030c			; 
030c			;      Byte 0 file id    - block 0 file details 
030c			;      Byte 1 block id - block 0 is file  
030c			;            Byte 2-15 - File name 
030c			; 
030c			;       - to end of block data 
030c			; 
030c			 
030c			 
030c			; Read Block 
030c			; ---------- 
030c			; 
030c			; With current bank 
030c			;  
030c			; Get block number to read 
030c			; Load physical blocks starting at start block into buffer 
030c			 
030c			; de points to buffer to use 
030c			; hl holds logical block number  
030c			 
030c			storage_read_block: 
030c			 
030c				; TODO bank selection 
030c			 
030c				; for each of the physical blocks read it into the buffer 
030c 06 40			ld b, STORE_BLOCK_PHY 
030e			 
030e				if DEBUG_STORESE 
030e d5					push de 
030f				endif 
030f				 
030f			.rl1:    
030f			 
030f				; read physical block at hl into de 
030f			        ; increment hl and de to next read position on exit 
030f			 
030f e5				push hl 
0310 d5				push de	 
0311 c5				push bc 
0312			;	if DEBUG_STORESE 
0312			;		push af 
0312			;		ld a, 'R' 
0312			;		ld (debug_mark),a 
0312			;		pop af 
0312			;		CALLMONITOR 
0312			;	endif 
0312 cd 8c 02			call se_readbyte 
0315			;	if DEBUG_STORESE 
0315			;		ld a,(spi_portbyte) 
0315			;		ld l, a 
0315			;		push af 
0315			;		ld a, '1' 
0315			;		ld (debug_mark),a 
0315			;		pop af 
0315			;		CALLMONITOR 
0315			;	endif 
0315 c1				pop bc 
0316 d1				pop de 
0317 e1				pop hl 
0318 12				ld (de),a 
0319 23				inc hl 
031a 13				inc de 
031b			 
031b			;	if DEBUG_STORESE 
031b			;		push af 
031b			;		ld a, 'r' 
031b			;		ld (debug_mark),a 
031b			;		pop af 
031b			;		CALLMONITOR 
031b			;	endif 
031b			 
031b 10 f2			djnz .rl1 
031d			 
031d				if DEBUG_STORESE 
031d					DMARK "SRB" 
031d f5				push af  
031e 3a 32 03			ld a, (.dmark)  
0321 32 77 fb			ld (debug_mark),a  
0324 3a 33 03			ld a, (.dmark+1)  
0327 32 78 fb			ld (debug_mark+1),a  
032a 3a 34 03			ld a, (.dmark+2)  
032d 32 79 fb			ld (debug_mark+2),a  
0330 18 03			jr .pastdmark  
0332 ..			.dmark: db "SRB"  
0335 f1			.pastdmark: pop af  
0336			endm  
# End of macro DMARK
0336 d1					pop de 
0337			; 
0337			;		push af 
0337			;		ld a, 'R' 
0337			;		ld (debug_mark),a 
0337			;		pop af 
0337					CALLMONITOR 
0337 cd 4d 17			call break_point_state  
033a				endm  
# End of macro CALLMONITOR
033a				endif 
033a c9				ret	 
033b				 
033b			 
033b			; File Size 
033b			; --------- 
033b			; 
033b			;   hl file id 
033b			; 
033b			;  returns in hl the number of blocks 
033b			 
033b			storage_file_size: 
033b 5d				ld e, l 
033c 16 00			ld d, 0 
033e 21 40 00			ld hl, STORE_BLOCK_PHY 
0341					if DEBUG_FORTH_WORDS 
0341						DMARK "SIZ" 
0341 f5				push af  
0342 3a 56 03			ld a, (.dmark)  
0345 32 77 fb			ld (debug_mark),a  
0348 3a 57 03			ld a, (.dmark+1)  
034b 32 78 fb			ld (debug_mark+1),a  
034e 3a 58 03			ld a, (.dmark+2)  
0351 32 79 fb			ld (debug_mark+2),a  
0354 18 03			jr .pastdmark  
0356 ..			.dmark: db "SIZ"  
0359 f1			.pastdmark: pop af  
035a			endm  
# End of macro DMARK
035a						CALLMONITOR 
035a cd 4d 17			call break_point_state  
035d				endm  
# End of macro CALLMONITOR
035d					endif 
035d cd 2d 06			call storage_findnextid 
0360			 
0360 cd 32 0d			call ishlzero 
0363			;	ld a, l 
0363			;	add h 
0363			;	cp 0 
0363 c8				ret z			; block not found so EOF 
0364			 
0364 11 62 f8			ld de, store_page 
0367 cd 0c 03			call storage_read_block 
036a			 
036a 3a 64 f8			ld a, (store_page+2)	 ; get extent count 
036d 6f				ld l, a 
036e 26 00			ld h, 0 
0370 c9			 	ret 
0371			 
0371			 
0371			; Write Block 
0371			; ----------- 
0371			; 
0371			; With current bank 
0371			;  
0371			; Get block number to write 
0371			; Write physical blocks starting at start block from buffer 
0371			  
0371			storage_write_block: 
0371				; TODO bank selection 
0371			 
0371				; for each of the physical blocks read it into the buffer 
0371 06 40			ld b, STORE_BLOCK_PHY 
0373			 
0373				if DEBUG_STORESE 
0373					DMARK "SWB" 
0373 f5				push af  
0374 3a 88 03			ld a, (.dmark)  
0377 32 77 fb			ld (debug_mark),a  
037a 3a 89 03			ld a, (.dmark+1)  
037d 32 78 fb			ld (debug_mark+1),a  
0380 3a 8a 03			ld a, (.dmark+2)  
0383 32 79 fb			ld (debug_mark+2),a  
0386 18 03			jr .pastdmark  
0388 ..			.dmark: db "SWB"  
038b f1			.pastdmark: pop af  
038c			endm  
# End of macro DMARK
038c			 
038c					;push af 
038c					;ld a, 'W' 
038c					;ld (debug_mark),a 
038c					;pop af 
038c					CALLMONITOR 
038c cd 4d 17			call break_point_state  
038f				endm  
# End of macro CALLMONITOR
038f				endif 
038f			 
038f			; might not be working 
038f			;	call se_writepage 
038f			 
038f			;	ret 
038f			; 
038f			 
038f			 
038f			 
038f			.wl1:    
038f			 
038f				; read physical block at hl into de 
038f			        ; increment hl and de to next read position on exit 
038f			 
038f e5				push hl 
0390 d5				push de	 
0391 c5				push bc 
0392 1a				ld a,(de) 
0393				;if DEBUG_STORESE 
0393			;		push af 
0393			;		ld a, 'W' 
0393			;		ld (debug_mark),a 
0393			;		pop af 
0393			;		CALLMONITOR 
0393			;	endif 
0393 cd ea 01			call se_writebyte 
0396			;	call delay250ms 
0396 00				nop 
0397 00				nop 
0398 00				nop 
0399			;	if DEBUG_STORESE 
0399			;		push af 
0399			;		ld a, 'w' 
0399			;		ld (debug_mark),a 
0399			;		pop af 
0399			;		CALLMONITOR 
0399			;	endif 
0399 c1				pop bc 
039a d1				pop de 
039b e1				pop hl 
039c 23				inc hl 
039d 13				inc de 
039e			 
039e			 
039e 10 ef			djnz .wl1 
03a0			 
03a0				if DEBUG_STORESE 
03a0					DMARK "SW2" 
03a0 f5				push af  
03a1 3a b5 03			ld a, (.dmark)  
03a4 32 77 fb			ld (debug_mark),a  
03a7 3a b6 03			ld a, (.dmark+1)  
03aa 32 78 fb			ld (debug_mark+1),a  
03ad 3a b7 03			ld a, (.dmark+2)  
03b0 32 79 fb			ld (debug_mark+2),a  
03b3 18 03			jr .pastdmark  
03b5 ..			.dmark: db "SW2"  
03b8 f1			.pastdmark: pop af  
03b9			endm  
# End of macro DMARK
03b9			 
03b9					;push af 
03b9					;ld a, 'W' 
03b9					;ld (debug_mark),a 
03b9					;pop af 
03b9					CALLMONITOR 
03b9 cd 4d 17			call break_point_state  
03bc				endm  
# End of macro CALLMONITOR
03bc				endif 
03bc c9				ret	 
03bd			 
03bd			; Init bank 
03bd			; --------- 
03bd			; 
03bd			; With current bank 
03bd			; 
03bd			; Setup block 0 config 
03bd			;     Set 0 file id counter 
03bd			;     Set formatted byte pattern 
03bd			;     Zero out bank label 
03bd			;      
03bd			; For every logical block write 0-1 byte as null 
03bd			 
03bd			storage_get_block_0: 
03bd			 
03bd				; TODO check presence 
03bd			 
03bd				; get block 0 config 
03bd			 
03bd 21 00 00			ld hl, 0 
03c0 11 62 f8			ld de, store_page 
03c3 cd 0c 03			call storage_read_block 
03c6			 
03c6				if DEBUG_STORESE 
03c6					DMARK "SB0" 
03c6 f5				push af  
03c7 3a db 03			ld a, (.dmark)  
03ca 32 77 fb			ld (debug_mark),a  
03cd 3a dc 03			ld a, (.dmark+1)  
03d0 32 78 fb			ld (debug_mark+1),a  
03d3 3a dd 03			ld a, (.dmark+2)  
03d6 32 79 fb			ld (debug_mark+2),a  
03d9 18 03			jr .pastdmark  
03db ..			.dmark: db "SB0"  
03de f1			.pastdmark: pop af  
03df			endm  
# End of macro DMARK
03df 11 62 f8				ld de, store_page 
03e2			;		push af 
03e2			;		ld a, 'i' 
03e2			;		ld (debug_mark),a 
03e2			;		pop af 
03e2					CALLMONITOR 
03e2 cd 4d 17			call break_point_state  
03e5				endm  
# End of macro CALLMONITOR
03e5				endif 
03e5			 
03e5				; is this area formatted? 
03e5			 
03e5			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03e5 2a 63 f8			ld hl, (store_page+1) 
03e8 3e 80			ld a,0x80 
03ea bd				cp l 
03eb 20 22			jr nz, .ininotformatted 
03ed				; do a double check 
03ed 3e 27			ld a, 0x27 
03ef bc				cp h 
03f0 20 1d			jr nz, .ininotformatted 
03f2			 
03f2				; formatted then 
03f2			 
03f2				if DEBUG_STORESE 
03f2					DMARK "SB1" 
03f2 f5				push af  
03f3 3a 07 04			ld a, (.dmark)  
03f6 32 77 fb			ld (debug_mark),a  
03f9 3a 08 04			ld a, (.dmark+1)  
03fc 32 78 fb			ld (debug_mark+1),a  
03ff 3a 09 04			ld a, (.dmark+2)  
0402 32 79 fb			ld (debug_mark+2),a  
0405 18 03			jr .pastdmark  
0407 ..			.dmark: db "SB1"  
040a f1			.pastdmark: pop af  
040b			endm  
# End of macro DMARK
040b					;push af 
040b					;ld a, 'I' 
040b					;ld (debug_mark),a 
040b					;pop af 
040b					CALLMONITOR 
040b cd 4d 17			call break_point_state  
040e				endm  
# End of macro CALLMONITOR
040e				endif 
040e c9				ret 
040f			 
040f			.ininotformatted: 
040f				; bank not formatted so poke various bits to make sure 
040f			 
040f				if DEBUG_STORESE 
040f					DMARK "SB2" 
040f f5				push af  
0410 3a 24 04			ld a, (.dmark)  
0413 32 77 fb			ld (debug_mark),a  
0416 3a 25 04			ld a, (.dmark+1)  
0419 32 78 fb			ld (debug_mark+1),a  
041c 3a 26 04			ld a, (.dmark+2)  
041f 32 79 fb			ld (debug_mark+2),a  
0422 18 03			jr .pastdmark  
0424 ..			.dmark: db "SB2"  
0427 f1			.pastdmark: pop af  
0428			endm  
# End of macro DMARK
0428					;push af 
0428					;ld a, 'f' 
0428					;ld (debug_mark),a 
0428					;pop af 
0428					CALLMONITOR 
0428 cd 4d 17			call break_point_state  
042b				endm  
# End of macro CALLMONITOR
042b				endif 
042b			 
042b cd 18 0a			call storage_clear_page 
042e			 
042e 21 62 f8			ld hl, store_page 
0431 3e 00			ld a, 0 
0433				 
0433 77				ld (hl),a   ; reset file counter 
0434			 
0434 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0437 22 63 f8		 	ld (store_page+1), hl	 
043a			 
043a				; set default label 
043a			 
043a 21 d6 04			ld hl, .defaultbanklabl 
043d 11 65 f8		 	ld de, store_page+3 
0440 01 0f 00			ld bc, 15 
0443 ed b0			ldir 
0445			 
0445				; Append the current bank id 
0445 21 6e f8			ld hl, store_page+3+9 
0448 3a 47 f8			ld a, (spi_device_id) 
044b 77				ld (hl), a 
044c			 
044c				; save default page 0 
044c			 
044c 21 00 00			ld hl, 0 
044f 11 62 f8			ld de, store_page 
0452				if DEBUG_STORESE 
0452					DMARK "SB3" 
0452 f5				push af  
0453 3a 67 04			ld a, (.dmark)  
0456 32 77 fb			ld (debug_mark),a  
0459 3a 68 04			ld a, (.dmark+1)  
045c 32 78 fb			ld (debug_mark+1),a  
045f 3a 69 04			ld a, (.dmark+2)  
0462 32 79 fb			ld (debug_mark+2),a  
0465 18 03			jr .pastdmark  
0467 ..			.dmark: db "SB3"  
046a f1			.pastdmark: pop af  
046b			endm  
# End of macro DMARK
046b			;		push af 
046b			;		ld a, 'F' 
046b			;		ld (debug_mark),a 
046b			;		pop af 
046b					CALLMONITOR 
046b cd 4d 17			call break_point_state  
046e				endm  
# End of macro CALLMONITOR
046e				endif 
046e cd 71 03			call storage_write_block 
0471				if DEBUG_STORESE 
0471					DMARK "SB4" 
0471 f5				push af  
0472 3a 86 04			ld a, (.dmark)  
0475 32 77 fb			ld (debug_mark),a  
0478 3a 87 04			ld a, (.dmark+1)  
047b 32 78 fb			ld (debug_mark+1),a  
047e 3a 88 04			ld a, (.dmark+2)  
0481 32 79 fb			ld (debug_mark+2),a  
0484 18 03			jr .pastdmark  
0486 ..			.dmark: db "SB4"  
0489 f1			.pastdmark: pop af  
048a			endm  
# End of macro DMARK
048a			;		push af 
048a			;		ld a, '>' 
048a			;		ld (debug_mark),a 
048a			;		pop af 
048a					CALLMONITOR 
048a cd 4d 17			call break_point_state  
048d				endm  
# End of macro CALLMONITOR
048d				endif 
048d			 
048d 00				nop 
048e 00				nop 
048f 00				nop 
0490			 
0490				; now set 0 in every page to mark as a free block 
0490			 
0490 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0492 21 40 00			ld hl, STORE_BLOCK_PHY 
0495			 
0495 3e 00		.setmark1:   	ld a,0 
0497 e5					push hl 
0498 c5					push bc 
0499 cd ea 01				call se_writebyte 
049c 3e 0a			ld a, 10 
049e cd 3a 0a			call aDelayInMS 
04a1 23				inc hl 
04a2 cd ea 01				call se_writebyte 
04a5 3e 0a			ld a, 10 
04a7 cd 3a 0a			call aDelayInMS 
04aa 2b				dec hl 
04ab c1					pop bc 
04ac e1					pop hl 
04ad 3e 40				ld a, STORE_BLOCK_PHY 
04af cd 09 0d				call addatohl 
04b2 10 e1				djnz .setmark1 
04b4			 
04b4 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
04b6 3e 00		.setmark2:   	ld a,0 
04b8 e5					push hl 
04b9 c5					push bc 
04ba cd ea 01				call se_writebyte 
04bd 3e 0a			ld a, 10 
04bf cd 3a 0a			call aDelayInMS 
04c2 23				inc hl 
04c3 cd ea 01				call se_writebyte 
04c6 3e 0a			ld a, 10 
04c8 cd 3a 0a			call aDelayInMS 
04cb 2b				dec hl 
04cc c1					pop bc 
04cd e1					pop hl 
04ce 3e 40				ld a, STORE_BLOCK_PHY 
04d0 cd 09 0d				call addatohl 
04d3 10 e1				djnz .setmark2 
04d5			 
04d5					 
04d5			 
04d5			 
04d5 c9				ret 
04d6			 
04d6			 
04d6			 
04d6			 
04d6 .. 00		.defaultbanklabl:   db "BankLabel_",0 
04e1			 
04e1			 
04e1			 
04e1			; Label Bank 
04e1			; ---------- 
04e1			; 
04e1			; With current bank 
04e1			; Read block 0 
04e1			; Set label 
04e1			; Write block 0 
04e1			 
04e1			; label str pointer in hl 
04e1			 
04e1			storage_label:     
04e1			 
04e1				if DEBUG_STORESE 
04e1					DMARK "LBL" 
04e1 f5				push af  
04e2 3a f6 04			ld a, (.dmark)  
04e5 32 77 fb			ld (debug_mark),a  
04e8 3a f7 04			ld a, (.dmark+1)  
04eb 32 78 fb			ld (debug_mark+1),a  
04ee 3a f8 04			ld a, (.dmark+2)  
04f1 32 79 fb			ld (debug_mark+2),a  
04f4 18 03			jr .pastdmark  
04f6 ..			.dmark: db "LBL"  
04f9 f1			.pastdmark: pop af  
04fa			endm  
# End of macro DMARK
04fa					CALLMONITOR 
04fa cd 4d 17			call break_point_state  
04fd				endm  
# End of macro CALLMONITOR
04fd				endif 
04fd			 
04fd e5				push hl 
04fe			 
04fe cd bd 03			call storage_get_block_0 
0501			 
0501				; set default label 
0501			 
0501 e1				pop hl 
0502			 
0502 11 65 f8		 	ld de, store_page+3 
0505 01 0f 00			ld bc, 15 
0508				if DEBUG_STORESE 
0508					DMARK "LB3" 
0508 f5				push af  
0509 3a 1d 05			ld a, (.dmark)  
050c 32 77 fb			ld (debug_mark),a  
050f 3a 1e 05			ld a, (.dmark+1)  
0512 32 78 fb			ld (debug_mark+1),a  
0515 3a 1f 05			ld a, (.dmark+2)  
0518 32 79 fb			ld (debug_mark+2),a  
051b 18 03			jr .pastdmark  
051d ..			.dmark: db "LB3"  
0520 f1			.pastdmark: pop af  
0521			endm  
# End of macro DMARK
0521					CALLMONITOR 
0521 cd 4d 17			call break_point_state  
0524				endm  
# End of macro CALLMONITOR
0524				endif 
0524 ed b0			ldir 
0526				; save default page 0 
0526			 
0526 21 00 00			ld hl, 0 
0529 11 62 f8			ld de, store_page 
052c				if DEBUG_STORESE 
052c					DMARK "LBW" 
052c f5				push af  
052d 3a 41 05			ld a, (.dmark)  
0530 32 77 fb			ld (debug_mark),a  
0533 3a 42 05			ld a, (.dmark+1)  
0536 32 78 fb			ld (debug_mark+1),a  
0539 3a 43 05			ld a, (.dmark+2)  
053c 32 79 fb			ld (debug_mark+2),a  
053f 18 03			jr .pastdmark  
0541 ..			.dmark: db "LBW"  
0544 f1			.pastdmark: pop af  
0545			endm  
# End of macro DMARK
0545					CALLMONITOR 
0545 cd 4d 17			call break_point_state  
0548				endm  
# End of macro CALLMONITOR
0548				endif 
0548 cd 71 03			call storage_write_block 
054b			 
054b c9				ret 
054c			 
054c			 
054c			 
054c			; Read Block 0 - Config 
054c			; --------------------- 
054c			; 
054c			; With current bank 
054c			; Call presence test 
054c			;    If not present format/init bank  
054c			; Read block 0  
054c			;  
054c			 
054c			 
054c			; Dir 
054c			; --- 
054c			; 
054c			; With current bank 
054c			; Load Block 0 Config 
054c			; Get max file id number 
054c			; For each logical block 
054c			;    Read block read byte 2 
054c			;      if first block of file 
054c			;         Display file name 
054c			;         Display type flags for file 
054c			;        
054c			 
054c			; moving to words as this requires stack control 
054c			 
054c			 
054c			; Delete File 
054c			; ----------- 
054c			; 
054c			; With current bank 
054c			; 
054c			; Load Block 0 Config 
054c			; Get max file id number 
054c			; For each logical block 
054c			;    Read block file id 
054c			;      If first block of file and dont have file id 
054c			;         if file to delete 
054c			;         Save file id 
054c			;         Null file id 
054c			;         Write this block back 
054c			;      If file id is one saved 
054c			;         Null file id 
054c			;         Write this block back 
054c			 
054c			storage_erase: 
054c			 
054c				; hl contains the file id 
054c			 
054c 5d				ld e, l 
054d 16 00			ld d, 0 
054f 21 40 00			ld hl, STORE_BLOCK_PHY 
0552					if DEBUG_FORTH_WORDS 
0552						DMARK "ERA" 
0552 f5				push af  
0553 3a 67 05			ld a, (.dmark)  
0556 32 77 fb			ld (debug_mark),a  
0559 3a 68 05			ld a, (.dmark+1)  
055c 32 78 fb			ld (debug_mark+1),a  
055f 3a 69 05			ld a, (.dmark+2)  
0562 32 79 fb			ld (debug_mark+2),a  
0565 18 03			jr .pastdmark  
0567 ..			.dmark: db "ERA"  
056a f1			.pastdmark: pop af  
056b			endm  
# End of macro DMARK
056b						CALLMONITOR 
056b cd 4d 17			call break_point_state  
056e				endm  
# End of macro CALLMONITOR
056e					endif 
056e cd 2d 06			call storage_findnextid 
0571			 
0571 e5				push hl 
0572			 
0572				; TODO check file not found 
0572			 
0572 11 62 f8			ld de, store_page 
0575 cd 0c 03			call storage_read_block 
0578			 
0578					if DEBUG_FORTH_WORDS 
0578						DMARK "ER1" 
0578 f5				push af  
0579 3a 8d 05			ld a, (.dmark)  
057c 32 77 fb			ld (debug_mark),a  
057f 3a 8e 05			ld a, (.dmark+1)  
0582 32 78 fb			ld (debug_mark+1),a  
0585 3a 8f 05			ld a, (.dmark+2)  
0588 32 79 fb			ld (debug_mark+2),a  
058b 18 03			jr .pastdmark  
058d ..			.dmark: db "ER1"  
0590 f1			.pastdmark: pop af  
0591			endm  
# End of macro DMARK
0591						CALLMONITOR 
0591 cd 4d 17			call break_point_state  
0594				endm  
# End of macro CALLMONITOR
0594					endif 
0594 3a 62 f8			ld a, (store_page)	; get file id 
0597 32 5b f8			ld (store_tmpid), a 
059a			 
059a 3a 64 f8			ld a, (store_page+2)    ; get count of extends 
059d 32 5a f8			ld (store_tmpext), a 
05a0			 
05a0				; wipe file header 
05a0			 
05a0 e1				pop hl 
05a1 3e 00			ld a, 0 
05a3 32 62 f8			ld (store_page), a 
05a6 32 63 f8			ld (store_page+1),a 
05a9 11 62 f8			ld de, store_page 
05ac					if DEBUG_FORTH_WORDS 
05ac						DMARK "ER2" 
05ac f5				push af  
05ad 3a c1 05			ld a, (.dmark)  
05b0 32 77 fb			ld (debug_mark),a  
05b3 3a c2 05			ld a, (.dmark+1)  
05b6 32 78 fb			ld (debug_mark+1),a  
05b9 3a c3 05			ld a, (.dmark+2)  
05bc 32 79 fb			ld (debug_mark+2),a  
05bf 18 03			jr .pastdmark  
05c1 ..			.dmark: db "ER2"  
05c4 f1			.pastdmark: pop af  
05c5			endm  
# End of macro DMARK
05c5						CALLMONITOR 
05c5 cd 4d 17			call break_point_state  
05c8				endm  
# End of macro CALLMONITOR
05c8					endif 
05c8 cd 71 03			call storage_write_block 
05cb			 
05cb			 
05cb				; wipe file extents 
05cb			 
05cb 3a 5a f8			ld a, (store_tmpext) 
05ce 47				ld b, a 
05cf			 
05cf			.eraext:	  
05cf c5				push bc 
05d0			 
05d0 21 40 00			ld hl, STORE_BLOCK_PHY 
05d3 3a 5b f8			ld a,(store_tmpid) 
05d6 5f				ld e, a 
05d7 50				ld d, b	 
05d8					if DEBUG_FORTH_WORDS 
05d8						DMARK "ER3" 
05d8 f5				push af  
05d9 3a ed 05			ld a, (.dmark)  
05dc 32 77 fb			ld (debug_mark),a  
05df 3a ee 05			ld a, (.dmark+1)  
05e2 32 78 fb			ld (debug_mark+1),a  
05e5 3a ef 05			ld a, (.dmark+2)  
05e8 32 79 fb			ld (debug_mark+2),a  
05eb 18 03			jr .pastdmark  
05ed ..			.dmark: db "ER3"  
05f0 f1			.pastdmark: pop af  
05f1			endm  
# End of macro DMARK
05f1						CALLMONITOR 
05f1 cd 4d 17			call break_point_state  
05f4				endm  
# End of macro CALLMONITOR
05f4					endif 
05f4 cd 2d 06			call storage_findnextid 
05f7			 
05f7 e5				push hl 
05f8 11 62 f8			ld de, store_page 
05fb cd 0c 03			call storage_read_block 
05fe			 
05fe				; free block	 
05fe			 
05fe 3e 00			ld a, 0 
0600 32 62 f8			ld (store_page), a 
0603 32 63 f8			ld (store_page+1),a 
0606 11 62 f8			ld de, store_page 
0609 e1				pop hl 
060a					if DEBUG_FORTH_WORDS 
060a						DMARK "ER4" 
060a f5				push af  
060b 3a 1f 06			ld a, (.dmark)  
060e 32 77 fb			ld (debug_mark),a  
0611 3a 20 06			ld a, (.dmark+1)  
0614 32 78 fb			ld (debug_mark+1),a  
0617 3a 21 06			ld a, (.dmark+2)  
061a 32 79 fb			ld (debug_mark+2),a  
061d 18 03			jr .pastdmark  
061f ..			.dmark: db "ER4"  
0622 f1			.pastdmark: pop af  
0623			endm  
# End of macro DMARK
0623						CALLMONITOR 
0623 cd 4d 17			call break_point_state  
0626				endm  
# End of macro CALLMONITOR
0626					endif 
0626 cd 71 03			call storage_write_block 
0629			 
0629 c1				pop bc 
062a 10 a3			djnz .eraext 
062c			 
062c c9				ret 
062d			 
062d			 
062d			; Find Free Block 
062d			; --------------- 
062d			; 
062d			; With current bank 
062d			;  
062d			; From given starting logical block 
062d			;    Read block  
062d			;    If no file id 
062d			;         Return block id 
062d			 
062d			 
062d			; hl starting page number 
062d			; hl contains free page number or zero if no pages free 
062d			; e contains the file id to locate 
062d			; d contains the block number 
062d			 
062d			; TODO change to find file id and use zero for free block 
062d			 
062d			storage_findnextid: 
062d			 
062d				; now locate first 0 page to mark as a free block 
062d			 
062d 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
062f			;	ld hl, STORE_BLOCK_PHY 
062f			 
062f					if DEBUG_FORTH_WORDS 
062f					DMARK "FNI" 
062f f5				push af  
0630 3a 44 06			ld a, (.dmark)  
0633 32 77 fb			ld (debug_mark),a  
0636 3a 45 06			ld a, (.dmark+1)  
0639 32 78 fb			ld (debug_mark+1),a  
063c 3a 46 06			ld a, (.dmark+2)  
063f 32 79 fb			ld (debug_mark+2),a  
0642 18 03			jr .pastdmark  
0644 ..			.dmark: db "FNI"  
0647 f1			.pastdmark: pop af  
0648			endm  
# End of macro DMARK
0648						CALLMONITOR 
0648 cd 4d 17			call break_point_state  
064b				endm  
# End of macro CALLMONITOR
064b					endif 
064b			.ff1:   	 
064b e5					push hl 
064c c5					push bc 
064d d5					push de 
064e cd 8c 02				call se_readbyte 
0651 5f					ld e,a 
0652 23					inc hl 
0653 cd 8c 02				call se_readbyte 
0656 57					ld d, a 
0657 e1					pop hl 
0658 e5					push hl 
0659 cd 27 0d				call cmp16 
065c 28 49				jr z, .fffound 
065e			 
065e d1					pop de 
065f c1					pop bc 
0660 e1					pop hl 
0661			 
0661					; is found? 
0661					;cp e 
0661					;ret z 
0661			 
0661 3e 40				ld a, STORE_BLOCK_PHY 
0663 cd 09 0d				call addatohl 
0666 10 e3				djnz .ff1 
0668			 
0668 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
066a			.ff2:   	 
066a			 
066a e5					push hl 
066b c5					push bc 
066c d5					push de 
066d cd 8c 02				call se_readbyte 
0670 5f					ld e,a 
0671 23					inc hl 
0672 cd 8c 02				call se_readbyte 
0675 57					ld d, a 
0676			 
0676 e1					pop hl 
0677 e5					push hl 
0678 cd 27 0d				call cmp16 
067b 28 2a				jr z, .fffound 
067d			 
067d d1					pop de 
067e c1					pop bc 
067f e1					pop hl 
0680					; is found? 
0680					;cp e 
0680					;ret z 
0680			 
0680 3e 40				ld a, STORE_BLOCK_PHY 
0682 cd 09 0d				call addatohl 
0685 10 e3				djnz .ff2 
0687			 
0687			 
0687					if DEBUG_FORTH_WORDS 
0687					DMARK "FN-" 
0687 f5				push af  
0688 3a 9c 06			ld a, (.dmark)  
068b 32 77 fb			ld (debug_mark),a  
068e 3a 9d 06			ld a, (.dmark+1)  
0691 32 78 fb			ld (debug_mark+1),a  
0694 3a 9e 06			ld a, (.dmark+2)  
0697 32 79 fb			ld (debug_mark+2),a  
069a 18 03			jr .pastdmark  
069c ..			.dmark: db "FN-"  
069f f1			.pastdmark: pop af  
06a0			endm  
# End of macro DMARK
06a0					;	push af 
06a0					;	ld a, 'n' 
06a0					;	ld (debug_mark),a 
06a0					;	pop af 
06a0						CALLMONITOR 
06a0 cd 4d 17			call break_point_state  
06a3				endm  
# End of macro CALLMONITOR
06a3					endif 
06a3				; no free marks! 
06a3 21 00 00				ld hl, 0 
06a6 c9				ret 
06a7			.fffound: 
06a7				 
06a7			 
06a7 d1					pop de 
06a8 c1					pop bc 
06a9 e1					pop hl 
06aa					if DEBUG_FORTH_WORDS 
06aa					DMARK "FNF" 
06aa f5				push af  
06ab 3a bf 06			ld a, (.dmark)  
06ae 32 77 fb			ld (debug_mark),a  
06b1 3a c0 06			ld a, (.dmark+1)  
06b4 32 78 fb			ld (debug_mark+1),a  
06b7 3a c1 06			ld a, (.dmark+2)  
06ba 32 79 fb			ld (debug_mark+2),a  
06bd 18 03			jr .pastdmark  
06bf ..			.dmark: db "FNF"  
06c2 f1			.pastdmark: pop af  
06c3			endm  
# End of macro DMARK
06c3					;	push af 
06c3					;	ld a, 'n' 
06c3					;	ld (debug_mark),a 
06c3					;	pop af 
06c3						CALLMONITOR 
06c3 cd 4d 17			call break_point_state  
06c6				endm  
# End of macro CALLMONITOR
06c6					endif 
06c6 c9				ret 
06c7			 
06c7			 
06c7			 
06c7			; Free Space 
06c7			; ---------- 
06c7			; 
06c7			; With current bank 
06c7			; 
06c7			; Set block count to zero 
06c7			; Starting with first logical block 
06c7			;      Find free block  
06c7			;      If block id given, increment block count 
06c7			; 
06c7			;  
06c7			 
06c7			 
06c7			; hl contains count of free blocks 
06c7			 
06c7			storage_freeblocks: 
06c7			 
06c7				; now locate first 0 page to mark as a free block 
06c7			 
06c7 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
06c9 21 40 00			ld hl, STORE_BLOCK_PHY 
06cc 11 00 00			ld de, 0 
06cf			 
06cf			.fb1:   	 
06cf e5					push hl 
06d0 c5					push bc 
06d1 d5					push de 
06d2 cd 8c 02				call se_readbyte 
06d5 d1					pop de 
06d6 c1					pop bc 
06d7 e1					pop hl 
06d8			 
06d8					; is free? 
06d8 fe 00				cp 0 
06da 20 01				jr nz, .ff1cont 
06dc 13					inc de 
06dd			 
06dd			.ff1cont: 
06dd			 
06dd			 
06dd 3e 40				ld a, STORE_BLOCK_PHY 
06df cd 09 0d				call addatohl 
06e2 10 eb				djnz .fb1 
06e4			 
06e4 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
06e6			.fb2:   	 
06e6 e5					push hl 
06e7 c5					push bc 
06e8 d5					push de 
06e9 cd 8c 02				call se_readbyte 
06ec d1					pop de 
06ed c1					pop bc 
06ee e1					pop hl 
06ef			 
06ef					; is free? 
06ef fe 00				cp 0 
06f1 20 01				jr nz, .ff2cont 
06f3 13					inc de 
06f4			 
06f4			.ff2cont: 
06f4			 
06f4 3e 40				ld a, STORE_BLOCK_PHY 
06f6 cd 09 0d				call addatohl 
06f9 10 eb				djnz .fb2 
06fb			 
06fb eb				ex de, hl 
06fc c9				ret 
06fd			 
06fd			; Get File ID 
06fd			; ----------- 
06fd			; 
06fd			; With current bank 
06fd			;  
06fd			; Load Block 0 Config 
06fd			; Get max file id number 
06fd			; For each logical block 
06fd			;    Read block file id 
06fd			;      If first block of file and dont have file id 
06fd			;         if file get id and exit 
06fd			 
06fd			 
06fd			 
06fd			 
06fd			; Create File 
06fd			; ----------- 
06fd			; 
06fd			; With current bank  
06fd			; Load Block 0 Config 
06fd			; Get max file id number 
06fd			; Increment file id number 
06fd			; Save Config 
06fd			; Find free block 
06fd			; Set buffer with file name and file id 
06fd			; Write buffer to free block  
06fd			 
06fd			 
06fd			; hl point to file name 
06fd			; hl returns file id 
06fd			 
06fd			; file format: 
06fd			; byte 0 - file id 
06fd			; byte 1 - extent number 
06fd			; byte 2-> data 
06fd			 
06fd			; format for extent number 0: 
06fd			; 
06fd			; byte 0 - file id 
06fd			; byte 1 - extent 0 
06fd			; byte 2 - extent count 
06fd			; byte 3 -> file name and meta data 
06fd			 
06fd			 
06fd			storage_create: 
06fd				if DEBUG_STORESE 
06fd					DMARK "SCR" 
06fd f5				push af  
06fe 3a 12 07			ld a, (.dmark)  
0701 32 77 fb			ld (debug_mark),a  
0704 3a 13 07			ld a, (.dmark+1)  
0707 32 78 fb			ld (debug_mark+1),a  
070a 3a 14 07			ld a, (.dmark+2)  
070d 32 79 fb			ld (debug_mark+2),a  
0710 18 03			jr .pastdmark  
0712 ..			.dmark: db "SCR"  
0715 f1			.pastdmark: pop af  
0716			endm  
# End of macro DMARK
0716					CALLMONITOR 
0716 cd 4d 17			call break_point_state  
0719				endm  
# End of macro CALLMONITOR
0719				endif 
0719			 
0719 e5				push hl		; save file name pointer 
071a			 
071a cd bd 03			call storage_get_block_0 
071d			 
071d 3a 62 f8			ld a,(store_page)	; get current file id 
0720 3c				inc a 
0721 32 62 f8			ld (store_page),a 
0724				 
0724 32 5b f8			ld (store_tmpid),a			; save id 
0727			 
0727 21 00 00			ld hl, 0 
072a 11 62 f8			ld de, store_page 
072d				if DEBUG_STORESE 
072d					DMARK "SCw" 
072d f5				push af  
072e 3a 42 07			ld a, (.dmark)  
0731 32 77 fb			ld (debug_mark),a  
0734 3a 43 07			ld a, (.dmark+1)  
0737 32 78 fb			ld (debug_mark+1),a  
073a 3a 44 07			ld a, (.dmark+2)  
073d 32 79 fb			ld (debug_mark+2),a  
0740 18 03			jr .pastdmark  
0742 ..			.dmark: db "SCw"  
0745 f1			.pastdmark: pop af  
0746			endm  
# End of macro DMARK
0746					CALLMONITOR 
0746 cd 4d 17			call break_point_state  
0749				endm  
# End of macro CALLMONITOR
0749				endif 
0749 cd 71 03			call storage_write_block	 ; save update 
074c			 
074c				if DEBUG_STORESE 
074c 11 62 f8				ld de, store_page 
074f					DMARK "SCC" 
074f f5				push af  
0750 3a 64 07			ld a, (.dmark)  
0753 32 77 fb			ld (debug_mark),a  
0756 3a 65 07			ld a, (.dmark+1)  
0759 32 78 fb			ld (debug_mark+1),a  
075c 3a 66 07			ld a, (.dmark+2)  
075f 32 79 fb			ld (debug_mark+2),a  
0762 18 03			jr .pastdmark  
0764 ..			.dmark: db "SCC"  
0767 f1			.pastdmark: pop af  
0768			endm  
# End of macro DMARK
0768					CALLMONITOR 
0768 cd 4d 17			call break_point_state  
076b				endm  
# End of macro CALLMONITOR
076b				endif 
076b				;  
076b				 
076b 21 40 00			ld hl, STORE_BLOCK_PHY 
076e 11 00 00			ld de, 0 
0771 cd 2d 06			call storage_findnextid 
0774			 
0774 22 4c f8			ld (store_tmppageid), hl    ; save page to use  
0777			 
0777				; TODO detect 0 = no spare blocks 
0777			 
0777				; hl now contains the free page to use for the file header page 
0777			 
0777				if DEBUG_STORESE 
0777				DMARK "SCF" 
0777 f5				push af  
0778 3a 8c 07			ld a, (.dmark)  
077b 32 77 fb			ld (debug_mark),a  
077e 3a 8d 07			ld a, (.dmark+1)  
0781 32 78 fb			ld (debug_mark+1),a  
0784 3a 8e 07			ld a, (.dmark+2)  
0787 32 79 fb			ld (debug_mark+2),a  
078a 18 03			jr .pastdmark  
078c ..			.dmark: db "SCF"  
078f f1			.pastdmark: pop af  
0790			endm  
# End of macro DMARK
0790					CALLMONITOR 
0790 cd 4d 17			call break_point_state  
0793				endm  
# End of macro CALLMONITOR
0793				endif 
0793			 
0793 22 4c f8			ld (store_tmppageid), hl 
0796				 
0796 3a 5b f8			ld a,(store_tmpid)    ; get file id 
0799			;	ld a, (store_filecache)			; save to cache 
0799			 
0799 32 62 f8			ld (store_page),a    ; set page id 
079c 3e 00			ld a, 0			 ; extent 0 is file header 
079e 32 63 f8			ld (store_page+1), a   ; set file extent 
07a1			 
07a1 32 64 f8			ld (store_page+2), a   ; extent count for the file 
07a4			 
07a4			;	inc hl 		; init block 0 of file 
07a4			;	inc hl   		; skip file and extent id 
07a4			 ;       ld a, 0 
07a4			;	ld (hl),a 
07a4			;	ld a, (store_filecache+1)  	; save to cache 
07a4			 
07a4			;	inc hl    ; file name 
07a4				 
07a4				 
07a4 11 65 f8			ld de, store_page+3    ; get buffer for term string to use as file name 
07a7				if DEBUG_STORESE 
07a7					DMARK "SCc" 
07a7 f5				push af  
07a8 3a bc 07			ld a, (.dmark)  
07ab 32 77 fb			ld (debug_mark),a  
07ae 3a bd 07			ld a, (.dmark+1)  
07b1 32 78 fb			ld (debug_mark+1),a  
07b4 3a be 07			ld a, (.dmark+2)  
07b7 32 79 fb			ld (debug_mark+2),a  
07ba 18 03			jr .pastdmark  
07bc ..			.dmark: db "SCc"  
07bf f1			.pastdmark: pop af  
07c0			endm  
# End of macro DMARK
07c0					CALLMONITOR 
07c0 cd 4d 17			call break_point_state  
07c3				endm  
# End of macro CALLMONITOR
07c3				endif 
07c3 e1				pop hl    ; get zero term string 
07c4 e5				push hl 
07c5 3e 00			ld a, 0 
07c7 cd 72 11			call strlent 
07ca 23				inc hl   ; cover zero term 
07cb 06 00			ld b,0 
07cd 4d				ld c,l 
07ce e1				pop hl 
07cf				;ex de, hl 
07cf				if DEBUG_STORESE 
07cf					DMARK "SCa" 
07cf f5				push af  
07d0 3a e4 07			ld a, (.dmark)  
07d3 32 77 fb			ld (debug_mark),a  
07d6 3a e5 07			ld a, (.dmark+1)  
07d9 32 78 fb			ld (debug_mark+1),a  
07dc 3a e6 07			ld a, (.dmark+2)  
07df 32 79 fb			ld (debug_mark+2),a  
07e2 18 03			jr .pastdmark  
07e4 ..			.dmark: db "SCa"  
07e7 f1			.pastdmark: pop af  
07e8			endm  
# End of macro DMARK
07e8					;push af 
07e8					;ld a, 'a' 
07e8					;ld (debug_mark),a 
07e8					;pop af 
07e8					CALLMONITOR 
07e8 cd 4d 17			call break_point_state  
07eb				endm  
# End of macro CALLMONITOR
07eb				endif 
07eb ed b0			ldir    ; copy zero term string 
07ed				if DEBUG_STORESE 
07ed					DMARK "SCA" 
07ed f5				push af  
07ee 3a 02 08			ld a, (.dmark)  
07f1 32 77 fb			ld (debug_mark),a  
07f4 3a 03 08			ld a, (.dmark+1)  
07f7 32 78 fb			ld (debug_mark+1),a  
07fa 3a 04 08			ld a, (.dmark+2)  
07fd 32 79 fb			ld (debug_mark+2),a  
0800 18 03			jr .pastdmark  
0802 ..			.dmark: db "SCA"  
0805 f1			.pastdmark: pop af  
0806			endm  
# End of macro DMARK
0806					CALLMONITOR 
0806 cd 4d 17			call break_point_state  
0809				endm  
# End of macro CALLMONITOR
0809				endif 
0809			 
0809				; write file header page 
0809			 
0809 2a 4c f8			ld hl,(store_tmppageid) 
080c 11 62 f8			ld de, store_page 
080f				if DEBUG_STORESE 
080f					DMARK "SCb" 
080f f5				push af  
0810 3a 24 08			ld a, (.dmark)  
0813 32 77 fb			ld (debug_mark),a  
0816 3a 25 08			ld a, (.dmark+1)  
0819 32 78 fb			ld (debug_mark+1),a  
081c 3a 26 08			ld a, (.dmark+2)  
081f 32 79 fb			ld (debug_mark+2),a  
0822 18 03			jr .pastdmark  
0824 ..			.dmark: db "SCb"  
0827 f1			.pastdmark: pop af  
0828			endm  
# End of macro DMARK
0828					;push af 
0828					;ld a, 'b' 
0828					;ld (debug_mark),a 
0828					;pop af 
0828					CALLMONITOR 
0828 cd 4d 17			call break_point_state  
082b				endm  
# End of macro CALLMONITOR
082b				endif 
082b cd 71 03			call storage_write_block 
082e			 
082e 3a 5b f8			ld a, (store_tmpid) 
0831 6f				ld l, a 
0832 26 00			ld h,0 
0834				if DEBUG_STORESE 
0834					DMARK "SCz" 
0834 f5				push af  
0835 3a 49 08			ld a, (.dmark)  
0838 32 77 fb			ld (debug_mark),a  
083b 3a 4a 08			ld a, (.dmark+1)  
083e 32 78 fb			ld (debug_mark+1),a  
0841 3a 4b 08			ld a, (.dmark+2)  
0844 32 79 fb			ld (debug_mark+2),a  
0847 18 03			jr .pastdmark  
0849 ..			.dmark: db "SCz"  
084c f1			.pastdmark: pop af  
084d			endm  
# End of macro DMARK
084d					CALLMONITOR 
084d cd 4d 17			call break_point_state  
0850				endm  
# End of macro CALLMONITOR
0850				endif 
0850 c9				ret 
0851				 
0851			 
0851			 
0851			; 
0851			; Read File 
0851			; 
0851			; h - file id to locate 
0851			; l - extent to locate 
0851			; de - pointer to string to read into 
0851			; 
0851			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
0851			storage_read: 
0851 d5				push de 
0852			 
0852			; TODO BUG the above push is it popped before the RET Z? 
0852			 
0852			; TODO how to handle multiple part blocks 
0852			 
0852				; locate file extent to read 
0852			 
0852 5c				ld e, h 
0853 55				ld d, l 
0854 21 40 00			ld hl, STORE_BLOCK_PHY 
0857				if DEBUG_STORESE 
0857					DMARK "SRE" 
0857 f5				push af  
0858 3a 6c 08			ld a, (.dmark)  
085b 32 77 fb			ld (debug_mark),a  
085e 3a 6d 08			ld a, (.dmark+1)  
0861 32 78 fb			ld (debug_mark+1),a  
0864 3a 6e 08			ld a, (.dmark+2)  
0867 32 79 fb			ld (debug_mark+2),a  
086a 18 03			jr .pastdmark  
086c ..			.dmark: db "SRE"  
086f f1			.pastdmark: pop af  
0870			endm  
# End of macro DMARK
0870					CALLMONITOR 
0870 cd 4d 17			call break_point_state  
0873				endm  
# End of macro CALLMONITOR
0873				endif 
0873 cd 2d 06			call storage_findnextid 
0876			 
0876				if DEBUG_STORESE 
0876					DMARK "SRf" 
0876 f5				push af  
0877 3a 8b 08			ld a, (.dmark)  
087a 32 77 fb			ld (debug_mark),a  
087d 3a 8c 08			ld a, (.dmark+1)  
0880 32 78 fb			ld (debug_mark+1),a  
0883 3a 8d 08			ld a, (.dmark+2)  
0886 32 79 fb			ld (debug_mark+2),a  
0889 18 03			jr .pastdmark  
088b ..			.dmark: db "SRf"  
088e f1			.pastdmark: pop af  
088f			endm  
# End of macro DMARK
088f					CALLMONITOR 
088f cd 4d 17			call break_point_state  
0892				endm  
# End of macro CALLMONITOR
0892				endif 
0892 cd 32 0d			call ishlzero 
0895			;	ld a, l 
0895			;	add h 
0895			;	cp 0 
0895 c8				ret z			; block not found so EOF 
0896			 
0896				; hl contains page number to load 
0896 d1				pop de   ; get storage 
0897 d5				push de 
0898				if DEBUG_STORESE 
0898					DMARK "SRg" 
0898 f5				push af  
0899 3a ad 08			ld a, (.dmark)  
089c 32 77 fb			ld (debug_mark),a  
089f 3a ae 08			ld a, (.dmark+1)  
08a2 32 78 fb			ld (debug_mark+1),a  
08a5 3a af 08			ld a, (.dmark+2)  
08a8 32 79 fb			ld (debug_mark+2),a  
08ab 18 03			jr .pastdmark  
08ad ..			.dmark: db "SRg"  
08b0 f1			.pastdmark: pop af  
08b1			endm  
# End of macro DMARK
08b1					CALLMONITOR 
08b1 cd 4d 17			call break_point_state  
08b4				endm  
# End of macro CALLMONITOR
08b4				endif 
08b4 cd 0c 03			call storage_read_block 
08b7			 
08b7			 
08b7			; TODO if block has no zeros then need to read next block  
08b7			 
08b7			 
08b7					 
08b7 e1				pop hl 		 ; return start of data to show as not EOF 
08b8 23				inc hl   ; past file id 
08b9 23				inc hl   ; past ext 
08ba				if DEBUG_STORESE 
08ba					DMARK "SRe" 
08ba f5				push af  
08bb 3a cf 08			ld a, (.dmark)  
08be 32 77 fb			ld (debug_mark),a  
08c1 3a d0 08			ld a, (.dmark+1)  
08c4 32 78 fb			ld (debug_mark+1),a  
08c7 3a d1 08			ld a, (.dmark+2)  
08ca 32 79 fb			ld (debug_mark+2),a  
08cd 18 03			jr .pastdmark  
08cf ..			.dmark: db "SRe"  
08d2 f1			.pastdmark: pop af  
08d3			endm  
# End of macro DMARK
08d3					CALLMONITOR 
08d3 cd 4d 17			call break_point_state  
08d6				endm  
# End of macro CALLMONITOR
08d6				endif 
08d6 c9					ret 
08d7			 
08d7			 
08d7			 
08d7			; 
08d7			; Append File 
08d7			; 
08d7			; hl - file id to locate 
08d7			; de - pointer to (multi block) string to write 
08d7			 
08d7			 
08d7			storage_append: 
08d7				; hl -  file id to append to 
08d7				; de - string to append 
08d7			 
08d7 d5				push de 
08d8				 
08d8				if DEBUG_STORESE 
08d8					DMARK "AP1" 
08d8 f5				push af  
08d9 3a ed 08			ld a, (.dmark)  
08dc 32 77 fb			ld (debug_mark),a  
08df 3a ee 08			ld a, (.dmark+1)  
08e2 32 78 fb			ld (debug_mark+1),a  
08e5 3a ef 08			ld a, (.dmark+2)  
08e8 32 79 fb			ld (debug_mark+2),a  
08eb 18 03			jr .pastdmark  
08ed ..			.dmark: db "AP1"  
08f0 f1			.pastdmark: pop af  
08f1			endm  
# End of macro DMARK
08f1					CALLMONITOR 
08f1 cd 4d 17			call break_point_state  
08f4				endm  
# End of macro CALLMONITOR
08f4				endif 
08f4			 
08f4 7d				ld a, l 
08f5 32 5b f8			ld (store_tmpid), a 
08f8			 
08f8				; get file header  
08f8			 
08f8 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
08fa 3a 5b f8			ld a, (store_tmpid) 
08fd 5f				ld e, a 
08fe			 
08fe 21 40 00				ld hl, STORE_BLOCK_PHY 
0901 cd 2d 06				call storage_findnextid 
0904			 
0904 22 4c f8			ld (store_tmppageid), hl 
0907			 
0907				; TODO handle file id not found 
0907			 
0907				if DEBUG_STORESE 
0907					DMARK "AP2" 
0907 f5				push af  
0908 3a 1c 09			ld a, (.dmark)  
090b 32 77 fb			ld (debug_mark),a  
090e 3a 1d 09			ld a, (.dmark+1)  
0911 32 78 fb			ld (debug_mark+1),a  
0914 3a 1e 09			ld a, (.dmark+2)  
0917 32 79 fb			ld (debug_mark+2),a  
091a 18 03			jr .pastdmark  
091c ..			.dmark: db "AP2"  
091f f1			.pastdmark: pop af  
0920			endm  
# End of macro DMARK
0920					CALLMONITOR 
0920 cd 4d 17			call break_point_state  
0923				endm  
# End of macro CALLMONITOR
0923				endif 
0923			 
0923				; update file extent count 
0923			 
0923 11 62 f8			ld de, store_page 
0926			 
0926 cd 0c 03			call storage_read_block 
0929			 
0929				if DEBUG_STORESE 
0929					DMARK "AP3" 
0929 f5				push af  
092a 3a 3e 09			ld a, (.dmark)  
092d 32 77 fb			ld (debug_mark),a  
0930 3a 3f 09			ld a, (.dmark+1)  
0933 32 78 fb			ld (debug_mark+1),a  
0936 3a 40 09			ld a, (.dmark+2)  
0939 32 79 fb			ld (debug_mark+2),a  
093c 18 03			jr .pastdmark  
093e ..			.dmark: db "AP3"  
0941 f1			.pastdmark: pop af  
0942			endm  
# End of macro DMARK
0942					CALLMONITOR 
0942 cd 4d 17			call break_point_state  
0945				endm  
# End of macro CALLMONITOR
0945				endif 
0945			;	ld (store_tmppageid), hl 
0945			 
0945 3a 64 f8			ld a, (store_page+2) 
0948 3c				inc a 
0949 32 64 f8			ld (store_page+2), a 
094c 32 5a f8			ld (store_tmpext), a 
094f				 
094f				if DEBUG_STORESE 
094f					DMARK "AP3" 
094f f5				push af  
0950 3a 64 09			ld a, (.dmark)  
0953 32 77 fb			ld (debug_mark),a  
0956 3a 65 09			ld a, (.dmark+1)  
0959 32 78 fb			ld (debug_mark+1),a  
095c 3a 66 09			ld a, (.dmark+2)  
095f 32 79 fb			ld (debug_mark+2),a  
0962 18 03			jr .pastdmark  
0964 ..			.dmark: db "AP3"  
0967 f1			.pastdmark: pop af  
0968			endm  
# End of macro DMARK
0968					CALLMONITOR 
0968 cd 4d 17			call break_point_state  
096b				endm  
# End of macro CALLMONITOR
096b				endif 
096b 2a 4c f8			ld hl, (store_tmppageid) 
096e 11 62 f8			ld de, store_page 
0971 cd 71 03			call storage_write_block 
0974			 
0974				; find free block 
0974			 
0974 11 00 00			ld de, 0			 ; file extent to locate 
0977			 
0977 21 40 00				ld hl, STORE_BLOCK_PHY 
097a cd 2d 06				call storage_findnextid 
097d			 
097d					; TODO handle no space left 
097d					 
097d 22 4c f8				ld (store_tmppageid), hl 
0980			 
0980				if DEBUG_STORESE 
0980					DMARK "AP4" 
0980 f5				push af  
0981 3a 95 09			ld a, (.dmark)  
0984 32 77 fb			ld (debug_mark),a  
0987 3a 96 09			ld a, (.dmark+1)  
098a 32 78 fb			ld (debug_mark+1),a  
098d 3a 97 09			ld a, (.dmark+2)  
0990 32 79 fb			ld (debug_mark+2),a  
0993 18 03			jr .pastdmark  
0995 ..			.dmark: db "AP4"  
0998 f1			.pastdmark: pop af  
0999			endm  
# End of macro DMARK
0999					CALLMONITOR 
0999 cd 4d 17			call break_point_state  
099c				endm  
# End of macro CALLMONITOR
099c				endif 
099c					; init the buffer with zeros so we can id if the buffer is full or not 
099c			 
099c e5					push hl 
099d c5					push bc 
099e			 
099e 21 62 f8				ld hl, store_page 
09a1 06 40				ld b, STORE_BLOCK_PHY 
09a3 3e 00				ld a, 0 
09a5 77			.zeroblock:	ld (hl), a 
09a6 23					inc hl 
09a7 10 fc				djnz .zeroblock 
09a9			 
09a9 c1					pop bc 
09aa e1					pop hl 
09ab			 
09ab					; construct block 
09ab			 
09ab 3a 5b f8				ld a, (store_tmpid) 
09ae 32 62 f8				ld (store_page), a   ; file id 
09b1 3a 5a f8				ld a, (store_tmpext)   ; extent for this block 
09b4 32 63 f8				ld (store_page+1), a 
09b7			 
09b7 e1					pop hl    ; get string to write 
09b8 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
09ba 11 64 f8				ld de, store_page+2 
09bd			 
09bd				if DEBUG_STORESE 
09bd					DMARK "AP5" 
09bd f5				push af  
09be 3a d2 09			ld a, (.dmark)  
09c1 32 77 fb			ld (debug_mark),a  
09c4 3a d3 09			ld a, (.dmark+1)  
09c7 32 78 fb			ld (debug_mark+1),a  
09ca 3a d4 09			ld a, (.dmark+2)  
09cd 32 79 fb			ld (debug_mark+2),a  
09d0 18 03			jr .pastdmark  
09d2 ..			.dmark: db "AP5"  
09d5 f1			.pastdmark: pop af  
09d6			endm  
# End of macro DMARK
09d6					CALLMONITOR 
09d6 cd 4d 17			call break_point_state  
09d9				endm  
# End of macro CALLMONITOR
09d9				endif 
09d9			 
09d9			 
09d9			 
09d9					; fill buffer with data until end of string or full block 
09d9			 
09d9 7e			.appd:		ld a, (hl) 
09da 12					ld (de), a 
09db fe 00				cp 0 
09dd 28 04				jr z, .appdone 
09df 23					inc hl 
09e0 13					inc de 
09e1 10 f6				djnz .appd 
09e3			 
09e3 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
09e4 f5					push af   		; save last byte dumped 
09e5			 
09e5			 
09e5 2a 4c f8			ld hl, (store_tmppageid) 
09e8 11 62 f8			ld de, store_page 
09eb				if DEBUG_STORESE 
09eb					DMARK "AP6" 
09eb f5				push af  
09ec 3a 00 0a			ld a, (.dmark)  
09ef 32 77 fb			ld (debug_mark),a  
09f2 3a 01 0a			ld a, (.dmark+1)  
09f5 32 78 fb			ld (debug_mark+1),a  
09f8 3a 02 0a			ld a, (.dmark+2)  
09fb 32 79 fb			ld (debug_mark+2),a  
09fe 18 03			jr .pastdmark  
0a00 ..			.dmark: db "AP6"  
0a03 f1			.pastdmark: pop af  
0a04			endm  
# End of macro DMARK
0a04					CALLMONITOR 
0a04 cd 4d 17			call break_point_state  
0a07				endm  
# End of macro CALLMONITOR
0a07				endif 
0a07 cd 71 03				call storage_write_block 
0a0a			 
0a0a			 
0a0a				; was that a full block of data written? 
0a0a				; any more to write out? 
0a0a			 
0a0a				; if yes then set vars and jump to start of function again 
0a0a			 
0a0a f1					pop af 
0a0b d1					pop de 
0a0c			 
0a0c fe 00				cp 0		 ; no, string was fully written 
0a0e c8					ret z 
0a0f			 
0a0f					; setup vars for next cycle 
0a0f			 
0a0f 3a 5b f8				ld a, (store_tmpid) 
0a12 6f					ld l, a 
0a13 26 00				ld h, 0 
0a15			 
0a15 c3 d7 08			 	jp storage_append	 ; yes, need to write out some more 
0a18			 
0a18			 
0a18			 
0a18			 
0a18			 
0a18			 
0a18			 
0a18			if DEBUG_STORECF 
0a18			storageput:	 
0a18					ret 
0a18			storageread: 
0a18					ld hl, store_page 
0a18					ld b, 200 
0a18					ld a,0 
0a18			.src:		ld (hl),a 
0a18					inc hl 
0a18					djnz .src 
0a18					 
0a18			 
0a18					ld de, 0 
0a18					ld bc, 1 
0a18					ld hl, store_page 
0a18					call cfRead 
0a18			 
0a18				call cfGetError 
0a18				ld hl,scratch 
0a18				call hexout 
0a18				ld hl, scratch+2 
0a18				ld a, 0 
0a18				ld (hl),a 
0a18				ld de, scratch 
0a18				ld a,display_row_1 
0a18				call str_at_display 
0a18				call update_display 
0a18			 
0a18					ld hl, store_page 
0a18					ld (os_cur_ptr),hl 
0a18			 
0a18					ret 
0a18			endif 
0a18			 
0a18			 
0a18			; Clear out the main buffer store (used to remove junk before writing a new block) 
0a18			 
0a18			storage_clear_page: 
0a18 e5				push hl 
0a19 d5				push de 
0a1a c5				push bc 
0a1b 21 62 f8			ld hl, store_page 
0a1e 3e 00			ld a, 0 
0a20 77				ld (hl), a 
0a21			 
0a21 11 63 f8			ld de, store_page+1 
0a24 01 40 00			ld bc, STORE_BLOCK_PHY 
0a27			 
0a27 ed b0			ldir 
0a29				 
0a29 c1				pop bc 
0a2a d1				pop de 
0a2b e1				pop hl 
0a2c c9				ret 
0a2d			 
0a2d			; eof 
# End of file firmware_storage.asm
0a2d			  
0a2d			; support routines for above hardware abstraction layer  
0a2d			  
0a2d			include "firmware_general.asm"        ; general support functions  
0a2d			 
0a2d			; word look up 
0a2d			 
0a2d			; in 
0a2d			; a is the index 
0a2d			; hl is pointer start of array 
0a2d			; 
0a2d			; returns 
0a2d			; hl to the word 
0a2d			; 
0a2d			 
0a2d			table_lookup:  
0a2d d5					push de 
0a2e eb					ex de, hl 
0a2f			 
0a2f 6f					ld l, a 
0a30 26 00				ld h, 0 
0a32 29					add hl, hl 
0a33 19					add hl, de 
0a34 7e					ld a, (hl) 
0a35 23					inc hl 
0a36 66					ld h,(hl) 
0a37 6f					ld l, a 
0a38			 
0a38 d1					pop de 
0a39 c9					ret 
0a3a			 
0a3a			; Delay loops 
0a3a			 
0a3a			 
0a3a			 
0a3a			aDelayInMS: 
0a3a c5				push bc 
0a3b 47				ld b,a 
0a3c			msdelay: 
0a3c c5				push bc 
0a3d				 
0a3d			 
0a3d 01 41 00			ld bc,041h 
0a40 cd 58 0a			call delayloop 
0a43 c1				pop bc 
0a44 05				dec b 
0a45 20 f5			jr nz,msdelay 
0a47			 
0a47			;if CPU_CLOCK_8MHZ 
0a47			;msdelay8: 
0a47			;	push bc 
0a47			;	 
0a47			; 
0a47			;	ld bc,041h 
0a47			;	call delayloop 
0a47			;	pop bc 
0a47			;	dec b 
0a47			;	jr nz,msdelay8 
0a47			;endif 
0a47			 
0a47			 
0a47 c1				pop bc 
0a48 c9				ret 
0a49			 
0a49			 
0a49			delay250ms: 
0a49				;push de 
0a49 01 00 40			ld bc, 04000h 
0a4c c3 58 0a			jp delayloop 
0a4f			delay500ms: 
0a4f				;push de 
0a4f 01 00 80			ld bc, 08000h 
0a52 c3 58 0a			jp delayloop 
0a55			delay1s: 
0a55				;push bc 
0a55			   ; Clobbers A, d and e 
0a55 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0a58			delayloop: 
0a58 c5			    push bc 
0a59			 
0a59			if BASE_CPM 
0a59				ld bc, CPM_DELAY_TUNE 
0a59			.cpmloop: 
0a59				push bc 
0a59			 
0a59			endif 
0a59			 
0a59			 
0a59			 
0a59			delayloopi: 
0a59			;	push bc 
0a59			;.dl: 
0a59 cb 47		    bit     0,a    	; 8 
0a5b cb 47		    bit     0,a    	; 8 
0a5d cb 47		    bit     0,a    	; 8 
0a5f e6 ff		    and     255  	; 7 
0a61 0b			    dec     bc      	; 6 
0a62 79			    ld      a,c     	; 4 
0a63 b0			    or      b     	; 4 
0a64 c2 59 0a		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0a67			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0a67				;pop de 
0a67			;pop bc 
0a67			 
0a67			if BASE_CPM 
0a67				pop bc 
0a67				 
0a67			    dec     bc      	; 6 
0a67			    ld      a,c     	; 4 
0a67			    or      b     	; 4 
0a67			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0a67				 
0a67			 
0a67			endif 
0a67			;if CPU_CLOCK_8MHZ 
0a67			;    pop bc 
0a67			;    push bc 
0a67			;.dl8: 
0a67			;    bit     0,a    	; 8 
0a67			;    bit     0,a    	; 8 
0a67			;    bit     0,a    	; 8 
0a67			;    and     255  	; 7 
0a67			;    dec     bc      	; 6 
0a67			;    ld      a,c     	; 4 
0a67			;    or      b     	; 4 
0a67			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0a67			;endif 
0a67			 
0a67			;if CPU_CLOCK_10MHZ 
0a67			;    pop bc 
0a67			;    push bc 
0a67			;.dl8: 
0a67			;    bit     0,a    	; 8 
0a67			;    bit     0,a    	; 8 
0a67			;    bit     0,a    	; 8 
0a67			;    and     255  	; 7 
0a67			;    dec     bc      	; 6 
0a67			;    ld      a,c     	; 4 
0a67			;    or      b     	; 4 
0a67			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0a67			;endif 
0a67 c1			    pop bc 
0a68			 
0a68 c9				ret 
0a69			 
0a69			 
0a69			 
0a69			; eof 
# End of file firmware_general.asm
0a69			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0a69			; display routines that use the physical hardware abstraction layer 
0a69			 
0a69			 
0a69			; information window 
0a69			 
0a69			; pass hl with 1st string to display 
0a69			; pass de with 2nd string to display 
0a69			 
0a69			info_panel: 
0a69 e5				push hl 
0a6a			 
0a6a 2a d8 f8			ld hl, (display_fb_active) 
0a6d e5				push hl    ; future de destination 
0a6e 21 bd fa				ld hl, display_fb0 
0a71 22 d8 f8				ld (display_fb_active), hl 
0a74			 
0a74 cd d5 0a			call clear_display 
0a77			 
0a77			 
0a77 3e 55			ld a, display_row_3 + 5 
0a79 cd e8 0a			call str_at_display 
0a7c			 
0a7c e1				pop hl 
0a7d d1				pop de 
0a7e			 
0a7e e5				push hl 
0a7f			 
0a7f			 
0a7f 3e 2d			ld a, display_row_2 + 5 
0a81 cd e8 0a			call str_at_display 
0a84			 
0a84			 
0a84 cd f8 0a			call update_display 
0a87 cd 55 1c			call next_page_prompt 
0a8a cd d5 0a			call clear_display 
0a8d			 
0a8d				 
0a8d 21 1c fa				ld hl, display_fb1 
0a90 22 d8 f8				ld (display_fb_active), hl 
0a93 cd f8 0a			call update_display 
0a96			 
0a96			 
0a96 c9				ret 
0a97			 
0a97			 
0a97			 
0a97			 
0a97			; TODO windowing? 
0a97			 
0a97			; TODO scroll line up 
0a97			 
0a97			scroll_up: 
0a97			 
0a97 e5				push hl 
0a98 d5				push de 
0a99 c5				push bc 
0a9a			 
0a9a				; get frame buffer  
0a9a			 
0a9a 2a d8 f8			ld hl, (display_fb_active) 
0a9d e5				push hl    ; future de destination 
0a9e			 
0a9e 11 28 00			ld  de, display_cols 
0aa1 19				add hl, de 
0aa2			 
0aa2 d1				pop de 
0aa3			 
0aa3				;ex de, hl 
0aa3 01 9f 00			ld bc, display_fb_len -1  
0aa6			;if DEBUG_FORTH_WORDS 
0aa6			;	DMARK "SCL" 
0aa6			;	CALLMONITOR 
0aa6			;endif	 
0aa6 ed b0			ldir 
0aa8			 
0aa8				; wipe bottom row 
0aa8			 
0aa8			 
0aa8 2a d8 f8			ld hl, (display_fb_active) 
0aab 11 a0 00			ld de, display_cols*display_rows 
0aae 19				add hl, de 
0aaf 06 28			ld b, display_cols 
0ab1 3e 20			ld a, ' ' 
0ab3			.scwipe: 
0ab3 77				ld (hl), a 
0ab4 2b				dec hl 
0ab5 10 fc			djnz .scwipe 
0ab7			 
0ab7				;pop hl 
0ab7			 
0ab7 c1				pop bc 
0ab8 d1				pop de 
0ab9 e1				pop hl 
0aba			 
0aba c9				ret 
0abb			 
0abb			 
0abb			;scroll_upo: 
0abb			;	ld de, display_row_1 
0abb			 ;	ld hl, display_row_2 
0abb			;	ld bc, display_cols 
0abb			;	ldir 
0abb			;	ld de, display_row_2 
0abb			 ;	ld hl, display_row_3 
0abb			;	ld bc, display_cols 
0abb			;	ldir 
0abb			;	ld de, display_row_3 
0abb			 ;	ld hl, display_row_4 
0abb			;	ld bc, display_cols 
0abb			;	ldir 
0abb			 
0abb			; TODO clear row 4 
0abb			 
0abb			;	ret 
0abb			 
0abb				 
0abb			scroll_down: 
0abb			 
0abb e5				push hl 
0abc d5				push de 
0abd c5				push bc 
0abe			 
0abe				; get frame buffer  
0abe			 
0abe 2a d8 f8			ld hl, (display_fb_active) 
0ac1			 
0ac1 11 9f 00			ld de, display_fb_len - 1 
0ac4 19				add hl, de 
0ac5			 
0ac5 e5			push hl    ; future de destination 
0ac6			 
0ac6 11 28 00			ld  de, display_cols 
0ac9 ed 52			sbc hl, de 
0acb			 
0acb			 
0acb d1				pop de 
0acc			 
0acc			;	ex de, hl 
0acc 01 9f 00			ld bc, display_fb_len -1  
0acf			 
0acf			 
0acf				 
0acf			 
0acf ed b0			ldir 
0ad1			 
0ad1				; wipe bottom row 
0ad1			 
0ad1			 
0ad1			;	ld hl, (display_fb_active) 
0ad1			;;	ld de, display_cols*display_rows 
0ad1			;;	add hl, de 
0ad1			;	ld b, display_cols 
0ad1			;	ld a, ' ' 
0ad1			;.scwiped: 
0ad1			;	ld (hl), a 
0ad1			;	dec hl 
0ad1			;	djnz .scwiped 
0ad1			 
0ad1				;pop hl 
0ad1			 
0ad1 c1				pop bc 
0ad2 d1				pop de 
0ad3 e1				pop hl 
0ad4			 
0ad4 c9				ret 
0ad5			;scroll_down: 
0ad5			;	ld de, display_row_4 
0ad5			;	ld hl, display_row_3 
0ad5			;	ld bc, display_cols 
0ad5			;	ldir 
0ad5			;	ld de, display_row_3 
0ad5			; 	ld hl, display_row_2 
0ad5			;	ld bc, display_cols 
0ad5			;	ldir 
0ad5			;	ld de, display_row_2 
0ad5			;	ld hl, display_row_1 
0ad5			;	ld bc, display_cols 
0ad5			;	ldir 
0ad5			;;; TODO clear row 1 
0ad5			;	ret 
0ad5			 
0ad5			 
0ad5			 
0ad5			 
0ad5			 
0ad5			; clear active frame buffer 
0ad5			 
0ad5			clear_display: 
0ad5 3e 20			ld a, ' ' 
0ad7 c3 da 0a			jp fill_display 
0ada			 
0ada			; fill active frame buffer with a char in A 
0ada			 
0ada			fill_display: 
0ada 06 a0			ld b,display_fb_len 
0adc 2a d8 f8			ld hl, (display_fb_active) 
0adf 77			.fd1:	ld (hl),a 
0ae0 23				inc hl 
0ae1 10 fc			djnz .fd1 
0ae3 23				inc hl 
0ae4 3e 00			ld a,0 
0ae6 77				ld (hl),a 
0ae7			 
0ae7			 
0ae7 c9				ret 
0ae8			; Write string (DE) at pos (A) to active frame buffer 
0ae8			 
0ae8 2a d8 f8		str_at_display:    ld hl,(display_fb_active) 
0aeb 06 00					ld b,0 
0aed 4f					ld c,a 
0aee 09					add hl,bc 
0aef 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0af0 b7			            OR   A              ;Null terminator? 
0af1 c8			            RET  Z              ;Yes, so finished 
0af2 77					ld (hl),a 
0af3 23				inc hl 
0af4 13			            INC  DE             ;Point to next character 
0af5 18 f8		            JR   .sad1     ;Repeat 
0af7 c9					ret 
0af8			 
0af8			; using current frame buffer write to physical display 
0af8			 
0af8			update_display: 
0af8 e5				push hl 
0af9 2a d8 f8			ld hl, (display_fb_active) 
0afc cd 7b 65			call write_display 
0aff e1				pop hl 
0b00 c9				ret 
0b01			 
0b01			; TODO scrolling 
0b01			 
0b01			 
0b01			; move cursor right one char 
0b01			cursor_right: 
0b01			 
0b01				; TODO shift right 
0b01				; TODO if beyond max col 
0b01				; TODO       cursor_next_line 
0b01			 
0b01 c9				ret 
0b02			 
0b02			 
0b02			cursor_next_line: 
0b02				; TODO first char 
0b02				; TODO line down 
0b02				; TODO if past last row 
0b02				; TODO    scroll up 
0b02			 
0b02 c9				ret 
0b03			 
0b03			cursor_left: 
0b03				; TODO shift left 
0b03				; TODO if beyond left  
0b03				; TODO     cursor prev line 
0b03				 
0b03 c9				ret 
0b04			 
0b04			cursor_prev_line: 
0b04				; TODO last char 
0b04				; TODO line up 
0b04				; TODO if past first row 
0b04				; TODO   scroll down 
0b04			 
0b04 c9				ret 
0b05			 
0b05			 
0b05			cout: 
0b05				; A - char 
0b05 c9				ret 
0b06			 
0b06			 
0b06			; Display a menu and allow item selection (optional toggle items) 
0b06			; 
0b06			; format: 
0b06			; hl pointer to word array with zero term for items 
0b06			; e.g.    db item1 
0b06			;         db .... 
0b06			;         db 0 
0b06			; 
0b06			; a = starting menu item  
0b06			; 
0b06			; de = pointer item toggle array   (todo) 
0b06			; 
0b06			; returns item selected in a 1-... 
0b06			; returns 0 if back button pressed 
0b06			; 
0b06			; NOTE: Uses system frame buffer to display 
0b06			; 
0b06			; LEFT, Q = go back 
0b06			; RIGHT, SPACE, CR = select 
0b06			; UP, A - Up 
0b06			; DOWN, Z - Down 
0b06			 
0b06			 
0b06			 
0b06			 
0b06			 
0b06			menu: 
0b06			 
0b06					; keep array pointer 
0b06			 
0b06 22 60 f8				ld (store_tmp1), hl 
0b09 32 5e f8				ld (store_tmp2), a 
0b0c			 
0b0c					; check for key bounce 
0b0c			 
0b0c			if BASE_KEV 
0b0c			 
0b0c cd c6 68		.mbounce:	call cin 
0b0f fe 00				cp 0 
0b11 20 f9				jr nz, .mbounce 
0b13			endif 
0b13					; for ease use ex 
0b13			 
0b13					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0b13 21 bd fa				ld hl, display_fb0 
0b16 22 d8 f8				ld (display_fb_active), hl 
0b19			 
0b19 cd d5 0a		.mloop:		call clear_display 
0b1c cd f8 0a				call update_display 
0b1f			 
0b1f					; draw selection id '>' at 1 
0b1f			 
0b1f					; init start of list display 
0b1f			 
0b1f 3e 05				ld a, 5 
0b21 32 5c f8				ld (store_tmp3), a   ; display row count 
0b24 3a 5e f8				ld a,( store_tmp2) 
0b27 32 5f f8				ld (store_tmp2+1), a   ; display item count 
0b2a			 
0b2a					 
0b2a			.mitem:	 
0b2a			 
0b2a			 
0b2a 3a 5f f8				ld a,(store_tmp2+1) 
0b2d 6f					ld l, a 
0b2e 26 00				ld h, 0 
0b30 29					add hl, hl 
0b31 ed 5b 60 f8			ld de, (store_tmp1) 
0b35 19					add hl, de 
0b36 7e					ld a, (hl) 
0b37 23					inc hl 
0b38 66					ld h,(hl) 
0b39 6f					ld l, a 
0b3a			 
0b3a cd 32 0d				call ishlzero 
0b3d 28 1a				jr z, .mdone 
0b3f			 
0b3f eb					ex de, hl 
0b40 3a 5c f8				ld a, (store_tmp3) 
0b43 cd e8 0a				call str_at_display 
0b46					 
0b46			 
0b46					; next item 
0b46 3a 5f f8				ld a, (store_tmp2+1) 
0b49 3c					inc a 
0b4a 32 5f f8				ld (store_tmp2+1), a   ; display item count 
0b4d			 
0b4d			 		; next row 
0b4d			 
0b4d 3a 5c f8				ld a, (store_tmp3) 
0b50 c6 28				add display_cols 
0b52 32 5c f8				ld (store_tmp3), a 
0b55			 
0b55					; at end of screen? 
0b55			 
0b55 fe 10				cp display_rows*4 
0b57 20 d1				jr nz, .mitem 
0b59			 
0b59			 
0b59			.mdone: 
0b59 cd 32 0d				call ishlzero 
0b5c 28 08				jr z, .nodn 
0b5e			 
0b5e 3e 78				ld a, display_row_4 
0b60 11 df 0b				ld de, .mdown 
0b63 cd e8 0a				call str_at_display 
0b66			 
0b66					; draw options to fill the screens with active item on line 1 
0b66					; if current option is 2 or more then display ^ in top 
0b66			 
0b66 3a 5e f8		.nodn:		ld a, (store_tmp2) 
0b69 fe 00				cp 0 
0b6b 28 08				jr z, .noup 
0b6d			 
0b6d 3e 00				ld a, 0 
0b6f 11 dd 0b				ld de, .mup 
0b72 cd e8 0a				call str_at_display 
0b75			 
0b75 3e 02		.noup:		ld a, 2 
0b77 11 db 0b				ld de, .msel 
0b7a cd e8 0a				call str_at_display 
0b7d			 
0b7d					; if current option + 1 is not null then display V in bottom 
0b7d					; get key 
0b7d cd f8 0a				call update_display 
0b80			 
0b80			 
0b80					; handle key 
0b80			 
0b80 cd b5 68				call cin_wait 
0b83			 
0b83 fe 05				cp KEY_UP 
0b85 28 2b				jr z, .mgoup 
0b87 fe 61				cp 'a' 
0b89 28 27				jr z, .mgoup 
0b8b fe 0a				cp KEY_DOWN 
0b8d 28 32				jr z, .mgod 
0b8f fe 7a				cp 'z' 
0b91 28 2e				jr z, .mgod 
0b93 fe 20				cp ' ' 
0b95 28 34				jr z, .goend 
0b97 fe 0c				cp KEY_RIGHT 
0b99 28 30				jr z, .goend 
0b9b fe 0d				cp KEY_CR 
0b9d 28 2c				jr z, .goend 
0b9f fe 71				cp 'q' 
0ba1 28 0b				jr z, .goback 
0ba3			 
0ba3 fe 0b				cp KEY_LEFT 
0ba5 28 07				jr z, .goback 
0ba7 fe 08				cp KEY_BS 
0ba9 28 03				jr z, .goback 
0bab c3 19 0b				jp .mloop 
0bae			 
0bae			.goback: 
0bae 3e 00			ld a, 0 
0bb0 18 1d			jr .goend2 
0bb2			 
0bb2				; move up one 
0bb2			.mgoup: 
0bb2 3a 5e f8				ld a, (store_tmp2) 
0bb5 fe 00				cp 0 
0bb7 ca 19 0b				jp z, .mloop 
0bba 3d					dec a 
0bbb 32 5e f8				ld (store_tmp2), a 
0bbe c3 19 0b				jp .mloop 
0bc1			 
0bc1				; move down one 
0bc1			.mgod: 
0bc1 3a 5e f8				ld a, (store_tmp2) 
0bc4 3c					inc a 
0bc5 32 5e f8				ld (store_tmp2), a 
0bc8 c3 19 0b				jp .mloop 
0bcb			 
0bcb			 
0bcb			.goend: 
0bcb					; get selected item number 
0bcb			 
0bcb 3a 5e f8				ld a, (store_tmp2) 
0bce 3c					inc a 
0bcf			 
0bcf			.goend2: 
0bcf f5					push af 
0bd0			 
0bd0					; restore active fb 
0bd0					; TODO BUG assumes fb1 
0bd0			 
0bd0 21 1c fa				ld hl, display_fb1 
0bd3 22 d8 f8				ld (display_fb_active), hl 
0bd6			 
0bd6					; restore main regs 
0bd6			 
0bd6			 
0bd6 cd f8 0a				call update_display 
0bd9			 
0bd9 f1					pop af 
0bda			 
0bda c9				ret 
0bdb			 
0bdb .. 00		.msel:   db ">",0 
0bdd .. 00		.mup:   db "^",0 
0bdf .. 00		.mdown:   db "v",0 
0be1			 
0be1			 
0be1			; eof 
0be1			 
# End of file firmware_display.asm
0be1			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0be1			; random number generators 
0be1			 
0be1			 
0be1			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0be1			 
0be1			 
0be1			;-----> Generate a random number 
0be1			; output a=answer 0<=a<=255 
0be1			; all registers are preserved except: af 
0be1			random: 
0be1 e5			        push    hl 
0be2 d5			        push    de 
0be3 2a ba f8		        ld      hl,(randData) 
0be6 ed 5f		        ld      a,r 
0be8 57			        ld      d,a 
0be9 5e			        ld      e,(hl) 
0bea 19			        add     hl,de 
0beb 85			        add     a,l 
0bec ac			        xor     h 
0bed 22 ba f8		        ld      (randData),hl 
0bf0 d1			        pop     de 
0bf1 e1			        pop     hl 
0bf2 c9			        ret 
0bf3			 
0bf3			 
0bf3			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0bf3			 
0bf3			 
0bf3			 
0bf3			;------LFSR------ 
0bf3			;James Montelongo 
0bf3			;optimized by Spencer Putt 
0bf3			;out: 
0bf3			; a = 8 bit random number 
0bf3			RandLFSR: 
0bf3 21 c0 f8		        ld hl,LFSRSeed+4 
0bf6 5e			        ld e,(hl) 
0bf7 23			        inc hl 
0bf8 56			        ld d,(hl) 
0bf9 23			        inc hl 
0bfa 4e			        ld c,(hl) 
0bfb 23			        inc hl 
0bfc 7e			        ld a,(hl) 
0bfd 47			        ld b,a 
0bfe cb 13		        rl e  
0c00 cb 12			rl d 
0c02 cb 11		        rl c  
0c04 17				rla 
0c05 cb 13		        rl e  
0c07 cb 12			rl d 
0c09 cb 11		        rl c  
0c0b 17				rla 
0c0c cb 13		        rl e  
0c0e cb 12			rl d 
0c10 cb 11		        rl c  
0c12 17				rla 
0c13 67			        ld h,a 
0c14 cb 13		        rl e  
0c16 cb 12			rl d 
0c18 cb 11		        rl c  
0c1a 17				rla 
0c1b a8			        xor b 
0c1c cb 13		        rl e  
0c1e cb 12			rl d 
0c20 ac			        xor h 
0c21 a9			        xor c 
0c22 aa			        xor d 
0c23 21 c2 f8		        ld hl,LFSRSeed+6 
0c26 11 c3 f8		        ld de,LFSRSeed+7 
0c29 01 07 00		        ld bc,7 
0c2c ed b8		        lddr 
0c2e 12			        ld (de),a 
0c2f c9			        ret 
0c30			 
0c30			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0c30			 
0c30			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0c30			 
0c30			 
0c30			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0c30			 
0c30			prng16: 
0c30			;Inputs: 
0c30			;   (seed1) contains a 16-bit seed value 
0c30			;   (seed2) contains a NON-ZERO 16-bit seed value 
0c30			;Outputs: 
0c30			;   HL is the result 
0c30			;   BC is the result of the LCG, so not that great of quality 
0c30			;   DE is preserved 
0c30			;Destroys: 
0c30			;   AF 
0c30			;cycle: 4,294,901,760 (almost 4.3 billion) 
0c30			;160cc 
0c30			;26 bytes 
0c30 2a b4 f8		    ld hl,(seed1) 
0c33 44			    ld b,h 
0c34 4d			    ld c,l 
0c35 29			    add hl,hl 
0c36 29			    add hl,hl 
0c37 2c			    inc l 
0c38 09			    add hl,bc 
0c39 22 b4 f8		    ld (seed1),hl 
0c3c 2a b2 f8		    ld hl,(seed2) 
0c3f 29			    add hl,hl 
0c40 9f			    sbc a,a 
0c41 e6 2d		    and %00101101 
0c43 ad			    xor l 
0c44 6f			    ld l,a 
0c45 22 b2 f8		    ld (seed2),hl 
0c48 09			    add hl,bc 
0c49 c9			    ret 
0c4a			 
0c4a			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0c4a			 
0c4a			rand32: 
0c4a			;Inputs: 
0c4a			;   (seed1_0) holds the lower 16 bits of the first seed 
0c4a			;   (seed1_1) holds the upper 16 bits of the first seed 
0c4a			;   (seed2_0) holds the lower 16 bits of the second seed 
0c4a			;   (seed2_1) holds the upper 16 bits of the second seed 
0c4a			;   **NOTE: seed2 must be non-zero 
0c4a			;Outputs: 
0c4a			;   HL is the result 
0c4a			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0c4a			;Destroys: 
0c4a			;   AF 
0c4a			;Tested and passes all CAcert tests 
0c4a			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0c4a			;it has a period of 18,446,744,069,414,584,320 
0c4a			;roughly 18.4 quintillion. 
0c4a			;LFSR taps: 0,2,6,7  = 11000101 
0c4a			;291cc 
0c4a			;seed1_0=$+1 
0c4a			;    ld hl,12345 
0c4a			;seed1_1=$+1 
0c4a			;    ld de,6789 
0c4a			;    ld b,h 
0c4a			;    ld c,l 
0c4a			;    add hl,hl \ rl e \ rl d 
0c4a			;    add hl,hl \ rl e \ rl d 
0c4a			;    inc l 
0c4a			;    add hl,bc 
0c4a			;    ld (seed1_0),hl 
0c4a			;    ld hl,(seed1_1) 
0c4a			;    adc hl,de 
0c4a			;    ld (seed1_1),hl 
0c4a			;    ex de,hl 
0c4a			;seed2_0=$+1 
0c4a			;    ld hl,9876 
0c4a			;seed2_1=$+1 
0c4a			;    ld bc,54321 
0c4a			;    add hl,hl \ rl c \ rl b 
0c4a			;    ld (seed2_1),bc 
0c4a			;    sbc a,a 
0c4a			;    and %11000101 
0c4a			;    xor l 
0c4a			;    ld l,a 
0c4a			;    ld (seed2_0),hl 
0c4a			;    ex de,hl 
0c4a			;    add hl,bc 
0c4a			;    ret 
0c4a			; 
0c4a			 
0c4a			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0c4a			; 20 bytes, 86 cycles (excluding ret) 
0c4a			 
0c4a			; returns   hl = pseudorandom number 
0c4a			; corrupts   a 
0c4a			 
0c4a			; generates 16-bit pseudorandom numbers with a period of 65535 
0c4a			; using the xorshift method: 
0c4a			 
0c4a			; hl ^= hl << 7 
0c4a			; hl ^= hl >> 9 
0c4a			; hl ^= hl << 8 
0c4a			 
0c4a			; some alternative shift triplets which also perform well are: 
0c4a			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0c4a			 
0c4a			;  org 32768 
0c4a			 
0c4a			xrnd: 
0c4a 2a b8 f8		  ld hl,(xrandc)       ; seed must not be 0 
0c4d 3e 00		  ld a,0 
0c4f bd			  cp l 
0c50 20 02		  jr nz, .xrnd1 
0c52 2e 01		  ld l, 1 
0c54			.xrnd1: 
0c54			 
0c54 7c			  ld a,h 
0c55 1f			  rra 
0c56 7d			  ld a,l 
0c57 1f			  rra 
0c58 ac			  xor h 
0c59 67			  ld h,a 
0c5a 7d			  ld a,l 
0c5b 1f			  rra 
0c5c 7c			  ld a,h 
0c5d 1f			  rra 
0c5e ad			  xor l 
0c5f 6f			  ld l,a 
0c60 ac			  xor h 
0c61 67			  ld h,a 
0c62			 
0c62 22 b8 f8		  ld (xrandc),hl 
0c65			 
0c65 c9			  ret 
0c66			;  
0c66			 
0c66			 
0c66			;;;; int maths 
0c66			 
0c66			; https://map.grauw.nl/articles/mult_div_shifts.php 
0c66			; Divide 16-bit values (with 16-bit result) 
0c66			; In: Divide BC by divider DE 
0c66			; Out: BC = result, HL = rest 
0c66			; 
0c66			Div16: 
0c66 21 00 00		    ld hl,0 
0c69 78			    ld a,b 
0c6a 06 08		    ld b,8 
0c6c			Div16_Loop1: 
0c6c 17			    rla 
0c6d ed 6a		    adc hl,hl 
0c6f ed 52		    sbc hl,de 
0c71 30 01		    jr nc,Div16_NoAdd1 
0c73 19			    add hl,de 
0c74			Div16_NoAdd1: 
0c74 10 f6		    djnz Div16_Loop1 
0c76 17			    rla 
0c77 2f			    cpl 
0c78 47			    ld b,a 
0c79 79			    ld a,c 
0c7a 48			    ld c,b 
0c7b 06 08		    ld b,8 
0c7d			Div16_Loop2: 
0c7d 17			    rla 
0c7e ed 6a		    adc hl,hl 
0c80 ed 52		    sbc hl,de 
0c82 30 01		    jr nc,Div16_NoAdd2 
0c84 19			    add hl,de 
0c85			Div16_NoAdd2: 
0c85 10 f6		    djnz Div16_Loop2 
0c87 17			    rla 
0c88 2f			    cpl 
0c89 41			    ld b,c 
0c8a 4f			    ld c,a 
0c8b c9			ret 
0c8c			 
0c8c			 
0c8c			;http://z80-heaven.wikidot.com/math 
0c8c			; 
0c8c			;Inputs: 
0c8c			;     DE and A are factors 
0c8c			;Outputs: 
0c8c			;     A is not changed 
0c8c			;     B is 0 
0c8c			;     C is not changed 
0c8c			;     DE is not changed 
0c8c			;     HL is the product 
0c8c			;Time: 
0c8c			;     342+6x 
0c8c			; 
0c8c			Mult16: 
0c8c			 
0c8c 06 08		     ld b,8          ;7           7 
0c8e 21 00 00		     ld hl,0         ;10         10 
0c91 29			       add hl,hl     ;11*8       88 
0c92 07			       rlca          ;4*8        32 
0c93 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0c95 19			         add hl,de   ;--         -- 
0c96 10 f9		       djnz $-5      ;13*7+8     99 
0c98 c9			ret 
0c99			 
0c99			; 
0c99			; Square root of 16-bit value 
0c99			; In:  HL = value 
0c99			; Out:  D = result (rounded down) 
0c99			; 
0c99			;Sqr16: 
0c99			;    ld de,#0040 
0c99			;    ld a,l 
0c99			;    ld l,h 
0c99			;    ld h,d 
0c99			;    or a 
0c99			;    ld b,8 
0c99			;Sqr16_Loop: 
0c99			;    sbc hl,de 
0c99			;    jr nc,Sqr16_Skip 
0c99			;    add hl,de 
0c99			;Sqr16_Skip: 
0c99			;    ccf 
0c99			;    rl d 
0c99			;    add a,a 
0c99			;    adc hl,hl 
0c99			;    add a,a 
0c99			;    adc hl,hl 
0c99			;    djnz Sqr16_Loop 
0c99			;    ret 
0c99			; 
0c99			; 
0c99			; Divide 8-bit values 
0c99			; In: Divide E by divider C 
0c99			; Out: A = result, B = rest 
0c99			; 
0c99			Div8: 
0c99 af			    xor a 
0c9a 06 08		    ld b,8 
0c9c			Div8_Loop: 
0c9c cb 13		    rl e 
0c9e 17			    rla 
0c9f 91			    sub c 
0ca0 30 01		    jr nc,Div8_NoAdd 
0ca2 81			    add a,c 
0ca3			Div8_NoAdd: 
0ca3 10 f7		    djnz Div8_Loop 
0ca5 47			    ld b,a 
0ca6 7b			    ld a,e 
0ca7 17			    rla 
0ca8 2f			    cpl 
0ca9 c9			    ret 
0caa			 
0caa			; 
0caa			; Multiply 8-bit value with a 16-bit value (unrolled) 
0caa			; In: Multiply A with DE 
0caa			; Out: HL = result 
0caa			; 
0caa			Mult12U: 
0caa 2e 00		    ld l,0 
0cac 87			    add a,a 
0cad 30 01		    jr nc,Mult12U_NoAdd0 
0caf 19			    add hl,de 
0cb0			Mult12U_NoAdd0: 
0cb0 29			    add hl,hl 
0cb1 87			    add a,a 
0cb2 30 01		    jr nc,Mult12U_NoAdd1 
0cb4 19			    add hl,de 
0cb5			Mult12U_NoAdd1: 
0cb5 29			    add hl,hl 
0cb6 87			    add a,a 
0cb7 30 01		    jr nc,Mult12U_NoAdd2 
0cb9 19			    add hl,de 
0cba			Mult12U_NoAdd2: 
0cba 29			    add hl,hl 
0cbb 87			    add a,a 
0cbc 30 01		    jr nc,Mult12U_NoAdd3 
0cbe 19			    add hl,de 
0cbf			Mult12U_NoAdd3: 
0cbf 29			    add hl,hl 
0cc0 87			    add a,a 
0cc1 30 01		    jr nc,Mult12U_NoAdd4 
0cc3 19			    add hl,de 
0cc4			Mult12U_NoAdd4: 
0cc4 29			    add hl,hl 
0cc5 87			    add a,a 
0cc6 30 01		    jr nc,Mult12U_NoAdd5 
0cc8 19			    add hl,de 
0cc9			Mult12U_NoAdd5: 
0cc9 29			    add hl,hl 
0cca 87			    add a,a 
0ccb 30 01		    jr nc,Mult12U_NoAdd6 
0ccd 19			    add hl,de 
0cce			Mult12U_NoAdd6: 
0cce 29			    add hl,hl 
0ccf 87			    add a,a 
0cd0 d0			    ret nc 
0cd1 19			    add hl,de 
0cd2 c9			    ret 
0cd3			 
0cd3			; 
0cd3			; Multiply 8-bit value with a 16-bit value (right rotating) 
0cd3			; In: Multiply A with DE 
0cd3			;      Put lowest value in A for most efficient calculation 
0cd3			; Out: HL = result 
0cd3			; 
0cd3			Mult12R: 
0cd3 21 00 00		    ld hl,0 
0cd6			Mult12R_Loop: 
0cd6 cb 3f		    srl a 
0cd8 30 01		    jr nc,Mult12R_NoAdd 
0cda 19			    add hl,de 
0cdb			Mult12R_NoAdd: 
0cdb cb 23		    sla e 
0cdd cb 12		    rl d 
0cdf b7			    or a 
0ce0 c2 d6 0c		    jp nz,Mult12R_Loop 
0ce3 c9			    ret 
0ce4			 
0ce4			; 
0ce4			; Multiply 16-bit values (with 32-bit result) 
0ce4			; In: Multiply BC with DE 
0ce4			; Out: BCHL = result 
0ce4			; 
0ce4			Mult32: 
0ce4 79			    ld a,c 
0ce5 48			    ld c,b 
0ce6 21 00 00		    ld hl,0 
0ce9 06 10		    ld b,16 
0ceb			Mult32_Loop: 
0ceb 29			    add hl,hl 
0cec 17			    rla 
0ced cb 11		    rl c 
0cef 30 07		    jr nc,Mult32_NoAdd 
0cf1 19			    add hl,de 
0cf2 ce 00		    adc a,0 
0cf4 d2 f8 0c		    jp nc,Mult32_NoAdd 
0cf7 0c			    inc c 
0cf8			Mult32_NoAdd: 
0cf8 10 f1		    djnz Mult32_Loop 
0cfa 41			    ld b,c 
0cfb 4f			    ld c,a 
0cfc c9			    ret 
0cfd			 
0cfd			 
0cfd			 
0cfd			; 
0cfd			; Multiply 8-bit values 
0cfd			; In:  Multiply H with E 
0cfd			; Out: HL = result 
0cfd			; 
0cfd			Mult8: 
0cfd 16 00		    ld d,0 
0cff 6a			    ld l,d 
0d00 06 08		    ld b,8 
0d02			Mult8_Loop: 
0d02 29			    add hl,hl 
0d03 30 01		    jr nc,Mult8_NoAdd 
0d05 19			    add hl,de 
0d06			Mult8_NoAdd: 
0d06 10 fa		    djnz Mult8_Loop 
0d08 c9			    ret 
0d09			 
0d09			 
0d09			 
0d09			 
0d09			 
0d09			 
0d09			 
0d09			 
0d09			;;http://z80-heaven.wikidot.com/math 
0d09			;;This divides DE by BC, storing the result in DE, remainder in HL 
0d09			; 
0d09			;DE_Div_BC:          ;1281-2x, x is at most 16 
0d09			;     ld a,16        ;7 
0d09			;     ld hl,0        ;10 
0d09			;     jp $+5         ;10 
0d09			;.DivLoop: 
0d09			;       add hl,bc    ;-- 
0d09			;       dec a        ;64 
0d09			;       jr z,.DivLoopEnd        ;86 
0d09			; 
0d09			;       sla e        ;128 
0d09			;       rl d         ;128 
0d09			;       adc hl,hl    ;240 
0d09			;       sbc hl,bc    ;240 
0d09			;       jr nc,.DivLoop ;23|21 
0d09			;       inc e        ;-- 
0d09			;       jp .DivLoop+1 
0d09			; 
0d09			;.DivLoopEnd: 
0d09			 
0d09			;HL_Div_C: 
0d09			;Inputs: 
0d09			;     HL is the numerator 
0d09			;     C is the denominator 
0d09			;Outputs: 
0d09			;     A is the remainder 
0d09			;     B is 0 
0d09			;     C is not changed 
0d09			;     DE is not changed 
0d09			;     HL is the quotient 
0d09			; 
0d09			;       ld b,16 
0d09			;       xor a 
0d09			;         add hl,hl 
0d09			;         rla 
0d09			;         cp c 
0d09			;         jr c,$+4 
0d09			;           inc l 
0d09			;           sub c 
0d09			;         djnz $-7 
0d09			 
0d09			; https://plutiedev.com/z80-add-8bit-to-16bit 
0d09			 
0d09			addatohl: 
0d09 85			    add   a, l    ; A = A+L 
0d0a 6f			    ld    l, a    ; L = A+L 
0d0b 8c			    adc   a, h    ; A = A+L+H+carry 
0d0c 95			    sub   l       ; A = H+carry 
0d0d 67			    ld    h, a    ; H = H+carry 
0d0e c9			ret 
0d0f			 
0d0f			addatode: 
0d0f 83			    add   a, e    ; A = A+L 
0d10 5f			    ld    e, a    ; L = A+L 
0d11 8a			    adc   a, d    ; A = A+L+H+carry 
0d12 93			    sub   e       ; A = H+carry 
0d13 57			    ld    d, a    ; H = H+carry 
0d14 c9			ret 
0d15			 
0d15			 
0d15			addatobc: 
0d15 81			    add   a, c    ; A = A+L 
0d16 4f			    ld    c, a    ; L = A+L 
0d17 88			    adc   a, b    ; A = A+L+H+carry 
0d18 91			    sub   c       ; A = H+carry 
0d19 47			    ld    b, a    ; H = H+carry 
0d1a c9			ret 
0d1b			 
0d1b			subafromhl: 
0d1b			   ; If A=0 do nothing 
0d1b			    ; Otherwise flip A's sign. Since 
0d1b			    ; the upper byte becomes -1, also 
0d1b			    ; substract 1 from H. 
0d1b ed 44		    neg 
0d1d ca 26 0d		    jp    z, Skip 
0d20 25			    dec   h 
0d21			     
0d21			    ; Now add the low byte as usual 
0d21			    ; Two's complement takes care of 
0d21			    ; ensuring the result is correct 
0d21 85			    add   a, l 
0d22 6f			    ld    l, a 
0d23 8c			    adc   a, h 
0d24 95			    sub   l 
0d25 67			    ld    h, a 
0d26			Skip: 
0d26 c9				ret 
0d27			 
0d27			 
0d27			; compare hl and de 
0d27			; returns:  
0d27			; if hl = de, z=1, s=0, c0=0 
0d27			; if hl > de, z=0, s=0, c=0 
0d27			; if hl < de, z=0, s=1, c=1 
0d27			cmp16:	 
0d27 b7				or a 
0d28 ed 52			sbc hl,de 
0d2a e0				ret po 
0d2b 7c				ld a,h 
0d2c 1f				rra 
0d2d ee 40			xor 01000000B 
0d2f 37				scf 
0d30 8f				adc a,a 
0d31 c9				ret 
0d32			 
0d32			 
0d32			; test if hl contains zero   - A is destroyed 
0d32			 
0d32			ishlzero:    
0d32 b7				or a     ; reset flags 
0d33 7c				ld a, h 
0d34 b5				or l        	 
0d35			 
0d35 c9				ret 
0d36			 
0d36			 
0d36			 
0d36			 
0d36			if FORTH_ENABLE_FLOATMATH 
0d36			;include "float/bbcmath.z80" 
0d36			include "float/lpfpcalc.asm" 
0d36			endif 
0d36			 
0d36			 
0d36			; eof 
0d36			 
# End of file firmware_maths.asm
0d36			include "firmware_strings.asm"   ; string handling  
0d36			 
0d36			 
0d36			; TODO string len 
0d36			; input text string, end on cr with zero term 
0d36			; a offset into frame buffer to start prompt 
0d36			; d is max length 
0d36			; e is display size TODO 
0d36			; c is current cursor position 
0d36			; hl is ptr to where string will be stored 
0d36			 
0d36			 
0d36			; TODO check limit of buffer for new inserts 
0d36			; TODO check insert does not push beyond buffer 
0d36			; TODO scroll in a limited display area 
0d36			; TODO scroll whole screen on page wrap 
0d36			 
0d36			 
0d36			; TODO handle KEY_PREVWORD 
0d36			; TODO handle KEY_NEXTWORD 
0d36			; TODO handle KEY_HOME 
0d36			; TODO handle KEY_END 
0d36			; TODO use LCD cursor? 
0d36			 
0d36 32 70 fb		input_str:    	ld (input_at_pos),a      ; save display position to start 
0d39 81					add c 
0d3a 32 6e fb				ld (input_at_cursor),a	; save draw pos of cursor 
0d3d 22 73 fb				ld (input_start), hl     ; save ptr to buffer 
0d40 79					ld a, c 
0d41 cd 09 0d				call addatohl 
0d44 22 75 fb				ld (input_ptr), hl     ; save ptr to point under the cursor 
0d47 7a					ld a,d 
0d48 32 72 fb			        ld (input_size), a       ; save length of input area 
0d4b 79					ld a, c 
0d4c 32 61 fb				ld (input_cursor),a      ; init cursor start position  
0d4f 7b					ld a,e 
0d50 32 71 fb			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0d53					 
0d53					 
0d53			 
0d53			;		ld a,(input_ptr) 
0d53			;		ld (input_under_cursor),a 	; save what is under the cursor 
0d53			 
0d53			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0d53					; init cursor shape if not set by the cin routines 
0d53 21 d0 f8				ld hl, cursor_shape 
0d56 3e ff				ld a, 255 
0d58 77					ld (hl), a 
0d59 23					inc hl 
0d5a 3e 00				ld a, 0 
0d5c 77					ld (hl), a 
0d5d			 
0d5d 3e 0f				ld a, CUR_BLINK_RATE 
0d5f 32 6c fb				ld (input_cur_flash), a 
0d62 3e 01				ld a, 1 
0d64 32 6b fb				ld (input_cur_onoff),a 
0d67			 
0d67			;	if DEBUG_INPUT 
0d67			;		push af 
0d67			;		ld a, 'I' 
0d67			;		ld (debug_mark),a 
0d67			;		pop af 
0d67			;		CALLMONITOR 
0d67			;	endif 
0d67			.is1:		; main entry loop 
0d67			 
0d67			 
0d67			 
0d67					; pause 1ms 
0d67			 
0d67 3e 01				ld a, 1 
0d69 cd 3a 0a				call aDelayInMS 
0d6c			 
0d6c					; dec flash counter 
0d6c 3a 6c fb				ld a, (input_cur_flash) 
0d6f 3d					dec a 
0d70 32 6c fb				ld (input_cur_flash), a 
0d73 fe 00				cp 0 
0d75 20 0d				jr nz, .nochgstate 
0d77			 
0d77			 
0d77					; change state 
0d77 3a 6b fb				ld a,(input_cur_onoff) 
0d7a ed 44				neg 
0d7c 32 6b fb				ld (input_cur_onoff),a 
0d7f			 
0d7f			 
0d7f					; reset on change of state 
0d7f 3e 0f				ld a, CUR_BLINK_RATE 
0d81 32 6c fb				ld (input_cur_flash), a 
0d84			 
0d84			.nochgstate: 
0d84					 
0d84					 
0d84			 
0d84					; display cursor  
0d84			 
0d84			;		ld hl, (input_start) 
0d84			;		ld a, (input_cursor) 
0d84			;		call addatohl 
0d84			 
0d84					; get char under cursor and replace with cursor 
0d84 2a 75 fb		ld hl, (input_ptr) 
0d87			;		ld a, (hl) 
0d87			;		ld (input_under_cursor),a 
0d87			;		ld a, '_' 
0d87			;		ld (hl), a 
0d87			 
0d87					; display string 
0d87			 
0d87 ed 5b 73 fb			ld de, (input_start) 
0d8b 3a 70 fb				ld a, (input_at_pos) 
0d8e cd e8 0a				call str_at_display 
0d91			;	        call update_display 
0d91			 
0d91					; find place to put the cursor 
0d91			;		add h 
0d91			;		ld l, display_row_1 
0d91			;		sub l 
0d91			; (input_at_pos) 
0d91					;ld c, a 
0d91			;		ld a, (input_cursor) 
0d91			;		ld l, (input_at_pos) 
0d91			;		;ld b, h 
0d91			;		add l 
0d91			;		ld (input_at_cursor),a 
0d91					;ld l,h 
0d91			 
0d91			;		ld h, 0 
0d91			;		ld l,(input_at_pos) 
0d91			;		ld a, (input_cursor) 
0d91			;		call addatohl 
0d91			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0d91			;		call subafromhl 
0d91			;		ld a,l 
0d91			;		ld (input_at_cursor), a 
0d91			 
0d91				if DEBUG_INPUT 
0d91					ld a, (hardware_diag) 
0d91					cp 0 
0d91					jr z, .skip_input_diag 
0d91			 
0d91					ld a,(input_at_pos) 
0d91					ld hl, LFSRSeed 
0d91					call hexout 
0d91					ld a, (input_cursor) 
0d91					ld hl, LFSRSeed+2 
0d91					call hexout 
0d91					ld a,(input_at_cursor) 
0d91					ld hl, LFSRSeed+4 
0d91					call hexout 
0d91			 
0d91					ld a,(input_cur_onoff) 
0d91					ld hl, LFSRSeed+6 
0d91					call hexout 
0d91			 
0d91					ld a,(input_cur_flash) 
0d91					ld hl, LFSRSeed+8 
0d91					call hexout 
0d91			 
0d91					ld a,(input_len) 
0d91					ld hl, LFSRSeed+10 
0d91					call hexout 
0d91					ld hl, LFSRSeed+12 
0d91					ld a, 0 
0d91					ld (hl),a 
0d91					ld a, display_row_4 
0d91					ld de, LFSRSeed 
0d91					call str_at_display 
0d91					.skip_input_diag: 
0d91				endif 
0d91			 
0d91					; decide on if we are showing the cursor this time round 
0d91			 
0d91 3a 6b fb				ld a, (input_cur_onoff) 
0d94 fe ff				cp 255 
0d96 28 13				jr z, .skipcur 
0d98			 
0d98			 
0d98 3a 6e fb				ld a,(input_at_cursor) 
0d9b 11 d0 f8				ld de, cursor_shape 
0d9e cd e8 0a				call str_at_display 
0da1			 
0da1					; save length of current input string 
0da1 2a 73 fb				ld hl, (input_start) 
0da4 cd 67 11				call strlenz 
0da7 7d					ld a,l 
0da8 32 66 fb				ld (input_len),a 
0dab			 
0dab			.skipcur: 
0dab			 
0dab cd f8 0a			        call update_display 
0dae					 
0dae			 
0dae			 
0dae					; wait 
0dae				 
0dae					; TODO loop without wait to flash the cursor and char under cursor	 
0dae cd c6 68				call cin    ; _wait 
0db1			 
0db1 fe 00				cp 0 
0db3 ca 67 0d				jp z, .is1 
0db6			 
0db6					; get ptr to char to input into 
0db6			 
0db6 4f					ld c,a 
0db7 2a 73 fb				ld hl, (input_start) 
0dba 3a 61 fb				ld a, (input_cursor) 
0dbd cd 09 0d				call addatohl 
0dc0 22 75 fb				ld (input_ptr), hl 
0dc3 79					ld a,c 
0dc4			 
0dc4					; replace char under cursor 
0dc4			 
0dc4			;		ld hl, (input_ptr) 
0dc4			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0dc4			;		ld (hl), a 
0dc4			 
0dc4			;	if DEBUG_INPUT 
0dc4			;		push af 
0dc4			;		ld a, 'i' 
0dc4			;		ld (debug_mark),a 
0dc4			;		pop af 
0dc4			;		CALLMONITOR 
0dc4			;	endif 
0dc4 fe 0e				cp KEY_HOME 
0dc6 20 0e				jr nz, .iske 
0dc8			 
0dc8 3a 70 fb				ld a, (input_at_pos) 
0dcb 32 6e fb				ld (input_at_cursor),a 
0dce 3e 00				ld a, 0 
0dd0 32 61 fb				ld (input_cursor), a 
0dd3 c3 67 0d				jp .is1 
0dd6					 
0dd6 fe 0f		.iske:		cp KEY_END 
0dd8 20 03				jr nz, .isknw 
0dda c3 67 0d				jp .is1 
0ddd			 
0ddd fe 06		.isknw:		cp KEY_NEXTWORD 
0ddf 20 1b				jr nz, .iskpw 
0de1			 
0de1 2a 75 fb		.isknwm:	ld hl, (input_ptr) 
0de4 7e					ld a,(hl)	 
0de5 fe 00				cp 0 
0de7 ca 67 0d				jp z, .is1    ; end of string 
0dea fe 20				cp ' ' 
0dec ca 67 0d				jp z, .is1    ; end of word 
0def 23					inc hl 
0df0 22 75 fb				ld (input_ptr), hl 
0df3 3a 6e fb				ld a, (input_at_cursor) 
0df6 3c					inc a 
0df7 32 6e fb				ld (input_at_cursor), a 
0dfa 18 e5				jr .isknwm 
0dfc			 
0dfc fe 07		.iskpw:		cp KEY_PREVWORD 
0dfe 20 1b				jr nz, .iskl 
0e00			.iskpwm:	 
0e00 2a 75 fb				ld hl, (input_ptr) 
0e03 7e					ld a,(hl)	 
0e04 fe 00				cp 0  
0e06 ca 67 0d				jp z, .is1    ; end of string 
0e09 fe 20				cp ' ' 
0e0b ca 67 0d				jp z, .is1    ; end of word 
0e0e 2b					dec hl 
0e0f 22 75 fb				ld (input_ptr), hl 
0e12 3a 6e fb				ld a, (input_at_cursor) 
0e15 3d					dec a 
0e16 32 6e fb				ld (input_at_cursor), a 
0e19 18 e5				jr .iskpwm 
0e1b			 
0e1b			 
0e1b fe 0b		.iskl:		cp KEY_LEFT 
0e1d 20 27				jr nz, .isk1 
0e1f			 
0e1f 3a 61 fb				ld a, (input_cursor) 
0e22			 
0e22 fe 00				cp 0 
0e24 ca 67 0d				jp z, .is1 		; at start of line to ignore  
0e27			 
0e27 3d					dec  a 		; TODO check underflow 
0e28 32 61 fb				ld (input_cursor), a 
0e2b			 
0e2b 2a 75 fb				ld hl, (input_ptr) 
0e2e 2b					dec hl 
0e2f 22 75 fb				ld (input_ptr), hl 
0e32					 
0e32 3a 6e fb				ld a, (input_at_cursor) 
0e35 3d					dec a 
0e36 32 6e fb				ld (input_at_cursor), a 
0e39			 
0e39 3e 01				ld a, 1		; show cursor moving 
0e3b 32 6b fb				ld (input_cur_onoff),a 
0e3e 3e 0f				ld a, CUR_BLINK_RATE 
0e40 32 6c fb				ld (input_cur_flash), a 
0e43			 
0e43 c3 67 0d				jp .is1 
0e46			 
0e46 fe 0c		.isk1:		cp KEY_RIGHT 
0e48 20 2a				jr nz, .isk2 
0e4a			 
0e4a 3a 66 fb				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0e4d 5f					ld e,a 
0e4e 3a 61 fb				ld a, (input_cursor) 
0e51 bb					cp e 
0e52 ca 67 0d				jp z, .is1		; at the end of string so dont go right 
0e55			 
0e55 3c					inc  a 		; TODO check overflow 
0e56 32 61 fb				ld (input_cursor), a 
0e59			 
0e59 3a 6e fb				ld a, (input_at_cursor) 
0e5c 3c					inc a 
0e5d 32 6e fb				ld (input_at_cursor), a 
0e60			 
0e60 2a 75 fb				ld hl, (input_ptr) 
0e63 23					inc hl 
0e64 22 75 fb				ld (input_ptr), hl 
0e67			 
0e67 3e 01				ld a, 1		; show cursor moving 
0e69 32 6b fb				ld (input_cur_onoff),a 
0e6c 3e 0f				ld a, CUR_BLINK_RATE 
0e6e 32 6c fb				ld (input_cur_flash), a 
0e71			 
0e71 c3 67 0d				jp .is1 
0e74			 
0e74 fe 05		.isk2:		cp KEY_UP 
0e76			 
0e76 20 26				jr nz, .isk3 
0e78			 
0e78					; swap last command with the current on 
0e78			 
0e78					; move cursor to start of string 
0e78 2a 73 fb				ld hl, (input_start) 
0e7b 22 75 fb				ld (input_ptr), hl 
0e7e			 
0e7e 3a 70 fb				ld a, (input_at_pos) 
0e81 32 6e fb				ld (input_at_cursor), a 
0e84			 
0e84 3e 00				ld a, 0 
0e86 32 61 fb				ld (input_cursor), a 
0e89					 
0e89					; swap input and last command buffers 
0e89			 
0e89 21 44 f1				ld hl, os_cli_cmd 
0e8c 11 43 f2				ld de, os_last_cmd 
0e8f 06 ff				ld b, 255 
0e91 7e			.swap1:		ld a, (hl) 
0e92 4f					ld c,a 
0e93 1a					ld a, (de) 
0e94 77					ld (hl), a 
0e95 79					ld a,c 
0e96 12					ld (de),a 
0e97 23					inc hl 
0e98 13					inc de 
0e99 10 f6				djnz .swap1 
0e9b			 
0e9b			 
0e9b			 
0e9b			 
0e9b			 
0e9b c3 67 0d				jp .is1 
0e9e			 
0e9e fe 08		.isk3:		cp KEY_BS 
0ea0 20 3c				jr nz, .isk4 
0ea2			 
0ea2 3a 61 fb				ld a, (input_cursor) 
0ea5			 
0ea5 fe 00				cp 0 
0ea7 ca 67 0d				jp z, .is1 		; at start of line to ignore  
0eaa			 
0eaa 3d					dec  a 		; TODO check underflow 
0eab 32 61 fb				ld (input_cursor), a 
0eae			 
0eae					; hl is source 
0eae					; de needs to be source - 1 
0eae			 
0eae			;		ld a, 0 
0eae			;		dec hl 
0eae			;		ld (hl), a 
0eae			 
0eae 2a 75 fb				ld hl, (input_ptr) 
0eb1 2b					dec hl 
0eb2 22 75 fb				ld (input_ptr), hl 
0eb5			 
0eb5					; shift all data 
0eb5			 
0eb5 e5					push hl 
0eb6 23					inc hl 
0eb7 d1					pop de 
0eb8 3a 66 fb				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0ebb 4f					ld c,a 
0ebc 06 00				ld b,0 
0ebe ed b0				ldir  
0ec0			 
0ec0			 
0ec0			 
0ec0			 
0ec0 3a 6e fb				ld a, (input_at_cursor) 
0ec3 3d					dec a 
0ec4 32 6e fb				ld (input_at_cursor), a 
0ec7			 
0ec7			 
0ec7 3e 01				ld a, 1		; show cursor moving 
0ec9 32 6b fb				ld (input_cur_onoff),a 
0ecc 3e 0f				ld a, CUR_BLINK_RATE 
0ece 32 6c fb				ld (input_cur_flash), a 
0ed1			 
0ed1					; remove char 
0ed1 3a 6e fb				ld a, (input_at_cursor) 
0ed4 3c					inc a 
0ed5 11 5f 0f				ld de,.iblank 
0ed8 cd e8 0a				call str_at_display 
0edb			 
0edb c3 67 0d				jp .is1 
0ede			 
0ede fe 0d		.isk4:		cp KEY_CR 
0ee0 28 6c				jr z, .endinput 
0ee2			 
0ee2					; else add the key press to the end 
0ee2			 
0ee2 4f					ld c, a			; save key pressed 
0ee3			 
0ee3 7e					ld a,(hl)		; get what is currently under char 
0ee4			 
0ee4 fe 00				cp 0			; we are at the end of the string 
0ee6 20 2f				jr nz, .onchar 
0ee8					 
0ee8					; add a char to the end of the string 
0ee8				 
0ee8 71					ld (hl),c 
0ee9 23					inc hl 
0eea			;		ld a,' ' 
0eea			;		ld (hl),a 
0eea			;		inc hl 
0eea 3e 00				ld a,0 
0eec 77					ld (hl),a 
0eed 2b					dec hl 
0eee			 
0eee 3a 61 fb				ld a, (input_cursor) 
0ef1 3c					inc a				; TODO check max string length and scroll  
0ef2 32 61 fb				ld (input_cursor), a		; inc cursor pos 
0ef5							 
0ef5 3a 6e fb				ld a, (input_at_cursor) 
0ef8 3c					inc a 
0ef9 32 6e fb				ld (input_at_cursor), a 
0efc			 
0efc 2a 75 fb				ld hl, (input_ptr) 
0eff 23					inc hl 
0f00 22 75 fb				ld (input_ptr), hl 
0f03			 
0f03 2a 75 fb				ld hl, (input_ptr) 
0f06 23					inc hl 
0f07 22 75 fb				ld (input_ptr), hl 
0f0a			;	if DEBUG_INPUT 
0f0a			;		push af 
0f0a			;		ld a, '+' 
0f0a			;		ld (debug_mark),a 
0f0a			;		pop af 
0f0a			;		CALLMONITOR 
0f0a			;	endif 
0f0a 3e 01				ld a, 1		; show cursor moving 
0f0c 32 6b fb				ld (input_cur_onoff),a 
0f0f 3e 0f				ld a, CUR_BLINK_RATE 
0f11 32 6c fb				ld (input_cur_flash), a 
0f14 c3 67 0d				jp .is1 
0f17					 
0f17			 
0f17			 
0f17					; if on a char then insert 
0f17			.onchar: 
0f17			 
0f17					; TODO over flow check: make sure insert does not blow out buffer 
0f17			 
0f17					; need to do some maths to use lddr 
0f17			 
0f17 e5					push hl   ; save char pos 
0f18 c5					push bc 
0f19			 
0f19 2a 73 fb				ld hl, (input_start) 
0f1c 3a 66 fb				ld a, (input_len) 
0f1f cd 09 0d				call addatohl  		; end of string 
0f22 23					inc hl 
0f23 23					inc hl		; past zero term 
0f24 e5					push hl 
0f25 23					inc hl 
0f26 e5					push hl  
0f27			 
0f27								; start and end of lddr set, now how much to move? 
0f27			 
0f27							 
0f27 3a 61 fb				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0f2a 47					ld b,a 
0f2b 3a 66 fb				ld a,(input_len) 
0f2e 5f					ld e,a 
0f2f 90					sub b 
0f30 3c					inc a		;?? 
0f31 3c					inc a		;?? 
0f32 3c					inc a		;?? 
0f33			 
0f33 06 00				ld b,0 
0f35 4f					ld c,a 
0f36			 
0f36				if DEBUG_INPUT 
0f36					push af 
0f36					ld a, 'i' 
0f36					ld (debug_mark),a 
0f36					pop af 
0f36			;		CALLMONITOR 
0f36				endif 
0f36 d1					pop de 
0f37 e1					pop hl 
0f38				if DEBUG_INPUT 
0f38					push af 
0f38					ld a, 'I' 
0f38					ld (debug_mark),a 
0f38					pop af 
0f38			;		CALLMONITOR 
0f38				endif 
0f38 ed b8				lddr 
0f3a				 
0f3a			 
0f3a			 
0f3a					; TODO have a key for insert/overwrite mode???? 
0f3a c1					pop bc 
0f3b e1					pop hl 
0f3c 71					ld (hl), c		; otherwise overwrite current char 
0f3d					 
0f3d			 
0f3d			 
0f3d			 
0f3d 3a 61 fb				ld a, (input_cursor) 
0f40 3c					inc  a 		; TODO check overflow 
0f41 32 61 fb				ld (input_cursor), a 
0f44			 
0f44 3a 6e fb				ld a, (input_at_cursor) 
0f47 3c					inc a 
0f48 32 6e fb				ld (input_at_cursor), a 
0f4b			 
0f4b c3 67 0d				jp .is1 
0f4e			 
0f4e			.endinput:	; TODO look for end of string 
0f4e			 
0f4e					; add trailing space for end of token 
0f4e			 
0f4e 2a 73 fb				ld hl, (input_start) 
0f51 3a 66 fb				ld a,(input_len) 
0f54 cd 09 0d				call addatohl 
0f57 3e 20				ld a, ' ' 
0f59 77					ld (hl),a 
0f5a					; TODO eof of parse marker 
0f5a			 
0f5a 23					inc hl 
0f5b 3e 00				ld a, 0 
0f5d 77					ld (hl),a 
0f5e			 
0f5e			 
0f5e c9					ret 
0f5f			 
0f5f .. 00		.iblank: db " ",0 
0f61			 
0f61			 
0f61 32 70 fb		input_str_prev:	ld (input_at_pos), a 
0f64 22 73 fb				ld (input_start), hl 
0f67 3e 01				ld a,1			; add cursor 
0f69 77					ld (hl),a 
0f6a 23					inc hl 
0f6b 3e 00				ld a,0 
0f6d 77					ld (hl),a 
0f6e 22 75 fb				ld (input_ptr), hl 
0f71 7a					ld a,d 
0f72 32 72 fb				ld (input_size), a 
0f75 3e 00				ld a,0 
0f77 32 61 fb				ld (input_cursor),a 
0f7a			.instr1:	 
0f7a			 
0f7a					; TODO do block cursor 
0f7a					; TODO switch cursor depending on the modifer key 
0f7a			 
0f7a					; update cursor shape change on key hold 
0f7a			 
0f7a 2a 75 fb				ld hl, (input_ptr) 
0f7d 2b					dec hl 
0f7e 3a d0 f8				ld a,(cursor_shape) 
0f81 77					ld (hl), a 
0f82			 
0f82					; display entered text 
0f82 3a 70 fb				ld a,(input_at_pos) 
0f85 cd 8a 66		            	CALL fLCD_Pos       ;Position cursor to location in A 
0f88 ed 5b 73 fb	            	LD   de, (input_start) 
0f8c cd ac 66		            	CALL fLCD_Str       ;Display string pointed to by DE 
0f8f			 
0f8f cd c6 68				call cin 
0f92 fe 00				cp 0 
0f94 28 e4				jr z, .instr1 
0f96			 
0f96					; proecess keyboard controls first 
0f96			 
0f96 2a 75 fb				ld hl,(input_ptr) 
0f99			 
0f99 fe 0d				cp KEY_CR	 ; pressing enter ends input 
0f9b 28 5a				jr z, .instrcr 
0f9d			 
0f9d fe 08				cp KEY_BS 	; back space 
0f9f 20 0f				jr nz, .instr2 
0fa1					; process back space 
0fa1			 
0fa1					; TODO stop back space if at start of string 
0fa1 2b					dec hl 
0fa2 2b					dec hl ; to over write cursor 
0fa3 3a d0 f8				ld a,(cursor_shape) 
0fa6					;ld a,0 
0fa6 77					ld (hl),a 
0fa7 23					inc hl 
0fa8 3e 20				ld a," " 
0faa 77					ld (hl),a 
0fab 22 75 fb				ld (input_ptr),hl 
0fae					 
0fae			 
0fae 18 ca				jr .instr1 
0fb0			 
0fb0 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
0fb2 20 06				jr nz, .instr3 
0fb4 2b					dec hl 
0fb5 22 75 fb				ld (input_ptr),hl 
0fb8 18 c0				jr .instr1 
0fba				 
0fba fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
0fbc 20 06				jr nz, .instr4 
0fbe 23					inc hl 
0fbf 22 75 fb				ld (input_ptr),hl 
0fc2 18 b6				jr .instr1 
0fc4			 
0fc4 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
0fc6 20 06				jr nz, .instr5 
0fc8 2b					dec hl 
0fc9 22 75 fb				ld (input_ptr),hl 
0fcc 18 ac				jr .instr1 
0fce			 
0fce fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
0fd0 20 06				jr nz, .instr6 
0fd2 2b					dec hl 
0fd3 22 75 fb				ld (input_ptr),hl 
0fd6 18 a2				jr .instr1 
0fd8 fe 05		.instr6:        cp KEY_UP      ; recall last command 
0fda 20 0b				jr nz, .instrnew 
0fdc			 
0fdc 21 1d ee			ld hl, scratch 
0fdf 11 43 f2			ld de, os_last_cmd 
0fe2 cd 00 10			call strcpy 
0fe5 18 93				jr .instr1 
0fe7			 
0fe7			 
0fe7			.instrnew:	; no special key pressed to see if we have room to store it 
0fe7			 
0fe7					; TODO do string size test 
0fe7			 
0fe7 2b					dec hl ; to over write cursor 
0fe8 77					ld (hl),a 
0fe9 23					inc hl 
0fea 3a d0 f8				ld a,(cursor_shape) 
0fed 77					ld (hl),a 
0fee 23					inc hl 
0fef 3e 00				ld a,0 
0ff1 77					ld (hl),a 
0ff2			 
0ff2 22 75 fb				ld (input_ptr),hl 
0ff5					 
0ff5 18 83				jr .instr1 
0ff7 2b			.instrcr:	dec hl		; remove cursor 
0ff8 3e 20				ld a,' '	; TODO add a trailing space for safety 
0ffa 77					ld (hl),a 
0ffb 23					inc hl 
0ffc 3e 00				ld a,0 
0ffe 77					ld (hl),a 
0fff			 
0fff			 
0fff					; if at end of line scroll up    
0fff					; TODO detecting only end of line 4 for scroll up  
0fff			 
0fff					;ld   
0fff			 
0fff c9					ret 
1000			 
1000			 
1000			; strcpy hl = dest, de source 
1000			 
1000 1a			strcpy:   LD   A, (DE)        ;Get character from string 
1001 b7			            OR   A              ;Null terminator? 
1002 c8			            RET  Z              ;Yes, so finished 
1003 1a					ld a,(de) 
1004 77					ld (hl),a 
1005 13			            INC  DE             ;Point to next character 
1006 23					inc hl 
1007 18 f7		            JR   strcpy       ;Repeat 
1009 c9					ret 
100a			 
100a			 
100a			; TODO string_at  
100a			; pass string which starts with lcd offset address and then null term string 
100a			 
100a			; TODO string to dec 
100a			; TODO string to hex 
100a			; TODO byte to string hex 
100a			; TODO byte to string dec 
100a			 
100a			 
100a			 
100a			; from z80uartmonitor 
100a			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
100a			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
100a			; pass hl for where to put the text 
100a			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
100a c5			hexout:	PUSH BC 
100b f5					PUSH AF 
100c 47					LD B, A 
100d					; Upper nybble 
100d cb 3f				SRL A 
100f cb 3f				SRL A 
1011 cb 3f				SRL A 
1013 cb 3f				SRL A 
1015 cd 25 10				CALL tohex 
1018 77					ld (hl),a 
1019 23					inc hl	 
101a					 
101a					; Lower nybble 
101a 78					LD A, B 
101b e6 0f				AND 0FH 
101d cd 25 10				CALL tohex 
1020 77					ld (hl),a 
1021 23					inc hl	 
1022					 
1022 f1					POP AF 
1023 c1					POP BC 
1024 c9					RET 
1025					 
1025			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1025			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
1025			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1025			tohex: 
1025 e5					PUSH HL 
1026 d5					PUSH DE 
1027 16 00				LD D, 0 
1029 5f					LD E, A 
102a 21 32 10				LD HL, .DATA 
102d 19					ADD HL, DE 
102e 7e					LD A, (HL) 
102f d1					POP DE 
1030 e1					POP HL 
1031 c9					RET 
1032			 
1032			.DATA: 
1032 30					DEFB	30h	; 0 
1033 31					DEFB	31h	; 1 
1034 32					DEFB	32h	; 2 
1035 33					DEFB	33h	; 3 
1036 34					DEFB	34h	; 4 
1037 35					DEFB	35h	; 5 
1038 36					DEFB	36h	; 6 
1039 37					DEFB	37h	; 7 
103a 38					DEFB	38h	; 8 
103b 39					DEFB	39h	; 9 
103c 41					DEFB	41h	; A 
103d 42					DEFB	42h	; B 
103e 43					DEFB	43h	; C 
103f 44					DEFB	44h	; D 
1040 45					DEFB	45h	; E 
1041 46					DEFB	46h	; F 
1042			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1042			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1042			;;    subtract $30, if result > 9 then subtract $7 more 
1042			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1042			atohex: 
1042 d6 30				SUB $30 
1044 fe 0a				CP 10 
1046 f8					RET M		; If result negative it was 0-9 so we're done 
1047 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
1049 c9					RET		 
104a			 
104a			 
104a			 
104a			 
104a			; Get 2 ASCII characters as hex byte from pointer in hl 
104a			 
104a			BYTERD: 
104a 16 00			LD	D,00h		;Set up 
104c cd 54 10			CALL	HEXCON		;Get byte and convert to hex 
104f 87				ADD	A,A		;First nibble so 
1050 87				ADD	A,A		;multiply by 16 
1051 87				ADD	A,A		; 
1052 87				ADD	A,A		; 
1053 57				LD	D,A		;Save hi nibble in D 
1054			HEXCON: 
1054 7e				ld a, (hl)		;Get next chr 
1055 23				inc hl 
1056 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
1058 fe 0a			CP	00Ah		;Is it 0-9 ? 
105a 38 02			JR	C,NALPHA	;If so miss next bit 
105c d6 07			SUB	007h		;Else convert alpha 
105e			NALPHA: 
105e b2				OR	D		;Add hi nibble back 
105f c9				RET			; 
1060			 
1060			 
1060			; 
1060			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
1060			; Since the routines get_byte and therefore get_nibble are called, only valid 
1060			; characters (0-9a-f) are accepted. 
1060			; 
1060			;get_word        push    af 
1060			;                call    get_byte        ; Get the upper byte 
1060			;                ld      h, a 
1060			;                call    get_byte        ; Get the lower byte 
1060			;                ld      l, a 
1060			;                pop     af 
1060			;                ret 
1060			; 
1060			; Get a byte in hexadecimal notation. The result is returned in A. Since 
1060			; the routine get_nibble is used only valid characters are accepted - the  
1060			; input routine only accepts characters 0-9a-f. 
1060			; 
1060 c5			get_byte:        push    bc              ; Save contents of B (and C) 
1061 7e					ld a,(hl) 
1062 23					inc hl 
1063 cd 88 10		                call    nibble2val      ; Get upper nibble 
1066 cb 07		                rlc     a 
1068 cb 07		                rlc     a 
106a cb 07		                rlc     a 
106c cb 07		                rlc     a 
106e 47			                ld      b, a            ; Save upper four bits 
106f 7e					ld a,(hl) 
1070 cd 88 10		                call    nibble2val      ; Get lower nibble 
1073 b0			                or      b               ; Combine both nibbles 
1074 c1			                pop     bc              ; Restore B (and C) 
1075 c9			                ret 
1076			; 
1076			; Get a hexadecimal digit from the serial line. This routine blocks until 
1076			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
1076			; to the serial line interface. The lower 4 bits of A contain the value of  
1076			; that particular digit. 
1076			; 
1076			;get_nibble      ld a,(hl)           ; Read a character 
1076			;                call    to_upper        ; Convert to upper case 
1076			;                call    is_hex          ; Was it a hex digit? 
1076			;                jr      nc, get_nibble  ; No, get another character 
1076			 ;               call    nibble2val      ; Convert nibble to value 
1076			 ;               call    print_nibble 
1076			 ;               ret 
1076			; 
1076			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
1076			; A valid hexadecimal digit is denoted by a set C flag. 
1076			; 
1076			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
1076			;                ret     nc              ; Yes 
1076			;                cp      '0'             ; Less than '0'? 
1076			;                jr      nc, is_hex_1    ; No, continue 
1076			;                ccf                     ; Complement carry (i.e. clear it) 
1076			;                ret 
1076			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
1076			;                ret     c               ; Yes 
1076			;                cp      'A'             ; Less than 'A'? 
1076			;                jr      nc, is_hex_2    ; No, continue 
1076			;                ccf                     ; Yes - clear carry and return 
1076			;                ret 
1076			;is_hex_2        scf                     ; Set carry 
1076			;                ret 
1076			; 
1076			; Convert a single character contained in A to upper case: 
1076			; 
1076 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
1078 d8			                ret     c 
1079 fe 7b		                cp      'z' + 1         ; > 'z'? 
107b d0			                ret     nc              ; Nothing to do, either 
107c e6 5f		                and     $5f             ; Convert to upper case 
107e c9			                ret 
107f			 
107f			 
107f			to_lower: 
107f			 
107f			   ; if char is in [A-Z] make it lower case 
107f			 
107f			   ; enter : a = char 
107f			   ; exit  : a = lower case char 
107f			   ; uses  : af 
107f			 
107f fe 41		   cp 'A' 
1081 d8			   ret c 
1082			    
1082 fe 5b		   cp 'Z'+1 
1084 d0			   ret nc 
1085			    
1085 f6 20		   or $20 
1087 c9			   ret 
1088			 
1088			; 
1088			; Expects a hexadecimal digit (upper case!) in A and returns the 
1088			; corresponding value in A. 
1088			; 
1088 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
108a 38 02		                jr      c, nibble2val_1 ; Yes 
108c d6 07		                sub     7               ; Adjust for A-F 
108e d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
1090 e6 0f		                and     $f              ; Only return lower 4 bits 
1092 c9			                ret 
1093			; 
1093			; Print_nibble prints a single hex nibble which is contained in the lower  
1093			; four bits of A: 
1093			; 
1093			;print_nibble    push    af              ; We won't destroy the contents of A 
1093			;                and     $f              ; Just in case... 
1093			;                add     a, '0'             ; If we have a digit we are done here. 
1093			;                cp      '9' + 1         ; Is the result > 9? 
1093			;                jr      c, print_nibble_1 
1093			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1093			;print_nibble_1  call    putc            ; Print the nibble and 
1093			;                pop     af              ; restore the original value of A 
1093			;                ret 
1093			;; 
1093			;; Send a CR/LF pair: 
1093			; 
1093			;crlf            push    af 
1093			;                ld      a, cr 
1093			;                call    putc 
1093			;                ld      a, lf 
1093			;                call    putc 
1093			;                pop     af 
1093			;                ret 
1093			; 
1093			; Print_word prints the four hex digits of a word to the serial line. The  
1093			; word is expected to be in HL. 
1093			; 
1093			;print_word      push    hl 
1093			;                push    af 
1093			;                ld      a, h 
1093			;                call    print_byte 
1093			;                ld      a, l 
1093			;                call    print_byte 
1093			;                pop     af 
1093			;                pop     hl 
1093			;                ret 
1093			; 
1093			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1093			; The byte to be printed is expected to be in A. 
1093			; 
1093			;print_byte      push    af              ; Save the contents of the registers 
1093			;                push    bc 
1093			;                ld      b, a 
1093			;                rrca 
1093			;                rrca 
1093			;                rrca 
1093			;                rrca 
1093			;                call    print_nibble    ; Print high nibble 
1093			;                ld      a, b 
1093			;                call    print_nibble    ; Print low nibble 
1093			;                pop     bc              ; Restore original register contents 
1093			;                pop     af 
1093			;                ret 
1093			 
1093			 
1093			 
1093			 
1093			 
1093			fourehexhl:  
1093 7e				ld a,(hl) 
1094 cd 42 10			call atohex 
1097 cb 3f				SRL A 
1099 cb 3f				SRL A 
109b cb 3f				SRL A 
109d cb 3f				SRL A 
109f 47				ld b, a 
10a0 23				inc hl 
10a1 7e				ld a,(hl) 
10a2 23				inc hl 
10a3 cd 42 10			call atohex 
10a6 80				add b 
10a7 57				ld d,a 
10a8 7e				ld a,(hl) 
10a9 cd 42 10			call atohex 
10ac cb 3f				SRL A 
10ae cb 3f				SRL A 
10b0 cb 3f				SRL A 
10b2 cb 3f				SRL A 
10b4 47				ld b, a 
10b5 23				inc hl 
10b6 7e				ld a,(hl) 
10b7 23				inc hl 
10b8 cd 42 10			call atohex 
10bb 80				add b 
10bc 5f				ld e, a 
10bd d5				push de 
10be e1				pop hl 
10bf c9				ret 
10c0			 
10c0			; pass hl. returns z set if the byte at hl is a digit 
10c0			;isdigithl:  
10c0			;	push bc 
10c0			;	ld a,(hl) 
10c0			;	cp ':' 
10c0			;	jr nc, .isdf 		; > 
10c0			;	cp '0' 
10c0			;	jr c, .isdf		; < 
10c0			; 
10c0			;	; TODO find a better way to set z 
10c0			; 
10c0			;	ld b,a 
10c0			;	cp b 
10c0			;	pop bc 
10c0			;	ret 
10c0			; 
10c0			;.isdf:	; not digit so clear z 
10c0			; 
10c0			;	; TODO find a better way to unset z 
10c0			; 
10c0			;	ld b,a 
10c0			;	inc b 
10c0			;	cp b 
10c0			; 
10c0			;	pop bc 
10c0			;	ret 
10c0				 
10c0				 
10c0			 
10c0			 
10c0			; pass hl as the four byte address to load 
10c0			 
10c0			get_word_hl:  
10c0 e5				push hl 
10c1 cd 60 10			call get_byte 
10c4				 
10c4 47				ld b, a 
10c5			 
10c5 e1				pop hl 
10c6 23				inc hl 
10c7 23				inc hl 
10c8			 
10c8			; TODO not able to handle a-f  
10c8 7e				ld a,(hl) 
10c9			;	;cp ':' 
10c9			;	cp 'g' 
10c9			;	jr nc, .single_byte_hl 		; > 
10c9			;	cp 'G' 
10c9			;	jr nc, .single_byte_hl 		; > 
10c9			;	cp '0' 
10c9			;	jr c, .single_byte_hl		; < 
10c9			 
10c9				;call isdigithl 
10c9 fe 00			cp 0 
10cb 28 06			jr z, .single_byte_hl 
10cd			 
10cd			.getwhln:   ; hex word so get next byte 
10cd			 
10cd cd 60 10			call get_byte 
10d0 6f				ld l, a 
10d1 60				ld h,b 
10d2 c9				ret 
10d3 68			.single_byte_hl:   ld l,b 
10d4 26 00				ld h,0 
10d6 c9					ret 
10d7			 
10d7			 
10d7			 
10d7			 
10d7 21 f4 19			ld hl,asc+1 
10da			;	ld a, (hl) 
10da			;	call nibble2val 
10da cd 60 10			call get_byte 
10dd			 
10dd			;	call fourehexhl 
10dd 32 51 ee			ld (scratch+52),a 
10e0				 
10e0 21 4f ee			ld hl,scratch+50 
10e3 22 40 f1			ld (os_cur_ptr),hl 
10e6			 
10e6 c9				ret 
10e7			 
10e7			 
10e7			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
10e7			 
10e7			; Decimal Unsigned Version 
10e7			 
10e7			;Number in a to decimal ASCII 
10e7			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
10e7			;Example: display a=56 as "056" 
10e7			;input: a = number 
10e7			;Output: a=0,value of a in the screen 
10e7			;destroys af,bc (don't know about hl and de) 
10e7			DispAToASCII: 
10e7 0e 9c			ld	c,-100 
10e9 cd f3 10			call	.Na1 
10ec 0e f6			ld	c,-10 
10ee cd f3 10			call	.Na1 
10f1 0e ff			ld	c,-1 
10f3 06 2f		.Na1:	ld	b,'0'-1 
10f5 04			.Na2:	inc	b 
10f6 81				add	a,c 
10f7 38 fc			jr	c,.Na2 
10f9 91				sub	c		;works as add 100/10/1 
10fa f5				push af		;safer than ld c,a 
10fb 78				ld	a,b		;char is in b 
10fc			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
10fc f1				pop af		;safer than ld a,c 
10fd c9				ret 
10fe			 
10fe			; Decimal Signed Version 
10fe			 
10fe			; DispA 
10fe			; -------------------------------------------------------------- 
10fe			; Converts a signed integer value to a zero-terminated ASCII 
10fe			; string representative of that value (using radix 10). 
10fe			; -------------------------------------------------------------- 
10fe			; INPUTS: 
10fe			;     HL     Value to convert (two's complement integer). 
10fe			;     DE     Base address of string destination. (pointer). 
10fe			; -------------------------------------------------------------- 
10fe			; OUTPUTS: 
10fe			;     None 
10fe			; -------------------------------------------------------------- 
10fe			; REGISTERS/MEMORY DESTROYED 
10fe			; AF HL 
10fe			; -------------------------------------------------------------- 
10fe			 
10fe			;DispHLToASCII: 
10fe			;   push    de 
10fe			;   push    bc 
10fe			; 
10fe			;; Detect sign of HL. 
10fe			;    bit    7, h 
10fe			;    jr     z, ._DoConvert 
10fe			; 
10fe			;; HL is negative. Output '-' to string and negate HL. 
10fe			;    ld     a, '-' 
10fe			;    ld     (de), a 
10fe			;    inc    de 
10fe			; 
10fe			;; Negate HL (using two's complement) 
10fe			;    xor    a 
10fe			;    sub    l 
10fe			;    ld     l, a 
10fe			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
10fe			;    sbc    a, h 
10fe			;    ld     h, a 
10fe			; 
10fe			;; Convert HL to digit characters 
10fe			;._DoConvert: 
10fe			;    ld     b, 0     ; B will count character length of number 
10fe			;-   ld     a, 10 
10fe			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
10fe			;    push   af 
10fe			;    inc    b 
10fe			;    ld     a, h 
10fe			;    or     l 
10fe			;    jr     nz, - 
10fe			; 
10fe			;; Retrieve digits from stack 
10fe			;-   pop    af 
10fe			;    or     $30 
10fe			;    ld     (de), a 
10fe			;    inc    de 
10fe			;    djnz   - 
10fe			; 
10fe			;; Terminate string with NULL 
10fe			;    xor    a 
10fe			;    ld     (de), a 
10fe			; 
10fe			;    pop    bc 
10fe			;    pop    de 
10fe			;    ret 
10fe			 
10fe			;Comments 
10fe			; 
10fe			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
10fe			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
10fe			;    Note that the output string will not be fixed-width. 
10fe			; 
10fe			;Example Usage 
10fe			; 
10fe			;    ld    hl, -1004 
10fe			;    ld    de, OP1 
10fe			;    call  DispA 
10fe			;    ld    hl, OP1 
10fe			;    syscall  PutS 
10fe			 
10fe			 
10fe			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
10fe			 
10fe			 
10fe			;Converts an ASCII string to an unsigned 16-bit integer 
10fe			;Quits when it reaches a non-decimal digit 
10fe			 
10fe			string_to_uint16: 
10fe			atoui_16: 
10fe			;Input: 
10fe			;     DE points to the string 
10fe			;Outputs: 
10fe			;     HL is the result 
10fe			;     A is the 8-bit value of the number 
10fe			;     DE points to the byte after the number 
10fe			;Destroys: 
10fe			;     BC 
10fe			;       if the string is non-empty, BC is HL/10 
10fe			;Size:  24 bytes 
10fe			;Speed: 42+d(104+{0,9}) 
10fe			;       d is the number of digits in the number 
10fe			;       max is 640 cycles for a 5 digit number 
10fe			;Assuming no leading zeros: 
10fe			;1 digit:  146cc 
10fe			;2 digit:  250cc 
10fe			;3 digit:  354cc or 363cc (avg: 354.126cc) 
10fe			;4 digit:  458cc or 467cc (avg: 458.27cc) 
10fe			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
10fe			;avg: 544.81158447265625cc (544+13297/16384) 
10fe			;=============================================================== 
10fe 21 00 00		  ld hl,0 
1101			.u16a: 
1101 1a			  ld a,(de) 
1102 d6 30		  sub 30h 
1104 fe 0a		  cp 10 
1106 d0			  ret nc 
1107 13			  inc de 
1108 44			  ld b,h 
1109 4d			  ld c,l 
110a 29			  add hl,hl 
110b 29			  add hl,hl 
110c 09			  add hl,bc 
110d 29			  add hl,hl 
110e 85			  add a,l 
110f 6f			  ld l,a 
1110 30 ef		  jr nc,.u16a 
1112 24			  inc h 
1113 c3 01 11		  jp .u16a 
1116			 
1116			 
1116			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
1116			 
1116			;written by Zeda 
1116			;Converts a 16-bit unsigned integer to an ASCII string. 
1116			 
1116			uitoa_16: 
1116			;Input: 
1116			;   DE is the number to convert 
1116			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
1116			;Output: 
1116			;   HL points to the null-terminated ASCII string 
1116			;      NOTE: This isn't necessarily the same as the input HL. 
1116 d5			  push de 
1117 c5			  push bc 
1118 f5			  push af 
1119 eb			  ex de,hl 
111a			 
111a 01 f0 d8		  ld bc,-10000 
111d 3e 2f		  ld a,'0'-1 
111f 3c			  inc a 
1120 09			  add hl,bc  
1121 38 fc		   jr c,$-2 
1123 12			  ld (de),a 
1124 13			  inc de 
1125			 
1125 01 e8 03		  ld bc,1000 
1128 3e 3a		  ld a,'9'+1 
112a 3d			  dec a  
112b 09			  add hl,bc  
112c 30 fc		   jr nc,$-2 
112e 12			  ld (de),a 
112f 13			  inc de 
1130			 
1130 01 9c ff		  ld bc,-100 
1133 3e 2f		  ld a,'0'-1 
1135 3c			  inc a  
1136 09			  add hl,bc  
1137 38 fc		   jr c,$-2 
1139 12			  ld (de),a 
113a 13			  inc de 
113b			 
113b 7d			  ld a,l 
113c 26 3a		  ld h,'9'+1 
113e 25			  dec h  
113f c6 0a		  add a,10  
1141 30 fb		   jr nc,$-3 
1143 c6 30		  add a,'0' 
1145 eb			  ex de,hl 
1146 72			  ld (hl),d 
1147 23			  inc hl 
1148 77			  ld (hl),a 
1149 23			  inc hl 
114a 36 00		  ld (hl),0 
114c			 
114c			;Now strip the leading zeros 
114c 0e fa		  ld c,-6 
114e 09			  add hl,bc 
114f 3e 30		  ld a,'0' 
1151 23			  inc hl  
1152 be			  cp (hl)  
1153 28 fc		  jr z,$-2 
1155			 
1155			;Make sure that the string is non-empty! 
1155 7e			  ld a,(hl) 
1156 b7			  or a 
1157 20 01		  jr nz,.atoub 
1159 2b			  dec hl 
115a			.atoub: 
115a			 
115a f1			  pop af 
115b c1			  pop bc 
115c d1			  pop de 
115d c9			  ret 
115e			 
115e			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
115e			 
115e			toUpper: 
115e			;A is the char. 
115e			;If A is a lowercase letter, this sets it to the matching uppercase 
115e			;18cc or 30cc or 41cc 
115e			;avg: 26.75cc 
115e fe 61		  cp 'a' 
1160 d8			  ret c 
1161 fe 7b		  cp 'z'+1 
1163 d0			  ret nc 
1164 d6 20		  sub 'a'-'A' 
1166 c9			  ret 
1167			 
1167			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1167			 
1167			; String Length 
1167			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1167			 
1167			; Get the length of the null-terminated string starting at $8000 hl 
1167			;    LD     HL, $8000 
1167			 
1167			strlenz: 
1167			 
1167 af			    XOR    A               ; Zero is the value we are looking for. 
1168 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1169 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
116a			                           ; 65, 536 bytes (the entire addressable memory space). 
116a ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
116c			 
116c			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
116c 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
116d 6f			    LD     L, A             ; number of bytes 
116e ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1170 2b			    DEC    HL              ; Compensate for null. 
1171 c9				ret 
1172			 
1172			; Get the length of the A terminated string starting at $8000 hl 
1172			;    LD     HL, $8000 
1172			 
1172			strlent: 
1172			 
1172			                  ; A is the value we are looking for. 
1172 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1174 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1176			                           ; 65, 536 bytes (the entire addressable memory space). 
1176 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1178			 
1178			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1178 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
117a 2e 00		    LD     L, 0             ; number of bytes 
117c ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
117e 2b			    DEC    HL              ; Compensate for null. 
117f c9				ret 
1180			 
1180			 
1180			;Comparing Strings 
1180			 
1180			;IN    HL     Address of string1. 
1180			;      DE     Address of string2. 
1180			 
1180			; doc given but wrong??? 
1180			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
1180			;      carry  Set if string1 > string2, reset if string1 <= string2. 
1180			; tested 
1180			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
1180			 
1180			strcmp_old: 
1180 e5			    PUSH   HL 
1181 d5			    PUSH   DE 
1182			 
1182 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1183 be			    CP     (HL)            ; (want to minimize work). 
1184 38 01		    JR     C, Str1IsBigger 
1186 7e			    LD     A, (HL) 
1187			 
1187			Str1IsBigger: 
1187 4f			    LD     C, A             ; Put length in BC 
1188 06 00		    LD     B, 0 
118a 13			    INC    DE              ; Increment pointers to meat of string. 
118b 23			    INC    HL 
118c			 
118c			CmpLoop: 
118c 1a			    LD     A, (DE)          ; Compare bytes. 
118d ed a1		    CPI 
118f 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
1191 13			    INC    DE              ; Update pointer. 
1192 ea 8c 11		    JP     PE, CmpLoop 
1195			 
1195 d1			    POP    DE 
1196 e1			    POP    HL 
1197 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
1198 be			    CP     (HL) 
1199 c9			    RET 
119a			 
119a			NoMatch: 
119a 2b			    DEC    HL 
119b be			    CP     (HL)            ; Compare again to affect carry. 
119c d1			    POP    DE 
119d e1			    POP    HL 
119e c9			    RET 
119f			 
119f			;; test strmp 
119f			; 
119f			;ld de, .str1 
119f			;ld hl, .str2 
119f			;call strcmp 
119f			;jr z, .z1 
119f			;;this 
119f			;	if DEBUG_FORTH_WORDS 
119f			;		DMARK "NZ1" 
119f			;		CALLMONITOR 
119f			;	endif 
119f			;.z1: 
119f			; 
119f			;	if DEBUG_FORTH_WORDS 
119f			;		DMARK "ZZ1" 
119f			;		CALLMONITOR 
119f			;	endif 
119f			; 
119f			;ld de, .str1 
119f			;ld hl, .str1 
119f			;call strcmp 
119f			;jr z, .z2 
119f			;;this 
119f			;	if DEBUG_FORTH_WORDS 
119f			;		DMARK "NZ2" 
119f			;		CALLMONITOR 
119f			;	endif 
119f			;.z2: 
119f			; 
119f			;	if DEBUG_FORTH_WORDS 
119f			;		DMARK "ZZ2" 
119f			;		CALLMONITOR 
119f			;	endif 
119f			; 
119f			;ld de, .str1 
119f			;ld hl, .str2 
119f			;call strcmp 
119f			;jr c, .c1 
119f			; 
119f			;	if DEBUG_FORTH_WORDS 
119f			;		DMARK "Nc1" 
119f			;		CALLMONITOR 
119f			;	endif 
119f			;.c1: 
119f			;;this 
119f			;	if DEBUG_FORTH_WORDS 
119f			;		DMARK "cc1" 
119f			;		CALLMONITOR 
119f			;	endif 
119f			; 
119f			;ld de, .str1 
119f			;ld hl, .str1 
119f			;call strcmp 
119f			;jr c, .c2 
119f			;;this 
119f			;	if DEBUG_FORTH_WORDS 
119f			;		DMARK "Nc2" 
119f			;		CALLMONITOR 
119f			;	endif 
119f			;.c2: 
119f			; 
119f			;	if DEBUG_FORTH_WORDS 
119f			;		DMARK "cc2" 
119f			;		CALLMONITOR 
119f			;	endif 
119f			;	NEXTW 
119f			;.str1:   db "string1",0 
119f			;.str2:   db "string2",0 
119f			 
119f			; only care about direct match or not 
119f			; hl and de strings 
119f			; zero set if the same 
119f			 
119f			strcmp: 
119f 1a				ld a, (de) 
11a0 be				cp (hl) 
11a1 28 02			jr z, .ssame 
11a3 b7				or a 
11a4 c9				ret 
11a5			 
11a5			.ssame:  
11a5 fe 00			cp 0 
11a7 c8				ret z 
11a8			 
11a8 23				inc hl 
11a9 13				inc de 
11aa 18 f3			jr strcmp 
11ac				 
11ac				 
11ac			 
11ac			 
11ac			 
11ac			 
11ac			; eof 
11ac			 
11ac			 
11ac			 
11ac			 
11ac			 
11ac			 
# End of file firmware_strings.asm
11ac			include "firmware_memory.asm"   ; malloc and free  
11ac			 
11ac			if DEBUG_FORTH_MALLOC_HIGH 
11ac			.mallocsize: db "Wants malloc >256",0 
11ac			.mallocasize: db "MALLOC gives >256",0 
11ac			.malloczero: db "MALLOC gives zero",0 
11ac			 
11ac			malloc_guard_zerolen: 
11ac				push hl 
11ac				push de 
11ac				push af 
11ac			 
11ac				ld de, 0 
11ac			        call cmp16 
11ac				jr nz, .lowalloz 
11ac			 
11ac				push hl 
11ac				push de 
11ac					ld hl, display_fb0 
11ac					ld (display_fb_active), hl 
11ac				call clear_display 
11ac				ld a, 0 
11ac				ld de, .malloczero 
11ac				call str_at_display 
11ac				call update_display 
11ac				call delay1s 
11ac				call delay1s 
11ac				ld a, 0 
11ac				ld (os_view_disable), a 
11ac			 
11ac				pop de 
11ac				pop hl 
11ac			 
11ac				 
11ac			 
11ac				CALLMONITOR 
11ac			.lowalloz: 
11ac			 
11ac			 
11ac				pop af 
11ac				pop de 
11ac				pop hl 
11ac			ret 
11ac			 
11ac			malloc_guard_entry: 
11ac				push hl 
11ac				push de 
11ac				push af 
11ac			 
11ac			 	or a      ;clear carry flag 
11ac				push hl 
11ac				ld de, 255 
11ac				sbc hl, de 
11ac				jr c, .lowalloc 
11ac			 
11ac				push de 
11ac					ld hl, display_fb0 
11ac					ld (display_fb_active), hl 
11ac				call clear_display 
11ac				ld a, 0 
11ac				ld de, .mallocsize 
11ac				call str_at_display 
11ac				call update_display 
11ac				call delay1s 
11ac				call delay1s 
11ac				ld a, 0 
11ac				ld (os_view_disable), a 
11ac			 
11ac				pop de 
11ac				pop hl 
11ac			 
11ac				 
11ac			 
11ac				CALLMONITOR 
11ac				jr .lowdone 
11ac			.lowalloc: 
11ac			 
11ac			 
11ac				pop hl 
11ac			.lowdone:	pop af 
11ac				pop de 
11ac				pop hl 
11ac			ret 
11ac			 
11ac			malloc_guard_exit: 
11ac				push hl 
11ac				push de 
11ac				push af 
11ac			 
11ac			 	or a      ;clear carry flag 
11ac				push hl 
11ac				ld de, 255 
11ac				sbc hl, de 
11ac				jr c, .lowallocx 
11ac			 
11ac				push de 
11ac					ld hl, display_fb0 
11ac					ld (display_fb_active), hl 
11ac				call clear_display 
11ac				ld a, 0 
11ac				ld de, .mallocasize 
11ac				call str_at_display 
11ac				call update_display 
11ac				call delay1s 
11ac				call delay1s 
11ac				ld a, 0 
11ac				ld (os_view_disable), a 
11ac				pop de 
11ac				pop hl 
11ac			 
11ac				CALLMONITOR 
11ac				jr .lowdonex 
11ac			.lowallocx: 
11ac			 
11ac				pop hl 
11ac			.lowdonex:	pop af 
11ac				pop de 
11ac				pop hl 
11ac			ret 
11ac			endif 
11ac			 
11ac			if MALLOC_2 
11ac			; Z80 Malloc and Free Functions 
11ac			 
11ac			; Malloc Function: 
11ac			; Input: 
11ac			;   HL: Size of block to allocate 
11ac			; Output: 
11ac			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
11ac			 
11ac			malloc: 
11ac				 
11ac			if DEBUG_FORTH_MALLOC_HIGH 
11ac			call malloc_guard_entry 
11ac			endif 
11ac			 
11ac			 
11ac			 
11ac			 
11ac					if DEBUG_FORTH_MALLOC 
11ac						DMARK "mal" 
11ac						CALLMONITOR 
11ac					endif 
11ac			    push af            ; Save AF register 
11ac			    ld a, l            ; Load low byte of size into A 
11ac			    or h               ; Check if size is zero 
11ac			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
11ac			 
11ac			    ; Allocate memory 
11ac			    ld hl, (heap_start) ; Load start of heap into HL 
11ac					if DEBUG_FORTH_MALLOC 
11ac						DMARK "ma1" 
11ac						CALLMONITOR 
11ac					endif 
11ac			    call malloc_internal ; Call internal malloc function 
11ac			    pop af             ; Restore AF register 
11ac			if DEBUG_FORTH_MALLOC_HIGH 
11ac			call malloc_guard_exit 
11ac			call malloc_guard_zerolen 
11ac			endif 
11ac			    ret                ; Return 
11ac			 
11ac			; Free Function: 
11ac			; Input: 
11ac			;   HL: Pointer to memory block to free 
11ac			; Output: 
11ac			;   None 
11ac			 
11ac			free: 
11ac			    push af            ; Save AF register 
11ac			    ld a, l            ; Load low byte of pointer into A 
11ac			    or h               ; Check if pointer is NULL 
11ac			    jp z, free_exit    ; If pointer is NULL, exit 
11ac			 
11ac			    ; Free memory 
11ac			    ld hl, (heap_start) ; Load start of heap into HL 
11ac			    call free_internal  ; Call internal free function 
11ac			    pop af             ; Restore AF register 
11ac			    ret                ; Return 
11ac			 
11ac			; Internal Malloc Function: 
11ac			; Input: 
11ac			;   HL: Size of block to allocate 
11ac			; Output: 
11ac			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
11ac			 
11ac			malloc_internal: 
11ac			    ld bc, 2           ; Number of bytes to allocate for management overhead 
11ac			    add hl, bc         ; Add management overhead to requested size 
11ac			    ex de, hl          ; Save total size in DE, and keep it in HL 
11ac					if DEBUG_FORTH_MALLOC 
11ac						DMARK "ma2" 
11ac						CALLMONITOR 
11ac					endif 
11ac			 
11ac			    ; Search for free memory block 
11ac			    ld de, (heap_end)  ; Load end of heap into DE 
11ac			    ld bc, 0           ; Initialize counter 
11ac			 
11ac					if DEBUG_FORTH_MALLOC 
11ac						DMARK "ma2" 
11ac						CALLMONITOR 
11ac					endif 
11ac			malloc_search_loop: 
11ac			    ; Check if current block is free 
11ac			    ld a, (hl)         ; Load current block's status (free or used) 
11ac			    cp 0               ; Compare with zero (free) 
11ac			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
11ac			 
11ac			    ; Check if current block is large enough 
11ac			    ld a, (hl+1)       ; Load high byte of block size 
11ac			    cp l               ; Compare with low byte of requested size 
11ac			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
11ac			 
11ac			    ld a, (hl+2)       ; Load low byte of block size 
11ac			    cp h               ; Compare with high byte of requested size 
11ac			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
11ac			 
11ac			    ; Mark block as used 
11ac			    ld (hl), 0xFF      ; Set status byte to indicate used block 
11ac			 
11ac			    ; Calculate remaining space in block 
11ac			    ld bc, 0           ; Clear BC 
11ac			    add hl, bc         ; Increment HL to point to start of data block 
11ac			    add hl, de         ; HL = HL + DE (total size) 
11ac			    ld bc, 1           ; Number of bytes to allocate for management overhead 
11ac			    add hl, bc         ; Add management overhead to start of data block 
11ac			 
11ac			    ; Save pointer to allocated block in HL 
11ac			if DEBUG_FORTH_MALLOC_HIGH 
11ac						DMARK "ma5" 
11ac			call malloc_guard_exit 
11ac			call malloc_guard_zerolen 
11ac			endif 
11ac			    ret 
11ac			 
11ac			malloc_skip_block_check: 
11ac			    ; Move to the next block 
11ac			    ld bc, 3           ; Size of management overhead 
11ac			    add hl, bc         ; Move to the next block 
11ac			    inc de             ; Increment counter 
11ac			 
11ac			    ; Check if we have reached the end of heap 
11ac			    ld a, e            ; Load low byte of heap end address 
11ac			    cp (hl)            ; Compare with low byte of current address 
11ac			    jr nz, malloc_search_loop  ; If not equal, continue searching 
11ac			    ld a, d            ; Load high byte of heap end address 
11ac			    cp 0               ; Check if it's zero (end of memory) 
11ac			    jr nz, malloc_search_loop  ; If not zero, continue searching 
11ac			 
11ac			    ; If we reached here, allocation failed 
11ac			    xor a              ; Set result to NULL 
11ac			if DEBUG_FORTH_MALLOC_HIGH 
11ac						DMARK "ma6" 
11ac			call malloc_guard_exit 
11ac			call malloc_guard_zerolen 
11ac			endif 
11ac			    ret 
11ac			malloc_exit: 
11ac			if DEBUG_FORTH_MALLOC_HIGH 
11ac						DMARK "ma7" 
11ac			call malloc_guard_exit 
11ac			call malloc_guard_zerolen 
11ac			endif 
11ac			    ret 
11ac			 
11ac			; Internal Free Function: 
11ac			; Input: 
11ac			;   HL: Pointer to memory block to free 
11ac			; Output: 
11ac			;   None 
11ac			 
11ac			free_internal: 
11ac			    ld de, (heap_start) ; Load start of heap into DE 
11ac			    ld bc, 0            ; Initialize counter 
11ac			 
11ac			free_search_loop: 
11ac			    ; Check if current block contains the pointer 
11ac			    ld a, l             ; Load low byte of pointer 
11ac			    cp (hl+1)           ; Compare with high byte of current block's address 
11ac			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
11ac			    ld a, h             ; Load high byte of pointer 
11ac			    cp (hl+2)           ; Compare with low byte of current block's address 
11ac			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
11ac			 
11ac			    ; Mark block as free 
11ac			    ld (hl), 0          ; Set status byte to indicate free block 
11ac			    ret                 ; Return 
11ac			 
11ac			free_skip_block_check: 
11ac			    ; Move to the next block 
11ac			    ld bc, 3            ; Size of management overhead 
11ac			    add hl, bc          ; Move to the next block 
11ac			    inc de              ; Increment counter 
11ac			 
11ac			    ; Check if we have reached the end of heap 
11ac			    ld a, e             ; Load low byte of heap end address 
11ac			    cp (hl)             ; Compare with low byte of current address 
11ac			    jr nz, free_search_loop  ; If not equal, continue searching 
11ac			    ld a, d             ; Load high byte of heap end address 
11ac			    cp 0                ; Check if it's zero (end of memory) 
11ac			    jr nz, free_search_loop  ; If not zero, continue searching 
11ac			 
11ac			    ; If we reached here, pointer is not found in heap 
11ac			    ret 
11ac			 
11ac			free_exit: 
11ac			    ret                 ; Return 
11ac			 
11ac			; Define heap start and end addresses 
11ac			;heap_start:    .dw 0xC000   ; Start of heap 
11ac			;heap_end:      .dw 0xE000   ; End of heap 
11ac			 
11ac			endif 
11ac			 
11ac			 
11ac			if MALLOC_1 
11ac			 
11ac			 
11ac			 
11ac			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
11ac			 
11ac			;moved to firmware.asm 
11ac			;heap_start        .equ  0x9000      ; Starting address of heap 
11ac			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
11ac			 
11ac			;      .org 0 
11ac			;      jp    main 
11ac			 
11ac			 
11ac			;      .org  0x100 
11ac			;main: 
11ac			;      ld    HL, 0x8100 
11ac			;      ld    SP, HL 
11ac			; 
11ac			;      call  heap_init 
11ac			; 
11ac			;      ; Make some allocations 
11ac			;      ld    HL, 12 
11ac			;      call  malloc            ; Allocates 0x9004 
11ac			; 
11ac			;      ld    HL, 12 
11ac			;      call  malloc            ; Allocates 0x9014 
11ac			; 
11ac			;      ld    HL, 12 
11ac			;      call  malloc            ; Allocates 0x9024 
11ac			; 
11ac			;      ; Free some allocations 
11ac			;      ld    HL, 0x9014 
11ac			;      call  free 
11ac			; 
11ac			;      ld    HL, 0x9004 
11ac			;      call  free 
11ac			; 
11ac			;      ld    HL, 0x9024 
11ac			;      call  free 
11ac			; 
11ac			; 
11ac			;      halt 
11ac			 
11ac			 
11ac			;------------------------------------------------------------------------------ 
11ac			;     heap_init                                                               : 
11ac			;                                                                             : 
11ac			; Description                                                                 : 
11ac			;     Initialise the heap and make it ready for malloc and free operations.   : 
11ac			;                                                                             : 
11ac			;     The heap is maintained as a linked list, starting with an initial       : 
11ac			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
11ac			;     the first free block in the heap. Each block then points to the next    : 
11ac			;     free block within the heap, and the free list ends at the first block   : 
11ac			;     with a null pointer to the next free block.                             : 
11ac			;                                                                             : 
11ac			; Parameters                                                                  : 
11ac			;     Inputs are compile-time only. Two defines which specify the starting    : 
11ac			;     address of the heap and its size are required, along with a memory      : 
11ac			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
11ac			;     principally stores a pointer to the first free block in the heap.       : 
11ac			;                                                                             : 
11ac			; Returns                                                                     : 
11ac			;     Nothing                                                                 : 
11ac			;------------------------------------------------------------------------------ 
11ac			heap_init: 
11ac e5			      push  HL 
11ad			 
11ad			      ; Initialise free list struct 
11ad 21 0e 80		      ld    HL, heap_start 
11b0 22 0a 80		      ld    (free_list), HL 
11b3 21 00 00		      ld    HL, 0 
11b6 22 0c 80		      ld    (free_list+2), HL 
11b9			 
11b9			      ; Insert first free block at bottom of heap, consumes entire heap 
11b9 21 ff ed		      ld    HL, heap_start+heap_size-4 
11bc 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
11bf 21 f1 6d		      ld    HL, heap_size-4 
11c2 22 10 80		      ld    (heap_start+2), HL      ; Block size 
11c5			 
11c5			      ; Insert end of free list block at top of heap - two null words will 
11c5			      ; terminate the free list 
11c5 21 00 00		      ld    HL, 0 
11c8 22 01 ee		      ld    (heap_start+heap_size-2), HL 
11cb 22 ff ed		      ld    (heap_start+heap_size-4), HL 
11ce			 
11ce e1			      pop   HL 
11cf			 
11cf c9			      ret 
11d0			 
11d0			 
11d0			;------------------------------------------------------------------------------ 
11d0			;     malloc                                                                  : 
11d0			;                                                                             : 
11d0			; Description                                                                 : 
11d0			;     Allocates the wanted space from the heap and returns the address of the : 
11d0			;     first useable byte of the allocation.                                   : 
11d0			;                                                                             : 
11d0			;     Allocations can happen in one of two ways:                              : 
11d0			;                                                                             : 
11d0			;     1. A free block may be found which is the exact size wanted. In this    : 
11d0			;        case the block is removed from the free list and retuedn to the      : 
11d0			;        caller.                                                              : 
11d0			;     2. A free block may be found which is larger than the size wanted. In   : 
11d0			;        this case, the larger block is split into two. The first portion of  : 
11d0			;        this block will become the requested space by the malloc call and    : 
11d0			;        is returned to the caller. The second portion becomes a new free     : 
11d0			;        block, and the free list is adjusted to maintain continuity via this : 
11d0			;        newly created block.                                                 : 
11d0			;                                                                             : 
11d0			;     malloc does not set any initial value in the allocated space, the       : 
11d0			;     caller is required to do this as required.                              : 
11d0			;                                                                             : 
11d0			;     This implementation of malloc uses the stack exclusively, and is        : 
11d0			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
11d0			;     advisable to disable interrupts before calling malloc, and recommended  : 
11d0			;     to avoid the use of malloc inside ISRs in general.                      : 
11d0			;                                                                             : 
11d0			;     NOTE: heap_init must be called before malloc and free can be used.      : 
11d0			;                                                                             : 
11d0			; Parameters                                                                  : 
11d0			;     HL  Number of bytes wanted                                              : 
11d0			;                                                                             : 
11d0			; Returns                                                                     : 
11d0			;     HL  Address of the first useable byte of the allocation                 : 
11d0			;                                                                             : 
11d0			; Flags                                                                       : 
11d0			;     Z   Set if the allocation did not succeed, clear otherwise              : 
11d0			;                                                                             : 
11d0			; Stack frame                                                                 : 
11d0			;       |             |                                                       : 
11d0			;       +-------------+                                                       : 
11d0			;       |     BC      |                                                       : 
11d0			;       +-------------+                                                       : 
11d0			;       |     DE      |                                                       : 
11d0			;       +-------------+                                                       : 
11d0			;       |     IX      |                                                       : 
11d0			;       +-------------+                                                       : 
11d0			;       |  prev_free  |                                                       : 
11d0			;   +4  +-------------+                                                       : 
11d0			;       |  this_free  |                                                       : 
11d0			;   +2  +-------------+                                                       : 
11d0			;       |  next_free  |                                                       : 
11d0			;   +0  +-------------+                                                       : 
11d0			;       |             |                                                       : 
11d0			;                                                                             : 
11d0			;------------------------------------------------------------------------------ 
11d0			 
11d0			 
11d0			;malloc: 
11d0			; 
11d0			;	SAVESP ON 1 
11d0			; 
11d0			;	call malloc_code 
11d0			; 
11d0			;	CHECKSP ON 1 
11d0			;	ret 
11d0			 
11d0			 
11d0			malloc: 
11d0 c5			      push  BC 
11d1 d5			      push  DE 
11d2 dd e5		      push  IX 
11d4			if DEBUG_FORTH_MALLOC_HIGH 
11d4			call malloc_guard_entry 
11d4			endif 
11d4			 
11d4					if DEBUG_FORTH_MALLOC 
11d4						DMARK "mal" 
11d4						CALLMONITOR 
11d4					endif 
11d4 7c			      ld    A, H                    ; Exit if no space requested 
11d5 b5			      or    L 
11d6 ca 95 12		      jp    Z, malloc_early_exit 
11d9			 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			; 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			 
11d9			 
11d9			 
11d9			 
11d9					if DEBUG_FORTH_MALLOC 
11d9						DMARK "maA" 
11d9						CALLMONITOR 
11d9					endif 
11d9			      ; Set up stack frame 
11d9 eb			      ex    DE, HL 
11da 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
11dd 39			      add   HL, SP 
11de f9			      ld    SP, HL 
11df dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
11e3 dd 39		      add   IX, SP 
11e5			 
11e5			      ; Setup initial state 
11e5 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
11e8 19			      add   HL, DE 
11e9			 
11e9 44			      ld    B, H                    ; Move want to BC 
11ea 4d			      ld    C, L 
11eb			 
11eb 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
11ee dd 75 04		      ld    (IX+4), L 
11f1 dd 74 05		      ld    (IX+5), H 
11f4			 
11f4 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
11f5 23			      inc   HL 
11f6 56			      ld    D, (HL) 
11f7 dd 73 02		      ld    (IX+2), E 
11fa dd 72 03		      ld    (IX+3), D 
11fd eb			      ex    DE, HL                  ; this_free ptr into HL 
11fe			 
11fe					if DEBUG_FORTH_MALLOC 
11fe						DMARK "maB" 
11fe						CALLMONITOR 
11fe					endif 
11fe			      ; Loop through free block list to find some space 
11fe			malloc_find_space: 
11fe 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
11ff 23			      inc   HL 
1200 56			      ld    D, (HL) 
1201			 
1201 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1202 b3			      or    E 
1203 ca 8f 12		      jp    Z, malloc_no_space 
1206			 
1206 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
1209 dd 72 01		      ld    (IX+1), D 
120c			 
120c			      ; Does this block have enough space to make the allocation? 
120c 23			      inc   HL                      ; Load free block size into DE 
120d 5e			      ld    E, (HL) 
120e 23			      inc   HL 
120f 56			      ld    D, (HL) 
1210			 
1210 eb			      ex    DE, HL                  ; Check size of block against want 
1211 b7			      or    A                       ; Ensure carry flag clear 
1212 ed 42		      sbc   HL, BC 
1214 e5			      push  HL                      ; Store the result for later (new block size) 
1215			 
1215 ca 64 12		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1218 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
121a			 
121a			      ; this_free block is not big enough, setup ptrs to test next free block 
121a e1			      pop   HL                      ; Discard previous result 
121b			 
121b dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
121e dd 66 03		      ld    H, (IX+3) 
1221 dd 75 04		      ld    (IX+4), L 
1224 dd 74 05		      ld    (IX+5), H 
1227			 
1227 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
122a dd 66 01		      ld    H, (IX+1) 
122d dd 75 02		      ld    (IX+2), L 
1230 dd 74 03		      ld    (IX+3), H 
1233			 
1233					if DEBUG_FORTH_MALLOC 
1233						DMARK "MA>" 
1233						CALLMONITOR 
1233					endif 
1233 18 c9		      jr    malloc_find_space 
1235			 
1235			      ; split a bigger block into two - requested size and remaining size 
1235			malloc_alloc_split: 
1235					if DEBUG_FORTH_MALLOC 
1235						DMARK "MAs" 
1235						CALLMONITOR 
1235					endif 
1235 eb			      ex    DE, HL                  ; Calculate address of new free block 
1236 2b			      dec   HL 
1237 2b			      dec   HL 
1238 2b			      dec   HL 
1239 09			      add   HL, BC 
123a			 
123a			      ; Create a new block and point it at next_free 
123a dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
123d dd 56 01		      ld    D, (IX+1) 
1240			 
1240 73			      ld    (HL), E                 ; Store next_free ptr into new block 
1241 23			      inc   HL 
1242 72			      ld    (HL), D 
1243			 
1243 d1			      pop   DE                      ; Store size of new block into new block 
1244 23			      inc   HL 
1245 73			      ld    (HL), E 
1246 23			      inc   HL 
1247 72			      ld    (HL), D 
1248			 
1248			      ; Update this_free ptr to point to new block 
1248 2b			      dec   HL 
1249 2b			      dec   HL 
124a 2b			      dec   HL 
124b			 
124b dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
124e dd 56 03		      ld    D, (IX+3) 
1251			 
1251 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1254 dd 74 03		      ld    (IX+3), H 
1257			 
1257			      ; Modify this_free block to be allocation 
1257 eb			      ex    DE, HL 
1258 af			      xor   A                       ; Null the next block ptr of allocated block 
1259 77			      ld    (HL), A 
125a 23			      inc   HL 
125b 77			      ld    (HL), A 
125c			 
125c 23			      inc   HL                      ; Store want size into allocated block 
125d 71			      ld    (HL), C 
125e 23			      inc   HL 
125f 70			      ld    (HL), B 
1260 23			      inc   HL 
1261 e5			      push  HL                      ; Address of allocation to return 
1262			 
1262 18 19		      jr    malloc_update_links 
1264			 
1264			malloc_alloc_fit: 
1264 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1265			 
1265					if DEBUG_FORTH_MALLOC 
1265						DMARK "MAf" 
1265						CALLMONITOR 
1265					endif 
1265			      ; Modify this_free block to be allocation 
1265 eb			      ex    DE, HL 
1266 2b			      dec   HL 
1267 2b			      dec   HL 
1268 2b			      dec   HL 
1269			 
1269 af			      xor   A                       ; Null the next block ptr of allocated block 
126a 77			      ld    (HL), A 
126b 23			      inc   HL 
126c 77			      ld    (HL), A 
126d			 
126d 23			      inc   HL                      ; Store address of allocation to return 
126e 23			      inc   HL 
126f 23			      inc   HL 
1270 e5			      push  HL 
1271			 
1271			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1271 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
1274 dd 66 01		      ld    H, (IX+1) 
1277			 
1277 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
127a dd 74 03		      ld    (IX+3), H 
127d			 
127d			 
127d			malloc_update_links: 
127d			      ; Update prev_free ptr to point to this_free 
127d dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1280 dd 66 05		      ld    H, (IX+5) 
1283			 
1283 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1286 dd 56 03		      ld    D, (IX+3) 
1289			 
1289 73			      ld    (HL), E                 ; this_free ptr into prev_free 
128a 23			      inc   HL 
128b 72			      ld    (HL), D 
128c			 
128c					if DEBUG_FORTH_MALLOC 
128c						DMARK "Mul" 
128c						CALLMONITOR 
128c					endif 
128c			      ; Clear the Z flag to indicate successful allocation 
128c 7a			      ld    A, D 
128d b3			      or    E 
128e			 
128e d1			      pop   DE                      ; Address of allocation 
128f					if DEBUG_FORTH_MALLOC 
128f						DMARK "MAu" 
128f						CALLMONITOR 
128f					endif 
128f			 
128f			malloc_no_space: 
128f 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
1292 39			      add   HL, SP 
1293 f9			      ld    SP, HL 
1294			 
1294 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1295					if DEBUG_FORTH_MALLOC 
1295						DMARK "MAN" 
1295						CALLMONITOR 
1295					endif 
1295			 
1295			malloc_early_exit: 
1295					if DEBUG_FORTH_MALLOC 
1295						DMARK "MAx" 
1295						CALLMONITOR 
1295					endif 
1295 dd e1		      pop   IX 
1297 d1			      pop   DE 
1298 c1			      pop   BC 
1299			 
1299			if DEBUG_FORTH_MALLOC_HIGH 
1299			call malloc_guard_exit 
1299			call malloc_guard_zerolen 
1299			endif 
1299 c9			      ret 
129a			 
129a			 
129a			;------------------------------------------------------------------------------ 
129a			;     free                                                                    : 
129a			;                                                                             : 
129a			; Description                                                                 : 
129a			;     Return the space pointed to by HL to the heap. HL must be an address as : 
129a			;     returned by malloc, otherwise the behaviour is undefined.               : 
129a			;                                                                             : 
129a			;     Where possible, directly adjacent free blocks will be merged together   : 
129a			;     into larger blocks to help ensure that the heap does not become         : 
129a			;     excessively fragmented.                                                 : 
129a			;                                                                             : 
129a			;     free does not clear or set any other value into the freed space, and    : 
129a			;     therefore its contents may be visible through subsequent malloc's. The  : 
129a			;     caller should clear the freed space as required.                        : 
129a			;                                                                             : 
129a			;     This implementation of free uses the stack exclusively, and is          : 
129a			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
129a			;     advisable to disable interrupts before calling free, and recommended    : 
129a			;     to avoid the use of free inside ISRs in general.                        : 
129a			;                                                                             : 
129a			;     NOTE: heap_init must be called before malloc and free can be used.      : 
129a			;                                                                             : 
129a			; Parameters                                                                  : 
129a			;     HL  Pointer to address of first byte of allocation to be freed          : 
129a			;                                                                             : 
129a			; Returns                                                                     : 
129a			;     Nothing                                                                 : 
129a			;                                                                             : 
129a			; Stack frame                                                                 : 
129a			;       |             |                                                       : 
129a			;       +-------------+                                                       : 
129a			;       |     BC      |                                                       : 
129a			;       +-------------+                                                       : 
129a			;       |     DE      |                                                       : 
129a			;       +-------------+                                                       : 
129a			;       |     IX      |                                                       : 
129a			;       +-------------+                                                       : 
129a			;       |  prev_free  |                                                       : 
129a			;   +2  +-------------+                                                       : 
129a			;       |  next_free  |                                                       : 
129a			;   +0  +-------------+                                                       : 
129a			;       |             |                                                       : 
129a			;                                                                             : 
129a			;------------------------------------------------------------------------------ 
129a			free: 
129a c5			      push  BC 
129b d5			      push  DE 
129c dd e5		      push  IX 
129e			 
129e 7c			      ld    A, H                    ; Exit if ptr is null 
129f b5			      or    L 
12a0 ca 64 13		      jp    Z, free_early_exit 
12a3			 
12a3			      ; Set up stack frame 
12a3 eb			      ex    DE, HL 
12a4 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
12a7 39			      add   HL, SP 
12a8 f9			      ld    SP, HL 
12a9 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
12ad dd 39		      add   IX, SP 
12af			 
12af			      ; The address in HL points to the start of the useable allocated space, 
12af			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
12af			      ; address of the block itself. 
12af eb			      ex    DE, HL 
12b0 11 fc ff		      ld    DE, -4 
12b3 19			      add   HL, DE 
12b4			 
12b4			      ; An allocated block must have a null next block pointer in it 
12b4 7e			      ld    A, (HL) 
12b5 23			      inc   HL 
12b6 b6			      or    (HL) 
12b7 c2 5f 13		      jp    NZ, free_done 
12ba			 
12ba 2b			      dec   HL 
12bb			 
12bb 44			      ld    B, H                    ; Copy HL to BC 
12bc 4d			      ld    C, L 
12bd			 
12bd			      ; Loop through the free list to find the first block with an address 
12bd			      ; higher than the block being freed 
12bd 21 0a 80		      ld    HL, free_list 
12c0			 
12c0			free_find_higher_block: 
12c0 5e			      ld    E, (HL)                 ; Load next ptr from free block 
12c1 23			      inc   HL 
12c2 56			      ld    D, (HL) 
12c3 2b			      dec   HL 
12c4			 
12c4 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
12c7 dd 72 01		      ld    (IX+1), D 
12ca dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
12cd dd 74 03		      ld    (IX+3), H 
12d0			 
12d0 78			      ld    A, B                    ; Check if DE is greater than BC 
12d1 ba			      cp    D                       ; Compare MSB first 
12d2 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
12d4 30 04		      jr    NC, free_find_higher_block_skip 
12d6 79			      ld    A, C 
12d7 bb			      cp    E                       ; Then compare LSB 
12d8 38 08		      jr    C, free_found_higher_block 
12da			 
12da			free_find_higher_block_skip: 
12da 7a			      ld    A, D                    ; Reached the end of the free list? 
12db b3			      or    E 
12dc ca 5f 13		      jp    Z, free_done 
12df			 
12df eb			      ex    DE, HL 
12e0			 
12e0 18 de		      jr    free_find_higher_block 
12e2			 
12e2			free_found_higher_block: 
12e2			      ; Insert freed block between prev and next free blocks 
12e2 71			      ld    (HL), C                 ; Point prev free block to freed block 
12e3 23			      inc   HL 
12e4 70			      ld    (HL), B 
12e5			 
12e5 60			      ld    H, B                    ; Point freed block at next free block 
12e6 69			      ld    L, C 
12e7 73			      ld    (HL), E 
12e8 23			      inc   HL 
12e9 72			      ld    (HL), D 
12ea			 
12ea			      ; Check if the freed block is adjacent to the next free block 
12ea 23			      inc   HL                      ; Load size of freed block into HL 
12eb 5e			      ld    E, (HL) 
12ec 23			      inc   HL 
12ed 56			      ld    D, (HL) 
12ee eb			      ex    DE, HL 
12ef			 
12ef 09			      add   HL, BC                  ; Add addr of freed block and its size 
12f0			 
12f0 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
12f3 dd 56 01		      ld    D, (IX+1) 
12f6			 
12f6 b7			      or    A                       ; Clear the carry flag 
12f7 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
12f9 20 22		      jr    NZ, free_check_adjacent_to_prev 
12fb			 
12fb			      ; Freed block is adjacent to next, merge into one bigger block 
12fb eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
12fc 5e			      ld    E, (HL) 
12fd 23			      inc   HL 
12fe 56			      ld    D, (HL) 
12ff e5			      push  HL                      ; Save ptr to next block for later 
1300			 
1300 60			      ld    H, B                    ; Store ptr from next block into freed block 
1301 69			      ld    L, C 
1302 73			      ld    (HL), E 
1303 23			      inc   HL 
1304 72			      ld    (HL), D 
1305			 
1305 e1			      pop   HL                      ; Restore ptr to next block 
1306 23			      inc   HL                      ; Load size of next block into DE 
1307 5e			      ld    E, (HL) 
1308 23			      inc   HL 
1309 56			      ld    D, (HL) 
130a d5			      push  DE                      ; Save next block size for later 
130b			 
130b 60			      ld    H, B                    ; Load size of freed block into HL 
130c 69			      ld    L, C 
130d 23			      inc   HL 
130e 23			      inc   HL 
130f 5e			      ld    E, (HL) 
1310 23			      inc   HL 
1311 56			      ld    D, (HL) 
1312 eb			      ex    DE, HL 
1313			 
1313 d1			      pop   DE                      ; Restore size of next block 
1314 19			      add   HL, DE                  ; Add sizes of both blocks 
1315 eb			      ex    DE, HL 
1316			 
1316 60			      ld    H, B                    ; Store new bigger size into freed block 
1317 69			      ld    L, C 
1318 23			      inc   HL 
1319 23			      inc   HL 
131a 73			      ld    (HL), E 
131b 23			      inc   HL 
131c 72			      ld    (HL), D 
131d			 
131d			free_check_adjacent_to_prev: 
131d			      ; Check if the freed block is adjacent to the prev free block 
131d dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
1320 dd 66 03		      ld    H, (IX+3) 
1323			 
1323 23			      inc   HL                      ; Size of prev free block into DE 
1324 23			      inc   HL 
1325 5e			      ld    E, (HL) 
1326 23			      inc   HL 
1327 56			      ld    D, (HL) 
1328 2b			      dec   HL 
1329 2b			      dec   HL 
132a 2b			      dec   HL 
132b			 
132b 19			      add   HL, DE                  ; Add prev block addr and size 
132c			 
132c b7			      or    A                       ; Clear the carry flag 
132d ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
132f 20 2e		      jr    NZ, free_done 
1331			 
1331			      ; Freed block is adjacent to prev, merge into one bigger block 
1331 60			      ld    H, B                    ; Load next ptr from freed block into DE 
1332 69			      ld    L, C 
1333 5e			      ld    E, (HL) 
1334 23			      inc   HL 
1335 56			      ld    D, (HL) 
1336 e5			      push  HL                      ; Save freed block ptr for later 
1337			 
1337 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
133a dd 66 03		      ld    H, (IX+3) 
133d 73			      ld    (HL), E 
133e 23			      inc   HL 
133f 72			      ld    (HL), D 
1340			 
1340 e1			      pop   HL                      ; Restore freed block ptr 
1341 23			      inc   HL                      ; Load size of freed block into DE 
1342 5e			      ld    E, (HL) 
1343 23			      inc   HL 
1344 56			      ld    D, (HL) 
1345 d5			      push  DE                      ; Save freed block size for later 
1346			 
1346 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1349 dd 66 03		      ld    H, (IX+3) 
134c 23			      inc   HL 
134d 23			      inc   HL 
134e 5e			      ld    E, (HL) 
134f 23			      inc   HL 
1350 56			      ld    D, (HL) 
1351			 
1351 e1			      pop   HL                      ; Add sizes of both blocks 
1352 19			      add   HL, DE 
1353 eb			      ex    DE, HL 
1354			 
1354 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1357 dd 66 03		      ld    H, (IX+3) 
135a 23			      inc   HL 
135b 23			      inc   HL 
135c 73			      ld    (HL), E 
135d 23			      inc   HL 
135e 72			      ld    (HL), D 
135f			 
135f			free_done: 
135f 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
1362 39			      add   HL, SP 
1363 f9			      ld    SP, HL 
1364			 
1364			free_early_exit: 
1364 dd e1		      pop   IX 
1366 d1			      pop   DE 
1367 c1			      pop   BC 
1368			 
1368 c9			      ret 
1369			 
1369			; moved to firmware.asm 
1369			; 
1369			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1369			;                  .dw   0 
1369			 
1369			 
1369			endif 
1369			 
1369			 
1369			if MALLOC_3 
1369			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1369			;heap_start        .equ  0x9000      ; Starting address of heap 
1369			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1369			; 
1369			 ;     .org 0 
1369			  ;    jp    main 
1369			; 
1369			; 
1369			 ;     .org  0x100 
1369			;main: 
1369			 ;     ld    HL, 0x8100 
1369			  ;    ld    SP, HL 
1369			; 
1369			;      call  heap_init 
1369			 
1369			      ; Make some allocations 
1369			;      ld    HL, 12 
1369			;      call  malloc            ; Allocates 0x9004 
1369			; 
1369			 ;     ld    HL, 12 
1369			;      call  malloc            ; Allocates 0x9014 
1369			 
1369			;      ld    HL, 12 
1369			;      call  malloc            ; Allocates 0x9024 
1369			 
1369			      ; Free some allocations 
1369			;      ld    HL, 0x9014 
1369			;      call  free 
1369			 
1369			;      ld    HL, 0x9004 
1369			;      call  free 
1369			; 
1369			;      ld    HL, 0x9024 
1369			;      call  free 
1369			 
1369			 
1369			 ;     halt 
1369			 
1369			 
1369			;------------------------------------------------------------------------------ 
1369			;     heap_init                                                               : 
1369			;                                                                             : 
1369			; Description                                                                 : 
1369			;     Initialise the heap and make it ready for malloc and free operations.   : 
1369			;                                                                             : 
1369			;     The heap is maintained as a linked list, starting with an initial       : 
1369			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1369			;     the first free block in the heap. Each block then points to the next    : 
1369			;     free block within the heap, and the free list ends at the first block   : 
1369			;     with a null pointer to the next free block.                             : 
1369			;                                                                             : 
1369			; Parameters                                                                  : 
1369			;     Inputs are compile-time only. Two defines which specify the starting    : 
1369			;     address of the heap and its size are required, along with a memory      : 
1369			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1369			;     principally stores a pointer to the first free block in the heap.       : 
1369			;                                                                             : 
1369			; Returns                                                                     : 
1369			;     Nothing                                                                 : 
1369			;------------------------------------------------------------------------------ 
1369			heap_init: 
1369			      push  HL 
1369			 
1369			      ; Initialise free list struct 
1369			      ld    HL, heap_start 
1369			      ld    (free_list), HL 
1369			      ld    HL, 0 
1369			      ld    (free_list+2), HL 
1369			 
1369			      ; Insert first free block at bottom of heap, consumes entire heap 
1369			      ld    HL, heap_start+heap_size-4 
1369			      ld    (heap_start), HL        ; Next block (end of free list) 
1369			      ld    HL, heap_size-4 
1369			      ld    (heap_start+2), HL      ; Block size 
1369			 
1369			      ; Insert end of free list block at top of heap - two null words will 
1369			      ; terminate the free list 
1369			      ld    HL, 0 
1369			      ld    (heap_start+heap_size-2), HL 
1369			      ld    (heap_start+heap_size-4), HL 
1369			 
1369			      pop   HL 
1369			 
1369			      ret 
1369			 
1369			 
1369			;------------------------------------------------------------------------------ 
1369			;     malloc                                                                  : 
1369			;                                                                             : 
1369			; Description                                                                 : 
1369			;     Allocates the wanted space from the heap and returns the address of the : 
1369			;     first useable byte of the allocation.                                   : 
1369			;                                                                             : 
1369			;     Allocations can happen in one of two ways:                              : 
1369			;                                                                             : 
1369			;     1. A free block may be found which is the exact size wanted. In this    : 
1369			;        case the block is removed from the free list and retuedn to the      : 
1369			;        caller.                                                              : 
1369			;     2. A free block may be found which is larger than the size wanted. In   : 
1369			;        this case, the larger block is split into two. The first portion of  : 
1369			;        this block will become the requested space by the malloc call and    : 
1369			;        is returned to the caller. The second portion becomes a new free     : 
1369			;        block, and the free list is adjusted to maintain continuity via this : 
1369			;        newly created block.                                                 : 
1369			;                                                                             : 
1369			;     malloc does not set any initial value in the allocated space, the       : 
1369			;     caller is required to do this as required.                              : 
1369			;                                                                             : 
1369			;     This implementation of malloc uses the stack exclusively, and is        : 
1369			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1369			;     advisable to disable interrupts before calling malloc, and recommended  : 
1369			;     to avoid the use of malloc inside ISRs in general.                      : 
1369			;                                                                             : 
1369			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1369			;                                                                             : 
1369			; Parameters                                                                  : 
1369			;     HL  Number of bytes wanted                                              : 
1369			;                                                                             : 
1369			; Returns                                                                     : 
1369			;     HL  Address of the first useable byte of the allocation                 : 
1369			;                                                                             : 
1369			; Flags                                                                       : 
1369			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1369			;                                                                             : 
1369			; Stack frame                                                                 : 
1369			;       |             |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |     BC      |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |     DE      |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |     IX      |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |  prev_free  |                                                       : 
1369			;   +4  +-------------+                                                       : 
1369			;       |  this_free  |                                                       : 
1369			;   +2  +-------------+                                                       : 
1369			;       |  next_free  |                                                       : 
1369			;   +0  +-------------+                                                       : 
1369			;       |             |                                                       : 
1369			;                                                                             : 
1369			;------------------------------------------------------------------------------ 
1369			malloc: 
1369			      push  BC 
1369			      push  DE 
1369			      push  IX 
1369			 
1369			      ld    A, H                    ; Exit if no space requested 
1369			      or    L 
1369			      jp    Z, malloc_early_exit 
1369			 
1369			      ; Set up stack frame 
1369			      ex    DE, HL 
1369			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1369			      add   HL, SP 
1369			      ld    SP, HL 
1369			      ld    IX, 0                   ; Use IX as a frame pointer 
1369			      add   IX, SP 
1369			 
1369			      ; Setup initial state 
1369			      ld    HL, 4                   ; want must also include space used by block struct 
1369			      add   HL, DE 
1369			 
1369			      ld    B, H                    ; Move want to BC 
1369			      ld    C, L 
1369			 
1369			      ld    HL, free_list           ; Store prev_free ptr to stack 
1369			      ld    (IX+4), L 
1369			      ld    (IX+5), H 
1369			 
1369			      ld    E, (HL)                 ; Store this_free ptr to stack 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      ld    (IX+2), E 
1369			      ld    (IX+3), D 
1369			      ex    DE, HL                  ; this_free ptr into HL 
1369			 
1369			      ; Loop through free block list to find some space 
1369			malloc_find_space: 
1369			      ld    E, (HL)                 ; Load next_free ptr into DE 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			 
1369			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1369			      or    E 
1369			      jp    Z, malloc_no_space 
1369			 
1369			      ld    (IX+0), E               ; Store next_free ptr to stack 
1369			      ld    (IX+1), D 
1369			 
1369			      ; Does this block have enough space to make the allocation? 
1369			      inc   HL                      ; Load free block size into DE 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			 
1369			      ex    DE, HL                  ; Check size of block against want 
1369			      or    A                       ; Ensure carry flag clear 
1369			      sbc   HL, BC 
1369			      push  HL                      ; Store the result for later (new block size) 
1369			 
1369			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1369			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1369			 
1369			      ; this_free block is not big enough, setup ptrs to test next free block 
1369			      pop   HL                      ; Discard previous result 
1369			 
1369			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1369			      ld    H, (IX+3) 
1369			      ld    (IX+4), L 
1369			      ld    (IX+5), H 
1369			 
1369			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1369			      ld    H, (IX+1) 
1369			      ld    (IX+2), L 
1369			      ld    (IX+3), H 
1369			 
1369			      jr    malloc_find_space 
1369			 
1369			      ; split a bigger block into two - requested size and remaining size 
1369			malloc_alloc_split: 
1369			      ex    DE, HL                  ; Calculate address of new free block 
1369			      dec   HL 
1369			      dec   HL 
1369			      dec   HL 
1369			      add   HL, BC 
1369			 
1369			      ; Create a new block and point it at next_free 
1369			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1369			      ld    D, (IX+1) 
1369			 
1369			      ld    (HL), E                 ; Store next_free ptr into new block 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			      pop   DE                      ; Store size of new block into new block 
1369			      inc   HL 
1369			      ld    (HL), E 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			      ; Update this_free ptr to point to new block 
1369			      dec   HL 
1369			      dec   HL 
1369			      dec   HL 
1369			 
1369			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1369			      ld    D, (IX+3) 
1369			 
1369			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1369			      ld    (IX+3), H 
1369			 
1369			      ; Modify this_free block to be allocation 
1369			      ex    DE, HL 
1369			      xor   A                       ; Null the next block ptr of allocated block 
1369			      ld    (HL), A 
1369			      inc   HL 
1369			      ld    (HL), A 
1369			 
1369			      inc   HL                      ; Store want size into allocated block 
1369			      ld    (HL), C 
1369			      inc   HL 
1369			      ld    (HL), B 
1369			      inc   HL 
1369			      push  HL                      ; Address of allocation to return 
1369			 
1369			      jr    malloc_update_links 
1369			 
1369			malloc_alloc_fit: 
1369			      pop   HL                      ; Dont need new block size, want is exact fit 
1369			 
1369			      ; Modify this_free block to be allocation 
1369			      ex    DE, HL 
1369			      dec   HL 
1369			      dec   HL 
1369			      dec   HL 
1369			 
1369			      xor   A                       ; Null the next block ptr of allocated block 
1369			      ld    (HL), A 
1369			      inc   HL 
1369			      ld    (HL), A 
1369			 
1369			      inc   HL                      ; Store address of allocation to return 
1369			      inc   HL 
1369			      inc   HL 
1369			      push  HL 
1369			 
1369			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1369			      ld    L, (IX+0)               ; next_free to HL 
1369			      ld    H, (IX+1) 
1369			 
1369			      ld    (IX+2), L               ; HL to this_free 
1369			      ld    (IX+3), H 
1369			 
1369			 
1369			malloc_update_links: 
1369			      ; Update prev_free ptr to point to this_free 
1369			      ld    L, (IX+4)               ; prev_free ptr to HL 
1369			      ld    H, (IX+5) 
1369			 
1369			      ld    E, (IX+2)               ; this_free ptr to DE 
1369			      ld    D, (IX+3) 
1369			 
1369			      ld    (HL), E                 ; this_free ptr into prev_free 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			      ; Clear the Z flag to indicate successful allocation 
1369			      ld    A, D 
1369			      or    E 
1369			 
1369			      pop   DE                      ; Address of allocation 
1369			 
1369			malloc_no_space: 
1369			      ld    HL, 6                   ; Clean up stack frame 
1369			      add   HL, SP 
1369			      ld    SP, HL 
1369			 
1369			      ex    DE, HL                  ; Alloc addr into HL for return 
1369			 
1369			malloc_early_exit: 
1369			      pop   IX 
1369			      pop   DE 
1369			      pop   BC 
1369			 
1369			      ret 
1369			 
1369			 
1369			;------------------------------------------------------------------------------ 
1369			;     free                                                                    : 
1369			;                                                                             : 
1369			; Description                                                                 : 
1369			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1369			;     returned by malloc, otherwise the behaviour is undefined.               : 
1369			;                                                                             : 
1369			;     Where possible, directly adjacent free blocks will be merged together   : 
1369			;     into larger blocks to help ensure that the heap does not become         : 
1369			;     excessively fragmented.                                                 : 
1369			;                                                                             : 
1369			;     free does not clear or set any other value into the freed space, and    : 
1369			;     therefore its contents may be visible through subsequent malloc's. The  : 
1369			;     caller should clear the freed space as required.                        : 
1369			;                                                                             : 
1369			;     This implementation of free uses the stack exclusively, and is          : 
1369			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1369			;     advisable to disable interrupts before calling free, and recommended    : 
1369			;     to avoid the use of free inside ISRs in general.                        : 
1369			;                                                                             : 
1369			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1369			;                                                                             : 
1369			; Parameters                                                                  : 
1369			;     HL  Pointer to address of first byte of allocation to be freed          : 
1369			;                                                                             : 
1369			; Returns                                                                     : 
1369			;     Nothing                                                                 : 
1369			;                                                                             : 
1369			; Stack frame                                                                 : 
1369			;       |             |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |     BC      |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |     DE      |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |     IX      |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |  prev_free  |                                                       : 
1369			;   +2  +-------------+                                                       : 
1369			;       |  next_free  |                                                       : 
1369			;   +0  +-------------+                                                       : 
1369			;       |             |                                                       : 
1369			;                                                                             : 
1369			;------------------------------------------------------------------------------ 
1369			free: 
1369			      push  BC 
1369			      push  DE 
1369			      push  IX 
1369			 
1369			      ld    A, H                    ; Exit if ptr is null 
1369			      or    L 
1369			      jp    Z, free_early_exit 
1369			 
1369			      ; Set up stack frame 
1369			      ex    DE, HL 
1369			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1369			      add   HL, SP 
1369			      ld    SP, HL 
1369			      ld    IX, 0                   ; Use IX as a frame pointer 
1369			      add   IX, SP 
1369			 
1369			      ; The address in HL points to the start of the useable allocated space, 
1369			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1369			      ; address of the block itself. 
1369			      ex    DE, HL 
1369			      ld    DE, -4 
1369			      add   HL, DE 
1369			 
1369			      ; An allocated block must have a null next block pointer in it 
1369			      ld    A, (HL) 
1369			      inc   HL 
1369			      or    (HL) 
1369			      jp    NZ, free_done 
1369			 
1369			      dec   HL 
1369			 
1369			      ld    B, H                    ; Copy HL to BC 
1369			      ld    C, L 
1369			 
1369			      ; Loop through the free list to find the first block with an address 
1369			      ; higher than the block being freed 
1369			      ld    HL, free_list 
1369			 
1369			free_find_higher_block: 
1369			      ld    E, (HL)                 ; Load next ptr from free block 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      dec   HL 
1369			 
1369			      ld    (IX+0), E               ; Save ptr to next free block 
1369			      ld    (IX+1), D 
1369			      ld    (IX+2), L               ; Save ptr to prev free block 
1369			      ld    (IX+3), H 
1369			 
1369			      ld    A, B                    ; Check if DE is greater than BC 
1369			      cp    D                       ; Compare MSB first 
1369			      jr    Z, $+4                  ; MSB the same, compare LSB 
1369			      jr    NC, free_find_higher_block_skip 
1369			      ld    A, C 
1369			      cp    E                       ; Then compare LSB 
1369			      jr    C, free_found_higher_block 
1369			 
1369			free_find_higher_block_skip: 
1369			      ld    A, D                    ; Reached the end of the free list? 
1369			      or    E 
1369			      jp    Z, free_done 
1369			 
1369			      ex    DE, HL 
1369			 
1369			      jr    free_find_higher_block 
1369			 
1369			free_found_higher_block: 
1369			      ; Insert freed block between prev and next free blocks 
1369			      ld    (HL), C                 ; Point prev free block to freed block 
1369			      inc   HL 
1369			      ld    (HL), B 
1369			 
1369			      ld    H, B                    ; Point freed block at next free block 
1369			      ld    L, C 
1369			      ld    (HL), E 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			      ; Check if the freed block is adjacent to the next free block 
1369			      inc   HL                      ; Load size of freed block into HL 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      ex    DE, HL 
1369			 
1369			      add   HL, BC                  ; Add addr of freed block and its size 
1369			 
1369			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1369			      ld    D, (IX+1) 
1369			 
1369			      or    A                       ; Clear the carry flag 
1369			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1369			      jr    NZ, free_check_adjacent_to_prev 
1369			 
1369			      ; Freed block is adjacent to next, merge into one bigger block 
1369			      ex    DE, HL                  ; Load next ptr from next block into DE 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      push  HL                      ; Save ptr to next block for later 
1369			 
1369			      ld    H, B                    ; Store ptr from next block into freed block 
1369			      ld    L, C 
1369			      ld    (HL), E 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			      pop   HL                      ; Restore ptr to next block 
1369			      inc   HL                      ; Load size of next block into DE 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      push  DE                      ; Save next block size for later 
1369			 
1369			      ld    H, B                    ; Load size of freed block into HL 
1369			      ld    L, C 
1369			      inc   HL 
1369			      inc   HL 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      ex    DE, HL 
1369			 
1369			      pop   DE                      ; Restore size of next block 
1369			      add   HL, DE                  ; Add sizes of both blocks 
1369			      ex    DE, HL 
1369			 
1369			      ld    H, B                    ; Store new bigger size into freed block 
1369			      ld    L, C 
1369			      inc   HL 
1369			      inc   HL 
1369			      ld    (HL), E 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			free_check_adjacent_to_prev: 
1369			      ; Check if the freed block is adjacent to the prev free block 
1369			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1369			      ld    H, (IX+3) 
1369			 
1369			      inc   HL                      ; Size of prev free block into DE 
1369			      inc   HL 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      dec   HL 
1369			      dec   HL 
1369			      dec   HL 
1369			 
1369			      add   HL, DE                  ; Add prev block addr and size 
1369			 
1369			      or    A                       ; Clear the carry flag 
1369			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1369			      jr    NZ, free_done 
1369			 
1369			      ; Freed block is adjacent to prev, merge into one bigger block 
1369			      ld    H, B                    ; Load next ptr from freed block into DE 
1369			      ld    L, C 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      push  HL                      ; Save freed block ptr for later 
1369			 
1369			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1369			      ld    H, (IX+3) 
1369			      ld    (HL), E 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			      pop   HL                      ; Restore freed block ptr 
1369			      inc   HL                      ; Load size of freed block into DE 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      push  DE                      ; Save freed block size for later 
1369			 
1369			      ld    L, (IX+2)               ; Load size of prev block into DE 
1369			      ld    H, (IX+3) 
1369			      inc   HL 
1369			      inc   HL 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			 
1369			      pop   HL                      ; Add sizes of both blocks 
1369			      add   HL, DE 
1369			      ex    DE, HL 
1369			 
1369			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1369			      ld    H, (IX+3) 
1369			      inc   HL 
1369			      inc   HL 
1369			      ld    (HL), E 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			free_done: 
1369			      ld    HL, 4                   ; Clean up stack frame 
1369			      add   HL, SP 
1369			      ld    SP, HL 
1369			 
1369			free_early_exit: 
1369			      pop   IX 
1369			      pop   DE 
1369			      pop   BC 
1369			 
1369			      ret 
1369			 
1369			 
1369			;      .org 0x8000 
1369			; 
1369			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1369			 ;                 .dw   0 
1369			 
1369			endif 
1369			 
1369			 
1369			if MALLOC_4 
1369			 
1369			; My memory allocation code. Very very simple.... 
1369			; allocate space under 250 chars 
1369			 
1369			heap_init: 
1369				; init start of heap as zero 
1369				;  
1369			 
1369				ld hl, heap_start 
1369				ld a, 0 
1369				ld (hl), a      ; empty block 
1369				inc hl 
1369				ld a, 0 
1369				ld (hl), a      ; length of block 
1369				; write end of list 
1369				inc hl 
1369				ld a,(hl) 
1369				inc hl 
1369				ld a,(hl) 
1369				 
1369			 
1369				; init some malloc vars 
1369			 
1369				ld hl, 0 
1369				ld (free_list), hl       ; store last malloc location 
1369			 
1369				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1369				ld a, 0 
1369				ld (hl), a 
1369			 
1369			 
1369				ld hl, heap_start 
1369				;  
1369				  
1369				ret 
1369			 
1369			 
1369			;    free block marker 
1369			;    requested size  
1369			;    pointer to next block 
1369			;    .... 
1369			;    next block marker 
1369			 
1369			 
1369			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1369			; 
1369			 
1369			 
1369			malloc:  
1369				push de 
1369				push bc 
1369				push af 
1369			 
1369				; hl space required 
1369				 
1369				ld c, l    ; hold space   (TODO only a max of 255) 
1369			 
1369			;	inc c     ; TODO BUG need to fix memory leak on push str 
1369			;	inc c 
1369			;	inc c 
1369			;	inc c 
1369			;	inc c 
1369			;	inc c 
1369			;	inc c 
1369			 
1369			 
1369			 
1369				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1369			 
1369				ld a, (free_list+3) 
1369				cp 0 
1369				jr z, .contheap 
1369			 
1369				ld hl, (free_list)     ; get last alloc 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "mrs" 
1369						CALLMONITOR 
1369					endif 
1369				jr .startalloc 
1369			 
1369			.contheap: 
1369				ld hl, heap_start 
1369			 
1369			.startalloc: 
1369			 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "mym" 
1369						CALLMONITOR 
1369					endif 
1369			.findblock: 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "mmf" 
1369						CALLMONITOR 
1369					endif 
1369			 
1369				ld a,(hl)  
1369				; if byte is zero then clear to use 
1369			 
1369				cp 0 
1369				jr z, .foundemptyblock 
1369			 
1369				; if byte is not clear 
1369				;     then byte is offset to next block 
1369			 
1369				inc hl 
1369				ld a, (hl) ; get size 
1369			.nextblock:	inc hl 
1369					ld e, (hl) 
1369					inc hl 
1369					ld d, (hl) 
1369					ex de, hl 
1369			;	inc hl  ; move past the store space 
1369			;	inc hl  ; move past zero index  
1369			 
1369				; TODO detect no more space 
1369			 
1369				push hl 
1369				ld de, heap_end 
1369				call cmp16 
1369				pop hl 
1369				jr nc, .nospace 
1369			 
1369				jr .findblock 
1369			 
1369			.nospace: ld hl, 0 
1369				jp .exit 
1369			 
1369			 
1369			.foundemptyblock:	 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "mme" 
1369						CALLMONITOR 
1369					endif 
1369			 
1369			; TODO has block enough space if reusing??? 
1369			 
1369				;  
1369			 
1369			; see if this block has been previously used 
1369				inc hl 
1369				ld a, (hl) 
1369				dec hl 
1369				cp 0 
1369				jr z, .newblock 
1369			 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "meR" 
1369						CALLMONITOR 
1369					endif 
1369			 
1369			; no reusing previously allocated block 
1369			 
1369			; is it smaller than previously used? 
1369				 
1369				inc hl    ; move to size 
1369				ld a, c 
1369				sub (hl)        ; we want c < (hl) 
1369				dec hl    ; move back to marker 
1369			        jr z, .findblock 
1369			 
1369				; update with the new size which should be lower 
1369			 
1369			        ;inc  hl   ; negate next move. move back to size  
1369			 
1369			.newblock: 
1369				; need to be at marker here 
1369			 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "meN" 
1369						CALLMONITOR 
1369					endif 
1369			 
1369			 
1369				ld a, c 
1369			 
1369				ld (free_list+3), a	 ; flag resume from last malloc  
1369				ld (free_list), hl    ; save out last location 
1369			 
1369			 
1369				;inc a     ; space for length byte 
1369				ld (hl), a     ; save block in use marker 
1369			 
1369				inc hl   ; move to space marker 
1369				ld (hl), a    ; save new space 
1369			 
1369				inc hl   ; move to start of allocated area 
1369				 
1369			;	push hl     ; save where we are - 1  
1369			 
1369			;	inc hl  ; move past zero index  
1369				; skip space to set down new marker 
1369			 
1369				; provide some extra space for now 
1369			 
1369				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1369				inc a 
1369				inc a 
1369			 
1369				push hl   ; save where we are in the node block 
1369			 
1369				call addatohl 
1369			 
1369				; write linked list point 
1369			 
1369				pop de     ; get our node position 
1369				ex de, hl 
1369			 
1369				ld (hl), e 
1369				inc hl 
1369				ld (hl), d 
1369			 
1369				inc hl 
1369			 
1369				; now at start of allocated data so save pointer 
1369			 
1369				push hl 
1369			 
1369				; jump to position of next node and setup empty header in DE 
1369			 
1369				ex de, hl 
1369			 
1369			;	inc hl ; move past end of block 
1369			 
1369				ld a, 0 
1369				ld (hl), a   ; empty marker 
1369				inc hl 
1369				ld (hl), a   ; size 
1369				inc hl  
1369				ld (hl), a   ; ptr 
1369				inc hl 
1369				ld (hl), a   ; ptr 
1369			 
1369			 
1369				pop hl 
1369			 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "mmr" 
1369						CALLMONITOR 
1369					endif 
1369			 
1369			.exit: 
1369				pop af 
1369				pop bc 
1369				pop de  
1369				ret 
1369			 
1369			 
1369			 
1369			 
1369			free:  
1369				push hl 
1369				push af 
1369				; get address in hl 
1369			 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "fre" 
1369						CALLMONITOR 
1369					endif 
1369				; data is at hl - move to block count 
1369				dec hl 
1369				dec hl    ; get past pointer 
1369				dec hl 
1369			 
1369				ld a, (hl)    ; need this for a validation check 
1369			 
1369				dec hl    ; move to block marker 
1369			 
1369				; now check that the block count and block marker are the same  
1369			        ; this checks that we are on a malloc node and not random memory 
1369			        ; OK a faint chance this could be a problem but rare - famous last words! 
1369			 
1369				ld c, a 
1369				ld a, (hl)    
1369			 
1369				cp c 
1369				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1369			 
1369				; yes good chance we are on a malloc node 
1369			 
1369				ld a, 0      
1369				ld (hl), a   ; mark as free 
1369			 
1369				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1369			 
1369			.freeignore:  
1369			 
1369				pop af 
1369				pop hl 
1369			 
1369				ret 
1369			 
1369			 
1369			 
1369			endif 
1369			 
1369			; eof 
# End of file firmware_memory.asm
1369			  
1369			; device C  
1369			if SOUND_ENABLE  
1369				include "firmware_sound.asm"  
1369			; Sound abstraction layer 
1369			 
1369			; support different sound chips through common interface 
1369			 
1369			SOUND_DEVICE_AY: equ 0 
1369			 
1369			SOUND_DEVICE: equ Device_A 
1369			 
1369			 
1369			 
1369			if SOUND_DEVICE_AY 
1369				include "firmware_sound_ay38910.asm" 
1369			else 
1369				include "firmware_sound_sn76489an.asm" 
1369			 
1369			; Device support for SN76489AN sound chip 
1369			 
1369			; https://arduinoplusplus.wordpress.com/2019/10/05/making-noise-with-a-sn76489-digital-sound-generator-part-1/ 
1369			; http://danceswithferrets.org/geekblog/?p=93 
1369			; https://www.smspower.org/Development/SN76489 
1369			 
1369			; D0 [ 3] 
1369			; D1 [ 2] 
1369			; D2 [ 1] 
1369			; D3 [15] 
1369			; D4 [13] 
1369			; D5 [12] 
1369			; D6 [11] 
1369			; D7 [10] 
1369			; /WE [ 5] 
1369			; CLK [14] 
1369			; /OE [ 6] 
1369			; AUDIO [ 7] 
1369			; GND 8 
1369			; +5 16 
1369			; 
1369			 
1369			; Write sequence: 
1369			; CE low 
1369			; Data bus 
1369			; WE low then high 
1369			; 32 clock cycles / 8ns write time at 4mhz 
1369			; 
1369			; https://github.com/jblang/SN76489 
1369			; Shows that the clock needs to be enabled when required. Noticed that with the clock connected it interupted the bus 
1369			; Tried: 
1369			; 
1369			; CE/OE -> Both pins of NAND -> To one pin of second NAND and second pin to full clock -> CLK on chip 
1369			; 
1369			; Connected WE to OR too 
1369			;  
1369			; That enabled the clock when required 
1369			; However still random bus corruption. Need further investigation 
1369			 
1369			 
1369			SOUND_LATCH: equ 10000000B 
1369			SOUND_DATA: equ 0B 
1369			SOUND_CH0:  equ 0B    ; Tone 
1369			SOUND_CH1: equ 0100000B        ; Tone 
1369			SOUND_CH2: equ 1000000B   ; Tone 
1369			SOUND_CH3: equ 1100000B    ; Noise 
1369			SOUND_VOL: equ 10000B 
1369			SOUND_TONE: equ 0B 
1369			 
1369			 
1369			sound_init: 
1369 3e 1f			ld a, SOUND_DATA | SOUND_CH0 | SOUND_VOL | 1111B 
136b cd 80 13			call note_send_byte 
136e 3e 07			ld a, SOUND_DATA | SOUND_CH0 | SOUND_TONE | 0111B 
1370 cd 80 13			call note_send_byte 
1373 cd 49 0a			call delay250ms 
1376 3e 05			ld a, SOUND_DATA | SOUND_CH0 | SOUND_TONE | 0101B 
1378 cd 80 13			call note_send_byte 
137b cd 49 0a			call delay250ms 
137e c9				ret 
137f			 
137f			; Play a note 
137f			; h = note 
137f			; l = duration 
137f			; a = channel 
137f			 
137f			 
137f			;  frequ = clock / ( 2 x reg valu x 32 )  
137f			 
137f			note:  
137f				 
137f			 
137f c9				ret 
1380			 
1380			note_send_byte: 
1380				; byte in a 
1380			 
1380				; we high 
1380 d3 40			out (Device_B), a 
1382			;	ld a, 1 
1382			;	call aDelayInMS 
1382 00				nop  
1383 00				nop  
1384 00				nop  
1385 00				nop  
1386				; we low 
1386 d3 40			out (Device_B), a 
1388			;	ld a, 1 
1388			;	call aDelayInMS 
1388 00				nop  
1389 00				nop  
138a 00				nop  
138b 00				nop  
138c				; we high 
138c d3 40			out (Device_B), a 
138e			;	ld a, 1 
138e			;	call aDelayInMS 
138e 00				nop  
138f 00				nop  
1390 00				nop  
1391 00				nop  
1392			 
1392			 
1392 c9				ret 
1393			 
1393			;void SilenceAllChannels() 
1393			;{ 
1393			;  SendByte(0x9f); 
1393			;  SendByte(0xbf); 
1393			;  SendByte(0xdf); 
1393			;  SendByte(0xff); 
1393			;} 
1393			 
1393			 
1393			; eof 
1393			 
# End of file firmware_sound_sn76489an.asm
1393			endif 
1393			 
1393			 
1393			; Abstraction entry points 
1393			 
1393			; init  
1393			 
1393			; sound_init in specific hardware files 
1393			 
1393			; Play a note 
1393			; h = note 
1393			; l = duration 
1393			; a = channel 
1393			 
1393			;note:     
1393			;	ret 
1393			 
1393			 
1393			 
1393			 
1393			; eof 
1393			 
# End of file firmware_sound.asm
1393			endif  
1393			  
1393			include "firmware_diags.asm"  
1393			; Hardware diags menu 
1393			 
1393			 
1393			config: 
1393			 
1393 3e 00			ld a, 0 
1395 21 c3 13			ld hl, .configmn 
1398 cd 06 0b			call menu 
139b			 
139b fe 00			cp 0 
139d c8				ret z 
139e			 
139e fe 01			cp 1 
13a0 cc 34 15			call z, .savetostore 
13a3			 
13a3 fe 02			cp 2 
13a5 cc 82 14			call z, .selautoload 
13a8 fe 03			cp 3 
13aa cc 6b 14			call z, .disautoload 
13ad fe 04			cp 4 
13af cc 32 15			call z, .selbank 
13b2 fe 06			cp 6 
13b4 cc 0f 16			call z, .debug_tog 
13b7 fe 07			cp 7 
13b9 cc 57 17			call z, .bpsgo 
13bc fe 08			cp 8 
13be cc 35 16			call z, hardware_diags 
13c1			 
13c1 18 d0			jr config 
13c3			 
13c3			.configmn: 
13c3 d5 13			dw .c3 
13c5 f1 13			dw .c2 
13c7 06 14			dw .c2a 
13c9 1c 14			dw .c2b 
13cb 30 14			dw .c4 
13cd 39 14			dw .m4 
13cf 54 14			dw .m4b 
13d1 5c 14			dw .c1 
13d3 00 00			dw 0 
13d5				 
13d5			 
13d5 .. 00		.c3: db "Add User Dictionary To File",0 
13f1 .. 00		.c2: db "Select Autoload File",0 
1406 .. 00		.c2a: db "Disable Autoload File", 0 
141c .. 00		.c2b: db "Select Storage Bank",0 
1430 .. 00		.c4: db "Settings",0 
1439 .. 00		.m4:   db "Debug & Breakpoints On/Off",0 
1454 .. 00		.m4b:   db "Monitor",0 
145c .. 00		.c1: db "Hardware Diags",0 
146b			 
146b			 
146b			.disautoload: 
146b				if STORAGE_SE 
146b 3e fe			ld a, $fe      ; bit 0 clear 
146d 32 48 f8			ld (spi_device), a 
1470			 
1470 cd bd 03			call storage_get_block_0 
1473			 
1473 3e 00			ld a, 0 
1475 32 83 f8			ld (store_page+STORE_0_AUTOFILE), a 
1478			 
1478 21 00 00				ld hl, 0 
147b 11 62 f8				ld de, store_page 
147e cd 71 03			call storage_write_block	 ; save update 
1481				endif 
1481			 
1481			 
1481 c9				ret 
1482			 
1482			 
1482			 
1482			; Select auto start 
1482			 
1482			.selautoload: 
1482			 
1482				 
1482				if STORAGE_SE 
1482			 
1482 cd 59 15				call config_dir 
1485 21 1d ee			        ld hl, scratch 
1488 3e 00				ld a, 0 
148a cd 06 0b				call menu 
148d			 
148d fe 00				cp 0 
148f c8					ret z 
1490			 
1490 3d					dec a 
1491			 
1491			 
1491					; locate menu option 
1491			 
1491 21 1d ee				ld hl, scratch 
1494 cd 2d 0a				call table_lookup 
1497			 
1497					if DEBUG_FORTH_WORDS 
1497						DMARK "ALl" 
1497 f5				push af  
1498 3a ac 14			ld a, (.dmark)  
149b 32 77 fb			ld (debug_mark),a  
149e 3a ad 14			ld a, (.dmark+1)  
14a1 32 78 fb			ld (debug_mark+1),a  
14a4 3a ae 14			ld a, (.dmark+2)  
14a7 32 79 fb			ld (debug_mark+2),a  
14aa 18 03			jr .pastdmark  
14ac ..			.dmark: db "ALl"  
14af f1			.pastdmark: pop af  
14b0			endm  
# End of macro DMARK
14b0						CALLMONITOR 
14b0 cd 4d 17			call break_point_state  
14b3				endm  
# End of macro CALLMONITOR
14b3					endif 
14b3					; with the pointer to the menu it, the byte following the zero term is the file id 
14b3			 
14b3 3e 00				ld a, 0 
14b5 01 32 00				ld bc, 50   ; max of bytes to look at 
14b8 ed b1				cpir  
14ba			 
14ba					if DEBUG_FORTH_WORDS 
14ba						DMARK "ALb" 
14ba f5				push af  
14bb 3a cf 14			ld a, (.dmark)  
14be 32 77 fb			ld (debug_mark),a  
14c1 3a d0 14			ld a, (.dmark+1)  
14c4 32 78 fb			ld (debug_mark+1),a  
14c7 3a d1 14			ld a, (.dmark+2)  
14ca 32 79 fb			ld (debug_mark+2),a  
14cd 18 03			jr .pastdmark  
14cf ..			.dmark: db "ALb"  
14d2 f1			.pastdmark: pop af  
14d3			endm  
# End of macro DMARK
14d3						CALLMONITOR 
14d3 cd 4d 17			call break_point_state  
14d6				endm  
# End of macro CALLMONITOR
14d6					endif 
14d6					;inc hl 
14d6			 
14d6 7e					ld a, (hl)   ; file id 
14d7					 
14d7				        ; save bank and file ids 
14d7			 
14d7 f5					push af 
14d8			 
14d8			; TODO need to save to block 0 on bank 1	 
14d8			 
14d8 cd bd 03				call storage_get_block_0 
14db			 
14db					if DEBUG_FORTH_WORDS 
14db						DMARK "AL0" 
14db f5				push af  
14dc 3a f0 14			ld a, (.dmark)  
14df 32 77 fb			ld (debug_mark),a  
14e2 3a f1 14			ld a, (.dmark+1)  
14e5 32 78 fb			ld (debug_mark+1),a  
14e8 3a f2 14			ld a, (.dmark+2)  
14eb 32 79 fb			ld (debug_mark+2),a  
14ee 18 03			jr .pastdmark  
14f0 ..			.dmark: db "AL0"  
14f3 f1			.pastdmark: pop af  
14f4			endm  
# End of macro DMARK
14f4						CALLMONITOR 
14f4 cd 4d 17			call break_point_state  
14f7				endm  
# End of macro CALLMONITOR
14f7					endif 
14f7 f1					pop af 
14f8			 
14f8 32 86 f8				ld (store_page+STORE_0_FILERUN),a 
14fb					 
14fb					; save bank id 
14fb			 
14fb 3a 48 f8				ld a,(spi_device) 
14fe 32 85 f8				ld (store_page+STORE_0_BANKRUN),a 
1501			 
1501					; enable auto run of store file 
1501			 
1501 3e 01				ld a, 1 
1503 32 83 f8				ld (store_page+STORE_0_AUTOFILE),a 
1506			 
1506					; save buffer 
1506			 
1506 21 00 00				ld hl, 0 
1509 11 62 f8				ld de, store_page 
150c					if DEBUG_FORTH_WORDS 
150c						DMARK "ALw" 
150c f5				push af  
150d 3a 21 15			ld a, (.dmark)  
1510 32 77 fb			ld (debug_mark),a  
1513 3a 22 15			ld a, (.dmark+1)  
1516 32 78 fb			ld (debug_mark+1),a  
1519 3a 23 15			ld a, (.dmark+2)  
151c 32 79 fb			ld (debug_mark+2),a  
151f 18 03			jr .pastdmark  
1521 ..			.dmark: db "ALw"  
1524 f1			.pastdmark: pop af  
1525			endm  
# End of macro DMARK
1525						CALLMONITOR 
1525 cd 4d 17			call break_point_state  
1528				endm  
# End of macro CALLMONITOR
1528					endif 
1528 cd 71 03			call storage_write_block	 ; save update 
152b			  
152b			 
152b			 
152b			 
152b 21 1d ee				ld hl, scratch 
152e cd 46 15				call config_fdir 
1531			 
1531			 
1531				endif 
1531 c9				ret 
1532			 
1532			 
1532			 
1532			; Select storage bank 
1532			 
1532			.selbank: 
1532			 
1532				if STORAGE_SE 
1532				endif 
1532				 
1532 c9				ret 
1533			 
1533			if STORAGE_SE 
1533			 
1533			.config_ldir:   
1533				; Load storage bank labels into menu array 
1533			 
1533				 
1533			 
1533			 
1533 c9				ret 
1534			 
1534			 
1534			endif 
1534			 
1534			 
1534			; Save user words to storage 
1534			 
1534			.savetostore: 
1534			 
1534				if STORAGE_SE 
1534			 
1534 cd 59 15				call config_dir 
1537 21 1d ee			        ld hl, scratch 
153a 3e 00				ld a, 0 
153c cd 06 0b				call menu 
153f					 
153f 21 1d ee				ld hl, scratch 
1542 cd 46 15				call config_fdir 
1545			 
1545			 
1545				endif 
1545			 
1545 c9				ret 
1546			 
1546			 
1546			 
1546			if STORAGE_SE 
1546			 
1546			config_fdir: 
1546				; using the scratch dir go through and release the memory allocated for each string 
1546				 
1546 21 1d ee			ld hl, scratch 
1549 5e			.cfdir:	ld e,(hl) 
154a 23				inc hl 
154b 56				ld d,(hl) 
154c 23				inc hl 
154d			 
154d eb				ex de, hl 
154e cd 32 0d			call ishlzero 
1551 c8				ret z     ; return on null pointer 
1552 cd 9a 12			call free 
1555 eb				ex de, hl 
1556 18 f1			jr .cfdir 
1558			 
1558			 
1558 c9				ret 
1559			 
1559			 
1559			config_dir: 
1559			 
1559				; for the config menus that need to build a directory of storage call this routine 
1559				; it will construct a menu in scratch to pass to menu 
1559			 
1559				; open storage device 
1559			 
1559				; execute DIR to build a list of files and their ids into scratch in menu format 
1559				; once the menu has finished then will need to call config_fdir to release the strings 
1559				 
1559				; c = number items 
1559			 
1559				 
1559 cd bd 03			call storage_get_block_0 
155c			 
155c 21 62 f8			ld hl, store_page     ; get current id count 
155f 46				ld b, (hl) 
1560 0e 00			ld c, 0    ; count of files   
1562			 
1562			 
1562 21 1d ee			ld hl, scratch 
1565 22 5e f8			ld (store_tmp2), hl    ; location to poke strings 
1568			 
1568				; check for empty drive 
1568			 
1568 3e 00			ld a, 0 
156a b8				cp b 
156b ca 05 16			jp z, .dirdone 
156e			 
156e				 
156e					if DEBUG_FORTH_WORDS 
156e						DMARK "Cdc" 
156e f5				push af  
156f 3a 83 15			ld a, (.dmark)  
1572 32 77 fb			ld (debug_mark),a  
1575 3a 84 15			ld a, (.dmark+1)  
1578 32 78 fb			ld (debug_mark+1),a  
157b 3a 85 15			ld a, (.dmark+2)  
157e 32 79 fb			ld (debug_mark+2),a  
1581 18 03			jr .pastdmark  
1583 ..			.dmark: db "Cdc"  
1586 f1			.pastdmark: pop af  
1587			endm  
# End of macro DMARK
1587						CALLMONITOR 
1587 cd 4d 17			call break_point_state  
158a				endm  
# End of macro CALLMONITOR
158a					endif 
158a			 
158a			 
158a			.diritem:	 
158a c5				push bc 
158b				; for each of the current ids do a search for them and if found push to stack 
158b			 
158b 21 40 00				ld hl, STORE_BLOCK_PHY 
158e 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
1590 58					ld e,b 
1591			 
1591 cd 2d 06				call storage_findnextid 
1594			 
1594			 
1594					; if found hl will be non zero 
1594			 
1594 cd 32 0d				call ishlzero 
1597 28 69				jr z, .dirnotfound 
1599			 
1599					; increase count 
1599			 
1599 c1					pop bc	 
159a 0c					inc c 
159b c5					push bc 
159c					 
159c			 
159c					; get file header and push the file name 
159c			 
159c 11 62 f8				ld de, store_page 
159f cd 0c 03				call storage_read_block 
15a2			 
15a2					; push file id to stack 
15a2				 
15a2 3a 62 f8				ld a, (store_page) 
15a5 26 00				ld h, 0 
15a7 6f					ld l, a 
15a8			 
15a8					;call forth_push_numhl 
15a8					; TODO store id 
15a8			 
15a8 e5					push hl 
15a9			 
15a9					; push extent count to stack  
15a9				 
15a9 21 65 f8				ld hl, store_page+3 
15ac			 
15ac					; get file name length 
15ac			 
15ac cd 67 11				call strlenz   
15af			 
15af 23					inc hl   ; cover zero term 
15b0 23					inc hl  ; stick the id at the end of the area 
15b1			 
15b1 e5					push hl 
15b2 c1					pop bc    ; move length to bc 
15b3			 
15b3 cd d0 11				call malloc 
15b6			 
15b6					; TODO save malloc area to scratch 
15b6			 
15b6 eb					ex de, hl 
15b7 2a 5e f8				ld hl, (store_tmp2) 
15ba 73					ld (hl), e 
15bb 23					inc hl 
15bc 72					ld (hl), d 
15bd 23					inc hl 
15be 22 5e f8				ld (store_tmp2), hl 
15c1			 
15c1					 
15c1			 
15c1					;pop hl   ; get source 
15c1			;		ex de, hl    ; swap aronund	 
15c1			 
15c1 21 65 f8				ld hl, store_page+3 
15c4					if DEBUG_FORTH_WORDS 
15c4						DMARK "CFd" 
15c4 f5				push af  
15c5 3a d9 15			ld a, (.dmark)  
15c8 32 77 fb			ld (debug_mark),a  
15cb 3a da 15			ld a, (.dmark+1)  
15ce 32 78 fb			ld (debug_mark+1),a  
15d1 3a db 15			ld a, (.dmark+2)  
15d4 32 79 fb			ld (debug_mark+2),a  
15d7 18 03			jr .pastdmark  
15d9 ..			.dmark: db "CFd"  
15dc f1			.pastdmark: pop af  
15dd			endm  
# End of macro DMARK
15dd						CALLMONITOR 
15dd cd 4d 17			call break_point_state  
15e0				endm  
# End of macro CALLMONITOR
15e0					endif 
15e0 ed b0				ldir 
15e2			 
15e2					; de is past string, move back one and store id 
15e2					 
15e2 1b					dec de 
15e3			 
15e3					; store file id 
15e3			 
15e3 e1					pop hl 
15e4 eb					ex de,hl 
15e5 73					ld (hl), e 
15e6			 
15e6					if DEBUG_FORTH_WORDS 
15e6						DMARK "Cdi" 
15e6 f5				push af  
15e7 3a fb 15			ld a, (.dmark)  
15ea 32 77 fb			ld (debug_mark),a  
15ed 3a fc 15			ld a, (.dmark+1)  
15f0 32 78 fb			ld (debug_mark+1),a  
15f3 3a fd 15			ld a, (.dmark+2)  
15f6 32 79 fb			ld (debug_mark+2),a  
15f9 18 03			jr .pastdmark  
15fb ..			.dmark: db "Cdi"  
15fe f1			.pastdmark: pop af  
15ff			endm  
# End of macro DMARK
15ff						CALLMONITOR 
15ff cd 4d 17			call break_point_state  
1602				endm  
# End of macro CALLMONITOR
1602					endif 
1602					 
1602			.dirnotfound: 
1602 c1					pop bc     
1603 10 85				djnz .diritem 
1605				 
1605			.dirdone:	 
1605			 
1605 3e 00				ld a, 0 
1607 2a 5e f8				ld hl, (store_tmp2) 
160a 77					ld (hl), a 
160b 23					inc hl 
160c 77					ld (hl), a 
160d 23					inc hl 
160e					; push a count of the dir items found 
160e			 
160e			;		ld h, 0 
160e			;		ld l, c 
160e			 
160e c9				ret 
160f			 
160f			endif 
160f			 
160f			 
160f			; Settings 
160f			; Run  
160f			 
160f			 
160f			 
160f			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
160f			;;hd_menu2:   db "        2: Editor",0   
160f			;hd_menu2:   db "        2: Editor       6: Menu",0   
160f			;hd_menu3:   db "        3: Storage",0 
160f			;hd_menu4:   db "0=quit  4: Debug",0 
160f			;hd_don:     db "ON",0 
160f			;hd_doff:     db "OFF",0 
160f			; 
160f			; 
160f			; 
160f			;hardware_diags_old:       
160f			; 
160f			;.diagmenu: 
160f			;	call clear_display 
160f			;	ld a, display_row_1 
160f			;	ld de, hd_menu1 
160f			;	call str_at_display 
160f			; 
160f			;	ld a, display_row_2 
160f			;	ld de, hd_menu2 
160f			;	call str_at_display 
160f			; 
160f			;	ld a, display_row_3 
160f			;	ld de, hd_menu3 
160f			;	call str_at_display 
160f			; 
160f			;	ld a,  display_row_4 
160f			;	ld de, hd_menu4 
160f			;	call str_at_display 
160f			; 
160f			;	; display debug state 
160f			; 
160f			;	ld de, hd_don 
160f			;	ld a, (os_view_disable) 
160f			;	cp 0 
160f			;	jr z, .distog 
160f			;	ld de, hd_doff 
160f			;.distog: ld a, display_row_4+17 
160f			;	call str_at_display 
160f			; 
160f			;	call update_display 
160f			; 
160f			;	call cin_wait 
160f			; 
160f			; 
160f			; 
160f			;	cp '4' 
160f			;	jr nz, .diagn1 
160f			; 
160f			;	; debug toggle 
160f			; 
160f			;	ld a, (os_view_disable) 
160f			;	ld b, '*' 
160f			;	cp 0 
160f			;	jr z, .debtog 
160f			;	ld b, 0 
160f			;.debtog:	 
160f			;	ld a,b 
160f			;	ld (os_view_disable),a 
160f			; 
160f			;.diagn1: cp '0' 
160f			;	 ret z 
160f			; 
160f			;;	cp '1' 
160f			;;       jp z, matrix	 
160f			;;   TODO keyboard matrix test 
160f			; 
160f			;	cp '2' 
160f			;	jp z, .diagedit 
160f			; 
160f			;;	cp '6' 
160f			;;	jp z, .menutest 
160f			;;if ENABLE_BASIC 
160f			;;	cp '6' 
160f			;;	jp z, basic 
160f			;;endif 
160f			 ; 
160f			;	jp .diagmenu 
160f			; 
160f			; 
160f			;	ret 
160f			 
160f			 
160f			.debug_tog: 
160f 21 56 16			ld hl, .menudebug 
1612				 
1612 3a 0e ee			ld a, (os_view_disable) 
1615 fe 2a			cp '*' 
1617 20 04			jr nz,.tdon  
1619 3e 01			ld a, 1 
161b 18 02			jr .tog1 
161d 3e 00		.tdon: ld a, 0 
161f			 
161f			.tog1: 
161f cd 06 0b			call menu 
1622 fe 00			cp 0 
1624 c8				ret z 
1625 fe 01			cp 1    ; disable debug 
1627 28 04			jr z, .dtog0 
1629 3e 2a			ld a, '*' 
162b 18 02			jr .dtogset 
162d 3e 00		.dtog0: ld a, 0 
162f 32 0e ee		.dtogset:  ld (os_view_disable), a 
1632 c3 0f 16			jp .debug_tog 
1635			 
1635			 
1635			hardware_diags:       
1635			 
1635			.diagm: 
1635 21 48 16			ld hl, .menuitems 
1638 3e 00			ld a, 0 
163a cd 06 0b			call menu 
163d			 
163d fe 00		         cp 0 
163f c8				 ret z 
1640			 
1640 fe 02			cp 2 
1642 ca a1 16			jp z, .diagedit 
1645			 
1645			;	cp '6' 
1645			;	jp z, .menutest 
1645			;if ENABLE_BASIC 
1645			;	cp '6' 
1645			;	jp z, basic 
1645			;endif 
1645			  
1645 c3 35 16			jp .diagm 
1648			 
1648				 
1648 5c 16		.menuitems:   	dw .m1 
164a 67 16				dw .m2 
164c 6e 16				dw .m3 
164e 76 16				dw .m5 
1650 7c 16				dw .m5a 
1652 85 16				dw .m5b 
1654 00 00				dw 0 
1656			 
1656			.menudebug: 
1656 8e 16				dw .m6 
1658 97 16				dw .m7 
165a 00 00				dw 0 
165c			 
165c .. 00		.m1:   db "Key Matrix",0 
1667 .. 00		.m2:   db "Editor",0 
166e .. 00		.m3:   db "Storage",0 
1676 .. 00		.m5:   db "Sound",0 
167c .. 00		.m5a:  db "RAM Test",0 
1685 .. 00		.m5b:  db "LCD Test",0 
168e			 
168e .. 00		.m6:   db "Debug ON",0 
1697 .. 00		.m7:   db "Debug OFF",0 
16a1			 
16a1			; debug editor 
16a1			 
16a1			.diagedit: 
16a1			 
16a1 21 1d ee			ld hl, scratch 
16a4			;	ld bc, 250 
16a4			;	ldir 
16a4				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
16a4 3e 00			ld a, 0 
16a6 77				ld (hl), a 
16a7 23				inc hl 
16a8 77				ld (hl), a 
16a9 23				inc hl 
16aa 77				ld (hl), a 
16ab			 
16ab cd d5 0a		        call clear_display 
16ae cd f8 0a			call update_display 
16b1 3e 01			ld a, 1 
16b3 32 7d fb			ld (hardware_diag), a 
16b6			.diloop: 
16b6 3e 00			ld a, display_row_1 
16b8 0e 00			ld c, 0 
16ba 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
16bc 1e 28			ld e, 40 
16be			 
16be 21 1d ee			ld hl, scratch	 
16c1 cd 36 0d			call input_str 
16c4			 
16c4 3e 28			ld a, display_row_2 
16c6 11 1d ee			ld de, scratch 
16c9 cd e8 0a			call str_at_display 
16cc cd f8 0a			call update_display 
16cf			 
16cf c3 b6 16			jp .diloop 
16d2			 
16d2			 
16d2			; pass word in hl 
16d2			; a has display location 
16d2			display_word_at: 
16d2 f5				push af 
16d3 e5				push hl 
16d4 7c				ld a,h 
16d5 21 22 f1			ld hl, os_word_scratch 
16d8 cd 0a 10			call hexout 
16db e1				pop hl 
16dc 7d				ld a,l 
16dd 21 24 f1			ld hl, os_word_scratch+2 
16e0 cd 0a 10			call hexout 
16e3 21 26 f1			ld hl, os_word_scratch+4 
16e6 3e 00			ld a,0 
16e8 77				ld (hl),a 
16e9 11 22 f1			ld de,os_word_scratch 
16ec f1				pop af 
16ed cd e8 0a				call str_at_display 
16f0 c9				ret 
16f1			 
16f1			display_ptr_state: 
16f1			 
16f1				; to restore afterwards 
16f1			 
16f1 d5				push de 
16f2 c5				push bc 
16f3 e5				push hl 
16f4 f5				push af 
16f5			 
16f5				; for use in here 
16f5			 
16f5			;	push bc 
16f5			;	push de 
16f5			;	push hl 
16f5			;	push af 
16f5			 
16f5 cd d5 0a			call clear_display 
16f8			 
16f8 11 cb 18			ld de, .ptrstate 
16fb 3e 00			ld a, display_row_1 
16fd cd e8 0a			call str_at_display 
1700			 
1700				; display debug step 
1700			 
1700			 
1700 11 77 fb			ld de, debug_mark 
1703 3e 26			ld a, display_row_1+display_cols-2 
1705 cd e8 0a			call str_at_display 
1708			 
1708				; display a 
1708 11 d5 18			ld de, .ptrcliptr 
170b 3e 28			ld a, display_row_2 
170d cd e8 0a			call str_at_display 
1710			 
1710 f1				pop af 
1711 2a 28 f8			ld hl,(cli_ptr) 
1714 3e 30			ld a, display_row_2+8 
1716 cd d2 16			call display_word_at 
1719			 
1719			 
1719				; display hl 
1719			 
1719			 
1719 11 dd 18			ld de, .ptrclioptr 
171c 3e 32			ld a, display_row_2+10 
171e cd e8 0a			call str_at_display 
1721			; 
1721			;	pop hl 
1721 3e 35			ld a, display_row_2+13 
1723 2a 26 f8			ld hl,(cli_origptr) 
1726 cd d2 16			call display_word_at 
1729			; 
1729			;	 
1729			;	; display de 
1729			 
1729			;	ld de, .regstatede 
1729			;	ld a, display_row_3 
1729			;	call str_at_display 
1729			 
1729			;	pop de 
1729			;	ld h,d 
1729			;	ld l, e 
1729			;	ld a, display_row_3+3 
1729			;	call display_word_at 
1729			 
1729			 
1729				; display bc 
1729			 
1729			;	ld de, .regstatebc 
1729			;	ld a, display_row_3+10 
1729			;	call str_at_display 
1729			 
1729			;	pop bc 
1729			;	ld h,b 
1729			;	ld l, c 
1729			;	ld a, display_row_3+13 
1729			;	call display_word_at 
1729			 
1729			 
1729				; display dsp 
1729			 
1729			;	ld de, .regstatedsp 
1729			;	ld a, display_row_4 
1729			;	call str_at_display 
1729			 
1729				 
1729			;	ld hl,(cli_data_sp) 
1729			;	ld a, display_row_4+4 
1729			;	call display_word_at 
1729			 
1729				; display rsp 
1729			 
1729 11 0c 19			ld de, .regstatersp 
172c 3e 82			ld a, display_row_4+10 
172e cd e8 0a			call str_at_display 
1731			 
1731				 
1731 2a 0e f8			ld hl,(cli_ret_sp) 
1734 3e 86			ld a, display_row_4+14 
1736 cd d2 16			call display_word_at 
1739			 
1739 cd f8 0a			call update_display 
173c			 
173c cd 55 0a			call delay1s 
173f cd 55 0a			call delay1s 
1742 cd 55 0a			call delay1s 
1745			 
1745			 
1745 cd 55 1c			call next_page_prompt 
1748			 
1748				; restore  
1748			 
1748 f1				pop af 
1749 e1				pop hl 
174a c1				pop bc 
174b d1				pop de 
174c c9				ret 
174d			 
174d			break_point_state: 
174d f5				push af 
174e			 
174e				; see if disabled 
174e			 
174e 3a 0e ee			ld a, (os_view_disable) 
1751 fe 2a			cp '*' 
1753 20 02			jr nz, .bpsgo 
1755 f1				pop af 
1756 c9				ret 
1757			 
1757			.bpsgo: 
1757 f1				pop af 
1758 f5				push af 
1759 22 0a ee			ld (os_view_hl), hl 
175c ed 53 08 ee		ld (os_view_de), de 
1760 ed 43 06 ee		ld (os_view_bc), bc 
1764 e5				push hl 
1765 6f				ld l, a 
1766 26 00			ld h, 0 
1768 22 0c ee			ld (os_view_af),hl 
176b			 
176b 21 bd fa				ld hl, display_fb0 
176e 22 d8 f8				ld (display_fb_active), hl 
1771 e1				pop hl	 
1772			 
1772 3e 31			ld a, '1' 
1774 fe 2a		.bps1:  cp '*' 
1776 20 03			jr nz, .bps1b 
1778 32 0e ee			ld (os_view_disable),a 
177b fe 31		.bps1b:  cp '1' 
177d 20 14			jr nz, .bps2 
177f			 
177f				; display reg 
177f			 
177f				 
177f			 
177f 3a 0c ee			ld a, (os_view_af) 
1782 2a 0a ee			ld hl, (os_view_hl) 
1785 ed 5b 08 ee		ld de, (os_view_de) 
1789 ed 4b 06 ee		ld bc, (os_view_bc) 
178d cd 27 18			call display_reg_state 
1790 c3 13 18			jp .bpschk 
1793			 
1793 fe 32		.bps2:  cp '2' 
1795 20 08			jr nz, .bps3 
1797				 
1797				; display hl 
1797 2a 0a ee			ld hl, (os_view_hl) 
179a cd 11 19			call display_dump_at_hl 
179d			 
179d 18 74			jr .bpschk 
179f			 
179f fe 33		.bps3:  cp '3' 
17a1 20 08			jr nz, .bps4 
17a3			 
17a3			        ; display de 
17a3 2a 08 ee			ld hl, (os_view_de) 
17a6 cd 11 19			call display_dump_at_hl 
17a9			 
17a9 18 68			jr .bpschk 
17ab fe 34		.bps4:  cp '4' 
17ad 20 08			jr nz, .bps5 
17af			 
17af			        ; display bc 
17af 2a 06 ee			ld hl, (os_view_bc) 
17b2 cd 11 19			call display_dump_at_hl 
17b5			 
17b5 18 5c			jr .bpschk 
17b7 fe 35		.bps5:  cp '5' 
17b9 20 08		        jr nz, .bps7 
17bb			 
17bb				; display cur ptr 
17bb 2a 28 f8			ld hl, (cli_ptr) 
17be cd 11 19			call display_dump_at_hl 
17c1			 
17c1 18 50			jr .bpschk 
17c3 fe 36		.bps7:  cp '6' 
17c5 20 08			jr nz, .bps8b 
17c7				 
17c7				; display cur orig ptr 
17c7 2a 26 f8			ld hl, (cli_origptr) 
17ca cd 11 19			call display_dump_at_hl 
17cd 18 44			jr .bpschk 
17cf fe 37		.bps8b:  cp '7' 
17d1 20 08			jr nz, .bps9 
17d3				 
17d3				; display dsp 
17d3 2a 0a f8			ld hl, (cli_data_sp) 
17d6 cd 11 19			call display_dump_at_hl 
17d9			 
17d9 18 38			jr .bpschk 
17db fe 39		.bps9:  cp '9' 
17dd 20 05			jr nz, .bps8c 
17df				 
17df				; display SP 
17df			;	ld hl, sp 
17df cd 11 19			call display_dump_at_hl 
17e2			 
17e2 18 2f			jr .bpschk 
17e4 fe 38		.bps8c:  cp '8' 
17e6 20 08			jr nz, .bps8d 
17e8				 
17e8				; display rsp 
17e8 2a 0e f8			ld hl, (cli_ret_sp) 
17eb cd 11 19			call display_dump_at_hl 
17ee			 
17ee 18 23			jr .bpschk 
17f0 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
17f2 20 05			jr nz, .bps8 
17f4 cd 4b 1a			call monitor 
17f7			 
17f7 18 1a			jr .bpschk 
17f9 fe 30		.bps8:  cp '0' 
17fb 20 16			jr nz, .bpschk 
17fd			 
17fd 21 1c fa				ld hl, display_fb1 
1800 22 d8 f8				ld (display_fb_active), hl 
1803 cd f8 0a				call update_display 
1806			 
1806				;ld a, (os_view_af) 
1806 2a 0a ee			ld hl, (os_view_hl) 
1809 ed 5b 08 ee		ld de, (os_view_de) 
180d ed 4b 06 ee		ld bc, (os_view_bc) 
1811 f1				pop af 
1812 c9				ret 
1813			 
1813			.bpschk:   
1813 cd 55 0a			call delay1s 
1816 3e 9f		ld a,display_row_4 + display_cols - 1 
1818 11 53 1c		        ld de, endprg 
181b cd e8 0a			call str_at_display 
181e cd f8 0a			call update_display 
1821 cd b5 68			call cin_wait 
1824			 
1824 c3 74 17			jp .bps1 
1827			 
1827			 
1827			display_reg_state: 
1827			 
1827				; to restore afterwards 
1827			 
1827 d5				push de 
1828 c5				push bc 
1829 e5				push hl 
182a f5				push af 
182b			 
182b				; for use in here 
182b			 
182b c5				push bc 
182c d5				push de 
182d e5				push hl 
182e f5				push af 
182f			 
182f cd d5 0a			call clear_display 
1832			 
1832 11 e7 18			ld de, .regstate 
1835 3e 00			ld a, display_row_1 
1837 cd e8 0a			call str_at_display 
183a			 
183a				; display debug step 
183a			 
183a			 
183a 11 77 fb			ld de, debug_mark 
183d 3e 25			ld a, display_row_1+display_cols-3 
183f cd e8 0a			call str_at_display 
1842			 
1842				; display a 
1842 11 03 19			ld de, .regstatea 
1845 3e 28			ld a, display_row_2 
1847 cd e8 0a			call str_at_display 
184a			 
184a e1				pop hl 
184b			;	ld h,0 
184b			;	ld l, a 
184b 3e 2b			ld a, display_row_2+3 
184d cd d2 16			call display_word_at 
1850			 
1850			 
1850				; display hl 
1850			 
1850			 
1850 11 f7 18			ld de, .regstatehl 
1853 3e 32			ld a, display_row_2+10 
1855 cd e8 0a			call str_at_display 
1858			 
1858 e1				pop hl 
1859 3e 35			ld a, display_row_2+13 
185b cd d2 16			call display_word_at 
185e			 
185e				 
185e				; display de 
185e			 
185e 11 fb 18			ld de, .regstatede 
1861 3e 50			ld a, display_row_3 
1863 cd e8 0a			call str_at_display 
1866			 
1866 e1				pop hl 
1867			;	ld h,d 
1867			;	ld l, e 
1867 3e 53			ld a, display_row_3+3 
1869 cd d2 16			call display_word_at 
186c			 
186c			 
186c				; display bc 
186c			 
186c 11 ff 18			ld de, .regstatebc 
186f 3e 5a			ld a, display_row_3+10 
1871 cd e8 0a			call str_at_display 
1874			 
1874 e1				pop hl 
1875			;	ld h,b 
1875			;	ld l, c 
1875 3e 5d			ld a, display_row_3+13 
1877 cd d2 16			call display_word_at 
187a			 
187a			 
187a				; display dsp 
187a			 
187a 11 07 19			ld de, .regstatedsp 
187d 3e 78			ld a, display_row_4 
187f cd e8 0a			call str_at_display 
1882			 
1882				 
1882 2a 0a f8			ld hl,(cli_data_sp) 
1885 3e 7c			ld a, display_row_4+4 
1887 cd d2 16			call display_word_at 
188a			 
188a				; display rsp 
188a			 
188a 11 0c 19			ld de, .regstatersp 
188d 3e 82			ld a, display_row_4+10 
188f cd e8 0a			call str_at_display 
1892			 
1892				 
1892 2a 0e f8			ld hl,(cli_ret_sp) 
1895 3e 86			ld a, display_row_4+14 
1897 cd d2 16			call display_word_at 
189a			 
189a cd f8 0a			call update_display 
189d			 
189d			;	call delay1s 
189d			;	call delay1s 
189d			;	call delay1s 
189d			 
189d			 
189d			;	call next_page_prompt 
189d			 
189d				; restore  
189d			 
189d f1				pop af 
189e e1				pop hl 
189f c1				pop bc 
18a0 d1				pop de 
18a1 c9				ret 
18a2			 
18a2 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
18b6 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
18cb .. 00		.ptrstate:	db "Ptr State",0 
18d5 .. 00		.ptrcliptr:     db "cli_ptr",0 
18dd .. 00		.ptrclioptr:     db "cli_o_ptr",0 
18e7 .. 00		.regstate:	db "Reg State (1/0)",0 
18f7 .. 00		.regstatehl:	db "HL:",0 
18fb .. 00		.regstatede:	db "DE:",0 
18ff .. 00		.regstatebc:	db "BC:",0 
1903 .. 00		.regstatea:	db "A :",0 
1907 .. 00		.regstatedsp:	db "DSP:",0 
190c .. 00		.regstatersp:	db "RSP:",0 
1911			 
1911			display_dump_at_hl: 
1911 e5				push hl 
1912 d5				push de 
1913 c5				push bc 
1914 f5				push af 
1915			 
1915 22 40 f1			ld (os_cur_ptr),hl	 
1918 cd d5 0a			call clear_display 
191b cd 5d 1b			call dumpcont 
191e			;	call delay1s 
191e			;	call next_page_prompt 
191e			 
191e			 
191e f1				pop af 
191f c1				pop bc 
1920 d1				pop de 
1921 e1				pop hl 
1922 c9				ret 
1923			 
1923			;if ENABLE_BASIC 
1923			;	include "nascombasic.asm" 
1923			;	basic: 
1923			;	include "forth/FORTH.ASM" 
1923			;endif 
1923			 
1923			; eof 
1923			 
1923			 
# End of file firmware_diags.asm
1923			  
1923			  
1923			  
1923			  
1923			; eof  
1923			  
# End of file firmware.asm
1923			 
1923			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1923			;if BASE_KEV  
1923			;baseram: equ 08000h 
1923			;endif 
1923			 
1923			;if BASE_SC114 
1923			;baseram:     equ    endofcode 
1923			;endif 
1923			 
1923			 
1923			; start system 
1923			 
1923			coldstart: 
1923				; set sp 
1923				; di/ei 
1923			 
1923 f3				di 
1924 31 fd ff			ld sp, tos 
1927			;	ei 
1927			 
1927			 
1927				; disable breakpoint by default 
1927			 
1927 3e 2a			ld a,'*' 
1929 32 0e ee			ld (os_view_disable),a 
192c			 
192c				; init hardware 
192c			 
192c				; init keyboard and screen hardware 
192c			 
192c cd 03 00			call hardware_init 
192f			 
192f			 
192f				; detect if any keys are held down to enable breakpoints at start up 
192f			 
192f cd c6 68			call cin  
1932 fe 00			cp 0 
1934 28 03			jr z, .nokeys 
1936			 
1936				;call hardware_diags 
1936 cd 93 13			call config 
1939			 
1939			;	ld de, .bpen 
1939			;	ld a, display_row_4 
1939			;	call str_at_display 
1939			;	call update_display 
1939			; 
1939			;	ld a,0 
1939			;	ld (os_view_disable),a 
1939			; 
1939			;.bpwait: 
1939			;	call cin 
1939			;	cp 0 
1939			;	jr z, .bpwait 
1939			;	jr .nokeys 
1939			; 
1939			; 
1939			;.bpen:  db "Break points enabled!",0 
1939			 
1939			 
1939			 
1939			 
1939			 
1939			 
1939			.nokeys: 
1939			 
1939			 
1939				 
1939			 
1939			;jp  testkey 
1939			 
1939			;call storage_get_block_0 
1939			; 
1939			;ld hl, 0 
1939			;ld de, store_page 
1939			;call storage_read_block 
1939			 
1939				 
1939			;ld hl, 10 
1939			;ld de, store_page 
1939			;call storage_read_block 
1939			 
1939			 
1939			 
1939			 
1939			 
1939			;stop:	nop 
1939			;	jp stop 
1939			 
1939			 
1939			 
1939			main: 
1939 cd d5 0a			call clear_display 
193c cd f8 0a			call update_display 
193f			 
193f			 
193f			 
193f			;	call testlcd 
193f			 
193f			 
193f			 
193f cd 1b 20			call forth_init 
1942			 
1942			 
1942			warmstart: 
1942 cd f1 1f			call forth_warmstart 
1945			 
1945				; run startup word load 
1945			        ; TODO prevent this running at warmstart after crash  
1945			 
1945				if STARTUP_ENABLE 
1945					if STORAGE_SE 
1945 cd 54 64					call forth_autoload 
1948					endif 
1948 cd 63 61				call forth_startup 
194b			 
194b			 
194b				endif 
194b			 
194b				; show free memory after boot 
194b 11 e5 19			ld de, freeram 
194e 3e 00			ld a, display_row_1 
1950 cd e8 0a			call str_at_display 
1953			 
1953			; Or use heap_size word???? 
1953 21 03 ee			ld hl, heap_end 
1956 11 0e 80			ld de, heap_start 
1959 ed 52			sbc hl, de 
195b e5				push hl 
195c 7c				ld a,h	         	 
195d 21 22 f1			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1960 cd 0a 10			call hexout 
1963 e1			   	pop hl 
1964			 
1964 7d				ld a,l 
1965 21 24 f1			ld hl, os_word_scratch+2 
1968 cd 0a 10			call hexout 
196b 21 26 f1			ld hl, os_word_scratch+4 
196e 3e 00			ld a, 0 
1970 77				ld (hl),a 
1971 11 22 f1			ld de, os_word_scratch 
1974 3e 0d			ld a, display_row_1 + 13 
1976 cd e8 0a			call str_at_display 
1979 cd f8 0a			call update_display 
197c			 
197c			 
197c				;call demo 
197c			 
197c			 
197c				; init scratch input area for cli commands 
197c			 
197c 21 44 f1			ld hl, os_cli_cmd 
197f 3e 00			ld a,0 
1981 77				ld (hl),a 
1982 23				inc hl 
1983 77				ld (hl),a 
1984			 
1984 3e 00			ld a,0 
1986 32 43 f2			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1989			 
1989 32 40 f1			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
198c 32 41 f1			ld (os_cur_ptr+1),a	 
198f			 
198f 32 22 f1			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1992 32 23 f1			ld (os_word_scratch+1),a	 
1995				 
1995			 
1995				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1995 21 44 f1			ld hl, os_cli_cmd 
1998			 
1998 3e 00			ld a, 0		 ; init cli input 
199a 77				ld (hl), a 
199b 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
199d			cli: 
199d				; show cli prompt 
199d				;push af 
199d				;ld a, 0 
199d				;ld de, prompt 
199d				;call str_at_display 
199d			 
199d				;call update_display 
199d				;pop af 
199d				;inc a 
199d				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
199d 0e 00			ld c, 0 
199f 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
19a1 1e 28			ld e, 40 
19a3			 
19a3 21 44 f1			ld hl, os_cli_cmd 
19a6			 
19a6				STACKFRAME OFF $fefe $9f9f 
19a6				if DEBUG_STACK_IMB 
19a6					if OFF 
19a6						exx 
19a6						ld de, $fefe 
19a6						ld a, d 
19a6						ld hl, curframe 
19a6						call hexout 
19a6						ld a, e 
19a6						ld hl, curframe+2 
19a6						call hexout 
19a6						ld hl, $fefe 
19a6						push hl 
19a6						ld hl, $9f9f 
19a6						push hl 
19a6						exx 
19a6					endif 
19a6				endif 
19a6			endm 
# End of macro STACKFRAME
19a6			 
19a6 cd 36 0d			call input_str 
19a9			 
19a9				STACKFRAMECHK OFF $fefe $9f9f 
19a9				if DEBUG_STACK_IMB 
19a9					if OFF 
19a9						exx 
19a9						ld hl, $9f9f 
19a9						pop de   ; $9f9f 
19a9						call cmp16 
19a9						jr nz, .spnosame 
19a9						ld hl, $fefe 
19a9						pop de   ; $fefe 
19a9						call cmp16 
19a9						jr z, .spfrsame 
19a9						.spnosame: call showsperror 
19a9						.spfrsame: nop 
19a9						exx 
19a9					endif 
19a9				endif 
19a9			endm 
# End of macro STACKFRAMECHK
19a9			 
19a9				; copy input to last command 
19a9			 
19a9 21 44 f1			ld hl, os_cli_cmd 
19ac 11 43 f2			ld de, os_last_cmd 
19af 01 ff 00			ld bc, 255 
19b2 ed b0			ldir 
19b4			 
19b4				; wipe current buffer 
19b4			 
19b4			;	ld a, 0 
19b4			;	ld hl, os_cli_cmd 
19b4			;	ld de, os_cli_cmd+1 
19b4			;	ld bc, 254 
19b4			;	ldir 
19b4				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
19b4			;	call strcpy 
19b4			;	ld a, 0 
19b4			;	ld (hl), a 
19b4			;	inc hl 
19b4			;	ld (hl), a 
19b4			;	inc hl 
19b4			;	ld (hl), a 
19b4			 
19b4				; switch frame buffer to program  
19b4			 
19b4 21 1c fa				ld hl, display_fb1 
19b7 22 d8 f8				ld (display_fb_active), hl 
19ba			 
19ba			;	nop 
19ba				STACKFRAME ON $fbfe $8f9f 
19ba				if DEBUG_STACK_IMB 
19ba					if ON 
19ba						exx 
19ba						ld de, $fbfe 
19ba						ld a, d 
19ba						ld hl, curframe 
19ba						call hexout 
19ba						ld a, e 
19ba						ld hl, curframe+2 
19ba						call hexout 
19ba						ld hl, $fbfe 
19ba						push hl 
19ba						ld hl, $8f9f 
19ba						push hl 
19ba						exx 
19ba					endif 
19ba				endif 
19ba			endm 
# End of macro STACKFRAME
19ba				; first time into the parser so pass over the current scratch pad 
19ba 21 44 f1			ld hl,os_cli_cmd 
19bd				; tokenise the entered statement(s) in HL 
19bd cd 94 20			call forthparse 
19c0			        ; exec forth statements in top of return stack 
19c0 cd d4 20			call forthexec 
19c3				;call forthexec_cleanup 
19c3			;	call parsenext 
19c3			 
19c3				STACKFRAMECHK ON $fbfe $8f9f 
19c3				if DEBUG_STACK_IMB 
19c3					if ON 
19c3						exx 
19c3						ld hl, $8f9f 
19c3						pop de   ; $8f9f 
19c3						call cmp16 
19c3						jr nz, .spnosame 
19c3						ld hl, $fbfe 
19c3						pop de   ; $fbfe 
19c3						call cmp16 
19c3						jr z, .spfrsame 
19c3						.spnosame: call showsperror 
19c3						.spfrsame: nop 
19c3						exx 
19c3					endif 
19c3				endif 
19c3			endm 
# End of macro STACKFRAMECHK
19c3				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
19c3			 
19c3 3e 78			ld a, display_row_4 
19c5 11 f7 19			ld de, endprog 
19c8			 
19c8 cd f8 0a			call update_display		 
19cb			 
19cb cd 55 1c			call next_page_prompt 
19ce			 
19ce				; switch frame buffer to cli 
19ce			 
19ce 21 bd fa				ld hl, display_fb0 
19d1 22 d8 f8				ld (display_fb_active), hl 
19d4			 
19d4			 
19d4 cd d5 0a		        call clear_display 
19d7 cd f8 0a			call update_display		 
19da			 
19da 21 44 f1			ld hl, os_cli_cmd 
19dd			 
19dd 3e 00			ld a, 0		 ; init cli input 
19df 77				ld (hl), a 
19e0			 
19e0				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
19e0			 
19e0				; now on last line 
19e0			 
19e0				; TODO scroll screen up 
19e0			 
19e0				; TODO instead just clear screen and place at top of screen 
19e0			 
19e0			;	ld a, 0 
19e0			;	ld (f_cursor_ptr),a 
19e0			 
19e0				;call clear_display 
19e0				;call update_display 
19e0			 
19e0				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
19e0 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
19e2 c3 9d 19			jp cli 
19e5			 
19e5 .. 00		freeram: db "Free bytes: $",0 
19f3 ..			asc: db "1A2F" 
19f7 .. 00		endprog: db "End prog...",0 
1a03			 
1a03			testenter2:   
1a03 21 4f ee			ld hl,scratch+50 
1a06 22 40 f1			ld (os_cur_ptr),hl 
1a09 c3 9d 19			jp cli 
1a0c			 
1a0c			testenter:  
1a0c			 
1a0c 21 f3 19			ld hl,asc 
1a0f			;	ld a,(hl) 
1a0f			;	call nibble2val 
1a0f cd 60 10			call get_byte 
1a12			 
1a12			 
1a12			;	ld a,(hl) 
1a12			;	call atohex 
1a12			 
1a12			;	call fourehexhl 
1a12 32 4f ee			ld (scratch+50),a 
1a15			 
1a15			 
1a15			 
1a15 21 f5 19			ld hl,asc+2 
1a18			;	ld a, (hl) 
1a18			;	call nibble2val 
1a18 cd 60 10			call get_byte 
1a1b			 
1a1b			;	call fourehexhl 
1a1b 32 51 ee			ld (scratch+52),a 
1a1e				 
1a1e 21 4f ee			ld hl,scratch+50 
1a21 22 40 f1			ld (os_cur_ptr),hl 
1a24 c3 9d 19			jp cli 
1a27			 
1a27			enter:	 
1a27 3a 21 ee			ld a,(scratch+4) 
1a2a fe 00			cp 0 
1a2c 28 0c			jr z, .entercont 
1a2e				; no, not a null term line so has an address to work out.... 
1a2e			 
1a2e 21 1f ee			ld hl,scratch+2 
1a31 cd c0 10			call get_word_hl 
1a34			 
1a34 22 40 f1			ld (os_cur_ptr),hl	 
1a37 c3 9d 19			jp cli 
1a3a			 
1a3a			 
1a3a			.entercont:  
1a3a			 
1a3a 21 1f ee			ld hl, scratch+2 
1a3d cd 60 10			call get_byte 
1a40			 
1a40 2a 40 f1		   	ld hl,(os_cur_ptr) 
1a43 77					ld (hl),a 
1a44 23					inc hl 
1a45 22 40 f1				ld (os_cur_ptr),hl 
1a48				 
1a48			; get byte  
1a48			 
1a48			 
1a48 c3 9d 19			jp cli 
1a4b			 
1a4b			 
1a4b			; basic monitor support 
1a4b			 
1a4b			monitor: 
1a4b				;  
1a4b cd d5 0a			call clear_display 
1a4e 3e 00			ld a, 0 
1a50 11 98 1a			ld de, .monprompt 
1a53 cd e8 0a			call str_at_display 
1a56 cd f8 0a			call update_display 
1a59			 
1a59				; get a monitor command 
1a59			 
1a59 0e 00			ld c, 0     ; entry at top left 
1a5b 16 64			ld d, 100   ; max buffer size 
1a5d 1e 0f			ld e, 15    ; input scroll area 
1a5f 3e 00			ld a, 0     ; init string 
1a61 21 1b f0			ld hl, os_input 
1a64 77				ld (hl), a 
1a65 23				inc hl 
1a66 77				ld (hl), a 
1a67 21 1b f0			ld hl, os_input 
1a6a 3e 01			ld a, 1     ; init string 
1a6c cd 36 0d			call input_str 
1a6f			 
1a6f cd d5 0a		        call clear_display 
1a72 cd f8 0a			call update_display		 
1a75			 
1a75 3a 1b f0			ld a, (os_input) 
1a78 cd 5e 11			call toUpper 
1a7b fe 48		        cp 'H' 
1a7d 28 6f		        jr z, .monhelp 
1a7f fe 44			cp 'D'		; dump 
1a81 ca 0f 1b			jp z, .mondump	 
1a84 fe 43			cp 'C'		; dump 
1a86 ca 29 1b			jp z, .moncdump	 
1a89 fe 4d			cp 'M'		; dump 
1a8b ca 9a 1a			jp z, .moneditstart 
1a8e fe 55			cp 'U'		; dump 
1a90 28 14			jr z, .monedit	 
1a92 fe 51			cp 'Q'		; dump 
1a94 c8				ret z	 
1a95			 
1a95			 
1a95				; TODO "S" to access symbol by name and not need the address 
1a95				; TODO "F" to find a string in memory 
1a95			 
1a95 c3 4b 1a			jp monitor 
1a98			 
1a98 .. 00		.monprompt: db ">", 0 
1a9a			 
1a9a			.moneditstart: 
1a9a				; get starting address 
1a9a			 
1a9a 21 1d f0			ld hl,os_input+2 
1a9d cd c0 10			call get_word_hl 
1aa0			 
1aa0 22 40 f1			ld (os_cur_ptr),hl	 
1aa3			 
1aa3 c3 4b 1a			jp monitor 
1aa6			 
1aa6			.monedit: 
1aa6				; get byte to load 
1aa6			 
1aa6 21 1d f0			ld hl,os_input+2 
1aa9 cd 60 10			call get_byte 
1aac			 
1aac				; get address to update 
1aac 2a 40 f1			ld hl, (os_cur_ptr) 
1aaf			 
1aaf				; update byte 
1aaf			 
1aaf 77				ld (hl), a 
1ab0			 
1ab0				; move to next address and save it 
1ab0			 
1ab0 23				inc hl 
1ab1 22 40 f1			ld (os_cur_ptr),hl	 
1ab4			 
1ab4 c3 4b 1a			jp monitor 
1ab7			 
1ab7			 
1ab7 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1acb .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1ae7 .. 00		.monhelptext3:  db "Q-Quit",0 
1aee			        
1aee			.monhelp: 
1aee 3e 00			ld a, display_row_1 
1af0 11 b7 1a		        ld de, .monhelptext1 
1af3			 
1af3 cd e8 0a			call str_at_display 
1af6 3e 28			ld a, display_row_2 
1af8 11 cb 1a		        ld de, .monhelptext2 
1afb					 
1afb cd e8 0a			call str_at_display 
1afe 3e 50			ld a, display_row_3 
1b00 11 e7 1a		        ld de, .monhelptext3 
1b03					 
1b03 cd e8 0a			call str_at_display 
1b06 cd f8 0a			call update_display		 
1b09			 
1b09 cd 55 1c			call next_page_prompt 
1b0c c3 4b 1a			jp monitor 
1b0f			 
1b0f			.mondump:    
1b0f 21 1d f0			ld hl,os_input+2 
1b12 cd c0 10			call get_word_hl 
1b15			 
1b15 22 40 f1			ld (os_cur_ptr),hl	 
1b18 cd 5d 1b			call dumpcont 
1b1b 3e 78			ld a, display_row_4 
1b1d 11 f7 19			ld de, endprog 
1b20			 
1b20 cd f8 0a			call update_display		 
1b23			 
1b23 cd 55 1c			call next_page_prompt 
1b26 c3 4b 1a			jp monitor 
1b29			.moncdump: 
1b29 cd 5d 1b			call dumpcont 
1b2c 3e 78			ld a, display_row_4 
1b2e 11 f7 19			ld de, endprog 
1b31			 
1b31 cd f8 0a			call update_display		 
1b34			 
1b34 cd 55 1c			call next_page_prompt 
1b37 c3 4b 1a			jp monitor 
1b3a			 
1b3a			 
1b3a			; TODO symbol access  
1b3a			 
1b3a			.symbols:     ;; A list of symbols that can be called up  
1b3a bd fa			dw display_fb0 
1b3c .. 00			db "fb0",0  
1b40 62 f8		     	dw store_page 
1b42 .. 00			db "store_page",0 
1b4d			 
1b4d			 
1b4d			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1b4d			 
1b4d 3a 1e ee			ld a,(scratch+1) 
1b50 fe 00			cp 0 
1b52 28 09			jr z, dumpcont 
1b54			 
1b54				; no, not a null term line so has an address to work out.... 
1b54			 
1b54 21 1f ee			ld hl,scratch+2 
1b57 cd c0 10			call get_word_hl 
1b5a			 
1b5a 22 40 f1			ld (os_cur_ptr),hl	 
1b5d			 
1b5d			 
1b5d			 
1b5d			dumpcont: 
1b5d			 
1b5d				; dump bytes at ptr 
1b5d			 
1b5d			 
1b5d 3e 00			ld a, display_row_1 
1b5f 2a d8 f8			ld hl, (display_fb_active) 
1b62 cd 09 0d			call addatohl 
1b65 cd 8d 1b			call .dumpbyterow 
1b68			 
1b68 3e 28			ld a, display_row_2 
1b6a 2a d8 f8			ld hl, (display_fb_active) 
1b6d cd 09 0d			call addatohl 
1b70 cd 8d 1b			call .dumpbyterow 
1b73			 
1b73			 
1b73 3e 50			ld a, display_row_3 
1b75 2a d8 f8			ld hl, (display_fb_active) 
1b78 cd 09 0d			call addatohl 
1b7b cd 8d 1b			call .dumpbyterow 
1b7e			 
1b7e 3e 78			ld a, display_row_4 
1b80 2a d8 f8			ld hl, (display_fb_active) 
1b83 cd 09 0d			call addatohl 
1b86 cd 8d 1b			call .dumpbyterow 
1b89			 
1b89 cd f8 0a			call update_display 
1b8c			;		jp cli 
1b8c c9				ret 
1b8d			 
1b8d			.dumpbyterow: 
1b8d			 
1b8d				;push af 
1b8d			 
1b8d e5				push hl 
1b8e			 
1b8e				; calc where to poke the ascii 
1b8e			if display_cols == 20 
1b8e				ld a, 16 
1b8e			else 
1b8e 3e 1f			ld a, 31 
1b90			endif 
1b90			 
1b90 cd 09 0d			call addatohl 
1b93 22 22 f1			ld (os_word_scratch),hl  		; save pos for later 
1b96			 
1b96			 
1b96			; display decoding address 
1b96 2a 40 f1		   	ld hl,(os_cur_ptr) 
1b99			 
1b99 7c				ld a,h 
1b9a e1				pop hl 
1b9b e5				push hl 
1b9c			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1b9c cd 0a 10			call hexout 
1b9f 2a 40 f1		   	ld hl,(os_cur_ptr) 
1ba2			 
1ba2 7d				ld a,l 
1ba3 e1				pop hl 
1ba4 23				inc hl 
1ba5 23				inc hl 
1ba6 e5				push hl 
1ba7			;	ld hl, os_word_scratch+2 
1ba7 cd 0a 10			call hexout 
1baa e1				pop hl 
1bab 23				inc hl 
1bac 23				inc hl 
1bad				;ld hl, os_word_scratch+4 
1bad 3e 3a			ld a, ':' 
1baf 77				ld (hl),a 
1bb0 23				inc hl 
1bb1				;ld a, 0 
1bb1				;ld (hl),a 
1bb1				;ld de, os_word_scratch 
1bb1				;pop af 
1bb1				;push af 
1bb1			;		ld a, display_row_2 
1bb1			;		call str_at_display 
1bb1			;		call update_display 
1bb1			 
1bb1			 
1bb1			;pop af 
1bb1			;	add 5 
1bb1			 
1bb1			if display_cols == 20 
1bb1				ld b, 4 
1bb1			else 
1bb1 06 08			ld b, 8 
1bb3			endif	 
1bb3			 
1bb3			.dumpbyte: 
1bb3 c5				push bc 
1bb4 e5				push hl 
1bb5			 
1bb5			 
1bb5 2a 40 f1		   	ld hl,(os_cur_ptr) 
1bb8 7e					ld a,(hl) 
1bb9			 
1bb9					; poke the ascii to display 
1bb9 2a 22 f1				ld hl,(os_word_scratch) 
1bbc 77					ld (hl),a 
1bbd 23					inc hl 
1bbe 22 22 f1				ld (os_word_scratch),hl 
1bc1			 
1bc1					 
1bc1			 
1bc1			 
1bc1 e1					pop hl 
1bc2 e5					push hl 
1bc3			 
1bc3 cd 0a 10				call hexout 
1bc6			 
1bc6					 
1bc6 2a 40 f1		   	ld hl,(os_cur_ptr) 
1bc9 23				inc hl 
1bca 22 40 f1		   	ld (os_cur_ptr),hl 
1bcd			 
1bcd e1					pop hl 
1bce 23					inc hl 
1bcf 23					inc hl 
1bd0 23					inc hl 
1bd1			 
1bd1			 
1bd1			 
1bd1					;ld a,0 
1bd1					;ld (os_word_scratch+2),a 
1bd1					;pop af 
1bd1					;push af 
1bd1			 
1bd1					;ld de, os_word_scratch 
1bd1					;call str_at_display 
1bd1			;		call update_display 
1bd1			;		pop af 
1bd1 c1					pop bc 
1bd2 c6 03				add 3 
1bd4 10 dd			djnz .dumpbyte 
1bd6			 
1bd6				 
1bd6			 
1bd6 c9				ret 
1bd7			 
1bd7			jump:	 
1bd7			 
1bd7 21 1f ee			ld hl,scratch+2 
1bda cd c0 10			call get_word_hl 
1bdd				;ld hl,(scratch+2) 
1bdd				;call fourehexhl 
1bdd			 
1bdd 22 40 f1			ld (os_cur_ptr),hl	 
1be0			 
1be0 e9				jp (hl) 
1be1			 
1be1			 
1be1			 
1be1			; TODO implement a basic monitor mode to start with 
1be1			 
1be1			 
1be1			 
1be1			 
1be1			 
1be1			 
1be1			 
1be1			 
1be1			 
1be1			; testing and demo code during development 
1be1			 
1be1			 
1be1 .. 00		str1: db "Enter some text...",0 
1bf4 .. 00		clear: db "                    ",0 
1c09			 
1c09			demo: 
1c09			 
1c09			 
1c09			 
1c09			;	call update_display 
1c09			 
1c09				; init scratch input area for testing 
1c09 21 1d ee			ld hl, scratch	 
1c0c 3e 00			ld a,0 
1c0e 77				ld (hl),a 
1c0f			 
1c0f			 
1c0f 3e 28		            LD   A, display_row_2 
1c11			;            CALL fLCD_Pos       ;Position cursor to location in A 
1c11 11 e1 1b		            LD   DE, str1 
1c14 cd e8 0a			call str_at_display 
1c17			 
1c17			;            CALL fLCD_Str       ;Display string pointed to by DE 
1c17			cloop:	 
1c17 3e 50		            LD   A, display_row_3 
1c19			;            CALL fLCD_Pos       ;Position cursor to location in A 
1c19 11 f4 1b		            LD   DE, clear 
1c1c			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1c1c cd e8 0a				call str_at_display 
1c1f 3e 78			ld a, display_row_4 
1c21 11 51 1c			ld de, prompt 
1c24			 
1c24 cd e8 0a				call str_at_display 
1c27 cd f8 0a			call update_display 
1c2a			 
1c2a 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1c2c 16 0a			ld d, 10 
1c2e 21 1d ee			ld hl, scratch	 
1c31 cd 36 0d			call input_str 
1c34			 
1c34			;	call clear_display 
1c34			;'	call update_display 
1c34			 
1c34 3e 00		            LD   A, display_row_1 
1c36			;            CALL fLCD_Pos       ;Position cursor to location in A 
1c36 11 f4 1b		            LD   DE, clear 
1c39 cd e8 0a				call str_at_display 
1c3c			;            CALL fLCD_Str       ;Display string pointed to by DE 
1c3c 3e 00		            LD   A, display_row_1 
1c3e			;            CALL fLCD_Pos       ;Position cursor to location in A 
1c3e 11 1d ee		            LD   DE, scratch 
1c41			;            CALL fLCD_Str       ;Display string pointed to by DE 
1c41 cd e8 0a				call str_at_display 
1c44 cd f8 0a			call update_display 
1c47			 
1c47 3e 00				ld a,0 
1c49 21 1d ee			ld hl, scratch 
1c4c 77				ld (hl),a 
1c4d			 
1c4d 00				nop 
1c4e c3 17 1c			jp cloop 
1c51			 
1c51			 
1c51			 
1c51			; OS Prompt 
1c51			 
1c51 .. 00		prompt: db ">",0 
1c53 .. 00		endprg: db "?",0 
1c55			 
1c55			 
1c55			; handy next page prompt 
1c55			next_page_prompt: 
1c55 e5				push hl 
1c56 d5				push de 
1c57 f5				push af 
1c58 c5				push bc 
1c59			 
1c59 3e 9f			ld a,display_row_4 + display_cols - 1 
1c5b 11 53 1c		        ld de, endprg 
1c5e cd e8 0a			call str_at_display 
1c61 cd f8 0a			call update_display 
1c64 cd b5 68			call cin_wait 
1c67 c1				pop bc 
1c68 f1				pop af 
1c69 d1				pop de 
1c6a e1				pop hl 
1c6b			 
1c6b			 
1c6b c9				ret 
1c6c			 
1c6c			 
1c6c			; forth parser 
1c6c			 
1c6c			; My forth kernel 
1c6c			include "forth_kernel.asm" 
1c6c			; 
1c6c			; kernel to the forth OS 
1c6c			 
1c6c			DS_TYPE_STR: equ 1     ; string type 
1c6c			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1c6c			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1c6c			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1c6c			 
1c6c			FORTH_PARSEV1: equ 0 
1c6c			FORTH_PARSEV2: equ 0 
1c6c			FORTH_PARSEV3: equ 0 
1c6c			FORTH_PARSEV4: equ 0 
1c6c			FORTH_PARSEV5: equ 1 
1c6c			 
1c6c			;if FORTH_PARSEV5 
1c6c			;	FORTH_END_BUFFER: equ 0 
1c6c			;else 
1c6c			FORTH_END_BUFFER: equ 127 
1c6c			;endif 
1c6c			 
1c6c			FORTH_TRUE: equ 1 
1c6c			FORTH_FALSE: equ 0 
1c6c			 
1c6c			if FORTH_PARSEV4 
1c6c			include "forth_stackops.asm" 
1c6c			endif 
1c6c			 
1c6c			if FORTH_PARSEV5 
1c6c			include "forth_stackopsv5.asm" 
1c6c			 
1c6c			; Stack operations for v5 parser on wards 
1c6c			; * DATA stack 
1c6c			; * LOOP stack 
1c6c			; * RETURN stack 
1c6c			 
1c6c			 
1c6c			 
1c6c			FORTH_CHK_DSP_UNDER: macro 
1c6c				push hl 
1c6c				push de 
1c6c				ld hl,(cli_data_sp) 
1c6c				ld de, cli_data_stack 
1c6c				call cmp16 
1c6c				jp c, fault_dsp_under 
1c6c				pop de 
1c6c				pop hl 
1c6c				endm 
1c6c			 
1c6c			 
1c6c			FORTH_CHK_RSP_UNDER: macro 
1c6c				push hl 
1c6c				push de 
1c6c				ld hl,(cli_ret_sp) 
1c6c				ld de, cli_ret_stack 
1c6c				call cmp16 
1c6c				jp c, fault_rsp_under 
1c6c				pop de 
1c6c				pop hl 
1c6c				endm 
1c6c			 
1c6c			FORTH_CHK_LOOP_UNDER: macro 
1c6c				push hl 
1c6c				push de 
1c6c				ld hl,(cli_loop_sp) 
1c6c				ld de, cli_loop_stack 
1c6c				call cmp16 
1c6c				jp c, fault_loop_under 
1c6c				pop de 
1c6c				pop hl 
1c6c				endm 
1c6c			 
1c6c			FORTH_ERR_TOS_NOTSTR: macro 
1c6c				; TOSO might need more for checks when used 
1c6c				push af 
1c6c				ld a,(hl) 
1c6c				cp DS_TYPE_STR 
1c6c				jp nz, type_faultn   
1c6c				pop af 
1c6c				endm 
1c6c			 
1c6c			FORTH_ERR_TOS_NOTNUM: macro 
1c6c				push af 
1c6c				ld a,(hl) 
1c6c				cp DS_TYPE_INUM 
1c6c				jp nz, type_faultn   
1c6c				pop af 
1c6c				endm 
1c6c			 
1c6c			 
1c6c			; increase data stack pointer and save hl to it 
1c6c				 
1c6c			FORTH_DSP_NEXT: macro 
1c6c				call macro_forth_dsp_next 
1c6c				endm 
1c6c			 
1c6c			 
1c6c			macro_forth_dsp_next: 
1c6c				if DEBUG_FORTH_STACK_GUARD 
1c6c cd 2d 62				call check_stacks 
1c6f				endif 
1c6f e5				push hl 
1c70 d5				push de 
1c71 eb				ex de,hl 
1c72 2a 0a f8			ld hl,(cli_data_sp) 
1c75 23				inc hl 
1c76 23				inc hl 
1c77			 
1c77			; PARSEV5 
1c77 23				inc hl 
1c78 22 0a f8			ld (cli_data_sp),hl 
1c7b 73				ld (hl), e 
1c7c 23				inc hl 
1c7d 72				ld (hl), d 
1c7e d1				pop de 
1c7f e1				pop hl 
1c80				if DEBUG_FORTH_STACK_GUARD 
1c80 cd 2d 62				call check_stacks 
1c83				endif 
1c83 c9				ret 
1c84			 
1c84			 
1c84			; increase ret stack pointer and save hl to it 
1c84				 
1c84			FORTH_RSP_NEXT: macro 
1c84				call macro_forth_rsp_next 
1c84				endm 
1c84			 
1c84			macro_forth_rsp_next: 
1c84				if DEBUG_FORTH_STACK_GUARD 
1c84 cd 2d 62				call check_stacks 
1c87				endif 
1c87 e5				push hl 
1c88 d5				push de 
1c89 eb				ex de,hl 
1c8a 2a 0e f8			ld hl,(cli_ret_sp) 
1c8d 23				inc hl 
1c8e 23				inc hl 
1c8f 22 0e f8			ld (cli_ret_sp),hl 
1c92 73				ld (hl), e 
1c93 23				inc hl 
1c94 72				ld (hl), d 
1c95 d1				pop de 
1c96 e1				pop hl 
1c97				if DEBUG_FORTH_STACK_GUARD 
1c97 cd 2d 62				call check_stacks 
1c9a				endif 
1c9a c9				ret 
1c9b			 
1c9b			; get current ret stack pointer and save to hl  
1c9b				 
1c9b			FORTH_RSP_TOS: macro 
1c9b				call macro_forth_rsp_tos 
1c9b				endm 
1c9b			 
1c9b			macro_forth_rsp_tos: 
1c9b				;push de 
1c9b 2a 0e f8			ld hl,(cli_ret_sp) 
1c9e cd d6 1c			call loadhlptrtohl 
1ca1				;ld e, (hl) 
1ca1				;inc hl 
1ca1				;ld d, (hl) 
1ca1				;ex de, hl 
1ca1					if DEBUG_FORTH_WORDS 
1ca1			;			DMARK "RST" 
1ca1						CALLMONITOR 
1ca1 cd 4d 17			call break_point_state  
1ca4				endm  
# End of macro CALLMONITOR
1ca4					endif 
1ca4				;pop de 
1ca4 c9				ret 
1ca5			 
1ca5			; pop ret stack pointer 
1ca5				 
1ca5			FORTH_RSP_POP: macro 
1ca5				call macro_forth_rsp_pop 
1ca5				endm 
1ca5			 
1ca5			 
1ca5			macro_forth_rsp_pop: 
1ca5				if DEBUG_FORTH_STACK_GUARD 
1ca5			;		DMARK "RPP" 
1ca5 cd 2d 62				call check_stacks 
1ca8					FORTH_CHK_RSP_UNDER 
1ca8 e5				push hl 
1ca9 d5				push de 
1caa 2a 0e f8			ld hl,(cli_ret_sp) 
1cad 11 88 f7			ld de, cli_ret_stack 
1cb0 cd 27 0d			call cmp16 
1cb3 da 41 63			jp c, fault_rsp_under 
1cb6 d1				pop de 
1cb7 e1				pop hl 
1cb8				endm 
# End of macro FORTH_CHK_RSP_UNDER
1cb8				endif 
1cb8 e5				push hl 
1cb9 2a 0e f8			ld hl,(cli_ret_sp) 
1cbc			 
1cbc			 
1cbc				if FORTH_ENABLE_FREE 
1cbc			 
1cbc					; get pointer 
1cbc			 
1cbc					push de 
1cbc					push hl 
1cbc			 
1cbc					ld e, (hl) 
1cbc					inc hl 
1cbc					ld d, (hl) 
1cbc			 
1cbc					ex de, hl 
1cbc					call free 
1cbc			 
1cbc					pop hl 
1cbc					pop de 
1cbc			 
1cbc			 
1cbc				endif 
1cbc			 
1cbc			 
1cbc 2b				dec hl 
1cbd 2b				dec hl 
1cbe 22 0e f8			ld (cli_ret_sp), hl 
1cc1				; do stack underflow checks 
1cc1 e1				pop hl 
1cc2				if DEBUG_FORTH_STACK_GUARD 
1cc2 cd 2d 62				call check_stacks 
1cc5					FORTH_CHK_RSP_UNDER 
1cc5 e5				push hl 
1cc6 d5				push de 
1cc7 2a 0e f8			ld hl,(cli_ret_sp) 
1cca 11 88 f7			ld de, cli_ret_stack 
1ccd cd 27 0d			call cmp16 
1cd0 da 41 63			jp c, fault_rsp_under 
1cd3 d1				pop de 
1cd4 e1				pop hl 
1cd5				endm 
# End of macro FORTH_CHK_RSP_UNDER
1cd5				endif 
1cd5 c9				ret 
1cd6			 
1cd6			 
1cd6			 
1cd6			; routine to load word pointed to by hl into hl 
1cd6			 
1cd6			loadhlptrtohl: 
1cd6			 
1cd6 d5				push de 
1cd7 5e				ld e, (hl) 
1cd8 23				inc hl 
1cd9 56				ld d, (hl) 
1cda eb				ex de, hl 
1cdb d1				pop de 
1cdc			 
1cdc c9				ret 
1cdd			 
1cdd			 
1cdd			 
1cdd			 
1cdd			 
1cdd			; push a number held in HL onto the data stack 
1cdd			; entry point for pushing a value when already in hl used in function above 
1cdd			 
1cdd			forth_push_numhl: 
1cdd			 
1cdd e5				push hl    ; save value to push 
1cde			 
1cde			if DEBUG_FORTH_PUSH 
1cde				; see if disabled 
1cde			 
1cde			 
1cde f5				push af 
1cdf 3a 0e ee			ld a, (os_view_disable) 
1ce2 fe 2a			cp '*' 
1ce4 28 34			jr z, .pskip2 
1ce6 e5				push hl 
1ce7 e5			push hl 
1ce8 cd d5 0a			call clear_display 
1ceb e1			pop hl 
1cec 7c				ld a,h 
1ced 21 22 f1			ld hl, os_word_scratch 
1cf0 cd 0a 10			call hexout 
1cf3 e1				pop hl 
1cf4 7d				ld a,l 
1cf5 21 24 f1			ld hl, os_word_scratch+2 
1cf8 cd 0a 10			call hexout 
1cfb			 
1cfb 21 26 f1			ld hl, os_word_scratch+4 
1cfe 3e 00			ld a,0 
1d00 77				ld (hl),a 
1d01 11 22 f1			ld de,os_word_scratch 
1d04 3e 28				ld a, display_row_2 
1d06 cd e8 0a				call str_at_display 
1d09 11 3b 51			ld de, .push_num 
1d0c 3e 00			ld a, display_row_1 
1d0e			 
1d0e cd e8 0a				call str_at_display 
1d11			 
1d11			 
1d11 cd f8 0a			call update_display 
1d14 cd 55 0a			call delay1s 
1d17 cd 55 0a			call delay1s 
1d1a			.pskip2:  
1d1a			 
1d1a f1				pop af 
1d1b			endif	 
1d1b			 
1d1b			 
1d1b				FORTH_DSP_NEXT 
1d1b cd 6c 1c			call macro_forth_dsp_next 
1d1e				endm 
# End of macro FORTH_DSP_NEXT
1d1e			 
1d1e 2a 0a f8			ld hl, (cli_data_sp) 
1d21			 
1d21				; save item type 
1d21 3e 02			ld a,  DS_TYPE_INUM 
1d23 77				ld (hl), a 
1d24 23				inc hl 
1d25			 
1d25				; get word off stack 
1d25 d1				pop de 
1d26 7b				ld a,e 
1d27 77				ld (hl), a 
1d28 23				inc hl 
1d29 7a				ld a,d 
1d2a 77				ld (hl), a 
1d2b			 
1d2b			if DEBUG_FORTH_PUSH 
1d2b 2b				dec hl 
1d2c 2b				dec hl 
1d2d 2b				dec hl 
1d2e						DMARK "PH5" 
1d2e f5				push af  
1d2f 3a 43 1d			ld a, (.dmark)  
1d32 32 77 fb			ld (debug_mark),a  
1d35 3a 44 1d			ld a, (.dmark+1)  
1d38 32 78 fb			ld (debug_mark+1),a  
1d3b 3a 45 1d			ld a, (.dmark+2)  
1d3e 32 79 fb			ld (debug_mark+2),a  
1d41 18 03			jr .pastdmark  
1d43 ..			.dmark: db "PH5"  
1d46 f1			.pastdmark: pop af  
1d47			endm  
# End of macro DMARK
1d47				CALLMONITOR 
1d47 cd 4d 17			call break_point_state  
1d4a				endm  
# End of macro CALLMONITOR
1d4a			endif	 
1d4a			 
1d4a c9				ret 
1d4b			 
1d4b			 
1d4b			; Push a string to stack pointed to by hl 
1d4b			 
1d4b			forth_push_str: 
1d4b			 
1d4b			if DEBUG_FORTH_PUSH 
1d4b						DMARK "PSQ" 
1d4b f5				push af  
1d4c 3a 60 1d			ld a, (.dmark)  
1d4f 32 77 fb			ld (debug_mark),a  
1d52 3a 61 1d			ld a, (.dmark+1)  
1d55 32 78 fb			ld (debug_mark+1),a  
1d58 3a 62 1d			ld a, (.dmark+2)  
1d5b 32 79 fb			ld (debug_mark+2),a  
1d5e 18 03			jr .pastdmark  
1d60 ..			.dmark: db "PSQ"  
1d63 f1			.pastdmark: pop af  
1d64			endm  
# End of macro DMARK
1d64				CALLMONITOR 
1d64 cd 4d 17			call break_point_state  
1d67				endm  
# End of macro CALLMONITOR
1d67			endif	 
1d67			    
1d67 e5				push hl 
1d68 e5				push hl 
1d69			 
1d69			;	ld a, 0   ; find end of string 
1d69 cd 67 11			call strlenz 
1d6c			if DEBUG_FORTH_PUSH 
1d6c						DMARK "PQ2" 
1d6c f5				push af  
1d6d 3a 81 1d			ld a, (.dmark)  
1d70 32 77 fb			ld (debug_mark),a  
1d73 3a 82 1d			ld a, (.dmark+1)  
1d76 32 78 fb			ld (debug_mark+1),a  
1d79 3a 83 1d			ld a, (.dmark+2)  
1d7c 32 79 fb			ld (debug_mark+2),a  
1d7f 18 03			jr .pastdmark  
1d81 ..			.dmark: db "PQ2"  
1d84 f1			.pastdmark: pop af  
1d85			endm  
# End of macro DMARK
1d85				CALLMONITOR 
1d85 cd 4d 17			call break_point_state  
1d88				endm  
# End of macro CALLMONITOR
1d88			endif	 
1d88 eb				ex de, hl 
1d89 e1				pop hl   ; get ptr to start of string 
1d8a			if DEBUG_FORTH_PUSH 
1d8a						DMARK "PQ3" 
1d8a f5				push af  
1d8b 3a 9f 1d			ld a, (.dmark)  
1d8e 32 77 fb			ld (debug_mark),a  
1d91 3a a0 1d			ld a, (.dmark+1)  
1d94 32 78 fb			ld (debug_mark+1),a  
1d97 3a a1 1d			ld a, (.dmark+2)  
1d9a 32 79 fb			ld (debug_mark+2),a  
1d9d 18 03			jr .pastdmark  
1d9f ..			.dmark: db "PQ3"  
1da2 f1			.pastdmark: pop af  
1da3			endm  
# End of macro DMARK
1da3				CALLMONITOR 
1da3 cd 4d 17			call break_point_state  
1da6				endm  
# End of macro CALLMONITOR
1da6			endif	 
1da6 19				add hl,de 
1da7			if DEBUG_FORTH_PUSH 
1da7						DMARK "PQE" 
1da7 f5				push af  
1da8 3a bc 1d			ld a, (.dmark)  
1dab 32 77 fb			ld (debug_mark),a  
1dae 3a bd 1d			ld a, (.dmark+1)  
1db1 32 78 fb			ld (debug_mark+1),a  
1db4 3a be 1d			ld a, (.dmark+2)  
1db7 32 79 fb			ld (debug_mark+2),a  
1dba 18 03			jr .pastdmark  
1dbc ..			.dmark: db "PQE"  
1dbf f1			.pastdmark: pop af  
1dc0			endm  
# End of macro DMARK
1dc0				CALLMONITOR 
1dc0 cd 4d 17			call break_point_state  
1dc3				endm  
# End of macro CALLMONITOR
1dc3			endif	 
1dc3			 
1dc3 2b				dec hl    ; see if there is an optional trailing double quote 
1dc4 7e				ld a,(hl) 
1dc5 fe 22			cp '"' 
1dc7 20 03			jr nz, .strnoq 
1dc9 3e 00			ld a, 0      ; get rid of double quote 
1dcb 77				ld (hl), a 
1dcc 23			.strnoq: inc hl 
1dcd			 
1dcd 3e 00			ld a, 0 
1dcf 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1dd0			 
1dd0 13				inc de ; add one for the type string 
1dd1 13				inc de ; add one for null term??? 
1dd2			 
1dd2				; tos is get string pointer again 
1dd2				; de contains space to allocate 
1dd2				 
1dd2 d5				push de 
1dd3			 
1dd3 eb				ex de, hl 
1dd4			 
1dd4				;push af 
1dd4			 
1dd4			if DEBUG_FORTH_PUSH 
1dd4						DMARK "PHm" 
1dd4 f5				push af  
1dd5 3a e9 1d			ld a, (.dmark)  
1dd8 32 77 fb			ld (debug_mark),a  
1ddb 3a ea 1d			ld a, (.dmark+1)  
1dde 32 78 fb			ld (debug_mark+1),a  
1de1 3a eb 1d			ld a, (.dmark+2)  
1de4 32 79 fb			ld (debug_mark+2),a  
1de7 18 03			jr .pastdmark  
1de9 ..			.dmark: db "PHm"  
1dec f1			.pastdmark: pop af  
1ded			endm  
# End of macro DMARK
1ded				CALLMONITOR 
1ded cd 4d 17			call break_point_state  
1df0				endm  
# End of macro CALLMONITOR
1df0			endif	 
1df0 cd d0 11			call malloc	; on ret hl now contains allocated memory 
1df3				if DEBUG_FORTH_MALLOC_GUARD 
1df3 cc 93 51				call z,malloc_error 
1df6				endif 
1df6			 
1df6				 
1df6 c1				pop bc    ; get length 
1df7 d1				pop de   ;  get string start    
1df8			 
1df8				; hl has destination from malloc 
1df8			 
1df8 eb				ex de, hl    ; prep for ldir 
1df9			 
1df9 d5				push de   ; save malloc area for DSP later 
1dfa				;push hl   ; save malloc area for DSP later 
1dfa			 
1dfa			if DEBUG_FORTH_PUSH 
1dfa						DMARK "PHc" 
1dfa f5				push af  
1dfb 3a 0f 1e			ld a, (.dmark)  
1dfe 32 77 fb			ld (debug_mark),a  
1e01 3a 10 1e			ld a, (.dmark+1)  
1e04 32 78 fb			ld (debug_mark+1),a  
1e07 3a 11 1e			ld a, (.dmark+2)  
1e0a 32 79 fb			ld (debug_mark+2),a  
1e0d 18 03			jr .pastdmark  
1e0f ..			.dmark: db "PHc"  
1e12 f1			.pastdmark: pop af  
1e13			endm  
# End of macro DMARK
1e13				CALLMONITOR 
1e13 cd 4d 17			call break_point_state  
1e16				endm  
# End of macro CALLMONITOR
1e16			endif	 
1e16			 
1e16			 
1e16 ed b0			ldir 
1e18			 
1e18			 
1e18				; push malloc to data stack     macro?????  
1e18			 
1e18				FORTH_DSP_NEXT 
1e18 cd 6c 1c			call macro_forth_dsp_next 
1e1b				endm 
# End of macro FORTH_DSP_NEXT
1e1b			 
1e1b				; save value and type 
1e1b			 
1e1b 2a 0a f8			ld hl, (cli_data_sp) 
1e1e			 
1e1e				; save item type 
1e1e 3e 01			ld a,  DS_TYPE_STR 
1e20 77				ld (hl), a 
1e21 23				inc hl 
1e22			 
1e22				; get malloc word off stack 
1e22 d1				pop de 
1e23 73				ld (hl), e 
1e24 23				inc hl 
1e25 72				ld (hl), d 
1e26			 
1e26			 
1e26			 
1e26			if DEBUG_FORTH_PUSH 
1e26 2a 0a f8			ld hl, (cli_data_sp) 
1e29						DMARK "PHS" 
1e29 f5				push af  
1e2a 3a 3e 1e			ld a, (.dmark)  
1e2d 32 77 fb			ld (debug_mark),a  
1e30 3a 3f 1e			ld a, (.dmark+1)  
1e33 32 78 fb			ld (debug_mark+1),a  
1e36 3a 40 1e			ld a, (.dmark+2)  
1e39 32 79 fb			ld (debug_mark+2),a  
1e3c 18 03			jr .pastdmark  
1e3e ..			.dmark: db "PHS"  
1e41 f1			.pastdmark: pop af  
1e42			endm  
# End of macro DMARK
1e42				CALLMONITOR 
1e42 cd 4d 17			call break_point_state  
1e45				endm  
# End of macro CALLMONITOR
1e45			;	ex de,hl 
1e45			endif	 
1e45				; in case of spaces, skip the ptr past the copied string 
1e45				;pop af 
1e45				;ld (cli_origptr),hl 
1e45			 
1e45 c9				ret 
1e46			 
1e46			 
1e46			 
1e46			; TODO ascii push input onto stack given hl to start of input 
1e46			 
1e46			; identify type 
1e46			; if starts with a " then a string 
1e46			; otherwise it is a number 
1e46			;  
1e46			; if a string 
1e46			;     scan for ending " to get length of string to malloc for + 1 
1e46			;     malloc 
1e46			;     put pointer to string on stack first byte flags as string 
1e46			; 
1e46			; else a number 
1e46			;    look for number format identifier 
1e46			;    $xx hex 
1e46			;    %xxxxx bin 
1e46			;    xxxxx decimal 
1e46			;    convert number to 16bit word.  
1e46			;    malloc word + 1 with flag to identiy as num 
1e46			;    put pointer to number on stack 
1e46			;   
1e46			;  
1e46			  
1e46			forth_apush: 
1e46				; kernel push 
1e46			 
1e46			if DEBUG_FORTH_PUSH 
1e46						DMARK "PSH" 
1e46 f5				push af  
1e47 3a 5b 1e			ld a, (.dmark)  
1e4a 32 77 fb			ld (debug_mark),a  
1e4d 3a 5c 1e			ld a, (.dmark+1)  
1e50 32 78 fb			ld (debug_mark+1),a  
1e53 3a 5d 1e			ld a, (.dmark+2)  
1e56 32 79 fb			ld (debug_mark+2),a  
1e59 18 03			jr .pastdmark  
1e5b ..			.dmark: db "PSH"  
1e5e f1			.pastdmark: pop af  
1e5f			endm  
# End of macro DMARK
1e5f				CALLMONITOR 
1e5f cd 4d 17			call break_point_state  
1e62				endm  
# End of macro CALLMONITOR
1e62			endif	 
1e62				; identify input type 
1e62			 
1e62 7e				ld a,(hl) 
1e63 fe 22			cp '"' 
1e65 28 0a			jr z, .fapstr 
1e67 fe 24			cp '$' 
1e69 ca 91 1e			jp z, .faphex 
1e6c fe 25			cp '%' 
1e6e ca 79 1e			jp z, .fapbin 
1e71			;	cp 'b' 
1e71			;	jp z, .fabin 
1e71				; else decimal 
1e71			 
1e71				; TODO do decimal conversion 
1e71				; decimal is stored as a 16bit word 
1e71			 
1e71				; by default everything is a string if type is not detected 
1e71			.fapstr: ; 
1e71 fe 22			cp '"' 
1e73 20 01			jr nz, .strnoqu 
1e75 23				inc hl 
1e76			.strnoqu: 
1e76 c3 4b 1d			jp forth_push_str 
1e79			 
1e79			 
1e79			 
1e79			.fapbin:    ; push a binary string.  
1e79 11 00 00			ld de, 0   ; hold a 16bit value 
1e7c			 
1e7c 23			.fapbinshift:	inc hl  
1e7d 7e				ld a,(hl) 
1e7e fe 00			cp 0     ; done scanning  
1e80 28 0b			jr z, .fapbdone  	; got it in HL so push  
1e82			 
1e82				; left shift de 
1e82 eb				ex de, hl	 
1e83 29				add hl, hl 
1e84			 
1e84				; is 1 
1e84 fe 31			cp '1' 
1e86 20 02			jr nz, .binzero 
1e88 cb 4d			bit 1, l 
1e8a			.binzero: 
1e8a eb				ex de, hl	 ; save current de 
1e8b 18 ef			jr .fapbinshift 
1e8d			 
1e8d			.fapbdone: 
1e8d eb				ex de, hl 
1e8e c3 dd 1c			jp forth_push_numhl 
1e91			 
1e91			 
1e91			.faphex:   ; hex is always stored as a 16bit word 
1e91				; skip number prefix 
1e91 23				inc hl 
1e92				; turn ascii into number 
1e92 cd c0 10			call get_word_hl	; ret 16bit word in hl 
1e95			 
1e95 c3 dd 1c			jp forth_push_numhl 
1e98			 
1e98 00				 nop 
1e99			 
1e99			.fabin:   ; TODO bin conversion 
1e99			 
1e99			 
1e99 c9				ret 
1e9a			 
1e9a			 
1e9a			; get either a string ptr or a 16bit word from the data stack 
1e9a			 
1e9a			FORTH_DSP: macro 
1e9a				call macro_forth_dsp 
1e9a				endm 
1e9a			 
1e9a			macro_forth_dsp: 
1e9a				; data stack pointer points to current word on tos 
1e9a			 
1e9a 2a 0a f8			ld hl,(cli_data_sp) 
1e9d			 
1e9d				if DEBUG_FORTH_PUSH 
1e9d						DMARK "DSP" 
1e9d f5				push af  
1e9e 3a b2 1e			ld a, (.dmark)  
1ea1 32 77 fb			ld (debug_mark),a  
1ea4 3a b3 1e			ld a, (.dmark+1)  
1ea7 32 78 fb			ld (debug_mark+1),a  
1eaa 3a b4 1e			ld a, (.dmark+2)  
1ead 32 79 fb			ld (debug_mark+2),a  
1eb0 18 03			jr .pastdmark  
1eb2 ..			.dmark: db "DSP"  
1eb5 f1			.pastdmark: pop af  
1eb6			endm  
# End of macro DMARK
1eb6			 
1eb6 cd c8 51				call display_data_sp 
1eb9				;call break_point_state 
1eb9				;rst 030h 
1eb9				CALLMONITOR 
1eb9 cd 4d 17			call break_point_state  
1ebc				endm  
# End of macro CALLMONITOR
1ebc				endif 
1ebc			 
1ebc c9				ret 
1ebd			 
1ebd			; return hl to start of value on stack 
1ebd			 
1ebd			FORTH_DSP_VALUE: macro 
1ebd				call macro_forth_dsp_value 
1ebd				endm 
1ebd			 
1ebd			macro_forth_dsp_value: 
1ebd			 
1ebd				FORTH_DSP 
1ebd cd 9a 1e			call macro_forth_dsp 
1ec0				endm 
# End of macro FORTH_DSP
1ec0			 
1ec0 d5				push de 
1ec1			 
1ec1 23				inc hl ; skip type 
1ec2			 
1ec2 5e				ld e, (hl) 
1ec3 23				inc hl 
1ec4 56				ld d, (hl) 
1ec5 eb				ex de,hl  
1ec6			 
1ec6 d1				pop de 
1ec7			 
1ec7 c9				ret 
1ec8			 
1ec8			; return hl to start of value to second item on stack 
1ec8			 
1ec8			FORTH_DSP_VALUEM1: macro 
1ec8				call macro_forth_dsp_value_m1 
1ec8				endm 
1ec8			 
1ec8			macro_forth_dsp_value_m1: 
1ec8			 
1ec8				FORTH_DSP 
1ec8 cd 9a 1e			call macro_forth_dsp 
1ecb				endm 
# End of macro FORTH_DSP
1ecb			 
1ecb 2b				dec hl 
1ecc 2b				dec hl 
1ecd			;	dec hl 
1ecd			 
1ecd d5				push de 
1ece			 
1ece 5e				ld e, (hl) 
1ecf 23				inc hl 
1ed0 56				ld d, (hl) 
1ed1 eb				ex de,hl  
1ed2			 
1ed2 d1				pop de 
1ed3			 
1ed3 c9				ret 
1ed4			 
1ed4				 
1ed4			 
1ed4			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1ed4			 
1ed4			FORTH_DSP_POP: macro 
1ed4				call macro_forth_dsp_pop 
1ed4				endm 
1ed4			 
1ed4			 
1ed4			; get the tos data type 
1ed4			 
1ed4			FORTH_DSP_TYPE:   macro 
1ed4			 
1ed4				;FORTH_DSP_VALUE 
1ed4				FORTH_DSP 
1ed4				 
1ed4				; hl points to value 
1ed4				; check type 
1ed4			 
1ed4				ld a,(hl) 
1ed4			 
1ed4				endm 
1ed4			 
1ed4			; load the tos value into hl 
1ed4			 
1ed4			 
1ed4			FORTH_DSP_VALUEHL:  macro 
1ed4				call macro_dsp_valuehl 
1ed4				endm 
1ed4			 
1ed4			 
1ed4			 
1ed4			macro_dsp_valuehl: 
1ed4				FORTH_DSP_VALUE 
1ed4 cd bd 1e			call macro_forth_dsp_value 
1ed7				endm 
# End of macro FORTH_DSP_VALUE
1ed7			 
1ed7				;FORTH_ERR_TOS_NOTNUM 
1ed7			 
1ed7				;inc hl   ; skip type id 
1ed7			 
1ed7			;	push de 
1ed7			; 
1ed7			;	ld e, (hl) 
1ed7			;	inc hl 
1ed7			;	ld d, (hl) 
1ed7			;	ex de,hl  
1ed7			 
1ed7			;	pop de 
1ed7			 
1ed7				if DEBUG_FORTH_PUSH 
1ed7						DMARK "DVL" 
1ed7 f5				push af  
1ed8 3a ec 1e			ld a, (.dmark)  
1edb 32 77 fb			ld (debug_mark),a  
1ede 3a ed 1e			ld a, (.dmark+1)  
1ee1 32 78 fb			ld (debug_mark+1),a  
1ee4 3a ee 1e			ld a, (.dmark+2)  
1ee7 32 79 fb			ld (debug_mark+2),a  
1eea 18 03			jr .pastdmark  
1eec ..			.dmark: db "DVL"  
1eef f1			.pastdmark: pop af  
1ef0			endm  
# End of macro DMARK
1ef0				CALLMONITOR 
1ef0 cd 4d 17			call break_point_state  
1ef3				endm  
# End of macro CALLMONITOR
1ef3				endif 
1ef3 c9				ret 
1ef4			 
1ef4			forth_apushstrhl:      
1ef4				; push of string requires use of cli_origptr 
1ef4				; bodge use 
1ef4			 
1ef4				; get current cli_origptr, save, update with temp pointer  
1ef4 ed 5b 26 f8		ld de, (cli_origptr) 
1ef8 22 26 f8			ld (cli_origptr), hl 
1efb d5				push de 
1efc cd 46 1e			call forth_apush 
1eff d1				pop de 
1f00 ed 53 26 f8		ld (cli_origptr), de 
1f04 c9			        ret	 
1f05			 
1f05			 
1f05			; increase loop stack pointer and save hl to it 
1f05				 
1f05			FORTH_LOOP_NEXT: macro 
1f05				call macro_forth_loop_next 
1f05				;nop 
1f05				endm 
1f05			 
1f05			macro_forth_loop_next: 
1f05				if DEBUG_FORTH_STACK_GUARD 
1f05 cd 2d 62				call check_stacks 
1f08				endif 
1f08 e5				push hl 
1f09 d5				push de 
1f0a eb				ex de,hl 
1f0b 2a 0c f8			ld hl,(cli_loop_sp) 
1f0e 23				inc hl 
1f0f 23				inc hl 
1f10					if DEBUG_FORTH_WORDS 
1f10						DMARK "LNX" 
1f10 f5				push af  
1f11 3a 25 1f			ld a, (.dmark)  
1f14 32 77 fb			ld (debug_mark),a  
1f17 3a 26 1f			ld a, (.dmark+1)  
1f1a 32 78 fb			ld (debug_mark+1),a  
1f1d 3a 27 1f			ld a, (.dmark+2)  
1f20 32 79 fb			ld (debug_mark+2),a  
1f23 18 03			jr .pastdmark  
1f25 ..			.dmark: db "LNX"  
1f28 f1			.pastdmark: pop af  
1f29			endm  
# End of macro DMARK
1f29						CALLMONITOR 
1f29 cd 4d 17			call break_point_state  
1f2c				endm  
# End of macro CALLMONITOR
1f2c					endif 
1f2c 22 0c f8			ld (cli_loop_sp),hl 
1f2f 73				ld (hl), e 
1f30 23				inc hl 
1f31 72				ld (hl), d 
1f32 d1				pop de    ; been reversed so save a swap on restore 
1f33 e1				pop hl 
1f34				if DEBUG_FORTH_STACK_GUARD 
1f34 cd 2d 62				call check_stacks 
1f37				endif 
1f37 c9				ret 
1f38			 
1f38			; get current ret stack pointer and save to hl  
1f38				 
1f38			FORTH_LOOP_TOS: macro 
1f38				call macro_forth_loop_tos 
1f38				endm 
1f38			 
1f38			macro_forth_loop_tos: 
1f38 d5				push de 
1f39 2a 0c f8			ld hl,(cli_loop_sp) 
1f3c 5e				ld e, (hl) 
1f3d 23				inc hl 
1f3e 56				ld d, (hl) 
1f3f eb				ex de, hl 
1f40 d1				pop de 
1f41 c9				ret 
1f42			 
1f42			; pop loop stack pointer 
1f42				 
1f42			FORTH_LOOP_POP: macro 
1f42				call macro_forth_loop_pop 
1f42				endm 
1f42			 
1f42			 
1f42			macro_forth_loop_pop: 
1f42				if DEBUG_FORTH_STACK_GUARD 
1f42					DMARK "LPP" 
1f42 f5				push af  
1f43 3a 57 1f			ld a, (.dmark)  
1f46 32 77 fb			ld (debug_mark),a  
1f49 3a 58 1f			ld a, (.dmark+1)  
1f4c 32 78 fb			ld (debug_mark+1),a  
1f4f 3a 59 1f			ld a, (.dmark+2)  
1f52 32 79 fb			ld (debug_mark+2),a  
1f55 18 03			jr .pastdmark  
1f57 ..			.dmark: db "LPP"  
1f5a f1			.pastdmark: pop af  
1f5b			endm  
# End of macro DMARK
1f5b cd 2d 62				call check_stacks 
1f5e					FORTH_CHK_LOOP_UNDER 
1f5e e5				push hl 
1f5f d5				push de 
1f60 2a 0c f8			ld hl,(cli_loop_sp) 
1f63 11 86 f5			ld de, cli_loop_stack 
1f66 cd 27 0d			call cmp16 
1f69 da 47 63			jp c, fault_loop_under 
1f6c d1				pop de 
1f6d e1				pop hl 
1f6e				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1f6e				endif 
1f6e e5				push hl 
1f6f 2a 0c f8			ld hl,(cli_loop_sp) 
1f72 2b				dec hl 
1f73 2b				dec hl 
1f74 22 0c f8			ld (cli_loop_sp), hl 
1f77				; TODO do stack underflow checks 
1f77 e1				pop hl 
1f78				if DEBUG_FORTH_STACK_GUARD 
1f78 cd 2d 62				call check_stacks 
1f7b					FORTH_CHK_LOOP_UNDER 
1f7b e5				push hl 
1f7c d5				push de 
1f7d 2a 0c f8			ld hl,(cli_loop_sp) 
1f80 11 86 f5			ld de, cli_loop_stack 
1f83 cd 27 0d			call cmp16 
1f86 da 47 63			jp c, fault_loop_under 
1f89 d1				pop de 
1f8a e1				pop hl 
1f8b				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1f8b				endif 
1f8b c9				ret 
1f8c			 
1f8c			macro_forth_dsp_pop: 
1f8c			 
1f8c e5				push hl 
1f8d			 
1f8d				; release malloc data 
1f8d			 
1f8d				if DEBUG_FORTH_STACK_GUARD 
1f8d cd 2d 62				call check_stacks 
1f90					FORTH_CHK_DSP_UNDER 
1f90 e5				push hl 
1f91 d5				push de 
1f92 2a 0a f8			ld hl,(cli_data_sp) 
1f95 11 84 f3			ld de, cli_data_stack 
1f98 cd 27 0d			call cmp16 
1f9b da 3b 63			jp c, fault_dsp_under 
1f9e d1				pop de 
1f9f e1				pop hl 
1fa0				endm 
# End of macro FORTH_CHK_DSP_UNDER
1fa0				endif 
1fa0				;ld hl,(cli_data_sp) 
1fa0			if DEBUG_FORTH_DOT 
1fa0				DMARK "DPP" 
1fa0				CALLMONITOR 
1fa0			endif	 
1fa0			 
1fa0			 
1fa0			if FORTH_ENABLE_DSPPOPFREE 
1fa0			 
1fa0				FORTH_DSP 
1fa0 cd 9a 1e			call macro_forth_dsp 
1fa3				endm 
# End of macro FORTH_DSP
1fa3			 
1fa3 7e				ld a, (hl) 
1fa4 fe 01			cp DS_TYPE_STR 
1fa6 20 07			jr nz, .skippopfree 
1fa8			 
1fa8				FORTH_DSP_VALUEHL 
1fa8 cd d4 1e			call macro_dsp_valuehl 
1fab				endm 
# End of macro FORTH_DSP_VALUEHL
1fab 00				nop 
1fac			if DEBUG_FORTH_DOT 
1fac				DMARK "DPf" 
1fac				CALLMONITOR 
1fac			endif	 
1fac cd 9a 12			call free 
1faf			.skippopfree: 
1faf				 
1faf			 
1faf			endif 
1faf			 
1faf			if DEBUG_FORTH_DOT_KEY 
1faf				DMARK "DP2" 
1faf				CALLMONITOR 
1faf			endif	 
1faf			 
1faf				; move pointer down 
1faf			 
1faf 2a 0a f8			ld hl,(cli_data_sp) 
1fb2 2b				dec hl 
1fb3 2b				dec hl 
1fb4			; PARSEV5 
1fb4 2b				dec hl 
1fb5 22 0a f8			ld (cli_data_sp), hl 
1fb8			 
1fb8				if DEBUG_FORTH_STACK_GUARD 
1fb8 cd 2d 62				call check_stacks 
1fbb					FORTH_CHK_DSP_UNDER 
1fbb e5				push hl 
1fbc d5				push de 
1fbd 2a 0a f8			ld hl,(cli_data_sp) 
1fc0 11 84 f3			ld de, cli_data_stack 
1fc3 cd 27 0d			call cmp16 
1fc6 da 3b 63			jp c, fault_dsp_under 
1fc9 d1				pop de 
1fca e1				pop hl 
1fcb				endm 
# End of macro FORTH_CHK_DSP_UNDER
1fcb				endif 
1fcb			 
1fcb e1				pop hl 
1fcc			 
1fcc c9				ret 
1fcd			 
1fcd			getwordathl: 
1fcd				; hl points to an address 
1fcd				; load hl with the word at that address 
1fcd			 
1fcd d5				push de 
1fce			 
1fce 5e				ld e, (hl) 
1fcf 23				inc hl 
1fd0 56				ld d, (hl) 
1fd1 eb				ex de, hl 
1fd2			 
1fd2 d1				pop de 
1fd3 c9				ret 
1fd4			 
1fd4			 
1fd4			 
1fd4			 
1fd4			 
1fd4			; eof 
1fd4			 
# End of file forth_stackopsv5.asm
1fd4			endif 
1fd4			 
1fd4			user_word_eol:  
1fd4				; hl contains the pointer to where to create a linked list item from the end 
1fd4				; of the user dict to continue on at the system word dict 
1fd4				 
1fd4				; poke the stub of the word list linked list to repoint to rom words 
1fd4			 
1fd4				; stub format 
1fd4				; db   word id 
1fd4				; dw    link to next word 
1fd4			        ; db char length of token 
1fd4				; db string + 0 term 
1fd4				; db exec code....  
1fd4			 
1fd4 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1fd6 77				ld (hl), a		; word id 
1fd7 23				inc hl 
1fd8			 
1fd8 11 9e 21			ld de, sysdict 
1fdb 73				ld (hl), e		; next word link ie system dict 
1fdc 23				inc hl 
1fdd 72				ld (hl), d		; next word link ie system dict 
1fde 23				inc hl	 
1fdf			 
1fdf			;	ld (hl), sysdict		; next word link ie system dict 
1fdf			;	inc hl 
1fdf			;	inc hl 
1fdf			 
1fdf			;	inc hl 
1fdf			;	inc hl 
1fdf			 
1fdf 3e 02			ld a, 2			; word length is 0 
1fe1 77				ld (hl), a	 
1fe2 23				inc hl 
1fe3			 
1fe3 3e 7e			ld a, '~'			; word length is 0 
1fe5 77				ld (hl), a	 
1fe6 23				inc hl 
1fe7 3e 00			ld a, 0			; save empty word 
1fe9 77				ld (hl), a 
1fea			 
1fea c9				ret 
1feb			 
1feb				 
1feb			 
1feb			forthexec_cleanup: 
1feb				FORTH_RSP_POP 
1feb cd a5 1c			call macro_forth_rsp_pop 
1fee				endm 
# End of macro FORTH_RSP_POP
1fee c9				ret 
1fef			 
1fef			forth_call_hl: 
1fef				; taking hl 
1fef e5				push hl 
1ff0 c9				ret 
1ff1			 
1ff1			; this is called to reset Forth system but keep existing uwords etc 
1ff1			 
1ff1			forth_warmstart: 
1ff1				; setup stack over/under flow checks 
1ff1				if DEBUG_FORTH_STACK_GUARD 
1ff1 cd 13 62				call chk_stk_init 
1ff4				endif 
1ff4			 
1ff4				; init stack pointers  - * these stacks go upwards *  
1ff4 21 88 f7			ld hl, cli_ret_stack 
1ff7 22 0e f8			ld (cli_ret_sp), hl	 
1ffa				; set bottom of stack 
1ffa 3e 00			ld a,0 
1ffc 77				ld (hl),a 
1ffd 23				inc hl 
1ffe 77				ld (hl),a 
1fff			 
1fff 21 84 f3			ld hl, cli_data_stack 
2002 22 0a f8			ld (cli_data_sp), hl	 
2005				; set bottom of stack 
2005 3e 00			ld a,0 
2007 77				ld (hl),a 
2008 23				inc hl 
2009 77				ld (hl),a 
200a			 
200a 21 86 f5			ld hl, cli_loop_stack 
200d 22 0c f8			ld (cli_loop_sp), hl	 
2010				; set bottom of stack 
2010 3e 00			ld a,0 
2012 77				ld (hl),a 
2013 23				inc hl 
2014 77				ld (hl),a 
2015			 
2015				; init extent of current open file 
2015			 
2015 3e 00			ld a, 0 
2017 32 59 f8			ld (store_openext), a 
201a			 
201a c9				ret 
201b			 
201b			 
201b			; Cold Start - this is called to setup the whole Forth system 
201b			 
201b			forth_init: 
201b			 
201b				; setup stack over/under flow checks 
201b			 
201b			;	if DEBUG_FORTH_STACK_GUARD 
201b			;		call chk_stk_init 
201b			;	endif 
201b			 
201b				; enable auto display updates (slow.....) 
201b			 
201b 3e 01			ld a, 1 
201d 32 24 f8			ld (cli_autodisplay), a 
2020			 
2020			 
2020			 
2020				; show start up screen 
2020			 
2020 cd d5 0a			call clear_display 
2023			 
2023 3e 00			ld a,0 
2025 32 46 f8			ld (f_cursor_ptr), a 
2028			 
2028				; set start of word list in start of ram - for use when creating user words 
2028			 
2028 21 00 80			ld hl, baseram 
202b 22 1a f1			ld (os_last_new_uword), hl 
202e cd d4 1f			call user_word_eol 
2031				 
2031			;		call display_data_sp 
2031			;		call next_page_prompt 
2031			 
2031			 
2031			 
2031			 
2031 c9				ret 
2032			 
2032 .. 00		.bootforth: db " Forth Kernel Init ",0 
2046			 
2046			; TODO push to stack 
2046			 
2046			;  
2046			 
2046			if FORTH_PARSEV2 
2046			 
2046			 
2046				include "forth_parserv2.asm" 
2046			 
2046			endif 
2046			 
2046			 
2046			; parse cli version 1 
2046			 
2046			if FORTH_PARSEV1 
2046			 
2046			 
2046			 
2046			      include "forth_parserv1.asm" 
2046			endif 
2046				 
2046			if FORTH_PARSEV3 
2046			 
2046			 
2046			 
2046			      include "forth_parserv3.asm" 
2046				include "forth_wordsv3.asm" 
2046			endif 
2046			 
2046			if FORTH_PARSEV4 
2046			 
2046			 
2046			 
2046			      include "forth_parserv4.asm" 
2046				include "forth_wordsv4.asm" 
2046			endif 
2046			 
2046			if FORTH_PARSEV5 
2046			 
2046			 
2046			 
2046			      include "forth_parserv5.asm" 
2046			 
2046			 
2046			; A better parser without using malloc and string copies all over the place.  
2046			; Exec in situ should be faster 
2046			 
2046			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
2046			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
2046			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
2046			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
2046			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
2046			WORD_SYS_END: equ 0   ; Opcode for all user words 
2046			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
2046			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
2046			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
2046			 
2046			; Core word preamble macro 
2046			 
2046			CWHEAD:   macro nxtword opcode lit len opflags 
2046				db WORD_SYS_CORE+opcode             
2046				; internal op code number 
2046				dw nxtword            
2046				; link to next dict word block 
2046				db len + 1 
2046				; literal length of dict word inc zero term 
2046				db lit,0              
2046				; literal dict word 
2046			        ; TODO db opflags        
2046				endm 
2046			 
2046			 
2046			NEXTW: macro  
2046				jp macro_next 
2046				endm 
2046			 
2046			macro_next: 
2046			if DEBUG_FORTH_PARSE_KEY 
2046				DMARK "NXT" 
2046				CALLMONITOR 
2046			endif	 
2046			;	inc hl  ; skip token null term  
2046 ed 4b 28 f8		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
204a ed 5b 26 f8		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
204e 2a 1e f1			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2051			if DEBUG_FORTH_PARSE_KEY 
2051				DMARK "}AA" 
2051				CALLMONITOR 
2051			endif	 
2051 c3 54 21			jp execnext 
2054				;jp exec1 
2054			       
2054			 
2054			 
2054			; Another go at the parser to compile  
2054			 
2054			 
2054			; TODO rework parser to change all of the string words to byte tokens 
2054			; TODO do a search for  
2054			 
2054			; TODO first run normal parser to zero term sections 
2054			; TODO for each word do a token look up to get the op code 
2054			; TODO need some means to flag to the exec that this is a byte code form    
2054			 
2054			 
2054			forthcompile: 
2054			 
2054			; 
2054			; line parse: 
2054			;       parse raw input buffer 
2054			;       tokenise the words 
2054			;       malloc new copy (for looping etc) 
2054			;       copy to malloc + current pc in line to start of string and add line term 
2054			;       save on new rsp 
2054			; 
2054			 
2054			; hl to point to the line to tokenise 
2054			 
2054			;	push hl 
2054 22 1e f1			ld (os_tok_ptr), hl  ; save ptr to string 
2057			 
2057			;	ld a,0		; string term on input 
2057			;	call strlent 
2057			 
2057			;	ld (os_tok_len), hl	 ; save string length 
2057			 
2057			;if DEBUG_FORTH_TOK 
2057			;	ex de,hl		 
2057			;endif 
2057			 
2057			;	pop hl 		; get back string pointer 
2057			 
2057			if DEBUG_FORTH_TOK 
2057						DMARK "TOc" 
2057				CALLMONITOR 
2057			endif 
2057 7e			.cptoken2:    ld a,(hl) 
2058 23				inc hl 
2059 fe 7f			cp FORTH_END_BUFFER 
205b 28 29			jr z, .cptokendone2 
205d fe 00			cp 0 
205f 28 25			jr z, .cptokendone2 
2061 fe 22			cp '"' 
2063 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
2065 fe 20			cp ' ' 
2067 20 ee			jr nz,  .cptoken2 
2069			 
2069			; TODO consume comments held between ( and ) 
2069			 
2069				; we have a space so change to zero term for dict match later 
2069 2b				dec hl 
206a 3e 00			ld a,0 
206c 77				ld (hl), a 
206d 23				inc hl 
206e 18 e7			jr .cptoken2 
2070				 
2070			 
2070			.cptokenstr2: 
2070				; skip all white space until either eol (because forgot to term) or end double quote 
2070			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
2070				;inc hl ; skip current double quote 
2070 7e				ld a,(hl) 
2071 23				inc hl 
2072 fe 22			cp '"' 
2074 28 e1			jr z, .cptoken2 
2076 fe 7f			cp FORTH_END_BUFFER 
2078 28 0c			jr z, .cptokendone2 
207a fe 00			cp 0 
207c 28 08			jr z, .cptokendone2 
207e fe 20			cp ' ' 
2080 28 02			jr z, .cptmp2 
2082 18 ec			jr .cptokenstr2 
2084			 
2084			.cptmp2:	; we have a space so change to zero term for dict match later 
2084				;dec hl 
2084				;ld a,"-"	; TODO remove this when working 
2084				;ld (hl), a 
2084				;inc hl 
2084 18 ea			jr .cptokenstr2 
2086			 
2086			.cptokendone2: 
2086				;inc hl 
2086 3e 7f			ld a, FORTH_END_BUFFER 
2088 77				ld (hl),a 
2089 23				inc hl 
208a 3e 21			ld a, '!' 
208c 77				ld (hl),a 
208d			 
208d 2a 1e f1			ld hl,(os_tok_ptr) 
2090			         
2090			if DEBUG_FORTH_TOK 
2090						DMARK "Tc1" 
2090				CALLMONITOR 
2090			endif 
2090			 
2090				; push exec string to top of return stack 
2090				FORTH_RSP_NEXT 
2090 cd 84 1c			call macro_forth_rsp_next 
2093				endm 
# End of macro FORTH_RSP_NEXT
2093 c9				ret 
2094			 
2094			; Another go at the parser need to simplify the process 
2094			 
2094			forthparse: 
2094			 
2094			; 
2094			; line parse: 
2094			;       parse raw input buffer 
2094			;       tokenise the words 
2094			;       malloc new copy (for looping etc) 
2094			;       copy to malloc + current pc in line to start of string and add line term 
2094			;       save on new rsp 
2094			; 
2094			 
2094			; hl to point to the line to tokenise 
2094			 
2094			;	push hl 
2094 22 1e f1			ld (os_tok_ptr), hl  ; save ptr to string 
2097			 
2097			;	ld a,0		; string term on input 
2097			;	call strlent 
2097			 
2097			;	ld (os_tok_len), hl	 ; save string length 
2097			 
2097			;if DEBUG_FORTH_TOK 
2097			;	ex de,hl		 
2097			;endif 
2097			 
2097			;	pop hl 		; get back string pointer 
2097			 
2097			if DEBUG_FORTH_TOK 
2097						DMARK "TOK" 
2097				CALLMONITOR 
2097			endif 
2097 7e			.ptoken2:    ld a,(hl) 
2098 23				inc hl 
2099 fe 7f			cp FORTH_END_BUFFER 
209b 28 29			jr z, .ptokendone2 
209d fe 00			cp 0 
209f 28 25			jr z, .ptokendone2 
20a1 fe 22			cp '"' 
20a3 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
20a5 fe 20			cp ' ' 
20a7 20 ee			jr nz,  .ptoken2 
20a9			 
20a9			; TODO consume comments held between ( and ) 
20a9			 
20a9				; we have a space so change to zero term for dict match later 
20a9 2b				dec hl 
20aa 3e 00			ld a,0 
20ac 77				ld (hl), a 
20ad 23				inc hl 
20ae 18 e7			jr .ptoken2 
20b0				 
20b0			 
20b0			.ptokenstr2: 
20b0				; skip all white space until either eol (because forgot to term) or end double quote 
20b0			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
20b0				;inc hl ; skip current double quote 
20b0 7e				ld a,(hl) 
20b1 23				inc hl 
20b2 fe 22			cp '"' 
20b4 28 e1			jr z, .ptoken2 
20b6 fe 7f			cp FORTH_END_BUFFER 
20b8 28 0c			jr z, .ptokendone2 
20ba fe 00			cp 0 
20bc 28 08			jr z, .ptokendone2 
20be fe 20			cp ' ' 
20c0 28 02			jr z, .ptmp2 
20c2 18 ec			jr .ptokenstr2 
20c4			 
20c4			.ptmp2:	; we have a space so change to zero term for dict match later 
20c4				;dec hl 
20c4				;ld a,"-"	; TODO remove this when working 
20c4				;ld (hl), a 
20c4				;inc hl 
20c4 18 ea			jr .ptokenstr2 
20c6			 
20c6			.ptokendone2: 
20c6				;inc hl 
20c6 3e 7f			ld a, FORTH_END_BUFFER 
20c8 77				ld (hl),a 
20c9 23				inc hl 
20ca 3e 21			ld a, '!' 
20cc 77				ld (hl),a 
20cd			 
20cd 2a 1e f1			ld hl,(os_tok_ptr) 
20d0			         
20d0			if DEBUG_FORTH_TOK 
20d0						DMARK "TK1" 
20d0				CALLMONITOR 
20d0			endif 
20d0			 
20d0				; push exec string to top of return stack 
20d0				FORTH_RSP_NEXT 
20d0 cd 84 1c			call macro_forth_rsp_next 
20d3				endm 
# End of macro FORTH_RSP_NEXT
20d3 c9				ret 
20d4			 
20d4			; 
20d4			;	; malloc size + buffer pointer + if is loop flag 
20d4			;	ld hl,(os_tok_len) 		 ; get string length 
20d4			; 
20d4			;	ld a,l 
20d4			; 
20d4			;	cp 0			; we dont want to use a null string 
20d4			;	ret z 
20d4			; 
20d4			;;	add 3    ; prefix malloc with buffer for current word ptr 
20d4			; 
20d4			;	add 5     ; TODO when certain not over writing memory remove 
20d4			; 
20d4			;		 
20d4			; 
20d4			;if DEBUG_FORTH_TOK 
20d4			;			DMARK "TKE" 
20d4			;	CALLMONITOR 
20d4			;endif 
20d4			; 
20d4			;	ld l,a 
20d4			;	ld h,0 
20d4			;;	push hl   ; save required space for the copy later 
20d4			;	call malloc 
20d4			;if DEBUG_FORTH_TOK 
20d4			;			DMARK "TKM" 
20d4			;	CALLMONITOR 
20d4			;endif 
20d4			;	if DEBUG_FORTH_MALLOC_GUARD 
20d4			;		push af 
20d4			;		call ishlzero 
20d4			;;		ld a, l 
20d4			;;		add h 
20d4			;;		cp 0 
20d4			;		pop af 
20d4			;		 
20d4			;		call z,malloc_error 
20d4			;	endif 
20d4			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
20d4			; 
20d4			; 
20d4			;if DEBUG_FORTH_TOK 
20d4			;			DMARK "TKR" 
20d4			;	CALLMONITOR 
20d4			;endif 
20d4			; 
20d4			;	FORTH_RSP_NEXT 
20d4			; 
20d4			;	;inc hl	 ; go past current buffer pointer 
20d4			;	;inc hl 
20d4			;	;inc hl   ; and past if loop flag 
20d4			;		; TODO Need to set flag  
20d4			; 
20d4			;	 
20d4			;	 
20d4			;	ex de,hl	; malloc is dest 
20d4			;	ld hl, (os_tok_len) 
20d4			;;	pop bc 
20d4			;	ld c, l                
20d4			;	ld b,0 
20d4			;	ld hl, (os_tok_ptr) 
20d4			; 
20d4			;if DEBUG_FORTH_TOK 
20d4			;			DMARK "TKT" 
20d4			;	CALLMONITOR 
20d4			;endif 
20d4			; 
20d4			;	; do str cpy 
20d4			; 
20d4			;	ldir      ; copy byte in hl to de 
20d4			; 
20d4			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
20d4			; 
20d4			;if DEBUG_FORTH_TOK 
20d4			; 
20d4			;			DMARK "TKY" 
20d4			;	CALLMONITOR 
20d4			;endif 
20d4			;	;ld a,0 
20d4			;	;ld a,FORTH_END_BUFFER 
20d4			;	ex de, hl 
20d4			;	;dec hl			 ; go back over the space delim at the end of word 
20d4			;	;ld (hl),a 
20d4			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
20d4			;	ld a,FORTH_END_BUFFER 
20d4			;	ld (hl),a 
20d4			;	inc hl 
20d4			;	ld a,FORTH_END_BUFFER 
20d4			;	ld (hl),a 
20d4			; 
20d4			;	; init the malloc area data 
20d4			;	; set pc for in current area 
20d4			;	;ld hl, (os_tok_malloc) 
20d4			;	;inc hl 
20d4			;	;inc hl 
20d4			;	;inc hl 
20d4			;	;ex de,hl 
20d4			;	;ld hl, (os_tok_malloc) 
20d4			;	;ld (hl),e 
20d4			;	;inc hl 
20d4			;	;ld (hl),d 
20d4			; 
20d4			; 
20d4			;	ld hl,(os_tok_malloc) 
20d4			;if DEBUG_FORTH_PARSE_KEY 
20d4			;			DMARK "TKU" 
20d4			;	CALLMONITOR 
20d4			;endif 
20d4			; 
20d4			;	ret 
20d4			 
20d4			forthexec: 
20d4			 
20d4			; line exec: 
20d4			; forth parser 
20d4			 
20d4			; 
20d4			;       get current exec line on rsp 
20d4			 
20d4				FORTH_RSP_TOS 
20d4 cd 9b 1c			call macro_forth_rsp_tos 
20d7				endm 
# End of macro FORTH_RSP_TOS
20d7			 
20d7			;       restore current pc - hl points to malloc of data 
20d7			 
20d7				;ld e, (hl) 
20d7				;inc hl 
20d7				;ld d, (hl) 
20d7				;ex de,hl 
20d7			 
20d7			 
20d7			exec1: 
20d7 22 1e f1			ld (os_tok_ptr), hl 
20da			 
20da				; copy our PC to working vars  
20da 22 28 f8			ld (cli_ptr), hl 
20dd 22 26 f8			ld (cli_origptr), hl 
20e0			 
20e0 7e				ld a,(hl) 
20e1 fe 7f			cp FORTH_END_BUFFER 
20e3 c8				ret z 
20e4			 
20e4				; skip any nulls 
20e4			 
20e4 fe 00			cp 0 
20e6 20 03			jr nz, .execword 
20e8 23				inc hl 
20e9 18 ec			jr exec1 
20eb			 
20eb			 
20eb			.execword: 
20eb			 
20eb			 
20eb			 
20eb			if DEBUG_FORTH_PARSE_KEY 
20eb						DMARK "KYQ" 
20eb				CALLMONITOR 
20eb			endif 
20eb			;       while at start of word: 
20eb			; get start of dict (in user area first) 
20eb			 
20eb 21 00 80		ld hl, baseram 
20ee			;ld hl, sysdict 
20ee 22 2a f8		ld (cli_nextword),hl 
20f1			;           match word at pc 
20f1			;           exec word 
20f1			;           or push to dsp 
20f1			;           forward to next token 
20f1			;           if line term pop rsp and exit 
20f1			;        
20f1			 
20f1			if DEBUG_FORTH_PARSE_KEY 
20f1						DMARK "KYq" 
20f1				CALLMONITOR 
20f1			endif 
20f1			 
20f1			; 
20f1			; word comp 
20f1			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
20f1			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
20f1			;    move to start of word  
20f1			;    compare word to cli_token 
20f1			 
20f1			.execpnword:	; HL at start of a word in the dictionary to check 
20f1			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
20f1			;	ld (cli_ptr), hl 
20f1			 
20f1 2a 2a f8			ld hl,(cli_nextword) 
20f4			 
20f4 cd 97 21			call forth_tok_next 
20f7			; tok next start here 
20f7			;	; TODO skip compiled symbol for now 
20f7			;	inc hl 
20f7			; 
20f7			;	; save pointer to next word 
20f7			; 
20f7			;	; hl now points to the address of the next word pointer  
20f7			;	ld e, (hl) 
20f7			;	inc hl 
20f7			;	ld d, (hl) 
20f7			;	inc l 
20f7			; 
20f7			;	ex de,hl 
20f7			;if DEBUG_FORTH_PARSE_NEXTWORD 
20f7			;	push bc 
20f7			;	ld bc, (cli_nextword) 
20f7			;			DMARK "NXW" 
20f7			;	CALLMONITOR 
20f7			;	pop bc 
20f7			;endif 
20f7			; tok next end here 
20f7 22 2a f8			ld (cli_nextword), hl     ; save for next check if no match on this word 
20fa eb				ex de, hl 
20fb			 
20fb			 
20fb				; save the pointer of the current token - 1 to check against 
20fb				 
20fb 22 2e f8			ld (cli_token), hl   
20fe				; TODO maybe remove below save if no debug 
20fe				; save token string ptr for any debug later 
20fe 23				inc hl  
20ff 22 30 f8			ld (cli_origtoken), hl 
2102 2b				dec hl 
2103				; save pointer to the start of the next dictionay word 
2103 7e				ld a,(hl)   ; get string length 
2104 47				ld b,a 
2105			.execpnwordinc:  
2105 23				inc hl 
2106 10 fd			djnz .execpnwordinc 
2108 22 2c f8			ld (cli_execword), hl      ; save start of this words code 
210b			 
210b				; now check the word token against the string being parsed 
210b			 
210b 2a 2e f8			ld hl,(cli_token) 
210e 23				inc hl     ; skip string length (use zero term instead to end) 
210f 22 2e f8			ld (cli_token), hl 
2112			 
2112			if DEBUG_FORTH_PARSE_KEY 
2112						DMARK "KY2" 
2112			endif 
2112			if DEBUG_FORTH_PARSE_EXEC 
2112				; see if disabled 
2112			 
2112				ld a, (os_view_disable) 
2112				cp '*' 
2112				jr z, .skip 
2112			 
2112				push hl 
2112				push hl 
2112				call clear_display 
2112				ld de, .compword 
2112				ld a, display_row_1 
2112				call str_at_display 
2112				pop de 
2112				ld a, display_row_2 
2112				call str_at_display 
2112				ld hl,(cli_ptr) 
2112				ld a,(hl) 
2112			        ld hl, os_word_scratch 
2112				ld (hl),a 
2112				ld a,0 
2112				inc hl 
2112				ld (hl),a 	 
2112				ld de, os_word_scratch 
2112				ld a, display_row_2+10 
2112				call str_at_display 
2112				call update_display 
2112				ld a, 100 
2112				call aDelayInMS 
2112				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2112				call delay250ms 
2112				endif 
2112				pop hl 
2112			.skip:  
2112			endif	 
2112			.execpnchar:    ; compare char between token and string to parse 
2112			 
2112			if DEBUG_FORTH_PARSE_KEY 
2112						DMARK "Ky3" 
2112			endif 
2112			if DEBUG_FORTH_PARSE_EXEC 
2112				; see if disabled 
2112			 
2112				ld a, (os_view_disable) 
2112				cp '*' 
2112				jr z, .skip2 
2112			 
2112			;	call clear_display 
2112			ld hl,(cli_token) 
2112			ld a,(hl) 
2112			ld (os_word_scratch),a 
2112				ld hl,(cli_ptr) 
2112			ld a,(hl) 
2112				ld (os_word_scratch+1),a 
2112				ld a,0 
2112				ld (os_word_scratch+2),a 
2112				ld de,os_word_scratch 
2112				ld a,display_row_4 
2112				call str_at_display 
2112				call update_display 
2112			.skip2:  
2112			endif 
2112 2a 2e f8			ld hl,(cli_token) 
2115 7e				ld a, (hl)	 ; char in word token 
2116 23				inc hl 		; move to next char 
2117 22 2e f8			ld (cli_token), hl ; and save it 
211a 47				ld b,a 
211b			 
211b 2a 28 f8			ld hl,(cli_ptr) ;	get the char from the string to parse 
211e 7e				ld a,(hl) 
211f 23				inc hl 
2120 22 28 f8			ld (cli_ptr), hl		; move to next char 
2123 cd 5e 11			call toUpper 		; make sure the input string matches case 
2126			 
2126			if DEBUG_FORTH_PARSE 
2126			endif 
2126			 
2126				; input stream end of token is a space so get rid of it 
2126			 
2126			;	cp ' ' 
2126			;	jr nz, .pnskipspace 
2126			; 
2126			;	ld a, 0		; make same term as word token term 
2126			; 
2126			;.pnskipspace: 
2126			 
2126			if DEBUG_FORTH_PARSE_KEY 
2126						DMARK "KY7" 
2126			endif 
2126 b8				cp b 
2127 c2 3d 21			jp nz, .execpnskipword	 ; no match so move to next word 
212a				 
212a			;    if same 
212a			;       scan for string terms 0 for token and 32 for input 
212a			 
212a				 
212a			if DEBUG_FORTH_PARSE_KEY 
212a						DMARK "KY8" 
212a			endif 
212a			 
212a 80				add b			 
212b fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
212d							; TODO need to make sure last word in zero term string is accounted for 
212d 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
212f			 
212f			 
212f				; at end of both strings so both are exact match 
212f			 
212f			;       skip ptr for next word 
212f			 
212f 2a 28 f8			ld hl,(cli_ptr) 	; at input string term 
2132 23				inc hl			 ; at next char 
2133 22 28 f8			ld (cli_ptr), hl     ; save for next round of the parser 
2136 22 26 f8			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
2139				 
2139				 
2139			if DEBUG_FORTH_PARSE_KEY 
2139						DMARK "KY3" 
2139			endif 
2139			 
2139			 
2139			 
2139			;       exec code block 
2139			if DEBUG_FORTH_JP 
2139				call clear_display 
2139				call update_display 
2139				call delay1s 
2139				ld hl, (cli_execword)     ; save for next check if no match on this word 
2139				ld a,h 
2139				ld hl, os_word_scratch 
2139				call hexout 
2139				ld hl, (cli_execword)     ; save for next check if no match on this word 
2139				ld a,l 
2139				ld hl, os_word_scratch+2 
2139				call hexout 
2139				ld hl, os_word_scratch+4 
2139				ld a,0 
2139				ld (hl),a 
2139				ld de,os_word_scratch 
2139				call str_at_display 
2139					ld a, display_row_2 
2139					call str_at_display 
2139				ld de, (cli_origtoken) 
2139				ld a, display_row_1+10 
2139					call str_at_display 
2139			 
2139				ld a,display_row_1 
2139				ld de, .foundword 
2139				ld a, display_row_3 
2139				call str_at_display 
2139				call update_display 
2139				call delay1s 
2139				call delay1s 
2139				call delay1s 
2139			endif 
2139			 
2139			if DEBUG_FORTH_PARSE_KEY 
2139						DMARK "KYj" 
2139			endif 
2139				; TODO save the word pointer in this exec 
2139			 
2139 2a 2c f8			ld hl,(cli_execword) 
213c e9				jp (hl) 
213d			 
213d			 
213d			;    if not same 
213d			;	scan for zero term 
213d			;	get ptr for next word 
213d			;	goto word comp 
213d			 
213d			.execpnskipword:	; get pointer to next word 
213d 2a 2a f8			ld hl,(cli_nextword) 
2140			 
2140 7e				ld a,(hl) 
2141 fe 00			cp WORD_SYS_END 
2143			;	cp 0 
2143 28 09			jr z, .execendofdict			 ; at end of words 
2145			 
2145			if DEBUG_FORTH_PARSE_KEY 
2145						DMARK "KY4" 
2145			endif 
2145			if DEBUG_FORTH_PARSE_EXEC 
2145			 
2145				; see if disabled 
2145			 
2145				ld a, (os_view_disable) 
2145				cp '*' 
2145				jr z, .noskip 
2145			 
2145			 
2145				ld de, .nowordfound 
2145				ld a, display_row_3 
2145				call str_at_display 
2145				call update_display 
2145				ld a, 100 
2145				call aDelayInMS 
2145				 
2145				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2145					call delay250ms 
2145				endif 
2145			.noskip:  
2145			 
2145			endif	 
2145			 
2145 2a 26 f8			ld hl,(cli_origptr) 
2148 22 28 f8			ld (cli_ptr),hl 
214b			 
214b			if DEBUG_FORTH_PARSE_KEY 
214b						DMARK "KY5" 
214b			endif 
214b c3 f1 20			jp .execpnword			; else go to next word 
214e			 
214e			.execendofdict:  
214e			 
214e			if DEBUG_FORTH_PARSE_KEY 
214e						DMARK "KYe" 
214e			endif 
214e			if DEBUG_FORTH_PARSE_EXEC 
214e				; see if disabled 
214e			 
214e				ld a, (os_view_disable) 
214e				cp '*' 
214e				jr z, .ispskip 
214e			 
214e				call clear_display 
214e				call update_display 
214e				call delay1s 
214e				ld de, (cli_origptr) 
214e				ld a, display_row_1 
214e				call str_at_display 
214e				 
214e				ld de, .enddict 
214e				ld a, display_row_3 
214e				call str_at_display 
214e				call update_display 
214e				ld a, 100 
214e				call aDelayInMS 
214e				if DEBUG_FORTH_PARSE_EXEC_SLOW 
214e				call delay1s 
214e				call delay1s 
214e				call delay1s 
214e				endif 
214e			.ispskip:  
214e				 
214e			endif	 
214e			 
214e			 
214e			 
214e				; if the word is not a keyword then must be a literal so push it to stack 
214e			 
214e			; push token to stack to end of word 
214e			 
214e				STACKFRAME ON $1efe $2f9f 
214e				if DEBUG_STACK_IMB 
214e					if ON 
214e						exx 
214e						ld de, $1efe 
214e						ld a, d 
214e						ld hl, curframe 
214e						call hexout 
214e						ld a, e 
214e						ld hl, curframe+2 
214e						call hexout 
214e						ld hl, $1efe 
214e						push hl 
214e						ld hl, $2f9f 
214e						push hl 
214e						exx 
214e					endif 
214e				endif 
214e			endm 
# End of macro STACKFRAME
214e			 
214e 2a 1e f1		ld hl,(os_tok_ptr) 
2151 cd 46 1e		call forth_apush 
2154			 
2154				STACKFRAMECHK ON $1efe $2f9f 
2154				if DEBUG_STACK_IMB 
2154					if ON 
2154						exx 
2154						ld hl, $2f9f 
2154						pop de   ; $2f9f 
2154						call cmp16 
2154						jr nz, .spnosame 
2154						ld hl, $1efe 
2154						pop de   ; $1efe 
2154						call cmp16 
2154						jr z, .spfrsame 
2154						.spnosame: call showsperror 
2154						.spfrsame: nop 
2154						exx 
2154					endif 
2154				endif 
2154			endm 
# End of macro STACKFRAMECHK
2154			 
2154			execnext: 
2154			 
2154			if DEBUG_FORTH_PARSE_KEY 
2154						DMARK "KY>" 
2154			endif 
2154			; move past token to next word 
2154			 
2154 2a 1e f1		ld hl, (os_tok_ptr) 
2157 3e 00		ld a, 0 
2159 01 ff 00		ld bc, 255     ; input buffer size 
215c ed b1		cpir 
215e			 
215e			if DEBUG_FORTH_PARSE_KEY 
215e						DMARK "KY!" 
215e				CALLMONITOR 
215e			endif	 
215e			; TODO this might place hl on the null, so will need to forward on??? 
215e			;inc hl   ; see if this gets onto the next item 
215e			 
215e			 
215e			; TODO pass a pointer to the buffer to push 
215e			; TODO call function to push 
215e			 
215e			; look for end of input 
215e			 
215e			;inc hl 
215e			;ld a,(hl) 
215e			;cp FORTH_END_BUFFER 
215e			;ret z 
215e			 
215e			 
215e c3 d7 20		jp exec1 
2161			 
2161			 
2161			 
2161			 
2161			 
2161			 
2161			 
2161			 
2161			 
2161			findnexttok: 
2161			 
2161				; hl is pointer to move 
2161				; de is the token to locate 
2161			 
2161					if DEBUG_FORTH 
2161						DMARK "NTK" 
2161						CALLMONITOR 
2161					endif 
2161 d5				push de 
2162			 
2162			.fnt1:	 
2162				; find first char of token to locate 
2162			 
2162 1a				ld a, (de) 
2163 4f				ld c,a 
2164 7e				ld a,(hl) 
2165 cd 5e 11			call toUpper 
2168					if DEBUG_FORTH 
2168						DMARK "NT1" 
2168						CALLMONITOR 
2168					endif 
2168 b9				cp c 
2169			 
2169 28 03			jr z, .fnt2cmpmorefirst	 
216b			 
216b				; first char not found move to next char 
216b			 
216b 23				inc hl 
216c 18 f4			jr .fnt1 
216e			 
216e			.fnt2cmpmorefirst:	 
216e				; first char of token found.  
216e			 
216e e5				push hl     ; save start of token just in case it is the right one 
216f d9				exx 
2170 e1				pop hl        ; save it to hl' 
2171 d9				exx 
2172			 
2172			 
2172			.fnt2cmpmore:	 
2172				; compare the rest 
2172				 
2172 23				inc hl 
2173 13				inc de 
2174				 
2174 1a				ld a, (de) 
2175 4f				ld c,a 
2176 7e				ld a,(hl) 
2177 cd 5e 11			call toUpper 
217a			 
217a					if DEBUG_FORTH 
217a						DMARK "NT2" 
217a						CALLMONITOR 
217a					endif 
217a				; c has the token to find char 
217a				; a has the mem to scan char 
217a			 
217a b9				cp c 
217b 28 04			jr z,.fntmatch1 
217d			 
217d				; they are not the same 
217d			 
217d					if DEBUG_FORTH 
217d						DMARK "NT3" 
217d						CALLMONITOR 
217d					endif 
217d d1				pop de	; reset de token to look for 
217e d5				push de 
217f 18 e1			jr .fnt1 
2181				 
2181			.fntmatch1: 
2181			 
2181				; is the same char a null which means we might have a full hit? 
2181					if DEBUG_FORTH 
2181						DMARK "NT4" 
2181						CALLMONITOR 
2181					endif 
2181			 
2181 fe 00			cp 0 
2183 28 0b			jr z, .fntmatchyes 
2185			 
2185				; are we at the end of the token to find? 
2185			 
2185					if DEBUG_FORTH 
2185						DMARK "NT5" 
2185						CALLMONITOR 
2185					endif 
2185 3e 00			ld a, 0 
2187 b9				cp c 
2188			 
2188 c2 72 21			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
218b			 
218b					if DEBUG_FORTH 
218b						DMARK "NT6" 
218b						CALLMONITOR 
218b					endif 
218b				; token to find is exhusted but no match to stream 
218b			 
218b				; restore tok pointer and continue on 
218b d1				pop de 
218c d5				push de 
218d c3 62 21			jp .fnt1 
2190			 
2190			 
2190			.fntmatchyes: 
2190			 
2190				; hl now contains the end of the found token 
2190			 
2190				; get rid of saved token pointer to find 
2190			 
2190 d1				pop de 
2191			 
2191					if DEBUG_FORTH 
2191						DMARK "NT9" 
2191						CALLMONITOR 
2191					endif 
2191			 
2191				; hl will be on the null term so forward on 
2191			 
2191				; get back the saved start of the token 
2191			 
2191 d9				exx 
2192 e5				push hl     ; save start of token just in case it is the right one 
2193 d9				exx 
2194 e1				pop hl        ; save it to hl 
2195			 
2195 c9				ret 
2196			 
2196			 
2196			; LIST needs to find a specific token   
2196			; FORGET needs to find a spefici token 
2196			 
2196			; SAVE needs to find all tokens by flag 
2196			; WORDS just needs to scan through all  by flag 
2196			; UWORDS needs to scan through all by flag 
2196			 
2196			 
2196			; given hl as pointer to start of dict look up string 
2196			; return hl as pointer to start of word block 
2196			; or 0 if not found 
2196			 
2196			forth_find_tok: 
2196 c9				ret 
2197			 
2197			; given hl as pointer to dict structure 
2197			; move to the next dict block structure 
2197			 
2197			forth_tok_next: 
2197				; hl now points to the address of the next word pointer  
2197				; TODO skip compiled symbol for now 
2197			;	push de 
2197 23				inc hl 
2198 5e				ld e, (hl) 
2199 23				inc hl 
219a 56				ld d, (hl) 
219b 23				inc hl 
219c			 
219c eb				ex de,hl 
219d			if DEBUG_FORTH_PARSE_NEXTWORD 
219d				push bc 
219d				ld bc, (cli_nextword) 
219d						DMARK "NXW" 
219d				CALLMONITOR 
219d				pop bc 
219d			endif 
219d			;	pop de	 
219d c9				ret 
219e			 
219e			 
219e			 
219e			; eof 
# End of file forth_parserv5.asm
219e				include "forth_wordsv4.asm" 
219e			 
219e			; the core word dictionary v4 
219e			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
219e			 
219e			; this is a linked list for each of the system words used 
219e			; user defined words will follow the same format but will be in ram 
219e			 
219e			 
219e			; 
219e			; 
219e			; define linked list: 
219e			; 
219e			; 1. compiled byte op code 
219e			; 2. len of text word 
219e			; 3. text word 
219e			; 4. ptr to next dictionary word 
219e			; 5. asm, calls etc for the word 
219e			; 
219e			;  if 1 == 0 then last word in dict  
219e			;   
219e			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
219e			;  
219e			;  
219e			; create basic standard set of words 
219e			; 
219e			;  
219e			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
219e			; 2DUP 2DROP 2SWAP  
219e			; @ C@ - get byte  
219e			; ! C! - store byte 
219e			; 0< true if less than zero 
219e			; 0= true if zero 
219e			; < >  
219e			; = true if same 
219e			; variables 
219e			 
219e			 
219e			; Hardware specific words I may need 
219e			; 
219e			; IN OUT  
219e			; calls to key util functions 
219e			; calls to hardward abstraction stuff 
219e			; easy control of frame buffers and lcd i/o 
219e			; keyboard  
219e			 
219e			 
219e			;DICT: macro 
219e			; op_code, len, word, next 
219e			;    word: 
219e			;    db op_code 
219e			;    ds word zero term 
219e			;    dw next 
219e			;    endm 
219e			 
219e			 
219e			 
219e			 
219e			; op code 1 is a flag for user define words which are to be handled differently 
219e			 
219e			 
219e			; 
219e			; 
219e			;    TODO on entry to a word this should be the expected environment 
219e			;    hl - tos value if number then held, if string this is the ptr 
219e			;    de -  
219e			 
219e			 
219e			; opcode ranges 
219e			; 0 - end of word dict 
219e			; 255 - user define words 
219e			 
219e			sysdict: 
219e			include "forth_opcodes.asm" 
219e			; op codes for forth keywords 
219e			; free to use code 0  
219e				OPCODE_HEAP: equ  1 
219e				OPCODE_EXEC: equ 2 
219e				OPCODE_DUP: equ 3 
219e				OPCODE_SWAP: equ 4 
219e				OPCODE_COLN: equ 5 
219e				OPCODE_SCOLN: equ 6 
219e				OPCODE_DROP: equ 7 
219e				OPCODE_DUP2: equ 8 
219e				OPCODE_DROP2: equ 9 
219e				OPCODE_SWAP2: equ 10 
219e				OPCODE_AT: equ 11 
219e				OPCODE_CAT: equ 12 
219e				OPCODE_BANG: equ 13 
219e				OPCODE_CBANG: equ 14 
219e				OPCODE_SCALL: equ 15 
219e				OPCODE_DEPTH: equ 16 
219e				OPCODE_OVER: equ 17 
219e				OPCODE_PAUSE: equ 18 
219e				OPCODE_PAUSES: equ 19 
219e				OPCODE_ROT: equ 20 
219e			;free to reuse	OPCODE_WORDS: equ 21 
219e			        OPCODE_NOT: equ 21 
219e				OPCODE_UWORDS: equ 22 
219e				OPCODE_BP: equ 23 
219e				OPCODE_MONITOR: equ 24  
219e				OPCODE_MALLOC: equ 25 
219e				OPCODE_FREE: equ 26 
219e				OPCODE_LIST: equ 27 
219e				OPCODE_FORGET: equ 28 
219e				OPCODE_NOP: equ 29 
219e				OPCODE_COMO: equ 30 
219e				OPCODE_COMC: equ 31 
219e			;free to reuse	OPCODE_ENDCORE: equ 32 
219e				OPCODE_AFTERSOUND: equ 33 
219e				OPCODE_GP2: equ 34 
219e				OPCODE_GP3: equ 35 
219e				OPCODE_GP4: equ 36 
219e				OPCODE_SIN: equ 37 
219e				OPCODE_SOUT: equ 38 
219e				OPCODE_SPIO: equ 39 
219e				OPCODE_SPICEH: equ 40 
219e				OPCODE_SPIOb: equ 41 
219e				OPCODE_SPII: equ 42 
219e				OPCODE_SESEL: equ 43 
219e				OPCODE_CARTDEV: equ 44 
219e			; free to reuse	OPCODE_ENDDEVICE: equ 45 
219e				OPCODE_FB: equ 46 
219e				OPCODE_EMIT: equ 47 
219e				OPCODE_DOTH: equ 48 
219e				OPCODE_DOTF: equ 49 
219e				OPCODE_DOT: equ 50 
219e				OPCODE_CLS: equ 51 
219e				OPCODE_DRAW: equ 52 
219e				OPCODE_DUMP: equ 53 
219e				OPCODE_CDUMP: equ 54 
219e				OPCODE_DAT: equ 55 
219e				OPCODE_HOME: equ 56 
219e				OPCODE_SPACE: equ 57 
219e				OPCODE_SPACES: equ 58 
219e				OPCODE_SCROLL: equ 59 
219e				OPCODE_ATQ: equ 60 
219e				OPCODE_AUTODSP: equ 61 
219e				OPCODE_MENU: equ 62 
219e			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
219e				OPCODE_THEN: equ 64 
219e				OPCODE_ELSE: equ 65 
219e				OPCODE_DO: equ 66 
219e				OPCODE_LOOP: equ 67 
219e				OPCODE_I: equ 68 
219e				OPCODE_DLOOP: equ 69  
219e				OPCODE_REPEAT: equ 70  
219e				OPCODE_UNTIL: equ 71 
219e				OPCODE_ENDFLOW: equ 72 
219e				OPCODE_WAITK: equ 73 
219e				OPCODE_ACCEPT: equ 74 
219e				OPCODE_EDIT: equ 75 
219e			;free to reuse	OPCODE_ENDKEY: equ 76 
219e				OPCODE_LZERO: equ 77 
219e				OPCODE_TZERO: equ 78 
219e				OPCODE_LESS: equ 79 
219e				OPCODE_GT: equ 80 
219e				OPCODE_EQUAL: equ 81  
219e			;free to reuse	OPCODE_ENDLOGIC: equ 82 
219e				OPCODE_NEG: equ 83 
219e				OPCODE_DIV: equ 84 
219e				OPCODE_MUL: equ 85 
219e				OPCODE_MIN: equ 86 
219e				OPCODE_MAX: equ 87 
219e				OPCODE_RND16: equ 88 
219e				OPCODE_RND8: equ 89 
219e				OPCODE_RND: equ 90 
219e			;free to reuse	OPCODE_ENDMATHS: equ 91  
219e				OPCODE_BYNAME: equ 92 
219e				OPCODE_DIR: equ 93 
219e				OPCODE_SAVE: equ 94 
219e				OPCODE_LOAD: equ 95 
219e				OPCODE_BSAVE: equ 96 
219e				OPCODE_BLOAD: equ 97 
219e				OPCODE_SEO: equ 98  
219e				OPCODE_SEI: equ 99 
219e				OPCODE_SFREE: equ 100 
219e				OPCODE_SIZE: equ 101 
219e				OPCODE_CREATE: equ 102 
219e				OPCODE_APPEND: equ 103 
219e				OPCODE_SDEL: equ 104 
219e				OPCODE_OPEN: equ 105 
219e				OPCODE_READ: equ 106 
219e				OPCODE_EOF: equ 106 
219e				OPCODE_FORMAT: equ 107 
219e				OPCODE_LABEL: equ 108 
219e				OPCODE_LABELS: equ 109 
219e			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
219e				OPCODE_UPPER: equ 111 
219e				OPCODE_LOWER: equ 112 
219e				OPCODE_SUBSTR: equ 113 
219e				OPCODE_LEFT: equ 114 
219e				OPCODE_RIGHT: equ 115 
219e				OPCODE_STR2NUM: equ 116 
219e				OPCODE_NUM2STR: equ 117 
219e				OPCODE_CONCAT: equ 118 
219e				OPCODE_FIND: equ 119 
219e				OPCODE_LEN: equ 120 
219e				OPCODE_CHAR: equ 121 
219e			; free to reuse	OPCODE_STRLEN: equ 122 
219e			; free to reuse	OPCODE_ENDSTR: equ 123 
219e				OPCODE_V0S: equ 124 
219e				OPCODE_V0Q: equ 125 
219e				OPCODE_V1S: equ 126 
219e				OPCODE_V1Q: equ 127 
219e				OPCODE_V2S: equ 128 
219e				OPCODE_V2Q: equ 129 
219e				OPCODE_V3S: equ 130 
219e				OPCODE_V3Q: equ 131 
219e			;free to reuse	OPCODE_END: equ 132 
219e				OPCODE_ZDUP: equ 133 
219e			 
219e			; eof 
# End of file forth_opcodes.asm
219e			 
219e			include "forth_words_core.asm" 
219e			 
219e			; | ## Core Words 
219e			 
219e			;if MALLOC_4 
219e			 
219e			.HEAP: 
219e				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
219e 15				db WORD_SYS_CORE+OPCODE_HEAP             
219f dd 21			dw .EXEC            
21a1 05				db 4 + 1 
21a2 .. 00			db "HEAP",0              
21a7				endm 
# End of macro CWHEAD
21a7			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
21a7			; | | u1 - Current number of bytes in the heap 
21a7			; | | u2 - Remaining bytes left on the heap 
21a7			; | |  
21a7			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
21a7			 
21a7			 
21a7					if DEBUG_FORTH_WORDS_KEY 
21a7						DMARK "HEP" 
21a7 f5				push af  
21a8 3a bc 21			ld a, (.dmark)  
21ab 32 77 fb			ld (debug_mark),a  
21ae 3a bd 21			ld a, (.dmark+1)  
21b1 32 78 fb			ld (debug_mark+1),a  
21b4 3a be 21			ld a, (.dmark+2)  
21b7 32 79 fb			ld (debug_mark+2),a  
21ba 18 03			jr .pastdmark  
21bc ..			.dmark: db "HEP"  
21bf f1			.pastdmark: pop af  
21c0			endm  
# End of macro DMARK
21c0						CALLMONITOR 
21c0 cd 4d 17			call break_point_state  
21c3				endm  
# End of macro CALLMONITOR
21c3					endif 
21c3 2a 0a 80				ld hl, (free_list )      
21c6 11 0e 80				ld de, heap_start 
21c9			 
21c9 ed 52				sbc hl, de  
21cb			 
21cb cd dd 1c				call forth_push_numhl 
21ce			 
21ce			 
21ce ed 5b 0a 80			ld de, (free_list )      
21d2 21 03 ee				ld hl, heap_end 
21d5			 
21d5 ed 52				sbc hl, de 
21d7			 
21d7 cd dd 1c				call forth_push_numhl 
21da					 
21da			 
21da					 
21da			 
21da			 
21da			 
21da					NEXTW 
21da c3 46 20			jp macro_next 
21dd				endm 
# End of macro NEXTW
21dd			;endif 
21dd			 
21dd			.EXEC: 
21dd			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
21dd			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
21dd			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
21dd			;; > > 
21dd			;; > >   
21dd			;	STACKFRAME OFF $5efe $5f9f 
21dd			; 
21dd			;		if DEBUG_FORTH_WORDS_KEY 
21dd			;			DMARK "EXE" 
21dd			;			CALLMONITOR 
21dd			;		endif 
21dd			; 
21dd			;	FORTH_DSP_VALUEHL 
21dd			; 
21dd			;	FORTH_DSP_POP 
21dd			; 
21dd			;		if DEBUG_FORTH_WORDS 
21dd			;			DMARK "EX1" 
21dd			;			CALLMONITOR 
21dd			;		endif 
21dd			;;	ld e,(hl) 
21dd			;;	inc hl 
21dd			;;	ld d,(hl) 
21dd			;;	ex de,hl 
21dd			; 
21dd			;;		if DEBUG_FORTH_WORDS 
21dd			;;			DMARK "EX2" 
21dd			;;			CALLMONITOR 
21dd			;;		endif 
21dd			;	push hl 
21dd			; 
21dd			;	;ld a, 0 
21dd			;	;ld a, FORTH_END_BUFFER 
21dd			;	call strlenz 
21dd			;	inc hl   ; include zero term to copy 
21dd			;	inc hl   ; include term 
21dd			;	inc hl   ; include term 
21dd			;	ld b,0 
21dd			;	ld c,l 
21dd			;	pop hl 
21dd			;	ld de, execscratch 
21dd			;		if DEBUG_FORTH_WORDS 
21dd			;			DMARK "EX3" 
21dd			;			CALLMONITOR 
21dd			;		endif 
21dd			;	ldir 
21dd			; 
21dd			; 
21dd			;	ld hl, execscratch 
21dd			; 
21dd			;		if DEBUG_FORTH_WORDS 
21dd			;			DMARK "EXe" 
21dd			;			CALLMONITOR 
21dd			;		endif 
21dd			; 
21dd			;	call forthparse 
21dd			;	call forthexec 
21dd			;;	call forthexec_cleanup 
21dd			;;	call forthparse 
21dd			;;	call forthexec 
21dd			; 
21dd			;	STACKFRAMECHK OFF $5efe $5f9f 
21dd			; 
21dd			;	; an immediate word so no need to process any more words 
21dd			;	ret 
21dd			;	NEXTW 
21dd			 
21dd			; dead code - old version  
21dd			;	FORTH_RSP_NEXT 
21dd			 
21dd			;  
21dd			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
21dd			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
21dd			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
21dd			;	push hl 
21dd			;	push de 
21dd			;	push bc 
21dd			; 
21dd			; 
21dd			;		if DEBUG_FORTH_WORDS_KEY 
21dd			;			DMARK "EXR" 
21dd			;			CALLMONITOR 
21dd			;		endif 
21dd			; 
21dd			; 
21dd			; 
21dd			;	;v5 FORTH_DSP_VALUE 
21dd			;	FORTH_DSP_VALUEHL 
21dd			; 
21dd			;	; TODO do string type checks 
21dd			; 
21dd			;;v5	inc hl   ; skip type 
21dd			; 
21dd			;	push hl  ; source code  
21dd			;		if DEBUG_FORTH_WORDS 
21dd			;			DMARK "EX1" 
21dd			;			CALLMONITOR 
21dd			;		endif 
21dd			;	ld a, 0 
21dd			;	call strlent 
21dd			; 
21dd			;	inc hl 
21dd			;	inc hl 
21dd			;	inc hl 
21dd			;	inc hl 
21dd			; 
21dd			;	push hl    ; size 
21dd			; 
21dd			;		if DEBUG_FORTH_WORDS 
21dd			;			DMARK "EX2" 
21dd			;			CALLMONITOR 
21dd			;		endif 
21dd			;	call malloc 
21dd			; 
21dd			;	ex de, hl    ; de now contains malloc area 
21dd			;	pop bc   	; get byte count 
21dd			;	pop hl      ; get string to copy 
21dd			; 
21dd			;	push de     ; save malloc for free later 
21dd			; 
21dd			;		if DEBUG_FORTH_WORDS 
21dd			;			DMARK "EX3" 
21dd			;			CALLMONITOR 
21dd			;		endif 
21dd			;	ldir       ; duplicate string 
21dd			; 
21dd			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
21dd			;	 
21dd			;	; TODO fix the parse would be better than this...  
21dd			;	ex de, hl 
21dd			;	dec hl 
21dd			;	ld a, 0 
21dd			;	ld (hl), a 
21dd			;	dec hl 
21dd			;	ld a, ' ' 
21dd			;	ld (hl), a 
21dd			;	dec hl 
21dd			;	ld (hl), a 
21dd			; 
21dd			;	dec hl 
21dd			;	ld (hl), a 
21dd			; 
21dd			; 
21dd			;	FORTH_DSP_POP  
21dd			; 
21dd			;	pop hl     
21dd			;	push hl    ; save malloc area 
21dd			; 
21dd			;		if DEBUG_FORTH_WORDS 
21dd			;			DMARK "EX4" 
21dd			;			CALLMONITOR 
21dd			;		endif 
21dd			; 
21dd			;	call forthparse 
21dd			;	call forthexec 
21dd			;	 
21dd			;	pop hl 
21dd			;	if DEBUG_FORTH_WORDS 
21dd			;		DMARK "EX5" 
21dd			;		CALLMONITOR 
21dd			;	endif 
21dd			; 
21dd			;	if FORTH_ENABLE_FREE 
21dd			;	call free 
21dd			;	endif 
21dd			; 
21dd			;	if DEBUG_FORTH_WORDS 
21dd			;		DMARK "EX6" 
21dd			;		CALLMONITOR 
21dd			;	endif 
21dd			; 
21dd			;	pop bc 
21dd			;	pop de 
21dd			;	pop hl 
21dd			;;	FORTH_RSP_POP	  
21dd			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
21dd			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
21dd			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
21dd			; 
21dd			;	if DEBUG_FORTH_WORDS 
21dd			;		DMARK "EX7" 
21dd			;		CALLMONITOR 
21dd			;	endif 
21dd			;	NEXTW 
21dd			 
21dd			;.STKEXEC: 
21dd			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
21dd			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
21dd			; 
21dd			; 
21dd			;		if DEBUG_FORTH_WORDS_KEY 
21dd			;			DMARK "STX" 
21dd			;			CALLMONITOR 
21dd			;		endif 
21dd			; 
21dd			;	FORTH_DSP_VALUEHL 
21dd			; 
21dd			;	ld (store_tmp1), hl    ; count 
21dd			; 
21dd			;	FORTH_DSP_POP 
21dd			;.stkexec1: 
21dd			;	ld hl, (store_tmp1)   ; count 
21dd			;	ld a, 0 
21dd			;	cp l 
21dd			;	ret z 
21dd			; 
21dd			;	dec hl 
21dd			;	ld (store_tmp1), hl    ; count 
21dd			;	 
21dd			;	FORTH_DSP_VALUEHL 
21dd			;	push hl 
21dd			;	 
21dd			;		if DEBUG_FORTH_WORDS 
21dd			;			DMARK "EXp" 
21dd			;			CALLMONITOR 
21dd			;		endif 
21dd			;	FORTH_DSP_POP 
21dd			; 
21dd			;	call strlenz 
21dd			;	inc hl   ; include zero term to copy 
21dd			;	inc hl   ; include zero term to copy 
21dd			;	inc hl   ; include zero term to copy 
21dd			;	ld b,0 
21dd			;	ld c,l 
21dd			;	pop hl 
21dd			;	ld de, execscratch 
21dd			;		if DEBUG_FORTH_WORDS 
21dd			;			DMARK "EX3" 
21dd			;			CALLMONITOR 
21dd			;		endif 
21dd			;	ldir 
21dd			; 
21dd			; 
21dd			;	ld hl, execscratch 
21dd			; 
21dd			;		if DEBUG_FORTH_WORDS 
21dd			;			DMARK "EXP" 
21dd			;			CALLMONITOR 
21dd			;		endif 
21dd			; 
21dd			;	call forthparse 
21dd			;	ld hl, execscratch 
21dd			;		if DEBUG_FORTH_WORDS 
21dd			;			DMARK "EXx" 
21dd			;			CALLMONITOR 
21dd			;		endif 
21dd			;	call forthexec 
21dd			; 
21dd			;	jp .stkexec1 
21dd			; 
21dd			;	ret 
21dd			 
21dd			 
21dd			.DUP: 
21dd				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
21dd 17				db WORD_SYS_CORE+OPCODE_DUP             
21de 53 22			dw .ZDUP            
21e0 04				db 3 + 1 
21e1 .. 00			db "DUP",0              
21e5				endm 
# End of macro CWHEAD
21e5			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
21e5			 
21e5					if DEBUG_FORTH_WORDS_KEY 
21e5						DMARK "DUP" 
21e5 f5				push af  
21e6 3a fa 21			ld a, (.dmark)  
21e9 32 77 fb			ld (debug_mark),a  
21ec 3a fb 21			ld a, (.dmark+1)  
21ef 32 78 fb			ld (debug_mark+1),a  
21f2 3a fc 21			ld a, (.dmark+2)  
21f5 32 79 fb			ld (debug_mark+2),a  
21f8 18 03			jr .pastdmark  
21fa ..			.dmark: db "DUP"  
21fd f1			.pastdmark: pop af  
21fe			endm  
# End of macro DMARK
21fe						CALLMONITOR 
21fe cd 4d 17			call break_point_state  
2201				endm  
# End of macro CALLMONITOR
2201					endif 
2201			 
2201					FORTH_DSP 
2201 cd 9a 1e			call macro_forth_dsp 
2204				endm 
# End of macro FORTH_DSP
2204			 
2204 7e					ld a, (HL) 
2205 fe 01				cp DS_TYPE_STR 
2207 20 25				jr nz, .dupinum 
2209			 
2209					; push another string 
2209			 
2209					FORTH_DSP_VALUEHL     		 
2209 cd d4 1e			call macro_dsp_valuehl 
220c				endm 
# End of macro FORTH_DSP_VALUEHL
220c			 
220c				if DEBUG_FORTH_WORDS 
220c					DMARK "DUs" 
220c f5				push af  
220d 3a 21 22			ld a, (.dmark)  
2210 32 77 fb			ld (debug_mark),a  
2213 3a 22 22			ld a, (.dmark+1)  
2216 32 78 fb			ld (debug_mark+1),a  
2219 3a 23 22			ld a, (.dmark+2)  
221c 32 79 fb			ld (debug_mark+2),a  
221f 18 03			jr .pastdmark  
2221 ..			.dmark: db "DUs"  
2224 f1			.pastdmark: pop af  
2225			endm  
# End of macro DMARK
2225					CALLMONITOR 
2225 cd 4d 17			call break_point_state  
2228				endm  
# End of macro CALLMONITOR
2228				endif 
2228 cd 4b 1d				call forth_push_str 
222b			 
222b					NEXTW 
222b c3 46 20			jp macro_next 
222e				endm 
# End of macro NEXTW
222e			 
222e			 
222e			.dupinum: 
222e					 
222e			 
222e			 
222e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
222e cd d4 1e			call macro_dsp_valuehl 
2231				endm 
# End of macro FORTH_DSP_VALUEHL
2231			 
2231				; TODO add floating point number detection 
2231			 
2231				if DEBUG_FORTH_WORDS 
2231					DMARK "DUi" 
2231 f5				push af  
2232 3a 46 22			ld a, (.dmark)  
2235 32 77 fb			ld (debug_mark),a  
2238 3a 47 22			ld a, (.dmark+1)  
223b 32 78 fb			ld (debug_mark+1),a  
223e 3a 48 22			ld a, (.dmark+2)  
2241 32 79 fb			ld (debug_mark+2),a  
2244 18 03			jr .pastdmark  
2246 ..			.dmark: db "DUi"  
2249 f1			.pastdmark: pop af  
224a			endm  
# End of macro DMARK
224a					CALLMONITOR 
224a cd 4d 17			call break_point_state  
224d				endm  
# End of macro CALLMONITOR
224d				endif 
224d			 
224d cd dd 1c				call forth_push_numhl 
2250					NEXTW 
2250 c3 46 20			jp macro_next 
2253				endm 
# End of macro NEXTW
2253			.ZDUP: 
2253				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
2253 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2254 8b 22			dw .SWAP            
2256 05				db 4 + 1 
2257 .. 00			db "?DUP",0              
225c				endm 
# End of macro CWHEAD
225c			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
225c			 
225c					if DEBUG_FORTH_WORDS_KEY 
225c						DMARK "qDU" 
225c f5				push af  
225d 3a 71 22			ld a, (.dmark)  
2260 32 77 fb			ld (debug_mark),a  
2263 3a 72 22			ld a, (.dmark+1)  
2266 32 78 fb			ld (debug_mark+1),a  
2269 3a 73 22			ld a, (.dmark+2)  
226c 32 79 fb			ld (debug_mark+2),a  
226f 18 03			jr .pastdmark  
2271 ..			.dmark: db "qDU"  
2274 f1			.pastdmark: pop af  
2275			endm  
# End of macro DMARK
2275						CALLMONITOR 
2275 cd 4d 17			call break_point_state  
2278				endm  
# End of macro CALLMONITOR
2278					endif 
2278					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2278 cd d4 1e			call macro_dsp_valuehl 
227b				endm 
# End of macro FORTH_DSP_VALUEHL
227b			 
227b e5					push hl 
227c			 
227c					; is it a zero? 
227c			 
227c 3e 00				ld a, 0 
227e 84					add h 
227f 85					add l 
2280			 
2280 e1					pop hl 
2281			 
2281 fe 00				cp 0 
2283 28 03				jr z, .dup2orig 
2285			 
2285			 
2285 cd dd 1c				call forth_push_numhl 
2288			 
2288			 
2288				; TODO add floating point number detection 
2288			 
2288			.dup2orig: 
2288			 
2288					NEXTW 
2288 c3 46 20			jp macro_next 
228b				endm 
# End of macro NEXTW
228b			.SWAP: 
228b				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
228b 18				db WORD_SYS_CORE+OPCODE_SWAP             
228c ca 22			dw .COLN            
228e 05				db 4 + 1 
228f .. 00			db "SWAP",0              
2294				endm 
# End of macro CWHEAD
2294			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
2294					if DEBUG_FORTH_WORDS_KEY 
2294						DMARK "SWP" 
2294 f5				push af  
2295 3a a9 22			ld a, (.dmark)  
2298 32 77 fb			ld (debug_mark),a  
229b 3a aa 22			ld a, (.dmark+1)  
229e 32 78 fb			ld (debug_mark+1),a  
22a1 3a ab 22			ld a, (.dmark+2)  
22a4 32 79 fb			ld (debug_mark+2),a  
22a7 18 03			jr .pastdmark  
22a9 ..			.dmark: db "SWP"  
22ac f1			.pastdmark: pop af  
22ad			endm  
# End of macro DMARK
22ad						CALLMONITOR 
22ad cd 4d 17			call break_point_state  
22b0				endm  
# End of macro CALLMONITOR
22b0					endif 
22b0			 
22b0					FORTH_DSP_VALUEHL 
22b0 cd d4 1e			call macro_dsp_valuehl 
22b3				endm 
# End of macro FORTH_DSP_VALUEHL
22b3 e5					push hl     ; w2 
22b4			 
22b4					FORTH_DSP_POP 
22b4 cd 8c 1f			call macro_forth_dsp_pop 
22b7				endm 
# End of macro FORTH_DSP_POP
22b7			 
22b7					FORTH_DSP_VALUEHL 
22b7 cd d4 1e			call macro_dsp_valuehl 
22ba				endm 
# End of macro FORTH_DSP_VALUEHL
22ba			 
22ba					FORTH_DSP_POP 
22ba cd 8c 1f			call macro_forth_dsp_pop 
22bd				endm 
# End of macro FORTH_DSP_POP
22bd			 
22bd d1					pop de     ; w2	, hl = w1 
22be			 
22be eb					ex de, hl 
22bf d5					push de 
22c0			 
22c0 cd dd 1c				call forth_push_numhl 
22c3			 
22c3 e1					pop hl 
22c4			 
22c4 cd dd 1c				call forth_push_numhl 
22c7					 
22c7			 
22c7					NEXTW 
22c7 c3 46 20			jp macro_next 
22ca				endm 
# End of macro NEXTW
22ca			.COLN: 
22ca				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
22ca 19				db WORD_SYS_CORE+OPCODE_COLN             
22cb 56 24			dw .SCOLN            
22cd 02				db 1 + 1 
22ce .. 00			db ":",0              
22d0				endm 
# End of macro CWHEAD
22d0			; | : ( -- )         Create new word | DONE 
22d0			 
22d0					if DEBUG_FORTH_WORDS_KEY 
22d0						DMARK "CLN" 
22d0 f5				push af  
22d1 3a e5 22			ld a, (.dmark)  
22d4 32 77 fb			ld (debug_mark),a  
22d7 3a e6 22			ld a, (.dmark+1)  
22da 32 78 fb			ld (debug_mark+1),a  
22dd 3a e7 22			ld a, (.dmark+2)  
22e0 32 79 fb			ld (debug_mark+2),a  
22e3 18 03			jr .pastdmark  
22e5 ..			.dmark: db "CLN"  
22e8 f1			.pastdmark: pop af  
22e9			endm  
# End of macro DMARK
22e9						CALLMONITOR 
22e9 cd 4d 17			call break_point_state  
22ec				endm  
# End of macro CALLMONITOR
22ec					endif 
22ec				STACKFRAME OFF $8efe $989f 
22ec				if DEBUG_STACK_IMB 
22ec					if OFF 
22ec						exx 
22ec						ld de, $8efe 
22ec						ld a, d 
22ec						ld hl, curframe 
22ec						call hexout 
22ec						ld a, e 
22ec						ld hl, curframe+2 
22ec						call hexout 
22ec						ld hl, $8efe 
22ec						push hl 
22ec						ld hl, $989f 
22ec						push hl 
22ec						exx 
22ec					endif 
22ec				endif 
22ec			endm 
# End of macro STACKFRAME
22ec				; get parser buffer length  of new word 
22ec			 
22ec				 
22ec			 
22ec					; move tok past this to start of name defintition 
22ec					; TODO get word to define 
22ec					; TODO Move past word token 
22ec					; TODO get length of string up to the ';' 
22ec			 
22ec 2a 1e f1			ld hl, (os_tok_ptr) 
22ef 23				inc hl 
22f0 23				inc hl 
22f1			 
22f1 3e 3b			ld a, ';' 
22f3 cd 72 11			call strlent 
22f6			 
22f6 7d				ld a,l 
22f7 32 19 ee			ld (os_new_parse_len), a 
22fa			 
22fa			 
22fa			if DEBUG_FORTH_UWORD 
22fa ed 5b 1e f1		ld de, (os_tok_ptr) 
22fe						DMARK ":01" 
22fe f5				push af  
22ff 3a 13 23			ld a, (.dmark)  
2302 32 77 fb			ld (debug_mark),a  
2305 3a 14 23			ld a, (.dmark+1)  
2308 32 78 fb			ld (debug_mark+1),a  
230b 3a 15 23			ld a, (.dmark+2)  
230e 32 79 fb			ld (debug_mark+2),a  
2311 18 03			jr .pastdmark  
2313 ..			.dmark: db ":01"  
2316 f1			.pastdmark: pop af  
2317			endm  
# End of macro DMARK
2317				CALLMONITOR 
2317 cd 4d 17			call break_point_state  
231a				endm  
# End of macro CALLMONITOR
231a			endif 
231a			 
231a			; 
231a			;  new word memory layout: 
231a			;  
231a			;    : adg 6666 ;  
231a			; 
231a			;    db   1     ; user defined word  
231a 23				inc hl    
231b			;    dw   sysdict 
231b 23				inc hl 
231c 23				inc hl 
231d			;    db <word len>+1 (for null) 
231d 23				inc hl 
231e			;    db .... <word> 
231e			; 
231e			 
231e 23				inc hl    ; some extras for the word preamble before the above 
231f 23				inc hl 
2320 23				inc hl 
2321 23				inc hl 
2322 23				inc hl 
2323 23				inc hl 
2324 23				inc hl  
2325 23				inc hl 
2326 23				inc hl 
2327 23				inc hl 
2328 23				inc hl 
2329 23				inc hl 
232a 23				inc hl 
232b 23				inc hl     ; TODO how many do we really need?     maybe only 6 
232c			;       exec word buffer 
232c			;	<ptr word>   
232c 23				inc hl 
232d 23				inc hl 
232e			;       <word list><null term> 7F final term 
232e			 
232e			 
232e			if DEBUG_FORTH_UWORD 
232e						DMARK ":02" 
232e f5				push af  
232f 3a 43 23			ld a, (.dmark)  
2332 32 77 fb			ld (debug_mark),a  
2335 3a 44 23			ld a, (.dmark+1)  
2338 32 78 fb			ld (debug_mark+1),a  
233b 3a 45 23			ld a, (.dmark+2)  
233e 32 79 fb			ld (debug_mark+2),a  
2341 18 03			jr .pastdmark  
2343 ..			.dmark: db ":02"  
2346 f1			.pastdmark: pop af  
2347			endm  
# End of macro DMARK
2347				CALLMONITOR 
2347 cd 4d 17			call break_point_state  
234a				endm  
# End of macro CALLMONITOR
234a			endif 
234a			 
234a				 
234a					; malloc the size 
234a			 
234a cd d0 11				call malloc 
234d 22 1b ee				ld (os_new_malloc), hl     ; save malloc start 
2350			 
2350			;    db   1     ; user defined word  
2350 3e 01				ld a, WORD_SYS_UWORD  
2352 77					ld (hl), a 
2353				 
2353 23				inc hl    
2354			;    dw   sysdict 
2354 11 9e 21			ld de, sysdict       ; continue on with the scan to the system dict 
2357 73				ld (hl), e 
2358 23				inc hl 
2359 72				ld (hl), d 
235a 23				inc hl 
235b			 
235b			 
235b			;    Setup dict word 
235b			 
235b 23				inc hl 
235c 22 15 ee			ld (os_new_work_ptr), hl     ; save start of dict word  
235f			 
235f				; 1. get length of dict word 
235f			 
235f			 
235f 2a 1e f1			ld hl, (os_tok_ptr) 
2362 23				inc hl 
2363 23				inc hl    ; position to start of dict word 
2364 3e 00			ld a, 0 
2366 cd 72 11			call strlent 
2369			 
2369			 
2369 23				inc hl    ; to include null??? 
236a			 
236a				; write length of dict word 
236a			 
236a ed 5b 15 ee		ld de, (os_new_work_ptr)   ; get dest for copy of word 
236e 1b				dec de 
236f eb				ex de, hl 
2370 73				ld (hl), e 
2371 eb				ex de, hl 
2372			 
2372				 
2372			 
2372				; copy  
2372 4d				ld c, l 
2373 06 00			ld b, 0 
2375 ed 5b 15 ee		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2379 2a 1e f1			ld hl, (os_tok_ptr) 
237c 23				inc hl 
237d 23				inc hl    ; position to start of dict word 
237e				 
237e			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
237e				 
237e				; TODO need to convert word to upper case 
237e			 
237e			ucasetok:	 
237e 7e				ld a,(hl) 
237f cd 5e 11			call toUpper 
2382 77				ld (hl),a 
2383 ed a0			ldi 
2385 f2 7e 23		 	jp p, ucasetok 
2388			 
2388			 
2388			 
2388				; de now points to start of where the word body code should be placed 
2388 ed 53 15 ee		ld (os_new_work_ptr), de 
238c				; hl now points to the words to throw at forthexec which needs to be copied 
238c 22 13 ee			ld (os_new_src_ptr), hl 
238f			 
238f				; TODO add 'call to forthexec' 
238f			 
238f			if DEBUG_FORTH_UWORD 
238f c5				push bc 
2390 ed 4b 1b ee		ld bc, (os_new_malloc) 
2394						DMARK ":0x" 
2394 f5				push af  
2395 3a a9 23			ld a, (.dmark)  
2398 32 77 fb			ld (debug_mark),a  
239b 3a aa 23			ld a, (.dmark+1)  
239e 32 78 fb			ld (debug_mark+1),a  
23a1 3a ab 23			ld a, (.dmark+2)  
23a4 32 79 fb			ld (debug_mark+2),a  
23a7 18 03			jr .pastdmark  
23a9 ..			.dmark: db ":0x"  
23ac f1			.pastdmark: pop af  
23ad			endm  
# End of macro DMARK
23ad				CALLMONITOR 
23ad cd 4d 17			call break_point_state  
23b0				endm  
# End of macro CALLMONITOR
23b0 c1				pop bc 
23b1			endif 
23b1			 
23b1			 
23b1				; create word preamble which should be: 
23b1			 
23b1			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
23b1			 
23b1				;    ld hl, <word code> 
23b1				;    jp user_exec 
23b1			        ;    <word code bytes> 
23b1			 
23b1			 
23b1			;	inc de     ; TODO ??? or are we already past the word's null 
23b1 eb				ex de, hl 
23b2			 
23b2 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
23b4			 
23b4 23				inc hl 
23b5 22 0f ee			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
23b8 23				inc hl 
23b9			 
23b9 23				inc hl 
23ba 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
23bc			 
23bc 01 c1 50			ld bc, user_exec 
23bf 23				inc hl 
23c0 71				ld (hl), c     ; poke address of user_exec 
23c1 23				inc hl 
23c2 70				ld (hl), b     
23c3			 ; 
23c3			;	inc hl 
23c3			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
23c3			; 
23c3			; 
23c3			;	ld bc, macro_forth_rsp_next 
23c3			;	inc hl 
23c3			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
23c3			;	inc hl 
23c3			;	ld (hl), b     
23c3			 ; 
23c3			;	inc hl 
23c3			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
23c3			; 
23c3			; 
23c3			;	inc hl 
23c3			;	ld bc, forthexec 
23c3			;	ld (hl), c     ; poke address of forthexec 
23c3			;	inc hl 
23c3			;	ld (hl), b      
23c3			; 
23c3			;	inc hl 
23c3			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
23c3			; 
23c3			;	ld bc, user_dict_next 
23c3			;	inc hl 
23c3			;	ld (hl), c     ; poke address of forthexec 
23c3			;	inc hl 
23c3			;	ld (hl), b      
23c3			 
23c3				; hl is now where we need to copy the word byte data to save this 
23c3			 
23c3 23				inc hl 
23c4 22 11 ee			ld (os_new_exec), hl 
23c7				 
23c7				; copy definition 
23c7			 
23c7 eb				ex de, hl 
23c8			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
23c8			;	inc de    ; skip the PC for this parse 
23c8 3a 19 ee			ld a, (os_new_parse_len) 
23cb 4f				ld c, a 
23cc 06 00			ld b, 0 
23ce ed b0			ldir		 ; copy defintion 
23d0			 
23d0			 
23d0				; poke the address of where the new word bytes live for forthexec 
23d0			 
23d0 2a 0f ee			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
23d3			 
23d3 ed 5b 11 ee		ld de, (os_new_exec)      
23d7				 
23d7 73				ld (hl), e 
23d8 23				inc hl 
23d9 72				ld (hl), d 
23da			 
23da					; TODO copy last user dict word next link to this word 
23da					; TODO update last user dict word to point to this word 
23da			; 
23da			; hl f923 de 812a ; bc 811a 
23da			 
23da			if DEBUG_FORTH_UWORD 
23da c5				push bc 
23db ed 4b 1b ee		ld bc, (os_new_malloc) 
23df						DMARK ":0A" 
23df f5				push af  
23e0 3a f4 23			ld a, (.dmark)  
23e3 32 77 fb			ld (debug_mark),a  
23e6 3a f5 23			ld a, (.dmark+1)  
23e9 32 78 fb			ld (debug_mark+1),a  
23ec 3a f6 23			ld a, (.dmark+2)  
23ef 32 79 fb			ld (debug_mark+2),a  
23f2 18 03			jr .pastdmark  
23f4 ..			.dmark: db ":0A"  
23f7 f1			.pastdmark: pop af  
23f8			endm  
# End of macro DMARK
23f8				CALLMONITOR 
23f8 cd 4d 17			call break_point_state  
23fb				endm  
# End of macro CALLMONITOR
23fb c1				pop bc 
23fc			endif 
23fc			if DEBUG_FORTH_UWORD 
23fc c5				push bc 
23fd ed 4b 1b ee		ld bc, (os_new_malloc) 
2401 03				inc bc 
2402 03				inc bc 
2403 03				inc bc 
2404 03				inc bc 
2405 03				inc bc 
2406 03				inc bc 
2407 03				inc bc 
2408 03				inc bc 
2409			 
2409						DMARK ":0B" 
2409 f5				push af  
240a 3a 1e 24			ld a, (.dmark)  
240d 32 77 fb			ld (debug_mark),a  
2410 3a 1f 24			ld a, (.dmark+1)  
2413 32 78 fb			ld (debug_mark+1),a  
2416 3a 20 24			ld a, (.dmark+2)  
2419 32 79 fb			ld (debug_mark+2),a  
241c 18 03			jr .pastdmark  
241e ..			.dmark: db ":0B"  
2421 f1			.pastdmark: pop af  
2422			endm  
# End of macro DMARK
2422				CALLMONITOR 
2422 cd 4d 17			call break_point_state  
2425				endm  
# End of macro CALLMONITOR
2425 c1				pop bc 
2426			endif 
2426			 
2426			; update word dict linked list for new word 
2426			 
2426			 
2426 2a 1a f1		ld hl, (os_last_new_uword)		; get the start of the last added uword 
2429 23			inc hl     ; move to next work linked list ptr 
242a			 
242a ed 5b 1b ee	ld de, (os_new_malloc)		 ; new next word 
242e 73			ld (hl), e 
242f 23			inc hl 
2430 72			ld (hl), d 
2431			 
2431			if DEBUG_FORTH_UWORD 
2431 ed 4b 1a f1		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
2435			endif 
2435			 
2435 ed 53 1a f1	ld (os_last_new_uword), de      ; update last new uword ptr 
2439			 
2439			 
2439			if DEBUG_FORTH_UWORD 
2439						DMARK ":0+" 
2439 f5				push af  
243a 3a 4e 24			ld a, (.dmark)  
243d 32 77 fb			ld (debug_mark),a  
2440 3a 4f 24			ld a, (.dmark+1)  
2443 32 78 fb			ld (debug_mark+1),a  
2446 3a 50 24			ld a, (.dmark+2)  
2449 32 79 fb			ld (debug_mark+2),a  
244c 18 03			jr .pastdmark  
244e ..			.dmark: db ":0+"  
2451 f1			.pastdmark: pop af  
2452			endm  
# End of macro DMARK
2452				CALLMONITOR 
2452 cd 4d 17			call break_point_state  
2455				endm  
# End of macro CALLMONITOR
2455			endif 
2455			 
2455				STACKFRAMECHK OFF $8efe $989f 
2455				if DEBUG_STACK_IMB 
2455					if OFF 
2455						exx 
2455						ld hl, $989f 
2455						pop de   ; $989f 
2455						call cmp16 
2455						jr nz, .spnosame 
2455						ld hl, $8efe 
2455						pop de   ; $8efe 
2455						call cmp16 
2455						jr z, .spfrsame 
2455						.spnosame: call showsperror 
2455						.spfrsame: nop 
2455						exx 
2455					endif 
2455				endif 
2455			endm 
# End of macro STACKFRAMECHK
2455			 
2455 c9			ret    ; dont process any remaining parser tokens as they form new word 
2456			 
2456			 
2456			 
2456			 
2456			;		NEXT 
2456			.SCOLN: 
2456			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
2456 06				db OPCODE_SCOLN 
2457 a2 24			dw .DROP 
2459 02				db 2 
245a .. 00			db ";",0           
245c			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
245c					if DEBUG_FORTH_WORDS_KEY 
245c						DMARK "SCN" 
245c f5				push af  
245d 3a 71 24			ld a, (.dmark)  
2460 32 77 fb			ld (debug_mark),a  
2463 3a 72 24			ld a, (.dmark+1)  
2466 32 78 fb			ld (debug_mark+1),a  
2469 3a 73 24			ld a, (.dmark+2)  
246c 32 79 fb			ld (debug_mark+2),a  
246f 18 03			jr .pastdmark  
2471 ..			.dmark: db "SCN"  
2474 f1			.pastdmark: pop af  
2475			endm  
# End of macro DMARK
2475						CALLMONITOR 
2475 cd 4d 17			call break_point_state  
2478				endm  
# End of macro CALLMONITOR
2478					endif 
2478					FORTH_RSP_TOS 
2478 cd 9b 1c			call macro_forth_rsp_tos 
247b				endm 
# End of macro FORTH_RSP_TOS
247b e5					push hl 
247c					FORTH_RSP_POP 
247c cd a5 1c			call macro_forth_rsp_pop 
247f				endm 
# End of macro FORTH_RSP_POP
247f e1					pop hl 
2480			;		ex de,hl 
2480 22 1e f1				ld (os_tok_ptr),hl 
2483			 
2483			if DEBUG_FORTH_UWORD 
2483						DMARK "SCL" 
2483 f5				push af  
2484 3a 98 24			ld a, (.dmark)  
2487 32 77 fb			ld (debug_mark),a  
248a 3a 99 24			ld a, (.dmark+1)  
248d 32 78 fb			ld (debug_mark+1),a  
2490 3a 9a 24			ld a, (.dmark+2)  
2493 32 79 fb			ld (debug_mark+2),a  
2496 18 03			jr .pastdmark  
2498 ..			.dmark: db "SCL"  
249b f1			.pastdmark: pop af  
249c			endm  
# End of macro DMARK
249c				CALLMONITOR 
249c cd 4d 17			call break_point_state  
249f				endm  
# End of macro CALLMONITOR
249f			endif 
249f					NEXTW 
249f c3 46 20			jp macro_next 
24a2				endm 
# End of macro NEXTW
24a2			 
24a2			.DROP: 
24a2				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
24a2 1b				db WORD_SYS_CORE+OPCODE_DROP             
24a3 cd 24			dw .DUP2            
24a5 05				db 4 + 1 
24a6 .. 00			db "DROP",0              
24ab				endm 
# End of macro CWHEAD
24ab			; | DROP ( w -- )   drop the TOS item   | DONE 
24ab					if DEBUG_FORTH_WORDS_KEY 
24ab						DMARK "DRP" 
24ab f5				push af  
24ac 3a c0 24			ld a, (.dmark)  
24af 32 77 fb			ld (debug_mark),a  
24b2 3a c1 24			ld a, (.dmark+1)  
24b5 32 78 fb			ld (debug_mark+1),a  
24b8 3a c2 24			ld a, (.dmark+2)  
24bb 32 79 fb			ld (debug_mark+2),a  
24be 18 03			jr .pastdmark  
24c0 ..			.dmark: db "DRP"  
24c3 f1			.pastdmark: pop af  
24c4			endm  
# End of macro DMARK
24c4						CALLMONITOR 
24c4 cd 4d 17			call break_point_state  
24c7				endm  
# End of macro CALLMONITOR
24c7					endif 
24c7					FORTH_DSP_POP 
24c7 cd 8c 1f			call macro_forth_dsp_pop 
24ca				endm 
# End of macro FORTH_DSP_POP
24ca					NEXTW 
24ca c3 46 20			jp macro_next 
24cd				endm 
# End of macro NEXTW
24cd			.DUP2: 
24cd				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
24cd 1c				db WORD_SYS_CORE+OPCODE_DUP2             
24ce 12 25			dw .DROP2            
24d0 05				db 4 + 1 
24d1 .. 00			db "2DUP",0              
24d6				endm 
# End of macro CWHEAD
24d6			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
24d6					if DEBUG_FORTH_WORDS_KEY 
24d6						DMARK "2DU" 
24d6 f5				push af  
24d7 3a eb 24			ld a, (.dmark)  
24da 32 77 fb			ld (debug_mark),a  
24dd 3a ec 24			ld a, (.dmark+1)  
24e0 32 78 fb			ld (debug_mark+1),a  
24e3 3a ed 24			ld a, (.dmark+2)  
24e6 32 79 fb			ld (debug_mark+2),a  
24e9 18 03			jr .pastdmark  
24eb ..			.dmark: db "2DU"  
24ee f1			.pastdmark: pop af  
24ef			endm  
# End of macro DMARK
24ef						CALLMONITOR 
24ef cd 4d 17			call break_point_state  
24f2				endm  
# End of macro CALLMONITOR
24f2					endif 
24f2					FORTH_DSP_VALUEHL 
24f2 cd d4 1e			call macro_dsp_valuehl 
24f5				endm 
# End of macro FORTH_DSP_VALUEHL
24f5 e5					push hl      ; 2 
24f6			 
24f6					FORTH_DSP_POP 
24f6 cd 8c 1f			call macro_forth_dsp_pop 
24f9				endm 
# End of macro FORTH_DSP_POP
24f9					 
24f9					FORTH_DSP_VALUEHL 
24f9 cd d4 1e			call macro_dsp_valuehl 
24fc				endm 
# End of macro FORTH_DSP_VALUEHL
24fc			;		push hl      ; 1 
24fc			 
24fc					FORTH_DSP_POP 
24fc cd 8c 1f			call macro_forth_dsp_pop 
24ff				endm 
# End of macro FORTH_DSP_POP
24ff			 
24ff			;		pop hl       ; 1 
24ff d1					pop de       ; 2 
2500			 
2500 cd dd 1c				call forth_push_numhl 
2503 eb					ex de, hl 
2504 cd dd 1c				call forth_push_numhl 
2507			 
2507					 
2507 eb					ex de, hl 
2508			 
2508 cd dd 1c				call forth_push_numhl 
250b eb					ex de, hl 
250c cd dd 1c				call forth_push_numhl 
250f			 
250f			 
250f					NEXTW 
250f c3 46 20			jp macro_next 
2512				endm 
# End of macro NEXTW
2512			.DROP2: 
2512				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
2512 1d				db WORD_SYS_CORE+OPCODE_DROP2             
2513 41 25			dw .SWAP2            
2515 06				db 5 + 1 
2516 .. 00			db "2DROP",0              
251c				endm 
# End of macro CWHEAD
251c			; | 2DROP ( w w -- )    Double drop | DONE 
251c					if DEBUG_FORTH_WORDS_KEY 
251c						DMARK "2DR" 
251c f5				push af  
251d 3a 31 25			ld a, (.dmark)  
2520 32 77 fb			ld (debug_mark),a  
2523 3a 32 25			ld a, (.dmark+1)  
2526 32 78 fb			ld (debug_mark+1),a  
2529 3a 33 25			ld a, (.dmark+2)  
252c 32 79 fb			ld (debug_mark+2),a  
252f 18 03			jr .pastdmark  
2531 ..			.dmark: db "2DR"  
2534 f1			.pastdmark: pop af  
2535			endm  
# End of macro DMARK
2535						CALLMONITOR 
2535 cd 4d 17			call break_point_state  
2538				endm  
# End of macro CALLMONITOR
2538					endif 
2538					FORTH_DSP_POP 
2538 cd 8c 1f			call macro_forth_dsp_pop 
253b				endm 
# End of macro FORTH_DSP_POP
253b					FORTH_DSP_POP 
253b cd 8c 1f			call macro_forth_dsp_pop 
253e				endm 
# End of macro FORTH_DSP_POP
253e					NEXTW 
253e c3 46 20			jp macro_next 
2541				endm 
# End of macro NEXTW
2541			.SWAP2: 
2541				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
2541 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
2542 6a 25			dw .AT            
2544 06				db 5 + 1 
2545 .. 00			db "2SWAP",0              
254b				endm 
# End of macro CWHEAD
254b			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
254b					if DEBUG_FORTH_WORDS_KEY 
254b						DMARK "2SW" 
254b f5				push af  
254c 3a 60 25			ld a, (.dmark)  
254f 32 77 fb			ld (debug_mark),a  
2552 3a 61 25			ld a, (.dmark+1)  
2555 32 78 fb			ld (debug_mark+1),a  
2558 3a 62 25			ld a, (.dmark+2)  
255b 32 79 fb			ld (debug_mark+2),a  
255e 18 03			jr .pastdmark  
2560 ..			.dmark: db "2SW"  
2563 f1			.pastdmark: pop af  
2564			endm  
# End of macro DMARK
2564						CALLMONITOR 
2564 cd 4d 17			call break_point_state  
2567				endm  
# End of macro CALLMONITOR
2567					endif 
2567					NEXTW 
2567 c3 46 20			jp macro_next 
256a				endm 
# End of macro NEXTW
256a			.AT: 
256a				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
256a 1f				db WORD_SYS_CORE+OPCODE_AT             
256b 9c 25			dw .CAT            
256d 02				db 1 + 1 
256e .. 00			db "@",0              
2570				endm 
# End of macro CWHEAD
2570			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
2570			 
2570					if DEBUG_FORTH_WORDS_KEY 
2570						DMARK "AT." 
2570 f5				push af  
2571 3a 85 25			ld a, (.dmark)  
2574 32 77 fb			ld (debug_mark),a  
2577 3a 86 25			ld a, (.dmark+1)  
257a 32 78 fb			ld (debug_mark+1),a  
257d 3a 87 25			ld a, (.dmark+2)  
2580 32 79 fb			ld (debug_mark+2),a  
2583 18 03			jr .pastdmark  
2585 ..			.dmark: db "AT."  
2588 f1			.pastdmark: pop af  
2589			endm  
# End of macro DMARK
2589						CALLMONITOR 
2589 cd 4d 17			call break_point_state  
258c				endm  
# End of macro CALLMONITOR
258c					endif 
258c			.getbyteat:	 
258c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
258c cd d4 1e			call macro_dsp_valuehl 
258f				endm 
# End of macro FORTH_DSP_VALUEHL
258f					 
258f			;		push hl 
258f				 
258f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
258f cd 8c 1f			call macro_forth_dsp_pop 
2592				endm 
# End of macro FORTH_DSP_POP
2592			 
2592			;		pop hl 
2592			 
2592 7e					ld a, (hl) 
2593			 
2593 6f					ld l, a 
2594 26 00				ld h, 0 
2596 cd dd 1c				call forth_push_numhl 
2599			 
2599					NEXTW 
2599 c3 46 20			jp macro_next 
259c				endm 
# End of macro NEXTW
259c			.CAT: 
259c				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
259c 20				db WORD_SYS_CORE+OPCODE_CAT             
259d c5 25			dw .BANG            
259f 03				db 2 + 1 
25a0 .. 00			db "C@",0              
25a3				endm 
# End of macro CWHEAD
25a3			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
25a3					if DEBUG_FORTH_WORDS_KEY 
25a3						DMARK "CAA" 
25a3 f5				push af  
25a4 3a b8 25			ld a, (.dmark)  
25a7 32 77 fb			ld (debug_mark),a  
25aa 3a b9 25			ld a, (.dmark+1)  
25ad 32 78 fb			ld (debug_mark+1),a  
25b0 3a ba 25			ld a, (.dmark+2)  
25b3 32 79 fb			ld (debug_mark+2),a  
25b6 18 03			jr .pastdmark  
25b8 ..			.dmark: db "CAA"  
25bb f1			.pastdmark: pop af  
25bc			endm  
# End of macro DMARK
25bc						CALLMONITOR 
25bc cd 4d 17			call break_point_state  
25bf				endm  
# End of macro CALLMONITOR
25bf					endif 
25bf c3 8c 25				jp .getbyteat 
25c2					NEXTW 
25c2 c3 46 20			jp macro_next 
25c5				endm 
# End of macro NEXTW
25c5			.BANG: 
25c5				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
25c5 21				db WORD_SYS_CORE+OPCODE_BANG             
25c6 fb 25			dw .CBANG            
25c8 02				db 1 + 1 
25c9 .. 00			db "!",0              
25cb				endm 
# End of macro CWHEAD
25cb			; | ! ( x w -- ) Store x at address w      | DONE 
25cb					if DEBUG_FORTH_WORDS_KEY 
25cb						DMARK "BNG" 
25cb f5				push af  
25cc 3a e0 25			ld a, (.dmark)  
25cf 32 77 fb			ld (debug_mark),a  
25d2 3a e1 25			ld a, (.dmark+1)  
25d5 32 78 fb			ld (debug_mark+1),a  
25d8 3a e2 25			ld a, (.dmark+2)  
25db 32 79 fb			ld (debug_mark+2),a  
25de 18 03			jr .pastdmark  
25e0 ..			.dmark: db "BNG"  
25e3 f1			.pastdmark: pop af  
25e4			endm  
# End of macro DMARK
25e4						CALLMONITOR 
25e4 cd 4d 17			call break_point_state  
25e7				endm  
# End of macro CALLMONITOR
25e7					endif 
25e7			 
25e7			.storebyteat:		 
25e7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25e7 cd d4 1e			call macro_dsp_valuehl 
25ea				endm 
# End of macro FORTH_DSP_VALUEHL
25ea					 
25ea e5					push hl 
25eb				 
25eb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25eb cd 8c 1f			call macro_forth_dsp_pop 
25ee				endm 
# End of macro FORTH_DSP_POP
25ee			 
25ee					; get byte to poke 
25ee			 
25ee					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25ee cd d4 1e			call macro_dsp_valuehl 
25f1				endm 
# End of macro FORTH_DSP_VALUEHL
25f1 e5					push hl 
25f2			 
25f2			 
25f2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25f2 cd 8c 1f			call macro_forth_dsp_pop 
25f5				endm 
# End of macro FORTH_DSP_POP
25f5			 
25f5			 
25f5 d1					pop de 
25f6 e1					pop hl 
25f7			 
25f7 73					ld (hl),e 
25f8			 
25f8			 
25f8					NEXTW 
25f8 c3 46 20			jp macro_next 
25fb				endm 
# End of macro NEXTW
25fb			.CBANG: 
25fb				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
25fb 22				db WORD_SYS_CORE+OPCODE_CBANG             
25fc 24 26			dw .SCALL            
25fe 03				db 2 + 1 
25ff .. 00			db "C!",0              
2602				endm 
# End of macro CWHEAD
2602			; | C!  ( x w -- ) Store x at address w  | DONE 
2602					if DEBUG_FORTH_WORDS_KEY 
2602						DMARK "CBA" 
2602 f5				push af  
2603 3a 17 26			ld a, (.dmark)  
2606 32 77 fb			ld (debug_mark),a  
2609 3a 18 26			ld a, (.dmark+1)  
260c 32 78 fb			ld (debug_mark+1),a  
260f 3a 19 26			ld a, (.dmark+2)  
2612 32 79 fb			ld (debug_mark+2),a  
2615 18 03			jr .pastdmark  
2617 ..			.dmark: db "CBA"  
261a f1			.pastdmark: pop af  
261b			endm  
# End of macro DMARK
261b						CALLMONITOR 
261b cd 4d 17			call break_point_state  
261e				endm  
# End of macro CALLMONITOR
261e					endif 
261e c3 e7 25				jp .storebyteat 
2621					NEXTW 
2621 c3 46 20			jp macro_next 
2624				endm 
# End of macro NEXTW
2624			.SCALL: 
2624				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
2624 23				db WORD_SYS_CORE+OPCODE_SCALL             
2625 58 26			dw .DEPTH            
2627 05				db 4 + 1 
2628 .. 00			db "CALL",0              
262d				endm 
# End of macro CWHEAD
262d			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
262d					if DEBUG_FORTH_WORDS_KEY 
262d						DMARK "CLL" 
262d f5				push af  
262e 3a 42 26			ld a, (.dmark)  
2631 32 77 fb			ld (debug_mark),a  
2634 3a 43 26			ld a, (.dmark+1)  
2637 32 78 fb			ld (debug_mark+1),a  
263a 3a 44 26			ld a, (.dmark+2)  
263d 32 79 fb			ld (debug_mark+2),a  
2640 18 03			jr .pastdmark  
2642 ..			.dmark: db "CLL"  
2645 f1			.pastdmark: pop af  
2646			endm  
# End of macro DMARK
2646						CALLMONITOR 
2646 cd 4d 17			call break_point_state  
2649				endm  
# End of macro CALLMONITOR
2649					endif 
2649			 
2649					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2649 cd d4 1e			call macro_dsp_valuehl 
264c				endm 
# End of macro FORTH_DSP_VALUEHL
264c			 
264c			;		push hl 
264c			 
264c					; destroy value TOS 
264c			 
264c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
264c cd 8c 1f			call macro_forth_dsp_pop 
264f				endm 
# End of macro FORTH_DSP_POP
264f			 
264f						 
264f			;		pop hl 
264f			 
264f					; how to do a call with hl???? save SP? 
264f cd ef 1f				call forth_call_hl 
2652			 
2652			 
2652					; TODO push value back onto stack for another op etc 
2652			 
2652 cd dd 1c				call forth_push_numhl 
2655					NEXTW 
2655 c3 46 20			jp macro_next 
2658				endm 
# End of macro NEXTW
2658			.DEPTH: 
2658				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2658 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2659 95 26			dw .OVER            
265b 06				db 5 + 1 
265c .. 00			db "DEPTH",0              
2662				endm 
# End of macro CWHEAD
2662			; | DEPTH ( -- u ) Push count of stack | DONE 
2662					; take current TOS and remove from base value div by two to get count 
2662					if DEBUG_FORTH_WORDS_KEY 
2662						DMARK "DEP" 
2662 f5				push af  
2663 3a 77 26			ld a, (.dmark)  
2666 32 77 fb			ld (debug_mark),a  
2669 3a 78 26			ld a, (.dmark+1)  
266c 32 78 fb			ld (debug_mark+1),a  
266f 3a 79 26			ld a, (.dmark+2)  
2672 32 79 fb			ld (debug_mark+2),a  
2675 18 03			jr .pastdmark  
2677 ..			.dmark: db "DEP"  
267a f1			.pastdmark: pop af  
267b			endm  
# End of macro DMARK
267b						CALLMONITOR 
267b cd 4d 17			call break_point_state  
267e				endm  
# End of macro CALLMONITOR
267e					endif 
267e			 
267e			 
267e 2a 0a f8			ld hl, (cli_data_sp) 
2681 11 84 f3			ld de, cli_data_stack 
2684 ed 52			sbc hl,de 
2686				 
2686				; div by size of stack item 
2686			 
2686 5d				ld e,l 
2687 0e 03			ld c, 3 
2689 cd 99 0c			call Div8 
268c			 
268c 6f				ld l,a 
268d 26 00			ld h,0 
268f			 
268f				;srl h 
268f				;rr l 
268f			 
268f cd dd 1c				call forth_push_numhl 
2692					NEXTW 
2692 c3 46 20			jp macro_next 
2695				endm 
# End of macro NEXTW
2695			.OVER: 
2695				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2695 42				db WORD_SYS_CORE+46             
2696 dc 26			dw .PAUSE            
2698 05				db 4 + 1 
2699 .. 00			db "OVER",0              
269e				endm 
# End of macro CWHEAD
269e			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
269e					if DEBUG_FORTH_WORDS_KEY 
269e						DMARK "OVR" 
269e f5				push af  
269f 3a b3 26			ld a, (.dmark)  
26a2 32 77 fb			ld (debug_mark),a  
26a5 3a b4 26			ld a, (.dmark+1)  
26a8 32 78 fb			ld (debug_mark+1),a  
26ab 3a b5 26			ld a, (.dmark+2)  
26ae 32 79 fb			ld (debug_mark+2),a  
26b1 18 03			jr .pastdmark  
26b3 ..			.dmark: db "OVR"  
26b6 f1			.pastdmark: pop af  
26b7			endm  
# End of macro DMARK
26b7						CALLMONITOR 
26b7 cd 4d 17			call break_point_state  
26ba				endm  
# End of macro CALLMONITOR
26ba					endif 
26ba			 
26ba					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26ba cd d4 1e			call macro_dsp_valuehl 
26bd				endm 
# End of macro FORTH_DSP_VALUEHL
26bd e5					push hl    ; n2 
26be					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26be cd 8c 1f			call macro_forth_dsp_pop 
26c1				endm 
# End of macro FORTH_DSP_POP
26c1			 
26c1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26c1 cd d4 1e			call macro_dsp_valuehl 
26c4				endm 
# End of macro FORTH_DSP_VALUEHL
26c4 e5					push hl    ; n1 
26c5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26c5 cd 8c 1f			call macro_forth_dsp_pop 
26c8				endm 
# End of macro FORTH_DSP_POP
26c8			 
26c8 d1					pop de     ; n1 
26c9 e1					pop hl     ; n2 
26ca			 
26ca d5					push de 
26cb e5					push hl 
26cc d5					push de 
26cd			 
26cd					; push back  
26cd			 
26cd e1					pop hl 
26ce cd dd 1c				call forth_push_numhl 
26d1 e1					pop hl 
26d2 cd dd 1c				call forth_push_numhl 
26d5 e1					pop hl 
26d6 cd dd 1c				call forth_push_numhl 
26d9					NEXTW 
26d9 c3 46 20			jp macro_next 
26dc				endm 
# End of macro NEXTW
26dc			 
26dc			.PAUSE: 
26dc				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
26dc 43				db WORD_SYS_CORE+47             
26dd 11 27			dw .PAUSES            
26df 08				db 7 + 1 
26e0 .. 00			db "PAUSEMS",0              
26e8				endm 
# End of macro CWHEAD
26e8			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
26e8					if DEBUG_FORTH_WORDS_KEY 
26e8						DMARK "PMS" 
26e8 f5				push af  
26e9 3a fd 26			ld a, (.dmark)  
26ec 32 77 fb			ld (debug_mark),a  
26ef 3a fe 26			ld a, (.dmark+1)  
26f2 32 78 fb			ld (debug_mark+1),a  
26f5 3a ff 26			ld a, (.dmark+2)  
26f8 32 79 fb			ld (debug_mark+2),a  
26fb 18 03			jr .pastdmark  
26fd ..			.dmark: db "PMS"  
2700 f1			.pastdmark: pop af  
2701			endm  
# End of macro DMARK
2701						CALLMONITOR 
2701 cd 4d 17			call break_point_state  
2704				endm  
# End of macro CALLMONITOR
2704					endif 
2704					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2704 cd d4 1e			call macro_dsp_valuehl 
2707				endm 
# End of macro FORTH_DSP_VALUEHL
2707			;		push hl    ; n2 
2707					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2707 cd 8c 1f			call macro_forth_dsp_pop 
270a				endm 
# End of macro FORTH_DSP_POP
270a			;		pop hl 
270a			 
270a 7d					ld a, l 
270b cd 3a 0a				call aDelayInMS 
270e				       NEXTW 
270e c3 46 20			jp macro_next 
2711				endm 
# End of macro NEXTW
2711			.PAUSES:  
2711				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
2711 44				db WORD_SYS_CORE+48             
2712 80 27			dw .ROT            
2714 06				db 5 + 1 
2715 .. 00			db "PAUSE",0              
271b				endm 
# End of macro CWHEAD
271b			; | PAUSE ( n -- )  Pause for n seconds | DONE 
271b					if DEBUG_FORTH_WORDS_KEY 
271b						DMARK "PAU" 
271b f5				push af  
271c 3a 30 27			ld a, (.dmark)  
271f 32 77 fb			ld (debug_mark),a  
2722 3a 31 27			ld a, (.dmark+1)  
2725 32 78 fb			ld (debug_mark+1),a  
2728 3a 32 27			ld a, (.dmark+2)  
272b 32 79 fb			ld (debug_mark+2),a  
272e 18 03			jr .pastdmark  
2730 ..			.dmark: db "PAU"  
2733 f1			.pastdmark: pop af  
2734			endm  
# End of macro DMARK
2734						CALLMONITOR 
2734 cd 4d 17			call break_point_state  
2737				endm  
# End of macro CALLMONITOR
2737					endif 
2737					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2737 cd d4 1e			call macro_dsp_valuehl 
273a				endm 
# End of macro FORTH_DSP_VALUEHL
273a			;		push hl    ; n2 
273a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
273a cd 8c 1f			call macro_forth_dsp_pop 
273d				endm 
# End of macro FORTH_DSP_POP
273d			;		pop hl 
273d 45					ld b, l 
273e					if DEBUG_FORTH_WORDS 
273e						DMARK "PAU" 
273e f5				push af  
273f 3a 53 27			ld a, (.dmark)  
2742 32 77 fb			ld (debug_mark),a  
2745 3a 54 27			ld a, (.dmark+1)  
2748 32 78 fb			ld (debug_mark+1),a  
274b 3a 55 27			ld a, (.dmark+2)  
274e 32 79 fb			ld (debug_mark+2),a  
2751 18 03			jr .pastdmark  
2753 ..			.dmark: db "PAU"  
2756 f1			.pastdmark: pop af  
2757			endm  
# End of macro DMARK
2757						CALLMONITOR 
2757 cd 4d 17			call break_point_state  
275a				endm  
# End of macro CALLMONITOR
275a					endif 
275a c5			.pauses1:	push bc 
275b cd 55 0a				call delay1s 
275e c1					pop bc 
275f					if DEBUG_FORTH_WORDS 
275f						DMARK "PA1" 
275f f5				push af  
2760 3a 74 27			ld a, (.dmark)  
2763 32 77 fb			ld (debug_mark),a  
2766 3a 75 27			ld a, (.dmark+1)  
2769 32 78 fb			ld (debug_mark+1),a  
276c 3a 76 27			ld a, (.dmark+2)  
276f 32 79 fb			ld (debug_mark+2),a  
2772 18 03			jr .pastdmark  
2774 ..			.dmark: db "PA1"  
2777 f1			.pastdmark: pop af  
2778			endm  
# End of macro DMARK
2778						CALLMONITOR 
2778 cd 4d 17			call break_point_state  
277b				endm  
# End of macro CALLMONITOR
277b					endif 
277b 10 dd				djnz .pauses1 
277d			 
277d				       NEXTW 
277d c3 46 20			jp macro_next 
2780				endm 
# End of macro NEXTW
2780			.ROT: 
2780				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2780 45				db WORD_SYS_CORE+49             
2781 ce 27			dw .UWORDS            
2783 04				db 3 + 1 
2784 .. 00			db "ROT",0              
2788				endm 
# End of macro CWHEAD
2788			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2788					if DEBUG_FORTH_WORDS_KEY 
2788						DMARK "ROT" 
2788 f5				push af  
2789 3a 9d 27			ld a, (.dmark)  
278c 32 77 fb			ld (debug_mark),a  
278f 3a 9e 27			ld a, (.dmark+1)  
2792 32 78 fb			ld (debug_mark+1),a  
2795 3a 9f 27			ld a, (.dmark+2)  
2798 32 79 fb			ld (debug_mark+2),a  
279b 18 03			jr .pastdmark  
279d ..			.dmark: db "ROT"  
27a0 f1			.pastdmark: pop af  
27a1			endm  
# End of macro DMARK
27a1						CALLMONITOR 
27a1 cd 4d 17			call break_point_state  
27a4				endm  
# End of macro CALLMONITOR
27a4					endif 
27a4			 
27a4					FORTH_DSP_VALUEHL 
27a4 cd d4 1e			call macro_dsp_valuehl 
27a7				endm 
# End of macro FORTH_DSP_VALUEHL
27a7 e5					push hl    ; u3  
27a8			 
27a8					FORTH_DSP_POP 
27a8 cd 8c 1f			call macro_forth_dsp_pop 
27ab				endm 
# End of macro FORTH_DSP_POP
27ab			   
27ab					FORTH_DSP_VALUEHL 
27ab cd d4 1e			call macro_dsp_valuehl 
27ae				endm 
# End of macro FORTH_DSP_VALUEHL
27ae e5					push hl     ; u2 
27af			 
27af					FORTH_DSP_POP 
27af cd 8c 1f			call macro_forth_dsp_pop 
27b2				endm 
# End of macro FORTH_DSP_POP
27b2			 
27b2					FORTH_DSP_VALUEHL 
27b2 cd d4 1e			call macro_dsp_valuehl 
27b5				endm 
# End of macro FORTH_DSP_VALUEHL
27b5 e5					push hl     ; u1 
27b6			 
27b6					FORTH_DSP_POP 
27b6 cd 8c 1f			call macro_forth_dsp_pop 
27b9				endm 
# End of macro FORTH_DSP_POP
27b9			 
27b9 c1					pop bc      ; u1 
27ba e1					pop hl      ; u2 
27bb d1					pop de      ; u3 
27bc			 
27bc			 
27bc c5					push bc 
27bd d5					push de 
27be e5					push hl 
27bf			 
27bf			 
27bf e1					pop hl 
27c0 cd dd 1c				call forth_push_numhl 
27c3			 
27c3 e1					pop hl 
27c4 cd dd 1c				call forth_push_numhl 
27c7			 
27c7 e1					pop hl 
27c8 cd dd 1c				call forth_push_numhl 
27cb					 
27cb			 
27cb			 
27cb			 
27cb			 
27cb			 
27cb				       NEXTW 
27cb c3 46 20			jp macro_next 
27ce				endm 
# End of macro NEXTW
27ce			 
27ce			.UWORDS: 
27ce				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
27ce 50				db WORD_SYS_CORE+60             
27cf 90 28			dw .BP            
27d1 07				db 6 + 1 
27d2 .. 00			db "UWORDS",0              
27d9				endm 
# End of macro CWHEAD
27d9			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
27d9			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
27d9			; | | Following the count are the individual words. 
27d9			; | | 
27d9			; | | e.g. UWORDS 
27d9			; | | BOX DIRLIST 2 
27d9			; | |  
27d9			; | | Can be used to save the words to storage via: 
27d9			; | | UWORDS $01 DO $01 APPEND LOOP 
27d9				if DEBUG_FORTH_WORDS_KEY 
27d9					DMARK "UWR" 
27d9 f5				push af  
27da 3a ee 27			ld a, (.dmark)  
27dd 32 77 fb			ld (debug_mark),a  
27e0 3a ef 27			ld a, (.dmark+1)  
27e3 32 78 fb			ld (debug_mark+1),a  
27e6 3a f0 27			ld a, (.dmark+2)  
27e9 32 79 fb			ld (debug_mark+2),a  
27ec 18 03			jr .pastdmark  
27ee ..			.dmark: db "UWR"  
27f1 f1			.pastdmark: pop af  
27f2			endm  
# End of macro DMARK
27f2					CALLMONITOR 
27f2 cd 4d 17			call break_point_state  
27f5				endm  
# End of macro CALLMONITOR
27f5				endif 
27f5 21 00 80				ld hl, baseram 
27f8					;ld hl, baseusermem 
27f8 01 00 00				ld bc, 0    ; start a counter 
27fb			 
27fb				; skip dict stub 
27fb			 
27fb cd 97 21				call forth_tok_next 
27fe			 
27fe			 
27fe			; while we have words to look for 
27fe			 
27fe 7e			.douscan:	ld a, (hl)      
27ff				if DEBUG_FORTH_WORDS 
27ff					DMARK "UWs" 
27ff f5				push af  
2800 3a 14 28			ld a, (.dmark)  
2803 32 77 fb			ld (debug_mark),a  
2806 3a 15 28			ld a, (.dmark+1)  
2809 32 78 fb			ld (debug_mark+1),a  
280c 3a 16 28			ld a, (.dmark+2)  
280f 32 79 fb			ld (debug_mark+2),a  
2812 18 03			jr .pastdmark  
2814 ..			.dmark: db "UWs"  
2817 f1			.pastdmark: pop af  
2818			endm  
# End of macro DMARK
2818					CALLMONITOR 
2818 cd 4d 17			call break_point_state  
281b				endm  
# End of macro CALLMONITOR
281b				endif 
281b fe 00				cp WORD_SYS_END 
281d 28 4d				jr z, .udone 
281f fe 01				cp WORD_SYS_UWORD 
2821 20 44				jr nz, .nuword 
2823			 
2823				if DEBUG_FORTH_WORDS 
2823					DMARK "UWu" 
2823 f5				push af  
2824 3a 38 28			ld a, (.dmark)  
2827 32 77 fb			ld (debug_mark),a  
282a 3a 39 28			ld a, (.dmark+1)  
282d 32 78 fb			ld (debug_mark+1),a  
2830 3a 3a 28			ld a, (.dmark+2)  
2833 32 79 fb			ld (debug_mark+2),a  
2836 18 03			jr .pastdmark  
2838 ..			.dmark: db "UWu"  
283b f1			.pastdmark: pop af  
283c			endm  
# End of macro DMARK
283c					CALLMONITOR 
283c cd 4d 17			call break_point_state  
283f				endm  
# End of macro CALLMONITOR
283f				endif 
283f					; we have a uword so push its name to the stack 
283f			 
283f e5				   	push hl  ; save so we can move to next dict block 
2840			 
2840					; skip opcode 
2840 23					inc hl  
2841					; skip next ptr 
2841 23					inc hl  
2842 23					inc hl 
2843					; skip len 
2843 23					inc hl 
2844				if DEBUG_FORTH_WORDS 
2844					DMARK "UWt" 
2844 f5				push af  
2845 3a 59 28			ld a, (.dmark)  
2848 32 77 fb			ld (debug_mark),a  
284b 3a 5a 28			ld a, (.dmark+1)  
284e 32 78 fb			ld (debug_mark+1),a  
2851 3a 5b 28			ld a, (.dmark+2)  
2854 32 79 fb			ld (debug_mark+2),a  
2857 18 03			jr .pastdmark  
2859 ..			.dmark: db "UWt"  
285c f1			.pastdmark: pop af  
285d			endm  
# End of macro DMARK
285d					CALLMONITOR 
285d cd 4d 17			call break_point_state  
2860				endm  
# End of macro CALLMONITOR
2860				endif 
2860 03					inc bc 
2861			 
2861 c5					push bc 
2862 cd 4b 1d				call forth_push_str 
2865 c1					pop bc 
2866			 
2866 e1					pop hl 	 
2867			 
2867 cd 97 21		.nuword:	call forth_tok_next 
286a 18 92				jr .douscan  
286c			 
286c			.udone:		 ; push count of uwords found 
286c c5					push bc 
286d e1					pop hl 
286e			 
286e				if DEBUG_FORTH_WORDS 
286e					DMARK "UWc" 
286e f5				push af  
286f 3a 83 28			ld a, (.dmark)  
2872 32 77 fb			ld (debug_mark),a  
2875 3a 84 28			ld a, (.dmark+1)  
2878 32 78 fb			ld (debug_mark+1),a  
287b 3a 85 28			ld a, (.dmark+2)  
287e 32 79 fb			ld (debug_mark+2),a  
2881 18 03			jr .pastdmark  
2883 ..			.dmark: db "UWc"  
2886 f1			.pastdmark: pop af  
2887			endm  
# End of macro DMARK
2887					CALLMONITOR 
2887 cd 4d 17			call break_point_state  
288a				endm  
# End of macro CALLMONITOR
288a				endif 
288a cd dd 1c				call forth_push_numhl 
288d			 
288d			 
288d				       NEXTW 
288d c3 46 20			jp macro_next 
2890				endm 
# End of macro NEXTW
2890			 
2890			.BP: 
2890				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2890 54				db WORD_SYS_CORE+64             
2891 c6 28			dw .MONITOR            
2893 03				db 2 + 1 
2894 .. 00			db "BP",0              
2897				endm 
# End of macro CWHEAD
2897			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2897			; | | $00 Will enable the break points within specific code paths 
2897			; | | $01 Will disable break points 
2897			; | |  
2897			; | | By default break points are off. Either the above can be used to enable them 
2897			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2897			; | | and on release of the pressed key a message will be disaplayed to notify 
2897			; | | that break points are enabled. Pressing any key will then continue boot process. 
2897					; get byte count 
2897					if DEBUG_FORTH_WORDS_KEY 
2897						DMARK "BP." 
2897 f5				push af  
2898 3a ac 28			ld a, (.dmark)  
289b 32 77 fb			ld (debug_mark),a  
289e 3a ad 28			ld a, (.dmark+1)  
28a1 32 78 fb			ld (debug_mark+1),a  
28a4 3a ae 28			ld a, (.dmark+2)  
28a7 32 79 fb			ld (debug_mark+2),a  
28aa 18 03			jr .pastdmark  
28ac ..			.dmark: db "BP."  
28af f1			.pastdmark: pop af  
28b0			endm  
# End of macro DMARK
28b0						CALLMONITOR 
28b0 cd 4d 17			call break_point_state  
28b3				endm  
# End of macro CALLMONITOR
28b3					endif 
28b3			 
28b3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
28b3 cd d4 1e			call macro_dsp_valuehl 
28b6				endm 
# End of macro FORTH_DSP_VALUEHL
28b6			 
28b6			;		push hl 
28b6			 
28b6					; destroy value TOS 
28b6			 
28b6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
28b6 cd 8c 1f			call macro_forth_dsp_pop 
28b9				endm 
# End of macro FORTH_DSP_POP
28b9			 
28b9			;		pop hl 
28b9			 
28b9 3e 00				ld a,0 
28bb bd					cp l 
28bc 28 02				jr z, .bpset 
28be 3e 2a				ld a, '*' 
28c0			 
28c0 32 0e ee		.bpset:		ld (os_view_disable), a 
28c3			 
28c3			 
28c3					NEXTW 
28c3 c3 46 20			jp macro_next 
28c6				endm 
# End of macro NEXTW
28c6			 
28c6			 
28c6			.MONITOR: 
28c6				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
28c6 55				db WORD_SYS_CORE+65             
28c7 f9 28			dw .MALLOC            
28c9 08				db 7 + 1 
28ca .. 00			db "MONITOR",0              
28d2				endm 
# End of macro CWHEAD
28d2			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
28d2			; | | At start the current various registers will be displayed with contents. 
28d2			; | | Top right corner will show the most recent debug marker seen. 
28d2			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
28d2			; | | and the return stack pointer (RSP). 
28d2			; | | Pressing: 
28d2			; | |    1 - Initial screen 
28d2			; | |    2 - Display a data dump of HL 
28d2			; | |    3 - Display a data dump of DE 
28d2			; | |    4 - Display a data dump of BC 
28d2			; | |    5 - Display a data dump of HL 
28d2			; | |    6 - Display a data dump of DSP 
28d2			; | |    7 - Display a data dump of RSP 
28d2			; | |    8 - Display a data dump of what is at DSP 
28d2			; | |    9 - Display a data dump of what is at RSP 
28d2			; | |    0 - Exit monitor and continue running. This will also enable break points 
28d2			; | |    * - Disable break points 
28d2			; | |    # - Enter traditional monitor mode 
28d2			; | | 
28d2			; | | Monitor Mode 
28d2			; | | ------------ 
28d2			; | | A prompt of '>' will be shown for various commands: 
28d2			; | |    D xxxx - Display a data dump starting from hex address xxxx 
28d2			; | |    C - Continue display a data dump from the last set address 
28d2			; | |    M xxxx - Set start of memory edit at address xx 
28d2			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
28d2			; | |    Q - Return to previous 
28d2					if DEBUG_FORTH_WORDS_KEY 
28d2						DMARK "MON" 
28d2 f5				push af  
28d3 3a e7 28			ld a, (.dmark)  
28d6 32 77 fb			ld (debug_mark),a  
28d9 3a e8 28			ld a, (.dmark+1)  
28dc 32 78 fb			ld (debug_mark+1),a  
28df 3a e9 28			ld a, (.dmark+2)  
28e2 32 79 fb			ld (debug_mark+2),a  
28e5 18 03			jr .pastdmark  
28e7 ..			.dmark: db "MON"  
28ea f1			.pastdmark: pop af  
28eb			endm  
# End of macro DMARK
28eb						CALLMONITOR 
28eb cd 4d 17			call break_point_state  
28ee				endm  
# End of macro CALLMONITOR
28ee					endif 
28ee 3e 00				ld a, 0 
28f0 32 0e ee				ld (os_view_disable), a 
28f3			 
28f3					CALLMONITOR 
28f3 cd 4d 17			call break_point_state  
28f6				endm  
# End of macro CALLMONITOR
28f6			 
28f6			;	call monitor 
28f6			 
28f6					NEXTW 
28f6 c3 46 20			jp macro_next 
28f9				endm 
# End of macro NEXTW
28f9			 
28f9			 
28f9			.MALLOC: 
28f9				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
28f9 56				db WORD_SYS_CORE+66             
28fa 22 29			dw .MALLOC2            
28fc 06				db 5 + 1 
28fd .. 00			db "ALLOT",0              
2903				endm 
# End of macro CWHEAD
2903			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2903					if DEBUG_FORTH_WORDS_KEY 
2903						DMARK "ALL" 
2903 f5				push af  
2904 3a 18 29			ld a, (.dmark)  
2907 32 77 fb			ld (debug_mark),a  
290a 3a 19 29			ld a, (.dmark+1)  
290d 32 78 fb			ld (debug_mark+1),a  
2910 3a 1a 29			ld a, (.dmark+2)  
2913 32 79 fb			ld (debug_mark+2),a  
2916 18 03			jr .pastdmark  
2918 ..			.dmark: db "ALL"  
291b f1			.pastdmark: pop af  
291c			endm  
# End of macro DMARK
291c						CALLMONITOR 
291c cd 4d 17			call break_point_state  
291f				endm  
# End of macro CALLMONITOR
291f					endif 
291f c3 49 29				jp .mallocc 
2922			.MALLOC2: 
2922				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2922 56				db WORD_SYS_CORE+66             
2923 60 29			dw .FREE            
2925 07				db 6 + 1 
2926 .. 00			db "MALLOC",0              
292d				endm 
# End of macro CWHEAD
292d			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
292d					; get byte count 
292d					if DEBUG_FORTH_WORDS_KEY 
292d						DMARK "MAL" 
292d f5				push af  
292e 3a 42 29			ld a, (.dmark)  
2931 32 77 fb			ld (debug_mark),a  
2934 3a 43 29			ld a, (.dmark+1)  
2937 32 78 fb			ld (debug_mark+1),a  
293a 3a 44 29			ld a, (.dmark+2)  
293d 32 79 fb			ld (debug_mark+2),a  
2940 18 03			jr .pastdmark  
2942 ..			.dmark: db "MAL"  
2945 f1			.pastdmark: pop af  
2946			endm  
# End of macro DMARK
2946						CALLMONITOR 
2946 cd 4d 17			call break_point_state  
2949				endm  
# End of macro CALLMONITOR
2949					endif 
2949			.mallocc: 
2949					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2949 cd d4 1e			call macro_dsp_valuehl 
294c				endm 
# End of macro FORTH_DSP_VALUEHL
294c			 
294c			;		push hl 
294c			 
294c					; destroy value TOS 
294c			 
294c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
294c cd 8c 1f			call macro_forth_dsp_pop 
294f				endm 
# End of macro FORTH_DSP_POP
294f			 
294f			;		pop hl 
294f cd d0 11				call malloc 
2952				if DEBUG_FORTH_MALLOC_GUARD 
2952 f5					push af 
2953 cd 32 0d				call ishlzero 
2956			;		ld a, l 
2956			;		add h 
2956			;		cp 0 
2956 f1					pop af 
2957					 
2957 cc 93 51				call z,malloc_error 
295a				endif 
295a			 
295a cd dd 1c				call forth_push_numhl 
295d					NEXTW 
295d c3 46 20			jp macro_next 
2960				endm 
# End of macro NEXTW
2960			 
2960			.FREE: 
2960				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2960 57				db WORD_SYS_CORE+67             
2961 91 29			dw .LIST            
2963 05				db 4 + 1 
2964 .. 00			db "FREE",0              
2969				endm 
# End of macro CWHEAD
2969			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2969					if DEBUG_FORTH_WORDS_KEY 
2969						DMARK "FRE" 
2969 f5				push af  
296a 3a 7e 29			ld a, (.dmark)  
296d 32 77 fb			ld (debug_mark),a  
2970 3a 7f 29			ld a, (.dmark+1)  
2973 32 78 fb			ld (debug_mark+1),a  
2976 3a 80 29			ld a, (.dmark+2)  
2979 32 79 fb			ld (debug_mark+2),a  
297c 18 03			jr .pastdmark  
297e ..			.dmark: db "FRE"  
2981 f1			.pastdmark: pop af  
2982			endm  
# End of macro DMARK
2982						CALLMONITOR 
2982 cd 4d 17			call break_point_state  
2985				endm  
# End of macro CALLMONITOR
2985					endif 
2985					; get address 
2985			 
2985					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2985 cd d4 1e			call macro_dsp_valuehl 
2988				endm 
# End of macro FORTH_DSP_VALUEHL
2988			 
2988			;		push hl 
2988			 
2988					; destroy value TOS 
2988			 
2988					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2988 cd 8c 1f			call macro_forth_dsp_pop 
298b				endm 
# End of macro FORTH_DSP_POP
298b			 
298b			;		pop hl 
298b			if FORTH_ENABLE_MALLOCFREE 
298b cd 9a 12				call free 
298e			endif 
298e					NEXTW 
298e c3 46 20			jp macro_next 
2991				endm 
# End of macro NEXTW
2991			.LIST: 
2991				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2991 5c				db WORD_SYS_CORE+72             
2992 54 2b			dw .FORGET            
2994 05				db 4 + 1 
2995 .. 00			db "LIST",0              
299a				endm 
# End of macro CWHEAD
299a			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
299a			; | | The quoted word must be in upper case. 
299a				if DEBUG_FORTH_WORDS_KEY 
299a					DMARK "LST" 
299a f5				push af  
299b 3a af 29			ld a, (.dmark)  
299e 32 77 fb			ld (debug_mark),a  
29a1 3a b0 29			ld a, (.dmark+1)  
29a4 32 78 fb			ld (debug_mark+1),a  
29a7 3a b1 29			ld a, (.dmark+2)  
29aa 32 79 fb			ld (debug_mark+2),a  
29ad 18 03			jr .pastdmark  
29af ..			.dmark: db "LST"  
29b2 f1			.pastdmark: pop af  
29b3			endm  
# End of macro DMARK
29b3					CALLMONITOR 
29b3 cd 4d 17			call break_point_state  
29b6				endm  
# End of macro CALLMONITOR
29b6				endif 
29b6			 
29b6					FORTH_DSP_VALUEHL 
29b6 cd d4 1e			call macro_dsp_valuehl 
29b9				endm 
# End of macro FORTH_DSP_VALUEHL
29b9			 
29b9 e5					push hl 
29ba c1					pop bc 
29bb			 
29bb			; Start format of scratch string 
29bb			 
29bb 21 1d ee				ld hl, scratch 
29be			 
29be 3e 3a				ld a, ':' 
29c0 77					ld (hl),a 
29c1 23					inc hl 
29c2 3e 20				ld a, ' ' 
29c4 77					ld (hl), a 
29c5			 
29c5					; Get ptr to the word we need to look up 
29c5			 
29c5			;		FORTH_DSP_VALUEHL 
29c5					;v5 FORTH_DSP_VALUE 
29c5				; TODO type check 
29c5			;		inc hl    ; Skip type check  
29c5			;		push hl 
29c5			;		ex de, hl    ; put into DE 
29c5			 
29c5			 
29c5 21 00 80				ld hl, baseram 
29c8					;ld hl, baseusermem 
29c8			 
29c8 e5			push hl   ; sacreifical push 
29c9			 
29c9			.ldouscanm: 
29c9 e1				pop hl 
29ca			.ldouscan: 
29ca				if DEBUG_FORTH_WORDS 
29ca					DMARK "LSs" 
29ca f5				push af  
29cb 3a df 29			ld a, (.dmark)  
29ce 32 77 fb			ld (debug_mark),a  
29d1 3a e0 29			ld a, (.dmark+1)  
29d4 32 78 fb			ld (debug_mark+1),a  
29d7 3a e1 29			ld a, (.dmark+2)  
29da 32 79 fb			ld (debug_mark+2),a  
29dd 18 03			jr .pastdmark  
29df ..			.dmark: db "LSs"  
29e2 f1			.pastdmark: pop af  
29e3			endm  
# End of macro DMARK
29e3					CALLMONITOR 
29e3 cd 4d 17			call break_point_state  
29e6				endm  
# End of macro CALLMONITOR
29e6				endif 
29e6				; skip dict stub 
29e6 cd 97 21				call forth_tok_next 
29e9			 
29e9			 
29e9			; while we have words to look for 
29e9			 
29e9 7e				ld a, (hl)      
29ea				if DEBUG_FORTH_WORDS 
29ea					DMARK "LSk" 
29ea f5				push af  
29eb 3a ff 29			ld a, (.dmark)  
29ee 32 77 fb			ld (debug_mark),a  
29f1 3a 00 2a			ld a, (.dmark+1)  
29f4 32 78 fb			ld (debug_mark+1),a  
29f7 3a 01 2a			ld a, (.dmark+2)  
29fa 32 79 fb			ld (debug_mark+2),a  
29fd 18 03			jr .pastdmark  
29ff ..			.dmark: db "LSk"  
2a02 f1			.pastdmark: pop af  
2a03			endm  
# End of macro DMARK
2a03					CALLMONITOR 
2a03 cd 4d 17			call break_point_state  
2a06				endm  
# End of macro CALLMONITOR
2a06				endif 
2a06 fe 00				cp WORD_SYS_END 
2a08 ca 3b 2b				jp z, .lunotfound 
2a0b fe 01				cp WORD_SYS_UWORD 
2a0d c2 ca 29				jp nz, .ldouscan 
2a10			 
2a10				if DEBUG_FORTH_WORDS 
2a10					DMARK "LSu" 
2a10 f5				push af  
2a11 3a 25 2a			ld a, (.dmark)  
2a14 32 77 fb			ld (debug_mark),a  
2a17 3a 26 2a			ld a, (.dmark+1)  
2a1a 32 78 fb			ld (debug_mark+1),a  
2a1d 3a 27 2a			ld a, (.dmark+2)  
2a20 32 79 fb			ld (debug_mark+2),a  
2a23 18 03			jr .pastdmark  
2a25 ..			.dmark: db "LSu"  
2a28 f1			.pastdmark: pop af  
2a29			endm  
# End of macro DMARK
2a29					CALLMONITOR 
2a29 cd 4d 17			call break_point_state  
2a2c				endm  
# End of macro CALLMONITOR
2a2c				endif 
2a2c			 
2a2c					; found a uword but is it the one we want... 
2a2c			 
2a2c c5					push bc     ; uword to find is on bc 
2a2d d1					pop de 
2a2e			 
2a2e e5					push hl  ; to save the ptr 
2a2f			 
2a2f					; skip opcode 
2a2f 23					inc hl  
2a30					; skip next ptr 
2a30 23					inc hl  
2a31 23					inc hl 
2a32					; skip len 
2a32 23					inc hl 
2a33			 
2a33				if DEBUG_FORTH_WORDS 
2a33					DMARK "LSc" 
2a33 f5				push af  
2a34 3a 48 2a			ld a, (.dmark)  
2a37 32 77 fb			ld (debug_mark),a  
2a3a 3a 49 2a			ld a, (.dmark+1)  
2a3d 32 78 fb			ld (debug_mark+1),a  
2a40 3a 4a 2a			ld a, (.dmark+2)  
2a43 32 79 fb			ld (debug_mark+2),a  
2a46 18 03			jr .pastdmark  
2a48 ..			.dmark: db "LSc"  
2a4b f1			.pastdmark: pop af  
2a4c			endm  
# End of macro DMARK
2a4c					CALLMONITOR 
2a4c cd 4d 17			call break_point_state  
2a4f				endm  
# End of macro CALLMONITOR
2a4f				endif 
2a4f cd 9f 11				call strcmp 
2a52 c2 c9 29				jp nz, .ldouscanm 
2a55				 
2a55			 
2a55			 
2a55					; we have a uword so push its name to the stack 
2a55			 
2a55			;	   	push hl  ; save so we can move to next dict block 
2a55 e1			pop hl 
2a56			 
2a56				if DEBUG_FORTH_WORDS 
2a56					DMARK "LSm" 
2a56 f5				push af  
2a57 3a 6b 2a			ld a, (.dmark)  
2a5a 32 77 fb			ld (debug_mark),a  
2a5d 3a 6c 2a			ld a, (.dmark+1)  
2a60 32 78 fb			ld (debug_mark+1),a  
2a63 3a 6d 2a			ld a, (.dmark+2)  
2a66 32 79 fb			ld (debug_mark+2),a  
2a69 18 03			jr .pastdmark  
2a6b ..			.dmark: db "LSm"  
2a6e f1			.pastdmark: pop af  
2a6f			endm  
# End of macro DMARK
2a6f					CALLMONITOR 
2a6f cd 4d 17			call break_point_state  
2a72				endm  
# End of macro CALLMONITOR
2a72				endif 
2a72			 
2a72					; skip opcode 
2a72 23					inc hl  
2a73					; skip next ptr 
2a73 23					inc hl  
2a74 23					inc hl 
2a75					; skip len 
2a75 7e					ld a, (hl)   ; save length to add 
2a76				if DEBUG_FORTH_WORDS 
2a76					DMARK "LS2" 
2a76 f5				push af  
2a77 3a 8b 2a			ld a, (.dmark)  
2a7a 32 77 fb			ld (debug_mark),a  
2a7d 3a 8c 2a			ld a, (.dmark+1)  
2a80 32 78 fb			ld (debug_mark+1),a  
2a83 3a 8d 2a			ld a, (.dmark+2)  
2a86 32 79 fb			ld (debug_mark+2),a  
2a89 18 03			jr .pastdmark  
2a8b ..			.dmark: db "LS2"  
2a8e f1			.pastdmark: pop af  
2a8f			endm  
# End of macro DMARK
2a8f					CALLMONITOR 
2a8f cd 4d 17			call break_point_state  
2a92				endm  
# End of macro CALLMONITOR
2a92				endif 
2a92			 
2a92					; save this location 
2a92				 
2a92 e5					push hl 
2a93			 
2a93 23					inc hl 
2a94 11 1f ee				ld de, scratch+2 
2a97 4f					ld c, a 
2a98 06 00				ld b, 0 
2a9a			 
2a9a				if DEBUG_FORTH_WORDS 
2a9a					DMARK "LSn" 
2a9a f5				push af  
2a9b 3a af 2a			ld a, (.dmark)  
2a9e 32 77 fb			ld (debug_mark),a  
2aa1 3a b0 2a			ld a, (.dmark+1)  
2aa4 32 78 fb			ld (debug_mark+1),a  
2aa7 3a b1 2a			ld a, (.dmark+2)  
2aaa 32 79 fb			ld (debug_mark+2),a  
2aad 18 03			jr .pastdmark  
2aaf ..			.dmark: db "LSn"  
2ab2 f1			.pastdmark: pop af  
2ab3			endm  
# End of macro DMARK
2ab3					CALLMONITOR 
2ab3 cd 4d 17			call break_point_state  
2ab6				endm  
# End of macro CALLMONITOR
2ab6				endif 
2ab6			 
2ab6					; copy uword name to scratch 
2ab6			 
2ab6 ed b0				ldir 
2ab8			 
2ab8 1b					dec de 
2ab9 3e 20				ld a, ' '    ; change null to space 
2abb 12					ld (de), a 
2abc			 
2abc 13					inc de 
2abd			 
2abd d5					push de 
2abe c1					pop bc     ; move scratch pointer to end of word name and save it 
2abf			 
2abf e1					pop hl 
2ac0 7e					ld a, (hl) 
2ac1					;inc hl 
2ac1					; skip word string 
2ac1 cd 09 0d				call addatohl 
2ac4			 
2ac4 23					inc hl 
2ac5			 
2ac5				if DEBUG_FORTH_WORDS 
2ac5					DMARK "LS3" 
2ac5 f5				push af  
2ac6 3a da 2a			ld a, (.dmark)  
2ac9 32 77 fb			ld (debug_mark),a  
2acc 3a db 2a			ld a, (.dmark+1)  
2acf 32 78 fb			ld (debug_mark+1),a  
2ad2 3a dc 2a			ld a, (.dmark+2)  
2ad5 32 79 fb			ld (debug_mark+2),a  
2ad8 18 03			jr .pastdmark  
2ada ..			.dmark: db "LS3"  
2add f1			.pastdmark: pop af  
2ade			endm  
# End of macro DMARK
2ade					CALLMONITOR 
2ade cd 4d 17			call break_point_state  
2ae1				endm  
# End of macro CALLMONITOR
2ae1				endif 
2ae1					; should now be at the start of the machine code to setup the eval of the uword 
2ae1					; now locate the ptr to the string defintion 
2ae1			 
2ae1					; skip ld hl, 
2ae1					; then load the ptr 
2ae1			 
2ae1 23					inc hl 
2ae2 5e					ld e, (hl) 
2ae3 23					inc hl 
2ae4 56					ld d, (hl) 
2ae5 eb					ex de, hl 
2ae6			 
2ae6			 
2ae6				if DEBUG_FORTH_WORDS 
2ae6					DMARK "LSt" 
2ae6 f5				push af  
2ae7 3a fb 2a			ld a, (.dmark)  
2aea 32 77 fb			ld (debug_mark),a  
2aed 3a fc 2a			ld a, (.dmark+1)  
2af0 32 78 fb			ld (debug_mark+1),a  
2af3 3a fd 2a			ld a, (.dmark+2)  
2af6 32 79 fb			ld (debug_mark+2),a  
2af9 18 03			jr .pastdmark  
2afb ..			.dmark: db "LSt"  
2afe f1			.pastdmark: pop af  
2aff			endm  
# End of macro DMARK
2aff					CALLMONITOR 
2aff cd 4d 17			call break_point_state  
2b02				endm  
# End of macro CALLMONITOR
2b02				endif 
2b02			 
2b02			; cant push right now due to tokenised strings  
2b02			 
2b02			; get the destination of where to copy this definition to. 
2b02			 
2b02 c5					push bc 
2b03 d1					pop de 
2b04			 
2b04 7e			.listl:         ld a,(hl) 
2b05 fe 00				cp 0 
2b07 28 09				jr z, .lreplsp     ; replace zero with space 
2b09 fe 7f				cp FORTH_END_BUFFER 
2b0b 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2b0d				 
2b0d					; just copy this char as is then 
2b0d			 
2b0d 12					ld (de), a 
2b0e			 
2b0e 23			.listnxt:	inc hl 
2b0f 13					inc de 
2b10 18 f2				jr .listl 
2b12			 
2b12 3e 20		.lreplsp:	ld a,' ' 
2b14 12					ld (de), a 
2b15 18 f7				jr .listnxt 
2b17			 
2b17			; close up uword def 
2b17			 
2b17			.listdone: 
2b17 3e 00				ld a, 0 
2b19 12					ld (de), a 
2b1a			 
2b1a			; now have def so clean up and push to stack 
2b1a			 
2b1a 21 1d ee				ld hl, scratch 
2b1d				if DEBUG_FORTH_WORDS 
2b1d					DMARK "Ltp" 
2b1d f5				push af  
2b1e 3a 32 2b			ld a, (.dmark)  
2b21 32 77 fb			ld (debug_mark),a  
2b24 3a 33 2b			ld a, (.dmark+1)  
2b27 32 78 fb			ld (debug_mark+1),a  
2b2a 3a 34 2b			ld a, (.dmark+2)  
2b2d 32 79 fb			ld (debug_mark+2),a  
2b30 18 03			jr .pastdmark  
2b32 ..			.dmark: db "Ltp"  
2b35 f1			.pastdmark: pop af  
2b36			endm  
# End of macro DMARK
2b36					CALLMONITOR 
2b36 cd 4d 17			call break_point_state  
2b39				endm  
# End of macro CALLMONITOR
2b39				endif 
2b39			 
2b39 18 06			jr .listpush 
2b3b			 
2b3b			;.lnuword:	pop hl 
2b3b			;		call forth_tok_next 
2b3b			;		jp .ldouscan  
2b3b			 
2b3b			.lunotfound:		  
2b3b			 
2b3b			 
2b3b					 
2b3b					FORTH_DSP_POP 
2b3b cd 8c 1f			call macro_forth_dsp_pop 
2b3e				endm 
# End of macro FORTH_DSP_POP
2b3e 21 47 2b				ld hl, .luno 
2b41						 
2b41			 
2b41			.listpush: 
2b41 cd 4b 1d				call forth_push_str 
2b44			 
2b44			 
2b44			 
2b44					NEXTW 
2b44 c3 46 20			jp macro_next 
2b47				endm 
# End of macro NEXTW
2b47			 
2b47 .. 00		.luno:    db "Not found",0 
2b51			 
2b51			 
2b51			 
2b51			 
2b51			 
2b51			;		push hl   ; save pointer to start of uword def string 
2b51			; 
2b51			;; look for FORTH_EOL_LINE 
2b51			;		ld a, FORTH_END_BUFFER 
2b51			;		call strlent 
2b51			; 
2b51			;		inc hl		 ; space for coln def 
2b51			;		inc hl 
2b51			;		inc hl          ; space for terms 
2b51			;		inc hl 
2b51			; 
2b51			;		ld a, 20   ; TODO get actual length 
2b51			;		call addatohl    ; include a random amount of room for the uword name 
2b51			; 
2b51			;		 
2b51			;	if DEBUG_FORTH_WORDS 
2b51			;		DMARK "Lt1" 
2b51			;		CALLMONITOR 
2b51			;	endif 
2b51			;		 
2b51			; 
2b51			;; malloc space for the string because we cant change it 
2b51			; 
2b51			;		call malloc 
2b51			;	if DEBUG_FORTH_MALLOC_GUARD 
2b51			;		push af 
2b51			;		call ishlzero 
2b51			;		pop af 
2b51			;		 
2b51			;		call z,malloc_error 
2b51			;	endif 
2b51			; 
2b51			;	if DEBUG_FORTH_WORDS 
2b51			;		DMARK "Lt2" 
2b51			;		CALLMONITOR 
2b51			;	endif 
2b51			;		pop de 
2b51			;		push hl    ; push the malloc to release later 
2b51			;		push hl   ;  push back a copy for the later stack push 
2b51			;		 
2b51			;; copy the string swapping out the zero terms for spaces 
2b51			; 
2b51			;		; de has our source 
2b51			;		; hl has our dest 
2b51			; 
2b51			;; add the coln def 
2b51			; 
2b51			;		ld a, ':' 
2b51			;		ld (hl), a 
2b51			;		inc hl 
2b51			;		ld a, ' ' 
2b51			;		ld (hl), a 
2b51			;		inc hl 
2b51			; 
2b51			;; add the uname word 
2b51			;		push de   ; save our string for now 
2b51			;		ex de, hl 
2b51			; 
2b51			;		FORTH_DSP_VALUE 
2b51			;		;v5 FORTH_DSP_VALUE 
2b51			; 
2b51			;		inc hl   ; skip type but we know by now this is OK 
2b51			; 
2b51			;.luword:	ld a,(hl) 
2b51			;		cp 0 
2b51			;		jr z, .luword2 
2b51			;		ld (de), a 
2b51			;		inc de 
2b51			;		inc hl 
2b51			;		jr .luword 
2b51			; 
2b51			;.luword2:	ld a, ' ' 
2b51			;		ld (de), a 
2b51			;;		inc hl 
2b51			;;		inc de 
2b51			;;		ld (de), a 
2b51			;;		inc hl 
2b51			;		inc de 
2b51			; 
2b51			;		ex de, hl 
2b51			;		pop de 
2b51			;		 
2b51			;		 
2b51			; 
2b51			;; detoken that string and copy it 
2b51			; 
2b51			;	if DEBUG_FORTH_WORDS 
2b51			;		DMARK "Lt2" 
2b51			;		CALLMONITOR 
2b51			;	endif 
2b51			;.ldetok:	ld a, (de) 
2b51			;		cp FORTH_END_BUFFER 
2b51			;		jr z, .ldetokend 
2b51			;		; swap out any zero term for space 
2b51			;		cp 0 
2b51			;		jr nz, .ldetoknext 
2b51			;		ld a, ' ' 
2b51			; 
2b51			;	if DEBUG_FORTH_WORDS 
2b51			;		DMARK "LtS" 
2b51			;		CALLMONITOR 
2b51			;	endif 
2b51			;.ldetoknext:	ld (hl), a 
2b51			;		inc de 
2b51			;		inc hl 
2b51			;		jr .ldetok 
2b51			; 
2b51			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2b51			;		ld (hl), a  
2b51			; 
2b51			;; free that temp malloc 
2b51			; 
2b51			;		pop hl    
2b51			; 
2b51			;	if DEBUG_FORTH_WORDS 
2b51			;		DMARK "Lt4" 
2b51			;		CALLMONITOR 
2b51			;	endif 
2b51			;		call forth_apushstrhl 
2b51			; 
2b51			;		; get rid of temp malloc area 
2b51			; 
2b51			;		pop hl 
2b51			;		call free 
2b51			; 
2b51			;		jr .ludone 
2b51			; 
2b51			;.lnuword:	pop hl 
2b51			;		call forth_tok_next 
2b51			;		jp .ldouscan  
2b51			; 
2b51			;.ludone:		 pop hl 
2b51			; 
2b51					NEXTW 
2b51 c3 46 20			jp macro_next 
2b54				endm 
# End of macro NEXTW
2b54			 
2b54			.FORGET: 
2b54				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2b54 5d				db WORD_SYS_CORE+73             
2b55 cd 2b			dw .NOP            
2b57 07				db 6 + 1 
2b58 .. 00			db "FORGET",0              
2b5f				endm 
# End of macro CWHEAD
2b5f			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2b5f			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2b5f			; | |  
2b5f			; | | e.g. "MORE" forget 
2b5f					if DEBUG_FORTH_WORDS_KEY 
2b5f						DMARK "FRG" 
2b5f f5				push af  
2b60 3a 74 2b			ld a, (.dmark)  
2b63 32 77 fb			ld (debug_mark),a  
2b66 3a 75 2b			ld a, (.dmark+1)  
2b69 32 78 fb			ld (debug_mark+1),a  
2b6c 3a 76 2b			ld a, (.dmark+2)  
2b6f 32 79 fb			ld (debug_mark+2),a  
2b72 18 03			jr .pastdmark  
2b74 ..			.dmark: db "FRG"  
2b77 f1			.pastdmark: pop af  
2b78			endm  
# End of macro DMARK
2b78						CALLMONITOR 
2b78 cd 4d 17			call break_point_state  
2b7b				endm  
# End of macro CALLMONITOR
2b7b					endif 
2b7b			 
2b7b				; find uword 
2b7b			        ; update start of word with "_" 
2b7b				; replace uword with deleted flag 
2b7b			 
2b7b			 
2b7b			;	if DEBUG_FORTH_WORDS 
2b7b			;		DMARK "FOG" 
2b7b			;		CALLMONITOR 
2b7b			;	endif 
2b7b			 
2b7b			 
2b7b					; Get ptr to the word we need to look up 
2b7b			 
2b7b					FORTH_DSP_VALUEHL 
2b7b cd d4 1e			call macro_dsp_valuehl 
2b7e				endm 
# End of macro FORTH_DSP_VALUEHL
2b7e					;v5 FORTH_DSP_VALUE 
2b7e				; TODO type check 
2b7e			;		inc hl    ; Skip type check  
2b7e e5					push hl 
2b7f c1					pop bc 
2b80			;		ex de, hl    ; put into DE 
2b80			 
2b80			 
2b80 21 00 80				ld hl, baseram 
2b83					;ld hl, baseusermem 
2b83			 
2b83				; skip dict stub 
2b83			;	call forth_tok_next 
2b83 e5			push hl   ; sacreifical push 
2b84			 
2b84			.fldouscanm: 
2b84 e1				pop hl 
2b85			.fldouscan: 
2b85			;	if DEBUG_FORTH_WORDS 
2b85			;		DMARK "LSs" 
2b85			;		CALLMONITOR 
2b85			;	endif 
2b85				; skip dict stub 
2b85 cd 97 21				call forth_tok_next 
2b88			 
2b88			 
2b88			; while we have words to look for 
2b88			 
2b88 7e				ld a, (hl)      
2b89			;	if DEBUG_FORTH_WORDS 
2b89			;		DMARK "LSk" 
2b89			;		CALLMONITOR 
2b89			;	endif 
2b89 fe 00				cp WORD_SYS_END 
2b8b ca c7 2b				jp z, .flunotfound 
2b8e fe 01				cp WORD_SYS_UWORD 
2b90 c2 85 2b				jp nz, .fldouscan 
2b93			 
2b93			;	if DEBUG_FORTH_WORDS 
2b93			;		DMARK "LSu" 
2b93			;		CALLMONITOR 
2b93			;	endif 
2b93			 
2b93					; found a uword but is it the one we want... 
2b93			 
2b93 c5					push bc     ; uword to find is on bc 
2b94 d1					pop de 
2b95			 
2b95 e5					push hl  ; to save the ptr 
2b96			 
2b96					; skip opcode 
2b96 23					inc hl  
2b97					; skip next ptr 
2b97 23					inc hl  
2b98 23					inc hl 
2b99					; skip len 
2b99 23					inc hl 
2b9a			 
2b9a			;	if DEBUG_FORTH_WORDS 
2b9a			;		DMARK "LSc" 
2b9a			;		CALLMONITOR 
2b9a			;	endif 
2b9a cd 9f 11				call strcmp 
2b9d c2 84 2b				jp nz, .fldouscanm 
2ba0			; 
2ba0			; 
2ba0			;; while we have words to look for 
2ba0			; 
2ba0			;.fdouscan:	ld a, (hl)      
2ba0			;	if DEBUG_FORTH_WORDS 
2ba0			;		DMARK "LSs" 
2ba0			;		CALLMONITOR 
2ba0			;	endif 
2ba0			;		cp WORD_SYS_END 
2ba0			;		jp z, .fudone 
2ba0			;		cp WORD_SYS_UWORD 
2ba0			;		jp nz, .fnuword 
2ba0			; 
2ba0			;	if DEBUG_FORTH_WORDS 
2ba0			;		DMARK "FGu" 
2ba0			;		CALLMONITOR 
2ba0			;	endif 
2ba0			; 
2ba0			;		; found a uword but is it the one we want... 
2ba0			; 
2ba0			; 
2ba0			;	        pop de   ; get back the dsp name 
2ba0			;		push de 
2ba0			; 
2ba0			;		push hl  ; to save the ptr 
2ba0			; 
2ba0			;		; skip opcode 
2ba0			;		inc hl  
2ba0			;		; skip next ptr 
2ba0			;		inc hl  
2ba0			;		inc hl 
2ba0			;		; skip len 
2ba0			;		inc hl 
2ba0			; 
2ba0			;	if DEBUG_FORTH_WORDS 
2ba0			;		DMARK "FGc" 
2ba0			;		CALLMONITOR 
2ba0			;	endif 
2ba0			;		call strcmp 
2ba0			;		jp nz, .fnuword 
2ba0			 
2ba0			 
2ba0 e1			pop hl 
2ba1			 
2ba1				 
2ba1				if DEBUG_FORTH_WORDS 
2ba1					DMARK "FGm" 
2ba1 f5				push af  
2ba2 3a b6 2b			ld a, (.dmark)  
2ba5 32 77 fb			ld (debug_mark),a  
2ba8 3a b7 2b			ld a, (.dmark+1)  
2bab 32 78 fb			ld (debug_mark+1),a  
2bae 3a b8 2b			ld a, (.dmark+2)  
2bb1 32 79 fb			ld (debug_mark+2),a  
2bb4 18 03			jr .pastdmark  
2bb6 ..			.dmark: db "FGm"  
2bb9 f1			.pastdmark: pop af  
2bba			endm  
# End of macro DMARK
2bba					CALLMONITOR 
2bba cd 4d 17			call break_point_state  
2bbd				endm  
# End of macro CALLMONITOR
2bbd				endif 
2bbd			 
2bbd			 
2bbd			 
2bbd					; we have a uword so push its name to the stack 
2bbd			 
2bbd			;	   	push hl  ; save so we can move to next dict block 
2bbd			;pop hl 
2bbd			 
2bbd					; update opcode to deleted 
2bbd 3e 03				ld a, WORD_SYS_DELETED 
2bbf 77					ld (hl), a 
2bc0			 
2bc0 23					inc hl  
2bc1					; skip next ptr 
2bc1 23					inc hl  
2bc2 23					inc hl 
2bc3					; skip len 
2bc3 23					inc hl 
2bc4			 
2bc4					; TODO change parser to skip deleted words but for now mark it out 
2bc4 3e 5f				ld a, "_" 
2bc6 77					ld  (hl),a 
2bc7			 
2bc7			;		jr .fudone 
2bc7			; 
2bc7			;.fnuword:	pop hl 
2bc7			;		call forth_tok_next 
2bc7			;		jp .fdouscan  
2bc7			 
2bc7			.flunotfound:		  
2bc7			 
2bc7			 
2bc7					 
2bc7					FORTH_DSP_POP 
2bc7 cd 8c 1f			call macro_forth_dsp_pop 
2bca				endm 
# End of macro FORTH_DSP_POP
2bca			;		ld hl, .luno 
2bca			;.fudone:		 pop hl 
2bca					NEXTW 
2bca c3 46 20			jp macro_next 
2bcd				endm 
# End of macro NEXTW
2bcd			.NOP: 
2bcd				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2bcd 61				db WORD_SYS_CORE+77             
2bce f4 2b			dw .COMO            
2bd0 04				db 3 + 1 
2bd1 .. 00			db "NOP",0              
2bd5				endm 
# End of macro CWHEAD
2bd5			; | NOP (  --  ) Do nothing | DONE 
2bd5					if DEBUG_FORTH_WORDS_KEY 
2bd5						DMARK "NOP" 
2bd5 f5				push af  
2bd6 3a ea 2b			ld a, (.dmark)  
2bd9 32 77 fb			ld (debug_mark),a  
2bdc 3a eb 2b			ld a, (.dmark+1)  
2bdf 32 78 fb			ld (debug_mark+1),a  
2be2 3a ec 2b			ld a, (.dmark+2)  
2be5 32 79 fb			ld (debug_mark+2),a  
2be8 18 03			jr .pastdmark  
2bea ..			.dmark: db "NOP"  
2bed f1			.pastdmark: pop af  
2bee			endm  
# End of macro DMARK
2bee						CALLMONITOR 
2bee cd 4d 17			call break_point_state  
2bf1				endm  
# End of macro CALLMONITOR
2bf1					endif 
2bf1				       NEXTW 
2bf1 c3 46 20			jp macro_next 
2bf4				endm 
# End of macro NEXTW
2bf4			.COMO: 
2bf4				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2bf4 6e				db WORD_SYS_CORE+90             
2bf5 46 2c			dw .COMC            
2bf7 02				db 1 + 1 
2bf8 .. 00			db "(",0              
2bfa				endm 
# End of macro CWHEAD
2bfa			; | ( ( -- )  Start of comment | DONE 
2bfa			 
2bfa			 
2bfa 2a 1e f1				ld hl, ( os_tok_ptr) 
2bfd 11 41 2c			ld de, .closepar 
2c00					 
2c00					if DEBUG_FORTH_WORDS 
2c00						DMARK ").." 
2c00 f5				push af  
2c01 3a 15 2c			ld a, (.dmark)  
2c04 32 77 fb			ld (debug_mark),a  
2c07 3a 16 2c			ld a, (.dmark+1)  
2c0a 32 78 fb			ld (debug_mark+1),a  
2c0d 3a 17 2c			ld a, (.dmark+2)  
2c10 32 79 fb			ld (debug_mark+2),a  
2c13 18 03			jr .pastdmark  
2c15 ..			.dmark: db ").."  
2c18 f1			.pastdmark: pop af  
2c19			endm  
# End of macro DMARK
2c19						CALLMONITOR 
2c19 cd 4d 17			call break_point_state  
2c1c				endm  
# End of macro CALLMONITOR
2c1c					endif 
2c1c cd 61 21			call findnexttok  
2c1f			 
2c1f					if DEBUG_FORTH_WORDS 
2c1f						DMARK "IF5" 
2c1f f5				push af  
2c20 3a 34 2c			ld a, (.dmark)  
2c23 32 77 fb			ld (debug_mark),a  
2c26 3a 35 2c			ld a, (.dmark+1)  
2c29 32 78 fb			ld (debug_mark+1),a  
2c2c 3a 36 2c			ld a, (.dmark+2)  
2c2f 32 79 fb			ld (debug_mark+2),a  
2c32 18 03			jr .pastdmark  
2c34 ..			.dmark: db "IF5"  
2c37 f1			.pastdmark: pop af  
2c38			endm  
# End of macro DMARK
2c38						CALLMONITOR 
2c38 cd 4d 17			call break_point_state  
2c3b				endm  
# End of macro CALLMONITOR
2c3b					endif 
2c3b				; replace below with ) exec using tok_ptr 
2c3b 22 1e f1			ld (os_tok_ptr), hl 
2c3e c3 d7 20			jp exec1 
2c41			 
2c41 .. 00			.closepar:   db ")",0 
2c43			 
2c43				       NEXTW 
2c43 c3 46 20			jp macro_next 
2c46				endm 
# End of macro NEXTW
2c46			.COMC: 
2c46				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2c46 6f				db WORD_SYS_CORE+91             
2c47 4f 2c			dw .SCRATCH            
2c49 02				db 1 + 1 
2c4a .. 00			db ")",0              
2c4c				endm 
# End of macro CWHEAD
2c4c			; | ) ( -- )  End of comment |  DONE  
2c4c				       NEXTW 
2c4c c3 46 20			jp macro_next 
2c4f				endm 
# End of macro NEXTW
2c4f			 
2c4f			.SCRATCH: 
2c4f				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2c4f 6f				db WORD_SYS_CORE+91             
2c50 8a 2c			dw .INC            
2c52 08				db 7 + 1 
2c53 .. 00			db "SCRATCH",0              
2c5b				endm 
# End of macro CWHEAD
2c5b			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2c5b			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2c5b			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2c5b			; | |  
2c5b			; | | e.g.    : score $00 scratch ; 
2c5b			; | |  
2c5b			; | | $00 score ! 
2c5b			; | | $01 score +! 
2c5b			; | |  
2c5b			; | | e.g.   : varword $0a scratch ;  
2c5b			; | | 
2c5b			; | | $8000 varword ! 
2c5b					if DEBUG_FORTH_WORDS_KEY 
2c5b						DMARK "SCR" 
2c5b f5				push af  
2c5c 3a 70 2c			ld a, (.dmark)  
2c5f 32 77 fb			ld (debug_mark),a  
2c62 3a 71 2c			ld a, (.dmark+1)  
2c65 32 78 fb			ld (debug_mark+1),a  
2c68 3a 72 2c			ld a, (.dmark+2)  
2c6b 32 79 fb			ld (debug_mark+2),a  
2c6e 18 03			jr .pastdmark  
2c70 ..			.dmark: db "SCR"  
2c73 f1			.pastdmark: pop af  
2c74			endm  
# End of macro DMARK
2c74						CALLMONITOR 
2c74 cd 4d 17			call break_point_state  
2c77				endm  
# End of macro CALLMONITOR
2c77					endif 
2c77			 
2c77					FORTH_DSP_VALUEHL 
2c77 cd d4 1e			call macro_dsp_valuehl 
2c7a				endm 
# End of macro FORTH_DSP_VALUEHL
2c7a				 
2c7a					FORTH_DSP_POP 
2c7a cd 8c 1f			call macro_forth_dsp_pop 
2c7d				endm 
# End of macro FORTH_DSP_POP
2c7d			 
2c7d 7d					ld a, l 
2c7e 21 42 f3				ld hl, os_var_array 
2c81 cd 09 0d				call addatohl 
2c84			 
2c84 cd dd 1c				call forth_push_numhl 
2c87			 
2c87				       NEXTW 
2c87 c3 46 20			jp macro_next 
2c8a				endm 
# End of macro NEXTW
2c8a			 
2c8a			.INC: 
2c8a				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2c8a 6f				db WORD_SYS_CORE+91             
2c8b de 2c			dw .DEC            
2c8d 03				db 2 + 1 
2c8e .. 00			db "+!",0              
2c91				endm 
# End of macro CWHEAD
2c91			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2c91					if DEBUG_FORTH_WORDS_KEY 
2c91						DMARK "+s_" 
2c91 f5				push af  
2c92 3a a6 2c			ld a, (.dmark)  
2c95 32 77 fb			ld (debug_mark),a  
2c98 3a a7 2c			ld a, (.dmark+1)  
2c9b 32 78 fb			ld (debug_mark+1),a  
2c9e 3a a8 2c			ld a, (.dmark+2)  
2ca1 32 79 fb			ld (debug_mark+2),a  
2ca4 18 03			jr .pastdmark  
2ca6 ..			.dmark: db "+s_"  
2ca9 f1			.pastdmark: pop af  
2caa			endm  
# End of macro DMARK
2caa						CALLMONITOR 
2caa cd 4d 17			call break_point_state  
2cad				endm  
# End of macro CALLMONITOR
2cad					endif 
2cad			 
2cad					FORTH_DSP_VALUEHL 
2cad cd d4 1e			call macro_dsp_valuehl 
2cb0				endm 
# End of macro FORTH_DSP_VALUEHL
2cb0			 
2cb0 e5					push hl   ; save address 
2cb1			 
2cb1					FORTH_DSP_POP 
2cb1 cd 8c 1f			call macro_forth_dsp_pop 
2cb4				endm 
# End of macro FORTH_DSP_POP
2cb4			 
2cb4					FORTH_DSP_VALUEHL 
2cb4 cd d4 1e			call macro_dsp_valuehl 
2cb7				endm 
# End of macro FORTH_DSP_VALUEHL
2cb7			 
2cb7					FORTH_DSP_POP 
2cb7 cd 8c 1f			call macro_forth_dsp_pop 
2cba				endm 
# End of macro FORTH_DSP_POP
2cba			 
2cba					; hl contains value to add to byte at a 
2cba				 
2cba eb					ex de, hl 
2cbb			 
2cbb e1					pop hl 
2cbc			 
2cbc					if DEBUG_FORTH_WORDS 
2cbc						DMARK "INC" 
2cbc f5				push af  
2cbd 3a d1 2c			ld a, (.dmark)  
2cc0 32 77 fb			ld (debug_mark),a  
2cc3 3a d2 2c			ld a, (.dmark+1)  
2cc6 32 78 fb			ld (debug_mark+1),a  
2cc9 3a d3 2c			ld a, (.dmark+2)  
2ccc 32 79 fb			ld (debug_mark+2),a  
2ccf 18 03			jr .pastdmark  
2cd1 ..			.dmark: db "INC"  
2cd4 f1			.pastdmark: pop af  
2cd5			endm  
# End of macro DMARK
2cd5						CALLMONITOR 
2cd5 cd 4d 17			call break_point_state  
2cd8				endm  
# End of macro CALLMONITOR
2cd8					endif 
2cd8			 
2cd8 7e					ld a,(hl) 
2cd9 83					add e 
2cda 77					ld (hl),a 
2cdb			 
2cdb			 
2cdb			 
2cdb				       NEXTW 
2cdb c3 46 20			jp macro_next 
2cde				endm 
# End of macro NEXTW
2cde			 
2cde			.DEC: 
2cde				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2cde 6f				db WORD_SYS_CORE+91             
2cdf 2f 2d			dw .INC2            
2ce1 03				db 2 + 1 
2ce2 .. 00			db "-!",0              
2ce5				endm 
# End of macro CWHEAD
2ce5			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2ce5					if DEBUG_FORTH_WORDS_KEY 
2ce5						DMARK "-s_" 
2ce5 f5				push af  
2ce6 3a fa 2c			ld a, (.dmark)  
2ce9 32 77 fb			ld (debug_mark),a  
2cec 3a fb 2c			ld a, (.dmark+1)  
2cef 32 78 fb			ld (debug_mark+1),a  
2cf2 3a fc 2c			ld a, (.dmark+2)  
2cf5 32 79 fb			ld (debug_mark+2),a  
2cf8 18 03			jr .pastdmark  
2cfa ..			.dmark: db "-s_"  
2cfd f1			.pastdmark: pop af  
2cfe			endm  
# End of macro DMARK
2cfe						CALLMONITOR 
2cfe cd 4d 17			call break_point_state  
2d01				endm  
# End of macro CALLMONITOR
2d01					endif 
2d01			 
2d01					FORTH_DSP_VALUEHL 
2d01 cd d4 1e			call macro_dsp_valuehl 
2d04				endm 
# End of macro FORTH_DSP_VALUEHL
2d04			 
2d04 e5					push hl   ; save address 
2d05			 
2d05					FORTH_DSP_POP 
2d05 cd 8c 1f			call macro_forth_dsp_pop 
2d08				endm 
# End of macro FORTH_DSP_POP
2d08			 
2d08					FORTH_DSP_VALUEHL 
2d08 cd d4 1e			call macro_dsp_valuehl 
2d0b				endm 
# End of macro FORTH_DSP_VALUEHL
2d0b			 
2d0b					; hl contains value to add to byte at a 
2d0b				 
2d0b eb					ex de, hl 
2d0c			 
2d0c e1					pop hl 
2d0d			 
2d0d					if DEBUG_FORTH_WORDS 
2d0d						DMARK "DEC" 
2d0d f5				push af  
2d0e 3a 22 2d			ld a, (.dmark)  
2d11 32 77 fb			ld (debug_mark),a  
2d14 3a 23 2d			ld a, (.dmark+1)  
2d17 32 78 fb			ld (debug_mark+1),a  
2d1a 3a 24 2d			ld a, (.dmark+2)  
2d1d 32 79 fb			ld (debug_mark+2),a  
2d20 18 03			jr .pastdmark  
2d22 ..			.dmark: db "DEC"  
2d25 f1			.pastdmark: pop af  
2d26			endm  
# End of macro DMARK
2d26						CALLMONITOR 
2d26 cd 4d 17			call break_point_state  
2d29				endm  
# End of macro CALLMONITOR
2d29					endif 
2d29			 
2d29 7e					ld a,(hl) 
2d2a 93					sub e 
2d2b 77					ld (hl),a 
2d2c			 
2d2c			 
2d2c			 
2d2c				       NEXTW 
2d2c c3 46 20			jp macro_next 
2d2f				endm 
# End of macro NEXTW
2d2f			 
2d2f			.INC2: 
2d2f				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2d2f 6f				db WORD_SYS_CORE+91             
2d30 d9 2d			dw .DEC2            
2d32 04				db 3 + 1 
2d33 .. 00			db "+2!",0              
2d37				endm 
# End of macro CWHEAD
2d37			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2d37			 
2d37					if DEBUG_FORTH_WORDS_KEY 
2d37						DMARK "+2s" 
2d37 f5				push af  
2d38 3a 4c 2d			ld a, (.dmark)  
2d3b 32 77 fb			ld (debug_mark),a  
2d3e 3a 4d 2d			ld a, (.dmark+1)  
2d41 32 78 fb			ld (debug_mark+1),a  
2d44 3a 4e 2d			ld a, (.dmark+2)  
2d47 32 79 fb			ld (debug_mark+2),a  
2d4a 18 03			jr .pastdmark  
2d4c ..			.dmark: db "+2s"  
2d4f f1			.pastdmark: pop af  
2d50			endm  
# End of macro DMARK
2d50						CALLMONITOR 
2d50 cd 4d 17			call break_point_state  
2d53				endm  
# End of macro CALLMONITOR
2d53					endif 
2d53			 
2d53					; Address 
2d53			 
2d53					FORTH_DSP_VALUEHL 
2d53 cd d4 1e			call macro_dsp_valuehl 
2d56				endm 
# End of macro FORTH_DSP_VALUEHL
2d56			 
2d56 e5					push hl    ; save address 
2d57			 
2d57					; load content into de 
2d57			 
2d57 5e					ld e,(hl) 
2d58 23					inc hl 
2d59 56					ld d, (hl) 
2d5a			 
2d5a					if DEBUG_FORTH_WORDS 
2d5a						DMARK "+2a" 
2d5a f5				push af  
2d5b 3a 6f 2d			ld a, (.dmark)  
2d5e 32 77 fb			ld (debug_mark),a  
2d61 3a 70 2d			ld a, (.dmark+1)  
2d64 32 78 fb			ld (debug_mark+1),a  
2d67 3a 71 2d			ld a, (.dmark+2)  
2d6a 32 79 fb			ld (debug_mark+2),a  
2d6d 18 03			jr .pastdmark  
2d6f ..			.dmark: db "+2a"  
2d72 f1			.pastdmark: pop af  
2d73			endm  
# End of macro DMARK
2d73						CALLMONITOR 
2d73 cd 4d 17			call break_point_state  
2d76				endm  
# End of macro CALLMONITOR
2d76					endif 
2d76			 
2d76					FORTH_DSP_POP 
2d76 cd 8c 1f			call macro_forth_dsp_pop 
2d79				endm 
# End of macro FORTH_DSP_POP
2d79			 
2d79					; Get value to add 
2d79			 
2d79					FORTH_DSP_VALUE 
2d79 cd bd 1e			call macro_forth_dsp_value 
2d7c				endm 
# End of macro FORTH_DSP_VALUE
2d7c			 
2d7c					if DEBUG_FORTH_WORDS 
2d7c						DMARK "+2v" 
2d7c f5				push af  
2d7d 3a 91 2d			ld a, (.dmark)  
2d80 32 77 fb			ld (debug_mark),a  
2d83 3a 92 2d			ld a, (.dmark+1)  
2d86 32 78 fb			ld (debug_mark+1),a  
2d89 3a 93 2d			ld a, (.dmark+2)  
2d8c 32 79 fb			ld (debug_mark+2),a  
2d8f 18 03			jr .pastdmark  
2d91 ..			.dmark: db "+2v"  
2d94 f1			.pastdmark: pop af  
2d95			endm  
# End of macro DMARK
2d95						CALLMONITOR 
2d95 cd 4d 17			call break_point_state  
2d98				endm  
# End of macro CALLMONITOR
2d98					endif 
2d98			 
2d98 19					add hl, de 
2d99			 
2d99					if DEBUG_FORTH_WORDS 
2d99						DMARK "+2+" 
2d99 f5				push af  
2d9a 3a ae 2d			ld a, (.dmark)  
2d9d 32 77 fb			ld (debug_mark),a  
2da0 3a af 2d			ld a, (.dmark+1)  
2da3 32 78 fb			ld (debug_mark+1),a  
2da6 3a b0 2d			ld a, (.dmark+2)  
2da9 32 79 fb			ld (debug_mark+2),a  
2dac 18 03			jr .pastdmark  
2dae ..			.dmark: db "+2+"  
2db1 f1			.pastdmark: pop af  
2db2			endm  
# End of macro DMARK
2db2						CALLMONITOR 
2db2 cd 4d 17			call break_point_state  
2db5				endm  
# End of macro CALLMONITOR
2db5					endif 
2db5			 
2db5					; move result to de 
2db5			 
2db5 eb					ex de, hl 
2db6			 
2db6					; Address 
2db6			 
2db6 e1					pop hl 
2db7			 
2db7					; save it back 
2db7			 
2db7 73					ld (hl), e 
2db8 23					inc hl 
2db9 72					ld (hl), d 
2dba			 
2dba					if DEBUG_FORTH_WORDS 
2dba						DMARK "+2e" 
2dba f5				push af  
2dbb 3a cf 2d			ld a, (.dmark)  
2dbe 32 77 fb			ld (debug_mark),a  
2dc1 3a d0 2d			ld a, (.dmark+1)  
2dc4 32 78 fb			ld (debug_mark+1),a  
2dc7 3a d1 2d			ld a, (.dmark+2)  
2dca 32 79 fb			ld (debug_mark+2),a  
2dcd 18 03			jr .pastdmark  
2dcf ..			.dmark: db "+2e"  
2dd2 f1			.pastdmark: pop af  
2dd3			endm  
# End of macro DMARK
2dd3						CALLMONITOR 
2dd3 cd 4d 17			call break_point_state  
2dd6				endm  
# End of macro CALLMONITOR
2dd6					endif 
2dd6			 
2dd6			 
2dd6			 
2dd6			 
2dd6			 
2dd6				       NEXTW 
2dd6 c3 46 20			jp macro_next 
2dd9				endm 
# End of macro NEXTW
2dd9			 
2dd9			.DEC2: 
2dd9				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2dd9 6f				db WORD_SYS_CORE+91             
2dda 85 2e			dw .GET2            
2ddc 04				db 3 + 1 
2ddd .. 00			db "-2!",0              
2de1				endm 
# End of macro CWHEAD
2de1			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2de1			 
2de1			 
2de1					if DEBUG_FORTH_WORDS_KEY 
2de1						DMARK "-2s" 
2de1 f5				push af  
2de2 3a f6 2d			ld a, (.dmark)  
2de5 32 77 fb			ld (debug_mark),a  
2de8 3a f7 2d			ld a, (.dmark+1)  
2deb 32 78 fb			ld (debug_mark+1),a  
2dee 3a f8 2d			ld a, (.dmark+2)  
2df1 32 79 fb			ld (debug_mark+2),a  
2df4 18 03			jr .pastdmark  
2df6 ..			.dmark: db "-2s"  
2df9 f1			.pastdmark: pop af  
2dfa			endm  
# End of macro DMARK
2dfa						CALLMONITOR 
2dfa cd 4d 17			call break_point_state  
2dfd				endm  
# End of macro CALLMONITOR
2dfd					endif 
2dfd			 
2dfd					; Address 
2dfd			 
2dfd					FORTH_DSP_VALUEHL 
2dfd cd d4 1e			call macro_dsp_valuehl 
2e00				endm 
# End of macro FORTH_DSP_VALUEHL
2e00			 
2e00 e5					push hl    ; save address 
2e01			 
2e01					; load content into de 
2e01			 
2e01 5e					ld e,(hl) 
2e02 23					inc hl 
2e03 56					ld d, (hl) 
2e04			 
2e04					if DEBUG_FORTH_WORDS 
2e04						DMARK "-2a" 
2e04 f5				push af  
2e05 3a 19 2e			ld a, (.dmark)  
2e08 32 77 fb			ld (debug_mark),a  
2e0b 3a 1a 2e			ld a, (.dmark+1)  
2e0e 32 78 fb			ld (debug_mark+1),a  
2e11 3a 1b 2e			ld a, (.dmark+2)  
2e14 32 79 fb			ld (debug_mark+2),a  
2e17 18 03			jr .pastdmark  
2e19 ..			.dmark: db "-2a"  
2e1c f1			.pastdmark: pop af  
2e1d			endm  
# End of macro DMARK
2e1d						CALLMONITOR 
2e1d cd 4d 17			call break_point_state  
2e20				endm  
# End of macro CALLMONITOR
2e20					endif 
2e20			 
2e20					FORTH_DSP_POP 
2e20 cd 8c 1f			call macro_forth_dsp_pop 
2e23				endm 
# End of macro FORTH_DSP_POP
2e23			 
2e23					; Get value to remove 
2e23			 
2e23					FORTH_DSP_VALUE 
2e23 cd bd 1e			call macro_forth_dsp_value 
2e26				endm 
# End of macro FORTH_DSP_VALUE
2e26			 
2e26					if DEBUG_FORTH_WORDS 
2e26						DMARK "-2v" 
2e26 f5				push af  
2e27 3a 3b 2e			ld a, (.dmark)  
2e2a 32 77 fb			ld (debug_mark),a  
2e2d 3a 3c 2e			ld a, (.dmark+1)  
2e30 32 78 fb			ld (debug_mark+1),a  
2e33 3a 3d 2e			ld a, (.dmark+2)  
2e36 32 79 fb			ld (debug_mark+2),a  
2e39 18 03			jr .pastdmark  
2e3b ..			.dmark: db "-2v"  
2e3e f1			.pastdmark: pop af  
2e3f			endm  
# End of macro DMARK
2e3f						CALLMONITOR 
2e3f cd 4d 17			call break_point_state  
2e42				endm  
# End of macro CALLMONITOR
2e42					endif 
2e42			 
2e42 eb					ex de, hl 
2e43 ed 52				sbc hl, de 
2e45			 
2e45					if DEBUG_FORTH_WORDS 
2e45						DMARK "-2d" 
2e45 f5				push af  
2e46 3a 5a 2e			ld a, (.dmark)  
2e49 32 77 fb			ld (debug_mark),a  
2e4c 3a 5b 2e			ld a, (.dmark+1)  
2e4f 32 78 fb			ld (debug_mark+1),a  
2e52 3a 5c 2e			ld a, (.dmark+2)  
2e55 32 79 fb			ld (debug_mark+2),a  
2e58 18 03			jr .pastdmark  
2e5a ..			.dmark: db "-2d"  
2e5d f1			.pastdmark: pop af  
2e5e			endm  
# End of macro DMARK
2e5e						CALLMONITOR 
2e5e cd 4d 17			call break_point_state  
2e61				endm  
# End of macro CALLMONITOR
2e61					endif 
2e61			 
2e61					; move result to de 
2e61			 
2e61 eb					ex de, hl 
2e62			 
2e62					; Address 
2e62			 
2e62 e1					pop hl 
2e63			 
2e63					; save it back 
2e63			 
2e63 73					ld (hl), e 
2e64 23					inc hl 
2e65 72					ld (hl), d 
2e66			 
2e66					if DEBUG_FORTH_WORDS 
2e66						DMARK "-2e" 
2e66 f5				push af  
2e67 3a 7b 2e			ld a, (.dmark)  
2e6a 32 77 fb			ld (debug_mark),a  
2e6d 3a 7c 2e			ld a, (.dmark+1)  
2e70 32 78 fb			ld (debug_mark+1),a  
2e73 3a 7d 2e			ld a, (.dmark+2)  
2e76 32 79 fb			ld (debug_mark+2),a  
2e79 18 03			jr .pastdmark  
2e7b ..			.dmark: db "-2e"  
2e7e f1			.pastdmark: pop af  
2e7f			endm  
# End of macro DMARK
2e7f						CALLMONITOR 
2e7f cd 4d 17			call break_point_state  
2e82				endm  
# End of macro CALLMONITOR
2e82					endif 
2e82			 
2e82			 
2e82			 
2e82			 
2e82			 
2e82				       NEXTW 
2e82 c3 46 20			jp macro_next 
2e85				endm 
# End of macro NEXTW
2e85			.GET2: 
2e85				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2e85 6f				db WORD_SYS_CORE+91             
2e86 b5 2e			dw .BANG2            
2e88 03				db 2 + 1 
2e89 .. 00			db "2@",0              
2e8c				endm 
# End of macro CWHEAD
2e8c			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2e8c					if DEBUG_FORTH_WORDS_KEY 
2e8c						DMARK "2A_" 
2e8c f5				push af  
2e8d 3a a1 2e			ld a, (.dmark)  
2e90 32 77 fb			ld (debug_mark),a  
2e93 3a a2 2e			ld a, (.dmark+1)  
2e96 32 78 fb			ld (debug_mark+1),a  
2e99 3a a3 2e			ld a, (.dmark+2)  
2e9c 32 79 fb			ld (debug_mark+2),a  
2e9f 18 03			jr .pastdmark  
2ea1 ..			.dmark: db "2A_"  
2ea4 f1			.pastdmark: pop af  
2ea5			endm  
# End of macro DMARK
2ea5						CALLMONITOR 
2ea5 cd 4d 17			call break_point_state  
2ea8				endm  
# End of macro CALLMONITOR
2ea8					endif 
2ea8			 
2ea8					FORTH_DSP_VALUEHL 
2ea8 cd d4 1e			call macro_dsp_valuehl 
2eab				endm 
# End of macro FORTH_DSP_VALUEHL
2eab			 
2eab 5e					ld e, (hl) 
2eac 23					inc hl 
2ead 56					ld d, (hl) 
2eae			 
2eae eb					ex de, hl 
2eaf			 
2eaf cd dd 1c				call forth_push_numhl 
2eb2			 
2eb2				       NEXTW 
2eb2 c3 46 20			jp macro_next 
2eb5				endm 
# End of macro NEXTW
2eb5			.BANG2: 
2eb5				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2eb5 6f				db WORD_SYS_CORE+91             
2eb6 ed 2e			dw .CONFIG            
2eb8 03				db 2 + 1 
2eb9 .. 00			db "2!",0              
2ebc				endm 
# End of macro CWHEAD
2ebc			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2ebc					if DEBUG_FORTH_WORDS_KEY 
2ebc						DMARK "2S_" 
2ebc f5				push af  
2ebd 3a d1 2e			ld a, (.dmark)  
2ec0 32 77 fb			ld (debug_mark),a  
2ec3 3a d2 2e			ld a, (.dmark+1)  
2ec6 32 78 fb			ld (debug_mark+1),a  
2ec9 3a d3 2e			ld a, (.dmark+2)  
2ecc 32 79 fb			ld (debug_mark+2),a  
2ecf 18 03			jr .pastdmark  
2ed1 ..			.dmark: db "2S_"  
2ed4 f1			.pastdmark: pop af  
2ed5			endm  
# End of macro DMARK
2ed5						CALLMONITOR 
2ed5 cd 4d 17			call break_point_state  
2ed8				endm  
# End of macro CALLMONITOR
2ed8					endif 
2ed8			 
2ed8					FORTH_DSP_VALUEHL 
2ed8 cd d4 1e			call macro_dsp_valuehl 
2edb				endm 
# End of macro FORTH_DSP_VALUEHL
2edb			 
2edb e5					push hl   ; save address 
2edc			 
2edc			 
2edc					FORTH_DSP_POP 
2edc cd 8c 1f			call macro_forth_dsp_pop 
2edf				endm 
# End of macro FORTH_DSP_POP
2edf			 
2edf					 
2edf					FORTH_DSP_VALUEHL 
2edf cd d4 1e			call macro_dsp_valuehl 
2ee2				endm 
# End of macro FORTH_DSP_VALUEHL
2ee2			 
2ee2					FORTH_DSP_POP 
2ee2 cd 8c 1f			call macro_forth_dsp_pop 
2ee5				endm 
# End of macro FORTH_DSP_POP
2ee5			 
2ee5 eb					ex de, hl    ; value now in de 
2ee6			 
2ee6 e1					pop hl 
2ee7			 
2ee7 73					ld (hl), e 
2ee8			 
2ee8 23					inc hl 
2ee9			 
2ee9 72					ld (hl), d 
2eea			 
2eea			 
2eea				       NEXTW 
2eea c3 46 20			jp macro_next 
2eed				endm 
# End of macro NEXTW
2eed			.CONFIG: 
2eed				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
2eed 6f				db WORD_SYS_CORE+91             
2eee fe 2e			dw .ENDCORE            
2ef0 07				db 6 + 1 
2ef1 .. 00			db "CONFIG",0              
2ef8				endm 
# End of macro CWHEAD
2ef8			; | CONFIG ( -- )  Access the system configuration menu | TO DO 
2ef8			 
2ef8 cd 93 13				call config 
2efb					NEXTW 
2efb c3 46 20			jp macro_next 
2efe				endm 
# End of macro NEXTW
2efe			.ENDCORE: 
2efe			 
2efe			; eof 
2efe			 
2efe			 
# End of file forth_words_core.asm
2efe			include "forth_words_flow.asm" 
2efe			 
2efe			; | ## Program Flow Words 
2efe			 
2efe			.IF: 
2efe				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2efe 1e				db WORD_SYS_CORE+10             
2eff f3 2f			dw .THEN            
2f01 03				db 2 + 1 
2f02 .. 00			db "IF",0              
2f05				endm 
# End of macro CWHEAD
2f05			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2f05			; 
2f05					if DEBUG_FORTH_WORDS_KEY 
2f05						DMARK "IF." 
2f05 f5				push af  
2f06 3a 1a 2f			ld a, (.dmark)  
2f09 32 77 fb			ld (debug_mark),a  
2f0c 3a 1b 2f			ld a, (.dmark+1)  
2f0f 32 78 fb			ld (debug_mark+1),a  
2f12 3a 1c 2f			ld a, (.dmark+2)  
2f15 32 79 fb			ld (debug_mark+2),a  
2f18 18 03			jr .pastdmark  
2f1a ..			.dmark: db "IF."  
2f1d f1			.pastdmark: pop af  
2f1e			endm  
# End of macro DMARK
2f1e						CALLMONITOR 
2f1e cd 4d 17			call break_point_state  
2f21				endm  
# End of macro CALLMONITOR
2f21					endif 
2f21			; eval TOS 
2f21			 
2f21				FORTH_DSP_VALUEHL 
2f21 cd d4 1e			call macro_dsp_valuehl 
2f24				endm 
# End of macro FORTH_DSP_VALUEHL
2f24			 
2f24			;	push hl 
2f24				FORTH_DSP_POP 
2f24 cd 8c 1f			call macro_forth_dsp_pop 
2f27				endm 
# End of macro FORTH_DSP_POP
2f27			;	pop hl 
2f27			 
2f27					if DEBUG_FORTH_WORDS 
2f27						DMARK "IF1" 
2f27 f5				push af  
2f28 3a 3c 2f			ld a, (.dmark)  
2f2b 32 77 fb			ld (debug_mark),a  
2f2e 3a 3d 2f			ld a, (.dmark+1)  
2f31 32 78 fb			ld (debug_mark+1),a  
2f34 3a 3e 2f			ld a, (.dmark+2)  
2f37 32 79 fb			ld (debug_mark+2),a  
2f3a 18 03			jr .pastdmark  
2f3c ..			.dmark: db "IF1"  
2f3f f1			.pastdmark: pop af  
2f40			endm  
# End of macro DMARK
2f40						CALLMONITOR 
2f40 cd 4d 17			call break_point_state  
2f43				endm  
# End of macro CALLMONITOR
2f43					endif 
2f43 b7				or a        ; clear carry flag 
2f44 11 00 00			ld de, 0 
2f47 eb				ex de,hl 
2f48 ed 52			sbc hl, de 
2f4a c2 d4 2f			jp nz, .iftrue 
2f4d			 
2f4d					if DEBUG_FORTH_WORDS 
2f4d						DMARK "IF2" 
2f4d f5				push af  
2f4e 3a 62 2f			ld a, (.dmark)  
2f51 32 77 fb			ld (debug_mark),a  
2f54 3a 63 2f			ld a, (.dmark+1)  
2f57 32 78 fb			ld (debug_mark+1),a  
2f5a 3a 64 2f			ld a, (.dmark+2)  
2f5d 32 79 fb			ld (debug_mark+2),a  
2f60 18 03			jr .pastdmark  
2f62 ..			.dmark: db "IF2"  
2f65 f1			.pastdmark: pop af  
2f66			endm  
# End of macro DMARK
2f66						CALLMONITOR 
2f66 cd 4d 17			call break_point_state  
2f69				endm  
# End of macro CALLMONITOR
2f69					endif 
2f69			 
2f69			; if not true then skip to THEN 
2f69			 
2f69				; TODO get tok_ptr 
2f69				; TODO consume toks until we get to THEN 
2f69			 
2f69 2a 1e f1			ld hl, (os_tok_ptr) 
2f6c					if DEBUG_FORTH_WORDS 
2f6c						DMARK "IF3" 
2f6c f5				push af  
2f6d 3a 81 2f			ld a, (.dmark)  
2f70 32 77 fb			ld (debug_mark),a  
2f73 3a 82 2f			ld a, (.dmark+1)  
2f76 32 78 fb			ld (debug_mark+1),a  
2f79 3a 83 2f			ld a, (.dmark+2)  
2f7c 32 79 fb			ld (debug_mark+2),a  
2f7f 18 03			jr .pastdmark  
2f81 ..			.dmark: db "IF3"  
2f84 f1			.pastdmark: pop af  
2f85			endm  
# End of macro DMARK
2f85						CALLMONITOR 
2f85 cd 4d 17			call break_point_state  
2f88				endm  
# End of macro CALLMONITOR
2f88						 
2f88					endif 
2f88 11 cf 2f			ld de, .ifthen 
2f8b					if DEBUG_FORTH_WORDS 
2f8b						DMARK "IF4" 
2f8b f5				push af  
2f8c 3a a0 2f			ld a, (.dmark)  
2f8f 32 77 fb			ld (debug_mark),a  
2f92 3a a1 2f			ld a, (.dmark+1)  
2f95 32 78 fb			ld (debug_mark+1),a  
2f98 3a a2 2f			ld a, (.dmark+2)  
2f9b 32 79 fb			ld (debug_mark+2),a  
2f9e 18 03			jr .pastdmark  
2fa0 ..			.dmark: db "IF4"  
2fa3 f1			.pastdmark: pop af  
2fa4			endm  
# End of macro DMARK
2fa4						CALLMONITOR 
2fa4 cd 4d 17			call break_point_state  
2fa7				endm  
# End of macro CALLMONITOR
2fa7					endif 
2fa7 cd 61 21			call findnexttok  
2faa			 
2faa					if DEBUG_FORTH_WORDS 
2faa						DMARK "IF5" 
2faa f5				push af  
2fab 3a bf 2f			ld a, (.dmark)  
2fae 32 77 fb			ld (debug_mark),a  
2fb1 3a c0 2f			ld a, (.dmark+1)  
2fb4 32 78 fb			ld (debug_mark+1),a  
2fb7 3a c1 2f			ld a, (.dmark+2)  
2fba 32 79 fb			ld (debug_mark+2),a  
2fbd 18 03			jr .pastdmark  
2fbf ..			.dmark: db "IF5"  
2fc2 f1			.pastdmark: pop af  
2fc3			endm  
# End of macro DMARK
2fc3						CALLMONITOR 
2fc3 cd 4d 17			call break_point_state  
2fc6				endm  
# End of macro CALLMONITOR
2fc6					endif 
2fc6				; TODO replace below with ; exec using tok_ptr 
2fc6 22 1e f1			ld (os_tok_ptr), hl 
2fc9 c3 d7 20			jp exec1 
2fcc				NEXTW 
2fcc c3 46 20			jp macro_next 
2fcf				endm 
# End of macro NEXTW
2fcf			 
2fcf .. 00		.ifthen:  db "THEN",0 
2fd4			 
2fd4			.iftrue:		 
2fd4				; Exec next words normally 
2fd4			 
2fd4				; if true then exec following IF as normal 
2fd4					if DEBUG_FORTH_WORDS 
2fd4						DMARK "IFT" 
2fd4 f5				push af  
2fd5 3a e9 2f			ld a, (.dmark)  
2fd8 32 77 fb			ld (debug_mark),a  
2fdb 3a ea 2f			ld a, (.dmark+1)  
2fde 32 78 fb			ld (debug_mark+1),a  
2fe1 3a eb 2f			ld a, (.dmark+2)  
2fe4 32 79 fb			ld (debug_mark+2),a  
2fe7 18 03			jr .pastdmark  
2fe9 ..			.dmark: db "IFT"  
2fec f1			.pastdmark: pop af  
2fed			endm  
# End of macro DMARK
2fed						CALLMONITOR 
2fed cd 4d 17			call break_point_state  
2ff0				endm  
# End of macro CALLMONITOR
2ff0					endif 
2ff0			 
2ff0					NEXTW 
2ff0 c3 46 20			jp macro_next 
2ff3				endm 
# End of macro NEXTW
2ff3			.THEN: 
2ff3				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
2ff3 1f				db WORD_SYS_CORE+11             
2ff4 1b 30			dw .ELSE            
2ff6 05				db 4 + 1 
2ff7 .. 00			db "THEN",0              
2ffc				endm 
# End of macro CWHEAD
2ffc			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
2ffc					if DEBUG_FORTH_WORDS_KEY 
2ffc						DMARK "THN" 
2ffc f5				push af  
2ffd 3a 11 30			ld a, (.dmark)  
3000 32 77 fb			ld (debug_mark),a  
3003 3a 12 30			ld a, (.dmark+1)  
3006 32 78 fb			ld (debug_mark+1),a  
3009 3a 13 30			ld a, (.dmark+2)  
300c 32 79 fb			ld (debug_mark+2),a  
300f 18 03			jr .pastdmark  
3011 ..			.dmark: db "THN"  
3014 f1			.pastdmark: pop af  
3015			endm  
# End of macro DMARK
3015						CALLMONITOR 
3015 cd 4d 17			call break_point_state  
3018				endm  
# End of macro CALLMONITOR
3018					endif 
3018					NEXTW 
3018 c3 46 20			jp macro_next 
301b				endm 
# End of macro NEXTW
301b			.ELSE: 
301b				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
301b 20				db WORD_SYS_CORE+12             
301c 43 30			dw .DO            
301e 03				db 2 + 1 
301f .. 00			db "ELSE",0              
3024				endm 
# End of macro CWHEAD
3024			; | ELSE ( -- ) Not supported - does nothing | TODO 
3024			 
3024					if DEBUG_FORTH_WORDS_KEY 
3024						DMARK "ELS" 
3024 f5				push af  
3025 3a 39 30			ld a, (.dmark)  
3028 32 77 fb			ld (debug_mark),a  
302b 3a 3a 30			ld a, (.dmark+1)  
302e 32 78 fb			ld (debug_mark+1),a  
3031 3a 3b 30			ld a, (.dmark+2)  
3034 32 79 fb			ld (debug_mark+2),a  
3037 18 03			jr .pastdmark  
3039 ..			.dmark: db "ELS"  
303c f1			.pastdmark: pop af  
303d			endm  
# End of macro DMARK
303d						CALLMONITOR 
303d cd 4d 17			call break_point_state  
3040				endm  
# End of macro CALLMONITOR
3040					endif 
3040			 
3040			 
3040					NEXTW 
3040 c3 46 20			jp macro_next 
3043				endm 
# End of macro NEXTW
3043			.DO: 
3043				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
3043 21				db WORD_SYS_CORE+13             
3044 6a 31			dw .LOOP            
3046 03				db 2 + 1 
3047 .. 00			db "DO",0              
304a				endm 
# End of macro CWHEAD
304a			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
304a			 
304a					if DEBUG_FORTH_WORDS_KEY 
304a						DMARK "DO." 
304a f5				push af  
304b 3a 5f 30			ld a, (.dmark)  
304e 32 77 fb			ld (debug_mark),a  
3051 3a 60 30			ld a, (.dmark+1)  
3054 32 78 fb			ld (debug_mark+1),a  
3057 3a 61 30			ld a, (.dmark+2)  
305a 32 79 fb			ld (debug_mark+2),a  
305d 18 03			jr .pastdmark  
305f ..			.dmark: db "DO."  
3062 f1			.pastdmark: pop af  
3063			endm  
# End of macro DMARK
3063						CALLMONITOR 
3063 cd 4d 17			call break_point_state  
3066				endm  
# End of macro CALLMONITOR
3066					endif 
3066			;  push pc to rsp stack past the DO 
3066			 
3066 2a 1e f1				ld hl, (os_tok_ptr) 
3069 23					inc hl   ; D 
306a 23					inc hl  ; O 
306b 23					inc hl   ; null 
306c					if DEBUG_FORTH_WORDS 
306c						DMARK "DO2" 
306c f5				push af  
306d 3a 81 30			ld a, (.dmark)  
3070 32 77 fb			ld (debug_mark),a  
3073 3a 82 30			ld a, (.dmark+1)  
3076 32 78 fb			ld (debug_mark+1),a  
3079 3a 83 30			ld a, (.dmark+2)  
307c 32 79 fb			ld (debug_mark+2),a  
307f 18 03			jr .pastdmark  
3081 ..			.dmark: db "DO2"  
3084 f1			.pastdmark: pop af  
3085			endm  
# End of macro DMARK
3085						CALLMONITOR 
3085 cd 4d 17			call break_point_state  
3088				endm  
# End of macro CALLMONITOR
3088					endif 
3088					FORTH_RSP_NEXT 
3088 cd 84 1c			call macro_forth_rsp_next 
308b				endm 
# End of macro FORTH_RSP_NEXT
308b					if DEBUG_FORTH_WORDS 
308b						DMARK "DO3" 
308b f5				push af  
308c 3a a0 30			ld a, (.dmark)  
308f 32 77 fb			ld (debug_mark),a  
3092 3a a1 30			ld a, (.dmark+1)  
3095 32 78 fb			ld (debug_mark+1),a  
3098 3a a2 30			ld a, (.dmark+2)  
309b 32 79 fb			ld (debug_mark+2),a  
309e 18 03			jr .pastdmark  
30a0 ..			.dmark: db "DO3"  
30a3 f1			.pastdmark: pop af  
30a4			endm  
# End of macro DMARK
30a4						CALLMONITOR 
30a4 cd 4d 17			call break_point_state  
30a7				endm  
# End of macro CALLMONITOR
30a7					endif 
30a7			 
30a7					;if DEBUG_FORTH_WORDS 
30a7				;		push hl 
30a7			;		endif  
30a7			 
30a7			; get counters from data stack 
30a7			 
30a7			 
30a7					FORTH_DSP_VALUEHL 
30a7 cd d4 1e			call macro_dsp_valuehl 
30aa				endm 
# End of macro FORTH_DSP_VALUEHL
30aa e5					push hl		 ; hl now has starting counter which needs to be tos 
30ab			 
30ab					if DEBUG_FORTH_WORDS 
30ab						DMARK "DO4" 
30ab f5				push af  
30ac 3a c0 30			ld a, (.dmark)  
30af 32 77 fb			ld (debug_mark),a  
30b2 3a c1 30			ld a, (.dmark+1)  
30b5 32 78 fb			ld (debug_mark+1),a  
30b8 3a c2 30			ld a, (.dmark+2)  
30bb 32 79 fb			ld (debug_mark+2),a  
30be 18 03			jr .pastdmark  
30c0 ..			.dmark: db "DO4"  
30c3 f1			.pastdmark: pop af  
30c4			endm  
# End of macro DMARK
30c4						CALLMONITOR 
30c4 cd 4d 17			call break_point_state  
30c7				endm  
# End of macro CALLMONITOR
30c7					endif 
30c7					FORTH_DSP_POP 
30c7 cd 8c 1f			call macro_forth_dsp_pop 
30ca				endm 
# End of macro FORTH_DSP_POP
30ca			 
30ca					if DEBUG_FORTH_WORDS 
30ca						DMARK "DO5" 
30ca f5				push af  
30cb 3a df 30			ld a, (.dmark)  
30ce 32 77 fb			ld (debug_mark),a  
30d1 3a e0 30			ld a, (.dmark+1)  
30d4 32 78 fb			ld (debug_mark+1),a  
30d7 3a e1 30			ld a, (.dmark+2)  
30da 32 79 fb			ld (debug_mark+2),a  
30dd 18 03			jr .pastdmark  
30df ..			.dmark: db "DO5"  
30e2 f1			.pastdmark: pop af  
30e3			endm  
# End of macro DMARK
30e3						CALLMONITOR 
30e3 cd 4d 17			call break_point_state  
30e6				endm  
# End of macro CALLMONITOR
30e6					endif 
30e6			 
30e6					FORTH_DSP_VALUEHL 
30e6 cd d4 1e			call macro_dsp_valuehl 
30e9				endm 
# End of macro FORTH_DSP_VALUEHL
30e9			;		push hl		 ; hl now has starting limit counter 
30e9			 
30e9					if DEBUG_FORTH_WORDS 
30e9						DMARK "DO6" 
30e9 f5				push af  
30ea 3a fe 30			ld a, (.dmark)  
30ed 32 77 fb			ld (debug_mark),a  
30f0 3a ff 30			ld a, (.dmark+1)  
30f3 32 78 fb			ld (debug_mark+1),a  
30f6 3a 00 31			ld a, (.dmark+2)  
30f9 32 79 fb			ld (debug_mark+2),a  
30fc 18 03			jr .pastdmark  
30fe ..			.dmark: db "DO6"  
3101 f1			.pastdmark: pop af  
3102			endm  
# End of macro DMARK
3102						CALLMONITOR 
3102 cd 4d 17			call break_point_state  
3105				endm  
# End of macro CALLMONITOR
3105					endif 
3105					FORTH_DSP_POP 
3105 cd 8c 1f			call macro_forth_dsp_pop 
3108				endm 
# End of macro FORTH_DSP_POP
3108			 
3108			; put counters on the loop stack 
3108			 
3108			;		pop hl			 ; limit counter 
3108 d1					pop de			; start counter 
3109			 
3109					; push limit counter 
3109			 
3109					if DEBUG_FORTH_WORDS 
3109						DMARK "DO7" 
3109 f5				push af  
310a 3a 1e 31			ld a, (.dmark)  
310d 32 77 fb			ld (debug_mark),a  
3110 3a 1f 31			ld a, (.dmark+1)  
3113 32 78 fb			ld (debug_mark+1),a  
3116 3a 20 31			ld a, (.dmark+2)  
3119 32 79 fb			ld (debug_mark+2),a  
311c 18 03			jr .pastdmark  
311e ..			.dmark: db "DO7"  
3121 f1			.pastdmark: pop af  
3122			endm  
# End of macro DMARK
3122						CALLMONITOR 
3122 cd 4d 17			call break_point_state  
3125				endm  
# End of macro CALLMONITOR
3125					endif 
3125					FORTH_LOOP_NEXT 
3125 cd 05 1f			call macro_forth_loop_next 
3128				endm 
# End of macro FORTH_LOOP_NEXT
3128			 
3128					; push start counter 
3128			 
3128 eb					ex de, hl 
3129					if DEBUG_FORTH_WORDS 
3129						DMARK "DO7" 
3129 f5				push af  
312a 3a 3e 31			ld a, (.dmark)  
312d 32 77 fb			ld (debug_mark),a  
3130 3a 3f 31			ld a, (.dmark+1)  
3133 32 78 fb			ld (debug_mark+1),a  
3136 3a 40 31			ld a, (.dmark+2)  
3139 32 79 fb			ld (debug_mark+2),a  
313c 18 03			jr .pastdmark  
313e ..			.dmark: db "DO7"  
3141 f1			.pastdmark: pop af  
3142			endm  
# End of macro DMARK
3142						CALLMONITOR 
3142 cd 4d 17			call break_point_state  
3145				endm  
# End of macro CALLMONITOR
3145					endif 
3145					FORTH_LOOP_NEXT 
3145 cd 05 1f			call macro_forth_loop_next 
3148				endm 
# End of macro FORTH_LOOP_NEXT
3148			 
3148			 
3148					; init first round of I counter 
3148			 
3148 22 42 f1				ld (os_current_i), hl 
314b			 
314b					if DEBUG_FORTH_WORDS 
314b						DMARK "DO8" 
314b f5				push af  
314c 3a 60 31			ld a, (.dmark)  
314f 32 77 fb			ld (debug_mark),a  
3152 3a 61 31			ld a, (.dmark+1)  
3155 32 78 fb			ld (debug_mark+1),a  
3158 3a 62 31			ld a, (.dmark+2)  
315b 32 79 fb			ld (debug_mark+2),a  
315e 18 03			jr .pastdmark  
3160 ..			.dmark: db "DO8"  
3163 f1			.pastdmark: pop af  
3164			endm  
# End of macro DMARK
3164						CALLMONITOR 
3164 cd 4d 17			call break_point_state  
3167				endm  
# End of macro CALLMONITOR
3167					endif 
3167			 
3167					NEXTW 
3167 c3 46 20			jp macro_next 
316a				endm 
# End of macro NEXTW
316a			.LOOP: 
316a				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
316a 22				db WORD_SYS_CORE+14             
316b 82 32			dw .I            
316d 05				db 4 + 1 
316e .. 00			db "LOOP",0              
3173				endm 
# End of macro CWHEAD
3173			; | LOOP ( -- ) Increment and test loop counter  | DONE 
3173			 
3173				; pop tos as current loop count to hl 
3173			 
3173				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3173			 
3173				FORTH_LOOP_TOS 
3173 cd 38 1f			call macro_forth_loop_tos 
3176				endm 
# End of macro FORTH_LOOP_TOS
3176 e5				push hl 
3177			 
3177					if DEBUG_FORTH_WORDS_KEY 
3177						DMARK "LOP" 
3177 f5				push af  
3178 3a 8c 31			ld a, (.dmark)  
317b 32 77 fb			ld (debug_mark),a  
317e 3a 8d 31			ld a, (.dmark+1)  
3181 32 78 fb			ld (debug_mark+1),a  
3184 3a 8e 31			ld a, (.dmark+2)  
3187 32 79 fb			ld (debug_mark+2),a  
318a 18 03			jr .pastdmark  
318c ..			.dmark: db "LOP"  
318f f1			.pastdmark: pop af  
3190			endm  
# End of macro DMARK
3190						CALLMONITOR 
3190 cd 4d 17			call break_point_state  
3193				endm  
# End of macro CALLMONITOR
3193					endif 
3193				; next item on the stack is the limit. get it 
3193			 
3193			 
3193				FORTH_LOOP_POP 
3193 cd 42 1f			call macro_forth_loop_pop 
3196				endm 
# End of macro FORTH_LOOP_POP
3196			 
3196				FORTH_LOOP_TOS 
3196 cd 38 1f			call macro_forth_loop_tos 
3199				endm 
# End of macro FORTH_LOOP_TOS
3199			 
3199 d1				pop de		 ; de = i, hl = limit 
319a			 
319a					if DEBUG_FORTH_WORDS 
319a						DMARK "LP1" 
319a f5				push af  
319b 3a af 31			ld a, (.dmark)  
319e 32 77 fb			ld (debug_mark),a  
31a1 3a b0 31			ld a, (.dmark+1)  
31a4 32 78 fb			ld (debug_mark+1),a  
31a7 3a b1 31			ld a, (.dmark+2)  
31aa 32 79 fb			ld (debug_mark+2),a  
31ad 18 03			jr .pastdmark  
31af ..			.dmark: db "LP1"  
31b2 f1			.pastdmark: pop af  
31b3			endm  
# End of macro DMARK
31b3						CALLMONITOR 
31b3 cd 4d 17			call break_point_state  
31b6				endm  
# End of macro CALLMONITOR
31b6					endif 
31b6			 
31b6				; go back to previous word 
31b6			 
31b6 d5				push de    ; save I for inc later 
31b7			 
31b7			 
31b7				; get limit 
31b7				;  is I at limit? 
31b7			 
31b7			 
31b7					if DEBUG_FORTH_WORDS 
31b7						DMARK "LP1" 
31b7 f5				push af  
31b8 3a cc 31			ld a, (.dmark)  
31bb 32 77 fb			ld (debug_mark),a  
31be 3a cd 31			ld a, (.dmark+1)  
31c1 32 78 fb			ld (debug_mark+1),a  
31c4 3a ce 31			ld a, (.dmark+2)  
31c7 32 79 fb			ld (debug_mark+2),a  
31ca 18 03			jr .pastdmark  
31cc ..			.dmark: db "LP1"  
31cf f1			.pastdmark: pop af  
31d0			endm  
# End of macro DMARK
31d0						CALLMONITOR 
31d0 cd 4d 17			call break_point_state  
31d3				endm  
# End of macro CALLMONITOR
31d3					endif 
31d3			 
31d3 ed 52			sbc hl, de 
31d5			 
31d5			 
31d5				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
31d5			 
31d5 20 26				jr nz, .loopnotdone 
31d7			 
31d7 e1				pop hl   ; get rid of saved I 
31d8				FORTH_LOOP_POP     ; get rid of limit 
31d8 cd 42 1f			call macro_forth_loop_pop 
31db				endm 
# End of macro FORTH_LOOP_POP
31db			 
31db				FORTH_RSP_POP     ; get rid of DO ptr 
31db cd a5 1c			call macro_forth_rsp_pop 
31de				endm 
# End of macro FORTH_RSP_POP
31de			 
31de			if DEBUG_FORTH_WORDS 
31de						DMARK "LP>" 
31de f5				push af  
31df 3a f3 31			ld a, (.dmark)  
31e2 32 77 fb			ld (debug_mark),a  
31e5 3a f4 31			ld a, (.dmark+1)  
31e8 32 78 fb			ld (debug_mark+1),a  
31eb 3a f5 31			ld a, (.dmark+2)  
31ee 32 79 fb			ld (debug_mark+2),a  
31f1 18 03			jr .pastdmark  
31f3 ..			.dmark: db "LP>"  
31f6 f1			.pastdmark: pop af  
31f7			endm  
# End of macro DMARK
31f7				CALLMONITOR 
31f7 cd 4d 17			call break_point_state  
31fa				endm  
# End of macro CALLMONITOR
31fa			endif 
31fa			 
31fa					NEXTW 
31fa c3 46 20			jp macro_next 
31fd				endm 
# End of macro NEXTW
31fd				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
31fd			 
31fd			.loopnotdone: 
31fd			 
31fd e1				pop hl    ; get I 
31fe 23				inc hl 
31ff			 
31ff			   	; save new I 
31ff			 
31ff			 
31ff					; set I counter 
31ff			 
31ff 22 42 f1				ld (os_current_i), hl 
3202			 
3202					if DEBUG_FORTH_WORDS 
3202						DMARK "LPN" 
3202 f5				push af  
3203 3a 17 32			ld a, (.dmark)  
3206 32 77 fb			ld (debug_mark),a  
3209 3a 18 32			ld a, (.dmark+1)  
320c 32 78 fb			ld (debug_mark+1),a  
320f 3a 19 32			ld a, (.dmark+2)  
3212 32 79 fb			ld (debug_mark+2),a  
3215 18 03			jr .pastdmark  
3217 ..			.dmark: db "LPN"  
321a f1			.pastdmark: pop af  
321b			endm  
# End of macro DMARK
321b					CALLMONITOR 
321b cd 4d 17			call break_point_state  
321e				endm  
# End of macro CALLMONITOR
321e					endif 
321e					 
321e				FORTH_LOOP_NEXT 
321e cd 05 1f			call macro_forth_loop_next 
3221				endm 
# End of macro FORTH_LOOP_NEXT
3221			 
3221			 
3221					if DEBUG_FORTH_WORDS 
3221 eb						ex de,hl 
3222					endif 
3222			 
3222			;	; get DO ptr 
3222			; 
3222					if DEBUG_FORTH_WORDS 
3222						DMARK "LP7" 
3222 f5				push af  
3223 3a 37 32			ld a, (.dmark)  
3226 32 77 fb			ld (debug_mark),a  
3229 3a 38 32			ld a, (.dmark+1)  
322c 32 78 fb			ld (debug_mark+1),a  
322f 3a 39 32			ld a, (.dmark+2)  
3232 32 79 fb			ld (debug_mark+2),a  
3235 18 03			jr .pastdmark  
3237 ..			.dmark: db "LP7"  
323a f1			.pastdmark: pop af  
323b			endm  
# End of macro DMARK
323b					CALLMONITOR 
323b cd 4d 17			call break_point_state  
323e				endm  
# End of macro CALLMONITOR
323e					endif 
323e				FORTH_RSP_TOS 
323e cd 9b 1c			call macro_forth_rsp_tos 
3241				endm 
# End of macro FORTH_RSP_TOS
3241			 
3241					if DEBUG_FORTH_WORDS 
3241						DMARK "LP8" 
3241 f5				push af  
3242 3a 56 32			ld a, (.dmark)  
3245 32 77 fb			ld (debug_mark),a  
3248 3a 57 32			ld a, (.dmark+1)  
324b 32 78 fb			ld (debug_mark+1),a  
324e 3a 58 32			ld a, (.dmark+2)  
3251 32 79 fb			ld (debug_mark+2),a  
3254 18 03			jr .pastdmark  
3256 ..			.dmark: db "LP8"  
3259 f1			.pastdmark: pop af  
325a			endm  
# End of macro DMARK
325a					CALLMONITOR 
325a cd 4d 17			call break_point_state  
325d				endm  
# End of macro CALLMONITOR
325d					endif 
325d				;push hl 
325d			 
325d				; not going to DO any more 
325d				; get rid of the RSP pointer as DO will add it back in 
325d				;FORTH_RSP_POP 
325d				;pop hl 
325d			 
325d				;ld hl,(cli_ret_sp) 
325d				;ld e, (hl) 
325d				;inc hl 
325d				;ld d, (hl) 
325d				;ex de,hl 
325d 22 1e f1			ld (os_tok_ptr), hl 
3260					if DEBUG_FORTH_WORDS 
3260						DMARK "LP<" 
3260 f5				push af  
3261 3a 75 32			ld a, (.dmark)  
3264 32 77 fb			ld (debug_mark),a  
3267 3a 76 32			ld a, (.dmark+1)  
326a 32 78 fb			ld (debug_mark+1),a  
326d 3a 77 32			ld a, (.dmark+2)  
3270 32 79 fb			ld (debug_mark+2),a  
3273 18 03			jr .pastdmark  
3275 ..			.dmark: db "LP<"  
3278 f1			.pastdmark: pop af  
3279			endm  
# End of macro DMARK
3279					CALLMONITOR 
3279 cd 4d 17			call break_point_state  
327c				endm  
# End of macro CALLMONITOR
327c				endif 
327c c3 d7 20			jp exec1 
327f			 
327f					 
327f			 
327f			 
327f					NEXTW 
327f c3 46 20			jp macro_next 
3282				endm 
# End of macro NEXTW
3282			.I:  
3282			 
3282				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
3282 5e				db WORD_SYS_CORE+74             
3283 ad 32			dw .DLOOP            
3285 02				db 1 + 1 
3286 .. 00			db "I",0              
3288				endm 
# End of macro CWHEAD
3288			; | I ( -- ) Current loop counter | DONE 
3288					if DEBUG_FORTH_WORDS_KEY 
3288						DMARK "I.." 
3288 f5				push af  
3289 3a 9d 32			ld a, (.dmark)  
328c 32 77 fb			ld (debug_mark),a  
328f 3a 9e 32			ld a, (.dmark+1)  
3292 32 78 fb			ld (debug_mark+1),a  
3295 3a 9f 32			ld a, (.dmark+2)  
3298 32 79 fb			ld (debug_mark+2),a  
329b 18 03			jr .pastdmark  
329d ..			.dmark: db "I.."  
32a0 f1			.pastdmark: pop af  
32a1			endm  
# End of macro DMARK
32a1						CALLMONITOR 
32a1 cd 4d 17			call break_point_state  
32a4				endm  
# End of macro CALLMONITOR
32a4					endif 
32a4			 
32a4 2a 42 f1				ld hl,(os_current_i) 
32a7 cd dd 1c				call forth_push_numhl 
32aa			 
32aa					NEXTW 
32aa c3 46 20			jp macro_next 
32ad				endm 
# End of macro NEXTW
32ad			.DLOOP: 
32ad				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
32ad 5f				db WORD_SYS_CORE+75             
32ae 8e 33			dw .REPEAT            
32b0 06				db 5 + 1 
32b1 .. 00			db "-LOOP",0              
32b7				endm 
# End of macro CWHEAD
32b7			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
32b7				; pop tos as current loop count to hl 
32b7					if DEBUG_FORTH_WORDS_KEY 
32b7						DMARK "-LP" 
32b7 f5				push af  
32b8 3a cc 32			ld a, (.dmark)  
32bb 32 77 fb			ld (debug_mark),a  
32be 3a cd 32			ld a, (.dmark+1)  
32c1 32 78 fb			ld (debug_mark+1),a  
32c4 3a ce 32			ld a, (.dmark+2)  
32c7 32 79 fb			ld (debug_mark+2),a  
32ca 18 03			jr .pastdmark  
32cc ..			.dmark: db "-LP"  
32cf f1			.pastdmark: pop af  
32d0			endm  
# End of macro DMARK
32d0						CALLMONITOR 
32d0 cd 4d 17			call break_point_state  
32d3				endm  
# End of macro CALLMONITOR
32d3					endif 
32d3			 
32d3				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
32d3			 
32d3				FORTH_LOOP_TOS 
32d3 cd 38 1f			call macro_forth_loop_tos 
32d6				endm 
# End of macro FORTH_LOOP_TOS
32d6 e5				push hl 
32d7			 
32d7					if DEBUG_FORTH_WORDS 
32d7						DMARK "-LP" 
32d7 f5				push af  
32d8 3a ec 32			ld a, (.dmark)  
32db 32 77 fb			ld (debug_mark),a  
32de 3a ed 32			ld a, (.dmark+1)  
32e1 32 78 fb			ld (debug_mark+1),a  
32e4 3a ee 32			ld a, (.dmark+2)  
32e7 32 79 fb			ld (debug_mark+2),a  
32ea 18 03			jr .pastdmark  
32ec ..			.dmark: db "-LP"  
32ef f1			.pastdmark: pop af  
32f0			endm  
# End of macro DMARK
32f0						CALLMONITOR 
32f0 cd 4d 17			call break_point_state  
32f3				endm  
# End of macro CALLMONITOR
32f3					endif 
32f3				; next item on the stack is the limit. get it 
32f3			 
32f3			 
32f3				FORTH_LOOP_POP 
32f3 cd 42 1f			call macro_forth_loop_pop 
32f6				endm 
# End of macro FORTH_LOOP_POP
32f6			 
32f6				FORTH_LOOP_TOS 
32f6 cd 38 1f			call macro_forth_loop_tos 
32f9				endm 
# End of macro FORTH_LOOP_TOS
32f9			 
32f9 d1				pop de		 ; de = i, hl = limit 
32fa			 
32fa					if DEBUG_FORTH_WORDS 
32fa						DMARK "-L1" 
32fa f5				push af  
32fb 3a 0f 33			ld a, (.dmark)  
32fe 32 77 fb			ld (debug_mark),a  
3301 3a 10 33			ld a, (.dmark+1)  
3304 32 78 fb			ld (debug_mark+1),a  
3307 3a 11 33			ld a, (.dmark+2)  
330a 32 79 fb			ld (debug_mark+2),a  
330d 18 03			jr .pastdmark  
330f ..			.dmark: db "-L1"  
3312 f1			.pastdmark: pop af  
3313			endm  
# End of macro DMARK
3313						CALLMONITOR 
3313 cd 4d 17			call break_point_state  
3316				endm  
# End of macro CALLMONITOR
3316					endif 
3316			 
3316				; go back to previous word 
3316			 
3316 d5				push de    ; save I for inc later 
3317			 
3317			 
3317				; get limit 
3317				;  is I at limit? 
3317			 
3317			 
3317					if DEBUG_FORTH_WORDS 
3317						DMARK "-L1" 
3317 f5				push af  
3318 3a 2c 33			ld a, (.dmark)  
331b 32 77 fb			ld (debug_mark),a  
331e 3a 2d 33			ld a, (.dmark+1)  
3321 32 78 fb			ld (debug_mark+1),a  
3324 3a 2e 33			ld a, (.dmark+2)  
3327 32 79 fb			ld (debug_mark+2),a  
332a 18 03			jr .pastdmark  
332c ..			.dmark: db "-L1"  
332f f1			.pastdmark: pop af  
3330			endm  
# End of macro DMARK
3330						CALLMONITOR 
3330 cd 4d 17			call break_point_state  
3333				endm  
# End of macro CALLMONITOR
3333					endif 
3333			 
3333 ed 52			sbc hl, de 
3335			 
3335			 
3335				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3335			 
3335 20 26				jr nz, .mloopnotdone 
3337			 
3337 e1				pop hl   ; get rid of saved I 
3338				FORTH_LOOP_POP     ; get rid of limit 
3338 cd 42 1f			call macro_forth_loop_pop 
333b				endm 
# End of macro FORTH_LOOP_POP
333b			 
333b				FORTH_RSP_POP     ; get rid of DO ptr 
333b cd a5 1c			call macro_forth_rsp_pop 
333e				endm 
# End of macro FORTH_RSP_POP
333e			 
333e			if DEBUG_FORTH_WORDS 
333e						DMARK "-L>" 
333e f5				push af  
333f 3a 53 33			ld a, (.dmark)  
3342 32 77 fb			ld (debug_mark),a  
3345 3a 54 33			ld a, (.dmark+1)  
3348 32 78 fb			ld (debug_mark+1),a  
334b 3a 55 33			ld a, (.dmark+2)  
334e 32 79 fb			ld (debug_mark+2),a  
3351 18 03			jr .pastdmark  
3353 ..			.dmark: db "-L>"  
3356 f1			.pastdmark: pop af  
3357			endm  
# End of macro DMARK
3357				CALLMONITOR 
3357 cd 4d 17			call break_point_state  
335a				endm  
# End of macro CALLMONITOR
335a			endif 
335a			 
335a					NEXTW 
335a c3 46 20			jp macro_next 
335d				endm 
# End of macro NEXTW
335d				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
335d			 
335d			.mloopnotdone: 
335d			 
335d e1				pop hl    ; get I 
335e 2b				dec hl 
335f			 
335f			   	; save new I 
335f			 
335f			 
335f					; set I counter 
335f			 
335f 22 42 f1				ld (os_current_i), hl 
3362			 
3362					 
3362				FORTH_LOOP_NEXT 
3362 cd 05 1f			call macro_forth_loop_next 
3365				endm 
# End of macro FORTH_LOOP_NEXT
3365			 
3365			 
3365					if DEBUG_FORTH_WORDS 
3365 eb						ex de,hl 
3366					endif 
3366			 
3366			;	; get DO ptr 
3366			; 
3366				FORTH_RSP_TOS 
3366 cd 9b 1c			call macro_forth_rsp_tos 
3369				endm 
# End of macro FORTH_RSP_TOS
3369			 
3369				;push hl 
3369			 
3369				; not going to DO any more 
3369				; get rid of the RSP pointer as DO will add it back in 
3369				;FORTH_RSP_POP 
3369				;pop hl 
3369			 
3369			 
3369 22 1e f1			ld (os_tok_ptr), hl 
336c					if DEBUG_FORTH_WORDS 
336c						DMARK "-L<" 
336c f5				push af  
336d 3a 81 33			ld a, (.dmark)  
3370 32 77 fb			ld (debug_mark),a  
3373 3a 82 33			ld a, (.dmark+1)  
3376 32 78 fb			ld (debug_mark+1),a  
3379 3a 83 33			ld a, (.dmark+2)  
337c 32 79 fb			ld (debug_mark+2),a  
337f 18 03			jr .pastdmark  
3381 ..			.dmark: db "-L<"  
3384 f1			.pastdmark: pop af  
3385			endm  
# End of macro DMARK
3385					CALLMONITOR 
3385 cd 4d 17			call break_point_state  
3388				endm  
# End of macro CALLMONITOR
3388				endif 
3388 c3 d7 20			jp exec1 
338b			 
338b					 
338b			 
338b			 
338b			 
338b				NEXTW 
338b c3 46 20			jp macro_next 
338e				endm 
# End of macro NEXTW
338e			 
338e			 
338e			 
338e			 
338e			.REPEAT: 
338e				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
338e 71				db WORD_SYS_CORE+93             
338f e1 33			dw .UNTIL            
3391 06				db 5 + 1 
3392 .. 00			db "REPEAT",0              
3399				endm 
# End of macro CWHEAD
3399			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
3399			;  push pc to rsp stack past the REPEAT 
3399					if DEBUG_FORTH_WORDS_KEY 
3399						DMARK "REP" 
3399 f5				push af  
339a 3a ae 33			ld a, (.dmark)  
339d 32 77 fb			ld (debug_mark),a  
33a0 3a af 33			ld a, (.dmark+1)  
33a3 32 78 fb			ld (debug_mark+1),a  
33a6 3a b0 33			ld a, (.dmark+2)  
33a9 32 79 fb			ld (debug_mark+2),a  
33ac 18 03			jr .pastdmark  
33ae ..			.dmark: db "REP"  
33b1 f1			.pastdmark: pop af  
33b2			endm  
# End of macro DMARK
33b2						CALLMONITOR 
33b2 cd 4d 17			call break_point_state  
33b5				endm  
# End of macro CALLMONITOR
33b5					endif 
33b5			 
33b5 2a 1e f1				ld hl, (os_tok_ptr) 
33b8 23					inc hl   ; R 
33b9 23					inc hl  ; E 
33ba 23					inc hl   ; P 
33bb 23					inc hl   ; E 
33bc 23					inc hl   ; A 
33bd 23					inc hl   ; T 
33be 23					inc hl   ; zero 
33bf					FORTH_RSP_NEXT 
33bf cd 84 1c			call macro_forth_rsp_next 
33c2				endm 
# End of macro FORTH_RSP_NEXT
33c2			 
33c2			 
33c2					if DEBUG_FORTH_WORDS 
33c2						DMARK "REP" 
33c2 f5				push af  
33c3 3a d7 33			ld a, (.dmark)  
33c6 32 77 fb			ld (debug_mark),a  
33c9 3a d8 33			ld a, (.dmark+1)  
33cc 32 78 fb			ld (debug_mark+1),a  
33cf 3a d9 33			ld a, (.dmark+2)  
33d2 32 79 fb			ld (debug_mark+2),a  
33d5 18 03			jr .pastdmark  
33d7 ..			.dmark: db "REP"  
33da f1			.pastdmark: pop af  
33db			endm  
# End of macro DMARK
33db						;pop bc    ; TODO BUG ?????? what is this for???? 
33db						CALLMONITOR 
33db cd 4d 17			call break_point_state  
33de				endm  
# End of macro CALLMONITOR
33de					endif 
33de			 
33de					NEXTW 
33de c3 46 20			jp macro_next 
33e1				endm 
# End of macro NEXTW
33e1			;	       NEXTW 
33e1			 
33e1			.UNTIL: 
33e1				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
33e1 72				db WORD_SYS_CORE+94             
33e2 78 34			dw .ENDFLOW            
33e4 06				db 5 + 1 
33e5 .. 00			db "UNTIL",0              
33eb				endm 
# End of macro CWHEAD
33eb			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
33eb			 
33eb				; pop tos as check 
33eb			 
33eb				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
33eb			 
33eb				FORTH_DSP_VALUEHL 
33eb cd d4 1e			call macro_dsp_valuehl 
33ee				endm 
# End of macro FORTH_DSP_VALUEHL
33ee			 
33ee					if DEBUG_FORTH_WORDS_KEY 
33ee						DMARK "UNT" 
33ee f5				push af  
33ef 3a 03 34			ld a, (.dmark)  
33f2 32 77 fb			ld (debug_mark),a  
33f5 3a 04 34			ld a, (.dmark+1)  
33f8 32 78 fb			ld (debug_mark+1),a  
33fb 3a 05 34			ld a, (.dmark+2)  
33fe 32 79 fb			ld (debug_mark+2),a  
3401 18 03			jr .pastdmark  
3403 ..			.dmark: db "UNT"  
3406 f1			.pastdmark: pop af  
3407			endm  
# End of macro DMARK
3407						CALLMONITOR 
3407 cd 4d 17			call break_point_state  
340a				endm  
# End of macro CALLMONITOR
340a					endif 
340a			 
340a			;	push hl 
340a				FORTH_DSP_POP 
340a cd 8c 1f			call macro_forth_dsp_pop 
340d				endm 
# End of macro FORTH_DSP_POP
340d			 
340d			;	pop hl 
340d			 
340d				; test if true 
340d			 
340d cd 32 0d			call ishlzero 
3410			;	ld a,l 
3410			;	add h 
3410			; 
3410			;	cp 0 
3410			 
3410 20 3e			jr nz, .untilnotdone 
3412			 
3412					if DEBUG_FORTH_WORDS 
3412						DMARK "UNf" 
3412 f5				push af  
3413 3a 27 34			ld a, (.dmark)  
3416 32 77 fb			ld (debug_mark),a  
3419 3a 28 34			ld a, (.dmark+1)  
341c 32 78 fb			ld (debug_mark+1),a  
341f 3a 29 34			ld a, (.dmark+2)  
3422 32 79 fb			ld (debug_mark+2),a  
3425 18 03			jr .pastdmark  
3427 ..			.dmark: db "UNf"  
342a f1			.pastdmark: pop af  
342b			endm  
# End of macro DMARK
342b						CALLMONITOR 
342b cd 4d 17			call break_point_state  
342e				endm  
# End of macro CALLMONITOR
342e					endif 
342e			 
342e			 
342e			 
342e				FORTH_RSP_POP     ; get rid of DO ptr 
342e cd a5 1c			call macro_forth_rsp_pop 
3431				endm 
# End of macro FORTH_RSP_POP
3431			 
3431			if DEBUG_FORTH_WORDS 
3431						DMARK "UN>" 
3431 f5				push af  
3432 3a 46 34			ld a, (.dmark)  
3435 32 77 fb			ld (debug_mark),a  
3438 3a 47 34			ld a, (.dmark+1)  
343b 32 78 fb			ld (debug_mark+1),a  
343e 3a 48 34			ld a, (.dmark+2)  
3441 32 79 fb			ld (debug_mark+2),a  
3444 18 03			jr .pastdmark  
3446 ..			.dmark: db "UN>"  
3449 f1			.pastdmark: pop af  
344a			endm  
# End of macro DMARK
344a				CALLMONITOR 
344a cd 4d 17			call break_point_state  
344d				endm  
# End of macro CALLMONITOR
344d			endif 
344d			 
344d					NEXTW 
344d c3 46 20			jp macro_next 
3450				endm 
# End of macro NEXTW
3450				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3450			 
3450			.untilnotdone: 
3450			 
3450			 
3450			;	; get DO ptr 
3450			; 
3450				FORTH_RSP_TOS 
3450 cd 9b 1c			call macro_forth_rsp_tos 
3453				endm 
# End of macro FORTH_RSP_TOS
3453			 
3453				;push hl 
3453			 
3453				; not going to DO any more 
3453				; get rid of the RSP pointer as DO will add it back in 
3453				;FORTH_RSP_POP 
3453				;pop hl 
3453			 
3453			 
3453 22 1e f1			ld (os_tok_ptr), hl 
3456					if DEBUG_FORTH_WORDS 
3456						DMARK "UN<" 
3456 f5				push af  
3457 3a 6b 34			ld a, (.dmark)  
345a 32 77 fb			ld (debug_mark),a  
345d 3a 6c 34			ld a, (.dmark+1)  
3460 32 78 fb			ld (debug_mark+1),a  
3463 3a 6d 34			ld a, (.dmark+2)  
3466 32 79 fb			ld (debug_mark+2),a  
3469 18 03			jr .pastdmark  
346b ..			.dmark: db "UN<"  
346e f1			.pastdmark: pop af  
346f			endm  
# End of macro DMARK
346f					CALLMONITOR 
346f cd 4d 17			call break_point_state  
3472				endm  
# End of macro CALLMONITOR
3472				endif 
3472 c3 d7 20			jp exec1 
3475			 
3475					 
3475			 
3475			 
3475					NEXTW 
3475 c3 46 20			jp macro_next 
3478				endm 
# End of macro NEXTW
3478			 
3478			 
3478			.ENDFLOW: 
3478			 
3478			; eof 
3478			 
# End of file forth_words_flow.asm
3478			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
3478			include "forth_words_logic.asm" 
3478			 
3478			; | ## Logic Words 
3478			 
3478			.NOT: 
3478				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
3478 2d				db WORD_SYS_CORE+25             
3479 c0 34			dw .IS            
347b 04				db 3 + 1 
347c .. 00			db "NOT",0              
3480				endm 
# End of macro CWHEAD
3480			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
3480					if DEBUG_FORTH_WORDS_KEY 
3480						DMARK "NOT" 
3480 f5				push af  
3481 3a 95 34			ld a, (.dmark)  
3484 32 77 fb			ld (debug_mark),a  
3487 3a 96 34			ld a, (.dmark+1)  
348a 32 78 fb			ld (debug_mark+1),a  
348d 3a 97 34			ld a, (.dmark+2)  
3490 32 79 fb			ld (debug_mark+2),a  
3493 18 03			jr .pastdmark  
3495 ..			.dmark: db "NOT"  
3498 f1			.pastdmark: pop af  
3499			endm  
# End of macro DMARK
3499						CALLMONITOR 
3499 cd 4d 17			call break_point_state  
349c				endm  
# End of macro CALLMONITOR
349c					endif 
349c					FORTH_DSP 
349c cd 9a 1e			call macro_forth_dsp 
349f				endm 
# End of macro FORTH_DSP
349f 7e					ld a,(hl)	; get type of value on TOS 
34a0 fe 02				cp DS_TYPE_INUM  
34a2 28 03				jr z, .noti 
34a4					NEXTW 
34a4 c3 46 20			jp macro_next 
34a7				endm 
# End of macro NEXTW
34a7			.noti:          FORTH_DSP_VALUEHL 
34a7 cd d4 1e			call macro_dsp_valuehl 
34aa				endm 
# End of macro FORTH_DSP_VALUEHL
34aa			;		push hl 
34aa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34aa cd 8c 1f			call macro_forth_dsp_pop 
34ad				endm 
# End of macro FORTH_DSP_POP
34ad			;		pop hl 
34ad 3e 00				ld a,0 
34af bd					cp l 
34b0 28 04				jr z, .not2t 
34b2 2e 00				ld l, 0 
34b4 18 02				jr .notip 
34b6			 
34b6 2e ff		.not2t:		ld l, 255 
34b8			 
34b8 26 00		.notip:		ld h, 0	 
34ba			 
34ba cd dd 1c				call forth_push_numhl 
34bd					NEXTW 
34bd c3 46 20			jp macro_next 
34c0				endm 
# End of macro NEXTW
34c0			 
34c0			.IS: 
34c0				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
34c0 2d				db WORD_SYS_CORE+25             
34c1 e6 34			dw .LZERO            
34c3 03				db 2 + 1 
34c4 .. 00			db "IS",0              
34c7				endm 
# End of macro CWHEAD
34c7			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
34c7					if DEBUG_FORTH_WORDS_KEY 
34c7						DMARK "IS." 
34c7 f5				push af  
34c8 3a dc 34			ld a, (.dmark)  
34cb 32 77 fb			ld (debug_mark),a  
34ce 3a dd 34			ld a, (.dmark+1)  
34d1 32 78 fb			ld (debug_mark+1),a  
34d4 3a de 34			ld a, (.dmark+2)  
34d7 32 79 fb			ld (debug_mark+2),a  
34da 18 03			jr .pastdmark  
34dc ..			.dmark: db "IS."  
34df f1			.pastdmark: pop af  
34e0			endm  
# End of macro DMARK
34e0						CALLMONITOR 
34e0 cd 4d 17			call break_point_state  
34e3				endm  
# End of macro CALLMONITOR
34e3					endif 
34e3					NEXTW 
34e3 c3 46 20			jp macro_next 
34e6				endm 
# End of macro NEXTW
34e6			.LZERO: 
34e6				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
34e6 2d				db WORD_SYS_CORE+25             
34e7 f0 34			dw .TZERO            
34e9 03				db 2 + 1 
34ea .. 00			db "0<",0              
34ed				endm 
# End of macro CWHEAD
34ed			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
34ed					NEXTW 
34ed c3 46 20			jp macro_next 
34f0				endm 
# End of macro NEXTW
34f0			.TZERO: 
34f0				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
34f0 2e				db WORD_SYS_CORE+26             
34f1 37 35			dw .LESS            
34f3 03				db 2 + 1 
34f4 .. 00			db "0=",0              
34f7				endm 
# End of macro CWHEAD
34f7			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
34f7				; TODO add floating point number detection 
34f7					;v5 FORTH_DSP_VALUE 
34f7					if DEBUG_FORTH_WORDS_KEY 
34f7						DMARK "0=." 
34f7 f5				push af  
34f8 3a 0c 35			ld a, (.dmark)  
34fb 32 77 fb			ld (debug_mark),a  
34fe 3a 0d 35			ld a, (.dmark+1)  
3501 32 78 fb			ld (debug_mark+1),a  
3504 3a 0e 35			ld a, (.dmark+2)  
3507 32 79 fb			ld (debug_mark+2),a  
350a 18 03			jr .pastdmark  
350c ..			.dmark: db "0=."  
350f f1			.pastdmark: pop af  
3510			endm  
# End of macro DMARK
3510						CALLMONITOR 
3510 cd 4d 17			call break_point_state  
3513				endm  
# End of macro CALLMONITOR
3513					endif 
3513					FORTH_DSP 
3513 cd 9a 1e			call macro_forth_dsp 
3516				endm 
# End of macro FORTH_DSP
3516 7e					ld a,(hl)	; get type of value on TOS 
3517 fe 02				cp DS_TYPE_INUM  
3519 28 00				jr z, .tz_inum 
351b			 
351b				if FORTH_ENABLE_FLOATMATH 
351b					jr .tz_done 
351b			 
351b				endif 
351b					 
351b			 
351b			.tz_inum: 
351b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
351b cd d4 1e			call macro_dsp_valuehl 
351e				endm 
# End of macro FORTH_DSP_VALUEHL
351e			 
351e			;		push hl 
351e			 
351e					; destroy value TOS 
351e			 
351e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
351e cd 8c 1f			call macro_forth_dsp_pop 
3521				endm 
# End of macro FORTH_DSP_POP
3521			 
3521			;		pop hl 
3521			 
3521 3e 00				ld a,0 
3523			 
3523 bd					cp l 
3524 20 08				jr nz, .tz_notzero 
3526			 
3526 bc					cp h 
3527			 
3527 20 05				jr nz, .tz_notzero 
3529			 
3529			 
3529 21 01 00				ld hl, FORTH_TRUE 
352c 18 03				jr .tz_done 
352e			 
352e 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
3531			 
3531					; push value back onto stack for another op etc 
3531			 
3531			.tz_done: 
3531 cd dd 1c				call forth_push_numhl 
3534			 
3534					NEXTW 
3534 c3 46 20			jp macro_next 
3537				endm 
# End of macro NEXTW
3537			.LESS: 
3537				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3537 2f				db WORD_SYS_CORE+27             
3538 a0 35			dw .GT            
353a 02				db 1 + 1 
353b .. 00			db "<",0              
353d				endm 
# End of macro CWHEAD
353d			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
353d				; TODO add floating point number detection 
353d					if DEBUG_FORTH_WORDS_KEY 
353d						DMARK "LES" 
353d f5				push af  
353e 3a 52 35			ld a, (.dmark)  
3541 32 77 fb			ld (debug_mark),a  
3544 3a 53 35			ld a, (.dmark+1)  
3547 32 78 fb			ld (debug_mark+1),a  
354a 3a 54 35			ld a, (.dmark+2)  
354d 32 79 fb			ld (debug_mark+2),a  
3550 18 03			jr .pastdmark  
3552 ..			.dmark: db "LES"  
3555 f1			.pastdmark: pop af  
3556			endm  
# End of macro DMARK
3556						CALLMONITOR 
3556 cd 4d 17			call break_point_state  
3559				endm  
# End of macro CALLMONITOR
3559					endif 
3559					FORTH_DSP 
3559 cd 9a 1e			call macro_forth_dsp 
355c				endm 
# End of macro FORTH_DSP
355c					;v5 FORTH_DSP_VALUE 
355c 7e					ld a,(hl)	; get type of value on TOS 
355d fe 02				cp DS_TYPE_INUM  
355f 28 00				jr z, .less_inum 
3561			 
3561				if FORTH_ENABLE_FLOATMATH 
3561					jr .less_done 
3561			 
3561				endif 
3561					 
3561			 
3561			.less_inum: 
3561					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3561 cd d4 1e			call macro_dsp_valuehl 
3564				endm 
# End of macro FORTH_DSP_VALUEHL
3564			 
3564 e5					push hl  ; u2 
3565			 
3565					; destroy value TOS 
3565			 
3565					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3565 cd 8c 1f			call macro_forth_dsp_pop 
3568				endm 
# End of macro FORTH_DSP_POP
3568			 
3568			 
3568					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3568 cd d4 1e			call macro_dsp_valuehl 
356b				endm 
# End of macro FORTH_DSP_VALUEHL
356b			 
356b e5					push hl    ; u1 
356c			 
356c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
356c cd 8c 1f			call macro_forth_dsp_pop 
356f				endm 
# End of macro FORTH_DSP_POP
356f			 
356f			 
356f b7			 or a      ;clear carry flag 
3570 01 00 00		 ld bc, FORTH_FALSE 
3573 e1			  pop hl    ; u1 
3574 d1			  pop de    ; u2 
3575 ed 52		  sbc hl,de 
3577 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
3579			 
3579 01 01 00		 ld bc, FORTH_TRUE 
357c			.lscont:  
357c c5					push bc 
357d e1					pop hl 
357e			 
357e					if DEBUG_FORTH_WORDS 
357e						DMARK "LT1" 
357e f5				push af  
357f 3a 93 35			ld a, (.dmark)  
3582 32 77 fb			ld (debug_mark),a  
3585 3a 94 35			ld a, (.dmark+1)  
3588 32 78 fb			ld (debug_mark+1),a  
358b 3a 95 35			ld a, (.dmark+2)  
358e 32 79 fb			ld (debug_mark+2),a  
3591 18 03			jr .pastdmark  
3593 ..			.dmark: db "LT1"  
3596 f1			.pastdmark: pop af  
3597			endm  
# End of macro DMARK
3597						CALLMONITOR 
3597 cd 4d 17			call break_point_state  
359a				endm  
# End of macro CALLMONITOR
359a					endif 
359a cd dd 1c				call forth_push_numhl 
359d			 
359d					NEXTW 
359d c3 46 20			jp macro_next 
35a0				endm 
# End of macro NEXTW
35a0			.GT: 
35a0				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
35a0 30				db WORD_SYS_CORE+28             
35a1 09 36			dw .EQUAL            
35a3 02				db 1 + 1 
35a4 .. 00			db ">",0              
35a6				endm 
# End of macro CWHEAD
35a6			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
35a6				; TODO add floating point number detection 
35a6					if DEBUG_FORTH_WORDS_KEY 
35a6						DMARK "GRT" 
35a6 f5				push af  
35a7 3a bb 35			ld a, (.dmark)  
35aa 32 77 fb			ld (debug_mark),a  
35ad 3a bc 35			ld a, (.dmark+1)  
35b0 32 78 fb			ld (debug_mark+1),a  
35b3 3a bd 35			ld a, (.dmark+2)  
35b6 32 79 fb			ld (debug_mark+2),a  
35b9 18 03			jr .pastdmark  
35bb ..			.dmark: db "GRT"  
35be f1			.pastdmark: pop af  
35bf			endm  
# End of macro DMARK
35bf						CALLMONITOR 
35bf cd 4d 17			call break_point_state  
35c2				endm  
# End of macro CALLMONITOR
35c2					endif 
35c2					FORTH_DSP 
35c2 cd 9a 1e			call macro_forth_dsp 
35c5				endm 
# End of macro FORTH_DSP
35c5					;FORTH_DSP_VALUE 
35c5 7e					ld a,(hl)	; get type of value on TOS 
35c6 fe 02				cp DS_TYPE_INUM  
35c8 28 00				jr z, .gt_inum 
35ca			 
35ca				if FORTH_ENABLE_FLOATMATH 
35ca					jr .gt_done 
35ca			 
35ca				endif 
35ca					 
35ca			 
35ca			.gt_inum: 
35ca					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35ca cd d4 1e			call macro_dsp_valuehl 
35cd				endm 
# End of macro FORTH_DSP_VALUEHL
35cd			 
35cd e5					push hl  ; u2 
35ce			 
35ce					; destroy value TOS 
35ce			 
35ce					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35ce cd 8c 1f			call macro_forth_dsp_pop 
35d1				endm 
# End of macro FORTH_DSP_POP
35d1			 
35d1			 
35d1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35d1 cd d4 1e			call macro_dsp_valuehl 
35d4				endm 
# End of macro FORTH_DSP_VALUEHL
35d4			 
35d4 e5					push hl    ; u1 
35d5			 
35d5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35d5 cd 8c 1f			call macro_forth_dsp_pop 
35d8				endm 
# End of macro FORTH_DSP_POP
35d8			 
35d8			 
35d8 b7			 or a      ;clear carry flag 
35d9 01 00 00		 ld bc, FORTH_FALSE 
35dc e1			  pop hl    ; u1 
35dd d1			  pop de    ; u2 
35de ed 52		  sbc hl,de 
35e0 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
35e2			 
35e2 01 01 00		 ld bc, FORTH_TRUE 
35e5			.gtcont:  
35e5 c5					push bc 
35e6 e1					pop hl 
35e7			 
35e7					if DEBUG_FORTH_WORDS 
35e7						DMARK "GT1" 
35e7 f5				push af  
35e8 3a fc 35			ld a, (.dmark)  
35eb 32 77 fb			ld (debug_mark),a  
35ee 3a fd 35			ld a, (.dmark+1)  
35f1 32 78 fb			ld (debug_mark+1),a  
35f4 3a fe 35			ld a, (.dmark+2)  
35f7 32 79 fb			ld (debug_mark+2),a  
35fa 18 03			jr .pastdmark  
35fc ..			.dmark: db "GT1"  
35ff f1			.pastdmark: pop af  
3600			endm  
# End of macro DMARK
3600						CALLMONITOR 
3600 cd 4d 17			call break_point_state  
3603				endm  
# End of macro CALLMONITOR
3603					endif 
3603 cd dd 1c				call forth_push_numhl 
3606			 
3606					NEXTW 
3606 c3 46 20			jp macro_next 
3609				endm 
# End of macro NEXTW
3609			.EQUAL: 
3609				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3609 31				db WORD_SYS_CORE+29             
360a 74 36			dw .ENDLOGIC            
360c 02				db 1 + 1 
360d .. 00			db "=",0              
360f				endm 
# End of macro CWHEAD
360f			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
360f				; TODO add floating point number detection 
360f					if DEBUG_FORTH_WORDS_KEY 
360f						DMARK "EQ." 
360f f5				push af  
3610 3a 24 36			ld a, (.dmark)  
3613 32 77 fb			ld (debug_mark),a  
3616 3a 25 36			ld a, (.dmark+1)  
3619 32 78 fb			ld (debug_mark+1),a  
361c 3a 26 36			ld a, (.dmark+2)  
361f 32 79 fb			ld (debug_mark+2),a  
3622 18 03			jr .pastdmark  
3624 ..			.dmark: db "EQ."  
3627 f1			.pastdmark: pop af  
3628			endm  
# End of macro DMARK
3628						CALLMONITOR 
3628 cd 4d 17			call break_point_state  
362b				endm  
# End of macro CALLMONITOR
362b					endif 
362b					FORTH_DSP 
362b cd 9a 1e			call macro_forth_dsp 
362e				endm 
# End of macro FORTH_DSP
362e					;v5 FORTH_DSP_VALUE 
362e 7e					ld a,(hl)	; get type of value on TOS 
362f fe 02				cp DS_TYPE_INUM  
3631 28 00				jr z, .eq_inum 
3633			 
3633				if FORTH_ENABLE_FLOATMATH 
3633					jr .eq_done 
3633			 
3633				endif 
3633					 
3633			 
3633			.eq_inum: 
3633					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3633 cd d4 1e			call macro_dsp_valuehl 
3636				endm 
# End of macro FORTH_DSP_VALUEHL
3636			 
3636 e5					push hl 
3637			 
3637					; destroy value TOS 
3637			 
3637					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3637 cd 8c 1f			call macro_forth_dsp_pop 
363a				endm 
# End of macro FORTH_DSP_POP
363a			 
363a			 
363a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
363a cd d4 1e			call macro_dsp_valuehl 
363d				endm 
# End of macro FORTH_DSP_VALUEHL
363d			 
363d					; one value on hl get other one back 
363d			 
363d e5					push hl 
363e			 
363e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
363e cd 8c 1f			call macro_forth_dsp_pop 
3641				endm 
# End of macro FORTH_DSP_POP
3641			 
3641 0e 00				ld c, FORTH_FALSE 
3643			 
3643 e1					pop hl 
3644 d1					pop de 
3645			 
3645 7b					ld a, e 
3646 bd					cp l 
3647			 
3647 20 06				jr nz, .eq_done 
3649			 
3649 7a					ld a, d 
364a bc					cp h 
364b			 
364b 20 02				jr nz, .eq_done 
364d			 
364d 0e 01				ld c, FORTH_TRUE 
364f					 
364f			 
364f			 
364f			.eq_done: 
364f			 
364f					; TODO push value back onto stack for another op etc 
364f			 
364f 26 00				ld h, 0 
3651 69					ld l, c 
3652					if DEBUG_FORTH_WORDS 
3652						DMARK "EQ1" 
3652 f5				push af  
3653 3a 67 36			ld a, (.dmark)  
3656 32 77 fb			ld (debug_mark),a  
3659 3a 68 36			ld a, (.dmark+1)  
365c 32 78 fb			ld (debug_mark+1),a  
365f 3a 69 36			ld a, (.dmark+2)  
3662 32 79 fb			ld (debug_mark+2),a  
3665 18 03			jr .pastdmark  
3667 ..			.dmark: db "EQ1"  
366a f1			.pastdmark: pop af  
366b			endm  
# End of macro DMARK
366b						CALLMONITOR 
366b cd 4d 17			call break_point_state  
366e				endm  
# End of macro CALLMONITOR
366e					endif 
366e cd dd 1c				call forth_push_numhl 
3671			 
3671					NEXTW 
3671 c3 46 20			jp macro_next 
3674				endm 
# End of macro NEXTW
3674			 
3674			 
3674			.ENDLOGIC: 
3674			; eof 
3674			 
3674			 
# End of file forth_words_logic.asm
3674			include "forth_words_maths.asm" 
3674			 
3674			; | ## Maths Words 
3674			 
3674			.PLUS:	 
3674				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3674 15				db WORD_SYS_CORE+1             
3675 b6 36			dw .NEG            
3677 02				db 1 + 1 
3678 .. 00			db "+",0              
367a				endm 
# End of macro CWHEAD
367a			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
367a					if DEBUG_FORTH_WORDS_KEY 
367a						DMARK "PLU" 
367a f5				push af  
367b 3a 8f 36			ld a, (.dmark)  
367e 32 77 fb			ld (debug_mark),a  
3681 3a 90 36			ld a, (.dmark+1)  
3684 32 78 fb			ld (debug_mark+1),a  
3687 3a 91 36			ld a, (.dmark+2)  
368a 32 79 fb			ld (debug_mark+2),a  
368d 18 03			jr .pastdmark  
368f ..			.dmark: db "PLU"  
3692 f1			.pastdmark: pop af  
3693			endm  
# End of macro DMARK
3693						CALLMONITOR 
3693 cd 4d 17			call break_point_state  
3696				endm  
# End of macro CALLMONITOR
3696					endif 
3696					; add top two values and push back result 
3696			 
3696					;for v5 FORTH_DSP_VALUE 
3696					FORTH_DSP 
3696 cd 9a 1e			call macro_forth_dsp 
3699				endm 
# End of macro FORTH_DSP
3699 7e					ld a,(hl)	; get type of value on TOS 
369a fe 02				cp DS_TYPE_INUM  
369c 28 03				jr z, .dot_inum 
369e			 
369e					NEXTW 
369e c3 46 20			jp macro_next 
36a1				endm 
# End of macro NEXTW
36a1			 
36a1			; float maths 
36a1			 
36a1				if FORTH_ENABLE_FLOATMATH 
36a1						inc hl      ; now at start of numeric as string 
36a1			 
36a1					if DEBUG_FORTH_MATHS 
36a1						DMARK "ADD" 
36a1				CALLMONITOR 
36a1					endif 
36a1			 
36a1					;ld ix, hl 
36a1					call CON 
36a1			 
36a1			 
36a1					push hl 
36a1					 
36a1					 
36a1			 
36a1						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
36a1			 
36a1					; get next number 
36a1			 
36a1						FORTH_DSP_VALUE 
36a1			 
36a1						inc hl      ; now at start of numeric as string 
36a1			 
36a1					;ld ix, hl 
36a1					call CON 
36a1			 
36a1					push hl 
36a1			 
36a1			 
36a1						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36a1			 
36a1						; TODO do add 
36a1			 
36a1						call IADD 
36a1			 
36a1						; TODO get result back as ascii 
36a1			 
36a1						; TODO push result  
36a1			 
36a1			 
36a1			 
36a1						jr .dot_done 
36a1				endif 
36a1			 
36a1			.dot_inum: 
36a1			 
36a1			 
36a1					if DEBUG_FORTH_DOT 
36a1						DMARK "+IT" 
36a1				CALLMONITOR 
36a1					endif 
36a1			 
36a1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36a1 cd d4 1e			call macro_dsp_valuehl 
36a4				endm 
# End of macro FORTH_DSP_VALUEHL
36a4			 
36a4				; TODO add floating point number detection 
36a4			 
36a4 e5					push hl 
36a5			 
36a5					; destroy value TOS 
36a5			 
36a5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36a5 cd 8c 1f			call macro_forth_dsp_pop 
36a8				endm 
# End of macro FORTH_DSP_POP
36a8			 
36a8			 
36a8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36a8 cd d4 1e			call macro_dsp_valuehl 
36ab				endm 
# End of macro FORTH_DSP_VALUEHL
36ab			 
36ab					; one value on hl get other one back 
36ab			 
36ab d1					pop de 
36ac			 
36ac					; do the add 
36ac			 
36ac 19					add hl,de 
36ad			 
36ad					; save it 
36ad			 
36ad			;		push hl	 
36ad			 
36ad					; 
36ad			 
36ad					; destroy value TOS 
36ad			 
36ad					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36ad cd 8c 1f			call macro_forth_dsp_pop 
36b0				endm 
# End of macro FORTH_DSP_POP
36b0			 
36b0					; TODO push value back onto stack for another op etc 
36b0			 
36b0			;		pop hl 
36b0			 
36b0			.dot_done: 
36b0 cd dd 1c				call forth_push_numhl 
36b3			 
36b3					NEXTW 
36b3 c3 46 20			jp macro_next 
36b6				endm 
# End of macro NEXTW
36b6			.NEG: 
36b6			 
36b6				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
36b6 17				db WORD_SYS_CORE+3             
36b7 f9 36			dw .DIV            
36b9 02				db 1 + 1 
36ba .. 00			db "-",0              
36bc				endm 
# End of macro CWHEAD
36bc			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
36bc					if DEBUG_FORTH_WORDS_KEY 
36bc						DMARK "SUB" 
36bc f5				push af  
36bd 3a d1 36			ld a, (.dmark)  
36c0 32 77 fb			ld (debug_mark),a  
36c3 3a d2 36			ld a, (.dmark+1)  
36c6 32 78 fb			ld (debug_mark+1),a  
36c9 3a d3 36			ld a, (.dmark+2)  
36cc 32 79 fb			ld (debug_mark+2),a  
36cf 18 03			jr .pastdmark  
36d1 ..			.dmark: db "SUB"  
36d4 f1			.pastdmark: pop af  
36d5			endm  
# End of macro DMARK
36d5						CALLMONITOR 
36d5 cd 4d 17			call break_point_state  
36d8				endm  
# End of macro CALLMONITOR
36d8					endif 
36d8			 
36d8			 
36d8				; TODO add floating point number detection 
36d8					; v5 FORTH_DSP_VALUE 
36d8					FORTH_DSP 
36d8 cd 9a 1e			call macro_forth_dsp 
36db				endm 
# End of macro FORTH_DSP
36db 7e					ld a,(hl)	; get type of value on TOS 
36dc fe 02				cp DS_TYPE_INUM  
36de 28 03				jr z, .neg_inum 
36e0			 
36e0					NEXTW 
36e0 c3 46 20			jp macro_next 
36e3				endm 
# End of macro NEXTW
36e3			 
36e3			; float maths 
36e3			 
36e3				if FORTH_ENABLE_FLOATMATH 
36e3					jr .neg_done 
36e3			 
36e3				endif 
36e3					 
36e3			 
36e3			.neg_inum: 
36e3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36e3 cd d4 1e			call macro_dsp_valuehl 
36e6				endm 
# End of macro FORTH_DSP_VALUEHL
36e6			 
36e6 e5					push hl 
36e7			 
36e7					; destroy value TOS 
36e7			 
36e7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36e7 cd 8c 1f			call macro_forth_dsp_pop 
36ea				endm 
# End of macro FORTH_DSP_POP
36ea			 
36ea			 
36ea					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36ea cd d4 1e			call macro_dsp_valuehl 
36ed				endm 
# End of macro FORTH_DSP_VALUEHL
36ed			 
36ed					; one value on hl get other one back 
36ed			 
36ed d1					pop de 
36ee			 
36ee					; do the sub 
36ee			;		ex de, hl 
36ee			 
36ee ed 52				sbc hl,de 
36f0			 
36f0					; save it 
36f0			 
36f0			;		push hl	 
36f0			 
36f0					; 
36f0			 
36f0					; destroy value TOS 
36f0			 
36f0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36f0 cd 8c 1f			call macro_forth_dsp_pop 
36f3				endm 
# End of macro FORTH_DSP_POP
36f3			 
36f3					; TODO push value back onto stack for another op etc 
36f3			 
36f3			;		pop hl 
36f3			 
36f3 cd dd 1c				call forth_push_numhl 
36f6			.neg_done: 
36f6			 
36f6					NEXTW 
36f6 c3 46 20			jp macro_next 
36f9				endm 
# End of macro NEXTW
36f9			.DIV: 
36f9				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
36f9 18				db WORD_SYS_CORE+4             
36fa 46 37			dw .MUL            
36fc 02				db 1 + 1 
36fd .. 00			db "/",0              
36ff				endm 
# End of macro CWHEAD
36ff			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
36ff					if DEBUG_FORTH_WORDS_KEY 
36ff						DMARK "DIV" 
36ff f5				push af  
3700 3a 14 37			ld a, (.dmark)  
3703 32 77 fb			ld (debug_mark),a  
3706 3a 15 37			ld a, (.dmark+1)  
3709 32 78 fb			ld (debug_mark+1),a  
370c 3a 16 37			ld a, (.dmark+2)  
370f 32 79 fb			ld (debug_mark+2),a  
3712 18 03			jr .pastdmark  
3714 ..			.dmark: db "DIV"  
3717 f1			.pastdmark: pop af  
3718			endm  
# End of macro DMARK
3718						CALLMONITOR 
3718 cd 4d 17			call break_point_state  
371b				endm  
# End of macro CALLMONITOR
371b					endif 
371b				; TODO add floating point number detection 
371b					; v5 FORTH_DSP_VALUE 
371b					FORTH_DSP 
371b cd 9a 1e			call macro_forth_dsp 
371e				endm 
# End of macro FORTH_DSP
371e 7e					ld a,(hl)	; get type of value on TOS 
371f fe 02				cp DS_TYPE_INUM  
3721 28 03				jr z, .div_inum 
3723			 
3723				if FORTH_ENABLE_FLOATMATH 
3723					jr .div_done 
3723			 
3723				endif 
3723					NEXTW 
3723 c3 46 20			jp macro_next 
3726				endm 
# End of macro NEXTW
3726			.div_inum: 
3726			 
3726					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3726 cd d4 1e			call macro_dsp_valuehl 
3729				endm 
# End of macro FORTH_DSP_VALUEHL
3729			 
3729 e5					push hl    ; to go to bc 
372a			 
372a					; destroy value TOS 
372a			 
372a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
372a cd 8c 1f			call macro_forth_dsp_pop 
372d				endm 
# End of macro FORTH_DSP_POP
372d			 
372d			 
372d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
372d cd d4 1e			call macro_dsp_valuehl 
3730				endm 
# End of macro FORTH_DSP_VALUEHL
3730			 
3730					; hl to go to de 
3730			 
3730 e5					push hl 
3731			 
3731 c1					pop bc 
3732 d1					pop de		 
3733			 
3733			 
3733					if DEBUG_FORTH_MATHS 
3733						DMARK "DIV" 
3733				CALLMONITOR 
3733					endif 
3733					; one value on hl but move to a get other one back 
3733			 
3733			        
3733 cd 66 0c			call Div16 
3736			 
3736			;	push af	 
3736 e5				push hl 
3737 c5				push bc 
3738			 
3738					if DEBUG_FORTH_MATHS 
3738						DMARK "DI1" 
3738				CALLMONITOR 
3738					endif 
3738			 
3738					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3738 cd 8c 1f			call macro_forth_dsp_pop 
373b				endm 
# End of macro FORTH_DSP_POP
373b			 
373b			 
373b			 
373b e1					pop hl    ; result 
373c			 
373c cd dd 1c				call forth_push_numhl 
373f			 
373f e1					pop hl    ; reminder 
3740			;		ld h,0 
3740			;		ld l,d 
3740			 
3740 cd dd 1c				call forth_push_numhl 
3743			.div_done: 
3743					NEXTW 
3743 c3 46 20			jp macro_next 
3746				endm 
# End of macro NEXTW
3746			.MUL: 
3746				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3746 19				db WORD_SYS_CORE+5             
3747 8b 37			dw .MIN            
3749 02				db 1 + 1 
374a .. 00			db "*",0              
374c				endm 
# End of macro CWHEAD
374c			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
374c				; TODO add floating point number detection 
374c					if DEBUG_FORTH_WORDS_KEY 
374c						DMARK "MUL" 
374c f5				push af  
374d 3a 61 37			ld a, (.dmark)  
3750 32 77 fb			ld (debug_mark),a  
3753 3a 62 37			ld a, (.dmark+1)  
3756 32 78 fb			ld (debug_mark+1),a  
3759 3a 63 37			ld a, (.dmark+2)  
375c 32 79 fb			ld (debug_mark+2),a  
375f 18 03			jr .pastdmark  
3761 ..			.dmark: db "MUL"  
3764 f1			.pastdmark: pop af  
3765			endm  
# End of macro DMARK
3765						CALLMONITOR 
3765 cd 4d 17			call break_point_state  
3768				endm  
# End of macro CALLMONITOR
3768					endif 
3768					FORTH_DSP 
3768 cd 9a 1e			call macro_forth_dsp 
376b				endm 
# End of macro FORTH_DSP
376b					; v5 FORTH_DSP_VALUE 
376b 7e					ld a,(hl)	; get type of value on TOS 
376c fe 02				cp DS_TYPE_INUM  
376e 28 03				jr z, .mul_inum 
3770			 
3770				if FORTH_ENABLE_FLOATMATH 
3770					jr .mul_done 
3770			 
3770				endif 
3770			 
3770					NEXTW 
3770 c3 46 20			jp macro_next 
3773				endm 
# End of macro NEXTW
3773			.mul_inum:	 
3773			 
3773					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3773 cd d4 1e			call macro_dsp_valuehl 
3776				endm 
# End of macro FORTH_DSP_VALUEHL
3776			 
3776 e5					push hl 
3777			 
3777					; destroy value TOS 
3777			 
3777					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3777 cd 8c 1f			call macro_forth_dsp_pop 
377a				endm 
# End of macro FORTH_DSP_POP
377a			 
377a			 
377a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
377a cd d4 1e			call macro_dsp_valuehl 
377d				endm 
# End of macro FORTH_DSP_VALUEHL
377d			 
377d					; one value on hl but move to a get other one back 
377d			 
377d 7d					ld a, l 
377e			 
377e d1					pop de 
377f			 
377f					; do the mull 
377f			;		ex de, hl 
377f			 
377f cd 8c 0c				call Mult16 
3782					; save it 
3782			 
3782			;		push hl	 
3782			 
3782					; 
3782			 
3782					; destroy value TOS 
3782			 
3782					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3782 cd 8c 1f			call macro_forth_dsp_pop 
3785				endm 
# End of macro FORTH_DSP_POP
3785			 
3785					; TODO push value back onto stack for another op etc 
3785			 
3785			;		pop hl 
3785			 
3785 cd dd 1c				call forth_push_numhl 
3788			 
3788			.mul_done: 
3788					NEXTW 
3788 c3 46 20			jp macro_next 
378b				endm 
# End of macro NEXTW
378b			 
378b			 
378b			 
378b			 
378b			.MIN: 
378b				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
378b 49				db WORD_SYS_CORE+53             
378c 0c 38			dw .MAX            
378e 04				db 3 + 1 
378f .. 00			db "MIN",0              
3793				endm 
# End of macro CWHEAD
3793			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3793					if DEBUG_FORTH_WORDS_KEY 
3793						DMARK "MIN" 
3793 f5				push af  
3794 3a a8 37			ld a, (.dmark)  
3797 32 77 fb			ld (debug_mark),a  
379a 3a a9 37			ld a, (.dmark+1)  
379d 32 78 fb			ld (debug_mark+1),a  
37a0 3a aa 37			ld a, (.dmark+2)  
37a3 32 79 fb			ld (debug_mark+2),a  
37a6 18 03			jr .pastdmark  
37a8 ..			.dmark: db "MIN"  
37ab f1			.pastdmark: pop af  
37ac			endm  
# End of macro DMARK
37ac						CALLMONITOR 
37ac cd 4d 17			call break_point_state  
37af				endm  
# End of macro CALLMONITOR
37af					endif 
37af					; get u2 
37af			 
37af					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37af cd d4 1e			call macro_dsp_valuehl 
37b2				endm 
# End of macro FORTH_DSP_VALUEHL
37b2			 
37b2 e5					push hl   ; u2 
37b3			 
37b3					; destroy value TOS 
37b3			 
37b3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37b3 cd 8c 1f			call macro_forth_dsp_pop 
37b6				endm 
# End of macro FORTH_DSP_POP
37b6			 
37b6					; get u1 
37b6			 
37b6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37b6 cd d4 1e			call macro_dsp_valuehl 
37b9				endm 
# End of macro FORTH_DSP_VALUEHL
37b9			 
37b9 e5					push hl  ; u1 
37ba			 
37ba					; destroy value TOS 
37ba			 
37ba					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37ba cd 8c 1f			call macro_forth_dsp_pop 
37bd				endm 
# End of macro FORTH_DSP_POP
37bd			 
37bd b7			 or a      ;clear carry flag 
37be e1			  pop hl    ; u1 
37bf d1			  pop de    ; u2 
37c0 e5				push hl   ; saved in case hl is lowest 
37c1 ed 52		  sbc hl,de 
37c3 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
37c5			 
37c5 e1				pop hl 
37c6					if DEBUG_FORTH_WORDS 
37c6						DMARK "MIN" 
37c6 f5				push af  
37c7 3a db 37			ld a, (.dmark)  
37ca 32 77 fb			ld (debug_mark),a  
37cd 3a dc 37			ld a, (.dmark+1)  
37d0 32 78 fb			ld (debug_mark+1),a  
37d3 3a dd 37			ld a, (.dmark+2)  
37d6 32 79 fb			ld (debug_mark+2),a  
37d9 18 03			jr .pastdmark  
37db ..			.dmark: db "MIN"  
37de f1			.pastdmark: pop af  
37df			endm  
# End of macro DMARK
37df						CALLMONITOR 
37df cd 4d 17			call break_point_state  
37e2				endm  
# End of macro CALLMONITOR
37e2					endif 
37e2 cd dd 1c				call forth_push_numhl 
37e5			 
37e5				       NEXTW 
37e5 c3 46 20			jp macro_next 
37e8				endm 
# End of macro NEXTW
37e8			 
37e8			.mincont:  
37e8 c1				pop bc   ; tidy up 
37e9 eb				ex de , hl  
37ea					if DEBUG_FORTH_WORDS 
37ea						DMARK "MI1" 
37ea f5				push af  
37eb 3a ff 37			ld a, (.dmark)  
37ee 32 77 fb			ld (debug_mark),a  
37f1 3a 00 38			ld a, (.dmark+1)  
37f4 32 78 fb			ld (debug_mark+1),a  
37f7 3a 01 38			ld a, (.dmark+2)  
37fa 32 79 fb			ld (debug_mark+2),a  
37fd 18 03			jr .pastdmark  
37ff ..			.dmark: db "MI1"  
3802 f1			.pastdmark: pop af  
3803			endm  
# End of macro DMARK
3803						CALLMONITOR 
3803 cd 4d 17			call break_point_state  
3806				endm  
# End of macro CALLMONITOR
3806					endif 
3806 cd dd 1c				call forth_push_numhl 
3809			 
3809				       NEXTW 
3809 c3 46 20			jp macro_next 
380c				endm 
# End of macro NEXTW
380c			.MAX: 
380c				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
380c 4a				db WORD_SYS_CORE+54             
380d 8d 38			dw .RND16            
380f 04				db 3 + 1 
3810 .. 00			db "MAX",0              
3814				endm 
# End of macro CWHEAD
3814			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3814					if DEBUG_FORTH_WORDS_KEY 
3814						DMARK "MAX" 
3814 f5				push af  
3815 3a 29 38			ld a, (.dmark)  
3818 32 77 fb			ld (debug_mark),a  
381b 3a 2a 38			ld a, (.dmark+1)  
381e 32 78 fb			ld (debug_mark+1),a  
3821 3a 2b 38			ld a, (.dmark+2)  
3824 32 79 fb			ld (debug_mark+2),a  
3827 18 03			jr .pastdmark  
3829 ..			.dmark: db "MAX"  
382c f1			.pastdmark: pop af  
382d			endm  
# End of macro DMARK
382d						CALLMONITOR 
382d cd 4d 17			call break_point_state  
3830				endm  
# End of macro CALLMONITOR
3830					endif 
3830					; get u2 
3830			 
3830					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3830 cd d4 1e			call macro_dsp_valuehl 
3833				endm 
# End of macro FORTH_DSP_VALUEHL
3833			 
3833 e5					push hl   ; u2 
3834			 
3834					; destroy value TOS 
3834			 
3834					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3834 cd 8c 1f			call macro_forth_dsp_pop 
3837				endm 
# End of macro FORTH_DSP_POP
3837			 
3837					; get u1 
3837			 
3837					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3837 cd d4 1e			call macro_dsp_valuehl 
383a				endm 
# End of macro FORTH_DSP_VALUEHL
383a			 
383a e5					push hl  ; u1 
383b			 
383b					; destroy value TOS 
383b			 
383b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
383b cd 8c 1f			call macro_forth_dsp_pop 
383e				endm 
# End of macro FORTH_DSP_POP
383e			 
383e b7			 or a      ;clear carry flag 
383f e1			  pop hl    ; u1 
3840 d1			  pop de    ; u2 
3841 e5				push hl   ; saved in case hl is lowest 
3842 ed 52		  sbc hl,de 
3844 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3846			 
3846 e1				pop hl 
3847					if DEBUG_FORTH_WORDS 
3847						DMARK "MAX" 
3847 f5				push af  
3848 3a 5c 38			ld a, (.dmark)  
384b 32 77 fb			ld (debug_mark),a  
384e 3a 5d 38			ld a, (.dmark+1)  
3851 32 78 fb			ld (debug_mark+1),a  
3854 3a 5e 38			ld a, (.dmark+2)  
3857 32 79 fb			ld (debug_mark+2),a  
385a 18 03			jr .pastdmark  
385c ..			.dmark: db "MAX"  
385f f1			.pastdmark: pop af  
3860			endm  
# End of macro DMARK
3860						CALLMONITOR 
3860 cd 4d 17			call break_point_state  
3863				endm  
# End of macro CALLMONITOR
3863					endif 
3863 cd dd 1c				call forth_push_numhl 
3866			 
3866				       NEXTW 
3866 c3 46 20			jp macro_next 
3869				endm 
# End of macro NEXTW
3869			 
3869			.maxcont:  
3869 c1				pop bc   ; tidy up 
386a eb				ex de , hl  
386b					if DEBUG_FORTH_WORDS 
386b						DMARK "MA1" 
386b f5				push af  
386c 3a 80 38			ld a, (.dmark)  
386f 32 77 fb			ld (debug_mark),a  
3872 3a 81 38			ld a, (.dmark+1)  
3875 32 78 fb			ld (debug_mark+1),a  
3878 3a 82 38			ld a, (.dmark+2)  
387b 32 79 fb			ld (debug_mark+2),a  
387e 18 03			jr .pastdmark  
3880 ..			.dmark: db "MA1"  
3883 f1			.pastdmark: pop af  
3884			endm  
# End of macro DMARK
3884						CALLMONITOR 
3884 cd 4d 17			call break_point_state  
3887				endm  
# End of macro CALLMONITOR
3887					endif 
3887 cd dd 1c				call forth_push_numhl 
388a				       NEXTW 
388a c3 46 20			jp macro_next 
388d				endm 
# End of macro NEXTW
388d			 
388d			.RND16: 
388d				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
388d 4e				db WORD_SYS_CORE+58             
388e bc 38			dw .RND8            
3890 06				db 5 + 1 
3891 .. 00			db "RND16",0              
3897				endm 
# End of macro CWHEAD
3897			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3897					if DEBUG_FORTH_WORDS_KEY 
3897						DMARK "R16" 
3897 f5				push af  
3898 3a ac 38			ld a, (.dmark)  
389b 32 77 fb			ld (debug_mark),a  
389e 3a ad 38			ld a, (.dmark+1)  
38a1 32 78 fb			ld (debug_mark+1),a  
38a4 3a ae 38			ld a, (.dmark+2)  
38a7 32 79 fb			ld (debug_mark+2),a  
38aa 18 03			jr .pastdmark  
38ac ..			.dmark: db "R16"  
38af f1			.pastdmark: pop af  
38b0			endm  
# End of macro DMARK
38b0						CALLMONITOR 
38b0 cd 4d 17			call break_point_state  
38b3				endm  
# End of macro CALLMONITOR
38b3					endif 
38b3 cd 30 0c				call prng16  
38b6 cd dd 1c				call forth_push_numhl 
38b9				       NEXTW 
38b9 c3 46 20			jp macro_next 
38bc				endm 
# End of macro NEXTW
38bc			.RND8: 
38bc				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
38bc 60				db WORD_SYS_CORE+76             
38bd f1 38			dw .RND            
38bf 05				db 4 + 1 
38c0 .. 00			db "RND8",0              
38c5				endm 
# End of macro CWHEAD
38c5			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
38c5					if DEBUG_FORTH_WORDS_KEY 
38c5						DMARK "RN8" 
38c5 f5				push af  
38c6 3a da 38			ld a, (.dmark)  
38c9 32 77 fb			ld (debug_mark),a  
38cc 3a db 38			ld a, (.dmark+1)  
38cf 32 78 fb			ld (debug_mark+1),a  
38d2 3a dc 38			ld a, (.dmark+2)  
38d5 32 79 fb			ld (debug_mark+2),a  
38d8 18 03			jr .pastdmark  
38da ..			.dmark: db "RN8"  
38dd f1			.pastdmark: pop af  
38de			endm  
# End of macro DMARK
38de						CALLMONITOR 
38de cd 4d 17			call break_point_state  
38e1				endm  
# End of macro CALLMONITOR
38e1					endif 
38e1 2a b8 f8				ld hl,(xrandc) 
38e4 23					inc hl 
38e5 cd 4a 0c				call xrnd 
38e8 6f					ld l,a	 
38e9 26 00				ld h,0 
38eb cd dd 1c				call forth_push_numhl 
38ee				       NEXTW 
38ee c3 46 20			jp macro_next 
38f1				endm 
# End of macro NEXTW
38f1			.RND: 
38f1				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
38f1 60				db WORD_SYS_CORE+76             
38f2 f7 39			dw .ENDMATHS            
38f4 04				db 3 + 1 
38f5 .. 00			db "RND",0              
38f9				endm 
# End of macro CWHEAD
38f9			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
38f9			 
38f9					if DEBUG_FORTH_WORDS_KEY 
38f9						DMARK "RND" 
38f9 f5				push af  
38fa 3a 0e 39			ld a, (.dmark)  
38fd 32 77 fb			ld (debug_mark),a  
3900 3a 0f 39			ld a, (.dmark+1)  
3903 32 78 fb			ld (debug_mark+1),a  
3906 3a 10 39			ld a, (.dmark+2)  
3909 32 79 fb			ld (debug_mark+2),a  
390c 18 03			jr .pastdmark  
390e ..			.dmark: db "RND"  
3911 f1			.pastdmark: pop af  
3912			endm  
# End of macro DMARK
3912						CALLMONITOR 
3912 cd 4d 17			call break_point_state  
3915				endm  
# End of macro CALLMONITOR
3915					endif 
3915					 
3915					FORTH_DSP_VALUEHL    ; upper range 
3915 cd d4 1e			call macro_dsp_valuehl 
3918				endm 
# End of macro FORTH_DSP_VALUEHL
3918			 
3918 22 bc f8				ld (LFSRSeed), hl	 
391b			 
391b					if DEBUG_FORTH_WORDS 
391b						DMARK "RN1" 
391b f5				push af  
391c 3a 30 39			ld a, (.dmark)  
391f 32 77 fb			ld (debug_mark),a  
3922 3a 31 39			ld a, (.dmark+1)  
3925 32 78 fb			ld (debug_mark+1),a  
3928 3a 32 39			ld a, (.dmark+2)  
392b 32 79 fb			ld (debug_mark+2),a  
392e 18 03			jr .pastdmark  
3930 ..			.dmark: db "RN1"  
3933 f1			.pastdmark: pop af  
3934			endm  
# End of macro DMARK
3934						CALLMONITOR 
3934 cd 4d 17			call break_point_state  
3937				endm  
# End of macro CALLMONITOR
3937					endif 
3937					FORTH_DSP_POP 
3937 cd 8c 1f			call macro_forth_dsp_pop 
393a				endm 
# End of macro FORTH_DSP_POP
393a			 
393a					FORTH_DSP_VALUEHL    ; low range 
393a cd d4 1e			call macro_dsp_valuehl 
393d				endm 
# End of macro FORTH_DSP_VALUEHL
393d			 
393d					if DEBUG_FORTH_WORDS 
393d						DMARK "RN2" 
393d f5				push af  
393e 3a 52 39			ld a, (.dmark)  
3941 32 77 fb			ld (debug_mark),a  
3944 3a 53 39			ld a, (.dmark+1)  
3947 32 78 fb			ld (debug_mark+1),a  
394a 3a 54 39			ld a, (.dmark+2)  
394d 32 79 fb			ld (debug_mark+2),a  
3950 18 03			jr .pastdmark  
3952 ..			.dmark: db "RN2"  
3955 f1			.pastdmark: pop af  
3956			endm  
# End of macro DMARK
3956						CALLMONITOR 
3956 cd 4d 17			call break_point_state  
3959				endm  
# End of macro CALLMONITOR
3959					endif 
3959 22 be f8				ld (LFSRSeed+2), hl 
395c			 
395c					FORTH_DSP_POP 
395c cd 8c 1f			call macro_forth_dsp_pop 
395f				endm 
# End of macro FORTH_DSP_POP
395f			 
395f e5					push hl 
3960			 
3960 e1			.inrange:	pop hl 
3961 cd 30 0c				call prng16  
3964					if DEBUG_FORTH_WORDS 
3964						DMARK "RN3" 
3964 f5				push af  
3965 3a 79 39			ld a, (.dmark)  
3968 32 77 fb			ld (debug_mark),a  
396b 3a 7a 39			ld a, (.dmark+1)  
396e 32 78 fb			ld (debug_mark+1),a  
3971 3a 7b 39			ld a, (.dmark+2)  
3974 32 79 fb			ld (debug_mark+2),a  
3977 18 03			jr .pastdmark  
3979 ..			.dmark: db "RN3"  
397c f1			.pastdmark: pop af  
397d			endm  
# End of macro DMARK
397d						CALLMONITOR 
397d cd 4d 17			call break_point_state  
3980				endm  
# End of macro CALLMONITOR
3980					endif 
3980					 
3980					; if the range is 8bit knock out the high byte 
3980			 
3980 ed 5b bc f8			ld de, (LFSRSeed)     ; check high level 
3984			 
3984 3e 00				ld a, 0 
3986 ba					cp d  
3987 20 1e				jr nz, .hirange 
3989 26 00				ld h, 0   ; knock it down to 8bit 
398b			 
398b					if DEBUG_FORTH_WORDS 
398b						DMARK "RNk" 
398b f5				push af  
398c 3a a0 39			ld a, (.dmark)  
398f 32 77 fb			ld (debug_mark),a  
3992 3a a1 39			ld a, (.dmark+1)  
3995 32 78 fb			ld (debug_mark+1),a  
3998 3a a2 39			ld a, (.dmark+2)  
399b 32 79 fb			ld (debug_mark+2),a  
399e 18 03			jr .pastdmark  
39a0 ..			.dmark: db "RNk"  
39a3 f1			.pastdmark: pop af  
39a4			endm  
# End of macro DMARK
39a4						CALLMONITOR 
39a4 cd 4d 17			call break_point_state  
39a7				endm  
# End of macro CALLMONITOR
39a7					endif 
39a7			.hirange:   
39a7 e5					push hl  
39a8 b7					or a  
39a9 ed 52		                sbc hl, de 
39ab			 
39ab					;call cmp16 
39ab			 
39ab 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
39ad e1					pop hl 
39ae e5					push hl 
39af			 
39af					if DEBUG_FORTH_WORDS 
39af						DMARK "RN4" 
39af f5				push af  
39b0 3a c4 39			ld a, (.dmark)  
39b3 32 77 fb			ld (debug_mark),a  
39b6 3a c5 39			ld a, (.dmark+1)  
39b9 32 78 fb			ld (debug_mark+1),a  
39bc 3a c6 39			ld a, (.dmark+2)  
39bf 32 79 fb			ld (debug_mark+2),a  
39c2 18 03			jr .pastdmark  
39c4 ..			.dmark: db "RN4"  
39c7 f1			.pastdmark: pop af  
39c8			endm  
# End of macro DMARK
39c8						CALLMONITOR 
39c8 cd 4d 17			call break_point_state  
39cb				endm  
# End of macro CALLMONITOR
39cb					endif 
39cb ed 5b be f8			ld de, (LFSRSeed+2)   ; check low range 
39cf					;call cmp16 
39cf				 
39cf b7					or a  
39d0 ed 52		                sbc hl, de 
39d2 38 8c				jr c, .inrange 
39d4			 
39d4 e1					pop hl 
39d5					 
39d5					if DEBUG_FORTH_WORDS 
39d5						DMARK "RNd" 
39d5 f5				push af  
39d6 3a ea 39			ld a, (.dmark)  
39d9 32 77 fb			ld (debug_mark),a  
39dc 3a eb 39			ld a, (.dmark+1)  
39df 32 78 fb			ld (debug_mark+1),a  
39e2 3a ec 39			ld a, (.dmark+2)  
39e5 32 79 fb			ld (debug_mark+2),a  
39e8 18 03			jr .pastdmark  
39ea ..			.dmark: db "RNd"  
39ed f1			.pastdmark: pop af  
39ee			endm  
# End of macro DMARK
39ee						CALLMONITOR 
39ee cd 4d 17			call break_point_state  
39f1				endm  
# End of macro CALLMONITOR
39f1					endif 
39f1			 
39f1			 
39f1 cd dd 1c				call forth_push_numhl 
39f4				       NEXTW 
39f4 c3 46 20			jp macro_next 
39f7				endm 
# End of macro NEXTW
39f7			 
39f7			.ENDMATHS: 
39f7			 
39f7			; eof 
39f7			 
# End of file forth_words_maths.asm
39f7			include "forth_words_display.asm" 
39f7			 
39f7			; | ## Display Words 
39f7			 
39f7			.ATP: 
39f7				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
39f7 62				db WORD_SYS_CORE+78             
39f8 6e 3a			dw .FB            
39fa 04				db 3 + 1 
39fb .. 00			db "AT?",0              
39ff				endm 
# End of macro CWHEAD
39ff			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
39ff					if DEBUG_FORTH_WORDS_KEY 
39ff						DMARK "AT?" 
39ff f5				push af  
3a00 3a 14 3a			ld a, (.dmark)  
3a03 32 77 fb			ld (debug_mark),a  
3a06 3a 15 3a			ld a, (.dmark+1)  
3a09 32 78 fb			ld (debug_mark+1),a  
3a0c 3a 16 3a			ld a, (.dmark+2)  
3a0f 32 79 fb			ld (debug_mark+2),a  
3a12 18 03			jr .pastdmark  
3a14 ..			.dmark: db "AT?"  
3a17 f1			.pastdmark: pop af  
3a18			endm  
# End of macro DMARK
3a18						CALLMONITOR 
3a18 cd 4d 17			call break_point_state  
3a1b				endm  
# End of macro CALLMONITOR
3a1b					endif 
3a1b 3a 46 f8				ld a, (f_cursor_ptr) 
3a1e			 
3a1e			if DEBUG_FORTH_WORDS 
3a1e				DMARK "AT?" 
3a1e f5				push af  
3a1f 3a 33 3a			ld a, (.dmark)  
3a22 32 77 fb			ld (debug_mark),a  
3a25 3a 34 3a			ld a, (.dmark+1)  
3a28 32 78 fb			ld (debug_mark+1),a  
3a2b 3a 35 3a			ld a, (.dmark+2)  
3a2e 32 79 fb			ld (debug_mark+2),a  
3a31 18 03			jr .pastdmark  
3a33 ..			.dmark: db "AT?"  
3a36 f1			.pastdmark: pop af  
3a37			endm  
# End of macro DMARK
3a37				CALLMONITOR 
3a37 cd 4d 17			call break_point_state  
3a3a				endm  
# End of macro CALLMONITOR
3a3a			endif	 
3a3a					; count the number of rows 
3a3a			 
3a3a 06 00				ld b, 0 
3a3c 4f			.atpr:		ld c, a    ; save in case we go below zero 
3a3d d6 28				sub display_cols 
3a3f f2 45 3a				jp p, .atprunder 
3a42 04					inc b 
3a43 18 f7				jr .atpr 
3a45			.atprunder:	 
3a45			if DEBUG_FORTH_WORDS 
3a45				DMARK "A?2" 
3a45 f5				push af  
3a46 3a 5a 3a			ld a, (.dmark)  
3a49 32 77 fb			ld (debug_mark),a  
3a4c 3a 5b 3a			ld a, (.dmark+1)  
3a4f 32 78 fb			ld (debug_mark+1),a  
3a52 3a 5c 3a			ld a, (.dmark+2)  
3a55 32 79 fb			ld (debug_mark+2),a  
3a58 18 03			jr .pastdmark  
3a5a ..			.dmark: db "A?2"  
3a5d f1			.pastdmark: pop af  
3a5e			endm  
# End of macro DMARK
3a5e				CALLMONITOR 
3a5e cd 4d 17			call break_point_state  
3a61				endm  
# End of macro CALLMONITOR
3a61			endif	 
3a61 26 00				ld h, 0 
3a63 69					ld l, c 
3a64 cd dd 1c				call forth_push_numhl 
3a67 68					ld l, b  
3a68 cd dd 1c				call forth_push_numhl 
3a6b			 
3a6b			 
3a6b				NEXTW 
3a6b c3 46 20			jp macro_next 
3a6e				endm 
# End of macro NEXTW
3a6e			 
3a6e			.FB: 
3a6e				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3a6e 1b				db WORD_SYS_CORE+7             
3a6f bc 3a			dw .EMIT            
3a71 03				db 2 + 1 
3a72 .. 00			db "FB",0              
3a75				endm 
# End of macro CWHEAD
3a75			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3a75			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3a75			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3a75			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3a75					if DEBUG_FORTH_WORDS_KEY 
3a75						DMARK "FB." 
3a75 f5				push af  
3a76 3a 8a 3a			ld a, (.dmark)  
3a79 32 77 fb			ld (debug_mark),a  
3a7c 3a 8b 3a			ld a, (.dmark+1)  
3a7f 32 78 fb			ld (debug_mark+1),a  
3a82 3a 8c 3a			ld a, (.dmark+2)  
3a85 32 79 fb			ld (debug_mark+2),a  
3a88 18 03			jr .pastdmark  
3a8a ..			.dmark: db "FB."  
3a8d f1			.pastdmark: pop af  
3a8e			endm  
# End of macro DMARK
3a8e						CALLMONITOR 
3a8e cd 4d 17			call break_point_state  
3a91				endm  
# End of macro CALLMONITOR
3a91					endif 
3a91			 
3a91					FORTH_DSP_VALUEHL 
3a91 cd d4 1e			call macro_dsp_valuehl 
3a94				endm 
# End of macro FORTH_DSP_VALUEHL
3a94			 
3a94 7d					ld a, l 
3a95 fe 01				cp 1 
3a97 20 05				jr nz, .fbn1 
3a99 21 1c fa				ld hl, display_fb1 
3a9c 18 15				jr .fbset 
3a9e fe 02		.fbn1:		cp 2 
3aa0 20 05				jr nz, .fbn2 
3aa2 21 da f8				ld hl, display_fb2 
3aa5 18 0c				jr .fbset 
3aa7 fe 03		.fbn2:		cp 3 
3aa9 20 05				jr nz, .fbn3 
3aab 21 7b f9				ld hl, display_fb3 
3aae 18 03				jr .fbset 
3ab0			.fbn3:		 ; if invalid number select first 
3ab0 21 1c fa				ld hl, display_fb1 
3ab3 22 d8 f8		.fbset:		ld (display_fb_active), hl 
3ab6			 
3ab6					FORTH_DSP_POP 
3ab6 cd 8c 1f			call macro_forth_dsp_pop 
3ab9				endm 
# End of macro FORTH_DSP_POP
3ab9			 
3ab9					NEXTW 
3ab9 c3 46 20			jp macro_next 
3abc				endm 
# End of macro NEXTW
3abc			 
3abc			 
3abc			.EMIT: 
3abc				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3abc 1b				db WORD_SYS_CORE+7             
3abd 0d 3b			dw .DOTH            
3abf 05				db 4 + 1 
3ac0 .. 00			db "EMIT",0              
3ac5				endm 
# End of macro CWHEAD
3ac5			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3ac5					; get value off TOS and display it 
3ac5			 
3ac5					if DEBUG_FORTH_WORDS_KEY 
3ac5						DMARK "EMT" 
3ac5 f5				push af  
3ac6 3a da 3a			ld a, (.dmark)  
3ac9 32 77 fb			ld (debug_mark),a  
3acc 3a db 3a			ld a, (.dmark+1)  
3acf 32 78 fb			ld (debug_mark+1),a  
3ad2 3a dc 3a			ld a, (.dmark+2)  
3ad5 32 79 fb			ld (debug_mark+2),a  
3ad8 18 03			jr .pastdmark  
3ada ..			.dmark: db "EMT"  
3add f1			.pastdmark: pop af  
3ade			endm  
# End of macro DMARK
3ade						CALLMONITOR 
3ade cd 4d 17			call break_point_state  
3ae1				endm  
# End of macro CALLMONITOR
3ae1					endif 
3ae1			 
3ae1					FORTH_DSP_VALUEHL 
3ae1 cd d4 1e			call macro_dsp_valuehl 
3ae4				endm 
# End of macro FORTH_DSP_VALUEHL
3ae4			 
3ae4 7d					ld a,l 
3ae5			 
3ae5					; TODO write to display 
3ae5			 
3ae5 32 1b f0				ld (os_input), a 
3ae8 3e 00				ld a, 0 
3aea 32 1c f0				ld (os_input+1), a 
3aed					 
3aed 3a 46 f8				ld a, (f_cursor_ptr) 
3af0 11 1b f0				ld de, os_input 
3af3 cd e8 0a				call str_at_display 
3af6			 
3af6			 
3af6 3a 24 f8				ld a,(cli_autodisplay) 
3af9 fe 00				cp 0 
3afb 28 03				jr z, .enoupdate 
3afd cd f8 0a						call update_display 
3b00					.enoupdate: 
3b00			 
3b00 3a 46 f8				ld a, (f_cursor_ptr) 
3b03 3c					inc a 
3b04 32 46 f8				ld (f_cursor_ptr), a   ; save new pos 
3b07			 
3b07			 
3b07					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b07 cd 8c 1f			call macro_forth_dsp_pop 
3b0a				endm 
# End of macro FORTH_DSP_POP
3b0a			  
3b0a			 
3b0a					NEXTW 
3b0a c3 46 20			jp macro_next 
3b0d				endm 
# End of macro NEXTW
3b0d			.DOTH: 
3b0d				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3b0d 1c				db WORD_SYS_CORE+8             
3b0e 3d 3b			dw .DOTF            
3b10 03				db 2 + 1 
3b11 .. 00			db ".-",0              
3b14				endm 
# End of macro CWHEAD
3b14			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3b14					; get value off TOS and display it 
3b14					if DEBUG_FORTH_WORDS_KEY 
3b14						DMARK "DTD" 
3b14 f5				push af  
3b15 3a 29 3b			ld a, (.dmark)  
3b18 32 77 fb			ld (debug_mark),a  
3b1b 3a 2a 3b			ld a, (.dmark+1)  
3b1e 32 78 fb			ld (debug_mark+1),a  
3b21 3a 2b 3b			ld a, (.dmark+2)  
3b24 32 79 fb			ld (debug_mark+2),a  
3b27 18 03			jr .pastdmark  
3b29 ..			.dmark: db "DTD"  
3b2c f1			.pastdmark: pop af  
3b2d			endm  
# End of macro DMARK
3b2d						CALLMONITOR 
3b2d cd 4d 17			call break_point_state  
3b30				endm  
# End of macro CALLMONITOR
3b30					endif 
3b30 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3b32 3e 00			ld a, 0 
3b34 32 25 f8			ld (cli_mvdot), a 
3b37 c3 94 3b			jp .dotgo 
3b3a				NEXTW 
3b3a c3 46 20			jp macro_next 
3b3d				endm 
# End of macro NEXTW
3b3d			.DOTF: 
3b3d				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3b3d 1c				db WORD_SYS_CORE+8             
3b3e 6b 3b			dw .DOT            
3b40 03				db 2 + 1 
3b41 .. 00			db ".>",0              
3b44				endm 
# End of macro CWHEAD
3b44			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3b44					; get value off TOS and display it 
3b44			        ; TODO BUG adds extra spaces 
3b44			        ; TODO BUG handle numerics? 
3b44					if DEBUG_FORTH_WORDS_KEY 
3b44						DMARK "DTC" 
3b44 f5				push af  
3b45 3a 59 3b			ld a, (.dmark)  
3b48 32 77 fb			ld (debug_mark),a  
3b4b 3a 5a 3b			ld a, (.dmark+1)  
3b4e 32 78 fb			ld (debug_mark+1),a  
3b51 3a 5b 3b			ld a, (.dmark+2)  
3b54 32 79 fb			ld (debug_mark+2),a  
3b57 18 03			jr .pastdmark  
3b59 ..			.dmark: db "DTC"  
3b5c f1			.pastdmark: pop af  
3b5d			endm  
# End of macro DMARK
3b5d						CALLMONITOR 
3b5d cd 4d 17			call break_point_state  
3b60				endm  
# End of macro CALLMONITOR
3b60					endif 
3b60 3e 01			ld a, 1 
3b62 32 25 f8			ld (cli_mvdot), a 
3b65 c3 94 3b			jp .dotgo 
3b68				NEXTW 
3b68 c3 46 20			jp macro_next 
3b6b				endm 
# End of macro NEXTW
3b6b			 
3b6b			.DOT: 
3b6b				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3b6b 1c				db WORD_SYS_CORE+8             
3b6c f7 3b			dw .CLS            
3b6e 02				db 1 + 1 
3b6f .. 00			db ".",0              
3b71				endm 
# End of macro CWHEAD
3b71			        ; | . ( u -- ) Display TOS | DONE 
3b71					; get value off TOS and display it 
3b71			 
3b71					if DEBUG_FORTH_WORDS_KEY 
3b71						DMARK "DOT" 
3b71 f5				push af  
3b72 3a 86 3b			ld a, (.dmark)  
3b75 32 77 fb			ld (debug_mark),a  
3b78 3a 87 3b			ld a, (.dmark+1)  
3b7b 32 78 fb			ld (debug_mark+1),a  
3b7e 3a 88 3b			ld a, (.dmark+2)  
3b81 32 79 fb			ld (debug_mark+2),a  
3b84 18 03			jr .pastdmark  
3b86 ..			.dmark: db "DOT"  
3b89 f1			.pastdmark: pop af  
3b8a			endm  
# End of macro DMARK
3b8a						CALLMONITOR 
3b8a cd 4d 17			call break_point_state  
3b8d				endm  
# End of macro CALLMONITOR
3b8d					endif 
3b8d 3e 00			ld a, 0 
3b8f 32 25 f8			ld (cli_mvdot), a 
3b92 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3b94				 
3b94			 
3b94			.dotgo: 
3b94			 
3b94			; move up type to on stack for parserv5 
3b94					FORTH_DSP 
3b94 cd 9a 1e			call macro_forth_dsp 
3b97				endm 
# End of macro FORTH_DSP
3b97				;FORTH_DSP_VALUE  
3b97			 
3b97			if DEBUG_FORTH_DOT 
3b97				DMARK "DOT" 
3b97				CALLMONITOR 
3b97			endif	 
3b97			;		.print: 
3b97			 
3b97 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3b98 23				inc hl   ; position to the actual value 
3b99 fe 01			cp DS_TYPE_STR 
3b9b 20 06			jr nz, .dotnum1  
3b9d			 
3b9d			; display string 
3b9d				FORTH_DSP_VALUE  
3b9d cd bd 1e			call macro_forth_dsp_value 
3ba0				endm 
# End of macro FORTH_DSP_VALUE
3ba0 eb				ex de,hl 
3ba1 18 11			jr .dotwrite 
3ba3			 
3ba3			.dotnum1: 
3ba3 fe 02			cp DS_TYPE_INUM 
3ba5 20 0c			jr nz, .dotflot 
3ba7			 
3ba7			 
3ba7			; display number 
3ba7			 
3ba7			;	push hl 
3ba7			;	call clear_display 
3ba7			;	pop hl 
3ba7			 
3ba7 5e				ld e, (hl) 
3ba8 23				inc hl 
3ba9 56				ld d, (hl) 
3baa 21 1d ee			ld hl, scratch 
3bad			if DEBUG_FORTH_DOT 
3bad				DMARK "DT1" 
3bad				CALLMONITOR 
3bad			endif	 
3bad			 
3bad cd 16 11			call uitoa_16 
3bb0 eb				ex de,hl 
3bb1			 
3bb1			if DEBUG_FORTH_DOT 
3bb1				DMARK "DT2" 
3bb1				CALLMONITOR 
3bb1			endif	 
3bb1			 
3bb1			;	ld de, os_word_scratch 
3bb1 18 01			jr .dotwrite 
3bb3			 
3bb3 00			.dotflot:   nop 
3bb4			; TODO print floating point number 
3bb4			 
3bb4			.dotwrite:		 
3bb4			 
3bb4					; if c is set then set all '-' to spaces 
3bb4					; need to also take into account .>  
3bb4			 
3bb4 3e 01				ld a, 1 
3bb6 b9					cp c 
3bb7 20 13				jr nz, .nodashswap 
3bb9			 
3bb9					; DE has the string to write, working with HL 
3bb9			 
3bb9 06 ff				ld b, 255 
3bbb d5					push de 
3bbc e1					pop hl 
3bbd			 
3bbd			if DEBUG_FORTH_DOT 
3bbd				DMARK "DT-" 
3bbd				CALLMONITOR 
3bbd			endif	 
3bbd 7e			.dashscan:	ld a, (hl) 
3bbe fe 00				cp 0 
3bc0 28 0a				jr z, .nodashswap 
3bc2 fe 2d				cp '-' 
3bc4 20 03				jr nz, .dashskip 
3bc6 3e 20				ld a, ' ' 
3bc8 77					ld (hl), a 
3bc9 23			.dashskip:	inc hl 
3bca			if DEBUG_FORTH_DOT 
3bca				DMARK "D-2" 
3bca				CALLMONITOR 
3bca			endif	 
3bca 10 f1				djnz .dashscan 
3bcc			 
3bcc			if DEBUG_FORTH_DOT 
3bcc				DMARK "D-1" 
3bcc				CALLMONITOR 
3bcc			endif	 
3bcc			 
3bcc			.nodashswap: 
3bcc			 
3bcc e5					push hl   ; save string start in case we need to advance print 
3bcd			 
3bcd 3a 46 f8				ld a, (f_cursor_ptr) 
3bd0 cd e8 0a				call str_at_display 
3bd3 3a 24 f8				ld a,(cli_autodisplay) 
3bd6 fe 00				cp 0 
3bd8 28 03				jr z, .noupdate 
3bda cd f8 0a						call update_display 
3bdd					.noupdate: 
3bdd			 
3bdd			 
3bdd					; see if we need to advance the print position 
3bdd			 
3bdd e1					pop hl   ; get back string 
3bde			 
3bde 3a 25 f8				ld a, (cli_mvdot) 
3be1			if DEBUG_FORTH_DOT 
3be1					ld e,a 
3be1				DMARK "D>1" 
3be1				CALLMONITOR 
3be1			endif	 
3be1 fe 00				cp 0 
3be3 28 0c				jr z, .noadv 
3be5					; yes, lets advance the print position 
3be5 3e 00				ld a, 0 
3be7 cd 72 11				call strlent 
3bea 3a 46 f8				ld a, (f_cursor_ptr) 
3bed 85					add a,l 
3bee					;call addatohl 
3bee					;ld a, l 
3bee 32 46 f8				ld (f_cursor_ptr), a   ; save new pos 
3bf1			 
3bf1			if DEBUG_FORTH_DOT 
3bf1				DMARK "D->" 
3bf1				CALLMONITOR 
3bf1			endif	 
3bf1			 
3bf1			.noadv:	 
3bf1			 
3bf1					if DEBUG_FORTH_DOT_WAIT 
3bf1							call next_page_prompt 
3bf1					endif	 
3bf1			; TODO this pop off the stack causes a crash. i dont know why 
3bf1			 
3bf1			 
3bf1			if DEBUG_FORTH_DOT 
3bf1				DMARK "DTh" 
3bf1				CALLMONITOR 
3bf1			endif	 
3bf1			 
3bf1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bf1 cd 8c 1f			call macro_forth_dsp_pop 
3bf4				endm 
# End of macro FORTH_DSP_POP
3bf4			 
3bf4			if DEBUG_FORTH_DOT 
3bf4				DMARK "DTi" 
3bf4				CALLMONITOR 
3bf4			endif	 
3bf4			 
3bf4			 
3bf4					NEXTW 
3bf4 c3 46 20			jp macro_next 
3bf7				endm 
# End of macro NEXTW
3bf7			 
3bf7			.CLS: 
3bf7				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3bf7 35				db WORD_SYS_CORE+33             
3bf8 24 3c			dw .DRAW            
3bfa 04				db 3 + 1 
3bfb .. 00			db "CLS",0              
3bff				endm 
# End of macro CWHEAD
3bff			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3bff					if DEBUG_FORTH_WORDS_KEY 
3bff						DMARK "CLS" 
3bff f5				push af  
3c00 3a 14 3c			ld a, (.dmark)  
3c03 32 77 fb			ld (debug_mark),a  
3c06 3a 15 3c			ld a, (.dmark+1)  
3c09 32 78 fb			ld (debug_mark+1),a  
3c0c 3a 16 3c			ld a, (.dmark+2)  
3c0f 32 79 fb			ld (debug_mark+2),a  
3c12 18 03			jr .pastdmark  
3c14 ..			.dmark: db "CLS"  
3c17 f1			.pastdmark: pop af  
3c18			endm  
# End of macro DMARK
3c18						CALLMONITOR 
3c18 cd 4d 17			call break_point_state  
3c1b				endm  
# End of macro CALLMONITOR
3c1b					endif 
3c1b cd d5 0a				call clear_display 
3c1e c3 32 3d				jp .home		; and home cursor 
3c21					NEXTW 
3c21 c3 46 20			jp macro_next 
3c24				endm 
# End of macro NEXTW
3c24			 
3c24			.DRAW: 
3c24				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3c24 36				db WORD_SYS_CORE+34             
3c25 4f 3c			dw .DUMP            
3c27 05				db 4 + 1 
3c28 .. 00			db "DRAW",0              
3c2d				endm 
# End of macro CWHEAD
3c2d			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3c2d					if DEBUG_FORTH_WORDS_KEY 
3c2d						DMARK "DRW" 
3c2d f5				push af  
3c2e 3a 42 3c			ld a, (.dmark)  
3c31 32 77 fb			ld (debug_mark),a  
3c34 3a 43 3c			ld a, (.dmark+1)  
3c37 32 78 fb			ld (debug_mark+1),a  
3c3a 3a 44 3c			ld a, (.dmark+2)  
3c3d 32 79 fb			ld (debug_mark+2),a  
3c40 18 03			jr .pastdmark  
3c42 ..			.dmark: db "DRW"  
3c45 f1			.pastdmark: pop af  
3c46			endm  
# End of macro DMARK
3c46						CALLMONITOR 
3c46 cd 4d 17			call break_point_state  
3c49				endm  
# End of macro CALLMONITOR
3c49					endif 
3c49 cd f8 0a				call update_display 
3c4c					NEXTW 
3c4c c3 46 20			jp macro_next 
3c4f				endm 
# End of macro NEXTW
3c4f			 
3c4f			.DUMP: 
3c4f				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3c4f 37				db WORD_SYS_CORE+35             
3c50 87 3c			dw .CDUMP            
3c52 05				db 4 + 1 
3c53 .. 00			db "DUMP",0              
3c58				endm 
# End of macro CWHEAD
3c58			; | DUMP ( x -- ) With address x display dump   | DONE 
3c58			; TODO pop address to use off of the stack 
3c58					if DEBUG_FORTH_WORDS_KEY 
3c58						DMARK "DUM" 
3c58 f5				push af  
3c59 3a 6d 3c			ld a, (.dmark)  
3c5c 32 77 fb			ld (debug_mark),a  
3c5f 3a 6e 3c			ld a, (.dmark+1)  
3c62 32 78 fb			ld (debug_mark+1),a  
3c65 3a 6f 3c			ld a, (.dmark+2)  
3c68 32 79 fb			ld (debug_mark+2),a  
3c6b 18 03			jr .pastdmark  
3c6d ..			.dmark: db "DUM"  
3c70 f1			.pastdmark: pop af  
3c71			endm  
# End of macro DMARK
3c71						CALLMONITOR 
3c71 cd 4d 17			call break_point_state  
3c74				endm  
# End of macro CALLMONITOR
3c74					endif 
3c74 cd d5 0a				call clear_display 
3c77			 
3c77					; get address 
3c77			 
3c77					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c77 cd d4 1e			call macro_dsp_valuehl 
3c7a				endm 
# End of macro FORTH_DSP_VALUEHL
3c7a				 
3c7a					; save it for cdump 
3c7a			 
3c7a 22 40 f1				ld (os_cur_ptr),hl 
3c7d			 
3c7d					; destroy value TOS 
3c7d			 
3c7d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c7d cd 8c 1f			call macro_forth_dsp_pop 
3c80				endm 
# End of macro FORTH_DSP_POP
3c80			 
3c80 cd 5d 1b				call dumpcont	; skip old style of param parsing	 
3c83 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3c84					NEXTW 
3c84 c3 46 20			jp macro_next 
3c87				endm 
# End of macro NEXTW
3c87			.CDUMP: 
3c87				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3c87 38				db WORD_SYS_CORE+36             
3c88 b7 3c			dw .DAT            
3c8a 06				db 5 + 1 
3c8b .. 00			db "CDUMP",0              
3c91				endm 
# End of macro CWHEAD
3c91			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3c91					if DEBUG_FORTH_WORDS_KEY 
3c91						DMARK "CDP" 
3c91 f5				push af  
3c92 3a a6 3c			ld a, (.dmark)  
3c95 32 77 fb			ld (debug_mark),a  
3c98 3a a7 3c			ld a, (.dmark+1)  
3c9b 32 78 fb			ld (debug_mark+1),a  
3c9e 3a a8 3c			ld a, (.dmark+2)  
3ca1 32 79 fb			ld (debug_mark+2),a  
3ca4 18 03			jr .pastdmark  
3ca6 ..			.dmark: db "CDP"  
3ca9 f1			.pastdmark: pop af  
3caa			endm  
# End of macro DMARK
3caa						CALLMONITOR 
3caa cd 4d 17			call break_point_state  
3cad				endm  
# End of macro CALLMONITOR
3cad					endif 
3cad cd d5 0a				call clear_display 
3cb0 cd 5d 1b				call dumpcont	 
3cb3 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3cb4					NEXTW 
3cb4 c3 46 20			jp macro_next 
3cb7				endm 
# End of macro NEXTW
3cb7			 
3cb7			 
3cb7			 
3cb7			 
3cb7			.DAT: 
3cb7				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3cb7 3d				db WORD_SYS_CORE+41             
3cb8 0d 3d			dw .HOME            
3cba 03				db 2 + 1 
3cbb .. 00			db "AT",0              
3cbe				endm 
# End of macro CWHEAD
3cbe			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3cbe					if DEBUG_FORTH_WORDS_KEY 
3cbe						DMARK "AT." 
3cbe f5				push af  
3cbf 3a d3 3c			ld a, (.dmark)  
3cc2 32 77 fb			ld (debug_mark),a  
3cc5 3a d4 3c			ld a, (.dmark+1)  
3cc8 32 78 fb			ld (debug_mark+1),a  
3ccb 3a d5 3c			ld a, (.dmark+2)  
3cce 32 79 fb			ld (debug_mark+2),a  
3cd1 18 03			jr .pastdmark  
3cd3 ..			.dmark: db "AT."  
3cd6 f1			.pastdmark: pop af  
3cd7			endm  
# End of macro DMARK
3cd7						CALLMONITOR 
3cd7 cd 4d 17			call break_point_state  
3cda				endm  
# End of macro CALLMONITOR
3cda					endif 
3cda					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3cda cd d4 1e			call macro_dsp_valuehl 
3cdd				endm 
# End of macro FORTH_DSP_VALUEHL
3cdd			 
3cdd			 
3cdd					; TODO save cursor row 
3cdd 7d					ld a,l 
3cde fe 02				cp 2 
3ce0 20 04				jr nz, .crow3 
3ce2 3e 28				ld a, display_row_2 
3ce4 18 12				jr .ccol1 
3ce6 fe 03		.crow3:		cp 3 
3ce8 20 04				jr nz, .crow4 
3cea 3e 50				ld a, display_row_3 
3cec 18 0a				jr .ccol1 
3cee fe 04		.crow4:		cp 4 
3cf0 20 04				jr nz, .crow1 
3cf2 3e 78				ld a, display_row_4 
3cf4 18 02				jr .ccol1 
3cf6 3e 00		.crow1:		ld a,display_row_1 
3cf8 f5			.ccol1:		push af			; got row offset 
3cf9 6f					ld l,a 
3cfa 26 00				ld h,0 
3cfc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cfc cd 8c 1f			call macro_forth_dsp_pop 
3cff				endm 
# End of macro FORTH_DSP_POP
3cff					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3cff cd d4 1e			call macro_dsp_valuehl 
3d02				endm 
# End of macro FORTH_DSP_VALUEHL
3d02					; TODO save cursor col 
3d02 f1					pop af 
3d03 85					add l		; add col offset 
3d04 32 46 f8				ld (f_cursor_ptr), a 
3d07					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d07 cd 8c 1f			call macro_forth_dsp_pop 
3d0a				endm 
# End of macro FORTH_DSP_POP
3d0a			 
3d0a					; calculate  
3d0a			 
3d0a					NEXTW 
3d0a c3 46 20			jp macro_next 
3d0d				endm 
# End of macro NEXTW
3d0d			 
3d0d			 
3d0d			.HOME: 
3d0d				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3d0d 41				db WORD_SYS_CORE+45             
3d0e 3a 3d			dw .SPACE            
3d10 05				db 4 + 1 
3d11 .. 00			db "HOME",0              
3d16				endm 
# End of macro CWHEAD
3d16			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3d16					if DEBUG_FORTH_WORDS_KEY 
3d16						DMARK "HOM" 
3d16 f5				push af  
3d17 3a 2b 3d			ld a, (.dmark)  
3d1a 32 77 fb			ld (debug_mark),a  
3d1d 3a 2c 3d			ld a, (.dmark+1)  
3d20 32 78 fb			ld (debug_mark+1),a  
3d23 3a 2d 3d			ld a, (.dmark+2)  
3d26 32 79 fb			ld (debug_mark+2),a  
3d29 18 03			jr .pastdmark  
3d2b ..			.dmark: db "HOM"  
3d2e f1			.pastdmark: pop af  
3d2f			endm  
# End of macro DMARK
3d2f						CALLMONITOR 
3d2f cd 4d 17			call break_point_state  
3d32				endm  
# End of macro CALLMONITOR
3d32					endif 
3d32 3e 00		.home:		ld a, 0		; and home cursor 
3d34 32 46 f8				ld (f_cursor_ptr), a 
3d37					NEXTW 
3d37 c3 46 20			jp macro_next 
3d3a				endm 
# End of macro NEXTW
3d3a			 
3d3a			 
3d3a			.SPACE: 
3d3a				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3d3a 46				db WORD_SYS_CORE+50             
3d3b 68 3d			dw .SPACES            
3d3d 03				db 2 + 1 
3d3e .. 00			db "BL",0              
3d41				endm 
# End of macro CWHEAD
3d41			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3d41					if DEBUG_FORTH_WORDS_KEY 
3d41						DMARK "BL." 
3d41 f5				push af  
3d42 3a 56 3d			ld a, (.dmark)  
3d45 32 77 fb			ld (debug_mark),a  
3d48 3a 57 3d			ld a, (.dmark+1)  
3d4b 32 78 fb			ld (debug_mark+1),a  
3d4e 3a 58 3d			ld a, (.dmark+2)  
3d51 32 79 fb			ld (debug_mark+2),a  
3d54 18 03			jr .pastdmark  
3d56 ..			.dmark: db "BL."  
3d59 f1			.pastdmark: pop af  
3d5a			endm  
# End of macro DMARK
3d5a						CALLMONITOR 
3d5a cd 4d 17			call break_point_state  
3d5d				endm  
# End of macro CALLMONITOR
3d5d					endif 
3d5d 21 66 3d				ld hl, .blstr 
3d60 cd 4b 1d				call forth_push_str 
3d63					 
3d63				       NEXTW 
3d63 c3 46 20			jp macro_next 
3d66				endm 
# End of macro NEXTW
3d66			 
3d66 .. 00		.blstr: db " ", 0 
3d68			 
3d68			.SPACES: 
3d68				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3d68 47				db WORD_SYS_CORE+51             
3d69 03 3e			dw .SCROLL            
3d6b 07				db 6 + 1 
3d6c .. 00			db "SPACES",0              
3d73				endm 
# End of macro CWHEAD
3d73			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
3d73					if DEBUG_FORTH_WORDS_KEY 
3d73						DMARK "SPS" 
3d73 f5				push af  
3d74 3a 88 3d			ld a, (.dmark)  
3d77 32 77 fb			ld (debug_mark),a  
3d7a 3a 89 3d			ld a, (.dmark+1)  
3d7d 32 78 fb			ld (debug_mark+1),a  
3d80 3a 8a 3d			ld a, (.dmark+2)  
3d83 32 79 fb			ld (debug_mark+2),a  
3d86 18 03			jr .pastdmark  
3d88 ..			.dmark: db "SPS"  
3d8b f1			.pastdmark: pop af  
3d8c			endm  
# End of macro DMARK
3d8c						CALLMONITOR 
3d8c cd 4d 17			call break_point_state  
3d8f				endm  
# End of macro CALLMONITOR
3d8f					endif 
3d8f			 
3d8f			 
3d8f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d8f cd d4 1e			call macro_dsp_valuehl 
3d92				endm 
# End of macro FORTH_DSP_VALUEHL
3d92			 
3d92			;		push hl    ; u 
3d92					if DEBUG_FORTH_WORDS 
3d92						DMARK "SPA" 
3d92 f5				push af  
3d93 3a a7 3d			ld a, (.dmark)  
3d96 32 77 fb			ld (debug_mark),a  
3d99 3a a8 3d			ld a, (.dmark+1)  
3d9c 32 78 fb			ld (debug_mark+1),a  
3d9f 3a a9 3d			ld a, (.dmark+2)  
3da2 32 79 fb			ld (debug_mark+2),a  
3da5 18 03			jr .pastdmark  
3da7 ..			.dmark: db "SPA"  
3daa f1			.pastdmark: pop af  
3dab			endm  
# End of macro DMARK
3dab						CALLMONITOR 
3dab cd 4d 17			call break_point_state  
3dae				endm  
# End of macro CALLMONITOR
3dae					endif 
3dae			 
3dae					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3dae cd 8c 1f			call macro_forth_dsp_pop 
3db1				endm 
# End of macro FORTH_DSP_POP
3db1			;		pop hl 
3db1 4d					ld c, l 
3db2 06 00				ld b, 0 
3db4 21 1d ee				ld hl, scratch  
3db7			 
3db7					if DEBUG_FORTH_WORDS 
3db7						DMARK "SP2" 
3db7 f5				push af  
3db8 3a cc 3d			ld a, (.dmark)  
3dbb 32 77 fb			ld (debug_mark),a  
3dbe 3a cd 3d			ld a, (.dmark+1)  
3dc1 32 78 fb			ld (debug_mark+1),a  
3dc4 3a ce 3d			ld a, (.dmark+2)  
3dc7 32 79 fb			ld (debug_mark+2),a  
3dca 18 03			jr .pastdmark  
3dcc ..			.dmark: db "SP2"  
3dcf f1			.pastdmark: pop af  
3dd0			endm  
# End of macro DMARK
3dd0						CALLMONITOR 
3dd0 cd 4d 17			call break_point_state  
3dd3				endm  
# End of macro CALLMONITOR
3dd3					endif 
3dd3 3e 20				ld a, ' ' 
3dd5 c5			.spaces1:	push bc 
3dd6 77					ld (hl),a 
3dd7 23					inc hl 
3dd8 c1					pop bc 
3dd9 10 fa				djnz .spaces1 
3ddb 3e 00				ld a,0 
3ddd 77					ld (hl),a 
3dde 21 1d ee				ld hl, scratch 
3de1					if DEBUG_FORTH_WORDS 
3de1						DMARK "SP3" 
3de1 f5				push af  
3de2 3a f6 3d			ld a, (.dmark)  
3de5 32 77 fb			ld (debug_mark),a  
3de8 3a f7 3d			ld a, (.dmark+1)  
3deb 32 78 fb			ld (debug_mark+1),a  
3dee 3a f8 3d			ld a, (.dmark+2)  
3df1 32 79 fb			ld (debug_mark+2),a  
3df4 18 03			jr .pastdmark  
3df6 ..			.dmark: db "SP3"  
3df9 f1			.pastdmark: pop af  
3dfa			endm  
# End of macro DMARK
3dfa						CALLMONITOR 
3dfa cd 4d 17			call break_point_state  
3dfd				endm  
# End of macro CALLMONITOR
3dfd					endif 
3dfd cd 46 1e				call forth_apush 
3e00			 
3e00				       NEXTW 
3e00 c3 46 20			jp macro_next 
3e03				endm 
# End of macro NEXTW
3e03			 
3e03			 
3e03			 
3e03			.SCROLL: 
3e03				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
3e03 53				db WORD_SYS_CORE+63             
3e04 30 3e			dw .SCROLLD            
3e06 07				db 6 + 1 
3e07 .. 00			db "SCROLL",0              
3e0e				endm 
# End of macro CWHEAD
3e0e			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
3e0e					if DEBUG_FORTH_WORDS_KEY 
3e0e						DMARK "SCR" 
3e0e f5				push af  
3e0f 3a 23 3e			ld a, (.dmark)  
3e12 32 77 fb			ld (debug_mark),a  
3e15 3a 24 3e			ld a, (.dmark+1)  
3e18 32 78 fb			ld (debug_mark+1),a  
3e1b 3a 25 3e			ld a, (.dmark+2)  
3e1e 32 79 fb			ld (debug_mark+2),a  
3e21 18 03			jr .pastdmark  
3e23 ..			.dmark: db "SCR"  
3e26 f1			.pastdmark: pop af  
3e27			endm  
# End of macro DMARK
3e27						CALLMONITOR 
3e27 cd 4d 17			call break_point_state  
3e2a				endm  
# End of macro CALLMONITOR
3e2a					endif 
3e2a			 
3e2a cd 97 0a			call scroll_up 
3e2d			;	call update_display 
3e2d			 
3e2d					NEXTW 
3e2d c3 46 20			jp macro_next 
3e30				endm 
# End of macro NEXTW
3e30			 
3e30			 
3e30			 
3e30			;		; get dir 
3e30			; 
3e30			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e30			; 
3e30			;		push hl 
3e30			; 
3e30			;		; destroy value TOS 
3e30			; 
3e30			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e30			; 
3e30			;		; get count 
3e30			; 
3e30			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e30			; 
3e30			;		push hl 
3e30			; 
3e30			;		; destroy value TOS 
3e30			; 
3e30			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e30			; 
3e30			;		; one value on hl get other one back 
3e30			; 
3e30			;		pop bc    ; count 
3e30			; 
3e30			;		pop de   ; dir 
3e30			; 
3e30			; 
3e30			;		ld b, c 
3e30			; 
3e30			;.scrolldir:     push bc 
3e30			;		push de 
3e30			; 
3e30			;		ld a, 0 
3e30			;		cp e 
3e30			;		jr z, .scrollup  
3e30			;		call scroll_down 
3e30			;		jr .scrollnext 
3e30			;.scrollup:	call scroll_up 
3e30			; 
3e30			;		 
3e30			;.scrollnext: 
3e30			;		pop de 
3e30			;		pop bc 
3e30			;		djnz .scrolldir 
3e30			; 
3e30			; 
3e30			; 
3e30			; 
3e30			; 
3e30			;		NEXTW 
3e30			 
3e30			.SCROLLD: 
3e30				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
3e30 53				db WORD_SYS_CORE+63             
3e31 5e 3e			dw .ATQ            
3e33 08				db 7 + 1 
3e34 .. 00			db "SCROLLD",0              
3e3c				endm 
# End of macro CWHEAD
3e3c			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
3e3c					if DEBUG_FORTH_WORDS_KEY 
3e3c						DMARK "SCD" 
3e3c f5				push af  
3e3d 3a 51 3e			ld a, (.dmark)  
3e40 32 77 fb			ld (debug_mark),a  
3e43 3a 52 3e			ld a, (.dmark+1)  
3e46 32 78 fb			ld (debug_mark+1),a  
3e49 3a 53 3e			ld a, (.dmark+2)  
3e4c 32 79 fb			ld (debug_mark+2),a  
3e4f 18 03			jr .pastdmark  
3e51 ..			.dmark: db "SCD"  
3e54 f1			.pastdmark: pop af  
3e55			endm  
# End of macro DMARK
3e55						CALLMONITOR 
3e55 cd 4d 17			call break_point_state  
3e58				endm  
# End of macro CALLMONITOR
3e58					endif 
3e58			 
3e58 cd bb 0a			call scroll_down 
3e5b			;	call update_display 
3e5b			 
3e5b					NEXTW 
3e5b c3 46 20			jp macro_next 
3e5e				endm 
# End of macro NEXTW
3e5e			 
3e5e			 
3e5e			.ATQ: 
3e5e				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
3e5e 62				db WORD_SYS_CORE+78             
3e5f bc 3e			dw .AUTODSP            
3e61 04				db 3 + 1 
3e62 .. 00			db "AT@",0              
3e66				endm 
# End of macro CWHEAD
3e66			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
3e66					if DEBUG_FORTH_WORDS_KEY 
3e66						DMARK "ATA" 
3e66 f5				push af  
3e67 3a 7b 3e			ld a, (.dmark)  
3e6a 32 77 fb			ld (debug_mark),a  
3e6d 3a 7c 3e			ld a, (.dmark+1)  
3e70 32 78 fb			ld (debug_mark+1),a  
3e73 3a 7d 3e			ld a, (.dmark+2)  
3e76 32 79 fb			ld (debug_mark+2),a  
3e79 18 03			jr .pastdmark  
3e7b ..			.dmark: db "ATA"  
3e7e f1			.pastdmark: pop af  
3e7f			endm  
# End of macro DMARK
3e7f						CALLMONITOR 
3e7f cd 4d 17			call break_point_state  
3e82				endm  
# End of macro CALLMONITOR
3e82					endif 
3e82			 
3e82			 
3e82					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e82 cd d4 1e			call macro_dsp_valuehl 
3e85				endm 
# End of macro FORTH_DSP_VALUEHL
3e85			 
3e85					; TODO save cursor row 
3e85 7d					ld a,l 
3e86 fe 02				cp 2 
3e88 20 04				jr nz, .crow3aq 
3e8a 3e 28				ld a, display_row_2 
3e8c 18 12				jr .ccol1aq 
3e8e fe 03		.crow3aq:		cp 3 
3e90 20 04				jr nz, .crow4aq 
3e92 3e 50				ld a, display_row_3 
3e94 18 0a				jr .ccol1aq 
3e96 fe 04		.crow4aq:		cp 4 
3e98 20 04				jr nz, .crow1aq 
3e9a 3e 78				ld a, display_row_4 
3e9c 18 02				jr .ccol1aq 
3e9e 3e 00		.crow1aq:		ld a,display_row_1 
3ea0 f5			.ccol1aq:		push af			; got row offset 
3ea1 6f					ld l,a 
3ea2 26 00				ld h,0 
3ea4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ea4 cd 8c 1f			call macro_forth_dsp_pop 
3ea7				endm 
# End of macro FORTH_DSP_POP
3ea7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ea7 cd d4 1e			call macro_dsp_valuehl 
3eaa				endm 
# End of macro FORTH_DSP_VALUEHL
3eaa					; TODO save cursor col 
3eaa f1					pop af 
3eab 85					add l		; add col offset 
3eac			 
3eac					; add current frame buffer address 
3eac 2a d8 f8				ld hl, (display_fb_active) 
3eaf cd 09 0d				call addatohl 
3eb2			 
3eb2			 
3eb2			 
3eb2			 
3eb2					; get char frame buffer location offset in hl 
3eb2			 
3eb2 7e					ld a,(hl) 
3eb3 26 00				ld h, 0 
3eb5 6f					ld l, a 
3eb6			 
3eb6 cd dd 1c				call forth_push_numhl 
3eb9			 
3eb9			 
3eb9					NEXTW 
3eb9 c3 46 20			jp macro_next 
3ebc				endm 
# End of macro NEXTW
3ebc			 
3ebc			.AUTODSP: 
3ebc				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
3ebc 63				db WORD_SYS_CORE+79             
3ebd d2 3e			dw .MENU            
3ebf 05				db 4 + 1 
3ec0 .. 00			db "ADSP",0              
3ec5				endm 
# End of macro CWHEAD
3ec5			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
3ec5			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
3ec5			 
3ec5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ec5 cd d4 1e			call macro_dsp_valuehl 
3ec8				endm 
# End of macro FORTH_DSP_VALUEHL
3ec8			 
3ec8			;		push hl 
3ec8			 
3ec8					; destroy value TOS 
3ec8			 
3ec8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ec8 cd 8c 1f			call macro_forth_dsp_pop 
3ecb				endm 
# End of macro FORTH_DSP_POP
3ecb			 
3ecb			;		pop hl 
3ecb			 
3ecb 7d					ld a,l 
3ecc 32 24 f8				ld (cli_autodisplay), a 
3ecf				       NEXTW 
3ecf c3 46 20			jp macro_next 
3ed2				endm 
# End of macro NEXTW
3ed2			 
3ed2			.MENU: 
3ed2				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
3ed2 70				db WORD_SYS_CORE+92             
3ed3 7b 3f			dw .ENDDISPLAY            
3ed5 05				db 4 + 1 
3ed6 .. 00			db "MENU",0              
3edb				endm 
# End of macro CWHEAD
3edb			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
3edb			 
3edb			;		; get number of items on the stack 
3edb			; 
3edb				 
3edb					FORTH_DSP_VALUEHL 
3edb cd d4 1e			call macro_dsp_valuehl 
3ede				endm 
# End of macro FORTH_DSP_VALUEHL
3ede				 
3ede					if DEBUG_FORTH_WORDS_KEY 
3ede						DMARK "MNU" 
3ede f5				push af  
3edf 3a f3 3e			ld a, (.dmark)  
3ee2 32 77 fb			ld (debug_mark),a  
3ee5 3a f4 3e			ld a, (.dmark+1)  
3ee8 32 78 fb			ld (debug_mark+1),a  
3eeb 3a f5 3e			ld a, (.dmark+2)  
3eee 32 79 fb			ld (debug_mark+2),a  
3ef1 18 03			jr .pastdmark  
3ef3 ..			.dmark: db "MNU"  
3ef6 f1			.pastdmark: pop af  
3ef7			endm  
# End of macro DMARK
3ef7						CALLMONITOR 
3ef7 cd 4d 17			call break_point_state  
3efa				endm  
# End of macro CALLMONITOR
3efa					endif 
3efa			 
3efa 45					ld b, l	 
3efb 05					dec b 
3efc			 
3efc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3efc cd 8c 1f			call macro_forth_dsp_pop 
3eff				endm 
# End of macro FORTH_DSP_POP
3eff			 
3eff			 
3eff					; go directly through the stack to pluck out the string pointers and build an array 
3eff			 
3eff			;		FORTH_DSP 
3eff			 
3eff					; hl contains top most stack item 
3eff				 
3eff 11 1d ee				ld de, scratch 
3f02			 
3f02			.mbuild: 
3f02			 
3f02					FORTH_DSP_VALUEHL 
3f02 cd d4 1e			call macro_dsp_valuehl 
3f05				endm 
# End of macro FORTH_DSP_VALUEHL
3f05			 
3f05					if DEBUG_FORTH_WORDS 
3f05						DMARK "MN3" 
3f05 f5				push af  
3f06 3a 1a 3f			ld a, (.dmark)  
3f09 32 77 fb			ld (debug_mark),a  
3f0c 3a 1b 3f			ld a, (.dmark+1)  
3f0f 32 78 fb			ld (debug_mark+1),a  
3f12 3a 1c 3f			ld a, (.dmark+2)  
3f15 32 79 fb			ld (debug_mark+2),a  
3f18 18 03			jr .pastdmark  
3f1a ..			.dmark: db "MN3"  
3f1d f1			.pastdmark: pop af  
3f1e			endm  
# End of macro DMARK
3f1e						CALLMONITOR 
3f1e cd 4d 17			call break_point_state  
3f21				endm  
# End of macro CALLMONITOR
3f21					endif 
3f21 eb					ex de, hl 
3f22 73					ld (hl), e 
3f23 23					inc hl 
3f24 72					ld (hl), d 
3f25 23					inc hl 
3f26 eb					ex de, hl 
3f27			 
3f27					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f27 cd 8c 1f			call macro_forth_dsp_pop 
3f2a				endm 
# End of macro FORTH_DSP_POP
3f2a			 
3f2a 10 d6				djnz .mbuild 
3f2c			 
3f2c					; done add term 
3f2c			 
3f2c eb					ex de, hl 
3f2d 36 00				ld (hl), 0 
3f2f 23					inc hl 
3f30 36 00				ld (hl), 0 
3f32			 
3f32				 
3f32					 
3f32 21 1d ee				ld hl, scratch 
3f35			 
3f35					if DEBUG_FORTH_WORDS 
3f35						DMARK "MNx" 
3f35 f5				push af  
3f36 3a 4a 3f			ld a, (.dmark)  
3f39 32 77 fb			ld (debug_mark),a  
3f3c 3a 4b 3f			ld a, (.dmark+1)  
3f3f 32 78 fb			ld (debug_mark+1),a  
3f42 3a 4c 3f			ld a, (.dmark+2)  
3f45 32 79 fb			ld (debug_mark+2),a  
3f48 18 03			jr .pastdmark  
3f4a ..			.dmark: db "MNx"  
3f4d f1			.pastdmark: pop af  
3f4e			endm  
# End of macro DMARK
3f4e						CALLMONITOR 
3f4e cd 4d 17			call break_point_state  
3f51				endm  
# End of macro CALLMONITOR
3f51					endif 
3f51			 
3f51			 
3f51			 
3f51 3e 00				ld a, 0 
3f53 cd 06 0b				call menu 
3f56			 
3f56			 
3f56 6f					ld l, a 
3f57 26 00				ld h, 0 
3f59			 
3f59					if DEBUG_FORTH_WORDS 
3f59						DMARK "MNr" 
3f59 f5				push af  
3f5a 3a 6e 3f			ld a, (.dmark)  
3f5d 32 77 fb			ld (debug_mark),a  
3f60 3a 6f 3f			ld a, (.dmark+1)  
3f63 32 78 fb			ld (debug_mark+1),a  
3f66 3a 70 3f			ld a, (.dmark+2)  
3f69 32 79 fb			ld (debug_mark+2),a  
3f6c 18 03			jr .pastdmark  
3f6e ..			.dmark: db "MNr"  
3f71 f1			.pastdmark: pop af  
3f72			endm  
# End of macro DMARK
3f72						CALLMONITOR 
3f72 cd 4d 17			call break_point_state  
3f75				endm  
# End of macro CALLMONITOR
3f75					endif 
3f75			 
3f75 cd dd 1c				call forth_push_numhl 
3f78			 
3f78			 
3f78			 
3f78			 
3f78				       NEXTW 
3f78 c3 46 20			jp macro_next 
3f7b				endm 
# End of macro NEXTW
3f7b			 
3f7b			 
3f7b			.ENDDISPLAY: 
3f7b			 
3f7b			; eof 
# End of file forth_words_display.asm
3f7b			include "forth_words_str.asm" 
3f7b			 
3f7b			; | ## String Words 
3f7b			 
3f7b			.PTR:   
3f7b			 
3f7b				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
3f7b 48				db WORD_SYS_CORE+52             
3f7c a8 3f			dw .STYPE            
3f7e 04				db 3 + 1 
3f7f .. 00			db "PTR",0              
3f83				endm 
# End of macro CWHEAD
3f83			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
3f83			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
3f83			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
3f83			 
3f83					if DEBUG_FORTH_WORDS_KEY 
3f83						DMARK "PTR" 
3f83 f5				push af  
3f84 3a 98 3f			ld a, (.dmark)  
3f87 32 77 fb			ld (debug_mark),a  
3f8a 3a 99 3f			ld a, (.dmark+1)  
3f8d 32 78 fb			ld (debug_mark+1),a  
3f90 3a 9a 3f			ld a, (.dmark+2)  
3f93 32 79 fb			ld (debug_mark+2),a  
3f96 18 03			jr .pastdmark  
3f98 ..			.dmark: db "PTR"  
3f9b f1			.pastdmark: pop af  
3f9c			endm  
# End of macro DMARK
3f9c						CALLMONITOR 
3f9c cd 4d 17			call break_point_state  
3f9f				endm  
# End of macro CALLMONITOR
3f9f					endif 
3f9f					FORTH_DSP_VALUEHL 
3f9f cd d4 1e			call macro_dsp_valuehl 
3fa2				endm 
# End of macro FORTH_DSP_VALUEHL
3fa2 cd dd 1c				call forth_push_numhl 
3fa5			 
3fa5			 
3fa5					NEXTW 
3fa5 c3 46 20			jp macro_next 
3fa8				endm 
# End of macro NEXTW
3fa8			.STYPE: 
3fa8				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
3fa8 48				db WORD_SYS_CORE+52             
3fa9 f7 3f			dw .UPPER            
3fab 06				db 5 + 1 
3fac .. 00			db "STYPE",0              
3fb2				endm 
# End of macro CWHEAD
3fb2			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
3fb2					if DEBUG_FORTH_WORDS_KEY 
3fb2						DMARK "STY" 
3fb2 f5				push af  
3fb3 3a c7 3f			ld a, (.dmark)  
3fb6 32 77 fb			ld (debug_mark),a  
3fb9 3a c8 3f			ld a, (.dmark+1)  
3fbc 32 78 fb			ld (debug_mark+1),a  
3fbf 3a c9 3f			ld a, (.dmark+2)  
3fc2 32 79 fb			ld (debug_mark+2),a  
3fc5 18 03			jr .pastdmark  
3fc7 ..			.dmark: db "STY"  
3fca f1			.pastdmark: pop af  
3fcb			endm  
# End of macro DMARK
3fcb						CALLMONITOR 
3fcb cd 4d 17			call break_point_state  
3fce				endm  
# End of macro CALLMONITOR
3fce					endif 
3fce					FORTH_DSP 
3fce cd 9a 1e			call macro_forth_dsp 
3fd1				endm 
# End of macro FORTH_DSP
3fd1					;v5 FORTH_DSP_VALUE 
3fd1			 
3fd1 7e					ld a, (hl) 
3fd2			 
3fd2 f5					push af 
3fd3			 
3fd3			; Dont destroy TOS		FORTH_DSP_POP 
3fd3			 
3fd3 f1					pop af 
3fd4			 
3fd4 fe 01				cp DS_TYPE_STR 
3fd6 28 09				jr z, .typestr 
3fd8			 
3fd8 fe 02				cp DS_TYPE_INUM 
3fda 28 0a				jr z, .typeinum 
3fdc			 
3fdc 21 f5 3f				ld hl, .tna 
3fdf 18 0a				jr .tpush 
3fe1			 
3fe1 21 f1 3f		.typestr:	ld hl, .tstr 
3fe4 18 05				jr .tpush 
3fe6 21 f3 3f		.typeinum:	ld hl, .tinum 
3fe9 18 00				jr .tpush 
3feb			 
3feb			.tpush: 
3feb			 
3feb cd 4b 1d				call forth_push_str 
3fee			 
3fee					NEXTW 
3fee c3 46 20			jp macro_next 
3ff1				endm 
# End of macro NEXTW
3ff1 .. 00		.tstr:	db "s",0 
3ff3 .. 00		.tinum:  db "i",0 
3ff5 .. 00		.tna:   db "?", 0 
3ff7			 
3ff7			 
3ff7			.UPPER: 
3ff7				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
3ff7 48				db WORD_SYS_CORE+52             
3ff8 32 40			dw .LOWER            
3ffa 06				db 5 + 1 
3ffb .. 00			db "UPPER",0              
4001				endm 
# End of macro CWHEAD
4001			; | UPPER ( s -- s ) Upper case string s  | DONE 
4001					if DEBUG_FORTH_WORDS_KEY 
4001						DMARK "UPR" 
4001 f5				push af  
4002 3a 16 40			ld a, (.dmark)  
4005 32 77 fb			ld (debug_mark),a  
4008 3a 17 40			ld a, (.dmark+1)  
400b 32 78 fb			ld (debug_mark+1),a  
400e 3a 18 40			ld a, (.dmark+2)  
4011 32 79 fb			ld (debug_mark+2),a  
4014 18 03			jr .pastdmark  
4016 ..			.dmark: db "UPR"  
4019 f1			.pastdmark: pop af  
401a			endm  
# End of macro DMARK
401a						CALLMONITOR 
401a cd 4d 17			call break_point_state  
401d				endm  
# End of macro CALLMONITOR
401d					endif 
401d			 
401d					FORTH_DSP 
401d cd 9a 1e			call macro_forth_dsp 
4020				endm 
# End of macro FORTH_DSP
4020					 
4020			; TODO check is string type 
4020			 
4020					FORTH_DSP_VALUEHL 
4020 cd d4 1e			call macro_dsp_valuehl 
4023				endm 
# End of macro FORTH_DSP_VALUEHL
4023			; get pointer to string in hl 
4023			 
4023 7e			.toup:		ld a, (hl) 
4024 fe 00				cp 0 
4026 28 07				jr z, .toupdone 
4028			 
4028 cd 76 10				call to_upper 
402b			 
402b 77					ld (hl), a 
402c 23					inc hl 
402d 18 f4				jr .toup 
402f			 
402f					 
402f			 
402f			 
402f			; for each char convert to upper 
402f					 
402f			.toupdone: 
402f			 
402f			 
402f					NEXTW 
402f c3 46 20			jp macro_next 
4032				endm 
# End of macro NEXTW
4032			.LOWER: 
4032				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
4032 48				db WORD_SYS_CORE+52             
4033 6d 40			dw .TCASE            
4035 06				db 5 + 1 
4036 .. 00			db "LOWER",0              
403c				endm 
# End of macro CWHEAD
403c			; | LOWER ( s -- s ) Lower case string s  | DONE 
403c					if DEBUG_FORTH_WORDS_KEY 
403c						DMARK "LWR" 
403c f5				push af  
403d 3a 51 40			ld a, (.dmark)  
4040 32 77 fb			ld (debug_mark),a  
4043 3a 52 40			ld a, (.dmark+1)  
4046 32 78 fb			ld (debug_mark+1),a  
4049 3a 53 40			ld a, (.dmark+2)  
404c 32 79 fb			ld (debug_mark+2),a  
404f 18 03			jr .pastdmark  
4051 ..			.dmark: db "LWR"  
4054 f1			.pastdmark: pop af  
4055			endm  
# End of macro DMARK
4055						CALLMONITOR 
4055 cd 4d 17			call break_point_state  
4058				endm  
# End of macro CALLMONITOR
4058					endif 
4058			 
4058					FORTH_DSP 
4058 cd 9a 1e			call macro_forth_dsp 
405b				endm 
# End of macro FORTH_DSP
405b					 
405b			; TODO check is string type 
405b			 
405b					FORTH_DSP_VALUEHL 
405b cd d4 1e			call macro_dsp_valuehl 
405e				endm 
# End of macro FORTH_DSP_VALUEHL
405e			; get pointer to string in hl 
405e			 
405e 7e			.tolow:		ld a, (hl) 
405f fe 00				cp 0 
4061 28 07				jr z, .tolowdone 
4063			 
4063 cd 7f 10				call to_lower 
4066			 
4066 77					ld (hl), a 
4067 23					inc hl 
4068 18 f4				jr .tolow 
406a			 
406a					 
406a			 
406a			 
406a			; for each char convert to low 
406a					 
406a			.tolowdone: 
406a					NEXTW 
406a c3 46 20			jp macro_next 
406d				endm 
# End of macro NEXTW
406d			.TCASE: 
406d				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
406d 48				db WORD_SYS_CORE+52             
406e a3 41			dw .SUBSTR            
4070 06				db 5 + 1 
4071 .. 00			db "TCASE",0              
4077				endm 
# End of macro CWHEAD
4077			; | TCASE ( s -- s ) Title case string s  | DONE 
4077					if DEBUG_FORTH_WORDS_KEY 
4077						DMARK "TCS" 
4077 f5				push af  
4078 3a 8c 40			ld a, (.dmark)  
407b 32 77 fb			ld (debug_mark),a  
407e 3a 8d 40			ld a, (.dmark+1)  
4081 32 78 fb			ld (debug_mark+1),a  
4084 3a 8e 40			ld a, (.dmark+2)  
4087 32 79 fb			ld (debug_mark+2),a  
408a 18 03			jr .pastdmark  
408c ..			.dmark: db "TCS"  
408f f1			.pastdmark: pop af  
4090			endm  
# End of macro DMARK
4090						CALLMONITOR 
4090 cd 4d 17			call break_point_state  
4093				endm  
# End of macro CALLMONITOR
4093					endif 
4093			 
4093					FORTH_DSP 
4093 cd 9a 1e			call macro_forth_dsp 
4096				endm 
# End of macro FORTH_DSP
4096					 
4096			; TODO check is string type 
4096			 
4096					FORTH_DSP_VALUEHL 
4096 cd d4 1e			call macro_dsp_valuehl 
4099				endm 
# End of macro FORTH_DSP_VALUEHL
4099			; get pointer to string in hl 
4099			 
4099					if DEBUG_FORTH_WORDS 
4099						DMARK "TC1" 
4099 f5				push af  
409a 3a ae 40			ld a, (.dmark)  
409d 32 77 fb			ld (debug_mark),a  
40a0 3a af 40			ld a, (.dmark+1)  
40a3 32 78 fb			ld (debug_mark+1),a  
40a6 3a b0 40			ld a, (.dmark+2)  
40a9 32 79 fb			ld (debug_mark+2),a  
40ac 18 03			jr .pastdmark  
40ae ..			.dmark: db "TC1"  
40b1 f1			.pastdmark: pop af  
40b2			endm  
# End of macro DMARK
40b2						CALLMONITOR 
40b2 cd 4d 17			call break_point_state  
40b5				endm  
# End of macro CALLMONITOR
40b5					endif 
40b5			 
40b5					; first time in turn to upper case first char 
40b5			 
40b5 7e					ld a, (hl) 
40b6 c3 40 41				jp .totsiptou 
40b9			 
40b9			 
40b9 7e			.tot:		ld a, (hl) 
40ba fe 00				cp 0 
40bc ca 84 41				jp z, .totdone 
40bf			 
40bf					if DEBUG_FORTH_WORDS 
40bf						DMARK "TC2" 
40bf f5				push af  
40c0 3a d4 40			ld a, (.dmark)  
40c3 32 77 fb			ld (debug_mark),a  
40c6 3a d5 40			ld a, (.dmark+1)  
40c9 32 78 fb			ld (debug_mark+1),a  
40cc 3a d6 40			ld a, (.dmark+2)  
40cf 32 79 fb			ld (debug_mark+2),a  
40d2 18 03			jr .pastdmark  
40d4 ..			.dmark: db "TC2"  
40d7 f1			.pastdmark: pop af  
40d8			endm  
# End of macro DMARK
40d8						CALLMONITOR 
40d8 cd 4d 17			call break_point_state  
40db				endm  
# End of macro CALLMONITOR
40db					endif 
40db					; check to see if current char is a space 
40db			 
40db fe 20				cp ' ' 
40dd 28 21				jr z, .totsp 
40df cd 7f 10				call to_lower 
40e2					if DEBUG_FORTH_WORDS 
40e2						DMARK "TC3" 
40e2 f5				push af  
40e3 3a f7 40			ld a, (.dmark)  
40e6 32 77 fb			ld (debug_mark),a  
40e9 3a f8 40			ld a, (.dmark+1)  
40ec 32 78 fb			ld (debug_mark+1),a  
40ef 3a f9 40			ld a, (.dmark+2)  
40f2 32 79 fb			ld (debug_mark+2),a  
40f5 18 03			jr .pastdmark  
40f7 ..			.dmark: db "TC3"  
40fa f1			.pastdmark: pop af  
40fb			endm  
# End of macro DMARK
40fb						CALLMONITOR 
40fb cd 4d 17			call break_point_state  
40fe				endm  
# End of macro CALLMONITOR
40fe					endif 
40fe 18 63				jr .totnxt 
4100			 
4100			.totsp:         ; on a space, find next char which should be upper 
4100			 
4100					if DEBUG_FORTH_WORDS 
4100						DMARK "TC4" 
4100 f5				push af  
4101 3a 15 41			ld a, (.dmark)  
4104 32 77 fb			ld (debug_mark),a  
4107 3a 16 41			ld a, (.dmark+1)  
410a 32 78 fb			ld (debug_mark+1),a  
410d 3a 17 41			ld a, (.dmark+2)  
4110 32 79 fb			ld (debug_mark+2),a  
4113 18 03			jr .pastdmark  
4115 ..			.dmark: db "TC4"  
4118 f1			.pastdmark: pop af  
4119			endm  
# End of macro DMARK
4119						CALLMONITOR 
4119 cd 4d 17			call break_point_state  
411c				endm  
# End of macro CALLMONITOR
411c					endif 
411c					;; 
411c			 
411c fe 20				cp ' ' 
411e 20 20				jr nz, .totsiptou 
4120 23					inc hl 
4121 7e					ld a, (hl) 
4122					if DEBUG_FORTH_WORDS 
4122						DMARK "TC5" 
4122 f5				push af  
4123 3a 37 41			ld a, (.dmark)  
4126 32 77 fb			ld (debug_mark),a  
4129 3a 38 41			ld a, (.dmark+1)  
412c 32 78 fb			ld (debug_mark+1),a  
412f 3a 39 41			ld a, (.dmark+2)  
4132 32 79 fb			ld (debug_mark+2),a  
4135 18 03			jr .pastdmark  
4137 ..			.dmark: db "TC5"  
413a f1			.pastdmark: pop af  
413b			endm  
# End of macro DMARK
413b						CALLMONITOR 
413b cd 4d 17			call break_point_state  
413e				endm  
# End of macro CALLMONITOR
413e					endif 
413e 18 c0				jr .totsp 
4140 fe 00		.totsiptou:    cp 0 
4142 28 40				jr z, .totdone 
4144					; not space and not zero term so upper case it 
4144 cd 76 10				call to_upper 
4147			 
4147					if DEBUG_FORTH_WORDS 
4147						DMARK "TC6" 
4147 f5				push af  
4148 3a 5c 41			ld a, (.dmark)  
414b 32 77 fb			ld (debug_mark),a  
414e 3a 5d 41			ld a, (.dmark+1)  
4151 32 78 fb			ld (debug_mark+1),a  
4154 3a 5e 41			ld a, (.dmark+2)  
4157 32 79 fb			ld (debug_mark+2),a  
415a 18 03			jr .pastdmark  
415c ..			.dmark: db "TC6"  
415f f1			.pastdmark: pop af  
4160			endm  
# End of macro DMARK
4160						CALLMONITOR 
4160 cd 4d 17			call break_point_state  
4163				endm  
# End of macro CALLMONITOR
4163					endif 
4163			 
4163			 
4163			.totnxt: 
4163			 
4163 77					ld (hl), a 
4164 23					inc hl 
4165					if DEBUG_FORTH_WORDS 
4165						DMARK "TC7" 
4165 f5				push af  
4166 3a 7a 41			ld a, (.dmark)  
4169 32 77 fb			ld (debug_mark),a  
416c 3a 7b 41			ld a, (.dmark+1)  
416f 32 78 fb			ld (debug_mark+1),a  
4172 3a 7c 41			ld a, (.dmark+2)  
4175 32 79 fb			ld (debug_mark+2),a  
4178 18 03			jr .pastdmark  
417a ..			.dmark: db "TC7"  
417d f1			.pastdmark: pop af  
417e			endm  
# End of macro DMARK
417e						CALLMONITOR 
417e cd 4d 17			call break_point_state  
4181				endm  
# End of macro CALLMONITOR
4181					endif 
4181 c3 b9 40				jp .tot 
4184			 
4184					 
4184			 
4184			 
4184			; for each char convert to low 
4184					 
4184			.totdone: 
4184					if DEBUG_FORTH_WORDS 
4184						DMARK "TCd" 
4184 f5				push af  
4185 3a 99 41			ld a, (.dmark)  
4188 32 77 fb			ld (debug_mark),a  
418b 3a 9a 41			ld a, (.dmark+1)  
418e 32 78 fb			ld (debug_mark+1),a  
4191 3a 9b 41			ld a, (.dmark+2)  
4194 32 79 fb			ld (debug_mark+2),a  
4197 18 03			jr .pastdmark  
4199 ..			.dmark: db "TCd"  
419c f1			.pastdmark: pop af  
419d			endm  
# End of macro DMARK
419d						CALLMONITOR 
419d cd 4d 17			call break_point_state  
41a0				endm  
# End of macro CALLMONITOR
41a0					endif 
41a0					NEXTW 
41a0 c3 46 20			jp macro_next 
41a3				endm 
# End of macro NEXTW
41a3			 
41a3			.SUBSTR: 
41a3				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
41a3 48				db WORD_SYS_CORE+52             
41a4 01 42			dw .LEFT            
41a6 07				db 6 + 1 
41a7 .. 00			db "SUBSTR",0              
41ae				endm 
# End of macro CWHEAD
41ae			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
41ae			 
41ae					if DEBUG_FORTH_WORDS_KEY 
41ae						DMARK "SST" 
41ae f5				push af  
41af 3a c3 41			ld a, (.dmark)  
41b2 32 77 fb			ld (debug_mark),a  
41b5 3a c4 41			ld a, (.dmark+1)  
41b8 32 78 fb			ld (debug_mark+1),a  
41bb 3a c5 41			ld a, (.dmark+2)  
41be 32 79 fb			ld (debug_mark+2),a  
41c1 18 03			jr .pastdmark  
41c3 ..			.dmark: db "SST"  
41c6 f1			.pastdmark: pop af  
41c7			endm  
# End of macro DMARK
41c7						CALLMONITOR 
41c7 cd 4d 17			call break_point_state  
41ca				endm  
# End of macro CALLMONITOR
41ca					endif 
41ca			; TODO check string type 
41ca					FORTH_DSP_VALUEHL 
41ca cd d4 1e			call macro_dsp_valuehl 
41cd				endm 
# End of macro FORTH_DSP_VALUEHL
41cd			 
41cd e5					push hl      ; string length 
41ce			 
41ce					FORTH_DSP_POP 
41ce cd 8c 1f			call macro_forth_dsp_pop 
41d1				endm 
# End of macro FORTH_DSP_POP
41d1			 
41d1					FORTH_DSP_VALUEHL 
41d1 cd d4 1e			call macro_dsp_valuehl 
41d4				endm 
# End of macro FORTH_DSP_VALUEHL
41d4			 
41d4 e5					push hl     ; start char 
41d5			 
41d5					FORTH_DSP_POP 
41d5 cd 8c 1f			call macro_forth_dsp_pop 
41d8				endm 
# End of macro FORTH_DSP_POP
41d8			 
41d8			 
41d8					FORTH_DSP_VALUE 
41d8 cd bd 1e			call macro_forth_dsp_value 
41db				endm 
# End of macro FORTH_DSP_VALUE
41db			 
41db d1					pop de    ; get start post offset 
41dc			 
41dc 19					add hl, de    ; starting offset 
41dd			 
41dd c1					pop bc 
41de c5					push bc      ; grab size of string 
41df			 
41df e5					push hl    ; save string start  
41e0			 
41e0 26 00				ld h, 0 
41e2 69					ld l, c 
41e3 23					inc hl 
41e4 23					inc hl 
41e5			 
41e5 cd d0 11				call malloc 
41e8				if DEBUG_FORTH_MALLOC_GUARD 
41e8 cc 93 51				call z,malloc_error 
41eb				endif 
41eb			 
41eb eb					ex de, hl      ; save malloc area for string copy 
41ec e1					pop hl    ; get back source 
41ed c1					pop bc    ; get length of string back 
41ee			 
41ee d5					push de    ; save malloc area for after we push 
41ef ed b0				ldir     ; copy substr 
41f1			 
41f1			 
41f1 eb					ex de, hl 
41f2 3e 00				ld a, 0 
41f4 77					ld (hl), a   ; term substr 
41f5			 
41f5					 
41f5 e1					pop hl    ; get malloc so we can push it 
41f6 e5					push hl   ; save so we can free it afterwards 
41f7			 
41f7 cd 4b 1d				call forth_push_str 
41fa			 
41fa e1					pop hl 
41fb cd 9a 12				call free 
41fe			 
41fe					 
41fe					 
41fe			 
41fe			 
41fe					NEXTW 
41fe c3 46 20			jp macro_next 
4201				endm 
# End of macro NEXTW
4201			 
4201			.LEFT: 
4201				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
4201 48				db WORD_SYS_CORE+52             
4202 29 42			dw .RIGHT            
4204 05				db 4 + 1 
4205 .. 00			db "LEFT",0              
420a				endm 
# End of macro CWHEAD
420a			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
420a					if DEBUG_FORTH_WORDS_KEY 
420a						DMARK "LEF" 
420a f5				push af  
420b 3a 1f 42			ld a, (.dmark)  
420e 32 77 fb			ld (debug_mark),a  
4211 3a 20 42			ld a, (.dmark+1)  
4214 32 78 fb			ld (debug_mark+1),a  
4217 3a 21 42			ld a, (.dmark+2)  
421a 32 79 fb			ld (debug_mark+2),a  
421d 18 03			jr .pastdmark  
421f ..			.dmark: db "LEF"  
4222 f1			.pastdmark: pop af  
4223			endm  
# End of macro DMARK
4223						CALLMONITOR 
4223 cd 4d 17			call break_point_state  
4226				endm  
# End of macro CALLMONITOR
4226					endif 
4226			 
4226					NEXTW 
4226 c3 46 20			jp macro_next 
4229				endm 
# End of macro NEXTW
4229			.RIGHT: 
4229				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
4229 48				db WORD_SYS_CORE+52             
422a 52 42			dw .STR2NUM            
422c 06				db 5 + 1 
422d .. 00			db "RIGHT",0              
4233				endm 
# End of macro CWHEAD
4233			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
4233					if DEBUG_FORTH_WORDS_KEY 
4233						DMARK "RIG" 
4233 f5				push af  
4234 3a 48 42			ld a, (.dmark)  
4237 32 77 fb			ld (debug_mark),a  
423a 3a 49 42			ld a, (.dmark+1)  
423d 32 78 fb			ld (debug_mark+1),a  
4240 3a 4a 42			ld a, (.dmark+2)  
4243 32 79 fb			ld (debug_mark+2),a  
4246 18 03			jr .pastdmark  
4248 ..			.dmark: db "RIG"  
424b f1			.pastdmark: pop af  
424c			endm  
# End of macro DMARK
424c						CALLMONITOR 
424c cd 4d 17			call break_point_state  
424f				endm  
# End of macro CALLMONITOR
424f					endif 
424f			 
424f					NEXTW 
424f c3 46 20			jp macro_next 
4252				endm 
# End of macro NEXTW
4252			 
4252			 
4252			.STR2NUM: 
4252				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
4252 48				db WORD_SYS_CORE+52             
4253 de 42			dw .NUM2STR            
4255 08				db 7 + 1 
4256 .. 00			db "STR2NUM",0              
425e				endm 
# End of macro CWHEAD
425e			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
425e			 
425e			 
425e			; TODO STR type check to do 
425e					if DEBUG_FORTH_WORDS_KEY 
425e						DMARK "S2N" 
425e f5				push af  
425f 3a 73 42			ld a, (.dmark)  
4262 32 77 fb			ld (debug_mark),a  
4265 3a 74 42			ld a, (.dmark+1)  
4268 32 78 fb			ld (debug_mark+1),a  
426b 3a 75 42			ld a, (.dmark+2)  
426e 32 79 fb			ld (debug_mark+2),a  
4271 18 03			jr .pastdmark  
4273 ..			.dmark: db "S2N"  
4276 f1			.pastdmark: pop af  
4277			endm  
# End of macro DMARK
4277						CALLMONITOR 
4277 cd 4d 17			call break_point_state  
427a				endm  
# End of macro CALLMONITOR
427a					endif 
427a			 
427a					;FORTH_DSP 
427a					FORTH_DSP_VALUE 
427a cd bd 1e			call macro_forth_dsp_value 
427d				endm 
# End of macro FORTH_DSP_VALUE
427d					;inc hl 
427d			 
427d eb					ex de, hl 
427e					if DEBUG_FORTH_WORDS 
427e						DMARK "S2a" 
427e f5				push af  
427f 3a 93 42			ld a, (.dmark)  
4282 32 77 fb			ld (debug_mark),a  
4285 3a 94 42			ld a, (.dmark+1)  
4288 32 78 fb			ld (debug_mark+1),a  
428b 3a 95 42			ld a, (.dmark+2)  
428e 32 79 fb			ld (debug_mark+2),a  
4291 18 03			jr .pastdmark  
4293 ..			.dmark: db "S2a"  
4296 f1			.pastdmark: pop af  
4297			endm  
# End of macro DMARK
4297						CALLMONITOR 
4297 cd 4d 17			call break_point_state  
429a				endm  
# End of macro CALLMONITOR
429a					endif 
429a cd fe 10				call string_to_uint16 
429d			 
429d					if DEBUG_FORTH_WORDS 
429d						DMARK "S2b" 
429d f5				push af  
429e 3a b2 42			ld a, (.dmark)  
42a1 32 77 fb			ld (debug_mark),a  
42a4 3a b3 42			ld a, (.dmark+1)  
42a7 32 78 fb			ld (debug_mark+1),a  
42aa 3a b4 42			ld a, (.dmark+2)  
42ad 32 79 fb			ld (debug_mark+2),a  
42b0 18 03			jr .pastdmark  
42b2 ..			.dmark: db "S2b"  
42b5 f1			.pastdmark: pop af  
42b6			endm  
# End of macro DMARK
42b6						CALLMONITOR 
42b6 cd 4d 17			call break_point_state  
42b9				endm  
# End of macro CALLMONITOR
42b9					endif 
42b9			;		push hl 
42b9					FORTH_DSP_POP 
42b9 cd 8c 1f			call macro_forth_dsp_pop 
42bc				endm 
# End of macro FORTH_DSP_POP
42bc			;		pop hl 
42bc					 
42bc					if DEBUG_FORTH_WORDS 
42bc						DMARK "S2b" 
42bc f5				push af  
42bd 3a d1 42			ld a, (.dmark)  
42c0 32 77 fb			ld (debug_mark),a  
42c3 3a d2 42			ld a, (.dmark+1)  
42c6 32 78 fb			ld (debug_mark+1),a  
42c9 3a d3 42			ld a, (.dmark+2)  
42cc 32 79 fb			ld (debug_mark+2),a  
42cf 18 03			jr .pastdmark  
42d1 ..			.dmark: db "S2b"  
42d4 f1			.pastdmark: pop af  
42d5			endm  
# End of macro DMARK
42d5						CALLMONITOR 
42d5 cd 4d 17			call break_point_state  
42d8				endm  
# End of macro CALLMONITOR
42d8					endif 
42d8 cd dd 1c				call forth_push_numhl	 
42db			 
42db				 
42db				       NEXTW 
42db c3 46 20			jp macro_next 
42de				endm 
# End of macro NEXTW
42de			.NUM2STR: 
42de				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
42de 48				db WORD_SYS_CORE+52             
42df ed 42			dw .CONCAT            
42e1 08				db 7 + 1 
42e2 .. 00			db "NUM2STR",0              
42ea				endm 
# End of macro CWHEAD
42ea			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
42ea			 
42ea			;		; malloc a string to target 
42ea			;		ld hl, 10     ; TODO max string size should be fine 
42ea			;		call malloc 
42ea			;		push hl    ; save malloc location 
42ea			; 
42ea			; 
42ea			;; TODO check int type 
42ea			;		FORTH_DSP_VALUEHL 
42ea			;		ld a, l 
42ea			;		call DispAToASCII   
42ea			;;TODO need to chage above call to dump into string 
42ea			; 
42ea			; 
42ea			 
42ea				       NEXTW 
42ea c3 46 20			jp macro_next 
42ed				endm 
# End of macro NEXTW
42ed			 
42ed			.CONCAT: 
42ed				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
42ed 48				db WORD_SYS_CORE+52             
42ee a0 43			dw .FIND            
42f0 07				db 6 + 1 
42f1 .. 00			db "CONCAT",0              
42f8				endm 
# End of macro CWHEAD
42f8			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
42f8			 
42f8			; TODO check string type 
42f8			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
42f8			 
42f8					if DEBUG_FORTH_WORDS_KEY 
42f8						DMARK "CON" 
42f8 f5				push af  
42f9 3a 0d 43			ld a, (.dmark)  
42fc 32 77 fb			ld (debug_mark),a  
42ff 3a 0e 43			ld a, (.dmark+1)  
4302 32 78 fb			ld (debug_mark+1),a  
4305 3a 0f 43			ld a, (.dmark+2)  
4308 32 79 fb			ld (debug_mark+2),a  
430b 18 03			jr .pastdmark  
430d ..			.dmark: db "CON"  
4310 f1			.pastdmark: pop af  
4311			endm  
# End of macro DMARK
4311						CALLMONITOR 
4311 cd 4d 17			call break_point_state  
4314				endm  
# End of macro CALLMONITOR
4314					endif 
4314			 
4314			 
4314					FORTH_DSP_VALUE 
4314 cd bd 1e			call macro_forth_dsp_value 
4317				endm 
# End of macro FORTH_DSP_VALUE
4317 e5					push hl   ; s2 
4318			 
4318					FORTH_DSP_POP 
4318 cd 8c 1f			call macro_forth_dsp_pop 
431b				endm 
# End of macro FORTH_DSP_POP
431b			 
431b					FORTH_DSP_VALUE 
431b cd bd 1e			call macro_forth_dsp_value 
431e				endm 
# End of macro FORTH_DSP_VALUE
431e			 
431e e5					push hl   ; s1 
431f			 
431f					FORTH_DSP_POP 
431f cd 8c 1f			call macro_forth_dsp_pop 
4322				endm 
# End of macro FORTH_DSP_POP
4322					 
4322			 
4322					; copy s1 
4322			 
4322				 
4322					; save ptr 
4322 e1					pop hl  
4323 e5					push hl 
4324 3e 00				ld a, 0 
4326 cd 72 11				call strlent 
4329					;inc hl    ; zer0 
4329 06 00				ld b, 0 
432b 4d					ld c, l 
432c e1					pop hl		 
432d 11 1d ee				ld de, scratch	 
4330					if DEBUG_FORTH_WORDS 
4330						DMARK "CO1" 
4330 f5				push af  
4331 3a 45 43			ld a, (.dmark)  
4334 32 77 fb			ld (debug_mark),a  
4337 3a 46 43			ld a, (.dmark+1)  
433a 32 78 fb			ld (debug_mark+1),a  
433d 3a 47 43			ld a, (.dmark+2)  
4340 32 79 fb			ld (debug_mark+2),a  
4343 18 03			jr .pastdmark  
4345 ..			.dmark: db "CO1"  
4348 f1			.pastdmark: pop af  
4349			endm  
# End of macro DMARK
4349						CALLMONITOR 
4349 cd 4d 17			call break_point_state  
434c				endm  
# End of macro CALLMONITOR
434c					endif 
434c ed b0				ldir 
434e			 
434e e1					pop hl 
434f e5					push hl 
4350 d5					push de 
4351			 
4351			 
4351 3e 00				ld a, 0 
4353 cd 72 11				call strlent 
4356 23					inc hl    ; zer0 
4357 23					inc hl 
4358 06 00				ld b, 0 
435a 4d					ld c, l 
435b d1					pop de 
435c e1					pop hl		 
435d					if DEBUG_FORTH_WORDS 
435d						DMARK "CO2" 
435d f5				push af  
435e 3a 72 43			ld a, (.dmark)  
4361 32 77 fb			ld (debug_mark),a  
4364 3a 73 43			ld a, (.dmark+1)  
4367 32 78 fb			ld (debug_mark+1),a  
436a 3a 74 43			ld a, (.dmark+2)  
436d 32 79 fb			ld (debug_mark+2),a  
4370 18 03			jr .pastdmark  
4372 ..			.dmark: db "CO2"  
4375 f1			.pastdmark: pop af  
4376			endm  
# End of macro DMARK
4376						CALLMONITOR 
4376 cd 4d 17			call break_point_state  
4379				endm  
# End of macro CALLMONITOR
4379					endif 
4379 ed b0				ldir 
437b			 
437b			 
437b			 
437b 21 1d ee				ld hl, scratch 
437e					if DEBUG_FORTH_WORDS 
437e						DMARK "CO5" 
437e f5				push af  
437f 3a 93 43			ld a, (.dmark)  
4382 32 77 fb			ld (debug_mark),a  
4385 3a 94 43			ld a, (.dmark+1)  
4388 32 78 fb			ld (debug_mark+1),a  
438b 3a 95 43			ld a, (.dmark+2)  
438e 32 79 fb			ld (debug_mark+2),a  
4391 18 03			jr .pastdmark  
4393 ..			.dmark: db "CO5"  
4396 f1			.pastdmark: pop af  
4397			endm  
# End of macro DMARK
4397						CALLMONITOR 
4397 cd 4d 17			call break_point_state  
439a				endm  
# End of macro CALLMONITOR
439a					endif 
439a			 
439a cd 4b 1d				call forth_push_str 
439d			 
439d			 
439d			 
439d			 
439d				       NEXTW 
439d c3 46 20			jp macro_next 
43a0				endm 
# End of macro NEXTW
43a0			 
43a0			 
43a0			.FIND: 
43a0				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
43a0 4b				db WORD_SYS_CORE+55             
43a1 5e 44			dw .LEN            
43a3 05				db 4 + 1 
43a4 .. 00			db "FIND",0              
43a9				endm 
# End of macro CWHEAD
43a9			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
43a9			 
43a9					if DEBUG_FORTH_WORDS_KEY 
43a9						DMARK "FND" 
43a9 f5				push af  
43aa 3a be 43			ld a, (.dmark)  
43ad 32 77 fb			ld (debug_mark),a  
43b0 3a bf 43			ld a, (.dmark+1)  
43b3 32 78 fb			ld (debug_mark+1),a  
43b6 3a c0 43			ld a, (.dmark+2)  
43b9 32 79 fb			ld (debug_mark+2),a  
43bc 18 03			jr .pastdmark  
43be ..			.dmark: db "FND"  
43c1 f1			.pastdmark: pop af  
43c2			endm  
# End of macro DMARK
43c2						CALLMONITOR 
43c2 cd 4d 17			call break_point_state  
43c5				endm  
# End of macro CALLMONITOR
43c5					endif 
43c5			 
43c5			; TODO check string type 
43c5					FORTH_DSP_VALUE 
43c5 cd bd 1e			call macro_forth_dsp_value 
43c8				endm 
# End of macro FORTH_DSP_VALUE
43c8			 
43c8 e5					push hl    
43c9 7e					ld a,(hl)    ; char to find   
43ca			; TODO change char to substr 
43ca			 
43ca f5					push af 
43cb					 
43cb			 
43cb			 
43cb					if DEBUG_FORTH_WORDS 
43cb						DMARK "FN1" 
43cb f5				push af  
43cc 3a e0 43			ld a, (.dmark)  
43cf 32 77 fb			ld (debug_mark),a  
43d2 3a e1 43			ld a, (.dmark+1)  
43d5 32 78 fb			ld (debug_mark+1),a  
43d8 3a e2 43			ld a, (.dmark+2)  
43db 32 79 fb			ld (debug_mark+2),a  
43de 18 03			jr .pastdmark  
43e0 ..			.dmark: db "FN1"  
43e3 f1			.pastdmark: pop af  
43e4			endm  
# End of macro DMARK
43e4						CALLMONITOR 
43e4 cd 4d 17			call break_point_state  
43e7				endm  
# End of macro CALLMONITOR
43e7					endif 
43e7			 
43e7					FORTH_DSP_POP 
43e7 cd 8c 1f			call macro_forth_dsp_pop 
43ea				endm 
# End of macro FORTH_DSP_POP
43ea			 
43ea					; string to search 
43ea			 
43ea					FORTH_DSP_VALUE 
43ea cd bd 1e			call macro_forth_dsp_value 
43ed				endm 
# End of macro FORTH_DSP_VALUE
43ed			 
43ed d1					pop de  ; d is char to find  
43ee			 
43ee					if DEBUG_FORTH_WORDS 
43ee						DMARK "FN2" 
43ee f5				push af  
43ef 3a 03 44			ld a, (.dmark)  
43f2 32 77 fb			ld (debug_mark),a  
43f5 3a 04 44			ld a, (.dmark+1)  
43f8 32 78 fb			ld (debug_mark+1),a  
43fb 3a 05 44			ld a, (.dmark+2)  
43fe 32 79 fb			ld (debug_mark+2),a  
4401 18 03			jr .pastdmark  
4403 ..			.dmark: db "FN2"  
4406 f1			.pastdmark: pop af  
4407			endm  
# End of macro DMARK
4407						CALLMONITOR 
4407 cd 4d 17			call break_point_state  
440a				endm  
# End of macro CALLMONITOR
440a					endif 
440a					 
440a 01 00 00				ld bc, 0 
440d 7e			.findchar:      ld a,(hl) 
440e fe 00				cp 0   		 
4410 28 27				jr z, .finddone     
4412 ba					cp d 
4413 28 20				jr z, .foundchar 
4415 03					inc bc 
4416 23					inc hl 
4417					if DEBUG_FORTH_WORDS 
4417						DMARK "FN3" 
4417 f5				push af  
4418 3a 2c 44			ld a, (.dmark)  
441b 32 77 fb			ld (debug_mark),a  
441e 3a 2d 44			ld a, (.dmark+1)  
4421 32 78 fb			ld (debug_mark+1),a  
4424 3a 2e 44			ld a, (.dmark+2)  
4427 32 79 fb			ld (debug_mark+2),a  
442a 18 03			jr .pastdmark  
442c ..			.dmark: db "FN3"  
442f f1			.pastdmark: pop af  
4430			endm  
# End of macro DMARK
4430						CALLMONITOR 
4430 cd 4d 17			call break_point_state  
4433				endm  
# End of macro CALLMONITOR
4433					endif 
4433 18 d8				jr .findchar 
4435			 
4435			 
4435 c5			.foundchar:	push bc 
4436 e1					pop hl 
4437 18 03				jr .findexit 
4439			 
4439			 
4439							 
4439			 
4439			.finddone:     ; got to end of string with no find 
4439 21 00 00				ld hl, 0 
443c			.findexit: 
443c			 
443c					if DEBUG_FORTH_WORDS 
443c						DMARK "FNd" 
443c f5				push af  
443d 3a 51 44			ld a, (.dmark)  
4440 32 77 fb			ld (debug_mark),a  
4443 3a 52 44			ld a, (.dmark+1)  
4446 32 78 fb			ld (debug_mark+1),a  
4449 3a 53 44			ld a, (.dmark+2)  
444c 32 79 fb			ld (debug_mark+2),a  
444f 18 03			jr .pastdmark  
4451 ..			.dmark: db "FNd"  
4454 f1			.pastdmark: pop af  
4455			endm  
# End of macro DMARK
4455						CALLMONITOR 
4455 cd 4d 17			call break_point_state  
4458				endm  
# End of macro CALLMONITOR
4458					endif 
4458 cd dd 1c			call forth_push_numhl 
445b			 
445b				       NEXTW 
445b c3 46 20			jp macro_next 
445e				endm 
# End of macro NEXTW
445e			 
445e			.LEN: 
445e				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
445e 4c				db WORD_SYS_CORE+56             
445f 93 44			dw .CHAR            
4461 06				db 5 + 1 
4462 .. 00			db "COUNT",0              
4468				endm 
# End of macro CWHEAD
4468			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
4468			 
4468					if DEBUG_FORTH_WORDS_KEY 
4468						DMARK "CNT" 
4468 f5				push af  
4469 3a 7d 44			ld a, (.dmark)  
446c 32 77 fb			ld (debug_mark),a  
446f 3a 7e 44			ld a, (.dmark+1)  
4472 32 78 fb			ld (debug_mark+1),a  
4475 3a 7f 44			ld a, (.dmark+2)  
4478 32 79 fb			ld (debug_mark+2),a  
447b 18 03			jr .pastdmark  
447d ..			.dmark: db "CNT"  
4480 f1			.pastdmark: pop af  
4481			endm  
# End of macro DMARK
4481						CALLMONITOR 
4481 cd 4d 17			call break_point_state  
4484				endm  
# End of macro CALLMONITOR
4484					endif 
4484			; TODO check string type 
4484					FORTH_DSP 
4484 cd 9a 1e			call macro_forth_dsp 
4487				endm 
# End of macro FORTH_DSP
4487					;v5FORTH_DSP_VALUE 
4487			 
4487 23					inc hl 
4488			 
4488 3e 00				ld a, 0 
448a cd 72 11				call strlent 
448d			 
448d cd dd 1c				call forth_push_numhl 
4490			 
4490			 
4490			 
4490				       NEXTW 
4490 c3 46 20			jp macro_next 
4493				endm 
# End of macro NEXTW
4493			.CHAR: 
4493				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
4493 4d				db WORD_SYS_CORE+57             
4494 c9 44			dw .ENDSTR            
4496 05				db 4 + 1 
4497 .. 00			db "CHAR",0              
449c				endm 
# End of macro CWHEAD
449c			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
449c					if DEBUG_FORTH_WORDS_KEY 
449c						DMARK "CHR" 
449c f5				push af  
449d 3a b1 44			ld a, (.dmark)  
44a0 32 77 fb			ld (debug_mark),a  
44a3 3a b2 44			ld a, (.dmark+1)  
44a6 32 78 fb			ld (debug_mark+1),a  
44a9 3a b3 44			ld a, (.dmark+2)  
44ac 32 79 fb			ld (debug_mark+2),a  
44af 18 03			jr .pastdmark  
44b1 ..			.dmark: db "CHR"  
44b4 f1			.pastdmark: pop af  
44b5			endm  
# End of macro DMARK
44b5						CALLMONITOR 
44b5 cd 4d 17			call break_point_state  
44b8				endm  
# End of macro CALLMONITOR
44b8					endif 
44b8					FORTH_DSP 
44b8 cd 9a 1e			call macro_forth_dsp 
44bb				endm 
# End of macro FORTH_DSP
44bb					;v5 FORTH_DSP_VALUE 
44bb 23					inc hl      ; now at start of numeric as string 
44bc			 
44bc			;		push hl 
44bc			 
44bc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
44bc cd 8c 1f			call macro_forth_dsp_pop 
44bf				endm 
# End of macro FORTH_DSP_POP
44bf			 
44bf			;		pop hl 
44bf			 
44bf					; push the content of a onto the stack as a value 
44bf			 
44bf 7e					ld a,(hl)   ; get char 
44c0 26 00				ld h,0 
44c2 6f					ld l,a 
44c3 cd dd 1c				call forth_push_numhl 
44c6			 
44c6				       NEXTW 
44c6 c3 46 20			jp macro_next 
44c9				endm 
# End of macro NEXTW
44c9			 
44c9			 
44c9			 
44c9			 
44c9			.ENDSTR: 
44c9			; eof 
44c9			 
# End of file forth_words_str.asm
44c9			include "forth_words_key.asm" 
44c9			 
44c9			; | ## Keyboard Words 
44c9			 
44c9			.KEY: 
44c9				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
44c9 3e				db WORD_SYS_CORE+42             
44ca f9 44			dw .WAITK            
44cc 04				db 3 + 1 
44cd .. 00			db "KEY",0              
44d1				endm 
# End of macro CWHEAD
44d1			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
44d1			 
44d1					if DEBUG_FORTH_WORDS_KEY 
44d1						DMARK "KEY" 
44d1 f5				push af  
44d2 3a e6 44			ld a, (.dmark)  
44d5 32 77 fb			ld (debug_mark),a  
44d8 3a e7 44			ld a, (.dmark+1)  
44db 32 78 fb			ld (debug_mark+1),a  
44de 3a e8 44			ld a, (.dmark+2)  
44e1 32 79 fb			ld (debug_mark+2),a  
44e4 18 03			jr .pastdmark  
44e6 ..			.dmark: db "KEY"  
44e9 f1			.pastdmark: pop af  
44ea			endm  
# End of macro DMARK
44ea						CALLMONITOR 
44ea cd 4d 17			call break_point_state  
44ed				endm  
# End of macro CALLMONITOR
44ed					endif 
44ed			; TODO currently waits 
44ed cd c6 68				call cin 
44f0					;call cin_wait 
44f0 6f					ld l, a 
44f1 26 00				ld h, 0 
44f3 cd dd 1c				call forth_push_numhl 
44f6					NEXTW 
44f6 c3 46 20			jp macro_next 
44f9				endm 
# End of macro NEXTW
44f9			.WAITK: 
44f9				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
44f9 3f				db WORD_SYS_CORE+43             
44fa 2b 45			dw .ACCEPT            
44fc 06				db 5 + 1 
44fd .. 00			db "WAITK",0              
4503				endm 
# End of macro CWHEAD
4503			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4503					if DEBUG_FORTH_WORDS_KEY 
4503						DMARK "WAI" 
4503 f5				push af  
4504 3a 18 45			ld a, (.dmark)  
4507 32 77 fb			ld (debug_mark),a  
450a 3a 19 45			ld a, (.dmark+1)  
450d 32 78 fb			ld (debug_mark+1),a  
4510 3a 1a 45			ld a, (.dmark+2)  
4513 32 79 fb			ld (debug_mark+2),a  
4516 18 03			jr .pastdmark  
4518 ..			.dmark: db "WAI"  
451b f1			.pastdmark: pop af  
451c			endm  
# End of macro DMARK
451c						CALLMONITOR 
451c cd 4d 17			call break_point_state  
451f				endm  
# End of macro CALLMONITOR
451f					endif 
451f cd b5 68				call cin_wait 
4522 6f					ld l, a 
4523 26 00				ld h, 0 
4525 cd dd 1c				call forth_push_numhl 
4528					NEXTW 
4528 c3 46 20			jp macro_next 
452b				endm 
# End of macro NEXTW
452b			.ACCEPT: 
452b				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
452b 40				db WORD_SYS_CORE+44             
452c 89 45			dw .EDIT            
452e 07				db 6 + 1 
452f .. 00			db "ACCEPT",0              
4536				endm 
# End of macro CWHEAD
4536			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
4536					; TODO crashes on push 
4536					if DEBUG_FORTH_WORDS_KEY 
4536						DMARK "ACC" 
4536 f5				push af  
4537 3a 4b 45			ld a, (.dmark)  
453a 32 77 fb			ld (debug_mark),a  
453d 3a 4c 45			ld a, (.dmark+1)  
4540 32 78 fb			ld (debug_mark+1),a  
4543 3a 4d 45			ld a, (.dmark+2)  
4546 32 79 fb			ld (debug_mark+2),a  
4549 18 03			jr .pastdmark  
454b ..			.dmark: db "ACC"  
454e f1			.pastdmark: pop af  
454f			endm  
# End of macro DMARK
454f						CALLMONITOR 
454f cd 4d 17			call break_point_state  
4552				endm  
# End of macro CALLMONITOR
4552					endif 
4552 21 1b f0				ld hl, os_input 
4555 3e 00				ld a, 0 
4557 77					ld (hl),a 
4558 3a 46 f8				ld a,(f_cursor_ptr) 
455b 16 64				ld d, 100 
455d 0e 00				ld c, 0 
455f 1e 28				ld e, 40 
4561 cd 36 0d				call input_str 
4564					; TODO perhaps do a type check and wrap in quotes if not a number 
4564 21 1b f0				ld hl, os_input 
4567					if DEBUG_FORTH_WORDS 
4567						DMARK "AC1" 
4567 f5				push af  
4568 3a 7c 45			ld a, (.dmark)  
456b 32 77 fb			ld (debug_mark),a  
456e 3a 7d 45			ld a, (.dmark+1)  
4571 32 78 fb			ld (debug_mark+1),a  
4574 3a 7e 45			ld a, (.dmark+2)  
4577 32 79 fb			ld (debug_mark+2),a  
457a 18 03			jr .pastdmark  
457c ..			.dmark: db "AC1"  
457f f1			.pastdmark: pop af  
4580			endm  
# End of macro DMARK
4580						CALLMONITOR 
4580 cd 4d 17			call break_point_state  
4583				endm  
# End of macro CALLMONITOR
4583					endif 
4583 cd 4b 1d				call forth_push_str 
4586					NEXTW 
4586 c3 46 20			jp macro_next 
4589				endm 
# End of macro NEXTW
4589			 
4589			.EDIT: 
4589				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
4589 40				db WORD_SYS_CORE+44             
458a 12 46			dw .ENDKEY            
458c 05				db 4 + 1 
458d .. 00			db "EDIT",0              
4592				endm 
# End of macro CWHEAD
4592			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4592			 
4592					; TODO does not copy from stack 
4592					if DEBUG_FORTH_WORDS_KEY 
4592						DMARK "EDT" 
4592 f5				push af  
4593 3a a7 45			ld a, (.dmark)  
4596 32 77 fb			ld (debug_mark),a  
4599 3a a8 45			ld a, (.dmark+1)  
459c 32 78 fb			ld (debug_mark+1),a  
459f 3a a9 45			ld a, (.dmark+2)  
45a2 32 79 fb			ld (debug_mark+2),a  
45a5 18 03			jr .pastdmark  
45a7 ..			.dmark: db "EDT"  
45aa f1			.pastdmark: pop af  
45ab			endm  
# End of macro DMARK
45ab						CALLMONITOR 
45ab cd 4d 17			call break_point_state  
45ae				endm  
# End of macro CALLMONITOR
45ae					endif 
45ae			 
45ae					FORTH_DSP 
45ae cd 9a 1e			call macro_forth_dsp 
45b1				endm 
# End of macro FORTH_DSP
45b1					;v5 FORTH_DSP_VALUE 
45b1 23					inc hl    ; TODO do type check 
45b2			 
45b2 e5					push hl 
45b3 3e 00				ld a, 0 
45b5 cd 72 11				call strlent 
45b8 23					inc hl 
45b9			 
45b9 06 00				ld b, 0 
45bb 4d					ld c, l 
45bc			 
45bc e1					pop hl 
45bd 11 1b f0				ld de, os_input 
45c0					if DEBUG_FORTH_WORDS_KEY 
45c0						DMARK "EDc" 
45c0 f5				push af  
45c1 3a d5 45			ld a, (.dmark)  
45c4 32 77 fb			ld (debug_mark),a  
45c7 3a d6 45			ld a, (.dmark+1)  
45ca 32 78 fb			ld (debug_mark+1),a  
45cd 3a d7 45			ld a, (.dmark+2)  
45d0 32 79 fb			ld (debug_mark+2),a  
45d3 18 03			jr .pastdmark  
45d5 ..			.dmark: db "EDc"  
45d8 f1			.pastdmark: pop af  
45d9			endm  
# End of macro DMARK
45d9						CALLMONITOR 
45d9 cd 4d 17			call break_point_state  
45dc				endm  
# End of macro CALLMONITOR
45dc					endif 
45dc ed b0				ldir 
45de			 
45de			 
45de 21 1b f0				ld hl, os_input 
45e1					;ld a, 0 
45e1					;ld (hl),a 
45e1 3a 46 f8				ld a,(f_cursor_ptr) 
45e4 16 64				ld d, 100 
45e6 0e 00				ld c, 0 
45e8 1e 28				ld e, 40 
45ea cd 36 0d				call input_str 
45ed					; TODO perhaps do a type check and wrap in quotes if not a number 
45ed 21 1b f0				ld hl, os_input 
45f0					if DEBUG_FORTH_WORDS 
45f0						DMARK "ED1" 
45f0 f5				push af  
45f1 3a 05 46			ld a, (.dmark)  
45f4 32 77 fb			ld (debug_mark),a  
45f7 3a 06 46			ld a, (.dmark+1)  
45fa 32 78 fb			ld (debug_mark+1),a  
45fd 3a 07 46			ld a, (.dmark+2)  
4600 32 79 fb			ld (debug_mark+2),a  
4603 18 03			jr .pastdmark  
4605 ..			.dmark: db "ED1"  
4608 f1			.pastdmark: pop af  
4609			endm  
# End of macro DMARK
4609						CALLMONITOR 
4609 cd 4d 17			call break_point_state  
460c				endm  
# End of macro CALLMONITOR
460c					endif 
460c cd 4b 1d				call forth_push_str 
460f					NEXTW 
460f c3 46 20			jp macro_next 
4612				endm 
# End of macro NEXTW
4612			 
4612			 
4612			 
4612			.ENDKEY: 
4612			; eof 
4612			 
# End of file forth_words_key.asm
4612			 
4612			if STORAGE_SE 
4612			   	include "forth_words_storage.asm" 
4612			 
4612			; | ## Fixed Storage Words 
4612			 
4612			 
4612			.BREAD: 
4612			  
4612				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
4612 3a				db WORD_SYS_CORE+38             
4613 8b 46			dw .BWRITE            
4615 06				db 5 + 1 
4616 .. 00			db "BREAD",0              
461c				endm 
# End of macro CWHEAD
461c			; | BREAD ( u -- u ) With the current bank, read a block from block address u (1-512) and push to stack  | DONE 
461c				 
461c					if DEBUG_FORTH_WORDS_KEY 
461c						DMARK "BRD" 
461c f5				push af  
461d 3a 31 46			ld a, (.dmark)  
4620 32 77 fb			ld (debug_mark),a  
4623 3a 32 46			ld a, (.dmark+1)  
4626 32 78 fb			ld (debug_mark+1),a  
4629 3a 33 46			ld a, (.dmark+2)  
462c 32 79 fb			ld (debug_mark+2),a  
462f 18 03			jr .pastdmark  
4631 ..			.dmark: db "BRD"  
4634 f1			.pastdmark: pop af  
4635			endm  
# End of macro DMARK
4635						CALLMONITOR 
4635 cd 4d 17			call break_point_state  
4638				endm  
# End of macro CALLMONITOR
4638					endif 
4638			 
4638				FORTH_DSP_VALUEHL 
4638 cd d4 1e			call macro_dsp_valuehl 
463b				endm 
# End of macro FORTH_DSP_VALUEHL
463b			 
463b				FORTH_DSP_POP 
463b cd 8c 1f			call macro_forth_dsp_pop 
463e				endm 
# End of macro FORTH_DSP_POP
463e			 
463e				; calc block address 
463e			 
463e eb				ex de, hl 
463f 3e 40			ld a, STORE_BLOCK_PHY 
4641 cd 8c 0c			call Mult16 
4644			 
4644			 
4644 11 62 f8			ld de, store_page 
4647			 
4647					if DEBUG_FORTH_WORDS 
4647						DMARK "BR1" 
4647 f5				push af  
4648 3a 5c 46			ld a, (.dmark)  
464b 32 77 fb			ld (debug_mark),a  
464e 3a 5d 46			ld a, (.dmark+1)  
4651 32 78 fb			ld (debug_mark+1),a  
4654 3a 5e 46			ld a, (.dmark+2)  
4657 32 79 fb			ld (debug_mark+2),a  
465a 18 03			jr .pastdmark  
465c ..			.dmark: db "BR1"  
465f f1			.pastdmark: pop af  
4660			endm  
# End of macro DMARK
4660						CALLMONITOR 
4660 cd 4d 17			call break_point_state  
4663				endm  
# End of macro CALLMONITOR
4663					endif 
4663			 
4663 cd 0c 03			call storage_read_block 
4666			 
4666 21 64 f8		        ld hl, store_page+2 
4669					if DEBUG_FORTH_WORDS 
4669						DMARK "BR2" 
4669 f5				push af  
466a 3a 7e 46			ld a, (.dmark)  
466d 32 77 fb			ld (debug_mark),a  
4670 3a 7f 46			ld a, (.dmark+1)  
4673 32 78 fb			ld (debug_mark+1),a  
4676 3a 80 46			ld a, (.dmark+2)  
4679 32 79 fb			ld (debug_mark+2),a  
467c 18 03			jr .pastdmark  
467e ..			.dmark: db "BR2"  
4681 f1			.pastdmark: pop af  
4682			endm  
# End of macro DMARK
4682						CALLMONITOR 
4682 cd 4d 17			call break_point_state  
4685				endm  
# End of macro CALLMONITOR
4685					endif 
4685 cd 4b 1d			call forth_push_str 
4688			 
4688			 
4688					NEXTW 
4688 c3 46 20			jp macro_next 
468b				endm 
# End of macro NEXTW
468b			.BWRITE: 
468b				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
468b 3a				db WORD_SYS_CORE+38             
468c 20 47			dw .BUPD            
468e 07				db 6 + 1 
468f .. 00			db "BWRITE",0              
4696				endm 
# End of macro CWHEAD
4696			; | BWRITE ( s u -- ) With the current bank, write the string s to address u | DONE 
4696			 
4696					if DEBUG_FORTH_WORDS_KEY 
4696						DMARK "BWR" 
4696 f5				push af  
4697 3a ab 46			ld a, (.dmark)  
469a 32 77 fb			ld (debug_mark),a  
469d 3a ac 46			ld a, (.dmark+1)  
46a0 32 78 fb			ld (debug_mark+1),a  
46a3 3a ad 46			ld a, (.dmark+2)  
46a6 32 79 fb			ld (debug_mark+2),a  
46a9 18 03			jr .pastdmark  
46ab ..			.dmark: db "BWR"  
46ae f1			.pastdmark: pop af  
46af			endm  
# End of macro DMARK
46af						CALLMONITOR 
46af cd 4d 17			call break_point_state  
46b2				endm  
# End of macro CALLMONITOR
46b2					endif 
46b2			 
46b2				FORTH_DSP_VALUEHL 
46b2 cd d4 1e			call macro_dsp_valuehl 
46b5				endm 
# End of macro FORTH_DSP_VALUEHL
46b5			 
46b5				; calc block address 
46b5			 
46b5 eb				ex de, hl 
46b6 3e 40			ld a, STORE_BLOCK_PHY 
46b8 cd 8c 0c			call Mult16 
46bb			 
46bb e5				push hl         ; address 
46bc			 
46bc				FORTH_DSP_POP 
46bc cd 8c 1f			call macro_forth_dsp_pop 
46bf				endm 
# End of macro FORTH_DSP_POP
46bf			 
46bf				FORTH_DSP_VALUEHL 
46bf cd d4 1e			call macro_dsp_valuehl 
46c2				endm 
# End of macro FORTH_DSP_VALUEHL
46c2			 
46c2				FORTH_DSP_POP 
46c2 cd 8c 1f			call macro_forth_dsp_pop 
46c5				endm 
# End of macro FORTH_DSP_POP
46c5			 
46c5 cd 18 0a			call storage_clear_page 
46c8			 
46c8				; copy string to store page 
46c8			 
46c8 e5				push hl     ; save string address 
46c9			 
46c9 3e 00			ld a, 0 
46cb cd 72 11			call strlent 
46ce			 
46ce 23				inc hl 
46cf			 
46cf 4d				ld c, l 
46d0 06 00			ld b, 0 
46d2			 
46d2 e1				pop hl 
46d3 11 64 f8			ld de, store_page + 2 
46d6					if DEBUG_FORTH_WORDS 
46d6						DMARK "BW1" 
46d6 f5				push af  
46d7 3a eb 46			ld a, (.dmark)  
46da 32 77 fb			ld (debug_mark),a  
46dd 3a ec 46			ld a, (.dmark+1)  
46e0 32 78 fb			ld (debug_mark+1),a  
46e3 3a ed 46			ld a, (.dmark+2)  
46e6 32 79 fb			ld (debug_mark+2),a  
46e9 18 03			jr .pastdmark  
46eb ..			.dmark: db "BW1"  
46ee f1			.pastdmark: pop af  
46ef			endm  
# End of macro DMARK
46ef						CALLMONITOR 
46ef cd 4d 17			call break_point_state  
46f2				endm  
# End of macro CALLMONITOR
46f2					endif 
46f2 ed b0			ldir 
46f4			 
46f4			 
46f4				; poke the start of the block with flags to prevent high level file ops hitting the block 
46f4			 
46f4 21 ff ff			ld hl, $ffff 
46f7			 
46f7 22 62 f8			ld (store_page), hl	 
46fa				 
46fa e1				pop hl    ; get address 
46fb 11 62 f8			ld de, store_page 
46fe			 
46fe					if DEBUG_FORTH_WORDS 
46fe						DMARK "BW2" 
46fe f5				push af  
46ff 3a 13 47			ld a, (.dmark)  
4702 32 77 fb			ld (debug_mark),a  
4705 3a 14 47			ld a, (.dmark+1)  
4708 32 78 fb			ld (debug_mark+1),a  
470b 3a 15 47			ld a, (.dmark+2)  
470e 32 79 fb			ld (debug_mark+2),a  
4711 18 03			jr .pastdmark  
4713 ..			.dmark: db "BW2"  
4716 f1			.pastdmark: pop af  
4717			endm  
# End of macro DMARK
4717						CALLMONITOR 
4717 cd 4d 17			call break_point_state  
471a				endm  
# End of macro CALLMONITOR
471a					endif 
471a			 
471a cd 71 03			call storage_write_block 
471d			 
471d					NEXTW 
471d c3 46 20			jp macro_next 
4720				endm 
# End of macro NEXTW
4720			 
4720			.BUPD: 
4720				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
4720 3a				db WORD_SYS_CORE+38             
4721 76 47			dw .BYID            
4723 05				db 4 + 1 
4724 .. 00			db "BUPD",0              
4729				endm 
# End of macro CWHEAD
4729			; | BUPD ( u -- ) Write the contents of the current file system storage buffer directly to address u | DONE 
4729			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
4729			; | | or completely different file system structure. 
4729			 
4729					if DEBUG_FORTH_WORDS_KEY 
4729						DMARK "BUD" 
4729 f5				push af  
472a 3a 3e 47			ld a, (.dmark)  
472d 32 77 fb			ld (debug_mark),a  
4730 3a 3f 47			ld a, (.dmark+1)  
4733 32 78 fb			ld (debug_mark+1),a  
4736 3a 40 47			ld a, (.dmark+2)  
4739 32 79 fb			ld (debug_mark+2),a  
473c 18 03			jr .pastdmark  
473e ..			.dmark: db "BUD"  
4741 f1			.pastdmark: pop af  
4742			endm  
# End of macro DMARK
4742						CALLMONITOR 
4742 cd 4d 17			call break_point_state  
4745				endm  
# End of macro CALLMONITOR
4745					endif 
4745			 
4745				FORTH_DSP_VALUEHL 
4745 cd d4 1e			call macro_dsp_valuehl 
4748				endm 
# End of macro FORTH_DSP_VALUEHL
4748			 
4748				; calc block address 
4748			 
4748 eb				ex de, hl 
4749 3e 40			ld a, STORE_BLOCK_PHY 
474b cd 8c 0c			call Mult16 
474e			 
474e				FORTH_DSP_POP 
474e cd 8c 1f			call macro_forth_dsp_pop 
4751				endm 
# End of macro FORTH_DSP_POP
4751			 
4751			 
4751 11 62 f8			ld de, store_page 
4754			 
4754					if DEBUG_FORTH_WORDS 
4754						DMARK "BUe" 
4754 f5				push af  
4755 3a 69 47			ld a, (.dmark)  
4758 32 77 fb			ld (debug_mark),a  
475b 3a 6a 47			ld a, (.dmark+1)  
475e 32 78 fb			ld (debug_mark+1),a  
4761 3a 6b 47			ld a, (.dmark+2)  
4764 32 79 fb			ld (debug_mark+2),a  
4767 18 03			jr .pastdmark  
4769 ..			.dmark: db "BUe"  
476c f1			.pastdmark: pop af  
476d			endm  
# End of macro DMARK
476d						CALLMONITOR 
476d cd 4d 17			call break_point_state  
4770				endm  
# End of macro CALLMONITOR
4770					endif 
4770			 
4770 cd 71 03			call storage_write_block 
4773			 
4773					NEXTW 
4773 c3 46 20			jp macro_next 
4776				endm 
# End of macro NEXTW
4776			 
4776			.BYID: 
4776			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
4776			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
4776			; 
4776			;		 
4776			;		if DEBUG_FORTH_WORDS_KEY 
4776			;			DMARK "BYID" 
4776			;			CALLMONITOR 
4776			;		endif 
4776			; 
4776			;		; get direct address 
4776			; 
4776			;		FORTH_DSP_VALUEHL 
4776			; 
4776			;		FORTH_DSP_POP 
4776			; 
4776			;	; calc block address 
4776			; 
4776			;	ex de, hl 
4776			;	ld a, STORE_BLOCK_PHY 
4776			;	call Mult16 
4776			;	;	do BREAD with number as param 
4776			;	; push the file name	 
4776			;	ld de, store_page 
4776			;	call storage_read_block 
4776			 ;       ld hl, store_page+2 
4776			; 
4776			; 
4776			;		NEXTW 
4776			;.BYNAME: 
4776			;	CWHEAD .DIR 38 "BYNAME" 6 WORD_FLAG_CODE 
4776			;; > BYNAME ( s -- u ) Get the file ID in the current BANK of the file named s > TODO 
4776			;		NEXTW 
4776			; 
4776			.DIR: 
4776				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
4776 3a				db WORD_SYS_CORE+38             
4777 7a 48			dw .SAVE            
4779 04				db 3 + 1 
477a .. 00			db "DIR",0              
477e				endm 
# End of macro CWHEAD
477e			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
477e			 
477e					if DEBUG_FORTH_WORDS_KEY 
477e						DMARK "DIR" 
477e f5				push af  
477f 3a 93 47			ld a, (.dmark)  
4782 32 77 fb			ld (debug_mark),a  
4785 3a 94 47			ld a, (.dmark+1)  
4788 32 78 fb			ld (debug_mark+1),a  
478b 3a 95 47			ld a, (.dmark+2)  
478e 32 79 fb			ld (debug_mark+2),a  
4791 18 03			jr .pastdmark  
4793 ..			.dmark: db "DIR"  
4796 f1			.pastdmark: pop af  
4797			endm  
# End of macro DMARK
4797						CALLMONITOR 
4797 cd 4d 17			call break_point_state  
479a				endm  
# End of macro CALLMONITOR
479a					endif 
479a cd bd 03			call storage_get_block_0 
479d			 
479d 21 62 f8			ld hl, store_page     ; get current id count 
47a0 46				ld b, (hl) 
47a1 0e 00			ld c, 0    ; count of files   
47a3					if DEBUG_FORTH_WORDS 
47a3						DMARK "DI1" 
47a3 f5				push af  
47a4 3a b8 47			ld a, (.dmark)  
47a7 32 77 fb			ld (debug_mark),a  
47aa 3a b9 47			ld a, (.dmark+1)  
47ad 32 78 fb			ld (debug_mark+1),a  
47b0 3a ba 47			ld a, (.dmark+2)  
47b3 32 79 fb			ld (debug_mark+2),a  
47b6 18 03			jr .pastdmark  
47b8 ..			.dmark: db "DI1"  
47bb f1			.pastdmark: pop af  
47bc			endm  
# End of macro DMARK
47bc						CALLMONITOR 
47bc cd 4d 17			call break_point_state  
47bf				endm  
# End of macro CALLMONITOR
47bf					endif 
47bf			 
47bf				; check for empty drive 
47bf			 
47bf 3e 00			ld a, 0 
47c1 b8				cp b 
47c2 ca 30 48			jp z, .dirdone 
47c5			 
47c5				; for each of the current ids do a search for them and if found push to stack 
47c5			 
47c5 c5			.diritem:	push bc 
47c6 21 40 00				ld hl, STORE_BLOCK_PHY 
47c9 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
47cb 58					ld e,b 
47cc			 
47cc			;		if DEBUG_FORTH_WORDS 
47cc			;			DMARK "DI2" 
47cc			;			CALLMONITOR 
47cc			;		endif 
47cc			 
47cc cd 2d 06				call storage_findnextid 
47cf			 
47cf			;		if DEBUG_FORTH_WORDS 
47cf			;			DMARK "DI3" 
47cf			;			CALLMONITOR 
47cf			;		endif 
47cf			 
47cf					; if found hl will be non zero 
47cf			 
47cf cd 32 0d				call ishlzero 
47d2			;		ld a, l 
47d2			;		add h 
47d2			; 
47d2			;		cp 0 
47d2 28 59				jr z, .dirnotfound 
47d4			 
47d4					; increase count 
47d4			 
47d4 c1					pop bc	 
47d5 0c					inc c 
47d6 c5					push bc 
47d7					 
47d7			 
47d7					; get file header and push the file name 
47d7			 
47d7 11 62 f8				ld de, store_page 
47da cd 0c 03				call storage_read_block 
47dd			 
47dd					; push file id to stack 
47dd				 
47dd 3a 62 f8				ld a, (store_page) 
47e0 26 00				ld h, 0 
47e2 6f					ld l, a 
47e3 cd dd 1c				call forth_push_numhl 
47e6			 
47e6					; push extent count to stack  
47e6				 
47e6 3a 64 f8				ld a, (store_page+2) 
47e9 26 00				ld h, 0 
47eb 6f					ld l, a 
47ec cd dd 1c				call forth_push_numhl 
47ef			 
47ef					; push file name 
47ef			 
47ef 21 65 f8				ld hl, store_page+3 
47f2					if DEBUG_FORTH_WORDS 
47f2						DMARK "DI5" 
47f2 f5				push af  
47f3 3a 07 48			ld a, (.dmark)  
47f6 32 77 fb			ld (debug_mark),a  
47f9 3a 08 48			ld a, (.dmark+1)  
47fc 32 78 fb			ld (debug_mark+1),a  
47ff 3a 09 48			ld a, (.dmark+2)  
4802 32 79 fb			ld (debug_mark+2),a  
4805 18 03			jr .pastdmark  
4807 ..			.dmark: db "DI5"  
480a f1			.pastdmark: pop af  
480b			endm  
# End of macro DMARK
480b						CALLMONITOR 
480b cd 4d 17			call break_point_state  
480e				endm  
# End of macro CALLMONITOR
480e					endif 
480e cd 4b 1d				call forth_push_str 
4811					if DEBUG_FORTH_WORDS 
4811						DMARK "DI6" 
4811 f5				push af  
4812 3a 26 48			ld a, (.dmark)  
4815 32 77 fb			ld (debug_mark),a  
4818 3a 27 48			ld a, (.dmark+1)  
481b 32 78 fb			ld (debug_mark+1),a  
481e 3a 28 48			ld a, (.dmark+2)  
4821 32 79 fb			ld (debug_mark+2),a  
4824 18 03			jr .pastdmark  
4826 ..			.dmark: db "DI6"  
4829 f1			.pastdmark: pop af  
482a			endm  
# End of macro DMARK
482a						CALLMONITOR 
482a cd 4d 17			call break_point_state  
482d				endm  
# End of macro CALLMONITOR
482d					endif 
482d			.dirnotfound: 
482d c1					pop bc     
482e 10 95				djnz .diritem 
4830				 
4830			.dirdone:	 
4830					if DEBUG_FORTH_WORDS 
4830						DMARK "DI7" 
4830 f5				push af  
4831 3a 45 48			ld a, (.dmark)  
4834 32 77 fb			ld (debug_mark),a  
4837 3a 46 48			ld a, (.dmark+1)  
483a 32 78 fb			ld (debug_mark+1),a  
483d 3a 47 48			ld a, (.dmark+2)  
4840 32 79 fb			ld (debug_mark+2),a  
4843 18 03			jr .pastdmark  
4845 ..			.dmark: db "DI7"  
4848 f1			.pastdmark: pop af  
4849			endm  
# End of macro DMARK
4849						CALLMONITOR 
4849 cd 4d 17			call break_point_state  
484c				endm  
# End of macro CALLMONITOR
484c					endif 
484c			 
484c					; push a count of the dir items found 
484c			 
484c 26 00				ld h, 0 
484e 69					ld l, c 
484f cd dd 1c				call forth_push_numhl 
4852			 
4852					; push the bank label 
4852			 
4852 cd bd 03				call storage_get_block_0 
4855			 
4855				 
4855 21 65 f8		 		ld hl, store_page+3 
4858			 
4858					if DEBUG_FORTH_WORDS 
4858						DMARK "DI8" 
4858 f5				push af  
4859 3a 6d 48			ld a, (.dmark)  
485c 32 77 fb			ld (debug_mark),a  
485f 3a 6e 48			ld a, (.dmark+1)  
4862 32 78 fb			ld (debug_mark+1),a  
4865 3a 6f 48			ld a, (.dmark+2)  
4868 32 79 fb			ld (debug_mark+2),a  
486b 18 03			jr .pastdmark  
486d ..			.dmark: db "DI8"  
4870 f1			.pastdmark: pop af  
4871			endm  
# End of macro DMARK
4871						CALLMONITOR 
4871 cd 4d 17			call break_point_state  
4874				endm  
# End of macro CALLMONITOR
4874					endif 
4874 cd 4b 1d				call forth_push_str 
4877			 
4877			 
4877				 
4877					NEXTW 
4877 c3 46 20			jp macro_next 
487a				endm 
# End of macro NEXTW
487a			.SAVE: 
487a			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
487a			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
487a			;		NEXTW 
487a			;.LOAD: 
487a			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
487a			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
487a			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
487a			;; > > The LOAD command can not be used in any user words or compound lines. 
487a			; 
487a			;		; store_openext use it. If zero it is EOF 
487a			; 
487a			;		; read block from current stream id 
487a			;		; if the block does not contain zero term keep reading blocks until zero found 
487a			;		; push the block to stack 
487a			;		; save the block id to stream 
487a			; 
487a			; 
487a			;		FORTH_DSP_VALUEHL 
487a			; 
487a			;;		push hl 
487a			; 
487a			;	if DEBUG_STORESE 
487a			;		DMARK "LOA" 
487a			;		CALLMONITOR 
487a			;	endif 
487a			;		FORTH_DSP_POP 
487a			; 
487a			;;		pop hl 
487a			; 
487a			;		ld h, l 
487a			;		ld l, 0 
487a			; 
487a			;		push hl     ; stack holds current file id and extent to work with 
487a			; 
487a			; 
487a			;		ld de, store_page      ; get block zero of file 
487a			;	if DEBUG_STORESE 
487a			;		DMARK "LO0" 
487a			;		CALLMONITOR 
487a			;	endif 
487a			;		call storage_read 
487a			; 
487a			;		ld a, (store_page+2)    ; max extents for this file 
487a			;		ld  (store_openmaxext),a   ; get our limit 
487a			; 
487a			;	if DEBUG_STORESE 
487a			;		DMARK "LOE" 
487a			;		CALLMONITOR 
487a			;	endif 
487a			; 
487a			;; TODO dont know why max extents are not present 
487a			;;		cp 0 
487a			;;		jp z, .loadeof     ; dont read past eof 
487a			; 
487a			;;		ld a, 1   ; start from the head of the file 
487a			; 
487a			;.loadline:	pop hl 
487a			;		inc hl 
487a			;		ld  a, (store_openmaxext)   ; get our limit 
487a			;	if DEBUG_STORESE 
487a			;		DMARK "LOx" 
487a			;		CALLMONITOR 
487a			;	endif 
487a			;		inc a 
487a			;		cp l 
487a			;		jp z, .loadeof 
487a			;		push hl    ; save current extent 
487a			; 
487a			;		ld de, store_page 
487a			; 
487a			;	if DEBUG_STORESE 
487a			;		DMARK "LO1" 
487a			;		CALLMONITOR 
487a			;	endif 
487a			;		call storage_read 
487a			; 
487a			;	if DEBUG_STORESE 
487a			;		DMARK "LO2" 
487a			;		CALLMONITOR 
487a			;	endif 
487a			;	call ishlzero 
487a			;	ld a, l 
487a			;	add h 
487a			;	cp 0 
487a			;	jr z, .loadeof 
487a			; 
487a			;	; not eof so hl should point to data to exec 
487a			; 
487a			;	; will need to add the FORTH_END_BUFFER flag 
487a			 ; 
487a			;	ld hl, store_page+2 
487a			;	ld bc, 255 
487a			;	ld a, 0 
487a			;	cpir 
487a			;	if DEBUG_STORESE 
487a			;		DMARK "LOt" 
487a			;		CALLMONITOR 
487a			;	endif 
487a			;	dec hl 
487a			;	ld a, ' ' 
487a			;	ld (hl), a 
487a			;	inc hl 
487a			;	ld (hl), a 
487a			;	inc hl 
487a			;	ld (hl), a 
487a			;	inc hl 
487a			;	ld a, FORTH_END_BUFFER 
487a			;	ld (hl), a 
487a			; 
487a			;	; TODO handle more than a single block read 
487a			; 
487a			; 
487a			;	ld hl, store_page+2 
487a			; 
487a			;	ld (os_tok_ptr), hl 
487a			; 
487a			;	if DEBUG_STORESE 
487a			;		DMARK "LO3" 
487a			;		CALLMONITOR 
487a			;	endif 
487a			; 
487a			;	call forthparse 
487a			;	call forthexec 
487a			;	call forthexec_cleanup 
487a			; 
487a			;	; go to next extent 
487a			; 
487a			;	; get next block  or mark as eof 
487a			;	jp .loadline 
487a			; 
487a			; 
487a			; 
487a			;	       NEXTW 
487a			;.loadeof:	ld a, 0 
487a			;		ld (store_openext), a 
487a			; 
487a			;	if DEBUG_STORESE 
487a			;		DMARK "LOF" 
487a			;		CALLMONITOR 
487a			;	endif 
487a			;		ret 
487a			;		;NEXTW 
487a			;.BSAVE:   
487a			; 
487a			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
487a			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
487a			;		NEXTW 
487a			;.BLOAD: 
487a			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
487a			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
487a			;		NEXTW 
487a			;;;; counter gap 
487a			 
487a			 
487a			.SEO: 
487a				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
487a 64				db WORD_SYS_CORE+80             
487b 99 48			dw .SEI            
487d 04				db 3 + 1 
487e .. 00			db "SEO",0              
4882				endm 
# End of macro CWHEAD
4882			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
4882			 
4882					; get port 
4882			 
4882					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4882 cd d4 1e			call macro_dsp_valuehl 
4885				endm 
# End of macro FORTH_DSP_VALUEHL
4885			 
4885 e5					push hl    ; u2 - byte 
4886			 
4886					; destroy value TOS 
4886			 
4886					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4886 cd 8c 1f			call macro_forth_dsp_pop 
4889				endm 
# End of macro FORTH_DSP_POP
4889			 
4889					; get byte to send 
4889			 
4889					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4889 cd d4 1e			call macro_dsp_valuehl 
488c				endm 
# End of macro FORTH_DSP_VALUEHL
488c			 
488c e5					push hl    ; u1 - addr 
488d			 
488d					; destroy value TOS 
488d			 
488d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
488d cd 8c 1f			call macro_forth_dsp_pop 
4890				endm 
# End of macro FORTH_DSP_POP
4890			 
4890					; one value on hl get other one back 
4890			 
4890 d1					pop de   ; u1 - byte 
4891			 
4891 e1					pop hl   ; u2 - addr 
4892			 
4892					; TODO Send SPI byte 
4892			 
4892			 
4892 7b					ld a, e 
4893 cd ea 01				call se_writebyte 
4896			 
4896					 
4896			 
4896					NEXTW 
4896 c3 46 20			jp macro_next 
4899				endm 
# End of macro NEXTW
4899			 
4899			.SEI: 
4899				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
4899 65				db WORD_SYS_CORE+81             
489a b3 48			dw .SFREE            
489c 04				db 3 + 1 
489d .. 00			db "SEI",0              
48a1				endm 
# End of macro CWHEAD
48a1			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
48a1			 
48a1					; get port 
48a1			 
48a1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
48a1 cd d4 1e			call macro_dsp_valuehl 
48a4				endm 
# End of macro FORTH_DSP_VALUEHL
48a4			 
48a4			;		push hl 
48a4			 
48a4					; destroy value TOS 
48a4			 
48a4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
48a4 cd 8c 1f			call macro_forth_dsp_pop 
48a7				endm 
# End of macro FORTH_DSP_POP
48a7			 
48a7					; one value on hl get other one back 
48a7			 
48a7			;		pop hl 
48a7			 
48a7			 
48a7					; TODO Get SPI byte 
48a7			 
48a7 cd 8c 02				call se_readbyte 
48aa			 
48aa 26 00				ld h, 0 
48ac 6f					ld l, a 
48ad cd dd 1c				call forth_push_numhl 
48b0			 
48b0					NEXTW 
48b0 c3 46 20			jp macro_next 
48b3				endm 
# End of macro NEXTW
48b3			 
48b3			.SFREE: 
48b3				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
48b3 67				db WORD_SYS_CORE+83             
48b4 e2 48			dw .SIZE            
48b6 06				db 5 + 1 
48b7 .. 00			db "FFREE",0              
48bd				endm 
# End of macro CWHEAD
48bd			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
48bd					if DEBUG_FORTH_WORDS_KEY 
48bd						DMARK "FFR" 
48bd f5				push af  
48be 3a d2 48			ld a, (.dmark)  
48c1 32 77 fb			ld (debug_mark),a  
48c4 3a d3 48			ld a, (.dmark+1)  
48c7 32 78 fb			ld (debug_mark+1),a  
48ca 3a d4 48			ld a, (.dmark+2)  
48cd 32 79 fb			ld (debug_mark+2),a  
48d0 18 03			jr .pastdmark  
48d2 ..			.dmark: db "FFR"  
48d5 f1			.pastdmark: pop af  
48d6			endm  
# End of macro DMARK
48d6						CALLMONITOR 
48d6 cd 4d 17			call break_point_state  
48d9				endm  
# End of macro CALLMONITOR
48d9					endif 
48d9			 
48d9 cd c7 06				call storage_freeblocks 
48dc			 
48dc cd dd 1c				call forth_push_numhl 
48df			 
48df				       NEXTW 
48df c3 46 20			jp macro_next 
48e2				endm 
# End of macro NEXTW
48e2			.SIZE: 
48e2				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
48e2 67				db WORD_SYS_CORE+83             
48e3 16 49			dw .CREATE            
48e5 05				db 4 + 1 
48e6 .. 00			db "SIZE",0              
48eb				endm 
# End of macro CWHEAD
48eb			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
48eb					if DEBUG_FORTH_WORDS_KEY 
48eb						DMARK "SIZ" 
48eb f5				push af  
48ec 3a 00 49			ld a, (.dmark)  
48ef 32 77 fb			ld (debug_mark),a  
48f2 3a 01 49			ld a, (.dmark+1)  
48f5 32 78 fb			ld (debug_mark+1),a  
48f8 3a 02 49			ld a, (.dmark+2)  
48fb 32 79 fb			ld (debug_mark+2),a  
48fe 18 03			jr .pastdmark  
4900 ..			.dmark: db "SIZ"  
4903 f1			.pastdmark: pop af  
4904			endm  
# End of macro DMARK
4904						CALLMONITOR 
4904 cd 4d 17			call break_point_state  
4907				endm  
# End of macro CALLMONITOR
4907					endif 
4907			 
4907					FORTH_DSP_VALUEHL 
4907 cd d4 1e			call macro_dsp_valuehl 
490a				endm 
# End of macro FORTH_DSP_VALUEHL
490a			;		push hl 
490a					FORTH_DSP_POP 
490a cd 8c 1f			call macro_forth_dsp_pop 
490d				endm 
# End of macro FORTH_DSP_POP
490d			;		pop hl 
490d cd 3b 03				call storage_file_size 
4910			 
4910 cd dd 1c				call forth_push_numhl 
4913			  
4913			 
4913				       NEXTW 
4913 c3 46 20			jp macro_next 
4916				endm 
# End of macro NEXTW
4916			 
4916			.CREATE: 
4916				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
4916 68				db WORD_SYS_CORE+84             
4917 84 49			dw .APPEND            
4919 07				db 6 + 1 
491a .. 00			db "CREATE",0              
4921				endm 
# End of macro CWHEAD
4921			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
4921			; | | e.g.  
4921			; | | TestProgram CREATE 
4921			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
4921			; | |  
4921			; | | Max file IDs are 255. 
4921			; | |  
4921					 
4921					if DEBUG_FORTH_WORDS_KEY 
4921						DMARK "CRT" 
4921 f5				push af  
4922 3a 36 49			ld a, (.dmark)  
4925 32 77 fb			ld (debug_mark),a  
4928 3a 37 49			ld a, (.dmark+1)  
492b 32 78 fb			ld (debug_mark+1),a  
492e 3a 38 49			ld a, (.dmark+2)  
4931 32 79 fb			ld (debug_mark+2),a  
4934 18 03			jr .pastdmark  
4936 ..			.dmark: db "CRT"  
4939 f1			.pastdmark: pop af  
493a			endm  
# End of macro DMARK
493a						CALLMONITOR 
493a cd 4d 17			call break_point_state  
493d				endm  
# End of macro CALLMONITOR
493d					endif 
493d			;		call storage_get_block_0 
493d			 
493d					; TODO pop hl 
493d			 
493d					;v5 FORTH_DSP_VALUE 
493d					FORTH_DSP_VALUE 
493d cd bd 1e			call macro_forth_dsp_value 
4940				endm 
# End of macro FORTH_DSP_VALUE
4940			 
4940				if DEBUG_STORESE 
4940					DMARK "CR1" 
4940 f5				push af  
4941 3a 55 49			ld a, (.dmark)  
4944 32 77 fb			ld (debug_mark),a  
4947 3a 56 49			ld a, (.dmark+1)  
494a 32 78 fb			ld (debug_mark+1),a  
494d 3a 57 49			ld a, (.dmark+2)  
4950 32 79 fb			ld (debug_mark+2),a  
4953 18 03			jr .pastdmark  
4955 ..			.dmark: db "CR1"  
4958 f1			.pastdmark: pop af  
4959			endm  
# End of macro DMARK
4959					CALLMONITOR 
4959 cd 4d 17			call break_point_state  
495c				endm  
# End of macro CALLMONITOR
495c				endif 
495c			;		push hl 
495c			;		FORTH_DSP_POP 
495c			;		pop hl 
495c			 
495c			;		inc hl   ; move past the type marker 
495c			 
495c cd fd 06				call storage_create 
495f			 
495f				if DEBUG_STORESE 
495f					DMARK "CT1" 
495f f5				push af  
4960 3a 74 49			ld a, (.dmark)  
4963 32 77 fb			ld (debug_mark),a  
4966 3a 75 49			ld a, (.dmark+1)  
4969 32 78 fb			ld (debug_mark+1),a  
496c 3a 76 49			ld a, (.dmark+2)  
496f 32 79 fb			ld (debug_mark+2),a  
4972 18 03			jr .pastdmark  
4974 ..			.dmark: db "CT1"  
4977 f1			.pastdmark: pop af  
4978			endm  
# End of macro DMARK
4978					CALLMONITOR 
4978 cd 4d 17			call break_point_state  
497b				endm  
# End of macro CALLMONITOR
497b				endif 
497b			;		push hl 
497b					FORTH_DSP_POP 
497b cd 8c 1f			call macro_forth_dsp_pop 
497e				endm 
# End of macro FORTH_DSP_POP
497e			;		pop hl 
497e					; push file id to stack 
497e cd dd 1c				call forth_push_numhl 
4981			 
4981			 
4981			 
4981				       NEXTW 
4981 c3 46 20			jp macro_next 
4984				endm 
# End of macro NEXTW
4984			 
4984			.APPEND: 
4984				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
4984 69				db WORD_SYS_CORE+85             
4985 15 4a			dw .SDEL            
4987 07				db 6 + 1 
4988 .. 00			db "APPEND",0              
498f				endm 
# End of macro CWHEAD
498f			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
498f			; | | e.g. 
498f			; | | Test CREATE      -> $01 
498f			; | | "A string to add to file" $01 APPEND 
498f			; | |  
498f			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
498f					if DEBUG_FORTH_WORDS_KEY 
498f						DMARK "APP" 
498f f5				push af  
4990 3a a4 49			ld a, (.dmark)  
4993 32 77 fb			ld (debug_mark),a  
4996 3a a5 49			ld a, (.dmark+1)  
4999 32 78 fb			ld (debug_mark+1),a  
499c 3a a6 49			ld a, (.dmark+2)  
499f 32 79 fb			ld (debug_mark+2),a  
49a2 18 03			jr .pastdmark  
49a4 ..			.dmark: db "APP"  
49a7 f1			.pastdmark: pop af  
49a8			endm  
# End of macro DMARK
49a8						CALLMONITOR 
49a8 cd 4d 17			call break_point_state  
49ab				endm  
# End of macro CALLMONITOR
49ab					endif 
49ab			 
49ab					FORTH_DSP_VALUEHL 
49ab cd d4 1e			call macro_dsp_valuehl 
49ae				endm 
# End of macro FORTH_DSP_VALUEHL
49ae e5					push hl 	; save file id 
49af			 
49af				if DEBUG_STORESE 
49af					DMARK "AP1" 
49af f5				push af  
49b0 3a c4 49			ld a, (.dmark)  
49b3 32 77 fb			ld (debug_mark),a  
49b6 3a c5 49			ld a, (.dmark+1)  
49b9 32 78 fb			ld (debug_mark+1),a  
49bc 3a c6 49			ld a, (.dmark+2)  
49bf 32 79 fb			ld (debug_mark+2),a  
49c2 18 03			jr .pastdmark  
49c4 ..			.dmark: db "AP1"  
49c7 f1			.pastdmark: pop af  
49c8			endm  
# End of macro DMARK
49c8					CALLMONITOR 
49c8 cd 4d 17			call break_point_state  
49cb				endm  
# End of macro CALLMONITOR
49cb				endif 
49cb					FORTH_DSP_POP 
49cb cd 8c 1f			call macro_forth_dsp_pop 
49ce				endm 
# End of macro FORTH_DSP_POP
49ce			 
49ce					FORTH_DSP_VALUEHL 
49ce cd d4 1e			call macro_dsp_valuehl 
49d1				endm 
# End of macro FORTH_DSP_VALUEHL
49d1					;v5 FORTH_DSP_VALUE 
49d1 e5					push hl 	; save ptr to string to save 
49d2			 
49d2				if DEBUG_STORESE 
49d2					DMARK "AP1" 
49d2 f5				push af  
49d3 3a e7 49			ld a, (.dmark)  
49d6 32 77 fb			ld (debug_mark),a  
49d9 3a e8 49			ld a, (.dmark+1)  
49dc 32 78 fb			ld (debug_mark+1),a  
49df 3a e9 49			ld a, (.dmark+2)  
49e2 32 79 fb			ld (debug_mark+2),a  
49e5 18 03			jr .pastdmark  
49e7 ..			.dmark: db "AP1"  
49ea f1			.pastdmark: pop af  
49eb			endm  
# End of macro DMARK
49eb					CALLMONITOR 
49eb cd 4d 17			call break_point_state  
49ee				endm  
# End of macro CALLMONITOR
49ee				endif 
49ee					FORTH_DSP_POP 
49ee cd 8c 1f			call macro_forth_dsp_pop 
49f1				endm 
# End of macro FORTH_DSP_POP
49f1			 
49f1 d1					pop de 
49f2 e1					pop hl 
49f3				if DEBUG_STORESE 
49f3					DMARK "AP2" 
49f3 f5				push af  
49f4 3a 08 4a			ld a, (.dmark)  
49f7 32 77 fb			ld (debug_mark),a  
49fa 3a 09 4a			ld a, (.dmark+1)  
49fd 32 78 fb			ld (debug_mark+1),a  
4a00 3a 0a 4a			ld a, (.dmark+2)  
4a03 32 79 fb			ld (debug_mark+2),a  
4a06 18 03			jr .pastdmark  
4a08 ..			.dmark: db "AP2"  
4a0b f1			.pastdmark: pop af  
4a0c			endm  
# End of macro DMARK
4a0c					CALLMONITOR 
4a0c cd 4d 17			call break_point_state  
4a0f				endm  
# End of macro CALLMONITOR
4a0f				endif 
4a0f					;inc de ; skip var type indicator 
4a0f			 
4a0f					; TODO how to append numerics???? 
4a0f			 
4a0f cd d7 08				call storage_append		 
4a12			 
4a12				       NEXTW 
4a12 c3 46 20			jp macro_next 
4a15				endm 
# End of macro NEXTW
4a15			.SDEL: 
4a15				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
4a15 6a				db WORD_SYS_CORE+86             
4a16 61 4a			dw .OPEN            
4a18 05				db 4 + 1 
4a19 .. 00			db "ERA",0              
4a1d				endm 
# End of macro CWHEAD
4a1d			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
4a1d					FORTH_DSP_VALUEHL 
4a1d cd d4 1e			call macro_dsp_valuehl 
4a20				endm 
# End of macro FORTH_DSP_VALUEHL
4a20			;		push hl 	; save file id 
4a20			 
4a20					if DEBUG_FORTH_WORDS_KEY 
4a20						DMARK "ERA" 
4a20 f5				push af  
4a21 3a 35 4a			ld a, (.dmark)  
4a24 32 77 fb			ld (debug_mark),a  
4a27 3a 36 4a			ld a, (.dmark+1)  
4a2a 32 78 fb			ld (debug_mark+1),a  
4a2d 3a 37 4a			ld a, (.dmark+2)  
4a30 32 79 fb			ld (debug_mark+2),a  
4a33 18 03			jr .pastdmark  
4a35 ..			.dmark: db "ERA"  
4a38 f1			.pastdmark: pop af  
4a39			endm  
# End of macro DMARK
4a39						CALLMONITOR 
4a39 cd 4d 17			call break_point_state  
4a3c				endm  
# End of macro CALLMONITOR
4a3c					endif 
4a3c				if DEBUG_STORESE 
4a3c					DMARK "ER1" 
4a3c f5				push af  
4a3d 3a 51 4a			ld a, (.dmark)  
4a40 32 77 fb			ld (debug_mark),a  
4a43 3a 52 4a			ld a, (.dmark+1)  
4a46 32 78 fb			ld (debug_mark+1),a  
4a49 3a 53 4a			ld a, (.dmark+2)  
4a4c 32 79 fb			ld (debug_mark+2),a  
4a4f 18 03			jr .pastdmark  
4a51 ..			.dmark: db "ER1"  
4a54 f1			.pastdmark: pop af  
4a55			endm  
# End of macro DMARK
4a55					CALLMONITOR 
4a55 cd 4d 17			call break_point_state  
4a58				endm  
# End of macro CALLMONITOR
4a58				endif 
4a58					FORTH_DSP_POP 
4a58 cd 8c 1f			call macro_forth_dsp_pop 
4a5b				endm 
# End of macro FORTH_DSP_POP
4a5b			 
4a5b			;		pop hl 
4a5b			 
4a5b cd 4c 05				call storage_erase 
4a5e				       NEXTW 
4a5e c3 46 20			jp macro_next 
4a61				endm 
# End of macro NEXTW
4a61			 
4a61			.OPEN: 
4a61				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
4a61 6b				db WORD_SYS_CORE+87             
4a62 e8 4a			dw .READ            
4a64 05				db 4 + 1 
4a65 .. 00			db "OPEN",0              
4a6a				endm 
# End of macro CWHEAD
4a6a			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
4a6a			; | | e.g. 
4a6a			; | | $01 OPEN $01 DO $01 READ . LOOP 
4a6a			 
4a6a					if DEBUG_FORTH_WORDS_KEY 
4a6a						DMARK "OPN" 
4a6a f5				push af  
4a6b 3a 7f 4a			ld a, (.dmark)  
4a6e 32 77 fb			ld (debug_mark),a  
4a71 3a 80 4a			ld a, (.dmark+1)  
4a74 32 78 fb			ld (debug_mark+1),a  
4a77 3a 81 4a			ld a, (.dmark+2)  
4a7a 32 79 fb			ld (debug_mark+2),a  
4a7d 18 03			jr .pastdmark  
4a7f ..			.dmark: db "OPN"  
4a82 f1			.pastdmark: pop af  
4a83			endm  
# End of macro DMARK
4a83						CALLMONITOR 
4a83 cd 4d 17			call break_point_state  
4a86				endm  
# End of macro CALLMONITOR
4a86					endif 
4a86					; TODO handle multiple file opens 
4a86			 
4a86 3e 01			       	ld a, 1 
4a88 32 59 f8				ld (store_openext), a 
4a8b			 
4a8b					; get max extents for this file 
4a8b				 
4a8b								 
4a8b					FORTH_DSP_VALUEHL 
4a8b cd d4 1e			call macro_dsp_valuehl 
4a8e				endm 
# End of macro FORTH_DSP_VALUEHL
4a8e			 
4a8e 65					ld h, l 
4a8f 2e 00				ld l, 0 
4a91			 
4a91				if DEBUG_STORESE 
4a91					DMARK "OPN" 
4a91 f5				push af  
4a92 3a a6 4a			ld a, (.dmark)  
4a95 32 77 fb			ld (debug_mark),a  
4a98 3a a7 4a			ld a, (.dmark+1)  
4a9b 32 78 fb			ld (debug_mark+1),a  
4a9e 3a a8 4a			ld a, (.dmark+2)  
4aa1 32 79 fb			ld (debug_mark+2),a  
4aa4 18 03			jr .pastdmark  
4aa6 ..			.dmark: db "OPN"  
4aa9 f1			.pastdmark: pop af  
4aaa			endm  
# End of macro DMARK
4aaa					CALLMONITOR 
4aaa cd 4d 17			call break_point_state  
4aad				endm  
# End of macro CALLMONITOR
4aad				endif 
4aad			;		push hl 
4aad					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
4aad cd 8c 1f			call macro_forth_dsp_pop 
4ab0				endm 
# End of macro FORTH_DSP_POP
4ab0			;		pop hl 
4ab0						 
4ab0 11 62 f8				ld de, store_page      ; get block zero of file 
4ab3 cd 51 08				call storage_read 
4ab6			 
4ab6			 
4ab6 3a 64 f8				ld a, (store_page+2)    ; max extents for this file 
4ab9 32 58 f8				ld  (store_openmaxext), a   ; get our limit and push 
4abc					 
4abc				if DEBUG_STORESE 
4abc					DMARK "OPx" 
4abc f5				push af  
4abd 3a d1 4a			ld a, (.dmark)  
4ac0 32 77 fb			ld (debug_mark),a  
4ac3 3a d2 4a			ld a, (.dmark+1)  
4ac6 32 78 fb			ld (debug_mark+1),a  
4ac9 3a d3 4a			ld a, (.dmark+2)  
4acc 32 79 fb			ld (debug_mark+2),a  
4acf 18 03			jr .pastdmark  
4ad1 ..			.dmark: db "OPx"  
4ad4 f1			.pastdmark: pop af  
4ad5			endm  
# End of macro DMARK
4ad5					CALLMONITOR 
4ad5 cd 4d 17			call break_point_state  
4ad8				endm  
# End of macro CALLMONITOR
4ad8				endif 
4ad8 fe 00				cp 0 
4ada 20 03				jr nz, .skipopeneof 
4adc					; have opened an empty file 
4adc					 
4adc 32 59 f8				ld (store_openext), a 
4adf			 
4adf			.skipopeneof: 
4adf			 
4adf 6f					ld l, a 
4ae0 26 00				ld h, 0 
4ae2 cd dd 1c				call forth_push_numhl 
4ae5			 
4ae5			 
4ae5				       NEXTW 
4ae5 c3 46 20			jp macro_next 
4ae8				endm 
# End of macro NEXTW
4ae8			.READ: 
4ae8				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
4ae8 6c				db WORD_SYS_CORE+88             
4ae9 2f 4c			dw .EOF            
4aeb 05				db 4 + 1 
4aec .. 00			db "READ",0              
4af1				endm 
# End of macro CWHEAD
4af1			; | READ ( n -- n  )  Reads next page of file id and push to stack | DONE 
4af1			; | | e.g. 
4af1			; | | $01 OPEN $01 DO $01 READ . LOOP 
4af1			 
4af1					if DEBUG_FORTH_WORDS_KEY 
4af1						DMARK "REA" 
4af1 f5				push af  
4af2 3a 06 4b			ld a, (.dmark)  
4af5 32 77 fb			ld (debug_mark),a  
4af8 3a 07 4b			ld a, (.dmark+1)  
4afb 32 78 fb			ld (debug_mark+1),a  
4afe 3a 08 4b			ld a, (.dmark+2)  
4b01 32 79 fb			ld (debug_mark+2),a  
4b04 18 03			jr .pastdmark  
4b06 ..			.dmark: db "REA"  
4b09 f1			.pastdmark: pop af  
4b0a			endm  
# End of macro DMARK
4b0a						CALLMONITOR 
4b0a cd 4d 17			call break_point_state  
4b0d				endm  
# End of macro CALLMONITOR
4b0d					endif 
4b0d					; store_openext use it. If zero it is EOF 
4b0d			 
4b0d					; read block from current stream id 
4b0d					; if the block does not contain zero term keep reading blocks until zero found 
4b0d					; push the block to stack 
4b0d					; save the block id to stream 
4b0d			 
4b0d			 
4b0d					FORTH_DSP_VALUEHL 
4b0d cd d4 1e			call macro_dsp_valuehl 
4b10				endm 
# End of macro FORTH_DSP_VALUEHL
4b10			 
4b10			;		push hl 
4b10			 
4b10				if DEBUG_STORESE 
4b10					DMARK "REA" 
4b10 f5				push af  
4b11 3a 25 4b			ld a, (.dmark)  
4b14 32 77 fb			ld (debug_mark),a  
4b17 3a 26 4b			ld a, (.dmark+1)  
4b1a 32 78 fb			ld (debug_mark+1),a  
4b1d 3a 27 4b			ld a, (.dmark+2)  
4b20 32 79 fb			ld (debug_mark+2),a  
4b23 18 03			jr .pastdmark  
4b25 ..			.dmark: db "REA"  
4b28 f1			.pastdmark: pop af  
4b29			endm  
# End of macro DMARK
4b29					CALLMONITOR 
4b29 cd 4d 17			call break_point_state  
4b2c				endm  
# End of macro CALLMONITOR
4b2c				endif 
4b2c					FORTH_DSP_POP 
4b2c cd 8c 1f			call macro_forth_dsp_pop 
4b2f				endm 
# End of macro FORTH_DSP_POP
4b2f			 
4b2f			;		pop hl 
4b2f				 
4b2f 65					ld h,l 
4b30			 
4b30 3a 59 f8				ld a, (store_openext) 
4b33 6f					ld l, a 
4b34					 
4b34 fe 00				cp 0 
4b36 ca 01 4c				jp z, .ateof     ; dont read past eof 
4b39			 
4b39			 
4b39 11 62 f8				ld de, store_page 
4b3c				if DEBUG_STORESE 
4b3c					DMARK "RE1" 
4b3c f5				push af  
4b3d 3a 51 4b			ld a, (.dmark)  
4b40 32 77 fb			ld (debug_mark),a  
4b43 3a 52 4b			ld a, (.dmark+1)  
4b46 32 78 fb			ld (debug_mark+1),a  
4b49 3a 53 4b			ld a, (.dmark+2)  
4b4c 32 79 fb			ld (debug_mark+2),a  
4b4f 18 03			jr .pastdmark  
4b51 ..			.dmark: db "RE1"  
4b54 f1			.pastdmark: pop af  
4b55			endm  
# End of macro DMARK
4b55					CALLMONITOR 
4b55 cd 4d 17			call break_point_state  
4b58				endm  
# End of macro CALLMONITOR
4b58				endif 
4b58 cd 51 08				call storage_read 
4b5b			 
4b5b				if DEBUG_STORESE 
4b5b					DMARK "RE2" 
4b5b f5				push af  
4b5c 3a 70 4b			ld a, (.dmark)  
4b5f 32 77 fb			ld (debug_mark),a  
4b62 3a 71 4b			ld a, (.dmark+1)  
4b65 32 78 fb			ld (debug_mark+1),a  
4b68 3a 72 4b			ld a, (.dmark+2)  
4b6b 32 79 fb			ld (debug_mark+2),a  
4b6e 18 03			jr .pastdmark  
4b70 ..			.dmark: db "RE2"  
4b73 f1			.pastdmark: pop af  
4b74			endm  
# End of macro DMARK
4b74					CALLMONITOR 
4b74 cd 4d 17			call break_point_state  
4b77				endm  
# End of macro CALLMONITOR
4b77				endif 
4b77 cd 32 0d			call ishlzero 
4b7a			;	ld a, l 
4b7a			;	add h 
4b7a			;	cp 0 
4b7a ca 07 4c			jp z, .readeof 
4b7d			 
4b7d				; not eof so hl should point to data to push to stack 
4b7d			 
4b7d				if DEBUG_STORESE 
4b7d					DMARK "RE3" 
4b7d f5				push af  
4b7e 3a 92 4b			ld a, (.dmark)  
4b81 32 77 fb			ld (debug_mark),a  
4b84 3a 93 4b			ld a, (.dmark+1)  
4b87 32 78 fb			ld (debug_mark+1),a  
4b8a 3a 94 4b			ld a, (.dmark+2)  
4b8d 32 79 fb			ld (debug_mark+2),a  
4b90 18 03			jr .pastdmark  
4b92 ..			.dmark: db "RE3"  
4b95 f1			.pastdmark: pop af  
4b96			endm  
# End of macro DMARK
4b96					CALLMONITOR 
4b96 cd 4d 17			call break_point_state  
4b99				endm  
# End of macro CALLMONITOR
4b99				endif 
4b99 cd 4b 1d			call forth_push_str 
4b9c			 
4b9c				if DEBUG_STORESE 
4b9c					DMARK "RE4" 
4b9c f5				push af  
4b9d 3a b1 4b			ld a, (.dmark)  
4ba0 32 77 fb			ld (debug_mark),a  
4ba3 3a b2 4b			ld a, (.dmark+1)  
4ba6 32 78 fb			ld (debug_mark+1),a  
4ba9 3a b3 4b			ld a, (.dmark+2)  
4bac 32 79 fb			ld (debug_mark+2),a  
4baf 18 03			jr .pastdmark  
4bb1 ..			.dmark: db "RE4"  
4bb4 f1			.pastdmark: pop af  
4bb5			endm  
# End of macro DMARK
4bb5					CALLMONITOR 
4bb5 cd 4d 17			call break_point_state  
4bb8				endm  
# End of macro CALLMONITOR
4bb8				endif 
4bb8				; get next block  or mark as eof 
4bb8			 
4bb8 3a 58 f8			ld a, (store_openmaxext)   ; get our limit 
4bbb 4f				ld c, a	 
4bbc 3a 59 f8			ld a, (store_openext) 
4bbf			 
4bbf				if DEBUG_STORESE 
4bbf					DMARK "RE5" 
4bbf f5				push af  
4bc0 3a d4 4b			ld a, (.dmark)  
4bc3 32 77 fb			ld (debug_mark),a  
4bc6 3a d5 4b			ld a, (.dmark+1)  
4bc9 32 78 fb			ld (debug_mark+1),a  
4bcc 3a d6 4b			ld a, (.dmark+2)  
4bcf 32 79 fb			ld (debug_mark+2),a  
4bd2 18 03			jr .pastdmark  
4bd4 ..			.dmark: db "RE5"  
4bd7 f1			.pastdmark: pop af  
4bd8			endm  
# End of macro DMARK
4bd8					CALLMONITOR 
4bd8 cd 4d 17			call break_point_state  
4bdb				endm  
# End of macro CALLMONITOR
4bdb				endif 
4bdb b9				cp c 
4bdc 28 29			jr z, .readeof     ; at last extent 
4bde			 
4bde 3c					inc a 
4bdf 32 59 f8				ld (store_openext), a 
4be2			 
4be2				if DEBUG_STORESE 
4be2					DMARK "RE6" 
4be2 f5				push af  
4be3 3a f7 4b			ld a, (.dmark)  
4be6 32 77 fb			ld (debug_mark),a  
4be9 3a f8 4b			ld a, (.dmark+1)  
4bec 32 78 fb			ld (debug_mark+1),a  
4bef 3a f9 4b			ld a, (.dmark+2)  
4bf2 32 79 fb			ld (debug_mark+2),a  
4bf5 18 03			jr .pastdmark  
4bf7 ..			.dmark: db "RE6"  
4bfa f1			.pastdmark: pop af  
4bfb			endm  
# End of macro DMARK
4bfb					CALLMONITOR 
4bfb cd 4d 17			call break_point_state  
4bfe				endm  
# End of macro CALLMONITOR
4bfe				endif 
4bfe			 
4bfe			 
4bfe				       NEXTW 
4bfe c3 46 20			jp macro_next 
4c01				endm 
# End of macro NEXTW
4c01			.ateof: 
4c01 21 2b 4c				ld hl, .showeof 
4c04 cd 4b 1d				call forth_push_str 
4c07 3e 00		.readeof:	ld a, 0 
4c09 32 59 f8				ld (store_openext), a 
4c0c			 
4c0c					 
4c0c				if DEBUG_STORESE 
4c0c					DMARK "REF" 
4c0c f5				push af  
4c0d 3a 21 4c			ld a, (.dmark)  
4c10 32 77 fb			ld (debug_mark),a  
4c13 3a 22 4c			ld a, (.dmark+1)  
4c16 32 78 fb			ld (debug_mark+1),a  
4c19 3a 23 4c			ld a, (.dmark+2)  
4c1c 32 79 fb			ld (debug_mark+2),a  
4c1f 18 03			jr .pastdmark  
4c21 ..			.dmark: db "REF"  
4c24 f1			.pastdmark: pop af  
4c25			endm  
# End of macro DMARK
4c25					CALLMONITOR 
4c25 cd 4d 17			call break_point_state  
4c28				endm  
# End of macro CALLMONITOR
4c28				endif 
4c28				       NEXTW 
4c28 c3 46 20			jp macro_next 
4c2b				endm 
# End of macro NEXTW
4c2b			 
4c2b .. 00		.showeof:   db "eof", 0 
4c2f			 
4c2f			 
4c2f			.EOF: 
4c2f				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
4c2f 6d				db WORD_SYS_CORE+89             
4c30 70 4c			dw .FORMAT            
4c32 04				db 3 + 1 
4c33 .. 00			db "EOF",0              
4c37				endm 
# End of macro CWHEAD
4c37			; | EOF ( n -- u )  Returns EOF logical state of file id n - CURRENTLY n IS IGNORED AND ONLY ONE STREAM IS SUPPORTED | DONE 
4c37			; | | e.g. 
4c37			; | | $01 OPEN REPEAT $01 READ $01 EOF $00 IF LOOP 
4c37					; TODO if current block id for stream is zero then push true else false 
4c37			 
4c37					if DEBUG_FORTH_WORDS_KEY 
4c37						DMARK "EOF" 
4c37 f5				push af  
4c38 3a 4c 4c			ld a, (.dmark)  
4c3b 32 77 fb			ld (debug_mark),a  
4c3e 3a 4d 4c			ld a, (.dmark+1)  
4c41 32 78 fb			ld (debug_mark+1),a  
4c44 3a 4e 4c			ld a, (.dmark+2)  
4c47 32 79 fb			ld (debug_mark+2),a  
4c4a 18 03			jr .pastdmark  
4c4c ..			.dmark: db "EOF"  
4c4f f1			.pastdmark: pop af  
4c50			endm  
# End of macro DMARK
4c50						CALLMONITOR 
4c50 cd 4d 17			call break_point_state  
4c53				endm  
# End of macro CALLMONITOR
4c53					endif 
4c53			 
4c53					; TODO handlue multiple file streams 
4c53			 
4c53					FORTH_DSP_POP     ; for now just get rid of stream id 
4c53 cd 8c 1f			call macro_forth_dsp_pop 
4c56				endm 
# End of macro FORTH_DSP_POP
4c56			 
4c56 2e 01				ld l, 1 
4c58 3a 58 f8				ld a, (store_openmaxext) 
4c5b fe 00				cp 0 
4c5d 28 09				jr  z, .eofdone   ; empty file 
4c5f 3a 59 f8				ld a, (store_openext) 
4c62 fe 00				cp 0 
4c64 28 02				jr  z, .eofdone 
4c66 2e 00				ld l, 0 
4c68 26 00		.eofdone:	ld h, 0 
4c6a cd dd 1c				call forth_push_numhl 
4c6d			 
4c6d			 
4c6d				       NEXTW 
4c6d c3 46 20			jp macro_next 
4c70				endm 
# End of macro NEXTW
4c70			 
4c70			.FORMAT: 
4c70				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
4c70 6d				db WORD_SYS_CORE+89             
4c71 c1 4c			dw .LABEL            
4c73 07				db 6 + 1 
4c74 .. 00			db "FORMAT",0              
4c7b				endm 
# End of macro CWHEAD
4c7b			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
4c7b					; TODO if current block id for stream is zero then push true else false 
4c7b				 
4c7b				if DEBUG_STORESE 
4c7b					DMARK "FOR" 
4c7b f5				push af  
4c7c 3a 90 4c			ld a, (.dmark)  
4c7f 32 77 fb			ld (debug_mark),a  
4c82 3a 91 4c			ld a, (.dmark+1)  
4c85 32 78 fb			ld (debug_mark+1),a  
4c88 3a 92 4c			ld a, (.dmark+2)  
4c8b 32 79 fb			ld (debug_mark+2),a  
4c8e 18 03			jr .pastdmark  
4c90 ..			.dmark: db "FOR"  
4c93 f1			.pastdmark: pop af  
4c94			endm  
# End of macro DMARK
4c94					CALLMONITOR 
4c94 cd 4d 17			call break_point_state  
4c97				endm  
# End of macro CALLMONITOR
4c97				endif 
4c97					; Wipes the bank check flags to cause a reformat on next block 0 read 
4c97			 
4c97 21 01 00				ld hl, 1 
4c9a 3e 00				ld a, 0 
4c9c cd ea 01				call se_writebyte 
4c9f			 
4c9f				if DEBUG_STORESE 
4c9f					DMARK "FO0" 
4c9f f5				push af  
4ca0 3a b4 4c			ld a, (.dmark)  
4ca3 32 77 fb			ld (debug_mark),a  
4ca6 3a b5 4c			ld a, (.dmark+1)  
4ca9 32 78 fb			ld (debug_mark+1),a  
4cac 3a b6 4c			ld a, (.dmark+2)  
4caf 32 79 fb			ld (debug_mark+2),a  
4cb2 18 03			jr .pastdmark  
4cb4 ..			.dmark: db "FO0"  
4cb7 f1			.pastdmark: pop af  
4cb8			endm  
# End of macro DMARK
4cb8					CALLMONITOR 
4cb8 cd 4d 17			call break_point_state  
4cbb				endm  
# End of macro CALLMONITOR
4cbb				endif 
4cbb					; force bank init 
4cbb			 
4cbb cd bd 03				call storage_get_block_0 
4cbe					 
4cbe				       NEXTW 
4cbe c3 46 20			jp macro_next 
4cc1				endm 
# End of macro NEXTW
4cc1			.LABEL: 
4cc1				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
4cc1 6d				db WORD_SYS_CORE+89             
4cc2 0f 4d			dw .STOREPAGE            
4cc4 06				db 5 + 1 
4cc5 .. 00			db "LABEL",0              
4ccb				endm 
# End of macro CWHEAD
4ccb			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
4ccb					; TODO test to see if bank is selected 
4ccb				 
4ccb					if DEBUG_FORTH_WORDS_KEY 
4ccb						DMARK "LBL" 
4ccb f5				push af  
4ccc 3a e0 4c			ld a, (.dmark)  
4ccf 32 77 fb			ld (debug_mark),a  
4cd2 3a e1 4c			ld a, (.dmark+1)  
4cd5 32 78 fb			ld (debug_mark+1),a  
4cd8 3a e2 4c			ld a, (.dmark+2)  
4cdb 32 79 fb			ld (debug_mark+2),a  
4cde 18 03			jr .pastdmark  
4ce0 ..			.dmark: db "LBL"  
4ce3 f1			.pastdmark: pop af  
4ce4			endm  
# End of macro DMARK
4ce4						CALLMONITOR 
4ce4 cd 4d 17			call break_point_state  
4ce7				endm  
# End of macro CALLMONITOR
4ce7					endif 
4ce7			;	if DEBUG_STORESE 
4ce7			;		DMARK "LBL" 
4ce7			;		CALLMONITOR 
4ce7			;	endif 
4ce7					FORTH_DSP_VALUEHL 
4ce7 cd d4 1e			call macro_dsp_valuehl 
4cea				endm 
# End of macro FORTH_DSP_VALUEHL
4cea					;v5FORTH_DSP_VALUE 
4cea					 
4cea			;		push hl 
4cea					FORTH_DSP_POP 
4cea cd 8c 1f			call macro_forth_dsp_pop 
4ced				endm 
# End of macro FORTH_DSP_POP
4ced			;		pop hl 
4ced			 
4ced			;v5		inc hl   ; move past the type marker 
4ced			 
4ced				if DEBUG_STORESE 
4ced					DMARK "LBl" 
4ced f5				push af  
4cee 3a 02 4d			ld a, (.dmark)  
4cf1 32 77 fb			ld (debug_mark),a  
4cf4 3a 03 4d			ld a, (.dmark+1)  
4cf7 32 78 fb			ld (debug_mark+1),a  
4cfa 3a 04 4d			ld a, (.dmark+2)  
4cfd 32 79 fb			ld (debug_mark+2),a  
4d00 18 03			jr .pastdmark  
4d02 ..			.dmark: db "LBl"  
4d05 f1			.pastdmark: pop af  
4d06			endm  
# End of macro DMARK
4d06					CALLMONITOR 
4d06 cd 4d 17			call break_point_state  
4d09				endm  
# End of macro CALLMONITOR
4d09				endif 
4d09 cd e1 04				call storage_label 
4d0c			 
4d0c				       NEXTW 
4d0c c3 46 20			jp macro_next 
4d0f				endm 
# End of macro NEXTW
4d0f			.STOREPAGE: 
4d0f				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
4d0f 6d				db WORD_SYS_CORE+89             
4d10 42 4d			dw .LABELS            
4d12 0a				db 9 + 1 
4d13 .. 00			db "STOREPAGE",0              
4d1d				endm 
# End of macro CWHEAD
4d1d			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
4d1d					; TODO test to see if bank is selected 
4d1d				 
4d1d					if DEBUG_FORTH_WORDS_KEY 
4d1d						DMARK "STP" 
4d1d f5				push af  
4d1e 3a 32 4d			ld a, (.dmark)  
4d21 32 77 fb			ld (debug_mark),a  
4d24 3a 33 4d			ld a, (.dmark+1)  
4d27 32 78 fb			ld (debug_mark+1),a  
4d2a 3a 34 4d			ld a, (.dmark+2)  
4d2d 32 79 fb			ld (debug_mark+2),a  
4d30 18 03			jr .pastdmark  
4d32 ..			.dmark: db "STP"  
4d35 f1			.pastdmark: pop af  
4d36			endm  
# End of macro DMARK
4d36						CALLMONITOR 
4d36 cd 4d 17			call break_point_state  
4d39				endm  
# End of macro CALLMONITOR
4d39					endif 
4d39			;	if DEBUG_STORESE 
4d39			;		DMARK "STP" 
4d39			;		CALLMONITOR 
4d39			;	endif 
4d39			 
4d39 21 62 f8			ld hl, store_page 
4d3c cd dd 1c			call forth_push_numhl 
4d3f			 
4d3f			 
4d3f				       NEXTW 
4d3f c3 46 20			jp macro_next 
4d42				endm 
# End of macro NEXTW
4d42			.LABELS: 
4d42				CWHEAD .ENDSTORAGE 89 "LABELS" 6 WORD_FLAG_CODE 
4d42 6d				db WORD_SYS_CORE+89             
4d43 cc 4d			dw .ENDSTORAGE            
4d45 07				db 6 + 1 
4d46 .. 00			db "LABELS",0              
4d4d				endm 
# End of macro CWHEAD
4d4d			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | TO TEST 
4d4d					;  
4d4d			 
4d4d					; save the current device selected to restore afterwards 
4d4d				 
4d4d 3a 48 f8				ld a, (spi_device) 
4d50 f5					push af 
4d51			 
4d51			 
4d51					; run through each of the banks 
4d51			 
4d51 21 01 00				ld hl, 1 
4d54 cd dd 1c				call forth_push_numhl 
4d57 3e ff				ld a, SPI_CE_HIGH 
4d59 cb 87				res SPI_CE0, a 
4d5b 32 48 f8				ld (spi_device), a 
4d5e cd bd 03				call storage_get_block_0 
4d61 21 65 f8				ld hl, store_page+3 
4d64 cd 4b 1d				call forth_push_str 
4d67			 
4d67					 
4d67 21 02 00				ld hl, 2 
4d6a cd dd 1c				call forth_push_numhl 
4d6d 3e ff				ld a, SPI_CE_HIGH 
4d6f cb 8f				res SPI_CE1, a 
4d71 32 48 f8				ld (spi_device), a 
4d74 cd bd 03				call storage_get_block_0 
4d77 21 65 f8				ld hl, store_page+3 
4d7a cd 4b 1d				call forth_push_str 
4d7d			 
4d7d					 
4d7d 21 03 00				ld hl, 3 
4d80 cd dd 1c				call forth_push_numhl 
4d83 3e ff				ld a, SPI_CE_HIGH 
4d85 cb 97				res SPI_CE2, a 
4d87 32 48 f8				ld (spi_device), a 
4d8a cd bd 03				call storage_get_block_0 
4d8d 21 65 f8				ld hl, store_page+3 
4d90 cd 4b 1d				call forth_push_str 
4d93			 
4d93			 
4d93 21 04 00				ld hl, 4 
4d96 cd dd 1c				call forth_push_numhl 
4d99 3e ff				ld a, SPI_CE_HIGH 
4d9b cb 9f				res SPI_CE3, a 
4d9d 32 48 f8				ld (spi_device), a 
4da0 cd bd 03				call storage_get_block_0 
4da3 21 65 f8				ld hl, store_page+3 
4da6 cd 4b 1d				call forth_push_str 
4da9			 
4da9					 
4da9			 
4da9 21 05 00				ld hl, 5 
4dac cd dd 1c				call forth_push_numhl 
4daf 3e ff				ld a, SPI_CE_HIGH 
4db1 cb a7				res SPI_CE4, a 
4db3 32 48 f8				ld (spi_device), a 
4db6 cd bd 03				call storage_get_block_0 
4db9 21 65 f8				ld hl, store_page+3 
4dbc cd 4b 1d				call forth_push_str 
4dbf			 
4dbf					 
4dbf					; push fixed count of storage devices (on board) for now 
4dbf			 
4dbf 21 05 00				ld hl, 5 
4dc2 cd dd 1c				call forth_push_numhl 
4dc5			 
4dc5					; restore selected device  
4dc5				 
4dc5 f1					pop af 
4dc6 32 48 f8				ld (spi_device), a 
4dc9			 
4dc9				       NEXTW 
4dc9 c3 46 20			jp macro_next 
4dcc				endm 
# End of macro NEXTW
4dcc			 
4dcc			.ENDSTORAGE: 
4dcc			; eof 
# End of file forth_words_storage.asm
4dcc			endif 
4dcc				include "forth_words_device.asm" 
4dcc			; Device related words 
4dcc			 
4dcc			; | ## Device Words 
4dcc			 
4dcc			if SOUND_ENABLE 
4dcc			.NOTE: 
4dcc				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
4dcc 33				db WORD_SYS_CORE+31             
4dcd f4 4d			dw .AFTERSOUND            
4dcf 05				db 4 + 1 
4dd0 .. 00			db "NOTE",0              
4dd5				endm 
# End of macro CWHEAD
4dd5			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
4dd5					if DEBUG_FORTH_WORDS_KEY 
4dd5						DMARK "NTE" 
4dd5 f5				push af  
4dd6 3a ea 4d			ld a, (.dmark)  
4dd9 32 77 fb			ld (debug_mark),a  
4ddc 3a eb 4d			ld a, (.dmark+1)  
4ddf 32 78 fb			ld (debug_mark+1),a  
4de2 3a ec 4d			ld a, (.dmark+2)  
4de5 32 79 fb			ld (debug_mark+2),a  
4de8 18 03			jr .pastdmark  
4dea ..			.dmark: db "NTE"  
4ded f1			.pastdmark: pop af  
4dee			endm  
# End of macro DMARK
4dee						CALLMONITOR 
4dee cd 4d 17			call break_point_state  
4df1				endm  
# End of macro CALLMONITOR
4df1					endif 
4df1			 
4df1				 
4df1			 
4df1					NEXTW 
4df1 c3 46 20			jp macro_next 
4df4				endm 
# End of macro NEXTW
4df4			.AFTERSOUND: 
4df4			endif 
4df4			 
4df4			 
4df4			USE_GPIO: equ 0 
4df4			 
4df4			if USE_GPIO 
4df4			.GP1: 
4df4				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
4df4			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
4df4					NEXTW 
4df4			.GP2: 
4df4				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
4df4			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
4df4			 
4df4					NEXTW 
4df4			 
4df4			.GP3: 
4df4				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
4df4			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
4df4			 
4df4					NEXTW 
4df4			 
4df4			.GP4: 
4df4				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
4df4			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
4df4			 
4df4					NEXTW 
4df4			.SIN: 
4df4			 
4df4			 
4df4			endif 
4df4			 
4df4			 
4df4				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
4df4 33				db WORD_SYS_CORE+31             
4df5 29 4e			dw .SOUT            
4df7 03				db 2 + 1 
4df8 .. 00			db "IN",0              
4dfb				endm 
# End of macro CWHEAD
4dfb			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
4dfb					if DEBUG_FORTH_WORDS_KEY 
4dfb						DMARK "IN." 
4dfb f5				push af  
4dfc 3a 10 4e			ld a, (.dmark)  
4dff 32 77 fb			ld (debug_mark),a  
4e02 3a 11 4e			ld a, (.dmark+1)  
4e05 32 78 fb			ld (debug_mark+1),a  
4e08 3a 12 4e			ld a, (.dmark+2)  
4e0b 32 79 fb			ld (debug_mark+2),a  
4e0e 18 03			jr .pastdmark  
4e10 ..			.dmark: db "IN."  
4e13 f1			.pastdmark: pop af  
4e14			endm  
# End of macro DMARK
4e14						CALLMONITOR 
4e14 cd 4d 17			call break_point_state  
4e17				endm  
# End of macro CALLMONITOR
4e17					endif 
4e17					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4e17 cd d4 1e			call macro_dsp_valuehl 
4e1a				endm 
# End of macro FORTH_DSP_VALUEHL
4e1a			 
4e1a e5					push hl 
4e1b			 
4e1b					; destroy value TOS 
4e1b			 
4e1b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4e1b cd 8c 1f			call macro_forth_dsp_pop 
4e1e				endm 
# End of macro FORTH_DSP_POP
4e1e			 
4e1e					; one value on hl get other one back 
4e1e			 
4e1e c1					pop bc 
4e1f			 
4e1f					; do the sub 
4e1f			;		ex de, hl 
4e1f			 
4e1f ed 68				in l,(c) 
4e21			 
4e21					; save it 
4e21			 
4e21 26 00				ld h,0 
4e23			 
4e23					; TODO push value back onto stack for another op etc 
4e23			 
4e23 cd dd 1c				call forth_push_numhl 
4e26					NEXTW 
4e26 c3 46 20			jp macro_next 
4e29				endm 
# End of macro NEXTW
4e29			.SOUT: 
4e29				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
4e29 34				db WORD_SYS_CORE+32             
4e2a 7c 4e			dw .SPIO            
4e2c 04				db 3 + 1 
4e2d .. 00			db "OUT",0              
4e31				endm 
# End of macro CWHEAD
4e31			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
4e31					if DEBUG_FORTH_WORDS_KEY 
4e31						DMARK "OUT" 
4e31 f5				push af  
4e32 3a 46 4e			ld a, (.dmark)  
4e35 32 77 fb			ld (debug_mark),a  
4e38 3a 47 4e			ld a, (.dmark+1)  
4e3b 32 78 fb			ld (debug_mark+1),a  
4e3e 3a 48 4e			ld a, (.dmark+2)  
4e41 32 79 fb			ld (debug_mark+2),a  
4e44 18 03			jr .pastdmark  
4e46 ..			.dmark: db "OUT"  
4e49 f1			.pastdmark: pop af  
4e4a			endm  
# End of macro DMARK
4e4a						CALLMONITOR 
4e4a cd 4d 17			call break_point_state  
4e4d				endm  
# End of macro CALLMONITOR
4e4d					endif 
4e4d			 
4e4d					; get port 
4e4d			 
4e4d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4e4d cd d4 1e			call macro_dsp_valuehl 
4e50				endm 
# End of macro FORTH_DSP_VALUEHL
4e50			 
4e50 e5					push hl 
4e51			 
4e51					; destroy value TOS 
4e51			 
4e51					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4e51 cd 8c 1f			call macro_forth_dsp_pop 
4e54				endm 
# End of macro FORTH_DSP_POP
4e54			 
4e54					; get byte to send 
4e54			 
4e54					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4e54 cd d4 1e			call macro_dsp_valuehl 
4e57				endm 
# End of macro FORTH_DSP_VALUEHL
4e57			 
4e57			;		push hl 
4e57			 
4e57					; destroy value TOS 
4e57			 
4e57					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4e57 cd 8c 1f			call macro_forth_dsp_pop 
4e5a				endm 
# End of macro FORTH_DSP_POP
4e5a			 
4e5a					; one value on hl get other one back 
4e5a			 
4e5a			;		pop hl 
4e5a			 
4e5a c1					pop bc 
4e5b			 
4e5b					if DEBUG_FORTH_WORDS 
4e5b						DMARK "OUT" 
4e5b f5				push af  
4e5c 3a 70 4e			ld a, (.dmark)  
4e5f 32 77 fb			ld (debug_mark),a  
4e62 3a 71 4e			ld a, (.dmark+1)  
4e65 32 78 fb			ld (debug_mark+1),a  
4e68 3a 72 4e			ld a, (.dmark+2)  
4e6b 32 79 fb			ld (debug_mark+2),a  
4e6e 18 03			jr .pastdmark  
4e70 ..			.dmark: db "OUT"  
4e73 f1			.pastdmark: pop af  
4e74			endm  
# End of macro DMARK
4e74						CALLMONITOR 
4e74 cd 4d 17			call break_point_state  
4e77				endm  
# End of macro CALLMONITOR
4e77					endif 
4e77			 
4e77 ed 69				out (c), l 
4e79			 
4e79					NEXTW 
4e79 c3 46 20			jp macro_next 
4e7c				endm 
# End of macro NEXTW
4e7c			 
4e7c			 
4e7c			.SPIO: 
4e7c			 
4e7c			if STORAGE_SE 
4e7c				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
4e7c 51				db WORD_SYS_CORE+61             
4e7d 8d 4e			dw .SPICEH            
4e7f 07				db 6 + 1 
4e80 .. 00			db "SPICEL",0              
4e87				endm 
# End of macro CWHEAD
4e87			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
4e87			 
4e87 cd 98 01				call spi_ce_low 
4e8a			    NEXTW 
4e8a c3 46 20			jp macro_next 
4e8d				endm 
# End of macro NEXTW
4e8d			 
4e8d			.SPICEH: 
4e8d				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
4e8d 51				db WORD_SYS_CORE+61             
4e8e 9e 4e			dw .SPIOb            
4e90 07				db 6 + 1 
4e91 .. 00			db "SPICEH",0              
4e98				endm 
# End of macro CWHEAD
4e98			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
4e98			 
4e98 cd 87 01				call spi_ce_high 
4e9b			    NEXTW 
4e9b c3 46 20			jp macro_next 
4e9e				endm 
# End of macro NEXTW
4e9e			 
4e9e			 
4e9e			.SPIOb: 
4e9e			 
4e9e				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
4e9e 51				db WORD_SYS_CORE+61             
4e9f b4 4e			dw .SPII            
4ea1 05				db 4 + 1 
4ea2 .. 00			db "SPIO",0              
4ea7				endm 
# End of macro CWHEAD
4ea7			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
4ea7			 
4ea7					; get port 
4ea7			 
4ea7			 
4ea7					; get byte to send 
4ea7			 
4ea7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4ea7 cd d4 1e			call macro_dsp_valuehl 
4eaa				endm 
# End of macro FORTH_DSP_VALUEHL
4eaa			 
4eaa			;		push hl    ; u1  
4eaa			 
4eaa					; destroy value TOS 
4eaa			 
4eaa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4eaa cd 8c 1f			call macro_forth_dsp_pop 
4ead				endm 
# End of macro FORTH_DSP_POP
4ead			 
4ead					; one value on hl get other one back 
4ead			 
4ead			;		pop hl   ; u2 - addr 
4ead			 
4ead					; TODO Send SPI byte 
4ead			 
4ead 7d					ld a, l 
4eae cd bc 00				call spi_send_byte 
4eb1			 
4eb1					NEXTW 
4eb1 c3 46 20			jp macro_next 
4eb4				endm 
# End of macro NEXTW
4eb4			 
4eb4			.SPII: 
4eb4				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
4eb4 52				db WORD_SYS_CORE+62             
4eb5 c9 4e			dw .SESEL            
4eb7 06				db 5 + 1 
4eb8 .. 00			db "SPII",0              
4ebd				endm 
# End of macro CWHEAD
4ebd			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
4ebd			 
4ebd					; TODO Get SPI byte 
4ebd			 
4ebd cd dd 00				call spi_read_byte 
4ec0			 
4ec0 26 00				ld h, 0 
4ec2 6f					ld l, a 
4ec3 cd dd 1c				call forth_push_numhl 
4ec6			 
4ec6					NEXTW 
4ec6 c3 46 20			jp macro_next 
4ec9				endm 
# End of macro NEXTW
4ec9			 
4ec9			 
4ec9			 
4ec9			.SESEL: 
4ec9				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
4ec9 66				db WORD_SYS_CORE+82             
4eca 6d 4f			dw .CARTDEV            
4ecc 05				db 4 + 1 
4ecd .. 00			db "BANK",0              
4ed2				endm 
# End of macro CWHEAD
4ed2			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
4ed2					if DEBUG_FORTH_WORDS_KEY 
4ed2						DMARK "BNK" 
4ed2 f5				push af  
4ed3 3a e7 4e			ld a, (.dmark)  
4ed6 32 77 fb			ld (debug_mark),a  
4ed9 3a e8 4e			ld a, (.dmark+1)  
4edc 32 78 fb			ld (debug_mark+1),a  
4edf 3a e9 4e			ld a, (.dmark+2)  
4ee2 32 79 fb			ld (debug_mark+2),a  
4ee5 18 03			jr .pastdmark  
4ee7 ..			.dmark: db "BNK"  
4eea f1			.pastdmark: pop af  
4eeb			endm  
# End of macro DMARK
4eeb						CALLMONITOR 
4eeb cd 4d 17			call break_point_state  
4eee				endm  
# End of macro CALLMONITOR
4eee					endif 
4eee			 
4eee 3e ff				ld a, 255 
4ef0 32 4b f8				ld (spi_cartdev), a 
4ef3			 
4ef3					; get bank 
4ef3			 
4ef3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4ef3 cd d4 1e			call macro_dsp_valuehl 
4ef6				endm 
# End of macro FORTH_DSP_VALUEHL
4ef6			 
4ef6			;		push hl 
4ef6			 
4ef6					; destroy value TOS 
4ef6			 
4ef6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ef6 cd 8c 1f			call macro_forth_dsp_pop 
4ef9				endm 
# End of macro FORTH_DSP_POP
4ef9			 
4ef9					; one value on hl get other one back 
4ef9			 
4ef9			;		pop hl 
4ef9			 
4ef9			 
4ef9 0e ff				ld c, SPI_CE_HIGH 
4efb 06 30				ld b, '0'    ; human readable bank number 
4efd			 
4efd 7d					ld a, l 
4efe			 
4efe					if DEBUG_FORTH_WORDS 
4efe						DMARK "BNK" 
4efe f5				push af  
4eff 3a 13 4f			ld a, (.dmark)  
4f02 32 77 fb			ld (debug_mark),a  
4f05 3a 14 4f			ld a, (.dmark+1)  
4f08 32 78 fb			ld (debug_mark+1),a  
4f0b 3a 15 4f			ld a, (.dmark+2)  
4f0e 32 79 fb			ld (debug_mark+2),a  
4f11 18 03			jr .pastdmark  
4f13 ..			.dmark: db "BNK"  
4f16 f1			.pastdmark: pop af  
4f17			endm  
# End of macro DMARK
4f17						CALLMONITOR 
4f17 cd 4d 17			call break_point_state  
4f1a				endm  
# End of macro CALLMONITOR
4f1a					endif 
4f1a			 
4f1a					; active low 
4f1a			 
4f1a fe 00				cp 0 
4f1c 28 28				jr z, .bset 
4f1e fe 01				cp 1 
4f20 20 04				jr nz, .b2 
4f22 cb 81				res 0, c 
4f24 06 31				ld b, '1'    ; human readable bank number 
4f26 fe 02		.b2:		cp 2 
4f28 20 04				jr nz, .b3 
4f2a cb 89				res 1, c 
4f2c 06 32				ld b, '2'    ; human readable bank number 
4f2e fe 03		.b3:		cp 3 
4f30 20 04				jr nz, .b4 
4f32 cb 91				res 2, c 
4f34 06 33				ld b, '3'    ; human readable bank number 
4f36 fe 04		.b4:		cp 4 
4f38 20 04				jr nz, .b5 
4f3a cb 99				res 3, c 
4f3c 06 34				ld b, '4'    ; human readable bank number 
4f3e fe 05		.b5:		cp 5 
4f40 20 04				jr nz, .bset 
4f42 cb a1				res 4, c 
4f44 06 35				ld b, '5'    ; human readable bank number 
4f46			 
4f46			.bset: 
4f46 79					ld a, c 
4f47 32 48 f8				ld (spi_device),a 
4f4a 78					ld a, b 
4f4b 32 47 f8				ld (spi_device_id),a 
4f4e					if DEBUG_FORTH_WORDS 
4f4e						DMARK "BN2" 
4f4e f5				push af  
4f4f 3a 63 4f			ld a, (.dmark)  
4f52 32 77 fb			ld (debug_mark),a  
4f55 3a 64 4f			ld a, (.dmark+1)  
4f58 32 78 fb			ld (debug_mark+1),a  
4f5b 3a 65 4f			ld a, (.dmark+2)  
4f5e 32 79 fb			ld (debug_mark+2),a  
4f61 18 03			jr .pastdmark  
4f63 ..			.dmark: db "BN2"  
4f66 f1			.pastdmark: pop af  
4f67			endm  
# End of macro DMARK
4f67						CALLMONITOR 
4f67 cd 4d 17			call break_point_state  
4f6a				endm  
# End of macro CALLMONITOR
4f6a					endif 
4f6a			 
4f6a					NEXTW 
4f6a c3 46 20			jp macro_next 
4f6d				endm 
# End of macro NEXTW
4f6d			 
4f6d			.CARTDEV: 
4f6d				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
4f6d 66				db WORD_SYS_CORE+82             
4f6e 16 50			dw .ENDDEVICE            
4f70 08				db 7 + 1 
4f71 .. 00			db "CARTDEV",0              
4f79				endm 
# End of macro CWHEAD
4f79			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
4f79					if DEBUG_FORTH_WORDS_KEY 
4f79						DMARK "CDV" 
4f79 f5				push af  
4f7a 3a 8e 4f			ld a, (.dmark)  
4f7d 32 77 fb			ld (debug_mark),a  
4f80 3a 8f 4f			ld a, (.dmark+1)  
4f83 32 78 fb			ld (debug_mark+1),a  
4f86 3a 90 4f			ld a, (.dmark+2)  
4f89 32 79 fb			ld (debug_mark+2),a  
4f8c 18 03			jr .pastdmark  
4f8e ..			.dmark: db "CDV"  
4f91 f1			.pastdmark: pop af  
4f92			endm  
# End of macro DMARK
4f92						CALLMONITOR 
4f92 cd 4d 17			call break_point_state  
4f95				endm  
# End of macro CALLMONITOR
4f95					endif 
4f95			 
4f95					; disable se storage bank selection 
4f95			 
4f95 3e ff				ld a, SPI_CE_HIGH		; ce high 
4f97 32 48 f8				ld (spi_device), a 
4f9a			 
4f9a					; get bank 
4f9a			 
4f9a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4f9a cd d4 1e			call macro_dsp_valuehl 
4f9d				endm 
# End of macro FORTH_DSP_VALUEHL
4f9d			 
4f9d			;		push hl 
4f9d			 
4f9d					; destroy value TOS 
4f9d			 
4f9d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4f9d cd 8c 1f			call macro_forth_dsp_pop 
4fa0				endm 
# End of macro FORTH_DSP_POP
4fa0			 
4fa0					; one value on hl get other one back 
4fa0			 
4fa0			;		pop hl 
4fa0			 
4fa0					; active low 
4fa0			 
4fa0 0e ff				ld c, 255 
4fa2			 
4fa2 7d					ld a, l 
4fa3					if DEBUG_FORTH_WORDS 
4fa3						DMARK "CDV" 
4fa3 f5				push af  
4fa4 3a b8 4f			ld a, (.dmark)  
4fa7 32 77 fb			ld (debug_mark),a  
4faa 3a b9 4f			ld a, (.dmark+1)  
4fad 32 78 fb			ld (debug_mark+1),a  
4fb0 3a ba 4f			ld a, (.dmark+2)  
4fb3 32 79 fb			ld (debug_mark+2),a  
4fb6 18 03			jr .pastdmark  
4fb8 ..			.dmark: db "CDV"  
4fbb f1			.pastdmark: pop af  
4fbc			endm  
# End of macro DMARK
4fbc						CALLMONITOR 
4fbc cd 4d 17			call break_point_state  
4fbf				endm  
# End of macro CALLMONITOR
4fbf					endif 
4fbf fe 00				cp 0 
4fc1 28 30				jr z, .cset 
4fc3 fe 01				cp 1 
4fc5 20 02				jr nz, .c2 
4fc7 cb 81				res 0, c 
4fc9 fe 02		.c2:		cp 2 
4fcb 20 02				jr nz, .c3 
4fcd cb 89				res 1, c 
4fcf fe 03		.c3:		cp 3 
4fd1 20 02				jr nz, .c4 
4fd3 cb 91				res 2, c 
4fd5 fe 04		.c4:		cp 4 
4fd7 20 02				jr nz, .c5 
4fd9 cb 99				res 3, c 
4fdb fe 05		.c5:		cp 5 
4fdd 20 02				jr nz, .c6 
4fdf cb a1				res 4, c 
4fe1 fe 06		.c6:		cp 6 
4fe3 20 02				jr nz, .c7 
4fe5 cb a9				res 5, c 
4fe7 fe 07		.c7:		cp 7 
4fe9 20 02				jr nz, .c8 
4feb cb b1				res 6, c 
4fed fe 08		.c8:		cp 8 
4fef 20 02				jr nz, .cset 
4ff1 cb b9				res 7, c 
4ff3 79			.cset:		ld a, c 
4ff4 32 4b f8				ld (spi_cartdev),a 
4ff7			 
4ff7					if DEBUG_FORTH_WORDS 
4ff7						DMARK "CD2" 
4ff7 f5				push af  
4ff8 3a 0c 50			ld a, (.dmark)  
4ffb 32 77 fb			ld (debug_mark),a  
4ffe 3a 0d 50			ld a, (.dmark+1)  
5001 32 78 fb			ld (debug_mark+1),a  
5004 3a 0e 50			ld a, (.dmark+2)  
5007 32 79 fb			ld (debug_mark+2),a  
500a 18 03			jr .pastdmark  
500c ..			.dmark: db "CD2"  
500f f1			.pastdmark: pop af  
5010			endm  
# End of macro DMARK
5010						CALLMONITOR 
5010 cd 4d 17			call break_point_state  
5013				endm  
# End of macro CALLMONITOR
5013					endif 
5013					NEXTW 
5013 c3 46 20			jp macro_next 
5016				endm 
# End of macro NEXTW
5016			endif 
5016			 
5016			.ENDDEVICE: 
5016			; eof 
5016			 
# End of file forth_words_device.asm
5016			 
5016			; var handler 
5016			 
5016			 
5016			.VARS: 
5016				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
5016 78				db WORD_SYS_CORE+100             
5017 2e 50			dw .V0Q            
5019 04				db 3 + 1 
501a .. 00			db "V0!",0              
501e				endm 
# End of macro CWHEAD
501e			;| V0! ( u1 -- )  Store value to v0  | DONE 
501e			 
501e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
501e cd d4 1e			call macro_dsp_valuehl 
5021				endm 
# End of macro FORTH_DSP_VALUEHL
5021			 
5021 11 10 f8				ld de, cli_var_array 
5024			 
5024 eb					ex de, hl 
5025 73					ld (hl), e 
5026 23					inc hl 
5027 72					ld (hl), d 
5028			 
5028					; destroy value TOS 
5028			 
5028					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5028 cd 8c 1f			call macro_forth_dsp_pop 
502b				endm 
# End of macro FORTH_DSP_POP
502b			 
502b				       NEXTW 
502b c3 46 20			jp macro_next 
502e				endm 
# End of macro NEXTW
502e			.V0Q: 
502e				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
502e 79				db WORD_SYS_CORE+101             
502f 3f 50			dw .V1S            
5031 04				db 3 + 1 
5032 .. 00			db "V0@",0              
5036				endm 
# End of macro CWHEAD
5036			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
5036 2a 10 f8				ld hl, (cli_var_array) 
5039 cd dd 1c				call forth_push_numhl 
503c			 
503c				       NEXTW 
503c c3 46 20			jp macro_next 
503f				endm 
# End of macro NEXTW
503f			.V1S: 
503f				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
503f 7a				db WORD_SYS_CORE+102             
5040 57 50			dw .V1Q            
5042 04				db 3 + 1 
5043 .. 00			db "V1!",0              
5047				endm 
# End of macro CWHEAD
5047			;| V1! ( u1 -- )  Store value to v1 | DONE 
5047					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5047 cd d4 1e			call macro_dsp_valuehl 
504a				endm 
# End of macro FORTH_DSP_VALUEHL
504a			 
504a 11 12 f8				ld de, cli_var_array+2 
504d				 
504d eb					ex de, hl 
504e 73					ld (hl), e 
504f 23					inc hl 
5050 72					ld (hl), d 
5051			 
5051					; destroy value TOS 
5051			 
5051					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5051 cd 8c 1f			call macro_forth_dsp_pop 
5054				endm 
# End of macro FORTH_DSP_POP
5054				       NEXTW 
5054 c3 46 20			jp macro_next 
5057				endm 
# End of macro NEXTW
5057			.V1Q: 
5057				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
5057 7b				db WORD_SYS_CORE+103             
5058 68 50			dw .V2S            
505a 04				db 3 + 1 
505b .. 00			db "V1@",0              
505f				endm 
# End of macro CWHEAD
505f			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
505f 2a 12 f8				ld hl, (cli_var_array+2) 
5062 cd dd 1c				call forth_push_numhl 
5065				       NEXTW 
5065 c3 46 20			jp macro_next 
5068				endm 
# End of macro NEXTW
5068			.V2S: 
5068				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
5068 7c				db WORD_SYS_CORE+104             
5069 80 50			dw .V2Q            
506b 04				db 3 + 1 
506c .. 00			db "V2!",0              
5070				endm 
# End of macro CWHEAD
5070			;| V2! ( u1 -- )  Store value to v2 | DONE 
5070					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5070 cd d4 1e			call macro_dsp_valuehl 
5073				endm 
# End of macro FORTH_DSP_VALUEHL
5073			 
5073 11 14 f8				ld de, cli_var_array+4 
5076				 
5076 eb					ex de, hl 
5077 73					ld (hl), e 
5078 23					inc hl 
5079 72					ld (hl), d 
507a			 
507a					; destroy value TOS 
507a			 
507a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
507a cd 8c 1f			call macro_forth_dsp_pop 
507d				endm 
# End of macro FORTH_DSP_POP
507d				       NEXTW 
507d c3 46 20			jp macro_next 
5080				endm 
# End of macro NEXTW
5080			.V2Q: 
5080				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
5080 7d				db WORD_SYS_CORE+105             
5081 91 50			dw .V3S            
5083 04				db 3 + 1 
5084 .. 00			db "V2@",0              
5088				endm 
# End of macro CWHEAD
5088			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
5088 2a 14 f8				ld hl, (cli_var_array+4) 
508b cd dd 1c				call forth_push_numhl 
508e				       NEXTW 
508e c3 46 20			jp macro_next 
5091				endm 
# End of macro NEXTW
5091			.V3S: 
5091				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
5091 7c				db WORD_SYS_CORE+104             
5092 a9 50			dw .V3Q            
5094 04				db 3 + 1 
5095 .. 00			db "V3!",0              
5099				endm 
# End of macro CWHEAD
5099			;| V3! ( u1 -- )  Store value to v3 | DONE 
5099					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5099 cd d4 1e			call macro_dsp_valuehl 
509c				endm 
# End of macro FORTH_DSP_VALUEHL
509c			 
509c 11 16 f8				ld de, cli_var_array+6 
509f				 
509f eb					ex de, hl 
50a0 73					ld (hl), e 
50a1 23					inc hl 
50a2 72					ld (hl), d 
50a3			 
50a3					; destroy value TOS 
50a3			 
50a3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
50a3 cd 8c 1f			call macro_forth_dsp_pop 
50a6				endm 
# End of macro FORTH_DSP_POP
50a6				       NEXTW 
50a6 c3 46 20			jp macro_next 
50a9				endm 
# End of macro NEXTW
50a9			.V3Q: 
50a9				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
50a9 7d				db WORD_SYS_CORE+105             
50aa ba 50			dw .END            
50ac 04				db 3 + 1 
50ad .. 00			db "V3@",0              
50b1				endm 
# End of macro CWHEAD
50b1			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
50b1 2a 16 f8				ld hl, (cli_var_array+6) 
50b4 cd dd 1c				call forth_push_numhl 
50b7				       NEXTW 
50b7 c3 46 20			jp macro_next 
50ba				endm 
# End of macro NEXTW
50ba			 
50ba			 
50ba			 
50ba			 
50ba			 
50ba			; end of dict marker 
50ba			 
50ba 00			.END:    db WORD_SYS_END 
50bb 00 00			dw 0 
50bd 00				db 0 
50be			 
50be			; use to jp here for user dict words to save on macro expansion  
50be			 
50be			user_dict_next: 
50be				NEXTW 
50be c3 46 20			jp macro_next 
50c1				endm 
# End of macro NEXTW
50c1			 
50c1			 
50c1			user_exec: 
50c1				;    ld hl, <word code> 
50c1				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
50c1				;    call forthexec 
50c1				;    jp user_dict_next   (NEXT) 
50c1			        ;    <word code bytes> 
50c1 eb				ex de, hl 
50c2 2a 1e f1			ld hl,(os_tok_ptr) 
50c5				 
50c5				FORTH_RSP_NEXT 
50c5 cd 84 1c			call macro_forth_rsp_next 
50c8				endm 
# End of macro FORTH_RSP_NEXT
50c8			 
50c8			if DEBUG_FORTH_UWORD 
50c8						DMARK "UEX" 
50c8 f5				push af  
50c9 3a dd 50			ld a, (.dmark)  
50cc 32 77 fb			ld (debug_mark),a  
50cf 3a de 50			ld a, (.dmark+1)  
50d2 32 78 fb			ld (debug_mark+1),a  
50d5 3a df 50			ld a, (.dmark+2)  
50d8 32 79 fb			ld (debug_mark+2),a  
50db 18 03			jr .pastdmark  
50dd ..			.dmark: db "UEX"  
50e0 f1			.pastdmark: pop af  
50e1			endm  
# End of macro DMARK
50e1				CALLMONITOR 
50e1 cd 4d 17			call break_point_state  
50e4				endm  
# End of macro CALLMONITOR
50e4			endif 
50e4			 
50e4			 
50e4			 
50e4 eb				ex de, hl 
50e5 22 1e f1			ld (os_tok_ptr), hl 
50e8				 
50e8				; Don't use next - Skips the first word in uword. 
50e8			 
50e8 c3 d7 20			jp exec1 
50eb			;	NEXT 
50eb			 
50eb			 
50eb			; eof 
# End of file forth_wordsv4.asm
50eb			endif 
50eb			;;;;;;;;;;;;;; Debug code 
50eb			 
50eb			 
50eb			;if DEBUG_FORTH_PARSE 
50eb .. 00		.nowordfound: db "No match",0 
50f4 .. 00		.compword:	db "Comparing word ",0 
5104 .. 00		.nextwordat:	db "Next word at",0 
5111 .. 00		.charmatch:	db "Char match",0 
511c			;endif 
511c			if DEBUG_FORTH_JP 
511c			.foundword:	db "Word match. Exec..",0 
511c			endif 
511c			;if DEBUG_FORTH_PUSH 
511c .. 00		.enddict:	db "Dict end. Push.",0 
512c .. 00		.push_str:	db "Pushing string",0 
513b .. 00		.push_num:	db "Pushing number",0 
514a .. 00		.data_sp:	db "SP:",0 
514e .. 00		.wordinhl:	db "Word in HL (2/0):",0 
5160 .. 00		.wordinde:	db "Word in DE (3/0):",0 
5172 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
5184			;endif 
5184			;if DEBUG_FORTH_MALLOC 
5184 .. 00		.push_malloc:	db "Malloc address",0 
5193			;endif 
5193			 
5193			 
5193			 
5193			; display malloc address and current data stack pointer  
5193			 
5193			malloc_error: 
5193 d5				push de 
5194 f5				push af 
5195 e5				push hl 
5196 cd d5 0a			call clear_display 
5199 11 bb 51			ld de, .mallocerr 
519c 3e 00			ld a,0 
519e			;	ld de,os_word_scratch 
519e cd e8 0a			call str_at_display 
51a1 3e 11			ld a, display_row_1+17 
51a3 11 77 fb			ld de, debug_mark 
51a6 cd e8 0a			call str_at_display 
51a9 cd f8 0a			call update_display 
51ac				;call break_point_state 
51ac cd b5 68			call cin_wait 
51af			 
51af 3e 20			ld a, ' ' 
51b1 32 0e ee			ld (os_view_disable), a 
51b4 e1				pop hl 
51b5 f1				pop af 
51b6 d1				pop de	 
51b7				CALLMONITOR 
51b7 cd 4d 17			call break_point_state  
51ba				endm  
# End of macro CALLMONITOR
51ba c9				ret 
51bb			 
51bb .. 00		.mallocerr: 	db "Malloc Error",0 
51c8			;if DEBUG_FORTH_PUSH 
51c8			display_data_sp: 
51c8 f5				push af 
51c9			 
51c9				; see if disabled 
51c9			 
51c9 3a 0e ee			ld a, (os_view_disable) 
51cc fe 2a			cp '*' 
51ce 28 67			jr z, .skipdsp 
51d0			 
51d0 e5				push hl 
51d1 e5				push hl 
51d2 e5			push hl 
51d3 cd d5 0a			call clear_display 
51d6 e1			pop hl 
51d7 7c				ld a,h 
51d8 21 22 f1			ld hl, os_word_scratch 
51db cd 0a 10			call hexout 
51de e1				pop hl 
51df 7d				ld a,l 
51e0 21 24 f1			ld hl, os_word_scratch+2 
51e3 cd 0a 10			call hexout 
51e6 21 26 f1			ld hl, os_word_scratch+4 
51e9 3e 00			ld a,0 
51eb 77				ld (hl),a 
51ec 11 22 f1			ld de,os_word_scratch 
51ef 3e 28				ld a, display_row_2 
51f1 cd e8 0a				call str_at_display 
51f4 11 4e 51			ld de, .wordinhl 
51f7 3e 00			ld a, display_row_1 
51f9			 
51f9 cd e8 0a				call str_at_display 
51fc 11 77 fb			ld de, debug_mark 
51ff 3e 11			ld a, display_row_1+17 
5201			 
5201 cd e8 0a				call str_at_display 
5204			 
5204				; display current data stack pointer 
5204 11 4a 51			ld de,.data_sp 
5207 3e 30				ld a, display_row_2 + 8 
5209 cd e8 0a				call str_at_display 
520c			 
520c 2a 0a f8			ld hl,(cli_data_sp) 
520f e5				push hl 
5210 7c				ld a,h 
5211 21 22 f1			ld hl, os_word_scratch 
5214 cd 0a 10			call hexout 
5217 e1				pop hl 
5218 7d				ld a,l 
5219 21 24 f1			ld hl, os_word_scratch+2 
521c cd 0a 10			call hexout 
521f 21 26 f1			ld hl, os_word_scratch+4 
5222 3e 00			ld a,0 
5224 77				ld (hl),a 
5225 11 22 f1			ld de,os_word_scratch 
5228 3e 33				ld a, display_row_2 + 11 
522a cd e8 0a				call str_at_display 
522d			 
522d			 
522d cd f8 0a			call update_display 
5230 cd 55 0a			call delay1s 
5233 cd 55 0a			call delay1s 
5236 e1				pop hl 
5237			.skipdsp: 
5237 f1				pop af 
5238 c9				ret 
5239			 
5239			display_data_malloc: 
5239			 
5239 f5				push af 
523a e5				push hl 
523b e5				push hl 
523c e5			push hl 
523d cd d5 0a			call clear_display 
5240 e1			pop hl 
5241 7c				ld a,h 
5242 21 22 f1			ld hl, os_word_scratch 
5245 cd 0a 10			call hexout 
5248 e1				pop hl 
5249 7d				ld a,l 
524a 21 24 f1			ld hl, os_word_scratch+2 
524d cd 0a 10			call hexout 
5250 21 26 f1			ld hl, os_word_scratch+4 
5253 3e 00			ld a,0 
5255 77				ld (hl),a 
5256 11 22 f1			ld de,os_word_scratch 
5259 3e 28				ld a, display_row_2 
525b cd e8 0a				call str_at_display 
525e 11 84 51			ld de, .push_malloc 
5261 3e 00			ld a, display_row_1 
5263			 
5263 cd e8 0a				call str_at_display 
5266			 
5266				; display current data stack pointer 
5266 11 4a 51			ld de,.data_sp 
5269 3e 30				ld a, display_row_2 + 8 
526b cd e8 0a				call str_at_display 
526e			 
526e 2a 0a f8			ld hl,(cli_data_sp) 
5271 e5				push hl 
5272 7c				ld a,h 
5273 21 22 f1			ld hl, os_word_scratch 
5276 cd 0a 10			call hexout 
5279 e1				pop hl 
527a 7d				ld a,l 
527b 21 24 f1			ld hl, os_word_scratch+2 
527e cd 0a 10			call hexout 
5281 21 26 f1			ld hl, os_word_scratch+4 
5284 3e 00			ld a,0 
5286 77				ld (hl),a 
5287 11 22 f1			ld de,os_word_scratch 
528a 3e 33				ld a, display_row_2 + 11 
528c cd e8 0a				call str_at_display 
528f			 
528f cd f8 0a			call update_display 
5292 cd 55 0a			call delay1s 
5295 cd 55 0a			call delay1s 
5298 e1				pop hl 
5299 f1				pop af 
529a c9				ret 
529b			;endif 
529b			 
529b			include "forth_autostart.asm" 
529b			; list of commands to perform at system start up 
529b			 
529b			startcmds: 
529b			;	dw test11 
529b			;	dw test12 
529b			;	dw test13 
529b			;	dw test14 
529b			;	dw test15 
529b			;	dw test16 
529b			;	dw test17 
529b			;	dw ifthtest1 
529b			;	dw ifthtest2 
529b			;	dw ifthtest3 
529b			;	dw mmtest1 
529b			;	dw mmtest2 
529b			;	dw mmtest3 
529b			;	dw mmtest4 
529b			;	dw mmtest5 
529b			;	dw mmtest6 
529b			;	dw iftest1 
529b			;	dw iftest2 
529b			;	dw iftest3 
529b			;	dw looptest1 
529b			;	dw looptest2 
529b			;	dw test1 
529b			;	dw test2 
529b			;	dw test3 
529b			;	dw test4 
529b			;	dw game2r 
529b			;	dw game2b1 
529b			;	dw game2b2 
529b			 
529b				; start up words that are actually useful 
529b			 
529b f9 52			dw clrstack 
529d 2c 53			dw type 
529f ed 54			dw stest 
52a1 50 53			dw strncpy 
52a3 8e 54			dw list 
52a5 b1 53			dw start1 
52a7 c3 53			dw start2 
52a9			;	dw start3 
52a9 d6 53			dw start3b 
52ab 2e 54			dw start3c 
52ad			 
52ad				; (unit) testing words 
52ad			 
52ad 64 55			dw mtesta 
52af 19 56			dw mtestb 
52b1 bc 56			dw mtestc 
52b3 71 57			dw mtestd 
52b5 15 58			dw mteste 
52b7			 
52b7				; demo/game words 
52b7			 
52b7 21 5f		        dw game3w 
52b9 4f 5f		        dw game3p 
52bb 6d 5f		        dw game3sc 
52bd 9e 5f		        dw game3vsi 
52bf ca 5f		        dw game3vs 
52c1				 
52c1 14 5d			dw game2b 
52c3 82 5d			dw game2bf 
52c5 cc 5d			dw game2mba 
52c7 62 5e			dw game2mbas 
52c9 a4 5e			dw game2mb 
52cb			 
52cb d5 59			dw game1 
52cd e6 59			dw game1a 
52cf 48 5a			dw game1b 
52d1 7d 5a			dw game1c 
52d3 b3 5a			dw game1d 
52d5 e4 5a			dw game1s 
52d7 f8 5a			dw game1t 
52d9 0d 5b			dw game1f 
52db 41 5b			dw game1z 
52dd 85 5b			dw game1zz 
52df			 
52df cb 58			dw test5 
52e1 03 59			dw test6 
52e3 3b 59			dw test7 
52e5 4f 59			dw test8 
52e7 7b 59			dw test9 
52e9 91 59			dw test10 
52eb				 
52eb 5c 5c		        dw ssv5 
52ed 40 5c		        dw ssv4 
52ef 24 5c		        dw ssv3 
52f1 ee 5b		        dw ssv2 
52f3 75 5c		        dw ssv1 
52f5 bd 5c		        dw ssv1cpm 
52f7			;	dw keyup 
52f7			;	dw keydown 
52f7			;	dw keyleft 
52f7			;	dw keyright 
52f7			;	dw 	keyf1 
52f7			;	dw keyf2 
52f7			;	dw keyf3 
52f7			;	dw keyf4 
52f7			;	dw keyf5 
52f7			;	dw keyf6 
52f7			;	dw keyf7 
52f7			;	dw keyf8 
52f7			;	dw keyf9 
52f7			;	dw keyf10 
52f7			;	dw keyf11 
52f7			;	dw keyf12 
52f7			;	dw keytab 
52f7			;	dw keycr 
52f7			;	dw keyhome 
52f7			;	dw keyend 
52f7			;	dw keybs 
52f7 00 00			db 0, 0	 
52f9			 
52f9			 
52f9			; clear stack  
52f9			 
52f9 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
532c			 
532c			; type ( addr count - ) 
532c .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
5350			 
5350			; some direct memory words 
5350			; strncpy ( len t f -- t ) 
5350			 
5350 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
53b1			 
53b1 .. 00		start1:     	db ": bpon $0000 bp ;",0 
53c3 .. 00		start2:     	db ": bpoff $0001 bp ;",0 
53d6			;start3:         db ": dirlist ir cls drop dup $00 > if $01 do .> BL .> .> BL .> .> BL .> loop then nop ;",0 
53d6 .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 i at . $01 i at . $04 i at . loop then nop ;",0 
542e .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
548e			 
548e			 
548e			; a handy word to list items on the stack 
548e			 
548e .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> accept drop depth 0= not until nop ;",0 
54ed			 
54ed			 
54ed			; test stack  
54ed			; rnd8 stest 
54ed			 
54ed .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
5564			 
5564			; random malloc and free cycles 
5564			 
5564 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5619			 
5619			; fixed malloc and free cycles 
5619			 
5619 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
56bc			 
56bc			; fixed double string push and drop cycle  
56bc			 
56bc .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
5771			 
5771			; consistent fixed string push and drop cycle  
5771			 
5771 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5815			 
5815 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
58cb			 
58cb			;test1:		db ": aa 1 2 3 ;", 0 
58cb			;test2:     	db "111 aa 888 999",0 
58cb			;test3:     	db ": bb 77 ;",0 
58cb			;test4:     	db "$02 $01 do i . loop bb",0 
58cb			 
58cb .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
5903 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
593b .. 00		test7:     	db ": box hline vline ;",0 
594f .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
597b .. 00		test9:     	db ": sw $01 adsp world ;",0 
5991 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
59b6 .. 00		test11:     	db "hello create .",0 
59c5 .. 00		test12:     	db "hello2 create .",0 
59d5			 
59d5			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
59d5			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
59d5			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
59d5			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
59d5			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
59d5			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
59d5			 
59d5			;iftest1:     	db "$0001 IF cls .",0 
59d5			;iftest2:     	db "$0000 IF cls .",0 
59d5			;iftest3:     	db "$0002 $0003 - IF cls .",0 
59d5			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
59d5			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
59d5			 
59d5			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
59d5			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
59d5			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
59d5			 
59d5			 
59d5			 
59d5			; a small guess the number game 
59d5			 
59d5 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
59e6 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
5a48			 
5a48 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
5a7d .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
5ab3 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
5ae4 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
5af8 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
5b0d .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5b41 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
5b85			 
5b85			; Using 'ga' save a high score across multiple runs using external storage 
5b85			 
5b85 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
5bee			 
5bee			 
5bee			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
5bee			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
5bee			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
5bee			 
5bee			; simple screen saver to test code memory reuse to destruction 
5bee			 
5bee .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
5c24 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
5c40 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
5c5c .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
5c75 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
5cbd .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
5d14			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
5d14			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
5d14			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
5d14			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
5d14			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
5d14			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
5d14			 
5d14			 
5d14			 
5d14			; minesweeper/battleship finding game 
5d14			; draws a game board of random ship/mine positions 
5d14			; user enters coords to see if it hits on 
5d14			; game ends when all are hit 
5d14			; when hit or miss says how many may be in the area 
5d14			 
5d14			; setup the game board and then hide it 
5d14 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
5d82 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
5dcc			; prompt for where to target 
5dcc .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
5e62 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
5e87			; TODO see if the entered coords hits or misses pushes char hit of miss 
5e87 .. 00		game2mbht:      db ": mbckht nop ;",0 
5e96 .. 00		game2mbms:      db ": mbcms nop ;",0 
5ea4			; TODO how many might be near by 
5ea4 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
5f21			 
5f21			; Game 3 
5f21			 
5f21			; Vert scroller ski game - avoid the trees! 
5f21			 
5f21			; v0 score (ie turns) 
5f21			; v1 player pos 
5f21			; v2 left wall 
5f21			; v3 right wall 
5f21			 
5f21			; Draw side walls randomly 
5f21			 
5f21 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
5f4f			 
5f4f			; Draw player 
5f4f .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
5f6d			 
5f6d			; TODO Get Key 
5f6d			 
5f6d			; TODO Move left right 
5f6d			 
5f6d			; scroll and move walls a bit 
5f6d			 
5f6d .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
5f9e			 
5f9e			; main game loop 
5f9e			 
5f9e .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
5fca .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
6009			 
6009			; key board defs 
6009			 
6009 .. 00		keyup:       db ": keyup $05 ;",0 
6017 .. 00		keydown:       db ": keydown $0a ;",0 
6027 .. 00		keyleft:       db ": keyleft $0b ;",0 
6037 .. 00		keyright:       db ": keyright $0c ;",0 
6048 .. 00		keyf1:       db ": keyf1 $10 ;",0 
6056 .. 00		keyf2:       db ": keyf2 $11 ;",0 
6064 .. 00		keyf3:       db ": keyf3 $12 ;",0 
6072 .. 00		keyf4:       db ": keyf4 $13 ;",0 
6080 .. 00		keyf5:       db ": keyf5 $14 ;",0 
608e .. 00		keyf6:       db ": keyf6 $15 ;",0 
609c .. 00		keyf7:       db ": keyf7 $16 ;",0 
60aa .. 00		keyf8:       db ": keyf8 $17 ;",0 
60b8 .. 00		keyf9:       db ": keyf9 $18 ;",0 
60c6 .. 00		keyf10:       db ": keyf10 $19 ;",0 
60d5 .. 00		keyf11:       db ": keyf11 $1a ;",0 
60e4 .. 00		keyf12:       db ": keyf12 $1b ;",0 
60f3			 
60f3 .. 00		keytab:       db ": keytab $09 ;",0 
6102 .. 00		keycr:       db ": keycr $0d ;",0 
6110 .. 00		keyhome:       db ": keyhome $0e ;",0 
6120 .. 00		keyend:       db ": keyend $0f ;",0 
612f .. 00		keybs:       db ": keybs $08 ;",0 
613d			 
613d			   
613d			 
613d			 
613d			 
613d			; eof 
# End of file forth_autostart.asm
613d			 
613d .. 00		sprompt1: db "Startup load...",0 
614d .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
6163			 
6163			 
6163			 
6163			 
6163			forth_startup: 
6163 21 9b 52			ld hl, startcmds 
6166 3e 00			ld a, 0 
6168 32 43 f2			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
616b			 
616b e5			.start1:	push hl 
616c cd d5 0a			call clear_display 
616f 11 3d 61			ld de, sprompt1 
6172 3e 00		        ld a, display_row_1 
6174 cd e8 0a			call str_at_display 
6177 11 4d 61			ld de, sprompt2 
617a 3e 28		        ld a, display_row_2 
617c cd e8 0a			call str_at_display 
617f e1				pop hl 
6180 e5				push hl 
6181 5e				ld e,(hl) 
6182 23				inc hl 
6183 56				ld d,(hl) 
6184 3e 50		        ld a, display_row_3 
6186 cd e8 0a			call str_at_display 
6189 cd f8 0a			call update_display 
618c			 
618c			 
618c 3a 43 f2			ld a, (os_last_cmd) 
618f fe 00			cp 0 
6191 28 05			jr z, .startprompt 
6193 cd 49 0a			call delay250ms 
6196 18 24			jr .startdo 
6198				 
6198				 
6198			 
6198			.startprompt: 
6198			 
6198 3e 9f			ld a,display_row_4 + display_cols - 1 
619a 11 53 1c		        ld de, endprg 
619d cd e8 0a			call str_at_display 
61a0 cd f8 0a			call update_display 
61a3 cd 55 0a			call delay1s 
61a6 cd b5 68			call cin_wait 
61a9						 
61a9 fe 2a			cp '*' 
61ab 28 5e			jr z, .startupend1 
61ad fe 23			cp '#' 
61af 20 07			jr nz, .startno 
61b1 3e 01			ld a, 1 
61b3 32 43 f2			ld (os_last_cmd),a 
61b6 18 04			jr .startdo 
61b8 fe 31		.startno:	cp '1' 
61ba 28 3a			jr z,.startnxt  
61bc			 
61bc				; exec startup line 
61bc			.startdo:	 
61bc e1				pop hl 
61bd e5				push hl 
61be				 
61be 5e				ld e,(hl) 
61bf 23				inc hl 
61c0 56				ld d,(hl) 
61c1 eb				ex de,hl 
61c2			 
61c2 e5				push hl 
61c3			 
61c3 3e 00			ld a, 0 
61c5				;ld a, FORTH_END_BUFFER 
61c5 cd 72 11			call strlent 
61c8 23				inc hl   ; include zero term to copy 
61c9 06 00			ld b,0 
61cb 4d				ld c,l 
61cc e1				pop hl 
61cd 11 1d ee			ld de, scratch 
61d0 ed b0			ldir 
61d2			 
61d2			 
61d2 21 1d ee			ld hl, scratch 
61d5 cd 94 20			call forthparse 
61d8 cd d4 20			call forthexec 
61db cd eb 1f			call forthexec_cleanup 
61de			 
61de 3e 78			ld a, display_row_4 
61e0 11 f7 19			ld de, endprog 
61e3			 
61e3 cd f8 0a			call update_display		 
61e6			 
61e6 3a 43 f2			ld a, (os_last_cmd) 
61e9 fe 00			cp 0 
61eb 20 09			jr nz, .startnxt 
61ed cd 55 1c			call next_page_prompt 
61f0 cd d5 0a		        call clear_display 
61f3 cd f8 0a			call update_display		 
61f6			 
61f6				; move onto next startup line? 
61f6			.startnxt: 
61f6			 
61f6 cd 49 0a			call delay250ms 
61f9 e1				pop hl 
61fa			 
61fa 23				inc hl 
61fb 23				inc hl 
61fc			 
61fc e5				push hl 
61fd 5e				ld e, (hl) 
61fe 23				inc hl 
61ff 56				ld d, (hl) 
6200 e1				pop hl 
6201				; TODO replace 0 test 
6201			 
6201 eb				ex de, hl 
6202 cd 32 0d			call ishlzero 
6205			;	ld a,e 
6205			;	add d 
6205			;	cp 0    ; any left to do? 
6205 eb				ex de, hl 
6206 c2 6b 61			jp nz, .start1 
6209 18 01			jr .startupend 
620b			 
620b e1			.startupend1: pop hl 
620c			.startupend: 
620c			 
620c cd d5 0a			call clear_display 
620f cd f8 0a			call update_display 
6212 c9				ret 
6213			 
6213			 
6213			; stack over and underflow checks 
6213			 
6213			; init the words to detect the under/overflow 
6213			 
6213			chk_stk_init: 
6213				; a vague random number to check so we dont get any "lucky" hits 
6213 3e 2d			ld a, 45 
6215 6f				ld l, a 
6216 00				nop 
6217 3e 17			ld a, 23 
6219 67				ld h, a 
621a			 
621a 22 04 ee			ld (chk_word), hl     ; the word we need to check against 
621d			 
621d			;	ld (chk_stund), hl	; stack points.... 
621d 22 fd fb			ld (chk_stovr), hl 
6220 22 08 f8			ld (chk_ret_und), hl 
6223 22 86 f7			ld (chk_ret_ovr), hl 
6226 22 84 f5			ld (chk_loop_ovr), hl 
6229 22 82 f3			ld (chk_data_ovr), hl 
622c c9				ret 
622d				 
622d			check_stacks: 
622d				; check all stack words 
622d			 
622d e5				push hl 
622e d5				push de 
622f			 
622f			;	ld de,(chk_word) 
622f			;	ld hl, (chk_stund)	; stack points.... 
622f			;	if DEBUG_STK_FAULT 
622f			;		DMARK "FAa" 
622f			;		CALLMONITOR 
622f			;	endif 
622f			;	call cmp16 
622f			;	jp z, .chk_faulta 
622f			; 
622f			;	ld de, sfaultsu 
622f			;	jp .chk_fault 
622f			 
622f 2a fd fb		.chk_faulta: ld hl, (chk_stovr) 
6232 ed 5b 04 ee		ld de,(chk_word) 
6236				if DEBUG_STK_FAULT 
6236					DMARK "FAb" 
6236					CALLMONITOR 
6236				endif 
6236 cd 27 0d			call cmp16 
6239 28 06			jr z, .chk_fault1 
623b 11 dc 62			ld de, sfaultso 
623e c3 90 62			jp .chk_fault 
6241			.chk_fault1:  
6241 2a 08 f8			ld hl, (chk_ret_und) 
6244 ed 5b 04 ee		ld de,(chk_word) 
6248				if DEBUG_STK_FAULT 
6248					DMARK "FAU" 
6248					CALLMONITOR 
6248				endif 
6248 cd 27 0d			call cmp16 
624b ca 54 62			jp z, .chk_fault2 
624e 11 ec 62			ld de, sfaultru 
6251 c3 90 62			jp .chk_fault 
6254			.chk_fault2:  
6254 2a 86 f7			ld hl, (chk_ret_ovr) 
6257 ed 5b 04 ee		ld de,(chk_word) 
625b				if DEBUG_STK_FAULT 
625b					DMARK "FA1" 
625b					CALLMONITOR 
625b				endif 
625b cd 27 0d			call cmp16 
625e ca 67 62			jp z, .chk_fault3 
6261 11 fa 62			ld de, sfaultro 
6264 c3 90 62			jp .chk_fault 
6267			.chk_fault3:  
6267 2a 84 f5			ld hl, (chk_loop_ovr) 
626a ed 5b 04 ee		ld de,(chk_word) 
626e				if DEBUG_STK_FAULT 
626e					DMARK "FA2" 
626e					CALLMONITOR 
626e				endif 
626e cd 27 0d			call cmp16 
6271 ca 7a 62			jp z, .chk_fault4 
6274 11 14 63			ld de, sfaultlo 
6277 c3 90 62			jp .chk_fault 
627a			.chk_fault4:  
627a 2a 82 f3			ld hl, (chk_data_ovr) 
627d ed 5b 04 ee		ld de,(chk_word) 
6281				if DEBUG_STK_FAULT 
6281					DMARK "FA3" 
6281					CALLMONITOR 
6281				endif 
6281 cd 27 0d			call cmp16 
6284 ca 8d 62			jp z, .chk_fault5 
6287 11 2e 63			ld de, sfaultdo 
628a c3 90 62			jp .chk_fault 
628d			 
628d			 
628d			.chk_fault5:  
628d d1				pop de 
628e e1				pop hl 
628f			 
628f c9				ret 
6290			 
6290 cd d5 0a		.chk_fault: 	call clear_display 
6293 3e 28				ld a, display_row_2 
6295 cd e8 0a				call str_at_display 
6298 11 be 62				   ld de, .stackfault 
629b 3e 00				ld a, display_row_1 
629d cd e8 0a				call str_at_display 
62a0 11 77 fb				    ld de, debug_mark 
62a3 3e 11				ld a, display_row_1+17 
62a5 cd e8 0a				call str_at_display 
62a8 cd f8 0a				call update_display 
62ab			 
62ab				; prompt before entering montior for investigating issue 
62ab			 
62ab 3e 78			ld a, display_row_4 
62ad 11 f7 19			ld de, endprog 
62b0			 
62b0 cd f8 0a			call update_display		 
62b3			 
62b3 cd 55 1c			call next_page_prompt 
62b6			 
62b6 d1				pop de 
62b7 e1				pop hl 
62b8 cd 4b 1a				call monitor 
62bb c3 42 19				jp warmstart 
62be					;jp 0 
62be					;halt 
62be			 
62be			 
62be			 
62be .. 00		.stackfault: 	db "Stack fault:",0 
62cb			 
62cb .. 00		sfaultsu: 	db	"Stack under flow",0 
62dc .. 00		sfaultso: 	db	"Stack over flow",0 
62ec .. 00		sfaultru:	db "RTS underflow",0 
62fa .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
6314 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
632e .. 00		sfaultdo:	db "DTS overflow", 0 
633b			 
633b			 
633b			fault_dsp_under: 
633b 11 4d 63			ld de, .dsp_under 
633e c3 fd 63			jp .show_fault 
6341			 
6341			fault_rsp_under: 
6341 11 5b 63			ld de, .rsp_under 
6344 c3 fd 63			jp .show_fault 
6347			fault_loop_under: 
6347 11 69 63			ld de, .loop_under 
634a c3 fd 63			jp .show_fault 
634d			 
634d .. 00		.dsp_under: db "DSP Underflow",0 
635b .. 00		.rsp_under: db "RSP Underflow",0 
6369 .. 00		.loop_under: db "LOOP Underflow",0 
6378			 
6378			 
6378 d5			type_faultn: 	push de 
6379 e5					push hl 
637a cd d5 0a				call clear_display 
637d 11 a4 63				   ld de, .typefaultn 
6380 3e 00				ld a, display_row_1 
6382 cd e8 0a				call str_at_display 
6385 11 77 fb				    ld de, debug_mark 
6388 3e 11				ld a, display_row_1+17 
638a cd e8 0a				call str_at_display 
638d cd f8 0a				call update_display 
6390			 
6390				; prompt before entering montior for investigating issue 
6390			 
6390 3e 78			ld a, display_row_4 
6392 11 f7 19			ld de, endprog 
6395			 
6395 cd f8 0a			call update_display		 
6398			 
6398 cd 55 1c			call next_page_prompt 
639b			 
639b e5					push hl 
639c d5					push de 
639d cd 4b 1a				call monitor 
63a0 c3 42 19				jp warmstart 
63a3 76					halt 
63a4			 
63a4			 
63a4 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
63bb			 
63bb d5			type_faults: 	push de 
63bc e5					push hl 
63bd cd d5 0a				call clear_display 
63c0 11 e6 63				   ld de, .typefaults 
63c3 3e 00				ld a, display_row_1 
63c5 cd e8 0a				call str_at_display 
63c8 11 77 fb				    ld de, debug_mark 
63cb 3e 11				ld a, display_row_1+17 
63cd cd e8 0a				call str_at_display 
63d0 cd f8 0a				call update_display 
63d3			 
63d3				; prompt before entering montior for investigating issue 
63d3			 
63d3 3e 78			ld a, display_row_4 
63d5 11 f7 19			ld de, endprog 
63d8			 
63d8 cd f8 0a			call update_display		 
63db			 
63db cd 55 1c			call next_page_prompt 
63de			 
63de e1					pop hl 
63df d1					pop de 
63e0 cd 4b 1a				call monitor 
63e3 c3 42 19				jp warmstart 
63e6			 
63e6			 
63e6 .. 00		.typefaults: db "STR Type Expected TOS!",0 
63fd			 
63fd			.show_fault: 	 
63fd d5					push de 
63fe cd d5 0a				call clear_display 
6401 d1					pop de 
6402 3e 00				ld a, display_row_1 
6404 cd e8 0a				call str_at_display 
6407 11 77 fb				    ld de, debug_mark 
640a 3e 11				ld a, display_row_1+17 
640c cd e8 0a				call str_at_display 
640f cd f8 0a				call update_display 
6412			 
6412				; prompt before entering montior for investigating issue 
6412			 
6412 3e 78			ld a, display_row_4 
6414 11 f7 19			ld de, endprog 
6417			 
6417 cd f8 0a			call update_display		 
641a			 
641a cd 55 1c			call next_page_prompt 
641d			 
641d e1					pop hl 
641e d1					pop de 
641f cd 4b 1a				call monitor 
6422			; do a dump to cli and not warmstart so we preserve all of the uwords.  
6422			; TODO Make optional fault restart to cli or warm boot? 
6422					;jp warmstart 
6422 c3 9d 19				jp cli 
6425 76					halt 
6426			 
6426			; handle the auto run of code from files in storage 
6426			 
6426			 
6426			if STORAGE_SE 
6426			 
6426 .. 00		sprompt3: db "Loading from start-up file?:",0 
6443 .. 00		sprompt4: db "(Y=Any key/N=No)",0 
6454			 
6454			 
6454			forth_autoload: 
6454			 
6454				; load block 0 of store 1 
6454				 
6454 3e fe			ld a, $fe      ; bit 0 clear 
6456 32 48 f8			ld (spi_device), a 
6459			 
6459 cd bd 03			call storage_get_block_0 
645c			 
645c 3a 83 f8			ld a, (store_page+STORE_0_AUTOFILE) 
645f			 
645f fe 00			cp 0 
6461 c8				ret z     ; auto start not enabled 
6462			 
6462 cd d5 0a			call clear_display 
6465			 
6465				; set bank 
6465			 
6465 3a 85 f8				ld a, (store_page+STORE_0_BANKRUN) 
6468 32 48 f8				ld (spi_device), a 
646b			 
646b				; get file id to load from and get the file name to display 
646b			 
646b 3a 86 f8				ld a, (store_page+STORE_0_FILERUN) 
646e			 
646e 2e 00				ld l, 0 
6470 67					ld h, a 
6471 11 62 f8				ld de, store_page 
6474			 
6474					if DEBUG_FORTH_WORDS 
6474						DMARK "ASp" 
6474 f5				push af  
6475 3a 89 64			ld a, (.dmark)  
6478 32 77 fb			ld (debug_mark),a  
647b 3a 8a 64			ld a, (.dmark+1)  
647e 32 78 fb			ld (debug_mark+1),a  
6481 3a 8b 64			ld a, (.dmark+2)  
6484 32 79 fb			ld (debug_mark+2),a  
6487 18 03			jr .pastdmark  
6489 ..			.dmark: db "ASp"  
648c f1			.pastdmark: pop af  
648d			endm  
# End of macro DMARK
648d						CALLMONITOR 
648d cd 4d 17			call break_point_state  
6490				endm  
# End of macro CALLMONITOR
6490					endif 
6490 cd 51 08				call storage_read 
6493			 
6493					if DEBUG_FORTH_WORDS 
6493						DMARK "ASr" 
6493 f5				push af  
6494 3a a8 64			ld a, (.dmark)  
6497 32 77 fb			ld (debug_mark),a  
649a 3a a9 64			ld a, (.dmark+1)  
649d 32 78 fb			ld (debug_mark+1),a  
64a0 3a aa 64			ld a, (.dmark+2)  
64a3 32 79 fb			ld (debug_mark+2),a  
64a6 18 03			jr .pastdmark  
64a8 ..			.dmark: db "ASr"  
64ab f1			.pastdmark: pop af  
64ac			endm  
# End of macro DMARK
64ac						CALLMONITOR 
64ac cd 4d 17			call break_point_state  
64af				endm  
# End of macro CALLMONITOR
64af					endif 
64af			 
64af cd 32 0d				call ishlzero 
64b2 c8					ret z             ; file not found 
64b3			 
64b3 3e 32				ld a, display_row_2 + 10 
64b5 11 65 f8				ld de, store_page+3 
64b8 cd e8 0a				call str_at_display 
64bb				 
64bb			; 
64bb			 
64bb 3e 05			ld a, display_row_1+5 
64bd 11 26 64			ld de, sprompt3 
64c0 cd e8 0a			call str_at_display 
64c3 3e 5f			ld a, display_row_3+15 
64c5 11 43 64			ld de, sprompt4 
64c8 cd e8 0a			call str_at_display 
64cb			 
64cb cd f8 0a			call update_display 
64ce			 
64ce cd b5 68			call cin_wait 
64d1 fe 6e			cp 'n' 
64d3 c8				ret z 
64d4 fe 4e			cp 'N' 
64d6 c8				ret z 
64d7			 
64d7 cd 55 0a			call delay1s 
64da			 
64da 3a 64 f8			ld a, (store_page+2) 
64dd 32 58 f8			ld (store_openmaxext), a    ; save count of ext 
64e0 3e 01			ld a, 1  
64e2 32 59 f8			ld (store_openext), a    ; save count of ext 
64e5			 
64e5			.autof:  
64e5 6f				ld l , a 
64e6				 
64e6 3a 62 f8			ld a, (store_page) 
64e9 67				ld h, a	 
64ea 11 62 f8			ld de, store_page 
64ed					if DEBUG_FORTH_WORDS 
64ed						DMARK "ASl" 
64ed f5				push af  
64ee 3a 02 65			ld a, (.dmark)  
64f1 32 77 fb			ld (debug_mark),a  
64f4 3a 03 65			ld a, (.dmark+1)  
64f7 32 78 fb			ld (debug_mark+1),a  
64fa 3a 04 65			ld a, (.dmark+2)  
64fd 32 79 fb			ld (debug_mark+2),a  
6500 18 03			jr .pastdmark  
6502 ..			.dmark: db "ASl"  
6505 f1			.pastdmark: pop af  
6506			endm  
# End of macro DMARK
6506						CALLMONITOR 
6506 cd 4d 17			call break_point_state  
6509				endm  
# End of macro CALLMONITOR
6509					endif 
6509 cd 51 08				call storage_read 
650c cd 32 0d			call ishlzero 
650f c8				ret z 
6510			 
6510					if DEBUG_FORTH_WORDS 
6510						DMARK "ASc" 
6510 f5				push af  
6511 3a 25 65			ld a, (.dmark)  
6514 32 77 fb			ld (debug_mark),a  
6517 3a 26 65			ld a, (.dmark+1)  
651a 32 78 fb			ld (debug_mark+1),a  
651d 3a 27 65			ld a, (.dmark+2)  
6520 32 79 fb			ld (debug_mark+2),a  
6523 18 03			jr .pastdmark  
6525 ..			.dmark: db "ASc"  
6528 f1			.pastdmark: pop af  
6529			endm  
# End of macro DMARK
6529						CALLMONITOR 
6529 cd 4d 17			call break_point_state  
652c				endm  
# End of macro CALLMONITOR
652c					endif 
652c 11 64 f8			ld de, store_page+2 
652f 3e 78			ld a, display_row_4 
6531 cd e8 0a			call str_at_display 
6534			 
6534 cd f8 0a			call update_display 
6537 cd 49 0a			call delay250ms 
653a			 
653a			 
653a			 
653a 21 64 f8			ld hl, store_page+2 
653d cd 94 20			call forthparse 
6540 cd d4 20			call forthexec 
6543 cd eb 1f			call forthexec_cleanup 
6546			 
6546				 
6546 3a 59 f8			ld a, (store_openext) 
6549 3c				inc a 
654a 32 59 f8			ld (store_openext), a    ; save count of ext 
654d			 
654d 18 96			jr .autof 
654f			 
654f			;.autofdone: 
654f			; 
654f			;		if DEBUG_FORTH_WORDS 
654f			;			DMARK "ASx" 
654f			;			CALLMONITOR 
654f			;		endif 
654f			;;	call clear_display 
654f			;	ret 
654f			 
654f			 
654f			 
654f			endif 
654f			 
654f			 
654f			; eof 
# End of file forth_kernel.asm
654f			;include "nascombasic.asm" 
654f			 
654f			 
654f			; find out where the code ends if loaded into RAM (for SC114) 
654f			;endofcode:  
654f			;	nop 
654f			 
654f			 
654f			; eof 
654f			 
# End of file main.asm
654f			include "firmware_lcd_4x40.asm" 
654f			; **********************************************************************  
654f			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
654f			; **********************************************************************  
654f			;  
654f			; **  Written as a Small Computer Monitor App  
654f			; **  www.scc.me.uk  
654f			;  
654f			; History  
654f			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
654f			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
654f			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
654f			;  
654f			; **********************************************************************  
654f			;  
654f			; This program is an example of one of the methods of interfacing an   
654f			; alphanumeric LCD module.   
654f			;  
654f			; In this example the display is connected to either a Z80 PIO or a   
654f			; simple 8-bit output port.   
654f			;  
654f			; This interfacing method uses 4-bit data mode and uses time delays  
654f			; rather than polling the display's ready status. As a result the   
654f			; interface only requires 6 simple output lines:  
654f			;   Output bit 0 = not used  
654f			;   Output bit 1 = not used  
654f			;   Output bit 2 = RS         High = data, Low = instruction  
654f			;   Output bit 3 = E          Active high  
654f			;   Output bit 4 = DB4  
654f			;   Output bit 5 = DB5  
654f			;   Output bit 6 = DB6  
654f			;   Output bit 7 = DB7  
654f			; Display's R/W is connected to 0v so it is always in write mode  
654f			;  
654f			; This set up should work with any system supporting the RC2014 bus  
654f			  
654f			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
654f			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
654f			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
654f			;  
654f			; **********************************************************************  
654f			  
654f			; Additonal for 4x40. E1 and E2 instead of just E   
654f			; TODO swipe vidout signal on port a to activate E2  
654f			  
654f			; **********************************************************************  
654f			; **  Constants  
654f			; **********************************************************************  
654f			; LCD constants required by LCD support module  
654f			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
654f			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
654f			kLCDBitE:   EQU 3              ;Port bit for LCD E signal             
654f			kLCDBitE2:   EQU 0              ;Port bit for LCD E2 signal            VIDOUT  
654f			; TODO Decide which E is being set  
654f			kLCDWidth:  EQU display_cols             ;Width in characters  
654f			  
654f			; **********************************************************************  
654f			; **  Code library usage  
654f			; **********************************************************************  
654f			  
654f			; send character to current cursor position  
654f			; wraps and/or scrolls screen automatically  
654f			  
654f			  
654f			  
654f			lcd_init:  
654f			  
654f			; SCMonAPI functions used  
654f			  
654f			; Alphanumeric LCD functions used  
654f			; no need to specify specific functions for this module  
654f			  
654f 3e cf		            LD   A, 11001111b  
6551 d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
6553 3e 00		            LD   A, 00000000b  
6555 d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
6557			  
6557			; Initialise alphanumeric LCD module  
6557 3e 00				ld a, 0  
6559 32 d7 f8				ld (display_lcde1e2), a  
655c cd dd 65		            CALL fLCD_Init      ;Initialise LCD module  
655f 3e 01				ld a, 1  
6561 32 d7 f8				ld (display_lcde1e2), a  
6564 cd dd 65		            CALL fLCD_Init      ;Initialise LCD module  
6567			  
6567 c9				ret  
6568			  
6568			;  
6568			;;  
6568			; lcd functions  
6568			;  
6568			;  
6568			  
6568			; what is at cursor position   
6568			  
6568			;get_cursor:	ld de, (cursor_row)   ;  row + col  
6568			;		call curptr  
6568			;		ret  
6568			  
6568			  
6568			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
6568			  
6568			curptr:  
6568 c5				push bc  
6569 21 bd fa			ld hl, display_fb0  
656c			cpr:	  
656c				; loop for cursor whole row  
656c 0e 28			ld c, display_cols  
656e 23			cpr1:	inc hl  
656f 0d				dec c  
6570 20 fc			jr nz, cpr1  
6572 05				dec b  
6573 20 f7			jr nz, cpr  
6575			  
6575				; add col	  
6575			  
6575 23			cpr2:	inc hl  
6576 1d				dec e  
6577 20 fc			jr nz, cpr2  
6579			  
6579 c1				pop bc  
657a c9				ret  
657b				  
657b			  
657b			  
657b			  
657b			  
657b			; write the frame buffer given in hl to hardware   
657b 22 d5 f8		write_display: ld (display_write_tmp), hl 	   
657e 3e 00			ld a, kLCD_Line1  
6580 cd 8a 66		            CALL fLCD_Pos       ;Position cursor to location in A  
6583 06 28			ld b, display_cols  
6585 ed 5b d5 f8		ld de, (display_write_tmp)  
6589 cd d5 65			call write_len_string  
658c				  
658c				  
658c 2a d5 f8			ld hl, (display_write_tmp)  
658f 11 28 00			ld de, display_cols  
6592 19				add hl,de  
6593 22 d5 f8			ld (display_write_tmp),hl  
6596			  
6596				  
6596 3e 28			ld a, kLCD_Line2  
6598 cd 8a 66		            CALL fLCD_Pos       ;Position cursor to location in A  
659b 06 28			ld b, display_cols  
659d ed 5b d5 f8		ld de, (display_write_tmp)  
65a1 cd d5 65			call write_len_string  
65a4				  
65a4 2a d5 f8			ld hl, (display_write_tmp)  
65a7 11 28 00			ld de, display_cols  
65aa 19				add hl,de  
65ab 22 d5 f8			ld (display_write_tmp),hl  
65ae			  
65ae				  
65ae 3e 50			ld a, kLCD_Line3  
65b0 cd 8a 66		            CALL fLCD_Pos       ;Position cursor to location in A  
65b3 06 28			ld b, display_cols  
65b5 ed 5b d5 f8		ld de, (display_write_tmp)  
65b9 cd d5 65			call write_len_string  
65bc				  
65bc 2a d5 f8			ld hl, (display_write_tmp)  
65bf 11 28 00			ld de, display_cols  
65c2 19				add hl,de  
65c3 22 d5 f8			ld (display_write_tmp),hl  
65c6			  
65c6				  
65c6 3e 78			ld a, kLCD_Line4  
65c8 cd 8a 66		            CALL fLCD_Pos       ;Position cursor to location in A  
65cb 06 28			ld b, display_cols  
65cd ed 5b d5 f8		ld de, (display_write_tmp)  
65d1 cd d5 65			call write_len_string  
65d4 c9					ret  
65d5				  
65d5				; write out a fixed length string given in b from de  
65d5			  
65d5 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
65d6 cd 42 66		            CALL fLCD_Data      ;Write character to display  
65d9 13				inc de  
65da 10 f9			djnz write_len_string  
65dc c9				ret  
65dd			  
65dd			; Some other things to do  
65dd			;            LD   A, kLCD_Clear ;Display clear  
65dd			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
65dd			;            LD   A, kLCD_Under ;Display on with underscore cursor  
65dd			;            LD   A, kLCD_On     ;Display on with no cursor  
65dd			;            ;LD   A, kLCD_Off   ;Display off  
65dd			;            CALL fLCD_Inst      ;Send instruction to display  
65dd			;  
65dd			;  
65dd			;            halt  
65dd			;  
65dd			;  
65dd			;MsgHello:   DB  "Hello World!",0  
65dd			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
65dd			  
65dd			; Custom characters 5 pixels wide by 8 pixels high  
65dd			; Up to 8 custom characters can be defined  
65dd			;BitMaps:      
65dd			;; Character 0x00 = Battery icon  
65dd			;            DB  01110b  
65dd			;            DB  11011b  
65dd			;            DB  10001b  
65dd			;            DB  10001b  
65dd			;            DB  11111b  
65dd			;            DB  11111b  
65dd			;            DB  11111b  
65dd			;            DB  11111b  
65dd			;; Character 0x01 = Bluetooth icon  
65dd			;            DB  01100b  
65dd			;            DB  01010b  
65dd			;            DB  11100b  
65dd			;            DB  01000b  
65dd			;            DB  11100b  
65dd			;            DB  01010b  
65dd			;            DB  01100b  
65dd			;            DB  00000b  
65dd			;  
65dd			  
65dd			  
65dd			; **********************************************************************  
65dd			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
65dd			; **********************************************************************  
65dd			;  
65dd			; **  Written as a Small Computer Monitor App   
65dd			; **  Version 0.1 SCC 2018-05-16  
65dd			; **  www.scc.me.uk  
65dd			;  
65dd			; **********************************************************************  
65dd			;  
65dd			; This module provides support for alphanumeric LCD modules using with  
65dd			; *  HD44780 (or compatible) controller  
65dd			; *  5 x 7 pixel fonts  
65dd			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
65dd			; *  Interface via six digital outputs to the display (see below)  
65dd			;  
65dd			; LCD module pinout:  
65dd			;   1  Vss   0v supply  
65dd			;   2  Vdd   5v supply  
65dd			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
65dd			;   4  RS    High = data, Low = instruction  
65dd			;   5  R/W   High = Read, Low = Write  
65dd			;   6  E     Enable signal (active high)  
65dd			;   7  DB0   Data bit 0  
65dd			;   8  DB1   Data bit 1  
65dd			;   9  DB2   Data bit 2  
65dd			;  10  DB3   Data bit 3  
65dd			;  11  DB4   Data bit 4  
65dd			;  12  DB5   Data bit 5  
65dd			;  13  DB6   Data bit 6  
65dd			;  14  DB7   Data bit 7  
65dd			;  15  A     Backlight anode (+)  
65dd			;  16  K     Backlight cathode (-)  
65dd			;  
65dd			; This interfacing method uses 4-bit data mode and uses time delays  
65dd			; rather than polling the display's ready status. As a result the   
65dd			; interface only requires 6 simple output lines:  
65dd			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
65dd			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
65dd			;   LCD DB4 = Microcomputer output port bit 4  
65dd			;   LCD DB5 = Microcomputer output port bit 5  
65dd			;   LCD DB6 = Microcomputer output port bit 6  
65dd			;   LCD DB7 = Microcomputer output port bit 7  
65dd			; Display's R/W is connected to 0v so it is always in write mode  
65dd			; All 6 connections must be on the same port address <kLCDPrt>  
65dd			; This method also allows a decent length of cable from micro to LCD  
65dd			;  
65dd			; **********************************************************************  
65dd			;  
65dd			; To include the code for any given function provided by this module,   
65dd			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
65dd			; the parent source file.  
65dd			; For example:  #REQUIRES   uHexPrefix  
65dd			;  
65dd			; Also #INCLUDE this file at some point after the #REQUIRES statements  
65dd			; in the parent source file.  
65dd			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
65dd			;  
65dd			; These are the function names provided by this module:  
65dd			; fLCD_Init                     ;Initialise LCD  
65dd			; fLCD_Inst                     ;Send instruction to LCD  
65dd			; fLCD_Data                     ;Send data byte to LCD  
65dd			; fLCD_Pos                      ;Position cursor  
65dd			; fLCD_Str                      ;Display string  
65dd			; fLCD_Def                      ;Define custom character  
65dd			;  
65dd			; **********************************************************************  
65dd			;  
65dd			; Requires SCMonAPI.asm to also be included in the project  
65dd			;  
65dd			  
65dd			  
65dd			; **********************************************************************  
65dd			; **  Constants  
65dd			; **********************************************************************  
65dd			  
65dd			; Constants that must be defined externally  
65dd			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
65dd			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
65dd			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
65dd			;kLCDWidth: EQU 20             ;Width in characters  
65dd			  
65dd			; general line offsets in any frame buffer  
65dd			  
65dd			  
65dd			display_row_1: equ 0  
65dd			display_row_2: equ display_row_1+display_cols  
65dd			display_row_3: equ display_row_2 + display_cols  
65dd			display_row_4: equ display_row_3 + display_cols  
65dd			;display_row_4_eol:   
65dd			  
65dd			  
65dd			; Cursor position values for the start of each line  
65dd			  
65dd			; E  
65dd			kLCD_Line1: EQU 0x00   
65dd			kLCD_Line2: EQU kLCD_Line1+kLCDWidth  
65dd			; E1  
65dd			kLCD_Line3: EQU kLCD_Line2+kLCDWidth  
65dd			kLCD_Line4: EQU kLCD_Line3+kLCDWidth   
65dd			  
65dd			; Instructions to send as A register to fLCD_Inst  
65dd			kLCD_Clear: EQU 00000001b     ;LCD clear  
65dd			kLCD_Off:   EQU 00001000b     ;LCD off  
65dd			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
65dd			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
65dd			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
65dd			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
65dd			  
65dd			; Constants used by this code module  
65dd			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
65dd			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
65dd			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
65dd			  
65dd			  
65dd			  
65dd			; **********************************************************************  
65dd			; **  LCD support functions  
65dd			; **********************************************************************  
65dd			  
65dd			; Initialise alphanumeric LCD module  
65dd			; LCD control register codes:  
65dd			;   DL   0 = 4-bit mode        1 = 8-bit mode  
65dd			;   N    0 = 1-line mode       1 = 2-line mode  
65dd			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
65dd			;   D    0 = Display off       1 = Display on  
65dd			;   C    0 = Cursor off        1 = Cursor on  
65dd			;   B    0 = Blinking off      1 = Blinking on  
65dd			;   ID   0 = Decrement mode    1 = Increment mode  
65dd			;   SH   0 = Entire shift off  1 = Entire shift on  
65dd 3e 28		fLCD_Init:  LD   A, 40  
65df cd 04 67		            CALL LCDDelay       ;Delay 40ms after power up  
65e2			; For reliable reset set 8-bit mode - 3 times  
65e2 cd d4 66		            CALL WrFn8bit       ;Function = 8-bit mode  
65e5 cd d4 66		            CALL WrFn8bit       ;Function = 8-bit mode  
65e8 cd d4 66		            CALL WrFn8bit       ;Function = 8-bit mode  
65eb			; Set 4-bit mode  
65eb cd d0 66		            CALL WrFn4bit       ;Function = 4-bit mode  
65ee cd 02 67		            CALL LCDDelay1      ;Delay 37 us or more  
65f1			; Function set  
65f1 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
65f3 cd 06 66		            CALL fLCD_Inst      ;2 line, display on  
65f6			; Display On/Off control  
65f6 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
65f8 cd 06 66		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
65fb			; Display Clear  
65fb 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
65fd cd 06 66		            CALL fLCD_Inst      ;Clear display  
6600			; Entry mode  
6600 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
6602 cd 06 66		            CALL fLCD_Inst      ;Increment mode, shift off  
6605			; Display module now initialised  
6605 c9			            RET  
6606			; ok to here  
6606			  
6606			; Write instruction to LCD  
6606			;   On entry: A = Instruction byte to be written  
6606			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6606 f5			fLCD_Inst:  PUSH AF  
6607 f5			            PUSH AF  
6608 cd 1a 66		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
660b f1			            POP  AF  
660c 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
660d 17			            RLA  
660e 17			            RLA  
660f 17			            RLA  
6610 cd 1a 66		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
6613 3e 02		            LD   A, 2  
6615 cd 04 67		            CALL LCDDelay       ;Delay 2 ms to complete   
6618 f1			            POP  AF  
6619 c9			            RET  
661a			Wr4bits:   
661a f5					push af  
661b 3a d7 f8				ld a, (display_lcde1e2)  
661e fe 00				cp 0     ; e  
6620 20 10				jr nz, .wea2	  
6622 f1					pop af  
6623 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
6625 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6627 cb df		            SET  kLCDBitE, A	    ; TODO decide which E is being set  
6629 cb 87		            res  kLCDBitE2, A	    ; TODO decide which E is being set  
662b d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
662d cb 9f		            RES  kLCDBitE, A        ; TODO decide which E is being set  
662f d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6631 c9			            RET  
6632 f1			.wea2:		pop af  
6633 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
6635 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6637 cb c7		            SET  kLCDBitE2, A	    ; TODO decide which E is being set  
6639 cb 9f		            res  kLCDBitE, A	    ; TODO decide which E is being set  
663b d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
663d cb 87		            RES  kLCDBitE2, A        ; TODO decide which E is being set  
663f d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6641 c9			            RET  
6642			  
6642			  
6642			; Write data to LCD  
6642			;   On entry: A = Data byte to be written  
6642			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6642 f5			fLCD_Data:  PUSH AF  
6643 f5			            PUSH AF  
6644 cd 56 66		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
6647 f1			            POP  AF  
6648 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
6649 17			            RLA  
664a 17			            RLA  
664b 17			            RLA  
664c cd 56 66		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
664f 3e 96		            LD   A, 150  
6651 3d			Wait:      DEC  A              ;Wait a while to allow data   
6652 20 fd		            JR   NZ, Wait      ;  write to complete  
6654 f1			            POP  AF  
6655 c9			            RET  
6656			Wr4bitsa:     
6656 f5					push af  
6657 3a d7 f8				ld a, (display_lcde1e2)  
665a fe 00				cp 0     ; e1  
665c 20 16				jr nz, .we2	  
665e f1					pop af  
665f e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
6661 cb d7		            SET  kLCDBitRS, A  
6663 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
6665 cb df		            SET  kLCDBitE, A      ; TODO Decide which E is being set  
6667 cb 87		            res  kLCDBitE2, A      ; TODO Decide which E is being set  
6669 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
666b cb 9f		            RES  kLCDBitE, A       ; TODO Decide which E is being set  
666d d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
666f cb 97		            RES  kLCDBitRS, A  
6671 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6673 c9			            RET  
6674 f1			.we2:		pop af  
6675 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
6677 cb d7		            SET  kLCDBitRS, A  
6679 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
667b cb c7		            SET  kLCDBitE2, A      ; TODO Decide which E is being set  
667d cb 9f		            res  kLCDBitE, A      ; TODO Decide which E is being set  
667f d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
6681 cb 87		            RES  kLCDBitE2, A       ; TODO Decide which E is being set  
6683 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
6685 cb 97		            RES  kLCDBitRS, A  
6687 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6689 c9			            RET  
668a			  
668a			  
668a			; Position cursor to specified location  
668a			;   On entry: A = Cursor position  
668a			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
668a f5			fLCD_Pos:   PUSH AF  
668b					; at this point set the E1 or E2 flag depending on position  
668b			  
668b c5					push bc  
668c			;		push af  
668c 06 00				ld b, 0  
668e 4f					ld c, a  
668f 3e 4f				ld a, kLCD_Line3-1  
6691 b7			 		or a      ;clear carry flag  
6692 99					sbc a,c    ; TODO may need to sub 80 from a to put in context of current frame    
6693 38 04				jr c, .pe1  
6695			  
6695					; E selection  
6695 cb 80				res 0, b         ; bit 0 unset e  
6697			;		pop af    ; before line 3 so recover orig pos  
6697			;		ld c, a    ; save for poking back  
6697 18 06				jr .peset	          
6699			.pe1:          	; E2 selection  
6699 cb c0				set 0, b         ; bit 0 set e1  
669b 79					ld a, c  
669c de 4f				sbc a, kLCD_Line3-1  
669e 4f					ld c, a	         ; save caculated offset  
669f			;		pop af     ; bin this original value now we have calculated form  
669f			  
669f			.peset:		; set bit  
669f 78					ld a, b  
66a0 32 d7 f8				ld (display_lcde1e2), a 	  
66a3 79					ld a, c  
66a4 c1					pop bc  
66a5			  
66a5 f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
66a7 cd 06 66		            CALL fLCD_Inst      ;Write instruction to LCD  
66aa f1			            POP  AF  
66ab c9			            RET  
66ac			  
66ac			  
66ac			; Output text string to LCD  
66ac			;   On entry: DE = Pointer to null terminated text string  
66ac			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
66ac 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
66ad b7			            OR   A              ;Null terminator?  
66ae c8			            RET  Z              ;Yes, so finished  
66af cd 42 66		            CALL fLCD_Data      ;Write character to display  
66b2 13			            INC  DE             ;Point to next character  
66b3 18 f7		            JR   fLCD_Str       ;Repeat  
66b5 c9					ret  
66b6			  
66b6			; Define custom character  
66b6			;   On entry: A = Character number (0 to 7)  
66b6			;             DE = Pointer to character bitmap data  
66b6			;   On exit:  A = Next character number  
66b6			;             DE = Next location following bitmap  
66b6			;             BC HL IX IY I AF' BC' DE' HL' preserved  
66b6			; Character is   
66b6 c5			fLCD_Def:   PUSH BC  
66b7 f5			            PUSH AF  
66b8 07			            RLCA                ;Calculate location  
66b9 07			            RLCA                ;  for bitmap data  
66ba 07			            RLCA                ;  = 8 x CharacterNumber  
66bb f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
66bd cd 06 66		            CALL fLCD_Inst      ;Write instruction to LCD  
66c0 06 00		            LD   B, 0  
66c2 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
66c3 cd 42 66		            CALL fLCD_Data      ;Write byte to display  
66c6 13			            INC  DE             ;Point to next byte  
66c7 04			            INC  B              ;Count bytes  
66c8 cb 58		            BIT  3, B           ;Finish all 8 bytes?  
66ca 28 f6		            JR   Z, Loop       ;No, so repeat  
66cc f1			            POP  AF  
66cd 3c			            INC  A              ;Increment character number  
66ce c1			            POP  BC  
66cf c9			            RET  
66d0			  
66d0			  
66d0			; **********************************************************************  
66d0			; **  Private functions  
66d0			; **********************************************************************  
66d0			  
66d0			; Write function to LCD  
66d0			;   On entry: A = Function byte to be written  
66d0			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
66d0 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
66d2 18 02		            JR   WrFunc  
66d4 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
66d6 f5			WrFunc:     PUSH AF  
66d7 f5					push af  
66d8 3a d7 f8				ld a, (display_lcde1e2)  
66db fe 00				cp 0     ; e1  
66dd 20 0f				jr nz, .wfea2	  
66df f1					pop af  
66e0 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
66e2 cb df		            SET  kLCDBitE, A     ; TODO Decide which E is being set  
66e4 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
66e6 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
66e8 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
66ea d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
66ec 18 0d			jr .wfskip  
66ee f1			.wfea2:		pop af  
66ef d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
66f1 cb c7		            SET  kLCDBitE2, A     ; TODO Decide which E is being set  
66f3 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
66f5 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
66f7 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
66f9 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
66fb 3e 05		.wfskip:            LD  A, 5  
66fd cd 04 67		            CALL LCDDelay       ;Delay 5 ms to complete  
6700 f1			            POP  AF  
6701 c9			            RET  
6702			  
6702			  
6702			; Delay in milliseconds  
6702			;   On entry: A = Number of milliseconds delay  
6702			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6702 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
6704 d5			LCDDelay:   PUSH DE  
6705 5f			            LD   E, A           ;Delay by 'A' ms  
6706 16 00		            LD   D, 0  
6708 cd 3a 0a		            CALL aDelayInMS  
670b d1			            POP  DE  
670c c9			            RET  
670d			  
670d			  
670d			testlcd:  
670d 3e 00			ld a, kLCD_Line1  
670f cd 8a 66			call fLCD_Pos  
6712 06 28			ld b, 40  
6714 11 42 67			ld de, .ttext1  
6717 cd d5 65			call write_len_string  
671a			  
671a 3e 28			ld a, kLCD_Line2  
671c cd 8a 66			call fLCD_Pos  
671f 06 28			ld b, 40  
6721 11 6b 67			ld de, .ttext2  
6724 cd d5 65			call write_len_string  
6727 3e 50			ld a, kLCD_Line3  
6729 cd 8a 66			call fLCD_Pos  
672c 06 28			ld b, 40  
672e 11 94 67			ld de, .ttext3  
6731 cd d5 65			call write_len_string  
6734 3e 78			ld a, kLCD_Line4  
6736 cd 8a 66			call fLCD_Pos  
6739 06 28			ld b, 40  
673b 11 bd 67			ld de, .ttext4  
673e cd d5 65			call write_len_string  
6741			  
6741 76				halt  
6742			  
6742			  
6742 .. 00		.ttext1: db "A234567890123456789012345678901234567890",0  
676b .. 00		.ttext2: db "B234567890123456789012345678901234567890",0  
6794 .. 00		.ttext3: db "C234567890123456789012345678901234567890",0  
67bd .. 00		.ttext4: db "D234567890123456789012345678901234567890",0  
67e6			   
67e6			  
67e6			  
67e6			; eof  
67e6			  
# End of file firmware_lcd_4x40.asm
67e6			;include "firmware_lcd_4x20.asm" 
67e6			include "firmware_key_5x10.asm" 
67e6			; 5 x 10 decade counter scanner  
67e6			  
67e6			  
67e6			; TODO do cursor shape change for shift keys  
67e6			; TODO hard coded positions for the shift keys. Change to work like 4x4 and detect and then hide them  
67e6			  
67e6			  
67e6			; bit mask for each scan column and row for teing the matrix  
67e6			  
67e6			  
67e6			key_init:  
67e6			  
67e6			; SCMonAPI functions used  
67e6			  
67e6			; Alphanumeric LCD functions used  
67e6			; no need to specify specific functions for this module  
67e6			  
67e6			  
67e6 3e cf		            LD   A, 11001111b  
67e8 d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
67ea			;            LD   A, 00000000b  
67ea 3e 1f		            LD   A, 00011111b  
67ec d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
67ee			  
67ee			  
67ee				; TODO Configure cursor shapes  
67ee			  
67ee				; Load cursor shapes   
67ee 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
67f0 11 00 68		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
67f3 06 02		            LD   B, 2           ;Number of characters to define  
67f5 cd b6 66		.DefLoop:   CALL fLCD_Def       ;Define custom character  
67f8 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
67fa			  
67fa 3e 01				ld a, 1  
67fc 32 d0 f8			ld (cursor_shape),a  
67ff c9				ret  
6800			  
6800			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
6800			; Up to 8 custom characters can be defined  
6800			.cursor_shapes:      
6800			;; Character 0x00 = Normal  
6800 1f			            DB  11111b  
6801 1f			            DB  11111b  
6802 1f			            DB  11111b  
6803 1f			            DB  11111b  
6804 1f			            DB  11111b  
6805 1f			            DB  11111b  
6806 1f			            DB  11111b  
6807 1f			            DB  11111b  
6808			;; Character 0x01 = Modifier  
6808 1f			            DB  11111b  
6809 1b			            DB  11011b  
680a 1b			            DB  11011b  
680b 1b			            DB  11011b  
680c 1b			            DB  11011b  
680d 1f			            DB  11111b  
680e 1b			            DB  11011b  
680f 1f			            DB  11111b  
6810			  
6810			  
6810			  
6810			  
6810			; Display custom character 0  
6810			;            LD   A, kLCD_Line1+14  
6810			;            CALL fLCD_Pos       ;Position cursor to location in A  
6810			;            LD   A, 0  
6810			;            CALL fLCD_Data      ;Write character in A at cursor  
6810			  
6810			; Display custom character 1  
6810			;            LD   A, kLCD_Line2+14  
6810			;            CALL fLCD_Pos      ;Position cursor to location in A  
6810			;            LD   A, 1  
6810			;            CALL fLCD_Data     ;Write character in A at cursor  
6810			  
6810			; keyboard scanning   
6810			  
6810			; character in from keyboard  
6810			  
6810			; mapping for the pcb layout  
6810			  
6810			.matrix_to_char:  
6810 .. 08 05 0a 00			db "1357890",KEY_BS,KEY_UP,KEY_DOWN,0  
681b .. 0b 0c 00			db "qweryiop",KEY_LEFT,KEY_RIGHT,0  
6826 7e .. 0d 00			db KEY_SYMBOLSHIFT,"asdfghjk",KEY_CR,0  
6831 7e .. 7e 00			db KEY_SHIFT,"zxcvbnm ",KEY_SHIFT,0  
683c .. 10 11 12 .. 13 00			db "246tu",KEY_F1,KEY_F2,KEY_F3,"l",KEY_F4,0  
6847			.matrix_to_shift:  
6847			  
6847 .. 08 05 0a 00			db "!#%&*()",KEY_BS,KEY_UP,KEY_DOWN,0  
6852 .. 07 06 00			db "QWERYIOP",KEY_PREVWORD,KEY_NEXTWORD,0  
685d 7e .. 0d 00			db KEY_SYMBOLSHIFT,"ASDFGHJK",KEY_CR,0  
6868 7e .. 7e 00			db KEY_SHIFT,"ZXCVBNM|",KEY_SHIFT,0  
6873 .. .. 14 15 16 .. 17 00			db '"',"$^TU",KEY_F5,KEY_F6,KEY_F7,"L",KEY_F8,0  
687e			  
687e			.matrix_to_symbolshift:  
687e			  
687e fc ed .. f7 08 05 0a 00			db 252,237,"5789",247,KEY_BS,KEY_UP,KEY_DOWN,0  
6889 .. b0 0e 0f 00			db "-+/=_?~",176,KEY_HOME,KEY_END,0  
6894 7e .. a5 7c db ff 0d 00			db KEY_SYMBOLSHIFT,"[]{}",165,124,219,255,KEY_CR,0  
689f			;		db KEY_SHIFT,"<>,.:;'\\",KEY_SHIFT,0  
689f 7e .. 5c 7e 00	    	 	db KEY_SHIFT,"<>,.:;'",92, KEY_SHIFT,0  
68aa .. f6 eb 7d 7e 18 19 1a df 1b 00			db "@",246,235,125,126,KEY_F9,KEY_F10,KEY_F11,223,KEY_F12,0  
68b5			  
68b5			  
68b5			  
68b5			; mapping for a simple straight through breadboard layout  
68b5			  
68b5			;.matrix_to_char:  
68b5			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
68b5			;		db KEY_SHIFT,"zxcvbnm ",KEY_SYMBOLSHIFT,0  
68b5			;		db "asdfghjkl",KEY_CR,0  
68b5			;		db "qwertyuiop",0  
68b5			;		 db "1234567890",0  
68b5			;.matrix_to_shift:  
68b5			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_HOME, KEY_END,0  
68b5			;		db KEY_SHIFT,"ZXCVBNM",KEY_BS,KEY_SYMBOLSHIFT,0  
68b5			;		db "ASDFGHJKL",KEY_CR,0  
68b5			;		db "QWERTYUIOP",0  
68b5			;		 db "!",'"',"#$%^&*()",0  
68b5			;.matrix_to_symbolshift:  
68b5			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
68b5			;		db KEY_SHIFT,"<>:;b,.",KEY_BS,KEY_SYMBOLSHIFT,0  
68b5			;		db "_?*fghjk=",KEY_CR,0  
68b5			;		db "-/+*[]{}@#",0  
68b5			;		 db "1234567890",0  
68b5			  
68b5			;.matrix_to_char: db "D#0*C987B654A321"  
68b5			  
68b5			  
68b5				  
68b5			  
68b5			; add cin and cin_wait  
68b5			  
68b5 cd c6 68		cin_wait: 	call cin  
68b8						if DEBUG_KEYCINWAIT  
68b8							push af  
68b8							  
68b8							ld hl,key_repeat_ct  
68b8							ld (hl),a  
68b8							inc hl  
68b8							call hexout  
68b8							ld hl,key_repeat_ct+3  
68b8							ld a,0  
68b8							ld (hl),a  
68b8			  
68b8							    LD   A, kLCD_Line1+11  
68b8							    CALL fLCD_Pos       ;Position cursor to location in A  
68b8							    LD   DE, key_repeat_ct  
68b8							    ;LD   DE, MsgHello  
68b8							    CALL fLCD_Str       ;Display string pointed to by DE  
68b8			  
68b8			  
68b8			  
68b8							pop af  
68b8						endif  
68b8 fe 00			cp 0  
68ba 28 f9			jr z, cin_wait   ; block until key press  
68bc			  
68bc							if DEBUG_KEYCINWAIT  
68bc								push af  
68bc			  
68bc								ld a, 'A'	  
68bc								ld hl,key_repeat_ct  
68bc								ld (hl),a  
68bc								inc hl  
68bc								ld a,0  
68bc								ld (hl),a  
68bc			  
68bc								    LD   A, kLCD_Line2+11  
68bc								    CALL fLCD_Pos       ;Position cursor to location in A  
68bc								    LD   DE, key_repeat_ct  
68bc								    ;LD   DE, MsgHello  
68bc								    CALL fLCD_Str       ;Display string pointed to by DE  
68bc			  
68bc							call delay500ms  
68bc			  
68bc								pop af  
68bc							endif  
68bc f5				push af   ; save key pressed  
68bd			  
68bd			.cin_wait1:	  
68bd							if DEBUG_KEYCINWAIT  
68bd								push af  
68bd			  
68bd								ld a, 'b'	  
68bd								ld hl,key_repeat_ct  
68bd								ld (hl),a  
68bd								inc hl  
68bd								ld a,0  
68bd								ld (hl),a  
68bd			  
68bd								    LD   A, kLCD_Line2+11  
68bd								    CALL fLCD_Pos       ;Position cursor to location in A  
68bd								    LD   DE, key_repeat_ct  
68bd								    ;LD   DE, MsgHello  
68bd								    CALL fLCD_Str       ;Display string pointed to by DE  
68bd			  
68bd			  
68bd							call delay500ms  
68bd			  
68bd								pop af  
68bd							endif  
68bd			  
68bd cd c6 68		call cin  
68c0 fe 00			cp 0  
68c2 20 f9			jr nz, .cin_wait1  	; wait for key release  
68c4			if DEBUG_KEYCINWAIT  
68c4				push af  
68c4			  
68c4				ld a, '3'	  
68c4				ld hl,key_repeat_ct  
68c4				ld (hl),a  
68c4				inc hl  
68c4				ld a,0  
68c4				ld (hl),a  
68c4			  
68c4			            LD   A, kLCD_Line2+11  
68c4			            CALL fLCD_Pos       ;Position cursor to location in A  
68c4			            LD   DE, key_repeat_ct  
68c4			            ;LD   DE, MsgHello  
68c4			            CALL fLCD_Str       ;Display string pointed to by DE  
68c4			  
68c4			  
68c4			call delay500ms  
68c4			  
68c4				pop af  
68c4			endif  
68c4			  
68c4 f1				pop af   ; get key  
68c5 c9				ret  
68c6			  
68c6			  
68c6 cd da 68		cin: 	call .mtoc  
68c9			  
68c9			if DEBUG_KEYCIN  
68c9				push af  
68c9				  
68c9				ld hl,key_repeat_ct  
68c9				ld (hl),a  
68c9				inc hl  
68c9				call hexout  
68c9				ld hl,key_repeat_ct+3  
68c9				ld a,0  
68c9				ld (hl),a  
68c9			  
68c9			            LD   A, kLCD_Line3+15  
68c9			            CALL fLCD_Pos       ;Position cursor to location in A  
68c9			            LD   DE, key_repeat_ct  
68c9			            ;LD   DE, MsgHello  
68c9			            CALL fLCD_Str       ;Display string pointed to by DE  
68c9			  
68c9			  
68c9			call delay500ms  
68c9			  
68c9				pop af  
68c9			endif  
68c9			  
68c9			  
68c9				; no key held  
68c9 fe 00			cp 0  
68cb c8				ret z  
68cc			  
68cc			if DEBUG_KEYCIN  
68cc				push af  
68cc			  
68cc				ld a, '1'	  
68cc				ld hl,key_repeat_ct  
68cc				ld (hl),a  
68cc				inc hl  
68cc				ld a,0  
68cc				ld (hl),a  
68cc			  
68cc			            LD   A, kLCD_Line4+15  
68cc			            CALL fLCD_Pos       ;Position cursor to location in A  
68cc			            LD   DE, key_repeat_ct  
68cc			            ;LD   DE, MsgHello  
68cc			            CALL fLCD_Str       ;Display string pointed to by DE  
68cc			  
68cc			  
68cc			call delay500ms  
68cc			  
68cc				pop af  
68cc			endif  
68cc			  
68cc				; stop key bounce  
68cc			  
68cc 32 88 fb			ld (key_held),a		 ; save it  
68cf 47				ld b, a  
68d0			  
68d0 c5			.cina1:	push bc  
68d1			if DEBUG_KEYCIN  
68d1				push af  
68d1			  
68d1				ld hl,key_repeat_ct  
68d1				inc hl  
68d1				call hexout  
68d1				ld hl,key_repeat_ct+3  
68d1				ld a,0  
68d1				ld (hl),a  
68d1				ld hl,key_repeat_ct  
68d1				ld a, '2'	  
68d1				ld (hl),a  
68d1			  
68d1			            LD   A, kLCD_Line4+15  
68d1			            CALL fLCD_Pos       ;Position cursor to location in A  
68d1			            LD   DE, key_repeat_ct  
68d1			            ;LD   DE, MsgHello  
68d1			            CALL fLCD_Str       ;Display string pointed to by DE  
68d1			  
68d1				pop af  
68d1			endif  
68d1 cd da 68			call .mtoc  
68d4 c1				pop bc  
68d5 b8				cp b  
68d6 28 f8			jr z, .cina1  
68d8 78				ld a,b		  
68d9			if DEBUG_KEYCIN  
68d9				push af  
68d9			  
68d9				ld hl,key_repeat_ct  
68d9				inc hl  
68d9				call hexout  
68d9				ld hl,key_repeat_ct+3  
68d9				ld a,0  
68d9				ld (hl),a  
68d9				ld hl,key_repeat_ct  
68d9				ld a, '3'	  
68d9				ld (hl),a  
68d9			  
68d9			            LD   A, kLCD_Line4+15  
68d9			            CALL fLCD_Pos       ;Position cursor to location in A  
68d9			            LD   DE, key_repeat_ct  
68d9			            ;LD   DE, MsgHello  
68d9			            CALL fLCD_Str       ;Display string pointed to by DE  
68d9			  
68d9				pop af  
68d9			endif  
68d9 c9				ret  
68da			  
68da			; detect keyboard modifier key press and apply new overlay to the face key held  
68da			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
68da			  
68da			;.cin_map_modifier:   
68da			;	ld a, (hl)  
68da			;	and 255  
68da			;	ret NZ		; modifier key not flagged  
68da			;  
68da			;	; get key face  
68da			;  
68da			;	ld b,(key_face_held)  
68da			;  
68da			;	ld b, key_cols * key_rows  
68da			;  
68da			;	push de  
68da			;	pop hl  
68da			;  
68da			;.mmod1: ld a,(hl)   ; get map test  
68da			;	cp b  
68da			;	jr z, .mmod2  
68da			;  
68da			;  
68da			;  
68da			;.mmod2: inc hl    ;   
68da			;  
68da			;	  
68da			;  
68da			;	  
68da			;  
68da			;	ld hl,key_actual_pressed  
68da			;	ld (hl),a,  
68da			;	ret  
68da			  
68da			; map matrix key held to char on face of key  
68da			  
68da			.mtoc:  
68da			  
68da			; test decade counter strobes  
68da			  
68da			;.decadetest1:  
68da			  
68da			; reset counter  
68da			;ld a, 128  
68da			;out (portbdata),a  
68da			  
68da			  
68da			;ld b, 5  
68da			;.dec1:  
68da			;ld a, 0  
68da			;out (portbdata),a  
68da			;call delay1s  
68da			  
68da			;ld a, 32  
68da			;out (portbdata),a  
68da			;call delay1s  
68da			;call delay1s  
68da			;call delay1s  
68da			;  
68da			;ld a, 64+32  
68da			;out (portbdata),a  
68da			;call delay1s  
68da			;;djnz .dec1  
68da			;  
68da			;jp .decadetest1  
68da			  
68da			  
68da			  
68da			  
68da			  
68da			  
68da			  
68da			  
68da			  
68da			  
68da				; scan keyboard matrix and generate raw scan map  
68da cd 6d 69			call matrix  
68dd			  
68dd				; reuse c bit 0 left modifer button - ie shift  
68dd			        ; reuse c bit 1 for right modifer button - ie symbol shift  
68dd				; both can be used with their other mappings and if seen together can do extra mappings (forth keywords????)  
68dd			  
68dd 0e 00			ld c, 0  
68df			  
68df				; TODO set flags for modifer key presses   
68df				; TODO do a search for modifer key...  
68df			  
68df				;ld hl,keyscan_table_row4  
68df 21 e7 fb			ld hl,keyscan_table_row2  
68e2			  
68e2 7e				ld a, (hl)  
68e3 fe 23			cp '#'  
68e5 20 07			jr nz, .nextmodcheck  
68e7 cb c1			set 0, c  
68e9 21 47 68			ld hl, .matrix_to_shift  
68ec 18 21			jr .dokeymap  
68ee				; TODO for now igonre  
68ee			.nextmodcheck:  
68ee 21 dc fb			ld hl,keyscan_table_row3  
68f1			  
68f1 7e				ld a, (hl)  
68f2 fe 23			cp '#'  
68f4 20 07			jr nz, .nextmodcheck2  
68f6 cb c9			set 1, c   
68f8 21 7e 68			ld hl, .matrix_to_symbolshift  
68fb 18 12			jr .dokeymap  
68fd			.nextmodcheck2:  
68fd 21 f0 fb			ld hl,keyscan_table_row2+9    ; right shift  
6900			  
6900 7e				ld a, (hl)  
6901 fe 23			cp '#'  
6903 20 07			jr nz, .donemodcheck  
6905 cb c9			set 1, c   
6907 21 47 68			ld hl, .matrix_to_shift  
690a 18 03			jr .dokeymap  
690c			  
690c				; no modifer found so just map to normal keys  
690c				; get mtoc map matrix to respective keys  
690c			;	ld hl, .matrix_to_char  
690c			;	ld hl, .matrix_to_char  
690c			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
690c			;	ld a, KEY_SHIFT  
690c			;	call findchar  
690c			;  
690c			;	; got offset to key modifer in b  
690c			;  
690c			;	ld hl,keyscan_table_row5  
690c			;  
690c			;	ld a,b  
690c			;	call addatohl  
690c			;	ld a,(hl)  
690c			;  
690c			;	cp '#'  
690c			;	jr nz, .nextmodcheck  
690c			;	set 0, c  
690c			;	ld hl, .matrix_to_char  
690c			;	jr .dokeymap  
690c			;	; TODO for now igonre  
690c			;.nextmodcheck:  
690c			;	ld hl, .matrix_to_symbolshift  
690c			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
690c			;	ld a, KEY_SYMBOLSHIFT  
690c			;	call findchar  
690c			;  
690c			;  
690c			;	; got offset to key modifer in b  
690c			;  
690c			;	ld hl,keyscan_table_row5  
690c			;  
690c			;	ld a,b  
690c			;	call addatohl  
690c			;	ld a,(hl)  
690c			;  
690c			;	cp '#'  
690c			;	jr nz, .donemodcheck  
690c			;	set 1, c   
690c			;	ld hl, .matrix_to_symbolshift  
690c			;	jr .dokeymap  
690c			  
690c			  
690c			  
690c			.donemodcheck:  
690c				; no modifer found so just map to normal keys  
690c				; get mtoc map matrix to respective keys  
690c 21 10 68			ld hl, .matrix_to_char  
690f			  
690f			.dokeymap:  
690f				;ld (key_fa), c   
690f cd 28 69			call .mapkeys  
6912			  
6912			  
6912			if DEBUG_KEY  
6912			  
6912			; Display text on first line  
6912			            LD   A, kLCD_Line1  
6912			            CALL fLCD_Pos       ;Position cursor to location in A  
6912			            LD   DE, keyscan_table_row1  
6912			            ;LD   DE, MsgHello  
6912			            CALL fLCD_Str       ;Display string pointed to by DE  
6912			  
6912			; Display text on second line  
6912			            LD   A, kLCD_Line2  
6912			            CALL fLCD_Pos       ;Position cursor to location in A  
6912			            LD   DE, keyscan_table_row2  
6912			            CALL fLCD_Str       ;Display string pointed to by DE  
6912			            LD   A, kLCD_Line3  
6912			            CALL fLCD_Pos       ;Position cursor to location in A  
6912			            LD   DE, keyscan_table_row3  
6912			            CALL fLCD_Str       ;Display string pointed to by DE  
6912			            LD   A, kLCD_Line4  
6912			            CALL fLCD_Pos       ;Position cursor to location in A  
6912			            LD   DE, keyscan_table_row4  
6912			            CALL fLCD_Str       ;Display string pointed to by DE  
6912			            LD   A, kLCD_Line1+10  
6912			            CALL fLCD_Pos       ;Position cursor to location in A  
6912			            LD   DE, keyscan_table_row5  
6912			            CALL fLCD_Str       ;Display string pointed to by DE  
6912			  
6912				;call delay250ms  
6912			endif  
6912			;	jp testkey  
6912			  
6912			; get first char reported  
6912			  
6912 21 c6 fb			ld hl,keyscan_table_row5  
6915			  
6915				;ld b, 46   ; 30 keys to remap + 8 nulls   
6915 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
6917			.findkey:  
6917 7e				ld a,(hl)  
6918 fe 00			cp 0  
691a 28 04			jr z, .nextkey  
691c fe 7e			cp KEY_MATRIX_NO_PRESS  
691e 20 06			jr nz, .foundkey  
6920			.nextkey:  
6920 23				inc hl  
6921 10 f4			djnz .findkey  
6923 3e 00			ld a,0  
6925 c9				ret  
6926			.foundkey:  
6926 7e				ld a,(hl)  
6927 c9				ret  
6928				  
6928			  
6928			; convert the raw key map given hl for destination key  
6928			.mapkeys:  
6928 11 c6 fb			ld de,keyscan_table_row5  
692b			  
692b 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
692d			.remap:  
692d 1a				ld a,(de)  
692e fe 23			cp '#'  
6930 20 02			jr nz, .remapnext  
6932				;CALLMONITOR  
6932 7e				ld a,(hl)  
6933 12				ld (de),a  
6934			  
6934			  
6934			  
6934			.remapnext:  
6934 23				inc hl  
6935 13				inc de  
6936 10 f5			djnz .remap  
6938				  
6938 c9				ret  
6939			  
6939			  
6939			  
6939			.mtocold2:  
6939			  
6939			;	; flag if key D is held down and remove from reporting  
6939			;	ld bc, .key_map_fd    
6939			;	ld hl, keyscan_table  
6939			;	ld de, key_fd  
6939			;	call .key_shift_hold  
6939			;	cp 255  
6939			;	jr z, .cinmap  
6939			;	; flag if key C is held down and remove from reporting  
6939			;	ld bc, .key_map_fc    
6939			;	ld hl, keyscan_table+key_cols  
6939			;	ld de, key_fc  
6939			;	call .key_shift_hold  
6939			;	cp 255  
6939			;	jr z, .cinmap  
6939			;	; flag if key B is held down and remove from reporting  
6939			;	ld bc, .key_map_fb    
6939			;	ld hl, keyscan_table+(key_cols*2)  
6939			;	ld de, key_fb  
6939			;	call .key_shift_hold  
6939			;	cp 255  
6939			;	jr z, .cinmap  
6939			;	; flag if key A is held down and remove from reporting  
6939			;	ld bc, .key_map_fa    
6939			;	ld hl, keyscan_table+(key_cols*3)  
6939			;	ld de, key_fa  
6939			;	call .key_shift_hold  
6939			;	cp 255  
6939			;	jr z, .cinmap  
6939			  
6939 11 10 68			ld de, .matrix_to_char  
693c			  
693c			  
693c			.cinmap1:   
693c				if DEBUG_KEY  
693c			            LD   A, kLCD_Line4  
693c			            CALL fLCD_Pos       ;Position cursor to location in A  
693c					push de  
693c			            LD   DE, keyscan_table  
693c			            CALL fLCD_Str       ;Display string pointed to by DE  
693c					pop de  
693c				endif  
693c			  
693c				; scan key matrix table for any held key  
693c			  
693c				; de holds either the default matrix or one selected above  
693c			  
693c 21 93 fb			ld hl, keyscan_table  
693f 06 32			ld b,key_cols*key_rows  
6941			  
6941 7e			.cin11:	ld a,(hl)  
6942 fe 23			cp '#'  
6944 28 08			jr z, .cinhit1  
6946 23				inc hl  
6947 13				inc de  
6948 05				dec b  
6949 20 f6			jr nz, .cin11  
694b				; no key found held  
694b 3e 00			ld a,0  
694d c9				ret  
694e d5			.cinhit1: push de  
694f e1				pop hl  
6950 7e				ld a,(hl)  
6951 c9				ret  
6952			  
6952			; flag a control key is held   
6952			; hl is key pin, de is flag indicator  
6952			  
6952			.key_shift_hold1:  
6952 c5				push bc  
6953 3e 01			ld a, 1  
6955 32 d0 f8			ld (cursor_shape),a  
6958 06 00			ld b, 0  
695a 7e				ld a, (hl)  
695b fe 2e			cp '.'  
695d 28 0a			jr z, .key_shift11  
695f 06 ff			ld b, 255  
6961 3e 2b			ld a, '+'    ; hide key from later scans  
6963 77				ld (hl),a  
6964 3e 02			ld a, 2  
6966 32 d0 f8			ld (cursor_shape),a  
6969			.key_shift11:  
6969				; write flag indicator  
6969 78				ld a,b  
696a 12				ld (de),a  
696b			  
696b d1				pop de    ; de now holds the key map ptr  
696c c9				ret  
696d			  
696d				  
696d			  
696d			; scans keyboard matrix and flags key press in memory array	  
696d				  
696d			matrix:  
696d				;call matrix  
696d				; TODO optimise the code....  
696d			  
696d			  
696d			;ld hl, keyscan_table_row1  
696d			;ld de, keyscan_table_row1+1  
696d			;ld bc,46  
696d			;ld a,KEY_MATRIX_NO_PRESS  
696d			;ldir  
696d			  
696d			  
696d			  
696d			; reset counter  
696d 3e 80		ld a, 128  
696f d3 c1		out (portbdata),a  
6971			  
6971 06 0a		ld b, 10  
6973 0e 00		ld c, 0       ; current clock toggle  
6975			  
6975			.colscan:  
6975			  
6975			; set current column  
6975			; disable clock enable and set clock low  
6975			  
6975			;ld a, 0  
6975			;out (portbdata),a  
6975			  
6975			; For each column scan for switches  
6975			  
6975 c5			push bc  
6976 21 89 fb		ld hl, keyscan_scancol  
6979 cd 82 6a		call .rowscan  
697c c1			pop bc  
697d			  
697d			  
697d			; get back current column  
697d			  
697d			; translate the row scan  
697d			  
697d			;   
697d			; row 1  
697d			  
697d 78			ld a,b  
697e			  
697e 21 fc fb		LD   hl, keyscan_table_row1+10  
6981			  
6981 cd 1b 0d		call subafromhl  
6984			;call addatohl  
6984			  
6984 11 89 fb		ld de, keyscan_scancol  
6987			  
6987 1a			ld a,(de)  
6988 77			ld (hl),a  
6989			  
6989			  
6989			  
6989			  
6989			; row 2  
6989			  
6989 78			ld a,b  
698a			  
698a 21 f1 fb		LD   hl, keyscan_table_row2+10  
698d			  
698d			;call addatohl  
698d cd 1b 0d		call subafromhl  
6990			  
6990			  
6990 11 8a fb		ld de, keyscan_scancol+1  
6993			  
6993 1a			ld a,(de)  
6994 77			ld (hl),a  
6995			  
6995			  
6995			; row 3  
6995			  
6995 78			ld a,b  
6996			  
6996 21 e6 fb		LD   hl, keyscan_table_row3+10  
6999			  
6999			;call addatohl  
6999 cd 1b 0d		call subafromhl  
699c			  
699c 11 8b fb		ld de, keyscan_scancol+2  
699f			  
699f 1a			ld a,(de)  
69a0 77			ld (hl),a  
69a1			  
69a1			  
69a1			  
69a1			; row 4  
69a1			  
69a1 78			ld a,b  
69a2			  
69a2 21 db fb		LD   hl, keyscan_table_row4+10  
69a5			  
69a5			;call addatohl  
69a5 cd 1b 0d		call subafromhl  
69a8			  
69a8 11 8c fb		ld de, keyscan_scancol+3  
69ab			  
69ab 1a			ld a,(de)  
69ac 77			ld (hl),a  
69ad			  
69ad			; row 5  
69ad			  
69ad 78			ld a,b  
69ae			  
69ae 21 d0 fb		LD   hl, keyscan_table_row5+10  
69b1			  
69b1			;call addatohl  
69b1 cd 1b 0d		call subafromhl  
69b4			  
69b4 11 8d fb		ld de, keyscan_scancol+4  
69b7			  
69b7 1a			ld a,(de)  
69b8 77			ld (hl),a  
69b9			  
69b9			; handshake next column  
69b9			  
69b9			  
69b9 3e 40		ld a, 64  
69bb d3 c1		out (portbdata),a  
69bd			  
69bd 3e 00		ld a, 0  
69bf d3 c1		out (portbdata),a  
69c1			  
69c1			; toggle clk and move to next column  
69c1			;ld a, 64  
69c1			;cp c  
69c1			;  
69c1			;jr z, .coltoglow  
69c1			;ld c, a  
69c1			;jr .coltog  
69c1			;.coltoglow:  
69c1			;ld c, 0  
69c1			;.coltog:  
69c1			;ld a, c  
69c1			;out (portbdata),a  
69c1			  
69c1 10 b2		djnz .colscan  
69c3			  
69c3 3e 0a		ld a,10  
69c5 21 f2 fb		LD   hl, keyscan_table_row1  
69c8 cd 09 0d		call addatohl  
69cb 3e 00		ld a, 0  
69cd 77			ld (hl), a  
69ce			  
69ce			  
69ce 3e 0a		ld a,10  
69d0 21 e7 fb		LD   hl, keyscan_table_row2  
69d3 cd 09 0d		call addatohl  
69d6 3e 00		ld a, 0  
69d8 77			ld (hl), a  
69d9			  
69d9 3e 0a		ld a,10  
69db 21 dc fb		LD   hl, keyscan_table_row3  
69de cd 09 0d		call addatohl  
69e1 3e 00		ld a, 0  
69e3 77			ld (hl), a  
69e4			  
69e4 3e 0a		ld a,10  
69e6 21 d1 fb		LD   hl, keyscan_table_row4  
69e9 cd 09 0d		call addatohl  
69ec 3e 00		ld a, 0  
69ee 77			ld (hl), a  
69ef			  
69ef 3e 0a		ld a,10  
69f1 21 c6 fb		LD   hl, keyscan_table_row5  
69f4 cd 09 0d		call addatohl  
69f7 3e 00		ld a, 0  
69f9 77			ld (hl), a  
69fa			  
69fa			if DEBUG_KEY_MATRIX  
69fa			  
69fa			; Display text on first line  
69fa			            LD   A, kLCD_Line1  
69fa			            CALL fLCD_Pos       ;Position cursor to location in A  
69fa			            LD   DE, keyscan_table_row1  
69fa			            ;LD   DE, MsgHello  
69fa			            CALL fLCD_Str       ;Display string pointed to by DE  
69fa			  
69fa			; Display text on second line  
69fa			            LD   A, kLCD_Line2  
69fa			            CALL fLCD_Pos       ;Position cursor to location in A  
69fa			            LD   DE, keyscan_table_row2  
69fa			            CALL fLCD_Str       ;Display string pointed to by DE  
69fa			            LD   A, kLCD_Line3  
69fa			            CALL fLCD_Pos       ;Position cursor to location in A  
69fa			            LD   DE, keyscan_table_row3  
69fa			            CALL fLCD_Str       ;Display string pointed to by DE  
69fa			            LD   A, kLCD_Line4  
69fa			            CALL fLCD_Pos       ;Position cursor to location in A  
69fa			            LD   DE, keyscan_table_row4  
69fa			            CALL fLCD_Str       ;Display string pointed to by DE  
69fa			            LD   A, kLCD_Line4+10  
69fa			            CALL fLCD_Pos       ;Position cursor to location in A  
69fa			            LD   DE, keyscan_table_row5  
69fa			            CALL fLCD_Str       ;Display string pointed to by DE  
69fa			  
69fa			;call delay250ms  
69fa				jp matrix  
69fa			endif  
69fa c9			ret  
69fb			  
69fb			; using decade counter....  
69fb			  
69fb			  
69fb			; TODO reset decade counter to start of scan  
69fb			  
69fb			; reset 15  
69fb			; clock 14  
69fb			; ce 13  
69fb			  
69fb			; 1 - q5  
69fb			; 2 - q1  
69fb			; 3 - q0  
69fb			; 4 - q2  
69fb			; 5 - q6  
69fb			; 6 - q7  
69fb			; 7 - q3  
69fb			; 8 - vss  
69fb			; 9 - q8  
69fb			; 10 - q4  
69fb			; 11 - q9  
69fb			; 12 - cout  
69fb			; 16 - vdd  
69fb			  
69fb			; clock      ce       reset     output  
69fb			; 0          x        0         n  
69fb			; x          1        0         n  
69fb			; x          x        1         q0  
69fb			; rising     0        0         n+1  
69fb			; falling    x        0         n  
69fb			; x          rising   0         n  
69fb			; 1          falling  0         x+1  
69fb			;  
69fb			; x = dont care, if n < 5 carry = 1 otherwise 0  
69fb			  
69fb			;   
69fb			; reset   
69fb			; 13=0, 14=0, 15=1 .. 15=0  
69fb			;  
69fb			; handshake line  
69fb			; 14=1.... read line 14=0  
69fb			  
69fb			  
69fb			  
69fb			  
69fb			  
69fb			; TODO hand shake clock for next column scan  
69fb			; TODO detect each row  
69fb			  
69fb			  
69fb			  
69fb			  
69fb			; reset 128  
69fb			; clock 64  
69fb			; ce 32  
69fb			  
69fb			  
69fb			.cyclestart:  
69fb			  
69fb			; reset counter  
69fb 3e 80		ld a, 128  
69fd d3 c1		out (portbdata),a  
69ff			  
69ff			; loop leds  
69ff 06 0a		ld b,10  
6a01			  
6a01			.cycle1:  
6a01 c5			push bc  
6a02 3e 00		ld a, 0  
6a04 d3 c1		out (portbdata),a  
6a06 cd 49 0a		call delay250ms  
6a09			  
6a09 3e 40		ld a, 64  
6a0b d3 c1		out (portbdata),a  
6a0d cd 49 0a		call delay250ms  
6a10			  
6a10 3e 00		ld a, 0  
6a12 d3 c1		out (portbdata),a  
6a14 cd 49 0a		call delay250ms  
6a17			  
6a17 c1			pop bc  
6a18 10 e7		djnz .cycle1  
6a1a			  
6a1a			  
6a1a 18 df		jr .cyclestart  
6a1c			  
6a1c			  
6a1c			  
6a1c			  
6a1c			  
6a1c			  
6a1c			  
6a1c			  
6a1c			  
6a1c			; map matrix key held to char on face of key  
6a1c			  
6a1c			;.mtocold:  
6a1c			;  
6a1c			;  
6a1c			;; reset counter  
6a1c			;ld a, 128  
6a1c			;out (portbdata),a  
6a1c			;  
6a1c			;  
6a1c			;; scan keyboard row 1  
6a1c			;ld a, 0  
6a1c			;out (portbdata),a  
6a1c			;;ld a, 64  
6a1c			;;out (portbdata),a  
6a1c			;  
6a1c			;  
6a1c			;	ld a, 128  
6a1c			;	ld hl, keyscan_table  
6a1c			;	call .rowscan  
6a1c			;  
6a1c			;;ld a, 0  
6a1c			;;out (portbdata),a  
6a1c			;ld a, 64  
6a1c			;out (portbdata),a  
6a1c			;  
6a1c			;	ld a, 64  
6a1c			;	ld hl, keyscan_table+key_cols  
6a1c			;	call .rowscan  
6a1c			;  
6a1c			;ld a, 0  
6a1c			;out (portbdata),a  
6a1c			;;ld a, 64  
6a1c			;;out (portbdata),a  
6a1c			;	ld a, 32  
6a1c			;	ld hl, keyscan_table+(key_cols*2)  
6a1c			;	call .rowscan  
6a1c			;  
6a1c			;  
6a1c			;;ld a, 0  
6a1c			;;out (portbdata),a  
6a1c			;ld a, 64  
6a1c			;out (portbdata),a  
6a1c			;  
6a1c			;	ld a, 16  
6a1c			;	ld hl, keyscan_table+(key_cols*3)  
6a1c			;	call .rowscan  
6a1c			;  
6a1c			;  
6a1c			;	; flag if key D is held down and remove from reporting  
6a1c			;	ld bc, .key_map_fd    
6a1c			;	ld hl, keyscan_table  
6a1c			;	ld de, key_fd  
6a1c			;	call .key_shift_hold  
6a1c			;	cp 255  
6a1c			;	jr z, .cinmap  
6a1c			;	; flag if key C is held down and remove from reporting  
6a1c			;	ld bc, .key_map_fc    
6a1c			;	ld hl, keyscan_table+key_cols  
6a1c			;	ld de, key_fc  
6a1c			;	call .key_shift_hold  
6a1c			;	cp 255  
6a1c			;	jr z, .cinmap  
6a1c			;	; flag if key B is held down and remove from reporting  
6a1c			;	ld bc, .key_map_fb    
6a1c			;	ld hl, keyscan_table+(key_cols*2)  
6a1c			;	ld de, key_fb  
6a1c			;	call .key_shift_hold  
6a1c			;	cp 255  
6a1c			;	jr z, .cinmap  
6a1c			;	; flag if key A is held down and remove from reporting  
6a1c			;	ld bc, .key_map_fa    
6a1c			;	ld hl, keyscan_table+(key_cols*3)  
6a1c			;	ld de, key_fa  
6a1c			;	call .key_shift_hold  
6a1c			;	cp 255  
6a1c			;	jr z, .cinmap  
6a1c			;  
6a1c			;	ld de, .matrix_to_char  
6a1c			;  
6a1c			;  
6a1c			;.cinmap:   
6a1c			;	if DEBUG_KEY  
6a1c			;            LD   A, kLCD_Line4  
6a1c			;            CALL fLCD_Pos       ;Position cursor to location in A  
6a1c			;		push de  
6a1c			;            LD   DE, keyscan_table  
6a1c			;            CALL fLCD_Str       ;Display string pointed to by DE  
6a1c			;		pop de  
6a1c			;	endif  
6a1c			  
6a1c				; scan key matrix table for any held key  
6a1c			  
6a1c				; de holds either the default matrix or one selected above  
6a1c			  
6a1c			;	ld hl, keyscan_table  
6a1c			;	ld b,key_cols*key_rows  
6a1c			;  
6a1c			;.cin1:	ld a,(hl)  
6a1c			;	cp '#'  
6a1c			;	jr z, .cinhit  
6a1c			;	inc hl  
6a1c			;	inc de  
6a1c			;	dec b  
6a1c			;	jr nz, .cin1  
6a1c			;	; no key found held  
6a1c			;	ld a,0  
6a1c			;	ret  
6a1c			;.cinhit: push de  
6a1c			;	pop hl  
6a1c			;	ld a,(hl)  
6a1c			;	ret  
6a1c			  
6a1c			; flag a control key is held   
6a1c			; hl is key pin, de is flag indicator  
6a1c			  
6a1c			;.key_shift_hold:  
6a1c			;	push bc  
6a1c			;	ld a, 1  
6a1c			;	ld (cursor_shape),a  
6a1c			;	ld b, 0  
6a1c			;	ld a, (hl)  
6a1c			;	cp '.'  
6a1c			;	jr z, .key_shift1  
6a1c			;	ld b, 255  
6a1c			;	ld a, '+'    ; hide key from later scans  
6a1c			;	ld (hl),a  
6a1c			;	ld a, 2  
6a1c			;	ld (cursor_shape),a  
6a1c			;.key_shift1:  
6a1c			;	; write flag indicator  
6a1c			;	ld a,b  
6a1c			;	ld (de),a  
6a1c			;  
6a1c			;	pop de    ; de now holds the key map ptr  
6a1c			;	ret  
6a1c			  
6a1c				  
6a1c				  
6a1c			  
6a1c			  
6a1c			  
6a1c			  
6a1c			  
6a1c			  
6a1c			  
6a1c			  
6a1c			  
6a1c			  
6a1c			  
6a1c			;	push hl  
6a1c			;	push de  
6a1c			;	push bc  
6a1c			;	call keyscan  
6a1c			;	; map key matrix to ascii value of key face  
6a1c			;  
6a1c			;	ld hl, key_face_map  
6a1c			;	ld de, keyscan_table  
6a1c			;  
6a1c			;	; get how many keys to look at  
6a1c			;	ld b, keyscan_table_len  
6a1c			;	  
6a1c			;  
6a1c			;	; at this stage fall out on first key hit  
6a1c			;	; TODO handle multiple key press  
6a1c			;  
6a1c			;map1:	ld a,(hl)  
6a1c			;	cp '#'  
6a1c			;	jr z, keyhit  
6a1c			;	inc hl  
6a1c			;	inc de  
6a1c			;	dec b  
6a1c			;	jr nz, map1  
6a1c			;nohit:	ld a, 0  
6a1c			;	jr keydone  
6a1c			;keyhit: push de  
6a1c			;	pop hl  
6a1c			;	ld a,(hl)  
6a1c			;keydone:  
6a1c			;	push bc  
6a1c			;	push de  
6a1c			; 	push hl  
6a1c			;	ret   
6a1c			;  
6a1c			  
6a1c			  
6a1c			  
6a1c			  
6a1c			; scan physical key matrix  
6a1c			  
6a1c			  
6a1c			;keyscan:  
6a1c			;  
6a1c			;; for each key_row use keyscanr bit mask for out  
6a1c			;; then read in for keyscanc bitmask  
6a1c			;; save result of row scan to keyscantable  
6a1c			;  
6a1c			;; scan keyboard row 1  
6a1c			;  
6a1c			;	ld b, key_rows  
6a1c			;	ld hl, key_scanr  
6a1c			;	ld de, keyscan_table  
6a1c			;  
6a1c			;rowloop:  
6a1c			;  
6a1c			;	ld a,(hl)		; out bit mask to energise keyboard row  
6a1c			;	call rowscan  
6a1c			;	inc hl  
6a1c			;	dec b  
6a1c			;	jr nz, rowloop  
6a1c			;  
6a1c			;	ret  
6a1c			;  
6a1c			;  
6a1c			;; pass a out bitmask, b row number  
6a1c			;arowscan:   
6a1c			;	push bc  
6a1c			;  
6a1c			;	ld d, b  
6a1c			;  
6a1c			;	; calculate buffer location for this row  
6a1c			;  
6a1c			;	ld hl, keyscan_table	  
6a1c			;kbufr:  ld e, key_cols  
6a1c			;kbufc:	inc hl  
6a1c			;	dec e  
6a1c			;	jr nz, kbufc  
6a1c			;	dec d  
6a1c			;	jr nz, kbufr  
6a1c			;  
6a1c			;	; energise row and read columns  
6a1c			;  
6a1c			;	out (portbdata),a  
6a1c			;	in a,(portbdata)  
6a1c			;	ld c,a  
6a1c			;  
6a1c			;  
6a1c			;	; save buffer loc  
6a1c			;  
6a1c			;	ld (keybufptr), hl  
6a1c			;  
6a1c			;	ld hl, key_scanc  
6a1c			;	ld d, key_cols  
6a1c			;  
6a1c			;	; for each column check each bit mask  
6a1c			;  
6a1c			;colloop:  
6a1c			;	  
6a1c			;  
6a1c			;	; reset flags for the row   
6a1c			;  
6a1c			;	ld b,'.'  
6a1c			;	and (hl)  
6a1c			;	jr z, maskskip  
6a1c			;	ld b,'#'  
6a1c			;maskskip:  
6a1c			;	; save  key state  
6a1c			;	push hl  
6a1c			;	ld hl, (keybufptr)  
6a1c			;	ld (hl), b  
6a1c			;	inc hl  
6a1c			;	ld (keybufptr), hl  
6a1c			;  
6a1c			;	; move to next bit mask  
6a1c			;	pop hl  
6a1c			;	inc hl  
6a1c			;  
6a1c			;	dec d  
6a1c			;	jr nz, colloop  
6a1c			;  
6a1c			;	ret  
6a1c			;  
6a1c			;  
6a1c			;;  
6a1c			; lcd functions  
6a1c			;  
6a1c			;  
6a1c			  
6a1c			;if DEBUG_KEY_MATRIX  
6a1c			  
6a1c			; test function to display hardware view of matrix state  
6a1c			  
6a1c			matrixold:  
6a1c			  
6a1c			  
6a1c			  
6a1c			; reset counter  
6a1c 3e 80		ld a, 128  
6a1e d3 c1		out (portbdata),a  
6a20			; scan keyboard row 1  
6a20 3e 00		ld a, 0  
6a22 d3 c1		out (portbdata),a  
6a24			;ld a, 64  
6a24			;out (portbdata),a  
6a24 3e 80			ld a, 128  
6a26 21 f2 fb			ld hl, keyscan_table_row1  
6a29 cd 82 6a			call .rowscan  
6a2c			  
6a2c			;ld a, 0  
6a2c			;out (portbdata),a  
6a2c 3e 40		ld a, 64  
6a2e d3 c1		out (portbdata),a  
6a30 3e 40			ld a, 64  
6a32 21 e7 fb			ld hl, keyscan_table_row2  
6a35 cd 82 6a			call .rowscan  
6a38			  
6a38 3e 00		ld a, 0  
6a3a d3 c1		out (portbdata),a  
6a3c			;ld a, 64  
6a3c			;out (portbdata),a  
6a3c 3e 20			ld a, 32  
6a3e 21 dc fb			ld hl, keyscan_table_row3  
6a41 cd 82 6a			call .rowscan  
6a44			  
6a44			;ld a, 0  
6a44			;out (portbdata),a  
6a44 3e 40		ld a, 64  
6a46 d3 c1		out (portbdata),a  
6a48 3e 10			ld a, 16  
6a4a 21 d1 fb			ld hl, keyscan_table_row4  
6a4d cd 82 6a			call .rowscan  
6a50			  
6a50			; Display text on first line  
6a50 3e 00		            LD   A, kLCD_Line1  
6a52 cd 8a 66		            CALL fLCD_Pos       ;Position cursor to location in A  
6a55 11 f2 fb		            LD   DE, keyscan_table_row1  
6a58			            ;LD   DE, MsgHello  
6a58 cd ac 66		            CALL fLCD_Str       ;Display string pointed to by DE  
6a5b			  
6a5b			; Display text on second line  
6a5b 3e 28		            LD   A, kLCD_Line2  
6a5d cd 8a 66		            CALL fLCD_Pos       ;Position cursor to location in A  
6a60 11 e7 fb		            LD   DE, keyscan_table_row2  
6a63 cd ac 66		            CALL fLCD_Str       ;Display string pointed to by DE  
6a66 3e 50		            LD   A, kLCD_Line3  
6a68 cd 8a 66		            CALL fLCD_Pos       ;Position cursor to location in A  
6a6b 11 dc fb		            LD   DE, keyscan_table_row3  
6a6e cd ac 66		            CALL fLCD_Str       ;Display string pointed to by DE  
6a71 3e 78		            LD   A, kLCD_Line4  
6a73 cd 8a 66		            CALL fLCD_Pos       ;Position cursor to location in A  
6a76 11 d1 fb		            LD   DE, keyscan_table_row4  
6a79 cd ac 66		            CALL fLCD_Str       ;Display string pointed to by DE  
6a7c			  
6a7c cd 49 0a			call delay250ms  
6a7f c3 6d 69			jp matrix  
6a82			  
6a82			; pass de as row display flags  
6a82			.rowscan:   
6a82			;	out (portbdata),a  
6a82 db c1			in a,(portbdata)  
6a84 4f				ld c,a  
6a85				; reset flags for the row   
6a85 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6a87 e6 01			and 1  
6a89 28 02			jr z, .p1on  
6a8b 06 23			ld b,'#'  
6a8d			.p1on:  
6a8d 70				ld (hl), b  
6a8e 23				inc hl  
6a8f			  
6a8f 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6a91 79				ld a,c  
6a92 e6 02			and 2  
6a94			;	bit 0,a  
6a94 28 02			jr z, .p2on  
6a96 06 23			ld b,'#'  
6a98			.p2on:  
6a98 70				ld (hl), b  
6a99 23				inc hl  
6a9a			;  
6a9a 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6a9c 79				ld a,c  
6a9d e6 04			and 4  
6a9f			;;	bit 0,a  
6a9f 28 02			jr z, .p3on  
6aa1 06 23			ld b,'#'  
6aa3			.p3on:  
6aa3 70				ld (hl), b  
6aa4 23				inc hl  
6aa5			;;  
6aa5 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6aa7			;;	bit 0,a  
6aa7 79				ld a,c  
6aa8 e6 08			and 8  
6aaa 28 02			jr z, .p4on  
6aac 06 23			ld b,'#'  
6aae			.p4on:  
6aae 70				ld (hl), b  
6aaf 23				inc hl  
6ab0			  
6ab0 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6ab2			;;	bit 0,a  
6ab2 79				ld a,c  
6ab3 e6 10			and 16  
6ab5 28 02			jr z, .p5on  
6ab7 06 23			ld b,'#'  
6ab9			.p5on:  
6ab9 70				ld (hl), b  
6aba 23				inc hl  
6abb			; zero term  
6abb 06 00			ld b,0  
6abd 70				ld (hl), b  
6abe			  
6abe c9			.rscandone: ret  
6abf			  
6abf			;addatohl:  
6abf			;  
6abf			 ;add   a, l    ; A = A+L  
6abf			  ;  ld    l, a    ; L = A+L  
6abf			   ; adc   a, h    ; A = A+L+H+carry  
6abf			   ; sub   l       ; A = H+carry  
6abf			   ; ld    h, a    ; H = H+carry  
6abf			  
6abf			;ret  
6abf			; eof  
# End of file firmware_key_5x10.asm
6abf			;include "firmware_key_4x10.asm" 
6abf			 
6abf			heap_size:    equ heap_end - heap_start 
6abf			;eof 
# End of file os_mega.asm
6abf
