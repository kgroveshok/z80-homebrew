# File os_mega_cpm.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 1 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 1 
0000			STARTUP_V2: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; Use this to tune the delay functions if your CPU is a bit quick. i.e. RunCPM on a PC 
0000			 
0000			CPM_DELAY_TUNE: equ 4000 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0100			endif 
0100 c3 be 17			jp coldstart     ; rst 0 - cold boot 
0103			 
0103			 
0103 ..			buildtime: db   "Build: " 
010a					include "romtimestamp.asm" 
010a ..			db '2025-08-09 10:39' 
# End of file romtimestamp.asm
011a 00				   db 0 
011b			 
011b			 
011b			 
011b			;        nop  
011b			;        nop 
011b			;;	org 05h		; null out bdos call 
011b			; 
011b			;        nop  
011b			;        nop  
011b			;        nop 
011b			;;	org 08h 
011b			;;; 
011b			;;	jp cin		; rst 8 - char in 
011b			;;; 
011b			; 
011b			;        nop 
011b			;        nop 
011b			;        nop 
011b			;        nop 
011b			;        nop 
011b			;        nop 
011b			;        nop 
011b			;        nop 
011b			;	org 010h 
011b			;; 
011b			;	jp cout		; rest 010h  - char out 
011b			;; 
011b			;	org 01bh   
011b			; 
011b			;	;jp  		; rst 01bh   - write string to display 
011b			;	jp str_at_display 
011b			; 
011b			; 
011b			;	org 020h 
011b			; 
011b			;	; jp		 ; rst 020h - read char at screen location 
011b			; 
011b			;	org 028h 
011b			 
011b				; jp		 ; rst 028h  - storage i/o 
011b			 
011b			; 	org 030h 
011b			;	jp break_point_state 
011b			  
011b			; $30  
011b			; org 038h 
011b			; $38 
011b			 
011b			; TODO any more important entry points to add to jump table for easier coding use? 
011b			 
011b			if BASE_KEV = 1  
011b			 
011b				; need to be at $66 for nmi support 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255 
011b				jp nmi 
011b			endif 
011b			 
011b			include "firmware.asm" 
011b			  
011b			; main constants (used here and in firmware)  
011b			  
011b			; TODO have page 0 of storage as bios  
011b			  
011b			Device_A: equ 0h  
011b			Device_B: equ 040h          ; Sound  
011b			  
011b			if BASE_KEV  
011b			Device_C: equ 080h          ; Storage and ext cart devices  
011b			endif  
011b			  
011b			if BASE_SC114  
011b			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
011b			endif  
011b			  
011b			if BASE_CPM  
011b			; TODO fixup for CPM  
011b			Device_C: equ 080h          ; Storage and ext cart devices  
011b			endif  
011b			  
011b			Device_D: equ 0c0h             ; Keyboard and LCD  
011b			  
011b			; Odd specific debug points for testing hardware dev  
011b			  
011b			DEBUG_SOUND: equ 0       
011b			DEBUG_STK_FAULT: equ 0  
011b			DEBUG_INPUT: equ 0     ; Debug input entry code  
011b			DEBUG_INPUTV2: equ 1     ; Debug input entry code  
011b			DEBUG_KEYCINWAIT: equ 0  
011b			DEBUG_KEYCIN: equ 0  
011b			DEBUG_KEY: equ 0  
011b			DEBUG_KEY_MATRIX: equ 0  
011b			DEBUG_STORECF: equ 0  
011b			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
011b			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
011b			DEBUG_SPI: equ 0    ; low level spi tests  
011b			  
011b			; Enable many break points  
011b			  
011b			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
011b			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
011b			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
011b			DEBUG_FORTH_JP: equ 0    ; 4  
011b			DEBUG_FORTH_MALLOC: equ 0  
011b			DEBUG_FORTH_MALLOC_INT: equ 0  
011b			DEBUG_FORTH_DOT: equ 1  
011b			DEBUG_FORTH_DOT_WAIT: equ 0  
011b			DEBUG_FORTH_MATHS: equ 0  
011b			DEBUG_FORTH_TOK: equ 0    ; 4  
011b			DEBUG_FORTH_PARSE: equ 0    ; 3  
011b			DEBUG_FORTH: equ 0  ;2  
011b			DEBUG_FORTH_WORDS: equ 1   ; 1  
011b			DEBUG_FORTH_PUSH: equ 1   ; 1  
011b			DEBUG_FORTH_UWORD: equ 1   ; 1  
011b			  
011b			; Enable key point breakpoints  
011b			  
011b			DEBUG_FORTH_DOT_KEY: equ 0  
011b			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
011b			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
011b			  
011b			; Debug stack imbalances  
011b			  
011b			ON: equ 1  
011b			OFF: equ 0  
011b			  
011b			DEBUG_STACK_IMB: equ 0  
011b			STACK_IMB_STORE: equ 20  
011b			  
011b			; House keeping and protections  
011b			  
011b			DEBUG_FORTH_STACK_GUARD: equ 1  
011b			DEBUG_FORTH_MALLOC_GUARD: equ 1  
011b			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
011b			FORTH_ENABLE_FREE: equ 0  
011b			FORTH_ENABLE_MALLOCFREE: equ 1  
011b			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
011b			FORTH_ENABLE_FLOATMATH: equ 0  
011b			  
011b			  
011b			CALLMONITOR: macro  
011b			;	call break_point_state  
011b			; now use the break point debug vector  
011b				call debug_vector  
011b				endm  
011b			  
011b			MALLOC_1: equ 1        ; from dk88   
011b			MALLOC_2: equ 0           ; broke  
011b			MALLOC_3: equ 0           ; really broke  
011b			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
011b			  
011b			if BASE_KEV   
011b			;stacksize: equ 256  
011b			; each stack entry is three bytes (type + word)  
011b			stacksize: equ 3*150  
011b			  
011b			STACK_RET_SIZE: equ 64  
011b			STACK_LOOP_SIZE: equ 128  
011b			STACK_DATA_SIZE: equ 512  
011b			endif  
011b			if BASE_SC114  
011b			;tos:	equ 0f000h  
011b			stacksize: equ 256  
011b			STACK_RET_SIZE: equ 64  
011b			STACK_LOOP_SIZE: equ 128  
011b			STACK_DATA_SIZE: equ 256  
011b			endif  
011b			  
011b			if BASE_CPM  
011b			;tos:	equ 0f000h  
011b			stacksize: equ 256  
011b			STACK_RET_SIZE: equ 64  
011b			STACK_LOOP_SIZE: equ 128  
011b			STACK_DATA_SIZE: equ 256  
011b			endif  
011b			  
011b			;if STORAGE_SE == 0  
011b			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
011b			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
011b			;endif  
011b			  
011b			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
011b			  
011b			STORE_0_AUTORUN: equ $20  
011b			  
011b			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
011b			  
011b			STORE_0_AUTOFILE: equ $21  
011b			STORE_0_BANKRUN: equ $23  
011b			STORE_0_FILERUN: equ $24  
011b			  
011b			; Block 0 offsets for settings  
011b			  
011b			; if set then skip prompt for start up and accept all  
011b			  
011b			STORE_0_QUICKSTART: equ $25  
011b			  
011b			; Blocks where directory table is held  
011b			  
011b			; Reducing the number of entries increases the max file size  
011b			  
011b			;STORE_DIR_START: equ 1  
011b			;STORE_DIR_END: equ 33  
011b			  
011b			; Blocks from where file data is stored  
011b			  
011b			;STORE_DATA_START: equ STORE_DIR_END + 1  
011b			  
011b			; Block indicators (<32 are data files)  
011b			  
011b			;STORE_BLOCK_CFG: equ $8f       ; config block  
011b			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
011b			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
011b			;STORE_BLOCK_FREE: equ $85       ; data block free  
011b			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
011b			  
011b			  
011b			  
011b			; Directory entry flags  
011b			  
011b			;STORE_DIR_FREE: equ 0  
011b			;STORE_DIR_FILE:  equ 1  
011b			  
011b			; Structure offsets to directory entries  
011b			;STORE_DE_FLAG: equ 0  
011b			;STORE_DE_MAXEXT: equ 1  
011b			;STORE_DE_FILENAME: equ 2  
011b			  
011b			; Structure offsets to block 0  
011b			  
011b			;STORE_BK0_ISFOR: equ 1  
011b			;STORE_BK0_LABEL: equ 3  
011b			  
011b			; memory allocation   
011b			  
011b			chk_stund: equ tos+2           ; underflow check word  
011b			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
011b			  
011b			; keyscan table needs rows x cols buffer  
011b			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
011b			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
011b			  
011b			keyscan_table_row1: equ chk_stovr -key_cols-1  
011b			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
011b			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
011b			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
011b			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
011b			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
011b			keyscan_scancol: equ keyscan_table-key_cols  
011b			;keyscan_table_len: equ key_rows*key_cols  
011b			;keybufptr: equ keyscan_table - 2  
011b			;keysymbol: equ keybufptr - 1  
011b			key_held: equ keyscan_scancol-1	; currently held  
011b			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
011b			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
011b			key_fa: equ key_repeat_ct -1 ;  
011b			key_fb: equ key_fa -1 ;  
011b			key_fc: equ key_fb -1 ;  
011b			key_fd: equ key_fc -1 ;  
011b			key_face_held: equ key_fd - 1   
011b			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
011b			  
011b			hardware_config: equ key_face_held - 10  
011b			  
011b			; hardware config switches  
011b			; TODO add bitmasks on includes for hardware  
011b			; high byte for expansion ids  
011b			;     0000 0000  no card inserted  
011b			;     0000 0001  storage card inserted  
011b			;     0000 0010  spi sd card active  
011b			  
011b			;       
011b			; low byte:  
011b			;     0000 0001   4x4 keypad  
011b			;     0000 0010   full keyboard  
011b			;     0000 0011   spi/ext keyboard  
011b			;     0000 0100   20x4 lcd  
011b			;     0000 1000   40x4 lcd  
011b			;     0000 1100   spi/ext display  
011b			;     0001 0000   ide interface available  
011b			  
011b			hardware_word: equ hardware_config - 2  
011b			  
011b			; debug marker - optional display of debug point on the debug screens  
011b			  
011b			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
011b			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
011b			  
011b			debug_mark: equ debug_vector - 4  
011b			  
011b			; input_str vars  
011b			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
011b			input_start:  equ input_ptr - 2    ; ptr to the start of string   
011b			input_size: equ input_start -1  ; number of chars  
011b			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
011b			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
011b			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
011b			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
011b			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
011b			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
011b			input_len: equ input_cur_onoff - 5 ; length of current input  
011b			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
011b			  
011b			; cursor blink rate  
011b			CUR_BLINK_RATE: equ $09  
011b			;CUR_BLINK_RATE: equ 15  
011b			  
011b			key_actual_pressed: equ input_cursor - 1   
011b			key_symbol: equ key_actual_pressed - 1   
011b			key_shift: equ key_symbol - 1   
011b			  
011b			; Display allocation  
011b			  
011b			;display_rows: equ 4     ; move out to mini and mega files  
011b			;display_cols: equ 20  
011b			  
011b			display_fb_len: equ display_rows*display_cols  
011b			  
011b			; primary frame buffer     
011b			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
011b			; working frame buffers  
011b			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
011b			display_fb3: equ  display_fb1-display_fb_len - 1  
011b			display_fb2: equ  display_fb3-display_fb_len - 1  
011b			;  
011b			; pointer to active frame buffer  
011b			display_fb_active: equ display_fb2 - 2  
011b			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
011b			display_write_tmp: equ display_lcde1e2 - 2  
011b			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
011b			  
011b			;  
011b			  
011b			;; can load into de directory  
011b			cursor_col: equ display_active-1  
011b			cursor_row: equ cursor_col-1  
011b			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
011b			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
011b			  
011b			; maths vars  
011b			  
011b			LFSRSeed: equ cursor_shape -20   
011b			randData: equ LFSRSeed - 2  
011b			xrandc: equ randData - 2  
011b			stackstore: equ xrandc - 2  
011b			seed1: equ  stackstore -2   
011b			seed2: equ seed1 - 2  
011b			  
011b			; cf storage vars  
011b			  
011b			iErrorNum:  equ seed2-1         ;Error number  
011b			iErrorReg:  equ iErrorNum -1              ;Error register  
011b			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
011b			  
011b			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
011b			  
011b			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
011b			  
011b			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
011b			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
011b			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
011b			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
011b			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
011b			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
011b			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
011b			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
011b			store_tmpid: equ store_tmp3 - 1		; page temp id  
011b			store_tmpext: equ store_tmpid - 1		; file extent temp  
011b			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
011b			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
011b			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
011b			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
011b			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
011b			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
011b			;  
011b			; spi vars  
011b			  
011b			  
011b			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
011b			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
011b			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
011b			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
011b			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
011b			spi_device_id: equ spi_device - 1    ; human readable bank number  
011b			  
011b			;;;;; forth cli params  
011b			  
011b			; TODO use a different frame buffer for forth???  
011b			  
011b			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
011b			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
011b			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
011b			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
011b			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
011b			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
011b			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
011b			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
011b			  
011b			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
011b			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
011b			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
011b			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
011b			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
011b			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
011b			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
011b			  
011b			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
011b			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011b			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
011b			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011b			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
011b			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
011b			chk_data_ovr: equ cli_data_stack -2; overflow check word  
011b			  
011b			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
011b			  
011b			; os/forth token vars  
011b			  
011b			os_last_cmd: equ os_var_array-255  
011b			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
011b			os_current_i: equ os_cli_cmd-2  
011b			os_cur_ptr: equ os_current_i-2  
011b			os_word_scratch: equ os_cur_ptr-30  
011b			os_tok_len: equ os_word_scratch - 2  
011b			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
011b			os_tok_malloc: equ os_tok_ptr - 2  
011b			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
011b			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
011b			execscratch: equ os_input-255        ; exec cmd eval buffer  
011b			scratch: equ execscratch-255  
011b			  
011b			os_stack_1: equ scratch - 3       ; stack holding area 1  
011b			os_stack_2: equ os_stack_1 - 3       ; stack holding area 2  
011b			os_stack_3: equ os_stack_2 - 3       ; stack holding area 3  
011b			os_stack_4: equ os_stack_3 - 3       ; stack holding area 4  
011b			  
011b			  
011b			; temp locations for new word processing to save on adding more   
011b			  
011b			os_new_malloc: equ os_stack_4-2  
011b			os_new_parse_len: equ os_new_malloc - 2  
011b			os_new_word_len: equ os_new_parse_len - 2  
011b			os_new_work_ptr: equ os_new_word_len - 2  
011b			os_new_src_ptr: equ os_new_work_ptr - 2  
011b			os_new_exec: equ os_new_src_ptr - 2  
011b			os_new_exec_ptr: equ os_new_exec - 2  
011b			  
011b			; resume memory alloocations....  
011b			  
011b			;os_view_disable: equ os_new_exec_ptr - 1  
011b			os_view_af: equ os_new_exec_ptr - 2  
011b			os_view_hl: equ os_view_af -2  
011b			os_view_de: equ os_view_hl - 2  
011b			os_view_bc: equ os_view_de - 2  
011b			  
011b			; stack checksum word  
011b			if DEBUG_STACK_IMB  
011b				curframe: equ  os_view_de - 5  
011b				store_sp: equ curframe - (STACK_IMB_STORE*4)  
011b				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011b			else  
011b				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011b			endif  
011b			  
011b			; with data stack could see memory filled with junk. need some memory management   
011b			; malloc and free entry points added  
011b			  
011b			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
011b			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
011b			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
011b			;heap_end: equ free_list-1  ; Starting address of heap  
011b			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011b			  
011b			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011b			heap_end: equ chk_word-1  ; Starting address of heap  
011b			  
011b			  
011b			;if BASE_KEV   
011b			;heap_start: equ 0800eh  ; Starting address of heap  
011b			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
011b			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
011b			;endif  
011b			  
011b			;if BASE_SC114  
011b			;heap_start: equ baseram+15  ; Starting address of heap  
011b			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
011b			;endif  
011b			  
011b			  
011b			;;;;  
011b			  
011b			  
011b			; change below to point to last memory alloc above  
011b			topusermem:  equ   heap_start  
011b			  
011b			;if BASE_KEV   
011b			;baseusermem: equ 08000h  
011b			;endif  
011b			  
011b			;if BASE_SC114  
011b			;;aseusermem:     equ    12  
011b			;baseusermem:     equ    prompt  
011b			;;baseusermem:     equ    endofcode  
011b			;endif  
011b			  
011b			  
011b			; **********************************************************************  
011b			; **  Constants  
011b			; **********************************************************************  
011b			  
011b			; Constants used by this code module  
011b			kDataReg:   EQU Device_D           ;PIO port A data register  
011b			kContReg:   EQU Device_D+2           ;PIO port A control register  
011b			  
011b			  
011b			portbdata:  equ Device_D+1    ; port b data  
011b			portbctl:   equ Device_D+3    ; port b control  
011b			  
011b			  
011b			;KEY_SHIFT:   equ 5  
011b			;KEY_SYMBOLSHIFT:  equ 6  
011b			  
011b			KEY_SHIFTLOCK: equ 4  
011b			  
011b			  
011b			KEY_UP: equ 5  
011b			KEY_NEXTWORD: equ 6  
011b			KEY_PREVWORD: equ 7  
011b			KEY_BS: equ 8  
011b			KEY_TAB:  equ 9  
011b			KEY_DOWN: equ 10  
011b			KEY_LEFT: equ 11  
011b			KEY_RIGHT: equ 12  
011b			KEY_CR:   equ 13  
011b			KEY_HOME: equ 14  
011b			KEY_END: equ 15  
011b			  
011b			KEY_F1: equ 16  
011b			KEY_F2: equ 17  
011b			KEY_F3: equ 18  
011b			KEY_F4: equ 19  
011b			  
011b			KEY_F5: equ 20  
011b			KEY_F6: equ 21  
011b			KEY_F7: equ 22  
011b			KEY_F8: equ 23  
011b			  
011b			KEY_F9: equ 24  
011b			KEY_F10: equ 25  
011b			KEY_F11: equ 26  
011b			KEY_F12: equ 27  
011b			  
011b			;if DEBUG_KEY  
011b			;	KEY_MATRIX_NO_PRESS: equ '.'  
011b			;	KEY_SHIFT:   equ '.'  
011b			;	KEY_SYMBOLSHIFT:  equ '.'  
011b			;else  
011b				KEY_SHIFT:   equ '~'  
011b				KEY_SYMBOLSHIFT:  equ '~'  
011b				KEY_MATRIX_NO_PRESS: equ '~'  
011b			;endi  
011b			  
011b			  
011b			  
011b			  
011b			; Macro to make adding debug marks easier  
011b			  
011b			DMARK: macro str  
011b				push af  
011b				ld a, (.dmark)  
011b				ld (debug_mark),a  
011b				ld a, (.dmark+1)  
011b				ld (debug_mark+1),a  
011b				ld a, (.dmark+2)  
011b				ld (debug_mark+2),a  
011b				jr .pastdmark  
011b			.dmark: db str  
011b			.pastdmark: pop af  
011b			  
011b			endm  
011b			  
011b			  
011b			; macro to detect for stack imbalances  
011b			  
011b			include "stackimbal.asm"  
011b			; Macro and code to detect stock imbalances 
011b			 
011b			SPPUSH: equ 0 
011b			 
011b			; Add a stack frame which can be checked before return 
011b			 
011b			STACKFRAME: macro onoff frame1 frame2 
011b			 
011b				if DEBUG_STACK_IMB 
011b					if onoff 
011b						; save current SP 
011b						exx 
011b			 
011b						ld de, frame1 
011b						ld a, d 
011b						ld hl, curframe 
011b						call hexout 
011b						ld a, e 
011b						ld hl, curframe+2 
011b						call hexout 
011b			  
011b						ld hl, frame1 
011b						push hl 
011b						ld hl, frame2 
011b						push hl 
011b						exx 
011b					endif 
011b					 
011b				endif 
011b			endm 
011b			 
011b			STACKFRAMECHK: macro onoff frame1 frame2 
011b			 
011b					 
011b				if DEBUG_STACK_IMB 
011b					if onoff 
011b						exx 
011b						; check stack frame SP 
011b			 
011b						ld hl, frame2 
011b						pop de   ; frame2 
011b			 
011b						call cmp16 
011b						jr nz, .spnosame 
011b						 
011b			 
011b						ld hl, frame1 
011b						pop de   ; frame1 
011b			 
011b						call cmp16 
011b						jr z, .spfrsame 
011b			 
011b						.spnosame: call showsperror 
011b			 
011b						.spfrsame: nop 
011b			 
011b						exx 
011b					endif 
011b					 
011b				endif 
011b			 
011b			 
011b			endm 
011b			 
011b			 
011b			; for a sub routine, wrap SP collection and comparisons 
011b			 
011b			; Usage: 
011b			; 
011b			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
011b			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
011b			 
011b			SAVESP: macro onoff storeword 
011b			 
011b				if DEBUG_STACK_IMB 
011b					if onoff 
011b						; save current SP 
011b			 
011b						ld (store_sp+(storeword*4)), sp 
011b			 
011b					endif 
011b					 
011b				endif 
011b			 
011b			endm 
011b			 
011b			CHECKSP: macro onoff storeword 
011b			 
011b				if DEBUG_STACK_IMB 
011b					if onoff 
011b			 
011b						; save SP after last save 
011b				 
011b						ld (store_sp+(storeword*4)+2), sp 
011b			 
011b						push hl 
011b						ld hl, store_sp+(storeword*4) 
011b						call check_stack_sp  
011b						pop hl 
011b			 
011b			 
011b					endif 
011b					 
011b				endif 
011b			 
011b			endm 
011b			 
011b			if DEBUG_STACK_IMB 
011b			 
011b			check_stack_sp: 
011b					push de 
011b			 
011b					ld e, (hl) 
011b					inc hl 
011b					ld d, (hl) 
011b					inc hl 
011b			 
011b					push de 
011b			 
011b			 
011b					ld e, (hl) 
011b					inc hl 
011b					ld d, (hl) 
011b					inc hl 
011b			 
011b					pop hl 
011b			 
011b			 
011b					; check to see if the same 
011b			 
011b					call cmp16 
011b					jr z, .spsame 
011b			 
011b					; not same 
011b			 
011b					call showsperror 
011b			.spsame: 
011b			 
011b					pop de 
011b			 
011b					ret 
011b			 
011b			.sperr:  db "Stack imbalance",0 
011b			 
011b			 
011b			showsperror: 
011b			 
011b			 
011b				push hl 
011b				push af 
011b				push de 
011b				call clear_display 
011b				ld de, .sperr 
011b				ld a,0 
011b			;	ld de,os_word_scratch 
011b				call str_at_display 
011b				ld a, display_row_1+17 
011b				ld de, debug_mark 
011b				call str_at_display 
011b				ld a, 0 
011b				ld (curframe+4),a 
011b				ld hl, curframe 
011b				ld de, os_word_scratch 
011b				ld a, display_row_4 
011b				call str_at_display 
011b				call update_display 
011b				;call break_point_state 
011b				call cin_wait 
011b			 
011b			;	ld a, ' ' 
011b			;	ld (os_view_disable), a 
011b				call bp_on 
011b				pop de	 
011b				pop af 
011b				pop hl 
011b				CALLMONITOR 
011b				ret 
011b			 
011b			endif 
011b			 
011b			 
011b			 
011b			; eof 
# End of file stackimbal.asm
011b			  
011b			;TODO macro to calc col and row offset into screen  
011b			  
011b			  
011b			  
011b			hardware_init:  
011b			  
011b				  
011b			  
011b					;ld a, 0  
011b					;ld (hardware_diag), a  
011b			  
011b					; clear all the buffers  
011b			  
011b 21 10 ed				ld hl, display_fb1  
011e 22 cc eb				ld (display_fb_active), hl  
0121			  
0121 cd b9 0b				call clear_display  
0124			  
0124 21 ce eb				ld hl, display_fb2  
0127 22 cc eb				ld (display_fb_active), hl  
012a			  
012a cd b9 0b				call clear_display  
012d			  
012d					; init primary frame buffer area  
012d 21 b1 ed				ld hl, display_fb0  
0130 22 cc eb				ld (display_fb_active), hl  
0133			  
0133 cd b9 0b				call clear_display  
0136			  
0136			  
0136 cd 90 64				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0139			  
0139 cd 7e 65			call key_init  
013c cd 9e 01			call storage_init  
013f			  
013f				; setup malloc functions  
013f			  
013f				if MALLOC_1  
013f cd ee 11				call  heap_init  
0142				endif  
0142				if MALLOC_4  
0142					call  heap_init  
0142				endif  
0142			  
0142				; init sound hardware if present  
0142			  
0142				if SOUND_ENABLE  
0142					call sound_init  
0142				endif  
0142			  
0142				; lcd test sequence  
0142					  
0142 cd dc 0b			call update_display  
0145 cd f1 0a			call delay1s  
0148 3e 2b			ld a,'+'  
014a cd be 0b			call fill_display  
014d cd dc 0b			call update_display  
0150 cd f1 0a			call delay1s  
0153 3e 2a			ld a,'*'  
0155 cd be 0b			call fill_display  
0158 cd dc 0b			call update_display  
015b cd f1 0a			call delay1s  
015e 3e 2d			ld a,'-'  
0160 cd be 0b			call fill_display  
0163 cd dc 0b			call update_display  
0166 cd f1 0a			call delay1s  
0169			  
0169			; boot splash screen  
0169			if display_cols == 20	  
0169			        ld a, display_row_1    
0169			else  
0169 3e 0a		        ld a, display_row_1 +10   
016b			endif  
016b 11 1c 17			ld de, prom_bootmsg  
016e cd cc 0b			call str_at_display  
0171 cd dc 0b			call update_display  
0174			  
0174			  
0174 cd f1 0a			call delay1s  
0177 cd f1 0a			call delay1s  
017a			if display_cols == 20	  
017a			            LD   A, display_row_3+2  
017a			else  
017a 3e 5c		            LD   A, display_row_3+12  
017c			endif  
017c 11 31 17			ld de, prom_bootmsg1  
017f cd cc 0b			call str_at_display  
0182 cd dc 0b			call update_display  
0185 cd f1 0a			call delay1s  
0188 cd f1 0a			call delay1s  
018b			  
018b			;	ld a, display_row_4+3  
018b			;	ld de, bootmsg2  
018b			;	call str_at_display  
018b			;	call update_display  
018b			;	call delay1s  
018b			;	call delay1s  
018b			  
018b			; debug mark setup  
018b			  
018b 3e 5f		ld a, '_'  
018d 32 6b ee		ld (debug_mark),a  
0190 32 6c ee		ld (debug_mark+1),a  
0193 32 6d ee		ld (debug_mark+2),a  
0196 3e 00		ld a,0  
0198 32 6e ee		ld (debug_mark+3),a  
019b			  
019b c9					ret  
019c			  
019c			  
019c			;bootmsg2:	db "Firmware v0.1",0  
019c			  
019c			; a 4x20 lcd  
019c			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
019c			  
019c			;if display_cols == 20  
019c			;	include "firmware_lcd_4x20.asm"  
019c			;endif  
019c			  
019c			;if display_cols == 40  
019c			;	include "firmware_lcd_4x40.asm"  
019c			;endif  
019c			  
019c			;  
019c			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
019c			; TODO abstract the bit bang video out interface for dual display  
019c			; TODO wire video out to tx pin on rc2014 bus  
019c			  
019c			; must supply cin, and cin_wait for low level hardware abstraction   
019c			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
019c			; test scancode  
019c			  
019c			;;;;;  
019c			;;;  
019c			; Moved out to mini and maxi versions  
019c			;  
019c			; include "firmware_key_4x4.asm"  
019c			; using existing 4 wire x 4 resistor array for input  
019c			;include "firmware_key_4x10.asm"  
019c			; need to mod the board for 5 rows due to resistor array  
019c			;include "firmware_key_5x10.asm"  
019c			  
019c			; storage hardware interface  
019c			  
019c			; use microchip serial eeprom for storage  
019c			  
019c			  
019c			if STORAGE_SE  
019c				include "firmware_spi.asm"  
019c				include "firmware_seeprom.asm"  
019c			else  
019c			   ; create some stubs for the labels  
019c c9			se_readbyte: ret  
019d c9			se_writebyte: ret  
019e c9			storage_init: ret  
019f			  
019f			endif  
019f			  
019f			; use cf card for storage - throwing timeout errors. Hardware or software?????  
019f			;include "firmware_cf.asm"  
019f			  
019f			; load up high level storage hardward abstractions  
019f			include "firmware_storage.asm"  
019f			 
019f			; persisent storage hardware abstraction layer  
019f			 
019f			 
019f			 
019f			; Block 0 on storage is a config state 
019f			 
019f			 
019f			 
019f			; TODO add read phy block and write phy block functions 
019f			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
019f			 
019f			; Abstraction layer  
019f			 
019f			; Logocial block size is same size as physical size - using tape concept 
019f			 
019f			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
019f			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
019f			 
019f			 
019f			 
019f			; Filesystem layout (Logical layout) 
019f			; 
019f			; Block 0 - Bank config  
019f			; 
019f			;      Byte - 0 file id counter 
019f			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
019f			;      Byte - 3-20 zero terminated bank label 
019f			; 
019f			; Block 1 > File storage 
019f			; 
019f			;      Byte 0 file id    - block 0 file details 
019f			;      Byte 1 block id - block 0 is file  
019f			;            Byte 2-15 - File name 
019f			; 
019f			;       - to end of block data 
019f			; 
019f			 
019f			; Get ID for the file named in pointer held HL 
019f			; Returns ID in HL = 255 if no file found 
019f			 
019f			storage_getid: 
019f			 
019f 22 73 ea			ld (store_tmp1), hl 
01a2			 
01a2				if DEBUG_STORESE 
01a2					DMARK "SGI" 
01a2 f5				push af  
01a3 3a b7 01			ld a, (.dmark)  
01a6 32 6b ee			ld (debug_mark),a  
01a9 3a b8 01			ld a, (.dmark+1)  
01ac 32 6c ee			ld (debug_mark+1),a  
01af 3a b9 01			ld a, (.dmark+2)  
01b2 32 6d ee			ld (debug_mark+2),a  
01b5 18 03			jr .pastdmark  
01b7 ..			.dmark: db "SGI"  
01ba f1			.pastdmark: pop af  
01bb			endm  
# End of macro DMARK
01bb					CALLMONITOR 
01bb cd 6f ee			call debug_vector  
01be				endm  
# End of macro CALLMONITOR
01be				endif 
01be				; get block 0 and set counter for number of files to scan 
01be			 
01be cd 29 03			call storage_get_block_0 
01c1			 
01c1 3a 7a ea			ld a, (store_page) 
01c4 47				ld b, a 
01c5			 
01c5				; get extent 0 of each file id 
01c5			 
01c5				if DEBUG_STORESE 
01c5					DMARK "SGc" 
01c5 f5				push af  
01c6 3a da 01			ld a, (.dmark)  
01c9 32 6b ee			ld (debug_mark),a  
01cc 3a db 01			ld a, (.dmark+1)  
01cf 32 6c ee			ld (debug_mark+1),a  
01d2 3a dc 01			ld a, (.dmark+2)  
01d5 32 6d ee			ld (debug_mark+2),a  
01d8 18 03			jr .pastdmark  
01da ..			.dmark: db "SGc"  
01dd f1			.pastdmark: pop af  
01de			endm  
# End of macro DMARK
01de					CALLMONITOR 
01de cd 6f ee			call debug_vector  
01e1				endm  
# End of macro CALLMONITOR
01e1				endif 
01e1 60			.getloop:	ld h, b 
01e2 2e 00				ld l, 0 
01e4 c5					push bc 
01e5			 
01e5 11 7a ea				ld de, store_page 
01e8				if DEBUG_STORESE 
01e8					DMARK "SGr" 
01e8 f5				push af  
01e9 3a fd 01			ld a, (.dmark)  
01ec 32 6b ee			ld (debug_mark),a  
01ef 3a fe 01			ld a, (.dmark+1)  
01f2 32 6c ee			ld (debug_mark+1),a  
01f5 3a ff 01			ld a, (.dmark+2)  
01f8 32 6d ee			ld (debug_mark+2),a  
01fb 18 03			jr .pastdmark  
01fd ..			.dmark: db "SGr"  
0200 f1			.pastdmark: pop af  
0201			endm  
# End of macro DMARK
0201					CALLMONITOR 
0201 cd 6f ee			call debug_vector  
0204				endm  
# End of macro CALLMONITOR
0204				endif 
0204 cd d1 07				call storage_read 
0207 cd 0f 0e				call ishlzero 
020a 28 2d				jr z, .gap 
020c					 
020c					; have a file name read. Is it one we want. 
020c			 
020c 2a 73 ea				ld hl, (store_tmp1) 
020f 11 7d ea				ld de, store_page+3   ; file name 
0212			 
0212				if DEBUG_STORESE 
0212					DMARK "SGc" 
0212 f5				push af  
0213 3a 27 02			ld a, (.dmark)  
0216 32 6b ee			ld (debug_mark),a  
0219 3a 28 02			ld a, (.dmark+1)  
021c 32 6c ee			ld (debug_mark+1),a  
021f 3a 29 02			ld a, (.dmark+2)  
0222 32 6d ee			ld (debug_mark+2),a  
0225 18 03			jr .pastdmark  
0227 ..			.dmark: db "SGc"  
022a f1			.pastdmark: pop af  
022b			endm  
# End of macro DMARK
022b					CALLMONITOR 
022b cd 6f ee			call debug_vector  
022e				endm  
# End of macro CALLMONITOR
022e				endif 
022e cd d5 11				call strcmp 
0231 20 06				jr nz, .gap   ; not this one 
0233			 
0233 c1				        pop bc 
0234			 
0234 26 00				ld h, 0 
0236 68					ld l, b 
0237 18 22				jr .getdone 
0239						 
0239			 
0239			 
0239			 
0239			.gap: 
0239				if DEBUG_STORESE 
0239					DMARK "SGg" 
0239 f5				push af  
023a 3a 4e 02			ld a, (.dmark)  
023d 32 6b ee			ld (debug_mark),a  
0240 3a 4f 02			ld a, (.dmark+1)  
0243 32 6c ee			ld (debug_mark+1),a  
0246 3a 50 02			ld a, (.dmark+2)  
0249 32 6d ee			ld (debug_mark+2),a  
024c 18 03			jr .pastdmark  
024e ..			.dmark: db "SGg"  
0251 f1			.pastdmark: pop af  
0252			endm  
# End of macro DMARK
0252					CALLMONITOR 
0252 cd 6f ee			call debug_vector  
0255				endm  
# End of macro CALLMONITOR
0255				endif 
0255			 
0255 c1					pop bc 
0256 10 89				djnz .getloop 
0258 21 ff 00				ld hl, 255 
025b			.getdone: 
025b			 
025b				if DEBUG_STORESE 
025b					DMARK "SGe" 
025b f5				push af  
025c 3a 70 02			ld a, (.dmark)  
025f 32 6b ee			ld (debug_mark),a  
0262 3a 71 02			ld a, (.dmark+1)  
0265 32 6c ee			ld (debug_mark+1),a  
0268 3a 72 02			ld a, (.dmark+2)  
026b 32 6d ee			ld (debug_mark+2),a  
026e 18 03			jr .pastdmark  
0270 ..			.dmark: db "SGe"  
0273 f1			.pastdmark: pop af  
0274			endm  
# End of macro DMARK
0274					CALLMONITOR 
0274 cd 6f ee			call debug_vector  
0277				endm  
# End of macro CALLMONITOR
0277				endif 
0277			 
0277 c9				ret 
0278			 
0278			 
0278			 
0278			 
0278			 
0278			 
0278			 
0278			 
0278			; Read Block 
0278			; ---------- 
0278			; 
0278			; With current bank 
0278			;  
0278			; Get block number to read 
0278			; Load physical blocks starting at start block into buffer 
0278			 
0278			; de points to buffer to use 
0278			; hl holds logical block number  
0278			 
0278			storage_read_block: 
0278			 
0278				; TODO bank selection 
0278			 
0278				; for each of the physical blocks read it into the buffer 
0278 06 40			ld b, STORE_BLOCK_PHY 
027a			 
027a				if DEBUG_STORESE 
027a d5					push de 
027b				endif 
027b				 
027b			.rl1:    
027b			 
027b				; read physical block at hl into de 
027b			        ; increment hl and de to next read position on exit 
027b			 
027b e5				push hl 
027c d5				push de	 
027d c5				push bc 
027e			;	if DEBUG_STORESE 
027e			;		push af 
027e			;		ld a, 'R' 
027e			;		ld (debug_mark),a 
027e			;		pop af 
027e			;		CALLMONITOR 
027e			;	endif 
027e cd 9c 01			call se_readbyte 
0281			;	if DEBUG_STORESE 
0281			;		ld a,(spi_portbyte) 
0281			;		ld l, a 
0281			;		push af 
0281			;		ld a, '1' 
0281			;		ld (debug_mark),a 
0281			;		pop af 
0281			;		CALLMONITOR 
0281			;	endif 
0281 c1				pop bc 
0282 d1				pop de 
0283 e1				pop hl 
0284 12				ld (de),a 
0285 23				inc hl 
0286 13				inc de 
0287			 
0287			;	if DEBUG_STORESE 
0287			;		push af 
0287			;		ld a, 'r' 
0287			;		ld (debug_mark),a 
0287			;		pop af 
0287			;		CALLMONITOR 
0287			;	endif 
0287			 
0287 10 f2			djnz .rl1 
0289			 
0289				if DEBUG_STORESE 
0289					DMARK "SRB" 
0289 f5				push af  
028a 3a 9e 02			ld a, (.dmark)  
028d 32 6b ee			ld (debug_mark),a  
0290 3a 9f 02			ld a, (.dmark+1)  
0293 32 6c ee			ld (debug_mark+1),a  
0296 3a a0 02			ld a, (.dmark+2)  
0299 32 6d ee			ld (debug_mark+2),a  
029c 18 03			jr .pastdmark  
029e ..			.dmark: db "SRB"  
02a1 f1			.pastdmark: pop af  
02a2			endm  
# End of macro DMARK
02a2 d1					pop de 
02a3			; 
02a3			;		push af 
02a3			;		ld a, 'R' 
02a3			;		ld (debug_mark),a 
02a3			;		pop af 
02a3					CALLMONITOR 
02a3 cd 6f ee			call debug_vector  
02a6				endm  
# End of macro CALLMONITOR
02a6				endif 
02a6 c9				ret	 
02a7				 
02a7			 
02a7			; File Size 
02a7			; --------- 
02a7			; 
02a7			;   hl file id 
02a7			; 
02a7			;  returns in hl the number of blocks 
02a7			 
02a7			storage_file_size: 
02a7 5d				ld e, l 
02a8 16 00			ld d, 0 
02aa 21 40 00			ld hl, STORE_BLOCK_PHY 
02ad					if DEBUG_FORTH_WORDS 
02ad						DMARK "SIZ" 
02ad f5				push af  
02ae 3a c2 02			ld a, (.dmark)  
02b1 32 6b ee			ld (debug_mark),a  
02b4 3a c3 02			ld a, (.dmark+1)  
02b7 32 6c ee			ld (debug_mark+1),a  
02ba 3a c4 02			ld a, (.dmark+2)  
02bd 32 6d ee			ld (debug_mark+2),a  
02c0 18 03			jr .pastdmark  
02c2 ..			.dmark: db "SIZ"  
02c5 f1			.pastdmark: pop af  
02c6			endm  
# End of macro DMARK
02c6						CALLMONITOR 
02c6 cd 6f ee			call debug_vector  
02c9				endm  
# End of macro CALLMONITOR
02c9					endif 
02c9 cd ab 05			call storage_findnextid 
02cc			 
02cc cd 0f 0e			call ishlzero 
02cf			;	ld a, l 
02cf			;	add h 
02cf			;	cp 0 
02cf c8				ret z			; block not found so EOF 
02d0			 
02d0 11 7a ea			ld de, store_page 
02d3 cd 78 02			call storage_read_block 
02d6			 
02d6 3a 7c ea			ld a, (store_page+2)	 ; get extent count 
02d9 6f				ld l, a 
02da 26 00			ld h, 0 
02dc c9			 	ret 
02dd			 
02dd			 
02dd			; Write Block 
02dd			; ----------- 
02dd			; 
02dd			; With current bank 
02dd			;  
02dd			; Get block number to write 
02dd			; Write physical blocks starting at start block from buffer 
02dd			  
02dd			storage_write_block: 
02dd				; TODO bank selection 
02dd			 
02dd				; for each of the physical blocks read it into the buffer 
02dd 06 40			ld b, STORE_BLOCK_PHY 
02df			 
02df				if DEBUG_STORESE 
02df					DMARK "SWB" 
02df f5				push af  
02e0 3a f4 02			ld a, (.dmark)  
02e3 32 6b ee			ld (debug_mark),a  
02e6 3a f5 02			ld a, (.dmark+1)  
02e9 32 6c ee			ld (debug_mark+1),a  
02ec 3a f6 02			ld a, (.dmark+2)  
02ef 32 6d ee			ld (debug_mark+2),a  
02f2 18 03			jr .pastdmark  
02f4 ..			.dmark: db "SWB"  
02f7 f1			.pastdmark: pop af  
02f8			endm  
# End of macro DMARK
02f8			 
02f8					;push af 
02f8					;ld a, 'W' 
02f8					;ld (debug_mark),a 
02f8					;pop af 
02f8					CALLMONITOR 
02f8 cd 6f ee			call debug_vector  
02fb				endm  
# End of macro CALLMONITOR
02fb				endif 
02fb			 
02fb			; might not be working 
02fb			;	call se_writepage 
02fb			 
02fb			;	ret 
02fb			; 
02fb			 
02fb			 
02fb			 
02fb			.wl1:    
02fb			 
02fb				; read physical block at hl into de 
02fb			        ; increment hl and de to next read position on exit 
02fb			 
02fb e5				push hl 
02fc d5				push de	 
02fd c5				push bc 
02fe 1a				ld a,(de) 
02ff				;if DEBUG_STORESE 
02ff			;		push af 
02ff			;		ld a, 'W' 
02ff			;		ld (debug_mark),a 
02ff			;		pop af 
02ff			;		CALLMONITOR 
02ff			;	endif 
02ff cd 9d 01			call se_writebyte 
0302			;	call delay250ms 
0302 00				nop 
0303 00				nop 
0304 00				nop 
0305			;	if DEBUG_STORESE 
0305			;		push af 
0305			;		ld a, 'w' 
0305			;		ld (debug_mark),a 
0305			;		pop af 
0305			;		CALLMONITOR 
0305			;	endif 
0305 c1				pop bc 
0306 d1				pop de 
0307 e1				pop hl 
0308 23				inc hl 
0309 13				inc de 
030a			 
030a			 
030a 10 ef			djnz .wl1 
030c			 
030c				if DEBUG_STORESE 
030c					DMARK "SW2" 
030c f5				push af  
030d 3a 21 03			ld a, (.dmark)  
0310 32 6b ee			ld (debug_mark),a  
0313 3a 22 03			ld a, (.dmark+1)  
0316 32 6c ee			ld (debug_mark+1),a  
0319 3a 23 03			ld a, (.dmark+2)  
031c 32 6d ee			ld (debug_mark+2),a  
031f 18 03			jr .pastdmark  
0321 ..			.dmark: db "SW2"  
0324 f1			.pastdmark: pop af  
0325			endm  
# End of macro DMARK
0325			 
0325					;push af 
0325					;ld a, 'W' 
0325					;ld (debug_mark),a 
0325					;pop af 
0325					CALLMONITOR 
0325 cd 6f ee			call debug_vector  
0328				endm  
# End of macro CALLMONITOR
0328				endif 
0328 c9				ret	 
0329			 
0329			; Init bank 
0329			; --------- 
0329			; 
0329			; With current bank 
0329			; 
0329			; Setup block 0 config 
0329			;     Set 0 file id counter 
0329			;     Set formatted byte pattern 
0329			;     Zero out bank label 
0329			;      
0329			; For every logical block write 0-1 byte as null 
0329			 
0329			storage_get_block_0: 
0329			 
0329				; TODO check presence 
0329			 
0329				; get block 0 config 
0329			 
0329 21 00 00			ld hl, 0 
032c 11 7a ea			ld de, store_page 
032f cd 78 02			call storage_read_block 
0332			 
0332				if DEBUG_STORESE 
0332					DMARK "SB0" 
0332 f5				push af  
0333 3a 47 03			ld a, (.dmark)  
0336 32 6b ee			ld (debug_mark),a  
0339 3a 48 03			ld a, (.dmark+1)  
033c 32 6c ee			ld (debug_mark+1),a  
033f 3a 49 03			ld a, (.dmark+2)  
0342 32 6d ee			ld (debug_mark+2),a  
0345 18 03			jr .pastdmark  
0347 ..			.dmark: db "SB0"  
034a f1			.pastdmark: pop af  
034b			endm  
# End of macro DMARK
034b 11 7a ea				ld de, store_page 
034e			;		push af 
034e			;		ld a, 'i' 
034e			;		ld (debug_mark),a 
034e			;		pop af 
034e					CALLMONITOR 
034e cd 6f ee			call debug_vector  
0351				endm  
# End of macro CALLMONITOR
0351				endif 
0351			 
0351				; is this area formatted? 
0351			 
0351			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0351 2a 7b ea			ld hl, (store_page+1) 
0354 3e 80			ld a,0x80 
0356 bd				cp l 
0357 20 22			jr nz, .ininotformatted 
0359				; do a double check 
0359 3e 27			ld a, 0x27 
035b bc				cp h 
035c 20 1d			jr nz, .ininotformatted 
035e			 
035e				; formatted then 
035e			 
035e				if DEBUG_STORESE 
035e					DMARK "SB1" 
035e f5				push af  
035f 3a 73 03			ld a, (.dmark)  
0362 32 6b ee			ld (debug_mark),a  
0365 3a 74 03			ld a, (.dmark+1)  
0368 32 6c ee			ld (debug_mark+1),a  
036b 3a 75 03			ld a, (.dmark+2)  
036e 32 6d ee			ld (debug_mark+2),a  
0371 18 03			jr .pastdmark  
0373 ..			.dmark: db "SB1"  
0376 f1			.pastdmark: pop af  
0377			endm  
# End of macro DMARK
0377					;push af 
0377					;ld a, 'I' 
0377					;ld (debug_mark),a 
0377					;pop af 
0377					CALLMONITOR 
0377 cd 6f ee			call debug_vector  
037a				endm  
# End of macro CALLMONITOR
037a				endif 
037a c9				ret 
037b			 
037b			.ininotformatted: 
037b				; bank not formatted so poke various bits to make sure 
037b			 
037b				if DEBUG_STORESE 
037b					DMARK "SB2" 
037b f5				push af  
037c 3a 90 03			ld a, (.dmark)  
037f 32 6b ee			ld (debug_mark),a  
0382 3a 91 03			ld a, (.dmark+1)  
0385 32 6c ee			ld (debug_mark+1),a  
0388 3a 92 03			ld a, (.dmark+2)  
038b 32 6d ee			ld (debug_mark+2),a  
038e 18 03			jr .pastdmark  
0390 ..			.dmark: db "SB2"  
0393 f1			.pastdmark: pop af  
0394			endm  
# End of macro DMARK
0394					;push af 
0394					;ld a, 'f' 
0394					;ld (debug_mark),a 
0394					;pop af 
0394					CALLMONITOR 
0394 cd 6f ee			call debug_vector  
0397				endm  
# End of macro CALLMONITOR
0397				endif 
0397			 
0397 cd b4 0a			call storage_clear_page 
039a			 
039a 21 7a ea			ld hl, store_page 
039d 3e 00			ld a, 0 
039f				 
039f 77				ld (hl),a   ; reset file counter 
03a0			 
03a0 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03a3 22 7b ea		 	ld (store_page+1), hl	 
03a6			 
03a6				; set default label 
03a6			 
03a6 21 42 04			ld hl, .defaultbanklabl 
03a9 11 7d ea		 	ld de, store_page+3 
03ac 01 0f 00			ld bc, 15 
03af ed b0			ldir 
03b1			 
03b1				; Append the current bank id 
03b1 21 86 ea			ld hl, store_page+3+9 
03b4 3a 5f ea			ld a, (spi_device_id) 
03b7 77				ld (hl), a 
03b8			 
03b8				; save default page 0 
03b8			 
03b8 21 00 00			ld hl, 0 
03bb 11 7a ea			ld de, store_page 
03be				if DEBUG_STORESE 
03be					DMARK "SB3" 
03be f5				push af  
03bf 3a d3 03			ld a, (.dmark)  
03c2 32 6b ee			ld (debug_mark),a  
03c5 3a d4 03			ld a, (.dmark+1)  
03c8 32 6c ee			ld (debug_mark+1),a  
03cb 3a d5 03			ld a, (.dmark+2)  
03ce 32 6d ee			ld (debug_mark+2),a  
03d1 18 03			jr .pastdmark  
03d3 ..			.dmark: db "SB3"  
03d6 f1			.pastdmark: pop af  
03d7			endm  
# End of macro DMARK
03d7			;		push af 
03d7			;		ld a, 'F' 
03d7			;		ld (debug_mark),a 
03d7			;		pop af 
03d7					CALLMONITOR 
03d7 cd 6f ee			call debug_vector  
03da				endm  
# End of macro CALLMONITOR
03da				endif 
03da cd dd 02			call storage_write_block 
03dd				if DEBUG_STORESE 
03dd					DMARK "SB4" 
03dd f5				push af  
03de 3a f2 03			ld a, (.dmark)  
03e1 32 6b ee			ld (debug_mark),a  
03e4 3a f3 03			ld a, (.dmark+1)  
03e7 32 6c ee			ld (debug_mark+1),a  
03ea 3a f4 03			ld a, (.dmark+2)  
03ed 32 6d ee			ld (debug_mark+2),a  
03f0 18 03			jr .pastdmark  
03f2 ..			.dmark: db "SB4"  
03f5 f1			.pastdmark: pop af  
03f6			endm  
# End of macro DMARK
03f6			;		push af 
03f6			;		ld a, '>' 
03f6			;		ld (debug_mark),a 
03f6			;		pop af 
03f6					CALLMONITOR 
03f6 cd 6f ee			call debug_vector  
03f9				endm  
# End of macro CALLMONITOR
03f9				endif 
03f9			 
03f9 00				nop 
03fa 00				nop 
03fb 00				nop 
03fc			 
03fc				; now set 0 in every page to mark as a free block 
03fc			 
03fc 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
03fe 21 40 00			ld hl, STORE_BLOCK_PHY 
0401			 
0401 3e 00		.setmark1:   	ld a,0 
0403 e5					push hl 
0404 c5					push bc 
0405 cd 9d 01				call se_writebyte 
0408 3e 0a			ld a, 10 
040a cd d6 0a			call aDelayInMS 
040d 23				inc hl 
040e cd 9d 01				call se_writebyte 
0411 3e 0a			ld a, 10 
0413 cd d6 0a			call aDelayInMS 
0416 2b				dec hl 
0417 c1					pop bc 
0418 e1					pop hl 
0419 3e 40				ld a, STORE_BLOCK_PHY 
041b cd e6 0d				call addatohl 
041e 10 e1				djnz .setmark1 
0420			 
0420 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0422 3e 00		.setmark2:   	ld a,0 
0424 e5					push hl 
0425 c5					push bc 
0426 cd 9d 01				call se_writebyte 
0429 3e 0a			ld a, 10 
042b cd d6 0a			call aDelayInMS 
042e 23				inc hl 
042f cd 9d 01				call se_writebyte 
0432 3e 0a			ld a, 10 
0434 cd d6 0a			call aDelayInMS 
0437 2b				dec hl 
0438 c1					pop bc 
0439 e1					pop hl 
043a 3e 40				ld a, STORE_BLOCK_PHY 
043c cd e6 0d				call addatohl 
043f 10 e1				djnz .setmark2 
0441			 
0441					 
0441			 
0441			 
0441 c9				ret 
0442			 
0442			 
0442			 
0442			 
0442 .. 00		.defaultbanklabl:   db "BankLabel_",0 
044d			 
044d			 
044d			 
044d			; Label Bank 
044d			; ---------- 
044d			; 
044d			; With current bank 
044d			; Read block 0 
044d			; Set label 
044d			; Write block 0 
044d			 
044d			; label str pointer in hl 
044d			 
044d			storage_label:     
044d			 
044d				if DEBUG_STORESE 
044d					DMARK "LBL" 
044d f5				push af  
044e 3a 62 04			ld a, (.dmark)  
0451 32 6b ee			ld (debug_mark),a  
0454 3a 63 04			ld a, (.dmark+1)  
0457 32 6c ee			ld (debug_mark+1),a  
045a 3a 64 04			ld a, (.dmark+2)  
045d 32 6d ee			ld (debug_mark+2),a  
0460 18 03			jr .pastdmark  
0462 ..			.dmark: db "LBL"  
0465 f1			.pastdmark: pop af  
0466			endm  
# End of macro DMARK
0466					CALLMONITOR 
0466 cd 6f ee			call debug_vector  
0469				endm  
# End of macro CALLMONITOR
0469				endif 
0469			 
0469 e5				push hl 
046a			 
046a cd 29 03			call storage_get_block_0 
046d			 
046d				; set default label 
046d			 
046d e1				pop hl 
046e			 
046e 11 7d ea		 	ld de, store_page+3 
0471 01 0f 00			ld bc, 15 
0474				if DEBUG_STORESE 
0474					DMARK "LB3" 
0474 f5				push af  
0475 3a 89 04			ld a, (.dmark)  
0478 32 6b ee			ld (debug_mark),a  
047b 3a 8a 04			ld a, (.dmark+1)  
047e 32 6c ee			ld (debug_mark+1),a  
0481 3a 8b 04			ld a, (.dmark+2)  
0484 32 6d ee			ld (debug_mark+2),a  
0487 18 03			jr .pastdmark  
0489 ..			.dmark: db "LB3"  
048c f1			.pastdmark: pop af  
048d			endm  
# End of macro DMARK
048d					CALLMONITOR 
048d cd 6f ee			call debug_vector  
0490				endm  
# End of macro CALLMONITOR
0490				endif 
0490 ed b0			ldir 
0492				; save default page 0 
0492			 
0492 21 00 00			ld hl, 0 
0495 11 7a ea			ld de, store_page 
0498				if DEBUG_STORESE 
0498					DMARK "LBW" 
0498 f5				push af  
0499 3a ad 04			ld a, (.dmark)  
049c 32 6b ee			ld (debug_mark),a  
049f 3a ae 04			ld a, (.dmark+1)  
04a2 32 6c ee			ld (debug_mark+1),a  
04a5 3a af 04			ld a, (.dmark+2)  
04a8 32 6d ee			ld (debug_mark+2),a  
04ab 18 03			jr .pastdmark  
04ad ..			.dmark: db "LBW"  
04b0 f1			.pastdmark: pop af  
04b1			endm  
# End of macro DMARK
04b1					CALLMONITOR 
04b1 cd 6f ee			call debug_vector  
04b4				endm  
# End of macro CALLMONITOR
04b4				endif 
04b4 cd dd 02			call storage_write_block 
04b7			 
04b7 c9				ret 
04b8			 
04b8			 
04b8			 
04b8			; Read Block 0 - Config 
04b8			; --------------------- 
04b8			; 
04b8			; With current bank 
04b8			; Call presence test 
04b8			;    If not present format/init bank  
04b8			; Read block 0  
04b8			;  
04b8			 
04b8			 
04b8			; Dir 
04b8			; --- 
04b8			; 
04b8			; With current bank 
04b8			; Load Block 0 Config 
04b8			; Get max file id number 
04b8			; For each logical block 
04b8			;    Read block read byte 2 
04b8			;      if first block of file 
04b8			;         Display file name 
04b8			;         Display type flags for file 
04b8			;        
04b8			 
04b8			; moving to words as this requires stack control 
04b8			 
04b8			 
04b8			; Delete File 
04b8			; ----------- 
04b8			; 
04b8			; With current bank 
04b8			; 
04b8			; Load Block 0 Config 
04b8			; Get max file id number 
04b8			; For each logical block 
04b8			;    Read block file id 
04b8			;      If first block of file and dont have file id 
04b8			;         if file to delete 
04b8			;         Save file id 
04b8			;         Null file id 
04b8			;         Write this block back 
04b8			;      If file id is one saved 
04b8			;         Null file id 
04b8			;         Write this block back 
04b8			 
04b8			 
04b8			.se_done: 
04b8 e1				pop hl 
04b9 c9				ret 
04ba			 
04ba			storage_erase: 
04ba			 
04ba				; hl contains the file id 
04ba			 
04ba 5d				ld e, l 
04bb 16 00			ld d, 0 
04bd 21 40 00			ld hl, STORE_BLOCK_PHY 
04c0					if DEBUG_FORTH_WORDS 
04c0						DMARK "ERA" 
04c0 f5				push af  
04c1 3a d5 04			ld a, (.dmark)  
04c4 32 6b ee			ld (debug_mark),a  
04c7 3a d6 04			ld a, (.dmark+1)  
04ca 32 6c ee			ld (debug_mark+1),a  
04cd 3a d7 04			ld a, (.dmark+2)  
04d0 32 6d ee			ld (debug_mark+2),a  
04d3 18 03			jr .pastdmark  
04d5 ..			.dmark: db "ERA"  
04d8 f1			.pastdmark: pop af  
04d9			endm  
# End of macro DMARK
04d9						CALLMONITOR 
04d9 cd 6f ee			call debug_vector  
04dc				endm  
# End of macro CALLMONITOR
04dc					endif 
04dc cd ab 05			call storage_findnextid 
04df cd 0f 0e			call ishlzero 
04e2 c8				ret z 
04e3			 
04e3 e5				push hl 
04e4			 
04e4				; TODO check file not found 
04e4			 
04e4 11 7a ea			ld de, store_page 
04e7 cd 78 02			call storage_read_block 
04ea			 
04ea cd 0f 0e			call ishlzero 
04ed ca b8 04			jp z,.se_done 
04f0			 
04f0					if DEBUG_FORTH_WORDS 
04f0						DMARK "ER1" 
04f0 f5				push af  
04f1 3a 05 05			ld a, (.dmark)  
04f4 32 6b ee			ld (debug_mark),a  
04f7 3a 06 05			ld a, (.dmark+1)  
04fa 32 6c ee			ld (debug_mark+1),a  
04fd 3a 07 05			ld a, (.dmark+2)  
0500 32 6d ee			ld (debug_mark+2),a  
0503 18 03			jr .pastdmark  
0505 ..			.dmark: db "ER1"  
0508 f1			.pastdmark: pop af  
0509			endm  
# End of macro DMARK
0509						CALLMONITOR 
0509 cd 6f ee			call debug_vector  
050c				endm  
# End of macro CALLMONITOR
050c					endif 
050c 3a 7a ea			ld a, (store_page)	; get file id 
050f 32 6e ea			ld (store_tmpid), a 
0512			 
0512 3a 7c ea			ld a, (store_page+2)    ; get count of extends 
0515 32 6d ea			ld (store_tmpext), a 
0518			 
0518				; wipe file header 
0518			 
0518 e1				pop hl 
0519 3e 00			ld a, 0 
051b 32 7a ea			ld (store_page), a 
051e 32 7b ea			ld (store_page+1),a 
0521 11 7a ea			ld de, store_page 
0524					if DEBUG_FORTH_WORDS 
0524						DMARK "ER2" 
0524 f5				push af  
0525 3a 39 05			ld a, (.dmark)  
0528 32 6b ee			ld (debug_mark),a  
052b 3a 3a 05			ld a, (.dmark+1)  
052e 32 6c ee			ld (debug_mark+1),a  
0531 3a 3b 05			ld a, (.dmark+2)  
0534 32 6d ee			ld (debug_mark+2),a  
0537 18 03			jr .pastdmark  
0539 ..			.dmark: db "ER2"  
053c f1			.pastdmark: pop af  
053d			endm  
# End of macro DMARK
053d						CALLMONITOR 
053d cd 6f ee			call debug_vector  
0540				endm  
# End of macro CALLMONITOR
0540					endif 
0540 cd dd 02			call storage_write_block 
0543			 
0543			 
0543				; wipe file extents 
0543			 
0543 3a 6d ea			ld a, (store_tmpext) 
0546 47				ld b, a 
0547			 
0547			.eraext:	  
0547 c5				push bc 
0548			 
0548 21 40 00			ld hl, STORE_BLOCK_PHY 
054b 3a 6e ea			ld a,(store_tmpid) 
054e 5f				ld e, a 
054f 50				ld d, b	 
0550					if DEBUG_FORTH_WORDS 
0550						DMARK "ER3" 
0550 f5				push af  
0551 3a 65 05			ld a, (.dmark)  
0554 32 6b ee			ld (debug_mark),a  
0557 3a 66 05			ld a, (.dmark+1)  
055a 32 6c ee			ld (debug_mark+1),a  
055d 3a 67 05			ld a, (.dmark+2)  
0560 32 6d ee			ld (debug_mark+2),a  
0563 18 03			jr .pastdmark  
0565 ..			.dmark: db "ER3"  
0568 f1			.pastdmark: pop af  
0569			endm  
# End of macro DMARK
0569						CALLMONITOR 
0569 cd 6f ee			call debug_vector  
056c				endm  
# End of macro CALLMONITOR
056c					endif 
056c cd ab 05			call storage_findnextid 
056f cd 0f 0e			call ishlzero 
0572 ca b8 04			jp z,.se_done 
0575			 
0575 e5				push hl 
0576 11 7a ea			ld de, store_page 
0579 cd 78 02			call storage_read_block 
057c			 
057c				; free block	 
057c			 
057c 3e 00			ld a, 0 
057e 32 7a ea			ld (store_page), a 
0581 32 7b ea			ld (store_page+1),a 
0584 11 7a ea			ld de, store_page 
0587 e1				pop hl 
0588					if DEBUG_FORTH_WORDS 
0588						DMARK "ER4" 
0588 f5				push af  
0589 3a 9d 05			ld a, (.dmark)  
058c 32 6b ee			ld (debug_mark),a  
058f 3a 9e 05			ld a, (.dmark+1)  
0592 32 6c ee			ld (debug_mark+1),a  
0595 3a 9f 05			ld a, (.dmark+2)  
0598 32 6d ee			ld (debug_mark+2),a  
059b 18 03			jr .pastdmark  
059d ..			.dmark: db "ER4"  
05a0 f1			.pastdmark: pop af  
05a1			endm  
# End of macro DMARK
05a1						CALLMONITOR 
05a1 cd 6f ee			call debug_vector  
05a4				endm  
# End of macro CALLMONITOR
05a4					endif 
05a4 cd dd 02			call storage_write_block 
05a7			 
05a7 c1				pop bc 
05a8 10 9d			djnz .eraext 
05aa			 
05aa c9				ret 
05ab			 
05ab			 
05ab			; Find Free Block 
05ab			; --------------- 
05ab			; 
05ab			; With current bank 
05ab			;  
05ab			; From given starting logical block 
05ab			;    Read block  
05ab			;    If no file id 
05ab			;         Return block id 
05ab			 
05ab			 
05ab			; hl starting page number 
05ab			; hl contains free page number or zero if no pages free 
05ab			; e contains the file id to locate 
05ab			; d contains the block number 
05ab			 
05ab			; TODO change to find file id and use zero for free block 
05ab			 
05ab			storage_findnextid: 
05ab			 
05ab				; now locate first 0 page to mark as a free block 
05ab			 
05ab 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05ad			;	ld hl, STORE_BLOCK_PHY 
05ad			 
05ad					if DEBUG_FORTH_WORDS 
05ad					DMARK "FNI" 
05ad f5				push af  
05ae 3a c2 05			ld a, (.dmark)  
05b1 32 6b ee			ld (debug_mark),a  
05b4 3a c3 05			ld a, (.dmark+1)  
05b7 32 6c ee			ld (debug_mark+1),a  
05ba 3a c4 05			ld a, (.dmark+2)  
05bd 32 6d ee			ld (debug_mark+2),a  
05c0 18 03			jr .pastdmark  
05c2 ..			.dmark: db "FNI"  
05c5 f1			.pastdmark: pop af  
05c6			endm  
# End of macro DMARK
05c6						CALLMONITOR 
05c6 cd 6f ee			call debug_vector  
05c9				endm  
# End of macro CALLMONITOR
05c9					endif 
05c9			.ff1:   	 
05c9 e5					push hl 
05ca c5					push bc 
05cb d5					push de 
05cc cd 9c 01				call se_readbyte 
05cf 5f					ld e,a 
05d0 23					inc hl 
05d1 cd 9c 01				call se_readbyte 
05d4 57					ld d, a 
05d5 e1					pop hl 
05d6 e5					push hl 
05d7 cd 04 0e				call cmp16 
05da 28 49				jr z, .fffound 
05dc			 
05dc d1					pop de 
05dd c1					pop bc 
05de e1					pop hl 
05df			 
05df					; is found? 
05df					;cp e 
05df					;ret z 
05df			 
05df 3e 40				ld a, STORE_BLOCK_PHY 
05e1 cd e6 0d				call addatohl 
05e4 10 e3				djnz .ff1 
05e6			 
05e6 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05e8			.ff2:   	 
05e8			 
05e8 e5					push hl 
05e9 c5					push bc 
05ea d5					push de 
05eb cd 9c 01				call se_readbyte 
05ee 5f					ld e,a 
05ef 23					inc hl 
05f0 cd 9c 01				call se_readbyte 
05f3 57					ld d, a 
05f4			 
05f4 e1					pop hl 
05f5 e5					push hl 
05f6 cd 04 0e				call cmp16 
05f9 28 2a				jr z, .fffound 
05fb			 
05fb d1					pop de 
05fc c1					pop bc 
05fd e1					pop hl 
05fe					; is found? 
05fe					;cp e 
05fe					;ret z 
05fe			 
05fe 3e 40				ld a, STORE_BLOCK_PHY 
0600 cd e6 0d				call addatohl 
0603 10 e3				djnz .ff2 
0605			 
0605			 
0605					if DEBUG_FORTH_WORDS 
0605					DMARK "FN-" 
0605 f5				push af  
0606 3a 1a 06			ld a, (.dmark)  
0609 32 6b ee			ld (debug_mark),a  
060c 3a 1b 06			ld a, (.dmark+1)  
060f 32 6c ee			ld (debug_mark+1),a  
0612 3a 1c 06			ld a, (.dmark+2)  
0615 32 6d ee			ld (debug_mark+2),a  
0618 18 03			jr .pastdmark  
061a ..			.dmark: db "FN-"  
061d f1			.pastdmark: pop af  
061e			endm  
# End of macro DMARK
061e					;	push af 
061e					;	ld a, 'n' 
061e					;	ld (debug_mark),a 
061e					;	pop af 
061e						CALLMONITOR 
061e cd 6f ee			call debug_vector  
0621				endm  
# End of macro CALLMONITOR
0621					endif 
0621				; no free marks! 
0621 21 00 00				ld hl, 0 
0624 c9				ret 
0625			.fffound: 
0625				 
0625			 
0625 d1					pop de 
0626 c1					pop bc 
0627 e1					pop hl 
0628					if DEBUG_FORTH_WORDS 
0628					DMARK "FNF" 
0628 f5				push af  
0629 3a 3d 06			ld a, (.dmark)  
062c 32 6b ee			ld (debug_mark),a  
062f 3a 3e 06			ld a, (.dmark+1)  
0632 32 6c ee			ld (debug_mark+1),a  
0635 3a 3f 06			ld a, (.dmark+2)  
0638 32 6d ee			ld (debug_mark+2),a  
063b 18 03			jr .pastdmark  
063d ..			.dmark: db "FNF"  
0640 f1			.pastdmark: pop af  
0641			endm  
# End of macro DMARK
0641					;	push af 
0641					;	ld a, 'n' 
0641					;	ld (debug_mark),a 
0641					;	pop af 
0641						CALLMONITOR 
0641 cd 6f ee			call debug_vector  
0644				endm  
# End of macro CALLMONITOR
0644					endif 
0644 c9				ret 
0645			 
0645			 
0645			 
0645			; Free Space 
0645			; ---------- 
0645			; 
0645			; With current bank 
0645			; 
0645			; Set block count to zero 
0645			; Starting with first logical block 
0645			;      Find free block  
0645			;      If block id given, increment block count 
0645			; 
0645			;  
0645			 
0645			 
0645			; hl contains count of free blocks 
0645			 
0645			storage_freeblocks: 
0645			 
0645				; now locate first 0 page to mark as a free block 
0645			 
0645 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0647 21 40 00			ld hl, STORE_BLOCK_PHY 
064a 11 00 00			ld de, 0 
064d			 
064d			.fb1:   	 
064d e5					push hl 
064e c5					push bc 
064f d5					push de 
0650 cd 9c 01				call se_readbyte 
0653 d1					pop de 
0654 c1					pop bc 
0655 e1					pop hl 
0656			 
0656					; is free? 
0656 fe 00				cp 0 
0658 20 01				jr nz, .ff1cont 
065a 13					inc de 
065b			 
065b			.ff1cont: 
065b			 
065b			 
065b 3e 40				ld a, STORE_BLOCK_PHY 
065d cd e6 0d				call addatohl 
0660 10 eb				djnz .fb1 
0662			 
0662 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0664			.fb2:   	 
0664 e5					push hl 
0665 c5					push bc 
0666 d5					push de 
0667 cd 9c 01				call se_readbyte 
066a d1					pop de 
066b c1					pop bc 
066c e1					pop hl 
066d			 
066d					; is free? 
066d fe 00				cp 0 
066f 20 01				jr nz, .ff2cont 
0671 13					inc de 
0672			 
0672			.ff2cont: 
0672			 
0672 3e 40				ld a, STORE_BLOCK_PHY 
0674 cd e6 0d				call addatohl 
0677 10 eb				djnz .fb2 
0679			 
0679 eb				ex de, hl 
067a c9				ret 
067b			 
067b			; Get File ID 
067b			; ----------- 
067b			; 
067b			; With current bank 
067b			;  
067b			; Load Block 0 Config 
067b			; Get max file id number 
067b			; For each logical block 
067b			;    Read block file id 
067b			;      If first block of file and dont have file id 
067b			;         if file get id and exit 
067b			 
067b			 
067b			 
067b			 
067b			; Create File 
067b			; ----------- 
067b			; 
067b			; With current bank  
067b			; Load Block 0 Config 
067b			; Get max file id number 
067b			; Increment file id number 
067b			; Save Config 
067b			; Find free block 
067b			; Set buffer with file name and file id 
067b			; Write buffer to free block  
067b			 
067b			 
067b			; hl point to file name 
067b			; hl returns file id 
067b			 
067b			; file format: 
067b			; byte 0 - file id 
067b			; byte 1 - extent number 
067b			; byte 2-> data 
067b			 
067b			; format for extent number 0: 
067b			; 
067b			; byte 0 - file id 
067b			; byte 1 - extent 0 
067b			; byte 2 - extent count 
067b			; byte 3 -> file name and meta data 
067b			 
067b			 
067b			storage_create: 
067b				if DEBUG_STORESE 
067b					DMARK "SCR" 
067b f5				push af  
067c 3a 90 06			ld a, (.dmark)  
067f 32 6b ee			ld (debug_mark),a  
0682 3a 91 06			ld a, (.dmark+1)  
0685 32 6c ee			ld (debug_mark+1),a  
0688 3a 92 06			ld a, (.dmark+2)  
068b 32 6d ee			ld (debug_mark+2),a  
068e 18 03			jr .pastdmark  
0690 ..			.dmark: db "SCR"  
0693 f1			.pastdmark: pop af  
0694			endm  
# End of macro DMARK
0694					CALLMONITOR 
0694 cd 6f ee			call debug_vector  
0697				endm  
# End of macro CALLMONITOR
0697				endif 
0697			 
0697 e5				push hl		; save file name pointer 
0698			 
0698 cd 29 03			call storage_get_block_0 
069b			 
069b 3a 7a ea			ld a,(store_page)	; get current file id 
069e 3c				inc a 
069f 32 7a ea			ld (store_page),a 
06a2				 
06a2 32 6e ea			ld (store_tmpid),a			; save id 
06a5			 
06a5 21 00 00			ld hl, 0 
06a8 11 7a ea			ld de, store_page 
06ab				if DEBUG_STORESE 
06ab					DMARK "SCw" 
06ab f5				push af  
06ac 3a c0 06			ld a, (.dmark)  
06af 32 6b ee			ld (debug_mark),a  
06b2 3a c1 06			ld a, (.dmark+1)  
06b5 32 6c ee			ld (debug_mark+1),a  
06b8 3a c2 06			ld a, (.dmark+2)  
06bb 32 6d ee			ld (debug_mark+2),a  
06be 18 03			jr .pastdmark  
06c0 ..			.dmark: db "SCw"  
06c3 f1			.pastdmark: pop af  
06c4			endm  
# End of macro DMARK
06c4					CALLMONITOR 
06c4 cd 6f ee			call debug_vector  
06c7				endm  
# End of macro CALLMONITOR
06c7				endif 
06c7 cd dd 02			call storage_write_block	 ; save update 
06ca			 
06ca				if DEBUG_STORESE 
06ca 11 7a ea				ld de, store_page 
06cd					DMARK "SCC" 
06cd f5				push af  
06ce 3a e2 06			ld a, (.dmark)  
06d1 32 6b ee			ld (debug_mark),a  
06d4 3a e3 06			ld a, (.dmark+1)  
06d7 32 6c ee			ld (debug_mark+1),a  
06da 3a e4 06			ld a, (.dmark+2)  
06dd 32 6d ee			ld (debug_mark+2),a  
06e0 18 03			jr .pastdmark  
06e2 ..			.dmark: db "SCC"  
06e5 f1			.pastdmark: pop af  
06e6			endm  
# End of macro DMARK
06e6					CALLMONITOR 
06e6 cd 6f ee			call debug_vector  
06e9				endm  
# End of macro CALLMONITOR
06e9				endif 
06e9				;  
06e9				 
06e9 21 40 00			ld hl, STORE_BLOCK_PHY 
06ec 11 00 00			ld de, 0 
06ef cd ab 05			call storage_findnextid 
06f2			 
06f2 22 65 ea			ld (store_tmppageid), hl    ; save page to use  
06f5			 
06f5				; TODO detect 0 = no spare blocks 
06f5			 
06f5				; hl now contains the free page to use for the file header page 
06f5			 
06f5				if DEBUG_STORESE 
06f5				DMARK "SCF" 
06f5 f5				push af  
06f6 3a 0a 07			ld a, (.dmark)  
06f9 32 6b ee			ld (debug_mark),a  
06fc 3a 0b 07			ld a, (.dmark+1)  
06ff 32 6c ee			ld (debug_mark+1),a  
0702 3a 0c 07			ld a, (.dmark+2)  
0705 32 6d ee			ld (debug_mark+2),a  
0708 18 03			jr .pastdmark  
070a ..			.dmark: db "SCF"  
070d f1			.pastdmark: pop af  
070e			endm  
# End of macro DMARK
070e					CALLMONITOR 
070e cd 6f ee			call debug_vector  
0711				endm  
# End of macro CALLMONITOR
0711				endif 
0711			 
0711 22 65 ea			ld (store_tmppageid), hl 
0714				 
0714 3a 6e ea			ld a,(store_tmpid)    ; get file id 
0717			;	ld a, (store_filecache)			; save to cache 
0717			 
0717 32 7a ea			ld (store_page),a    ; set page id 
071a 3e 00			ld a, 0			 ; extent 0 is file header 
071c 32 7b ea			ld (store_page+1), a   ; set file extent 
071f			 
071f 32 7c ea			ld (store_page+2), a   ; extent count for the file 
0722			 
0722			;	inc hl 		; init block 0 of file 
0722			;	inc hl   		; skip file and extent id 
0722			 ;       ld a, 0 
0722			;	ld (hl),a 
0722			;	ld a, (store_filecache+1)  	; save to cache 
0722			 
0722			;	inc hl    ; file name 
0722				 
0722				 
0722 11 7d ea			ld de, store_page+3    ; get buffer for term string to use as file name 
0725				if DEBUG_STORESE 
0725					DMARK "SCc" 
0725 f5				push af  
0726 3a 3a 07			ld a, (.dmark)  
0729 32 6b ee			ld (debug_mark),a  
072c 3a 3b 07			ld a, (.dmark+1)  
072f 32 6c ee			ld (debug_mark+1),a  
0732 3a 3c 07			ld a, (.dmark+2)  
0735 32 6d ee			ld (debug_mark+2),a  
0738 18 03			jr .pastdmark  
073a ..			.dmark: db "SCc"  
073d f1			.pastdmark: pop af  
073e			endm  
# End of macro DMARK
073e					CALLMONITOR 
073e cd 6f ee			call debug_vector  
0741				endm  
# End of macro CALLMONITOR
0741				endif 
0741 e1				pop hl    ; get zero term string 
0742 e5				push hl 
0743 3e 00			ld a, 0 
0745 cd a8 11			call strlent 
0748 23				inc hl   ; cover zero term 
0749 06 00			ld b,0 
074b 4d				ld c,l 
074c e1				pop hl 
074d				;ex de, hl 
074d				if DEBUG_STORESE 
074d					DMARK "SCa" 
074d f5				push af  
074e 3a 62 07			ld a, (.dmark)  
0751 32 6b ee			ld (debug_mark),a  
0754 3a 63 07			ld a, (.dmark+1)  
0757 32 6c ee			ld (debug_mark+1),a  
075a 3a 64 07			ld a, (.dmark+2)  
075d 32 6d ee			ld (debug_mark+2),a  
0760 18 03			jr .pastdmark  
0762 ..			.dmark: db "SCa"  
0765 f1			.pastdmark: pop af  
0766			endm  
# End of macro DMARK
0766					;push af 
0766					;ld a, 'a' 
0766					;ld (debug_mark),a 
0766					;pop af 
0766					CALLMONITOR 
0766 cd 6f ee			call debug_vector  
0769				endm  
# End of macro CALLMONITOR
0769				endif 
0769 ed b0			ldir    ; copy zero term string 
076b				if DEBUG_STORESE 
076b					DMARK "SCA" 
076b f5				push af  
076c 3a 80 07			ld a, (.dmark)  
076f 32 6b ee			ld (debug_mark),a  
0772 3a 81 07			ld a, (.dmark+1)  
0775 32 6c ee			ld (debug_mark+1),a  
0778 3a 82 07			ld a, (.dmark+2)  
077b 32 6d ee			ld (debug_mark+2),a  
077e 18 03			jr .pastdmark  
0780 ..			.dmark: db "SCA"  
0783 f1			.pastdmark: pop af  
0784			endm  
# End of macro DMARK
0784					CALLMONITOR 
0784 cd 6f ee			call debug_vector  
0787				endm  
# End of macro CALLMONITOR
0787				endif 
0787			 
0787				; write file header page 
0787			 
0787 2a 65 ea			ld hl,(store_tmppageid) 
078a 11 7a ea			ld de, store_page 
078d				if DEBUG_STORESE 
078d					DMARK "SCb" 
078d f5				push af  
078e 3a a2 07			ld a, (.dmark)  
0791 32 6b ee			ld (debug_mark),a  
0794 3a a3 07			ld a, (.dmark+1)  
0797 32 6c ee			ld (debug_mark+1),a  
079a 3a a4 07			ld a, (.dmark+2)  
079d 32 6d ee			ld (debug_mark+2),a  
07a0 18 03			jr .pastdmark  
07a2 ..			.dmark: db "SCb"  
07a5 f1			.pastdmark: pop af  
07a6			endm  
# End of macro DMARK
07a6					;push af 
07a6					;ld a, 'b' 
07a6					;ld (debug_mark),a 
07a6					;pop af 
07a6					CALLMONITOR 
07a6 cd 6f ee			call debug_vector  
07a9				endm  
# End of macro CALLMONITOR
07a9				endif 
07a9 cd dd 02			call storage_write_block 
07ac			 
07ac 3a 6e ea			ld a, (store_tmpid) 
07af 6f				ld l, a 
07b0 26 00			ld h,0 
07b2				if DEBUG_STORESE 
07b2					DMARK "SCz" 
07b2 f5				push af  
07b3 3a c7 07			ld a, (.dmark)  
07b6 32 6b ee			ld (debug_mark),a  
07b9 3a c8 07			ld a, (.dmark+1)  
07bc 32 6c ee			ld (debug_mark+1),a  
07bf 3a c9 07			ld a, (.dmark+2)  
07c2 32 6d ee			ld (debug_mark+2),a  
07c5 18 03			jr .pastdmark  
07c7 ..			.dmark: db "SCz"  
07ca f1			.pastdmark: pop af  
07cb			endm  
# End of macro DMARK
07cb					CALLMONITOR 
07cb cd 6f ee			call debug_vector  
07ce				endm  
# End of macro CALLMONITOR
07ce				endif 
07ce c9				ret 
07cf				 
07cf			 
07cf			 
07cf			; 
07cf			; Read File 
07cf			; 
07cf			; h - file id to locate 
07cf			; l - extent to locate 
07cf			; de - pointer to string to read into 
07cf			; 
07cf			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
07cf			 
07cf			.sr_fail: 
07cf d1				pop de 
07d0 c9				ret 
07d1			 
07d1			storage_read: 
07d1			 
07d1			 
07d1 d5				push de 
07d2			 
07d2			; TODO BUG the above push is it popped before the RET Z? 
07d2			 
07d2			; TODO how to handle multiple part blocks 
07d2			 
07d2				; locate file extent to read 
07d2			 
07d2 5c				ld e, h 
07d3 55				ld d, l 
07d4			 
07d4			.srext: 
07d4 22 78 ea			ld (store_readptr), hl     ; save the current extent to load 
07d7 ed 53 76 ea		ld (store_readbuf), de     ; save the current buffer to load in to 
07db			 
07db 21 40 00			ld hl, STORE_BLOCK_PHY 
07de				if DEBUG_STORESE 
07de					DMARK "sre" 
07de f5				push af  
07df 3a f3 07			ld a, (.dmark)  
07e2 32 6b ee			ld (debug_mark),a  
07e5 3a f4 07			ld a, (.dmark+1)  
07e8 32 6c ee			ld (debug_mark+1),a  
07eb 3a f5 07			ld a, (.dmark+2)  
07ee 32 6d ee			ld (debug_mark+2),a  
07f1 18 03			jr .pastdmark  
07f3 ..			.dmark: db "sre"  
07f6 f1			.pastdmark: pop af  
07f7			endm  
# End of macro DMARK
07f7					CALLMONITOR 
07f7 cd 6f ee			call debug_vector  
07fa				endm  
# End of macro CALLMONITOR
07fa				endif 
07fa cd ab 05			call storage_findnextid 
07fd			 
07fd				if DEBUG_STORESE 
07fd					DMARK "srf" 
07fd f5				push af  
07fe 3a 12 08			ld a, (.dmark)  
0801 32 6b ee			ld (debug_mark),a  
0804 3a 13 08			ld a, (.dmark+1)  
0807 32 6c ee			ld (debug_mark+1),a  
080a 3a 14 08			ld a, (.dmark+2)  
080d 32 6d ee			ld (debug_mark+2),a  
0810 18 03			jr .pastdmark  
0812 ..			.dmark: db "srf"  
0815 f1			.pastdmark: pop af  
0816			endm  
# End of macro DMARK
0816					CALLMONITOR 
0816 cd 6f ee			call debug_vector  
0819				endm  
# End of macro CALLMONITOR
0819				endif 
0819 cd 0f 0e			call ishlzero 
081c			;	ld a, l 
081c			;	add h 
081c			;	cp 0 
081c 28 b1			jr z,.sr_fail			; block not found so EOF 
081e			 
081e				; save current address for use by higher level words etc 
081e			 
081e 22 6b ea			ld (store_openaddr),hl 
0821			 
0821			 
0821				; hl contains page number to load 
0821 d1				pop de   ; get storage 
0822 ed 53 76 ea		ld (store_readbuf), de     ; current buffer to load in to 
0826 d5				push de 
0827				if DEBUG_STORESE 
0827					DMARK "srg" 
0827 f5				push af  
0828 3a 3c 08			ld a, (.dmark)  
082b 32 6b ee			ld (debug_mark),a  
082e 3a 3d 08			ld a, (.dmark+1)  
0831 32 6c ee			ld (debug_mark+1),a  
0834 3a 3e 08			ld a, (.dmark+2)  
0837 32 6d ee			ld (debug_mark+2),a  
083a 18 03			jr .pastdmark  
083c ..			.dmark: db "srg"  
083f f1			.pastdmark: pop af  
0840			endm  
# End of macro DMARK
0840					CALLMONITOR 
0840 cd 6f ee			call debug_vector  
0843				endm  
# End of macro CALLMONITOR
0843				endif 
0843 cd 78 02			call storage_read_block 
0846			 
0846				; if this a continuation read??? 
0846			 
0846 2a 76 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
0849			 
0849 3e 3f			ld a, STORE_BLOCK_PHY-1 
084b cd e6 0d			call addatohl 
084e 7e				ld a,(hl) 
084f fe 00			cp 0 
0851 28 02			jr z, .markiscont 
0853 3e ff			ld a, 255 
0855			 
0855			.markiscont: 
0855 32 6d ea			ld (store_readcont), a 
0858			 
0858				if DEBUG_STORESE 
0858					DMARK "srC" 
0858 f5				push af  
0859 3a 6d 08			ld a, (.dmark)  
085c 32 6b ee			ld (debug_mark),a  
085f 3a 6e 08			ld a, (.dmark+1)  
0862 32 6c ee			ld (debug_mark+1),a  
0865 3a 6f 08			ld a, (.dmark+2)  
0868 32 6d ee			ld (debug_mark+2),a  
086b 18 03			jr .pastdmark  
086d ..			.dmark: db "srC"  
0870 f1			.pastdmark: pop af  
0871			endm  
# End of macro DMARK
0871					CALLMONITOR 
0871 cd 6f ee			call debug_vector  
0874				endm  
# End of macro CALLMONITOR
0874				endif 
0874				; only short reads enabled 
0874			 
0874 3a 75 ea			ld a, (store_longread) 
0877 fe 00			cp 0 
0879 ca 46 09			jp z, .readdone 
087c			 
087c			; TODO if block has no zeros then need to read next block  
087c			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
087c			; check last byte of physical block. 
087c			; if not zero then the next block needs to be loaded 
087c			 
087c			 
087c 2a 76 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
087f			 
087f 3e 3f			ld a, STORE_BLOCK_PHY-1 
0881 cd e6 0d			call addatohl 
0884				;dec hl 
0884 7e				ld a,(hl) 
0885				if DEBUG_STORESE 
0885					DMARK "sr?" 
0885 f5				push af  
0886 3a 9a 08			ld a, (.dmark)  
0889 32 6b ee			ld (debug_mark),a  
088c 3a 9b 08			ld a, (.dmark+1)  
088f 32 6c ee			ld (debug_mark+1),a  
0892 3a 9c 08			ld a, (.dmark+2)  
0895 32 6d ee			ld (debug_mark+2),a  
0898 18 03			jr .pastdmark  
089a ..			.dmark: db "sr?"  
089d f1			.pastdmark: pop af  
089e			endm  
# End of macro DMARK
089e					CALLMONITOR 
089e cd 6f ee			call debug_vector  
08a1				endm  
# End of macro CALLMONITOR
08a1				endif 
08a1 fe 00			cp 0 
08a3 ca 46 09			jp z, .readdone 
08a6			 
08a6				; last byte is not zero so there is more in the next extent. Load it on the end.	 
08a6			 
08a6 23				inc hl 
08a7			 
08a7 22 76 ea			ld (store_readbuf), hl     ; save the current buffer to load in to 
08aa			 
08aa ed 5b 78 ea		ld de, (store_readptr)     ; save the current extent to load 
08ae			 
08ae eb				ex de, hl 
08af			 
08af				; next ext 
08af			 
08af 23				inc hl 
08b0 22 78 ea			ld  (store_readptr), hl     ; save the current extent to load 
08b3			 
08b3				if DEBUG_STORESE 
08b3					DMARK "sF2" 
08b3 f5				push af  
08b4 3a c8 08			ld a, (.dmark)  
08b7 32 6b ee			ld (debug_mark),a  
08ba 3a c9 08			ld a, (.dmark+1)  
08bd 32 6c ee			ld (debug_mark+1),a  
08c0 3a ca 08			ld a, (.dmark+2)  
08c3 32 6d ee			ld (debug_mark+2),a  
08c6 18 03			jr .pastdmark  
08c8 ..			.dmark: db "sF2"  
08cb f1			.pastdmark: pop af  
08cc			endm  
# End of macro DMARK
08cc					CALLMONITOR 
08cc cd 6f ee			call debug_vector  
08cf				endm  
# End of macro CALLMONITOR
08cf				endif 
08cf			 
08cf				; get and load block 
08cf			 
08cf cd ab 05			call storage_findnextid 
08d2			 
08d2				if DEBUG_STORESE 
08d2					DMARK "sf2" 
08d2 f5				push af  
08d3 3a e7 08			ld a, (.dmark)  
08d6 32 6b ee			ld (debug_mark),a  
08d9 3a e8 08			ld a, (.dmark+1)  
08dc 32 6c ee			ld (debug_mark+1),a  
08df 3a e9 08			ld a, (.dmark+2)  
08e2 32 6d ee			ld (debug_mark+2),a  
08e5 18 03			jr .pastdmark  
08e7 ..			.dmark: db "sf2"  
08ea f1			.pastdmark: pop af  
08eb			endm  
# End of macro DMARK
08eb					CALLMONITOR 
08eb cd 6f ee			call debug_vector  
08ee				endm  
# End of macro CALLMONITOR
08ee				endif 
08ee cd 0f 0e			call ishlzero 
08f1			;	ld a, l 
08f1			;	add h 
08f1			;	cp 0 
08f1 ca cf 07			jp z,.sr_fail			; block not found so EOF 
08f4				 
08f4				; save current address for use by higher level words etc 
08f4			 
08f4 22 6b ea			ld (store_openaddr),hl 
08f7			 
08f7 cd 78 02			call storage_read_block 
08fa			 
08fa				; on a continuation block, we now have the file id and ext in the middle of the block 
08fa				; we need to pull everything back  
08fa			 
08fa ed 5b 76 ea		ld de, (store_readbuf)     ; current buffer to nudge into 
08fe 2a 76 ea			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0901 23				inc hl 
0902 23				inc hl     ; skip id and ext 
0903 01 40 00			ld bc, STORE_BLOCK_PHY 
0906				if DEBUG_STORESE 
0906					DMARK "SR<" 
0906 f5				push af  
0907 3a 1b 09			ld a, (.dmark)  
090a 32 6b ee			ld (debug_mark),a  
090d 3a 1c 09			ld a, (.dmark+1)  
0910 32 6c ee			ld (debug_mark+1),a  
0913 3a 1d 09			ld a, (.dmark+2)  
0916 32 6d ee			ld (debug_mark+2),a  
0919 18 03			jr .pastdmark  
091b ..			.dmark: db "SR<"  
091e f1			.pastdmark: pop af  
091f			endm  
# End of macro DMARK
091f					CALLMONITOR 
091f cd 6f ee			call debug_vector  
0922				endm  
# End of macro CALLMONITOR
0922				endif 
0922 ed b0			ldir     ; copy data 
0924			 
0924				; move the pointer back and pretend we have a full buffer for next recheck 
0924			 
0924 1b				dec de 
0925 1b				dec de 
0926			 
0926			; TODO do pop below now short circuit loop????? 
0926 c1				pop bc     ; get rid of spare de on stack 
0927				if DEBUG_STORESE 
0927					DMARK "SR>" 
0927 f5				push af  
0928 3a 3c 09			ld a, (.dmark)  
092b 32 6b ee			ld (debug_mark),a  
092e 3a 3d 09			ld a, (.dmark+1)  
0931 32 6c ee			ld (debug_mark+1),a  
0934 3a 3e 09			ld a, (.dmark+2)  
0937 32 6d ee			ld (debug_mark+2),a  
093a 18 03			jr .pastdmark  
093c ..			.dmark: db "SR>"  
093f f1			.pastdmark: pop af  
0940			endm  
# End of macro DMARK
0940					CALLMONITOR 
0940 cd 6f ee			call debug_vector  
0943				endm  
# End of macro CALLMONITOR
0943				endif 
0943 c3 d4 07			jp .srext 
0946			 
0946			 
0946			 
0946			 
0946			 
0946			.readdone:		 
0946 e1				pop hl 		 ; return start of data to show as not EOF 
0947 23				inc hl   ; past file id 
0948 23				inc hl   ; past ext 
0949				if DEBUG_STORESE 
0949					DMARK "SRe" 
0949 f5				push af  
094a 3a 5e 09			ld a, (.dmark)  
094d 32 6b ee			ld (debug_mark),a  
0950 3a 5f 09			ld a, (.dmark+1)  
0953 32 6c ee			ld (debug_mark+1),a  
0956 3a 60 09			ld a, (.dmark+2)  
0959 32 6d ee			ld (debug_mark+2),a  
095c 18 03			jr .pastdmark  
095e ..			.dmark: db "SRe"  
0961 f1			.pastdmark: pop af  
0962			endm  
# End of macro DMARK
0962					CALLMONITOR 
0962 cd 6f ee			call debug_vector  
0965				endm  
# End of macro CALLMONITOR
0965				endif 
0965 c9					ret 
0966			 
0966			 
0966			 
0966			; 
0966			; Append File 
0966			; 
0966			; hl - file id to locate 
0966			; de - pointer to (multi block) string to write 
0966			 
0966			.sa_notfound: 
0966 d1				pop de 
0967 c9				ret 
0968			 
0968			 
0968			storage_append: 
0968				; hl -  file id to append to 
0968				; de - string to append 
0968			 
0968 d5				push de 
0969				 
0969				if DEBUG_STORESE 
0969					DMARK "AP1" 
0969 f5				push af  
096a 3a 7e 09			ld a, (.dmark)  
096d 32 6b ee			ld (debug_mark),a  
0970 3a 7f 09			ld a, (.dmark+1)  
0973 32 6c ee			ld (debug_mark+1),a  
0976 3a 80 09			ld a, (.dmark+2)  
0979 32 6d ee			ld (debug_mark+2),a  
097c 18 03			jr .pastdmark  
097e ..			.dmark: db "AP1"  
0981 f1			.pastdmark: pop af  
0982			endm  
# End of macro DMARK
0982					CALLMONITOR 
0982 cd 6f ee			call debug_vector  
0985				endm  
# End of macro CALLMONITOR
0985				endif 
0985			 
0985 7d				ld a, l 
0986 32 6e ea			ld (store_tmpid), a 
0989			 
0989				; get file header  
0989			 
0989 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
098b 3a 6e ea			ld a, (store_tmpid) 
098e 5f				ld e, a 
098f			 
098f 21 40 00				ld hl, STORE_BLOCK_PHY 
0992 cd ab 05				call storage_findnextid 
0995			 
0995 cd 0f 0e			call ishlzero 
0998 28 cc			jr z, .sa_notfound 
099a			 
099a 22 65 ea			ld (store_tmppageid), hl 
099d			 
099d				; TODO handle file id not found 
099d			 
099d				if DEBUG_STORESE 
099d					DMARK "AP2" 
099d f5				push af  
099e 3a b2 09			ld a, (.dmark)  
09a1 32 6b ee			ld (debug_mark),a  
09a4 3a b3 09			ld a, (.dmark+1)  
09a7 32 6c ee			ld (debug_mark+1),a  
09aa 3a b4 09			ld a, (.dmark+2)  
09ad 32 6d ee			ld (debug_mark+2),a  
09b0 18 03			jr .pastdmark  
09b2 ..			.dmark: db "AP2"  
09b5 f1			.pastdmark: pop af  
09b6			endm  
# End of macro DMARK
09b6					CALLMONITOR 
09b6 cd 6f ee			call debug_vector  
09b9				endm  
# End of macro CALLMONITOR
09b9				endif 
09b9			 
09b9				; update file extent count 
09b9			 
09b9 11 7a ea			ld de, store_page 
09bc			 
09bc cd 78 02			call storage_read_block 
09bf			 
09bf				if DEBUG_STORESE 
09bf					DMARK "AP3" 
09bf f5				push af  
09c0 3a d4 09			ld a, (.dmark)  
09c3 32 6b ee			ld (debug_mark),a  
09c6 3a d5 09			ld a, (.dmark+1)  
09c9 32 6c ee			ld (debug_mark+1),a  
09cc 3a d6 09			ld a, (.dmark+2)  
09cf 32 6d ee			ld (debug_mark+2),a  
09d2 18 03			jr .pastdmark  
09d4 ..			.dmark: db "AP3"  
09d7 f1			.pastdmark: pop af  
09d8			endm  
# End of macro DMARK
09d8					CALLMONITOR 
09d8 cd 6f ee			call debug_vector  
09db				endm  
# End of macro CALLMONITOR
09db				endif 
09db			;	ld (store_tmppageid), hl 
09db			 
09db 3a 7c ea			ld a, (store_page+2) 
09de 3c				inc a 
09df 32 7c ea			ld (store_page+2), a 
09e2 32 6d ea			ld (store_tmpext), a 
09e5				 
09e5				if DEBUG_STORESE 
09e5					DMARK "AP3" 
09e5 f5				push af  
09e6 3a fa 09			ld a, (.dmark)  
09e9 32 6b ee			ld (debug_mark),a  
09ec 3a fb 09			ld a, (.dmark+1)  
09ef 32 6c ee			ld (debug_mark+1),a  
09f2 3a fc 09			ld a, (.dmark+2)  
09f5 32 6d ee			ld (debug_mark+2),a  
09f8 18 03			jr .pastdmark  
09fa ..			.dmark: db "AP3"  
09fd f1			.pastdmark: pop af  
09fe			endm  
# End of macro DMARK
09fe					CALLMONITOR 
09fe cd 6f ee			call debug_vector  
0a01				endm  
# End of macro CALLMONITOR
0a01				endif 
0a01 2a 65 ea			ld hl, (store_tmppageid) 
0a04 11 7a ea			ld de, store_page 
0a07 cd dd 02			call storage_write_block 
0a0a			 
0a0a				; find free block 
0a0a			 
0a0a 11 00 00			ld de, 0			 ; file extent to locate 
0a0d			 
0a0d 21 40 00				ld hl, STORE_BLOCK_PHY 
0a10 cd ab 05				call storage_findnextid 
0a13 cd 0f 0e			call ishlzero 
0a16 ca 66 09			jp z, .sa_notfound 
0a19			 
0a19					; TODO handle no space left 
0a19					 
0a19 22 65 ea				ld (store_tmppageid), hl 
0a1c			 
0a1c				if DEBUG_STORESE 
0a1c					DMARK "AP4" 
0a1c f5				push af  
0a1d 3a 31 0a			ld a, (.dmark)  
0a20 32 6b ee			ld (debug_mark),a  
0a23 3a 32 0a			ld a, (.dmark+1)  
0a26 32 6c ee			ld (debug_mark+1),a  
0a29 3a 33 0a			ld a, (.dmark+2)  
0a2c 32 6d ee			ld (debug_mark+2),a  
0a2f 18 03			jr .pastdmark  
0a31 ..			.dmark: db "AP4"  
0a34 f1			.pastdmark: pop af  
0a35			endm  
# End of macro DMARK
0a35					CALLMONITOR 
0a35 cd 6f ee			call debug_vector  
0a38				endm  
# End of macro CALLMONITOR
0a38				endif 
0a38					; init the buffer with zeros so we can id if the buffer is full or not 
0a38			 
0a38 e5					push hl 
0a39 c5					push bc 
0a3a			 
0a3a 21 7a ea				ld hl, store_page 
0a3d 06 40				ld b, STORE_BLOCK_PHY 
0a3f 3e 00				ld a, 0 
0a41 77			.zeroblock:	ld (hl), a 
0a42 23					inc hl 
0a43 10 fc				djnz .zeroblock 
0a45			 
0a45 c1					pop bc 
0a46 e1					pop hl 
0a47			 
0a47					; construct block 
0a47			 
0a47 3a 6e ea				ld a, (store_tmpid) 
0a4a 32 7a ea				ld (store_page), a   ; file id 
0a4d 3a 6d ea				ld a, (store_tmpext)   ; extent for this block 
0a50 32 7b ea				ld (store_page+1), a 
0a53			 
0a53 e1					pop hl    ; get string to write 
0a54 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0a56 11 7c ea				ld de, store_page+2 
0a59			 
0a59				if DEBUG_STORESE 
0a59					DMARK "AP5" 
0a59 f5				push af  
0a5a 3a 6e 0a			ld a, (.dmark)  
0a5d 32 6b ee			ld (debug_mark),a  
0a60 3a 6f 0a			ld a, (.dmark+1)  
0a63 32 6c ee			ld (debug_mark+1),a  
0a66 3a 70 0a			ld a, (.dmark+2)  
0a69 32 6d ee			ld (debug_mark+2),a  
0a6c 18 03			jr .pastdmark  
0a6e ..			.dmark: db "AP5"  
0a71 f1			.pastdmark: pop af  
0a72			endm  
# End of macro DMARK
0a72					CALLMONITOR 
0a72 cd 6f ee			call debug_vector  
0a75				endm  
# End of macro CALLMONITOR
0a75				endif 
0a75			 
0a75			 
0a75			 
0a75					; fill buffer with data until end of string or full block 
0a75			 
0a75 7e			.appd:		ld a, (hl) 
0a76 12					ld (de), a 
0a77 fe 00				cp 0 
0a79 28 04				jr z, .appdone 
0a7b 23					inc hl 
0a7c 13					inc de 
0a7d 10 f6				djnz .appd 
0a7f			 
0a7f e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0a80 f5					push af   		; save last byte dumped 
0a81			 
0a81			 
0a81 2a 65 ea			ld hl, (store_tmppageid) 
0a84 11 7a ea			ld de, store_page 
0a87				if DEBUG_STORESE 
0a87					DMARK "AP6" 
0a87 f5				push af  
0a88 3a 9c 0a			ld a, (.dmark)  
0a8b 32 6b ee			ld (debug_mark),a  
0a8e 3a 9d 0a			ld a, (.dmark+1)  
0a91 32 6c ee			ld (debug_mark+1),a  
0a94 3a 9e 0a			ld a, (.dmark+2)  
0a97 32 6d ee			ld (debug_mark+2),a  
0a9a 18 03			jr .pastdmark  
0a9c ..			.dmark: db "AP6"  
0a9f f1			.pastdmark: pop af  
0aa0			endm  
# End of macro DMARK
0aa0					CALLMONITOR 
0aa0 cd 6f ee			call debug_vector  
0aa3				endm  
# End of macro CALLMONITOR
0aa3				endif 
0aa3 cd dd 02				call storage_write_block 
0aa6			 
0aa6			 
0aa6				; was that a full block of data written? 
0aa6				; any more to write out? 
0aa6			 
0aa6				; if yes then set vars and jump to start of function again 
0aa6			 
0aa6 f1					pop af 
0aa7 d1					pop de 
0aa8			 
0aa8 fe 00				cp 0		 ; no, string was fully written 
0aaa c8					ret z 
0aab			 
0aab					; setup vars for next cycle 
0aab			 
0aab 3a 6e ea				ld a, (store_tmpid) 
0aae 6f					ld l, a 
0aaf 26 00				ld h, 0 
0ab1			 
0ab1 c3 68 09			 	jp storage_append	 ; yes, need to write out some more 
0ab4			 
0ab4			 
0ab4			 
0ab4			 
0ab4			 
0ab4			 
0ab4			 
0ab4			if DEBUG_STORECF 
0ab4			storageput:	 
0ab4					ret 
0ab4			storageread: 
0ab4					ld hl, store_page 
0ab4					ld b, 200 
0ab4					ld a,0 
0ab4			.src:		ld (hl),a 
0ab4					inc hl 
0ab4					djnz .src 
0ab4					 
0ab4			 
0ab4					ld de, 0 
0ab4					ld bc, 1 
0ab4					ld hl, store_page 
0ab4					call cfRead 
0ab4			 
0ab4				call cfGetError 
0ab4				ld hl,scratch 
0ab4				call hexout 
0ab4				ld hl, scratch+2 
0ab4				ld a, 0 
0ab4				ld (hl),a 
0ab4				ld de, scratch 
0ab4				ld a,display_row_1 
0ab4				call str_at_display 
0ab4				call update_display 
0ab4			 
0ab4					ld hl, store_page 
0ab4					ld (os_cur_ptr),hl 
0ab4			 
0ab4					ret 
0ab4			endif 
0ab4			 
0ab4			 
0ab4			; Clear out the main buffer store (used to remove junk before writing a new block) 
0ab4			 
0ab4			storage_clear_page: 
0ab4 e5				push hl 
0ab5 d5				push de 
0ab6 c5				push bc 
0ab7 21 7a ea			ld hl, store_page 
0aba 3e 00			ld a, 0 
0abc 77				ld (hl), a 
0abd			 
0abd 11 7b ea			ld de, store_page+1 
0ac0 01 19 01			ld bc, STORE_BLOCK_LOG+1 
0ac3			 
0ac3 ed b0			ldir 
0ac5				 
0ac5 c1				pop bc 
0ac6 d1				pop de 
0ac7 e1				pop hl 
0ac8 c9				ret 
0ac9			 
0ac9			; eof 
# End of file firmware_storage.asm
0ac9			  
0ac9			; support routines for above hardware abstraction layer  
0ac9			  
0ac9			include "firmware_general.asm"        ; general support functions  
0ac9			 
0ac9			; word look up 
0ac9			 
0ac9			; in 
0ac9			; a is the index 
0ac9			; hl is pointer start of array 
0ac9			; 
0ac9			; returns 
0ac9			; hl to the word 
0ac9			; 
0ac9			 
0ac9			table_lookup:  
0ac9 d5					push de 
0aca eb					ex de, hl 
0acb			 
0acb 6f					ld l, a 
0acc 26 00				ld h, 0 
0ace 29					add hl, hl 
0acf 19					add hl, de 
0ad0 7e					ld a, (hl) 
0ad1 23					inc hl 
0ad2 66					ld h,(hl) 
0ad3 6f					ld l, a 
0ad4			 
0ad4 d1					pop de 
0ad5 c9					ret 
0ad6			 
0ad6			; Delay loops 
0ad6			 
0ad6			 
0ad6			 
0ad6			aDelayInMS: 
0ad6 c5				push bc 
0ad7 47				ld b,a 
0ad8			msdelay: 
0ad8 c5				push bc 
0ad9				 
0ad9			 
0ad9 01 41 00			ld bc,041h 
0adc cd f4 0a			call delayloop 
0adf c1				pop bc 
0ae0 05				dec b 
0ae1 20 f5			jr nz,msdelay 
0ae3			 
0ae3			;if CPU_CLOCK_8MHZ 
0ae3			;msdelay8: 
0ae3			;	push bc 
0ae3			;	 
0ae3			; 
0ae3			;	ld bc,041h 
0ae3			;	call delayloop 
0ae3			;	pop bc 
0ae3			;	dec b 
0ae3			;	jr nz,msdelay8 
0ae3			;endif 
0ae3			 
0ae3			 
0ae3 c1				pop bc 
0ae4 c9				ret 
0ae5			 
0ae5			 
0ae5			delay250ms: 
0ae5				;push de 
0ae5 01 00 40			ld bc, 04000h 
0ae8 c3 f4 0a			jp delayloop 
0aeb			delay500ms: 
0aeb				;push de 
0aeb 01 00 80			ld bc, 08000h 
0aee c3 f4 0a			jp delayloop 
0af1			delay1s: 
0af1				;push bc 
0af1			   ; Clobbers A, d and e 
0af1 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0af4			delayloop: 
0af4 c5			    push bc 
0af5			 
0af5			if BASE_CPM 
0af5 01 a0 0f			ld bc, CPM_DELAY_TUNE 
0af8			.cpmloop: 
0af8 c5				push bc 
0af9			 
0af9			endif 
0af9			 
0af9			 
0af9			 
0af9			delayloopi: 
0af9			;	push bc 
0af9			;.dl: 
0af9 cb 47		    bit     0,a    	; 8 
0afb cb 47		    bit     0,a    	; 8 
0afd cb 47		    bit     0,a    	; 8 
0aff e6 ff		    and     255  	; 7 
0b01 0b			    dec     bc      	; 6 
0b02 79			    ld      a,c     	; 4 
0b03 b0			    or      b     	; 4 
0b04 c2 f9 0a		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0b07			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0b07				;pop de 
0b07			;pop bc 
0b07			 
0b07			if BASE_CPM 
0b07 c1				pop bc 
0b08				 
0b08 0b			    dec     bc      	; 6 
0b09 79			    ld      a,c     	; 4 
0b0a b0			    or      b     	; 4 
0b0b c2 f8 0a		    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0b0e				 
0b0e			 
0b0e			endif 
0b0e			;if CPU_CLOCK_8MHZ 
0b0e			;    pop bc 
0b0e			;    push bc 
0b0e			;.dl8: 
0b0e			;    bit     0,a    	; 8 
0b0e			;    bit     0,a    	; 8 
0b0e			;    bit     0,a    	; 8 
0b0e			;    and     255  	; 7 
0b0e			;    dec     bc      	; 6 
0b0e			;    ld      a,c     	; 4 
0b0e			;    or      b     	; 4 
0b0e			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b0e			;endif 
0b0e			 
0b0e			;if CPU_CLOCK_10MHZ 
0b0e			;    pop bc 
0b0e			;    push bc 
0b0e			;.dl8: 
0b0e			;    bit     0,a    	; 8 
0b0e			;    bit     0,a    	; 8 
0b0e			;    bit     0,a    	; 8 
0b0e			;    and     255  	; 7 
0b0e			;    dec     bc      	; 6 
0b0e			;    ld      a,c     	; 4 
0b0e			;    or      b     	; 4 
0b0e			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b0e			;endif 
0b0e c1			    pop bc 
0b0f			 
0b0f c9				ret 
0b10			 
0b10			 
0b10			 
0b10			; eof 
# End of file firmware_general.asm
0b10			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0b10			; display routines that use the physical hardware abstraction layer 
0b10			 
0b10			 
0b10			; Display an activity indicator 
0b10			; Each call returns the new char pointed to in hl 
0b10			 
0b10			active: 
0b10 3a c6 eb			ld a, (display_active) 
0b13 fe 06			cp 6 
0b15			 
0b15 20 02			jr nz, .sne 
0b17				; gone past the last one reset sequence 
0b17 3e ff			ld a, 255 
0b19			 
0b19			.sne:   
0b19				; get the next char in seq 
0b19 3c				inc a 
0b1a 32 c6 eb			ld (display_active), a 
0b1d			 
0b1d				; look up the string in the table 
0b1d 21 34 0b			ld hl, actseq 
0b20 cb 27			sla a 
0b22 cd e6 0d			call addatohl 
0b25 cd da 1e			call loadwordinhl 
0b28			 
0b28				; forth will write the to string when pushing so move from rom to ram 
0b28			 
0b28 11 c7 eb			ld de, display_active+1 
0b2b 01 02 00			ld bc, 2 
0b2e ed b0			ldir 
0b30			 
0b30 21 c7 eb			ld hl, display_active+1 
0b33 c9				ret 
0b34				 
0b34				 
0b34			 
0b34			 
0b34			;db "|/-\|-\" 
0b34			 
0b34			actseq: 
0b34			 
0b34 42 0b		dw spin0 
0b36 44 0b		dw spin1 
0b38 46 0b		dw spin2 
0b3a 48 0b		dw spin3 
0b3c 46 0b		dw spin2 
0b3e 44 0b		dw spin1 
0b40 42 0b		dw spin0 
0b42			 
0b42 .. 00		spin0: db " ", 0 
0b44 .. 00		spin1: db "-", 0 
0b46 .. 00		spin2: db "+", 0 
0b48 .. 00		spin3: db "#", 0 
0b4a			 
0b4a			 
0b4a			; information window 
0b4a			 
0b4a			; pass hl with 1st string to display 
0b4a			; pass de with 2nd string to display 
0b4a			 
0b4a			info_panel: 
0b4a e5				push hl 
0b4b			 
0b4b 2a cc eb			ld hl, (display_fb_active) 
0b4e e5				push hl    ; future de destination 
0b4f 21 b1 ed				ld hl, display_fb0 
0b52 22 cc eb				ld (display_fb_active), hl 
0b55			 
0b55			;	call clear_display 
0b55			 
0b55				if BASE_CPM 
0b55 3e 2e			ld a, '.' 
0b57				else 
0b57				ld a, 165 
0b57				endif 
0b57 cd be 0b			call fill_display 
0b5a			 
0b5a			 
0b5a 3e 55			ld a, display_row_3 + 5 
0b5c cd cc 0b			call str_at_display 
0b5f			 
0b5f e1				pop hl 
0b60 d1				pop de 
0b61			 
0b61 e5				push hl 
0b62			 
0b62			 
0b62 3e 2d			ld a, display_row_2 + 5 
0b64 cd cc 0b			call str_at_display 
0b67			 
0b67			 
0b67 cd dc 0b			call update_display 
0b6a cd 23 1b			call next_page_prompt 
0b6d cd b9 0b			call clear_display 
0b70			 
0b70				 
0b70 21 10 ed				ld hl, display_fb1 
0b73 22 cc eb				ld (display_fb_active), hl 
0b76 cd dc 0b			call update_display 
0b79			 
0b79 e1				pop hl 
0b7a			 
0b7a c9				ret 
0b7b			 
0b7b			 
0b7b			 
0b7b			 
0b7b			; TODO windowing? 
0b7b			 
0b7b			; TODO scroll line up 
0b7b			 
0b7b			scroll_up: 
0b7b			 
0b7b e5				push hl 
0b7c d5				push de 
0b7d c5				push bc 
0b7e			 
0b7e				; get frame buffer  
0b7e			 
0b7e 2a cc eb			ld hl, (display_fb_active) 
0b81 e5				push hl    ; future de destination 
0b82			 
0b82 11 28 00			ld  de, display_cols 
0b85 19				add hl, de 
0b86			 
0b86 d1				pop de 
0b87			 
0b87				;ex de, hl 
0b87 01 9f 00			ld bc, display_fb_len -1  
0b8a			;if DEBUG_FORTH_WORDS 
0b8a			;	DMARK "SCL" 
0b8a			;	CALLMONITOR 
0b8a			;endif	 
0b8a ed b0			ldir 
0b8c			 
0b8c				; wipe bottom row 
0b8c			 
0b8c			 
0b8c 2a cc eb			ld hl, (display_fb_active) 
0b8f 11 a0 00			ld de, display_cols*display_rows 
0b92 19				add hl, de 
0b93 06 28			ld b, display_cols 
0b95 3e 20			ld a, ' ' 
0b97			.scwipe: 
0b97 77				ld (hl), a 
0b98 2b				dec hl 
0b99 10 fc			djnz .scwipe 
0b9b			 
0b9b				;pop hl 
0b9b			 
0b9b c1				pop bc 
0b9c d1				pop de 
0b9d e1				pop hl 
0b9e			 
0b9e c9				ret 
0b9f			 
0b9f			 
0b9f			;scroll_upo: 
0b9f			;	ld de, display_row_1 
0b9f			 ;	ld hl, display_row_2 
0b9f			;	ld bc, display_cols 
0b9f			;	ldir 
0b9f			;	ld de, display_row_2 
0b9f			 ;	ld hl, display_row_3 
0b9f			;	ld bc, display_cols 
0b9f			;	ldir 
0b9f			;	ld de, display_row_3 
0b9f			 ;	ld hl, display_row_4 
0b9f			;	ld bc, display_cols 
0b9f			;	ldir 
0b9f			 
0b9f			; TODO clear row 4 
0b9f			 
0b9f			;	ret 
0b9f			 
0b9f				 
0b9f			scroll_down: 
0b9f			 
0b9f e5				push hl 
0ba0 d5				push de 
0ba1 c5				push bc 
0ba2			 
0ba2				; get frame buffer  
0ba2			 
0ba2 2a cc eb			ld hl, (display_fb_active) 
0ba5			 
0ba5 11 9f 00			ld de, display_fb_len - 1 
0ba8 19				add hl, de 
0ba9			 
0ba9 e5			push hl    ; future de destination 
0baa			 
0baa 11 28 00			ld  de, display_cols 
0bad ed 52			sbc hl, de 
0baf			 
0baf			 
0baf d1				pop de 
0bb0			 
0bb0			;	ex de, hl 
0bb0 01 9f 00			ld bc, display_fb_len -1  
0bb3			 
0bb3			 
0bb3				 
0bb3			 
0bb3 ed b0			ldir 
0bb5			 
0bb5				; wipe bottom row 
0bb5			 
0bb5			 
0bb5			;	ld hl, (display_fb_active) 
0bb5			;;	ld de, display_cols*display_rows 
0bb5			;;	add hl, de 
0bb5			;	ld b, display_cols 
0bb5			;	ld a, ' ' 
0bb5			;.scwiped: 
0bb5			;	ld (hl), a 
0bb5			;	dec hl 
0bb5			;	djnz .scwiped 
0bb5			 
0bb5				;pop hl 
0bb5			 
0bb5 c1				pop bc 
0bb6 d1				pop de 
0bb7 e1				pop hl 
0bb8			 
0bb8 c9				ret 
0bb9			;scroll_down: 
0bb9			;	ld de, display_row_4 
0bb9			;	ld hl, display_row_3 
0bb9			;	ld bc, display_cols 
0bb9			;	ldir 
0bb9			;	ld de, display_row_3 
0bb9			; 	ld hl, display_row_2 
0bb9			;	ld bc, display_cols 
0bb9			;	ldir 
0bb9			;	ld de, display_row_2 
0bb9			;	ld hl, display_row_1 
0bb9			;	ld bc, display_cols 
0bb9			;	ldir 
0bb9			;;; TODO clear row 1 
0bb9			;	ret 
0bb9			 
0bb9			 
0bb9			 
0bb9			 
0bb9			 
0bb9			; clear active frame buffer 
0bb9			 
0bb9			clear_display: 
0bb9 3e 20			ld a, ' ' 
0bbb c3 be 0b			jp fill_display 
0bbe			 
0bbe			; fill active frame buffer with a char in A 
0bbe			 
0bbe			fill_display: 
0bbe 06 a0			ld b,display_fb_len 
0bc0 2a cc eb			ld hl, (display_fb_active) 
0bc3 77			.fd1:	ld (hl),a 
0bc4 23				inc hl 
0bc5 10 fc			djnz .fd1 
0bc7 23				inc hl 
0bc8 3e 00			ld a,0 
0bca 77				ld (hl),a 
0bcb			 
0bcb			 
0bcb c9				ret 
0bcc			; Write string (DE) at pos (A) to active frame buffer 
0bcc			 
0bcc 2a cc eb		str_at_display:    ld hl,(display_fb_active) 
0bcf 06 00					ld b,0 
0bd1 4f					ld c,a 
0bd2 09					add hl,bc 
0bd3 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0bd4 b7			            OR   A              ;Null terminator? 
0bd5 c8			            RET  Z              ;Yes, so finished 
0bd6 77					ld (hl),a 
0bd7 23				inc hl 
0bd8 13			            INC  DE             ;Point to next character 
0bd9 18 f8		            JR   .sad1     ;Repeat 
0bdb c9					ret 
0bdc			 
0bdc			; using current frame buffer write to physical display 
0bdc			 
0bdc			update_display: 
0bdc e5				push hl 
0bdd 2a cc eb			ld hl, (display_fb_active) 
0be0 cd cd 64			call write_display 
0be3 e1				pop hl 
0be4 c9				ret 
0be5			 
0be5			; TODO scrolling 
0be5			 
0be5			 
0be5			; move cursor right one char 
0be5			cursor_right: 
0be5			 
0be5				; TODO shift right 
0be5				; TODO if beyond max col 
0be5				; TODO       cursor_next_line 
0be5			 
0be5 c9				ret 
0be6			 
0be6			 
0be6			cursor_next_line: 
0be6				; TODO first char 
0be6				; TODO line down 
0be6				; TODO if past last row 
0be6				; TODO    scroll up 
0be6			 
0be6 c9				ret 
0be7			 
0be7			cursor_left: 
0be7				; TODO shift left 
0be7				; TODO if beyond left  
0be7				; TODO     cursor prev line 
0be7				 
0be7 c9				ret 
0be8			 
0be8			cursor_prev_line: 
0be8				; TODO last char 
0be8				; TODO line up 
0be8				; TODO if past first row 
0be8				; TODO   scroll down 
0be8			 
0be8 c9				ret 
0be9			 
0be9			 
0be9			cout: 
0be9				; A - char 
0be9 c9				ret 
0bea			 
0bea			 
0bea			; Display a menu and allow item selection (optional toggle items) 
0bea			; 
0bea			; format: 
0bea			; hl pointer to word array with zero term for items 
0bea			; e.g.    db item1 
0bea			;         db .... 
0bea			;         db 0 
0bea			; 
0bea			; a = starting menu item  
0bea			; 
0bea			; de = pointer item toggle array   (todo) 
0bea			; 
0bea			; returns item selected in a 1-... 
0bea			; returns 0 if back button pressed 
0bea			; 
0bea			; NOTE: Uses system frame buffer to display 
0bea			; 
0bea			; LEFT, Q = go back 
0bea			; RIGHT, SPACE, CR = select 
0bea			; UP, A - Up 
0bea			; DOWN, Z - Down 
0bea			 
0bea			 
0bea			 
0bea			 
0bea			 
0bea			menu: 
0bea			 
0bea					; keep array pointer 
0bea			 
0bea 22 73 ea				ld (store_tmp1), hl 
0bed 32 71 ea				ld (store_tmp2), a 
0bf0			 
0bf0					; check for key bounce 
0bf0			 
0bf0			if BASE_KEV 
0bf0			 
0bf0			.mbounce:	call cin 
0bf0					cp 0 
0bf0					jr nz, .mbounce 
0bf0			endif 
0bf0					; for ease use ex 
0bf0			 
0bf0					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0bf0 21 b1 ed				ld hl, display_fb0 
0bf3 22 cc eb				ld (display_fb_active), hl 
0bf6			 
0bf6 cd b9 0b		.mloop:		call clear_display 
0bf9 cd dc 0b				call update_display 
0bfc			 
0bfc					; draw selection id '>' at 1 
0bfc			 
0bfc					; init start of list display 
0bfc			 
0bfc 3e 05				ld a, 5 
0bfe 32 6f ea				ld (store_tmp3), a   ; display row count 
0c01 3a 71 ea				ld a,( store_tmp2) 
0c04 32 72 ea				ld (store_tmp2+1), a   ; display item count 
0c07			 
0c07					 
0c07			.mitem:	 
0c07			 
0c07			 
0c07 3a 72 ea				ld a,(store_tmp2+1) 
0c0a 6f					ld l, a 
0c0b 26 00				ld h, 0 
0c0d 29					add hl, hl 
0c0e ed 5b 73 ea			ld de, (store_tmp1) 
0c12 19					add hl, de 
0c13 7e					ld a, (hl) 
0c14 23					inc hl 
0c15 66					ld h,(hl) 
0c16 6f					ld l, a 
0c17			 
0c17 cd 0f 0e				call ishlzero 
0c1a 28 1a				jr z, .mdone 
0c1c			 
0c1c eb					ex de, hl 
0c1d 3a 6f ea				ld a, (store_tmp3) 
0c20 cd cc 0b				call str_at_display 
0c23					 
0c23			 
0c23					; next item 
0c23 3a 72 ea				ld a, (store_tmp2+1) 
0c26 3c					inc a 
0c27 32 72 ea				ld (store_tmp2+1), a   ; display item count 
0c2a			 
0c2a			 		; next row 
0c2a			 
0c2a 3a 6f ea				ld a, (store_tmp3) 
0c2d c6 28				add display_cols 
0c2f 32 6f ea				ld (store_tmp3), a 
0c32			 
0c32					; at end of screen? 
0c32			 
0c32 fe 10				cp display_rows*4 
0c34 20 d1				jr nz, .mitem 
0c36			 
0c36			 
0c36			.mdone: 
0c36 cd 0f 0e				call ishlzero 
0c39 28 08				jr z, .nodn 
0c3b			 
0c3b 3e 78				ld a, display_row_4 
0c3d 11 bc 0c				ld de, .mdown 
0c40 cd cc 0b				call str_at_display 
0c43			 
0c43					; draw options to fill the screens with active item on line 1 
0c43					; if current option is 2 or more then display ^ in top 
0c43			 
0c43 3a 71 ea		.nodn:		ld a, (store_tmp2) 
0c46 fe 00				cp 0 
0c48 28 08				jr z, .noup 
0c4a			 
0c4a 3e 00				ld a, 0 
0c4c 11 ba 0c				ld de, .mup 
0c4f cd cc 0b				call str_at_display 
0c52			 
0c52 3e 02		.noup:		ld a, 2 
0c54 11 b8 0c				ld de, .msel 
0c57 cd cc 0b				call str_at_display 
0c5a			 
0c5a					; if current option + 1 is not null then display V in bottom 
0c5a					; get key 
0c5a cd dc 0b				call update_display 
0c5d			 
0c5d			 
0c5d					; handle key 
0c5d			 
0c5d cd 7f 65				call cin_wait 
0c60			 
0c60 fe 05				cp KEY_UP 
0c62 28 2b				jr z, .mgoup 
0c64 fe 61				cp 'a' 
0c66 28 27				jr z, .mgoup 
0c68 fe 0a				cp KEY_DOWN 
0c6a 28 32				jr z, .mgod 
0c6c fe 7a				cp 'z' 
0c6e 28 2e				jr z, .mgod 
0c70 fe 20				cp ' ' 
0c72 28 34				jr z, .goend 
0c74 fe 0c				cp KEY_RIGHT 
0c76 28 30				jr z, .goend 
0c78 fe 0d				cp KEY_CR 
0c7a 28 2c				jr z, .goend 
0c7c fe 71				cp 'q' 
0c7e 28 0b				jr z, .goback 
0c80			 
0c80 fe 0b				cp KEY_LEFT 
0c82 28 07				jr z, .goback 
0c84 fe 08				cp KEY_BS 
0c86 28 03				jr z, .goback 
0c88 c3 f6 0b				jp .mloop 
0c8b			 
0c8b			.goback: 
0c8b 3e 00			ld a, 0 
0c8d 18 1d			jr .goend2 
0c8f			 
0c8f				; move up one 
0c8f			.mgoup: 
0c8f 3a 71 ea				ld a, (store_tmp2) 
0c92 fe 00				cp 0 
0c94 ca f6 0b				jp z, .mloop 
0c97 3d					dec a 
0c98 32 71 ea				ld (store_tmp2), a 
0c9b c3 f6 0b				jp .mloop 
0c9e			 
0c9e				; move down one 
0c9e			.mgod: 
0c9e 3a 71 ea				ld a, (store_tmp2) 
0ca1 3c					inc a 
0ca2 32 71 ea				ld (store_tmp2), a 
0ca5 c3 f6 0b				jp .mloop 
0ca8			 
0ca8			 
0ca8			.goend: 
0ca8					; get selected item number 
0ca8			 
0ca8 3a 71 ea				ld a, (store_tmp2) 
0cab 3c					inc a 
0cac			 
0cac			.goend2: 
0cac f5					push af 
0cad			 
0cad					; restore active fb 
0cad					; TODO BUG assumes fb1 
0cad			 
0cad 21 10 ed				ld hl, display_fb1 
0cb0 22 cc eb				ld (display_fb_active), hl 
0cb3			 
0cb3					; restore main regs 
0cb3			 
0cb3			 
0cb3 cd dc 0b				call update_display 
0cb6			 
0cb6 f1					pop af 
0cb7			 
0cb7 c9				ret 
0cb8			 
0cb8 .. 00		.msel:   db ">",0 
0cba .. 00		.mup:   db "^",0 
0cbc .. 00		.mdown:   db "v",0 
0cbe			 
0cbe			 
0cbe			; eof 
0cbe			 
# End of file firmware_display.asm
0cbe			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0cbe			; random number generators 
0cbe			 
0cbe			 
0cbe			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0cbe			 
0cbe			 
0cbe			;-----> Generate a random number 
0cbe			; output a=answer 0<=a<=255 
0cbe			; all registers are preserved except: af 
0cbe			random: 
0cbe e5			        push    hl 
0cbf d5			        push    de 
0cc0 2a ab eb		        ld      hl,(randData) 
0cc3 ed 5f		        ld      a,r 
0cc5 57			        ld      d,a 
0cc6 5e			        ld      e,(hl) 
0cc7 19			        add     hl,de 
0cc8 85			        add     a,l 
0cc9 ac			        xor     h 
0cca 22 ab eb		        ld      (randData),hl 
0ccd d1			        pop     de 
0cce e1			        pop     hl 
0ccf c9			        ret 
0cd0			 
0cd0			 
0cd0			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0cd0			 
0cd0			 
0cd0			 
0cd0			;------LFSR------ 
0cd0			;James Montelongo 
0cd0			;optimized by Spencer Putt 
0cd0			;out: 
0cd0			; a = 8 bit random number 
0cd0			RandLFSR: 
0cd0 21 b1 eb		        ld hl,LFSRSeed+4 
0cd3 5e			        ld e,(hl) 
0cd4 23			        inc hl 
0cd5 56			        ld d,(hl) 
0cd6 23			        inc hl 
0cd7 4e			        ld c,(hl) 
0cd8 23			        inc hl 
0cd9 7e			        ld a,(hl) 
0cda 47			        ld b,a 
0cdb cb 13		        rl e  
0cdd cb 12			rl d 
0cdf cb 11		        rl c  
0ce1 17				rla 
0ce2 cb 13		        rl e  
0ce4 cb 12			rl d 
0ce6 cb 11		        rl c  
0ce8 17				rla 
0ce9 cb 13		        rl e  
0ceb cb 12			rl d 
0ced cb 11		        rl c  
0cef 17				rla 
0cf0 67			        ld h,a 
0cf1 cb 13		        rl e  
0cf3 cb 12			rl d 
0cf5 cb 11		        rl c  
0cf7 17				rla 
0cf8 a8			        xor b 
0cf9 cb 13		        rl e  
0cfb cb 12			rl d 
0cfd ac			        xor h 
0cfe a9			        xor c 
0cff aa			        xor d 
0d00 21 b3 eb		        ld hl,LFSRSeed+6 
0d03 11 b4 eb		        ld de,LFSRSeed+7 
0d06 01 07 00		        ld bc,7 
0d09 ed b8		        lddr 
0d0b 12			        ld (de),a 
0d0c c9			        ret 
0d0d			 
0d0d			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0d0d			 
0d0d			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0d0d			 
0d0d			 
0d0d			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0d0d			 
0d0d			prng16: 
0d0d			;Inputs: 
0d0d			;   (seed1) contains a 16-bit seed value 
0d0d			;   (seed2) contains a NON-ZERO 16-bit seed value 
0d0d			;Outputs: 
0d0d			;   HL is the result 
0d0d			;   BC is the result of the LCG, so not that great of quality 
0d0d			;   DE is preserved 
0d0d			;Destroys: 
0d0d			;   AF 
0d0d			;cycle: 4,294,901,760 (almost 4.3 billion) 
0d0d			;160cc 
0d0d			;26 bytes 
0d0d 2a a5 eb		    ld hl,(seed1) 
0d10 44			    ld b,h 
0d11 4d			    ld c,l 
0d12 29			    add hl,hl 
0d13 29			    add hl,hl 
0d14 2c			    inc l 
0d15 09			    add hl,bc 
0d16 22 a5 eb		    ld (seed1),hl 
0d19 2a a3 eb		    ld hl,(seed2) 
0d1c 29			    add hl,hl 
0d1d 9f			    sbc a,a 
0d1e e6 2d		    and %00101101 
0d20 ad			    xor l 
0d21 6f			    ld l,a 
0d22 22 a3 eb		    ld (seed2),hl 
0d25 09			    add hl,bc 
0d26 c9			    ret 
0d27			 
0d27			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0d27			 
0d27			rand32: 
0d27			;Inputs: 
0d27			;   (seed1_0) holds the lower 16 bits of the first seed 
0d27			;   (seed1_1) holds the upper 16 bits of the first seed 
0d27			;   (seed2_0) holds the lower 16 bits of the second seed 
0d27			;   (seed2_1) holds the upper 16 bits of the second seed 
0d27			;   **NOTE: seed2 must be non-zero 
0d27			;Outputs: 
0d27			;   HL is the result 
0d27			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0d27			;Destroys: 
0d27			;   AF 
0d27			;Tested and passes all CAcert tests 
0d27			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0d27			;it has a period of 18,446,744,069,414,584,320 
0d27			;roughly 18.4 quintillion. 
0d27			;LFSR taps: 0,2,6,7  = 11000101 
0d27			;291cc 
0d27			;seed1_0=$+1 
0d27			;    ld hl,12345 
0d27			;seed1_1=$+1 
0d27			;    ld de,6789 
0d27			;    ld b,h 
0d27			;    ld c,l 
0d27			;    add hl,hl \ rl e \ rl d 
0d27			;    add hl,hl \ rl e \ rl d 
0d27			;    inc l 
0d27			;    add hl,bc 
0d27			;    ld (seed1_0),hl 
0d27			;    ld hl,(seed1_1) 
0d27			;    adc hl,de 
0d27			;    ld (seed1_1),hl 
0d27			;    ex de,hl 
0d27			;seed2_0=$+1 
0d27			;    ld hl,9876 
0d27			;seed2_1=$+1 
0d27			;    ld bc,54321 
0d27			;    add hl,hl \ rl c \ rl b 
0d27			;    ld (seed2_1),bc 
0d27			;    sbc a,a 
0d27			;    and %11000101 
0d27			;    xor l 
0d27			;    ld l,a 
0d27			;    ld (seed2_0),hl 
0d27			;    ex de,hl 
0d27			;    add hl,bc 
0d27			;    ret 
0d27			; 
0d27			 
0d27			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0d27			; 20 bytes, 86 cycles (excluding ret) 
0d27			 
0d27			; returns   hl = pseudorandom number 
0d27			; corrupts   a 
0d27			 
0d27			; generates 16-bit pseudorandom numbers with a period of 65535 
0d27			; using the xorshift method: 
0d27			 
0d27			; hl ^= hl << 7 
0d27			; hl ^= hl >> 9 
0d27			; hl ^= hl << 8 
0d27			 
0d27			; some alternative shift triplets which also perform well are: 
0d27			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0d27			 
0d27			;  org 32768 
0d27			 
0d27			xrnd: 
0d27 2a a9 eb		  ld hl,(xrandc)       ; seed must not be 0 
0d2a 3e 00		  ld a,0 
0d2c bd			  cp l 
0d2d 20 02		  jr nz, .xrnd1 
0d2f 2e 01		  ld l, 1 
0d31			.xrnd1: 
0d31			 
0d31 7c			  ld a,h 
0d32 1f			  rra 
0d33 7d			  ld a,l 
0d34 1f			  rra 
0d35 ac			  xor h 
0d36 67			  ld h,a 
0d37 7d			  ld a,l 
0d38 1f			  rra 
0d39 7c			  ld a,h 
0d3a 1f			  rra 
0d3b ad			  xor l 
0d3c 6f			  ld l,a 
0d3d ac			  xor h 
0d3e 67			  ld h,a 
0d3f			 
0d3f 22 a9 eb		  ld (xrandc),hl 
0d42			 
0d42 c9			  ret 
0d43			;  
0d43			 
0d43			 
0d43			;;;; int maths 
0d43			 
0d43			; https://map.grauw.nl/articles/mult_div_shifts.php 
0d43			; Divide 16-bit values (with 16-bit result) 
0d43			; In: Divide BC by divider DE 
0d43			; Out: BC = result, HL = rest 
0d43			; 
0d43			Div16: 
0d43 21 00 00		    ld hl,0 
0d46 78			    ld a,b 
0d47 06 08		    ld b,8 
0d49			Div16_Loop1: 
0d49 17			    rla 
0d4a ed 6a		    adc hl,hl 
0d4c ed 52		    sbc hl,de 
0d4e 30 01		    jr nc,Div16_NoAdd1 
0d50 19			    add hl,de 
0d51			Div16_NoAdd1: 
0d51 10 f6		    djnz Div16_Loop1 
0d53 17			    rla 
0d54 2f			    cpl 
0d55 47			    ld b,a 
0d56 79			    ld a,c 
0d57 48			    ld c,b 
0d58 06 08		    ld b,8 
0d5a			Div16_Loop2: 
0d5a 17			    rla 
0d5b ed 6a		    adc hl,hl 
0d5d ed 52		    sbc hl,de 
0d5f 30 01		    jr nc,Div16_NoAdd2 
0d61 19			    add hl,de 
0d62			Div16_NoAdd2: 
0d62 10 f6		    djnz Div16_Loop2 
0d64 17			    rla 
0d65 2f			    cpl 
0d66 41			    ld b,c 
0d67 4f			    ld c,a 
0d68 c9			ret 
0d69			 
0d69			 
0d69			;http://z80-heaven.wikidot.com/math 
0d69			; 
0d69			;Inputs: 
0d69			;     DE and A are factors 
0d69			;Outputs: 
0d69			;     A is not changed 
0d69			;     B is 0 
0d69			;     C is not changed 
0d69			;     DE is not changed 
0d69			;     HL is the product 
0d69			;Time: 
0d69			;     342+6x 
0d69			; 
0d69			Mult16: 
0d69			 
0d69 06 08		     ld b,8          ;7           7 
0d6b 21 00 00		     ld hl,0         ;10         10 
0d6e 29			       add hl,hl     ;11*8       88 
0d6f 07			       rlca          ;4*8        32 
0d70 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0d72 19			         add hl,de   ;--         -- 
0d73 10 f9		       djnz $-5      ;13*7+8     99 
0d75 c9			ret 
0d76			 
0d76			; 
0d76			; Square root of 16-bit value 
0d76			; In:  HL = value 
0d76			; Out:  D = result (rounded down) 
0d76			; 
0d76			;Sqr16: 
0d76			;    ld de,#0040 
0d76			;    ld a,l 
0d76			;    ld l,h 
0d76			;    ld h,d 
0d76			;    or a 
0d76			;    ld b,8 
0d76			;Sqr16_Loop: 
0d76			;    sbc hl,de 
0d76			;    jr nc,Sqr16_Skip 
0d76			;    add hl,de 
0d76			;Sqr16_Skip: 
0d76			;    ccf 
0d76			;    rl d 
0d76			;    add a,a 
0d76			;    adc hl,hl 
0d76			;    add a,a 
0d76			;    adc hl,hl 
0d76			;    djnz Sqr16_Loop 
0d76			;    ret 
0d76			; 
0d76			; 
0d76			; Divide 8-bit values 
0d76			; In: Divide E by divider C 
0d76			; Out: A = result, B = rest 
0d76			; 
0d76			Div8: 
0d76 af			    xor a 
0d77 06 08		    ld b,8 
0d79			Div8_Loop: 
0d79 cb 13		    rl e 
0d7b 17			    rla 
0d7c 91			    sub c 
0d7d 30 01		    jr nc,Div8_NoAdd 
0d7f 81			    add a,c 
0d80			Div8_NoAdd: 
0d80 10 f7		    djnz Div8_Loop 
0d82 47			    ld b,a 
0d83 7b			    ld a,e 
0d84 17			    rla 
0d85 2f			    cpl 
0d86 c9			    ret 
0d87			 
0d87			; 
0d87			; Multiply 8-bit value with a 16-bit value (unrolled) 
0d87			; In: Multiply A with DE 
0d87			; Out: HL = result 
0d87			; 
0d87			Mult12U: 
0d87 2e 00		    ld l,0 
0d89 87			    add a,a 
0d8a 30 01		    jr nc,Mult12U_NoAdd0 
0d8c 19			    add hl,de 
0d8d			Mult12U_NoAdd0: 
0d8d 29			    add hl,hl 
0d8e 87			    add a,a 
0d8f 30 01		    jr nc,Mult12U_NoAdd1 
0d91 19			    add hl,de 
0d92			Mult12U_NoAdd1: 
0d92 29			    add hl,hl 
0d93 87			    add a,a 
0d94 30 01		    jr nc,Mult12U_NoAdd2 
0d96 19			    add hl,de 
0d97			Mult12U_NoAdd2: 
0d97 29			    add hl,hl 
0d98 87			    add a,a 
0d99 30 01		    jr nc,Mult12U_NoAdd3 
0d9b 19			    add hl,de 
0d9c			Mult12U_NoAdd3: 
0d9c 29			    add hl,hl 
0d9d 87			    add a,a 
0d9e 30 01		    jr nc,Mult12U_NoAdd4 
0da0 19			    add hl,de 
0da1			Mult12U_NoAdd4: 
0da1 29			    add hl,hl 
0da2 87			    add a,a 
0da3 30 01		    jr nc,Mult12U_NoAdd5 
0da5 19			    add hl,de 
0da6			Mult12U_NoAdd5: 
0da6 29			    add hl,hl 
0da7 87			    add a,a 
0da8 30 01		    jr nc,Mult12U_NoAdd6 
0daa 19			    add hl,de 
0dab			Mult12U_NoAdd6: 
0dab 29			    add hl,hl 
0dac 87			    add a,a 
0dad d0			    ret nc 
0dae 19			    add hl,de 
0daf c9			    ret 
0db0			 
0db0			; 
0db0			; Multiply 8-bit value with a 16-bit value (right rotating) 
0db0			; In: Multiply A with DE 
0db0			;      Put lowest value in A for most efficient calculation 
0db0			; Out: HL = result 
0db0			; 
0db0			Mult12R: 
0db0 21 00 00		    ld hl,0 
0db3			Mult12R_Loop: 
0db3 cb 3f		    srl a 
0db5 30 01		    jr nc,Mult12R_NoAdd 
0db7 19			    add hl,de 
0db8			Mult12R_NoAdd: 
0db8 cb 23		    sla e 
0dba cb 12		    rl d 
0dbc b7			    or a 
0dbd c2 b3 0d		    jp nz,Mult12R_Loop 
0dc0 c9			    ret 
0dc1			 
0dc1			; 
0dc1			; Multiply 16-bit values (with 32-bit result) 
0dc1			; In: Multiply BC with DE 
0dc1			; Out: BCHL = result 
0dc1			; 
0dc1			Mult32: 
0dc1 79			    ld a,c 
0dc2 48			    ld c,b 
0dc3 21 00 00		    ld hl,0 
0dc6 06 10		    ld b,16 
0dc8			Mult32_Loop: 
0dc8 29			    add hl,hl 
0dc9 17			    rla 
0dca cb 11		    rl c 
0dcc 30 07		    jr nc,Mult32_NoAdd 
0dce 19			    add hl,de 
0dcf ce 00		    adc a,0 
0dd1 d2 d5 0d		    jp nc,Mult32_NoAdd 
0dd4 0c			    inc c 
0dd5			Mult32_NoAdd: 
0dd5 10 f1		    djnz Mult32_Loop 
0dd7 41			    ld b,c 
0dd8 4f			    ld c,a 
0dd9 c9			    ret 
0dda			 
0dda			 
0dda			 
0dda			; 
0dda			; Multiply 8-bit values 
0dda			; In:  Multiply H with E 
0dda			; Out: HL = result 
0dda			; 
0dda			Mult8: 
0dda 16 00		    ld d,0 
0ddc 6a			    ld l,d 
0ddd 06 08		    ld b,8 
0ddf			Mult8_Loop: 
0ddf 29			    add hl,hl 
0de0 30 01		    jr nc,Mult8_NoAdd 
0de2 19			    add hl,de 
0de3			Mult8_NoAdd: 
0de3 10 fa		    djnz Mult8_Loop 
0de5 c9			    ret 
0de6			 
0de6			 
0de6			 
0de6			 
0de6			 
0de6			 
0de6			 
0de6			 
0de6			;;http://z80-heaven.wikidot.com/math 
0de6			;;This divides DE by BC, storing the result in DE, remainder in HL 
0de6			; 
0de6			;DE_Div_BC:          ;1281-2x, x is at most 16 
0de6			;     ld a,16        ;7 
0de6			;     ld hl,0        ;10 
0de6			;     jp $+5         ;10 
0de6			;.DivLoop: 
0de6			;       add hl,bc    ;-- 
0de6			;       dec a        ;64 
0de6			;       jr z,.DivLoopEnd        ;86 
0de6			; 
0de6			;       sla e        ;128 
0de6			;       rl d         ;128 
0de6			;       adc hl,hl    ;240 
0de6			;       sbc hl,bc    ;240 
0de6			;       jr nc,.DivLoop ;23|21 
0de6			;       inc e        ;-- 
0de6			;       jp .DivLoop+1 
0de6			; 
0de6			;.DivLoopEnd: 
0de6			 
0de6			;HL_Div_C: 
0de6			;Inputs: 
0de6			;     HL is the numerator 
0de6			;     C is the denominator 
0de6			;Outputs: 
0de6			;     A is the remainder 
0de6			;     B is 0 
0de6			;     C is not changed 
0de6			;     DE is not changed 
0de6			;     HL is the quotient 
0de6			; 
0de6			;       ld b,16 
0de6			;       xor a 
0de6			;         add hl,hl 
0de6			;         rla 
0de6			;         cp c 
0de6			;         jr c,$+4 
0de6			;           inc l 
0de6			;           sub c 
0de6			;         djnz $-7 
0de6			 
0de6			; https://plutiedev.com/z80-add-8bit-to-16bit 
0de6			 
0de6			addatohl: 
0de6 85			    add   a, l    ; A = A+L 
0de7 6f			    ld    l, a    ; L = A+L 
0de8 8c			    adc   a, h    ; A = A+L+H+carry 
0de9 95			    sub   l       ; A = H+carry 
0dea 67			    ld    h, a    ; H = H+carry 
0deb c9			ret 
0dec			 
0dec			addatode: 
0dec 83			    add   a, e    ; A = A+L 
0ded 5f			    ld    e, a    ; L = A+L 
0dee 8a			    adc   a, d    ; A = A+L+H+carry 
0def 93			    sub   e       ; A = H+carry 
0df0 57			    ld    d, a    ; H = H+carry 
0df1 c9			ret 
0df2			 
0df2			 
0df2			addatobc: 
0df2 81			    add   a, c    ; A = A+L 
0df3 4f			    ld    c, a    ; L = A+L 
0df4 88			    adc   a, b    ; A = A+L+H+carry 
0df5 91			    sub   c       ; A = H+carry 
0df6 47			    ld    b, a    ; H = H+carry 
0df7 c9			ret 
0df8			 
0df8			subafromhl: 
0df8			   ; If A=0 do nothing 
0df8			    ; Otherwise flip A's sign. Since 
0df8			    ; the upper byte becomes -1, also 
0df8			    ; substract 1 from H. 
0df8 ed 44		    neg 
0dfa ca 03 0e		    jp    z, Skip 
0dfd 25			    dec   h 
0dfe			     
0dfe			    ; Now add the low byte as usual 
0dfe			    ; Two's complement takes care of 
0dfe			    ; ensuring the result is correct 
0dfe 85			    add   a, l 
0dff 6f			    ld    l, a 
0e00 8c			    adc   a, h 
0e01 95			    sub   l 
0e02 67			    ld    h, a 
0e03			Skip: 
0e03 c9				ret 
0e04			 
0e04			 
0e04			; compare hl and de 
0e04			; returns:  
0e04			; if hl = de, z=1, s=0, c0=0 
0e04			; if hl > de, z=0, s=0, c=0 
0e04			; if hl < de, z=0, s=1, c=1 
0e04			cmp16:	 
0e04 b7				or a 
0e05 ed 52			sbc hl,de 
0e07 e0				ret po 
0e08 7c				ld a,h 
0e09 1f				rra 
0e0a ee 40			xor 01000000B 
0e0c 37				scf 
0e0d 8f				adc a,a 
0e0e c9				ret 
0e0f			 
0e0f			 
0e0f			; test if hl contains zero   - A is destroyed 
0e0f			 
0e0f			ishlzero:    
0e0f b7				or a     ; reset flags 
0e10 7c				ld a, h 
0e11 b5				or l        	 
0e12			 
0e12 c9				ret 
0e13			 
0e13			 
0e13			 
0e13			 
0e13			if FORTH_ENABLE_FLOATMATH 
0e13			;include "float/bbcmath.z80" 
0e13			include "float/lpfpcalc.asm" 
0e13			endif 
0e13			 
0e13			 
0e13			; eof 
0e13			 
# End of file firmware_maths.asm
0e13			include "firmware_strings.asm"   ; string handling  
0e13			 
0e13			 
0e13			; TODO string len 
0e13			; input text string, end on cr with zero term 
0e13			; a offset into frame buffer to start prompt 
0e13			; d is max length 
0e13			; e is display size TODO 
0e13			; c is current cursor position 
0e13			; hl is ptr to where string will be stored and edited directly 
0e13			 
0e13			 
0e13			; TODO check limit of buffer for new inserts 
0e13			; TODO check insert does not push beyond buffer 
0e13			; TODO scroll in a limited display area 
0e13			; TODO scroll whole screen on page wrap 
0e13			 
0e13			 
0e13			; TODO use LCD cursor? 
0e13			 
0e13			EDIT_V1: equ 0 
0e13			EDIT_V2: equ 1 
0e13			 
0e13			 
0e13			 
0e13			if EDIT_V2 
0e13			input_str: 
0e13			 
0e13 32 64 ee			    	ld (input_at_pos),a      ; save display position to start 
0e16			;		ld (input_at_cursor),a	; save draw pos of cursor relative to start 
0e16 22 67 ee				ld (input_start), hl     ; save ptr to buffer 
0e19			;		ld a, c 
0e19			;		call addatohl 
0e19			;		ld (input_ptr), hl     ; save ptr to point under the cursor 
0e19 7a					ld a,d 
0e1a 32 66 ee			        ld (input_size), a       ; save length of input area 
0e1d 79					ld a, c 
0e1e 32 55 ee				ld (input_cursor),a      ; init cursor start position relative to start of string 
0e21 7b					ld a,e 
0e22 32 65 ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0e25			 
0e25			 
0e25					; add a trailing space to make screen refresh nicer 
0e25			 
0e25					;ld hl, (input_start) 
0e25					;push hl 
0e25					;ld a, 0 
0e25					;call strlent 
0e25					;ld a, l 
0e25					;pop hl 
0e25					;call addatohl 
0e25					;dec hl 
0e25					;ld a, ' ' 
0e25					;ld (hl), a 
0e25					;inc hl 
0e25					;ld (hl), a 
0e25					;inc hl 
0e25					;ld a, 0 
0e25					;ld (hl), a 
0e25			 
0e25			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0e25					; init cursor shape if not set by the cin routines 
0e25 21 c1 eb				ld hl, cursor_shape 
0e28			if BASE_KEV 
0e28					ld a, 255 
0e28			else 
0e28 3e 23				ld a, '#' 
0e2a			endif 
0e2a 77					ld (hl), a 
0e2b 23					inc hl 
0e2c 3e 00				ld a, 0 
0e2e 77					ld (hl), a 
0e2f			 
0e2f 3e 09				ld a, CUR_BLINK_RATE 
0e31 32 60 ee				ld (input_cur_flash), a 
0e34 3e 01				ld a, 1 
0e36 32 5f ee				ld (input_cur_onoff),a 
0e39			.inmain:	 
0e39			 
0e39 cd b2 0f				call input_disp_ref 
0e3c			 
0e3c					; save current length of string 
0e3c			 
0e3c 2a 67 ee				ld hl, (input_start) 
0e3f 3e 00				ld a, 0 
0e41 cd a8 11				call strlent 
0e44 7d					ld a,l 
0e45 32 5a ee				ld (input_len), a 
0e48			 
0e48					;call input_disp_oncur 
0e48			 
0e48					; display current state of input buffer 
0e48			 
0e48					; clean any backspace chars 
0e48			 
0e48 3e 20				ld a, " " 
0e4a 32 c1 e2				ld (scratch),a 
0e4d 3e 00				ld a, 0 
0e4f 32 c2 e2				ld (scratch+1),a 
0e52 3a 64 ee				ld a,(input_at_pos) 
0e55 85					add l 
0e56 11 c1 e2				ld de, scratch 
0e59 cd cc 0b				call str_at_display 
0e5c			 
0e5c					; pause 1ms 
0e5c			 
0e5c 3e 01				ld a, 1 
0e5e cd d6 0a				call aDelayInMS 
0e61			 
0e61			; display cursor if visible on this cycle 
0e61			 
0e61					; dec flash counter 
0e61 3a 60 ee				ld a, (input_cur_flash) 
0e64 3d					dec a 
0e65 32 60 ee				ld (input_cur_flash), a 
0e68 fe 00				cp 0 
0e6a 20 0d				jr nz, .inochgstate 
0e6c			 
0e6c			 
0e6c					; reset on change of state 
0e6c 3e 09				ld a, CUR_BLINK_RATE 
0e6e 32 60 ee				ld (input_cur_flash), a 
0e71			 
0e71					; change state 
0e71 3a 5f ee				ld a,(input_cur_onoff) 
0e74 ed 44				neg 
0e76 32 5f ee				ld (input_cur_onoff),a 
0e79			 
0e79			 
0e79			 
0e79			 
0e79					; TODO is cursor visible? 
0e79					; TODO if so then over write the char at curspos pos with the cursor shape 
0e79			 
0e79								 
0e79			 
0e79			.inochgstate: 
0e79 3a 5f ee				ld a,(input_cur_onoff) 
0e7c fe ff				cp 255 
0e7e 28 0e				jr z, .skipcursor 
0e80 3a 64 ee				ld a, (input_at_pos) 
0e83 47					ld b, a 
0e84 3a 55 ee				ld a, (input_cursor) 
0e87 80					add b 
0e88 11 c1 eb				ld de, cursor_shape 
0e8b					 
0e8b cd cc 0b				call str_at_display 
0e8e			 
0e8e			.skipcursor: 
0e8e				if DEBUG_INPUTV2 
0e8e			 
0e8e 3a 64 ee				ld a,(input_at_pos) 
0e91 21 ad eb				ld hl, LFSRSeed 
0e94 cd 40 10				call hexout 
0e97 3a 55 ee				ld a, (input_cursor) 
0e9a 21 af eb				ld hl, LFSRSeed+2 
0e9d cd 40 10				call hexout 
0ea0 3a 66 ee				ld a,(input_size) 
0ea3 21 b1 eb				ld hl, LFSRSeed+4 
0ea6 cd 40 10				call hexout 
0ea9			 
0ea9 3a 5f ee				ld a,(input_cur_onoff) 
0eac 21 b3 eb				ld hl, LFSRSeed+6 
0eaf cd 40 10				call hexout 
0eb2			 
0eb2 3a 60 ee				ld a,(input_cur_flash) 
0eb5 21 b5 eb				ld hl, LFSRSeed+8 
0eb8 cd 40 10				call hexout 
0ebb			 
0ebb 3a 5a ee				ld a,(input_len) 
0ebe 21 b7 eb				ld hl, LFSRSeed+10 
0ec1 cd 40 10				call hexout 
0ec4 21 b9 eb				ld hl, LFSRSeed+12 
0ec7 3e 00				ld a, 0 
0ec9 77					ld (hl),a 
0eca 3e 78				ld a, display_row_4 
0ecc 11 ad eb				ld de, LFSRSeed 
0ecf cd cc 0b				call str_at_display 
0ed2				endif 
0ed2 cd dc 0b				call update_display 
0ed5			 
0ed5					; TODO keyboard processing 
0ed5			 
0ed5			if BASE_CPM 
0ed5 cd 7f 65				call cin_wait 
0ed8			else 
0ed8					call cin    ; _wait 
0ed8			endif 
0ed8 fe 00				cp 0 
0eda ca 39 0e				jp z, .inmain 
0edd			 
0edd fe 0b				cp KEY_LEFT    ; cursor left 
0edf ca a4 0f				jp z, input_left 
0ee2				 
0ee2 fe 0c				cp KEY_RIGHT      ; cursor right 
0ee4 ca ab 0f				jp z, input_right 
0ee7			 
0ee7 fe 0d				cp KEY_CR 
0ee9 c8					ret z 
0eea			 
0eea fe 08				cp KEY_BS 
0eec ca 19 10				jp z, input_delchar 
0eef			 
0eef fe 06				cp KEY_NEXTWORD 
0ef1 ca 25 0f				jp z, input_nxtword 
0ef4			 
0ef4 fe 07				cp KEY_PREVWORD 
0ef6 ca 4c 0f				jp z, input_prvword 
0ef9			 
0ef9 fe 0e				cp KEY_HOME    ; jump to start of line 
0efb 20 08				jr nz, .ikh 
0efd 3e 00				ld a, 0 
0eff 32 55 ee				ld (input_cursor), a 
0f02 ca 39 0e				jp z, .inmain 
0f05			.ikh: 
0f05			 
0f05 fe 0f				cp KEY_END     ; jump to end of line 
0f07 20 09				jr nz, .ike 
0f09 3a 5a ee				ld a, (input_len) 
0f0c 32 55 ee				ld (input_cursor),a 
0f0f ca 39 0e				jp z, .inmain 
0f12			.ike: 
0f12 fe 05			        cp KEY_UP      ; recall last command 
0f14 20 0c				jr nz, .irec 
0f16			; TODO next word 
0f16			; TODO prev word 
0f16			;  
0f16			; 
0f16 21 c1 e2			ld hl, scratch 
0f19 11 e7 e6			ld de, os_last_cmd 
0f1c cd 36 10			call strcpy 
0f1f ca 39 0e				jp z, .inmain 
0f22			.irec: 
0f22			;		jr .instr1 
0f22			 
0f22			 
0f22					; if no special key then insert as a char 
0f22			 
0f22 c3 eb 0f				jp input_inschr 
0f25			 
0f25				 
0f25			input_nxtword: 
0f25				; jump to start next word after the cursor 
0f25			 
0f25			.insknwn:	 
0f25 cd e1 0f				call input_curptr	 
0f28 7e					ld a,(hl)	 
0f29 fe 00				cp 0 
0f2b ca 39 0e				jp z, .inmain    ; end of string 
0f2e			 
0f2e			; if we are on a word, then move off of it 
0f2e			 
0f2e fe 20				cp ' ' 
0f30 28 06				jr z, .inspace     ; we are on space so eat the space until we hit non-space 
0f32 21 55 ee				ld hl, input_cursor 
0f35 34					inc (hl) 
0f36 18 ed				jr .insknwn 
0f38			 
0f38			.inspace: 
0f38			 
0f38 cd e1 0f				call input_curptr	 
0f3b 7e					ld a,(hl)	 
0f3c fe 00				cp 0 
0f3e ca 39 0e				jp z, .inmain    ; end of string 
0f41			 
0f41			; if we are on a word, then move off of it 
0f41			 
0f41 fe 20				cp ' ' 
0f43 c2 39 0e				jp nz, .inmain     ; we are on non space so at next word 
0f46 21 55 ee				ld hl, input_cursor 
0f49 34					inc (hl) 
0f4a 18 ec				jr .inspace 
0f4c			 
0f4c			 
0f4c			 
0f4c			 
0f4c			input_prvword: 
0f4c				; jump to the start of previous word before the cursor 
0f4c			 
0f4c			; where are we to start with currently? 
0f4c			 
0f4c cd e1 0f				call input_curptr	 
0f4f 7e					ld a, (hl) 
0f50 fe 20				cp ' ' 
0f52 28 1d				jr z, .inspacep     ; we are on space so eat the space until we hit non-space 
0f54			 
0f54			 
0f54			 
0f54			.inskpwn:	 
0f54 3a 55 ee				ld a,(input_cursor) 
0f57 fe 00				cp 0 
0f59 ca 39 0e				jp z, .inmain    ; start of string 
0f5c			 
0f5c			;if we are on a word, then move off of it 
0f5c			 
0f5c cd e1 0f				call input_curptr	 
0f5f 7e					ld a, (hl) 
0f60 fe 20				cp ' ' 
0f62 28 06				jr z, .iwstart     ; we are on space so eat the space until we hit non-space 
0f64					;jp z, .inmain    ; start of string 
0f64 21 55 ee				ld hl, input_cursor 
0f67 35					dec (hl) 
0f68 18 ea				jr .inskpwn 
0f6a			.iwstart: 
0f6a 21 55 ee				ld hl, input_cursor 
0f6d 34					inc (hl) 
0f6e c3 39 0e				jp .inmain 
0f71					 
0f71			 
0f71			.inspacep: 
0f71			 
0f71					;jp .inmain    ; start of string 
0f71			 
0f71			 
0f71			 
0f71 3a 55 ee				ld a,(input_cursor) 
0f74 fe 00				cp 0 
0f76 ca 39 0e				jp z, .inmain    ; start of string 
0f79			 
0f79			; if we are on a word, then move off of it 
0f79			 
0f79 cd e1 0f				call input_curptr	 
0f7c 7e					ld a, (hl) 
0f7d fe 20				cp ' ' 
0f7f c2 88 0f				jp nz, .incharp     ; we are on non space so at end of prev word 
0f82 21 55 ee				ld hl, input_cursor 
0f85 35					dec (hl) 
0f86 18 e9				jr .inspacep 
0f88			 
0f88			 
0f88			.incharp:	 
0f88					; eat the word to get to the start 
0f88 3a 55 ee				ld a,(input_cursor) 
0f8b fe 00				cp 0 
0f8d ca 39 0e				jp z, .inmain    ; start of string 
0f90			 
0f90			; if we are on a word, then move off of it 
0f90			 
0f90 cd e1 0f				call input_curptr	 
0f93 7e					ld a, (hl) 
0f94 fe 20				cp ' ' 
0f96 28 06				jr z, .ipwordst     ; we are on space so eat the space until we hit non-space 
0f98 21 55 ee				ld hl, input_cursor 
0f9b 35					dec (hl) 
0f9c 18 ea				jr .incharp 
0f9e			.ipwordst: 
0f9e					; at space before the prev word so reposition over it 
0f9e 21 55 ee				ld hl, input_cursor 
0fa1 34					inc (hl) 
0fa2 18 b0				jr .inskpwn 
0fa4					 
0fa4			 
0fa4			 
0fa4			input_left: 
0fa4				; move cursor left 
0fa4 21 55 ee			ld hl, input_cursor 
0fa7 35				dec (hl) 
0fa8			;	cp 0 
0fa8			;	jp z, .inmain    ; ignore left as at the start of the string 
0fa8 c3 39 0e			jp .inmain 
0fab			 
0fab			input_right: 
0fab				; move cursor right 
0fab				 
0fab				;ld a, (input_size) 
0fab				;ld b, a 
0fab 21 55 ee			ld hl, input_cursor 
0fae 34				inc (hl) 
0faf				;dec b 
0faf				;cp 0 
0faf				;jp z, .inmain   ; ignore as at end of the string buffer 
0faf				;ld a, b 
0faf				;inc a 
0faf				;ld (input_cursor), a 
0faf c3 39 0e			jp .inmain 
0fb2			 
0fb2			 
0fb2			 
0fb2			input_disp_ref: 
0fb2				; display the text from start of buffer (ie full refresh) 
0fb2 3a 64 ee			ld a, (input_at_pos) 
0fb5 2a 67 ee			ld hl,(input_start) 
0fb8 eb				ex de, hl 
0fb9 cd cc 0b			call str_at_display  
0fbc c9				ret 
0fbd			input_disp_oncur: 
0fbd				; display the text from cursor position to end of buffer 
0fbd				; TODO position start of string at cursor position on screen 
0fbd				; TODO draw from that point on 
0fbd 3a 55 ee			ld a, (input_cursor) 
0fc0 47				ld b, a 
0fc1 3a 64 ee			ld a, (input_at_pos) 
0fc4 80				add b 
0fc5 48				ld c, b     ; save a 
0fc6 78				ld a, b     ; inc string start for cursor 
0fc7 2a 67 ee			ld hl,(input_start) 
0fca cd e6 0d			call addatohl 
0fcd eb				ex de, hl 
0fce 79				ld a, c 
0fcf cd cc 0b			call str_at_display  
0fd2 c9				ret 
0fd3			 
0fd3			input_nxtw: 
0fd3				; Find next word 
0fd3 c9				ret 
0fd4			 
0fd4			input_prvw: 
0fd4				; Find previous word 
0fd4 c9				ret 
0fd5			 
0fd5			input_lenrem:   
0fd5				; Calculate the length of string remaining from current cursor 
0fd5				; position to end of buffer (exc null term) 
0fd5				 
0fd5 3a 55 ee			ld a, (input_cursor) 
0fd8 4f				ld c, a 
0fd9 3a 66 ee			ld a, (input_size) 
0fdc 91				sub c 
0fdd 06 00			ld b, 0 
0fdf 0d				dec c 
0fe0 c9				ret	 
0fe1			 
0fe1			input_curptr: 
0fe1				; calc address of the character under the cursor 
0fe1				 
0fe1 2a 67 ee			ld hl, (input_start) 
0fe4 3a 55 ee			ld a, (input_cursor) 
0fe7 cd e6 0d			call addatohl 
0fea c9				ret 
0feb			 
0feb			input_inschr: 
0feb				; Insert char at cursor position 
0feb f5				push af   ; save char 
0fec				;call input_lenrem    ; get bc length of remaining string 
0fec			 
0fec				 
0fec cd e1 0f			call input_curptr 
0fef			;	ld hl, (input_start) 
0fef			;	ld a, (input_cursor) 
0fef			;	call addatohl 
0fef				;push hl   ; save to come back to 
0fef			 
0fef				; shift everything up one to end of buffer 
0fef			 
0fef				;push hl 
0fef				;dec de 
0fef				;inc de 
0fef			;	ldir 
0fef				 
0fef				;pop hl 
0fef			 
0fef				; are we adding to the end of line? 
0fef			 
0fef 3a 55 ee			ld a, (input_cursor) 
0ff2 47				ld b, a 
0ff3 3a 5a ee			ld a, (input_len) 
0ff6 b8				cp b 
0ff7 20 09			jr nz, .insmid   ; no, insert in middle of text 
0ff9			 
0ff9				; tack on the end of the line 
0ff9 f1				pop af 
0ffa 77				ld (hl), a   ; save new char 
0ffb 23				inc hl 
0ffc 3e 00			ld a, 0 
0ffe 77				ld (hl), a 
0fff c3 ab 0f			jp input_right 
1002				 
1002			.insmid: 
1002				; hl has insertion point so move everything up one to allow for insertion 
1002				;call input_shiftright 
1002 f1				pop af 
1003			 
1003			.shufinsmid: 
1003 47				ld b, a     ; b contains new char, c prev char at this position  
1004 7e				ld a, (hl) 
1005			 
1005 fe 00			cp 0    ; at end of string need to then dump new char and add term 
1007 28 07			jr z, .endinsmid 
1009 4f				ld c, a 
100a 78				ld a, b 
100b 77				ld (hl), a 
100c 23				inc hl 
100d 79				ld a, c 
100e 18 f3			jr .shufinsmid 
1010				 
1010			 
1010			 
1010			 
1010			.endinsmid: 
1010 78				ld a, b 
1011 77				ld (hl), a 
1012 23				inc hl 
1013 3e 00			ld a, 0 
1015 77				ld (hl), a 
1016			 
1016			 
1016			;	ld (hl), a   ; save new char 
1016			 
1016 c3 ab 0f			jp input_right 
1019			 
1019			;input_shiftright: 
1019			;	; shift text right at cursor, hl has shift start 
1019			;	push hl 
1019			;	push de 
1019			;	push bc 
1019			; 
1019			; 
1019			;	; move to end of string past zero term 
1019			;	ld hl,(input_start) 
1019			;	ld a, (input_len) 
1019			;	call addatohl 
1019			;	inc hl 
1019			;;	inc hl 
1019			;;	inc hl 
1019			;	ld a, 0 
1019			;	ld (hl), a 
1019			;;	dec hl 
1019			;	 
1019			;;	ld (hl), a 
1019			;;	dec hl 
1019			; 
1019			;	push hl 
1019			;	pop de 
1019			;	inc de 
1019			;	 
1019			; 
1019			;;	ld hl,(input_start) 
1019			;;	ld a, (input_cursor) 
1019			;;	call addatohl 
1019			; 
1019			; 
1019			;	; calc how many bytes from cursor pos to end of string we need to shift 
1019			;	call input_lenrem    ; get bc length of remaining string 
1019			;	;ld a, (input_cursor) 
1019			;	;ld c, a 
1019			;	ld a, (input_len) 
1019			;	cp 2 
1019			;	jr z, .iskipzero	 
1019			;	;sub c 
1019			;	;inc a 
1019			;	;ld c, a 
1019			;	;ld b, 0 
1019			;	inc c 
1019			;	inc c 
1019			;	; move data 
1019			;	lddr 
1019			;.iskipzero: 
1019			; 
1019			;	pop bc 
1019			;	pop de 
1019			;	pop hl 
1019			;	ret	 
1019			 
1019			input_delchar: 
1019				; Delete char at cursor position 
1019 cd d5 0f			call input_lenrem    ; get bc length of remaining string 
101c 2a 67 ee			ld hl, (input_start) 
101f 3a 55 ee			ld a, (input_cursor) 
1022 cd e6 0d			call addatohl 
1025			 
1025 e5				push hl 
1026 d1				pop de 
1027 1b				dec de 
1028			 
1028			.dl:	 
1028 ed a0			ldi  
102a 7e				ld a, (hl) 
102b fe 00			cp 0 
102d 28 02			jr z, .dldone 
102f 18 f7			jr .dl 
1031			.dldone: 
1031 ed a0			ldi 
1033			 
1033 c3 a4 0f			jp input_left 
1036			 
1036			 
1036			endif 
1036			 
1036			 
1036			 
1036			if EDIT_V1 
1036			input_str: 
1036			 
1036				    	ld (input_at_pos),a      ; save display position to start 
1036					add c 
1036					ld (input_at_cursor),a	; save draw pos of cursor 
1036					ld (input_start), hl     ; save ptr to buffer 
1036					ld a, c 
1036					call addatohl 
1036					ld (input_ptr), hl     ; save ptr to point under the cursor 
1036					ld a,d 
1036				        ld (input_size), a       ; save length of input area 
1036					ld a, c 
1036					ld (input_cursor),a      ; init cursor start position  
1036					ld a,e 
1036				        ld (input_display_size), a       ; save length of input area that is displayed TODO 
1036					 
1036					 
1036			 
1036			;		ld a,(input_ptr) 
1036			;		ld (input_under_cursor),a 	; save what is under the cursor 
1036			 
1036			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
1036					; init cursor shape if not set by the cin routines 
1036					ld hl, cursor_shape 
1036			if BASE_KEV 
1036					ld a, 255 
1036			else 
1036					ld a, '#' 
1036			endif 
1036					ld (hl), a 
1036					inc hl 
1036					ld a, 0 
1036					ld (hl), a 
1036			 
1036					ld a, CUR_BLINK_RATE 
1036					ld (input_cur_flash), a 
1036					ld a, 1 
1036					ld (input_cur_onoff),a 
1036			 
1036			;	if DEBUG_INPUT 
1036			;		push af 
1036			;		ld a, 'I' 
1036			;		ld (debug_mark),a 
1036			;		pop af 
1036			;		CALLMONITOR 
1036			;	endif 
1036			.is1:		; main entry loop 
1036			 
1036			 
1036			 
1036					; pause 1ms 
1036			 
1036					ld a, 1 
1036					call aDelayInMS 
1036			 
1036					; dec flash counter 
1036					ld a, (input_cur_flash) 
1036					dec a 
1036					ld (input_cur_flash), a 
1036					cp 0 
1036					jr nz, .nochgstate 
1036			 
1036			 
1036					; change state 
1036					ld a,(input_cur_onoff) 
1036					neg 
1036					ld (input_cur_onoff),a 
1036			 
1036			 
1036					; reset on change of state 
1036					ld a, CUR_BLINK_RATE 
1036					ld (input_cur_flash), a 
1036			 
1036			.nochgstate: 
1036					 
1036					 
1036			 
1036					; display cursor  
1036			 
1036			;		ld hl, (input_start) 
1036			;		ld a, (input_cursor) 
1036			;		call addatohl 
1036			 
1036					; get char under cursor and replace with cursor 
1036			ld hl, (input_ptr) 
1036			;		ld a, (hl) 
1036			;		ld (input_under_cursor),a 
1036			;		ld a, '_' 
1036			;		ld (hl), a 
1036			 
1036					; display string 
1036			 
1036					ld de, (input_start) 
1036					ld a, (input_at_pos) 
1036					call str_at_display 
1036			;	        call update_display 
1036			 
1036					; find place to put the cursor 
1036			;		add h 
1036			;		ld l, display_row_1 
1036			;		sub l 
1036			; (input_at_pos) 
1036					;ld c, a 
1036			;		ld a, (input_cursor) 
1036			;		ld l, (input_at_pos) 
1036			;		;ld b, h 
1036			;		add l 
1036			;		ld (input_at_cursor),a 
1036					;ld l,h 
1036			 
1036			;		ld h, 0 
1036			;		ld l,(input_at_pos) 
1036			;		ld a, (input_cursor) 
1036			;		call addatohl 
1036			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
1036			;		call subafromhl 
1036			;		ld a,l 
1036			;		ld (input_at_cursor), a 
1036			 
1036				if DEBUG_INPUT 
1036					ld a, (hardware_diag) 
1036					cp 0 
1036					jr z, .skip_input_diag 
1036			 
1036					ld a,(input_at_pos) 
1036					ld hl, LFSRSeed 
1036					call hexout 
1036					ld a, (input_cursor) 
1036					ld hl, LFSRSeed+2 
1036					call hexout 
1036					ld a,(input_at_cursor) 
1036					ld hl, LFSRSeed+4 
1036					call hexout 
1036			 
1036					ld a,(input_cur_onoff) 
1036					ld hl, LFSRSeed+6 
1036					call hexout 
1036			 
1036					ld a,(input_cur_flash) 
1036					ld hl, LFSRSeed+8 
1036					call hexout 
1036			 
1036					ld a,(input_len) 
1036					ld hl, LFSRSeed+10 
1036					call hexout 
1036					ld hl, LFSRSeed+12 
1036					ld a, 0 
1036					ld (hl),a 
1036					ld a, display_row_4 
1036					ld de, LFSRSeed 
1036					call str_at_display 
1036					.skip_input_diag: 
1036				endif 
1036			 
1036					; decide on if we are showing the cursor this time round 
1036			 
1036					ld a, (input_cur_onoff) 
1036					cp 255 
1036					jr z, .skipcur 
1036			 
1036			 
1036					ld a,(input_at_cursor) 
1036					ld de, cursor_shape 
1036					call str_at_display 
1036			 
1036					; save length of current input string 
1036					ld hl, (input_start) 
1036					ld a, 0 
1036					call strlent 
1036					ld a,l 
1036					ld (input_len),a 
1036			 
1036			.skipcur: 
1036			 
1036				        call update_display 
1036					 
1036			 
1036			 
1036					; wait 
1036				 
1036					; TODO loop without wait to flash the cursor and char under cursor	 
1036					call cin    ; _wait 
1036			 
1036					cp 0 
1036					jp z, .is1 
1036			 
1036					; get ptr to char to input into 
1036			 
1036					ld c,a 
1036					ld hl, (input_start) 
1036					ld a, (input_cursor) 
1036					call addatohl 
1036					ld (input_ptr), hl 
1036					ld a,c 
1036			 
1036					; replace char under cursor 
1036			 
1036			;		ld hl, (input_ptr) 
1036			;		ld a, (input_under_cursor) 	; get what is under the cursor 
1036			;		ld (hl), a 
1036			 
1036			;	if DEBUG_INPUT 
1036			;		push af 
1036			;		ld a, 'i' 
1036			;		ld (debug_mark),a 
1036			;		pop af 
1036			;		CALLMONITOR 
1036			;	endif 
1036					cp KEY_HOME 
1036					jr nz, .iske 
1036			 
1036					ld a, (input_at_pos) 
1036					ld (input_at_cursor),a 
1036					ld a, 0 
1036					ld (input_cursor), a 
1036					jp .is1 
1036					 
1036			.iske:		cp KEY_END 
1036					jr nz, .isknw 
1036					jp .is1 
1036			 
1036			.isknw:		cp KEY_NEXTWORD 
1036					jr nz, .iskpw 
1036			 
1036			.isknwm:	ld hl, (input_ptr) 
1036					ld a,(hl)	 
1036					cp 0 
1036					jp z, .is1    ; end of string 
1036					cp ' ' 
1036					jp z, .is1    ; end of word 
1036					inc hl 
1036					ld (input_ptr), hl 
1036					ld a, (input_at_cursor) 
1036					inc a 
1036					ld (input_at_cursor), a 
1036					jr .isknwm 
1036			 
1036			.iskpw:		cp KEY_PREVWORD 
1036					jr nz, .iskl 
1036			.iskpwm:	 
1036					ld hl, (input_ptr) 
1036					ld a,(hl)	 
1036					cp 0  
1036					jp z, .is1    ; end of string 
1036					cp ' ' 
1036					jp z, .is1    ; end of word 
1036					dec hl 
1036					ld (input_ptr), hl 
1036					ld a, (input_at_cursor) 
1036					dec a 
1036					ld (input_at_cursor), a 
1036					jr .iskpwm 
1036			 
1036			 
1036			.iskl:		cp KEY_LEFT 
1036					jr nz, .isk1 
1036			 
1036					ld a, (input_cursor) 
1036			 
1036					cp 0 
1036					jp z, .is1 		; at start of line to ignore  
1036			 
1036					dec  a 		; TODO check underflow 
1036					ld (input_cursor), a 
1036			 
1036					ld hl, (input_ptr) 
1036					dec hl 
1036					ld (input_ptr), hl 
1036					 
1036					ld a, (input_at_cursor) 
1036					dec a 
1036					ld (input_at_cursor), a 
1036			 
1036					ld a, 1		; show cursor moving 
1036					ld (input_cur_onoff),a 
1036					ld a, CUR_BLINK_RATE 
1036					ld (input_cur_flash), a 
1036			 
1036					jp .is1 
1036			 
1036			.isk1:		cp KEY_RIGHT 
1036					jr nz, .isk2 
1036			 
1036					ld a,(input_len)		; TODO BUG why cant i load e direct? 
1036					ld e,a 
1036					ld a, (input_cursor) 
1036					cp e 
1036					jp z, .is1		; at the end of string so dont go right 
1036			 
1036					inc  a 		; TODO check overflow 
1036					ld (input_cursor), a 
1036			 
1036					ld a, (input_at_cursor) 
1036					inc a 
1036					ld (input_at_cursor), a 
1036			 
1036					ld hl, (input_ptr) 
1036					inc hl 
1036					ld (input_ptr), hl 
1036			 
1036					ld a, 1		; show cursor moving 
1036					ld (input_cur_onoff),a 
1036					ld a, CUR_BLINK_RATE 
1036					ld (input_cur_flash), a 
1036			 
1036					jp .is1 
1036			 
1036			.isk2:		cp KEY_UP 
1036			 
1036					jr nz, .isk3 
1036			 
1036					; swap last command with the current on 
1036			 
1036					; move cursor to start of string 
1036					ld hl, (input_start) 
1036					ld (input_ptr), hl 
1036			 
1036					ld a, (input_at_pos) 
1036					ld (input_at_cursor), a 
1036			 
1036					ld a, 0 
1036					ld (input_cursor), a 
1036					 
1036					; swap input and last command buffers 
1036			 
1036					ld hl, os_cli_cmd 
1036					ld de, os_last_cmd 
1036					ld b, 255 
1036			.swap1:		ld a, (hl) 
1036					ld c,a 
1036					ld a, (de) 
1036					ld (hl), a 
1036					ld a,c 
1036					ld (de),a 
1036					inc hl 
1036					inc de 
1036					djnz .swap1 
1036			 
1036			 
1036			 
1036			 
1036			 
1036					jp .is1 
1036			 
1036			.isk3:		cp KEY_BS 
1036					jr nz, .isk4 
1036			 
1036					ld a, (input_cursor) 
1036			 
1036					cp 0 
1036					jp z, .is1 		; at start of line to ignore  
1036			 
1036					dec  a 		; TODO check underflow 
1036					ld (input_cursor), a 
1036			 
1036					; hl is source 
1036					; de needs to be source - 1 
1036			 
1036			;		ld a, 0 
1036			;		dec hl 
1036			;		ld (hl), a 
1036			 
1036					ld hl, (input_ptr) 
1036					dec hl 
1036					ld (input_ptr), hl 
1036			 
1036					; shift all data 
1036			 
1036					push hl 
1036					inc hl 
1036					pop de 
1036					ld a, (input_len)		; TODO BUG WAS ld c, (input... 
1036					ld c,a 
1036					ld b,0 
1036					ldir  
1036			 
1036			 
1036			 
1036			 
1036					ld a, (input_at_cursor) 
1036					dec a 
1036					ld (input_at_cursor), a 
1036			 
1036			 
1036					ld a, 1		; show cursor moving 
1036					ld (input_cur_onoff),a 
1036					ld a, CUR_BLINK_RATE 
1036					ld (input_cur_flash), a 
1036			 
1036					; remove char 
1036					ld a, (input_at_cursor) 
1036					inc a 
1036					ld de,.iblank 
1036					call str_at_display 
1036			 
1036					jp .is1 
1036			 
1036			.isk4:		cp KEY_CR 
1036					jr z, .endinput 
1036			 
1036					; else add the key press to the end 
1036			 
1036					ld c, a			; save key pressed 
1036			 
1036					ld a,(hl)		; get what is currently under char 
1036			 
1036					cp 0			; we are at the end of the string 
1036					jr nz, .onchar 
1036					 
1036					; add a char to the end of the string 
1036				 
1036					ld (hl),c 
1036					inc hl 
1036			;		ld a,' ' 
1036			;		ld (hl),a 
1036			;		inc hl 
1036					ld a,0 
1036					ld (hl),a 
1036					dec hl 
1036			 
1036					ld a, (input_cursor) 
1036					inc a				; TODO check max string length and scroll  
1036					ld (input_cursor), a		; inc cursor pos 
1036							 
1036					ld a, (input_at_cursor) 
1036					inc a 
1036					ld (input_at_cursor), a 
1036			 
1036					ld hl, (input_ptr) 
1036					inc hl 
1036					ld (input_ptr), hl 
1036			 
1036					ld hl, (input_ptr) 
1036					inc hl 
1036					ld (input_ptr), hl 
1036			;	if DEBUG_INPUT 
1036			;		push af 
1036			;		ld a, '+' 
1036			;		ld (debug_mark),a 
1036			;		pop af 
1036			;		CALLMONITOR 
1036			;	endif 
1036					ld a, 1		; show cursor moving 
1036					ld (input_cur_onoff),a 
1036					ld a, CUR_BLINK_RATE 
1036					ld (input_cur_flash), a 
1036					jp .is1 
1036					 
1036			 
1036			 
1036					; if on a char then insert 
1036			.onchar: 
1036			 
1036					; TODO over flow check: make sure insert does not blow out buffer 
1036			 
1036					; need to do some maths to use lddr 
1036			 
1036					push hl   ; save char pos 
1036					push bc 
1036			 
1036					ld hl, (input_start) 
1036					ld a, (input_len) 
1036					call addatohl  		; end of string 
1036					inc hl 
1036					inc hl		; past zero term 
1036					push hl 
1036					inc hl 
1036					push hl  
1036			 
1036								; start and end of lddr set, now how much to move? 
1036			 
1036							 
1036					ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
1036					ld b,a 
1036					ld a,(input_len) 
1036					ld e,a 
1036					sub b 
1036					inc a		;?? 
1036					inc a		;?? 
1036					inc a		;?? 
1036			 
1036					ld b,0 
1036					ld c,a 
1036			 
1036				if DEBUG_INPUT 
1036					push af 
1036					ld a, 'i' 
1036					ld (debug_mark),a 
1036					pop af 
1036			;		CALLMONITOR 
1036				endif 
1036					pop de 
1036					pop hl 
1036				if DEBUG_INPUT 
1036					push af 
1036					ld a, 'I' 
1036					ld (debug_mark),a 
1036					pop af 
1036			;		CALLMONITOR 
1036				endif 
1036					lddr 
1036				 
1036			 
1036			 
1036					; TODO have a key for insert/overwrite mode???? 
1036					pop bc 
1036					pop hl 
1036					ld (hl), c		; otherwise overwrite current char 
1036					 
1036			 
1036			 
1036			 
1036					ld a, (input_cursor) 
1036					inc  a 		; TODO check overflow 
1036					ld (input_cursor), a 
1036			 
1036					ld a, (input_at_cursor) 
1036					inc a 
1036					ld (input_at_cursor), a 
1036			 
1036					jp .is1 
1036			 
1036			.endinput:	; TODO look for end of string 
1036			 
1036					; add trailing space for end of token 
1036			 
1036					ld hl, (input_start) 
1036					ld a,(input_len) 
1036					call addatohl 
1036					ld a, ' ' 
1036					ld (hl),a 
1036					; TODO eof of parse marker 
1036			 
1036					inc hl 
1036					ld a, 0 
1036					ld (hl),a 
1036			 
1036			 
1036					ret 
1036			 
1036			.iblank: db " ",0 
1036			 
1036			 
1036			input_str_prev:	ld (input_at_pos), a 
1036					ld (input_start), hl 
1036					ld a,1			; add cursor 
1036					ld (hl),a 
1036					inc hl 
1036					ld a,0 
1036					ld (hl),a 
1036					ld (input_ptr), hl 
1036					ld a,d 
1036					ld (input_size), a 
1036					ld a,0 
1036					ld (input_cursor),a 
1036			.instr1:	 
1036			 
1036					; TODO do block cursor 
1036					; TODO switch cursor depending on the modifer key 
1036			 
1036					; update cursor shape change on key hold 
1036			 
1036					ld hl, (input_ptr) 
1036					dec hl 
1036					ld a,(cursor_shape) 
1036					ld (hl), a 
1036			 
1036					; display entered text 
1036					ld a,(input_at_pos) 
1036			            	CALL fLCD_Pos       ;Position cursor to location in A 
1036			            	LD   de, (input_start) 
1036			            	CALL fLCD_Str       ;Display string pointed to by DE 
1036			 
1036					call cin 
1036					cp 0 
1036					jr z, .instr1 
1036			 
1036					; proecess keyboard controls first 
1036			 
1036					ld hl,(input_ptr) 
1036			 
1036					cp KEY_CR	 ; pressing enter ends input 
1036					jr z, .instrcr 
1036			 
1036					cp KEY_BS 	; back space 
1036					jr nz, .instr2 
1036					; process back space 
1036			 
1036					; TODO stop back space if at start of string 
1036					dec hl 
1036					dec hl ; to over write cursor 
1036					ld a,(cursor_shape) 
1036					;ld a,0 
1036					ld (hl),a 
1036					inc hl 
1036					ld a," " 
1036					ld (hl),a 
1036					ld (input_ptr),hl 
1036					 
1036			 
1036					jr .instr1 
1036			 
1036			.instr2:	cp KEY_LEFT    ; cursor left 
1036					jr nz, .instr3 
1036					dec hl 
1036					ld (input_ptr),hl 
1036					jr .instr1 
1036				 
1036			.instr3:	cp KEY_RIGHT      ; cursor right 
1036					jr nz, .instr4 
1036					inc hl 
1036					ld (input_ptr),hl 
1036					jr .instr1 
1036			 
1036			.instr4:	cp KEY_HOME    ; jump to start of line 
1036					jr nz, .instr5 
1036					dec hl 
1036					ld (input_ptr),hl 
1036					jr .instr1 
1036			 
1036			.instr5:	cp KEY_END     ; jump to end of line 
1036					jr nz, .instr6 
1036					dec hl 
1036					ld (input_ptr),hl 
1036					jr .instr1 
1036			.instr6:        cp KEY_UP      ; recall last command 
1036					jr nz, .instrnew 
1036			 
1036				ld hl, scratch 
1036				ld de, os_last_cmd 
1036				call strcpy 
1036					jr .instr1 
1036			 
1036			 
1036			.instrnew:	; no special key pressed to see if we have room to store it 
1036			 
1036					; TODO do string size test 
1036			 
1036					dec hl ; to over write cursor 
1036					ld (hl),a 
1036					inc hl 
1036					ld a,(cursor_shape) 
1036					ld (hl),a 
1036					inc hl 
1036					ld a,0 
1036					ld (hl),a 
1036			 
1036					ld (input_ptr),hl 
1036					 
1036					jr .instr1 
1036			.instrcr:	dec hl		; remove cursor 
1036					ld a,' '	; TODO add a trailing space for safety 
1036					ld (hl),a 
1036					inc hl 
1036					ld a,0 
1036					ld (hl),a 
1036			 
1036			 
1036					; if at end of line scroll up    
1036					; TODO detecting only end of line 4 for scroll up  
1036			 
1036					;ld   
1036			 
1036					ret 
1036			 
1036			 
1036			endif 
1036			; strcpy hl = dest, de source 
1036			 
1036 1a			strcpy:   LD   A, (DE)        ;Get character from string 
1037 b7			            OR   A              ;Null terminator? 
1038 c8			            RET  Z              ;Yes, so finished 
1039 1a					ld a,(de) 
103a 77					ld (hl),a 
103b 13			            INC  DE             ;Point to next character 
103c 23					inc hl 
103d 18 f7		            JR   strcpy       ;Repeat 
103f c9					ret 
1040			 
1040			 
1040			; TODO string_at  
1040			; pass string which starts with lcd offset address and then null term string 
1040			 
1040			; TODO string to dec 
1040			; TODO string to hex 
1040			; TODO byte to string hex 
1040			; TODO byte to string dec 
1040			 
1040			 
1040			 
1040			; from z80uartmonitor 
1040			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1040			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
1040			; pass hl for where to put the text 
1040			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1040 c5			hexout:	PUSH BC 
1041 f5					PUSH AF 
1042 47					LD B, A 
1043					; Upper nybble 
1043 cb 3f				SRL A 
1045 cb 3f				SRL A 
1047 cb 3f				SRL A 
1049 cb 3f				SRL A 
104b cd 5b 10				CALL tohex 
104e 77					ld (hl),a 
104f 23					inc hl	 
1050					 
1050					; Lower nybble 
1050 78					LD A, B 
1051 e6 0f				AND 0FH 
1053 cd 5b 10				CALL tohex 
1056 77					ld (hl),a 
1057 23					inc hl	 
1058					 
1058 f1					POP AF 
1059 c1					POP BC 
105a c9					RET 
105b					 
105b			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
105b			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
105b			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
105b			tohex: 
105b e5					PUSH HL 
105c d5					PUSH DE 
105d 16 00				LD D, 0 
105f 5f					LD E, A 
1060 21 68 10				LD HL, .DATA 
1063 19					ADD HL, DE 
1064 7e					LD A, (HL) 
1065 d1					POP DE 
1066 e1					POP HL 
1067 c9					RET 
1068			 
1068			.DATA: 
1068 30					DEFB	30h	; 0 
1069 31					DEFB	31h	; 1 
106a 32					DEFB	32h	; 2 
106b 33					DEFB	33h	; 3 
106c 34					DEFB	34h	; 4 
106d 35					DEFB	35h	; 5 
106e 36					DEFB	36h	; 6 
106f 37					DEFB	37h	; 7 
1070 38					DEFB	38h	; 8 
1071 39					DEFB	39h	; 9 
1072 41					DEFB	41h	; A 
1073 42					DEFB	42h	; B 
1074 43					DEFB	43h	; C 
1075 44					DEFB	44h	; D 
1076 45					DEFB	45h	; E 
1077 46					DEFB	46h	; F 
1078			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1078			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1078			;;    subtract $30, if result > 9 then subtract $7 more 
1078			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1078			atohex: 
1078 d6 30				SUB $30 
107a fe 0a				CP 10 
107c f8					RET M		; If result negative it was 0-9 so we're done 
107d d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
107f c9					RET		 
1080			 
1080			 
1080			 
1080			 
1080			; Get 2 ASCII characters as hex byte from pointer in hl 
1080			 
1080			BYTERD: 
1080 16 00			LD	D,00h		;Set up 
1082 cd 8a 10			CALL	HEXCON		;Get byte and convert to hex 
1085 87				ADD	A,A		;First nibble so 
1086 87				ADD	A,A		;multiply by 16 
1087 87				ADD	A,A		; 
1088 87				ADD	A,A		; 
1089 57				LD	D,A		;Save hi nibble in D 
108a			HEXCON: 
108a 7e				ld a, (hl)		;Get next chr 
108b 23				inc hl 
108c d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
108e fe 0a			CP	00Ah		;Is it 0-9 ? 
1090 38 02			JR	C,NALPHA	;If so miss next bit 
1092 d6 07			SUB	007h		;Else convert alpha 
1094			NALPHA: 
1094 b2				OR	D		;Add hi nibble back 
1095 c9				RET			; 
1096			 
1096			 
1096			; 
1096			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
1096			; Since the routines get_byte and therefore get_nibble are called, only valid 
1096			; characters (0-9a-f) are accepted. 
1096			; 
1096			;get_word        push    af 
1096			;                call    get_byte        ; Get the upper byte 
1096			;                ld      h, a 
1096			;                call    get_byte        ; Get the lower byte 
1096			;                ld      l, a 
1096			;                pop     af 
1096			;                ret 
1096			; 
1096			; Get a byte in hexadecimal notation. The result is returned in A. Since 
1096			; the routine get_nibble is used only valid characters are accepted - the  
1096			; input routine only accepts characters 0-9a-f. 
1096			; 
1096 c5			get_byte:        push    bc              ; Save contents of B (and C) 
1097 7e					ld a,(hl) 
1098 23					inc hl 
1099 cd be 10		                call    nibble2val      ; Get upper nibble 
109c cb 07		                rlc     a 
109e cb 07		                rlc     a 
10a0 cb 07		                rlc     a 
10a2 cb 07		                rlc     a 
10a4 47			                ld      b, a            ; Save upper four bits 
10a5 7e					ld a,(hl) 
10a6 cd be 10		                call    nibble2val      ; Get lower nibble 
10a9 b0			                or      b               ; Combine both nibbles 
10aa c1			                pop     bc              ; Restore B (and C) 
10ab c9			                ret 
10ac			; 
10ac			; Get a hexadecimal digit from the serial line. This routine blocks until 
10ac			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
10ac			; to the serial line interface. The lower 4 bits of A contain the value of  
10ac			; that particular digit. 
10ac			; 
10ac			;get_nibble      ld a,(hl)           ; Read a character 
10ac			;                call    to_upper        ; Convert to upper case 
10ac			;                call    is_hex          ; Was it a hex digit? 
10ac			;                jr      nc, get_nibble  ; No, get another character 
10ac			 ;               call    nibble2val      ; Convert nibble to value 
10ac			 ;               call    print_nibble 
10ac			 ;               ret 
10ac			; 
10ac			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
10ac			; A valid hexadecimal digit is denoted by a set C flag. 
10ac			; 
10ac			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
10ac			;                ret     nc              ; Yes 
10ac			;                cp      '0'             ; Less than '0'? 
10ac			;                jr      nc, is_hex_1    ; No, continue 
10ac			;                ccf                     ; Complement carry (i.e. clear it) 
10ac			;                ret 
10ac			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
10ac			;                ret     c               ; Yes 
10ac			;                cp      'A'             ; Less than 'A'? 
10ac			;                jr      nc, is_hex_2    ; No, continue 
10ac			;                ccf                     ; Yes - clear carry and return 
10ac			;                ret 
10ac			;is_hex_2        scf                     ; Set carry 
10ac			;                ret 
10ac			; 
10ac			; Convert a single character contained in A to upper case: 
10ac			; 
10ac fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
10ae d8			                ret     c 
10af fe 7b		                cp      'z' + 1         ; > 'z'? 
10b1 d0			                ret     nc              ; Nothing to do, either 
10b2 e6 5f		                and     $5f             ; Convert to upper case 
10b4 c9			                ret 
10b5			 
10b5			 
10b5			to_lower: 
10b5			 
10b5			   ; if char is in [A-Z] make it lower case 
10b5			 
10b5			   ; enter : a = char 
10b5			   ; exit  : a = lower case char 
10b5			   ; uses  : af 
10b5			 
10b5 fe 41		   cp 'A' 
10b7 d8			   ret c 
10b8			    
10b8 fe 5b		   cp 'Z'+1 
10ba d0			   ret nc 
10bb			    
10bb f6 20		   or $20 
10bd c9			   ret 
10be			 
10be			; 
10be			; Expects a hexadecimal digit (upper case!) in A and returns the 
10be			; corresponding value in A. 
10be			; 
10be fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
10c0 38 02		                jr      c, nibble2val_1 ; Yes 
10c2 d6 07		                sub     7               ; Adjust for A-F 
10c4 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
10c6 e6 0f		                and     $f              ; Only return lower 4 bits 
10c8 c9			                ret 
10c9			; 
10c9			; Print_nibble prints a single hex nibble which is contained in the lower  
10c9			; four bits of A: 
10c9			; 
10c9			;print_nibble    push    af              ; We won't destroy the contents of A 
10c9			;                and     $f              ; Just in case... 
10c9			;                add     a, '0'             ; If we have a digit we are done here. 
10c9			;                cp      '9' + 1         ; Is the result > 9? 
10c9			;                jr      c, print_nibble_1 
10c9			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
10c9			;print_nibble_1  call    putc            ; Print the nibble and 
10c9			;                pop     af              ; restore the original value of A 
10c9			;                ret 
10c9			;; 
10c9			;; Send a CR/LF pair: 
10c9			; 
10c9			;crlf            push    af 
10c9			;                ld      a, cr 
10c9			;                call    putc 
10c9			;                ld      a, lf 
10c9			;                call    putc 
10c9			;                pop     af 
10c9			;                ret 
10c9			; 
10c9			; Print_word prints the four hex digits of a word to the serial line. The  
10c9			; word is expected to be in HL. 
10c9			; 
10c9			;print_word      push    hl 
10c9			;                push    af 
10c9			;                ld      a, h 
10c9			;                call    print_byte 
10c9			;                ld      a, l 
10c9			;                call    print_byte 
10c9			;                pop     af 
10c9			;                pop     hl 
10c9			;                ret 
10c9			; 
10c9			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
10c9			; The byte to be printed is expected to be in A. 
10c9			; 
10c9			;print_byte      push    af              ; Save the contents of the registers 
10c9			;                push    bc 
10c9			;                ld      b, a 
10c9			;                rrca 
10c9			;                rrca 
10c9			;                rrca 
10c9			;                rrca 
10c9			;                call    print_nibble    ; Print high nibble 
10c9			;                ld      a, b 
10c9			;                call    print_nibble    ; Print low nibble 
10c9			;                pop     bc              ; Restore original register contents 
10c9			;                pop     af 
10c9			;                ret 
10c9			 
10c9			 
10c9			 
10c9			 
10c9			 
10c9			fourehexhl:  
10c9 7e				ld a,(hl) 
10ca cd 78 10			call atohex 
10cd cb 3f				SRL A 
10cf cb 3f				SRL A 
10d1 cb 3f				SRL A 
10d3 cb 3f				SRL A 
10d5 47				ld b, a 
10d6 23				inc hl 
10d7 7e				ld a,(hl) 
10d8 23				inc hl 
10d9 cd 78 10			call atohex 
10dc 80				add b 
10dd 57				ld d,a 
10de 7e				ld a,(hl) 
10df cd 78 10			call atohex 
10e2 cb 3f				SRL A 
10e4 cb 3f				SRL A 
10e6 cb 3f				SRL A 
10e8 cb 3f				SRL A 
10ea 47				ld b, a 
10eb 23				inc hl 
10ec 7e				ld a,(hl) 
10ed 23				inc hl 
10ee cd 78 10			call atohex 
10f1 80				add b 
10f2 5f				ld e, a 
10f3 d5				push de 
10f4 e1				pop hl 
10f5 c9				ret 
10f6			 
10f6			; pass hl. returns z set if the byte at hl is a digit 
10f6			;isdigithl:  
10f6			;	push bc 
10f6			;	ld a,(hl) 
10f6			;	cp ':' 
10f6			;	jr nc, .isdf 		; > 
10f6			;	cp '0' 
10f6			;	jr c, .isdf		; < 
10f6			; 
10f6			;	; TODO find a better way to set z 
10f6			; 
10f6			;	ld b,a 
10f6			;	cp b 
10f6			;	pop bc 
10f6			;	ret 
10f6			; 
10f6			;.isdf:	; not digit so clear z 
10f6			; 
10f6			;	; TODO find a better way to unset z 
10f6			; 
10f6			;	ld b,a 
10f6			;	inc b 
10f6			;	cp b 
10f6			; 
10f6			;	pop bc 
10f6			;	ret 
10f6				 
10f6				 
10f6			 
10f6			 
10f6			; pass hl as the four byte address to load 
10f6			 
10f6			get_word_hl:  
10f6 e5				push hl 
10f7 cd 96 10			call get_byte 
10fa				 
10fa 47				ld b, a 
10fb			 
10fb e1				pop hl 
10fc 23				inc hl 
10fd 23				inc hl 
10fe			 
10fe			; TODO not able to handle a-f  
10fe 7e				ld a,(hl) 
10ff			;	;cp ':' 
10ff			;	cp 'g' 
10ff			;	jr nc, .single_byte_hl 		; > 
10ff			;	cp 'G' 
10ff			;	jr nc, .single_byte_hl 		; > 
10ff			;	cp '0' 
10ff			;	jr c, .single_byte_hl		; < 
10ff			 
10ff				;call isdigithl 
10ff fe 00			cp 0 
1101 28 06			jr z, .single_byte_hl 
1103			 
1103			.getwhln:   ; hex word so get next byte 
1103			 
1103 cd 96 10			call get_byte 
1106 6f				ld l, a 
1107 60				ld h,b 
1108 c9				ret 
1109 68			.single_byte_hl:   ld l,b 
110a 26 00				ld h,0 
110c c9					ret 
110d			 
110d			 
110d			 
110d			 
110d 21 9a 18			ld hl,asc+1 
1110			;	ld a, (hl) 
1110			;	call nibble2val 
1110 cd 96 10			call get_byte 
1113			 
1113			;	call fourehexhl 
1113 32 f5 e2			ld (scratch+52),a 
1116				 
1116 21 f3 e2			ld hl,scratch+50 
1119 22 e4 e5			ld (os_cur_ptr),hl 
111c			 
111c c9				ret 
111d			 
111d			 
111d			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
111d			 
111d			; Decimal Unsigned Version 
111d			 
111d			;Number in a to decimal ASCII 
111d			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
111d			;Example: display a=56 as "056" 
111d			;input: a = number 
111d			;Output: a=0,value of a in the screen 
111d			;destroys af,bc (don't know about hl and de) 
111d			DispAToASCII: 
111d 0e 9c			ld	c,-100 
111f cd 29 11			call	.Na1 
1122 0e f6			ld	c,-10 
1124 cd 29 11			call	.Na1 
1127 0e ff			ld	c,-1 
1129 06 2f		.Na1:	ld	b,'0'-1 
112b 04			.Na2:	inc	b 
112c 81				add	a,c 
112d 38 fc			jr	c,.Na2 
112f 91				sub	c		;works as add 100/10/1 
1130 f5				push af		;safer than ld c,a 
1131 78				ld	a,b		;char is in b 
1132			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
1132 f1				pop af		;safer than ld a,c 
1133 c9				ret 
1134			 
1134			; Decimal Signed Version 
1134			 
1134			; DispA 
1134			; -------------------------------------------------------------- 
1134			; Converts a signed integer value to a zero-terminated ASCII 
1134			; string representative of that value (using radix 10). 
1134			; -------------------------------------------------------------- 
1134			; INPUTS: 
1134			;     HL     Value to convert (two's complement integer). 
1134			;     DE     Base address of string destination. (pointer). 
1134			; -------------------------------------------------------------- 
1134			; OUTPUTS: 
1134			;     None 
1134			; -------------------------------------------------------------- 
1134			; REGISTERS/MEMORY DESTROYED 
1134			; AF HL 
1134			; -------------------------------------------------------------- 
1134			 
1134			;DispHLToASCII: 
1134			;   push    de 
1134			;   push    bc 
1134			; 
1134			;; Detect sign of HL. 
1134			;    bit    7, h 
1134			;    jr     z, ._DoConvert 
1134			; 
1134			;; HL is negative. Output '-' to string and negate HL. 
1134			;    ld     a, '-' 
1134			;    ld     (de), a 
1134			;    inc    de 
1134			; 
1134			;; Negate HL (using two's complement) 
1134			;    xor    a 
1134			;    sub    l 
1134			;    ld     l, a 
1134			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
1134			;    sbc    a, h 
1134			;    ld     h, a 
1134			; 
1134			;; Convert HL to digit characters 
1134			;._DoConvert: 
1134			;    ld     b, 0     ; B will count character length of number 
1134			;-   ld     a, 10 
1134			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
1134			;    push   af 
1134			;    inc    b 
1134			;    ld     a, h 
1134			;    or     l 
1134			;    jr     nz, - 
1134			; 
1134			;; Retrieve digits from stack 
1134			;-   pop    af 
1134			;    or     $30 
1134			;    ld     (de), a 
1134			;    inc    de 
1134			;    djnz   - 
1134			; 
1134			;; Terminate string with NULL 
1134			;    xor    a 
1134			;    ld     (de), a 
1134			; 
1134			;    pop    bc 
1134			;    pop    de 
1134			;    ret 
1134			 
1134			;Comments 
1134			; 
1134			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
1134			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
1134			;    Note that the output string will not be fixed-width. 
1134			; 
1134			;Example Usage 
1134			; 
1134			;    ld    hl, -1004 
1134			;    ld    de, OP1 
1134			;    call  DispA 
1134			;    ld    hl, OP1 
1134			;    syscall  PutS 
1134			 
1134			 
1134			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
1134			 
1134			 
1134			;Converts an ASCII string to an unsigned 16-bit integer 
1134			;Quits when it reaches a non-decimal digit 
1134			 
1134			string_to_uint16: 
1134			atoui_16: 
1134			;Input: 
1134			;     DE points to the string 
1134			;Outputs: 
1134			;     HL is the result 
1134			;     A is the 8-bit value of the number 
1134			;     DE points to the byte after the number 
1134			;Destroys: 
1134			;     BC 
1134			;       if the string is non-empty, BC is HL/10 
1134			;Size:  24 bytes 
1134			;Speed: 42+d(104+{0,9}) 
1134			;       d is the number of digits in the number 
1134			;       max is 640 cycles for a 5 digit number 
1134			;Assuming no leading zeros: 
1134			;1 digit:  146cc 
1134			;2 digit:  250cc 
1134			;3 digit:  354cc or 363cc (avg: 354.126cc) 
1134			;4 digit:  458cc or 467cc (avg: 458.27cc) 
1134			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
1134			;avg: 544.81158447265625cc (544+13297/16384) 
1134			;=============================================================== 
1134 21 00 00		  ld hl,0 
1137			.u16a: 
1137 1a			  ld a,(de) 
1138 d6 30		  sub 30h 
113a fe 0a		  cp 10 
113c d0			  ret nc 
113d 13			  inc de 
113e 44			  ld b,h 
113f 4d			  ld c,l 
1140 29			  add hl,hl 
1141 29			  add hl,hl 
1142 09			  add hl,bc 
1143 29			  add hl,hl 
1144 85			  add a,l 
1145 6f			  ld l,a 
1146 30 ef		  jr nc,.u16a 
1148 24			  inc h 
1149 c3 37 11		  jp .u16a 
114c			 
114c			 
114c			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
114c			 
114c			;written by Zeda 
114c			;Converts a 16-bit unsigned integer to an ASCII string. 
114c			 
114c			uitoa_16: 
114c			;Input: 
114c			;   DE is the number to convert 
114c			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
114c			;Output: 
114c			;   HL points to the null-terminated ASCII string 
114c			;      NOTE: This isn't necessarily the same as the input HL. 
114c d5			  push de 
114d c5			  push bc 
114e f5			  push af 
114f eb			  ex de,hl 
1150			 
1150 01 f0 d8		  ld bc,-10000 
1153 3e 2f		  ld a,'0'-1 
1155 3c			  inc a 
1156 09			  add hl,bc  
1157 38 fc		   jr c,$-2 
1159 12			  ld (de),a 
115a 13			  inc de 
115b			 
115b 01 e8 03		  ld bc,1000 
115e 3e 3a		  ld a,'9'+1 
1160 3d			  dec a  
1161 09			  add hl,bc  
1162 30 fc		   jr nc,$-2 
1164 12			  ld (de),a 
1165 13			  inc de 
1166			 
1166 01 9c ff		  ld bc,-100 
1169 3e 2f		  ld a,'0'-1 
116b 3c			  inc a  
116c 09			  add hl,bc  
116d 38 fc		   jr c,$-2 
116f 12			  ld (de),a 
1170 13			  inc de 
1171			 
1171 7d			  ld a,l 
1172 26 3a		  ld h,'9'+1 
1174 25			  dec h  
1175 c6 0a		  add a,10  
1177 30 fb		   jr nc,$-3 
1179 c6 30		  add a,'0' 
117b eb			  ex de,hl 
117c 72			  ld (hl),d 
117d 23			  inc hl 
117e 77			  ld (hl),a 
117f 23			  inc hl 
1180 36 00		  ld (hl),0 
1182			 
1182			;Now strip the leading zeros 
1182 0e fa		  ld c,-6 
1184 09			  add hl,bc 
1185 3e 30		  ld a,'0' 
1187 23			  inc hl  
1188 be			  cp (hl)  
1189 28 fc		  jr z,$-2 
118b			 
118b			;Make sure that the string is non-empty! 
118b 7e			  ld a,(hl) 
118c b7			  or a 
118d 20 01		  jr nz,.atoub 
118f 2b			  dec hl 
1190			.atoub: 
1190			 
1190 f1			  pop af 
1191 c1			  pop bc 
1192 d1			  pop de 
1193 c9			  ret 
1194			 
1194			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
1194			 
1194			toUpper: 
1194			;A is the char. 
1194			;If A is a lowercase letter, this sets it to the matching uppercase 
1194			;18cc or 30cc or 41cc 
1194			;avg: 26.75cc 
1194 fe 61		  cp 'a' 
1196 d8			  ret c 
1197 fe 7b		  cp 'z'+1 
1199 d0			  ret nc 
119a d6 20		  sub 'a'-'A' 
119c c9			  ret 
119d			 
119d			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
119d			 
119d			; String Length 
119d			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
119d			 
119d			; Get the length of the null-terminated string starting at $8000 hl 
119d			;    LD     HL, $8000 
119d			 
119d			strlenz: 
119d			 
119d af			    XOR    A               ; Zero is the value we are looking for. 
119e 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
119f 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
11a0			                           ; 65, 536 bytes (the entire addressable memory space). 
11a0 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
11a2			 
11a2			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
11a2 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
11a3 6f			    LD     L, A             ; number of bytes 
11a4 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
11a6 2b			    DEC    HL              ; Compensate for null. 
11a7 c9				ret 
11a8			 
11a8			; Get the length of the A terminated string starting at $8000 hl 
11a8			;    LD     HL, $8000 
11a8			 
11a8			strlent: 
11a8			 
11a8			                  ; A is the value we are looking for. 
11a8 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
11aa 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
11ac			                           ; 65, 536 bytes (the entire addressable memory space). 
11ac ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
11ae			 
11ae			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
11ae 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
11b0 2e 00		    LD     L, 0             ; number of bytes 
11b2 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
11b4 2b			    DEC    HL              ; Compensate for null. 
11b5 c9				ret 
11b6			 
11b6			 
11b6			;Comparing Strings 
11b6			 
11b6			;IN    HL     Address of string1. 
11b6			;      DE     Address of string2. 
11b6			 
11b6			; doc given but wrong??? 
11b6			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
11b6			;      carry  Set if string1 > string2, reset if string1 <= string2. 
11b6			; tested 
11b6			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
11b6			 
11b6			strcmp_old: 
11b6 e5			    PUSH   HL 
11b7 d5			    PUSH   DE 
11b8			 
11b8 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
11b9 be			    CP     (HL)            ; (want to minimize work). 
11ba 38 01		    JR     C, Str1IsBigger 
11bc 7e			    LD     A, (HL) 
11bd			 
11bd			Str1IsBigger: 
11bd 4f			    LD     C, A             ; Put length in BC 
11be 06 00		    LD     B, 0 
11c0 13			    INC    DE              ; Increment pointers to meat of string. 
11c1 23			    INC    HL 
11c2			 
11c2			CmpLoop: 
11c2 1a			    LD     A, (DE)          ; Compare bytes. 
11c3 ed a1		    CPI 
11c5 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
11c7 13			    INC    DE              ; Update pointer. 
11c8 ea c2 11		    JP     PE, CmpLoop 
11cb			 
11cb d1			    POP    DE 
11cc e1			    POP    HL 
11cd 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
11ce be			    CP     (HL) 
11cf c9			    RET 
11d0			 
11d0			NoMatch: 
11d0 2b			    DEC    HL 
11d1 be			    CP     (HL)            ; Compare again to affect carry. 
11d2 d1			    POP    DE 
11d3 e1			    POP    HL 
11d4 c9			    RET 
11d5			 
11d5			;; test strmp 
11d5			; 
11d5			;ld de, .str1 
11d5			;ld hl, .str2 
11d5			;call strcmp 
11d5			;jr z, .z1 
11d5			;;this 
11d5			;	if DEBUG_FORTH_WORDS 
11d5			;		DMARK "NZ1" 
11d5			;		CALLMONITOR 
11d5			;	endif 
11d5			;.z1: 
11d5			; 
11d5			;	if DEBUG_FORTH_WORDS 
11d5			;		DMARK "ZZ1" 
11d5			;		CALLMONITOR 
11d5			;	endif 
11d5			; 
11d5			;ld de, .str1 
11d5			;ld hl, .str1 
11d5			;call strcmp 
11d5			;jr z, .z2 
11d5			;;this 
11d5			;	if DEBUG_FORTH_WORDS 
11d5			;		DMARK "NZ2" 
11d5			;		CALLMONITOR 
11d5			;	endif 
11d5			;.z2: 
11d5			; 
11d5			;	if DEBUG_FORTH_WORDS 
11d5			;		DMARK "ZZ2" 
11d5			;		CALLMONITOR 
11d5			;	endif 
11d5			; 
11d5			;ld de, .str1 
11d5			;ld hl, .str2 
11d5			;call strcmp 
11d5			;jr c, .c1 
11d5			; 
11d5			;	if DEBUG_FORTH_WORDS 
11d5			;		DMARK "Nc1" 
11d5			;		CALLMONITOR 
11d5			;	endif 
11d5			;.c1: 
11d5			;;this 
11d5			;	if DEBUG_FORTH_WORDS 
11d5			;		DMARK "cc1" 
11d5			;		CALLMONITOR 
11d5			;	endif 
11d5			; 
11d5			;ld de, .str1 
11d5			;ld hl, .str1 
11d5			;call strcmp 
11d5			;jr c, .c2 
11d5			;;this 
11d5			;	if DEBUG_FORTH_WORDS 
11d5			;		DMARK "Nc2" 
11d5			;		CALLMONITOR 
11d5			;	endif 
11d5			;.c2: 
11d5			; 
11d5			;	if DEBUG_FORTH_WORDS 
11d5			;		DMARK "cc2" 
11d5			;		CALLMONITOR 
11d5			;	endif 
11d5			;	NEXTW 
11d5			;.str1:   db "string1",0 
11d5			;.str2:   db "string2",0 
11d5			 
11d5			; only care about direct match or not 
11d5			; hl and de strings 
11d5			; zero set if the same 
11d5			 
11d5			strcmp: 
11d5 1a				ld a, (de) 
11d6 be				cp (hl) 
11d7 28 02			jr z, .ssame 
11d9 b7				or a 
11da c9				ret 
11db			 
11db			.ssame:  
11db fe 00			cp 0 
11dd c8				ret z 
11de			 
11de 23				inc hl 
11df 13				inc de 
11e0 18 f3			jr strcmp 
11e2				 
11e2				 
11e2			 
11e2			;Copyright (c) 2014, Luke Maurits 
11e2			;All rights reserved. 
11e2			; 
11e2			;Redistribution and use in source and binary forms, with or without 
11e2			;modification, are permitted provided that the following conditions are met: 
11e2			; 
11e2			;* Redistributions of source code must retain the above copyright notice, this 
11e2			;  list of conditions and the following disclaimer. 
11e2			; 
11e2			;* Redistributions in binary form must reproduce the above copyright notice, 
11e2			;  this list of conditions and the following disclaimer in the documentation 
11e2			;  and/or other materials provided with the distribution. 
11e2			; 
11e2			;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
11e2			;AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
11e2			;IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
11e2			;DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE 
11e2			;FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
11e2			;DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
11e2			;SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
11e2			;CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
11e2			;OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
11e2			;OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
11e2			 
11e2			; https://github.com/lmaurits/lm512/blob/master/string.z80 
11e2			 
11e2			StrictStrCmp: 
11e2				; Load next chars of each string 
11e2 1a				ld a, (de) 
11e3 47				ld b, a 
11e4 7e				ld a, (hl) 
11e5				; Compare 
11e5 b8				cp b 
11e6				; Return non-zero if chars don't match 
11e6 c0				ret nz 
11e7				; Check for end of both strings 
11e7 fe 00			cp "\0" 
11e9				; Return if strings have ended 
11e9 c8				ret z 
11ea				; Otherwise, advance to next chars 
11ea 23				inc hl 
11eb 13				inc de 
11ec 18 f4			jr StrictStrCmp 
11ee			 
11ee			;end 
11ee			; eof 
11ee			 
11ee			 
11ee			 
11ee			 
11ee			 
11ee			 
# End of file firmware_strings.asm
11ee			include "firmware_memory.asm"   ; malloc and free  
11ee			 
11ee			if DEBUG_FORTH_MALLOC_HIGH 
11ee			.mallocsize: db "Wants malloc >256",0 
11ee			.mallocasize: db "MALLOC gives >256",0 
11ee			.malloczero: db "MALLOC gives zero",0 
11ee			 
11ee			malloc_guard_zerolen: 
11ee				push hl 
11ee				push de 
11ee				push af 
11ee			 
11ee				ld de, 0 
11ee			        call cmp16 
11ee				jr nz, .lowalloz 
11ee			 
11ee				push hl 
11ee				push de 
11ee					ld hl, display_fb0 
11ee					ld (display_fb_active), hl 
11ee				call clear_display 
11ee				ld a, 0 
11ee				ld de, .malloczero 
11ee				call str_at_display 
11ee				call update_display 
11ee				call delay1s 
11ee				call delay1s 
11ee				call bp_on 
11ee			;	ld a, 0 
11ee			;	ld (os_view_disable), a 
11ee			 
11ee				pop de 
11ee				pop hl 
11ee			 
11ee				 
11ee			 
11ee				CALLMONITOR 
11ee			.lowalloz: 
11ee			 
11ee			 
11ee				pop af 
11ee				pop de 
11ee				pop hl 
11ee			ret 
11ee			 
11ee			malloc_guard_entry: 
11ee				push hl 
11ee				push de 
11ee				push af 
11ee			 
11ee			 	or a      ;clear carry flag 
11ee				push hl 
11ee				ld de, 255 
11ee				sbc hl, de 
11ee				jr c, .lowalloc 
11ee			 
11ee				push de 
11ee					ld hl, display_fb0 
11ee					ld (display_fb_active), hl 
11ee				call clear_display 
11ee				ld a, 0 
11ee				ld de, .mallocsize 
11ee				call str_at_display 
11ee				call update_display 
11ee				call delay1s 
11ee				call delay1s 
11ee			;	ld a, 0 
11ee			;	ld (os_view_disable), a 
11ee				call bp_on 
11ee			 
11ee				pop de 
11ee				pop hl 
11ee			 
11ee				 
11ee			 
11ee				CALLMONITOR 
11ee				jr .lowdone 
11ee			.lowalloc: 
11ee			 
11ee			 
11ee				pop hl 
11ee			.lowdone:	pop af 
11ee				pop de 
11ee				pop hl 
11ee			ret 
11ee			 
11ee			malloc_guard_exit: 
11ee				push hl 
11ee				push de 
11ee				push af 
11ee			 
11ee			 	or a      ;clear carry flag 
11ee				push hl 
11ee				ld de, 255 
11ee				sbc hl, de 
11ee				jr c, .lowallocx 
11ee			 
11ee				push de 
11ee					ld hl, display_fb0 
11ee					ld (display_fb_active), hl 
11ee				call clear_display 
11ee				ld a, 0 
11ee				ld de, .mallocasize 
11ee				call str_at_display 
11ee				call update_display 
11ee				call delay1s 
11ee				call delay1s 
11ee			;	ld a, 0 
11ee			;	ld (os_view_disable), a 
11ee				call bp_on 
11ee				pop de 
11ee				pop hl 
11ee			 
11ee				CALLMONITOR 
11ee				jr .lowdonex 
11ee			.lowallocx: 
11ee			 
11ee				pop hl 
11ee			.lowdonex:	pop af 
11ee				pop de 
11ee				pop hl 
11ee			ret 
11ee			endif 
11ee			 
11ee			if MALLOC_2 
11ee			; Z80 Malloc and Free Functions 
11ee			 
11ee			; Malloc Function: 
11ee			; Input: 
11ee			;   HL: Size of block to allocate 
11ee			; Output: 
11ee			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
11ee			 
11ee			malloc: 
11ee				 
11ee			if DEBUG_FORTH_MALLOC_HIGH 
11ee			call malloc_guard_entry 
11ee			endif 
11ee			 
11ee			 
11ee			 
11ee			 
11ee					if DEBUG_FORTH_MALLOC 
11ee						DMARK "mal" 
11ee						CALLMONITOR 
11ee					endif 
11ee			    push af            ; Save AF register 
11ee			    ld a, l            ; Load low byte of size into A 
11ee			    or h               ; Check if size is zero 
11ee			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
11ee			 
11ee			    ; Allocate memory 
11ee			    ld hl, (heap_start) ; Load start of heap into HL 
11ee					if DEBUG_FORTH_MALLOC 
11ee						DMARK "ma1" 
11ee						CALLMONITOR 
11ee					endif 
11ee			    call malloc_internal ; Call internal malloc function 
11ee			    pop af             ; Restore AF register 
11ee			if DEBUG_FORTH_MALLOC_HIGH 
11ee			call malloc_guard_exit 
11ee			call malloc_guard_zerolen 
11ee			endif 
11ee			    ret                ; Return 
11ee			 
11ee			; Free Function: 
11ee			; Input: 
11ee			;   HL: Pointer to memory block to free 
11ee			; Output: 
11ee			;   None 
11ee			 
11ee			free: 
11ee			    push af            ; Save AF register 
11ee			    ld a, l            ; Load low byte of pointer into A 
11ee			    or h               ; Check if pointer is NULL 
11ee			    jp z, free_exit    ; If pointer is NULL, exit 
11ee			 
11ee			    ; Free memory 
11ee			    ld hl, (heap_start) ; Load start of heap into HL 
11ee			    call free_internal  ; Call internal free function 
11ee			    pop af             ; Restore AF register 
11ee			    ret                ; Return 
11ee			 
11ee			; Internal Malloc Function: 
11ee			; Input: 
11ee			;   HL: Size of block to allocate 
11ee			; Output: 
11ee			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
11ee			 
11ee			malloc_internal: 
11ee			    ld bc, 2           ; Number of bytes to allocate for management overhead 
11ee			    add hl, bc         ; Add management overhead to requested size 
11ee			    ex de, hl          ; Save total size in DE, and keep it in HL 
11ee					if DEBUG_FORTH_MALLOC 
11ee						DMARK "ma2" 
11ee						CALLMONITOR 
11ee					endif 
11ee			 
11ee			    ; Search for free memory block 
11ee			    ld de, (heap_end)  ; Load end of heap into DE 
11ee			    ld bc, 0           ; Initialize counter 
11ee			 
11ee					if DEBUG_FORTH_MALLOC 
11ee						DMARK "ma2" 
11ee						CALLMONITOR 
11ee					endif 
11ee			malloc_search_loop: 
11ee			    ; Check if current block is free 
11ee			    ld a, (hl)         ; Load current block's status (free or used) 
11ee			    cp 0               ; Compare with zero (free) 
11ee			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
11ee			 
11ee			    ; Check if current block is large enough 
11ee			    ld a, (hl+1)       ; Load high byte of block size 
11ee			    cp l               ; Compare with low byte of requested size 
11ee			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
11ee			 
11ee			    ld a, (hl+2)       ; Load low byte of block size 
11ee			    cp h               ; Compare with high byte of requested size 
11ee			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
11ee			 
11ee			    ; Mark block as used 
11ee			    ld (hl), 0xFF      ; Set status byte to indicate used block 
11ee			 
11ee			    ; Calculate remaining space in block 
11ee			    ld bc, 0           ; Clear BC 
11ee			    add hl, bc         ; Increment HL to point to start of data block 
11ee			    add hl, de         ; HL = HL + DE (total size) 
11ee			    ld bc, 1           ; Number of bytes to allocate for management overhead 
11ee			    add hl, bc         ; Add management overhead to start of data block 
11ee			 
11ee			    ; Save pointer to allocated block in HL 
11ee			if DEBUG_FORTH_MALLOC_HIGH 
11ee						DMARK "ma5" 
11ee			call malloc_guard_exit 
11ee			call malloc_guard_zerolen 
11ee			endif 
11ee			    ret 
11ee			 
11ee			malloc_skip_block_check: 
11ee			    ; Move to the next block 
11ee			    ld bc, 3           ; Size of management overhead 
11ee			    add hl, bc         ; Move to the next block 
11ee			    inc de             ; Increment counter 
11ee			 
11ee			    ; Check if we have reached the end of heap 
11ee			    ld a, e            ; Load low byte of heap end address 
11ee			    cp (hl)            ; Compare with low byte of current address 
11ee			    jr nz, malloc_search_loop  ; If not equal, continue searching 
11ee			    ld a, d            ; Load high byte of heap end address 
11ee			    cp 0               ; Check if it's zero (end of memory) 
11ee			    jr nz, malloc_search_loop  ; If not zero, continue searching 
11ee			 
11ee			    ; If we reached here, allocation failed 
11ee			    xor a              ; Set result to NULL 
11ee			if DEBUG_FORTH_MALLOC_HIGH 
11ee						DMARK "ma6" 
11ee			call malloc_guard_exit 
11ee			call malloc_guard_zerolen 
11ee			endif 
11ee			    ret 
11ee			malloc_exit: 
11ee			if DEBUG_FORTH_MALLOC_HIGH 
11ee						DMARK "ma7" 
11ee			call malloc_guard_exit 
11ee			call malloc_guard_zerolen 
11ee			endif 
11ee			    ret 
11ee			 
11ee			; Internal Free Function: 
11ee			; Input: 
11ee			;   HL: Pointer to memory block to free 
11ee			; Output: 
11ee			;   None 
11ee			 
11ee			free_internal: 
11ee			    ld de, (heap_start) ; Load start of heap into DE 
11ee			    ld bc, 0            ; Initialize counter 
11ee			 
11ee			free_search_loop: 
11ee			    ; Check if current block contains the pointer 
11ee			    ld a, l             ; Load low byte of pointer 
11ee			    cp (hl+1)           ; Compare with high byte of current block's address 
11ee			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
11ee			    ld a, h             ; Load high byte of pointer 
11ee			    cp (hl+2)           ; Compare with low byte of current block's address 
11ee			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
11ee			 
11ee			    ; Mark block as free 
11ee			    ld (hl), 0          ; Set status byte to indicate free block 
11ee			    ret                 ; Return 
11ee			 
11ee			free_skip_block_check: 
11ee			    ; Move to the next block 
11ee			    ld bc, 3            ; Size of management overhead 
11ee			    add hl, bc          ; Move to the next block 
11ee			    inc de              ; Increment counter 
11ee			 
11ee			    ; Check if we have reached the end of heap 
11ee			    ld a, e             ; Load low byte of heap end address 
11ee			    cp (hl)             ; Compare with low byte of current address 
11ee			    jr nz, free_search_loop  ; If not equal, continue searching 
11ee			    ld a, d             ; Load high byte of heap end address 
11ee			    cp 0                ; Check if it's zero (end of memory) 
11ee			    jr nz, free_search_loop  ; If not zero, continue searching 
11ee			 
11ee			    ; If we reached here, pointer is not found in heap 
11ee			    ret 
11ee			 
11ee			free_exit: 
11ee			    ret                 ; Return 
11ee			 
11ee			; Define heap start and end addresses 
11ee			;heap_start:    .dw 0xC000   ; Start of heap 
11ee			;heap_end:      .dw 0xE000   ; End of heap 
11ee			 
11ee			endif 
11ee			 
11ee			 
11ee			if MALLOC_1 
11ee			 
11ee			 
11ee			 
11ee			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
11ee			 
11ee			;moved to firmware.asm 
11ee			;heap_start        .equ  0x9000      ; Starting address of heap 
11ee			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
11ee			 
11ee			;      .org 0 
11ee			;      jp    main 
11ee			 
11ee			 
11ee			;      .org  0x100 
11ee			;main: 
11ee			;      ld    HL, 0x8100 
11ee			;      ld    SP, HL 
11ee			; 
11ee			;      call  heap_init 
11ee			; 
11ee			;      ; Make some allocations 
11ee			;      ld    HL, 12 
11ee			;      call  malloc            ; Allocates 0x9004 
11ee			; 
11ee			;      ld    HL, 12 
11ee			;      call  malloc            ; Allocates 0x9014 
11ee			; 
11ee			;      ld    HL, 12 
11ee			;      call  malloc            ; Allocates 0x9024 
11ee			; 
11ee			;      ; Free some allocations 
11ee			;      ld    HL, 0x9014 
11ee			;      call  free 
11ee			; 
11ee			;      ld    HL, 0x9004 
11ee			;      call  free 
11ee			; 
11ee			;      ld    HL, 0x9024 
11ee			;      call  free 
11ee			; 
11ee			; 
11ee			;      halt 
11ee			 
11ee			 
11ee			;------------------------------------------------------------------------------ 
11ee			;     heap_init                                                               : 
11ee			;                                                                             : 
11ee			; Description                                                                 : 
11ee			;     Initialise the heap and make it ready for malloc and free operations.   : 
11ee			;                                                                             : 
11ee			;     The heap is maintained as a linked list, starting with an initial       : 
11ee			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
11ee			;     the first free block in the heap. Each block then points to the next    : 
11ee			;     free block within the heap, and the free list ends at the first block   : 
11ee			;     with a null pointer to the next free block.                             : 
11ee			;                                                                             : 
11ee			; Parameters                                                                  : 
11ee			;     Inputs are compile-time only. Two defines which specify the starting    : 
11ee			;     address of the heap and its size are required, along with a memory      : 
11ee			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
11ee			;     principally stores a pointer to the first free block in the heap.       : 
11ee			;                                                                             : 
11ee			; Returns                                                                     : 
11ee			;     Nothing                                                                 : 
11ee			;------------------------------------------------------------------------------ 
11ee			heap_init: 
11ee e5			      push  HL 
11ef			 
11ef			      ; Initialise free list struct 
11ef 21 af 65		      ld    HL, heap_start 
11f2 22 aa 65		      ld    (free_list), HL 
11f5 21 00 00		      ld    HL, 0 
11f8 22 ac 65		      ld    (free_list+2), HL 
11fb			 
11fb			      ; Insert first free block at bottom of heap, consumes entire heap 
11fb 21 98 e2		      ld    HL, heap_start+heap_size-4 
11fe 22 af 65		      ld    (heap_start), HL        ; Next block (end of free list) 
1201 21 e9 7c		      ld    HL, heap_size-4 
1204 22 b1 65		      ld    (heap_start+2), HL      ; Block size 
1207			 
1207			      ; Insert end of free list block at top of heap - two null words will 
1207			      ; terminate the free list 
1207 21 00 00		      ld    HL, 0 
120a 22 9a e2		      ld    (heap_start+heap_size-2), HL 
120d 22 98 e2		      ld    (heap_start+heap_size-4), HL 
1210			 
1210 e1			      pop   HL 
1211			 
1211 c9			      ret 
1212			 
1212			 
1212			;------------------------------------------------------------------------------ 
1212			;     malloc                                                                  : 
1212			;                                                                             : 
1212			; Description                                                                 : 
1212			;     Allocates the wanted space from the heap and returns the address of the : 
1212			;     first useable byte of the allocation.                                   : 
1212			;                                                                             : 
1212			;     Allocations can happen in one of two ways:                              : 
1212			;                                                                             : 
1212			;     1. A free block may be found which is the exact size wanted. In this    : 
1212			;        case the block is removed from the free list and retuedn to the      : 
1212			;        caller.                                                              : 
1212			;     2. A free block may be found which is larger than the size wanted. In   : 
1212			;        this case, the larger block is split into two. The first portion of  : 
1212			;        this block will become the requested space by the malloc call and    : 
1212			;        is returned to the caller. The second portion becomes a new free     : 
1212			;        block, and the free list is adjusted to maintain continuity via this : 
1212			;        newly created block.                                                 : 
1212			;                                                                             : 
1212			;     malloc does not set any initial value in the allocated space, the       : 
1212			;     caller is required to do this as required.                              : 
1212			;                                                                             : 
1212			;     This implementation of malloc uses the stack exclusively, and is        : 
1212			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1212			;     advisable to disable interrupts before calling malloc, and recommended  : 
1212			;     to avoid the use of malloc inside ISRs in general.                      : 
1212			;                                                                             : 
1212			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1212			;                                                                             : 
1212			; Parameters                                                                  : 
1212			;     HL  Number of bytes wanted                                              : 
1212			;                                                                             : 
1212			; Returns                                                                     : 
1212			;     HL  Address of the first useable byte of the allocation                 : 
1212			;                                                                             : 
1212			; Flags                                                                       : 
1212			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1212			;                                                                             : 
1212			; Stack frame                                                                 : 
1212			;       |             |                                                       : 
1212			;       +-------------+                                                       : 
1212			;       |     BC      |                                                       : 
1212			;       +-------------+                                                       : 
1212			;       |     DE      |                                                       : 
1212			;       +-------------+                                                       : 
1212			;       |     IX      |                                                       : 
1212			;       +-------------+                                                       : 
1212			;       |  prev_free  |                                                       : 
1212			;   +4  +-------------+                                                       : 
1212			;       |  this_free  |                                                       : 
1212			;   +2  +-------------+                                                       : 
1212			;       |  next_free  |                                                       : 
1212			;   +0  +-------------+                                                       : 
1212			;       |             |                                                       : 
1212			;                                                                             : 
1212			;------------------------------------------------------------------------------ 
1212			 
1212			 
1212			;malloc: 
1212			; 
1212			;	SAVESP ON 1 
1212			; 
1212			;	call malloc_code 
1212			; 
1212			;	CHECKSP ON 1 
1212			;	ret 
1212			 
1212			 
1212			malloc: 
1212 c5			      push  BC 
1213 d5			      push  DE 
1214 dd e5		      push  IX 
1216			if DEBUG_FORTH_MALLOC_HIGH 
1216			call malloc_guard_entry 
1216			endif 
1216			 
1216					if DEBUG_FORTH_MALLOC 
1216						DMARK "mal" 
1216						CALLMONITOR 
1216					endif 
1216 7c			      ld    A, H                    ; Exit if no space requested 
1217 b5			      or    L 
1218 ca d7 12		      jp    Z, malloc_early_exit 
121b			 
121b			;inc hl 
121b			;inc hl 
121b			;inc hl 
121b			; 
121b			;inc hl 
121b			;inc hl 
121b			;inc hl 
121b			;inc hl 
121b			;inc hl 
121b			;inc hl 
121b			;inc hl 
121b			;inc hl 
121b			;inc hl 
121b			 
121b			 
121b			 
121b			 
121b					if DEBUG_FORTH_MALLOC 
121b						DMARK "maA" 
121b						CALLMONITOR 
121b					endif 
121b			      ; Set up stack frame 
121b eb			      ex    DE, HL 
121c 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
121f 39			      add   HL, SP 
1220 f9			      ld    SP, HL 
1221 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1225 dd 39		      add   IX, SP 
1227			 
1227			      ; Setup initial state 
1227 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
122a 19			      add   HL, DE 
122b			 
122b 44			      ld    B, H                    ; Move want to BC 
122c 4d			      ld    C, L 
122d			 
122d 21 aa 65		      ld    HL, free_list           ; Store prev_free ptr to stack 
1230 dd 75 04		      ld    (IX+4), L 
1233 dd 74 05		      ld    (IX+5), H 
1236			 
1236 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
1237 23			      inc   HL 
1238 56			      ld    D, (HL) 
1239 dd 73 02		      ld    (IX+2), E 
123c dd 72 03		      ld    (IX+3), D 
123f eb			      ex    DE, HL                  ; this_free ptr into HL 
1240			 
1240					if DEBUG_FORTH_MALLOC 
1240						DMARK "maB" 
1240						CALLMONITOR 
1240					endif 
1240			      ; Loop through free block list to find some space 
1240			malloc_find_space: 
1240 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
1241 23			      inc   HL 
1242 56			      ld    D, (HL) 
1243			 
1243 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1244 b3			      or    E 
1245 ca d1 12		      jp    Z, malloc_no_space 
1248			 
1248 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
124b dd 72 01		      ld    (IX+1), D 
124e			 
124e			      ; Does this block have enough space to make the allocation? 
124e 23			      inc   HL                      ; Load free block size into DE 
124f 5e			      ld    E, (HL) 
1250 23			      inc   HL 
1251 56			      ld    D, (HL) 
1252			 
1252 eb			      ex    DE, HL                  ; Check size of block against want 
1253 b7			      or    A                       ; Ensure carry flag clear 
1254 ed 42		      sbc   HL, BC 
1256 e5			      push  HL                      ; Store the result for later (new block size) 
1257			 
1257 ca a6 12		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
125a 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
125c			 
125c			      ; this_free block is not big enough, setup ptrs to test next free block 
125c e1			      pop   HL                      ; Discard previous result 
125d			 
125d dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1260 dd 66 03		      ld    H, (IX+3) 
1263 dd 75 04		      ld    (IX+4), L 
1266 dd 74 05		      ld    (IX+5), H 
1269			 
1269 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
126c dd 66 01		      ld    H, (IX+1) 
126f dd 75 02		      ld    (IX+2), L 
1272 dd 74 03		      ld    (IX+3), H 
1275			 
1275					if DEBUG_FORTH_MALLOC 
1275						DMARK "MA>" 
1275						CALLMONITOR 
1275					endif 
1275 18 c9		      jr    malloc_find_space 
1277			 
1277			      ; split a bigger block into two - requested size and remaining size 
1277			malloc_alloc_split: 
1277					if DEBUG_FORTH_MALLOC 
1277						DMARK "MAs" 
1277						CALLMONITOR 
1277					endif 
1277 eb			      ex    DE, HL                  ; Calculate address of new free block 
1278 2b			      dec   HL 
1279 2b			      dec   HL 
127a 2b			      dec   HL 
127b 09			      add   HL, BC 
127c			 
127c			      ; Create a new block and point it at next_free 
127c dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
127f dd 56 01		      ld    D, (IX+1) 
1282			 
1282 73			      ld    (HL), E                 ; Store next_free ptr into new block 
1283 23			      inc   HL 
1284 72			      ld    (HL), D 
1285			 
1285 d1			      pop   DE                      ; Store size of new block into new block 
1286 23			      inc   HL 
1287 73			      ld    (HL), E 
1288 23			      inc   HL 
1289 72			      ld    (HL), D 
128a			 
128a			      ; Update this_free ptr to point to new block 
128a 2b			      dec   HL 
128b 2b			      dec   HL 
128c 2b			      dec   HL 
128d			 
128d dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1290 dd 56 03		      ld    D, (IX+3) 
1293			 
1293 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1296 dd 74 03		      ld    (IX+3), H 
1299			 
1299			      ; Modify this_free block to be allocation 
1299 eb			      ex    DE, HL 
129a af			      xor   A                       ; Null the next block ptr of allocated block 
129b 77			      ld    (HL), A 
129c 23			      inc   HL 
129d 77			      ld    (HL), A 
129e			 
129e 23			      inc   HL                      ; Store want size into allocated block 
129f 71			      ld    (HL), C 
12a0 23			      inc   HL 
12a1 70			      ld    (HL), B 
12a2 23			      inc   HL 
12a3 e5			      push  HL                      ; Address of allocation to return 
12a4			 
12a4 18 19		      jr    malloc_update_links 
12a6			 
12a6			malloc_alloc_fit: 
12a6 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
12a7			 
12a7					if DEBUG_FORTH_MALLOC 
12a7						DMARK "MAf" 
12a7						CALLMONITOR 
12a7					endif 
12a7			      ; Modify this_free block to be allocation 
12a7 eb			      ex    DE, HL 
12a8 2b			      dec   HL 
12a9 2b			      dec   HL 
12aa 2b			      dec   HL 
12ab			 
12ab af			      xor   A                       ; Null the next block ptr of allocated block 
12ac 77			      ld    (HL), A 
12ad 23			      inc   HL 
12ae 77			      ld    (HL), A 
12af			 
12af 23			      inc   HL                      ; Store address of allocation to return 
12b0 23			      inc   HL 
12b1 23			      inc   HL 
12b2 e5			      push  HL 
12b3			 
12b3			      ; Copy next_free ptr to this_free, remove allocated block from free list 
12b3 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
12b6 dd 66 01		      ld    H, (IX+1) 
12b9			 
12b9 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
12bc dd 74 03		      ld    (IX+3), H 
12bf			 
12bf			 
12bf			malloc_update_links: 
12bf			      ; Update prev_free ptr to point to this_free 
12bf dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
12c2 dd 66 05		      ld    H, (IX+5) 
12c5			 
12c5 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
12c8 dd 56 03		      ld    D, (IX+3) 
12cb			 
12cb 73			      ld    (HL), E                 ; this_free ptr into prev_free 
12cc 23			      inc   HL 
12cd 72			      ld    (HL), D 
12ce			 
12ce					if DEBUG_FORTH_MALLOC 
12ce						DMARK "Mul" 
12ce						CALLMONITOR 
12ce					endif 
12ce			      ; Clear the Z flag to indicate successful allocation 
12ce 7a			      ld    A, D 
12cf b3			      or    E 
12d0			 
12d0 d1			      pop   DE                      ; Address of allocation 
12d1					if DEBUG_FORTH_MALLOC 
12d1						DMARK "MAu" 
12d1						CALLMONITOR 
12d1					endif 
12d1			 
12d1			malloc_no_space: 
12d1 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
12d4 39			      add   HL, SP 
12d5 f9			      ld    SP, HL 
12d6			 
12d6 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
12d7					if DEBUG_FORTH_MALLOC 
12d7						DMARK "MAN" 
12d7						CALLMONITOR 
12d7					endif 
12d7			 
12d7			malloc_early_exit: 
12d7					if DEBUG_FORTH_MALLOC 
12d7						DMARK "MAx" 
12d7						CALLMONITOR 
12d7					endif 
12d7 dd e1		      pop   IX 
12d9 d1			      pop   DE 
12da c1			      pop   BC 
12db			 
12db			if DEBUG_FORTH_MALLOC_HIGH 
12db			call malloc_guard_exit 
12db			call malloc_guard_zerolen 
12db			endif 
12db c9			      ret 
12dc			 
12dc			 
12dc			;------------------------------------------------------------------------------ 
12dc			;     free                                                                    : 
12dc			;                                                                             : 
12dc			; Description                                                                 : 
12dc			;     Return the space pointed to by HL to the heap. HL must be an address as : 
12dc			;     returned by malloc, otherwise the behaviour is undefined.               : 
12dc			;                                                                             : 
12dc			;     Where possible, directly adjacent free blocks will be merged together   : 
12dc			;     into larger blocks to help ensure that the heap does not become         : 
12dc			;     excessively fragmented.                                                 : 
12dc			;                                                                             : 
12dc			;     free does not clear or set any other value into the freed space, and    : 
12dc			;     therefore its contents may be visible through subsequent malloc's. The  : 
12dc			;     caller should clear the freed space as required.                        : 
12dc			;                                                                             : 
12dc			;     This implementation of free uses the stack exclusively, and is          : 
12dc			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
12dc			;     advisable to disable interrupts before calling free, and recommended    : 
12dc			;     to avoid the use of free inside ISRs in general.                        : 
12dc			;                                                                             : 
12dc			;     NOTE: heap_init must be called before malloc and free can be used.      : 
12dc			;                                                                             : 
12dc			; Parameters                                                                  : 
12dc			;     HL  Pointer to address of first byte of allocation to be freed          : 
12dc			;                                                                             : 
12dc			; Returns                                                                     : 
12dc			;     Nothing                                                                 : 
12dc			;                                                                             : 
12dc			; Stack frame                                                                 : 
12dc			;       |             |                                                       : 
12dc			;       +-------------+                                                       : 
12dc			;       |     BC      |                                                       : 
12dc			;       +-------------+                                                       : 
12dc			;       |     DE      |                                                       : 
12dc			;       +-------------+                                                       : 
12dc			;       |     IX      |                                                       : 
12dc			;       +-------------+                                                       : 
12dc			;       |  prev_free  |                                                       : 
12dc			;   +2  +-------------+                                                       : 
12dc			;       |  next_free  |                                                       : 
12dc			;   +0  +-------------+                                                       : 
12dc			;       |             |                                                       : 
12dc			;                                                                             : 
12dc			;------------------------------------------------------------------------------ 
12dc			free: 
12dc c5			      push  BC 
12dd d5			      push  DE 
12de dd e5		      push  IX 
12e0			 
12e0 7c			      ld    A, H                    ; Exit if ptr is null 
12e1 b5			      or    L 
12e2 ca a6 13		      jp    Z, free_early_exit 
12e5			 
12e5			      ; Set up stack frame 
12e5 eb			      ex    DE, HL 
12e6 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
12e9 39			      add   HL, SP 
12ea f9			      ld    SP, HL 
12eb dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
12ef dd 39		      add   IX, SP 
12f1			 
12f1			      ; The address in HL points to the start of the useable allocated space, 
12f1			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
12f1			      ; address of the block itself. 
12f1 eb			      ex    DE, HL 
12f2 11 fc ff		      ld    DE, -4 
12f5 19			      add   HL, DE 
12f6			 
12f6			      ; An allocated block must have a null next block pointer in it 
12f6 7e			      ld    A, (HL) 
12f7 23			      inc   HL 
12f8 b6			      or    (HL) 
12f9 c2 a1 13		      jp    NZ, free_done 
12fc			 
12fc 2b			      dec   HL 
12fd			 
12fd 44			      ld    B, H                    ; Copy HL to BC 
12fe 4d			      ld    C, L 
12ff			 
12ff			      ; Loop through the free list to find the first block with an address 
12ff			      ; higher than the block being freed 
12ff 21 aa 65		      ld    HL, free_list 
1302			 
1302			free_find_higher_block: 
1302 5e			      ld    E, (HL)                 ; Load next ptr from free block 
1303 23			      inc   HL 
1304 56			      ld    D, (HL) 
1305 2b			      dec   HL 
1306			 
1306 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
1309 dd 72 01		      ld    (IX+1), D 
130c dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
130f dd 74 03		      ld    (IX+3), H 
1312			 
1312 78			      ld    A, B                    ; Check if DE is greater than BC 
1313 ba			      cp    D                       ; Compare MSB first 
1314 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
1316 30 04		      jr    NC, free_find_higher_block_skip 
1318 79			      ld    A, C 
1319 bb			      cp    E                       ; Then compare LSB 
131a 38 08		      jr    C, free_found_higher_block 
131c			 
131c			free_find_higher_block_skip: 
131c 7a			      ld    A, D                    ; Reached the end of the free list? 
131d b3			      or    E 
131e ca a1 13		      jp    Z, free_done 
1321			 
1321 eb			      ex    DE, HL 
1322			 
1322 18 de		      jr    free_find_higher_block 
1324			 
1324			free_found_higher_block: 
1324			      ; Insert freed block between prev and next free blocks 
1324 71			      ld    (HL), C                 ; Point prev free block to freed block 
1325 23			      inc   HL 
1326 70			      ld    (HL), B 
1327			 
1327 60			      ld    H, B                    ; Point freed block at next free block 
1328 69			      ld    L, C 
1329 73			      ld    (HL), E 
132a 23			      inc   HL 
132b 72			      ld    (HL), D 
132c			 
132c			      ; Check if the freed block is adjacent to the next free block 
132c 23			      inc   HL                      ; Load size of freed block into HL 
132d 5e			      ld    E, (HL) 
132e 23			      inc   HL 
132f 56			      ld    D, (HL) 
1330 eb			      ex    DE, HL 
1331			 
1331 09			      add   HL, BC                  ; Add addr of freed block and its size 
1332			 
1332 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
1335 dd 56 01		      ld    D, (IX+1) 
1338			 
1338 b7			      or    A                       ; Clear the carry flag 
1339 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
133b 20 22		      jr    NZ, free_check_adjacent_to_prev 
133d			 
133d			      ; Freed block is adjacent to next, merge into one bigger block 
133d eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
133e 5e			      ld    E, (HL) 
133f 23			      inc   HL 
1340 56			      ld    D, (HL) 
1341 e5			      push  HL                      ; Save ptr to next block for later 
1342			 
1342 60			      ld    H, B                    ; Store ptr from next block into freed block 
1343 69			      ld    L, C 
1344 73			      ld    (HL), E 
1345 23			      inc   HL 
1346 72			      ld    (HL), D 
1347			 
1347 e1			      pop   HL                      ; Restore ptr to next block 
1348 23			      inc   HL                      ; Load size of next block into DE 
1349 5e			      ld    E, (HL) 
134a 23			      inc   HL 
134b 56			      ld    D, (HL) 
134c d5			      push  DE                      ; Save next block size for later 
134d			 
134d 60			      ld    H, B                    ; Load size of freed block into HL 
134e 69			      ld    L, C 
134f 23			      inc   HL 
1350 23			      inc   HL 
1351 5e			      ld    E, (HL) 
1352 23			      inc   HL 
1353 56			      ld    D, (HL) 
1354 eb			      ex    DE, HL 
1355			 
1355 d1			      pop   DE                      ; Restore size of next block 
1356 19			      add   HL, DE                  ; Add sizes of both blocks 
1357 eb			      ex    DE, HL 
1358			 
1358 60			      ld    H, B                    ; Store new bigger size into freed block 
1359 69			      ld    L, C 
135a 23			      inc   HL 
135b 23			      inc   HL 
135c 73			      ld    (HL), E 
135d 23			      inc   HL 
135e 72			      ld    (HL), D 
135f			 
135f			free_check_adjacent_to_prev: 
135f			      ; Check if the freed block is adjacent to the prev free block 
135f dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
1362 dd 66 03		      ld    H, (IX+3) 
1365			 
1365 23			      inc   HL                      ; Size of prev free block into DE 
1366 23			      inc   HL 
1367 5e			      ld    E, (HL) 
1368 23			      inc   HL 
1369 56			      ld    D, (HL) 
136a 2b			      dec   HL 
136b 2b			      dec   HL 
136c 2b			      dec   HL 
136d			 
136d 19			      add   HL, DE                  ; Add prev block addr and size 
136e			 
136e b7			      or    A                       ; Clear the carry flag 
136f ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1371 20 2e		      jr    NZ, free_done 
1373			 
1373			      ; Freed block is adjacent to prev, merge into one bigger block 
1373 60			      ld    H, B                    ; Load next ptr from freed block into DE 
1374 69			      ld    L, C 
1375 5e			      ld    E, (HL) 
1376 23			      inc   HL 
1377 56			      ld    D, (HL) 
1378 e5			      push  HL                      ; Save freed block ptr for later 
1379			 
1379 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
137c dd 66 03		      ld    H, (IX+3) 
137f 73			      ld    (HL), E 
1380 23			      inc   HL 
1381 72			      ld    (HL), D 
1382			 
1382 e1			      pop   HL                      ; Restore freed block ptr 
1383 23			      inc   HL                      ; Load size of freed block into DE 
1384 5e			      ld    E, (HL) 
1385 23			      inc   HL 
1386 56			      ld    D, (HL) 
1387 d5			      push  DE                      ; Save freed block size for later 
1388			 
1388 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
138b dd 66 03		      ld    H, (IX+3) 
138e 23			      inc   HL 
138f 23			      inc   HL 
1390 5e			      ld    E, (HL) 
1391 23			      inc   HL 
1392 56			      ld    D, (HL) 
1393			 
1393 e1			      pop   HL                      ; Add sizes of both blocks 
1394 19			      add   HL, DE 
1395 eb			      ex    DE, HL 
1396			 
1396 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1399 dd 66 03		      ld    H, (IX+3) 
139c 23			      inc   HL 
139d 23			      inc   HL 
139e 73			      ld    (HL), E 
139f 23			      inc   HL 
13a0 72			      ld    (HL), D 
13a1			 
13a1			free_done: 
13a1 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
13a4 39			      add   HL, SP 
13a5 f9			      ld    SP, HL 
13a6			 
13a6			free_early_exit: 
13a6 dd e1		      pop   IX 
13a8 d1			      pop   DE 
13a9 c1			      pop   BC 
13aa			 
13aa c9			      ret 
13ab			 
13ab			; moved to firmware.asm 
13ab			; 
13ab			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
13ab			;                  .dw   0 
13ab			 
13ab			 
13ab			endif 
13ab			 
13ab			 
13ab			if MALLOC_3 
13ab			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
13ab			;heap_start        .equ  0x9000      ; Starting address of heap 
13ab			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
13ab			; 
13ab			 ;     .org 0 
13ab			  ;    jp    main 
13ab			; 
13ab			; 
13ab			 ;     .org  0x100 
13ab			;main: 
13ab			 ;     ld    HL, 0x8100 
13ab			  ;    ld    SP, HL 
13ab			; 
13ab			;      call  heap_init 
13ab			 
13ab			      ; Make some allocations 
13ab			;      ld    HL, 12 
13ab			;      call  malloc            ; Allocates 0x9004 
13ab			; 
13ab			 ;     ld    HL, 12 
13ab			;      call  malloc            ; Allocates 0x9014 
13ab			 
13ab			;      ld    HL, 12 
13ab			;      call  malloc            ; Allocates 0x9024 
13ab			 
13ab			      ; Free some allocations 
13ab			;      ld    HL, 0x9014 
13ab			;      call  free 
13ab			 
13ab			;      ld    HL, 0x9004 
13ab			;      call  free 
13ab			; 
13ab			;      ld    HL, 0x9024 
13ab			;      call  free 
13ab			 
13ab			 
13ab			 ;     halt 
13ab			 
13ab			 
13ab			;------------------------------------------------------------------------------ 
13ab			;     heap_init                                                               : 
13ab			;                                                                             : 
13ab			; Description                                                                 : 
13ab			;     Initialise the heap and make it ready for malloc and free operations.   : 
13ab			;                                                                             : 
13ab			;     The heap is maintained as a linked list, starting with an initial       : 
13ab			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
13ab			;     the first free block in the heap. Each block then points to the next    : 
13ab			;     free block within the heap, and the free list ends at the first block   : 
13ab			;     with a null pointer to the next free block.                             : 
13ab			;                                                                             : 
13ab			; Parameters                                                                  : 
13ab			;     Inputs are compile-time only. Two defines which specify the starting    : 
13ab			;     address of the heap and its size are required, along with a memory      : 
13ab			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
13ab			;     principally stores a pointer to the first free block in the heap.       : 
13ab			;                                                                             : 
13ab			; Returns                                                                     : 
13ab			;     Nothing                                                                 : 
13ab			;------------------------------------------------------------------------------ 
13ab			heap_init: 
13ab			      push  HL 
13ab			 
13ab			      ; Initialise free list struct 
13ab			      ld    HL, heap_start 
13ab			      ld    (free_list), HL 
13ab			      ld    HL, 0 
13ab			      ld    (free_list+2), HL 
13ab			 
13ab			      ; Insert first free block at bottom of heap, consumes entire heap 
13ab			      ld    HL, heap_start+heap_size-4 
13ab			      ld    (heap_start), HL        ; Next block (end of free list) 
13ab			      ld    HL, heap_size-4 
13ab			      ld    (heap_start+2), HL      ; Block size 
13ab			 
13ab			      ; Insert end of free list block at top of heap - two null words will 
13ab			      ; terminate the free list 
13ab			      ld    HL, 0 
13ab			      ld    (heap_start+heap_size-2), HL 
13ab			      ld    (heap_start+heap_size-4), HL 
13ab			 
13ab			      pop   HL 
13ab			 
13ab			      ret 
13ab			 
13ab			 
13ab			;------------------------------------------------------------------------------ 
13ab			;     malloc                                                                  : 
13ab			;                                                                             : 
13ab			; Description                                                                 : 
13ab			;     Allocates the wanted space from the heap and returns the address of the : 
13ab			;     first useable byte of the allocation.                                   : 
13ab			;                                                                             : 
13ab			;     Allocations can happen in one of two ways:                              : 
13ab			;                                                                             : 
13ab			;     1. A free block may be found which is the exact size wanted. In this    : 
13ab			;        case the block is removed from the free list and retuedn to the      : 
13ab			;        caller.                                                              : 
13ab			;     2. A free block may be found which is larger than the size wanted. In   : 
13ab			;        this case, the larger block is split into two. The first portion of  : 
13ab			;        this block will become the requested space by the malloc call and    : 
13ab			;        is returned to the caller. The second portion becomes a new free     : 
13ab			;        block, and the free list is adjusted to maintain continuity via this : 
13ab			;        newly created block.                                                 : 
13ab			;                                                                             : 
13ab			;     malloc does not set any initial value in the allocated space, the       : 
13ab			;     caller is required to do this as required.                              : 
13ab			;                                                                             : 
13ab			;     This implementation of malloc uses the stack exclusively, and is        : 
13ab			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
13ab			;     advisable to disable interrupts before calling malloc, and recommended  : 
13ab			;     to avoid the use of malloc inside ISRs in general.                      : 
13ab			;                                                                             : 
13ab			;     NOTE: heap_init must be called before malloc and free can be used.      : 
13ab			;                                                                             : 
13ab			; Parameters                                                                  : 
13ab			;     HL  Number of bytes wanted                                              : 
13ab			;                                                                             : 
13ab			; Returns                                                                     : 
13ab			;     HL  Address of the first useable byte of the allocation                 : 
13ab			;                                                                             : 
13ab			; Flags                                                                       : 
13ab			;     Z   Set if the allocation did not succeed, clear otherwise              : 
13ab			;                                                                             : 
13ab			; Stack frame                                                                 : 
13ab			;       |             |                                                       : 
13ab			;       +-------------+                                                       : 
13ab			;       |     BC      |                                                       : 
13ab			;       +-------------+                                                       : 
13ab			;       |     DE      |                                                       : 
13ab			;       +-------------+                                                       : 
13ab			;       |     IX      |                                                       : 
13ab			;       +-------------+                                                       : 
13ab			;       |  prev_free  |                                                       : 
13ab			;   +4  +-------------+                                                       : 
13ab			;       |  this_free  |                                                       : 
13ab			;   +2  +-------------+                                                       : 
13ab			;       |  next_free  |                                                       : 
13ab			;   +0  +-------------+                                                       : 
13ab			;       |             |                                                       : 
13ab			;                                                                             : 
13ab			;------------------------------------------------------------------------------ 
13ab			malloc: 
13ab			      push  BC 
13ab			      push  DE 
13ab			      push  IX 
13ab			 
13ab			      ld    A, H                    ; Exit if no space requested 
13ab			      or    L 
13ab			      jp    Z, malloc_early_exit 
13ab			 
13ab			      ; Set up stack frame 
13ab			      ex    DE, HL 
13ab			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
13ab			      add   HL, SP 
13ab			      ld    SP, HL 
13ab			      ld    IX, 0                   ; Use IX as a frame pointer 
13ab			      add   IX, SP 
13ab			 
13ab			      ; Setup initial state 
13ab			      ld    HL, 4                   ; want must also include space used by block struct 
13ab			      add   HL, DE 
13ab			 
13ab			      ld    B, H                    ; Move want to BC 
13ab			      ld    C, L 
13ab			 
13ab			      ld    HL, free_list           ; Store prev_free ptr to stack 
13ab			      ld    (IX+4), L 
13ab			      ld    (IX+5), H 
13ab			 
13ab			      ld    E, (HL)                 ; Store this_free ptr to stack 
13ab			      inc   HL 
13ab			      ld    D, (HL) 
13ab			      ld    (IX+2), E 
13ab			      ld    (IX+3), D 
13ab			      ex    DE, HL                  ; this_free ptr into HL 
13ab			 
13ab			      ; Loop through free block list to find some space 
13ab			malloc_find_space: 
13ab			      ld    E, (HL)                 ; Load next_free ptr into DE 
13ab			      inc   HL 
13ab			      ld    D, (HL) 
13ab			 
13ab			      ld    A, D                    ; Check for null next_free ptr - end of free list 
13ab			      or    E 
13ab			      jp    Z, malloc_no_space 
13ab			 
13ab			      ld    (IX+0), E               ; Store next_free ptr to stack 
13ab			      ld    (IX+1), D 
13ab			 
13ab			      ; Does this block have enough space to make the allocation? 
13ab			      inc   HL                      ; Load free block size into DE 
13ab			      ld    E, (HL) 
13ab			      inc   HL 
13ab			      ld    D, (HL) 
13ab			 
13ab			      ex    DE, HL                  ; Check size of block against want 
13ab			      or    A                       ; Ensure carry flag clear 
13ab			      sbc   HL, BC 
13ab			      push  HL                      ; Store the result for later (new block size) 
13ab			 
13ab			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
13ab			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
13ab			 
13ab			      ; this_free block is not big enough, setup ptrs to test next free block 
13ab			      pop   HL                      ; Discard previous result 
13ab			 
13ab			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
13ab			      ld    H, (IX+3) 
13ab			      ld    (IX+4), L 
13ab			      ld    (IX+5), H 
13ab			 
13ab			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
13ab			      ld    H, (IX+1) 
13ab			      ld    (IX+2), L 
13ab			      ld    (IX+3), H 
13ab			 
13ab			      jr    malloc_find_space 
13ab			 
13ab			      ; split a bigger block into two - requested size and remaining size 
13ab			malloc_alloc_split: 
13ab			      ex    DE, HL                  ; Calculate address of new free block 
13ab			      dec   HL 
13ab			      dec   HL 
13ab			      dec   HL 
13ab			      add   HL, BC 
13ab			 
13ab			      ; Create a new block and point it at next_free 
13ab			      ld    E, (IX+0)               ; Load next_free ptr into DE 
13ab			      ld    D, (IX+1) 
13ab			 
13ab			      ld    (HL), E                 ; Store next_free ptr into new block 
13ab			      inc   HL 
13ab			      ld    (HL), D 
13ab			 
13ab			      pop   DE                      ; Store size of new block into new block 
13ab			      inc   HL 
13ab			      ld    (HL), E 
13ab			      inc   HL 
13ab			      ld    (HL), D 
13ab			 
13ab			      ; Update this_free ptr to point to new block 
13ab			      dec   HL 
13ab			      dec   HL 
13ab			      dec   HL 
13ab			 
13ab			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
13ab			      ld    D, (IX+3) 
13ab			 
13ab			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
13ab			      ld    (IX+3), H 
13ab			 
13ab			      ; Modify this_free block to be allocation 
13ab			      ex    DE, HL 
13ab			      xor   A                       ; Null the next block ptr of allocated block 
13ab			      ld    (HL), A 
13ab			      inc   HL 
13ab			      ld    (HL), A 
13ab			 
13ab			      inc   HL                      ; Store want size into allocated block 
13ab			      ld    (HL), C 
13ab			      inc   HL 
13ab			      ld    (HL), B 
13ab			      inc   HL 
13ab			      push  HL                      ; Address of allocation to return 
13ab			 
13ab			      jr    malloc_update_links 
13ab			 
13ab			malloc_alloc_fit: 
13ab			      pop   HL                      ; Dont need new block size, want is exact fit 
13ab			 
13ab			      ; Modify this_free block to be allocation 
13ab			      ex    DE, HL 
13ab			      dec   HL 
13ab			      dec   HL 
13ab			      dec   HL 
13ab			 
13ab			      xor   A                       ; Null the next block ptr of allocated block 
13ab			      ld    (HL), A 
13ab			      inc   HL 
13ab			      ld    (HL), A 
13ab			 
13ab			      inc   HL                      ; Store address of allocation to return 
13ab			      inc   HL 
13ab			      inc   HL 
13ab			      push  HL 
13ab			 
13ab			      ; Copy next_free ptr to this_free, remove allocated block from free list 
13ab			      ld    L, (IX+0)               ; next_free to HL 
13ab			      ld    H, (IX+1) 
13ab			 
13ab			      ld    (IX+2), L               ; HL to this_free 
13ab			      ld    (IX+3), H 
13ab			 
13ab			 
13ab			malloc_update_links: 
13ab			      ; Update prev_free ptr to point to this_free 
13ab			      ld    L, (IX+4)               ; prev_free ptr to HL 
13ab			      ld    H, (IX+5) 
13ab			 
13ab			      ld    E, (IX+2)               ; this_free ptr to DE 
13ab			      ld    D, (IX+3) 
13ab			 
13ab			      ld    (HL), E                 ; this_free ptr into prev_free 
13ab			      inc   HL 
13ab			      ld    (HL), D 
13ab			 
13ab			      ; Clear the Z flag to indicate successful allocation 
13ab			      ld    A, D 
13ab			      or    E 
13ab			 
13ab			      pop   DE                      ; Address of allocation 
13ab			 
13ab			malloc_no_space: 
13ab			      ld    HL, 6                   ; Clean up stack frame 
13ab			      add   HL, SP 
13ab			      ld    SP, HL 
13ab			 
13ab			      ex    DE, HL                  ; Alloc addr into HL for return 
13ab			 
13ab			malloc_early_exit: 
13ab			      pop   IX 
13ab			      pop   DE 
13ab			      pop   BC 
13ab			 
13ab			      ret 
13ab			 
13ab			 
13ab			;------------------------------------------------------------------------------ 
13ab			;     free                                                                    : 
13ab			;                                                                             : 
13ab			; Description                                                                 : 
13ab			;     Return the space pointed to by HL to the heap. HL must be an address as : 
13ab			;     returned by malloc, otherwise the behaviour is undefined.               : 
13ab			;                                                                             : 
13ab			;     Where possible, directly adjacent free blocks will be merged together   : 
13ab			;     into larger blocks to help ensure that the heap does not become         : 
13ab			;     excessively fragmented.                                                 : 
13ab			;                                                                             : 
13ab			;     free does not clear or set any other value into the freed space, and    : 
13ab			;     therefore its contents may be visible through subsequent malloc's. The  : 
13ab			;     caller should clear the freed space as required.                        : 
13ab			;                                                                             : 
13ab			;     This implementation of free uses the stack exclusively, and is          : 
13ab			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
13ab			;     advisable to disable interrupts before calling free, and recommended    : 
13ab			;     to avoid the use of free inside ISRs in general.                        : 
13ab			;                                                                             : 
13ab			;     NOTE: heap_init must be called before malloc and free can be used.      : 
13ab			;                                                                             : 
13ab			; Parameters                                                                  : 
13ab			;     HL  Pointer to address of first byte of allocation to be freed          : 
13ab			;                                                                             : 
13ab			; Returns                                                                     : 
13ab			;     Nothing                                                                 : 
13ab			;                                                                             : 
13ab			; Stack frame                                                                 : 
13ab			;       |             |                                                       : 
13ab			;       +-------------+                                                       : 
13ab			;       |     BC      |                                                       : 
13ab			;       +-------------+                                                       : 
13ab			;       |     DE      |                                                       : 
13ab			;       +-------------+                                                       : 
13ab			;       |     IX      |                                                       : 
13ab			;       +-------------+                                                       : 
13ab			;       |  prev_free  |                                                       : 
13ab			;   +2  +-------------+                                                       : 
13ab			;       |  next_free  |                                                       : 
13ab			;   +0  +-------------+                                                       : 
13ab			;       |             |                                                       : 
13ab			;                                                                             : 
13ab			;------------------------------------------------------------------------------ 
13ab			free: 
13ab			      push  BC 
13ab			      push  DE 
13ab			      push  IX 
13ab			 
13ab			      ld    A, H                    ; Exit if ptr is null 
13ab			      or    L 
13ab			      jp    Z, free_early_exit 
13ab			 
13ab			      ; Set up stack frame 
13ab			      ex    DE, HL 
13ab			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
13ab			      add   HL, SP 
13ab			      ld    SP, HL 
13ab			      ld    IX, 0                   ; Use IX as a frame pointer 
13ab			      add   IX, SP 
13ab			 
13ab			      ; The address in HL points to the start of the useable allocated space, 
13ab			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
13ab			      ; address of the block itself. 
13ab			      ex    DE, HL 
13ab			      ld    DE, -4 
13ab			      add   HL, DE 
13ab			 
13ab			      ; An allocated block must have a null next block pointer in it 
13ab			      ld    A, (HL) 
13ab			      inc   HL 
13ab			      or    (HL) 
13ab			      jp    NZ, free_done 
13ab			 
13ab			      dec   HL 
13ab			 
13ab			      ld    B, H                    ; Copy HL to BC 
13ab			      ld    C, L 
13ab			 
13ab			      ; Loop through the free list to find the first block with an address 
13ab			      ; higher than the block being freed 
13ab			      ld    HL, free_list 
13ab			 
13ab			free_find_higher_block: 
13ab			      ld    E, (HL)                 ; Load next ptr from free block 
13ab			      inc   HL 
13ab			      ld    D, (HL) 
13ab			      dec   HL 
13ab			 
13ab			      ld    (IX+0), E               ; Save ptr to next free block 
13ab			      ld    (IX+1), D 
13ab			      ld    (IX+2), L               ; Save ptr to prev free block 
13ab			      ld    (IX+3), H 
13ab			 
13ab			      ld    A, B                    ; Check if DE is greater than BC 
13ab			      cp    D                       ; Compare MSB first 
13ab			      jr    Z, $+4                  ; MSB the same, compare LSB 
13ab			      jr    NC, free_find_higher_block_skip 
13ab			      ld    A, C 
13ab			      cp    E                       ; Then compare LSB 
13ab			      jr    C, free_found_higher_block 
13ab			 
13ab			free_find_higher_block_skip: 
13ab			      ld    A, D                    ; Reached the end of the free list? 
13ab			      or    E 
13ab			      jp    Z, free_done 
13ab			 
13ab			      ex    DE, HL 
13ab			 
13ab			      jr    free_find_higher_block 
13ab			 
13ab			free_found_higher_block: 
13ab			      ; Insert freed block between prev and next free blocks 
13ab			      ld    (HL), C                 ; Point prev free block to freed block 
13ab			      inc   HL 
13ab			      ld    (HL), B 
13ab			 
13ab			      ld    H, B                    ; Point freed block at next free block 
13ab			      ld    L, C 
13ab			      ld    (HL), E 
13ab			      inc   HL 
13ab			      ld    (HL), D 
13ab			 
13ab			      ; Check if the freed block is adjacent to the next free block 
13ab			      inc   HL                      ; Load size of freed block into HL 
13ab			      ld    E, (HL) 
13ab			      inc   HL 
13ab			      ld    D, (HL) 
13ab			      ex    DE, HL 
13ab			 
13ab			      add   HL, BC                  ; Add addr of freed block and its size 
13ab			 
13ab			      ld    E, (IX+0)               ; Load addr of next free block into DE 
13ab			      ld    D, (IX+1) 
13ab			 
13ab			      or    A                       ; Clear the carry flag 
13ab			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
13ab			      jr    NZ, free_check_adjacent_to_prev 
13ab			 
13ab			      ; Freed block is adjacent to next, merge into one bigger block 
13ab			      ex    DE, HL                  ; Load next ptr from next block into DE 
13ab			      ld    E, (HL) 
13ab			      inc   HL 
13ab			      ld    D, (HL) 
13ab			      push  HL                      ; Save ptr to next block for later 
13ab			 
13ab			      ld    H, B                    ; Store ptr from next block into freed block 
13ab			      ld    L, C 
13ab			      ld    (HL), E 
13ab			      inc   HL 
13ab			      ld    (HL), D 
13ab			 
13ab			      pop   HL                      ; Restore ptr to next block 
13ab			      inc   HL                      ; Load size of next block into DE 
13ab			      ld    E, (HL) 
13ab			      inc   HL 
13ab			      ld    D, (HL) 
13ab			      push  DE                      ; Save next block size for later 
13ab			 
13ab			      ld    H, B                    ; Load size of freed block into HL 
13ab			      ld    L, C 
13ab			      inc   HL 
13ab			      inc   HL 
13ab			      ld    E, (HL) 
13ab			      inc   HL 
13ab			      ld    D, (HL) 
13ab			      ex    DE, HL 
13ab			 
13ab			      pop   DE                      ; Restore size of next block 
13ab			      add   HL, DE                  ; Add sizes of both blocks 
13ab			      ex    DE, HL 
13ab			 
13ab			      ld    H, B                    ; Store new bigger size into freed block 
13ab			      ld    L, C 
13ab			      inc   HL 
13ab			      inc   HL 
13ab			      ld    (HL), E 
13ab			      inc   HL 
13ab			      ld    (HL), D 
13ab			 
13ab			free_check_adjacent_to_prev: 
13ab			      ; Check if the freed block is adjacent to the prev free block 
13ab			      ld    L, (IX+2)               ; Prev free block ptr into HL 
13ab			      ld    H, (IX+3) 
13ab			 
13ab			      inc   HL                      ; Size of prev free block into DE 
13ab			      inc   HL 
13ab			      ld    E, (HL) 
13ab			      inc   HL 
13ab			      ld    D, (HL) 
13ab			      dec   HL 
13ab			      dec   HL 
13ab			      dec   HL 
13ab			 
13ab			      add   HL, DE                  ; Add prev block addr and size 
13ab			 
13ab			      or    A                       ; Clear the carry flag 
13ab			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
13ab			      jr    NZ, free_done 
13ab			 
13ab			      ; Freed block is adjacent to prev, merge into one bigger block 
13ab			      ld    H, B                    ; Load next ptr from freed block into DE 
13ab			      ld    L, C 
13ab			      ld    E, (HL) 
13ab			      inc   HL 
13ab			      ld    D, (HL) 
13ab			      push  HL                      ; Save freed block ptr for later 
13ab			 
13ab			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
13ab			      ld    H, (IX+3) 
13ab			      ld    (HL), E 
13ab			      inc   HL 
13ab			      ld    (HL), D 
13ab			 
13ab			      pop   HL                      ; Restore freed block ptr 
13ab			      inc   HL                      ; Load size of freed block into DE 
13ab			      ld    E, (HL) 
13ab			      inc   HL 
13ab			      ld    D, (HL) 
13ab			      push  DE                      ; Save freed block size for later 
13ab			 
13ab			      ld    L, (IX+2)               ; Load size of prev block into DE 
13ab			      ld    H, (IX+3) 
13ab			      inc   HL 
13ab			      inc   HL 
13ab			      ld    E, (HL) 
13ab			      inc   HL 
13ab			      ld    D, (HL) 
13ab			 
13ab			      pop   HL                      ; Add sizes of both blocks 
13ab			      add   HL, DE 
13ab			      ex    DE, HL 
13ab			 
13ab			      ld    L, (IX+2)               ; Store new bigger size into prev block 
13ab			      ld    H, (IX+3) 
13ab			      inc   HL 
13ab			      inc   HL 
13ab			      ld    (HL), E 
13ab			      inc   HL 
13ab			      ld    (HL), D 
13ab			 
13ab			free_done: 
13ab			      ld    HL, 4                   ; Clean up stack frame 
13ab			      add   HL, SP 
13ab			      ld    SP, HL 
13ab			 
13ab			free_early_exit: 
13ab			      pop   IX 
13ab			      pop   DE 
13ab			      pop   BC 
13ab			 
13ab			      ret 
13ab			 
13ab			 
13ab			;      .org 0x8000 
13ab			; 
13ab			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
13ab			 ;                 .dw   0 
13ab			 
13ab			endif 
13ab			 
13ab			 
13ab			if MALLOC_4 
13ab			 
13ab			; My memory allocation code. Very very simple.... 
13ab			; allocate space under 250 chars 
13ab			 
13ab			heap_init: 
13ab				; init start of heap as zero 
13ab				;  
13ab			 
13ab				ld hl, heap_start 
13ab				ld a, 0 
13ab				ld (hl), a      ; empty block 
13ab				inc hl 
13ab				ld a, 0 
13ab				ld (hl), a      ; length of block 
13ab				; write end of list 
13ab				inc hl 
13ab				ld a,(hl) 
13ab				inc hl 
13ab				ld a,(hl) 
13ab				 
13ab			 
13ab				; init some malloc vars 
13ab			 
13ab				ld hl, 0 
13ab				ld (free_list), hl       ; store last malloc location 
13ab			 
13ab				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
13ab				ld a, 0 
13ab				ld (hl), a 
13ab			 
13ab			 
13ab				ld hl, heap_start 
13ab				;  
13ab				  
13ab				ret 
13ab			 
13ab			 
13ab			;    free block marker 
13ab			;    requested size  
13ab			;    pointer to next block 
13ab			;    .... 
13ab			;    next block marker 
13ab			 
13ab			 
13ab			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
13ab			; 
13ab			 
13ab			 
13ab			malloc:  
13ab				push de 
13ab				push bc 
13ab				push af 
13ab			 
13ab				; hl space required 
13ab				 
13ab				ld c, l    ; hold space   (TODO only a max of 255) 
13ab			 
13ab			;	inc c     ; TODO BUG need to fix memory leak on push str 
13ab			;	inc c 
13ab			;	inc c 
13ab			;	inc c 
13ab			;	inc c 
13ab			;	inc c 
13ab			;	inc c 
13ab			 
13ab			 
13ab			 
13ab				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
13ab			 
13ab				ld a, (free_list+3) 
13ab				cp 0 
13ab				jr z, .contheap 
13ab			 
13ab				ld hl, (free_list)     ; get last alloc 
13ab					if DEBUG_FORTH_MALLOC_INT 
13ab						DMARK "mrs" 
13ab						CALLMONITOR 
13ab					endif 
13ab				jr .startalloc 
13ab			 
13ab			.contheap: 
13ab				ld hl, heap_start 
13ab			 
13ab			.startalloc: 
13ab			 
13ab					if DEBUG_FORTH_MALLOC_INT 
13ab						DMARK "mym" 
13ab						CALLMONITOR 
13ab					endif 
13ab			.findblock: 
13ab					if DEBUG_FORTH_MALLOC_INT 
13ab						DMARK "mmf" 
13ab						CALLMONITOR 
13ab					endif 
13ab			 
13ab				ld a,(hl)  
13ab				; if byte is zero then clear to use 
13ab			 
13ab				cp 0 
13ab				jr z, .foundemptyblock 
13ab			 
13ab				; if byte is not clear 
13ab				;     then byte is offset to next block 
13ab			 
13ab				inc hl 
13ab				ld a, (hl) ; get size 
13ab			.nextblock:	inc hl 
13ab					ld e, (hl) 
13ab					inc hl 
13ab					ld d, (hl) 
13ab					ex de, hl 
13ab			;	inc hl  ; move past the store space 
13ab			;	inc hl  ; move past zero index  
13ab			 
13ab				; TODO detect no more space 
13ab			 
13ab				push hl 
13ab				ld de, heap_end 
13ab				call cmp16 
13ab				pop hl 
13ab				jr nc, .nospace 
13ab			 
13ab				jr .findblock 
13ab			 
13ab			.nospace: ld hl, 0 
13ab				jp .exit 
13ab			 
13ab			 
13ab			.foundemptyblock:	 
13ab					if DEBUG_FORTH_MALLOC_INT 
13ab						DMARK "mme" 
13ab						CALLMONITOR 
13ab					endif 
13ab			 
13ab			; TODO has block enough space if reusing??? 
13ab			 
13ab				;  
13ab			 
13ab			; see if this block has been previously used 
13ab				inc hl 
13ab				ld a, (hl) 
13ab				dec hl 
13ab				cp 0 
13ab				jr z, .newblock 
13ab			 
13ab					if DEBUG_FORTH_MALLOC_INT 
13ab						DMARK "meR" 
13ab						CALLMONITOR 
13ab					endif 
13ab			 
13ab			; no reusing previously allocated block 
13ab			 
13ab			; is it smaller than previously used? 
13ab				 
13ab				inc hl    ; move to size 
13ab				ld a, c 
13ab				sub (hl)        ; we want c < (hl) 
13ab				dec hl    ; move back to marker 
13ab			        jr z, .findblock 
13ab			 
13ab				; update with the new size which should be lower 
13ab			 
13ab			        ;inc  hl   ; negate next move. move back to size  
13ab			 
13ab			.newblock: 
13ab				; need to be at marker here 
13ab			 
13ab					if DEBUG_FORTH_MALLOC_INT 
13ab						DMARK "meN" 
13ab						CALLMONITOR 
13ab					endif 
13ab			 
13ab			 
13ab				ld a, c 
13ab			 
13ab				ld (free_list+3), a	 ; flag resume from last malloc  
13ab				ld (free_list), hl    ; save out last location 
13ab			 
13ab			 
13ab				;inc a     ; space for length byte 
13ab				ld (hl), a     ; save block in use marker 
13ab			 
13ab				inc hl   ; move to space marker 
13ab				ld (hl), a    ; save new space 
13ab			 
13ab				inc hl   ; move to start of allocated area 
13ab				 
13ab			;	push hl     ; save where we are - 1  
13ab			 
13ab			;	inc hl  ; move past zero index  
13ab				; skip space to set down new marker 
13ab			 
13ab				; provide some extra space for now 
13ab			 
13ab				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
13ab				inc a 
13ab				inc a 
13ab			 
13ab				push hl   ; save where we are in the node block 
13ab			 
13ab				call addatohl 
13ab			 
13ab				; write linked list point 
13ab			 
13ab				pop de     ; get our node position 
13ab				ex de, hl 
13ab			 
13ab				ld (hl), e 
13ab				inc hl 
13ab				ld (hl), d 
13ab			 
13ab				inc hl 
13ab			 
13ab				; now at start of allocated data so save pointer 
13ab			 
13ab				push hl 
13ab			 
13ab				; jump to position of next node and setup empty header in DE 
13ab			 
13ab				ex de, hl 
13ab			 
13ab			;	inc hl ; move past end of block 
13ab			 
13ab				ld a, 0 
13ab				ld (hl), a   ; empty marker 
13ab				inc hl 
13ab				ld (hl), a   ; size 
13ab				inc hl  
13ab				ld (hl), a   ; ptr 
13ab				inc hl 
13ab				ld (hl), a   ; ptr 
13ab			 
13ab			 
13ab				pop hl 
13ab			 
13ab					if DEBUG_FORTH_MALLOC_INT 
13ab						DMARK "mmr" 
13ab						CALLMONITOR 
13ab					endif 
13ab			 
13ab			.exit: 
13ab				pop af 
13ab				pop bc 
13ab				pop de  
13ab				ret 
13ab			 
13ab			 
13ab			 
13ab			 
13ab			free:  
13ab				push hl 
13ab				push af 
13ab				; get address in hl 
13ab			 
13ab					if DEBUG_FORTH_MALLOC_INT 
13ab						DMARK "fre" 
13ab						CALLMONITOR 
13ab					endif 
13ab				; data is at hl - move to block count 
13ab				dec hl 
13ab				dec hl    ; get past pointer 
13ab				dec hl 
13ab			 
13ab				ld a, (hl)    ; need this for a validation check 
13ab			 
13ab				dec hl    ; move to block marker 
13ab			 
13ab				; now check that the block count and block marker are the same  
13ab			        ; this checks that we are on a malloc node and not random memory 
13ab			        ; OK a faint chance this could be a problem but rare - famous last words! 
13ab			 
13ab				ld c, a 
13ab				ld a, (hl)    
13ab			 
13ab				cp c 
13ab				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
13ab			 
13ab				; yes good chance we are on a malloc node 
13ab			 
13ab				ld a, 0      
13ab				ld (hl), a   ; mark as free 
13ab			 
13ab				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
13ab			 
13ab			.freeignore:  
13ab			 
13ab				pop af 
13ab				pop hl 
13ab			 
13ab				ret 
13ab			 
13ab			 
13ab			 
13ab			endif 
13ab			 
13ab			; eof 
# End of file firmware_memory.asm
13ab			  
13ab			; device C  
13ab			; Now handled by SPI  
13ab			;if SOUND_ENABLE  
13ab			;	include "firmware_sound.asm"  
13ab			;endif  
13ab			  
13ab			include "firmware_diags.asm"  
13ab			; Hardware diags menu 
13ab			 
13ab			 
13ab			config: 
13ab			 
13ab 3e 00			ld a, 0 
13ad 21 d1 13			ld hl, .configmn 
13b0 cd ea 0b			call menu 
13b3			 
13b3 fe 00			cp 0 
13b5 c8				ret z 
13b6			 
13b6			;	cp 1 
13b6			;	call z, .savetostore 
13b6			 
13b6 fe 01			cp 1 
13b8			if STARTUP_V1 
13b8 cc e7 13			call z, .selautoload 
13bb			endif 
13bb			 
13bb			if STARTUP_V2 
13bb				call z, .enautoload 
13bb			endif 
13bb fe 02			cp 2 
13bd cc dd 13			call z, .disautoload 
13c0			;	cp 3 
13c0			;	call z, .selbank 
13c0 fe 03			cp 3 
13c2 cc 05 14			call z, .debug_tog 
13c5 fe 04			cp 4 
13c7 cc 53 15			call z, .bpsgo 
13ca fe 05			cp 5 
13cc cc 2e 14			call z, hardware_diags 
13cf			if STARTUP_V2 
13cf				cp 6 
13cf				call z, create_startup 
13cf			endif 
13cf 18 da			jr config 
13d1			 
13d1			.configmn: 
13d1			;	dw prom_c3 
13d1 41 17			dw prom_c2 
13d3 56 17			dw prom_c2a 
13d5			;	dw prom_c2b 
13d5			;	dw prom_c4 
13d5 75 17			dw prom_m4 
13d7 90 17			dw prom_m4b 
13d9 98 17			dw prom_c1 
13db			if STARTUP_V2 
13db				dw prom_c9 
13db			endif 
13db 00 00			dw 0 
13dd				 
13dd			 
13dd			if STARTUP_V2 
13dd			.enautoload: 
13dd				if STORAGE_SE 
13dd				ld a, $fe      ; bit 0 clear 
13dd				ld (spi_device), a 
13dd			 
13dd				call storage_get_block_0 
13dd			 
13dd				ld a, 1 
13dd				ld (store_page+STORE_0_AUTOFILE), a 
13dd			 
13dd					ld hl, 0 
13dd					ld de, store_page 
13dd				call storage_write_block	 ; save update 
13dd				else 
13dd			 
13dd				ld hl, prom_notav 
13dd				ld de, prom_empty 
13dd				call info_panel 
13dd				endif 
13dd			 
13dd			 
13dd				ret 
13dd			endif 
13dd			 
13dd			.disautoload: 
13dd				if STORAGE_SE 
13dd				ld a, $fe      ; bit 0 clear 
13dd				ld (spi_device), a 
13dd			 
13dd				call storage_get_block_0 
13dd			 
13dd				ld a, 0 
13dd				ld (store_page+STORE_0_AUTOFILE), a 
13dd			 
13dd					ld hl, 0 
13dd					ld de, store_page 
13dd				call storage_write_block	 ; save update 
13dd				else 
13dd			 
13dd 21 a7 17			ld hl, prom_notav 
13e0 11 bd 17			ld de, prom_empty 
13e3 cd 4a 0b			call info_panel 
13e6				endif 
13e6			 
13e6			 
13e6 c9				ret 
13e7			 
13e7			if STARTUP_V1 
13e7			 
13e7			; Select auto start 
13e7			 
13e7			.selautoload: 
13e7			 
13e7				 
13e7				if STORAGE_SE 
13e7			 
13e7					call config_dir 
13e7				        ld hl, scratch 
13e7					ld a, 0 
13e7					call menu 
13e7			 
13e7					cp 0 
13e7					ret z 
13e7			 
13e7					dec a 
13e7			 
13e7			 
13e7					; locate menu option 
13e7			 
13e7					ld hl, scratch 
13e7					call table_lookup 
13e7			 
13e7					if DEBUG_FORTH_WORDS 
13e7						DMARK "ALl" 
13e7						CALLMONITOR 
13e7					endif 
13e7					; with the pointer to the menu it, the byte following the zero term is the file id 
13e7			 
13e7					ld a, 0 
13e7					ld bc, 50   ; max of bytes to look at 
13e7					cpir  
13e7			 
13e7					if DEBUG_FORTH_WORDS 
13e7						DMARK "ALb" 
13e7						CALLMONITOR 
13e7					endif 
13e7					;inc hl 
13e7			 
13e7					ld a, (hl)   ; file id 
13e7					 
13e7				        ; save bank and file ids 
13e7			 
13e7					push af 
13e7			 
13e7			; TODO need to save to block 0 on bank 1	 
13e7			 
13e7					call storage_get_block_0 
13e7			 
13e7					if DEBUG_FORTH_WORDS 
13e7						DMARK "AL0" 
13e7						CALLMONITOR 
13e7					endif 
13e7					pop af 
13e7			 
13e7					ld (store_page+STORE_0_FILERUN),a 
13e7					 
13e7					; save bank id 
13e7			 
13e7					ld a,(spi_device) 
13e7					ld (store_page+STORE_0_BANKRUN),a 
13e7			 
13e7					; enable auto run of store file 
13e7			 
13e7					ld a, 1 
13e7					ld (store_page+STORE_0_AUTOFILE),a 
13e7			 
13e7					; save buffer 
13e7			 
13e7					ld hl, 0 
13e7					ld de, store_page 
13e7					if DEBUG_FORTH_WORDS 
13e7						DMARK "ALw" 
13e7						CALLMONITOR 
13e7					endif 
13e7				call storage_write_block	 ; save update 
13e7			  
13e7			 
13e7			 
13e7			 
13e7					ld hl, scratch 
13e7					call config_fdir 
13e7			 
13e7				else 
13e7			 
13e7 21 a7 17			ld hl, prom_notav 
13ea 11 bd 17			ld de, prom_empty 
13ed cd 4a 0b			call info_panel 
13f0			 
13f0				endif 
13f0 c9				ret 
13f1			endif 
13f1			 
13f1			 
13f1			; Select storage bank 
13f1			 
13f1			.selbank: 
13f1			 
13f1			;	if STORAGE_SE 
13f1			;	else 
13f1			 
13f1 21 a7 17			ld hl, prom_notav 
13f4 11 bd 17			ld de, prom_empty 
13f7 cd 4a 0b			call info_panel 
13fa			;	endif 
13fa				 
13fa c9				ret 
13fb			 
13fb			if STORAGE_SE 
13fb			 
13fb			.config_ldir:   
13fb				; Load storage bank labels into menu array 
13fb			 
13fb				 
13fb			 
13fb			 
13fb				ret 
13fb			 
13fb			 
13fb			endif 
13fb			 
13fb			 
13fb			; Save user words to storage 
13fb			 
13fb			.savetostore: 
13fb			 
13fb			;	if STORAGE_SE 
13fb			; 
13fb			;		call config_dir 
13fb			;	        ld hl, scratch 
13fb			;		ld a, 0 
13fb			;		call menu 
13fb			;		 
13fb			;		ld hl, scratch 
13fb			;		call config_fdir 
13fb			; 
13fb			;	else 
13fb			 
13fb 21 a7 17			ld hl, prom_notav 
13fe 11 bd 17			ld de, prom_empty 
1401 cd 4a 0b			call info_panel 
1404			 
1404			;	endif 
1404			 
1404 c9				ret 
1405			 
1405			if STARTUP_V2 
1405			 
1405			create_startup: 
1405			 
1405				ld a, 0 
1405				ld hl, .crstart 
1405				call menu 
1405			 
1405				cp 0 
1405				ret z 
1405			 
1405				cp 1 
1405				call z, .genlsword 
1405				cp 2 
1405				call z, .genedword 
1405			 
1405				cp 3 
1405				call z, .gendemword 
1405			 
1405				cp 4 
1405				call z, .genutlword 
1405				cp 5 
1405				call z, .genspiword 
1405				cp 6 
1405				call z, .genkeyword 
1405				cp 7 
1405				call z, .gensoundword 
1405				jr create_startup 
1405			 
1405			.gensoundword: 
1405				ld hl, crs_sound 
1405				ld de, .soundworddef 
1405				call .genfile 
1405				ret 
1405			.genlsword: 
1405				ld hl, crs_s1 
1405				ld de, .lsworddef 
1405				call .genfile 
1405				ret 
1405			 
1405			.genedword: 
1405				ld de, .edworddef 
1405				ld hl, crs_s2 
1405				call .genfile 
1405				ret 
1405			 
1405			.gendemword: 
1405				ld de, .demoworddef 
1405				ld hl, crs_s3 
1405				call .genfile 
1405				ret 
1405			 
1405			.genutlword: 
1405				ld hl, crs_s4 
1405				ld de, .utilwordef 
1405				call .genfile 
1405				ret 
1405			.genspiword: 
1405				ld hl, crs_s5 
1405				ld de, .spiworddef 
1405				call .genfile 
1405				ret 
1405			.genkeyword: 
1405				ld hl, crs_s6 
1405				ld de, .keyworddef 
1405				call .genfile 
1405				ret 
1405			 
1405			; hl - points to file name 
1405			; de - points to strings to add to file 
1405			 
1405			.genfile: 
1405				push hl 
1405				push de 
1405			 
1405				call clear_display 
1405				ld a, display_row_1 
1405				ld de, .genfiletxt 
1405				call str_at_display 
1405				call update_display 
1405			 
1405				pop de 
1405				pop hl 
1405			 
1405			 
1405				push de 
1405				call storage_create 
1405				; id in hl 
1405				pop de   ; table of strings to add 
1405			 
1405			.genloop: 
1405			 
1405				push hl ; save id for next time around 
1405				push de ; save de for next time around 
1405			 
1405				ex de, hl 
1405				call loadwordinhl 
1405				ex de, hl 
1405			 
1405				; need hl to be the id 
1405				; need de to be the string ptr 
1405				 
1405				call storage_append 
1405			 
1405				pop de 
1405				pop hl 
1405			 
1405				inc de 
1405				inc de 
1405			 
1405				ld a,(de) 
1405				cp 0 
1405				jr nz, .genloop 
1405				inc de 
1405				ld a, (de) 
1405				dec de 
1405				cp 0 
1405				jr nz, .genloop	 
1405			 
1405				ret 
1405			 
1405			.genfiletxt:  db "Creating file...",0 
1405			 
1405			.soundworddef: 
1405				dw sound1 
1405				dw sound2 
1405				dw sound3 
1405				dw sound4 
1405				dw sound5 
1405				dw sound6 
1405				dw sound7 
1405				dw sound8 
1405				dw sound9 
1405				dw 0 
1405			 
1405			.utilwordef: 
1405				dw strncpy 
1405				dw type 
1405				dw clrstack 
1405				dw longread 
1405				dw start1 
1405				dw start2 
1405			; duplicated 
1405			;	dw start3b 
1405			;	dw start3c 
1405				dw list 
1405				dw 0 
1405			 
1405			.lsworddef: 
1405				dw start3b 
1405				dw 0 
1405			 
1405			.edworddef: 
1405				dw edit1 
1405				dw edit2 
1405				dw edit3 
1405				dw 0 
1405			 
1405			.demoworddef: 
1405				dw test5 
1405				dw test6 
1405				dw test7 
1405				dw test8 
1405				dw test9 
1405				dw test10 
1405				dw game1 
1405				dw game1a 
1405				dw game1b 
1405				dw game1c 
1405				dw game1d 
1405				dw game1s 
1405				dw game1t 
1405				dw game1f 
1405				dw game1z 
1405				dw game1zz 
1405				dw ssv2 
1405				dw ssv3 
1405				dw ssv4 
1405				dw ssv5 
1405				dw ssv1 
1405				dw ssv1cpm	 
1405				dw game2b 
1405				dw game2bf 
1405				dw game2mba 
1405				dw game2mbas	 
1405				dw game2mbht 
1405				dw game2mbms 
1405				dw game2mb 
1405				dw game3w 
1405				dw game3p 
1405				dw game3sc 
1405				dw game3vsi 
1405				dw game3vs 
1405				dw 0 
1405			 
1405			 
1405			.spiworddef: 
1405			 
1405			    dw spi1 
1405			    dw spi2 
1405			    dw spi2b 
1405			    dw spi3 
1405			    dw spi4 
1405			    dw spi5 
1405			;    dw spi6 
1405			;    dw spi7 
1405			 
1405			;    dw spi8 
1405			;    dw spi9 
1405			;    dw spi10 
1405			    dw 0 
1405			 
1405			.keyworddef: 
1405			 
1405				dw keyup 
1405				dw keydown 
1405				dw keyleft 
1405				dw keyright 
1405				dw 	keyf1 
1405				dw keyf2 
1405				dw keyf3 
1405				dw keyf4 
1405				dw keyf5 
1405				dw keyf6 
1405				dw keyf7 
1405				dw keyf8 
1405				dw keyf9 
1405				dw keyf10 
1405				dw keyf11 
1405				dw keyf12 
1405				dw keytab 
1405				dw keycr 
1405				dw keyhome 
1405				dw keyend 
1405				dw keybs 
1405				dw 0 
1405			 
1405			.crstart: 
1405				dw crs_s1 
1405				dw crs_s2 
1405				dw crs_s3 
1405				dw crs_s4 
1405				dw crs_s5 
1405				dw crs_s6 
1405				dw crs_sound 
1405				dw 0 
1405			 
1405			endif 
1405			 
1405			 
1405			if STORAGE_SE 
1405			 
1405			config_fdir: 
1405				; using the scratch dir go through and release the memory allocated for each string 
1405				 
1405				ld hl, scratch 
1405			.cfdir:	ld e,(hl) 
1405				inc hl 
1405				ld d,(hl) 
1405				inc hl 
1405			 
1405				ex de, hl 
1405				call ishlzero 
1405				ret z     ; return on null pointer 
1405				call free 
1405				ex de, hl 
1405				jr .cfdir 
1405			 
1405			 
1405				ret 
1405			 
1405			 
1405			config_dir: 
1405			 
1405				; for the config menus that need to build a directory of storage call this routine 
1405				; it will construct a menu in scratch to pass to menu 
1405			 
1405				; open storage device 
1405			 
1405				; execute DIR to build a list of files and their ids into scratch in menu format 
1405				; once the menu has finished then will need to call config_fdir to release the strings 
1405				 
1405				; c = number items 
1405			 
1405				 
1405				call storage_get_block_0 
1405			 
1405				ld hl, store_page     ; get current id count 
1405				ld b, (hl) 
1405				ld c, 0    ; count of files   
1405			 
1405			 
1405				ld hl, scratch 
1405				ld (store_tmp2), hl    ; location to poke strings 
1405			 
1405				; check for empty drive 
1405			 
1405				ld a, 0 
1405				cp b 
1405				jp z, .dirdone 
1405			 
1405				 
1405					if DEBUG_FORTH_WORDS 
1405						DMARK "Cdc" 
1405						CALLMONITOR 
1405					endif 
1405			 
1405			 
1405			.diritem:	 
1405				push bc 
1405				; for each of the current ids do a search for them and if found push to stack 
1405			 
1405					ld hl, STORE_BLOCK_PHY 
1405					ld d, 0		 ; look for extent 0 of block id as this contains file name 
1405					ld e,b 
1405			 
1405					call storage_findnextid 
1405			 
1405			 
1405					; if found hl will be non zero 
1405			 
1405					call ishlzero 
1405					jr z, .dirnotfound 
1405			 
1405					; increase count 
1405			 
1405					pop bc	 
1405					inc c 
1405					push bc 
1405					 
1405			 
1405					; get file header and push the file name 
1405			 
1405					ld de, store_page 
1405					call storage_read_block 
1405			 
1405					; push file id to stack 
1405				 
1405					ld a, (store_page) 
1405					ld h, 0 
1405					ld l, a 
1405			 
1405					;call forth_push_numhl 
1405					; TODO store id 
1405			 
1405					push hl 
1405			 
1405					; push extent count to stack  
1405				 
1405					ld hl, store_page+3 
1405			 
1405					; get file name length 
1405			 
1405					call strlenz   
1405			 
1405					inc hl   ; cover zero term 
1405					inc hl  ; stick the id at the end of the area 
1405			 
1405					push hl 
1405					pop bc    ; move length to bc 
1405			 
1405					call malloc 
1405			 
1405					; TODO save malloc area to scratch 
1405			 
1405					ex de, hl 
1405					ld hl, (store_tmp2) 
1405					ld (hl), e 
1405					inc hl 
1405					ld (hl), d 
1405					inc hl 
1405					ld (store_tmp2), hl 
1405			 
1405					 
1405			 
1405					;pop hl   ; get source 
1405			;		ex de, hl    ; swap aronund	 
1405			 
1405					ld hl, store_page+3 
1405					if DEBUG_FORTH_WORDS 
1405						DMARK "CFd" 
1405						CALLMONITOR 
1405					endif 
1405					ldir 
1405			 
1405					; de is past string, move back one and store id 
1405					 
1405					dec de 
1405			 
1405					; store file id 
1405			 
1405					pop hl 
1405					ex de,hl 
1405					ld (hl), e 
1405			 
1405					if DEBUG_FORTH_WORDS 
1405						DMARK "Cdi" 
1405						CALLMONITOR 
1405					endif 
1405					 
1405			.dirnotfound: 
1405					pop bc     
1405					djnz .diritem 
1405				 
1405			.dirdone:	 
1405			 
1405					ld a, 0 
1405					ld hl, (store_tmp2) 
1405					ld (hl), a 
1405					inc hl 
1405					ld (hl), a 
1405					inc hl 
1405					; push a count of the dir items found 
1405			 
1405			;		ld h, 0 
1405			;		ld l, c 
1405			 
1405				ret 
1405			 
1405			endif 
1405			 
1405			 
1405			; Settings 
1405			; Run  
1405			 
1405			 
1405			 
1405			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
1405			;;hd_menu2:   db "        2: Editor",0   
1405			;hd_menu2:   db "        2: Editor       6: Menu",0   
1405			;hd_menu3:   db "        3: Storage",0 
1405			;hd_menu4:   db "0=quit  4: Debug",0 
1405			;hd_don:     db "ON",0 
1405			;hd_doff:     db "OFF",0 
1405			; 
1405			; 
1405			; 
1405			;hardware_diags_old:       
1405			; 
1405			;.diagmenu: 
1405			;	call clear_display 
1405			;	ld a, display_row_1 
1405			;	ld de, hd_menu1 
1405			;	call str_at_display 
1405			; 
1405			;	ld a, display_row_2 
1405			;	ld de, hd_menu2 
1405			;	call str_at_display 
1405			; 
1405			;	ld a, display_row_3 
1405			;	ld de, hd_menu3 
1405			;	call str_at_display 
1405			; 
1405			;	ld a,  display_row_4 
1405			;	ld de, hd_menu4 
1405			;	call str_at_display 
1405			; 
1405			;	; display debug state 
1405			; 
1405			;	ld de, hd_don 
1405			;	ld a, (os_view_disable) 
1405			;	cp 0 
1405			;	jr z, .distog 
1405			;	ld de, hd_doff 
1405			;.distog: ld a, display_row_4+17 
1405			;	call str_at_display 
1405			; 
1405			;	call update_display 
1405			; 
1405			;	call cin_wait 
1405			; 
1405			; 
1405			; 
1405			;	cp '4' 
1405			;	jr nz, .diagn1 
1405			; 
1405			;	; debug toggle 
1405			; 
1405			;	ld a, (os_view_disable) 
1405			;	ld b, '*' 
1405			;	cp 0 
1405			;	jr z, .debtog 
1405			;	ld b, 0 
1405			;.debtog:	 
1405			;	ld a,b 
1405			;	ld (os_view_disable),a 
1405			; 
1405			;.diagn1: cp '0' 
1405			;	 ret z 
1405			; 
1405			;;	cp '1' 
1405			;;       jp z, matrix	 
1405			;;   TODO keyboard matrix test 
1405			; 
1405			;	cp '2' 
1405			;	jp z, .diagedit 
1405			; 
1405			;;	cp '6' 
1405			;;	jp z, .menutest 
1405			;;if ENABLE_BASIC 
1405			;;	cp '6' 
1405			;;	jp z, basic 
1405			;;endif 
1405			 ; 
1405			;	jp .diagmenu 
1405			; 
1405			; 
1405			;	ret 
1405			 
1405			 
1405			.debug_tog: 
1405 21 4f 14			ld hl, .menudebug 
1408				 
1408			;	ld a, (os_view_disable) 
1408			;	cp '*' 
1408 3a 6f ee			ld a,(debug_vector) 
140b fe c9			cp $C9   ; RET 
140d 20 04			jr nz,.tdon  
140f 3e 01			ld a, 1 
1411 18 02			jr .tog1 
1413 3e 00		.tdon: ld a, 0 
1415			 
1415			.tog1: 
1415 cd ea 0b			call menu 
1418 fe 00			cp 0 
141a c8				ret z 
141b fe 01			cp 1    ; disable debug 
141d 28 04			jr z, .dtog0 
141f 3e 2a			ld a, '*' 
1421 18 05			jr .dtogset 
1423			.dtog0:  
1423				;ld a, 0 
1423 cd 41 15			call bp_on 
1426 18 dd			jr .debug_tog 
1428			.dtogset:  
1428				; ld (os_view_disable), a 
1428 cd 4d 15			call bp_off 
142b c3 05 14			jp .debug_tog 
142e			 
142e			 
142e			hardware_diags:       
142e			 
142e			.diagm: 
142e 21 41 14			ld hl, .menuitems 
1431 3e 00			ld a, 0 
1433 cd ea 0b			call menu 
1436			 
1436 fe 00		         cp 0 
1438 c8				 ret z 
1439			 
1439 fe 02			cp 2 
143b ca 9a 14			jp z, .diagedit 
143e			 
143e			;	cp '6' 
143e			;	jp z, .menutest 
143e			;if ENABLE_BASIC 
143e			;	cp '6' 
143e			;	jp z, basic 
143e			;endif 
143e			  
143e c3 2e 14			jp .diagm 
1441			 
1441				 
1441 55 14		.menuitems:   	dw .m1 
1443 60 14				dw .m2 
1445 67 14				dw .m3 
1447 6f 14				dw .m5 
1449 75 14				dw .m5a 
144b 7e 14				dw .m5b 
144d 00 00				dw 0 
144f			 
144f			.menudebug: 
144f 87 14				dw .m6 
1451 90 14				dw .m7 
1453 00 00				dw 0 
1455			 
1455 .. 00		.m1:   db "Key Matrix",0 
1460 .. 00		.m2:   db "Editor",0 
1467 .. 00		.m3:   db "Storage",0 
146f .. 00		.m5:   db "Sound",0 
1475 .. 00		.m5a:  db "RAM Test",0 
147e .. 00		.m5b:  db "LCD Test",0 
1487			 
1487 .. 00		.m6:   db "Debug ON",0 
1490 .. 00		.m7:   db "Debug OFF",0 
149a			 
149a			; debug editor 
149a			 
149a			.diagedit: 
149a			 
149a 21 c1 e2			ld hl, scratch 
149d			;	ld bc, 250 
149d			;	ldir 
149d				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
149d 3e 00			ld a, 0 
149f 77				ld (hl), a 
14a0 23				inc hl 
14a1 77				ld (hl), a 
14a2 23				inc hl 
14a3 77				ld (hl), a 
14a4			 
14a4 cd b9 0b		        call clear_display 
14a7 cd dc 0b			call update_display 
14aa				;ld a, 1 
14aa				;ld (hardware_diag), a 
14aa			.diloop: 
14aa 3e 00			ld a, display_row_1 
14ac 0e 00			ld c, 0 
14ae 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
14b0 1e 28			ld e, 40 
14b2			 
14b2 21 c1 e2			ld hl, scratch	 
14b5 cd 13 0e			call input_str 
14b8			 
14b8 3e 28			ld a, display_row_2 
14ba 11 c1 e2			ld de, scratch 
14bd cd cc 0b			call str_at_display 
14c0 cd dc 0b			call update_display 
14c3			 
14c3 c3 aa 14			jp .diloop 
14c6			 
14c6			 
14c6			; pass word in hl 
14c6			; a has display location 
14c6			display_word_at: 
14c6 f5				push af 
14c7 e5				push hl 
14c8 7c				ld a,h 
14c9 21 c6 e5			ld hl, os_word_scratch 
14cc cd 40 10			call hexout 
14cf e1				pop hl 
14d0 7d				ld a,l 
14d1 21 c8 e5			ld hl, os_word_scratch+2 
14d4 cd 40 10			call hexout 
14d7 21 ca e5			ld hl, os_word_scratch+4 
14da 3e 00			ld a,0 
14dc 77				ld (hl),a 
14dd 11 c6 e5			ld de,os_word_scratch 
14e0 f1				pop af 
14e1 cd cc 0b				call str_at_display 
14e4 c9				ret 
14e5			 
14e5			display_ptr_state: 
14e5			 
14e5				; to restore afterwards 
14e5			 
14e5 d5				push de 
14e6 c5				push bc 
14e7 e5				push hl 
14e8 f5				push af 
14e9			 
14e9				; for use in here 
14e9			 
14e9			;	push bc 
14e9			;	push de 
14e9			;	push hl 
14e9			;	push af 
14e9			 
14e9 cd b9 0b			call clear_display 
14ec			 
14ec 11 c4 16			ld de, .ptrstate 
14ef 3e 00			ld a, display_row_1 
14f1 cd cc 0b			call str_at_display 
14f4			 
14f4				; display debug step 
14f4			 
14f4			 
14f4 11 6b ee			ld de, debug_mark 
14f7 3e 26			ld a, display_row_1+display_cols-2 
14f9 cd cc 0b			call str_at_display 
14fc			 
14fc				; display a 
14fc 11 ce 16			ld de, .ptrcliptr 
14ff 3e 28			ld a, display_row_2 
1501 cd cc 0b			call str_at_display 
1504			 
1504 f1				pop af 
1505 2a 40 ea			ld hl,(cli_ptr) 
1508 3e 30			ld a, display_row_2+8 
150a cd c6 14			call display_word_at 
150d			 
150d			 
150d				; display hl 
150d			 
150d			 
150d 11 d6 16			ld de, .ptrclioptr 
1510 3e 32			ld a, display_row_2+10 
1512 cd cc 0b			call str_at_display 
1515			; 
1515			;	pop hl 
1515 3e 35			ld a, display_row_2+13 
1517 2a 3e ea			ld hl,(cli_origptr) 
151a cd c6 14			call display_word_at 
151d			; 
151d			;	 
151d			;	; display de 
151d			 
151d			;	ld de, .regstatede 
151d			;	ld a, display_row_3 
151d			;	call str_at_display 
151d			 
151d			;	pop de 
151d			;	ld h,d 
151d			;	ld l, e 
151d			;	ld a, display_row_3+3 
151d			;	call display_word_at 
151d			 
151d			 
151d				; display bc 
151d			 
151d			;	ld de, .regstatebc 
151d			;	ld a, display_row_3+10 
151d			;	call str_at_display 
151d			 
151d			;	pop bc 
151d			;	ld h,b 
151d			;	ld l, c 
151d			;	ld a, display_row_3+13 
151d			;	call display_word_at 
151d			 
151d			 
151d				; display dsp 
151d			 
151d			;	ld de, .regstatedsp 
151d			;	ld a, display_row_4 
151d			;	call str_at_display 
151d			 
151d				 
151d			;	ld hl,(cli_data_sp) 
151d			;	ld a, display_row_4+4 
151d			;	call display_word_at 
151d			 
151d				; display rsp 
151d			 
151d 11 05 17			ld de, .regstatersp 
1520 3e 82			ld a, display_row_4+10 
1522 cd cc 0b			call str_at_display 
1525			 
1525				 
1525 2a f2 e9			ld hl,(cli_ret_sp) 
1528 3e 86			ld a, display_row_4+14 
152a cd c6 14			call display_word_at 
152d			 
152d cd dc 0b			call update_display 
1530			 
1530 cd f1 0a			call delay1s 
1533 cd f1 0a			call delay1s 
1536 cd f1 0a			call delay1s 
1539			 
1539			 
1539 cd 23 1b			call next_page_prompt 
153c			 
153c				; restore  
153c			 
153c f1				pop af 
153d e1				pop hl 
153e c1				pop bc 
153f d1				pop de 
1540 c9				ret 
1541			 
1541			; Update the break point vector so that the user can hook a new routine 
1541			 
1541			bp_on: 
1541 3e c3			ld a, $c3    ; JP 
1543 32 6f ee			ld (debug_vector), a 
1546 21 53 15			ld hl, break_point_state 
1549 22 70 ee			ld (debug_vector+1), hl 
154c c9				ret 
154d			 
154d			bp_off: 
154d 3e c9			ld a, $c9    ; RET 
154f 32 6f ee			ld (debug_vector), a 
1552 c9				ret 
1553			 
1553			 
1553			break_point_state: 
1553			;	push af 
1553			; 
1553			;	; see if disabled 
1553			; 
1553			;	ld a, (os_view_disable) 
1553			;	cp '*' 
1553			;	jr nz, .bpsgo 
1553			;	pop af 
1553			;	ret 
1553			 
1553			.bpsgo: 
1553			;	pop af 
1553 f5				push af 
1554 22 a3 e2			ld (os_view_hl), hl 
1557 ed 53 a1 e2		ld (os_view_de), de 
155b ed 43 9f e2		ld (os_view_bc), bc 
155f e5				push hl 
1560 6f				ld l, a 
1561 26 00			ld h, 0 
1563 22 a5 e2			ld (os_view_af),hl 
1566			 
1566 21 b1 ed				ld hl, display_fb0 
1569 22 cc eb				ld (display_fb_active), hl 
156c e1				pop hl	 
156d			 
156d 3e 31			ld a, '1' 
156f fe 2a		.bps1:  cp '*' 
1571 cc 4d 15			call z, bp_off 
1574			;	jr nz, .bps1b 
1574			;	ld (os_view_disable),a 
1574 fe 31		.bps1b:  cp '1' 
1576 20 14			jr nz, .bps2 
1578			 
1578				; display reg 
1578			 
1578				 
1578			 
1578 3a a5 e2			ld a, (os_view_af) 
157b 2a a3 e2			ld hl, (os_view_hl) 
157e ed 5b a1 e2		ld de, (os_view_de) 
1582 ed 4b 9f e2		ld bc, (os_view_bc) 
1586 cd 20 16			call display_reg_state 
1589 c3 0c 16			jp .bpschk 
158c			 
158c fe 32		.bps2:  cp '2' 
158e 20 08			jr nz, .bps3 
1590				 
1590				; display hl 
1590 2a a3 e2			ld hl, (os_view_hl) 
1593 cd 0a 17			call display_dump_at_hl 
1596			 
1596 18 74			jr .bpschk 
1598			 
1598 fe 33		.bps3:  cp '3' 
159a 20 08			jr nz, .bps4 
159c			 
159c			        ; display de 
159c 2a a1 e2			ld hl, (os_view_de) 
159f cd 0a 17			call display_dump_at_hl 
15a2			 
15a2 18 68			jr .bpschk 
15a4 fe 34		.bps4:  cp '4' 
15a6 20 08			jr nz, .bps5 
15a8			 
15a8			        ; display bc 
15a8 2a 9f e2			ld hl, (os_view_bc) 
15ab cd 0a 17			call display_dump_at_hl 
15ae			 
15ae 18 5c			jr .bpschk 
15b0 fe 35		.bps5:  cp '5' 
15b2 20 08		        jr nz, .bps7 
15b4			 
15b4				; display cur ptr 
15b4 2a 40 ea			ld hl, (cli_ptr) 
15b7 cd 0a 17			call display_dump_at_hl 
15ba			 
15ba 18 50			jr .bpschk 
15bc fe 36		.bps7:  cp '6' 
15be 20 08			jr nz, .bps8b 
15c0				 
15c0				; display cur orig ptr 
15c0 2a 3e ea			ld hl, (cli_origptr) 
15c3 cd 0a 17			call display_dump_at_hl 
15c6 18 44			jr .bpschk 
15c8 fe 37		.bps8b:  cp '7' 
15ca 20 08			jr nz, .bps9 
15cc				 
15cc				; display dsp 
15cc 2a ee e9			ld hl, (cli_data_sp) 
15cf cd 0a 17			call display_dump_at_hl 
15d2			 
15d2 18 38			jr .bpschk 
15d4 fe 39		.bps9:  cp '9' 
15d6 20 05			jr nz, .bps8c 
15d8				 
15d8				; display SP 
15d8			;	ld hl, sp 
15d8 cd 0a 17			call display_dump_at_hl 
15db			 
15db 18 2f			jr .bpschk 
15dd fe 38		.bps8c:  cp '8' 
15df 20 08			jr nz, .bps8d 
15e1				 
15e1				; display rsp 
15e1 2a f2 e9			ld hl, (cli_ret_sp) 
15e4 cd 0a 17			call display_dump_at_hl 
15e7			 
15e7 18 23			jr .bpschk 
15e9 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
15eb 20 05			jr nz, .bps8 
15ed cd f1 18			call monitor 
15f0			 
15f0 18 1a			jr .bpschk 
15f2 fe 30		.bps8:  cp '0' 
15f4 20 16			jr nz, .bpschk 
15f6			 
15f6 21 10 ed				ld hl, display_fb1 
15f9 22 cc eb				ld (display_fb_active), hl 
15fc cd dc 0b				call update_display 
15ff			 
15ff				;ld a, (os_view_af) 
15ff 2a a3 e2			ld hl, (os_view_hl) 
1602 ed 5b a1 e2		ld de, (os_view_de) 
1606 ed 4b 9f e2		ld bc, (os_view_bc) 
160a f1				pop af 
160b c9				ret 
160c			 
160c			.bpschk:   
160c cd f1 0a			call delay1s 
160f 3e 9f		ld a,display_row_4 + display_cols - 1 
1611 11 21 1b		        ld de, endprg 
1614 cd cc 0b			call str_at_display 
1617 cd dc 0b			call update_display 
161a cd 7f 65			call cin_wait 
161d			 
161d c3 6f 15			jp .bps1 
1620			 
1620			 
1620			display_reg_state: 
1620			 
1620				; to restore afterwards 
1620			 
1620 d5				push de 
1621 c5				push bc 
1622 e5				push hl 
1623 f5				push af 
1624			 
1624				; for use in here 
1624			 
1624 c5				push bc 
1625 d5				push de 
1626 e5				push hl 
1627 f5				push af 
1628			 
1628 cd b9 0b			call clear_display 
162b			 
162b 11 e0 16			ld de, .regstate 
162e 3e 00			ld a, display_row_1 
1630 cd cc 0b			call str_at_display 
1633			 
1633				; display debug step 
1633			 
1633			 
1633 11 6b ee			ld de, debug_mark 
1636 3e 25			ld a, display_row_1+display_cols-3 
1638 cd cc 0b			call str_at_display 
163b			 
163b				; display a 
163b 11 fc 16			ld de, .regstatea 
163e 3e 28			ld a, display_row_2 
1640 cd cc 0b			call str_at_display 
1643			 
1643 e1				pop hl 
1644			;	ld h,0 
1644			;	ld l, a 
1644 3e 2b			ld a, display_row_2+3 
1646 cd c6 14			call display_word_at 
1649			 
1649			 
1649				; display hl 
1649			 
1649			 
1649 11 f0 16			ld de, .regstatehl 
164c 3e 32			ld a, display_row_2+10 
164e cd cc 0b			call str_at_display 
1651			 
1651 e1				pop hl 
1652 3e 35			ld a, display_row_2+13 
1654 cd c6 14			call display_word_at 
1657			 
1657				 
1657				; display de 
1657			 
1657 11 f4 16			ld de, .regstatede 
165a 3e 50			ld a, display_row_3 
165c cd cc 0b			call str_at_display 
165f			 
165f e1				pop hl 
1660			;	ld h,d 
1660			;	ld l, e 
1660 3e 53			ld a, display_row_3+3 
1662 cd c6 14			call display_word_at 
1665			 
1665			 
1665				; display bc 
1665			 
1665 11 f8 16			ld de, .regstatebc 
1668 3e 5a			ld a, display_row_3+10 
166a cd cc 0b			call str_at_display 
166d			 
166d e1				pop hl 
166e			;	ld h,b 
166e			;	ld l, c 
166e 3e 5d			ld a, display_row_3+13 
1670 cd c6 14			call display_word_at 
1673			 
1673			 
1673				; display dsp 
1673			 
1673 11 00 17			ld de, .regstatedsp 
1676 3e 78			ld a, display_row_4 
1678 cd cc 0b			call str_at_display 
167b			 
167b				 
167b 2a ee e9			ld hl,(cli_data_sp) 
167e 3e 7c			ld a, display_row_4+4 
1680 cd c6 14			call display_word_at 
1683			 
1683				; display rsp 
1683			 
1683 11 05 17			ld de, .regstatersp 
1686 3e 82			ld a, display_row_4+10 
1688 cd cc 0b			call str_at_display 
168b			 
168b				 
168b 2a f2 e9			ld hl,(cli_ret_sp) 
168e 3e 86			ld a, display_row_4+14 
1690 cd c6 14			call display_word_at 
1693			 
1693 cd dc 0b			call update_display 
1696			 
1696			;	call delay1s 
1696			;	call delay1s 
1696			;	call delay1s 
1696			 
1696			 
1696			;	call next_page_prompt 
1696			 
1696				; restore  
1696			 
1696 f1				pop af 
1697 e1				pop hl 
1698 c1				pop bc 
1699 d1				pop de 
169a c9				ret 
169b			 
169b .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
16af .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
16c4 .. 00		.ptrstate:	db "Ptr State",0 
16ce .. 00		.ptrcliptr:     db "cli_ptr",0 
16d6 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
16e0 .. 00		.regstate:	db "Reg State (1/0)",0 
16f0 .. 00		.regstatehl:	db "HL:",0 
16f4 .. 00		.regstatede:	db "DE:",0 
16f8 .. 00		.regstatebc:	db "BC:",0 
16fc .. 00		.regstatea:	db "A :",0 
1700 .. 00		.regstatedsp:	db "DSP:",0 
1705 .. 00		.regstatersp:	db "RSP:",0 
170a			 
170a			display_dump_at_hl: 
170a e5				push hl 
170b d5				push de 
170c c5				push bc 
170d f5				push af 
170e			 
170e 22 e4 e5			ld (os_cur_ptr),hl	 
1711 cd b9 0b			call clear_display 
1714 cd 2b 1a			call dumpcont 
1717			;	call delay1s 
1717			;	call next_page_prompt 
1717			 
1717			 
1717 f1				pop af 
1718 c1				pop bc 
1719 d1				pop de 
171a e1				pop hl 
171b c9				ret 
171c			 
171c			;if ENABLE_BASIC 
171c			;	include "nascombasic.asm" 
171c			;	basic: 
171c			;	include "forth/FORTH.ASM" 
171c			;endif 
171c			 
171c			; eof 
171c			 
171c			 
# End of file firmware_diags.asm
171c			  
171c			include "firmware_prompts.asm"  
171c			; Prompts  
171c			 
171c			; boot messages 
171c			 
171c .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
1731 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
1741			 
1741			 
1741			; config menus 
1741			 
1741			;prom_c3: db "Add Dictionary To File",0 
1741			 
1741			if STARTUP_V1 
1741 .. 00		prom_c2: db "Select Autoload File",0 
1756 .. 00		prom_c2a: db "Disable Autoload File", 0 
176c			endif 
176c			 
176c			if STARTUP_V2 
176c			prom_c2: db "Enable Autoload Files",0 
176c			prom_c2a: db "Disable Autoload Files", 0 
176c			 
176c			crs_s1: db "*ls-word", 0 
176c			crs_s2: db "*ed-word", 0 
176c			crs_s3: db "*Demo-Programs", 0 
176c			crs_s4: db "*Utils", 0 
176c			crs_s5: db "*SPI-Util", 0 
176c			crs_s6: db "*Key-constants", 0 
176c			crs_sound: db "*Sound-Util", 0 
176c			 
176c			 
176c			 
176c			endif 
176c			;prom_c2b: db "Select Storage Bank",0 
176c .. 00		prom_c4: db "Settings",0 
1775 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
1790 .. 00		prom_m4b:   db "Monitor",0 
1798 .. 00		prom_c1: db "Hardware Diags",0 
17a7			 
17a7			 
17a7			if STARTUP_V2 
17a7			prom_c9: db "Create Startup Files",0 
17a7			endif 
17a7			 
17a7 .. 00		prom_notav:    db "Feature not available",0 
17bd .. 00		prom_empty:    db "",0 
17be			 
17be			; eof 
17be			 
# End of file firmware_prompts.asm
17be			  
17be			  
17be			; eof  
17be			  
# End of file firmware.asm
17be			 
17be			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
17be			;if BASE_KEV  
17be			;baseram: equ 08000h 
17be			;endif 
17be			 
17be			;if BASE_SC114 
17be			;baseram:     equ    endofcode 
17be			;endif 
17be			 
17be			 
17be			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
17be			 
17be			; start system 
17be			 
17be			coldstart: 
17be				; set sp 
17be				; di/ei 
17be			 
17be f3				di 
17bf 31 00 f0			ld sp, tos 
17c2 cd 7d 64			call init_nmi 
17c5			;	ei 
17c5			 
17c5				; init spinner 
17c5 3e 00			ld a,0 
17c7 32 c6 eb			ld (display_active), a 
17ca			 
17ca				; disable breakpoint by default 
17ca			 
17ca				;ld a,'*' 
17ca			;	ld a,' ' 
17ca			;	ld (os_view_disable),a 
17ca			 
17ca				; set break point vector as new break point on or off 
17ca cd 4d 15			call bp_off 
17cd			 
17cd				; init hardware 
17cd			 
17cd				; init keyboard and screen hardware 
17cd			 
17cd cd 1b 01			call hardware_init 
17d0			 
17d0			 
17d0 cd f1 0a			call delay1s 
17d3 3e 58			ld a, display_row_3+8 
17d5 11 03 01			ld de, buildtime 
17d8 cd cc 0b			call str_at_display 
17db cd dc 0b			call update_display 
17de			 
17de cd f1 0a			call delay1s 
17e1 cd f1 0a			call delay1s 
17e4 cd f1 0a			call delay1s 
17e7			 
17e7				; detect if any keys are held down to enable breakpoints at start up 
17e7			 
17e7 cd 87 65			call cin  
17ea fe 00			cp 0 
17ec 28 03			jr z, .nokeys 
17ee			 
17ee				;call hardware_diags 
17ee cd ab 13			call config 
17f1			 
17f1			;	ld de, .bpen 
17f1			;	ld a, display_row_4 
17f1			;	call str_at_display 
17f1			;	call update_display 
17f1			; 
17f1			;	ld a,0 
17f1			;	ld (os_view_disable),a 
17f1			; 
17f1			;.bpwait: 
17f1			;	call cin 
17f1			;	cp 0 
17f1			;	jr z, .bpwait 
17f1			;	jr .nokeys 
17f1			; 
17f1			; 
17f1			;.bpen:  db "Break points enabled!",0 
17f1			 
17f1			 
17f1			 
17f1			 
17f1			 
17f1			 
17f1			.nokeys: 
17f1			 
17f1			 
17f1				 
17f1			 
17f1			;jp  testkey 
17f1			 
17f1			;call storage_get_block_0 
17f1			; 
17f1			;ld hl, 0 
17f1			;ld de, store_page 
17f1			;call storage_read_block 
17f1			 
17f1				 
17f1			;ld hl, 10 
17f1			;ld de, store_page 
17f1			;call storage_read_block 
17f1			 
17f1			 
17f1			 
17f1			 
17f1			 
17f1			;stop:	nop 
17f1			;	jp stop 
17f1			 
17f1			 
17f1			 
17f1			main: 
17f1 cd b9 0b			call clear_display 
17f4 cd dc 0b			call update_display 
17f7			 
17f7			 
17f7			 
17f7			;	call testlcd 
17f7			 
17f7			 
17f7			 
17f7 cd 28 1f			call forth_init 
17fa			 
17fa			 
17fa			warmstart: 
17fa cd fe 1e			call forth_warmstart 
17fd			 
17fd				; run startup word load 
17fd			        ; TODO prevent this running at warmstart after crash  
17fd			 
17fd				if STARTUP_ENABLE 
17fd			 
17fd					if STARTUP_V1 
17fd			 
17fd						if STORAGE_SE 
17fd							call forth_autoload 
17fd						endif 
17fd cd cd 63					call forth_startup 
1800					endif 
1800			 
1800					if STARTUP_V2 
1800			 
1800						if STORAGE_SE 
1800							call forth_autoload 
1800						else 
1800							call forth_startup 
1800						endif 
1800			 
1800			 
1800					endif 
1800			 
1800				endif 
1800			 
1800				; show free memory after boot 
1800 11 8c 18			ld de, freeram 
1803 3e 00			ld a, display_row_1 
1805 cd cc 0b			call str_at_display 
1808			 
1808				; get current heap start after loading any uwords 
1808			 
1808				;ld de, (os_last_new_uword) 
1808				;ex de, hl 
1808			 
1808			; Or use heap_size word???? 
1808				;ld hl, heap_end 
1808				;ld hl, heap_size 
1808				;ld de, topusermem 
1808				;ld de, heap_start 
1808 ed 5b aa 65			ld de, (free_list )      
180c 21 9c e2				ld hl, heap_end 
180f ed 52			sbc hl, de 
1811				;push hl 
1811				;ld a,h	         	 
1811				;ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1811				;call hexout 
1811			   	;pop hl 
1811			; 
1811			;	ld a,l 
1811			;	ld hl, os_word_scratch+2 
1811			;	call hexout 
1811			;	ld hl, os_word_scratch+4 
1811			;	ld a, 0 
1811			;	ld (hl),a 
1811 eb				ex de, hl 
1812 21 c6 e5			ld hl, os_word_scratch 
1815 cd 4c 11			call uitoa_16 
1818			 
1818			 
1818 11 c6 e5			ld de, os_word_scratch 
181b 3e 0d			ld a, display_row_1 + 13 
181d cd cc 0b			call str_at_display 
1820 cd dc 0b			call update_display 
1823			 
1823			 
1823				;call demo 
1823			 
1823			 
1823				; init scratch input area for cli commands 
1823			 
1823 21 e8 e5			ld hl, os_cli_cmd 
1826 3e 00			ld a,0 
1828 77				ld (hl),a 
1829 23				inc hl 
182a 77				ld (hl),a 
182b			 
182b 3e 00			ld a,0 
182d 32 e7 e6			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1830			 
1830 32 e4 e5			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1833 32 e5 e5			ld (os_cur_ptr+1),a	 
1836			 
1836 32 c6 e5			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1839 32 c7 e5			ld (os_word_scratch+1),a	 
183c				 
183c			 
183c				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
183c 21 e8 e5			ld hl, os_cli_cmd 
183f			 
183f 3e 00			ld a, 0		 ; init cli input 
1841 77				ld (hl), a 
1842 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1844			cli: 
1844				; show cli prompt 
1844				;push af 
1844				;ld a, 0 
1844				;ld de, prompt 
1844				;call str_at_display 
1844			 
1844				;call update_display 
1844				;pop af 
1844				;inc a 
1844				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1844 0e 00			ld c, 0 
1846 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1848 1e 28			ld e, 40 
184a			 
184a 21 e8 e5			ld hl, os_cli_cmd 
184d			 
184d				STACKFRAME OFF $fefe $9f9f 
184d				if DEBUG_STACK_IMB 
184d					if OFF 
184d						exx 
184d						ld de, $fefe 
184d						ld a, d 
184d						ld hl, curframe 
184d						call hexout 
184d						ld a, e 
184d						ld hl, curframe+2 
184d						call hexout 
184d						ld hl, $fefe 
184d						push hl 
184d						ld hl, $9f9f 
184d						push hl 
184d						exx 
184d					endif 
184d				endif 
184d			endm 
# End of macro STACKFRAME
184d			 
184d cd 13 0e			call input_str 
1850			 
1850				STACKFRAMECHK OFF $fefe $9f9f 
1850				if DEBUG_STACK_IMB 
1850					if OFF 
1850						exx 
1850						ld hl, $9f9f 
1850						pop de   ; $9f9f 
1850						call cmp16 
1850						jr nz, .spnosame 
1850						ld hl, $fefe 
1850						pop de   ; $fefe 
1850						call cmp16 
1850						jr z, .spfrsame 
1850						.spnosame: call showsperror 
1850						.spfrsame: nop 
1850						exx 
1850					endif 
1850				endif 
1850			endm 
# End of macro STACKFRAMECHK
1850			 
1850				; copy input to last command 
1850			 
1850 21 e8 e5			ld hl, os_cli_cmd 
1853 11 e7 e6			ld de, os_last_cmd 
1856 01 ff 00			ld bc, 255 
1859 ed b0			ldir 
185b			 
185b				; wipe current buffer 
185b			 
185b			;	ld a, 0 
185b			;	ld hl, os_cli_cmd 
185b			;	ld de, os_cli_cmd+1 
185b			;	ld bc, 254 
185b			;	ldir 
185b				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
185b			;	call strcpy 
185b			;	ld a, 0 
185b			;	ld (hl), a 
185b			;	inc hl 
185b			;	ld (hl), a 
185b			;	inc hl 
185b			;	ld (hl), a 
185b			 
185b				; switch frame buffer to program  
185b			 
185b 21 10 ed				ld hl, display_fb1 
185e 22 cc eb				ld (display_fb_active), hl 
1861			 
1861			;	nop 
1861				STACKFRAME ON $fbfe $8f9f 
1861				if DEBUG_STACK_IMB 
1861					if ON 
1861						exx 
1861						ld de, $fbfe 
1861						ld a, d 
1861						ld hl, curframe 
1861						call hexout 
1861						ld a, e 
1861						ld hl, curframe+2 
1861						call hexout 
1861						ld hl, $fbfe 
1861						push hl 
1861						ld hl, $8f9f 
1861						push hl 
1861						exx 
1861					endif 
1861				endif 
1861			endm 
# End of macro STACKFRAME
1861				; first time into the parser so pass over the current scratch pad 
1861 21 e8 e5			ld hl,os_cli_cmd 
1864				; tokenise the entered statement(s) in HL 
1864 cd a6 1f			call forthparse 
1867			        ; exec forth statements in top of return stack 
1867 cd e6 1f			call forthexec 
186a				;call forthexec_cleanup 
186a			;	call parsenext 
186a			 
186a				STACKFRAMECHK ON $fbfe $8f9f 
186a				if DEBUG_STACK_IMB 
186a					if ON 
186a						exx 
186a						ld hl, $8f9f 
186a						pop de   ; $8f9f 
186a						call cmp16 
186a						jr nz, .spnosame 
186a						ld hl, $fbfe 
186a						pop de   ; $fbfe 
186a						call cmp16 
186a						jr z, .spfrsame 
186a						.spnosame: call showsperror 
186a						.spfrsame: nop 
186a						exx 
186a					endif 
186a				endif 
186a			endm 
# End of macro STACKFRAMECHK
186a				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
186a			 
186a 3e 78			ld a, display_row_4 
186c 11 9d 18			ld de, endprog 
186f			 
186f cd dc 0b			call update_display		 
1872			 
1872 cd 23 1b			call next_page_prompt 
1875			 
1875				; switch frame buffer to cli 
1875			 
1875 21 b1 ed				ld hl, display_fb0 
1878 22 cc eb				ld (display_fb_active), hl 
187b			 
187b			 
187b cd b9 0b		        call clear_display 
187e cd dc 0b			call update_display		 
1881			 
1881 21 e8 e5			ld hl, os_cli_cmd 
1884			 
1884 3e 00			ld a, 0		 ; init cli input 
1886 77				ld (hl), a 
1887			 
1887				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1887			 
1887				; now on last line 
1887			 
1887				; TODO scroll screen up 
1887			 
1887				; TODO instead just clear screen and place at top of screen 
1887			 
1887			;	ld a, 0 
1887			;	ld (f_cursor_ptr),a 
1887			 
1887				;call clear_display 
1887				;call update_display 
1887			 
1887				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1887 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1889 c3 44 18			jp cli 
188c			 
188c .. 00		freeram: db "Free bytes: ",0 
1899 ..			asc: db "1A2F" 
189d .. 00		endprog: db "End prog...",0 
18a9			 
18a9			testenter2:   
18a9 21 f3 e2			ld hl,scratch+50 
18ac 22 e4 e5			ld (os_cur_ptr),hl 
18af c3 44 18			jp cli 
18b2			 
18b2			testenter:  
18b2			 
18b2 21 99 18			ld hl,asc 
18b5			;	ld a,(hl) 
18b5			;	call nibble2val 
18b5 cd 96 10			call get_byte 
18b8			 
18b8			 
18b8			;	ld a,(hl) 
18b8			;	call atohex 
18b8			 
18b8			;	call fourehexhl 
18b8 32 f3 e2			ld (scratch+50),a 
18bb			 
18bb			 
18bb			 
18bb 21 9b 18			ld hl,asc+2 
18be			;	ld a, (hl) 
18be			;	call nibble2val 
18be cd 96 10			call get_byte 
18c1			 
18c1			;	call fourehexhl 
18c1 32 f5 e2			ld (scratch+52),a 
18c4				 
18c4 21 f3 e2			ld hl,scratch+50 
18c7 22 e4 e5			ld (os_cur_ptr),hl 
18ca c3 44 18			jp cli 
18cd			 
18cd			enter:	 
18cd 3a c5 e2			ld a,(scratch+4) 
18d0 fe 00			cp 0 
18d2 28 0c			jr z, .entercont 
18d4				; no, not a null term line so has an address to work out.... 
18d4			 
18d4 21 c3 e2			ld hl,scratch+2 
18d7 cd f6 10			call get_word_hl 
18da			 
18da 22 e4 e5			ld (os_cur_ptr),hl	 
18dd c3 44 18			jp cli 
18e0			 
18e0			 
18e0			.entercont:  
18e0			 
18e0 21 c3 e2			ld hl, scratch+2 
18e3 cd 96 10			call get_byte 
18e6			 
18e6 2a e4 e5		   	ld hl,(os_cur_ptr) 
18e9 77					ld (hl),a 
18ea 23					inc hl 
18eb 22 e4 e5				ld (os_cur_ptr),hl 
18ee				 
18ee			; get byte  
18ee			 
18ee			 
18ee c3 44 18			jp cli 
18f1			 
18f1			 
18f1			; basic monitor support 
18f1			 
18f1			monitor: 
18f1				;  
18f1 cd b9 0b			call clear_display 
18f4 3e 00			ld a, 0 
18f6 11 45 19			ld de, .monprompt 
18f9 cd cc 0b			call str_at_display 
18fc cd dc 0b			call update_display 
18ff			 
18ff				; get a monitor command 
18ff			 
18ff 0e 00			ld c, 0     ; entry at top left 
1901 16 64			ld d, 100   ; max buffer size 
1903 1e 0f			ld e, 15    ; input scroll area 
1905 3e 00			ld a, 0     ; init string 
1907 21 bf e4			ld hl, os_input 
190a 77				ld (hl), a 
190b 23				inc hl 
190c 77				ld (hl), a 
190d 21 bf e4			ld hl, os_input 
1910 3e 01			ld a, 1     ; init string 
1912 cd 13 0e			call input_str 
1915			 
1915 cd b9 0b		        call clear_display 
1918 cd dc 0b			call update_display		 
191b			 
191b 3a bf e4			ld a, (os_input) 
191e cd 94 11			call toUpper 
1921 fe 48		        cp 'H' 
1923 ca aa 19		        jp z, .monhelp 
1926 fe 44			cp 'D'		; dump 
1928 ca dd 19			jp z, .mondump	 
192b fe 43			cp 'C'		; dump 
192d ca f7 19			jp z, .moncdump	 
1930 fe 4d			cp 'M'		; dump 
1932 ca 47 19			jp z, .moneditstart 
1935 fe 55			cp 'U'		; dump 
1937 ca 53 19			jp z, .monedit	 
193a fe 47			cp 'G'		; dump 
193c ca d3 19			jp z, .monjump 
193f fe 51			cp 'Q'		; dump 
1941 c8				ret z	 
1942			 
1942			 
1942				; TODO "S" to access symbol by name and not need the address 
1942				; TODO "F" to find a string in memory 
1942			 
1942 c3 f1 18			jp monitor 
1945			 
1945 .. 00		.monprompt: db ">", 0 
1947			 
1947			.moneditstart: 
1947				; get starting address 
1947			 
1947 21 c1 e4			ld hl,os_input+2 
194a cd f6 10			call get_word_hl 
194d			 
194d 22 e4 e5			ld (os_cur_ptr),hl	 
1950			 
1950 c3 f1 18			jp monitor 
1953			 
1953			.monedit: 
1953				; get byte to load 
1953			 
1953 21 c1 e4			ld hl,os_input+2 
1956 cd 96 10			call get_byte 
1959			 
1959				; get address to update 
1959 2a e4 e5			ld hl, (os_cur_ptr) 
195c			 
195c				; update byte 
195c			 
195c 77				ld (hl), a 
195d			 
195d				; move to next address and save it 
195d			 
195d 23				inc hl 
195e 22 e4 e5			ld (os_cur_ptr),hl	 
1961			 
1961 c3 f1 18			jp monitor 
1964			 
1964			 
1964 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1978 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1994 .. 00		.monhelptext3:  db "G-Call address",0 
19a3 .. 00		.monhelptext4:  db "Q-Quit",0 
19aa			        
19aa			.monhelp: 
19aa 3e 00			ld a, display_row_1 
19ac 11 64 19		        ld de, .monhelptext1 
19af			 
19af cd cc 0b			call str_at_display 
19b2 3e 28			ld a, display_row_2 
19b4 11 78 19		        ld de, .monhelptext2 
19b7					 
19b7 cd cc 0b			call str_at_display 
19ba 3e 50			ld a, display_row_3 
19bc 11 94 19		        ld de, .monhelptext3 
19bf					 
19bf cd cc 0b			call str_at_display 
19c2 3e 78			ld a, display_row_4 
19c4 11 a3 19		        ld de, .monhelptext4 
19c7 cd cc 0b			call str_at_display 
19ca			 
19ca cd dc 0b			call update_display		 
19cd			 
19cd cd 23 1b			call next_page_prompt 
19d0 c3 f1 18			jp monitor 
19d3			 
19d3			.monjump:    
19d3 21 c1 e4			ld hl,os_input+2 
19d6 cd f6 10			call get_word_hl 
19d9			 
19d9 e9				jp (hl) 
19da c3 f1 18			jp monitor 
19dd			 
19dd			.mondump:    
19dd 21 c1 e4			ld hl,os_input+2 
19e0 cd f6 10			call get_word_hl 
19e3			 
19e3 22 e4 e5			ld (os_cur_ptr),hl	 
19e6 cd 2b 1a			call dumpcont 
19e9 3e 78			ld a, display_row_4 
19eb 11 9d 18			ld de, endprog 
19ee			 
19ee cd dc 0b			call update_display		 
19f1			 
19f1 cd 23 1b			call next_page_prompt 
19f4 c3 f1 18			jp monitor 
19f7			.moncdump: 
19f7 cd 2b 1a			call dumpcont 
19fa 3e 78			ld a, display_row_4 
19fc 11 9d 18			ld de, endprog 
19ff			 
19ff cd dc 0b			call update_display		 
1a02			 
1a02 cd 23 1b			call next_page_prompt 
1a05 c3 f1 18			jp monitor 
1a08			 
1a08			 
1a08			; TODO symbol access  
1a08			 
1a08			.symbols:     ;; A list of symbols that can be called up  
1a08 b1 ed			dw display_fb0 
1a0a .. 00			db "fb0",0  
1a0e 7a ea		     	dw store_page 
1a10 .. 00			db "store_page",0 
1a1b			 
1a1b			 
1a1b			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1a1b			 
1a1b 3a c2 e2			ld a,(scratch+1) 
1a1e fe 00			cp 0 
1a20 28 09			jr z, dumpcont 
1a22			 
1a22				; no, not a null term line so has an address to work out.... 
1a22			 
1a22 21 c3 e2			ld hl,scratch+2 
1a25 cd f6 10			call get_word_hl 
1a28			 
1a28 22 e4 e5			ld (os_cur_ptr),hl	 
1a2b			 
1a2b			 
1a2b			 
1a2b			dumpcont: 
1a2b			 
1a2b				; dump bytes at ptr 
1a2b			 
1a2b			 
1a2b 3e 00			ld a, display_row_1 
1a2d 2a cc eb			ld hl, (display_fb_active) 
1a30 cd e6 0d			call addatohl 
1a33 cd 5b 1a			call .dumpbyterow 
1a36			 
1a36 3e 28			ld a, display_row_2 
1a38 2a cc eb			ld hl, (display_fb_active) 
1a3b cd e6 0d			call addatohl 
1a3e cd 5b 1a			call .dumpbyterow 
1a41			 
1a41			 
1a41 3e 50			ld a, display_row_3 
1a43 2a cc eb			ld hl, (display_fb_active) 
1a46 cd e6 0d			call addatohl 
1a49 cd 5b 1a			call .dumpbyterow 
1a4c			 
1a4c 3e 78			ld a, display_row_4 
1a4e 2a cc eb			ld hl, (display_fb_active) 
1a51 cd e6 0d			call addatohl 
1a54 cd 5b 1a			call .dumpbyterow 
1a57			 
1a57 cd dc 0b			call update_display 
1a5a			;		jp cli 
1a5a c9				ret 
1a5b			 
1a5b			.dumpbyterow: 
1a5b			 
1a5b				;push af 
1a5b			 
1a5b e5				push hl 
1a5c			 
1a5c				; calc where to poke the ascii 
1a5c			if display_cols == 20 
1a5c				ld a, 16 
1a5c			else 
1a5c 3e 1f			ld a, 31 
1a5e			endif 
1a5e			 
1a5e cd e6 0d			call addatohl 
1a61 22 c6 e5			ld (os_word_scratch),hl  		; save pos for later 
1a64			 
1a64			 
1a64			; display decoding address 
1a64 2a e4 e5		   	ld hl,(os_cur_ptr) 
1a67			 
1a67 7c				ld a,h 
1a68 e1				pop hl 
1a69 e5				push hl 
1a6a			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1a6a cd 40 10			call hexout 
1a6d 2a e4 e5		   	ld hl,(os_cur_ptr) 
1a70			 
1a70 7d				ld a,l 
1a71 e1				pop hl 
1a72 23				inc hl 
1a73 23				inc hl 
1a74 e5				push hl 
1a75			;	ld hl, os_word_scratch+2 
1a75 cd 40 10			call hexout 
1a78 e1				pop hl 
1a79 23				inc hl 
1a7a 23				inc hl 
1a7b				;ld hl, os_word_scratch+4 
1a7b 3e 3a			ld a, ':' 
1a7d 77				ld (hl),a 
1a7e 23				inc hl 
1a7f				;ld a, 0 
1a7f				;ld (hl),a 
1a7f				;ld de, os_word_scratch 
1a7f				;pop af 
1a7f				;push af 
1a7f			;		ld a, display_row_2 
1a7f			;		call str_at_display 
1a7f			;		call update_display 
1a7f			 
1a7f			 
1a7f			;pop af 
1a7f			;	add 5 
1a7f			 
1a7f			if display_cols == 20 
1a7f				ld b, 4 
1a7f			else 
1a7f 06 08			ld b, 8 
1a81			endif	 
1a81			 
1a81			.dumpbyte: 
1a81 c5				push bc 
1a82 e5				push hl 
1a83			 
1a83			 
1a83 2a e4 e5		   	ld hl,(os_cur_ptr) 
1a86 7e					ld a,(hl) 
1a87			 
1a87					; poke the ascii to display 
1a87 2a c6 e5				ld hl,(os_word_scratch) 
1a8a 77					ld (hl),a 
1a8b 23					inc hl 
1a8c 22 c6 e5				ld (os_word_scratch),hl 
1a8f			 
1a8f					 
1a8f			 
1a8f			 
1a8f e1					pop hl 
1a90 e5					push hl 
1a91			 
1a91 cd 40 10				call hexout 
1a94			 
1a94					 
1a94 2a e4 e5		   	ld hl,(os_cur_ptr) 
1a97 23				inc hl 
1a98 22 e4 e5		   	ld (os_cur_ptr),hl 
1a9b			 
1a9b e1					pop hl 
1a9c 23					inc hl 
1a9d 23					inc hl 
1a9e 23					inc hl 
1a9f			 
1a9f			 
1a9f			 
1a9f					;ld a,0 
1a9f					;ld (os_word_scratch+2),a 
1a9f					;pop af 
1a9f					;push af 
1a9f			 
1a9f					;ld de, os_word_scratch 
1a9f					;call str_at_display 
1a9f			;		call update_display 
1a9f			;		pop af 
1a9f c1					pop bc 
1aa0 c6 03				add 3 
1aa2 10 dd			djnz .dumpbyte 
1aa4			 
1aa4				 
1aa4			 
1aa4 c9				ret 
1aa5			 
1aa5			jump:	 
1aa5			 
1aa5 21 c3 e2			ld hl,scratch+2 
1aa8 cd f6 10			call get_word_hl 
1aab				;ld hl,(scratch+2) 
1aab				;call fourehexhl 
1aab			 
1aab 22 e4 e5			ld (os_cur_ptr),hl	 
1aae			 
1aae e9				jp (hl) 
1aaf			 
1aaf			 
1aaf			 
1aaf			; TODO implement a basic monitor mode to start with 
1aaf			 
1aaf			 
1aaf			 
1aaf			 
1aaf			 
1aaf			 
1aaf			 
1aaf			 
1aaf			 
1aaf			; testing and demo code during development 
1aaf			 
1aaf			 
1aaf .. 00		str1: db "Enter some text...",0 
1ac2 .. 00		clear: db "                    ",0 
1ad7			 
1ad7			demo: 
1ad7			 
1ad7			 
1ad7			 
1ad7			;	call update_display 
1ad7			 
1ad7				; init scratch input area for testing 
1ad7 21 c1 e2			ld hl, scratch	 
1ada 3e 00			ld a,0 
1adc 77				ld (hl),a 
1add			 
1add			 
1add 3e 28		            LD   A, display_row_2 
1adf			;            CALL fLCD_Pos       ;Position cursor to location in A 
1adf 11 af 1a		            LD   DE, str1 
1ae2 cd cc 0b			call str_at_display 
1ae5			 
1ae5			;            CALL fLCD_Str       ;Display string pointed to by DE 
1ae5			cloop:	 
1ae5 3e 50		            LD   A, display_row_3 
1ae7			;            CALL fLCD_Pos       ;Position cursor to location in A 
1ae7 11 c2 1a		            LD   DE, clear 
1aea			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1aea cd cc 0b				call str_at_display 
1aed 3e 78			ld a, display_row_4 
1aef 11 1f 1b			ld de, prompt 
1af2			 
1af2 cd cc 0b				call str_at_display 
1af5 cd dc 0b			call update_display 
1af8			 
1af8 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1afa 16 0a			ld d, 10 
1afc 21 c1 e2			ld hl, scratch	 
1aff cd 13 0e			call input_str 
1b02			 
1b02			;	call clear_display 
1b02			;'	call update_display 
1b02			 
1b02 3e 00		            LD   A, display_row_1 
1b04			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b04 11 c2 1a		            LD   DE, clear 
1b07 cd cc 0b				call str_at_display 
1b0a			;            CALL fLCD_Str       ;Display string pointed to by DE 
1b0a 3e 00		            LD   A, display_row_1 
1b0c			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b0c 11 c1 e2		            LD   DE, scratch 
1b0f			;            CALL fLCD_Str       ;Display string pointed to by DE 
1b0f cd cc 0b				call str_at_display 
1b12 cd dc 0b			call update_display 
1b15			 
1b15 3e 00				ld a,0 
1b17 21 c1 e2			ld hl, scratch 
1b1a 77				ld (hl),a 
1b1b			 
1b1b 00				nop 
1b1c c3 e5 1a			jp cloop 
1b1f			 
1b1f			 
1b1f			 
1b1f			; OS Prompt 
1b1f			 
1b1f .. 00		prompt: db ">",0 
1b21 .. 00		endprg: db "?",0 
1b23			 
1b23			 
1b23			; handy next page prompt 
1b23			next_page_prompt: 
1b23 e5				push hl 
1b24 d5				push de 
1b25 f5				push af 
1b26 c5				push bc 
1b27			 
1b27 3e 9f			ld a,display_row_4 + display_cols - 1 
1b29 11 21 1b		        ld de, endprg 
1b2c cd cc 0b			call str_at_display 
1b2f cd dc 0b			call update_display 
1b32 cd 7f 65			call cin_wait 
1b35 c1				pop bc 
1b36 f1				pop af 
1b37 d1				pop de 
1b38 e1				pop hl 
1b39			 
1b39			 
1b39 c9				ret 
1b3a			 
1b3a			 
1b3a			; forth parser 
1b3a			 
1b3a			; My forth kernel 
1b3a			include "forth_kernel.asm" 
1b3a			; 
1b3a			; kernel to the forth OS 
1b3a			 
1b3a			DS_TYPE_STR: equ 1     ; string type 
1b3a			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1b3a			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1b3a			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1b3a			 
1b3a			FORTH_PARSEV1: equ 0 
1b3a			FORTH_PARSEV2: equ 0 
1b3a			FORTH_PARSEV3: equ 0 
1b3a			FORTH_PARSEV4: equ 0 
1b3a			FORTH_PARSEV5: equ 1 
1b3a			 
1b3a			;if FORTH_PARSEV5 
1b3a			;	FORTH_END_BUFFER: equ 0 
1b3a			;else 
1b3a			FORTH_END_BUFFER: equ 127 
1b3a			;endif 
1b3a			 
1b3a			FORTH_TRUE: equ 1 
1b3a			FORTH_FALSE: equ 0 
1b3a			 
1b3a			if FORTH_PARSEV4 
1b3a			include "forth_stackops.asm" 
1b3a			endif 
1b3a			 
1b3a			if FORTH_PARSEV5 
1b3a			include "forth_stackopsv5.asm" 
1b3a			 
1b3a			; Stack operations for v5 parser on wards 
1b3a			; * DATA stack 
1b3a			; * LOOP stack 
1b3a			; * RETURN stack 
1b3a			 
1b3a			 
1b3a			 
1b3a			FORTH_CHK_DSP_UNDER: macro 
1b3a				push hl 
1b3a				push de 
1b3a				ld hl,(cli_data_sp) 
1b3a				ld de, cli_data_stack 
1b3a				call cmp16 
1b3a				jp c, fault_dsp_under 
1b3a				pop de 
1b3a				pop hl 
1b3a				endm 
1b3a			 
1b3a			 
1b3a			FORTH_CHK_RSP_UNDER: macro 
1b3a				push hl 
1b3a				push de 
1b3a				ld hl,(cli_ret_sp) 
1b3a				ld de, cli_ret_stack 
1b3a				call cmp16 
1b3a				jp c, fault_rsp_under 
1b3a				pop de 
1b3a				pop hl 
1b3a				endm 
1b3a			 
1b3a			FORTH_CHK_LOOP_UNDER: macro 
1b3a				push hl 
1b3a				push de 
1b3a				ld hl,(cli_loop_sp) 
1b3a				ld de, cli_loop_stack 
1b3a				call cmp16 
1b3a				jp c, fault_loop_under 
1b3a				pop de 
1b3a				pop hl 
1b3a				endm 
1b3a			 
1b3a			FORTH_ERR_TOS_NOTSTR: macro 
1b3a				; TOSO might need more for checks when used 
1b3a				push af 
1b3a				ld a,(hl) 
1b3a				cp DS_TYPE_STR 
1b3a				jp nz, type_faultn   
1b3a				pop af 
1b3a				endm 
1b3a			 
1b3a			FORTH_ERR_TOS_NOTNUM: macro 
1b3a				push af 
1b3a				ld a,(hl) 
1b3a				cp DS_TYPE_INUM 
1b3a				jp nz, type_faultn   
1b3a				pop af 
1b3a				endm 
1b3a			 
1b3a			 
1b3a			; increase data stack pointer and save hl to it 
1b3a				 
1b3a			FORTH_DSP_NEXT: macro 
1b3a				call macro_forth_dsp_next 
1b3a				endm 
1b3a			 
1b3a			 
1b3a			macro_forth_dsp_next: 
1b3a				if DEBUG_FORTH_STACK_GUARD 
1b3a cd ae 61				call check_stacks 
1b3d				endif 
1b3d e5				push hl 
1b3e d5				push de 
1b3f eb				ex de,hl 
1b40 2a ee e9			ld hl,(cli_data_sp) 
1b43 23				inc hl 
1b44 23				inc hl 
1b45			 
1b45			; PARSEV5 
1b45 23				inc hl 
1b46 22 ee e9			ld (cli_data_sp),hl 
1b49 73				ld (hl), e 
1b4a 23				inc hl 
1b4b 72				ld (hl), d 
1b4c d1				pop de 
1b4d e1				pop hl 
1b4e				if DEBUG_FORTH_STACK_GUARD 
1b4e cd ae 61				call check_stacks 
1b51				endif 
1b51 c9				ret 
1b52			 
1b52			 
1b52			; increase ret stack pointer and save hl to it 
1b52				 
1b52			FORTH_RSP_NEXT: macro 
1b52				call macro_forth_rsp_next 
1b52				endm 
1b52			 
1b52			macro_forth_rsp_next: 
1b52				if DEBUG_FORTH_STACK_GUARD 
1b52 cd ae 61				call check_stacks 
1b55				endif 
1b55 e5				push hl 
1b56 d5				push de 
1b57 eb				ex de,hl 
1b58 2a f2 e9			ld hl,(cli_ret_sp) 
1b5b 23				inc hl 
1b5c 23				inc hl 
1b5d 22 f2 e9			ld (cli_ret_sp),hl 
1b60 73				ld (hl), e 
1b61 23				inc hl 
1b62 72				ld (hl), d 
1b63 d1				pop de 
1b64 e1				pop hl 
1b65				if DEBUG_FORTH_STACK_GUARD 
1b65 cd ae 61				call check_stacks 
1b68				endif 
1b68 c9				ret 
1b69			 
1b69			; get current ret stack pointer and save to hl  
1b69				 
1b69			FORTH_RSP_TOS: macro 
1b69				call macro_forth_rsp_tos 
1b69				endm 
1b69			 
1b69			macro_forth_rsp_tos: 
1b69				;push de 
1b69 2a f2 e9			ld hl,(cli_ret_sp) 
1b6c cd a4 1b			call loadhlptrtohl 
1b6f				;ld e, (hl) 
1b6f				;inc hl 
1b6f				;ld d, (hl) 
1b6f				;ex de, hl 
1b6f					if DEBUG_FORTH_WORDS 
1b6f			;			DMARK "RST" 
1b6f						CALLMONITOR 
1b6f cd 6f ee			call debug_vector  
1b72				endm  
# End of macro CALLMONITOR
1b72					endif 
1b72				;pop de 
1b72 c9				ret 
1b73			 
1b73			; pop ret stack pointer 
1b73				 
1b73			FORTH_RSP_POP: macro 
1b73				call macro_forth_rsp_pop 
1b73				endm 
1b73			 
1b73			 
1b73			macro_forth_rsp_pop: 
1b73				if DEBUG_FORTH_STACK_GUARD 
1b73			;		DMARK "RPP" 
1b73 cd ae 61				call check_stacks 
1b76					FORTH_CHK_RSP_UNDER 
1b76 e5				push hl 
1b77 d5				push de 
1b78 2a f2 e9			ld hl,(cli_ret_sp) 
1b7b 11 ac e9			ld de, cli_ret_stack 
1b7e cd 04 0e			call cmp16 
1b81 da c2 62			jp c, fault_rsp_under 
1b84 d1				pop de 
1b85 e1				pop hl 
1b86				endm 
# End of macro FORTH_CHK_RSP_UNDER
1b86				endif 
1b86 e5				push hl 
1b87 2a f2 e9			ld hl,(cli_ret_sp) 
1b8a			 
1b8a			 
1b8a				if FORTH_ENABLE_FREE 
1b8a			 
1b8a					; get pointer 
1b8a			 
1b8a					push de 
1b8a					push hl 
1b8a			 
1b8a					ld e, (hl) 
1b8a					inc hl 
1b8a					ld d, (hl) 
1b8a			 
1b8a					ex de, hl 
1b8a					call free 
1b8a			 
1b8a					pop hl 
1b8a					pop de 
1b8a			 
1b8a			 
1b8a				endif 
1b8a			 
1b8a			 
1b8a 2b				dec hl 
1b8b 2b				dec hl 
1b8c 22 f2 e9			ld (cli_ret_sp), hl 
1b8f				; do stack underflow checks 
1b8f e1				pop hl 
1b90				if DEBUG_FORTH_STACK_GUARD 
1b90 cd ae 61				call check_stacks 
1b93					FORTH_CHK_RSP_UNDER 
1b93 e5				push hl 
1b94 d5				push de 
1b95 2a f2 e9			ld hl,(cli_ret_sp) 
1b98 11 ac e9			ld de, cli_ret_stack 
1b9b cd 04 0e			call cmp16 
1b9e da c2 62			jp c, fault_rsp_under 
1ba1 d1				pop de 
1ba2 e1				pop hl 
1ba3				endm 
# End of macro FORTH_CHK_RSP_UNDER
1ba3				endif 
1ba3 c9				ret 
1ba4			 
1ba4			 
1ba4			 
1ba4			; routine to load word pointed to by hl into hl 
1ba4			 
1ba4			loadhlptrtohl: 
1ba4			 
1ba4 d5				push de 
1ba5 5e				ld e, (hl) 
1ba6 23				inc hl 
1ba7 56				ld d, (hl) 
1ba8 eb				ex de, hl 
1ba9 d1				pop de 
1baa			 
1baa c9				ret 
1bab			 
1bab			 
1bab			 
1bab			 
1bab			 
1bab			; push a number held in HL onto the data stack 
1bab			; entry point for pushing a value when already in hl used in function above 
1bab			 
1bab			forth_push_numhl: 
1bab			 
1bab e5				push hl    ; save value to push 
1bac			 
1bac			if DEBUG_FORTH_PUSH 
1bac				; see if disabled 
1bac			 
1bac			 
1bac f5				push af 
1bad 3a 6f ee			ld a,(debug_vector) 
1bb0 fe c9			cp $c9   ; ret 
1bb2			;	ld a, (os_view_disable) 
1bb2			;	cp '*' 
1bb2 28 34			jr z, .pskip2 
1bb4 e5				push hl 
1bb5 e5			push hl 
1bb6 cd b9 0b			call clear_display 
1bb9 e1			pop hl 
1bba 7c				ld a,h 
1bbb 21 c6 e5			ld hl, os_word_scratch 
1bbe cd 40 10			call hexout 
1bc1 e1				pop hl 
1bc2 7d				ld a,l 
1bc3 21 c8 e5			ld hl, os_word_scratch+2 
1bc6 cd 40 10			call hexout 
1bc9			 
1bc9 21 ca e5			ld hl, os_word_scratch+4 
1bcc 3e 00			ld a,0 
1bce 77				ld (hl),a 
1bcf 11 c6 e5			ld de,os_word_scratch 
1bd2 3e 28				ld a, display_row_2 
1bd4 cd cc 0b				call str_at_display 
1bd7 11 c0 4c			ld de, .push_num 
1bda 3e 00			ld a, display_row_1 
1bdc			 
1bdc cd cc 0b				call str_at_display 
1bdf			 
1bdf			 
1bdf cd dc 0b			call update_display 
1be2 cd f1 0a			call delay1s 
1be5 cd f1 0a			call delay1s 
1be8			.pskip2:  
1be8			 
1be8 f1				pop af 
1be9			endif	 
1be9			 
1be9			 
1be9				FORTH_DSP_NEXT 
1be9 cd 3a 1b			call macro_forth_dsp_next 
1bec				endm 
# End of macro FORTH_DSP_NEXT
1bec			 
1bec 2a ee e9			ld hl, (cli_data_sp) 
1bef			 
1bef				; save item type 
1bef 3e 02			ld a,  DS_TYPE_INUM 
1bf1 77				ld (hl), a 
1bf2 23				inc hl 
1bf3			 
1bf3				; get word off stack 
1bf3 d1				pop de 
1bf4 7b				ld a,e 
1bf5 77				ld (hl), a 
1bf6 23				inc hl 
1bf7 7a				ld a,d 
1bf8 77				ld (hl), a 
1bf9			 
1bf9			if DEBUG_FORTH_PUSH 
1bf9 2b				dec hl 
1bfa 2b				dec hl 
1bfb 2b				dec hl 
1bfc						DMARK "PH5" 
1bfc f5				push af  
1bfd 3a 11 1c			ld a, (.dmark)  
1c00 32 6b ee			ld (debug_mark),a  
1c03 3a 12 1c			ld a, (.dmark+1)  
1c06 32 6c ee			ld (debug_mark+1),a  
1c09 3a 13 1c			ld a, (.dmark+2)  
1c0c 32 6d ee			ld (debug_mark+2),a  
1c0f 18 03			jr .pastdmark  
1c11 ..			.dmark: db "PH5"  
1c14 f1			.pastdmark: pop af  
1c15			endm  
# End of macro DMARK
1c15				CALLMONITOR 
1c15 cd 6f ee			call debug_vector  
1c18				endm  
# End of macro CALLMONITOR
1c18			endif	 
1c18			 
1c18 c9				ret 
1c19			 
1c19			 
1c19			; Push a string to stack pointed to by hl 
1c19			 
1c19			forth_push_str: 
1c19			 
1c19			if DEBUG_FORTH_PUSH 
1c19						DMARK "PSQ" 
1c19 f5				push af  
1c1a 3a 2e 1c			ld a, (.dmark)  
1c1d 32 6b ee			ld (debug_mark),a  
1c20 3a 2f 1c			ld a, (.dmark+1)  
1c23 32 6c ee			ld (debug_mark+1),a  
1c26 3a 30 1c			ld a, (.dmark+2)  
1c29 32 6d ee			ld (debug_mark+2),a  
1c2c 18 03			jr .pastdmark  
1c2e ..			.dmark: db "PSQ"  
1c31 f1			.pastdmark: pop af  
1c32			endm  
# End of macro DMARK
1c32				CALLMONITOR 
1c32 cd 6f ee			call debug_vector  
1c35				endm  
# End of macro CALLMONITOR
1c35			endif	 
1c35			    
1c35 e5				push hl 
1c36 e5				push hl 
1c37			 
1c37			;	ld a, 0   ; find end of string 
1c37 cd 9d 11			call strlenz 
1c3a			if DEBUG_FORTH_PUSH 
1c3a						DMARK "PQ2" 
1c3a f5				push af  
1c3b 3a 4f 1c			ld a, (.dmark)  
1c3e 32 6b ee			ld (debug_mark),a  
1c41 3a 50 1c			ld a, (.dmark+1)  
1c44 32 6c ee			ld (debug_mark+1),a  
1c47 3a 51 1c			ld a, (.dmark+2)  
1c4a 32 6d ee			ld (debug_mark+2),a  
1c4d 18 03			jr .pastdmark  
1c4f ..			.dmark: db "PQ2"  
1c52 f1			.pastdmark: pop af  
1c53			endm  
# End of macro DMARK
1c53				CALLMONITOR 
1c53 cd 6f ee			call debug_vector  
1c56				endm  
# End of macro CALLMONITOR
1c56			endif	 
1c56 eb				ex de, hl 
1c57 e1				pop hl   ; get ptr to start of string 
1c58			if DEBUG_FORTH_PUSH 
1c58						DMARK "PQ3" 
1c58 f5				push af  
1c59 3a 6d 1c			ld a, (.dmark)  
1c5c 32 6b ee			ld (debug_mark),a  
1c5f 3a 6e 1c			ld a, (.dmark+1)  
1c62 32 6c ee			ld (debug_mark+1),a  
1c65 3a 6f 1c			ld a, (.dmark+2)  
1c68 32 6d ee			ld (debug_mark+2),a  
1c6b 18 03			jr .pastdmark  
1c6d ..			.dmark: db "PQ3"  
1c70 f1			.pastdmark: pop af  
1c71			endm  
# End of macro DMARK
1c71				CALLMONITOR 
1c71 cd 6f ee			call debug_vector  
1c74				endm  
# End of macro CALLMONITOR
1c74			endif	 
1c74 19				add hl,de 
1c75			if DEBUG_FORTH_PUSH 
1c75						DMARK "PQE" 
1c75 f5				push af  
1c76 3a 8a 1c			ld a, (.dmark)  
1c79 32 6b ee			ld (debug_mark),a  
1c7c 3a 8b 1c			ld a, (.dmark+1)  
1c7f 32 6c ee			ld (debug_mark+1),a  
1c82 3a 8c 1c			ld a, (.dmark+2)  
1c85 32 6d ee			ld (debug_mark+2),a  
1c88 18 03			jr .pastdmark  
1c8a ..			.dmark: db "PQE"  
1c8d f1			.pastdmark: pop af  
1c8e			endm  
# End of macro DMARK
1c8e				CALLMONITOR 
1c8e cd 6f ee			call debug_vector  
1c91				endm  
# End of macro CALLMONITOR
1c91			endif	 
1c91			 
1c91 2b				dec hl    ; see if there is an optional trailing double quote 
1c92 7e				ld a,(hl) 
1c93 fe 22			cp '"' 
1c95 20 03			jr nz, .strnoq 
1c97 3e 00			ld a, 0      ; get rid of double quote 
1c99 77				ld (hl), a 
1c9a 23			.strnoq: inc hl 
1c9b			 
1c9b 3e 00			ld a, 0 
1c9d 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1c9e			 
1c9e 13				inc de ; add one for the type string 
1c9f 13				inc de ; add one for null term??? 
1ca0			 
1ca0				; tos is get string pointer again 
1ca0				; de contains space to allocate 
1ca0				 
1ca0 d5				push de 
1ca1			 
1ca1 eb				ex de, hl 
1ca2			 
1ca2				;push af 
1ca2			 
1ca2			if DEBUG_FORTH_PUSH 
1ca2						DMARK "PHm" 
1ca2 f5				push af  
1ca3 3a b7 1c			ld a, (.dmark)  
1ca6 32 6b ee			ld (debug_mark),a  
1ca9 3a b8 1c			ld a, (.dmark+1)  
1cac 32 6c ee			ld (debug_mark+1),a  
1caf 3a b9 1c			ld a, (.dmark+2)  
1cb2 32 6d ee			ld (debug_mark+2),a  
1cb5 18 03			jr .pastdmark  
1cb7 ..			.dmark: db "PHm"  
1cba f1			.pastdmark: pop af  
1cbb			endm  
# End of macro DMARK
1cbb				CALLMONITOR 
1cbb cd 6f ee			call debug_vector  
1cbe				endm  
# End of macro CALLMONITOR
1cbe			endif	 
1cbe cd 12 12			call malloc	; on ret hl now contains allocated memory 
1cc1				if DEBUG_FORTH_MALLOC_GUARD 
1cc1 cc 18 4d				call z,malloc_error 
1cc4				endif 
1cc4			 
1cc4				 
1cc4 c1				pop bc    ; get length 
1cc5 d1				pop de   ;  get string start    
1cc6			 
1cc6				; hl has destination from malloc 
1cc6			 
1cc6 eb				ex de, hl    ; prep for ldir 
1cc7			 
1cc7 d5				push de   ; save malloc area for DSP later 
1cc8				;push hl   ; save malloc area for DSP later 
1cc8			 
1cc8			if DEBUG_FORTH_PUSH 
1cc8						DMARK "PHc" 
1cc8 f5				push af  
1cc9 3a dd 1c			ld a, (.dmark)  
1ccc 32 6b ee			ld (debug_mark),a  
1ccf 3a de 1c			ld a, (.dmark+1)  
1cd2 32 6c ee			ld (debug_mark+1),a  
1cd5 3a df 1c			ld a, (.dmark+2)  
1cd8 32 6d ee			ld (debug_mark+2),a  
1cdb 18 03			jr .pastdmark  
1cdd ..			.dmark: db "PHc"  
1ce0 f1			.pastdmark: pop af  
1ce1			endm  
# End of macro DMARK
1ce1				CALLMONITOR 
1ce1 cd 6f ee			call debug_vector  
1ce4				endm  
# End of macro CALLMONITOR
1ce4			endif	 
1ce4			 
1ce4			 
1ce4 ed b0			ldir 
1ce6			 
1ce6			 
1ce6				; push malloc to data stack     macro?????  
1ce6			 
1ce6				FORTH_DSP_NEXT 
1ce6 cd 3a 1b			call macro_forth_dsp_next 
1ce9				endm 
# End of macro FORTH_DSP_NEXT
1ce9			 
1ce9				; save value and type 
1ce9			 
1ce9 2a ee e9			ld hl, (cli_data_sp) 
1cec			 
1cec				; save item type 
1cec 3e 01			ld a,  DS_TYPE_STR 
1cee 77				ld (hl), a 
1cef 23				inc hl 
1cf0			 
1cf0				; get malloc word off stack 
1cf0 d1				pop de 
1cf1 73				ld (hl), e 
1cf2 23				inc hl 
1cf3 72				ld (hl), d 
1cf4			 
1cf4			 
1cf4			 
1cf4			if DEBUG_FORTH_PUSH 
1cf4 2a ee e9			ld hl, (cli_data_sp) 
1cf7						DMARK "PHS" 
1cf7 f5				push af  
1cf8 3a 0c 1d			ld a, (.dmark)  
1cfb 32 6b ee			ld (debug_mark),a  
1cfe 3a 0d 1d			ld a, (.dmark+1)  
1d01 32 6c ee			ld (debug_mark+1),a  
1d04 3a 0e 1d			ld a, (.dmark+2)  
1d07 32 6d ee			ld (debug_mark+2),a  
1d0a 18 03			jr .pastdmark  
1d0c ..			.dmark: db "PHS"  
1d0f f1			.pastdmark: pop af  
1d10			endm  
# End of macro DMARK
1d10				CALLMONITOR 
1d10 cd 6f ee			call debug_vector  
1d13				endm  
# End of macro CALLMONITOR
1d13			;	ex de,hl 
1d13			endif	 
1d13				; in case of spaces, skip the ptr past the copied string 
1d13				;pop af 
1d13				;ld (cli_origptr),hl 
1d13			 
1d13 c9				ret 
1d14			 
1d14			 
1d14			 
1d14			; TODO ascii push input onto stack given hl to start of input 
1d14			 
1d14			; identify type 
1d14			; if starts with a " then a string 
1d14			; otherwise it is a number 
1d14			;  
1d14			; if a string 
1d14			;     scan for ending " to get length of string to malloc for + 1 
1d14			;     malloc 
1d14			;     put pointer to string on stack first byte flags as string 
1d14			; 
1d14			; else a number 
1d14			;    look for number format identifier 
1d14			;    $xx hex 
1d14			;    %xxxxx bin 
1d14			;    xxxxx decimal 
1d14			;    convert number to 16bit word.  
1d14			;    malloc word + 1 with flag to identiy as num 
1d14			;    put pointer to number on stack 
1d14			;   
1d14			;  
1d14			  
1d14			forth_apush: 
1d14				; kernel push 
1d14			 
1d14			if DEBUG_FORTH_PUSH 
1d14						DMARK "PSH" 
1d14 f5				push af  
1d15 3a 29 1d			ld a, (.dmark)  
1d18 32 6b ee			ld (debug_mark),a  
1d1b 3a 2a 1d			ld a, (.dmark+1)  
1d1e 32 6c ee			ld (debug_mark+1),a  
1d21 3a 2b 1d			ld a, (.dmark+2)  
1d24 32 6d ee			ld (debug_mark+2),a  
1d27 18 03			jr .pastdmark  
1d29 ..			.dmark: db "PSH"  
1d2c f1			.pastdmark: pop af  
1d2d			endm  
# End of macro DMARK
1d2d				CALLMONITOR 
1d2d cd 6f ee			call debug_vector  
1d30				endm  
# End of macro CALLMONITOR
1d30			endif	 
1d30				; identify input type 
1d30			 
1d30 7e				ld a,(hl) 
1d31 fe 22			cp '"' 
1d33 28 0a			jr z, .fapstr 
1d35 fe 24			cp '$' 
1d37 ca 5f 1d			jp z, .faphex 
1d3a fe 25			cp '%' 
1d3c ca 47 1d			jp z, .fapbin 
1d3f			;	cp 'b' 
1d3f			;	jp z, .fabin 
1d3f				; else decimal 
1d3f			 
1d3f				; TODO do decimal conversion 
1d3f				; decimal is stored as a 16bit word 
1d3f			 
1d3f				; by default everything is a string if type is not detected 
1d3f			.fapstr: ; 
1d3f fe 22			cp '"' 
1d41 20 01			jr nz, .strnoqu 
1d43 23				inc hl 
1d44			.strnoqu: 
1d44 c3 19 1c			jp forth_push_str 
1d47			 
1d47			 
1d47			 
1d47			.fapbin:    ; push a binary string.  
1d47 11 00 00			ld de, 0   ; hold a 16bit value 
1d4a			 
1d4a 23			.fapbinshift:	inc hl  
1d4b 7e				ld a,(hl) 
1d4c fe 00			cp 0     ; done scanning  
1d4e 28 0b			jr z, .fapbdone  	; got it in HL so push  
1d50			 
1d50				; left shift de 
1d50 eb				ex de, hl	 
1d51 29				add hl, hl 
1d52			 
1d52				; is 1 
1d52 fe 31			cp '1' 
1d54 20 02			jr nz, .binzero 
1d56 cb 4d			bit 1, l 
1d58			.binzero: 
1d58 eb				ex de, hl	 ; save current de 
1d59 18 ef			jr .fapbinshift 
1d5b			 
1d5b			.fapbdone: 
1d5b eb				ex de, hl 
1d5c c3 ab 1b			jp forth_push_numhl 
1d5f			 
1d5f			 
1d5f			.faphex:   ; hex is always stored as a 16bit word 
1d5f				; skip number prefix 
1d5f 23				inc hl 
1d60				; turn ascii into number 
1d60 cd f6 10			call get_word_hl	; ret 16bit word in hl 
1d63			 
1d63 c3 ab 1b			jp forth_push_numhl 
1d66			 
1d66 00				 nop 
1d67			 
1d67			.fabin:   ; TODO bin conversion 
1d67			 
1d67			 
1d67 c9				ret 
1d68			 
1d68			 
1d68			; get either a string ptr or a 16bit word from the data stack 
1d68			 
1d68			FORTH_DSP: macro 
1d68				call macro_forth_dsp 
1d68				endm 
1d68			 
1d68			macro_forth_dsp: 
1d68				; data stack pointer points to current word on tos 
1d68			 
1d68 2a ee e9			ld hl,(cli_data_sp) 
1d6b			 
1d6b				if DEBUG_FORTH_PUSH 
1d6b						DMARK "DSP" 
1d6b f5				push af  
1d6c 3a 80 1d			ld a, (.dmark)  
1d6f 32 6b ee			ld (debug_mark),a  
1d72 3a 81 1d			ld a, (.dmark+1)  
1d75 32 6c ee			ld (debug_mark+1),a  
1d78 3a 82 1d			ld a, (.dmark+2)  
1d7b 32 6d ee			ld (debug_mark+2),a  
1d7e 18 03			jr .pastdmark  
1d80 ..			.dmark: db "DSP"  
1d83 f1			.pastdmark: pop af  
1d84			endm  
# End of macro DMARK
1d84			 
1d84 cd 4b 4d				call display_data_sp 
1d87				;call break_point_state 
1d87				;rst 030h 
1d87				CALLMONITOR 
1d87 cd 6f ee			call debug_vector  
1d8a				endm  
# End of macro CALLMONITOR
1d8a				endif 
1d8a			 
1d8a c9				ret 
1d8b			 
1d8b			; return hl to start of value on stack 
1d8b			 
1d8b			FORTH_DSP_VALUE: macro 
1d8b				call macro_forth_dsp_value 
1d8b				endm 
1d8b			 
1d8b			macro_forth_dsp_value: 
1d8b			 
1d8b				FORTH_DSP 
1d8b cd 68 1d			call macro_forth_dsp 
1d8e				endm 
# End of macro FORTH_DSP
1d8e			 
1d8e d5				push de 
1d8f			 
1d8f 23				inc hl ; skip type 
1d90			 
1d90 5e				ld e, (hl) 
1d91 23				inc hl 
1d92 56				ld d, (hl) 
1d93 eb				ex de,hl  
1d94			 
1d94 d1				pop de 
1d95			 
1d95 c9				ret 
1d96			 
1d96			; return hl to start of value to second item on stack 
1d96			 
1d96			FORTH_DSP_VALUEM1: macro 
1d96				call macro_forth_dsp_value_m1 
1d96				endm 
1d96			 
1d96			macro_forth_dsp_value_m1: 
1d96			 
1d96				FORTH_DSP 
1d96 cd 68 1d			call macro_forth_dsp 
1d99				endm 
# End of macro FORTH_DSP
1d99			 
1d99 2b				dec hl 
1d9a 2b				dec hl 
1d9b			;	dec hl 
1d9b			 
1d9b d5				push de 
1d9c			 
1d9c 5e				ld e, (hl) 
1d9d 23				inc hl 
1d9e 56				ld d, (hl) 
1d9f eb				ex de,hl  
1da0			 
1da0 d1				pop de 
1da1			 
1da1 c9				ret 
1da2			 
1da2				 
1da2			 
1da2			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1da2			 
1da2			FORTH_DSP_POP: macro 
1da2				call macro_forth_dsp_pop 
1da2				endm 
1da2			 
1da2			 
1da2			; get the tos data type 
1da2			 
1da2			FORTH_DSP_TYPE:   macro 
1da2			 
1da2				;FORTH_DSP_VALUE 
1da2				FORTH_DSP 
1da2				 
1da2				; hl points to value 
1da2				; check type 
1da2			 
1da2				ld a,(hl) 
1da2			 
1da2				endm 
1da2			 
1da2			; load the tos value into hl 
1da2			 
1da2			 
1da2			FORTH_DSP_VALUEHL:  macro 
1da2				call macro_dsp_valuehl 
1da2				endm 
1da2			 
1da2			 
1da2			 
1da2			macro_dsp_valuehl: 
1da2				FORTH_DSP_VALUE 
1da2 cd 8b 1d			call macro_forth_dsp_value 
1da5				endm 
# End of macro FORTH_DSP_VALUE
1da5			 
1da5				;FORTH_ERR_TOS_NOTNUM 
1da5			 
1da5				;inc hl   ; skip type id 
1da5			 
1da5			;	push de 
1da5			; 
1da5			;	ld e, (hl) 
1da5			;	inc hl 
1da5			;	ld d, (hl) 
1da5			;	ex de,hl  
1da5			 
1da5			;	pop de 
1da5			 
1da5				if DEBUG_FORTH_PUSH 
1da5						DMARK "DVL" 
1da5 f5				push af  
1da6 3a ba 1d			ld a, (.dmark)  
1da9 32 6b ee			ld (debug_mark),a  
1dac 3a bb 1d			ld a, (.dmark+1)  
1daf 32 6c ee			ld (debug_mark+1),a  
1db2 3a bc 1d			ld a, (.dmark+2)  
1db5 32 6d ee			ld (debug_mark+2),a  
1db8 18 03			jr .pastdmark  
1dba ..			.dmark: db "DVL"  
1dbd f1			.pastdmark: pop af  
1dbe			endm  
# End of macro DMARK
1dbe				CALLMONITOR 
1dbe cd 6f ee			call debug_vector  
1dc1				endm  
# End of macro CALLMONITOR
1dc1				endif 
1dc1 c9				ret 
1dc2			 
1dc2			forth_apushstrhl:      
1dc2				; push of string requires use of cli_origptr 
1dc2				; bodge use 
1dc2			 
1dc2				; get current cli_origptr, save, update with temp pointer  
1dc2 ed 5b 3e ea		ld de, (cli_origptr) 
1dc6 22 3e ea			ld (cli_origptr), hl 
1dc9 d5				push de 
1dca cd 14 1d			call forth_apush 
1dcd d1				pop de 
1dce ed 53 3e ea		ld (cli_origptr), de 
1dd2 c9			        ret	 
1dd3			 
1dd3			 
1dd3			; increase loop stack pointer and save hl to it 
1dd3				 
1dd3			FORTH_LOOP_NEXT: macro 
1dd3				call macro_forth_loop_next 
1dd3				;nop 
1dd3				endm 
1dd3			 
1dd3			macro_forth_loop_next: 
1dd3				if DEBUG_FORTH_STACK_GUARD 
1dd3 cd ae 61				call check_stacks 
1dd6				endif 
1dd6 e5				push hl 
1dd7 d5				push de 
1dd8 eb				ex de,hl 
1dd9 2a f0 e9			ld hl,(cli_loop_sp) 
1ddc 23				inc hl 
1ddd 23				inc hl 
1dde					if DEBUG_FORTH_WORDS 
1dde						DMARK "LNX" 
1dde f5				push af  
1ddf 3a f3 1d			ld a, (.dmark)  
1de2 32 6b ee			ld (debug_mark),a  
1de5 3a f4 1d			ld a, (.dmark+1)  
1de8 32 6c ee			ld (debug_mark+1),a  
1deb 3a f5 1d			ld a, (.dmark+2)  
1dee 32 6d ee			ld (debug_mark+2),a  
1df1 18 03			jr .pastdmark  
1df3 ..			.dmark: db "LNX"  
1df6 f1			.pastdmark: pop af  
1df7			endm  
# End of macro DMARK
1df7						CALLMONITOR 
1df7 cd 6f ee			call debug_vector  
1dfa				endm  
# End of macro CALLMONITOR
1dfa					endif 
1dfa 22 f0 e9			ld (cli_loop_sp),hl 
1dfd 73				ld (hl), e 
1dfe 23				inc hl 
1dff 72				ld (hl), d 
1e00 d1				pop de    ; been reversed so save a swap on restore 
1e01 e1				pop hl 
1e02				if DEBUG_FORTH_STACK_GUARD 
1e02 cd ae 61				call check_stacks 
1e05				endif 
1e05 c9				ret 
1e06			 
1e06			; get current ret stack pointer and save to hl  
1e06				 
1e06			FORTH_LOOP_TOS: macro 
1e06				call macro_forth_loop_tos 
1e06				endm 
1e06			 
1e06			macro_forth_loop_tos: 
1e06 d5				push de 
1e07 2a f0 e9			ld hl,(cli_loop_sp) 
1e0a 5e				ld e, (hl) 
1e0b 23				inc hl 
1e0c 56				ld d, (hl) 
1e0d eb				ex de, hl 
1e0e d1				pop de 
1e0f c9				ret 
1e10			 
1e10			; pop loop stack pointer 
1e10				 
1e10			FORTH_LOOP_POP: macro 
1e10				call macro_forth_loop_pop 
1e10				endm 
1e10			 
1e10			 
1e10			macro_forth_loop_pop: 
1e10				if DEBUG_FORTH_STACK_GUARD 
1e10					DMARK "LPP" 
1e10 f5				push af  
1e11 3a 25 1e			ld a, (.dmark)  
1e14 32 6b ee			ld (debug_mark),a  
1e17 3a 26 1e			ld a, (.dmark+1)  
1e1a 32 6c ee			ld (debug_mark+1),a  
1e1d 3a 27 1e			ld a, (.dmark+2)  
1e20 32 6d ee			ld (debug_mark+2),a  
1e23 18 03			jr .pastdmark  
1e25 ..			.dmark: db "LPP"  
1e28 f1			.pastdmark: pop af  
1e29			endm  
# End of macro DMARK
1e29 cd ae 61				call check_stacks 
1e2c					FORTH_CHK_LOOP_UNDER 
1e2c e5				push hl 
1e2d d5				push de 
1e2e 2a f0 e9			ld hl,(cli_loop_sp) 
1e31 11 2a e9			ld de, cli_loop_stack 
1e34 cd 04 0e			call cmp16 
1e37 da c8 62			jp c, fault_loop_under 
1e3a d1				pop de 
1e3b e1				pop hl 
1e3c				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1e3c				endif 
1e3c e5				push hl 
1e3d 2a f0 e9			ld hl,(cli_loop_sp) 
1e40 2b				dec hl 
1e41 2b				dec hl 
1e42 22 f0 e9			ld (cli_loop_sp), hl 
1e45				; TODO do stack underflow checks 
1e45 e1				pop hl 
1e46				if DEBUG_FORTH_STACK_GUARD 
1e46 cd ae 61				call check_stacks 
1e49					FORTH_CHK_LOOP_UNDER 
1e49 e5				push hl 
1e4a d5				push de 
1e4b 2a f0 e9			ld hl,(cli_loop_sp) 
1e4e 11 2a e9			ld de, cli_loop_stack 
1e51 cd 04 0e			call cmp16 
1e54 da c8 62			jp c, fault_loop_under 
1e57 d1				pop de 
1e58 e1				pop hl 
1e59				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1e59				endif 
1e59 c9				ret 
1e5a			 
1e5a			macro_forth_dsp_pop: 
1e5a			 
1e5a e5				push hl 
1e5b			 
1e5b				; release malloc data 
1e5b			 
1e5b				if DEBUG_FORTH_STACK_GUARD 
1e5b cd ae 61				call check_stacks 
1e5e					FORTH_CHK_DSP_UNDER 
1e5e e5				push hl 
1e5f d5				push de 
1e60 2a ee e9			ld hl,(cli_data_sp) 
1e63 11 28 e8			ld de, cli_data_stack 
1e66 cd 04 0e			call cmp16 
1e69 da bc 62			jp c, fault_dsp_under 
1e6c d1				pop de 
1e6d e1				pop hl 
1e6e				endm 
# End of macro FORTH_CHK_DSP_UNDER
1e6e				endif 
1e6e				;ld hl,(cli_data_sp) 
1e6e			if DEBUG_FORTH_DOT 
1e6e				DMARK "DPP" 
1e6e f5				push af  
1e6f 3a 83 1e			ld a, (.dmark)  
1e72 32 6b ee			ld (debug_mark),a  
1e75 3a 84 1e			ld a, (.dmark+1)  
1e78 32 6c ee			ld (debug_mark+1),a  
1e7b 3a 85 1e			ld a, (.dmark+2)  
1e7e 32 6d ee			ld (debug_mark+2),a  
1e81 18 03			jr .pastdmark  
1e83 ..			.dmark: db "DPP"  
1e86 f1			.pastdmark: pop af  
1e87			endm  
# End of macro DMARK
1e87				CALLMONITOR 
1e87 cd 6f ee			call debug_vector  
1e8a				endm  
# End of macro CALLMONITOR
1e8a			endif	 
1e8a			 
1e8a			 
1e8a			if FORTH_ENABLE_DSPPOPFREE 
1e8a			 
1e8a				FORTH_DSP 
1e8a cd 68 1d			call macro_forth_dsp 
1e8d				endm 
# End of macro FORTH_DSP
1e8d			 
1e8d 7e				ld a, (hl) 
1e8e fe 01			cp DS_TYPE_STR 
1e90 20 23			jr nz, .skippopfree 
1e92			 
1e92				FORTH_DSP_VALUEHL 
1e92 cd a2 1d			call macro_dsp_valuehl 
1e95				endm 
# End of macro FORTH_DSP_VALUEHL
1e95 00				nop 
1e96			if DEBUG_FORTH_DOT 
1e96				DMARK "DPf" 
1e96 f5				push af  
1e97 3a ab 1e			ld a, (.dmark)  
1e9a 32 6b ee			ld (debug_mark),a  
1e9d 3a ac 1e			ld a, (.dmark+1)  
1ea0 32 6c ee			ld (debug_mark+1),a  
1ea3 3a ad 1e			ld a, (.dmark+2)  
1ea6 32 6d ee			ld (debug_mark+2),a  
1ea9 18 03			jr .pastdmark  
1eab ..			.dmark: db "DPf"  
1eae f1			.pastdmark: pop af  
1eaf			endm  
# End of macro DMARK
1eaf				CALLMONITOR 
1eaf cd 6f ee			call debug_vector  
1eb2				endm  
# End of macro CALLMONITOR
1eb2			endif	 
1eb2 cd dc 12			call free 
1eb5			.skippopfree: 
1eb5				 
1eb5			 
1eb5			endif 
1eb5			 
1eb5			if DEBUG_FORTH_DOT_KEY 
1eb5				DMARK "DP2" 
1eb5				CALLMONITOR 
1eb5			endif	 
1eb5			 
1eb5				; move pointer down 
1eb5			 
1eb5 2a ee e9			ld hl,(cli_data_sp) 
1eb8 2b				dec hl 
1eb9 2b				dec hl 
1eba			; PARSEV5 
1eba 2b				dec hl 
1ebb 22 ee e9			ld (cli_data_sp), hl 
1ebe			 
1ebe				if DEBUG_FORTH_STACK_GUARD 
1ebe cd ae 61				call check_stacks 
1ec1					FORTH_CHK_DSP_UNDER 
1ec1 e5				push hl 
1ec2 d5				push de 
1ec3 2a ee e9			ld hl,(cli_data_sp) 
1ec6 11 28 e8			ld de, cli_data_stack 
1ec9 cd 04 0e			call cmp16 
1ecc da bc 62			jp c, fault_dsp_under 
1ecf d1				pop de 
1ed0 e1				pop hl 
1ed1				endm 
# End of macro FORTH_CHK_DSP_UNDER
1ed1				endif 
1ed1			 
1ed1 e1				pop hl 
1ed2			 
1ed2 c9				ret 
1ed3			 
1ed3			getwordathl: 
1ed3				; hl points to an address 
1ed3				; load hl with the word at that address 
1ed3			 
1ed3 d5				push de 
1ed4			 
1ed4 5e				ld e, (hl) 
1ed5 23				inc hl 
1ed6 56				ld d, (hl) 
1ed7 eb				ex de, hl 
1ed8			 
1ed8 d1				pop de 
1ed9 c9				ret 
1eda			 
1eda			 
1eda			 
1eda			 
1eda			 
1eda			; eof 
1eda			 
# End of file forth_stackopsv5.asm
1eda			endif 
1eda			 
1eda			loadwordinhl:	 
1eda			 
1eda d5				push de 
1edb			 
1edb 5e				ld e, (hl) 
1edc 23				inc hl 
1edd 56				ld d, (hl) 
1ede eb				ex de,hl  
1edf			 
1edf d1				pop de 
1ee0			 
1ee0 c9				ret 
1ee1			 
1ee1			user_word_eol:  
1ee1				; hl contains the pointer to where to create a linked list item from the end 
1ee1				; of the user dict to continue on at the system word dict 
1ee1				 
1ee1				; poke the stub of the word list linked list to repoint to rom words 
1ee1			 
1ee1				; stub format 
1ee1				; db   word id 
1ee1				; dw    link to next word 
1ee1			        ; db char length of token 
1ee1				; db string + 0 term 
1ee1				; db exec code....  
1ee1			 
1ee1 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1ee3 77				ld (hl), a		; word id 
1ee4 23				inc hl 
1ee5			 
1ee5 11 b0 20			ld de, sysdict 
1ee8 73				ld (hl), e		; next word link ie system dict 
1ee9 23				inc hl 
1eea 72				ld (hl), d		; next word link ie system dict 
1eeb 23				inc hl	 
1eec			 
1eec			;	ld (hl), sysdict		; next word link ie system dict 
1eec			;	inc hl 
1eec			;	inc hl 
1eec			 
1eec			;	inc hl 
1eec			;	inc hl 
1eec			 
1eec 3e 02			ld a, 2			; word length is 0 
1eee 77				ld (hl), a	 
1eef 23				inc hl 
1ef0			 
1ef0 3e 7e			ld a, '~'			; word length is 0 
1ef2 77				ld (hl), a	 
1ef3 23				inc hl 
1ef4 3e 00			ld a, 0			; save empty word 
1ef6 77				ld (hl), a 
1ef7			 
1ef7 c9				ret 
1ef8			 
1ef8				 
1ef8			 
1ef8			forthexec_cleanup: 
1ef8				FORTH_RSP_POP 
1ef8 cd 73 1b			call macro_forth_rsp_pop 
1efb				endm 
# End of macro FORTH_RSP_POP
1efb c9				ret 
1efc			 
1efc			forth_call_hl: 
1efc				; taking hl 
1efc e5				push hl 
1efd c9				ret 
1efe			 
1efe			; this is called to reset Forth system but keep existing uwords etc 
1efe			 
1efe			forth_warmstart: 
1efe				; setup stack over/under flow checks 
1efe				if DEBUG_FORTH_STACK_GUARD 
1efe cd 94 61				call chk_stk_init 
1f01				endif 
1f01			 
1f01				; init stack pointers  - * these stacks go upwards *  
1f01 21 ac e9			ld hl, cli_ret_stack 
1f04 22 f2 e9			ld (cli_ret_sp), hl	 
1f07				; set bottom of stack 
1f07 3e 00			ld a,0 
1f09 77				ld (hl),a 
1f0a 23				inc hl 
1f0b 77				ld (hl),a 
1f0c			 
1f0c 21 28 e8			ld hl, cli_data_stack 
1f0f 22 ee e9			ld (cli_data_sp), hl	 
1f12				; set bottom of stack 
1f12 3e 00			ld a,0 
1f14 77				ld (hl),a 
1f15 23				inc hl 
1f16 77				ld (hl),a 
1f17			 
1f17 21 2a e9			ld hl, cli_loop_stack 
1f1a 22 f0 e9			ld (cli_loop_sp), hl	 
1f1d				; set bottom of stack 
1f1d 3e 00			ld a,0 
1f1f 77				ld (hl),a 
1f20 23				inc hl 
1f21 77				ld (hl),a 
1f22			 
1f22				; init extent of current open file 
1f22			 
1f22 3e 00			ld a, 0 
1f24 32 6a ea			ld (store_openext), a 
1f27			 
1f27 c9				ret 
1f28			 
1f28			 
1f28			 
1f28			; Cold Start - this is called to setup the whole Forth system 
1f28			 
1f28			forth_init: 
1f28			 
1f28				; setup stack over/under flow checks 
1f28			 
1f28			;	if DEBUG_FORTH_STACK_GUARD 
1f28			;		call chk_stk_init 
1f28			;	endif 
1f28			 
1f28				; enable auto display updates (slow.....) 
1f28			 
1f28 3e 01			ld a, 1 
1f2a 32 3c ea			ld (cli_autodisplay), a 
1f2d			 
1f2d				; if storage is in use disable long reads for now 
1f2d 3e 00			ld a, 0 
1f2f 32 75 ea			ld (store_longread), a 
1f32			 
1f32			 
1f32				; show start up screen 
1f32			 
1f32 cd b9 0b			call clear_display 
1f35			 
1f35 3e 00			ld a,0 
1f37 32 5e ea			ld (f_cursor_ptr), a 
1f3a			 
1f3a				; set start of word list in start of ram - for use when creating user words 
1f3a			 
1f3a 21 a0 65			ld hl, baseram 
1f3d 22 be e5			ld (os_last_new_uword), hl 
1f40 cd e1 1e			call user_word_eol 
1f43				 
1f43			;		call display_data_sp 
1f43			;		call next_page_prompt 
1f43			 
1f43			 
1f43			 
1f43			 
1f43 c9				ret 
1f44			 
1f44 .. 00		.bootforth: db " Forth Kernel Init ",0 
1f58			 
1f58			; TODO push to stack 
1f58			 
1f58			;  
1f58			 
1f58			if FORTH_PARSEV2 
1f58			 
1f58			 
1f58				include "forth_parserv2.asm" 
1f58			 
1f58			endif 
1f58			 
1f58			 
1f58			; parse cli version 1 
1f58			 
1f58			if FORTH_PARSEV1 
1f58			 
1f58			 
1f58			 
1f58			      include "forth_parserv1.asm" 
1f58			endif 
1f58				 
1f58			if FORTH_PARSEV3 
1f58			 
1f58			 
1f58			 
1f58			      include "forth_parserv3.asm" 
1f58				include "forth_wordsv3.asm" 
1f58			endif 
1f58			 
1f58			if FORTH_PARSEV4 
1f58			 
1f58			 
1f58			 
1f58			      include "forth_parserv4.asm" 
1f58				include "forth_wordsv4.asm" 
1f58			endif 
1f58			 
1f58			if FORTH_PARSEV5 
1f58			 
1f58			 
1f58			 
1f58			      include "forth_parserv5.asm" 
1f58			 
1f58			 
1f58			; A better parser without using malloc and string copies all over the place.  
1f58			; Exec in situ should be faster 
1f58			 
1f58			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
1f58			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
1f58			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
1f58			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
1f58			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
1f58			WORD_SYS_END: equ 0   ; Opcode for all user words 
1f58			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
1f58			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
1f58			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
1f58			 
1f58			; Core word preamble macro 
1f58			 
1f58			CWHEAD:   macro nxtword opcode lit len opflags 
1f58				db WORD_SYS_CORE+opcode             
1f58				; internal op code number 
1f58				dw nxtword            
1f58				; link to next dict word block 
1f58				db len + 1 
1f58				; literal length of dict word inc zero term 
1f58				db lit,0              
1f58				; literal dict word 
1f58			        ; TODO db opflags        
1f58				endm 
1f58			 
1f58			 
1f58			NEXTW: macro  
1f58				jp macro_next 
1f58				endm 
1f58			 
1f58			macro_next: 
1f58			if DEBUG_FORTH_PARSE_KEY 
1f58				DMARK "NXT" 
1f58				CALLMONITOR 
1f58			endif	 
1f58			;	inc hl  ; skip token null term  
1f58 ed 4b 40 ea		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1f5c ed 5b 3e ea		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1f60 2a c2 e5			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1f63			if DEBUG_FORTH_PARSE_KEY 
1f63				DMARK "}AA" 
1f63				CALLMONITOR 
1f63			endif	 
1f63 c3 66 20			jp execnext 
1f66				;jp exec1 
1f66			       
1f66			 
1f66			 
1f66			; Another go at the parser to compile  
1f66			 
1f66			 
1f66			; TODO rework parser to change all of the string words to byte tokens 
1f66			; TODO do a search for  
1f66			 
1f66			; TODO first run normal parser to zero term sections 
1f66			; TODO for each word do a token look up to get the op code 
1f66			; TODO need some means to flag to the exec that this is a byte code form    
1f66			 
1f66			 
1f66			forthcompile: 
1f66			 
1f66			; 
1f66			; line parse: 
1f66			;       parse raw input buffer 
1f66			;       tokenise the words 
1f66			;       malloc new copy (for looping etc) 
1f66			;       copy to malloc + current pc in line to start of string and add line term 
1f66			;       save on new rsp 
1f66			; 
1f66			 
1f66			; hl to point to the line to tokenise 
1f66			 
1f66			;	push hl 
1f66 22 c2 e5			ld (os_tok_ptr), hl  ; save ptr to string 
1f69			 
1f69			;	ld a,0		; string term on input 
1f69			;	call strlent 
1f69			 
1f69			;	ld (os_tok_len), hl	 ; save string length 
1f69			 
1f69			;if DEBUG_FORTH_TOK 
1f69			;	ex de,hl		 
1f69			;endif 
1f69			 
1f69			;	pop hl 		; get back string pointer 
1f69			 
1f69			if DEBUG_FORTH_TOK 
1f69						DMARK "TOc" 
1f69				CALLMONITOR 
1f69			endif 
1f69 7e			.cptoken2:    ld a,(hl) 
1f6a 23				inc hl 
1f6b fe 7f			cp FORTH_END_BUFFER 
1f6d 28 29			jr z, .cptokendone2 
1f6f fe 00			cp 0 
1f71 28 25			jr z, .cptokendone2 
1f73 fe 22			cp '"' 
1f75 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
1f77 fe 20			cp ' ' 
1f79 20 ee			jr nz,  .cptoken2 
1f7b			 
1f7b			; TODO consume comments held between ( and ) 
1f7b			 
1f7b				; we have a space so change to zero term for dict match later 
1f7b 2b				dec hl 
1f7c 3e 00			ld a,0 
1f7e 77				ld (hl), a 
1f7f 23				inc hl 
1f80 18 e7			jr .cptoken2 
1f82				 
1f82			 
1f82			.cptokenstr2: 
1f82				; skip all white space until either eol (because forgot to term) or end double quote 
1f82			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1f82				;inc hl ; skip current double quote 
1f82 7e				ld a,(hl) 
1f83 23				inc hl 
1f84 fe 22			cp '"' 
1f86 28 e1			jr z, .cptoken2 
1f88 fe 7f			cp FORTH_END_BUFFER 
1f8a 28 0c			jr z, .cptokendone2 
1f8c fe 00			cp 0 
1f8e 28 08			jr z, .cptokendone2 
1f90 fe 20			cp ' ' 
1f92 28 02			jr z, .cptmp2 
1f94 18 ec			jr .cptokenstr2 
1f96			 
1f96			.cptmp2:	; we have a space so change to zero term for dict match later 
1f96				;dec hl 
1f96				;ld a,"-"	; TODO remove this when working 
1f96				;ld (hl), a 
1f96				;inc hl 
1f96 18 ea			jr .cptokenstr2 
1f98			 
1f98			.cptokendone2: 
1f98				;inc hl 
1f98 3e 7f			ld a, FORTH_END_BUFFER 
1f9a 77				ld (hl),a 
1f9b 23				inc hl 
1f9c 3e 21			ld a, '!' 
1f9e 77				ld (hl),a 
1f9f			 
1f9f 2a c2 e5			ld hl,(os_tok_ptr) 
1fa2			         
1fa2			if DEBUG_FORTH_TOK 
1fa2						DMARK "Tc1" 
1fa2				CALLMONITOR 
1fa2			endif 
1fa2			 
1fa2				; push exec string to top of return stack 
1fa2				FORTH_RSP_NEXT 
1fa2 cd 52 1b			call macro_forth_rsp_next 
1fa5				endm 
# End of macro FORTH_RSP_NEXT
1fa5 c9				ret 
1fa6			 
1fa6			; Another go at the parser need to simplify the process 
1fa6			 
1fa6			forthparse: 
1fa6			 
1fa6			; 
1fa6			; line parse: 
1fa6			;       parse raw input buffer 
1fa6			;       tokenise the words 
1fa6			;       malloc new copy (for looping etc) 
1fa6			;       copy to malloc + current pc in line to start of string and add line term 
1fa6			;       save on new rsp 
1fa6			; 
1fa6			 
1fa6			; hl to point to the line to tokenise 
1fa6			 
1fa6			;	push hl 
1fa6 22 c2 e5			ld (os_tok_ptr), hl  ; save ptr to string 
1fa9			 
1fa9			;	ld a,0		; string term on input 
1fa9			;	call strlent 
1fa9			 
1fa9			;	ld (os_tok_len), hl	 ; save string length 
1fa9			 
1fa9			;if DEBUG_FORTH_TOK 
1fa9			;	ex de,hl		 
1fa9			;endif 
1fa9			 
1fa9			;	pop hl 		; get back string pointer 
1fa9			 
1fa9			if DEBUG_FORTH_TOK 
1fa9						DMARK "TOK" 
1fa9				CALLMONITOR 
1fa9			endif 
1fa9 7e			.ptoken2:    ld a,(hl) 
1faa 23				inc hl 
1fab fe 7f			cp FORTH_END_BUFFER 
1fad 28 29			jr z, .ptokendone2 
1faf fe 00			cp 0 
1fb1 28 25			jr z, .ptokendone2 
1fb3 fe 22			cp '"' 
1fb5 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
1fb7 fe 20			cp ' ' 
1fb9 20 ee			jr nz,  .ptoken2 
1fbb			 
1fbb			; TODO consume comments held between ( and ) 
1fbb			 
1fbb				; we have a space so change to zero term for dict match later 
1fbb 2b				dec hl 
1fbc 3e 00			ld a,0 
1fbe 77				ld (hl), a 
1fbf 23				inc hl 
1fc0 18 e7			jr .ptoken2 
1fc2				 
1fc2			 
1fc2			.ptokenstr2: 
1fc2				; skip all white space until either eol (because forgot to term) or end double quote 
1fc2			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1fc2				;inc hl ; skip current double quote 
1fc2 7e				ld a,(hl) 
1fc3 23				inc hl 
1fc4 fe 22			cp '"' 
1fc6 28 e1			jr z, .ptoken2 
1fc8 fe 7f			cp FORTH_END_BUFFER 
1fca 28 0c			jr z, .ptokendone2 
1fcc fe 00			cp 0 
1fce 28 08			jr z, .ptokendone2 
1fd0 fe 20			cp ' ' 
1fd2 28 02			jr z, .ptmp2 
1fd4 18 ec			jr .ptokenstr2 
1fd6			 
1fd6			.ptmp2:	; we have a space so change to zero term for dict match later 
1fd6				;dec hl 
1fd6				;ld a,"-"	; TODO remove this when working 
1fd6				;ld (hl), a 
1fd6				;inc hl 
1fd6 18 ea			jr .ptokenstr2 
1fd8			 
1fd8			.ptokendone2: 
1fd8				;inc hl 
1fd8 3e 7f			ld a, FORTH_END_BUFFER 
1fda 77				ld (hl),a 
1fdb 23				inc hl 
1fdc 3e 21			ld a, '!' 
1fde 77				ld (hl),a 
1fdf			 
1fdf 2a c2 e5			ld hl,(os_tok_ptr) 
1fe2			         
1fe2			if DEBUG_FORTH_TOK 
1fe2						DMARK "TK1" 
1fe2				CALLMONITOR 
1fe2			endif 
1fe2			 
1fe2				; push exec string to top of return stack 
1fe2				FORTH_RSP_NEXT 
1fe2 cd 52 1b			call macro_forth_rsp_next 
1fe5				endm 
# End of macro FORTH_RSP_NEXT
1fe5 c9				ret 
1fe6			 
1fe6			; 
1fe6			;	; malloc size + buffer pointer + if is loop flag 
1fe6			;	ld hl,(os_tok_len) 		 ; get string length 
1fe6			; 
1fe6			;	ld a,l 
1fe6			; 
1fe6			;	cp 0			; we dont want to use a null string 
1fe6			;	ret z 
1fe6			; 
1fe6			;;	add 3    ; prefix malloc with buffer for current word ptr 
1fe6			; 
1fe6			;	add 5     ; TODO when certain not over writing memory remove 
1fe6			; 
1fe6			;		 
1fe6			; 
1fe6			;if DEBUG_FORTH_TOK 
1fe6			;			DMARK "TKE" 
1fe6			;	CALLMONITOR 
1fe6			;endif 
1fe6			; 
1fe6			;	ld l,a 
1fe6			;	ld h,0 
1fe6			;;	push hl   ; save required space for the copy later 
1fe6			;	call malloc 
1fe6			;if DEBUG_FORTH_TOK 
1fe6			;			DMARK "TKM" 
1fe6			;	CALLMONITOR 
1fe6			;endif 
1fe6			;	if DEBUG_FORTH_MALLOC_GUARD 
1fe6			;		push af 
1fe6			;		call ishlzero 
1fe6			;;		ld a, l 
1fe6			;;		add h 
1fe6			;;		cp 0 
1fe6			;		pop af 
1fe6			;		 
1fe6			;		call z,malloc_error 
1fe6			;	endif 
1fe6			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
1fe6			; 
1fe6			; 
1fe6			;if DEBUG_FORTH_TOK 
1fe6			;			DMARK "TKR" 
1fe6			;	CALLMONITOR 
1fe6			;endif 
1fe6			; 
1fe6			;	FORTH_RSP_NEXT 
1fe6			; 
1fe6			;	;inc hl	 ; go past current buffer pointer 
1fe6			;	;inc hl 
1fe6			;	;inc hl   ; and past if loop flag 
1fe6			;		; TODO Need to set flag  
1fe6			; 
1fe6			;	 
1fe6			;	 
1fe6			;	ex de,hl	; malloc is dest 
1fe6			;	ld hl, (os_tok_len) 
1fe6			;;	pop bc 
1fe6			;	ld c, l                
1fe6			;	ld b,0 
1fe6			;	ld hl, (os_tok_ptr) 
1fe6			; 
1fe6			;if DEBUG_FORTH_TOK 
1fe6			;			DMARK "TKT" 
1fe6			;	CALLMONITOR 
1fe6			;endif 
1fe6			; 
1fe6			;	; do str cpy 
1fe6			; 
1fe6			;	ldir      ; copy byte in hl to de 
1fe6			; 
1fe6			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
1fe6			; 
1fe6			;if DEBUG_FORTH_TOK 
1fe6			; 
1fe6			;			DMARK "TKY" 
1fe6			;	CALLMONITOR 
1fe6			;endif 
1fe6			;	;ld a,0 
1fe6			;	;ld a,FORTH_END_BUFFER 
1fe6			;	ex de, hl 
1fe6			;	;dec hl			 ; go back over the space delim at the end of word 
1fe6			;	;ld (hl),a 
1fe6			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
1fe6			;	ld a,FORTH_END_BUFFER 
1fe6			;	ld (hl),a 
1fe6			;	inc hl 
1fe6			;	ld a,FORTH_END_BUFFER 
1fe6			;	ld (hl),a 
1fe6			; 
1fe6			;	; init the malloc area data 
1fe6			;	; set pc for in current area 
1fe6			;	;ld hl, (os_tok_malloc) 
1fe6			;	;inc hl 
1fe6			;	;inc hl 
1fe6			;	;inc hl 
1fe6			;	;ex de,hl 
1fe6			;	;ld hl, (os_tok_malloc) 
1fe6			;	;ld (hl),e 
1fe6			;	;inc hl 
1fe6			;	;ld (hl),d 
1fe6			; 
1fe6			; 
1fe6			;	ld hl,(os_tok_malloc) 
1fe6			;if DEBUG_FORTH_PARSE_KEY 
1fe6			;			DMARK "TKU" 
1fe6			;	CALLMONITOR 
1fe6			;endif 
1fe6			; 
1fe6			;	ret 
1fe6			 
1fe6			forthexec: 
1fe6			 
1fe6			; line exec: 
1fe6			; forth parser 
1fe6			 
1fe6			; 
1fe6			;       get current exec line on rsp 
1fe6			 
1fe6				FORTH_RSP_TOS 
1fe6 cd 69 1b			call macro_forth_rsp_tos 
1fe9				endm 
# End of macro FORTH_RSP_TOS
1fe9			 
1fe9			;       restore current pc - hl points to malloc of data 
1fe9			 
1fe9				;ld e, (hl) 
1fe9				;inc hl 
1fe9				;ld d, (hl) 
1fe9				;ex de,hl 
1fe9			 
1fe9			 
1fe9			exec1: 
1fe9 22 c2 e5			ld (os_tok_ptr), hl 
1fec			 
1fec				; copy our PC to working vars  
1fec 22 40 ea			ld (cli_ptr), hl 
1fef 22 3e ea			ld (cli_origptr), hl 
1ff2			 
1ff2 7e				ld a,(hl) 
1ff3 fe 7f			cp FORTH_END_BUFFER 
1ff5 c8				ret z 
1ff6			 
1ff6				; skip any nulls 
1ff6			 
1ff6 fe 00			cp 0 
1ff8 20 03			jr nz, .execword 
1ffa 23				inc hl 
1ffb 18 ec			jr exec1 
1ffd			 
1ffd			 
1ffd			.execword: 
1ffd			 
1ffd			 
1ffd			 
1ffd			if DEBUG_FORTH_PARSE_KEY 
1ffd						DMARK "KYQ" 
1ffd				CALLMONITOR 
1ffd			endif 
1ffd			;       while at start of word: 
1ffd			; get start of dict (in user area first) 
1ffd			 
1ffd 21 a0 65		ld hl, baseram 
2000			;ld hl, sysdict 
2000 22 42 ea		ld (cli_nextword),hl 
2003			;           match word at pc 
2003			;           exec word 
2003			;           or push to dsp 
2003			;           forward to next token 
2003			;           if line term pop rsp and exit 
2003			;        
2003			 
2003			if DEBUG_FORTH_PARSE_KEY 
2003						DMARK "KYq" 
2003				CALLMONITOR 
2003			endif 
2003			 
2003			; 
2003			; word comp 
2003			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
2003			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
2003			;    move to start of word  
2003			;    compare word to cli_token 
2003			 
2003			.execpnword:	; HL at start of a word in the dictionary to check 
2003			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
2003			;	ld (cli_ptr), hl 
2003			 
2003 2a 42 ea			ld hl,(cli_nextword) 
2006			 
2006 cd a9 20			call forth_tok_next 
2009			; tok next start here 
2009			;	; TODO skip compiled symbol for now 
2009			;	inc hl 
2009			; 
2009			;	; save pointer to next word 
2009			; 
2009			;	; hl now points to the address of the next word pointer  
2009			;	ld e, (hl) 
2009			;	inc hl 
2009			;	ld d, (hl) 
2009			;	inc l 
2009			; 
2009			;	ex de,hl 
2009			;if DEBUG_FORTH_PARSE_NEXTWORD 
2009			;	push bc 
2009			;	ld bc, (cli_nextword) 
2009			;			DMARK "NXW" 
2009			;	CALLMONITOR 
2009			;	pop bc 
2009			;endif 
2009			; tok next end here 
2009 22 42 ea			ld (cli_nextword), hl     ; save for next check if no match on this word 
200c eb				ex de, hl 
200d			 
200d			 
200d				; save the pointer of the current token - 1 to check against 
200d				 
200d 22 46 ea			ld (cli_token), hl   
2010				; TODO maybe remove below save if no debug 
2010				; save token string ptr for any debug later 
2010 23				inc hl  
2011 22 48 ea			ld (cli_origtoken), hl 
2014 2b				dec hl 
2015				; save pointer to the start of the next dictionay word 
2015 7e				ld a,(hl)   ; get string length 
2016 47				ld b,a 
2017			.execpnwordinc:  
2017 23				inc hl 
2018 10 fd			djnz .execpnwordinc 
201a 22 44 ea			ld (cli_execword), hl      ; save start of this words code 
201d			 
201d				; now check the word token against the string being parsed 
201d			 
201d 2a 46 ea			ld hl,(cli_token) 
2020 23				inc hl     ; skip string length (use zero term instead to end) 
2021 22 46 ea			ld (cli_token), hl 
2024			 
2024			if DEBUG_FORTH_PARSE_KEY 
2024						DMARK "KY2" 
2024			endif 
2024			if DEBUG_FORTH_PARSE_EXEC 
2024				; see if disabled 
2024			 
2024			;	ld a, (os_view_disable) 
2024			;	cp '*' 
2024				ld a, (debug_vector) 
2024				cp $c9   ; RET  
2024				jr z, .skip 
2024			 
2024				push hl 
2024				push hl 
2024				call clear_display 
2024				ld de, .compword 
2024				ld a, display_row_1 
2024				call str_at_display 
2024				pop de 
2024				ld a, display_row_2 
2024				call str_at_display 
2024				ld hl,(cli_ptr) 
2024				ld a,(hl) 
2024			        ld hl, os_word_scratch 
2024				ld (hl),a 
2024				ld a,0 
2024				inc hl 
2024				ld (hl),a 	 
2024				ld de, os_word_scratch 
2024				ld a, display_row_2+10 
2024				call str_at_display 
2024				call update_display 
2024				ld a, 100 
2024				call aDelayInMS 
2024				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2024				call delay250ms 
2024				endif 
2024				pop hl 
2024			.skip:  
2024			endif	 
2024			.execpnchar:    ; compare char between token and string to parse 
2024			 
2024			if DEBUG_FORTH_PARSE_KEY 
2024						DMARK "Ky3" 
2024			endif 
2024			if DEBUG_FORTH_PARSE_EXEC 
2024				; see if disabled 
2024			 
2024			;	ld a, (os_view_disable) 
2024			;	cp '*' 
2024				ld a, (debug_vector) 
2024				cp $C9  ; RET 
2024				jr z, .skip2 
2024			 
2024			;	call clear_display 
2024			ld hl,(cli_token) 
2024			ld a,(hl) 
2024			ld (os_word_scratch),a 
2024				ld hl,(cli_ptr) 
2024			ld a,(hl) 
2024				ld (os_word_scratch+1),a 
2024				ld a,0 
2024				ld (os_word_scratch+2),a 
2024				ld de,os_word_scratch 
2024				ld a,display_row_4 
2024				call str_at_display 
2024				call update_display 
2024			.skip2:  
2024			endif 
2024 2a 46 ea			ld hl,(cli_token) 
2027 7e				ld a, (hl)	 ; char in word token 
2028 23				inc hl 		; move to next char 
2029 22 46 ea			ld (cli_token), hl ; and save it 
202c 47				ld b,a 
202d			 
202d 2a 40 ea			ld hl,(cli_ptr) ;	get the char from the string to parse 
2030 7e				ld a,(hl) 
2031 23				inc hl 
2032 22 40 ea			ld (cli_ptr), hl		; move to next char 
2035 cd 94 11			call toUpper 		; make sure the input string matches case 
2038			 
2038			if DEBUG_FORTH_PARSE 
2038			endif 
2038			 
2038				; input stream end of token is a space so get rid of it 
2038			 
2038			;	cp ' ' 
2038			;	jr nz, .pnskipspace 
2038			; 
2038			;	ld a, 0		; make same term as word token term 
2038			; 
2038			;.pnskipspace: 
2038			 
2038			if DEBUG_FORTH_PARSE_KEY 
2038						DMARK "KY7" 
2038			endif 
2038 b8				cp b 
2039 c2 4f 20			jp nz, .execpnskipword	 ; no match so move to next word 
203c				 
203c			;    if same 
203c			;       scan for string terms 0 for token and 32 for input 
203c			 
203c				 
203c			if DEBUG_FORTH_PARSE_KEY 
203c						DMARK "KY8" 
203c			endif 
203c			 
203c 80				add b			 
203d fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
203f							; TODO need to make sure last word in zero term string is accounted for 
203f 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
2041			 
2041			 
2041				; at end of both strings so both are exact match 
2041			 
2041			;       skip ptr for next word 
2041			 
2041 2a 40 ea			ld hl,(cli_ptr) 	; at input string term 
2044 23				inc hl			 ; at next char 
2045 22 40 ea			ld (cli_ptr), hl     ; save for next round of the parser 
2048 22 3e ea			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
204b				 
204b				 
204b			if DEBUG_FORTH_PARSE_KEY 
204b						DMARK "KY3" 
204b			endif 
204b			 
204b			 
204b			 
204b			;       exec code block 
204b			if DEBUG_FORTH_JP 
204b				call clear_display 
204b				call update_display 
204b				call delay1s 
204b				ld hl, (cli_execword)     ; save for next check if no match on this word 
204b				ld a,h 
204b				ld hl, os_word_scratch 
204b				call hexout 
204b				ld hl, (cli_execword)     ; save for next check if no match on this word 
204b				ld a,l 
204b				ld hl, os_word_scratch+2 
204b				call hexout 
204b				ld hl, os_word_scratch+4 
204b				ld a,0 
204b				ld (hl),a 
204b				ld de,os_word_scratch 
204b				call str_at_display 
204b					ld a, display_row_2 
204b					call str_at_display 
204b				ld de, (cli_origtoken) 
204b				ld a, display_row_1+10 
204b					call str_at_display 
204b			 
204b				ld a,display_row_1 
204b				ld de, .foundword 
204b				ld a, display_row_3 
204b				call str_at_display 
204b				call update_display 
204b				call delay1s 
204b				call delay1s 
204b				call delay1s 
204b			endif 
204b			 
204b			if DEBUG_FORTH_PARSE_KEY 
204b						DMARK "KYj" 
204b			endif 
204b				; TODO save the word pointer in this exec 
204b			 
204b 2a 44 ea			ld hl,(cli_execword) 
204e e9				jp (hl) 
204f			 
204f			 
204f			;    if not same 
204f			;	scan for zero term 
204f			;	get ptr for next word 
204f			;	goto word comp 
204f			 
204f			.execpnskipword:	; get pointer to next word 
204f 2a 42 ea			ld hl,(cli_nextword) 
2052			 
2052 7e				ld a,(hl) 
2053 fe 00			cp WORD_SYS_END 
2055			;	cp 0 
2055 28 09			jr z, .execendofdict			 ; at end of words 
2057			 
2057			if DEBUG_FORTH_PARSE_KEY 
2057						DMARK "KY4" 
2057			endif 
2057			if DEBUG_FORTH_PARSE_EXEC 
2057			 
2057				; see if disabled 
2057			 
2057			;	ld a, (os_view_disable) 
2057			;	cp '*' 
2057				ld a,(debug_vector) 
2057				cp $c9   ; RET 
2057				jr z, .noskip 
2057			 
2057			 
2057				ld de, .nowordfound 
2057				ld a, display_row_3 
2057				call str_at_display 
2057				call update_display 
2057				ld a, 100 
2057				call aDelayInMS 
2057				 
2057				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2057					call delay250ms 
2057				endif 
2057			.noskip:  
2057			 
2057			endif	 
2057			 
2057 2a 3e ea			ld hl,(cli_origptr) 
205a 22 40 ea			ld (cli_ptr),hl 
205d			 
205d			if DEBUG_FORTH_PARSE_KEY 
205d						DMARK "KY5" 
205d			endif 
205d c3 03 20			jp .execpnword			; else go to next word 
2060			 
2060			.execendofdict:  
2060			 
2060			if DEBUG_FORTH_PARSE_KEY 
2060						DMARK "KYe" 
2060			endif 
2060			if DEBUG_FORTH_PARSE_EXEC 
2060				; see if disabled 
2060			 
2060			;	ld a, (os_view_disable) 
2060			;	cp '*' 
2060				ld a,(debug_vector) 
2060				cp $c9   ; ret 
2060				jr z, .ispskip 
2060			 
2060				call clear_display 
2060				call update_display 
2060				call delay1s 
2060				ld de, (cli_origptr) 
2060				ld a, display_row_1 
2060				call str_at_display 
2060				 
2060				ld de, .enddict 
2060				ld a, display_row_3 
2060				call str_at_display 
2060				call update_display 
2060				ld a, 100 
2060				call aDelayInMS 
2060				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2060				call delay1s 
2060				call delay1s 
2060				call delay1s 
2060				endif 
2060			.ispskip:  
2060				 
2060			endif	 
2060			 
2060			 
2060			 
2060				; if the word is not a keyword then must be a literal so push it to stack 
2060			 
2060			; push token to stack to end of word 
2060			 
2060				STACKFRAME ON $1efe $2f9f 
2060				if DEBUG_STACK_IMB 
2060					if ON 
2060						exx 
2060						ld de, $1efe 
2060						ld a, d 
2060						ld hl, curframe 
2060						call hexout 
2060						ld a, e 
2060						ld hl, curframe+2 
2060						call hexout 
2060						ld hl, $1efe 
2060						push hl 
2060						ld hl, $2f9f 
2060						push hl 
2060						exx 
2060					endif 
2060				endif 
2060			endm 
# End of macro STACKFRAME
2060			 
2060 2a c2 e5		ld hl,(os_tok_ptr) 
2063 cd 14 1d		call forth_apush 
2066			 
2066				STACKFRAMECHK ON $1efe $2f9f 
2066				if DEBUG_STACK_IMB 
2066					if ON 
2066						exx 
2066						ld hl, $2f9f 
2066						pop de   ; $2f9f 
2066						call cmp16 
2066						jr nz, .spnosame 
2066						ld hl, $1efe 
2066						pop de   ; $1efe 
2066						call cmp16 
2066						jr z, .spfrsame 
2066						.spnosame: call showsperror 
2066						.spfrsame: nop 
2066						exx 
2066					endif 
2066				endif 
2066			endm 
# End of macro STACKFRAMECHK
2066			 
2066			execnext: 
2066			 
2066			if DEBUG_FORTH_PARSE_KEY 
2066						DMARK "KY>" 
2066			endif 
2066			; move past token to next word 
2066			 
2066 2a c2 e5		ld hl, (os_tok_ptr) 
2069 3e 00		ld a, 0 
206b 01 ff 00		ld bc, 255     ; input buffer size 
206e ed b1		cpir 
2070			 
2070			if DEBUG_FORTH_PARSE_KEY 
2070						DMARK "KY!" 
2070				CALLMONITOR 
2070			endif	 
2070			; TODO this might place hl on the null, so will need to forward on??? 
2070			;inc hl   ; see if this gets onto the next item 
2070			 
2070			 
2070			; TODO pass a pointer to the buffer to push 
2070			; TODO call function to push 
2070			 
2070			; look for end of input 
2070			 
2070			;inc hl 
2070			;ld a,(hl) 
2070			;cp FORTH_END_BUFFER 
2070			;ret z 
2070			 
2070			 
2070 c3 e9 1f		jp exec1 
2073			 
2073			 
2073			 
2073			 
2073			 
2073			 
2073			 
2073			 
2073			 
2073			findnexttok: 
2073			 
2073				; hl is pointer to move 
2073				; de is the token to locate 
2073			 
2073					if DEBUG_FORTH 
2073						DMARK "NTK" 
2073						CALLMONITOR 
2073					endif 
2073 d5				push de 
2074			 
2074			.fnt1:	 
2074				; find first char of token to locate 
2074			 
2074 1a				ld a, (de) 
2075 4f				ld c,a 
2076 7e				ld a,(hl) 
2077 cd 94 11			call toUpper 
207a					if DEBUG_FORTH 
207a						DMARK "NT1" 
207a						CALLMONITOR 
207a					endif 
207a b9				cp c 
207b			 
207b 28 03			jr z, .fnt2cmpmorefirst	 
207d			 
207d				; first char not found move to next char 
207d			 
207d 23				inc hl 
207e 18 f4			jr .fnt1 
2080			 
2080			.fnt2cmpmorefirst:	 
2080				; first char of token found.  
2080			 
2080 e5				push hl     ; save start of token just in case it is the right one 
2081 d9				exx 
2082 e1				pop hl        ; save it to hl' 
2083 d9				exx 
2084			 
2084			 
2084			.fnt2cmpmore:	 
2084				; compare the rest 
2084				 
2084 23				inc hl 
2085 13				inc de 
2086				 
2086 1a				ld a, (de) 
2087 4f				ld c,a 
2088 7e				ld a,(hl) 
2089 cd 94 11			call toUpper 
208c			 
208c					if DEBUG_FORTH 
208c						DMARK "NT2" 
208c						CALLMONITOR 
208c					endif 
208c				; c has the token to find char 
208c				; a has the mem to scan char 
208c			 
208c b9				cp c 
208d 28 04			jr z,.fntmatch1 
208f			 
208f				; they are not the same 
208f			 
208f					if DEBUG_FORTH 
208f						DMARK "NT3" 
208f						CALLMONITOR 
208f					endif 
208f d1				pop de	; reset de token to look for 
2090 d5				push de 
2091 18 e1			jr .fnt1 
2093				 
2093			.fntmatch1: 
2093			 
2093				; is the same char a null which means we might have a full hit? 
2093					if DEBUG_FORTH 
2093						DMARK "NT4" 
2093						CALLMONITOR 
2093					endif 
2093			 
2093 fe 00			cp 0 
2095 28 0b			jr z, .fntmatchyes 
2097			 
2097				; are we at the end of the token to find? 
2097			 
2097					if DEBUG_FORTH 
2097						DMARK "NT5" 
2097						CALLMONITOR 
2097					endif 
2097 3e 00			ld a, 0 
2099 b9				cp c 
209a			 
209a c2 84 20			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
209d			 
209d					if DEBUG_FORTH 
209d						DMARK "NT6" 
209d						CALLMONITOR 
209d					endif 
209d				; token to find is exhusted but no match to stream 
209d			 
209d				; restore tok pointer and continue on 
209d d1				pop de 
209e d5				push de 
209f c3 74 20			jp .fnt1 
20a2			 
20a2			 
20a2			.fntmatchyes: 
20a2			 
20a2				; hl now contains the end of the found token 
20a2			 
20a2				; get rid of saved token pointer to find 
20a2			 
20a2 d1				pop de 
20a3			 
20a3					if DEBUG_FORTH 
20a3						DMARK "NT9" 
20a3						CALLMONITOR 
20a3					endif 
20a3			 
20a3				; hl will be on the null term so forward on 
20a3			 
20a3				; get back the saved start of the token 
20a3			 
20a3 d9				exx 
20a4 e5				push hl     ; save start of token just in case it is the right one 
20a5 d9				exx 
20a6 e1				pop hl        ; save it to hl 
20a7			 
20a7 c9				ret 
20a8			 
20a8			 
20a8			; LIST needs to find a specific token   
20a8			; FORGET needs to find a spefici token 
20a8			 
20a8			; SAVE needs to find all tokens by flag 
20a8			; WORDS just needs to scan through all  by flag 
20a8			; UWORDS needs to scan through all by flag 
20a8			 
20a8			 
20a8			; given hl as pointer to start of dict look up string 
20a8			; return hl as pointer to start of word block 
20a8			; or 0 if not found 
20a8			 
20a8			forth_find_tok: 
20a8 c9				ret 
20a9			 
20a9			; given hl as pointer to dict structure 
20a9			; move to the next dict block structure 
20a9			 
20a9			forth_tok_next: 
20a9				; hl now points to the address of the next word pointer  
20a9				; TODO skip compiled symbol for now 
20a9			;	push de 
20a9 23				inc hl 
20aa 5e				ld e, (hl) 
20ab 23				inc hl 
20ac 56				ld d, (hl) 
20ad 23				inc hl 
20ae			 
20ae eb				ex de,hl 
20af			if DEBUG_FORTH_PARSE_NEXTWORD 
20af				push bc 
20af				ld bc, (cli_nextword) 
20af						DMARK "NXW" 
20af				CALLMONITOR 
20af				pop bc 
20af			endif 
20af			;	pop de	 
20af c9				ret 
20b0			 
20b0			 
20b0			 
20b0			; eof 
# End of file forth_parserv5.asm
20b0				include "forth_wordsv4.asm" 
20b0			 
20b0			; the core word dictionary v4 
20b0			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
20b0			 
20b0			; this is a linked list for each of the system words used 
20b0			; user defined words will follow the same format but will be in ram 
20b0			 
20b0			 
20b0			; 
20b0			; 
20b0			; define linked list: 
20b0			; 
20b0			; 1. compiled byte op code 
20b0			; 2. len of text word 
20b0			; 3. text word 
20b0			; 4. ptr to next dictionary word 
20b0			; 5. asm, calls etc for the word 
20b0			; 
20b0			;  if 1 == 0 then last word in dict  
20b0			;   
20b0			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
20b0			;  
20b0			;  
20b0			; create basic standard set of words 
20b0			; 
20b0			;  
20b0			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
20b0			; 2DUP 2DROP 2SWAP  
20b0			; @ C@ - get byte  
20b0			; ! C! - store byte 
20b0			; 0< true if less than zero 
20b0			; 0= true if zero 
20b0			; < >  
20b0			; = true if same 
20b0			; variables 
20b0			 
20b0			 
20b0			; Hardware specific words I may need 
20b0			; 
20b0			; IN OUT  
20b0			; calls to key util functions 
20b0			; calls to hardward abstraction stuff 
20b0			; easy control of frame buffers and lcd i/o 
20b0			; keyboard  
20b0			 
20b0			 
20b0			;DICT: macro 
20b0			; op_code, len, word, next 
20b0			;    word: 
20b0			;    db op_code 
20b0			;    ds word zero term 
20b0			;    dw next 
20b0			;    endm 
20b0			 
20b0			 
20b0			 
20b0			 
20b0			; op code 1 is a flag for user define words which are to be handled differently 
20b0			 
20b0			 
20b0			; 
20b0			; 
20b0			;    TODO on entry to a word this should be the expected environment 
20b0			;    hl - tos value if number then held, if string this is the ptr 
20b0			;    de -  
20b0			 
20b0			 
20b0			; opcode ranges 
20b0			; 0 - end of word dict 
20b0			; 255 - user define words 
20b0			 
20b0			sysdict: 
20b0			include "forth_opcodes.asm" 
20b0			; op codes for forth keywords 
20b0			; free to use code 0  
20b0				OPCODE_HEAP: equ  1 
20b0				OPCODE_EXEC: equ 2 
20b0				OPCODE_DUP: equ 3 
20b0				OPCODE_SWAP: equ 4 
20b0				OPCODE_COLN: equ 5 
20b0				OPCODE_SCOLN: equ 6 
20b0				OPCODE_DROP: equ 7 
20b0				OPCODE_DUP2: equ 8 
20b0				OPCODE_DROP2: equ 9 
20b0				OPCODE_SWAP2: equ 10 
20b0				OPCODE_AT: equ 11 
20b0				OPCODE_CAT: equ 12 
20b0				OPCODE_BANG: equ 13 
20b0				OPCODE_CBANG: equ 14 
20b0				OPCODE_SCALL: equ 15 
20b0				OPCODE_DEPTH: equ 16 
20b0				OPCODE_OVER: equ 17 
20b0				OPCODE_PAUSE: equ 18 
20b0				OPCODE_PAUSES: equ 19 
20b0				OPCODE_ROT: equ 20 
20b0			;free to reuse	OPCODE_WORDS: equ 21 
20b0			        OPCODE_NOT: equ 21 
20b0				OPCODE_UWORDS: equ 22 
20b0				OPCODE_BP: equ 23 
20b0				OPCODE_MONITOR: equ 24  
20b0				OPCODE_MALLOC: equ 25 
20b0				OPCODE_FREE: equ 26 
20b0				OPCODE_LIST: equ 27 
20b0				OPCODE_FORGET: equ 28 
20b0				OPCODE_NOP: equ 29 
20b0				OPCODE_COMO: equ 30 
20b0				OPCODE_COMC: equ 31 
20b0			;free to reuse	OPCODE_ENDCORE: equ 32 
20b0				OPCODE_AFTERSOUND: equ 33 
20b0				OPCODE_GP2: equ 34 
20b0				OPCODE_GP3: equ 35 
20b0				OPCODE_GP4: equ 36 
20b0				OPCODE_SIN: equ 37 
20b0				OPCODE_SOUT: equ 38 
20b0				OPCODE_SPIO: equ 39 
20b0				OPCODE_SPICEH: equ 40 
20b0				OPCODE_SPIOb: equ 41 
20b0				OPCODE_SPII: equ 42 
20b0				OPCODE_SESEL: equ 43 
20b0				OPCODE_CARTDEV: equ 44 
20b0			; free to reuse	OPCODE_ENDDEVICE: equ 45 
20b0				OPCODE_FB: equ 46 
20b0				OPCODE_EMIT: equ 47 
20b0				OPCODE_DOTH: equ 48 
20b0				OPCODE_DOTF: equ 49 
20b0				OPCODE_DOT: equ 50 
20b0				OPCODE_CLS: equ 51 
20b0				OPCODE_DRAW: equ 52 
20b0				OPCODE_DUMP: equ 53 
20b0				OPCODE_CDUMP: equ 54 
20b0				OPCODE_DAT: equ 55 
20b0				OPCODE_HOME: equ 56 
20b0				OPCODE_SPACE: equ 57 
20b0				OPCODE_SPACES: equ 58 
20b0				OPCODE_SCROLL: equ 59 
20b0				OPCODE_ATQ: equ 60 
20b0				OPCODE_AUTODSP: equ 61 
20b0				OPCODE_MENU: equ 62 
20b0			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
20b0				OPCODE_THEN: equ 64 
20b0				OPCODE_ELSE: equ 65 
20b0				OPCODE_DO: equ 66 
20b0				OPCODE_LOOP: equ 67 
20b0				OPCODE_I: equ 68 
20b0				OPCODE_DLOOP: equ 69  
20b0				OPCODE_REPEAT: equ 70  
20b0				OPCODE_UNTIL: equ 71 
20b0				OPCODE_ENDFLOW: equ 72 
20b0				OPCODE_WAITK: equ 73 
20b0				OPCODE_ACCEPT: equ 74 
20b0				OPCODE_EDIT: equ 75 
20b0			;free to reuse	OPCODE_ENDKEY: equ 76 
20b0				OPCODE_LZERO: equ 77 
20b0				OPCODE_TZERO: equ 78 
20b0				OPCODE_LESS: equ 79 
20b0				OPCODE_GT: equ 80 
20b0				OPCODE_EQUAL: equ 81  
20b0			;free to reuse	OPCODE_ENDLOGIC: equ 82 
20b0				OPCODE_NEG: equ 83 
20b0				OPCODE_DIV: equ 84 
20b0				OPCODE_MUL: equ 85 
20b0				OPCODE_MIN: equ 86 
20b0				OPCODE_MAX: equ 87 
20b0				OPCODE_RND16: equ 88 
20b0				OPCODE_RND8: equ 89 
20b0				OPCODE_RND: equ 90 
20b0			;free to reuse	OPCODE_ENDMATHS: equ 91  
20b0				OPCODE_BYNAME: equ 92 
20b0				OPCODE_DIR: equ 93 
20b0				OPCODE_SAVE: equ 94 
20b0				OPCODE_LOAD: equ 95 
20b0				OPCODE_BSAVE: equ 96 
20b0				OPCODE_BLOAD: equ 97 
20b0				OPCODE_SEO: equ 98  
20b0				OPCODE_SEI: equ 99 
20b0				OPCODE_SFREE: equ 100 
20b0				OPCODE_SIZE: equ 101 
20b0				OPCODE_CREATE: equ 102 
20b0				OPCODE_APPEND: equ 103 
20b0				OPCODE_SDEL: equ 104 
20b0				OPCODE_OPEN: equ 105 
20b0				OPCODE_READ: equ 106 
20b0				OPCODE_EOF: equ 106 
20b0				OPCODE_FORMAT: equ 107 
20b0				OPCODE_LABEL: equ 108 
20b0				OPCODE_LABELS: equ 109 
20b0			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
20b0				OPCODE_UPPER: equ 111 
20b0				OPCODE_LOWER: equ 112 
20b0				OPCODE_SUBSTR: equ 113 
20b0				OPCODE_LEFT: equ 114 
20b0				OPCODE_RIGHT: equ 115 
20b0				OPCODE_STR2NUM: equ 116 
20b0				OPCODE_NUM2STR: equ 117 
20b0				OPCODE_CONCAT: equ 118 
20b0				OPCODE_FIND: equ 119 
20b0				OPCODE_LEN: equ 120 
20b0				OPCODE_CHAR: equ 121 
20b0			; free to reuse	OPCODE_STRLEN: equ 122 
20b0			; free to reuse	OPCODE_ENDSTR: equ 123 
20b0				OPCODE_V0S: equ 124 
20b0				OPCODE_V0Q: equ 125 
20b0				OPCODE_V1S: equ 126 
20b0				OPCODE_V1Q: equ 127 
20b0				OPCODE_V2S: equ 128 
20b0				OPCODE_V2Q: equ 129 
20b0				OPCODE_V3S: equ 130 
20b0				OPCODE_V3Q: equ 131 
20b0			;free to reuse	OPCODE_END: equ 132 
20b0				OPCODE_ZDUP: equ 133 
20b0			 
20b0			; eof 
# End of file forth_opcodes.asm
20b0			 
20b0			include "forth_words_core.asm" 
20b0			 
20b0			; | ## Core Words 
20b0			 
20b0			;if MALLOC_4 
20b0			 
20b0			.HEAP: 
20b0			CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
20b0 15				db WORD_SYS_CORE+OPCODE_HEAP             
20b1 ef 20			dw .EXEC            
20b3 05				db 4 + 1 
20b4 .. 00			db "HEAP",0              
20b9				endm 
# End of macro CWHEAD
20b9			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
20b9			; | | u1 - Current number of bytes in the heap 
20b9			; | | u2 - Remaining bytes left on the heap 
20b9			; | |  
20b9			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
20b9			 
20b9			 
20b9				if DEBUG_FORTH_WORDS_KEY 
20b9					DMARK "HEP" 
20b9 f5				push af  
20ba 3a ce 20			ld a, (.dmark)  
20bd 32 6b ee			ld (debug_mark),a  
20c0 3a cf 20			ld a, (.dmark+1)  
20c3 32 6c ee			ld (debug_mark+1),a  
20c6 3a d0 20			ld a, (.dmark+2)  
20c9 32 6d ee			ld (debug_mark+2),a  
20cc 18 03			jr .pastdmark  
20ce ..			.dmark: db "HEP"  
20d1 f1			.pastdmark: pop af  
20d2			endm  
# End of macro DMARK
20d2					CALLMONITOR 
20d2 cd 6f ee			call debug_vector  
20d5				endm  
# End of macro CALLMONITOR
20d5				endif 
20d5 2a aa 65			ld hl, (free_list )      
20d8 11 af 65			ld de, heap_start 
20db			 
20db ed 52			sbc hl, de  
20dd			 
20dd cd ab 1b			call forth_push_numhl 
20e0			 
20e0			 
20e0 ed 5b aa 65		ld de, (free_list )      
20e4 21 9c e2			ld hl, heap_end 
20e7			 
20e7 ed 52			sbc hl, de 
20e9			 
20e9 cd ab 1b			call forth_push_numhl 
20ec				 
20ec			 
20ec				 
20ec			 
20ec			 
20ec			 
20ec				NEXTW 
20ec c3 58 1f			jp macro_next 
20ef				endm 
# End of macro NEXTW
20ef			;endif 
20ef			 
20ef			.EXEC: 
20ef			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
20ef			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
20ef			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
20ef			;; > > 
20ef			;; > >   
20ef			;	STACKFRAME OFF $5efe $5f9f 
20ef			; 
20ef			;		if DEBUG_FORTH_WORDS_KEY 
20ef			;			DMARK "EXE" 
20ef			;			CALLMONITOR 
20ef			;		endif 
20ef			; 
20ef			;	FORTH_DSP_VALUEHL 
20ef			; 
20ef			;	FORTH_DSP_POP 
20ef			; 
20ef			;		if DEBUG_FORTH_WORDS 
20ef			;			DMARK "EX1" 
20ef			;			CALLMONITOR 
20ef			;		endif 
20ef			;;	ld e,(hl) 
20ef			;;	inc hl 
20ef			;;	ld d,(hl) 
20ef			;;	ex de,hl 
20ef			; 
20ef			;;		if DEBUG_FORTH_WORDS 
20ef			;;			DMARK "EX2" 
20ef			;;			CALLMONITOR 
20ef			;;		endif 
20ef			;	push hl 
20ef			; 
20ef			;	;ld a, 0 
20ef			;	;ld a, FORTH_END_BUFFER 
20ef			;	call strlenz 
20ef			;	inc hl   ; include zero term to copy 
20ef			;	inc hl   ; include term 
20ef			;	inc hl   ; include term 
20ef			;	ld b,0 
20ef			;	ld c,l 
20ef			;	pop hl 
20ef			;	ld de, execscratch 
20ef			;		if DEBUG_FORTH_WORDS 
20ef			;			DMARK "EX3" 
20ef			;			CALLMONITOR 
20ef			;		endif 
20ef			;	ldir 
20ef			; 
20ef			; 
20ef			;	ld hl, execscratch 
20ef			; 
20ef			;		if DEBUG_FORTH_WORDS 
20ef			;			DMARK "EXe" 
20ef			;			CALLMONITOR 
20ef			;		endif 
20ef			; 
20ef			;	call forthparse 
20ef			;	call forthexec 
20ef			;;	call forthexec_cleanup 
20ef			;;	call forthparse 
20ef			;;	call forthexec 
20ef			; 
20ef			;	STACKFRAMECHK OFF $5efe $5f9f 
20ef			; 
20ef			;	; an immediate word so no need to process any more words 
20ef			;	ret 
20ef			;	NEXTW 
20ef			 
20ef			; dead code - old version  
20ef			;	FORTH_RSP_NEXT 
20ef			 
20ef			;  
20ef			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
20ef			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
20ef			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
20ef			;	push hl 
20ef			;	push de 
20ef			;	push bc 
20ef			; 
20ef			; 
20ef			;		if DEBUG_FORTH_WORDS_KEY 
20ef			;			DMARK "EXR" 
20ef			;			CALLMONITOR 
20ef			;		endif 
20ef			; 
20ef			; 
20ef			; 
20ef			;	;v5 FORTH_DSP_VALUE 
20ef			;	FORTH_DSP_VALUEHL 
20ef			; 
20ef			;	; TODO do string type checks 
20ef			; 
20ef			;;v5	inc hl   ; skip type 
20ef			; 
20ef			;	push hl  ; source code  
20ef			;		if DEBUG_FORTH_WORDS 
20ef			;			DMARK "EX1" 
20ef			;			CALLMONITOR 
20ef			;		endif 
20ef			;	ld a, 0 
20ef			;	call strlent 
20ef			; 
20ef			;	inc hl 
20ef			;	inc hl 
20ef			;	inc hl 
20ef			;	inc hl 
20ef			; 
20ef			;	push hl    ; size 
20ef			; 
20ef			;		if DEBUG_FORTH_WORDS 
20ef			;			DMARK "EX2" 
20ef			;			CALLMONITOR 
20ef			;		endif 
20ef			;	call malloc 
20ef			; 
20ef			;	ex de, hl    ; de now contains malloc area 
20ef			;	pop bc   	; get byte count 
20ef			;	pop hl      ; get string to copy 
20ef			; 
20ef			;	push de     ; save malloc for free later 
20ef			; 
20ef			;		if DEBUG_FORTH_WORDS 
20ef			;			DMARK "EX3" 
20ef			;			CALLMONITOR 
20ef			;		endif 
20ef			;	ldir       ; duplicate string 
20ef			; 
20ef			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
20ef			;	 
20ef			;	; TODO fix the parse would be better than this...  
20ef			;	ex de, hl 
20ef			;	dec hl 
20ef			;	ld a, 0 
20ef			;	ld (hl), a 
20ef			;	dec hl 
20ef			;	ld a, ' ' 
20ef			;	ld (hl), a 
20ef			;	dec hl 
20ef			;	ld (hl), a 
20ef			; 
20ef			;	dec hl 
20ef			;	ld (hl), a 
20ef			; 
20ef			; 
20ef			;	FORTH_DSP_POP  
20ef			; 
20ef			;	pop hl     
20ef			;	push hl    ; save malloc area 
20ef			; 
20ef			;		if DEBUG_FORTH_WORDS 
20ef			;			DMARK "EX4" 
20ef			;			CALLMONITOR 
20ef			;		endif 
20ef			; 
20ef			;	call forthparse 
20ef			;	call forthexec 
20ef			;	 
20ef			;	pop hl 
20ef			;	if DEBUG_FORTH_WORDS 
20ef			;		DMARK "EX5" 
20ef			;		CALLMONITOR 
20ef			;	endif 
20ef			; 
20ef			;	if FORTH_ENABLE_FREE 
20ef			;	call free 
20ef			;	endif 
20ef			; 
20ef			;	if DEBUG_FORTH_WORDS 
20ef			;		DMARK "EX6" 
20ef			;		CALLMONITOR 
20ef			;	endif 
20ef			; 
20ef			;	pop bc 
20ef			;	pop de 
20ef			;	pop hl 
20ef			;;	FORTH_RSP_POP	  
20ef			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
20ef			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
20ef			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
20ef			; 
20ef			;	if DEBUG_FORTH_WORDS 
20ef			;		DMARK "EX7" 
20ef			;		CALLMONITOR 
20ef			;	endif 
20ef			;	NEXTW 
20ef			 
20ef			;.STKEXEC: 
20ef			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
20ef			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
20ef			; 
20ef			; 
20ef			;		if DEBUG_FORTH_WORDS_KEY 
20ef			;			DMARK "STX" 
20ef			;			CALLMONITOR 
20ef			;		endif 
20ef			; 
20ef			;	FORTH_DSP_VALUEHL 
20ef			; 
20ef			;	ld (store_tmp1), hl    ; count 
20ef			; 
20ef			;	FORTH_DSP_POP 
20ef			;.stkexec1: 
20ef			;	ld hl, (store_tmp1)   ; count 
20ef			;	ld a, 0 
20ef			;	cp l 
20ef			;	ret z 
20ef			; 
20ef			;	dec hl 
20ef			;	ld (store_tmp1), hl    ; count 
20ef			;	 
20ef			;	FORTH_DSP_VALUEHL 
20ef			;	push hl 
20ef			;	 
20ef			;		if DEBUG_FORTH_WORDS 
20ef			;			DMARK "EXp" 
20ef			;			CALLMONITOR 
20ef			;		endif 
20ef			;	FORTH_DSP_POP 
20ef			; 
20ef			;	call strlenz 
20ef			;	inc hl   ; include zero term to copy 
20ef			;	inc hl   ; include zero term to copy 
20ef			;	inc hl   ; include zero term to copy 
20ef			;	ld b,0 
20ef			;	ld c,l 
20ef			;	pop hl 
20ef			;	ld de, execscratch 
20ef			;		if DEBUG_FORTH_WORDS 
20ef			;			DMARK "EX3" 
20ef			;			CALLMONITOR 
20ef			;		endif 
20ef			;	ldir 
20ef			; 
20ef			; 
20ef			;	ld hl, execscratch 
20ef			; 
20ef			;		if DEBUG_FORTH_WORDS 
20ef			;			DMARK "EXP" 
20ef			;			CALLMONITOR 
20ef			;		endif 
20ef			; 
20ef			;	call forthparse 
20ef			;	ld hl, execscratch 
20ef			;		if DEBUG_FORTH_WORDS 
20ef			;			DMARK "EXx" 
20ef			;			CALLMONITOR 
20ef			;		endif 
20ef			;	call forthexec 
20ef			; 
20ef			;	jp .stkexec1 
20ef			; 
20ef			;	ret 
20ef			 
20ef			 
20ef			.DUP: 
20ef			CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
20ef 17				db WORD_SYS_CORE+OPCODE_DUP             
20f0 65 21			dw .ZDUP            
20f2 04				db 3 + 1 
20f3 .. 00			db "DUP",0              
20f7				endm 
# End of macro CWHEAD
20f7			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
20f7			 
20f7				if DEBUG_FORTH_WORDS_KEY 
20f7					DMARK "DUP" 
20f7 f5				push af  
20f8 3a 0c 21			ld a, (.dmark)  
20fb 32 6b ee			ld (debug_mark),a  
20fe 3a 0d 21			ld a, (.dmark+1)  
2101 32 6c ee			ld (debug_mark+1),a  
2104 3a 0e 21			ld a, (.dmark+2)  
2107 32 6d ee			ld (debug_mark+2),a  
210a 18 03			jr .pastdmark  
210c ..			.dmark: db "DUP"  
210f f1			.pastdmark: pop af  
2110			endm  
# End of macro DMARK
2110					CALLMONITOR 
2110 cd 6f ee			call debug_vector  
2113				endm  
# End of macro CALLMONITOR
2113				endif 
2113			 
2113				FORTH_DSP 
2113 cd 68 1d			call macro_forth_dsp 
2116				endm 
# End of macro FORTH_DSP
2116			 
2116 7e				ld a, (HL) 
2117 fe 01			cp DS_TYPE_STR 
2119 20 25			jr nz, .dupinum 
211b			 
211b				; push another string 
211b			 
211b				FORTH_DSP_VALUEHL     		 
211b cd a2 1d			call macro_dsp_valuehl 
211e				endm 
# End of macro FORTH_DSP_VALUEHL
211e			 
211e			if DEBUG_FORTH_WORDS 
211e				DMARK "DUs" 
211e f5				push af  
211f 3a 33 21			ld a, (.dmark)  
2122 32 6b ee			ld (debug_mark),a  
2125 3a 34 21			ld a, (.dmark+1)  
2128 32 6c ee			ld (debug_mark+1),a  
212b 3a 35 21			ld a, (.dmark+2)  
212e 32 6d ee			ld (debug_mark+2),a  
2131 18 03			jr .pastdmark  
2133 ..			.dmark: db "DUs"  
2136 f1			.pastdmark: pop af  
2137			endm  
# End of macro DMARK
2137				CALLMONITOR 
2137 cd 6f ee			call debug_vector  
213a				endm  
# End of macro CALLMONITOR
213a			endif 
213a cd 19 1c			call forth_push_str 
213d			 
213d				NEXTW 
213d c3 58 1f			jp macro_next 
2140				endm 
# End of macro NEXTW
2140			 
2140			 
2140			.dupinum: 
2140				 
2140			 
2140			 
2140				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2140 cd a2 1d			call macro_dsp_valuehl 
2143				endm 
# End of macro FORTH_DSP_VALUEHL
2143			 
2143			; TODO add floating point number detection 
2143			 
2143			if DEBUG_FORTH_WORDS 
2143				DMARK "DUi" 
2143 f5				push af  
2144 3a 58 21			ld a, (.dmark)  
2147 32 6b ee			ld (debug_mark),a  
214a 3a 59 21			ld a, (.dmark+1)  
214d 32 6c ee			ld (debug_mark+1),a  
2150 3a 5a 21			ld a, (.dmark+2)  
2153 32 6d ee			ld (debug_mark+2),a  
2156 18 03			jr .pastdmark  
2158 ..			.dmark: db "DUi"  
215b f1			.pastdmark: pop af  
215c			endm  
# End of macro DMARK
215c				CALLMONITOR 
215c cd 6f ee			call debug_vector  
215f				endm  
# End of macro CALLMONITOR
215f			endif 
215f			 
215f cd ab 1b			call forth_push_numhl 
2162				NEXTW 
2162 c3 58 1f			jp macro_next 
2165				endm 
# End of macro NEXTW
2165			.ZDUP: 
2165			CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
2165 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2166 9d 21			dw .SWAP            
2168 05				db 4 + 1 
2169 .. 00			db "?DUP",0              
216e				endm 
# End of macro CWHEAD
216e			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
216e			 
216e				if DEBUG_FORTH_WORDS_KEY 
216e					DMARK "qDU" 
216e f5				push af  
216f 3a 83 21			ld a, (.dmark)  
2172 32 6b ee			ld (debug_mark),a  
2175 3a 84 21			ld a, (.dmark+1)  
2178 32 6c ee			ld (debug_mark+1),a  
217b 3a 85 21			ld a, (.dmark+2)  
217e 32 6d ee			ld (debug_mark+2),a  
2181 18 03			jr .pastdmark  
2183 ..			.dmark: db "qDU"  
2186 f1			.pastdmark: pop af  
2187			endm  
# End of macro DMARK
2187					CALLMONITOR 
2187 cd 6f ee			call debug_vector  
218a				endm  
# End of macro CALLMONITOR
218a				endif 
218a				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
218a cd a2 1d			call macro_dsp_valuehl 
218d				endm 
# End of macro FORTH_DSP_VALUEHL
218d			 
218d e5				push hl 
218e			 
218e				; is it a zero? 
218e			 
218e 3e 00			ld a, 0 
2190 84				add h 
2191 85				add l 
2192			 
2192 e1				pop hl 
2193			 
2193 fe 00			cp 0 
2195 28 03			jr z, .dup2orig 
2197			 
2197			 
2197 cd ab 1b			call forth_push_numhl 
219a			 
219a			 
219a			; TODO add floating point number detection 
219a			 
219a			.dup2orig: 
219a			 
219a				NEXTW 
219a c3 58 1f			jp macro_next 
219d				endm 
# End of macro NEXTW
219d			.SWAP: 
219d			CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
219d 18				db WORD_SYS_CORE+OPCODE_SWAP             
219e dc 21			dw .COLN            
21a0 05				db 4 + 1 
21a1 .. 00			db "SWAP",0              
21a6				endm 
# End of macro CWHEAD
21a6			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
21a6				if DEBUG_FORTH_WORDS_KEY 
21a6					DMARK "SWP" 
21a6 f5				push af  
21a7 3a bb 21			ld a, (.dmark)  
21aa 32 6b ee			ld (debug_mark),a  
21ad 3a bc 21			ld a, (.dmark+1)  
21b0 32 6c ee			ld (debug_mark+1),a  
21b3 3a bd 21			ld a, (.dmark+2)  
21b6 32 6d ee			ld (debug_mark+2),a  
21b9 18 03			jr .pastdmark  
21bb ..			.dmark: db "SWP"  
21be f1			.pastdmark: pop af  
21bf			endm  
# End of macro DMARK
21bf					CALLMONITOR 
21bf cd 6f ee			call debug_vector  
21c2				endm  
# End of macro CALLMONITOR
21c2				endif 
21c2			 
21c2			; TODO Use os stack swap memory 
21c2				FORTH_DSP_VALUEHL 
21c2 cd a2 1d			call macro_dsp_valuehl 
21c5				endm 
# End of macro FORTH_DSP_VALUEHL
21c5 e5				push hl     ; w2 
21c6			 
21c6				FORTH_DSP_POP 
21c6 cd 5a 1e			call macro_forth_dsp_pop 
21c9				endm 
# End of macro FORTH_DSP_POP
21c9			 
21c9				FORTH_DSP_VALUEHL 
21c9 cd a2 1d			call macro_dsp_valuehl 
21cc				endm 
# End of macro FORTH_DSP_VALUEHL
21cc			 
21cc				FORTH_DSP_POP 
21cc cd 5a 1e			call macro_forth_dsp_pop 
21cf				endm 
# End of macro FORTH_DSP_POP
21cf			 
21cf d1				pop de     ; w2	, hl = w1 
21d0			 
21d0 eb				ex de, hl 
21d1 d5				push de 
21d2			 
21d2 cd ab 1b			call forth_push_numhl 
21d5			 
21d5 e1				pop hl 
21d6			 
21d6 cd ab 1b			call forth_push_numhl 
21d9				 
21d9			 
21d9				NEXTW 
21d9 c3 58 1f			jp macro_next 
21dc				endm 
# End of macro NEXTW
21dc			.COLN: 
21dc			CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
21dc 19				db WORD_SYS_CORE+OPCODE_COLN             
21dd 68 23			dw .SCOLN            
21df 02				db 1 + 1 
21e0 .. 00			db ":",0              
21e2				endm 
# End of macro CWHEAD
21e2			; | : ( -- )         Create new word | DONE 
21e2			 
21e2				if DEBUG_FORTH_WORDS_KEY 
21e2					DMARK "CLN" 
21e2 f5				push af  
21e3 3a f7 21			ld a, (.dmark)  
21e6 32 6b ee			ld (debug_mark),a  
21e9 3a f8 21			ld a, (.dmark+1)  
21ec 32 6c ee			ld (debug_mark+1),a  
21ef 3a f9 21			ld a, (.dmark+2)  
21f2 32 6d ee			ld (debug_mark+2),a  
21f5 18 03			jr .pastdmark  
21f7 ..			.dmark: db "CLN"  
21fa f1			.pastdmark: pop af  
21fb			endm  
# End of macro DMARK
21fb					CALLMONITOR 
21fb cd 6f ee			call debug_vector  
21fe				endm  
# End of macro CALLMONITOR
21fe				endif 
21fe			STACKFRAME OFF $8efe $989f 
21fe				if DEBUG_STACK_IMB 
21fe					if OFF 
21fe						exx 
21fe						ld de, $8efe 
21fe						ld a, d 
21fe						ld hl, curframe 
21fe						call hexout 
21fe						ld a, e 
21fe						ld hl, curframe+2 
21fe						call hexout 
21fe						ld hl, $8efe 
21fe						push hl 
21fe						ld hl, $989f 
21fe						push hl 
21fe						exx 
21fe					endif 
21fe				endif 
21fe			endm 
# End of macro STACKFRAME
21fe			; get parser buffer length  of new word 
21fe			 
21fe			 
21fe			 
21fe				; move tok past this to start of name defintition 
21fe				; TODO get word to define 
21fe				; TODO Move past word token 
21fe				; TODO get length of string up to the ';' 
21fe			 
21fe 2a c2 e5		ld hl, (os_tok_ptr) 
2201 23			inc hl 
2202 23			inc hl 
2203			 
2203 3e 3b		ld a, ';' 
2205 cd a8 11		call strlent 
2208			 
2208 7d			ld a,l 
2209 32 b1 e2		ld (os_new_parse_len), a 
220c			 
220c			 
220c			if DEBUG_FORTH_UWORD 
220c ed 5b c2 e5	ld de, (os_tok_ptr) 
2210					DMARK ":01" 
2210 f5				push af  
2211 3a 25 22			ld a, (.dmark)  
2214 32 6b ee			ld (debug_mark),a  
2217 3a 26 22			ld a, (.dmark+1)  
221a 32 6c ee			ld (debug_mark+1),a  
221d 3a 27 22			ld a, (.dmark+2)  
2220 32 6d ee			ld (debug_mark+2),a  
2223 18 03			jr .pastdmark  
2225 ..			.dmark: db ":01"  
2228 f1			.pastdmark: pop af  
2229			endm  
# End of macro DMARK
2229			CALLMONITOR 
2229 cd 6f ee			call debug_vector  
222c				endm  
# End of macro CALLMONITOR
222c			endif 
222c			 
222c			; 
222c			;  new word memory layout: 
222c			;  
222c			;    : adg 6666 ;  
222c			; 
222c			;    db   1     ; user defined word  
222c 23			inc hl    
222d			;    dw   sysdict 
222d 23			inc hl 
222e 23			inc hl 
222f			;    db <word len>+1 (for null) 
222f 23			inc hl 
2230			;    db .... <word> 
2230			; 
2230			 
2230 23			inc hl    ; some extras for the word preamble before the above 
2231 23			inc hl 
2232 23			inc hl 
2233 23			inc hl 
2234 23			inc hl 
2235 23			inc hl 
2236 23			inc hl  
2237 23			inc hl 
2238 23			inc hl 
2239 23			inc hl 
223a 23			inc hl 
223b 23			inc hl 
223c 23			inc hl 
223d 23			inc hl     ; TODO how many do we really need?     maybe only 6 
223e			;       exec word buffer 
223e			;	<ptr word>   
223e 23			inc hl 
223f 23			inc hl 
2240			;       <word list><null term> 7F final term 
2240			 
2240			 
2240			if DEBUG_FORTH_UWORD 
2240					DMARK ":02" 
2240 f5				push af  
2241 3a 55 22			ld a, (.dmark)  
2244 32 6b ee			ld (debug_mark),a  
2247 3a 56 22			ld a, (.dmark+1)  
224a 32 6c ee			ld (debug_mark+1),a  
224d 3a 57 22			ld a, (.dmark+2)  
2250 32 6d ee			ld (debug_mark+2),a  
2253 18 03			jr .pastdmark  
2255 ..			.dmark: db ":02"  
2258 f1			.pastdmark: pop af  
2259			endm  
# End of macro DMARK
2259			CALLMONITOR 
2259 cd 6f ee			call debug_vector  
225c				endm  
# End of macro CALLMONITOR
225c			endif 
225c			 
225c			 
225c				; malloc the size 
225c			 
225c cd 12 12			call malloc 
225f 22 b3 e2			ld (os_new_malloc), hl     ; save malloc start 
2262			 
2262			;    db   1     ; user defined word  
2262 3e 01			ld a, WORD_SYS_UWORD  
2264 77				ld (hl), a 
2265			 
2265 23			inc hl    
2266			;    dw   sysdict 
2266 11 b0 20		ld de, sysdict       ; continue on with the scan to the system dict 
2269 73			ld (hl), e 
226a 23			inc hl 
226b 72			ld (hl), d 
226c 23			inc hl 
226d			 
226d			 
226d			;    Setup dict word 
226d			 
226d 23			inc hl 
226e 22 ad e2		ld (os_new_work_ptr), hl     ; save start of dict word  
2271			 
2271			; 1. get length of dict word 
2271			 
2271			 
2271 2a c2 e5		ld hl, (os_tok_ptr) 
2274 23			inc hl 
2275 23			inc hl    ; position to start of dict word 
2276 3e 00		ld a, 0 
2278 cd a8 11		call strlent 
227b			 
227b			 
227b 23			inc hl    ; to include null??? 
227c			 
227c			; write length of dict word 
227c			 
227c ed 5b ad e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
2280 1b			dec de 
2281 eb			ex de, hl 
2282 73			ld (hl), e 
2283 eb			ex de, hl 
2284			 
2284			 
2284			 
2284			; copy  
2284 4d			ld c, l 
2285 06 00		ld b, 0 
2287 ed 5b ad e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
228b 2a c2 e5		ld hl, (os_tok_ptr) 
228e 23			inc hl 
228f 23			inc hl    ; position to start of dict word 
2290			 
2290			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
2290			 
2290			; TODO need to convert word to upper case 
2290			 
2290			ucasetok:	 
2290 7e			ld a,(hl) 
2291 cd 94 11		call toUpper 
2294 77			ld (hl),a 
2295 ed a0		ldi 
2297 f2 90 22		jp p, ucasetok 
229a			 
229a			 
229a			 
229a			; de now points to start of where the word body code should be placed 
229a ed 53 ad e2	ld (os_new_work_ptr), de 
229e			; hl now points to the words to throw at forthexec which needs to be copied 
229e 22 ab e2		ld (os_new_src_ptr), hl 
22a1			 
22a1			; TODO add 'call to forthexec' 
22a1			 
22a1			if DEBUG_FORTH_UWORD 
22a1 c5			push bc 
22a2 ed 4b b3 e2	ld bc, (os_new_malloc) 
22a6					DMARK ":0x" 
22a6 f5				push af  
22a7 3a bb 22			ld a, (.dmark)  
22aa 32 6b ee			ld (debug_mark),a  
22ad 3a bc 22			ld a, (.dmark+1)  
22b0 32 6c ee			ld (debug_mark+1),a  
22b3 3a bd 22			ld a, (.dmark+2)  
22b6 32 6d ee			ld (debug_mark+2),a  
22b9 18 03			jr .pastdmark  
22bb ..			.dmark: db ":0x"  
22be f1			.pastdmark: pop af  
22bf			endm  
# End of macro DMARK
22bf			CALLMONITOR 
22bf cd 6f ee			call debug_vector  
22c2				endm  
# End of macro CALLMONITOR
22c2 c1			pop bc 
22c3			endif 
22c3			 
22c3			 
22c3			; create word preamble which should be: 
22c3			 
22c3			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
22c3			 
22c3			;    ld hl, <word code> 
22c3			;    jp user_exec 
22c3			;    <word code bytes> 
22c3			 
22c3			 
22c3			;	inc de     ; TODO ??? or are we already past the word's null 
22c3 eb			ex de, hl 
22c4			 
22c4 36 21		ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
22c6			 
22c6 23			inc hl 
22c7 22 a7 e2		ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
22ca 23			inc hl 
22cb			 
22cb 23			inc hl 
22cc 36 c3		ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
22ce			 
22ce 01 46 4c		ld bc, user_exec 
22d1 23			inc hl 
22d2 71			ld (hl), c     ; poke address of user_exec 
22d3 23			inc hl 
22d4 70			ld (hl), b     
22d5			; 
22d5			;	inc hl 
22d5			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
22d5			; 
22d5			; 
22d5			;	ld bc, macro_forth_rsp_next 
22d5			;	inc hl 
22d5			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
22d5			;	inc hl 
22d5			;	ld (hl), b     
22d5			; 
22d5			;	inc hl 
22d5			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
22d5			; 
22d5			; 
22d5			;	inc hl 
22d5			;	ld bc, forthexec 
22d5			;	ld (hl), c     ; poke address of forthexec 
22d5			;	inc hl 
22d5			;	ld (hl), b      
22d5			; 
22d5			;	inc hl 
22d5			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
22d5			; 
22d5			;	ld bc, user_dict_next 
22d5			;	inc hl 
22d5			;	ld (hl), c     ; poke address of forthexec 
22d5			;	inc hl 
22d5			;	ld (hl), b      
22d5			 
22d5			; hl is now where we need to copy the word byte data to save this 
22d5			 
22d5 23			inc hl 
22d6 22 a9 e2		ld (os_new_exec), hl 
22d9			 
22d9			; copy definition 
22d9			 
22d9 eb			ex de, hl 
22da			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
22da			;	inc de    ; skip the PC for this parse 
22da 3a b1 e2		ld a, (os_new_parse_len) 
22dd 4f			ld c, a 
22de 06 00		ld b, 0 
22e0 ed b0		ldir		 ; copy defintion 
22e2			 
22e2			 
22e2			; poke the address of where the new word bytes live for forthexec 
22e2			 
22e2 2a a7 e2		ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
22e5			 
22e5 ed 5b a9 e2	ld de, (os_new_exec)      
22e9			 
22e9 73			ld (hl), e 
22ea 23			inc hl 
22eb 72			ld (hl), d 
22ec			 
22ec				; TODO copy last user dict word next link to this word 
22ec				; TODO update last user dict word to point to this word 
22ec			; 
22ec			; hl f923 de 812a ; bc 811a 
22ec			 
22ec			if DEBUG_FORTH_UWORD 
22ec c5			push bc 
22ed ed 4b b3 e2	ld bc, (os_new_malloc) 
22f1					DMARK ":0A" 
22f1 f5				push af  
22f2 3a 06 23			ld a, (.dmark)  
22f5 32 6b ee			ld (debug_mark),a  
22f8 3a 07 23			ld a, (.dmark+1)  
22fb 32 6c ee			ld (debug_mark+1),a  
22fe 3a 08 23			ld a, (.dmark+2)  
2301 32 6d ee			ld (debug_mark+2),a  
2304 18 03			jr .pastdmark  
2306 ..			.dmark: db ":0A"  
2309 f1			.pastdmark: pop af  
230a			endm  
# End of macro DMARK
230a			CALLMONITOR 
230a cd 6f ee			call debug_vector  
230d				endm  
# End of macro CALLMONITOR
230d c1			pop bc 
230e			endif 
230e			if DEBUG_FORTH_UWORD 
230e c5			push bc 
230f ed 4b b3 e2	ld bc, (os_new_malloc) 
2313 03			inc bc 
2314 03			inc bc 
2315 03			inc bc 
2316 03			inc bc 
2317 03			inc bc 
2318 03			inc bc 
2319 03			inc bc 
231a 03			inc bc 
231b			 
231b					DMARK ":0B" 
231b f5				push af  
231c 3a 30 23			ld a, (.dmark)  
231f 32 6b ee			ld (debug_mark),a  
2322 3a 31 23			ld a, (.dmark+1)  
2325 32 6c ee			ld (debug_mark+1),a  
2328 3a 32 23			ld a, (.dmark+2)  
232b 32 6d ee			ld (debug_mark+2),a  
232e 18 03			jr .pastdmark  
2330 ..			.dmark: db ":0B"  
2333 f1			.pastdmark: pop af  
2334			endm  
# End of macro DMARK
2334			CALLMONITOR 
2334 cd 6f ee			call debug_vector  
2337				endm  
# End of macro CALLMONITOR
2337 c1			pop bc 
2338			endif 
2338			 
2338			; update word dict linked list for new word 
2338			 
2338			 
2338 2a be e5		ld hl, (os_last_new_uword)		; get the start of the last added uword 
233b 23			inc hl     ; move to next work linked list ptr 
233c			 
233c ed 5b b3 e2	ld de, (os_new_malloc)		 ; new next word 
2340 73			ld (hl), e 
2341 23			inc hl 
2342 72			ld (hl), d 
2343			 
2343			if DEBUG_FORTH_UWORD 
2343 ed 4b be e5	ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
2347			endif 
2347			 
2347 ed 53 be e5	ld (os_last_new_uword), de      ; update last new uword ptr 
234b			 
234b			 
234b			if DEBUG_FORTH_UWORD 
234b					DMARK ":0+" 
234b f5				push af  
234c 3a 60 23			ld a, (.dmark)  
234f 32 6b ee			ld (debug_mark),a  
2352 3a 61 23			ld a, (.dmark+1)  
2355 32 6c ee			ld (debug_mark+1),a  
2358 3a 62 23			ld a, (.dmark+2)  
235b 32 6d ee			ld (debug_mark+2),a  
235e 18 03			jr .pastdmark  
2360 ..			.dmark: db ":0+"  
2363 f1			.pastdmark: pop af  
2364			endm  
# End of macro DMARK
2364			CALLMONITOR 
2364 cd 6f ee			call debug_vector  
2367				endm  
# End of macro CALLMONITOR
2367			endif 
2367			 
2367			STACKFRAMECHK OFF $8efe $989f 
2367				if DEBUG_STACK_IMB 
2367					if OFF 
2367						exx 
2367						ld hl, $989f 
2367						pop de   ; $989f 
2367						call cmp16 
2367						jr nz, .spnosame 
2367						ld hl, $8efe 
2367						pop de   ; $8efe 
2367						call cmp16 
2367						jr z, .spfrsame 
2367						.spnosame: call showsperror 
2367						.spfrsame: nop 
2367						exx 
2367					endif 
2367				endif 
2367			endm 
# End of macro STACKFRAMECHK
2367			 
2367 c9			ret    ; dont process any remaining parser tokens as they form new word 
2368			 
2368			 
2368			 
2368			 
2368			;		NEXT 
2368			.SCOLN: 
2368			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
2368 06			db OPCODE_SCOLN 
2369 b4 23		dw .DROP 
236b 02			db 2 
236c .. 00		db ";",0           
236e			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
236e				if DEBUG_FORTH_WORDS_KEY 
236e					DMARK "SCN" 
236e f5				push af  
236f 3a 83 23			ld a, (.dmark)  
2372 32 6b ee			ld (debug_mark),a  
2375 3a 84 23			ld a, (.dmark+1)  
2378 32 6c ee			ld (debug_mark+1),a  
237b 3a 85 23			ld a, (.dmark+2)  
237e 32 6d ee			ld (debug_mark+2),a  
2381 18 03			jr .pastdmark  
2383 ..			.dmark: db "SCN"  
2386 f1			.pastdmark: pop af  
2387			endm  
# End of macro DMARK
2387					CALLMONITOR 
2387 cd 6f ee			call debug_vector  
238a				endm  
# End of macro CALLMONITOR
238a				endif 
238a				FORTH_RSP_TOS 
238a cd 69 1b			call macro_forth_rsp_tos 
238d				endm 
# End of macro FORTH_RSP_TOS
238d e5				push hl 
238e				FORTH_RSP_POP 
238e cd 73 1b			call macro_forth_rsp_pop 
2391				endm 
# End of macro FORTH_RSP_POP
2391 e1				pop hl 
2392			;		ex de,hl 
2392 22 c2 e5			ld (os_tok_ptr),hl 
2395			 
2395			if DEBUG_FORTH_UWORD 
2395					DMARK "SCL" 
2395 f5				push af  
2396 3a aa 23			ld a, (.dmark)  
2399 32 6b ee			ld (debug_mark),a  
239c 3a ab 23			ld a, (.dmark+1)  
239f 32 6c ee			ld (debug_mark+1),a  
23a2 3a ac 23			ld a, (.dmark+2)  
23a5 32 6d ee			ld (debug_mark+2),a  
23a8 18 03			jr .pastdmark  
23aa ..			.dmark: db "SCL"  
23ad f1			.pastdmark: pop af  
23ae			endm  
# End of macro DMARK
23ae			CALLMONITOR 
23ae cd 6f ee			call debug_vector  
23b1				endm  
# End of macro CALLMONITOR
23b1			endif 
23b1				NEXTW 
23b1 c3 58 1f			jp macro_next 
23b4				endm 
# End of macro NEXTW
23b4			 
23b4			.DROP: 
23b4			CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
23b4 1b				db WORD_SYS_CORE+OPCODE_DROP             
23b5 df 23			dw .DUP2            
23b7 05				db 4 + 1 
23b8 .. 00			db "DROP",0              
23bd				endm 
# End of macro CWHEAD
23bd			; | DROP ( w -- )   drop the TOS item   | DONE 
23bd				if DEBUG_FORTH_WORDS_KEY 
23bd					DMARK "DRP" 
23bd f5				push af  
23be 3a d2 23			ld a, (.dmark)  
23c1 32 6b ee			ld (debug_mark),a  
23c4 3a d3 23			ld a, (.dmark+1)  
23c7 32 6c ee			ld (debug_mark+1),a  
23ca 3a d4 23			ld a, (.dmark+2)  
23cd 32 6d ee			ld (debug_mark+2),a  
23d0 18 03			jr .pastdmark  
23d2 ..			.dmark: db "DRP"  
23d5 f1			.pastdmark: pop af  
23d6			endm  
# End of macro DMARK
23d6					CALLMONITOR 
23d6 cd 6f ee			call debug_vector  
23d9				endm  
# End of macro CALLMONITOR
23d9				endif 
23d9				FORTH_DSP_POP 
23d9 cd 5a 1e			call macro_forth_dsp_pop 
23dc				endm 
# End of macro FORTH_DSP_POP
23dc				NEXTW 
23dc c3 58 1f			jp macro_next 
23df				endm 
# End of macro NEXTW
23df			.DUP2: 
23df			CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
23df 1c				db WORD_SYS_CORE+OPCODE_DUP2             
23e0 24 24			dw .DROP2            
23e2 05				db 4 + 1 
23e3 .. 00			db "2DUP",0              
23e8				endm 
# End of macro CWHEAD
23e8			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
23e8				if DEBUG_FORTH_WORDS_KEY 
23e8					DMARK "2DU" 
23e8 f5				push af  
23e9 3a fd 23			ld a, (.dmark)  
23ec 32 6b ee			ld (debug_mark),a  
23ef 3a fe 23			ld a, (.dmark+1)  
23f2 32 6c ee			ld (debug_mark+1),a  
23f5 3a ff 23			ld a, (.dmark+2)  
23f8 32 6d ee			ld (debug_mark+2),a  
23fb 18 03			jr .pastdmark  
23fd ..			.dmark: db "2DU"  
2400 f1			.pastdmark: pop af  
2401			endm  
# End of macro DMARK
2401					CALLMONITOR 
2401 cd 6f ee			call debug_vector  
2404				endm  
# End of macro CALLMONITOR
2404				endif 
2404				FORTH_DSP_VALUEHL 
2404 cd a2 1d			call macro_dsp_valuehl 
2407				endm 
# End of macro FORTH_DSP_VALUEHL
2407 e5				push hl      ; 2 
2408			 
2408				FORTH_DSP_POP 
2408 cd 5a 1e			call macro_forth_dsp_pop 
240b				endm 
# End of macro FORTH_DSP_POP
240b				 
240b				FORTH_DSP_VALUEHL 
240b cd a2 1d			call macro_dsp_valuehl 
240e				endm 
# End of macro FORTH_DSP_VALUEHL
240e			;		push hl      ; 1 
240e			 
240e				FORTH_DSP_POP 
240e cd 5a 1e			call macro_forth_dsp_pop 
2411				endm 
# End of macro FORTH_DSP_POP
2411			 
2411			;		pop hl       ; 1 
2411 d1				pop de       ; 2 
2412			 
2412 cd ab 1b			call forth_push_numhl 
2415 eb				ex de, hl 
2416 cd ab 1b			call forth_push_numhl 
2419			 
2419				 
2419 eb				ex de, hl 
241a			 
241a cd ab 1b			call forth_push_numhl 
241d eb				ex de, hl 
241e cd ab 1b			call forth_push_numhl 
2421			 
2421			 
2421				NEXTW 
2421 c3 58 1f			jp macro_next 
2424				endm 
# End of macro NEXTW
2424			.DROP2: 
2424			CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
2424 1d				db WORD_SYS_CORE+OPCODE_DROP2             
2425 53 24			dw .SWAP2            
2427 06				db 5 + 1 
2428 .. 00			db "2DROP",0              
242e				endm 
# End of macro CWHEAD
242e			; | 2DROP ( w w -- )    Double drop | DONE 
242e				if DEBUG_FORTH_WORDS_KEY 
242e					DMARK "2DR" 
242e f5				push af  
242f 3a 43 24			ld a, (.dmark)  
2432 32 6b ee			ld (debug_mark),a  
2435 3a 44 24			ld a, (.dmark+1)  
2438 32 6c ee			ld (debug_mark+1),a  
243b 3a 45 24			ld a, (.dmark+2)  
243e 32 6d ee			ld (debug_mark+2),a  
2441 18 03			jr .pastdmark  
2443 ..			.dmark: db "2DR"  
2446 f1			.pastdmark: pop af  
2447			endm  
# End of macro DMARK
2447					CALLMONITOR 
2447 cd 6f ee			call debug_vector  
244a				endm  
# End of macro CALLMONITOR
244a				endif 
244a				FORTH_DSP_POP 
244a cd 5a 1e			call macro_forth_dsp_pop 
244d				endm 
# End of macro FORTH_DSP_POP
244d				FORTH_DSP_POP 
244d cd 5a 1e			call macro_forth_dsp_pop 
2450				endm 
# End of macro FORTH_DSP_POP
2450				NEXTW 
2450 c3 58 1f			jp macro_next 
2453				endm 
# End of macro NEXTW
2453			.SWAP2: 
2453			CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
2453 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
2454 7c 24			dw .AT            
2456 06				db 5 + 1 
2457 .. 00			db "2SWAP",0              
245d				endm 
# End of macro CWHEAD
245d			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
245d				if DEBUG_FORTH_WORDS_KEY 
245d					DMARK "2SW" 
245d f5				push af  
245e 3a 72 24			ld a, (.dmark)  
2461 32 6b ee			ld (debug_mark),a  
2464 3a 73 24			ld a, (.dmark+1)  
2467 32 6c ee			ld (debug_mark+1),a  
246a 3a 74 24			ld a, (.dmark+2)  
246d 32 6d ee			ld (debug_mark+2),a  
2470 18 03			jr .pastdmark  
2472 ..			.dmark: db "2SW"  
2475 f1			.pastdmark: pop af  
2476			endm  
# End of macro DMARK
2476					CALLMONITOR 
2476 cd 6f ee			call debug_vector  
2479				endm  
# End of macro CALLMONITOR
2479				endif 
2479			; TODO Use os stack swap memory 
2479				NEXTW 
2479 c3 58 1f			jp macro_next 
247c				endm 
# End of macro NEXTW
247c			.AT: 
247c			CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
247c 1f				db WORD_SYS_CORE+OPCODE_AT             
247d ae 24			dw .CAT            
247f 02				db 1 + 1 
2480 .. 00			db "@",0              
2482				endm 
# End of macro CWHEAD
2482			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
2482			 
2482				if DEBUG_FORTH_WORDS_KEY 
2482					DMARK "AT." 
2482 f5				push af  
2483 3a 97 24			ld a, (.dmark)  
2486 32 6b ee			ld (debug_mark),a  
2489 3a 98 24			ld a, (.dmark+1)  
248c 32 6c ee			ld (debug_mark+1),a  
248f 3a 99 24			ld a, (.dmark+2)  
2492 32 6d ee			ld (debug_mark+2),a  
2495 18 03			jr .pastdmark  
2497 ..			.dmark: db "AT."  
249a f1			.pastdmark: pop af  
249b			endm  
# End of macro DMARK
249b					CALLMONITOR 
249b cd 6f ee			call debug_vector  
249e				endm  
# End of macro CALLMONITOR
249e				endif 
249e			.getbyteat:	 
249e				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
249e cd a2 1d			call macro_dsp_valuehl 
24a1				endm 
# End of macro FORTH_DSP_VALUEHL
24a1				 
24a1			;		push hl 
24a1			 
24a1				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
24a1 cd 5a 1e			call macro_forth_dsp_pop 
24a4				endm 
# End of macro FORTH_DSP_POP
24a4			 
24a4			;		pop hl 
24a4			 
24a4 7e				ld a, (hl) 
24a5			 
24a5 6f				ld l, a 
24a6 26 00			ld h, 0 
24a8 cd ab 1b			call forth_push_numhl 
24ab			 
24ab				NEXTW 
24ab c3 58 1f			jp macro_next 
24ae				endm 
# End of macro NEXTW
24ae			.CAT: 
24ae			CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
24ae 20				db WORD_SYS_CORE+OPCODE_CAT             
24af d7 24			dw .BANG            
24b1 03				db 2 + 1 
24b2 .. 00			db "C@",0              
24b5				endm 
# End of macro CWHEAD
24b5			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
24b5				if DEBUG_FORTH_WORDS_KEY 
24b5					DMARK "CAA" 
24b5 f5				push af  
24b6 3a ca 24			ld a, (.dmark)  
24b9 32 6b ee			ld (debug_mark),a  
24bc 3a cb 24			ld a, (.dmark+1)  
24bf 32 6c ee			ld (debug_mark+1),a  
24c2 3a cc 24			ld a, (.dmark+2)  
24c5 32 6d ee			ld (debug_mark+2),a  
24c8 18 03			jr .pastdmark  
24ca ..			.dmark: db "CAA"  
24cd f1			.pastdmark: pop af  
24ce			endm  
# End of macro DMARK
24ce					CALLMONITOR 
24ce cd 6f ee			call debug_vector  
24d1				endm  
# End of macro CALLMONITOR
24d1				endif 
24d1 c3 9e 24			jp .getbyteat 
24d4				NEXTW 
24d4 c3 58 1f			jp macro_next 
24d7				endm 
# End of macro NEXTW
24d7			.BANG: 
24d7			CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
24d7 21				db WORD_SYS_CORE+OPCODE_BANG             
24d8 0d 25			dw .CBANG            
24da 02				db 1 + 1 
24db .. 00			db "!",0              
24dd				endm 
# End of macro CWHEAD
24dd			; | ! ( x w -- ) Store x at address w      | DONE 
24dd				if DEBUG_FORTH_WORDS_KEY 
24dd					DMARK "BNG" 
24dd f5				push af  
24de 3a f2 24			ld a, (.dmark)  
24e1 32 6b ee			ld (debug_mark),a  
24e4 3a f3 24			ld a, (.dmark+1)  
24e7 32 6c ee			ld (debug_mark+1),a  
24ea 3a f4 24			ld a, (.dmark+2)  
24ed 32 6d ee			ld (debug_mark+2),a  
24f0 18 03			jr .pastdmark  
24f2 ..			.dmark: db "BNG"  
24f5 f1			.pastdmark: pop af  
24f6			endm  
# End of macro DMARK
24f6					CALLMONITOR 
24f6 cd 6f ee			call debug_vector  
24f9				endm  
# End of macro CALLMONITOR
24f9				endif 
24f9			 
24f9			.storebyteat:		 
24f9				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
24f9 cd a2 1d			call macro_dsp_valuehl 
24fc				endm 
# End of macro FORTH_DSP_VALUEHL
24fc				 
24fc e5				push hl 
24fd			 
24fd				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
24fd cd 5a 1e			call macro_forth_dsp_pop 
2500				endm 
# End of macro FORTH_DSP_POP
2500			 
2500				; get byte to poke 
2500			 
2500				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2500 cd a2 1d			call macro_dsp_valuehl 
2503				endm 
# End of macro FORTH_DSP_VALUEHL
2503 e5				push hl 
2504			 
2504			 
2504				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2504 cd 5a 1e			call macro_forth_dsp_pop 
2507				endm 
# End of macro FORTH_DSP_POP
2507			 
2507			 
2507 d1				pop de 
2508 e1				pop hl 
2509			 
2509 73				ld (hl),e 
250a			 
250a			 
250a				NEXTW 
250a c3 58 1f			jp macro_next 
250d				endm 
# End of macro NEXTW
250d			.CBANG: 
250d			CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
250d 22				db WORD_SYS_CORE+OPCODE_CBANG             
250e 36 25			dw .SCALL            
2510 03				db 2 + 1 
2511 .. 00			db "C!",0              
2514				endm 
# End of macro CWHEAD
2514			; | C!  ( x w -- ) Store x at address w  | DONE 
2514				if DEBUG_FORTH_WORDS_KEY 
2514					DMARK "CBA" 
2514 f5				push af  
2515 3a 29 25			ld a, (.dmark)  
2518 32 6b ee			ld (debug_mark),a  
251b 3a 2a 25			ld a, (.dmark+1)  
251e 32 6c ee			ld (debug_mark+1),a  
2521 3a 2b 25			ld a, (.dmark+2)  
2524 32 6d ee			ld (debug_mark+2),a  
2527 18 03			jr .pastdmark  
2529 ..			.dmark: db "CBA"  
252c f1			.pastdmark: pop af  
252d			endm  
# End of macro DMARK
252d					CALLMONITOR 
252d cd 6f ee			call debug_vector  
2530				endm  
# End of macro CALLMONITOR
2530				endif 
2530 c3 f9 24			jp .storebyteat 
2533				NEXTW 
2533 c3 58 1f			jp macro_next 
2536				endm 
# End of macro NEXTW
2536			.SCALL: 
2536			CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
2536 23				db WORD_SYS_CORE+OPCODE_SCALL             
2537 6a 25			dw .DEPTH            
2539 05				db 4 + 1 
253a .. 00			db "CALL",0              
253f				endm 
# End of macro CWHEAD
253f			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
253f				if DEBUG_FORTH_WORDS_KEY 
253f					DMARK "CLL" 
253f f5				push af  
2540 3a 54 25			ld a, (.dmark)  
2543 32 6b ee			ld (debug_mark),a  
2546 3a 55 25			ld a, (.dmark+1)  
2549 32 6c ee			ld (debug_mark+1),a  
254c 3a 56 25			ld a, (.dmark+2)  
254f 32 6d ee			ld (debug_mark+2),a  
2552 18 03			jr .pastdmark  
2554 ..			.dmark: db "CLL"  
2557 f1			.pastdmark: pop af  
2558			endm  
# End of macro DMARK
2558					CALLMONITOR 
2558 cd 6f ee			call debug_vector  
255b				endm  
# End of macro CALLMONITOR
255b				endif 
255b			 
255b				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
255b cd a2 1d			call macro_dsp_valuehl 
255e				endm 
# End of macro FORTH_DSP_VALUEHL
255e			 
255e			;		push hl 
255e			 
255e				; destroy value TOS 
255e			 
255e				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
255e cd 5a 1e			call macro_forth_dsp_pop 
2561				endm 
# End of macro FORTH_DSP_POP
2561			 
2561					 
2561			;		pop hl 
2561			 
2561				; how to do a call with hl???? save SP? 
2561 cd fc 1e			call forth_call_hl 
2564			 
2564			 
2564				; TODO push value back onto stack for another op etc 
2564			 
2564 cd ab 1b			call forth_push_numhl 
2567				NEXTW 
2567 c3 58 1f			jp macro_next 
256a				endm 
# End of macro NEXTW
256a			.DEPTH: 
256a			CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
256a 24				db WORD_SYS_CORE+OPCODE_DEPTH             
256b a7 25			dw .OVER            
256d 06				db 5 + 1 
256e .. 00			db "DEPTH",0              
2574				endm 
# End of macro CWHEAD
2574			; | DEPTH ( -- u ) Push count of stack | DONE 
2574				; take current TOS and remove from base value div by two to get count 
2574				if DEBUG_FORTH_WORDS_KEY 
2574					DMARK "DEP" 
2574 f5				push af  
2575 3a 89 25			ld a, (.dmark)  
2578 32 6b ee			ld (debug_mark),a  
257b 3a 8a 25			ld a, (.dmark+1)  
257e 32 6c ee			ld (debug_mark+1),a  
2581 3a 8b 25			ld a, (.dmark+2)  
2584 32 6d ee			ld (debug_mark+2),a  
2587 18 03			jr .pastdmark  
2589 ..			.dmark: db "DEP"  
258c f1			.pastdmark: pop af  
258d			endm  
# End of macro DMARK
258d					CALLMONITOR 
258d cd 6f ee			call debug_vector  
2590				endm  
# End of macro CALLMONITOR
2590				endif 
2590			 
2590			 
2590 2a ee e9		ld hl, (cli_data_sp) 
2593 11 28 e8		ld de, cli_data_stack 
2596 ed 52		sbc hl,de 
2598			 
2598			; div by size of stack item 
2598			 
2598 5d			ld e,l 
2599 0e 03		ld c, 3 
259b cd 76 0d		call Div8 
259e			 
259e 6f			ld l,a 
259f 26 00		ld h,0 
25a1			 
25a1			;srl h 
25a1			;rr l 
25a1			 
25a1 cd ab 1b			call forth_push_numhl 
25a4				NEXTW 
25a4 c3 58 1f			jp macro_next 
25a7				endm 
# End of macro NEXTW
25a7			.OVER: 
25a7			CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
25a7 42				db WORD_SYS_CORE+46             
25a8 ee 25			dw .PAUSE            
25aa 05				db 4 + 1 
25ab .. 00			db "OVER",0              
25b0				endm 
# End of macro CWHEAD
25b0			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
25b0				if DEBUG_FORTH_WORDS_KEY 
25b0					DMARK "OVR" 
25b0 f5				push af  
25b1 3a c5 25			ld a, (.dmark)  
25b4 32 6b ee			ld (debug_mark),a  
25b7 3a c6 25			ld a, (.dmark+1)  
25ba 32 6c ee			ld (debug_mark+1),a  
25bd 3a c7 25			ld a, (.dmark+2)  
25c0 32 6d ee			ld (debug_mark+2),a  
25c3 18 03			jr .pastdmark  
25c5 ..			.dmark: db "OVR"  
25c8 f1			.pastdmark: pop af  
25c9			endm  
# End of macro DMARK
25c9					CALLMONITOR 
25c9 cd 6f ee			call debug_vector  
25cc				endm  
# End of macro CALLMONITOR
25cc				endif 
25cc			 
25cc			; TODO Use os stack swap memory 
25cc				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25cc cd a2 1d			call macro_dsp_valuehl 
25cf				endm 
# End of macro FORTH_DSP_VALUEHL
25cf e5				push hl    ; n2 
25d0				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25d0 cd 5a 1e			call macro_forth_dsp_pop 
25d3				endm 
# End of macro FORTH_DSP_POP
25d3			 
25d3				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25d3 cd a2 1d			call macro_dsp_valuehl 
25d6				endm 
# End of macro FORTH_DSP_VALUEHL
25d6 e5				push hl    ; n1 
25d7				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25d7 cd 5a 1e			call macro_forth_dsp_pop 
25da				endm 
# End of macro FORTH_DSP_POP
25da			 
25da d1				pop de     ; n1 
25db e1				pop hl     ; n2 
25dc			 
25dc d5				push de 
25dd e5				push hl 
25de d5				push de 
25df			 
25df				; push back  
25df			 
25df e1				pop hl 
25e0 cd ab 1b			call forth_push_numhl 
25e3 e1				pop hl 
25e4 cd ab 1b			call forth_push_numhl 
25e7 e1				pop hl 
25e8 cd ab 1b			call forth_push_numhl 
25eb				NEXTW 
25eb c3 58 1f			jp macro_next 
25ee				endm 
# End of macro NEXTW
25ee			 
25ee			.PAUSE: 
25ee			CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
25ee 43				db WORD_SYS_CORE+47             
25ef 23 26			dw .PAUSES            
25f1 08				db 7 + 1 
25f2 .. 00			db "PAUSEMS",0              
25fa				endm 
# End of macro CWHEAD
25fa			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
25fa				if DEBUG_FORTH_WORDS_KEY 
25fa					DMARK "PMS" 
25fa f5				push af  
25fb 3a 0f 26			ld a, (.dmark)  
25fe 32 6b ee			ld (debug_mark),a  
2601 3a 10 26			ld a, (.dmark+1)  
2604 32 6c ee			ld (debug_mark+1),a  
2607 3a 11 26			ld a, (.dmark+2)  
260a 32 6d ee			ld (debug_mark+2),a  
260d 18 03			jr .pastdmark  
260f ..			.dmark: db "PMS"  
2612 f1			.pastdmark: pop af  
2613			endm  
# End of macro DMARK
2613					CALLMONITOR 
2613 cd 6f ee			call debug_vector  
2616				endm  
# End of macro CALLMONITOR
2616				endif 
2616				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2616 cd a2 1d			call macro_dsp_valuehl 
2619				endm 
# End of macro FORTH_DSP_VALUEHL
2619			;		push hl    ; n2 
2619				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2619 cd 5a 1e			call macro_forth_dsp_pop 
261c				endm 
# End of macro FORTH_DSP_POP
261c			;		pop hl 
261c			 
261c 7d				ld a, l 
261d cd d6 0a			call aDelayInMS 
2620			       NEXTW 
2620 c3 58 1f			jp macro_next 
2623				endm 
# End of macro NEXTW
2623			.PAUSES:  
2623			CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
2623 44				db WORD_SYS_CORE+48             
2624 92 26			dw .ROT            
2626 06				db 5 + 1 
2627 .. 00			db "PAUSE",0              
262d				endm 
# End of macro CWHEAD
262d			; | PAUSE ( n -- )  Pause for n seconds | DONE 
262d				if DEBUG_FORTH_WORDS_KEY 
262d					DMARK "PAU" 
262d f5				push af  
262e 3a 42 26			ld a, (.dmark)  
2631 32 6b ee			ld (debug_mark),a  
2634 3a 43 26			ld a, (.dmark+1)  
2637 32 6c ee			ld (debug_mark+1),a  
263a 3a 44 26			ld a, (.dmark+2)  
263d 32 6d ee			ld (debug_mark+2),a  
2640 18 03			jr .pastdmark  
2642 ..			.dmark: db "PAU"  
2645 f1			.pastdmark: pop af  
2646			endm  
# End of macro DMARK
2646					CALLMONITOR 
2646 cd 6f ee			call debug_vector  
2649				endm  
# End of macro CALLMONITOR
2649				endif 
2649				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2649 cd a2 1d			call macro_dsp_valuehl 
264c				endm 
# End of macro FORTH_DSP_VALUEHL
264c			;		push hl    ; n2 
264c				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
264c cd 5a 1e			call macro_forth_dsp_pop 
264f				endm 
# End of macro FORTH_DSP_POP
264f			;		pop hl 
264f 45				ld b, l 
2650				if DEBUG_FORTH_WORDS 
2650					DMARK "PAU" 
2650 f5				push af  
2651 3a 65 26			ld a, (.dmark)  
2654 32 6b ee			ld (debug_mark),a  
2657 3a 66 26			ld a, (.dmark+1)  
265a 32 6c ee			ld (debug_mark+1),a  
265d 3a 67 26			ld a, (.dmark+2)  
2660 32 6d ee			ld (debug_mark+2),a  
2663 18 03			jr .pastdmark  
2665 ..			.dmark: db "PAU"  
2668 f1			.pastdmark: pop af  
2669			endm  
# End of macro DMARK
2669					CALLMONITOR 
2669 cd 6f ee			call debug_vector  
266c				endm  
# End of macro CALLMONITOR
266c				endif 
266c c5			.pauses1:	push bc 
266d cd f1 0a			call delay1s 
2670 c1				pop bc 
2671				if DEBUG_FORTH_WORDS 
2671					DMARK "PA1" 
2671 f5				push af  
2672 3a 86 26			ld a, (.dmark)  
2675 32 6b ee			ld (debug_mark),a  
2678 3a 87 26			ld a, (.dmark+1)  
267b 32 6c ee			ld (debug_mark+1),a  
267e 3a 88 26			ld a, (.dmark+2)  
2681 32 6d ee			ld (debug_mark+2),a  
2684 18 03			jr .pastdmark  
2686 ..			.dmark: db "PA1"  
2689 f1			.pastdmark: pop af  
268a			endm  
# End of macro DMARK
268a					CALLMONITOR 
268a cd 6f ee			call debug_vector  
268d				endm  
# End of macro CALLMONITOR
268d				endif 
268d 10 dd			djnz .pauses1 
268f			 
268f			       NEXTW 
268f c3 58 1f			jp macro_next 
2692				endm 
# End of macro NEXTW
2692			.ROT: 
2692			CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2692 45				db WORD_SYS_CORE+49             
2693 e0 26			dw .UWORDS            
2695 04				db 3 + 1 
2696 .. 00			db "ROT",0              
269a				endm 
# End of macro CWHEAD
269a			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
269a				if DEBUG_FORTH_WORDS_KEY 
269a					DMARK "ROT" 
269a f5				push af  
269b 3a af 26			ld a, (.dmark)  
269e 32 6b ee			ld (debug_mark),a  
26a1 3a b0 26			ld a, (.dmark+1)  
26a4 32 6c ee			ld (debug_mark+1),a  
26a7 3a b1 26			ld a, (.dmark+2)  
26aa 32 6d ee			ld (debug_mark+2),a  
26ad 18 03			jr .pastdmark  
26af ..			.dmark: db "ROT"  
26b2 f1			.pastdmark: pop af  
26b3			endm  
# End of macro DMARK
26b3					CALLMONITOR 
26b3 cd 6f ee			call debug_vector  
26b6				endm  
# End of macro CALLMONITOR
26b6				endif 
26b6			 
26b6			; TODO Use os stack swap memory 
26b6				FORTH_DSP_VALUEHL 
26b6 cd a2 1d			call macro_dsp_valuehl 
26b9				endm 
# End of macro FORTH_DSP_VALUEHL
26b9 e5				push hl    ; u3  
26ba			 
26ba				FORTH_DSP_POP 
26ba cd 5a 1e			call macro_forth_dsp_pop 
26bd				endm 
# End of macro FORTH_DSP_POP
26bd			 
26bd				FORTH_DSP_VALUEHL 
26bd cd a2 1d			call macro_dsp_valuehl 
26c0				endm 
# End of macro FORTH_DSP_VALUEHL
26c0 e5				push hl     ; u2 
26c1			 
26c1				FORTH_DSP_POP 
26c1 cd 5a 1e			call macro_forth_dsp_pop 
26c4				endm 
# End of macro FORTH_DSP_POP
26c4			 
26c4				FORTH_DSP_VALUEHL 
26c4 cd a2 1d			call macro_dsp_valuehl 
26c7				endm 
# End of macro FORTH_DSP_VALUEHL
26c7 e5				push hl     ; u1 
26c8			 
26c8				FORTH_DSP_POP 
26c8 cd 5a 1e			call macro_forth_dsp_pop 
26cb				endm 
# End of macro FORTH_DSP_POP
26cb			 
26cb c1				pop bc      ; u1 
26cc e1				pop hl      ; u2 
26cd d1				pop de      ; u3 
26ce			 
26ce			 
26ce c5				push bc 
26cf d5				push de 
26d0 e5				push hl 
26d1			 
26d1			 
26d1 e1				pop hl 
26d2 cd ab 1b			call forth_push_numhl 
26d5			 
26d5 e1				pop hl 
26d6 cd ab 1b			call forth_push_numhl 
26d9			 
26d9 e1				pop hl 
26da cd ab 1b			call forth_push_numhl 
26dd				 
26dd			 
26dd			 
26dd			 
26dd			 
26dd			 
26dd			       NEXTW 
26dd c3 58 1f			jp macro_next 
26e0				endm 
# End of macro NEXTW
26e0			 
26e0			.UWORDS: 
26e0			CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
26e0 50				db WORD_SYS_CORE+60             
26e1 a2 27			dw .BP            
26e3 07				db 6 + 1 
26e4 .. 00			db "UWORDS",0              
26eb				endm 
# End of macro CWHEAD
26eb			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
26eb			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
26eb			; | | Following the count are the individual words. 
26eb			; | | 
26eb			; | | e.g. UWORDS 
26eb			; | | BOX DIRLIST 2 
26eb			; | |  
26eb			; | | Can be used to save the words to storage via: 
26eb			; | | UWORDS $01 DO $01 APPEND LOOP 
26eb			if DEBUG_FORTH_WORDS_KEY 
26eb				DMARK "UWR" 
26eb f5				push af  
26ec 3a 00 27			ld a, (.dmark)  
26ef 32 6b ee			ld (debug_mark),a  
26f2 3a 01 27			ld a, (.dmark+1)  
26f5 32 6c ee			ld (debug_mark+1),a  
26f8 3a 02 27			ld a, (.dmark+2)  
26fb 32 6d ee			ld (debug_mark+2),a  
26fe 18 03			jr .pastdmark  
2700 ..			.dmark: db "UWR"  
2703 f1			.pastdmark: pop af  
2704			endm  
# End of macro DMARK
2704				CALLMONITOR 
2704 cd 6f ee			call debug_vector  
2707				endm  
# End of macro CALLMONITOR
2707			endif 
2707 21 a0 65			ld hl, baseram 
270a				;ld hl, baseusermem 
270a 01 00 00			ld bc, 0    ; start a counter 
270d			 
270d			; skip dict stub 
270d			 
270d cd a9 20			call forth_tok_next 
2710			 
2710			 
2710			; while we have words to look for 
2710			 
2710 7e			.douscan:	ld a, (hl)      
2711			if DEBUG_FORTH_WORDS 
2711				DMARK "UWs" 
2711 f5				push af  
2712 3a 26 27			ld a, (.dmark)  
2715 32 6b ee			ld (debug_mark),a  
2718 3a 27 27			ld a, (.dmark+1)  
271b 32 6c ee			ld (debug_mark+1),a  
271e 3a 28 27			ld a, (.dmark+2)  
2721 32 6d ee			ld (debug_mark+2),a  
2724 18 03			jr .pastdmark  
2726 ..			.dmark: db "UWs"  
2729 f1			.pastdmark: pop af  
272a			endm  
# End of macro DMARK
272a				CALLMONITOR 
272a cd 6f ee			call debug_vector  
272d				endm  
# End of macro CALLMONITOR
272d			endif 
272d fe 00			cp WORD_SYS_END 
272f 28 4d			jr z, .udone 
2731 fe 01			cp WORD_SYS_UWORD 
2733 20 44			jr nz, .nuword 
2735			 
2735			if DEBUG_FORTH_WORDS 
2735				DMARK "UWu" 
2735 f5				push af  
2736 3a 4a 27			ld a, (.dmark)  
2739 32 6b ee			ld (debug_mark),a  
273c 3a 4b 27			ld a, (.dmark+1)  
273f 32 6c ee			ld (debug_mark+1),a  
2742 3a 4c 27			ld a, (.dmark+2)  
2745 32 6d ee			ld (debug_mark+2),a  
2748 18 03			jr .pastdmark  
274a ..			.dmark: db "UWu"  
274d f1			.pastdmark: pop af  
274e			endm  
# End of macro DMARK
274e				CALLMONITOR 
274e cd 6f ee			call debug_vector  
2751				endm  
# End of macro CALLMONITOR
2751			endif 
2751				; we have a uword so push its name to the stack 
2751			 
2751 e5				push hl  ; save so we can move to next dict block 
2752			 
2752				; skip opcode 
2752 23				inc hl  
2753				; skip next ptr 
2753 23				inc hl  
2754 23				inc hl 
2755				; skip len 
2755 23				inc hl 
2756			if DEBUG_FORTH_WORDS 
2756				DMARK "UWt" 
2756 f5				push af  
2757 3a 6b 27			ld a, (.dmark)  
275a 32 6b ee			ld (debug_mark),a  
275d 3a 6c 27			ld a, (.dmark+1)  
2760 32 6c ee			ld (debug_mark+1),a  
2763 3a 6d 27			ld a, (.dmark+2)  
2766 32 6d ee			ld (debug_mark+2),a  
2769 18 03			jr .pastdmark  
276b ..			.dmark: db "UWt"  
276e f1			.pastdmark: pop af  
276f			endm  
# End of macro DMARK
276f				CALLMONITOR 
276f cd 6f ee			call debug_vector  
2772				endm  
# End of macro CALLMONITOR
2772			endif 
2772 03				inc bc 
2773			 
2773 c5				push bc 
2774 cd 19 1c			call forth_push_str 
2777 c1				pop bc 
2778			 
2778 e1				pop hl 	 
2779			 
2779 cd a9 20		.nuword:	call forth_tok_next 
277c 18 92			jr .douscan  
277e			 
277e			.udone:		 ; push count of uwords found 
277e c5				push bc 
277f e1				pop hl 
2780			 
2780			if DEBUG_FORTH_WORDS 
2780				DMARK "UWc" 
2780 f5				push af  
2781 3a 95 27			ld a, (.dmark)  
2784 32 6b ee			ld (debug_mark),a  
2787 3a 96 27			ld a, (.dmark+1)  
278a 32 6c ee			ld (debug_mark+1),a  
278d 3a 97 27			ld a, (.dmark+2)  
2790 32 6d ee			ld (debug_mark+2),a  
2793 18 03			jr .pastdmark  
2795 ..			.dmark: db "UWc"  
2798 f1			.pastdmark: pop af  
2799			endm  
# End of macro DMARK
2799				CALLMONITOR 
2799 cd 6f ee			call debug_vector  
279c				endm  
# End of macro CALLMONITOR
279c			endif 
279c cd ab 1b			call forth_push_numhl 
279f			 
279f			 
279f			       NEXTW 
279f c3 58 1f			jp macro_next 
27a2				endm 
# End of macro NEXTW
27a2			 
27a2			.BP: 
27a2			CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
27a2 54				db WORD_SYS_CORE+64             
27a3 dc 27			dw .MONITOR            
27a5 03				db 2 + 1 
27a6 .. 00			db "BP",0              
27a9				endm 
# End of macro CWHEAD
27a9			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
27a9			; | | $00 Will enable the break points within specific code paths 
27a9			; | | $01 Will disable break points 
27a9			; | |  
27a9			; | | By default break points are off. Either the above can be used to enable them 
27a9			; | | or if a key is held down during start up the spashscreen will appear to freeze 
27a9			; | | and on release of the pressed key the CONFIG menu will be displayed where you 
27a9			; | | can disable break points. Exiting will then continue boot process. 
27a9				; get byte count 
27a9				if DEBUG_FORTH_WORDS_KEY 
27a9					DMARK "BP." 
27a9 f5				push af  
27aa 3a be 27			ld a, (.dmark)  
27ad 32 6b ee			ld (debug_mark),a  
27b0 3a bf 27			ld a, (.dmark+1)  
27b3 32 6c ee			ld (debug_mark+1),a  
27b6 3a c0 27			ld a, (.dmark+2)  
27b9 32 6d ee			ld (debug_mark+2),a  
27bc 18 03			jr .pastdmark  
27be ..			.dmark: db "BP."  
27c1 f1			.pastdmark: pop af  
27c2			endm  
# End of macro DMARK
27c2					CALLMONITOR 
27c2 cd 6f ee			call debug_vector  
27c5				endm  
# End of macro CALLMONITOR
27c5				endif 
27c5			 
27c5				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
27c5 cd a2 1d			call macro_dsp_valuehl 
27c8				endm 
# End of macro FORTH_DSP_VALUEHL
27c8			 
27c8			;		push hl 
27c8			 
27c8				; destroy value TOS 
27c8			 
27c8				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
27c8 cd 5a 1e			call macro_forth_dsp_pop 
27cb				endm 
# End of macro FORTH_DSP_POP
27cb			 
27cb			;		pop hl 
27cb			 
27cb 3e 00			ld a,0 
27cd bd				cp l 
27ce 28 06			jr z, .bpset 
27d0			;		ld a, '*' 
27d0 cd 4d 15			call bp_off 
27d3				NEXTW 
27d3 c3 58 1f			jp macro_next 
27d6				endm 
# End of macro NEXTW
27d6			 
27d6			.bpset:	 
27d6				;	ld (os_view_disable), a 
27d6 cd 41 15			call bp_on 
27d9			 
27d9			 
27d9				NEXTW 
27d9 c3 58 1f			jp macro_next 
27dc				endm 
# End of macro NEXTW
27dc			 
27dc			 
27dc			.MONITOR: 
27dc			CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
27dc 55				db WORD_SYS_CORE+65             
27dd 0d 28			dw .MALLOC            
27df 08				db 7 + 1 
27e0 .. 00			db "MONITOR",0              
27e8				endm 
# End of macro CWHEAD
27e8			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
27e8			; | | At start the current various registers will be displayed with contents. 
27e8			; | | Top right corner will show the most recent debug marker seen. 
27e8			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
27e8			; | | and the return stack pointer (RSP). 
27e8			; | | Pressing: 
27e8			; | |    1 - Initial screen 
27e8			; | |    2 - Display a data dump of HL 
27e8			; | |    3 - Display a data dump of DE 
27e8			; | |    4 - Display a data dump of BC 
27e8			; | |    5 - Display a data dump of HL 
27e8			; | |    6 - Display a data dump of DSP 
27e8			; | |    7 - Display a data dump of RSP 
27e8			; | |    8 - Display a data dump of what is at DSP 
27e8			; | |    9 - Display a data dump of what is at RSP 
27e8			; | |    0 - Exit monitor and continue running. This will also enable break points 
27e8			; | |    * - Disable break points 
27e8			; | |    # - Enter traditional monitor mode 
27e8			; | | 
27e8			; | | Monitor Mode 
27e8			; | | ------------ 
27e8			; | | A prompt of '>' will be shown for various commands: 
27e8			; | |    D xxxx - Display a data dump starting from hex address xxxx 
27e8			; | |    C - Continue display a data dump from the last set address 
27e8			; | |    M xxxx - Set start of memory edit at address xx 
27e8			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
27e8			; | |    G xxxx - Exec code at specific address 
27e8			; | |    Q - Return to previous 
27e8				if DEBUG_FORTH_WORDS_KEY 
27e8					DMARK "MON" 
27e8 f5				push af  
27e9 3a fd 27			ld a, (.dmark)  
27ec 32 6b ee			ld (debug_mark),a  
27ef 3a fe 27			ld a, (.dmark+1)  
27f2 32 6c ee			ld (debug_mark+1),a  
27f5 3a ff 27			ld a, (.dmark+2)  
27f8 32 6d ee			ld (debug_mark+2),a  
27fb 18 03			jr .pastdmark  
27fd ..			.dmark: db "MON"  
2800 f1			.pastdmark: pop af  
2801			endm  
# End of macro DMARK
2801					CALLMONITOR 
2801 cd 6f ee			call debug_vector  
2804				endm  
# End of macro CALLMONITOR
2804				endif 
2804			;		ld a, 0 
2804			;		ld (os_view_disable), a 
2804 cd 41 15			call bp_on 
2807			 
2807				CALLMONITOR 
2807 cd 6f ee			call debug_vector  
280a				endm  
# End of macro CALLMONITOR
280a			 
280a			;	call monitor 
280a			 
280a				NEXTW 
280a c3 58 1f			jp macro_next 
280d				endm 
# End of macro NEXTW
280d			 
280d			 
280d			.MALLOC: 
280d			CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
280d 56				db WORD_SYS_CORE+66             
280e 36 28			dw .MALLOC2            
2810 06				db 5 + 1 
2811 .. 00			db "ALLOT",0              
2817				endm 
# End of macro CWHEAD
2817			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2817				if DEBUG_FORTH_WORDS_KEY 
2817					DMARK "ALL" 
2817 f5				push af  
2818 3a 2c 28			ld a, (.dmark)  
281b 32 6b ee			ld (debug_mark),a  
281e 3a 2d 28			ld a, (.dmark+1)  
2821 32 6c ee			ld (debug_mark+1),a  
2824 3a 2e 28			ld a, (.dmark+2)  
2827 32 6d ee			ld (debug_mark+2),a  
282a 18 03			jr .pastdmark  
282c ..			.dmark: db "ALL"  
282f f1			.pastdmark: pop af  
2830			endm  
# End of macro DMARK
2830					CALLMONITOR 
2830 cd 6f ee			call debug_vector  
2833				endm  
# End of macro CALLMONITOR
2833				endif 
2833 c3 5d 28			jp .mallocc 
2836			.MALLOC2: 
2836			CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2836 56				db WORD_SYS_CORE+66             
2837 74 28			dw .FREE            
2839 07				db 6 + 1 
283a .. 00			db "MALLOC",0              
2841				endm 
# End of macro CWHEAD
2841			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2841				; get byte count 
2841				if DEBUG_FORTH_WORDS_KEY 
2841					DMARK "MAL" 
2841 f5				push af  
2842 3a 56 28			ld a, (.dmark)  
2845 32 6b ee			ld (debug_mark),a  
2848 3a 57 28			ld a, (.dmark+1)  
284b 32 6c ee			ld (debug_mark+1),a  
284e 3a 58 28			ld a, (.dmark+2)  
2851 32 6d ee			ld (debug_mark+2),a  
2854 18 03			jr .pastdmark  
2856 ..			.dmark: db "MAL"  
2859 f1			.pastdmark: pop af  
285a			endm  
# End of macro DMARK
285a					CALLMONITOR 
285a cd 6f ee			call debug_vector  
285d				endm  
# End of macro CALLMONITOR
285d				endif 
285d			.mallocc: 
285d				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
285d cd a2 1d			call macro_dsp_valuehl 
2860				endm 
# End of macro FORTH_DSP_VALUEHL
2860			 
2860			;		push hl 
2860			 
2860				; destroy value TOS 
2860			 
2860				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2860 cd 5a 1e			call macro_forth_dsp_pop 
2863				endm 
# End of macro FORTH_DSP_POP
2863			 
2863			;		pop hl 
2863 cd 12 12			call malloc 
2866			if DEBUG_FORTH_MALLOC_GUARD 
2866 f5				push af 
2867 cd 0f 0e			call ishlzero 
286a			;		ld a, l 
286a			;		add h 
286a			;		cp 0 
286a f1				pop af 
286b				 
286b cc 18 4d			call z,malloc_error 
286e			endif 
286e			 
286e cd ab 1b			call forth_push_numhl 
2871				NEXTW 
2871 c3 58 1f			jp macro_next 
2874				endm 
# End of macro NEXTW
2874			 
2874			.FREE: 
2874			CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2874 57				db WORD_SYS_CORE+67             
2875 a5 28			dw .LIST            
2877 05				db 4 + 1 
2878 .. 00			db "FREE",0              
287d				endm 
# End of macro CWHEAD
287d			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
287d				if DEBUG_FORTH_WORDS_KEY 
287d					DMARK "FRE" 
287d f5				push af  
287e 3a 92 28			ld a, (.dmark)  
2881 32 6b ee			ld (debug_mark),a  
2884 3a 93 28			ld a, (.dmark+1)  
2887 32 6c ee			ld (debug_mark+1),a  
288a 3a 94 28			ld a, (.dmark+2)  
288d 32 6d ee			ld (debug_mark+2),a  
2890 18 03			jr .pastdmark  
2892 ..			.dmark: db "FRE"  
2895 f1			.pastdmark: pop af  
2896			endm  
# End of macro DMARK
2896					CALLMONITOR 
2896 cd 6f ee			call debug_vector  
2899				endm  
# End of macro CALLMONITOR
2899				endif 
2899				; get address 
2899			 
2899				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2899 cd a2 1d			call macro_dsp_valuehl 
289c				endm 
# End of macro FORTH_DSP_VALUEHL
289c			 
289c			;		push hl 
289c			 
289c				; destroy value TOS 
289c			 
289c				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
289c cd 5a 1e			call macro_forth_dsp_pop 
289f				endm 
# End of macro FORTH_DSP_POP
289f			 
289f			;		pop hl 
289f			if FORTH_ENABLE_MALLOCFREE 
289f cd dc 12			call free 
28a2			endif 
28a2				NEXTW 
28a2 c3 58 1f			jp macro_next 
28a5				endm 
# End of macro NEXTW
28a5			.LIST: 
28a5			CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
28a5 5c				db WORD_SYS_CORE+72             
28a6 95 2a			dw .FORGET            
28a8 05				db 4 + 1 
28a9 .. 00			db "LIST",0              
28ae				endm 
# End of macro CWHEAD
28ae			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
28ae			; | | The quoted word must be in upper case. 
28ae			if DEBUG_FORTH_WORDS_KEY 
28ae				DMARK "LST" 
28ae f5				push af  
28af 3a c3 28			ld a, (.dmark)  
28b2 32 6b ee			ld (debug_mark),a  
28b5 3a c4 28			ld a, (.dmark+1)  
28b8 32 6c ee			ld (debug_mark+1),a  
28bb 3a c5 28			ld a, (.dmark+2)  
28be 32 6d ee			ld (debug_mark+2),a  
28c1 18 03			jr .pastdmark  
28c3 ..			.dmark: db "LST"  
28c6 f1			.pastdmark: pop af  
28c7			endm  
# End of macro DMARK
28c7				CALLMONITOR 
28c7 cd 6f ee			call debug_vector  
28ca				endm  
# End of macro CALLMONITOR
28ca			endif 
28ca			 
28ca				FORTH_DSP_VALUEHL 
28ca cd a2 1d			call macro_dsp_valuehl 
28cd				endm 
# End of macro FORTH_DSP_VALUEHL
28cd			 
28cd e5				push hl 
28ce				FORTH_DSP_POP 
28ce cd 5a 1e			call macro_forth_dsp_pop 
28d1				endm 
# End of macro FORTH_DSP_POP
28d1 c1				pop bc 
28d2			 
28d2			; Start format of scratch string 
28d2			 
28d2 21 c1 e2			ld hl, scratch 
28d5			 
28d5 3e 3a			ld a, ':' 
28d7 77				ld (hl),a 
28d8 23				inc hl 
28d9 3e 20			ld a, ' ' 
28db 77				ld (hl), a 
28dc			 
28dc				; Get ptr to the word we need to look up 
28dc			 
28dc			;		FORTH_DSP_VALUEHL 
28dc				;v5 FORTH_DSP_VALUE 
28dc			; TODO type check 
28dc			;		inc hl    ; Skip type check  
28dc			;		push hl 
28dc			;		ex de, hl    ; put into DE 
28dc			 
28dc			 
28dc 21 a0 65			ld hl, baseram 
28df				;ld hl, baseusermem 
28df			 
28df e5			push hl   ; sacreifical push 
28e0			 
28e0			.ldouscanm: 
28e0 e1			pop hl 
28e1			.ldouscan: 
28e1			if DEBUG_FORTH_WORDS 
28e1				DMARK "LSs" 
28e1 f5				push af  
28e2 3a f6 28			ld a, (.dmark)  
28e5 32 6b ee			ld (debug_mark),a  
28e8 3a f7 28			ld a, (.dmark+1)  
28eb 32 6c ee			ld (debug_mark+1),a  
28ee 3a f8 28			ld a, (.dmark+2)  
28f1 32 6d ee			ld (debug_mark+2),a  
28f4 18 03			jr .pastdmark  
28f6 ..			.dmark: db "LSs"  
28f9 f1			.pastdmark: pop af  
28fa			endm  
# End of macro DMARK
28fa				CALLMONITOR 
28fa cd 6f ee			call debug_vector  
28fd				endm  
# End of macro CALLMONITOR
28fd			endif 
28fd			; skip dict stub 
28fd cd a9 20			call forth_tok_next 
2900			 
2900			 
2900			; while we have words to look for 
2900			 
2900 7e			ld a, (hl)      
2901			if DEBUG_FORTH_WORDS 
2901				DMARK "LSk" 
2901 f5				push af  
2902 3a 16 29			ld a, (.dmark)  
2905 32 6b ee			ld (debug_mark),a  
2908 3a 17 29			ld a, (.dmark+1)  
290b 32 6c ee			ld (debug_mark+1),a  
290e 3a 18 29			ld a, (.dmark+2)  
2911 32 6d ee			ld (debug_mark+2),a  
2914 18 03			jr .pastdmark  
2916 ..			.dmark: db "LSk"  
2919 f1			.pastdmark: pop af  
291a			endm  
# End of macro DMARK
291a				CALLMONITOR 
291a cd 6f ee			call debug_vector  
291d				endm  
# End of macro CALLMONITOR
291d			endif 
291d				;cp WORD_SYS_END 
291d				;jp z, .lunotfound 
291d			 
291d					; if we hit non uwords then gone too far 
291d fe 01				cp WORD_SYS_UWORD 
291f c2 51 2a				jp nz, .lunotfound 
2922			 
2922				if DEBUG_FORTH_WORDS 
2922					DMARK "LSu" 
2922 f5				push af  
2923 3a 37 29			ld a, (.dmark)  
2926 32 6b ee			ld (debug_mark),a  
2929 3a 38 29			ld a, (.dmark+1)  
292c 32 6c ee			ld (debug_mark+1),a  
292f 3a 39 29			ld a, (.dmark+2)  
2932 32 6d ee			ld (debug_mark+2),a  
2935 18 03			jr .pastdmark  
2937 ..			.dmark: db "LSu"  
293a f1			.pastdmark: pop af  
293b			endm  
# End of macro DMARK
293b					CALLMONITOR 
293b cd 6f ee			call debug_vector  
293e				endm  
# End of macro CALLMONITOR
293e				endif 
293e			 
293e					; found a uword but is it the one we want... 
293e			 
293e c5					push bc     ; uword to find is on bc 
293f d1					pop de 
2940			 
2940 e5					push hl  ; to save the ptr 
2941			 
2941					; skip opcode 
2941 23					inc hl  
2942					; skip next ptr 
2942 23					inc hl  
2943 23					inc hl 
2944					; skip len 
2944 23					inc hl 
2945			 
2945				if DEBUG_FORTH_WORDS 
2945					DMARK "LSc" 
2945 f5				push af  
2946 3a 5a 29			ld a, (.dmark)  
2949 32 6b ee			ld (debug_mark),a  
294c 3a 5b 29			ld a, (.dmark+1)  
294f 32 6c ee			ld (debug_mark+1),a  
2952 3a 5c 29			ld a, (.dmark+2)  
2955 32 6d ee			ld (debug_mark+2),a  
2958 18 03			jr .pastdmark  
295a ..			.dmark: db "LSc"  
295d f1			.pastdmark: pop af  
295e			endm  
# End of macro DMARK
295e					CALLMONITOR 
295e cd 6f ee			call debug_vector  
2961				endm  
# End of macro CALLMONITOR
2961				endif 
2961			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
2961			; ie. If WOO is defined first and then WO. Couldnt list WO. 
2961			; Nope that has gone the other way. It needs to be exact not on first zero 
2961			;		call strcmp 
2961 c5					push bc 
2962 cd e2 11				call StrictStrCmp 
2965 c1					pop bc 
2966 c2 e0 28				jp nz, .ldouscanm 
2969				 
2969			 
2969			 
2969					; we have a uword so push its name to the stack 
2969			 
2969			;	   	push hl  ; save so we can move to next dict block 
2969 e1			pop hl 
296a			 
296a				if DEBUG_FORTH_WORDS 
296a					DMARK "LSm" 
296a f5				push af  
296b 3a 7f 29			ld a, (.dmark)  
296e 32 6b ee			ld (debug_mark),a  
2971 3a 80 29			ld a, (.dmark+1)  
2974 32 6c ee			ld (debug_mark+1),a  
2977 3a 81 29			ld a, (.dmark+2)  
297a 32 6d ee			ld (debug_mark+2),a  
297d 18 03			jr .pastdmark  
297f ..			.dmark: db "LSm"  
2982 f1			.pastdmark: pop af  
2983			endm  
# End of macro DMARK
2983					CALLMONITOR 
2983 cd 6f ee			call debug_vector  
2986				endm  
# End of macro CALLMONITOR
2986				endif 
2986			 
2986					; skip opcode 
2986 23					inc hl  
2987					; skip next ptr 
2987 23					inc hl  
2988 23					inc hl 
2989					; skip len 
2989 7e					ld a, (hl)   ; save length to add 
298a				if DEBUG_FORTH_WORDS 
298a					DMARK "LS2" 
298a f5				push af  
298b 3a 9f 29			ld a, (.dmark)  
298e 32 6b ee			ld (debug_mark),a  
2991 3a a0 29			ld a, (.dmark+1)  
2994 32 6c ee			ld (debug_mark+1),a  
2997 3a a1 29			ld a, (.dmark+2)  
299a 32 6d ee			ld (debug_mark+2),a  
299d 18 03			jr .pastdmark  
299f ..			.dmark: db "LS2"  
29a2 f1			.pastdmark: pop af  
29a3			endm  
# End of macro DMARK
29a3					CALLMONITOR 
29a3 cd 6f ee			call debug_vector  
29a6				endm  
# End of macro CALLMONITOR
29a6				endif 
29a6			 
29a6					; save this location 
29a6				 
29a6 e5					push hl 
29a7			 
29a7 23					inc hl 
29a8 11 c3 e2				ld de, scratch+2 
29ab 4f					ld c, a 
29ac 06 00				ld b, 0 
29ae			 
29ae				if DEBUG_FORTH_WORDS 
29ae					DMARK "LSn" 
29ae f5				push af  
29af 3a c3 29			ld a, (.dmark)  
29b2 32 6b ee			ld (debug_mark),a  
29b5 3a c4 29			ld a, (.dmark+1)  
29b8 32 6c ee			ld (debug_mark+1),a  
29bb 3a c5 29			ld a, (.dmark+2)  
29be 32 6d ee			ld (debug_mark+2),a  
29c1 18 03			jr .pastdmark  
29c3 ..			.dmark: db "LSn"  
29c6 f1			.pastdmark: pop af  
29c7			endm  
# End of macro DMARK
29c7					CALLMONITOR 
29c7 cd 6f ee			call debug_vector  
29ca				endm  
# End of macro CALLMONITOR
29ca				endif 
29ca			 
29ca					; copy uword name to scratch 
29ca			 
29ca ed b0				ldir 
29cc			 
29cc 1b					dec de 
29cd 3e 20				ld a, ' '    ; change null to space 
29cf 12					ld (de), a 
29d0			 
29d0 13					inc de 
29d1			 
29d1 d5					push de 
29d2 c1					pop bc     ; move scratch pointer to end of word name and save it 
29d3			 
29d3 e1					pop hl 
29d4 7e					ld a, (hl) 
29d5					;inc hl 
29d5					; skip word string 
29d5 cd e6 0d				call addatohl 
29d8			 
29d8 23					inc hl 
29d9			 
29d9				if DEBUG_FORTH_WORDS 
29d9					DMARK "LS3" 
29d9 f5				push af  
29da 3a ee 29			ld a, (.dmark)  
29dd 32 6b ee			ld (debug_mark),a  
29e0 3a ef 29			ld a, (.dmark+1)  
29e3 32 6c ee			ld (debug_mark+1),a  
29e6 3a f0 29			ld a, (.dmark+2)  
29e9 32 6d ee			ld (debug_mark+2),a  
29ec 18 03			jr .pastdmark  
29ee ..			.dmark: db "LS3"  
29f1 f1			.pastdmark: pop af  
29f2			endm  
# End of macro DMARK
29f2					CALLMONITOR 
29f2 cd 6f ee			call debug_vector  
29f5				endm  
# End of macro CALLMONITOR
29f5				endif 
29f5					; should now be at the start of the machine code to setup the eval of the uword 
29f5					; now locate the ptr to the string defintion 
29f5			 
29f5					; skip ld hl, 
29f5					; then load the ptr 
29f5			; TODO use get from hl ptr 
29f5 23					inc hl 
29f6 5e					ld e, (hl) 
29f7 23					inc hl 
29f8 56					ld d, (hl) 
29f9 eb					ex de, hl 
29fa			 
29fa			 
29fa				if DEBUG_FORTH_WORDS 
29fa					DMARK "LSt" 
29fa f5				push af  
29fb 3a 0f 2a			ld a, (.dmark)  
29fe 32 6b ee			ld (debug_mark),a  
2a01 3a 10 2a			ld a, (.dmark+1)  
2a04 32 6c ee			ld (debug_mark+1),a  
2a07 3a 11 2a			ld a, (.dmark+2)  
2a0a 32 6d ee			ld (debug_mark+2),a  
2a0d 18 03			jr .pastdmark  
2a0f ..			.dmark: db "LSt"  
2a12 f1			.pastdmark: pop af  
2a13			endm  
# End of macro DMARK
2a13					CALLMONITOR 
2a13 cd 6f ee			call debug_vector  
2a16				endm  
# End of macro CALLMONITOR
2a16				endif 
2a16			 
2a16			; cant push right now due to tokenised strings  
2a16			 
2a16			; get the destination of where to copy this definition to. 
2a16			 
2a16 c5					push bc 
2a17 d1					pop de 
2a18			 
2a18 7e			.listl:         ld a,(hl) 
2a19 fe 00				cp 0 
2a1b 28 09				jr z, .lreplsp     ; replace zero with space 
2a1d					;cp FORTH_END_BUFFER 
2a1d fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2a1f 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2a21				 
2a21					; just copy this char as is then 
2a21			 
2a21 12					ld (de), a 
2a22			 
2a22 23			.listnxt:	inc hl 
2a23 13					inc de 
2a24 18 f2				jr .listl 
2a26			 
2a26 3e 20		.lreplsp:	ld a,' ' 
2a28 12					ld (de), a 
2a29 18 f7				jr .listnxt 
2a2b			 
2a2b			; close up uword def 
2a2b			 
2a2b			.listdone: 
2a2b 12					ld (de), a 
2a2c 13					inc de 
2a2d 3e 00				ld a, 0 
2a2f 12					ld (de), a 
2a30			 
2a30			; now have def so clean up and push to stack 
2a30			 
2a30 21 c1 e2				ld hl, scratch 
2a33				if DEBUG_FORTH_WORDS 
2a33					DMARK "Ltp" 
2a33 f5				push af  
2a34 3a 48 2a			ld a, (.dmark)  
2a37 32 6b ee			ld (debug_mark),a  
2a3a 3a 49 2a			ld a, (.dmark+1)  
2a3d 32 6c ee			ld (debug_mark+1),a  
2a40 3a 4a 2a			ld a, (.dmark+2)  
2a43 32 6d ee			ld (debug_mark+2),a  
2a46 18 03			jr .pastdmark  
2a48 ..			.dmark: db "Ltp"  
2a4b f1			.pastdmark: pop af  
2a4c			endm  
# End of macro DMARK
2a4c					CALLMONITOR 
2a4c cd 6f ee			call debug_vector  
2a4f				endm  
# End of macro CALLMONITOR
2a4f				endif 
2a4f			 
2a4f 18 1f			jr .listpush 
2a51			 
2a51			;.lnuword:	pop hl 
2a51			;		call forth_tok_next 
2a51			;		jp .ldouscan  
2a51			 
2a51			.lunotfound:		  
2a51			 
2a51				if DEBUG_FORTH_WORDS 
2a51					DMARK "LSn" 
2a51 f5				push af  
2a52 3a 66 2a			ld a, (.dmark)  
2a55 32 6b ee			ld (debug_mark),a  
2a58 3a 67 2a			ld a, (.dmark+1)  
2a5b 32 6c ee			ld (debug_mark+1),a  
2a5e 3a 68 2a			ld a, (.dmark+2)  
2a61 32 6d ee			ld (debug_mark+2),a  
2a64 18 03			jr .pastdmark  
2a66 ..			.dmark: db "LSn"  
2a69 f1			.pastdmark: pop af  
2a6a			endm  
# End of macro DMARK
2a6a					CALLMONITOR 
2a6a cd 6f ee			call debug_vector  
2a6d				endm  
# End of macro CALLMONITOR
2a6d				endif 
2a6d			 
2a6d					 
2a6d			;		FORTH_DSP_POP 
2a6d			;		ld hl, .luno 
2a6d			 
2a6d					NEXTW			 
2a6d c3 58 1f			jp macro_next 
2a70				endm 
# End of macro NEXTW
2a70			 
2a70			.listpush: 
2a70				if DEBUG_FORTH_WORDS 
2a70					DMARK "LS>" 
2a70 f5				push af  
2a71 3a 85 2a			ld a, (.dmark)  
2a74 32 6b ee			ld (debug_mark),a  
2a77 3a 86 2a			ld a, (.dmark+1)  
2a7a 32 6c ee			ld (debug_mark+1),a  
2a7d 3a 87 2a			ld a, (.dmark+2)  
2a80 32 6d ee			ld (debug_mark+2),a  
2a83 18 03			jr .pastdmark  
2a85 ..			.dmark: db "LS>"  
2a88 f1			.pastdmark: pop af  
2a89			endm  
# End of macro DMARK
2a89					CALLMONITOR 
2a89 cd 6f ee			call debug_vector  
2a8c				endm  
# End of macro CALLMONITOR
2a8c				endif 
2a8c cd 19 1c				call forth_push_str 
2a8f			 
2a8f			 
2a8f			 
2a8f					NEXTW 
2a8f c3 58 1f			jp macro_next 
2a92				endm 
# End of macro NEXTW
2a92			 
2a92			;.luno:    db "Word not found",0 
2a92			 
2a92			 
2a92			 
2a92			 
2a92			 
2a92			;		push hl   ; save pointer to start of uword def string 
2a92			; 
2a92			;; look for FORTH_EOL_LINE 
2a92			;		ld a, FORTH_END_BUFFER 
2a92			;		call strlent 
2a92			; 
2a92			;		inc hl		 ; space for coln def 
2a92			;		inc hl 
2a92			;		inc hl          ; space for terms 
2a92			;		inc hl 
2a92			; 
2a92			;		ld a, 20   ; TODO get actual length 
2a92			;		call addatohl    ; include a random amount of room for the uword name 
2a92			; 
2a92			;		 
2a92			;	if DEBUG_FORTH_WORDS 
2a92			;		DMARK "Lt1" 
2a92			;		CALLMONITOR 
2a92			;	endif 
2a92			;		 
2a92			; 
2a92			;; malloc space for the string because we cant change it 
2a92			; 
2a92			;		call malloc 
2a92			;	if DEBUG_FORTH_MALLOC_GUARD 
2a92			;		push af 
2a92			;		call ishlzero 
2a92			;		pop af 
2a92			;		 
2a92			;		call z,malloc_error 
2a92			;	endif 
2a92			; 
2a92			;	if DEBUG_FORTH_WORDS 
2a92			;		DMARK "Lt2" 
2a92			;		CALLMONITOR 
2a92			;	endif 
2a92			;		pop de 
2a92			;		push hl    ; push the malloc to release later 
2a92			;		push hl   ;  push back a copy for the later stack push 
2a92			;		 
2a92			;; copy the string swapping out the zero terms for spaces 
2a92			; 
2a92			;		; de has our source 
2a92			;		; hl has our dest 
2a92			; 
2a92			;; add the coln def 
2a92			; 
2a92			;		ld a, ':' 
2a92			;		ld (hl), a 
2a92			;		inc hl 
2a92			;		ld a, ' ' 
2a92			;		ld (hl), a 
2a92			;		inc hl 
2a92			; 
2a92			;; add the uname word 
2a92			;		push de   ; save our string for now 
2a92			;		ex de, hl 
2a92			; 
2a92			;		FORTH_DSP_VALUE 
2a92			;		;v5 FORTH_DSP_VALUE 
2a92			; 
2a92			;		inc hl   ; skip type but we know by now this is OK 
2a92			; 
2a92			;.luword:	ld a,(hl) 
2a92			;		cp 0 
2a92			;		jr z, .luword2 
2a92			;		ld (de), a 
2a92			;		inc de 
2a92			;		inc hl 
2a92			;		jr .luword 
2a92			; 
2a92			;.luword2:	ld a, ' ' 
2a92			;		ld (de), a 
2a92			;;		inc hl 
2a92			;;		inc de 
2a92			;;		ld (de), a 
2a92			;;		inc hl 
2a92			;		inc de 
2a92			; 
2a92			;		ex de, hl 
2a92			;		pop de 
2a92			;		 
2a92			;		 
2a92			; 
2a92			;; detoken that string and copy it 
2a92			; 
2a92			;	if DEBUG_FORTH_WORDS 
2a92			;		DMARK "Lt2" 
2a92			;		CALLMONITOR 
2a92			;	endif 
2a92			;.ldetok:	ld a, (de) 
2a92			;		cp FORTH_END_BUFFER 
2a92			;		jr z, .ldetokend 
2a92			;		; swap out any zero term for space 
2a92			;		cp 0 
2a92			;		jr nz, .ldetoknext 
2a92			;		ld a, ' ' 
2a92			; 
2a92			;	if DEBUG_FORTH_WORDS 
2a92			;		DMARK "LtS" 
2a92			;		CALLMONITOR 
2a92			;	endif 
2a92			;.ldetoknext:	ld (hl), a 
2a92			;		inc de 
2a92			;		inc hl 
2a92			;		jr .ldetok 
2a92			; 
2a92			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2a92			;		ld (hl), a  
2a92			; 
2a92			;; free that temp malloc 
2a92			; 
2a92			;		pop hl    
2a92			; 
2a92			;	if DEBUG_FORTH_WORDS 
2a92			;		DMARK "Lt4" 
2a92			;		CALLMONITOR 
2a92			;	endif 
2a92			;		call forth_apushstrhl 
2a92			; 
2a92			;		; get rid of temp malloc area 
2a92			; 
2a92			;		pop hl 
2a92			;		call free 
2a92			; 
2a92			;		jr .ludone 
2a92			; 
2a92			;.lnuword:	pop hl 
2a92			;		call forth_tok_next 
2a92			;		jp .ldouscan  
2a92			; 
2a92			;.ludone:		 pop hl 
2a92			; 
2a92					NEXTW 
2a92 c3 58 1f			jp macro_next 
2a95				endm 
# End of macro NEXTW
2a95			 
2a95			.FORGET: 
2a95				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2a95 5d				db WORD_SYS_CORE+73             
2a96 0e 2b			dw .NOP            
2a98 07				db 6 + 1 
2a99 .. 00			db "FORGET",0              
2aa0				endm 
# End of macro CWHEAD
2aa0			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2aa0			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quoted uword name must be in caps. 
2aa0			; | |  
2aa0			; | | e.g. "MORE" forget 
2aa0					if DEBUG_FORTH_WORDS_KEY 
2aa0						DMARK "FRG" 
2aa0 f5				push af  
2aa1 3a b5 2a			ld a, (.dmark)  
2aa4 32 6b ee			ld (debug_mark),a  
2aa7 3a b6 2a			ld a, (.dmark+1)  
2aaa 32 6c ee			ld (debug_mark+1),a  
2aad 3a b7 2a			ld a, (.dmark+2)  
2ab0 32 6d ee			ld (debug_mark+2),a  
2ab3 18 03			jr .pastdmark  
2ab5 ..			.dmark: db "FRG"  
2ab8 f1			.pastdmark: pop af  
2ab9			endm  
# End of macro DMARK
2ab9						CALLMONITOR 
2ab9 cd 6f ee			call debug_vector  
2abc				endm  
# End of macro CALLMONITOR
2abc					endif 
2abc			 
2abc				; find uword 
2abc			        ; update start of word with "_" 
2abc				; replace uword with deleted flag 
2abc			 
2abc			 
2abc			;	if DEBUG_FORTH_WORDS 
2abc			;		DMARK "FOG" 
2abc			;		CALLMONITOR 
2abc			;	endif 
2abc			 
2abc			 
2abc					; Get ptr to the word we need to look up 
2abc			 
2abc					FORTH_DSP_VALUEHL 
2abc cd a2 1d			call macro_dsp_valuehl 
2abf				endm 
# End of macro FORTH_DSP_VALUEHL
2abf					;v5 FORTH_DSP_VALUE 
2abf				; TODO type check 
2abf			;		inc hl    ; Skip type check  
2abf e5					push hl 
2ac0 c1					pop bc 
2ac1			;		ex de, hl    ; put into DE 
2ac1			 
2ac1			 
2ac1 21 a0 65				ld hl, baseram 
2ac4					;ld hl, baseusermem 
2ac4			 
2ac4				; skip dict stub 
2ac4			;	call forth_tok_next 
2ac4 e5			push hl   ; sacreifical push 
2ac5			 
2ac5			.fldouscanm: 
2ac5 e1				pop hl 
2ac6			.fldouscan: 
2ac6			;	if DEBUG_FORTH_WORDS 
2ac6			;		DMARK "LSs" 
2ac6			;		CALLMONITOR 
2ac6			;	endif 
2ac6				; skip dict stub 
2ac6 cd a9 20				call forth_tok_next 
2ac9			 
2ac9			 
2ac9			; while we have words to look for 
2ac9			 
2ac9 7e				ld a, (hl)      
2aca			;	if DEBUG_FORTH_WORDS 
2aca			;		DMARK "LSk" 
2aca			;		CALLMONITOR 
2aca			;	endif 
2aca fe 00				cp WORD_SYS_END 
2acc ca 08 2b				jp z, .flunotfound 
2acf fe 01				cp WORD_SYS_UWORD 
2ad1 c2 c6 2a				jp nz, .fldouscan 
2ad4			 
2ad4			;	if DEBUG_FORTH_WORDS 
2ad4			;		DMARK "LSu" 
2ad4			;		CALLMONITOR 
2ad4			;	endif 
2ad4			 
2ad4					; found a uword but is it the one we want... 
2ad4			 
2ad4 c5					push bc     ; uword to find is on bc 
2ad5 d1					pop de 
2ad6			 
2ad6 e5					push hl  ; to save the ptr 
2ad7			 
2ad7					; skip opcode 
2ad7 23					inc hl  
2ad8					; skip next ptr 
2ad8 23					inc hl  
2ad9 23					inc hl 
2ada					; skip len 
2ada 23					inc hl 
2adb			 
2adb			;	if DEBUG_FORTH_WORDS 
2adb			;		DMARK "LSc" 
2adb			;		CALLMONITOR 
2adb			;	endif 
2adb cd d5 11				call strcmp 
2ade c2 c5 2a				jp nz, .fldouscanm 
2ae1			; 
2ae1			; 
2ae1			;; while we have words to look for 
2ae1			; 
2ae1			;.fdouscan:	ld a, (hl)      
2ae1			;	if DEBUG_FORTH_WORDS 
2ae1			;		DMARK "LSs" 
2ae1			;		CALLMONITOR 
2ae1			;	endif 
2ae1			;		cp WORD_SYS_END 
2ae1			;		jp z, .fudone 
2ae1			;		cp WORD_SYS_UWORD 
2ae1			;		jp nz, .fnuword 
2ae1			; 
2ae1			;	if DEBUG_FORTH_WORDS 
2ae1			;		DMARK "FGu" 
2ae1			;		CALLMONITOR 
2ae1			;	endif 
2ae1			; 
2ae1			;		; found a uword but is it the one we want... 
2ae1			; 
2ae1			; 
2ae1			;	        pop de   ; get back the dsp name 
2ae1			;		push de 
2ae1			; 
2ae1			;		push hl  ; to save the ptr 
2ae1			; 
2ae1			;		; skip opcode 
2ae1			;		inc hl  
2ae1			;		; skip next ptr 
2ae1			;		inc hl  
2ae1			;		inc hl 
2ae1			;		; skip len 
2ae1			;		inc hl 
2ae1			; 
2ae1			;	if DEBUG_FORTH_WORDS 
2ae1			;		DMARK "FGc" 
2ae1			;		CALLMONITOR 
2ae1			;	endif 
2ae1			;		call strcmp 
2ae1			;		jp nz, .fnuword 
2ae1			 
2ae1			 
2ae1 e1			pop hl 
2ae2			 
2ae2				 
2ae2				if DEBUG_FORTH_WORDS 
2ae2					DMARK "FGm" 
2ae2 f5				push af  
2ae3 3a f7 2a			ld a, (.dmark)  
2ae6 32 6b ee			ld (debug_mark),a  
2ae9 3a f8 2a			ld a, (.dmark+1)  
2aec 32 6c ee			ld (debug_mark+1),a  
2aef 3a f9 2a			ld a, (.dmark+2)  
2af2 32 6d ee			ld (debug_mark+2),a  
2af5 18 03			jr .pastdmark  
2af7 ..			.dmark: db "FGm"  
2afa f1			.pastdmark: pop af  
2afb			endm  
# End of macro DMARK
2afb					CALLMONITOR 
2afb cd 6f ee			call debug_vector  
2afe				endm  
# End of macro CALLMONITOR
2afe				endif 
2afe			 
2afe			 
2afe			 
2afe					; we have a uword so push its name to the stack 
2afe			 
2afe			;	   	push hl  ; save so we can move to next dict block 
2afe			;pop hl 
2afe			 
2afe					; update opcode to deleted 
2afe 3e 03				ld a, WORD_SYS_DELETED 
2b00 77					ld (hl), a 
2b01			 
2b01 23					inc hl  
2b02					; skip next ptr 
2b02 23					inc hl  
2b03 23					inc hl 
2b04					; skip len 
2b04 23					inc hl 
2b05			 
2b05					; TODO change parser to skip deleted words but for now mark it out 
2b05 3e 5f				ld a, "_" 
2b07 77					ld  (hl),a 
2b08			 
2b08			;		jr .fudone 
2b08			; 
2b08			;.fnuword:	pop hl 
2b08			;		call forth_tok_next 
2b08			;		jp .fdouscan  
2b08			 
2b08			.flunotfound:		  
2b08			 
2b08			 
2b08					 
2b08					FORTH_DSP_POP 
2b08 cd 5a 1e			call macro_forth_dsp_pop 
2b0b				endm 
# End of macro FORTH_DSP_POP
2b0b			;		ld hl, .luno 
2b0b			;.fudone:		 pop hl 
2b0b					NEXTW 
2b0b c3 58 1f			jp macro_next 
2b0e				endm 
# End of macro NEXTW
2b0e			.NOP: 
2b0e				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2b0e 61				db WORD_SYS_CORE+77             
2b0f 35 2b			dw .COMO            
2b11 04				db 3 + 1 
2b12 .. 00			db "NOP",0              
2b16				endm 
# End of macro CWHEAD
2b16			; | NOP (  --  ) Do nothing | DONE 
2b16					if DEBUG_FORTH_WORDS_KEY 
2b16						DMARK "NOP" 
2b16 f5				push af  
2b17 3a 2b 2b			ld a, (.dmark)  
2b1a 32 6b ee			ld (debug_mark),a  
2b1d 3a 2c 2b			ld a, (.dmark+1)  
2b20 32 6c ee			ld (debug_mark+1),a  
2b23 3a 2d 2b			ld a, (.dmark+2)  
2b26 32 6d ee			ld (debug_mark+2),a  
2b29 18 03			jr .pastdmark  
2b2b ..			.dmark: db "NOP"  
2b2e f1			.pastdmark: pop af  
2b2f			endm  
# End of macro DMARK
2b2f						CALLMONITOR 
2b2f cd 6f ee			call debug_vector  
2b32				endm  
# End of macro CALLMONITOR
2b32					endif 
2b32				       NEXTW 
2b32 c3 58 1f			jp macro_next 
2b35				endm 
# End of macro NEXTW
2b35			.COMO: 
2b35				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2b35 6e				db WORD_SYS_CORE+90             
2b36 87 2b			dw .COMC            
2b38 02				db 1 + 1 
2b39 .. 00			db "(",0              
2b3b				endm 
# End of macro CWHEAD
2b3b			; | ( ( -- )  Start of comment | DONE 
2b3b			 
2b3b			 
2b3b 2a c2 e5				ld hl, ( os_tok_ptr) 
2b3e 11 82 2b			ld de, .closepar 
2b41					 
2b41					if DEBUG_FORTH_WORDS 
2b41						DMARK ").." 
2b41 f5				push af  
2b42 3a 56 2b			ld a, (.dmark)  
2b45 32 6b ee			ld (debug_mark),a  
2b48 3a 57 2b			ld a, (.dmark+1)  
2b4b 32 6c ee			ld (debug_mark+1),a  
2b4e 3a 58 2b			ld a, (.dmark+2)  
2b51 32 6d ee			ld (debug_mark+2),a  
2b54 18 03			jr .pastdmark  
2b56 ..			.dmark: db ").."  
2b59 f1			.pastdmark: pop af  
2b5a			endm  
# End of macro DMARK
2b5a						CALLMONITOR 
2b5a cd 6f ee			call debug_vector  
2b5d				endm  
# End of macro CALLMONITOR
2b5d					endif 
2b5d cd 73 20			call findnexttok  
2b60			 
2b60					if DEBUG_FORTH_WORDS 
2b60						DMARK "IF5" 
2b60 f5				push af  
2b61 3a 75 2b			ld a, (.dmark)  
2b64 32 6b ee			ld (debug_mark),a  
2b67 3a 76 2b			ld a, (.dmark+1)  
2b6a 32 6c ee			ld (debug_mark+1),a  
2b6d 3a 77 2b			ld a, (.dmark+2)  
2b70 32 6d ee			ld (debug_mark+2),a  
2b73 18 03			jr .pastdmark  
2b75 ..			.dmark: db "IF5"  
2b78 f1			.pastdmark: pop af  
2b79			endm  
# End of macro DMARK
2b79						CALLMONITOR 
2b79 cd 6f ee			call debug_vector  
2b7c				endm  
# End of macro CALLMONITOR
2b7c					endif 
2b7c				; replace below with ) exec using tok_ptr 
2b7c 22 c2 e5			ld (os_tok_ptr), hl 
2b7f c3 e9 1f			jp exec1 
2b82			 
2b82 .. 00			.closepar:   db ")",0 
2b84			 
2b84				       NEXTW 
2b84 c3 58 1f			jp macro_next 
2b87				endm 
# End of macro NEXTW
2b87			.COMC: 
2b87				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2b87 6f				db WORD_SYS_CORE+91             
2b88 90 2b			dw .SCRATCH            
2b8a 02				db 1 + 1 
2b8b .. 00			db ")",0              
2b8d				endm 
# End of macro CWHEAD
2b8d			; | ) ( -- )  End of comment |  DONE  
2b8d				       NEXTW 
2b8d c3 58 1f			jp macro_next 
2b90				endm 
# End of macro NEXTW
2b90			 
2b90			.SCRATCH: 
2b90				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2b90 6f				db WORD_SYS_CORE+91             
2b91 cb 2b			dw .INC            
2b93 08				db 7 + 1 
2b94 .. 00			db "SCRATCH",0              
2b9c				endm 
# End of macro CWHEAD
2b9c			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2b9c			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2b9c			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2b9c			; | |  
2b9c			; | | e.g.    : score $00 scratch ; 
2b9c			; | |  
2b9c			; | | $00 score ! 
2b9c			; | | $01 score +! 
2b9c			; | |  
2b9c			; | | e.g.   : varword $0a scratch ;  
2b9c			; | | 
2b9c			; | | $8000 varword ! 
2b9c					if DEBUG_FORTH_WORDS_KEY 
2b9c						DMARK "SCR" 
2b9c f5				push af  
2b9d 3a b1 2b			ld a, (.dmark)  
2ba0 32 6b ee			ld (debug_mark),a  
2ba3 3a b2 2b			ld a, (.dmark+1)  
2ba6 32 6c ee			ld (debug_mark+1),a  
2ba9 3a b3 2b			ld a, (.dmark+2)  
2bac 32 6d ee			ld (debug_mark+2),a  
2baf 18 03			jr .pastdmark  
2bb1 ..			.dmark: db "SCR"  
2bb4 f1			.pastdmark: pop af  
2bb5			endm  
# End of macro DMARK
2bb5						CALLMONITOR 
2bb5 cd 6f ee			call debug_vector  
2bb8				endm  
# End of macro CALLMONITOR
2bb8					endif 
2bb8			 
2bb8					FORTH_DSP_VALUEHL 
2bb8 cd a2 1d			call macro_dsp_valuehl 
2bbb				endm 
# End of macro FORTH_DSP_VALUEHL
2bbb				 
2bbb					FORTH_DSP_POP 
2bbb cd 5a 1e			call macro_forth_dsp_pop 
2bbe				endm 
# End of macro FORTH_DSP_POP
2bbe			 
2bbe 7d					ld a, l 
2bbf 21 e6 e7				ld hl, os_var_array 
2bc2 cd e6 0d				call addatohl 
2bc5			 
2bc5 cd ab 1b				call forth_push_numhl 
2bc8			 
2bc8				       NEXTW 
2bc8 c3 58 1f			jp macro_next 
2bcb				endm 
# End of macro NEXTW
2bcb			 
2bcb			.INC: 
2bcb				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2bcb 6f				db WORD_SYS_CORE+91             
2bcc 21 2c			dw .DEC            
2bce 03				db 2 + 1 
2bcf .. 00			db "+!",0              
2bd2				endm 
# End of macro CWHEAD
2bd2			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2bd2					if DEBUG_FORTH_WORDS_KEY 
2bd2						DMARK "+s_" 
2bd2 f5				push af  
2bd3 3a e7 2b			ld a, (.dmark)  
2bd6 32 6b ee			ld (debug_mark),a  
2bd9 3a e8 2b			ld a, (.dmark+1)  
2bdc 32 6c ee			ld (debug_mark+1),a  
2bdf 3a e9 2b			ld a, (.dmark+2)  
2be2 32 6d ee			ld (debug_mark+2),a  
2be5 18 03			jr .pastdmark  
2be7 ..			.dmark: db "+s_"  
2bea f1			.pastdmark: pop af  
2beb			endm  
# End of macro DMARK
2beb						CALLMONITOR 
2beb cd 6f ee			call debug_vector  
2bee				endm  
# End of macro CALLMONITOR
2bee					endif 
2bee			 
2bee					FORTH_DSP_VALUEHL 
2bee cd a2 1d			call macro_dsp_valuehl 
2bf1				endm 
# End of macro FORTH_DSP_VALUEHL
2bf1			 
2bf1 e5					push hl   ; save address 
2bf2			 
2bf2					FORTH_DSP_POP 
2bf2 cd 5a 1e			call macro_forth_dsp_pop 
2bf5				endm 
# End of macro FORTH_DSP_POP
2bf5			 
2bf5					FORTH_DSP_VALUEHL 
2bf5 cd a2 1d			call macro_dsp_valuehl 
2bf8				endm 
# End of macro FORTH_DSP_VALUEHL
2bf8			 
2bf8 e5					push hl 
2bf9					FORTH_DSP_POP 
2bf9 cd 5a 1e			call macro_forth_dsp_pop 
2bfc				endm 
# End of macro FORTH_DSP_POP
2bfc e1					pop hl 
2bfd			 
2bfd					; hl contains value to add to byte at a 
2bfd				 
2bfd eb					ex de, hl 
2bfe			 
2bfe e1					pop hl 
2bff			 
2bff					if DEBUG_FORTH_WORDS 
2bff						DMARK "INC" 
2bff f5				push af  
2c00 3a 14 2c			ld a, (.dmark)  
2c03 32 6b ee			ld (debug_mark),a  
2c06 3a 15 2c			ld a, (.dmark+1)  
2c09 32 6c ee			ld (debug_mark+1),a  
2c0c 3a 16 2c			ld a, (.dmark+2)  
2c0f 32 6d ee			ld (debug_mark+2),a  
2c12 18 03			jr .pastdmark  
2c14 ..			.dmark: db "INC"  
2c17 f1			.pastdmark: pop af  
2c18			endm  
# End of macro DMARK
2c18						CALLMONITOR 
2c18 cd 6f ee			call debug_vector  
2c1b				endm  
# End of macro CALLMONITOR
2c1b					endif 
2c1b			 
2c1b 7e					ld a,(hl) 
2c1c 83					add e 
2c1d 77					ld (hl),a 
2c1e			 
2c1e			 
2c1e			 
2c1e				       NEXTW 
2c1e c3 58 1f			jp macro_next 
2c21				endm 
# End of macro NEXTW
2c21			 
2c21			.DEC: 
2c21				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2c21 6f				db WORD_SYS_CORE+91             
2c22 75 2c			dw .INC2            
2c24 03				db 2 + 1 
2c25 .. 00			db "-!",0              
2c28				endm 
# End of macro CWHEAD
2c28			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2c28					if DEBUG_FORTH_WORDS_KEY 
2c28						DMARK "-s_" 
2c28 f5				push af  
2c29 3a 3d 2c			ld a, (.dmark)  
2c2c 32 6b ee			ld (debug_mark),a  
2c2f 3a 3e 2c			ld a, (.dmark+1)  
2c32 32 6c ee			ld (debug_mark+1),a  
2c35 3a 3f 2c			ld a, (.dmark+2)  
2c38 32 6d ee			ld (debug_mark+2),a  
2c3b 18 03			jr .pastdmark  
2c3d ..			.dmark: db "-s_"  
2c40 f1			.pastdmark: pop af  
2c41			endm  
# End of macro DMARK
2c41						CALLMONITOR 
2c41 cd 6f ee			call debug_vector  
2c44				endm  
# End of macro CALLMONITOR
2c44					endif 
2c44			 
2c44					FORTH_DSP_VALUEHL 
2c44 cd a2 1d			call macro_dsp_valuehl 
2c47				endm 
# End of macro FORTH_DSP_VALUEHL
2c47			 
2c47 e5					push hl   ; save address 
2c48			 
2c48					FORTH_DSP_POP 
2c48 cd 5a 1e			call macro_forth_dsp_pop 
2c4b				endm 
# End of macro FORTH_DSP_POP
2c4b			 
2c4b					FORTH_DSP_VALUEHL 
2c4b cd a2 1d			call macro_dsp_valuehl 
2c4e				endm 
# End of macro FORTH_DSP_VALUEHL
2c4e			 
2c4e					; hl contains value to add to byte at a 
2c4e				 
2c4e eb					ex de, hl 
2c4f			 
2c4f e1					pop hl 
2c50			 
2c50					if DEBUG_FORTH_WORDS 
2c50						DMARK "DEC" 
2c50 f5				push af  
2c51 3a 65 2c			ld a, (.dmark)  
2c54 32 6b ee			ld (debug_mark),a  
2c57 3a 66 2c			ld a, (.dmark+1)  
2c5a 32 6c ee			ld (debug_mark+1),a  
2c5d 3a 67 2c			ld a, (.dmark+2)  
2c60 32 6d ee			ld (debug_mark+2),a  
2c63 18 03			jr .pastdmark  
2c65 ..			.dmark: db "DEC"  
2c68 f1			.pastdmark: pop af  
2c69			endm  
# End of macro DMARK
2c69						CALLMONITOR 
2c69 cd 6f ee			call debug_vector  
2c6c				endm  
# End of macro CALLMONITOR
2c6c					endif 
2c6c			 
2c6c 7e					ld a,(hl) 
2c6d 93					sub e 
2c6e 77					ld (hl),a 
2c6f			 
2c6f			 
2c6f					FORTH_DSP_POP 
2c6f cd 5a 1e			call macro_forth_dsp_pop 
2c72				endm 
# End of macro FORTH_DSP_POP
2c72			 
2c72				       NEXTW 
2c72 c3 58 1f			jp macro_next 
2c75				endm 
# End of macro NEXTW
2c75			 
2c75			.INC2: 
2c75				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2c75 6f				db WORD_SYS_CORE+91             
2c76 22 2d			dw .DEC2            
2c78 04				db 3 + 1 
2c79 .. 00			db "+2!",0              
2c7d				endm 
# End of macro CWHEAD
2c7d			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2c7d			 
2c7d					if DEBUG_FORTH_WORDS_KEY 
2c7d						DMARK "+2s" 
2c7d f5				push af  
2c7e 3a 92 2c			ld a, (.dmark)  
2c81 32 6b ee			ld (debug_mark),a  
2c84 3a 93 2c			ld a, (.dmark+1)  
2c87 32 6c ee			ld (debug_mark+1),a  
2c8a 3a 94 2c			ld a, (.dmark+2)  
2c8d 32 6d ee			ld (debug_mark+2),a  
2c90 18 03			jr .pastdmark  
2c92 ..			.dmark: db "+2s"  
2c95 f1			.pastdmark: pop af  
2c96			endm  
# End of macro DMARK
2c96						CALLMONITOR 
2c96 cd 6f ee			call debug_vector  
2c99				endm  
# End of macro CALLMONITOR
2c99					endif 
2c99			 
2c99					; Address 
2c99			 
2c99					FORTH_DSP_VALUEHL 
2c99 cd a2 1d			call macro_dsp_valuehl 
2c9c				endm 
# End of macro FORTH_DSP_VALUEHL
2c9c			 
2c9c e5					push hl    ; save address 
2c9d			 
2c9d					; load content into de 
2c9d			 
2c9d 5e					ld e,(hl) 
2c9e 23					inc hl 
2c9f 56					ld d, (hl) 
2ca0			 
2ca0					if DEBUG_FORTH_WORDS 
2ca0						DMARK "+2a" 
2ca0 f5				push af  
2ca1 3a b5 2c			ld a, (.dmark)  
2ca4 32 6b ee			ld (debug_mark),a  
2ca7 3a b6 2c			ld a, (.dmark+1)  
2caa 32 6c ee			ld (debug_mark+1),a  
2cad 3a b7 2c			ld a, (.dmark+2)  
2cb0 32 6d ee			ld (debug_mark+2),a  
2cb3 18 03			jr .pastdmark  
2cb5 ..			.dmark: db "+2a"  
2cb8 f1			.pastdmark: pop af  
2cb9			endm  
# End of macro DMARK
2cb9						CALLMONITOR 
2cb9 cd 6f ee			call debug_vector  
2cbc				endm  
# End of macro CALLMONITOR
2cbc					endif 
2cbc			 
2cbc					FORTH_DSP_POP 
2cbc cd 5a 1e			call macro_forth_dsp_pop 
2cbf				endm 
# End of macro FORTH_DSP_POP
2cbf			 
2cbf					; Get value to add 
2cbf			 
2cbf					FORTH_DSP_VALUE 
2cbf cd 8b 1d			call macro_forth_dsp_value 
2cc2				endm 
# End of macro FORTH_DSP_VALUE
2cc2			 
2cc2					if DEBUG_FORTH_WORDS 
2cc2						DMARK "+2v" 
2cc2 f5				push af  
2cc3 3a d7 2c			ld a, (.dmark)  
2cc6 32 6b ee			ld (debug_mark),a  
2cc9 3a d8 2c			ld a, (.dmark+1)  
2ccc 32 6c ee			ld (debug_mark+1),a  
2ccf 3a d9 2c			ld a, (.dmark+2)  
2cd2 32 6d ee			ld (debug_mark+2),a  
2cd5 18 03			jr .pastdmark  
2cd7 ..			.dmark: db "+2v"  
2cda f1			.pastdmark: pop af  
2cdb			endm  
# End of macro DMARK
2cdb						CALLMONITOR 
2cdb cd 6f ee			call debug_vector  
2cde				endm  
# End of macro CALLMONITOR
2cde					endif 
2cde			 
2cde 19					add hl, de 
2cdf			 
2cdf					if DEBUG_FORTH_WORDS 
2cdf						DMARK "+2+" 
2cdf f5				push af  
2ce0 3a f4 2c			ld a, (.dmark)  
2ce3 32 6b ee			ld (debug_mark),a  
2ce6 3a f5 2c			ld a, (.dmark+1)  
2ce9 32 6c ee			ld (debug_mark+1),a  
2cec 3a f6 2c			ld a, (.dmark+2)  
2cef 32 6d ee			ld (debug_mark+2),a  
2cf2 18 03			jr .pastdmark  
2cf4 ..			.dmark: db "+2+"  
2cf7 f1			.pastdmark: pop af  
2cf8			endm  
# End of macro DMARK
2cf8						CALLMONITOR 
2cf8 cd 6f ee			call debug_vector  
2cfb				endm  
# End of macro CALLMONITOR
2cfb					endif 
2cfb			 
2cfb					; move result to de 
2cfb			 
2cfb eb					ex de, hl 
2cfc			 
2cfc					; Address 
2cfc			 
2cfc e1					pop hl 
2cfd			 
2cfd					; save it back 
2cfd			 
2cfd 73					ld (hl), e 
2cfe 23					inc hl 
2cff 72					ld (hl), d 
2d00			 
2d00					if DEBUG_FORTH_WORDS 
2d00						DMARK "+2e" 
2d00 f5				push af  
2d01 3a 15 2d			ld a, (.dmark)  
2d04 32 6b ee			ld (debug_mark),a  
2d07 3a 16 2d			ld a, (.dmark+1)  
2d0a 32 6c ee			ld (debug_mark+1),a  
2d0d 3a 17 2d			ld a, (.dmark+2)  
2d10 32 6d ee			ld (debug_mark+2),a  
2d13 18 03			jr .pastdmark  
2d15 ..			.dmark: db "+2e"  
2d18 f1			.pastdmark: pop af  
2d19			endm  
# End of macro DMARK
2d19						CALLMONITOR 
2d19 cd 6f ee			call debug_vector  
2d1c				endm  
# End of macro CALLMONITOR
2d1c					endif 
2d1c			 
2d1c			 
2d1c			 
2d1c					FORTH_DSP_POP 
2d1c cd 5a 1e			call macro_forth_dsp_pop 
2d1f				endm 
# End of macro FORTH_DSP_POP
2d1f			 
2d1f			 
2d1f				       NEXTW 
2d1f c3 58 1f			jp macro_next 
2d22				endm 
# End of macro NEXTW
2d22			 
2d22			.DEC2: 
2d22				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2d22 6f				db WORD_SYS_CORE+91             
2d23 d1 2d			dw .GET2            
2d25 04				db 3 + 1 
2d26 .. 00			db "-2!",0              
2d2a				endm 
# End of macro CWHEAD
2d2a			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2d2a			 
2d2a			 
2d2a					if DEBUG_FORTH_WORDS_KEY 
2d2a						DMARK "-2s" 
2d2a f5				push af  
2d2b 3a 3f 2d			ld a, (.dmark)  
2d2e 32 6b ee			ld (debug_mark),a  
2d31 3a 40 2d			ld a, (.dmark+1)  
2d34 32 6c ee			ld (debug_mark+1),a  
2d37 3a 41 2d			ld a, (.dmark+2)  
2d3a 32 6d ee			ld (debug_mark+2),a  
2d3d 18 03			jr .pastdmark  
2d3f ..			.dmark: db "-2s"  
2d42 f1			.pastdmark: pop af  
2d43			endm  
# End of macro DMARK
2d43						CALLMONITOR 
2d43 cd 6f ee			call debug_vector  
2d46				endm  
# End of macro CALLMONITOR
2d46					endif 
2d46			 
2d46					; Address 
2d46			 
2d46					FORTH_DSP_VALUEHL 
2d46 cd a2 1d			call macro_dsp_valuehl 
2d49				endm 
# End of macro FORTH_DSP_VALUEHL
2d49			 
2d49 e5					push hl    ; save address 
2d4a			 
2d4a					; load content into de 
2d4a			 
2d4a 5e					ld e,(hl) 
2d4b 23					inc hl 
2d4c 56					ld d, (hl) 
2d4d			 
2d4d					if DEBUG_FORTH_WORDS 
2d4d						DMARK "-2a" 
2d4d f5				push af  
2d4e 3a 62 2d			ld a, (.dmark)  
2d51 32 6b ee			ld (debug_mark),a  
2d54 3a 63 2d			ld a, (.dmark+1)  
2d57 32 6c ee			ld (debug_mark+1),a  
2d5a 3a 64 2d			ld a, (.dmark+2)  
2d5d 32 6d ee			ld (debug_mark+2),a  
2d60 18 03			jr .pastdmark  
2d62 ..			.dmark: db "-2a"  
2d65 f1			.pastdmark: pop af  
2d66			endm  
# End of macro DMARK
2d66						CALLMONITOR 
2d66 cd 6f ee			call debug_vector  
2d69				endm  
# End of macro CALLMONITOR
2d69					endif 
2d69			 
2d69					FORTH_DSP_POP 
2d69 cd 5a 1e			call macro_forth_dsp_pop 
2d6c				endm 
# End of macro FORTH_DSP_POP
2d6c			 
2d6c					; Get value to remove 
2d6c			 
2d6c					FORTH_DSP_VALUE 
2d6c cd 8b 1d			call macro_forth_dsp_value 
2d6f				endm 
# End of macro FORTH_DSP_VALUE
2d6f			 
2d6f					if DEBUG_FORTH_WORDS 
2d6f						DMARK "-2v" 
2d6f f5				push af  
2d70 3a 84 2d			ld a, (.dmark)  
2d73 32 6b ee			ld (debug_mark),a  
2d76 3a 85 2d			ld a, (.dmark+1)  
2d79 32 6c ee			ld (debug_mark+1),a  
2d7c 3a 86 2d			ld a, (.dmark+2)  
2d7f 32 6d ee			ld (debug_mark+2),a  
2d82 18 03			jr .pastdmark  
2d84 ..			.dmark: db "-2v"  
2d87 f1			.pastdmark: pop af  
2d88			endm  
# End of macro DMARK
2d88						CALLMONITOR 
2d88 cd 6f ee			call debug_vector  
2d8b				endm  
# End of macro CALLMONITOR
2d8b					endif 
2d8b			 
2d8b eb					ex de, hl 
2d8c ed 52				sbc hl, de 
2d8e			 
2d8e					if DEBUG_FORTH_WORDS 
2d8e						DMARK "-2d" 
2d8e f5				push af  
2d8f 3a a3 2d			ld a, (.dmark)  
2d92 32 6b ee			ld (debug_mark),a  
2d95 3a a4 2d			ld a, (.dmark+1)  
2d98 32 6c ee			ld (debug_mark+1),a  
2d9b 3a a5 2d			ld a, (.dmark+2)  
2d9e 32 6d ee			ld (debug_mark+2),a  
2da1 18 03			jr .pastdmark  
2da3 ..			.dmark: db "-2d"  
2da6 f1			.pastdmark: pop af  
2da7			endm  
# End of macro DMARK
2da7						CALLMONITOR 
2da7 cd 6f ee			call debug_vector  
2daa				endm  
# End of macro CALLMONITOR
2daa					endif 
2daa			 
2daa					; move result to de 
2daa			 
2daa eb					ex de, hl 
2dab			 
2dab					; Address 
2dab			 
2dab e1					pop hl 
2dac			 
2dac					; save it back 
2dac			 
2dac 73					ld (hl), e 
2dad 23					inc hl 
2dae 72					ld (hl), d 
2daf			 
2daf					if DEBUG_FORTH_WORDS 
2daf						DMARK "-2e" 
2daf f5				push af  
2db0 3a c4 2d			ld a, (.dmark)  
2db3 32 6b ee			ld (debug_mark),a  
2db6 3a c5 2d			ld a, (.dmark+1)  
2db9 32 6c ee			ld (debug_mark+1),a  
2dbc 3a c6 2d			ld a, (.dmark+2)  
2dbf 32 6d ee			ld (debug_mark+2),a  
2dc2 18 03			jr .pastdmark  
2dc4 ..			.dmark: db "-2e"  
2dc7 f1			.pastdmark: pop af  
2dc8			endm  
# End of macro DMARK
2dc8						CALLMONITOR 
2dc8 cd 6f ee			call debug_vector  
2dcb				endm  
# End of macro CALLMONITOR
2dcb					endif 
2dcb			 
2dcb			 
2dcb					FORTH_DSP_POP 
2dcb cd 5a 1e			call macro_forth_dsp_pop 
2dce				endm 
# End of macro FORTH_DSP_POP
2dce			 
2dce			 
2dce			 
2dce				       NEXTW 
2dce c3 58 1f			jp macro_next 
2dd1				endm 
# End of macro NEXTW
2dd1			.GET2: 
2dd1				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2dd1 6f				db WORD_SYS_CORE+91             
2dd2 06 2e			dw .BANG2            
2dd4 03				db 2 + 1 
2dd5 .. 00			db "2@",0              
2dd8				endm 
# End of macro CWHEAD
2dd8			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2dd8					if DEBUG_FORTH_WORDS_KEY 
2dd8						DMARK "2A_" 
2dd8 f5				push af  
2dd9 3a ed 2d			ld a, (.dmark)  
2ddc 32 6b ee			ld (debug_mark),a  
2ddf 3a ee 2d			ld a, (.dmark+1)  
2de2 32 6c ee			ld (debug_mark+1),a  
2de5 3a ef 2d			ld a, (.dmark+2)  
2de8 32 6d ee			ld (debug_mark+2),a  
2deb 18 03			jr .pastdmark  
2ded ..			.dmark: db "2A_"  
2df0 f1			.pastdmark: pop af  
2df1			endm  
# End of macro DMARK
2df1						CALLMONITOR 
2df1 cd 6f ee			call debug_vector  
2df4				endm  
# End of macro CALLMONITOR
2df4					endif 
2df4			 
2df4					FORTH_DSP_VALUEHL 
2df4 cd a2 1d			call macro_dsp_valuehl 
2df7				endm 
# End of macro FORTH_DSP_VALUEHL
2df7			 
2df7 e5					push hl   ; save address 
2df8			 
2df8					FORTH_DSP_POP 
2df8 cd 5a 1e			call macro_forth_dsp_pop 
2dfb				endm 
# End of macro FORTH_DSP_POP
2dfb			 
2dfb e1					pop hl 
2dfc			 
2dfc 5e					ld e, (hl) 
2dfd 23					inc hl 
2dfe 56					ld d, (hl) 
2dff			 
2dff eb					ex de, hl 
2e00			 
2e00 cd ab 1b				call forth_push_numhl 
2e03			 
2e03				       NEXTW 
2e03 c3 58 1f			jp macro_next 
2e06				endm 
# End of macro NEXTW
2e06			.BANG2: 
2e06				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2e06 6f				db WORD_SYS_CORE+91             
2e07 3e 2e			dw .CONFIG            
2e09 03				db 2 + 1 
2e0a .. 00			db "2!",0              
2e0d				endm 
# End of macro CWHEAD
2e0d			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2e0d					if DEBUG_FORTH_WORDS_KEY 
2e0d						DMARK "2S_" 
2e0d f5				push af  
2e0e 3a 22 2e			ld a, (.dmark)  
2e11 32 6b ee			ld (debug_mark),a  
2e14 3a 23 2e			ld a, (.dmark+1)  
2e17 32 6c ee			ld (debug_mark+1),a  
2e1a 3a 24 2e			ld a, (.dmark+2)  
2e1d 32 6d ee			ld (debug_mark+2),a  
2e20 18 03			jr .pastdmark  
2e22 ..			.dmark: db "2S_"  
2e25 f1			.pastdmark: pop af  
2e26			endm  
# End of macro DMARK
2e26						CALLMONITOR 
2e26 cd 6f ee			call debug_vector  
2e29				endm  
# End of macro CALLMONITOR
2e29					endif 
2e29			 
2e29					FORTH_DSP_VALUEHL 
2e29 cd a2 1d			call macro_dsp_valuehl 
2e2c				endm 
# End of macro FORTH_DSP_VALUEHL
2e2c			 
2e2c e5					push hl   ; save address 
2e2d			 
2e2d			 
2e2d					FORTH_DSP_POP 
2e2d cd 5a 1e			call macro_forth_dsp_pop 
2e30				endm 
# End of macro FORTH_DSP_POP
2e30			 
2e30					 
2e30					FORTH_DSP_VALUEHL 
2e30 cd a2 1d			call macro_dsp_valuehl 
2e33				endm 
# End of macro FORTH_DSP_VALUEHL
2e33			 
2e33					FORTH_DSP_POP 
2e33 cd 5a 1e			call macro_forth_dsp_pop 
2e36				endm 
# End of macro FORTH_DSP_POP
2e36			 
2e36 eb					ex de, hl    ; value now in de 
2e37			 
2e37 e1					pop hl 
2e38			 
2e38 73					ld (hl), e 
2e39			 
2e39 23					inc hl 
2e3a			 
2e3a 72					ld (hl), d 
2e3b			 
2e3b			 
2e3b				       NEXTW 
2e3b c3 58 1f			jp macro_next 
2e3e				endm 
# End of macro NEXTW
2e3e			.CONFIG: 
2e3e				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
2e3e 6f				db WORD_SYS_CORE+91             
2e3f 4f 2e			dw .ADTOS            
2e41 07				db 6 + 1 
2e42 .. 00			db "CONFIG",0              
2e49				endm 
# End of macro CWHEAD
2e49			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
2e49			 
2e49 cd ab 13				call config 
2e4c					NEXTW 
2e4c c3 58 1f			jp macro_next 
2e4f				endm 
# End of macro NEXTW
2e4f			 
2e4f			.ADTOS: 
2e4f				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
2e4f 6f				db WORD_SYS_CORE+91             
2e50 65 2e			dw .SBTOS            
2e52 03				db 2 + 1 
2e53 .. 00			db "1+",0              
2e56				endm 
# End of macro CWHEAD
2e56			; | 1+ ( u -- u )  Increment value on TOS | DONE 
2e56			 
2e56					FORTH_DSP_VALUEHL 
2e56 cd a2 1d			call macro_dsp_valuehl 
2e59				endm 
# End of macro FORTH_DSP_VALUEHL
2e59 e5					push hl 
2e5a			 
2e5a					FORTH_DSP_POP 
2e5a cd 5a 1e			call macro_forth_dsp_pop 
2e5d				endm 
# End of macro FORTH_DSP_POP
2e5d e1					pop hl 
2e5e			 
2e5e 23					inc hl 
2e5f cd ab 1b				call forth_push_numhl 
2e62					 
2e62					NEXTW 
2e62 c3 58 1f			jp macro_next 
2e65				endm 
# End of macro NEXTW
2e65			.SBTOS: 
2e65				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
2e65 6f				db WORD_SYS_CORE+91             
2e66 7b 2e			dw .ADSTORE            
2e68 03				db 2 + 1 
2e69 .. 00			db "1-",0              
2e6c				endm 
# End of macro CWHEAD
2e6c			; | 1- ( u -- u )  Decrement value on TOS | DONE 
2e6c			 
2e6c					FORTH_DSP_VALUEHL 
2e6c cd a2 1d			call macro_dsp_valuehl 
2e6f				endm 
# End of macro FORTH_DSP_VALUEHL
2e6f e5					push hl 
2e70			 
2e70					FORTH_DSP_POP 
2e70 cd 5a 1e			call macro_forth_dsp_pop 
2e73				endm 
# End of macro FORTH_DSP_POP
2e73 e1					pop hl 
2e74			 
2e74 2b					dec hl 
2e75 cd ab 1b				call forth_push_numhl 
2e78					 
2e78					NEXTW 
2e78 c3 58 1f			jp macro_next 
2e7b				endm 
# End of macro NEXTW
2e7b			.ADSTORE: 
2e7b				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
2e7b 6f				db WORD_SYS_CORE+91             
2e7c 91 2e			dw .ADWSTORE            
2e7e 04				db 3 + 1 
2e7f .. 00			db "1+!",0              
2e83				endm 
# End of macro CWHEAD
2e83			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
2e83			 
2e83					FORTH_DSP_VALUEHL 
2e83 cd a2 1d			call macro_dsp_valuehl 
2e86				endm 
# End of macro FORTH_DSP_VALUEHL
2e86 e5					push hl 
2e87			 
2e87					FORTH_DSP_POP 
2e87 cd 5a 1e			call macro_forth_dsp_pop 
2e8a				endm 
# End of macro FORTH_DSP_POP
2e8a e1					pop hl 
2e8b			 
2e8b 7e					ld a, (hl) 
2e8c 3c					inc a 
2e8d 77					ld (hl), a 
2e8e					 
2e8e					NEXTW 
2e8e c3 58 1f			jp macro_next 
2e91				endm 
# End of macro NEXTW
2e91			.ADWSTORE: 
2e91				CWHEAD .SBSTORE 91 "1+2!" 4 WORD_FLAG_CODE 
2e91 6f				db WORD_SYS_CORE+91             
2e92 af 2e			dw .SBSTORE            
2e94 05				db 4 + 1 
2e95 .. 00			db "1+2!",0              
2e9a				endm 
# End of macro CWHEAD
2e9a			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
2e9a			 
2e9a					FORTH_DSP_VALUEHL 
2e9a cd a2 1d			call macro_dsp_valuehl 
2e9d				endm 
# End of macro FORTH_DSP_VALUEHL
2e9d e5					push hl 
2e9e			 
2e9e					FORTH_DSP_POP 
2e9e cd 5a 1e			call macro_forth_dsp_pop 
2ea1				endm 
# End of macro FORTH_DSP_POP
2ea1 e1					pop hl 
2ea2			 
2ea2 e5					push hl 
2ea3			 
2ea3 cd da 1e				call loadwordinhl 
2ea6 23					inc hl 
2ea7			 
2ea7 d1					pop de 
2ea8 eb					ex de, hl 
2ea9 73					ld (hl), e 
2eaa 23					inc hl 
2eab 72					ld (hl), d 
2eac					 
2eac					NEXTW 
2eac c3 58 1f			jp macro_next 
2eaf				endm 
# End of macro NEXTW
2eaf			.SBSTORE: 
2eaf				CWHEAD .SBWSTORE 91 "1-!" 3 WORD_FLAG_CODE 
2eaf 6f				db WORD_SYS_CORE+91             
2eb0 c5 2e			dw .SBWSTORE            
2eb2 04				db 3 + 1 
2eb3 .. 00			db "1-!",0              
2eb7				endm 
# End of macro CWHEAD
2eb7			; | 1-! ( addr -- )  Decrement byte at address addr | DONE 
2eb7			 
2eb7					FORTH_DSP_VALUEHL 
2eb7 cd a2 1d			call macro_dsp_valuehl 
2eba				endm 
# End of macro FORTH_DSP_VALUEHL
2eba e5					push hl 
2ebb			 
2ebb					FORTH_DSP_POP 
2ebb cd 5a 1e			call macro_forth_dsp_pop 
2ebe				endm 
# End of macro FORTH_DSP_POP
2ebe e1					pop hl 
2ebf			 
2ebf 7e					ld a, (hl) 
2ec0 3d					dec a 
2ec1 77					ld (hl), a 
2ec2					 
2ec2					NEXTW 
2ec2 c3 58 1f			jp macro_next 
2ec5				endm 
# End of macro NEXTW
2ec5			.SBWSTORE: 
2ec5				CWHEAD .ENDCORE 91 "1-2!" 4 WORD_FLAG_CODE 
2ec5 6f				db WORD_SYS_CORE+91             
2ec6 e3 2e			dw .ENDCORE            
2ec8 05				db 4 + 1 
2ec9 .. 00			db "1-2!",0              
2ece				endm 
# End of macro CWHEAD
2ece			; | 1-2! ( addr -- )  Decrement word at address addr | DONE 
2ece			 
2ece					FORTH_DSP_VALUEHL 
2ece cd a2 1d			call macro_dsp_valuehl 
2ed1				endm 
# End of macro FORTH_DSP_VALUEHL
2ed1 e5					push hl 
2ed2			 
2ed2					FORTH_DSP_POP 
2ed2 cd 5a 1e			call macro_forth_dsp_pop 
2ed5				endm 
# End of macro FORTH_DSP_POP
2ed5 e1					pop hl 
2ed6			 
2ed6 e5					push hl 
2ed7			 
2ed7 cd da 1e				call loadwordinhl 
2eda 2b					dec hl 
2edb			 
2edb d1					pop de 
2edc eb					ex de, hl 
2edd 73					ld (hl), e 
2ede 23					inc hl 
2edf 72					ld (hl), d 
2ee0					 
2ee0					NEXTW 
2ee0 c3 58 1f			jp macro_next 
2ee3				endm 
# End of macro NEXTW
2ee3			.ENDCORE: 
2ee3			 
2ee3			; eof 
2ee3			 
2ee3			 
# End of file forth_words_core.asm
2ee3			include "forth_words_flow.asm" 
2ee3			 
2ee3			; | ## Program Flow Words 
2ee3			 
2ee3			.IF: 
2ee3				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2ee3 1e				db WORD_SYS_CORE+10             
2ee4 d8 2f			dw .THEN            
2ee6 03				db 2 + 1 
2ee7 .. 00			db "IF",0              
2eea				endm 
# End of macro CWHEAD
2eea			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2eea			; 
2eea					if DEBUG_FORTH_WORDS_KEY 
2eea						DMARK "IF." 
2eea f5				push af  
2eeb 3a ff 2e			ld a, (.dmark)  
2eee 32 6b ee			ld (debug_mark),a  
2ef1 3a 00 2f			ld a, (.dmark+1)  
2ef4 32 6c ee			ld (debug_mark+1),a  
2ef7 3a 01 2f			ld a, (.dmark+2)  
2efa 32 6d ee			ld (debug_mark+2),a  
2efd 18 03			jr .pastdmark  
2eff ..			.dmark: db "IF."  
2f02 f1			.pastdmark: pop af  
2f03			endm  
# End of macro DMARK
2f03						CALLMONITOR 
2f03 cd 6f ee			call debug_vector  
2f06				endm  
# End of macro CALLMONITOR
2f06					endif 
2f06			; eval TOS 
2f06			 
2f06				FORTH_DSP_VALUEHL 
2f06 cd a2 1d			call macro_dsp_valuehl 
2f09				endm 
# End of macro FORTH_DSP_VALUEHL
2f09			 
2f09			;	push hl 
2f09				FORTH_DSP_POP 
2f09 cd 5a 1e			call macro_forth_dsp_pop 
2f0c				endm 
# End of macro FORTH_DSP_POP
2f0c			;	pop hl 
2f0c			 
2f0c					if DEBUG_FORTH_WORDS 
2f0c						DMARK "IF1" 
2f0c f5				push af  
2f0d 3a 21 2f			ld a, (.dmark)  
2f10 32 6b ee			ld (debug_mark),a  
2f13 3a 22 2f			ld a, (.dmark+1)  
2f16 32 6c ee			ld (debug_mark+1),a  
2f19 3a 23 2f			ld a, (.dmark+2)  
2f1c 32 6d ee			ld (debug_mark+2),a  
2f1f 18 03			jr .pastdmark  
2f21 ..			.dmark: db "IF1"  
2f24 f1			.pastdmark: pop af  
2f25			endm  
# End of macro DMARK
2f25						CALLMONITOR 
2f25 cd 6f ee			call debug_vector  
2f28				endm  
# End of macro CALLMONITOR
2f28					endif 
2f28 b7				or a        ; clear carry flag 
2f29 11 00 00			ld de, 0 
2f2c eb				ex de,hl 
2f2d ed 52			sbc hl, de 
2f2f c2 b9 2f			jp nz, .iftrue 
2f32			 
2f32					if DEBUG_FORTH_WORDS 
2f32						DMARK "IF2" 
2f32 f5				push af  
2f33 3a 47 2f			ld a, (.dmark)  
2f36 32 6b ee			ld (debug_mark),a  
2f39 3a 48 2f			ld a, (.dmark+1)  
2f3c 32 6c ee			ld (debug_mark+1),a  
2f3f 3a 49 2f			ld a, (.dmark+2)  
2f42 32 6d ee			ld (debug_mark+2),a  
2f45 18 03			jr .pastdmark  
2f47 ..			.dmark: db "IF2"  
2f4a f1			.pastdmark: pop af  
2f4b			endm  
# End of macro DMARK
2f4b						CALLMONITOR 
2f4b cd 6f ee			call debug_vector  
2f4e				endm  
# End of macro CALLMONITOR
2f4e					endif 
2f4e			 
2f4e			; if not true then skip to THEN 
2f4e			 
2f4e				; TODO get tok_ptr 
2f4e				; TODO consume toks until we get to THEN 
2f4e			 
2f4e 2a c2 e5			ld hl, (os_tok_ptr) 
2f51					if DEBUG_FORTH_WORDS 
2f51						DMARK "IF3" 
2f51 f5				push af  
2f52 3a 66 2f			ld a, (.dmark)  
2f55 32 6b ee			ld (debug_mark),a  
2f58 3a 67 2f			ld a, (.dmark+1)  
2f5b 32 6c ee			ld (debug_mark+1),a  
2f5e 3a 68 2f			ld a, (.dmark+2)  
2f61 32 6d ee			ld (debug_mark+2),a  
2f64 18 03			jr .pastdmark  
2f66 ..			.dmark: db "IF3"  
2f69 f1			.pastdmark: pop af  
2f6a			endm  
# End of macro DMARK
2f6a						CALLMONITOR 
2f6a cd 6f ee			call debug_vector  
2f6d				endm  
# End of macro CALLMONITOR
2f6d						 
2f6d					endif 
2f6d 11 b4 2f			ld de, .ifthen 
2f70					if DEBUG_FORTH_WORDS 
2f70						DMARK "IF4" 
2f70 f5				push af  
2f71 3a 85 2f			ld a, (.dmark)  
2f74 32 6b ee			ld (debug_mark),a  
2f77 3a 86 2f			ld a, (.dmark+1)  
2f7a 32 6c ee			ld (debug_mark+1),a  
2f7d 3a 87 2f			ld a, (.dmark+2)  
2f80 32 6d ee			ld (debug_mark+2),a  
2f83 18 03			jr .pastdmark  
2f85 ..			.dmark: db "IF4"  
2f88 f1			.pastdmark: pop af  
2f89			endm  
# End of macro DMARK
2f89						CALLMONITOR 
2f89 cd 6f ee			call debug_vector  
2f8c				endm  
# End of macro CALLMONITOR
2f8c					endif 
2f8c cd 73 20			call findnexttok  
2f8f			 
2f8f					if DEBUG_FORTH_WORDS 
2f8f						DMARK "IF5" 
2f8f f5				push af  
2f90 3a a4 2f			ld a, (.dmark)  
2f93 32 6b ee			ld (debug_mark),a  
2f96 3a a5 2f			ld a, (.dmark+1)  
2f99 32 6c ee			ld (debug_mark+1),a  
2f9c 3a a6 2f			ld a, (.dmark+2)  
2f9f 32 6d ee			ld (debug_mark+2),a  
2fa2 18 03			jr .pastdmark  
2fa4 ..			.dmark: db "IF5"  
2fa7 f1			.pastdmark: pop af  
2fa8			endm  
# End of macro DMARK
2fa8						CALLMONITOR 
2fa8 cd 6f ee			call debug_vector  
2fab				endm  
# End of macro CALLMONITOR
2fab					endif 
2fab				; TODO replace below with ; exec using tok_ptr 
2fab 22 c2 e5			ld (os_tok_ptr), hl 
2fae c3 e9 1f			jp exec1 
2fb1				NEXTW 
2fb1 c3 58 1f			jp macro_next 
2fb4				endm 
# End of macro NEXTW
2fb4			 
2fb4 .. 00		.ifthen:  db "THEN",0 
2fb9			 
2fb9			.iftrue:		 
2fb9				; Exec next words normally 
2fb9			 
2fb9				; if true then exec following IF as normal 
2fb9					if DEBUG_FORTH_WORDS 
2fb9						DMARK "IFT" 
2fb9 f5				push af  
2fba 3a ce 2f			ld a, (.dmark)  
2fbd 32 6b ee			ld (debug_mark),a  
2fc0 3a cf 2f			ld a, (.dmark+1)  
2fc3 32 6c ee			ld (debug_mark+1),a  
2fc6 3a d0 2f			ld a, (.dmark+2)  
2fc9 32 6d ee			ld (debug_mark+2),a  
2fcc 18 03			jr .pastdmark  
2fce ..			.dmark: db "IFT"  
2fd1 f1			.pastdmark: pop af  
2fd2			endm  
# End of macro DMARK
2fd2						CALLMONITOR 
2fd2 cd 6f ee			call debug_vector  
2fd5				endm  
# End of macro CALLMONITOR
2fd5					endif 
2fd5			 
2fd5					NEXTW 
2fd5 c3 58 1f			jp macro_next 
2fd8				endm 
# End of macro NEXTW
2fd8			.THEN: 
2fd8				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
2fd8 1f				db WORD_SYS_CORE+11             
2fd9 00 30			dw .ELSE            
2fdb 05				db 4 + 1 
2fdc .. 00			db "THEN",0              
2fe1				endm 
# End of macro CWHEAD
2fe1			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
2fe1					if DEBUG_FORTH_WORDS_KEY 
2fe1						DMARK "THN" 
2fe1 f5				push af  
2fe2 3a f6 2f			ld a, (.dmark)  
2fe5 32 6b ee			ld (debug_mark),a  
2fe8 3a f7 2f			ld a, (.dmark+1)  
2feb 32 6c ee			ld (debug_mark+1),a  
2fee 3a f8 2f			ld a, (.dmark+2)  
2ff1 32 6d ee			ld (debug_mark+2),a  
2ff4 18 03			jr .pastdmark  
2ff6 ..			.dmark: db "THN"  
2ff9 f1			.pastdmark: pop af  
2ffa			endm  
# End of macro DMARK
2ffa						CALLMONITOR 
2ffa cd 6f ee			call debug_vector  
2ffd				endm  
# End of macro CALLMONITOR
2ffd					endif 
2ffd					NEXTW 
2ffd c3 58 1f			jp macro_next 
3000				endm 
# End of macro NEXTW
3000			.ELSE: 
3000				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
3000 20				db WORD_SYS_CORE+12             
3001 28 30			dw .DO            
3003 03				db 2 + 1 
3004 .. 00			db "ELSE",0              
3009				endm 
# End of macro CWHEAD
3009			; | ELSE ( -- ) Not supported - does nothing | TODO 
3009			 
3009					if DEBUG_FORTH_WORDS_KEY 
3009						DMARK "ELS" 
3009 f5				push af  
300a 3a 1e 30			ld a, (.dmark)  
300d 32 6b ee			ld (debug_mark),a  
3010 3a 1f 30			ld a, (.dmark+1)  
3013 32 6c ee			ld (debug_mark+1),a  
3016 3a 20 30			ld a, (.dmark+2)  
3019 32 6d ee			ld (debug_mark+2),a  
301c 18 03			jr .pastdmark  
301e ..			.dmark: db "ELS"  
3021 f1			.pastdmark: pop af  
3022			endm  
# End of macro DMARK
3022						CALLMONITOR 
3022 cd 6f ee			call debug_vector  
3025				endm  
# End of macro CALLMONITOR
3025					endif 
3025			 
3025			 
3025					NEXTW 
3025 c3 58 1f			jp macro_next 
3028				endm 
# End of macro NEXTW
3028			.DO: 
3028				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
3028 21				db WORD_SYS_CORE+13             
3029 4f 31			dw .LOOP            
302b 03				db 2 + 1 
302c .. 00			db "DO",0              
302f				endm 
# End of macro CWHEAD
302f			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
302f			 
302f					if DEBUG_FORTH_WORDS_KEY 
302f						DMARK "DO." 
302f f5				push af  
3030 3a 44 30			ld a, (.dmark)  
3033 32 6b ee			ld (debug_mark),a  
3036 3a 45 30			ld a, (.dmark+1)  
3039 32 6c ee			ld (debug_mark+1),a  
303c 3a 46 30			ld a, (.dmark+2)  
303f 32 6d ee			ld (debug_mark+2),a  
3042 18 03			jr .pastdmark  
3044 ..			.dmark: db "DO."  
3047 f1			.pastdmark: pop af  
3048			endm  
# End of macro DMARK
3048						CALLMONITOR 
3048 cd 6f ee			call debug_vector  
304b				endm  
# End of macro CALLMONITOR
304b					endif 
304b			;  push pc to rsp stack past the DO 
304b			 
304b 2a c2 e5				ld hl, (os_tok_ptr) 
304e 23					inc hl   ; D 
304f 23					inc hl  ; O 
3050 23					inc hl   ; null 
3051					if DEBUG_FORTH_WORDS 
3051						DMARK "DO2" 
3051 f5				push af  
3052 3a 66 30			ld a, (.dmark)  
3055 32 6b ee			ld (debug_mark),a  
3058 3a 67 30			ld a, (.dmark+1)  
305b 32 6c ee			ld (debug_mark+1),a  
305e 3a 68 30			ld a, (.dmark+2)  
3061 32 6d ee			ld (debug_mark+2),a  
3064 18 03			jr .pastdmark  
3066 ..			.dmark: db "DO2"  
3069 f1			.pastdmark: pop af  
306a			endm  
# End of macro DMARK
306a						CALLMONITOR 
306a cd 6f ee			call debug_vector  
306d				endm  
# End of macro CALLMONITOR
306d					endif 
306d					FORTH_RSP_NEXT 
306d cd 52 1b			call macro_forth_rsp_next 
3070				endm 
# End of macro FORTH_RSP_NEXT
3070					if DEBUG_FORTH_WORDS 
3070						DMARK "DO3" 
3070 f5				push af  
3071 3a 85 30			ld a, (.dmark)  
3074 32 6b ee			ld (debug_mark),a  
3077 3a 86 30			ld a, (.dmark+1)  
307a 32 6c ee			ld (debug_mark+1),a  
307d 3a 87 30			ld a, (.dmark+2)  
3080 32 6d ee			ld (debug_mark+2),a  
3083 18 03			jr .pastdmark  
3085 ..			.dmark: db "DO3"  
3088 f1			.pastdmark: pop af  
3089			endm  
# End of macro DMARK
3089						CALLMONITOR 
3089 cd 6f ee			call debug_vector  
308c				endm  
# End of macro CALLMONITOR
308c					endif 
308c			 
308c					;if DEBUG_FORTH_WORDS 
308c				;		push hl 
308c			;		endif  
308c			 
308c			; get counters from data stack 
308c			 
308c			 
308c					FORTH_DSP_VALUEHL 
308c cd a2 1d			call macro_dsp_valuehl 
308f				endm 
# End of macro FORTH_DSP_VALUEHL
308f e5					push hl		 ; hl now has starting counter which needs to be tos 
3090			 
3090					if DEBUG_FORTH_WORDS 
3090						DMARK "DO4" 
3090 f5				push af  
3091 3a a5 30			ld a, (.dmark)  
3094 32 6b ee			ld (debug_mark),a  
3097 3a a6 30			ld a, (.dmark+1)  
309a 32 6c ee			ld (debug_mark+1),a  
309d 3a a7 30			ld a, (.dmark+2)  
30a0 32 6d ee			ld (debug_mark+2),a  
30a3 18 03			jr .pastdmark  
30a5 ..			.dmark: db "DO4"  
30a8 f1			.pastdmark: pop af  
30a9			endm  
# End of macro DMARK
30a9						CALLMONITOR 
30a9 cd 6f ee			call debug_vector  
30ac				endm  
# End of macro CALLMONITOR
30ac					endif 
30ac					FORTH_DSP_POP 
30ac cd 5a 1e			call macro_forth_dsp_pop 
30af				endm 
# End of macro FORTH_DSP_POP
30af			 
30af					if DEBUG_FORTH_WORDS 
30af						DMARK "DO5" 
30af f5				push af  
30b0 3a c4 30			ld a, (.dmark)  
30b3 32 6b ee			ld (debug_mark),a  
30b6 3a c5 30			ld a, (.dmark+1)  
30b9 32 6c ee			ld (debug_mark+1),a  
30bc 3a c6 30			ld a, (.dmark+2)  
30bf 32 6d ee			ld (debug_mark+2),a  
30c2 18 03			jr .pastdmark  
30c4 ..			.dmark: db "DO5"  
30c7 f1			.pastdmark: pop af  
30c8			endm  
# End of macro DMARK
30c8						CALLMONITOR 
30c8 cd 6f ee			call debug_vector  
30cb				endm  
# End of macro CALLMONITOR
30cb					endif 
30cb			 
30cb					FORTH_DSP_VALUEHL 
30cb cd a2 1d			call macro_dsp_valuehl 
30ce				endm 
# End of macro FORTH_DSP_VALUEHL
30ce			;		push hl		 ; hl now has starting limit counter 
30ce			 
30ce					if DEBUG_FORTH_WORDS 
30ce						DMARK "DO6" 
30ce f5				push af  
30cf 3a e3 30			ld a, (.dmark)  
30d2 32 6b ee			ld (debug_mark),a  
30d5 3a e4 30			ld a, (.dmark+1)  
30d8 32 6c ee			ld (debug_mark+1),a  
30db 3a e5 30			ld a, (.dmark+2)  
30de 32 6d ee			ld (debug_mark+2),a  
30e1 18 03			jr .pastdmark  
30e3 ..			.dmark: db "DO6"  
30e6 f1			.pastdmark: pop af  
30e7			endm  
# End of macro DMARK
30e7						CALLMONITOR 
30e7 cd 6f ee			call debug_vector  
30ea				endm  
# End of macro CALLMONITOR
30ea					endif 
30ea					FORTH_DSP_POP 
30ea cd 5a 1e			call macro_forth_dsp_pop 
30ed				endm 
# End of macro FORTH_DSP_POP
30ed			 
30ed			; put counters on the loop stack 
30ed			 
30ed			;		pop hl			 ; limit counter 
30ed d1					pop de			; start counter 
30ee			 
30ee					; push limit counter 
30ee			 
30ee					if DEBUG_FORTH_WORDS 
30ee						DMARK "DO7" 
30ee f5				push af  
30ef 3a 03 31			ld a, (.dmark)  
30f2 32 6b ee			ld (debug_mark),a  
30f5 3a 04 31			ld a, (.dmark+1)  
30f8 32 6c ee			ld (debug_mark+1),a  
30fb 3a 05 31			ld a, (.dmark+2)  
30fe 32 6d ee			ld (debug_mark+2),a  
3101 18 03			jr .pastdmark  
3103 ..			.dmark: db "DO7"  
3106 f1			.pastdmark: pop af  
3107			endm  
# End of macro DMARK
3107						CALLMONITOR 
3107 cd 6f ee			call debug_vector  
310a				endm  
# End of macro CALLMONITOR
310a					endif 
310a					FORTH_LOOP_NEXT 
310a cd d3 1d			call macro_forth_loop_next 
310d				endm 
# End of macro FORTH_LOOP_NEXT
310d			 
310d					; push start counter 
310d			 
310d eb					ex de, hl 
310e					if DEBUG_FORTH_WORDS 
310e						DMARK "DO7" 
310e f5				push af  
310f 3a 23 31			ld a, (.dmark)  
3112 32 6b ee			ld (debug_mark),a  
3115 3a 24 31			ld a, (.dmark+1)  
3118 32 6c ee			ld (debug_mark+1),a  
311b 3a 25 31			ld a, (.dmark+2)  
311e 32 6d ee			ld (debug_mark+2),a  
3121 18 03			jr .pastdmark  
3123 ..			.dmark: db "DO7"  
3126 f1			.pastdmark: pop af  
3127			endm  
# End of macro DMARK
3127						CALLMONITOR 
3127 cd 6f ee			call debug_vector  
312a				endm  
# End of macro CALLMONITOR
312a					endif 
312a					FORTH_LOOP_NEXT 
312a cd d3 1d			call macro_forth_loop_next 
312d				endm 
# End of macro FORTH_LOOP_NEXT
312d			 
312d			 
312d					; init first round of I counter 
312d			 
312d 22 e6 e5				ld (os_current_i), hl 
3130			 
3130					if DEBUG_FORTH_WORDS 
3130						DMARK "DO8" 
3130 f5				push af  
3131 3a 45 31			ld a, (.dmark)  
3134 32 6b ee			ld (debug_mark),a  
3137 3a 46 31			ld a, (.dmark+1)  
313a 32 6c ee			ld (debug_mark+1),a  
313d 3a 47 31			ld a, (.dmark+2)  
3140 32 6d ee			ld (debug_mark+2),a  
3143 18 03			jr .pastdmark  
3145 ..			.dmark: db "DO8"  
3148 f1			.pastdmark: pop af  
3149			endm  
# End of macro DMARK
3149						CALLMONITOR 
3149 cd 6f ee			call debug_vector  
314c				endm  
# End of macro CALLMONITOR
314c					endif 
314c			 
314c					NEXTW 
314c c3 58 1f			jp macro_next 
314f				endm 
# End of macro NEXTW
314f			.LOOP: 
314f				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
314f 22				db WORD_SYS_CORE+14             
3150 67 32			dw .I            
3152 05				db 4 + 1 
3153 .. 00			db "LOOP",0              
3158				endm 
# End of macro CWHEAD
3158			; | LOOP ( -- ) Increment and test loop counter  | DONE 
3158			 
3158				; pop tos as current loop count to hl 
3158			 
3158				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3158			 
3158				FORTH_LOOP_TOS 
3158 cd 06 1e			call macro_forth_loop_tos 
315b				endm 
# End of macro FORTH_LOOP_TOS
315b e5				push hl 
315c			 
315c					if DEBUG_FORTH_WORDS_KEY 
315c						DMARK "LOP" 
315c f5				push af  
315d 3a 71 31			ld a, (.dmark)  
3160 32 6b ee			ld (debug_mark),a  
3163 3a 72 31			ld a, (.dmark+1)  
3166 32 6c ee			ld (debug_mark+1),a  
3169 3a 73 31			ld a, (.dmark+2)  
316c 32 6d ee			ld (debug_mark+2),a  
316f 18 03			jr .pastdmark  
3171 ..			.dmark: db "LOP"  
3174 f1			.pastdmark: pop af  
3175			endm  
# End of macro DMARK
3175						CALLMONITOR 
3175 cd 6f ee			call debug_vector  
3178				endm  
# End of macro CALLMONITOR
3178					endif 
3178				; next item on the stack is the limit. get it 
3178			 
3178			 
3178				FORTH_LOOP_POP 
3178 cd 10 1e			call macro_forth_loop_pop 
317b				endm 
# End of macro FORTH_LOOP_POP
317b			 
317b				FORTH_LOOP_TOS 
317b cd 06 1e			call macro_forth_loop_tos 
317e				endm 
# End of macro FORTH_LOOP_TOS
317e			 
317e d1				pop de		 ; de = i, hl = limit 
317f			 
317f					if DEBUG_FORTH_WORDS 
317f						DMARK "LP1" 
317f f5				push af  
3180 3a 94 31			ld a, (.dmark)  
3183 32 6b ee			ld (debug_mark),a  
3186 3a 95 31			ld a, (.dmark+1)  
3189 32 6c ee			ld (debug_mark+1),a  
318c 3a 96 31			ld a, (.dmark+2)  
318f 32 6d ee			ld (debug_mark+2),a  
3192 18 03			jr .pastdmark  
3194 ..			.dmark: db "LP1"  
3197 f1			.pastdmark: pop af  
3198			endm  
# End of macro DMARK
3198						CALLMONITOR 
3198 cd 6f ee			call debug_vector  
319b				endm  
# End of macro CALLMONITOR
319b					endif 
319b			 
319b				; go back to previous word 
319b			 
319b d5				push de    ; save I for inc later 
319c			 
319c			 
319c				; get limit 
319c				;  is I at limit? 
319c			 
319c			 
319c					if DEBUG_FORTH_WORDS 
319c						DMARK "LP1" 
319c f5				push af  
319d 3a b1 31			ld a, (.dmark)  
31a0 32 6b ee			ld (debug_mark),a  
31a3 3a b2 31			ld a, (.dmark+1)  
31a6 32 6c ee			ld (debug_mark+1),a  
31a9 3a b3 31			ld a, (.dmark+2)  
31ac 32 6d ee			ld (debug_mark+2),a  
31af 18 03			jr .pastdmark  
31b1 ..			.dmark: db "LP1"  
31b4 f1			.pastdmark: pop af  
31b5			endm  
# End of macro DMARK
31b5						CALLMONITOR 
31b5 cd 6f ee			call debug_vector  
31b8				endm  
# End of macro CALLMONITOR
31b8					endif 
31b8			 
31b8 ed 52			sbc hl, de 
31ba			 
31ba			 
31ba				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
31ba			 
31ba 20 26				jr nz, .loopnotdone 
31bc			 
31bc e1				pop hl   ; get rid of saved I 
31bd				FORTH_LOOP_POP     ; get rid of limit 
31bd cd 10 1e			call macro_forth_loop_pop 
31c0				endm 
# End of macro FORTH_LOOP_POP
31c0			 
31c0				FORTH_RSP_POP     ; get rid of DO ptr 
31c0 cd 73 1b			call macro_forth_rsp_pop 
31c3				endm 
# End of macro FORTH_RSP_POP
31c3			 
31c3			if DEBUG_FORTH_WORDS 
31c3						DMARK "LP>" 
31c3 f5				push af  
31c4 3a d8 31			ld a, (.dmark)  
31c7 32 6b ee			ld (debug_mark),a  
31ca 3a d9 31			ld a, (.dmark+1)  
31cd 32 6c ee			ld (debug_mark+1),a  
31d0 3a da 31			ld a, (.dmark+2)  
31d3 32 6d ee			ld (debug_mark+2),a  
31d6 18 03			jr .pastdmark  
31d8 ..			.dmark: db "LP>"  
31db f1			.pastdmark: pop af  
31dc			endm  
# End of macro DMARK
31dc				CALLMONITOR 
31dc cd 6f ee			call debug_vector  
31df				endm  
# End of macro CALLMONITOR
31df			endif 
31df			 
31df					NEXTW 
31df c3 58 1f			jp macro_next 
31e2				endm 
# End of macro NEXTW
31e2				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
31e2			 
31e2			.loopnotdone: 
31e2			 
31e2 e1				pop hl    ; get I 
31e3 23				inc hl 
31e4			 
31e4			   	; save new I 
31e4			 
31e4			 
31e4					; set I counter 
31e4			 
31e4 22 e6 e5				ld (os_current_i), hl 
31e7			 
31e7					if DEBUG_FORTH_WORDS 
31e7						DMARK "LPN" 
31e7 f5				push af  
31e8 3a fc 31			ld a, (.dmark)  
31eb 32 6b ee			ld (debug_mark),a  
31ee 3a fd 31			ld a, (.dmark+1)  
31f1 32 6c ee			ld (debug_mark+1),a  
31f4 3a fe 31			ld a, (.dmark+2)  
31f7 32 6d ee			ld (debug_mark+2),a  
31fa 18 03			jr .pastdmark  
31fc ..			.dmark: db "LPN"  
31ff f1			.pastdmark: pop af  
3200			endm  
# End of macro DMARK
3200					CALLMONITOR 
3200 cd 6f ee			call debug_vector  
3203				endm  
# End of macro CALLMONITOR
3203					endif 
3203					 
3203				FORTH_LOOP_NEXT 
3203 cd d3 1d			call macro_forth_loop_next 
3206				endm 
# End of macro FORTH_LOOP_NEXT
3206			 
3206			 
3206					if DEBUG_FORTH_WORDS 
3206 eb						ex de,hl 
3207					endif 
3207			 
3207			;	; get DO ptr 
3207			; 
3207					if DEBUG_FORTH_WORDS 
3207						DMARK "LP7" 
3207 f5				push af  
3208 3a 1c 32			ld a, (.dmark)  
320b 32 6b ee			ld (debug_mark),a  
320e 3a 1d 32			ld a, (.dmark+1)  
3211 32 6c ee			ld (debug_mark+1),a  
3214 3a 1e 32			ld a, (.dmark+2)  
3217 32 6d ee			ld (debug_mark+2),a  
321a 18 03			jr .pastdmark  
321c ..			.dmark: db "LP7"  
321f f1			.pastdmark: pop af  
3220			endm  
# End of macro DMARK
3220					CALLMONITOR 
3220 cd 6f ee			call debug_vector  
3223				endm  
# End of macro CALLMONITOR
3223					endif 
3223				FORTH_RSP_TOS 
3223 cd 69 1b			call macro_forth_rsp_tos 
3226				endm 
# End of macro FORTH_RSP_TOS
3226			 
3226					if DEBUG_FORTH_WORDS 
3226						DMARK "LP8" 
3226 f5				push af  
3227 3a 3b 32			ld a, (.dmark)  
322a 32 6b ee			ld (debug_mark),a  
322d 3a 3c 32			ld a, (.dmark+1)  
3230 32 6c ee			ld (debug_mark+1),a  
3233 3a 3d 32			ld a, (.dmark+2)  
3236 32 6d ee			ld (debug_mark+2),a  
3239 18 03			jr .pastdmark  
323b ..			.dmark: db "LP8"  
323e f1			.pastdmark: pop af  
323f			endm  
# End of macro DMARK
323f					CALLMONITOR 
323f cd 6f ee			call debug_vector  
3242				endm  
# End of macro CALLMONITOR
3242					endif 
3242				;push hl 
3242			 
3242				; not going to DO any more 
3242				; get rid of the RSP pointer as DO will add it back in 
3242				;FORTH_RSP_POP 
3242				;pop hl 
3242			 
3242				;ld hl,(cli_ret_sp) 
3242				;ld e, (hl) 
3242				;inc hl 
3242				;ld d, (hl) 
3242				;ex de,hl 
3242 22 c2 e5			ld (os_tok_ptr), hl 
3245					if DEBUG_FORTH_WORDS 
3245						DMARK "LP<" 
3245 f5				push af  
3246 3a 5a 32			ld a, (.dmark)  
3249 32 6b ee			ld (debug_mark),a  
324c 3a 5b 32			ld a, (.dmark+1)  
324f 32 6c ee			ld (debug_mark+1),a  
3252 3a 5c 32			ld a, (.dmark+2)  
3255 32 6d ee			ld (debug_mark+2),a  
3258 18 03			jr .pastdmark  
325a ..			.dmark: db "LP<"  
325d f1			.pastdmark: pop af  
325e			endm  
# End of macro DMARK
325e					CALLMONITOR 
325e cd 6f ee			call debug_vector  
3261				endm  
# End of macro CALLMONITOR
3261				endif 
3261 c3 e9 1f			jp exec1 
3264			 
3264					 
3264			 
3264			 
3264					NEXTW 
3264 c3 58 1f			jp macro_next 
3267				endm 
# End of macro NEXTW
3267			.I:  
3267			 
3267				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
3267 5e				db WORD_SYS_CORE+74             
3268 92 32			dw .DLOOP            
326a 02				db 1 + 1 
326b .. 00			db "I",0              
326d				endm 
# End of macro CWHEAD
326d			; | I ( -- ) Current loop counter | DONE 
326d					if DEBUG_FORTH_WORDS_KEY 
326d						DMARK "I.." 
326d f5				push af  
326e 3a 82 32			ld a, (.dmark)  
3271 32 6b ee			ld (debug_mark),a  
3274 3a 83 32			ld a, (.dmark+1)  
3277 32 6c ee			ld (debug_mark+1),a  
327a 3a 84 32			ld a, (.dmark+2)  
327d 32 6d ee			ld (debug_mark+2),a  
3280 18 03			jr .pastdmark  
3282 ..			.dmark: db "I.."  
3285 f1			.pastdmark: pop af  
3286			endm  
# End of macro DMARK
3286						CALLMONITOR 
3286 cd 6f ee			call debug_vector  
3289				endm  
# End of macro CALLMONITOR
3289					endif 
3289			 
3289 2a e6 e5				ld hl,(os_current_i) 
328c cd ab 1b				call forth_push_numhl 
328f			 
328f					NEXTW 
328f c3 58 1f			jp macro_next 
3292				endm 
# End of macro NEXTW
3292			.DLOOP: 
3292				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
3292 5f				db WORD_SYS_CORE+75             
3293 73 33			dw .REPEAT            
3295 06				db 5 + 1 
3296 .. 00			db "-LOOP",0              
329c				endm 
# End of macro CWHEAD
329c			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
329c				; pop tos as current loop count to hl 
329c					if DEBUG_FORTH_WORDS_KEY 
329c						DMARK "-LP" 
329c f5				push af  
329d 3a b1 32			ld a, (.dmark)  
32a0 32 6b ee			ld (debug_mark),a  
32a3 3a b2 32			ld a, (.dmark+1)  
32a6 32 6c ee			ld (debug_mark+1),a  
32a9 3a b3 32			ld a, (.dmark+2)  
32ac 32 6d ee			ld (debug_mark+2),a  
32af 18 03			jr .pastdmark  
32b1 ..			.dmark: db "-LP"  
32b4 f1			.pastdmark: pop af  
32b5			endm  
# End of macro DMARK
32b5						CALLMONITOR 
32b5 cd 6f ee			call debug_vector  
32b8				endm  
# End of macro CALLMONITOR
32b8					endif 
32b8			 
32b8				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
32b8			 
32b8				FORTH_LOOP_TOS 
32b8 cd 06 1e			call macro_forth_loop_tos 
32bb				endm 
# End of macro FORTH_LOOP_TOS
32bb e5				push hl 
32bc			 
32bc					if DEBUG_FORTH_WORDS 
32bc						DMARK "-LP" 
32bc f5				push af  
32bd 3a d1 32			ld a, (.dmark)  
32c0 32 6b ee			ld (debug_mark),a  
32c3 3a d2 32			ld a, (.dmark+1)  
32c6 32 6c ee			ld (debug_mark+1),a  
32c9 3a d3 32			ld a, (.dmark+2)  
32cc 32 6d ee			ld (debug_mark+2),a  
32cf 18 03			jr .pastdmark  
32d1 ..			.dmark: db "-LP"  
32d4 f1			.pastdmark: pop af  
32d5			endm  
# End of macro DMARK
32d5						CALLMONITOR 
32d5 cd 6f ee			call debug_vector  
32d8				endm  
# End of macro CALLMONITOR
32d8					endif 
32d8				; next item on the stack is the limit. get it 
32d8			 
32d8			 
32d8				FORTH_LOOP_POP 
32d8 cd 10 1e			call macro_forth_loop_pop 
32db				endm 
# End of macro FORTH_LOOP_POP
32db			 
32db				FORTH_LOOP_TOS 
32db cd 06 1e			call macro_forth_loop_tos 
32de				endm 
# End of macro FORTH_LOOP_TOS
32de			 
32de d1				pop de		 ; de = i, hl = limit 
32df			 
32df					if DEBUG_FORTH_WORDS 
32df						DMARK "-L1" 
32df f5				push af  
32e0 3a f4 32			ld a, (.dmark)  
32e3 32 6b ee			ld (debug_mark),a  
32e6 3a f5 32			ld a, (.dmark+1)  
32e9 32 6c ee			ld (debug_mark+1),a  
32ec 3a f6 32			ld a, (.dmark+2)  
32ef 32 6d ee			ld (debug_mark+2),a  
32f2 18 03			jr .pastdmark  
32f4 ..			.dmark: db "-L1"  
32f7 f1			.pastdmark: pop af  
32f8			endm  
# End of macro DMARK
32f8						CALLMONITOR 
32f8 cd 6f ee			call debug_vector  
32fb				endm  
# End of macro CALLMONITOR
32fb					endif 
32fb			 
32fb				; go back to previous word 
32fb			 
32fb d5				push de    ; save I for inc later 
32fc			 
32fc			 
32fc				; get limit 
32fc				;  is I at limit? 
32fc			 
32fc			 
32fc					if DEBUG_FORTH_WORDS 
32fc						DMARK "-L1" 
32fc f5				push af  
32fd 3a 11 33			ld a, (.dmark)  
3300 32 6b ee			ld (debug_mark),a  
3303 3a 12 33			ld a, (.dmark+1)  
3306 32 6c ee			ld (debug_mark+1),a  
3309 3a 13 33			ld a, (.dmark+2)  
330c 32 6d ee			ld (debug_mark+2),a  
330f 18 03			jr .pastdmark  
3311 ..			.dmark: db "-L1"  
3314 f1			.pastdmark: pop af  
3315			endm  
# End of macro DMARK
3315						CALLMONITOR 
3315 cd 6f ee			call debug_vector  
3318				endm  
# End of macro CALLMONITOR
3318					endif 
3318			 
3318 ed 52			sbc hl, de 
331a			 
331a			 
331a				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
331a			 
331a 20 26				jr nz, .mloopnotdone 
331c			 
331c e1				pop hl   ; get rid of saved I 
331d				FORTH_LOOP_POP     ; get rid of limit 
331d cd 10 1e			call macro_forth_loop_pop 
3320				endm 
# End of macro FORTH_LOOP_POP
3320			 
3320				FORTH_RSP_POP     ; get rid of DO ptr 
3320 cd 73 1b			call macro_forth_rsp_pop 
3323				endm 
# End of macro FORTH_RSP_POP
3323			 
3323			if DEBUG_FORTH_WORDS 
3323						DMARK "-L>" 
3323 f5				push af  
3324 3a 38 33			ld a, (.dmark)  
3327 32 6b ee			ld (debug_mark),a  
332a 3a 39 33			ld a, (.dmark+1)  
332d 32 6c ee			ld (debug_mark+1),a  
3330 3a 3a 33			ld a, (.dmark+2)  
3333 32 6d ee			ld (debug_mark+2),a  
3336 18 03			jr .pastdmark  
3338 ..			.dmark: db "-L>"  
333b f1			.pastdmark: pop af  
333c			endm  
# End of macro DMARK
333c				CALLMONITOR 
333c cd 6f ee			call debug_vector  
333f				endm  
# End of macro CALLMONITOR
333f			endif 
333f			 
333f					NEXTW 
333f c3 58 1f			jp macro_next 
3342				endm 
# End of macro NEXTW
3342				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3342			 
3342			.mloopnotdone: 
3342			 
3342 e1				pop hl    ; get I 
3343 2b				dec hl 
3344			 
3344			   	; save new I 
3344			 
3344			 
3344					; set I counter 
3344			 
3344 22 e6 e5				ld (os_current_i), hl 
3347			 
3347					 
3347				FORTH_LOOP_NEXT 
3347 cd d3 1d			call macro_forth_loop_next 
334a				endm 
# End of macro FORTH_LOOP_NEXT
334a			 
334a			 
334a					if DEBUG_FORTH_WORDS 
334a eb						ex de,hl 
334b					endif 
334b			 
334b			;	; get DO ptr 
334b			; 
334b				FORTH_RSP_TOS 
334b cd 69 1b			call macro_forth_rsp_tos 
334e				endm 
# End of macro FORTH_RSP_TOS
334e			 
334e				;push hl 
334e			 
334e				; not going to DO any more 
334e				; get rid of the RSP pointer as DO will add it back in 
334e				;FORTH_RSP_POP 
334e				;pop hl 
334e			 
334e			 
334e 22 c2 e5			ld (os_tok_ptr), hl 
3351					if DEBUG_FORTH_WORDS 
3351						DMARK "-L<" 
3351 f5				push af  
3352 3a 66 33			ld a, (.dmark)  
3355 32 6b ee			ld (debug_mark),a  
3358 3a 67 33			ld a, (.dmark+1)  
335b 32 6c ee			ld (debug_mark+1),a  
335e 3a 68 33			ld a, (.dmark+2)  
3361 32 6d ee			ld (debug_mark+2),a  
3364 18 03			jr .pastdmark  
3366 ..			.dmark: db "-L<"  
3369 f1			.pastdmark: pop af  
336a			endm  
# End of macro DMARK
336a					CALLMONITOR 
336a cd 6f ee			call debug_vector  
336d				endm  
# End of macro CALLMONITOR
336d				endif 
336d c3 e9 1f			jp exec1 
3370			 
3370					 
3370			 
3370			 
3370			 
3370				NEXTW 
3370 c3 58 1f			jp macro_next 
3373				endm 
# End of macro NEXTW
3373			 
3373			 
3373			 
3373			 
3373			.REPEAT: 
3373				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
3373 71				db WORD_SYS_CORE+93             
3374 c6 33			dw .UNTIL            
3376 06				db 5 + 1 
3377 .. 00			db "REPEAT",0              
337e				endm 
# End of macro CWHEAD
337e			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
337e			;  push pc to rsp stack past the REPEAT 
337e					if DEBUG_FORTH_WORDS_KEY 
337e						DMARK "REP" 
337e f5				push af  
337f 3a 93 33			ld a, (.dmark)  
3382 32 6b ee			ld (debug_mark),a  
3385 3a 94 33			ld a, (.dmark+1)  
3388 32 6c ee			ld (debug_mark+1),a  
338b 3a 95 33			ld a, (.dmark+2)  
338e 32 6d ee			ld (debug_mark+2),a  
3391 18 03			jr .pastdmark  
3393 ..			.dmark: db "REP"  
3396 f1			.pastdmark: pop af  
3397			endm  
# End of macro DMARK
3397						CALLMONITOR 
3397 cd 6f ee			call debug_vector  
339a				endm  
# End of macro CALLMONITOR
339a					endif 
339a			 
339a 2a c2 e5				ld hl, (os_tok_ptr) 
339d 23					inc hl   ; R 
339e 23					inc hl  ; E 
339f 23					inc hl   ; P 
33a0 23					inc hl   ; E 
33a1 23					inc hl   ; A 
33a2 23					inc hl   ; T 
33a3 23					inc hl   ; zero 
33a4					FORTH_RSP_NEXT 
33a4 cd 52 1b			call macro_forth_rsp_next 
33a7				endm 
# End of macro FORTH_RSP_NEXT
33a7			 
33a7			 
33a7					if DEBUG_FORTH_WORDS 
33a7						DMARK "REP" 
33a7 f5				push af  
33a8 3a bc 33			ld a, (.dmark)  
33ab 32 6b ee			ld (debug_mark),a  
33ae 3a bd 33			ld a, (.dmark+1)  
33b1 32 6c ee			ld (debug_mark+1),a  
33b4 3a be 33			ld a, (.dmark+2)  
33b7 32 6d ee			ld (debug_mark+2),a  
33ba 18 03			jr .pastdmark  
33bc ..			.dmark: db "REP"  
33bf f1			.pastdmark: pop af  
33c0			endm  
# End of macro DMARK
33c0						;pop bc    ; TODO BUG ?????? what is this for???? 
33c0						CALLMONITOR 
33c0 cd 6f ee			call debug_vector  
33c3				endm  
# End of macro CALLMONITOR
33c3					endif 
33c3			 
33c3					NEXTW 
33c3 c3 58 1f			jp macro_next 
33c6				endm 
# End of macro NEXTW
33c6			;	       NEXTW 
33c6			 
33c6			.UNTIL: 
33c6				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
33c6 72				db WORD_SYS_CORE+94             
33c7 5d 34			dw .ENDFLOW            
33c9 06				db 5 + 1 
33ca .. 00			db "UNTIL",0              
33d0				endm 
# End of macro CWHEAD
33d0			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
33d0			 
33d0				; pop tos as check 
33d0			 
33d0				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
33d0			 
33d0				FORTH_DSP_VALUEHL 
33d0 cd a2 1d			call macro_dsp_valuehl 
33d3				endm 
# End of macro FORTH_DSP_VALUEHL
33d3			 
33d3					if DEBUG_FORTH_WORDS_KEY 
33d3						DMARK "UNT" 
33d3 f5				push af  
33d4 3a e8 33			ld a, (.dmark)  
33d7 32 6b ee			ld (debug_mark),a  
33da 3a e9 33			ld a, (.dmark+1)  
33dd 32 6c ee			ld (debug_mark+1),a  
33e0 3a ea 33			ld a, (.dmark+2)  
33e3 32 6d ee			ld (debug_mark+2),a  
33e6 18 03			jr .pastdmark  
33e8 ..			.dmark: db "UNT"  
33eb f1			.pastdmark: pop af  
33ec			endm  
# End of macro DMARK
33ec						CALLMONITOR 
33ec cd 6f ee			call debug_vector  
33ef				endm  
# End of macro CALLMONITOR
33ef					endif 
33ef			 
33ef			;	push hl 
33ef				FORTH_DSP_POP 
33ef cd 5a 1e			call macro_forth_dsp_pop 
33f2				endm 
# End of macro FORTH_DSP_POP
33f2			 
33f2			;	pop hl 
33f2			 
33f2				; test if true 
33f2			 
33f2 cd 0f 0e			call ishlzero 
33f5			;	ld a,l 
33f5			;	add h 
33f5			; 
33f5			;	cp 0 
33f5			 
33f5 20 3e			jr nz, .untilnotdone 
33f7			 
33f7					if DEBUG_FORTH_WORDS 
33f7						DMARK "UNf" 
33f7 f5				push af  
33f8 3a 0c 34			ld a, (.dmark)  
33fb 32 6b ee			ld (debug_mark),a  
33fe 3a 0d 34			ld a, (.dmark+1)  
3401 32 6c ee			ld (debug_mark+1),a  
3404 3a 0e 34			ld a, (.dmark+2)  
3407 32 6d ee			ld (debug_mark+2),a  
340a 18 03			jr .pastdmark  
340c ..			.dmark: db "UNf"  
340f f1			.pastdmark: pop af  
3410			endm  
# End of macro DMARK
3410						CALLMONITOR 
3410 cd 6f ee			call debug_vector  
3413				endm  
# End of macro CALLMONITOR
3413					endif 
3413			 
3413			 
3413			 
3413				FORTH_RSP_POP     ; get rid of DO ptr 
3413 cd 73 1b			call macro_forth_rsp_pop 
3416				endm 
# End of macro FORTH_RSP_POP
3416			 
3416			if DEBUG_FORTH_WORDS 
3416						DMARK "UN>" 
3416 f5				push af  
3417 3a 2b 34			ld a, (.dmark)  
341a 32 6b ee			ld (debug_mark),a  
341d 3a 2c 34			ld a, (.dmark+1)  
3420 32 6c ee			ld (debug_mark+1),a  
3423 3a 2d 34			ld a, (.dmark+2)  
3426 32 6d ee			ld (debug_mark+2),a  
3429 18 03			jr .pastdmark  
342b ..			.dmark: db "UN>"  
342e f1			.pastdmark: pop af  
342f			endm  
# End of macro DMARK
342f				CALLMONITOR 
342f cd 6f ee			call debug_vector  
3432				endm  
# End of macro CALLMONITOR
3432			endif 
3432			 
3432					NEXTW 
3432 c3 58 1f			jp macro_next 
3435				endm 
# End of macro NEXTW
3435				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3435			 
3435			.untilnotdone: 
3435			 
3435			 
3435			;	; get DO ptr 
3435			; 
3435				FORTH_RSP_TOS 
3435 cd 69 1b			call macro_forth_rsp_tos 
3438				endm 
# End of macro FORTH_RSP_TOS
3438			 
3438				;push hl 
3438			 
3438				; not going to DO any more 
3438				; get rid of the RSP pointer as DO will add it back in 
3438				;FORTH_RSP_POP 
3438				;pop hl 
3438			 
3438			 
3438 22 c2 e5			ld (os_tok_ptr), hl 
343b					if DEBUG_FORTH_WORDS 
343b						DMARK "UN<" 
343b f5				push af  
343c 3a 50 34			ld a, (.dmark)  
343f 32 6b ee			ld (debug_mark),a  
3442 3a 51 34			ld a, (.dmark+1)  
3445 32 6c ee			ld (debug_mark+1),a  
3448 3a 52 34			ld a, (.dmark+2)  
344b 32 6d ee			ld (debug_mark+2),a  
344e 18 03			jr .pastdmark  
3450 ..			.dmark: db "UN<"  
3453 f1			.pastdmark: pop af  
3454			endm  
# End of macro DMARK
3454					CALLMONITOR 
3454 cd 6f ee			call debug_vector  
3457				endm  
# End of macro CALLMONITOR
3457				endif 
3457 c3 e9 1f			jp exec1 
345a			 
345a					 
345a			 
345a			 
345a					NEXTW 
345a c3 58 1f			jp macro_next 
345d				endm 
# End of macro NEXTW
345d			 
345d			 
345d			.ENDFLOW: 
345d			 
345d			; eof 
345d			 
# End of file forth_words_flow.asm
345d			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
345d			include "forth_words_logic.asm" 
345d			 
345d			; | ## Logic Words 
345d			 
345d			.NOT: 
345d				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
345d 2d				db WORD_SYS_CORE+25             
345e a5 34			dw .IS            
3460 04				db 3 + 1 
3461 .. 00			db "NOT",0              
3465				endm 
# End of macro CWHEAD
3465			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
3465					if DEBUG_FORTH_WORDS_KEY 
3465						DMARK "NOT" 
3465 f5				push af  
3466 3a 7a 34			ld a, (.dmark)  
3469 32 6b ee			ld (debug_mark),a  
346c 3a 7b 34			ld a, (.dmark+1)  
346f 32 6c ee			ld (debug_mark+1),a  
3472 3a 7c 34			ld a, (.dmark+2)  
3475 32 6d ee			ld (debug_mark+2),a  
3478 18 03			jr .pastdmark  
347a ..			.dmark: db "NOT"  
347d f1			.pastdmark: pop af  
347e			endm  
# End of macro DMARK
347e						CALLMONITOR 
347e cd 6f ee			call debug_vector  
3481				endm  
# End of macro CALLMONITOR
3481					endif 
3481					FORTH_DSP 
3481 cd 68 1d			call macro_forth_dsp 
3484				endm 
# End of macro FORTH_DSP
3484 7e					ld a,(hl)	; get type of value on TOS 
3485 fe 02				cp DS_TYPE_INUM  
3487 28 03				jr z, .noti 
3489					NEXTW 
3489 c3 58 1f			jp macro_next 
348c				endm 
# End of macro NEXTW
348c			.noti:          FORTH_DSP_VALUEHL 
348c cd a2 1d			call macro_dsp_valuehl 
348f				endm 
# End of macro FORTH_DSP_VALUEHL
348f			;		push hl 
348f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
348f cd 5a 1e			call macro_forth_dsp_pop 
3492				endm 
# End of macro FORTH_DSP_POP
3492			;		pop hl 
3492 3e 00				ld a,0 
3494 bd					cp l 
3495 28 04				jr z, .not2t 
3497 2e 00				ld l, 0 
3499 18 02				jr .notip 
349b			 
349b 2e ff		.not2t:		ld l, 255 
349d			 
349d 26 00		.notip:		ld h, 0	 
349f			 
349f cd ab 1b				call forth_push_numhl 
34a2					NEXTW 
34a2 c3 58 1f			jp macro_next 
34a5				endm 
# End of macro NEXTW
34a5			 
34a5			.IS: 
34a5				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
34a5 2d				db WORD_SYS_CORE+25             
34a6 cb 34			dw .LZERO            
34a8 03				db 2 + 1 
34a9 .. 00			db "IS",0              
34ac				endm 
# End of macro CWHEAD
34ac			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
34ac					if DEBUG_FORTH_WORDS_KEY 
34ac						DMARK "IS." 
34ac f5				push af  
34ad 3a c1 34			ld a, (.dmark)  
34b0 32 6b ee			ld (debug_mark),a  
34b3 3a c2 34			ld a, (.dmark+1)  
34b6 32 6c ee			ld (debug_mark+1),a  
34b9 3a c3 34			ld a, (.dmark+2)  
34bc 32 6d ee			ld (debug_mark+2),a  
34bf 18 03			jr .pastdmark  
34c1 ..			.dmark: db "IS."  
34c4 f1			.pastdmark: pop af  
34c5			endm  
# End of macro DMARK
34c5						CALLMONITOR 
34c5 cd 6f ee			call debug_vector  
34c8				endm  
# End of macro CALLMONITOR
34c8					endif 
34c8					NEXTW 
34c8 c3 58 1f			jp macro_next 
34cb				endm 
# End of macro NEXTW
34cb			.LZERO: 
34cb				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
34cb 2d				db WORD_SYS_CORE+25             
34cc d5 34			dw .TZERO            
34ce 03				db 2 + 1 
34cf .. 00			db "0<",0              
34d2				endm 
# End of macro CWHEAD
34d2			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
34d2					NEXTW 
34d2 c3 58 1f			jp macro_next 
34d5				endm 
# End of macro NEXTW
34d5			.TZERO: 
34d5				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
34d5 2e				db WORD_SYS_CORE+26             
34d6 1c 35			dw .LESS            
34d8 03				db 2 + 1 
34d9 .. 00			db "0=",0              
34dc				endm 
# End of macro CWHEAD
34dc			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
34dc				; TODO add floating point number detection 
34dc					;v5 FORTH_DSP_VALUE 
34dc					if DEBUG_FORTH_WORDS_KEY 
34dc						DMARK "0=." 
34dc f5				push af  
34dd 3a f1 34			ld a, (.dmark)  
34e0 32 6b ee			ld (debug_mark),a  
34e3 3a f2 34			ld a, (.dmark+1)  
34e6 32 6c ee			ld (debug_mark+1),a  
34e9 3a f3 34			ld a, (.dmark+2)  
34ec 32 6d ee			ld (debug_mark+2),a  
34ef 18 03			jr .pastdmark  
34f1 ..			.dmark: db "0=."  
34f4 f1			.pastdmark: pop af  
34f5			endm  
# End of macro DMARK
34f5						CALLMONITOR 
34f5 cd 6f ee			call debug_vector  
34f8				endm  
# End of macro CALLMONITOR
34f8					endif 
34f8					FORTH_DSP 
34f8 cd 68 1d			call macro_forth_dsp 
34fb				endm 
# End of macro FORTH_DSP
34fb 7e					ld a,(hl)	; get type of value on TOS 
34fc fe 02				cp DS_TYPE_INUM  
34fe 28 00				jr z, .tz_inum 
3500			 
3500				if FORTH_ENABLE_FLOATMATH 
3500					jr .tz_done 
3500			 
3500				endif 
3500					 
3500			 
3500			.tz_inum: 
3500					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3500 cd a2 1d			call macro_dsp_valuehl 
3503				endm 
# End of macro FORTH_DSP_VALUEHL
3503			 
3503			;		push hl 
3503			 
3503					; destroy value TOS 
3503			 
3503					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3503 cd 5a 1e			call macro_forth_dsp_pop 
3506				endm 
# End of macro FORTH_DSP_POP
3506			 
3506			;		pop hl 
3506			 
3506 3e 00				ld a,0 
3508			 
3508 bd					cp l 
3509 20 08				jr nz, .tz_notzero 
350b			 
350b bc					cp h 
350c			 
350c 20 05				jr nz, .tz_notzero 
350e			 
350e			 
350e 21 01 00				ld hl, FORTH_TRUE 
3511 18 03				jr .tz_done 
3513			 
3513 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
3516			 
3516					; push value back onto stack for another op etc 
3516			 
3516			.tz_done: 
3516 cd ab 1b				call forth_push_numhl 
3519			 
3519					NEXTW 
3519 c3 58 1f			jp macro_next 
351c				endm 
# End of macro NEXTW
351c			.LESS: 
351c				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
351c 2f				db WORD_SYS_CORE+27             
351d 85 35			dw .GT            
351f 02				db 1 + 1 
3520 .. 00			db "<",0              
3522				endm 
# End of macro CWHEAD
3522			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3522				; TODO add floating point number detection 
3522					if DEBUG_FORTH_WORDS_KEY 
3522						DMARK "LES" 
3522 f5				push af  
3523 3a 37 35			ld a, (.dmark)  
3526 32 6b ee			ld (debug_mark),a  
3529 3a 38 35			ld a, (.dmark+1)  
352c 32 6c ee			ld (debug_mark+1),a  
352f 3a 39 35			ld a, (.dmark+2)  
3532 32 6d ee			ld (debug_mark+2),a  
3535 18 03			jr .pastdmark  
3537 ..			.dmark: db "LES"  
353a f1			.pastdmark: pop af  
353b			endm  
# End of macro DMARK
353b						CALLMONITOR 
353b cd 6f ee			call debug_vector  
353e				endm  
# End of macro CALLMONITOR
353e					endif 
353e					FORTH_DSP 
353e cd 68 1d			call macro_forth_dsp 
3541				endm 
# End of macro FORTH_DSP
3541					;v5 FORTH_DSP_VALUE 
3541 7e					ld a,(hl)	; get type of value on TOS 
3542 fe 02				cp DS_TYPE_INUM  
3544 28 00				jr z, .less_inum 
3546			 
3546				if FORTH_ENABLE_FLOATMATH 
3546					jr .less_done 
3546			 
3546				endif 
3546					 
3546			 
3546			.less_inum: 
3546					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3546 cd a2 1d			call macro_dsp_valuehl 
3549				endm 
# End of macro FORTH_DSP_VALUEHL
3549			 
3549 e5					push hl  ; u2 
354a			 
354a					; destroy value TOS 
354a			 
354a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
354a cd 5a 1e			call macro_forth_dsp_pop 
354d				endm 
# End of macro FORTH_DSP_POP
354d			 
354d			 
354d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
354d cd a2 1d			call macro_dsp_valuehl 
3550				endm 
# End of macro FORTH_DSP_VALUEHL
3550			 
3550 e5					push hl    ; u1 
3551			 
3551					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3551 cd 5a 1e			call macro_forth_dsp_pop 
3554				endm 
# End of macro FORTH_DSP_POP
3554			 
3554			 
3554 b7			 or a      ;clear carry flag 
3555 01 00 00		 ld bc, FORTH_FALSE 
3558 e1			  pop hl    ; u1 
3559 d1			  pop de    ; u2 
355a ed 52		  sbc hl,de 
355c 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
355e			 
355e 01 01 00		 ld bc, FORTH_TRUE 
3561			.lscont:  
3561 c5					push bc 
3562 e1					pop hl 
3563			 
3563					if DEBUG_FORTH_WORDS 
3563						DMARK "LT1" 
3563 f5				push af  
3564 3a 78 35			ld a, (.dmark)  
3567 32 6b ee			ld (debug_mark),a  
356a 3a 79 35			ld a, (.dmark+1)  
356d 32 6c ee			ld (debug_mark+1),a  
3570 3a 7a 35			ld a, (.dmark+2)  
3573 32 6d ee			ld (debug_mark+2),a  
3576 18 03			jr .pastdmark  
3578 ..			.dmark: db "LT1"  
357b f1			.pastdmark: pop af  
357c			endm  
# End of macro DMARK
357c						CALLMONITOR 
357c cd 6f ee			call debug_vector  
357f				endm  
# End of macro CALLMONITOR
357f					endif 
357f cd ab 1b				call forth_push_numhl 
3582			 
3582					NEXTW 
3582 c3 58 1f			jp macro_next 
3585				endm 
# End of macro NEXTW
3585			.GT: 
3585				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
3585 30				db WORD_SYS_CORE+28             
3586 ee 35			dw .EQUAL            
3588 02				db 1 + 1 
3589 .. 00			db ">",0              
358b				endm 
# End of macro CWHEAD
358b			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
358b				; TODO add floating point number detection 
358b					if DEBUG_FORTH_WORDS_KEY 
358b						DMARK "GRT" 
358b f5				push af  
358c 3a a0 35			ld a, (.dmark)  
358f 32 6b ee			ld (debug_mark),a  
3592 3a a1 35			ld a, (.dmark+1)  
3595 32 6c ee			ld (debug_mark+1),a  
3598 3a a2 35			ld a, (.dmark+2)  
359b 32 6d ee			ld (debug_mark+2),a  
359e 18 03			jr .pastdmark  
35a0 ..			.dmark: db "GRT"  
35a3 f1			.pastdmark: pop af  
35a4			endm  
# End of macro DMARK
35a4						CALLMONITOR 
35a4 cd 6f ee			call debug_vector  
35a7				endm  
# End of macro CALLMONITOR
35a7					endif 
35a7					FORTH_DSP 
35a7 cd 68 1d			call macro_forth_dsp 
35aa				endm 
# End of macro FORTH_DSP
35aa					;FORTH_DSP_VALUE 
35aa 7e					ld a,(hl)	; get type of value on TOS 
35ab fe 02				cp DS_TYPE_INUM  
35ad 28 00				jr z, .gt_inum 
35af			 
35af				if FORTH_ENABLE_FLOATMATH 
35af					jr .gt_done 
35af			 
35af				endif 
35af					 
35af			 
35af			.gt_inum: 
35af					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35af cd a2 1d			call macro_dsp_valuehl 
35b2				endm 
# End of macro FORTH_DSP_VALUEHL
35b2			 
35b2 e5					push hl  ; u2 
35b3			 
35b3					; destroy value TOS 
35b3			 
35b3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35b3 cd 5a 1e			call macro_forth_dsp_pop 
35b6				endm 
# End of macro FORTH_DSP_POP
35b6			 
35b6			 
35b6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35b6 cd a2 1d			call macro_dsp_valuehl 
35b9				endm 
# End of macro FORTH_DSP_VALUEHL
35b9			 
35b9 e5					push hl    ; u1 
35ba			 
35ba					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35ba cd 5a 1e			call macro_forth_dsp_pop 
35bd				endm 
# End of macro FORTH_DSP_POP
35bd			 
35bd			 
35bd b7			 or a      ;clear carry flag 
35be 01 00 00		 ld bc, FORTH_FALSE 
35c1 e1			  pop hl    ; u1 
35c2 d1			  pop de    ; u2 
35c3 ed 52		  sbc hl,de 
35c5 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
35c7			 
35c7 01 01 00		 ld bc, FORTH_TRUE 
35ca			.gtcont:  
35ca c5					push bc 
35cb e1					pop hl 
35cc			 
35cc					if DEBUG_FORTH_WORDS 
35cc						DMARK "GT1" 
35cc f5				push af  
35cd 3a e1 35			ld a, (.dmark)  
35d0 32 6b ee			ld (debug_mark),a  
35d3 3a e2 35			ld a, (.dmark+1)  
35d6 32 6c ee			ld (debug_mark+1),a  
35d9 3a e3 35			ld a, (.dmark+2)  
35dc 32 6d ee			ld (debug_mark+2),a  
35df 18 03			jr .pastdmark  
35e1 ..			.dmark: db "GT1"  
35e4 f1			.pastdmark: pop af  
35e5			endm  
# End of macro DMARK
35e5						CALLMONITOR 
35e5 cd 6f ee			call debug_vector  
35e8				endm  
# End of macro CALLMONITOR
35e8					endif 
35e8 cd ab 1b				call forth_push_numhl 
35eb			 
35eb					NEXTW 
35eb c3 58 1f			jp macro_next 
35ee				endm 
# End of macro NEXTW
35ee			.EQUAL: 
35ee				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
35ee 31				db WORD_SYS_CORE+29             
35ef 59 36			dw .ENDLOGIC            
35f1 02				db 1 + 1 
35f2 .. 00			db "=",0              
35f4				endm 
# End of macro CWHEAD
35f4			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
35f4				; TODO add floating point number detection 
35f4					if DEBUG_FORTH_WORDS_KEY 
35f4						DMARK "EQ." 
35f4 f5				push af  
35f5 3a 09 36			ld a, (.dmark)  
35f8 32 6b ee			ld (debug_mark),a  
35fb 3a 0a 36			ld a, (.dmark+1)  
35fe 32 6c ee			ld (debug_mark+1),a  
3601 3a 0b 36			ld a, (.dmark+2)  
3604 32 6d ee			ld (debug_mark+2),a  
3607 18 03			jr .pastdmark  
3609 ..			.dmark: db "EQ."  
360c f1			.pastdmark: pop af  
360d			endm  
# End of macro DMARK
360d						CALLMONITOR 
360d cd 6f ee			call debug_vector  
3610				endm  
# End of macro CALLMONITOR
3610					endif 
3610					FORTH_DSP 
3610 cd 68 1d			call macro_forth_dsp 
3613				endm 
# End of macro FORTH_DSP
3613					;v5 FORTH_DSP_VALUE 
3613 7e					ld a,(hl)	; get type of value on TOS 
3614 fe 02				cp DS_TYPE_INUM  
3616 28 00				jr z, .eq_inum 
3618			 
3618				if FORTH_ENABLE_FLOATMATH 
3618					jr .eq_done 
3618			 
3618				endif 
3618					 
3618			 
3618			.eq_inum: 
3618					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3618 cd a2 1d			call macro_dsp_valuehl 
361b				endm 
# End of macro FORTH_DSP_VALUEHL
361b			 
361b e5					push hl 
361c			 
361c					; destroy value TOS 
361c			 
361c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
361c cd 5a 1e			call macro_forth_dsp_pop 
361f				endm 
# End of macro FORTH_DSP_POP
361f			 
361f			 
361f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
361f cd a2 1d			call macro_dsp_valuehl 
3622				endm 
# End of macro FORTH_DSP_VALUEHL
3622			 
3622					; one value on hl get other one back 
3622			 
3622 e5					push hl 
3623			 
3623					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3623 cd 5a 1e			call macro_forth_dsp_pop 
3626				endm 
# End of macro FORTH_DSP_POP
3626			 
3626 0e 00				ld c, FORTH_FALSE 
3628			 
3628 e1					pop hl 
3629 d1					pop de 
362a			 
362a 7b					ld a, e 
362b bd					cp l 
362c			 
362c 20 06				jr nz, .eq_done 
362e			 
362e 7a					ld a, d 
362f bc					cp h 
3630			 
3630 20 02				jr nz, .eq_done 
3632			 
3632 0e 01				ld c, FORTH_TRUE 
3634					 
3634			 
3634			 
3634			.eq_done: 
3634			 
3634					; TODO push value back onto stack for another op etc 
3634			 
3634 26 00				ld h, 0 
3636 69					ld l, c 
3637					if DEBUG_FORTH_WORDS 
3637						DMARK "EQ1" 
3637 f5				push af  
3638 3a 4c 36			ld a, (.dmark)  
363b 32 6b ee			ld (debug_mark),a  
363e 3a 4d 36			ld a, (.dmark+1)  
3641 32 6c ee			ld (debug_mark+1),a  
3644 3a 4e 36			ld a, (.dmark+2)  
3647 32 6d ee			ld (debug_mark+2),a  
364a 18 03			jr .pastdmark  
364c ..			.dmark: db "EQ1"  
364f f1			.pastdmark: pop af  
3650			endm  
# End of macro DMARK
3650						CALLMONITOR 
3650 cd 6f ee			call debug_vector  
3653				endm  
# End of macro CALLMONITOR
3653					endif 
3653 cd ab 1b				call forth_push_numhl 
3656			 
3656					NEXTW 
3656 c3 58 1f			jp macro_next 
3659				endm 
# End of macro NEXTW
3659			 
3659			 
3659			.ENDLOGIC: 
3659			; eof 
3659			 
3659			 
# End of file forth_words_logic.asm
3659			include "forth_words_maths.asm" 
3659			 
3659			; | ## Maths Words 
3659			 
3659			.PLUS:	 
3659				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3659 15				db WORD_SYS_CORE+1             
365a b7 36			dw .NEG            
365c 02				db 1 + 1 
365d .. 00			db "+",0              
365f				endm 
# End of macro CWHEAD
365f			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
365f					if DEBUG_FORTH_WORDS_KEY 
365f						DMARK "PLU" 
365f f5				push af  
3660 3a 74 36			ld a, (.dmark)  
3663 32 6b ee			ld (debug_mark),a  
3666 3a 75 36			ld a, (.dmark+1)  
3669 32 6c ee			ld (debug_mark+1),a  
366c 3a 76 36			ld a, (.dmark+2)  
366f 32 6d ee			ld (debug_mark+2),a  
3672 18 03			jr .pastdmark  
3674 ..			.dmark: db "PLU"  
3677 f1			.pastdmark: pop af  
3678			endm  
# End of macro DMARK
3678						CALLMONITOR 
3678 cd 6f ee			call debug_vector  
367b				endm  
# End of macro CALLMONITOR
367b					endif 
367b					; add top two values and push back result 
367b			 
367b					;for v5 FORTH_DSP_VALUE 
367b					FORTH_DSP 
367b cd 68 1d			call macro_forth_dsp 
367e				endm 
# End of macro FORTH_DSP
367e 7e					ld a,(hl)	; get type of value on TOS 
367f fe 02				cp DS_TYPE_INUM  
3681 28 03				jr z, .dot_inum 
3683			 
3683					NEXTW 
3683 c3 58 1f			jp macro_next 
3686				endm 
# End of macro NEXTW
3686			 
3686			; float maths 
3686			 
3686				if FORTH_ENABLE_FLOATMATH 
3686						inc hl      ; now at start of numeric as string 
3686			 
3686					if DEBUG_FORTH_MATHS 
3686						DMARK "ADD" 
3686				CALLMONITOR 
3686					endif 
3686			 
3686					;ld ix, hl 
3686					call CON 
3686			 
3686			 
3686					push hl 
3686					 
3686					 
3686			 
3686						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
3686			 
3686					; get next number 
3686			 
3686						FORTH_DSP_VALUE 
3686			 
3686						inc hl      ; now at start of numeric as string 
3686			 
3686					;ld ix, hl 
3686					call CON 
3686			 
3686					push hl 
3686			 
3686			 
3686						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3686			 
3686						; TODO do add 
3686			 
3686						call IADD 
3686			 
3686						; TODO get result back as ascii 
3686			 
3686						; TODO push result  
3686			 
3686			 
3686			 
3686						jr .dot_done 
3686				endif 
3686			 
3686			.dot_inum: 
3686			 
3686			 
3686					if DEBUG_FORTH_DOT 
3686						DMARK "+IT" 
3686 f5				push af  
3687 3a 9b 36			ld a, (.dmark)  
368a 32 6b ee			ld (debug_mark),a  
368d 3a 9c 36			ld a, (.dmark+1)  
3690 32 6c ee			ld (debug_mark+1),a  
3693 3a 9d 36			ld a, (.dmark+2)  
3696 32 6d ee			ld (debug_mark+2),a  
3699 18 03			jr .pastdmark  
369b ..			.dmark: db "+IT"  
369e f1			.pastdmark: pop af  
369f			endm  
# End of macro DMARK
369f				CALLMONITOR 
369f cd 6f ee			call debug_vector  
36a2				endm  
# End of macro CALLMONITOR
36a2					endif 
36a2			 
36a2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36a2 cd a2 1d			call macro_dsp_valuehl 
36a5				endm 
# End of macro FORTH_DSP_VALUEHL
36a5			 
36a5				; TODO add floating point number detection 
36a5			 
36a5 e5					push hl 
36a6			 
36a6					; destroy value TOS 
36a6			 
36a6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36a6 cd 5a 1e			call macro_forth_dsp_pop 
36a9				endm 
# End of macro FORTH_DSP_POP
36a9			 
36a9			 
36a9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36a9 cd a2 1d			call macro_dsp_valuehl 
36ac				endm 
# End of macro FORTH_DSP_VALUEHL
36ac			 
36ac					; one value on hl get other one back 
36ac			 
36ac d1					pop de 
36ad			 
36ad					; do the add 
36ad			 
36ad 19					add hl,de 
36ae			 
36ae					; save it 
36ae			 
36ae			;		push hl	 
36ae			 
36ae					; 
36ae			 
36ae					; destroy value TOS 
36ae			 
36ae					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36ae cd 5a 1e			call macro_forth_dsp_pop 
36b1				endm 
# End of macro FORTH_DSP_POP
36b1			 
36b1					; TODO push value back onto stack for another op etc 
36b1			 
36b1			;		pop hl 
36b1			 
36b1			.dot_done: 
36b1 cd ab 1b				call forth_push_numhl 
36b4			 
36b4					NEXTW 
36b4 c3 58 1f			jp macro_next 
36b7				endm 
# End of macro NEXTW
36b7			.NEG: 
36b7			 
36b7				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
36b7 17				db WORD_SYS_CORE+3             
36b8 fa 36			dw .DIV            
36ba 02				db 1 + 1 
36bb .. 00			db "-",0              
36bd				endm 
# End of macro CWHEAD
36bd			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
36bd					if DEBUG_FORTH_WORDS_KEY 
36bd						DMARK "SUB" 
36bd f5				push af  
36be 3a d2 36			ld a, (.dmark)  
36c1 32 6b ee			ld (debug_mark),a  
36c4 3a d3 36			ld a, (.dmark+1)  
36c7 32 6c ee			ld (debug_mark+1),a  
36ca 3a d4 36			ld a, (.dmark+2)  
36cd 32 6d ee			ld (debug_mark+2),a  
36d0 18 03			jr .pastdmark  
36d2 ..			.dmark: db "SUB"  
36d5 f1			.pastdmark: pop af  
36d6			endm  
# End of macro DMARK
36d6						CALLMONITOR 
36d6 cd 6f ee			call debug_vector  
36d9				endm  
# End of macro CALLMONITOR
36d9					endif 
36d9			 
36d9			 
36d9				; TODO add floating point number detection 
36d9					; v5 FORTH_DSP_VALUE 
36d9					FORTH_DSP 
36d9 cd 68 1d			call macro_forth_dsp 
36dc				endm 
# End of macro FORTH_DSP
36dc 7e					ld a,(hl)	; get type of value on TOS 
36dd fe 02				cp DS_TYPE_INUM  
36df 28 03				jr z, .neg_inum 
36e1			 
36e1					NEXTW 
36e1 c3 58 1f			jp macro_next 
36e4				endm 
# End of macro NEXTW
36e4			 
36e4			; float maths 
36e4			 
36e4				if FORTH_ENABLE_FLOATMATH 
36e4					jr .neg_done 
36e4			 
36e4				endif 
36e4					 
36e4			 
36e4			.neg_inum: 
36e4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36e4 cd a2 1d			call macro_dsp_valuehl 
36e7				endm 
# End of macro FORTH_DSP_VALUEHL
36e7			 
36e7 e5					push hl 
36e8			 
36e8					; destroy value TOS 
36e8			 
36e8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36e8 cd 5a 1e			call macro_forth_dsp_pop 
36eb				endm 
# End of macro FORTH_DSP_POP
36eb			 
36eb			 
36eb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36eb cd a2 1d			call macro_dsp_valuehl 
36ee				endm 
# End of macro FORTH_DSP_VALUEHL
36ee			 
36ee					; one value on hl get other one back 
36ee			 
36ee d1					pop de 
36ef			 
36ef					; do the sub 
36ef			;		ex de, hl 
36ef			 
36ef ed 52				sbc hl,de 
36f1			 
36f1					; save it 
36f1			 
36f1			;		push hl	 
36f1			 
36f1					; 
36f1			 
36f1					; destroy value TOS 
36f1			 
36f1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36f1 cd 5a 1e			call macro_forth_dsp_pop 
36f4				endm 
# End of macro FORTH_DSP_POP
36f4			 
36f4					; TODO push value back onto stack for another op etc 
36f4			 
36f4			;		pop hl 
36f4			 
36f4 cd ab 1b				call forth_push_numhl 
36f7			.neg_done: 
36f7			 
36f7					NEXTW 
36f7 c3 58 1f			jp macro_next 
36fa				endm 
# End of macro NEXTW
36fa			.DIV: 
36fa				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
36fa 18				db WORD_SYS_CORE+4             
36fb 47 37			dw .MUL            
36fd 02				db 1 + 1 
36fe .. 00			db "/",0              
3700				endm 
# End of macro CWHEAD
3700			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3700					if DEBUG_FORTH_WORDS_KEY 
3700						DMARK "DIV" 
3700 f5				push af  
3701 3a 15 37			ld a, (.dmark)  
3704 32 6b ee			ld (debug_mark),a  
3707 3a 16 37			ld a, (.dmark+1)  
370a 32 6c ee			ld (debug_mark+1),a  
370d 3a 17 37			ld a, (.dmark+2)  
3710 32 6d ee			ld (debug_mark+2),a  
3713 18 03			jr .pastdmark  
3715 ..			.dmark: db "DIV"  
3718 f1			.pastdmark: pop af  
3719			endm  
# End of macro DMARK
3719						CALLMONITOR 
3719 cd 6f ee			call debug_vector  
371c				endm  
# End of macro CALLMONITOR
371c					endif 
371c				; TODO add floating point number detection 
371c					; v5 FORTH_DSP_VALUE 
371c					FORTH_DSP 
371c cd 68 1d			call macro_forth_dsp 
371f				endm 
# End of macro FORTH_DSP
371f 7e					ld a,(hl)	; get type of value on TOS 
3720 fe 02				cp DS_TYPE_INUM  
3722 28 03				jr z, .div_inum 
3724			 
3724				if FORTH_ENABLE_FLOATMATH 
3724					jr .div_done 
3724			 
3724				endif 
3724					NEXTW 
3724 c3 58 1f			jp macro_next 
3727				endm 
# End of macro NEXTW
3727			.div_inum: 
3727			 
3727					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3727 cd a2 1d			call macro_dsp_valuehl 
372a				endm 
# End of macro FORTH_DSP_VALUEHL
372a			 
372a e5					push hl    ; to go to bc 
372b			 
372b					; destroy value TOS 
372b			 
372b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
372b cd 5a 1e			call macro_forth_dsp_pop 
372e				endm 
# End of macro FORTH_DSP_POP
372e			 
372e			 
372e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
372e cd a2 1d			call macro_dsp_valuehl 
3731				endm 
# End of macro FORTH_DSP_VALUEHL
3731			 
3731					; hl to go to de 
3731			 
3731 e5					push hl 
3732			 
3732 c1					pop bc 
3733 d1					pop de		 
3734			 
3734			 
3734					if DEBUG_FORTH_MATHS 
3734						DMARK "DIV" 
3734				CALLMONITOR 
3734					endif 
3734					; one value on hl but move to a get other one back 
3734			 
3734			        
3734 cd 43 0d			call Div16 
3737			 
3737			;	push af	 
3737 e5				push hl 
3738 c5				push bc 
3739			 
3739					if DEBUG_FORTH_MATHS 
3739						DMARK "DI1" 
3739				CALLMONITOR 
3739					endif 
3739			 
3739					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3739 cd 5a 1e			call macro_forth_dsp_pop 
373c				endm 
# End of macro FORTH_DSP_POP
373c			 
373c			 
373c			 
373c e1					pop hl    ; result 
373d			 
373d cd ab 1b				call forth_push_numhl 
3740			 
3740 e1					pop hl    ; reminder 
3741			;		ld h,0 
3741			;		ld l,d 
3741			 
3741 cd ab 1b				call forth_push_numhl 
3744			.div_done: 
3744					NEXTW 
3744 c3 58 1f			jp macro_next 
3747				endm 
# End of macro NEXTW
3747			.MUL: 
3747				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3747 19				db WORD_SYS_CORE+5             
3748 8c 37			dw .MIN            
374a 02				db 1 + 1 
374b .. 00			db "*",0              
374d				endm 
# End of macro CWHEAD
374d			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
374d				; TODO add floating point number detection 
374d					if DEBUG_FORTH_WORDS_KEY 
374d						DMARK "MUL" 
374d f5				push af  
374e 3a 62 37			ld a, (.dmark)  
3751 32 6b ee			ld (debug_mark),a  
3754 3a 63 37			ld a, (.dmark+1)  
3757 32 6c ee			ld (debug_mark+1),a  
375a 3a 64 37			ld a, (.dmark+2)  
375d 32 6d ee			ld (debug_mark+2),a  
3760 18 03			jr .pastdmark  
3762 ..			.dmark: db "MUL"  
3765 f1			.pastdmark: pop af  
3766			endm  
# End of macro DMARK
3766						CALLMONITOR 
3766 cd 6f ee			call debug_vector  
3769				endm  
# End of macro CALLMONITOR
3769					endif 
3769					FORTH_DSP 
3769 cd 68 1d			call macro_forth_dsp 
376c				endm 
# End of macro FORTH_DSP
376c					; v5 FORTH_DSP_VALUE 
376c 7e					ld a,(hl)	; get type of value on TOS 
376d fe 02				cp DS_TYPE_INUM  
376f 28 03				jr z, .mul_inum 
3771			 
3771				if FORTH_ENABLE_FLOATMATH 
3771					jr .mul_done 
3771			 
3771				endif 
3771			 
3771					NEXTW 
3771 c3 58 1f			jp macro_next 
3774				endm 
# End of macro NEXTW
3774			.mul_inum:	 
3774			 
3774					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3774 cd a2 1d			call macro_dsp_valuehl 
3777				endm 
# End of macro FORTH_DSP_VALUEHL
3777			 
3777 e5					push hl 
3778			 
3778					; destroy value TOS 
3778			 
3778					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3778 cd 5a 1e			call macro_forth_dsp_pop 
377b				endm 
# End of macro FORTH_DSP_POP
377b			 
377b			 
377b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
377b cd a2 1d			call macro_dsp_valuehl 
377e				endm 
# End of macro FORTH_DSP_VALUEHL
377e			 
377e					; one value on hl but move to a get other one back 
377e			 
377e 7d					ld a, l 
377f			 
377f d1					pop de 
3780			 
3780					; do the mull 
3780			;		ex de, hl 
3780			 
3780 cd 69 0d				call Mult16 
3783					; save it 
3783			 
3783			;		push hl	 
3783			 
3783					; 
3783			 
3783					; destroy value TOS 
3783			 
3783					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3783 cd 5a 1e			call macro_forth_dsp_pop 
3786				endm 
# End of macro FORTH_DSP_POP
3786			 
3786					; TODO push value back onto stack for another op etc 
3786			 
3786			;		pop hl 
3786			 
3786 cd ab 1b				call forth_push_numhl 
3789			 
3789			.mul_done: 
3789					NEXTW 
3789 c3 58 1f			jp macro_next 
378c				endm 
# End of macro NEXTW
378c			 
378c			 
378c			 
378c			 
378c			.MIN: 
378c				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
378c 49				db WORD_SYS_CORE+53             
378d 0d 38			dw .MAX            
378f 04				db 3 + 1 
3790 .. 00			db "MIN",0              
3794				endm 
# End of macro CWHEAD
3794			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3794					if DEBUG_FORTH_WORDS_KEY 
3794						DMARK "MIN" 
3794 f5				push af  
3795 3a a9 37			ld a, (.dmark)  
3798 32 6b ee			ld (debug_mark),a  
379b 3a aa 37			ld a, (.dmark+1)  
379e 32 6c ee			ld (debug_mark+1),a  
37a1 3a ab 37			ld a, (.dmark+2)  
37a4 32 6d ee			ld (debug_mark+2),a  
37a7 18 03			jr .pastdmark  
37a9 ..			.dmark: db "MIN"  
37ac f1			.pastdmark: pop af  
37ad			endm  
# End of macro DMARK
37ad						CALLMONITOR 
37ad cd 6f ee			call debug_vector  
37b0				endm  
# End of macro CALLMONITOR
37b0					endif 
37b0					; get u2 
37b0			 
37b0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37b0 cd a2 1d			call macro_dsp_valuehl 
37b3				endm 
# End of macro FORTH_DSP_VALUEHL
37b3			 
37b3 e5					push hl   ; u2 
37b4			 
37b4					; destroy value TOS 
37b4			 
37b4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37b4 cd 5a 1e			call macro_forth_dsp_pop 
37b7				endm 
# End of macro FORTH_DSP_POP
37b7			 
37b7					; get u1 
37b7			 
37b7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37b7 cd a2 1d			call macro_dsp_valuehl 
37ba				endm 
# End of macro FORTH_DSP_VALUEHL
37ba			 
37ba e5					push hl  ; u1 
37bb			 
37bb					; destroy value TOS 
37bb			 
37bb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37bb cd 5a 1e			call macro_forth_dsp_pop 
37be				endm 
# End of macro FORTH_DSP_POP
37be			 
37be b7			 or a      ;clear carry flag 
37bf e1			  pop hl    ; u1 
37c0 d1			  pop de    ; u2 
37c1 e5				push hl   ; saved in case hl is lowest 
37c2 ed 52		  sbc hl,de 
37c4 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
37c6			 
37c6 e1				pop hl 
37c7					if DEBUG_FORTH_WORDS 
37c7						DMARK "MIN" 
37c7 f5				push af  
37c8 3a dc 37			ld a, (.dmark)  
37cb 32 6b ee			ld (debug_mark),a  
37ce 3a dd 37			ld a, (.dmark+1)  
37d1 32 6c ee			ld (debug_mark+1),a  
37d4 3a de 37			ld a, (.dmark+2)  
37d7 32 6d ee			ld (debug_mark+2),a  
37da 18 03			jr .pastdmark  
37dc ..			.dmark: db "MIN"  
37df f1			.pastdmark: pop af  
37e0			endm  
# End of macro DMARK
37e0						CALLMONITOR 
37e0 cd 6f ee			call debug_vector  
37e3				endm  
# End of macro CALLMONITOR
37e3					endif 
37e3 cd ab 1b				call forth_push_numhl 
37e6			 
37e6				       NEXTW 
37e6 c3 58 1f			jp macro_next 
37e9				endm 
# End of macro NEXTW
37e9			 
37e9			.mincont:  
37e9 c1				pop bc   ; tidy up 
37ea eb				ex de , hl  
37eb					if DEBUG_FORTH_WORDS 
37eb						DMARK "MI1" 
37eb f5				push af  
37ec 3a 00 38			ld a, (.dmark)  
37ef 32 6b ee			ld (debug_mark),a  
37f2 3a 01 38			ld a, (.dmark+1)  
37f5 32 6c ee			ld (debug_mark+1),a  
37f8 3a 02 38			ld a, (.dmark+2)  
37fb 32 6d ee			ld (debug_mark+2),a  
37fe 18 03			jr .pastdmark  
3800 ..			.dmark: db "MI1"  
3803 f1			.pastdmark: pop af  
3804			endm  
# End of macro DMARK
3804						CALLMONITOR 
3804 cd 6f ee			call debug_vector  
3807				endm  
# End of macro CALLMONITOR
3807					endif 
3807 cd ab 1b				call forth_push_numhl 
380a			 
380a				       NEXTW 
380a c3 58 1f			jp macro_next 
380d				endm 
# End of macro NEXTW
380d			.MAX: 
380d				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
380d 4a				db WORD_SYS_CORE+54             
380e 8e 38			dw .RND16            
3810 04				db 3 + 1 
3811 .. 00			db "MAX",0              
3815				endm 
# End of macro CWHEAD
3815			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3815					if DEBUG_FORTH_WORDS_KEY 
3815						DMARK "MAX" 
3815 f5				push af  
3816 3a 2a 38			ld a, (.dmark)  
3819 32 6b ee			ld (debug_mark),a  
381c 3a 2b 38			ld a, (.dmark+1)  
381f 32 6c ee			ld (debug_mark+1),a  
3822 3a 2c 38			ld a, (.dmark+2)  
3825 32 6d ee			ld (debug_mark+2),a  
3828 18 03			jr .pastdmark  
382a ..			.dmark: db "MAX"  
382d f1			.pastdmark: pop af  
382e			endm  
# End of macro DMARK
382e						CALLMONITOR 
382e cd 6f ee			call debug_vector  
3831				endm  
# End of macro CALLMONITOR
3831					endif 
3831					; get u2 
3831			 
3831					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3831 cd a2 1d			call macro_dsp_valuehl 
3834				endm 
# End of macro FORTH_DSP_VALUEHL
3834			 
3834 e5					push hl   ; u2 
3835			 
3835					; destroy value TOS 
3835			 
3835					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3835 cd 5a 1e			call macro_forth_dsp_pop 
3838				endm 
# End of macro FORTH_DSP_POP
3838			 
3838					; get u1 
3838			 
3838					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3838 cd a2 1d			call macro_dsp_valuehl 
383b				endm 
# End of macro FORTH_DSP_VALUEHL
383b			 
383b e5					push hl  ; u1 
383c			 
383c					; destroy value TOS 
383c			 
383c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
383c cd 5a 1e			call macro_forth_dsp_pop 
383f				endm 
# End of macro FORTH_DSP_POP
383f			 
383f b7			 or a      ;clear carry flag 
3840 e1			  pop hl    ; u1 
3841 d1			  pop de    ; u2 
3842 e5				push hl   ; saved in case hl is lowest 
3843 ed 52		  sbc hl,de 
3845 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3847			 
3847 e1				pop hl 
3848					if DEBUG_FORTH_WORDS 
3848						DMARK "MAX" 
3848 f5				push af  
3849 3a 5d 38			ld a, (.dmark)  
384c 32 6b ee			ld (debug_mark),a  
384f 3a 5e 38			ld a, (.dmark+1)  
3852 32 6c ee			ld (debug_mark+1),a  
3855 3a 5f 38			ld a, (.dmark+2)  
3858 32 6d ee			ld (debug_mark+2),a  
385b 18 03			jr .pastdmark  
385d ..			.dmark: db "MAX"  
3860 f1			.pastdmark: pop af  
3861			endm  
# End of macro DMARK
3861						CALLMONITOR 
3861 cd 6f ee			call debug_vector  
3864				endm  
# End of macro CALLMONITOR
3864					endif 
3864 cd ab 1b				call forth_push_numhl 
3867			 
3867				       NEXTW 
3867 c3 58 1f			jp macro_next 
386a				endm 
# End of macro NEXTW
386a			 
386a			.maxcont:  
386a c1				pop bc   ; tidy up 
386b eb				ex de , hl  
386c					if DEBUG_FORTH_WORDS 
386c						DMARK "MA1" 
386c f5				push af  
386d 3a 81 38			ld a, (.dmark)  
3870 32 6b ee			ld (debug_mark),a  
3873 3a 82 38			ld a, (.dmark+1)  
3876 32 6c ee			ld (debug_mark+1),a  
3879 3a 83 38			ld a, (.dmark+2)  
387c 32 6d ee			ld (debug_mark+2),a  
387f 18 03			jr .pastdmark  
3881 ..			.dmark: db "MA1"  
3884 f1			.pastdmark: pop af  
3885			endm  
# End of macro DMARK
3885						CALLMONITOR 
3885 cd 6f ee			call debug_vector  
3888				endm  
# End of macro CALLMONITOR
3888					endif 
3888 cd ab 1b				call forth_push_numhl 
388b				       NEXTW 
388b c3 58 1f			jp macro_next 
388e				endm 
# End of macro NEXTW
388e			 
388e			.RND16: 
388e				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
388e 4e				db WORD_SYS_CORE+58             
388f bd 38			dw .RND8            
3891 06				db 5 + 1 
3892 .. 00			db "RND16",0              
3898				endm 
# End of macro CWHEAD
3898			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3898					if DEBUG_FORTH_WORDS_KEY 
3898						DMARK "R16" 
3898 f5				push af  
3899 3a ad 38			ld a, (.dmark)  
389c 32 6b ee			ld (debug_mark),a  
389f 3a ae 38			ld a, (.dmark+1)  
38a2 32 6c ee			ld (debug_mark+1),a  
38a5 3a af 38			ld a, (.dmark+2)  
38a8 32 6d ee			ld (debug_mark+2),a  
38ab 18 03			jr .pastdmark  
38ad ..			.dmark: db "R16"  
38b0 f1			.pastdmark: pop af  
38b1			endm  
# End of macro DMARK
38b1						CALLMONITOR 
38b1 cd 6f ee			call debug_vector  
38b4				endm  
# End of macro CALLMONITOR
38b4					endif 
38b4 cd 0d 0d				call prng16  
38b7 cd ab 1b				call forth_push_numhl 
38ba				       NEXTW 
38ba c3 58 1f			jp macro_next 
38bd				endm 
# End of macro NEXTW
38bd			.RND8: 
38bd				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
38bd 60				db WORD_SYS_CORE+76             
38be f2 38			dw .RND            
38c0 05				db 4 + 1 
38c1 .. 00			db "RND8",0              
38c6				endm 
# End of macro CWHEAD
38c6			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
38c6					if DEBUG_FORTH_WORDS_KEY 
38c6						DMARK "RN8" 
38c6 f5				push af  
38c7 3a db 38			ld a, (.dmark)  
38ca 32 6b ee			ld (debug_mark),a  
38cd 3a dc 38			ld a, (.dmark+1)  
38d0 32 6c ee			ld (debug_mark+1),a  
38d3 3a dd 38			ld a, (.dmark+2)  
38d6 32 6d ee			ld (debug_mark+2),a  
38d9 18 03			jr .pastdmark  
38db ..			.dmark: db "RN8"  
38de f1			.pastdmark: pop af  
38df			endm  
# End of macro DMARK
38df						CALLMONITOR 
38df cd 6f ee			call debug_vector  
38e2				endm  
# End of macro CALLMONITOR
38e2					endif 
38e2 2a a9 eb				ld hl,(xrandc) 
38e5 23					inc hl 
38e6 cd 27 0d				call xrnd 
38e9 6f					ld l,a	 
38ea 26 00				ld h,0 
38ec cd ab 1b				call forth_push_numhl 
38ef				       NEXTW 
38ef c3 58 1f			jp macro_next 
38f2				endm 
# End of macro NEXTW
38f2			.RND: 
38f2				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
38f2 60				db WORD_SYS_CORE+76             
38f3 f8 39			dw .ENDMATHS            
38f5 04				db 3 + 1 
38f6 .. 00			db "RND",0              
38fa				endm 
# End of macro CWHEAD
38fa			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
38fa			 
38fa					if DEBUG_FORTH_WORDS_KEY 
38fa						DMARK "RND" 
38fa f5				push af  
38fb 3a 0f 39			ld a, (.dmark)  
38fe 32 6b ee			ld (debug_mark),a  
3901 3a 10 39			ld a, (.dmark+1)  
3904 32 6c ee			ld (debug_mark+1),a  
3907 3a 11 39			ld a, (.dmark+2)  
390a 32 6d ee			ld (debug_mark+2),a  
390d 18 03			jr .pastdmark  
390f ..			.dmark: db "RND"  
3912 f1			.pastdmark: pop af  
3913			endm  
# End of macro DMARK
3913						CALLMONITOR 
3913 cd 6f ee			call debug_vector  
3916				endm  
# End of macro CALLMONITOR
3916					endif 
3916					 
3916					FORTH_DSP_VALUEHL    ; upper range 
3916 cd a2 1d			call macro_dsp_valuehl 
3919				endm 
# End of macro FORTH_DSP_VALUEHL
3919			 
3919 22 ad eb				ld (LFSRSeed), hl	 
391c			 
391c					if DEBUG_FORTH_WORDS 
391c						DMARK "RN1" 
391c f5				push af  
391d 3a 31 39			ld a, (.dmark)  
3920 32 6b ee			ld (debug_mark),a  
3923 3a 32 39			ld a, (.dmark+1)  
3926 32 6c ee			ld (debug_mark+1),a  
3929 3a 33 39			ld a, (.dmark+2)  
392c 32 6d ee			ld (debug_mark+2),a  
392f 18 03			jr .pastdmark  
3931 ..			.dmark: db "RN1"  
3934 f1			.pastdmark: pop af  
3935			endm  
# End of macro DMARK
3935						CALLMONITOR 
3935 cd 6f ee			call debug_vector  
3938				endm  
# End of macro CALLMONITOR
3938					endif 
3938					FORTH_DSP_POP 
3938 cd 5a 1e			call macro_forth_dsp_pop 
393b				endm 
# End of macro FORTH_DSP_POP
393b			 
393b					FORTH_DSP_VALUEHL    ; low range 
393b cd a2 1d			call macro_dsp_valuehl 
393e				endm 
# End of macro FORTH_DSP_VALUEHL
393e			 
393e					if DEBUG_FORTH_WORDS 
393e						DMARK "RN2" 
393e f5				push af  
393f 3a 53 39			ld a, (.dmark)  
3942 32 6b ee			ld (debug_mark),a  
3945 3a 54 39			ld a, (.dmark+1)  
3948 32 6c ee			ld (debug_mark+1),a  
394b 3a 55 39			ld a, (.dmark+2)  
394e 32 6d ee			ld (debug_mark+2),a  
3951 18 03			jr .pastdmark  
3953 ..			.dmark: db "RN2"  
3956 f1			.pastdmark: pop af  
3957			endm  
# End of macro DMARK
3957						CALLMONITOR 
3957 cd 6f ee			call debug_vector  
395a				endm  
# End of macro CALLMONITOR
395a					endif 
395a 22 af eb				ld (LFSRSeed+2), hl 
395d			 
395d					FORTH_DSP_POP 
395d cd 5a 1e			call macro_forth_dsp_pop 
3960				endm 
# End of macro FORTH_DSP_POP
3960			 
3960 e5					push hl 
3961			 
3961 e1			.inrange:	pop hl 
3962 cd 0d 0d				call prng16  
3965					if DEBUG_FORTH_WORDS 
3965						DMARK "RN3" 
3965 f5				push af  
3966 3a 7a 39			ld a, (.dmark)  
3969 32 6b ee			ld (debug_mark),a  
396c 3a 7b 39			ld a, (.dmark+1)  
396f 32 6c ee			ld (debug_mark+1),a  
3972 3a 7c 39			ld a, (.dmark+2)  
3975 32 6d ee			ld (debug_mark+2),a  
3978 18 03			jr .pastdmark  
397a ..			.dmark: db "RN3"  
397d f1			.pastdmark: pop af  
397e			endm  
# End of macro DMARK
397e						CALLMONITOR 
397e cd 6f ee			call debug_vector  
3981				endm  
# End of macro CALLMONITOR
3981					endif 
3981					 
3981					; if the range is 8bit knock out the high byte 
3981			 
3981 ed 5b ad eb			ld de, (LFSRSeed)     ; check high level 
3985			 
3985 3e 00				ld a, 0 
3987 ba					cp d  
3988 20 1e				jr nz, .hirange 
398a 26 00				ld h, 0   ; knock it down to 8bit 
398c			 
398c					if DEBUG_FORTH_WORDS 
398c						DMARK "RNk" 
398c f5				push af  
398d 3a a1 39			ld a, (.dmark)  
3990 32 6b ee			ld (debug_mark),a  
3993 3a a2 39			ld a, (.dmark+1)  
3996 32 6c ee			ld (debug_mark+1),a  
3999 3a a3 39			ld a, (.dmark+2)  
399c 32 6d ee			ld (debug_mark+2),a  
399f 18 03			jr .pastdmark  
39a1 ..			.dmark: db "RNk"  
39a4 f1			.pastdmark: pop af  
39a5			endm  
# End of macro DMARK
39a5						CALLMONITOR 
39a5 cd 6f ee			call debug_vector  
39a8				endm  
# End of macro CALLMONITOR
39a8					endif 
39a8			.hirange:   
39a8 e5					push hl  
39a9 b7					or a  
39aa ed 52		                sbc hl, de 
39ac			 
39ac					;call cmp16 
39ac			 
39ac 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
39ae e1					pop hl 
39af e5					push hl 
39b0			 
39b0					if DEBUG_FORTH_WORDS 
39b0						DMARK "RN4" 
39b0 f5				push af  
39b1 3a c5 39			ld a, (.dmark)  
39b4 32 6b ee			ld (debug_mark),a  
39b7 3a c6 39			ld a, (.dmark+1)  
39ba 32 6c ee			ld (debug_mark+1),a  
39bd 3a c7 39			ld a, (.dmark+2)  
39c0 32 6d ee			ld (debug_mark+2),a  
39c3 18 03			jr .pastdmark  
39c5 ..			.dmark: db "RN4"  
39c8 f1			.pastdmark: pop af  
39c9			endm  
# End of macro DMARK
39c9						CALLMONITOR 
39c9 cd 6f ee			call debug_vector  
39cc				endm  
# End of macro CALLMONITOR
39cc					endif 
39cc ed 5b af eb			ld de, (LFSRSeed+2)   ; check low range 
39d0					;call cmp16 
39d0				 
39d0 b7					or a  
39d1 ed 52		                sbc hl, de 
39d3 38 8c				jr c, .inrange 
39d5			 
39d5 e1					pop hl 
39d6					 
39d6					if DEBUG_FORTH_WORDS 
39d6						DMARK "RNd" 
39d6 f5				push af  
39d7 3a eb 39			ld a, (.dmark)  
39da 32 6b ee			ld (debug_mark),a  
39dd 3a ec 39			ld a, (.dmark+1)  
39e0 32 6c ee			ld (debug_mark+1),a  
39e3 3a ed 39			ld a, (.dmark+2)  
39e6 32 6d ee			ld (debug_mark+2),a  
39e9 18 03			jr .pastdmark  
39eb ..			.dmark: db "RNd"  
39ee f1			.pastdmark: pop af  
39ef			endm  
# End of macro DMARK
39ef						CALLMONITOR 
39ef cd 6f ee			call debug_vector  
39f2				endm  
# End of macro CALLMONITOR
39f2					endif 
39f2			 
39f2			 
39f2 cd ab 1b				call forth_push_numhl 
39f5				       NEXTW 
39f5 c3 58 1f			jp macro_next 
39f8				endm 
# End of macro NEXTW
39f8			 
39f8			.ENDMATHS: 
39f8			 
39f8			; eof 
39f8			 
# End of file forth_words_maths.asm
39f8			include "forth_words_display.asm" 
39f8			 
39f8			; | ## Display Words 
39f8			 
39f8			.ACT: 
39f8			 
39f8				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
39f8 62				db WORD_SYS_CORE+78             
39f9 44 3a			dw .INFO            
39fb 07				db 6 + 1 
39fc .. 00			db "ACTIVE",0              
3a03				endm 
# End of macro CWHEAD
3a03			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
3a03			;  
3a03			; | | To display a pulsing activity indicator in a processing loop do this... 
3a03			; | | e.g. $ff $00 do active . ..... Your code ..... loop 
3a03			 
3a03					if DEBUG_FORTH_WORDS_KEY 
3a03						DMARK "ACT" 
3a03 f5				push af  
3a04 3a 18 3a			ld a, (.dmark)  
3a07 32 6b ee			ld (debug_mark),a  
3a0a 3a 19 3a			ld a, (.dmark+1)  
3a0d 32 6c ee			ld (debug_mark+1),a  
3a10 3a 1a 3a			ld a, (.dmark+2)  
3a13 32 6d ee			ld (debug_mark+2),a  
3a16 18 03			jr .pastdmark  
3a18 ..			.dmark: db "ACT"  
3a1b f1			.pastdmark: pop af  
3a1c			endm  
# End of macro DMARK
3a1c						CALLMONITOR 
3a1c cd 6f ee			call debug_vector  
3a1f				endm  
# End of macro CALLMONITOR
3a1f					endif 
3a1f cd 10 0b				call active 
3a22					if DEBUG_FORTH_WORDS 
3a22						DMARK "ACp" 
3a22 f5				push af  
3a23 3a 37 3a			ld a, (.dmark)  
3a26 32 6b ee			ld (debug_mark),a  
3a29 3a 38 3a			ld a, (.dmark+1)  
3a2c 32 6c ee			ld (debug_mark+1),a  
3a2f 3a 39 3a			ld a, (.dmark+2)  
3a32 32 6d ee			ld (debug_mark+2),a  
3a35 18 03			jr .pastdmark  
3a37 ..			.dmark: db "ACp"  
3a3a f1			.pastdmark: pop af  
3a3b			endm  
# End of macro DMARK
3a3b						CALLMONITOR 
3a3b cd 6f ee			call debug_vector  
3a3e				endm  
# End of macro CALLMONITOR
3a3e					endif 
3a3e cd 19 1c				call forth_push_str 
3a41			 
3a41					NEXTW 
3a41 c3 58 1f			jp macro_next 
3a44				endm 
# End of macro NEXTW
3a44			.INFO: 
3a44			 
3a44				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3a44 62				db WORD_SYS_CORE+78             
3a45 61 3a			dw .ATP            
3a47 05				db 4 + 1 
3a48 .. 00			db "INFO",0              
3a4d				endm 
# End of macro CWHEAD
3a4d			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3a4d					FORTH_DSP_VALUEHL 
3a4d cd a2 1d			call macro_dsp_valuehl 
3a50				endm 
# End of macro FORTH_DSP_VALUEHL
3a50			 
3a50					FORTH_DSP_POP 
3a50 cd 5a 1e			call macro_forth_dsp_pop 
3a53				endm 
# End of macro FORTH_DSP_POP
3a53			 
3a53 e5					push hl 
3a54			 
3a54					FORTH_DSP_VALUEHL 
3a54 cd a2 1d			call macro_dsp_valuehl 
3a57				endm 
# End of macro FORTH_DSP_VALUEHL
3a57			 
3a57					FORTH_DSP_POP 
3a57 cd 5a 1e			call macro_forth_dsp_pop 
3a5a				endm 
# End of macro FORTH_DSP_POP
3a5a			 
3a5a d1					pop de 
3a5b			 
3a5b cd 4a 0b				call info_panel 
3a5e			 
3a5e			 
3a5e					NEXTW 
3a5e c3 58 1f			jp macro_next 
3a61				endm 
# End of macro NEXTW
3a61			.ATP: 
3a61				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3a61 62				db WORD_SYS_CORE+78             
3a62 d8 3a			dw .FB            
3a64 04				db 3 + 1 
3a65 .. 00			db "AT?",0              
3a69				endm 
# End of macro CWHEAD
3a69			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3a69					if DEBUG_FORTH_WORDS_KEY 
3a69						DMARK "AT?" 
3a69 f5				push af  
3a6a 3a 7e 3a			ld a, (.dmark)  
3a6d 32 6b ee			ld (debug_mark),a  
3a70 3a 7f 3a			ld a, (.dmark+1)  
3a73 32 6c ee			ld (debug_mark+1),a  
3a76 3a 80 3a			ld a, (.dmark+2)  
3a79 32 6d ee			ld (debug_mark+2),a  
3a7c 18 03			jr .pastdmark  
3a7e ..			.dmark: db "AT?"  
3a81 f1			.pastdmark: pop af  
3a82			endm  
# End of macro DMARK
3a82						CALLMONITOR 
3a82 cd 6f ee			call debug_vector  
3a85				endm  
# End of macro CALLMONITOR
3a85					endif 
3a85 3a 5e ea				ld a, (f_cursor_ptr) 
3a88			 
3a88			if DEBUG_FORTH_WORDS 
3a88				DMARK "AT?" 
3a88 f5				push af  
3a89 3a 9d 3a			ld a, (.dmark)  
3a8c 32 6b ee			ld (debug_mark),a  
3a8f 3a 9e 3a			ld a, (.dmark+1)  
3a92 32 6c ee			ld (debug_mark+1),a  
3a95 3a 9f 3a			ld a, (.dmark+2)  
3a98 32 6d ee			ld (debug_mark+2),a  
3a9b 18 03			jr .pastdmark  
3a9d ..			.dmark: db "AT?"  
3aa0 f1			.pastdmark: pop af  
3aa1			endm  
# End of macro DMARK
3aa1				CALLMONITOR 
3aa1 cd 6f ee			call debug_vector  
3aa4				endm  
# End of macro CALLMONITOR
3aa4			endif	 
3aa4					; count the number of rows 
3aa4			 
3aa4 06 00				ld b, 0 
3aa6 4f			.atpr:		ld c, a    ; save in case we go below zero 
3aa7 d6 28				sub display_cols 
3aa9 f2 af 3a				jp p, .atprunder 
3aac 04					inc b 
3aad 18 f7				jr .atpr 
3aaf			.atprunder:	 
3aaf			if DEBUG_FORTH_WORDS 
3aaf				DMARK "A?2" 
3aaf f5				push af  
3ab0 3a c4 3a			ld a, (.dmark)  
3ab3 32 6b ee			ld (debug_mark),a  
3ab6 3a c5 3a			ld a, (.dmark+1)  
3ab9 32 6c ee			ld (debug_mark+1),a  
3abc 3a c6 3a			ld a, (.dmark+2)  
3abf 32 6d ee			ld (debug_mark+2),a  
3ac2 18 03			jr .pastdmark  
3ac4 ..			.dmark: db "A?2"  
3ac7 f1			.pastdmark: pop af  
3ac8			endm  
# End of macro DMARK
3ac8				CALLMONITOR 
3ac8 cd 6f ee			call debug_vector  
3acb				endm  
# End of macro CALLMONITOR
3acb			endif	 
3acb 26 00				ld h, 0 
3acd 69					ld l, c 
3ace cd ab 1b				call forth_push_numhl 
3ad1 68					ld l, b  
3ad2 cd ab 1b				call forth_push_numhl 
3ad5			 
3ad5			 
3ad5				NEXTW 
3ad5 c3 58 1f			jp macro_next 
3ad8				endm 
# End of macro NEXTW
3ad8			 
3ad8			.FB: 
3ad8				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3ad8 1b				db WORD_SYS_CORE+7             
3ad9 26 3b			dw .EMIT            
3adb 03				db 2 + 1 
3adc .. 00			db "FB",0              
3adf				endm 
# End of macro CWHEAD
3adf			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3adf			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3adf			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3adf			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3adf					if DEBUG_FORTH_WORDS_KEY 
3adf						DMARK "FB." 
3adf f5				push af  
3ae0 3a f4 3a			ld a, (.dmark)  
3ae3 32 6b ee			ld (debug_mark),a  
3ae6 3a f5 3a			ld a, (.dmark+1)  
3ae9 32 6c ee			ld (debug_mark+1),a  
3aec 3a f6 3a			ld a, (.dmark+2)  
3aef 32 6d ee			ld (debug_mark+2),a  
3af2 18 03			jr .pastdmark  
3af4 ..			.dmark: db "FB."  
3af7 f1			.pastdmark: pop af  
3af8			endm  
# End of macro DMARK
3af8						CALLMONITOR 
3af8 cd 6f ee			call debug_vector  
3afb				endm  
# End of macro CALLMONITOR
3afb					endif 
3afb			 
3afb					FORTH_DSP_VALUEHL 
3afb cd a2 1d			call macro_dsp_valuehl 
3afe				endm 
# End of macro FORTH_DSP_VALUEHL
3afe			 
3afe 7d					ld a, l 
3aff fe 01				cp 1 
3b01 20 05				jr nz, .fbn1 
3b03 21 10 ed				ld hl, display_fb1 
3b06 18 15				jr .fbset 
3b08 fe 02		.fbn1:		cp 2 
3b0a 20 05				jr nz, .fbn2 
3b0c 21 ce eb				ld hl, display_fb2 
3b0f 18 0c				jr .fbset 
3b11 fe 03		.fbn2:		cp 3 
3b13 20 05				jr nz, .fbn3 
3b15 21 6f ec				ld hl, display_fb3 
3b18 18 03				jr .fbset 
3b1a			.fbn3:		 ; if invalid number select first 
3b1a 21 10 ed				ld hl, display_fb1 
3b1d 22 cc eb		.fbset:		ld (display_fb_active), hl 
3b20			 
3b20					FORTH_DSP_POP 
3b20 cd 5a 1e			call macro_forth_dsp_pop 
3b23				endm 
# End of macro FORTH_DSP_POP
3b23			 
3b23					NEXTW 
3b23 c3 58 1f			jp macro_next 
3b26				endm 
# End of macro NEXTW
3b26			 
3b26			 
3b26			.EMIT: 
3b26				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3b26 1b				db WORD_SYS_CORE+7             
3b27 77 3b			dw .DOTH            
3b29 05				db 4 + 1 
3b2a .. 00			db "EMIT",0              
3b2f				endm 
# End of macro CWHEAD
3b2f			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3b2f					; get value off TOS and display it 
3b2f			 
3b2f					if DEBUG_FORTH_WORDS_KEY 
3b2f						DMARK "EMT" 
3b2f f5				push af  
3b30 3a 44 3b			ld a, (.dmark)  
3b33 32 6b ee			ld (debug_mark),a  
3b36 3a 45 3b			ld a, (.dmark+1)  
3b39 32 6c ee			ld (debug_mark+1),a  
3b3c 3a 46 3b			ld a, (.dmark+2)  
3b3f 32 6d ee			ld (debug_mark+2),a  
3b42 18 03			jr .pastdmark  
3b44 ..			.dmark: db "EMT"  
3b47 f1			.pastdmark: pop af  
3b48			endm  
# End of macro DMARK
3b48						CALLMONITOR 
3b48 cd 6f ee			call debug_vector  
3b4b				endm  
# End of macro CALLMONITOR
3b4b					endif 
3b4b			 
3b4b					FORTH_DSP_VALUEHL 
3b4b cd a2 1d			call macro_dsp_valuehl 
3b4e				endm 
# End of macro FORTH_DSP_VALUEHL
3b4e			 
3b4e 7d					ld a,l 
3b4f			 
3b4f					; TODO write to display 
3b4f			 
3b4f 32 bf e4				ld (os_input), a 
3b52 3e 00				ld a, 0 
3b54 32 c0 e4				ld (os_input+1), a 
3b57					 
3b57 3a 5e ea				ld a, (f_cursor_ptr) 
3b5a 11 bf e4				ld de, os_input 
3b5d cd cc 0b				call str_at_display 
3b60			 
3b60			 
3b60 3a 3c ea				ld a,(cli_autodisplay) 
3b63 fe 00				cp 0 
3b65 28 03				jr z, .enoupdate 
3b67 cd dc 0b						call update_display 
3b6a					.enoupdate: 
3b6a			 
3b6a 3a 5e ea				ld a, (f_cursor_ptr) 
3b6d 3c					inc a 
3b6e 32 5e ea				ld (f_cursor_ptr), a   ; save new pos 
3b71			 
3b71			 
3b71					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b71 cd 5a 1e			call macro_forth_dsp_pop 
3b74				endm 
# End of macro FORTH_DSP_POP
3b74			  
3b74			 
3b74					NEXTW 
3b74 c3 58 1f			jp macro_next 
3b77				endm 
# End of macro NEXTW
3b77			.DOTH: 
3b77				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3b77 1c				db WORD_SYS_CORE+8             
3b78 a7 3b			dw .DOTF            
3b7a 03				db 2 + 1 
3b7b .. 00			db ".-",0              
3b7e				endm 
# End of macro CWHEAD
3b7e			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3b7e					; get value off TOS and display it 
3b7e					if DEBUG_FORTH_WORDS_KEY 
3b7e						DMARK "DTD" 
3b7e f5				push af  
3b7f 3a 93 3b			ld a, (.dmark)  
3b82 32 6b ee			ld (debug_mark),a  
3b85 3a 94 3b			ld a, (.dmark+1)  
3b88 32 6c ee			ld (debug_mark+1),a  
3b8b 3a 95 3b			ld a, (.dmark+2)  
3b8e 32 6d ee			ld (debug_mark+2),a  
3b91 18 03			jr .pastdmark  
3b93 ..			.dmark: db "DTD"  
3b96 f1			.pastdmark: pop af  
3b97			endm  
# End of macro DMARK
3b97						CALLMONITOR 
3b97 cd 6f ee			call debug_vector  
3b9a				endm  
# End of macro CALLMONITOR
3b9a					endif 
3b9a 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3b9c 3e 00			ld a, 0 
3b9e 32 3d ea			ld (cli_mvdot), a 
3ba1 c3 fe 3b			jp .dotgo 
3ba4				NEXTW 
3ba4 c3 58 1f			jp macro_next 
3ba7				endm 
# End of macro NEXTW
3ba7			.DOTF: 
3ba7				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3ba7 1c				db WORD_SYS_CORE+8             
3ba8 d5 3b			dw .DOT            
3baa 03				db 2 + 1 
3bab .. 00			db ".>",0              
3bae				endm 
# End of macro CWHEAD
3bae			        ; | .> ( u -- ) Display TOS and move the next display point with display  | DONE 
3bae					; get value off TOS and display it 
3bae			        ; TODO BUG adds extra spaces 
3bae			        ; TODO BUG handle numerics? 
3bae					if DEBUG_FORTH_WORDS_KEY 
3bae						DMARK "DTC" 
3bae f5				push af  
3baf 3a c3 3b			ld a, (.dmark)  
3bb2 32 6b ee			ld (debug_mark),a  
3bb5 3a c4 3b			ld a, (.dmark+1)  
3bb8 32 6c ee			ld (debug_mark+1),a  
3bbb 3a c5 3b			ld a, (.dmark+2)  
3bbe 32 6d ee			ld (debug_mark+2),a  
3bc1 18 03			jr .pastdmark  
3bc3 ..			.dmark: db "DTC"  
3bc6 f1			.pastdmark: pop af  
3bc7			endm  
# End of macro DMARK
3bc7						CALLMONITOR 
3bc7 cd 6f ee			call debug_vector  
3bca				endm  
# End of macro CALLMONITOR
3bca					endif 
3bca 3e 01			ld a, 1 
3bcc 32 3d ea			ld (cli_mvdot), a 
3bcf c3 fe 3b			jp .dotgo 
3bd2				NEXTW 
3bd2 c3 58 1f			jp macro_next 
3bd5				endm 
# End of macro NEXTW
3bd5			 
3bd5			.DOT: 
3bd5				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3bd5 1c				db WORD_SYS_CORE+8             
3bd6 b1 3d			dw .CLS            
3bd8 02				db 1 + 1 
3bd9 .. 00			db ".",0              
3bdb				endm 
# End of macro CWHEAD
3bdb			        ; | . ( u -- ) Display TOS. Does not move next print position. Use .> if you want that. | DONE 
3bdb					; get value off TOS and display it 
3bdb			 
3bdb					if DEBUG_FORTH_WORDS_KEY 
3bdb						DMARK "DOT" 
3bdb f5				push af  
3bdc 3a f0 3b			ld a, (.dmark)  
3bdf 32 6b ee			ld (debug_mark),a  
3be2 3a f1 3b			ld a, (.dmark+1)  
3be5 32 6c ee			ld (debug_mark+1),a  
3be8 3a f2 3b			ld a, (.dmark+2)  
3beb 32 6d ee			ld (debug_mark+2),a  
3bee 18 03			jr .pastdmark  
3bf0 ..			.dmark: db "DOT"  
3bf3 f1			.pastdmark: pop af  
3bf4			endm  
# End of macro DMARK
3bf4						CALLMONITOR 
3bf4 cd 6f ee			call debug_vector  
3bf7				endm  
# End of macro CALLMONITOR
3bf7					endif 
3bf7 3e 00			ld a, 0 
3bf9 32 3d ea			ld (cli_mvdot), a 
3bfc 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3bfe				 
3bfe			 
3bfe			.dotgo: 
3bfe			 
3bfe			; move up type to on stack for parserv5 
3bfe					FORTH_DSP 
3bfe cd 68 1d			call macro_forth_dsp 
3c01				endm 
# End of macro FORTH_DSP
3c01				;FORTH_DSP_VALUE  
3c01			 
3c01			if DEBUG_FORTH_DOT 
3c01				DMARK "DOT" 
3c01 f5				push af  
3c02 3a 16 3c			ld a, (.dmark)  
3c05 32 6b ee			ld (debug_mark),a  
3c08 3a 17 3c			ld a, (.dmark+1)  
3c0b 32 6c ee			ld (debug_mark+1),a  
3c0e 3a 18 3c			ld a, (.dmark+2)  
3c11 32 6d ee			ld (debug_mark+2),a  
3c14 18 03			jr .pastdmark  
3c16 ..			.dmark: db "DOT"  
3c19 f1			.pastdmark: pop af  
3c1a			endm  
# End of macro DMARK
3c1a				CALLMONITOR 
3c1a cd 6f ee			call debug_vector  
3c1d				endm  
# End of macro CALLMONITOR
3c1d			endif	 
3c1d			;		.print: 
3c1d			 
3c1d 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3c1e 23				inc hl   ; position to the actual value 
3c1f fe 01			cp DS_TYPE_STR 
3c21 20 06			jr nz, .dotnum1  
3c23			 
3c23			; display string 
3c23				FORTH_DSP_VALUE  
3c23 cd 8b 1d			call macro_forth_dsp_value 
3c26				endm 
# End of macro FORTH_DSP_VALUE
3c26 eb				ex de,hl 
3c27 18 49			jr .dotwrite 
3c29			 
3c29			.dotnum1: 
3c29 fe 02			cp DS_TYPE_INUM 
3c2b 20 44			jr nz, .dotflot 
3c2d			 
3c2d			 
3c2d			; display number 
3c2d			 
3c2d			;	push hl 
3c2d			;	call clear_display 
3c2d			;	pop hl 
3c2d			 
3c2d 5e				ld e, (hl) 
3c2e 23				inc hl 
3c2f 56				ld d, (hl) 
3c30 21 c1 e2			ld hl, scratch 
3c33			if DEBUG_FORTH_DOT 
3c33				DMARK "DT1" 
3c33 f5				push af  
3c34 3a 48 3c			ld a, (.dmark)  
3c37 32 6b ee			ld (debug_mark),a  
3c3a 3a 49 3c			ld a, (.dmark+1)  
3c3d 32 6c ee			ld (debug_mark+1),a  
3c40 3a 4a 3c			ld a, (.dmark+2)  
3c43 32 6d ee			ld (debug_mark+2),a  
3c46 18 03			jr .pastdmark  
3c48 ..			.dmark: db "DT1"  
3c4b f1			.pastdmark: pop af  
3c4c			endm  
# End of macro DMARK
3c4c				CALLMONITOR 
3c4c cd 6f ee			call debug_vector  
3c4f				endm  
# End of macro CALLMONITOR
3c4f			endif	 
3c4f			 
3c4f cd 4c 11			call uitoa_16 
3c52 eb				ex de,hl 
3c53			 
3c53			if DEBUG_FORTH_DOT 
3c53				DMARK "DT2" 
3c53 f5				push af  
3c54 3a 68 3c			ld a, (.dmark)  
3c57 32 6b ee			ld (debug_mark),a  
3c5a 3a 69 3c			ld a, (.dmark+1)  
3c5d 32 6c ee			ld (debug_mark+1),a  
3c60 3a 6a 3c			ld a, (.dmark+2)  
3c63 32 6d ee			ld (debug_mark+2),a  
3c66 18 03			jr .pastdmark  
3c68 ..			.dmark: db "DT2"  
3c6b f1			.pastdmark: pop af  
3c6c			endm  
# End of macro DMARK
3c6c				CALLMONITOR 
3c6c cd 6f ee			call debug_vector  
3c6f				endm  
# End of macro CALLMONITOR
3c6f			endif	 
3c6f			 
3c6f			;	ld de, os_word_scratch 
3c6f 18 01			jr .dotwrite 
3c71			 
3c71 00			.dotflot:   nop 
3c72			; TODO print floating point number 
3c72			 
3c72			.dotwrite:		 
3c72			 
3c72					; if c is set then set all '-' to spaces 
3c72					; need to also take into account .>  
3c72			 
3c72 3e 01				ld a, 1 
3c74 b9					cp c 
3c75 20 67				jr nz, .nodashswap 
3c77			 
3c77					; DE has the string to write, working with HL 
3c77			 
3c77 06 ff				ld b, 255 
3c79 d5					push de 
3c7a e1					pop hl 
3c7b			 
3c7b			if DEBUG_FORTH_DOT 
3c7b				DMARK "DT-" 
3c7b f5				push af  
3c7c 3a 90 3c			ld a, (.dmark)  
3c7f 32 6b ee			ld (debug_mark),a  
3c82 3a 91 3c			ld a, (.dmark+1)  
3c85 32 6c ee			ld (debug_mark+1),a  
3c88 3a 92 3c			ld a, (.dmark+2)  
3c8b 32 6d ee			ld (debug_mark+2),a  
3c8e 18 03			jr .pastdmark  
3c90 ..			.dmark: db "DT-"  
3c93 f1			.pastdmark: pop af  
3c94			endm  
# End of macro DMARK
3c94				CALLMONITOR 
3c94 cd 6f ee			call debug_vector  
3c97				endm  
# End of macro CALLMONITOR
3c97			endif	 
3c97 7e			.dashscan:	ld a, (hl) 
3c98 fe 00				cp 0 
3c9a 28 42				jr z, .nodashswap 
3c9c fe 2d				cp '-' 
3c9e 20 03				jr nz, .dashskip 
3ca0 3e 20				ld a, ' ' 
3ca2 77					ld (hl), a 
3ca3 23			.dashskip:	inc hl 
3ca4			if DEBUG_FORTH_DOT 
3ca4				DMARK "D-2" 
3ca4 f5				push af  
3ca5 3a b9 3c			ld a, (.dmark)  
3ca8 32 6b ee			ld (debug_mark),a  
3cab 3a ba 3c			ld a, (.dmark+1)  
3cae 32 6c ee			ld (debug_mark+1),a  
3cb1 3a bb 3c			ld a, (.dmark+2)  
3cb4 32 6d ee			ld (debug_mark+2),a  
3cb7 18 03			jr .pastdmark  
3cb9 ..			.dmark: db "D-2"  
3cbc f1			.pastdmark: pop af  
3cbd			endm  
# End of macro DMARK
3cbd				CALLMONITOR 
3cbd cd 6f ee			call debug_vector  
3cc0				endm  
# End of macro CALLMONITOR
3cc0			endif	 
3cc0 10 d5				djnz .dashscan 
3cc2			 
3cc2			if DEBUG_FORTH_DOT 
3cc2				DMARK "D-1" 
3cc2 f5				push af  
3cc3 3a d7 3c			ld a, (.dmark)  
3cc6 32 6b ee			ld (debug_mark),a  
3cc9 3a d8 3c			ld a, (.dmark+1)  
3ccc 32 6c ee			ld (debug_mark+1),a  
3ccf 3a d9 3c			ld a, (.dmark+2)  
3cd2 32 6d ee			ld (debug_mark+2),a  
3cd5 18 03			jr .pastdmark  
3cd7 ..			.dmark: db "D-1"  
3cda f1			.pastdmark: pop af  
3cdb			endm  
# End of macro DMARK
3cdb				CALLMONITOR 
3cdb cd 6f ee			call debug_vector  
3cde				endm  
# End of macro CALLMONITOR
3cde			endif	 
3cde			 
3cde			.nodashswap: 
3cde			 
3cde			if DEBUG_FORTH_DOT 
3cde				DMARK "D-o" 
3cde f5				push af  
3cdf 3a f3 3c			ld a, (.dmark)  
3ce2 32 6b ee			ld (debug_mark),a  
3ce5 3a f4 3c			ld a, (.dmark+1)  
3ce8 32 6c ee			ld (debug_mark+1),a  
3ceb 3a f5 3c			ld a, (.dmark+2)  
3cee 32 6d ee			ld (debug_mark+2),a  
3cf1 18 03			jr .pastdmark  
3cf3 ..			.dmark: db "D-o"  
3cf6 f1			.pastdmark: pop af  
3cf7			endm  
# End of macro DMARK
3cf7				CALLMONITOR 
3cf7 cd 6f ee			call debug_vector  
3cfa				endm  
# End of macro CALLMONITOR
3cfa			endif	 
3cfa			 
3cfa d5					push de   ; save string start in case we need to advance print 
3cfb			 
3cfb 3a 5e ea				ld a, (f_cursor_ptr) 
3cfe cd cc 0b				call str_at_display 
3d01 3a 3c ea				ld a,(cli_autodisplay) 
3d04 fe 00				cp 0 
3d06 28 03				jr z, .noupdate 
3d08 cd dc 0b						call update_display 
3d0b					.noupdate: 
3d0b			 
3d0b			 
3d0b					; see if we need to advance the print position 
3d0b			 
3d0b e1					pop hl   ; get back string 
3d0c			;		ex de,hl 
3d0c			 
3d0c 3a 3d ea				ld a, (cli_mvdot) 
3d0f			if DEBUG_FORTH_DOT 
3d0f			;		ld e,a 
3d0f				DMARK "D>1" 
3d0f f5				push af  
3d10 3a 24 3d			ld a, (.dmark)  
3d13 32 6b ee			ld (debug_mark),a  
3d16 3a 25 3d			ld a, (.dmark+1)  
3d19 32 6c ee			ld (debug_mark+1),a  
3d1c 3a 26 3d			ld a, (.dmark+2)  
3d1f 32 6d ee			ld (debug_mark+2),a  
3d22 18 03			jr .pastdmark  
3d24 ..			.dmark: db "D>1"  
3d27 f1			.pastdmark: pop af  
3d28			endm  
# End of macro DMARK
3d28				CALLMONITOR 
3d28 cd 6f ee			call debug_vector  
3d2b				endm  
# End of macro CALLMONITOR
3d2b			endif	 
3d2b fe 00				cp 0 
3d2d 28 44				jr z, .noadv 
3d2f					; yes, lets advance the print position 
3d2f 3e 00				ld a, 0 
3d31 cd a8 11				call strlent 
3d34			if DEBUG_FORTH_DOT 
3d34				DMARK "D-?" 
3d34 f5				push af  
3d35 3a 49 3d			ld a, (.dmark)  
3d38 32 6b ee			ld (debug_mark),a  
3d3b 3a 4a 3d			ld a, (.dmark+1)  
3d3e 32 6c ee			ld (debug_mark+1),a  
3d41 3a 4b 3d			ld a, (.dmark+2)  
3d44 32 6d ee			ld (debug_mark+2),a  
3d47 18 03			jr .pastdmark  
3d49 ..			.dmark: db "D-?"  
3d4c f1			.pastdmark: pop af  
3d4d			endm  
# End of macro DMARK
3d4d				CALLMONITOR 
3d4d cd 6f ee			call debug_vector  
3d50				endm  
# End of macro CALLMONITOR
3d50			endif	 
3d50 3a 5e ea				ld a, (f_cursor_ptr) 
3d53 85					add a,l 
3d54					;call addatohl 
3d54					;ld a, l 
3d54 32 5e ea				ld (f_cursor_ptr), a   ; save new pos 
3d57			 
3d57			if DEBUG_FORTH_DOT 
3d57				DMARK "D->" 
3d57 f5				push af  
3d58 3a 6c 3d			ld a, (.dmark)  
3d5b 32 6b ee			ld (debug_mark),a  
3d5e 3a 6d 3d			ld a, (.dmark+1)  
3d61 32 6c ee			ld (debug_mark+1),a  
3d64 3a 6e 3d			ld a, (.dmark+2)  
3d67 32 6d ee			ld (debug_mark+2),a  
3d6a 18 03			jr .pastdmark  
3d6c ..			.dmark: db "D->"  
3d6f f1			.pastdmark: pop af  
3d70			endm  
# End of macro DMARK
3d70				CALLMONITOR 
3d70 cd 6f ee			call debug_vector  
3d73				endm  
# End of macro CALLMONITOR
3d73			endif	 
3d73			 
3d73			.noadv:	 
3d73			 
3d73					if DEBUG_FORTH_DOT_WAIT 
3d73							call next_page_prompt 
3d73					endif	 
3d73			; TODO this pop off the stack causes a crash. i dont know why 
3d73			 
3d73			 
3d73			if DEBUG_FORTH_DOT 
3d73				DMARK "DTh" 
3d73 f5				push af  
3d74 3a 88 3d			ld a, (.dmark)  
3d77 32 6b ee			ld (debug_mark),a  
3d7a 3a 89 3d			ld a, (.dmark+1)  
3d7d 32 6c ee			ld (debug_mark+1),a  
3d80 3a 8a 3d			ld a, (.dmark+2)  
3d83 32 6d ee			ld (debug_mark+2),a  
3d86 18 03			jr .pastdmark  
3d88 ..			.dmark: db "DTh"  
3d8b f1			.pastdmark: pop af  
3d8c			endm  
# End of macro DMARK
3d8c				CALLMONITOR 
3d8c cd 6f ee			call debug_vector  
3d8f				endm  
# End of macro CALLMONITOR
3d8f			endif	 
3d8f			 
3d8f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d8f cd 5a 1e			call macro_forth_dsp_pop 
3d92				endm 
# End of macro FORTH_DSP_POP
3d92			 
3d92			if DEBUG_FORTH_DOT 
3d92				DMARK "DTi" 
3d92 f5				push af  
3d93 3a a7 3d			ld a, (.dmark)  
3d96 32 6b ee			ld (debug_mark),a  
3d99 3a a8 3d			ld a, (.dmark+1)  
3d9c 32 6c ee			ld (debug_mark+1),a  
3d9f 3a a9 3d			ld a, (.dmark+2)  
3da2 32 6d ee			ld (debug_mark+2),a  
3da5 18 03			jr .pastdmark  
3da7 ..			.dmark: db "DTi"  
3daa f1			.pastdmark: pop af  
3dab			endm  
# End of macro DMARK
3dab				CALLMONITOR 
3dab cd 6f ee			call debug_vector  
3dae				endm  
# End of macro CALLMONITOR
3dae			endif	 
3dae			 
3dae			 
3dae					NEXTW 
3dae c3 58 1f			jp macro_next 
3db1				endm 
# End of macro NEXTW
3db1			 
3db1			.CLS: 
3db1				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3db1 35				db WORD_SYS_CORE+33             
3db2 de 3d			dw .DRAW            
3db4 04				db 3 + 1 
3db5 .. 00			db "CLS",0              
3db9				endm 
# End of macro CWHEAD
3db9			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3db9					if DEBUG_FORTH_WORDS_KEY 
3db9						DMARK "CLS" 
3db9 f5				push af  
3dba 3a ce 3d			ld a, (.dmark)  
3dbd 32 6b ee			ld (debug_mark),a  
3dc0 3a cf 3d			ld a, (.dmark+1)  
3dc3 32 6c ee			ld (debug_mark+1),a  
3dc6 3a d0 3d			ld a, (.dmark+2)  
3dc9 32 6d ee			ld (debug_mark+2),a  
3dcc 18 03			jr .pastdmark  
3dce ..			.dmark: db "CLS"  
3dd1 f1			.pastdmark: pop af  
3dd2			endm  
# End of macro DMARK
3dd2						CALLMONITOR 
3dd2 cd 6f ee			call debug_vector  
3dd5				endm  
# End of macro CALLMONITOR
3dd5					endif 
3dd5 cd b9 0b				call clear_display 
3dd8 c3 ec 3e				jp .home		; and home cursor 
3ddb					NEXTW 
3ddb c3 58 1f			jp macro_next 
3dde				endm 
# End of macro NEXTW
3dde			 
3dde			.DRAW: 
3dde				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3dde 36				db WORD_SYS_CORE+34             
3ddf 09 3e			dw .DUMP            
3de1 05				db 4 + 1 
3de2 .. 00			db "DRAW",0              
3de7				endm 
# End of macro CWHEAD
3de7			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3de7					if DEBUG_FORTH_WORDS_KEY 
3de7						DMARK "DRW" 
3de7 f5				push af  
3de8 3a fc 3d			ld a, (.dmark)  
3deb 32 6b ee			ld (debug_mark),a  
3dee 3a fd 3d			ld a, (.dmark+1)  
3df1 32 6c ee			ld (debug_mark+1),a  
3df4 3a fe 3d			ld a, (.dmark+2)  
3df7 32 6d ee			ld (debug_mark+2),a  
3dfa 18 03			jr .pastdmark  
3dfc ..			.dmark: db "DRW"  
3dff f1			.pastdmark: pop af  
3e00			endm  
# End of macro DMARK
3e00						CALLMONITOR 
3e00 cd 6f ee			call debug_vector  
3e03				endm  
# End of macro CALLMONITOR
3e03					endif 
3e03 cd dc 0b				call update_display 
3e06					NEXTW 
3e06 c3 58 1f			jp macro_next 
3e09				endm 
# End of macro NEXTW
3e09			 
3e09			.DUMP: 
3e09				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3e09 37				db WORD_SYS_CORE+35             
3e0a 41 3e			dw .CDUMP            
3e0c 05				db 4 + 1 
3e0d .. 00			db "DUMP",0              
3e12				endm 
# End of macro CWHEAD
3e12			; | DUMP ( x -- ) With address x display dump   | DONE 
3e12			; TODO pop address to use off of the stack 
3e12					if DEBUG_FORTH_WORDS_KEY 
3e12						DMARK "DUM" 
3e12 f5				push af  
3e13 3a 27 3e			ld a, (.dmark)  
3e16 32 6b ee			ld (debug_mark),a  
3e19 3a 28 3e			ld a, (.dmark+1)  
3e1c 32 6c ee			ld (debug_mark+1),a  
3e1f 3a 29 3e			ld a, (.dmark+2)  
3e22 32 6d ee			ld (debug_mark+2),a  
3e25 18 03			jr .pastdmark  
3e27 ..			.dmark: db "DUM"  
3e2a f1			.pastdmark: pop af  
3e2b			endm  
# End of macro DMARK
3e2b						CALLMONITOR 
3e2b cd 6f ee			call debug_vector  
3e2e				endm  
# End of macro CALLMONITOR
3e2e					endif 
3e2e cd b9 0b				call clear_display 
3e31			 
3e31					; get address 
3e31			 
3e31					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e31 cd a2 1d			call macro_dsp_valuehl 
3e34				endm 
# End of macro FORTH_DSP_VALUEHL
3e34				 
3e34					; save it for cdump 
3e34			 
3e34 22 e4 e5				ld (os_cur_ptr),hl 
3e37			 
3e37					; destroy value TOS 
3e37			 
3e37					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e37 cd 5a 1e			call macro_forth_dsp_pop 
3e3a				endm 
# End of macro FORTH_DSP_POP
3e3a			 
3e3a cd 2b 1a				call dumpcont	; skip old style of param parsing	 
3e3d c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3e3e					NEXTW 
3e3e c3 58 1f			jp macro_next 
3e41				endm 
# End of macro NEXTW
3e41			.CDUMP: 
3e41				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3e41 38				db WORD_SYS_CORE+36             
3e42 71 3e			dw .DAT            
3e44 06				db 5 + 1 
3e45 .. 00			db "CDUMP",0              
3e4b				endm 
# End of macro CWHEAD
3e4b			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3e4b					if DEBUG_FORTH_WORDS_KEY 
3e4b						DMARK "CDP" 
3e4b f5				push af  
3e4c 3a 60 3e			ld a, (.dmark)  
3e4f 32 6b ee			ld (debug_mark),a  
3e52 3a 61 3e			ld a, (.dmark+1)  
3e55 32 6c ee			ld (debug_mark+1),a  
3e58 3a 62 3e			ld a, (.dmark+2)  
3e5b 32 6d ee			ld (debug_mark+2),a  
3e5e 18 03			jr .pastdmark  
3e60 ..			.dmark: db "CDP"  
3e63 f1			.pastdmark: pop af  
3e64			endm  
# End of macro DMARK
3e64						CALLMONITOR 
3e64 cd 6f ee			call debug_vector  
3e67				endm  
# End of macro CALLMONITOR
3e67					endif 
3e67 cd b9 0b				call clear_display 
3e6a cd 2b 1a				call dumpcont	 
3e6d c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3e6e					NEXTW 
3e6e c3 58 1f			jp macro_next 
3e71				endm 
# End of macro NEXTW
3e71			 
3e71			 
3e71			 
3e71			 
3e71			.DAT: 
3e71				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3e71 3d				db WORD_SYS_CORE+41             
3e72 c7 3e			dw .HOME            
3e74 03				db 2 + 1 
3e75 .. 00			db "AT",0              
3e78				endm 
# End of macro CWHEAD
3e78			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3e78					if DEBUG_FORTH_WORDS_KEY 
3e78						DMARK "AT." 
3e78 f5				push af  
3e79 3a 8d 3e			ld a, (.dmark)  
3e7c 32 6b ee			ld (debug_mark),a  
3e7f 3a 8e 3e			ld a, (.dmark+1)  
3e82 32 6c ee			ld (debug_mark+1),a  
3e85 3a 8f 3e			ld a, (.dmark+2)  
3e88 32 6d ee			ld (debug_mark+2),a  
3e8b 18 03			jr .pastdmark  
3e8d ..			.dmark: db "AT."  
3e90 f1			.pastdmark: pop af  
3e91			endm  
# End of macro DMARK
3e91						CALLMONITOR 
3e91 cd 6f ee			call debug_vector  
3e94				endm  
# End of macro CALLMONITOR
3e94					endif 
3e94					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e94 cd a2 1d			call macro_dsp_valuehl 
3e97				endm 
# End of macro FORTH_DSP_VALUEHL
3e97			 
3e97			 
3e97					; TODO save cursor row 
3e97 7d					ld a,l 
3e98 fe 02				cp 2 
3e9a 20 04				jr nz, .crow3 
3e9c 3e 28				ld a, display_row_2 
3e9e 18 12				jr .ccol1 
3ea0 fe 03		.crow3:		cp 3 
3ea2 20 04				jr nz, .crow4 
3ea4 3e 50				ld a, display_row_3 
3ea6 18 0a				jr .ccol1 
3ea8 fe 04		.crow4:		cp 4 
3eaa 20 04				jr nz, .crow1 
3eac 3e 78				ld a, display_row_4 
3eae 18 02				jr .ccol1 
3eb0 3e 00		.crow1:		ld a,display_row_1 
3eb2 f5			.ccol1:		push af			; got row offset 
3eb3 6f					ld l,a 
3eb4 26 00				ld h,0 
3eb6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3eb6 cd 5a 1e			call macro_forth_dsp_pop 
3eb9				endm 
# End of macro FORTH_DSP_POP
3eb9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3eb9 cd a2 1d			call macro_dsp_valuehl 
3ebc				endm 
# End of macro FORTH_DSP_VALUEHL
3ebc					; TODO save cursor col 
3ebc f1					pop af 
3ebd 85					add l		; add col offset 
3ebe 32 5e ea				ld (f_cursor_ptr), a 
3ec1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ec1 cd 5a 1e			call macro_forth_dsp_pop 
3ec4				endm 
# End of macro FORTH_DSP_POP
3ec4			 
3ec4					; calculate  
3ec4			 
3ec4					NEXTW 
3ec4 c3 58 1f			jp macro_next 
3ec7				endm 
# End of macro NEXTW
3ec7			 
3ec7			 
3ec7			.HOME: 
3ec7				CWHEAD .CR 45 "HOME" 4 WORD_FLAG_CODE 
3ec7 41				db WORD_SYS_CORE+45             
3ec8 f4 3e			dw .CR            
3eca 05				db 4 + 1 
3ecb .. 00			db "HOME",0              
3ed0				endm 
# End of macro CWHEAD
3ed0			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3ed0					if DEBUG_FORTH_WORDS_KEY 
3ed0						DMARK "HOM" 
3ed0 f5				push af  
3ed1 3a e5 3e			ld a, (.dmark)  
3ed4 32 6b ee			ld (debug_mark),a  
3ed7 3a e6 3e			ld a, (.dmark+1)  
3eda 32 6c ee			ld (debug_mark+1),a  
3edd 3a e7 3e			ld a, (.dmark+2)  
3ee0 32 6d ee			ld (debug_mark+2),a  
3ee3 18 03			jr .pastdmark  
3ee5 ..			.dmark: db "HOM"  
3ee8 f1			.pastdmark: pop af  
3ee9			endm  
# End of macro DMARK
3ee9						CALLMONITOR 
3ee9 cd 6f ee			call debug_vector  
3eec				endm  
# End of macro CALLMONITOR
3eec					endif 
3eec 3e 00		.home:		ld a, 0		; and home cursor 
3eee 32 5e ea				ld (f_cursor_ptr), a 
3ef1					NEXTW 
3ef1 c3 58 1f			jp macro_next 
3ef4				endm 
# End of macro NEXTW
3ef4			 
3ef4			 
3ef4			.CR: 
3ef4				CWHEAD .SPACE 50 "CR" 2 WORD_FLAG_CODE 
3ef4 46				db WORD_SYS_CORE+50             
3ef5 2f 3f			dw .SPACE            
3ef7 03				db 2 + 1 
3ef8 .. 00			db "CR",0              
3efb				endm 
# End of macro CWHEAD
3efb			; | CR (  -- s ) Push CR/LF pair onto the stack as a string  | DONE 
3efb					if DEBUG_FORTH_WORDS_KEY 
3efb						DMARK "CR." 
3efb f5				push af  
3efc 3a 10 3f			ld a, (.dmark)  
3eff 32 6b ee			ld (debug_mark),a  
3f02 3a 11 3f			ld a, (.dmark+1)  
3f05 32 6c ee			ld (debug_mark+1),a  
3f08 3a 12 3f			ld a, (.dmark+2)  
3f0b 32 6d ee			ld (debug_mark+2),a  
3f0e 18 03			jr .pastdmark  
3f10 ..			.dmark: db "CR."  
3f13 f1			.pastdmark: pop af  
3f14			endm  
# End of macro DMARK
3f14						CALLMONITOR 
3f14 cd 6f ee			call debug_vector  
3f17				endm  
# End of macro CALLMONITOR
3f17					endif 
3f17 3e 0d				ld a, 13 
3f19 32 c1 e2				ld (scratch),a 
3f1c 3e 0a				ld a, 10 
3f1e 32 c2 e2				ld (scratch+1),a 
3f21 3e 00				ld a, 0 
3f23 32 c3 e2				ld (scratch+2),a 
3f26 21 c1 e2				ld hl, scratch 
3f29 cd 19 1c				call forth_push_str 
3f2c					 
3f2c				       NEXTW 
3f2c c3 58 1f			jp macro_next 
3f2f				endm 
# End of macro NEXTW
3f2f			.SPACE: 
3f2f				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3f2f 46				db WORD_SYS_CORE+50             
3f30 65 3f			dw .SPACES            
3f32 03				db 2 + 1 
3f33 .. 00			db "BL",0              
3f36				endm 
# End of macro CWHEAD
3f36			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3f36					if DEBUG_FORTH_WORDS_KEY 
3f36						DMARK "BL." 
3f36 f5				push af  
3f37 3a 4b 3f			ld a, (.dmark)  
3f3a 32 6b ee			ld (debug_mark),a  
3f3d 3a 4c 3f			ld a, (.dmark+1)  
3f40 32 6c ee			ld (debug_mark+1),a  
3f43 3a 4d 3f			ld a, (.dmark+2)  
3f46 32 6d ee			ld (debug_mark+2),a  
3f49 18 03			jr .pastdmark  
3f4b ..			.dmark: db "BL."  
3f4e f1			.pastdmark: pop af  
3f4f			endm  
# End of macro DMARK
3f4f						CALLMONITOR 
3f4f cd 6f ee			call debug_vector  
3f52				endm  
# End of macro CALLMONITOR
3f52					endif 
3f52 3e 20				ld a, " " 
3f54 32 c1 e2				ld (scratch),a 
3f57 3e 00				ld a, 0 
3f59 32 c2 e2				ld (scratch+1),a 
3f5c 21 c1 e2				ld hl, scratch 
3f5f cd 19 1c				call forth_push_str 
3f62					 
3f62				       NEXTW 
3f62 c3 58 1f			jp macro_next 
3f65				endm 
# End of macro NEXTW
3f65			 
3f65			;.blstr: db " ", 0 
3f65			 
3f65			.SPACES: 
3f65				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3f65 47				db WORD_SYS_CORE+51             
3f66 00 40			dw .SCROLL            
3f68 07				db 6 + 1 
3f69 .. 00			db "SPACES",0              
3f70				endm 
# End of macro CWHEAD
3f70			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
3f70					if DEBUG_FORTH_WORDS_KEY 
3f70						DMARK "SPS" 
3f70 f5				push af  
3f71 3a 85 3f			ld a, (.dmark)  
3f74 32 6b ee			ld (debug_mark),a  
3f77 3a 86 3f			ld a, (.dmark+1)  
3f7a 32 6c ee			ld (debug_mark+1),a  
3f7d 3a 87 3f			ld a, (.dmark+2)  
3f80 32 6d ee			ld (debug_mark+2),a  
3f83 18 03			jr .pastdmark  
3f85 ..			.dmark: db "SPS"  
3f88 f1			.pastdmark: pop af  
3f89			endm  
# End of macro DMARK
3f89						CALLMONITOR 
3f89 cd 6f ee			call debug_vector  
3f8c				endm  
# End of macro CALLMONITOR
3f8c					endif 
3f8c			 
3f8c			 
3f8c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f8c cd a2 1d			call macro_dsp_valuehl 
3f8f				endm 
# End of macro FORTH_DSP_VALUEHL
3f8f			 
3f8f e5					push hl    ; u 
3f90					if DEBUG_FORTH_WORDS 
3f90						DMARK "SPA" 
3f90 f5				push af  
3f91 3a a5 3f			ld a, (.dmark)  
3f94 32 6b ee			ld (debug_mark),a  
3f97 3a a6 3f			ld a, (.dmark+1)  
3f9a 32 6c ee			ld (debug_mark+1),a  
3f9d 3a a7 3f			ld a, (.dmark+2)  
3fa0 32 6d ee			ld (debug_mark+2),a  
3fa3 18 03			jr .pastdmark  
3fa5 ..			.dmark: db "SPA"  
3fa8 f1			.pastdmark: pop af  
3fa9			endm  
# End of macro DMARK
3fa9						CALLMONITOR 
3fa9 cd 6f ee			call debug_vector  
3fac				endm  
# End of macro CALLMONITOR
3fac					endif 
3fac			 
3fac					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3fac cd 5a 1e			call macro_forth_dsp_pop 
3faf				endm 
# End of macro FORTH_DSP_POP
3faf e1					pop hl 
3fb0 0e 00				ld c, 0 
3fb2 45					ld b, l 
3fb3 21 c1 e2				ld hl, scratch  
3fb6			 
3fb6					if DEBUG_FORTH_WORDS 
3fb6						DMARK "SP2" 
3fb6 f5				push af  
3fb7 3a cb 3f			ld a, (.dmark)  
3fba 32 6b ee			ld (debug_mark),a  
3fbd 3a cc 3f			ld a, (.dmark+1)  
3fc0 32 6c ee			ld (debug_mark+1),a  
3fc3 3a cd 3f			ld a, (.dmark+2)  
3fc6 32 6d ee			ld (debug_mark+2),a  
3fc9 18 03			jr .pastdmark  
3fcb ..			.dmark: db "SP2"  
3fce f1			.pastdmark: pop af  
3fcf			endm  
# End of macro DMARK
3fcf						CALLMONITOR 
3fcf cd 6f ee			call debug_vector  
3fd2				endm  
# End of macro CALLMONITOR
3fd2					endif 
3fd2 3e 20				ld a, ' ' 
3fd4			.spaces1:	 
3fd4 77					ld (hl),a 
3fd5 23					inc hl 
3fd6					 
3fd6 10 fc				djnz .spaces1 
3fd8 3e 00				ld a,0 
3fda 77					ld (hl),a 
3fdb 21 c1 e2				ld hl, scratch 
3fde					if DEBUG_FORTH_WORDS 
3fde						DMARK "SP3" 
3fde f5				push af  
3fdf 3a f3 3f			ld a, (.dmark)  
3fe2 32 6b ee			ld (debug_mark),a  
3fe5 3a f4 3f			ld a, (.dmark+1)  
3fe8 32 6c ee			ld (debug_mark+1),a  
3feb 3a f5 3f			ld a, (.dmark+2)  
3fee 32 6d ee			ld (debug_mark+2),a  
3ff1 18 03			jr .pastdmark  
3ff3 ..			.dmark: db "SP3"  
3ff6 f1			.pastdmark: pop af  
3ff7			endm  
# End of macro DMARK
3ff7						CALLMONITOR 
3ff7 cd 6f ee			call debug_vector  
3ffa				endm  
# End of macro CALLMONITOR
3ffa					endif 
3ffa cd 19 1c				call forth_push_str 
3ffd			 
3ffd				       NEXTW 
3ffd c3 58 1f			jp macro_next 
4000				endm 
# End of macro NEXTW
4000			 
4000			 
4000			 
4000			.SCROLL: 
4000				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
4000 53				db WORD_SYS_CORE+63             
4001 2d 40			dw .SCROLLD            
4003 07				db 6 + 1 
4004 .. 00			db "SCROLL",0              
400b				endm 
# End of macro CWHEAD
400b			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
400b					if DEBUG_FORTH_WORDS_KEY 
400b						DMARK "SCR" 
400b f5				push af  
400c 3a 20 40			ld a, (.dmark)  
400f 32 6b ee			ld (debug_mark),a  
4012 3a 21 40			ld a, (.dmark+1)  
4015 32 6c ee			ld (debug_mark+1),a  
4018 3a 22 40			ld a, (.dmark+2)  
401b 32 6d ee			ld (debug_mark+2),a  
401e 18 03			jr .pastdmark  
4020 ..			.dmark: db "SCR"  
4023 f1			.pastdmark: pop af  
4024			endm  
# End of macro DMARK
4024						CALLMONITOR 
4024 cd 6f ee			call debug_vector  
4027				endm  
# End of macro CALLMONITOR
4027					endif 
4027			 
4027 cd 7b 0b			call scroll_up 
402a			;	call update_display 
402a			 
402a					NEXTW 
402a c3 58 1f			jp macro_next 
402d				endm 
# End of macro NEXTW
402d			 
402d			 
402d			 
402d			;		; get dir 
402d			; 
402d			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
402d			; 
402d			;		push hl 
402d			; 
402d			;		; destroy value TOS 
402d			; 
402d			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
402d			; 
402d			;		; get count 
402d			; 
402d			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
402d			; 
402d			;		push hl 
402d			; 
402d			;		; destroy value TOS 
402d			; 
402d			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
402d			; 
402d			;		; one value on hl get other one back 
402d			; 
402d			;		pop bc    ; count 
402d			; 
402d			;		pop de   ; dir 
402d			; 
402d			; 
402d			;		ld b, c 
402d			; 
402d			;.scrolldir:     push bc 
402d			;		push de 
402d			; 
402d			;		ld a, 0 
402d			;		cp e 
402d			;		jr z, .scrollup  
402d			;		call scroll_down 
402d			;		jr .scrollnext 
402d			;.scrollup:	call scroll_up 
402d			; 
402d			;		 
402d			;.scrollnext: 
402d			;		pop de 
402d			;		pop bc 
402d			;		djnz .scrolldir 
402d			; 
402d			; 
402d			; 
402d			; 
402d			; 
402d			;		NEXTW 
402d			 
402d			.SCROLLD: 
402d				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
402d 53				db WORD_SYS_CORE+63             
402e 5b 40			dw .ATQ            
4030 08				db 7 + 1 
4031 .. 00			db "SCROLLD",0              
4039				endm 
# End of macro CWHEAD
4039			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
4039					if DEBUG_FORTH_WORDS_KEY 
4039						DMARK "SCD" 
4039 f5				push af  
403a 3a 4e 40			ld a, (.dmark)  
403d 32 6b ee			ld (debug_mark),a  
4040 3a 4f 40			ld a, (.dmark+1)  
4043 32 6c ee			ld (debug_mark+1),a  
4046 3a 50 40			ld a, (.dmark+2)  
4049 32 6d ee			ld (debug_mark+2),a  
404c 18 03			jr .pastdmark  
404e ..			.dmark: db "SCD"  
4051 f1			.pastdmark: pop af  
4052			endm  
# End of macro DMARK
4052						CALLMONITOR 
4052 cd 6f ee			call debug_vector  
4055				endm  
# End of macro CALLMONITOR
4055					endif 
4055			 
4055 cd 9f 0b			call scroll_down 
4058			;	call update_display 
4058			 
4058					NEXTW 
4058 c3 58 1f			jp macro_next 
405b				endm 
# End of macro NEXTW
405b			 
405b			 
405b			.ATQ: 
405b				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
405b 62				db WORD_SYS_CORE+78             
405c b9 40			dw .AUTODSP            
405e 04				db 3 + 1 
405f .. 00			db "AT@",0              
4063				endm 
# End of macro CWHEAD
4063			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
4063					if DEBUG_FORTH_WORDS_KEY 
4063						DMARK "ATA" 
4063 f5				push af  
4064 3a 78 40			ld a, (.dmark)  
4067 32 6b ee			ld (debug_mark),a  
406a 3a 79 40			ld a, (.dmark+1)  
406d 32 6c ee			ld (debug_mark+1),a  
4070 3a 7a 40			ld a, (.dmark+2)  
4073 32 6d ee			ld (debug_mark+2),a  
4076 18 03			jr .pastdmark  
4078 ..			.dmark: db "ATA"  
407b f1			.pastdmark: pop af  
407c			endm  
# End of macro DMARK
407c						CALLMONITOR 
407c cd 6f ee			call debug_vector  
407f				endm  
# End of macro CALLMONITOR
407f					endif 
407f			 
407f			 
407f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
407f cd a2 1d			call macro_dsp_valuehl 
4082				endm 
# End of macro FORTH_DSP_VALUEHL
4082			 
4082					; TODO save cursor row 
4082 7d					ld a,l 
4083 fe 02				cp 2 
4085 20 04				jr nz, .crow3aq 
4087 3e 28				ld a, display_row_2 
4089 18 12				jr .ccol1aq 
408b fe 03		.crow3aq:		cp 3 
408d 20 04				jr nz, .crow4aq 
408f 3e 50				ld a, display_row_3 
4091 18 0a				jr .ccol1aq 
4093 fe 04		.crow4aq:		cp 4 
4095 20 04				jr nz, .crow1aq 
4097 3e 78				ld a, display_row_4 
4099 18 02				jr .ccol1aq 
409b 3e 00		.crow1aq:		ld a,display_row_1 
409d f5			.ccol1aq:		push af			; got row offset 
409e 6f					ld l,a 
409f 26 00				ld h,0 
40a1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40a1 cd 5a 1e			call macro_forth_dsp_pop 
40a4				endm 
# End of macro FORTH_DSP_POP
40a4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
40a4 cd a2 1d			call macro_dsp_valuehl 
40a7				endm 
# End of macro FORTH_DSP_VALUEHL
40a7					; TODO save cursor col 
40a7 f1					pop af 
40a8 85					add l		; add col offset 
40a9			 
40a9					; add current frame buffer address 
40a9 2a cc eb				ld hl, (display_fb_active) 
40ac cd e6 0d				call addatohl 
40af			 
40af			 
40af			 
40af			 
40af					; get char frame buffer location offset in hl 
40af			 
40af 7e					ld a,(hl) 
40b0 26 00				ld h, 0 
40b2 6f					ld l, a 
40b3			 
40b3 cd ab 1b				call forth_push_numhl 
40b6			 
40b6			 
40b6					NEXTW 
40b6 c3 58 1f			jp macro_next 
40b9				endm 
# End of macro NEXTW
40b9			 
40b9			.AUTODSP: 
40b9				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
40b9 63				db WORD_SYS_CORE+79             
40ba cf 40			dw .MENU            
40bc 05				db 4 + 1 
40bd .. 00			db "ADSP",0              
40c2				endm 
# End of macro CWHEAD
40c2			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
40c2			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
40c2			 
40c2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
40c2 cd a2 1d			call macro_dsp_valuehl 
40c5				endm 
# End of macro FORTH_DSP_VALUEHL
40c5			 
40c5			;		push hl 
40c5			 
40c5					; destroy value TOS 
40c5			 
40c5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40c5 cd 5a 1e			call macro_forth_dsp_pop 
40c8				endm 
# End of macro FORTH_DSP_POP
40c8			 
40c8			;		pop hl 
40c8			 
40c8 7d					ld a,l 
40c9 32 3c ea				ld (cli_autodisplay), a 
40cc				       NEXTW 
40cc c3 58 1f			jp macro_next 
40cf				endm 
# End of macro NEXTW
40cf			 
40cf			.MENU: 
40cf				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
40cf 70				db WORD_SYS_CORE+92             
40d0 78 41			dw .ENDDISPLAY            
40d2 05				db 4 + 1 
40d3 .. 00			db "MENU",0              
40d8				endm 
# End of macro CWHEAD
40d8			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | DONE 
40d8			 
40d8			;		; get number of items on the stack 
40d8			; 
40d8				 
40d8					FORTH_DSP_VALUEHL 
40d8 cd a2 1d			call macro_dsp_valuehl 
40db				endm 
# End of macro FORTH_DSP_VALUEHL
40db				 
40db					if DEBUG_FORTH_WORDS_KEY 
40db						DMARK "MNU" 
40db f5				push af  
40dc 3a f0 40			ld a, (.dmark)  
40df 32 6b ee			ld (debug_mark),a  
40e2 3a f1 40			ld a, (.dmark+1)  
40e5 32 6c ee			ld (debug_mark+1),a  
40e8 3a f2 40			ld a, (.dmark+2)  
40eb 32 6d ee			ld (debug_mark+2),a  
40ee 18 03			jr .pastdmark  
40f0 ..			.dmark: db "MNU"  
40f3 f1			.pastdmark: pop af  
40f4			endm  
# End of macro DMARK
40f4						CALLMONITOR 
40f4 cd 6f ee			call debug_vector  
40f7				endm  
# End of macro CALLMONITOR
40f7					endif 
40f7			 
40f7 45					ld b, l	 
40f8 05					dec b 
40f9			 
40f9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40f9 cd 5a 1e			call macro_forth_dsp_pop 
40fc				endm 
# End of macro FORTH_DSP_POP
40fc			 
40fc			 
40fc					; go directly through the stack to pluck out the string pointers and build an array 
40fc			 
40fc			;		FORTH_DSP 
40fc			 
40fc					; hl contains top most stack item 
40fc				 
40fc 11 c1 e2				ld de, scratch 
40ff			 
40ff			.mbuild: 
40ff			 
40ff					FORTH_DSP_VALUEHL 
40ff cd a2 1d			call macro_dsp_valuehl 
4102				endm 
# End of macro FORTH_DSP_VALUEHL
4102			 
4102					if DEBUG_FORTH_WORDS 
4102						DMARK "MN3" 
4102 f5				push af  
4103 3a 17 41			ld a, (.dmark)  
4106 32 6b ee			ld (debug_mark),a  
4109 3a 18 41			ld a, (.dmark+1)  
410c 32 6c ee			ld (debug_mark+1),a  
410f 3a 19 41			ld a, (.dmark+2)  
4112 32 6d ee			ld (debug_mark+2),a  
4115 18 03			jr .pastdmark  
4117 ..			.dmark: db "MN3"  
411a f1			.pastdmark: pop af  
411b			endm  
# End of macro DMARK
411b						CALLMONITOR 
411b cd 6f ee			call debug_vector  
411e				endm  
# End of macro CALLMONITOR
411e					endif 
411e eb					ex de, hl 
411f 73					ld (hl), e 
4120 23					inc hl 
4121 72					ld (hl), d 
4122 23					inc hl 
4123 eb					ex de, hl 
4124			 
4124					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4124 cd 5a 1e			call macro_forth_dsp_pop 
4127				endm 
# End of macro FORTH_DSP_POP
4127			 
4127 10 d6				djnz .mbuild 
4129			 
4129					; done add term 
4129			 
4129 eb					ex de, hl 
412a 36 00				ld (hl), 0 
412c 23					inc hl 
412d 36 00				ld (hl), 0 
412f			 
412f				 
412f					 
412f 21 c1 e2				ld hl, scratch 
4132			 
4132					if DEBUG_FORTH_WORDS 
4132						DMARK "MNx" 
4132 f5				push af  
4133 3a 47 41			ld a, (.dmark)  
4136 32 6b ee			ld (debug_mark),a  
4139 3a 48 41			ld a, (.dmark+1)  
413c 32 6c ee			ld (debug_mark+1),a  
413f 3a 49 41			ld a, (.dmark+2)  
4142 32 6d ee			ld (debug_mark+2),a  
4145 18 03			jr .pastdmark  
4147 ..			.dmark: db "MNx"  
414a f1			.pastdmark: pop af  
414b			endm  
# End of macro DMARK
414b						CALLMONITOR 
414b cd 6f ee			call debug_vector  
414e				endm  
# End of macro CALLMONITOR
414e					endif 
414e			 
414e			 
414e			 
414e 3e 00				ld a, 0 
4150 cd ea 0b				call menu 
4153			 
4153			 
4153 6f					ld l, a 
4154 26 00				ld h, 0 
4156			 
4156					if DEBUG_FORTH_WORDS 
4156						DMARK "MNr" 
4156 f5				push af  
4157 3a 6b 41			ld a, (.dmark)  
415a 32 6b ee			ld (debug_mark),a  
415d 3a 6c 41			ld a, (.dmark+1)  
4160 32 6c ee			ld (debug_mark+1),a  
4163 3a 6d 41			ld a, (.dmark+2)  
4166 32 6d ee			ld (debug_mark+2),a  
4169 18 03			jr .pastdmark  
416b ..			.dmark: db "MNr"  
416e f1			.pastdmark: pop af  
416f			endm  
# End of macro DMARK
416f						CALLMONITOR 
416f cd 6f ee			call debug_vector  
4172				endm  
# End of macro CALLMONITOR
4172					endif 
4172			 
4172 cd ab 1b				call forth_push_numhl 
4175			 
4175			 
4175			 
4175			 
4175				       NEXTW 
4175 c3 58 1f			jp macro_next 
4178				endm 
# End of macro NEXTW
4178			 
4178			 
4178			.ENDDISPLAY: 
4178			 
4178			; eof 
# End of file forth_words_display.asm
4178			include "forth_words_str.asm" 
4178			 
4178			; | ## String Words 
4178			 
4178			.PTR:   
4178			 
4178				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
4178 48				db WORD_SYS_CORE+52             
4179 a5 41			dw .STYPE            
417b 04				db 3 + 1 
417c .. 00			db "PTR",0              
4180				endm 
# End of macro CWHEAD
4180			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
4180			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
4180			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
4180			 
4180					if DEBUG_FORTH_WORDS_KEY 
4180						DMARK "PTR" 
4180 f5				push af  
4181 3a 95 41			ld a, (.dmark)  
4184 32 6b ee			ld (debug_mark),a  
4187 3a 96 41			ld a, (.dmark+1)  
418a 32 6c ee			ld (debug_mark+1),a  
418d 3a 97 41			ld a, (.dmark+2)  
4190 32 6d ee			ld (debug_mark+2),a  
4193 18 03			jr .pastdmark  
4195 ..			.dmark: db "PTR"  
4198 f1			.pastdmark: pop af  
4199			endm  
# End of macro DMARK
4199						CALLMONITOR 
4199 cd 6f ee			call debug_vector  
419c				endm  
# End of macro CALLMONITOR
419c					endif 
419c					FORTH_DSP_VALUEHL 
419c cd a2 1d			call macro_dsp_valuehl 
419f				endm 
# End of macro FORTH_DSP_VALUEHL
419f cd ab 1b				call forth_push_numhl 
41a2			 
41a2			 
41a2					NEXTW 
41a2 c3 58 1f			jp macro_next 
41a5				endm 
# End of macro NEXTW
41a5			.STYPE: 
41a5				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
41a5 48				db WORD_SYS_CORE+52             
41a6 f4 41			dw .UPPER            
41a8 06				db 5 + 1 
41a9 .. 00			db "STYPE",0              
41af				endm 
# End of macro CWHEAD
41af			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
41af					if DEBUG_FORTH_WORDS_KEY 
41af						DMARK "STY" 
41af f5				push af  
41b0 3a c4 41			ld a, (.dmark)  
41b3 32 6b ee			ld (debug_mark),a  
41b6 3a c5 41			ld a, (.dmark+1)  
41b9 32 6c ee			ld (debug_mark+1),a  
41bc 3a c6 41			ld a, (.dmark+2)  
41bf 32 6d ee			ld (debug_mark+2),a  
41c2 18 03			jr .pastdmark  
41c4 ..			.dmark: db "STY"  
41c7 f1			.pastdmark: pop af  
41c8			endm  
# End of macro DMARK
41c8						CALLMONITOR 
41c8 cd 6f ee			call debug_vector  
41cb				endm  
# End of macro CALLMONITOR
41cb					endif 
41cb					FORTH_DSP 
41cb cd 68 1d			call macro_forth_dsp 
41ce				endm 
# End of macro FORTH_DSP
41ce					;v5 FORTH_DSP_VALUE 
41ce			 
41ce 7e					ld a, (hl) 
41cf			 
41cf f5					push af 
41d0			 
41d0			; Dont destroy TOS		FORTH_DSP_POP 
41d0			 
41d0 f1					pop af 
41d1			 
41d1 fe 01				cp DS_TYPE_STR 
41d3 28 09				jr z, .typestr 
41d5			 
41d5 fe 02				cp DS_TYPE_INUM 
41d7 28 0a				jr z, .typeinum 
41d9			 
41d9 21 f2 41				ld hl, .tna 
41dc 18 0a				jr .tpush 
41de			 
41de 21 ee 41		.typestr:	ld hl, .tstr 
41e1 18 05				jr .tpush 
41e3 21 f0 41		.typeinum:	ld hl, .tinum 
41e6 18 00				jr .tpush 
41e8			 
41e8			.tpush: 
41e8			 
41e8 cd 19 1c				call forth_push_str 
41eb			 
41eb					NEXTW 
41eb c3 58 1f			jp macro_next 
41ee				endm 
# End of macro NEXTW
41ee .. 00		.tstr:	db "s",0 
41f0 .. 00		.tinum:  db "i",0 
41f2 .. 00		.tna:   db "?", 0 
41f4			 
41f4			 
41f4			.UPPER: 
41f4				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
41f4 48				db WORD_SYS_CORE+52             
41f5 2f 42			dw .LOWER            
41f7 06				db 5 + 1 
41f8 .. 00			db "UPPER",0              
41fe				endm 
# End of macro CWHEAD
41fe			; | UPPER ( s -- s ) Upper case string s  | DONE 
41fe					if DEBUG_FORTH_WORDS_KEY 
41fe						DMARK "UPR" 
41fe f5				push af  
41ff 3a 13 42			ld a, (.dmark)  
4202 32 6b ee			ld (debug_mark),a  
4205 3a 14 42			ld a, (.dmark+1)  
4208 32 6c ee			ld (debug_mark+1),a  
420b 3a 15 42			ld a, (.dmark+2)  
420e 32 6d ee			ld (debug_mark+2),a  
4211 18 03			jr .pastdmark  
4213 ..			.dmark: db "UPR"  
4216 f1			.pastdmark: pop af  
4217			endm  
# End of macro DMARK
4217						CALLMONITOR 
4217 cd 6f ee			call debug_vector  
421a				endm  
# End of macro CALLMONITOR
421a					endif 
421a			 
421a					FORTH_DSP 
421a cd 68 1d			call macro_forth_dsp 
421d				endm 
# End of macro FORTH_DSP
421d					 
421d			; TODO check is string type 
421d			 
421d					FORTH_DSP_VALUEHL 
421d cd a2 1d			call macro_dsp_valuehl 
4220				endm 
# End of macro FORTH_DSP_VALUEHL
4220			; get pointer to string in hl 
4220			 
4220 7e			.toup:		ld a, (hl) 
4221 fe 00				cp 0 
4223 28 07				jr z, .toupdone 
4225			 
4225 cd ac 10				call to_upper 
4228			 
4228 77					ld (hl), a 
4229 23					inc hl 
422a 18 f4				jr .toup 
422c			 
422c					 
422c			 
422c			 
422c			; for each char convert to upper 
422c					 
422c			.toupdone: 
422c			 
422c			 
422c					NEXTW 
422c c3 58 1f			jp macro_next 
422f				endm 
# End of macro NEXTW
422f			.LOWER: 
422f				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
422f 48				db WORD_SYS_CORE+52             
4230 6a 42			dw .TCASE            
4232 06				db 5 + 1 
4233 .. 00			db "LOWER",0              
4239				endm 
# End of macro CWHEAD
4239			; | LOWER ( s -- s ) Lower case string s  | DONE 
4239					if DEBUG_FORTH_WORDS_KEY 
4239						DMARK "LWR" 
4239 f5				push af  
423a 3a 4e 42			ld a, (.dmark)  
423d 32 6b ee			ld (debug_mark),a  
4240 3a 4f 42			ld a, (.dmark+1)  
4243 32 6c ee			ld (debug_mark+1),a  
4246 3a 50 42			ld a, (.dmark+2)  
4249 32 6d ee			ld (debug_mark+2),a  
424c 18 03			jr .pastdmark  
424e ..			.dmark: db "LWR"  
4251 f1			.pastdmark: pop af  
4252			endm  
# End of macro DMARK
4252						CALLMONITOR 
4252 cd 6f ee			call debug_vector  
4255				endm  
# End of macro CALLMONITOR
4255					endif 
4255			 
4255					FORTH_DSP 
4255 cd 68 1d			call macro_forth_dsp 
4258				endm 
# End of macro FORTH_DSP
4258					 
4258			; TODO check is string type 
4258			 
4258					FORTH_DSP_VALUEHL 
4258 cd a2 1d			call macro_dsp_valuehl 
425b				endm 
# End of macro FORTH_DSP_VALUEHL
425b			; get pointer to string in hl 
425b			 
425b 7e			.tolow:		ld a, (hl) 
425c fe 00				cp 0 
425e 28 07				jr z, .tolowdone 
4260			 
4260 cd b5 10				call to_lower 
4263			 
4263 77					ld (hl), a 
4264 23					inc hl 
4265 18 f4				jr .tolow 
4267			 
4267					 
4267			 
4267			 
4267			; for each char convert to low 
4267					 
4267			.tolowdone: 
4267					NEXTW 
4267 c3 58 1f			jp macro_next 
426a				endm 
# End of macro NEXTW
426a			.TCASE: 
426a				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
426a 48				db WORD_SYS_CORE+52             
426b a0 43			dw .SUBSTR            
426d 06				db 5 + 1 
426e .. 00			db "TCASE",0              
4274				endm 
# End of macro CWHEAD
4274			; | TCASE ( s -- s ) Title case string s  | DONE 
4274					if DEBUG_FORTH_WORDS_KEY 
4274						DMARK "TCS" 
4274 f5				push af  
4275 3a 89 42			ld a, (.dmark)  
4278 32 6b ee			ld (debug_mark),a  
427b 3a 8a 42			ld a, (.dmark+1)  
427e 32 6c ee			ld (debug_mark+1),a  
4281 3a 8b 42			ld a, (.dmark+2)  
4284 32 6d ee			ld (debug_mark+2),a  
4287 18 03			jr .pastdmark  
4289 ..			.dmark: db "TCS"  
428c f1			.pastdmark: pop af  
428d			endm  
# End of macro DMARK
428d						CALLMONITOR 
428d cd 6f ee			call debug_vector  
4290				endm  
# End of macro CALLMONITOR
4290					endif 
4290			 
4290					FORTH_DSP 
4290 cd 68 1d			call macro_forth_dsp 
4293				endm 
# End of macro FORTH_DSP
4293					 
4293			; TODO check is string type 
4293			 
4293					FORTH_DSP_VALUEHL 
4293 cd a2 1d			call macro_dsp_valuehl 
4296				endm 
# End of macro FORTH_DSP_VALUEHL
4296			; get pointer to string in hl 
4296			 
4296					if DEBUG_FORTH_WORDS 
4296						DMARK "TC1" 
4296 f5				push af  
4297 3a ab 42			ld a, (.dmark)  
429a 32 6b ee			ld (debug_mark),a  
429d 3a ac 42			ld a, (.dmark+1)  
42a0 32 6c ee			ld (debug_mark+1),a  
42a3 3a ad 42			ld a, (.dmark+2)  
42a6 32 6d ee			ld (debug_mark+2),a  
42a9 18 03			jr .pastdmark  
42ab ..			.dmark: db "TC1"  
42ae f1			.pastdmark: pop af  
42af			endm  
# End of macro DMARK
42af						CALLMONITOR 
42af cd 6f ee			call debug_vector  
42b2				endm  
# End of macro CALLMONITOR
42b2					endif 
42b2			 
42b2					; first time in turn to upper case first char 
42b2			 
42b2 7e					ld a, (hl) 
42b3 c3 3d 43				jp .totsiptou 
42b6			 
42b6			 
42b6 7e			.tot:		ld a, (hl) 
42b7 fe 00				cp 0 
42b9 ca 81 43				jp z, .totdone 
42bc			 
42bc					if DEBUG_FORTH_WORDS 
42bc						DMARK "TC2" 
42bc f5				push af  
42bd 3a d1 42			ld a, (.dmark)  
42c0 32 6b ee			ld (debug_mark),a  
42c3 3a d2 42			ld a, (.dmark+1)  
42c6 32 6c ee			ld (debug_mark+1),a  
42c9 3a d3 42			ld a, (.dmark+2)  
42cc 32 6d ee			ld (debug_mark+2),a  
42cf 18 03			jr .pastdmark  
42d1 ..			.dmark: db "TC2"  
42d4 f1			.pastdmark: pop af  
42d5			endm  
# End of macro DMARK
42d5						CALLMONITOR 
42d5 cd 6f ee			call debug_vector  
42d8				endm  
# End of macro CALLMONITOR
42d8					endif 
42d8					; check to see if current char is a space 
42d8			 
42d8 fe 20				cp ' ' 
42da 28 21				jr z, .totsp 
42dc cd b5 10				call to_lower 
42df					if DEBUG_FORTH_WORDS 
42df						DMARK "TC3" 
42df f5				push af  
42e0 3a f4 42			ld a, (.dmark)  
42e3 32 6b ee			ld (debug_mark),a  
42e6 3a f5 42			ld a, (.dmark+1)  
42e9 32 6c ee			ld (debug_mark+1),a  
42ec 3a f6 42			ld a, (.dmark+2)  
42ef 32 6d ee			ld (debug_mark+2),a  
42f2 18 03			jr .pastdmark  
42f4 ..			.dmark: db "TC3"  
42f7 f1			.pastdmark: pop af  
42f8			endm  
# End of macro DMARK
42f8						CALLMONITOR 
42f8 cd 6f ee			call debug_vector  
42fb				endm  
# End of macro CALLMONITOR
42fb					endif 
42fb 18 63				jr .totnxt 
42fd			 
42fd			.totsp:         ; on a space, find next char which should be upper 
42fd			 
42fd					if DEBUG_FORTH_WORDS 
42fd						DMARK "TC4" 
42fd f5				push af  
42fe 3a 12 43			ld a, (.dmark)  
4301 32 6b ee			ld (debug_mark),a  
4304 3a 13 43			ld a, (.dmark+1)  
4307 32 6c ee			ld (debug_mark+1),a  
430a 3a 14 43			ld a, (.dmark+2)  
430d 32 6d ee			ld (debug_mark+2),a  
4310 18 03			jr .pastdmark  
4312 ..			.dmark: db "TC4"  
4315 f1			.pastdmark: pop af  
4316			endm  
# End of macro DMARK
4316						CALLMONITOR 
4316 cd 6f ee			call debug_vector  
4319				endm  
# End of macro CALLMONITOR
4319					endif 
4319					;; 
4319			 
4319 fe 20				cp ' ' 
431b 20 20				jr nz, .totsiptou 
431d 23					inc hl 
431e 7e					ld a, (hl) 
431f					if DEBUG_FORTH_WORDS 
431f						DMARK "TC5" 
431f f5				push af  
4320 3a 34 43			ld a, (.dmark)  
4323 32 6b ee			ld (debug_mark),a  
4326 3a 35 43			ld a, (.dmark+1)  
4329 32 6c ee			ld (debug_mark+1),a  
432c 3a 36 43			ld a, (.dmark+2)  
432f 32 6d ee			ld (debug_mark+2),a  
4332 18 03			jr .pastdmark  
4334 ..			.dmark: db "TC5"  
4337 f1			.pastdmark: pop af  
4338			endm  
# End of macro DMARK
4338						CALLMONITOR 
4338 cd 6f ee			call debug_vector  
433b				endm  
# End of macro CALLMONITOR
433b					endif 
433b 18 c0				jr .totsp 
433d fe 00		.totsiptou:    cp 0 
433f 28 40				jr z, .totdone 
4341					; not space and not zero term so upper case it 
4341 cd ac 10				call to_upper 
4344			 
4344					if DEBUG_FORTH_WORDS 
4344						DMARK "TC6" 
4344 f5				push af  
4345 3a 59 43			ld a, (.dmark)  
4348 32 6b ee			ld (debug_mark),a  
434b 3a 5a 43			ld a, (.dmark+1)  
434e 32 6c ee			ld (debug_mark+1),a  
4351 3a 5b 43			ld a, (.dmark+2)  
4354 32 6d ee			ld (debug_mark+2),a  
4357 18 03			jr .pastdmark  
4359 ..			.dmark: db "TC6"  
435c f1			.pastdmark: pop af  
435d			endm  
# End of macro DMARK
435d						CALLMONITOR 
435d cd 6f ee			call debug_vector  
4360				endm  
# End of macro CALLMONITOR
4360					endif 
4360			 
4360			 
4360			.totnxt: 
4360			 
4360 77					ld (hl), a 
4361 23					inc hl 
4362					if DEBUG_FORTH_WORDS 
4362						DMARK "TC7" 
4362 f5				push af  
4363 3a 77 43			ld a, (.dmark)  
4366 32 6b ee			ld (debug_mark),a  
4369 3a 78 43			ld a, (.dmark+1)  
436c 32 6c ee			ld (debug_mark+1),a  
436f 3a 79 43			ld a, (.dmark+2)  
4372 32 6d ee			ld (debug_mark+2),a  
4375 18 03			jr .pastdmark  
4377 ..			.dmark: db "TC7"  
437a f1			.pastdmark: pop af  
437b			endm  
# End of macro DMARK
437b						CALLMONITOR 
437b cd 6f ee			call debug_vector  
437e				endm  
# End of macro CALLMONITOR
437e					endif 
437e c3 b6 42				jp .tot 
4381			 
4381					 
4381			 
4381			 
4381			; for each char convert to low 
4381					 
4381			.totdone: 
4381					if DEBUG_FORTH_WORDS 
4381						DMARK "TCd" 
4381 f5				push af  
4382 3a 96 43			ld a, (.dmark)  
4385 32 6b ee			ld (debug_mark),a  
4388 3a 97 43			ld a, (.dmark+1)  
438b 32 6c ee			ld (debug_mark+1),a  
438e 3a 98 43			ld a, (.dmark+2)  
4391 32 6d ee			ld (debug_mark+2),a  
4394 18 03			jr .pastdmark  
4396 ..			.dmark: db "TCd"  
4399 f1			.pastdmark: pop af  
439a			endm  
# End of macro DMARK
439a						CALLMONITOR 
439a cd 6f ee			call debug_vector  
439d				endm  
# End of macro CALLMONITOR
439d					endif 
439d					NEXTW 
439d c3 58 1f			jp macro_next 
43a0				endm 
# End of macro NEXTW
43a0			 
43a0			.SUBSTR: 
43a0				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
43a0 48				db WORD_SYS_CORE+52             
43a1 fe 43			dw .LEFT            
43a3 07				db 6 + 1 
43a4 .. 00			db "SUBSTR",0              
43ab				endm 
# End of macro CWHEAD
43ab			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
43ab			 
43ab					if DEBUG_FORTH_WORDS_KEY 
43ab						DMARK "SST" 
43ab f5				push af  
43ac 3a c0 43			ld a, (.dmark)  
43af 32 6b ee			ld (debug_mark),a  
43b2 3a c1 43			ld a, (.dmark+1)  
43b5 32 6c ee			ld (debug_mark+1),a  
43b8 3a c2 43			ld a, (.dmark+2)  
43bb 32 6d ee			ld (debug_mark+2),a  
43be 18 03			jr .pastdmark  
43c0 ..			.dmark: db "SST"  
43c3 f1			.pastdmark: pop af  
43c4			endm  
# End of macro DMARK
43c4						CALLMONITOR 
43c4 cd 6f ee			call debug_vector  
43c7				endm  
# End of macro CALLMONITOR
43c7					endif 
43c7			; TODO check string type 
43c7					FORTH_DSP_VALUEHL 
43c7 cd a2 1d			call macro_dsp_valuehl 
43ca				endm 
# End of macro FORTH_DSP_VALUEHL
43ca			 
43ca e5					push hl      ; string length 
43cb			 
43cb					FORTH_DSP_POP 
43cb cd 5a 1e			call macro_forth_dsp_pop 
43ce				endm 
# End of macro FORTH_DSP_POP
43ce			 
43ce					FORTH_DSP_VALUEHL 
43ce cd a2 1d			call macro_dsp_valuehl 
43d1				endm 
# End of macro FORTH_DSP_VALUEHL
43d1			 
43d1 e5					push hl     ; start char 
43d2			 
43d2					FORTH_DSP_POP 
43d2 cd 5a 1e			call macro_forth_dsp_pop 
43d5				endm 
# End of macro FORTH_DSP_POP
43d5			 
43d5			 
43d5					FORTH_DSP_VALUE 
43d5 cd 8b 1d			call macro_forth_dsp_value 
43d8				endm 
# End of macro FORTH_DSP_VALUE
43d8			 
43d8 d1					pop de    ; get start post offset 
43d9			 
43d9 19					add hl, de    ; starting offset 
43da			 
43da c1					pop bc 
43db c5					push bc      ; grab size of string 
43dc			 
43dc e5					push hl    ; save string start  
43dd			 
43dd 26 00				ld h, 0 
43df 69					ld l, c 
43e0 23					inc hl 
43e1 23					inc hl 
43e2			 
43e2 cd 12 12				call malloc 
43e5				if DEBUG_FORTH_MALLOC_GUARD 
43e5 cc 18 4d				call z,malloc_error 
43e8				endif 
43e8			 
43e8 eb					ex de, hl      ; save malloc area for string copy 
43e9 e1					pop hl    ; get back source 
43ea c1					pop bc    ; get length of string back 
43eb			 
43eb d5					push de    ; save malloc area for after we push 
43ec ed b0				ldir     ; copy substr 
43ee			 
43ee			 
43ee eb					ex de, hl 
43ef 3e 00				ld a, 0 
43f1 77					ld (hl), a   ; term substr 
43f2			 
43f2					 
43f2 e1					pop hl    ; get malloc so we can push it 
43f3 e5					push hl   ; save so we can free it afterwards 
43f4			 
43f4 cd 19 1c				call forth_push_str 
43f7			 
43f7 e1					pop hl 
43f8 cd dc 12				call free 
43fb			 
43fb					 
43fb					 
43fb			 
43fb			 
43fb					NEXTW 
43fb c3 58 1f			jp macro_next 
43fe				endm 
# End of macro NEXTW
43fe			 
43fe			.LEFT: 
43fe				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
43fe 48				db WORD_SYS_CORE+52             
43ff 26 44			dw .RIGHT            
4401 05				db 4 + 1 
4402 .. 00			db "LEFT",0              
4407				endm 
# End of macro CWHEAD
4407			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
4407					if DEBUG_FORTH_WORDS_KEY 
4407						DMARK "LEF" 
4407 f5				push af  
4408 3a 1c 44			ld a, (.dmark)  
440b 32 6b ee			ld (debug_mark),a  
440e 3a 1d 44			ld a, (.dmark+1)  
4411 32 6c ee			ld (debug_mark+1),a  
4414 3a 1e 44			ld a, (.dmark+2)  
4417 32 6d ee			ld (debug_mark+2),a  
441a 18 03			jr .pastdmark  
441c ..			.dmark: db "LEF"  
441f f1			.pastdmark: pop af  
4420			endm  
# End of macro DMARK
4420						CALLMONITOR 
4420 cd 6f ee			call debug_vector  
4423				endm  
# End of macro CALLMONITOR
4423					endif 
4423			 
4423					NEXTW 
4423 c3 58 1f			jp macro_next 
4426				endm 
# End of macro NEXTW
4426			.RIGHT: 
4426				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
4426 48				db WORD_SYS_CORE+52             
4427 4f 44			dw .STR2NUM            
4429 06				db 5 + 1 
442a .. 00			db "RIGHT",0              
4430				endm 
# End of macro CWHEAD
4430			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
4430					if DEBUG_FORTH_WORDS_KEY 
4430						DMARK "RIG" 
4430 f5				push af  
4431 3a 45 44			ld a, (.dmark)  
4434 32 6b ee			ld (debug_mark),a  
4437 3a 46 44			ld a, (.dmark+1)  
443a 32 6c ee			ld (debug_mark+1),a  
443d 3a 47 44			ld a, (.dmark+2)  
4440 32 6d ee			ld (debug_mark+2),a  
4443 18 03			jr .pastdmark  
4445 ..			.dmark: db "RIG"  
4448 f1			.pastdmark: pop af  
4449			endm  
# End of macro DMARK
4449						CALLMONITOR 
4449 cd 6f ee			call debug_vector  
444c				endm  
# End of macro CALLMONITOR
444c					endif 
444c			 
444c					NEXTW 
444c c3 58 1f			jp macro_next 
444f				endm 
# End of macro NEXTW
444f			 
444f			 
444f			.STR2NUM: 
444f				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
444f 48				db WORD_SYS_CORE+52             
4450 db 44			dw .NUM2STR            
4452 08				db 7 + 1 
4453 .. 00			db "STR2NUM",0              
445b				endm 
# End of macro CWHEAD
445b			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
445b			 
445b			 
445b			; TODO STR type check to do 
445b					if DEBUG_FORTH_WORDS_KEY 
445b						DMARK "S2N" 
445b f5				push af  
445c 3a 70 44			ld a, (.dmark)  
445f 32 6b ee			ld (debug_mark),a  
4462 3a 71 44			ld a, (.dmark+1)  
4465 32 6c ee			ld (debug_mark+1),a  
4468 3a 72 44			ld a, (.dmark+2)  
446b 32 6d ee			ld (debug_mark+2),a  
446e 18 03			jr .pastdmark  
4470 ..			.dmark: db "S2N"  
4473 f1			.pastdmark: pop af  
4474			endm  
# End of macro DMARK
4474						CALLMONITOR 
4474 cd 6f ee			call debug_vector  
4477				endm  
# End of macro CALLMONITOR
4477					endif 
4477			 
4477					;FORTH_DSP 
4477					FORTH_DSP_VALUE 
4477 cd 8b 1d			call macro_forth_dsp_value 
447a				endm 
# End of macro FORTH_DSP_VALUE
447a					;inc hl 
447a			 
447a eb					ex de, hl 
447b					if DEBUG_FORTH_WORDS 
447b						DMARK "S2a" 
447b f5				push af  
447c 3a 90 44			ld a, (.dmark)  
447f 32 6b ee			ld (debug_mark),a  
4482 3a 91 44			ld a, (.dmark+1)  
4485 32 6c ee			ld (debug_mark+1),a  
4488 3a 92 44			ld a, (.dmark+2)  
448b 32 6d ee			ld (debug_mark+2),a  
448e 18 03			jr .pastdmark  
4490 ..			.dmark: db "S2a"  
4493 f1			.pastdmark: pop af  
4494			endm  
# End of macro DMARK
4494						CALLMONITOR 
4494 cd 6f ee			call debug_vector  
4497				endm  
# End of macro CALLMONITOR
4497					endif 
4497 cd 34 11				call string_to_uint16 
449a			 
449a					if DEBUG_FORTH_WORDS 
449a						DMARK "S2b" 
449a f5				push af  
449b 3a af 44			ld a, (.dmark)  
449e 32 6b ee			ld (debug_mark),a  
44a1 3a b0 44			ld a, (.dmark+1)  
44a4 32 6c ee			ld (debug_mark+1),a  
44a7 3a b1 44			ld a, (.dmark+2)  
44aa 32 6d ee			ld (debug_mark+2),a  
44ad 18 03			jr .pastdmark  
44af ..			.dmark: db "S2b"  
44b2 f1			.pastdmark: pop af  
44b3			endm  
# End of macro DMARK
44b3						CALLMONITOR 
44b3 cd 6f ee			call debug_vector  
44b6				endm  
# End of macro CALLMONITOR
44b6					endif 
44b6			;		push hl 
44b6					FORTH_DSP_POP 
44b6 cd 5a 1e			call macro_forth_dsp_pop 
44b9				endm 
# End of macro FORTH_DSP_POP
44b9			;		pop hl 
44b9					 
44b9					if DEBUG_FORTH_WORDS 
44b9						DMARK "S2b" 
44b9 f5				push af  
44ba 3a ce 44			ld a, (.dmark)  
44bd 32 6b ee			ld (debug_mark),a  
44c0 3a cf 44			ld a, (.dmark+1)  
44c3 32 6c ee			ld (debug_mark+1),a  
44c6 3a d0 44			ld a, (.dmark+2)  
44c9 32 6d ee			ld (debug_mark+2),a  
44cc 18 03			jr .pastdmark  
44ce ..			.dmark: db "S2b"  
44d1 f1			.pastdmark: pop af  
44d2			endm  
# End of macro DMARK
44d2						CALLMONITOR 
44d2 cd 6f ee			call debug_vector  
44d5				endm  
# End of macro CALLMONITOR
44d5					endif 
44d5 cd ab 1b				call forth_push_numhl	 
44d8			 
44d8				 
44d8				       NEXTW 
44d8 c3 58 1f			jp macro_next 
44db				endm 
# End of macro NEXTW
44db			.NUM2STR: 
44db				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
44db 48				db WORD_SYS_CORE+52             
44dc ea 44			dw .CONCAT            
44de 08				db 7 + 1 
44df .. 00			db "NUM2STR",0              
44e7				endm 
# End of macro CWHEAD
44e7			; | NUM2STR ( n -- s ) Convert a number on TOS to string | TODO 
44e7			 
44e7			;		; malloc a string to target 
44e7			;		ld hl, 10     ; TODO max string size should be fine 
44e7			;		call malloc 
44e7			;		push hl    ; save malloc location 
44e7			; 
44e7			; 
44e7			;; TODO check int type 
44e7			;		FORTH_DSP_VALUEHL 
44e7			;		ld a, l 
44e7			;		call DispAToASCII   
44e7			;;TODO need to chage above call to dump into string 
44e7			; 
44e7			; 
44e7			 
44e7				       NEXTW 
44e7 c3 58 1f			jp macro_next 
44ea				endm 
# End of macro NEXTW
44ea			 
44ea			.CONCAT: 
44ea				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
44ea 48				db WORD_SYS_CORE+52             
44eb 9d 45			dw .FIND            
44ed 07				db 6 + 1 
44ee .. 00			db "CONCAT",0              
44f5				endm 
# End of macro CWHEAD
44f5			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
44f5			 
44f5			; TODO check string type 
44f5			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
44f5			 
44f5					if DEBUG_FORTH_WORDS_KEY 
44f5						DMARK "CON" 
44f5 f5				push af  
44f6 3a 0a 45			ld a, (.dmark)  
44f9 32 6b ee			ld (debug_mark),a  
44fc 3a 0b 45			ld a, (.dmark+1)  
44ff 32 6c ee			ld (debug_mark+1),a  
4502 3a 0c 45			ld a, (.dmark+2)  
4505 32 6d ee			ld (debug_mark+2),a  
4508 18 03			jr .pastdmark  
450a ..			.dmark: db "CON"  
450d f1			.pastdmark: pop af  
450e			endm  
# End of macro DMARK
450e						CALLMONITOR 
450e cd 6f ee			call debug_vector  
4511				endm  
# End of macro CALLMONITOR
4511					endif 
4511			 
4511			 
4511					FORTH_DSP_VALUE 
4511 cd 8b 1d			call macro_forth_dsp_value 
4514				endm 
# End of macro FORTH_DSP_VALUE
4514 e5					push hl   ; s2 
4515			 
4515					FORTH_DSP_POP 
4515 cd 5a 1e			call macro_forth_dsp_pop 
4518				endm 
# End of macro FORTH_DSP_POP
4518			 
4518					FORTH_DSP_VALUE 
4518 cd 8b 1d			call macro_forth_dsp_value 
451b				endm 
# End of macro FORTH_DSP_VALUE
451b			 
451b e5					push hl   ; s1 
451c			 
451c					FORTH_DSP_POP 
451c cd 5a 1e			call macro_forth_dsp_pop 
451f				endm 
# End of macro FORTH_DSP_POP
451f					 
451f			 
451f					; copy s1 
451f			 
451f				 
451f					; save ptr 
451f e1					pop hl  
4520 e5					push hl 
4521 3e 00				ld a, 0 
4523 cd a8 11				call strlent 
4526					;inc hl    ; zer0 
4526 06 00				ld b, 0 
4528 4d					ld c, l 
4529 e1					pop hl		 
452a 11 c1 e2				ld de, scratch	 
452d					if DEBUG_FORTH_WORDS 
452d						DMARK "CO1" 
452d f5				push af  
452e 3a 42 45			ld a, (.dmark)  
4531 32 6b ee			ld (debug_mark),a  
4534 3a 43 45			ld a, (.dmark+1)  
4537 32 6c ee			ld (debug_mark+1),a  
453a 3a 44 45			ld a, (.dmark+2)  
453d 32 6d ee			ld (debug_mark+2),a  
4540 18 03			jr .pastdmark  
4542 ..			.dmark: db "CO1"  
4545 f1			.pastdmark: pop af  
4546			endm  
# End of macro DMARK
4546						CALLMONITOR 
4546 cd 6f ee			call debug_vector  
4549				endm  
# End of macro CALLMONITOR
4549					endif 
4549 ed b0				ldir 
454b			 
454b e1					pop hl 
454c e5					push hl 
454d d5					push de 
454e			 
454e			 
454e 3e 00				ld a, 0 
4550 cd a8 11				call strlent 
4553 23					inc hl    ; zer0 
4554 23					inc hl 
4555 06 00				ld b, 0 
4557 4d					ld c, l 
4558 d1					pop de 
4559 e1					pop hl		 
455a					if DEBUG_FORTH_WORDS 
455a						DMARK "CO2" 
455a f5				push af  
455b 3a 6f 45			ld a, (.dmark)  
455e 32 6b ee			ld (debug_mark),a  
4561 3a 70 45			ld a, (.dmark+1)  
4564 32 6c ee			ld (debug_mark+1),a  
4567 3a 71 45			ld a, (.dmark+2)  
456a 32 6d ee			ld (debug_mark+2),a  
456d 18 03			jr .pastdmark  
456f ..			.dmark: db "CO2"  
4572 f1			.pastdmark: pop af  
4573			endm  
# End of macro DMARK
4573						CALLMONITOR 
4573 cd 6f ee			call debug_vector  
4576				endm  
# End of macro CALLMONITOR
4576					endif 
4576 ed b0				ldir 
4578			 
4578			 
4578			 
4578 21 c1 e2				ld hl, scratch 
457b					if DEBUG_FORTH_WORDS 
457b						DMARK "CO5" 
457b f5				push af  
457c 3a 90 45			ld a, (.dmark)  
457f 32 6b ee			ld (debug_mark),a  
4582 3a 91 45			ld a, (.dmark+1)  
4585 32 6c ee			ld (debug_mark+1),a  
4588 3a 92 45			ld a, (.dmark+2)  
458b 32 6d ee			ld (debug_mark+2),a  
458e 18 03			jr .pastdmark  
4590 ..			.dmark: db "CO5"  
4593 f1			.pastdmark: pop af  
4594			endm  
# End of macro DMARK
4594						CALLMONITOR 
4594 cd 6f ee			call debug_vector  
4597				endm  
# End of macro CALLMONITOR
4597					endif 
4597			 
4597 cd 19 1c				call forth_push_str 
459a			 
459a			 
459a			 
459a			 
459a				       NEXTW 
459a c3 58 1f			jp macro_next 
459d				endm 
# End of macro NEXTW
459d			 
459d			 
459d			.FIND: 
459d				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
459d 4b				db WORD_SYS_CORE+55             
459e 5b 46			dw .LEN            
45a0 05				db 4 + 1 
45a1 .. 00			db "FIND",0              
45a6				endm 
# End of macro CWHEAD
45a6			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
45a6			 
45a6					if DEBUG_FORTH_WORDS_KEY 
45a6						DMARK "FND" 
45a6 f5				push af  
45a7 3a bb 45			ld a, (.dmark)  
45aa 32 6b ee			ld (debug_mark),a  
45ad 3a bc 45			ld a, (.dmark+1)  
45b0 32 6c ee			ld (debug_mark+1),a  
45b3 3a bd 45			ld a, (.dmark+2)  
45b6 32 6d ee			ld (debug_mark+2),a  
45b9 18 03			jr .pastdmark  
45bb ..			.dmark: db "FND"  
45be f1			.pastdmark: pop af  
45bf			endm  
# End of macro DMARK
45bf						CALLMONITOR 
45bf cd 6f ee			call debug_vector  
45c2				endm  
# End of macro CALLMONITOR
45c2					endif 
45c2			 
45c2			; TODO check string type 
45c2					FORTH_DSP_VALUE 
45c2 cd 8b 1d			call macro_forth_dsp_value 
45c5				endm 
# End of macro FORTH_DSP_VALUE
45c5			 
45c5 e5					push hl    
45c6 7e					ld a,(hl)    ; char to find   
45c7			; TODO change char to substr 
45c7			 
45c7 f5					push af 
45c8					 
45c8			 
45c8			 
45c8					if DEBUG_FORTH_WORDS 
45c8						DMARK "FN1" 
45c8 f5				push af  
45c9 3a dd 45			ld a, (.dmark)  
45cc 32 6b ee			ld (debug_mark),a  
45cf 3a de 45			ld a, (.dmark+1)  
45d2 32 6c ee			ld (debug_mark+1),a  
45d5 3a df 45			ld a, (.dmark+2)  
45d8 32 6d ee			ld (debug_mark+2),a  
45db 18 03			jr .pastdmark  
45dd ..			.dmark: db "FN1"  
45e0 f1			.pastdmark: pop af  
45e1			endm  
# End of macro DMARK
45e1						CALLMONITOR 
45e1 cd 6f ee			call debug_vector  
45e4				endm  
# End of macro CALLMONITOR
45e4					endif 
45e4			 
45e4					FORTH_DSP_POP 
45e4 cd 5a 1e			call macro_forth_dsp_pop 
45e7				endm 
# End of macro FORTH_DSP_POP
45e7			 
45e7					; string to search 
45e7			 
45e7					FORTH_DSP_VALUE 
45e7 cd 8b 1d			call macro_forth_dsp_value 
45ea				endm 
# End of macro FORTH_DSP_VALUE
45ea			 
45ea d1					pop de  ; d is char to find  
45eb			 
45eb					if DEBUG_FORTH_WORDS 
45eb						DMARK "FN2" 
45eb f5				push af  
45ec 3a 00 46			ld a, (.dmark)  
45ef 32 6b ee			ld (debug_mark),a  
45f2 3a 01 46			ld a, (.dmark+1)  
45f5 32 6c ee			ld (debug_mark+1),a  
45f8 3a 02 46			ld a, (.dmark+2)  
45fb 32 6d ee			ld (debug_mark+2),a  
45fe 18 03			jr .pastdmark  
4600 ..			.dmark: db "FN2"  
4603 f1			.pastdmark: pop af  
4604			endm  
# End of macro DMARK
4604						CALLMONITOR 
4604 cd 6f ee			call debug_vector  
4607				endm  
# End of macro CALLMONITOR
4607					endif 
4607					 
4607 01 00 00				ld bc, 0 
460a 7e			.findchar:      ld a,(hl) 
460b fe 00				cp 0   		 
460d 28 27				jr z, .finddone     
460f ba					cp d 
4610 28 20				jr z, .foundchar 
4612 03					inc bc 
4613 23					inc hl 
4614					if DEBUG_FORTH_WORDS 
4614						DMARK "FN3" 
4614 f5				push af  
4615 3a 29 46			ld a, (.dmark)  
4618 32 6b ee			ld (debug_mark),a  
461b 3a 2a 46			ld a, (.dmark+1)  
461e 32 6c ee			ld (debug_mark+1),a  
4621 3a 2b 46			ld a, (.dmark+2)  
4624 32 6d ee			ld (debug_mark+2),a  
4627 18 03			jr .pastdmark  
4629 ..			.dmark: db "FN3"  
462c f1			.pastdmark: pop af  
462d			endm  
# End of macro DMARK
462d						CALLMONITOR 
462d cd 6f ee			call debug_vector  
4630				endm  
# End of macro CALLMONITOR
4630					endif 
4630 18 d8				jr .findchar 
4632			 
4632			 
4632 c5			.foundchar:	push bc 
4633 e1					pop hl 
4634 18 03				jr .findexit 
4636			 
4636			 
4636							 
4636			 
4636			.finddone:     ; got to end of string with no find 
4636 21 00 00				ld hl, 0 
4639			.findexit: 
4639			 
4639					if DEBUG_FORTH_WORDS 
4639						DMARK "FNd" 
4639 f5				push af  
463a 3a 4e 46			ld a, (.dmark)  
463d 32 6b ee			ld (debug_mark),a  
4640 3a 4f 46			ld a, (.dmark+1)  
4643 32 6c ee			ld (debug_mark+1),a  
4646 3a 50 46			ld a, (.dmark+2)  
4649 32 6d ee			ld (debug_mark+2),a  
464c 18 03			jr .pastdmark  
464e ..			.dmark: db "FNd"  
4651 f1			.pastdmark: pop af  
4652			endm  
# End of macro DMARK
4652						CALLMONITOR 
4652 cd 6f ee			call debug_vector  
4655				endm  
# End of macro CALLMONITOR
4655					endif 
4655 cd ab 1b			call forth_push_numhl 
4658			 
4658				       NEXTW 
4658 c3 58 1f			jp macro_next 
465b				endm 
# End of macro NEXTW
465b			 
465b			.LEN: 
465b				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
465b 4c				db WORD_SYS_CORE+56             
465c c5 46			dw .ASC            
465e 06				db 5 + 1 
465f .. 00			db "COUNT",0              
4665				endm 
# End of macro CWHEAD
4665			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
4665			 
4665					if DEBUG_FORTH_WORDS_KEY 
4665						DMARK "CNT" 
4665 f5				push af  
4666 3a 7a 46			ld a, (.dmark)  
4669 32 6b ee			ld (debug_mark),a  
466c 3a 7b 46			ld a, (.dmark+1)  
466f 32 6c ee			ld (debug_mark+1),a  
4672 3a 7c 46			ld a, (.dmark+2)  
4675 32 6d ee			ld (debug_mark+2),a  
4678 18 03			jr .pastdmark  
467a ..			.dmark: db "CNT"  
467d f1			.pastdmark: pop af  
467e			endm  
# End of macro DMARK
467e						CALLMONITOR 
467e cd 6f ee			call debug_vector  
4681				endm  
# End of macro CALLMONITOR
4681					endif 
4681			; TODO check string type 
4681					FORTH_DSP_VALUE 
4681 cd 8b 1d			call macro_forth_dsp_value 
4684				endm 
# End of macro FORTH_DSP_VALUE
4684			 
4684			 
4684					if DEBUG_FORTH_WORDS 
4684						DMARK "CN?" 
4684 f5				push af  
4685 3a 99 46			ld a, (.dmark)  
4688 32 6b ee			ld (debug_mark),a  
468b 3a 9a 46			ld a, (.dmark+1)  
468e 32 6c ee			ld (debug_mark+1),a  
4691 3a 9b 46			ld a, (.dmark+2)  
4694 32 6d ee			ld (debug_mark+2),a  
4697 18 03			jr .pastdmark  
4699 ..			.dmark: db "CN?"  
469c f1			.pastdmark: pop af  
469d			endm  
# End of macro DMARK
469d						CALLMONITOR 
469d cd 6f ee			call debug_vector  
46a0				endm  
# End of macro CALLMONITOR
46a0					endif 
46a0 cd 9d 11				call strlenz 
46a3					if DEBUG_FORTH_WORDS 
46a3						DMARK "CNl" 
46a3 f5				push af  
46a4 3a b8 46			ld a, (.dmark)  
46a7 32 6b ee			ld (debug_mark),a  
46aa 3a b9 46			ld a, (.dmark+1)  
46ad 32 6c ee			ld (debug_mark+1),a  
46b0 3a ba 46			ld a, (.dmark+2)  
46b3 32 6d ee			ld (debug_mark+2),a  
46b6 18 03			jr .pastdmark  
46b8 ..			.dmark: db "CNl"  
46bb f1			.pastdmark: pop af  
46bc			endm  
# End of macro DMARK
46bc						CALLMONITOR 
46bc cd 6f ee			call debug_vector  
46bf				endm  
# End of macro CALLMONITOR
46bf					endif 
46bf			 
46bf cd ab 1b				call forth_push_numhl 
46c2			 
46c2			 
46c2			 
46c2				       NEXTW 
46c2 c3 58 1f			jp macro_next 
46c5				endm 
# End of macro NEXTW
46c5			.ASC: 
46c5				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
46c5 4d				db WORD_SYS_CORE+57             
46c6 33 47			dw .CHR            
46c8 04				db 3 + 1 
46c9 .. 00			db "ASC",0              
46cd				endm 
# End of macro CWHEAD
46cd			; | ASC ( u -- n ) Get the ASCII value of the first character of the string on TOS | DONE 
46cd					if DEBUG_FORTH_WORDS_KEY 
46cd						DMARK "ASC" 
46cd f5				push af  
46ce 3a e2 46			ld a, (.dmark)  
46d1 32 6b ee			ld (debug_mark),a  
46d4 3a e3 46			ld a, (.dmark+1)  
46d7 32 6c ee			ld (debug_mark+1),a  
46da 3a e4 46			ld a, (.dmark+2)  
46dd 32 6d ee			ld (debug_mark+2),a  
46e0 18 03			jr .pastdmark  
46e2 ..			.dmark: db "ASC"  
46e5 f1			.pastdmark: pop af  
46e6			endm  
# End of macro DMARK
46e6						CALLMONITOR 
46e6 cd 6f ee			call debug_vector  
46e9				endm  
# End of macro CALLMONITOR
46e9					endif 
46e9					FORTH_DSP_VALUE 
46e9 cd 8b 1d			call macro_forth_dsp_value 
46ec				endm 
# End of macro FORTH_DSP_VALUE
46ec					;v5 FORTH_DSP_VALUE 
46ec			;		inc hl      ; now at start of numeric as string 
46ec			 
46ec e5					push hl 
46ed			 
46ed					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
46ed cd 5a 1e			call macro_forth_dsp_pop 
46f0				endm 
# End of macro FORTH_DSP_POP
46f0			 
46f0 e1					pop hl 
46f1			 
46f1					if DEBUG_FORTH_WORDS 
46f1						DMARK "AS1" 
46f1 f5				push af  
46f2 3a 06 47			ld a, (.dmark)  
46f5 32 6b ee			ld (debug_mark),a  
46f8 3a 07 47			ld a, (.dmark+1)  
46fb 32 6c ee			ld (debug_mark+1),a  
46fe 3a 08 47			ld a, (.dmark+2)  
4701 32 6d ee			ld (debug_mark+2),a  
4704 18 03			jr .pastdmark  
4706 ..			.dmark: db "AS1"  
4709 f1			.pastdmark: pop af  
470a			endm  
# End of macro DMARK
470a						CALLMONITOR 
470a cd 6f ee			call debug_vector  
470d				endm  
# End of macro CALLMONITOR
470d					endif 
470d					; push the content of a onto the stack as a value 
470d			 
470d 7e					ld a,(hl)   ; get char 
470e 26 00				ld h,0 
4710 6f					ld l,a 
4711					if DEBUG_FORTH_WORDS 
4711						DMARK "AS2" 
4711 f5				push af  
4712 3a 26 47			ld a, (.dmark)  
4715 32 6b ee			ld (debug_mark),a  
4718 3a 27 47			ld a, (.dmark+1)  
471b 32 6c ee			ld (debug_mark+1),a  
471e 3a 28 47			ld a, (.dmark+2)  
4721 32 6d ee			ld (debug_mark+2),a  
4724 18 03			jr .pastdmark  
4726 ..			.dmark: db "AS2"  
4729 f1			.pastdmark: pop af  
472a			endm  
# End of macro DMARK
472a						CALLMONITOR 
472a cd 6f ee			call debug_vector  
472d				endm  
# End of macro CALLMONITOR
472d					endif 
472d cd ab 1b				call forth_push_numhl 
4730			 
4730				       NEXTW 
4730 c3 58 1f			jp macro_next 
4733				endm 
# End of macro NEXTW
4733			 
4733			.CHR: 
4733				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
4733 4d				db WORD_SYS_CORE+57             
4734 6f 47			dw .ENDSTR            
4736 04				db 3 + 1 
4737 .. 00			db "CHR",0              
473b				endm 
# End of macro CWHEAD
473b			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
473b					if DEBUG_FORTH_WORDS_KEY 
473b						DMARK "CHR" 
473b f5				push af  
473c 3a 50 47			ld a, (.dmark)  
473f 32 6b ee			ld (debug_mark),a  
4742 3a 51 47			ld a, (.dmark+1)  
4745 32 6c ee			ld (debug_mark+1),a  
4748 3a 52 47			ld a, (.dmark+2)  
474b 32 6d ee			ld (debug_mark+2),a  
474e 18 03			jr .pastdmark  
4750 ..			.dmark: db "CHR"  
4753 f1			.pastdmark: pop af  
4754			endm  
# End of macro DMARK
4754						CALLMONITOR 
4754 cd 6f ee			call debug_vector  
4757				endm  
# End of macro CALLMONITOR
4757					endif 
4757					FORTH_DSP_VALUEHL 
4757 cd a2 1d			call macro_dsp_valuehl 
475a				endm 
# End of macro FORTH_DSP_VALUEHL
475a			 
475a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
475a cd 5a 1e			call macro_forth_dsp_pop 
475d				endm 
# End of macro FORTH_DSP_POP
475d			 
475d					; save asci byte as a zero term string and push string 
475d			 
475d 7d					ld a,l 
475e 32 c1 e2				ld (scratch), a 
4761			 
4761 3e 00				ld a, 0 
4763 32 c2 e2				ld (scratch+1), a 
4766			 
4766 21 c1 e2				ld hl, scratch 
4769 cd 19 1c				call forth_push_str 
476c			 
476c			 
476c				       NEXTW 
476c c3 58 1f			jp macro_next 
476f				endm 
# End of macro NEXTW
476f			 
476f			 
476f			 
476f			 
476f			.ENDSTR: 
476f			; eof 
476f			 
# End of file forth_words_str.asm
476f			include "forth_words_key.asm" 
476f			 
476f			; | ## Keyboard Words 
476f			 
476f			.KEY: 
476f				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
476f 3e				db WORD_SYS_CORE+42             
4770 9f 47			dw .WAITK            
4772 04				db 3 + 1 
4773 .. 00			db "KEY",0              
4777				endm 
# End of macro CWHEAD
4777			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
4777			 
4777					if DEBUG_FORTH_WORDS_KEY 
4777						DMARK "KEY" 
4777 f5				push af  
4778 3a 8c 47			ld a, (.dmark)  
477b 32 6b ee			ld (debug_mark),a  
477e 3a 8d 47			ld a, (.dmark+1)  
4781 32 6c ee			ld (debug_mark+1),a  
4784 3a 8e 47			ld a, (.dmark+2)  
4787 32 6d ee			ld (debug_mark+2),a  
478a 18 03			jr .pastdmark  
478c ..			.dmark: db "KEY"  
478f f1			.pastdmark: pop af  
4790			endm  
# End of macro DMARK
4790						CALLMONITOR 
4790 cd 6f ee			call debug_vector  
4793				endm  
# End of macro CALLMONITOR
4793					endif 
4793			; TODO currently waits 
4793 cd 87 65				call cin 
4796					;call cin_wait 
4796 6f					ld l, a 
4797 26 00				ld h, 0 
4799 cd ab 1b				call forth_push_numhl 
479c					NEXTW 
479c c3 58 1f			jp macro_next 
479f				endm 
# End of macro NEXTW
479f			.WAITK: 
479f				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
479f 3f				db WORD_SYS_CORE+43             
47a0 d1 47			dw .ACCEPT            
47a2 06				db 5 + 1 
47a3 .. 00			db "WAITK",0              
47a9				endm 
# End of macro CWHEAD
47a9			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
47a9					if DEBUG_FORTH_WORDS_KEY 
47a9						DMARK "WAI" 
47a9 f5				push af  
47aa 3a be 47			ld a, (.dmark)  
47ad 32 6b ee			ld (debug_mark),a  
47b0 3a bf 47			ld a, (.dmark+1)  
47b3 32 6c ee			ld (debug_mark+1),a  
47b6 3a c0 47			ld a, (.dmark+2)  
47b9 32 6d ee			ld (debug_mark+2),a  
47bc 18 03			jr .pastdmark  
47be ..			.dmark: db "WAI"  
47c1 f1			.pastdmark: pop af  
47c2			endm  
# End of macro DMARK
47c2						CALLMONITOR 
47c2 cd 6f ee			call debug_vector  
47c5				endm  
# End of macro CALLMONITOR
47c5					endif 
47c5 cd 7f 65				call cin_wait 
47c8 6f					ld l, a 
47c9 26 00				ld h, 0 
47cb cd ab 1b				call forth_push_numhl 
47ce					NEXTW 
47ce c3 58 1f			jp macro_next 
47d1				endm 
# End of macro NEXTW
47d1			.ACCEPT: 
47d1				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
47d1 40				db WORD_SYS_CORE+44             
47d2 2f 48			dw .EDIT            
47d4 07				db 6 + 1 
47d5 .. 00			db "ACCEPT",0              
47dc				endm 
# End of macro CWHEAD
47dc			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
47dc					; TODO crashes on push 
47dc					if DEBUG_FORTH_WORDS_KEY 
47dc						DMARK "ACC" 
47dc f5				push af  
47dd 3a f1 47			ld a, (.dmark)  
47e0 32 6b ee			ld (debug_mark),a  
47e3 3a f2 47			ld a, (.dmark+1)  
47e6 32 6c ee			ld (debug_mark+1),a  
47e9 3a f3 47			ld a, (.dmark+2)  
47ec 32 6d ee			ld (debug_mark+2),a  
47ef 18 03			jr .pastdmark  
47f1 ..			.dmark: db "ACC"  
47f4 f1			.pastdmark: pop af  
47f5			endm  
# End of macro DMARK
47f5						CALLMONITOR 
47f5 cd 6f ee			call debug_vector  
47f8				endm  
# End of macro CALLMONITOR
47f8					endif 
47f8 21 bf e4				ld hl, os_input 
47fb 3e 00				ld a, 0 
47fd 77					ld (hl),a 
47fe 3a 5e ea				ld a,(f_cursor_ptr) 
4801 16 64				ld d, 100 
4803 0e 00				ld c, 0 
4805 1e 28				ld e, 40 
4807 cd 13 0e				call input_str 
480a					; TODO perhaps do a type check and wrap in quotes if not a number 
480a 21 bf e4				ld hl, os_input 
480d					if DEBUG_FORTH_WORDS 
480d						DMARK "AC1" 
480d f5				push af  
480e 3a 22 48			ld a, (.dmark)  
4811 32 6b ee			ld (debug_mark),a  
4814 3a 23 48			ld a, (.dmark+1)  
4817 32 6c ee			ld (debug_mark+1),a  
481a 3a 24 48			ld a, (.dmark+2)  
481d 32 6d ee			ld (debug_mark+2),a  
4820 18 03			jr .pastdmark  
4822 ..			.dmark: db "AC1"  
4825 f1			.pastdmark: pop af  
4826			endm  
# End of macro DMARK
4826						CALLMONITOR 
4826 cd 6f ee			call debug_vector  
4829				endm  
# End of macro CALLMONITOR
4829					endif 
4829 cd 19 1c				call forth_push_str 
482c					NEXTW 
482c c3 58 1f			jp macro_next 
482f				endm 
# End of macro NEXTW
482f			 
482f			.EDIT: 
482f				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
482f 40				db WORD_SYS_CORE+44             
4830 d1 48			dw .DEDIT            
4832 05				db 4 + 1 
4833 .. 00			db "EDIT",0              
4838				endm 
# End of macro CWHEAD
4838			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4838			 
4838					; TODO does not copy from stack 
4838					if DEBUG_FORTH_WORDS_KEY 
4838						DMARK "EDT" 
4838 f5				push af  
4839 3a 4d 48			ld a, (.dmark)  
483c 32 6b ee			ld (debug_mark),a  
483f 3a 4e 48			ld a, (.dmark+1)  
4842 32 6c ee			ld (debug_mark+1),a  
4845 3a 4f 48			ld a, (.dmark+2)  
4848 32 6d ee			ld (debug_mark+2),a  
484b 18 03			jr .pastdmark  
484d ..			.dmark: db "EDT"  
4850 f1			.pastdmark: pop af  
4851			endm  
# End of macro DMARK
4851						CALLMONITOR 
4851 cd 6f ee			call debug_vector  
4854				endm  
# End of macro CALLMONITOR
4854					endif 
4854			 
4854					;FORTH_DSP 
4854					FORTH_DSP_VALUEHL 
4854 cd a2 1d			call macro_dsp_valuehl 
4857				endm 
# End of macro FORTH_DSP_VALUEHL
4857			;		inc hl    ; TODO do type check 
4857			 
4857			;		call get_word_hl 
4857 e5					push hl 
4858					if DEBUG_FORTH_WORDS 
4858						DMARK "EDp" 
4858 f5				push af  
4859 3a 6d 48			ld a, (.dmark)  
485c 32 6b ee			ld (debug_mark),a  
485f 3a 6e 48			ld a, (.dmark+1)  
4862 32 6c ee			ld (debug_mark+1),a  
4865 3a 6f 48			ld a, (.dmark+2)  
4868 32 6d ee			ld (debug_mark+2),a  
486b 18 03			jr .pastdmark  
486d ..			.dmark: db "EDp"  
4870 f1			.pastdmark: pop af  
4871			endm  
# End of macro DMARK
4871						CALLMONITOR 
4871 cd 6f ee			call debug_vector  
4874				endm  
# End of macro CALLMONITOR
4874					endif 
4874				;	ld a, 0 
4874 cd 9d 11				call strlenz 
4877 23					inc hl 
4878			 
4878 06 00				ld b, 0 
487a 4d					ld c, l 
487b			 
487b e1					pop hl 
487c 11 bf e4				ld de, os_input 
487f					if DEBUG_FORTH_WORDS_KEY 
487f						DMARK "EDc" 
487f f5				push af  
4880 3a 94 48			ld a, (.dmark)  
4883 32 6b ee			ld (debug_mark),a  
4886 3a 95 48			ld a, (.dmark+1)  
4889 32 6c ee			ld (debug_mark+1),a  
488c 3a 96 48			ld a, (.dmark+2)  
488f 32 6d ee			ld (debug_mark+2),a  
4892 18 03			jr .pastdmark  
4894 ..			.dmark: db "EDc"  
4897 f1			.pastdmark: pop af  
4898			endm  
# End of macro DMARK
4898						CALLMONITOR 
4898 cd 6f ee			call debug_vector  
489b				endm  
# End of macro CALLMONITOR
489b					endif 
489b ed b0				ldir 
489d			 
489d			 
489d 21 bf e4				ld hl, os_input 
48a0					;ld a, 0 
48a0					;ld (hl),a 
48a0 3a 5e ea				ld a,(f_cursor_ptr) 
48a3 16 64				ld d, 100 
48a5 0e 00				ld c, 0 
48a7 1e 28				ld e, 40 
48a9 cd 13 0e				call input_str 
48ac					; TODO perhaps do a type check and wrap in quotes if not a number 
48ac 21 bf e4				ld hl, os_input 
48af					if DEBUG_FORTH_WORDS 
48af						DMARK "ED1" 
48af f5				push af  
48b0 3a c4 48			ld a, (.dmark)  
48b3 32 6b ee			ld (debug_mark),a  
48b6 3a c5 48			ld a, (.dmark+1)  
48b9 32 6c ee			ld (debug_mark+1),a  
48bc 3a c6 48			ld a, (.dmark+2)  
48bf 32 6d ee			ld (debug_mark+2),a  
48c2 18 03			jr .pastdmark  
48c4 ..			.dmark: db "ED1"  
48c7 f1			.pastdmark: pop af  
48c8			endm  
# End of macro DMARK
48c8						CALLMONITOR 
48c8 cd 6f ee			call debug_vector  
48cb				endm  
# End of macro CALLMONITOR
48cb					endif 
48cb cd 19 1c				call forth_push_str 
48ce					NEXTW 
48ce c3 58 1f			jp macro_next 
48d1				endm 
# End of macro NEXTW
48d1			 
48d1			.DEDIT: 
48d1				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
48d1 40				db WORD_SYS_CORE+44             
48d2 33 49			dw .ENDKEY            
48d4 06				db 5 + 1 
48d5 .. 00			db "DEDIT",0              
48db				endm 
# End of macro CWHEAD
48db			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
48db			 
48db					; TODO does not copy from stack 
48db					if DEBUG_FORTH_WORDS_KEY 
48db						DMARK "DED" 
48db f5				push af  
48dc 3a f0 48			ld a, (.dmark)  
48df 32 6b ee			ld (debug_mark),a  
48e2 3a f1 48			ld a, (.dmark+1)  
48e5 32 6c ee			ld (debug_mark+1),a  
48e8 3a f2 48			ld a, (.dmark+2)  
48eb 32 6d ee			ld (debug_mark+2),a  
48ee 18 03			jr .pastdmark  
48f0 ..			.dmark: db "DED"  
48f3 f1			.pastdmark: pop af  
48f4			endm  
# End of macro DMARK
48f4						CALLMONITOR 
48f4 cd 6f ee			call debug_vector  
48f7				endm  
# End of macro CALLMONITOR
48f7					endif 
48f7			 
48f7					;FORTH_DSP 
48f7					FORTH_DSP_VALUEHL 
48f7 cd a2 1d			call macro_dsp_valuehl 
48fa				endm 
# End of macro FORTH_DSP_VALUEHL
48fa			;		inc hl    ; TODO do type check 
48fa			 
48fa			;		call get_word_hl 
48fa e5					push hl 
48fb e5					push hl 
48fc					FORTH_DSP_POP 
48fc cd 5a 1e			call macro_forth_dsp_pop 
48ff				endm 
# End of macro FORTH_DSP_POP
48ff e1					pop hl 
4900					if DEBUG_FORTH_WORDS 
4900						DMARK "EDp" 
4900 f5				push af  
4901 3a 15 49			ld a, (.dmark)  
4904 32 6b ee			ld (debug_mark),a  
4907 3a 16 49			ld a, (.dmark+1)  
490a 32 6c ee			ld (debug_mark+1),a  
490d 3a 17 49			ld a, (.dmark+2)  
4910 32 6d ee			ld (debug_mark+2),a  
4913 18 03			jr .pastdmark  
4915 ..			.dmark: db "EDp"  
4918 f1			.pastdmark: pop af  
4919			endm  
# End of macro DMARK
4919						CALLMONITOR 
4919 cd 6f ee			call debug_vector  
491c				endm  
# End of macro CALLMONITOR
491c					endif 
491c				;	ld a, 0 
491c cd 9d 11				call strlenz 
491f 23					inc hl 
4920			 
4920 06 00				ld b, 0 
4922 4d					ld c, l 
4923			 
4923 e1					pop hl 
4924			 
4924					;ld a, 0 
4924					;ld (hl),a 
4924 3a 5e ea				ld a,(f_cursor_ptr) 
4927 16 64				ld d, 100 
4929 0e 00				ld c, 0 
492b 1e 28				ld e, 40 
492d cd 13 0e				call input_str 
4930					; TODO perhaps do a type check and wrap in quotes if not a number 
4930					NEXTW 
4930 c3 58 1f			jp macro_next 
4933				endm 
# End of macro NEXTW
4933			 
4933			 
4933			.ENDKEY: 
4933			; eof 
4933			 
# End of file forth_words_key.asm
4933			include "forth_words_const.asm" 
4933			 
4933			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
4933			 
4933			 
4933			.SPITIME: 
4933				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
4933 77				db WORD_SYS_CORE+99             
4934 48 49			dw .VA            
4936 08				db 7 + 1 
4937 .. 00			db "SPITIME",0              
493f				endm 
# End of macro CWHEAD
493f			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack | DONE 
493f			; 
493f			; | | If using BANK devices then leave as is. 
493f			; | | Only really useful for the CARTDEV where other devices may be far too slow. In particular 
493f			; | | the multiplexing of the PicoSPINet addon which might not be running fast enough for all of the nodes 
493f			 
493f 21 64 ea				ld hl, spi_clktime  
4942 cd ab 1b				call forth_push_numhl 
4945			 
4945					NEXTW 
4945 c3 58 1f			jp macro_next 
4948				endm 
# End of macro NEXTW
4948			 
4948			 
4948			.VA: 
4948				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
4948 77				db WORD_SYS_CORE+99             
4949 58 49			dw .SYMBOL            
494b 03				db 2 + 1 
494c .. 00			db "VA",0              
494f				endm 
# End of macro CWHEAD
494f			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 | DONE 
494f 21 28 ea				ld hl, cli_var_array 
4952 cd ab 1b				call forth_push_numhl 
4955			 
4955					NEXTW 
4955 c3 58 1f			jp macro_next 
4958				endm 
# End of macro NEXTW
4958			 
4958			.SYMBOL: 
4958				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
4958 77				db WORD_SYS_CORE+99             
4959 62 4a			dw .ENDCONST            
495b 07				db 6 + 1 
495c .. 00			db "SYMBOL",0              
4963				endm 
# End of macro CWHEAD
4963			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
4963			; | 
4963			; | | The value is the number reference and the final address is pushed to stack 
4963			 
4963			; | | ``` 
4963			; | | dw sym_table 
4963			; | | dw nmi_vector 
4963			; | | dw cli_autodisplay 
4963			; | | dw cli_data_sp 
4963			; | | dw cli_data_stack 
4963			; | | dw cli_loop_sp 
4963			; | | dw cli_loop_stack 
4963			; | | dw cli_var_array 
4963			; | | dw cursor_col 
4963			; | | dw cursor_ptr 
4963			; | | ; 10 
4963			; | | dw cursor_row 
4963			; | | dw debug_mark 
4963			; | | dw display_fb0 
4963			; | | dw display_fb1 
4963			; | | dw display_fb2 
4963			; | | dw display_fb3 
4963			; | | dw display_fb_active 
4963			; | | dw execscratch 
4963			; | | dw f_cursor_ptr 
4963			; | | dw hardware_word 
4963			; | | ;20 
4963			; | | dw input_at_cursor 
4963			; | | dw input_at_pos 
4963			; | | dw input_cur_flash 
4963			; | | dw input_cur_onoff 
4963			; | | dw input_cursor 
4963			; | | dw input_display_size 
4963			; | | dw input_len 
4963			; | | dw input_ptr 
4963			; | | dw input_size 
4963			; | | dw input_start 
4963			; | | ; 30 
4963			; | | dw input_str 
4963			; | | dw input_under_cursor 
4963			; | | dw os_cli_cmd 
4963			; | | dw os_cur_ptr 
4963			; | | dw os_current_i 
4963			; | | dw os_input 
4963			; | | dw os_last_cmd 
4963			; | | dw os_last_new_uword 
4963			; | | dw debug_vector 
4963			; | | dw os_view_hl 
4963			; | | ;40 
4963			; | | dw os_word_scratch 
4963			; | | dw portbctl 
4963			; | | dw portbdata 
4963			; | | dw spi_cartdev 
4963			; | | dw spi_cartdev2 
4963			; | | dw spi_clktime 
4963			; | | dw spi_device 
4963			; | | dw spi_device_id 
4963			; | | dw spi_portbyte 
4963			; | | dw stackstore 
4963			; | | ; 50 
4963			; | | if STORAGE_SE 
4963			; | | dw storage_actl 
4963			; | | dw storage_adata 
4963			; | | else 
4963			; | | dw 0 
4963			; | | dw 0 
4963			; | | endif 
4963			; | | dw storage_append 
4963			; | | if STORAGE_SE 
4963			; | | dw storage_bctl 
4963			; | | else 
4963			; | | dw 0 
4963			; | | endif 
4963			; | | dw store_bank_active 
4963			; | | dw store_filecache 
4963			; | | dw store_longread 
4963			; | | dw store_openaddr 
4963			; | | dw store_openext 
4963			; | | dw store_openmaxext 
4963			; | | ; 60 
4963			; | | dw store_page 
4963			; | | dw store_readbuf 
4963			; | | dw store_readcont 
4963			; | | dw store_readptr 
4963			; | | dw store_tmpext 
4963			; | | dw store_tmpid 
4963			; | | dw store_tmppageid 
4963			; | | dw malloc 
4963			; | | dw free 
4963			; | | dw cin 
4963			; | | ; 70 
4963			; | | dw cin_wait 
4963			; | | dw forth_push_numhl 
4963			; | | dw forth_push_str 
4963			; | | ``` 
4963			 
4963					if DEBUG_FORTH_WORDS_KEY 
4963						DMARK "SYM" 
4963 f5				push af  
4964 3a 78 49			ld a, (.dmark)  
4967 32 6b ee			ld (debug_mark),a  
496a 3a 79 49			ld a, (.dmark+1)  
496d 32 6c ee			ld (debug_mark+1),a  
4970 3a 7a 49			ld a, (.dmark+2)  
4973 32 6d ee			ld (debug_mark+2),a  
4976 18 03			jr .pastdmark  
4978 ..			.dmark: db "SYM"  
497b f1			.pastdmark: pop af  
497c			endm  
# End of macro DMARK
497c						CALLMONITOR 
497c cd 6f ee			call debug_vector  
497f				endm  
# End of macro CALLMONITOR
497f					endif 
497f			 
497f					FORTH_DSP_VALUEHL 
497f cd a2 1d			call macro_dsp_valuehl 
4982				endm 
# End of macro FORTH_DSP_VALUEHL
4982			 
4982 7d					ld a, l     
4983			 
4983			 
4983					if DEBUG_FORTH_WORDS 
4983						DMARK "SY1" 
4983 f5				push af  
4984 3a 98 49			ld a, (.dmark)  
4987 32 6b ee			ld (debug_mark),a  
498a 3a 99 49			ld a, (.dmark+1)  
498d 32 6c ee			ld (debug_mark+1),a  
4990 3a 9a 49			ld a, (.dmark+2)  
4993 32 6d ee			ld (debug_mark+2),a  
4996 18 03			jr .pastdmark  
4998 ..			.dmark: db "SY1"  
499b f1			.pastdmark: pop af  
499c			endm  
# End of macro DMARK
499c						CALLMONITOR 
499c cd 6f ee			call debug_vector  
499f				endm  
# End of macro CALLMONITOR
499f					endif 
499f					 
499f f5					push af	 
49a0					FORTH_DSP_POP 
49a0 cd 5a 1e			call macro_forth_dsp_pop 
49a3				endm 
# End of macro FORTH_DSP_POP
49a3 f1					pop af 
49a4			 
49a4 cb 27				sla a  
49a6				 
49a6					 
49a6					if DEBUG_FORTH_WORDS 
49a6						DMARK "SY" 
49a6 f5				push af  
49a7 3a bb 49			ld a, (.dmark)  
49aa 32 6b ee			ld (debug_mark),a  
49ad 3a bc 49			ld a, (.dmark+1)  
49b0 32 6c ee			ld (debug_mark+1),a  
49b3 3a bd 49			ld a, (.dmark+2)  
49b6 32 6d ee			ld (debug_mark+2),a  
49b9 18 02			jr .pastdmark  
49bb ..			.dmark: db "SY"  
49bd f1			.pastdmark: pop af  
49be			endm  
# End of macro DMARK
49be						CALLMONITOR 
49be cd 6f ee			call debug_vector  
49c1				endm  
# End of macro CALLMONITOR
49c1					endif 
49c1			 
49c1 21 d0 49				ld hl, sym_table 
49c4 cd e6 0d				call addatohl 
49c7 cd da 1e				call loadwordinhl 
49ca cd ab 1b				call forth_push_numhl 
49cd			 
49cd			 
49cd				       NEXTW 
49cd c3 58 1f			jp macro_next 
49d0				endm 
# End of macro NEXTW
49d0			 
49d0			sym_table: 
49d0			 
49d0			; 0 
49d0 d0 49		dw sym_table 
49d2 72 ee		dw nmi_vector 
49d4 3c ea		dw cli_autodisplay 
49d6 ee e9		dw cli_data_sp 
49d8 28 e8		dw cli_data_stack 
49da f0 e9		dw cli_loop_sp 
49dc 2a e9		dw cli_loop_stack 
49de 28 ea		dw cli_var_array 
49e0 c5 eb		dw cursor_col 
49e2 c3 eb		dw cursor_ptr 
49e4			; 10 
49e4 c4 eb		dw cursor_row 
49e6 6b ee		dw debug_mark 
49e8 b1 ed		dw display_fb0 
49ea 10 ed		dw display_fb1 
49ec ce eb		dw display_fb2 
49ee 6f ec		dw display_fb3 
49f0 cc eb		dw display_fb_active 
49f2 c0 e3		dw execscratch 
49f4 5e ea		dw f_cursor_ptr 
49f6 75 ee		dw hardware_word 
49f8			;20 
49f8 62 ee		dw input_at_cursor 
49fa 64 ee		dw input_at_pos 
49fc 60 ee		dw input_cur_flash 
49fe 5f ee		dw input_cur_onoff 
4a00 55 ee		dw input_cursor 
4a02 65 ee		dw input_display_size 
4a04 5a ee		dw input_len 
4a06 69 ee		dw input_ptr 
4a08 66 ee		dw input_size 
4a0a 67 ee		dw input_start 
4a0c			; 30 
4a0c 13 0e		dw input_str 
4a0e 63 ee		dw input_under_cursor 
4a10 e8 e5		dw os_cli_cmd 
4a12 e4 e5		dw os_cur_ptr 
4a14 e6 e5		dw os_current_i 
4a16 bf e4		dw os_input 
4a18 e7 e6		dw os_last_cmd 
4a1a be e5		dw os_last_new_uword 
4a1c 6f ee		dw debug_vector 
4a1e a3 e2		dw os_view_hl 
4a20			;40 
4a20 c6 e5		dw os_word_scratch 
4a22 c3 00		dw portbctl 
4a24 c1 00		dw portbdata 
4a26 63 ea		dw spi_cartdev 
4a28 62 ea		dw spi_cartdev2 
4a2a 64 ea		dw spi_clktime 
4a2c 60 ea		dw spi_device 
4a2e 5f ea		dw spi_device_id 
4a30 61 ea		dw spi_portbyte 
4a32 a7 eb		dw stackstore 
4a34			; 50 
4a34			if STORAGE_SE 
4a34			dw storage_actl 
4a34			dw storage_adata 
4a34			else 
4a34 00 00		dw 0 
4a36 00 00		dw 0 
4a38			endif 
4a38 68 09		dw storage_append 
4a3a			if STORAGE_SE 
4a3a			dw storage_bctl 
4a3a			else 
4a3a 00 00		dw 0 
4a3c			endif 
4a3c 93 eb		dw store_bank_active 
4a3e 67 ea		dw store_filecache 
4a40 75 ea		dw store_longread 
4a42 6b ea		dw store_openaddr 
4a44 6a ea		dw store_openext 
4a46 69 ea		dw store_openmaxext 
4a48			; 60 
4a48 7a ea		dw store_page 
4a4a 76 ea		dw store_readbuf 
4a4c 6d ea		dw store_readcont 
4a4e 78 ea		dw store_readptr 
4a50 6d ea		dw store_tmpext 
4a52 6e ea		dw store_tmpid 
4a54 65 ea		dw store_tmppageid 
4a56 12 12		dw malloc 
4a58 dc 12		dw free 
4a5a 87 65		dw cin 
4a5c			; 70 
4a5c 7f 65		dw cin_wait 
4a5e ab 1b		dw forth_push_numhl 
4a60 19 1c		dw forth_push_str 
4a62			 
4a62			 
4a62			.ENDCONST: 
4a62			 
4a62			; eof 
4a62			 
4a62			 
# End of file forth_words_const.asm
4a62			 
4a62			if STORAGE_SE 
4a62			   	include "forth_words_storage.asm" 
4a62			endif 
4a62				include "forth_words_device.asm" 
4a62			; Device related words 
4a62			 
4a62			; | ## Device Words 
4a62			 
4a62			;if SOUND_ENABLE 
4a62			;.NOTE: 
4a62			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
4a62			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds  TODO 
4a62			;		if DEBUG_FORTH_WORDS_KEY 
4a62			;			DMARK "NTE" 
4a62			;			CALLMONITOR 
4a62			;		endif 
4a62			; 
4a62			;	 
4a62			; 
4a62			;		NEXTW 
4a62			;.AFTERSOUND: 
4a62			;endif 
4a62			 
4a62			 
4a62			USE_GPIO: equ 0 
4a62			 
4a62			if USE_GPIO 
4a62			.GP1: 
4a62				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
4a62			;  IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result   
4a62					NEXTW 
4a62			.GP2: 
4a62				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
4a62			;  IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2   
4a62			 
4a62					NEXTW 
4a62			 
4a62			.GP3: 
4a62				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
4a62			;  IOBYTE ( u1 --  )    Perform a GPIO write of byte u1   
4a62			 
4a62					NEXTW 
4a62			 
4a62			.GP4: 
4a62				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
4a62			;  IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin   
4a62			 
4a62					NEXTW 
4a62			.SIN: 
4a62			 
4a62			 
4a62			endif 
4a62			 
4a62			 
4a62				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
4a62 33				db WORD_SYS_CORE+31             
4a63 97 4a			dw .SOUT            
4a65 03				db 2 + 1 
4a66 .. 00			db "IN",0              
4a69				endm 
# End of macro CWHEAD
4a69			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
4a69					if DEBUG_FORTH_WORDS_KEY 
4a69						DMARK "IN." 
4a69 f5				push af  
4a6a 3a 7e 4a			ld a, (.dmark)  
4a6d 32 6b ee			ld (debug_mark),a  
4a70 3a 7f 4a			ld a, (.dmark+1)  
4a73 32 6c ee			ld (debug_mark+1),a  
4a76 3a 80 4a			ld a, (.dmark+2)  
4a79 32 6d ee			ld (debug_mark+2),a  
4a7c 18 03			jr .pastdmark  
4a7e ..			.dmark: db "IN."  
4a81 f1			.pastdmark: pop af  
4a82			endm  
# End of macro DMARK
4a82						CALLMONITOR 
4a82 cd 6f ee			call debug_vector  
4a85				endm  
# End of macro CALLMONITOR
4a85					endif 
4a85					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4a85 cd a2 1d			call macro_dsp_valuehl 
4a88				endm 
# End of macro FORTH_DSP_VALUEHL
4a88			 
4a88 e5					push hl 
4a89			 
4a89					; destroy value TOS 
4a89			 
4a89					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4a89 cd 5a 1e			call macro_forth_dsp_pop 
4a8c				endm 
# End of macro FORTH_DSP_POP
4a8c			 
4a8c					; one value on hl get other one back 
4a8c			 
4a8c c1					pop bc 
4a8d			 
4a8d					; do the sub 
4a8d			;		ex de, hl 
4a8d			 
4a8d ed 68				in l,(c) 
4a8f			 
4a8f					; save it 
4a8f			 
4a8f 26 00				ld h,0 
4a91			 
4a91					; TODO push value back onto stack for another op etc 
4a91			 
4a91 cd ab 1b				call forth_push_numhl 
4a94					NEXTW 
4a94 c3 58 1f			jp macro_next 
4a97				endm 
# End of macro NEXTW
4a97			.SOUT: 
4a97				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
4a97 34				db WORD_SYS_CORE+32             
4a98 ea 4a			dw .SPIO            
4a9a 04				db 3 + 1 
4a9b .. 00			db "OUT",0              
4a9f				endm 
# End of macro CWHEAD
4a9f			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
4a9f					if DEBUG_FORTH_WORDS_KEY 
4a9f						DMARK "OUT" 
4a9f f5				push af  
4aa0 3a b4 4a			ld a, (.dmark)  
4aa3 32 6b ee			ld (debug_mark),a  
4aa6 3a b5 4a			ld a, (.dmark+1)  
4aa9 32 6c ee			ld (debug_mark+1),a  
4aac 3a b6 4a			ld a, (.dmark+2)  
4aaf 32 6d ee			ld (debug_mark+2),a  
4ab2 18 03			jr .pastdmark  
4ab4 ..			.dmark: db "OUT"  
4ab7 f1			.pastdmark: pop af  
4ab8			endm  
# End of macro DMARK
4ab8						CALLMONITOR 
4ab8 cd 6f ee			call debug_vector  
4abb				endm  
# End of macro CALLMONITOR
4abb					endif 
4abb			 
4abb					; get port 
4abb			 
4abb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4abb cd a2 1d			call macro_dsp_valuehl 
4abe				endm 
# End of macro FORTH_DSP_VALUEHL
4abe			 
4abe e5					push hl 
4abf			 
4abf					; destroy value TOS 
4abf			 
4abf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4abf cd 5a 1e			call macro_forth_dsp_pop 
4ac2				endm 
# End of macro FORTH_DSP_POP
4ac2			 
4ac2					; get byte to send 
4ac2			 
4ac2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4ac2 cd a2 1d			call macro_dsp_valuehl 
4ac5				endm 
# End of macro FORTH_DSP_VALUEHL
4ac5			 
4ac5			;		push hl 
4ac5			 
4ac5					; destroy value TOS 
4ac5			 
4ac5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ac5 cd 5a 1e			call macro_forth_dsp_pop 
4ac8				endm 
# End of macro FORTH_DSP_POP
4ac8			 
4ac8					; one value on hl get other one back 
4ac8			 
4ac8			;		pop hl 
4ac8			 
4ac8 c1					pop bc 
4ac9			 
4ac9					if DEBUG_FORTH_WORDS 
4ac9						DMARK "OUT" 
4ac9 f5				push af  
4aca 3a de 4a			ld a, (.dmark)  
4acd 32 6b ee			ld (debug_mark),a  
4ad0 3a df 4a			ld a, (.dmark+1)  
4ad3 32 6c ee			ld (debug_mark+1),a  
4ad6 3a e0 4a			ld a, (.dmark+2)  
4ad9 32 6d ee			ld (debug_mark+2),a  
4adc 18 03			jr .pastdmark  
4ade ..			.dmark: db "OUT"  
4ae1 f1			.pastdmark: pop af  
4ae2			endm  
# End of macro DMARK
4ae2						CALLMONITOR 
4ae2 cd 6f ee			call debug_vector  
4ae5				endm  
# End of macro CALLMONITOR
4ae5					endif 
4ae5			 
4ae5 ed 69				out (c), l 
4ae7			 
4ae7					NEXTW 
4ae7 c3 58 1f			jp macro_next 
4aea				endm 
# End of macro NEXTW
4aea			 
4aea			 
4aea			.SPIO: 
4aea			 
4aea			if STORAGE_SE 
4aea				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
4aea			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
4aea			 
4aea					call spi_ce_low 
4aea			    NEXTW 
4aea			 
4aea			.SPICEH: 
4aea				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
4aea			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
4aea			 
4aea					call spi_ce_high 
4aea			    NEXTW 
4aea			 
4aea			 
4aea			.SPIOb: 
4aea			 
4aea				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
4aea			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
4aea			 
4aea					if DEBUG_FORTH_WORDS_KEY 
4aea						DMARK "SPo" 
4aea						CALLMONITOR 
4aea					endif 
4aea					; get port 
4aea			 
4aea			 
4aea					; get byte to send 
4aea			 
4aea					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4aea			 
4aea			;		push hl    ; u1  
4aea			 
4aea					; destroy value TOS 
4aea			 
4aea					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4aea			 
4aea					; one value on hl get other one back 
4aea			 
4aea			;		pop hl   ; u2 - addr 
4aea			 
4aea					; TODO Send SPI byte 
4aea			 
4aea			;		push hl 
4aea			;		call spi_ce_low 
4aea			;		pop hl 
4aea					ld a, l 
4aea					call spi_send_byte 
4aea			;		call spi_ce_high 
4aea			 
4aea					NEXTW 
4aea			 
4aea			.SPII: 
4aea				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
4aea			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
4aea					if DEBUG_FORTH_WORDS_KEY 
4aea						DMARK "SPi" 
4aea						CALLMONITOR 
4aea					endif 
4aea			 
4aea					; TODO Get SPI byte 
4aea			 
4aea					call spi_read_byte 
4aea			 
4aea					if DEBUG_FORTH_WORDS 
4aea						DMARK "Si2" 
4aea						CALLMONITOR 
4aea					endif 
4aea					ld h, 0 
4aea					ld l, a 
4aea					if DEBUG_FORTH_WORDS 
4aea						DMARK "Si3" 
4aea						CALLMONITOR 
4aea					endif 
4aea					call forth_push_numhl 
4aea			 
4aea					NEXTW 
4aea			 
4aea			 
4aea			 
4aea			.SESEL: 
4aea				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
4aea			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
4aea					if DEBUG_FORTH_WORDS_KEY 
4aea						DMARK "BNK" 
4aea						CALLMONITOR 
4aea					endif 
4aea			 
4aea					ld a, 255 
4aea					ld (spi_cartdev), a 
4aea			 
4aea					; get bank 
4aea			 
4aea					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4aea			 
4aea			;		push hl 
4aea			 
4aea					; destroy value TOS 
4aea			 
4aea					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4aea			 
4aea					; one value on hl get other one back 
4aea			 
4aea			;		pop hl 
4aea			 
4aea			 
4aea					ld c, SPI_CE_HIGH 
4aea					ld b, '0'    ; human readable bank number 
4aea			 
4aea					ld a, l 
4aea			 
4aea					if DEBUG_FORTH_WORDS 
4aea						DMARK "BNK" 
4aea						CALLMONITOR 
4aea					endif 
4aea			 
4aea					; active low 
4aea			 
4aea					cp 0 
4aea					jr z, .bset 
4aea					cp 1 
4aea					jr nz, .b2 
4aea					res 0, c 
4aea					ld b, '1'    ; human readable bank number 
4aea			.b2:		cp 2 
4aea					jr nz, .b3 
4aea					res 1, c 
4aea					ld b, '2'    ; human readable bank number 
4aea			.b3:		cp 3 
4aea					jr nz, .b4 
4aea					res 2, c 
4aea					ld b, '3'    ; human readable bank number 
4aea			.b4:		cp 4 
4aea					jr nz, .b5 
4aea					res 3, c 
4aea					ld b, '4'    ; human readable bank number 
4aea			.b5:		cp 5 
4aea					jr nz, .bset 
4aea					res 4, c 
4aea					ld b, '5'    ; human readable bank number 
4aea			 
4aea			.bset: 
4aea					ld a, c 
4aea					ld (spi_device),a 
4aea					ld a, b 
4aea					ld (spi_device_id),a 
4aea					if DEBUG_FORTH_WORDS 
4aea						DMARK "BN2" 
4aea						CALLMONITOR 
4aea					endif 
4aea			 
4aea					; set default SPI clk pulse time as disabled for BANK use 
4aea			 
4aea					ld a, 0 
4aea					ld (spi_clktime), a 
4aea			 
4aea					NEXTW 
4aea			 
4aea			.CARTDEV: 
4aea				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
4aea			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
4aea					if DEBUG_FORTH_WORDS_KEY 
4aea						DMARK "CDV" 
4aea						CALLMONITOR 
4aea					endif 
4aea			 
4aea					; disable se storage bank selection 
4aea			 
4aea					ld a, SPI_CE_HIGH		; ce high 
4aea					ld (spi_device), a 
4aea			 
4aea					; get bank 
4aea			 
4aea					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4aea			 
4aea			;		push hl 
4aea			 
4aea					; destroy value TOS 
4aea			 
4aea					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4aea			 
4aea					; one value on hl get other one back 
4aea			 
4aea			;		pop hl 
4aea			 
4aea					; active low 
4aea			 
4aea					ld c, 255 
4aea			 
4aea					ld a, l 
4aea					if DEBUG_FORTH_WORDS 
4aea						DMARK "CDV" 
4aea						CALLMONITOR 
4aea					endif 
4aea					cp 0 
4aea					jr z, .cset 
4aea					cp 1 
4aea					jr nz, .c2 
4aea					res 0, c 
4aea			.c2:		cp 2 
4aea					jr nz, .c3 
4aea					res 1, c 
4aea			.c3:		cp 3 
4aea					jr nz, .c4 
4aea					res 2, c 
4aea			.c4:		cp 4 
4aea					jr nz, .c5 
4aea					res 3, c 
4aea			.c5:		cp 5 
4aea					jr nz, .c6 
4aea					res 4, c 
4aea			.c6:		cp 6 
4aea					jr nz, .c7 
4aea					res 5, c 
4aea			.c7:		cp 7 
4aea					jr nz, .c8 
4aea					res 6, c 
4aea			.c8:		cp 8 
4aea					jr nz, .cset 
4aea					res 7, c 
4aea			.cset:		ld a, c 
4aea					ld (spi_cartdev),a 
4aea			 
4aea					if DEBUG_FORTH_WORDS 
4aea						DMARK "CD2" 
4aea						CALLMONITOR 
4aea					endif 
4aea			 
4aea					; set default SPI clk pulse time as 10ms for CARTDEV use 
4aea			 
4aea					ld a, $0a 
4aea					ld (spi_clktime), a 
4aea					NEXTW 
4aea			endif 
4aea			 
4aea			.ENDDEVICE: 
4aea			; eof 
4aea			 
# End of file forth_words_device.asm
4aea			 
4aea			; var handler 
4aea			 
4aea			 
4aea			.VARS: 
4aea				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
4aea 77				db WORD_SYS_CORE+99             
4aeb 9b 4b			dw .V0            
4aed 04				db 3 + 1 
4aee .. 00			db "VAR",0              
4af2				endm 
# End of macro CWHEAD
4af2			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
4af2			;| 
4af2			;| The variable name should consist of a single letter. e.g. "a" 
4af2			;! If a full string is passed then only the first char is looked at 
4af2			;| Any other char could exceed bounds checks!  
4af2			 
4af2					if DEBUG_FORTH_WORDS_KEY 
4af2						DMARK "VAR" 
4af2 f5				push af  
4af3 3a 07 4b			ld a, (.dmark)  
4af6 32 6b ee			ld (debug_mark),a  
4af9 3a 08 4b			ld a, (.dmark+1)  
4afc 32 6c ee			ld (debug_mark+1),a  
4aff 3a 09 4b			ld a, (.dmark+2)  
4b02 32 6d ee			ld (debug_mark+2),a  
4b05 18 03			jr .pastdmark  
4b07 ..			.dmark: db "VAR"  
4b0a f1			.pastdmark: pop af  
4b0b			endm  
# End of macro DMARK
4b0b						CALLMONITOR 
4b0b cd 6f ee			call debug_vector  
4b0e				endm  
# End of macro CALLMONITOR
4b0e					endif 
4b0e			 
4b0e					FORTH_DSP_VALUEHL 
4b0e cd a2 1d			call macro_dsp_valuehl 
4b11				endm 
# End of macro FORTH_DSP_VALUEHL
4b11			 
4b11 7e					ld a, (hl)    ; get first char on of the string 
4b12			 
4b12			 
4b12					if DEBUG_FORTH_WORDS 
4b12						DMARK "VR1" 
4b12 f5				push af  
4b13 3a 27 4b			ld a, (.dmark)  
4b16 32 6b ee			ld (debug_mark),a  
4b19 3a 28 4b			ld a, (.dmark+1)  
4b1c 32 6c ee			ld (debug_mark+1),a  
4b1f 3a 29 4b			ld a, (.dmark+2)  
4b22 32 6d ee			ld (debug_mark+2),a  
4b25 18 03			jr .pastdmark  
4b27 ..			.dmark: db "VR1"  
4b2a f1			.pastdmark: pop af  
4b2b			endm  
# End of macro DMARK
4b2b						CALLMONITOR 
4b2b cd 6f ee			call debug_vector  
4b2e				endm  
# End of macro CALLMONITOR
4b2e					endif 
4b2e					 
4b2e f5					push af	 
4b2f					FORTH_DSP_POP 
4b2f cd 5a 1e			call macro_forth_dsp_pop 
4b32				endm 
# End of macro FORTH_DSP_POP
4b32 f1					pop af 
4b33			 
4b33					; convert to upper 
4b33			 
4b33 cd ac 10				call to_upper 
4b36					if DEBUG_FORTH_WORDS 
4b36						DMARK "Vaa" 
4b36 f5				push af  
4b37 3a 4b 4b			ld a, (.dmark)  
4b3a 32 6b ee			ld (debug_mark),a  
4b3d 3a 4c 4b			ld a, (.dmark+1)  
4b40 32 6c ee			ld (debug_mark+1),a  
4b43 3a 4d 4b			ld a, (.dmark+2)  
4b46 32 6d ee			ld (debug_mark+2),a  
4b49 18 03			jr .pastdmark  
4b4b ..			.dmark: db "Vaa"  
4b4e f1			.pastdmark: pop af  
4b4f			endm  
# End of macro DMARK
4b4f						CALLMONITOR 
4b4f cd 6f ee			call debug_vector  
4b52				endm  
# End of macro CALLMONITOR
4b52					endif 
4b52 06 41				ld b, 'A' 
4b54 90					sub b			; set offset 
4b55					if DEBUG_FORTH_WORDS 
4b55						DMARK "Vbb" 
4b55 f5				push af  
4b56 3a 6a 4b			ld a, (.dmark)  
4b59 32 6b ee			ld (debug_mark),a  
4b5c 3a 6b 4b			ld a, (.dmark+1)  
4b5f 32 6c ee			ld (debug_mark+1),a  
4b62 3a 6c 4b			ld a, (.dmark+2)  
4b65 32 6d ee			ld (debug_mark+2),a  
4b68 18 03			jr .pastdmark  
4b6a ..			.dmark: db "Vbb"  
4b6d f1			.pastdmark: pop af  
4b6e			endm  
# End of macro DMARK
4b6e						CALLMONITOR 
4b6e cd 6f ee			call debug_vector  
4b71				endm  
# End of macro CALLMONITOR
4b71					endif 
4b71 cb 27				sla a  
4b73				 
4b73					 
4b73					if DEBUG_FORTH_WORDS 
4b73						DMARK "VR2" 
4b73 f5				push af  
4b74 3a 88 4b			ld a, (.dmark)  
4b77 32 6b ee			ld (debug_mark),a  
4b7a 3a 89 4b			ld a, (.dmark+1)  
4b7d 32 6c ee			ld (debug_mark+1),a  
4b80 3a 8a 4b			ld a, (.dmark+2)  
4b83 32 6d ee			ld (debug_mark+2),a  
4b86 18 03			jr .pastdmark  
4b88 ..			.dmark: db "VR2"  
4b8b f1			.pastdmark: pop af  
4b8c			endm  
# End of macro DMARK
4b8c						CALLMONITOR 
4b8c cd 6f ee			call debug_vector  
4b8f				endm  
# End of macro CALLMONITOR
4b8f					endif 
4b8f			 
4b8f 21 f4 e9				ld hl, cli_var_array2 
4b92 cd e6 0d				call addatohl 
4b95 cd ab 1b				call forth_push_numhl 
4b98			 
4b98			 
4b98				       NEXTW 
4b98 c3 58 1f			jp macro_next 
4b9b				endm 
# End of macro NEXTW
4b9b			.V0: 
4b9b				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
4b9b 78				db WORD_SYS_CORE+100             
4b9c b3 4b			dw .V0Q            
4b9e 04				db 3 + 1 
4b9f .. 00			db "V0!",0              
4ba3				endm 
# End of macro CWHEAD
4ba3			;| V0! ( u1 -- )  Store value to v0  | DONE 
4ba3			 
4ba3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4ba3 cd a2 1d			call macro_dsp_valuehl 
4ba6				endm 
# End of macro FORTH_DSP_VALUEHL
4ba6			 
4ba6 11 28 ea				ld de, cli_var_array 
4ba9			 
4ba9 eb					ex de, hl 
4baa 73					ld (hl), e 
4bab 23					inc hl 
4bac 72					ld (hl), d 
4bad			 
4bad					; destroy value TOS 
4bad			 
4bad					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4bad cd 5a 1e			call macro_forth_dsp_pop 
4bb0				endm 
# End of macro FORTH_DSP_POP
4bb0			 
4bb0				       NEXTW 
4bb0 c3 58 1f			jp macro_next 
4bb3				endm 
# End of macro NEXTW
4bb3			.V0Q: 
4bb3				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
4bb3 79				db WORD_SYS_CORE+101             
4bb4 c4 4b			dw .V1S            
4bb6 04				db 3 + 1 
4bb7 .. 00			db "V0@",0              
4bbb				endm 
# End of macro CWHEAD
4bbb			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
4bbb 2a 28 ea				ld hl, (cli_var_array) 
4bbe cd ab 1b				call forth_push_numhl 
4bc1			 
4bc1				       NEXTW 
4bc1 c3 58 1f			jp macro_next 
4bc4				endm 
# End of macro NEXTW
4bc4			.V1S: 
4bc4				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
4bc4 7a				db WORD_SYS_CORE+102             
4bc5 dc 4b			dw .V1Q            
4bc7 04				db 3 + 1 
4bc8 .. 00			db "V1!",0              
4bcc				endm 
# End of macro CWHEAD
4bcc			;| V1! ( u1 -- )  Store value to v1 | DONE 
4bcc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4bcc cd a2 1d			call macro_dsp_valuehl 
4bcf				endm 
# End of macro FORTH_DSP_VALUEHL
4bcf			 
4bcf 11 2a ea				ld de, cli_var_array+2 
4bd2				 
4bd2 eb					ex de, hl 
4bd3 73					ld (hl), e 
4bd4 23					inc hl 
4bd5 72					ld (hl), d 
4bd6			 
4bd6					; destroy value TOS 
4bd6			 
4bd6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4bd6 cd 5a 1e			call macro_forth_dsp_pop 
4bd9				endm 
# End of macro FORTH_DSP_POP
4bd9				       NEXTW 
4bd9 c3 58 1f			jp macro_next 
4bdc				endm 
# End of macro NEXTW
4bdc			.V1Q: 
4bdc				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
4bdc 7b				db WORD_SYS_CORE+103             
4bdd ed 4b			dw .V2S            
4bdf 04				db 3 + 1 
4be0 .. 00			db "V1@",0              
4be4				endm 
# End of macro CWHEAD
4be4			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
4be4 2a 2a ea				ld hl, (cli_var_array+2) 
4be7 cd ab 1b				call forth_push_numhl 
4bea				       NEXTW 
4bea c3 58 1f			jp macro_next 
4bed				endm 
# End of macro NEXTW
4bed			.V2S: 
4bed				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
4bed 7c				db WORD_SYS_CORE+104             
4bee 05 4c			dw .V2Q            
4bf0 04				db 3 + 1 
4bf1 .. 00			db "V2!",0              
4bf5				endm 
# End of macro CWHEAD
4bf5			;| V2! ( u1 -- )  Store value to v2 | DONE 
4bf5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4bf5 cd a2 1d			call macro_dsp_valuehl 
4bf8				endm 
# End of macro FORTH_DSP_VALUEHL
4bf8			 
4bf8 11 2c ea				ld de, cli_var_array+4 
4bfb				 
4bfb eb					ex de, hl 
4bfc 73					ld (hl), e 
4bfd 23					inc hl 
4bfe 72					ld (hl), d 
4bff			 
4bff					; destroy value TOS 
4bff			 
4bff					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4bff cd 5a 1e			call macro_forth_dsp_pop 
4c02				endm 
# End of macro FORTH_DSP_POP
4c02				       NEXTW 
4c02 c3 58 1f			jp macro_next 
4c05				endm 
# End of macro NEXTW
4c05			.V2Q: 
4c05				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
4c05 7d				db WORD_SYS_CORE+105             
4c06 16 4c			dw .V3S            
4c08 04				db 3 + 1 
4c09 .. 00			db "V2@",0              
4c0d				endm 
# End of macro CWHEAD
4c0d			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
4c0d 2a 2c ea				ld hl, (cli_var_array+4) 
4c10 cd ab 1b				call forth_push_numhl 
4c13				       NEXTW 
4c13 c3 58 1f			jp macro_next 
4c16				endm 
# End of macro NEXTW
4c16			.V3S: 
4c16				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
4c16 7c				db WORD_SYS_CORE+104             
4c17 2e 4c			dw .V3Q            
4c19 04				db 3 + 1 
4c1a .. 00			db "V3!",0              
4c1e				endm 
# End of macro CWHEAD
4c1e			;| V3! ( u1 -- )  Store value to v3 | DONE 
4c1e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4c1e cd a2 1d			call macro_dsp_valuehl 
4c21				endm 
# End of macro FORTH_DSP_VALUEHL
4c21			 
4c21 11 2e ea				ld de, cli_var_array+6 
4c24				 
4c24 eb					ex de, hl 
4c25 73					ld (hl), e 
4c26 23					inc hl 
4c27 72					ld (hl), d 
4c28			 
4c28					; destroy value TOS 
4c28			 
4c28					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c28 cd 5a 1e			call macro_forth_dsp_pop 
4c2b				endm 
# End of macro FORTH_DSP_POP
4c2b				       NEXTW 
4c2b c3 58 1f			jp macro_next 
4c2e				endm 
# End of macro NEXTW
4c2e			.V3Q: 
4c2e				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
4c2e 7d				db WORD_SYS_CORE+105             
4c2f 3f 4c			dw .END            
4c31 04				db 3 + 1 
4c32 .. 00			db "V3@",0              
4c36				endm 
# End of macro CWHEAD
4c36			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
4c36 2a 2e ea				ld hl, (cli_var_array+6) 
4c39 cd ab 1b				call forth_push_numhl 
4c3c				       NEXTW 
4c3c c3 58 1f			jp macro_next 
4c3f				endm 
# End of macro NEXTW
4c3f			 
4c3f			 
4c3f			 
4c3f			 
4c3f			 
4c3f			; end of dict marker 
4c3f			 
4c3f 00			.END:    db WORD_SYS_END 
4c40 00 00			dw 0 
4c42 00				db 0 
4c43			 
4c43			; use to jp here for user dict words to save on macro expansion  
4c43			 
4c43			user_dict_next: 
4c43				NEXTW 
4c43 c3 58 1f			jp macro_next 
4c46				endm 
# End of macro NEXTW
4c46			 
4c46			 
4c46			user_exec: 
4c46				;    ld hl, <word code> 
4c46				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
4c46				;    call forthexec 
4c46				;    jp user_dict_next   (NEXT) 
4c46			        ;    <word code bytes> 
4c46 eb				ex de, hl 
4c47 2a c2 e5			ld hl,(os_tok_ptr) 
4c4a				 
4c4a				FORTH_RSP_NEXT 
4c4a cd 52 1b			call macro_forth_rsp_next 
4c4d				endm 
# End of macro FORTH_RSP_NEXT
4c4d			 
4c4d			if DEBUG_FORTH_UWORD 
4c4d						DMARK "UEX" 
4c4d f5				push af  
4c4e 3a 62 4c			ld a, (.dmark)  
4c51 32 6b ee			ld (debug_mark),a  
4c54 3a 63 4c			ld a, (.dmark+1)  
4c57 32 6c ee			ld (debug_mark+1),a  
4c5a 3a 64 4c			ld a, (.dmark+2)  
4c5d 32 6d ee			ld (debug_mark+2),a  
4c60 18 03			jr .pastdmark  
4c62 ..			.dmark: db "UEX"  
4c65 f1			.pastdmark: pop af  
4c66			endm  
# End of macro DMARK
4c66				CALLMONITOR 
4c66 cd 6f ee			call debug_vector  
4c69				endm  
# End of macro CALLMONITOR
4c69			endif 
4c69			 
4c69			 
4c69			 
4c69 eb				ex de, hl 
4c6a 22 c2 e5			ld (os_tok_ptr), hl 
4c6d				 
4c6d				; Don't use next - Skips the first word in uword. 
4c6d			 
4c6d c3 e9 1f			jp exec1 
4c70			;	NEXT 
4c70			 
4c70			 
4c70			; eof 
# End of file forth_wordsv4.asm
4c70			endif 
4c70			;;;;;;;;;;;;;; Debug code 
4c70			 
4c70			 
4c70			;if DEBUG_FORTH_PARSE 
4c70 .. 00		.nowordfound: db "No match",0 
4c79 .. 00		.compword:	db "Comparing word ",0 
4c89 .. 00		.nextwordat:	db "Next word at",0 
4c96 .. 00		.charmatch:	db "Char match",0 
4ca1			;endif 
4ca1			if DEBUG_FORTH_JP 
4ca1			.foundword:	db "Word match. Exec..",0 
4ca1			endif 
4ca1			;if DEBUG_FORTH_PUSH 
4ca1 .. 00		.enddict:	db "Dict end. Push.",0 
4cb1 .. 00		.push_str:	db "Pushing string",0 
4cc0 .. 00		.push_num:	db "Pushing number",0 
4ccf .. 00		.data_sp:	db "SP:",0 
4cd3 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
4ce5 .. 00		.wordinde:	db "Word in DE (3/0):",0 
4cf7 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
4d09			;endif 
4d09			;if DEBUG_FORTH_MALLOC 
4d09 .. 00		.push_malloc:	db "Malloc address",0 
4d18			;endif 
4d18			 
4d18			 
4d18			 
4d18			; display malloc address and current data stack pointer  
4d18			 
4d18			malloc_error: 
4d18 d5				push de 
4d19 f5				push af 
4d1a e5				push hl 
4d1b cd b9 0b			call clear_display 
4d1e 11 3e 4d			ld de, .mallocerr 
4d21 3e 00			ld a,0 
4d23			;	ld de,os_word_scratch 
4d23 cd cc 0b			call str_at_display 
4d26 3e 11			ld a, display_row_1+17 
4d28 11 6b ee			ld de, debug_mark 
4d2b cd cc 0b			call str_at_display 
4d2e cd dc 0b			call update_display 
4d31				;call break_point_state 
4d31 cd 7f 65			call cin_wait 
4d34			 
4d34			;	ld a, ' ' 
4d34			;	ld (os_view_disable), a 
4d34 cd 41 15			call bp_on 
4d37 e1				pop hl 
4d38 f1				pop af 
4d39 d1				pop de	 
4d3a				CALLMONITOR 
4d3a cd 6f ee			call debug_vector  
4d3d				endm  
# End of macro CALLMONITOR
4d3d c9				ret 
4d3e			 
4d3e .. 00		.mallocerr: 	db "Malloc Error",0 
4d4b			;if DEBUG_FORTH_PUSH 
4d4b			display_data_sp: 
4d4b f5				push af 
4d4c			 
4d4c				; see if disabled 
4d4c			 
4d4c			 
4d4c 3a 6f ee			ld a, (debug_vector) 
4d4f fe c9			cp $C9  ; RET 
4d51				;ld a, (os_view_disable) 
4d51				;cp '*' 
4d51 28 67			jr z, .skipdsp 
4d53			 
4d53 e5				push hl 
4d54 e5				push hl 
4d55 e5			push hl 
4d56 cd b9 0b			call clear_display 
4d59 e1			pop hl 
4d5a 7c				ld a,h 
4d5b 21 c6 e5			ld hl, os_word_scratch 
4d5e cd 40 10			call hexout 
4d61 e1				pop hl 
4d62 7d				ld a,l 
4d63 21 c8 e5			ld hl, os_word_scratch+2 
4d66 cd 40 10			call hexout 
4d69 21 ca e5			ld hl, os_word_scratch+4 
4d6c 3e 00			ld a,0 
4d6e 77				ld (hl),a 
4d6f 11 c6 e5			ld de,os_word_scratch 
4d72 3e 28				ld a, display_row_2 
4d74 cd cc 0b				call str_at_display 
4d77 11 d3 4c			ld de, .wordinhl 
4d7a 3e 00			ld a, display_row_1 
4d7c			 
4d7c cd cc 0b				call str_at_display 
4d7f 11 6b ee			ld de, debug_mark 
4d82 3e 11			ld a, display_row_1+17 
4d84			 
4d84 cd cc 0b				call str_at_display 
4d87			 
4d87				; display current data stack pointer 
4d87 11 cf 4c			ld de,.data_sp 
4d8a 3e 30				ld a, display_row_2 + 8 
4d8c cd cc 0b				call str_at_display 
4d8f			 
4d8f 2a ee e9			ld hl,(cli_data_sp) 
4d92 e5				push hl 
4d93 7c				ld a,h 
4d94 21 c6 e5			ld hl, os_word_scratch 
4d97 cd 40 10			call hexout 
4d9a e1				pop hl 
4d9b 7d				ld a,l 
4d9c 21 c8 e5			ld hl, os_word_scratch+2 
4d9f cd 40 10			call hexout 
4da2 21 ca e5			ld hl, os_word_scratch+4 
4da5 3e 00			ld a,0 
4da7 77				ld (hl),a 
4da8 11 c6 e5			ld de,os_word_scratch 
4dab 3e 33				ld a, display_row_2 + 11 
4dad cd cc 0b				call str_at_display 
4db0			 
4db0			 
4db0 cd dc 0b			call update_display 
4db3 cd f1 0a			call delay1s 
4db6 cd f1 0a			call delay1s 
4db9 e1				pop hl 
4dba			.skipdsp: 
4dba f1				pop af 
4dbb c9				ret 
4dbc			 
4dbc			display_data_malloc: 
4dbc			 
4dbc f5				push af 
4dbd e5				push hl 
4dbe e5				push hl 
4dbf e5			push hl 
4dc0 cd b9 0b			call clear_display 
4dc3 e1			pop hl 
4dc4 7c				ld a,h 
4dc5 21 c6 e5			ld hl, os_word_scratch 
4dc8 cd 40 10			call hexout 
4dcb e1				pop hl 
4dcc 7d				ld a,l 
4dcd 21 c8 e5			ld hl, os_word_scratch+2 
4dd0 cd 40 10			call hexout 
4dd3 21 ca e5			ld hl, os_word_scratch+4 
4dd6 3e 00			ld a,0 
4dd8 77				ld (hl),a 
4dd9 11 c6 e5			ld de,os_word_scratch 
4ddc 3e 28				ld a, display_row_2 
4dde cd cc 0b				call str_at_display 
4de1 11 09 4d			ld de, .push_malloc 
4de4 3e 00			ld a, display_row_1 
4de6			 
4de6 cd cc 0b				call str_at_display 
4de9			 
4de9				; display current data stack pointer 
4de9 11 cf 4c			ld de,.data_sp 
4dec 3e 30				ld a, display_row_2 + 8 
4dee cd cc 0b				call str_at_display 
4df1			 
4df1 2a ee e9			ld hl,(cli_data_sp) 
4df4 e5				push hl 
4df5 7c				ld a,h 
4df6 21 c6 e5			ld hl, os_word_scratch 
4df9 cd 40 10			call hexout 
4dfc e1				pop hl 
4dfd 7d				ld a,l 
4dfe 21 c8 e5			ld hl, os_word_scratch+2 
4e01 cd 40 10			call hexout 
4e04 21 ca e5			ld hl, os_word_scratch+4 
4e07 3e 00			ld a,0 
4e09 77				ld (hl),a 
4e0a 11 c6 e5			ld de,os_word_scratch 
4e0d 3e 33				ld a, display_row_2 + 11 
4e0f cd cc 0b				call str_at_display 
4e12			 
4e12 cd dc 0b			call update_display 
4e15 cd f1 0a			call delay1s 
4e18 cd f1 0a			call delay1s 
4e1b e1				pop hl 
4e1c f1				pop af 
4e1d c9				ret 
4e1e			;endif 
4e1e			 
4e1e			include "forth_autostart.asm" 
4e1e			; list of commands to perform at system start up 
4e1e			 
4e1e			startcmds: 
4e1e			;	dw test11 
4e1e			;	dw test12 
4e1e			;	dw test13 
4e1e			;	dw test14 
4e1e			;	dw test15 
4e1e			;	dw test16 
4e1e			;	dw test17 
4e1e			;	dw ifthtest1 
4e1e			;	dw ifthtest2 
4e1e			;	dw ifthtest3 
4e1e			;	dw mmtest1 
4e1e			;	dw mmtest2 
4e1e			;	dw mmtest3 
4e1e			;	dw mmtest4 
4e1e			;	dw mmtest5 
4e1e			;	dw mmtest6 
4e1e			;	dw iftest1 
4e1e			;	dw iftest2 
4e1e			;	dw iftest3 
4e1e			;	dw looptest1 
4e1e			;	dw looptest2 
4e1e			;	dw test1 
4e1e			;	dw test2 
4e1e			;	dw test3 
4e1e			;	dw test4 
4e1e			;	dw game2r 
4e1e			;	dw game2b1 
4e1e			;	dw game2b2 
4e1e			 
4e1e				; start up words that are actually useful 
4e1e			 
4e1e			;    dw spi1 
4e1e			;    dw spi2 
4e1e			;    dw spi3 
4e1e			;    dw spi4 
4e1e			;    dw spi5 
4e1e			;    dw spi6 
4e1e			;    dw spi7 
4e1e			; 
4e1e			;    dw spi8 
4e1e			;    dw spi9 
4e1e			;    dw spi10 
4e1e			 
4e1e			; file editor 
4e1e			;	dw edit1 
4e1e			;	dw edit2 
4e1e			;	dw edit3 
4e1e			 
4e1e			;	dw longread 
4e1e 48 52			dw clrstack 
4e20 7c 52			dw type 
4e22			;	dw stest 
4e22 a1 52			dw strncpy 
4e24			;	dw list 
4e24 02 53			dw start1 
4e26 12 53			dw start2 
4e28			;	dw start3 
4e28			;	dw start3b 
4e28			;	dw start3c 
4e28			 
4e28				; (unit) testing words 
4e28			 
4e28			;	dw mtesta 
4e28			;	dw mtestb 
4e28			;	dw mtestc 
4e28			;	dw mtestd 
4e28			;	dw mteste 
4e28			 
4e28				; demo/game words 
4e28			 
4e28			;        dw game3w 
4e28			;        dw game3p 
4e28			;        dw game3sc 
4e28			;        dw game3vsi 
4e28			;        dw game3vs 
4e28				 
4e28 6b 5d			dw game2b 
4e2a d9 5d			dw game2bf 
4e2c 23 5e			dw game2mba 
4e2e b9 5e			dw game2mbas 
4e30 fb 5e			dw game2mb 
4e32			 
4e32 2c 5a			dw game1 
4e34 3d 5a			dw game1a 
4e36 9f 5a			dw game1b 
4e38 d4 5a			dw game1c 
4e3a 0a 5b			dw game1d 
4e3c 3b 5b			dw game1s 
4e3e 4f 5b			dw game1t 
4e40 64 5b			dw game1f 
4e42 98 5b			dw game1z 
4e44 dc 5b			dw game1zz 
4e46			 
4e46 46 58			dw test5 
4e48 7e 58			dw test6 
4e4a b6 58			dw test7 
4e4c ca 58			dw test8 
4e4e f6 58			dw test9 
4e50 0c 59			dw test10 
4e52				 
4e52 b3 5c		        dw ssv5 
4e54 97 5c		        dw ssv4 
4e56 7b 5c		        dw ssv3 
4e58 45 5c		        dw ssv2 
4e5a cc 5c		        dw ssv1 
4e5c 14 5d		        dw ssv1cpm 
4e5e			;	dw keyup 
4e5e			;	dw keydown 
4e5e			;	dw keyleft 
4e5e			;	dw keyright 
4e5e			;	dw 	keyf1 
4e5e			;	dw keyf2 
4e5e			;	dw keyf3 
4e5e			;	dw keyf4 
4e5e			;	dw keyf5 
4e5e			;	dw keyf6 
4e5e			;	dw keyf7 
4e5e			;	dw keyf8 
4e5e			;	dw keyf9 
4e5e			;	dw keyf10 
4e5e			;	dw keyf11 
4e5e			;	dw keyf12 
4e5e			;	dw keytab 
4e5e			;	dw keycr 
4e5e			;	dw keyhome 
4e5e			;	dw keyend 
4e5e			;	dw keybs 
4e5e 00 00			db 0, 0	 
4e60			 
4e60			 
4e60			; File Editor 
4e60			 
4e60			; ( id - ) use 'e' to edit the displayed line 
4e60 .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
4e81 .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
4eb6			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
4eb6 .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
4eee			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
4eee			 
4eee			; SPI Net support words 
4eee			 
4eee			; v0! = node to send to 
4eee			; ( str count - ) 
4eee .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
4f47			 
4f47			; spiputc ( char node - ) 
4f47 .. 00		spi2:       db ": spiputc spicel $10 spio spio ptr @ spio spiceh ; ",0 
4f7b			; spiputc ( u node - ) 
4f7b .. 00		spi2b:       db ": spiputb spicel $10 spio spio spio spiceh ; ",0 
4fa9			 
4fa9			; spigetc ( - n ) 
4fa9 .. 00		spi4:       db ": spigetc spicel $11 spio spii spiceh ; ", 0 
4fd2			 
4fd2			; getnode ( - n ) 
4fd2 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
4fff			 
4fff			; ( str node - )  
4fff .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
5065			; store string ( str i - ) 
5065			 
5065			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
5065 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
50ba			 
50ba			; get string ( addr i -  )    TO FIX 
50ba			 
50ba .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
5112			 
5112			 
5112			; NETCHAT (TODO) 
5112			; Program to allow two nodes to chat with eachother 
5112			; 
5112			; v0 - target node 
5112			;  
5112			; accept input at 0,0 
5112			; if input is string send spitype to target node 
5112			; starting at row 2,0 , while spigetchr is not zero ->  
5112			; 
5112			; 
5112			; TODO add paging of get request 
5112			 
5112			; ( node - ) 
5112 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
5131 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
5189 .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
5201			 
5201			 
5201			; Long read of currently open file 
5201 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
5248			 
5248			; clear stack  
5248			 
5248 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
527c			 
527c			; type ( addr count - ) 
527c .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
52a1			 
52a1			; some direct memory words 
52a1			; strncpy ( len t f -- t ) 
52a1			 
52a1 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
5302			 
5302 .. 00		start1:     	db ": bpon $00 bp ;",0 
5312 .. 00		start2:     	db ": bpoff $01 bp ;",0 
5323 .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
539e .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
53fe			 
53fe			 
53fe			; a handy word to list items on the stack 
53fe			 
53fe .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
5468			 
5468			 
5468			; test stack  
5468			; rnd8 stest 
5468			 
5468 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
54df			 
54df			; random malloc and free cycles 
54df			 
54df .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5594			 
5594			; fixed malloc and free cycles 
5594			 
5594 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5637			 
5637			; fixed double string push and drop cycle  
5637			 
5637 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
56ec			 
56ec			; consistent fixed string push and drop cycle  
56ec			 
56ec .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5790			 
5790 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5846			 
5846			;test1:		db ": aa 1 2 3 ;", 0 
5846			;test2:     	db "111 aa 888 999",0 
5846			;test3:     	db ": bb 77 ;",0 
5846			;test4:     	db "$02 $01 do i . loop bb",0 
5846			 
5846 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
587e .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
58b6 .. 00		test7:     	db ": box hline vline ;",0 
58ca .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
58f6 .. 00		test9:     	db ": sw $01 adsp world ;",0 
590c .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
5931 .. 00		test11:     	db "hello create .",0 
5940 .. 00		test12:     	db "hello2 create .",0 
5950			 
5950			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
5950			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
5950			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
5950			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
5950			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
5950			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
5950			 
5950			;iftest1:     	db "$0001 IF cls .",0 
5950			;iftest2:     	db "$0000 IF cls .",0 
5950			;iftest3:     	db "$0002 $0003 - IF cls .",0 
5950			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
5950			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
5950			 
5950			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5950			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5950			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5950			 
5950			 
5950 .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
5974 .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
59a4 .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
59c9 .. 00		sound4: db ": cha $00 ; ",0 
59d6 .. 00		sound5: db ": chb $20 ; ",0 
59e3 .. 00		sound6: db ": chc $40 ; ",0 
59f0 .. 00		sound7: db ": chd $60 ; ",0 
59fd .. 00		sound8: db ": cnote $80 + + note ; ", 0 
5a15 .. 00		sound9: db ": cvol $90 + + note ; ", 0 
5a2c			 
5a2c			 
5a2c			 
5a2c			 
5a2c			; a small guess the number game 
5a2c			 
5a2c .. 00		game1:          db ": gsn rnd8 v1! ;",0 
5a3d .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
5a9f			 
5a9f .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
5ad4 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
5b0a .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
5b3b .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
5b4f .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
5b64 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5b98 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
5bdc			 
5bdc			; Using 'ga' save a high score across multiple runs using external storage 
5bdc			 
5bdc .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
5c45			 
5c45			 
5c45			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
5c45			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
5c45			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
5c45			 
5c45			; simple screen saver to test code memory reuse to destruction 
5c45			 
5c45 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
5c7b .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
5c97 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
5cb3 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
5ccc .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
5d14 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
5d6b			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
5d6b			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
5d6b			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
5d6b			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
5d6b			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
5d6b			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
5d6b			 
5d6b			 
5d6b			 
5d6b			; minesweeper/battleship finding game 
5d6b			; draws a game board of random ship/mine positions 
5d6b			; user enters coords to see if it hits on 
5d6b			; game ends when all are hit 
5d6b			; when hit or miss says how many may be in the area 
5d6b			 
5d6b			; setup the game board and then hide it 
5d6b .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
5dd9 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
5e23			; prompt for where to target 
5e23 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
5eb9 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
5ede			; TODO see if the entered coords hits or misses pushes char hit of miss 
5ede .. 00		game2mbht:      db ": mbckht nop ;",0 
5eed .. 00		game2mbms:      db ": mbcms nop ;",0 
5efb			; TODO how many might be near by 
5efb .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
5f78			 
5f78			; Game 3 
5f78			 
5f78			; Vert scroller ski game - avoid the trees! 
5f78			 
5f78			; v0 score (ie turns) 
5f78			; v1 player pos 
5f78			; v2 left wall 
5f78			; v3 right wall 
5f78			 
5f78			; Draw side walls randomly 
5f78			 
5f78 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
5fa6			 
5fa6			; Draw player 
5fa6 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
5fc4			 
5fc4			; TODO Get Key 
5fc4			 
5fc4			; TODO Move left right 
5fc4			 
5fc4			; scroll and move walls a bit 
5fc4			 
5fc4 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
5ff5			 
5ff5			; main game loop 
5ff5			 
5ff5 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
6021 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
6060			 
6060			; key board defs 
6060			 
6060 .. 00		keyup:       db ": keyup $05 ;",0 
606e .. 00		keydown:       db ": keydown $0a ;",0 
607e .. 00		keyleft:       db ": keyleft $0b ;",0 
608e .. 00		keyright:       db ": keyright $0c ;",0 
609f .. 00		keyf1:       db ": keyf1 $10 ;",0 
60ad .. 00		keyf2:       db ": keyf2 $11 ;",0 
60bb .. 00		keyf3:       db ": keyf3 $12 ;",0 
60c9 .. 00		keyf4:       db ": keyf4 $13 ;",0 
60d7 .. 00		keyf5:       db ": keyf5 $14 ;",0 
60e5 .. 00		keyf6:       db ": keyf6 $15 ;",0 
60f3 .. 00		keyf7:       db ": keyf7 $16 ;",0 
6101 .. 00		keyf8:       db ": keyf8 $17 ;",0 
610f .. 00		keyf9:       db ": keyf9 $18 ;",0 
611d .. 00		keyf10:       db ": keyf10 $19 ;",0 
612c .. 00		keyf11:       db ": keyf11 $1a ;",0 
613b .. 00		keyf12:       db ": keyf12 $1b ;",0 
614a			 
614a .. 00		keytab:       db ": keytab $09 ;",0 
6159 .. 00		keycr:       db ": keycr $0d ;",0 
6167 .. 00		keyhome:       db ": keyhome $0e ;",0 
6177 .. 00		keyend:       db ": keyend $0f ;",0 
6186 .. 00		keybs:       db ": keybs $08 ;",0 
6194			 
6194			   
6194			 
6194			 
6194			 
6194			; eof 
# End of file forth_autostart.asm
6194			 
6194			 
6194			 
6194			; stack over and underflow checks 
6194			 
6194			; init the words to detect the under/overflow 
6194			 
6194			chk_stk_init: 
6194				; a vague random number to check so we dont get any "lucky" hits 
6194 3e 2d			ld a, 45 
6196 6f				ld l, a 
6197 00				nop 
6198 3e 17			ld a, 23 
619a 67				ld h, a 
619b			 
619b 22 9d e2			ld (chk_word), hl     ; the word we need to check against 
619e			 
619e			;	ld (chk_stund), hl	; stack points.... 
619e 22 00 ef			ld (chk_stovr), hl 
61a1 22 ec e9			ld (chk_ret_und), hl 
61a4 22 aa e9			ld (chk_ret_ovr), hl 
61a7 22 28 e9			ld (chk_loop_ovr), hl 
61aa 22 26 e8			ld (chk_data_ovr), hl 
61ad c9				ret 
61ae				 
61ae			check_stacks: 
61ae				; check all stack words 
61ae			 
61ae e5				push hl 
61af d5				push de 
61b0			 
61b0			;	ld de,(chk_word) 
61b0			;	ld hl, (chk_stund)	; stack points.... 
61b0			;	if DEBUG_STK_FAULT 
61b0			;		DMARK "FAa" 
61b0			;		CALLMONITOR 
61b0			;	endif 
61b0			;	call cmp16 
61b0			;	jp z, .chk_faulta 
61b0			; 
61b0			;	ld de, sfaultsu 
61b0			;	jp .chk_fault 
61b0			 
61b0 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
61b3 ed 5b 9d e2		ld de,(chk_word) 
61b7				if DEBUG_STK_FAULT 
61b7					DMARK "FAb" 
61b7					CALLMONITOR 
61b7				endif 
61b7 cd 04 0e			call cmp16 
61ba 28 06			jr z, .chk_fault1 
61bc 11 5d 62			ld de, sfaultso 
61bf c3 11 62			jp .chk_fault 
61c2			.chk_fault1:  
61c2 2a ec e9			ld hl, (chk_ret_und) 
61c5 ed 5b 9d e2		ld de,(chk_word) 
61c9				if DEBUG_STK_FAULT 
61c9					DMARK "FAU" 
61c9					CALLMONITOR 
61c9				endif 
61c9 cd 04 0e			call cmp16 
61cc ca d5 61			jp z, .chk_fault2 
61cf 11 6d 62			ld de, sfaultru 
61d2 c3 11 62			jp .chk_fault 
61d5			.chk_fault2:  
61d5 2a aa e9			ld hl, (chk_ret_ovr) 
61d8 ed 5b 9d e2		ld de,(chk_word) 
61dc				if DEBUG_STK_FAULT 
61dc					DMARK "FA1" 
61dc					CALLMONITOR 
61dc				endif 
61dc cd 04 0e			call cmp16 
61df ca e8 61			jp z, .chk_fault3 
61e2 11 7b 62			ld de, sfaultro 
61e5 c3 11 62			jp .chk_fault 
61e8			.chk_fault3:  
61e8 2a 28 e9			ld hl, (chk_loop_ovr) 
61eb ed 5b 9d e2		ld de,(chk_word) 
61ef				if DEBUG_STK_FAULT 
61ef					DMARK "FA2" 
61ef					CALLMONITOR 
61ef				endif 
61ef cd 04 0e			call cmp16 
61f2 ca fb 61			jp z, .chk_fault4 
61f5 11 95 62			ld de, sfaultlo 
61f8 c3 11 62			jp .chk_fault 
61fb			.chk_fault4:  
61fb 2a 26 e8			ld hl, (chk_data_ovr) 
61fe ed 5b 9d e2		ld de,(chk_word) 
6202				if DEBUG_STK_FAULT 
6202					DMARK "FA3" 
6202					CALLMONITOR 
6202				endif 
6202 cd 04 0e			call cmp16 
6205 ca 0e 62			jp z, .chk_fault5 
6208 11 af 62			ld de, sfaultdo 
620b c3 11 62			jp .chk_fault 
620e			 
620e			 
620e			.chk_fault5:  
620e d1				pop de 
620f e1				pop hl 
6210			 
6210 c9				ret 
6211			 
6211 cd b9 0b		.chk_fault: 	call clear_display 
6214 3e 28				ld a, display_row_2 
6216 cd cc 0b				call str_at_display 
6219 11 3f 62				   ld de, .stackfault 
621c 3e 00				ld a, display_row_1 
621e cd cc 0b				call str_at_display 
6221 11 6b ee				    ld de, debug_mark 
6224 3e 11				ld a, display_row_1+17 
6226 cd cc 0b				call str_at_display 
6229 cd dc 0b				call update_display 
622c			 
622c				; prompt before entering montior for investigating issue 
622c			 
622c 3e 78			ld a, display_row_4 
622e 11 9d 18			ld de, endprog 
6231			 
6231 cd dc 0b			call update_display		 
6234			 
6234 cd 23 1b			call next_page_prompt 
6237			 
6237 d1				pop de 
6238 e1				pop hl 
6239 cd f1 18				call monitor 
623c c3 fa 17				jp warmstart 
623f					;jp 0 
623f					;halt 
623f			 
623f			 
623f			 
623f .. 00		.stackfault: 	db "Stack fault:",0 
624c			 
624c .. 00		sfaultsu: 	db	"Stack under flow",0 
625d .. 00		sfaultso: 	db	"Stack over flow",0 
626d .. 00		sfaultru:	db "RTS underflow",0 
627b .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
6295 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
62af .. 00		sfaultdo:	db "DTS overflow", 0 
62bc			 
62bc			 
62bc			fault_dsp_under: 
62bc 11 ce 62			ld de, .dsp_under 
62bf c3 7e 63			jp .show_fault 
62c2			 
62c2			fault_rsp_under: 
62c2 11 dc 62			ld de, .rsp_under 
62c5 c3 7e 63			jp .show_fault 
62c8			fault_loop_under: 
62c8 11 ea 62			ld de, .loop_under 
62cb c3 7e 63			jp .show_fault 
62ce			 
62ce .. 00		.dsp_under: db "DSP Underflow",0 
62dc .. 00		.rsp_under: db "RSP Underflow",0 
62ea .. 00		.loop_under: db "LOOP Underflow",0 
62f9			 
62f9			 
62f9 d5			type_faultn: 	push de 
62fa e5					push hl 
62fb cd b9 0b				call clear_display 
62fe 11 25 63				   ld de, .typefaultn 
6301 3e 00				ld a, display_row_1 
6303 cd cc 0b				call str_at_display 
6306 11 6b ee				    ld de, debug_mark 
6309 3e 11				ld a, display_row_1+17 
630b cd cc 0b				call str_at_display 
630e cd dc 0b				call update_display 
6311			 
6311				; prompt before entering montior for investigating issue 
6311			 
6311 3e 78			ld a, display_row_4 
6313 11 9d 18			ld de, endprog 
6316			 
6316 cd dc 0b			call update_display		 
6319			 
6319 cd 23 1b			call next_page_prompt 
631c			 
631c e5					push hl 
631d d5					push de 
631e cd f1 18				call monitor 
6321 c3 fa 17				jp warmstart 
6324 76					halt 
6325			 
6325			 
6325 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
633c			 
633c d5			type_faults: 	push de 
633d e5					push hl 
633e cd b9 0b				call clear_display 
6341 11 67 63				   ld de, .typefaults 
6344 3e 00				ld a, display_row_1 
6346 cd cc 0b				call str_at_display 
6349 11 6b ee				    ld de, debug_mark 
634c 3e 11				ld a, display_row_1+17 
634e cd cc 0b				call str_at_display 
6351 cd dc 0b				call update_display 
6354			 
6354				; prompt before entering montior for investigating issue 
6354			 
6354 3e 78			ld a, display_row_4 
6356 11 9d 18			ld de, endprog 
6359			 
6359 cd dc 0b			call update_display		 
635c			 
635c cd 23 1b			call next_page_prompt 
635f			 
635f e1					pop hl 
6360 d1					pop de 
6361 cd f1 18				call monitor 
6364 c3 fa 17				jp warmstart 
6367			 
6367			 
6367 .. 00		.typefaults: db "STR Type Expected TOS!",0 
637e			 
637e			.show_fault: 	 
637e d5					push de 
637f cd b9 0b				call clear_display 
6382 d1					pop de 
6383 3e 00				ld a, display_row_1 
6385 cd cc 0b				call str_at_display 
6388 11 6b ee				    ld de, debug_mark 
638b 3e 11				ld a, display_row_1+17 
638d cd cc 0b				call str_at_display 
6390 cd dc 0b				call update_display 
6393			 
6393				; prompt before entering montior for investigating issue 
6393			 
6393 3e 78			ld a, display_row_4 
6395 11 9d 18			ld de, endprog 
6398			 
6398 cd dc 0b			call update_display		 
639b			 
639b cd 23 1b			call next_page_prompt 
639e			 
639e e1					pop hl 
639f d1					pop de 
63a0 cd f1 18				call monitor 
63a3			; do a dump to cli and not warmstart so we preserve all of the uwords.  
63a3			; TODO Make optional fault restart to cli or warm boot? 
63a3					;jp warmstart 
63a3 c3 44 18				jp cli 
63a6 76					halt 
63a7			 
63a7			; handle the auto run of code from files in storage 
63a7			 
63a7			 
63a7			include "forth_startup.asm" 
63a7			; Which startup method to use? 
63a7			; 
63a7			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
63a7			; followed by loading of a list of scripts in eeprom 
63a7			 
63a7			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
63a7			; from eeprom 
63a7			 
63a7			; Select with define in main stubs 
63a7			 
63a7			if STARTUP_V1 
63a7				include "forth_startupv1.asm" 
63a7			; Startup script loading version 1 
63a7			 
63a7			; If SE storage is available first stage is to use the selected file 
63a7			; then go through the eeprom list 
63a7			 
63a7 .. 00		sprompt1: db "Startup load...",0 
63b7 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
63cd			 
63cd			 
63cd			 
63cd			 
63cd			forth_startup: 
63cd 21 1e 4e			ld hl, startcmds 
63d0 3e 00			ld a, 0 
63d2 32 e7 e6			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
63d5			 
63d5 e5			.start1:	push hl 
63d6 cd b9 0b			call clear_display 
63d9 11 a7 63			ld de, sprompt1 
63dc 3e 00		        ld a, display_row_1 
63de cd cc 0b			call str_at_display 
63e1 11 b7 63			ld de, sprompt2 
63e4 3e 28		        ld a, display_row_2 
63e6 cd cc 0b			call str_at_display 
63e9 e1				pop hl 
63ea e5				push hl 
63eb 5e				ld e,(hl) 
63ec 23				inc hl 
63ed 56				ld d,(hl) 
63ee 3e 50		        ld a, display_row_3 
63f0 cd cc 0b			call str_at_display 
63f3 cd dc 0b			call update_display 
63f6			 
63f6			 
63f6 3a e7 e6			ld a, (os_last_cmd) 
63f9 fe 00			cp 0 
63fb 28 05			jr z, .startprompt 
63fd cd e5 0a			call delay250ms 
6400 18 24			jr .startdo 
6402				 
6402				 
6402			 
6402			.startprompt: 
6402			 
6402 3e 9f			ld a,display_row_4 + display_cols - 1 
6404 11 21 1b		        ld de, endprg 
6407 cd cc 0b			call str_at_display 
640a cd dc 0b			call update_display 
640d cd f1 0a			call delay1s 
6410 cd 7f 65			call cin_wait 
6413						 
6413 fe 2a			cp '*' 
6415 28 5e			jr z, .startupend1 
6417 fe 23			cp '#' 
6419 20 07			jr nz, .startno 
641b 3e 01			ld a, 1 
641d 32 e7 e6			ld (os_last_cmd),a 
6420 18 04			jr .startdo 
6422 fe 31		.startno:	cp '1' 
6424 28 3a			jr z,.startnxt  
6426			 
6426				; exec startup line 
6426			.startdo:	 
6426 e1				pop hl 
6427 e5				push hl 
6428				 
6428 5e				ld e,(hl) 
6429 23				inc hl 
642a 56				ld d,(hl) 
642b eb				ex de,hl 
642c			 
642c e5				push hl 
642d			 
642d 3e 00			ld a, 0 
642f				;ld a, FORTH_END_BUFFER 
642f cd a8 11			call strlent 
6432 23				inc hl   ; include zero term to copy 
6433 06 00			ld b,0 
6435 4d				ld c,l 
6436 e1				pop hl 
6437 11 c1 e2			ld de, scratch 
643a ed b0			ldir 
643c			 
643c			 
643c 21 c1 e2			ld hl, scratch 
643f cd a6 1f			call forthparse 
6442 cd e6 1f			call forthexec 
6445 cd f8 1e			call forthexec_cleanup 
6448			 
6448 3e 78			ld a, display_row_4 
644a 11 9d 18			ld de, endprog 
644d			 
644d cd dc 0b			call update_display		 
6450			 
6450 3a e7 e6			ld a, (os_last_cmd) 
6453 fe 00			cp 0 
6455 20 09			jr nz, .startnxt 
6457 cd 23 1b			call next_page_prompt 
645a cd b9 0b		        call clear_display 
645d cd dc 0b			call update_display		 
6460			 
6460				; move onto next startup line? 
6460			.startnxt: 
6460			 
6460 cd e5 0a			call delay250ms 
6463 e1				pop hl 
6464			 
6464 23				inc hl 
6465 23				inc hl 
6466			 
6466 e5				push hl 
6467 5e				ld e, (hl) 
6468 23				inc hl 
6469 56				ld d, (hl) 
646a e1				pop hl 
646b				; TODO replace 0 test 
646b			 
646b eb				ex de, hl 
646c cd 0f 0e			call ishlzero 
646f			;	ld a,e 
646f			;	add d 
646f			;	cp 0    ; any left to do? 
646f eb				ex de, hl 
6470 c2 d5 63			jp nz, .start1 
6473 18 01			jr .startupend 
6475			 
6475 e1			.startupend1: pop hl 
6476			.startupend: 
6476			 
6476 cd b9 0b			call clear_display 
6479 cd dc 0b			call update_display 
647c c9				ret 
647d			if STORAGE_SE 
647d			 
647d			sprompt3: db "Loading from start-up file?:",0 
647d			sprompt4: db "(Y=Any key/N=No)",0 
647d			 
647d			 
647d			forth_autoload: 
647d			 
647d				; load block 0 of store 1 
647d				 
647d				ld a, $fe      ; bit 0 clear 
647d				ld (spi_device), a 
647d			 
647d				call storage_get_block_0 
647d			 
647d				ld a, (store_page+STORE_0_AUTOFILE) 
647d			 
647d				cp 0 
647d				ret z     ; auto start not enabled 
647d			 
647d				call clear_display 
647d			 
647d				; set bank 
647d			 
647d					ld a, (store_page+STORE_0_BANKRUN) 
647d					ld (spi_device), a 
647d			 
647d				; get file id to load from and get the file name to display 
647d			 
647d					ld a, (store_page+STORE_0_FILERUN) 
647d			 
647d					ld l, 0 
647d					ld h, a 
647d					ld de, store_page 
647d			 
647d					if DEBUG_FORTH_WORDS 
647d						DMARK "ASp" 
647d						CALLMONITOR 
647d					endif 
647d					call storage_read 
647d			 
647d					if DEBUG_FORTH_WORDS 
647d						DMARK "ASr" 
647d						CALLMONITOR 
647d					endif 
647d			 
647d					call ishlzero 
647d					ret z             ; file not found 
647d			 
647d					ld a, display_row_2 + 10 
647d					ld de, store_page+3 
647d					call str_at_display 
647d				 
647d			; 
647d			 
647d				ld a, display_row_1+5 
647d				ld de, sprompt3 
647d				call str_at_display 
647d				ld a, display_row_3+15 
647d				ld de, sprompt4 
647d				call str_at_display 
647d			 
647d				call update_display 
647d			 
647d				call cin_wait 
647d				cp 'n' 
647d				ret z 
647d				cp 'N' 
647d				ret z 
647d			 
647d				call delay1s 
647d			 
647d				ld a, (store_page+2) 
647d				ld (store_openmaxext), a    ; save count of ext 
647d				ld a, 1  
647d				ld (store_openext), a    ; save count of ext 
647d			 
647d			.autof:  
647d				ld l , a 
647d				 
647d				ld a, (store_page) 
647d				ld h, a	 
647d				ld de, store_page 
647d					if DEBUG_FORTH_WORDS 
647d						DMARK "ASl" 
647d						CALLMONITOR 
647d					endif 
647d					call storage_read 
647d				call ishlzero 
647d				ret z 
647d			;	jr z, .autoend 
647d			 
647d					if DEBUG_FORTH_WORDS 
647d						DMARK "ASc" 
647d						CALLMONITOR 
647d					endif 
647d				ld de, store_page+2 
647d				ld a, display_row_4 
647d				call str_at_display 
647d			 
647d				call update_display 
647d				call delay250ms 
647d			 
647d			 
647d			 
647d				ld hl, store_page+2 
647d				call forthparse 
647d				call forthexec 
647d				call forthexec_cleanup 
647d			 
647d				 
647d				ld a, (store_openext) 
647d				inc a 
647d				ld (store_openext), a    ; save count of ext 
647d			 
647d				jr .autof 
647d			;.autofdone: 
647d			; 
647d			;		if DEBUG_FORTH_WORDS 
647d			;			DMARK "ASx" 
647d			;			CALLMONITOR 
647d			;		endif 
647d			;;	call clear_display 
647d			;	ret 
647d			 
647d			 
647d			 
647d			endif 
# End of file forth_startupv1.asm
647d			endif 
647d			if STARTUP_V2 
647d				include "forth_startupv2.asm" 
647d			endif 
647d			 
# End of file forth_startup.asm
647d			 
647d			; eof 
# End of file forth_kernel.asm
647d			;include "nascombasic.asm" 
647d			 
647d			 
647d			; find out where the code ends if loaded into RAM (for SC114) 
647d			;endofcode:  
647d			;	nop 
647d			 
647d			 
647d			; jump to nmi vector 
647d			 
647d			init_nmi: 
647d 3e c9			ld a, $c9   ; RET 
647f 32 72 ee			ld (nmi_vector), a 
6482 c9				ret 
6483			nmi: 
6483 e5				push hl 
6484 d5				push de 
6485 c5				push bc 
6486 f5				push af 
6487 cd 72 ee			call nmi_vector 
648a f5				push af 
648b c5				push bc 
648c d5				push de 
648d e5				push hl 
648e ed 4d			reti 
6490			 
6490			 
6490			; eof 
6490			 
# End of file main.asm
6490			;include "firmware_lcd_4x40.asm" 
6490			;;include "firmware_lcd_4x20.asm" 
6490			include "firmware_cpm_display.asm" 
6490			 
6490			; Serial display interface for SC114 
6490			 
6490			 
6490			display_row_1: equ 0 
6490			display_row_2: equ display_row_1+display_cols 
6490			display_row_3: equ display_row_2 + display_cols 
6490			display_row_4: equ display_row_3 + display_cols 
6490			 
6490			kLCDWidth:  EQU display_cols             ;Width in characters 
6490			kLCD_Line1: EQU 0x00  
6490			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
6490			; E1 
6490			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
6490			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
6490			 
6490			lcd_init: 
6490				; no init as handled by the SCM bios 
6490 c9				ret 
6491			 
6491			 
6491			; low level functions for direct screen writes 
6491			 
6491			; output char at pos? 
6491			fLCD_Str: 
6491			        ;out (SC114_SIO_1_OUT),a 
6491 c5				push bc 
6492 d5				push de 
6493 5f				ld e, a 
6494			; TODO Replace with CP/M BIOS call 
6494 0e 02			ld c, $02 
6496 cd 05 00			call 5 
6499 d1				pop de 
649a c1				pop bc 
649b c9				ret 
649c			 
649c			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
649c			fLCD_Pos: 
649c				; use ASCII escape to position 
649c			        ;out (SC114_SIO_1_OUT),a 
649c c5				push bc 
649d d5				push de 
649e 5f				ld e, a 
649f 0e 02			ld c, $02 
64a1			; TODO Replace with CP/M BIOS call 
64a1 cd 05 00			call 5 
64a4 d1				pop de 
64a5 c1				pop bc 
64a6			 
64a6 c9				ret 
64a7			 
64a7			; output char at pos 
64a7			fLCD_Data: 
64a7			      ;  out (SC114_SIO_1_OUT),a 
64a7 c5				push bc 
64a8 d5				push de 
64a9 0e 02			ld c, $02 
64ab 5f				ld e, a 
64ac			; TODO Replace with CP/M BIOS call 
64ac cd 05 00			call 5 
64af d1				pop de 
64b0 c1				pop bc 
64b1			 
64b1 c9				ret 
64b2			 
64b2			; ascii cls  
64b2			 
64b2 1b 5b 48 24	.cls:   db 27, '[', 'H', "$" 
64b6			 
64b6 0d 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a ..	.clscpm: db 13, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,10,10,10,10,10,"$" 
64cd			;.clscpm: db 3, $3c,"$" 
64cd			 
64cd			; write the frame buffer given in hl to hardware  
64cd			write_display: 
64cd			 
64cd			API: equ 0 
64cd			 
64cd			if API 
64cd				push bc 
64cd				ld b, 4 
64cd			 
64cd			        ld (display_write_tmp), hl 	  
64cd			 
64cd				; clear and home cursor 
64cd			 
64cd				ld c, 9 
64cd				ld de, .cls 
64cd			; TODO Replace with CP/M BIOS call 
64cd				call 5 
64cd			 
64cd			 
64cd			.writeln: 
64cd			 
64cd				ld de, (display_write_tmp) 
64cd				ld c, 6 
64cd			; TODO Replace with CP/M BIOS call 
64cd				rst $30 
64cd				ld c, 7 
64cd				rst $30 
64cd			 
64cd				ld hl, (display_write_tmp) 
64cd				ld de, display_cols 
64cd				add hl,de 
64cd				ld (display_write_tmp),hl 
64cd			 
64cd				djnz  .writeln 
64cd			 
64cd				pop bc 
64cd			 
64cd			 
64cd				ret 
64cd			endif 
64cd e5				push hl 
64ce c5				push bc 
64cf d5				push de 
64d0			 
64d0			;	ld c, 2 
64d0			;	;ld de, .cls 
64d0			;	ld a, 27 
64d0			;	rst $30 
64d0			;	ld c, 2 
64d0			;	;ld de, .cls 
64d0			;	ld a, '[' 
64d0			;	rst $30 
64d0			; 
64d0			;	ld c, 2 
64d0			;	;ld de, .cls 
64d0			;	ld a, 'H' 
64d0			;	rst $30 
64d0			; 
64d0			 
64d0			 
64d0			; lots of CR/LF 
64d0			;	ld c, 9 
64d0			;	ld de, .clscpm 
64d0			;	call 5 
64d0			 
64d0			; xterm cls 
64d0 0e 02			ld c, 2 
64d2 1e 1b			ld e, 27 
64d4 cd 05 00			call 5 
64d7			; cls causes too much flicker 
64d7			;	ld c, 2 
64d7			;	ld e, 'c' 
64d7			;	call 5 
64d7			 
64d7			; use xterm home instead 
64d7 0e 02			ld c, 2 
64d9 1e 5b			ld e, '[' 
64db cd 05 00			call 5 
64de 0e 02			ld c, 2 
64e0 1e 48			ld e, 'H' 
64e2 cd 05 00			call 5 
64e5			LLL: equ 0 
64e5			 
64e5			if LLL 
64e5			 
64e5				ld c, 2 
64e5				;ld de, .cls 
64e5				ld e, 27 
64e5			; TODO Replace with CP/M BIOS call 
64e5				call 5 
64e5			 
64e5			 
64e5				ld c, 2 
64e5				;ld de, .cls 
64e5				ld e, '[' 
64e5			; TODO Replace with CP/M BIOS call 
64e5				call 5 
64e5				ld c, 2 
64e5				;ld de, .cls 
64e5				ld e, '2' 
64e5			; TODO Replace with CP/M BIOS call 
64e5				call 5 
64e5				ld c, 2 
64e5				;ld de, .cls 
64e5				ld e, 'J' 
64e5			; TODO Replace with CP/M BIOS call 
64e5				call 5 
64e5			 
64e5			endif 
64e5			 
64e5 d1				pop de 
64e6 c1				pop bc 
64e7 e1				pop hl 
64e8			 
64e8			 
64e8 22 c9 eb		        ld (display_write_tmp), hl 	  
64eb 3e 00			ld a, kLCD_Line1 
64ed			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
64ed 06 28			ld b, display_cols 
64ef ed 5b c9 eb		ld de, (display_write_tmp) 
64f3 cd 76 65			call write_len_string 
64f6				 
64f6			 
64f6 e5			push hl 
64f7 d5			push de 
64f8 c5			push bc 
64f9 0e 02			ld c, 2 
64fb 1e 0a			ld e, 10 
64fd cd 05 00			call 5 
6500 0e 02			ld c, 2 
6502 1e 0d			ld e, 13 
6504 cd 05 00			call 5 
6507			; TODO Replace with CP/M BIOS call 
6507				;rst $30 
6507 c1			pop bc 
6508 d1			pop de 
6509 e1			pop hl 
650a			 
650a				 
650a 2a c9 eb			ld hl, (display_write_tmp) 
650d 11 28 00			ld de, display_cols 
6510 19				add hl,de 
6511 22 c9 eb			ld (display_write_tmp),hl 
6514			 
6514				 
6514 3e 28			ld a, kLCD_Line2 
6516			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
6516 06 28			ld b, display_cols 
6518 ed 5b c9 eb		ld de, (display_write_tmp) 
651c cd 76 65			call write_len_string 
651f				 
651f 2a c9 eb			ld hl, (display_write_tmp) 
6522 11 28 00			ld de, display_cols 
6525 19				add hl,de 
6526 22 c9 eb			ld (display_write_tmp),hl 
6529			 
6529 e5			push hl 
652a d5			push de 
652b c5			push bc 
652c 0e 07			ld c, 7 
652e			; TODO Replace with CP/M BIOS call 
652e				;rst $30 
652e 0e 02			ld c, 2 
6530 1e 0a			ld e, 10 
6532 cd 05 00			call 5 
6535 0e 02			ld c, 2 
6537 1e 0d			ld e, 13 
6539 cd 05 00			call 5 
653c c1			pop bc 
653d d1			pop de 
653e e1			pop hl 
653f			 
653f				 
653f 3e 50			ld a, kLCD_Line3 
6541			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
6541 06 28			ld b, display_cols 
6543 ed 5b c9 eb		ld de, (display_write_tmp) 
6547 cd 76 65			call write_len_string 
654a				 
654a 2a c9 eb			ld hl, (display_write_tmp) 
654d 11 28 00			ld de, display_cols 
6550 19				add hl,de 
6551 22 c9 eb			ld (display_write_tmp),hl 
6554			 
6554 e5			push hl 
6555 d5			push de 
6556 c5			push bc 
6557 0e 07			ld c, 7 
6559			; TODO Replace with CP/M BIOS call 
6559				;rst $30 
6559 0e 02			ld c, 2 
655b 1e 0a			ld e, 10 
655d cd 05 00			call 5 
6560 0e 02			ld c, 2 
6562 1e 0d			ld e, 13 
6564 cd 05 00			call 5 
6567 c1			pop bc 
6568 d1			pop de 
6569 e1			pop hl 
656a			 
656a				 
656a 3e 78			ld a, kLCD_Line4 
656c			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
656c 06 28			ld b, display_cols 
656e ed 5b c9 eb		ld de, (display_write_tmp) 
6572 cd 76 65			call write_len_string 
6575 c9					ret 
6576			 
6576			 
6576				; write out a fixed length string given in b from de 
6576			 
6576 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
6577 cd a7 64		            CALL fLCD_Data      ;Write character to display 
657a 13				inc de 
657b 10 f9			djnz write_len_string 
657d c9				ret 
657e			 
657e			 
657e			; eof 
# End of file firmware_cpm_display.asm
657e			;include "firmware_key_5x10.asm" 
657e			;;include "firmware_key_4x10.asm" 
657e			include "firmware_key_cpm.asm" 
657e			; Serial keyboard interface for SC114 
657e			 
657e			 
657e			key_init: 
657e				; no init as handled by the SCM bios 
657e c9				ret 
657f			 
657f			 
657f			cin_wait: 
657f			;	ld a, 0 
657f			;	ret 
657f			 
657f				;in a,(SC114_SIO_1_IN) 
657f			        ; Use SCM API to get from whatever console device we are using 
657f			 
657f			; TODO Replace with CP/M BIOS call 
657f c5				push bc 
6580 0e 01			ld c, $01 
6582 cd 05 00			call 5 
6585 c1				pop bc 
6586 c9				ret 
6587			 
6587			cin: 
6587			 
6587			 
6587 c5				push bc 
6588			 
6588				; any key waiting to process? 
6588			; TODO Replace with CP/M BIOS call 
6588 0e 06			ld c, $06 
658a cd 05 00			call 5 
658d 28 0d			jr z, .cin_skip 
658f			 
658f				; yep, get it 
658f			 
658f 0e 01			ld c, $01 
6591			; TODO Replace with CP/M BIOS call 
6591 cd 05 00			call 5 
6594			 
6594 fe 7f			cp $7f     ; back space 
6596 20 02			jr nz, .skipbs 
6598 3e 08			ld a, KEY_BS 
659a			.skipbs: 
659a			 
659a c1				pop bc 
659b c9				ret 
659c			.cin_skip: 
659c 3e 00			ld a, 0 
659e c1				pop bc 
659f c9				ret 
65a0			 
65a0			 
65a0			 
65a0			 
# End of file firmware_key_cpm.asm
65a0			endofcode:  
65a0			baseram:  
65a0 00				nop 
65a1			 
65a1			heap_start: equ baseram+15  ; Starting address of heap 
65a1			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
65a1			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
65a1			;VDU:  EQU     endofcode           ; BASIC Work space 
65a1			; eof 
65a1			 
# End of file os_mega_cpm.asm
65a1
