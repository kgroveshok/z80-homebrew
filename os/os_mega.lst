# File os_mega.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			tos:	equ 0fffdh 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			SOUND_ENABLE: equ 1 
0000			 
0000			; Number of bytes available in heap   TODO make all of user ram 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 4e 1b			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			 
0003 .. 00		buildtime: db   "Build: 00/00/00 00:00:00",0 
001c			 
001c			 
001c			;        nop  
001c			;        nop 
001c			;;	org 05h		; null out bdos call 
001c			; 
001c			;        nop  
001c			;        nop  
001c			;        nop 
001c			;;	org 08h 
001c			;;; 
001c			;;	jp cin		; rst 8 - char in 
001c			;;; 
001c			; 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;	org 010h 
001c			;; 
001c			;	jp cout		; rest 010h  - char out 
001c			;; 
001c			;	org 01bh   
001c			; 
001c			;	;jp  		; rst 01bh   - write string to display 
001c			;	jp str_at_display 
001c			; 
001c			; 
001c			;	org 020h 
001c			; 
001c			;	; jp		 ; rst 020h - read char at screen location 
001c			; 
001c			;	org 028h 
001c			 
001c				; jp		 ; rst 028h  - storage i/o 
001c			 
001c			; 	org 030h 
001c			;	jp break_point_state 
001c			  
001c			; $30  
001c			; org 038h 
001c			; $38 
001c			 
001c			; TODO any more important entry points to add to jump table for easier coding use? 
001c			 
001c			 
001c			include "firmware.asm" 
001c			  
001c			; main constants (used here and in firmware)  
001c			  
001c			; TODO have page 0 of storage as bios  
001c			  
001c			Device_A: equ 0h  
001c			Device_B: equ 040h          ; Sound  
001c			  
001c			if BASE_KEV  
001c			Device_C: equ 080h          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			if BASE_SC114  
001c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			if BASE_CPM  
001c			; TODO fixup for CPM  
001c			Device_C: equ 080h          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			Device_D: equ 0c0h             ; Keyboard and LCD  
001c			  
001c			; Odd specific debug points for testing hardware dev  
001c			  
001c			DEBUG_SOUND: equ 1  
001c			DEBUG_STK_FAULT: equ 0  
001c			DEBUG_INPUT: equ 0     ; Debug input entry code  
001c			DEBUG_KEYCINWAIT: equ 0  
001c			DEBUG_KEYCIN: equ 0  
001c			DEBUG_KEY: equ 0  
001c			DEBUG_KEY_MATRIX: equ 0  
001c			DEBUG_STORECF: equ 0  
001c			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
001c			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
001c			DEBUG_SPI: equ 0    ; low level spi tests  
001c			  
001c			; Enable many break points  
001c			  
001c			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
001c			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
001c			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
001c			DEBUG_FORTH_JP: equ 0    ; 4  
001c			DEBUG_FORTH_MALLOC: equ 0  
001c			DEBUG_FORTH_MALLOC_INT: equ 0  
001c			DEBUG_FORTH_DOT: equ 0  
001c			DEBUG_FORTH_DOT_WAIT: equ 0  
001c			DEBUG_FORTH_MATHS: equ 0  
001c			DEBUG_FORTH_TOK: equ 0    ; 4  
001c			DEBUG_FORTH_PARSE: equ 0    ; 3  
001c			DEBUG_FORTH: equ 0  ;2  
001c			DEBUG_FORTH_WORDS: equ 1   ; 1  
001c			DEBUG_FORTH_PUSH: equ 1   ; 1  
001c			DEBUG_FORTH_UWORD: equ 1   ; 1  
001c			  
001c			; Enable key point breakpoints  
001c			  
001c			DEBUG_FORTH_DOT_KEY: equ 0  
001c			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
001c			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
001c			  
001c			; Debug stack imbalances  
001c			  
001c			ON: equ 1  
001c			OFF: equ 0  
001c			  
001c			DEBUG_STACK_IMB: equ 0  
001c			STACK_IMB_STORE: equ 20  
001c			  
001c			; House keeping and protections  
001c			  
001c			DEBUG_FORTH_STACK_GUARD: equ 1  
001c			DEBUG_FORTH_MALLOC_GUARD: equ 1  
001c			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
001c			FORTH_ENABLE_FREE: equ 0  
001c			FORTH_ENABLE_MALLOCFREE: equ 1  
001c			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
001c			FORTH_ENABLE_FLOATMATH: equ 0  
001c			  
001c			  
001c			CALLMONITOR: macro  
001c				call break_point_state  
001c				endm  
001c			  
001c			MALLOC_1: equ 1        ; from dk88   
001c			MALLOC_2: equ 0           ; broke  
001c			MALLOC_3: equ 0           ; really broke  
001c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
001c			  
001c			if BASE_KEV   
001c			stacksize: equ 256  
001c			  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 512  
001c			endif  
001c			if BASE_SC114  
001c			;tos:	equ 0f000h  
001c			stacksize: equ 256  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 256  
001c			endif  
001c			  
001c			if BASE_CPM  
001c			;tos:	equ 0f000h  
001c			stacksize: equ 256  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 256  
001c			endif  
001c			  
001c			;if STORAGE_SE == 0  
001c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
001c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
001c			;endif  
001c			  
001c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
001c			  
001c			STORE_0_AUTORUN: equ $20  
001c			  
001c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
001c			  
001c			STORE_0_AUTOFILE: equ $21  
001c			STORE_0_BANKRUN: equ $23  
001c			STORE_0_FILERUN: equ $24  
001c			  
001c			; Block 0 offsets for settings  
001c			  
001c			; if set then skip prompt for start up and accept all  
001c			  
001c			STORE_0_QUICKSTART: equ $25  
001c			  
001c			; Blocks where directory table is held  
001c			  
001c			; Reducing the number of entries increases the max file size  
001c			  
001c			;STORE_DIR_START: equ 1  
001c			;STORE_DIR_END: equ 33  
001c			  
001c			; Blocks from where file data is stored  
001c			  
001c			;STORE_DATA_START: equ STORE_DIR_END + 1  
001c			  
001c			; Block indicators (<32 are data files)  
001c			  
001c			;STORE_BLOCK_CFG: equ $8f       ; config block  
001c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
001c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
001c			;STORE_BLOCK_FREE: equ $85       ; data block free  
001c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
001c			  
001c			  
001c			  
001c			; Directory entry flags  
001c			  
001c			;STORE_DIR_FREE: equ 0  
001c			;STORE_DIR_FILE:  equ 1  
001c			  
001c			; Structure offsets to directory entries  
001c			;STORE_DE_FLAG: equ 0  
001c			;STORE_DE_MAXEXT: equ 1  
001c			;STORE_DE_FILENAME: equ 2  
001c			  
001c			; Structure offsets to block 0  
001c			  
001c			;STORE_BK0_ISFOR: equ 1  
001c			;STORE_BK0_LABEL: equ 3  
001c			  
001c			; memory allocation   
001c			  
001c			chk_stund: equ tos+2           ; underflow check word  
001c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
001c			  
001c			; keyscan table needs rows x cols buffer  
001c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
001c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
001c			  
001c			keyscan_table_row1: equ chk_stovr -key_cols-1  
001c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
001c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
001c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
001c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
001c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
001c			keyscan_scancol: equ keyscan_table-key_cols  
001c			;keyscan_table_len: equ key_rows*key_cols  
001c			;keybufptr: equ keyscan_table - 2  
001c			;keysymbol: equ keybufptr - 1  
001c			key_held: equ keyscan_scancol-1	; currently held  
001c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
001c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
001c			key_fa: equ key_repeat_ct -1 ;  
001c			key_fb: equ key_fa -1 ;  
001c			key_fc: equ key_fb -1 ;  
001c			key_fd: equ key_fc -1 ;  
001c			key_face_held: equ key_fd - 1   
001c			  
001c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
001c			  
001c			hardware_config: equ key_face_held - 10  
001c			  
001c			; hardware config switches  
001c			; TODO add bitmasks on includes for hardware  
001c			; high byte for expansion ids  
001c			;     0000 0000  no card inserted  
001c			;     0000 0001  storage card inserted  
001c			;     0000 0010  spi sd card active  
001c			  
001c			;       
001c			; low byte:  
001c			;     0000 0001   4x4 keypad  
001c			;     0000 0010   full keyboard  
001c			;     0000 0011   spi/ext keyboard  
001c			;     0000 0100   20x4 lcd  
001c			;     0000 1000   40x4 lcd  
001c			;     0000 1100   spi/ext display  
001c			;     0001 0000   ide interface available  
001c			  
001c			hardware_word: equ hardware_config - 2  
001c			  
001c			; debug marker - optional display of debug point on the debug screens  
001c			  
001c			debug_mark: equ hardware_word - 4  
001c			  
001c			; input_str vars  
001c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
001c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
001c			input_size: equ input_start -1  ; number of chars  
001c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
001c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
001c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
001c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
001c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
001c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
001c			input_len: equ input_cur_onoff - 5 ; length of current input  
001c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
001c			  
001c			CUR_BLINK_RATE: equ 15  
001c			  
001c			key_actual_pressed: equ input_cursor - 1   
001c			key_symbol: equ key_actual_pressed - 1   
001c			key_shift: equ key_symbol - 1   
001c			  
001c			; Display allocation  
001c			  
001c			;display_rows: equ 4     ; move out to mini and mega files  
001c			;display_cols: equ 20  
001c			  
001c			display_fb_len: equ display_rows*display_cols  
001c			  
001c			; primary frame buffer     
001c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
001c			; working frame buffers  
001c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
001c			display_fb3: equ  display_fb1-display_fb_len - 1  
001c			display_fb2: equ  display_fb3-display_fb_len - 1  
001c			;  
001c			; pointer to active frame buffer  
001c			display_fb_active: equ display_fb2 - 2  
001c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
001c			display_write_tmp: equ display_lcde1e2 - 2  
001c			  
001c			  
001c			;  
001c			  
001c			;; can load into de directory  
001c			cursor_col: equ display_write_tmp-1  
001c			cursor_row: equ cursor_col-1  
001c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
001c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
001c			  
001c			; maths vars  
001c			  
001c			LFSRSeed: equ cursor_shape -20   
001c			randData: equ LFSRSeed - 2  
001c			xrandc: equ randData - 2  
001c			stackstore: equ xrandc - 2  
001c			seed1: equ  stackstore -2   
001c			seed2: equ seed1 - 2  
001c			  
001c			; cf storage vars  
001c			  
001c			iErrorNum:  equ seed2-1         ;Error number  
001c			iErrorReg:  equ iErrorNum -1              ;Error register  
001c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
001c			  
001c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
001c			  
001c			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
001c			  
001c			store_page: equ store_bank_active-STORE_BLOCK_LOG            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
001c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
001c			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
001c			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
001c			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
001c			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
001c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
001c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
001c			store_tmpid: equ store_tmp3 - 1		; page temp id  
001c			store_tmpext: equ store_tmpid - 1		; file extent temp  
001c			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
001c			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
001c			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
001c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
001c			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
001c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
001c			;  
001c			; spi vars  
001c			  
001c			  
001c			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
001c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
001c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
001c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
001c			spi_device_id: equ spi_device - 1    ; human readable bank number  
001c			  
001c			;;;;; forth cli params  
001c			  
001c			; TODO use a different frame buffer for forth???  
001c			  
001c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
001c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
001c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
001c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
001c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
001c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
001c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
001c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
001c			  
001c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
001c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
001c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
001c			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
001c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
001c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
001c			  
001c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
001c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
001c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
001c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
001c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
001c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
001c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
001c			  
001c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
001c			  
001c			; os/forth token vars  
001c			  
001c			os_last_cmd: equ os_var_array-255  
001c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
001c			os_current_i: equ os_cli_cmd-2  
001c			os_cur_ptr: equ os_current_i-2  
001c			os_word_scratch: equ os_cur_ptr-30  
001c			os_tok_len: equ os_word_scratch - 2  
001c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
001c			os_tok_malloc: equ os_tok_ptr - 2  
001c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
001c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
001c			execscratch: equ os_input-255        ; exec cmd eval buffer  
001c			scratch: equ execscratch-255  
001c			  
001c			  
001c			; temp locations for new word processing to save on adding more   
001c			  
001c			os_new_malloc: equ scratch-2  
001c			os_new_parse_len: equ os_new_malloc - 2  
001c			os_new_word_len: equ os_new_parse_len - 2  
001c			os_new_work_ptr: equ os_new_word_len - 2  
001c			os_new_src_ptr: equ os_new_work_ptr - 2  
001c			os_new_exec: equ os_new_src_ptr - 2  
001c			os_new_exec_ptr: equ os_new_exec - 2  
001c			  
001c			; resume memory alloocations....  
001c			  
001c			os_view_disable: equ os_new_exec_ptr - 1  
001c			os_view_af: equ os_view_disable - 2  
001c			os_view_hl: equ os_view_af -2  
001c			os_view_de: equ os_view_hl - 2  
001c			os_view_bc: equ os_view_de - 2  
001c			  
001c			; stack checksum word  
001c			if DEBUG_STACK_IMB  
001c				curframe: equ  os_view_de - 5  
001c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
001c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
001c			else  
001c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
001c			endif  
001c			  
001c			; with data stack could see memory filled with junk. need some memory management   
001c			; malloc and free entry points added  
001c			  
001c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
001c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
001c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			;heap_end: equ free_list-1  ; Starting address of heap  
001c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			  
001c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			heap_end: equ chk_word-1  ; Starting address of heap  
001c			  
001c			  
001c			;if BASE_KEV   
001c			;heap_start: equ 0800eh  ; Starting address of heap  
001c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
001c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
001c			;endif  
001c			  
001c			;if BASE_SC114  
001c			;heap_start: equ baseram+15  ; Starting address of heap  
001c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
001c			;endif  
001c			  
001c			  
001c			;;;;  
001c			  
001c			  
001c			; change below to point to last memory alloc above  
001c			topusermem:  equ   heap_start  
001c			  
001c			;if BASE_KEV   
001c			;baseusermem: equ 08000h  
001c			;endif  
001c			  
001c			;if BASE_SC114  
001c			;;aseusermem:     equ    12  
001c			;baseusermem:     equ    prompt  
001c			;;baseusermem:     equ    endofcode  
001c			;endif  
001c			  
001c			  
001c			; **********************************************************************  
001c			; **  Constants  
001c			; **********************************************************************  
001c			  
001c			; Constants used by this code module  
001c			kDataReg:   EQU Device_D           ;PIO port A data register  
001c			kContReg:   EQU Device_D+2           ;PIO port A control register  
001c			  
001c			  
001c			portbdata:  equ Device_D+1    ; port b data  
001c			portbctl:   equ Device_D+3    ; port b control  
001c			  
001c			  
001c			;KEY_SHIFT:   equ 5  
001c			;KEY_SYMBOLSHIFT:  equ 6  
001c			  
001c			KEY_SHIFTLOCK: equ 4  
001c			  
001c			  
001c			KEY_UP: equ 5  
001c			KEY_NEXTWORD: equ 6  
001c			KEY_PREVWORD: equ 7  
001c			KEY_BS: equ 8  
001c			KEY_TAB:  equ 9  
001c			KEY_DOWN: equ 10  
001c			KEY_LEFT: equ 11  
001c			KEY_RIGHT: equ 12  
001c			KEY_CR:   equ 13  
001c			KEY_HOME: equ 14  
001c			KEY_END: equ 15  
001c			  
001c			KEY_F1: equ 16  
001c			KEY_F2: equ 17  
001c			KEY_F3: equ 18  
001c			KEY_F4: equ 19  
001c			  
001c			KEY_F5: equ 20  
001c			KEY_F6: equ 21  
001c			KEY_F7: equ 22  
001c			KEY_F8: equ 23  
001c			  
001c			KEY_F9: equ 24  
001c			KEY_F10: equ 25  
001c			KEY_F11: equ 26  
001c			KEY_F12: equ 27  
001c			  
001c			;if DEBUG_KEY  
001c			;	KEY_MATRIX_NO_PRESS: equ '.'  
001c			;	KEY_SHIFT:   equ '.'  
001c			;	KEY_SYMBOLSHIFT:  equ '.'  
001c			;else  
001c				KEY_SHIFT:   equ '~'  
001c				KEY_SYMBOLSHIFT:  equ '~'  
001c				KEY_MATRIX_NO_PRESS: equ '~'  
001c			;endi  
001c			  
001c			  
001c			  
001c			  
001c			; Macro to make adding debug marks easier  
001c			  
001c			DMARK: macro str  
001c				push af  
001c				ld a, (.dmark)  
001c				ld (debug_mark),a  
001c				ld a, (.dmark+1)  
001c				ld (debug_mark+1),a  
001c				ld a, (.dmark+2)  
001c				ld (debug_mark+2),a  
001c				jr .pastdmark  
001c			.dmark: db str  
001c			.pastdmark: pop af  
001c			  
001c			endm  
001c			  
001c			  
001c			; macro to detect for stack imbalances  
001c			  
001c			include "stackimbal.asm"  
001c			; Macro and code to detect stock imbalances 
001c			 
001c			SPPUSH: equ 0 
001c			 
001c			; Add a stack frame which can be checked before return 
001c			 
001c			STACKFRAME: macro onoff frame1 frame2 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						; save current SP 
001c						exx 
001c			 
001c						ld de, frame1 
001c						ld a, d 
001c						ld hl, curframe 
001c						call hexout 
001c						ld a, e 
001c						ld hl, curframe+2 
001c						call hexout 
001c			  
001c						ld hl, frame1 
001c						push hl 
001c						ld hl, frame2 
001c						push hl 
001c						exx 
001c					endif 
001c					 
001c				endif 
001c			endm 
001c			 
001c			STACKFRAMECHK: macro onoff frame1 frame2 
001c			 
001c					 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						exx 
001c						; check stack frame SP 
001c			 
001c						ld hl, frame2 
001c						pop de   ; frame2 
001c			 
001c						call cmp16 
001c						jr nz, .spnosame 
001c						 
001c			 
001c						ld hl, frame1 
001c						pop de   ; frame1 
001c			 
001c						call cmp16 
001c						jr z, .spfrsame 
001c			 
001c						.spnosame: call showsperror 
001c			 
001c						.spfrsame: nop 
001c			 
001c						exx 
001c					endif 
001c					 
001c				endif 
001c			 
001c			 
001c			endm 
001c			 
001c			 
001c			; for a sub routine, wrap SP collection and comparisons 
001c			 
001c			; Usage: 
001c			; 
001c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
001c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
001c			 
001c			SAVESP: macro onoff storeword 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						; save current SP 
001c			 
001c						ld (store_sp+(storeword*4)), sp 
001c			 
001c					endif 
001c					 
001c				endif 
001c			 
001c			endm 
001c			 
001c			CHECKSP: macro onoff storeword 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c			 
001c						; save SP after last save 
001c				 
001c						ld (store_sp+(storeword*4)+2), sp 
001c			 
001c						push hl 
001c						ld hl, store_sp+(storeword*4) 
001c						call check_stack_sp  
001c						pop hl 
001c			 
001c			 
001c					endif 
001c					 
001c				endif 
001c			 
001c			endm 
001c			 
001c			if DEBUG_STACK_IMB 
001c			 
001c			check_stack_sp: 
001c					push de 
001c			 
001c					ld e, (hl) 
001c					inc hl 
001c					ld d, (hl) 
001c					inc hl 
001c			 
001c					push de 
001c			 
001c			 
001c					ld e, (hl) 
001c					inc hl 
001c					ld d, (hl) 
001c					inc hl 
001c			 
001c					pop hl 
001c			 
001c			 
001c					; check to see if the same 
001c			 
001c					call cmp16 
001c					jr z, .spsame 
001c			 
001c					; not same 
001c			 
001c					call showsperror 
001c			.spsame: 
001c			 
001c					pop de 
001c			 
001c					ret 
001c			 
001c			.sperr:  db "Stack imbalance",0 
001c			 
001c			 
001c			showsperror: 
001c			 
001c			 
001c				push hl 
001c				push af 
001c				push de 
001c				call clear_display 
001c				ld de, .sperr 
001c				ld a,0 
001c			;	ld de,os_word_scratch 
001c				call str_at_display 
001c				ld a, display_row_1+17 
001c				ld de, debug_mark 
001c				call str_at_display 
001c				ld a, 0 
001c				ld (curframe+4),a 
001c				ld hl, curframe 
001c				ld de, os_word_scratch 
001c				ld a, display_row_4 
001c				call str_at_display 
001c				call update_display 
001c				;call break_point_state 
001c				call cin_wait 
001c			 
001c				ld a, ' ' 
001c				ld (os_view_disable), a 
001c				pop de	 
001c				pop af 
001c				pop hl 
001c				CALLMONITOR 
001c				ret 
001c			 
001c			endif 
001c			 
001c			 
001c			 
001c			; eof 
# End of file stackimbal.asm
001c			  
001c			;TODO macro to calc col and row offset into screen  
001c			  
001c			  
001c			  
001c			hardware_init:  
001c			  
001c				  
001c			  
001c					;ld a, 0  
001c					;ld (hardware_diag), a  
001c			  
001c					; clear all the buffers  
001c			  
001c 21 13 fd				ld hl, display_fb1  
001f 22 cf fb				ld (display_fb_active), hl  
0022			  
0022 cd d0 0c				call clear_display  
0025			  
0025 21 d1 fb				ld hl, display_fb2  
0028 22 cf fb				ld (display_fb_active), hl  
002b			  
002b cd d0 0c				call clear_display  
002e			  
002e					; init primary frame buffer area  
002e 21 b4 fd				ld hl, display_fb0  
0031 22 cf fb				ld (display_fb_active), hl  
0034			  
0034 cd d0 0c				call clear_display  
0037			  
0037			  
0037 cd d2 69				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
003a			  
003a cd 69 6c			call key_init  
003d cd bb 01			call storage_init  
0040			  
0040				; setup malloc functions  
0040			  
0040				if MALLOC_1  
0040 cd a7 13				call  heap_init  
0043				endif  
0043				if MALLOC_4  
0043					call  heap_init  
0043				endif  
0043			  
0043				; init sound hardware if present  
0043			  
0043				if SOUND_ENABLE  
0043 cd 64 15				call sound_init  
0046				endif  
0046			  
0046				; lcd test sequence  
0046					  
0046 cd f3 0c			call update_display  
0049 cd 4d 0c			call delay1s  
004c 3e 2b			ld a,'+'  
004e cd d5 0c			call fill_display  
0051 cd f3 0c			call update_display  
0054 cd 4d 0c			call delay1s  
0057 3e 2a			ld a,'*'  
0059 cd d5 0c			call fill_display  
005c cd f3 0c			call update_display  
005f cd 4d 0c			call delay1s  
0062 3e 2d			ld a,'-'  
0064 cd d5 0c			call fill_display  
0067 cd f3 0c			call update_display  
006a cd 4d 0c			call delay1s  
006d			  
006d			; boot splash screen  
006d			if display_cols == 20	  
006d			        ld a, display_row_1    
006d			else  
006d 3e 0a		        ld a, display_row_1 +10   
006f			endif  
006f 11 81 1a			ld de, prom_bootmsg  
0072 cd e3 0c			call str_at_display  
0075 cd f3 0c			call update_display  
0078			  
0078			  
0078 cd 4d 0c			call delay1s  
007b cd 4d 0c			call delay1s  
007e			if display_cols == 20	  
007e			            LD   A, display_row_3+2  
007e			else  
007e 3e 5c		            LD   A, display_row_3+12  
0080			endif  
0080 11 96 1a			ld de, prom_bootmsg1  
0083 cd e3 0c			call str_at_display  
0086 cd f3 0c			call update_display  
0089 cd 4d 0c			call delay1s  
008c cd 4d 0c			call delay1s  
008f			  
008f			;	ld a, display_row_4+3  
008f			;	ld de, bootmsg2  
008f			;	call str_at_display  
008f			;	call update_display  
008f			;	call delay1s  
008f			;	call delay1s  
008f			  
008f			; debug mark setup  
008f			  
008f 3e 5f		ld a, '_'  
0091 32 6e fe		ld (debug_mark),a  
0094 32 6f fe		ld (debug_mark+1),a  
0097 32 70 fe		ld (debug_mark+2),a  
009a 3e 00		ld a,0  
009c 32 71 fe		ld (debug_mark+3),a  
009f			  
009f c9					ret  
00a0			  
00a0			  
00a0			;bootmsg2:	db "Firmware v0.1",0  
00a0			  
00a0			; a 4x20 lcd  
00a0			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00a0			  
00a0			;if display_cols == 20  
00a0			;	include "firmware_lcd_4x20.asm"  
00a0			;endif  
00a0			  
00a0			;if display_cols == 40  
00a0			;	include "firmware_lcd_4x40.asm"  
00a0			;endif  
00a0			  
00a0			;  
00a0			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00a0			; TODO abstract the bit bang video out interface for dual display  
00a0			; TODO wire video out to tx pin on rc2014 bus  
00a0			  
00a0			; must supply cin, and cin_wait for low level hardware abstraction   
00a0			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00a0			; test scancode  
00a0			  
00a0			;;;;;  
00a0			;;;  
00a0			; Moved out to mini and maxi versions  
00a0			;  
00a0			; include "firmware_key_4x4.asm"  
00a0			; using existing 4 wire x 4 resistor array for input  
00a0			;include "firmware_key_4x10.asm"  
00a0			; need to mod the board for 5 rows due to resistor array  
00a0			;include "firmware_key_5x10.asm"  
00a0			  
00a0			; storage hardware interface  
00a0			  
00a0			; use microchip serial eeprom for storage  
00a0			  
00a0			  
00a0			if STORAGE_SE  
00a0				include "firmware_spi.asm"  
00a0			; my spi protocol (used by storage) 
00a0			 
00a0			; SPI pins 
00a0			 
00a0			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00a0			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00a0			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00a0			 
00a0			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00a0			; chip pin 4 gnd 
00a0			 
00a0			 
00a0			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00a0			SPI_CE1: equ 1      ;    port a1 pin 14  
00a0			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00a0			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00a0			SPI_CE4: equ 4      ; port a4     pin 10 
00a0			 
00a0			; active low AND masks 
00a0			 
00a0			;SPI_CE0_MASK: equ    255-1 
00a0			;SPI_CE1_MASK: equ   255-2 
00a0			;SPI_CE2_MASK: equ   255-4 
00a0			;SPI_CE3_MASK: equ   255-8 
00a0			;SPI_CE4_MASK: equ   255-16 
00a0			SPI_CE_HIGH:  equ 255 
00a0			 
00a0			 
00a0			 
00a0			 
00a0			; TODO store port id for spi device ie dev c 
00a0			; TODO store pin for SO 
00a0			; TODO store pin for SI 
00a0			; TODO store pin for SCLK 
00a0			 
00a0			; 
00a0			 
00a0			; ensure that spi bus is in a stable state with default pins  
00a0			 
00a0			se_stable_spi:   
00a0			 
00a0				 ; set DI high, CE high , SCLK low 
00a0				;ld a, SPI_DI | SPI_CE0 
00a0 3e 07			ld a, SPI_DI  
00a2 cd 76 01			call spi_ce_high 
00a5 d3 80			 out (storage_adata),a 
00a7 32 69 fa			ld (spi_portbyte),a 
00aa			 
00aa				if DEBUG_SPI 
00aa					push hl 
00aa					ld l, a 
00aa					DMARK "SPI" 
00aa					CALLMONITOR 
00aa					pop hl 
00aa				endif 
00aa c9				ret 
00ab			 
00ab			; byte to send in a 
00ab			 
00ab			spi_send_byte: 
00ab				; save byte to send for bit mask shift out 
00ab 4f			        ld c,a 
00ac 3a 69 fa			ld a,(spi_portbyte) 
00af				  
00af				; clock out	each bit of the byte msb first 
00af			 
00af 06 08			ld b, 8 
00b1			.ssb1: 
00b1				; clear so bit  
00b1 cb bf			res SPI_DI, a 
00b3 cb 11			rl c 
00b5				; if bit 7 is set then carry is set 
00b5 30 02			jr nc, .ssb2 
00b7 cb ff			set SPI_DI,a 
00b9			.ssb2:  ; output bit to ensure it is stable 
00b9 d3 80			out (storage_adata),a 
00bb 00				nop 
00bc				; clock bit high 
00bc cb ef			set SPI_SCLK,a 
00be d3 80			out (storage_adata),a 
00c0 00				nop 
00c1				; then low 
00c1 cb af			res SPI_SCLK,a 
00c3 d3 80			out (storage_adata),a 
00c5 00				nop 
00c6 10 e9			djnz .ssb1 
00c8			 
00c8 32 69 fa			ld (spi_portbyte),a 
00cb c9				ret 
00cc			 
00cc			; TODO low level get byte into A on spi 
00cc			 
00cc			spi_read_byte:  
00cc			 
00cc				; save byte to send for bit mask shift out 
00cc 0e 00		    ld c,0 
00ce 3a 69 fa			ld a,(spi_portbyte) 
00d1				  
00d1				; clock out	each bit of the byte msb first 
00d1			 
00d1			 
00d1				; clock bit high 
00d1 cb ef			set SPI_SCLK,a 
00d3 d3 80			out (storage_adata),a 
00d5 00				nop 
00d6			 
00d6			    ; read DO  
00d6			 
00d6 cb f9		    set 7,c 
00d8 db 80			in a,(storage_adata) 
00da cb 77		    bit SPI_DO,a 
00dc 20 02		    jr nz, .b7 
00de cb b9		    res 7,c 
00e0			.b7: 
00e0				; then low 
00e0 cb af			res SPI_SCLK,a 
00e2 d3 80			out (storage_adata),a 
00e4 00				nop 
00e5			     
00e5			 
00e5				; clock bit high 
00e5 cb ef			set SPI_SCLK,a 
00e7 d3 80			out (storage_adata),a 
00e9 00				nop 
00ea			 
00ea			    ; read DO  
00ea			 
00ea cb f1		    set 6,c 
00ec db 80			in a,(storage_adata) 
00ee cb 77		    bit SPI_DO,a 
00f0 20 02		    jr nz, .b6 
00f2 cb b1		    res 6,c 
00f4			.b6: 
00f4				; then low 
00f4 cb af			res SPI_SCLK,a 
00f6 d3 80			out (storage_adata),a 
00f8 00				nop 
00f9			 
00f9				; clock bit high 
00f9 cb ef			set SPI_SCLK,a 
00fb d3 80			out (storage_adata),a 
00fd 00				nop 
00fe			 
00fe			 
00fe			    ; read DO  
00fe			 
00fe cb e9		    set 5,c 
0100 db 80			in a,(storage_adata) 
0102 cb 77		    bit SPI_DO,a 
0104 20 02		    jr nz, .b5 
0106 cb a9		    res 5,c 
0108			.b5: 
0108				; then low 
0108 cb af			res SPI_SCLK,a 
010a d3 80			out (storage_adata),a 
010c 00				nop 
010d				; clock bit high 
010d cb ef			set SPI_SCLK,a 
010f d3 80			out (storage_adata),a 
0111 00				nop 
0112			 
0112			    ; read DO  
0112			 
0112 cb e1		    set 4,c 
0114 db 80			in a,(storage_adata) 
0116 cb 77		    bit SPI_DO,a 
0118 20 02		    jr nz, .b4 
011a cb a1		    res 4,c 
011c			.b4: 
011c				; then low 
011c cb af			res SPI_SCLK,a 
011e d3 80			out (storage_adata),a 
0120 00				nop 
0121				; clock bit high 
0121 cb ef			set SPI_SCLK,a 
0123 d3 80			out (storage_adata),a 
0125 00				nop 
0126			 
0126			    ; read DO  
0126			 
0126 cb d9		    set 3,c 
0128 db 80			in a,(storage_adata) 
012a cb 77		    bit SPI_DO,a 
012c 20 02		    jr nz, .b3 
012e cb 99		    res 3,c 
0130			.b3: 
0130				; then low 
0130 cb af			res SPI_SCLK,a 
0132 d3 80			out (storage_adata),a 
0134 00				nop 
0135				; clock bit high 
0135 cb ef			set SPI_SCLK,a 
0137 d3 80			out (storage_adata),a 
0139 00				nop 
013a			 
013a			    ; read DO  
013a			 
013a cb d1		    set 2,c 
013c db 80			in a,(storage_adata) 
013e cb 77		    bit SPI_DO,a 
0140 20 02		    jr nz, .b2 
0142 cb 91		    res 2,c 
0144			.b2: 
0144				; then low 
0144 cb af			res SPI_SCLK,a 
0146 d3 80			out (storage_adata),a 
0148 00				nop 
0149				; clock bit high 
0149 cb ef			set SPI_SCLK,a 
014b d3 80			out (storage_adata),a 
014d 00				nop 
014e			 
014e			    ; read DO  
014e			 
014e cb c9		    set 1,c 
0150 db 80			in a,(storage_adata) 
0152 cb 77		    bit SPI_DO,a 
0154 20 02		    jr nz, .b1 
0156 cb 89		    res 1,c 
0158			.b1: 
0158				; then low 
0158 cb af			res SPI_SCLK,a 
015a d3 80			out (storage_adata),a 
015c 00				nop 
015d				; clock bit high 
015d cb ef			set SPI_SCLK,a 
015f d3 80			out (storage_adata),a 
0161 00				nop 
0162			 
0162			    ; read DO  
0162			 
0162 cb c1		    set 0,c 
0164 db 80			in a,(storage_adata) 
0166 cb 77		    bit SPI_DO,a 
0168 20 02		    jr nz, .b0 
016a cb 81		    res 0,c 
016c			.b0: 
016c				; then low 
016c cb af			res SPI_SCLK,a 
016e d3 80			out (storage_adata),a 
0170 00				nop 
0171			 
0171			 
0171 32 69 fa			ld (spi_portbyte),a 
0174			 
0174			    ; return byte 
0174 79			    ld a,c 
0175			 
0175			 
0175 c9				ret 
0176			 
0176			 
0176			 
0176			spi_ce_high: 
0176			 
0176				if DEBUG_SPI_HARD_CE0 
0176			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0176					ret 
0176			 
0176				endif 
0176			 
0176			 
0176 f5				push af 
0177			 
0177				; send direct ce to port b 
0177 3e ff			ld a, 255 
0179 d3 81			out (storage_bdata), a 
017b			 
017b f1				pop af 
017c			 
017c				; for port a that shares with spi lines AND the mask 
017c			  
017c				if DEBUG_SPI 
017c					push hl 
017c					ld h, a 
017c				endif 
017c			;	ld c, SPI_CE_HIGH 
017c			;	and c 
017c cb c7			set SPI_CE0, a 
017e cb cf			set SPI_CE1, a 
0180 cb d7			set SPI_CE2, a 
0182 cb df			set SPI_CE3, a 
0184 cb e7			set SPI_CE4, a 
0186			 
0186				if DEBUG_SPI 
0186					ld l, a 
0186					DMARK "CEh" 
0186					CALLMONITOR 
0186					pop hl 
0186				endif 
0186 c9				ret 
0187			 
0187			 
0187			spi_ce_low: 
0187			 
0187				if DEBUG_SPI_HARD_CE0 
0187			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0187					ret 
0187			 
0187				endif 
0187			 
0187 c5				push bc 
0188 f5				push af 
0189			 
0189				; send direct ce to port b 
0189 3a 6b fa			ld a, (spi_cartdev) 
018c d3 81			out (storage_bdata), a 
018e			 
018e			 
018e			 
018e				; for port a that shares with spi lines AND the mask 
018e			 
018e 3a 68 fa			ld a, (spi_device)  
0191 4f				ld c, a 
0192			 
0192 f1				pop af 
0193			 
0193				; detect CEx 
0193			 
0193				if DEBUG_SPI 
0193					push hl 
0193					ld h, a 
0193				endif 
0193			 
0193 cb 41			bit SPI_CE0, c 
0195 20 04			jr nz, .cel1 
0197 cb 87			res SPI_CE0, a 
0199 18 1e			jr .celn 
019b			.cel1: 
019b cb 49			bit SPI_CE1, c 
019d 20 04			jr nz, .cel2 
019f cb 8f			res SPI_CE1, a 
01a1 18 16			jr .celn 
01a3			.cel2: 
01a3 cb 51			bit SPI_CE2, c 
01a5 20 04			jr nz, .cel3 
01a7 cb 97			res SPI_CE2, a 
01a9 18 0e			jr .celn 
01ab			.cel3: 
01ab cb 59			bit SPI_CE3, c 
01ad 20 04			jr nz, .cel4 
01af cb 9f			res SPI_CE3, a 
01b1 18 06			jr .celn 
01b3			.cel4: 
01b3 cb 61			bit SPI_CE4, c 
01b5 20 02			jr nz, .celn 
01b7 cb a7			res SPI_CE4, a 
01b9			.celn: 
01b9			 
01b9			 
01b9			 
01b9			;	add c 
01b9			 
01b9				if DEBUG_SPI 
01b9					ld l, a 
01b9					DMARK "CEl" 
01b9					CALLMONITOR 
01b9					pop hl 
01b9				endif 
01b9 c1				pop bc 
01ba c9				ret 
01bb			 
01bb			 
01bb			 
01bb			; eof 
01bb			 
01bb			 
01bb			 
01bb			 
01bb			 
# End of file firmware_spi.asm
01bb				include "firmware_seeprom.asm"  
01bb			; 
01bb			; persisent storage interface via microchip serial eeprom 
01bb			 
01bb			; port a pio 2 
01bb			; pa 7 - si 
01bb			; pa 6 - sclk  
01bb			; pa 5 - so 
01bb			; pa 4 - cs 
01bb			; pa 3 - cs 
01bb			; pa 2 - cs 
01bb			; pa 1 - cs 
01bb			; pa 0 - cs 
01bb			; 
01bb			; TODO get block 
01bb			; TODO save block 
01bb			; TODO load file 
01bb			; TODO save file 
01bb			; TODO get dir  
01bb			 
01bb			;  
01bb			storage_adata: equ Device_C    ; device c port a - onboard storage 
01bb			storage_actl: equ Device_C+2     ; device c port a 
01bb			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
01bb			storage_bctl: equ Device_C+3     ; device c port b 
01bb			 
01bb			 
01bb			; TODO move these to hardware driver file 
01bb			 
01bb			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
01bb			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
01bb			; storage bank file system format 
01bb			; 
01bb			; first page of bank: 
01bb			; 	addr 0 - status check 
01bb			;       addr 1 - write protect flag 
01bb			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
01bb			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
01bb			;         TODO see if scanning whole of for available next file id is fast enough 
01bb			;	addr 4 > zero term string of bank label 
01bb			; 
01bb			;        
01bb			;  
01bb			; first page of any file: 
01bb			;      byte 0 - file id  
01bb			;      byte 1-17 - fixed file name  
01bb			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
01bb			; 
01bb			; other pages of any file: 
01bb			;      byte 0 - file id 
01bb			;      byte 1> - file data 
01bb			; 
01bb			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
01bb			;  
01bb			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
01bb			 
01bb			 
01bb			;storage_so_bit: 5 
01bb			;storage_si_bit: 7 
01bb			;storage_sclk_bit: 6 
01bb			  
01bb			 
01bb			; init storage pio 
01bb			 
01bb			storage_init: 
01bb			 
01bb 3e cf		            LD   A, 11001111b 
01bd d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
01bf 3e 00		            LD   A, 00000000b 
01c1 cb f7			set SPI_DO,a 
01c3			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
01c3 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
01c5			 
01c5 3e cf		            LD   A, 11001111b 
01c7 d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
01c9 3e 00		            LD   A, 00000000b 
01cb d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
01cd			 
01cd				; set all external spi devices off 
01cd 3e 00			ld a, 0 
01cf 32 68 fa			ld (spi_device), a 
01d2 32 6b fa			ld (spi_cartdev), a 
01d5			 
01d5					; ensure the spi bus is in a default stable state 
01d5 cd a0 00				call se_stable_spi 
01d8			 
01d8			; TODO scan spi bus and gather which storage banks are present 
01d8			 
01d8			; populate store_bank_active  
01d8			; for each ce line activate and attempt to write first byte of bank and read back 
01d8			; if zero is returned then bank is empty 
01d8			;   
01d8			; 
01d8			 
01d8					; init file extent cache to save on slow reads 
01d8			 
01d8			;	ld hl, store_filecache 
01d8			;	ld de, 0 
01d8			;	ld hl,(de)	 
01d8			 
01d8			 
01d8 c9			    ret 
01d9			 
01d9			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
01d9			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
01d9			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
01d9			 
01d9			; INSTRUCTION SET 
01d9			; READ 0000 0011 Read data from memory array beginning at selected address 
01d9			; WRITE 0000 0010 Write data to memory array beginning at selected address 
01d9			; WREN 0000 0110 Set the write enable latch (enable write operations) 
01d9			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
01d9			; RDSR 0000 0101 Read STATUS register 
01d9			; WRSR 0000 0001 Write STATUS register 
01d9			; PE 0100 0010 Page Erase – erase one page in memory array 
01d9			; SE 1101 1000 Sector Erase – erase one sector in memory array 
01d9			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
01d9			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
01d9			 
01d9			; TODO send byte steam for page without setting the address for every single byte 
01d9			; TODO read byte  
01d9			 
01d9			; byte in a 
01d9			; address in hl  
01d9			se_writebyte: 
01d9			        
01d9			    ;   ld c, a 
01d9 f5			        push af 
01da e5			        push hl 
01db			 
01db			    ; initi write mode 
01db			    ; 
01db			    ;CS low 
01db			 
01db 3a 69 fa		       ld a,(spi_portbyte) 
01de cd 87 01			call spi_ce_low 
01e1			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01e1 d3 80		       out (storage_adata),a 
01e3 32 69 fa		       ld (spi_portbyte), a 
01e6			 
01e6			    ;clock out wren instruction 
01e6			 
01e6 3e 06		    ld a, store_wren_ins 
01e8 cd ab 00		    call spi_send_byte  
01eb			 
01eb			    ;cs high to enable write latch 
01eb			 
01eb 3a 69 fa		       ld a,(spi_portbyte) 
01ee cd 76 01			call spi_ce_high 
01f1			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
01f1 d3 80		       out (storage_adata),a 
01f3 32 69 fa		       ld (spi_portbyte), a 
01f6			 
01f6 00				nop 
01f7			    ; 
01f7			    ; intial write data 
01f7			    ; 
01f7			    ; cs low 
01f7			     
01f7 3a 69 fa		       ld a,(spi_portbyte) 
01fa cd 87 01			call spi_ce_low 
01fd			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01fd d3 80		       out (storage_adata),a 
01ff 32 69 fa		       ld (spi_portbyte), a 
0202			 
0202			    ; clock out write instruction 
0202			     
0202 3e 02		    ld a, store_write_ins  
0204 cd ab 00		    call spi_send_byte  
0207			 
0207			    ; clock out address (depending on address size) 
0207			     
0207 e1			    pop hl 
0208 7c			    ld a,h    ; address out msb first 
0209 cd ab 00		    call spi_send_byte  
020c 7d			    ld a,l 
020d cd ab 00		    call spi_send_byte  
0210			 
0210			    ; clock out byte(s) for page 
0210			 
0210 f1			    pop af 
0211 cd ab 00		    call spi_send_byte  
0214			 
0214			    ; end write with ce high 
0214 3a 69 fa		       ld a,(spi_portbyte) 
0217			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
0217 cd 76 01			call spi_ce_high 
021a d3 80		       out (storage_adata),a 
021c 32 69 fa		       ld (spi_portbyte), a 
021f			 
021f				; pause for internal write cycle 
021f 3e 0a			ld a, 10 
0221 cd 32 0c			call aDelayInMS 
0224 c9			    ret 
0225			 
0225			; buffer to write in de 
0225			; address in hl  
0225			se_writepage: 
0225			        
0225			    ;   ld c, a 
0225 d5				push de 
0226 e5			        push hl 
0227			 
0227			    ; initi write mode 
0227			    ; 
0227			    ;CS low 
0227			 
0227 3a 69 fa		       ld a,(spi_portbyte) 
022a cd 87 01			call spi_ce_low 
022d			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
022d d3 80		       out (storage_adata),a 
022f 32 69 fa		       ld (spi_portbyte), a 
0232			 
0232			    ;clock out wren instruction 
0232			 
0232 3e 06		    ld a, store_wren_ins 
0234 cd ab 00		    call spi_send_byte  
0237			 
0237			    ;cs high to enable write latch 
0237			 
0237 3a 69 fa		       ld a,(spi_portbyte) 
023a cd 76 01			call spi_ce_high 
023d			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
023d d3 80		       out (storage_adata),a 
023f 32 69 fa		       ld (spi_portbyte), a 
0242			 
0242 00				nop 
0243			    ; 
0243			    ; intial write data 
0243			    ; 
0243			    ; cs low 
0243			     
0243 3a 69 fa		       ld a,(spi_portbyte) 
0246			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0246 cd 87 01			call spi_ce_low 
0249 d3 80		       out (storage_adata),a 
024b 32 69 fa		       ld (spi_portbyte), a 
024e			 
024e			    ; clock out write instruction 
024e			     
024e 3e 02		    ld a, store_write_ins  
0250 cd ab 00		    call spi_send_byte  
0253			 
0253			    ; clock out address (depending on address size) 
0253			     
0253 e1			    pop hl 
0254 7c			    ld a,h    ; address out msb first 
0255 cd ab 00		    call spi_send_byte  
0258 7d			    ld a,l 
0259 cd ab 00		    call spi_send_byte  
025c			 
025c			    ; clock out byte(s) for page 
025c			 
025c e1				pop hl 
025d 06 40			ld b, STORE_BLOCK_PHY 
025f			.bytewrite: 
025f			 
025f 7e				ld a,(hl) 
0260 e5			    push hl 
0261 c5				push bc 
0262 cd ab 00		    call spi_send_byte  
0265 c1				pop bc 
0266 e1				pop hl 
0267			 
0267			    ; end write with ce high 
0267 3a 69 fa		       ld a,(spi_portbyte) 
026a cd 76 01			call spi_ce_high 
026d			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
026d d3 80		       out (storage_adata),a 
026f 32 69 fa		       ld (spi_portbyte), a 
0272			 
0272 23				inc hl 
0273 10 ea			djnz .bytewrite 
0275			 
0275				; pause for internal write cycle 
0275 3e 64			ld a, 100 
0277 cd 32 0c			call aDelayInMS 
027a c9			    ret 
027b			; returns byte in a 
027b			; address in hl  
027b			se_readbyte: 
027b d5				push de 
027c c5				push bc 
027d			 
027d			    ;   ld c, a 
027d e5			        push hl 
027e			 
027e			    ; initi write mode 
027e			    ; 
027e			    ;CS low 
027e			 
027e 3a 69 fa		       ld a,(spi_portbyte) 
0281 cd 87 01			call spi_ce_low 
0284			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0284 d3 80		       out (storage_adata),a 
0286 32 69 fa		       ld (spi_portbyte), a 
0289			 
0289			    ;clock out wren instruction 
0289			 
0289 3e 03		    ld a, store_read_ins 
028b cd ab 00		    call spi_send_byte  
028e			 
028e			 
028e			    ; clock out address (depending on address size) 
028e			     
028e e1			    pop hl 
028f 7c			    ld a,h    ; address out msb first 
0290 cd ab 00		    call spi_send_byte  
0293 7d			    ld a,l 
0294 cd ab 00		    call spi_send_byte  
0297			 
0297			    ; clock in byte(s) for page 
0297			 
0297 cd cc 00		    call spi_read_byte  
029a f5				push af 
029b			 
029b			    ; end write with ce high 
029b 3a 69 fa		       ld a,(spi_portbyte) 
029e			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
029e cd 76 01			call spi_ce_high 
02a1 d3 80		       out (storage_adata),a 
02a3 32 69 fa		       ld (spi_portbyte), a 
02a6			 
02a6 f1				pop af 
02a7			 
02a7 c1				pop bc 
02a8 d1				pop de 
02a9			 
02a9 c9			    ret 
02aa			 
02aa			if DEBUG_STORESE 
02aa			 
02aa			storageput:  
02aa			 
02aa			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
02aa			 
02aa 21 ff f1			ld hl,scratch+2 
02ad cd bb 12			call get_word_hl 
02b0			 
02b0				; stuff it here for the moment as it will be overwritten later anyway 
02b0			 
02b0 22 20 f5			ld (os_cur_ptr),hl	 
02b3			 
02b3			 
02b3			; get pointer to start of string 
02b3			 
02b3 21 04 f2			ld hl, scratch+7 
02b6			 
02b6			; loop writing char of string to eeprom 
02b6			 
02b6 7e			.writestr:	ld a,(hl) 
02b7 fe 00				cp 0 
02b9 28 12				jr z, .wsdone		; done writing 
02bb e5					push hl 
02bc 2a 20 f5				ld hl,(os_cur_ptr) 
02bf cd d9 01				call se_writebyte 
02c2			 
02c2 2a 20 f5				ld hl,(os_cur_ptr)	 ; save next eeprom address 
02c5 23					inc hl 
02c6 22 20 f5				ld (os_cur_ptr),hl 
02c9			 
02c9					; restore string pointer and get next char 
02c9			 
02c9 e1					pop hl 
02ca 23					inc hl 
02cb 18 e9				jr .writestr 
02cd			 
02cd			 
02cd			 
02cd			.wsdone: 
02cd			 
02cd			 
02cd			; when done load first page into a buffer  
02cd			 
02cd 21 00 80				ld hl,08000h		; start in ram 
02d0 22 20 f5				ld (os_cur_ptr),hl 
02d3 21 00 00				ld hl, 0		 ; start of page 
02d6 22 25 f2				ld (scratch+40),hl	; hang on to it 
02d9			 
02d9 06 80				ld b, 128		; actually get more then one page 
02db c5			.wsload:	push bc 
02dc 2a 25 f2				ld hl,(scratch+40) 
02df e5					push hl 
02e0 cd 7b 02				call se_readbyte 
02e3			 
02e3					; a now as the byte 
02e3			 
02e3 2a 20 f5				ld hl,(os_cur_ptr) 
02e6 77					ld (hl),a 
02e7					; inc next buffer area 
02e7 23					inc hl 
02e8 22 20 f5				ld (os_cur_ptr),hl 
02eb			 
02eb					; get eeprom position, inc and save for next round 
02eb e1					pop hl		 
02ec 23					inc hl 
02ed 22 25 f2				ld (scratch+40),hl 
02f0 c1					pop bc 
02f1 10 e8				djnz .wsload 
02f3			 
02f3			; set 'd' pointer to start of buffer 
02f3			 
02f3 21 00 80				ld hl,08000h 
02f6 22 20 f5				ld (os_cur_ptr),hl 
02f9			 
02f9			 
02f9 c9			ret 
02fa			 
02fa			 
02fa c9			storageread: ret 
02fb			 
02fb			 
02fb			 
02fb			 
02fb			 
02fb			 
02fb			endif 
02fb			 
02fb			 
02fb			 
# End of file firmware_seeprom.asm
02fb			else  
02fb			   ; create some stubs for the labels  
02fb			se_readbyte: ret  
02fb			se_writebyte: ret  
02fb			storage_init: ret  
02fb			  
02fb			endif  
02fb			  
02fb			; use cf card for storage - throwing timeout errors. Hardware or software?????  
02fb			;include "firmware_cf.asm"  
02fb			  
02fb			; load up high level storage hardward abstractions  
02fb			include "firmware_storage.asm"  
02fb			 
02fb			; persisent storage hardware abstraction layer  
02fb			 
02fb			 
02fb			 
02fb			; Block 0 on storage is a config state 
02fb			 
02fb			 
02fb			 
02fb			; TODO add read phy block and write phy block functions 
02fb			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
02fb			 
02fb			; Abstraction layer  
02fb			 
02fb			; Logocial block size is same size as physical size - using tape concept 
02fb			 
02fb			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
02fb			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
02fb			 
02fb			 
02fb			 
02fb			; Filesystem layout (Logical layout) 
02fb			; 
02fb			; Block 0 - Bank config  
02fb			; 
02fb			;      Byte - 0 file id counter 
02fb			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
02fb			;      Byte - 3-20 zero terminated bank label 
02fb			; 
02fb			; Block 1 > File storage 
02fb			; 
02fb			;      Byte 0 file id    - block 0 file details 
02fb			;      Byte 1 block id - block 0 is file  
02fb			;            Byte 2-15 - File name 
02fb			; 
02fb			;       - to end of block data 
02fb			; 
02fb			 
02fb			; Get ID for the file named in pointer held HL 
02fb			; Returns ID in HL = 255 if no file found 
02fb			 
02fb			storage_getid: 
02fb			 
02fb 22 7a fa			ld (store_tmp1), hl 
02fe			 
02fe				if DEBUG_STORESE 
02fe					DMARK "SGI" 
02fe f5				push af  
02ff 3a 13 03			ld a, (.dmark)  
0302 32 6e fe			ld (debug_mark),a  
0305 3a 14 03			ld a, (.dmark+1)  
0308 32 6f fe			ld (debug_mark+1),a  
030b 3a 15 03			ld a, (.dmark+2)  
030e 32 70 fe			ld (debug_mark+2),a  
0311 18 03			jr .pastdmark  
0313 ..			.dmark: db "SGI"  
0316 f1			.pastdmark: pop af  
0317			endm  
# End of macro DMARK
0317					CALLMONITOR 
0317 cd ab 18			call break_point_state  
031a				endm  
# End of macro CALLMONITOR
031a				endif 
031a				; get block 0 and set counter for number of files to scan 
031a			 
031a cd 85 04			call storage_get_block_0 
031d			 
031d 3a 81 fa			ld a, (store_page) 
0320 47				ld b, a 
0321			 
0321				; get extent 0 of each file id 
0321			 
0321				if DEBUG_STORESE 
0321					DMARK "SGc" 
0321 f5				push af  
0322 3a 36 03			ld a, (.dmark)  
0325 32 6e fe			ld (debug_mark),a  
0328 3a 37 03			ld a, (.dmark+1)  
032b 32 6f fe			ld (debug_mark+1),a  
032e 3a 38 03			ld a, (.dmark+2)  
0331 32 70 fe			ld (debug_mark+2),a  
0334 18 03			jr .pastdmark  
0336 ..			.dmark: db "SGc"  
0339 f1			.pastdmark: pop af  
033a			endm  
# End of macro DMARK
033a					CALLMONITOR 
033a cd ab 18			call break_point_state  
033d				endm  
# End of macro CALLMONITOR
033d				endif 
033d 60			.getloop:	ld h, b 
033e 2e 00				ld l, 0 
0340 c5					push bc 
0341			 
0341 11 81 fa				ld de, store_page 
0344				if DEBUG_STORESE 
0344					DMARK "SGr" 
0344 f5				push af  
0345 3a 59 03			ld a, (.dmark)  
0348 32 6e fe			ld (debug_mark),a  
034b 3a 5a 03			ld a, (.dmark+1)  
034e 32 6f fe			ld (debug_mark+1),a  
0351 3a 5b 03			ld a, (.dmark+2)  
0354 32 70 fe			ld (debug_mark+2),a  
0357 18 03			jr .pastdmark  
0359 ..			.dmark: db "SGr"  
035c f1			.pastdmark: pop af  
035d			endm  
# End of macro DMARK
035d					CALLMONITOR 
035d cd ab 18			call break_point_state  
0360				endm  
# End of macro CALLMONITOR
0360				endif 
0360 cd 2d 09				call storage_read 
0363 cd 2d 0f				call ishlzero 
0366 28 2d				jr z, .gap 
0368					 
0368					; have a file name read. Is it one we want. 
0368			 
0368 2a 7a fa				ld hl, (store_tmp1) 
036b 11 84 fa				ld de, store_page+3   ; file name 
036e			 
036e				if DEBUG_STORESE 
036e					DMARK "SGc" 
036e f5				push af  
036f 3a 83 03			ld a, (.dmark)  
0372 32 6e fe			ld (debug_mark),a  
0375 3a 84 03			ld a, (.dmark+1)  
0378 32 6f fe			ld (debug_mark+1),a  
037b 3a 85 03			ld a, (.dmark+2)  
037e 32 70 fe			ld (debug_mark+2),a  
0381 18 03			jr .pastdmark  
0383 ..			.dmark: db "SGc"  
0386 f1			.pastdmark: pop af  
0387			endm  
# End of macro DMARK
0387					CALLMONITOR 
0387 cd ab 18			call break_point_state  
038a				endm  
# End of macro CALLMONITOR
038a				endif 
038a cd 9a 13				call strcmp 
038d 20 06				jr nz, .gap   ; not this one 
038f			 
038f c1				        pop bc 
0390			 
0390 26 00				ld h, 0 
0392 68					ld l, b 
0393 18 22				jr .getdone 
0395						 
0395			 
0395			 
0395			 
0395			.gap: 
0395				if DEBUG_STORESE 
0395					DMARK "SGg" 
0395 f5				push af  
0396 3a aa 03			ld a, (.dmark)  
0399 32 6e fe			ld (debug_mark),a  
039c 3a ab 03			ld a, (.dmark+1)  
039f 32 6f fe			ld (debug_mark+1),a  
03a2 3a ac 03			ld a, (.dmark+2)  
03a5 32 70 fe			ld (debug_mark+2),a  
03a8 18 03			jr .pastdmark  
03aa ..			.dmark: db "SGg"  
03ad f1			.pastdmark: pop af  
03ae			endm  
# End of macro DMARK
03ae					CALLMONITOR 
03ae cd ab 18			call break_point_state  
03b1				endm  
# End of macro CALLMONITOR
03b1				endif 
03b1			 
03b1 c1					pop bc 
03b2 10 89				djnz .getloop 
03b4 21 ff 00				ld hl, 255 
03b7			.getdone: 
03b7			 
03b7				if DEBUG_STORESE 
03b7					DMARK "SGe" 
03b7 f5				push af  
03b8 3a cc 03			ld a, (.dmark)  
03bb 32 6e fe			ld (debug_mark),a  
03be 3a cd 03			ld a, (.dmark+1)  
03c1 32 6f fe			ld (debug_mark+1),a  
03c4 3a ce 03			ld a, (.dmark+2)  
03c7 32 70 fe			ld (debug_mark+2),a  
03ca 18 03			jr .pastdmark  
03cc ..			.dmark: db "SGe"  
03cf f1			.pastdmark: pop af  
03d0			endm  
# End of macro DMARK
03d0					CALLMONITOR 
03d0 cd ab 18			call break_point_state  
03d3				endm  
# End of macro CALLMONITOR
03d3				endif 
03d3			 
03d3 c9				ret 
03d4			 
03d4			 
03d4			 
03d4			 
03d4			 
03d4			 
03d4			 
03d4			 
03d4			; Read Block 
03d4			; ---------- 
03d4			; 
03d4			; With current bank 
03d4			;  
03d4			; Get block number to read 
03d4			; Load physical blocks starting at start block into buffer 
03d4			 
03d4			; de points to buffer to use 
03d4			; hl holds logical block number  
03d4			 
03d4			storage_read_block: 
03d4			 
03d4				; TODO bank selection 
03d4			 
03d4				; for each of the physical blocks read it into the buffer 
03d4 06 40			ld b, STORE_BLOCK_PHY 
03d6			 
03d6				if DEBUG_STORESE 
03d6 d5					push de 
03d7				endif 
03d7				 
03d7			.rl1:    
03d7			 
03d7				; read physical block at hl into de 
03d7			        ; increment hl and de to next read position on exit 
03d7			 
03d7 e5				push hl 
03d8 d5				push de	 
03d9 c5				push bc 
03da			;	if DEBUG_STORESE 
03da			;		push af 
03da			;		ld a, 'R' 
03da			;		ld (debug_mark),a 
03da			;		pop af 
03da			;		CALLMONITOR 
03da			;	endif 
03da cd 7b 02			call se_readbyte 
03dd			;	if DEBUG_STORESE 
03dd			;		ld a,(spi_portbyte) 
03dd			;		ld l, a 
03dd			;		push af 
03dd			;		ld a, '1' 
03dd			;		ld (debug_mark),a 
03dd			;		pop af 
03dd			;		CALLMONITOR 
03dd			;	endif 
03dd c1				pop bc 
03de d1				pop de 
03df e1				pop hl 
03e0 12				ld (de),a 
03e1 23				inc hl 
03e2 13				inc de 
03e3			 
03e3			;	if DEBUG_STORESE 
03e3			;		push af 
03e3			;		ld a, 'r' 
03e3			;		ld (debug_mark),a 
03e3			;		pop af 
03e3			;		CALLMONITOR 
03e3			;	endif 
03e3			 
03e3 10 f2			djnz .rl1 
03e5			 
03e5				if DEBUG_STORESE 
03e5					DMARK "SRB" 
03e5 f5				push af  
03e6 3a fa 03			ld a, (.dmark)  
03e9 32 6e fe			ld (debug_mark),a  
03ec 3a fb 03			ld a, (.dmark+1)  
03ef 32 6f fe			ld (debug_mark+1),a  
03f2 3a fc 03			ld a, (.dmark+2)  
03f5 32 70 fe			ld (debug_mark+2),a  
03f8 18 03			jr .pastdmark  
03fa ..			.dmark: db "SRB"  
03fd f1			.pastdmark: pop af  
03fe			endm  
# End of macro DMARK
03fe d1					pop de 
03ff			; 
03ff			;		push af 
03ff			;		ld a, 'R' 
03ff			;		ld (debug_mark),a 
03ff			;		pop af 
03ff					CALLMONITOR 
03ff cd ab 18			call break_point_state  
0402				endm  
# End of macro CALLMONITOR
0402				endif 
0402 c9				ret	 
0403				 
0403			 
0403			; File Size 
0403			; --------- 
0403			; 
0403			;   hl file id 
0403			; 
0403			;  returns in hl the number of blocks 
0403			 
0403			storage_file_size: 
0403 5d				ld e, l 
0404 16 00			ld d, 0 
0406 21 40 00			ld hl, STORE_BLOCK_PHY 
0409					if DEBUG_FORTH_WORDS 
0409						DMARK "SIZ" 
0409 f5				push af  
040a 3a 1e 04			ld a, (.dmark)  
040d 32 6e fe			ld (debug_mark),a  
0410 3a 1f 04			ld a, (.dmark+1)  
0413 32 6f fe			ld (debug_mark+1),a  
0416 3a 20 04			ld a, (.dmark+2)  
0419 32 70 fe			ld (debug_mark+2),a  
041c 18 03			jr .pastdmark  
041e ..			.dmark: db "SIZ"  
0421 f1			.pastdmark: pop af  
0422			endm  
# End of macro DMARK
0422						CALLMONITOR 
0422 cd ab 18			call break_point_state  
0425				endm  
# End of macro CALLMONITOR
0425					endif 
0425 cd 07 07			call storage_findnextid 
0428			 
0428 cd 2d 0f			call ishlzero 
042b			;	ld a, l 
042b			;	add h 
042b			;	cp 0 
042b c8				ret z			; block not found so EOF 
042c			 
042c 11 81 fa			ld de, store_page 
042f cd d4 03			call storage_read_block 
0432			 
0432 3a 83 fa			ld a, (store_page+2)	 ; get extent count 
0435 6f				ld l, a 
0436 26 00			ld h, 0 
0438 c9			 	ret 
0439			 
0439			 
0439			; Write Block 
0439			; ----------- 
0439			; 
0439			; With current bank 
0439			;  
0439			; Get block number to write 
0439			; Write physical blocks starting at start block from buffer 
0439			  
0439			storage_write_block: 
0439				; TODO bank selection 
0439			 
0439				; for each of the physical blocks read it into the buffer 
0439 06 40			ld b, STORE_BLOCK_PHY 
043b			 
043b				if DEBUG_STORESE 
043b					DMARK "SWB" 
043b f5				push af  
043c 3a 50 04			ld a, (.dmark)  
043f 32 6e fe			ld (debug_mark),a  
0442 3a 51 04			ld a, (.dmark+1)  
0445 32 6f fe			ld (debug_mark+1),a  
0448 3a 52 04			ld a, (.dmark+2)  
044b 32 70 fe			ld (debug_mark+2),a  
044e 18 03			jr .pastdmark  
0450 ..			.dmark: db "SWB"  
0453 f1			.pastdmark: pop af  
0454			endm  
# End of macro DMARK
0454			 
0454					;push af 
0454					;ld a, 'W' 
0454					;ld (debug_mark),a 
0454					;pop af 
0454					CALLMONITOR 
0454 cd ab 18			call break_point_state  
0457				endm  
# End of macro CALLMONITOR
0457				endif 
0457			 
0457			; might not be working 
0457			;	call se_writepage 
0457			 
0457			;	ret 
0457			; 
0457			 
0457			 
0457			 
0457			.wl1:    
0457			 
0457				; read physical block at hl into de 
0457			        ; increment hl and de to next read position on exit 
0457			 
0457 e5				push hl 
0458 d5				push de	 
0459 c5				push bc 
045a 1a				ld a,(de) 
045b				;if DEBUG_STORESE 
045b			;		push af 
045b			;		ld a, 'W' 
045b			;		ld (debug_mark),a 
045b			;		pop af 
045b			;		CALLMONITOR 
045b			;	endif 
045b cd d9 01			call se_writebyte 
045e			;	call delay250ms 
045e 00				nop 
045f 00				nop 
0460 00				nop 
0461			;	if DEBUG_STORESE 
0461			;		push af 
0461			;		ld a, 'w' 
0461			;		ld (debug_mark),a 
0461			;		pop af 
0461			;		CALLMONITOR 
0461			;	endif 
0461 c1				pop bc 
0462 d1				pop de 
0463 e1				pop hl 
0464 23				inc hl 
0465 13				inc de 
0466			 
0466			 
0466 10 ef			djnz .wl1 
0468			 
0468				if DEBUG_STORESE 
0468					DMARK "SW2" 
0468 f5				push af  
0469 3a 7d 04			ld a, (.dmark)  
046c 32 6e fe			ld (debug_mark),a  
046f 3a 7e 04			ld a, (.dmark+1)  
0472 32 6f fe			ld (debug_mark+1),a  
0475 3a 7f 04			ld a, (.dmark+2)  
0478 32 70 fe			ld (debug_mark+2),a  
047b 18 03			jr .pastdmark  
047d ..			.dmark: db "SW2"  
0480 f1			.pastdmark: pop af  
0481			endm  
# End of macro DMARK
0481			 
0481					;push af 
0481					;ld a, 'W' 
0481					;ld (debug_mark),a 
0481					;pop af 
0481					CALLMONITOR 
0481 cd ab 18			call break_point_state  
0484				endm  
# End of macro CALLMONITOR
0484				endif 
0484 c9				ret	 
0485			 
0485			; Init bank 
0485			; --------- 
0485			; 
0485			; With current bank 
0485			; 
0485			; Setup block 0 config 
0485			;     Set 0 file id counter 
0485			;     Set formatted byte pattern 
0485			;     Zero out bank label 
0485			;      
0485			; For every logical block write 0-1 byte as null 
0485			 
0485			storage_get_block_0: 
0485			 
0485				; TODO check presence 
0485			 
0485				; get block 0 config 
0485			 
0485 21 00 00			ld hl, 0 
0488 11 81 fa			ld de, store_page 
048b cd d4 03			call storage_read_block 
048e			 
048e				if DEBUG_STORESE 
048e					DMARK "SB0" 
048e f5				push af  
048f 3a a3 04			ld a, (.dmark)  
0492 32 6e fe			ld (debug_mark),a  
0495 3a a4 04			ld a, (.dmark+1)  
0498 32 6f fe			ld (debug_mark+1),a  
049b 3a a5 04			ld a, (.dmark+2)  
049e 32 70 fe			ld (debug_mark+2),a  
04a1 18 03			jr .pastdmark  
04a3 ..			.dmark: db "SB0"  
04a6 f1			.pastdmark: pop af  
04a7			endm  
# End of macro DMARK
04a7 11 81 fa				ld de, store_page 
04aa			;		push af 
04aa			;		ld a, 'i' 
04aa			;		ld (debug_mark),a 
04aa			;		pop af 
04aa					CALLMONITOR 
04aa cd ab 18			call break_point_state  
04ad				endm  
# End of macro CALLMONITOR
04ad				endif 
04ad			 
04ad				; is this area formatted? 
04ad			 
04ad			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
04ad 2a 82 fa			ld hl, (store_page+1) 
04b0 3e 80			ld a,0x80 
04b2 bd				cp l 
04b3 20 22			jr nz, .ininotformatted 
04b5				; do a double check 
04b5 3e 27			ld a, 0x27 
04b7 bc				cp h 
04b8 20 1d			jr nz, .ininotformatted 
04ba			 
04ba				; formatted then 
04ba			 
04ba				if DEBUG_STORESE 
04ba					DMARK "SB1" 
04ba f5				push af  
04bb 3a cf 04			ld a, (.dmark)  
04be 32 6e fe			ld (debug_mark),a  
04c1 3a d0 04			ld a, (.dmark+1)  
04c4 32 6f fe			ld (debug_mark+1),a  
04c7 3a d1 04			ld a, (.dmark+2)  
04ca 32 70 fe			ld (debug_mark+2),a  
04cd 18 03			jr .pastdmark  
04cf ..			.dmark: db "SB1"  
04d2 f1			.pastdmark: pop af  
04d3			endm  
# End of macro DMARK
04d3					;push af 
04d3					;ld a, 'I' 
04d3					;ld (debug_mark),a 
04d3					;pop af 
04d3					CALLMONITOR 
04d3 cd ab 18			call break_point_state  
04d6				endm  
# End of macro CALLMONITOR
04d6				endif 
04d6 c9				ret 
04d7			 
04d7			.ininotformatted: 
04d7				; bank not formatted so poke various bits to make sure 
04d7			 
04d7				if DEBUG_STORESE 
04d7					DMARK "SB2" 
04d7 f5				push af  
04d8 3a ec 04			ld a, (.dmark)  
04db 32 6e fe			ld (debug_mark),a  
04de 3a ed 04			ld a, (.dmark+1)  
04e1 32 6f fe			ld (debug_mark+1),a  
04e4 3a ee 04			ld a, (.dmark+2)  
04e7 32 70 fe			ld (debug_mark+2),a  
04ea 18 03			jr .pastdmark  
04ec ..			.dmark: db "SB2"  
04ef f1			.pastdmark: pop af  
04f0			endm  
# End of macro DMARK
04f0					;push af 
04f0					;ld a, 'f' 
04f0					;ld (debug_mark),a 
04f0					;pop af 
04f0					CALLMONITOR 
04f0 cd ab 18			call break_point_state  
04f3				endm  
# End of macro CALLMONITOR
04f3				endif 
04f3			 
04f3 cd 10 0c			call storage_clear_page 
04f6			 
04f6 21 81 fa			ld hl, store_page 
04f9 3e 00			ld a, 0 
04fb				 
04fb 77				ld (hl),a   ; reset file counter 
04fc			 
04fc 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
04ff 22 82 fa		 	ld (store_page+1), hl	 
0502			 
0502				; set default label 
0502			 
0502 21 9e 05			ld hl, .defaultbanklabl 
0505 11 84 fa		 	ld de, store_page+3 
0508 01 0f 00			ld bc, 15 
050b ed b0			ldir 
050d			 
050d				; Append the current bank id 
050d 21 8d fa			ld hl, store_page+3+9 
0510 3a 67 fa			ld a, (spi_device_id) 
0513 77				ld (hl), a 
0514			 
0514				; save default page 0 
0514			 
0514 21 00 00			ld hl, 0 
0517 11 81 fa			ld de, store_page 
051a				if DEBUG_STORESE 
051a					DMARK "SB3" 
051a f5				push af  
051b 3a 2f 05			ld a, (.dmark)  
051e 32 6e fe			ld (debug_mark),a  
0521 3a 30 05			ld a, (.dmark+1)  
0524 32 6f fe			ld (debug_mark+1),a  
0527 3a 31 05			ld a, (.dmark+2)  
052a 32 70 fe			ld (debug_mark+2),a  
052d 18 03			jr .pastdmark  
052f ..			.dmark: db "SB3"  
0532 f1			.pastdmark: pop af  
0533			endm  
# End of macro DMARK
0533			;		push af 
0533			;		ld a, 'F' 
0533			;		ld (debug_mark),a 
0533			;		pop af 
0533					CALLMONITOR 
0533 cd ab 18			call break_point_state  
0536				endm  
# End of macro CALLMONITOR
0536				endif 
0536 cd 39 04			call storage_write_block 
0539				if DEBUG_STORESE 
0539					DMARK "SB4" 
0539 f5				push af  
053a 3a 4e 05			ld a, (.dmark)  
053d 32 6e fe			ld (debug_mark),a  
0540 3a 4f 05			ld a, (.dmark+1)  
0543 32 6f fe			ld (debug_mark+1),a  
0546 3a 50 05			ld a, (.dmark+2)  
0549 32 70 fe			ld (debug_mark+2),a  
054c 18 03			jr .pastdmark  
054e ..			.dmark: db "SB4"  
0551 f1			.pastdmark: pop af  
0552			endm  
# End of macro DMARK
0552			;		push af 
0552			;		ld a, '>' 
0552			;		ld (debug_mark),a 
0552			;		pop af 
0552					CALLMONITOR 
0552 cd ab 18			call break_point_state  
0555				endm  
# End of macro CALLMONITOR
0555				endif 
0555			 
0555 00				nop 
0556 00				nop 
0557 00				nop 
0558			 
0558				; now set 0 in every page to mark as a free block 
0558			 
0558 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
055a 21 40 00			ld hl, STORE_BLOCK_PHY 
055d			 
055d 3e 00		.setmark1:   	ld a,0 
055f e5					push hl 
0560 c5					push bc 
0561 cd d9 01				call se_writebyte 
0564 3e 0a			ld a, 10 
0566 cd 32 0c			call aDelayInMS 
0569 23				inc hl 
056a cd d9 01				call se_writebyte 
056d 3e 0a			ld a, 10 
056f cd 32 0c			call aDelayInMS 
0572 2b				dec hl 
0573 c1					pop bc 
0574 e1					pop hl 
0575 3e 40				ld a, STORE_BLOCK_PHY 
0577 cd 04 0f				call addatohl 
057a 10 e1				djnz .setmark1 
057c			 
057c 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
057e 3e 00		.setmark2:   	ld a,0 
0580 e5					push hl 
0581 c5					push bc 
0582 cd d9 01				call se_writebyte 
0585 3e 0a			ld a, 10 
0587 cd 32 0c			call aDelayInMS 
058a 23				inc hl 
058b cd d9 01				call se_writebyte 
058e 3e 0a			ld a, 10 
0590 cd 32 0c			call aDelayInMS 
0593 2b				dec hl 
0594 c1					pop bc 
0595 e1					pop hl 
0596 3e 40				ld a, STORE_BLOCK_PHY 
0598 cd 04 0f				call addatohl 
059b 10 e1				djnz .setmark2 
059d			 
059d					 
059d			 
059d			 
059d c9				ret 
059e			 
059e			 
059e			 
059e			 
059e .. 00		.defaultbanklabl:   db "BankLabel_",0 
05a9			 
05a9			 
05a9			 
05a9			; Label Bank 
05a9			; ---------- 
05a9			; 
05a9			; With current bank 
05a9			; Read block 0 
05a9			; Set label 
05a9			; Write block 0 
05a9			 
05a9			; label str pointer in hl 
05a9			 
05a9			storage_label:     
05a9			 
05a9				if DEBUG_STORESE 
05a9					DMARK "LBL" 
05a9 f5				push af  
05aa 3a be 05			ld a, (.dmark)  
05ad 32 6e fe			ld (debug_mark),a  
05b0 3a bf 05			ld a, (.dmark+1)  
05b3 32 6f fe			ld (debug_mark+1),a  
05b6 3a c0 05			ld a, (.dmark+2)  
05b9 32 70 fe			ld (debug_mark+2),a  
05bc 18 03			jr .pastdmark  
05be ..			.dmark: db "LBL"  
05c1 f1			.pastdmark: pop af  
05c2			endm  
# End of macro DMARK
05c2					CALLMONITOR 
05c2 cd ab 18			call break_point_state  
05c5				endm  
# End of macro CALLMONITOR
05c5				endif 
05c5			 
05c5 e5				push hl 
05c6			 
05c6 cd 85 04			call storage_get_block_0 
05c9			 
05c9				; set default label 
05c9			 
05c9 e1				pop hl 
05ca			 
05ca 11 84 fa		 	ld de, store_page+3 
05cd 01 0f 00			ld bc, 15 
05d0				if DEBUG_STORESE 
05d0					DMARK "LB3" 
05d0 f5				push af  
05d1 3a e5 05			ld a, (.dmark)  
05d4 32 6e fe			ld (debug_mark),a  
05d7 3a e6 05			ld a, (.dmark+1)  
05da 32 6f fe			ld (debug_mark+1),a  
05dd 3a e7 05			ld a, (.dmark+2)  
05e0 32 70 fe			ld (debug_mark+2),a  
05e3 18 03			jr .pastdmark  
05e5 ..			.dmark: db "LB3"  
05e8 f1			.pastdmark: pop af  
05e9			endm  
# End of macro DMARK
05e9					CALLMONITOR 
05e9 cd ab 18			call break_point_state  
05ec				endm  
# End of macro CALLMONITOR
05ec				endif 
05ec ed b0			ldir 
05ee				; save default page 0 
05ee			 
05ee 21 00 00			ld hl, 0 
05f1 11 81 fa			ld de, store_page 
05f4				if DEBUG_STORESE 
05f4					DMARK "LBW" 
05f4 f5				push af  
05f5 3a 09 06			ld a, (.dmark)  
05f8 32 6e fe			ld (debug_mark),a  
05fb 3a 0a 06			ld a, (.dmark+1)  
05fe 32 6f fe			ld (debug_mark+1),a  
0601 3a 0b 06			ld a, (.dmark+2)  
0604 32 70 fe			ld (debug_mark+2),a  
0607 18 03			jr .pastdmark  
0609 ..			.dmark: db "LBW"  
060c f1			.pastdmark: pop af  
060d			endm  
# End of macro DMARK
060d					CALLMONITOR 
060d cd ab 18			call break_point_state  
0610				endm  
# End of macro CALLMONITOR
0610				endif 
0610 cd 39 04			call storage_write_block 
0613			 
0613 c9				ret 
0614			 
0614			 
0614			 
0614			; Read Block 0 - Config 
0614			; --------------------- 
0614			; 
0614			; With current bank 
0614			; Call presence test 
0614			;    If not present format/init bank  
0614			; Read block 0  
0614			;  
0614			 
0614			 
0614			; Dir 
0614			; --- 
0614			; 
0614			; With current bank 
0614			; Load Block 0 Config 
0614			; Get max file id number 
0614			; For each logical block 
0614			;    Read block read byte 2 
0614			;      if first block of file 
0614			;         Display file name 
0614			;         Display type flags for file 
0614			;        
0614			 
0614			; moving to words as this requires stack control 
0614			 
0614			 
0614			; Delete File 
0614			; ----------- 
0614			; 
0614			; With current bank 
0614			; 
0614			; Load Block 0 Config 
0614			; Get max file id number 
0614			; For each logical block 
0614			;    Read block file id 
0614			;      If first block of file and dont have file id 
0614			;         if file to delete 
0614			;         Save file id 
0614			;         Null file id 
0614			;         Write this block back 
0614			;      If file id is one saved 
0614			;         Null file id 
0614			;         Write this block back 
0614			 
0614			 
0614			.se_done: 
0614 e1				pop hl 
0615 c9				ret 
0616			 
0616			storage_erase: 
0616			 
0616				; hl contains the file id 
0616			 
0616 5d				ld e, l 
0617 16 00			ld d, 0 
0619 21 40 00			ld hl, STORE_BLOCK_PHY 
061c					if DEBUG_FORTH_WORDS 
061c						DMARK "ERA" 
061c f5				push af  
061d 3a 31 06			ld a, (.dmark)  
0620 32 6e fe			ld (debug_mark),a  
0623 3a 32 06			ld a, (.dmark+1)  
0626 32 6f fe			ld (debug_mark+1),a  
0629 3a 33 06			ld a, (.dmark+2)  
062c 32 70 fe			ld (debug_mark+2),a  
062f 18 03			jr .pastdmark  
0631 ..			.dmark: db "ERA"  
0634 f1			.pastdmark: pop af  
0635			endm  
# End of macro DMARK
0635						CALLMONITOR 
0635 cd ab 18			call break_point_state  
0638				endm  
# End of macro CALLMONITOR
0638					endif 
0638 cd 07 07			call storage_findnextid 
063b cd 2d 0f			call ishlzero 
063e c8				ret z 
063f			 
063f e5				push hl 
0640			 
0640				; TODO check file not found 
0640			 
0640 11 81 fa			ld de, store_page 
0643 cd d4 03			call storage_read_block 
0646			 
0646 cd 2d 0f			call ishlzero 
0649 ca 14 06			jp z,.se_done 
064c			 
064c					if DEBUG_FORTH_WORDS 
064c						DMARK "ER1" 
064c f5				push af  
064d 3a 61 06			ld a, (.dmark)  
0650 32 6e fe			ld (debug_mark),a  
0653 3a 62 06			ld a, (.dmark+1)  
0656 32 6f fe			ld (debug_mark+1),a  
0659 3a 63 06			ld a, (.dmark+2)  
065c 32 70 fe			ld (debug_mark+2),a  
065f 18 03			jr .pastdmark  
0661 ..			.dmark: db "ER1"  
0664 f1			.pastdmark: pop af  
0665			endm  
# End of macro DMARK
0665						CALLMONITOR 
0665 cd ab 18			call break_point_state  
0668				endm  
# End of macro CALLMONITOR
0668					endif 
0668 3a 81 fa			ld a, (store_page)	; get file id 
066b 32 75 fa			ld (store_tmpid), a 
066e			 
066e 3a 83 fa			ld a, (store_page+2)    ; get count of extends 
0671 32 74 fa			ld (store_tmpext), a 
0674			 
0674				; wipe file header 
0674			 
0674 e1				pop hl 
0675 3e 00			ld a, 0 
0677 32 81 fa			ld (store_page), a 
067a 32 82 fa			ld (store_page+1),a 
067d 11 81 fa			ld de, store_page 
0680					if DEBUG_FORTH_WORDS 
0680						DMARK "ER2" 
0680 f5				push af  
0681 3a 95 06			ld a, (.dmark)  
0684 32 6e fe			ld (debug_mark),a  
0687 3a 96 06			ld a, (.dmark+1)  
068a 32 6f fe			ld (debug_mark+1),a  
068d 3a 97 06			ld a, (.dmark+2)  
0690 32 70 fe			ld (debug_mark+2),a  
0693 18 03			jr .pastdmark  
0695 ..			.dmark: db "ER2"  
0698 f1			.pastdmark: pop af  
0699			endm  
# End of macro DMARK
0699						CALLMONITOR 
0699 cd ab 18			call break_point_state  
069c				endm  
# End of macro CALLMONITOR
069c					endif 
069c cd 39 04			call storage_write_block 
069f			 
069f			 
069f				; wipe file extents 
069f			 
069f 3a 74 fa			ld a, (store_tmpext) 
06a2 47				ld b, a 
06a3			 
06a3			.eraext:	  
06a3 c5				push bc 
06a4			 
06a4 21 40 00			ld hl, STORE_BLOCK_PHY 
06a7 3a 75 fa			ld a,(store_tmpid) 
06aa 5f				ld e, a 
06ab 50				ld d, b	 
06ac					if DEBUG_FORTH_WORDS 
06ac						DMARK "ER3" 
06ac f5				push af  
06ad 3a c1 06			ld a, (.dmark)  
06b0 32 6e fe			ld (debug_mark),a  
06b3 3a c2 06			ld a, (.dmark+1)  
06b6 32 6f fe			ld (debug_mark+1),a  
06b9 3a c3 06			ld a, (.dmark+2)  
06bc 32 70 fe			ld (debug_mark+2),a  
06bf 18 03			jr .pastdmark  
06c1 ..			.dmark: db "ER3"  
06c4 f1			.pastdmark: pop af  
06c5			endm  
# End of macro DMARK
06c5						CALLMONITOR 
06c5 cd ab 18			call break_point_state  
06c8				endm  
# End of macro CALLMONITOR
06c8					endif 
06c8 cd 07 07			call storage_findnextid 
06cb cd 2d 0f			call ishlzero 
06ce ca 14 06			jp z,.se_done 
06d1			 
06d1 e5				push hl 
06d2 11 81 fa			ld de, store_page 
06d5 cd d4 03			call storage_read_block 
06d8			 
06d8				; free block	 
06d8			 
06d8 3e 00			ld a, 0 
06da 32 81 fa			ld (store_page), a 
06dd 32 82 fa			ld (store_page+1),a 
06e0 11 81 fa			ld de, store_page 
06e3 e1				pop hl 
06e4					if DEBUG_FORTH_WORDS 
06e4						DMARK "ER4" 
06e4 f5				push af  
06e5 3a f9 06			ld a, (.dmark)  
06e8 32 6e fe			ld (debug_mark),a  
06eb 3a fa 06			ld a, (.dmark+1)  
06ee 32 6f fe			ld (debug_mark+1),a  
06f1 3a fb 06			ld a, (.dmark+2)  
06f4 32 70 fe			ld (debug_mark+2),a  
06f7 18 03			jr .pastdmark  
06f9 ..			.dmark: db "ER4"  
06fc f1			.pastdmark: pop af  
06fd			endm  
# End of macro DMARK
06fd						CALLMONITOR 
06fd cd ab 18			call break_point_state  
0700				endm  
# End of macro CALLMONITOR
0700					endif 
0700 cd 39 04			call storage_write_block 
0703			 
0703 c1				pop bc 
0704 10 9d			djnz .eraext 
0706			 
0706 c9				ret 
0707			 
0707			 
0707			; Find Free Block 
0707			; --------------- 
0707			; 
0707			; With current bank 
0707			;  
0707			; From given starting logical block 
0707			;    Read block  
0707			;    If no file id 
0707			;         Return block id 
0707			 
0707			 
0707			; hl starting page number 
0707			; hl contains free page number or zero if no pages free 
0707			; e contains the file id to locate 
0707			; d contains the block number 
0707			 
0707			; TODO change to find file id and use zero for free block 
0707			 
0707			storage_findnextid: 
0707			 
0707				; now locate first 0 page to mark as a free block 
0707			 
0707 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0709			;	ld hl, STORE_BLOCK_PHY 
0709			 
0709					if DEBUG_FORTH_WORDS 
0709					DMARK "FNI" 
0709 f5				push af  
070a 3a 1e 07			ld a, (.dmark)  
070d 32 6e fe			ld (debug_mark),a  
0710 3a 1f 07			ld a, (.dmark+1)  
0713 32 6f fe			ld (debug_mark+1),a  
0716 3a 20 07			ld a, (.dmark+2)  
0719 32 70 fe			ld (debug_mark+2),a  
071c 18 03			jr .pastdmark  
071e ..			.dmark: db "FNI"  
0721 f1			.pastdmark: pop af  
0722			endm  
# End of macro DMARK
0722						CALLMONITOR 
0722 cd ab 18			call break_point_state  
0725				endm  
# End of macro CALLMONITOR
0725					endif 
0725			.ff1:   	 
0725 e5					push hl 
0726 c5					push bc 
0727 d5					push de 
0728 cd 7b 02				call se_readbyte 
072b 5f					ld e,a 
072c 23					inc hl 
072d cd 7b 02				call se_readbyte 
0730 57					ld d, a 
0731 e1					pop hl 
0732 e5					push hl 
0733 cd 22 0f				call cmp16 
0736 28 49				jr z, .fffound 
0738			 
0738 d1					pop de 
0739 c1					pop bc 
073a e1					pop hl 
073b			 
073b					; is found? 
073b					;cp e 
073b					;ret z 
073b			 
073b 3e 40				ld a, STORE_BLOCK_PHY 
073d cd 04 0f				call addatohl 
0740 10 e3				djnz .ff1 
0742			 
0742 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0744			.ff2:   	 
0744			 
0744 e5					push hl 
0745 c5					push bc 
0746 d5					push de 
0747 cd 7b 02				call se_readbyte 
074a 5f					ld e,a 
074b 23					inc hl 
074c cd 7b 02				call se_readbyte 
074f 57					ld d, a 
0750			 
0750 e1					pop hl 
0751 e5					push hl 
0752 cd 22 0f				call cmp16 
0755 28 2a				jr z, .fffound 
0757			 
0757 d1					pop de 
0758 c1					pop bc 
0759 e1					pop hl 
075a					; is found? 
075a					;cp e 
075a					;ret z 
075a			 
075a 3e 40				ld a, STORE_BLOCK_PHY 
075c cd 04 0f				call addatohl 
075f 10 e3				djnz .ff2 
0761			 
0761			 
0761					if DEBUG_FORTH_WORDS 
0761					DMARK "FN-" 
0761 f5				push af  
0762 3a 76 07			ld a, (.dmark)  
0765 32 6e fe			ld (debug_mark),a  
0768 3a 77 07			ld a, (.dmark+1)  
076b 32 6f fe			ld (debug_mark+1),a  
076e 3a 78 07			ld a, (.dmark+2)  
0771 32 70 fe			ld (debug_mark+2),a  
0774 18 03			jr .pastdmark  
0776 ..			.dmark: db "FN-"  
0779 f1			.pastdmark: pop af  
077a			endm  
# End of macro DMARK
077a					;	push af 
077a					;	ld a, 'n' 
077a					;	ld (debug_mark),a 
077a					;	pop af 
077a						CALLMONITOR 
077a cd ab 18			call break_point_state  
077d				endm  
# End of macro CALLMONITOR
077d					endif 
077d				; no free marks! 
077d 21 00 00				ld hl, 0 
0780 c9				ret 
0781			.fffound: 
0781				 
0781			 
0781 d1					pop de 
0782 c1					pop bc 
0783 e1					pop hl 
0784					if DEBUG_FORTH_WORDS 
0784					DMARK "FNF" 
0784 f5				push af  
0785 3a 99 07			ld a, (.dmark)  
0788 32 6e fe			ld (debug_mark),a  
078b 3a 9a 07			ld a, (.dmark+1)  
078e 32 6f fe			ld (debug_mark+1),a  
0791 3a 9b 07			ld a, (.dmark+2)  
0794 32 70 fe			ld (debug_mark+2),a  
0797 18 03			jr .pastdmark  
0799 ..			.dmark: db "FNF"  
079c f1			.pastdmark: pop af  
079d			endm  
# End of macro DMARK
079d					;	push af 
079d					;	ld a, 'n' 
079d					;	ld (debug_mark),a 
079d					;	pop af 
079d						CALLMONITOR 
079d cd ab 18			call break_point_state  
07a0				endm  
# End of macro CALLMONITOR
07a0					endif 
07a0 c9				ret 
07a1			 
07a1			 
07a1			 
07a1			; Free Space 
07a1			; ---------- 
07a1			; 
07a1			; With current bank 
07a1			; 
07a1			; Set block count to zero 
07a1			; Starting with first logical block 
07a1			;      Find free block  
07a1			;      If block id given, increment block count 
07a1			; 
07a1			;  
07a1			 
07a1			 
07a1			; hl contains count of free blocks 
07a1			 
07a1			storage_freeblocks: 
07a1			 
07a1				; now locate first 0 page to mark as a free block 
07a1			 
07a1 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07a3 21 40 00			ld hl, STORE_BLOCK_PHY 
07a6 11 00 00			ld de, 0 
07a9			 
07a9			.fb1:   	 
07a9 e5					push hl 
07aa c5					push bc 
07ab d5					push de 
07ac cd 7b 02				call se_readbyte 
07af d1					pop de 
07b0 c1					pop bc 
07b1 e1					pop hl 
07b2			 
07b2					; is free? 
07b2 fe 00				cp 0 
07b4 20 01				jr nz, .ff1cont 
07b6 13					inc de 
07b7			 
07b7			.ff1cont: 
07b7			 
07b7			 
07b7 3e 40				ld a, STORE_BLOCK_PHY 
07b9 cd 04 0f				call addatohl 
07bc 10 eb				djnz .fb1 
07be			 
07be 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07c0			.fb2:   	 
07c0 e5					push hl 
07c1 c5					push bc 
07c2 d5					push de 
07c3 cd 7b 02				call se_readbyte 
07c6 d1					pop de 
07c7 c1					pop bc 
07c8 e1					pop hl 
07c9			 
07c9					; is free? 
07c9 fe 00				cp 0 
07cb 20 01				jr nz, .ff2cont 
07cd 13					inc de 
07ce			 
07ce			.ff2cont: 
07ce			 
07ce 3e 40				ld a, STORE_BLOCK_PHY 
07d0 cd 04 0f				call addatohl 
07d3 10 eb				djnz .fb2 
07d5			 
07d5 eb				ex de, hl 
07d6 c9				ret 
07d7			 
07d7			; Get File ID 
07d7			; ----------- 
07d7			; 
07d7			; With current bank 
07d7			;  
07d7			; Load Block 0 Config 
07d7			; Get max file id number 
07d7			; For each logical block 
07d7			;    Read block file id 
07d7			;      If first block of file and dont have file id 
07d7			;         if file get id and exit 
07d7			 
07d7			 
07d7			 
07d7			 
07d7			; Create File 
07d7			; ----------- 
07d7			; 
07d7			; With current bank  
07d7			; Load Block 0 Config 
07d7			; Get max file id number 
07d7			; Increment file id number 
07d7			; Save Config 
07d7			; Find free block 
07d7			; Set buffer with file name and file id 
07d7			; Write buffer to free block  
07d7			 
07d7			 
07d7			; hl point to file name 
07d7			; hl returns file id 
07d7			 
07d7			; file format: 
07d7			; byte 0 - file id 
07d7			; byte 1 - extent number 
07d7			; byte 2-> data 
07d7			 
07d7			; format for extent number 0: 
07d7			; 
07d7			; byte 0 - file id 
07d7			; byte 1 - extent 0 
07d7			; byte 2 - extent count 
07d7			; byte 3 -> file name and meta data 
07d7			 
07d7			 
07d7			storage_create: 
07d7				if DEBUG_STORESE 
07d7					DMARK "SCR" 
07d7 f5				push af  
07d8 3a ec 07			ld a, (.dmark)  
07db 32 6e fe			ld (debug_mark),a  
07de 3a ed 07			ld a, (.dmark+1)  
07e1 32 6f fe			ld (debug_mark+1),a  
07e4 3a ee 07			ld a, (.dmark+2)  
07e7 32 70 fe			ld (debug_mark+2),a  
07ea 18 03			jr .pastdmark  
07ec ..			.dmark: db "SCR"  
07ef f1			.pastdmark: pop af  
07f0			endm  
# End of macro DMARK
07f0					CALLMONITOR 
07f0 cd ab 18			call break_point_state  
07f3				endm  
# End of macro CALLMONITOR
07f3				endif 
07f3			 
07f3 e5				push hl		; save file name pointer 
07f4			 
07f4 cd 85 04			call storage_get_block_0 
07f7			 
07f7 3a 81 fa			ld a,(store_page)	; get current file id 
07fa 3c				inc a 
07fb 32 81 fa			ld (store_page),a 
07fe				 
07fe 32 75 fa			ld (store_tmpid),a			; save id 
0801			 
0801 21 00 00			ld hl, 0 
0804 11 81 fa			ld de, store_page 
0807				if DEBUG_STORESE 
0807					DMARK "SCw" 
0807 f5				push af  
0808 3a 1c 08			ld a, (.dmark)  
080b 32 6e fe			ld (debug_mark),a  
080e 3a 1d 08			ld a, (.dmark+1)  
0811 32 6f fe			ld (debug_mark+1),a  
0814 3a 1e 08			ld a, (.dmark+2)  
0817 32 70 fe			ld (debug_mark+2),a  
081a 18 03			jr .pastdmark  
081c ..			.dmark: db "SCw"  
081f f1			.pastdmark: pop af  
0820			endm  
# End of macro DMARK
0820					CALLMONITOR 
0820 cd ab 18			call break_point_state  
0823				endm  
# End of macro CALLMONITOR
0823				endif 
0823 cd 39 04			call storage_write_block	 ; save update 
0826			 
0826				if DEBUG_STORESE 
0826 11 81 fa				ld de, store_page 
0829					DMARK "SCC" 
0829 f5				push af  
082a 3a 3e 08			ld a, (.dmark)  
082d 32 6e fe			ld (debug_mark),a  
0830 3a 3f 08			ld a, (.dmark+1)  
0833 32 6f fe			ld (debug_mark+1),a  
0836 3a 40 08			ld a, (.dmark+2)  
0839 32 70 fe			ld (debug_mark+2),a  
083c 18 03			jr .pastdmark  
083e ..			.dmark: db "SCC"  
0841 f1			.pastdmark: pop af  
0842			endm  
# End of macro DMARK
0842					CALLMONITOR 
0842 cd ab 18			call break_point_state  
0845				endm  
# End of macro CALLMONITOR
0845				endif 
0845				;  
0845				 
0845 21 40 00			ld hl, STORE_BLOCK_PHY 
0848 11 00 00			ld de, 0 
084b cd 07 07			call storage_findnextid 
084e			 
084e 22 6c fa			ld (store_tmppageid), hl    ; save page to use  
0851			 
0851				; TODO detect 0 = no spare blocks 
0851			 
0851				; hl now contains the free page to use for the file header page 
0851			 
0851				if DEBUG_STORESE 
0851				DMARK "SCF" 
0851 f5				push af  
0852 3a 66 08			ld a, (.dmark)  
0855 32 6e fe			ld (debug_mark),a  
0858 3a 67 08			ld a, (.dmark+1)  
085b 32 6f fe			ld (debug_mark+1),a  
085e 3a 68 08			ld a, (.dmark+2)  
0861 32 70 fe			ld (debug_mark+2),a  
0864 18 03			jr .pastdmark  
0866 ..			.dmark: db "SCF"  
0869 f1			.pastdmark: pop af  
086a			endm  
# End of macro DMARK
086a					CALLMONITOR 
086a cd ab 18			call break_point_state  
086d				endm  
# End of macro CALLMONITOR
086d				endif 
086d			 
086d 22 6c fa			ld (store_tmppageid), hl 
0870				 
0870 3a 75 fa			ld a,(store_tmpid)    ; get file id 
0873			;	ld a, (store_filecache)			; save to cache 
0873			 
0873 32 81 fa			ld (store_page),a    ; set page id 
0876 3e 00			ld a, 0			 ; extent 0 is file header 
0878 32 82 fa			ld (store_page+1), a   ; set file extent 
087b			 
087b 32 83 fa			ld (store_page+2), a   ; extent count for the file 
087e			 
087e			;	inc hl 		; init block 0 of file 
087e			;	inc hl   		; skip file and extent id 
087e			 ;       ld a, 0 
087e			;	ld (hl),a 
087e			;	ld a, (store_filecache+1)  	; save to cache 
087e			 
087e			;	inc hl    ; file name 
087e				 
087e				 
087e 11 84 fa			ld de, store_page+3    ; get buffer for term string to use as file name 
0881				if DEBUG_STORESE 
0881					DMARK "SCc" 
0881 f5				push af  
0882 3a 96 08			ld a, (.dmark)  
0885 32 6e fe			ld (debug_mark),a  
0888 3a 97 08			ld a, (.dmark+1)  
088b 32 6f fe			ld (debug_mark+1),a  
088e 3a 98 08			ld a, (.dmark+2)  
0891 32 70 fe			ld (debug_mark+2),a  
0894 18 03			jr .pastdmark  
0896 ..			.dmark: db "SCc"  
0899 f1			.pastdmark: pop af  
089a			endm  
# End of macro DMARK
089a					CALLMONITOR 
089a cd ab 18			call break_point_state  
089d				endm  
# End of macro CALLMONITOR
089d				endif 
089d e1				pop hl    ; get zero term string 
089e e5				push hl 
089f 3e 00			ld a, 0 
08a1 cd 6d 13			call strlent 
08a4 23				inc hl   ; cover zero term 
08a5 06 00			ld b,0 
08a7 4d				ld c,l 
08a8 e1				pop hl 
08a9				;ex de, hl 
08a9				if DEBUG_STORESE 
08a9					DMARK "SCa" 
08a9 f5				push af  
08aa 3a be 08			ld a, (.dmark)  
08ad 32 6e fe			ld (debug_mark),a  
08b0 3a bf 08			ld a, (.dmark+1)  
08b3 32 6f fe			ld (debug_mark+1),a  
08b6 3a c0 08			ld a, (.dmark+2)  
08b9 32 70 fe			ld (debug_mark+2),a  
08bc 18 03			jr .pastdmark  
08be ..			.dmark: db "SCa"  
08c1 f1			.pastdmark: pop af  
08c2			endm  
# End of macro DMARK
08c2					;push af 
08c2					;ld a, 'a' 
08c2					;ld (debug_mark),a 
08c2					;pop af 
08c2					CALLMONITOR 
08c2 cd ab 18			call break_point_state  
08c5				endm  
# End of macro CALLMONITOR
08c5				endif 
08c5 ed b0			ldir    ; copy zero term string 
08c7				if DEBUG_STORESE 
08c7					DMARK "SCA" 
08c7 f5				push af  
08c8 3a dc 08			ld a, (.dmark)  
08cb 32 6e fe			ld (debug_mark),a  
08ce 3a dd 08			ld a, (.dmark+1)  
08d1 32 6f fe			ld (debug_mark+1),a  
08d4 3a de 08			ld a, (.dmark+2)  
08d7 32 70 fe			ld (debug_mark+2),a  
08da 18 03			jr .pastdmark  
08dc ..			.dmark: db "SCA"  
08df f1			.pastdmark: pop af  
08e0			endm  
# End of macro DMARK
08e0					CALLMONITOR 
08e0 cd ab 18			call break_point_state  
08e3				endm  
# End of macro CALLMONITOR
08e3				endif 
08e3			 
08e3				; write file header page 
08e3			 
08e3 2a 6c fa			ld hl,(store_tmppageid) 
08e6 11 81 fa			ld de, store_page 
08e9				if DEBUG_STORESE 
08e9					DMARK "SCb" 
08e9 f5				push af  
08ea 3a fe 08			ld a, (.dmark)  
08ed 32 6e fe			ld (debug_mark),a  
08f0 3a ff 08			ld a, (.dmark+1)  
08f3 32 6f fe			ld (debug_mark+1),a  
08f6 3a 00 09			ld a, (.dmark+2)  
08f9 32 70 fe			ld (debug_mark+2),a  
08fc 18 03			jr .pastdmark  
08fe ..			.dmark: db "SCb"  
0901 f1			.pastdmark: pop af  
0902			endm  
# End of macro DMARK
0902					;push af 
0902					;ld a, 'b' 
0902					;ld (debug_mark),a 
0902					;pop af 
0902					CALLMONITOR 
0902 cd ab 18			call break_point_state  
0905				endm  
# End of macro CALLMONITOR
0905				endif 
0905 cd 39 04			call storage_write_block 
0908			 
0908 3a 75 fa			ld a, (store_tmpid) 
090b 6f				ld l, a 
090c 26 00			ld h,0 
090e				if DEBUG_STORESE 
090e					DMARK "SCz" 
090e f5				push af  
090f 3a 23 09			ld a, (.dmark)  
0912 32 6e fe			ld (debug_mark),a  
0915 3a 24 09			ld a, (.dmark+1)  
0918 32 6f fe			ld (debug_mark+1),a  
091b 3a 25 09			ld a, (.dmark+2)  
091e 32 70 fe			ld (debug_mark+2),a  
0921 18 03			jr .pastdmark  
0923 ..			.dmark: db "SCz"  
0926 f1			.pastdmark: pop af  
0927			endm  
# End of macro DMARK
0927					CALLMONITOR 
0927 cd ab 18			call break_point_state  
092a				endm  
# End of macro CALLMONITOR
092a				endif 
092a c9				ret 
092b				 
092b			 
092b			 
092b			; 
092b			; Read File 
092b			; 
092b			; h - file id to locate 
092b			; l - extent to locate 
092b			; de - pointer to string to read into 
092b			; 
092b			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
092b			 
092b			.sr_fail: 
092b d1				pop de 
092c c9				ret 
092d			 
092d			storage_read: 
092d			 
092d			 
092d d5				push de 
092e			 
092e			; TODO BUG the above push is it popped before the RET Z? 
092e			 
092e			; TODO how to handle multiple part blocks 
092e			 
092e				; locate file extent to read 
092e			 
092e 5c				ld e, h 
092f 55				ld d, l 
0930			 
0930			.srext: 
0930 22 7f fa			ld (store_readptr), hl     ; save the current extent to load 
0933 ed 53 7d fa		ld (store_readbuf), de     ; save the current buffer to load in to 
0937			 
0937 21 40 00			ld hl, STORE_BLOCK_PHY 
093a				if DEBUG_STORESE 
093a					DMARK "sre" 
093a f5				push af  
093b 3a 4f 09			ld a, (.dmark)  
093e 32 6e fe			ld (debug_mark),a  
0941 3a 50 09			ld a, (.dmark+1)  
0944 32 6f fe			ld (debug_mark+1),a  
0947 3a 51 09			ld a, (.dmark+2)  
094a 32 70 fe			ld (debug_mark+2),a  
094d 18 03			jr .pastdmark  
094f ..			.dmark: db "sre"  
0952 f1			.pastdmark: pop af  
0953			endm  
# End of macro DMARK
0953					CALLMONITOR 
0953 cd ab 18			call break_point_state  
0956				endm  
# End of macro CALLMONITOR
0956				endif 
0956 cd 07 07			call storage_findnextid 
0959			 
0959				if DEBUG_STORESE 
0959					DMARK "srf" 
0959 f5				push af  
095a 3a 6e 09			ld a, (.dmark)  
095d 32 6e fe			ld (debug_mark),a  
0960 3a 6f 09			ld a, (.dmark+1)  
0963 32 6f fe			ld (debug_mark+1),a  
0966 3a 70 09			ld a, (.dmark+2)  
0969 32 70 fe			ld (debug_mark+2),a  
096c 18 03			jr .pastdmark  
096e ..			.dmark: db "srf"  
0971 f1			.pastdmark: pop af  
0972			endm  
# End of macro DMARK
0972					CALLMONITOR 
0972 cd ab 18			call break_point_state  
0975				endm  
# End of macro CALLMONITOR
0975				endif 
0975 cd 2d 0f			call ishlzero 
0978			;	ld a, l 
0978			;	add h 
0978			;	cp 0 
0978 28 b1			jr z,.sr_fail			; block not found so EOF 
097a			 
097a				; save current address for use by higher level words etc 
097a			 
097a 22 72 fa			ld (store_openaddr),hl 
097d			 
097d			 
097d				; hl contains page number to load 
097d d1				pop de   ; get storage 
097e ed 53 7d fa		ld (store_readbuf), de     ; current buffer to load in to 
0982 d5				push de 
0983				if DEBUG_STORESE 
0983					DMARK "srg" 
0983 f5				push af  
0984 3a 98 09			ld a, (.dmark)  
0987 32 6e fe			ld (debug_mark),a  
098a 3a 99 09			ld a, (.dmark+1)  
098d 32 6f fe			ld (debug_mark+1),a  
0990 3a 9a 09			ld a, (.dmark+2)  
0993 32 70 fe			ld (debug_mark+2),a  
0996 18 03			jr .pastdmark  
0998 ..			.dmark: db "srg"  
099b f1			.pastdmark: pop af  
099c			endm  
# End of macro DMARK
099c					CALLMONITOR 
099c cd ab 18			call break_point_state  
099f				endm  
# End of macro CALLMONITOR
099f				endif 
099f cd d4 03			call storage_read_block 
09a2			 
09a2				; if this a continuation read??? 
09a2			 
09a2 2a 7d fa			ld hl, (store_readbuf)     ; current buffer to load in to 
09a5			 
09a5 3e 3f			ld a, STORE_BLOCK_PHY-1 
09a7 cd 04 0f			call addatohl 
09aa 7e				ld a,(hl) 
09ab fe 00			cp 0 
09ad 28 02			jr z, .markiscont 
09af 3e ff			ld a, 255 
09b1			 
09b1			.markiscont: 
09b1 32 74 fa			ld (store_readcont), a 
09b4			 
09b4				if DEBUG_STORESE 
09b4					DMARK "srC" 
09b4 f5				push af  
09b5 3a c9 09			ld a, (.dmark)  
09b8 32 6e fe			ld (debug_mark),a  
09bb 3a ca 09			ld a, (.dmark+1)  
09be 32 6f fe			ld (debug_mark+1),a  
09c1 3a cb 09			ld a, (.dmark+2)  
09c4 32 70 fe			ld (debug_mark+2),a  
09c7 18 03			jr .pastdmark  
09c9 ..			.dmark: db "srC"  
09cc f1			.pastdmark: pop af  
09cd			endm  
# End of macro DMARK
09cd					CALLMONITOR 
09cd cd ab 18			call break_point_state  
09d0				endm  
# End of macro CALLMONITOR
09d0				endif 
09d0				; only short reads enabled 
09d0			 
09d0 3a 7c fa			ld a, (store_longread) 
09d3 fe 00			cp 0 
09d5 ca a2 0a			jp z, .readdone 
09d8			 
09d8			; TODO if block has no zeros then need to read next block  
09d8			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
09d8			; check last byte of physical block. 
09d8			; if not zero then the next block needs to be loaded 
09d8			 
09d8			 
09d8 2a 7d fa			ld hl, (store_readbuf)     ; current buffer to load in to 
09db			 
09db 3e 3f			ld a, STORE_BLOCK_PHY-1 
09dd cd 04 0f			call addatohl 
09e0				;dec hl 
09e0 7e				ld a,(hl) 
09e1				if DEBUG_STORESE 
09e1					DMARK "sr?" 
09e1 f5				push af  
09e2 3a f6 09			ld a, (.dmark)  
09e5 32 6e fe			ld (debug_mark),a  
09e8 3a f7 09			ld a, (.dmark+1)  
09eb 32 6f fe			ld (debug_mark+1),a  
09ee 3a f8 09			ld a, (.dmark+2)  
09f1 32 70 fe			ld (debug_mark+2),a  
09f4 18 03			jr .pastdmark  
09f6 ..			.dmark: db "sr?"  
09f9 f1			.pastdmark: pop af  
09fa			endm  
# End of macro DMARK
09fa					CALLMONITOR 
09fa cd ab 18			call break_point_state  
09fd				endm  
# End of macro CALLMONITOR
09fd				endif 
09fd fe 00			cp 0 
09ff ca a2 0a			jp z, .readdone 
0a02			 
0a02				; last byte is not zero so there is more in the next extent. Load it on the end.	 
0a02			 
0a02 23				inc hl 
0a03			 
0a03 22 7d fa			ld (store_readbuf), hl     ; save the current buffer to load in to 
0a06			 
0a06 ed 5b 7f fa		ld de, (store_readptr)     ; save the current extent to load 
0a0a			 
0a0a eb				ex de, hl 
0a0b			 
0a0b				; next ext 
0a0b			 
0a0b 23				inc hl 
0a0c 22 7f fa			ld  (store_readptr), hl     ; save the current extent to load 
0a0f			 
0a0f				if DEBUG_STORESE 
0a0f					DMARK "sF2" 
0a0f f5				push af  
0a10 3a 24 0a			ld a, (.dmark)  
0a13 32 6e fe			ld (debug_mark),a  
0a16 3a 25 0a			ld a, (.dmark+1)  
0a19 32 6f fe			ld (debug_mark+1),a  
0a1c 3a 26 0a			ld a, (.dmark+2)  
0a1f 32 70 fe			ld (debug_mark+2),a  
0a22 18 03			jr .pastdmark  
0a24 ..			.dmark: db "sF2"  
0a27 f1			.pastdmark: pop af  
0a28			endm  
# End of macro DMARK
0a28					CALLMONITOR 
0a28 cd ab 18			call break_point_state  
0a2b				endm  
# End of macro CALLMONITOR
0a2b				endif 
0a2b			 
0a2b				; get and load block 
0a2b			 
0a2b cd 07 07			call storage_findnextid 
0a2e			 
0a2e				if DEBUG_STORESE 
0a2e					DMARK "sf2" 
0a2e f5				push af  
0a2f 3a 43 0a			ld a, (.dmark)  
0a32 32 6e fe			ld (debug_mark),a  
0a35 3a 44 0a			ld a, (.dmark+1)  
0a38 32 6f fe			ld (debug_mark+1),a  
0a3b 3a 45 0a			ld a, (.dmark+2)  
0a3e 32 70 fe			ld (debug_mark+2),a  
0a41 18 03			jr .pastdmark  
0a43 ..			.dmark: db "sf2"  
0a46 f1			.pastdmark: pop af  
0a47			endm  
# End of macro DMARK
0a47					CALLMONITOR 
0a47 cd ab 18			call break_point_state  
0a4a				endm  
# End of macro CALLMONITOR
0a4a				endif 
0a4a cd 2d 0f			call ishlzero 
0a4d			;	ld a, l 
0a4d			;	add h 
0a4d			;	cp 0 
0a4d ca 2b 09			jp z,.sr_fail			; block not found so EOF 
0a50				 
0a50				; save current address for use by higher level words etc 
0a50			 
0a50 22 72 fa			ld (store_openaddr),hl 
0a53			 
0a53 cd d4 03			call storage_read_block 
0a56			 
0a56				; on a continuation block, we now have the file id and ext in the middle of the block 
0a56				; we need to pull everything back  
0a56			 
0a56 ed 5b 7d fa		ld de, (store_readbuf)     ; current buffer to nudge into 
0a5a 2a 7d fa			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0a5d 23				inc hl 
0a5e 23				inc hl     ; skip id and ext 
0a5f 01 40 00			ld bc, STORE_BLOCK_PHY 
0a62				if DEBUG_STORESE 
0a62					DMARK "SR<" 
0a62 f5				push af  
0a63 3a 77 0a			ld a, (.dmark)  
0a66 32 6e fe			ld (debug_mark),a  
0a69 3a 78 0a			ld a, (.dmark+1)  
0a6c 32 6f fe			ld (debug_mark+1),a  
0a6f 3a 79 0a			ld a, (.dmark+2)  
0a72 32 70 fe			ld (debug_mark+2),a  
0a75 18 03			jr .pastdmark  
0a77 ..			.dmark: db "SR<"  
0a7a f1			.pastdmark: pop af  
0a7b			endm  
# End of macro DMARK
0a7b					CALLMONITOR 
0a7b cd ab 18			call break_point_state  
0a7e				endm  
# End of macro CALLMONITOR
0a7e				endif 
0a7e ed b0			ldir     ; copy data 
0a80			 
0a80				; move the pointer back and pretend we have a full buffer for next recheck 
0a80			 
0a80 1b				dec de 
0a81 1b				dec de 
0a82			 
0a82			; TODO do pop below now short circuit loop????? 
0a82 c1				pop bc     ; get rid of spare de on stack 
0a83				if DEBUG_STORESE 
0a83					DMARK "SR>" 
0a83 f5				push af  
0a84 3a 98 0a			ld a, (.dmark)  
0a87 32 6e fe			ld (debug_mark),a  
0a8a 3a 99 0a			ld a, (.dmark+1)  
0a8d 32 6f fe			ld (debug_mark+1),a  
0a90 3a 9a 0a			ld a, (.dmark+2)  
0a93 32 70 fe			ld (debug_mark+2),a  
0a96 18 03			jr .pastdmark  
0a98 ..			.dmark: db "SR>"  
0a9b f1			.pastdmark: pop af  
0a9c			endm  
# End of macro DMARK
0a9c					CALLMONITOR 
0a9c cd ab 18			call break_point_state  
0a9f				endm  
# End of macro CALLMONITOR
0a9f				endif 
0a9f c3 30 09			jp .srext 
0aa2			 
0aa2			 
0aa2			 
0aa2			 
0aa2			 
0aa2			.readdone:		 
0aa2 e1				pop hl 		 ; return start of data to show as not EOF 
0aa3 23				inc hl   ; past file id 
0aa4 23				inc hl   ; past ext 
0aa5				if DEBUG_STORESE 
0aa5					DMARK "SRe" 
0aa5 f5				push af  
0aa6 3a ba 0a			ld a, (.dmark)  
0aa9 32 6e fe			ld (debug_mark),a  
0aac 3a bb 0a			ld a, (.dmark+1)  
0aaf 32 6f fe			ld (debug_mark+1),a  
0ab2 3a bc 0a			ld a, (.dmark+2)  
0ab5 32 70 fe			ld (debug_mark+2),a  
0ab8 18 03			jr .pastdmark  
0aba ..			.dmark: db "SRe"  
0abd f1			.pastdmark: pop af  
0abe			endm  
# End of macro DMARK
0abe					CALLMONITOR 
0abe cd ab 18			call break_point_state  
0ac1				endm  
# End of macro CALLMONITOR
0ac1				endif 
0ac1 c9					ret 
0ac2			 
0ac2			 
0ac2			 
0ac2			; 
0ac2			; Append File 
0ac2			; 
0ac2			; hl - file id to locate 
0ac2			; de - pointer to (multi block) string to write 
0ac2			 
0ac2			.sa_notfound: 
0ac2 d1				pop de 
0ac3 c9				ret 
0ac4			 
0ac4			 
0ac4			storage_append: 
0ac4				; hl -  file id to append to 
0ac4				; de - string to append 
0ac4			 
0ac4 d5				push de 
0ac5				 
0ac5				if DEBUG_STORESE 
0ac5					DMARK "AP1" 
0ac5 f5				push af  
0ac6 3a da 0a			ld a, (.dmark)  
0ac9 32 6e fe			ld (debug_mark),a  
0acc 3a db 0a			ld a, (.dmark+1)  
0acf 32 6f fe			ld (debug_mark+1),a  
0ad2 3a dc 0a			ld a, (.dmark+2)  
0ad5 32 70 fe			ld (debug_mark+2),a  
0ad8 18 03			jr .pastdmark  
0ada ..			.dmark: db "AP1"  
0add f1			.pastdmark: pop af  
0ade			endm  
# End of macro DMARK
0ade					CALLMONITOR 
0ade cd ab 18			call break_point_state  
0ae1				endm  
# End of macro CALLMONITOR
0ae1				endif 
0ae1			 
0ae1 7d				ld a, l 
0ae2 32 75 fa			ld (store_tmpid), a 
0ae5			 
0ae5				; get file header  
0ae5			 
0ae5 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
0ae7 3a 75 fa			ld a, (store_tmpid) 
0aea 5f				ld e, a 
0aeb			 
0aeb 21 40 00				ld hl, STORE_BLOCK_PHY 
0aee cd 07 07				call storage_findnextid 
0af1			 
0af1 cd 2d 0f			call ishlzero 
0af4 28 cc			jr z, .sa_notfound 
0af6			 
0af6 22 6c fa			ld (store_tmppageid), hl 
0af9			 
0af9				; TODO handle file id not found 
0af9			 
0af9				if DEBUG_STORESE 
0af9					DMARK "AP2" 
0af9 f5				push af  
0afa 3a 0e 0b			ld a, (.dmark)  
0afd 32 6e fe			ld (debug_mark),a  
0b00 3a 0f 0b			ld a, (.dmark+1)  
0b03 32 6f fe			ld (debug_mark+1),a  
0b06 3a 10 0b			ld a, (.dmark+2)  
0b09 32 70 fe			ld (debug_mark+2),a  
0b0c 18 03			jr .pastdmark  
0b0e ..			.dmark: db "AP2"  
0b11 f1			.pastdmark: pop af  
0b12			endm  
# End of macro DMARK
0b12					CALLMONITOR 
0b12 cd ab 18			call break_point_state  
0b15				endm  
# End of macro CALLMONITOR
0b15				endif 
0b15			 
0b15				; update file extent count 
0b15			 
0b15 11 81 fa			ld de, store_page 
0b18			 
0b18 cd d4 03			call storage_read_block 
0b1b			 
0b1b				if DEBUG_STORESE 
0b1b					DMARK "AP3" 
0b1b f5				push af  
0b1c 3a 30 0b			ld a, (.dmark)  
0b1f 32 6e fe			ld (debug_mark),a  
0b22 3a 31 0b			ld a, (.dmark+1)  
0b25 32 6f fe			ld (debug_mark+1),a  
0b28 3a 32 0b			ld a, (.dmark+2)  
0b2b 32 70 fe			ld (debug_mark+2),a  
0b2e 18 03			jr .pastdmark  
0b30 ..			.dmark: db "AP3"  
0b33 f1			.pastdmark: pop af  
0b34			endm  
# End of macro DMARK
0b34					CALLMONITOR 
0b34 cd ab 18			call break_point_state  
0b37				endm  
# End of macro CALLMONITOR
0b37				endif 
0b37			;	ld (store_tmppageid), hl 
0b37			 
0b37 3a 83 fa			ld a, (store_page+2) 
0b3a 3c				inc a 
0b3b 32 83 fa			ld (store_page+2), a 
0b3e 32 74 fa			ld (store_tmpext), a 
0b41				 
0b41				if DEBUG_STORESE 
0b41					DMARK "AP3" 
0b41 f5				push af  
0b42 3a 56 0b			ld a, (.dmark)  
0b45 32 6e fe			ld (debug_mark),a  
0b48 3a 57 0b			ld a, (.dmark+1)  
0b4b 32 6f fe			ld (debug_mark+1),a  
0b4e 3a 58 0b			ld a, (.dmark+2)  
0b51 32 70 fe			ld (debug_mark+2),a  
0b54 18 03			jr .pastdmark  
0b56 ..			.dmark: db "AP3"  
0b59 f1			.pastdmark: pop af  
0b5a			endm  
# End of macro DMARK
0b5a					CALLMONITOR 
0b5a cd ab 18			call break_point_state  
0b5d				endm  
# End of macro CALLMONITOR
0b5d				endif 
0b5d 2a 6c fa			ld hl, (store_tmppageid) 
0b60 11 81 fa			ld de, store_page 
0b63 cd 39 04			call storage_write_block 
0b66			 
0b66				; find free block 
0b66			 
0b66 11 00 00			ld de, 0			 ; file extent to locate 
0b69			 
0b69 21 40 00				ld hl, STORE_BLOCK_PHY 
0b6c cd 07 07				call storage_findnextid 
0b6f cd 2d 0f			call ishlzero 
0b72 ca c2 0a			jp z, .sa_notfound 
0b75			 
0b75					; TODO handle no space left 
0b75					 
0b75 22 6c fa				ld (store_tmppageid), hl 
0b78			 
0b78				if DEBUG_STORESE 
0b78					DMARK "AP4" 
0b78 f5				push af  
0b79 3a 8d 0b			ld a, (.dmark)  
0b7c 32 6e fe			ld (debug_mark),a  
0b7f 3a 8e 0b			ld a, (.dmark+1)  
0b82 32 6f fe			ld (debug_mark+1),a  
0b85 3a 8f 0b			ld a, (.dmark+2)  
0b88 32 70 fe			ld (debug_mark+2),a  
0b8b 18 03			jr .pastdmark  
0b8d ..			.dmark: db "AP4"  
0b90 f1			.pastdmark: pop af  
0b91			endm  
# End of macro DMARK
0b91					CALLMONITOR 
0b91 cd ab 18			call break_point_state  
0b94				endm  
# End of macro CALLMONITOR
0b94				endif 
0b94					; init the buffer with zeros so we can id if the buffer is full or not 
0b94			 
0b94 e5					push hl 
0b95 c5					push bc 
0b96			 
0b96 21 81 fa				ld hl, store_page 
0b99 06 40				ld b, STORE_BLOCK_PHY 
0b9b 3e 00				ld a, 0 
0b9d 77			.zeroblock:	ld (hl), a 
0b9e 23					inc hl 
0b9f 10 fc				djnz .zeroblock 
0ba1			 
0ba1 c1					pop bc 
0ba2 e1					pop hl 
0ba3			 
0ba3					; construct block 
0ba3			 
0ba3 3a 75 fa				ld a, (store_tmpid) 
0ba6 32 81 fa				ld (store_page), a   ; file id 
0ba9 3a 74 fa				ld a, (store_tmpext)   ; extent for this block 
0bac 32 82 fa				ld (store_page+1), a 
0baf			 
0baf e1					pop hl    ; get string to write 
0bb0 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0bb2 11 83 fa				ld de, store_page+2 
0bb5			 
0bb5				if DEBUG_STORESE 
0bb5					DMARK "AP5" 
0bb5 f5				push af  
0bb6 3a ca 0b			ld a, (.dmark)  
0bb9 32 6e fe			ld (debug_mark),a  
0bbc 3a cb 0b			ld a, (.dmark+1)  
0bbf 32 6f fe			ld (debug_mark+1),a  
0bc2 3a cc 0b			ld a, (.dmark+2)  
0bc5 32 70 fe			ld (debug_mark+2),a  
0bc8 18 03			jr .pastdmark  
0bca ..			.dmark: db "AP5"  
0bcd f1			.pastdmark: pop af  
0bce			endm  
# End of macro DMARK
0bce					CALLMONITOR 
0bce cd ab 18			call break_point_state  
0bd1				endm  
# End of macro CALLMONITOR
0bd1				endif 
0bd1			 
0bd1			 
0bd1			 
0bd1					; fill buffer with data until end of string or full block 
0bd1			 
0bd1 7e			.appd:		ld a, (hl) 
0bd2 12					ld (de), a 
0bd3 fe 00				cp 0 
0bd5 28 04				jr z, .appdone 
0bd7 23					inc hl 
0bd8 13					inc de 
0bd9 10 f6				djnz .appd 
0bdb			 
0bdb e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0bdc f5					push af   		; save last byte dumped 
0bdd			 
0bdd			 
0bdd 2a 6c fa			ld hl, (store_tmppageid) 
0be0 11 81 fa			ld de, store_page 
0be3				if DEBUG_STORESE 
0be3					DMARK "AP6" 
0be3 f5				push af  
0be4 3a f8 0b			ld a, (.dmark)  
0be7 32 6e fe			ld (debug_mark),a  
0bea 3a f9 0b			ld a, (.dmark+1)  
0bed 32 6f fe			ld (debug_mark+1),a  
0bf0 3a fa 0b			ld a, (.dmark+2)  
0bf3 32 70 fe			ld (debug_mark+2),a  
0bf6 18 03			jr .pastdmark  
0bf8 ..			.dmark: db "AP6"  
0bfb f1			.pastdmark: pop af  
0bfc			endm  
# End of macro DMARK
0bfc					CALLMONITOR 
0bfc cd ab 18			call break_point_state  
0bff				endm  
# End of macro CALLMONITOR
0bff				endif 
0bff cd 39 04				call storage_write_block 
0c02			 
0c02			 
0c02				; was that a full block of data written? 
0c02				; any more to write out? 
0c02			 
0c02				; if yes then set vars and jump to start of function again 
0c02			 
0c02 f1					pop af 
0c03 d1					pop de 
0c04			 
0c04 fe 00				cp 0		 ; no, string was fully written 
0c06 c8					ret z 
0c07			 
0c07					; setup vars for next cycle 
0c07			 
0c07 3a 75 fa				ld a, (store_tmpid) 
0c0a 6f					ld l, a 
0c0b 26 00				ld h, 0 
0c0d			 
0c0d c3 c4 0a			 	jp storage_append	 ; yes, need to write out some more 
0c10			 
0c10			 
0c10			 
0c10			 
0c10			 
0c10			 
0c10			 
0c10			if DEBUG_STORECF 
0c10			storageput:	 
0c10					ret 
0c10			storageread: 
0c10					ld hl, store_page 
0c10					ld b, 200 
0c10					ld a,0 
0c10			.src:		ld (hl),a 
0c10					inc hl 
0c10					djnz .src 
0c10					 
0c10			 
0c10					ld de, 0 
0c10					ld bc, 1 
0c10					ld hl, store_page 
0c10					call cfRead 
0c10			 
0c10				call cfGetError 
0c10				ld hl,scratch 
0c10				call hexout 
0c10				ld hl, scratch+2 
0c10				ld a, 0 
0c10				ld (hl),a 
0c10				ld de, scratch 
0c10				ld a,display_row_1 
0c10				call str_at_display 
0c10				call update_display 
0c10			 
0c10					ld hl, store_page 
0c10					ld (os_cur_ptr),hl 
0c10			 
0c10					ret 
0c10			endif 
0c10			 
0c10			 
0c10			; Clear out the main buffer store (used to remove junk before writing a new block) 
0c10			 
0c10			storage_clear_page: 
0c10 e5				push hl 
0c11 d5				push de 
0c12 c5				push bc 
0c13 21 81 fa			ld hl, store_page 
0c16 3e 00			ld a, 0 
0c18 77				ld (hl), a 
0c19			 
0c19 11 82 fa			ld de, store_page+1 
0c1c 01 18 01			ld bc, STORE_BLOCK_LOG 
0c1f			 
0c1f ed b0			ldir 
0c21				 
0c21 c1				pop bc 
0c22 d1				pop de 
0c23 e1				pop hl 
0c24 c9				ret 
0c25			 
0c25			; eof 
# End of file firmware_storage.asm
0c25			  
0c25			; support routines for above hardware abstraction layer  
0c25			  
0c25			include "firmware_general.asm"        ; general support functions  
0c25			 
0c25			; word look up 
0c25			 
0c25			; in 
0c25			; a is the index 
0c25			; hl is pointer start of array 
0c25			; 
0c25			; returns 
0c25			; hl to the word 
0c25			; 
0c25			 
0c25			table_lookup:  
0c25 d5					push de 
0c26 eb					ex de, hl 
0c27			 
0c27 6f					ld l, a 
0c28 26 00				ld h, 0 
0c2a 29					add hl, hl 
0c2b 19					add hl, de 
0c2c 7e					ld a, (hl) 
0c2d 23					inc hl 
0c2e 66					ld h,(hl) 
0c2f 6f					ld l, a 
0c30			 
0c30 d1					pop de 
0c31 c9					ret 
0c32			 
0c32			; Delay loops 
0c32			 
0c32			 
0c32			 
0c32			aDelayInMS: 
0c32 c5				push bc 
0c33 47				ld b,a 
0c34			msdelay: 
0c34 c5				push bc 
0c35				 
0c35			 
0c35 01 41 00			ld bc,041h 
0c38 cd 50 0c			call delayloop 
0c3b c1				pop bc 
0c3c 05				dec b 
0c3d 20 f5			jr nz,msdelay 
0c3f			 
0c3f			;if CPU_CLOCK_8MHZ 
0c3f			;msdelay8: 
0c3f			;	push bc 
0c3f			;	 
0c3f			; 
0c3f			;	ld bc,041h 
0c3f			;	call delayloop 
0c3f			;	pop bc 
0c3f			;	dec b 
0c3f			;	jr nz,msdelay8 
0c3f			;endif 
0c3f			 
0c3f			 
0c3f c1				pop bc 
0c40 c9				ret 
0c41			 
0c41			 
0c41			delay250ms: 
0c41				;push de 
0c41 01 00 40			ld bc, 04000h 
0c44 c3 50 0c			jp delayloop 
0c47			delay500ms: 
0c47				;push de 
0c47 01 00 80			ld bc, 08000h 
0c4a c3 50 0c			jp delayloop 
0c4d			delay1s: 
0c4d				;push bc 
0c4d			   ; Clobbers A, d and e 
0c4d 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0c50			delayloop: 
0c50 c5			    push bc 
0c51			 
0c51			if BASE_CPM 
0c51				ld bc, CPM_DELAY_TUNE 
0c51			.cpmloop: 
0c51				push bc 
0c51			 
0c51			endif 
0c51			 
0c51			 
0c51			 
0c51			delayloopi: 
0c51			;	push bc 
0c51			;.dl: 
0c51 cb 47		    bit     0,a    	; 8 
0c53 cb 47		    bit     0,a    	; 8 
0c55 cb 47		    bit     0,a    	; 8 
0c57 e6 ff		    and     255  	; 7 
0c59 0b			    dec     bc      	; 6 
0c5a 79			    ld      a,c     	; 4 
0c5b b0			    or      b     	; 4 
0c5c c2 51 0c		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0c5f			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0c5f				;pop de 
0c5f			;pop bc 
0c5f			 
0c5f			if BASE_CPM 
0c5f				pop bc 
0c5f				 
0c5f			    dec     bc      	; 6 
0c5f			    ld      a,c     	; 4 
0c5f			    or      b     	; 4 
0c5f			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0c5f				 
0c5f			 
0c5f			endif 
0c5f			;if CPU_CLOCK_8MHZ 
0c5f			;    pop bc 
0c5f			;    push bc 
0c5f			;.dl8: 
0c5f			;    bit     0,a    	; 8 
0c5f			;    bit     0,a    	; 8 
0c5f			;    bit     0,a    	; 8 
0c5f			;    and     255  	; 7 
0c5f			;    dec     bc      	; 6 
0c5f			;    ld      a,c     	; 4 
0c5f			;    or      b     	; 4 
0c5f			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0c5f			;endif 
0c5f			 
0c5f			;if CPU_CLOCK_10MHZ 
0c5f			;    pop bc 
0c5f			;    push bc 
0c5f			;.dl8: 
0c5f			;    bit     0,a    	; 8 
0c5f			;    bit     0,a    	; 8 
0c5f			;    bit     0,a    	; 8 
0c5f			;    and     255  	; 7 
0c5f			;    dec     bc      	; 6 
0c5f			;    ld      a,c     	; 4 
0c5f			;    or      b     	; 4 
0c5f			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0c5f			;endif 
0c5f c1			    pop bc 
0c60			 
0c60 c9				ret 
0c61			 
0c61			 
0c61			 
0c61			; eof 
# End of file firmware_general.asm
0c61			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0c61			; display routines that use the physical hardware abstraction layer 
0c61			 
0c61			 
0c61			; information window 
0c61			 
0c61			; pass hl with 1st string to display 
0c61			; pass de with 2nd string to display 
0c61			 
0c61			info_panel: 
0c61 e5				push hl 
0c62			 
0c62 2a cf fb			ld hl, (display_fb_active) 
0c65 e5				push hl    ; future de destination 
0c66 21 b4 fd				ld hl, display_fb0 
0c69 22 cf fb				ld (display_fb_active), hl 
0c6c			 
0c6c			;	call clear_display 
0c6c			 
0c6c				if BASE_CPM 
0c6c				ld a, '.' 
0c6c				else 
0c6c 3e a5			ld a, 165 
0c6e				endif 
0c6e cd d5 0c			call fill_display 
0c71			 
0c71			 
0c71 3e 55			ld a, display_row_3 + 5 
0c73 cd e3 0c			call str_at_display 
0c76			 
0c76 e1				pop hl 
0c77 d1				pop de 
0c78			 
0c78 e5				push hl 
0c79			 
0c79			 
0c79 3e 2d			ld a, display_row_2 + 5 
0c7b cd e3 0c			call str_at_display 
0c7e			 
0c7e			 
0c7e cd f3 0c			call update_display 
0c81 cd 97 1e			call next_page_prompt 
0c84 cd d0 0c			call clear_display 
0c87			 
0c87				 
0c87 21 13 fd				ld hl, display_fb1 
0c8a 22 cf fb				ld (display_fb_active), hl 
0c8d cd f3 0c			call update_display 
0c90			 
0c90 e1				pop hl 
0c91			 
0c91 c9				ret 
0c92			 
0c92			 
0c92			 
0c92			 
0c92			; TODO windowing? 
0c92			 
0c92			; TODO scroll line up 
0c92			 
0c92			scroll_up: 
0c92			 
0c92 e5				push hl 
0c93 d5				push de 
0c94 c5				push bc 
0c95			 
0c95				; get frame buffer  
0c95			 
0c95 2a cf fb			ld hl, (display_fb_active) 
0c98 e5				push hl    ; future de destination 
0c99			 
0c99 11 28 00			ld  de, display_cols 
0c9c 19				add hl, de 
0c9d			 
0c9d d1				pop de 
0c9e			 
0c9e				;ex de, hl 
0c9e 01 9f 00			ld bc, display_fb_len -1  
0ca1			;if DEBUG_FORTH_WORDS 
0ca1			;	DMARK "SCL" 
0ca1			;	CALLMONITOR 
0ca1			;endif	 
0ca1 ed b0			ldir 
0ca3			 
0ca3				; wipe bottom row 
0ca3			 
0ca3			 
0ca3 2a cf fb			ld hl, (display_fb_active) 
0ca6 11 a0 00			ld de, display_cols*display_rows 
0ca9 19				add hl, de 
0caa 06 28			ld b, display_cols 
0cac 3e 20			ld a, ' ' 
0cae			.scwipe: 
0cae 77				ld (hl), a 
0caf 2b				dec hl 
0cb0 10 fc			djnz .scwipe 
0cb2			 
0cb2				;pop hl 
0cb2			 
0cb2 c1				pop bc 
0cb3 d1				pop de 
0cb4 e1				pop hl 
0cb5			 
0cb5 c9				ret 
0cb6			 
0cb6			 
0cb6			;scroll_upo: 
0cb6			;	ld de, display_row_1 
0cb6			 ;	ld hl, display_row_2 
0cb6			;	ld bc, display_cols 
0cb6			;	ldir 
0cb6			;	ld de, display_row_2 
0cb6			 ;	ld hl, display_row_3 
0cb6			;	ld bc, display_cols 
0cb6			;	ldir 
0cb6			;	ld de, display_row_3 
0cb6			 ;	ld hl, display_row_4 
0cb6			;	ld bc, display_cols 
0cb6			;	ldir 
0cb6			 
0cb6			; TODO clear row 4 
0cb6			 
0cb6			;	ret 
0cb6			 
0cb6				 
0cb6			scroll_down: 
0cb6			 
0cb6 e5				push hl 
0cb7 d5				push de 
0cb8 c5				push bc 
0cb9			 
0cb9				; get frame buffer  
0cb9			 
0cb9 2a cf fb			ld hl, (display_fb_active) 
0cbc			 
0cbc 11 9f 00			ld de, display_fb_len - 1 
0cbf 19				add hl, de 
0cc0			 
0cc0 e5			push hl    ; future de destination 
0cc1			 
0cc1 11 28 00			ld  de, display_cols 
0cc4 ed 52			sbc hl, de 
0cc6			 
0cc6			 
0cc6 d1				pop de 
0cc7			 
0cc7			;	ex de, hl 
0cc7 01 9f 00			ld bc, display_fb_len -1  
0cca			 
0cca			 
0cca				 
0cca			 
0cca ed b0			ldir 
0ccc			 
0ccc				; wipe bottom row 
0ccc			 
0ccc			 
0ccc			;	ld hl, (display_fb_active) 
0ccc			;;	ld de, display_cols*display_rows 
0ccc			;;	add hl, de 
0ccc			;	ld b, display_cols 
0ccc			;	ld a, ' ' 
0ccc			;.scwiped: 
0ccc			;	ld (hl), a 
0ccc			;	dec hl 
0ccc			;	djnz .scwiped 
0ccc			 
0ccc				;pop hl 
0ccc			 
0ccc c1				pop bc 
0ccd d1				pop de 
0cce e1				pop hl 
0ccf			 
0ccf c9				ret 
0cd0			;scroll_down: 
0cd0			;	ld de, display_row_4 
0cd0			;	ld hl, display_row_3 
0cd0			;	ld bc, display_cols 
0cd0			;	ldir 
0cd0			;	ld de, display_row_3 
0cd0			; 	ld hl, display_row_2 
0cd0			;	ld bc, display_cols 
0cd0			;	ldir 
0cd0			;	ld de, display_row_2 
0cd0			;	ld hl, display_row_1 
0cd0			;	ld bc, display_cols 
0cd0			;	ldir 
0cd0			;;; TODO clear row 1 
0cd0			;	ret 
0cd0			 
0cd0			 
0cd0			 
0cd0			 
0cd0			 
0cd0			; clear active frame buffer 
0cd0			 
0cd0			clear_display: 
0cd0 3e 20			ld a, ' ' 
0cd2 c3 d5 0c			jp fill_display 
0cd5			 
0cd5			; fill active frame buffer with a char in A 
0cd5			 
0cd5			fill_display: 
0cd5 06 a0			ld b,display_fb_len 
0cd7 2a cf fb			ld hl, (display_fb_active) 
0cda 77			.fd1:	ld (hl),a 
0cdb 23				inc hl 
0cdc 10 fc			djnz .fd1 
0cde 23				inc hl 
0cdf 3e 00			ld a,0 
0ce1 77				ld (hl),a 
0ce2			 
0ce2			 
0ce2 c9				ret 
0ce3			; Write string (DE) at pos (A) to active frame buffer 
0ce3			 
0ce3 2a cf fb		str_at_display:    ld hl,(display_fb_active) 
0ce6 06 00					ld b,0 
0ce8 4f					ld c,a 
0ce9 09					add hl,bc 
0cea 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0ceb b7			            OR   A              ;Null terminator? 
0cec c8			            RET  Z              ;Yes, so finished 
0ced 77					ld (hl),a 
0cee 23				inc hl 
0cef 13			            INC  DE             ;Point to next character 
0cf0 18 f8		            JR   .sad1     ;Repeat 
0cf2 c9					ret 
0cf3			 
0cf3			; using current frame buffer write to physical display 
0cf3			 
0cf3			update_display: 
0cf3 e5				push hl 
0cf4 2a cf fb			ld hl, (display_fb_active) 
0cf7 cd fe 69			call write_display 
0cfa e1				pop hl 
0cfb c9				ret 
0cfc			 
0cfc			; TODO scrolling 
0cfc			 
0cfc			 
0cfc			; move cursor right one char 
0cfc			cursor_right: 
0cfc			 
0cfc				; TODO shift right 
0cfc				; TODO if beyond max col 
0cfc				; TODO       cursor_next_line 
0cfc			 
0cfc c9				ret 
0cfd			 
0cfd			 
0cfd			cursor_next_line: 
0cfd				; TODO first char 
0cfd				; TODO line down 
0cfd				; TODO if past last row 
0cfd				; TODO    scroll up 
0cfd			 
0cfd c9				ret 
0cfe			 
0cfe			cursor_left: 
0cfe				; TODO shift left 
0cfe				; TODO if beyond left  
0cfe				; TODO     cursor prev line 
0cfe				 
0cfe c9				ret 
0cff			 
0cff			cursor_prev_line: 
0cff				; TODO last char 
0cff				; TODO line up 
0cff				; TODO if past first row 
0cff				; TODO   scroll down 
0cff			 
0cff c9				ret 
0d00			 
0d00			 
0d00			cout: 
0d00				; A - char 
0d00 c9				ret 
0d01			 
0d01			 
0d01			; Display a menu and allow item selection (optional toggle items) 
0d01			; 
0d01			; format: 
0d01			; hl pointer to word array with zero term for items 
0d01			; e.g.    db item1 
0d01			;         db .... 
0d01			;         db 0 
0d01			; 
0d01			; a = starting menu item  
0d01			; 
0d01			; de = pointer item toggle array   (todo) 
0d01			; 
0d01			; returns item selected in a 1-... 
0d01			; returns 0 if back button pressed 
0d01			; 
0d01			; NOTE: Uses system frame buffer to display 
0d01			; 
0d01			; LEFT, Q = go back 
0d01			; RIGHT, SPACE, CR = select 
0d01			; UP, A - Up 
0d01			; DOWN, Z - Down 
0d01			 
0d01			 
0d01			 
0d01			 
0d01			 
0d01			menu: 
0d01			 
0d01					; keep array pointer 
0d01			 
0d01 22 7a fa				ld (store_tmp1), hl 
0d04 32 78 fa				ld (store_tmp2), a 
0d07			 
0d07					; check for key bounce 
0d07			 
0d07			if BASE_KEV 
0d07			 
0d07 cd 49 6d		.mbounce:	call cin 
0d0a fe 00				cp 0 
0d0c 20 f9				jr nz, .mbounce 
0d0e			endif 
0d0e					; for ease use ex 
0d0e			 
0d0e					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0d0e 21 b4 fd				ld hl, display_fb0 
0d11 22 cf fb				ld (display_fb_active), hl 
0d14			 
0d14 cd d0 0c		.mloop:		call clear_display 
0d17 cd f3 0c				call update_display 
0d1a			 
0d1a					; draw selection id '>' at 1 
0d1a			 
0d1a					; init start of list display 
0d1a			 
0d1a 3e 05				ld a, 5 
0d1c 32 76 fa				ld (store_tmp3), a   ; display row count 
0d1f 3a 78 fa				ld a,( store_tmp2) 
0d22 32 79 fa				ld (store_tmp2+1), a   ; display item count 
0d25			 
0d25					 
0d25			.mitem:	 
0d25			 
0d25			 
0d25 3a 79 fa				ld a,(store_tmp2+1) 
0d28 6f					ld l, a 
0d29 26 00				ld h, 0 
0d2b 29					add hl, hl 
0d2c ed 5b 7a fa			ld de, (store_tmp1) 
0d30 19					add hl, de 
0d31 7e					ld a, (hl) 
0d32 23					inc hl 
0d33 66					ld h,(hl) 
0d34 6f					ld l, a 
0d35			 
0d35 cd 2d 0f				call ishlzero 
0d38 28 1a				jr z, .mdone 
0d3a			 
0d3a eb					ex de, hl 
0d3b 3a 76 fa				ld a, (store_tmp3) 
0d3e cd e3 0c				call str_at_display 
0d41					 
0d41			 
0d41					; next item 
0d41 3a 79 fa				ld a, (store_tmp2+1) 
0d44 3c					inc a 
0d45 32 79 fa				ld (store_tmp2+1), a   ; display item count 
0d48			 
0d48			 		; next row 
0d48			 
0d48 3a 76 fa				ld a, (store_tmp3) 
0d4b c6 28				add display_cols 
0d4d 32 76 fa				ld (store_tmp3), a 
0d50			 
0d50					; at end of screen? 
0d50			 
0d50 fe 10				cp display_rows*4 
0d52 20 d1				jr nz, .mitem 
0d54			 
0d54			 
0d54			.mdone: 
0d54 cd 2d 0f				call ishlzero 
0d57 28 08				jr z, .nodn 
0d59			 
0d59 3e 78				ld a, display_row_4 
0d5b 11 da 0d				ld de, .mdown 
0d5e cd e3 0c				call str_at_display 
0d61			 
0d61					; draw options to fill the screens with active item on line 1 
0d61					; if current option is 2 or more then display ^ in top 
0d61			 
0d61 3a 78 fa		.nodn:		ld a, (store_tmp2) 
0d64 fe 00				cp 0 
0d66 28 08				jr z, .noup 
0d68			 
0d68 3e 00				ld a, 0 
0d6a 11 d8 0d				ld de, .mup 
0d6d cd e3 0c				call str_at_display 
0d70			 
0d70 3e 02		.noup:		ld a, 2 
0d72 11 d6 0d				ld de, .msel 
0d75 cd e3 0c				call str_at_display 
0d78			 
0d78					; if current option + 1 is not null then display V in bottom 
0d78					; get key 
0d78 cd f3 0c				call update_display 
0d7b			 
0d7b			 
0d7b					; handle key 
0d7b			 
0d7b cd 38 6d				call cin_wait 
0d7e			 
0d7e fe 05				cp KEY_UP 
0d80 28 2b				jr z, .mgoup 
0d82 fe 61				cp 'a' 
0d84 28 27				jr z, .mgoup 
0d86 fe 0a				cp KEY_DOWN 
0d88 28 32				jr z, .mgod 
0d8a fe 7a				cp 'z' 
0d8c 28 2e				jr z, .mgod 
0d8e fe 20				cp ' ' 
0d90 28 34				jr z, .goend 
0d92 fe 0c				cp KEY_RIGHT 
0d94 28 30				jr z, .goend 
0d96 fe 0d				cp KEY_CR 
0d98 28 2c				jr z, .goend 
0d9a fe 71				cp 'q' 
0d9c 28 0b				jr z, .goback 
0d9e			 
0d9e fe 0b				cp KEY_LEFT 
0da0 28 07				jr z, .goback 
0da2 fe 08				cp KEY_BS 
0da4 28 03				jr z, .goback 
0da6 c3 14 0d				jp .mloop 
0da9			 
0da9			.goback: 
0da9 3e 00			ld a, 0 
0dab 18 1d			jr .goend2 
0dad			 
0dad				; move up one 
0dad			.mgoup: 
0dad 3a 78 fa				ld a, (store_tmp2) 
0db0 fe 00				cp 0 
0db2 ca 14 0d				jp z, .mloop 
0db5 3d					dec a 
0db6 32 78 fa				ld (store_tmp2), a 
0db9 c3 14 0d				jp .mloop 
0dbc			 
0dbc				; move down one 
0dbc			.mgod: 
0dbc 3a 78 fa				ld a, (store_tmp2) 
0dbf 3c					inc a 
0dc0 32 78 fa				ld (store_tmp2), a 
0dc3 c3 14 0d				jp .mloop 
0dc6			 
0dc6			 
0dc6			.goend: 
0dc6					; get selected item number 
0dc6			 
0dc6 3a 78 fa				ld a, (store_tmp2) 
0dc9 3c					inc a 
0dca			 
0dca			.goend2: 
0dca f5					push af 
0dcb			 
0dcb					; restore active fb 
0dcb					; TODO BUG assumes fb1 
0dcb			 
0dcb 21 13 fd				ld hl, display_fb1 
0dce 22 cf fb				ld (display_fb_active), hl 
0dd1			 
0dd1					; restore main regs 
0dd1			 
0dd1			 
0dd1 cd f3 0c				call update_display 
0dd4			 
0dd4 f1					pop af 
0dd5			 
0dd5 c9				ret 
0dd6			 
0dd6 .. 00		.msel:   db ">",0 
0dd8 .. 00		.mup:   db "^",0 
0dda .. 00		.mdown:   db "v",0 
0ddc			 
0ddc			 
0ddc			; eof 
0ddc			 
# End of file firmware_display.asm
0ddc			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0ddc			; random number generators 
0ddc			 
0ddc			 
0ddc			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0ddc			 
0ddc			 
0ddc			;-----> Generate a random number 
0ddc			; output a=answer 0<=a<=255 
0ddc			; all registers are preserved except: af 
0ddc			random: 
0ddc e5			        push    hl 
0ddd d5			        push    de 
0dde 2a b1 fb		        ld      hl,(randData) 
0de1 ed 5f		        ld      a,r 
0de3 57			        ld      d,a 
0de4 5e			        ld      e,(hl) 
0de5 19			        add     hl,de 
0de6 85			        add     a,l 
0de7 ac			        xor     h 
0de8 22 b1 fb		        ld      (randData),hl 
0deb d1			        pop     de 
0dec e1			        pop     hl 
0ded c9			        ret 
0dee			 
0dee			 
0dee			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0dee			 
0dee			 
0dee			 
0dee			;------LFSR------ 
0dee			;James Montelongo 
0dee			;optimized by Spencer Putt 
0dee			;out: 
0dee			; a = 8 bit random number 
0dee			RandLFSR: 
0dee 21 b7 fb		        ld hl,LFSRSeed+4 
0df1 5e			        ld e,(hl) 
0df2 23			        inc hl 
0df3 56			        ld d,(hl) 
0df4 23			        inc hl 
0df5 4e			        ld c,(hl) 
0df6 23			        inc hl 
0df7 7e			        ld a,(hl) 
0df8 47			        ld b,a 
0df9 cb 13		        rl e  
0dfb cb 12			rl d 
0dfd cb 11		        rl c  
0dff 17				rla 
0e00 cb 13		        rl e  
0e02 cb 12			rl d 
0e04 cb 11		        rl c  
0e06 17				rla 
0e07 cb 13		        rl e  
0e09 cb 12			rl d 
0e0b cb 11		        rl c  
0e0d 17				rla 
0e0e 67			        ld h,a 
0e0f cb 13		        rl e  
0e11 cb 12			rl d 
0e13 cb 11		        rl c  
0e15 17				rla 
0e16 a8			        xor b 
0e17 cb 13		        rl e  
0e19 cb 12			rl d 
0e1b ac			        xor h 
0e1c a9			        xor c 
0e1d aa			        xor d 
0e1e 21 b9 fb		        ld hl,LFSRSeed+6 
0e21 11 ba fb		        ld de,LFSRSeed+7 
0e24 01 07 00		        ld bc,7 
0e27 ed b8		        lddr 
0e29 12			        ld (de),a 
0e2a c9			        ret 
0e2b			 
0e2b			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0e2b			 
0e2b			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0e2b			 
0e2b			 
0e2b			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0e2b			 
0e2b			prng16: 
0e2b			;Inputs: 
0e2b			;   (seed1) contains a 16-bit seed value 
0e2b			;   (seed2) contains a NON-ZERO 16-bit seed value 
0e2b			;Outputs: 
0e2b			;   HL is the result 
0e2b			;   BC is the result of the LCG, so not that great of quality 
0e2b			;   DE is preserved 
0e2b			;Destroys: 
0e2b			;   AF 
0e2b			;cycle: 4,294,901,760 (almost 4.3 billion) 
0e2b			;160cc 
0e2b			;26 bytes 
0e2b 2a ab fb		    ld hl,(seed1) 
0e2e 44			    ld b,h 
0e2f 4d			    ld c,l 
0e30 29			    add hl,hl 
0e31 29			    add hl,hl 
0e32 2c			    inc l 
0e33 09			    add hl,bc 
0e34 22 ab fb		    ld (seed1),hl 
0e37 2a a9 fb		    ld hl,(seed2) 
0e3a 29			    add hl,hl 
0e3b 9f			    sbc a,a 
0e3c e6 2d		    and %00101101 
0e3e ad			    xor l 
0e3f 6f			    ld l,a 
0e40 22 a9 fb		    ld (seed2),hl 
0e43 09			    add hl,bc 
0e44 c9			    ret 
0e45			 
0e45			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0e45			 
0e45			rand32: 
0e45			;Inputs: 
0e45			;   (seed1_0) holds the lower 16 bits of the first seed 
0e45			;   (seed1_1) holds the upper 16 bits of the first seed 
0e45			;   (seed2_0) holds the lower 16 bits of the second seed 
0e45			;   (seed2_1) holds the upper 16 bits of the second seed 
0e45			;   **NOTE: seed2 must be non-zero 
0e45			;Outputs: 
0e45			;   HL is the result 
0e45			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0e45			;Destroys: 
0e45			;   AF 
0e45			;Tested and passes all CAcert tests 
0e45			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0e45			;it has a period of 18,446,744,069,414,584,320 
0e45			;roughly 18.4 quintillion. 
0e45			;LFSR taps: 0,2,6,7  = 11000101 
0e45			;291cc 
0e45			;seed1_0=$+1 
0e45			;    ld hl,12345 
0e45			;seed1_1=$+1 
0e45			;    ld de,6789 
0e45			;    ld b,h 
0e45			;    ld c,l 
0e45			;    add hl,hl \ rl e \ rl d 
0e45			;    add hl,hl \ rl e \ rl d 
0e45			;    inc l 
0e45			;    add hl,bc 
0e45			;    ld (seed1_0),hl 
0e45			;    ld hl,(seed1_1) 
0e45			;    adc hl,de 
0e45			;    ld (seed1_1),hl 
0e45			;    ex de,hl 
0e45			;seed2_0=$+1 
0e45			;    ld hl,9876 
0e45			;seed2_1=$+1 
0e45			;    ld bc,54321 
0e45			;    add hl,hl \ rl c \ rl b 
0e45			;    ld (seed2_1),bc 
0e45			;    sbc a,a 
0e45			;    and %11000101 
0e45			;    xor l 
0e45			;    ld l,a 
0e45			;    ld (seed2_0),hl 
0e45			;    ex de,hl 
0e45			;    add hl,bc 
0e45			;    ret 
0e45			; 
0e45			 
0e45			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0e45			; 20 bytes, 86 cycles (excluding ret) 
0e45			 
0e45			; returns   hl = pseudorandom number 
0e45			; corrupts   a 
0e45			 
0e45			; generates 16-bit pseudorandom numbers with a period of 65535 
0e45			; using the xorshift method: 
0e45			 
0e45			; hl ^= hl << 7 
0e45			; hl ^= hl >> 9 
0e45			; hl ^= hl << 8 
0e45			 
0e45			; some alternative shift triplets which also perform well are: 
0e45			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0e45			 
0e45			;  org 32768 
0e45			 
0e45			xrnd: 
0e45 2a af fb		  ld hl,(xrandc)       ; seed must not be 0 
0e48 3e 00		  ld a,0 
0e4a bd			  cp l 
0e4b 20 02		  jr nz, .xrnd1 
0e4d 2e 01		  ld l, 1 
0e4f			.xrnd1: 
0e4f			 
0e4f 7c			  ld a,h 
0e50 1f			  rra 
0e51 7d			  ld a,l 
0e52 1f			  rra 
0e53 ac			  xor h 
0e54 67			  ld h,a 
0e55 7d			  ld a,l 
0e56 1f			  rra 
0e57 7c			  ld a,h 
0e58 1f			  rra 
0e59 ad			  xor l 
0e5a 6f			  ld l,a 
0e5b ac			  xor h 
0e5c 67			  ld h,a 
0e5d			 
0e5d 22 af fb		  ld (xrandc),hl 
0e60			 
0e60 c9			  ret 
0e61			;  
0e61			 
0e61			 
0e61			;;;; int maths 
0e61			 
0e61			; https://map.grauw.nl/articles/mult_div_shifts.php 
0e61			; Divide 16-bit values (with 16-bit result) 
0e61			; In: Divide BC by divider DE 
0e61			; Out: BC = result, HL = rest 
0e61			; 
0e61			Div16: 
0e61 21 00 00		    ld hl,0 
0e64 78			    ld a,b 
0e65 06 08		    ld b,8 
0e67			Div16_Loop1: 
0e67 17			    rla 
0e68 ed 6a		    adc hl,hl 
0e6a ed 52		    sbc hl,de 
0e6c 30 01		    jr nc,Div16_NoAdd1 
0e6e 19			    add hl,de 
0e6f			Div16_NoAdd1: 
0e6f 10 f6		    djnz Div16_Loop1 
0e71 17			    rla 
0e72 2f			    cpl 
0e73 47			    ld b,a 
0e74 79			    ld a,c 
0e75 48			    ld c,b 
0e76 06 08		    ld b,8 
0e78			Div16_Loop2: 
0e78 17			    rla 
0e79 ed 6a		    adc hl,hl 
0e7b ed 52		    sbc hl,de 
0e7d 30 01		    jr nc,Div16_NoAdd2 
0e7f 19			    add hl,de 
0e80			Div16_NoAdd2: 
0e80 10 f6		    djnz Div16_Loop2 
0e82 17			    rla 
0e83 2f			    cpl 
0e84 41			    ld b,c 
0e85 4f			    ld c,a 
0e86 c9			ret 
0e87			 
0e87			 
0e87			;http://z80-heaven.wikidot.com/math 
0e87			; 
0e87			;Inputs: 
0e87			;     DE and A are factors 
0e87			;Outputs: 
0e87			;     A is not changed 
0e87			;     B is 0 
0e87			;     C is not changed 
0e87			;     DE is not changed 
0e87			;     HL is the product 
0e87			;Time: 
0e87			;     342+6x 
0e87			; 
0e87			Mult16: 
0e87			 
0e87 06 08		     ld b,8          ;7           7 
0e89 21 00 00		     ld hl,0         ;10         10 
0e8c 29			       add hl,hl     ;11*8       88 
0e8d 07			       rlca          ;4*8        32 
0e8e 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0e90 19			         add hl,de   ;--         -- 
0e91 10 f9		       djnz $-5      ;13*7+8     99 
0e93 c9			ret 
0e94			 
0e94			; 
0e94			; Square root of 16-bit value 
0e94			; In:  HL = value 
0e94			; Out:  D = result (rounded down) 
0e94			; 
0e94			;Sqr16: 
0e94			;    ld de,#0040 
0e94			;    ld a,l 
0e94			;    ld l,h 
0e94			;    ld h,d 
0e94			;    or a 
0e94			;    ld b,8 
0e94			;Sqr16_Loop: 
0e94			;    sbc hl,de 
0e94			;    jr nc,Sqr16_Skip 
0e94			;    add hl,de 
0e94			;Sqr16_Skip: 
0e94			;    ccf 
0e94			;    rl d 
0e94			;    add a,a 
0e94			;    adc hl,hl 
0e94			;    add a,a 
0e94			;    adc hl,hl 
0e94			;    djnz Sqr16_Loop 
0e94			;    ret 
0e94			; 
0e94			; 
0e94			; Divide 8-bit values 
0e94			; In: Divide E by divider C 
0e94			; Out: A = result, B = rest 
0e94			; 
0e94			Div8: 
0e94 af			    xor a 
0e95 06 08		    ld b,8 
0e97			Div8_Loop: 
0e97 cb 13		    rl e 
0e99 17			    rla 
0e9a 91			    sub c 
0e9b 30 01		    jr nc,Div8_NoAdd 
0e9d 81			    add a,c 
0e9e			Div8_NoAdd: 
0e9e 10 f7		    djnz Div8_Loop 
0ea0 47			    ld b,a 
0ea1 7b			    ld a,e 
0ea2 17			    rla 
0ea3 2f			    cpl 
0ea4 c9			    ret 
0ea5			 
0ea5			; 
0ea5			; Multiply 8-bit value with a 16-bit value (unrolled) 
0ea5			; In: Multiply A with DE 
0ea5			; Out: HL = result 
0ea5			; 
0ea5			Mult12U: 
0ea5 2e 00		    ld l,0 
0ea7 87			    add a,a 
0ea8 30 01		    jr nc,Mult12U_NoAdd0 
0eaa 19			    add hl,de 
0eab			Mult12U_NoAdd0: 
0eab 29			    add hl,hl 
0eac 87			    add a,a 
0ead 30 01		    jr nc,Mult12U_NoAdd1 
0eaf 19			    add hl,de 
0eb0			Mult12U_NoAdd1: 
0eb0 29			    add hl,hl 
0eb1 87			    add a,a 
0eb2 30 01		    jr nc,Mult12U_NoAdd2 
0eb4 19			    add hl,de 
0eb5			Mult12U_NoAdd2: 
0eb5 29			    add hl,hl 
0eb6 87			    add a,a 
0eb7 30 01		    jr nc,Mult12U_NoAdd3 
0eb9 19			    add hl,de 
0eba			Mult12U_NoAdd3: 
0eba 29			    add hl,hl 
0ebb 87			    add a,a 
0ebc 30 01		    jr nc,Mult12U_NoAdd4 
0ebe 19			    add hl,de 
0ebf			Mult12U_NoAdd4: 
0ebf 29			    add hl,hl 
0ec0 87			    add a,a 
0ec1 30 01		    jr nc,Mult12U_NoAdd5 
0ec3 19			    add hl,de 
0ec4			Mult12U_NoAdd5: 
0ec4 29			    add hl,hl 
0ec5 87			    add a,a 
0ec6 30 01		    jr nc,Mult12U_NoAdd6 
0ec8 19			    add hl,de 
0ec9			Mult12U_NoAdd6: 
0ec9 29			    add hl,hl 
0eca 87			    add a,a 
0ecb d0			    ret nc 
0ecc 19			    add hl,de 
0ecd c9			    ret 
0ece			 
0ece			; 
0ece			; Multiply 8-bit value with a 16-bit value (right rotating) 
0ece			; In: Multiply A with DE 
0ece			;      Put lowest value in A for most efficient calculation 
0ece			; Out: HL = result 
0ece			; 
0ece			Mult12R: 
0ece 21 00 00		    ld hl,0 
0ed1			Mult12R_Loop: 
0ed1 cb 3f		    srl a 
0ed3 30 01		    jr nc,Mult12R_NoAdd 
0ed5 19			    add hl,de 
0ed6			Mult12R_NoAdd: 
0ed6 cb 23		    sla e 
0ed8 cb 12		    rl d 
0eda b7			    or a 
0edb c2 d1 0e		    jp nz,Mult12R_Loop 
0ede c9			    ret 
0edf			 
0edf			; 
0edf			; Multiply 16-bit values (with 32-bit result) 
0edf			; In: Multiply BC with DE 
0edf			; Out: BCHL = result 
0edf			; 
0edf			Mult32: 
0edf 79			    ld a,c 
0ee0 48			    ld c,b 
0ee1 21 00 00		    ld hl,0 
0ee4 06 10		    ld b,16 
0ee6			Mult32_Loop: 
0ee6 29			    add hl,hl 
0ee7 17			    rla 
0ee8 cb 11		    rl c 
0eea 30 07		    jr nc,Mult32_NoAdd 
0eec 19			    add hl,de 
0eed ce 00		    adc a,0 
0eef d2 f3 0e		    jp nc,Mult32_NoAdd 
0ef2 0c			    inc c 
0ef3			Mult32_NoAdd: 
0ef3 10 f1		    djnz Mult32_Loop 
0ef5 41			    ld b,c 
0ef6 4f			    ld c,a 
0ef7 c9			    ret 
0ef8			 
0ef8			 
0ef8			 
0ef8			; 
0ef8			; Multiply 8-bit values 
0ef8			; In:  Multiply H with E 
0ef8			; Out: HL = result 
0ef8			; 
0ef8			Mult8: 
0ef8 16 00		    ld d,0 
0efa 6a			    ld l,d 
0efb 06 08		    ld b,8 
0efd			Mult8_Loop: 
0efd 29			    add hl,hl 
0efe 30 01		    jr nc,Mult8_NoAdd 
0f00 19			    add hl,de 
0f01			Mult8_NoAdd: 
0f01 10 fa		    djnz Mult8_Loop 
0f03 c9			    ret 
0f04			 
0f04			 
0f04			 
0f04			 
0f04			 
0f04			 
0f04			 
0f04			 
0f04			;;http://z80-heaven.wikidot.com/math 
0f04			;;This divides DE by BC, storing the result in DE, remainder in HL 
0f04			; 
0f04			;DE_Div_BC:          ;1281-2x, x is at most 16 
0f04			;     ld a,16        ;7 
0f04			;     ld hl,0        ;10 
0f04			;     jp $+5         ;10 
0f04			;.DivLoop: 
0f04			;       add hl,bc    ;-- 
0f04			;       dec a        ;64 
0f04			;       jr z,.DivLoopEnd        ;86 
0f04			; 
0f04			;       sla e        ;128 
0f04			;       rl d         ;128 
0f04			;       adc hl,hl    ;240 
0f04			;       sbc hl,bc    ;240 
0f04			;       jr nc,.DivLoop ;23|21 
0f04			;       inc e        ;-- 
0f04			;       jp .DivLoop+1 
0f04			; 
0f04			;.DivLoopEnd: 
0f04			 
0f04			;HL_Div_C: 
0f04			;Inputs: 
0f04			;     HL is the numerator 
0f04			;     C is the denominator 
0f04			;Outputs: 
0f04			;     A is the remainder 
0f04			;     B is 0 
0f04			;     C is not changed 
0f04			;     DE is not changed 
0f04			;     HL is the quotient 
0f04			; 
0f04			;       ld b,16 
0f04			;       xor a 
0f04			;         add hl,hl 
0f04			;         rla 
0f04			;         cp c 
0f04			;         jr c,$+4 
0f04			;           inc l 
0f04			;           sub c 
0f04			;         djnz $-7 
0f04			 
0f04			; https://plutiedev.com/z80-add-8bit-to-16bit 
0f04			 
0f04			addatohl: 
0f04 85			    add   a, l    ; A = A+L 
0f05 6f			    ld    l, a    ; L = A+L 
0f06 8c			    adc   a, h    ; A = A+L+H+carry 
0f07 95			    sub   l       ; A = H+carry 
0f08 67			    ld    h, a    ; H = H+carry 
0f09 c9			ret 
0f0a			 
0f0a			addatode: 
0f0a 83			    add   a, e    ; A = A+L 
0f0b 5f			    ld    e, a    ; L = A+L 
0f0c 8a			    adc   a, d    ; A = A+L+H+carry 
0f0d 93			    sub   e       ; A = H+carry 
0f0e 57			    ld    d, a    ; H = H+carry 
0f0f c9			ret 
0f10			 
0f10			 
0f10			addatobc: 
0f10 81			    add   a, c    ; A = A+L 
0f11 4f			    ld    c, a    ; L = A+L 
0f12 88			    adc   a, b    ; A = A+L+H+carry 
0f13 91			    sub   c       ; A = H+carry 
0f14 47			    ld    b, a    ; H = H+carry 
0f15 c9			ret 
0f16			 
0f16			subafromhl: 
0f16			   ; If A=0 do nothing 
0f16			    ; Otherwise flip A's sign. Since 
0f16			    ; the upper byte becomes -1, also 
0f16			    ; substract 1 from H. 
0f16 ed 44		    neg 
0f18 ca 21 0f		    jp    z, Skip 
0f1b 25			    dec   h 
0f1c			     
0f1c			    ; Now add the low byte as usual 
0f1c			    ; Two's complement takes care of 
0f1c			    ; ensuring the result is correct 
0f1c 85			    add   a, l 
0f1d 6f			    ld    l, a 
0f1e 8c			    adc   a, h 
0f1f 95			    sub   l 
0f20 67			    ld    h, a 
0f21			Skip: 
0f21 c9				ret 
0f22			 
0f22			 
0f22			; compare hl and de 
0f22			; returns:  
0f22			; if hl = de, z=1, s=0, c0=0 
0f22			; if hl > de, z=0, s=0, c=0 
0f22			; if hl < de, z=0, s=1, c=1 
0f22			cmp16:	 
0f22 b7				or a 
0f23 ed 52			sbc hl,de 
0f25 e0				ret po 
0f26 7c				ld a,h 
0f27 1f				rra 
0f28 ee 40			xor 01000000B 
0f2a 37				scf 
0f2b 8f				adc a,a 
0f2c c9				ret 
0f2d			 
0f2d			 
0f2d			; test if hl contains zero   - A is destroyed 
0f2d			 
0f2d			ishlzero:    
0f2d b7				or a     ; reset flags 
0f2e 7c				ld a, h 
0f2f b5				or l        	 
0f30			 
0f30 c9				ret 
0f31			 
0f31			 
0f31			 
0f31			 
0f31			if FORTH_ENABLE_FLOATMATH 
0f31			;include "float/bbcmath.z80" 
0f31			include "float/lpfpcalc.asm" 
0f31			endif 
0f31			 
0f31			 
0f31			; eof 
0f31			 
# End of file firmware_maths.asm
0f31			include "firmware_strings.asm"   ; string handling  
0f31			 
0f31			 
0f31			; TODO string len 
0f31			; input text string, end on cr with zero term 
0f31			; a offset into frame buffer to start prompt 
0f31			; d is max length 
0f31			; e is display size TODO 
0f31			; c is current cursor position 
0f31			; hl is ptr to where string will be stored 
0f31			 
0f31			 
0f31			; TODO check limit of buffer for new inserts 
0f31			; TODO check insert does not push beyond buffer 
0f31			; TODO scroll in a limited display area 
0f31			; TODO scroll whole screen on page wrap 
0f31			 
0f31			 
0f31			; TODO handle KEY_PREVWORD 
0f31			; TODO handle KEY_NEXTWORD 
0f31			; TODO handle KEY_HOME 
0f31			; TODO handle KEY_END 
0f31			; TODO use LCD cursor? 
0f31			 
0f31 32 67 fe		input_str:    	ld (input_at_pos),a      ; save display position to start 
0f34 81					add c 
0f35 32 65 fe				ld (input_at_cursor),a	; save draw pos of cursor 
0f38 22 6a fe				ld (input_start), hl     ; save ptr to buffer 
0f3b 79					ld a, c 
0f3c cd 04 0f				call addatohl 
0f3f 22 6c fe				ld (input_ptr), hl     ; save ptr to point under the cursor 
0f42 7a					ld a,d 
0f43 32 69 fe			        ld (input_size), a       ; save length of input area 
0f46 79					ld a, c 
0f47 32 58 fe				ld (input_cursor),a      ; init cursor start position  
0f4a 7b					ld a,e 
0f4b 32 68 fe			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0f4e					 
0f4e					 
0f4e			 
0f4e			;		ld a,(input_ptr) 
0f4e			;		ld (input_under_cursor),a 	; save what is under the cursor 
0f4e			 
0f4e			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0f4e					; init cursor shape if not set by the cin routines 
0f4e 21 c7 fb				ld hl, cursor_shape 
0f51 3e ff				ld a, 255 
0f53 77					ld (hl), a 
0f54 23					inc hl 
0f55 3e 00				ld a, 0 
0f57 77					ld (hl), a 
0f58			 
0f58 3e 0f				ld a, CUR_BLINK_RATE 
0f5a 32 63 fe				ld (input_cur_flash), a 
0f5d 3e 01				ld a, 1 
0f5f 32 62 fe				ld (input_cur_onoff),a 
0f62			 
0f62			;	if DEBUG_INPUT 
0f62			;		push af 
0f62			;		ld a, 'I' 
0f62			;		ld (debug_mark),a 
0f62			;		pop af 
0f62			;		CALLMONITOR 
0f62			;	endif 
0f62			.is1:		; main entry loop 
0f62			 
0f62			 
0f62			 
0f62					; pause 1ms 
0f62			 
0f62 3e 01				ld a, 1 
0f64 cd 32 0c				call aDelayInMS 
0f67			 
0f67					; dec flash counter 
0f67 3a 63 fe				ld a, (input_cur_flash) 
0f6a 3d					dec a 
0f6b 32 63 fe				ld (input_cur_flash), a 
0f6e fe 00				cp 0 
0f70 20 0d				jr nz, .nochgstate 
0f72			 
0f72			 
0f72					; change state 
0f72 3a 62 fe				ld a,(input_cur_onoff) 
0f75 ed 44				neg 
0f77 32 62 fe				ld (input_cur_onoff),a 
0f7a			 
0f7a			 
0f7a					; reset on change of state 
0f7a 3e 0f				ld a, CUR_BLINK_RATE 
0f7c 32 63 fe				ld (input_cur_flash), a 
0f7f			 
0f7f			.nochgstate: 
0f7f					 
0f7f					 
0f7f			 
0f7f					; display cursor  
0f7f			 
0f7f			;		ld hl, (input_start) 
0f7f			;		ld a, (input_cursor) 
0f7f			;		call addatohl 
0f7f			 
0f7f					; get char under cursor and replace with cursor 
0f7f 2a 6c fe		ld hl, (input_ptr) 
0f82			;		ld a, (hl) 
0f82			;		ld (input_under_cursor),a 
0f82			;		ld a, '_' 
0f82			;		ld (hl), a 
0f82			 
0f82					; display string 
0f82			 
0f82 ed 5b 6a fe			ld de, (input_start) 
0f86 3a 67 fe				ld a, (input_at_pos) 
0f89 cd e3 0c				call str_at_display 
0f8c			;	        call update_display 
0f8c			 
0f8c					; find place to put the cursor 
0f8c			;		add h 
0f8c			;		ld l, display_row_1 
0f8c			;		sub l 
0f8c			; (input_at_pos) 
0f8c					;ld c, a 
0f8c			;		ld a, (input_cursor) 
0f8c			;		ld l, (input_at_pos) 
0f8c			;		;ld b, h 
0f8c			;		add l 
0f8c			;		ld (input_at_cursor),a 
0f8c					;ld l,h 
0f8c			 
0f8c			;		ld h, 0 
0f8c			;		ld l,(input_at_pos) 
0f8c			;		ld a, (input_cursor) 
0f8c			;		call addatohl 
0f8c			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0f8c			;		call subafromhl 
0f8c			;		ld a,l 
0f8c			;		ld (input_at_cursor), a 
0f8c			 
0f8c				if DEBUG_INPUT 
0f8c					ld a, (hardware_diag) 
0f8c					cp 0 
0f8c					jr z, .skip_input_diag 
0f8c			 
0f8c					ld a,(input_at_pos) 
0f8c					ld hl, LFSRSeed 
0f8c					call hexout 
0f8c					ld a, (input_cursor) 
0f8c					ld hl, LFSRSeed+2 
0f8c					call hexout 
0f8c					ld a,(input_at_cursor) 
0f8c					ld hl, LFSRSeed+4 
0f8c					call hexout 
0f8c			 
0f8c					ld a,(input_cur_onoff) 
0f8c					ld hl, LFSRSeed+6 
0f8c					call hexout 
0f8c			 
0f8c					ld a,(input_cur_flash) 
0f8c					ld hl, LFSRSeed+8 
0f8c					call hexout 
0f8c			 
0f8c					ld a,(input_len) 
0f8c					ld hl, LFSRSeed+10 
0f8c					call hexout 
0f8c					ld hl, LFSRSeed+12 
0f8c					ld a, 0 
0f8c					ld (hl),a 
0f8c					ld a, display_row_4 
0f8c					ld de, LFSRSeed 
0f8c					call str_at_display 
0f8c					.skip_input_diag: 
0f8c				endif 
0f8c			 
0f8c					; decide on if we are showing the cursor this time round 
0f8c			 
0f8c 3a 62 fe				ld a, (input_cur_onoff) 
0f8f fe ff				cp 255 
0f91 28 13				jr z, .skipcur 
0f93			 
0f93			 
0f93 3a 65 fe				ld a,(input_at_cursor) 
0f96 11 c7 fb				ld de, cursor_shape 
0f99 cd e3 0c				call str_at_display 
0f9c			 
0f9c					; save length of current input string 
0f9c 2a 6a fe				ld hl, (input_start) 
0f9f cd 62 13				call strlenz 
0fa2 7d					ld a,l 
0fa3 32 5d fe				ld (input_len),a 
0fa6			 
0fa6			.skipcur: 
0fa6			 
0fa6 cd f3 0c			        call update_display 
0fa9					 
0fa9			 
0fa9			 
0fa9					; wait 
0fa9				 
0fa9					; TODO loop without wait to flash the cursor and char under cursor	 
0fa9 cd 49 6d				call cin    ; _wait 
0fac			 
0fac fe 00				cp 0 
0fae ca 62 0f				jp z, .is1 
0fb1			 
0fb1					; get ptr to char to input into 
0fb1			 
0fb1 4f					ld c,a 
0fb2 2a 6a fe				ld hl, (input_start) 
0fb5 3a 58 fe				ld a, (input_cursor) 
0fb8 cd 04 0f				call addatohl 
0fbb 22 6c fe				ld (input_ptr), hl 
0fbe 79					ld a,c 
0fbf			 
0fbf					; replace char under cursor 
0fbf			 
0fbf			;		ld hl, (input_ptr) 
0fbf			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0fbf			;		ld (hl), a 
0fbf			 
0fbf			;	if DEBUG_INPUT 
0fbf			;		push af 
0fbf			;		ld a, 'i' 
0fbf			;		ld (debug_mark),a 
0fbf			;		pop af 
0fbf			;		CALLMONITOR 
0fbf			;	endif 
0fbf fe 0e				cp KEY_HOME 
0fc1 20 0e				jr nz, .iske 
0fc3			 
0fc3 3a 67 fe				ld a, (input_at_pos) 
0fc6 32 65 fe				ld (input_at_cursor),a 
0fc9 3e 00				ld a, 0 
0fcb 32 58 fe				ld (input_cursor), a 
0fce c3 62 0f				jp .is1 
0fd1					 
0fd1 fe 0f		.iske:		cp KEY_END 
0fd3 20 03				jr nz, .isknw 
0fd5 c3 62 0f				jp .is1 
0fd8			 
0fd8 fe 06		.isknw:		cp KEY_NEXTWORD 
0fda 20 1b				jr nz, .iskpw 
0fdc			 
0fdc 2a 6c fe		.isknwm:	ld hl, (input_ptr) 
0fdf 7e					ld a,(hl)	 
0fe0 fe 00				cp 0 
0fe2 ca 62 0f				jp z, .is1    ; end of string 
0fe5 fe 20				cp ' ' 
0fe7 ca 62 0f				jp z, .is1    ; end of word 
0fea 23					inc hl 
0feb 22 6c fe				ld (input_ptr), hl 
0fee 3a 65 fe				ld a, (input_at_cursor) 
0ff1 3c					inc a 
0ff2 32 65 fe				ld (input_at_cursor), a 
0ff5 18 e5				jr .isknwm 
0ff7			 
0ff7 fe 07		.iskpw:		cp KEY_PREVWORD 
0ff9 20 1b				jr nz, .iskl 
0ffb			.iskpwm:	 
0ffb 2a 6c fe				ld hl, (input_ptr) 
0ffe 7e					ld a,(hl)	 
0fff fe 00				cp 0  
1001 ca 62 0f				jp z, .is1    ; end of string 
1004 fe 20				cp ' ' 
1006 ca 62 0f				jp z, .is1    ; end of word 
1009 2b					dec hl 
100a 22 6c fe				ld (input_ptr), hl 
100d 3a 65 fe				ld a, (input_at_cursor) 
1010 3d					dec a 
1011 32 65 fe				ld (input_at_cursor), a 
1014 18 e5				jr .iskpwm 
1016			 
1016			 
1016 fe 0b		.iskl:		cp KEY_LEFT 
1018 20 27				jr nz, .isk1 
101a			 
101a 3a 58 fe				ld a, (input_cursor) 
101d			 
101d fe 00				cp 0 
101f ca 62 0f				jp z, .is1 		; at start of line to ignore  
1022			 
1022 3d					dec  a 		; TODO check underflow 
1023 32 58 fe				ld (input_cursor), a 
1026			 
1026 2a 6c fe				ld hl, (input_ptr) 
1029 2b					dec hl 
102a 22 6c fe				ld (input_ptr), hl 
102d					 
102d 3a 65 fe				ld a, (input_at_cursor) 
1030 3d					dec a 
1031 32 65 fe				ld (input_at_cursor), a 
1034			 
1034 3e 01				ld a, 1		; show cursor moving 
1036 32 62 fe				ld (input_cur_onoff),a 
1039 3e 0f				ld a, CUR_BLINK_RATE 
103b 32 63 fe				ld (input_cur_flash), a 
103e			 
103e c3 62 0f				jp .is1 
1041			 
1041 fe 0c		.isk1:		cp KEY_RIGHT 
1043 20 2a				jr nz, .isk2 
1045			 
1045 3a 5d fe				ld a,(input_len)		; TODO BUG why cant i load e direct? 
1048 5f					ld e,a 
1049 3a 58 fe				ld a, (input_cursor) 
104c bb					cp e 
104d ca 62 0f				jp z, .is1		; at the end of string so dont go right 
1050			 
1050 3c					inc  a 		; TODO check overflow 
1051 32 58 fe				ld (input_cursor), a 
1054			 
1054 3a 65 fe				ld a, (input_at_cursor) 
1057 3c					inc a 
1058 32 65 fe				ld (input_at_cursor), a 
105b			 
105b 2a 6c fe				ld hl, (input_ptr) 
105e 23					inc hl 
105f 22 6c fe				ld (input_ptr), hl 
1062			 
1062 3e 01				ld a, 1		; show cursor moving 
1064 32 62 fe				ld (input_cur_onoff),a 
1067 3e 0f				ld a, CUR_BLINK_RATE 
1069 32 63 fe				ld (input_cur_flash), a 
106c			 
106c c3 62 0f				jp .is1 
106f			 
106f fe 05		.isk2:		cp KEY_UP 
1071			 
1071 20 26				jr nz, .isk3 
1073			 
1073					; swap last command with the current on 
1073			 
1073					; move cursor to start of string 
1073 2a 6a fe				ld hl, (input_start) 
1076 22 6c fe				ld (input_ptr), hl 
1079			 
1079 3a 67 fe				ld a, (input_at_pos) 
107c 32 65 fe				ld (input_at_cursor), a 
107f			 
107f 3e 00				ld a, 0 
1081 32 58 fe				ld (input_cursor), a 
1084					 
1084					; swap input and last command buffers 
1084			 
1084 21 24 f5				ld hl, os_cli_cmd 
1087 11 23 f6				ld de, os_last_cmd 
108a 06 ff				ld b, 255 
108c 7e			.swap1:		ld a, (hl) 
108d 4f					ld c,a 
108e 1a					ld a, (de) 
108f 77					ld (hl), a 
1090 79					ld a,c 
1091 12					ld (de),a 
1092 23					inc hl 
1093 13					inc de 
1094 10 f6				djnz .swap1 
1096			 
1096			 
1096			 
1096			 
1096			 
1096 c3 62 0f				jp .is1 
1099			 
1099 fe 08		.isk3:		cp KEY_BS 
109b 20 3c				jr nz, .isk4 
109d			 
109d 3a 58 fe				ld a, (input_cursor) 
10a0			 
10a0 fe 00				cp 0 
10a2 ca 62 0f				jp z, .is1 		; at start of line to ignore  
10a5			 
10a5 3d					dec  a 		; TODO check underflow 
10a6 32 58 fe				ld (input_cursor), a 
10a9			 
10a9					; hl is source 
10a9					; de needs to be source - 1 
10a9			 
10a9			;		ld a, 0 
10a9			;		dec hl 
10a9			;		ld (hl), a 
10a9			 
10a9 2a 6c fe				ld hl, (input_ptr) 
10ac 2b					dec hl 
10ad 22 6c fe				ld (input_ptr), hl 
10b0			 
10b0					; shift all data 
10b0			 
10b0 e5					push hl 
10b1 23					inc hl 
10b2 d1					pop de 
10b3 3a 5d fe				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
10b6 4f					ld c,a 
10b7 06 00				ld b,0 
10b9 ed b0				ldir  
10bb			 
10bb			 
10bb			 
10bb			 
10bb 3a 65 fe				ld a, (input_at_cursor) 
10be 3d					dec a 
10bf 32 65 fe				ld (input_at_cursor), a 
10c2			 
10c2			 
10c2 3e 01				ld a, 1		; show cursor moving 
10c4 32 62 fe				ld (input_cur_onoff),a 
10c7 3e 0f				ld a, CUR_BLINK_RATE 
10c9 32 63 fe				ld (input_cur_flash), a 
10cc			 
10cc					; remove char 
10cc 3a 65 fe				ld a, (input_at_cursor) 
10cf 3c					inc a 
10d0 11 5a 11				ld de,.iblank 
10d3 cd e3 0c				call str_at_display 
10d6			 
10d6 c3 62 0f				jp .is1 
10d9			 
10d9 fe 0d		.isk4:		cp KEY_CR 
10db 28 6c				jr z, .endinput 
10dd			 
10dd					; else add the key press to the end 
10dd			 
10dd 4f					ld c, a			; save key pressed 
10de			 
10de 7e					ld a,(hl)		; get what is currently under char 
10df			 
10df fe 00				cp 0			; we are at the end of the string 
10e1 20 2f				jr nz, .onchar 
10e3					 
10e3					; add a char to the end of the string 
10e3				 
10e3 71					ld (hl),c 
10e4 23					inc hl 
10e5			;		ld a,' ' 
10e5			;		ld (hl),a 
10e5			;		inc hl 
10e5 3e 00				ld a,0 
10e7 77					ld (hl),a 
10e8 2b					dec hl 
10e9			 
10e9 3a 58 fe				ld a, (input_cursor) 
10ec 3c					inc a				; TODO check max string length and scroll  
10ed 32 58 fe				ld (input_cursor), a		; inc cursor pos 
10f0							 
10f0 3a 65 fe				ld a, (input_at_cursor) 
10f3 3c					inc a 
10f4 32 65 fe				ld (input_at_cursor), a 
10f7			 
10f7 2a 6c fe				ld hl, (input_ptr) 
10fa 23					inc hl 
10fb 22 6c fe				ld (input_ptr), hl 
10fe			 
10fe 2a 6c fe				ld hl, (input_ptr) 
1101 23					inc hl 
1102 22 6c fe				ld (input_ptr), hl 
1105			;	if DEBUG_INPUT 
1105			;		push af 
1105			;		ld a, '+' 
1105			;		ld (debug_mark),a 
1105			;		pop af 
1105			;		CALLMONITOR 
1105			;	endif 
1105 3e 01				ld a, 1		; show cursor moving 
1107 32 62 fe				ld (input_cur_onoff),a 
110a 3e 0f				ld a, CUR_BLINK_RATE 
110c 32 63 fe				ld (input_cur_flash), a 
110f c3 62 0f				jp .is1 
1112					 
1112			 
1112			 
1112					; if on a char then insert 
1112			.onchar: 
1112			 
1112					; TODO over flow check: make sure insert does not blow out buffer 
1112			 
1112					; need to do some maths to use lddr 
1112			 
1112 e5					push hl   ; save char pos 
1113 c5					push bc 
1114			 
1114 2a 6a fe				ld hl, (input_start) 
1117 3a 5d fe				ld a, (input_len) 
111a cd 04 0f				call addatohl  		; end of string 
111d 23					inc hl 
111e 23					inc hl		; past zero term 
111f e5					push hl 
1120 23					inc hl 
1121 e5					push hl  
1122			 
1122								; start and end of lddr set, now how much to move? 
1122			 
1122							 
1122 3a 58 fe				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
1125 47					ld b,a 
1126 3a 5d fe				ld a,(input_len) 
1129 5f					ld e,a 
112a 90					sub b 
112b 3c					inc a		;?? 
112c 3c					inc a		;?? 
112d 3c					inc a		;?? 
112e			 
112e 06 00				ld b,0 
1130 4f					ld c,a 
1131			 
1131				if DEBUG_INPUT 
1131					push af 
1131					ld a, 'i' 
1131					ld (debug_mark),a 
1131					pop af 
1131			;		CALLMONITOR 
1131				endif 
1131 d1					pop de 
1132 e1					pop hl 
1133				if DEBUG_INPUT 
1133					push af 
1133					ld a, 'I' 
1133					ld (debug_mark),a 
1133					pop af 
1133			;		CALLMONITOR 
1133				endif 
1133 ed b8				lddr 
1135				 
1135			 
1135			 
1135					; TODO have a key for insert/overwrite mode???? 
1135 c1					pop bc 
1136 e1					pop hl 
1137 71					ld (hl), c		; otherwise overwrite current char 
1138					 
1138			 
1138			 
1138			 
1138 3a 58 fe				ld a, (input_cursor) 
113b 3c					inc  a 		; TODO check overflow 
113c 32 58 fe				ld (input_cursor), a 
113f			 
113f 3a 65 fe				ld a, (input_at_cursor) 
1142 3c					inc a 
1143 32 65 fe				ld (input_at_cursor), a 
1146			 
1146 c3 62 0f				jp .is1 
1149			 
1149			.endinput:	; TODO look for end of string 
1149			 
1149					; add trailing space for end of token 
1149			 
1149 2a 6a fe				ld hl, (input_start) 
114c 3a 5d fe				ld a,(input_len) 
114f cd 04 0f				call addatohl 
1152 3e 20				ld a, ' ' 
1154 77					ld (hl),a 
1155					; TODO eof of parse marker 
1155			 
1155 23					inc hl 
1156 3e 00				ld a, 0 
1158 77					ld (hl),a 
1159			 
1159			 
1159 c9					ret 
115a			 
115a .. 00		.iblank: db " ",0 
115c			 
115c			 
115c 32 67 fe		input_str_prev:	ld (input_at_pos), a 
115f 22 6a fe				ld (input_start), hl 
1162 3e 01				ld a,1			; add cursor 
1164 77					ld (hl),a 
1165 23					inc hl 
1166 3e 00				ld a,0 
1168 77					ld (hl),a 
1169 22 6c fe				ld (input_ptr), hl 
116c 7a					ld a,d 
116d 32 69 fe				ld (input_size), a 
1170 3e 00				ld a,0 
1172 32 58 fe				ld (input_cursor),a 
1175			.instr1:	 
1175			 
1175					; TODO do block cursor 
1175					; TODO switch cursor depending on the modifer key 
1175			 
1175					; update cursor shape change on key hold 
1175			 
1175 2a 6c fe				ld hl, (input_ptr) 
1178 2b					dec hl 
1179 3a c7 fb				ld a,(cursor_shape) 
117c 77					ld (hl), a 
117d			 
117d					; display entered text 
117d 3a 67 fe				ld a,(input_at_pos) 
1180 cd 0d 6b		            	CALL fLCD_Pos       ;Position cursor to location in A 
1183 ed 5b 6a fe	            	LD   de, (input_start) 
1187 cd 2f 6b		            	CALL fLCD_Str       ;Display string pointed to by DE 
118a			 
118a cd 49 6d				call cin 
118d fe 00				cp 0 
118f 28 e4				jr z, .instr1 
1191			 
1191					; proecess keyboard controls first 
1191			 
1191 2a 6c fe				ld hl,(input_ptr) 
1194			 
1194 fe 0d				cp KEY_CR	 ; pressing enter ends input 
1196 28 5a				jr z, .instrcr 
1198			 
1198 fe 08				cp KEY_BS 	; back space 
119a 20 0f				jr nz, .instr2 
119c					; process back space 
119c			 
119c					; TODO stop back space if at start of string 
119c 2b					dec hl 
119d 2b					dec hl ; to over write cursor 
119e 3a c7 fb				ld a,(cursor_shape) 
11a1					;ld a,0 
11a1 77					ld (hl),a 
11a2 23					inc hl 
11a3 3e 20				ld a," " 
11a5 77					ld (hl),a 
11a6 22 6c fe				ld (input_ptr),hl 
11a9					 
11a9			 
11a9 18 ca				jr .instr1 
11ab			 
11ab fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
11ad 20 06				jr nz, .instr3 
11af 2b					dec hl 
11b0 22 6c fe				ld (input_ptr),hl 
11b3 18 c0				jr .instr1 
11b5				 
11b5 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
11b7 20 06				jr nz, .instr4 
11b9 23					inc hl 
11ba 22 6c fe				ld (input_ptr),hl 
11bd 18 b6				jr .instr1 
11bf			 
11bf fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
11c1 20 06				jr nz, .instr5 
11c3 2b					dec hl 
11c4 22 6c fe				ld (input_ptr),hl 
11c7 18 ac				jr .instr1 
11c9			 
11c9 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
11cb 20 06				jr nz, .instr6 
11cd 2b					dec hl 
11ce 22 6c fe				ld (input_ptr),hl 
11d1 18 a2				jr .instr1 
11d3 fe 05		.instr6:        cp KEY_UP      ; recall last command 
11d5 20 0b				jr nz, .instrnew 
11d7			 
11d7 21 fd f1			ld hl, scratch 
11da 11 23 f6			ld de, os_last_cmd 
11dd cd fb 11			call strcpy 
11e0 18 93				jr .instr1 
11e2			 
11e2			 
11e2			.instrnew:	; no special key pressed to see if we have room to store it 
11e2			 
11e2					; TODO do string size test 
11e2			 
11e2 2b					dec hl ; to over write cursor 
11e3 77					ld (hl),a 
11e4 23					inc hl 
11e5 3a c7 fb				ld a,(cursor_shape) 
11e8 77					ld (hl),a 
11e9 23					inc hl 
11ea 3e 00				ld a,0 
11ec 77					ld (hl),a 
11ed			 
11ed 22 6c fe				ld (input_ptr),hl 
11f0					 
11f0 18 83				jr .instr1 
11f2 2b			.instrcr:	dec hl		; remove cursor 
11f3 3e 20				ld a,' '	; TODO add a trailing space for safety 
11f5 77					ld (hl),a 
11f6 23					inc hl 
11f7 3e 00				ld a,0 
11f9 77					ld (hl),a 
11fa			 
11fa			 
11fa					; if at end of line scroll up    
11fa					; TODO detecting only end of line 4 for scroll up  
11fa			 
11fa					;ld   
11fa			 
11fa c9					ret 
11fb			 
11fb			 
11fb			; strcpy hl = dest, de source 
11fb			 
11fb 1a			strcpy:   LD   A, (DE)        ;Get character from string 
11fc b7			            OR   A              ;Null terminator? 
11fd c8			            RET  Z              ;Yes, so finished 
11fe 1a					ld a,(de) 
11ff 77					ld (hl),a 
1200 13			            INC  DE             ;Point to next character 
1201 23					inc hl 
1202 18 f7		            JR   strcpy       ;Repeat 
1204 c9					ret 
1205			 
1205			 
1205			; TODO string_at  
1205			; pass string which starts with lcd offset address and then null term string 
1205			 
1205			; TODO string to dec 
1205			; TODO string to hex 
1205			; TODO byte to string hex 
1205			; TODO byte to string dec 
1205			 
1205			 
1205			 
1205			; from z80uartmonitor 
1205			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1205			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
1205			; pass hl for where to put the text 
1205			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1205 c5			hexout:	PUSH BC 
1206 f5					PUSH AF 
1207 47					LD B, A 
1208					; Upper nybble 
1208 cb 3f				SRL A 
120a cb 3f				SRL A 
120c cb 3f				SRL A 
120e cb 3f				SRL A 
1210 cd 20 12				CALL tohex 
1213 77					ld (hl),a 
1214 23					inc hl	 
1215					 
1215					; Lower nybble 
1215 78					LD A, B 
1216 e6 0f				AND 0FH 
1218 cd 20 12				CALL tohex 
121b 77					ld (hl),a 
121c 23					inc hl	 
121d					 
121d f1					POP AF 
121e c1					POP BC 
121f c9					RET 
1220					 
1220			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1220			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
1220			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1220			tohex: 
1220 e5					PUSH HL 
1221 d5					PUSH DE 
1222 16 00				LD D, 0 
1224 5f					LD E, A 
1225 21 2d 12				LD HL, .DATA 
1228 19					ADD HL, DE 
1229 7e					LD A, (HL) 
122a d1					POP DE 
122b e1					POP HL 
122c c9					RET 
122d			 
122d			.DATA: 
122d 30					DEFB	30h	; 0 
122e 31					DEFB	31h	; 1 
122f 32					DEFB	32h	; 2 
1230 33					DEFB	33h	; 3 
1231 34					DEFB	34h	; 4 
1232 35					DEFB	35h	; 5 
1233 36					DEFB	36h	; 6 
1234 37					DEFB	37h	; 7 
1235 38					DEFB	38h	; 8 
1236 39					DEFB	39h	; 9 
1237 41					DEFB	41h	; A 
1238 42					DEFB	42h	; B 
1239 43					DEFB	43h	; C 
123a 44					DEFB	44h	; D 
123b 45					DEFB	45h	; E 
123c 46					DEFB	46h	; F 
123d			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
123d			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
123d			;;    subtract $30, if result > 9 then subtract $7 more 
123d			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
123d			atohex: 
123d d6 30				SUB $30 
123f fe 0a				CP 10 
1241 f8					RET M		; If result negative it was 0-9 so we're done 
1242 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
1244 c9					RET		 
1245			 
1245			 
1245			 
1245			 
1245			; Get 2 ASCII characters as hex byte from pointer in hl 
1245			 
1245			BYTERD: 
1245 16 00			LD	D,00h		;Set up 
1247 cd 4f 12			CALL	HEXCON		;Get byte and convert to hex 
124a 87				ADD	A,A		;First nibble so 
124b 87				ADD	A,A		;multiply by 16 
124c 87				ADD	A,A		; 
124d 87				ADD	A,A		; 
124e 57				LD	D,A		;Save hi nibble in D 
124f			HEXCON: 
124f 7e				ld a, (hl)		;Get next chr 
1250 23				inc hl 
1251 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
1253 fe 0a			CP	00Ah		;Is it 0-9 ? 
1255 38 02			JR	C,NALPHA	;If so miss next bit 
1257 d6 07			SUB	007h		;Else convert alpha 
1259			NALPHA: 
1259 b2				OR	D		;Add hi nibble back 
125a c9				RET			; 
125b			 
125b			 
125b			; 
125b			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
125b			; Since the routines get_byte and therefore get_nibble are called, only valid 
125b			; characters (0-9a-f) are accepted. 
125b			; 
125b			;get_word        push    af 
125b			;                call    get_byte        ; Get the upper byte 
125b			;                ld      h, a 
125b			;                call    get_byte        ; Get the lower byte 
125b			;                ld      l, a 
125b			;                pop     af 
125b			;                ret 
125b			; 
125b			; Get a byte in hexadecimal notation. The result is returned in A. Since 
125b			; the routine get_nibble is used only valid characters are accepted - the  
125b			; input routine only accepts characters 0-9a-f. 
125b			; 
125b c5			get_byte:        push    bc              ; Save contents of B (and C) 
125c 7e					ld a,(hl) 
125d 23					inc hl 
125e cd 83 12		                call    nibble2val      ; Get upper nibble 
1261 cb 07		                rlc     a 
1263 cb 07		                rlc     a 
1265 cb 07		                rlc     a 
1267 cb 07		                rlc     a 
1269 47			                ld      b, a            ; Save upper four bits 
126a 7e					ld a,(hl) 
126b cd 83 12		                call    nibble2val      ; Get lower nibble 
126e b0			                or      b               ; Combine both nibbles 
126f c1			                pop     bc              ; Restore B (and C) 
1270 c9			                ret 
1271			; 
1271			; Get a hexadecimal digit from the serial line. This routine blocks until 
1271			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
1271			; to the serial line interface. The lower 4 bits of A contain the value of  
1271			; that particular digit. 
1271			; 
1271			;get_nibble      ld a,(hl)           ; Read a character 
1271			;                call    to_upper        ; Convert to upper case 
1271			;                call    is_hex          ; Was it a hex digit? 
1271			;                jr      nc, get_nibble  ; No, get another character 
1271			 ;               call    nibble2val      ; Convert nibble to value 
1271			 ;               call    print_nibble 
1271			 ;               ret 
1271			; 
1271			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
1271			; A valid hexadecimal digit is denoted by a set C flag. 
1271			; 
1271			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
1271			;                ret     nc              ; Yes 
1271			;                cp      '0'             ; Less than '0'? 
1271			;                jr      nc, is_hex_1    ; No, continue 
1271			;                ccf                     ; Complement carry (i.e. clear it) 
1271			;                ret 
1271			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
1271			;                ret     c               ; Yes 
1271			;                cp      'A'             ; Less than 'A'? 
1271			;                jr      nc, is_hex_2    ; No, continue 
1271			;                ccf                     ; Yes - clear carry and return 
1271			;                ret 
1271			;is_hex_2        scf                     ; Set carry 
1271			;                ret 
1271			; 
1271			; Convert a single character contained in A to upper case: 
1271			; 
1271 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
1273 d8			                ret     c 
1274 fe 7b		                cp      'z' + 1         ; > 'z'? 
1276 d0			                ret     nc              ; Nothing to do, either 
1277 e6 5f		                and     $5f             ; Convert to upper case 
1279 c9			                ret 
127a			 
127a			 
127a			to_lower: 
127a			 
127a			   ; if char is in [A-Z] make it lower case 
127a			 
127a			   ; enter : a = char 
127a			   ; exit  : a = lower case char 
127a			   ; uses  : af 
127a			 
127a fe 41		   cp 'A' 
127c d8			   ret c 
127d			    
127d fe 5b		   cp 'Z'+1 
127f d0			   ret nc 
1280			    
1280 f6 20		   or $20 
1282 c9			   ret 
1283			 
1283			; 
1283			; Expects a hexadecimal digit (upper case!) in A and returns the 
1283			; corresponding value in A. 
1283			; 
1283 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
1285 38 02		                jr      c, nibble2val_1 ; Yes 
1287 d6 07		                sub     7               ; Adjust for A-F 
1289 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
128b e6 0f		                and     $f              ; Only return lower 4 bits 
128d c9			                ret 
128e			; 
128e			; Print_nibble prints a single hex nibble which is contained in the lower  
128e			; four bits of A: 
128e			; 
128e			;print_nibble    push    af              ; We won't destroy the contents of A 
128e			;                and     $f              ; Just in case... 
128e			;                add     a, '0'             ; If we have a digit we are done here. 
128e			;                cp      '9' + 1         ; Is the result > 9? 
128e			;                jr      c, print_nibble_1 
128e			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
128e			;print_nibble_1  call    putc            ; Print the nibble and 
128e			;                pop     af              ; restore the original value of A 
128e			;                ret 
128e			;; 
128e			;; Send a CR/LF pair: 
128e			; 
128e			;crlf            push    af 
128e			;                ld      a, cr 
128e			;                call    putc 
128e			;                ld      a, lf 
128e			;                call    putc 
128e			;                pop     af 
128e			;                ret 
128e			; 
128e			; Print_word prints the four hex digits of a word to the serial line. The  
128e			; word is expected to be in HL. 
128e			; 
128e			;print_word      push    hl 
128e			;                push    af 
128e			;                ld      a, h 
128e			;                call    print_byte 
128e			;                ld      a, l 
128e			;                call    print_byte 
128e			;                pop     af 
128e			;                pop     hl 
128e			;                ret 
128e			; 
128e			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
128e			; The byte to be printed is expected to be in A. 
128e			; 
128e			;print_byte      push    af              ; Save the contents of the registers 
128e			;                push    bc 
128e			;                ld      b, a 
128e			;                rrca 
128e			;                rrca 
128e			;                rrca 
128e			;                rrca 
128e			;                call    print_nibble    ; Print high nibble 
128e			;                ld      a, b 
128e			;                call    print_nibble    ; Print low nibble 
128e			;                pop     bc              ; Restore original register contents 
128e			;                pop     af 
128e			;                ret 
128e			 
128e			 
128e			 
128e			 
128e			 
128e			fourehexhl:  
128e 7e				ld a,(hl) 
128f cd 3d 12			call atohex 
1292 cb 3f				SRL A 
1294 cb 3f				SRL A 
1296 cb 3f				SRL A 
1298 cb 3f				SRL A 
129a 47				ld b, a 
129b 23				inc hl 
129c 7e				ld a,(hl) 
129d 23				inc hl 
129e cd 3d 12			call atohex 
12a1 80				add b 
12a2 57				ld d,a 
12a3 7e				ld a,(hl) 
12a4 cd 3d 12			call atohex 
12a7 cb 3f				SRL A 
12a9 cb 3f				SRL A 
12ab cb 3f				SRL A 
12ad cb 3f				SRL A 
12af 47				ld b, a 
12b0 23				inc hl 
12b1 7e				ld a,(hl) 
12b2 23				inc hl 
12b3 cd 3d 12			call atohex 
12b6 80				add b 
12b7 5f				ld e, a 
12b8 d5				push de 
12b9 e1				pop hl 
12ba c9				ret 
12bb			 
12bb			; pass hl. returns z set if the byte at hl is a digit 
12bb			;isdigithl:  
12bb			;	push bc 
12bb			;	ld a,(hl) 
12bb			;	cp ':' 
12bb			;	jr nc, .isdf 		; > 
12bb			;	cp '0' 
12bb			;	jr c, .isdf		; < 
12bb			; 
12bb			;	; TODO find a better way to set z 
12bb			; 
12bb			;	ld b,a 
12bb			;	cp b 
12bb			;	pop bc 
12bb			;	ret 
12bb			; 
12bb			;.isdf:	; not digit so clear z 
12bb			; 
12bb			;	; TODO find a better way to unset z 
12bb			; 
12bb			;	ld b,a 
12bb			;	inc b 
12bb			;	cp b 
12bb			; 
12bb			;	pop bc 
12bb			;	ret 
12bb				 
12bb				 
12bb			 
12bb			 
12bb			; pass hl as the four byte address to load 
12bb			 
12bb			get_word_hl:  
12bb e5				push hl 
12bc cd 5b 12			call get_byte 
12bf				 
12bf 47				ld b, a 
12c0			 
12c0 e1				pop hl 
12c1 23				inc hl 
12c2 23				inc hl 
12c3			 
12c3			; TODO not able to handle a-f  
12c3 7e				ld a,(hl) 
12c4			;	;cp ':' 
12c4			;	cp 'g' 
12c4			;	jr nc, .single_byte_hl 		; > 
12c4			;	cp 'G' 
12c4			;	jr nc, .single_byte_hl 		; > 
12c4			;	cp '0' 
12c4			;	jr c, .single_byte_hl		; < 
12c4			 
12c4				;call isdigithl 
12c4 fe 00			cp 0 
12c6 28 06			jr z, .single_byte_hl 
12c8			 
12c8			.getwhln:   ; hex word so get next byte 
12c8			 
12c8 cd 5b 12			call get_byte 
12cb 6f				ld l, a 
12cc 60				ld h,b 
12cd c9				ret 
12ce 68			.single_byte_hl:   ld l,b 
12cf 26 00				ld h,0 
12d1 c9					ret 
12d2			 
12d2			 
12d2			 
12d2			 
12d2 21 36 1c			ld hl,asc+1 
12d5			;	ld a, (hl) 
12d5			;	call nibble2val 
12d5 cd 5b 12			call get_byte 
12d8			 
12d8			;	call fourehexhl 
12d8 32 31 f2			ld (scratch+52),a 
12db				 
12db 21 2f f2			ld hl,scratch+50 
12de 22 20 f5			ld (os_cur_ptr),hl 
12e1			 
12e1 c9				ret 
12e2			 
12e2			 
12e2			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
12e2			 
12e2			; Decimal Unsigned Version 
12e2			 
12e2			;Number in a to decimal ASCII 
12e2			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
12e2			;Example: display a=56 as "056" 
12e2			;input: a = number 
12e2			;Output: a=0,value of a in the screen 
12e2			;destroys af,bc (don't know about hl and de) 
12e2			DispAToASCII: 
12e2 0e 9c			ld	c,-100 
12e4 cd ee 12			call	.Na1 
12e7 0e f6			ld	c,-10 
12e9 cd ee 12			call	.Na1 
12ec 0e ff			ld	c,-1 
12ee 06 2f		.Na1:	ld	b,'0'-1 
12f0 04			.Na2:	inc	b 
12f1 81				add	a,c 
12f2 38 fc			jr	c,.Na2 
12f4 91				sub	c		;works as add 100/10/1 
12f5 f5				push af		;safer than ld c,a 
12f6 78				ld	a,b		;char is in b 
12f7			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
12f7 f1				pop af		;safer than ld a,c 
12f8 c9				ret 
12f9			 
12f9			; Decimal Signed Version 
12f9			 
12f9			; DispA 
12f9			; -------------------------------------------------------------- 
12f9			; Converts a signed integer value to a zero-terminated ASCII 
12f9			; string representative of that value (using radix 10). 
12f9			; -------------------------------------------------------------- 
12f9			; INPUTS: 
12f9			;     HL     Value to convert (two's complement integer). 
12f9			;     DE     Base address of string destination. (pointer). 
12f9			; -------------------------------------------------------------- 
12f9			; OUTPUTS: 
12f9			;     None 
12f9			; -------------------------------------------------------------- 
12f9			; REGISTERS/MEMORY DESTROYED 
12f9			; AF HL 
12f9			; -------------------------------------------------------------- 
12f9			 
12f9			;DispHLToASCII: 
12f9			;   push    de 
12f9			;   push    bc 
12f9			; 
12f9			;; Detect sign of HL. 
12f9			;    bit    7, h 
12f9			;    jr     z, ._DoConvert 
12f9			; 
12f9			;; HL is negative. Output '-' to string and negate HL. 
12f9			;    ld     a, '-' 
12f9			;    ld     (de), a 
12f9			;    inc    de 
12f9			; 
12f9			;; Negate HL (using two's complement) 
12f9			;    xor    a 
12f9			;    sub    l 
12f9			;    ld     l, a 
12f9			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
12f9			;    sbc    a, h 
12f9			;    ld     h, a 
12f9			; 
12f9			;; Convert HL to digit characters 
12f9			;._DoConvert: 
12f9			;    ld     b, 0     ; B will count character length of number 
12f9			;-   ld     a, 10 
12f9			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
12f9			;    push   af 
12f9			;    inc    b 
12f9			;    ld     a, h 
12f9			;    or     l 
12f9			;    jr     nz, - 
12f9			; 
12f9			;; Retrieve digits from stack 
12f9			;-   pop    af 
12f9			;    or     $30 
12f9			;    ld     (de), a 
12f9			;    inc    de 
12f9			;    djnz   - 
12f9			; 
12f9			;; Terminate string with NULL 
12f9			;    xor    a 
12f9			;    ld     (de), a 
12f9			; 
12f9			;    pop    bc 
12f9			;    pop    de 
12f9			;    ret 
12f9			 
12f9			;Comments 
12f9			; 
12f9			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
12f9			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
12f9			;    Note that the output string will not be fixed-width. 
12f9			; 
12f9			;Example Usage 
12f9			; 
12f9			;    ld    hl, -1004 
12f9			;    ld    de, OP1 
12f9			;    call  DispA 
12f9			;    ld    hl, OP1 
12f9			;    syscall  PutS 
12f9			 
12f9			 
12f9			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
12f9			 
12f9			 
12f9			;Converts an ASCII string to an unsigned 16-bit integer 
12f9			;Quits when it reaches a non-decimal digit 
12f9			 
12f9			string_to_uint16: 
12f9			atoui_16: 
12f9			;Input: 
12f9			;     DE points to the string 
12f9			;Outputs: 
12f9			;     HL is the result 
12f9			;     A is the 8-bit value of the number 
12f9			;     DE points to the byte after the number 
12f9			;Destroys: 
12f9			;     BC 
12f9			;       if the string is non-empty, BC is HL/10 
12f9			;Size:  24 bytes 
12f9			;Speed: 42+d(104+{0,9}) 
12f9			;       d is the number of digits in the number 
12f9			;       max is 640 cycles for a 5 digit number 
12f9			;Assuming no leading zeros: 
12f9			;1 digit:  146cc 
12f9			;2 digit:  250cc 
12f9			;3 digit:  354cc or 363cc (avg: 354.126cc) 
12f9			;4 digit:  458cc or 467cc (avg: 458.27cc) 
12f9			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
12f9			;avg: 544.81158447265625cc (544+13297/16384) 
12f9			;=============================================================== 
12f9 21 00 00		  ld hl,0 
12fc			.u16a: 
12fc 1a			  ld a,(de) 
12fd d6 30		  sub 30h 
12ff fe 0a		  cp 10 
1301 d0			  ret nc 
1302 13			  inc de 
1303 44			  ld b,h 
1304 4d			  ld c,l 
1305 29			  add hl,hl 
1306 29			  add hl,hl 
1307 09			  add hl,bc 
1308 29			  add hl,hl 
1309 85			  add a,l 
130a 6f			  ld l,a 
130b 30 ef		  jr nc,.u16a 
130d 24			  inc h 
130e c3 fc 12		  jp .u16a 
1311			 
1311			 
1311			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
1311			 
1311			;written by Zeda 
1311			;Converts a 16-bit unsigned integer to an ASCII string. 
1311			 
1311			uitoa_16: 
1311			;Input: 
1311			;   DE is the number to convert 
1311			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
1311			;Output: 
1311			;   HL points to the null-terminated ASCII string 
1311			;      NOTE: This isn't necessarily the same as the input HL. 
1311 d5			  push de 
1312 c5			  push bc 
1313 f5			  push af 
1314 eb			  ex de,hl 
1315			 
1315 01 f0 d8		  ld bc,-10000 
1318 3e 2f		  ld a,'0'-1 
131a 3c			  inc a 
131b 09			  add hl,bc  
131c 38 fc		   jr c,$-2 
131e 12			  ld (de),a 
131f 13			  inc de 
1320			 
1320 01 e8 03		  ld bc,1000 
1323 3e 3a		  ld a,'9'+1 
1325 3d			  dec a  
1326 09			  add hl,bc  
1327 30 fc		   jr nc,$-2 
1329 12			  ld (de),a 
132a 13			  inc de 
132b			 
132b 01 9c ff		  ld bc,-100 
132e 3e 2f		  ld a,'0'-1 
1330 3c			  inc a  
1331 09			  add hl,bc  
1332 38 fc		   jr c,$-2 
1334 12			  ld (de),a 
1335 13			  inc de 
1336			 
1336 7d			  ld a,l 
1337 26 3a		  ld h,'9'+1 
1339 25			  dec h  
133a c6 0a		  add a,10  
133c 30 fb		   jr nc,$-3 
133e c6 30		  add a,'0' 
1340 eb			  ex de,hl 
1341 72			  ld (hl),d 
1342 23			  inc hl 
1343 77			  ld (hl),a 
1344 23			  inc hl 
1345 36 00		  ld (hl),0 
1347			 
1347			;Now strip the leading zeros 
1347 0e fa		  ld c,-6 
1349 09			  add hl,bc 
134a 3e 30		  ld a,'0' 
134c 23			  inc hl  
134d be			  cp (hl)  
134e 28 fc		  jr z,$-2 
1350			 
1350			;Make sure that the string is non-empty! 
1350 7e			  ld a,(hl) 
1351 b7			  or a 
1352 20 01		  jr nz,.atoub 
1354 2b			  dec hl 
1355			.atoub: 
1355			 
1355 f1			  pop af 
1356 c1			  pop bc 
1357 d1			  pop de 
1358 c9			  ret 
1359			 
1359			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
1359			 
1359			toUpper: 
1359			;A is the char. 
1359			;If A is a lowercase letter, this sets it to the matching uppercase 
1359			;18cc or 30cc or 41cc 
1359			;avg: 26.75cc 
1359 fe 61		  cp 'a' 
135b d8			  ret c 
135c fe 7b		  cp 'z'+1 
135e d0			  ret nc 
135f d6 20		  sub 'a'-'A' 
1361 c9			  ret 
1362			 
1362			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1362			 
1362			; String Length 
1362			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1362			 
1362			; Get the length of the null-terminated string starting at $8000 hl 
1362			;    LD     HL, $8000 
1362			 
1362			strlenz: 
1362			 
1362 af			    XOR    A               ; Zero is the value we are looking for. 
1363 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1364 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1365			                           ; 65, 536 bytes (the entire addressable memory space). 
1365 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1367			 
1367			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1367 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
1368 6f			    LD     L, A             ; number of bytes 
1369 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
136b 2b			    DEC    HL              ; Compensate for null. 
136c c9				ret 
136d			 
136d			; Get the length of the A terminated string starting at $8000 hl 
136d			;    LD     HL, $8000 
136d			 
136d			strlent: 
136d			 
136d			                  ; A is the value we are looking for. 
136d 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
136f 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1371			                           ; 65, 536 bytes (the entire addressable memory space). 
1371 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1373			 
1373			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1373 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1375 2e 00		    LD     L, 0             ; number of bytes 
1377 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1379 2b			    DEC    HL              ; Compensate for null. 
137a c9				ret 
137b			 
137b			 
137b			;Comparing Strings 
137b			 
137b			;IN    HL     Address of string1. 
137b			;      DE     Address of string2. 
137b			 
137b			; doc given but wrong??? 
137b			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
137b			;      carry  Set if string1 > string2, reset if string1 <= string2. 
137b			; tested 
137b			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
137b			 
137b			strcmp_old: 
137b e5			    PUSH   HL 
137c d5			    PUSH   DE 
137d			 
137d 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
137e be			    CP     (HL)            ; (want to minimize work). 
137f 38 01		    JR     C, Str1IsBigger 
1381 7e			    LD     A, (HL) 
1382			 
1382			Str1IsBigger: 
1382 4f			    LD     C, A             ; Put length in BC 
1383 06 00		    LD     B, 0 
1385 13			    INC    DE              ; Increment pointers to meat of string. 
1386 23			    INC    HL 
1387			 
1387			CmpLoop: 
1387 1a			    LD     A, (DE)          ; Compare bytes. 
1388 ed a1		    CPI 
138a 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
138c 13			    INC    DE              ; Update pointer. 
138d ea 87 13		    JP     PE, CmpLoop 
1390			 
1390 d1			    POP    DE 
1391 e1			    POP    HL 
1392 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
1393 be			    CP     (HL) 
1394 c9			    RET 
1395			 
1395			NoMatch: 
1395 2b			    DEC    HL 
1396 be			    CP     (HL)            ; Compare again to affect carry. 
1397 d1			    POP    DE 
1398 e1			    POP    HL 
1399 c9			    RET 
139a			 
139a			;; test strmp 
139a			; 
139a			;ld de, .str1 
139a			;ld hl, .str2 
139a			;call strcmp 
139a			;jr z, .z1 
139a			;;this 
139a			;	if DEBUG_FORTH_WORDS 
139a			;		DMARK "NZ1" 
139a			;		CALLMONITOR 
139a			;	endif 
139a			;.z1: 
139a			; 
139a			;	if DEBUG_FORTH_WORDS 
139a			;		DMARK "ZZ1" 
139a			;		CALLMONITOR 
139a			;	endif 
139a			; 
139a			;ld de, .str1 
139a			;ld hl, .str1 
139a			;call strcmp 
139a			;jr z, .z2 
139a			;;this 
139a			;	if DEBUG_FORTH_WORDS 
139a			;		DMARK "NZ2" 
139a			;		CALLMONITOR 
139a			;	endif 
139a			;.z2: 
139a			; 
139a			;	if DEBUG_FORTH_WORDS 
139a			;		DMARK "ZZ2" 
139a			;		CALLMONITOR 
139a			;	endif 
139a			; 
139a			;ld de, .str1 
139a			;ld hl, .str2 
139a			;call strcmp 
139a			;jr c, .c1 
139a			; 
139a			;	if DEBUG_FORTH_WORDS 
139a			;		DMARK "Nc1" 
139a			;		CALLMONITOR 
139a			;	endif 
139a			;.c1: 
139a			;;this 
139a			;	if DEBUG_FORTH_WORDS 
139a			;		DMARK "cc1" 
139a			;		CALLMONITOR 
139a			;	endif 
139a			; 
139a			;ld de, .str1 
139a			;ld hl, .str1 
139a			;call strcmp 
139a			;jr c, .c2 
139a			;;this 
139a			;	if DEBUG_FORTH_WORDS 
139a			;		DMARK "Nc2" 
139a			;		CALLMONITOR 
139a			;	endif 
139a			;.c2: 
139a			; 
139a			;	if DEBUG_FORTH_WORDS 
139a			;		DMARK "cc2" 
139a			;		CALLMONITOR 
139a			;	endif 
139a			;	NEXTW 
139a			;.str1:   db "string1",0 
139a			;.str2:   db "string2",0 
139a			 
139a			; only care about direct match or not 
139a			; hl and de strings 
139a			; zero set if the same 
139a			 
139a			strcmp: 
139a 1a				ld a, (de) 
139b be				cp (hl) 
139c 28 02			jr z, .ssame 
139e b7				or a 
139f c9				ret 
13a0			 
13a0			.ssame:  
13a0 fe 00			cp 0 
13a2 c8				ret z 
13a3			 
13a3 23				inc hl 
13a4 13				inc de 
13a5 18 f3			jr strcmp 
13a7				 
13a7				 
13a7			 
13a7			 
13a7			 
13a7			 
13a7			; eof 
13a7			 
13a7			 
13a7			 
13a7			 
13a7			 
13a7			 
# End of file firmware_strings.asm
13a7			include "firmware_memory.asm"   ; malloc and free  
13a7			 
13a7			if DEBUG_FORTH_MALLOC_HIGH 
13a7			.mallocsize: db "Wants malloc >256",0 
13a7			.mallocasize: db "MALLOC gives >256",0 
13a7			.malloczero: db "MALLOC gives zero",0 
13a7			 
13a7			malloc_guard_zerolen: 
13a7				push hl 
13a7				push de 
13a7				push af 
13a7			 
13a7				ld de, 0 
13a7			        call cmp16 
13a7				jr nz, .lowalloz 
13a7			 
13a7				push hl 
13a7				push de 
13a7					ld hl, display_fb0 
13a7					ld (display_fb_active), hl 
13a7				call clear_display 
13a7				ld a, 0 
13a7				ld de, .malloczero 
13a7				call str_at_display 
13a7				call update_display 
13a7				call delay1s 
13a7				call delay1s 
13a7				ld a, 0 
13a7				ld (os_view_disable), a 
13a7			 
13a7				pop de 
13a7				pop hl 
13a7			 
13a7				 
13a7			 
13a7				CALLMONITOR 
13a7			.lowalloz: 
13a7			 
13a7			 
13a7				pop af 
13a7				pop de 
13a7				pop hl 
13a7			ret 
13a7			 
13a7			malloc_guard_entry: 
13a7				push hl 
13a7				push de 
13a7				push af 
13a7			 
13a7			 	or a      ;clear carry flag 
13a7				push hl 
13a7				ld de, 255 
13a7				sbc hl, de 
13a7				jr c, .lowalloc 
13a7			 
13a7				push de 
13a7					ld hl, display_fb0 
13a7					ld (display_fb_active), hl 
13a7				call clear_display 
13a7				ld a, 0 
13a7				ld de, .mallocsize 
13a7				call str_at_display 
13a7				call update_display 
13a7				call delay1s 
13a7				call delay1s 
13a7				ld a, 0 
13a7				ld (os_view_disable), a 
13a7			 
13a7				pop de 
13a7				pop hl 
13a7			 
13a7				 
13a7			 
13a7				CALLMONITOR 
13a7				jr .lowdone 
13a7			.lowalloc: 
13a7			 
13a7			 
13a7				pop hl 
13a7			.lowdone:	pop af 
13a7				pop de 
13a7				pop hl 
13a7			ret 
13a7			 
13a7			malloc_guard_exit: 
13a7				push hl 
13a7				push de 
13a7				push af 
13a7			 
13a7			 	or a      ;clear carry flag 
13a7				push hl 
13a7				ld de, 255 
13a7				sbc hl, de 
13a7				jr c, .lowallocx 
13a7			 
13a7				push de 
13a7					ld hl, display_fb0 
13a7					ld (display_fb_active), hl 
13a7				call clear_display 
13a7				ld a, 0 
13a7				ld de, .mallocasize 
13a7				call str_at_display 
13a7				call update_display 
13a7				call delay1s 
13a7				call delay1s 
13a7				ld a, 0 
13a7				ld (os_view_disable), a 
13a7				pop de 
13a7				pop hl 
13a7			 
13a7				CALLMONITOR 
13a7				jr .lowdonex 
13a7			.lowallocx: 
13a7			 
13a7				pop hl 
13a7			.lowdonex:	pop af 
13a7				pop de 
13a7				pop hl 
13a7			ret 
13a7			endif 
13a7			 
13a7			if MALLOC_2 
13a7			; Z80 Malloc and Free Functions 
13a7			 
13a7			; Malloc Function: 
13a7			; Input: 
13a7			;   HL: Size of block to allocate 
13a7			; Output: 
13a7			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
13a7			 
13a7			malloc: 
13a7				 
13a7			if DEBUG_FORTH_MALLOC_HIGH 
13a7			call malloc_guard_entry 
13a7			endif 
13a7			 
13a7			 
13a7			 
13a7			 
13a7					if DEBUG_FORTH_MALLOC 
13a7						DMARK "mal" 
13a7						CALLMONITOR 
13a7					endif 
13a7			    push af            ; Save AF register 
13a7			    ld a, l            ; Load low byte of size into A 
13a7			    or h               ; Check if size is zero 
13a7			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
13a7			 
13a7			    ; Allocate memory 
13a7			    ld hl, (heap_start) ; Load start of heap into HL 
13a7					if DEBUG_FORTH_MALLOC 
13a7						DMARK "ma1" 
13a7						CALLMONITOR 
13a7					endif 
13a7			    call malloc_internal ; Call internal malloc function 
13a7			    pop af             ; Restore AF register 
13a7			if DEBUG_FORTH_MALLOC_HIGH 
13a7			call malloc_guard_exit 
13a7			call malloc_guard_zerolen 
13a7			endif 
13a7			    ret                ; Return 
13a7			 
13a7			; Free Function: 
13a7			; Input: 
13a7			;   HL: Pointer to memory block to free 
13a7			; Output: 
13a7			;   None 
13a7			 
13a7			free: 
13a7			    push af            ; Save AF register 
13a7			    ld a, l            ; Load low byte of pointer into A 
13a7			    or h               ; Check if pointer is NULL 
13a7			    jp z, free_exit    ; If pointer is NULL, exit 
13a7			 
13a7			    ; Free memory 
13a7			    ld hl, (heap_start) ; Load start of heap into HL 
13a7			    call free_internal  ; Call internal free function 
13a7			    pop af             ; Restore AF register 
13a7			    ret                ; Return 
13a7			 
13a7			; Internal Malloc Function: 
13a7			; Input: 
13a7			;   HL: Size of block to allocate 
13a7			; Output: 
13a7			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
13a7			 
13a7			malloc_internal: 
13a7			    ld bc, 2           ; Number of bytes to allocate for management overhead 
13a7			    add hl, bc         ; Add management overhead to requested size 
13a7			    ex de, hl          ; Save total size in DE, and keep it in HL 
13a7					if DEBUG_FORTH_MALLOC 
13a7						DMARK "ma2" 
13a7						CALLMONITOR 
13a7					endif 
13a7			 
13a7			    ; Search for free memory block 
13a7			    ld de, (heap_end)  ; Load end of heap into DE 
13a7			    ld bc, 0           ; Initialize counter 
13a7			 
13a7					if DEBUG_FORTH_MALLOC 
13a7						DMARK "ma2" 
13a7						CALLMONITOR 
13a7					endif 
13a7			malloc_search_loop: 
13a7			    ; Check if current block is free 
13a7			    ld a, (hl)         ; Load current block's status (free or used) 
13a7			    cp 0               ; Compare with zero (free) 
13a7			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
13a7			 
13a7			    ; Check if current block is large enough 
13a7			    ld a, (hl+1)       ; Load high byte of block size 
13a7			    cp l               ; Compare with low byte of requested size 
13a7			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
13a7			 
13a7			    ld a, (hl+2)       ; Load low byte of block size 
13a7			    cp h               ; Compare with high byte of requested size 
13a7			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
13a7			 
13a7			    ; Mark block as used 
13a7			    ld (hl), 0xFF      ; Set status byte to indicate used block 
13a7			 
13a7			    ; Calculate remaining space in block 
13a7			    ld bc, 0           ; Clear BC 
13a7			    add hl, bc         ; Increment HL to point to start of data block 
13a7			    add hl, de         ; HL = HL + DE (total size) 
13a7			    ld bc, 1           ; Number of bytes to allocate for management overhead 
13a7			    add hl, bc         ; Add management overhead to start of data block 
13a7			 
13a7			    ; Save pointer to allocated block in HL 
13a7			if DEBUG_FORTH_MALLOC_HIGH 
13a7						DMARK "ma5" 
13a7			call malloc_guard_exit 
13a7			call malloc_guard_zerolen 
13a7			endif 
13a7			    ret 
13a7			 
13a7			malloc_skip_block_check: 
13a7			    ; Move to the next block 
13a7			    ld bc, 3           ; Size of management overhead 
13a7			    add hl, bc         ; Move to the next block 
13a7			    inc de             ; Increment counter 
13a7			 
13a7			    ; Check if we have reached the end of heap 
13a7			    ld a, e            ; Load low byte of heap end address 
13a7			    cp (hl)            ; Compare with low byte of current address 
13a7			    jr nz, malloc_search_loop  ; If not equal, continue searching 
13a7			    ld a, d            ; Load high byte of heap end address 
13a7			    cp 0               ; Check if it's zero (end of memory) 
13a7			    jr nz, malloc_search_loop  ; If not zero, continue searching 
13a7			 
13a7			    ; If we reached here, allocation failed 
13a7			    xor a              ; Set result to NULL 
13a7			if DEBUG_FORTH_MALLOC_HIGH 
13a7						DMARK "ma6" 
13a7			call malloc_guard_exit 
13a7			call malloc_guard_zerolen 
13a7			endif 
13a7			    ret 
13a7			malloc_exit: 
13a7			if DEBUG_FORTH_MALLOC_HIGH 
13a7						DMARK "ma7" 
13a7			call malloc_guard_exit 
13a7			call malloc_guard_zerolen 
13a7			endif 
13a7			    ret 
13a7			 
13a7			; Internal Free Function: 
13a7			; Input: 
13a7			;   HL: Pointer to memory block to free 
13a7			; Output: 
13a7			;   None 
13a7			 
13a7			free_internal: 
13a7			    ld de, (heap_start) ; Load start of heap into DE 
13a7			    ld bc, 0            ; Initialize counter 
13a7			 
13a7			free_search_loop: 
13a7			    ; Check if current block contains the pointer 
13a7			    ld a, l             ; Load low byte of pointer 
13a7			    cp (hl+1)           ; Compare with high byte of current block's address 
13a7			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
13a7			    ld a, h             ; Load high byte of pointer 
13a7			    cp (hl+2)           ; Compare with low byte of current block's address 
13a7			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
13a7			 
13a7			    ; Mark block as free 
13a7			    ld (hl), 0          ; Set status byte to indicate free block 
13a7			    ret                 ; Return 
13a7			 
13a7			free_skip_block_check: 
13a7			    ; Move to the next block 
13a7			    ld bc, 3            ; Size of management overhead 
13a7			    add hl, bc          ; Move to the next block 
13a7			    inc de              ; Increment counter 
13a7			 
13a7			    ; Check if we have reached the end of heap 
13a7			    ld a, e             ; Load low byte of heap end address 
13a7			    cp (hl)             ; Compare with low byte of current address 
13a7			    jr nz, free_search_loop  ; If not equal, continue searching 
13a7			    ld a, d             ; Load high byte of heap end address 
13a7			    cp 0                ; Check if it's zero (end of memory) 
13a7			    jr nz, free_search_loop  ; If not zero, continue searching 
13a7			 
13a7			    ; If we reached here, pointer is not found in heap 
13a7			    ret 
13a7			 
13a7			free_exit: 
13a7			    ret                 ; Return 
13a7			 
13a7			; Define heap start and end addresses 
13a7			;heap_start:    .dw 0xC000   ; Start of heap 
13a7			;heap_end:      .dw 0xE000   ; End of heap 
13a7			 
13a7			endif 
13a7			 
13a7			 
13a7			if MALLOC_1 
13a7			 
13a7			 
13a7			 
13a7			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
13a7			 
13a7			;moved to firmware.asm 
13a7			;heap_start        .equ  0x9000      ; Starting address of heap 
13a7			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
13a7			 
13a7			;      .org 0 
13a7			;      jp    main 
13a7			 
13a7			 
13a7			;      .org  0x100 
13a7			;main: 
13a7			;      ld    HL, 0x8100 
13a7			;      ld    SP, HL 
13a7			; 
13a7			;      call  heap_init 
13a7			; 
13a7			;      ; Make some allocations 
13a7			;      ld    HL, 12 
13a7			;      call  malloc            ; Allocates 0x9004 
13a7			; 
13a7			;      ld    HL, 12 
13a7			;      call  malloc            ; Allocates 0x9014 
13a7			; 
13a7			;      ld    HL, 12 
13a7			;      call  malloc            ; Allocates 0x9024 
13a7			; 
13a7			;      ; Free some allocations 
13a7			;      ld    HL, 0x9014 
13a7			;      call  free 
13a7			; 
13a7			;      ld    HL, 0x9004 
13a7			;      call  free 
13a7			; 
13a7			;      ld    HL, 0x9024 
13a7			;      call  free 
13a7			; 
13a7			; 
13a7			;      halt 
13a7			 
13a7			 
13a7			;------------------------------------------------------------------------------ 
13a7			;     heap_init                                                               : 
13a7			;                                                                             : 
13a7			; Description                                                                 : 
13a7			;     Initialise the heap and make it ready for malloc and free operations.   : 
13a7			;                                                                             : 
13a7			;     The heap is maintained as a linked list, starting with an initial       : 
13a7			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
13a7			;     the first free block in the heap. Each block then points to the next    : 
13a7			;     free block within the heap, and the free list ends at the first block   : 
13a7			;     with a null pointer to the next free block.                             : 
13a7			;                                                                             : 
13a7			; Parameters                                                                  : 
13a7			;     Inputs are compile-time only. Two defines which specify the starting    : 
13a7			;     address of the heap and its size are required, along with a memory      : 
13a7			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
13a7			;     principally stores a pointer to the first free block in the heap.       : 
13a7			;                                                                             : 
13a7			; Returns                                                                     : 
13a7			;     Nothing                                                                 : 
13a7			;------------------------------------------------------------------------------ 
13a7			heap_init: 
13a7 e5			      push  HL 
13a8			 
13a8			      ; Initialise free list struct 
13a8 21 0e 80		      ld    HL, heap_start 
13ab 22 0a 80		      ld    (free_list), HL 
13ae 21 00 00		      ld    HL, 0 
13b1 22 0c 80		      ld    (free_list+2), HL 
13b4			 
13b4			      ; Insert first free block at bottom of heap, consumes entire heap 
13b4 21 df f1		      ld    HL, heap_start+heap_size-4 
13b7 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
13ba 21 d1 71		      ld    HL, heap_size-4 
13bd 22 10 80		      ld    (heap_start+2), HL      ; Block size 
13c0			 
13c0			      ; Insert end of free list block at top of heap - two null words will 
13c0			      ; terminate the free list 
13c0 21 00 00		      ld    HL, 0 
13c3 22 e1 f1		      ld    (heap_start+heap_size-2), HL 
13c6 22 df f1		      ld    (heap_start+heap_size-4), HL 
13c9			 
13c9 e1			      pop   HL 
13ca			 
13ca c9			      ret 
13cb			 
13cb			 
13cb			;------------------------------------------------------------------------------ 
13cb			;     malloc                                                                  : 
13cb			;                                                                             : 
13cb			; Description                                                                 : 
13cb			;     Allocates the wanted space from the heap and returns the address of the : 
13cb			;     first useable byte of the allocation.                                   : 
13cb			;                                                                             : 
13cb			;     Allocations can happen in one of two ways:                              : 
13cb			;                                                                             : 
13cb			;     1. A free block may be found which is the exact size wanted. In this    : 
13cb			;        case the block is removed from the free list and retuedn to the      : 
13cb			;        caller.                                                              : 
13cb			;     2. A free block may be found which is larger than the size wanted. In   : 
13cb			;        this case, the larger block is split into two. The first portion of  : 
13cb			;        this block will become the requested space by the malloc call and    : 
13cb			;        is returned to the caller. The second portion becomes a new free     : 
13cb			;        block, and the free list is adjusted to maintain continuity via this : 
13cb			;        newly created block.                                                 : 
13cb			;                                                                             : 
13cb			;     malloc does not set any initial value in the allocated space, the       : 
13cb			;     caller is required to do this as required.                              : 
13cb			;                                                                             : 
13cb			;     This implementation of malloc uses the stack exclusively, and is        : 
13cb			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
13cb			;     advisable to disable interrupts before calling malloc, and recommended  : 
13cb			;     to avoid the use of malloc inside ISRs in general.                      : 
13cb			;                                                                             : 
13cb			;     NOTE: heap_init must be called before malloc and free can be used.      : 
13cb			;                                                                             : 
13cb			; Parameters                                                                  : 
13cb			;     HL  Number of bytes wanted                                              : 
13cb			;                                                                             : 
13cb			; Returns                                                                     : 
13cb			;     HL  Address of the first useable byte of the allocation                 : 
13cb			;                                                                             : 
13cb			; Flags                                                                       : 
13cb			;     Z   Set if the allocation did not succeed, clear otherwise              : 
13cb			;                                                                             : 
13cb			; Stack frame                                                                 : 
13cb			;       |             |                                                       : 
13cb			;       +-------------+                                                       : 
13cb			;       |     BC      |                                                       : 
13cb			;       +-------------+                                                       : 
13cb			;       |     DE      |                                                       : 
13cb			;       +-------------+                                                       : 
13cb			;       |     IX      |                                                       : 
13cb			;       +-------------+                                                       : 
13cb			;       |  prev_free  |                                                       : 
13cb			;   +4  +-------------+                                                       : 
13cb			;       |  this_free  |                                                       : 
13cb			;   +2  +-------------+                                                       : 
13cb			;       |  next_free  |                                                       : 
13cb			;   +0  +-------------+                                                       : 
13cb			;       |             |                                                       : 
13cb			;                                                                             : 
13cb			;------------------------------------------------------------------------------ 
13cb			 
13cb			 
13cb			;malloc: 
13cb			; 
13cb			;	SAVESP ON 1 
13cb			; 
13cb			;	call malloc_code 
13cb			; 
13cb			;	CHECKSP ON 1 
13cb			;	ret 
13cb			 
13cb			 
13cb			malloc: 
13cb c5			      push  BC 
13cc d5			      push  DE 
13cd dd e5		      push  IX 
13cf			if DEBUG_FORTH_MALLOC_HIGH 
13cf			call malloc_guard_entry 
13cf			endif 
13cf			 
13cf					if DEBUG_FORTH_MALLOC 
13cf						DMARK "mal" 
13cf						CALLMONITOR 
13cf					endif 
13cf 7c			      ld    A, H                    ; Exit if no space requested 
13d0 b5			      or    L 
13d1 ca 90 14		      jp    Z, malloc_early_exit 
13d4			 
13d4			;inc hl 
13d4			;inc hl 
13d4			;inc hl 
13d4			; 
13d4			;inc hl 
13d4			;inc hl 
13d4			;inc hl 
13d4			;inc hl 
13d4			;inc hl 
13d4			;inc hl 
13d4			;inc hl 
13d4			;inc hl 
13d4			;inc hl 
13d4			 
13d4			 
13d4			 
13d4			 
13d4					if DEBUG_FORTH_MALLOC 
13d4						DMARK "maA" 
13d4						CALLMONITOR 
13d4					endif 
13d4			      ; Set up stack frame 
13d4 eb			      ex    DE, HL 
13d5 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
13d8 39			      add   HL, SP 
13d9 f9			      ld    SP, HL 
13da dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
13de dd 39		      add   IX, SP 
13e0			 
13e0			      ; Setup initial state 
13e0 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
13e3 19			      add   HL, DE 
13e4			 
13e4 44			      ld    B, H                    ; Move want to BC 
13e5 4d			      ld    C, L 
13e6			 
13e6 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
13e9 dd 75 04		      ld    (IX+4), L 
13ec dd 74 05		      ld    (IX+5), H 
13ef			 
13ef 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
13f0 23			      inc   HL 
13f1 56			      ld    D, (HL) 
13f2 dd 73 02		      ld    (IX+2), E 
13f5 dd 72 03		      ld    (IX+3), D 
13f8 eb			      ex    DE, HL                  ; this_free ptr into HL 
13f9			 
13f9					if DEBUG_FORTH_MALLOC 
13f9						DMARK "maB" 
13f9						CALLMONITOR 
13f9					endif 
13f9			      ; Loop through free block list to find some space 
13f9			malloc_find_space: 
13f9 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
13fa 23			      inc   HL 
13fb 56			      ld    D, (HL) 
13fc			 
13fc 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
13fd b3			      or    E 
13fe ca 8a 14		      jp    Z, malloc_no_space 
1401			 
1401 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
1404 dd 72 01		      ld    (IX+1), D 
1407			 
1407			      ; Does this block have enough space to make the allocation? 
1407 23			      inc   HL                      ; Load free block size into DE 
1408 5e			      ld    E, (HL) 
1409 23			      inc   HL 
140a 56			      ld    D, (HL) 
140b			 
140b eb			      ex    DE, HL                  ; Check size of block against want 
140c b7			      or    A                       ; Ensure carry flag clear 
140d ed 42		      sbc   HL, BC 
140f e5			      push  HL                      ; Store the result for later (new block size) 
1410			 
1410 ca 5f 14		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1413 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1415			 
1415			      ; this_free block is not big enough, setup ptrs to test next free block 
1415 e1			      pop   HL                      ; Discard previous result 
1416			 
1416 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1419 dd 66 03		      ld    H, (IX+3) 
141c dd 75 04		      ld    (IX+4), L 
141f dd 74 05		      ld    (IX+5), H 
1422			 
1422 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1425 dd 66 01		      ld    H, (IX+1) 
1428 dd 75 02		      ld    (IX+2), L 
142b dd 74 03		      ld    (IX+3), H 
142e			 
142e					if DEBUG_FORTH_MALLOC 
142e						DMARK "MA>" 
142e						CALLMONITOR 
142e					endif 
142e 18 c9		      jr    malloc_find_space 
1430			 
1430			      ; split a bigger block into two - requested size and remaining size 
1430			malloc_alloc_split: 
1430					if DEBUG_FORTH_MALLOC 
1430						DMARK "MAs" 
1430						CALLMONITOR 
1430					endif 
1430 eb			      ex    DE, HL                  ; Calculate address of new free block 
1431 2b			      dec   HL 
1432 2b			      dec   HL 
1433 2b			      dec   HL 
1434 09			      add   HL, BC 
1435			 
1435			      ; Create a new block and point it at next_free 
1435 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
1438 dd 56 01		      ld    D, (IX+1) 
143b			 
143b 73			      ld    (HL), E                 ; Store next_free ptr into new block 
143c 23			      inc   HL 
143d 72			      ld    (HL), D 
143e			 
143e d1			      pop   DE                      ; Store size of new block into new block 
143f 23			      inc   HL 
1440 73			      ld    (HL), E 
1441 23			      inc   HL 
1442 72			      ld    (HL), D 
1443			 
1443			      ; Update this_free ptr to point to new block 
1443 2b			      dec   HL 
1444 2b			      dec   HL 
1445 2b			      dec   HL 
1446			 
1446 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1449 dd 56 03		      ld    D, (IX+3) 
144c			 
144c dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
144f dd 74 03		      ld    (IX+3), H 
1452			 
1452			      ; Modify this_free block to be allocation 
1452 eb			      ex    DE, HL 
1453 af			      xor   A                       ; Null the next block ptr of allocated block 
1454 77			      ld    (HL), A 
1455 23			      inc   HL 
1456 77			      ld    (HL), A 
1457			 
1457 23			      inc   HL                      ; Store want size into allocated block 
1458 71			      ld    (HL), C 
1459 23			      inc   HL 
145a 70			      ld    (HL), B 
145b 23			      inc   HL 
145c e5			      push  HL                      ; Address of allocation to return 
145d			 
145d 18 19		      jr    malloc_update_links 
145f			 
145f			malloc_alloc_fit: 
145f e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1460			 
1460					if DEBUG_FORTH_MALLOC 
1460						DMARK "MAf" 
1460						CALLMONITOR 
1460					endif 
1460			      ; Modify this_free block to be allocation 
1460 eb			      ex    DE, HL 
1461 2b			      dec   HL 
1462 2b			      dec   HL 
1463 2b			      dec   HL 
1464			 
1464 af			      xor   A                       ; Null the next block ptr of allocated block 
1465 77			      ld    (HL), A 
1466 23			      inc   HL 
1467 77			      ld    (HL), A 
1468			 
1468 23			      inc   HL                      ; Store address of allocation to return 
1469 23			      inc   HL 
146a 23			      inc   HL 
146b e5			      push  HL 
146c			 
146c			      ; Copy next_free ptr to this_free, remove allocated block from free list 
146c dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
146f dd 66 01		      ld    H, (IX+1) 
1472			 
1472 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1475 dd 74 03		      ld    (IX+3), H 
1478			 
1478			 
1478			malloc_update_links: 
1478			      ; Update prev_free ptr to point to this_free 
1478 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
147b dd 66 05		      ld    H, (IX+5) 
147e			 
147e dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1481 dd 56 03		      ld    D, (IX+3) 
1484			 
1484 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1485 23			      inc   HL 
1486 72			      ld    (HL), D 
1487			 
1487					if DEBUG_FORTH_MALLOC 
1487						DMARK "Mul" 
1487						CALLMONITOR 
1487					endif 
1487			      ; Clear the Z flag to indicate successful allocation 
1487 7a			      ld    A, D 
1488 b3			      or    E 
1489			 
1489 d1			      pop   DE                      ; Address of allocation 
148a					if DEBUG_FORTH_MALLOC 
148a						DMARK "MAu" 
148a						CALLMONITOR 
148a					endif 
148a			 
148a			malloc_no_space: 
148a 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
148d 39			      add   HL, SP 
148e f9			      ld    SP, HL 
148f			 
148f eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1490					if DEBUG_FORTH_MALLOC 
1490						DMARK "MAN" 
1490						CALLMONITOR 
1490					endif 
1490			 
1490			malloc_early_exit: 
1490					if DEBUG_FORTH_MALLOC 
1490						DMARK "MAx" 
1490						CALLMONITOR 
1490					endif 
1490 dd e1		      pop   IX 
1492 d1			      pop   DE 
1493 c1			      pop   BC 
1494			 
1494			if DEBUG_FORTH_MALLOC_HIGH 
1494			call malloc_guard_exit 
1494			call malloc_guard_zerolen 
1494			endif 
1494 c9			      ret 
1495			 
1495			 
1495			;------------------------------------------------------------------------------ 
1495			;     free                                                                    : 
1495			;                                                                             : 
1495			; Description                                                                 : 
1495			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1495			;     returned by malloc, otherwise the behaviour is undefined.               : 
1495			;                                                                             : 
1495			;     Where possible, directly adjacent free blocks will be merged together   : 
1495			;     into larger blocks to help ensure that the heap does not become         : 
1495			;     excessively fragmented.                                                 : 
1495			;                                                                             : 
1495			;     free does not clear or set any other value into the freed space, and    : 
1495			;     therefore its contents may be visible through subsequent malloc's. The  : 
1495			;     caller should clear the freed space as required.                        : 
1495			;                                                                             : 
1495			;     This implementation of free uses the stack exclusively, and is          : 
1495			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1495			;     advisable to disable interrupts before calling free, and recommended    : 
1495			;     to avoid the use of free inside ISRs in general.                        : 
1495			;                                                                             : 
1495			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1495			;                                                                             : 
1495			; Parameters                                                                  : 
1495			;     HL  Pointer to address of first byte of allocation to be freed          : 
1495			;                                                                             : 
1495			; Returns                                                                     : 
1495			;     Nothing                                                                 : 
1495			;                                                                             : 
1495			; Stack frame                                                                 : 
1495			;       |             |                                                       : 
1495			;       +-------------+                                                       : 
1495			;       |     BC      |                                                       : 
1495			;       +-------------+                                                       : 
1495			;       |     DE      |                                                       : 
1495			;       +-------------+                                                       : 
1495			;       |     IX      |                                                       : 
1495			;       +-------------+                                                       : 
1495			;       |  prev_free  |                                                       : 
1495			;   +2  +-------------+                                                       : 
1495			;       |  next_free  |                                                       : 
1495			;   +0  +-------------+                                                       : 
1495			;       |             |                                                       : 
1495			;                                                                             : 
1495			;------------------------------------------------------------------------------ 
1495			free: 
1495 c5			      push  BC 
1496 d5			      push  DE 
1497 dd e5		      push  IX 
1499			 
1499 7c			      ld    A, H                    ; Exit if ptr is null 
149a b5			      or    L 
149b ca 5f 15		      jp    Z, free_early_exit 
149e			 
149e			      ; Set up stack frame 
149e eb			      ex    DE, HL 
149f 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
14a2 39			      add   HL, SP 
14a3 f9			      ld    SP, HL 
14a4 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
14a8 dd 39		      add   IX, SP 
14aa			 
14aa			      ; The address in HL points to the start of the useable allocated space, 
14aa			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
14aa			      ; address of the block itself. 
14aa eb			      ex    DE, HL 
14ab 11 fc ff		      ld    DE, -4 
14ae 19			      add   HL, DE 
14af			 
14af			      ; An allocated block must have a null next block pointer in it 
14af 7e			      ld    A, (HL) 
14b0 23			      inc   HL 
14b1 b6			      or    (HL) 
14b2 c2 5a 15		      jp    NZ, free_done 
14b5			 
14b5 2b			      dec   HL 
14b6			 
14b6 44			      ld    B, H                    ; Copy HL to BC 
14b7 4d			      ld    C, L 
14b8			 
14b8			      ; Loop through the free list to find the first block with an address 
14b8			      ; higher than the block being freed 
14b8 21 0a 80		      ld    HL, free_list 
14bb			 
14bb			free_find_higher_block: 
14bb 5e			      ld    E, (HL)                 ; Load next ptr from free block 
14bc 23			      inc   HL 
14bd 56			      ld    D, (HL) 
14be 2b			      dec   HL 
14bf			 
14bf dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
14c2 dd 72 01		      ld    (IX+1), D 
14c5 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
14c8 dd 74 03		      ld    (IX+3), H 
14cb			 
14cb 78			      ld    A, B                    ; Check if DE is greater than BC 
14cc ba			      cp    D                       ; Compare MSB first 
14cd 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
14cf 30 04		      jr    NC, free_find_higher_block_skip 
14d1 79			      ld    A, C 
14d2 bb			      cp    E                       ; Then compare LSB 
14d3 38 08		      jr    C, free_found_higher_block 
14d5			 
14d5			free_find_higher_block_skip: 
14d5 7a			      ld    A, D                    ; Reached the end of the free list? 
14d6 b3			      or    E 
14d7 ca 5a 15		      jp    Z, free_done 
14da			 
14da eb			      ex    DE, HL 
14db			 
14db 18 de		      jr    free_find_higher_block 
14dd			 
14dd			free_found_higher_block: 
14dd			      ; Insert freed block between prev and next free blocks 
14dd 71			      ld    (HL), C                 ; Point prev free block to freed block 
14de 23			      inc   HL 
14df 70			      ld    (HL), B 
14e0			 
14e0 60			      ld    H, B                    ; Point freed block at next free block 
14e1 69			      ld    L, C 
14e2 73			      ld    (HL), E 
14e3 23			      inc   HL 
14e4 72			      ld    (HL), D 
14e5			 
14e5			      ; Check if the freed block is adjacent to the next free block 
14e5 23			      inc   HL                      ; Load size of freed block into HL 
14e6 5e			      ld    E, (HL) 
14e7 23			      inc   HL 
14e8 56			      ld    D, (HL) 
14e9 eb			      ex    DE, HL 
14ea			 
14ea 09			      add   HL, BC                  ; Add addr of freed block and its size 
14eb			 
14eb dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
14ee dd 56 01		      ld    D, (IX+1) 
14f1			 
14f1 b7			      or    A                       ; Clear the carry flag 
14f2 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
14f4 20 22		      jr    NZ, free_check_adjacent_to_prev 
14f6			 
14f6			      ; Freed block is adjacent to next, merge into one bigger block 
14f6 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
14f7 5e			      ld    E, (HL) 
14f8 23			      inc   HL 
14f9 56			      ld    D, (HL) 
14fa e5			      push  HL                      ; Save ptr to next block for later 
14fb			 
14fb 60			      ld    H, B                    ; Store ptr from next block into freed block 
14fc 69			      ld    L, C 
14fd 73			      ld    (HL), E 
14fe 23			      inc   HL 
14ff 72			      ld    (HL), D 
1500			 
1500 e1			      pop   HL                      ; Restore ptr to next block 
1501 23			      inc   HL                      ; Load size of next block into DE 
1502 5e			      ld    E, (HL) 
1503 23			      inc   HL 
1504 56			      ld    D, (HL) 
1505 d5			      push  DE                      ; Save next block size for later 
1506			 
1506 60			      ld    H, B                    ; Load size of freed block into HL 
1507 69			      ld    L, C 
1508 23			      inc   HL 
1509 23			      inc   HL 
150a 5e			      ld    E, (HL) 
150b 23			      inc   HL 
150c 56			      ld    D, (HL) 
150d eb			      ex    DE, HL 
150e			 
150e d1			      pop   DE                      ; Restore size of next block 
150f 19			      add   HL, DE                  ; Add sizes of both blocks 
1510 eb			      ex    DE, HL 
1511			 
1511 60			      ld    H, B                    ; Store new bigger size into freed block 
1512 69			      ld    L, C 
1513 23			      inc   HL 
1514 23			      inc   HL 
1515 73			      ld    (HL), E 
1516 23			      inc   HL 
1517 72			      ld    (HL), D 
1518			 
1518			free_check_adjacent_to_prev: 
1518			      ; Check if the freed block is adjacent to the prev free block 
1518 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
151b dd 66 03		      ld    H, (IX+3) 
151e			 
151e 23			      inc   HL                      ; Size of prev free block into DE 
151f 23			      inc   HL 
1520 5e			      ld    E, (HL) 
1521 23			      inc   HL 
1522 56			      ld    D, (HL) 
1523 2b			      dec   HL 
1524 2b			      dec   HL 
1525 2b			      dec   HL 
1526			 
1526 19			      add   HL, DE                  ; Add prev block addr and size 
1527			 
1527 b7			      or    A                       ; Clear the carry flag 
1528 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
152a 20 2e		      jr    NZ, free_done 
152c			 
152c			      ; Freed block is adjacent to prev, merge into one bigger block 
152c 60			      ld    H, B                    ; Load next ptr from freed block into DE 
152d 69			      ld    L, C 
152e 5e			      ld    E, (HL) 
152f 23			      inc   HL 
1530 56			      ld    D, (HL) 
1531 e5			      push  HL                      ; Save freed block ptr for later 
1532			 
1532 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1535 dd 66 03		      ld    H, (IX+3) 
1538 73			      ld    (HL), E 
1539 23			      inc   HL 
153a 72			      ld    (HL), D 
153b			 
153b e1			      pop   HL                      ; Restore freed block ptr 
153c 23			      inc   HL                      ; Load size of freed block into DE 
153d 5e			      ld    E, (HL) 
153e 23			      inc   HL 
153f 56			      ld    D, (HL) 
1540 d5			      push  DE                      ; Save freed block size for later 
1541			 
1541 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1544 dd 66 03		      ld    H, (IX+3) 
1547 23			      inc   HL 
1548 23			      inc   HL 
1549 5e			      ld    E, (HL) 
154a 23			      inc   HL 
154b 56			      ld    D, (HL) 
154c			 
154c e1			      pop   HL                      ; Add sizes of both blocks 
154d 19			      add   HL, DE 
154e eb			      ex    DE, HL 
154f			 
154f dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1552 dd 66 03		      ld    H, (IX+3) 
1555 23			      inc   HL 
1556 23			      inc   HL 
1557 73			      ld    (HL), E 
1558 23			      inc   HL 
1559 72			      ld    (HL), D 
155a			 
155a			free_done: 
155a 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
155d 39			      add   HL, SP 
155e f9			      ld    SP, HL 
155f			 
155f			free_early_exit: 
155f dd e1		      pop   IX 
1561 d1			      pop   DE 
1562 c1			      pop   BC 
1563			 
1563 c9			      ret 
1564			 
1564			; moved to firmware.asm 
1564			; 
1564			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1564			;                  .dw   0 
1564			 
1564			 
1564			endif 
1564			 
1564			 
1564			if MALLOC_3 
1564			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1564			;heap_start        .equ  0x9000      ; Starting address of heap 
1564			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1564			; 
1564			 ;     .org 0 
1564			  ;    jp    main 
1564			; 
1564			; 
1564			 ;     .org  0x100 
1564			;main: 
1564			 ;     ld    HL, 0x8100 
1564			  ;    ld    SP, HL 
1564			; 
1564			;      call  heap_init 
1564			 
1564			      ; Make some allocations 
1564			;      ld    HL, 12 
1564			;      call  malloc            ; Allocates 0x9004 
1564			; 
1564			 ;     ld    HL, 12 
1564			;      call  malloc            ; Allocates 0x9014 
1564			 
1564			;      ld    HL, 12 
1564			;      call  malloc            ; Allocates 0x9024 
1564			 
1564			      ; Free some allocations 
1564			;      ld    HL, 0x9014 
1564			;      call  free 
1564			 
1564			;      ld    HL, 0x9004 
1564			;      call  free 
1564			; 
1564			;      ld    HL, 0x9024 
1564			;      call  free 
1564			 
1564			 
1564			 ;     halt 
1564			 
1564			 
1564			;------------------------------------------------------------------------------ 
1564			;     heap_init                                                               : 
1564			;                                                                             : 
1564			; Description                                                                 : 
1564			;     Initialise the heap and make it ready for malloc and free operations.   : 
1564			;                                                                             : 
1564			;     The heap is maintained as a linked list, starting with an initial       : 
1564			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1564			;     the first free block in the heap. Each block then points to the next    : 
1564			;     free block within the heap, and the free list ends at the first block   : 
1564			;     with a null pointer to the next free block.                             : 
1564			;                                                                             : 
1564			; Parameters                                                                  : 
1564			;     Inputs are compile-time only. Two defines which specify the starting    : 
1564			;     address of the heap and its size are required, along with a memory      : 
1564			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1564			;     principally stores a pointer to the first free block in the heap.       : 
1564			;                                                                             : 
1564			; Returns                                                                     : 
1564			;     Nothing                                                                 : 
1564			;------------------------------------------------------------------------------ 
1564			heap_init: 
1564			      push  HL 
1564			 
1564			      ; Initialise free list struct 
1564			      ld    HL, heap_start 
1564			      ld    (free_list), HL 
1564			      ld    HL, 0 
1564			      ld    (free_list+2), HL 
1564			 
1564			      ; Insert first free block at bottom of heap, consumes entire heap 
1564			      ld    HL, heap_start+heap_size-4 
1564			      ld    (heap_start), HL        ; Next block (end of free list) 
1564			      ld    HL, heap_size-4 
1564			      ld    (heap_start+2), HL      ; Block size 
1564			 
1564			      ; Insert end of free list block at top of heap - two null words will 
1564			      ; terminate the free list 
1564			      ld    HL, 0 
1564			      ld    (heap_start+heap_size-2), HL 
1564			      ld    (heap_start+heap_size-4), HL 
1564			 
1564			      pop   HL 
1564			 
1564			      ret 
1564			 
1564			 
1564			;------------------------------------------------------------------------------ 
1564			;     malloc                                                                  : 
1564			;                                                                             : 
1564			; Description                                                                 : 
1564			;     Allocates the wanted space from the heap and returns the address of the : 
1564			;     first useable byte of the allocation.                                   : 
1564			;                                                                             : 
1564			;     Allocations can happen in one of two ways:                              : 
1564			;                                                                             : 
1564			;     1. A free block may be found which is the exact size wanted. In this    : 
1564			;        case the block is removed from the free list and retuedn to the      : 
1564			;        caller.                                                              : 
1564			;     2. A free block may be found which is larger than the size wanted. In   : 
1564			;        this case, the larger block is split into two. The first portion of  : 
1564			;        this block will become the requested space by the malloc call and    : 
1564			;        is returned to the caller. The second portion becomes a new free     : 
1564			;        block, and the free list is adjusted to maintain continuity via this : 
1564			;        newly created block.                                                 : 
1564			;                                                                             : 
1564			;     malloc does not set any initial value in the allocated space, the       : 
1564			;     caller is required to do this as required.                              : 
1564			;                                                                             : 
1564			;     This implementation of malloc uses the stack exclusively, and is        : 
1564			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1564			;     advisable to disable interrupts before calling malloc, and recommended  : 
1564			;     to avoid the use of malloc inside ISRs in general.                      : 
1564			;                                                                             : 
1564			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1564			;                                                                             : 
1564			; Parameters                                                                  : 
1564			;     HL  Number of bytes wanted                                              : 
1564			;                                                                             : 
1564			; Returns                                                                     : 
1564			;     HL  Address of the first useable byte of the allocation                 : 
1564			;                                                                             : 
1564			; Flags                                                                       : 
1564			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1564			;                                                                             : 
1564			; Stack frame                                                                 : 
1564			;       |             |                                                       : 
1564			;       +-------------+                                                       : 
1564			;       |     BC      |                                                       : 
1564			;       +-------------+                                                       : 
1564			;       |     DE      |                                                       : 
1564			;       +-------------+                                                       : 
1564			;       |     IX      |                                                       : 
1564			;       +-------------+                                                       : 
1564			;       |  prev_free  |                                                       : 
1564			;   +4  +-------------+                                                       : 
1564			;       |  this_free  |                                                       : 
1564			;   +2  +-------------+                                                       : 
1564			;       |  next_free  |                                                       : 
1564			;   +0  +-------------+                                                       : 
1564			;       |             |                                                       : 
1564			;                                                                             : 
1564			;------------------------------------------------------------------------------ 
1564			malloc: 
1564			      push  BC 
1564			      push  DE 
1564			      push  IX 
1564			 
1564			      ld    A, H                    ; Exit if no space requested 
1564			      or    L 
1564			      jp    Z, malloc_early_exit 
1564			 
1564			      ; Set up stack frame 
1564			      ex    DE, HL 
1564			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1564			      add   HL, SP 
1564			      ld    SP, HL 
1564			      ld    IX, 0                   ; Use IX as a frame pointer 
1564			      add   IX, SP 
1564			 
1564			      ; Setup initial state 
1564			      ld    HL, 4                   ; want must also include space used by block struct 
1564			      add   HL, DE 
1564			 
1564			      ld    B, H                    ; Move want to BC 
1564			      ld    C, L 
1564			 
1564			      ld    HL, free_list           ; Store prev_free ptr to stack 
1564			      ld    (IX+4), L 
1564			      ld    (IX+5), H 
1564			 
1564			      ld    E, (HL)                 ; Store this_free ptr to stack 
1564			      inc   HL 
1564			      ld    D, (HL) 
1564			      ld    (IX+2), E 
1564			      ld    (IX+3), D 
1564			      ex    DE, HL                  ; this_free ptr into HL 
1564			 
1564			      ; Loop through free block list to find some space 
1564			malloc_find_space: 
1564			      ld    E, (HL)                 ; Load next_free ptr into DE 
1564			      inc   HL 
1564			      ld    D, (HL) 
1564			 
1564			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1564			      or    E 
1564			      jp    Z, malloc_no_space 
1564			 
1564			      ld    (IX+0), E               ; Store next_free ptr to stack 
1564			      ld    (IX+1), D 
1564			 
1564			      ; Does this block have enough space to make the allocation? 
1564			      inc   HL                      ; Load free block size into DE 
1564			      ld    E, (HL) 
1564			      inc   HL 
1564			      ld    D, (HL) 
1564			 
1564			      ex    DE, HL                  ; Check size of block against want 
1564			      or    A                       ; Ensure carry flag clear 
1564			      sbc   HL, BC 
1564			      push  HL                      ; Store the result for later (new block size) 
1564			 
1564			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1564			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1564			 
1564			      ; this_free block is not big enough, setup ptrs to test next free block 
1564			      pop   HL                      ; Discard previous result 
1564			 
1564			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1564			      ld    H, (IX+3) 
1564			      ld    (IX+4), L 
1564			      ld    (IX+5), H 
1564			 
1564			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1564			      ld    H, (IX+1) 
1564			      ld    (IX+2), L 
1564			      ld    (IX+3), H 
1564			 
1564			      jr    malloc_find_space 
1564			 
1564			      ; split a bigger block into two - requested size and remaining size 
1564			malloc_alloc_split: 
1564			      ex    DE, HL                  ; Calculate address of new free block 
1564			      dec   HL 
1564			      dec   HL 
1564			      dec   HL 
1564			      add   HL, BC 
1564			 
1564			      ; Create a new block and point it at next_free 
1564			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1564			      ld    D, (IX+1) 
1564			 
1564			      ld    (HL), E                 ; Store next_free ptr into new block 
1564			      inc   HL 
1564			      ld    (HL), D 
1564			 
1564			      pop   DE                      ; Store size of new block into new block 
1564			      inc   HL 
1564			      ld    (HL), E 
1564			      inc   HL 
1564			      ld    (HL), D 
1564			 
1564			      ; Update this_free ptr to point to new block 
1564			      dec   HL 
1564			      dec   HL 
1564			      dec   HL 
1564			 
1564			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1564			      ld    D, (IX+3) 
1564			 
1564			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1564			      ld    (IX+3), H 
1564			 
1564			      ; Modify this_free block to be allocation 
1564			      ex    DE, HL 
1564			      xor   A                       ; Null the next block ptr of allocated block 
1564			      ld    (HL), A 
1564			      inc   HL 
1564			      ld    (HL), A 
1564			 
1564			      inc   HL                      ; Store want size into allocated block 
1564			      ld    (HL), C 
1564			      inc   HL 
1564			      ld    (HL), B 
1564			      inc   HL 
1564			      push  HL                      ; Address of allocation to return 
1564			 
1564			      jr    malloc_update_links 
1564			 
1564			malloc_alloc_fit: 
1564			      pop   HL                      ; Dont need new block size, want is exact fit 
1564			 
1564			      ; Modify this_free block to be allocation 
1564			      ex    DE, HL 
1564			      dec   HL 
1564			      dec   HL 
1564			      dec   HL 
1564			 
1564			      xor   A                       ; Null the next block ptr of allocated block 
1564			      ld    (HL), A 
1564			      inc   HL 
1564			      ld    (HL), A 
1564			 
1564			      inc   HL                      ; Store address of allocation to return 
1564			      inc   HL 
1564			      inc   HL 
1564			      push  HL 
1564			 
1564			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1564			      ld    L, (IX+0)               ; next_free to HL 
1564			      ld    H, (IX+1) 
1564			 
1564			      ld    (IX+2), L               ; HL to this_free 
1564			      ld    (IX+3), H 
1564			 
1564			 
1564			malloc_update_links: 
1564			      ; Update prev_free ptr to point to this_free 
1564			      ld    L, (IX+4)               ; prev_free ptr to HL 
1564			      ld    H, (IX+5) 
1564			 
1564			      ld    E, (IX+2)               ; this_free ptr to DE 
1564			      ld    D, (IX+3) 
1564			 
1564			      ld    (HL), E                 ; this_free ptr into prev_free 
1564			      inc   HL 
1564			      ld    (HL), D 
1564			 
1564			      ; Clear the Z flag to indicate successful allocation 
1564			      ld    A, D 
1564			      or    E 
1564			 
1564			      pop   DE                      ; Address of allocation 
1564			 
1564			malloc_no_space: 
1564			      ld    HL, 6                   ; Clean up stack frame 
1564			      add   HL, SP 
1564			      ld    SP, HL 
1564			 
1564			      ex    DE, HL                  ; Alloc addr into HL for return 
1564			 
1564			malloc_early_exit: 
1564			      pop   IX 
1564			      pop   DE 
1564			      pop   BC 
1564			 
1564			      ret 
1564			 
1564			 
1564			;------------------------------------------------------------------------------ 
1564			;     free                                                                    : 
1564			;                                                                             : 
1564			; Description                                                                 : 
1564			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1564			;     returned by malloc, otherwise the behaviour is undefined.               : 
1564			;                                                                             : 
1564			;     Where possible, directly adjacent free blocks will be merged together   : 
1564			;     into larger blocks to help ensure that the heap does not become         : 
1564			;     excessively fragmented.                                                 : 
1564			;                                                                             : 
1564			;     free does not clear or set any other value into the freed space, and    : 
1564			;     therefore its contents may be visible through subsequent malloc's. The  : 
1564			;     caller should clear the freed space as required.                        : 
1564			;                                                                             : 
1564			;     This implementation of free uses the stack exclusively, and is          : 
1564			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1564			;     advisable to disable interrupts before calling free, and recommended    : 
1564			;     to avoid the use of free inside ISRs in general.                        : 
1564			;                                                                             : 
1564			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1564			;                                                                             : 
1564			; Parameters                                                                  : 
1564			;     HL  Pointer to address of first byte of allocation to be freed          : 
1564			;                                                                             : 
1564			; Returns                                                                     : 
1564			;     Nothing                                                                 : 
1564			;                                                                             : 
1564			; Stack frame                                                                 : 
1564			;       |             |                                                       : 
1564			;       +-------------+                                                       : 
1564			;       |     BC      |                                                       : 
1564			;       +-------------+                                                       : 
1564			;       |     DE      |                                                       : 
1564			;       +-------------+                                                       : 
1564			;       |     IX      |                                                       : 
1564			;       +-------------+                                                       : 
1564			;       |  prev_free  |                                                       : 
1564			;   +2  +-------------+                                                       : 
1564			;       |  next_free  |                                                       : 
1564			;   +0  +-------------+                                                       : 
1564			;       |             |                                                       : 
1564			;                                                                             : 
1564			;------------------------------------------------------------------------------ 
1564			free: 
1564			      push  BC 
1564			      push  DE 
1564			      push  IX 
1564			 
1564			      ld    A, H                    ; Exit if ptr is null 
1564			      or    L 
1564			      jp    Z, free_early_exit 
1564			 
1564			      ; Set up stack frame 
1564			      ex    DE, HL 
1564			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1564			      add   HL, SP 
1564			      ld    SP, HL 
1564			      ld    IX, 0                   ; Use IX as a frame pointer 
1564			      add   IX, SP 
1564			 
1564			      ; The address in HL points to the start of the useable allocated space, 
1564			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1564			      ; address of the block itself. 
1564			      ex    DE, HL 
1564			      ld    DE, -4 
1564			      add   HL, DE 
1564			 
1564			      ; An allocated block must have a null next block pointer in it 
1564			      ld    A, (HL) 
1564			      inc   HL 
1564			      or    (HL) 
1564			      jp    NZ, free_done 
1564			 
1564			      dec   HL 
1564			 
1564			      ld    B, H                    ; Copy HL to BC 
1564			      ld    C, L 
1564			 
1564			      ; Loop through the free list to find the first block with an address 
1564			      ; higher than the block being freed 
1564			      ld    HL, free_list 
1564			 
1564			free_find_higher_block: 
1564			      ld    E, (HL)                 ; Load next ptr from free block 
1564			      inc   HL 
1564			      ld    D, (HL) 
1564			      dec   HL 
1564			 
1564			      ld    (IX+0), E               ; Save ptr to next free block 
1564			      ld    (IX+1), D 
1564			      ld    (IX+2), L               ; Save ptr to prev free block 
1564			      ld    (IX+3), H 
1564			 
1564			      ld    A, B                    ; Check if DE is greater than BC 
1564			      cp    D                       ; Compare MSB first 
1564			      jr    Z, $+4                  ; MSB the same, compare LSB 
1564			      jr    NC, free_find_higher_block_skip 
1564			      ld    A, C 
1564			      cp    E                       ; Then compare LSB 
1564			      jr    C, free_found_higher_block 
1564			 
1564			free_find_higher_block_skip: 
1564			      ld    A, D                    ; Reached the end of the free list? 
1564			      or    E 
1564			      jp    Z, free_done 
1564			 
1564			      ex    DE, HL 
1564			 
1564			      jr    free_find_higher_block 
1564			 
1564			free_found_higher_block: 
1564			      ; Insert freed block between prev and next free blocks 
1564			      ld    (HL), C                 ; Point prev free block to freed block 
1564			      inc   HL 
1564			      ld    (HL), B 
1564			 
1564			      ld    H, B                    ; Point freed block at next free block 
1564			      ld    L, C 
1564			      ld    (HL), E 
1564			      inc   HL 
1564			      ld    (HL), D 
1564			 
1564			      ; Check if the freed block is adjacent to the next free block 
1564			      inc   HL                      ; Load size of freed block into HL 
1564			      ld    E, (HL) 
1564			      inc   HL 
1564			      ld    D, (HL) 
1564			      ex    DE, HL 
1564			 
1564			      add   HL, BC                  ; Add addr of freed block and its size 
1564			 
1564			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1564			      ld    D, (IX+1) 
1564			 
1564			      or    A                       ; Clear the carry flag 
1564			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1564			      jr    NZ, free_check_adjacent_to_prev 
1564			 
1564			      ; Freed block is adjacent to next, merge into one bigger block 
1564			      ex    DE, HL                  ; Load next ptr from next block into DE 
1564			      ld    E, (HL) 
1564			      inc   HL 
1564			      ld    D, (HL) 
1564			      push  HL                      ; Save ptr to next block for later 
1564			 
1564			      ld    H, B                    ; Store ptr from next block into freed block 
1564			      ld    L, C 
1564			      ld    (HL), E 
1564			      inc   HL 
1564			      ld    (HL), D 
1564			 
1564			      pop   HL                      ; Restore ptr to next block 
1564			      inc   HL                      ; Load size of next block into DE 
1564			      ld    E, (HL) 
1564			      inc   HL 
1564			      ld    D, (HL) 
1564			      push  DE                      ; Save next block size for later 
1564			 
1564			      ld    H, B                    ; Load size of freed block into HL 
1564			      ld    L, C 
1564			      inc   HL 
1564			      inc   HL 
1564			      ld    E, (HL) 
1564			      inc   HL 
1564			      ld    D, (HL) 
1564			      ex    DE, HL 
1564			 
1564			      pop   DE                      ; Restore size of next block 
1564			      add   HL, DE                  ; Add sizes of both blocks 
1564			      ex    DE, HL 
1564			 
1564			      ld    H, B                    ; Store new bigger size into freed block 
1564			      ld    L, C 
1564			      inc   HL 
1564			      inc   HL 
1564			      ld    (HL), E 
1564			      inc   HL 
1564			      ld    (HL), D 
1564			 
1564			free_check_adjacent_to_prev: 
1564			      ; Check if the freed block is adjacent to the prev free block 
1564			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1564			      ld    H, (IX+3) 
1564			 
1564			      inc   HL                      ; Size of prev free block into DE 
1564			      inc   HL 
1564			      ld    E, (HL) 
1564			      inc   HL 
1564			      ld    D, (HL) 
1564			      dec   HL 
1564			      dec   HL 
1564			      dec   HL 
1564			 
1564			      add   HL, DE                  ; Add prev block addr and size 
1564			 
1564			      or    A                       ; Clear the carry flag 
1564			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1564			      jr    NZ, free_done 
1564			 
1564			      ; Freed block is adjacent to prev, merge into one bigger block 
1564			      ld    H, B                    ; Load next ptr from freed block into DE 
1564			      ld    L, C 
1564			      ld    E, (HL) 
1564			      inc   HL 
1564			      ld    D, (HL) 
1564			      push  HL                      ; Save freed block ptr for later 
1564			 
1564			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1564			      ld    H, (IX+3) 
1564			      ld    (HL), E 
1564			      inc   HL 
1564			      ld    (HL), D 
1564			 
1564			      pop   HL                      ; Restore freed block ptr 
1564			      inc   HL                      ; Load size of freed block into DE 
1564			      ld    E, (HL) 
1564			      inc   HL 
1564			      ld    D, (HL) 
1564			      push  DE                      ; Save freed block size for later 
1564			 
1564			      ld    L, (IX+2)               ; Load size of prev block into DE 
1564			      ld    H, (IX+3) 
1564			      inc   HL 
1564			      inc   HL 
1564			      ld    E, (HL) 
1564			      inc   HL 
1564			      ld    D, (HL) 
1564			 
1564			      pop   HL                      ; Add sizes of both blocks 
1564			      add   HL, DE 
1564			      ex    DE, HL 
1564			 
1564			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1564			      ld    H, (IX+3) 
1564			      inc   HL 
1564			      inc   HL 
1564			      ld    (HL), E 
1564			      inc   HL 
1564			      ld    (HL), D 
1564			 
1564			free_done: 
1564			      ld    HL, 4                   ; Clean up stack frame 
1564			      add   HL, SP 
1564			      ld    SP, HL 
1564			 
1564			free_early_exit: 
1564			      pop   IX 
1564			      pop   DE 
1564			      pop   BC 
1564			 
1564			      ret 
1564			 
1564			 
1564			;      .org 0x8000 
1564			; 
1564			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1564			 ;                 .dw   0 
1564			 
1564			endif 
1564			 
1564			 
1564			if MALLOC_4 
1564			 
1564			; My memory allocation code. Very very simple.... 
1564			; allocate space under 250 chars 
1564			 
1564			heap_init: 
1564				; init start of heap as zero 
1564				;  
1564			 
1564				ld hl, heap_start 
1564				ld a, 0 
1564				ld (hl), a      ; empty block 
1564				inc hl 
1564				ld a, 0 
1564				ld (hl), a      ; length of block 
1564				; write end of list 
1564				inc hl 
1564				ld a,(hl) 
1564				inc hl 
1564				ld a,(hl) 
1564				 
1564			 
1564				; init some malloc vars 
1564			 
1564				ld hl, 0 
1564				ld (free_list), hl       ; store last malloc location 
1564			 
1564				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1564				ld a, 0 
1564				ld (hl), a 
1564			 
1564			 
1564				ld hl, heap_start 
1564				;  
1564				  
1564				ret 
1564			 
1564			 
1564			;    free block marker 
1564			;    requested size  
1564			;    pointer to next block 
1564			;    .... 
1564			;    next block marker 
1564			 
1564			 
1564			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1564			; 
1564			 
1564			 
1564			malloc:  
1564				push de 
1564				push bc 
1564				push af 
1564			 
1564				; hl space required 
1564				 
1564				ld c, l    ; hold space   (TODO only a max of 255) 
1564			 
1564			;	inc c     ; TODO BUG need to fix memory leak on push str 
1564			;	inc c 
1564			;	inc c 
1564			;	inc c 
1564			;	inc c 
1564			;	inc c 
1564			;	inc c 
1564			 
1564			 
1564			 
1564				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1564			 
1564				ld a, (free_list+3) 
1564				cp 0 
1564				jr z, .contheap 
1564			 
1564				ld hl, (free_list)     ; get last alloc 
1564					if DEBUG_FORTH_MALLOC_INT 
1564						DMARK "mrs" 
1564						CALLMONITOR 
1564					endif 
1564				jr .startalloc 
1564			 
1564			.contheap: 
1564				ld hl, heap_start 
1564			 
1564			.startalloc: 
1564			 
1564					if DEBUG_FORTH_MALLOC_INT 
1564						DMARK "mym" 
1564						CALLMONITOR 
1564					endif 
1564			.findblock: 
1564					if DEBUG_FORTH_MALLOC_INT 
1564						DMARK "mmf" 
1564						CALLMONITOR 
1564					endif 
1564			 
1564				ld a,(hl)  
1564				; if byte is zero then clear to use 
1564			 
1564				cp 0 
1564				jr z, .foundemptyblock 
1564			 
1564				; if byte is not clear 
1564				;     then byte is offset to next block 
1564			 
1564				inc hl 
1564				ld a, (hl) ; get size 
1564			.nextblock:	inc hl 
1564					ld e, (hl) 
1564					inc hl 
1564					ld d, (hl) 
1564					ex de, hl 
1564			;	inc hl  ; move past the store space 
1564			;	inc hl  ; move past zero index  
1564			 
1564				; TODO detect no more space 
1564			 
1564				push hl 
1564				ld de, heap_end 
1564				call cmp16 
1564				pop hl 
1564				jr nc, .nospace 
1564			 
1564				jr .findblock 
1564			 
1564			.nospace: ld hl, 0 
1564				jp .exit 
1564			 
1564			 
1564			.foundemptyblock:	 
1564					if DEBUG_FORTH_MALLOC_INT 
1564						DMARK "mme" 
1564						CALLMONITOR 
1564					endif 
1564			 
1564			; TODO has block enough space if reusing??? 
1564			 
1564				;  
1564			 
1564			; see if this block has been previously used 
1564				inc hl 
1564				ld a, (hl) 
1564				dec hl 
1564				cp 0 
1564				jr z, .newblock 
1564			 
1564					if DEBUG_FORTH_MALLOC_INT 
1564						DMARK "meR" 
1564						CALLMONITOR 
1564					endif 
1564			 
1564			; no reusing previously allocated block 
1564			 
1564			; is it smaller than previously used? 
1564				 
1564				inc hl    ; move to size 
1564				ld a, c 
1564				sub (hl)        ; we want c < (hl) 
1564				dec hl    ; move back to marker 
1564			        jr z, .findblock 
1564			 
1564				; update with the new size which should be lower 
1564			 
1564			        ;inc  hl   ; negate next move. move back to size  
1564			 
1564			.newblock: 
1564				; need to be at marker here 
1564			 
1564					if DEBUG_FORTH_MALLOC_INT 
1564						DMARK "meN" 
1564						CALLMONITOR 
1564					endif 
1564			 
1564			 
1564				ld a, c 
1564			 
1564				ld (free_list+3), a	 ; flag resume from last malloc  
1564				ld (free_list), hl    ; save out last location 
1564			 
1564			 
1564				;inc a     ; space for length byte 
1564				ld (hl), a     ; save block in use marker 
1564			 
1564				inc hl   ; move to space marker 
1564				ld (hl), a    ; save new space 
1564			 
1564				inc hl   ; move to start of allocated area 
1564				 
1564			;	push hl     ; save where we are - 1  
1564			 
1564			;	inc hl  ; move past zero index  
1564				; skip space to set down new marker 
1564			 
1564				; provide some extra space for now 
1564			 
1564				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1564				inc a 
1564				inc a 
1564			 
1564				push hl   ; save where we are in the node block 
1564			 
1564				call addatohl 
1564			 
1564				; write linked list point 
1564			 
1564				pop de     ; get our node position 
1564				ex de, hl 
1564			 
1564				ld (hl), e 
1564				inc hl 
1564				ld (hl), d 
1564			 
1564				inc hl 
1564			 
1564				; now at start of allocated data so save pointer 
1564			 
1564				push hl 
1564			 
1564				; jump to position of next node and setup empty header in DE 
1564			 
1564				ex de, hl 
1564			 
1564			;	inc hl ; move past end of block 
1564			 
1564				ld a, 0 
1564				ld (hl), a   ; empty marker 
1564				inc hl 
1564				ld (hl), a   ; size 
1564				inc hl  
1564				ld (hl), a   ; ptr 
1564				inc hl 
1564				ld (hl), a   ; ptr 
1564			 
1564			 
1564				pop hl 
1564			 
1564					if DEBUG_FORTH_MALLOC_INT 
1564						DMARK "mmr" 
1564						CALLMONITOR 
1564					endif 
1564			 
1564			.exit: 
1564				pop af 
1564				pop bc 
1564				pop de  
1564				ret 
1564			 
1564			 
1564			 
1564			 
1564			free:  
1564				push hl 
1564				push af 
1564				; get address in hl 
1564			 
1564					if DEBUG_FORTH_MALLOC_INT 
1564						DMARK "fre" 
1564						CALLMONITOR 
1564					endif 
1564				; data is at hl - move to block count 
1564				dec hl 
1564				dec hl    ; get past pointer 
1564				dec hl 
1564			 
1564				ld a, (hl)    ; need this for a validation check 
1564			 
1564				dec hl    ; move to block marker 
1564			 
1564				; now check that the block count and block marker are the same  
1564			        ; this checks that we are on a malloc node and not random memory 
1564			        ; OK a faint chance this could be a problem but rare - famous last words! 
1564			 
1564				ld c, a 
1564				ld a, (hl)    
1564			 
1564				cp c 
1564				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1564			 
1564				; yes good chance we are on a malloc node 
1564			 
1564				ld a, 0      
1564				ld (hl), a   ; mark as free 
1564			 
1564				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1564			 
1564			.freeignore:  
1564			 
1564				pop af 
1564				pop hl 
1564			 
1564				ret 
1564			 
1564			 
1564			 
1564			endif 
1564			 
1564			; eof 
# End of file firmware_memory.asm
1564			  
1564			; device C  
1564			if SOUND_ENABLE  
1564				include "firmware_sound.asm"  
1564			; Sound abstraction layer 
1564			 
1564			; support different sound chips through common interface 
1564			 
1564			SOUND_DEVICE_AY: equ 0 
1564			 
1564			SOUND_DEVICE: equ Device_A 
1564			 
1564			 
1564			 
1564			if SOUND_DEVICE_AY 
1564				include "firmware_sound_ay38910.asm" 
1564			else 
1564				include "firmware_sound_sn76489an.asm" 
1564			 
1564			; Device support for SN76489AN sound chip 
1564			 
1564			; https://arduinoplusplus.wordpress.com/2019/10/05/making-noise-with-a-sn76489-digital-sound-generator-part-1/ 
1564			; http://danceswithferrets.org/geekblog/?p=93 
1564			; https://www.smspower.org/Development/SN76489 
1564			 
1564			; D0 [ 3] 
1564			; D1 [ 2] 
1564			; D2 [ 1] 
1564			; D3 [15] 
1564			; D4 [13] 
1564			; D5 [12] 
1564			; D6 [11] 
1564			; D7 [10] 
1564			; /WE [ 5] 
1564			; CLK [14] 
1564			; /OE [ 6] 
1564			; AUDIO [ 7] 
1564			; GND 8 
1564			; +5 16 
1564			; 
1564			 
1564			; Write sequence: 
1564			; CE low 
1564			; Data bus 
1564			; WE low then high 
1564			; 32 clock cycles / 8ns write time at 4mhz 
1564			; 
1564			; https://github.com/jblang/SN76489 
1564			; Shows that the clock needs to be enabled when required. Noticed that with the clock connected it interupted the bus 
1564			; Tried: 
1564			; 
1564			; CE/OE -> Both pins of NAND -> To one pin of second NAND and second pin to full clock -> CLK on chip 
1564			; 
1564			; Connected WE to OR too 
1564			;  
1564			; That enabled the clock when required 
1564			; However still random bus corruption. Need further investigation 
1564			 
1564			 
1564			SOUND_LATCH: equ 10000000B 
1564			SOUND_DATA: equ 0B 
1564			SOUND_CH0:  equ 0B    ; Tone 
1564			SOUND_CH1: equ 0100000B        ; Tone 
1564			SOUND_CH2: equ 1000000B   ; Tone 
1564			SOUND_CH3: equ 1100000B    ; Noise 
1564			SOUND_VOL: equ 10000B 
1564			SOUND_TONE: equ 0B 
1564			 
1564			 
1564			sound_init: 
1564 3e 1f			ld a, SOUND_DATA | SOUND_CH0 | SOUND_VOL | 1111B 
1566 cd 7b 15			call note_send_byte 
1569 3e 07			ld a, SOUND_DATA | SOUND_CH0 | SOUND_TONE | 0111B 
156b cd 7b 15			call note_send_byte 
156e cd 41 0c			call delay250ms 
1571 3e 05			ld a, SOUND_DATA | SOUND_CH0 | SOUND_TONE | 0101B 
1573 cd 7b 15			call note_send_byte 
1576 cd 41 0c			call delay250ms 
1579 c9				ret 
157a			 
157a			; Play a note 
157a			; h = note 
157a			; l = duration 
157a			; a = channel 
157a			 
157a			 
157a			;  frequ = clock / ( 2 x reg valu x 32 )  
157a			 
157a			note:  
157a				 
157a			 
157a c9				ret 
157b			 
157b			note_send_byte: 
157b				; byte in a 
157b			 
157b				; we high 
157b d3 40			out (Device_B), a 
157d			;	ld a, 1 
157d			;	call aDelayInMS 
157d 00				nop  
157e 00				nop  
157f 00				nop  
1580 00				nop  
1581				; we low 
1581 d3 40			out (Device_B), a 
1583			;	ld a, 1 
1583			;	call aDelayInMS 
1583 00				nop  
1584 00				nop  
1585 00				nop  
1586 00				nop  
1587				; we high 
1587 d3 40			out (Device_B), a 
1589			;	ld a, 1 
1589			;	call aDelayInMS 
1589 00				nop  
158a 00				nop  
158b 00				nop  
158c 00				nop  
158d			 
158d			 
158d c9				ret 
158e			 
158e			;void SilenceAllChannels() 
158e			;{ 
158e			;  SendByte(0x9f); 
158e			;  SendByte(0xbf); 
158e			;  SendByte(0xdf); 
158e			;  SendByte(0xff); 
158e			;} 
158e			 
158e			 
158e			; eof 
158e			 
# End of file firmware_sound_sn76489an.asm
158e			endif 
158e			 
158e			 
158e			; Abstraction entry points 
158e			 
158e			; init  
158e			 
158e			; sound_init in specific hardware files 
158e			 
158e			; Play a note 
158e			; h = note 
158e			; l = duration 
158e			; a = channel 
158e			 
158e			;note:     
158e			;	ret 
158e			 
158e			 
158e			 
158e			 
158e			; eof 
158e			 
# End of file firmware_sound.asm
158e			endif  
158e			  
158e			include "firmware_diags.asm"  
158e			; Hardware diags menu 
158e			 
158e			 
158e			config: 
158e			 
158e 3e 00			ld a, 0 
1590 21 be 15			ld hl, .configmn 
1593 cd 01 0d			call menu 
1596			 
1596 fe 00			cp 0 
1598 c8				ret z 
1599			 
1599 fe 01			cp 1 
159b cc 97 16			call z, .savetostore 
159e			 
159e fe 02			cp 2 
15a0 cc e5 15			call z, .selautoload 
15a3 fe 03			cp 3 
15a5 cc ce 15			call z, .disautoload 
15a8 fe 04			cp 4 
15aa cc 95 16			call z, .selbank 
15ad fe 05			cp 5 
15af cc 72 17			call z, .debug_tog 
15b2 fe 06			cp 6 
15b4 cc b5 18			call z, .bpsgo 
15b7 fe 07			cp 7 
15b9 cc 98 17			call z, hardware_diags 
15bc			 
15bc 18 d0			jr config 
15be			 
15be			.configmn: 
15be a6 1a			dw prom_c3 
15c0 bd 1a			dw prom_c2 
15c2 d2 1a			dw prom_c2a 
15c4 e8 1a			dw prom_c2b 
15c6			;	dw prom_c4 
15c6 05 1b			dw prom_m4 
15c8 20 1b			dw prom_m4b 
15ca 28 1b			dw prom_c1 
15cc 00 00			dw 0 
15ce				 
15ce			 
15ce			 
15ce			 
15ce			.disautoload: 
15ce				if STORAGE_SE 
15ce 3e fe			ld a, $fe      ; bit 0 clear 
15d0 32 68 fa			ld (spi_device), a 
15d3			 
15d3 cd 85 04			call storage_get_block_0 
15d6			 
15d6 3e 00			ld a, 0 
15d8 32 a2 fa			ld (store_page+STORE_0_AUTOFILE), a 
15db			 
15db 21 00 00				ld hl, 0 
15de 11 81 fa				ld de, store_page 
15e1 cd 39 04			call storage_write_block	 ; save update 
15e4				else 
15e4			 
15e4				ld hl, prom_notav 
15e4				ld de, prom_empty 
15e4				call info_panel 
15e4				endif 
15e4			 
15e4			 
15e4 c9				ret 
15e5			 
15e5			 
15e5			 
15e5			; Select auto start 
15e5			 
15e5			.selautoload: 
15e5			 
15e5				 
15e5				if STORAGE_SE 
15e5			 
15e5 cd bc 16				call config_dir 
15e8 21 fd f1			        ld hl, scratch 
15eb 3e 00				ld a, 0 
15ed cd 01 0d				call menu 
15f0			 
15f0 fe 00				cp 0 
15f2 c8					ret z 
15f3			 
15f3 3d					dec a 
15f4			 
15f4			 
15f4					; locate menu option 
15f4			 
15f4 21 fd f1				ld hl, scratch 
15f7 cd 25 0c				call table_lookup 
15fa			 
15fa					if DEBUG_FORTH_WORDS 
15fa						DMARK "ALl" 
15fa f5				push af  
15fb 3a 0f 16			ld a, (.dmark)  
15fe 32 6e fe			ld (debug_mark),a  
1601 3a 10 16			ld a, (.dmark+1)  
1604 32 6f fe			ld (debug_mark+1),a  
1607 3a 11 16			ld a, (.dmark+2)  
160a 32 70 fe			ld (debug_mark+2),a  
160d 18 03			jr .pastdmark  
160f ..			.dmark: db "ALl"  
1612 f1			.pastdmark: pop af  
1613			endm  
# End of macro DMARK
1613						CALLMONITOR 
1613 cd ab 18			call break_point_state  
1616				endm  
# End of macro CALLMONITOR
1616					endif 
1616					; with the pointer to the menu it, the byte following the zero term is the file id 
1616			 
1616 3e 00				ld a, 0 
1618 01 32 00				ld bc, 50   ; max of bytes to look at 
161b ed b1				cpir  
161d			 
161d					if DEBUG_FORTH_WORDS 
161d						DMARK "ALb" 
161d f5				push af  
161e 3a 32 16			ld a, (.dmark)  
1621 32 6e fe			ld (debug_mark),a  
1624 3a 33 16			ld a, (.dmark+1)  
1627 32 6f fe			ld (debug_mark+1),a  
162a 3a 34 16			ld a, (.dmark+2)  
162d 32 70 fe			ld (debug_mark+2),a  
1630 18 03			jr .pastdmark  
1632 ..			.dmark: db "ALb"  
1635 f1			.pastdmark: pop af  
1636			endm  
# End of macro DMARK
1636						CALLMONITOR 
1636 cd ab 18			call break_point_state  
1639				endm  
# End of macro CALLMONITOR
1639					endif 
1639					;inc hl 
1639			 
1639 7e					ld a, (hl)   ; file id 
163a					 
163a				        ; save bank and file ids 
163a			 
163a f5					push af 
163b			 
163b			; TODO need to save to block 0 on bank 1	 
163b			 
163b cd 85 04				call storage_get_block_0 
163e			 
163e					if DEBUG_FORTH_WORDS 
163e						DMARK "AL0" 
163e f5				push af  
163f 3a 53 16			ld a, (.dmark)  
1642 32 6e fe			ld (debug_mark),a  
1645 3a 54 16			ld a, (.dmark+1)  
1648 32 6f fe			ld (debug_mark+1),a  
164b 3a 55 16			ld a, (.dmark+2)  
164e 32 70 fe			ld (debug_mark+2),a  
1651 18 03			jr .pastdmark  
1653 ..			.dmark: db "AL0"  
1656 f1			.pastdmark: pop af  
1657			endm  
# End of macro DMARK
1657						CALLMONITOR 
1657 cd ab 18			call break_point_state  
165a				endm  
# End of macro CALLMONITOR
165a					endif 
165a f1					pop af 
165b			 
165b 32 a5 fa				ld (store_page+STORE_0_FILERUN),a 
165e					 
165e					; save bank id 
165e			 
165e 3a 68 fa				ld a,(spi_device) 
1661 32 a4 fa				ld (store_page+STORE_0_BANKRUN),a 
1664			 
1664					; enable auto run of store file 
1664			 
1664 3e 01				ld a, 1 
1666 32 a2 fa				ld (store_page+STORE_0_AUTOFILE),a 
1669			 
1669					; save buffer 
1669			 
1669 21 00 00				ld hl, 0 
166c 11 81 fa				ld de, store_page 
166f					if DEBUG_FORTH_WORDS 
166f						DMARK "ALw" 
166f f5				push af  
1670 3a 84 16			ld a, (.dmark)  
1673 32 6e fe			ld (debug_mark),a  
1676 3a 85 16			ld a, (.dmark+1)  
1679 32 6f fe			ld (debug_mark+1),a  
167c 3a 86 16			ld a, (.dmark+2)  
167f 32 70 fe			ld (debug_mark+2),a  
1682 18 03			jr .pastdmark  
1684 ..			.dmark: db "ALw"  
1687 f1			.pastdmark: pop af  
1688			endm  
# End of macro DMARK
1688						CALLMONITOR 
1688 cd ab 18			call break_point_state  
168b				endm  
# End of macro CALLMONITOR
168b					endif 
168b cd 39 04			call storage_write_block	 ; save update 
168e			  
168e			 
168e			 
168e			 
168e 21 fd f1				ld hl, scratch 
1691 cd a9 16				call config_fdir 
1694			 
1694				else 
1694			 
1694				ld hl, prom_notav 
1694				ld de, prom_empty 
1694				call info_panel 
1694			 
1694				endif 
1694 c9				ret 
1695			 
1695			 
1695			 
1695			; Select storage bank 
1695			 
1695			.selbank: 
1695			 
1695				if STORAGE_SE 
1695				else 
1695			 
1695				ld hl, prom_notav 
1695				ld de, prom_empty 
1695				call info_panel 
1695				endif 
1695				 
1695 c9				ret 
1696			 
1696			if STORAGE_SE 
1696			 
1696			.config_ldir:   
1696				; Load storage bank labels into menu array 
1696			 
1696				 
1696			 
1696			 
1696 c9				ret 
1697			 
1697			 
1697			endif 
1697			 
1697			 
1697			; Save user words to storage 
1697			 
1697			.savetostore: 
1697			 
1697				if STORAGE_SE 
1697			 
1697 cd bc 16				call config_dir 
169a 21 fd f1			        ld hl, scratch 
169d 3e 00				ld a, 0 
169f cd 01 0d				call menu 
16a2					 
16a2 21 fd f1				ld hl, scratch 
16a5 cd a9 16				call config_fdir 
16a8			 
16a8				else 
16a8			 
16a8				ld hl, prom_notav 
16a8				ld de, prom_empty 
16a8				call info_panel 
16a8			 
16a8				endif 
16a8			 
16a8 c9				ret 
16a9			 
16a9			 
16a9			 
16a9			if STORAGE_SE 
16a9			 
16a9			config_fdir: 
16a9				; using the scratch dir go through and release the memory allocated for each string 
16a9				 
16a9 21 fd f1			ld hl, scratch 
16ac 5e			.cfdir:	ld e,(hl) 
16ad 23				inc hl 
16ae 56				ld d,(hl) 
16af 23				inc hl 
16b0			 
16b0 eb				ex de, hl 
16b1 cd 2d 0f			call ishlzero 
16b4 c8				ret z     ; return on null pointer 
16b5 cd 95 14			call free 
16b8 eb				ex de, hl 
16b9 18 f1			jr .cfdir 
16bb			 
16bb			 
16bb c9				ret 
16bc			 
16bc			 
16bc			config_dir: 
16bc			 
16bc				; for the config menus that need to build a directory of storage call this routine 
16bc				; it will construct a menu in scratch to pass to menu 
16bc			 
16bc				; open storage device 
16bc			 
16bc				; execute DIR to build a list of files and their ids into scratch in menu format 
16bc				; once the menu has finished then will need to call config_fdir to release the strings 
16bc				 
16bc				; c = number items 
16bc			 
16bc				 
16bc cd 85 04			call storage_get_block_0 
16bf			 
16bf 21 81 fa			ld hl, store_page     ; get current id count 
16c2 46				ld b, (hl) 
16c3 0e 00			ld c, 0    ; count of files   
16c5			 
16c5			 
16c5 21 fd f1			ld hl, scratch 
16c8 22 78 fa			ld (store_tmp2), hl    ; location to poke strings 
16cb			 
16cb				; check for empty drive 
16cb			 
16cb 3e 00			ld a, 0 
16cd b8				cp b 
16ce ca 68 17			jp z, .dirdone 
16d1			 
16d1				 
16d1					if DEBUG_FORTH_WORDS 
16d1						DMARK "Cdc" 
16d1 f5				push af  
16d2 3a e6 16			ld a, (.dmark)  
16d5 32 6e fe			ld (debug_mark),a  
16d8 3a e7 16			ld a, (.dmark+1)  
16db 32 6f fe			ld (debug_mark+1),a  
16de 3a e8 16			ld a, (.dmark+2)  
16e1 32 70 fe			ld (debug_mark+2),a  
16e4 18 03			jr .pastdmark  
16e6 ..			.dmark: db "Cdc"  
16e9 f1			.pastdmark: pop af  
16ea			endm  
# End of macro DMARK
16ea						CALLMONITOR 
16ea cd ab 18			call break_point_state  
16ed				endm  
# End of macro CALLMONITOR
16ed					endif 
16ed			 
16ed			 
16ed			.diritem:	 
16ed c5				push bc 
16ee				; for each of the current ids do a search for them and if found push to stack 
16ee			 
16ee 21 40 00				ld hl, STORE_BLOCK_PHY 
16f1 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
16f3 58					ld e,b 
16f4			 
16f4 cd 07 07				call storage_findnextid 
16f7			 
16f7			 
16f7					; if found hl will be non zero 
16f7			 
16f7 cd 2d 0f				call ishlzero 
16fa 28 69				jr z, .dirnotfound 
16fc			 
16fc					; increase count 
16fc			 
16fc c1					pop bc	 
16fd 0c					inc c 
16fe c5					push bc 
16ff					 
16ff			 
16ff					; get file header and push the file name 
16ff			 
16ff 11 81 fa				ld de, store_page 
1702 cd d4 03				call storage_read_block 
1705			 
1705					; push file id to stack 
1705				 
1705 3a 81 fa				ld a, (store_page) 
1708 26 00				ld h, 0 
170a 6f					ld l, a 
170b			 
170b					;call forth_push_numhl 
170b					; TODO store id 
170b			 
170b e5					push hl 
170c			 
170c					; push extent count to stack  
170c				 
170c 21 84 fa				ld hl, store_page+3 
170f			 
170f					; get file name length 
170f			 
170f cd 62 13				call strlenz   
1712			 
1712 23					inc hl   ; cover zero term 
1713 23					inc hl  ; stick the id at the end of the area 
1714			 
1714 e5					push hl 
1715 c1					pop bc    ; move length to bc 
1716			 
1716 cd cb 13				call malloc 
1719			 
1719					; TODO save malloc area to scratch 
1719			 
1719 eb					ex de, hl 
171a 2a 78 fa				ld hl, (store_tmp2) 
171d 73					ld (hl), e 
171e 23					inc hl 
171f 72					ld (hl), d 
1720 23					inc hl 
1721 22 78 fa				ld (store_tmp2), hl 
1724			 
1724					 
1724			 
1724					;pop hl   ; get source 
1724			;		ex de, hl    ; swap aronund	 
1724			 
1724 21 84 fa				ld hl, store_page+3 
1727					if DEBUG_FORTH_WORDS 
1727						DMARK "CFd" 
1727 f5				push af  
1728 3a 3c 17			ld a, (.dmark)  
172b 32 6e fe			ld (debug_mark),a  
172e 3a 3d 17			ld a, (.dmark+1)  
1731 32 6f fe			ld (debug_mark+1),a  
1734 3a 3e 17			ld a, (.dmark+2)  
1737 32 70 fe			ld (debug_mark+2),a  
173a 18 03			jr .pastdmark  
173c ..			.dmark: db "CFd"  
173f f1			.pastdmark: pop af  
1740			endm  
# End of macro DMARK
1740						CALLMONITOR 
1740 cd ab 18			call break_point_state  
1743				endm  
# End of macro CALLMONITOR
1743					endif 
1743 ed b0				ldir 
1745			 
1745					; de is past string, move back one and store id 
1745					 
1745 1b					dec de 
1746			 
1746					; store file id 
1746			 
1746 e1					pop hl 
1747 eb					ex de,hl 
1748 73					ld (hl), e 
1749			 
1749					if DEBUG_FORTH_WORDS 
1749						DMARK "Cdi" 
1749 f5				push af  
174a 3a 5e 17			ld a, (.dmark)  
174d 32 6e fe			ld (debug_mark),a  
1750 3a 5f 17			ld a, (.dmark+1)  
1753 32 6f fe			ld (debug_mark+1),a  
1756 3a 60 17			ld a, (.dmark+2)  
1759 32 70 fe			ld (debug_mark+2),a  
175c 18 03			jr .pastdmark  
175e ..			.dmark: db "Cdi"  
1761 f1			.pastdmark: pop af  
1762			endm  
# End of macro DMARK
1762						CALLMONITOR 
1762 cd ab 18			call break_point_state  
1765				endm  
# End of macro CALLMONITOR
1765					endif 
1765					 
1765			.dirnotfound: 
1765 c1					pop bc     
1766 10 85				djnz .diritem 
1768				 
1768			.dirdone:	 
1768			 
1768 3e 00				ld a, 0 
176a 2a 78 fa				ld hl, (store_tmp2) 
176d 77					ld (hl), a 
176e 23					inc hl 
176f 77					ld (hl), a 
1770 23					inc hl 
1771					; push a count of the dir items found 
1771			 
1771			;		ld h, 0 
1771			;		ld l, c 
1771			 
1771 c9				ret 
1772			 
1772			endif 
1772			 
1772			 
1772			; Settings 
1772			; Run  
1772			 
1772			 
1772			 
1772			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
1772			;;hd_menu2:   db "        2: Editor",0   
1772			;hd_menu2:   db "        2: Editor       6: Menu",0   
1772			;hd_menu3:   db "        3: Storage",0 
1772			;hd_menu4:   db "0=quit  4: Debug",0 
1772			;hd_don:     db "ON",0 
1772			;hd_doff:     db "OFF",0 
1772			; 
1772			; 
1772			; 
1772			;hardware_diags_old:       
1772			; 
1772			;.diagmenu: 
1772			;	call clear_display 
1772			;	ld a, display_row_1 
1772			;	ld de, hd_menu1 
1772			;	call str_at_display 
1772			; 
1772			;	ld a, display_row_2 
1772			;	ld de, hd_menu2 
1772			;	call str_at_display 
1772			; 
1772			;	ld a, display_row_3 
1772			;	ld de, hd_menu3 
1772			;	call str_at_display 
1772			; 
1772			;	ld a,  display_row_4 
1772			;	ld de, hd_menu4 
1772			;	call str_at_display 
1772			; 
1772			;	; display debug state 
1772			; 
1772			;	ld de, hd_don 
1772			;	ld a, (os_view_disable) 
1772			;	cp 0 
1772			;	jr z, .distog 
1772			;	ld de, hd_doff 
1772			;.distog: ld a, display_row_4+17 
1772			;	call str_at_display 
1772			; 
1772			;	call update_display 
1772			; 
1772			;	call cin_wait 
1772			; 
1772			; 
1772			; 
1772			;	cp '4' 
1772			;	jr nz, .diagn1 
1772			; 
1772			;	; debug toggle 
1772			; 
1772			;	ld a, (os_view_disable) 
1772			;	ld b, '*' 
1772			;	cp 0 
1772			;	jr z, .debtog 
1772			;	ld b, 0 
1772			;.debtog:	 
1772			;	ld a,b 
1772			;	ld (os_view_disable),a 
1772			; 
1772			;.diagn1: cp '0' 
1772			;	 ret z 
1772			; 
1772			;;	cp '1' 
1772			;;       jp z, matrix	 
1772			;;   TODO keyboard matrix test 
1772			; 
1772			;	cp '2' 
1772			;	jp z, .diagedit 
1772			; 
1772			;;	cp '6' 
1772			;;	jp z, .menutest 
1772			;;if ENABLE_BASIC 
1772			;;	cp '6' 
1772			;;	jp z, basic 
1772			;;endif 
1772			 ; 
1772			;	jp .diagmenu 
1772			; 
1772			; 
1772			;	ret 
1772			 
1772			 
1772			.debug_tog: 
1772 21 b9 17			ld hl, .menudebug 
1775				 
1775 3a ee f1			ld a, (os_view_disable) 
1778 fe 2a			cp '*' 
177a 20 04			jr nz,.tdon  
177c 3e 01			ld a, 1 
177e 18 02			jr .tog1 
1780 3e 00		.tdon: ld a, 0 
1782			 
1782			.tog1: 
1782 cd 01 0d			call menu 
1785 fe 00			cp 0 
1787 c8				ret z 
1788 fe 01			cp 1    ; disable debug 
178a 28 04			jr z, .dtog0 
178c 3e 2a			ld a, '*' 
178e 18 02			jr .dtogset 
1790 3e 00		.dtog0: ld a, 0 
1792 32 ee f1		.dtogset:  ld (os_view_disable), a 
1795 c3 72 17			jp .debug_tog 
1798			 
1798			 
1798			hardware_diags:       
1798			 
1798			.diagm: 
1798 21 ab 17			ld hl, .menuitems 
179b 3e 00			ld a, 0 
179d cd 01 0d			call menu 
17a0			 
17a0 fe 00		         cp 0 
17a2 c8				 ret z 
17a3			 
17a3 fe 02			cp 2 
17a5 ca 04 18			jp z, .diagedit 
17a8			 
17a8			;	cp '6' 
17a8			;	jp z, .menutest 
17a8			;if ENABLE_BASIC 
17a8			;	cp '6' 
17a8			;	jp z, basic 
17a8			;endif 
17a8			  
17a8 c3 98 17			jp .diagm 
17ab			 
17ab				 
17ab bf 17		.menuitems:   	dw .m1 
17ad ca 17				dw .m2 
17af d1 17				dw .m3 
17b1 d9 17				dw .m5 
17b3 df 17				dw .m5a 
17b5 e8 17				dw .m5b 
17b7 00 00				dw 0 
17b9			 
17b9			.menudebug: 
17b9 f1 17				dw .m6 
17bb fa 17				dw .m7 
17bd 00 00				dw 0 
17bf			 
17bf .. 00		.m1:   db "Key Matrix",0 
17ca .. 00		.m2:   db "Editor",0 
17d1 .. 00		.m3:   db "Storage",0 
17d9 .. 00		.m5:   db "Sound",0 
17df .. 00		.m5a:  db "RAM Test",0 
17e8 .. 00		.m5b:  db "LCD Test",0 
17f1			 
17f1 .. 00		.m6:   db "Debug ON",0 
17fa .. 00		.m7:   db "Debug OFF",0 
1804			 
1804			; debug editor 
1804			 
1804			.diagedit: 
1804			 
1804 21 fd f1			ld hl, scratch 
1807			;	ld bc, 250 
1807			;	ldir 
1807				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1807 3e 00			ld a, 0 
1809 77				ld (hl), a 
180a 23				inc hl 
180b 77				ld (hl), a 
180c 23				inc hl 
180d 77				ld (hl), a 
180e			 
180e cd d0 0c		        call clear_display 
1811 cd f3 0c			call update_display 
1814				;ld a, 1 
1814				;ld (hardware_diag), a 
1814			.diloop: 
1814 3e 00			ld a, display_row_1 
1816 0e 00			ld c, 0 
1818 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
181a 1e 28			ld e, 40 
181c			 
181c 21 fd f1			ld hl, scratch	 
181f cd 31 0f			call input_str 
1822			 
1822 3e 28			ld a, display_row_2 
1824 11 fd f1			ld de, scratch 
1827 cd e3 0c			call str_at_display 
182a cd f3 0c			call update_display 
182d			 
182d c3 14 18			jp .diloop 
1830			 
1830			 
1830			; pass word in hl 
1830			; a has display location 
1830			display_word_at: 
1830 f5				push af 
1831 e5				push hl 
1832 7c				ld a,h 
1833 21 02 f5			ld hl, os_word_scratch 
1836 cd 05 12			call hexout 
1839 e1				pop hl 
183a 7d				ld a,l 
183b 21 04 f5			ld hl, os_word_scratch+2 
183e cd 05 12			call hexout 
1841 21 06 f5			ld hl, os_word_scratch+4 
1844 3e 00			ld a,0 
1846 77				ld (hl),a 
1847 11 02 f5			ld de,os_word_scratch 
184a f1				pop af 
184b cd e3 0c				call str_at_display 
184e c9				ret 
184f			 
184f			display_ptr_state: 
184f			 
184f				; to restore afterwards 
184f			 
184f d5				push de 
1850 c5				push bc 
1851 e5				push hl 
1852 f5				push af 
1853			 
1853				; for use in here 
1853			 
1853			;	push bc 
1853			;	push de 
1853			;	push hl 
1853			;	push af 
1853			 
1853 cd d0 0c			call clear_display 
1856			 
1856 11 29 1a			ld de, .ptrstate 
1859 3e 00			ld a, display_row_1 
185b cd e3 0c			call str_at_display 
185e			 
185e				; display debug step 
185e			 
185e			 
185e 11 6e fe			ld de, debug_mark 
1861 3e 26			ld a, display_row_1+display_cols-2 
1863 cd e3 0c			call str_at_display 
1866			 
1866				; display a 
1866 11 33 1a			ld de, .ptrcliptr 
1869 3e 28			ld a, display_row_2 
186b cd e3 0c			call str_at_display 
186e			 
186e f1				pop af 
186f 2a 48 fa			ld hl,(cli_ptr) 
1872 3e 30			ld a, display_row_2+8 
1874 cd 30 18			call display_word_at 
1877			 
1877			 
1877				; display hl 
1877			 
1877			 
1877 11 3b 1a			ld de, .ptrclioptr 
187a 3e 32			ld a, display_row_2+10 
187c cd e3 0c			call str_at_display 
187f			; 
187f			;	pop hl 
187f 3e 35			ld a, display_row_2+13 
1881 2a 46 fa			ld hl,(cli_origptr) 
1884 cd 30 18			call display_word_at 
1887			; 
1887			;	 
1887			;	; display de 
1887			 
1887			;	ld de, .regstatede 
1887			;	ld a, display_row_3 
1887			;	call str_at_display 
1887			 
1887			;	pop de 
1887			;	ld h,d 
1887			;	ld l, e 
1887			;	ld a, display_row_3+3 
1887			;	call display_word_at 
1887			 
1887			 
1887				; display bc 
1887			 
1887			;	ld de, .regstatebc 
1887			;	ld a, display_row_3+10 
1887			;	call str_at_display 
1887			 
1887			;	pop bc 
1887			;	ld h,b 
1887			;	ld l, c 
1887			;	ld a, display_row_3+13 
1887			;	call display_word_at 
1887			 
1887			 
1887				; display dsp 
1887			 
1887			;	ld de, .regstatedsp 
1887			;	ld a, display_row_4 
1887			;	call str_at_display 
1887			 
1887				 
1887			;	ld hl,(cli_data_sp) 
1887			;	ld a, display_row_4+4 
1887			;	call display_word_at 
1887			 
1887				; display rsp 
1887			 
1887 11 6a 1a			ld de, .regstatersp 
188a 3e 82			ld a, display_row_4+10 
188c cd e3 0c			call str_at_display 
188f			 
188f				 
188f 2a 2e fa			ld hl,(cli_ret_sp) 
1892 3e 86			ld a, display_row_4+14 
1894 cd 30 18			call display_word_at 
1897			 
1897 cd f3 0c			call update_display 
189a			 
189a cd 4d 0c			call delay1s 
189d cd 4d 0c			call delay1s 
18a0 cd 4d 0c			call delay1s 
18a3			 
18a3			 
18a3 cd 97 1e			call next_page_prompt 
18a6			 
18a6				; restore  
18a6			 
18a6 f1				pop af 
18a7 e1				pop hl 
18a8 c1				pop bc 
18a9 d1				pop de 
18aa c9				ret 
18ab			 
18ab			break_point_state: 
18ab f5				push af 
18ac			 
18ac				; see if disabled 
18ac			 
18ac 3a ee f1			ld a, (os_view_disable) 
18af fe 2a			cp '*' 
18b1 20 02			jr nz, .bpsgo 
18b3 f1				pop af 
18b4 c9				ret 
18b5			 
18b5			.bpsgo: 
18b5 f1				pop af 
18b6 f5				push af 
18b7 22 ea f1			ld (os_view_hl), hl 
18ba ed 53 e8 f1		ld (os_view_de), de 
18be ed 43 e6 f1		ld (os_view_bc), bc 
18c2 e5				push hl 
18c3 6f				ld l, a 
18c4 26 00			ld h, 0 
18c6 22 ec f1			ld (os_view_af),hl 
18c9			 
18c9 21 b4 fd				ld hl, display_fb0 
18cc 22 cf fb				ld (display_fb_active), hl 
18cf e1				pop hl	 
18d0			 
18d0 3e 31			ld a, '1' 
18d2 fe 2a		.bps1:  cp '*' 
18d4 20 03			jr nz, .bps1b 
18d6 32 ee f1			ld (os_view_disable),a 
18d9 fe 31		.bps1b:  cp '1' 
18db 20 14			jr nz, .bps2 
18dd			 
18dd				; display reg 
18dd			 
18dd				 
18dd			 
18dd 3a ec f1			ld a, (os_view_af) 
18e0 2a ea f1			ld hl, (os_view_hl) 
18e3 ed 5b e8 f1		ld de, (os_view_de) 
18e7 ed 4b e6 f1		ld bc, (os_view_bc) 
18eb cd 85 19			call display_reg_state 
18ee c3 71 19			jp .bpschk 
18f1			 
18f1 fe 32		.bps2:  cp '2' 
18f3 20 08			jr nz, .bps3 
18f5				 
18f5				; display hl 
18f5 2a ea f1			ld hl, (os_view_hl) 
18f8 cd 6f 1a			call display_dump_at_hl 
18fb			 
18fb 18 74			jr .bpschk 
18fd			 
18fd fe 33		.bps3:  cp '3' 
18ff 20 08			jr nz, .bps4 
1901			 
1901			        ; display de 
1901 2a e8 f1			ld hl, (os_view_de) 
1904 cd 6f 1a			call display_dump_at_hl 
1907			 
1907 18 68			jr .bpschk 
1909 fe 34		.bps4:  cp '4' 
190b 20 08			jr nz, .bps5 
190d			 
190d			        ; display bc 
190d 2a e6 f1			ld hl, (os_view_bc) 
1910 cd 6f 1a			call display_dump_at_hl 
1913			 
1913 18 5c			jr .bpschk 
1915 fe 35		.bps5:  cp '5' 
1917 20 08		        jr nz, .bps7 
1919			 
1919				; display cur ptr 
1919 2a 48 fa			ld hl, (cli_ptr) 
191c cd 6f 1a			call display_dump_at_hl 
191f			 
191f 18 50			jr .bpschk 
1921 fe 36		.bps7:  cp '6' 
1923 20 08			jr nz, .bps8b 
1925				 
1925				; display cur orig ptr 
1925 2a 46 fa			ld hl, (cli_origptr) 
1928 cd 6f 1a			call display_dump_at_hl 
192b 18 44			jr .bpschk 
192d fe 37		.bps8b:  cp '7' 
192f 20 08			jr nz, .bps9 
1931				 
1931				; display dsp 
1931 2a 2a fa			ld hl, (cli_data_sp) 
1934 cd 6f 1a			call display_dump_at_hl 
1937			 
1937 18 38			jr .bpschk 
1939 fe 39		.bps9:  cp '9' 
193b 20 05			jr nz, .bps8c 
193d				 
193d				; display SP 
193d			;	ld hl, sp 
193d cd 6f 1a			call display_dump_at_hl 
1940			 
1940 18 2f			jr .bpschk 
1942 fe 38		.bps8c:  cp '8' 
1944 20 08			jr nz, .bps8d 
1946				 
1946				; display rsp 
1946 2a 2e fa			ld hl, (cli_ret_sp) 
1949 cd 6f 1a			call display_dump_at_hl 
194c			 
194c 18 23			jr .bpschk 
194e fe 23		.bps8d:  cp '#'     ; access monitor sub system 
1950 20 05			jr nz, .bps8 
1952 cd 8d 1c			call monitor 
1955			 
1955 18 1a			jr .bpschk 
1957 fe 30		.bps8:  cp '0' 
1959 20 16			jr nz, .bpschk 
195b			 
195b 21 13 fd				ld hl, display_fb1 
195e 22 cf fb				ld (display_fb_active), hl 
1961 cd f3 0c				call update_display 
1964			 
1964				;ld a, (os_view_af) 
1964 2a ea f1			ld hl, (os_view_hl) 
1967 ed 5b e8 f1		ld de, (os_view_de) 
196b ed 4b e6 f1		ld bc, (os_view_bc) 
196f f1				pop af 
1970 c9				ret 
1971			 
1971			.bpschk:   
1971 cd 4d 0c			call delay1s 
1974 3e 9f		ld a,display_row_4 + display_cols - 1 
1976 11 95 1e		        ld de, endprg 
1979 cd e3 0c			call str_at_display 
197c cd f3 0c			call update_display 
197f cd 38 6d			call cin_wait 
1982			 
1982 c3 d2 18			jp .bps1 
1985			 
1985			 
1985			display_reg_state: 
1985			 
1985				; to restore afterwards 
1985			 
1985 d5				push de 
1986 c5				push bc 
1987 e5				push hl 
1988 f5				push af 
1989			 
1989				; for use in here 
1989			 
1989 c5				push bc 
198a d5				push de 
198b e5				push hl 
198c f5				push af 
198d			 
198d cd d0 0c			call clear_display 
1990			 
1990 11 45 1a			ld de, .regstate 
1993 3e 00			ld a, display_row_1 
1995 cd e3 0c			call str_at_display 
1998			 
1998				; display debug step 
1998			 
1998			 
1998 11 6e fe			ld de, debug_mark 
199b 3e 25			ld a, display_row_1+display_cols-3 
199d cd e3 0c			call str_at_display 
19a0			 
19a0				; display a 
19a0 11 61 1a			ld de, .regstatea 
19a3 3e 28			ld a, display_row_2 
19a5 cd e3 0c			call str_at_display 
19a8			 
19a8 e1				pop hl 
19a9			;	ld h,0 
19a9			;	ld l, a 
19a9 3e 2b			ld a, display_row_2+3 
19ab cd 30 18			call display_word_at 
19ae			 
19ae			 
19ae				; display hl 
19ae			 
19ae			 
19ae 11 55 1a			ld de, .regstatehl 
19b1 3e 32			ld a, display_row_2+10 
19b3 cd e3 0c			call str_at_display 
19b6			 
19b6 e1				pop hl 
19b7 3e 35			ld a, display_row_2+13 
19b9 cd 30 18			call display_word_at 
19bc			 
19bc				 
19bc				; display de 
19bc			 
19bc 11 59 1a			ld de, .regstatede 
19bf 3e 50			ld a, display_row_3 
19c1 cd e3 0c			call str_at_display 
19c4			 
19c4 e1				pop hl 
19c5			;	ld h,d 
19c5			;	ld l, e 
19c5 3e 53			ld a, display_row_3+3 
19c7 cd 30 18			call display_word_at 
19ca			 
19ca			 
19ca				; display bc 
19ca			 
19ca 11 5d 1a			ld de, .regstatebc 
19cd 3e 5a			ld a, display_row_3+10 
19cf cd e3 0c			call str_at_display 
19d2			 
19d2 e1				pop hl 
19d3			;	ld h,b 
19d3			;	ld l, c 
19d3 3e 5d			ld a, display_row_3+13 
19d5 cd 30 18			call display_word_at 
19d8			 
19d8			 
19d8				; display dsp 
19d8			 
19d8 11 65 1a			ld de, .regstatedsp 
19db 3e 78			ld a, display_row_4 
19dd cd e3 0c			call str_at_display 
19e0			 
19e0				 
19e0 2a 2a fa			ld hl,(cli_data_sp) 
19e3 3e 7c			ld a, display_row_4+4 
19e5 cd 30 18			call display_word_at 
19e8			 
19e8				; display rsp 
19e8			 
19e8 11 6a 1a			ld de, .regstatersp 
19eb 3e 82			ld a, display_row_4+10 
19ed cd e3 0c			call str_at_display 
19f0			 
19f0				 
19f0 2a 2e fa			ld hl,(cli_ret_sp) 
19f3 3e 86			ld a, display_row_4+14 
19f5 cd 30 18			call display_word_at 
19f8			 
19f8 cd f3 0c			call update_display 
19fb			 
19fb			;	call delay1s 
19fb			;	call delay1s 
19fb			;	call delay1s 
19fb			 
19fb			 
19fb			;	call next_page_prompt 
19fb			 
19fb				; restore  
19fb			 
19fb f1				pop af 
19fc e1				pop hl 
19fd c1				pop bc 
19fe d1				pop de 
19ff c9				ret 
1a00			 
1a00 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1a14 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1a29 .. 00		.ptrstate:	db "Ptr State",0 
1a33 .. 00		.ptrcliptr:     db "cli_ptr",0 
1a3b .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1a45 .. 00		.regstate:	db "Reg State (1/0)",0 
1a55 .. 00		.regstatehl:	db "HL:",0 
1a59 .. 00		.regstatede:	db "DE:",0 
1a5d .. 00		.regstatebc:	db "BC:",0 
1a61 .. 00		.regstatea:	db "A :",0 
1a65 .. 00		.regstatedsp:	db "DSP:",0 
1a6a .. 00		.regstatersp:	db "RSP:",0 
1a6f			 
1a6f			display_dump_at_hl: 
1a6f e5				push hl 
1a70 d5				push de 
1a71 c5				push bc 
1a72 f5				push af 
1a73			 
1a73 22 20 f5			ld (os_cur_ptr),hl	 
1a76 cd d0 0c			call clear_display 
1a79 cd 9f 1d			call dumpcont 
1a7c			;	call delay1s 
1a7c			;	call next_page_prompt 
1a7c			 
1a7c			 
1a7c f1				pop af 
1a7d c1				pop bc 
1a7e d1				pop de 
1a7f e1				pop hl 
1a80 c9				ret 
1a81			 
1a81			;if ENABLE_BASIC 
1a81			;	include "nascombasic.asm" 
1a81			;	basic: 
1a81			;	include "forth/FORTH.ASM" 
1a81			;endif 
1a81			 
1a81			; eof 
1a81			 
1a81			 
# End of file firmware_diags.asm
1a81			  
1a81			include "firmware_prompts.asm"  
1a81			; Prompts  
1a81			 
1a81			; boot messages 
1a81			 
1a81 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.6",0 
1a96 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
1aa6			 
1aa6			 
1aa6			; config menus 
1aa6			 
1aa6 .. 00		prom_c3: db "Add Dictionary To File",0 
1abd .. 00		prom_c2: db "Select Autoload File",0 
1ad2 .. 00		prom_c2a: db "Disable Autoload File", 0 
1ae8 .. 00		prom_c2b: db "Select Storage Bank",0 
1afc .. 00		prom_c4: db "Settings",0 
1b05 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
1b20 .. 00		prom_m4b:   db "Monitor",0 
1b28 .. 00		prom_c1: db "Hardware Diags",0 
1b37			 
1b37			 
1b37 .. 00		prom_notav:    db "Feature not available",0 
1b4d .. 00		prom_empty:    db "",0 
1b4e			 
1b4e			; eof 
1b4e			 
# End of file firmware_prompts.asm
1b4e			  
1b4e			  
1b4e			; eof  
1b4e			  
# End of file firmware.asm
1b4e			 
1b4e			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1b4e			;if BASE_KEV  
1b4e			;baseram: equ 08000h 
1b4e			;endif 
1b4e			 
1b4e			;if BASE_SC114 
1b4e			;baseram:     equ    endofcode 
1b4e			;endif 
1b4e			 
1b4e			 
1b4e			; start system 
1b4e			 
1b4e			coldstart: 
1b4e				; set sp 
1b4e				; di/ei 
1b4e			 
1b4e f3				di 
1b4f 31 fd ff			ld sp, tos 
1b52			;	ei 
1b52			 
1b52			 
1b52				; disable breakpoint by default 
1b52			 
1b52 3e 2a			ld a,'*' 
1b54 32 ee f1			ld (os_view_disable),a 
1b57			 
1b57				; init hardware 
1b57			 
1b57				; init keyboard and screen hardware 
1b57			 
1b57 cd 1c 00			call hardware_init 
1b5a			 
1b5a			 
1b5a cd 4d 0c			call delay1s 
1b5d 3e 58			ld a, display_row_3+8 
1b5f 11 03 00			ld de, buildtime 
1b62 cd e3 0c			call str_at_display 
1b65 cd f3 0c			call update_display 
1b68			 
1b68 cd 4d 0c			call delay1s 
1b6b cd 4d 0c			call delay1s 
1b6e cd 4d 0c			call delay1s 
1b71			 
1b71				; detect if any keys are held down to enable breakpoints at start up 
1b71			 
1b71 cd 49 6d			call cin  
1b74 fe 00			cp 0 
1b76 28 03			jr z, .nokeys 
1b78			 
1b78				;call hardware_diags 
1b78 cd 8e 15			call config 
1b7b			 
1b7b			;	ld de, .bpen 
1b7b			;	ld a, display_row_4 
1b7b			;	call str_at_display 
1b7b			;	call update_display 
1b7b			; 
1b7b			;	ld a,0 
1b7b			;	ld (os_view_disable),a 
1b7b			; 
1b7b			;.bpwait: 
1b7b			;	call cin 
1b7b			;	cp 0 
1b7b			;	jr z, .bpwait 
1b7b			;	jr .nokeys 
1b7b			; 
1b7b			; 
1b7b			;.bpen:  db "Break points enabled!",0 
1b7b			 
1b7b			 
1b7b			 
1b7b			 
1b7b			 
1b7b			 
1b7b			.nokeys: 
1b7b			 
1b7b			 
1b7b				 
1b7b			 
1b7b			;jp  testkey 
1b7b			 
1b7b			;call storage_get_block_0 
1b7b			; 
1b7b			;ld hl, 0 
1b7b			;ld de, store_page 
1b7b			;call storage_read_block 
1b7b			 
1b7b				 
1b7b			;ld hl, 10 
1b7b			;ld de, store_page 
1b7b			;call storage_read_block 
1b7b			 
1b7b			 
1b7b			 
1b7b			 
1b7b			 
1b7b			;stop:	nop 
1b7b			;	jp stop 
1b7b			 
1b7b			 
1b7b			 
1b7b			main: 
1b7b cd d0 0c			call clear_display 
1b7e cd f3 0c			call update_display 
1b81			 
1b81			 
1b81			 
1b81			;	call testlcd 
1b81			 
1b81			 
1b81			 
1b81 cd 5d 22			call forth_init 
1b84			 
1b84			 
1b84			warmstart: 
1b84 cd 33 22			call forth_warmstart 
1b87			 
1b87				; run startup word load 
1b87			        ; TODO prevent this running at warmstart after crash  
1b87			 
1b87				if STARTUP_ENABLE 
1b87					if STORAGE_SE 
1b87 cd d7 68					call forth_autoload 
1b8a					endif 
1b8a cd e6 65				call forth_startup 
1b8d			 
1b8d			 
1b8d				endif 
1b8d			 
1b8d				; show free memory after boot 
1b8d 11 27 1c			ld de, freeram 
1b90 3e 00			ld a, display_row_1 
1b92 cd e3 0c			call str_at_display 
1b95			 
1b95			; Or use heap_size word???? 
1b95 21 e3 f1			ld hl, heap_end 
1b98 11 0e 80			ld de, heap_start 
1b9b ed 52			sbc hl, de 
1b9d e5				push hl 
1b9e 7c				ld a,h	         	 
1b9f 21 02 f5			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1ba2 cd 05 12			call hexout 
1ba5 e1			   	pop hl 
1ba6			 
1ba6 7d				ld a,l 
1ba7 21 04 f5			ld hl, os_word_scratch+2 
1baa cd 05 12			call hexout 
1bad 21 06 f5			ld hl, os_word_scratch+4 
1bb0 3e 00			ld a, 0 
1bb2 77				ld (hl),a 
1bb3 11 02 f5			ld de, os_word_scratch 
1bb6 3e 0d			ld a, display_row_1 + 13 
1bb8 cd e3 0c			call str_at_display 
1bbb cd f3 0c			call update_display 
1bbe			 
1bbe			 
1bbe				;call demo 
1bbe			 
1bbe			 
1bbe				; init scratch input area for cli commands 
1bbe			 
1bbe 21 24 f5			ld hl, os_cli_cmd 
1bc1 3e 00			ld a,0 
1bc3 77				ld (hl),a 
1bc4 23				inc hl 
1bc5 77				ld (hl),a 
1bc6			 
1bc6 3e 00			ld a,0 
1bc8 32 23 f6			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1bcb			 
1bcb 32 20 f5			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1bce 32 21 f5			ld (os_cur_ptr+1),a	 
1bd1			 
1bd1 32 02 f5			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1bd4 32 03 f5			ld (os_word_scratch+1),a	 
1bd7				 
1bd7			 
1bd7				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1bd7 21 24 f5			ld hl, os_cli_cmd 
1bda			 
1bda 3e 00			ld a, 0		 ; init cli input 
1bdc 77				ld (hl), a 
1bdd 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1bdf			cli: 
1bdf				; show cli prompt 
1bdf				;push af 
1bdf				;ld a, 0 
1bdf				;ld de, prompt 
1bdf				;call str_at_display 
1bdf			 
1bdf				;call update_display 
1bdf				;pop af 
1bdf				;inc a 
1bdf				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1bdf 0e 00			ld c, 0 
1be1 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1be3 1e 28			ld e, 40 
1be5			 
1be5 21 24 f5			ld hl, os_cli_cmd 
1be8			 
1be8				STACKFRAME OFF $fefe $9f9f 
1be8				if DEBUG_STACK_IMB 
1be8					if OFF 
1be8						exx 
1be8						ld de, $fefe 
1be8						ld a, d 
1be8						ld hl, curframe 
1be8						call hexout 
1be8						ld a, e 
1be8						ld hl, curframe+2 
1be8						call hexout 
1be8						ld hl, $fefe 
1be8						push hl 
1be8						ld hl, $9f9f 
1be8						push hl 
1be8						exx 
1be8					endif 
1be8				endif 
1be8			endm 
# End of macro STACKFRAME
1be8			 
1be8 cd 31 0f			call input_str 
1beb			 
1beb				STACKFRAMECHK OFF $fefe $9f9f 
1beb				if DEBUG_STACK_IMB 
1beb					if OFF 
1beb						exx 
1beb						ld hl, $9f9f 
1beb						pop de   ; $9f9f 
1beb						call cmp16 
1beb						jr nz, .spnosame 
1beb						ld hl, $fefe 
1beb						pop de   ; $fefe 
1beb						call cmp16 
1beb						jr z, .spfrsame 
1beb						.spnosame: call showsperror 
1beb						.spfrsame: nop 
1beb						exx 
1beb					endif 
1beb				endif 
1beb			endm 
# End of macro STACKFRAMECHK
1beb			 
1beb				; copy input to last command 
1beb			 
1beb 21 24 f5			ld hl, os_cli_cmd 
1bee 11 23 f6			ld de, os_last_cmd 
1bf1 01 ff 00			ld bc, 255 
1bf4 ed b0			ldir 
1bf6			 
1bf6				; wipe current buffer 
1bf6			 
1bf6			;	ld a, 0 
1bf6			;	ld hl, os_cli_cmd 
1bf6			;	ld de, os_cli_cmd+1 
1bf6			;	ld bc, 254 
1bf6			;	ldir 
1bf6				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1bf6			;	call strcpy 
1bf6			;	ld a, 0 
1bf6			;	ld (hl), a 
1bf6			;	inc hl 
1bf6			;	ld (hl), a 
1bf6			;	inc hl 
1bf6			;	ld (hl), a 
1bf6			 
1bf6				; switch frame buffer to program  
1bf6			 
1bf6 21 13 fd				ld hl, display_fb1 
1bf9 22 cf fb				ld (display_fb_active), hl 
1bfc			 
1bfc			;	nop 
1bfc				STACKFRAME ON $fbfe $8f9f 
1bfc				if DEBUG_STACK_IMB 
1bfc					if ON 
1bfc						exx 
1bfc						ld de, $fbfe 
1bfc						ld a, d 
1bfc						ld hl, curframe 
1bfc						call hexout 
1bfc						ld a, e 
1bfc						ld hl, curframe+2 
1bfc						call hexout 
1bfc						ld hl, $fbfe 
1bfc						push hl 
1bfc						ld hl, $8f9f 
1bfc						push hl 
1bfc						exx 
1bfc					endif 
1bfc				endif 
1bfc			endm 
# End of macro STACKFRAME
1bfc				; first time into the parser so pass over the current scratch pad 
1bfc 21 24 f5			ld hl,os_cli_cmd 
1bff				; tokenise the entered statement(s) in HL 
1bff cd db 22			call forthparse 
1c02			        ; exec forth statements in top of return stack 
1c02 cd 1b 23			call forthexec 
1c05				;call forthexec_cleanup 
1c05			;	call parsenext 
1c05			 
1c05				STACKFRAMECHK ON $fbfe $8f9f 
1c05				if DEBUG_STACK_IMB 
1c05					if ON 
1c05						exx 
1c05						ld hl, $8f9f 
1c05						pop de   ; $8f9f 
1c05						call cmp16 
1c05						jr nz, .spnosame 
1c05						ld hl, $fbfe 
1c05						pop de   ; $fbfe 
1c05						call cmp16 
1c05						jr z, .spfrsame 
1c05						.spnosame: call showsperror 
1c05						.spfrsame: nop 
1c05						exx 
1c05					endif 
1c05				endif 
1c05			endm 
# End of macro STACKFRAMECHK
1c05				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1c05			 
1c05 3e 78			ld a, display_row_4 
1c07 11 39 1c			ld de, endprog 
1c0a			 
1c0a cd f3 0c			call update_display		 
1c0d			 
1c0d cd 97 1e			call next_page_prompt 
1c10			 
1c10				; switch frame buffer to cli 
1c10			 
1c10 21 b4 fd				ld hl, display_fb0 
1c13 22 cf fb				ld (display_fb_active), hl 
1c16			 
1c16			 
1c16 cd d0 0c		        call clear_display 
1c19 cd f3 0c			call update_display		 
1c1c			 
1c1c 21 24 f5			ld hl, os_cli_cmd 
1c1f			 
1c1f 3e 00			ld a, 0		 ; init cli input 
1c21 77				ld (hl), a 
1c22			 
1c22				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1c22			 
1c22				; now on last line 
1c22			 
1c22				; TODO scroll screen up 
1c22			 
1c22				; TODO instead just clear screen and place at top of screen 
1c22			 
1c22			;	ld a, 0 
1c22			;	ld (f_cursor_ptr),a 
1c22			 
1c22				;call clear_display 
1c22				;call update_display 
1c22			 
1c22				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1c22 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1c24 c3 df 1b			jp cli 
1c27			 
1c27 .. 00		freeram: db "Free bytes: $",0 
1c35 ..			asc: db "1A2F" 
1c39 .. 00		endprog: db "End prog...",0 
1c45			 
1c45			testenter2:   
1c45 21 2f f2			ld hl,scratch+50 
1c48 22 20 f5			ld (os_cur_ptr),hl 
1c4b c3 df 1b			jp cli 
1c4e			 
1c4e			testenter:  
1c4e			 
1c4e 21 35 1c			ld hl,asc 
1c51			;	ld a,(hl) 
1c51			;	call nibble2val 
1c51 cd 5b 12			call get_byte 
1c54			 
1c54			 
1c54			;	ld a,(hl) 
1c54			;	call atohex 
1c54			 
1c54			;	call fourehexhl 
1c54 32 2f f2			ld (scratch+50),a 
1c57			 
1c57			 
1c57			 
1c57 21 37 1c			ld hl,asc+2 
1c5a			;	ld a, (hl) 
1c5a			;	call nibble2val 
1c5a cd 5b 12			call get_byte 
1c5d			 
1c5d			;	call fourehexhl 
1c5d 32 31 f2			ld (scratch+52),a 
1c60				 
1c60 21 2f f2			ld hl,scratch+50 
1c63 22 20 f5			ld (os_cur_ptr),hl 
1c66 c3 df 1b			jp cli 
1c69			 
1c69			enter:	 
1c69 3a 01 f2			ld a,(scratch+4) 
1c6c fe 00			cp 0 
1c6e 28 0c			jr z, .entercont 
1c70				; no, not a null term line so has an address to work out.... 
1c70			 
1c70 21 ff f1			ld hl,scratch+2 
1c73 cd bb 12			call get_word_hl 
1c76			 
1c76 22 20 f5			ld (os_cur_ptr),hl	 
1c79 c3 df 1b			jp cli 
1c7c			 
1c7c			 
1c7c			.entercont:  
1c7c			 
1c7c 21 ff f1			ld hl, scratch+2 
1c7f cd 5b 12			call get_byte 
1c82			 
1c82 2a 20 f5		   	ld hl,(os_cur_ptr) 
1c85 77					ld (hl),a 
1c86 23					inc hl 
1c87 22 20 f5				ld (os_cur_ptr),hl 
1c8a				 
1c8a			; get byte  
1c8a			 
1c8a			 
1c8a c3 df 1b			jp cli 
1c8d			 
1c8d			 
1c8d			; basic monitor support 
1c8d			 
1c8d			monitor: 
1c8d				;  
1c8d cd d0 0c			call clear_display 
1c90 3e 00			ld a, 0 
1c92 11 da 1c			ld de, .monprompt 
1c95 cd e3 0c			call str_at_display 
1c98 cd f3 0c			call update_display 
1c9b			 
1c9b				; get a monitor command 
1c9b			 
1c9b 0e 00			ld c, 0     ; entry at top left 
1c9d 16 64			ld d, 100   ; max buffer size 
1c9f 1e 0f			ld e, 15    ; input scroll area 
1ca1 3e 00			ld a, 0     ; init string 
1ca3 21 fb f3			ld hl, os_input 
1ca6 77				ld (hl), a 
1ca7 23				inc hl 
1ca8 77				ld (hl), a 
1ca9 21 fb f3			ld hl, os_input 
1cac 3e 01			ld a, 1     ; init string 
1cae cd 31 0f			call input_str 
1cb1			 
1cb1 cd d0 0c		        call clear_display 
1cb4 cd f3 0c			call update_display		 
1cb7			 
1cb7 3a fb f3			ld a, (os_input) 
1cba cd 59 13			call toUpper 
1cbd fe 48		        cp 'H' 
1cbf 28 6f		        jr z, .monhelp 
1cc1 fe 44			cp 'D'		; dump 
1cc3 ca 51 1d			jp z, .mondump	 
1cc6 fe 43			cp 'C'		; dump 
1cc8 ca 6b 1d			jp z, .moncdump	 
1ccb fe 4d			cp 'M'		; dump 
1ccd ca dc 1c			jp z, .moneditstart 
1cd0 fe 55			cp 'U'		; dump 
1cd2 28 14			jr z, .monedit	 
1cd4 fe 51			cp 'Q'		; dump 
1cd6 c8				ret z	 
1cd7			 
1cd7			 
1cd7				; TODO "S" to access symbol by name and not need the address 
1cd7				; TODO "F" to find a string in memory 
1cd7			 
1cd7 c3 8d 1c			jp monitor 
1cda			 
1cda .. 00		.monprompt: db ">", 0 
1cdc			 
1cdc			.moneditstart: 
1cdc				; get starting address 
1cdc			 
1cdc 21 fd f3			ld hl,os_input+2 
1cdf cd bb 12			call get_word_hl 
1ce2			 
1ce2 22 20 f5			ld (os_cur_ptr),hl	 
1ce5			 
1ce5 c3 8d 1c			jp monitor 
1ce8			 
1ce8			.monedit: 
1ce8				; get byte to load 
1ce8			 
1ce8 21 fd f3			ld hl,os_input+2 
1ceb cd 5b 12			call get_byte 
1cee			 
1cee				; get address to update 
1cee 2a 20 f5			ld hl, (os_cur_ptr) 
1cf1			 
1cf1				; update byte 
1cf1			 
1cf1 77				ld (hl), a 
1cf2			 
1cf2				; move to next address and save it 
1cf2			 
1cf2 23				inc hl 
1cf3 22 20 f5			ld (os_cur_ptr),hl	 
1cf6			 
1cf6 c3 8d 1c			jp monitor 
1cf9			 
1cf9			 
1cf9 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1d0d .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1d29 .. 00		.monhelptext3:  db "Q-Quit",0 
1d30			        
1d30			.monhelp: 
1d30 3e 00			ld a, display_row_1 
1d32 11 f9 1c		        ld de, .monhelptext1 
1d35			 
1d35 cd e3 0c			call str_at_display 
1d38 3e 28			ld a, display_row_2 
1d3a 11 0d 1d		        ld de, .monhelptext2 
1d3d					 
1d3d cd e3 0c			call str_at_display 
1d40 3e 50			ld a, display_row_3 
1d42 11 29 1d		        ld de, .monhelptext3 
1d45					 
1d45 cd e3 0c			call str_at_display 
1d48 cd f3 0c			call update_display		 
1d4b			 
1d4b cd 97 1e			call next_page_prompt 
1d4e c3 8d 1c			jp monitor 
1d51			 
1d51			.mondump:    
1d51 21 fd f3			ld hl,os_input+2 
1d54 cd bb 12			call get_word_hl 
1d57			 
1d57 22 20 f5			ld (os_cur_ptr),hl	 
1d5a cd 9f 1d			call dumpcont 
1d5d 3e 78			ld a, display_row_4 
1d5f 11 39 1c			ld de, endprog 
1d62			 
1d62 cd f3 0c			call update_display		 
1d65			 
1d65 cd 97 1e			call next_page_prompt 
1d68 c3 8d 1c			jp monitor 
1d6b			.moncdump: 
1d6b cd 9f 1d			call dumpcont 
1d6e 3e 78			ld a, display_row_4 
1d70 11 39 1c			ld de, endprog 
1d73			 
1d73 cd f3 0c			call update_display		 
1d76			 
1d76 cd 97 1e			call next_page_prompt 
1d79 c3 8d 1c			jp monitor 
1d7c			 
1d7c			 
1d7c			; TODO symbol access  
1d7c			 
1d7c			.symbols:     ;; A list of symbols that can be called up  
1d7c b4 fd			dw display_fb0 
1d7e .. 00			db "fb0",0  
1d82 81 fa		     	dw store_page 
1d84 .. 00			db "store_page",0 
1d8f			 
1d8f			 
1d8f			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1d8f			 
1d8f 3a fe f1			ld a,(scratch+1) 
1d92 fe 00			cp 0 
1d94 28 09			jr z, dumpcont 
1d96			 
1d96				; no, not a null term line so has an address to work out.... 
1d96			 
1d96 21 ff f1			ld hl,scratch+2 
1d99 cd bb 12			call get_word_hl 
1d9c			 
1d9c 22 20 f5			ld (os_cur_ptr),hl	 
1d9f			 
1d9f			 
1d9f			 
1d9f			dumpcont: 
1d9f			 
1d9f				; dump bytes at ptr 
1d9f			 
1d9f			 
1d9f 3e 00			ld a, display_row_1 
1da1 2a cf fb			ld hl, (display_fb_active) 
1da4 cd 04 0f			call addatohl 
1da7 cd cf 1d			call .dumpbyterow 
1daa			 
1daa 3e 28			ld a, display_row_2 
1dac 2a cf fb			ld hl, (display_fb_active) 
1daf cd 04 0f			call addatohl 
1db2 cd cf 1d			call .dumpbyterow 
1db5			 
1db5			 
1db5 3e 50			ld a, display_row_3 
1db7 2a cf fb			ld hl, (display_fb_active) 
1dba cd 04 0f			call addatohl 
1dbd cd cf 1d			call .dumpbyterow 
1dc0			 
1dc0 3e 78			ld a, display_row_4 
1dc2 2a cf fb			ld hl, (display_fb_active) 
1dc5 cd 04 0f			call addatohl 
1dc8 cd cf 1d			call .dumpbyterow 
1dcb			 
1dcb cd f3 0c			call update_display 
1dce			;		jp cli 
1dce c9				ret 
1dcf			 
1dcf			.dumpbyterow: 
1dcf			 
1dcf				;push af 
1dcf			 
1dcf e5				push hl 
1dd0			 
1dd0				; calc where to poke the ascii 
1dd0			if display_cols == 20 
1dd0				ld a, 16 
1dd0			else 
1dd0 3e 1f			ld a, 31 
1dd2			endif 
1dd2			 
1dd2 cd 04 0f			call addatohl 
1dd5 22 02 f5			ld (os_word_scratch),hl  		; save pos for later 
1dd8			 
1dd8			 
1dd8			; display decoding address 
1dd8 2a 20 f5		   	ld hl,(os_cur_ptr) 
1ddb			 
1ddb 7c				ld a,h 
1ddc e1				pop hl 
1ddd e5				push hl 
1dde			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1dde cd 05 12			call hexout 
1de1 2a 20 f5		   	ld hl,(os_cur_ptr) 
1de4			 
1de4 7d				ld a,l 
1de5 e1				pop hl 
1de6 23				inc hl 
1de7 23				inc hl 
1de8 e5				push hl 
1de9			;	ld hl, os_word_scratch+2 
1de9 cd 05 12			call hexout 
1dec e1				pop hl 
1ded 23				inc hl 
1dee 23				inc hl 
1def				;ld hl, os_word_scratch+4 
1def 3e 3a			ld a, ':' 
1df1 77				ld (hl),a 
1df2 23				inc hl 
1df3				;ld a, 0 
1df3				;ld (hl),a 
1df3				;ld de, os_word_scratch 
1df3				;pop af 
1df3				;push af 
1df3			;		ld a, display_row_2 
1df3			;		call str_at_display 
1df3			;		call update_display 
1df3			 
1df3			 
1df3			;pop af 
1df3			;	add 5 
1df3			 
1df3			if display_cols == 20 
1df3				ld b, 4 
1df3			else 
1df3 06 08			ld b, 8 
1df5			endif	 
1df5			 
1df5			.dumpbyte: 
1df5 c5				push bc 
1df6 e5				push hl 
1df7			 
1df7			 
1df7 2a 20 f5		   	ld hl,(os_cur_ptr) 
1dfa 7e					ld a,(hl) 
1dfb			 
1dfb					; poke the ascii to display 
1dfb 2a 02 f5				ld hl,(os_word_scratch) 
1dfe 77					ld (hl),a 
1dff 23					inc hl 
1e00 22 02 f5				ld (os_word_scratch),hl 
1e03			 
1e03					 
1e03			 
1e03			 
1e03 e1					pop hl 
1e04 e5					push hl 
1e05			 
1e05 cd 05 12				call hexout 
1e08			 
1e08					 
1e08 2a 20 f5		   	ld hl,(os_cur_ptr) 
1e0b 23				inc hl 
1e0c 22 20 f5		   	ld (os_cur_ptr),hl 
1e0f			 
1e0f e1					pop hl 
1e10 23					inc hl 
1e11 23					inc hl 
1e12 23					inc hl 
1e13			 
1e13			 
1e13			 
1e13					;ld a,0 
1e13					;ld (os_word_scratch+2),a 
1e13					;pop af 
1e13					;push af 
1e13			 
1e13					;ld de, os_word_scratch 
1e13					;call str_at_display 
1e13			;		call update_display 
1e13			;		pop af 
1e13 c1					pop bc 
1e14 c6 03				add 3 
1e16 10 dd			djnz .dumpbyte 
1e18			 
1e18				 
1e18			 
1e18 c9				ret 
1e19			 
1e19			jump:	 
1e19			 
1e19 21 ff f1			ld hl,scratch+2 
1e1c cd bb 12			call get_word_hl 
1e1f				;ld hl,(scratch+2) 
1e1f				;call fourehexhl 
1e1f			 
1e1f 22 20 f5			ld (os_cur_ptr),hl	 
1e22			 
1e22 e9				jp (hl) 
1e23			 
1e23			 
1e23			 
1e23			; TODO implement a basic monitor mode to start with 
1e23			 
1e23			 
1e23			 
1e23			 
1e23			 
1e23			 
1e23			 
1e23			 
1e23			 
1e23			; testing and demo code during development 
1e23			 
1e23			 
1e23 .. 00		str1: db "Enter some text...",0 
1e36 .. 00		clear: db "                    ",0 
1e4b			 
1e4b			demo: 
1e4b			 
1e4b			 
1e4b			 
1e4b			;	call update_display 
1e4b			 
1e4b				; init scratch input area for testing 
1e4b 21 fd f1			ld hl, scratch	 
1e4e 3e 00			ld a,0 
1e50 77				ld (hl),a 
1e51			 
1e51			 
1e51 3e 28		            LD   A, display_row_2 
1e53			;            CALL fLCD_Pos       ;Position cursor to location in A 
1e53 11 23 1e		            LD   DE, str1 
1e56 cd e3 0c			call str_at_display 
1e59			 
1e59			;            CALL fLCD_Str       ;Display string pointed to by DE 
1e59			cloop:	 
1e59 3e 50		            LD   A, display_row_3 
1e5b			;            CALL fLCD_Pos       ;Position cursor to location in A 
1e5b 11 36 1e		            LD   DE, clear 
1e5e			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1e5e cd e3 0c				call str_at_display 
1e61 3e 78			ld a, display_row_4 
1e63 11 93 1e			ld de, prompt 
1e66			 
1e66 cd e3 0c				call str_at_display 
1e69 cd f3 0c			call update_display 
1e6c			 
1e6c 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1e6e 16 0a			ld d, 10 
1e70 21 fd f1			ld hl, scratch	 
1e73 cd 31 0f			call input_str 
1e76			 
1e76			;	call clear_display 
1e76			;'	call update_display 
1e76			 
1e76 3e 00		            LD   A, display_row_1 
1e78			;            CALL fLCD_Pos       ;Position cursor to location in A 
1e78 11 36 1e		            LD   DE, clear 
1e7b cd e3 0c				call str_at_display 
1e7e			;            CALL fLCD_Str       ;Display string pointed to by DE 
1e7e 3e 00		            LD   A, display_row_1 
1e80			;            CALL fLCD_Pos       ;Position cursor to location in A 
1e80 11 fd f1		            LD   DE, scratch 
1e83			;            CALL fLCD_Str       ;Display string pointed to by DE 
1e83 cd e3 0c				call str_at_display 
1e86 cd f3 0c			call update_display 
1e89			 
1e89 3e 00				ld a,0 
1e8b 21 fd f1			ld hl, scratch 
1e8e 77				ld (hl),a 
1e8f			 
1e8f 00				nop 
1e90 c3 59 1e			jp cloop 
1e93			 
1e93			 
1e93			 
1e93			; OS Prompt 
1e93			 
1e93 .. 00		prompt: db ">",0 
1e95 .. 00		endprg: db "?",0 
1e97			 
1e97			 
1e97			; handy next page prompt 
1e97			next_page_prompt: 
1e97 e5				push hl 
1e98 d5				push de 
1e99 f5				push af 
1e9a c5				push bc 
1e9b			 
1e9b 3e 9f			ld a,display_row_4 + display_cols - 1 
1e9d 11 95 1e		        ld de, endprg 
1ea0 cd e3 0c			call str_at_display 
1ea3 cd f3 0c			call update_display 
1ea6 cd 38 6d			call cin_wait 
1ea9 c1				pop bc 
1eaa f1				pop af 
1eab d1				pop de 
1eac e1				pop hl 
1ead			 
1ead			 
1ead c9				ret 
1eae			 
1eae			 
1eae			; forth parser 
1eae			 
1eae			; My forth kernel 
1eae			include "forth_kernel.asm" 
1eae			; 
1eae			; kernel to the forth OS 
1eae			 
1eae			DS_TYPE_STR: equ 1     ; string type 
1eae			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1eae			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1eae			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1eae			 
1eae			FORTH_PARSEV1: equ 0 
1eae			FORTH_PARSEV2: equ 0 
1eae			FORTH_PARSEV3: equ 0 
1eae			FORTH_PARSEV4: equ 0 
1eae			FORTH_PARSEV5: equ 1 
1eae			 
1eae			;if FORTH_PARSEV5 
1eae			;	FORTH_END_BUFFER: equ 0 
1eae			;else 
1eae			FORTH_END_BUFFER: equ 127 
1eae			;endif 
1eae			 
1eae			FORTH_TRUE: equ 1 
1eae			FORTH_FALSE: equ 0 
1eae			 
1eae			if FORTH_PARSEV4 
1eae			include "forth_stackops.asm" 
1eae			endif 
1eae			 
1eae			if FORTH_PARSEV5 
1eae			include "forth_stackopsv5.asm" 
1eae			 
1eae			; Stack operations for v5 parser on wards 
1eae			; * DATA stack 
1eae			; * LOOP stack 
1eae			; * RETURN stack 
1eae			 
1eae			 
1eae			 
1eae			FORTH_CHK_DSP_UNDER: macro 
1eae				push hl 
1eae				push de 
1eae				ld hl,(cli_data_sp) 
1eae				ld de, cli_data_stack 
1eae				call cmp16 
1eae				jp c, fault_dsp_under 
1eae				pop de 
1eae				pop hl 
1eae				endm 
1eae			 
1eae			 
1eae			FORTH_CHK_RSP_UNDER: macro 
1eae				push hl 
1eae				push de 
1eae				ld hl,(cli_ret_sp) 
1eae				ld de, cli_ret_stack 
1eae				call cmp16 
1eae				jp c, fault_rsp_under 
1eae				pop de 
1eae				pop hl 
1eae				endm 
1eae			 
1eae			FORTH_CHK_LOOP_UNDER: macro 
1eae				push hl 
1eae				push de 
1eae				ld hl,(cli_loop_sp) 
1eae				ld de, cli_loop_stack 
1eae				call cmp16 
1eae				jp c, fault_loop_under 
1eae				pop de 
1eae				pop hl 
1eae				endm 
1eae			 
1eae			FORTH_ERR_TOS_NOTSTR: macro 
1eae				; TOSO might need more for checks when used 
1eae				push af 
1eae				ld a,(hl) 
1eae				cp DS_TYPE_STR 
1eae				jp nz, type_faultn   
1eae				pop af 
1eae				endm 
1eae			 
1eae			FORTH_ERR_TOS_NOTNUM: macro 
1eae				push af 
1eae				ld a,(hl) 
1eae				cp DS_TYPE_INUM 
1eae				jp nz, type_faultn   
1eae				pop af 
1eae				endm 
1eae			 
1eae			 
1eae			; increase data stack pointer and save hl to it 
1eae				 
1eae			FORTH_DSP_NEXT: macro 
1eae				call macro_forth_dsp_next 
1eae				endm 
1eae			 
1eae			 
1eae			macro_forth_dsp_next: 
1eae				if DEBUG_FORTH_STACK_GUARD 
1eae cd b0 66				call check_stacks 
1eb1				endif 
1eb1 e5				push hl 
1eb2 d5				push de 
1eb3 eb				ex de,hl 
1eb4 2a 2a fa			ld hl,(cli_data_sp) 
1eb7 23				inc hl 
1eb8 23				inc hl 
1eb9			 
1eb9			; PARSEV5 
1eb9 23				inc hl 
1eba 22 2a fa			ld (cli_data_sp),hl 
1ebd 73				ld (hl), e 
1ebe 23				inc hl 
1ebf 72				ld (hl), d 
1ec0 d1				pop de 
1ec1 e1				pop hl 
1ec2				if DEBUG_FORTH_STACK_GUARD 
1ec2 cd b0 66				call check_stacks 
1ec5				endif 
1ec5 c9				ret 
1ec6			 
1ec6			 
1ec6			; increase ret stack pointer and save hl to it 
1ec6				 
1ec6			FORTH_RSP_NEXT: macro 
1ec6				call macro_forth_rsp_next 
1ec6				endm 
1ec6			 
1ec6			macro_forth_rsp_next: 
1ec6				if DEBUG_FORTH_STACK_GUARD 
1ec6 cd b0 66				call check_stacks 
1ec9				endif 
1ec9 e5				push hl 
1eca d5				push de 
1ecb eb				ex de,hl 
1ecc 2a 2e fa			ld hl,(cli_ret_sp) 
1ecf 23				inc hl 
1ed0 23				inc hl 
1ed1 22 2e fa			ld (cli_ret_sp),hl 
1ed4 73				ld (hl), e 
1ed5 23				inc hl 
1ed6 72				ld (hl), d 
1ed7 d1				pop de 
1ed8 e1				pop hl 
1ed9				if DEBUG_FORTH_STACK_GUARD 
1ed9 cd b0 66				call check_stacks 
1edc				endif 
1edc c9				ret 
1edd			 
1edd			; get current ret stack pointer and save to hl  
1edd				 
1edd			FORTH_RSP_TOS: macro 
1edd				call macro_forth_rsp_tos 
1edd				endm 
1edd			 
1edd			macro_forth_rsp_tos: 
1edd				;push de 
1edd 2a 2e fa			ld hl,(cli_ret_sp) 
1ee0 cd 18 1f			call loadhlptrtohl 
1ee3				;ld e, (hl) 
1ee3				;inc hl 
1ee3				;ld d, (hl) 
1ee3				;ex de, hl 
1ee3					if DEBUG_FORTH_WORDS 
1ee3			;			DMARK "RST" 
1ee3						CALLMONITOR 
1ee3 cd ab 18			call break_point_state  
1ee6				endm  
# End of macro CALLMONITOR
1ee6					endif 
1ee6				;pop de 
1ee6 c9				ret 
1ee7			 
1ee7			; pop ret stack pointer 
1ee7				 
1ee7			FORTH_RSP_POP: macro 
1ee7				call macro_forth_rsp_pop 
1ee7				endm 
1ee7			 
1ee7			 
1ee7			macro_forth_rsp_pop: 
1ee7				if DEBUG_FORTH_STACK_GUARD 
1ee7			;		DMARK "RPP" 
1ee7 cd b0 66				call check_stacks 
1eea					FORTH_CHK_RSP_UNDER 
1eea e5				push hl 
1eeb d5				push de 
1eec 2a 2e fa			ld hl,(cli_ret_sp) 
1eef 11 e8 f9			ld de, cli_ret_stack 
1ef2 cd 22 0f			call cmp16 
1ef5 da c4 67			jp c, fault_rsp_under 
1ef8 d1				pop de 
1ef9 e1				pop hl 
1efa				endm 
# End of macro FORTH_CHK_RSP_UNDER
1efa				endif 
1efa e5				push hl 
1efb 2a 2e fa			ld hl,(cli_ret_sp) 
1efe			 
1efe			 
1efe				if FORTH_ENABLE_FREE 
1efe			 
1efe					; get pointer 
1efe			 
1efe					push de 
1efe					push hl 
1efe			 
1efe					ld e, (hl) 
1efe					inc hl 
1efe					ld d, (hl) 
1efe			 
1efe					ex de, hl 
1efe					call free 
1efe			 
1efe					pop hl 
1efe					pop de 
1efe			 
1efe			 
1efe				endif 
1efe			 
1efe			 
1efe 2b				dec hl 
1eff 2b				dec hl 
1f00 22 2e fa			ld (cli_ret_sp), hl 
1f03				; do stack underflow checks 
1f03 e1				pop hl 
1f04				if DEBUG_FORTH_STACK_GUARD 
1f04 cd b0 66				call check_stacks 
1f07					FORTH_CHK_RSP_UNDER 
1f07 e5				push hl 
1f08 d5				push de 
1f09 2a 2e fa			ld hl,(cli_ret_sp) 
1f0c 11 e8 f9			ld de, cli_ret_stack 
1f0f cd 22 0f			call cmp16 
1f12 da c4 67			jp c, fault_rsp_under 
1f15 d1				pop de 
1f16 e1				pop hl 
1f17				endm 
# End of macro FORTH_CHK_RSP_UNDER
1f17				endif 
1f17 c9				ret 
1f18			 
1f18			 
1f18			 
1f18			; routine to load word pointed to by hl into hl 
1f18			 
1f18			loadhlptrtohl: 
1f18			 
1f18 d5				push de 
1f19 5e				ld e, (hl) 
1f1a 23				inc hl 
1f1b 56				ld d, (hl) 
1f1c eb				ex de, hl 
1f1d d1				pop de 
1f1e			 
1f1e c9				ret 
1f1f			 
1f1f			 
1f1f			 
1f1f			 
1f1f			 
1f1f			; push a number held in HL onto the data stack 
1f1f			; entry point for pushing a value when already in hl used in function above 
1f1f			 
1f1f			forth_push_numhl: 
1f1f			 
1f1f e5				push hl    ; save value to push 
1f20			 
1f20			if DEBUG_FORTH_PUSH 
1f20				; see if disabled 
1f20			 
1f20			 
1f20 f5				push af 
1f21 3a ee f1			ld a, (os_view_disable) 
1f24 fe 2a			cp '*' 
1f26 28 34			jr z, .pskip2 
1f28 e5				push hl 
1f29 e5			push hl 
1f2a cd d0 0c			call clear_display 
1f2d e1			pop hl 
1f2e 7c				ld a,h 
1f2f 21 02 f5			ld hl, os_word_scratch 
1f32 cd 05 12			call hexout 
1f35 e1				pop hl 
1f36 7d				ld a,l 
1f37 21 04 f5			ld hl, os_word_scratch+2 
1f3a cd 05 12			call hexout 
1f3d			 
1f3d 21 06 f5			ld hl, os_word_scratch+4 
1f40 3e 00			ld a,0 
1f42 77				ld (hl),a 
1f43 11 02 f5			ld de,os_word_scratch 
1f46 3e 28				ld a, display_row_2 
1f48 cd e3 0c				call str_at_display 
1f4b 11 46 55			ld de, .push_num 
1f4e 3e 00			ld a, display_row_1 
1f50			 
1f50 cd e3 0c				call str_at_display 
1f53			 
1f53			 
1f53 cd f3 0c			call update_display 
1f56 cd 4d 0c			call delay1s 
1f59 cd 4d 0c			call delay1s 
1f5c			.pskip2:  
1f5c			 
1f5c f1				pop af 
1f5d			endif	 
1f5d			 
1f5d			 
1f5d				FORTH_DSP_NEXT 
1f5d cd ae 1e			call macro_forth_dsp_next 
1f60				endm 
# End of macro FORTH_DSP_NEXT
1f60			 
1f60 2a 2a fa			ld hl, (cli_data_sp) 
1f63			 
1f63				; save item type 
1f63 3e 02			ld a,  DS_TYPE_INUM 
1f65 77				ld (hl), a 
1f66 23				inc hl 
1f67			 
1f67				; get word off stack 
1f67 d1				pop de 
1f68 7b				ld a,e 
1f69 77				ld (hl), a 
1f6a 23				inc hl 
1f6b 7a				ld a,d 
1f6c 77				ld (hl), a 
1f6d			 
1f6d			if DEBUG_FORTH_PUSH 
1f6d 2b				dec hl 
1f6e 2b				dec hl 
1f6f 2b				dec hl 
1f70						DMARK "PH5" 
1f70 f5				push af  
1f71 3a 85 1f			ld a, (.dmark)  
1f74 32 6e fe			ld (debug_mark),a  
1f77 3a 86 1f			ld a, (.dmark+1)  
1f7a 32 6f fe			ld (debug_mark+1),a  
1f7d 3a 87 1f			ld a, (.dmark+2)  
1f80 32 70 fe			ld (debug_mark+2),a  
1f83 18 03			jr .pastdmark  
1f85 ..			.dmark: db "PH5"  
1f88 f1			.pastdmark: pop af  
1f89			endm  
# End of macro DMARK
1f89				CALLMONITOR 
1f89 cd ab 18			call break_point_state  
1f8c				endm  
# End of macro CALLMONITOR
1f8c			endif	 
1f8c			 
1f8c c9				ret 
1f8d			 
1f8d			 
1f8d			; Push a string to stack pointed to by hl 
1f8d			 
1f8d			forth_push_str: 
1f8d			 
1f8d			if DEBUG_FORTH_PUSH 
1f8d						DMARK "PSQ" 
1f8d f5				push af  
1f8e 3a a2 1f			ld a, (.dmark)  
1f91 32 6e fe			ld (debug_mark),a  
1f94 3a a3 1f			ld a, (.dmark+1)  
1f97 32 6f fe			ld (debug_mark+1),a  
1f9a 3a a4 1f			ld a, (.dmark+2)  
1f9d 32 70 fe			ld (debug_mark+2),a  
1fa0 18 03			jr .pastdmark  
1fa2 ..			.dmark: db "PSQ"  
1fa5 f1			.pastdmark: pop af  
1fa6			endm  
# End of macro DMARK
1fa6				CALLMONITOR 
1fa6 cd ab 18			call break_point_state  
1fa9				endm  
# End of macro CALLMONITOR
1fa9			endif	 
1fa9			    
1fa9 e5				push hl 
1faa e5				push hl 
1fab			 
1fab			;	ld a, 0   ; find end of string 
1fab cd 62 13			call strlenz 
1fae			if DEBUG_FORTH_PUSH 
1fae						DMARK "PQ2" 
1fae f5				push af  
1faf 3a c3 1f			ld a, (.dmark)  
1fb2 32 6e fe			ld (debug_mark),a  
1fb5 3a c4 1f			ld a, (.dmark+1)  
1fb8 32 6f fe			ld (debug_mark+1),a  
1fbb 3a c5 1f			ld a, (.dmark+2)  
1fbe 32 70 fe			ld (debug_mark+2),a  
1fc1 18 03			jr .pastdmark  
1fc3 ..			.dmark: db "PQ2"  
1fc6 f1			.pastdmark: pop af  
1fc7			endm  
# End of macro DMARK
1fc7				CALLMONITOR 
1fc7 cd ab 18			call break_point_state  
1fca				endm  
# End of macro CALLMONITOR
1fca			endif	 
1fca eb				ex de, hl 
1fcb e1				pop hl   ; get ptr to start of string 
1fcc			if DEBUG_FORTH_PUSH 
1fcc						DMARK "PQ3" 
1fcc f5				push af  
1fcd 3a e1 1f			ld a, (.dmark)  
1fd0 32 6e fe			ld (debug_mark),a  
1fd3 3a e2 1f			ld a, (.dmark+1)  
1fd6 32 6f fe			ld (debug_mark+1),a  
1fd9 3a e3 1f			ld a, (.dmark+2)  
1fdc 32 70 fe			ld (debug_mark+2),a  
1fdf 18 03			jr .pastdmark  
1fe1 ..			.dmark: db "PQ3"  
1fe4 f1			.pastdmark: pop af  
1fe5			endm  
# End of macro DMARK
1fe5				CALLMONITOR 
1fe5 cd ab 18			call break_point_state  
1fe8				endm  
# End of macro CALLMONITOR
1fe8			endif	 
1fe8 19				add hl,de 
1fe9			if DEBUG_FORTH_PUSH 
1fe9						DMARK "PQE" 
1fe9 f5				push af  
1fea 3a fe 1f			ld a, (.dmark)  
1fed 32 6e fe			ld (debug_mark),a  
1ff0 3a ff 1f			ld a, (.dmark+1)  
1ff3 32 6f fe			ld (debug_mark+1),a  
1ff6 3a 00 20			ld a, (.dmark+2)  
1ff9 32 70 fe			ld (debug_mark+2),a  
1ffc 18 03			jr .pastdmark  
1ffe ..			.dmark: db "PQE"  
2001 f1			.pastdmark: pop af  
2002			endm  
# End of macro DMARK
2002				CALLMONITOR 
2002 cd ab 18			call break_point_state  
2005				endm  
# End of macro CALLMONITOR
2005			endif	 
2005			 
2005 2b				dec hl    ; see if there is an optional trailing double quote 
2006 7e				ld a,(hl) 
2007 fe 22			cp '"' 
2009 20 03			jr nz, .strnoq 
200b 3e 00			ld a, 0      ; get rid of double quote 
200d 77				ld (hl), a 
200e 23			.strnoq: inc hl 
200f			 
200f 3e 00			ld a, 0 
2011 77				ld (hl), a     ; add null term and get rid of trailing double quote 
2012			 
2012 13				inc de ; add one for the type string 
2013 13				inc de ; add one for null term??? 
2014			 
2014				; tos is get string pointer again 
2014				; de contains space to allocate 
2014				 
2014 d5				push de 
2015			 
2015 eb				ex de, hl 
2016			 
2016				;push af 
2016			 
2016			if DEBUG_FORTH_PUSH 
2016						DMARK "PHm" 
2016 f5				push af  
2017 3a 2b 20			ld a, (.dmark)  
201a 32 6e fe			ld (debug_mark),a  
201d 3a 2c 20			ld a, (.dmark+1)  
2020 32 6f fe			ld (debug_mark+1),a  
2023 3a 2d 20			ld a, (.dmark+2)  
2026 32 70 fe			ld (debug_mark+2),a  
2029 18 03			jr .pastdmark  
202b ..			.dmark: db "PHm"  
202e f1			.pastdmark: pop af  
202f			endm  
# End of macro DMARK
202f				CALLMONITOR 
202f cd ab 18			call break_point_state  
2032				endm  
# End of macro CALLMONITOR
2032			endif	 
2032 cd cb 13			call malloc	; on ret hl now contains allocated memory 
2035				if DEBUG_FORTH_MALLOC_GUARD 
2035 cc 9e 55				call z,malloc_error 
2038				endif 
2038			 
2038				 
2038 c1				pop bc    ; get length 
2039 d1				pop de   ;  get string start    
203a			 
203a				; hl has destination from malloc 
203a			 
203a eb				ex de, hl    ; prep for ldir 
203b			 
203b d5				push de   ; save malloc area for DSP later 
203c				;push hl   ; save malloc area for DSP later 
203c			 
203c			if DEBUG_FORTH_PUSH 
203c						DMARK "PHc" 
203c f5				push af  
203d 3a 51 20			ld a, (.dmark)  
2040 32 6e fe			ld (debug_mark),a  
2043 3a 52 20			ld a, (.dmark+1)  
2046 32 6f fe			ld (debug_mark+1),a  
2049 3a 53 20			ld a, (.dmark+2)  
204c 32 70 fe			ld (debug_mark+2),a  
204f 18 03			jr .pastdmark  
2051 ..			.dmark: db "PHc"  
2054 f1			.pastdmark: pop af  
2055			endm  
# End of macro DMARK
2055				CALLMONITOR 
2055 cd ab 18			call break_point_state  
2058				endm  
# End of macro CALLMONITOR
2058			endif	 
2058			 
2058			 
2058 ed b0			ldir 
205a			 
205a			 
205a				; push malloc to data stack     macro?????  
205a			 
205a				FORTH_DSP_NEXT 
205a cd ae 1e			call macro_forth_dsp_next 
205d				endm 
# End of macro FORTH_DSP_NEXT
205d			 
205d				; save value and type 
205d			 
205d 2a 2a fa			ld hl, (cli_data_sp) 
2060			 
2060				; save item type 
2060 3e 01			ld a,  DS_TYPE_STR 
2062 77				ld (hl), a 
2063 23				inc hl 
2064			 
2064				; get malloc word off stack 
2064 d1				pop de 
2065 73				ld (hl), e 
2066 23				inc hl 
2067 72				ld (hl), d 
2068			 
2068			 
2068			 
2068			if DEBUG_FORTH_PUSH 
2068 2a 2a fa			ld hl, (cli_data_sp) 
206b						DMARK "PHS" 
206b f5				push af  
206c 3a 80 20			ld a, (.dmark)  
206f 32 6e fe			ld (debug_mark),a  
2072 3a 81 20			ld a, (.dmark+1)  
2075 32 6f fe			ld (debug_mark+1),a  
2078 3a 82 20			ld a, (.dmark+2)  
207b 32 70 fe			ld (debug_mark+2),a  
207e 18 03			jr .pastdmark  
2080 ..			.dmark: db "PHS"  
2083 f1			.pastdmark: pop af  
2084			endm  
# End of macro DMARK
2084				CALLMONITOR 
2084 cd ab 18			call break_point_state  
2087				endm  
# End of macro CALLMONITOR
2087			;	ex de,hl 
2087			endif	 
2087				; in case of spaces, skip the ptr past the copied string 
2087				;pop af 
2087				;ld (cli_origptr),hl 
2087			 
2087 c9				ret 
2088			 
2088			 
2088			 
2088			; TODO ascii push input onto stack given hl to start of input 
2088			 
2088			; identify type 
2088			; if starts with a " then a string 
2088			; otherwise it is a number 
2088			;  
2088			; if a string 
2088			;     scan for ending " to get length of string to malloc for + 1 
2088			;     malloc 
2088			;     put pointer to string on stack first byte flags as string 
2088			; 
2088			; else a number 
2088			;    look for number format identifier 
2088			;    $xx hex 
2088			;    %xxxxx bin 
2088			;    xxxxx decimal 
2088			;    convert number to 16bit word.  
2088			;    malloc word + 1 with flag to identiy as num 
2088			;    put pointer to number on stack 
2088			;   
2088			;  
2088			  
2088			forth_apush: 
2088				; kernel push 
2088			 
2088			if DEBUG_FORTH_PUSH 
2088						DMARK "PSH" 
2088 f5				push af  
2089 3a 9d 20			ld a, (.dmark)  
208c 32 6e fe			ld (debug_mark),a  
208f 3a 9e 20			ld a, (.dmark+1)  
2092 32 6f fe			ld (debug_mark+1),a  
2095 3a 9f 20			ld a, (.dmark+2)  
2098 32 70 fe			ld (debug_mark+2),a  
209b 18 03			jr .pastdmark  
209d ..			.dmark: db "PSH"  
20a0 f1			.pastdmark: pop af  
20a1			endm  
# End of macro DMARK
20a1				CALLMONITOR 
20a1 cd ab 18			call break_point_state  
20a4				endm  
# End of macro CALLMONITOR
20a4			endif	 
20a4				; identify input type 
20a4			 
20a4 7e				ld a,(hl) 
20a5 fe 22			cp '"' 
20a7 28 0a			jr z, .fapstr 
20a9 fe 24			cp '$' 
20ab ca d3 20			jp z, .faphex 
20ae fe 25			cp '%' 
20b0 ca bb 20			jp z, .fapbin 
20b3			;	cp 'b' 
20b3			;	jp z, .fabin 
20b3				; else decimal 
20b3			 
20b3				; TODO do decimal conversion 
20b3				; decimal is stored as a 16bit word 
20b3			 
20b3				; by default everything is a string if type is not detected 
20b3			.fapstr: ; 
20b3 fe 22			cp '"' 
20b5 20 01			jr nz, .strnoqu 
20b7 23				inc hl 
20b8			.strnoqu: 
20b8 c3 8d 1f			jp forth_push_str 
20bb			 
20bb			 
20bb			 
20bb			.fapbin:    ; push a binary string.  
20bb 11 00 00			ld de, 0   ; hold a 16bit value 
20be			 
20be 23			.fapbinshift:	inc hl  
20bf 7e				ld a,(hl) 
20c0 fe 00			cp 0     ; done scanning  
20c2 28 0b			jr z, .fapbdone  	; got it in HL so push  
20c4			 
20c4				; left shift de 
20c4 eb				ex de, hl	 
20c5 29				add hl, hl 
20c6			 
20c6				; is 1 
20c6 fe 31			cp '1' 
20c8 20 02			jr nz, .binzero 
20ca cb 4d			bit 1, l 
20cc			.binzero: 
20cc eb				ex de, hl	 ; save current de 
20cd 18 ef			jr .fapbinshift 
20cf			 
20cf			.fapbdone: 
20cf eb				ex de, hl 
20d0 c3 1f 1f			jp forth_push_numhl 
20d3			 
20d3			 
20d3			.faphex:   ; hex is always stored as a 16bit word 
20d3				; skip number prefix 
20d3 23				inc hl 
20d4				; turn ascii into number 
20d4 cd bb 12			call get_word_hl	; ret 16bit word in hl 
20d7			 
20d7 c3 1f 1f			jp forth_push_numhl 
20da			 
20da 00				 nop 
20db			 
20db			.fabin:   ; TODO bin conversion 
20db			 
20db			 
20db c9				ret 
20dc			 
20dc			 
20dc			; get either a string ptr or a 16bit word from the data stack 
20dc			 
20dc			FORTH_DSP: macro 
20dc				call macro_forth_dsp 
20dc				endm 
20dc			 
20dc			macro_forth_dsp: 
20dc				; data stack pointer points to current word on tos 
20dc			 
20dc 2a 2a fa			ld hl,(cli_data_sp) 
20df			 
20df				if DEBUG_FORTH_PUSH 
20df						DMARK "DSP" 
20df f5				push af  
20e0 3a f4 20			ld a, (.dmark)  
20e3 32 6e fe			ld (debug_mark),a  
20e6 3a f5 20			ld a, (.dmark+1)  
20e9 32 6f fe			ld (debug_mark+1),a  
20ec 3a f6 20			ld a, (.dmark+2)  
20ef 32 70 fe			ld (debug_mark+2),a  
20f2 18 03			jr .pastdmark  
20f4 ..			.dmark: db "DSP"  
20f7 f1			.pastdmark: pop af  
20f8			endm  
# End of macro DMARK
20f8			 
20f8 cd d3 55				call display_data_sp 
20fb				;call break_point_state 
20fb				;rst 030h 
20fb				CALLMONITOR 
20fb cd ab 18			call break_point_state  
20fe				endm  
# End of macro CALLMONITOR
20fe				endif 
20fe			 
20fe c9				ret 
20ff			 
20ff			; return hl to start of value on stack 
20ff			 
20ff			FORTH_DSP_VALUE: macro 
20ff				call macro_forth_dsp_value 
20ff				endm 
20ff			 
20ff			macro_forth_dsp_value: 
20ff			 
20ff				FORTH_DSP 
20ff cd dc 20			call macro_forth_dsp 
2102				endm 
# End of macro FORTH_DSP
2102			 
2102 d5				push de 
2103			 
2103 23				inc hl ; skip type 
2104			 
2104 5e				ld e, (hl) 
2105 23				inc hl 
2106 56				ld d, (hl) 
2107 eb				ex de,hl  
2108			 
2108 d1				pop de 
2109			 
2109 c9				ret 
210a			 
210a			; return hl to start of value to second item on stack 
210a			 
210a			FORTH_DSP_VALUEM1: macro 
210a				call macro_forth_dsp_value_m1 
210a				endm 
210a			 
210a			macro_forth_dsp_value_m1: 
210a			 
210a				FORTH_DSP 
210a cd dc 20			call macro_forth_dsp 
210d				endm 
# End of macro FORTH_DSP
210d			 
210d 2b				dec hl 
210e 2b				dec hl 
210f			;	dec hl 
210f			 
210f d5				push de 
2110			 
2110 5e				ld e, (hl) 
2111 23				inc hl 
2112 56				ld d, (hl) 
2113 eb				ex de,hl  
2114			 
2114 d1				pop de 
2115			 
2115 c9				ret 
2116			 
2116				 
2116			 
2116			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
2116			 
2116			FORTH_DSP_POP: macro 
2116				call macro_forth_dsp_pop 
2116				endm 
2116			 
2116			 
2116			; get the tos data type 
2116			 
2116			FORTH_DSP_TYPE:   macro 
2116			 
2116				;FORTH_DSP_VALUE 
2116				FORTH_DSP 
2116				 
2116				; hl points to value 
2116				; check type 
2116			 
2116				ld a,(hl) 
2116			 
2116				endm 
2116			 
2116			; load the tos value into hl 
2116			 
2116			 
2116			FORTH_DSP_VALUEHL:  macro 
2116				call macro_dsp_valuehl 
2116				endm 
2116			 
2116			 
2116			 
2116			macro_dsp_valuehl: 
2116				FORTH_DSP_VALUE 
2116 cd ff 20			call macro_forth_dsp_value 
2119				endm 
# End of macro FORTH_DSP_VALUE
2119			 
2119				;FORTH_ERR_TOS_NOTNUM 
2119			 
2119				;inc hl   ; skip type id 
2119			 
2119			;	push de 
2119			; 
2119			;	ld e, (hl) 
2119			;	inc hl 
2119			;	ld d, (hl) 
2119			;	ex de,hl  
2119			 
2119			;	pop de 
2119			 
2119				if DEBUG_FORTH_PUSH 
2119						DMARK "DVL" 
2119 f5				push af  
211a 3a 2e 21			ld a, (.dmark)  
211d 32 6e fe			ld (debug_mark),a  
2120 3a 2f 21			ld a, (.dmark+1)  
2123 32 6f fe			ld (debug_mark+1),a  
2126 3a 30 21			ld a, (.dmark+2)  
2129 32 70 fe			ld (debug_mark+2),a  
212c 18 03			jr .pastdmark  
212e ..			.dmark: db "DVL"  
2131 f1			.pastdmark: pop af  
2132			endm  
# End of macro DMARK
2132				CALLMONITOR 
2132 cd ab 18			call break_point_state  
2135				endm  
# End of macro CALLMONITOR
2135				endif 
2135 c9				ret 
2136			 
2136			forth_apushstrhl:      
2136				; push of string requires use of cli_origptr 
2136				; bodge use 
2136			 
2136				; get current cli_origptr, save, update with temp pointer  
2136 ed 5b 46 fa		ld de, (cli_origptr) 
213a 22 46 fa			ld (cli_origptr), hl 
213d d5				push de 
213e cd 88 20			call forth_apush 
2141 d1				pop de 
2142 ed 53 46 fa		ld (cli_origptr), de 
2146 c9			        ret	 
2147			 
2147			 
2147			; increase loop stack pointer and save hl to it 
2147				 
2147			FORTH_LOOP_NEXT: macro 
2147				call macro_forth_loop_next 
2147				;nop 
2147				endm 
2147			 
2147			macro_forth_loop_next: 
2147				if DEBUG_FORTH_STACK_GUARD 
2147 cd b0 66				call check_stacks 
214a				endif 
214a e5				push hl 
214b d5				push de 
214c eb				ex de,hl 
214d 2a 2c fa			ld hl,(cli_loop_sp) 
2150 23				inc hl 
2151 23				inc hl 
2152					if DEBUG_FORTH_WORDS 
2152						DMARK "LNX" 
2152 f5				push af  
2153 3a 67 21			ld a, (.dmark)  
2156 32 6e fe			ld (debug_mark),a  
2159 3a 68 21			ld a, (.dmark+1)  
215c 32 6f fe			ld (debug_mark+1),a  
215f 3a 69 21			ld a, (.dmark+2)  
2162 32 70 fe			ld (debug_mark+2),a  
2165 18 03			jr .pastdmark  
2167 ..			.dmark: db "LNX"  
216a f1			.pastdmark: pop af  
216b			endm  
# End of macro DMARK
216b						CALLMONITOR 
216b cd ab 18			call break_point_state  
216e				endm  
# End of macro CALLMONITOR
216e					endif 
216e 22 2c fa			ld (cli_loop_sp),hl 
2171 73				ld (hl), e 
2172 23				inc hl 
2173 72				ld (hl), d 
2174 d1				pop de    ; been reversed so save a swap on restore 
2175 e1				pop hl 
2176				if DEBUG_FORTH_STACK_GUARD 
2176 cd b0 66				call check_stacks 
2179				endif 
2179 c9				ret 
217a			 
217a			; get current ret stack pointer and save to hl  
217a				 
217a			FORTH_LOOP_TOS: macro 
217a				call macro_forth_loop_tos 
217a				endm 
217a			 
217a			macro_forth_loop_tos: 
217a d5				push de 
217b 2a 2c fa			ld hl,(cli_loop_sp) 
217e 5e				ld e, (hl) 
217f 23				inc hl 
2180 56				ld d, (hl) 
2181 eb				ex de, hl 
2182 d1				pop de 
2183 c9				ret 
2184			 
2184			; pop loop stack pointer 
2184				 
2184			FORTH_LOOP_POP: macro 
2184				call macro_forth_loop_pop 
2184				endm 
2184			 
2184			 
2184			macro_forth_loop_pop: 
2184				if DEBUG_FORTH_STACK_GUARD 
2184					DMARK "LPP" 
2184 f5				push af  
2185 3a 99 21			ld a, (.dmark)  
2188 32 6e fe			ld (debug_mark),a  
218b 3a 9a 21			ld a, (.dmark+1)  
218e 32 6f fe			ld (debug_mark+1),a  
2191 3a 9b 21			ld a, (.dmark+2)  
2194 32 70 fe			ld (debug_mark+2),a  
2197 18 03			jr .pastdmark  
2199 ..			.dmark: db "LPP"  
219c f1			.pastdmark: pop af  
219d			endm  
# End of macro DMARK
219d cd b0 66				call check_stacks 
21a0					FORTH_CHK_LOOP_UNDER 
21a0 e5				push hl 
21a1 d5				push de 
21a2 2a 2c fa			ld hl,(cli_loop_sp) 
21a5 11 66 f9			ld de, cli_loop_stack 
21a8 cd 22 0f			call cmp16 
21ab da ca 67			jp c, fault_loop_under 
21ae d1				pop de 
21af e1				pop hl 
21b0				endm 
# End of macro FORTH_CHK_LOOP_UNDER
21b0				endif 
21b0 e5				push hl 
21b1 2a 2c fa			ld hl,(cli_loop_sp) 
21b4 2b				dec hl 
21b5 2b				dec hl 
21b6 22 2c fa			ld (cli_loop_sp), hl 
21b9				; TODO do stack underflow checks 
21b9 e1				pop hl 
21ba				if DEBUG_FORTH_STACK_GUARD 
21ba cd b0 66				call check_stacks 
21bd					FORTH_CHK_LOOP_UNDER 
21bd e5				push hl 
21be d5				push de 
21bf 2a 2c fa			ld hl,(cli_loop_sp) 
21c2 11 66 f9			ld de, cli_loop_stack 
21c5 cd 22 0f			call cmp16 
21c8 da ca 67			jp c, fault_loop_under 
21cb d1				pop de 
21cc e1				pop hl 
21cd				endm 
# End of macro FORTH_CHK_LOOP_UNDER
21cd				endif 
21cd c9				ret 
21ce			 
21ce			macro_forth_dsp_pop: 
21ce			 
21ce e5				push hl 
21cf			 
21cf				; release malloc data 
21cf			 
21cf				if DEBUG_FORTH_STACK_GUARD 
21cf cd b0 66				call check_stacks 
21d2					FORTH_CHK_DSP_UNDER 
21d2 e5				push hl 
21d3 d5				push de 
21d4 2a 2a fa			ld hl,(cli_data_sp) 
21d7 11 64 f7			ld de, cli_data_stack 
21da cd 22 0f			call cmp16 
21dd da be 67			jp c, fault_dsp_under 
21e0 d1				pop de 
21e1 e1				pop hl 
21e2				endm 
# End of macro FORTH_CHK_DSP_UNDER
21e2				endif 
21e2				;ld hl,(cli_data_sp) 
21e2			if DEBUG_FORTH_DOT 
21e2				DMARK "DPP" 
21e2				CALLMONITOR 
21e2			endif	 
21e2			 
21e2			 
21e2			if FORTH_ENABLE_DSPPOPFREE 
21e2			 
21e2				FORTH_DSP 
21e2 cd dc 20			call macro_forth_dsp 
21e5				endm 
# End of macro FORTH_DSP
21e5			 
21e5 7e				ld a, (hl) 
21e6 fe 01			cp DS_TYPE_STR 
21e8 20 07			jr nz, .skippopfree 
21ea			 
21ea				FORTH_DSP_VALUEHL 
21ea cd 16 21			call macro_dsp_valuehl 
21ed				endm 
# End of macro FORTH_DSP_VALUEHL
21ed 00				nop 
21ee			if DEBUG_FORTH_DOT 
21ee				DMARK "DPf" 
21ee				CALLMONITOR 
21ee			endif	 
21ee cd 95 14			call free 
21f1			.skippopfree: 
21f1				 
21f1			 
21f1			endif 
21f1			 
21f1			if DEBUG_FORTH_DOT_KEY 
21f1				DMARK "DP2" 
21f1				CALLMONITOR 
21f1			endif	 
21f1			 
21f1				; move pointer down 
21f1			 
21f1 2a 2a fa			ld hl,(cli_data_sp) 
21f4 2b				dec hl 
21f5 2b				dec hl 
21f6			; PARSEV5 
21f6 2b				dec hl 
21f7 22 2a fa			ld (cli_data_sp), hl 
21fa			 
21fa				if DEBUG_FORTH_STACK_GUARD 
21fa cd b0 66				call check_stacks 
21fd					FORTH_CHK_DSP_UNDER 
21fd e5				push hl 
21fe d5				push de 
21ff 2a 2a fa			ld hl,(cli_data_sp) 
2202 11 64 f7			ld de, cli_data_stack 
2205 cd 22 0f			call cmp16 
2208 da be 67			jp c, fault_dsp_under 
220b d1				pop de 
220c e1				pop hl 
220d				endm 
# End of macro FORTH_CHK_DSP_UNDER
220d				endif 
220d			 
220d e1				pop hl 
220e			 
220e c9				ret 
220f			 
220f			getwordathl: 
220f				; hl points to an address 
220f				; load hl with the word at that address 
220f			 
220f d5				push de 
2210			 
2210 5e				ld e, (hl) 
2211 23				inc hl 
2212 56				ld d, (hl) 
2213 eb				ex de, hl 
2214			 
2214 d1				pop de 
2215 c9				ret 
2216			 
2216			 
2216			 
2216			 
2216			 
2216			; eof 
2216			 
# End of file forth_stackopsv5.asm
2216			endif 
2216			 
2216			user_word_eol:  
2216				; hl contains the pointer to where to create a linked list item from the end 
2216				; of the user dict to continue on at the system word dict 
2216				 
2216				; poke the stub of the word list linked list to repoint to rom words 
2216			 
2216				; stub format 
2216				; db   word id 
2216				; dw    link to next word 
2216			        ; db char length of token 
2216				; db string + 0 term 
2216				; db exec code....  
2216			 
2216 3e 00			ld a, WORD_SYS_ROOT     ; root word 
2218 77				ld (hl), a		; word id 
2219 23				inc hl 
221a			 
221a 11 e5 23			ld de, sysdict 
221d 73				ld (hl), e		; next word link ie system dict 
221e 23				inc hl 
221f 72				ld (hl), d		; next word link ie system dict 
2220 23				inc hl	 
2221			 
2221			;	ld (hl), sysdict		; next word link ie system dict 
2221			;	inc hl 
2221			;	inc hl 
2221			 
2221			;	inc hl 
2221			;	inc hl 
2221			 
2221 3e 02			ld a, 2			; word length is 0 
2223 77				ld (hl), a	 
2224 23				inc hl 
2225			 
2225 3e 7e			ld a, '~'			; word length is 0 
2227 77				ld (hl), a	 
2228 23				inc hl 
2229 3e 00			ld a, 0			; save empty word 
222b 77				ld (hl), a 
222c			 
222c c9				ret 
222d			 
222d				 
222d			 
222d			forthexec_cleanup: 
222d				FORTH_RSP_POP 
222d cd e7 1e			call macro_forth_rsp_pop 
2230				endm 
# End of macro FORTH_RSP_POP
2230 c9				ret 
2231			 
2231			forth_call_hl: 
2231				; taking hl 
2231 e5				push hl 
2232 c9				ret 
2233			 
2233			; this is called to reset Forth system but keep existing uwords etc 
2233			 
2233			forth_warmstart: 
2233				; setup stack over/under flow checks 
2233				if DEBUG_FORTH_STACK_GUARD 
2233 cd 96 66				call chk_stk_init 
2236				endif 
2236			 
2236				; init stack pointers  - * these stacks go upwards *  
2236 21 e8 f9			ld hl, cli_ret_stack 
2239 22 2e fa			ld (cli_ret_sp), hl	 
223c				; set bottom of stack 
223c 3e 00			ld a,0 
223e 77				ld (hl),a 
223f 23				inc hl 
2240 77				ld (hl),a 
2241			 
2241 21 64 f7			ld hl, cli_data_stack 
2244 22 2a fa			ld (cli_data_sp), hl	 
2247				; set bottom of stack 
2247 3e 00			ld a,0 
2249 77				ld (hl),a 
224a 23				inc hl 
224b 77				ld (hl),a 
224c			 
224c 21 66 f9			ld hl, cli_loop_stack 
224f 22 2c fa			ld (cli_loop_sp), hl	 
2252				; set bottom of stack 
2252 3e 00			ld a,0 
2254 77				ld (hl),a 
2255 23				inc hl 
2256 77				ld (hl),a 
2257			 
2257				; init extent of current open file 
2257			 
2257 3e 00			ld a, 0 
2259 32 71 fa			ld (store_openext), a 
225c			 
225c c9				ret 
225d			 
225d			 
225d			; Cold Start - this is called to setup the whole Forth system 
225d			 
225d			forth_init: 
225d			 
225d				; setup stack over/under flow checks 
225d			 
225d			;	if DEBUG_FORTH_STACK_GUARD 
225d			;		call chk_stk_init 
225d			;	endif 
225d			 
225d				; enable auto display updates (slow.....) 
225d			 
225d 3e 01			ld a, 1 
225f 32 44 fa			ld (cli_autodisplay), a 
2262			 
2262				; if storage is in use disable long reads for now 
2262 3e 00			ld a, 0 
2264 32 7c fa			ld (store_longread), a 
2267			 
2267			 
2267				; show start up screen 
2267			 
2267 cd d0 0c			call clear_display 
226a			 
226a 3e 00			ld a,0 
226c 32 66 fa			ld (f_cursor_ptr), a 
226f			 
226f				; set start of word list in start of ram - for use when creating user words 
226f			 
226f 21 00 80			ld hl, baseram 
2272 22 fa f4			ld (os_last_new_uword), hl 
2275 cd 16 22			call user_word_eol 
2278				 
2278			;		call display_data_sp 
2278			;		call next_page_prompt 
2278			 
2278			 
2278			 
2278			 
2278 c9				ret 
2279			 
2279 .. 00		.bootforth: db " Forth Kernel Init ",0 
228d			 
228d			; TODO push to stack 
228d			 
228d			;  
228d			 
228d			if FORTH_PARSEV2 
228d			 
228d			 
228d				include "forth_parserv2.asm" 
228d			 
228d			endif 
228d			 
228d			 
228d			; parse cli version 1 
228d			 
228d			if FORTH_PARSEV1 
228d			 
228d			 
228d			 
228d			      include "forth_parserv1.asm" 
228d			endif 
228d				 
228d			if FORTH_PARSEV3 
228d			 
228d			 
228d			 
228d			      include "forth_parserv3.asm" 
228d				include "forth_wordsv3.asm" 
228d			endif 
228d			 
228d			if FORTH_PARSEV4 
228d			 
228d			 
228d			 
228d			      include "forth_parserv4.asm" 
228d				include "forth_wordsv4.asm" 
228d			endif 
228d			 
228d			if FORTH_PARSEV5 
228d			 
228d			 
228d			 
228d			      include "forth_parserv5.asm" 
228d			 
228d			 
228d			; A better parser without using malloc and string copies all over the place.  
228d			; Exec in situ should be faster 
228d			 
228d			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
228d			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
228d			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
228d			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
228d			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
228d			WORD_SYS_END: equ 0   ; Opcode for all user words 
228d			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
228d			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
228d			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
228d			 
228d			; Core word preamble macro 
228d			 
228d			CWHEAD:   macro nxtword opcode lit len opflags 
228d				db WORD_SYS_CORE+opcode             
228d				; internal op code number 
228d				dw nxtword            
228d				; link to next dict word block 
228d				db len + 1 
228d				; literal length of dict word inc zero term 
228d				db lit,0              
228d				; literal dict word 
228d			        ; TODO db opflags        
228d				endm 
228d			 
228d			 
228d			NEXTW: macro  
228d				jp macro_next 
228d				endm 
228d			 
228d			macro_next: 
228d			if DEBUG_FORTH_PARSE_KEY 
228d				DMARK "NXT" 
228d				CALLMONITOR 
228d			endif	 
228d			;	inc hl  ; skip token null term  
228d ed 4b 48 fa		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
2291 ed 5b 46 fa		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
2295 2a fe f4			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2298			if DEBUG_FORTH_PARSE_KEY 
2298				DMARK "}AA" 
2298				CALLMONITOR 
2298			endif	 
2298 c3 9b 23			jp execnext 
229b				;jp exec1 
229b			       
229b			 
229b			 
229b			; Another go at the parser to compile  
229b			 
229b			 
229b			; TODO rework parser to change all of the string words to byte tokens 
229b			; TODO do a search for  
229b			 
229b			; TODO first run normal parser to zero term sections 
229b			; TODO for each word do a token look up to get the op code 
229b			; TODO need some means to flag to the exec that this is a byte code form    
229b			 
229b			 
229b			forthcompile: 
229b			 
229b			; 
229b			; line parse: 
229b			;       parse raw input buffer 
229b			;       tokenise the words 
229b			;       malloc new copy (for looping etc) 
229b			;       copy to malloc + current pc in line to start of string and add line term 
229b			;       save on new rsp 
229b			; 
229b			 
229b			; hl to point to the line to tokenise 
229b			 
229b			;	push hl 
229b 22 fe f4			ld (os_tok_ptr), hl  ; save ptr to string 
229e			 
229e			;	ld a,0		; string term on input 
229e			;	call strlent 
229e			 
229e			;	ld (os_tok_len), hl	 ; save string length 
229e			 
229e			;if DEBUG_FORTH_TOK 
229e			;	ex de,hl		 
229e			;endif 
229e			 
229e			;	pop hl 		; get back string pointer 
229e			 
229e			if DEBUG_FORTH_TOK 
229e						DMARK "TOc" 
229e				CALLMONITOR 
229e			endif 
229e 7e			.cptoken2:    ld a,(hl) 
229f 23				inc hl 
22a0 fe 7f			cp FORTH_END_BUFFER 
22a2 28 29			jr z, .cptokendone2 
22a4 fe 00			cp 0 
22a6 28 25			jr z, .cptokendone2 
22a8 fe 22			cp '"' 
22aa 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
22ac fe 20			cp ' ' 
22ae 20 ee			jr nz,  .cptoken2 
22b0			 
22b0			; TODO consume comments held between ( and ) 
22b0			 
22b0				; we have a space so change to zero term for dict match later 
22b0 2b				dec hl 
22b1 3e 00			ld a,0 
22b3 77				ld (hl), a 
22b4 23				inc hl 
22b5 18 e7			jr .cptoken2 
22b7				 
22b7			 
22b7			.cptokenstr2: 
22b7				; skip all white space until either eol (because forgot to term) or end double quote 
22b7			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
22b7				;inc hl ; skip current double quote 
22b7 7e				ld a,(hl) 
22b8 23				inc hl 
22b9 fe 22			cp '"' 
22bb 28 e1			jr z, .cptoken2 
22bd fe 7f			cp FORTH_END_BUFFER 
22bf 28 0c			jr z, .cptokendone2 
22c1 fe 00			cp 0 
22c3 28 08			jr z, .cptokendone2 
22c5 fe 20			cp ' ' 
22c7 28 02			jr z, .cptmp2 
22c9 18 ec			jr .cptokenstr2 
22cb			 
22cb			.cptmp2:	; we have a space so change to zero term for dict match later 
22cb				;dec hl 
22cb				;ld a,"-"	; TODO remove this when working 
22cb				;ld (hl), a 
22cb				;inc hl 
22cb 18 ea			jr .cptokenstr2 
22cd			 
22cd			.cptokendone2: 
22cd				;inc hl 
22cd 3e 7f			ld a, FORTH_END_BUFFER 
22cf 77				ld (hl),a 
22d0 23				inc hl 
22d1 3e 21			ld a, '!' 
22d3 77				ld (hl),a 
22d4			 
22d4 2a fe f4			ld hl,(os_tok_ptr) 
22d7			         
22d7			if DEBUG_FORTH_TOK 
22d7						DMARK "Tc1" 
22d7				CALLMONITOR 
22d7			endif 
22d7			 
22d7				; push exec string to top of return stack 
22d7				FORTH_RSP_NEXT 
22d7 cd c6 1e			call macro_forth_rsp_next 
22da				endm 
# End of macro FORTH_RSP_NEXT
22da c9				ret 
22db			 
22db			; Another go at the parser need to simplify the process 
22db			 
22db			forthparse: 
22db			 
22db			; 
22db			; line parse: 
22db			;       parse raw input buffer 
22db			;       tokenise the words 
22db			;       malloc new copy (for looping etc) 
22db			;       copy to malloc + current pc in line to start of string and add line term 
22db			;       save on new rsp 
22db			; 
22db			 
22db			; hl to point to the line to tokenise 
22db			 
22db			;	push hl 
22db 22 fe f4			ld (os_tok_ptr), hl  ; save ptr to string 
22de			 
22de			;	ld a,0		; string term on input 
22de			;	call strlent 
22de			 
22de			;	ld (os_tok_len), hl	 ; save string length 
22de			 
22de			;if DEBUG_FORTH_TOK 
22de			;	ex de,hl		 
22de			;endif 
22de			 
22de			;	pop hl 		; get back string pointer 
22de			 
22de			if DEBUG_FORTH_TOK 
22de						DMARK "TOK" 
22de				CALLMONITOR 
22de			endif 
22de 7e			.ptoken2:    ld a,(hl) 
22df 23				inc hl 
22e0 fe 7f			cp FORTH_END_BUFFER 
22e2 28 29			jr z, .ptokendone2 
22e4 fe 00			cp 0 
22e6 28 25			jr z, .ptokendone2 
22e8 fe 22			cp '"' 
22ea 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
22ec fe 20			cp ' ' 
22ee 20 ee			jr nz,  .ptoken2 
22f0			 
22f0			; TODO consume comments held between ( and ) 
22f0			 
22f0				; we have a space so change to zero term for dict match later 
22f0 2b				dec hl 
22f1 3e 00			ld a,0 
22f3 77				ld (hl), a 
22f4 23				inc hl 
22f5 18 e7			jr .ptoken2 
22f7				 
22f7			 
22f7			.ptokenstr2: 
22f7				; skip all white space until either eol (because forgot to term) or end double quote 
22f7			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
22f7				;inc hl ; skip current double quote 
22f7 7e				ld a,(hl) 
22f8 23				inc hl 
22f9 fe 22			cp '"' 
22fb 28 e1			jr z, .ptoken2 
22fd fe 7f			cp FORTH_END_BUFFER 
22ff 28 0c			jr z, .ptokendone2 
2301 fe 00			cp 0 
2303 28 08			jr z, .ptokendone2 
2305 fe 20			cp ' ' 
2307 28 02			jr z, .ptmp2 
2309 18 ec			jr .ptokenstr2 
230b			 
230b			.ptmp2:	; we have a space so change to zero term for dict match later 
230b				;dec hl 
230b				;ld a,"-"	; TODO remove this when working 
230b				;ld (hl), a 
230b				;inc hl 
230b 18 ea			jr .ptokenstr2 
230d			 
230d			.ptokendone2: 
230d				;inc hl 
230d 3e 7f			ld a, FORTH_END_BUFFER 
230f 77				ld (hl),a 
2310 23				inc hl 
2311 3e 21			ld a, '!' 
2313 77				ld (hl),a 
2314			 
2314 2a fe f4			ld hl,(os_tok_ptr) 
2317			         
2317			if DEBUG_FORTH_TOK 
2317						DMARK "TK1" 
2317				CALLMONITOR 
2317			endif 
2317			 
2317				; push exec string to top of return stack 
2317				FORTH_RSP_NEXT 
2317 cd c6 1e			call macro_forth_rsp_next 
231a				endm 
# End of macro FORTH_RSP_NEXT
231a c9				ret 
231b			 
231b			; 
231b			;	; malloc size + buffer pointer + if is loop flag 
231b			;	ld hl,(os_tok_len) 		 ; get string length 
231b			; 
231b			;	ld a,l 
231b			; 
231b			;	cp 0			; we dont want to use a null string 
231b			;	ret z 
231b			; 
231b			;;	add 3    ; prefix malloc with buffer for current word ptr 
231b			; 
231b			;	add 5     ; TODO when certain not over writing memory remove 
231b			; 
231b			;		 
231b			; 
231b			;if DEBUG_FORTH_TOK 
231b			;			DMARK "TKE" 
231b			;	CALLMONITOR 
231b			;endif 
231b			; 
231b			;	ld l,a 
231b			;	ld h,0 
231b			;;	push hl   ; save required space for the copy later 
231b			;	call malloc 
231b			;if DEBUG_FORTH_TOK 
231b			;			DMARK "TKM" 
231b			;	CALLMONITOR 
231b			;endif 
231b			;	if DEBUG_FORTH_MALLOC_GUARD 
231b			;		push af 
231b			;		call ishlzero 
231b			;;		ld a, l 
231b			;;		add h 
231b			;;		cp 0 
231b			;		pop af 
231b			;		 
231b			;		call z,malloc_error 
231b			;	endif 
231b			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
231b			; 
231b			; 
231b			;if DEBUG_FORTH_TOK 
231b			;			DMARK "TKR" 
231b			;	CALLMONITOR 
231b			;endif 
231b			; 
231b			;	FORTH_RSP_NEXT 
231b			; 
231b			;	;inc hl	 ; go past current buffer pointer 
231b			;	;inc hl 
231b			;	;inc hl   ; and past if loop flag 
231b			;		; TODO Need to set flag  
231b			; 
231b			;	 
231b			;	 
231b			;	ex de,hl	; malloc is dest 
231b			;	ld hl, (os_tok_len) 
231b			;;	pop bc 
231b			;	ld c, l                
231b			;	ld b,0 
231b			;	ld hl, (os_tok_ptr) 
231b			; 
231b			;if DEBUG_FORTH_TOK 
231b			;			DMARK "TKT" 
231b			;	CALLMONITOR 
231b			;endif 
231b			; 
231b			;	; do str cpy 
231b			; 
231b			;	ldir      ; copy byte in hl to de 
231b			; 
231b			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
231b			; 
231b			;if DEBUG_FORTH_TOK 
231b			; 
231b			;			DMARK "TKY" 
231b			;	CALLMONITOR 
231b			;endif 
231b			;	;ld a,0 
231b			;	;ld a,FORTH_END_BUFFER 
231b			;	ex de, hl 
231b			;	;dec hl			 ; go back over the space delim at the end of word 
231b			;	;ld (hl),a 
231b			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
231b			;	ld a,FORTH_END_BUFFER 
231b			;	ld (hl),a 
231b			;	inc hl 
231b			;	ld a,FORTH_END_BUFFER 
231b			;	ld (hl),a 
231b			; 
231b			;	; init the malloc area data 
231b			;	; set pc for in current area 
231b			;	;ld hl, (os_tok_malloc) 
231b			;	;inc hl 
231b			;	;inc hl 
231b			;	;inc hl 
231b			;	;ex de,hl 
231b			;	;ld hl, (os_tok_malloc) 
231b			;	;ld (hl),e 
231b			;	;inc hl 
231b			;	;ld (hl),d 
231b			; 
231b			; 
231b			;	ld hl,(os_tok_malloc) 
231b			;if DEBUG_FORTH_PARSE_KEY 
231b			;			DMARK "TKU" 
231b			;	CALLMONITOR 
231b			;endif 
231b			; 
231b			;	ret 
231b			 
231b			forthexec: 
231b			 
231b			; line exec: 
231b			; forth parser 
231b			 
231b			; 
231b			;       get current exec line on rsp 
231b			 
231b				FORTH_RSP_TOS 
231b cd dd 1e			call macro_forth_rsp_tos 
231e				endm 
# End of macro FORTH_RSP_TOS
231e			 
231e			;       restore current pc - hl points to malloc of data 
231e			 
231e				;ld e, (hl) 
231e				;inc hl 
231e				;ld d, (hl) 
231e				;ex de,hl 
231e			 
231e			 
231e			exec1: 
231e 22 fe f4			ld (os_tok_ptr), hl 
2321			 
2321				; copy our PC to working vars  
2321 22 48 fa			ld (cli_ptr), hl 
2324 22 46 fa			ld (cli_origptr), hl 
2327			 
2327 7e				ld a,(hl) 
2328 fe 7f			cp FORTH_END_BUFFER 
232a c8				ret z 
232b			 
232b				; skip any nulls 
232b			 
232b fe 00			cp 0 
232d 20 03			jr nz, .execword 
232f 23				inc hl 
2330 18 ec			jr exec1 
2332			 
2332			 
2332			.execword: 
2332			 
2332			 
2332			 
2332			if DEBUG_FORTH_PARSE_KEY 
2332						DMARK "KYQ" 
2332				CALLMONITOR 
2332			endif 
2332			;       while at start of word: 
2332			; get start of dict (in user area first) 
2332			 
2332 21 00 80		ld hl, baseram 
2335			;ld hl, sysdict 
2335 22 4a fa		ld (cli_nextword),hl 
2338			;           match word at pc 
2338			;           exec word 
2338			;           or push to dsp 
2338			;           forward to next token 
2338			;           if line term pop rsp and exit 
2338			;        
2338			 
2338			if DEBUG_FORTH_PARSE_KEY 
2338						DMARK "KYq" 
2338				CALLMONITOR 
2338			endif 
2338			 
2338			; 
2338			; word comp 
2338			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
2338			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
2338			;    move to start of word  
2338			;    compare word to cli_token 
2338			 
2338			.execpnword:	; HL at start of a word in the dictionary to check 
2338			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
2338			;	ld (cli_ptr), hl 
2338			 
2338 2a 4a fa			ld hl,(cli_nextword) 
233b			 
233b cd de 23			call forth_tok_next 
233e			; tok next start here 
233e			;	; TODO skip compiled symbol for now 
233e			;	inc hl 
233e			; 
233e			;	; save pointer to next word 
233e			; 
233e			;	; hl now points to the address of the next word pointer  
233e			;	ld e, (hl) 
233e			;	inc hl 
233e			;	ld d, (hl) 
233e			;	inc l 
233e			; 
233e			;	ex de,hl 
233e			;if DEBUG_FORTH_PARSE_NEXTWORD 
233e			;	push bc 
233e			;	ld bc, (cli_nextword) 
233e			;			DMARK "NXW" 
233e			;	CALLMONITOR 
233e			;	pop bc 
233e			;endif 
233e			; tok next end here 
233e 22 4a fa			ld (cli_nextword), hl     ; save for next check if no match on this word 
2341 eb				ex de, hl 
2342			 
2342			 
2342				; save the pointer of the current token - 1 to check against 
2342				 
2342 22 4e fa			ld (cli_token), hl   
2345				; TODO maybe remove below save if no debug 
2345				; save token string ptr for any debug later 
2345 23				inc hl  
2346 22 50 fa			ld (cli_origtoken), hl 
2349 2b				dec hl 
234a				; save pointer to the start of the next dictionay word 
234a 7e				ld a,(hl)   ; get string length 
234b 47				ld b,a 
234c			.execpnwordinc:  
234c 23				inc hl 
234d 10 fd			djnz .execpnwordinc 
234f 22 4c fa			ld (cli_execword), hl      ; save start of this words code 
2352			 
2352				; now check the word token against the string being parsed 
2352			 
2352 2a 4e fa			ld hl,(cli_token) 
2355 23				inc hl     ; skip string length (use zero term instead to end) 
2356 22 4e fa			ld (cli_token), hl 
2359			 
2359			if DEBUG_FORTH_PARSE_KEY 
2359						DMARK "KY2" 
2359			endif 
2359			if DEBUG_FORTH_PARSE_EXEC 
2359				; see if disabled 
2359			 
2359				ld a, (os_view_disable) 
2359				cp '*' 
2359				jr z, .skip 
2359			 
2359				push hl 
2359				push hl 
2359				call clear_display 
2359				ld de, .compword 
2359				ld a, display_row_1 
2359				call str_at_display 
2359				pop de 
2359				ld a, display_row_2 
2359				call str_at_display 
2359				ld hl,(cli_ptr) 
2359				ld a,(hl) 
2359			        ld hl, os_word_scratch 
2359				ld (hl),a 
2359				ld a,0 
2359				inc hl 
2359				ld (hl),a 	 
2359				ld de, os_word_scratch 
2359				ld a, display_row_2+10 
2359				call str_at_display 
2359				call update_display 
2359				ld a, 100 
2359				call aDelayInMS 
2359				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2359				call delay250ms 
2359				endif 
2359				pop hl 
2359			.skip:  
2359			endif	 
2359			.execpnchar:    ; compare char between token and string to parse 
2359			 
2359			if DEBUG_FORTH_PARSE_KEY 
2359						DMARK "Ky3" 
2359			endif 
2359			if DEBUG_FORTH_PARSE_EXEC 
2359				; see if disabled 
2359			 
2359				ld a, (os_view_disable) 
2359				cp '*' 
2359				jr z, .skip2 
2359			 
2359			;	call clear_display 
2359			ld hl,(cli_token) 
2359			ld a,(hl) 
2359			ld (os_word_scratch),a 
2359				ld hl,(cli_ptr) 
2359			ld a,(hl) 
2359				ld (os_word_scratch+1),a 
2359				ld a,0 
2359				ld (os_word_scratch+2),a 
2359				ld de,os_word_scratch 
2359				ld a,display_row_4 
2359				call str_at_display 
2359				call update_display 
2359			.skip2:  
2359			endif 
2359 2a 4e fa			ld hl,(cli_token) 
235c 7e				ld a, (hl)	 ; char in word token 
235d 23				inc hl 		; move to next char 
235e 22 4e fa			ld (cli_token), hl ; and save it 
2361 47				ld b,a 
2362			 
2362 2a 48 fa			ld hl,(cli_ptr) ;	get the char from the string to parse 
2365 7e				ld a,(hl) 
2366 23				inc hl 
2367 22 48 fa			ld (cli_ptr), hl		; move to next char 
236a cd 59 13			call toUpper 		; make sure the input string matches case 
236d			 
236d			if DEBUG_FORTH_PARSE 
236d			endif 
236d			 
236d				; input stream end of token is a space so get rid of it 
236d			 
236d			;	cp ' ' 
236d			;	jr nz, .pnskipspace 
236d			; 
236d			;	ld a, 0		; make same term as word token term 
236d			; 
236d			;.pnskipspace: 
236d			 
236d			if DEBUG_FORTH_PARSE_KEY 
236d						DMARK "KY7" 
236d			endif 
236d b8				cp b 
236e c2 84 23			jp nz, .execpnskipword	 ; no match so move to next word 
2371				 
2371			;    if same 
2371			;       scan for string terms 0 for token and 32 for input 
2371			 
2371				 
2371			if DEBUG_FORTH_PARSE_KEY 
2371						DMARK "KY8" 
2371			endif 
2371			 
2371 80				add b			 
2372 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
2374							; TODO need to make sure last word in zero term string is accounted for 
2374 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
2376			 
2376			 
2376				; at end of both strings so both are exact match 
2376			 
2376			;       skip ptr for next word 
2376			 
2376 2a 48 fa			ld hl,(cli_ptr) 	; at input string term 
2379 23				inc hl			 ; at next char 
237a 22 48 fa			ld (cli_ptr), hl     ; save for next round of the parser 
237d 22 46 fa			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
2380				 
2380				 
2380			if DEBUG_FORTH_PARSE_KEY 
2380						DMARK "KY3" 
2380			endif 
2380			 
2380			 
2380			 
2380			;       exec code block 
2380			if DEBUG_FORTH_JP 
2380				call clear_display 
2380				call update_display 
2380				call delay1s 
2380				ld hl, (cli_execword)     ; save for next check if no match on this word 
2380				ld a,h 
2380				ld hl, os_word_scratch 
2380				call hexout 
2380				ld hl, (cli_execword)     ; save for next check if no match on this word 
2380				ld a,l 
2380				ld hl, os_word_scratch+2 
2380				call hexout 
2380				ld hl, os_word_scratch+4 
2380				ld a,0 
2380				ld (hl),a 
2380				ld de,os_word_scratch 
2380				call str_at_display 
2380					ld a, display_row_2 
2380					call str_at_display 
2380				ld de, (cli_origtoken) 
2380				ld a, display_row_1+10 
2380					call str_at_display 
2380			 
2380				ld a,display_row_1 
2380				ld de, .foundword 
2380				ld a, display_row_3 
2380				call str_at_display 
2380				call update_display 
2380				call delay1s 
2380				call delay1s 
2380				call delay1s 
2380			endif 
2380			 
2380			if DEBUG_FORTH_PARSE_KEY 
2380						DMARK "KYj" 
2380			endif 
2380				; TODO save the word pointer in this exec 
2380			 
2380 2a 4c fa			ld hl,(cli_execword) 
2383 e9				jp (hl) 
2384			 
2384			 
2384			;    if not same 
2384			;	scan for zero term 
2384			;	get ptr for next word 
2384			;	goto word comp 
2384			 
2384			.execpnskipword:	; get pointer to next word 
2384 2a 4a fa			ld hl,(cli_nextword) 
2387			 
2387 7e				ld a,(hl) 
2388 fe 00			cp WORD_SYS_END 
238a			;	cp 0 
238a 28 09			jr z, .execendofdict			 ; at end of words 
238c			 
238c			if DEBUG_FORTH_PARSE_KEY 
238c						DMARK "KY4" 
238c			endif 
238c			if DEBUG_FORTH_PARSE_EXEC 
238c			 
238c				; see if disabled 
238c			 
238c				ld a, (os_view_disable) 
238c				cp '*' 
238c				jr z, .noskip 
238c			 
238c			 
238c				ld de, .nowordfound 
238c				ld a, display_row_3 
238c				call str_at_display 
238c				call update_display 
238c				ld a, 100 
238c				call aDelayInMS 
238c				 
238c				if DEBUG_FORTH_PARSE_EXEC_SLOW 
238c					call delay250ms 
238c				endif 
238c			.noskip:  
238c			 
238c			endif	 
238c			 
238c 2a 46 fa			ld hl,(cli_origptr) 
238f 22 48 fa			ld (cli_ptr),hl 
2392			 
2392			if DEBUG_FORTH_PARSE_KEY 
2392						DMARK "KY5" 
2392			endif 
2392 c3 38 23			jp .execpnword			; else go to next word 
2395			 
2395			.execendofdict:  
2395			 
2395			if DEBUG_FORTH_PARSE_KEY 
2395						DMARK "KYe" 
2395			endif 
2395			if DEBUG_FORTH_PARSE_EXEC 
2395				; see if disabled 
2395			 
2395				ld a, (os_view_disable) 
2395				cp '*' 
2395				jr z, .ispskip 
2395			 
2395				call clear_display 
2395				call update_display 
2395				call delay1s 
2395				ld de, (cli_origptr) 
2395				ld a, display_row_1 
2395				call str_at_display 
2395				 
2395				ld de, .enddict 
2395				ld a, display_row_3 
2395				call str_at_display 
2395				call update_display 
2395				ld a, 100 
2395				call aDelayInMS 
2395				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2395				call delay1s 
2395				call delay1s 
2395				call delay1s 
2395				endif 
2395			.ispskip:  
2395				 
2395			endif	 
2395			 
2395			 
2395			 
2395				; if the word is not a keyword then must be a literal so push it to stack 
2395			 
2395			; push token to stack to end of word 
2395			 
2395				STACKFRAME ON $1efe $2f9f 
2395				if DEBUG_STACK_IMB 
2395					if ON 
2395						exx 
2395						ld de, $1efe 
2395						ld a, d 
2395						ld hl, curframe 
2395						call hexout 
2395						ld a, e 
2395						ld hl, curframe+2 
2395						call hexout 
2395						ld hl, $1efe 
2395						push hl 
2395						ld hl, $2f9f 
2395						push hl 
2395						exx 
2395					endif 
2395				endif 
2395			endm 
# End of macro STACKFRAME
2395			 
2395 2a fe f4		ld hl,(os_tok_ptr) 
2398 cd 88 20		call forth_apush 
239b			 
239b				STACKFRAMECHK ON $1efe $2f9f 
239b				if DEBUG_STACK_IMB 
239b					if ON 
239b						exx 
239b						ld hl, $2f9f 
239b						pop de   ; $2f9f 
239b						call cmp16 
239b						jr nz, .spnosame 
239b						ld hl, $1efe 
239b						pop de   ; $1efe 
239b						call cmp16 
239b						jr z, .spfrsame 
239b						.spnosame: call showsperror 
239b						.spfrsame: nop 
239b						exx 
239b					endif 
239b				endif 
239b			endm 
# End of macro STACKFRAMECHK
239b			 
239b			execnext: 
239b			 
239b			if DEBUG_FORTH_PARSE_KEY 
239b						DMARK "KY>" 
239b			endif 
239b			; move past token to next word 
239b			 
239b 2a fe f4		ld hl, (os_tok_ptr) 
239e 3e 00		ld a, 0 
23a0 01 ff 00		ld bc, 255     ; input buffer size 
23a3 ed b1		cpir 
23a5			 
23a5			if DEBUG_FORTH_PARSE_KEY 
23a5						DMARK "KY!" 
23a5				CALLMONITOR 
23a5			endif	 
23a5			; TODO this might place hl on the null, so will need to forward on??? 
23a5			;inc hl   ; see if this gets onto the next item 
23a5			 
23a5			 
23a5			; TODO pass a pointer to the buffer to push 
23a5			; TODO call function to push 
23a5			 
23a5			; look for end of input 
23a5			 
23a5			;inc hl 
23a5			;ld a,(hl) 
23a5			;cp FORTH_END_BUFFER 
23a5			;ret z 
23a5			 
23a5			 
23a5 c3 1e 23		jp exec1 
23a8			 
23a8			 
23a8			 
23a8			 
23a8			 
23a8			 
23a8			 
23a8			 
23a8			 
23a8			findnexttok: 
23a8			 
23a8				; hl is pointer to move 
23a8				; de is the token to locate 
23a8			 
23a8					if DEBUG_FORTH 
23a8						DMARK "NTK" 
23a8						CALLMONITOR 
23a8					endif 
23a8 d5				push de 
23a9			 
23a9			.fnt1:	 
23a9				; find first char of token to locate 
23a9			 
23a9 1a				ld a, (de) 
23aa 4f				ld c,a 
23ab 7e				ld a,(hl) 
23ac cd 59 13			call toUpper 
23af					if DEBUG_FORTH 
23af						DMARK "NT1" 
23af						CALLMONITOR 
23af					endif 
23af b9				cp c 
23b0			 
23b0 28 03			jr z, .fnt2cmpmorefirst	 
23b2			 
23b2				; first char not found move to next char 
23b2			 
23b2 23				inc hl 
23b3 18 f4			jr .fnt1 
23b5			 
23b5			.fnt2cmpmorefirst:	 
23b5				; first char of token found.  
23b5			 
23b5 e5				push hl     ; save start of token just in case it is the right one 
23b6 d9				exx 
23b7 e1				pop hl        ; save it to hl' 
23b8 d9				exx 
23b9			 
23b9			 
23b9			.fnt2cmpmore:	 
23b9				; compare the rest 
23b9				 
23b9 23				inc hl 
23ba 13				inc de 
23bb				 
23bb 1a				ld a, (de) 
23bc 4f				ld c,a 
23bd 7e				ld a,(hl) 
23be cd 59 13			call toUpper 
23c1			 
23c1					if DEBUG_FORTH 
23c1						DMARK "NT2" 
23c1						CALLMONITOR 
23c1					endif 
23c1				; c has the token to find char 
23c1				; a has the mem to scan char 
23c1			 
23c1 b9				cp c 
23c2 28 04			jr z,.fntmatch1 
23c4			 
23c4				; they are not the same 
23c4			 
23c4					if DEBUG_FORTH 
23c4						DMARK "NT3" 
23c4						CALLMONITOR 
23c4					endif 
23c4 d1				pop de	; reset de token to look for 
23c5 d5				push de 
23c6 18 e1			jr .fnt1 
23c8				 
23c8			.fntmatch1: 
23c8			 
23c8				; is the same char a null which means we might have a full hit? 
23c8					if DEBUG_FORTH 
23c8						DMARK "NT4" 
23c8						CALLMONITOR 
23c8					endif 
23c8			 
23c8 fe 00			cp 0 
23ca 28 0b			jr z, .fntmatchyes 
23cc			 
23cc				; are we at the end of the token to find? 
23cc			 
23cc					if DEBUG_FORTH 
23cc						DMARK "NT5" 
23cc						CALLMONITOR 
23cc					endif 
23cc 3e 00			ld a, 0 
23ce b9				cp c 
23cf			 
23cf c2 b9 23			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
23d2			 
23d2					if DEBUG_FORTH 
23d2						DMARK "NT6" 
23d2						CALLMONITOR 
23d2					endif 
23d2				; token to find is exhusted but no match to stream 
23d2			 
23d2				; restore tok pointer and continue on 
23d2 d1				pop de 
23d3 d5				push de 
23d4 c3 a9 23			jp .fnt1 
23d7			 
23d7			 
23d7			.fntmatchyes: 
23d7			 
23d7				; hl now contains the end of the found token 
23d7			 
23d7				; get rid of saved token pointer to find 
23d7			 
23d7 d1				pop de 
23d8			 
23d8					if DEBUG_FORTH 
23d8						DMARK "NT9" 
23d8						CALLMONITOR 
23d8					endif 
23d8			 
23d8				; hl will be on the null term so forward on 
23d8			 
23d8				; get back the saved start of the token 
23d8			 
23d8 d9				exx 
23d9 e5				push hl     ; save start of token just in case it is the right one 
23da d9				exx 
23db e1				pop hl        ; save it to hl 
23dc			 
23dc c9				ret 
23dd			 
23dd			 
23dd			; LIST needs to find a specific token   
23dd			; FORGET needs to find a spefici token 
23dd			 
23dd			; SAVE needs to find all tokens by flag 
23dd			; WORDS just needs to scan through all  by flag 
23dd			; UWORDS needs to scan through all by flag 
23dd			 
23dd			 
23dd			; given hl as pointer to start of dict look up string 
23dd			; return hl as pointer to start of word block 
23dd			; or 0 if not found 
23dd			 
23dd			forth_find_tok: 
23dd c9				ret 
23de			 
23de			; given hl as pointer to dict structure 
23de			; move to the next dict block structure 
23de			 
23de			forth_tok_next: 
23de				; hl now points to the address of the next word pointer  
23de				; TODO skip compiled symbol for now 
23de			;	push de 
23de 23				inc hl 
23df 5e				ld e, (hl) 
23e0 23				inc hl 
23e1 56				ld d, (hl) 
23e2 23				inc hl 
23e3			 
23e3 eb				ex de,hl 
23e4			if DEBUG_FORTH_PARSE_NEXTWORD 
23e4				push bc 
23e4				ld bc, (cli_nextword) 
23e4						DMARK "NXW" 
23e4				CALLMONITOR 
23e4				pop bc 
23e4			endif 
23e4			;	pop de	 
23e4 c9				ret 
23e5			 
23e5			 
23e5			 
23e5			; eof 
# End of file forth_parserv5.asm
23e5				include "forth_wordsv4.asm" 
23e5			 
23e5			; the core word dictionary v4 
23e5			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
23e5			 
23e5			; this is a linked list for each of the system words used 
23e5			; user defined words will follow the same format but will be in ram 
23e5			 
23e5			 
23e5			; 
23e5			; 
23e5			; define linked list: 
23e5			; 
23e5			; 1. compiled byte op code 
23e5			; 2. len of text word 
23e5			; 3. text word 
23e5			; 4. ptr to next dictionary word 
23e5			; 5. asm, calls etc for the word 
23e5			; 
23e5			;  if 1 == 0 then last word in dict  
23e5			;   
23e5			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
23e5			;  
23e5			;  
23e5			; create basic standard set of words 
23e5			; 
23e5			;  
23e5			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
23e5			; 2DUP 2DROP 2SWAP  
23e5			; @ C@ - get byte  
23e5			; ! C! - store byte 
23e5			; 0< true if less than zero 
23e5			; 0= true if zero 
23e5			; < >  
23e5			; = true if same 
23e5			; variables 
23e5			 
23e5			 
23e5			; Hardware specific words I may need 
23e5			; 
23e5			; IN OUT  
23e5			; calls to key util functions 
23e5			; calls to hardward abstraction stuff 
23e5			; easy control of frame buffers and lcd i/o 
23e5			; keyboard  
23e5			 
23e5			 
23e5			;DICT: macro 
23e5			; op_code, len, word, next 
23e5			;    word: 
23e5			;    db op_code 
23e5			;    ds word zero term 
23e5			;    dw next 
23e5			;    endm 
23e5			 
23e5			 
23e5			 
23e5			 
23e5			; op code 1 is a flag for user define words which are to be handled differently 
23e5			 
23e5			 
23e5			; 
23e5			; 
23e5			;    TODO on entry to a word this should be the expected environment 
23e5			;    hl - tos value if number then held, if string this is the ptr 
23e5			;    de -  
23e5			 
23e5			 
23e5			; opcode ranges 
23e5			; 0 - end of word dict 
23e5			; 255 - user define words 
23e5			 
23e5			sysdict: 
23e5			include "forth_opcodes.asm" 
23e5			; op codes for forth keywords 
23e5			; free to use code 0  
23e5				OPCODE_HEAP: equ  1 
23e5				OPCODE_EXEC: equ 2 
23e5				OPCODE_DUP: equ 3 
23e5				OPCODE_SWAP: equ 4 
23e5				OPCODE_COLN: equ 5 
23e5				OPCODE_SCOLN: equ 6 
23e5				OPCODE_DROP: equ 7 
23e5				OPCODE_DUP2: equ 8 
23e5				OPCODE_DROP2: equ 9 
23e5				OPCODE_SWAP2: equ 10 
23e5				OPCODE_AT: equ 11 
23e5				OPCODE_CAT: equ 12 
23e5				OPCODE_BANG: equ 13 
23e5				OPCODE_CBANG: equ 14 
23e5				OPCODE_SCALL: equ 15 
23e5				OPCODE_DEPTH: equ 16 
23e5				OPCODE_OVER: equ 17 
23e5				OPCODE_PAUSE: equ 18 
23e5				OPCODE_PAUSES: equ 19 
23e5				OPCODE_ROT: equ 20 
23e5			;free to reuse	OPCODE_WORDS: equ 21 
23e5			        OPCODE_NOT: equ 21 
23e5				OPCODE_UWORDS: equ 22 
23e5				OPCODE_BP: equ 23 
23e5				OPCODE_MONITOR: equ 24  
23e5				OPCODE_MALLOC: equ 25 
23e5				OPCODE_FREE: equ 26 
23e5				OPCODE_LIST: equ 27 
23e5				OPCODE_FORGET: equ 28 
23e5				OPCODE_NOP: equ 29 
23e5				OPCODE_COMO: equ 30 
23e5				OPCODE_COMC: equ 31 
23e5			;free to reuse	OPCODE_ENDCORE: equ 32 
23e5				OPCODE_AFTERSOUND: equ 33 
23e5				OPCODE_GP2: equ 34 
23e5				OPCODE_GP3: equ 35 
23e5				OPCODE_GP4: equ 36 
23e5				OPCODE_SIN: equ 37 
23e5				OPCODE_SOUT: equ 38 
23e5				OPCODE_SPIO: equ 39 
23e5				OPCODE_SPICEH: equ 40 
23e5				OPCODE_SPIOb: equ 41 
23e5				OPCODE_SPII: equ 42 
23e5				OPCODE_SESEL: equ 43 
23e5				OPCODE_CARTDEV: equ 44 
23e5			; free to reuse	OPCODE_ENDDEVICE: equ 45 
23e5				OPCODE_FB: equ 46 
23e5				OPCODE_EMIT: equ 47 
23e5				OPCODE_DOTH: equ 48 
23e5				OPCODE_DOTF: equ 49 
23e5				OPCODE_DOT: equ 50 
23e5				OPCODE_CLS: equ 51 
23e5				OPCODE_DRAW: equ 52 
23e5				OPCODE_DUMP: equ 53 
23e5				OPCODE_CDUMP: equ 54 
23e5				OPCODE_DAT: equ 55 
23e5				OPCODE_HOME: equ 56 
23e5				OPCODE_SPACE: equ 57 
23e5				OPCODE_SPACES: equ 58 
23e5				OPCODE_SCROLL: equ 59 
23e5				OPCODE_ATQ: equ 60 
23e5				OPCODE_AUTODSP: equ 61 
23e5				OPCODE_MENU: equ 62 
23e5			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
23e5				OPCODE_THEN: equ 64 
23e5				OPCODE_ELSE: equ 65 
23e5				OPCODE_DO: equ 66 
23e5				OPCODE_LOOP: equ 67 
23e5				OPCODE_I: equ 68 
23e5				OPCODE_DLOOP: equ 69  
23e5				OPCODE_REPEAT: equ 70  
23e5				OPCODE_UNTIL: equ 71 
23e5				OPCODE_ENDFLOW: equ 72 
23e5				OPCODE_WAITK: equ 73 
23e5				OPCODE_ACCEPT: equ 74 
23e5				OPCODE_EDIT: equ 75 
23e5			;free to reuse	OPCODE_ENDKEY: equ 76 
23e5				OPCODE_LZERO: equ 77 
23e5				OPCODE_TZERO: equ 78 
23e5				OPCODE_LESS: equ 79 
23e5				OPCODE_GT: equ 80 
23e5				OPCODE_EQUAL: equ 81  
23e5			;free to reuse	OPCODE_ENDLOGIC: equ 82 
23e5				OPCODE_NEG: equ 83 
23e5				OPCODE_DIV: equ 84 
23e5				OPCODE_MUL: equ 85 
23e5				OPCODE_MIN: equ 86 
23e5				OPCODE_MAX: equ 87 
23e5				OPCODE_RND16: equ 88 
23e5				OPCODE_RND8: equ 89 
23e5				OPCODE_RND: equ 90 
23e5			;free to reuse	OPCODE_ENDMATHS: equ 91  
23e5				OPCODE_BYNAME: equ 92 
23e5				OPCODE_DIR: equ 93 
23e5				OPCODE_SAVE: equ 94 
23e5				OPCODE_LOAD: equ 95 
23e5				OPCODE_BSAVE: equ 96 
23e5				OPCODE_BLOAD: equ 97 
23e5				OPCODE_SEO: equ 98  
23e5				OPCODE_SEI: equ 99 
23e5				OPCODE_SFREE: equ 100 
23e5				OPCODE_SIZE: equ 101 
23e5				OPCODE_CREATE: equ 102 
23e5				OPCODE_APPEND: equ 103 
23e5				OPCODE_SDEL: equ 104 
23e5				OPCODE_OPEN: equ 105 
23e5				OPCODE_READ: equ 106 
23e5				OPCODE_EOF: equ 106 
23e5				OPCODE_FORMAT: equ 107 
23e5				OPCODE_LABEL: equ 108 
23e5				OPCODE_LABELS: equ 109 
23e5			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
23e5				OPCODE_UPPER: equ 111 
23e5				OPCODE_LOWER: equ 112 
23e5				OPCODE_SUBSTR: equ 113 
23e5				OPCODE_LEFT: equ 114 
23e5				OPCODE_RIGHT: equ 115 
23e5				OPCODE_STR2NUM: equ 116 
23e5				OPCODE_NUM2STR: equ 117 
23e5				OPCODE_CONCAT: equ 118 
23e5				OPCODE_FIND: equ 119 
23e5				OPCODE_LEN: equ 120 
23e5				OPCODE_CHAR: equ 121 
23e5			; free to reuse	OPCODE_STRLEN: equ 122 
23e5			; free to reuse	OPCODE_ENDSTR: equ 123 
23e5				OPCODE_V0S: equ 124 
23e5				OPCODE_V0Q: equ 125 
23e5				OPCODE_V1S: equ 126 
23e5				OPCODE_V1Q: equ 127 
23e5				OPCODE_V2S: equ 128 
23e5				OPCODE_V2Q: equ 129 
23e5				OPCODE_V3S: equ 130 
23e5				OPCODE_V3Q: equ 131 
23e5			;free to reuse	OPCODE_END: equ 132 
23e5				OPCODE_ZDUP: equ 133 
23e5			 
23e5			; eof 
# End of file forth_opcodes.asm
23e5			 
23e5			include "forth_words_core.asm" 
23e5			 
23e5			; | ## Core Words 
23e5			 
23e5			;if MALLOC_4 
23e5			 
23e5			.HEAP: 
23e5				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
23e5 15				db WORD_SYS_CORE+OPCODE_HEAP             
23e6 24 24			dw .EXEC            
23e8 05				db 4 + 1 
23e9 .. 00			db "HEAP",0              
23ee				endm 
# End of macro CWHEAD
23ee			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
23ee			; | | u1 - Current number of bytes in the heap 
23ee			; | | u2 - Remaining bytes left on the heap 
23ee			; | |  
23ee			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
23ee			 
23ee			 
23ee					if DEBUG_FORTH_WORDS_KEY 
23ee						DMARK "HEP" 
23ee f5				push af  
23ef 3a 03 24			ld a, (.dmark)  
23f2 32 6e fe			ld (debug_mark),a  
23f5 3a 04 24			ld a, (.dmark+1)  
23f8 32 6f fe			ld (debug_mark+1),a  
23fb 3a 05 24			ld a, (.dmark+2)  
23fe 32 70 fe			ld (debug_mark+2),a  
2401 18 03			jr .pastdmark  
2403 ..			.dmark: db "HEP"  
2406 f1			.pastdmark: pop af  
2407			endm  
# End of macro DMARK
2407						CALLMONITOR 
2407 cd ab 18			call break_point_state  
240a				endm  
# End of macro CALLMONITOR
240a					endif 
240a 2a 0a 80				ld hl, (free_list )      
240d 11 0e 80				ld de, heap_start 
2410			 
2410 ed 52				sbc hl, de  
2412			 
2412 cd 1f 1f				call forth_push_numhl 
2415			 
2415			 
2415 ed 5b 0a 80			ld de, (free_list )      
2419 21 e3 f1				ld hl, heap_end 
241c			 
241c ed 52				sbc hl, de 
241e			 
241e cd 1f 1f				call forth_push_numhl 
2421					 
2421			 
2421					 
2421			 
2421			 
2421			 
2421					NEXTW 
2421 c3 8d 22			jp macro_next 
2424				endm 
# End of macro NEXTW
2424			;endif 
2424			 
2424			.EXEC: 
2424			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
2424			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
2424			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
2424			;; > > 
2424			;; > >   
2424			;	STACKFRAME OFF $5efe $5f9f 
2424			; 
2424			;		if DEBUG_FORTH_WORDS_KEY 
2424			;			DMARK "EXE" 
2424			;			CALLMONITOR 
2424			;		endif 
2424			; 
2424			;	FORTH_DSP_VALUEHL 
2424			; 
2424			;	FORTH_DSP_POP 
2424			; 
2424			;		if DEBUG_FORTH_WORDS 
2424			;			DMARK "EX1" 
2424			;			CALLMONITOR 
2424			;		endif 
2424			;;	ld e,(hl) 
2424			;;	inc hl 
2424			;;	ld d,(hl) 
2424			;;	ex de,hl 
2424			; 
2424			;;		if DEBUG_FORTH_WORDS 
2424			;;			DMARK "EX2" 
2424			;;			CALLMONITOR 
2424			;;		endif 
2424			;	push hl 
2424			; 
2424			;	;ld a, 0 
2424			;	;ld a, FORTH_END_BUFFER 
2424			;	call strlenz 
2424			;	inc hl   ; include zero term to copy 
2424			;	inc hl   ; include term 
2424			;	inc hl   ; include term 
2424			;	ld b,0 
2424			;	ld c,l 
2424			;	pop hl 
2424			;	ld de, execscratch 
2424			;		if DEBUG_FORTH_WORDS 
2424			;			DMARK "EX3" 
2424			;			CALLMONITOR 
2424			;		endif 
2424			;	ldir 
2424			; 
2424			; 
2424			;	ld hl, execscratch 
2424			; 
2424			;		if DEBUG_FORTH_WORDS 
2424			;			DMARK "EXe" 
2424			;			CALLMONITOR 
2424			;		endif 
2424			; 
2424			;	call forthparse 
2424			;	call forthexec 
2424			;;	call forthexec_cleanup 
2424			;;	call forthparse 
2424			;;	call forthexec 
2424			; 
2424			;	STACKFRAMECHK OFF $5efe $5f9f 
2424			; 
2424			;	; an immediate word so no need to process any more words 
2424			;	ret 
2424			;	NEXTW 
2424			 
2424			; dead code - old version  
2424			;	FORTH_RSP_NEXT 
2424			 
2424			;  
2424			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
2424			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
2424			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2424			;	push hl 
2424			;	push de 
2424			;	push bc 
2424			; 
2424			; 
2424			;		if DEBUG_FORTH_WORDS_KEY 
2424			;			DMARK "EXR" 
2424			;			CALLMONITOR 
2424			;		endif 
2424			; 
2424			; 
2424			; 
2424			;	;v5 FORTH_DSP_VALUE 
2424			;	FORTH_DSP_VALUEHL 
2424			; 
2424			;	; TODO do string type checks 
2424			; 
2424			;;v5	inc hl   ; skip type 
2424			; 
2424			;	push hl  ; source code  
2424			;		if DEBUG_FORTH_WORDS 
2424			;			DMARK "EX1" 
2424			;			CALLMONITOR 
2424			;		endif 
2424			;	ld a, 0 
2424			;	call strlent 
2424			; 
2424			;	inc hl 
2424			;	inc hl 
2424			;	inc hl 
2424			;	inc hl 
2424			; 
2424			;	push hl    ; size 
2424			; 
2424			;		if DEBUG_FORTH_WORDS 
2424			;			DMARK "EX2" 
2424			;			CALLMONITOR 
2424			;		endif 
2424			;	call malloc 
2424			; 
2424			;	ex de, hl    ; de now contains malloc area 
2424			;	pop bc   	; get byte count 
2424			;	pop hl      ; get string to copy 
2424			; 
2424			;	push de     ; save malloc for free later 
2424			; 
2424			;		if DEBUG_FORTH_WORDS 
2424			;			DMARK "EX3" 
2424			;			CALLMONITOR 
2424			;		endif 
2424			;	ldir       ; duplicate string 
2424			; 
2424			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
2424			;	 
2424			;	; TODO fix the parse would be better than this...  
2424			;	ex de, hl 
2424			;	dec hl 
2424			;	ld a, 0 
2424			;	ld (hl), a 
2424			;	dec hl 
2424			;	ld a, ' ' 
2424			;	ld (hl), a 
2424			;	dec hl 
2424			;	ld (hl), a 
2424			; 
2424			;	dec hl 
2424			;	ld (hl), a 
2424			; 
2424			; 
2424			;	FORTH_DSP_POP  
2424			; 
2424			;	pop hl     
2424			;	push hl    ; save malloc area 
2424			; 
2424			;		if DEBUG_FORTH_WORDS 
2424			;			DMARK "EX4" 
2424			;			CALLMONITOR 
2424			;		endif 
2424			; 
2424			;	call forthparse 
2424			;	call forthexec 
2424			;	 
2424			;	pop hl 
2424			;	if DEBUG_FORTH_WORDS 
2424			;		DMARK "EX5" 
2424			;		CALLMONITOR 
2424			;	endif 
2424			; 
2424			;	if FORTH_ENABLE_FREE 
2424			;	call free 
2424			;	endif 
2424			; 
2424			;	if DEBUG_FORTH_WORDS 
2424			;		DMARK "EX6" 
2424			;		CALLMONITOR 
2424			;	endif 
2424			; 
2424			;	pop bc 
2424			;	pop de 
2424			;	pop hl 
2424			;;	FORTH_RSP_POP	  
2424			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
2424			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
2424			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
2424			; 
2424			;	if DEBUG_FORTH_WORDS 
2424			;		DMARK "EX7" 
2424			;		CALLMONITOR 
2424			;	endif 
2424			;	NEXTW 
2424			 
2424			;.STKEXEC: 
2424			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
2424			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
2424			; 
2424			; 
2424			;		if DEBUG_FORTH_WORDS_KEY 
2424			;			DMARK "STX" 
2424			;			CALLMONITOR 
2424			;		endif 
2424			; 
2424			;	FORTH_DSP_VALUEHL 
2424			; 
2424			;	ld (store_tmp1), hl    ; count 
2424			; 
2424			;	FORTH_DSP_POP 
2424			;.stkexec1: 
2424			;	ld hl, (store_tmp1)   ; count 
2424			;	ld a, 0 
2424			;	cp l 
2424			;	ret z 
2424			; 
2424			;	dec hl 
2424			;	ld (store_tmp1), hl    ; count 
2424			;	 
2424			;	FORTH_DSP_VALUEHL 
2424			;	push hl 
2424			;	 
2424			;		if DEBUG_FORTH_WORDS 
2424			;			DMARK "EXp" 
2424			;			CALLMONITOR 
2424			;		endif 
2424			;	FORTH_DSP_POP 
2424			; 
2424			;	call strlenz 
2424			;	inc hl   ; include zero term to copy 
2424			;	inc hl   ; include zero term to copy 
2424			;	inc hl   ; include zero term to copy 
2424			;	ld b,0 
2424			;	ld c,l 
2424			;	pop hl 
2424			;	ld de, execscratch 
2424			;		if DEBUG_FORTH_WORDS 
2424			;			DMARK "EX3" 
2424			;			CALLMONITOR 
2424			;		endif 
2424			;	ldir 
2424			; 
2424			; 
2424			;	ld hl, execscratch 
2424			; 
2424			;		if DEBUG_FORTH_WORDS 
2424			;			DMARK "EXP" 
2424			;			CALLMONITOR 
2424			;		endif 
2424			; 
2424			;	call forthparse 
2424			;	ld hl, execscratch 
2424			;		if DEBUG_FORTH_WORDS 
2424			;			DMARK "EXx" 
2424			;			CALLMONITOR 
2424			;		endif 
2424			;	call forthexec 
2424			; 
2424			;	jp .stkexec1 
2424			; 
2424			;	ret 
2424			 
2424			 
2424			.DUP: 
2424				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
2424 17				db WORD_SYS_CORE+OPCODE_DUP             
2425 9a 24			dw .ZDUP            
2427 04				db 3 + 1 
2428 .. 00			db "DUP",0              
242c				endm 
# End of macro CWHEAD
242c			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
242c			 
242c					if DEBUG_FORTH_WORDS_KEY 
242c						DMARK "DUP" 
242c f5				push af  
242d 3a 41 24			ld a, (.dmark)  
2430 32 6e fe			ld (debug_mark),a  
2433 3a 42 24			ld a, (.dmark+1)  
2436 32 6f fe			ld (debug_mark+1),a  
2439 3a 43 24			ld a, (.dmark+2)  
243c 32 70 fe			ld (debug_mark+2),a  
243f 18 03			jr .pastdmark  
2441 ..			.dmark: db "DUP"  
2444 f1			.pastdmark: pop af  
2445			endm  
# End of macro DMARK
2445						CALLMONITOR 
2445 cd ab 18			call break_point_state  
2448				endm  
# End of macro CALLMONITOR
2448					endif 
2448			 
2448					FORTH_DSP 
2448 cd dc 20			call macro_forth_dsp 
244b				endm 
# End of macro FORTH_DSP
244b			 
244b 7e					ld a, (HL) 
244c fe 01				cp DS_TYPE_STR 
244e 20 25				jr nz, .dupinum 
2450			 
2450					; push another string 
2450			 
2450					FORTH_DSP_VALUEHL     		 
2450 cd 16 21			call macro_dsp_valuehl 
2453				endm 
# End of macro FORTH_DSP_VALUEHL
2453			 
2453				if DEBUG_FORTH_WORDS 
2453					DMARK "DUs" 
2453 f5				push af  
2454 3a 68 24			ld a, (.dmark)  
2457 32 6e fe			ld (debug_mark),a  
245a 3a 69 24			ld a, (.dmark+1)  
245d 32 6f fe			ld (debug_mark+1),a  
2460 3a 6a 24			ld a, (.dmark+2)  
2463 32 70 fe			ld (debug_mark+2),a  
2466 18 03			jr .pastdmark  
2468 ..			.dmark: db "DUs"  
246b f1			.pastdmark: pop af  
246c			endm  
# End of macro DMARK
246c					CALLMONITOR 
246c cd ab 18			call break_point_state  
246f				endm  
# End of macro CALLMONITOR
246f				endif 
246f cd 8d 1f				call forth_push_str 
2472			 
2472					NEXTW 
2472 c3 8d 22			jp macro_next 
2475				endm 
# End of macro NEXTW
2475			 
2475			 
2475			.dupinum: 
2475					 
2475			 
2475			 
2475					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2475 cd 16 21			call macro_dsp_valuehl 
2478				endm 
# End of macro FORTH_DSP_VALUEHL
2478			 
2478				; TODO add floating point number detection 
2478			 
2478				if DEBUG_FORTH_WORDS 
2478					DMARK "DUi" 
2478 f5				push af  
2479 3a 8d 24			ld a, (.dmark)  
247c 32 6e fe			ld (debug_mark),a  
247f 3a 8e 24			ld a, (.dmark+1)  
2482 32 6f fe			ld (debug_mark+1),a  
2485 3a 8f 24			ld a, (.dmark+2)  
2488 32 70 fe			ld (debug_mark+2),a  
248b 18 03			jr .pastdmark  
248d ..			.dmark: db "DUi"  
2490 f1			.pastdmark: pop af  
2491			endm  
# End of macro DMARK
2491					CALLMONITOR 
2491 cd ab 18			call break_point_state  
2494				endm  
# End of macro CALLMONITOR
2494				endif 
2494			 
2494 cd 1f 1f				call forth_push_numhl 
2497					NEXTW 
2497 c3 8d 22			jp macro_next 
249a				endm 
# End of macro NEXTW
249a			.ZDUP: 
249a				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
249a 99				db WORD_SYS_CORE+OPCODE_ZDUP             
249b d2 24			dw .SWAP            
249d 05				db 4 + 1 
249e .. 00			db "?DUP",0              
24a3				endm 
# End of macro CWHEAD
24a3			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
24a3			 
24a3					if DEBUG_FORTH_WORDS_KEY 
24a3						DMARK "qDU" 
24a3 f5				push af  
24a4 3a b8 24			ld a, (.dmark)  
24a7 32 6e fe			ld (debug_mark),a  
24aa 3a b9 24			ld a, (.dmark+1)  
24ad 32 6f fe			ld (debug_mark+1),a  
24b0 3a ba 24			ld a, (.dmark+2)  
24b3 32 70 fe			ld (debug_mark+2),a  
24b6 18 03			jr .pastdmark  
24b8 ..			.dmark: db "qDU"  
24bb f1			.pastdmark: pop af  
24bc			endm  
# End of macro DMARK
24bc						CALLMONITOR 
24bc cd ab 18			call break_point_state  
24bf				endm  
# End of macro CALLMONITOR
24bf					endif 
24bf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
24bf cd 16 21			call macro_dsp_valuehl 
24c2				endm 
# End of macro FORTH_DSP_VALUEHL
24c2			 
24c2 e5					push hl 
24c3			 
24c3					; is it a zero? 
24c3			 
24c3 3e 00				ld a, 0 
24c5 84					add h 
24c6 85					add l 
24c7			 
24c7 e1					pop hl 
24c8			 
24c8 fe 00				cp 0 
24ca 28 03				jr z, .dup2orig 
24cc			 
24cc			 
24cc cd 1f 1f				call forth_push_numhl 
24cf			 
24cf			 
24cf				; TODO add floating point number detection 
24cf			 
24cf			.dup2orig: 
24cf			 
24cf					NEXTW 
24cf c3 8d 22			jp macro_next 
24d2				endm 
# End of macro NEXTW
24d2			.SWAP: 
24d2				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
24d2 18				db WORD_SYS_CORE+OPCODE_SWAP             
24d3 11 25			dw .COLN            
24d5 05				db 4 + 1 
24d6 .. 00			db "SWAP",0              
24db				endm 
# End of macro CWHEAD
24db			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
24db					if DEBUG_FORTH_WORDS_KEY 
24db						DMARK "SWP" 
24db f5				push af  
24dc 3a f0 24			ld a, (.dmark)  
24df 32 6e fe			ld (debug_mark),a  
24e2 3a f1 24			ld a, (.dmark+1)  
24e5 32 6f fe			ld (debug_mark+1),a  
24e8 3a f2 24			ld a, (.dmark+2)  
24eb 32 70 fe			ld (debug_mark+2),a  
24ee 18 03			jr .pastdmark  
24f0 ..			.dmark: db "SWP"  
24f3 f1			.pastdmark: pop af  
24f4			endm  
# End of macro DMARK
24f4						CALLMONITOR 
24f4 cd ab 18			call break_point_state  
24f7				endm  
# End of macro CALLMONITOR
24f7					endif 
24f7			 
24f7					FORTH_DSP_VALUEHL 
24f7 cd 16 21			call macro_dsp_valuehl 
24fa				endm 
# End of macro FORTH_DSP_VALUEHL
24fa e5					push hl     ; w2 
24fb			 
24fb					FORTH_DSP_POP 
24fb cd ce 21			call macro_forth_dsp_pop 
24fe				endm 
# End of macro FORTH_DSP_POP
24fe			 
24fe					FORTH_DSP_VALUEHL 
24fe cd 16 21			call macro_dsp_valuehl 
2501				endm 
# End of macro FORTH_DSP_VALUEHL
2501			 
2501					FORTH_DSP_POP 
2501 cd ce 21			call macro_forth_dsp_pop 
2504				endm 
# End of macro FORTH_DSP_POP
2504			 
2504 d1					pop de     ; w2	, hl = w1 
2505			 
2505 eb					ex de, hl 
2506 d5					push de 
2507			 
2507 cd 1f 1f				call forth_push_numhl 
250a			 
250a e1					pop hl 
250b			 
250b cd 1f 1f				call forth_push_numhl 
250e					 
250e			 
250e					NEXTW 
250e c3 8d 22			jp macro_next 
2511				endm 
# End of macro NEXTW
2511			.COLN: 
2511				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
2511 19				db WORD_SYS_CORE+OPCODE_COLN             
2512 9d 26			dw .SCOLN            
2514 02				db 1 + 1 
2515 .. 00			db ":",0              
2517				endm 
# End of macro CWHEAD
2517			; | : ( -- )         Create new word | DONE 
2517			 
2517					if DEBUG_FORTH_WORDS_KEY 
2517						DMARK "CLN" 
2517 f5				push af  
2518 3a 2c 25			ld a, (.dmark)  
251b 32 6e fe			ld (debug_mark),a  
251e 3a 2d 25			ld a, (.dmark+1)  
2521 32 6f fe			ld (debug_mark+1),a  
2524 3a 2e 25			ld a, (.dmark+2)  
2527 32 70 fe			ld (debug_mark+2),a  
252a 18 03			jr .pastdmark  
252c ..			.dmark: db "CLN"  
252f f1			.pastdmark: pop af  
2530			endm  
# End of macro DMARK
2530						CALLMONITOR 
2530 cd ab 18			call break_point_state  
2533				endm  
# End of macro CALLMONITOR
2533					endif 
2533				STACKFRAME OFF $8efe $989f 
2533				if DEBUG_STACK_IMB 
2533					if OFF 
2533						exx 
2533						ld de, $8efe 
2533						ld a, d 
2533						ld hl, curframe 
2533						call hexout 
2533						ld a, e 
2533						ld hl, curframe+2 
2533						call hexout 
2533						ld hl, $8efe 
2533						push hl 
2533						ld hl, $989f 
2533						push hl 
2533						exx 
2533					endif 
2533				endif 
2533			endm 
# End of macro STACKFRAME
2533				; get parser buffer length  of new word 
2533			 
2533				 
2533			 
2533					; move tok past this to start of name defintition 
2533					; TODO get word to define 
2533					; TODO Move past word token 
2533					; TODO get length of string up to the ';' 
2533			 
2533 2a fe f4			ld hl, (os_tok_ptr) 
2536 23				inc hl 
2537 23				inc hl 
2538			 
2538 3e 3b			ld a, ';' 
253a cd 6d 13			call strlent 
253d			 
253d 7d				ld a,l 
253e 32 f9 f1			ld (os_new_parse_len), a 
2541			 
2541			 
2541			if DEBUG_FORTH_UWORD 
2541 ed 5b fe f4		ld de, (os_tok_ptr) 
2545						DMARK ":01" 
2545 f5				push af  
2546 3a 5a 25			ld a, (.dmark)  
2549 32 6e fe			ld (debug_mark),a  
254c 3a 5b 25			ld a, (.dmark+1)  
254f 32 6f fe			ld (debug_mark+1),a  
2552 3a 5c 25			ld a, (.dmark+2)  
2555 32 70 fe			ld (debug_mark+2),a  
2558 18 03			jr .pastdmark  
255a ..			.dmark: db ":01"  
255d f1			.pastdmark: pop af  
255e			endm  
# End of macro DMARK
255e				CALLMONITOR 
255e cd ab 18			call break_point_state  
2561				endm  
# End of macro CALLMONITOR
2561			endif 
2561			 
2561			; 
2561			;  new word memory layout: 
2561			;  
2561			;    : adg 6666 ;  
2561			; 
2561			;    db   1     ; user defined word  
2561 23				inc hl    
2562			;    dw   sysdict 
2562 23				inc hl 
2563 23				inc hl 
2564			;    db <word len>+1 (for null) 
2564 23				inc hl 
2565			;    db .... <word> 
2565			; 
2565			 
2565 23				inc hl    ; some extras for the word preamble before the above 
2566 23				inc hl 
2567 23				inc hl 
2568 23				inc hl 
2569 23				inc hl 
256a 23				inc hl 
256b 23				inc hl  
256c 23				inc hl 
256d 23				inc hl 
256e 23				inc hl 
256f 23				inc hl 
2570 23				inc hl 
2571 23				inc hl 
2572 23				inc hl     ; TODO how many do we really need?     maybe only 6 
2573			;       exec word buffer 
2573			;	<ptr word>   
2573 23				inc hl 
2574 23				inc hl 
2575			;       <word list><null term> 7F final term 
2575			 
2575			 
2575			if DEBUG_FORTH_UWORD 
2575						DMARK ":02" 
2575 f5				push af  
2576 3a 8a 25			ld a, (.dmark)  
2579 32 6e fe			ld (debug_mark),a  
257c 3a 8b 25			ld a, (.dmark+1)  
257f 32 6f fe			ld (debug_mark+1),a  
2582 3a 8c 25			ld a, (.dmark+2)  
2585 32 70 fe			ld (debug_mark+2),a  
2588 18 03			jr .pastdmark  
258a ..			.dmark: db ":02"  
258d f1			.pastdmark: pop af  
258e			endm  
# End of macro DMARK
258e				CALLMONITOR 
258e cd ab 18			call break_point_state  
2591				endm  
# End of macro CALLMONITOR
2591			endif 
2591			 
2591				 
2591					; malloc the size 
2591			 
2591 cd cb 13				call malloc 
2594 22 fb f1				ld (os_new_malloc), hl     ; save malloc start 
2597			 
2597			;    db   1     ; user defined word  
2597 3e 01				ld a, WORD_SYS_UWORD  
2599 77					ld (hl), a 
259a				 
259a 23				inc hl    
259b			;    dw   sysdict 
259b 11 e5 23			ld de, sysdict       ; continue on with the scan to the system dict 
259e 73				ld (hl), e 
259f 23				inc hl 
25a0 72				ld (hl), d 
25a1 23				inc hl 
25a2			 
25a2			 
25a2			;    Setup dict word 
25a2			 
25a2 23				inc hl 
25a3 22 f5 f1			ld (os_new_work_ptr), hl     ; save start of dict word  
25a6			 
25a6				; 1. get length of dict word 
25a6			 
25a6			 
25a6 2a fe f4			ld hl, (os_tok_ptr) 
25a9 23				inc hl 
25aa 23				inc hl    ; position to start of dict word 
25ab 3e 00			ld a, 0 
25ad cd 6d 13			call strlent 
25b0			 
25b0			 
25b0 23				inc hl    ; to include null??? 
25b1			 
25b1				; write length of dict word 
25b1			 
25b1 ed 5b f5 f1		ld de, (os_new_work_ptr)   ; get dest for copy of word 
25b5 1b				dec de 
25b6 eb				ex de, hl 
25b7 73				ld (hl), e 
25b8 eb				ex de, hl 
25b9			 
25b9				 
25b9			 
25b9				; copy  
25b9 4d				ld c, l 
25ba 06 00			ld b, 0 
25bc ed 5b f5 f1		ld de, (os_new_work_ptr)   ; get dest for copy of word 
25c0 2a fe f4			ld hl, (os_tok_ptr) 
25c3 23				inc hl 
25c4 23				inc hl    ; position to start of dict word 
25c5				 
25c5			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
25c5				 
25c5				; TODO need to convert word to upper case 
25c5			 
25c5			ucasetok:	 
25c5 7e				ld a,(hl) 
25c6 cd 59 13			call toUpper 
25c9 77				ld (hl),a 
25ca ed a0			ldi 
25cc f2 c5 25		 	jp p, ucasetok 
25cf			 
25cf			 
25cf			 
25cf				; de now points to start of where the word body code should be placed 
25cf ed 53 f5 f1		ld (os_new_work_ptr), de 
25d3				; hl now points to the words to throw at forthexec which needs to be copied 
25d3 22 f3 f1			ld (os_new_src_ptr), hl 
25d6			 
25d6				; TODO add 'call to forthexec' 
25d6			 
25d6			if DEBUG_FORTH_UWORD 
25d6 c5				push bc 
25d7 ed 4b fb f1		ld bc, (os_new_malloc) 
25db						DMARK ":0x" 
25db f5				push af  
25dc 3a f0 25			ld a, (.dmark)  
25df 32 6e fe			ld (debug_mark),a  
25e2 3a f1 25			ld a, (.dmark+1)  
25e5 32 6f fe			ld (debug_mark+1),a  
25e8 3a f2 25			ld a, (.dmark+2)  
25eb 32 70 fe			ld (debug_mark+2),a  
25ee 18 03			jr .pastdmark  
25f0 ..			.dmark: db ":0x"  
25f3 f1			.pastdmark: pop af  
25f4			endm  
# End of macro DMARK
25f4				CALLMONITOR 
25f4 cd ab 18			call break_point_state  
25f7				endm  
# End of macro CALLMONITOR
25f7 c1				pop bc 
25f8			endif 
25f8			 
25f8			 
25f8				; create word preamble which should be: 
25f8			 
25f8			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
25f8			 
25f8				;    ld hl, <word code> 
25f8				;    jp user_exec 
25f8			        ;    <word code bytes> 
25f8			 
25f8			 
25f8			;	inc de     ; TODO ??? or are we already past the word's null 
25f8 eb				ex de, hl 
25f9			 
25f9 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
25fb			 
25fb 23				inc hl 
25fc 22 ef f1			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
25ff 23				inc hl 
2600			 
2600 23				inc hl 
2601 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
2603			 
2603 01 cc 54			ld bc, user_exec 
2606 23				inc hl 
2607 71				ld (hl), c     ; poke address of user_exec 
2608 23				inc hl 
2609 70				ld (hl), b     
260a			 ; 
260a			;	inc hl 
260a			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
260a			; 
260a			; 
260a			;	ld bc, macro_forth_rsp_next 
260a			;	inc hl 
260a			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
260a			;	inc hl 
260a			;	ld (hl), b     
260a			 ; 
260a			;	inc hl 
260a			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
260a			; 
260a			; 
260a			;	inc hl 
260a			;	ld bc, forthexec 
260a			;	ld (hl), c     ; poke address of forthexec 
260a			;	inc hl 
260a			;	ld (hl), b      
260a			; 
260a			;	inc hl 
260a			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
260a			; 
260a			;	ld bc, user_dict_next 
260a			;	inc hl 
260a			;	ld (hl), c     ; poke address of forthexec 
260a			;	inc hl 
260a			;	ld (hl), b      
260a			 
260a				; hl is now where we need to copy the word byte data to save this 
260a			 
260a 23				inc hl 
260b 22 f1 f1			ld (os_new_exec), hl 
260e				 
260e				; copy definition 
260e			 
260e eb				ex de, hl 
260f			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
260f			;	inc de    ; skip the PC for this parse 
260f 3a f9 f1			ld a, (os_new_parse_len) 
2612 4f				ld c, a 
2613 06 00			ld b, 0 
2615 ed b0			ldir		 ; copy defintion 
2617			 
2617			 
2617				; poke the address of where the new word bytes live for forthexec 
2617			 
2617 2a ef f1			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
261a			 
261a ed 5b f1 f1		ld de, (os_new_exec)      
261e				 
261e 73				ld (hl), e 
261f 23				inc hl 
2620 72				ld (hl), d 
2621			 
2621					; TODO copy last user dict word next link to this word 
2621					; TODO update last user dict word to point to this word 
2621			; 
2621			; hl f923 de 812a ; bc 811a 
2621			 
2621			if DEBUG_FORTH_UWORD 
2621 c5				push bc 
2622 ed 4b fb f1		ld bc, (os_new_malloc) 
2626						DMARK ":0A" 
2626 f5				push af  
2627 3a 3b 26			ld a, (.dmark)  
262a 32 6e fe			ld (debug_mark),a  
262d 3a 3c 26			ld a, (.dmark+1)  
2630 32 6f fe			ld (debug_mark+1),a  
2633 3a 3d 26			ld a, (.dmark+2)  
2636 32 70 fe			ld (debug_mark+2),a  
2639 18 03			jr .pastdmark  
263b ..			.dmark: db ":0A"  
263e f1			.pastdmark: pop af  
263f			endm  
# End of macro DMARK
263f				CALLMONITOR 
263f cd ab 18			call break_point_state  
2642				endm  
# End of macro CALLMONITOR
2642 c1				pop bc 
2643			endif 
2643			if DEBUG_FORTH_UWORD 
2643 c5				push bc 
2644 ed 4b fb f1		ld bc, (os_new_malloc) 
2648 03				inc bc 
2649 03				inc bc 
264a 03				inc bc 
264b 03				inc bc 
264c 03				inc bc 
264d 03				inc bc 
264e 03				inc bc 
264f 03				inc bc 
2650			 
2650						DMARK ":0B" 
2650 f5				push af  
2651 3a 65 26			ld a, (.dmark)  
2654 32 6e fe			ld (debug_mark),a  
2657 3a 66 26			ld a, (.dmark+1)  
265a 32 6f fe			ld (debug_mark+1),a  
265d 3a 67 26			ld a, (.dmark+2)  
2660 32 70 fe			ld (debug_mark+2),a  
2663 18 03			jr .pastdmark  
2665 ..			.dmark: db ":0B"  
2668 f1			.pastdmark: pop af  
2669			endm  
# End of macro DMARK
2669				CALLMONITOR 
2669 cd ab 18			call break_point_state  
266c				endm  
# End of macro CALLMONITOR
266c c1				pop bc 
266d			endif 
266d			 
266d			; update word dict linked list for new word 
266d			 
266d			 
266d 2a fa f4		ld hl, (os_last_new_uword)		; get the start of the last added uword 
2670 23			inc hl     ; move to next work linked list ptr 
2671			 
2671 ed 5b fb f1	ld de, (os_new_malloc)		 ; new next word 
2675 73			ld (hl), e 
2676 23			inc hl 
2677 72			ld (hl), d 
2678			 
2678			if DEBUG_FORTH_UWORD 
2678 ed 4b fa f4		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
267c			endif 
267c			 
267c ed 53 fa f4	ld (os_last_new_uword), de      ; update last new uword ptr 
2680			 
2680			 
2680			if DEBUG_FORTH_UWORD 
2680						DMARK ":0+" 
2680 f5				push af  
2681 3a 95 26			ld a, (.dmark)  
2684 32 6e fe			ld (debug_mark),a  
2687 3a 96 26			ld a, (.dmark+1)  
268a 32 6f fe			ld (debug_mark+1),a  
268d 3a 97 26			ld a, (.dmark+2)  
2690 32 70 fe			ld (debug_mark+2),a  
2693 18 03			jr .pastdmark  
2695 ..			.dmark: db ":0+"  
2698 f1			.pastdmark: pop af  
2699			endm  
# End of macro DMARK
2699				CALLMONITOR 
2699 cd ab 18			call break_point_state  
269c				endm  
# End of macro CALLMONITOR
269c			endif 
269c			 
269c				STACKFRAMECHK OFF $8efe $989f 
269c				if DEBUG_STACK_IMB 
269c					if OFF 
269c						exx 
269c						ld hl, $989f 
269c						pop de   ; $989f 
269c						call cmp16 
269c						jr nz, .spnosame 
269c						ld hl, $8efe 
269c						pop de   ; $8efe 
269c						call cmp16 
269c						jr z, .spfrsame 
269c						.spnosame: call showsperror 
269c						.spfrsame: nop 
269c						exx 
269c					endif 
269c				endif 
269c			endm 
# End of macro STACKFRAMECHK
269c			 
269c c9			ret    ; dont process any remaining parser tokens as they form new word 
269d			 
269d			 
269d			 
269d			 
269d			;		NEXT 
269d			.SCOLN: 
269d			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
269d 06				db OPCODE_SCOLN 
269e e9 26			dw .DROP 
26a0 02				db 2 
26a1 .. 00			db ";",0           
26a3			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
26a3					if DEBUG_FORTH_WORDS_KEY 
26a3						DMARK "SCN" 
26a3 f5				push af  
26a4 3a b8 26			ld a, (.dmark)  
26a7 32 6e fe			ld (debug_mark),a  
26aa 3a b9 26			ld a, (.dmark+1)  
26ad 32 6f fe			ld (debug_mark+1),a  
26b0 3a ba 26			ld a, (.dmark+2)  
26b3 32 70 fe			ld (debug_mark+2),a  
26b6 18 03			jr .pastdmark  
26b8 ..			.dmark: db "SCN"  
26bb f1			.pastdmark: pop af  
26bc			endm  
# End of macro DMARK
26bc						CALLMONITOR 
26bc cd ab 18			call break_point_state  
26bf				endm  
# End of macro CALLMONITOR
26bf					endif 
26bf					FORTH_RSP_TOS 
26bf cd dd 1e			call macro_forth_rsp_tos 
26c2				endm 
# End of macro FORTH_RSP_TOS
26c2 e5					push hl 
26c3					FORTH_RSP_POP 
26c3 cd e7 1e			call macro_forth_rsp_pop 
26c6				endm 
# End of macro FORTH_RSP_POP
26c6 e1					pop hl 
26c7			;		ex de,hl 
26c7 22 fe f4				ld (os_tok_ptr),hl 
26ca			 
26ca			if DEBUG_FORTH_UWORD 
26ca						DMARK "SCL" 
26ca f5				push af  
26cb 3a df 26			ld a, (.dmark)  
26ce 32 6e fe			ld (debug_mark),a  
26d1 3a e0 26			ld a, (.dmark+1)  
26d4 32 6f fe			ld (debug_mark+1),a  
26d7 3a e1 26			ld a, (.dmark+2)  
26da 32 70 fe			ld (debug_mark+2),a  
26dd 18 03			jr .pastdmark  
26df ..			.dmark: db "SCL"  
26e2 f1			.pastdmark: pop af  
26e3			endm  
# End of macro DMARK
26e3				CALLMONITOR 
26e3 cd ab 18			call break_point_state  
26e6				endm  
# End of macro CALLMONITOR
26e6			endif 
26e6					NEXTW 
26e6 c3 8d 22			jp macro_next 
26e9				endm 
# End of macro NEXTW
26e9			 
26e9			.DROP: 
26e9				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
26e9 1b				db WORD_SYS_CORE+OPCODE_DROP             
26ea 14 27			dw .DUP2            
26ec 05				db 4 + 1 
26ed .. 00			db "DROP",0              
26f2				endm 
# End of macro CWHEAD
26f2			; | DROP ( w -- )   drop the TOS item   | DONE 
26f2					if DEBUG_FORTH_WORDS_KEY 
26f2						DMARK "DRP" 
26f2 f5				push af  
26f3 3a 07 27			ld a, (.dmark)  
26f6 32 6e fe			ld (debug_mark),a  
26f9 3a 08 27			ld a, (.dmark+1)  
26fc 32 6f fe			ld (debug_mark+1),a  
26ff 3a 09 27			ld a, (.dmark+2)  
2702 32 70 fe			ld (debug_mark+2),a  
2705 18 03			jr .pastdmark  
2707 ..			.dmark: db "DRP"  
270a f1			.pastdmark: pop af  
270b			endm  
# End of macro DMARK
270b						CALLMONITOR 
270b cd ab 18			call break_point_state  
270e				endm  
# End of macro CALLMONITOR
270e					endif 
270e					FORTH_DSP_POP 
270e cd ce 21			call macro_forth_dsp_pop 
2711				endm 
# End of macro FORTH_DSP_POP
2711					NEXTW 
2711 c3 8d 22			jp macro_next 
2714				endm 
# End of macro NEXTW
2714			.DUP2: 
2714				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
2714 1c				db WORD_SYS_CORE+OPCODE_DUP2             
2715 59 27			dw .DROP2            
2717 05				db 4 + 1 
2718 .. 00			db "2DUP",0              
271d				endm 
# End of macro CWHEAD
271d			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
271d					if DEBUG_FORTH_WORDS_KEY 
271d						DMARK "2DU" 
271d f5				push af  
271e 3a 32 27			ld a, (.dmark)  
2721 32 6e fe			ld (debug_mark),a  
2724 3a 33 27			ld a, (.dmark+1)  
2727 32 6f fe			ld (debug_mark+1),a  
272a 3a 34 27			ld a, (.dmark+2)  
272d 32 70 fe			ld (debug_mark+2),a  
2730 18 03			jr .pastdmark  
2732 ..			.dmark: db "2DU"  
2735 f1			.pastdmark: pop af  
2736			endm  
# End of macro DMARK
2736						CALLMONITOR 
2736 cd ab 18			call break_point_state  
2739				endm  
# End of macro CALLMONITOR
2739					endif 
2739					FORTH_DSP_VALUEHL 
2739 cd 16 21			call macro_dsp_valuehl 
273c				endm 
# End of macro FORTH_DSP_VALUEHL
273c e5					push hl      ; 2 
273d			 
273d					FORTH_DSP_POP 
273d cd ce 21			call macro_forth_dsp_pop 
2740				endm 
# End of macro FORTH_DSP_POP
2740					 
2740					FORTH_DSP_VALUEHL 
2740 cd 16 21			call macro_dsp_valuehl 
2743				endm 
# End of macro FORTH_DSP_VALUEHL
2743			;		push hl      ; 1 
2743			 
2743					FORTH_DSP_POP 
2743 cd ce 21			call macro_forth_dsp_pop 
2746				endm 
# End of macro FORTH_DSP_POP
2746			 
2746			;		pop hl       ; 1 
2746 d1					pop de       ; 2 
2747			 
2747 cd 1f 1f				call forth_push_numhl 
274a eb					ex de, hl 
274b cd 1f 1f				call forth_push_numhl 
274e			 
274e					 
274e eb					ex de, hl 
274f			 
274f cd 1f 1f				call forth_push_numhl 
2752 eb					ex de, hl 
2753 cd 1f 1f				call forth_push_numhl 
2756			 
2756			 
2756					NEXTW 
2756 c3 8d 22			jp macro_next 
2759				endm 
# End of macro NEXTW
2759			.DROP2: 
2759				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
2759 1d				db WORD_SYS_CORE+OPCODE_DROP2             
275a 88 27			dw .SWAP2            
275c 06				db 5 + 1 
275d .. 00			db "2DROP",0              
2763				endm 
# End of macro CWHEAD
2763			; | 2DROP ( w w -- )    Double drop | DONE 
2763					if DEBUG_FORTH_WORDS_KEY 
2763						DMARK "2DR" 
2763 f5				push af  
2764 3a 78 27			ld a, (.dmark)  
2767 32 6e fe			ld (debug_mark),a  
276a 3a 79 27			ld a, (.dmark+1)  
276d 32 6f fe			ld (debug_mark+1),a  
2770 3a 7a 27			ld a, (.dmark+2)  
2773 32 70 fe			ld (debug_mark+2),a  
2776 18 03			jr .pastdmark  
2778 ..			.dmark: db "2DR"  
277b f1			.pastdmark: pop af  
277c			endm  
# End of macro DMARK
277c						CALLMONITOR 
277c cd ab 18			call break_point_state  
277f				endm  
# End of macro CALLMONITOR
277f					endif 
277f					FORTH_DSP_POP 
277f cd ce 21			call macro_forth_dsp_pop 
2782				endm 
# End of macro FORTH_DSP_POP
2782					FORTH_DSP_POP 
2782 cd ce 21			call macro_forth_dsp_pop 
2785				endm 
# End of macro FORTH_DSP_POP
2785					NEXTW 
2785 c3 8d 22			jp macro_next 
2788				endm 
# End of macro NEXTW
2788			.SWAP2: 
2788				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
2788 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
2789 b1 27			dw .AT            
278b 06				db 5 + 1 
278c .. 00			db "2SWAP",0              
2792				endm 
# End of macro CWHEAD
2792			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
2792					if DEBUG_FORTH_WORDS_KEY 
2792						DMARK "2SW" 
2792 f5				push af  
2793 3a a7 27			ld a, (.dmark)  
2796 32 6e fe			ld (debug_mark),a  
2799 3a a8 27			ld a, (.dmark+1)  
279c 32 6f fe			ld (debug_mark+1),a  
279f 3a a9 27			ld a, (.dmark+2)  
27a2 32 70 fe			ld (debug_mark+2),a  
27a5 18 03			jr .pastdmark  
27a7 ..			.dmark: db "2SW"  
27aa f1			.pastdmark: pop af  
27ab			endm  
# End of macro DMARK
27ab						CALLMONITOR 
27ab cd ab 18			call break_point_state  
27ae				endm  
# End of macro CALLMONITOR
27ae					endif 
27ae					NEXTW 
27ae c3 8d 22			jp macro_next 
27b1				endm 
# End of macro NEXTW
27b1			.AT: 
27b1				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
27b1 1f				db WORD_SYS_CORE+OPCODE_AT             
27b2 e3 27			dw .CAT            
27b4 02				db 1 + 1 
27b5 .. 00			db "@",0              
27b7				endm 
# End of macro CWHEAD
27b7			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
27b7			 
27b7					if DEBUG_FORTH_WORDS_KEY 
27b7						DMARK "AT." 
27b7 f5				push af  
27b8 3a cc 27			ld a, (.dmark)  
27bb 32 6e fe			ld (debug_mark),a  
27be 3a cd 27			ld a, (.dmark+1)  
27c1 32 6f fe			ld (debug_mark+1),a  
27c4 3a ce 27			ld a, (.dmark+2)  
27c7 32 70 fe			ld (debug_mark+2),a  
27ca 18 03			jr .pastdmark  
27cc ..			.dmark: db "AT."  
27cf f1			.pastdmark: pop af  
27d0			endm  
# End of macro DMARK
27d0						CALLMONITOR 
27d0 cd ab 18			call break_point_state  
27d3				endm  
# End of macro CALLMONITOR
27d3					endif 
27d3			.getbyteat:	 
27d3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
27d3 cd 16 21			call macro_dsp_valuehl 
27d6				endm 
# End of macro FORTH_DSP_VALUEHL
27d6					 
27d6			;		push hl 
27d6				 
27d6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
27d6 cd ce 21			call macro_forth_dsp_pop 
27d9				endm 
# End of macro FORTH_DSP_POP
27d9			 
27d9			;		pop hl 
27d9			 
27d9 7e					ld a, (hl) 
27da			 
27da 6f					ld l, a 
27db 26 00				ld h, 0 
27dd cd 1f 1f				call forth_push_numhl 
27e0			 
27e0					NEXTW 
27e0 c3 8d 22			jp macro_next 
27e3				endm 
# End of macro NEXTW
27e3			.CAT: 
27e3				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
27e3 20				db WORD_SYS_CORE+OPCODE_CAT             
27e4 0c 28			dw .BANG            
27e6 03				db 2 + 1 
27e7 .. 00			db "C@",0              
27ea				endm 
# End of macro CWHEAD
27ea			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
27ea					if DEBUG_FORTH_WORDS_KEY 
27ea						DMARK "CAA" 
27ea f5				push af  
27eb 3a ff 27			ld a, (.dmark)  
27ee 32 6e fe			ld (debug_mark),a  
27f1 3a 00 28			ld a, (.dmark+1)  
27f4 32 6f fe			ld (debug_mark+1),a  
27f7 3a 01 28			ld a, (.dmark+2)  
27fa 32 70 fe			ld (debug_mark+2),a  
27fd 18 03			jr .pastdmark  
27ff ..			.dmark: db "CAA"  
2802 f1			.pastdmark: pop af  
2803			endm  
# End of macro DMARK
2803						CALLMONITOR 
2803 cd ab 18			call break_point_state  
2806				endm  
# End of macro CALLMONITOR
2806					endif 
2806 c3 d3 27				jp .getbyteat 
2809					NEXTW 
2809 c3 8d 22			jp macro_next 
280c				endm 
# End of macro NEXTW
280c			.BANG: 
280c				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
280c 21				db WORD_SYS_CORE+OPCODE_BANG             
280d 42 28			dw .CBANG            
280f 02				db 1 + 1 
2810 .. 00			db "!",0              
2812				endm 
# End of macro CWHEAD
2812			; | ! ( x w -- ) Store x at address w      | DONE 
2812					if DEBUG_FORTH_WORDS_KEY 
2812						DMARK "BNG" 
2812 f5				push af  
2813 3a 27 28			ld a, (.dmark)  
2816 32 6e fe			ld (debug_mark),a  
2819 3a 28 28			ld a, (.dmark+1)  
281c 32 6f fe			ld (debug_mark+1),a  
281f 3a 29 28			ld a, (.dmark+2)  
2822 32 70 fe			ld (debug_mark+2),a  
2825 18 03			jr .pastdmark  
2827 ..			.dmark: db "BNG"  
282a f1			.pastdmark: pop af  
282b			endm  
# End of macro DMARK
282b						CALLMONITOR 
282b cd ab 18			call break_point_state  
282e				endm  
# End of macro CALLMONITOR
282e					endif 
282e			 
282e			.storebyteat:		 
282e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
282e cd 16 21			call macro_dsp_valuehl 
2831				endm 
# End of macro FORTH_DSP_VALUEHL
2831					 
2831 e5					push hl 
2832				 
2832					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2832 cd ce 21			call macro_forth_dsp_pop 
2835				endm 
# End of macro FORTH_DSP_POP
2835			 
2835					; get byte to poke 
2835			 
2835					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2835 cd 16 21			call macro_dsp_valuehl 
2838				endm 
# End of macro FORTH_DSP_VALUEHL
2838 e5					push hl 
2839			 
2839			 
2839					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2839 cd ce 21			call macro_forth_dsp_pop 
283c				endm 
# End of macro FORTH_DSP_POP
283c			 
283c			 
283c d1					pop de 
283d e1					pop hl 
283e			 
283e 73					ld (hl),e 
283f			 
283f			 
283f					NEXTW 
283f c3 8d 22			jp macro_next 
2842				endm 
# End of macro NEXTW
2842			.CBANG: 
2842				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
2842 22				db WORD_SYS_CORE+OPCODE_CBANG             
2843 6b 28			dw .SCALL            
2845 03				db 2 + 1 
2846 .. 00			db "C!",0              
2849				endm 
# End of macro CWHEAD
2849			; | C!  ( x w -- ) Store x at address w  | DONE 
2849					if DEBUG_FORTH_WORDS_KEY 
2849						DMARK "CBA" 
2849 f5				push af  
284a 3a 5e 28			ld a, (.dmark)  
284d 32 6e fe			ld (debug_mark),a  
2850 3a 5f 28			ld a, (.dmark+1)  
2853 32 6f fe			ld (debug_mark+1),a  
2856 3a 60 28			ld a, (.dmark+2)  
2859 32 70 fe			ld (debug_mark+2),a  
285c 18 03			jr .pastdmark  
285e ..			.dmark: db "CBA"  
2861 f1			.pastdmark: pop af  
2862			endm  
# End of macro DMARK
2862						CALLMONITOR 
2862 cd ab 18			call break_point_state  
2865				endm  
# End of macro CALLMONITOR
2865					endif 
2865 c3 2e 28				jp .storebyteat 
2868					NEXTW 
2868 c3 8d 22			jp macro_next 
286b				endm 
# End of macro NEXTW
286b			.SCALL: 
286b				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
286b 23				db WORD_SYS_CORE+OPCODE_SCALL             
286c 9f 28			dw .DEPTH            
286e 05				db 4 + 1 
286f .. 00			db "CALL",0              
2874				endm 
# End of macro CWHEAD
2874			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
2874					if DEBUG_FORTH_WORDS_KEY 
2874						DMARK "CLL" 
2874 f5				push af  
2875 3a 89 28			ld a, (.dmark)  
2878 32 6e fe			ld (debug_mark),a  
287b 3a 8a 28			ld a, (.dmark+1)  
287e 32 6f fe			ld (debug_mark+1),a  
2881 3a 8b 28			ld a, (.dmark+2)  
2884 32 70 fe			ld (debug_mark+2),a  
2887 18 03			jr .pastdmark  
2889 ..			.dmark: db "CLL"  
288c f1			.pastdmark: pop af  
288d			endm  
# End of macro DMARK
288d						CALLMONITOR 
288d cd ab 18			call break_point_state  
2890				endm  
# End of macro CALLMONITOR
2890					endif 
2890			 
2890					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2890 cd 16 21			call macro_dsp_valuehl 
2893				endm 
# End of macro FORTH_DSP_VALUEHL
2893			 
2893			;		push hl 
2893			 
2893					; destroy value TOS 
2893			 
2893					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2893 cd ce 21			call macro_forth_dsp_pop 
2896				endm 
# End of macro FORTH_DSP_POP
2896			 
2896						 
2896			;		pop hl 
2896			 
2896					; how to do a call with hl???? save SP? 
2896 cd 31 22				call forth_call_hl 
2899			 
2899			 
2899					; TODO push value back onto stack for another op etc 
2899			 
2899 cd 1f 1f				call forth_push_numhl 
289c					NEXTW 
289c c3 8d 22			jp macro_next 
289f				endm 
# End of macro NEXTW
289f			.DEPTH: 
289f				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
289f 24				db WORD_SYS_CORE+OPCODE_DEPTH             
28a0 dc 28			dw .OVER            
28a2 06				db 5 + 1 
28a3 .. 00			db "DEPTH",0              
28a9				endm 
# End of macro CWHEAD
28a9			; | DEPTH ( -- u ) Push count of stack | DONE 
28a9					; take current TOS and remove from base value div by two to get count 
28a9					if DEBUG_FORTH_WORDS_KEY 
28a9						DMARK "DEP" 
28a9 f5				push af  
28aa 3a be 28			ld a, (.dmark)  
28ad 32 6e fe			ld (debug_mark),a  
28b0 3a bf 28			ld a, (.dmark+1)  
28b3 32 6f fe			ld (debug_mark+1),a  
28b6 3a c0 28			ld a, (.dmark+2)  
28b9 32 70 fe			ld (debug_mark+2),a  
28bc 18 03			jr .pastdmark  
28be ..			.dmark: db "DEP"  
28c1 f1			.pastdmark: pop af  
28c2			endm  
# End of macro DMARK
28c2						CALLMONITOR 
28c2 cd ab 18			call break_point_state  
28c5				endm  
# End of macro CALLMONITOR
28c5					endif 
28c5			 
28c5			 
28c5 2a 2a fa			ld hl, (cli_data_sp) 
28c8 11 64 f7			ld de, cli_data_stack 
28cb ed 52			sbc hl,de 
28cd				 
28cd				; div by size of stack item 
28cd			 
28cd 5d				ld e,l 
28ce 0e 03			ld c, 3 
28d0 cd 94 0e			call Div8 
28d3			 
28d3 6f				ld l,a 
28d4 26 00			ld h,0 
28d6			 
28d6				;srl h 
28d6				;rr l 
28d6			 
28d6 cd 1f 1f				call forth_push_numhl 
28d9					NEXTW 
28d9 c3 8d 22			jp macro_next 
28dc				endm 
# End of macro NEXTW
28dc			.OVER: 
28dc				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
28dc 42				db WORD_SYS_CORE+46             
28dd 23 29			dw .PAUSE            
28df 05				db 4 + 1 
28e0 .. 00			db "OVER",0              
28e5				endm 
# End of macro CWHEAD
28e5			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
28e5					if DEBUG_FORTH_WORDS_KEY 
28e5						DMARK "OVR" 
28e5 f5				push af  
28e6 3a fa 28			ld a, (.dmark)  
28e9 32 6e fe			ld (debug_mark),a  
28ec 3a fb 28			ld a, (.dmark+1)  
28ef 32 6f fe			ld (debug_mark+1),a  
28f2 3a fc 28			ld a, (.dmark+2)  
28f5 32 70 fe			ld (debug_mark+2),a  
28f8 18 03			jr .pastdmark  
28fa ..			.dmark: db "OVR"  
28fd f1			.pastdmark: pop af  
28fe			endm  
# End of macro DMARK
28fe						CALLMONITOR 
28fe cd ab 18			call break_point_state  
2901				endm  
# End of macro CALLMONITOR
2901					endif 
2901			 
2901					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2901 cd 16 21			call macro_dsp_valuehl 
2904				endm 
# End of macro FORTH_DSP_VALUEHL
2904 e5					push hl    ; n2 
2905					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2905 cd ce 21			call macro_forth_dsp_pop 
2908				endm 
# End of macro FORTH_DSP_POP
2908			 
2908					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2908 cd 16 21			call macro_dsp_valuehl 
290b				endm 
# End of macro FORTH_DSP_VALUEHL
290b e5					push hl    ; n1 
290c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
290c cd ce 21			call macro_forth_dsp_pop 
290f				endm 
# End of macro FORTH_DSP_POP
290f			 
290f d1					pop de     ; n1 
2910 e1					pop hl     ; n2 
2911			 
2911 d5					push de 
2912 e5					push hl 
2913 d5					push de 
2914			 
2914					; push back  
2914			 
2914 e1					pop hl 
2915 cd 1f 1f				call forth_push_numhl 
2918 e1					pop hl 
2919 cd 1f 1f				call forth_push_numhl 
291c e1					pop hl 
291d cd 1f 1f				call forth_push_numhl 
2920					NEXTW 
2920 c3 8d 22			jp macro_next 
2923				endm 
# End of macro NEXTW
2923			 
2923			.PAUSE: 
2923				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2923 43				db WORD_SYS_CORE+47             
2924 58 29			dw .PAUSES            
2926 08				db 7 + 1 
2927 .. 00			db "PAUSEMS",0              
292f				endm 
# End of macro CWHEAD
292f			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
292f					if DEBUG_FORTH_WORDS_KEY 
292f						DMARK "PMS" 
292f f5				push af  
2930 3a 44 29			ld a, (.dmark)  
2933 32 6e fe			ld (debug_mark),a  
2936 3a 45 29			ld a, (.dmark+1)  
2939 32 6f fe			ld (debug_mark+1),a  
293c 3a 46 29			ld a, (.dmark+2)  
293f 32 70 fe			ld (debug_mark+2),a  
2942 18 03			jr .pastdmark  
2944 ..			.dmark: db "PMS"  
2947 f1			.pastdmark: pop af  
2948			endm  
# End of macro DMARK
2948						CALLMONITOR 
2948 cd ab 18			call break_point_state  
294b				endm  
# End of macro CALLMONITOR
294b					endif 
294b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
294b cd 16 21			call macro_dsp_valuehl 
294e				endm 
# End of macro FORTH_DSP_VALUEHL
294e			;		push hl    ; n2 
294e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
294e cd ce 21			call macro_forth_dsp_pop 
2951				endm 
# End of macro FORTH_DSP_POP
2951			;		pop hl 
2951			 
2951 7d					ld a, l 
2952 cd 32 0c				call aDelayInMS 
2955				       NEXTW 
2955 c3 8d 22			jp macro_next 
2958				endm 
# End of macro NEXTW
2958			.PAUSES:  
2958				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
2958 44				db WORD_SYS_CORE+48             
2959 c7 29			dw .ROT            
295b 06				db 5 + 1 
295c .. 00			db "PAUSE",0              
2962				endm 
# End of macro CWHEAD
2962			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2962					if DEBUG_FORTH_WORDS_KEY 
2962						DMARK "PAU" 
2962 f5				push af  
2963 3a 77 29			ld a, (.dmark)  
2966 32 6e fe			ld (debug_mark),a  
2969 3a 78 29			ld a, (.dmark+1)  
296c 32 6f fe			ld (debug_mark+1),a  
296f 3a 79 29			ld a, (.dmark+2)  
2972 32 70 fe			ld (debug_mark+2),a  
2975 18 03			jr .pastdmark  
2977 ..			.dmark: db "PAU"  
297a f1			.pastdmark: pop af  
297b			endm  
# End of macro DMARK
297b						CALLMONITOR 
297b cd ab 18			call break_point_state  
297e				endm  
# End of macro CALLMONITOR
297e					endif 
297e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
297e cd 16 21			call macro_dsp_valuehl 
2981				endm 
# End of macro FORTH_DSP_VALUEHL
2981			;		push hl    ; n2 
2981					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2981 cd ce 21			call macro_forth_dsp_pop 
2984				endm 
# End of macro FORTH_DSP_POP
2984			;		pop hl 
2984 45					ld b, l 
2985					if DEBUG_FORTH_WORDS 
2985						DMARK "PAU" 
2985 f5				push af  
2986 3a 9a 29			ld a, (.dmark)  
2989 32 6e fe			ld (debug_mark),a  
298c 3a 9b 29			ld a, (.dmark+1)  
298f 32 6f fe			ld (debug_mark+1),a  
2992 3a 9c 29			ld a, (.dmark+2)  
2995 32 70 fe			ld (debug_mark+2),a  
2998 18 03			jr .pastdmark  
299a ..			.dmark: db "PAU"  
299d f1			.pastdmark: pop af  
299e			endm  
# End of macro DMARK
299e						CALLMONITOR 
299e cd ab 18			call break_point_state  
29a1				endm  
# End of macro CALLMONITOR
29a1					endif 
29a1 c5			.pauses1:	push bc 
29a2 cd 4d 0c				call delay1s 
29a5 c1					pop bc 
29a6					if DEBUG_FORTH_WORDS 
29a6						DMARK "PA1" 
29a6 f5				push af  
29a7 3a bb 29			ld a, (.dmark)  
29aa 32 6e fe			ld (debug_mark),a  
29ad 3a bc 29			ld a, (.dmark+1)  
29b0 32 6f fe			ld (debug_mark+1),a  
29b3 3a bd 29			ld a, (.dmark+2)  
29b6 32 70 fe			ld (debug_mark+2),a  
29b9 18 03			jr .pastdmark  
29bb ..			.dmark: db "PA1"  
29be f1			.pastdmark: pop af  
29bf			endm  
# End of macro DMARK
29bf						CALLMONITOR 
29bf cd ab 18			call break_point_state  
29c2				endm  
# End of macro CALLMONITOR
29c2					endif 
29c2 10 dd				djnz .pauses1 
29c4			 
29c4				       NEXTW 
29c4 c3 8d 22			jp macro_next 
29c7				endm 
# End of macro NEXTW
29c7			.ROT: 
29c7				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
29c7 45				db WORD_SYS_CORE+49             
29c8 15 2a			dw .UWORDS            
29ca 04				db 3 + 1 
29cb .. 00			db "ROT",0              
29cf				endm 
# End of macro CWHEAD
29cf			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
29cf					if DEBUG_FORTH_WORDS_KEY 
29cf						DMARK "ROT" 
29cf f5				push af  
29d0 3a e4 29			ld a, (.dmark)  
29d3 32 6e fe			ld (debug_mark),a  
29d6 3a e5 29			ld a, (.dmark+1)  
29d9 32 6f fe			ld (debug_mark+1),a  
29dc 3a e6 29			ld a, (.dmark+2)  
29df 32 70 fe			ld (debug_mark+2),a  
29e2 18 03			jr .pastdmark  
29e4 ..			.dmark: db "ROT"  
29e7 f1			.pastdmark: pop af  
29e8			endm  
# End of macro DMARK
29e8						CALLMONITOR 
29e8 cd ab 18			call break_point_state  
29eb				endm  
# End of macro CALLMONITOR
29eb					endif 
29eb			 
29eb					FORTH_DSP_VALUEHL 
29eb cd 16 21			call macro_dsp_valuehl 
29ee				endm 
# End of macro FORTH_DSP_VALUEHL
29ee e5					push hl    ; u3  
29ef			 
29ef					FORTH_DSP_POP 
29ef cd ce 21			call macro_forth_dsp_pop 
29f2				endm 
# End of macro FORTH_DSP_POP
29f2			   
29f2					FORTH_DSP_VALUEHL 
29f2 cd 16 21			call macro_dsp_valuehl 
29f5				endm 
# End of macro FORTH_DSP_VALUEHL
29f5 e5					push hl     ; u2 
29f6			 
29f6					FORTH_DSP_POP 
29f6 cd ce 21			call macro_forth_dsp_pop 
29f9				endm 
# End of macro FORTH_DSP_POP
29f9			 
29f9					FORTH_DSP_VALUEHL 
29f9 cd 16 21			call macro_dsp_valuehl 
29fc				endm 
# End of macro FORTH_DSP_VALUEHL
29fc e5					push hl     ; u1 
29fd			 
29fd					FORTH_DSP_POP 
29fd cd ce 21			call macro_forth_dsp_pop 
2a00				endm 
# End of macro FORTH_DSP_POP
2a00			 
2a00 c1					pop bc      ; u1 
2a01 e1					pop hl      ; u2 
2a02 d1					pop de      ; u3 
2a03			 
2a03			 
2a03 c5					push bc 
2a04 d5					push de 
2a05 e5					push hl 
2a06			 
2a06			 
2a06 e1					pop hl 
2a07 cd 1f 1f				call forth_push_numhl 
2a0a			 
2a0a e1					pop hl 
2a0b cd 1f 1f				call forth_push_numhl 
2a0e			 
2a0e e1					pop hl 
2a0f cd 1f 1f				call forth_push_numhl 
2a12					 
2a12			 
2a12			 
2a12			 
2a12			 
2a12			 
2a12				       NEXTW 
2a12 c3 8d 22			jp macro_next 
2a15				endm 
# End of macro NEXTW
2a15			 
2a15			.UWORDS: 
2a15				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2a15 50				db WORD_SYS_CORE+60             
2a16 d7 2a			dw .BP            
2a18 07				db 6 + 1 
2a19 .. 00			db "UWORDS",0              
2a20				endm 
# End of macro CWHEAD
2a20			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2a20			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2a20			; | | Following the count are the individual words. 
2a20			; | | 
2a20			; | | e.g. UWORDS 
2a20			; | | BOX DIRLIST 2 
2a20			; | |  
2a20			; | | Can be used to save the words to storage via: 
2a20			; | | UWORDS $01 DO $01 APPEND LOOP 
2a20				if DEBUG_FORTH_WORDS_KEY 
2a20					DMARK "UWR" 
2a20 f5				push af  
2a21 3a 35 2a			ld a, (.dmark)  
2a24 32 6e fe			ld (debug_mark),a  
2a27 3a 36 2a			ld a, (.dmark+1)  
2a2a 32 6f fe			ld (debug_mark+1),a  
2a2d 3a 37 2a			ld a, (.dmark+2)  
2a30 32 70 fe			ld (debug_mark+2),a  
2a33 18 03			jr .pastdmark  
2a35 ..			.dmark: db "UWR"  
2a38 f1			.pastdmark: pop af  
2a39			endm  
# End of macro DMARK
2a39					CALLMONITOR 
2a39 cd ab 18			call break_point_state  
2a3c				endm  
# End of macro CALLMONITOR
2a3c				endif 
2a3c 21 00 80				ld hl, baseram 
2a3f					;ld hl, baseusermem 
2a3f 01 00 00				ld bc, 0    ; start a counter 
2a42			 
2a42				; skip dict stub 
2a42			 
2a42 cd de 23				call forth_tok_next 
2a45			 
2a45			 
2a45			; while we have words to look for 
2a45			 
2a45 7e			.douscan:	ld a, (hl)      
2a46				if DEBUG_FORTH_WORDS 
2a46					DMARK "UWs" 
2a46 f5				push af  
2a47 3a 5b 2a			ld a, (.dmark)  
2a4a 32 6e fe			ld (debug_mark),a  
2a4d 3a 5c 2a			ld a, (.dmark+1)  
2a50 32 6f fe			ld (debug_mark+1),a  
2a53 3a 5d 2a			ld a, (.dmark+2)  
2a56 32 70 fe			ld (debug_mark+2),a  
2a59 18 03			jr .pastdmark  
2a5b ..			.dmark: db "UWs"  
2a5e f1			.pastdmark: pop af  
2a5f			endm  
# End of macro DMARK
2a5f					CALLMONITOR 
2a5f cd ab 18			call break_point_state  
2a62				endm  
# End of macro CALLMONITOR
2a62				endif 
2a62 fe 00				cp WORD_SYS_END 
2a64 28 4d				jr z, .udone 
2a66 fe 01				cp WORD_SYS_UWORD 
2a68 20 44				jr nz, .nuword 
2a6a			 
2a6a				if DEBUG_FORTH_WORDS 
2a6a					DMARK "UWu" 
2a6a f5				push af  
2a6b 3a 7f 2a			ld a, (.dmark)  
2a6e 32 6e fe			ld (debug_mark),a  
2a71 3a 80 2a			ld a, (.dmark+1)  
2a74 32 6f fe			ld (debug_mark+1),a  
2a77 3a 81 2a			ld a, (.dmark+2)  
2a7a 32 70 fe			ld (debug_mark+2),a  
2a7d 18 03			jr .pastdmark  
2a7f ..			.dmark: db "UWu"  
2a82 f1			.pastdmark: pop af  
2a83			endm  
# End of macro DMARK
2a83					CALLMONITOR 
2a83 cd ab 18			call break_point_state  
2a86				endm  
# End of macro CALLMONITOR
2a86				endif 
2a86					; we have a uword so push its name to the stack 
2a86			 
2a86 e5				   	push hl  ; save so we can move to next dict block 
2a87			 
2a87					; skip opcode 
2a87 23					inc hl  
2a88					; skip next ptr 
2a88 23					inc hl  
2a89 23					inc hl 
2a8a					; skip len 
2a8a 23					inc hl 
2a8b				if DEBUG_FORTH_WORDS 
2a8b					DMARK "UWt" 
2a8b f5				push af  
2a8c 3a a0 2a			ld a, (.dmark)  
2a8f 32 6e fe			ld (debug_mark),a  
2a92 3a a1 2a			ld a, (.dmark+1)  
2a95 32 6f fe			ld (debug_mark+1),a  
2a98 3a a2 2a			ld a, (.dmark+2)  
2a9b 32 70 fe			ld (debug_mark+2),a  
2a9e 18 03			jr .pastdmark  
2aa0 ..			.dmark: db "UWt"  
2aa3 f1			.pastdmark: pop af  
2aa4			endm  
# End of macro DMARK
2aa4					CALLMONITOR 
2aa4 cd ab 18			call break_point_state  
2aa7				endm  
# End of macro CALLMONITOR
2aa7				endif 
2aa7 03					inc bc 
2aa8			 
2aa8 c5					push bc 
2aa9 cd 8d 1f				call forth_push_str 
2aac c1					pop bc 
2aad			 
2aad e1					pop hl 	 
2aae			 
2aae cd de 23		.nuword:	call forth_tok_next 
2ab1 18 92				jr .douscan  
2ab3			 
2ab3			.udone:		 ; push count of uwords found 
2ab3 c5					push bc 
2ab4 e1					pop hl 
2ab5			 
2ab5				if DEBUG_FORTH_WORDS 
2ab5					DMARK "UWc" 
2ab5 f5				push af  
2ab6 3a ca 2a			ld a, (.dmark)  
2ab9 32 6e fe			ld (debug_mark),a  
2abc 3a cb 2a			ld a, (.dmark+1)  
2abf 32 6f fe			ld (debug_mark+1),a  
2ac2 3a cc 2a			ld a, (.dmark+2)  
2ac5 32 70 fe			ld (debug_mark+2),a  
2ac8 18 03			jr .pastdmark  
2aca ..			.dmark: db "UWc"  
2acd f1			.pastdmark: pop af  
2ace			endm  
# End of macro DMARK
2ace					CALLMONITOR 
2ace cd ab 18			call break_point_state  
2ad1				endm  
# End of macro CALLMONITOR
2ad1				endif 
2ad1 cd 1f 1f				call forth_push_numhl 
2ad4			 
2ad4			 
2ad4				       NEXTW 
2ad4 c3 8d 22			jp macro_next 
2ad7				endm 
# End of macro NEXTW
2ad7			 
2ad7			.BP: 
2ad7				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2ad7 54				db WORD_SYS_CORE+64             
2ad8 0d 2b			dw .MONITOR            
2ada 03				db 2 + 1 
2adb .. 00			db "BP",0              
2ade				endm 
# End of macro CWHEAD
2ade			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2ade			; | | $00 Will enable the break points within specific code paths 
2ade			; | | $01 Will disable break points 
2ade			; | |  
2ade			; | | By default break points are off. Either the above can be used to enable them 
2ade			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2ade			; | | and on release of the pressed key a message will be disaplayed to notify 
2ade			; | | that break points are enabled. Pressing any key will then continue boot process. 
2ade					; get byte count 
2ade					if DEBUG_FORTH_WORDS_KEY 
2ade						DMARK "BP." 
2ade f5				push af  
2adf 3a f3 2a			ld a, (.dmark)  
2ae2 32 6e fe			ld (debug_mark),a  
2ae5 3a f4 2a			ld a, (.dmark+1)  
2ae8 32 6f fe			ld (debug_mark+1),a  
2aeb 3a f5 2a			ld a, (.dmark+2)  
2aee 32 70 fe			ld (debug_mark+2),a  
2af1 18 03			jr .pastdmark  
2af3 ..			.dmark: db "BP."  
2af6 f1			.pastdmark: pop af  
2af7			endm  
# End of macro DMARK
2af7						CALLMONITOR 
2af7 cd ab 18			call break_point_state  
2afa				endm  
# End of macro CALLMONITOR
2afa					endif 
2afa			 
2afa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2afa cd 16 21			call macro_dsp_valuehl 
2afd				endm 
# End of macro FORTH_DSP_VALUEHL
2afd			 
2afd			;		push hl 
2afd			 
2afd					; destroy value TOS 
2afd			 
2afd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2afd cd ce 21			call macro_forth_dsp_pop 
2b00				endm 
# End of macro FORTH_DSP_POP
2b00			 
2b00			;		pop hl 
2b00			 
2b00 3e 00				ld a,0 
2b02 bd					cp l 
2b03 28 02				jr z, .bpset 
2b05 3e 2a				ld a, '*' 
2b07			 
2b07 32 ee f1		.bpset:		ld (os_view_disable), a 
2b0a			 
2b0a			 
2b0a					NEXTW 
2b0a c3 8d 22			jp macro_next 
2b0d				endm 
# End of macro NEXTW
2b0d			 
2b0d			 
2b0d			.MONITOR: 
2b0d				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2b0d 55				db WORD_SYS_CORE+65             
2b0e 40 2b			dw .MALLOC            
2b10 08				db 7 + 1 
2b11 .. 00			db "MONITOR",0              
2b19				endm 
# End of macro CWHEAD
2b19			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2b19			; | | At start the current various registers will be displayed with contents. 
2b19			; | | Top right corner will show the most recent debug marker seen. 
2b19			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2b19			; | | and the return stack pointer (RSP). 
2b19			; | | Pressing: 
2b19			; | |    1 - Initial screen 
2b19			; | |    2 - Display a data dump of HL 
2b19			; | |    3 - Display a data dump of DE 
2b19			; | |    4 - Display a data dump of BC 
2b19			; | |    5 - Display a data dump of HL 
2b19			; | |    6 - Display a data dump of DSP 
2b19			; | |    7 - Display a data dump of RSP 
2b19			; | |    8 - Display a data dump of what is at DSP 
2b19			; | |    9 - Display a data dump of what is at RSP 
2b19			; | |    0 - Exit monitor and continue running. This will also enable break points 
2b19			; | |    * - Disable break points 
2b19			; | |    # - Enter traditional monitor mode 
2b19			; | | 
2b19			; | | Monitor Mode 
2b19			; | | ------------ 
2b19			; | | A prompt of '>' will be shown for various commands: 
2b19			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2b19			; | |    C - Continue display a data dump from the last set address 
2b19			; | |    M xxxx - Set start of memory edit at address xx 
2b19			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2b19			; | |    Q - Return to previous 
2b19					if DEBUG_FORTH_WORDS_KEY 
2b19						DMARK "MON" 
2b19 f5				push af  
2b1a 3a 2e 2b			ld a, (.dmark)  
2b1d 32 6e fe			ld (debug_mark),a  
2b20 3a 2f 2b			ld a, (.dmark+1)  
2b23 32 6f fe			ld (debug_mark+1),a  
2b26 3a 30 2b			ld a, (.dmark+2)  
2b29 32 70 fe			ld (debug_mark+2),a  
2b2c 18 03			jr .pastdmark  
2b2e ..			.dmark: db "MON"  
2b31 f1			.pastdmark: pop af  
2b32			endm  
# End of macro DMARK
2b32						CALLMONITOR 
2b32 cd ab 18			call break_point_state  
2b35				endm  
# End of macro CALLMONITOR
2b35					endif 
2b35 3e 00				ld a, 0 
2b37 32 ee f1				ld (os_view_disable), a 
2b3a			 
2b3a					CALLMONITOR 
2b3a cd ab 18			call break_point_state  
2b3d				endm  
# End of macro CALLMONITOR
2b3d			 
2b3d			;	call monitor 
2b3d			 
2b3d					NEXTW 
2b3d c3 8d 22			jp macro_next 
2b40				endm 
# End of macro NEXTW
2b40			 
2b40			 
2b40			.MALLOC: 
2b40				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2b40 56				db WORD_SYS_CORE+66             
2b41 69 2b			dw .MALLOC2            
2b43 06				db 5 + 1 
2b44 .. 00			db "ALLOT",0              
2b4a				endm 
# End of macro CWHEAD
2b4a			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2b4a					if DEBUG_FORTH_WORDS_KEY 
2b4a						DMARK "ALL" 
2b4a f5				push af  
2b4b 3a 5f 2b			ld a, (.dmark)  
2b4e 32 6e fe			ld (debug_mark),a  
2b51 3a 60 2b			ld a, (.dmark+1)  
2b54 32 6f fe			ld (debug_mark+1),a  
2b57 3a 61 2b			ld a, (.dmark+2)  
2b5a 32 70 fe			ld (debug_mark+2),a  
2b5d 18 03			jr .pastdmark  
2b5f ..			.dmark: db "ALL"  
2b62 f1			.pastdmark: pop af  
2b63			endm  
# End of macro DMARK
2b63						CALLMONITOR 
2b63 cd ab 18			call break_point_state  
2b66				endm  
# End of macro CALLMONITOR
2b66					endif 
2b66 c3 90 2b				jp .mallocc 
2b69			.MALLOC2: 
2b69				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2b69 56				db WORD_SYS_CORE+66             
2b6a a7 2b			dw .FREE            
2b6c 07				db 6 + 1 
2b6d .. 00			db "MALLOC",0              
2b74				endm 
# End of macro CWHEAD
2b74			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2b74					; get byte count 
2b74					if DEBUG_FORTH_WORDS_KEY 
2b74						DMARK "MAL" 
2b74 f5				push af  
2b75 3a 89 2b			ld a, (.dmark)  
2b78 32 6e fe			ld (debug_mark),a  
2b7b 3a 8a 2b			ld a, (.dmark+1)  
2b7e 32 6f fe			ld (debug_mark+1),a  
2b81 3a 8b 2b			ld a, (.dmark+2)  
2b84 32 70 fe			ld (debug_mark+2),a  
2b87 18 03			jr .pastdmark  
2b89 ..			.dmark: db "MAL"  
2b8c f1			.pastdmark: pop af  
2b8d			endm  
# End of macro DMARK
2b8d						CALLMONITOR 
2b8d cd ab 18			call break_point_state  
2b90				endm  
# End of macro CALLMONITOR
2b90					endif 
2b90			.mallocc: 
2b90					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b90 cd 16 21			call macro_dsp_valuehl 
2b93				endm 
# End of macro FORTH_DSP_VALUEHL
2b93			 
2b93			;		push hl 
2b93			 
2b93					; destroy value TOS 
2b93			 
2b93					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b93 cd ce 21			call macro_forth_dsp_pop 
2b96				endm 
# End of macro FORTH_DSP_POP
2b96			 
2b96			;		pop hl 
2b96 cd cb 13				call malloc 
2b99				if DEBUG_FORTH_MALLOC_GUARD 
2b99 f5					push af 
2b9a cd 2d 0f				call ishlzero 
2b9d			;		ld a, l 
2b9d			;		add h 
2b9d			;		cp 0 
2b9d f1					pop af 
2b9e					 
2b9e cc 9e 55				call z,malloc_error 
2ba1				endif 
2ba1			 
2ba1 cd 1f 1f				call forth_push_numhl 
2ba4					NEXTW 
2ba4 c3 8d 22			jp macro_next 
2ba7				endm 
# End of macro NEXTW
2ba7			 
2ba7			.FREE: 
2ba7				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2ba7 57				db WORD_SYS_CORE+67             
2ba8 d8 2b			dw .LIST            
2baa 05				db 4 + 1 
2bab .. 00			db "FREE",0              
2bb0				endm 
# End of macro CWHEAD
2bb0			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2bb0					if DEBUG_FORTH_WORDS_KEY 
2bb0						DMARK "FRE" 
2bb0 f5				push af  
2bb1 3a c5 2b			ld a, (.dmark)  
2bb4 32 6e fe			ld (debug_mark),a  
2bb7 3a c6 2b			ld a, (.dmark+1)  
2bba 32 6f fe			ld (debug_mark+1),a  
2bbd 3a c7 2b			ld a, (.dmark+2)  
2bc0 32 70 fe			ld (debug_mark+2),a  
2bc3 18 03			jr .pastdmark  
2bc5 ..			.dmark: db "FRE"  
2bc8 f1			.pastdmark: pop af  
2bc9			endm  
# End of macro DMARK
2bc9						CALLMONITOR 
2bc9 cd ab 18			call break_point_state  
2bcc				endm  
# End of macro CALLMONITOR
2bcc					endif 
2bcc					; get address 
2bcc			 
2bcc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2bcc cd 16 21			call macro_dsp_valuehl 
2bcf				endm 
# End of macro FORTH_DSP_VALUEHL
2bcf			 
2bcf			;		push hl 
2bcf			 
2bcf					; destroy value TOS 
2bcf			 
2bcf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2bcf cd ce 21			call macro_forth_dsp_pop 
2bd2				endm 
# End of macro FORTH_DSP_POP
2bd2			 
2bd2			;		pop hl 
2bd2			if FORTH_ENABLE_MALLOCFREE 
2bd2 cd 95 14				call free 
2bd5			endif 
2bd5					NEXTW 
2bd5 c3 8d 22			jp macro_next 
2bd8				endm 
# End of macro NEXTW
2bd8			.LIST: 
2bd8				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2bd8 5c				db WORD_SYS_CORE+72             
2bd9 c6 2d			dw .FORGET            
2bdb 05				db 4 + 1 
2bdc .. 00			db "LIST",0              
2be1				endm 
# End of macro CWHEAD
2be1			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2be1			; | | The quoted word must be in upper case. 
2be1				if DEBUG_FORTH_WORDS_KEY 
2be1					DMARK "LST" 
2be1 f5				push af  
2be2 3a f6 2b			ld a, (.dmark)  
2be5 32 6e fe			ld (debug_mark),a  
2be8 3a f7 2b			ld a, (.dmark+1)  
2beb 32 6f fe			ld (debug_mark+1),a  
2bee 3a f8 2b			ld a, (.dmark+2)  
2bf1 32 70 fe			ld (debug_mark+2),a  
2bf4 18 03			jr .pastdmark  
2bf6 ..			.dmark: db "LST"  
2bf9 f1			.pastdmark: pop af  
2bfa			endm  
# End of macro DMARK
2bfa					CALLMONITOR 
2bfa cd ab 18			call break_point_state  
2bfd				endm  
# End of macro CALLMONITOR
2bfd				endif 
2bfd			 
2bfd					FORTH_DSP_VALUEHL 
2bfd cd 16 21			call macro_dsp_valuehl 
2c00				endm 
# End of macro FORTH_DSP_VALUEHL
2c00			 
2c00 e5					push hl 
2c01					FORTH_DSP_POP 
2c01 cd ce 21			call macro_forth_dsp_pop 
2c04				endm 
# End of macro FORTH_DSP_POP
2c04 c1					pop bc 
2c05			 
2c05			; Start format of scratch string 
2c05			 
2c05 21 fd f1				ld hl, scratch 
2c08			 
2c08 3e 3a				ld a, ':' 
2c0a 77					ld (hl),a 
2c0b 23					inc hl 
2c0c 3e 20				ld a, ' ' 
2c0e 77					ld (hl), a 
2c0f			 
2c0f					; Get ptr to the word we need to look up 
2c0f			 
2c0f			;		FORTH_DSP_VALUEHL 
2c0f					;v5 FORTH_DSP_VALUE 
2c0f				; TODO type check 
2c0f			;		inc hl    ; Skip type check  
2c0f			;		push hl 
2c0f			;		ex de, hl    ; put into DE 
2c0f			 
2c0f			 
2c0f 21 00 80				ld hl, baseram 
2c12					;ld hl, baseusermem 
2c12			 
2c12 e5			push hl   ; sacreifical push 
2c13			 
2c13			.ldouscanm: 
2c13 e1				pop hl 
2c14			.ldouscan: 
2c14				if DEBUG_FORTH_WORDS 
2c14					DMARK "LSs" 
2c14 f5				push af  
2c15 3a 29 2c			ld a, (.dmark)  
2c18 32 6e fe			ld (debug_mark),a  
2c1b 3a 2a 2c			ld a, (.dmark+1)  
2c1e 32 6f fe			ld (debug_mark+1),a  
2c21 3a 2b 2c			ld a, (.dmark+2)  
2c24 32 70 fe			ld (debug_mark+2),a  
2c27 18 03			jr .pastdmark  
2c29 ..			.dmark: db "LSs"  
2c2c f1			.pastdmark: pop af  
2c2d			endm  
# End of macro DMARK
2c2d					CALLMONITOR 
2c2d cd ab 18			call break_point_state  
2c30				endm  
# End of macro CALLMONITOR
2c30				endif 
2c30				; skip dict stub 
2c30 cd de 23				call forth_tok_next 
2c33			 
2c33			 
2c33			; while we have words to look for 
2c33			 
2c33 7e				ld a, (hl)      
2c34				if DEBUG_FORTH_WORDS 
2c34					DMARK "LSk" 
2c34 f5				push af  
2c35 3a 49 2c			ld a, (.dmark)  
2c38 32 6e fe			ld (debug_mark),a  
2c3b 3a 4a 2c			ld a, (.dmark+1)  
2c3e 32 6f fe			ld (debug_mark+1),a  
2c41 3a 4b 2c			ld a, (.dmark+2)  
2c44 32 70 fe			ld (debug_mark+2),a  
2c47 18 03			jr .pastdmark  
2c49 ..			.dmark: db "LSk"  
2c4c f1			.pastdmark: pop af  
2c4d			endm  
# End of macro DMARK
2c4d					CALLMONITOR 
2c4d cd ab 18			call break_point_state  
2c50				endm  
# End of macro CALLMONITOR
2c50				endif 
2c50					;cp WORD_SYS_END 
2c50					;jp z, .lunotfound 
2c50			 
2c50					; if we hit non uwords then gone too far 
2c50 fe 01				cp WORD_SYS_UWORD 
2c52 c2 82 2d				jp nz, .lunotfound 
2c55			 
2c55				if DEBUG_FORTH_WORDS 
2c55					DMARK "LSu" 
2c55 f5				push af  
2c56 3a 6a 2c			ld a, (.dmark)  
2c59 32 6e fe			ld (debug_mark),a  
2c5c 3a 6b 2c			ld a, (.dmark+1)  
2c5f 32 6f fe			ld (debug_mark+1),a  
2c62 3a 6c 2c			ld a, (.dmark+2)  
2c65 32 70 fe			ld (debug_mark+2),a  
2c68 18 03			jr .pastdmark  
2c6a ..			.dmark: db "LSu"  
2c6d f1			.pastdmark: pop af  
2c6e			endm  
# End of macro DMARK
2c6e					CALLMONITOR 
2c6e cd ab 18			call break_point_state  
2c71				endm  
# End of macro CALLMONITOR
2c71				endif 
2c71			 
2c71					; found a uword but is it the one we want... 
2c71			 
2c71 c5					push bc     ; uword to find is on bc 
2c72 d1					pop de 
2c73			 
2c73 e5					push hl  ; to save the ptr 
2c74			 
2c74					; skip opcode 
2c74 23					inc hl  
2c75					; skip next ptr 
2c75 23					inc hl  
2c76 23					inc hl 
2c77					; skip len 
2c77 23					inc hl 
2c78			 
2c78				if DEBUG_FORTH_WORDS 
2c78					DMARK "LSc" 
2c78 f5				push af  
2c79 3a 8d 2c			ld a, (.dmark)  
2c7c 32 6e fe			ld (debug_mark),a  
2c7f 3a 8e 2c			ld a, (.dmark+1)  
2c82 32 6f fe			ld (debug_mark+1),a  
2c85 3a 8f 2c			ld a, (.dmark+2)  
2c88 32 70 fe			ld (debug_mark+2),a  
2c8b 18 03			jr .pastdmark  
2c8d ..			.dmark: db "LSc"  
2c90 f1			.pastdmark: pop af  
2c91			endm  
# End of macro DMARK
2c91					CALLMONITOR 
2c91 cd ab 18			call break_point_state  
2c94				endm  
# End of macro CALLMONITOR
2c94				endif 
2c94 cd 9a 13				call strcmp 
2c97 c2 13 2c				jp nz, .ldouscanm 
2c9a				 
2c9a			 
2c9a			 
2c9a					; we have a uword so push its name to the stack 
2c9a			 
2c9a			;	   	push hl  ; save so we can move to next dict block 
2c9a e1			pop hl 
2c9b			 
2c9b				if DEBUG_FORTH_WORDS 
2c9b					DMARK "LSm" 
2c9b f5				push af  
2c9c 3a b0 2c			ld a, (.dmark)  
2c9f 32 6e fe			ld (debug_mark),a  
2ca2 3a b1 2c			ld a, (.dmark+1)  
2ca5 32 6f fe			ld (debug_mark+1),a  
2ca8 3a b2 2c			ld a, (.dmark+2)  
2cab 32 70 fe			ld (debug_mark+2),a  
2cae 18 03			jr .pastdmark  
2cb0 ..			.dmark: db "LSm"  
2cb3 f1			.pastdmark: pop af  
2cb4			endm  
# End of macro DMARK
2cb4					CALLMONITOR 
2cb4 cd ab 18			call break_point_state  
2cb7				endm  
# End of macro CALLMONITOR
2cb7				endif 
2cb7			 
2cb7					; skip opcode 
2cb7 23					inc hl  
2cb8					; skip next ptr 
2cb8 23					inc hl  
2cb9 23					inc hl 
2cba					; skip len 
2cba 7e					ld a, (hl)   ; save length to add 
2cbb				if DEBUG_FORTH_WORDS 
2cbb					DMARK "LS2" 
2cbb f5				push af  
2cbc 3a d0 2c			ld a, (.dmark)  
2cbf 32 6e fe			ld (debug_mark),a  
2cc2 3a d1 2c			ld a, (.dmark+1)  
2cc5 32 6f fe			ld (debug_mark+1),a  
2cc8 3a d2 2c			ld a, (.dmark+2)  
2ccb 32 70 fe			ld (debug_mark+2),a  
2cce 18 03			jr .pastdmark  
2cd0 ..			.dmark: db "LS2"  
2cd3 f1			.pastdmark: pop af  
2cd4			endm  
# End of macro DMARK
2cd4					CALLMONITOR 
2cd4 cd ab 18			call break_point_state  
2cd7				endm  
# End of macro CALLMONITOR
2cd7				endif 
2cd7			 
2cd7					; save this location 
2cd7				 
2cd7 e5					push hl 
2cd8			 
2cd8 23					inc hl 
2cd9 11 ff f1				ld de, scratch+2 
2cdc 4f					ld c, a 
2cdd 06 00				ld b, 0 
2cdf			 
2cdf				if DEBUG_FORTH_WORDS 
2cdf					DMARK "LSn" 
2cdf f5				push af  
2ce0 3a f4 2c			ld a, (.dmark)  
2ce3 32 6e fe			ld (debug_mark),a  
2ce6 3a f5 2c			ld a, (.dmark+1)  
2ce9 32 6f fe			ld (debug_mark+1),a  
2cec 3a f6 2c			ld a, (.dmark+2)  
2cef 32 70 fe			ld (debug_mark+2),a  
2cf2 18 03			jr .pastdmark  
2cf4 ..			.dmark: db "LSn"  
2cf7 f1			.pastdmark: pop af  
2cf8			endm  
# End of macro DMARK
2cf8					CALLMONITOR 
2cf8 cd ab 18			call break_point_state  
2cfb				endm  
# End of macro CALLMONITOR
2cfb				endif 
2cfb			 
2cfb					; copy uword name to scratch 
2cfb			 
2cfb ed b0				ldir 
2cfd			 
2cfd 1b					dec de 
2cfe 3e 20				ld a, ' '    ; change null to space 
2d00 12					ld (de), a 
2d01			 
2d01 13					inc de 
2d02			 
2d02 d5					push de 
2d03 c1					pop bc     ; move scratch pointer to end of word name and save it 
2d04			 
2d04 e1					pop hl 
2d05 7e					ld a, (hl) 
2d06					;inc hl 
2d06					; skip word string 
2d06 cd 04 0f				call addatohl 
2d09			 
2d09 23					inc hl 
2d0a			 
2d0a				if DEBUG_FORTH_WORDS 
2d0a					DMARK "LS3" 
2d0a f5				push af  
2d0b 3a 1f 2d			ld a, (.dmark)  
2d0e 32 6e fe			ld (debug_mark),a  
2d11 3a 20 2d			ld a, (.dmark+1)  
2d14 32 6f fe			ld (debug_mark+1),a  
2d17 3a 21 2d			ld a, (.dmark+2)  
2d1a 32 70 fe			ld (debug_mark+2),a  
2d1d 18 03			jr .pastdmark  
2d1f ..			.dmark: db "LS3"  
2d22 f1			.pastdmark: pop af  
2d23			endm  
# End of macro DMARK
2d23					CALLMONITOR 
2d23 cd ab 18			call break_point_state  
2d26				endm  
# End of macro CALLMONITOR
2d26				endif 
2d26					; should now be at the start of the machine code to setup the eval of the uword 
2d26					; now locate the ptr to the string defintion 
2d26			 
2d26					; skip ld hl, 
2d26					; then load the ptr 
2d26			; TODO use get from hl ptr 
2d26 23					inc hl 
2d27 5e					ld e, (hl) 
2d28 23					inc hl 
2d29 56					ld d, (hl) 
2d2a eb					ex de, hl 
2d2b			 
2d2b			 
2d2b				if DEBUG_FORTH_WORDS 
2d2b					DMARK "LSt" 
2d2b f5				push af  
2d2c 3a 40 2d			ld a, (.dmark)  
2d2f 32 6e fe			ld (debug_mark),a  
2d32 3a 41 2d			ld a, (.dmark+1)  
2d35 32 6f fe			ld (debug_mark+1),a  
2d38 3a 42 2d			ld a, (.dmark+2)  
2d3b 32 70 fe			ld (debug_mark+2),a  
2d3e 18 03			jr .pastdmark  
2d40 ..			.dmark: db "LSt"  
2d43 f1			.pastdmark: pop af  
2d44			endm  
# End of macro DMARK
2d44					CALLMONITOR 
2d44 cd ab 18			call break_point_state  
2d47				endm  
# End of macro CALLMONITOR
2d47				endif 
2d47			 
2d47			; cant push right now due to tokenised strings  
2d47			 
2d47			; get the destination of where to copy this definition to. 
2d47			 
2d47 c5					push bc 
2d48 d1					pop de 
2d49			 
2d49 7e			.listl:         ld a,(hl) 
2d4a fe 00				cp 0 
2d4c 28 09				jr z, .lreplsp     ; replace zero with space 
2d4e					;cp FORTH_END_BUFFER 
2d4e fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2d50 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2d52				 
2d52					; just copy this char as is then 
2d52			 
2d52 12					ld (de), a 
2d53			 
2d53 23			.listnxt:	inc hl 
2d54 13					inc de 
2d55 18 f2				jr .listl 
2d57			 
2d57 3e 20		.lreplsp:	ld a,' ' 
2d59 12					ld (de), a 
2d5a 18 f7				jr .listnxt 
2d5c			 
2d5c			; close up uword def 
2d5c			 
2d5c			.listdone: 
2d5c 12					ld (de), a 
2d5d 13					inc de 
2d5e 3e 00				ld a, 0 
2d60 12					ld (de), a 
2d61			 
2d61			; now have def so clean up and push to stack 
2d61			 
2d61 21 fd f1				ld hl, scratch 
2d64				if DEBUG_FORTH_WORDS 
2d64					DMARK "Ltp" 
2d64 f5				push af  
2d65 3a 79 2d			ld a, (.dmark)  
2d68 32 6e fe			ld (debug_mark),a  
2d6b 3a 7a 2d			ld a, (.dmark+1)  
2d6e 32 6f fe			ld (debug_mark+1),a  
2d71 3a 7b 2d			ld a, (.dmark+2)  
2d74 32 70 fe			ld (debug_mark+2),a  
2d77 18 03			jr .pastdmark  
2d79 ..			.dmark: db "Ltp"  
2d7c f1			.pastdmark: pop af  
2d7d			endm  
# End of macro DMARK
2d7d					CALLMONITOR 
2d7d cd ab 18			call break_point_state  
2d80				endm  
# End of macro CALLMONITOR
2d80				endif 
2d80			 
2d80 18 1f			jr .listpush 
2d82			 
2d82			;.lnuword:	pop hl 
2d82			;		call forth_tok_next 
2d82			;		jp .ldouscan  
2d82			 
2d82			.lunotfound:		  
2d82			 
2d82				if DEBUG_FORTH_WORDS 
2d82					DMARK "LSn" 
2d82 f5				push af  
2d83 3a 97 2d			ld a, (.dmark)  
2d86 32 6e fe			ld (debug_mark),a  
2d89 3a 98 2d			ld a, (.dmark+1)  
2d8c 32 6f fe			ld (debug_mark+1),a  
2d8f 3a 99 2d			ld a, (.dmark+2)  
2d92 32 70 fe			ld (debug_mark+2),a  
2d95 18 03			jr .pastdmark  
2d97 ..			.dmark: db "LSn"  
2d9a f1			.pastdmark: pop af  
2d9b			endm  
# End of macro DMARK
2d9b					CALLMONITOR 
2d9b cd ab 18			call break_point_state  
2d9e				endm  
# End of macro CALLMONITOR
2d9e				endif 
2d9e			 
2d9e					 
2d9e			;		FORTH_DSP_POP 
2d9e			;		ld hl, .luno 
2d9e			 
2d9e					NEXTW			 
2d9e c3 8d 22			jp macro_next 
2da1				endm 
# End of macro NEXTW
2da1			 
2da1			.listpush: 
2da1				if DEBUG_FORTH_WORDS 
2da1					DMARK "LS>" 
2da1 f5				push af  
2da2 3a b6 2d			ld a, (.dmark)  
2da5 32 6e fe			ld (debug_mark),a  
2da8 3a b7 2d			ld a, (.dmark+1)  
2dab 32 6f fe			ld (debug_mark+1),a  
2dae 3a b8 2d			ld a, (.dmark+2)  
2db1 32 70 fe			ld (debug_mark+2),a  
2db4 18 03			jr .pastdmark  
2db6 ..			.dmark: db "LS>"  
2db9 f1			.pastdmark: pop af  
2dba			endm  
# End of macro DMARK
2dba					CALLMONITOR 
2dba cd ab 18			call break_point_state  
2dbd				endm  
# End of macro CALLMONITOR
2dbd				endif 
2dbd cd 8d 1f				call forth_push_str 
2dc0			 
2dc0			 
2dc0			 
2dc0					NEXTW 
2dc0 c3 8d 22			jp macro_next 
2dc3				endm 
# End of macro NEXTW
2dc3			 
2dc3			;.luno:    db "Word not found",0 
2dc3			 
2dc3			 
2dc3			 
2dc3			 
2dc3			 
2dc3			;		push hl   ; save pointer to start of uword def string 
2dc3			; 
2dc3			;; look for FORTH_EOL_LINE 
2dc3			;		ld a, FORTH_END_BUFFER 
2dc3			;		call strlent 
2dc3			; 
2dc3			;		inc hl		 ; space for coln def 
2dc3			;		inc hl 
2dc3			;		inc hl          ; space for terms 
2dc3			;		inc hl 
2dc3			; 
2dc3			;		ld a, 20   ; TODO get actual length 
2dc3			;		call addatohl    ; include a random amount of room for the uword name 
2dc3			; 
2dc3			;		 
2dc3			;	if DEBUG_FORTH_WORDS 
2dc3			;		DMARK "Lt1" 
2dc3			;		CALLMONITOR 
2dc3			;	endif 
2dc3			;		 
2dc3			; 
2dc3			;; malloc space for the string because we cant change it 
2dc3			; 
2dc3			;		call malloc 
2dc3			;	if DEBUG_FORTH_MALLOC_GUARD 
2dc3			;		push af 
2dc3			;		call ishlzero 
2dc3			;		pop af 
2dc3			;		 
2dc3			;		call z,malloc_error 
2dc3			;	endif 
2dc3			; 
2dc3			;	if DEBUG_FORTH_WORDS 
2dc3			;		DMARK "Lt2" 
2dc3			;		CALLMONITOR 
2dc3			;	endif 
2dc3			;		pop de 
2dc3			;		push hl    ; push the malloc to release later 
2dc3			;		push hl   ;  push back a copy for the later stack push 
2dc3			;		 
2dc3			;; copy the string swapping out the zero terms for spaces 
2dc3			; 
2dc3			;		; de has our source 
2dc3			;		; hl has our dest 
2dc3			; 
2dc3			;; add the coln def 
2dc3			; 
2dc3			;		ld a, ':' 
2dc3			;		ld (hl), a 
2dc3			;		inc hl 
2dc3			;		ld a, ' ' 
2dc3			;		ld (hl), a 
2dc3			;		inc hl 
2dc3			; 
2dc3			;; add the uname word 
2dc3			;		push de   ; save our string for now 
2dc3			;		ex de, hl 
2dc3			; 
2dc3			;		FORTH_DSP_VALUE 
2dc3			;		;v5 FORTH_DSP_VALUE 
2dc3			; 
2dc3			;		inc hl   ; skip type but we know by now this is OK 
2dc3			; 
2dc3			;.luword:	ld a,(hl) 
2dc3			;		cp 0 
2dc3			;		jr z, .luword2 
2dc3			;		ld (de), a 
2dc3			;		inc de 
2dc3			;		inc hl 
2dc3			;		jr .luword 
2dc3			; 
2dc3			;.luword2:	ld a, ' ' 
2dc3			;		ld (de), a 
2dc3			;;		inc hl 
2dc3			;;		inc de 
2dc3			;;		ld (de), a 
2dc3			;;		inc hl 
2dc3			;		inc de 
2dc3			; 
2dc3			;		ex de, hl 
2dc3			;		pop de 
2dc3			;		 
2dc3			;		 
2dc3			; 
2dc3			;; detoken that string and copy it 
2dc3			; 
2dc3			;	if DEBUG_FORTH_WORDS 
2dc3			;		DMARK "Lt2" 
2dc3			;		CALLMONITOR 
2dc3			;	endif 
2dc3			;.ldetok:	ld a, (de) 
2dc3			;		cp FORTH_END_BUFFER 
2dc3			;		jr z, .ldetokend 
2dc3			;		; swap out any zero term for space 
2dc3			;		cp 0 
2dc3			;		jr nz, .ldetoknext 
2dc3			;		ld a, ' ' 
2dc3			; 
2dc3			;	if DEBUG_FORTH_WORDS 
2dc3			;		DMARK "LtS" 
2dc3			;		CALLMONITOR 
2dc3			;	endif 
2dc3			;.ldetoknext:	ld (hl), a 
2dc3			;		inc de 
2dc3			;		inc hl 
2dc3			;		jr .ldetok 
2dc3			; 
2dc3			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2dc3			;		ld (hl), a  
2dc3			; 
2dc3			;; free that temp malloc 
2dc3			; 
2dc3			;		pop hl    
2dc3			; 
2dc3			;	if DEBUG_FORTH_WORDS 
2dc3			;		DMARK "Lt4" 
2dc3			;		CALLMONITOR 
2dc3			;	endif 
2dc3			;		call forth_apushstrhl 
2dc3			; 
2dc3			;		; get rid of temp malloc area 
2dc3			; 
2dc3			;		pop hl 
2dc3			;		call free 
2dc3			; 
2dc3			;		jr .ludone 
2dc3			; 
2dc3			;.lnuword:	pop hl 
2dc3			;		call forth_tok_next 
2dc3			;		jp .ldouscan  
2dc3			; 
2dc3			;.ludone:		 pop hl 
2dc3			; 
2dc3					NEXTW 
2dc3 c3 8d 22			jp macro_next 
2dc6				endm 
# End of macro NEXTW
2dc6			 
2dc6			.FORGET: 
2dc6				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2dc6 5d				db WORD_SYS_CORE+73             
2dc7 3f 2e			dw .NOP            
2dc9 07				db 6 + 1 
2dca .. 00			db "FORGET",0              
2dd1				endm 
# End of macro CWHEAD
2dd1			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2dd1			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2dd1			; | |  
2dd1			; | | e.g. "MORE" forget 
2dd1					if DEBUG_FORTH_WORDS_KEY 
2dd1						DMARK "FRG" 
2dd1 f5				push af  
2dd2 3a e6 2d			ld a, (.dmark)  
2dd5 32 6e fe			ld (debug_mark),a  
2dd8 3a e7 2d			ld a, (.dmark+1)  
2ddb 32 6f fe			ld (debug_mark+1),a  
2dde 3a e8 2d			ld a, (.dmark+2)  
2de1 32 70 fe			ld (debug_mark+2),a  
2de4 18 03			jr .pastdmark  
2de6 ..			.dmark: db "FRG"  
2de9 f1			.pastdmark: pop af  
2dea			endm  
# End of macro DMARK
2dea						CALLMONITOR 
2dea cd ab 18			call break_point_state  
2ded				endm  
# End of macro CALLMONITOR
2ded					endif 
2ded			 
2ded				; find uword 
2ded			        ; update start of word with "_" 
2ded				; replace uword with deleted flag 
2ded			 
2ded			 
2ded			;	if DEBUG_FORTH_WORDS 
2ded			;		DMARK "FOG" 
2ded			;		CALLMONITOR 
2ded			;	endif 
2ded			 
2ded			 
2ded					; Get ptr to the word we need to look up 
2ded			 
2ded					FORTH_DSP_VALUEHL 
2ded cd 16 21			call macro_dsp_valuehl 
2df0				endm 
# End of macro FORTH_DSP_VALUEHL
2df0					;v5 FORTH_DSP_VALUE 
2df0				; TODO type check 
2df0			;		inc hl    ; Skip type check  
2df0 e5					push hl 
2df1 c1					pop bc 
2df2			;		ex de, hl    ; put into DE 
2df2			 
2df2			 
2df2 21 00 80				ld hl, baseram 
2df5					;ld hl, baseusermem 
2df5			 
2df5				; skip dict stub 
2df5			;	call forth_tok_next 
2df5 e5			push hl   ; sacreifical push 
2df6			 
2df6			.fldouscanm: 
2df6 e1				pop hl 
2df7			.fldouscan: 
2df7			;	if DEBUG_FORTH_WORDS 
2df7			;		DMARK "LSs" 
2df7			;		CALLMONITOR 
2df7			;	endif 
2df7				; skip dict stub 
2df7 cd de 23				call forth_tok_next 
2dfa			 
2dfa			 
2dfa			; while we have words to look for 
2dfa			 
2dfa 7e				ld a, (hl)      
2dfb			;	if DEBUG_FORTH_WORDS 
2dfb			;		DMARK "LSk" 
2dfb			;		CALLMONITOR 
2dfb			;	endif 
2dfb fe 00				cp WORD_SYS_END 
2dfd ca 39 2e				jp z, .flunotfound 
2e00 fe 01				cp WORD_SYS_UWORD 
2e02 c2 f7 2d				jp nz, .fldouscan 
2e05			 
2e05			;	if DEBUG_FORTH_WORDS 
2e05			;		DMARK "LSu" 
2e05			;		CALLMONITOR 
2e05			;	endif 
2e05			 
2e05					; found a uword but is it the one we want... 
2e05			 
2e05 c5					push bc     ; uword to find is on bc 
2e06 d1					pop de 
2e07			 
2e07 e5					push hl  ; to save the ptr 
2e08			 
2e08					; skip opcode 
2e08 23					inc hl  
2e09					; skip next ptr 
2e09 23					inc hl  
2e0a 23					inc hl 
2e0b					; skip len 
2e0b 23					inc hl 
2e0c			 
2e0c			;	if DEBUG_FORTH_WORDS 
2e0c			;		DMARK "LSc" 
2e0c			;		CALLMONITOR 
2e0c			;	endif 
2e0c cd 9a 13				call strcmp 
2e0f c2 f6 2d				jp nz, .fldouscanm 
2e12			; 
2e12			; 
2e12			;; while we have words to look for 
2e12			; 
2e12			;.fdouscan:	ld a, (hl)      
2e12			;	if DEBUG_FORTH_WORDS 
2e12			;		DMARK "LSs" 
2e12			;		CALLMONITOR 
2e12			;	endif 
2e12			;		cp WORD_SYS_END 
2e12			;		jp z, .fudone 
2e12			;		cp WORD_SYS_UWORD 
2e12			;		jp nz, .fnuword 
2e12			; 
2e12			;	if DEBUG_FORTH_WORDS 
2e12			;		DMARK "FGu" 
2e12			;		CALLMONITOR 
2e12			;	endif 
2e12			; 
2e12			;		; found a uword but is it the one we want... 
2e12			; 
2e12			; 
2e12			;	        pop de   ; get back the dsp name 
2e12			;		push de 
2e12			; 
2e12			;		push hl  ; to save the ptr 
2e12			; 
2e12			;		; skip opcode 
2e12			;		inc hl  
2e12			;		; skip next ptr 
2e12			;		inc hl  
2e12			;		inc hl 
2e12			;		; skip len 
2e12			;		inc hl 
2e12			; 
2e12			;	if DEBUG_FORTH_WORDS 
2e12			;		DMARK "FGc" 
2e12			;		CALLMONITOR 
2e12			;	endif 
2e12			;		call strcmp 
2e12			;		jp nz, .fnuword 
2e12			 
2e12			 
2e12 e1			pop hl 
2e13			 
2e13				 
2e13				if DEBUG_FORTH_WORDS 
2e13					DMARK "FGm" 
2e13 f5				push af  
2e14 3a 28 2e			ld a, (.dmark)  
2e17 32 6e fe			ld (debug_mark),a  
2e1a 3a 29 2e			ld a, (.dmark+1)  
2e1d 32 6f fe			ld (debug_mark+1),a  
2e20 3a 2a 2e			ld a, (.dmark+2)  
2e23 32 70 fe			ld (debug_mark+2),a  
2e26 18 03			jr .pastdmark  
2e28 ..			.dmark: db "FGm"  
2e2b f1			.pastdmark: pop af  
2e2c			endm  
# End of macro DMARK
2e2c					CALLMONITOR 
2e2c cd ab 18			call break_point_state  
2e2f				endm  
# End of macro CALLMONITOR
2e2f				endif 
2e2f			 
2e2f			 
2e2f			 
2e2f					; we have a uword so push its name to the stack 
2e2f			 
2e2f			;	   	push hl  ; save so we can move to next dict block 
2e2f			;pop hl 
2e2f			 
2e2f					; update opcode to deleted 
2e2f 3e 03				ld a, WORD_SYS_DELETED 
2e31 77					ld (hl), a 
2e32			 
2e32 23					inc hl  
2e33					; skip next ptr 
2e33 23					inc hl  
2e34 23					inc hl 
2e35					; skip len 
2e35 23					inc hl 
2e36			 
2e36					; TODO change parser to skip deleted words but for now mark it out 
2e36 3e 5f				ld a, "_" 
2e38 77					ld  (hl),a 
2e39			 
2e39			;		jr .fudone 
2e39			; 
2e39			;.fnuword:	pop hl 
2e39			;		call forth_tok_next 
2e39			;		jp .fdouscan  
2e39			 
2e39			.flunotfound:		  
2e39			 
2e39			 
2e39					 
2e39					FORTH_DSP_POP 
2e39 cd ce 21			call macro_forth_dsp_pop 
2e3c				endm 
# End of macro FORTH_DSP_POP
2e3c			;		ld hl, .luno 
2e3c			;.fudone:		 pop hl 
2e3c					NEXTW 
2e3c c3 8d 22			jp macro_next 
2e3f				endm 
# End of macro NEXTW
2e3f			.NOP: 
2e3f				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2e3f 61				db WORD_SYS_CORE+77             
2e40 66 2e			dw .COMO            
2e42 04				db 3 + 1 
2e43 .. 00			db "NOP",0              
2e47				endm 
# End of macro CWHEAD
2e47			; | NOP (  --  ) Do nothing | DONE 
2e47					if DEBUG_FORTH_WORDS_KEY 
2e47						DMARK "NOP" 
2e47 f5				push af  
2e48 3a 5c 2e			ld a, (.dmark)  
2e4b 32 6e fe			ld (debug_mark),a  
2e4e 3a 5d 2e			ld a, (.dmark+1)  
2e51 32 6f fe			ld (debug_mark+1),a  
2e54 3a 5e 2e			ld a, (.dmark+2)  
2e57 32 70 fe			ld (debug_mark+2),a  
2e5a 18 03			jr .pastdmark  
2e5c ..			.dmark: db "NOP"  
2e5f f1			.pastdmark: pop af  
2e60			endm  
# End of macro DMARK
2e60						CALLMONITOR 
2e60 cd ab 18			call break_point_state  
2e63				endm  
# End of macro CALLMONITOR
2e63					endif 
2e63				       NEXTW 
2e63 c3 8d 22			jp macro_next 
2e66				endm 
# End of macro NEXTW
2e66			.COMO: 
2e66				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2e66 6e				db WORD_SYS_CORE+90             
2e67 b8 2e			dw .COMC            
2e69 02				db 1 + 1 
2e6a .. 00			db "(",0              
2e6c				endm 
# End of macro CWHEAD
2e6c			; | ( ( -- )  Start of comment | DONE 
2e6c			 
2e6c			 
2e6c 2a fe f4				ld hl, ( os_tok_ptr) 
2e6f 11 b3 2e			ld de, .closepar 
2e72					 
2e72					if DEBUG_FORTH_WORDS 
2e72						DMARK ").." 
2e72 f5				push af  
2e73 3a 87 2e			ld a, (.dmark)  
2e76 32 6e fe			ld (debug_mark),a  
2e79 3a 88 2e			ld a, (.dmark+1)  
2e7c 32 6f fe			ld (debug_mark+1),a  
2e7f 3a 89 2e			ld a, (.dmark+2)  
2e82 32 70 fe			ld (debug_mark+2),a  
2e85 18 03			jr .pastdmark  
2e87 ..			.dmark: db ").."  
2e8a f1			.pastdmark: pop af  
2e8b			endm  
# End of macro DMARK
2e8b						CALLMONITOR 
2e8b cd ab 18			call break_point_state  
2e8e				endm  
# End of macro CALLMONITOR
2e8e					endif 
2e8e cd a8 23			call findnexttok  
2e91			 
2e91					if DEBUG_FORTH_WORDS 
2e91						DMARK "IF5" 
2e91 f5				push af  
2e92 3a a6 2e			ld a, (.dmark)  
2e95 32 6e fe			ld (debug_mark),a  
2e98 3a a7 2e			ld a, (.dmark+1)  
2e9b 32 6f fe			ld (debug_mark+1),a  
2e9e 3a a8 2e			ld a, (.dmark+2)  
2ea1 32 70 fe			ld (debug_mark+2),a  
2ea4 18 03			jr .pastdmark  
2ea6 ..			.dmark: db "IF5"  
2ea9 f1			.pastdmark: pop af  
2eaa			endm  
# End of macro DMARK
2eaa						CALLMONITOR 
2eaa cd ab 18			call break_point_state  
2ead				endm  
# End of macro CALLMONITOR
2ead					endif 
2ead				; replace below with ) exec using tok_ptr 
2ead 22 fe f4			ld (os_tok_ptr), hl 
2eb0 c3 1e 23			jp exec1 
2eb3			 
2eb3 .. 00			.closepar:   db ")",0 
2eb5			 
2eb5				       NEXTW 
2eb5 c3 8d 22			jp macro_next 
2eb8				endm 
# End of macro NEXTW
2eb8			.COMC: 
2eb8				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2eb8 6f				db WORD_SYS_CORE+91             
2eb9 c1 2e			dw .SCRATCH            
2ebb 02				db 1 + 1 
2ebc .. 00			db ")",0              
2ebe				endm 
# End of macro CWHEAD
2ebe			; | ) ( -- )  End of comment |  DONE  
2ebe				       NEXTW 
2ebe c3 8d 22			jp macro_next 
2ec1				endm 
# End of macro NEXTW
2ec1			 
2ec1			.SCRATCH: 
2ec1				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2ec1 6f				db WORD_SYS_CORE+91             
2ec2 fc 2e			dw .INC            
2ec4 08				db 7 + 1 
2ec5 .. 00			db "SCRATCH",0              
2ecd				endm 
# End of macro CWHEAD
2ecd			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2ecd			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2ecd			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2ecd			; | |  
2ecd			; | | e.g.    : score $00 scratch ; 
2ecd			; | |  
2ecd			; | | $00 score ! 
2ecd			; | | $01 score +! 
2ecd			; | |  
2ecd			; | | e.g.   : varword $0a scratch ;  
2ecd			; | | 
2ecd			; | | $8000 varword ! 
2ecd					if DEBUG_FORTH_WORDS_KEY 
2ecd						DMARK "SCR" 
2ecd f5				push af  
2ece 3a e2 2e			ld a, (.dmark)  
2ed1 32 6e fe			ld (debug_mark),a  
2ed4 3a e3 2e			ld a, (.dmark+1)  
2ed7 32 6f fe			ld (debug_mark+1),a  
2eda 3a e4 2e			ld a, (.dmark+2)  
2edd 32 70 fe			ld (debug_mark+2),a  
2ee0 18 03			jr .pastdmark  
2ee2 ..			.dmark: db "SCR"  
2ee5 f1			.pastdmark: pop af  
2ee6			endm  
# End of macro DMARK
2ee6						CALLMONITOR 
2ee6 cd ab 18			call break_point_state  
2ee9				endm  
# End of macro CALLMONITOR
2ee9					endif 
2ee9			 
2ee9					FORTH_DSP_VALUEHL 
2ee9 cd 16 21			call macro_dsp_valuehl 
2eec				endm 
# End of macro FORTH_DSP_VALUEHL
2eec				 
2eec					FORTH_DSP_POP 
2eec cd ce 21			call macro_forth_dsp_pop 
2eef				endm 
# End of macro FORTH_DSP_POP
2eef			 
2eef 7d					ld a, l 
2ef0 21 22 f7				ld hl, os_var_array 
2ef3 cd 04 0f				call addatohl 
2ef6			 
2ef6 cd 1f 1f				call forth_push_numhl 
2ef9			 
2ef9				       NEXTW 
2ef9 c3 8d 22			jp macro_next 
2efc				endm 
# End of macro NEXTW
2efc			 
2efc			.INC: 
2efc				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2efc 6f				db WORD_SYS_CORE+91             
2efd 50 2f			dw .DEC            
2eff 03				db 2 + 1 
2f00 .. 00			db "+!",0              
2f03				endm 
# End of macro CWHEAD
2f03			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2f03					if DEBUG_FORTH_WORDS_KEY 
2f03						DMARK "+s_" 
2f03 f5				push af  
2f04 3a 18 2f			ld a, (.dmark)  
2f07 32 6e fe			ld (debug_mark),a  
2f0a 3a 19 2f			ld a, (.dmark+1)  
2f0d 32 6f fe			ld (debug_mark+1),a  
2f10 3a 1a 2f			ld a, (.dmark+2)  
2f13 32 70 fe			ld (debug_mark+2),a  
2f16 18 03			jr .pastdmark  
2f18 ..			.dmark: db "+s_"  
2f1b f1			.pastdmark: pop af  
2f1c			endm  
# End of macro DMARK
2f1c						CALLMONITOR 
2f1c cd ab 18			call break_point_state  
2f1f				endm  
# End of macro CALLMONITOR
2f1f					endif 
2f1f			 
2f1f					FORTH_DSP_VALUEHL 
2f1f cd 16 21			call macro_dsp_valuehl 
2f22				endm 
# End of macro FORTH_DSP_VALUEHL
2f22			 
2f22 e5					push hl   ; save address 
2f23			 
2f23					FORTH_DSP_POP 
2f23 cd ce 21			call macro_forth_dsp_pop 
2f26				endm 
# End of macro FORTH_DSP_POP
2f26			 
2f26					FORTH_DSP_VALUEHL 
2f26 cd 16 21			call macro_dsp_valuehl 
2f29				endm 
# End of macro FORTH_DSP_VALUEHL
2f29			 
2f29					FORTH_DSP_POP 
2f29 cd ce 21			call macro_forth_dsp_pop 
2f2c				endm 
# End of macro FORTH_DSP_POP
2f2c			 
2f2c					; hl contains value to add to byte at a 
2f2c				 
2f2c eb					ex de, hl 
2f2d			 
2f2d e1					pop hl 
2f2e			 
2f2e					if DEBUG_FORTH_WORDS 
2f2e						DMARK "INC" 
2f2e f5				push af  
2f2f 3a 43 2f			ld a, (.dmark)  
2f32 32 6e fe			ld (debug_mark),a  
2f35 3a 44 2f			ld a, (.dmark+1)  
2f38 32 6f fe			ld (debug_mark+1),a  
2f3b 3a 45 2f			ld a, (.dmark+2)  
2f3e 32 70 fe			ld (debug_mark+2),a  
2f41 18 03			jr .pastdmark  
2f43 ..			.dmark: db "INC"  
2f46 f1			.pastdmark: pop af  
2f47			endm  
# End of macro DMARK
2f47						CALLMONITOR 
2f47 cd ab 18			call break_point_state  
2f4a				endm  
# End of macro CALLMONITOR
2f4a					endif 
2f4a			 
2f4a 7e					ld a,(hl) 
2f4b 83					add e 
2f4c 77					ld (hl),a 
2f4d			 
2f4d			 
2f4d			 
2f4d				       NEXTW 
2f4d c3 8d 22			jp macro_next 
2f50				endm 
# End of macro NEXTW
2f50			 
2f50			.DEC: 
2f50				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2f50 6f				db WORD_SYS_CORE+91             
2f51 a1 2f			dw .INC2            
2f53 03				db 2 + 1 
2f54 .. 00			db "-!",0              
2f57				endm 
# End of macro CWHEAD
2f57			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2f57					if DEBUG_FORTH_WORDS_KEY 
2f57						DMARK "-s_" 
2f57 f5				push af  
2f58 3a 6c 2f			ld a, (.dmark)  
2f5b 32 6e fe			ld (debug_mark),a  
2f5e 3a 6d 2f			ld a, (.dmark+1)  
2f61 32 6f fe			ld (debug_mark+1),a  
2f64 3a 6e 2f			ld a, (.dmark+2)  
2f67 32 70 fe			ld (debug_mark+2),a  
2f6a 18 03			jr .pastdmark  
2f6c ..			.dmark: db "-s_"  
2f6f f1			.pastdmark: pop af  
2f70			endm  
# End of macro DMARK
2f70						CALLMONITOR 
2f70 cd ab 18			call break_point_state  
2f73				endm  
# End of macro CALLMONITOR
2f73					endif 
2f73			 
2f73					FORTH_DSP_VALUEHL 
2f73 cd 16 21			call macro_dsp_valuehl 
2f76				endm 
# End of macro FORTH_DSP_VALUEHL
2f76			 
2f76 e5					push hl   ; save address 
2f77			 
2f77					FORTH_DSP_POP 
2f77 cd ce 21			call macro_forth_dsp_pop 
2f7a				endm 
# End of macro FORTH_DSP_POP
2f7a			 
2f7a					FORTH_DSP_VALUEHL 
2f7a cd 16 21			call macro_dsp_valuehl 
2f7d				endm 
# End of macro FORTH_DSP_VALUEHL
2f7d			 
2f7d					; hl contains value to add to byte at a 
2f7d				 
2f7d eb					ex de, hl 
2f7e			 
2f7e e1					pop hl 
2f7f			 
2f7f					if DEBUG_FORTH_WORDS 
2f7f						DMARK "DEC" 
2f7f f5				push af  
2f80 3a 94 2f			ld a, (.dmark)  
2f83 32 6e fe			ld (debug_mark),a  
2f86 3a 95 2f			ld a, (.dmark+1)  
2f89 32 6f fe			ld (debug_mark+1),a  
2f8c 3a 96 2f			ld a, (.dmark+2)  
2f8f 32 70 fe			ld (debug_mark+2),a  
2f92 18 03			jr .pastdmark  
2f94 ..			.dmark: db "DEC"  
2f97 f1			.pastdmark: pop af  
2f98			endm  
# End of macro DMARK
2f98						CALLMONITOR 
2f98 cd ab 18			call break_point_state  
2f9b				endm  
# End of macro CALLMONITOR
2f9b					endif 
2f9b			 
2f9b 7e					ld a,(hl) 
2f9c 93					sub e 
2f9d 77					ld (hl),a 
2f9e			 
2f9e			 
2f9e			 
2f9e				       NEXTW 
2f9e c3 8d 22			jp macro_next 
2fa1				endm 
# End of macro NEXTW
2fa1			 
2fa1			.INC2: 
2fa1				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2fa1 6f				db WORD_SYS_CORE+91             
2fa2 4b 30			dw .DEC2            
2fa4 04				db 3 + 1 
2fa5 .. 00			db "+2!",0              
2fa9				endm 
# End of macro CWHEAD
2fa9			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2fa9			 
2fa9					if DEBUG_FORTH_WORDS_KEY 
2fa9						DMARK "+2s" 
2fa9 f5				push af  
2faa 3a be 2f			ld a, (.dmark)  
2fad 32 6e fe			ld (debug_mark),a  
2fb0 3a bf 2f			ld a, (.dmark+1)  
2fb3 32 6f fe			ld (debug_mark+1),a  
2fb6 3a c0 2f			ld a, (.dmark+2)  
2fb9 32 70 fe			ld (debug_mark+2),a  
2fbc 18 03			jr .pastdmark  
2fbe ..			.dmark: db "+2s"  
2fc1 f1			.pastdmark: pop af  
2fc2			endm  
# End of macro DMARK
2fc2						CALLMONITOR 
2fc2 cd ab 18			call break_point_state  
2fc5				endm  
# End of macro CALLMONITOR
2fc5					endif 
2fc5			 
2fc5					; Address 
2fc5			 
2fc5					FORTH_DSP_VALUEHL 
2fc5 cd 16 21			call macro_dsp_valuehl 
2fc8				endm 
# End of macro FORTH_DSP_VALUEHL
2fc8			 
2fc8 e5					push hl    ; save address 
2fc9			 
2fc9					; load content into de 
2fc9			 
2fc9 5e					ld e,(hl) 
2fca 23					inc hl 
2fcb 56					ld d, (hl) 
2fcc			 
2fcc					if DEBUG_FORTH_WORDS 
2fcc						DMARK "+2a" 
2fcc f5				push af  
2fcd 3a e1 2f			ld a, (.dmark)  
2fd0 32 6e fe			ld (debug_mark),a  
2fd3 3a e2 2f			ld a, (.dmark+1)  
2fd6 32 6f fe			ld (debug_mark+1),a  
2fd9 3a e3 2f			ld a, (.dmark+2)  
2fdc 32 70 fe			ld (debug_mark+2),a  
2fdf 18 03			jr .pastdmark  
2fe1 ..			.dmark: db "+2a"  
2fe4 f1			.pastdmark: pop af  
2fe5			endm  
# End of macro DMARK
2fe5						CALLMONITOR 
2fe5 cd ab 18			call break_point_state  
2fe8				endm  
# End of macro CALLMONITOR
2fe8					endif 
2fe8			 
2fe8					FORTH_DSP_POP 
2fe8 cd ce 21			call macro_forth_dsp_pop 
2feb				endm 
# End of macro FORTH_DSP_POP
2feb			 
2feb					; Get value to add 
2feb			 
2feb					FORTH_DSP_VALUE 
2feb cd ff 20			call macro_forth_dsp_value 
2fee				endm 
# End of macro FORTH_DSP_VALUE
2fee			 
2fee					if DEBUG_FORTH_WORDS 
2fee						DMARK "+2v" 
2fee f5				push af  
2fef 3a 03 30			ld a, (.dmark)  
2ff2 32 6e fe			ld (debug_mark),a  
2ff5 3a 04 30			ld a, (.dmark+1)  
2ff8 32 6f fe			ld (debug_mark+1),a  
2ffb 3a 05 30			ld a, (.dmark+2)  
2ffe 32 70 fe			ld (debug_mark+2),a  
3001 18 03			jr .pastdmark  
3003 ..			.dmark: db "+2v"  
3006 f1			.pastdmark: pop af  
3007			endm  
# End of macro DMARK
3007						CALLMONITOR 
3007 cd ab 18			call break_point_state  
300a				endm  
# End of macro CALLMONITOR
300a					endif 
300a			 
300a 19					add hl, de 
300b			 
300b					if DEBUG_FORTH_WORDS 
300b						DMARK "+2+" 
300b f5				push af  
300c 3a 20 30			ld a, (.dmark)  
300f 32 6e fe			ld (debug_mark),a  
3012 3a 21 30			ld a, (.dmark+1)  
3015 32 6f fe			ld (debug_mark+1),a  
3018 3a 22 30			ld a, (.dmark+2)  
301b 32 70 fe			ld (debug_mark+2),a  
301e 18 03			jr .pastdmark  
3020 ..			.dmark: db "+2+"  
3023 f1			.pastdmark: pop af  
3024			endm  
# End of macro DMARK
3024						CALLMONITOR 
3024 cd ab 18			call break_point_state  
3027				endm  
# End of macro CALLMONITOR
3027					endif 
3027			 
3027					; move result to de 
3027			 
3027 eb					ex de, hl 
3028			 
3028					; Address 
3028			 
3028 e1					pop hl 
3029			 
3029					; save it back 
3029			 
3029 73					ld (hl), e 
302a 23					inc hl 
302b 72					ld (hl), d 
302c			 
302c					if DEBUG_FORTH_WORDS 
302c						DMARK "+2e" 
302c f5				push af  
302d 3a 41 30			ld a, (.dmark)  
3030 32 6e fe			ld (debug_mark),a  
3033 3a 42 30			ld a, (.dmark+1)  
3036 32 6f fe			ld (debug_mark+1),a  
3039 3a 43 30			ld a, (.dmark+2)  
303c 32 70 fe			ld (debug_mark+2),a  
303f 18 03			jr .pastdmark  
3041 ..			.dmark: db "+2e"  
3044 f1			.pastdmark: pop af  
3045			endm  
# End of macro DMARK
3045						CALLMONITOR 
3045 cd ab 18			call break_point_state  
3048				endm  
# End of macro CALLMONITOR
3048					endif 
3048			 
3048			 
3048			 
3048			 
3048			 
3048				       NEXTW 
3048 c3 8d 22			jp macro_next 
304b				endm 
# End of macro NEXTW
304b			 
304b			.DEC2: 
304b				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
304b 6f				db WORD_SYS_CORE+91             
304c f7 30			dw .GET2            
304e 04				db 3 + 1 
304f .. 00			db "-2!",0              
3053				endm 
# End of macro CWHEAD
3053			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
3053			 
3053			 
3053					if DEBUG_FORTH_WORDS_KEY 
3053						DMARK "-2s" 
3053 f5				push af  
3054 3a 68 30			ld a, (.dmark)  
3057 32 6e fe			ld (debug_mark),a  
305a 3a 69 30			ld a, (.dmark+1)  
305d 32 6f fe			ld (debug_mark+1),a  
3060 3a 6a 30			ld a, (.dmark+2)  
3063 32 70 fe			ld (debug_mark+2),a  
3066 18 03			jr .pastdmark  
3068 ..			.dmark: db "-2s"  
306b f1			.pastdmark: pop af  
306c			endm  
# End of macro DMARK
306c						CALLMONITOR 
306c cd ab 18			call break_point_state  
306f				endm  
# End of macro CALLMONITOR
306f					endif 
306f			 
306f					; Address 
306f			 
306f					FORTH_DSP_VALUEHL 
306f cd 16 21			call macro_dsp_valuehl 
3072				endm 
# End of macro FORTH_DSP_VALUEHL
3072			 
3072 e5					push hl    ; save address 
3073			 
3073					; load content into de 
3073			 
3073 5e					ld e,(hl) 
3074 23					inc hl 
3075 56					ld d, (hl) 
3076			 
3076					if DEBUG_FORTH_WORDS 
3076						DMARK "-2a" 
3076 f5				push af  
3077 3a 8b 30			ld a, (.dmark)  
307a 32 6e fe			ld (debug_mark),a  
307d 3a 8c 30			ld a, (.dmark+1)  
3080 32 6f fe			ld (debug_mark+1),a  
3083 3a 8d 30			ld a, (.dmark+2)  
3086 32 70 fe			ld (debug_mark+2),a  
3089 18 03			jr .pastdmark  
308b ..			.dmark: db "-2a"  
308e f1			.pastdmark: pop af  
308f			endm  
# End of macro DMARK
308f						CALLMONITOR 
308f cd ab 18			call break_point_state  
3092				endm  
# End of macro CALLMONITOR
3092					endif 
3092			 
3092					FORTH_DSP_POP 
3092 cd ce 21			call macro_forth_dsp_pop 
3095				endm 
# End of macro FORTH_DSP_POP
3095			 
3095					; Get value to remove 
3095			 
3095					FORTH_DSP_VALUE 
3095 cd ff 20			call macro_forth_dsp_value 
3098				endm 
# End of macro FORTH_DSP_VALUE
3098			 
3098					if DEBUG_FORTH_WORDS 
3098						DMARK "-2v" 
3098 f5				push af  
3099 3a ad 30			ld a, (.dmark)  
309c 32 6e fe			ld (debug_mark),a  
309f 3a ae 30			ld a, (.dmark+1)  
30a2 32 6f fe			ld (debug_mark+1),a  
30a5 3a af 30			ld a, (.dmark+2)  
30a8 32 70 fe			ld (debug_mark+2),a  
30ab 18 03			jr .pastdmark  
30ad ..			.dmark: db "-2v"  
30b0 f1			.pastdmark: pop af  
30b1			endm  
# End of macro DMARK
30b1						CALLMONITOR 
30b1 cd ab 18			call break_point_state  
30b4				endm  
# End of macro CALLMONITOR
30b4					endif 
30b4			 
30b4 eb					ex de, hl 
30b5 ed 52				sbc hl, de 
30b7			 
30b7					if DEBUG_FORTH_WORDS 
30b7						DMARK "-2d" 
30b7 f5				push af  
30b8 3a cc 30			ld a, (.dmark)  
30bb 32 6e fe			ld (debug_mark),a  
30be 3a cd 30			ld a, (.dmark+1)  
30c1 32 6f fe			ld (debug_mark+1),a  
30c4 3a ce 30			ld a, (.dmark+2)  
30c7 32 70 fe			ld (debug_mark+2),a  
30ca 18 03			jr .pastdmark  
30cc ..			.dmark: db "-2d"  
30cf f1			.pastdmark: pop af  
30d0			endm  
# End of macro DMARK
30d0						CALLMONITOR 
30d0 cd ab 18			call break_point_state  
30d3				endm  
# End of macro CALLMONITOR
30d3					endif 
30d3			 
30d3					; move result to de 
30d3			 
30d3 eb					ex de, hl 
30d4			 
30d4					; Address 
30d4			 
30d4 e1					pop hl 
30d5			 
30d5					; save it back 
30d5			 
30d5 73					ld (hl), e 
30d6 23					inc hl 
30d7 72					ld (hl), d 
30d8			 
30d8					if DEBUG_FORTH_WORDS 
30d8						DMARK "-2e" 
30d8 f5				push af  
30d9 3a ed 30			ld a, (.dmark)  
30dc 32 6e fe			ld (debug_mark),a  
30df 3a ee 30			ld a, (.dmark+1)  
30e2 32 6f fe			ld (debug_mark+1),a  
30e5 3a ef 30			ld a, (.dmark+2)  
30e8 32 70 fe			ld (debug_mark+2),a  
30eb 18 03			jr .pastdmark  
30ed ..			.dmark: db "-2e"  
30f0 f1			.pastdmark: pop af  
30f1			endm  
# End of macro DMARK
30f1						CALLMONITOR 
30f1 cd ab 18			call break_point_state  
30f4				endm  
# End of macro CALLMONITOR
30f4					endif 
30f4			 
30f4			 
30f4			 
30f4			 
30f4			 
30f4				       NEXTW 
30f4 c3 8d 22			jp macro_next 
30f7				endm 
# End of macro NEXTW
30f7			.GET2: 
30f7				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
30f7 6f				db WORD_SYS_CORE+91             
30f8 27 31			dw .BANG2            
30fa 03				db 2 + 1 
30fb .. 00			db "2@",0              
30fe				endm 
# End of macro CWHEAD
30fe			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
30fe					if DEBUG_FORTH_WORDS_KEY 
30fe						DMARK "2A_" 
30fe f5				push af  
30ff 3a 13 31			ld a, (.dmark)  
3102 32 6e fe			ld (debug_mark),a  
3105 3a 14 31			ld a, (.dmark+1)  
3108 32 6f fe			ld (debug_mark+1),a  
310b 3a 15 31			ld a, (.dmark+2)  
310e 32 70 fe			ld (debug_mark+2),a  
3111 18 03			jr .pastdmark  
3113 ..			.dmark: db "2A_"  
3116 f1			.pastdmark: pop af  
3117			endm  
# End of macro DMARK
3117						CALLMONITOR 
3117 cd ab 18			call break_point_state  
311a				endm  
# End of macro CALLMONITOR
311a					endif 
311a			 
311a					FORTH_DSP_VALUEHL 
311a cd 16 21			call macro_dsp_valuehl 
311d				endm 
# End of macro FORTH_DSP_VALUEHL
311d			 
311d 5e					ld e, (hl) 
311e 23					inc hl 
311f 56					ld d, (hl) 
3120			 
3120 eb					ex de, hl 
3121			 
3121 cd 1f 1f				call forth_push_numhl 
3124			 
3124				       NEXTW 
3124 c3 8d 22			jp macro_next 
3127				endm 
# End of macro NEXTW
3127			.BANG2: 
3127				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
3127 6f				db WORD_SYS_CORE+91             
3128 5f 31			dw .CONFIG            
312a 03				db 2 + 1 
312b .. 00			db "2!",0              
312e				endm 
# End of macro CWHEAD
312e			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
312e					if DEBUG_FORTH_WORDS_KEY 
312e						DMARK "2S_" 
312e f5				push af  
312f 3a 43 31			ld a, (.dmark)  
3132 32 6e fe			ld (debug_mark),a  
3135 3a 44 31			ld a, (.dmark+1)  
3138 32 6f fe			ld (debug_mark+1),a  
313b 3a 45 31			ld a, (.dmark+2)  
313e 32 70 fe			ld (debug_mark+2),a  
3141 18 03			jr .pastdmark  
3143 ..			.dmark: db "2S_"  
3146 f1			.pastdmark: pop af  
3147			endm  
# End of macro DMARK
3147						CALLMONITOR 
3147 cd ab 18			call break_point_state  
314a				endm  
# End of macro CALLMONITOR
314a					endif 
314a			 
314a					FORTH_DSP_VALUEHL 
314a cd 16 21			call macro_dsp_valuehl 
314d				endm 
# End of macro FORTH_DSP_VALUEHL
314d			 
314d e5					push hl   ; save address 
314e			 
314e			 
314e					FORTH_DSP_POP 
314e cd ce 21			call macro_forth_dsp_pop 
3151				endm 
# End of macro FORTH_DSP_POP
3151			 
3151					 
3151					FORTH_DSP_VALUEHL 
3151 cd 16 21			call macro_dsp_valuehl 
3154				endm 
# End of macro FORTH_DSP_VALUEHL
3154			 
3154					FORTH_DSP_POP 
3154 cd ce 21			call macro_forth_dsp_pop 
3157				endm 
# End of macro FORTH_DSP_POP
3157			 
3157 eb					ex de, hl    ; value now in de 
3158			 
3158 e1					pop hl 
3159			 
3159 73					ld (hl), e 
315a			 
315a 23					inc hl 
315b			 
315b 72					ld (hl), d 
315c			 
315c			 
315c				       NEXTW 
315c c3 8d 22			jp macro_next 
315f				endm 
# End of macro NEXTW
315f			.CONFIG: 
315f				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
315f 6f				db WORD_SYS_CORE+91             
3160 70 31			dw .ENDCORE            
3162 07				db 6 + 1 
3163 .. 00			db "CONFIG",0              
316a				endm 
# End of macro CWHEAD
316a			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
316a			 
316a cd 8e 15				call config 
316d					NEXTW 
316d c3 8d 22			jp macro_next 
3170				endm 
# End of macro NEXTW
3170			.ENDCORE: 
3170			 
3170			; eof 
3170			 
3170			 
# End of file forth_words_core.asm
3170			include "forth_words_flow.asm" 
3170			 
3170			; | ## Program Flow Words 
3170			 
3170			.IF: 
3170				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
3170 1e				db WORD_SYS_CORE+10             
3171 65 32			dw .THEN            
3173 03				db 2 + 1 
3174 .. 00			db "IF",0              
3177				endm 
# End of macro CWHEAD
3177			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
3177			; 
3177					if DEBUG_FORTH_WORDS_KEY 
3177						DMARK "IF." 
3177 f5				push af  
3178 3a 8c 31			ld a, (.dmark)  
317b 32 6e fe			ld (debug_mark),a  
317e 3a 8d 31			ld a, (.dmark+1)  
3181 32 6f fe			ld (debug_mark+1),a  
3184 3a 8e 31			ld a, (.dmark+2)  
3187 32 70 fe			ld (debug_mark+2),a  
318a 18 03			jr .pastdmark  
318c ..			.dmark: db "IF."  
318f f1			.pastdmark: pop af  
3190			endm  
# End of macro DMARK
3190						CALLMONITOR 
3190 cd ab 18			call break_point_state  
3193				endm  
# End of macro CALLMONITOR
3193					endif 
3193			; eval TOS 
3193			 
3193				FORTH_DSP_VALUEHL 
3193 cd 16 21			call macro_dsp_valuehl 
3196				endm 
# End of macro FORTH_DSP_VALUEHL
3196			 
3196			;	push hl 
3196				FORTH_DSP_POP 
3196 cd ce 21			call macro_forth_dsp_pop 
3199				endm 
# End of macro FORTH_DSP_POP
3199			;	pop hl 
3199			 
3199					if DEBUG_FORTH_WORDS 
3199						DMARK "IF1" 
3199 f5				push af  
319a 3a ae 31			ld a, (.dmark)  
319d 32 6e fe			ld (debug_mark),a  
31a0 3a af 31			ld a, (.dmark+1)  
31a3 32 6f fe			ld (debug_mark+1),a  
31a6 3a b0 31			ld a, (.dmark+2)  
31a9 32 70 fe			ld (debug_mark+2),a  
31ac 18 03			jr .pastdmark  
31ae ..			.dmark: db "IF1"  
31b1 f1			.pastdmark: pop af  
31b2			endm  
# End of macro DMARK
31b2						CALLMONITOR 
31b2 cd ab 18			call break_point_state  
31b5				endm  
# End of macro CALLMONITOR
31b5					endif 
31b5 b7				or a        ; clear carry flag 
31b6 11 00 00			ld de, 0 
31b9 eb				ex de,hl 
31ba ed 52			sbc hl, de 
31bc c2 46 32			jp nz, .iftrue 
31bf			 
31bf					if DEBUG_FORTH_WORDS 
31bf						DMARK "IF2" 
31bf f5				push af  
31c0 3a d4 31			ld a, (.dmark)  
31c3 32 6e fe			ld (debug_mark),a  
31c6 3a d5 31			ld a, (.dmark+1)  
31c9 32 6f fe			ld (debug_mark+1),a  
31cc 3a d6 31			ld a, (.dmark+2)  
31cf 32 70 fe			ld (debug_mark+2),a  
31d2 18 03			jr .pastdmark  
31d4 ..			.dmark: db "IF2"  
31d7 f1			.pastdmark: pop af  
31d8			endm  
# End of macro DMARK
31d8						CALLMONITOR 
31d8 cd ab 18			call break_point_state  
31db				endm  
# End of macro CALLMONITOR
31db					endif 
31db			 
31db			; if not true then skip to THEN 
31db			 
31db				; TODO get tok_ptr 
31db				; TODO consume toks until we get to THEN 
31db			 
31db 2a fe f4			ld hl, (os_tok_ptr) 
31de					if DEBUG_FORTH_WORDS 
31de						DMARK "IF3" 
31de f5				push af  
31df 3a f3 31			ld a, (.dmark)  
31e2 32 6e fe			ld (debug_mark),a  
31e5 3a f4 31			ld a, (.dmark+1)  
31e8 32 6f fe			ld (debug_mark+1),a  
31eb 3a f5 31			ld a, (.dmark+2)  
31ee 32 70 fe			ld (debug_mark+2),a  
31f1 18 03			jr .pastdmark  
31f3 ..			.dmark: db "IF3"  
31f6 f1			.pastdmark: pop af  
31f7			endm  
# End of macro DMARK
31f7						CALLMONITOR 
31f7 cd ab 18			call break_point_state  
31fa				endm  
# End of macro CALLMONITOR
31fa						 
31fa					endif 
31fa 11 41 32			ld de, .ifthen 
31fd					if DEBUG_FORTH_WORDS 
31fd						DMARK "IF4" 
31fd f5				push af  
31fe 3a 12 32			ld a, (.dmark)  
3201 32 6e fe			ld (debug_mark),a  
3204 3a 13 32			ld a, (.dmark+1)  
3207 32 6f fe			ld (debug_mark+1),a  
320a 3a 14 32			ld a, (.dmark+2)  
320d 32 70 fe			ld (debug_mark+2),a  
3210 18 03			jr .pastdmark  
3212 ..			.dmark: db "IF4"  
3215 f1			.pastdmark: pop af  
3216			endm  
# End of macro DMARK
3216						CALLMONITOR 
3216 cd ab 18			call break_point_state  
3219				endm  
# End of macro CALLMONITOR
3219					endif 
3219 cd a8 23			call findnexttok  
321c			 
321c					if DEBUG_FORTH_WORDS 
321c						DMARK "IF5" 
321c f5				push af  
321d 3a 31 32			ld a, (.dmark)  
3220 32 6e fe			ld (debug_mark),a  
3223 3a 32 32			ld a, (.dmark+1)  
3226 32 6f fe			ld (debug_mark+1),a  
3229 3a 33 32			ld a, (.dmark+2)  
322c 32 70 fe			ld (debug_mark+2),a  
322f 18 03			jr .pastdmark  
3231 ..			.dmark: db "IF5"  
3234 f1			.pastdmark: pop af  
3235			endm  
# End of macro DMARK
3235						CALLMONITOR 
3235 cd ab 18			call break_point_state  
3238				endm  
# End of macro CALLMONITOR
3238					endif 
3238				; TODO replace below with ; exec using tok_ptr 
3238 22 fe f4			ld (os_tok_ptr), hl 
323b c3 1e 23			jp exec1 
323e				NEXTW 
323e c3 8d 22			jp macro_next 
3241				endm 
# End of macro NEXTW
3241			 
3241 .. 00		.ifthen:  db "THEN",0 
3246			 
3246			.iftrue:		 
3246				; Exec next words normally 
3246			 
3246				; if true then exec following IF as normal 
3246					if DEBUG_FORTH_WORDS 
3246						DMARK "IFT" 
3246 f5				push af  
3247 3a 5b 32			ld a, (.dmark)  
324a 32 6e fe			ld (debug_mark),a  
324d 3a 5c 32			ld a, (.dmark+1)  
3250 32 6f fe			ld (debug_mark+1),a  
3253 3a 5d 32			ld a, (.dmark+2)  
3256 32 70 fe			ld (debug_mark+2),a  
3259 18 03			jr .pastdmark  
325b ..			.dmark: db "IFT"  
325e f1			.pastdmark: pop af  
325f			endm  
# End of macro DMARK
325f						CALLMONITOR 
325f cd ab 18			call break_point_state  
3262				endm  
# End of macro CALLMONITOR
3262					endif 
3262			 
3262					NEXTW 
3262 c3 8d 22			jp macro_next 
3265				endm 
# End of macro NEXTW
3265			.THEN: 
3265				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
3265 1f				db WORD_SYS_CORE+11             
3266 8d 32			dw .ELSE            
3268 05				db 4 + 1 
3269 .. 00			db "THEN",0              
326e				endm 
# End of macro CWHEAD
326e			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
326e					if DEBUG_FORTH_WORDS_KEY 
326e						DMARK "THN" 
326e f5				push af  
326f 3a 83 32			ld a, (.dmark)  
3272 32 6e fe			ld (debug_mark),a  
3275 3a 84 32			ld a, (.dmark+1)  
3278 32 6f fe			ld (debug_mark+1),a  
327b 3a 85 32			ld a, (.dmark+2)  
327e 32 70 fe			ld (debug_mark+2),a  
3281 18 03			jr .pastdmark  
3283 ..			.dmark: db "THN"  
3286 f1			.pastdmark: pop af  
3287			endm  
# End of macro DMARK
3287						CALLMONITOR 
3287 cd ab 18			call break_point_state  
328a				endm  
# End of macro CALLMONITOR
328a					endif 
328a					NEXTW 
328a c3 8d 22			jp macro_next 
328d				endm 
# End of macro NEXTW
328d			.ELSE: 
328d				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
328d 20				db WORD_SYS_CORE+12             
328e b5 32			dw .DO            
3290 03				db 2 + 1 
3291 .. 00			db "ELSE",0              
3296				endm 
# End of macro CWHEAD
3296			; | ELSE ( -- ) Not supported - does nothing | TODO 
3296			 
3296					if DEBUG_FORTH_WORDS_KEY 
3296						DMARK "ELS" 
3296 f5				push af  
3297 3a ab 32			ld a, (.dmark)  
329a 32 6e fe			ld (debug_mark),a  
329d 3a ac 32			ld a, (.dmark+1)  
32a0 32 6f fe			ld (debug_mark+1),a  
32a3 3a ad 32			ld a, (.dmark+2)  
32a6 32 70 fe			ld (debug_mark+2),a  
32a9 18 03			jr .pastdmark  
32ab ..			.dmark: db "ELS"  
32ae f1			.pastdmark: pop af  
32af			endm  
# End of macro DMARK
32af						CALLMONITOR 
32af cd ab 18			call break_point_state  
32b2				endm  
# End of macro CALLMONITOR
32b2					endif 
32b2			 
32b2			 
32b2					NEXTW 
32b2 c3 8d 22			jp macro_next 
32b5				endm 
# End of macro NEXTW
32b5			.DO: 
32b5				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
32b5 21				db WORD_SYS_CORE+13             
32b6 dc 33			dw .LOOP            
32b8 03				db 2 + 1 
32b9 .. 00			db "DO",0              
32bc				endm 
# End of macro CWHEAD
32bc			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
32bc			 
32bc					if DEBUG_FORTH_WORDS_KEY 
32bc						DMARK "DO." 
32bc f5				push af  
32bd 3a d1 32			ld a, (.dmark)  
32c0 32 6e fe			ld (debug_mark),a  
32c3 3a d2 32			ld a, (.dmark+1)  
32c6 32 6f fe			ld (debug_mark+1),a  
32c9 3a d3 32			ld a, (.dmark+2)  
32cc 32 70 fe			ld (debug_mark+2),a  
32cf 18 03			jr .pastdmark  
32d1 ..			.dmark: db "DO."  
32d4 f1			.pastdmark: pop af  
32d5			endm  
# End of macro DMARK
32d5						CALLMONITOR 
32d5 cd ab 18			call break_point_state  
32d8				endm  
# End of macro CALLMONITOR
32d8					endif 
32d8			;  push pc to rsp stack past the DO 
32d8			 
32d8 2a fe f4				ld hl, (os_tok_ptr) 
32db 23					inc hl   ; D 
32dc 23					inc hl  ; O 
32dd 23					inc hl   ; null 
32de					if DEBUG_FORTH_WORDS 
32de						DMARK "DO2" 
32de f5				push af  
32df 3a f3 32			ld a, (.dmark)  
32e2 32 6e fe			ld (debug_mark),a  
32e5 3a f4 32			ld a, (.dmark+1)  
32e8 32 6f fe			ld (debug_mark+1),a  
32eb 3a f5 32			ld a, (.dmark+2)  
32ee 32 70 fe			ld (debug_mark+2),a  
32f1 18 03			jr .pastdmark  
32f3 ..			.dmark: db "DO2"  
32f6 f1			.pastdmark: pop af  
32f7			endm  
# End of macro DMARK
32f7						CALLMONITOR 
32f7 cd ab 18			call break_point_state  
32fa				endm  
# End of macro CALLMONITOR
32fa					endif 
32fa					FORTH_RSP_NEXT 
32fa cd c6 1e			call macro_forth_rsp_next 
32fd				endm 
# End of macro FORTH_RSP_NEXT
32fd					if DEBUG_FORTH_WORDS 
32fd						DMARK "DO3" 
32fd f5				push af  
32fe 3a 12 33			ld a, (.dmark)  
3301 32 6e fe			ld (debug_mark),a  
3304 3a 13 33			ld a, (.dmark+1)  
3307 32 6f fe			ld (debug_mark+1),a  
330a 3a 14 33			ld a, (.dmark+2)  
330d 32 70 fe			ld (debug_mark+2),a  
3310 18 03			jr .pastdmark  
3312 ..			.dmark: db "DO3"  
3315 f1			.pastdmark: pop af  
3316			endm  
# End of macro DMARK
3316						CALLMONITOR 
3316 cd ab 18			call break_point_state  
3319				endm  
# End of macro CALLMONITOR
3319					endif 
3319			 
3319					;if DEBUG_FORTH_WORDS 
3319				;		push hl 
3319			;		endif  
3319			 
3319			; get counters from data stack 
3319			 
3319			 
3319					FORTH_DSP_VALUEHL 
3319 cd 16 21			call macro_dsp_valuehl 
331c				endm 
# End of macro FORTH_DSP_VALUEHL
331c e5					push hl		 ; hl now has starting counter which needs to be tos 
331d			 
331d					if DEBUG_FORTH_WORDS 
331d						DMARK "DO4" 
331d f5				push af  
331e 3a 32 33			ld a, (.dmark)  
3321 32 6e fe			ld (debug_mark),a  
3324 3a 33 33			ld a, (.dmark+1)  
3327 32 6f fe			ld (debug_mark+1),a  
332a 3a 34 33			ld a, (.dmark+2)  
332d 32 70 fe			ld (debug_mark+2),a  
3330 18 03			jr .pastdmark  
3332 ..			.dmark: db "DO4"  
3335 f1			.pastdmark: pop af  
3336			endm  
# End of macro DMARK
3336						CALLMONITOR 
3336 cd ab 18			call break_point_state  
3339				endm  
# End of macro CALLMONITOR
3339					endif 
3339					FORTH_DSP_POP 
3339 cd ce 21			call macro_forth_dsp_pop 
333c				endm 
# End of macro FORTH_DSP_POP
333c			 
333c					if DEBUG_FORTH_WORDS 
333c						DMARK "DO5" 
333c f5				push af  
333d 3a 51 33			ld a, (.dmark)  
3340 32 6e fe			ld (debug_mark),a  
3343 3a 52 33			ld a, (.dmark+1)  
3346 32 6f fe			ld (debug_mark+1),a  
3349 3a 53 33			ld a, (.dmark+2)  
334c 32 70 fe			ld (debug_mark+2),a  
334f 18 03			jr .pastdmark  
3351 ..			.dmark: db "DO5"  
3354 f1			.pastdmark: pop af  
3355			endm  
# End of macro DMARK
3355						CALLMONITOR 
3355 cd ab 18			call break_point_state  
3358				endm  
# End of macro CALLMONITOR
3358					endif 
3358			 
3358					FORTH_DSP_VALUEHL 
3358 cd 16 21			call macro_dsp_valuehl 
335b				endm 
# End of macro FORTH_DSP_VALUEHL
335b			;		push hl		 ; hl now has starting limit counter 
335b			 
335b					if DEBUG_FORTH_WORDS 
335b						DMARK "DO6" 
335b f5				push af  
335c 3a 70 33			ld a, (.dmark)  
335f 32 6e fe			ld (debug_mark),a  
3362 3a 71 33			ld a, (.dmark+1)  
3365 32 6f fe			ld (debug_mark+1),a  
3368 3a 72 33			ld a, (.dmark+2)  
336b 32 70 fe			ld (debug_mark+2),a  
336e 18 03			jr .pastdmark  
3370 ..			.dmark: db "DO6"  
3373 f1			.pastdmark: pop af  
3374			endm  
# End of macro DMARK
3374						CALLMONITOR 
3374 cd ab 18			call break_point_state  
3377				endm  
# End of macro CALLMONITOR
3377					endif 
3377					FORTH_DSP_POP 
3377 cd ce 21			call macro_forth_dsp_pop 
337a				endm 
# End of macro FORTH_DSP_POP
337a			 
337a			; put counters on the loop stack 
337a			 
337a			;		pop hl			 ; limit counter 
337a d1					pop de			; start counter 
337b			 
337b					; push limit counter 
337b			 
337b					if DEBUG_FORTH_WORDS 
337b						DMARK "DO7" 
337b f5				push af  
337c 3a 90 33			ld a, (.dmark)  
337f 32 6e fe			ld (debug_mark),a  
3382 3a 91 33			ld a, (.dmark+1)  
3385 32 6f fe			ld (debug_mark+1),a  
3388 3a 92 33			ld a, (.dmark+2)  
338b 32 70 fe			ld (debug_mark+2),a  
338e 18 03			jr .pastdmark  
3390 ..			.dmark: db "DO7"  
3393 f1			.pastdmark: pop af  
3394			endm  
# End of macro DMARK
3394						CALLMONITOR 
3394 cd ab 18			call break_point_state  
3397				endm  
# End of macro CALLMONITOR
3397					endif 
3397					FORTH_LOOP_NEXT 
3397 cd 47 21			call macro_forth_loop_next 
339a				endm 
# End of macro FORTH_LOOP_NEXT
339a			 
339a					; push start counter 
339a			 
339a eb					ex de, hl 
339b					if DEBUG_FORTH_WORDS 
339b						DMARK "DO7" 
339b f5				push af  
339c 3a b0 33			ld a, (.dmark)  
339f 32 6e fe			ld (debug_mark),a  
33a2 3a b1 33			ld a, (.dmark+1)  
33a5 32 6f fe			ld (debug_mark+1),a  
33a8 3a b2 33			ld a, (.dmark+2)  
33ab 32 70 fe			ld (debug_mark+2),a  
33ae 18 03			jr .pastdmark  
33b0 ..			.dmark: db "DO7"  
33b3 f1			.pastdmark: pop af  
33b4			endm  
# End of macro DMARK
33b4						CALLMONITOR 
33b4 cd ab 18			call break_point_state  
33b7				endm  
# End of macro CALLMONITOR
33b7					endif 
33b7					FORTH_LOOP_NEXT 
33b7 cd 47 21			call macro_forth_loop_next 
33ba				endm 
# End of macro FORTH_LOOP_NEXT
33ba			 
33ba			 
33ba					; init first round of I counter 
33ba			 
33ba 22 22 f5				ld (os_current_i), hl 
33bd			 
33bd					if DEBUG_FORTH_WORDS 
33bd						DMARK "DO8" 
33bd f5				push af  
33be 3a d2 33			ld a, (.dmark)  
33c1 32 6e fe			ld (debug_mark),a  
33c4 3a d3 33			ld a, (.dmark+1)  
33c7 32 6f fe			ld (debug_mark+1),a  
33ca 3a d4 33			ld a, (.dmark+2)  
33cd 32 70 fe			ld (debug_mark+2),a  
33d0 18 03			jr .pastdmark  
33d2 ..			.dmark: db "DO8"  
33d5 f1			.pastdmark: pop af  
33d6			endm  
# End of macro DMARK
33d6						CALLMONITOR 
33d6 cd ab 18			call break_point_state  
33d9				endm  
# End of macro CALLMONITOR
33d9					endif 
33d9			 
33d9					NEXTW 
33d9 c3 8d 22			jp macro_next 
33dc				endm 
# End of macro NEXTW
33dc			.LOOP: 
33dc				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
33dc 22				db WORD_SYS_CORE+14             
33dd f4 34			dw .I            
33df 05				db 4 + 1 
33e0 .. 00			db "LOOP",0              
33e5				endm 
# End of macro CWHEAD
33e5			; | LOOP ( -- ) Increment and test loop counter  | DONE 
33e5			 
33e5				; pop tos as current loop count to hl 
33e5			 
33e5				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
33e5			 
33e5				FORTH_LOOP_TOS 
33e5 cd 7a 21			call macro_forth_loop_tos 
33e8				endm 
# End of macro FORTH_LOOP_TOS
33e8 e5				push hl 
33e9			 
33e9					if DEBUG_FORTH_WORDS_KEY 
33e9						DMARK "LOP" 
33e9 f5				push af  
33ea 3a fe 33			ld a, (.dmark)  
33ed 32 6e fe			ld (debug_mark),a  
33f0 3a ff 33			ld a, (.dmark+1)  
33f3 32 6f fe			ld (debug_mark+1),a  
33f6 3a 00 34			ld a, (.dmark+2)  
33f9 32 70 fe			ld (debug_mark+2),a  
33fc 18 03			jr .pastdmark  
33fe ..			.dmark: db "LOP"  
3401 f1			.pastdmark: pop af  
3402			endm  
# End of macro DMARK
3402						CALLMONITOR 
3402 cd ab 18			call break_point_state  
3405				endm  
# End of macro CALLMONITOR
3405					endif 
3405				; next item on the stack is the limit. get it 
3405			 
3405			 
3405				FORTH_LOOP_POP 
3405 cd 84 21			call macro_forth_loop_pop 
3408				endm 
# End of macro FORTH_LOOP_POP
3408			 
3408				FORTH_LOOP_TOS 
3408 cd 7a 21			call macro_forth_loop_tos 
340b				endm 
# End of macro FORTH_LOOP_TOS
340b			 
340b d1				pop de		 ; de = i, hl = limit 
340c			 
340c					if DEBUG_FORTH_WORDS 
340c						DMARK "LP1" 
340c f5				push af  
340d 3a 21 34			ld a, (.dmark)  
3410 32 6e fe			ld (debug_mark),a  
3413 3a 22 34			ld a, (.dmark+1)  
3416 32 6f fe			ld (debug_mark+1),a  
3419 3a 23 34			ld a, (.dmark+2)  
341c 32 70 fe			ld (debug_mark+2),a  
341f 18 03			jr .pastdmark  
3421 ..			.dmark: db "LP1"  
3424 f1			.pastdmark: pop af  
3425			endm  
# End of macro DMARK
3425						CALLMONITOR 
3425 cd ab 18			call break_point_state  
3428				endm  
# End of macro CALLMONITOR
3428					endif 
3428			 
3428				; go back to previous word 
3428			 
3428 d5				push de    ; save I for inc later 
3429			 
3429			 
3429				; get limit 
3429				;  is I at limit? 
3429			 
3429			 
3429					if DEBUG_FORTH_WORDS 
3429						DMARK "LP1" 
3429 f5				push af  
342a 3a 3e 34			ld a, (.dmark)  
342d 32 6e fe			ld (debug_mark),a  
3430 3a 3f 34			ld a, (.dmark+1)  
3433 32 6f fe			ld (debug_mark+1),a  
3436 3a 40 34			ld a, (.dmark+2)  
3439 32 70 fe			ld (debug_mark+2),a  
343c 18 03			jr .pastdmark  
343e ..			.dmark: db "LP1"  
3441 f1			.pastdmark: pop af  
3442			endm  
# End of macro DMARK
3442						CALLMONITOR 
3442 cd ab 18			call break_point_state  
3445				endm  
# End of macro CALLMONITOR
3445					endif 
3445			 
3445 ed 52			sbc hl, de 
3447			 
3447			 
3447				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3447			 
3447 20 26				jr nz, .loopnotdone 
3449			 
3449 e1				pop hl   ; get rid of saved I 
344a				FORTH_LOOP_POP     ; get rid of limit 
344a cd 84 21			call macro_forth_loop_pop 
344d				endm 
# End of macro FORTH_LOOP_POP
344d			 
344d				FORTH_RSP_POP     ; get rid of DO ptr 
344d cd e7 1e			call macro_forth_rsp_pop 
3450				endm 
# End of macro FORTH_RSP_POP
3450			 
3450			if DEBUG_FORTH_WORDS 
3450						DMARK "LP>" 
3450 f5				push af  
3451 3a 65 34			ld a, (.dmark)  
3454 32 6e fe			ld (debug_mark),a  
3457 3a 66 34			ld a, (.dmark+1)  
345a 32 6f fe			ld (debug_mark+1),a  
345d 3a 67 34			ld a, (.dmark+2)  
3460 32 70 fe			ld (debug_mark+2),a  
3463 18 03			jr .pastdmark  
3465 ..			.dmark: db "LP>"  
3468 f1			.pastdmark: pop af  
3469			endm  
# End of macro DMARK
3469				CALLMONITOR 
3469 cd ab 18			call break_point_state  
346c				endm  
# End of macro CALLMONITOR
346c			endif 
346c			 
346c					NEXTW 
346c c3 8d 22			jp macro_next 
346f				endm 
# End of macro NEXTW
346f				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
346f			 
346f			.loopnotdone: 
346f			 
346f e1				pop hl    ; get I 
3470 23				inc hl 
3471			 
3471			   	; save new I 
3471			 
3471			 
3471					; set I counter 
3471			 
3471 22 22 f5				ld (os_current_i), hl 
3474			 
3474					if DEBUG_FORTH_WORDS 
3474						DMARK "LPN" 
3474 f5				push af  
3475 3a 89 34			ld a, (.dmark)  
3478 32 6e fe			ld (debug_mark),a  
347b 3a 8a 34			ld a, (.dmark+1)  
347e 32 6f fe			ld (debug_mark+1),a  
3481 3a 8b 34			ld a, (.dmark+2)  
3484 32 70 fe			ld (debug_mark+2),a  
3487 18 03			jr .pastdmark  
3489 ..			.dmark: db "LPN"  
348c f1			.pastdmark: pop af  
348d			endm  
# End of macro DMARK
348d					CALLMONITOR 
348d cd ab 18			call break_point_state  
3490				endm  
# End of macro CALLMONITOR
3490					endif 
3490					 
3490				FORTH_LOOP_NEXT 
3490 cd 47 21			call macro_forth_loop_next 
3493				endm 
# End of macro FORTH_LOOP_NEXT
3493			 
3493			 
3493					if DEBUG_FORTH_WORDS 
3493 eb						ex de,hl 
3494					endif 
3494			 
3494			;	; get DO ptr 
3494			; 
3494					if DEBUG_FORTH_WORDS 
3494						DMARK "LP7" 
3494 f5				push af  
3495 3a a9 34			ld a, (.dmark)  
3498 32 6e fe			ld (debug_mark),a  
349b 3a aa 34			ld a, (.dmark+1)  
349e 32 6f fe			ld (debug_mark+1),a  
34a1 3a ab 34			ld a, (.dmark+2)  
34a4 32 70 fe			ld (debug_mark+2),a  
34a7 18 03			jr .pastdmark  
34a9 ..			.dmark: db "LP7"  
34ac f1			.pastdmark: pop af  
34ad			endm  
# End of macro DMARK
34ad					CALLMONITOR 
34ad cd ab 18			call break_point_state  
34b0				endm  
# End of macro CALLMONITOR
34b0					endif 
34b0				FORTH_RSP_TOS 
34b0 cd dd 1e			call macro_forth_rsp_tos 
34b3				endm 
# End of macro FORTH_RSP_TOS
34b3			 
34b3					if DEBUG_FORTH_WORDS 
34b3						DMARK "LP8" 
34b3 f5				push af  
34b4 3a c8 34			ld a, (.dmark)  
34b7 32 6e fe			ld (debug_mark),a  
34ba 3a c9 34			ld a, (.dmark+1)  
34bd 32 6f fe			ld (debug_mark+1),a  
34c0 3a ca 34			ld a, (.dmark+2)  
34c3 32 70 fe			ld (debug_mark+2),a  
34c6 18 03			jr .pastdmark  
34c8 ..			.dmark: db "LP8"  
34cb f1			.pastdmark: pop af  
34cc			endm  
# End of macro DMARK
34cc					CALLMONITOR 
34cc cd ab 18			call break_point_state  
34cf				endm  
# End of macro CALLMONITOR
34cf					endif 
34cf				;push hl 
34cf			 
34cf				; not going to DO any more 
34cf				; get rid of the RSP pointer as DO will add it back in 
34cf				;FORTH_RSP_POP 
34cf				;pop hl 
34cf			 
34cf				;ld hl,(cli_ret_sp) 
34cf				;ld e, (hl) 
34cf				;inc hl 
34cf				;ld d, (hl) 
34cf				;ex de,hl 
34cf 22 fe f4			ld (os_tok_ptr), hl 
34d2					if DEBUG_FORTH_WORDS 
34d2						DMARK "LP<" 
34d2 f5				push af  
34d3 3a e7 34			ld a, (.dmark)  
34d6 32 6e fe			ld (debug_mark),a  
34d9 3a e8 34			ld a, (.dmark+1)  
34dc 32 6f fe			ld (debug_mark+1),a  
34df 3a e9 34			ld a, (.dmark+2)  
34e2 32 70 fe			ld (debug_mark+2),a  
34e5 18 03			jr .pastdmark  
34e7 ..			.dmark: db "LP<"  
34ea f1			.pastdmark: pop af  
34eb			endm  
# End of macro DMARK
34eb					CALLMONITOR 
34eb cd ab 18			call break_point_state  
34ee				endm  
# End of macro CALLMONITOR
34ee				endif 
34ee c3 1e 23			jp exec1 
34f1			 
34f1					 
34f1			 
34f1			 
34f1					NEXTW 
34f1 c3 8d 22			jp macro_next 
34f4				endm 
# End of macro NEXTW
34f4			.I:  
34f4			 
34f4				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
34f4 5e				db WORD_SYS_CORE+74             
34f5 1f 35			dw .DLOOP            
34f7 02				db 1 + 1 
34f8 .. 00			db "I",0              
34fa				endm 
# End of macro CWHEAD
34fa			; | I ( -- ) Current loop counter | DONE 
34fa					if DEBUG_FORTH_WORDS_KEY 
34fa						DMARK "I.." 
34fa f5				push af  
34fb 3a 0f 35			ld a, (.dmark)  
34fe 32 6e fe			ld (debug_mark),a  
3501 3a 10 35			ld a, (.dmark+1)  
3504 32 6f fe			ld (debug_mark+1),a  
3507 3a 11 35			ld a, (.dmark+2)  
350a 32 70 fe			ld (debug_mark+2),a  
350d 18 03			jr .pastdmark  
350f ..			.dmark: db "I.."  
3512 f1			.pastdmark: pop af  
3513			endm  
# End of macro DMARK
3513						CALLMONITOR 
3513 cd ab 18			call break_point_state  
3516				endm  
# End of macro CALLMONITOR
3516					endif 
3516			 
3516 2a 22 f5				ld hl,(os_current_i) 
3519 cd 1f 1f				call forth_push_numhl 
351c			 
351c					NEXTW 
351c c3 8d 22			jp macro_next 
351f				endm 
# End of macro NEXTW
351f			.DLOOP: 
351f				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
351f 5f				db WORD_SYS_CORE+75             
3520 00 36			dw .REPEAT            
3522 06				db 5 + 1 
3523 .. 00			db "-LOOP",0              
3529				endm 
# End of macro CWHEAD
3529			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
3529				; pop tos as current loop count to hl 
3529					if DEBUG_FORTH_WORDS_KEY 
3529						DMARK "-LP" 
3529 f5				push af  
352a 3a 3e 35			ld a, (.dmark)  
352d 32 6e fe			ld (debug_mark),a  
3530 3a 3f 35			ld a, (.dmark+1)  
3533 32 6f fe			ld (debug_mark+1),a  
3536 3a 40 35			ld a, (.dmark+2)  
3539 32 70 fe			ld (debug_mark+2),a  
353c 18 03			jr .pastdmark  
353e ..			.dmark: db "-LP"  
3541 f1			.pastdmark: pop af  
3542			endm  
# End of macro DMARK
3542						CALLMONITOR 
3542 cd ab 18			call break_point_state  
3545				endm  
# End of macro CALLMONITOR
3545					endif 
3545			 
3545				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3545			 
3545				FORTH_LOOP_TOS 
3545 cd 7a 21			call macro_forth_loop_tos 
3548				endm 
# End of macro FORTH_LOOP_TOS
3548 e5				push hl 
3549			 
3549					if DEBUG_FORTH_WORDS 
3549						DMARK "-LP" 
3549 f5				push af  
354a 3a 5e 35			ld a, (.dmark)  
354d 32 6e fe			ld (debug_mark),a  
3550 3a 5f 35			ld a, (.dmark+1)  
3553 32 6f fe			ld (debug_mark+1),a  
3556 3a 60 35			ld a, (.dmark+2)  
3559 32 70 fe			ld (debug_mark+2),a  
355c 18 03			jr .pastdmark  
355e ..			.dmark: db "-LP"  
3561 f1			.pastdmark: pop af  
3562			endm  
# End of macro DMARK
3562						CALLMONITOR 
3562 cd ab 18			call break_point_state  
3565				endm  
# End of macro CALLMONITOR
3565					endif 
3565				; next item on the stack is the limit. get it 
3565			 
3565			 
3565				FORTH_LOOP_POP 
3565 cd 84 21			call macro_forth_loop_pop 
3568				endm 
# End of macro FORTH_LOOP_POP
3568			 
3568				FORTH_LOOP_TOS 
3568 cd 7a 21			call macro_forth_loop_tos 
356b				endm 
# End of macro FORTH_LOOP_TOS
356b			 
356b d1				pop de		 ; de = i, hl = limit 
356c			 
356c					if DEBUG_FORTH_WORDS 
356c						DMARK "-L1" 
356c f5				push af  
356d 3a 81 35			ld a, (.dmark)  
3570 32 6e fe			ld (debug_mark),a  
3573 3a 82 35			ld a, (.dmark+1)  
3576 32 6f fe			ld (debug_mark+1),a  
3579 3a 83 35			ld a, (.dmark+2)  
357c 32 70 fe			ld (debug_mark+2),a  
357f 18 03			jr .pastdmark  
3581 ..			.dmark: db "-L1"  
3584 f1			.pastdmark: pop af  
3585			endm  
# End of macro DMARK
3585						CALLMONITOR 
3585 cd ab 18			call break_point_state  
3588				endm  
# End of macro CALLMONITOR
3588					endif 
3588			 
3588				; go back to previous word 
3588			 
3588 d5				push de    ; save I for inc later 
3589			 
3589			 
3589				; get limit 
3589				;  is I at limit? 
3589			 
3589			 
3589					if DEBUG_FORTH_WORDS 
3589						DMARK "-L1" 
3589 f5				push af  
358a 3a 9e 35			ld a, (.dmark)  
358d 32 6e fe			ld (debug_mark),a  
3590 3a 9f 35			ld a, (.dmark+1)  
3593 32 6f fe			ld (debug_mark+1),a  
3596 3a a0 35			ld a, (.dmark+2)  
3599 32 70 fe			ld (debug_mark+2),a  
359c 18 03			jr .pastdmark  
359e ..			.dmark: db "-L1"  
35a1 f1			.pastdmark: pop af  
35a2			endm  
# End of macro DMARK
35a2						CALLMONITOR 
35a2 cd ab 18			call break_point_state  
35a5				endm  
# End of macro CALLMONITOR
35a5					endif 
35a5			 
35a5 ed 52			sbc hl, de 
35a7			 
35a7			 
35a7				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
35a7			 
35a7 20 26				jr nz, .mloopnotdone 
35a9			 
35a9 e1				pop hl   ; get rid of saved I 
35aa				FORTH_LOOP_POP     ; get rid of limit 
35aa cd 84 21			call macro_forth_loop_pop 
35ad				endm 
# End of macro FORTH_LOOP_POP
35ad			 
35ad				FORTH_RSP_POP     ; get rid of DO ptr 
35ad cd e7 1e			call macro_forth_rsp_pop 
35b0				endm 
# End of macro FORTH_RSP_POP
35b0			 
35b0			if DEBUG_FORTH_WORDS 
35b0						DMARK "-L>" 
35b0 f5				push af  
35b1 3a c5 35			ld a, (.dmark)  
35b4 32 6e fe			ld (debug_mark),a  
35b7 3a c6 35			ld a, (.dmark+1)  
35ba 32 6f fe			ld (debug_mark+1),a  
35bd 3a c7 35			ld a, (.dmark+2)  
35c0 32 70 fe			ld (debug_mark+2),a  
35c3 18 03			jr .pastdmark  
35c5 ..			.dmark: db "-L>"  
35c8 f1			.pastdmark: pop af  
35c9			endm  
# End of macro DMARK
35c9				CALLMONITOR 
35c9 cd ab 18			call break_point_state  
35cc				endm  
# End of macro CALLMONITOR
35cc			endif 
35cc			 
35cc					NEXTW 
35cc c3 8d 22			jp macro_next 
35cf				endm 
# End of macro NEXTW
35cf				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
35cf			 
35cf			.mloopnotdone: 
35cf			 
35cf e1				pop hl    ; get I 
35d0 2b				dec hl 
35d1			 
35d1			   	; save new I 
35d1			 
35d1			 
35d1					; set I counter 
35d1			 
35d1 22 22 f5				ld (os_current_i), hl 
35d4			 
35d4					 
35d4				FORTH_LOOP_NEXT 
35d4 cd 47 21			call macro_forth_loop_next 
35d7				endm 
# End of macro FORTH_LOOP_NEXT
35d7			 
35d7			 
35d7					if DEBUG_FORTH_WORDS 
35d7 eb						ex de,hl 
35d8					endif 
35d8			 
35d8			;	; get DO ptr 
35d8			; 
35d8				FORTH_RSP_TOS 
35d8 cd dd 1e			call macro_forth_rsp_tos 
35db				endm 
# End of macro FORTH_RSP_TOS
35db			 
35db				;push hl 
35db			 
35db				; not going to DO any more 
35db				; get rid of the RSP pointer as DO will add it back in 
35db				;FORTH_RSP_POP 
35db				;pop hl 
35db			 
35db			 
35db 22 fe f4			ld (os_tok_ptr), hl 
35de					if DEBUG_FORTH_WORDS 
35de						DMARK "-L<" 
35de f5				push af  
35df 3a f3 35			ld a, (.dmark)  
35e2 32 6e fe			ld (debug_mark),a  
35e5 3a f4 35			ld a, (.dmark+1)  
35e8 32 6f fe			ld (debug_mark+1),a  
35eb 3a f5 35			ld a, (.dmark+2)  
35ee 32 70 fe			ld (debug_mark+2),a  
35f1 18 03			jr .pastdmark  
35f3 ..			.dmark: db "-L<"  
35f6 f1			.pastdmark: pop af  
35f7			endm  
# End of macro DMARK
35f7					CALLMONITOR 
35f7 cd ab 18			call break_point_state  
35fa				endm  
# End of macro CALLMONITOR
35fa				endif 
35fa c3 1e 23			jp exec1 
35fd			 
35fd					 
35fd			 
35fd			 
35fd			 
35fd				NEXTW 
35fd c3 8d 22			jp macro_next 
3600				endm 
# End of macro NEXTW
3600			 
3600			 
3600			 
3600			 
3600			.REPEAT: 
3600				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
3600 71				db WORD_SYS_CORE+93             
3601 53 36			dw .UNTIL            
3603 06				db 5 + 1 
3604 .. 00			db "REPEAT",0              
360b				endm 
# End of macro CWHEAD
360b			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
360b			;  push pc to rsp stack past the REPEAT 
360b					if DEBUG_FORTH_WORDS_KEY 
360b						DMARK "REP" 
360b f5				push af  
360c 3a 20 36			ld a, (.dmark)  
360f 32 6e fe			ld (debug_mark),a  
3612 3a 21 36			ld a, (.dmark+1)  
3615 32 6f fe			ld (debug_mark+1),a  
3618 3a 22 36			ld a, (.dmark+2)  
361b 32 70 fe			ld (debug_mark+2),a  
361e 18 03			jr .pastdmark  
3620 ..			.dmark: db "REP"  
3623 f1			.pastdmark: pop af  
3624			endm  
# End of macro DMARK
3624						CALLMONITOR 
3624 cd ab 18			call break_point_state  
3627				endm  
# End of macro CALLMONITOR
3627					endif 
3627			 
3627 2a fe f4				ld hl, (os_tok_ptr) 
362a 23					inc hl   ; R 
362b 23					inc hl  ; E 
362c 23					inc hl   ; P 
362d 23					inc hl   ; E 
362e 23					inc hl   ; A 
362f 23					inc hl   ; T 
3630 23					inc hl   ; zero 
3631					FORTH_RSP_NEXT 
3631 cd c6 1e			call macro_forth_rsp_next 
3634				endm 
# End of macro FORTH_RSP_NEXT
3634			 
3634			 
3634					if DEBUG_FORTH_WORDS 
3634						DMARK "REP" 
3634 f5				push af  
3635 3a 49 36			ld a, (.dmark)  
3638 32 6e fe			ld (debug_mark),a  
363b 3a 4a 36			ld a, (.dmark+1)  
363e 32 6f fe			ld (debug_mark+1),a  
3641 3a 4b 36			ld a, (.dmark+2)  
3644 32 70 fe			ld (debug_mark+2),a  
3647 18 03			jr .pastdmark  
3649 ..			.dmark: db "REP"  
364c f1			.pastdmark: pop af  
364d			endm  
# End of macro DMARK
364d						;pop bc    ; TODO BUG ?????? what is this for???? 
364d						CALLMONITOR 
364d cd ab 18			call break_point_state  
3650				endm  
# End of macro CALLMONITOR
3650					endif 
3650			 
3650					NEXTW 
3650 c3 8d 22			jp macro_next 
3653				endm 
# End of macro NEXTW
3653			;	       NEXTW 
3653			 
3653			.UNTIL: 
3653				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
3653 72				db WORD_SYS_CORE+94             
3654 ea 36			dw .ENDFLOW            
3656 06				db 5 + 1 
3657 .. 00			db "UNTIL",0              
365d				endm 
# End of macro CWHEAD
365d			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
365d			 
365d				; pop tos as check 
365d			 
365d				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
365d			 
365d				FORTH_DSP_VALUEHL 
365d cd 16 21			call macro_dsp_valuehl 
3660				endm 
# End of macro FORTH_DSP_VALUEHL
3660			 
3660					if DEBUG_FORTH_WORDS_KEY 
3660						DMARK "UNT" 
3660 f5				push af  
3661 3a 75 36			ld a, (.dmark)  
3664 32 6e fe			ld (debug_mark),a  
3667 3a 76 36			ld a, (.dmark+1)  
366a 32 6f fe			ld (debug_mark+1),a  
366d 3a 77 36			ld a, (.dmark+2)  
3670 32 70 fe			ld (debug_mark+2),a  
3673 18 03			jr .pastdmark  
3675 ..			.dmark: db "UNT"  
3678 f1			.pastdmark: pop af  
3679			endm  
# End of macro DMARK
3679						CALLMONITOR 
3679 cd ab 18			call break_point_state  
367c				endm  
# End of macro CALLMONITOR
367c					endif 
367c			 
367c			;	push hl 
367c				FORTH_DSP_POP 
367c cd ce 21			call macro_forth_dsp_pop 
367f				endm 
# End of macro FORTH_DSP_POP
367f			 
367f			;	pop hl 
367f			 
367f				; test if true 
367f			 
367f cd 2d 0f			call ishlzero 
3682			;	ld a,l 
3682			;	add h 
3682			; 
3682			;	cp 0 
3682			 
3682 20 3e			jr nz, .untilnotdone 
3684			 
3684					if DEBUG_FORTH_WORDS 
3684						DMARK "UNf" 
3684 f5				push af  
3685 3a 99 36			ld a, (.dmark)  
3688 32 6e fe			ld (debug_mark),a  
368b 3a 9a 36			ld a, (.dmark+1)  
368e 32 6f fe			ld (debug_mark+1),a  
3691 3a 9b 36			ld a, (.dmark+2)  
3694 32 70 fe			ld (debug_mark+2),a  
3697 18 03			jr .pastdmark  
3699 ..			.dmark: db "UNf"  
369c f1			.pastdmark: pop af  
369d			endm  
# End of macro DMARK
369d						CALLMONITOR 
369d cd ab 18			call break_point_state  
36a0				endm  
# End of macro CALLMONITOR
36a0					endif 
36a0			 
36a0			 
36a0			 
36a0				FORTH_RSP_POP     ; get rid of DO ptr 
36a0 cd e7 1e			call macro_forth_rsp_pop 
36a3				endm 
# End of macro FORTH_RSP_POP
36a3			 
36a3			if DEBUG_FORTH_WORDS 
36a3						DMARK "UN>" 
36a3 f5				push af  
36a4 3a b8 36			ld a, (.dmark)  
36a7 32 6e fe			ld (debug_mark),a  
36aa 3a b9 36			ld a, (.dmark+1)  
36ad 32 6f fe			ld (debug_mark+1),a  
36b0 3a ba 36			ld a, (.dmark+2)  
36b3 32 70 fe			ld (debug_mark+2),a  
36b6 18 03			jr .pastdmark  
36b8 ..			.dmark: db "UN>"  
36bb f1			.pastdmark: pop af  
36bc			endm  
# End of macro DMARK
36bc				CALLMONITOR 
36bc cd ab 18			call break_point_state  
36bf				endm  
# End of macro CALLMONITOR
36bf			endif 
36bf			 
36bf					NEXTW 
36bf c3 8d 22			jp macro_next 
36c2				endm 
# End of macro NEXTW
36c2				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
36c2			 
36c2			.untilnotdone: 
36c2			 
36c2			 
36c2			;	; get DO ptr 
36c2			; 
36c2				FORTH_RSP_TOS 
36c2 cd dd 1e			call macro_forth_rsp_tos 
36c5				endm 
# End of macro FORTH_RSP_TOS
36c5			 
36c5				;push hl 
36c5			 
36c5				; not going to DO any more 
36c5				; get rid of the RSP pointer as DO will add it back in 
36c5				;FORTH_RSP_POP 
36c5				;pop hl 
36c5			 
36c5			 
36c5 22 fe f4			ld (os_tok_ptr), hl 
36c8					if DEBUG_FORTH_WORDS 
36c8						DMARK "UN<" 
36c8 f5				push af  
36c9 3a dd 36			ld a, (.dmark)  
36cc 32 6e fe			ld (debug_mark),a  
36cf 3a de 36			ld a, (.dmark+1)  
36d2 32 6f fe			ld (debug_mark+1),a  
36d5 3a df 36			ld a, (.dmark+2)  
36d8 32 70 fe			ld (debug_mark+2),a  
36db 18 03			jr .pastdmark  
36dd ..			.dmark: db "UN<"  
36e0 f1			.pastdmark: pop af  
36e1			endm  
# End of macro DMARK
36e1					CALLMONITOR 
36e1 cd ab 18			call break_point_state  
36e4				endm  
# End of macro CALLMONITOR
36e4				endif 
36e4 c3 1e 23			jp exec1 
36e7			 
36e7					 
36e7			 
36e7			 
36e7					NEXTW 
36e7 c3 8d 22			jp macro_next 
36ea				endm 
# End of macro NEXTW
36ea			 
36ea			 
36ea			.ENDFLOW: 
36ea			 
36ea			; eof 
36ea			 
# End of file forth_words_flow.asm
36ea			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
36ea			include "forth_words_logic.asm" 
36ea			 
36ea			; | ## Logic Words 
36ea			 
36ea			.NOT: 
36ea				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
36ea 2d				db WORD_SYS_CORE+25             
36eb 32 37			dw .IS            
36ed 04				db 3 + 1 
36ee .. 00			db "NOT",0              
36f2				endm 
# End of macro CWHEAD
36f2			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
36f2					if DEBUG_FORTH_WORDS_KEY 
36f2						DMARK "NOT" 
36f2 f5				push af  
36f3 3a 07 37			ld a, (.dmark)  
36f6 32 6e fe			ld (debug_mark),a  
36f9 3a 08 37			ld a, (.dmark+1)  
36fc 32 6f fe			ld (debug_mark+1),a  
36ff 3a 09 37			ld a, (.dmark+2)  
3702 32 70 fe			ld (debug_mark+2),a  
3705 18 03			jr .pastdmark  
3707 ..			.dmark: db "NOT"  
370a f1			.pastdmark: pop af  
370b			endm  
# End of macro DMARK
370b						CALLMONITOR 
370b cd ab 18			call break_point_state  
370e				endm  
# End of macro CALLMONITOR
370e					endif 
370e					FORTH_DSP 
370e cd dc 20			call macro_forth_dsp 
3711				endm 
# End of macro FORTH_DSP
3711 7e					ld a,(hl)	; get type of value on TOS 
3712 fe 02				cp DS_TYPE_INUM  
3714 28 03				jr z, .noti 
3716					NEXTW 
3716 c3 8d 22			jp macro_next 
3719				endm 
# End of macro NEXTW
3719			.noti:          FORTH_DSP_VALUEHL 
3719 cd 16 21			call macro_dsp_valuehl 
371c				endm 
# End of macro FORTH_DSP_VALUEHL
371c			;		push hl 
371c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
371c cd ce 21			call macro_forth_dsp_pop 
371f				endm 
# End of macro FORTH_DSP_POP
371f			;		pop hl 
371f 3e 00				ld a,0 
3721 bd					cp l 
3722 28 04				jr z, .not2t 
3724 2e 00				ld l, 0 
3726 18 02				jr .notip 
3728			 
3728 2e ff		.not2t:		ld l, 255 
372a			 
372a 26 00		.notip:		ld h, 0	 
372c			 
372c cd 1f 1f				call forth_push_numhl 
372f					NEXTW 
372f c3 8d 22			jp macro_next 
3732				endm 
# End of macro NEXTW
3732			 
3732			.IS: 
3732				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
3732 2d				db WORD_SYS_CORE+25             
3733 58 37			dw .LZERO            
3735 03				db 2 + 1 
3736 .. 00			db "IS",0              
3739				endm 
# End of macro CWHEAD
3739			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
3739					if DEBUG_FORTH_WORDS_KEY 
3739						DMARK "IS." 
3739 f5				push af  
373a 3a 4e 37			ld a, (.dmark)  
373d 32 6e fe			ld (debug_mark),a  
3740 3a 4f 37			ld a, (.dmark+1)  
3743 32 6f fe			ld (debug_mark+1),a  
3746 3a 50 37			ld a, (.dmark+2)  
3749 32 70 fe			ld (debug_mark+2),a  
374c 18 03			jr .pastdmark  
374e ..			.dmark: db "IS."  
3751 f1			.pastdmark: pop af  
3752			endm  
# End of macro DMARK
3752						CALLMONITOR 
3752 cd ab 18			call break_point_state  
3755				endm  
# End of macro CALLMONITOR
3755					endif 
3755					NEXTW 
3755 c3 8d 22			jp macro_next 
3758				endm 
# End of macro NEXTW
3758			.LZERO: 
3758				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
3758 2d				db WORD_SYS_CORE+25             
3759 62 37			dw .TZERO            
375b 03				db 2 + 1 
375c .. 00			db "0<",0              
375f				endm 
# End of macro CWHEAD
375f			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
375f					NEXTW 
375f c3 8d 22			jp macro_next 
3762				endm 
# End of macro NEXTW
3762			.TZERO: 
3762				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
3762 2e				db WORD_SYS_CORE+26             
3763 a9 37			dw .LESS            
3765 03				db 2 + 1 
3766 .. 00			db "0=",0              
3769				endm 
# End of macro CWHEAD
3769			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
3769				; TODO add floating point number detection 
3769					;v5 FORTH_DSP_VALUE 
3769					if DEBUG_FORTH_WORDS_KEY 
3769						DMARK "0=." 
3769 f5				push af  
376a 3a 7e 37			ld a, (.dmark)  
376d 32 6e fe			ld (debug_mark),a  
3770 3a 7f 37			ld a, (.dmark+1)  
3773 32 6f fe			ld (debug_mark+1),a  
3776 3a 80 37			ld a, (.dmark+2)  
3779 32 70 fe			ld (debug_mark+2),a  
377c 18 03			jr .pastdmark  
377e ..			.dmark: db "0=."  
3781 f1			.pastdmark: pop af  
3782			endm  
# End of macro DMARK
3782						CALLMONITOR 
3782 cd ab 18			call break_point_state  
3785				endm  
# End of macro CALLMONITOR
3785					endif 
3785					FORTH_DSP 
3785 cd dc 20			call macro_forth_dsp 
3788				endm 
# End of macro FORTH_DSP
3788 7e					ld a,(hl)	; get type of value on TOS 
3789 fe 02				cp DS_TYPE_INUM  
378b 28 00				jr z, .tz_inum 
378d			 
378d				if FORTH_ENABLE_FLOATMATH 
378d					jr .tz_done 
378d			 
378d				endif 
378d					 
378d			 
378d			.tz_inum: 
378d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
378d cd 16 21			call macro_dsp_valuehl 
3790				endm 
# End of macro FORTH_DSP_VALUEHL
3790			 
3790			;		push hl 
3790			 
3790					; destroy value TOS 
3790			 
3790					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3790 cd ce 21			call macro_forth_dsp_pop 
3793				endm 
# End of macro FORTH_DSP_POP
3793			 
3793			;		pop hl 
3793			 
3793 3e 00				ld a,0 
3795			 
3795 bd					cp l 
3796 20 08				jr nz, .tz_notzero 
3798			 
3798 bc					cp h 
3799			 
3799 20 05				jr nz, .tz_notzero 
379b			 
379b			 
379b 21 01 00				ld hl, FORTH_TRUE 
379e 18 03				jr .tz_done 
37a0			 
37a0 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
37a3			 
37a3					; push value back onto stack for another op etc 
37a3			 
37a3			.tz_done: 
37a3 cd 1f 1f				call forth_push_numhl 
37a6			 
37a6					NEXTW 
37a6 c3 8d 22			jp macro_next 
37a9				endm 
# End of macro NEXTW
37a9			.LESS: 
37a9				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
37a9 2f				db WORD_SYS_CORE+27             
37aa 12 38			dw .GT            
37ac 02				db 1 + 1 
37ad .. 00			db "<",0              
37af				endm 
# End of macro CWHEAD
37af			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
37af				; TODO add floating point number detection 
37af					if DEBUG_FORTH_WORDS_KEY 
37af						DMARK "LES" 
37af f5				push af  
37b0 3a c4 37			ld a, (.dmark)  
37b3 32 6e fe			ld (debug_mark),a  
37b6 3a c5 37			ld a, (.dmark+1)  
37b9 32 6f fe			ld (debug_mark+1),a  
37bc 3a c6 37			ld a, (.dmark+2)  
37bf 32 70 fe			ld (debug_mark+2),a  
37c2 18 03			jr .pastdmark  
37c4 ..			.dmark: db "LES"  
37c7 f1			.pastdmark: pop af  
37c8			endm  
# End of macro DMARK
37c8						CALLMONITOR 
37c8 cd ab 18			call break_point_state  
37cb				endm  
# End of macro CALLMONITOR
37cb					endif 
37cb					FORTH_DSP 
37cb cd dc 20			call macro_forth_dsp 
37ce				endm 
# End of macro FORTH_DSP
37ce					;v5 FORTH_DSP_VALUE 
37ce 7e					ld a,(hl)	; get type of value on TOS 
37cf fe 02				cp DS_TYPE_INUM  
37d1 28 00				jr z, .less_inum 
37d3			 
37d3				if FORTH_ENABLE_FLOATMATH 
37d3					jr .less_done 
37d3			 
37d3				endif 
37d3					 
37d3			 
37d3			.less_inum: 
37d3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37d3 cd 16 21			call macro_dsp_valuehl 
37d6				endm 
# End of macro FORTH_DSP_VALUEHL
37d6			 
37d6 e5					push hl  ; u2 
37d7			 
37d7					; destroy value TOS 
37d7			 
37d7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37d7 cd ce 21			call macro_forth_dsp_pop 
37da				endm 
# End of macro FORTH_DSP_POP
37da			 
37da			 
37da					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37da cd 16 21			call macro_dsp_valuehl 
37dd				endm 
# End of macro FORTH_DSP_VALUEHL
37dd			 
37dd e5					push hl    ; u1 
37de			 
37de					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37de cd ce 21			call macro_forth_dsp_pop 
37e1				endm 
# End of macro FORTH_DSP_POP
37e1			 
37e1			 
37e1 b7			 or a      ;clear carry flag 
37e2 01 00 00		 ld bc, FORTH_FALSE 
37e5 e1			  pop hl    ; u1 
37e6 d1			  pop de    ; u2 
37e7 ed 52		  sbc hl,de 
37e9 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
37eb			 
37eb 01 01 00		 ld bc, FORTH_TRUE 
37ee			.lscont:  
37ee c5					push bc 
37ef e1					pop hl 
37f0			 
37f0					if DEBUG_FORTH_WORDS 
37f0						DMARK "LT1" 
37f0 f5				push af  
37f1 3a 05 38			ld a, (.dmark)  
37f4 32 6e fe			ld (debug_mark),a  
37f7 3a 06 38			ld a, (.dmark+1)  
37fa 32 6f fe			ld (debug_mark+1),a  
37fd 3a 07 38			ld a, (.dmark+2)  
3800 32 70 fe			ld (debug_mark+2),a  
3803 18 03			jr .pastdmark  
3805 ..			.dmark: db "LT1"  
3808 f1			.pastdmark: pop af  
3809			endm  
# End of macro DMARK
3809						CALLMONITOR 
3809 cd ab 18			call break_point_state  
380c				endm  
# End of macro CALLMONITOR
380c					endif 
380c cd 1f 1f				call forth_push_numhl 
380f			 
380f					NEXTW 
380f c3 8d 22			jp macro_next 
3812				endm 
# End of macro NEXTW
3812			.GT: 
3812				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
3812 30				db WORD_SYS_CORE+28             
3813 7b 38			dw .EQUAL            
3815 02				db 1 + 1 
3816 .. 00			db ">",0              
3818				endm 
# End of macro CWHEAD
3818			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
3818				; TODO add floating point number detection 
3818					if DEBUG_FORTH_WORDS_KEY 
3818						DMARK "GRT" 
3818 f5				push af  
3819 3a 2d 38			ld a, (.dmark)  
381c 32 6e fe			ld (debug_mark),a  
381f 3a 2e 38			ld a, (.dmark+1)  
3822 32 6f fe			ld (debug_mark+1),a  
3825 3a 2f 38			ld a, (.dmark+2)  
3828 32 70 fe			ld (debug_mark+2),a  
382b 18 03			jr .pastdmark  
382d ..			.dmark: db "GRT"  
3830 f1			.pastdmark: pop af  
3831			endm  
# End of macro DMARK
3831						CALLMONITOR 
3831 cd ab 18			call break_point_state  
3834				endm  
# End of macro CALLMONITOR
3834					endif 
3834					FORTH_DSP 
3834 cd dc 20			call macro_forth_dsp 
3837				endm 
# End of macro FORTH_DSP
3837					;FORTH_DSP_VALUE 
3837 7e					ld a,(hl)	; get type of value on TOS 
3838 fe 02				cp DS_TYPE_INUM  
383a 28 00				jr z, .gt_inum 
383c			 
383c				if FORTH_ENABLE_FLOATMATH 
383c					jr .gt_done 
383c			 
383c				endif 
383c					 
383c			 
383c			.gt_inum: 
383c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
383c cd 16 21			call macro_dsp_valuehl 
383f				endm 
# End of macro FORTH_DSP_VALUEHL
383f			 
383f e5					push hl  ; u2 
3840			 
3840					; destroy value TOS 
3840			 
3840					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3840 cd ce 21			call macro_forth_dsp_pop 
3843				endm 
# End of macro FORTH_DSP_POP
3843			 
3843			 
3843					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3843 cd 16 21			call macro_dsp_valuehl 
3846				endm 
# End of macro FORTH_DSP_VALUEHL
3846			 
3846 e5					push hl    ; u1 
3847			 
3847					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3847 cd ce 21			call macro_forth_dsp_pop 
384a				endm 
# End of macro FORTH_DSP_POP
384a			 
384a			 
384a b7			 or a      ;clear carry flag 
384b 01 00 00		 ld bc, FORTH_FALSE 
384e e1			  pop hl    ; u1 
384f d1			  pop de    ; u2 
3850 ed 52		  sbc hl,de 
3852 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
3854			 
3854 01 01 00		 ld bc, FORTH_TRUE 
3857			.gtcont:  
3857 c5					push bc 
3858 e1					pop hl 
3859			 
3859					if DEBUG_FORTH_WORDS 
3859						DMARK "GT1" 
3859 f5				push af  
385a 3a 6e 38			ld a, (.dmark)  
385d 32 6e fe			ld (debug_mark),a  
3860 3a 6f 38			ld a, (.dmark+1)  
3863 32 6f fe			ld (debug_mark+1),a  
3866 3a 70 38			ld a, (.dmark+2)  
3869 32 70 fe			ld (debug_mark+2),a  
386c 18 03			jr .pastdmark  
386e ..			.dmark: db "GT1"  
3871 f1			.pastdmark: pop af  
3872			endm  
# End of macro DMARK
3872						CALLMONITOR 
3872 cd ab 18			call break_point_state  
3875				endm  
# End of macro CALLMONITOR
3875					endif 
3875 cd 1f 1f				call forth_push_numhl 
3878			 
3878					NEXTW 
3878 c3 8d 22			jp macro_next 
387b				endm 
# End of macro NEXTW
387b			.EQUAL: 
387b				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
387b 31				db WORD_SYS_CORE+29             
387c e6 38			dw .ENDLOGIC            
387e 02				db 1 + 1 
387f .. 00			db "=",0              
3881				endm 
# End of macro CWHEAD
3881			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3881				; TODO add floating point number detection 
3881					if DEBUG_FORTH_WORDS_KEY 
3881						DMARK "EQ." 
3881 f5				push af  
3882 3a 96 38			ld a, (.dmark)  
3885 32 6e fe			ld (debug_mark),a  
3888 3a 97 38			ld a, (.dmark+1)  
388b 32 6f fe			ld (debug_mark+1),a  
388e 3a 98 38			ld a, (.dmark+2)  
3891 32 70 fe			ld (debug_mark+2),a  
3894 18 03			jr .pastdmark  
3896 ..			.dmark: db "EQ."  
3899 f1			.pastdmark: pop af  
389a			endm  
# End of macro DMARK
389a						CALLMONITOR 
389a cd ab 18			call break_point_state  
389d				endm  
# End of macro CALLMONITOR
389d					endif 
389d					FORTH_DSP 
389d cd dc 20			call macro_forth_dsp 
38a0				endm 
# End of macro FORTH_DSP
38a0					;v5 FORTH_DSP_VALUE 
38a0 7e					ld a,(hl)	; get type of value on TOS 
38a1 fe 02				cp DS_TYPE_INUM  
38a3 28 00				jr z, .eq_inum 
38a5			 
38a5				if FORTH_ENABLE_FLOATMATH 
38a5					jr .eq_done 
38a5			 
38a5				endif 
38a5					 
38a5			 
38a5			.eq_inum: 
38a5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38a5 cd 16 21			call macro_dsp_valuehl 
38a8				endm 
# End of macro FORTH_DSP_VALUEHL
38a8			 
38a8 e5					push hl 
38a9			 
38a9					; destroy value TOS 
38a9			 
38a9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38a9 cd ce 21			call macro_forth_dsp_pop 
38ac				endm 
# End of macro FORTH_DSP_POP
38ac			 
38ac			 
38ac					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38ac cd 16 21			call macro_dsp_valuehl 
38af				endm 
# End of macro FORTH_DSP_VALUEHL
38af			 
38af					; one value on hl get other one back 
38af			 
38af e5					push hl 
38b0			 
38b0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38b0 cd ce 21			call macro_forth_dsp_pop 
38b3				endm 
# End of macro FORTH_DSP_POP
38b3			 
38b3 0e 00				ld c, FORTH_FALSE 
38b5			 
38b5 e1					pop hl 
38b6 d1					pop de 
38b7			 
38b7 7b					ld a, e 
38b8 bd					cp l 
38b9			 
38b9 20 06				jr nz, .eq_done 
38bb			 
38bb 7a					ld a, d 
38bc bc					cp h 
38bd			 
38bd 20 02				jr nz, .eq_done 
38bf			 
38bf 0e 01				ld c, FORTH_TRUE 
38c1					 
38c1			 
38c1			 
38c1			.eq_done: 
38c1			 
38c1					; TODO push value back onto stack for another op etc 
38c1			 
38c1 26 00				ld h, 0 
38c3 69					ld l, c 
38c4					if DEBUG_FORTH_WORDS 
38c4						DMARK "EQ1" 
38c4 f5				push af  
38c5 3a d9 38			ld a, (.dmark)  
38c8 32 6e fe			ld (debug_mark),a  
38cb 3a da 38			ld a, (.dmark+1)  
38ce 32 6f fe			ld (debug_mark+1),a  
38d1 3a db 38			ld a, (.dmark+2)  
38d4 32 70 fe			ld (debug_mark+2),a  
38d7 18 03			jr .pastdmark  
38d9 ..			.dmark: db "EQ1"  
38dc f1			.pastdmark: pop af  
38dd			endm  
# End of macro DMARK
38dd						CALLMONITOR 
38dd cd ab 18			call break_point_state  
38e0				endm  
# End of macro CALLMONITOR
38e0					endif 
38e0 cd 1f 1f				call forth_push_numhl 
38e3			 
38e3					NEXTW 
38e3 c3 8d 22			jp macro_next 
38e6				endm 
# End of macro NEXTW
38e6			 
38e6			 
38e6			.ENDLOGIC: 
38e6			; eof 
38e6			 
38e6			 
# End of file forth_words_logic.asm
38e6			include "forth_words_maths.asm" 
38e6			 
38e6			; | ## Maths Words 
38e6			 
38e6			.PLUS:	 
38e6				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
38e6 15				db WORD_SYS_CORE+1             
38e7 28 39			dw .NEG            
38e9 02				db 1 + 1 
38ea .. 00			db "+",0              
38ec				endm 
# End of macro CWHEAD
38ec			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
38ec					if DEBUG_FORTH_WORDS_KEY 
38ec						DMARK "PLU" 
38ec f5				push af  
38ed 3a 01 39			ld a, (.dmark)  
38f0 32 6e fe			ld (debug_mark),a  
38f3 3a 02 39			ld a, (.dmark+1)  
38f6 32 6f fe			ld (debug_mark+1),a  
38f9 3a 03 39			ld a, (.dmark+2)  
38fc 32 70 fe			ld (debug_mark+2),a  
38ff 18 03			jr .pastdmark  
3901 ..			.dmark: db "PLU"  
3904 f1			.pastdmark: pop af  
3905			endm  
# End of macro DMARK
3905						CALLMONITOR 
3905 cd ab 18			call break_point_state  
3908				endm  
# End of macro CALLMONITOR
3908					endif 
3908					; add top two values and push back result 
3908			 
3908					;for v5 FORTH_DSP_VALUE 
3908					FORTH_DSP 
3908 cd dc 20			call macro_forth_dsp 
390b				endm 
# End of macro FORTH_DSP
390b 7e					ld a,(hl)	; get type of value on TOS 
390c fe 02				cp DS_TYPE_INUM  
390e 28 03				jr z, .dot_inum 
3910			 
3910					NEXTW 
3910 c3 8d 22			jp macro_next 
3913				endm 
# End of macro NEXTW
3913			 
3913			; float maths 
3913			 
3913				if FORTH_ENABLE_FLOATMATH 
3913						inc hl      ; now at start of numeric as string 
3913			 
3913					if DEBUG_FORTH_MATHS 
3913						DMARK "ADD" 
3913				CALLMONITOR 
3913					endif 
3913			 
3913					;ld ix, hl 
3913					call CON 
3913			 
3913			 
3913					push hl 
3913					 
3913					 
3913			 
3913						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
3913			 
3913					; get next number 
3913			 
3913						FORTH_DSP_VALUE 
3913			 
3913						inc hl      ; now at start of numeric as string 
3913			 
3913					;ld ix, hl 
3913					call CON 
3913			 
3913					push hl 
3913			 
3913			 
3913						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3913			 
3913						; TODO do add 
3913			 
3913						call IADD 
3913			 
3913						; TODO get result back as ascii 
3913			 
3913						; TODO push result  
3913			 
3913			 
3913			 
3913						jr .dot_done 
3913				endif 
3913			 
3913			.dot_inum: 
3913			 
3913			 
3913					if DEBUG_FORTH_DOT 
3913						DMARK "+IT" 
3913				CALLMONITOR 
3913					endif 
3913			 
3913					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3913 cd 16 21			call macro_dsp_valuehl 
3916				endm 
# End of macro FORTH_DSP_VALUEHL
3916			 
3916				; TODO add floating point number detection 
3916			 
3916 e5					push hl 
3917			 
3917					; destroy value TOS 
3917			 
3917					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3917 cd ce 21			call macro_forth_dsp_pop 
391a				endm 
# End of macro FORTH_DSP_POP
391a			 
391a			 
391a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
391a cd 16 21			call macro_dsp_valuehl 
391d				endm 
# End of macro FORTH_DSP_VALUEHL
391d			 
391d					; one value on hl get other one back 
391d			 
391d d1					pop de 
391e			 
391e					; do the add 
391e			 
391e 19					add hl,de 
391f			 
391f					; save it 
391f			 
391f			;		push hl	 
391f			 
391f					; 
391f			 
391f					; destroy value TOS 
391f			 
391f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
391f cd ce 21			call macro_forth_dsp_pop 
3922				endm 
# End of macro FORTH_DSP_POP
3922			 
3922					; TODO push value back onto stack for another op etc 
3922			 
3922			;		pop hl 
3922			 
3922			.dot_done: 
3922 cd 1f 1f				call forth_push_numhl 
3925			 
3925					NEXTW 
3925 c3 8d 22			jp macro_next 
3928				endm 
# End of macro NEXTW
3928			.NEG: 
3928			 
3928				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
3928 17				db WORD_SYS_CORE+3             
3929 6b 39			dw .DIV            
392b 02				db 1 + 1 
392c .. 00			db "-",0              
392e				endm 
# End of macro CWHEAD
392e			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
392e					if DEBUG_FORTH_WORDS_KEY 
392e						DMARK "SUB" 
392e f5				push af  
392f 3a 43 39			ld a, (.dmark)  
3932 32 6e fe			ld (debug_mark),a  
3935 3a 44 39			ld a, (.dmark+1)  
3938 32 6f fe			ld (debug_mark+1),a  
393b 3a 45 39			ld a, (.dmark+2)  
393e 32 70 fe			ld (debug_mark+2),a  
3941 18 03			jr .pastdmark  
3943 ..			.dmark: db "SUB"  
3946 f1			.pastdmark: pop af  
3947			endm  
# End of macro DMARK
3947						CALLMONITOR 
3947 cd ab 18			call break_point_state  
394a				endm  
# End of macro CALLMONITOR
394a					endif 
394a			 
394a			 
394a				; TODO add floating point number detection 
394a					; v5 FORTH_DSP_VALUE 
394a					FORTH_DSP 
394a cd dc 20			call macro_forth_dsp 
394d				endm 
# End of macro FORTH_DSP
394d 7e					ld a,(hl)	; get type of value on TOS 
394e fe 02				cp DS_TYPE_INUM  
3950 28 03				jr z, .neg_inum 
3952			 
3952					NEXTW 
3952 c3 8d 22			jp macro_next 
3955				endm 
# End of macro NEXTW
3955			 
3955			; float maths 
3955			 
3955				if FORTH_ENABLE_FLOATMATH 
3955					jr .neg_done 
3955			 
3955				endif 
3955					 
3955			 
3955			.neg_inum: 
3955					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3955 cd 16 21			call macro_dsp_valuehl 
3958				endm 
# End of macro FORTH_DSP_VALUEHL
3958			 
3958 e5					push hl 
3959			 
3959					; destroy value TOS 
3959			 
3959					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3959 cd ce 21			call macro_forth_dsp_pop 
395c				endm 
# End of macro FORTH_DSP_POP
395c			 
395c			 
395c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
395c cd 16 21			call macro_dsp_valuehl 
395f				endm 
# End of macro FORTH_DSP_VALUEHL
395f			 
395f					; one value on hl get other one back 
395f			 
395f d1					pop de 
3960			 
3960					; do the sub 
3960			;		ex de, hl 
3960			 
3960 ed 52				sbc hl,de 
3962			 
3962					; save it 
3962			 
3962			;		push hl	 
3962			 
3962					; 
3962			 
3962					; destroy value TOS 
3962			 
3962					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3962 cd ce 21			call macro_forth_dsp_pop 
3965				endm 
# End of macro FORTH_DSP_POP
3965			 
3965					; TODO push value back onto stack for another op etc 
3965			 
3965			;		pop hl 
3965			 
3965 cd 1f 1f				call forth_push_numhl 
3968			.neg_done: 
3968			 
3968					NEXTW 
3968 c3 8d 22			jp macro_next 
396b				endm 
# End of macro NEXTW
396b			.DIV: 
396b				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
396b 18				db WORD_SYS_CORE+4             
396c b8 39			dw .MUL            
396e 02				db 1 + 1 
396f .. 00			db "/",0              
3971				endm 
# End of macro CWHEAD
3971			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3971					if DEBUG_FORTH_WORDS_KEY 
3971						DMARK "DIV" 
3971 f5				push af  
3972 3a 86 39			ld a, (.dmark)  
3975 32 6e fe			ld (debug_mark),a  
3978 3a 87 39			ld a, (.dmark+1)  
397b 32 6f fe			ld (debug_mark+1),a  
397e 3a 88 39			ld a, (.dmark+2)  
3981 32 70 fe			ld (debug_mark+2),a  
3984 18 03			jr .pastdmark  
3986 ..			.dmark: db "DIV"  
3989 f1			.pastdmark: pop af  
398a			endm  
# End of macro DMARK
398a						CALLMONITOR 
398a cd ab 18			call break_point_state  
398d				endm  
# End of macro CALLMONITOR
398d					endif 
398d				; TODO add floating point number detection 
398d					; v5 FORTH_DSP_VALUE 
398d					FORTH_DSP 
398d cd dc 20			call macro_forth_dsp 
3990				endm 
# End of macro FORTH_DSP
3990 7e					ld a,(hl)	; get type of value on TOS 
3991 fe 02				cp DS_TYPE_INUM  
3993 28 03				jr z, .div_inum 
3995			 
3995				if FORTH_ENABLE_FLOATMATH 
3995					jr .div_done 
3995			 
3995				endif 
3995					NEXTW 
3995 c3 8d 22			jp macro_next 
3998				endm 
# End of macro NEXTW
3998			.div_inum: 
3998			 
3998					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3998 cd 16 21			call macro_dsp_valuehl 
399b				endm 
# End of macro FORTH_DSP_VALUEHL
399b			 
399b e5					push hl    ; to go to bc 
399c			 
399c					; destroy value TOS 
399c			 
399c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
399c cd ce 21			call macro_forth_dsp_pop 
399f				endm 
# End of macro FORTH_DSP_POP
399f			 
399f			 
399f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
399f cd 16 21			call macro_dsp_valuehl 
39a2				endm 
# End of macro FORTH_DSP_VALUEHL
39a2			 
39a2					; hl to go to de 
39a2			 
39a2 e5					push hl 
39a3			 
39a3 c1					pop bc 
39a4 d1					pop de		 
39a5			 
39a5			 
39a5					if DEBUG_FORTH_MATHS 
39a5						DMARK "DIV" 
39a5				CALLMONITOR 
39a5					endif 
39a5					; one value on hl but move to a get other one back 
39a5			 
39a5			        
39a5 cd 61 0e			call Div16 
39a8			 
39a8			;	push af	 
39a8 e5				push hl 
39a9 c5				push bc 
39aa			 
39aa					if DEBUG_FORTH_MATHS 
39aa						DMARK "DI1" 
39aa				CALLMONITOR 
39aa					endif 
39aa			 
39aa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39aa cd ce 21			call macro_forth_dsp_pop 
39ad				endm 
# End of macro FORTH_DSP_POP
39ad			 
39ad			 
39ad			 
39ad e1					pop hl    ; result 
39ae			 
39ae cd 1f 1f				call forth_push_numhl 
39b1			 
39b1 e1					pop hl    ; reminder 
39b2			;		ld h,0 
39b2			;		ld l,d 
39b2			 
39b2 cd 1f 1f				call forth_push_numhl 
39b5			.div_done: 
39b5					NEXTW 
39b5 c3 8d 22			jp macro_next 
39b8				endm 
# End of macro NEXTW
39b8			.MUL: 
39b8				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
39b8 19				db WORD_SYS_CORE+5             
39b9 fd 39			dw .MIN            
39bb 02				db 1 + 1 
39bc .. 00			db "*",0              
39be				endm 
# End of macro CWHEAD
39be			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
39be				; TODO add floating point number detection 
39be					if DEBUG_FORTH_WORDS_KEY 
39be						DMARK "MUL" 
39be f5				push af  
39bf 3a d3 39			ld a, (.dmark)  
39c2 32 6e fe			ld (debug_mark),a  
39c5 3a d4 39			ld a, (.dmark+1)  
39c8 32 6f fe			ld (debug_mark+1),a  
39cb 3a d5 39			ld a, (.dmark+2)  
39ce 32 70 fe			ld (debug_mark+2),a  
39d1 18 03			jr .pastdmark  
39d3 ..			.dmark: db "MUL"  
39d6 f1			.pastdmark: pop af  
39d7			endm  
# End of macro DMARK
39d7						CALLMONITOR 
39d7 cd ab 18			call break_point_state  
39da				endm  
# End of macro CALLMONITOR
39da					endif 
39da					FORTH_DSP 
39da cd dc 20			call macro_forth_dsp 
39dd				endm 
# End of macro FORTH_DSP
39dd					; v5 FORTH_DSP_VALUE 
39dd 7e					ld a,(hl)	; get type of value on TOS 
39de fe 02				cp DS_TYPE_INUM  
39e0 28 03				jr z, .mul_inum 
39e2			 
39e2				if FORTH_ENABLE_FLOATMATH 
39e2					jr .mul_done 
39e2			 
39e2				endif 
39e2			 
39e2					NEXTW 
39e2 c3 8d 22			jp macro_next 
39e5				endm 
# End of macro NEXTW
39e5			.mul_inum:	 
39e5			 
39e5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39e5 cd 16 21			call macro_dsp_valuehl 
39e8				endm 
# End of macro FORTH_DSP_VALUEHL
39e8			 
39e8 e5					push hl 
39e9			 
39e9					; destroy value TOS 
39e9			 
39e9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39e9 cd ce 21			call macro_forth_dsp_pop 
39ec				endm 
# End of macro FORTH_DSP_POP
39ec			 
39ec			 
39ec					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39ec cd 16 21			call macro_dsp_valuehl 
39ef				endm 
# End of macro FORTH_DSP_VALUEHL
39ef			 
39ef					; one value on hl but move to a get other one back 
39ef			 
39ef 7d					ld a, l 
39f0			 
39f0 d1					pop de 
39f1			 
39f1					; do the mull 
39f1			;		ex de, hl 
39f1			 
39f1 cd 87 0e				call Mult16 
39f4					; save it 
39f4			 
39f4			;		push hl	 
39f4			 
39f4					; 
39f4			 
39f4					; destroy value TOS 
39f4			 
39f4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39f4 cd ce 21			call macro_forth_dsp_pop 
39f7				endm 
# End of macro FORTH_DSP_POP
39f7			 
39f7					; TODO push value back onto stack for another op etc 
39f7			 
39f7			;		pop hl 
39f7			 
39f7 cd 1f 1f				call forth_push_numhl 
39fa			 
39fa			.mul_done: 
39fa					NEXTW 
39fa c3 8d 22			jp macro_next 
39fd				endm 
# End of macro NEXTW
39fd			 
39fd			 
39fd			 
39fd			 
39fd			.MIN: 
39fd				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
39fd 49				db WORD_SYS_CORE+53             
39fe 7e 3a			dw .MAX            
3a00 04				db 3 + 1 
3a01 .. 00			db "MIN",0              
3a05				endm 
# End of macro CWHEAD
3a05			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3a05					if DEBUG_FORTH_WORDS_KEY 
3a05						DMARK "MIN" 
3a05 f5				push af  
3a06 3a 1a 3a			ld a, (.dmark)  
3a09 32 6e fe			ld (debug_mark),a  
3a0c 3a 1b 3a			ld a, (.dmark+1)  
3a0f 32 6f fe			ld (debug_mark+1),a  
3a12 3a 1c 3a			ld a, (.dmark+2)  
3a15 32 70 fe			ld (debug_mark+2),a  
3a18 18 03			jr .pastdmark  
3a1a ..			.dmark: db "MIN"  
3a1d f1			.pastdmark: pop af  
3a1e			endm  
# End of macro DMARK
3a1e						CALLMONITOR 
3a1e cd ab 18			call break_point_state  
3a21				endm  
# End of macro CALLMONITOR
3a21					endif 
3a21					; get u2 
3a21			 
3a21					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a21 cd 16 21			call macro_dsp_valuehl 
3a24				endm 
# End of macro FORTH_DSP_VALUEHL
3a24			 
3a24 e5					push hl   ; u2 
3a25			 
3a25					; destroy value TOS 
3a25			 
3a25					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a25 cd ce 21			call macro_forth_dsp_pop 
3a28				endm 
# End of macro FORTH_DSP_POP
3a28			 
3a28					; get u1 
3a28			 
3a28					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a28 cd 16 21			call macro_dsp_valuehl 
3a2b				endm 
# End of macro FORTH_DSP_VALUEHL
3a2b			 
3a2b e5					push hl  ; u1 
3a2c			 
3a2c					; destroy value TOS 
3a2c			 
3a2c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a2c cd ce 21			call macro_forth_dsp_pop 
3a2f				endm 
# End of macro FORTH_DSP_POP
3a2f			 
3a2f b7			 or a      ;clear carry flag 
3a30 e1			  pop hl    ; u1 
3a31 d1			  pop de    ; u2 
3a32 e5				push hl   ; saved in case hl is lowest 
3a33 ed 52		  sbc hl,de 
3a35 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3a37			 
3a37 e1				pop hl 
3a38					if DEBUG_FORTH_WORDS 
3a38						DMARK "MIN" 
3a38 f5				push af  
3a39 3a 4d 3a			ld a, (.dmark)  
3a3c 32 6e fe			ld (debug_mark),a  
3a3f 3a 4e 3a			ld a, (.dmark+1)  
3a42 32 6f fe			ld (debug_mark+1),a  
3a45 3a 4f 3a			ld a, (.dmark+2)  
3a48 32 70 fe			ld (debug_mark+2),a  
3a4b 18 03			jr .pastdmark  
3a4d ..			.dmark: db "MIN"  
3a50 f1			.pastdmark: pop af  
3a51			endm  
# End of macro DMARK
3a51						CALLMONITOR 
3a51 cd ab 18			call break_point_state  
3a54				endm  
# End of macro CALLMONITOR
3a54					endif 
3a54 cd 1f 1f				call forth_push_numhl 
3a57			 
3a57				       NEXTW 
3a57 c3 8d 22			jp macro_next 
3a5a				endm 
# End of macro NEXTW
3a5a			 
3a5a			.mincont:  
3a5a c1				pop bc   ; tidy up 
3a5b eb				ex de , hl  
3a5c					if DEBUG_FORTH_WORDS 
3a5c						DMARK "MI1" 
3a5c f5				push af  
3a5d 3a 71 3a			ld a, (.dmark)  
3a60 32 6e fe			ld (debug_mark),a  
3a63 3a 72 3a			ld a, (.dmark+1)  
3a66 32 6f fe			ld (debug_mark+1),a  
3a69 3a 73 3a			ld a, (.dmark+2)  
3a6c 32 70 fe			ld (debug_mark+2),a  
3a6f 18 03			jr .pastdmark  
3a71 ..			.dmark: db "MI1"  
3a74 f1			.pastdmark: pop af  
3a75			endm  
# End of macro DMARK
3a75						CALLMONITOR 
3a75 cd ab 18			call break_point_state  
3a78				endm  
# End of macro CALLMONITOR
3a78					endif 
3a78 cd 1f 1f				call forth_push_numhl 
3a7b			 
3a7b				       NEXTW 
3a7b c3 8d 22			jp macro_next 
3a7e				endm 
# End of macro NEXTW
3a7e			.MAX: 
3a7e				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3a7e 4a				db WORD_SYS_CORE+54             
3a7f ff 3a			dw .RND16            
3a81 04				db 3 + 1 
3a82 .. 00			db "MAX",0              
3a86				endm 
# End of macro CWHEAD
3a86			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3a86					if DEBUG_FORTH_WORDS_KEY 
3a86						DMARK "MAX" 
3a86 f5				push af  
3a87 3a 9b 3a			ld a, (.dmark)  
3a8a 32 6e fe			ld (debug_mark),a  
3a8d 3a 9c 3a			ld a, (.dmark+1)  
3a90 32 6f fe			ld (debug_mark+1),a  
3a93 3a 9d 3a			ld a, (.dmark+2)  
3a96 32 70 fe			ld (debug_mark+2),a  
3a99 18 03			jr .pastdmark  
3a9b ..			.dmark: db "MAX"  
3a9e f1			.pastdmark: pop af  
3a9f			endm  
# End of macro DMARK
3a9f						CALLMONITOR 
3a9f cd ab 18			call break_point_state  
3aa2				endm  
# End of macro CALLMONITOR
3aa2					endif 
3aa2					; get u2 
3aa2			 
3aa2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3aa2 cd 16 21			call macro_dsp_valuehl 
3aa5				endm 
# End of macro FORTH_DSP_VALUEHL
3aa5			 
3aa5 e5					push hl   ; u2 
3aa6			 
3aa6					; destroy value TOS 
3aa6			 
3aa6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3aa6 cd ce 21			call macro_forth_dsp_pop 
3aa9				endm 
# End of macro FORTH_DSP_POP
3aa9			 
3aa9					; get u1 
3aa9			 
3aa9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3aa9 cd 16 21			call macro_dsp_valuehl 
3aac				endm 
# End of macro FORTH_DSP_VALUEHL
3aac			 
3aac e5					push hl  ; u1 
3aad			 
3aad					; destroy value TOS 
3aad			 
3aad					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3aad cd ce 21			call macro_forth_dsp_pop 
3ab0				endm 
# End of macro FORTH_DSP_POP
3ab0			 
3ab0 b7			 or a      ;clear carry flag 
3ab1 e1			  pop hl    ; u1 
3ab2 d1			  pop de    ; u2 
3ab3 e5				push hl   ; saved in case hl is lowest 
3ab4 ed 52		  sbc hl,de 
3ab6 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3ab8			 
3ab8 e1				pop hl 
3ab9					if DEBUG_FORTH_WORDS 
3ab9						DMARK "MAX" 
3ab9 f5				push af  
3aba 3a ce 3a			ld a, (.dmark)  
3abd 32 6e fe			ld (debug_mark),a  
3ac0 3a cf 3a			ld a, (.dmark+1)  
3ac3 32 6f fe			ld (debug_mark+1),a  
3ac6 3a d0 3a			ld a, (.dmark+2)  
3ac9 32 70 fe			ld (debug_mark+2),a  
3acc 18 03			jr .pastdmark  
3ace ..			.dmark: db "MAX"  
3ad1 f1			.pastdmark: pop af  
3ad2			endm  
# End of macro DMARK
3ad2						CALLMONITOR 
3ad2 cd ab 18			call break_point_state  
3ad5				endm  
# End of macro CALLMONITOR
3ad5					endif 
3ad5 cd 1f 1f				call forth_push_numhl 
3ad8			 
3ad8				       NEXTW 
3ad8 c3 8d 22			jp macro_next 
3adb				endm 
# End of macro NEXTW
3adb			 
3adb			.maxcont:  
3adb c1				pop bc   ; tidy up 
3adc eb				ex de , hl  
3add					if DEBUG_FORTH_WORDS 
3add						DMARK "MA1" 
3add f5				push af  
3ade 3a f2 3a			ld a, (.dmark)  
3ae1 32 6e fe			ld (debug_mark),a  
3ae4 3a f3 3a			ld a, (.dmark+1)  
3ae7 32 6f fe			ld (debug_mark+1),a  
3aea 3a f4 3a			ld a, (.dmark+2)  
3aed 32 70 fe			ld (debug_mark+2),a  
3af0 18 03			jr .pastdmark  
3af2 ..			.dmark: db "MA1"  
3af5 f1			.pastdmark: pop af  
3af6			endm  
# End of macro DMARK
3af6						CALLMONITOR 
3af6 cd ab 18			call break_point_state  
3af9				endm  
# End of macro CALLMONITOR
3af9					endif 
3af9 cd 1f 1f				call forth_push_numhl 
3afc				       NEXTW 
3afc c3 8d 22			jp macro_next 
3aff				endm 
# End of macro NEXTW
3aff			 
3aff			.RND16: 
3aff				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3aff 4e				db WORD_SYS_CORE+58             
3b00 2e 3b			dw .RND8            
3b02 06				db 5 + 1 
3b03 .. 00			db "RND16",0              
3b09				endm 
# End of macro CWHEAD
3b09			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3b09					if DEBUG_FORTH_WORDS_KEY 
3b09						DMARK "R16" 
3b09 f5				push af  
3b0a 3a 1e 3b			ld a, (.dmark)  
3b0d 32 6e fe			ld (debug_mark),a  
3b10 3a 1f 3b			ld a, (.dmark+1)  
3b13 32 6f fe			ld (debug_mark+1),a  
3b16 3a 20 3b			ld a, (.dmark+2)  
3b19 32 70 fe			ld (debug_mark+2),a  
3b1c 18 03			jr .pastdmark  
3b1e ..			.dmark: db "R16"  
3b21 f1			.pastdmark: pop af  
3b22			endm  
# End of macro DMARK
3b22						CALLMONITOR 
3b22 cd ab 18			call break_point_state  
3b25				endm  
# End of macro CALLMONITOR
3b25					endif 
3b25 cd 2b 0e				call prng16  
3b28 cd 1f 1f				call forth_push_numhl 
3b2b				       NEXTW 
3b2b c3 8d 22			jp macro_next 
3b2e				endm 
# End of macro NEXTW
3b2e			.RND8: 
3b2e				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3b2e 60				db WORD_SYS_CORE+76             
3b2f 63 3b			dw .RND            
3b31 05				db 4 + 1 
3b32 .. 00			db "RND8",0              
3b37				endm 
# End of macro CWHEAD
3b37			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3b37					if DEBUG_FORTH_WORDS_KEY 
3b37						DMARK "RN8" 
3b37 f5				push af  
3b38 3a 4c 3b			ld a, (.dmark)  
3b3b 32 6e fe			ld (debug_mark),a  
3b3e 3a 4d 3b			ld a, (.dmark+1)  
3b41 32 6f fe			ld (debug_mark+1),a  
3b44 3a 4e 3b			ld a, (.dmark+2)  
3b47 32 70 fe			ld (debug_mark+2),a  
3b4a 18 03			jr .pastdmark  
3b4c ..			.dmark: db "RN8"  
3b4f f1			.pastdmark: pop af  
3b50			endm  
# End of macro DMARK
3b50						CALLMONITOR 
3b50 cd ab 18			call break_point_state  
3b53				endm  
# End of macro CALLMONITOR
3b53					endif 
3b53 2a af fb				ld hl,(xrandc) 
3b56 23					inc hl 
3b57 cd 45 0e				call xrnd 
3b5a 6f					ld l,a	 
3b5b 26 00				ld h,0 
3b5d cd 1f 1f				call forth_push_numhl 
3b60				       NEXTW 
3b60 c3 8d 22			jp macro_next 
3b63				endm 
# End of macro NEXTW
3b63			.RND: 
3b63				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3b63 60				db WORD_SYS_CORE+76             
3b64 69 3c			dw .ENDMATHS            
3b66 04				db 3 + 1 
3b67 .. 00			db "RND",0              
3b6b				endm 
# End of macro CWHEAD
3b6b			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3b6b			 
3b6b					if DEBUG_FORTH_WORDS_KEY 
3b6b						DMARK "RND" 
3b6b f5				push af  
3b6c 3a 80 3b			ld a, (.dmark)  
3b6f 32 6e fe			ld (debug_mark),a  
3b72 3a 81 3b			ld a, (.dmark+1)  
3b75 32 6f fe			ld (debug_mark+1),a  
3b78 3a 82 3b			ld a, (.dmark+2)  
3b7b 32 70 fe			ld (debug_mark+2),a  
3b7e 18 03			jr .pastdmark  
3b80 ..			.dmark: db "RND"  
3b83 f1			.pastdmark: pop af  
3b84			endm  
# End of macro DMARK
3b84						CALLMONITOR 
3b84 cd ab 18			call break_point_state  
3b87				endm  
# End of macro CALLMONITOR
3b87					endif 
3b87					 
3b87					FORTH_DSP_VALUEHL    ; upper range 
3b87 cd 16 21			call macro_dsp_valuehl 
3b8a				endm 
# End of macro FORTH_DSP_VALUEHL
3b8a			 
3b8a 22 b3 fb				ld (LFSRSeed), hl	 
3b8d			 
3b8d					if DEBUG_FORTH_WORDS 
3b8d						DMARK "RN1" 
3b8d f5				push af  
3b8e 3a a2 3b			ld a, (.dmark)  
3b91 32 6e fe			ld (debug_mark),a  
3b94 3a a3 3b			ld a, (.dmark+1)  
3b97 32 6f fe			ld (debug_mark+1),a  
3b9a 3a a4 3b			ld a, (.dmark+2)  
3b9d 32 70 fe			ld (debug_mark+2),a  
3ba0 18 03			jr .pastdmark  
3ba2 ..			.dmark: db "RN1"  
3ba5 f1			.pastdmark: pop af  
3ba6			endm  
# End of macro DMARK
3ba6						CALLMONITOR 
3ba6 cd ab 18			call break_point_state  
3ba9				endm  
# End of macro CALLMONITOR
3ba9					endif 
3ba9					FORTH_DSP_POP 
3ba9 cd ce 21			call macro_forth_dsp_pop 
3bac				endm 
# End of macro FORTH_DSP_POP
3bac			 
3bac					FORTH_DSP_VALUEHL    ; low range 
3bac cd 16 21			call macro_dsp_valuehl 
3baf				endm 
# End of macro FORTH_DSP_VALUEHL
3baf			 
3baf					if DEBUG_FORTH_WORDS 
3baf						DMARK "RN2" 
3baf f5				push af  
3bb0 3a c4 3b			ld a, (.dmark)  
3bb3 32 6e fe			ld (debug_mark),a  
3bb6 3a c5 3b			ld a, (.dmark+1)  
3bb9 32 6f fe			ld (debug_mark+1),a  
3bbc 3a c6 3b			ld a, (.dmark+2)  
3bbf 32 70 fe			ld (debug_mark+2),a  
3bc2 18 03			jr .pastdmark  
3bc4 ..			.dmark: db "RN2"  
3bc7 f1			.pastdmark: pop af  
3bc8			endm  
# End of macro DMARK
3bc8						CALLMONITOR 
3bc8 cd ab 18			call break_point_state  
3bcb				endm  
# End of macro CALLMONITOR
3bcb					endif 
3bcb 22 b5 fb				ld (LFSRSeed+2), hl 
3bce			 
3bce					FORTH_DSP_POP 
3bce cd ce 21			call macro_forth_dsp_pop 
3bd1				endm 
# End of macro FORTH_DSP_POP
3bd1			 
3bd1 e5					push hl 
3bd2			 
3bd2 e1			.inrange:	pop hl 
3bd3 cd 2b 0e				call prng16  
3bd6					if DEBUG_FORTH_WORDS 
3bd6						DMARK "RN3" 
3bd6 f5				push af  
3bd7 3a eb 3b			ld a, (.dmark)  
3bda 32 6e fe			ld (debug_mark),a  
3bdd 3a ec 3b			ld a, (.dmark+1)  
3be0 32 6f fe			ld (debug_mark+1),a  
3be3 3a ed 3b			ld a, (.dmark+2)  
3be6 32 70 fe			ld (debug_mark+2),a  
3be9 18 03			jr .pastdmark  
3beb ..			.dmark: db "RN3"  
3bee f1			.pastdmark: pop af  
3bef			endm  
# End of macro DMARK
3bef						CALLMONITOR 
3bef cd ab 18			call break_point_state  
3bf2				endm  
# End of macro CALLMONITOR
3bf2					endif 
3bf2					 
3bf2					; if the range is 8bit knock out the high byte 
3bf2			 
3bf2 ed 5b b3 fb			ld de, (LFSRSeed)     ; check high level 
3bf6			 
3bf6 3e 00				ld a, 0 
3bf8 ba					cp d  
3bf9 20 1e				jr nz, .hirange 
3bfb 26 00				ld h, 0   ; knock it down to 8bit 
3bfd			 
3bfd					if DEBUG_FORTH_WORDS 
3bfd						DMARK "RNk" 
3bfd f5				push af  
3bfe 3a 12 3c			ld a, (.dmark)  
3c01 32 6e fe			ld (debug_mark),a  
3c04 3a 13 3c			ld a, (.dmark+1)  
3c07 32 6f fe			ld (debug_mark+1),a  
3c0a 3a 14 3c			ld a, (.dmark+2)  
3c0d 32 70 fe			ld (debug_mark+2),a  
3c10 18 03			jr .pastdmark  
3c12 ..			.dmark: db "RNk"  
3c15 f1			.pastdmark: pop af  
3c16			endm  
# End of macro DMARK
3c16						CALLMONITOR 
3c16 cd ab 18			call break_point_state  
3c19				endm  
# End of macro CALLMONITOR
3c19					endif 
3c19			.hirange:   
3c19 e5					push hl  
3c1a b7					or a  
3c1b ed 52		                sbc hl, de 
3c1d			 
3c1d					;call cmp16 
3c1d			 
3c1d 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3c1f e1					pop hl 
3c20 e5					push hl 
3c21			 
3c21					if DEBUG_FORTH_WORDS 
3c21						DMARK "RN4" 
3c21 f5				push af  
3c22 3a 36 3c			ld a, (.dmark)  
3c25 32 6e fe			ld (debug_mark),a  
3c28 3a 37 3c			ld a, (.dmark+1)  
3c2b 32 6f fe			ld (debug_mark+1),a  
3c2e 3a 38 3c			ld a, (.dmark+2)  
3c31 32 70 fe			ld (debug_mark+2),a  
3c34 18 03			jr .pastdmark  
3c36 ..			.dmark: db "RN4"  
3c39 f1			.pastdmark: pop af  
3c3a			endm  
# End of macro DMARK
3c3a						CALLMONITOR 
3c3a cd ab 18			call break_point_state  
3c3d				endm  
# End of macro CALLMONITOR
3c3d					endif 
3c3d ed 5b b5 fb			ld de, (LFSRSeed+2)   ; check low range 
3c41					;call cmp16 
3c41				 
3c41 b7					or a  
3c42 ed 52		                sbc hl, de 
3c44 38 8c				jr c, .inrange 
3c46			 
3c46 e1					pop hl 
3c47					 
3c47					if DEBUG_FORTH_WORDS 
3c47						DMARK "RNd" 
3c47 f5				push af  
3c48 3a 5c 3c			ld a, (.dmark)  
3c4b 32 6e fe			ld (debug_mark),a  
3c4e 3a 5d 3c			ld a, (.dmark+1)  
3c51 32 6f fe			ld (debug_mark+1),a  
3c54 3a 5e 3c			ld a, (.dmark+2)  
3c57 32 70 fe			ld (debug_mark+2),a  
3c5a 18 03			jr .pastdmark  
3c5c ..			.dmark: db "RNd"  
3c5f f1			.pastdmark: pop af  
3c60			endm  
# End of macro DMARK
3c60						CALLMONITOR 
3c60 cd ab 18			call break_point_state  
3c63				endm  
# End of macro CALLMONITOR
3c63					endif 
3c63			 
3c63			 
3c63 cd 1f 1f				call forth_push_numhl 
3c66				       NEXTW 
3c66 c3 8d 22			jp macro_next 
3c69				endm 
# End of macro NEXTW
3c69			 
3c69			.ENDMATHS: 
3c69			 
3c69			; eof 
3c69			 
# End of file forth_words_maths.asm
3c69			include "forth_words_display.asm" 
3c69			 
3c69			; | ## Display Words 
3c69			 
3c69			.INFO: 
3c69			 
3c69				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3c69 62				db WORD_SYS_CORE+78             
3c6a 86 3c			dw .ATP            
3c6c 05				db 4 + 1 
3c6d .. 00			db "INFO",0              
3c72				endm 
# End of macro CWHEAD
3c72			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3c72					FORTH_DSP_VALUEHL 
3c72 cd 16 21			call macro_dsp_valuehl 
3c75				endm 
# End of macro FORTH_DSP_VALUEHL
3c75			 
3c75					FORTH_DSP_POP 
3c75 cd ce 21			call macro_forth_dsp_pop 
3c78				endm 
# End of macro FORTH_DSP_POP
3c78			 
3c78 e5					push hl 
3c79			 
3c79					FORTH_DSP_VALUEHL 
3c79 cd 16 21			call macro_dsp_valuehl 
3c7c				endm 
# End of macro FORTH_DSP_VALUEHL
3c7c			 
3c7c					FORTH_DSP_POP 
3c7c cd ce 21			call macro_forth_dsp_pop 
3c7f				endm 
# End of macro FORTH_DSP_POP
3c7f			 
3c7f d1					pop de 
3c80			 
3c80 cd 61 0c				call info_panel 
3c83			 
3c83			 
3c83					NEXTW 
3c83 c3 8d 22			jp macro_next 
3c86				endm 
# End of macro NEXTW
3c86			.ATP: 
3c86				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3c86 62				db WORD_SYS_CORE+78             
3c87 fd 3c			dw .FB            
3c89 04				db 3 + 1 
3c8a .. 00			db "AT?",0              
3c8e				endm 
# End of macro CWHEAD
3c8e			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3c8e					if DEBUG_FORTH_WORDS_KEY 
3c8e						DMARK "AT?" 
3c8e f5				push af  
3c8f 3a a3 3c			ld a, (.dmark)  
3c92 32 6e fe			ld (debug_mark),a  
3c95 3a a4 3c			ld a, (.dmark+1)  
3c98 32 6f fe			ld (debug_mark+1),a  
3c9b 3a a5 3c			ld a, (.dmark+2)  
3c9e 32 70 fe			ld (debug_mark+2),a  
3ca1 18 03			jr .pastdmark  
3ca3 ..			.dmark: db "AT?"  
3ca6 f1			.pastdmark: pop af  
3ca7			endm  
# End of macro DMARK
3ca7						CALLMONITOR 
3ca7 cd ab 18			call break_point_state  
3caa				endm  
# End of macro CALLMONITOR
3caa					endif 
3caa 3a 66 fa				ld a, (f_cursor_ptr) 
3cad			 
3cad			if DEBUG_FORTH_WORDS 
3cad				DMARK "AT?" 
3cad f5				push af  
3cae 3a c2 3c			ld a, (.dmark)  
3cb1 32 6e fe			ld (debug_mark),a  
3cb4 3a c3 3c			ld a, (.dmark+1)  
3cb7 32 6f fe			ld (debug_mark+1),a  
3cba 3a c4 3c			ld a, (.dmark+2)  
3cbd 32 70 fe			ld (debug_mark+2),a  
3cc0 18 03			jr .pastdmark  
3cc2 ..			.dmark: db "AT?"  
3cc5 f1			.pastdmark: pop af  
3cc6			endm  
# End of macro DMARK
3cc6				CALLMONITOR 
3cc6 cd ab 18			call break_point_state  
3cc9				endm  
# End of macro CALLMONITOR
3cc9			endif	 
3cc9					; count the number of rows 
3cc9			 
3cc9 06 00				ld b, 0 
3ccb 4f			.atpr:		ld c, a    ; save in case we go below zero 
3ccc d6 28				sub display_cols 
3cce f2 d4 3c				jp p, .atprunder 
3cd1 04					inc b 
3cd2 18 f7				jr .atpr 
3cd4			.atprunder:	 
3cd4			if DEBUG_FORTH_WORDS 
3cd4				DMARK "A?2" 
3cd4 f5				push af  
3cd5 3a e9 3c			ld a, (.dmark)  
3cd8 32 6e fe			ld (debug_mark),a  
3cdb 3a ea 3c			ld a, (.dmark+1)  
3cde 32 6f fe			ld (debug_mark+1),a  
3ce1 3a eb 3c			ld a, (.dmark+2)  
3ce4 32 70 fe			ld (debug_mark+2),a  
3ce7 18 03			jr .pastdmark  
3ce9 ..			.dmark: db "A?2"  
3cec f1			.pastdmark: pop af  
3ced			endm  
# End of macro DMARK
3ced				CALLMONITOR 
3ced cd ab 18			call break_point_state  
3cf0				endm  
# End of macro CALLMONITOR
3cf0			endif	 
3cf0 26 00				ld h, 0 
3cf2 69					ld l, c 
3cf3 cd 1f 1f				call forth_push_numhl 
3cf6 68					ld l, b  
3cf7 cd 1f 1f				call forth_push_numhl 
3cfa			 
3cfa			 
3cfa				NEXTW 
3cfa c3 8d 22			jp macro_next 
3cfd				endm 
# End of macro NEXTW
3cfd			 
3cfd			.FB: 
3cfd				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3cfd 1b				db WORD_SYS_CORE+7             
3cfe 4b 3d			dw .EMIT            
3d00 03				db 2 + 1 
3d01 .. 00			db "FB",0              
3d04				endm 
# End of macro CWHEAD
3d04			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3d04			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3d04			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3d04			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3d04					if DEBUG_FORTH_WORDS_KEY 
3d04						DMARK "FB." 
3d04 f5				push af  
3d05 3a 19 3d			ld a, (.dmark)  
3d08 32 6e fe			ld (debug_mark),a  
3d0b 3a 1a 3d			ld a, (.dmark+1)  
3d0e 32 6f fe			ld (debug_mark+1),a  
3d11 3a 1b 3d			ld a, (.dmark+2)  
3d14 32 70 fe			ld (debug_mark+2),a  
3d17 18 03			jr .pastdmark  
3d19 ..			.dmark: db "FB."  
3d1c f1			.pastdmark: pop af  
3d1d			endm  
# End of macro DMARK
3d1d						CALLMONITOR 
3d1d cd ab 18			call break_point_state  
3d20				endm  
# End of macro CALLMONITOR
3d20					endif 
3d20			 
3d20					FORTH_DSP_VALUEHL 
3d20 cd 16 21			call macro_dsp_valuehl 
3d23				endm 
# End of macro FORTH_DSP_VALUEHL
3d23			 
3d23 7d					ld a, l 
3d24 fe 01				cp 1 
3d26 20 05				jr nz, .fbn1 
3d28 21 13 fd				ld hl, display_fb1 
3d2b 18 15				jr .fbset 
3d2d fe 02		.fbn1:		cp 2 
3d2f 20 05				jr nz, .fbn2 
3d31 21 d1 fb				ld hl, display_fb2 
3d34 18 0c				jr .fbset 
3d36 fe 03		.fbn2:		cp 3 
3d38 20 05				jr nz, .fbn3 
3d3a 21 72 fc				ld hl, display_fb3 
3d3d 18 03				jr .fbset 
3d3f			.fbn3:		 ; if invalid number select first 
3d3f 21 13 fd				ld hl, display_fb1 
3d42 22 cf fb		.fbset:		ld (display_fb_active), hl 
3d45			 
3d45					FORTH_DSP_POP 
3d45 cd ce 21			call macro_forth_dsp_pop 
3d48				endm 
# End of macro FORTH_DSP_POP
3d48			 
3d48					NEXTW 
3d48 c3 8d 22			jp macro_next 
3d4b				endm 
# End of macro NEXTW
3d4b			 
3d4b			 
3d4b			.EMIT: 
3d4b				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3d4b 1b				db WORD_SYS_CORE+7             
3d4c 9c 3d			dw .DOTH            
3d4e 05				db 4 + 1 
3d4f .. 00			db "EMIT",0              
3d54				endm 
# End of macro CWHEAD
3d54			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3d54					; get value off TOS and display it 
3d54			 
3d54					if DEBUG_FORTH_WORDS_KEY 
3d54						DMARK "EMT" 
3d54 f5				push af  
3d55 3a 69 3d			ld a, (.dmark)  
3d58 32 6e fe			ld (debug_mark),a  
3d5b 3a 6a 3d			ld a, (.dmark+1)  
3d5e 32 6f fe			ld (debug_mark+1),a  
3d61 3a 6b 3d			ld a, (.dmark+2)  
3d64 32 70 fe			ld (debug_mark+2),a  
3d67 18 03			jr .pastdmark  
3d69 ..			.dmark: db "EMT"  
3d6c f1			.pastdmark: pop af  
3d6d			endm  
# End of macro DMARK
3d6d						CALLMONITOR 
3d6d cd ab 18			call break_point_state  
3d70				endm  
# End of macro CALLMONITOR
3d70					endif 
3d70			 
3d70					FORTH_DSP_VALUEHL 
3d70 cd 16 21			call macro_dsp_valuehl 
3d73				endm 
# End of macro FORTH_DSP_VALUEHL
3d73			 
3d73 7d					ld a,l 
3d74			 
3d74					; TODO write to display 
3d74			 
3d74 32 fb f3				ld (os_input), a 
3d77 3e 00				ld a, 0 
3d79 32 fc f3				ld (os_input+1), a 
3d7c					 
3d7c 3a 66 fa				ld a, (f_cursor_ptr) 
3d7f 11 fb f3				ld de, os_input 
3d82 cd e3 0c				call str_at_display 
3d85			 
3d85			 
3d85 3a 44 fa				ld a,(cli_autodisplay) 
3d88 fe 00				cp 0 
3d8a 28 03				jr z, .enoupdate 
3d8c cd f3 0c						call update_display 
3d8f					.enoupdate: 
3d8f			 
3d8f 3a 66 fa				ld a, (f_cursor_ptr) 
3d92 3c					inc a 
3d93 32 66 fa				ld (f_cursor_ptr), a   ; save new pos 
3d96			 
3d96			 
3d96					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d96 cd ce 21			call macro_forth_dsp_pop 
3d99				endm 
# End of macro FORTH_DSP_POP
3d99			  
3d99			 
3d99					NEXTW 
3d99 c3 8d 22			jp macro_next 
3d9c				endm 
# End of macro NEXTW
3d9c			.DOTH: 
3d9c				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3d9c 1c				db WORD_SYS_CORE+8             
3d9d cc 3d			dw .DOTF            
3d9f 03				db 2 + 1 
3da0 .. 00			db ".-",0              
3da3				endm 
# End of macro CWHEAD
3da3			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3da3					; get value off TOS and display it 
3da3					if DEBUG_FORTH_WORDS_KEY 
3da3						DMARK "DTD" 
3da3 f5				push af  
3da4 3a b8 3d			ld a, (.dmark)  
3da7 32 6e fe			ld (debug_mark),a  
3daa 3a b9 3d			ld a, (.dmark+1)  
3dad 32 6f fe			ld (debug_mark+1),a  
3db0 3a ba 3d			ld a, (.dmark+2)  
3db3 32 70 fe			ld (debug_mark+2),a  
3db6 18 03			jr .pastdmark  
3db8 ..			.dmark: db "DTD"  
3dbb f1			.pastdmark: pop af  
3dbc			endm  
# End of macro DMARK
3dbc						CALLMONITOR 
3dbc cd ab 18			call break_point_state  
3dbf				endm  
# End of macro CALLMONITOR
3dbf					endif 
3dbf 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3dc1 3e 00			ld a, 0 
3dc3 32 45 fa			ld (cli_mvdot), a 
3dc6 c3 23 3e			jp .dotgo 
3dc9				NEXTW 
3dc9 c3 8d 22			jp macro_next 
3dcc				endm 
# End of macro NEXTW
3dcc			.DOTF: 
3dcc				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3dcc 1c				db WORD_SYS_CORE+8             
3dcd fa 3d			dw .DOT            
3dcf 03				db 2 + 1 
3dd0 .. 00			db ".>",0              
3dd3				endm 
# End of macro CWHEAD
3dd3			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3dd3					; get value off TOS and display it 
3dd3			        ; TODO BUG adds extra spaces 
3dd3			        ; TODO BUG handle numerics? 
3dd3					if DEBUG_FORTH_WORDS_KEY 
3dd3						DMARK "DTC" 
3dd3 f5				push af  
3dd4 3a e8 3d			ld a, (.dmark)  
3dd7 32 6e fe			ld (debug_mark),a  
3dda 3a e9 3d			ld a, (.dmark+1)  
3ddd 32 6f fe			ld (debug_mark+1),a  
3de0 3a ea 3d			ld a, (.dmark+2)  
3de3 32 70 fe			ld (debug_mark+2),a  
3de6 18 03			jr .pastdmark  
3de8 ..			.dmark: db "DTC"  
3deb f1			.pastdmark: pop af  
3dec			endm  
# End of macro DMARK
3dec						CALLMONITOR 
3dec cd ab 18			call break_point_state  
3def				endm  
# End of macro CALLMONITOR
3def					endif 
3def 3e 01			ld a, 1 
3df1 32 45 fa			ld (cli_mvdot), a 
3df4 c3 23 3e			jp .dotgo 
3df7				NEXTW 
3df7 c3 8d 22			jp macro_next 
3dfa				endm 
# End of macro NEXTW
3dfa			 
3dfa			.DOT: 
3dfa				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3dfa 1c				db WORD_SYS_CORE+8             
3dfb 86 3e			dw .CLS            
3dfd 02				db 1 + 1 
3dfe .. 00			db ".",0              
3e00				endm 
# End of macro CWHEAD
3e00			        ; | . ( u -- ) Display TOS | DONE 
3e00					; get value off TOS and display it 
3e00			 
3e00					if DEBUG_FORTH_WORDS_KEY 
3e00						DMARK "DOT" 
3e00 f5				push af  
3e01 3a 15 3e			ld a, (.dmark)  
3e04 32 6e fe			ld (debug_mark),a  
3e07 3a 16 3e			ld a, (.dmark+1)  
3e0a 32 6f fe			ld (debug_mark+1),a  
3e0d 3a 17 3e			ld a, (.dmark+2)  
3e10 32 70 fe			ld (debug_mark+2),a  
3e13 18 03			jr .pastdmark  
3e15 ..			.dmark: db "DOT"  
3e18 f1			.pastdmark: pop af  
3e19			endm  
# End of macro DMARK
3e19						CALLMONITOR 
3e19 cd ab 18			call break_point_state  
3e1c				endm  
# End of macro CALLMONITOR
3e1c					endif 
3e1c 3e 00			ld a, 0 
3e1e 32 45 fa			ld (cli_mvdot), a 
3e21 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3e23				 
3e23			 
3e23			.dotgo: 
3e23			 
3e23			; move up type to on stack for parserv5 
3e23					FORTH_DSP 
3e23 cd dc 20			call macro_forth_dsp 
3e26				endm 
# End of macro FORTH_DSP
3e26				;FORTH_DSP_VALUE  
3e26			 
3e26			if DEBUG_FORTH_DOT 
3e26				DMARK "DOT" 
3e26				CALLMONITOR 
3e26			endif	 
3e26			;		.print: 
3e26			 
3e26 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3e27 23				inc hl   ; position to the actual value 
3e28 fe 01			cp DS_TYPE_STR 
3e2a 20 06			jr nz, .dotnum1  
3e2c			 
3e2c			; display string 
3e2c				FORTH_DSP_VALUE  
3e2c cd ff 20			call macro_forth_dsp_value 
3e2f				endm 
# End of macro FORTH_DSP_VALUE
3e2f eb				ex de,hl 
3e30 18 11			jr .dotwrite 
3e32			 
3e32			.dotnum1: 
3e32 fe 02			cp DS_TYPE_INUM 
3e34 20 0c			jr nz, .dotflot 
3e36			 
3e36			 
3e36			; display number 
3e36			 
3e36			;	push hl 
3e36			;	call clear_display 
3e36			;	pop hl 
3e36			 
3e36 5e				ld e, (hl) 
3e37 23				inc hl 
3e38 56				ld d, (hl) 
3e39 21 fd f1			ld hl, scratch 
3e3c			if DEBUG_FORTH_DOT 
3e3c				DMARK "DT1" 
3e3c				CALLMONITOR 
3e3c			endif	 
3e3c			 
3e3c cd 11 13			call uitoa_16 
3e3f eb				ex de,hl 
3e40			 
3e40			if DEBUG_FORTH_DOT 
3e40				DMARK "DT2" 
3e40				CALLMONITOR 
3e40			endif	 
3e40			 
3e40			;	ld de, os_word_scratch 
3e40 18 01			jr .dotwrite 
3e42			 
3e42 00			.dotflot:   nop 
3e43			; TODO print floating point number 
3e43			 
3e43			.dotwrite:		 
3e43			 
3e43					; if c is set then set all '-' to spaces 
3e43					; need to also take into account .>  
3e43			 
3e43 3e 01				ld a, 1 
3e45 b9					cp c 
3e46 20 13				jr nz, .nodashswap 
3e48			 
3e48					; DE has the string to write, working with HL 
3e48			 
3e48 06 ff				ld b, 255 
3e4a d5					push de 
3e4b e1					pop hl 
3e4c			 
3e4c			if DEBUG_FORTH_DOT 
3e4c				DMARK "DT-" 
3e4c				CALLMONITOR 
3e4c			endif	 
3e4c 7e			.dashscan:	ld a, (hl) 
3e4d fe 00				cp 0 
3e4f 28 0a				jr z, .nodashswap 
3e51 fe 2d				cp '-' 
3e53 20 03				jr nz, .dashskip 
3e55 3e 20				ld a, ' ' 
3e57 77					ld (hl), a 
3e58 23			.dashskip:	inc hl 
3e59			if DEBUG_FORTH_DOT 
3e59				DMARK "D-2" 
3e59				CALLMONITOR 
3e59			endif	 
3e59 10 f1				djnz .dashscan 
3e5b			 
3e5b			if DEBUG_FORTH_DOT 
3e5b				DMARK "D-1" 
3e5b				CALLMONITOR 
3e5b			endif	 
3e5b			 
3e5b			.nodashswap: 
3e5b			 
3e5b e5					push hl   ; save string start in case we need to advance print 
3e5c			 
3e5c 3a 66 fa				ld a, (f_cursor_ptr) 
3e5f cd e3 0c				call str_at_display 
3e62 3a 44 fa				ld a,(cli_autodisplay) 
3e65 fe 00				cp 0 
3e67 28 03				jr z, .noupdate 
3e69 cd f3 0c						call update_display 
3e6c					.noupdate: 
3e6c			 
3e6c			 
3e6c					; see if we need to advance the print position 
3e6c			 
3e6c e1					pop hl   ; get back string 
3e6d			 
3e6d 3a 45 fa				ld a, (cli_mvdot) 
3e70			if DEBUG_FORTH_DOT 
3e70					ld e,a 
3e70				DMARK "D>1" 
3e70				CALLMONITOR 
3e70			endif	 
3e70 fe 00				cp 0 
3e72 28 0c				jr z, .noadv 
3e74					; yes, lets advance the print position 
3e74 3e 00				ld a, 0 
3e76 cd 6d 13				call strlent 
3e79 3a 66 fa				ld a, (f_cursor_ptr) 
3e7c 85					add a,l 
3e7d					;call addatohl 
3e7d					;ld a, l 
3e7d 32 66 fa				ld (f_cursor_ptr), a   ; save new pos 
3e80			 
3e80			if DEBUG_FORTH_DOT 
3e80				DMARK "D->" 
3e80				CALLMONITOR 
3e80			endif	 
3e80			 
3e80			.noadv:	 
3e80			 
3e80					if DEBUG_FORTH_DOT_WAIT 
3e80							call next_page_prompt 
3e80					endif	 
3e80			; TODO this pop off the stack causes a crash. i dont know why 
3e80			 
3e80			 
3e80			if DEBUG_FORTH_DOT 
3e80				DMARK "DTh" 
3e80				CALLMONITOR 
3e80			endif	 
3e80			 
3e80					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e80 cd ce 21			call macro_forth_dsp_pop 
3e83				endm 
# End of macro FORTH_DSP_POP
3e83			 
3e83			if DEBUG_FORTH_DOT 
3e83				DMARK "DTi" 
3e83				CALLMONITOR 
3e83			endif	 
3e83			 
3e83			 
3e83					NEXTW 
3e83 c3 8d 22			jp macro_next 
3e86				endm 
# End of macro NEXTW
3e86			 
3e86			.CLS: 
3e86				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3e86 35				db WORD_SYS_CORE+33             
3e87 b3 3e			dw .DRAW            
3e89 04				db 3 + 1 
3e8a .. 00			db "CLS",0              
3e8e				endm 
# End of macro CWHEAD
3e8e			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3e8e					if DEBUG_FORTH_WORDS_KEY 
3e8e						DMARK "CLS" 
3e8e f5				push af  
3e8f 3a a3 3e			ld a, (.dmark)  
3e92 32 6e fe			ld (debug_mark),a  
3e95 3a a4 3e			ld a, (.dmark+1)  
3e98 32 6f fe			ld (debug_mark+1),a  
3e9b 3a a5 3e			ld a, (.dmark+2)  
3e9e 32 70 fe			ld (debug_mark+2),a  
3ea1 18 03			jr .pastdmark  
3ea3 ..			.dmark: db "CLS"  
3ea6 f1			.pastdmark: pop af  
3ea7			endm  
# End of macro DMARK
3ea7						CALLMONITOR 
3ea7 cd ab 18			call break_point_state  
3eaa				endm  
# End of macro CALLMONITOR
3eaa					endif 
3eaa cd d0 0c				call clear_display 
3ead c3 c1 3f				jp .home		; and home cursor 
3eb0					NEXTW 
3eb0 c3 8d 22			jp macro_next 
3eb3				endm 
# End of macro NEXTW
3eb3			 
3eb3			.DRAW: 
3eb3				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3eb3 36				db WORD_SYS_CORE+34             
3eb4 de 3e			dw .DUMP            
3eb6 05				db 4 + 1 
3eb7 .. 00			db "DRAW",0              
3ebc				endm 
# End of macro CWHEAD
3ebc			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3ebc					if DEBUG_FORTH_WORDS_KEY 
3ebc						DMARK "DRW" 
3ebc f5				push af  
3ebd 3a d1 3e			ld a, (.dmark)  
3ec0 32 6e fe			ld (debug_mark),a  
3ec3 3a d2 3e			ld a, (.dmark+1)  
3ec6 32 6f fe			ld (debug_mark+1),a  
3ec9 3a d3 3e			ld a, (.dmark+2)  
3ecc 32 70 fe			ld (debug_mark+2),a  
3ecf 18 03			jr .pastdmark  
3ed1 ..			.dmark: db "DRW"  
3ed4 f1			.pastdmark: pop af  
3ed5			endm  
# End of macro DMARK
3ed5						CALLMONITOR 
3ed5 cd ab 18			call break_point_state  
3ed8				endm  
# End of macro CALLMONITOR
3ed8					endif 
3ed8 cd f3 0c				call update_display 
3edb					NEXTW 
3edb c3 8d 22			jp macro_next 
3ede				endm 
# End of macro NEXTW
3ede			 
3ede			.DUMP: 
3ede				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3ede 37				db WORD_SYS_CORE+35             
3edf 16 3f			dw .CDUMP            
3ee1 05				db 4 + 1 
3ee2 .. 00			db "DUMP",0              
3ee7				endm 
# End of macro CWHEAD
3ee7			; | DUMP ( x -- ) With address x display dump   | DONE 
3ee7			; TODO pop address to use off of the stack 
3ee7					if DEBUG_FORTH_WORDS_KEY 
3ee7						DMARK "DUM" 
3ee7 f5				push af  
3ee8 3a fc 3e			ld a, (.dmark)  
3eeb 32 6e fe			ld (debug_mark),a  
3eee 3a fd 3e			ld a, (.dmark+1)  
3ef1 32 6f fe			ld (debug_mark+1),a  
3ef4 3a fe 3e			ld a, (.dmark+2)  
3ef7 32 70 fe			ld (debug_mark+2),a  
3efa 18 03			jr .pastdmark  
3efc ..			.dmark: db "DUM"  
3eff f1			.pastdmark: pop af  
3f00			endm  
# End of macro DMARK
3f00						CALLMONITOR 
3f00 cd ab 18			call break_point_state  
3f03				endm  
# End of macro CALLMONITOR
3f03					endif 
3f03 cd d0 0c				call clear_display 
3f06			 
3f06					; get address 
3f06			 
3f06					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f06 cd 16 21			call macro_dsp_valuehl 
3f09				endm 
# End of macro FORTH_DSP_VALUEHL
3f09				 
3f09					; save it for cdump 
3f09			 
3f09 22 20 f5				ld (os_cur_ptr),hl 
3f0c			 
3f0c					; destroy value TOS 
3f0c			 
3f0c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f0c cd ce 21			call macro_forth_dsp_pop 
3f0f				endm 
# End of macro FORTH_DSP_POP
3f0f			 
3f0f cd 9f 1d				call dumpcont	; skip old style of param parsing	 
3f12 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3f13					NEXTW 
3f13 c3 8d 22			jp macro_next 
3f16				endm 
# End of macro NEXTW
3f16			.CDUMP: 
3f16				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3f16 38				db WORD_SYS_CORE+36             
3f17 46 3f			dw .DAT            
3f19 06				db 5 + 1 
3f1a .. 00			db "CDUMP",0              
3f20				endm 
# End of macro CWHEAD
3f20			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3f20					if DEBUG_FORTH_WORDS_KEY 
3f20						DMARK "CDP" 
3f20 f5				push af  
3f21 3a 35 3f			ld a, (.dmark)  
3f24 32 6e fe			ld (debug_mark),a  
3f27 3a 36 3f			ld a, (.dmark+1)  
3f2a 32 6f fe			ld (debug_mark+1),a  
3f2d 3a 37 3f			ld a, (.dmark+2)  
3f30 32 70 fe			ld (debug_mark+2),a  
3f33 18 03			jr .pastdmark  
3f35 ..			.dmark: db "CDP"  
3f38 f1			.pastdmark: pop af  
3f39			endm  
# End of macro DMARK
3f39						CALLMONITOR 
3f39 cd ab 18			call break_point_state  
3f3c				endm  
# End of macro CALLMONITOR
3f3c					endif 
3f3c cd d0 0c				call clear_display 
3f3f cd 9f 1d				call dumpcont	 
3f42 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3f43					NEXTW 
3f43 c3 8d 22			jp macro_next 
3f46				endm 
# End of macro NEXTW
3f46			 
3f46			 
3f46			 
3f46			 
3f46			.DAT: 
3f46				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3f46 3d				db WORD_SYS_CORE+41             
3f47 9c 3f			dw .HOME            
3f49 03				db 2 + 1 
3f4a .. 00			db "AT",0              
3f4d				endm 
# End of macro CWHEAD
3f4d			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3f4d					if DEBUG_FORTH_WORDS_KEY 
3f4d						DMARK "AT." 
3f4d f5				push af  
3f4e 3a 62 3f			ld a, (.dmark)  
3f51 32 6e fe			ld (debug_mark),a  
3f54 3a 63 3f			ld a, (.dmark+1)  
3f57 32 6f fe			ld (debug_mark+1),a  
3f5a 3a 64 3f			ld a, (.dmark+2)  
3f5d 32 70 fe			ld (debug_mark+2),a  
3f60 18 03			jr .pastdmark  
3f62 ..			.dmark: db "AT."  
3f65 f1			.pastdmark: pop af  
3f66			endm  
# End of macro DMARK
3f66						CALLMONITOR 
3f66 cd ab 18			call break_point_state  
3f69				endm  
# End of macro CALLMONITOR
3f69					endif 
3f69					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f69 cd 16 21			call macro_dsp_valuehl 
3f6c				endm 
# End of macro FORTH_DSP_VALUEHL
3f6c			 
3f6c			 
3f6c					; TODO save cursor row 
3f6c 7d					ld a,l 
3f6d fe 02				cp 2 
3f6f 20 04				jr nz, .crow3 
3f71 3e 28				ld a, display_row_2 
3f73 18 12				jr .ccol1 
3f75 fe 03		.crow3:		cp 3 
3f77 20 04				jr nz, .crow4 
3f79 3e 50				ld a, display_row_3 
3f7b 18 0a				jr .ccol1 
3f7d fe 04		.crow4:		cp 4 
3f7f 20 04				jr nz, .crow1 
3f81 3e 78				ld a, display_row_4 
3f83 18 02				jr .ccol1 
3f85 3e 00		.crow1:		ld a,display_row_1 
3f87 f5			.ccol1:		push af			; got row offset 
3f88 6f					ld l,a 
3f89 26 00				ld h,0 
3f8b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f8b cd ce 21			call macro_forth_dsp_pop 
3f8e				endm 
# End of macro FORTH_DSP_POP
3f8e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f8e cd 16 21			call macro_dsp_valuehl 
3f91				endm 
# End of macro FORTH_DSP_VALUEHL
3f91					; TODO save cursor col 
3f91 f1					pop af 
3f92 85					add l		; add col offset 
3f93 32 66 fa				ld (f_cursor_ptr), a 
3f96					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f96 cd ce 21			call macro_forth_dsp_pop 
3f99				endm 
# End of macro FORTH_DSP_POP
3f99			 
3f99					; calculate  
3f99			 
3f99					NEXTW 
3f99 c3 8d 22			jp macro_next 
3f9c				endm 
# End of macro NEXTW
3f9c			 
3f9c			 
3f9c			.HOME: 
3f9c				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3f9c 41				db WORD_SYS_CORE+45             
3f9d c9 3f			dw .SPACE            
3f9f 05				db 4 + 1 
3fa0 .. 00			db "HOME",0              
3fa5				endm 
# End of macro CWHEAD
3fa5			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3fa5					if DEBUG_FORTH_WORDS_KEY 
3fa5						DMARK "HOM" 
3fa5 f5				push af  
3fa6 3a ba 3f			ld a, (.dmark)  
3fa9 32 6e fe			ld (debug_mark),a  
3fac 3a bb 3f			ld a, (.dmark+1)  
3faf 32 6f fe			ld (debug_mark+1),a  
3fb2 3a bc 3f			ld a, (.dmark+2)  
3fb5 32 70 fe			ld (debug_mark+2),a  
3fb8 18 03			jr .pastdmark  
3fba ..			.dmark: db "HOM"  
3fbd f1			.pastdmark: pop af  
3fbe			endm  
# End of macro DMARK
3fbe						CALLMONITOR 
3fbe cd ab 18			call break_point_state  
3fc1				endm  
# End of macro CALLMONITOR
3fc1					endif 
3fc1 3e 00		.home:		ld a, 0		; and home cursor 
3fc3 32 66 fa				ld (f_cursor_ptr), a 
3fc6					NEXTW 
3fc6 c3 8d 22			jp macro_next 
3fc9				endm 
# End of macro NEXTW
3fc9			 
3fc9			 
3fc9			.SPACE: 
3fc9				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3fc9 46				db WORD_SYS_CORE+50             
3fca f7 3f			dw .SPACES            
3fcc 03				db 2 + 1 
3fcd .. 00			db "BL",0              
3fd0				endm 
# End of macro CWHEAD
3fd0			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3fd0					if DEBUG_FORTH_WORDS_KEY 
3fd0						DMARK "BL." 
3fd0 f5				push af  
3fd1 3a e5 3f			ld a, (.dmark)  
3fd4 32 6e fe			ld (debug_mark),a  
3fd7 3a e6 3f			ld a, (.dmark+1)  
3fda 32 6f fe			ld (debug_mark+1),a  
3fdd 3a e7 3f			ld a, (.dmark+2)  
3fe0 32 70 fe			ld (debug_mark+2),a  
3fe3 18 03			jr .pastdmark  
3fe5 ..			.dmark: db "BL."  
3fe8 f1			.pastdmark: pop af  
3fe9			endm  
# End of macro DMARK
3fe9						CALLMONITOR 
3fe9 cd ab 18			call break_point_state  
3fec				endm  
# End of macro CALLMONITOR
3fec					endif 
3fec 21 f5 3f				ld hl, .blstr 
3fef cd 8d 1f				call forth_push_str 
3ff2					 
3ff2				       NEXTW 
3ff2 c3 8d 22			jp macro_next 
3ff5				endm 
# End of macro NEXTW
3ff5			 
3ff5 .. 00		.blstr: db " ", 0 
3ff7			 
3ff7			.SPACES: 
3ff7				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3ff7 47				db WORD_SYS_CORE+51             
3ff8 92 40			dw .SCROLL            
3ffa 07				db 6 + 1 
3ffb .. 00			db "SPACES",0              
4002				endm 
# End of macro CWHEAD
4002			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
4002					if DEBUG_FORTH_WORDS_KEY 
4002						DMARK "SPS" 
4002 f5				push af  
4003 3a 17 40			ld a, (.dmark)  
4006 32 6e fe			ld (debug_mark),a  
4009 3a 18 40			ld a, (.dmark+1)  
400c 32 6f fe			ld (debug_mark+1),a  
400f 3a 19 40			ld a, (.dmark+2)  
4012 32 70 fe			ld (debug_mark+2),a  
4015 18 03			jr .pastdmark  
4017 ..			.dmark: db "SPS"  
401a f1			.pastdmark: pop af  
401b			endm  
# End of macro DMARK
401b						CALLMONITOR 
401b cd ab 18			call break_point_state  
401e				endm  
# End of macro CALLMONITOR
401e					endif 
401e			 
401e			 
401e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
401e cd 16 21			call macro_dsp_valuehl 
4021				endm 
# End of macro FORTH_DSP_VALUEHL
4021			 
4021			;		push hl    ; u 
4021					if DEBUG_FORTH_WORDS 
4021						DMARK "SPA" 
4021 f5				push af  
4022 3a 36 40			ld a, (.dmark)  
4025 32 6e fe			ld (debug_mark),a  
4028 3a 37 40			ld a, (.dmark+1)  
402b 32 6f fe			ld (debug_mark+1),a  
402e 3a 38 40			ld a, (.dmark+2)  
4031 32 70 fe			ld (debug_mark+2),a  
4034 18 03			jr .pastdmark  
4036 ..			.dmark: db "SPA"  
4039 f1			.pastdmark: pop af  
403a			endm  
# End of macro DMARK
403a						CALLMONITOR 
403a cd ab 18			call break_point_state  
403d				endm  
# End of macro CALLMONITOR
403d					endif 
403d			 
403d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
403d cd ce 21			call macro_forth_dsp_pop 
4040				endm 
# End of macro FORTH_DSP_POP
4040			;		pop hl 
4040 4d					ld c, l 
4041 06 00				ld b, 0 
4043 21 fd f1				ld hl, scratch  
4046			 
4046					if DEBUG_FORTH_WORDS 
4046						DMARK "SP2" 
4046 f5				push af  
4047 3a 5b 40			ld a, (.dmark)  
404a 32 6e fe			ld (debug_mark),a  
404d 3a 5c 40			ld a, (.dmark+1)  
4050 32 6f fe			ld (debug_mark+1),a  
4053 3a 5d 40			ld a, (.dmark+2)  
4056 32 70 fe			ld (debug_mark+2),a  
4059 18 03			jr .pastdmark  
405b ..			.dmark: db "SP2"  
405e f1			.pastdmark: pop af  
405f			endm  
# End of macro DMARK
405f						CALLMONITOR 
405f cd ab 18			call break_point_state  
4062				endm  
# End of macro CALLMONITOR
4062					endif 
4062 3e 20				ld a, ' ' 
4064 c5			.spaces1:	push bc 
4065 77					ld (hl),a 
4066 23					inc hl 
4067 c1					pop bc 
4068 10 fa				djnz .spaces1 
406a 3e 00				ld a,0 
406c 77					ld (hl),a 
406d 21 fd f1				ld hl, scratch 
4070					if DEBUG_FORTH_WORDS 
4070						DMARK "SP3" 
4070 f5				push af  
4071 3a 85 40			ld a, (.dmark)  
4074 32 6e fe			ld (debug_mark),a  
4077 3a 86 40			ld a, (.dmark+1)  
407a 32 6f fe			ld (debug_mark+1),a  
407d 3a 87 40			ld a, (.dmark+2)  
4080 32 70 fe			ld (debug_mark+2),a  
4083 18 03			jr .pastdmark  
4085 ..			.dmark: db "SP3"  
4088 f1			.pastdmark: pop af  
4089			endm  
# End of macro DMARK
4089						CALLMONITOR 
4089 cd ab 18			call break_point_state  
408c				endm  
# End of macro CALLMONITOR
408c					endif 
408c cd 88 20				call forth_apush 
408f			 
408f				       NEXTW 
408f c3 8d 22			jp macro_next 
4092				endm 
# End of macro NEXTW
4092			 
4092			 
4092			 
4092			.SCROLL: 
4092				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
4092 53				db WORD_SYS_CORE+63             
4093 bf 40			dw .SCROLLD            
4095 07				db 6 + 1 
4096 .. 00			db "SCROLL",0              
409d				endm 
# End of macro CWHEAD
409d			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
409d					if DEBUG_FORTH_WORDS_KEY 
409d						DMARK "SCR" 
409d f5				push af  
409e 3a b2 40			ld a, (.dmark)  
40a1 32 6e fe			ld (debug_mark),a  
40a4 3a b3 40			ld a, (.dmark+1)  
40a7 32 6f fe			ld (debug_mark+1),a  
40aa 3a b4 40			ld a, (.dmark+2)  
40ad 32 70 fe			ld (debug_mark+2),a  
40b0 18 03			jr .pastdmark  
40b2 ..			.dmark: db "SCR"  
40b5 f1			.pastdmark: pop af  
40b6			endm  
# End of macro DMARK
40b6						CALLMONITOR 
40b6 cd ab 18			call break_point_state  
40b9				endm  
# End of macro CALLMONITOR
40b9					endif 
40b9			 
40b9 cd 92 0c			call scroll_up 
40bc			;	call update_display 
40bc			 
40bc					NEXTW 
40bc c3 8d 22			jp macro_next 
40bf				endm 
# End of macro NEXTW
40bf			 
40bf			 
40bf			 
40bf			;		; get dir 
40bf			; 
40bf			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
40bf			; 
40bf			;		push hl 
40bf			; 
40bf			;		; destroy value TOS 
40bf			; 
40bf			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40bf			; 
40bf			;		; get count 
40bf			; 
40bf			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
40bf			; 
40bf			;		push hl 
40bf			; 
40bf			;		; destroy value TOS 
40bf			; 
40bf			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40bf			; 
40bf			;		; one value on hl get other one back 
40bf			; 
40bf			;		pop bc    ; count 
40bf			; 
40bf			;		pop de   ; dir 
40bf			; 
40bf			; 
40bf			;		ld b, c 
40bf			; 
40bf			;.scrolldir:     push bc 
40bf			;		push de 
40bf			; 
40bf			;		ld a, 0 
40bf			;		cp e 
40bf			;		jr z, .scrollup  
40bf			;		call scroll_down 
40bf			;		jr .scrollnext 
40bf			;.scrollup:	call scroll_up 
40bf			; 
40bf			;		 
40bf			;.scrollnext: 
40bf			;		pop de 
40bf			;		pop bc 
40bf			;		djnz .scrolldir 
40bf			; 
40bf			; 
40bf			; 
40bf			; 
40bf			; 
40bf			;		NEXTW 
40bf			 
40bf			.SCROLLD: 
40bf				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
40bf 53				db WORD_SYS_CORE+63             
40c0 ed 40			dw .ATQ            
40c2 08				db 7 + 1 
40c3 .. 00			db "SCROLLD",0              
40cb				endm 
# End of macro CWHEAD
40cb			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
40cb					if DEBUG_FORTH_WORDS_KEY 
40cb						DMARK "SCD" 
40cb f5				push af  
40cc 3a e0 40			ld a, (.dmark)  
40cf 32 6e fe			ld (debug_mark),a  
40d2 3a e1 40			ld a, (.dmark+1)  
40d5 32 6f fe			ld (debug_mark+1),a  
40d8 3a e2 40			ld a, (.dmark+2)  
40db 32 70 fe			ld (debug_mark+2),a  
40de 18 03			jr .pastdmark  
40e0 ..			.dmark: db "SCD"  
40e3 f1			.pastdmark: pop af  
40e4			endm  
# End of macro DMARK
40e4						CALLMONITOR 
40e4 cd ab 18			call break_point_state  
40e7				endm  
# End of macro CALLMONITOR
40e7					endif 
40e7			 
40e7 cd b6 0c			call scroll_down 
40ea			;	call update_display 
40ea			 
40ea					NEXTW 
40ea c3 8d 22			jp macro_next 
40ed				endm 
# End of macro NEXTW
40ed			 
40ed			 
40ed			.ATQ: 
40ed				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
40ed 62				db WORD_SYS_CORE+78             
40ee 4b 41			dw .AUTODSP            
40f0 04				db 3 + 1 
40f1 .. 00			db "AT@",0              
40f5				endm 
# End of macro CWHEAD
40f5			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
40f5					if DEBUG_FORTH_WORDS_KEY 
40f5						DMARK "ATA" 
40f5 f5				push af  
40f6 3a 0a 41			ld a, (.dmark)  
40f9 32 6e fe			ld (debug_mark),a  
40fc 3a 0b 41			ld a, (.dmark+1)  
40ff 32 6f fe			ld (debug_mark+1),a  
4102 3a 0c 41			ld a, (.dmark+2)  
4105 32 70 fe			ld (debug_mark+2),a  
4108 18 03			jr .pastdmark  
410a ..			.dmark: db "ATA"  
410d f1			.pastdmark: pop af  
410e			endm  
# End of macro DMARK
410e						CALLMONITOR 
410e cd ab 18			call break_point_state  
4111				endm  
# End of macro CALLMONITOR
4111					endif 
4111			 
4111			 
4111					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4111 cd 16 21			call macro_dsp_valuehl 
4114				endm 
# End of macro FORTH_DSP_VALUEHL
4114			 
4114					; TODO save cursor row 
4114 7d					ld a,l 
4115 fe 02				cp 2 
4117 20 04				jr nz, .crow3aq 
4119 3e 28				ld a, display_row_2 
411b 18 12				jr .ccol1aq 
411d fe 03		.crow3aq:		cp 3 
411f 20 04				jr nz, .crow4aq 
4121 3e 50				ld a, display_row_3 
4123 18 0a				jr .ccol1aq 
4125 fe 04		.crow4aq:		cp 4 
4127 20 04				jr nz, .crow1aq 
4129 3e 78				ld a, display_row_4 
412b 18 02				jr .ccol1aq 
412d 3e 00		.crow1aq:		ld a,display_row_1 
412f f5			.ccol1aq:		push af			; got row offset 
4130 6f					ld l,a 
4131 26 00				ld h,0 
4133					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4133 cd ce 21			call macro_forth_dsp_pop 
4136				endm 
# End of macro FORTH_DSP_POP
4136					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4136 cd 16 21			call macro_dsp_valuehl 
4139				endm 
# End of macro FORTH_DSP_VALUEHL
4139					; TODO save cursor col 
4139 f1					pop af 
413a 85					add l		; add col offset 
413b			 
413b					; add current frame buffer address 
413b 2a cf fb				ld hl, (display_fb_active) 
413e cd 04 0f				call addatohl 
4141			 
4141			 
4141			 
4141			 
4141					; get char frame buffer location offset in hl 
4141			 
4141 7e					ld a,(hl) 
4142 26 00				ld h, 0 
4144 6f					ld l, a 
4145			 
4145 cd 1f 1f				call forth_push_numhl 
4148			 
4148			 
4148					NEXTW 
4148 c3 8d 22			jp macro_next 
414b				endm 
# End of macro NEXTW
414b			 
414b			.AUTODSP: 
414b				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
414b 63				db WORD_SYS_CORE+79             
414c 61 41			dw .MENU            
414e 05				db 4 + 1 
414f .. 00			db "ADSP",0              
4154				endm 
# End of macro CWHEAD
4154			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
4154			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
4154			 
4154					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4154 cd 16 21			call macro_dsp_valuehl 
4157				endm 
# End of macro FORTH_DSP_VALUEHL
4157			 
4157			;		push hl 
4157			 
4157					; destroy value TOS 
4157			 
4157					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4157 cd ce 21			call macro_forth_dsp_pop 
415a				endm 
# End of macro FORTH_DSP_POP
415a			 
415a			;		pop hl 
415a			 
415a 7d					ld a,l 
415b 32 44 fa				ld (cli_autodisplay), a 
415e				       NEXTW 
415e c3 8d 22			jp macro_next 
4161				endm 
# End of macro NEXTW
4161			 
4161			.MENU: 
4161				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
4161 70				db WORD_SYS_CORE+92             
4162 0a 42			dw .ENDDISPLAY            
4164 05				db 4 + 1 
4165 .. 00			db "MENU",0              
416a				endm 
# End of macro CWHEAD
416a			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
416a			 
416a			;		; get number of items on the stack 
416a			; 
416a				 
416a					FORTH_DSP_VALUEHL 
416a cd 16 21			call macro_dsp_valuehl 
416d				endm 
# End of macro FORTH_DSP_VALUEHL
416d				 
416d					if DEBUG_FORTH_WORDS_KEY 
416d						DMARK "MNU" 
416d f5				push af  
416e 3a 82 41			ld a, (.dmark)  
4171 32 6e fe			ld (debug_mark),a  
4174 3a 83 41			ld a, (.dmark+1)  
4177 32 6f fe			ld (debug_mark+1),a  
417a 3a 84 41			ld a, (.dmark+2)  
417d 32 70 fe			ld (debug_mark+2),a  
4180 18 03			jr .pastdmark  
4182 ..			.dmark: db "MNU"  
4185 f1			.pastdmark: pop af  
4186			endm  
# End of macro DMARK
4186						CALLMONITOR 
4186 cd ab 18			call break_point_state  
4189				endm  
# End of macro CALLMONITOR
4189					endif 
4189			 
4189 45					ld b, l	 
418a 05					dec b 
418b			 
418b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
418b cd ce 21			call macro_forth_dsp_pop 
418e				endm 
# End of macro FORTH_DSP_POP
418e			 
418e			 
418e					; go directly through the stack to pluck out the string pointers and build an array 
418e			 
418e			;		FORTH_DSP 
418e			 
418e					; hl contains top most stack item 
418e				 
418e 11 fd f1				ld de, scratch 
4191			 
4191			.mbuild: 
4191			 
4191					FORTH_DSP_VALUEHL 
4191 cd 16 21			call macro_dsp_valuehl 
4194				endm 
# End of macro FORTH_DSP_VALUEHL
4194			 
4194					if DEBUG_FORTH_WORDS 
4194						DMARK "MN3" 
4194 f5				push af  
4195 3a a9 41			ld a, (.dmark)  
4198 32 6e fe			ld (debug_mark),a  
419b 3a aa 41			ld a, (.dmark+1)  
419e 32 6f fe			ld (debug_mark+1),a  
41a1 3a ab 41			ld a, (.dmark+2)  
41a4 32 70 fe			ld (debug_mark+2),a  
41a7 18 03			jr .pastdmark  
41a9 ..			.dmark: db "MN3"  
41ac f1			.pastdmark: pop af  
41ad			endm  
# End of macro DMARK
41ad						CALLMONITOR 
41ad cd ab 18			call break_point_state  
41b0				endm  
# End of macro CALLMONITOR
41b0					endif 
41b0 eb					ex de, hl 
41b1 73					ld (hl), e 
41b2 23					inc hl 
41b3 72					ld (hl), d 
41b4 23					inc hl 
41b5 eb					ex de, hl 
41b6			 
41b6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
41b6 cd ce 21			call macro_forth_dsp_pop 
41b9				endm 
# End of macro FORTH_DSP_POP
41b9			 
41b9 10 d6				djnz .mbuild 
41bb			 
41bb					; done add term 
41bb			 
41bb eb					ex de, hl 
41bc 36 00				ld (hl), 0 
41be 23					inc hl 
41bf 36 00				ld (hl), 0 
41c1			 
41c1				 
41c1					 
41c1 21 fd f1				ld hl, scratch 
41c4			 
41c4					if DEBUG_FORTH_WORDS 
41c4						DMARK "MNx" 
41c4 f5				push af  
41c5 3a d9 41			ld a, (.dmark)  
41c8 32 6e fe			ld (debug_mark),a  
41cb 3a da 41			ld a, (.dmark+1)  
41ce 32 6f fe			ld (debug_mark+1),a  
41d1 3a db 41			ld a, (.dmark+2)  
41d4 32 70 fe			ld (debug_mark+2),a  
41d7 18 03			jr .pastdmark  
41d9 ..			.dmark: db "MNx"  
41dc f1			.pastdmark: pop af  
41dd			endm  
# End of macro DMARK
41dd						CALLMONITOR 
41dd cd ab 18			call break_point_state  
41e0				endm  
# End of macro CALLMONITOR
41e0					endif 
41e0			 
41e0			 
41e0			 
41e0 3e 00				ld a, 0 
41e2 cd 01 0d				call menu 
41e5			 
41e5			 
41e5 6f					ld l, a 
41e6 26 00				ld h, 0 
41e8			 
41e8					if DEBUG_FORTH_WORDS 
41e8						DMARK "MNr" 
41e8 f5				push af  
41e9 3a fd 41			ld a, (.dmark)  
41ec 32 6e fe			ld (debug_mark),a  
41ef 3a fe 41			ld a, (.dmark+1)  
41f2 32 6f fe			ld (debug_mark+1),a  
41f5 3a ff 41			ld a, (.dmark+2)  
41f8 32 70 fe			ld (debug_mark+2),a  
41fb 18 03			jr .pastdmark  
41fd ..			.dmark: db "MNr"  
4200 f1			.pastdmark: pop af  
4201			endm  
# End of macro DMARK
4201						CALLMONITOR 
4201 cd ab 18			call break_point_state  
4204				endm  
# End of macro CALLMONITOR
4204					endif 
4204			 
4204 cd 1f 1f				call forth_push_numhl 
4207			 
4207			 
4207			 
4207			 
4207				       NEXTW 
4207 c3 8d 22			jp macro_next 
420a				endm 
# End of macro NEXTW
420a			 
420a			 
420a			.ENDDISPLAY: 
420a			 
420a			; eof 
# End of file forth_words_display.asm
420a			include "forth_words_str.asm" 
420a			 
420a			; | ## String Words 
420a			 
420a			.PTR:   
420a			 
420a				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
420a 48				db WORD_SYS_CORE+52             
420b 37 42			dw .STYPE            
420d 04				db 3 + 1 
420e .. 00			db "PTR",0              
4212				endm 
# End of macro CWHEAD
4212			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
4212			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
4212			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
4212			 
4212					if DEBUG_FORTH_WORDS_KEY 
4212						DMARK "PTR" 
4212 f5				push af  
4213 3a 27 42			ld a, (.dmark)  
4216 32 6e fe			ld (debug_mark),a  
4219 3a 28 42			ld a, (.dmark+1)  
421c 32 6f fe			ld (debug_mark+1),a  
421f 3a 29 42			ld a, (.dmark+2)  
4222 32 70 fe			ld (debug_mark+2),a  
4225 18 03			jr .pastdmark  
4227 ..			.dmark: db "PTR"  
422a f1			.pastdmark: pop af  
422b			endm  
# End of macro DMARK
422b						CALLMONITOR 
422b cd ab 18			call break_point_state  
422e				endm  
# End of macro CALLMONITOR
422e					endif 
422e					FORTH_DSP_VALUEHL 
422e cd 16 21			call macro_dsp_valuehl 
4231				endm 
# End of macro FORTH_DSP_VALUEHL
4231 cd 1f 1f				call forth_push_numhl 
4234			 
4234			 
4234					NEXTW 
4234 c3 8d 22			jp macro_next 
4237				endm 
# End of macro NEXTW
4237			.STYPE: 
4237				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
4237 48				db WORD_SYS_CORE+52             
4238 86 42			dw .UPPER            
423a 06				db 5 + 1 
423b .. 00			db "STYPE",0              
4241				endm 
# End of macro CWHEAD
4241			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
4241					if DEBUG_FORTH_WORDS_KEY 
4241						DMARK "STY" 
4241 f5				push af  
4242 3a 56 42			ld a, (.dmark)  
4245 32 6e fe			ld (debug_mark),a  
4248 3a 57 42			ld a, (.dmark+1)  
424b 32 6f fe			ld (debug_mark+1),a  
424e 3a 58 42			ld a, (.dmark+2)  
4251 32 70 fe			ld (debug_mark+2),a  
4254 18 03			jr .pastdmark  
4256 ..			.dmark: db "STY"  
4259 f1			.pastdmark: pop af  
425a			endm  
# End of macro DMARK
425a						CALLMONITOR 
425a cd ab 18			call break_point_state  
425d				endm  
# End of macro CALLMONITOR
425d					endif 
425d					FORTH_DSP 
425d cd dc 20			call macro_forth_dsp 
4260				endm 
# End of macro FORTH_DSP
4260					;v5 FORTH_DSP_VALUE 
4260			 
4260 7e					ld a, (hl) 
4261			 
4261 f5					push af 
4262			 
4262			; Dont destroy TOS		FORTH_DSP_POP 
4262			 
4262 f1					pop af 
4263			 
4263 fe 01				cp DS_TYPE_STR 
4265 28 09				jr z, .typestr 
4267			 
4267 fe 02				cp DS_TYPE_INUM 
4269 28 0a				jr z, .typeinum 
426b			 
426b 21 84 42				ld hl, .tna 
426e 18 0a				jr .tpush 
4270			 
4270 21 80 42		.typestr:	ld hl, .tstr 
4273 18 05				jr .tpush 
4275 21 82 42		.typeinum:	ld hl, .tinum 
4278 18 00				jr .tpush 
427a			 
427a			.tpush: 
427a			 
427a cd 8d 1f				call forth_push_str 
427d			 
427d					NEXTW 
427d c3 8d 22			jp macro_next 
4280				endm 
# End of macro NEXTW
4280 .. 00		.tstr:	db "s",0 
4282 .. 00		.tinum:  db "i",0 
4284 .. 00		.tna:   db "?", 0 
4286			 
4286			 
4286			.UPPER: 
4286				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
4286 48				db WORD_SYS_CORE+52             
4287 c1 42			dw .LOWER            
4289 06				db 5 + 1 
428a .. 00			db "UPPER",0              
4290				endm 
# End of macro CWHEAD
4290			; | UPPER ( s -- s ) Upper case string s  | DONE 
4290					if DEBUG_FORTH_WORDS_KEY 
4290						DMARK "UPR" 
4290 f5				push af  
4291 3a a5 42			ld a, (.dmark)  
4294 32 6e fe			ld (debug_mark),a  
4297 3a a6 42			ld a, (.dmark+1)  
429a 32 6f fe			ld (debug_mark+1),a  
429d 3a a7 42			ld a, (.dmark+2)  
42a0 32 70 fe			ld (debug_mark+2),a  
42a3 18 03			jr .pastdmark  
42a5 ..			.dmark: db "UPR"  
42a8 f1			.pastdmark: pop af  
42a9			endm  
# End of macro DMARK
42a9						CALLMONITOR 
42a9 cd ab 18			call break_point_state  
42ac				endm  
# End of macro CALLMONITOR
42ac					endif 
42ac			 
42ac					FORTH_DSP 
42ac cd dc 20			call macro_forth_dsp 
42af				endm 
# End of macro FORTH_DSP
42af					 
42af			; TODO check is string type 
42af			 
42af					FORTH_DSP_VALUEHL 
42af cd 16 21			call macro_dsp_valuehl 
42b2				endm 
# End of macro FORTH_DSP_VALUEHL
42b2			; get pointer to string in hl 
42b2			 
42b2 7e			.toup:		ld a, (hl) 
42b3 fe 00				cp 0 
42b5 28 07				jr z, .toupdone 
42b7			 
42b7 cd 71 12				call to_upper 
42ba			 
42ba 77					ld (hl), a 
42bb 23					inc hl 
42bc 18 f4				jr .toup 
42be			 
42be					 
42be			 
42be			 
42be			; for each char convert to upper 
42be					 
42be			.toupdone: 
42be			 
42be			 
42be					NEXTW 
42be c3 8d 22			jp macro_next 
42c1				endm 
# End of macro NEXTW
42c1			.LOWER: 
42c1				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
42c1 48				db WORD_SYS_CORE+52             
42c2 fc 42			dw .TCASE            
42c4 06				db 5 + 1 
42c5 .. 00			db "LOWER",0              
42cb				endm 
# End of macro CWHEAD
42cb			; | LOWER ( s -- s ) Lower case string s  | DONE 
42cb					if DEBUG_FORTH_WORDS_KEY 
42cb						DMARK "LWR" 
42cb f5				push af  
42cc 3a e0 42			ld a, (.dmark)  
42cf 32 6e fe			ld (debug_mark),a  
42d2 3a e1 42			ld a, (.dmark+1)  
42d5 32 6f fe			ld (debug_mark+1),a  
42d8 3a e2 42			ld a, (.dmark+2)  
42db 32 70 fe			ld (debug_mark+2),a  
42de 18 03			jr .pastdmark  
42e0 ..			.dmark: db "LWR"  
42e3 f1			.pastdmark: pop af  
42e4			endm  
# End of macro DMARK
42e4						CALLMONITOR 
42e4 cd ab 18			call break_point_state  
42e7				endm  
# End of macro CALLMONITOR
42e7					endif 
42e7			 
42e7					FORTH_DSP 
42e7 cd dc 20			call macro_forth_dsp 
42ea				endm 
# End of macro FORTH_DSP
42ea					 
42ea			; TODO check is string type 
42ea			 
42ea					FORTH_DSP_VALUEHL 
42ea cd 16 21			call macro_dsp_valuehl 
42ed				endm 
# End of macro FORTH_DSP_VALUEHL
42ed			; get pointer to string in hl 
42ed			 
42ed 7e			.tolow:		ld a, (hl) 
42ee fe 00				cp 0 
42f0 28 07				jr z, .tolowdone 
42f2			 
42f2 cd 7a 12				call to_lower 
42f5			 
42f5 77					ld (hl), a 
42f6 23					inc hl 
42f7 18 f4				jr .tolow 
42f9			 
42f9					 
42f9			 
42f9			 
42f9			; for each char convert to low 
42f9					 
42f9			.tolowdone: 
42f9					NEXTW 
42f9 c3 8d 22			jp macro_next 
42fc				endm 
# End of macro NEXTW
42fc			.TCASE: 
42fc				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
42fc 48				db WORD_SYS_CORE+52             
42fd 32 44			dw .SUBSTR            
42ff 06				db 5 + 1 
4300 .. 00			db "TCASE",0              
4306				endm 
# End of macro CWHEAD
4306			; | TCASE ( s -- s ) Title case string s  | DONE 
4306					if DEBUG_FORTH_WORDS_KEY 
4306						DMARK "TCS" 
4306 f5				push af  
4307 3a 1b 43			ld a, (.dmark)  
430a 32 6e fe			ld (debug_mark),a  
430d 3a 1c 43			ld a, (.dmark+1)  
4310 32 6f fe			ld (debug_mark+1),a  
4313 3a 1d 43			ld a, (.dmark+2)  
4316 32 70 fe			ld (debug_mark+2),a  
4319 18 03			jr .pastdmark  
431b ..			.dmark: db "TCS"  
431e f1			.pastdmark: pop af  
431f			endm  
# End of macro DMARK
431f						CALLMONITOR 
431f cd ab 18			call break_point_state  
4322				endm  
# End of macro CALLMONITOR
4322					endif 
4322			 
4322					FORTH_DSP 
4322 cd dc 20			call macro_forth_dsp 
4325				endm 
# End of macro FORTH_DSP
4325					 
4325			; TODO check is string type 
4325			 
4325					FORTH_DSP_VALUEHL 
4325 cd 16 21			call macro_dsp_valuehl 
4328				endm 
# End of macro FORTH_DSP_VALUEHL
4328			; get pointer to string in hl 
4328			 
4328					if DEBUG_FORTH_WORDS 
4328						DMARK "TC1" 
4328 f5				push af  
4329 3a 3d 43			ld a, (.dmark)  
432c 32 6e fe			ld (debug_mark),a  
432f 3a 3e 43			ld a, (.dmark+1)  
4332 32 6f fe			ld (debug_mark+1),a  
4335 3a 3f 43			ld a, (.dmark+2)  
4338 32 70 fe			ld (debug_mark+2),a  
433b 18 03			jr .pastdmark  
433d ..			.dmark: db "TC1"  
4340 f1			.pastdmark: pop af  
4341			endm  
# End of macro DMARK
4341						CALLMONITOR 
4341 cd ab 18			call break_point_state  
4344				endm  
# End of macro CALLMONITOR
4344					endif 
4344			 
4344					; first time in turn to upper case first char 
4344			 
4344 7e					ld a, (hl) 
4345 c3 cf 43				jp .totsiptou 
4348			 
4348			 
4348 7e			.tot:		ld a, (hl) 
4349 fe 00				cp 0 
434b ca 13 44				jp z, .totdone 
434e			 
434e					if DEBUG_FORTH_WORDS 
434e						DMARK "TC2" 
434e f5				push af  
434f 3a 63 43			ld a, (.dmark)  
4352 32 6e fe			ld (debug_mark),a  
4355 3a 64 43			ld a, (.dmark+1)  
4358 32 6f fe			ld (debug_mark+1),a  
435b 3a 65 43			ld a, (.dmark+2)  
435e 32 70 fe			ld (debug_mark+2),a  
4361 18 03			jr .pastdmark  
4363 ..			.dmark: db "TC2"  
4366 f1			.pastdmark: pop af  
4367			endm  
# End of macro DMARK
4367						CALLMONITOR 
4367 cd ab 18			call break_point_state  
436a				endm  
# End of macro CALLMONITOR
436a					endif 
436a					; check to see if current char is a space 
436a			 
436a fe 20				cp ' ' 
436c 28 21				jr z, .totsp 
436e cd 7a 12				call to_lower 
4371					if DEBUG_FORTH_WORDS 
4371						DMARK "TC3" 
4371 f5				push af  
4372 3a 86 43			ld a, (.dmark)  
4375 32 6e fe			ld (debug_mark),a  
4378 3a 87 43			ld a, (.dmark+1)  
437b 32 6f fe			ld (debug_mark+1),a  
437e 3a 88 43			ld a, (.dmark+2)  
4381 32 70 fe			ld (debug_mark+2),a  
4384 18 03			jr .pastdmark  
4386 ..			.dmark: db "TC3"  
4389 f1			.pastdmark: pop af  
438a			endm  
# End of macro DMARK
438a						CALLMONITOR 
438a cd ab 18			call break_point_state  
438d				endm  
# End of macro CALLMONITOR
438d					endif 
438d 18 63				jr .totnxt 
438f			 
438f			.totsp:         ; on a space, find next char which should be upper 
438f			 
438f					if DEBUG_FORTH_WORDS 
438f						DMARK "TC4" 
438f f5				push af  
4390 3a a4 43			ld a, (.dmark)  
4393 32 6e fe			ld (debug_mark),a  
4396 3a a5 43			ld a, (.dmark+1)  
4399 32 6f fe			ld (debug_mark+1),a  
439c 3a a6 43			ld a, (.dmark+2)  
439f 32 70 fe			ld (debug_mark+2),a  
43a2 18 03			jr .pastdmark  
43a4 ..			.dmark: db "TC4"  
43a7 f1			.pastdmark: pop af  
43a8			endm  
# End of macro DMARK
43a8						CALLMONITOR 
43a8 cd ab 18			call break_point_state  
43ab				endm  
# End of macro CALLMONITOR
43ab					endif 
43ab					;; 
43ab			 
43ab fe 20				cp ' ' 
43ad 20 20				jr nz, .totsiptou 
43af 23					inc hl 
43b0 7e					ld a, (hl) 
43b1					if DEBUG_FORTH_WORDS 
43b1						DMARK "TC5" 
43b1 f5				push af  
43b2 3a c6 43			ld a, (.dmark)  
43b5 32 6e fe			ld (debug_mark),a  
43b8 3a c7 43			ld a, (.dmark+1)  
43bb 32 6f fe			ld (debug_mark+1),a  
43be 3a c8 43			ld a, (.dmark+2)  
43c1 32 70 fe			ld (debug_mark+2),a  
43c4 18 03			jr .pastdmark  
43c6 ..			.dmark: db "TC5"  
43c9 f1			.pastdmark: pop af  
43ca			endm  
# End of macro DMARK
43ca						CALLMONITOR 
43ca cd ab 18			call break_point_state  
43cd				endm  
# End of macro CALLMONITOR
43cd					endif 
43cd 18 c0				jr .totsp 
43cf fe 00		.totsiptou:    cp 0 
43d1 28 40				jr z, .totdone 
43d3					; not space and not zero term so upper case it 
43d3 cd 71 12				call to_upper 
43d6			 
43d6					if DEBUG_FORTH_WORDS 
43d6						DMARK "TC6" 
43d6 f5				push af  
43d7 3a eb 43			ld a, (.dmark)  
43da 32 6e fe			ld (debug_mark),a  
43dd 3a ec 43			ld a, (.dmark+1)  
43e0 32 6f fe			ld (debug_mark+1),a  
43e3 3a ed 43			ld a, (.dmark+2)  
43e6 32 70 fe			ld (debug_mark+2),a  
43e9 18 03			jr .pastdmark  
43eb ..			.dmark: db "TC6"  
43ee f1			.pastdmark: pop af  
43ef			endm  
# End of macro DMARK
43ef						CALLMONITOR 
43ef cd ab 18			call break_point_state  
43f2				endm  
# End of macro CALLMONITOR
43f2					endif 
43f2			 
43f2			 
43f2			.totnxt: 
43f2			 
43f2 77					ld (hl), a 
43f3 23					inc hl 
43f4					if DEBUG_FORTH_WORDS 
43f4						DMARK "TC7" 
43f4 f5				push af  
43f5 3a 09 44			ld a, (.dmark)  
43f8 32 6e fe			ld (debug_mark),a  
43fb 3a 0a 44			ld a, (.dmark+1)  
43fe 32 6f fe			ld (debug_mark+1),a  
4401 3a 0b 44			ld a, (.dmark+2)  
4404 32 70 fe			ld (debug_mark+2),a  
4407 18 03			jr .pastdmark  
4409 ..			.dmark: db "TC7"  
440c f1			.pastdmark: pop af  
440d			endm  
# End of macro DMARK
440d						CALLMONITOR 
440d cd ab 18			call break_point_state  
4410				endm  
# End of macro CALLMONITOR
4410					endif 
4410 c3 48 43				jp .tot 
4413			 
4413					 
4413			 
4413			 
4413			; for each char convert to low 
4413					 
4413			.totdone: 
4413					if DEBUG_FORTH_WORDS 
4413						DMARK "TCd" 
4413 f5				push af  
4414 3a 28 44			ld a, (.dmark)  
4417 32 6e fe			ld (debug_mark),a  
441a 3a 29 44			ld a, (.dmark+1)  
441d 32 6f fe			ld (debug_mark+1),a  
4420 3a 2a 44			ld a, (.dmark+2)  
4423 32 70 fe			ld (debug_mark+2),a  
4426 18 03			jr .pastdmark  
4428 ..			.dmark: db "TCd"  
442b f1			.pastdmark: pop af  
442c			endm  
# End of macro DMARK
442c						CALLMONITOR 
442c cd ab 18			call break_point_state  
442f				endm  
# End of macro CALLMONITOR
442f					endif 
442f					NEXTW 
442f c3 8d 22			jp macro_next 
4432				endm 
# End of macro NEXTW
4432			 
4432			.SUBSTR: 
4432				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
4432 48				db WORD_SYS_CORE+52             
4433 90 44			dw .LEFT            
4435 07				db 6 + 1 
4436 .. 00			db "SUBSTR",0              
443d				endm 
# End of macro CWHEAD
443d			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
443d			 
443d					if DEBUG_FORTH_WORDS_KEY 
443d						DMARK "SST" 
443d f5				push af  
443e 3a 52 44			ld a, (.dmark)  
4441 32 6e fe			ld (debug_mark),a  
4444 3a 53 44			ld a, (.dmark+1)  
4447 32 6f fe			ld (debug_mark+1),a  
444a 3a 54 44			ld a, (.dmark+2)  
444d 32 70 fe			ld (debug_mark+2),a  
4450 18 03			jr .pastdmark  
4452 ..			.dmark: db "SST"  
4455 f1			.pastdmark: pop af  
4456			endm  
# End of macro DMARK
4456						CALLMONITOR 
4456 cd ab 18			call break_point_state  
4459				endm  
# End of macro CALLMONITOR
4459					endif 
4459			; TODO check string type 
4459					FORTH_DSP_VALUEHL 
4459 cd 16 21			call macro_dsp_valuehl 
445c				endm 
# End of macro FORTH_DSP_VALUEHL
445c			 
445c e5					push hl      ; string length 
445d			 
445d					FORTH_DSP_POP 
445d cd ce 21			call macro_forth_dsp_pop 
4460				endm 
# End of macro FORTH_DSP_POP
4460			 
4460					FORTH_DSP_VALUEHL 
4460 cd 16 21			call macro_dsp_valuehl 
4463				endm 
# End of macro FORTH_DSP_VALUEHL
4463			 
4463 e5					push hl     ; start char 
4464			 
4464					FORTH_DSP_POP 
4464 cd ce 21			call macro_forth_dsp_pop 
4467				endm 
# End of macro FORTH_DSP_POP
4467			 
4467			 
4467					FORTH_DSP_VALUE 
4467 cd ff 20			call macro_forth_dsp_value 
446a				endm 
# End of macro FORTH_DSP_VALUE
446a			 
446a d1					pop de    ; get start post offset 
446b			 
446b 19					add hl, de    ; starting offset 
446c			 
446c c1					pop bc 
446d c5					push bc      ; grab size of string 
446e			 
446e e5					push hl    ; save string start  
446f			 
446f 26 00				ld h, 0 
4471 69					ld l, c 
4472 23					inc hl 
4473 23					inc hl 
4474			 
4474 cd cb 13				call malloc 
4477				if DEBUG_FORTH_MALLOC_GUARD 
4477 cc 9e 55				call z,malloc_error 
447a				endif 
447a			 
447a eb					ex de, hl      ; save malloc area for string copy 
447b e1					pop hl    ; get back source 
447c c1					pop bc    ; get length of string back 
447d			 
447d d5					push de    ; save malloc area for after we push 
447e ed b0				ldir     ; copy substr 
4480			 
4480			 
4480 eb					ex de, hl 
4481 3e 00				ld a, 0 
4483 77					ld (hl), a   ; term substr 
4484			 
4484					 
4484 e1					pop hl    ; get malloc so we can push it 
4485 e5					push hl   ; save so we can free it afterwards 
4486			 
4486 cd 8d 1f				call forth_push_str 
4489			 
4489 e1					pop hl 
448a cd 95 14				call free 
448d			 
448d					 
448d					 
448d			 
448d			 
448d					NEXTW 
448d c3 8d 22			jp macro_next 
4490				endm 
# End of macro NEXTW
4490			 
4490			.LEFT: 
4490				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
4490 48				db WORD_SYS_CORE+52             
4491 b8 44			dw .RIGHT            
4493 05				db 4 + 1 
4494 .. 00			db "LEFT",0              
4499				endm 
# End of macro CWHEAD
4499			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
4499					if DEBUG_FORTH_WORDS_KEY 
4499						DMARK "LEF" 
4499 f5				push af  
449a 3a ae 44			ld a, (.dmark)  
449d 32 6e fe			ld (debug_mark),a  
44a0 3a af 44			ld a, (.dmark+1)  
44a3 32 6f fe			ld (debug_mark+1),a  
44a6 3a b0 44			ld a, (.dmark+2)  
44a9 32 70 fe			ld (debug_mark+2),a  
44ac 18 03			jr .pastdmark  
44ae ..			.dmark: db "LEF"  
44b1 f1			.pastdmark: pop af  
44b2			endm  
# End of macro DMARK
44b2						CALLMONITOR 
44b2 cd ab 18			call break_point_state  
44b5				endm  
# End of macro CALLMONITOR
44b5					endif 
44b5			 
44b5					NEXTW 
44b5 c3 8d 22			jp macro_next 
44b8				endm 
# End of macro NEXTW
44b8			.RIGHT: 
44b8				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
44b8 48				db WORD_SYS_CORE+52             
44b9 e1 44			dw .STR2NUM            
44bb 06				db 5 + 1 
44bc .. 00			db "RIGHT",0              
44c2				endm 
# End of macro CWHEAD
44c2			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
44c2					if DEBUG_FORTH_WORDS_KEY 
44c2						DMARK "RIG" 
44c2 f5				push af  
44c3 3a d7 44			ld a, (.dmark)  
44c6 32 6e fe			ld (debug_mark),a  
44c9 3a d8 44			ld a, (.dmark+1)  
44cc 32 6f fe			ld (debug_mark+1),a  
44cf 3a d9 44			ld a, (.dmark+2)  
44d2 32 70 fe			ld (debug_mark+2),a  
44d5 18 03			jr .pastdmark  
44d7 ..			.dmark: db "RIG"  
44da f1			.pastdmark: pop af  
44db			endm  
# End of macro DMARK
44db						CALLMONITOR 
44db cd ab 18			call break_point_state  
44de				endm  
# End of macro CALLMONITOR
44de					endif 
44de			 
44de					NEXTW 
44de c3 8d 22			jp macro_next 
44e1				endm 
# End of macro NEXTW
44e1			 
44e1			 
44e1			.STR2NUM: 
44e1				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
44e1 48				db WORD_SYS_CORE+52             
44e2 6d 45			dw .NUM2STR            
44e4 08				db 7 + 1 
44e5 .. 00			db "STR2NUM",0              
44ed				endm 
# End of macro CWHEAD
44ed			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
44ed			 
44ed			 
44ed			; TODO STR type check to do 
44ed					if DEBUG_FORTH_WORDS_KEY 
44ed						DMARK "S2N" 
44ed f5				push af  
44ee 3a 02 45			ld a, (.dmark)  
44f1 32 6e fe			ld (debug_mark),a  
44f4 3a 03 45			ld a, (.dmark+1)  
44f7 32 6f fe			ld (debug_mark+1),a  
44fa 3a 04 45			ld a, (.dmark+2)  
44fd 32 70 fe			ld (debug_mark+2),a  
4500 18 03			jr .pastdmark  
4502 ..			.dmark: db "S2N"  
4505 f1			.pastdmark: pop af  
4506			endm  
# End of macro DMARK
4506						CALLMONITOR 
4506 cd ab 18			call break_point_state  
4509				endm  
# End of macro CALLMONITOR
4509					endif 
4509			 
4509					;FORTH_DSP 
4509					FORTH_DSP_VALUE 
4509 cd ff 20			call macro_forth_dsp_value 
450c				endm 
# End of macro FORTH_DSP_VALUE
450c					;inc hl 
450c			 
450c eb					ex de, hl 
450d					if DEBUG_FORTH_WORDS 
450d						DMARK "S2a" 
450d f5				push af  
450e 3a 22 45			ld a, (.dmark)  
4511 32 6e fe			ld (debug_mark),a  
4514 3a 23 45			ld a, (.dmark+1)  
4517 32 6f fe			ld (debug_mark+1),a  
451a 3a 24 45			ld a, (.dmark+2)  
451d 32 70 fe			ld (debug_mark+2),a  
4520 18 03			jr .pastdmark  
4522 ..			.dmark: db "S2a"  
4525 f1			.pastdmark: pop af  
4526			endm  
# End of macro DMARK
4526						CALLMONITOR 
4526 cd ab 18			call break_point_state  
4529				endm  
# End of macro CALLMONITOR
4529					endif 
4529 cd f9 12				call string_to_uint16 
452c			 
452c					if DEBUG_FORTH_WORDS 
452c						DMARK "S2b" 
452c f5				push af  
452d 3a 41 45			ld a, (.dmark)  
4530 32 6e fe			ld (debug_mark),a  
4533 3a 42 45			ld a, (.dmark+1)  
4536 32 6f fe			ld (debug_mark+1),a  
4539 3a 43 45			ld a, (.dmark+2)  
453c 32 70 fe			ld (debug_mark+2),a  
453f 18 03			jr .pastdmark  
4541 ..			.dmark: db "S2b"  
4544 f1			.pastdmark: pop af  
4545			endm  
# End of macro DMARK
4545						CALLMONITOR 
4545 cd ab 18			call break_point_state  
4548				endm  
# End of macro CALLMONITOR
4548					endif 
4548			;		push hl 
4548					FORTH_DSP_POP 
4548 cd ce 21			call macro_forth_dsp_pop 
454b				endm 
# End of macro FORTH_DSP_POP
454b			;		pop hl 
454b					 
454b					if DEBUG_FORTH_WORDS 
454b						DMARK "S2b" 
454b f5				push af  
454c 3a 60 45			ld a, (.dmark)  
454f 32 6e fe			ld (debug_mark),a  
4552 3a 61 45			ld a, (.dmark+1)  
4555 32 6f fe			ld (debug_mark+1),a  
4558 3a 62 45			ld a, (.dmark+2)  
455b 32 70 fe			ld (debug_mark+2),a  
455e 18 03			jr .pastdmark  
4560 ..			.dmark: db "S2b"  
4563 f1			.pastdmark: pop af  
4564			endm  
# End of macro DMARK
4564						CALLMONITOR 
4564 cd ab 18			call break_point_state  
4567				endm  
# End of macro CALLMONITOR
4567					endif 
4567 cd 1f 1f				call forth_push_numhl	 
456a			 
456a				 
456a				       NEXTW 
456a c3 8d 22			jp macro_next 
456d				endm 
# End of macro NEXTW
456d			.NUM2STR: 
456d				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
456d 48				db WORD_SYS_CORE+52             
456e 7c 45			dw .CONCAT            
4570 08				db 7 + 1 
4571 .. 00			db "NUM2STR",0              
4579				endm 
# End of macro CWHEAD
4579			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
4579			 
4579			;		; malloc a string to target 
4579			;		ld hl, 10     ; TODO max string size should be fine 
4579			;		call malloc 
4579			;		push hl    ; save malloc location 
4579			; 
4579			; 
4579			;; TODO check int type 
4579			;		FORTH_DSP_VALUEHL 
4579			;		ld a, l 
4579			;		call DispAToASCII   
4579			;;TODO need to chage above call to dump into string 
4579			; 
4579			; 
4579			 
4579				       NEXTW 
4579 c3 8d 22			jp macro_next 
457c				endm 
# End of macro NEXTW
457c			 
457c			.CONCAT: 
457c				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
457c 48				db WORD_SYS_CORE+52             
457d 2f 46			dw .FIND            
457f 07				db 6 + 1 
4580 .. 00			db "CONCAT",0              
4587				endm 
# End of macro CWHEAD
4587			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
4587			 
4587			; TODO check string type 
4587			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
4587			 
4587					if DEBUG_FORTH_WORDS_KEY 
4587						DMARK "CON" 
4587 f5				push af  
4588 3a 9c 45			ld a, (.dmark)  
458b 32 6e fe			ld (debug_mark),a  
458e 3a 9d 45			ld a, (.dmark+1)  
4591 32 6f fe			ld (debug_mark+1),a  
4594 3a 9e 45			ld a, (.dmark+2)  
4597 32 70 fe			ld (debug_mark+2),a  
459a 18 03			jr .pastdmark  
459c ..			.dmark: db "CON"  
459f f1			.pastdmark: pop af  
45a0			endm  
# End of macro DMARK
45a0						CALLMONITOR 
45a0 cd ab 18			call break_point_state  
45a3				endm  
# End of macro CALLMONITOR
45a3					endif 
45a3			 
45a3			 
45a3					FORTH_DSP_VALUE 
45a3 cd ff 20			call macro_forth_dsp_value 
45a6				endm 
# End of macro FORTH_DSP_VALUE
45a6 e5					push hl   ; s2 
45a7			 
45a7					FORTH_DSP_POP 
45a7 cd ce 21			call macro_forth_dsp_pop 
45aa				endm 
# End of macro FORTH_DSP_POP
45aa			 
45aa					FORTH_DSP_VALUE 
45aa cd ff 20			call macro_forth_dsp_value 
45ad				endm 
# End of macro FORTH_DSP_VALUE
45ad			 
45ad e5					push hl   ; s1 
45ae			 
45ae					FORTH_DSP_POP 
45ae cd ce 21			call macro_forth_dsp_pop 
45b1				endm 
# End of macro FORTH_DSP_POP
45b1					 
45b1			 
45b1					; copy s1 
45b1			 
45b1				 
45b1					; save ptr 
45b1 e1					pop hl  
45b2 e5					push hl 
45b3 3e 00				ld a, 0 
45b5 cd 6d 13				call strlent 
45b8					;inc hl    ; zer0 
45b8 06 00				ld b, 0 
45ba 4d					ld c, l 
45bb e1					pop hl		 
45bc 11 fd f1				ld de, scratch	 
45bf					if DEBUG_FORTH_WORDS 
45bf						DMARK "CO1" 
45bf f5				push af  
45c0 3a d4 45			ld a, (.dmark)  
45c3 32 6e fe			ld (debug_mark),a  
45c6 3a d5 45			ld a, (.dmark+1)  
45c9 32 6f fe			ld (debug_mark+1),a  
45cc 3a d6 45			ld a, (.dmark+2)  
45cf 32 70 fe			ld (debug_mark+2),a  
45d2 18 03			jr .pastdmark  
45d4 ..			.dmark: db "CO1"  
45d7 f1			.pastdmark: pop af  
45d8			endm  
# End of macro DMARK
45d8						CALLMONITOR 
45d8 cd ab 18			call break_point_state  
45db				endm  
# End of macro CALLMONITOR
45db					endif 
45db ed b0				ldir 
45dd			 
45dd e1					pop hl 
45de e5					push hl 
45df d5					push de 
45e0			 
45e0			 
45e0 3e 00				ld a, 0 
45e2 cd 6d 13				call strlent 
45e5 23					inc hl    ; zer0 
45e6 23					inc hl 
45e7 06 00				ld b, 0 
45e9 4d					ld c, l 
45ea d1					pop de 
45eb e1					pop hl		 
45ec					if DEBUG_FORTH_WORDS 
45ec						DMARK "CO2" 
45ec f5				push af  
45ed 3a 01 46			ld a, (.dmark)  
45f0 32 6e fe			ld (debug_mark),a  
45f3 3a 02 46			ld a, (.dmark+1)  
45f6 32 6f fe			ld (debug_mark+1),a  
45f9 3a 03 46			ld a, (.dmark+2)  
45fc 32 70 fe			ld (debug_mark+2),a  
45ff 18 03			jr .pastdmark  
4601 ..			.dmark: db "CO2"  
4604 f1			.pastdmark: pop af  
4605			endm  
# End of macro DMARK
4605						CALLMONITOR 
4605 cd ab 18			call break_point_state  
4608				endm  
# End of macro CALLMONITOR
4608					endif 
4608 ed b0				ldir 
460a			 
460a			 
460a			 
460a 21 fd f1				ld hl, scratch 
460d					if DEBUG_FORTH_WORDS 
460d						DMARK "CO5" 
460d f5				push af  
460e 3a 22 46			ld a, (.dmark)  
4611 32 6e fe			ld (debug_mark),a  
4614 3a 23 46			ld a, (.dmark+1)  
4617 32 6f fe			ld (debug_mark+1),a  
461a 3a 24 46			ld a, (.dmark+2)  
461d 32 70 fe			ld (debug_mark+2),a  
4620 18 03			jr .pastdmark  
4622 ..			.dmark: db "CO5"  
4625 f1			.pastdmark: pop af  
4626			endm  
# End of macro DMARK
4626						CALLMONITOR 
4626 cd ab 18			call break_point_state  
4629				endm  
# End of macro CALLMONITOR
4629					endif 
4629			 
4629 cd 8d 1f				call forth_push_str 
462c			 
462c			 
462c			 
462c			 
462c				       NEXTW 
462c c3 8d 22			jp macro_next 
462f				endm 
# End of macro NEXTW
462f			 
462f			 
462f			.FIND: 
462f				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
462f 4b				db WORD_SYS_CORE+55             
4630 ed 46			dw .LEN            
4632 05				db 4 + 1 
4633 .. 00			db "FIND",0              
4638				endm 
# End of macro CWHEAD
4638			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
4638			 
4638					if DEBUG_FORTH_WORDS_KEY 
4638						DMARK "FND" 
4638 f5				push af  
4639 3a 4d 46			ld a, (.dmark)  
463c 32 6e fe			ld (debug_mark),a  
463f 3a 4e 46			ld a, (.dmark+1)  
4642 32 6f fe			ld (debug_mark+1),a  
4645 3a 4f 46			ld a, (.dmark+2)  
4648 32 70 fe			ld (debug_mark+2),a  
464b 18 03			jr .pastdmark  
464d ..			.dmark: db "FND"  
4650 f1			.pastdmark: pop af  
4651			endm  
# End of macro DMARK
4651						CALLMONITOR 
4651 cd ab 18			call break_point_state  
4654				endm  
# End of macro CALLMONITOR
4654					endif 
4654			 
4654			; TODO check string type 
4654					FORTH_DSP_VALUE 
4654 cd ff 20			call macro_forth_dsp_value 
4657				endm 
# End of macro FORTH_DSP_VALUE
4657			 
4657 e5					push hl    
4658 7e					ld a,(hl)    ; char to find   
4659			; TODO change char to substr 
4659			 
4659 f5					push af 
465a					 
465a			 
465a			 
465a					if DEBUG_FORTH_WORDS 
465a						DMARK "FN1" 
465a f5				push af  
465b 3a 6f 46			ld a, (.dmark)  
465e 32 6e fe			ld (debug_mark),a  
4661 3a 70 46			ld a, (.dmark+1)  
4664 32 6f fe			ld (debug_mark+1),a  
4667 3a 71 46			ld a, (.dmark+2)  
466a 32 70 fe			ld (debug_mark+2),a  
466d 18 03			jr .pastdmark  
466f ..			.dmark: db "FN1"  
4672 f1			.pastdmark: pop af  
4673			endm  
# End of macro DMARK
4673						CALLMONITOR 
4673 cd ab 18			call break_point_state  
4676				endm  
# End of macro CALLMONITOR
4676					endif 
4676			 
4676					FORTH_DSP_POP 
4676 cd ce 21			call macro_forth_dsp_pop 
4679				endm 
# End of macro FORTH_DSP_POP
4679			 
4679					; string to search 
4679			 
4679					FORTH_DSP_VALUE 
4679 cd ff 20			call macro_forth_dsp_value 
467c				endm 
# End of macro FORTH_DSP_VALUE
467c			 
467c d1					pop de  ; d is char to find  
467d			 
467d					if DEBUG_FORTH_WORDS 
467d						DMARK "FN2" 
467d f5				push af  
467e 3a 92 46			ld a, (.dmark)  
4681 32 6e fe			ld (debug_mark),a  
4684 3a 93 46			ld a, (.dmark+1)  
4687 32 6f fe			ld (debug_mark+1),a  
468a 3a 94 46			ld a, (.dmark+2)  
468d 32 70 fe			ld (debug_mark+2),a  
4690 18 03			jr .pastdmark  
4692 ..			.dmark: db "FN2"  
4695 f1			.pastdmark: pop af  
4696			endm  
# End of macro DMARK
4696						CALLMONITOR 
4696 cd ab 18			call break_point_state  
4699				endm  
# End of macro CALLMONITOR
4699					endif 
4699					 
4699 01 00 00				ld bc, 0 
469c 7e			.findchar:      ld a,(hl) 
469d fe 00				cp 0   		 
469f 28 27				jr z, .finddone     
46a1 ba					cp d 
46a2 28 20				jr z, .foundchar 
46a4 03					inc bc 
46a5 23					inc hl 
46a6					if DEBUG_FORTH_WORDS 
46a6						DMARK "FN3" 
46a6 f5				push af  
46a7 3a bb 46			ld a, (.dmark)  
46aa 32 6e fe			ld (debug_mark),a  
46ad 3a bc 46			ld a, (.dmark+1)  
46b0 32 6f fe			ld (debug_mark+1),a  
46b3 3a bd 46			ld a, (.dmark+2)  
46b6 32 70 fe			ld (debug_mark+2),a  
46b9 18 03			jr .pastdmark  
46bb ..			.dmark: db "FN3"  
46be f1			.pastdmark: pop af  
46bf			endm  
# End of macro DMARK
46bf						CALLMONITOR 
46bf cd ab 18			call break_point_state  
46c2				endm  
# End of macro CALLMONITOR
46c2					endif 
46c2 18 d8				jr .findchar 
46c4			 
46c4			 
46c4 c5			.foundchar:	push bc 
46c5 e1					pop hl 
46c6 18 03				jr .findexit 
46c8			 
46c8			 
46c8							 
46c8			 
46c8			.finddone:     ; got to end of string with no find 
46c8 21 00 00				ld hl, 0 
46cb			.findexit: 
46cb			 
46cb					if DEBUG_FORTH_WORDS 
46cb						DMARK "FNd" 
46cb f5				push af  
46cc 3a e0 46			ld a, (.dmark)  
46cf 32 6e fe			ld (debug_mark),a  
46d2 3a e1 46			ld a, (.dmark+1)  
46d5 32 6f fe			ld (debug_mark+1),a  
46d8 3a e2 46			ld a, (.dmark+2)  
46db 32 70 fe			ld (debug_mark+2),a  
46de 18 03			jr .pastdmark  
46e0 ..			.dmark: db "FNd"  
46e3 f1			.pastdmark: pop af  
46e4			endm  
# End of macro DMARK
46e4						CALLMONITOR 
46e4 cd ab 18			call break_point_state  
46e7				endm  
# End of macro CALLMONITOR
46e7					endif 
46e7 cd 1f 1f			call forth_push_numhl 
46ea			 
46ea				       NEXTW 
46ea c3 8d 22			jp macro_next 
46ed				endm 
# End of macro NEXTW
46ed			 
46ed			.LEN: 
46ed				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
46ed 4c				db WORD_SYS_CORE+56             
46ee 57 47			dw .CHAR            
46f0 06				db 5 + 1 
46f1 .. 00			db "COUNT",0              
46f7				endm 
# End of macro CWHEAD
46f7			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
46f7			 
46f7					if DEBUG_FORTH_WORDS_KEY 
46f7						DMARK "CNT" 
46f7 f5				push af  
46f8 3a 0c 47			ld a, (.dmark)  
46fb 32 6e fe			ld (debug_mark),a  
46fe 3a 0d 47			ld a, (.dmark+1)  
4701 32 6f fe			ld (debug_mark+1),a  
4704 3a 0e 47			ld a, (.dmark+2)  
4707 32 70 fe			ld (debug_mark+2),a  
470a 18 03			jr .pastdmark  
470c ..			.dmark: db "CNT"  
470f f1			.pastdmark: pop af  
4710			endm  
# End of macro DMARK
4710						CALLMONITOR 
4710 cd ab 18			call break_point_state  
4713				endm  
# End of macro CALLMONITOR
4713					endif 
4713			; TODO check string type 
4713					FORTH_DSP_VALUE 
4713 cd ff 20			call macro_forth_dsp_value 
4716				endm 
# End of macro FORTH_DSP_VALUE
4716			 
4716			 
4716					if DEBUG_FORTH_WORDS 
4716						DMARK "CN?" 
4716 f5				push af  
4717 3a 2b 47			ld a, (.dmark)  
471a 32 6e fe			ld (debug_mark),a  
471d 3a 2c 47			ld a, (.dmark+1)  
4720 32 6f fe			ld (debug_mark+1),a  
4723 3a 2d 47			ld a, (.dmark+2)  
4726 32 70 fe			ld (debug_mark+2),a  
4729 18 03			jr .pastdmark  
472b ..			.dmark: db "CN?"  
472e f1			.pastdmark: pop af  
472f			endm  
# End of macro DMARK
472f						CALLMONITOR 
472f cd ab 18			call break_point_state  
4732				endm  
# End of macro CALLMONITOR
4732					endif 
4732 cd 62 13				call strlenz 
4735					if DEBUG_FORTH_WORDS 
4735						DMARK "CNl" 
4735 f5				push af  
4736 3a 4a 47			ld a, (.dmark)  
4739 32 6e fe			ld (debug_mark),a  
473c 3a 4b 47			ld a, (.dmark+1)  
473f 32 6f fe			ld (debug_mark+1),a  
4742 3a 4c 47			ld a, (.dmark+2)  
4745 32 70 fe			ld (debug_mark+2),a  
4748 18 03			jr .pastdmark  
474a ..			.dmark: db "CNl"  
474d f1			.pastdmark: pop af  
474e			endm  
# End of macro DMARK
474e						CALLMONITOR 
474e cd ab 18			call break_point_state  
4751				endm  
# End of macro CALLMONITOR
4751					endif 
4751			 
4751 cd 1f 1f				call forth_push_numhl 
4754			 
4754			 
4754			 
4754				       NEXTW 
4754 c3 8d 22			jp macro_next 
4757				endm 
# End of macro NEXTW
4757			.CHAR: 
4757				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
4757 4d				db WORD_SYS_CORE+57             
4758 8d 47			dw .ENDSTR            
475a 05				db 4 + 1 
475b .. 00			db "CHAR",0              
4760				endm 
# End of macro CWHEAD
4760			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
4760					if DEBUG_FORTH_WORDS_KEY 
4760						DMARK "CHR" 
4760 f5				push af  
4761 3a 75 47			ld a, (.dmark)  
4764 32 6e fe			ld (debug_mark),a  
4767 3a 76 47			ld a, (.dmark+1)  
476a 32 6f fe			ld (debug_mark+1),a  
476d 3a 77 47			ld a, (.dmark+2)  
4770 32 70 fe			ld (debug_mark+2),a  
4773 18 03			jr .pastdmark  
4775 ..			.dmark: db "CHR"  
4778 f1			.pastdmark: pop af  
4779			endm  
# End of macro DMARK
4779						CALLMONITOR 
4779 cd ab 18			call break_point_state  
477c				endm  
# End of macro CALLMONITOR
477c					endif 
477c					FORTH_DSP 
477c cd dc 20			call macro_forth_dsp 
477f				endm 
# End of macro FORTH_DSP
477f					;v5 FORTH_DSP_VALUE 
477f 23					inc hl      ; now at start of numeric as string 
4780			 
4780			;		push hl 
4780			 
4780					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4780 cd ce 21			call macro_forth_dsp_pop 
4783				endm 
# End of macro FORTH_DSP_POP
4783			 
4783			;		pop hl 
4783			 
4783					; push the content of a onto the stack as a value 
4783			 
4783 7e					ld a,(hl)   ; get char 
4784 26 00				ld h,0 
4786 6f					ld l,a 
4787 cd 1f 1f				call forth_push_numhl 
478a			 
478a				       NEXTW 
478a c3 8d 22			jp macro_next 
478d				endm 
# End of macro NEXTW
478d			 
478d			 
478d			 
478d			 
478d			.ENDSTR: 
478d			; eof 
478d			 
# End of file forth_words_str.asm
478d			include "forth_words_key.asm" 
478d			 
478d			; | ## Keyboard Words 
478d			 
478d			.KEY: 
478d				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
478d 3e				db WORD_SYS_CORE+42             
478e bd 47			dw .WAITK            
4790 04				db 3 + 1 
4791 .. 00			db "KEY",0              
4795				endm 
# End of macro CWHEAD
4795			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
4795			 
4795					if DEBUG_FORTH_WORDS_KEY 
4795						DMARK "KEY" 
4795 f5				push af  
4796 3a aa 47			ld a, (.dmark)  
4799 32 6e fe			ld (debug_mark),a  
479c 3a ab 47			ld a, (.dmark+1)  
479f 32 6f fe			ld (debug_mark+1),a  
47a2 3a ac 47			ld a, (.dmark+2)  
47a5 32 70 fe			ld (debug_mark+2),a  
47a8 18 03			jr .pastdmark  
47aa ..			.dmark: db "KEY"  
47ad f1			.pastdmark: pop af  
47ae			endm  
# End of macro DMARK
47ae						CALLMONITOR 
47ae cd ab 18			call break_point_state  
47b1				endm  
# End of macro CALLMONITOR
47b1					endif 
47b1			; TODO currently waits 
47b1 cd 49 6d				call cin 
47b4					;call cin_wait 
47b4 6f					ld l, a 
47b5 26 00				ld h, 0 
47b7 cd 1f 1f				call forth_push_numhl 
47ba					NEXTW 
47ba c3 8d 22			jp macro_next 
47bd				endm 
# End of macro NEXTW
47bd			.WAITK: 
47bd				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
47bd 3f				db WORD_SYS_CORE+43             
47be ef 47			dw .ACCEPT            
47c0 06				db 5 + 1 
47c1 .. 00			db "WAITK",0              
47c7				endm 
# End of macro CWHEAD
47c7			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
47c7					if DEBUG_FORTH_WORDS_KEY 
47c7						DMARK "WAI" 
47c7 f5				push af  
47c8 3a dc 47			ld a, (.dmark)  
47cb 32 6e fe			ld (debug_mark),a  
47ce 3a dd 47			ld a, (.dmark+1)  
47d1 32 6f fe			ld (debug_mark+1),a  
47d4 3a de 47			ld a, (.dmark+2)  
47d7 32 70 fe			ld (debug_mark+2),a  
47da 18 03			jr .pastdmark  
47dc ..			.dmark: db "WAI"  
47df f1			.pastdmark: pop af  
47e0			endm  
# End of macro DMARK
47e0						CALLMONITOR 
47e0 cd ab 18			call break_point_state  
47e3				endm  
# End of macro CALLMONITOR
47e3					endif 
47e3 cd 38 6d				call cin_wait 
47e6 6f					ld l, a 
47e7 26 00				ld h, 0 
47e9 cd 1f 1f				call forth_push_numhl 
47ec					NEXTW 
47ec c3 8d 22			jp macro_next 
47ef				endm 
# End of macro NEXTW
47ef			.ACCEPT: 
47ef				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
47ef 40				db WORD_SYS_CORE+44             
47f0 4d 48			dw .EDIT            
47f2 07				db 6 + 1 
47f3 .. 00			db "ACCEPT",0              
47fa				endm 
# End of macro CWHEAD
47fa			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
47fa					; TODO crashes on push 
47fa					if DEBUG_FORTH_WORDS_KEY 
47fa						DMARK "ACC" 
47fa f5				push af  
47fb 3a 0f 48			ld a, (.dmark)  
47fe 32 6e fe			ld (debug_mark),a  
4801 3a 10 48			ld a, (.dmark+1)  
4804 32 6f fe			ld (debug_mark+1),a  
4807 3a 11 48			ld a, (.dmark+2)  
480a 32 70 fe			ld (debug_mark+2),a  
480d 18 03			jr .pastdmark  
480f ..			.dmark: db "ACC"  
4812 f1			.pastdmark: pop af  
4813			endm  
# End of macro DMARK
4813						CALLMONITOR 
4813 cd ab 18			call break_point_state  
4816				endm  
# End of macro CALLMONITOR
4816					endif 
4816 21 fb f3				ld hl, os_input 
4819 3e 00				ld a, 0 
481b 77					ld (hl),a 
481c 3a 66 fa				ld a,(f_cursor_ptr) 
481f 16 64				ld d, 100 
4821 0e 00				ld c, 0 
4823 1e 28				ld e, 40 
4825 cd 31 0f				call input_str 
4828					; TODO perhaps do a type check and wrap in quotes if not a number 
4828 21 fb f3				ld hl, os_input 
482b					if DEBUG_FORTH_WORDS 
482b						DMARK "AC1" 
482b f5				push af  
482c 3a 40 48			ld a, (.dmark)  
482f 32 6e fe			ld (debug_mark),a  
4832 3a 41 48			ld a, (.dmark+1)  
4835 32 6f fe			ld (debug_mark+1),a  
4838 3a 42 48			ld a, (.dmark+2)  
483b 32 70 fe			ld (debug_mark+2),a  
483e 18 03			jr .pastdmark  
4840 ..			.dmark: db "AC1"  
4843 f1			.pastdmark: pop af  
4844			endm  
# End of macro DMARK
4844						CALLMONITOR 
4844 cd ab 18			call break_point_state  
4847				endm  
# End of macro CALLMONITOR
4847					endif 
4847 cd 8d 1f				call forth_push_str 
484a					NEXTW 
484a c3 8d 22			jp macro_next 
484d				endm 
# End of macro NEXTW
484d			 
484d			.EDIT: 
484d				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
484d 40				db WORD_SYS_CORE+44             
484e ef 48			dw .ENDKEY            
4850 05				db 4 + 1 
4851 .. 00			db "EDIT",0              
4856				endm 
# End of macro CWHEAD
4856			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4856			 
4856					; TODO does not copy from stack 
4856					if DEBUG_FORTH_WORDS_KEY 
4856						DMARK "EDT" 
4856 f5				push af  
4857 3a 6b 48			ld a, (.dmark)  
485a 32 6e fe			ld (debug_mark),a  
485d 3a 6c 48			ld a, (.dmark+1)  
4860 32 6f fe			ld (debug_mark+1),a  
4863 3a 6d 48			ld a, (.dmark+2)  
4866 32 70 fe			ld (debug_mark+2),a  
4869 18 03			jr .pastdmark  
486b ..			.dmark: db "EDT"  
486e f1			.pastdmark: pop af  
486f			endm  
# End of macro DMARK
486f						CALLMONITOR 
486f cd ab 18			call break_point_state  
4872				endm  
# End of macro CALLMONITOR
4872					endif 
4872			 
4872					;FORTH_DSP 
4872					FORTH_DSP_VALUEHL 
4872 cd 16 21			call macro_dsp_valuehl 
4875				endm 
# End of macro FORTH_DSP_VALUEHL
4875			;		inc hl    ; TODO do type check 
4875			 
4875			;		call get_word_hl 
4875 e5					push hl 
4876					if DEBUG_FORTH_WORDS 
4876						DMARK "EDp" 
4876 f5				push af  
4877 3a 8b 48			ld a, (.dmark)  
487a 32 6e fe			ld (debug_mark),a  
487d 3a 8c 48			ld a, (.dmark+1)  
4880 32 6f fe			ld (debug_mark+1),a  
4883 3a 8d 48			ld a, (.dmark+2)  
4886 32 70 fe			ld (debug_mark+2),a  
4889 18 03			jr .pastdmark  
488b ..			.dmark: db "EDp"  
488e f1			.pastdmark: pop af  
488f			endm  
# End of macro DMARK
488f						CALLMONITOR 
488f cd ab 18			call break_point_state  
4892				endm  
# End of macro CALLMONITOR
4892					endif 
4892				;	ld a, 0 
4892 cd 62 13				call strlenz 
4895 23					inc hl 
4896			 
4896 06 00				ld b, 0 
4898 4d					ld c, l 
4899			 
4899 e1					pop hl 
489a 11 fb f3				ld de, os_input 
489d					if DEBUG_FORTH_WORDS_KEY 
489d						DMARK "EDc" 
489d f5				push af  
489e 3a b2 48			ld a, (.dmark)  
48a1 32 6e fe			ld (debug_mark),a  
48a4 3a b3 48			ld a, (.dmark+1)  
48a7 32 6f fe			ld (debug_mark+1),a  
48aa 3a b4 48			ld a, (.dmark+2)  
48ad 32 70 fe			ld (debug_mark+2),a  
48b0 18 03			jr .pastdmark  
48b2 ..			.dmark: db "EDc"  
48b5 f1			.pastdmark: pop af  
48b6			endm  
# End of macro DMARK
48b6						CALLMONITOR 
48b6 cd ab 18			call break_point_state  
48b9				endm  
# End of macro CALLMONITOR
48b9					endif 
48b9 ed b0				ldir 
48bb			 
48bb			 
48bb 21 fb f3				ld hl, os_input 
48be					;ld a, 0 
48be					;ld (hl),a 
48be 3a 66 fa				ld a,(f_cursor_ptr) 
48c1 16 64				ld d, 100 
48c3 0e 00				ld c, 0 
48c5 1e 28				ld e, 40 
48c7 cd 31 0f				call input_str 
48ca					; TODO perhaps do a type check and wrap in quotes if not a number 
48ca 21 fb f3				ld hl, os_input 
48cd					if DEBUG_FORTH_WORDS 
48cd						DMARK "ED1" 
48cd f5				push af  
48ce 3a e2 48			ld a, (.dmark)  
48d1 32 6e fe			ld (debug_mark),a  
48d4 3a e3 48			ld a, (.dmark+1)  
48d7 32 6f fe			ld (debug_mark+1),a  
48da 3a e4 48			ld a, (.dmark+2)  
48dd 32 70 fe			ld (debug_mark+2),a  
48e0 18 03			jr .pastdmark  
48e2 ..			.dmark: db "ED1"  
48e5 f1			.pastdmark: pop af  
48e6			endm  
# End of macro DMARK
48e6						CALLMONITOR 
48e6 cd ab 18			call break_point_state  
48e9				endm  
# End of macro CALLMONITOR
48e9					endif 
48e9 cd 8d 1f				call forth_push_str 
48ec					NEXTW 
48ec c3 8d 22			jp macro_next 
48ef				endm 
# End of macro NEXTW
48ef			 
48ef			 
48ef			 
48ef			.ENDKEY: 
48ef			; eof 
48ef			 
# End of file forth_words_key.asm
48ef			 
48ef			if STORAGE_SE 
48ef			   	include "forth_words_storage.asm" 
48ef			 
48ef			; | ## Fixed Storage Words 
48ef			 
48ef			.RECORD: 
48ef			  
48ef				CWHEAD .BREAD 38 "RECORD" 6 WORD_FLAG_CODE 
48ef 3a				db WORD_SYS_CORE+38             
48f0 93 49			dw .BREAD            
48f2 07				db 6 + 1 
48f3 .. 00			db "RECORD",0              
48fa				endm 
# End of macro CWHEAD
48fa			; | RECORD ( u id -- s ) With the current bank, read record number u from file id and push to stack  | DONE 
48fa			 
48fa					if DEBUG_FORTH_WORDS_KEY 
48fa						DMARK "REC" 
48fa f5				push af  
48fb 3a 0f 49			ld a, (.dmark)  
48fe 32 6e fe			ld (debug_mark),a  
4901 3a 10 49			ld a, (.dmark+1)  
4904 32 6f fe			ld (debug_mark+1),a  
4907 3a 11 49			ld a, (.dmark+2)  
490a 32 70 fe			ld (debug_mark+2),a  
490d 18 03			jr .pastdmark  
490f ..			.dmark: db "REC"  
4912 f1			.pastdmark: pop af  
4913			endm  
# End of macro DMARK
4913						CALLMONITOR 
4913 cd ab 18			call break_point_state  
4916				endm  
# End of macro CALLMONITOR
4916					endif 
4916			 
4916					FORTH_DSP_VALUEHL 
4916 cd 16 21			call macro_dsp_valuehl 
4919				endm 
# End of macro FORTH_DSP_VALUEHL
4919			 
4919 e5					push hl    ; id 
491a			 
491a					FORTH_DSP_POP 
491a cd ce 21			call macro_forth_dsp_pop 
491d				endm 
# End of macro FORTH_DSP_POP
491d			 
491d					FORTH_DSP_VALUEHL 
491d cd 16 21			call macro_dsp_valuehl 
4920				endm 
# End of macro FORTH_DSP_VALUEHL
4920			 
4920					FORTH_DSP_POP 
4920 cd ce 21			call macro_forth_dsp_pop 
4923				endm 
# End of macro FORTH_DSP_POP
4923			 
4923 d1					pop de     ; get file id 
4924			 
4924					; e = file id 
4924					; l = file extent 
4924			 
4924			 
4924					; construct request to access file extent 
4924			 
4924			;		ld a, e 
4924 63					ld h, e 
4925					 
4925					 
4925					 
4925			 
4925					; e has id 
4925			 
4925 11 81 fa			ld de, store_page 
4928					if DEBUG_FORTH_WORDS 
4928						DMARK "REr" 
4928 f5				push af  
4929 3a 3d 49			ld a, (.dmark)  
492c 32 6e fe			ld (debug_mark),a  
492f 3a 3e 49			ld a, (.dmark+1)  
4932 32 6f fe			ld (debug_mark+1),a  
4935 3a 3f 49			ld a, (.dmark+2)  
4938 32 70 fe			ld (debug_mark+2),a  
493b 18 03			jr .pastdmark  
493d ..			.dmark: db "REr"  
4940 f1			.pastdmark: pop af  
4941			endm  
# End of macro DMARK
4941						CALLMONITOR 
4941 cd ab 18			call break_point_state  
4944				endm  
# End of macro CALLMONITOR
4944					endif 
4944 cd 2d 09				call storage_read 
4947 cd 2d 0f			call ishlzero 
494a 28 22			jr z, .recnotfound 
494c			 
494c			 
494c					if DEBUG_FORTH_WORDS 
494c						DMARK "REe" 
494c f5				push af  
494d 3a 61 49			ld a, (.dmark)  
4950 32 6e fe			ld (debug_mark),a  
4953 3a 62 49			ld a, (.dmark+1)  
4956 32 6f fe			ld (debug_mark+1),a  
4959 3a 63 49			ld a, (.dmark+2)  
495c 32 70 fe			ld (debug_mark+2),a  
495f 18 03			jr .pastdmark  
4961 ..			.dmark: db "REe"  
4964 f1			.pastdmark: pop af  
4965			endm  
# End of macro DMARK
4965						CALLMONITOR 
4965 cd ab 18			call break_point_state  
4968				endm  
# End of macro CALLMONITOR
4968					endif 
4968 cd 8d 1f			call forth_push_str 
496b			 
496b					NEXTW 
496b c3 8d 22			jp macro_next 
496e				endm 
# End of macro NEXTW
496e			 
496e			.recnotfound: 
496e					if DEBUG_FORTH_WORDS 
496e						DMARK "REf" 
496e f5				push af  
496f 3a 83 49			ld a, (.dmark)  
4972 32 6e fe			ld (debug_mark),a  
4975 3a 84 49			ld a, (.dmark+1)  
4978 32 6f fe			ld (debug_mark+1),a  
497b 3a 85 49			ld a, (.dmark+2)  
497e 32 70 fe			ld (debug_mark+2),a  
4981 18 03			jr .pastdmark  
4983 ..			.dmark: db "REf"  
4986 f1			.pastdmark: pop af  
4987			endm  
# End of macro DMARK
4987						CALLMONITOR 
4987 cd ab 18			call break_point_state  
498a				endm  
# End of macro CALLMONITOR
498a					endif 
498a 21 ff 00			ld hl, 255 
498d cd 1f 1f			call forth_push_numhl 
4990				NEXTW 
4990 c3 8d 22			jp macro_next 
4993				endm 
# End of macro NEXTW
4993			 
4993			 
4993			.BREAD: 
4993			  
4993				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
4993 3a				db WORD_SYS_CORE+38             
4994 16 4a			dw .BWRITE            
4996 06				db 5 + 1 
4997 .. 00			db "BREAD",0              
499d				endm 
# End of macro CWHEAD
499d			; | BREAD ( u -- u ) Lowlevel storage word. With the current bank, read a block from block address u (1-512) and push to stack  | DONE 
499d				 
499d					if DEBUG_FORTH_WORDS_KEY 
499d						DMARK "BRD" 
499d f5				push af  
499e 3a b2 49			ld a, (.dmark)  
49a1 32 6e fe			ld (debug_mark),a  
49a4 3a b3 49			ld a, (.dmark+1)  
49a7 32 6f fe			ld (debug_mark+1),a  
49aa 3a b4 49			ld a, (.dmark+2)  
49ad 32 70 fe			ld (debug_mark+2),a  
49b0 18 03			jr .pastdmark  
49b2 ..			.dmark: db "BRD"  
49b5 f1			.pastdmark: pop af  
49b6			endm  
# End of macro DMARK
49b6						CALLMONITOR 
49b6 cd ab 18			call break_point_state  
49b9				endm  
# End of macro CALLMONITOR
49b9					endif 
49b9			 
49b9				FORTH_DSP_VALUEHL 
49b9 cd 16 21			call macro_dsp_valuehl 
49bc				endm 
# End of macro FORTH_DSP_VALUEHL
49bc			 
49bc				FORTH_DSP_POP 
49bc cd ce 21			call macro_forth_dsp_pop 
49bf				endm 
# End of macro FORTH_DSP_POP
49bf			 
49bf				; calc block address 
49bf			 
49bf eb				ex de, hl 
49c0 3e 40			ld a, STORE_BLOCK_PHY 
49c2 cd 87 0e			call Mult16 
49c5			 
49c5			 
49c5 11 81 fa			ld de, store_page 
49c8			 
49c8					if DEBUG_FORTH_WORDS 
49c8						DMARK "BR1" 
49c8 f5				push af  
49c9 3a dd 49			ld a, (.dmark)  
49cc 32 6e fe			ld (debug_mark),a  
49cf 3a de 49			ld a, (.dmark+1)  
49d2 32 6f fe			ld (debug_mark+1),a  
49d5 3a df 49			ld a, (.dmark+2)  
49d8 32 70 fe			ld (debug_mark+2),a  
49db 18 03			jr .pastdmark  
49dd ..			.dmark: db "BR1"  
49e0 f1			.pastdmark: pop af  
49e1			endm  
# End of macro DMARK
49e1						CALLMONITOR 
49e1 cd ab 18			call break_point_state  
49e4				endm  
# End of macro CALLMONITOR
49e4					endif 
49e4			 
49e4 cd d4 03			call storage_read_block 
49e7			 
49e7 cd 2d 0f			call ishlzero 
49ea 20 05			jr nz, .brfound 
49ec			 
49ec cd 1f 1f			call forth_push_numhl 
49ef 18 22			jr .brdone 
49f1			 
49f1			 
49f1			.brfound: 
49f1 21 83 fa		        ld hl, store_page+2 
49f4			 
49f4					if DEBUG_FORTH_WORDS 
49f4						DMARK "BR2" 
49f4 f5				push af  
49f5 3a 09 4a			ld a, (.dmark)  
49f8 32 6e fe			ld (debug_mark),a  
49fb 3a 0a 4a			ld a, (.dmark+1)  
49fe 32 6f fe			ld (debug_mark+1),a  
4a01 3a 0b 4a			ld a, (.dmark+2)  
4a04 32 70 fe			ld (debug_mark+2),a  
4a07 18 03			jr .pastdmark  
4a09 ..			.dmark: db "BR2"  
4a0c f1			.pastdmark: pop af  
4a0d			endm  
# End of macro DMARK
4a0d						CALLMONITOR 
4a0d cd ab 18			call break_point_state  
4a10				endm  
# End of macro CALLMONITOR
4a10					endif 
4a10			 
4a10 cd 8d 1f			call forth_push_str 
4a13			 
4a13			 
4a13			.brdone: 
4a13			 
4a13					NEXTW 
4a13 c3 8d 22			jp macro_next 
4a16				endm 
# End of macro NEXTW
4a16			.BWRITE: 
4a16				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
4a16 3a				db WORD_SYS_CORE+38             
4a17 ab 4a			dw .BUPD            
4a19 07				db 6 + 1 
4a1a .. 00			db "BWRITE",0              
4a21				endm 
# End of macro CWHEAD
4a21			; | BWRITE ( s u -- ) Lowlevel storage word. With the current bank, write the string s to address u | DONE 
4a21			 
4a21					if DEBUG_FORTH_WORDS_KEY 
4a21						DMARK "BWR" 
4a21 f5				push af  
4a22 3a 36 4a			ld a, (.dmark)  
4a25 32 6e fe			ld (debug_mark),a  
4a28 3a 37 4a			ld a, (.dmark+1)  
4a2b 32 6f fe			ld (debug_mark+1),a  
4a2e 3a 38 4a			ld a, (.dmark+2)  
4a31 32 70 fe			ld (debug_mark+2),a  
4a34 18 03			jr .pastdmark  
4a36 ..			.dmark: db "BWR"  
4a39 f1			.pastdmark: pop af  
4a3a			endm  
# End of macro DMARK
4a3a						CALLMONITOR 
4a3a cd ab 18			call break_point_state  
4a3d				endm  
# End of macro CALLMONITOR
4a3d					endif 
4a3d			 
4a3d				FORTH_DSP_VALUEHL 
4a3d cd 16 21			call macro_dsp_valuehl 
4a40				endm 
# End of macro FORTH_DSP_VALUEHL
4a40			 
4a40				; calc block address 
4a40			 
4a40 eb				ex de, hl 
4a41 3e 40			ld a, STORE_BLOCK_PHY 
4a43 cd 87 0e			call Mult16 
4a46			 
4a46 e5				push hl         ; address 
4a47			 
4a47				FORTH_DSP_POP 
4a47 cd ce 21			call macro_forth_dsp_pop 
4a4a				endm 
# End of macro FORTH_DSP_POP
4a4a			 
4a4a				FORTH_DSP_VALUEHL 
4a4a cd 16 21			call macro_dsp_valuehl 
4a4d				endm 
# End of macro FORTH_DSP_VALUEHL
4a4d			 
4a4d				FORTH_DSP_POP 
4a4d cd ce 21			call macro_forth_dsp_pop 
4a50				endm 
# End of macro FORTH_DSP_POP
4a50			 
4a50 cd 10 0c			call storage_clear_page 
4a53			 
4a53				; copy string to store page 
4a53			 
4a53 e5				push hl     ; save string address 
4a54			 
4a54 3e 00			ld a, 0 
4a56 cd 6d 13			call strlent 
4a59			 
4a59 23				inc hl 
4a5a			 
4a5a 4d				ld c, l 
4a5b 06 00			ld b, 0 
4a5d			 
4a5d e1				pop hl 
4a5e 11 83 fa			ld de, store_page + 2 
4a61					if DEBUG_FORTH_WORDS 
4a61						DMARK "BW1" 
4a61 f5				push af  
4a62 3a 76 4a			ld a, (.dmark)  
4a65 32 6e fe			ld (debug_mark),a  
4a68 3a 77 4a			ld a, (.dmark+1)  
4a6b 32 6f fe			ld (debug_mark+1),a  
4a6e 3a 78 4a			ld a, (.dmark+2)  
4a71 32 70 fe			ld (debug_mark+2),a  
4a74 18 03			jr .pastdmark  
4a76 ..			.dmark: db "BW1"  
4a79 f1			.pastdmark: pop af  
4a7a			endm  
# End of macro DMARK
4a7a						CALLMONITOR 
4a7a cd ab 18			call break_point_state  
4a7d				endm  
# End of macro CALLMONITOR
4a7d					endif 
4a7d ed b0			ldir 
4a7f			 
4a7f			 
4a7f				; poke the start of the block with flags to prevent high level file ops hitting the block 
4a7f			 
4a7f 21 ff ff			ld hl, $ffff 
4a82			 
4a82 22 81 fa			ld (store_page), hl	 
4a85				 
4a85 e1				pop hl    ; get address 
4a86 11 81 fa			ld de, store_page 
4a89			 
4a89					if DEBUG_FORTH_WORDS 
4a89						DMARK "BW2" 
4a89 f5				push af  
4a8a 3a 9e 4a			ld a, (.dmark)  
4a8d 32 6e fe			ld (debug_mark),a  
4a90 3a 9f 4a			ld a, (.dmark+1)  
4a93 32 6f fe			ld (debug_mark+1),a  
4a96 3a a0 4a			ld a, (.dmark+2)  
4a99 32 70 fe			ld (debug_mark+2),a  
4a9c 18 03			jr .pastdmark  
4a9e ..			.dmark: db "BW2"  
4aa1 f1			.pastdmark: pop af  
4aa2			endm  
# End of macro DMARK
4aa2						CALLMONITOR 
4aa2 cd ab 18			call break_point_state  
4aa5				endm  
# End of macro CALLMONITOR
4aa5					endif 
4aa5			 
4aa5 cd 39 04			call storage_write_block 
4aa8			 
4aa8					NEXTW 
4aa8 c3 8d 22			jp macro_next 
4aab				endm 
# End of macro NEXTW
4aab			 
4aab			.BUPD: 
4aab				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
4aab 3a				db WORD_SYS_CORE+38             
4aac 01 4b			dw .BYID            
4aae 05				db 4 + 1 
4aaf .. 00			db "BUPD",0              
4ab4				endm 
# End of macro CWHEAD
4ab4			; | BUPD ( u -- ) Lowlevel storage word. Write the contents of the current file system storage buffer directly to address u | DONE 
4ab4			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
4ab4			; | | or completely different file system structure. 
4ab4			 
4ab4					if DEBUG_FORTH_WORDS_KEY 
4ab4						DMARK "BUD" 
4ab4 f5				push af  
4ab5 3a c9 4a			ld a, (.dmark)  
4ab8 32 6e fe			ld (debug_mark),a  
4abb 3a ca 4a			ld a, (.dmark+1)  
4abe 32 6f fe			ld (debug_mark+1),a  
4ac1 3a cb 4a			ld a, (.dmark+2)  
4ac4 32 70 fe			ld (debug_mark+2),a  
4ac7 18 03			jr .pastdmark  
4ac9 ..			.dmark: db "BUD"  
4acc f1			.pastdmark: pop af  
4acd			endm  
# End of macro DMARK
4acd						CALLMONITOR 
4acd cd ab 18			call break_point_state  
4ad0				endm  
# End of macro CALLMONITOR
4ad0					endif 
4ad0			 
4ad0				FORTH_DSP_VALUEHL 
4ad0 cd 16 21			call macro_dsp_valuehl 
4ad3				endm 
# End of macro FORTH_DSP_VALUEHL
4ad3			 
4ad3				; calc block address 
4ad3			 
4ad3 eb				ex de, hl 
4ad4 3e 40			ld a, STORE_BLOCK_PHY 
4ad6 cd 87 0e			call Mult16 
4ad9			 
4ad9				FORTH_DSP_POP 
4ad9 cd ce 21			call macro_forth_dsp_pop 
4adc				endm 
# End of macro FORTH_DSP_POP
4adc			 
4adc			 
4adc 11 81 fa			ld de, store_page 
4adf			 
4adf					if DEBUG_FORTH_WORDS 
4adf						DMARK "BUe" 
4adf f5				push af  
4ae0 3a f4 4a			ld a, (.dmark)  
4ae3 32 6e fe			ld (debug_mark),a  
4ae6 3a f5 4a			ld a, (.dmark+1)  
4ae9 32 6f fe			ld (debug_mark+1),a  
4aec 3a f6 4a			ld a, (.dmark+2)  
4aef 32 70 fe			ld (debug_mark+2),a  
4af2 18 03			jr .pastdmark  
4af4 ..			.dmark: db "BUe"  
4af7 f1			.pastdmark: pop af  
4af8			endm  
# End of macro DMARK
4af8						CALLMONITOR 
4af8 cd ab 18			call break_point_state  
4afb				endm  
# End of macro CALLMONITOR
4afb					endif 
4afb			 
4afb cd 39 04			call storage_write_block 
4afe			 
4afe					NEXTW 
4afe c3 8d 22			jp macro_next 
4b01				endm 
# End of macro NEXTW
4b01			 
4b01			.BYID: 
4b01			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
4b01			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
4b01			; 
4b01			;		 
4b01			;		if DEBUG_FORTH_WORDS_KEY 
4b01			;			DMARK "BYID" 
4b01			;			CALLMONITOR 
4b01			;		endif 
4b01			; 
4b01			;		; get direct address 
4b01			; 
4b01			;		FORTH_DSP_VALUEHL 
4b01			; 
4b01			;		FORTH_DSP_POP 
4b01			; 
4b01			;	; calc block address 
4b01			; 
4b01			;	ex de, hl 
4b01			;	ld a, STORE_BLOCK_PHY 
4b01			;	call Mult16 
4b01			;	;	do BREAD with number as param 
4b01			;	; push the file name	 
4b01			;	ld de, store_page 
4b01			;	call storage_read_block 
4b01			 ;       ld hl, store_page+2 
4b01			; 
4b01			; 
4b01			;		NEXTW 
4b01			;.BYNAME: 
4b01				CWHEAD .DIR 38 "GETID" 5 WORD_FLAG_CODE 
4b01 3a				db WORD_SYS_CORE+38             
4b02 1a 4b			dw .DIR            
4b04 06				db 5 + 1 
4b05 .. 00			db "GETID",0              
4b0b				endm 
# End of macro CWHEAD
4b0b			; | GETID ( s -- u ) Get the file ID in the current BANK of the file named s | DONE 
4b0b			 
4b0b					; get pointer to file name to seek 
4b0b			 
4b0b					FORTH_DSP_VALUEHL 
4b0b cd 16 21			call macro_dsp_valuehl 
4b0e				endm 
# End of macro FORTH_DSP_VALUEHL
4b0e			 
4b0e			 
4b0e cd fb 02				call storage_getid  
4b11			 
4b11					FORTH_DSP_POP 
4b11 cd ce 21			call macro_forth_dsp_pop 
4b14				endm 
# End of macro FORTH_DSP_POP
4b14			 
4b14 cd 1f 1f				call forth_push_numhl 
4b17			 
4b17					NEXTW 
4b17 c3 8d 22			jp macro_next 
4b1a				endm 
# End of macro NEXTW
4b1a			; 
4b1a			.DIR: 
4b1a				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
4b1a 3a				db WORD_SYS_CORE+38             
4b1b 1e 4c			dw .SAVE            
4b1d 04				db 3 + 1 
4b1e .. 00			db "DIR",0              
4b22				endm 
# End of macro CWHEAD
4b22			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
4b22			 
4b22					if DEBUG_FORTH_WORDS_KEY 
4b22						DMARK "DIR" 
4b22 f5				push af  
4b23 3a 37 4b			ld a, (.dmark)  
4b26 32 6e fe			ld (debug_mark),a  
4b29 3a 38 4b			ld a, (.dmark+1)  
4b2c 32 6f fe			ld (debug_mark+1),a  
4b2f 3a 39 4b			ld a, (.dmark+2)  
4b32 32 70 fe			ld (debug_mark+2),a  
4b35 18 03			jr .pastdmark  
4b37 ..			.dmark: db "DIR"  
4b3a f1			.pastdmark: pop af  
4b3b			endm  
# End of macro DMARK
4b3b						CALLMONITOR 
4b3b cd ab 18			call break_point_state  
4b3e				endm  
# End of macro CALLMONITOR
4b3e					endif 
4b3e cd 85 04			call storage_get_block_0 
4b41			 
4b41 21 81 fa			ld hl, store_page     ; get current id count 
4b44 46				ld b, (hl) 
4b45 0e 00			ld c, 0    ; count of files   
4b47					if DEBUG_FORTH_WORDS 
4b47						DMARK "DI1" 
4b47 f5				push af  
4b48 3a 5c 4b			ld a, (.dmark)  
4b4b 32 6e fe			ld (debug_mark),a  
4b4e 3a 5d 4b			ld a, (.dmark+1)  
4b51 32 6f fe			ld (debug_mark+1),a  
4b54 3a 5e 4b			ld a, (.dmark+2)  
4b57 32 70 fe			ld (debug_mark+2),a  
4b5a 18 03			jr .pastdmark  
4b5c ..			.dmark: db "DI1"  
4b5f f1			.pastdmark: pop af  
4b60			endm  
# End of macro DMARK
4b60						CALLMONITOR 
4b60 cd ab 18			call break_point_state  
4b63				endm  
# End of macro CALLMONITOR
4b63					endif 
4b63			 
4b63				; check for empty drive 
4b63			 
4b63 3e 00			ld a, 0 
4b65 b8				cp b 
4b66 ca d4 4b			jp z, .dirdone 
4b69			 
4b69				; for each of the current ids do a search for them and if found push to stack 
4b69			 
4b69 c5			.diritem:	push bc 
4b6a 21 40 00				ld hl, STORE_BLOCK_PHY 
4b6d 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
4b6f 58					ld e,b 
4b70			 
4b70			;		if DEBUG_FORTH_WORDS 
4b70			;			DMARK "DI2" 
4b70			;			CALLMONITOR 
4b70			;		endif 
4b70			 
4b70 cd 07 07				call storage_findnextid 
4b73			 
4b73			;		if DEBUG_FORTH_WORDS 
4b73			;			DMARK "DI3" 
4b73			;			CALLMONITOR 
4b73			;		endif 
4b73			 
4b73					; if found hl will be non zero 
4b73			 
4b73 cd 2d 0f				call ishlzero 
4b76			;		ld a, l 
4b76			;		add h 
4b76			; 
4b76			;		cp 0 
4b76 28 59				jr z, .dirnotfound 
4b78			 
4b78					; increase count 
4b78			 
4b78 c1					pop bc	 
4b79 0c					inc c 
4b7a c5					push bc 
4b7b					 
4b7b			 
4b7b					; get file header and push the file name 
4b7b			 
4b7b 11 81 fa				ld de, store_page 
4b7e cd d4 03				call storage_read_block 
4b81			 
4b81					; push file id to stack 
4b81				 
4b81 3a 81 fa				ld a, (store_page) 
4b84 26 00				ld h, 0 
4b86 6f					ld l, a 
4b87 cd 1f 1f				call forth_push_numhl 
4b8a			 
4b8a					; push extent count to stack  
4b8a				 
4b8a 3a 83 fa				ld a, (store_page+2) 
4b8d 26 00				ld h, 0 
4b8f 6f					ld l, a 
4b90 cd 1f 1f				call forth_push_numhl 
4b93			 
4b93					; push file name 
4b93			 
4b93 21 84 fa				ld hl, store_page+3 
4b96					if DEBUG_FORTH_WORDS 
4b96						DMARK "DI5" 
4b96 f5				push af  
4b97 3a ab 4b			ld a, (.dmark)  
4b9a 32 6e fe			ld (debug_mark),a  
4b9d 3a ac 4b			ld a, (.dmark+1)  
4ba0 32 6f fe			ld (debug_mark+1),a  
4ba3 3a ad 4b			ld a, (.dmark+2)  
4ba6 32 70 fe			ld (debug_mark+2),a  
4ba9 18 03			jr .pastdmark  
4bab ..			.dmark: db "DI5"  
4bae f1			.pastdmark: pop af  
4baf			endm  
# End of macro DMARK
4baf						CALLMONITOR 
4baf cd ab 18			call break_point_state  
4bb2				endm  
# End of macro CALLMONITOR
4bb2					endif 
4bb2 cd 8d 1f				call forth_push_str 
4bb5					if DEBUG_FORTH_WORDS 
4bb5						DMARK "DI6" 
4bb5 f5				push af  
4bb6 3a ca 4b			ld a, (.dmark)  
4bb9 32 6e fe			ld (debug_mark),a  
4bbc 3a cb 4b			ld a, (.dmark+1)  
4bbf 32 6f fe			ld (debug_mark+1),a  
4bc2 3a cc 4b			ld a, (.dmark+2)  
4bc5 32 70 fe			ld (debug_mark+2),a  
4bc8 18 03			jr .pastdmark  
4bca ..			.dmark: db "DI6"  
4bcd f1			.pastdmark: pop af  
4bce			endm  
# End of macro DMARK
4bce						CALLMONITOR 
4bce cd ab 18			call break_point_state  
4bd1				endm  
# End of macro CALLMONITOR
4bd1					endif 
4bd1			.dirnotfound: 
4bd1 c1					pop bc     
4bd2 10 95				djnz .diritem 
4bd4				 
4bd4			.dirdone:	 
4bd4					if DEBUG_FORTH_WORDS 
4bd4						DMARK "DI7" 
4bd4 f5				push af  
4bd5 3a e9 4b			ld a, (.dmark)  
4bd8 32 6e fe			ld (debug_mark),a  
4bdb 3a ea 4b			ld a, (.dmark+1)  
4bde 32 6f fe			ld (debug_mark+1),a  
4be1 3a eb 4b			ld a, (.dmark+2)  
4be4 32 70 fe			ld (debug_mark+2),a  
4be7 18 03			jr .pastdmark  
4be9 ..			.dmark: db "DI7"  
4bec f1			.pastdmark: pop af  
4bed			endm  
# End of macro DMARK
4bed						CALLMONITOR 
4bed cd ab 18			call break_point_state  
4bf0				endm  
# End of macro CALLMONITOR
4bf0					endif 
4bf0			 
4bf0					; push a count of the dir items found 
4bf0			 
4bf0 26 00				ld h, 0 
4bf2 69					ld l, c 
4bf3 cd 1f 1f				call forth_push_numhl 
4bf6			 
4bf6					; push the bank label 
4bf6			 
4bf6 cd 85 04				call storage_get_block_0 
4bf9			 
4bf9				 
4bf9 21 84 fa		 		ld hl, store_page+3 
4bfc			 
4bfc					if DEBUG_FORTH_WORDS 
4bfc						DMARK "DI8" 
4bfc f5				push af  
4bfd 3a 11 4c			ld a, (.dmark)  
4c00 32 6e fe			ld (debug_mark),a  
4c03 3a 12 4c			ld a, (.dmark+1)  
4c06 32 6f fe			ld (debug_mark+1),a  
4c09 3a 13 4c			ld a, (.dmark+2)  
4c0c 32 70 fe			ld (debug_mark+2),a  
4c0f 18 03			jr .pastdmark  
4c11 ..			.dmark: db "DI8"  
4c14 f1			.pastdmark: pop af  
4c15			endm  
# End of macro DMARK
4c15						CALLMONITOR 
4c15 cd ab 18			call break_point_state  
4c18				endm  
# End of macro CALLMONITOR
4c18					endif 
4c18 cd 8d 1f				call forth_push_str 
4c1b			 
4c1b			 
4c1b				 
4c1b					NEXTW 
4c1b c3 8d 22			jp macro_next 
4c1e				endm 
# End of macro NEXTW
4c1e			.SAVE: 
4c1e			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
4c1e			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
4c1e			;		NEXTW 
4c1e			;.LOAD: 
4c1e			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
4c1e			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
4c1e			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
4c1e			;; > > The LOAD command can not be used in any user words or compound lines. 
4c1e			; 
4c1e			;		; store_openext use it. If zero it is EOF 
4c1e			; 
4c1e			;		; read block from current stream id 
4c1e			;		; if the block does not contain zero term keep reading blocks until zero found 
4c1e			;		; push the block to stack 
4c1e			;		; save the block id to stream 
4c1e			; 
4c1e			; 
4c1e			;		FORTH_DSP_VALUEHL 
4c1e			; 
4c1e			;;		push hl 
4c1e			; 
4c1e			;	if DEBUG_STORESE 
4c1e			;		DMARK "LOA" 
4c1e			;		CALLMONITOR 
4c1e			;	endif 
4c1e			;		FORTH_DSP_POP 
4c1e			; 
4c1e			;;		pop hl 
4c1e			; 
4c1e			;		ld h, l 
4c1e			;		ld l, 0 
4c1e			; 
4c1e			;		push hl     ; stack holds current file id and extent to work with 
4c1e			; 
4c1e			; 
4c1e			;		ld de, store_page      ; get block zero of file 
4c1e			;	if DEBUG_STORESE 
4c1e			;		DMARK "LO0" 
4c1e			;		CALLMONITOR 
4c1e			;	endif 
4c1e			;		call storage_read 
4c1e			; 
4c1e			;		ld a, (store_page+2)    ; max extents for this file 
4c1e			;		ld  (store_openmaxext),a   ; get our limit 
4c1e			; 
4c1e			;	if DEBUG_STORESE 
4c1e			;		DMARK "LOE" 
4c1e			;		CALLMONITOR 
4c1e			;	endif 
4c1e			; 
4c1e			;; TODO dont know why max extents are not present 
4c1e			;;		cp 0 
4c1e			;;		jp z, .loadeof     ; dont read past eof 
4c1e			; 
4c1e			;;		ld a, 1   ; start from the head of the file 
4c1e			; 
4c1e			;.loadline:	pop hl 
4c1e			;		inc hl 
4c1e			;		ld  a, (store_openmaxext)   ; get our limit 
4c1e			;	if DEBUG_STORESE 
4c1e			;		DMARK "LOx" 
4c1e			;		CALLMONITOR 
4c1e			;	endif 
4c1e			;		inc a 
4c1e			;		cp l 
4c1e			;		jp z, .loadeof 
4c1e			;		push hl    ; save current extent 
4c1e			; 
4c1e			;		ld de, store_page 
4c1e			; 
4c1e			;	if DEBUG_STORESE 
4c1e			;		DMARK "LO1" 
4c1e			;		CALLMONITOR 
4c1e			;	endif 
4c1e			;		call storage_read 
4c1e			; 
4c1e			;	if DEBUG_STORESE 
4c1e			;		DMARK "LO2" 
4c1e			;		CALLMONITOR 
4c1e			;	endif 
4c1e			;	call ishlzero 
4c1e			;	ld a, l 
4c1e			;	add h 
4c1e			;	cp 0 
4c1e			;	jr z, .loadeof 
4c1e			; 
4c1e			;	; not eof so hl should point to data to exec 
4c1e			; 
4c1e			;	; will need to add the FORTH_END_BUFFER flag 
4c1e			 ; 
4c1e			;	ld hl, store_page+2 
4c1e			;	ld bc, 255 
4c1e			;	ld a, 0 
4c1e			;	cpir 
4c1e			;	if DEBUG_STORESE 
4c1e			;		DMARK "LOt" 
4c1e			;		CALLMONITOR 
4c1e			;	endif 
4c1e			;	dec hl 
4c1e			;	ld a, ' ' 
4c1e			;	ld (hl), a 
4c1e			;	inc hl 
4c1e			;	ld (hl), a 
4c1e			;	inc hl 
4c1e			;	ld (hl), a 
4c1e			;	inc hl 
4c1e			;	ld a, FORTH_END_BUFFER 
4c1e			;	ld (hl), a 
4c1e			; 
4c1e			;	; TODO handle more than a single block read 
4c1e			; 
4c1e			; 
4c1e			;	ld hl, store_page+2 
4c1e			; 
4c1e			;	ld (os_tok_ptr), hl 
4c1e			; 
4c1e			;	if DEBUG_STORESE 
4c1e			;		DMARK "LO3" 
4c1e			;		CALLMONITOR 
4c1e			;	endif 
4c1e			; 
4c1e			;	call forthparse 
4c1e			;	call forthexec 
4c1e			;	call forthexec_cleanup 
4c1e			; 
4c1e			;	; go to next extent 
4c1e			; 
4c1e			;	; get next block  or mark as eof 
4c1e			;	jp .loadline 
4c1e			; 
4c1e			; 
4c1e			; 
4c1e			;	       NEXTW 
4c1e			;.loadeof:	ld a, 0 
4c1e			;		ld (store_openext), a 
4c1e			; 
4c1e			;	if DEBUG_STORESE 
4c1e			;		DMARK "LOF" 
4c1e			;		CALLMONITOR 
4c1e			;	endif 
4c1e			;		ret 
4c1e			;		;NEXTW 
4c1e			;.BSAVE:   
4c1e			; 
4c1e			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
4c1e			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
4c1e			;		NEXTW 
4c1e			;.BLOAD: 
4c1e			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
4c1e			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
4c1e			;		NEXTW 
4c1e			;;;; counter gap 
4c1e			 
4c1e			 
4c1e			.SEO: 
4c1e				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
4c1e 64				db WORD_SYS_CORE+80             
4c1f 3d 4c			dw .SEI            
4c21 04				db 3 + 1 
4c22 .. 00			db "SEO",0              
4c26				endm 
# End of macro CWHEAD
4c26			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
4c26			 
4c26					; get port 
4c26			 
4c26					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4c26 cd 16 21			call macro_dsp_valuehl 
4c29				endm 
# End of macro FORTH_DSP_VALUEHL
4c29			 
4c29 e5					push hl    ; u2 - byte 
4c2a			 
4c2a					; destroy value TOS 
4c2a			 
4c2a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c2a cd ce 21			call macro_forth_dsp_pop 
4c2d				endm 
# End of macro FORTH_DSP_POP
4c2d			 
4c2d					; get byte to send 
4c2d			 
4c2d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4c2d cd 16 21			call macro_dsp_valuehl 
4c30				endm 
# End of macro FORTH_DSP_VALUEHL
4c30			 
4c30 e5					push hl    ; u1 - addr 
4c31			 
4c31					; destroy value TOS 
4c31			 
4c31					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c31 cd ce 21			call macro_forth_dsp_pop 
4c34				endm 
# End of macro FORTH_DSP_POP
4c34			 
4c34					; one value on hl get other one back 
4c34			 
4c34 d1					pop de   ; u1 - byte 
4c35			 
4c35 e1					pop hl   ; u2 - addr 
4c36			 
4c36					; TODO Send SPI byte 
4c36			 
4c36			 
4c36 7b					ld a, e 
4c37 cd d9 01				call se_writebyte 
4c3a			 
4c3a					 
4c3a			 
4c3a					NEXTW 
4c3a c3 8d 22			jp macro_next 
4c3d				endm 
# End of macro NEXTW
4c3d			 
4c3d			.SEI: 
4c3d				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
4c3d 65				db WORD_SYS_CORE+81             
4c3e 57 4c			dw .SFREE            
4c40 04				db 3 + 1 
4c41 .. 00			db "SEI",0              
4c45				endm 
# End of macro CWHEAD
4c45			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
4c45			 
4c45					; get port 
4c45			 
4c45					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4c45 cd 16 21			call macro_dsp_valuehl 
4c48				endm 
# End of macro FORTH_DSP_VALUEHL
4c48			 
4c48			;		push hl 
4c48			 
4c48					; destroy value TOS 
4c48			 
4c48					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c48 cd ce 21			call macro_forth_dsp_pop 
4c4b				endm 
# End of macro FORTH_DSP_POP
4c4b			 
4c4b					; one value on hl get other one back 
4c4b			 
4c4b			;		pop hl 
4c4b			 
4c4b			 
4c4b					; TODO Get SPI byte 
4c4b			 
4c4b cd 7b 02				call se_readbyte 
4c4e			 
4c4e 26 00				ld h, 0 
4c50 6f					ld l, a 
4c51 cd 1f 1f				call forth_push_numhl 
4c54			 
4c54					NEXTW 
4c54 c3 8d 22			jp macro_next 
4c57				endm 
# End of macro NEXTW
4c57			 
4c57			.SFREE: 
4c57				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
4c57 67				db WORD_SYS_CORE+83             
4c58 86 4c			dw .SIZE            
4c5a 06				db 5 + 1 
4c5b .. 00			db "FFREE",0              
4c61				endm 
# End of macro CWHEAD
4c61			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
4c61					if DEBUG_FORTH_WORDS_KEY 
4c61						DMARK "FFR" 
4c61 f5				push af  
4c62 3a 76 4c			ld a, (.dmark)  
4c65 32 6e fe			ld (debug_mark),a  
4c68 3a 77 4c			ld a, (.dmark+1)  
4c6b 32 6f fe			ld (debug_mark+1),a  
4c6e 3a 78 4c			ld a, (.dmark+2)  
4c71 32 70 fe			ld (debug_mark+2),a  
4c74 18 03			jr .pastdmark  
4c76 ..			.dmark: db "FFR"  
4c79 f1			.pastdmark: pop af  
4c7a			endm  
# End of macro DMARK
4c7a						CALLMONITOR 
4c7a cd ab 18			call break_point_state  
4c7d				endm  
# End of macro CALLMONITOR
4c7d					endif 
4c7d			 
4c7d cd a1 07				call storage_freeblocks 
4c80			 
4c80 cd 1f 1f				call forth_push_numhl 
4c83			 
4c83				       NEXTW 
4c83 c3 8d 22			jp macro_next 
4c86				endm 
# End of macro NEXTW
4c86			.SIZE: 
4c86				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
4c86 67				db WORD_SYS_CORE+83             
4c87 ba 4c			dw .CREATE            
4c89 05				db 4 + 1 
4c8a .. 00			db "SIZE",0              
4c8f				endm 
# End of macro CWHEAD
4c8f			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
4c8f					if DEBUG_FORTH_WORDS_KEY 
4c8f						DMARK "SIZ" 
4c8f f5				push af  
4c90 3a a4 4c			ld a, (.dmark)  
4c93 32 6e fe			ld (debug_mark),a  
4c96 3a a5 4c			ld a, (.dmark+1)  
4c99 32 6f fe			ld (debug_mark+1),a  
4c9c 3a a6 4c			ld a, (.dmark+2)  
4c9f 32 70 fe			ld (debug_mark+2),a  
4ca2 18 03			jr .pastdmark  
4ca4 ..			.dmark: db "SIZ"  
4ca7 f1			.pastdmark: pop af  
4ca8			endm  
# End of macro DMARK
4ca8						CALLMONITOR 
4ca8 cd ab 18			call break_point_state  
4cab				endm  
# End of macro CALLMONITOR
4cab					endif 
4cab			 
4cab					FORTH_DSP_VALUEHL 
4cab cd 16 21			call macro_dsp_valuehl 
4cae				endm 
# End of macro FORTH_DSP_VALUEHL
4cae			;		push hl 
4cae					FORTH_DSP_POP 
4cae cd ce 21			call macro_forth_dsp_pop 
4cb1				endm 
# End of macro FORTH_DSP_POP
4cb1			;		pop hl 
4cb1 cd 03 04				call storage_file_size 
4cb4			 
4cb4 cd 1f 1f				call forth_push_numhl 
4cb7			  
4cb7			 
4cb7				       NEXTW 
4cb7 c3 8d 22			jp macro_next 
4cba				endm 
# End of macro NEXTW
4cba			 
4cba			.CREATE: 
4cba				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
4cba 68				db WORD_SYS_CORE+84             
4cbb 28 4d			dw .APPEND            
4cbd 07				db 6 + 1 
4cbe .. 00			db "CREATE",0              
4cc5				endm 
# End of macro CWHEAD
4cc5			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
4cc5			; | | e.g.  
4cc5			; | | TestProgram CREATE 
4cc5			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
4cc5			; | |  
4cc5			; | | Max file IDs are 255. 
4cc5			; | |  
4cc5					 
4cc5					if DEBUG_FORTH_WORDS_KEY 
4cc5						DMARK "CRT" 
4cc5 f5				push af  
4cc6 3a da 4c			ld a, (.dmark)  
4cc9 32 6e fe			ld (debug_mark),a  
4ccc 3a db 4c			ld a, (.dmark+1)  
4ccf 32 6f fe			ld (debug_mark+1),a  
4cd2 3a dc 4c			ld a, (.dmark+2)  
4cd5 32 70 fe			ld (debug_mark+2),a  
4cd8 18 03			jr .pastdmark  
4cda ..			.dmark: db "CRT"  
4cdd f1			.pastdmark: pop af  
4cde			endm  
# End of macro DMARK
4cde						CALLMONITOR 
4cde cd ab 18			call break_point_state  
4ce1				endm  
# End of macro CALLMONITOR
4ce1					endif 
4ce1			;		call storage_get_block_0 
4ce1			 
4ce1					; TODO pop hl 
4ce1			 
4ce1					;v5 FORTH_DSP_VALUE 
4ce1					FORTH_DSP_VALUE 
4ce1 cd ff 20			call macro_forth_dsp_value 
4ce4				endm 
# End of macro FORTH_DSP_VALUE
4ce4			 
4ce4				if DEBUG_STORESE 
4ce4					DMARK "CR1" 
4ce4 f5				push af  
4ce5 3a f9 4c			ld a, (.dmark)  
4ce8 32 6e fe			ld (debug_mark),a  
4ceb 3a fa 4c			ld a, (.dmark+1)  
4cee 32 6f fe			ld (debug_mark+1),a  
4cf1 3a fb 4c			ld a, (.dmark+2)  
4cf4 32 70 fe			ld (debug_mark+2),a  
4cf7 18 03			jr .pastdmark  
4cf9 ..			.dmark: db "CR1"  
4cfc f1			.pastdmark: pop af  
4cfd			endm  
# End of macro DMARK
4cfd					CALLMONITOR 
4cfd cd ab 18			call break_point_state  
4d00				endm  
# End of macro CALLMONITOR
4d00				endif 
4d00			;		push hl 
4d00			;		FORTH_DSP_POP 
4d00			;		pop hl 
4d00			 
4d00			;		inc hl   ; move past the type marker 
4d00			 
4d00 cd d7 07				call storage_create 
4d03			 
4d03				if DEBUG_STORESE 
4d03					DMARK "CT1" 
4d03 f5				push af  
4d04 3a 18 4d			ld a, (.dmark)  
4d07 32 6e fe			ld (debug_mark),a  
4d0a 3a 19 4d			ld a, (.dmark+1)  
4d0d 32 6f fe			ld (debug_mark+1),a  
4d10 3a 1a 4d			ld a, (.dmark+2)  
4d13 32 70 fe			ld (debug_mark+2),a  
4d16 18 03			jr .pastdmark  
4d18 ..			.dmark: db "CT1"  
4d1b f1			.pastdmark: pop af  
4d1c			endm  
# End of macro DMARK
4d1c					CALLMONITOR 
4d1c cd ab 18			call break_point_state  
4d1f				endm  
# End of macro CALLMONITOR
4d1f				endif 
4d1f			;		push hl 
4d1f					FORTH_DSP_POP 
4d1f cd ce 21			call macro_forth_dsp_pop 
4d22				endm 
# End of macro FORTH_DSP_POP
4d22			;		pop hl 
4d22					; push file id to stack 
4d22 cd 1f 1f				call forth_push_numhl 
4d25			 
4d25			 
4d25			 
4d25				       NEXTW 
4d25 c3 8d 22			jp macro_next 
4d28				endm 
# End of macro NEXTW
4d28			 
4d28			.APPEND: 
4d28				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
4d28 69				db WORD_SYS_CORE+85             
4d29 b9 4d			dw .SDEL            
4d2b 07				db 6 + 1 
4d2c .. 00			db "APPEND",0              
4d33				endm 
# End of macro CWHEAD
4d33			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
4d33			; | | e.g. 
4d33			; | | Test CREATE      -> $01 
4d33			; | | "A string to add to file" $01 APPEND 
4d33			; | |  
4d33			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
4d33					if DEBUG_FORTH_WORDS_KEY 
4d33						DMARK "APP" 
4d33 f5				push af  
4d34 3a 48 4d			ld a, (.dmark)  
4d37 32 6e fe			ld (debug_mark),a  
4d3a 3a 49 4d			ld a, (.dmark+1)  
4d3d 32 6f fe			ld (debug_mark+1),a  
4d40 3a 4a 4d			ld a, (.dmark+2)  
4d43 32 70 fe			ld (debug_mark+2),a  
4d46 18 03			jr .pastdmark  
4d48 ..			.dmark: db "APP"  
4d4b f1			.pastdmark: pop af  
4d4c			endm  
# End of macro DMARK
4d4c						CALLMONITOR 
4d4c cd ab 18			call break_point_state  
4d4f				endm  
# End of macro CALLMONITOR
4d4f					endif 
4d4f			 
4d4f					FORTH_DSP_VALUEHL 
4d4f cd 16 21			call macro_dsp_valuehl 
4d52				endm 
# End of macro FORTH_DSP_VALUEHL
4d52 e5					push hl 	; save file id 
4d53			 
4d53				if DEBUG_STORESE 
4d53					DMARK "AP1" 
4d53 f5				push af  
4d54 3a 68 4d			ld a, (.dmark)  
4d57 32 6e fe			ld (debug_mark),a  
4d5a 3a 69 4d			ld a, (.dmark+1)  
4d5d 32 6f fe			ld (debug_mark+1),a  
4d60 3a 6a 4d			ld a, (.dmark+2)  
4d63 32 70 fe			ld (debug_mark+2),a  
4d66 18 03			jr .pastdmark  
4d68 ..			.dmark: db "AP1"  
4d6b f1			.pastdmark: pop af  
4d6c			endm  
# End of macro DMARK
4d6c					CALLMONITOR 
4d6c cd ab 18			call break_point_state  
4d6f				endm  
# End of macro CALLMONITOR
4d6f				endif 
4d6f					FORTH_DSP_POP 
4d6f cd ce 21			call macro_forth_dsp_pop 
4d72				endm 
# End of macro FORTH_DSP_POP
4d72			 
4d72					FORTH_DSP_VALUEHL 
4d72 cd 16 21			call macro_dsp_valuehl 
4d75				endm 
# End of macro FORTH_DSP_VALUEHL
4d75					;v5 FORTH_DSP_VALUE 
4d75 e5					push hl 	; save ptr to string to save 
4d76			 
4d76				if DEBUG_STORESE 
4d76					DMARK "AP1" 
4d76 f5				push af  
4d77 3a 8b 4d			ld a, (.dmark)  
4d7a 32 6e fe			ld (debug_mark),a  
4d7d 3a 8c 4d			ld a, (.dmark+1)  
4d80 32 6f fe			ld (debug_mark+1),a  
4d83 3a 8d 4d			ld a, (.dmark+2)  
4d86 32 70 fe			ld (debug_mark+2),a  
4d89 18 03			jr .pastdmark  
4d8b ..			.dmark: db "AP1"  
4d8e f1			.pastdmark: pop af  
4d8f			endm  
# End of macro DMARK
4d8f					CALLMONITOR 
4d8f cd ab 18			call break_point_state  
4d92				endm  
# End of macro CALLMONITOR
4d92				endif 
4d92					FORTH_DSP_POP 
4d92 cd ce 21			call macro_forth_dsp_pop 
4d95				endm 
# End of macro FORTH_DSP_POP
4d95			 
4d95 d1					pop de 
4d96 e1					pop hl 
4d97				if DEBUG_STORESE 
4d97					DMARK "AP2" 
4d97 f5				push af  
4d98 3a ac 4d			ld a, (.dmark)  
4d9b 32 6e fe			ld (debug_mark),a  
4d9e 3a ad 4d			ld a, (.dmark+1)  
4da1 32 6f fe			ld (debug_mark+1),a  
4da4 3a ae 4d			ld a, (.dmark+2)  
4da7 32 70 fe			ld (debug_mark+2),a  
4daa 18 03			jr .pastdmark  
4dac ..			.dmark: db "AP2"  
4daf f1			.pastdmark: pop af  
4db0			endm  
# End of macro DMARK
4db0					CALLMONITOR 
4db0 cd ab 18			call break_point_state  
4db3				endm  
# End of macro CALLMONITOR
4db3				endif 
4db3					;inc de ; skip var type indicator 
4db3			 
4db3					; TODO how to append numerics???? 
4db3			 
4db3 cd c4 0a				call storage_append		 
4db6			 
4db6				       NEXTW 
4db6 c3 8d 22			jp macro_next 
4db9				endm 
# End of macro NEXTW
4db9			.SDEL: 
4db9				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
4db9 6a				db WORD_SYS_CORE+86             
4dba 05 4e			dw .OPEN            
4dbc 05				db 4 + 1 
4dbd .. 00			db "ERA",0              
4dc1				endm 
# End of macro CWHEAD
4dc1			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
4dc1					FORTH_DSP_VALUEHL 
4dc1 cd 16 21			call macro_dsp_valuehl 
4dc4				endm 
# End of macro FORTH_DSP_VALUEHL
4dc4			;		push hl 	; save file id 
4dc4			 
4dc4					if DEBUG_FORTH_WORDS_KEY 
4dc4						DMARK "ERA" 
4dc4 f5				push af  
4dc5 3a d9 4d			ld a, (.dmark)  
4dc8 32 6e fe			ld (debug_mark),a  
4dcb 3a da 4d			ld a, (.dmark+1)  
4dce 32 6f fe			ld (debug_mark+1),a  
4dd1 3a db 4d			ld a, (.dmark+2)  
4dd4 32 70 fe			ld (debug_mark+2),a  
4dd7 18 03			jr .pastdmark  
4dd9 ..			.dmark: db "ERA"  
4ddc f1			.pastdmark: pop af  
4ddd			endm  
# End of macro DMARK
4ddd						CALLMONITOR 
4ddd cd ab 18			call break_point_state  
4de0				endm  
# End of macro CALLMONITOR
4de0					endif 
4de0				if DEBUG_STORESE 
4de0					DMARK "ER1" 
4de0 f5				push af  
4de1 3a f5 4d			ld a, (.dmark)  
4de4 32 6e fe			ld (debug_mark),a  
4de7 3a f6 4d			ld a, (.dmark+1)  
4dea 32 6f fe			ld (debug_mark+1),a  
4ded 3a f7 4d			ld a, (.dmark+2)  
4df0 32 70 fe			ld (debug_mark+2),a  
4df3 18 03			jr .pastdmark  
4df5 ..			.dmark: db "ER1"  
4df8 f1			.pastdmark: pop af  
4df9			endm  
# End of macro DMARK
4df9					CALLMONITOR 
4df9 cd ab 18			call break_point_state  
4dfc				endm  
# End of macro CALLMONITOR
4dfc				endif 
4dfc					FORTH_DSP_POP 
4dfc cd ce 21			call macro_forth_dsp_pop 
4dff				endm 
# End of macro FORTH_DSP_POP
4dff			 
4dff			;		pop hl 
4dff			 
4dff cd 16 06				call storage_erase 
4e02				       NEXTW 
4e02 c3 8d 22			jp macro_next 
4e05				endm 
# End of macro NEXTW
4e05			 
4e05			.OPEN: 
4e05				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
4e05 6b				db WORD_SYS_CORE+87             
4e06 99 4e			dw .READ            
4e08 05				db 4 + 1 
4e09 .. 00			db "OPEN",0              
4e0e				endm 
# End of macro CWHEAD
4e0e			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
4e0e			; | | e.g. 
4e0e			; | | $01 OPEN $01 DO $01 READ . LOOP 
4e0e			; | | 
4e0e			; | | Will return with 255 blocks if the file does not exist 
4e0e			 
4e0e					if DEBUG_FORTH_WORDS_KEY 
4e0e						DMARK "OPN" 
4e0e f5				push af  
4e0f 3a 23 4e			ld a, (.dmark)  
4e12 32 6e fe			ld (debug_mark),a  
4e15 3a 24 4e			ld a, (.dmark+1)  
4e18 32 6f fe			ld (debug_mark+1),a  
4e1b 3a 25 4e			ld a, (.dmark+2)  
4e1e 32 70 fe			ld (debug_mark+2),a  
4e21 18 03			jr .pastdmark  
4e23 ..			.dmark: db "OPN"  
4e26 f1			.pastdmark: pop af  
4e27			endm  
# End of macro DMARK
4e27						CALLMONITOR 
4e27 cd ab 18			call break_point_state  
4e2a				endm  
# End of macro CALLMONITOR
4e2a					endif 
4e2a					; TODO handle multiple file opens 
4e2a			 
4e2a 3e 01			       	ld a, 1 
4e2c 32 71 fa				ld (store_openext), a 
4e2f			 
4e2f					; get max extents for this file 
4e2f				 
4e2f								 
4e2f					FORTH_DSP_VALUEHL 
4e2f cd 16 21			call macro_dsp_valuehl 
4e32				endm 
# End of macro FORTH_DSP_VALUEHL
4e32			 
4e32 65					ld h, l 
4e33 2e 00				ld l, 0 
4e35			 
4e35					; store file id 
4e35			 
4e35 7c					ld a, h 
4e36 32 6e fa				ld (store_filecache), a 
4e39			 
4e39				if DEBUG_STORESE 
4e39					DMARK "OPN" 
4e39 f5				push af  
4e3a 3a 4e 4e			ld a, (.dmark)  
4e3d 32 6e fe			ld (debug_mark),a  
4e40 3a 4f 4e			ld a, (.dmark+1)  
4e43 32 6f fe			ld (debug_mark+1),a  
4e46 3a 50 4e			ld a, (.dmark+2)  
4e49 32 70 fe			ld (debug_mark+2),a  
4e4c 18 03			jr .pastdmark  
4e4e ..			.dmark: db "OPN"  
4e51 f1			.pastdmark: pop af  
4e52			endm  
# End of macro DMARK
4e52					CALLMONITOR 
4e52 cd ab 18			call break_point_state  
4e55				endm  
# End of macro CALLMONITOR
4e55				endif 
4e55			;		push hl 
4e55					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
4e55 cd ce 21			call macro_forth_dsp_pop 
4e58				endm 
# End of macro FORTH_DSP_POP
4e58			;		pop hl 
4e58						 
4e58 11 81 fa				ld de, store_page      ; get block zero of file 
4e5b cd 2d 09				call storage_read 
4e5e cd 2d 0f			call ishlzero 
4e61 20 04			jr nz, .opfound 
4e63			 
4e63				; file does not exist so indicate with 255 extents in use 
4e63			 
4e63 3e ff			ld a, 255 
4e65 18 29			jr .skipopeneof 
4e67			 
4e67			 
4e67			.opfound: 
4e67			 
4e67			 
4e67 3a 83 fa				ld a, (store_page+2)    ; max extents for this file 
4e6a 32 70 fa				ld  (store_openmaxext), a   ; get our limit and push 
4e6d					 
4e6d				if DEBUG_STORESE 
4e6d					DMARK "OPx" 
4e6d f5				push af  
4e6e 3a 82 4e			ld a, (.dmark)  
4e71 32 6e fe			ld (debug_mark),a  
4e74 3a 83 4e			ld a, (.dmark+1)  
4e77 32 6f fe			ld (debug_mark+1),a  
4e7a 3a 84 4e			ld a, (.dmark+2)  
4e7d 32 70 fe			ld (debug_mark+2),a  
4e80 18 03			jr .pastdmark  
4e82 ..			.dmark: db "OPx"  
4e85 f1			.pastdmark: pop af  
4e86			endm  
# End of macro DMARK
4e86					CALLMONITOR 
4e86 cd ab 18			call break_point_state  
4e89				endm  
# End of macro CALLMONITOR
4e89				endif 
4e89 fe 00				cp 0 
4e8b 20 03				jr nz, .skipopeneof 
4e8d					; have opened an empty file 
4e8d					 
4e8d 32 71 fa				ld (store_openext), a 
4e90			 
4e90			.skipopeneof: 
4e90			 
4e90 6f					ld l, a 
4e91 26 00				ld h, 0 
4e93 cd 1f 1f				call forth_push_numhl 
4e96			 
4e96			 
4e96				       NEXTW 
4e96 c3 8d 22			jp macro_next 
4e99				endm 
# End of macro NEXTW
4e99			.READ: 
4e99				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
4e99 6c				db WORD_SYS_CORE+88             
4e9a c3 4f			dw .EOF            
4e9c 05				db 4 + 1 
4e9d .. 00			db "READ",0              
4ea2				endm 
# End of macro CWHEAD
4ea2			; | READ ( -- n  )  Reads next page of current file id and push to stack | DONE 
4ea2			; | | e.g. 
4ea2			; | | $01 OPEN $01 DO READ . LOOP 
4ea2			; | | 
4ea2			; | | As this word only reads one 64 byte block in at a time, if the APPEND word has created extra blocks for the excess, this READ 
4ea2			; | | word is unaware so the long string needs to be joined if the string is a full. A single block read might be what you want, 
4ea2			; | | but if not then writing a word to join blocks will be required. The upshot is a full string will be 62 bytes as the first 
4ea2			; | | two bytes contain the file id and extent. 
4ea2			; | |  
4ea2			; | | Note: There is a flag that enables/disables long block reads called 'store_longread' and a poke of a non-zero value will 
4ea2			; | | enable the code to automatically read futher blocks if full. It is BUGGY so don't use for now. 
4ea2			 
4ea2					if DEBUG_FORTH_WORDS_KEY 
4ea2						DMARK "REA" 
4ea2 f5				push af  
4ea3 3a b7 4e			ld a, (.dmark)  
4ea6 32 6e fe			ld (debug_mark),a  
4ea9 3a b8 4e			ld a, (.dmark+1)  
4eac 32 6f fe			ld (debug_mark+1),a  
4eaf 3a b9 4e			ld a, (.dmark+2)  
4eb2 32 70 fe			ld (debug_mark+2),a  
4eb5 18 03			jr .pastdmark  
4eb7 ..			.dmark: db "REA"  
4eba f1			.pastdmark: pop af  
4ebb			endm  
# End of macro DMARK
4ebb						CALLMONITOR 
4ebb cd ab 18			call break_point_state  
4ebe				endm  
# End of macro CALLMONITOR
4ebe					endif 
4ebe					; store_openext use it. If zero it is EOF 
4ebe			 
4ebe					; read block from current stream id 
4ebe					; if the block does not contain zero term keep reading blocks until zero found 
4ebe					; push the block to stack 
4ebe					; save the block id to stream 
4ebe			 
4ebe			 
4ebe cd f0 4f				call .testeof 
4ec1 3e 01				ld a, 1 
4ec3 bd					cp l 
4ec4 ca 9f 4f				jp z, .ateof 
4ec7			 
4ec7			 
4ec7			;		FORTH_DSP_VALUEHL 
4ec7			 
4ec7			;		push hl 
4ec7			 
4ec7			;	if DEBUG_STORESE 
4ec7			;		DMARK "REA" 
4ec7			;		CALLMONITOR 
4ec7			;	endif 
4ec7			;		FORTH_DSP_POP 
4ec7			 
4ec7			;		pop hl 
4ec7				 
4ec7 3a 6e fa				ld a, (store_filecache) 
4eca 67					ld h,a 
4ecb			 
4ecb 3a 71 fa				ld a, (store_openext) 
4ece 6f					ld l, a 
4ecf					 
4ecf fe 00				cp 0 
4ed1 ca 9f 4f				jp z, .ateof     ; dont read past eof 
4ed4			 
4ed4 cd 10 0c				call storage_clear_page 
4ed7			 
4ed7 11 81 fa				ld de, store_page 
4eda				if DEBUG_STORESE 
4eda					DMARK "RE1" 
4eda f5				push af  
4edb 3a ef 4e			ld a, (.dmark)  
4ede 32 6e fe			ld (debug_mark),a  
4ee1 3a f0 4e			ld a, (.dmark+1)  
4ee4 32 6f fe			ld (debug_mark+1),a  
4ee7 3a f1 4e			ld a, (.dmark+2)  
4eea 32 70 fe			ld (debug_mark+2),a  
4eed 18 03			jr .pastdmark  
4eef ..			.dmark: db "RE1"  
4ef2 f1			.pastdmark: pop af  
4ef3			endm  
# End of macro DMARK
4ef3					CALLMONITOR 
4ef3 cd ab 18			call break_point_state  
4ef6				endm  
# End of macro CALLMONITOR
4ef6				endif 
4ef6 cd 2d 09				call storage_read 
4ef9			 
4ef9				if DEBUG_STORESE 
4ef9					DMARK "RE2" 
4ef9 f5				push af  
4efa 3a 0e 4f			ld a, (.dmark)  
4efd 32 6e fe			ld (debug_mark),a  
4f00 3a 0f 4f			ld a, (.dmark+1)  
4f03 32 6f fe			ld (debug_mark+1),a  
4f06 3a 10 4f			ld a, (.dmark+2)  
4f09 32 70 fe			ld (debug_mark+2),a  
4f0c 18 03			jr .pastdmark  
4f0e ..			.dmark: db "RE2"  
4f11 f1			.pastdmark: pop af  
4f12			endm  
# End of macro DMARK
4f12					CALLMONITOR 
4f12 cd ab 18			call break_point_state  
4f15				endm  
# End of macro CALLMONITOR
4f15				endif 
4f15 cd 2d 0f			call ishlzero 
4f18			;	ld a, l 
4f18			;	add h 
4f18			;	cp 0 
4f18 ca 9f 4f			jp z, .readeof 
4f1b			 
4f1b				; not eof so hl should point to data to push to stack 
4f1b			 
4f1b				if DEBUG_STORESE 
4f1b					DMARK "RE3" 
4f1b f5				push af  
4f1c 3a 30 4f			ld a, (.dmark)  
4f1f 32 6e fe			ld (debug_mark),a  
4f22 3a 31 4f			ld a, (.dmark+1)  
4f25 32 6f fe			ld (debug_mark+1),a  
4f28 3a 32 4f			ld a, (.dmark+2)  
4f2b 32 70 fe			ld (debug_mark+2),a  
4f2e 18 03			jr .pastdmark  
4f30 ..			.dmark: db "RE3"  
4f33 f1			.pastdmark: pop af  
4f34			endm  
# End of macro DMARK
4f34					CALLMONITOR 
4f34 cd ab 18			call break_point_state  
4f37				endm  
# End of macro CALLMONITOR
4f37				endif 
4f37 cd 8d 1f			call forth_push_str 
4f3a			 
4f3a				if DEBUG_STORESE 
4f3a					DMARK "RE4" 
4f3a f5				push af  
4f3b 3a 4f 4f			ld a, (.dmark)  
4f3e 32 6e fe			ld (debug_mark),a  
4f41 3a 50 4f			ld a, (.dmark+1)  
4f44 32 6f fe			ld (debug_mark+1),a  
4f47 3a 51 4f			ld a, (.dmark+2)  
4f4a 32 70 fe			ld (debug_mark+2),a  
4f4d 18 03			jr .pastdmark  
4f4f ..			.dmark: db "RE4"  
4f52 f1			.pastdmark: pop af  
4f53			endm  
# End of macro DMARK
4f53					CALLMONITOR 
4f53 cd ab 18			call break_point_state  
4f56				endm  
# End of macro CALLMONITOR
4f56				endif 
4f56				; get next block  or mark as eof 
4f56			 
4f56 3a 70 fa			ld a, (store_openmaxext)   ; get our limit 
4f59 4f				ld c, a	 
4f5a 3a 71 fa			ld a, (store_openext) 
4f5d			 
4f5d				if DEBUG_STORESE 
4f5d					DMARK "RE5" 
4f5d f5				push af  
4f5e 3a 72 4f			ld a, (.dmark)  
4f61 32 6e fe			ld (debug_mark),a  
4f64 3a 73 4f			ld a, (.dmark+1)  
4f67 32 6f fe			ld (debug_mark+1),a  
4f6a 3a 74 4f			ld a, (.dmark+2)  
4f6d 32 70 fe			ld (debug_mark+2),a  
4f70 18 03			jr .pastdmark  
4f72 ..			.dmark: db "RE5"  
4f75 f1			.pastdmark: pop af  
4f76			endm  
# End of macro DMARK
4f76					CALLMONITOR 
4f76 cd ab 18			call break_point_state  
4f79				endm  
# End of macro CALLMONITOR
4f79				endif 
4f79 b9				cp c 
4f7a 28 23			jr z, .readeof     ; at last extent 
4f7c			 
4f7c 3c					inc a 
4f7d 32 71 fa				ld (store_openext), a 
4f80			 
4f80				if DEBUG_STORESE 
4f80					DMARK "RE6" 
4f80 f5				push af  
4f81 3a 95 4f			ld a, (.dmark)  
4f84 32 6e fe			ld (debug_mark),a  
4f87 3a 96 4f			ld a, (.dmark+1)  
4f8a 32 6f fe			ld (debug_mark+1),a  
4f8d 3a 97 4f			ld a, (.dmark+2)  
4f90 32 70 fe			ld (debug_mark+2),a  
4f93 18 03			jr .pastdmark  
4f95 ..			.dmark: db "RE6"  
4f98 f1			.pastdmark: pop af  
4f99			endm  
# End of macro DMARK
4f99					CALLMONITOR 
4f99 cd ab 18			call break_point_state  
4f9c				endm  
# End of macro CALLMONITOR
4f9c				endif 
4f9c			 
4f9c			 
4f9c				       NEXTW 
4f9c c3 8d 22			jp macro_next 
4f9f				endm 
# End of macro NEXTW
4f9f			.ateof: 
4f9f				;	ld hl, .showeof 
4f9f				;	call forth_push_str 
4f9f 3e 00		.readeof:	ld a, 0 
4fa1 32 71 fa				ld (store_openext), a 
4fa4			 
4fa4					 
4fa4				if DEBUG_STORESE 
4fa4					DMARK "REF" 
4fa4 f5				push af  
4fa5 3a b9 4f			ld a, (.dmark)  
4fa8 32 6e fe			ld (debug_mark),a  
4fab 3a ba 4f			ld a, (.dmark+1)  
4fae 32 6f fe			ld (debug_mark+1),a  
4fb1 3a bb 4f			ld a, (.dmark+2)  
4fb4 32 70 fe			ld (debug_mark+2),a  
4fb7 18 03			jr .pastdmark  
4fb9 ..			.dmark: db "REF"  
4fbc f1			.pastdmark: pop af  
4fbd			endm  
# End of macro DMARK
4fbd					CALLMONITOR 
4fbd cd ab 18			call break_point_state  
4fc0				endm  
# End of macro CALLMONITOR
4fc0				endif 
4fc0				       NEXTW 
4fc0 c3 8d 22			jp macro_next 
4fc3				endm 
# End of macro NEXTW
4fc3			 
4fc3			;.showeof:   db "eof", 0 
4fc3			 
4fc3			 
4fc3			.EOF: 
4fc3				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
4fc3 6d				db WORD_SYS_CORE+89             
4fc4 05 50			dw .FORMAT            
4fc6 04				db 3 + 1 
4fc7 .. 00			db "EOF",0              
4fcb				endm 
# End of macro CWHEAD
4fcb			; | EOF ( -- u )  Returns EOF logical state of current open file id | DONE 
4fcb			; | | e.g. 
4fcb			; | | $01 OPEN REPEAT READ EOF $00 IF LOOP 
4fcb					; TODO if current block id for stream is zero then push true else false 
4fcb			 
4fcb					if DEBUG_FORTH_WORDS_KEY 
4fcb						DMARK "EOF" 
4fcb f5				push af  
4fcc 3a e0 4f			ld a, (.dmark)  
4fcf 32 6e fe			ld (debug_mark),a  
4fd2 3a e1 4f			ld a, (.dmark+1)  
4fd5 32 6f fe			ld (debug_mark+1),a  
4fd8 3a e2 4f			ld a, (.dmark+2)  
4fdb 32 70 fe			ld (debug_mark+2),a  
4fde 18 03			jr .pastdmark  
4fe0 ..			.dmark: db "EOF"  
4fe3 f1			.pastdmark: pop af  
4fe4			endm  
# End of macro DMARK
4fe4						CALLMONITOR 
4fe4 cd ab 18			call break_point_state  
4fe7				endm  
# End of macro CALLMONITOR
4fe7					endif 
4fe7			 
4fe7					; TODO handlue multiple file streams 
4fe7			 
4fe7			;		FORTH_iDSP_POP     ; for now just get rid of stream id 
4fe7 cd f0 4f				call .testeof 
4fea cd 1f 1f				call forth_push_numhl 
4fed			 
4fed			 
4fed				       NEXTW 
4fed c3 8d 22			jp macro_next 
4ff0				endm 
# End of macro NEXTW
4ff0			 
4ff0			.testeof: 
4ff0 2e 01				ld l, 1 
4ff2 3a 70 fa				ld a, (store_openmaxext) 
4ff5 fe 00				cp 0 
4ff7 28 09				jr  z, .eofdone   ; empty file 
4ff9 3a 71 fa				ld a, (store_openext) 
4ffc fe 00				cp 0 
4ffe 28 02				jr  z, .eofdone 
5000 2e 00				ld l, 0 
5002 26 00		.eofdone:	ld h, 0 
5004 c9					ret 
5005			 
5005			 
5005			 
5005			 
5005			.FORMAT: 
5005				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
5005 6d				db WORD_SYS_CORE+89             
5006 56 50			dw .LABEL            
5008 07				db 6 + 1 
5009 .. 00			db "FORMAT",0              
5010				endm 
# End of macro CWHEAD
5010			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
5010					; TODO if current block id for stream is zero then push true else false 
5010				 
5010				if DEBUG_STORESE 
5010					DMARK "FOR" 
5010 f5				push af  
5011 3a 25 50			ld a, (.dmark)  
5014 32 6e fe			ld (debug_mark),a  
5017 3a 26 50			ld a, (.dmark+1)  
501a 32 6f fe			ld (debug_mark+1),a  
501d 3a 27 50			ld a, (.dmark+2)  
5020 32 70 fe			ld (debug_mark+2),a  
5023 18 03			jr .pastdmark  
5025 ..			.dmark: db "FOR"  
5028 f1			.pastdmark: pop af  
5029			endm  
# End of macro DMARK
5029					CALLMONITOR 
5029 cd ab 18			call break_point_state  
502c				endm  
# End of macro CALLMONITOR
502c				endif 
502c					; Wipes the bank check flags to cause a reformat on next block 0 read 
502c			 
502c 21 01 00				ld hl, 1 
502f 3e 00				ld a, 0 
5031 cd d9 01				call se_writebyte 
5034			 
5034				if DEBUG_STORESE 
5034					DMARK "FO0" 
5034 f5				push af  
5035 3a 49 50			ld a, (.dmark)  
5038 32 6e fe			ld (debug_mark),a  
503b 3a 4a 50			ld a, (.dmark+1)  
503e 32 6f fe			ld (debug_mark+1),a  
5041 3a 4b 50			ld a, (.dmark+2)  
5044 32 70 fe			ld (debug_mark+2),a  
5047 18 03			jr .pastdmark  
5049 ..			.dmark: db "FO0"  
504c f1			.pastdmark: pop af  
504d			endm  
# End of macro DMARK
504d					CALLMONITOR 
504d cd ab 18			call break_point_state  
5050				endm  
# End of macro CALLMONITOR
5050				endif 
5050					; force bank init 
5050			 
5050 cd 85 04				call storage_get_block_0 
5053					 
5053				       NEXTW 
5053 c3 8d 22			jp macro_next 
5056				endm 
# End of macro NEXTW
5056			.LABEL: 
5056				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
5056 6d				db WORD_SYS_CORE+89             
5057 a4 50			dw .STOREPAGE            
5059 06				db 5 + 1 
505a .. 00			db "LABEL",0              
5060				endm 
# End of macro CWHEAD
5060			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
5060					; TODO test to see if bank is selected 
5060				 
5060					if DEBUG_FORTH_WORDS_KEY 
5060						DMARK "LBL" 
5060 f5				push af  
5061 3a 75 50			ld a, (.dmark)  
5064 32 6e fe			ld (debug_mark),a  
5067 3a 76 50			ld a, (.dmark+1)  
506a 32 6f fe			ld (debug_mark+1),a  
506d 3a 77 50			ld a, (.dmark+2)  
5070 32 70 fe			ld (debug_mark+2),a  
5073 18 03			jr .pastdmark  
5075 ..			.dmark: db "LBL"  
5078 f1			.pastdmark: pop af  
5079			endm  
# End of macro DMARK
5079						CALLMONITOR 
5079 cd ab 18			call break_point_state  
507c				endm  
# End of macro CALLMONITOR
507c					endif 
507c			;	if DEBUG_STORESE 
507c			;		DMARK "LBL" 
507c			;		CALLMONITOR 
507c			;	endif 
507c					FORTH_DSP_VALUEHL 
507c cd 16 21			call macro_dsp_valuehl 
507f				endm 
# End of macro FORTH_DSP_VALUEHL
507f					;v5FORTH_DSP_VALUE 
507f					 
507f			;		push hl 
507f					FORTH_DSP_POP 
507f cd ce 21			call macro_forth_dsp_pop 
5082				endm 
# End of macro FORTH_DSP_POP
5082			;		pop hl 
5082			 
5082			;v5		inc hl   ; move past the type marker 
5082			 
5082				if DEBUG_STORESE 
5082					DMARK "LBl" 
5082 f5				push af  
5083 3a 97 50			ld a, (.dmark)  
5086 32 6e fe			ld (debug_mark),a  
5089 3a 98 50			ld a, (.dmark+1)  
508c 32 6f fe			ld (debug_mark+1),a  
508f 3a 99 50			ld a, (.dmark+2)  
5092 32 70 fe			ld (debug_mark+2),a  
5095 18 03			jr .pastdmark  
5097 ..			.dmark: db "LBl"  
509a f1			.pastdmark: pop af  
509b			endm  
# End of macro DMARK
509b					CALLMONITOR 
509b cd ab 18			call break_point_state  
509e				endm  
# End of macro CALLMONITOR
509e				endif 
509e cd a9 05				call storage_label 
50a1			 
50a1				       NEXTW 
50a1 c3 8d 22			jp macro_next 
50a4				endm 
# End of macro NEXTW
50a4			.STOREPAGE: 
50a4				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
50a4 6d				db WORD_SYS_CORE+89             
50a5 d7 50			dw .LABELS            
50a7 0a				db 9 + 1 
50a8 .. 00			db "STOREPAGE",0              
50b2				endm 
# End of macro CWHEAD
50b2			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
50b2					; TODO test to see if bank is selected 
50b2				 
50b2					if DEBUG_FORTH_WORDS_KEY 
50b2						DMARK "STP" 
50b2 f5				push af  
50b3 3a c7 50			ld a, (.dmark)  
50b6 32 6e fe			ld (debug_mark),a  
50b9 3a c8 50			ld a, (.dmark+1)  
50bc 32 6f fe			ld (debug_mark+1),a  
50bf 3a c9 50			ld a, (.dmark+2)  
50c2 32 70 fe			ld (debug_mark+2),a  
50c5 18 03			jr .pastdmark  
50c7 ..			.dmark: db "STP"  
50ca f1			.pastdmark: pop af  
50cb			endm  
# End of macro DMARK
50cb						CALLMONITOR 
50cb cd ab 18			call break_point_state  
50ce				endm  
# End of macro CALLMONITOR
50ce					endif 
50ce			;	if DEBUG_STORESE 
50ce			;		DMARK "STP" 
50ce			;		CALLMONITOR 
50ce			;	endif 
50ce			 
50ce 21 81 fa			ld hl, store_page 
50d1 cd 1f 1f			call forth_push_numhl 
50d4			 
50d4			 
50d4				       NEXTW 
50d4 c3 8d 22			jp macro_next 
50d7				endm 
# End of macro NEXTW
50d7			.LABELS: 
50d7				CWHEAD .SCONST1 89 "LABELS" 6 WORD_FLAG_CODE 
50d7 6d				db WORD_SYS_CORE+89             
50d8 61 51			dw .SCONST1            
50da 07				db 6 + 1 
50db .. 00			db "LABELS",0              
50e2				endm 
# End of macro CWHEAD
50e2			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | TO TEST 
50e2					;  
50e2			 
50e2					; save the current device selected to restore afterwards 
50e2				 
50e2 3a 68 fa				ld a, (spi_device) 
50e5 f5					push af 
50e6			 
50e6			 
50e6					; run through each of the banks 
50e6			 
50e6 21 01 00				ld hl, 1 
50e9 cd 1f 1f				call forth_push_numhl 
50ec 3e ff				ld a, SPI_CE_HIGH 
50ee cb 87				res SPI_CE0, a 
50f0 32 68 fa				ld (spi_device), a 
50f3 cd 85 04				call storage_get_block_0 
50f6 21 84 fa				ld hl, store_page+3 
50f9 cd 8d 1f				call forth_push_str 
50fc			 
50fc					 
50fc 21 02 00				ld hl, 2 
50ff cd 1f 1f				call forth_push_numhl 
5102 3e ff				ld a, SPI_CE_HIGH 
5104 cb 8f				res SPI_CE1, a 
5106 32 68 fa				ld (spi_device), a 
5109 cd 85 04				call storage_get_block_0 
510c 21 84 fa				ld hl, store_page+3 
510f cd 8d 1f				call forth_push_str 
5112			 
5112					 
5112 21 03 00				ld hl, 3 
5115 cd 1f 1f				call forth_push_numhl 
5118 3e ff				ld a, SPI_CE_HIGH 
511a cb 97				res SPI_CE2, a 
511c 32 68 fa				ld (spi_device), a 
511f cd 85 04				call storage_get_block_0 
5122 21 84 fa				ld hl, store_page+3 
5125 cd 8d 1f				call forth_push_str 
5128			 
5128			 
5128 21 04 00				ld hl, 4 
512b cd 1f 1f				call forth_push_numhl 
512e 3e ff				ld a, SPI_CE_HIGH 
5130 cb 9f				res SPI_CE3, a 
5132 32 68 fa				ld (spi_device), a 
5135 cd 85 04				call storage_get_block_0 
5138 21 84 fa				ld hl, store_page+3 
513b cd 8d 1f				call forth_push_str 
513e			 
513e					 
513e			 
513e 21 05 00				ld hl, 5 
5141 cd 1f 1f				call forth_push_numhl 
5144 3e ff				ld a, SPI_CE_HIGH 
5146 cb a7				res SPI_CE4, a 
5148 32 68 fa				ld (spi_device), a 
514b cd 85 04				call storage_get_block_0 
514e 21 84 fa				ld hl, store_page+3 
5151 cd 8d 1f				call forth_push_str 
5154			 
5154					 
5154					; push fixed count of storage devices (on board) for now 
5154			 
5154 21 05 00				ld hl, 5 
5157 cd 1f 1f				call forth_push_numhl 
515a			 
515a					; restore selected device  
515a				 
515a f1					pop af 
515b 32 68 fa				ld (spi_device), a 
515e			 
515e				       NEXTW 
515e c3 8d 22			jp macro_next 
5161				endm 
# End of macro NEXTW
5161			 
5161			.SCONST1: 
5161				CWHEAD .SCONST2 89 "FILEID" 6 WORD_FLAG_CODE 
5161 6d				db WORD_SYS_CORE+89             
5162 78 51			dw .SCONST2            
5164 07				db 6 + 1 
5165 .. 00			db "FILEID",0              
516c				endm 
# End of macro CWHEAD
516c			; | FILEID (  -- u1  )  Pushes currently open file ID to stack | DONE 
516c 3a 6e fa				ld a, (store_filecache) 
516f 26 00				ld h, 0 
5171 6f					ld l, a 
5172 cd 1f 1f				call forth_push_numhl 
5175					NEXTW 
5175 c3 8d 22			jp macro_next 
5178				endm 
# End of macro NEXTW
5178			.SCONST2: 
5178				CWHEAD .SCONST3 89 "FILEEXT" 7 WORD_FLAG_CODE 
5178 6d				db WORD_SYS_CORE+89             
5179 90 51			dw .SCONST3            
517b 08				db 7 + 1 
517c .. 00			db "FILEEXT",0              
5184				endm 
# End of macro CWHEAD
5184			; | FILEEXT (  -- u1  )  Pushes the currently read file extent of the file to stack | DONE 
5184 3a 71 fa				ld a, (store_openext) 
5187 26 00				ld h, 0 
5189 6f					ld l, a 
518a cd 1f 1f				call forth_push_numhl 
518d					NEXTW 
518d c3 8d 22			jp macro_next 
5190				endm 
# End of macro NEXTW
5190			.SCONST3: 
5190				CWHEAD .SCONST4 89 "FILEMAX" 7 WORD_FLAG_CODE 
5190 6d				db WORD_SYS_CORE+89             
5191 a8 51			dw .SCONST4            
5193 08				db 7 + 1 
5194 .. 00			db "FILEMAX",0              
519c				endm 
# End of macro CWHEAD
519c			; | FILEMAXEXT (  -- u1  )  Pushes the maximum file extent of the currenlty open file to stack | DONE 
519c 3a 70 fa				ld a, (store_openmaxext) 
519f 26 00				ld h, 0 
51a1 6f					ld l, a 
51a2 cd 1f 1f				call forth_push_numhl 
51a5					NEXTW 
51a5 c3 8d 22			jp macro_next 
51a8				endm 
# End of macro NEXTW
51a8			.SCONST4: 
51a8				CWHEAD .SCONST5 89 "FILEADDR" 8 WORD_FLAG_CODE 
51a8 6d				db WORD_SYS_CORE+89             
51a9 be 51			dw .SCONST5            
51ab 09				db 8 + 1 
51ac .. 00			db "FILEADDR",0              
51b5				endm 
# End of macro CWHEAD
51b5			; | FILEADDR (  -- u1  )  Pushes the address of the block accessed for the currenlty open file to stack | DONE 
51b5 2a 72 fa				ld hl, (store_openaddr) 
51b8 cd 1f 1f				call forth_push_numhl 
51bb					NEXTW 
51bb c3 8d 22			jp macro_next 
51be				endm 
# End of macro NEXTW
51be			.SCONST5: 
51be				CWHEAD .ENDSTORAGE 89 "READCONT" 8 WORD_FLAG_CODE 
51be 6d				db WORD_SYS_CORE+89             
51bf d7 51			dw .ENDSTORAGE            
51c1 09				db 8 + 1 
51c2 .. 00			db "READCONT",0              
51cb				endm 
# End of macro CWHEAD
51cb			; | READCONT (  -- u1  )  Pushes the READ continuation flag to stack | DONE 
51cb			; | | If the most recent READ results in a full buffer load then this flag is set and will indicate that 
51cb			; | | a further read should, if applicable, be CONCAT to the previous read. 
51cb 3a 74 fa				ld a, (store_readcont) 
51ce 26 00				ld h, 0 
51d0 6f					ld l, a 
51d1 cd 1f 1f				call forth_push_numhl 
51d4					NEXTW 
51d4 c3 8d 22			jp macro_next 
51d7				endm 
# End of macro NEXTW
51d7			.ENDSTORAGE: 
51d7			; eof 
# End of file forth_words_storage.asm
51d7			endif 
51d7				include "forth_words_device.asm" 
51d7			; Device related words 
51d7			 
51d7			; | ## Device Words 
51d7			 
51d7			if SOUND_ENABLE 
51d7			.NOTE: 
51d7				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
51d7 33				db WORD_SYS_CORE+31             
51d8 ff 51			dw .AFTERSOUND            
51da 05				db 4 + 1 
51db .. 00			db "NOTE",0              
51e0				endm 
# End of macro CWHEAD
51e0			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
51e0					if DEBUG_FORTH_WORDS_KEY 
51e0						DMARK "NTE" 
51e0 f5				push af  
51e1 3a f5 51			ld a, (.dmark)  
51e4 32 6e fe			ld (debug_mark),a  
51e7 3a f6 51			ld a, (.dmark+1)  
51ea 32 6f fe			ld (debug_mark+1),a  
51ed 3a f7 51			ld a, (.dmark+2)  
51f0 32 70 fe			ld (debug_mark+2),a  
51f3 18 03			jr .pastdmark  
51f5 ..			.dmark: db "NTE"  
51f8 f1			.pastdmark: pop af  
51f9			endm  
# End of macro DMARK
51f9						CALLMONITOR 
51f9 cd ab 18			call break_point_state  
51fc				endm  
# End of macro CALLMONITOR
51fc					endif 
51fc			 
51fc				 
51fc			 
51fc					NEXTW 
51fc c3 8d 22			jp macro_next 
51ff				endm 
# End of macro NEXTW
51ff			.AFTERSOUND: 
51ff			endif 
51ff			 
51ff			 
51ff			USE_GPIO: equ 0 
51ff			 
51ff			if USE_GPIO 
51ff			.GP1: 
51ff				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
51ff			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
51ff					NEXTW 
51ff			.GP2: 
51ff				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
51ff			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
51ff			 
51ff					NEXTW 
51ff			 
51ff			.GP3: 
51ff				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
51ff			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
51ff			 
51ff					NEXTW 
51ff			 
51ff			.GP4: 
51ff				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
51ff			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
51ff			 
51ff					NEXTW 
51ff			.SIN: 
51ff			 
51ff			 
51ff			endif 
51ff			 
51ff			 
51ff				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
51ff 33				db WORD_SYS_CORE+31             
5200 34 52			dw .SOUT            
5202 03				db 2 + 1 
5203 .. 00			db "IN",0              
5206				endm 
# End of macro CWHEAD
5206			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
5206					if DEBUG_FORTH_WORDS_KEY 
5206						DMARK "IN." 
5206 f5				push af  
5207 3a 1b 52			ld a, (.dmark)  
520a 32 6e fe			ld (debug_mark),a  
520d 3a 1c 52			ld a, (.dmark+1)  
5210 32 6f fe			ld (debug_mark+1),a  
5213 3a 1d 52			ld a, (.dmark+2)  
5216 32 70 fe			ld (debug_mark+2),a  
5219 18 03			jr .pastdmark  
521b ..			.dmark: db "IN."  
521e f1			.pastdmark: pop af  
521f			endm  
# End of macro DMARK
521f						CALLMONITOR 
521f cd ab 18			call break_point_state  
5222				endm  
# End of macro CALLMONITOR
5222					endif 
5222					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5222 cd 16 21			call macro_dsp_valuehl 
5225				endm 
# End of macro FORTH_DSP_VALUEHL
5225			 
5225 e5					push hl 
5226			 
5226					; destroy value TOS 
5226			 
5226					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5226 cd ce 21			call macro_forth_dsp_pop 
5229				endm 
# End of macro FORTH_DSP_POP
5229			 
5229					; one value on hl get other one back 
5229			 
5229 c1					pop bc 
522a			 
522a					; do the sub 
522a			;		ex de, hl 
522a			 
522a ed 68				in l,(c) 
522c			 
522c					; save it 
522c			 
522c 26 00				ld h,0 
522e			 
522e					; TODO push value back onto stack for another op etc 
522e			 
522e cd 1f 1f				call forth_push_numhl 
5231					NEXTW 
5231 c3 8d 22			jp macro_next 
5234				endm 
# End of macro NEXTW
5234			.SOUT: 
5234				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
5234 34				db WORD_SYS_CORE+32             
5235 87 52			dw .SPIO            
5237 04				db 3 + 1 
5238 .. 00			db "OUT",0              
523c				endm 
# End of macro CWHEAD
523c			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
523c					if DEBUG_FORTH_WORDS_KEY 
523c						DMARK "OUT" 
523c f5				push af  
523d 3a 51 52			ld a, (.dmark)  
5240 32 6e fe			ld (debug_mark),a  
5243 3a 52 52			ld a, (.dmark+1)  
5246 32 6f fe			ld (debug_mark+1),a  
5249 3a 53 52			ld a, (.dmark+2)  
524c 32 70 fe			ld (debug_mark+2),a  
524f 18 03			jr .pastdmark  
5251 ..			.dmark: db "OUT"  
5254 f1			.pastdmark: pop af  
5255			endm  
# End of macro DMARK
5255						CALLMONITOR 
5255 cd ab 18			call break_point_state  
5258				endm  
# End of macro CALLMONITOR
5258					endif 
5258			 
5258					; get port 
5258			 
5258					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5258 cd 16 21			call macro_dsp_valuehl 
525b				endm 
# End of macro FORTH_DSP_VALUEHL
525b			 
525b e5					push hl 
525c			 
525c					; destroy value TOS 
525c			 
525c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
525c cd ce 21			call macro_forth_dsp_pop 
525f				endm 
# End of macro FORTH_DSP_POP
525f			 
525f					; get byte to send 
525f			 
525f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
525f cd 16 21			call macro_dsp_valuehl 
5262				endm 
# End of macro FORTH_DSP_VALUEHL
5262			 
5262			;		push hl 
5262			 
5262					; destroy value TOS 
5262			 
5262					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5262 cd ce 21			call macro_forth_dsp_pop 
5265				endm 
# End of macro FORTH_DSP_POP
5265			 
5265					; one value on hl get other one back 
5265			 
5265			;		pop hl 
5265			 
5265 c1					pop bc 
5266			 
5266					if DEBUG_FORTH_WORDS 
5266						DMARK "OUT" 
5266 f5				push af  
5267 3a 7b 52			ld a, (.dmark)  
526a 32 6e fe			ld (debug_mark),a  
526d 3a 7c 52			ld a, (.dmark+1)  
5270 32 6f fe			ld (debug_mark+1),a  
5273 3a 7d 52			ld a, (.dmark+2)  
5276 32 70 fe			ld (debug_mark+2),a  
5279 18 03			jr .pastdmark  
527b ..			.dmark: db "OUT"  
527e f1			.pastdmark: pop af  
527f			endm  
# End of macro DMARK
527f						CALLMONITOR 
527f cd ab 18			call break_point_state  
5282				endm  
# End of macro CALLMONITOR
5282					endif 
5282			 
5282 ed 69				out (c), l 
5284			 
5284					NEXTW 
5284 c3 8d 22			jp macro_next 
5287				endm 
# End of macro NEXTW
5287			 
5287			 
5287			.SPIO: 
5287			 
5287			if STORAGE_SE 
5287				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
5287 51				db WORD_SYS_CORE+61             
5288 98 52			dw .SPICEH            
528a 07				db 6 + 1 
528b .. 00			db "SPICEL",0              
5292				endm 
# End of macro CWHEAD
5292			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
5292			 
5292 cd 87 01				call spi_ce_low 
5295			    NEXTW 
5295 c3 8d 22			jp macro_next 
5298				endm 
# End of macro NEXTW
5298			 
5298			.SPICEH: 
5298				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
5298 51				db WORD_SYS_CORE+61             
5299 a9 52			dw .SPIOb            
529b 07				db 6 + 1 
529c .. 00			db "SPICEH",0              
52a3				endm 
# End of macro CWHEAD
52a3			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
52a3			 
52a3 cd 76 01				call spi_ce_high 
52a6			    NEXTW 
52a6 c3 8d 22			jp macro_next 
52a9				endm 
# End of macro NEXTW
52a9			 
52a9			 
52a9			.SPIOb: 
52a9			 
52a9				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
52a9 51				db WORD_SYS_CORE+61             
52aa bf 52			dw .SPII            
52ac 05				db 4 + 1 
52ad .. 00			db "SPIO",0              
52b2				endm 
# End of macro CWHEAD
52b2			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
52b2			 
52b2					; get port 
52b2			 
52b2			 
52b2					; get byte to send 
52b2			 
52b2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
52b2 cd 16 21			call macro_dsp_valuehl 
52b5				endm 
# End of macro FORTH_DSP_VALUEHL
52b5			 
52b5			;		push hl    ; u1  
52b5			 
52b5					; destroy value TOS 
52b5			 
52b5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
52b5 cd ce 21			call macro_forth_dsp_pop 
52b8				endm 
# End of macro FORTH_DSP_POP
52b8			 
52b8					; one value on hl get other one back 
52b8			 
52b8			;		pop hl   ; u2 - addr 
52b8			 
52b8					; TODO Send SPI byte 
52b8			 
52b8 7d					ld a, l 
52b9 cd ab 00				call spi_send_byte 
52bc			 
52bc					NEXTW 
52bc c3 8d 22			jp macro_next 
52bf				endm 
# End of macro NEXTW
52bf			 
52bf			.SPII: 
52bf				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
52bf 52				db WORD_SYS_CORE+62             
52c0 d4 52			dw .SESEL            
52c2 06				db 5 + 1 
52c3 .. 00			db "SPII",0              
52c8				endm 
# End of macro CWHEAD
52c8			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
52c8			 
52c8					; TODO Get SPI byte 
52c8			 
52c8 cd cc 00				call spi_read_byte 
52cb			 
52cb 26 00				ld h, 0 
52cd 6f					ld l, a 
52ce cd 1f 1f				call forth_push_numhl 
52d1			 
52d1					NEXTW 
52d1 c3 8d 22			jp macro_next 
52d4				endm 
# End of macro NEXTW
52d4			 
52d4			 
52d4			 
52d4			.SESEL: 
52d4				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
52d4 66				db WORD_SYS_CORE+82             
52d5 78 53			dw .CARTDEV            
52d7 05				db 4 + 1 
52d8 .. 00			db "BANK",0              
52dd				endm 
# End of macro CWHEAD
52dd			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
52dd					if DEBUG_FORTH_WORDS_KEY 
52dd						DMARK "BNK" 
52dd f5				push af  
52de 3a f2 52			ld a, (.dmark)  
52e1 32 6e fe			ld (debug_mark),a  
52e4 3a f3 52			ld a, (.dmark+1)  
52e7 32 6f fe			ld (debug_mark+1),a  
52ea 3a f4 52			ld a, (.dmark+2)  
52ed 32 70 fe			ld (debug_mark+2),a  
52f0 18 03			jr .pastdmark  
52f2 ..			.dmark: db "BNK"  
52f5 f1			.pastdmark: pop af  
52f6			endm  
# End of macro DMARK
52f6						CALLMONITOR 
52f6 cd ab 18			call break_point_state  
52f9				endm  
# End of macro CALLMONITOR
52f9					endif 
52f9			 
52f9 3e ff				ld a, 255 
52fb 32 6b fa				ld (spi_cartdev), a 
52fe			 
52fe					; get bank 
52fe			 
52fe					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
52fe cd 16 21			call macro_dsp_valuehl 
5301				endm 
# End of macro FORTH_DSP_VALUEHL
5301			 
5301			;		push hl 
5301			 
5301					; destroy value TOS 
5301			 
5301					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5301 cd ce 21			call macro_forth_dsp_pop 
5304				endm 
# End of macro FORTH_DSP_POP
5304			 
5304					; one value on hl get other one back 
5304			 
5304			;		pop hl 
5304			 
5304			 
5304 0e ff				ld c, SPI_CE_HIGH 
5306 06 30				ld b, '0'    ; human readable bank number 
5308			 
5308 7d					ld a, l 
5309			 
5309					if DEBUG_FORTH_WORDS 
5309						DMARK "BNK" 
5309 f5				push af  
530a 3a 1e 53			ld a, (.dmark)  
530d 32 6e fe			ld (debug_mark),a  
5310 3a 1f 53			ld a, (.dmark+1)  
5313 32 6f fe			ld (debug_mark+1),a  
5316 3a 20 53			ld a, (.dmark+2)  
5319 32 70 fe			ld (debug_mark+2),a  
531c 18 03			jr .pastdmark  
531e ..			.dmark: db "BNK"  
5321 f1			.pastdmark: pop af  
5322			endm  
# End of macro DMARK
5322						CALLMONITOR 
5322 cd ab 18			call break_point_state  
5325				endm  
# End of macro CALLMONITOR
5325					endif 
5325			 
5325					; active low 
5325			 
5325 fe 00				cp 0 
5327 28 28				jr z, .bset 
5329 fe 01				cp 1 
532b 20 04				jr nz, .b2 
532d cb 81				res 0, c 
532f 06 31				ld b, '1'    ; human readable bank number 
5331 fe 02		.b2:		cp 2 
5333 20 04				jr nz, .b3 
5335 cb 89				res 1, c 
5337 06 32				ld b, '2'    ; human readable bank number 
5339 fe 03		.b3:		cp 3 
533b 20 04				jr nz, .b4 
533d cb 91				res 2, c 
533f 06 33				ld b, '3'    ; human readable bank number 
5341 fe 04		.b4:		cp 4 
5343 20 04				jr nz, .b5 
5345 cb 99				res 3, c 
5347 06 34				ld b, '4'    ; human readable bank number 
5349 fe 05		.b5:		cp 5 
534b 20 04				jr nz, .bset 
534d cb a1				res 4, c 
534f 06 35				ld b, '5'    ; human readable bank number 
5351			 
5351			.bset: 
5351 79					ld a, c 
5352 32 68 fa				ld (spi_device),a 
5355 78					ld a, b 
5356 32 67 fa				ld (spi_device_id),a 
5359					if DEBUG_FORTH_WORDS 
5359						DMARK "BN2" 
5359 f5				push af  
535a 3a 6e 53			ld a, (.dmark)  
535d 32 6e fe			ld (debug_mark),a  
5360 3a 6f 53			ld a, (.dmark+1)  
5363 32 6f fe			ld (debug_mark+1),a  
5366 3a 70 53			ld a, (.dmark+2)  
5369 32 70 fe			ld (debug_mark+2),a  
536c 18 03			jr .pastdmark  
536e ..			.dmark: db "BN2"  
5371 f1			.pastdmark: pop af  
5372			endm  
# End of macro DMARK
5372						CALLMONITOR 
5372 cd ab 18			call break_point_state  
5375				endm  
# End of macro CALLMONITOR
5375					endif 
5375			 
5375					NEXTW 
5375 c3 8d 22			jp macro_next 
5378				endm 
# End of macro NEXTW
5378			 
5378			.CARTDEV: 
5378				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
5378 66				db WORD_SYS_CORE+82             
5379 21 54			dw .ENDDEVICE            
537b 08				db 7 + 1 
537c .. 00			db "CARTDEV",0              
5384				endm 
# End of macro CWHEAD
5384			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
5384					if DEBUG_FORTH_WORDS_KEY 
5384						DMARK "CDV" 
5384 f5				push af  
5385 3a 99 53			ld a, (.dmark)  
5388 32 6e fe			ld (debug_mark),a  
538b 3a 9a 53			ld a, (.dmark+1)  
538e 32 6f fe			ld (debug_mark+1),a  
5391 3a 9b 53			ld a, (.dmark+2)  
5394 32 70 fe			ld (debug_mark+2),a  
5397 18 03			jr .pastdmark  
5399 ..			.dmark: db "CDV"  
539c f1			.pastdmark: pop af  
539d			endm  
# End of macro DMARK
539d						CALLMONITOR 
539d cd ab 18			call break_point_state  
53a0				endm  
# End of macro CALLMONITOR
53a0					endif 
53a0			 
53a0					; disable se storage bank selection 
53a0			 
53a0 3e ff				ld a, SPI_CE_HIGH		; ce high 
53a2 32 68 fa				ld (spi_device), a 
53a5			 
53a5					; get bank 
53a5			 
53a5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
53a5 cd 16 21			call macro_dsp_valuehl 
53a8				endm 
# End of macro FORTH_DSP_VALUEHL
53a8			 
53a8			;		push hl 
53a8			 
53a8					; destroy value TOS 
53a8			 
53a8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
53a8 cd ce 21			call macro_forth_dsp_pop 
53ab				endm 
# End of macro FORTH_DSP_POP
53ab			 
53ab					; one value on hl get other one back 
53ab			 
53ab			;		pop hl 
53ab			 
53ab					; active low 
53ab			 
53ab 0e ff				ld c, 255 
53ad			 
53ad 7d					ld a, l 
53ae					if DEBUG_FORTH_WORDS 
53ae						DMARK "CDV" 
53ae f5				push af  
53af 3a c3 53			ld a, (.dmark)  
53b2 32 6e fe			ld (debug_mark),a  
53b5 3a c4 53			ld a, (.dmark+1)  
53b8 32 6f fe			ld (debug_mark+1),a  
53bb 3a c5 53			ld a, (.dmark+2)  
53be 32 70 fe			ld (debug_mark+2),a  
53c1 18 03			jr .pastdmark  
53c3 ..			.dmark: db "CDV"  
53c6 f1			.pastdmark: pop af  
53c7			endm  
# End of macro DMARK
53c7						CALLMONITOR 
53c7 cd ab 18			call break_point_state  
53ca				endm  
# End of macro CALLMONITOR
53ca					endif 
53ca fe 00				cp 0 
53cc 28 30				jr z, .cset 
53ce fe 01				cp 1 
53d0 20 02				jr nz, .c2 
53d2 cb 81				res 0, c 
53d4 fe 02		.c2:		cp 2 
53d6 20 02				jr nz, .c3 
53d8 cb 89				res 1, c 
53da fe 03		.c3:		cp 3 
53dc 20 02				jr nz, .c4 
53de cb 91				res 2, c 
53e0 fe 04		.c4:		cp 4 
53e2 20 02				jr nz, .c5 
53e4 cb 99				res 3, c 
53e6 fe 05		.c5:		cp 5 
53e8 20 02				jr nz, .c6 
53ea cb a1				res 4, c 
53ec fe 06		.c6:		cp 6 
53ee 20 02				jr nz, .c7 
53f0 cb a9				res 5, c 
53f2 fe 07		.c7:		cp 7 
53f4 20 02				jr nz, .c8 
53f6 cb b1				res 6, c 
53f8 fe 08		.c8:		cp 8 
53fa 20 02				jr nz, .cset 
53fc cb b9				res 7, c 
53fe 79			.cset:		ld a, c 
53ff 32 6b fa				ld (spi_cartdev),a 
5402			 
5402					if DEBUG_FORTH_WORDS 
5402						DMARK "CD2" 
5402 f5				push af  
5403 3a 17 54			ld a, (.dmark)  
5406 32 6e fe			ld (debug_mark),a  
5409 3a 18 54			ld a, (.dmark+1)  
540c 32 6f fe			ld (debug_mark+1),a  
540f 3a 19 54			ld a, (.dmark+2)  
5412 32 70 fe			ld (debug_mark+2),a  
5415 18 03			jr .pastdmark  
5417 ..			.dmark: db "CD2"  
541a f1			.pastdmark: pop af  
541b			endm  
# End of macro DMARK
541b						CALLMONITOR 
541b cd ab 18			call break_point_state  
541e				endm  
# End of macro CALLMONITOR
541e					endif 
541e					NEXTW 
541e c3 8d 22			jp macro_next 
5421				endm 
# End of macro NEXTW
5421			endif 
5421			 
5421			.ENDDEVICE: 
5421			; eof 
5421			 
# End of file forth_words_device.asm
5421			 
5421			; var handler 
5421			 
5421			 
5421			.VARS: 
5421				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
5421 78				db WORD_SYS_CORE+100             
5422 39 54			dw .V0Q            
5424 04				db 3 + 1 
5425 .. 00			db "V0!",0              
5429				endm 
# End of macro CWHEAD
5429			;| V0! ( u1 -- )  Store value to v0  | DONE 
5429			 
5429					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5429 cd 16 21			call macro_dsp_valuehl 
542c				endm 
# End of macro FORTH_DSP_VALUEHL
542c			 
542c 11 30 fa				ld de, cli_var_array 
542f			 
542f eb					ex de, hl 
5430 73					ld (hl), e 
5431 23					inc hl 
5432 72					ld (hl), d 
5433			 
5433					; destroy value TOS 
5433			 
5433					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5433 cd ce 21			call macro_forth_dsp_pop 
5436				endm 
# End of macro FORTH_DSP_POP
5436			 
5436				       NEXTW 
5436 c3 8d 22			jp macro_next 
5439				endm 
# End of macro NEXTW
5439			.V0Q: 
5439				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
5439 79				db WORD_SYS_CORE+101             
543a 4a 54			dw .V1S            
543c 04				db 3 + 1 
543d .. 00			db "V0@",0              
5441				endm 
# End of macro CWHEAD
5441			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
5441 2a 30 fa				ld hl, (cli_var_array) 
5444 cd 1f 1f				call forth_push_numhl 
5447			 
5447				       NEXTW 
5447 c3 8d 22			jp macro_next 
544a				endm 
# End of macro NEXTW
544a			.V1S: 
544a				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
544a 7a				db WORD_SYS_CORE+102             
544b 62 54			dw .V1Q            
544d 04				db 3 + 1 
544e .. 00			db "V1!",0              
5452				endm 
# End of macro CWHEAD
5452			;| V1! ( u1 -- )  Store value to v1 | DONE 
5452					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5452 cd 16 21			call macro_dsp_valuehl 
5455				endm 
# End of macro FORTH_DSP_VALUEHL
5455			 
5455 11 32 fa				ld de, cli_var_array+2 
5458				 
5458 eb					ex de, hl 
5459 73					ld (hl), e 
545a 23					inc hl 
545b 72					ld (hl), d 
545c			 
545c					; destroy value TOS 
545c			 
545c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
545c cd ce 21			call macro_forth_dsp_pop 
545f				endm 
# End of macro FORTH_DSP_POP
545f				       NEXTW 
545f c3 8d 22			jp macro_next 
5462				endm 
# End of macro NEXTW
5462			.V1Q: 
5462				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
5462 7b				db WORD_SYS_CORE+103             
5463 73 54			dw .V2S            
5465 04				db 3 + 1 
5466 .. 00			db "V1@",0              
546a				endm 
# End of macro CWHEAD
546a			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
546a 2a 32 fa				ld hl, (cli_var_array+2) 
546d cd 1f 1f				call forth_push_numhl 
5470				       NEXTW 
5470 c3 8d 22			jp macro_next 
5473				endm 
# End of macro NEXTW
5473			.V2S: 
5473				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
5473 7c				db WORD_SYS_CORE+104             
5474 8b 54			dw .V2Q            
5476 04				db 3 + 1 
5477 .. 00			db "V2!",0              
547b				endm 
# End of macro CWHEAD
547b			;| V2! ( u1 -- )  Store value to v2 | DONE 
547b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
547b cd 16 21			call macro_dsp_valuehl 
547e				endm 
# End of macro FORTH_DSP_VALUEHL
547e			 
547e 11 34 fa				ld de, cli_var_array+4 
5481				 
5481 eb					ex de, hl 
5482 73					ld (hl), e 
5483 23					inc hl 
5484 72					ld (hl), d 
5485			 
5485					; destroy value TOS 
5485			 
5485					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5485 cd ce 21			call macro_forth_dsp_pop 
5488				endm 
# End of macro FORTH_DSP_POP
5488				       NEXTW 
5488 c3 8d 22			jp macro_next 
548b				endm 
# End of macro NEXTW
548b			.V2Q: 
548b				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
548b 7d				db WORD_SYS_CORE+105             
548c 9c 54			dw .V3S            
548e 04				db 3 + 1 
548f .. 00			db "V2@",0              
5493				endm 
# End of macro CWHEAD
5493			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
5493 2a 34 fa				ld hl, (cli_var_array+4) 
5496 cd 1f 1f				call forth_push_numhl 
5499				       NEXTW 
5499 c3 8d 22			jp macro_next 
549c				endm 
# End of macro NEXTW
549c			.V3S: 
549c				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
549c 7c				db WORD_SYS_CORE+104             
549d b4 54			dw .V3Q            
549f 04				db 3 + 1 
54a0 .. 00			db "V3!",0              
54a4				endm 
# End of macro CWHEAD
54a4			;| V3! ( u1 -- )  Store value to v3 | DONE 
54a4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
54a4 cd 16 21			call macro_dsp_valuehl 
54a7				endm 
# End of macro FORTH_DSP_VALUEHL
54a7			 
54a7 11 36 fa				ld de, cli_var_array+6 
54aa				 
54aa eb					ex de, hl 
54ab 73					ld (hl), e 
54ac 23					inc hl 
54ad 72					ld (hl), d 
54ae			 
54ae					; destroy value TOS 
54ae			 
54ae					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
54ae cd ce 21			call macro_forth_dsp_pop 
54b1				endm 
# End of macro FORTH_DSP_POP
54b1				       NEXTW 
54b1 c3 8d 22			jp macro_next 
54b4				endm 
# End of macro NEXTW
54b4			.V3Q: 
54b4				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
54b4 7d				db WORD_SYS_CORE+105             
54b5 c5 54			dw .END            
54b7 04				db 3 + 1 
54b8 .. 00			db "V3@",0              
54bc				endm 
# End of macro CWHEAD
54bc			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
54bc 2a 36 fa				ld hl, (cli_var_array+6) 
54bf cd 1f 1f				call forth_push_numhl 
54c2				       NEXTW 
54c2 c3 8d 22			jp macro_next 
54c5				endm 
# End of macro NEXTW
54c5			 
54c5			 
54c5			 
54c5			 
54c5			 
54c5			; end of dict marker 
54c5			 
54c5 00			.END:    db WORD_SYS_END 
54c6 00 00			dw 0 
54c8 00				db 0 
54c9			 
54c9			; use to jp here for user dict words to save on macro expansion  
54c9			 
54c9			user_dict_next: 
54c9				NEXTW 
54c9 c3 8d 22			jp macro_next 
54cc				endm 
# End of macro NEXTW
54cc			 
54cc			 
54cc			user_exec: 
54cc				;    ld hl, <word code> 
54cc				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
54cc				;    call forthexec 
54cc				;    jp user_dict_next   (NEXT) 
54cc			        ;    <word code bytes> 
54cc eb				ex de, hl 
54cd 2a fe f4			ld hl,(os_tok_ptr) 
54d0				 
54d0				FORTH_RSP_NEXT 
54d0 cd c6 1e			call macro_forth_rsp_next 
54d3				endm 
# End of macro FORTH_RSP_NEXT
54d3			 
54d3			if DEBUG_FORTH_UWORD 
54d3						DMARK "UEX" 
54d3 f5				push af  
54d4 3a e8 54			ld a, (.dmark)  
54d7 32 6e fe			ld (debug_mark),a  
54da 3a e9 54			ld a, (.dmark+1)  
54dd 32 6f fe			ld (debug_mark+1),a  
54e0 3a ea 54			ld a, (.dmark+2)  
54e3 32 70 fe			ld (debug_mark+2),a  
54e6 18 03			jr .pastdmark  
54e8 ..			.dmark: db "UEX"  
54eb f1			.pastdmark: pop af  
54ec			endm  
# End of macro DMARK
54ec				CALLMONITOR 
54ec cd ab 18			call break_point_state  
54ef				endm  
# End of macro CALLMONITOR
54ef			endif 
54ef			 
54ef			 
54ef			 
54ef eb				ex de, hl 
54f0 22 fe f4			ld (os_tok_ptr), hl 
54f3				 
54f3				; Don't use next - Skips the first word in uword. 
54f3			 
54f3 c3 1e 23			jp exec1 
54f6			;	NEXT 
54f6			 
54f6			 
54f6			; eof 
# End of file forth_wordsv4.asm
54f6			endif 
54f6			;;;;;;;;;;;;;; Debug code 
54f6			 
54f6			 
54f6			;if DEBUG_FORTH_PARSE 
54f6 .. 00		.nowordfound: db "No match",0 
54ff .. 00		.compword:	db "Comparing word ",0 
550f .. 00		.nextwordat:	db "Next word at",0 
551c .. 00		.charmatch:	db "Char match",0 
5527			;endif 
5527			if DEBUG_FORTH_JP 
5527			.foundword:	db "Word match. Exec..",0 
5527			endif 
5527			;if DEBUG_FORTH_PUSH 
5527 .. 00		.enddict:	db "Dict end. Push.",0 
5537 .. 00		.push_str:	db "Pushing string",0 
5546 .. 00		.push_num:	db "Pushing number",0 
5555 .. 00		.data_sp:	db "SP:",0 
5559 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
556b .. 00		.wordinde:	db "Word in DE (3/0):",0 
557d .. 00		.wordinbc:	db "Word in BC (4/0):",0 
558f			;endif 
558f			;if DEBUG_FORTH_MALLOC 
558f .. 00		.push_malloc:	db "Malloc address",0 
559e			;endif 
559e			 
559e			 
559e			 
559e			; display malloc address and current data stack pointer  
559e			 
559e			malloc_error: 
559e d5				push de 
559f f5				push af 
55a0 e5				push hl 
55a1 cd d0 0c			call clear_display 
55a4 11 c6 55			ld de, .mallocerr 
55a7 3e 00			ld a,0 
55a9			;	ld de,os_word_scratch 
55a9 cd e3 0c			call str_at_display 
55ac 3e 11			ld a, display_row_1+17 
55ae 11 6e fe			ld de, debug_mark 
55b1 cd e3 0c			call str_at_display 
55b4 cd f3 0c			call update_display 
55b7				;call break_point_state 
55b7 cd 38 6d			call cin_wait 
55ba			 
55ba 3e 20			ld a, ' ' 
55bc 32 ee f1			ld (os_view_disable), a 
55bf e1				pop hl 
55c0 f1				pop af 
55c1 d1				pop de	 
55c2				CALLMONITOR 
55c2 cd ab 18			call break_point_state  
55c5				endm  
# End of macro CALLMONITOR
55c5 c9				ret 
55c6			 
55c6 .. 00		.mallocerr: 	db "Malloc Error",0 
55d3			;if DEBUG_FORTH_PUSH 
55d3			display_data_sp: 
55d3 f5				push af 
55d4			 
55d4				; see if disabled 
55d4			 
55d4 3a ee f1			ld a, (os_view_disable) 
55d7 fe 2a			cp '*' 
55d9 28 67			jr z, .skipdsp 
55db			 
55db e5				push hl 
55dc e5				push hl 
55dd e5			push hl 
55de cd d0 0c			call clear_display 
55e1 e1			pop hl 
55e2 7c				ld a,h 
55e3 21 02 f5			ld hl, os_word_scratch 
55e6 cd 05 12			call hexout 
55e9 e1				pop hl 
55ea 7d				ld a,l 
55eb 21 04 f5			ld hl, os_word_scratch+2 
55ee cd 05 12			call hexout 
55f1 21 06 f5			ld hl, os_word_scratch+4 
55f4 3e 00			ld a,0 
55f6 77				ld (hl),a 
55f7 11 02 f5			ld de,os_word_scratch 
55fa 3e 28				ld a, display_row_2 
55fc cd e3 0c				call str_at_display 
55ff 11 59 55			ld de, .wordinhl 
5602 3e 00			ld a, display_row_1 
5604			 
5604 cd e3 0c				call str_at_display 
5607 11 6e fe			ld de, debug_mark 
560a 3e 11			ld a, display_row_1+17 
560c			 
560c cd e3 0c				call str_at_display 
560f			 
560f				; display current data stack pointer 
560f 11 55 55			ld de,.data_sp 
5612 3e 30				ld a, display_row_2 + 8 
5614 cd e3 0c				call str_at_display 
5617			 
5617 2a 2a fa			ld hl,(cli_data_sp) 
561a e5				push hl 
561b 7c				ld a,h 
561c 21 02 f5			ld hl, os_word_scratch 
561f cd 05 12			call hexout 
5622 e1				pop hl 
5623 7d				ld a,l 
5624 21 04 f5			ld hl, os_word_scratch+2 
5627 cd 05 12			call hexout 
562a 21 06 f5			ld hl, os_word_scratch+4 
562d 3e 00			ld a,0 
562f 77				ld (hl),a 
5630 11 02 f5			ld de,os_word_scratch 
5633 3e 33				ld a, display_row_2 + 11 
5635 cd e3 0c				call str_at_display 
5638			 
5638			 
5638 cd f3 0c			call update_display 
563b cd 4d 0c			call delay1s 
563e cd 4d 0c			call delay1s 
5641 e1				pop hl 
5642			.skipdsp: 
5642 f1				pop af 
5643 c9				ret 
5644			 
5644			display_data_malloc: 
5644			 
5644 f5				push af 
5645 e5				push hl 
5646 e5				push hl 
5647 e5			push hl 
5648 cd d0 0c			call clear_display 
564b e1			pop hl 
564c 7c				ld a,h 
564d 21 02 f5			ld hl, os_word_scratch 
5650 cd 05 12			call hexout 
5653 e1				pop hl 
5654 7d				ld a,l 
5655 21 04 f5			ld hl, os_word_scratch+2 
5658 cd 05 12			call hexout 
565b 21 06 f5			ld hl, os_word_scratch+4 
565e 3e 00			ld a,0 
5660 77				ld (hl),a 
5661 11 02 f5			ld de,os_word_scratch 
5664 3e 28				ld a, display_row_2 
5666 cd e3 0c				call str_at_display 
5669 11 8f 55			ld de, .push_malloc 
566c 3e 00			ld a, display_row_1 
566e			 
566e cd e3 0c				call str_at_display 
5671			 
5671				; display current data stack pointer 
5671 11 55 55			ld de,.data_sp 
5674 3e 30				ld a, display_row_2 + 8 
5676 cd e3 0c				call str_at_display 
5679			 
5679 2a 2a fa			ld hl,(cli_data_sp) 
567c e5				push hl 
567d 7c				ld a,h 
567e 21 02 f5			ld hl, os_word_scratch 
5681 cd 05 12			call hexout 
5684 e1				pop hl 
5685 7d				ld a,l 
5686 21 04 f5			ld hl, os_word_scratch+2 
5689 cd 05 12			call hexout 
568c 21 06 f5			ld hl, os_word_scratch+4 
568f 3e 00			ld a,0 
5691 77				ld (hl),a 
5692 11 02 f5			ld de,os_word_scratch 
5695 3e 33				ld a, display_row_2 + 11 
5697 cd e3 0c				call str_at_display 
569a			 
569a cd f3 0c			call update_display 
569d cd 4d 0c			call delay1s 
56a0 cd 4d 0c			call delay1s 
56a3 e1				pop hl 
56a4 f1				pop af 
56a5 c9				ret 
56a6			;endif 
56a6			 
56a6			include "forth_autostart.asm" 
56a6			; list of commands to perform at system start up 
56a6			 
56a6			startcmds: 
56a6			;	dw test11 
56a6			;	dw test12 
56a6			;	dw test13 
56a6			;	dw test14 
56a6			;	dw test15 
56a6			;	dw test16 
56a6			;	dw test17 
56a6			;	dw ifthtest1 
56a6			;	dw ifthtest2 
56a6			;	dw ifthtest3 
56a6			;	dw mmtest1 
56a6			;	dw mmtest2 
56a6			;	dw mmtest3 
56a6			;	dw mmtest4 
56a6			;	dw mmtest5 
56a6			;	dw mmtest6 
56a6			;	dw iftest1 
56a6			;	dw iftest2 
56a6			;	dw iftest3 
56a6			;	dw looptest1 
56a6			;	dw looptest2 
56a6			;	dw test1 
56a6			;	dw test2 
56a6			;	dw test3 
56a6			;	dw test4 
56a6			;	dw game2r 
56a6			;	dw game2b1 
56a6			;	dw game2b2 
56a6			 
56a6				; start up words that are actually useful 
56a6			 
56a6 06 57			dw longread 
56a8 4d 57			dw clrstack 
56aa 80 57			dw type 
56ac 70 59			dw stest 
56ae a4 57			dw strncpy 
56b0 06 59			dw list 
56b2 05 58			dw start1 
56b4 17 58			dw start2 
56b6			;	dw start3 
56b6 2a 58			dw start3b 
56b8 a6 58			dw start3c 
56ba			 
56ba				; (unit) testing words 
56ba			 
56ba e7 59			dw mtesta 
56bc 9c 5a			dw mtestb 
56be 3f 5b			dw mtestc 
56c0 f4 5b			dw mtestd 
56c2 98 5c			dw mteste 
56c4			 
56c4				; demo/game words 
56c4			 
56c4 a4 63		        dw game3w 
56c6 d2 63		        dw game3p 
56c8 f0 63		        dw game3sc 
56ca 21 64		        dw game3vsi 
56cc 4d 64		        dw game3vs 
56ce				 
56ce 97 61			dw game2b 
56d0 05 62			dw game2bf 
56d2 4f 62			dw game2mba 
56d4 e5 62			dw game2mbas 
56d6 27 63			dw game2mb 
56d8			 
56d8 58 5e			dw game1 
56da 69 5e			dw game1a 
56dc cb 5e			dw game1b 
56de 00 5f			dw game1c 
56e0 36 5f			dw game1d 
56e2 67 5f			dw game1s 
56e4 7b 5f			dw game1t 
56e6 90 5f			dw game1f 
56e8 c4 5f			dw game1z 
56ea 08 60			dw game1zz 
56ec			 
56ec 4e 5d			dw test5 
56ee 86 5d			dw test6 
56f0 be 5d			dw test7 
56f2 d2 5d			dw test8 
56f4 fe 5d			dw test9 
56f6 14 5e			dw test10 
56f8				 
56f8 df 60		        dw ssv5 
56fa c3 60		        dw ssv4 
56fc a7 60		        dw ssv3 
56fe 71 60		        dw ssv2 
5700 f8 60		        dw ssv1 
5702 40 61		        dw ssv1cpm 
5704			;	dw keyup 
5704			;	dw keydown 
5704			;	dw keyleft 
5704			;	dw keyright 
5704			;	dw 	keyf1 
5704			;	dw keyf2 
5704			;	dw keyf3 
5704			;	dw keyf4 
5704			;	dw keyf5 
5704			;	dw keyf6 
5704			;	dw keyf7 
5704			;	dw keyf8 
5704			;	dw keyf9 
5704			;	dw keyf10 
5704			;	dw keyf11 
5704			;	dw keyf12 
5704			;	dw keytab 
5704			;	dw keycr 
5704			;	dw keyhome 
5704			;	dw keyend 
5704			;	dw keybs 
5704 00 00			db 0, 0	 
5706			 
5706			 
5706			; Long read of currently open file 
5706 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
574d			 
574d			; clear stack  
574d			 
574d .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
5780			 
5780			; type ( addr count - ) 
5780 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
57a4			 
57a4			; some direct memory words 
57a4			; strncpy ( len t f -- t ) 
57a4			 
57a4 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
5805			 
5805 .. 00		start1:     	db ": bpon $0000 bp ;",0 
5817 .. 00		start2:     	db ": bpoff $0001 bp ;",0 
582a .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
58a6 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
5906			 
5906			 
5906			; a handy word to list items on the stack 
5906			 
5906 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
5970			 
5970			 
5970			; test stack  
5970			; rnd8 stest 
5970			 
5970 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
59e7			 
59e7			; random malloc and free cycles 
59e7			 
59e7 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5a9c			 
5a9c			; fixed malloc and free cycles 
5a9c			 
5a9c .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5b3f			 
5b3f			; fixed double string push and drop cycle  
5b3f			 
5b3f .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
5bf4			 
5bf4			; consistent fixed string push and drop cycle  
5bf4			 
5bf4 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5c98			 
5c98 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5d4e			 
5d4e			;test1:		db ": aa 1 2 3 ;", 0 
5d4e			;test2:     	db "111 aa 888 999",0 
5d4e			;test3:     	db ": bb 77 ;",0 
5d4e			;test4:     	db "$02 $01 do i . loop bb",0 
5d4e			 
5d4e .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
5d86 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
5dbe .. 00		test7:     	db ": box hline vline ;",0 
5dd2 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
5dfe .. 00		test9:     	db ": sw $01 adsp world ;",0 
5e14 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
5e39 .. 00		test11:     	db "hello create .",0 
5e48 .. 00		test12:     	db "hello2 create .",0 
5e58			 
5e58			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
5e58			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
5e58			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
5e58			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
5e58			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
5e58			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
5e58			 
5e58			;iftest1:     	db "$0001 IF cls .",0 
5e58			;iftest2:     	db "$0000 IF cls .",0 
5e58			;iftest3:     	db "$0002 $0003 - IF cls .",0 
5e58			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
5e58			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
5e58			 
5e58			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5e58			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5e58			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5e58			 
5e58			 
5e58			 
5e58			; a small guess the number game 
5e58			 
5e58 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
5e69 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
5ecb			 
5ecb .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
5f00 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
5f36 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
5f67 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
5f7b .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
5f90 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5fc4 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
6008			 
6008			; Using 'ga' save a high score across multiple runs using external storage 
6008			 
6008 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
6071			 
6071			 
6071			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
6071			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
6071			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
6071			 
6071			; simple screen saver to test code memory reuse to destruction 
6071			 
6071 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
60a7 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
60c3 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
60df .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
60f8 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
6140 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
6197			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
6197			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
6197			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
6197			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
6197			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
6197			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
6197			 
6197			 
6197			 
6197			; minesweeper/battleship finding game 
6197			; draws a game board of random ship/mine positions 
6197			; user enters coords to see if it hits on 
6197			; game ends when all are hit 
6197			; when hit or miss says how many may be in the area 
6197			 
6197			; setup the game board and then hide it 
6197 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
6205 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
624f			; prompt for where to target 
624f .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
62e5 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
630a			; TODO see if the entered coords hits or misses pushes char hit of miss 
630a .. 00		game2mbht:      db ": mbckht nop ;",0 
6319 .. 00		game2mbms:      db ": mbcms nop ;",0 
6327			; TODO how many might be near by 
6327 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
63a4			 
63a4			; Game 3 
63a4			 
63a4			; Vert scroller ski game - avoid the trees! 
63a4			 
63a4			; v0 score (ie turns) 
63a4			; v1 player pos 
63a4			; v2 left wall 
63a4			; v3 right wall 
63a4			 
63a4			; Draw side walls randomly 
63a4			 
63a4 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
63d2			 
63d2			; Draw player 
63d2 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
63f0			 
63f0			; TODO Get Key 
63f0			 
63f0			; TODO Move left right 
63f0			 
63f0			; scroll and move walls a bit 
63f0			 
63f0 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
6421			 
6421			; main game loop 
6421			 
6421 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
644d .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
648c			 
648c			; key board defs 
648c			 
648c .. 00		keyup:       db ": keyup $05 ;",0 
649a .. 00		keydown:       db ": keydown $0a ;",0 
64aa .. 00		keyleft:       db ": keyleft $0b ;",0 
64ba .. 00		keyright:       db ": keyright $0c ;",0 
64cb .. 00		keyf1:       db ": keyf1 $10 ;",0 
64d9 .. 00		keyf2:       db ": keyf2 $11 ;",0 
64e7 .. 00		keyf3:       db ": keyf3 $12 ;",0 
64f5 .. 00		keyf4:       db ": keyf4 $13 ;",0 
6503 .. 00		keyf5:       db ": keyf5 $14 ;",0 
6511 .. 00		keyf6:       db ": keyf6 $15 ;",0 
651f .. 00		keyf7:       db ": keyf7 $16 ;",0 
652d .. 00		keyf8:       db ": keyf8 $17 ;",0 
653b .. 00		keyf9:       db ": keyf9 $18 ;",0 
6549 .. 00		keyf10:       db ": keyf10 $19 ;",0 
6558 .. 00		keyf11:       db ": keyf11 $1a ;",0 
6567 .. 00		keyf12:       db ": keyf12 $1b ;",0 
6576			 
6576 .. 00		keytab:       db ": keytab $09 ;",0 
6585 .. 00		keycr:       db ": keycr $0d ;",0 
6593 .. 00		keyhome:       db ": keyhome $0e ;",0 
65a3 .. 00		keyend:       db ": keyend $0f ;",0 
65b2 .. 00		keybs:       db ": keybs $08 ;",0 
65c0			 
65c0			   
65c0			 
65c0			 
65c0			 
65c0			; eof 
# End of file forth_autostart.asm
65c0			 
65c0 .. 00		sprompt1: db "Startup load...",0 
65d0 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
65e6			 
65e6			 
65e6			 
65e6			 
65e6			forth_startup: 
65e6 21 a6 56			ld hl, startcmds 
65e9 3e 00			ld a, 0 
65eb 32 23 f6			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
65ee			 
65ee e5			.start1:	push hl 
65ef cd d0 0c			call clear_display 
65f2 11 c0 65			ld de, sprompt1 
65f5 3e 00		        ld a, display_row_1 
65f7 cd e3 0c			call str_at_display 
65fa 11 d0 65			ld de, sprompt2 
65fd 3e 28		        ld a, display_row_2 
65ff cd e3 0c			call str_at_display 
6602 e1				pop hl 
6603 e5				push hl 
6604 5e				ld e,(hl) 
6605 23				inc hl 
6606 56				ld d,(hl) 
6607 3e 50		        ld a, display_row_3 
6609 cd e3 0c			call str_at_display 
660c cd f3 0c			call update_display 
660f			 
660f			 
660f 3a 23 f6			ld a, (os_last_cmd) 
6612 fe 00			cp 0 
6614 28 05			jr z, .startprompt 
6616 cd 41 0c			call delay250ms 
6619 18 24			jr .startdo 
661b				 
661b				 
661b			 
661b			.startprompt: 
661b			 
661b 3e 9f			ld a,display_row_4 + display_cols - 1 
661d 11 95 1e		        ld de, endprg 
6620 cd e3 0c			call str_at_display 
6623 cd f3 0c			call update_display 
6626 cd 4d 0c			call delay1s 
6629 cd 38 6d			call cin_wait 
662c						 
662c fe 2a			cp '*' 
662e 28 5e			jr z, .startupend1 
6630 fe 23			cp '#' 
6632 20 07			jr nz, .startno 
6634 3e 01			ld a, 1 
6636 32 23 f6			ld (os_last_cmd),a 
6639 18 04			jr .startdo 
663b fe 31		.startno:	cp '1' 
663d 28 3a			jr z,.startnxt  
663f			 
663f				; exec startup line 
663f			.startdo:	 
663f e1				pop hl 
6640 e5				push hl 
6641				 
6641 5e				ld e,(hl) 
6642 23				inc hl 
6643 56				ld d,(hl) 
6644 eb				ex de,hl 
6645			 
6645 e5				push hl 
6646			 
6646 3e 00			ld a, 0 
6648				;ld a, FORTH_END_BUFFER 
6648 cd 6d 13			call strlent 
664b 23				inc hl   ; include zero term to copy 
664c 06 00			ld b,0 
664e 4d				ld c,l 
664f e1				pop hl 
6650 11 fd f1			ld de, scratch 
6653 ed b0			ldir 
6655			 
6655			 
6655 21 fd f1			ld hl, scratch 
6658 cd db 22			call forthparse 
665b cd 1b 23			call forthexec 
665e cd 2d 22			call forthexec_cleanup 
6661			 
6661 3e 78			ld a, display_row_4 
6663 11 39 1c			ld de, endprog 
6666			 
6666 cd f3 0c			call update_display		 
6669			 
6669 3a 23 f6			ld a, (os_last_cmd) 
666c fe 00			cp 0 
666e 20 09			jr nz, .startnxt 
6670 cd 97 1e			call next_page_prompt 
6673 cd d0 0c		        call clear_display 
6676 cd f3 0c			call update_display		 
6679			 
6679				; move onto next startup line? 
6679			.startnxt: 
6679			 
6679 cd 41 0c			call delay250ms 
667c e1				pop hl 
667d			 
667d 23				inc hl 
667e 23				inc hl 
667f			 
667f e5				push hl 
6680 5e				ld e, (hl) 
6681 23				inc hl 
6682 56				ld d, (hl) 
6683 e1				pop hl 
6684				; TODO replace 0 test 
6684			 
6684 eb				ex de, hl 
6685 cd 2d 0f			call ishlzero 
6688			;	ld a,e 
6688			;	add d 
6688			;	cp 0    ; any left to do? 
6688 eb				ex de, hl 
6689 c2 ee 65			jp nz, .start1 
668c 18 01			jr .startupend 
668e			 
668e e1			.startupend1: pop hl 
668f			.startupend: 
668f			 
668f cd d0 0c			call clear_display 
6692 cd f3 0c			call update_display 
6695 c9				ret 
6696			 
6696			 
6696			; stack over and underflow checks 
6696			 
6696			; init the words to detect the under/overflow 
6696			 
6696			chk_stk_init: 
6696				; a vague random number to check so we dont get any "lucky" hits 
6696 3e 2d			ld a, 45 
6698 6f				ld l, a 
6699 00				nop 
669a 3e 17			ld a, 23 
669c 67				ld h, a 
669d			 
669d 22 e4 f1			ld (chk_word), hl     ; the word we need to check against 
66a0			 
66a0			;	ld (chk_stund), hl	; stack points.... 
66a0 22 fd fe			ld (chk_stovr), hl 
66a3 22 28 fa			ld (chk_ret_und), hl 
66a6 22 e6 f9			ld (chk_ret_ovr), hl 
66a9 22 64 f9			ld (chk_loop_ovr), hl 
66ac 22 62 f7			ld (chk_data_ovr), hl 
66af c9				ret 
66b0				 
66b0			check_stacks: 
66b0				; check all stack words 
66b0			 
66b0 e5				push hl 
66b1 d5				push de 
66b2			 
66b2			;	ld de,(chk_word) 
66b2			;	ld hl, (chk_stund)	; stack points.... 
66b2			;	if DEBUG_STK_FAULT 
66b2			;		DMARK "FAa" 
66b2			;		CALLMONITOR 
66b2			;	endif 
66b2			;	call cmp16 
66b2			;	jp z, .chk_faulta 
66b2			; 
66b2			;	ld de, sfaultsu 
66b2			;	jp .chk_fault 
66b2			 
66b2 2a fd fe		.chk_faulta: ld hl, (chk_stovr) 
66b5 ed 5b e4 f1		ld de,(chk_word) 
66b9				if DEBUG_STK_FAULT 
66b9					DMARK "FAb" 
66b9					CALLMONITOR 
66b9				endif 
66b9 cd 22 0f			call cmp16 
66bc 28 06			jr z, .chk_fault1 
66be 11 5f 67			ld de, sfaultso 
66c1 c3 13 67			jp .chk_fault 
66c4			.chk_fault1:  
66c4 2a 28 fa			ld hl, (chk_ret_und) 
66c7 ed 5b e4 f1		ld de,(chk_word) 
66cb				if DEBUG_STK_FAULT 
66cb					DMARK "FAU" 
66cb					CALLMONITOR 
66cb				endif 
66cb cd 22 0f			call cmp16 
66ce ca d7 66			jp z, .chk_fault2 
66d1 11 6f 67			ld de, sfaultru 
66d4 c3 13 67			jp .chk_fault 
66d7			.chk_fault2:  
66d7 2a e6 f9			ld hl, (chk_ret_ovr) 
66da ed 5b e4 f1		ld de,(chk_word) 
66de				if DEBUG_STK_FAULT 
66de					DMARK "FA1" 
66de					CALLMONITOR 
66de				endif 
66de cd 22 0f			call cmp16 
66e1 ca ea 66			jp z, .chk_fault3 
66e4 11 7d 67			ld de, sfaultro 
66e7 c3 13 67			jp .chk_fault 
66ea			.chk_fault3:  
66ea 2a 64 f9			ld hl, (chk_loop_ovr) 
66ed ed 5b e4 f1		ld de,(chk_word) 
66f1				if DEBUG_STK_FAULT 
66f1					DMARK "FA2" 
66f1					CALLMONITOR 
66f1				endif 
66f1 cd 22 0f			call cmp16 
66f4 ca fd 66			jp z, .chk_fault4 
66f7 11 97 67			ld de, sfaultlo 
66fa c3 13 67			jp .chk_fault 
66fd			.chk_fault4:  
66fd 2a 62 f7			ld hl, (chk_data_ovr) 
6700 ed 5b e4 f1		ld de,(chk_word) 
6704				if DEBUG_STK_FAULT 
6704					DMARK "FA3" 
6704					CALLMONITOR 
6704				endif 
6704 cd 22 0f			call cmp16 
6707 ca 10 67			jp z, .chk_fault5 
670a 11 b1 67			ld de, sfaultdo 
670d c3 13 67			jp .chk_fault 
6710			 
6710			 
6710			.chk_fault5:  
6710 d1				pop de 
6711 e1				pop hl 
6712			 
6712 c9				ret 
6713			 
6713 cd d0 0c		.chk_fault: 	call clear_display 
6716 3e 28				ld a, display_row_2 
6718 cd e3 0c				call str_at_display 
671b 11 41 67				   ld de, .stackfault 
671e 3e 00				ld a, display_row_1 
6720 cd e3 0c				call str_at_display 
6723 11 6e fe				    ld de, debug_mark 
6726 3e 11				ld a, display_row_1+17 
6728 cd e3 0c				call str_at_display 
672b cd f3 0c				call update_display 
672e			 
672e				; prompt before entering montior for investigating issue 
672e			 
672e 3e 78			ld a, display_row_4 
6730 11 39 1c			ld de, endprog 
6733			 
6733 cd f3 0c			call update_display		 
6736			 
6736 cd 97 1e			call next_page_prompt 
6739			 
6739 d1				pop de 
673a e1				pop hl 
673b cd 8d 1c				call monitor 
673e c3 84 1b				jp warmstart 
6741					;jp 0 
6741					;halt 
6741			 
6741			 
6741			 
6741 .. 00		.stackfault: 	db "Stack fault:",0 
674e			 
674e .. 00		sfaultsu: 	db	"Stack under flow",0 
675f .. 00		sfaultso: 	db	"Stack over flow",0 
676f .. 00		sfaultru:	db "RTS underflow",0 
677d .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
6797 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
67b1 .. 00		sfaultdo:	db "DTS overflow", 0 
67be			 
67be			 
67be			fault_dsp_under: 
67be 11 d0 67			ld de, .dsp_under 
67c1 c3 80 68			jp .show_fault 
67c4			 
67c4			fault_rsp_under: 
67c4 11 de 67			ld de, .rsp_under 
67c7 c3 80 68			jp .show_fault 
67ca			fault_loop_under: 
67ca 11 ec 67			ld de, .loop_under 
67cd c3 80 68			jp .show_fault 
67d0			 
67d0 .. 00		.dsp_under: db "DSP Underflow",0 
67de .. 00		.rsp_under: db "RSP Underflow",0 
67ec .. 00		.loop_under: db "LOOP Underflow",0 
67fb			 
67fb			 
67fb d5			type_faultn: 	push de 
67fc e5					push hl 
67fd cd d0 0c				call clear_display 
6800 11 27 68				   ld de, .typefaultn 
6803 3e 00				ld a, display_row_1 
6805 cd e3 0c				call str_at_display 
6808 11 6e fe				    ld de, debug_mark 
680b 3e 11				ld a, display_row_1+17 
680d cd e3 0c				call str_at_display 
6810 cd f3 0c				call update_display 
6813			 
6813				; prompt before entering montior for investigating issue 
6813			 
6813 3e 78			ld a, display_row_4 
6815 11 39 1c			ld de, endprog 
6818			 
6818 cd f3 0c			call update_display		 
681b			 
681b cd 97 1e			call next_page_prompt 
681e			 
681e e5					push hl 
681f d5					push de 
6820 cd 8d 1c				call monitor 
6823 c3 84 1b				jp warmstart 
6826 76					halt 
6827			 
6827			 
6827 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
683e			 
683e d5			type_faults: 	push de 
683f e5					push hl 
6840 cd d0 0c				call clear_display 
6843 11 69 68				   ld de, .typefaults 
6846 3e 00				ld a, display_row_1 
6848 cd e3 0c				call str_at_display 
684b 11 6e fe				    ld de, debug_mark 
684e 3e 11				ld a, display_row_1+17 
6850 cd e3 0c				call str_at_display 
6853 cd f3 0c				call update_display 
6856			 
6856				; prompt before entering montior for investigating issue 
6856			 
6856 3e 78			ld a, display_row_4 
6858 11 39 1c			ld de, endprog 
685b			 
685b cd f3 0c			call update_display		 
685e			 
685e cd 97 1e			call next_page_prompt 
6861			 
6861 e1					pop hl 
6862 d1					pop de 
6863 cd 8d 1c				call monitor 
6866 c3 84 1b				jp warmstart 
6869			 
6869			 
6869 .. 00		.typefaults: db "STR Type Expected TOS!",0 
6880			 
6880			.show_fault: 	 
6880 d5					push de 
6881 cd d0 0c				call clear_display 
6884 d1					pop de 
6885 3e 00				ld a, display_row_1 
6887 cd e3 0c				call str_at_display 
688a 11 6e fe				    ld de, debug_mark 
688d 3e 11				ld a, display_row_1+17 
688f cd e3 0c				call str_at_display 
6892 cd f3 0c				call update_display 
6895			 
6895				; prompt before entering montior for investigating issue 
6895			 
6895 3e 78			ld a, display_row_4 
6897 11 39 1c			ld de, endprog 
689a			 
689a cd f3 0c			call update_display		 
689d			 
689d cd 97 1e			call next_page_prompt 
68a0			 
68a0 e1					pop hl 
68a1 d1					pop de 
68a2 cd 8d 1c				call monitor 
68a5			; do a dump to cli and not warmstart so we preserve all of the uwords.  
68a5			; TODO Make optional fault restart to cli or warm boot? 
68a5					;jp warmstart 
68a5 c3 df 1b				jp cli 
68a8 76					halt 
68a9			 
68a9			; handle the auto run of code from files in storage 
68a9			 
68a9			 
68a9			if STORAGE_SE 
68a9			 
68a9 .. 00		sprompt3: db "Loading from start-up file?:",0 
68c6 .. 00		sprompt4: db "(Y=Any key/N=No)",0 
68d7			 
68d7			 
68d7			forth_autoload: 
68d7			 
68d7				; load block 0 of store 1 
68d7				 
68d7 3e fe			ld a, $fe      ; bit 0 clear 
68d9 32 68 fa			ld (spi_device), a 
68dc			 
68dc cd 85 04			call storage_get_block_0 
68df			 
68df 3a a2 fa			ld a, (store_page+STORE_0_AUTOFILE) 
68e2			 
68e2 fe 00			cp 0 
68e4 c8				ret z     ; auto start not enabled 
68e5			 
68e5 cd d0 0c			call clear_display 
68e8			 
68e8				; set bank 
68e8			 
68e8 3a a4 fa				ld a, (store_page+STORE_0_BANKRUN) 
68eb 32 68 fa				ld (spi_device), a 
68ee			 
68ee				; get file id to load from and get the file name to display 
68ee			 
68ee 3a a5 fa				ld a, (store_page+STORE_0_FILERUN) 
68f1			 
68f1 2e 00				ld l, 0 
68f3 67					ld h, a 
68f4 11 81 fa				ld de, store_page 
68f7			 
68f7					if DEBUG_FORTH_WORDS 
68f7						DMARK "ASp" 
68f7 f5				push af  
68f8 3a 0c 69			ld a, (.dmark)  
68fb 32 6e fe			ld (debug_mark),a  
68fe 3a 0d 69			ld a, (.dmark+1)  
6901 32 6f fe			ld (debug_mark+1),a  
6904 3a 0e 69			ld a, (.dmark+2)  
6907 32 70 fe			ld (debug_mark+2),a  
690a 18 03			jr .pastdmark  
690c ..			.dmark: db "ASp"  
690f f1			.pastdmark: pop af  
6910			endm  
# End of macro DMARK
6910						CALLMONITOR 
6910 cd ab 18			call break_point_state  
6913				endm  
# End of macro CALLMONITOR
6913					endif 
6913 cd 2d 09				call storage_read 
6916			 
6916					if DEBUG_FORTH_WORDS 
6916						DMARK "ASr" 
6916 f5				push af  
6917 3a 2b 69			ld a, (.dmark)  
691a 32 6e fe			ld (debug_mark),a  
691d 3a 2c 69			ld a, (.dmark+1)  
6920 32 6f fe			ld (debug_mark+1),a  
6923 3a 2d 69			ld a, (.dmark+2)  
6926 32 70 fe			ld (debug_mark+2),a  
6929 18 03			jr .pastdmark  
692b ..			.dmark: db "ASr"  
692e f1			.pastdmark: pop af  
692f			endm  
# End of macro DMARK
692f						CALLMONITOR 
692f cd ab 18			call break_point_state  
6932				endm  
# End of macro CALLMONITOR
6932					endif 
6932			 
6932 cd 2d 0f				call ishlzero 
6935 c8					ret z             ; file not found 
6936			 
6936 3e 32				ld a, display_row_2 + 10 
6938 11 84 fa				ld de, store_page+3 
693b cd e3 0c				call str_at_display 
693e				 
693e			; 
693e			 
693e 3e 05			ld a, display_row_1+5 
6940 11 a9 68			ld de, sprompt3 
6943 cd e3 0c			call str_at_display 
6946 3e 5f			ld a, display_row_3+15 
6948 11 c6 68			ld de, sprompt4 
694b cd e3 0c			call str_at_display 
694e			 
694e cd f3 0c			call update_display 
6951			 
6951 cd 38 6d			call cin_wait 
6954 fe 6e			cp 'n' 
6956 c8				ret z 
6957 fe 4e			cp 'N' 
6959 c8				ret z 
695a			 
695a cd 4d 0c			call delay1s 
695d			 
695d 3a 83 fa			ld a, (store_page+2) 
6960 32 70 fa			ld (store_openmaxext), a    ; save count of ext 
6963 3e 01			ld a, 1  
6965 32 71 fa			ld (store_openext), a    ; save count of ext 
6968			 
6968			.autof:  
6968 6f				ld l , a 
6969				 
6969 3a 81 fa			ld a, (store_page) 
696c 67				ld h, a	 
696d 11 81 fa			ld de, store_page 
6970					if DEBUG_FORTH_WORDS 
6970						DMARK "ASl" 
6970 f5				push af  
6971 3a 85 69			ld a, (.dmark)  
6974 32 6e fe			ld (debug_mark),a  
6977 3a 86 69			ld a, (.dmark+1)  
697a 32 6f fe			ld (debug_mark+1),a  
697d 3a 87 69			ld a, (.dmark+2)  
6980 32 70 fe			ld (debug_mark+2),a  
6983 18 03			jr .pastdmark  
6985 ..			.dmark: db "ASl"  
6988 f1			.pastdmark: pop af  
6989			endm  
# End of macro DMARK
6989						CALLMONITOR 
6989 cd ab 18			call break_point_state  
698c				endm  
# End of macro CALLMONITOR
698c					endif 
698c cd 2d 09				call storage_read 
698f cd 2d 0f			call ishlzero 
6992 c8				ret z 
6993			;	jr z, .autoend 
6993			 
6993					if DEBUG_FORTH_WORDS 
6993						DMARK "ASc" 
6993 f5				push af  
6994 3a a8 69			ld a, (.dmark)  
6997 32 6e fe			ld (debug_mark),a  
699a 3a a9 69			ld a, (.dmark+1)  
699d 32 6f fe			ld (debug_mark+1),a  
69a0 3a aa 69			ld a, (.dmark+2)  
69a3 32 70 fe			ld (debug_mark+2),a  
69a6 18 03			jr .pastdmark  
69a8 ..			.dmark: db "ASc"  
69ab f1			.pastdmark: pop af  
69ac			endm  
# End of macro DMARK
69ac						CALLMONITOR 
69ac cd ab 18			call break_point_state  
69af				endm  
# End of macro CALLMONITOR
69af					endif 
69af 11 83 fa			ld de, store_page+2 
69b2 3e 78			ld a, display_row_4 
69b4 cd e3 0c			call str_at_display 
69b7			 
69b7 cd f3 0c			call update_display 
69ba cd 41 0c			call delay250ms 
69bd			 
69bd			 
69bd			 
69bd 21 83 fa			ld hl, store_page+2 
69c0 cd db 22			call forthparse 
69c3 cd 1b 23			call forthexec 
69c6 cd 2d 22			call forthexec_cleanup 
69c9			 
69c9				 
69c9 3a 71 fa			ld a, (store_openext) 
69cc 3c				inc a 
69cd 32 71 fa			ld (store_openext), a    ; save count of ext 
69d0			 
69d0 18 96			jr .autof 
69d2			;.autofdone: 
69d2			; 
69d2			;		if DEBUG_FORTH_WORDS 
69d2			;			DMARK "ASx" 
69d2			;			CALLMONITOR 
69d2			;		endif 
69d2			;;	call clear_display 
69d2			;	ret 
69d2			 
69d2			 
69d2			 
69d2			endif 
69d2			 
69d2			 
69d2			; eof 
# End of file forth_kernel.asm
69d2			;include "nascombasic.asm" 
69d2			 
69d2			 
69d2			; find out where the code ends if loaded into RAM (for SC114) 
69d2			;endofcode:  
69d2			;	nop 
69d2			 
69d2			 
69d2			; eof 
69d2			 
# End of file main.asm
69d2			include "firmware_lcd_4x40.asm" 
69d2			; **********************************************************************  
69d2			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
69d2			; **********************************************************************  
69d2			;  
69d2			; **  Written as a Small Computer Monitor App  
69d2			; **  www.scc.me.uk  
69d2			;  
69d2			; History  
69d2			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
69d2			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
69d2			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
69d2			;  
69d2			; **********************************************************************  
69d2			;  
69d2			; This program is an example of one of the methods of interfacing an   
69d2			; alphanumeric LCD module.   
69d2			;  
69d2			; In this example the display is connected to either a Z80 PIO or a   
69d2			; simple 8-bit output port.   
69d2			;  
69d2			; This interfacing method uses 4-bit data mode and uses time delays  
69d2			; rather than polling the display's ready status. As a result the   
69d2			; interface only requires 6 simple output lines:  
69d2			;   Output bit 0 = not used  
69d2			;   Output bit 1 = not used  
69d2			;   Output bit 2 = RS         High = data, Low = instruction  
69d2			;   Output bit 3 = E          Active high  
69d2			;   Output bit 4 = DB4  
69d2			;   Output bit 5 = DB5  
69d2			;   Output bit 6 = DB6  
69d2			;   Output bit 7 = DB7  
69d2			; Display's R/W is connected to 0v so it is always in write mode  
69d2			;  
69d2			; This set up should work with any system supporting the RC2014 bus  
69d2			  
69d2			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
69d2			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
69d2			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
69d2			;  
69d2			; **********************************************************************  
69d2			  
69d2			; Additonal for 4x40. E1 and E2 instead of just E   
69d2			; TODO swipe vidout signal on port a to activate E2  
69d2			  
69d2			; **********************************************************************  
69d2			; **  Constants  
69d2			; **********************************************************************  
69d2			; LCD constants required by LCD support module  
69d2			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
69d2			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
69d2			kLCDBitE:   EQU 3              ;Port bit for LCD E signal             
69d2			kLCDBitE2:   EQU 0              ;Port bit for LCD E2 signal            VIDOUT  
69d2			; TODO Decide which E is being set  
69d2			kLCDWidth:  EQU display_cols             ;Width in characters  
69d2			  
69d2			; **********************************************************************  
69d2			; **  Code library usage  
69d2			; **********************************************************************  
69d2			  
69d2			; send character to current cursor position  
69d2			; wraps and/or scrolls screen automatically  
69d2			  
69d2			  
69d2			  
69d2			lcd_init:  
69d2			  
69d2			; SCMonAPI functions used  
69d2			  
69d2			; Alphanumeric LCD functions used  
69d2			; no need to specify specific functions for this module  
69d2			  
69d2 3e cf		            LD   A, 11001111b  
69d4 d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
69d6 3e 00		            LD   A, 00000000b  
69d8 d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
69da			  
69da			; Initialise alphanumeric LCD module  
69da 3e 00				ld a, 0  
69dc 32 ce fb				ld (display_lcde1e2), a  
69df cd 60 6a		            CALL fLCD_Init      ;Initialise LCD module  
69e2 3e 01				ld a, 1  
69e4 32 ce fb				ld (display_lcde1e2), a  
69e7 cd 60 6a		            CALL fLCD_Init      ;Initialise LCD module  
69ea			  
69ea c9				ret  
69eb			  
69eb			;  
69eb			;;  
69eb			; lcd functions  
69eb			;  
69eb			;  
69eb			  
69eb			; what is at cursor position   
69eb			  
69eb			;get_cursor:	ld de, (cursor_row)   ;  row + col  
69eb			;		call curptr  
69eb			;		ret  
69eb			  
69eb			  
69eb			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
69eb			  
69eb			curptr:  
69eb c5				push bc  
69ec 21 b4 fd			ld hl, display_fb0  
69ef			cpr:	  
69ef				; loop for cursor whole row  
69ef 0e 28			ld c, display_cols  
69f1 23			cpr1:	inc hl  
69f2 0d				dec c  
69f3 20 fc			jr nz, cpr1  
69f5 05				dec b  
69f6 20 f7			jr nz, cpr  
69f8			  
69f8				; add col	  
69f8			  
69f8 23			cpr2:	inc hl  
69f9 1d				dec e  
69fa 20 fc			jr nz, cpr2  
69fc			  
69fc c1				pop bc  
69fd c9				ret  
69fe				  
69fe			  
69fe			  
69fe			  
69fe			  
69fe			; write the frame buffer given in hl to hardware   
69fe 22 cc fb		write_display: ld (display_write_tmp), hl 	   
6a01 3e 00			ld a, kLCD_Line1  
6a03 cd 0d 6b		            CALL fLCD_Pos       ;Position cursor to location in A  
6a06 06 28			ld b, display_cols  
6a08 ed 5b cc fb		ld de, (display_write_tmp)  
6a0c cd 58 6a			call write_len_string  
6a0f				  
6a0f				  
6a0f 2a cc fb			ld hl, (display_write_tmp)  
6a12 11 28 00			ld de, display_cols  
6a15 19				add hl,de  
6a16 22 cc fb			ld (display_write_tmp),hl  
6a19			  
6a19				  
6a19 3e 28			ld a, kLCD_Line2  
6a1b cd 0d 6b		            CALL fLCD_Pos       ;Position cursor to location in A  
6a1e 06 28			ld b, display_cols  
6a20 ed 5b cc fb		ld de, (display_write_tmp)  
6a24 cd 58 6a			call write_len_string  
6a27				  
6a27 2a cc fb			ld hl, (display_write_tmp)  
6a2a 11 28 00			ld de, display_cols  
6a2d 19				add hl,de  
6a2e 22 cc fb			ld (display_write_tmp),hl  
6a31			  
6a31				  
6a31 3e 50			ld a, kLCD_Line3  
6a33 cd 0d 6b		            CALL fLCD_Pos       ;Position cursor to location in A  
6a36 06 28			ld b, display_cols  
6a38 ed 5b cc fb		ld de, (display_write_tmp)  
6a3c cd 58 6a			call write_len_string  
6a3f				  
6a3f 2a cc fb			ld hl, (display_write_tmp)  
6a42 11 28 00			ld de, display_cols  
6a45 19				add hl,de  
6a46 22 cc fb			ld (display_write_tmp),hl  
6a49			  
6a49				  
6a49 3e 78			ld a, kLCD_Line4  
6a4b cd 0d 6b		            CALL fLCD_Pos       ;Position cursor to location in A  
6a4e 06 28			ld b, display_cols  
6a50 ed 5b cc fb		ld de, (display_write_tmp)  
6a54 cd 58 6a			call write_len_string  
6a57 c9					ret  
6a58				  
6a58				; write out a fixed length string given in b from de  
6a58			  
6a58 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
6a59 cd c5 6a		            CALL fLCD_Data      ;Write character to display  
6a5c 13				inc de  
6a5d 10 f9			djnz write_len_string  
6a5f c9				ret  
6a60			  
6a60			; Some other things to do  
6a60			;            LD   A, kLCD_Clear ;Display clear  
6a60			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
6a60			;            LD   A, kLCD_Under ;Display on with underscore cursor  
6a60			;            LD   A, kLCD_On     ;Display on with no cursor  
6a60			;            ;LD   A, kLCD_Off   ;Display off  
6a60			;            CALL fLCD_Inst      ;Send instruction to display  
6a60			;  
6a60			;  
6a60			;            halt  
6a60			;  
6a60			;  
6a60			;MsgHello:   DB  "Hello World!",0  
6a60			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
6a60			  
6a60			; Custom characters 5 pixels wide by 8 pixels high  
6a60			; Up to 8 custom characters can be defined  
6a60			;BitMaps:      
6a60			;; Character 0x00 = Battery icon  
6a60			;            DB  01110b  
6a60			;            DB  11011b  
6a60			;            DB  10001b  
6a60			;            DB  10001b  
6a60			;            DB  11111b  
6a60			;            DB  11111b  
6a60			;            DB  11111b  
6a60			;            DB  11111b  
6a60			;; Character 0x01 = Bluetooth icon  
6a60			;            DB  01100b  
6a60			;            DB  01010b  
6a60			;            DB  11100b  
6a60			;            DB  01000b  
6a60			;            DB  11100b  
6a60			;            DB  01010b  
6a60			;            DB  01100b  
6a60			;            DB  00000b  
6a60			;  
6a60			  
6a60			  
6a60			; **********************************************************************  
6a60			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
6a60			; **********************************************************************  
6a60			;  
6a60			; **  Written as a Small Computer Monitor App   
6a60			; **  Version 0.1 SCC 2018-05-16  
6a60			; **  www.scc.me.uk  
6a60			;  
6a60			; **********************************************************************  
6a60			;  
6a60			; This module provides support for alphanumeric LCD modules using with  
6a60			; *  HD44780 (or compatible) controller  
6a60			; *  5 x 7 pixel fonts  
6a60			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
6a60			; *  Interface via six digital outputs to the display (see below)  
6a60			;  
6a60			; LCD module pinout:  
6a60			;   1  Vss   0v supply  
6a60			;   2  Vdd   5v supply  
6a60			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
6a60			;   4  RS    High = data, Low = instruction  
6a60			;   5  R/W   High = Read, Low = Write  
6a60			;   6  E     Enable signal (active high)  
6a60			;   7  DB0   Data bit 0  
6a60			;   8  DB1   Data bit 1  
6a60			;   9  DB2   Data bit 2  
6a60			;  10  DB3   Data bit 3  
6a60			;  11  DB4   Data bit 4  
6a60			;  12  DB5   Data bit 5  
6a60			;  13  DB6   Data bit 6  
6a60			;  14  DB7   Data bit 7  
6a60			;  15  A     Backlight anode (+)  
6a60			;  16  K     Backlight cathode (-)  
6a60			;  
6a60			; This interfacing method uses 4-bit data mode and uses time delays  
6a60			; rather than polling the display's ready status. As a result the   
6a60			; interface only requires 6 simple output lines:  
6a60			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
6a60			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
6a60			;   LCD DB4 = Microcomputer output port bit 4  
6a60			;   LCD DB5 = Microcomputer output port bit 5  
6a60			;   LCD DB6 = Microcomputer output port bit 6  
6a60			;   LCD DB7 = Microcomputer output port bit 7  
6a60			; Display's R/W is connected to 0v so it is always in write mode  
6a60			; All 6 connections must be on the same port address <kLCDPrt>  
6a60			; This method also allows a decent length of cable from micro to LCD  
6a60			;  
6a60			; **********************************************************************  
6a60			;  
6a60			; To include the code for any given function provided by this module,   
6a60			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
6a60			; the parent source file.  
6a60			; For example:  #REQUIRES   uHexPrefix  
6a60			;  
6a60			; Also #INCLUDE this file at some point after the #REQUIRES statements  
6a60			; in the parent source file.  
6a60			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
6a60			;  
6a60			; These are the function names provided by this module:  
6a60			; fLCD_Init                     ;Initialise LCD  
6a60			; fLCD_Inst                     ;Send instruction to LCD  
6a60			; fLCD_Data                     ;Send data byte to LCD  
6a60			; fLCD_Pos                      ;Position cursor  
6a60			; fLCD_Str                      ;Display string  
6a60			; fLCD_Def                      ;Define custom character  
6a60			;  
6a60			; **********************************************************************  
6a60			;  
6a60			; Requires SCMonAPI.asm to also be included in the project  
6a60			;  
6a60			  
6a60			  
6a60			; **********************************************************************  
6a60			; **  Constants  
6a60			; **********************************************************************  
6a60			  
6a60			; Constants that must be defined externally  
6a60			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
6a60			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
6a60			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
6a60			;kLCDWidth: EQU 20             ;Width in characters  
6a60			  
6a60			; general line offsets in any frame buffer  
6a60			  
6a60			  
6a60			display_row_1: equ 0  
6a60			display_row_2: equ display_row_1+display_cols  
6a60			display_row_3: equ display_row_2 + display_cols  
6a60			display_row_4: equ display_row_3 + display_cols  
6a60			;display_row_4_eol:   
6a60			  
6a60			  
6a60			; Cursor position values for the start of each line  
6a60			  
6a60			; E  
6a60			kLCD_Line1: EQU 0x00   
6a60			kLCD_Line2: EQU kLCD_Line1+kLCDWidth  
6a60			; E1  
6a60			kLCD_Line3: EQU kLCD_Line2+kLCDWidth  
6a60			kLCD_Line4: EQU kLCD_Line3+kLCDWidth   
6a60			  
6a60			; Instructions to send as A register to fLCD_Inst  
6a60			kLCD_Clear: EQU 00000001b     ;LCD clear  
6a60			kLCD_Off:   EQU 00001000b     ;LCD off  
6a60			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
6a60			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
6a60			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
6a60			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
6a60			  
6a60			; Constants used by this code module  
6a60			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
6a60			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
6a60			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
6a60			  
6a60			  
6a60			  
6a60			; **********************************************************************  
6a60			; **  LCD support functions  
6a60			; **********************************************************************  
6a60			  
6a60			; Initialise alphanumeric LCD module  
6a60			; LCD control register codes:  
6a60			;   DL   0 = 4-bit mode        1 = 8-bit mode  
6a60			;   N    0 = 1-line mode       1 = 2-line mode  
6a60			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
6a60			;   D    0 = Display off       1 = Display on  
6a60			;   C    0 = Cursor off        1 = Cursor on  
6a60			;   B    0 = Blinking off      1 = Blinking on  
6a60			;   ID   0 = Decrement mode    1 = Increment mode  
6a60			;   SH   0 = Entire shift off  1 = Entire shift on  
6a60 3e 28		fLCD_Init:  LD   A, 40  
6a62 cd 87 6b		            CALL LCDDelay       ;Delay 40ms after power up  
6a65			; For reliable reset set 8-bit mode - 3 times  
6a65 cd 57 6b		            CALL WrFn8bit       ;Function = 8-bit mode  
6a68 cd 57 6b		            CALL WrFn8bit       ;Function = 8-bit mode  
6a6b cd 57 6b		            CALL WrFn8bit       ;Function = 8-bit mode  
6a6e			; Set 4-bit mode  
6a6e cd 53 6b		            CALL WrFn4bit       ;Function = 4-bit mode  
6a71 cd 85 6b		            CALL LCDDelay1      ;Delay 37 us or more  
6a74			; Function set  
6a74 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
6a76 cd 89 6a		            CALL fLCD_Inst      ;2 line, display on  
6a79			; Display On/Off control  
6a79 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
6a7b cd 89 6a		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
6a7e			; Display Clear  
6a7e 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
6a80 cd 89 6a		            CALL fLCD_Inst      ;Clear display  
6a83			; Entry mode  
6a83 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
6a85 cd 89 6a		            CALL fLCD_Inst      ;Increment mode, shift off  
6a88			; Display module now initialised  
6a88 c9			            RET  
6a89			; ok to here  
6a89			  
6a89			; Write instruction to LCD  
6a89			;   On entry: A = Instruction byte to be written  
6a89			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6a89 f5			fLCD_Inst:  PUSH AF  
6a8a f5			            PUSH AF  
6a8b cd 9d 6a		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
6a8e f1			            POP  AF  
6a8f 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
6a90 17			            RLA  
6a91 17			            RLA  
6a92 17			            RLA  
6a93 cd 9d 6a		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
6a96 3e 02		            LD   A, 2  
6a98 cd 87 6b		            CALL LCDDelay       ;Delay 2 ms to complete   
6a9b f1			            POP  AF  
6a9c c9			            RET  
6a9d			Wr4bits:   
6a9d f5					push af  
6a9e 3a ce fb				ld a, (display_lcde1e2)  
6aa1 fe 00				cp 0     ; e  
6aa3 20 10				jr nz, .wea2	  
6aa5 f1					pop af  
6aa6 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
6aa8 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6aaa cb df		            SET  kLCDBitE, A	    ; TODO decide which E is being set  
6aac cb 87		            res  kLCDBitE2, A	    ; TODO decide which E is being set  
6aae d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6ab0 cb 9f		            RES  kLCDBitE, A        ; TODO decide which E is being set  
6ab2 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6ab4 c9			            RET  
6ab5 f1			.wea2:		pop af  
6ab6 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
6ab8 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6aba cb c7		            SET  kLCDBitE2, A	    ; TODO decide which E is being set  
6abc cb 9f		            res  kLCDBitE, A	    ; TODO decide which E is being set  
6abe d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6ac0 cb 87		            RES  kLCDBitE2, A        ; TODO decide which E is being set  
6ac2 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6ac4 c9			            RET  
6ac5			  
6ac5			  
6ac5			; Write data to LCD  
6ac5			;   On entry: A = Data byte to be written  
6ac5			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6ac5 f5			fLCD_Data:  PUSH AF  
6ac6 f5			            PUSH AF  
6ac7 cd d9 6a		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
6aca f1			            POP  AF  
6acb 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
6acc 17			            RLA  
6acd 17			            RLA  
6ace 17			            RLA  
6acf cd d9 6a		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
6ad2 3e 96		            LD   A, 150  
6ad4 3d			Wait:      DEC  A              ;Wait a while to allow data   
6ad5 20 fd		            JR   NZ, Wait      ;  write to complete  
6ad7 f1			            POP  AF  
6ad8 c9			            RET  
6ad9			Wr4bitsa:     
6ad9 f5					push af  
6ada 3a ce fb				ld a, (display_lcde1e2)  
6add fe 00				cp 0     ; e1  
6adf 20 16				jr nz, .we2	  
6ae1 f1					pop af  
6ae2 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
6ae4 cb d7		            SET  kLCDBitRS, A  
6ae6 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
6ae8 cb df		            SET  kLCDBitE, A      ; TODO Decide which E is being set  
6aea cb 87		            res  kLCDBitE2, A      ; TODO Decide which E is being set  
6aec d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
6aee cb 9f		            RES  kLCDBitE, A       ; TODO Decide which E is being set  
6af0 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
6af2 cb 97		            RES  kLCDBitRS, A  
6af4 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6af6 c9			            RET  
6af7 f1			.we2:		pop af  
6af8 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
6afa cb d7		            SET  kLCDBitRS, A  
6afc d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
6afe cb c7		            SET  kLCDBitE2, A      ; TODO Decide which E is being set  
6b00 cb 9f		            res  kLCDBitE, A      ; TODO Decide which E is being set  
6b02 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
6b04 cb 87		            RES  kLCDBitE2, A       ; TODO Decide which E is being set  
6b06 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
6b08 cb 97		            RES  kLCDBitRS, A  
6b0a d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6b0c c9			            RET  
6b0d			  
6b0d			  
6b0d			; Position cursor to specified location  
6b0d			;   On entry: A = Cursor position  
6b0d			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6b0d f5			fLCD_Pos:   PUSH AF  
6b0e					; at this point set the E1 or E2 flag depending on position  
6b0e			  
6b0e c5					push bc  
6b0f			;		push af  
6b0f 06 00				ld b, 0  
6b11 4f					ld c, a  
6b12 3e 4f				ld a, kLCD_Line3-1  
6b14 b7			 		or a      ;clear carry flag  
6b15 99					sbc a,c    ; TODO may need to sub 80 from a to put in context of current frame    
6b16 38 04				jr c, .pe1  
6b18			  
6b18					; E selection  
6b18 cb 80				res 0, b         ; bit 0 unset e  
6b1a			;		pop af    ; before line 3 so recover orig pos  
6b1a			;		ld c, a    ; save for poking back  
6b1a 18 06				jr .peset	          
6b1c			.pe1:          	; E2 selection  
6b1c cb c0				set 0, b         ; bit 0 set e1  
6b1e 79					ld a, c  
6b1f de 4f				sbc a, kLCD_Line3-1  
6b21 4f					ld c, a	         ; save caculated offset  
6b22			;		pop af     ; bin this original value now we have calculated form  
6b22			  
6b22			.peset:		; set bit  
6b22 78					ld a, b  
6b23 32 ce fb				ld (display_lcde1e2), a 	  
6b26 79					ld a, c  
6b27 c1					pop bc  
6b28			  
6b28 f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
6b2a cd 89 6a		            CALL fLCD_Inst      ;Write instruction to LCD  
6b2d f1			            POP  AF  
6b2e c9			            RET  
6b2f			  
6b2f			  
6b2f			; Output text string to LCD  
6b2f			;   On entry: DE = Pointer to null terminated text string  
6b2f			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
6b2f 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
6b30 b7			            OR   A              ;Null terminator?  
6b31 c8			            RET  Z              ;Yes, so finished  
6b32 cd c5 6a		            CALL fLCD_Data      ;Write character to display  
6b35 13			            INC  DE             ;Point to next character  
6b36 18 f7		            JR   fLCD_Str       ;Repeat  
6b38 c9					ret  
6b39			  
6b39			; Define custom character  
6b39			;   On entry: A = Character number (0 to 7)  
6b39			;             DE = Pointer to character bitmap data  
6b39			;   On exit:  A = Next character number  
6b39			;             DE = Next location following bitmap  
6b39			;             BC HL IX IY I AF' BC' DE' HL' preserved  
6b39			; Character is   
6b39 c5			fLCD_Def:   PUSH BC  
6b3a f5			            PUSH AF  
6b3b 07			            RLCA                ;Calculate location  
6b3c 07			            RLCA                ;  for bitmap data  
6b3d 07			            RLCA                ;  = 8 x CharacterNumber  
6b3e f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
6b40 cd 89 6a		            CALL fLCD_Inst      ;Write instruction to LCD  
6b43 06 00		            LD   B, 0  
6b45 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
6b46 cd c5 6a		            CALL fLCD_Data      ;Write byte to display  
6b49 13			            INC  DE             ;Point to next byte  
6b4a 04			            INC  B              ;Count bytes  
6b4b cb 58		            BIT  3, B           ;Finish all 8 bytes?  
6b4d 28 f6		            JR   Z, Loop       ;No, so repeat  
6b4f f1			            POP  AF  
6b50 3c			            INC  A              ;Increment character number  
6b51 c1			            POP  BC  
6b52 c9			            RET  
6b53			  
6b53			  
6b53			; **********************************************************************  
6b53			; **  Private functions  
6b53			; **********************************************************************  
6b53			  
6b53			; Write function to LCD  
6b53			;   On entry: A = Function byte to be written  
6b53			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6b53 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
6b55 18 02		            JR   WrFunc  
6b57 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
6b59 f5			WrFunc:     PUSH AF  
6b5a f5					push af  
6b5b 3a ce fb				ld a, (display_lcde1e2)  
6b5e fe 00				cp 0     ; e1  
6b60 20 0f				jr nz, .wfea2	  
6b62 f1					pop af  
6b63 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6b65 cb df		            SET  kLCDBitE, A     ; TODO Decide which E is being set  
6b67 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
6b69 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6b6b cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
6b6d d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6b6f 18 0d			jr .wfskip  
6b71 f1			.wfea2:		pop af  
6b72 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6b74 cb c7		            SET  kLCDBitE2, A     ; TODO Decide which E is being set  
6b76 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
6b78 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6b7a cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
6b7c d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6b7e 3e 05		.wfskip:            LD  A, 5  
6b80 cd 87 6b		            CALL LCDDelay       ;Delay 5 ms to complete  
6b83 f1			            POP  AF  
6b84 c9			            RET  
6b85			  
6b85			  
6b85			; Delay in milliseconds  
6b85			;   On entry: A = Number of milliseconds delay  
6b85			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6b85 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
6b87 d5			LCDDelay:   PUSH DE  
6b88 5f			            LD   E, A           ;Delay by 'A' ms  
6b89 16 00		            LD   D, 0  
6b8b cd 32 0c		            CALL aDelayInMS  
6b8e d1			            POP  DE  
6b8f c9			            RET  
6b90			  
6b90			  
6b90			testlcd:  
6b90 3e 00			ld a, kLCD_Line1  
6b92 cd 0d 6b			call fLCD_Pos  
6b95 06 28			ld b, 40  
6b97 11 c5 6b			ld de, .ttext1  
6b9a cd 58 6a			call write_len_string  
6b9d			  
6b9d 3e 28			ld a, kLCD_Line2  
6b9f cd 0d 6b			call fLCD_Pos  
6ba2 06 28			ld b, 40  
6ba4 11 ee 6b			ld de, .ttext2  
6ba7 cd 58 6a			call write_len_string  
6baa 3e 50			ld a, kLCD_Line3  
6bac cd 0d 6b			call fLCD_Pos  
6baf 06 28			ld b, 40  
6bb1 11 17 6c			ld de, .ttext3  
6bb4 cd 58 6a			call write_len_string  
6bb7 3e 78			ld a, kLCD_Line4  
6bb9 cd 0d 6b			call fLCD_Pos  
6bbc 06 28			ld b, 40  
6bbe 11 40 6c			ld de, .ttext4  
6bc1 cd 58 6a			call write_len_string  
6bc4			  
6bc4 76				halt  
6bc5			  
6bc5			  
6bc5 .. 00		.ttext1: db "A234567890123456789012345678901234567890",0  
6bee .. 00		.ttext2: db "B234567890123456789012345678901234567890",0  
6c17 .. 00		.ttext3: db "C234567890123456789012345678901234567890",0  
6c40 .. 00		.ttext4: db "D234567890123456789012345678901234567890",0  
6c69			   
6c69			  
6c69			  
6c69			; eof  
6c69			  
# End of file firmware_lcd_4x40.asm
6c69			;include "firmware_lcd_4x20.asm" 
6c69			include "firmware_key_5x10.asm" 
6c69			; 5 x 10 decade counter scanner  
6c69			  
6c69			  
6c69			; TODO do cursor shape change for shift keys  
6c69			; TODO hard coded positions for the shift keys. Change to work like 4x4 and detect and then hide them  
6c69			  
6c69			  
6c69			; bit mask for each scan column and row for teing the matrix  
6c69			  
6c69			  
6c69			key_init:  
6c69			  
6c69			; SCMonAPI functions used  
6c69			  
6c69			; Alphanumeric LCD functions used  
6c69			; no need to specify specific functions for this module  
6c69			  
6c69			  
6c69 3e cf		            LD   A, 11001111b  
6c6b d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
6c6d			;            LD   A, 00000000b  
6c6d 3e 1f		            LD   A, 00011111b  
6c6f d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
6c71			  
6c71			  
6c71				; TODO Configure cursor shapes  
6c71			  
6c71				; Load cursor shapes   
6c71 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
6c73 11 83 6c		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
6c76 06 02		            LD   B, 2           ;Number of characters to define  
6c78 cd 39 6b		.DefLoop:   CALL fLCD_Def       ;Define custom character  
6c7b 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
6c7d			  
6c7d 3e 01				ld a, 1  
6c7f 32 c7 fb			ld (cursor_shape),a  
6c82 c9				ret  
6c83			  
6c83			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
6c83			; Up to 8 custom characters can be defined  
6c83			.cursor_shapes:      
6c83			;; Character 0x00 = Normal  
6c83 1f			            DB  11111b  
6c84 1f			            DB  11111b  
6c85 1f			            DB  11111b  
6c86 1f			            DB  11111b  
6c87 1f			            DB  11111b  
6c88 1f			            DB  11111b  
6c89 1f			            DB  11111b  
6c8a 1f			            DB  11111b  
6c8b			;; Character 0x01 = Modifier  
6c8b 1f			            DB  11111b  
6c8c 1b			            DB  11011b  
6c8d 1b			            DB  11011b  
6c8e 1b			            DB  11011b  
6c8f 1b			            DB  11011b  
6c90 1f			            DB  11111b  
6c91 1b			            DB  11011b  
6c92 1f			            DB  11111b  
6c93			  
6c93			  
6c93			  
6c93			  
6c93			; Display custom character 0  
6c93			;            LD   A, kLCD_Line1+14  
6c93			;            CALL fLCD_Pos       ;Position cursor to location in A  
6c93			;            LD   A, 0  
6c93			;            CALL fLCD_Data      ;Write character in A at cursor  
6c93			  
6c93			; Display custom character 1  
6c93			;            LD   A, kLCD_Line2+14  
6c93			;            CALL fLCD_Pos      ;Position cursor to location in A  
6c93			;            LD   A, 1  
6c93			;            CALL fLCD_Data     ;Write character in A at cursor  
6c93			  
6c93			; keyboard scanning   
6c93			  
6c93			; character in from keyboard  
6c93			  
6c93			; mapping for the pcb layout  
6c93			  
6c93			.matrix_to_char:  
6c93 .. 08 05 0a 00			db "1357890",KEY_BS,KEY_UP,KEY_DOWN,0  
6c9e .. 0b 0c 00			db "qweryiop",KEY_LEFT,KEY_RIGHT,0  
6ca9 7e .. 0d 00			db KEY_SYMBOLSHIFT,"asdfghjk",KEY_CR,0  
6cb4 7e .. 7e 00			db KEY_SHIFT,"zxcvbnm ",KEY_SHIFT,0  
6cbf .. 10 11 12 .. 13 00			db "246tu",KEY_F1,KEY_F2,KEY_F3,"l",KEY_F4,0  
6cca			.matrix_to_shift:  
6cca			  
6cca .. 08 05 0a 00			db "!#%&*()",KEY_BS,KEY_UP,KEY_DOWN,0  
6cd5 .. 07 06 00			db "QWERYIOP",KEY_PREVWORD,KEY_NEXTWORD,0  
6ce0 7e .. 0d 00			db KEY_SYMBOLSHIFT,"ASDFGHJK",KEY_CR,0  
6ceb 7e .. 7e 00			db KEY_SHIFT,"ZXCVBNM|",KEY_SHIFT,0  
6cf6 .. .. 14 15 16 .. 17 00			db '"',"$^TU",KEY_F5,KEY_F6,KEY_F7,"L",KEY_F8,0  
6d01			  
6d01			.matrix_to_symbolshift:  
6d01			  
6d01 fc ed .. f7 08 05 0a 00			db 252,237,"5789",247,KEY_BS,KEY_UP,KEY_DOWN,0  
6d0c .. b0 0e 0f 00			db "-+/=_?~",176,KEY_HOME,KEY_END,0  
6d17 7e .. a5 7c db ff 0d 00			db KEY_SYMBOLSHIFT,"[]{}",165,124,219,255,KEY_CR,0  
6d22			;		db KEY_SHIFT,"<>,.:;'\\",KEY_SHIFT,0  
6d22 7e .. 5c 7e 00	    	 	db KEY_SHIFT,"<>,.:;'",92, KEY_SHIFT,0  
6d2d .. f6 eb 7d 7e 18 19 1a df 1b 00			db "@",246,235,125,126,KEY_F9,KEY_F10,KEY_F11,223,KEY_F12,0  
6d38			  
6d38			  
6d38			  
6d38			; mapping for a simple straight through breadboard layout  
6d38			  
6d38			;.matrix_to_char:  
6d38			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
6d38			;		db KEY_SHIFT,"zxcvbnm ",KEY_SYMBOLSHIFT,0  
6d38			;		db "asdfghjkl",KEY_CR,0  
6d38			;		db "qwertyuiop",0  
6d38			;		 db "1234567890",0  
6d38			;.matrix_to_shift:  
6d38			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_HOME, KEY_END,0  
6d38			;		db KEY_SHIFT,"ZXCVBNM",KEY_BS,KEY_SYMBOLSHIFT,0  
6d38			;		db "ASDFGHJKL",KEY_CR,0  
6d38			;		db "QWERTYUIOP",0  
6d38			;		 db "!",'"',"#$%^&*()",0  
6d38			;.matrix_to_symbolshift:  
6d38			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
6d38			;		db KEY_SHIFT,"<>:;b,.",KEY_BS,KEY_SYMBOLSHIFT,0  
6d38			;		db "_?*fghjk=",KEY_CR,0  
6d38			;		db "-/+*[]{}@#",0  
6d38			;		 db "1234567890",0  
6d38			  
6d38			;.matrix_to_char: db "D#0*C987B654A321"  
6d38			  
6d38			  
6d38				  
6d38			  
6d38			; add cin and cin_wait  
6d38			  
6d38 cd 49 6d		cin_wait: 	call cin  
6d3b						if DEBUG_KEYCINWAIT  
6d3b							push af  
6d3b							  
6d3b							ld hl,key_repeat_ct  
6d3b							ld (hl),a  
6d3b							inc hl  
6d3b							call hexout  
6d3b							ld hl,key_repeat_ct+3  
6d3b							ld a,0  
6d3b							ld (hl),a  
6d3b			  
6d3b							    LD   A, kLCD_Line1+11  
6d3b							    CALL fLCD_Pos       ;Position cursor to location in A  
6d3b							    LD   DE, key_repeat_ct  
6d3b							    ;LD   DE, MsgHello  
6d3b							    CALL fLCD_Str       ;Display string pointed to by DE  
6d3b			  
6d3b			  
6d3b			  
6d3b							pop af  
6d3b						endif  
6d3b fe 00			cp 0  
6d3d 28 f9			jr z, cin_wait   ; block until key press  
6d3f			  
6d3f							if DEBUG_KEYCINWAIT  
6d3f								push af  
6d3f			  
6d3f								ld a, 'A'	  
6d3f								ld hl,key_repeat_ct  
6d3f								ld (hl),a  
6d3f								inc hl  
6d3f								ld a,0  
6d3f								ld (hl),a  
6d3f			  
6d3f								    LD   A, kLCD_Line2+11  
6d3f								    CALL fLCD_Pos       ;Position cursor to location in A  
6d3f								    LD   DE, key_repeat_ct  
6d3f								    ;LD   DE, MsgHello  
6d3f								    CALL fLCD_Str       ;Display string pointed to by DE  
6d3f			  
6d3f							call delay500ms  
6d3f			  
6d3f								pop af  
6d3f							endif  
6d3f f5				push af   ; save key pressed  
6d40			  
6d40			.cin_wait1:	  
6d40							if DEBUG_KEYCINWAIT  
6d40								push af  
6d40			  
6d40								ld a, 'b'	  
6d40								ld hl,key_repeat_ct  
6d40								ld (hl),a  
6d40								inc hl  
6d40								ld a,0  
6d40								ld (hl),a  
6d40			  
6d40								    LD   A, kLCD_Line2+11  
6d40								    CALL fLCD_Pos       ;Position cursor to location in A  
6d40								    LD   DE, key_repeat_ct  
6d40								    ;LD   DE, MsgHello  
6d40								    CALL fLCD_Str       ;Display string pointed to by DE  
6d40			  
6d40			  
6d40							call delay500ms  
6d40			  
6d40								pop af  
6d40							endif  
6d40			  
6d40 cd 49 6d		call cin  
6d43 fe 00			cp 0  
6d45 20 f9			jr nz, .cin_wait1  	; wait for key release  
6d47			if DEBUG_KEYCINWAIT  
6d47				push af  
6d47			  
6d47				ld a, '3'	  
6d47				ld hl,key_repeat_ct  
6d47				ld (hl),a  
6d47				inc hl  
6d47				ld a,0  
6d47				ld (hl),a  
6d47			  
6d47			            LD   A, kLCD_Line2+11  
6d47			            CALL fLCD_Pos       ;Position cursor to location in A  
6d47			            LD   DE, key_repeat_ct  
6d47			            ;LD   DE, MsgHello  
6d47			            CALL fLCD_Str       ;Display string pointed to by DE  
6d47			  
6d47			  
6d47			call delay500ms  
6d47			  
6d47				pop af  
6d47			endif  
6d47			  
6d47 f1				pop af   ; get key  
6d48 c9				ret  
6d49			  
6d49			  
6d49 cd 5d 6d		cin: 	call .mtoc  
6d4c			  
6d4c			if DEBUG_KEYCIN  
6d4c				push af  
6d4c				  
6d4c				ld hl,key_repeat_ct  
6d4c				ld (hl),a  
6d4c				inc hl  
6d4c				call hexout  
6d4c				ld hl,key_repeat_ct+3  
6d4c				ld a,0  
6d4c				ld (hl),a  
6d4c			  
6d4c			            LD   A, kLCD_Line3+15  
6d4c			            CALL fLCD_Pos       ;Position cursor to location in A  
6d4c			            LD   DE, key_repeat_ct  
6d4c			            ;LD   DE, MsgHello  
6d4c			            CALL fLCD_Str       ;Display string pointed to by DE  
6d4c			  
6d4c			  
6d4c			call delay500ms  
6d4c			  
6d4c				pop af  
6d4c			endif  
6d4c			  
6d4c			  
6d4c				; no key held  
6d4c fe 00			cp 0  
6d4e c8				ret z  
6d4f			  
6d4f			if DEBUG_KEYCIN  
6d4f				push af  
6d4f			  
6d4f				ld a, '1'	  
6d4f				ld hl,key_repeat_ct  
6d4f				ld (hl),a  
6d4f				inc hl  
6d4f				ld a,0  
6d4f				ld (hl),a  
6d4f			  
6d4f			            LD   A, kLCD_Line4+15  
6d4f			            CALL fLCD_Pos       ;Position cursor to location in A  
6d4f			            LD   DE, key_repeat_ct  
6d4f			            ;LD   DE, MsgHello  
6d4f			            CALL fLCD_Str       ;Display string pointed to by DE  
6d4f			  
6d4f			  
6d4f			call delay500ms  
6d4f			  
6d4f				pop af  
6d4f			endif  
6d4f			  
6d4f				; stop key bounce  
6d4f			  
6d4f 32 88 fe			ld (key_held),a		 ; save it  
6d52 47				ld b, a  
6d53			  
6d53 c5			.cina1:	push bc  
6d54			if DEBUG_KEYCIN  
6d54				push af  
6d54			  
6d54				ld hl,key_repeat_ct  
6d54				inc hl  
6d54				call hexout  
6d54				ld hl,key_repeat_ct+3  
6d54				ld a,0  
6d54				ld (hl),a  
6d54				ld hl,key_repeat_ct  
6d54				ld a, '2'	  
6d54				ld (hl),a  
6d54			  
6d54			            LD   A, kLCD_Line4+15  
6d54			            CALL fLCD_Pos       ;Position cursor to location in A  
6d54			            LD   DE, key_repeat_ct  
6d54			            ;LD   DE, MsgHello  
6d54			            CALL fLCD_Str       ;Display string pointed to by DE  
6d54			  
6d54				pop af  
6d54			endif  
6d54 cd 5d 6d			call .mtoc  
6d57 c1				pop bc  
6d58 b8				cp b  
6d59 28 f8			jr z, .cina1  
6d5b 78				ld a,b		  
6d5c			if DEBUG_KEYCIN  
6d5c				push af  
6d5c			  
6d5c				ld hl,key_repeat_ct  
6d5c				inc hl  
6d5c				call hexout  
6d5c				ld hl,key_repeat_ct+3  
6d5c				ld a,0  
6d5c				ld (hl),a  
6d5c				ld hl,key_repeat_ct  
6d5c				ld a, '3'	  
6d5c				ld (hl),a  
6d5c			  
6d5c			            LD   A, kLCD_Line4+15  
6d5c			            CALL fLCD_Pos       ;Position cursor to location in A  
6d5c			            LD   DE, key_repeat_ct  
6d5c			            ;LD   DE, MsgHello  
6d5c			            CALL fLCD_Str       ;Display string pointed to by DE  
6d5c			  
6d5c				pop af  
6d5c			endif  
6d5c c9				ret  
6d5d			  
6d5d			; detect keyboard modifier key press and apply new overlay to the face key held  
6d5d			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
6d5d			  
6d5d			;.cin_map_modifier:   
6d5d			;	ld a, (hl)  
6d5d			;	and 255  
6d5d			;	ret NZ		; modifier key not flagged  
6d5d			;  
6d5d			;	; get key face  
6d5d			;  
6d5d			;	ld b,(key_face_held)  
6d5d			;  
6d5d			;	ld b, key_cols * key_rows  
6d5d			;  
6d5d			;	push de  
6d5d			;	pop hl  
6d5d			;  
6d5d			;.mmod1: ld a,(hl)   ; get map test  
6d5d			;	cp b  
6d5d			;	jr z, .mmod2  
6d5d			;  
6d5d			;  
6d5d			;  
6d5d			;.mmod2: inc hl    ;   
6d5d			;  
6d5d			;	  
6d5d			;  
6d5d			;	  
6d5d			;  
6d5d			;	ld hl,key_actual_pressed  
6d5d			;	ld (hl),a,  
6d5d			;	ret  
6d5d			  
6d5d			; map matrix key held to char on face of key  
6d5d			  
6d5d			.mtoc:  
6d5d			  
6d5d			; test decade counter strobes  
6d5d			  
6d5d			;.decadetest1:  
6d5d			  
6d5d			; reset counter  
6d5d			;ld a, 128  
6d5d			;out (portbdata),a  
6d5d			  
6d5d			  
6d5d			;ld b, 5  
6d5d			;.dec1:  
6d5d			;ld a, 0  
6d5d			;out (portbdata),a  
6d5d			;call delay1s  
6d5d			  
6d5d			;ld a, 32  
6d5d			;out (portbdata),a  
6d5d			;call delay1s  
6d5d			;call delay1s  
6d5d			;call delay1s  
6d5d			;  
6d5d			;ld a, 64+32  
6d5d			;out (portbdata),a  
6d5d			;call delay1s  
6d5d			;;djnz .dec1  
6d5d			;  
6d5d			;jp .decadetest1  
6d5d			  
6d5d			  
6d5d			  
6d5d			  
6d5d			  
6d5d			  
6d5d			  
6d5d			  
6d5d			  
6d5d			  
6d5d				; scan keyboard matrix and generate raw scan map  
6d5d cd f0 6d			call matrix  
6d60			  
6d60				; reuse c bit 0 left modifer button - ie shift  
6d60			        ; reuse c bit 1 for right modifer button - ie symbol shift  
6d60				; both can be used with their other mappings and if seen together can do extra mappings (forth keywords????)  
6d60			  
6d60 0e 00			ld c, 0  
6d62			  
6d62				; TODO set flags for modifer key presses   
6d62				; TODO do a search for modifer key...  
6d62			  
6d62				;ld hl,keyscan_table_row4  
6d62 21 e7 fe			ld hl,keyscan_table_row2  
6d65			  
6d65 7e				ld a, (hl)  
6d66 fe 23			cp '#'  
6d68 20 07			jr nz, .nextmodcheck  
6d6a cb c1			set 0, c  
6d6c 21 ca 6c			ld hl, .matrix_to_shift  
6d6f 18 21			jr .dokeymap  
6d71				; TODO for now igonre  
6d71			.nextmodcheck:  
6d71 21 dc fe			ld hl,keyscan_table_row3  
6d74			  
6d74 7e				ld a, (hl)  
6d75 fe 23			cp '#'  
6d77 20 07			jr nz, .nextmodcheck2  
6d79 cb c9			set 1, c   
6d7b 21 01 6d			ld hl, .matrix_to_symbolshift  
6d7e 18 12			jr .dokeymap  
6d80			.nextmodcheck2:  
6d80 21 f0 fe			ld hl,keyscan_table_row2+9    ; right shift  
6d83			  
6d83 7e				ld a, (hl)  
6d84 fe 23			cp '#'  
6d86 20 07			jr nz, .donemodcheck  
6d88 cb c9			set 1, c   
6d8a 21 ca 6c			ld hl, .matrix_to_shift  
6d8d 18 03			jr .dokeymap  
6d8f			  
6d8f				; no modifer found so just map to normal keys  
6d8f				; get mtoc map matrix to respective keys  
6d8f			;	ld hl, .matrix_to_char  
6d8f			;	ld hl, .matrix_to_char  
6d8f			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
6d8f			;	ld a, KEY_SHIFT  
6d8f			;	call findchar  
6d8f			;  
6d8f			;	; got offset to key modifer in b  
6d8f			;  
6d8f			;	ld hl,keyscan_table_row5  
6d8f			;  
6d8f			;	ld a,b  
6d8f			;	call addatohl  
6d8f			;	ld a,(hl)  
6d8f			;  
6d8f			;	cp '#'  
6d8f			;	jr nz, .nextmodcheck  
6d8f			;	set 0, c  
6d8f			;	ld hl, .matrix_to_char  
6d8f			;	jr .dokeymap  
6d8f			;	; TODO for now igonre  
6d8f			;.nextmodcheck:  
6d8f			;	ld hl, .matrix_to_symbolshift  
6d8f			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
6d8f			;	ld a, KEY_SYMBOLSHIFT  
6d8f			;	call findchar  
6d8f			;  
6d8f			;  
6d8f			;	; got offset to key modifer in b  
6d8f			;  
6d8f			;	ld hl,keyscan_table_row5  
6d8f			;  
6d8f			;	ld a,b  
6d8f			;	call addatohl  
6d8f			;	ld a,(hl)  
6d8f			;  
6d8f			;	cp '#'  
6d8f			;	jr nz, .donemodcheck  
6d8f			;	set 1, c   
6d8f			;	ld hl, .matrix_to_symbolshift  
6d8f			;	jr .dokeymap  
6d8f			  
6d8f			  
6d8f			  
6d8f			.donemodcheck:  
6d8f				; no modifer found so just map to normal keys  
6d8f				; get mtoc map matrix to respective keys  
6d8f 21 93 6c			ld hl, .matrix_to_char  
6d92			  
6d92			.dokeymap:  
6d92				;ld (key_fa), c   
6d92 cd ab 6d			call .mapkeys  
6d95			  
6d95			  
6d95			if DEBUG_KEY  
6d95			  
6d95			; Display text on first line  
6d95			            LD   A, kLCD_Line1  
6d95			            CALL fLCD_Pos       ;Position cursor to location in A  
6d95			            LD   DE, keyscan_table_row1  
6d95			            ;LD   DE, MsgHello  
6d95			            CALL fLCD_Str       ;Display string pointed to by DE  
6d95			  
6d95			; Display text on second line  
6d95			            LD   A, kLCD_Line2  
6d95			            CALL fLCD_Pos       ;Position cursor to location in A  
6d95			            LD   DE, keyscan_table_row2  
6d95			            CALL fLCD_Str       ;Display string pointed to by DE  
6d95			            LD   A, kLCD_Line3  
6d95			            CALL fLCD_Pos       ;Position cursor to location in A  
6d95			            LD   DE, keyscan_table_row3  
6d95			            CALL fLCD_Str       ;Display string pointed to by DE  
6d95			            LD   A, kLCD_Line4  
6d95			            CALL fLCD_Pos       ;Position cursor to location in A  
6d95			            LD   DE, keyscan_table_row4  
6d95			            CALL fLCD_Str       ;Display string pointed to by DE  
6d95			            LD   A, kLCD_Line1+10  
6d95			            CALL fLCD_Pos       ;Position cursor to location in A  
6d95			            LD   DE, keyscan_table_row5  
6d95			            CALL fLCD_Str       ;Display string pointed to by DE  
6d95			  
6d95				;call delay250ms  
6d95			endif  
6d95			;	jp testkey  
6d95			  
6d95			; get first char reported  
6d95			  
6d95 21 c6 fe			ld hl,keyscan_table_row5  
6d98			  
6d98				;ld b, 46   ; 30 keys to remap + 8 nulls   
6d98 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
6d9a			.findkey:  
6d9a 7e				ld a,(hl)  
6d9b fe 00			cp 0  
6d9d 28 04			jr z, .nextkey  
6d9f fe 7e			cp KEY_MATRIX_NO_PRESS  
6da1 20 06			jr nz, .foundkey  
6da3			.nextkey:  
6da3 23				inc hl  
6da4 10 f4			djnz .findkey  
6da6 3e 00			ld a,0  
6da8 c9				ret  
6da9			.foundkey:  
6da9 7e				ld a,(hl)  
6daa c9				ret  
6dab				  
6dab			  
6dab			; convert the raw key map given hl for destination key  
6dab			.mapkeys:  
6dab 11 c6 fe			ld de,keyscan_table_row5  
6dae			  
6dae 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
6db0			.remap:  
6db0 1a				ld a,(de)  
6db1 fe 23			cp '#'  
6db3 20 02			jr nz, .remapnext  
6db5				;CALLMONITOR  
6db5 7e				ld a,(hl)  
6db6 12				ld (de),a  
6db7			  
6db7			  
6db7			  
6db7			.remapnext:  
6db7 23				inc hl  
6db8 13				inc de  
6db9 10 f5			djnz .remap  
6dbb				  
6dbb c9				ret  
6dbc			  
6dbc			  
6dbc			  
6dbc			.mtocold2:  
6dbc			  
6dbc			;	; flag if key D is held down and remove from reporting  
6dbc			;	ld bc, .key_map_fd    
6dbc			;	ld hl, keyscan_table  
6dbc			;	ld de, key_fd  
6dbc			;	call .key_shift_hold  
6dbc			;	cp 255  
6dbc			;	jr z, .cinmap  
6dbc			;	; flag if key C is held down and remove from reporting  
6dbc			;	ld bc, .key_map_fc    
6dbc			;	ld hl, keyscan_table+key_cols  
6dbc			;	ld de, key_fc  
6dbc			;	call .key_shift_hold  
6dbc			;	cp 255  
6dbc			;	jr z, .cinmap  
6dbc			;	; flag if key B is held down and remove from reporting  
6dbc			;	ld bc, .key_map_fb    
6dbc			;	ld hl, keyscan_table+(key_cols*2)  
6dbc			;	ld de, key_fb  
6dbc			;	call .key_shift_hold  
6dbc			;	cp 255  
6dbc			;	jr z, .cinmap  
6dbc			;	; flag if key A is held down and remove from reporting  
6dbc			;	ld bc, .key_map_fa    
6dbc			;	ld hl, keyscan_table+(key_cols*3)  
6dbc			;	ld de, key_fa  
6dbc			;	call .key_shift_hold  
6dbc			;	cp 255  
6dbc			;	jr z, .cinmap  
6dbc			  
6dbc 11 93 6c			ld de, .matrix_to_char  
6dbf			  
6dbf			  
6dbf			.cinmap1:   
6dbf				if DEBUG_KEY  
6dbf			            LD   A, kLCD_Line4  
6dbf			            CALL fLCD_Pos       ;Position cursor to location in A  
6dbf					push de  
6dbf			            LD   DE, keyscan_table  
6dbf			            CALL fLCD_Str       ;Display string pointed to by DE  
6dbf					pop de  
6dbf				endif  
6dbf			  
6dbf				; scan key matrix table for any held key  
6dbf			  
6dbf				; de holds either the default matrix or one selected above  
6dbf			  
6dbf 21 93 fe			ld hl, keyscan_table  
6dc2 06 32			ld b,key_cols*key_rows  
6dc4			  
6dc4 7e			.cin11:	ld a,(hl)  
6dc5 fe 23			cp '#'  
6dc7 28 08			jr z, .cinhit1  
6dc9 23				inc hl  
6dca 13				inc de  
6dcb 05				dec b  
6dcc 20 f6			jr nz, .cin11  
6dce				; no key found held  
6dce 3e 00			ld a,0  
6dd0 c9				ret  
6dd1 d5			.cinhit1: push de  
6dd2 e1				pop hl  
6dd3 7e				ld a,(hl)  
6dd4 c9				ret  
6dd5			  
6dd5			; flag a control key is held   
6dd5			; hl is key pin, de is flag indicator  
6dd5			  
6dd5			.key_shift_hold1:  
6dd5 c5				push bc  
6dd6 3e 01			ld a, 1  
6dd8 32 c7 fb			ld (cursor_shape),a  
6ddb 06 00			ld b, 0  
6ddd 7e				ld a, (hl)  
6dde fe 2e			cp '.'  
6de0 28 0a			jr z, .key_shift11  
6de2 06 ff			ld b, 255  
6de4 3e 2b			ld a, '+'    ; hide key from later scans  
6de6 77				ld (hl),a  
6de7 3e 02			ld a, 2  
6de9 32 c7 fb			ld (cursor_shape),a  
6dec			.key_shift11:  
6dec				; write flag indicator  
6dec 78				ld a,b  
6ded 12				ld (de),a  
6dee			  
6dee d1				pop de    ; de now holds the key map ptr  
6def c9				ret  
6df0			  
6df0				  
6df0			  
6df0			; scans keyboard matrix and flags key press in memory array	  
6df0				  
6df0			matrix:  
6df0				;call matrix  
6df0				; TODO optimise the code....  
6df0			  
6df0			  
6df0			;ld hl, keyscan_table_row1  
6df0			;ld de, keyscan_table_row1+1  
6df0			;ld bc,46  
6df0			;ld a,KEY_MATRIX_NO_PRESS  
6df0			;ldir  
6df0			  
6df0			  
6df0			  
6df0			; reset counter  
6df0 3e 80		ld a, 128  
6df2 d3 c1		out (portbdata),a  
6df4			  
6df4 06 0a		ld b, 10  
6df6 0e 00		ld c, 0       ; current clock toggle  
6df8			  
6df8			.colscan:  
6df8			  
6df8			; set current column  
6df8			; disable clock enable and set clock low  
6df8			  
6df8			;ld a, 0  
6df8			;out (portbdata),a  
6df8			  
6df8			; For each column scan for switches  
6df8			  
6df8 c5			push bc  
6df9 21 89 fe		ld hl, keyscan_scancol  
6dfc cd 05 6f		call .rowscan  
6dff c1			pop bc  
6e00			  
6e00			  
6e00			; get back current column  
6e00			  
6e00			; translate the row scan  
6e00			  
6e00			;   
6e00			; row 1  
6e00			  
6e00 78			ld a,b  
6e01			  
6e01 21 fc fe		LD   hl, keyscan_table_row1+10  
6e04			  
6e04 cd 16 0f		call subafromhl  
6e07			;call addatohl  
6e07			  
6e07 11 89 fe		ld de, keyscan_scancol  
6e0a			  
6e0a 1a			ld a,(de)  
6e0b 77			ld (hl),a  
6e0c			  
6e0c			  
6e0c			  
6e0c			  
6e0c			; row 2  
6e0c			  
6e0c 78			ld a,b  
6e0d			  
6e0d 21 f1 fe		LD   hl, keyscan_table_row2+10  
6e10			  
6e10			;call addatohl  
6e10 cd 16 0f		call subafromhl  
6e13			  
6e13			  
6e13 11 8a fe		ld de, keyscan_scancol+1  
6e16			  
6e16 1a			ld a,(de)  
6e17 77			ld (hl),a  
6e18			  
6e18			  
6e18			; row 3  
6e18			  
6e18 78			ld a,b  
6e19			  
6e19 21 e6 fe		LD   hl, keyscan_table_row3+10  
6e1c			  
6e1c			;call addatohl  
6e1c cd 16 0f		call subafromhl  
6e1f			  
6e1f 11 8b fe		ld de, keyscan_scancol+2  
6e22			  
6e22 1a			ld a,(de)  
6e23 77			ld (hl),a  
6e24			  
6e24			  
6e24			  
6e24			; row 4  
6e24			  
6e24 78			ld a,b  
6e25			  
6e25 21 db fe		LD   hl, keyscan_table_row4+10  
6e28			  
6e28			;call addatohl  
6e28 cd 16 0f		call subafromhl  
6e2b			  
6e2b 11 8c fe		ld de, keyscan_scancol+3  
6e2e			  
6e2e 1a			ld a,(de)  
6e2f 77			ld (hl),a  
6e30			  
6e30			; row 5  
6e30			  
6e30 78			ld a,b  
6e31			  
6e31 21 d0 fe		LD   hl, keyscan_table_row5+10  
6e34			  
6e34			;call addatohl  
6e34 cd 16 0f		call subafromhl  
6e37			  
6e37 11 8d fe		ld de, keyscan_scancol+4  
6e3a			  
6e3a 1a			ld a,(de)  
6e3b 77			ld (hl),a  
6e3c			  
6e3c			; handshake next column  
6e3c			  
6e3c			  
6e3c 3e 40		ld a, 64  
6e3e d3 c1		out (portbdata),a  
6e40			  
6e40 3e 00		ld a, 0  
6e42 d3 c1		out (portbdata),a  
6e44			  
6e44			; toggle clk and move to next column  
6e44			;ld a, 64  
6e44			;cp c  
6e44			;  
6e44			;jr z, .coltoglow  
6e44			;ld c, a  
6e44			;jr .coltog  
6e44			;.coltoglow:  
6e44			;ld c, 0  
6e44			;.coltog:  
6e44			;ld a, c  
6e44			;out (portbdata),a  
6e44			  
6e44 10 b2		djnz .colscan  
6e46			  
6e46 3e 0a		ld a,10  
6e48 21 f2 fe		LD   hl, keyscan_table_row1  
6e4b cd 04 0f		call addatohl  
6e4e 3e 00		ld a, 0  
6e50 77			ld (hl), a  
6e51			  
6e51			  
6e51 3e 0a		ld a,10  
6e53 21 e7 fe		LD   hl, keyscan_table_row2  
6e56 cd 04 0f		call addatohl  
6e59 3e 00		ld a, 0  
6e5b 77			ld (hl), a  
6e5c			  
6e5c 3e 0a		ld a,10  
6e5e 21 dc fe		LD   hl, keyscan_table_row3  
6e61 cd 04 0f		call addatohl  
6e64 3e 00		ld a, 0  
6e66 77			ld (hl), a  
6e67			  
6e67 3e 0a		ld a,10  
6e69 21 d1 fe		LD   hl, keyscan_table_row4  
6e6c cd 04 0f		call addatohl  
6e6f 3e 00		ld a, 0  
6e71 77			ld (hl), a  
6e72			  
6e72 3e 0a		ld a,10  
6e74 21 c6 fe		LD   hl, keyscan_table_row5  
6e77 cd 04 0f		call addatohl  
6e7a 3e 00		ld a, 0  
6e7c 77			ld (hl), a  
6e7d			  
6e7d			if DEBUG_KEY_MATRIX  
6e7d			  
6e7d			; Display text on first line  
6e7d			            LD   A, kLCD_Line1  
6e7d			            CALL fLCD_Pos       ;Position cursor to location in A  
6e7d			            LD   DE, keyscan_table_row1  
6e7d			            ;LD   DE, MsgHello  
6e7d			            CALL fLCD_Str       ;Display string pointed to by DE  
6e7d			  
6e7d			; Display text on second line  
6e7d			            LD   A, kLCD_Line2  
6e7d			            CALL fLCD_Pos       ;Position cursor to location in A  
6e7d			            LD   DE, keyscan_table_row2  
6e7d			            CALL fLCD_Str       ;Display string pointed to by DE  
6e7d			            LD   A, kLCD_Line3  
6e7d			            CALL fLCD_Pos       ;Position cursor to location in A  
6e7d			            LD   DE, keyscan_table_row3  
6e7d			            CALL fLCD_Str       ;Display string pointed to by DE  
6e7d			            LD   A, kLCD_Line4  
6e7d			            CALL fLCD_Pos       ;Position cursor to location in A  
6e7d			            LD   DE, keyscan_table_row4  
6e7d			            CALL fLCD_Str       ;Display string pointed to by DE  
6e7d			            LD   A, kLCD_Line4+10  
6e7d			            CALL fLCD_Pos       ;Position cursor to location in A  
6e7d			            LD   DE, keyscan_table_row5  
6e7d			            CALL fLCD_Str       ;Display string pointed to by DE  
6e7d			  
6e7d			;call delay250ms  
6e7d				jp matrix  
6e7d			endif  
6e7d c9			ret  
6e7e			  
6e7e			; using decade counter....  
6e7e			  
6e7e			  
6e7e			; TODO reset decade counter to start of scan  
6e7e			  
6e7e			; reset 15  
6e7e			; clock 14  
6e7e			; ce 13  
6e7e			  
6e7e			; 1 - q5  
6e7e			; 2 - q1  
6e7e			; 3 - q0  
6e7e			; 4 - q2  
6e7e			; 5 - q6  
6e7e			; 6 - q7  
6e7e			; 7 - q3  
6e7e			; 8 - vss  
6e7e			; 9 - q8  
6e7e			; 10 - q4  
6e7e			; 11 - q9  
6e7e			; 12 - cout  
6e7e			; 16 - vdd  
6e7e			  
6e7e			; clock      ce       reset     output  
6e7e			; 0          x        0         n  
6e7e			; x          1        0         n  
6e7e			; x          x        1         q0  
6e7e			; rising     0        0         n+1  
6e7e			; falling    x        0         n  
6e7e			; x          rising   0         n  
6e7e			; 1          falling  0         x+1  
6e7e			;  
6e7e			; x = dont care, if n < 5 carry = 1 otherwise 0  
6e7e			  
6e7e			;   
6e7e			; reset   
6e7e			; 13=0, 14=0, 15=1 .. 15=0  
6e7e			;  
6e7e			; handshake line  
6e7e			; 14=1.... read line 14=0  
6e7e			  
6e7e			  
6e7e			  
6e7e			  
6e7e			  
6e7e			; TODO hand shake clock for next column scan  
6e7e			; TODO detect each row  
6e7e			  
6e7e			  
6e7e			  
6e7e			  
6e7e			; reset 128  
6e7e			; clock 64  
6e7e			; ce 32  
6e7e			  
6e7e			  
6e7e			.cyclestart:  
6e7e			  
6e7e			; reset counter  
6e7e 3e 80		ld a, 128  
6e80 d3 c1		out (portbdata),a  
6e82			  
6e82			; loop leds  
6e82 06 0a		ld b,10  
6e84			  
6e84			.cycle1:  
6e84 c5			push bc  
6e85 3e 00		ld a, 0  
6e87 d3 c1		out (portbdata),a  
6e89 cd 41 0c		call delay250ms  
6e8c			  
6e8c 3e 40		ld a, 64  
6e8e d3 c1		out (portbdata),a  
6e90 cd 41 0c		call delay250ms  
6e93			  
6e93 3e 00		ld a, 0  
6e95 d3 c1		out (portbdata),a  
6e97 cd 41 0c		call delay250ms  
6e9a			  
6e9a c1			pop bc  
6e9b 10 e7		djnz .cycle1  
6e9d			  
6e9d			  
6e9d 18 df		jr .cyclestart  
6e9f			  
6e9f			  
6e9f			  
6e9f			  
6e9f			  
6e9f			  
6e9f			  
6e9f			  
6e9f			  
6e9f			; map matrix key held to char on face of key  
6e9f			  
6e9f			;.mtocold:  
6e9f			;  
6e9f			;  
6e9f			;; reset counter  
6e9f			;ld a, 128  
6e9f			;out (portbdata),a  
6e9f			;  
6e9f			;  
6e9f			;; scan keyboard row 1  
6e9f			;ld a, 0  
6e9f			;out (portbdata),a  
6e9f			;;ld a, 64  
6e9f			;;out (portbdata),a  
6e9f			;  
6e9f			;  
6e9f			;	ld a, 128  
6e9f			;	ld hl, keyscan_table  
6e9f			;	call .rowscan  
6e9f			;  
6e9f			;;ld a, 0  
6e9f			;;out (portbdata),a  
6e9f			;ld a, 64  
6e9f			;out (portbdata),a  
6e9f			;  
6e9f			;	ld a, 64  
6e9f			;	ld hl, keyscan_table+key_cols  
6e9f			;	call .rowscan  
6e9f			;  
6e9f			;ld a, 0  
6e9f			;out (portbdata),a  
6e9f			;;ld a, 64  
6e9f			;;out (portbdata),a  
6e9f			;	ld a, 32  
6e9f			;	ld hl, keyscan_table+(key_cols*2)  
6e9f			;	call .rowscan  
6e9f			;  
6e9f			;  
6e9f			;;ld a, 0  
6e9f			;;out (portbdata),a  
6e9f			;ld a, 64  
6e9f			;out (portbdata),a  
6e9f			;  
6e9f			;	ld a, 16  
6e9f			;	ld hl, keyscan_table+(key_cols*3)  
6e9f			;	call .rowscan  
6e9f			;  
6e9f			;  
6e9f			;	; flag if key D is held down and remove from reporting  
6e9f			;	ld bc, .key_map_fd    
6e9f			;	ld hl, keyscan_table  
6e9f			;	ld de, key_fd  
6e9f			;	call .key_shift_hold  
6e9f			;	cp 255  
6e9f			;	jr z, .cinmap  
6e9f			;	; flag if key C is held down and remove from reporting  
6e9f			;	ld bc, .key_map_fc    
6e9f			;	ld hl, keyscan_table+key_cols  
6e9f			;	ld de, key_fc  
6e9f			;	call .key_shift_hold  
6e9f			;	cp 255  
6e9f			;	jr z, .cinmap  
6e9f			;	; flag if key B is held down and remove from reporting  
6e9f			;	ld bc, .key_map_fb    
6e9f			;	ld hl, keyscan_table+(key_cols*2)  
6e9f			;	ld de, key_fb  
6e9f			;	call .key_shift_hold  
6e9f			;	cp 255  
6e9f			;	jr z, .cinmap  
6e9f			;	; flag if key A is held down and remove from reporting  
6e9f			;	ld bc, .key_map_fa    
6e9f			;	ld hl, keyscan_table+(key_cols*3)  
6e9f			;	ld de, key_fa  
6e9f			;	call .key_shift_hold  
6e9f			;	cp 255  
6e9f			;	jr z, .cinmap  
6e9f			;  
6e9f			;	ld de, .matrix_to_char  
6e9f			;  
6e9f			;  
6e9f			;.cinmap:   
6e9f			;	if DEBUG_KEY  
6e9f			;            LD   A, kLCD_Line4  
6e9f			;            CALL fLCD_Pos       ;Position cursor to location in A  
6e9f			;		push de  
6e9f			;            LD   DE, keyscan_table  
6e9f			;            CALL fLCD_Str       ;Display string pointed to by DE  
6e9f			;		pop de  
6e9f			;	endif  
6e9f			  
6e9f				; scan key matrix table for any held key  
6e9f			  
6e9f				; de holds either the default matrix or one selected above  
6e9f			  
6e9f			;	ld hl, keyscan_table  
6e9f			;	ld b,key_cols*key_rows  
6e9f			;  
6e9f			;.cin1:	ld a,(hl)  
6e9f			;	cp '#'  
6e9f			;	jr z, .cinhit  
6e9f			;	inc hl  
6e9f			;	inc de  
6e9f			;	dec b  
6e9f			;	jr nz, .cin1  
6e9f			;	; no key found held  
6e9f			;	ld a,0  
6e9f			;	ret  
6e9f			;.cinhit: push de  
6e9f			;	pop hl  
6e9f			;	ld a,(hl)  
6e9f			;	ret  
6e9f			  
6e9f			; flag a control key is held   
6e9f			; hl is key pin, de is flag indicator  
6e9f			  
6e9f			;.key_shift_hold:  
6e9f			;	push bc  
6e9f			;	ld a, 1  
6e9f			;	ld (cursor_shape),a  
6e9f			;	ld b, 0  
6e9f			;	ld a, (hl)  
6e9f			;	cp '.'  
6e9f			;	jr z, .key_shift1  
6e9f			;	ld b, 255  
6e9f			;	ld a, '+'    ; hide key from later scans  
6e9f			;	ld (hl),a  
6e9f			;	ld a, 2  
6e9f			;	ld (cursor_shape),a  
6e9f			;.key_shift1:  
6e9f			;	; write flag indicator  
6e9f			;	ld a,b  
6e9f			;	ld (de),a  
6e9f			;  
6e9f			;	pop de    ; de now holds the key map ptr  
6e9f			;	ret  
6e9f			  
6e9f				  
6e9f				  
6e9f			  
6e9f			  
6e9f			  
6e9f			  
6e9f			  
6e9f			  
6e9f			  
6e9f			  
6e9f			  
6e9f			  
6e9f			  
6e9f			;	push hl  
6e9f			;	push de  
6e9f			;	push bc  
6e9f			;	call keyscan  
6e9f			;	; map key matrix to ascii value of key face  
6e9f			;  
6e9f			;	ld hl, key_face_map  
6e9f			;	ld de, keyscan_table  
6e9f			;  
6e9f			;	; get how many keys to look at  
6e9f			;	ld b, keyscan_table_len  
6e9f			;	  
6e9f			;  
6e9f			;	; at this stage fall out on first key hit  
6e9f			;	; TODO handle multiple key press  
6e9f			;  
6e9f			;map1:	ld a,(hl)  
6e9f			;	cp '#'  
6e9f			;	jr z, keyhit  
6e9f			;	inc hl  
6e9f			;	inc de  
6e9f			;	dec b  
6e9f			;	jr nz, map1  
6e9f			;nohit:	ld a, 0  
6e9f			;	jr keydone  
6e9f			;keyhit: push de  
6e9f			;	pop hl  
6e9f			;	ld a,(hl)  
6e9f			;keydone:  
6e9f			;	push bc  
6e9f			;	push de  
6e9f			; 	push hl  
6e9f			;	ret   
6e9f			;  
6e9f			  
6e9f			  
6e9f			  
6e9f			  
6e9f			; scan physical key matrix  
6e9f			  
6e9f			  
6e9f			;keyscan:  
6e9f			;  
6e9f			;; for each key_row use keyscanr bit mask for out  
6e9f			;; then read in for keyscanc bitmask  
6e9f			;; save result of row scan to keyscantable  
6e9f			;  
6e9f			;; scan keyboard row 1  
6e9f			;  
6e9f			;	ld b, key_rows  
6e9f			;	ld hl, key_scanr  
6e9f			;	ld de, keyscan_table  
6e9f			;  
6e9f			;rowloop:  
6e9f			;  
6e9f			;	ld a,(hl)		; out bit mask to energise keyboard row  
6e9f			;	call rowscan  
6e9f			;	inc hl  
6e9f			;	dec b  
6e9f			;	jr nz, rowloop  
6e9f			;  
6e9f			;	ret  
6e9f			;  
6e9f			;  
6e9f			;; pass a out bitmask, b row number  
6e9f			;arowscan:   
6e9f			;	push bc  
6e9f			;  
6e9f			;	ld d, b  
6e9f			;  
6e9f			;	; calculate buffer location for this row  
6e9f			;  
6e9f			;	ld hl, keyscan_table	  
6e9f			;kbufr:  ld e, key_cols  
6e9f			;kbufc:	inc hl  
6e9f			;	dec e  
6e9f			;	jr nz, kbufc  
6e9f			;	dec d  
6e9f			;	jr nz, kbufr  
6e9f			;  
6e9f			;	; energise row and read columns  
6e9f			;  
6e9f			;	out (portbdata),a  
6e9f			;	in a,(portbdata)  
6e9f			;	ld c,a  
6e9f			;  
6e9f			;  
6e9f			;	; save buffer loc  
6e9f			;  
6e9f			;	ld (keybufptr), hl  
6e9f			;  
6e9f			;	ld hl, key_scanc  
6e9f			;	ld d, key_cols  
6e9f			;  
6e9f			;	; for each column check each bit mask  
6e9f			;  
6e9f			;colloop:  
6e9f			;	  
6e9f			;  
6e9f			;	; reset flags for the row   
6e9f			;  
6e9f			;	ld b,'.'  
6e9f			;	and (hl)  
6e9f			;	jr z, maskskip  
6e9f			;	ld b,'#'  
6e9f			;maskskip:  
6e9f			;	; save  key state  
6e9f			;	push hl  
6e9f			;	ld hl, (keybufptr)  
6e9f			;	ld (hl), b  
6e9f			;	inc hl  
6e9f			;	ld (keybufptr), hl  
6e9f			;  
6e9f			;	; move to next bit mask  
6e9f			;	pop hl  
6e9f			;	inc hl  
6e9f			;  
6e9f			;	dec d  
6e9f			;	jr nz, colloop  
6e9f			;  
6e9f			;	ret  
6e9f			;  
6e9f			;  
6e9f			;;  
6e9f			; lcd functions  
6e9f			;  
6e9f			;  
6e9f			  
6e9f			;if DEBUG_KEY_MATRIX  
6e9f			  
6e9f			; test function to display hardware view of matrix state  
6e9f			  
6e9f			matrixold:  
6e9f			  
6e9f			  
6e9f			  
6e9f			; reset counter  
6e9f 3e 80		ld a, 128  
6ea1 d3 c1		out (portbdata),a  
6ea3			; scan keyboard row 1  
6ea3 3e 00		ld a, 0  
6ea5 d3 c1		out (portbdata),a  
6ea7			;ld a, 64  
6ea7			;out (portbdata),a  
6ea7 3e 80			ld a, 128  
6ea9 21 f2 fe			ld hl, keyscan_table_row1  
6eac cd 05 6f			call .rowscan  
6eaf			  
6eaf			;ld a, 0  
6eaf			;out (portbdata),a  
6eaf 3e 40		ld a, 64  
6eb1 d3 c1		out (portbdata),a  
6eb3 3e 40			ld a, 64  
6eb5 21 e7 fe			ld hl, keyscan_table_row2  
6eb8 cd 05 6f			call .rowscan  
6ebb			  
6ebb 3e 00		ld a, 0  
6ebd d3 c1		out (portbdata),a  
6ebf			;ld a, 64  
6ebf			;out (portbdata),a  
6ebf 3e 20			ld a, 32  
6ec1 21 dc fe			ld hl, keyscan_table_row3  
6ec4 cd 05 6f			call .rowscan  
6ec7			  
6ec7			;ld a, 0  
6ec7			;out (portbdata),a  
6ec7 3e 40		ld a, 64  
6ec9 d3 c1		out (portbdata),a  
6ecb 3e 10			ld a, 16  
6ecd 21 d1 fe			ld hl, keyscan_table_row4  
6ed0 cd 05 6f			call .rowscan  
6ed3			  
6ed3			; Display text on first line  
6ed3 3e 00		            LD   A, kLCD_Line1  
6ed5 cd 0d 6b		            CALL fLCD_Pos       ;Position cursor to location in A  
6ed8 11 f2 fe		            LD   DE, keyscan_table_row1  
6edb			            ;LD   DE, MsgHello  
6edb cd 2f 6b		            CALL fLCD_Str       ;Display string pointed to by DE  
6ede			  
6ede			; Display text on second line  
6ede 3e 28		            LD   A, kLCD_Line2  
6ee0 cd 0d 6b		            CALL fLCD_Pos       ;Position cursor to location in A  
6ee3 11 e7 fe		            LD   DE, keyscan_table_row2  
6ee6 cd 2f 6b		            CALL fLCD_Str       ;Display string pointed to by DE  
6ee9 3e 50		            LD   A, kLCD_Line3  
6eeb cd 0d 6b		            CALL fLCD_Pos       ;Position cursor to location in A  
6eee 11 dc fe		            LD   DE, keyscan_table_row3  
6ef1 cd 2f 6b		            CALL fLCD_Str       ;Display string pointed to by DE  
6ef4 3e 78		            LD   A, kLCD_Line4  
6ef6 cd 0d 6b		            CALL fLCD_Pos       ;Position cursor to location in A  
6ef9 11 d1 fe		            LD   DE, keyscan_table_row4  
6efc cd 2f 6b		            CALL fLCD_Str       ;Display string pointed to by DE  
6eff			  
6eff cd 41 0c			call delay250ms  
6f02 c3 f0 6d			jp matrix  
6f05			  
6f05			; pass de as row display flags  
6f05			.rowscan:   
6f05			;	out (portbdata),a  
6f05 db c1			in a,(portbdata)  
6f07 4f				ld c,a  
6f08				; reset flags for the row   
6f08 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6f0a e6 01			and 1  
6f0c 28 02			jr z, .p1on  
6f0e 06 23			ld b,'#'  
6f10			.p1on:  
6f10 70				ld (hl), b  
6f11 23				inc hl  
6f12			  
6f12 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6f14 79				ld a,c  
6f15 e6 02			and 2  
6f17			;	bit 0,a  
6f17 28 02			jr z, .p2on  
6f19 06 23			ld b,'#'  
6f1b			.p2on:  
6f1b 70				ld (hl), b  
6f1c 23				inc hl  
6f1d			;  
6f1d 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6f1f 79				ld a,c  
6f20 e6 04			and 4  
6f22			;;	bit 0,a  
6f22 28 02			jr z, .p3on  
6f24 06 23			ld b,'#'  
6f26			.p3on:  
6f26 70				ld (hl), b  
6f27 23				inc hl  
6f28			;;  
6f28 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6f2a			;;	bit 0,a  
6f2a 79				ld a,c  
6f2b e6 08			and 8  
6f2d 28 02			jr z, .p4on  
6f2f 06 23			ld b,'#'  
6f31			.p4on:  
6f31 70				ld (hl), b  
6f32 23				inc hl  
6f33			  
6f33 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6f35			;;	bit 0,a  
6f35 79				ld a,c  
6f36 e6 10			and 16  
6f38 28 02			jr z, .p5on  
6f3a 06 23			ld b,'#'  
6f3c			.p5on:  
6f3c 70				ld (hl), b  
6f3d 23				inc hl  
6f3e			; zero term  
6f3e 06 00			ld b,0  
6f40 70				ld (hl), b  
6f41			  
6f41 c9			.rscandone: ret  
6f42			  
6f42			;addatohl:  
6f42			;  
6f42			 ;add   a, l    ; A = A+L  
6f42			  ;  ld    l, a    ; L = A+L  
6f42			   ; adc   a, h    ; A = A+L+H+carry  
6f42			   ; sub   l       ; A = H+carry  
6f42			   ; ld    h, a    ; H = H+carry  
6f42			  
6f42			;ret  
6f42			; eof  
# End of file firmware_key_5x10.asm
6f42			;include "firmware_key_4x10.asm" 
6f42			 
6f42			heap_size:    equ heap_end - heap_start 
6f42			;eof 
# End of file os_mega.asm
6f42
