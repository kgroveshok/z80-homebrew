# File os_mega_cpm.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 1 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; Use this to tune the delay functions if your CPU is a bit quick. i.e. RunCPM on a PC 
0000			 
0000			CPM_DELAY_TUNE: equ 4000 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0100			endif 
0100 c3 91 15			jp coldstart     ; rst 0 - cold boot 
0103			 
0103			;        nop  
0103			;        nop 
0103			;;	org 05h		; null out bdos call 
0103			; 
0103			;        nop  
0103			;        nop  
0103			;        nop 
0103			;;	org 08h 
0103			;;; 
0103			;;	jp cin		; rst 8 - char in 
0103			;;; 
0103			; 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;	org 010h 
0103			;; 
0103			;	jp cout		; rest 010h  - char out 
0103			;; 
0103			;	org 01bh   
0103			; 
0103			;	;jp  		; rst 01bh   - write string to display 
0103			;	jp str_at_display 
0103			; 
0103			; 
0103			;	org 020h 
0103			; 
0103			;	; jp		 ; rst 020h - read char at screen location 
0103			; 
0103			;	org 028h 
0103			 
0103				; jp		 ; rst 028h  - storage i/o 
0103			 
0103			; 	org 030h 
0103			;	jp break_point_state 
0103			  
0103			; $30  
0103			; org 038h 
0103			; $38 
0103			 
0103			; TODO any more important entry points to add to jump table for easier coding use? 
0103			 
0103			 
0103			include "firmware.asm" 
0103			  
0103			; main constants (used here and in firmware)  
0103			  
0103			; TODO have page 0 of storage as bios  
0103			  
0103			Device_A: equ 0h  
0103			Device_B: equ 040h          ; Sound  
0103			  
0103			if BASE_KEV  
0103			Device_C: equ 080h          ; Storage and ext cart devices  
0103			endif  
0103			  
0103			if BASE_SC114  
0103			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
0103			endif  
0103			  
0103			if BASE_CPM  
0103			; TODO fixup for CPM  
0103			Device_C: equ 080h          ; Storage and ext cart devices  
0103			endif  
0103			  
0103			Device_D: equ 0c0h             ; Keyboard and LCD  
0103			  
0103			; Odd specific debug points for testing hardware dev  
0103			  
0103			DEBUG_SOUND: equ 1  
0103			DEBUG_STK_FAULT: equ 0  
0103			DEBUG_INPUT: equ 0     ; Debug input entry code  
0103			DEBUG_KEYCINWAIT: equ 0  
0103			DEBUG_KEYCIN: equ 0  
0103			DEBUG_KEY: equ 0  
0103			DEBUG_KEY_MATRIX: equ 0  
0103			DEBUG_STORECF: equ 0  
0103			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
0103			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
0103			DEBUG_SPI: equ 0    ; low level spi tests  
0103			  
0103			; Enable many break points  
0103			  
0103			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
0103			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
0103			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
0103			DEBUG_FORTH_JP: equ 0    ; 4  
0103			DEBUG_FORTH_MALLOC: equ 0  
0103			DEBUG_FORTH_MALLOC_INT: equ 0  
0103			DEBUG_FORTH_DOT: equ 0  
0103			DEBUG_FORTH_DOT_WAIT: equ 0  
0103			DEBUG_FORTH_MATHS: equ 0  
0103			DEBUG_FORTH_TOK: equ 0    ; 4  
0103			DEBUG_FORTH_PARSE: equ 0    ; 3  
0103			DEBUG_FORTH: equ 0  ;2  
0103			DEBUG_FORTH_WORDS: equ 1   ; 1  
0103			DEBUG_FORTH_PUSH: equ 1   ; 1  
0103			DEBUG_FORTH_UWORD: equ 1   ; 1  
0103			  
0103			; Enable key point breakpoints  
0103			  
0103			DEBUG_FORTH_DOT_KEY: equ 0  
0103			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
0103			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
0103			  
0103			; Debug stack imbalances  
0103			  
0103			ON: equ 1  
0103			OFF: equ 0  
0103			  
0103			DEBUG_STACK_IMB: equ 0  
0103			STACK_IMB_STORE: equ 20  
0103			  
0103			; House keeping and protections  
0103			  
0103			DEBUG_FORTH_STACK_GUARD: equ 1  
0103			DEBUG_FORTH_MALLOC_GUARD: equ 1  
0103			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
0103			FORTH_ENABLE_FREE: equ 0  
0103			FORTH_ENABLE_MALLOCFREE: equ 1  
0103			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
0103			FORTH_ENABLE_FLOATMATH: equ 0  
0103			  
0103			  
0103			CALLMONITOR: macro  
0103				call break_point_state  
0103				endm  
0103			  
0103			MALLOC_1: equ 1        ; from dk88   
0103			MALLOC_2: equ 0           ; broke  
0103			MALLOC_3: equ 0           ; really broke  
0103			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
0103			  
0103			if BASE_KEV   
0103			stacksize: equ 512*2  
0103			  
0103			STACK_RET_SIZE: equ 128  
0103			STACK_LOOP_SIZE: equ 512  
0103			STACK_DATA_SIZE: equ 512  
0103			endif  
0103			if BASE_SC114  
0103			;tos:	equ 0f000h  
0103			stacksize: equ 256  
0103			STACK_RET_SIZE: equ 64  
0103			STACK_LOOP_SIZE: equ 256  
0103			STACK_DATA_SIZE: equ 256  
0103			endif  
0103			  
0103			if BASE_CPM  
0103			;tos:	equ 0f000h  
0103			stacksize: equ 256  
0103			STACK_RET_SIZE: equ 64  
0103			STACK_LOOP_SIZE: equ 256  
0103			STACK_DATA_SIZE: equ 256  
0103			endif  
0103			  
0103			;if STORAGE_SE == 0  
0103			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
0103			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
0103			;endif  
0103			  
0103			; Block 0 at offset $3c holds the file number to run at system startup after the display  
0103			  
0103			STORE_0_FILERUN: equ $3c  
0103			  
0103			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
0103			  
0103			STORE_0_AUTORUN: equ $3c  
0103			  
0103			; Blocks where directory table is held  
0103			  
0103			; Reducing the number of entries increases the max file size  
0103			  
0103			;STORE_DIR_START: equ 1  
0103			;STORE_DIR_END: equ 33  
0103			  
0103			; Blocks from where file data is stored  
0103			  
0103			;STORE_DATA_START: equ STORE_DIR_END + 1  
0103			  
0103			; Block indicators (<32 are data files)  
0103			  
0103			;STORE_BLOCK_CFG: equ $8f       ; config block  
0103			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
0103			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
0103			;STORE_BLOCK_FREE: equ $85       ; data block free  
0103			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
0103			  
0103			  
0103			  
0103			; Directory entry flags  
0103			  
0103			;STORE_DIR_FREE: equ 0  
0103			;STORE_DIR_FILE:  equ 1  
0103			  
0103			; Structure offsets to directory entries  
0103			;STORE_DE_FLAG: equ 0  
0103			;STORE_DE_MAXEXT: equ 1  
0103			;STORE_DE_FILENAME: equ 2  
0103			  
0103			; Structure offsets to block 0  
0103			  
0103			;STORE_BK0_ISFOR: equ 1  
0103			;STORE_BK0_LABEL: equ 3  
0103			  
0103			; memory allocation   
0103			  
0103			chk_stund: equ tos+2           ; underflow check word  
0103			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
0103			  
0103			; keyscan table needs rows x cols buffer  
0103			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
0103			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
0103			  
0103			keyscan_table_row1: equ chk_stovr -key_cols-1  
0103			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
0103			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
0103			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
0103			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
0103			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
0103			keyscan_scancol: equ keyscan_table-key_cols  
0103			;keyscan_table_len: equ key_rows*key_cols  
0103			;keybufptr: equ keyscan_table - 2  
0103			;keysymbol: equ keybufptr - 1  
0103			key_held: equ keyscan_scancol-1	; currently held  
0103			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
0103			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
0103			key_fa: equ key_repeat_ct -1 ;  
0103			key_fb: equ key_fa -1 ;  
0103			key_fc: equ key_fb -1 ;  
0103			key_fd: equ key_fc -1 ;  
0103			key_face_held: equ key_fd - 1   
0103			  
0103			; flag for enabling/disabling various hardware diags   
0103			  
0103			hardware_diag: equ key_face_held - 1  
0103			  
0103			; hardware config switches  
0103			; TODO add bitmasks on includes for hardware  
0103			; high byte for expansion ids  
0103			;     0000 0000  no card inserted  
0103			;     0000 0001  storage card inserted  
0103			;     0000 0010  spi sd card active  
0103			  
0103			;       
0103			; low byte:  
0103			;     0000 0001   4x4 keypad  
0103			;     0000 0010   full keyboard  
0103			;     0000 0011   spi/ext keyboard  
0103			;     0000 0100   20x4 lcd  
0103			;     0000 1000   40x4 lcd  
0103			;     0000 1100   spi/ext display  
0103			;     0001 0000   ide interface available  
0103			  
0103			hardware_word: equ hardware_diag - 2  
0103			  
0103			; debug marker - optional display of debug point on the debug screens  
0103			  
0103			debug_mark: equ hardware_word - 4  
0103			  
0103			; input_str vars  
0103			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
0103			input_start:  equ input_ptr - 2    ; ptr to the start of string   
0103			input_size: equ input_start -1  ; number of chars  
0103			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
0103			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
0103			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
0103			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
0103			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
0103			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
0103			input_len: equ input_cur_onoff - 5 ; length of current input  
0103			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
0103			  
0103			CUR_BLINK_RATE: equ 15  
0103			  
0103			key_actual_pressed: equ input_cursor - 1   
0103			key_symbol: equ key_actual_pressed - 1   
0103			key_shift: equ key_symbol - 1   
0103			  
0103			; Display allocation  
0103			  
0103			;display_rows: equ 4     ; move out to mini and mega files  
0103			;display_cols: equ 20  
0103			  
0103			display_fb_len: equ display_rows*display_cols  
0103			  
0103			; primary frame buffer     
0103			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
0103			; working frame buffers  
0103			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
0103			display_fb3: equ  display_fb1-display_fb_len - 1  
0103			display_fb2: equ  display_fb3-display_fb_len - 1  
0103			;  
0103			; pointer to active frame buffer  
0103			display_fb_active: equ display_fb2 - 2  
0103			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
0103			display_write_tmp: equ display_lcde1e2 - 2  
0103			  
0103			  
0103			;  
0103			  
0103			;; can load into de directory  
0103			cursor_col: equ display_write_tmp-1  
0103			cursor_row: equ cursor_col-1  
0103			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
0103			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
0103			  
0103			; maths vars  
0103			  
0103			LFSRSeed: equ cursor_shape -20   
0103			randData: equ LFSRSeed - 2  
0103			xrandc: equ randData - 2  
0103			stackstore: equ xrandc - 2  
0103			seed1: equ  stackstore -2   
0103			seed2: equ seed1 - 2  
0103			  
0103			; cf storage vars  
0103			  
0103			iErrorNum:  equ seed2-1         ;Error number  
0103			iErrorReg:  equ iErrorNum -1              ;Error register  
0103			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
0103			  
0103			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
0103			  
0103			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
0103			  
0103			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
0103			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
0103			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
0103			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
0103			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
0103			store_tmpid: equ store_tmp3 - 1		; page temp id  
0103			store_tmpext: equ store_tmpid - 1		; file extent temp  
0103			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
0103			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
0103			store_filecache: equ store_openmaxext-(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
0103			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
0103			;  
0103			; spi vars  
0103			  
0103			  
0103			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
0103			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
0103			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
0103			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
0103			spi_device_id: equ spi_device - 1    ; human readable bank number  
0103			  
0103			;;;;; forth cli params  
0103			  
0103			; TODO use a different frame buffer for forth???  
0103			  
0103			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
0103			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
0103			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
0103			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
0103			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
0103			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
0103			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
0103			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
0103			  
0103			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
0103			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
0103			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
0103			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
0103			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
0103			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
0103			  
0103			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
0103			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0103			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
0103			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0103			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
0103			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
0103			chk_data_ovr: equ cli_data_stack -2; overflow check word  
0103			  
0103			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
0103			  
0103			; os/forth token vars  
0103			  
0103			os_last_cmd: equ os_var_array-255  
0103			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
0103			os_current_i: equ os_cli_cmd-2  
0103			os_cur_ptr: equ os_current_i-2  
0103			os_word_scratch: equ os_cur_ptr-30  
0103			os_tok_len: equ os_word_scratch - 2  
0103			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
0103			os_tok_malloc: equ os_tok_ptr - 2  
0103			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
0103			os_input: equ os_last_new_uword-255  
0103			execscratch: equ os_input-255        ; exec cmd eval buffer  
0103			scratch: equ execscratch-255  
0103			  
0103			  
0103			; temp locations for new word processing to save on adding more   
0103			  
0103			os_new_malloc: equ scratch-2  
0103			os_new_parse_len: equ os_new_malloc - 2  
0103			os_new_word_len: equ os_new_parse_len - 2  
0103			os_new_work_ptr: equ os_new_word_len - 2  
0103			os_new_src_ptr: equ os_new_work_ptr - 2  
0103			os_new_exec: equ os_new_src_ptr - 2  
0103			os_new_exec_ptr: equ os_new_exec - 2  
0103			  
0103			; resume memory alloocations....  
0103			  
0103			os_view_disable: equ os_new_exec_ptr - 1  
0103			os_view_af: equ os_view_disable - 2  
0103			os_view_hl: equ os_view_af -2  
0103			os_view_de: equ os_view_hl - 2  
0103			os_view_bc: equ os_view_de - 2  
0103			  
0103			; stack checksum word  
0103			if DEBUG_STACK_IMB  
0103				curframe: equ  os_view_de - 5  
0103				store_sp: equ curframe - (STACK_IMB_STORE*4)  
0103				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0103			else  
0103				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0103			endif  
0103			  
0103			; with data stack could see memory filled with junk. need some memory management   
0103			; malloc and free entry points added  
0103			  
0103			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
0103			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
0103			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
0103			;heap_end: equ free_list-1  ; Starting address of heap  
0103			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0103			  
0103			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0103			heap_end: equ chk_word-1  ; Starting address of heap  
0103			  
0103			  
0103			;if BASE_KEV   
0103			;heap_start: equ 0800eh  ; Starting address of heap  
0103			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
0103			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
0103			;endif  
0103			  
0103			;if BASE_SC114  
0103			;heap_start: equ baseram+15  ; Starting address of heap  
0103			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
0103			;endif  
0103			  
0103			  
0103			;;;;  
0103			  
0103			  
0103			; change below to point to last memory alloc above  
0103			topusermem:  equ   heap_start  
0103			  
0103			;if BASE_KEV   
0103			;baseusermem: equ 08000h  
0103			;endif  
0103			  
0103			;if BASE_SC114  
0103			;;aseusermem:     equ    12  
0103			;baseusermem:     equ    prompt  
0103			;;baseusermem:     equ    endofcode  
0103			;endif  
0103			  
0103			  
0103			; **********************************************************************  
0103			; **  Constants  
0103			; **********************************************************************  
0103			  
0103			; Constants used by this code module  
0103			kDataReg:   EQU Device_D           ;PIO port A data register  
0103			kContReg:   EQU Device_D+2           ;PIO port A control register  
0103			  
0103			  
0103			portbdata:  equ Device_D+1    ; port b data  
0103			portbctl:   equ Device_D+3    ; port b control  
0103			  
0103			  
0103			;KEY_SHIFT:   equ 5  
0103			;KEY_SYMBOLSHIFT:  equ 6  
0103			  
0103			KEY_SHIFTLOCK: equ 4  
0103			  
0103			  
0103			KEY_UP: equ 5  
0103			KEY_NEXTWORD: equ 6  
0103			KEY_PREVWORD: equ 7  
0103			KEY_BS: equ 8  
0103			KEY_TAB:  equ 9  
0103			KEY_DOWN: equ 10  
0103			KEY_LEFT: equ 11  
0103			KEY_RIGHT: equ 12  
0103			KEY_CR:   equ 13  
0103			KEY_HOME: equ 14  
0103			KEY_END: equ 15  
0103			  
0103			KEY_F1: equ 16  
0103			KEY_F2: equ 17  
0103			KEY_F3: equ 18  
0103			KEY_F4: equ 19  
0103			  
0103			KEY_F5: equ 20  
0103			KEY_F6: equ 21  
0103			KEY_F7: equ 22  
0103			KEY_F8: equ 23  
0103			  
0103			KEY_F9: equ 24  
0103			KEY_F10: equ 25  
0103			KEY_F11: equ 26  
0103			KEY_F12: equ 27  
0103			  
0103			;if DEBUG_KEY  
0103			;	KEY_MATRIX_NO_PRESS: equ '.'  
0103			;	KEY_SHIFT:   equ '.'  
0103			;	KEY_SYMBOLSHIFT:  equ '.'  
0103			;else  
0103				KEY_SHIFT:   equ '~'  
0103				KEY_SYMBOLSHIFT:  equ '~'  
0103				KEY_MATRIX_NO_PRESS: equ '~'  
0103			;endi  
0103			  
0103			  
0103			  
0103			  
0103			; Macro to make adding debug marks easier  
0103			  
0103			DMARK: macro str  
0103				push af  
0103				ld a, (.dmark)  
0103				ld (debug_mark),a  
0103				ld a, (.dmark+1)  
0103				ld (debug_mark+1),a  
0103				ld a, (.dmark+2)  
0103				ld (debug_mark+2),a  
0103				jr .pastdmark  
0103			.dmark: db str  
0103			.pastdmark: pop af  
0103			  
0103			endm  
0103			  
0103			  
0103			; macro to detect for stack imbalances  
0103			  
0103			include "stackimbal.asm"  
0103			; Macro and code to detect stock imbalances 
0103			 
0103			SPPUSH: equ 0 
0103			 
0103			; Add a stack frame which can be checked before return 
0103			 
0103			STACKFRAME: macro onoff frame1 frame2 
0103			 
0103				if DEBUG_STACK_IMB 
0103					if onoff 
0103						; save current SP 
0103						exx 
0103			 
0103						ld de, frame1 
0103						ld a, d 
0103						ld hl, curframe 
0103						call hexout 
0103						ld a, e 
0103						ld hl, curframe+2 
0103						call hexout 
0103			  
0103						ld hl, frame1 
0103						push hl 
0103						ld hl, frame2 
0103						push hl 
0103						exx 
0103					endif 
0103					 
0103				endif 
0103			endm 
0103			 
0103			STACKFRAMECHK: macro onoff frame1 frame2 
0103			 
0103					 
0103				if DEBUG_STACK_IMB 
0103					if onoff 
0103						exx 
0103						; check stack frame SP 
0103			 
0103						ld hl, frame2 
0103						pop de   ; frame2 
0103			 
0103						call cmp16 
0103						jr nz, .spnosame 
0103						 
0103			 
0103						ld hl, frame1 
0103						pop de   ; frame1 
0103			 
0103						call cmp16 
0103						jr z, .spfrsame 
0103			 
0103						.spnosame: call showsperror 
0103			 
0103						.spfrsame: nop 
0103			 
0103						exx 
0103					endif 
0103					 
0103				endif 
0103			 
0103			 
0103			endm 
0103			 
0103			 
0103			; for a sub routine, wrap SP collection and comparisons 
0103			 
0103			; Usage: 
0103			; 
0103			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
0103			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
0103			 
0103			SAVESP: macro onoff storeword 
0103			 
0103				if DEBUG_STACK_IMB 
0103					if onoff 
0103						; save current SP 
0103			 
0103						ld (store_sp+(storeword*4)), sp 
0103			 
0103					endif 
0103					 
0103				endif 
0103			 
0103			endm 
0103			 
0103			CHECKSP: macro onoff storeword 
0103			 
0103				if DEBUG_STACK_IMB 
0103					if onoff 
0103			 
0103						; save SP after last save 
0103				 
0103						ld (store_sp+(storeword*4)+2), sp 
0103			 
0103						push hl 
0103						ld hl, store_sp+(storeword*4) 
0103						call check_stack_sp  
0103						pop hl 
0103			 
0103			 
0103					endif 
0103					 
0103				endif 
0103			 
0103			endm 
0103			 
0103			if DEBUG_STACK_IMB 
0103			 
0103			check_stack_sp: 
0103					push de 
0103			 
0103					ld e, (hl) 
0103					inc hl 
0103					ld d, (hl) 
0103					inc hl 
0103			 
0103					push de 
0103			 
0103			 
0103					ld e, (hl) 
0103					inc hl 
0103					ld d, (hl) 
0103					inc hl 
0103			 
0103					pop hl 
0103			 
0103			 
0103					; check to see if the same 
0103			 
0103					call cmp16 
0103					jr z, .spsame 
0103			 
0103					; not same 
0103			 
0103					call showsperror 
0103			.spsame: 
0103			 
0103					pop de 
0103			 
0103					ret 
0103			 
0103			.sperr:  db "Stack imbalance",0 
0103			 
0103			 
0103			showsperror: 
0103			 
0103			 
0103				push hl 
0103				push af 
0103				push de 
0103				call clear_display 
0103				ld de, .sperr 
0103				ld a,0 
0103			;	ld de,os_word_scratch 
0103				call str_at_display 
0103				ld a, display_row_1+17 
0103				ld de, debug_mark 
0103				call str_at_display 
0103				ld a, 0 
0103				ld (curframe+4),a 
0103				ld hl, curframe 
0103				ld de, os_word_scratch 
0103				ld a, display_row_4 
0103				call str_at_display 
0103				call update_display 
0103				;call break_point_state 
0103				call cin_wait 
0103			 
0103				ld a, ' ' 
0103				ld (os_view_disable), a 
0103				pop de	 
0103				pop af 
0103				pop hl 
0103				CALLMONITOR 
0103				ret 
0103			 
0103			endif 
0103			 
0103			 
0103			 
0103			; eof 
# End of file stackimbal.asm
0103			  
0103			;TODO macro to calc col and row offset into screen  
0103			  
0103			  
0103			  
0103			hardware_init:  
0103			  
0103 3e 00				ld a, 0  
0105 32 80 ee				ld (hardware_diag), a  
0108			  
0108					; clear all the buffers  
0108			  
0108 21 1f ed				ld hl, display_fb1  
010b 22 db eb				ld (display_fb_active), hl  
010e			  
010e cd 47 09				call clear_display  
0111			  
0111 21 dd eb				ld hl, display_fb2  
0114 22 db eb				ld (display_fb_active), hl  
0117			  
0117 cd 47 09				call clear_display  
011a			  
011a					; init primary frame buffer area  
011a 21 c0 ed				ld hl, display_fb0  
011d 22 db eb				ld (display_fb_active), hl  
0120			  
0120 cd 47 09				call clear_display  
0123			  
0123			  
0123 cd 83 58				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0126			  
0126 cd 71 59			call key_init  
0129 cd b0 01			call storage_init  
012c			  
012c				; setup malloc functions  
012c			  
012c				if MALLOC_1  
012c cd 17 10				call  heap_init  
012f				endif  
012f				if MALLOC_4  
012f					call  heap_init  
012f				endif  
012f			  
012f				; init sound hardware if present  
012f			  
012f				if SOUND_ENABLE  
012f					call sound_init  
012f				endif  
012f			  
012f				; lcd test sequence  
012f					  
012f cd 6a 09			call update_display  
0132 cd ea 08			call delay1s  
0135 3e 2b			ld a,'+'  
0137 cd 4c 09			call fill_display  
013a cd 6a 09			call update_display  
013d cd ea 08			call delay1s  
0140 3e 2a			ld a,'*'  
0142 cd 4c 09			call fill_display  
0145 cd 6a 09			call update_display  
0148 cd ea 08			call delay1s  
014b 3e 2d			ld a,'-'  
014d cd 4c 09			call fill_display  
0150 cd 6a 09			call update_display  
0153 cd ea 08			call delay1s  
0156			  
0156			; boot splash screen  
0156			if display_cols == 20	  
0156			        ld a, display_row_1    
0156			else  
0156 3e 0a		        ld a, display_row_1 +10   
0158			endif  
0158 11 89 01			ld de, bootmsg  
015b cd 5a 09			call str_at_display  
015e cd 6a 09			call update_display  
0161			  
0161			  
0161 cd ea 08			call delay1s  
0164 cd ea 08			call delay1s  
0167			if display_cols == 20	  
0167			            LD   A, display_row_3+2  
0167			else  
0167 3e 5c		            LD   A, display_row_3+12  
0169			endif  
0169 11 9e 01			ld de, bootmsg1  
016c cd 5a 09			call str_at_display  
016f cd 6a 09			call update_display  
0172 cd ea 08			call delay1s  
0175 cd ea 08			call delay1s  
0178			  
0178			;	ld a, display_row_4+3  
0178			;	ld de, bootmsg2  
0178			;	call str_at_display  
0178			;	call update_display  
0178			;	call delay1s  
0178			;	call delay1s  
0178			  
0178			; debug mark setup  
0178			  
0178 3e 5f		ld a, '_'  
017a 32 7a ee		ld (debug_mark),a  
017d 32 7b ee		ld (debug_mark+1),a  
0180 32 7c ee		ld (debug_mark+2),a  
0183 3e 00		ld a,0  
0185 32 7d ee		ld (debug_mark+3),a  
0188			  
0188 c9					ret  
0189			  
0189			  
0189 .. 00		bootmsg:	db "z80-homebrew OS v1.5",0  
019e .. 00		bootmsg1:	db "by Kevin Groves",0  
01ae			;bootmsg2:	db "Firmware v0.1",0  
01ae			  
01ae			; a 4x20 lcd  
01ae			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
01ae			  
01ae			;if display_cols == 20  
01ae			;	include "firmware_lcd_4x20.asm"  
01ae			;endif  
01ae			  
01ae			;if display_cols == 40  
01ae			;	include "firmware_lcd_4x40.asm"  
01ae			;endif  
01ae			  
01ae			;  
01ae			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
01ae			; TODO abstract the bit bang video out interface for dual display  
01ae			; TODO wire video out to tx pin on rc2014 bus  
01ae			  
01ae			; must supply cin, and cin_wait for low level hardware abstraction   
01ae			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
01ae			; test scancode  
01ae			  
01ae			;;;;;  
01ae			;;;  
01ae			; Moved out to mini and maxi versions  
01ae			;  
01ae			; include "firmware_key_4x4.asm"  
01ae			; using existing 4 wire x 4 resistor array for input  
01ae			;include "firmware_key_4x10.asm"  
01ae			; need to mod the board for 5 rows due to resistor array  
01ae			;include "firmware_key_5x10.asm"  
01ae			  
01ae			; storage hardware interface  
01ae			  
01ae			; use microchip serial eeprom for storage  
01ae			  
01ae			  
01ae			if STORAGE_SE  
01ae				include "firmware_spi.asm"  
01ae				include "firmware_seeprom.asm"  
01ae			else  
01ae			   ; create some stubs for the labels  
01ae c9			se_readbyte: ret  
01af c9			se_writebyte: ret  
01b0 c9			storage_init: ret  
01b1			  
01b1			endif  
01b1			  
01b1			; use cf card for storage - throwing timeout errors. Hardware or software?????  
01b1			;include "firmware_cf.asm"  
01b1			  
01b1			; load up high level storage hardward abstractions  
01b1			include "firmware_storage.asm"  
01b1			 
01b1			; persisent storage hardware abstraction layer  
01b1			 
01b1			 
01b1			 
01b1			; Block 0 on storage is a config state 
01b1			 
01b1			 
01b1			 
01b1			; TODO add read phy block and write phy block functions 
01b1			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
01b1			 
01b1			; Abstraction layer  
01b1			 
01b1			; Logocial block size is same size as physical size - using tape concept 
01b1			 
01b1			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
01b1			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
01b1			 
01b1			 
01b1			 
01b1			; Filesystem layout (Logical layout) 
01b1			; 
01b1			; Block 0 - Bank config  
01b1			; 
01b1			;      Byte - 0 file id counter 
01b1			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
01b1			;      Byte - 3-20 zero terminated bank label 
01b1			; 
01b1			; Block 1 > File storage 
01b1			; 
01b1			;      Byte 0 file id    - block 0 file details 
01b1			;      Byte 1 block id - block 0 is file  
01b1			;            Byte 2-15 - File name 
01b1			; 
01b1			;       - to end of block data 
01b1			; 
01b1			 
01b1			 
01b1			; Read Block 
01b1			; ---------- 
01b1			; 
01b1			; With current bank 
01b1			;  
01b1			; Get block number to read 
01b1			; Load physical blocks starting at start block into buffer 
01b1			 
01b1			; de points to buffer to use 
01b1			; hl holds logical block number  
01b1			 
01b1			storage_read_block: 
01b1			 
01b1				; TODO bank selection 
01b1			 
01b1				; for each of the physical blocks read it into the buffer 
01b1 06 40			ld b, STORE_BLOCK_PHY 
01b3			 
01b3				if DEBUG_STORESE 
01b3 d5					push de 
01b4				endif 
01b4				 
01b4			.rl1:    
01b4			 
01b4				; read physical block at hl into de 
01b4			        ; increment hl and de to next read position on exit 
01b4			 
01b4 e5				push hl 
01b5 d5				push de	 
01b6 c5				push bc 
01b7			;	if DEBUG_STORESE 
01b7			;		push af 
01b7			;		ld a, 'R' 
01b7			;		ld (debug_mark),a 
01b7			;		pop af 
01b7			;		CALLMONITOR 
01b7			;	endif 
01b7 cd ae 01			call se_readbyte 
01ba			;	if DEBUG_STORESE 
01ba			;		ld a,(spi_portbyte) 
01ba			;		ld l, a 
01ba			;		push af 
01ba			;		ld a, '1' 
01ba			;		ld (debug_mark),a 
01ba			;		pop af 
01ba			;		CALLMONITOR 
01ba			;	endif 
01ba c1				pop bc 
01bb d1				pop de 
01bc e1				pop hl 
01bd 12				ld (de),a 
01be 23				inc hl 
01bf 13				inc de 
01c0			 
01c0			;	if DEBUG_STORESE 
01c0			;		push af 
01c0			;		ld a, 'r' 
01c0			;		ld (debug_mark),a 
01c0			;		pop af 
01c0			;		CALLMONITOR 
01c0			;	endif 
01c0			 
01c0 10 f2			djnz .rl1 
01c2			 
01c2				if DEBUG_STORESE 
01c2					DMARK "SRB" 
01c2 f5				push af  
01c3 3a d7 01			ld a, (.dmark)  
01c6 32 7a ee			ld (debug_mark),a  
01c9 3a d8 01			ld a, (.dmark+1)  
01cc 32 7b ee			ld (debug_mark+1),a  
01cf 3a d9 01			ld a, (.dmark+2)  
01d2 32 7c ee			ld (debug_mark+2),a  
01d5 18 03			jr .pastdmark  
01d7 ..			.dmark: db "SRB"  
01da f1			.pastdmark: pop af  
01db			endm  
# End of macro DMARK
01db d1					pop de 
01dc			; 
01dc			;		push af 
01dc			;		ld a, 'R' 
01dc			;		ld (debug_mark),a 
01dc			;		pop af 
01dc					CALLMONITOR 
01dc cd bb 13			call break_point_state  
01df				endm  
# End of macro CALLMONITOR
01df				endif 
01df c9				ret	 
01e0				 
01e0			 
01e0			; File Size 
01e0			; --------- 
01e0			; 
01e0			;   hl file id 
01e0			; 
01e0			;  returns in hl the number of blocks 
01e0			 
01e0			storage_file_size: 
01e0 5d				ld e, l 
01e1 16 00			ld d, 0 
01e3 21 40 00			ld hl, STORE_BLOCK_PHY 
01e6					if DEBUG_FORTH_WORDS 
01e6						DMARK "SIZ" 
01e6 f5				push af  
01e7 3a fb 01			ld a, (.dmark)  
01ea 32 7a ee			ld (debug_mark),a  
01ed 3a fc 01			ld a, (.dmark+1)  
01f0 32 7b ee			ld (debug_mark+1),a  
01f3 3a fd 01			ld a, (.dmark+2)  
01f6 32 7c ee			ld (debug_mark+2),a  
01f9 18 03			jr .pastdmark  
01fb ..			.dmark: db "SIZ"  
01fe f1			.pastdmark: pop af  
01ff			endm  
# End of macro DMARK
01ff						CALLMONITOR 
01ff cd bb 13			call break_point_state  
0202				endm  
# End of macro CALLMONITOR
0202					endif 
0202 cd cf 04			call storage_findnextid 
0205			 
0205 cd 9d 0b			call ishlzero 
0208			;	ld a, l 
0208			;	add h 
0208			;	cp 0 
0208 c8				ret z			; block not found so EOF 
0209			 
0209 11 65 eb			ld de, store_page 
020c cd b1 01			call storage_read_block 
020f			 
020f 3a 67 eb			ld a, (store_page+2)	 ; get extent count 
0212 6f				ld l, a 
0213 26 00			ld h, 0 
0215 c9			 	ret 
0216			 
0216			 
0216			; Write Block 
0216			; ----------- 
0216			; 
0216			; With current bank 
0216			;  
0216			; Get block number to write 
0216			; Write physical blocks starting at start block from buffer 
0216			  
0216			storage_write_block: 
0216				; TODO bank selection 
0216			 
0216				; for each of the physical blocks read it into the buffer 
0216 06 40			ld b, STORE_BLOCK_PHY 
0218			 
0218				if DEBUG_STORESE 
0218					DMARK "SWB" 
0218 f5				push af  
0219 3a 2d 02			ld a, (.dmark)  
021c 32 7a ee			ld (debug_mark),a  
021f 3a 2e 02			ld a, (.dmark+1)  
0222 32 7b ee			ld (debug_mark+1),a  
0225 3a 2f 02			ld a, (.dmark+2)  
0228 32 7c ee			ld (debug_mark+2),a  
022b 18 03			jr .pastdmark  
022d ..			.dmark: db "SWB"  
0230 f1			.pastdmark: pop af  
0231			endm  
# End of macro DMARK
0231			 
0231					;push af 
0231					;ld a, 'W' 
0231					;ld (debug_mark),a 
0231					;pop af 
0231					CALLMONITOR 
0231 cd bb 13			call break_point_state  
0234				endm  
# End of macro CALLMONITOR
0234				endif 
0234			 
0234			; might not be working 
0234			;	call se_writepage 
0234			 
0234			;	ret 
0234			; 
0234			 
0234			 
0234			 
0234			.wl1:    
0234			 
0234				; read physical block at hl into de 
0234			        ; increment hl and de to next read position on exit 
0234			 
0234 e5				push hl 
0235 d5				push de	 
0236 c5				push bc 
0237 1a				ld a,(de) 
0238				;if DEBUG_STORESE 
0238			;		push af 
0238			;		ld a, 'W' 
0238			;		ld (debug_mark),a 
0238			;		pop af 
0238			;		CALLMONITOR 
0238			;	endif 
0238 cd af 01			call se_writebyte 
023b			;	call delay250ms 
023b 00				nop 
023c 00				nop 
023d 00				nop 
023e			;	if DEBUG_STORESE 
023e			;		push af 
023e			;		ld a, 'w' 
023e			;		ld (debug_mark),a 
023e			;		pop af 
023e			;		CALLMONITOR 
023e			;	endif 
023e c1				pop bc 
023f d1				pop de 
0240 e1				pop hl 
0241 23				inc hl 
0242 13				inc de 
0243			 
0243			 
0243 10 ef			djnz .wl1 
0245			 
0245				if DEBUG_STORESE 
0245					DMARK "SW2" 
0245 f5				push af  
0246 3a 5a 02			ld a, (.dmark)  
0249 32 7a ee			ld (debug_mark),a  
024c 3a 5b 02			ld a, (.dmark+1)  
024f 32 7b ee			ld (debug_mark+1),a  
0252 3a 5c 02			ld a, (.dmark+2)  
0255 32 7c ee			ld (debug_mark+2),a  
0258 18 03			jr .pastdmark  
025a ..			.dmark: db "SW2"  
025d f1			.pastdmark: pop af  
025e			endm  
# End of macro DMARK
025e			 
025e					;push af 
025e					;ld a, 'W' 
025e					;ld (debug_mark),a 
025e					;pop af 
025e					CALLMONITOR 
025e cd bb 13			call break_point_state  
0261				endm  
# End of macro CALLMONITOR
0261				endif 
0261 c9				ret	 
0262			 
0262			; Init bank 
0262			; --------- 
0262			; 
0262			; With current bank 
0262			; 
0262			; Setup block 0 config 
0262			;     Set 0 file id counter 
0262			;     Set formatted byte pattern 
0262			;     Zero out bank label 
0262			;      
0262			; For every logical block write 0-1 byte as null 
0262			 
0262			storage_get_block_0: 
0262			 
0262				; TODO check presence 
0262			 
0262				; get block 0 config 
0262			 
0262 21 00 00			ld hl, 0 
0265 11 65 eb			ld de, store_page 
0268 cd b1 01			call storage_read_block 
026b			 
026b				if DEBUG_STORESE 
026b					DMARK "SB0" 
026b f5				push af  
026c 3a 80 02			ld a, (.dmark)  
026f 32 7a ee			ld (debug_mark),a  
0272 3a 81 02			ld a, (.dmark+1)  
0275 32 7b ee			ld (debug_mark+1),a  
0278 3a 82 02			ld a, (.dmark+2)  
027b 32 7c ee			ld (debug_mark+2),a  
027e 18 03			jr .pastdmark  
0280 ..			.dmark: db "SB0"  
0283 f1			.pastdmark: pop af  
0284			endm  
# End of macro DMARK
0284 11 65 eb				ld de, store_page 
0287			;		push af 
0287			;		ld a, 'i' 
0287			;		ld (debug_mark),a 
0287			;		pop af 
0287					CALLMONITOR 
0287 cd bb 13			call break_point_state  
028a				endm  
# End of macro CALLMONITOR
028a				endif 
028a			 
028a				; is this area formatted? 
028a			 
028a			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
028a 2a 66 eb			ld hl, (store_page+1) 
028d 3e 80			ld a,0x80 
028f bd				cp l 
0290 20 22			jr nz, .ininotformatted 
0292				; do a double check 
0292 3e 27			ld a, 0x27 
0294 bc				cp h 
0295 20 1d			jr nz, .ininotformatted 
0297			 
0297				; formatted then 
0297			 
0297				if DEBUG_STORESE 
0297					DMARK "SB1" 
0297 f5				push af  
0298 3a ac 02			ld a, (.dmark)  
029b 32 7a ee			ld (debug_mark),a  
029e 3a ad 02			ld a, (.dmark+1)  
02a1 32 7b ee			ld (debug_mark+1),a  
02a4 3a ae 02			ld a, (.dmark+2)  
02a7 32 7c ee			ld (debug_mark+2),a  
02aa 18 03			jr .pastdmark  
02ac ..			.dmark: db "SB1"  
02af f1			.pastdmark: pop af  
02b0			endm  
# End of macro DMARK
02b0					;push af 
02b0					;ld a, 'I' 
02b0					;ld (debug_mark),a 
02b0					;pop af 
02b0					CALLMONITOR 
02b0 cd bb 13			call break_point_state  
02b3				endm  
# End of macro CALLMONITOR
02b3				endif 
02b3 c9				ret 
02b4			 
02b4			.ininotformatted: 
02b4				; bank not formatted so poke various bits to make sure 
02b4			 
02b4				if DEBUG_STORESE 
02b4					DMARK "SB2" 
02b4 f5				push af  
02b5 3a c9 02			ld a, (.dmark)  
02b8 32 7a ee			ld (debug_mark),a  
02bb 3a ca 02			ld a, (.dmark+1)  
02be 32 7b ee			ld (debug_mark+1),a  
02c1 3a cb 02			ld a, (.dmark+2)  
02c4 32 7c ee			ld (debug_mark+2),a  
02c7 18 03			jr .pastdmark  
02c9 ..			.dmark: db "SB2"  
02cc f1			.pastdmark: pop af  
02cd			endm  
# End of macro DMARK
02cd					;push af 
02cd					;ld a, 'f' 
02cd					;ld (debug_mark),a 
02cd					;pop af 
02cd					CALLMONITOR 
02cd cd bb 13			call break_point_state  
02d0				endm  
# End of macro CALLMONITOR
02d0				endif 
02d0			 
02d0 21 65 eb			ld hl, store_page 
02d3 3e 00			ld a, 0 
02d5				 
02d5 77				ld (hl),a   ; reset file counter 
02d6			 
02d6 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
02d9 22 66 eb		 	ld (store_page+1), hl	 
02dc			 
02dc				; set default label 
02dc			 
02dc 21 78 03			ld hl, .defaultbanklabl 
02df 11 68 eb		 	ld de, store_page+3 
02e2 01 0f 00			ld bc, 15 
02e5 ed b0			ldir 
02e7			 
02e7				; Append the current bank id 
02e7 21 71 eb			ld hl, store_page+3+9 
02ea 3a 4a eb			ld a, (spi_device_id) 
02ed 77				ld (hl), a 
02ee			 
02ee				; save default page 0 
02ee			 
02ee 21 00 00			ld hl, 0 
02f1 11 65 eb			ld de, store_page 
02f4				if DEBUG_STORESE 
02f4					DMARK "SB3" 
02f4 f5				push af  
02f5 3a 09 03			ld a, (.dmark)  
02f8 32 7a ee			ld (debug_mark),a  
02fb 3a 0a 03			ld a, (.dmark+1)  
02fe 32 7b ee			ld (debug_mark+1),a  
0301 3a 0b 03			ld a, (.dmark+2)  
0304 32 7c ee			ld (debug_mark+2),a  
0307 18 03			jr .pastdmark  
0309 ..			.dmark: db "SB3"  
030c f1			.pastdmark: pop af  
030d			endm  
# End of macro DMARK
030d			;		push af 
030d			;		ld a, 'F' 
030d			;		ld (debug_mark),a 
030d			;		pop af 
030d					CALLMONITOR 
030d cd bb 13			call break_point_state  
0310				endm  
# End of macro CALLMONITOR
0310				endif 
0310 cd 16 02			call storage_write_block 
0313				if DEBUG_STORESE 
0313					DMARK "SB4" 
0313 f5				push af  
0314 3a 28 03			ld a, (.dmark)  
0317 32 7a ee			ld (debug_mark),a  
031a 3a 29 03			ld a, (.dmark+1)  
031d 32 7b ee			ld (debug_mark+1),a  
0320 3a 2a 03			ld a, (.dmark+2)  
0323 32 7c ee			ld (debug_mark+2),a  
0326 18 03			jr .pastdmark  
0328 ..			.dmark: db "SB4"  
032b f1			.pastdmark: pop af  
032c			endm  
# End of macro DMARK
032c			;		push af 
032c			;		ld a, '>' 
032c			;		ld (debug_mark),a 
032c			;		pop af 
032c					CALLMONITOR 
032c cd bb 13			call break_point_state  
032f				endm  
# End of macro CALLMONITOR
032f				endif 
032f			 
032f 00				nop 
0330 00				nop 
0331 00				nop 
0332			 
0332				; now set 0 in every page to mark as a free block 
0332			 
0332 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0334 21 40 00			ld hl, STORE_BLOCK_PHY 
0337			 
0337 3e 00		.setmark1:   	ld a,0 
0339 e5					push hl 
033a c5					push bc 
033b cd af 01				call se_writebyte 
033e 3e 0a			ld a, 10 
0340 cd cf 08			call aDelayInMS 
0343 23				inc hl 
0344 cd af 01				call se_writebyte 
0347 3e 0a			ld a, 10 
0349 cd cf 08			call aDelayInMS 
034c 2b				dec hl 
034d c1					pop bc 
034e e1					pop hl 
034f 3e 40				ld a, STORE_BLOCK_PHY 
0351 cd 74 0b				call addatohl 
0354 10 e1				djnz .setmark1 
0356			 
0356 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0358 3e 00		.setmark2:   	ld a,0 
035a e5					push hl 
035b c5					push bc 
035c cd af 01				call se_writebyte 
035f 3e 0a			ld a, 10 
0361 cd cf 08			call aDelayInMS 
0364 23				inc hl 
0365 cd af 01				call se_writebyte 
0368 3e 0a			ld a, 10 
036a cd cf 08			call aDelayInMS 
036d 2b				dec hl 
036e c1					pop bc 
036f e1					pop hl 
0370 3e 40				ld a, STORE_BLOCK_PHY 
0372 cd 74 0b				call addatohl 
0375 10 e1				djnz .setmark2 
0377			 
0377					 
0377			 
0377			 
0377 c9				ret 
0378			 
0378			 
0378			 
0378			 
0378 .. 00		.defaultbanklabl:   db "BankLabel_",0 
0383			 
0383			 
0383			 
0383			; Label Bank 
0383			; ---------- 
0383			; 
0383			; With current bank 
0383			; Read block 0 
0383			; Set label 
0383			; Write block 0 
0383			 
0383			; label str pointer in hl 
0383			 
0383			storage_label:     
0383			 
0383				if DEBUG_STORESE 
0383					DMARK "LBL" 
0383 f5				push af  
0384 3a 98 03			ld a, (.dmark)  
0387 32 7a ee			ld (debug_mark),a  
038a 3a 99 03			ld a, (.dmark+1)  
038d 32 7b ee			ld (debug_mark+1),a  
0390 3a 9a 03			ld a, (.dmark+2)  
0393 32 7c ee			ld (debug_mark+2),a  
0396 18 03			jr .pastdmark  
0398 ..			.dmark: db "LBL"  
039b f1			.pastdmark: pop af  
039c			endm  
# End of macro DMARK
039c					CALLMONITOR 
039c cd bb 13			call break_point_state  
039f				endm  
# End of macro CALLMONITOR
039f				endif 
039f			 
039f e5				push hl 
03a0			 
03a0 cd 62 02			call storage_get_block_0 
03a3			 
03a3				; set default label 
03a3			 
03a3 e1				pop hl 
03a4			 
03a4 11 68 eb		 	ld de, store_page+3 
03a7 01 0f 00			ld bc, 15 
03aa				if DEBUG_STORESE 
03aa					DMARK "LB3" 
03aa f5				push af  
03ab 3a bf 03			ld a, (.dmark)  
03ae 32 7a ee			ld (debug_mark),a  
03b1 3a c0 03			ld a, (.dmark+1)  
03b4 32 7b ee			ld (debug_mark+1),a  
03b7 3a c1 03			ld a, (.dmark+2)  
03ba 32 7c ee			ld (debug_mark+2),a  
03bd 18 03			jr .pastdmark  
03bf ..			.dmark: db "LB3"  
03c2 f1			.pastdmark: pop af  
03c3			endm  
# End of macro DMARK
03c3					CALLMONITOR 
03c3 cd bb 13			call break_point_state  
03c6				endm  
# End of macro CALLMONITOR
03c6				endif 
03c6 ed b0			ldir 
03c8				; save default page 0 
03c8			 
03c8 21 00 00			ld hl, 0 
03cb 11 65 eb			ld de, store_page 
03ce				if DEBUG_STORESE 
03ce					DMARK "LBW" 
03ce f5				push af  
03cf 3a e3 03			ld a, (.dmark)  
03d2 32 7a ee			ld (debug_mark),a  
03d5 3a e4 03			ld a, (.dmark+1)  
03d8 32 7b ee			ld (debug_mark+1),a  
03db 3a e5 03			ld a, (.dmark+2)  
03de 32 7c ee			ld (debug_mark+2),a  
03e1 18 03			jr .pastdmark  
03e3 ..			.dmark: db "LBW"  
03e6 f1			.pastdmark: pop af  
03e7			endm  
# End of macro DMARK
03e7					CALLMONITOR 
03e7 cd bb 13			call break_point_state  
03ea				endm  
# End of macro CALLMONITOR
03ea				endif 
03ea cd 16 02			call storage_write_block 
03ed			 
03ed c9				ret 
03ee			 
03ee			 
03ee			 
03ee			; Read Block 0 - Config 
03ee			; --------------------- 
03ee			; 
03ee			; With current bank 
03ee			; Call presence test 
03ee			;    If not present format/init bank  
03ee			; Read block 0  
03ee			;  
03ee			 
03ee			 
03ee			; Dir 
03ee			; --- 
03ee			; 
03ee			; With current bank 
03ee			; Load Block 0 Config 
03ee			; Get max file id number 
03ee			; For each logical block 
03ee			;    Read block read byte 2 
03ee			;      if first block of file 
03ee			;         Display file name 
03ee			;         Display type flags for file 
03ee			;        
03ee			 
03ee			; moving to words as this requires stack control 
03ee			 
03ee			 
03ee			; Delete File 
03ee			; ----------- 
03ee			; 
03ee			; With current bank 
03ee			; 
03ee			; Load Block 0 Config 
03ee			; Get max file id number 
03ee			; For each logical block 
03ee			;    Read block file id 
03ee			;      If first block of file and dont have file id 
03ee			;         if file to delete 
03ee			;         Save file id 
03ee			;         Null file id 
03ee			;         Write this block back 
03ee			;      If file id is one saved 
03ee			;         Null file id 
03ee			;         Write this block back 
03ee			 
03ee			storage_erase: 
03ee			 
03ee				; hl contains the file id 
03ee			 
03ee 5d				ld e, l 
03ef 16 00			ld d, 0 
03f1 21 40 00			ld hl, STORE_BLOCK_PHY 
03f4					if DEBUG_FORTH_WORDS 
03f4						DMARK "ERA" 
03f4 f5				push af  
03f5 3a 09 04			ld a, (.dmark)  
03f8 32 7a ee			ld (debug_mark),a  
03fb 3a 0a 04			ld a, (.dmark+1)  
03fe 32 7b ee			ld (debug_mark+1),a  
0401 3a 0b 04			ld a, (.dmark+2)  
0404 32 7c ee			ld (debug_mark+2),a  
0407 18 03			jr .pastdmark  
0409 ..			.dmark: db "ERA"  
040c f1			.pastdmark: pop af  
040d			endm  
# End of macro DMARK
040d						CALLMONITOR 
040d cd bb 13			call break_point_state  
0410				endm  
# End of macro CALLMONITOR
0410					endif 
0410 cd cf 04			call storage_findnextid 
0413			 
0413 e5				push hl 
0414			 
0414				; TODO check file not found 
0414			 
0414 11 65 eb			ld de, store_page 
0417 cd b1 01			call storage_read_block 
041a			 
041a					if DEBUG_FORTH_WORDS 
041a						DMARK "ER1" 
041a f5				push af  
041b 3a 2f 04			ld a, (.dmark)  
041e 32 7a ee			ld (debug_mark),a  
0421 3a 30 04			ld a, (.dmark+1)  
0424 32 7b ee			ld (debug_mark+1),a  
0427 3a 31 04			ld a, (.dmark+2)  
042a 32 7c ee			ld (debug_mark+2),a  
042d 18 03			jr .pastdmark  
042f ..			.dmark: db "ER1"  
0432 f1			.pastdmark: pop af  
0433			endm  
# End of macro DMARK
0433						CALLMONITOR 
0433 cd bb 13			call break_point_state  
0436				endm  
# End of macro CALLMONITOR
0436					endif 
0436 3a 65 eb			ld a, (store_page)	; get file id 
0439 32 5e eb			ld (store_tmpid), a 
043c			 
043c 3a 67 eb			ld a, (store_page+2)    ; get count of extends 
043f 32 5d eb			ld (store_tmpext), a 
0442			 
0442				; wipe file header 
0442			 
0442 e1				pop hl 
0443 3e 00			ld a, 0 
0445 32 65 eb			ld (store_page), a 
0448 32 66 eb			ld (store_page+1),a 
044b 11 65 eb			ld de, store_page 
044e					if DEBUG_FORTH_WORDS 
044e						DMARK "ER2" 
044e f5				push af  
044f 3a 63 04			ld a, (.dmark)  
0452 32 7a ee			ld (debug_mark),a  
0455 3a 64 04			ld a, (.dmark+1)  
0458 32 7b ee			ld (debug_mark+1),a  
045b 3a 65 04			ld a, (.dmark+2)  
045e 32 7c ee			ld (debug_mark+2),a  
0461 18 03			jr .pastdmark  
0463 ..			.dmark: db "ER2"  
0466 f1			.pastdmark: pop af  
0467			endm  
# End of macro DMARK
0467						CALLMONITOR 
0467 cd bb 13			call break_point_state  
046a				endm  
# End of macro CALLMONITOR
046a					endif 
046a cd 16 02			call storage_write_block 
046d			 
046d			 
046d				; wipe file extents 
046d			 
046d 3a 5d eb			ld a, (store_tmpext) 
0470 47				ld b, a 
0471			 
0471			.eraext:	  
0471 c5				push bc 
0472			 
0472 21 40 00			ld hl, STORE_BLOCK_PHY 
0475 3a 5e eb			ld a,(store_tmpid) 
0478 5f				ld e, a 
0479 50				ld d, b	 
047a					if DEBUG_FORTH_WORDS 
047a						DMARK "ER3" 
047a f5				push af  
047b 3a 8f 04			ld a, (.dmark)  
047e 32 7a ee			ld (debug_mark),a  
0481 3a 90 04			ld a, (.dmark+1)  
0484 32 7b ee			ld (debug_mark+1),a  
0487 3a 91 04			ld a, (.dmark+2)  
048a 32 7c ee			ld (debug_mark+2),a  
048d 18 03			jr .pastdmark  
048f ..			.dmark: db "ER3"  
0492 f1			.pastdmark: pop af  
0493			endm  
# End of macro DMARK
0493						CALLMONITOR 
0493 cd bb 13			call break_point_state  
0496				endm  
# End of macro CALLMONITOR
0496					endif 
0496 cd cf 04			call storage_findnextid 
0499			 
0499 e5				push hl 
049a 11 65 eb			ld de, store_page 
049d cd b1 01			call storage_read_block 
04a0			 
04a0				; free block	 
04a0			 
04a0 3e 00			ld a, 0 
04a2 32 65 eb			ld (store_page), a 
04a5 32 66 eb			ld (store_page+1),a 
04a8 11 65 eb			ld de, store_page 
04ab e1				pop hl 
04ac					if DEBUG_FORTH_WORDS 
04ac						DMARK "ER4" 
04ac f5				push af  
04ad 3a c1 04			ld a, (.dmark)  
04b0 32 7a ee			ld (debug_mark),a  
04b3 3a c2 04			ld a, (.dmark+1)  
04b6 32 7b ee			ld (debug_mark+1),a  
04b9 3a c3 04			ld a, (.dmark+2)  
04bc 32 7c ee			ld (debug_mark+2),a  
04bf 18 03			jr .pastdmark  
04c1 ..			.dmark: db "ER4"  
04c4 f1			.pastdmark: pop af  
04c5			endm  
# End of macro DMARK
04c5						CALLMONITOR 
04c5 cd bb 13			call break_point_state  
04c8				endm  
# End of macro CALLMONITOR
04c8					endif 
04c8 cd 16 02			call storage_write_block 
04cb			 
04cb c1				pop bc 
04cc 10 a3			djnz .eraext 
04ce			 
04ce c9				ret 
04cf			 
04cf			 
04cf			; Find Free Block 
04cf			; --------------- 
04cf			; 
04cf			; With current bank 
04cf			;  
04cf			; From given starting logical block 
04cf			;    Read block  
04cf			;    If no file id 
04cf			;         Return block id 
04cf			 
04cf			 
04cf			; hl starting page number 
04cf			; hl contains free page number or zero if no pages free 
04cf			; e contains the file id to locate 
04cf			; d contains the block number 
04cf			 
04cf			; TODO change to find file id and use zero for free block 
04cf			 
04cf			storage_findnextid: 
04cf			 
04cf				; now locate first 0 page to mark as a free block 
04cf			 
04cf 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
04d1			;	ld hl, STORE_BLOCK_PHY 
04d1			 
04d1					if DEBUG_FORTH_WORDS 
04d1					DMARK "FNI" 
04d1 f5				push af  
04d2 3a e6 04			ld a, (.dmark)  
04d5 32 7a ee			ld (debug_mark),a  
04d8 3a e7 04			ld a, (.dmark+1)  
04db 32 7b ee			ld (debug_mark+1),a  
04de 3a e8 04			ld a, (.dmark+2)  
04e1 32 7c ee			ld (debug_mark+2),a  
04e4 18 03			jr .pastdmark  
04e6 ..			.dmark: db "FNI"  
04e9 f1			.pastdmark: pop af  
04ea			endm  
# End of macro DMARK
04ea						CALLMONITOR 
04ea cd bb 13			call break_point_state  
04ed				endm  
# End of macro CALLMONITOR
04ed					endif 
04ed			.ff1:   	 
04ed e5					push hl 
04ee c5					push bc 
04ef d5					push de 
04f0 cd ae 01				call se_readbyte 
04f3 5f					ld e,a 
04f4 23					inc hl 
04f5 cd ae 01				call se_readbyte 
04f8 57					ld d, a 
04f9 e1					pop hl 
04fa e5					push hl 
04fb cd 92 0b				call cmp16 
04fe 28 49				jr z, .fffound 
0500			 
0500 d1					pop de 
0501 c1					pop bc 
0502 e1					pop hl 
0503			 
0503					; is found? 
0503					;cp e 
0503					;ret z 
0503			 
0503 3e 40				ld a, STORE_BLOCK_PHY 
0505 cd 74 0b				call addatohl 
0508 10 e3				djnz .ff1 
050a			 
050a 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
050c			.ff2:   	 
050c			 
050c e5					push hl 
050d c5					push bc 
050e d5					push de 
050f cd ae 01				call se_readbyte 
0512 5f					ld e,a 
0513 23					inc hl 
0514 cd ae 01				call se_readbyte 
0517 57					ld d, a 
0518			 
0518 e1					pop hl 
0519 e5					push hl 
051a cd 92 0b				call cmp16 
051d 28 2a				jr z, .fffound 
051f			 
051f d1					pop de 
0520 c1					pop bc 
0521 e1					pop hl 
0522					; is found? 
0522					;cp e 
0522					;ret z 
0522			 
0522 3e 40				ld a, STORE_BLOCK_PHY 
0524 cd 74 0b				call addatohl 
0527 10 e3				djnz .ff2 
0529			 
0529			 
0529					if DEBUG_FORTH_WORDS 
0529					DMARK "FN-" 
0529 f5				push af  
052a 3a 3e 05			ld a, (.dmark)  
052d 32 7a ee			ld (debug_mark),a  
0530 3a 3f 05			ld a, (.dmark+1)  
0533 32 7b ee			ld (debug_mark+1),a  
0536 3a 40 05			ld a, (.dmark+2)  
0539 32 7c ee			ld (debug_mark+2),a  
053c 18 03			jr .pastdmark  
053e ..			.dmark: db "FN-"  
0541 f1			.pastdmark: pop af  
0542			endm  
# End of macro DMARK
0542					;	push af 
0542					;	ld a, 'n' 
0542					;	ld (debug_mark),a 
0542					;	pop af 
0542						CALLMONITOR 
0542 cd bb 13			call break_point_state  
0545				endm  
# End of macro CALLMONITOR
0545					endif 
0545				; no free marks! 
0545 21 00 00				ld hl, 0 
0548 c9				ret 
0549			.fffound: 
0549				 
0549			 
0549 d1					pop de 
054a c1					pop bc 
054b e1					pop hl 
054c					if DEBUG_FORTH_WORDS 
054c					DMARK "FNF" 
054c f5				push af  
054d 3a 61 05			ld a, (.dmark)  
0550 32 7a ee			ld (debug_mark),a  
0553 3a 62 05			ld a, (.dmark+1)  
0556 32 7b ee			ld (debug_mark+1),a  
0559 3a 63 05			ld a, (.dmark+2)  
055c 32 7c ee			ld (debug_mark+2),a  
055f 18 03			jr .pastdmark  
0561 ..			.dmark: db "FNF"  
0564 f1			.pastdmark: pop af  
0565			endm  
# End of macro DMARK
0565					;	push af 
0565					;	ld a, 'n' 
0565					;	ld (debug_mark),a 
0565					;	pop af 
0565						CALLMONITOR 
0565 cd bb 13			call break_point_state  
0568				endm  
# End of macro CALLMONITOR
0568					endif 
0568 c9				ret 
0569			 
0569			 
0569			 
0569			; Free Space 
0569			; ---------- 
0569			; 
0569			; With current bank 
0569			; 
0569			; Set block count to zero 
0569			; Starting with first logical block 
0569			;      Find free block  
0569			;      If block id given, increment block count 
0569			; 
0569			;  
0569			 
0569			 
0569			; hl contains count of free blocks 
0569			 
0569			storage_freeblocks: 
0569			 
0569				; now locate first 0 page to mark as a free block 
0569			 
0569 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
056b 21 40 00			ld hl, STORE_BLOCK_PHY 
056e 11 00 00			ld de, 0 
0571			 
0571			.fb1:   	 
0571 e5					push hl 
0572 c5					push bc 
0573 d5					push de 
0574 cd ae 01				call se_readbyte 
0577 d1					pop de 
0578 c1					pop bc 
0579 e1					pop hl 
057a			 
057a					; is free? 
057a fe 00				cp 0 
057c 20 01				jr nz, .ff1cont 
057e 13					inc de 
057f			 
057f			.ff1cont: 
057f			 
057f			 
057f 3e 40				ld a, STORE_BLOCK_PHY 
0581 cd 74 0b				call addatohl 
0584 10 eb				djnz .fb1 
0586			 
0586 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0588			.fb2:   	 
0588 e5					push hl 
0589 c5					push bc 
058a d5					push de 
058b cd ae 01				call se_readbyte 
058e d1					pop de 
058f c1					pop bc 
0590 e1					pop hl 
0591			 
0591					; is free? 
0591 fe 00				cp 0 
0593 20 01				jr nz, .ff2cont 
0595 13					inc de 
0596			 
0596			.ff2cont: 
0596			 
0596 3e 40				ld a, STORE_BLOCK_PHY 
0598 cd 74 0b				call addatohl 
059b 10 eb				djnz .fb2 
059d			 
059d eb				ex de, hl 
059e c9				ret 
059f			 
059f			; Get File ID 
059f			; ----------- 
059f			; 
059f			; With current bank 
059f			;  
059f			; Load Block 0 Config 
059f			; Get max file id number 
059f			; For each logical block 
059f			;    Read block file id 
059f			;      If first block of file and dont have file id 
059f			;         if file get id and exit 
059f			 
059f			 
059f			 
059f			 
059f			; Create File 
059f			; ----------- 
059f			; 
059f			; With current bank  
059f			; Load Block 0 Config 
059f			; Get max file id number 
059f			; Increment file id number 
059f			; Save Config 
059f			; Find free block 
059f			; Set buffer with file name and file id 
059f			; Write buffer to free block  
059f			 
059f			 
059f			; hl point to file name 
059f			; hl returns file id 
059f			 
059f			; file format: 
059f			; byte 0 - file id 
059f			; byte 1 - extent number 
059f			; byte 2-> data 
059f			 
059f			; format for extent number 0: 
059f			; 
059f			; byte 0 - file id 
059f			; byte 1 - extent 0 
059f			; byte 2 - extent count 
059f			; byte 3 -> file name and meta data 
059f			 
059f			 
059f			storage_create: 
059f				if DEBUG_STORESE 
059f					DMARK "SCR" 
059f f5				push af  
05a0 3a b4 05			ld a, (.dmark)  
05a3 32 7a ee			ld (debug_mark),a  
05a6 3a b5 05			ld a, (.dmark+1)  
05a9 32 7b ee			ld (debug_mark+1),a  
05ac 3a b6 05			ld a, (.dmark+2)  
05af 32 7c ee			ld (debug_mark+2),a  
05b2 18 03			jr .pastdmark  
05b4 ..			.dmark: db "SCR"  
05b7 f1			.pastdmark: pop af  
05b8			endm  
# End of macro DMARK
05b8					CALLMONITOR 
05b8 cd bb 13			call break_point_state  
05bb				endm  
# End of macro CALLMONITOR
05bb				endif 
05bb			 
05bb e5				push hl		; save file name pointer 
05bc			 
05bc cd 62 02			call storage_get_block_0 
05bf			 
05bf 3a 65 eb			ld a,(store_page)	; get current file id 
05c2 3c				inc a 
05c3 32 65 eb			ld (store_page),a 
05c6				 
05c6 32 5e eb			ld (store_tmpid),a			; save id 
05c9			 
05c9 21 00 00			ld hl, 0 
05cc 11 65 eb			ld de, store_page 
05cf				if DEBUG_STORESE 
05cf					DMARK "SCw" 
05cf f5				push af  
05d0 3a e4 05			ld a, (.dmark)  
05d3 32 7a ee			ld (debug_mark),a  
05d6 3a e5 05			ld a, (.dmark+1)  
05d9 32 7b ee			ld (debug_mark+1),a  
05dc 3a e6 05			ld a, (.dmark+2)  
05df 32 7c ee			ld (debug_mark+2),a  
05e2 18 03			jr .pastdmark  
05e4 ..			.dmark: db "SCw"  
05e7 f1			.pastdmark: pop af  
05e8			endm  
# End of macro DMARK
05e8					CALLMONITOR 
05e8 cd bb 13			call break_point_state  
05eb				endm  
# End of macro CALLMONITOR
05eb				endif 
05eb cd 16 02			call storage_write_block	 ; save update 
05ee			 
05ee				if DEBUG_STORESE 
05ee 11 65 eb				ld de, store_page 
05f1					DMARK "SCC" 
05f1 f5				push af  
05f2 3a 06 06			ld a, (.dmark)  
05f5 32 7a ee			ld (debug_mark),a  
05f8 3a 07 06			ld a, (.dmark+1)  
05fb 32 7b ee			ld (debug_mark+1),a  
05fe 3a 08 06			ld a, (.dmark+2)  
0601 32 7c ee			ld (debug_mark+2),a  
0604 18 03			jr .pastdmark  
0606 ..			.dmark: db "SCC"  
0609 f1			.pastdmark: pop af  
060a			endm  
# End of macro DMARK
060a					CALLMONITOR 
060a cd bb 13			call break_point_state  
060d				endm  
# End of macro CALLMONITOR
060d				endif 
060d				;  
060d				 
060d 21 40 00			ld hl, STORE_BLOCK_PHY 
0610 11 00 00			ld de, 0 
0613 cd cf 04			call storage_findnextid 
0616			 
0616 22 4f eb			ld (store_tmppageid), hl    ; save page to use  
0619			 
0619				; TODO detect 0 = no spare blocks 
0619			 
0619				; hl now contains the free page to use for the file header page 
0619			 
0619				if DEBUG_STORESE 
0619				DMARK "SCF" 
0619 f5				push af  
061a 3a 2e 06			ld a, (.dmark)  
061d 32 7a ee			ld (debug_mark),a  
0620 3a 2f 06			ld a, (.dmark+1)  
0623 32 7b ee			ld (debug_mark+1),a  
0626 3a 30 06			ld a, (.dmark+2)  
0629 32 7c ee			ld (debug_mark+2),a  
062c 18 03			jr .pastdmark  
062e ..			.dmark: db "SCF"  
0631 f1			.pastdmark: pop af  
0632			endm  
# End of macro DMARK
0632					CALLMONITOR 
0632 cd bb 13			call break_point_state  
0635				endm  
# End of macro CALLMONITOR
0635				endif 
0635			 
0635 22 4f eb			ld (store_tmppageid), hl 
0638				 
0638 3a 5e eb			ld a,(store_tmpid)    ; get file id 
063b			;	ld a, (store_filecache)			; save to cache 
063b			 
063b 32 65 eb			ld (store_page),a    ; set page id 
063e 3e 00			ld a, 0			 ; extent 0 is file header 
0640 32 66 eb			ld (store_page+1), a   ; set file extent 
0643			 
0643 32 67 eb			ld (store_page+2), a   ; extent count for the file 
0646			 
0646			;	inc hl 		; init block 0 of file 
0646			;	inc hl   		; skip file and extent id 
0646			 ;       ld a, 0 
0646			;	ld (hl),a 
0646			;	ld a, (store_filecache+1)  	; save to cache 
0646			 
0646			;	inc hl    ; file name 
0646				 
0646				 
0646 11 68 eb			ld de, store_page+3    ; get buffer for term string to use as file name 
0649				if DEBUG_STORESE 
0649					DMARK "SCc" 
0649 f5				push af  
064a 3a 5e 06			ld a, (.dmark)  
064d 32 7a ee			ld (debug_mark),a  
0650 3a 5f 06			ld a, (.dmark+1)  
0653 32 7b ee			ld (debug_mark+1),a  
0656 3a 60 06			ld a, (.dmark+2)  
0659 32 7c ee			ld (debug_mark+2),a  
065c 18 03			jr .pastdmark  
065e ..			.dmark: db "SCc"  
0661 f1			.pastdmark: pop af  
0662			endm  
# End of macro DMARK
0662					CALLMONITOR 
0662 cd bb 13			call break_point_state  
0665				endm  
# End of macro CALLMONITOR
0665				endif 
0665 e1				pop hl    ; get zero term string 
0666 e5				push hl 
0667 3e 00			ld a, 0 
0669 cd dd 0f			call strlent 
066c 23				inc hl   ; cover zero term 
066d 06 00			ld b,0 
066f 4d				ld c,l 
0670 e1				pop hl 
0671				;ex de, hl 
0671				if DEBUG_STORESE 
0671					DMARK "SCa" 
0671 f5				push af  
0672 3a 86 06			ld a, (.dmark)  
0675 32 7a ee			ld (debug_mark),a  
0678 3a 87 06			ld a, (.dmark+1)  
067b 32 7b ee			ld (debug_mark+1),a  
067e 3a 88 06			ld a, (.dmark+2)  
0681 32 7c ee			ld (debug_mark+2),a  
0684 18 03			jr .pastdmark  
0686 ..			.dmark: db "SCa"  
0689 f1			.pastdmark: pop af  
068a			endm  
# End of macro DMARK
068a					;push af 
068a					;ld a, 'a' 
068a					;ld (debug_mark),a 
068a					;pop af 
068a					CALLMONITOR 
068a cd bb 13			call break_point_state  
068d				endm  
# End of macro CALLMONITOR
068d				endif 
068d ed b0			ldir    ; copy zero term string 
068f				if DEBUG_STORESE 
068f					DMARK "SCA" 
068f f5				push af  
0690 3a a4 06			ld a, (.dmark)  
0693 32 7a ee			ld (debug_mark),a  
0696 3a a5 06			ld a, (.dmark+1)  
0699 32 7b ee			ld (debug_mark+1),a  
069c 3a a6 06			ld a, (.dmark+2)  
069f 32 7c ee			ld (debug_mark+2),a  
06a2 18 03			jr .pastdmark  
06a4 ..			.dmark: db "SCA"  
06a7 f1			.pastdmark: pop af  
06a8			endm  
# End of macro DMARK
06a8					CALLMONITOR 
06a8 cd bb 13			call break_point_state  
06ab				endm  
# End of macro CALLMONITOR
06ab				endif 
06ab			 
06ab				; write file header page 
06ab			 
06ab 2a 4f eb			ld hl,(store_tmppageid) 
06ae 11 65 eb			ld de, store_page 
06b1				if DEBUG_STORESE 
06b1					DMARK "SCb" 
06b1 f5				push af  
06b2 3a c6 06			ld a, (.dmark)  
06b5 32 7a ee			ld (debug_mark),a  
06b8 3a c7 06			ld a, (.dmark+1)  
06bb 32 7b ee			ld (debug_mark+1),a  
06be 3a c8 06			ld a, (.dmark+2)  
06c1 32 7c ee			ld (debug_mark+2),a  
06c4 18 03			jr .pastdmark  
06c6 ..			.dmark: db "SCb"  
06c9 f1			.pastdmark: pop af  
06ca			endm  
# End of macro DMARK
06ca					;push af 
06ca					;ld a, 'b' 
06ca					;ld (debug_mark),a 
06ca					;pop af 
06ca					CALLMONITOR 
06ca cd bb 13			call break_point_state  
06cd				endm  
# End of macro CALLMONITOR
06cd				endif 
06cd cd 16 02			call storage_write_block 
06d0			 
06d0 3a 5e eb			ld a, (store_tmpid) 
06d3 6f				ld l, a 
06d4 26 00			ld h,0 
06d6				if DEBUG_STORESE 
06d6					DMARK "SCz" 
06d6 f5				push af  
06d7 3a eb 06			ld a, (.dmark)  
06da 32 7a ee			ld (debug_mark),a  
06dd 3a ec 06			ld a, (.dmark+1)  
06e0 32 7b ee			ld (debug_mark+1),a  
06e3 3a ed 06			ld a, (.dmark+2)  
06e6 32 7c ee			ld (debug_mark+2),a  
06e9 18 03			jr .pastdmark  
06eb ..			.dmark: db "SCz"  
06ee f1			.pastdmark: pop af  
06ef			endm  
# End of macro DMARK
06ef					CALLMONITOR 
06ef cd bb 13			call break_point_state  
06f2				endm  
# End of macro CALLMONITOR
06f2				endif 
06f2 c9				ret 
06f3				 
06f3			 
06f3			 
06f3			; 
06f3			; Read File 
06f3			; 
06f3			; h - file id to locate 
06f3			; l - extent to locate 
06f3			; de - pointer to string to read into 
06f3			; 
06f3			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
06f3			storage_read: 
06f3 d5				push de 
06f4			 
06f4			; TODO BUG the above push is it popped before the RET Z? 
06f4			 
06f4			; TODO how to handle multiple part blocks 
06f4			 
06f4				; locate file extent to read 
06f4			 
06f4 5c				ld e, h 
06f5 55				ld d, l 
06f6 21 40 00			ld hl, STORE_BLOCK_PHY 
06f9				if DEBUG_STORESE 
06f9					DMARK "SRE" 
06f9 f5				push af  
06fa 3a 0e 07			ld a, (.dmark)  
06fd 32 7a ee			ld (debug_mark),a  
0700 3a 0f 07			ld a, (.dmark+1)  
0703 32 7b ee			ld (debug_mark+1),a  
0706 3a 10 07			ld a, (.dmark+2)  
0709 32 7c ee			ld (debug_mark+2),a  
070c 18 03			jr .pastdmark  
070e ..			.dmark: db "SRE"  
0711 f1			.pastdmark: pop af  
0712			endm  
# End of macro DMARK
0712					CALLMONITOR 
0712 cd bb 13			call break_point_state  
0715				endm  
# End of macro CALLMONITOR
0715				endif 
0715 cd cf 04			call storage_findnextid 
0718			 
0718				if DEBUG_STORESE 
0718					DMARK "SRf" 
0718 f5				push af  
0719 3a 2d 07			ld a, (.dmark)  
071c 32 7a ee			ld (debug_mark),a  
071f 3a 2e 07			ld a, (.dmark+1)  
0722 32 7b ee			ld (debug_mark+1),a  
0725 3a 2f 07			ld a, (.dmark+2)  
0728 32 7c ee			ld (debug_mark+2),a  
072b 18 03			jr .pastdmark  
072d ..			.dmark: db "SRf"  
0730 f1			.pastdmark: pop af  
0731			endm  
# End of macro DMARK
0731					CALLMONITOR 
0731 cd bb 13			call break_point_state  
0734				endm  
# End of macro CALLMONITOR
0734				endif 
0734 cd 9d 0b			call ishlzero 
0737			;	ld a, l 
0737			;	add h 
0737			;	cp 0 
0737 c8				ret z			; block not found so EOF 
0738			 
0738				; hl contains page number to load 
0738 d1				pop de   ; get storage 
0739 d5				push de 
073a				if DEBUG_STORESE 
073a					DMARK "SRg" 
073a f5				push af  
073b 3a 4f 07			ld a, (.dmark)  
073e 32 7a ee			ld (debug_mark),a  
0741 3a 50 07			ld a, (.dmark+1)  
0744 32 7b ee			ld (debug_mark+1),a  
0747 3a 51 07			ld a, (.dmark+2)  
074a 32 7c ee			ld (debug_mark+2),a  
074d 18 03			jr .pastdmark  
074f ..			.dmark: db "SRg"  
0752 f1			.pastdmark: pop af  
0753			endm  
# End of macro DMARK
0753					CALLMONITOR 
0753 cd bb 13			call break_point_state  
0756				endm  
# End of macro CALLMONITOR
0756				endif 
0756 cd b1 01			call storage_read_block 
0759			 
0759			 
0759			; TODO if block has no zeros then need to read next block  
0759			 
0759			 
0759					 
0759 e1				pop hl 		 ; return start of data to show as not EOF 
075a 23				inc hl   ; past file id 
075b 23				inc hl   ; past ext 
075c				if DEBUG_STORESE 
075c					DMARK "SRe" 
075c f5				push af  
075d 3a 71 07			ld a, (.dmark)  
0760 32 7a ee			ld (debug_mark),a  
0763 3a 72 07			ld a, (.dmark+1)  
0766 32 7b ee			ld (debug_mark+1),a  
0769 3a 73 07			ld a, (.dmark+2)  
076c 32 7c ee			ld (debug_mark+2),a  
076f 18 03			jr .pastdmark  
0771 ..			.dmark: db "SRe"  
0774 f1			.pastdmark: pop af  
0775			endm  
# End of macro DMARK
0775					CALLMONITOR 
0775 cd bb 13			call break_point_state  
0778				endm  
# End of macro CALLMONITOR
0778				endif 
0778 c9					ret 
0779			 
0779			 
0779			 
0779			; 
0779			; Append File 
0779			; 
0779			; hl - file id to locate 
0779			; de - pointer to (multi block) string to write 
0779			 
0779			 
0779			storage_append: 
0779				; hl -  file id to append to 
0779				; de - string to append 
0779			 
0779 d5				push de 
077a				 
077a				if DEBUG_STORESE 
077a					DMARK "AP1" 
077a f5				push af  
077b 3a 8f 07			ld a, (.dmark)  
077e 32 7a ee			ld (debug_mark),a  
0781 3a 90 07			ld a, (.dmark+1)  
0784 32 7b ee			ld (debug_mark+1),a  
0787 3a 91 07			ld a, (.dmark+2)  
078a 32 7c ee			ld (debug_mark+2),a  
078d 18 03			jr .pastdmark  
078f ..			.dmark: db "AP1"  
0792 f1			.pastdmark: pop af  
0793			endm  
# End of macro DMARK
0793					CALLMONITOR 
0793 cd bb 13			call break_point_state  
0796				endm  
# End of macro CALLMONITOR
0796				endif 
0796			 
0796 7d				ld a, l 
0797 32 5e eb			ld (store_tmpid), a 
079a			 
079a				; get file header  
079a			 
079a 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
079c 3a 5e eb			ld a, (store_tmpid) 
079f 5f				ld e, a 
07a0			 
07a0 21 40 00				ld hl, STORE_BLOCK_PHY 
07a3 cd cf 04				call storage_findnextid 
07a6			 
07a6 22 4f eb			ld (store_tmppageid), hl 
07a9			 
07a9				; TODO handle file id not found 
07a9			 
07a9				if DEBUG_STORESE 
07a9					DMARK "AP2" 
07a9 f5				push af  
07aa 3a be 07			ld a, (.dmark)  
07ad 32 7a ee			ld (debug_mark),a  
07b0 3a bf 07			ld a, (.dmark+1)  
07b3 32 7b ee			ld (debug_mark+1),a  
07b6 3a c0 07			ld a, (.dmark+2)  
07b9 32 7c ee			ld (debug_mark+2),a  
07bc 18 03			jr .pastdmark  
07be ..			.dmark: db "AP2"  
07c1 f1			.pastdmark: pop af  
07c2			endm  
# End of macro DMARK
07c2					CALLMONITOR 
07c2 cd bb 13			call break_point_state  
07c5				endm  
# End of macro CALLMONITOR
07c5				endif 
07c5			 
07c5				; update file extent count 
07c5			 
07c5 11 65 eb			ld de, store_page 
07c8			 
07c8 cd b1 01			call storage_read_block 
07cb			 
07cb				if DEBUG_STORESE 
07cb					DMARK "AP3" 
07cb f5				push af  
07cc 3a e0 07			ld a, (.dmark)  
07cf 32 7a ee			ld (debug_mark),a  
07d2 3a e1 07			ld a, (.dmark+1)  
07d5 32 7b ee			ld (debug_mark+1),a  
07d8 3a e2 07			ld a, (.dmark+2)  
07db 32 7c ee			ld (debug_mark+2),a  
07de 18 03			jr .pastdmark  
07e0 ..			.dmark: db "AP3"  
07e3 f1			.pastdmark: pop af  
07e4			endm  
# End of macro DMARK
07e4					CALLMONITOR 
07e4 cd bb 13			call break_point_state  
07e7				endm  
# End of macro CALLMONITOR
07e7				endif 
07e7			;	ld (store_tmppageid), hl 
07e7			 
07e7 3a 67 eb			ld a, (store_page+2) 
07ea 3c				inc a 
07eb 32 67 eb			ld (store_page+2), a 
07ee 32 5d eb			ld (store_tmpext), a 
07f1				 
07f1				if DEBUG_STORESE 
07f1					DMARK "AP3" 
07f1 f5				push af  
07f2 3a 06 08			ld a, (.dmark)  
07f5 32 7a ee			ld (debug_mark),a  
07f8 3a 07 08			ld a, (.dmark+1)  
07fb 32 7b ee			ld (debug_mark+1),a  
07fe 3a 08 08			ld a, (.dmark+2)  
0801 32 7c ee			ld (debug_mark+2),a  
0804 18 03			jr .pastdmark  
0806 ..			.dmark: db "AP3"  
0809 f1			.pastdmark: pop af  
080a			endm  
# End of macro DMARK
080a					CALLMONITOR 
080a cd bb 13			call break_point_state  
080d				endm  
# End of macro CALLMONITOR
080d				endif 
080d 2a 4f eb			ld hl, (store_tmppageid) 
0810 11 65 eb			ld de, store_page 
0813 cd 16 02			call storage_write_block 
0816			 
0816				; find free block 
0816			 
0816 11 00 00			ld de, 0			 ; file extent to locate 
0819			 
0819 21 40 00				ld hl, STORE_BLOCK_PHY 
081c cd cf 04				call storage_findnextid 
081f			 
081f					; TODO handle no space left 
081f					 
081f 22 4f eb				ld (store_tmppageid), hl 
0822			 
0822				if DEBUG_STORESE 
0822					DMARK "AP4" 
0822 f5				push af  
0823 3a 37 08			ld a, (.dmark)  
0826 32 7a ee			ld (debug_mark),a  
0829 3a 38 08			ld a, (.dmark+1)  
082c 32 7b ee			ld (debug_mark+1),a  
082f 3a 39 08			ld a, (.dmark+2)  
0832 32 7c ee			ld (debug_mark+2),a  
0835 18 03			jr .pastdmark  
0837 ..			.dmark: db "AP4"  
083a f1			.pastdmark: pop af  
083b			endm  
# End of macro DMARK
083b					CALLMONITOR 
083b cd bb 13			call break_point_state  
083e				endm  
# End of macro CALLMONITOR
083e				endif 
083e					; init the buffer with zeros so we can id if the buffer is full or not 
083e			 
083e e5					push hl 
083f c5					push bc 
0840			 
0840 21 65 eb				ld hl, store_page 
0843 06 40				ld b, STORE_BLOCK_PHY 
0845 3e 00				ld a, 0 
0847 77			.zeroblock:	ld (hl), a 
0848 23					inc hl 
0849 10 fc				djnz .zeroblock 
084b			 
084b c1					pop bc 
084c e1					pop hl 
084d			 
084d					; construct block 
084d			 
084d 3a 5e eb				ld a, (store_tmpid) 
0850 32 65 eb				ld (store_page), a   ; file id 
0853 3a 5d eb				ld a, (store_tmpext)   ; extent for this block 
0856 32 66 eb				ld (store_page+1), a 
0859			 
0859 e1					pop hl    ; get string to write 
085a 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
085c 11 67 eb				ld de, store_page+2 
085f			 
085f				if DEBUG_STORESE 
085f					DMARK "AP5" 
085f f5				push af  
0860 3a 74 08			ld a, (.dmark)  
0863 32 7a ee			ld (debug_mark),a  
0866 3a 75 08			ld a, (.dmark+1)  
0869 32 7b ee			ld (debug_mark+1),a  
086c 3a 76 08			ld a, (.dmark+2)  
086f 32 7c ee			ld (debug_mark+2),a  
0872 18 03			jr .pastdmark  
0874 ..			.dmark: db "AP5"  
0877 f1			.pastdmark: pop af  
0878			endm  
# End of macro DMARK
0878					CALLMONITOR 
0878 cd bb 13			call break_point_state  
087b				endm  
# End of macro CALLMONITOR
087b				endif 
087b			 
087b			 
087b			 
087b					; fill buffer with data until end of string or full block 
087b			 
087b 7e			.appd:		ld a, (hl) 
087c 12					ld (de), a 
087d fe 00				cp 0 
087f 28 04				jr z, .appdone 
0881 23					inc hl 
0882 13					inc de 
0883 10 f6				djnz .appd 
0885			 
0885 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0886 f5					push af   		; save last byte dumped 
0887			 
0887			 
0887 2a 4f eb			ld hl, (store_tmppageid) 
088a 11 65 eb			ld de, store_page 
088d				if DEBUG_STORESE 
088d					DMARK "AP6" 
088d f5				push af  
088e 3a a2 08			ld a, (.dmark)  
0891 32 7a ee			ld (debug_mark),a  
0894 3a a3 08			ld a, (.dmark+1)  
0897 32 7b ee			ld (debug_mark+1),a  
089a 3a a4 08			ld a, (.dmark+2)  
089d 32 7c ee			ld (debug_mark+2),a  
08a0 18 03			jr .pastdmark  
08a2 ..			.dmark: db "AP6"  
08a5 f1			.pastdmark: pop af  
08a6			endm  
# End of macro DMARK
08a6					CALLMONITOR 
08a6 cd bb 13			call break_point_state  
08a9				endm  
# End of macro CALLMONITOR
08a9				endif 
08a9 cd 16 02				call storage_write_block 
08ac			 
08ac			 
08ac				; was that a full block of data written? 
08ac				; any more to write out? 
08ac			 
08ac				; if yes then set vars and jump to start of function again 
08ac			 
08ac f1					pop af 
08ad d1					pop de 
08ae			 
08ae fe 00				cp 0		 ; no, string was fully written 
08b0 c8					ret z 
08b1			 
08b1					; setup vars for next cycle 
08b1			 
08b1 3a 5e eb				ld a, (store_tmpid) 
08b4 6f					ld l, a 
08b5 26 00				ld h, 0 
08b7			 
08b7 c3 79 07			 	jp storage_append	 ; yes, need to write out some more 
08ba			 
08ba			 
08ba			 
08ba			 
08ba			 
08ba			 
08ba			 
08ba			if DEBUG_STORECF 
08ba			storageput:	 
08ba					ret 
08ba			storageread: 
08ba					ld hl, store_page 
08ba					ld b, 200 
08ba					ld a,0 
08ba			.src:		ld (hl),a 
08ba					inc hl 
08ba					djnz .src 
08ba					 
08ba			 
08ba					ld de, 0 
08ba					ld bc, 1 
08ba					ld hl, store_page 
08ba					call cfRead 
08ba			 
08ba				call cfGetError 
08ba				ld hl,scratch 
08ba				call hexout 
08ba				ld hl, scratch+2 
08ba				ld a, 0 
08ba				ld (hl),a 
08ba				ld de, scratch 
08ba				ld a,display_row_1 
08ba				call str_at_display 
08ba				call update_display 
08ba			 
08ba					ld hl, store_page 
08ba					ld (os_cur_ptr),hl 
08ba			 
08ba					ret 
08ba			endif 
08ba			 
08ba			 
08ba			; Clear out the main buffer store (used to remove junk before writing a new block) 
08ba			 
08ba			storage_clear_page: 
08ba e5				push hl 
08bb d5				push de 
08bc c5				push bc 
08bd 21 65 eb			ld hl, store_page 
08c0 3e 00			ld a, 0 
08c2 77				ld (hl), a 
08c3			 
08c3 11 66 eb			ld de, store_page+1 
08c6 01 40 00			ld bc, STORE_BLOCK_PHY 
08c9			 
08c9 ed b0			ldir 
08cb				 
08cb c1				pop bc 
08cc d1				pop de 
08cd e1				pop hl 
08ce c9				ret 
08cf			 
08cf			; eof 
# End of file firmware_storage.asm
08cf			  
08cf			; support routines for above hardware abstraction layer  
08cf			  
08cf			include "firmware_general.asm"        ; general support functions  
08cf			 
08cf			 
08cf			 
08cf			; Delay loops 
08cf			 
08cf			 
08cf			 
08cf			aDelayInMS: 
08cf c5				push bc 
08d0 47				ld b,a 
08d1			msdelay: 
08d1 c5				push bc 
08d2				 
08d2			 
08d2 01 41 00			ld bc,041h 
08d5 cd ed 08			call delayloop 
08d8 c1				pop bc 
08d9 05				dec b 
08da 20 f5			jr nz,msdelay 
08dc			 
08dc			;if CPU_CLOCK_8MHZ 
08dc			;msdelay8: 
08dc			;	push bc 
08dc			;	 
08dc			; 
08dc			;	ld bc,041h 
08dc			;	call delayloop 
08dc			;	pop bc 
08dc			;	dec b 
08dc			;	jr nz,msdelay8 
08dc			;endif 
08dc			 
08dc			 
08dc c1				pop bc 
08dd c9				ret 
08de			 
08de			 
08de			delay250ms: 
08de				;push de 
08de 01 00 40			ld bc, 04000h 
08e1 c3 ed 08			jp delayloop 
08e4			delay500ms: 
08e4				;push de 
08e4 01 00 80			ld bc, 08000h 
08e7 c3 ed 08			jp delayloop 
08ea			delay1s: 
08ea				;push bc 
08ea			   ; Clobbers A, d and e 
08ea 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
08ed			delayloop: 
08ed c5			    push bc 
08ee			 
08ee			if BASE_CPM 
08ee 01 a0 0f			ld bc, CPM_DELAY_TUNE 
08f1			.cpmloop: 
08f1 c5				push bc 
08f2			 
08f2			endif 
08f2			 
08f2			 
08f2			 
08f2			delayloopi: 
08f2			;	push bc 
08f2			;.dl: 
08f2 cb 47		    bit     0,a    	; 8 
08f4 cb 47		    bit     0,a    	; 8 
08f6 cb 47		    bit     0,a    	; 8 
08f8 e6 ff		    and     255  	; 7 
08fa 0b			    dec     bc      	; 6 
08fb 79			    ld      a,c     	; 4 
08fc b0			    or      b     	; 4 
08fd c2 f2 08		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0900			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0900				;pop de 
0900			;pop bc 
0900			 
0900			if BASE_CPM 
0900 c1				pop bc 
0901				 
0901 0b			    dec     bc      	; 6 
0902 79			    ld      a,c     	; 4 
0903 b0			    or      b     	; 4 
0904 c2 f1 08		    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0907				 
0907			 
0907			endif 
0907			;if CPU_CLOCK_8MHZ 
0907			;    pop bc 
0907			;    push bc 
0907			;.dl8: 
0907			;    bit     0,a    	; 8 
0907			;    bit     0,a    	; 8 
0907			;    bit     0,a    	; 8 
0907			;    and     255  	; 7 
0907			;    dec     bc      	; 6 
0907			;    ld      a,c     	; 4 
0907			;    or      b     	; 4 
0907			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0907			;endif 
0907			 
0907			;if CPU_CLOCK_10MHZ 
0907			;    pop bc 
0907			;    push bc 
0907			;.dl8: 
0907			;    bit     0,a    	; 8 
0907			;    bit     0,a    	; 8 
0907			;    bit     0,a    	; 8 
0907			;    and     255  	; 7 
0907			;    dec     bc      	; 6 
0907			;    ld      a,c     	; 4 
0907			;    or      b     	; 4 
0907			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0907			;endif 
0907 c1			    pop bc 
0908			 
0908 c9				ret 
0909			 
0909			 
0909			 
0909			; eof 
# End of file firmware_general.asm
0909			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0909			; display routines that use the physical hardware abstraction layer 
0909			 
0909			 
0909			; TODO windowing? 
0909			 
0909			; TODO scroll line up 
0909			 
0909			scroll_up: 
0909			 
0909 e5				push hl 
090a d5				push de 
090b c5				push bc 
090c			 
090c				; get frame buffer  
090c			 
090c 2a db eb			ld hl, (display_fb_active) 
090f e5				push hl    ; future de destination 
0910			 
0910 11 28 00			ld  de, display_cols 
0913 19				add hl, de 
0914			 
0914 d1				pop de 
0915			 
0915				;ex de, hl 
0915 01 9f 00			ld bc, display_fb_len -1  
0918			;if DEBUG_FORTH_WORDS 
0918			;	DMARK "SCL" 
0918			;	CALLMONITOR 
0918			;endif	 
0918 ed b0			ldir 
091a			 
091a				; wipe bottom row 
091a			 
091a			 
091a 2a db eb			ld hl, (display_fb_active) 
091d 11 a0 00			ld de, display_cols*display_rows 
0920 19				add hl, de 
0921 06 28			ld b, display_cols 
0923 3e 20			ld a, ' ' 
0925			.scwipe: 
0925 77				ld (hl), a 
0926 2b				dec hl 
0927 10 fc			djnz .scwipe 
0929			 
0929				;pop hl 
0929			 
0929 c1				pop bc 
092a d1				pop de 
092b e1				pop hl 
092c			 
092c c9				ret 
092d			 
092d			 
092d			;scroll_upo: 
092d			;	ld de, display_row_1 
092d			 ;	ld hl, display_row_2 
092d			;	ld bc, display_cols 
092d			;	ldir 
092d			;	ld de, display_row_2 
092d			 ;	ld hl, display_row_3 
092d			;	ld bc, display_cols 
092d			;	ldir 
092d			;	ld de, display_row_3 
092d			 ;	ld hl, display_row_4 
092d			;	ld bc, display_cols 
092d			;	ldir 
092d			 
092d			; TODO clear row 4 
092d			 
092d			;	ret 
092d			 
092d				 
092d			scroll_down: 
092d			 
092d e5				push hl 
092e d5				push de 
092f c5				push bc 
0930			 
0930				; get frame buffer  
0930			 
0930 2a db eb			ld hl, (display_fb_active) 
0933			 
0933 11 9f 00			ld de, display_fb_len - 1 
0936 19				add hl, de 
0937			 
0937 e5			push hl    ; future de destination 
0938			 
0938 11 28 00			ld  de, display_cols 
093b ed 52			sbc hl, de 
093d			 
093d			 
093d d1				pop de 
093e			 
093e			;	ex de, hl 
093e 01 9f 00			ld bc, display_fb_len -1  
0941			 
0941			 
0941				 
0941			 
0941 ed b0			ldir 
0943			 
0943				; wipe bottom row 
0943			 
0943			 
0943			;	ld hl, (display_fb_active) 
0943			;;	ld de, display_cols*display_rows 
0943			;;	add hl, de 
0943			;	ld b, display_cols 
0943			;	ld a, ' ' 
0943			;.scwiped: 
0943			;	ld (hl), a 
0943			;	dec hl 
0943			;	djnz .scwiped 
0943			 
0943				;pop hl 
0943			 
0943 c1				pop bc 
0944 d1				pop de 
0945 e1				pop hl 
0946			 
0946 c9				ret 
0947			;scroll_down: 
0947			;	ld de, display_row_4 
0947			;	ld hl, display_row_3 
0947			;	ld bc, display_cols 
0947			;	ldir 
0947			;	ld de, display_row_3 
0947			; 	ld hl, display_row_2 
0947			;	ld bc, display_cols 
0947			;	ldir 
0947			;	ld de, display_row_2 
0947			;	ld hl, display_row_1 
0947			;	ld bc, display_cols 
0947			;	ldir 
0947			;;; TODO clear row 1 
0947			;	ret 
0947			 
0947			 
0947			 
0947			 
0947			 
0947			; clear active frame buffer 
0947			 
0947			clear_display: 
0947 3e 20			ld a, ' ' 
0949 c3 4c 09			jp fill_display 
094c			 
094c			; fill active frame buffer with a char in A 
094c			 
094c			fill_display: 
094c 06 a0			ld b,display_fb_len 
094e 2a db eb			ld hl, (display_fb_active) 
0951 77			.fd1:	ld (hl),a 
0952 23				inc hl 
0953 10 fc			djnz .fd1 
0955 23				inc hl 
0956 3e 00			ld a,0 
0958 77				ld (hl),a 
0959			 
0959			 
0959 c9				ret 
095a			; Write string (DE) at pos (A) to active frame buffer 
095a			 
095a 2a db eb		str_at_display:    ld hl,(display_fb_active) 
095d 06 00					ld b,0 
095f 4f					ld c,a 
0960 09					add hl,bc 
0961 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0962 b7			            OR   A              ;Null terminator? 
0963 c8			            RET  Z              ;Yes, so finished 
0964 77					ld (hl),a 
0965 23				inc hl 
0966 13			            INC  DE             ;Point to next character 
0967 18 f8		            JR   .sad1     ;Repeat 
0969 c9					ret 
096a			 
096a			; using current frame buffer write to physical display 
096a			 
096a			update_display: 
096a e5				push hl 
096b 2a db eb			ld hl, (display_fb_active) 
096e cd c0 58			call write_display 
0971 e1				pop hl 
0972 c9				ret 
0973			 
0973			; TODO scrolling 
0973			 
0973			 
0973			; move cursor right one char 
0973			cursor_right: 
0973			 
0973				; TODO shift right 
0973				; TODO if beyond max col 
0973				; TODO       cursor_next_line 
0973			 
0973 c9				ret 
0974			 
0974			 
0974			cursor_next_line: 
0974				; TODO first char 
0974				; TODO line down 
0974				; TODO if past last row 
0974				; TODO    scroll up 
0974			 
0974 c9				ret 
0975			 
0975			cursor_left: 
0975				; TODO shift left 
0975				; TODO if beyond left  
0975				; TODO     cursor prev line 
0975				 
0975 c9				ret 
0976			 
0976			cursor_prev_line: 
0976				; TODO last char 
0976				; TODO line up 
0976				; TODO if past first row 
0976				; TODO   scroll down 
0976			 
0976 c9				ret 
0977			 
0977			 
0977			cout: 
0977				; A - char 
0977 c9				ret 
0978			 
0978			 
0978			; Display a menu and allow item selection (optional toggle items) 
0978			; 
0978			; format: 
0978			; hl pointer to word array with zero term for items 
0978			; e.g.    db item1 
0978			;         db .... 
0978			;         db 0 
0978			; 
0978			; a = starting menu item  
0978			; 
0978			; de = pointer item toggle array   (todo) 
0978			; 
0978			; returns item selected in a 1-... 
0978			; returns 0 if back button pressed 
0978			; 
0978			; NOTE: Uses system frame buffer to display 
0978			; 
0978			; LEFT, Q = go back 
0978			; RIGHT, SPACE, CR = select 
0978			; UP, A - Up 
0978			; DOWN, Z - Down 
0978			 
0978			 
0978			 
0978			 
0978			 
0978			menu: 
0978			 
0978					; keep array pointer 
0978			 
0978 22 63 eb				ld (store_tmp1), hl 
097b 32 61 eb				ld (store_tmp2), a 
097e			 
097e					; check for key bounce 
097e			 
097e			if BASE_KEV 
097e			 
097e			.mbounce:	call cin 
097e					cp 0 
097e					jr nz, .mbounce 
097e			endif 
097e					; for ease use ex 
097e			 
097e					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
097e 21 c0 ed				ld hl, display_fb0 
0981 22 db eb				ld (display_fb_active), hl 
0984			 
0984 cd 47 09		.mloop:		call clear_display 
0987 cd 6a 09				call update_display 
098a			 
098a					; draw selection id '>' at 1 
098a			 
098a					; init start of list display 
098a			 
098a 3e 05				ld a, 5 
098c 32 5f eb				ld (store_tmp3), a   ; display row count 
098f 3a 61 eb				ld a,( store_tmp2) 
0992 32 62 eb				ld (store_tmp2+1), a   ; display item count 
0995			 
0995					 
0995			.mitem:	 
0995			 
0995			 
0995 3a 62 eb				ld a,(store_tmp2+1) 
0998 6f					ld l, a 
0999 26 00				ld h, 0 
099b 29					add hl, hl 
099c ed 5b 63 eb			ld de, (store_tmp1) 
09a0 19					add hl, de 
09a1 7e					ld a, (hl) 
09a2 23					inc hl 
09a3 66					ld h,(hl) 
09a4 6f					ld l, a 
09a5			 
09a5 cd 9d 0b				call ishlzero 
09a8 28 1a				jr z, .mdone 
09aa			 
09aa eb					ex de, hl 
09ab 3a 5f eb				ld a, (store_tmp3) 
09ae cd 5a 09				call str_at_display 
09b1					 
09b1			 
09b1					; next item 
09b1 3a 62 eb				ld a, (store_tmp2+1) 
09b4 3c					inc a 
09b5 32 62 eb				ld (store_tmp2+1), a   ; display item count 
09b8			 
09b8			 		; next row 
09b8			 
09b8 3a 5f eb				ld a, (store_tmp3) 
09bb c6 28				add display_cols 
09bd 32 5f eb				ld (store_tmp3), a 
09c0			 
09c0					; at end of screen? 
09c0			 
09c0 fe 10				cp display_rows*4 
09c2 20 d1				jr nz, .mitem 
09c4			 
09c4			 
09c4			.mdone: 
09c4 cd 9d 0b				call ishlzero 
09c7 28 08				jr z, .nodn 
09c9			 
09c9 3e 78				ld a, display_row_4 
09cb 11 4a 0a				ld de, .mdown 
09ce cd 5a 09				call str_at_display 
09d1			 
09d1					; draw options to fill the screens with active item on line 1 
09d1					; if current option is 2 or more then display ^ in top 
09d1			 
09d1 3a 61 eb		.nodn:		ld a, (store_tmp2) 
09d4 fe 00				cp 0 
09d6 28 08				jr z, .noup 
09d8			 
09d8 3e 00				ld a, 0 
09da 11 48 0a				ld de, .mup 
09dd cd 5a 09				call str_at_display 
09e0			 
09e0 3e 02		.noup:		ld a, 2 
09e2 11 46 0a				ld de, .msel 
09e5 cd 5a 09				call str_at_display 
09e8			 
09e8					; if current option + 1 is not null then display V in bottom 
09e8					; get key 
09e8 cd 6a 09				call update_display 
09eb			 
09eb			 
09eb					; handle key 
09eb			 
09eb cd 72 59				call cin_wait 
09ee			 
09ee fe 05				cp KEY_UP 
09f0 28 2b				jr z, .mgoup 
09f2 fe 61				cp 'a' 
09f4 28 27				jr z, .mgoup 
09f6 fe 0a				cp KEY_DOWN 
09f8 28 32				jr z, .mgod 
09fa fe 7a				cp 'z' 
09fc 28 2e				jr z, .mgod 
09fe fe 20				cp ' ' 
0a00 28 34				jr z, .goend 
0a02 fe 0c				cp KEY_RIGHT 
0a04 28 30				jr z, .goend 
0a06 fe 0d				cp KEY_CR 
0a08 28 2c				jr z, .goend 
0a0a fe 71				cp 'q' 
0a0c 28 0b				jr z, .goback 
0a0e			 
0a0e fe 0b				cp KEY_LEFT 
0a10 28 07				jr z, .goback 
0a12 fe 08				cp KEY_BS 
0a14 28 03				jr z, .goback 
0a16 c3 84 09				jp .mloop 
0a19			 
0a19			.goback: 
0a19 3e 00			ld a, 0 
0a1b 18 1d			jr .goend2 
0a1d			 
0a1d				; move up one 
0a1d			.mgoup: 
0a1d 3a 61 eb				ld a, (store_tmp2) 
0a20 fe 00				cp 0 
0a22 ca 84 09				jp z, .mloop 
0a25 3d					dec a 
0a26 32 61 eb				ld (store_tmp2), a 
0a29 c3 84 09				jp .mloop 
0a2c			 
0a2c				; move down one 
0a2c			.mgod: 
0a2c 3a 61 eb				ld a, (store_tmp2) 
0a2f 3c					inc a 
0a30 32 61 eb				ld (store_tmp2), a 
0a33 c3 84 09				jp .mloop 
0a36			 
0a36			 
0a36			.goend: 
0a36					; get selected item number 
0a36			 
0a36 3a 61 eb				ld a, (store_tmp2) 
0a39 3c					inc a 
0a3a			 
0a3a			.goend2: 
0a3a f5					push af 
0a3b			 
0a3b					; restore active fb 
0a3b					; TODO BUG assumes fb1 
0a3b			 
0a3b 21 1f ed				ld hl, display_fb1 
0a3e 22 db eb				ld (display_fb_active), hl 
0a41			 
0a41					; restore main regs 
0a41			 
0a41			 
0a41 cd 6a 09				call update_display 
0a44			 
0a44 f1					pop af 
0a45			 
0a45 c9				ret 
0a46			 
0a46 .. 00		.msel:   db ">",0 
0a48 .. 00		.mup:   db "^",0 
0a4a .. 00		.mdown:   db "v",0 
0a4c			 
0a4c			 
0a4c			; eof 
0a4c			 
# End of file firmware_display.asm
0a4c			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0a4c			; random number generators 
0a4c			 
0a4c			 
0a4c			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0a4c			 
0a4c			 
0a4c			;-----> Generate a random number 
0a4c			; output a=answer 0<=a<=255 
0a4c			; all registers are preserved except: af 
0a4c			random: 
0a4c e5			        push    hl 
0a4d d5			        push    de 
0a4e 2a bd eb		        ld      hl,(randData) 
0a51 ed 5f		        ld      a,r 
0a53 57			        ld      d,a 
0a54 5e			        ld      e,(hl) 
0a55 19			        add     hl,de 
0a56 85			        add     a,l 
0a57 ac			        xor     h 
0a58 22 bd eb		        ld      (randData),hl 
0a5b d1			        pop     de 
0a5c e1			        pop     hl 
0a5d c9			        ret 
0a5e			 
0a5e			 
0a5e			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0a5e			 
0a5e			 
0a5e			 
0a5e			;------LFSR------ 
0a5e			;James Montelongo 
0a5e			;optimized by Spencer Putt 
0a5e			;out: 
0a5e			; a = 8 bit random number 
0a5e			RandLFSR: 
0a5e 21 c3 eb		        ld hl,LFSRSeed+4 
0a61 5e			        ld e,(hl) 
0a62 23			        inc hl 
0a63 56			        ld d,(hl) 
0a64 23			        inc hl 
0a65 4e			        ld c,(hl) 
0a66 23			        inc hl 
0a67 7e			        ld a,(hl) 
0a68 47			        ld b,a 
0a69 cb 13		        rl e  
0a6b cb 12			rl d 
0a6d cb 11		        rl c  
0a6f 17				rla 
0a70 cb 13		        rl e  
0a72 cb 12			rl d 
0a74 cb 11		        rl c  
0a76 17				rla 
0a77 cb 13		        rl e  
0a79 cb 12			rl d 
0a7b cb 11		        rl c  
0a7d 17				rla 
0a7e 67			        ld h,a 
0a7f cb 13		        rl e  
0a81 cb 12			rl d 
0a83 cb 11		        rl c  
0a85 17				rla 
0a86 a8			        xor b 
0a87 cb 13		        rl e  
0a89 cb 12			rl d 
0a8b ac			        xor h 
0a8c a9			        xor c 
0a8d aa			        xor d 
0a8e 21 c5 eb		        ld hl,LFSRSeed+6 
0a91 11 c6 eb		        ld de,LFSRSeed+7 
0a94 01 07 00		        ld bc,7 
0a97 ed b8		        lddr 
0a99 12			        ld (de),a 
0a9a c9			        ret 
0a9b			 
0a9b			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0a9b			 
0a9b			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0a9b			 
0a9b			 
0a9b			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0a9b			 
0a9b			prng16: 
0a9b			;Inputs: 
0a9b			;   (seed1) contains a 16-bit seed value 
0a9b			;   (seed2) contains a NON-ZERO 16-bit seed value 
0a9b			;Outputs: 
0a9b			;   HL is the result 
0a9b			;   BC is the result of the LCG, so not that great of quality 
0a9b			;   DE is preserved 
0a9b			;Destroys: 
0a9b			;   AF 
0a9b			;cycle: 4,294,901,760 (almost 4.3 billion) 
0a9b			;160cc 
0a9b			;26 bytes 
0a9b 2a b7 eb		    ld hl,(seed1) 
0a9e 44			    ld b,h 
0a9f 4d			    ld c,l 
0aa0 29			    add hl,hl 
0aa1 29			    add hl,hl 
0aa2 2c			    inc l 
0aa3 09			    add hl,bc 
0aa4 22 b7 eb		    ld (seed1),hl 
0aa7 2a b5 eb		    ld hl,(seed2) 
0aaa 29			    add hl,hl 
0aab 9f			    sbc a,a 
0aac e6 2d		    and %00101101 
0aae ad			    xor l 
0aaf 6f			    ld l,a 
0ab0 22 b5 eb		    ld (seed2),hl 
0ab3 09			    add hl,bc 
0ab4 c9			    ret 
0ab5			 
0ab5			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0ab5			 
0ab5			rand32: 
0ab5			;Inputs: 
0ab5			;   (seed1_0) holds the lower 16 bits of the first seed 
0ab5			;   (seed1_1) holds the upper 16 bits of the first seed 
0ab5			;   (seed2_0) holds the lower 16 bits of the second seed 
0ab5			;   (seed2_1) holds the upper 16 bits of the second seed 
0ab5			;   **NOTE: seed2 must be non-zero 
0ab5			;Outputs: 
0ab5			;   HL is the result 
0ab5			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0ab5			;Destroys: 
0ab5			;   AF 
0ab5			;Tested and passes all CAcert tests 
0ab5			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0ab5			;it has a period of 18,446,744,069,414,584,320 
0ab5			;roughly 18.4 quintillion. 
0ab5			;LFSR taps: 0,2,6,7  = 11000101 
0ab5			;291cc 
0ab5			;seed1_0=$+1 
0ab5			;    ld hl,12345 
0ab5			;seed1_1=$+1 
0ab5			;    ld de,6789 
0ab5			;    ld b,h 
0ab5			;    ld c,l 
0ab5			;    add hl,hl \ rl e \ rl d 
0ab5			;    add hl,hl \ rl e \ rl d 
0ab5			;    inc l 
0ab5			;    add hl,bc 
0ab5			;    ld (seed1_0),hl 
0ab5			;    ld hl,(seed1_1) 
0ab5			;    adc hl,de 
0ab5			;    ld (seed1_1),hl 
0ab5			;    ex de,hl 
0ab5			;seed2_0=$+1 
0ab5			;    ld hl,9876 
0ab5			;seed2_1=$+1 
0ab5			;    ld bc,54321 
0ab5			;    add hl,hl \ rl c \ rl b 
0ab5			;    ld (seed2_1),bc 
0ab5			;    sbc a,a 
0ab5			;    and %11000101 
0ab5			;    xor l 
0ab5			;    ld l,a 
0ab5			;    ld (seed2_0),hl 
0ab5			;    ex de,hl 
0ab5			;    add hl,bc 
0ab5			;    ret 
0ab5			; 
0ab5			 
0ab5			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0ab5			; 20 bytes, 86 cycles (excluding ret) 
0ab5			 
0ab5			; returns   hl = pseudorandom number 
0ab5			; corrupts   a 
0ab5			 
0ab5			; generates 16-bit pseudorandom numbers with a period of 65535 
0ab5			; using the xorshift method: 
0ab5			 
0ab5			; hl ^= hl << 7 
0ab5			; hl ^= hl >> 9 
0ab5			; hl ^= hl << 8 
0ab5			 
0ab5			; some alternative shift triplets which also perform well are: 
0ab5			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0ab5			 
0ab5			;  org 32768 
0ab5			 
0ab5			xrnd: 
0ab5 2a bb eb		  ld hl,(xrandc)       ; seed must not be 0 
0ab8 3e 00		  ld a,0 
0aba bd			  cp l 
0abb 20 02		  jr nz, .xrnd1 
0abd 2e 01		  ld l, 1 
0abf			.xrnd1: 
0abf			 
0abf 7c			  ld a,h 
0ac0 1f			  rra 
0ac1 7d			  ld a,l 
0ac2 1f			  rra 
0ac3 ac			  xor h 
0ac4 67			  ld h,a 
0ac5 7d			  ld a,l 
0ac6 1f			  rra 
0ac7 7c			  ld a,h 
0ac8 1f			  rra 
0ac9 ad			  xor l 
0aca 6f			  ld l,a 
0acb ac			  xor h 
0acc 67			  ld h,a 
0acd			 
0acd 22 bb eb		  ld (xrandc),hl 
0ad0			 
0ad0 c9			  ret 
0ad1			;  
0ad1			 
0ad1			 
0ad1			;;;; int maths 
0ad1			 
0ad1			; https://map.grauw.nl/articles/mult_div_shifts.php 
0ad1			; Divide 16-bit values (with 16-bit result) 
0ad1			; In: Divide BC by divider DE 
0ad1			; Out: BC = result, HL = rest 
0ad1			; 
0ad1			Div16: 
0ad1 21 00 00		    ld hl,0 
0ad4 78			    ld a,b 
0ad5 06 08		    ld b,8 
0ad7			Div16_Loop1: 
0ad7 17			    rla 
0ad8 ed 6a		    adc hl,hl 
0ada ed 52		    sbc hl,de 
0adc 30 01		    jr nc,Div16_NoAdd1 
0ade 19			    add hl,de 
0adf			Div16_NoAdd1: 
0adf 10 f6		    djnz Div16_Loop1 
0ae1 17			    rla 
0ae2 2f			    cpl 
0ae3 47			    ld b,a 
0ae4 79			    ld a,c 
0ae5 48			    ld c,b 
0ae6 06 08		    ld b,8 
0ae8			Div16_Loop2: 
0ae8 17			    rla 
0ae9 ed 6a		    adc hl,hl 
0aeb ed 52		    sbc hl,de 
0aed 30 01		    jr nc,Div16_NoAdd2 
0aef 19			    add hl,de 
0af0			Div16_NoAdd2: 
0af0 10 f6		    djnz Div16_Loop2 
0af2 17			    rla 
0af3 2f			    cpl 
0af4 41			    ld b,c 
0af5 4f			    ld c,a 
0af6 c9			ret 
0af7			 
0af7			 
0af7			;http://z80-heaven.wikidot.com/math 
0af7			; 
0af7			;Inputs: 
0af7			;     DE and A are factors 
0af7			;Outputs: 
0af7			;     A is not changed 
0af7			;     B is 0 
0af7			;     C is not changed 
0af7			;     DE is not changed 
0af7			;     HL is the product 
0af7			;Time: 
0af7			;     342+6x 
0af7			; 
0af7			Mult16: 
0af7			 
0af7 06 08		     ld b,8          ;7           7 
0af9 21 00 00		     ld hl,0         ;10         10 
0afc 29			       add hl,hl     ;11*8       88 
0afd 07			       rlca          ;4*8        32 
0afe 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0b00 19			         add hl,de   ;--         -- 
0b01 10 f9		       djnz $-5      ;13*7+8     99 
0b03 c9			ret 
0b04			 
0b04			; 
0b04			; Square root of 16-bit value 
0b04			; In:  HL = value 
0b04			; Out:  D = result (rounded down) 
0b04			; 
0b04			;Sqr16: 
0b04			;    ld de,#0040 
0b04			;    ld a,l 
0b04			;    ld l,h 
0b04			;    ld h,d 
0b04			;    or a 
0b04			;    ld b,8 
0b04			;Sqr16_Loop: 
0b04			;    sbc hl,de 
0b04			;    jr nc,Sqr16_Skip 
0b04			;    add hl,de 
0b04			;Sqr16_Skip: 
0b04			;    ccf 
0b04			;    rl d 
0b04			;    add a,a 
0b04			;    adc hl,hl 
0b04			;    add a,a 
0b04			;    adc hl,hl 
0b04			;    djnz Sqr16_Loop 
0b04			;    ret 
0b04			; 
0b04			; 
0b04			; Divide 8-bit values 
0b04			; In: Divide E by divider C 
0b04			; Out: A = result, B = rest 
0b04			; 
0b04			Div8: 
0b04 af			    xor a 
0b05 06 08		    ld b,8 
0b07			Div8_Loop: 
0b07 cb 13		    rl e 
0b09 17			    rla 
0b0a 91			    sub c 
0b0b 30 01		    jr nc,Div8_NoAdd 
0b0d 81			    add a,c 
0b0e			Div8_NoAdd: 
0b0e 10 f7		    djnz Div8_Loop 
0b10 47			    ld b,a 
0b11 7b			    ld a,e 
0b12 17			    rla 
0b13 2f			    cpl 
0b14 c9			    ret 
0b15			 
0b15			; 
0b15			; Multiply 8-bit value with a 16-bit value (unrolled) 
0b15			; In: Multiply A with DE 
0b15			; Out: HL = result 
0b15			; 
0b15			Mult12U: 
0b15 2e 00		    ld l,0 
0b17 87			    add a,a 
0b18 30 01		    jr nc,Mult12U_NoAdd0 
0b1a 19			    add hl,de 
0b1b			Mult12U_NoAdd0: 
0b1b 29			    add hl,hl 
0b1c 87			    add a,a 
0b1d 30 01		    jr nc,Mult12U_NoAdd1 
0b1f 19			    add hl,de 
0b20			Mult12U_NoAdd1: 
0b20 29			    add hl,hl 
0b21 87			    add a,a 
0b22 30 01		    jr nc,Mult12U_NoAdd2 
0b24 19			    add hl,de 
0b25			Mult12U_NoAdd2: 
0b25 29			    add hl,hl 
0b26 87			    add a,a 
0b27 30 01		    jr nc,Mult12U_NoAdd3 
0b29 19			    add hl,de 
0b2a			Mult12U_NoAdd3: 
0b2a 29			    add hl,hl 
0b2b 87			    add a,a 
0b2c 30 01		    jr nc,Mult12U_NoAdd4 
0b2e 19			    add hl,de 
0b2f			Mult12U_NoAdd4: 
0b2f 29			    add hl,hl 
0b30 87			    add a,a 
0b31 30 01		    jr nc,Mult12U_NoAdd5 
0b33 19			    add hl,de 
0b34			Mult12U_NoAdd5: 
0b34 29			    add hl,hl 
0b35 87			    add a,a 
0b36 30 01		    jr nc,Mult12U_NoAdd6 
0b38 19			    add hl,de 
0b39			Mult12U_NoAdd6: 
0b39 29			    add hl,hl 
0b3a 87			    add a,a 
0b3b d0			    ret nc 
0b3c 19			    add hl,de 
0b3d c9			    ret 
0b3e			 
0b3e			; 
0b3e			; Multiply 8-bit value with a 16-bit value (right rotating) 
0b3e			; In: Multiply A with DE 
0b3e			;      Put lowest value in A for most efficient calculation 
0b3e			; Out: HL = result 
0b3e			; 
0b3e			Mult12R: 
0b3e 21 00 00		    ld hl,0 
0b41			Mult12R_Loop: 
0b41 cb 3f		    srl a 
0b43 30 01		    jr nc,Mult12R_NoAdd 
0b45 19			    add hl,de 
0b46			Mult12R_NoAdd: 
0b46 cb 23		    sla e 
0b48 cb 12		    rl d 
0b4a b7			    or a 
0b4b c2 41 0b		    jp nz,Mult12R_Loop 
0b4e c9			    ret 
0b4f			 
0b4f			; 
0b4f			; Multiply 16-bit values (with 32-bit result) 
0b4f			; In: Multiply BC with DE 
0b4f			; Out: BCHL = result 
0b4f			; 
0b4f			Mult32: 
0b4f 79			    ld a,c 
0b50 48			    ld c,b 
0b51 21 00 00		    ld hl,0 
0b54 06 10		    ld b,16 
0b56			Mult32_Loop: 
0b56 29			    add hl,hl 
0b57 17			    rla 
0b58 cb 11		    rl c 
0b5a 30 07		    jr nc,Mult32_NoAdd 
0b5c 19			    add hl,de 
0b5d ce 00		    adc a,0 
0b5f d2 63 0b		    jp nc,Mult32_NoAdd 
0b62 0c			    inc c 
0b63			Mult32_NoAdd: 
0b63 10 f1		    djnz Mult32_Loop 
0b65 41			    ld b,c 
0b66 4f			    ld c,a 
0b67 c9			    ret 
0b68			 
0b68			 
0b68			 
0b68			; 
0b68			; Multiply 8-bit values 
0b68			; In:  Multiply H with E 
0b68			; Out: HL = result 
0b68			; 
0b68			Mult8: 
0b68 16 00		    ld d,0 
0b6a 6a			    ld l,d 
0b6b 06 08		    ld b,8 
0b6d			Mult8_Loop: 
0b6d 29			    add hl,hl 
0b6e 30 01		    jr nc,Mult8_NoAdd 
0b70 19			    add hl,de 
0b71			Mult8_NoAdd: 
0b71 10 fa		    djnz Mult8_Loop 
0b73 c9			    ret 
0b74			 
0b74			 
0b74			 
0b74			 
0b74			 
0b74			 
0b74			 
0b74			 
0b74			;;http://z80-heaven.wikidot.com/math 
0b74			;;This divides DE by BC, storing the result in DE, remainder in HL 
0b74			; 
0b74			;DE_Div_BC:          ;1281-2x, x is at most 16 
0b74			;     ld a,16        ;7 
0b74			;     ld hl,0        ;10 
0b74			;     jp $+5         ;10 
0b74			;.DivLoop: 
0b74			;       add hl,bc    ;-- 
0b74			;       dec a        ;64 
0b74			;       jr z,.DivLoopEnd        ;86 
0b74			; 
0b74			;       sla e        ;128 
0b74			;       rl d         ;128 
0b74			;       adc hl,hl    ;240 
0b74			;       sbc hl,bc    ;240 
0b74			;       jr nc,.DivLoop ;23|21 
0b74			;       inc e        ;-- 
0b74			;       jp .DivLoop+1 
0b74			; 
0b74			;.DivLoopEnd: 
0b74			 
0b74			;HL_Div_C: 
0b74			;Inputs: 
0b74			;     HL is the numerator 
0b74			;     C is the denominator 
0b74			;Outputs: 
0b74			;     A is the remainder 
0b74			;     B is 0 
0b74			;     C is not changed 
0b74			;     DE is not changed 
0b74			;     HL is the quotient 
0b74			; 
0b74			;       ld b,16 
0b74			;       xor a 
0b74			;         add hl,hl 
0b74			;         rla 
0b74			;         cp c 
0b74			;         jr c,$+4 
0b74			;           inc l 
0b74			;           sub c 
0b74			;         djnz $-7 
0b74			 
0b74			; https://plutiedev.com/z80-add-8bit-to-16bit 
0b74			 
0b74			addatohl: 
0b74 85			    add   a, l    ; A = A+L 
0b75 6f			    ld    l, a    ; L = A+L 
0b76 8c			    adc   a, h    ; A = A+L+H+carry 
0b77 95			    sub   l       ; A = H+carry 
0b78 67			    ld    h, a    ; H = H+carry 
0b79 c9			ret 
0b7a			 
0b7a			addatode: 
0b7a 83			    add   a, e    ; A = A+L 
0b7b 5f			    ld    e, a    ; L = A+L 
0b7c 8a			    adc   a, d    ; A = A+L+H+carry 
0b7d 93			    sub   e       ; A = H+carry 
0b7e 57			    ld    d, a    ; H = H+carry 
0b7f c9			ret 
0b80			 
0b80			 
0b80			addatobc: 
0b80 81			    add   a, c    ; A = A+L 
0b81 4f			    ld    c, a    ; L = A+L 
0b82 88			    adc   a, b    ; A = A+L+H+carry 
0b83 91			    sub   c       ; A = H+carry 
0b84 47			    ld    b, a    ; H = H+carry 
0b85 c9			ret 
0b86			 
0b86			subafromhl: 
0b86			   ; If A=0 do nothing 
0b86			    ; Otherwise flip A's sign. Since 
0b86			    ; the upper byte becomes -1, also 
0b86			    ; substract 1 from H. 
0b86 ed 44		    neg 
0b88 ca 91 0b		    jp    z, Skip 
0b8b 25			    dec   h 
0b8c			     
0b8c			    ; Now add the low byte as usual 
0b8c			    ; Two's complement takes care of 
0b8c			    ; ensuring the result is correct 
0b8c 85			    add   a, l 
0b8d 6f			    ld    l, a 
0b8e 8c			    adc   a, h 
0b8f 95			    sub   l 
0b90 67			    ld    h, a 
0b91			Skip: 
0b91 c9				ret 
0b92			 
0b92			 
0b92			; compare hl and de 
0b92			; returns:  
0b92			; if hl = de, z=1, s=0, c0=0 
0b92			; if hl > de, z=0, s=0, c=0 
0b92			; if hl < de, z=0, s=1, c=1 
0b92			cmp16:	 
0b92 b7				or a 
0b93 ed 52			sbc hl,de 
0b95 e0				ret po 
0b96 7c				ld a,h 
0b97 1f				rra 
0b98 ee 40			xor 01000000B 
0b9a 37				scf 
0b9b 8f				adc a,a 
0b9c c9				ret 
0b9d			 
0b9d			 
0b9d			; test if hl contains zero   - A is destroyed 
0b9d			 
0b9d			ishlzero:    
0b9d b7				or a     ; reset flags 
0b9e 7c				ld a, h 
0b9f b5				or l        	 
0ba0			 
0ba0 c9				ret 
0ba1			 
0ba1			 
0ba1			 
0ba1			 
0ba1			if FORTH_ENABLE_FLOATMATH 
0ba1			;include "float/bbcmath.z80" 
0ba1			include "float/lpfpcalc.asm" 
0ba1			endif 
0ba1			 
0ba1			 
0ba1			; eof 
0ba1			 
# End of file firmware_maths.asm
0ba1			include "firmware_strings.asm"   ; string handling  
0ba1			 
0ba1			 
0ba1			; TODO string len 
0ba1			; input text string, end on cr with zero term 
0ba1			; a offset into frame buffer to start prompt 
0ba1			; d is max length 
0ba1			; e is display size TODO 
0ba1			; c is current cursor position 
0ba1			; hl is ptr to where string will be stored 
0ba1			 
0ba1			 
0ba1			; TODO check limit of buffer for new inserts 
0ba1			; TODO check insert does not push beyond buffer 
0ba1			; TODO scroll in a limited display area 
0ba1			; TODO scroll whole screen on page wrap 
0ba1			 
0ba1			 
0ba1			; TODO handle KEY_PREVWORD 
0ba1			; TODO handle KEY_NEXTWORD 
0ba1			; TODO handle KEY_HOME 
0ba1			; TODO handle KEY_END 
0ba1			; TODO use LCD cursor? 
0ba1			 
0ba1 32 73 ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
0ba4 81					add c 
0ba5 32 71 ee				ld (input_at_cursor),a	; save draw pos of cursor 
0ba8 22 76 ee				ld (input_start), hl     ; save ptr to buffer 
0bab 79					ld a, c 
0bac cd 74 0b				call addatohl 
0baf 22 78 ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
0bb2 7a					ld a,d 
0bb3 32 75 ee			        ld (input_size), a       ; save length of input area 
0bb6 79					ld a, c 
0bb7 32 64 ee				ld (input_cursor),a      ; init cursor start position  
0bba 7b					ld a,e 
0bbb 32 74 ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0bbe					 
0bbe					 
0bbe			 
0bbe			;		ld a,(input_ptr) 
0bbe			;		ld (input_under_cursor),a 	; save what is under the cursor 
0bbe			 
0bbe			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0bbe					; init cursor shape if not set by the cin routines 
0bbe 21 d3 eb				ld hl, cursor_shape 
0bc1 3e ff				ld a, 255 
0bc3 77					ld (hl), a 
0bc4 23					inc hl 
0bc5 3e 00				ld a, 0 
0bc7 77					ld (hl), a 
0bc8			 
0bc8 3e 0f				ld a, CUR_BLINK_RATE 
0bca 32 6f ee				ld (input_cur_flash), a 
0bcd 3e 01				ld a, 1 
0bcf 32 6e ee				ld (input_cur_onoff),a 
0bd2			 
0bd2			;	if DEBUG_INPUT 
0bd2			;		push af 
0bd2			;		ld a, 'I' 
0bd2			;		ld (debug_mark),a 
0bd2			;		pop af 
0bd2			;		CALLMONITOR 
0bd2			;	endif 
0bd2			.is1:		; main entry loop 
0bd2			 
0bd2			 
0bd2			 
0bd2					; pause 1ms 
0bd2			 
0bd2 3e 01				ld a, 1 
0bd4 cd cf 08				call aDelayInMS 
0bd7			 
0bd7					; dec flash counter 
0bd7 3a 6f ee				ld a, (input_cur_flash) 
0bda 3d					dec a 
0bdb 32 6f ee				ld (input_cur_flash), a 
0bde fe 00				cp 0 
0be0 20 0d				jr nz, .nochgstate 
0be2			 
0be2			 
0be2					; change state 
0be2 3a 6e ee				ld a,(input_cur_onoff) 
0be5 ed 44				neg 
0be7 32 6e ee				ld (input_cur_onoff),a 
0bea			 
0bea			 
0bea					; reset on change of state 
0bea 3e 0f				ld a, CUR_BLINK_RATE 
0bec 32 6f ee				ld (input_cur_flash), a 
0bef			 
0bef			.nochgstate: 
0bef					 
0bef					 
0bef			 
0bef					; display cursor  
0bef			 
0bef			;		ld hl, (input_start) 
0bef			;		ld a, (input_cursor) 
0bef			;		call addatohl 
0bef			 
0bef					; get char under cursor and replace with cursor 
0bef 2a 78 ee		ld hl, (input_ptr) 
0bf2			;		ld a, (hl) 
0bf2			;		ld (input_under_cursor),a 
0bf2			;		ld a, '_' 
0bf2			;		ld (hl), a 
0bf2			 
0bf2					; display string 
0bf2			 
0bf2 ed 5b 76 ee			ld de, (input_start) 
0bf6 3a 73 ee				ld a, (input_at_pos) 
0bf9 cd 5a 09				call str_at_display 
0bfc			;	        call update_display 
0bfc			 
0bfc					; find place to put the cursor 
0bfc			;		add h 
0bfc			;		ld l, display_row_1 
0bfc			;		sub l 
0bfc			; (input_at_pos) 
0bfc					;ld c, a 
0bfc			;		ld a, (input_cursor) 
0bfc			;		ld l, (input_at_pos) 
0bfc			;		;ld b, h 
0bfc			;		add l 
0bfc			;		ld (input_at_cursor),a 
0bfc					;ld l,h 
0bfc			 
0bfc			;		ld h, 0 
0bfc			;		ld l,(input_at_pos) 
0bfc			;		ld a, (input_cursor) 
0bfc			;		call addatohl 
0bfc			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0bfc			;		call subafromhl 
0bfc			;		ld a,l 
0bfc			;		ld (input_at_cursor), a 
0bfc			 
0bfc				if DEBUG_INPUT 
0bfc					ld a, (hardware_diag) 
0bfc					cp 0 
0bfc					jr z, .skip_input_diag 
0bfc			 
0bfc					ld a,(input_at_pos) 
0bfc					ld hl, LFSRSeed 
0bfc					call hexout 
0bfc					ld a, (input_cursor) 
0bfc					ld hl, LFSRSeed+2 
0bfc					call hexout 
0bfc					ld a,(input_at_cursor) 
0bfc					ld hl, LFSRSeed+4 
0bfc					call hexout 
0bfc			 
0bfc					ld a,(input_cur_onoff) 
0bfc					ld hl, LFSRSeed+6 
0bfc					call hexout 
0bfc			 
0bfc					ld a,(input_cur_flash) 
0bfc					ld hl, LFSRSeed+8 
0bfc					call hexout 
0bfc			 
0bfc					ld a,(input_len) 
0bfc					ld hl, LFSRSeed+10 
0bfc					call hexout 
0bfc					ld hl, LFSRSeed+12 
0bfc					ld a, 0 
0bfc					ld (hl),a 
0bfc					ld a, display_row_4 
0bfc					ld de, LFSRSeed 
0bfc					call str_at_display 
0bfc					.skip_input_diag: 
0bfc				endif 
0bfc			 
0bfc					; decide on if we are showing the cursor this time round 
0bfc			 
0bfc 3a 6e ee				ld a, (input_cur_onoff) 
0bff fe ff				cp 255 
0c01 28 13				jr z, .skipcur 
0c03			 
0c03			 
0c03 3a 71 ee				ld a,(input_at_cursor) 
0c06 11 d3 eb				ld de, cursor_shape 
0c09 cd 5a 09				call str_at_display 
0c0c			 
0c0c					; save length of current input string 
0c0c 2a 76 ee				ld hl, (input_start) 
0c0f cd d2 0f				call strlenz 
0c12 7d					ld a,l 
0c13 32 69 ee				ld (input_len),a 
0c16			 
0c16			.skipcur: 
0c16			 
0c16 cd 6a 09			        call update_display 
0c19					 
0c19			 
0c19			 
0c19					; wait 
0c19				 
0c19					; TODO loop without wait to flash the cursor and char under cursor	 
0c19 cd 7a 59				call cin    ; _wait 
0c1c			 
0c1c fe 00				cp 0 
0c1e ca d2 0b				jp z, .is1 
0c21			 
0c21					; get ptr to char to input into 
0c21			 
0c21 4f					ld c,a 
0c22 2a 76 ee				ld hl, (input_start) 
0c25 3a 64 ee				ld a, (input_cursor) 
0c28 cd 74 0b				call addatohl 
0c2b 22 78 ee				ld (input_ptr), hl 
0c2e 79					ld a,c 
0c2f			 
0c2f					; replace char under cursor 
0c2f			 
0c2f			;		ld hl, (input_ptr) 
0c2f			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0c2f			;		ld (hl), a 
0c2f			 
0c2f			;	if DEBUG_INPUT 
0c2f			;		push af 
0c2f			;		ld a, 'i' 
0c2f			;		ld (debug_mark),a 
0c2f			;		pop af 
0c2f			;		CALLMONITOR 
0c2f			;	endif 
0c2f fe 0e				cp KEY_HOME 
0c31 20 0e				jr nz, .iske 
0c33			 
0c33 3a 73 ee				ld a, (input_at_pos) 
0c36 32 71 ee				ld (input_at_cursor),a 
0c39 3e 00				ld a, 0 
0c3b 32 64 ee				ld (input_cursor), a 
0c3e c3 d2 0b				jp .is1 
0c41					 
0c41 fe 0f		.iske:		cp KEY_END 
0c43 20 03				jr nz, .isknw 
0c45 c3 d2 0b				jp .is1 
0c48			 
0c48 fe 06		.isknw:		cp KEY_NEXTWORD 
0c4a 20 1b				jr nz, .iskpw 
0c4c			 
0c4c 2a 78 ee		.isknwm:	ld hl, (input_ptr) 
0c4f 7e					ld a,(hl)	 
0c50 fe 00				cp 0 
0c52 ca d2 0b				jp z, .is1    ; end of string 
0c55 fe 20				cp ' ' 
0c57 ca d2 0b				jp z, .is1    ; end of word 
0c5a 23					inc hl 
0c5b 22 78 ee				ld (input_ptr), hl 
0c5e 3a 71 ee				ld a, (input_at_cursor) 
0c61 3c					inc a 
0c62 32 71 ee				ld (input_at_cursor), a 
0c65 18 e5				jr .isknwm 
0c67			 
0c67 fe 07		.iskpw:		cp KEY_PREVWORD 
0c69 20 1b				jr nz, .iskl 
0c6b			.iskpwm:	 
0c6b 2a 78 ee				ld hl, (input_ptr) 
0c6e 7e					ld a,(hl)	 
0c6f fe 00				cp 0  
0c71 ca d2 0b				jp z, .is1    ; end of string 
0c74 fe 20				cp ' ' 
0c76 ca d2 0b				jp z, .is1    ; end of word 
0c79 2b					dec hl 
0c7a 22 78 ee				ld (input_ptr), hl 
0c7d 3a 71 ee				ld a, (input_at_cursor) 
0c80 3d					dec a 
0c81 32 71 ee				ld (input_at_cursor), a 
0c84 18 e5				jr .iskpwm 
0c86			 
0c86			 
0c86 fe 0b		.iskl:		cp KEY_LEFT 
0c88 20 27				jr nz, .isk1 
0c8a			 
0c8a 3a 64 ee				ld a, (input_cursor) 
0c8d			 
0c8d fe 00				cp 0 
0c8f ca d2 0b				jp z, .is1 		; at start of line to ignore  
0c92			 
0c92 3d					dec  a 		; TODO check underflow 
0c93 32 64 ee				ld (input_cursor), a 
0c96			 
0c96 2a 78 ee				ld hl, (input_ptr) 
0c99 2b					dec hl 
0c9a 22 78 ee				ld (input_ptr), hl 
0c9d					 
0c9d 3a 71 ee				ld a, (input_at_cursor) 
0ca0 3d					dec a 
0ca1 32 71 ee				ld (input_at_cursor), a 
0ca4			 
0ca4 3e 01				ld a, 1		; show cursor moving 
0ca6 32 6e ee				ld (input_cur_onoff),a 
0ca9 3e 0f				ld a, CUR_BLINK_RATE 
0cab 32 6f ee				ld (input_cur_flash), a 
0cae			 
0cae c3 d2 0b				jp .is1 
0cb1			 
0cb1 fe 0c		.isk1:		cp KEY_RIGHT 
0cb3 20 2a				jr nz, .isk2 
0cb5			 
0cb5 3a 69 ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0cb8 5f					ld e,a 
0cb9 3a 64 ee				ld a, (input_cursor) 
0cbc bb					cp e 
0cbd ca d2 0b				jp z, .is1		; at the end of string so dont go right 
0cc0			 
0cc0 3c					inc  a 		; TODO check overflow 
0cc1 32 64 ee				ld (input_cursor), a 
0cc4			 
0cc4 3a 71 ee				ld a, (input_at_cursor) 
0cc7 3c					inc a 
0cc8 32 71 ee				ld (input_at_cursor), a 
0ccb			 
0ccb 2a 78 ee				ld hl, (input_ptr) 
0cce 23					inc hl 
0ccf 22 78 ee				ld (input_ptr), hl 
0cd2			 
0cd2 3e 01				ld a, 1		; show cursor moving 
0cd4 32 6e ee				ld (input_cur_onoff),a 
0cd7 3e 0f				ld a, CUR_BLINK_RATE 
0cd9 32 6f ee				ld (input_cur_flash), a 
0cdc			 
0cdc c3 d2 0b				jp .is1 
0cdf			 
0cdf fe 05		.isk2:		cp KEY_UP 
0ce1			 
0ce1 20 26				jr nz, .isk3 
0ce3			 
0ce3					; swap last command with the current on 
0ce3			 
0ce3					; move cursor to start of string 
0ce3 2a 76 ee				ld hl, (input_start) 
0ce6 22 78 ee				ld (input_ptr), hl 
0ce9			 
0ce9 3a 73 ee				ld a, (input_at_pos) 
0cec 32 71 ee				ld (input_at_cursor), a 
0cef			 
0cef 3e 00				ld a, 0 
0cf1 32 64 ee				ld (input_cursor), a 
0cf4					 
0cf4					; swap input and last command buffers 
0cf4			 
0cf4 21 87 e6				ld hl, os_cli_cmd 
0cf7 11 86 e7				ld de, os_last_cmd 
0cfa 06 ff				ld b, 255 
0cfc 7e			.swap1:		ld a, (hl) 
0cfd 4f					ld c,a 
0cfe 1a					ld a, (de) 
0cff 77					ld (hl), a 
0d00 79					ld a,c 
0d01 12					ld (de),a 
0d02 23					inc hl 
0d03 13					inc de 
0d04 10 f6				djnz .swap1 
0d06			 
0d06			 
0d06			 
0d06			 
0d06			 
0d06 c3 d2 0b				jp .is1 
0d09			 
0d09 fe 08		.isk3:		cp KEY_BS 
0d0b 20 3c				jr nz, .isk4 
0d0d			 
0d0d 3a 64 ee				ld a, (input_cursor) 
0d10			 
0d10 fe 00				cp 0 
0d12 ca d2 0b				jp z, .is1 		; at start of line to ignore  
0d15			 
0d15 3d					dec  a 		; TODO check underflow 
0d16 32 64 ee				ld (input_cursor), a 
0d19			 
0d19					; hl is source 
0d19					; de needs to be source - 1 
0d19			 
0d19			;		ld a, 0 
0d19			;		dec hl 
0d19			;		ld (hl), a 
0d19			 
0d19 2a 78 ee				ld hl, (input_ptr) 
0d1c 2b					dec hl 
0d1d 22 78 ee				ld (input_ptr), hl 
0d20			 
0d20					; shift all data 
0d20			 
0d20 e5					push hl 
0d21 23					inc hl 
0d22 d1					pop de 
0d23 3a 69 ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0d26 4f					ld c,a 
0d27 06 00				ld b,0 
0d29 ed b0				ldir  
0d2b			 
0d2b			 
0d2b			 
0d2b			 
0d2b 3a 71 ee				ld a, (input_at_cursor) 
0d2e 3d					dec a 
0d2f 32 71 ee				ld (input_at_cursor), a 
0d32			 
0d32			 
0d32 3e 01				ld a, 1		; show cursor moving 
0d34 32 6e ee				ld (input_cur_onoff),a 
0d37 3e 0f				ld a, CUR_BLINK_RATE 
0d39 32 6f ee				ld (input_cur_flash), a 
0d3c			 
0d3c					; remove char 
0d3c 3a 71 ee				ld a, (input_at_cursor) 
0d3f 3c					inc a 
0d40 11 ca 0d				ld de,.iblank 
0d43 cd 5a 09				call str_at_display 
0d46			 
0d46 c3 d2 0b				jp .is1 
0d49			 
0d49 fe 0d		.isk4:		cp KEY_CR 
0d4b 28 6c				jr z, .endinput 
0d4d			 
0d4d					; else add the key press to the end 
0d4d			 
0d4d 4f					ld c, a			; save key pressed 
0d4e			 
0d4e 7e					ld a,(hl)		; get what is currently under char 
0d4f			 
0d4f fe 00				cp 0			; we are at the end of the string 
0d51 20 2f				jr nz, .onchar 
0d53					 
0d53					; add a char to the end of the string 
0d53				 
0d53 71					ld (hl),c 
0d54 23					inc hl 
0d55			;		ld a,' ' 
0d55			;		ld (hl),a 
0d55			;		inc hl 
0d55 3e 00				ld a,0 
0d57 77					ld (hl),a 
0d58 2b					dec hl 
0d59			 
0d59 3a 64 ee				ld a, (input_cursor) 
0d5c 3c					inc a				; TODO check max string length and scroll  
0d5d 32 64 ee				ld (input_cursor), a		; inc cursor pos 
0d60							 
0d60 3a 71 ee				ld a, (input_at_cursor) 
0d63 3c					inc a 
0d64 32 71 ee				ld (input_at_cursor), a 
0d67			 
0d67 2a 78 ee				ld hl, (input_ptr) 
0d6a 23					inc hl 
0d6b 22 78 ee				ld (input_ptr), hl 
0d6e			 
0d6e 2a 78 ee				ld hl, (input_ptr) 
0d71 23					inc hl 
0d72 22 78 ee				ld (input_ptr), hl 
0d75			;	if DEBUG_INPUT 
0d75			;		push af 
0d75			;		ld a, '+' 
0d75			;		ld (debug_mark),a 
0d75			;		pop af 
0d75			;		CALLMONITOR 
0d75			;	endif 
0d75 3e 01				ld a, 1		; show cursor moving 
0d77 32 6e ee				ld (input_cur_onoff),a 
0d7a 3e 0f				ld a, CUR_BLINK_RATE 
0d7c 32 6f ee				ld (input_cur_flash), a 
0d7f c3 d2 0b				jp .is1 
0d82					 
0d82			 
0d82			 
0d82					; if on a char then insert 
0d82			.onchar: 
0d82			 
0d82					; TODO over flow check: make sure insert does not blow out buffer 
0d82			 
0d82					; need to do some maths to use lddr 
0d82			 
0d82 e5					push hl   ; save char pos 
0d83 c5					push bc 
0d84			 
0d84 2a 76 ee				ld hl, (input_start) 
0d87 3a 69 ee				ld a, (input_len) 
0d8a cd 74 0b				call addatohl  		; end of string 
0d8d 23					inc hl 
0d8e 23					inc hl		; past zero term 
0d8f e5					push hl 
0d90 23					inc hl 
0d91 e5					push hl  
0d92			 
0d92								; start and end of lddr set, now how much to move? 
0d92			 
0d92							 
0d92 3a 64 ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0d95 47					ld b,a 
0d96 3a 69 ee				ld a,(input_len) 
0d99 5f					ld e,a 
0d9a 90					sub b 
0d9b 3c					inc a		;?? 
0d9c 3c					inc a		;?? 
0d9d 3c					inc a		;?? 
0d9e			 
0d9e 06 00				ld b,0 
0da0 4f					ld c,a 
0da1			 
0da1				if DEBUG_INPUT 
0da1					push af 
0da1					ld a, 'i' 
0da1					ld (debug_mark),a 
0da1					pop af 
0da1			;		CALLMONITOR 
0da1				endif 
0da1 d1					pop de 
0da2 e1					pop hl 
0da3				if DEBUG_INPUT 
0da3					push af 
0da3					ld a, 'I' 
0da3					ld (debug_mark),a 
0da3					pop af 
0da3			;		CALLMONITOR 
0da3				endif 
0da3 ed b8				lddr 
0da5				 
0da5			 
0da5			 
0da5					; TODO have a key for insert/overwrite mode???? 
0da5 c1					pop bc 
0da6 e1					pop hl 
0da7 71					ld (hl), c		; otherwise overwrite current char 
0da8					 
0da8			 
0da8			 
0da8			 
0da8 3a 64 ee				ld a, (input_cursor) 
0dab 3c					inc  a 		; TODO check overflow 
0dac 32 64 ee				ld (input_cursor), a 
0daf			 
0daf 3a 71 ee				ld a, (input_at_cursor) 
0db2 3c					inc a 
0db3 32 71 ee				ld (input_at_cursor), a 
0db6			 
0db6 c3 d2 0b				jp .is1 
0db9			 
0db9			.endinput:	; TODO look for end of string 
0db9			 
0db9					; add trailing space for end of token 
0db9			 
0db9 2a 76 ee				ld hl, (input_start) 
0dbc 3a 69 ee				ld a,(input_len) 
0dbf cd 74 0b				call addatohl 
0dc2 3e 20				ld a, ' ' 
0dc4 77					ld (hl),a 
0dc5					; TODO eof of parse marker 
0dc5			 
0dc5 23					inc hl 
0dc6 3e 00				ld a, 0 
0dc8 77					ld (hl),a 
0dc9			 
0dc9			 
0dc9 c9					ret 
0dca			 
0dca .. 00		.iblank: db " ",0 
0dcc			 
0dcc			 
0dcc 32 73 ee		input_str_prev:	ld (input_at_pos), a 
0dcf 22 76 ee				ld (input_start), hl 
0dd2 3e 01				ld a,1			; add cursor 
0dd4 77					ld (hl),a 
0dd5 23					inc hl 
0dd6 3e 00				ld a,0 
0dd8 77					ld (hl),a 
0dd9 22 78 ee				ld (input_ptr), hl 
0ddc 7a					ld a,d 
0ddd 32 75 ee				ld (input_size), a 
0de0 3e 00				ld a,0 
0de2 32 64 ee				ld (input_cursor),a 
0de5			.instr1:	 
0de5			 
0de5					; TODO do block cursor 
0de5					; TODO switch cursor depending on the modifer key 
0de5			 
0de5					; update cursor shape change on key hold 
0de5			 
0de5 2a 78 ee				ld hl, (input_ptr) 
0de8 2b					dec hl 
0de9 3a d3 eb				ld a,(cursor_shape) 
0dec 77					ld (hl), a 
0ded			 
0ded					; display entered text 
0ded 3a 73 ee				ld a,(input_at_pos) 
0df0 cd 8f 58		            	CALL fLCD_Pos       ;Position cursor to location in A 
0df3 ed 5b 76 ee	            	LD   de, (input_start) 
0df7 cd 84 58		            	CALL fLCD_Str       ;Display string pointed to by DE 
0dfa			 
0dfa cd 7a 59				call cin 
0dfd fe 00				cp 0 
0dff 28 e4				jr z, .instr1 
0e01			 
0e01					; proecess keyboard controls first 
0e01			 
0e01 2a 78 ee				ld hl,(input_ptr) 
0e04			 
0e04 fe 0d				cp KEY_CR	 ; pressing enter ends input 
0e06 28 5a				jr z, .instrcr 
0e08			 
0e08 fe 08				cp KEY_BS 	; back space 
0e0a 20 0f				jr nz, .instr2 
0e0c					; process back space 
0e0c			 
0e0c					; TODO stop back space if at start of string 
0e0c 2b					dec hl 
0e0d 2b					dec hl ; to over write cursor 
0e0e 3a d3 eb				ld a,(cursor_shape) 
0e11					;ld a,0 
0e11 77					ld (hl),a 
0e12 23					inc hl 
0e13 3e 20				ld a," " 
0e15 77					ld (hl),a 
0e16 22 78 ee				ld (input_ptr),hl 
0e19					 
0e19			 
0e19 18 ca				jr .instr1 
0e1b			 
0e1b fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
0e1d 20 06				jr nz, .instr3 
0e1f 2b					dec hl 
0e20 22 78 ee				ld (input_ptr),hl 
0e23 18 c0				jr .instr1 
0e25				 
0e25 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
0e27 20 06				jr nz, .instr4 
0e29 23					inc hl 
0e2a 22 78 ee				ld (input_ptr),hl 
0e2d 18 b6				jr .instr1 
0e2f			 
0e2f fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
0e31 20 06				jr nz, .instr5 
0e33 2b					dec hl 
0e34 22 78 ee				ld (input_ptr),hl 
0e37 18 ac				jr .instr1 
0e39			 
0e39 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
0e3b 20 06				jr nz, .instr6 
0e3d 2b					dec hl 
0e3e 22 78 ee				ld (input_ptr),hl 
0e41 18 a2				jr .instr1 
0e43 fe 05		.instr6:        cp KEY_UP      ; recall last command 
0e45 20 0b				jr nz, .instrnew 
0e47			 
0e47 21 60 e3			ld hl, scratch 
0e4a 11 86 e7			ld de, os_last_cmd 
0e4d cd 6b 0e			call strcpy 
0e50 18 93				jr .instr1 
0e52			 
0e52			 
0e52			.instrnew:	; no special key pressed to see if we have room to store it 
0e52			 
0e52					; TODO do string size test 
0e52			 
0e52 2b					dec hl ; to over write cursor 
0e53 77					ld (hl),a 
0e54 23					inc hl 
0e55 3a d3 eb				ld a,(cursor_shape) 
0e58 77					ld (hl),a 
0e59 23					inc hl 
0e5a 3e 00				ld a,0 
0e5c 77					ld (hl),a 
0e5d			 
0e5d 22 78 ee				ld (input_ptr),hl 
0e60					 
0e60 18 83				jr .instr1 
0e62 2b			.instrcr:	dec hl		; remove cursor 
0e63 3e 20				ld a,' '	; TODO add a trailing space for safety 
0e65 77					ld (hl),a 
0e66 23					inc hl 
0e67 3e 00				ld a,0 
0e69 77					ld (hl),a 
0e6a			 
0e6a			 
0e6a					; if at end of line scroll up    
0e6a					; TODO detecting only end of line 4 for scroll up  
0e6a			 
0e6a					;ld   
0e6a			 
0e6a c9					ret 
0e6b			 
0e6b			 
0e6b			; strcpy hl = dest, de source 
0e6b			 
0e6b 1a			strcpy:   LD   A, (DE)        ;Get character from string 
0e6c b7			            OR   A              ;Null terminator? 
0e6d c8			            RET  Z              ;Yes, so finished 
0e6e 1a					ld a,(de) 
0e6f 77					ld (hl),a 
0e70 13			            INC  DE             ;Point to next character 
0e71 23					inc hl 
0e72 18 f7		            JR   strcpy       ;Repeat 
0e74 c9					ret 
0e75			 
0e75			 
0e75			; TODO string_at  
0e75			; pass string which starts with lcd offset address and then null term string 
0e75			 
0e75			; TODO string to dec 
0e75			; TODO string to hex 
0e75			; TODO byte to string hex 
0e75			; TODO byte to string dec 
0e75			 
0e75			 
0e75			 
0e75			; from z80uartmonitor 
0e75			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0e75			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
0e75			; pass hl for where to put the text 
0e75			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0e75 c5			hexout:	PUSH BC 
0e76 f5					PUSH AF 
0e77 47					LD B, A 
0e78					; Upper nybble 
0e78 cb 3f				SRL A 
0e7a cb 3f				SRL A 
0e7c cb 3f				SRL A 
0e7e cb 3f				SRL A 
0e80 cd 90 0e				CALL tohex 
0e83 77					ld (hl),a 
0e84 23					inc hl	 
0e85					 
0e85					; Lower nybble 
0e85 78					LD A, B 
0e86 e6 0f				AND 0FH 
0e88 cd 90 0e				CALL tohex 
0e8b 77					ld (hl),a 
0e8c 23					inc hl	 
0e8d					 
0e8d f1					POP AF 
0e8e c1					POP BC 
0e8f c9					RET 
0e90					 
0e90			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0e90			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
0e90			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0e90			tohex: 
0e90 e5					PUSH HL 
0e91 d5					PUSH DE 
0e92 16 00				LD D, 0 
0e94 5f					LD E, A 
0e95 21 9d 0e				LD HL, .DATA 
0e98 19					ADD HL, DE 
0e99 7e					LD A, (HL) 
0e9a d1					POP DE 
0e9b e1					POP HL 
0e9c c9					RET 
0e9d			 
0e9d			.DATA: 
0e9d 30					DEFB	30h	; 0 
0e9e 31					DEFB	31h	; 1 
0e9f 32					DEFB	32h	; 2 
0ea0 33					DEFB	33h	; 3 
0ea1 34					DEFB	34h	; 4 
0ea2 35					DEFB	35h	; 5 
0ea3 36					DEFB	36h	; 6 
0ea4 37					DEFB	37h	; 7 
0ea5 38					DEFB	38h	; 8 
0ea6 39					DEFB	39h	; 9 
0ea7 41					DEFB	41h	; A 
0ea8 42					DEFB	42h	; B 
0ea9 43					DEFB	43h	; C 
0eaa 44					DEFB	44h	; D 
0eab 45					DEFB	45h	; E 
0eac 46					DEFB	46h	; F 
0ead			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0ead			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
0ead			;;    subtract $30, if result > 9 then subtract $7 more 
0ead			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0ead			atohex: 
0ead d6 30				SUB $30 
0eaf fe 0a				CP 10 
0eb1 f8					RET M		; If result negative it was 0-9 so we're done 
0eb2 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
0eb4 c9					RET		 
0eb5			 
0eb5			 
0eb5			 
0eb5			 
0eb5			; Get 2 ASCII characters as hex byte from pointer in hl 
0eb5			 
0eb5			BYTERD: 
0eb5 16 00			LD	D,00h		;Set up 
0eb7 cd bf 0e			CALL	HEXCON		;Get byte and convert to hex 
0eba 87				ADD	A,A		;First nibble so 
0ebb 87				ADD	A,A		;multiply by 16 
0ebc 87				ADD	A,A		; 
0ebd 87				ADD	A,A		; 
0ebe 57				LD	D,A		;Save hi nibble in D 
0ebf			HEXCON: 
0ebf 7e				ld a, (hl)		;Get next chr 
0ec0 23				inc hl 
0ec1 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
0ec3 fe 0a			CP	00Ah		;Is it 0-9 ? 
0ec5 38 02			JR	C,NALPHA	;If so miss next bit 
0ec7 d6 07			SUB	007h		;Else convert alpha 
0ec9			NALPHA: 
0ec9 b2				OR	D		;Add hi nibble back 
0eca c9				RET			; 
0ecb			 
0ecb			 
0ecb			; 
0ecb			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
0ecb			; Since the routines get_byte and therefore get_nibble are called, only valid 
0ecb			; characters (0-9a-f) are accepted. 
0ecb			; 
0ecb			;get_word        push    af 
0ecb			;                call    get_byte        ; Get the upper byte 
0ecb			;                ld      h, a 
0ecb			;                call    get_byte        ; Get the lower byte 
0ecb			;                ld      l, a 
0ecb			;                pop     af 
0ecb			;                ret 
0ecb			; 
0ecb			; Get a byte in hexadecimal notation. The result is returned in A. Since 
0ecb			; the routine get_nibble is used only valid characters are accepted - the  
0ecb			; input routine only accepts characters 0-9a-f. 
0ecb			; 
0ecb c5			get_byte:        push    bc              ; Save contents of B (and C) 
0ecc 7e					ld a,(hl) 
0ecd 23					inc hl 
0ece cd f3 0e		                call    nibble2val      ; Get upper nibble 
0ed1 cb 07		                rlc     a 
0ed3 cb 07		                rlc     a 
0ed5 cb 07		                rlc     a 
0ed7 cb 07		                rlc     a 
0ed9 47			                ld      b, a            ; Save upper four bits 
0eda 7e					ld a,(hl) 
0edb cd f3 0e		                call    nibble2val      ; Get lower nibble 
0ede b0			                or      b               ; Combine both nibbles 
0edf c1			                pop     bc              ; Restore B (and C) 
0ee0 c9			                ret 
0ee1			; 
0ee1			; Get a hexadecimal digit from the serial line. This routine blocks until 
0ee1			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
0ee1			; to the serial line interface. The lower 4 bits of A contain the value of  
0ee1			; that particular digit. 
0ee1			; 
0ee1			;get_nibble      ld a,(hl)           ; Read a character 
0ee1			;                call    to_upper        ; Convert to upper case 
0ee1			;                call    is_hex          ; Was it a hex digit? 
0ee1			;                jr      nc, get_nibble  ; No, get another character 
0ee1			 ;               call    nibble2val      ; Convert nibble to value 
0ee1			 ;               call    print_nibble 
0ee1			 ;               ret 
0ee1			; 
0ee1			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
0ee1			; A valid hexadecimal digit is denoted by a set C flag. 
0ee1			; 
0ee1			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
0ee1			;                ret     nc              ; Yes 
0ee1			;                cp      '0'             ; Less than '0'? 
0ee1			;                jr      nc, is_hex_1    ; No, continue 
0ee1			;                ccf                     ; Complement carry (i.e. clear it) 
0ee1			;                ret 
0ee1			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
0ee1			;                ret     c               ; Yes 
0ee1			;                cp      'A'             ; Less than 'A'? 
0ee1			;                jr      nc, is_hex_2    ; No, continue 
0ee1			;                ccf                     ; Yes - clear carry and return 
0ee1			;                ret 
0ee1			;is_hex_2        scf                     ; Set carry 
0ee1			;                ret 
0ee1			; 
0ee1			; Convert a single character contained in A to upper case: 
0ee1			; 
0ee1 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
0ee3 d8			                ret     c 
0ee4 fe 7b		                cp      'z' + 1         ; > 'z'? 
0ee6 d0			                ret     nc              ; Nothing to do, either 
0ee7 e6 5f		                and     $5f             ; Convert to upper case 
0ee9 c9			                ret 
0eea			 
0eea			 
0eea			to_lower: 
0eea			 
0eea			   ; if char is in [A-Z] make it lower case 
0eea			 
0eea			   ; enter : a = char 
0eea			   ; exit  : a = lower case char 
0eea			   ; uses  : af 
0eea			 
0eea fe 41		   cp 'A' 
0eec d8			   ret c 
0eed			    
0eed fe 5b		   cp 'Z'+1 
0eef d0			   ret nc 
0ef0			    
0ef0 f6 20		   or $20 
0ef2 c9			   ret 
0ef3			 
0ef3			; 
0ef3			; Expects a hexadecimal digit (upper case!) in A and returns the 
0ef3			; corresponding value in A. 
0ef3			; 
0ef3 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
0ef5 38 02		                jr      c, nibble2val_1 ; Yes 
0ef7 d6 07		                sub     7               ; Adjust for A-F 
0ef9 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
0efb e6 0f		                and     $f              ; Only return lower 4 bits 
0efd c9			                ret 
0efe			; 
0efe			; Print_nibble prints a single hex nibble which is contained in the lower  
0efe			; four bits of A: 
0efe			; 
0efe			;print_nibble    push    af              ; We won't destroy the contents of A 
0efe			;                and     $f              ; Just in case... 
0efe			;                add     a, '0'             ; If we have a digit we are done here. 
0efe			;                cp      '9' + 1         ; Is the result > 9? 
0efe			;                jr      c, print_nibble_1 
0efe			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
0efe			;print_nibble_1  call    putc            ; Print the nibble and 
0efe			;                pop     af              ; restore the original value of A 
0efe			;                ret 
0efe			;; 
0efe			;; Send a CR/LF pair: 
0efe			; 
0efe			;crlf            push    af 
0efe			;                ld      a, cr 
0efe			;                call    putc 
0efe			;                ld      a, lf 
0efe			;                call    putc 
0efe			;                pop     af 
0efe			;                ret 
0efe			; 
0efe			; Print_word prints the four hex digits of a word to the serial line. The  
0efe			; word is expected to be in HL. 
0efe			; 
0efe			;print_word      push    hl 
0efe			;                push    af 
0efe			;                ld      a, h 
0efe			;                call    print_byte 
0efe			;                ld      a, l 
0efe			;                call    print_byte 
0efe			;                pop     af 
0efe			;                pop     hl 
0efe			;                ret 
0efe			; 
0efe			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
0efe			; The byte to be printed is expected to be in A. 
0efe			; 
0efe			;print_byte      push    af              ; Save the contents of the registers 
0efe			;                push    bc 
0efe			;                ld      b, a 
0efe			;                rrca 
0efe			;                rrca 
0efe			;                rrca 
0efe			;                rrca 
0efe			;                call    print_nibble    ; Print high nibble 
0efe			;                ld      a, b 
0efe			;                call    print_nibble    ; Print low nibble 
0efe			;                pop     bc              ; Restore original register contents 
0efe			;                pop     af 
0efe			;                ret 
0efe			 
0efe			 
0efe			 
0efe			 
0efe			 
0efe			fourehexhl:  
0efe 7e				ld a,(hl) 
0eff cd ad 0e			call atohex 
0f02 cb 3f				SRL A 
0f04 cb 3f				SRL A 
0f06 cb 3f				SRL A 
0f08 cb 3f				SRL A 
0f0a 47				ld b, a 
0f0b 23				inc hl 
0f0c 7e				ld a,(hl) 
0f0d 23				inc hl 
0f0e cd ad 0e			call atohex 
0f11 80				add b 
0f12 57				ld d,a 
0f13 7e				ld a,(hl) 
0f14 cd ad 0e			call atohex 
0f17 cb 3f				SRL A 
0f19 cb 3f				SRL A 
0f1b cb 3f				SRL A 
0f1d cb 3f				SRL A 
0f1f 47				ld b, a 
0f20 23				inc hl 
0f21 7e				ld a,(hl) 
0f22 23				inc hl 
0f23 cd ad 0e			call atohex 
0f26 80				add b 
0f27 5f				ld e, a 
0f28 d5				push de 
0f29 e1				pop hl 
0f2a c9				ret 
0f2b			 
0f2b			; pass hl. returns z set if the byte at hl is a digit 
0f2b			;isdigithl:  
0f2b			;	push bc 
0f2b			;	ld a,(hl) 
0f2b			;	cp ':' 
0f2b			;	jr nc, .isdf 		; > 
0f2b			;	cp '0' 
0f2b			;	jr c, .isdf		; < 
0f2b			; 
0f2b			;	; TODO find a better way to set z 
0f2b			; 
0f2b			;	ld b,a 
0f2b			;	cp b 
0f2b			;	pop bc 
0f2b			;	ret 
0f2b			; 
0f2b			;.isdf:	; not digit so clear z 
0f2b			; 
0f2b			;	; TODO find a better way to unset z 
0f2b			; 
0f2b			;	ld b,a 
0f2b			;	inc b 
0f2b			;	cp b 
0f2b			; 
0f2b			;	pop bc 
0f2b			;	ret 
0f2b				 
0f2b				 
0f2b			 
0f2b			 
0f2b			; pass hl as the four byte address to load 
0f2b			 
0f2b			get_word_hl:  
0f2b e5				push hl 
0f2c cd cb 0e			call get_byte 
0f2f				 
0f2f 47				ld b, a 
0f30			 
0f30 e1				pop hl 
0f31 23				inc hl 
0f32 23				inc hl 
0f33			 
0f33			; TODO not able to handle a-f  
0f33 7e				ld a,(hl) 
0f34			;	;cp ':' 
0f34			;	cp 'g' 
0f34			;	jr nc, .single_byte_hl 		; > 
0f34			;	cp 'G' 
0f34			;	jr nc, .single_byte_hl 		; > 
0f34			;	cp '0' 
0f34			;	jr c, .single_byte_hl		; < 
0f34			 
0f34				;call isdigithl 
0f34 fe 00			cp 0 
0f36 28 06			jr z, .single_byte_hl 
0f38			 
0f38			.getwhln:   ; hex word so get next byte 
0f38			 
0f38 cd cb 0e			call get_byte 
0f3b 6f				ld l, a 
0f3c 60				ld h,b 
0f3d c9				ret 
0f3e 68			.single_byte_hl:   ld l,b 
0f3f 26 00				ld h,0 
0f41 c9					ret 
0f42			 
0f42			 
0f42			 
0f42			 
0f42 21 5f 16			ld hl,asc+1 
0f45			;	ld a, (hl) 
0f45			;	call nibble2val 
0f45 cd cb 0e			call get_byte 
0f48			 
0f48			;	call fourehexhl 
0f48 32 94 e3			ld (scratch+52),a 
0f4b				 
0f4b 21 92 e3			ld hl,scratch+50 
0f4e 22 83 e6			ld (os_cur_ptr),hl 
0f51			 
0f51 c9				ret 
0f52			 
0f52			 
0f52			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
0f52			 
0f52			; Decimal Unsigned Version 
0f52			 
0f52			;Number in a to decimal ASCII 
0f52			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
0f52			;Example: display a=56 as "056" 
0f52			;input: a = number 
0f52			;Output: a=0,value of a in the screen 
0f52			;destroys af,bc (don't know about hl and de) 
0f52			DispAToASCII: 
0f52 0e 9c			ld	c,-100 
0f54 cd 5e 0f			call	.Na1 
0f57 0e f6			ld	c,-10 
0f59 cd 5e 0f			call	.Na1 
0f5c 0e ff			ld	c,-1 
0f5e 06 2f		.Na1:	ld	b,'0'-1 
0f60 04			.Na2:	inc	b 
0f61 81				add	a,c 
0f62 38 fc			jr	c,.Na2 
0f64 91				sub	c		;works as add 100/10/1 
0f65 f5				push af		;safer than ld c,a 
0f66 78				ld	a,b		;char is in b 
0f67			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
0f67 f1				pop af		;safer than ld a,c 
0f68 c9				ret 
0f69			 
0f69			; Decimal Signed Version 
0f69			 
0f69			; DispA 
0f69			; -------------------------------------------------------------- 
0f69			; Converts a signed integer value to a zero-terminated ASCII 
0f69			; string representative of that value (using radix 10). 
0f69			; -------------------------------------------------------------- 
0f69			; INPUTS: 
0f69			;     HL     Value to convert (two's complement integer). 
0f69			;     DE     Base address of string destination. (pointer). 
0f69			; -------------------------------------------------------------- 
0f69			; OUTPUTS: 
0f69			;     None 
0f69			; -------------------------------------------------------------- 
0f69			; REGISTERS/MEMORY DESTROYED 
0f69			; AF HL 
0f69			; -------------------------------------------------------------- 
0f69			 
0f69			;DispHLToASCII: 
0f69			;   push    de 
0f69			;   push    bc 
0f69			; 
0f69			;; Detect sign of HL. 
0f69			;    bit    7, h 
0f69			;    jr     z, ._DoConvert 
0f69			; 
0f69			;; HL is negative. Output '-' to string and negate HL. 
0f69			;    ld     a, '-' 
0f69			;    ld     (de), a 
0f69			;    inc    de 
0f69			; 
0f69			;; Negate HL (using two's complement) 
0f69			;    xor    a 
0f69			;    sub    l 
0f69			;    ld     l, a 
0f69			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
0f69			;    sbc    a, h 
0f69			;    ld     h, a 
0f69			; 
0f69			;; Convert HL to digit characters 
0f69			;._DoConvert: 
0f69			;    ld     b, 0     ; B will count character length of number 
0f69			;-   ld     a, 10 
0f69			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
0f69			;    push   af 
0f69			;    inc    b 
0f69			;    ld     a, h 
0f69			;    or     l 
0f69			;    jr     nz, - 
0f69			; 
0f69			;; Retrieve digits from stack 
0f69			;-   pop    af 
0f69			;    or     $30 
0f69			;    ld     (de), a 
0f69			;    inc    de 
0f69			;    djnz   - 
0f69			; 
0f69			;; Terminate string with NULL 
0f69			;    xor    a 
0f69			;    ld     (de), a 
0f69			; 
0f69			;    pop    bc 
0f69			;    pop    de 
0f69			;    ret 
0f69			 
0f69			;Comments 
0f69			; 
0f69			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
0f69			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
0f69			;    Note that the output string will not be fixed-width. 
0f69			; 
0f69			;Example Usage 
0f69			; 
0f69			;    ld    hl, -1004 
0f69			;    ld    de, OP1 
0f69			;    call  DispA 
0f69			;    ld    hl, OP1 
0f69			;    syscall  PutS 
0f69			 
0f69			 
0f69			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
0f69			 
0f69			 
0f69			;Converts an ASCII string to an unsigned 16-bit integer 
0f69			;Quits when it reaches a non-decimal digit 
0f69			 
0f69			string_to_uint16: 
0f69			atoui_16: 
0f69			;Input: 
0f69			;     DE points to the string 
0f69			;Outputs: 
0f69			;     HL is the result 
0f69			;     A is the 8-bit value of the number 
0f69			;     DE points to the byte after the number 
0f69			;Destroys: 
0f69			;     BC 
0f69			;       if the string is non-empty, BC is HL/10 
0f69			;Size:  24 bytes 
0f69			;Speed: 42+d(104+{0,9}) 
0f69			;       d is the number of digits in the number 
0f69			;       max is 640 cycles for a 5 digit number 
0f69			;Assuming no leading zeros: 
0f69			;1 digit:  146cc 
0f69			;2 digit:  250cc 
0f69			;3 digit:  354cc or 363cc (avg: 354.126cc) 
0f69			;4 digit:  458cc or 467cc (avg: 458.27cc) 
0f69			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
0f69			;avg: 544.81158447265625cc (544+13297/16384) 
0f69			;=============================================================== 
0f69 21 00 00		  ld hl,0 
0f6c			.u16a: 
0f6c 1a			  ld a,(de) 
0f6d d6 30		  sub 30h 
0f6f fe 0a		  cp 10 
0f71 d0			  ret nc 
0f72 13			  inc de 
0f73 44			  ld b,h 
0f74 4d			  ld c,l 
0f75 29			  add hl,hl 
0f76 29			  add hl,hl 
0f77 09			  add hl,bc 
0f78 29			  add hl,hl 
0f79 85			  add a,l 
0f7a 6f			  ld l,a 
0f7b 30 ef		  jr nc,.u16a 
0f7d 24			  inc h 
0f7e c3 6c 0f		  jp .u16a 
0f81			 
0f81			 
0f81			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
0f81			 
0f81			;written by Zeda 
0f81			;Converts a 16-bit unsigned integer to an ASCII string. 
0f81			 
0f81			uitoa_16: 
0f81			;Input: 
0f81			;   DE is the number to convert 
0f81			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
0f81			;Output: 
0f81			;   HL points to the null-terminated ASCII string 
0f81			;      NOTE: This isn't necessarily the same as the input HL. 
0f81 d5			  push de 
0f82 c5			  push bc 
0f83 f5			  push af 
0f84 eb			  ex de,hl 
0f85			 
0f85 01 f0 d8		  ld bc,-10000 
0f88 3e 2f		  ld a,'0'-1 
0f8a 3c			  inc a 
0f8b 09			  add hl,bc  
0f8c 38 fc		   jr c,$-2 
0f8e 12			  ld (de),a 
0f8f 13			  inc de 
0f90			 
0f90 01 e8 03		  ld bc,1000 
0f93 3e 3a		  ld a,'9'+1 
0f95 3d			  dec a  
0f96 09			  add hl,bc  
0f97 30 fc		   jr nc,$-2 
0f99 12			  ld (de),a 
0f9a 13			  inc de 
0f9b			 
0f9b 01 9c ff		  ld bc,-100 
0f9e 3e 2f		  ld a,'0'-1 
0fa0 3c			  inc a  
0fa1 09			  add hl,bc  
0fa2 38 fc		   jr c,$-2 
0fa4 12			  ld (de),a 
0fa5 13			  inc de 
0fa6			 
0fa6 7d			  ld a,l 
0fa7 26 3a		  ld h,'9'+1 
0fa9 25			  dec h  
0faa c6 0a		  add a,10  
0fac 30 fb		   jr nc,$-3 
0fae c6 30		  add a,'0' 
0fb0 eb			  ex de,hl 
0fb1 72			  ld (hl),d 
0fb2 23			  inc hl 
0fb3 77			  ld (hl),a 
0fb4 23			  inc hl 
0fb5 36 00		  ld (hl),0 
0fb7			 
0fb7			;Now strip the leading zeros 
0fb7 0e fa		  ld c,-6 
0fb9 09			  add hl,bc 
0fba 3e 30		  ld a,'0' 
0fbc 23			  inc hl  
0fbd be			  cp (hl)  
0fbe 28 fc		  jr z,$-2 
0fc0			 
0fc0			;Make sure that the string is non-empty! 
0fc0 7e			  ld a,(hl) 
0fc1 b7			  or a 
0fc2 20 01		  jr nz,.atoub 
0fc4 2b			  dec hl 
0fc5			.atoub: 
0fc5			 
0fc5 f1			  pop af 
0fc6 c1			  pop bc 
0fc7 d1			  pop de 
0fc8 c9			  ret 
0fc9			 
0fc9			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
0fc9			 
0fc9			toUpper: 
0fc9			;A is the char. 
0fc9			;If A is a lowercase letter, this sets it to the matching uppercase 
0fc9			;18cc or 30cc or 41cc 
0fc9			;avg: 26.75cc 
0fc9 fe 61		  cp 'a' 
0fcb d8			  ret c 
0fcc fe 7b		  cp 'z'+1 
0fce d0			  ret nc 
0fcf d6 20		  sub 'a'-'A' 
0fd1 c9			  ret 
0fd2			 
0fd2			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
0fd2			 
0fd2			; String Length 
0fd2			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
0fd2			 
0fd2			; Get the length of the null-terminated string starting at $8000 hl 
0fd2			;    LD     HL, $8000 
0fd2			 
0fd2			strlenz: 
0fd2			 
0fd2 af			    XOR    A               ; Zero is the value we are looking for. 
0fd3 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
0fd4 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
0fd5			                           ; 65, 536 bytes (the entire addressable memory space). 
0fd5 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
0fd7			 
0fd7			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
0fd7 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
0fd8 6f			    LD     L, A             ; number of bytes 
0fd9 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
0fdb 2b			    DEC    HL              ; Compensate for null. 
0fdc c9				ret 
0fdd			 
0fdd			; Get the length of the A terminated string starting at $8000 hl 
0fdd			;    LD     HL, $8000 
0fdd			 
0fdd			strlent: 
0fdd			 
0fdd			                  ; A is the value we are looking for. 
0fdd 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
0fdf 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
0fe1			                           ; 65, 536 bytes (the entire addressable memory space). 
0fe1 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
0fe3			 
0fe3			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
0fe3 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
0fe5 2e 00		    LD     L, 0             ; number of bytes 
0fe7 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
0fe9 2b			    DEC    HL              ; Compensate for null. 
0fea c9				ret 
0feb			 
0feb			 
0feb			;Comparing Strings 
0feb			 
0feb			;IN    HL     Address of string1. 
0feb			;      DE     Address of string2. 
0feb			 
0feb			; doc given but wrong??? 
0feb			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
0feb			;      carry  Set if string1 > string2, reset if string1 <= string2. 
0feb			; tested 
0feb			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
0feb			 
0feb			strcmp_old: 
0feb e5			    PUSH   HL 
0fec d5			    PUSH   DE 
0fed			 
0fed 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
0fee be			    CP     (HL)            ; (want to minimize work). 
0fef 38 01		    JR     C, Str1IsBigger 
0ff1 7e			    LD     A, (HL) 
0ff2			 
0ff2			Str1IsBigger: 
0ff2 4f			    LD     C, A             ; Put length in BC 
0ff3 06 00		    LD     B, 0 
0ff5 13			    INC    DE              ; Increment pointers to meat of string. 
0ff6 23			    INC    HL 
0ff7			 
0ff7			CmpLoop: 
0ff7 1a			    LD     A, (DE)          ; Compare bytes. 
0ff8 ed a1		    CPI 
0ffa 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
0ffc 13			    INC    DE              ; Update pointer. 
0ffd ea f7 0f		    JP     PE, CmpLoop 
1000			 
1000 d1			    POP    DE 
1001 e1			    POP    HL 
1002 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
1003 be			    CP     (HL) 
1004 c9			    RET 
1005			 
1005			NoMatch: 
1005 2b			    DEC    HL 
1006 be			    CP     (HL)            ; Compare again to affect carry. 
1007 d1			    POP    DE 
1008 e1			    POP    HL 
1009 c9			    RET 
100a			 
100a			;; test strmp 
100a			; 
100a			;ld de, .str1 
100a			;ld hl, .str2 
100a			;call strcmp 
100a			;jr z, .z1 
100a			;;this 
100a			;	if DEBUG_FORTH_WORDS 
100a			;		DMARK "NZ1" 
100a			;		CALLMONITOR 
100a			;	endif 
100a			;.z1: 
100a			; 
100a			;	if DEBUG_FORTH_WORDS 
100a			;		DMARK "ZZ1" 
100a			;		CALLMONITOR 
100a			;	endif 
100a			; 
100a			;ld de, .str1 
100a			;ld hl, .str1 
100a			;call strcmp 
100a			;jr z, .z2 
100a			;;this 
100a			;	if DEBUG_FORTH_WORDS 
100a			;		DMARK "NZ2" 
100a			;		CALLMONITOR 
100a			;	endif 
100a			;.z2: 
100a			; 
100a			;	if DEBUG_FORTH_WORDS 
100a			;		DMARK "ZZ2" 
100a			;		CALLMONITOR 
100a			;	endif 
100a			; 
100a			;ld de, .str1 
100a			;ld hl, .str2 
100a			;call strcmp 
100a			;jr c, .c1 
100a			; 
100a			;	if DEBUG_FORTH_WORDS 
100a			;		DMARK "Nc1" 
100a			;		CALLMONITOR 
100a			;	endif 
100a			;.c1: 
100a			;;this 
100a			;	if DEBUG_FORTH_WORDS 
100a			;		DMARK "cc1" 
100a			;		CALLMONITOR 
100a			;	endif 
100a			; 
100a			;ld de, .str1 
100a			;ld hl, .str1 
100a			;call strcmp 
100a			;jr c, .c2 
100a			;;this 
100a			;	if DEBUG_FORTH_WORDS 
100a			;		DMARK "Nc2" 
100a			;		CALLMONITOR 
100a			;	endif 
100a			;.c2: 
100a			; 
100a			;	if DEBUG_FORTH_WORDS 
100a			;		DMARK "cc2" 
100a			;		CALLMONITOR 
100a			;	endif 
100a			;	NEXTW 
100a			;.str1:   db "string1",0 
100a			;.str2:   db "string2",0 
100a			 
100a			; only care about direct match or not 
100a			; hl and de strings 
100a			; zero set if the same 
100a			 
100a			strcmp: 
100a 1a				ld a, (de) 
100b be				cp (hl) 
100c 28 02			jr z, .ssame 
100e b7				or a 
100f c9				ret 
1010			 
1010			.ssame:  
1010 fe 00			cp 0 
1012 c8				ret z 
1013			 
1013 23				inc hl 
1014 13				inc de 
1015 18 f3			jr strcmp 
1017				 
1017				 
1017			 
1017			 
1017			 
1017			 
1017			; eof 
1017			 
1017			 
1017			 
1017			 
1017			 
1017			 
# End of file firmware_strings.asm
1017			include "firmware_memory.asm"   ; malloc and free  
1017			 
1017			if DEBUG_FORTH_MALLOC_HIGH 
1017			.mallocsize: db "Wants malloc >256",0 
1017			.mallocasize: db "MALLOC gives >256",0 
1017			.malloczero: db "MALLOC gives zero",0 
1017			 
1017			malloc_guard_zerolen: 
1017				push hl 
1017				push de 
1017				push af 
1017			 
1017				ld de, 0 
1017			        call cmp16 
1017				jr nz, .lowalloz 
1017			 
1017				push hl 
1017				push de 
1017					ld hl, display_fb0 
1017					ld (display_fb_active), hl 
1017				call clear_display 
1017				ld a, 0 
1017				ld de, .malloczero 
1017				call str_at_display 
1017				call update_display 
1017				call delay1s 
1017				call delay1s 
1017				ld a, 0 
1017				ld (os_view_disable), a 
1017			 
1017				pop de 
1017				pop hl 
1017			 
1017				 
1017			 
1017				CALLMONITOR 
1017			.lowalloz: 
1017			 
1017			 
1017				pop af 
1017				pop de 
1017				pop hl 
1017			ret 
1017			 
1017			malloc_guard_entry: 
1017				push hl 
1017				push de 
1017				push af 
1017			 
1017			 	or a      ;clear carry flag 
1017				push hl 
1017				ld de, 255 
1017				sbc hl, de 
1017				jr c, .lowalloc 
1017			 
1017				push de 
1017					ld hl, display_fb0 
1017					ld (display_fb_active), hl 
1017				call clear_display 
1017				ld a, 0 
1017				ld de, .mallocsize 
1017				call str_at_display 
1017				call update_display 
1017				call delay1s 
1017				call delay1s 
1017				ld a, 0 
1017				ld (os_view_disable), a 
1017			 
1017				pop de 
1017				pop hl 
1017			 
1017				 
1017			 
1017				CALLMONITOR 
1017				jr .lowdone 
1017			.lowalloc: 
1017			 
1017			 
1017				pop hl 
1017			.lowdone:	pop af 
1017				pop de 
1017				pop hl 
1017			ret 
1017			 
1017			malloc_guard_exit: 
1017				push hl 
1017				push de 
1017				push af 
1017			 
1017			 	or a      ;clear carry flag 
1017				push hl 
1017				ld de, 255 
1017				sbc hl, de 
1017				jr c, .lowallocx 
1017			 
1017				push de 
1017					ld hl, display_fb0 
1017					ld (display_fb_active), hl 
1017				call clear_display 
1017				ld a, 0 
1017				ld de, .mallocasize 
1017				call str_at_display 
1017				call update_display 
1017				call delay1s 
1017				call delay1s 
1017				ld a, 0 
1017				ld (os_view_disable), a 
1017				pop de 
1017				pop hl 
1017			 
1017				CALLMONITOR 
1017				jr .lowdonex 
1017			.lowallocx: 
1017			 
1017				pop hl 
1017			.lowdonex:	pop af 
1017				pop de 
1017				pop hl 
1017			ret 
1017			endif 
1017			 
1017			if MALLOC_2 
1017			; Z80 Malloc and Free Functions 
1017			 
1017			; Malloc Function: 
1017			; Input: 
1017			;   HL: Size of block to allocate 
1017			; Output: 
1017			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1017			 
1017			malloc: 
1017				 
1017			if DEBUG_FORTH_MALLOC_HIGH 
1017			call malloc_guard_entry 
1017			endif 
1017			 
1017			 
1017			 
1017			 
1017					if DEBUG_FORTH_MALLOC 
1017						DMARK "mal" 
1017						CALLMONITOR 
1017					endif 
1017			    push af            ; Save AF register 
1017			    ld a, l            ; Load low byte of size into A 
1017			    or h               ; Check if size is zero 
1017			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
1017			 
1017			    ; Allocate memory 
1017			    ld hl, (heap_start) ; Load start of heap into HL 
1017					if DEBUG_FORTH_MALLOC 
1017						DMARK "ma1" 
1017						CALLMONITOR 
1017					endif 
1017			    call malloc_internal ; Call internal malloc function 
1017			    pop af             ; Restore AF register 
1017			if DEBUG_FORTH_MALLOC_HIGH 
1017			call malloc_guard_exit 
1017			call malloc_guard_zerolen 
1017			endif 
1017			    ret                ; Return 
1017			 
1017			; Free Function: 
1017			; Input: 
1017			;   HL: Pointer to memory block to free 
1017			; Output: 
1017			;   None 
1017			 
1017			free: 
1017			    push af            ; Save AF register 
1017			    ld a, l            ; Load low byte of pointer into A 
1017			    or h               ; Check if pointer is NULL 
1017			    jp z, free_exit    ; If pointer is NULL, exit 
1017			 
1017			    ; Free memory 
1017			    ld hl, (heap_start) ; Load start of heap into HL 
1017			    call free_internal  ; Call internal free function 
1017			    pop af             ; Restore AF register 
1017			    ret                ; Return 
1017			 
1017			; Internal Malloc Function: 
1017			; Input: 
1017			;   HL: Size of block to allocate 
1017			; Output: 
1017			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1017			 
1017			malloc_internal: 
1017			    ld bc, 2           ; Number of bytes to allocate for management overhead 
1017			    add hl, bc         ; Add management overhead to requested size 
1017			    ex de, hl          ; Save total size in DE, and keep it in HL 
1017					if DEBUG_FORTH_MALLOC 
1017						DMARK "ma2" 
1017						CALLMONITOR 
1017					endif 
1017			 
1017			    ; Search for free memory block 
1017			    ld de, (heap_end)  ; Load end of heap into DE 
1017			    ld bc, 0           ; Initialize counter 
1017			 
1017					if DEBUG_FORTH_MALLOC 
1017						DMARK "ma2" 
1017						CALLMONITOR 
1017					endif 
1017			malloc_search_loop: 
1017			    ; Check if current block is free 
1017			    ld a, (hl)         ; Load current block's status (free or used) 
1017			    cp 0               ; Compare with zero (free) 
1017			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
1017			 
1017			    ; Check if current block is large enough 
1017			    ld a, (hl+1)       ; Load high byte of block size 
1017			    cp l               ; Compare with low byte of requested size 
1017			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
1017			 
1017			    ld a, (hl+2)       ; Load low byte of block size 
1017			    cp h               ; Compare with high byte of requested size 
1017			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
1017			 
1017			    ; Mark block as used 
1017			    ld (hl), 0xFF      ; Set status byte to indicate used block 
1017			 
1017			    ; Calculate remaining space in block 
1017			    ld bc, 0           ; Clear BC 
1017			    add hl, bc         ; Increment HL to point to start of data block 
1017			    add hl, de         ; HL = HL + DE (total size) 
1017			    ld bc, 1           ; Number of bytes to allocate for management overhead 
1017			    add hl, bc         ; Add management overhead to start of data block 
1017			 
1017			    ; Save pointer to allocated block in HL 
1017			if DEBUG_FORTH_MALLOC_HIGH 
1017						DMARK "ma5" 
1017			call malloc_guard_exit 
1017			call malloc_guard_zerolen 
1017			endif 
1017			    ret 
1017			 
1017			malloc_skip_block_check: 
1017			    ; Move to the next block 
1017			    ld bc, 3           ; Size of management overhead 
1017			    add hl, bc         ; Move to the next block 
1017			    inc de             ; Increment counter 
1017			 
1017			    ; Check if we have reached the end of heap 
1017			    ld a, e            ; Load low byte of heap end address 
1017			    cp (hl)            ; Compare with low byte of current address 
1017			    jr nz, malloc_search_loop  ; If not equal, continue searching 
1017			    ld a, d            ; Load high byte of heap end address 
1017			    cp 0               ; Check if it's zero (end of memory) 
1017			    jr nz, malloc_search_loop  ; If not zero, continue searching 
1017			 
1017			    ; If we reached here, allocation failed 
1017			    xor a              ; Set result to NULL 
1017			if DEBUG_FORTH_MALLOC_HIGH 
1017						DMARK "ma6" 
1017			call malloc_guard_exit 
1017			call malloc_guard_zerolen 
1017			endif 
1017			    ret 
1017			malloc_exit: 
1017			if DEBUG_FORTH_MALLOC_HIGH 
1017						DMARK "ma7" 
1017			call malloc_guard_exit 
1017			call malloc_guard_zerolen 
1017			endif 
1017			    ret 
1017			 
1017			; Internal Free Function: 
1017			; Input: 
1017			;   HL: Pointer to memory block to free 
1017			; Output: 
1017			;   None 
1017			 
1017			free_internal: 
1017			    ld de, (heap_start) ; Load start of heap into DE 
1017			    ld bc, 0            ; Initialize counter 
1017			 
1017			free_search_loop: 
1017			    ; Check if current block contains the pointer 
1017			    ld a, l             ; Load low byte of pointer 
1017			    cp (hl+1)           ; Compare with high byte of current block's address 
1017			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1017			    ld a, h             ; Load high byte of pointer 
1017			    cp (hl+2)           ; Compare with low byte of current block's address 
1017			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1017			 
1017			    ; Mark block as free 
1017			    ld (hl), 0          ; Set status byte to indicate free block 
1017			    ret                 ; Return 
1017			 
1017			free_skip_block_check: 
1017			    ; Move to the next block 
1017			    ld bc, 3            ; Size of management overhead 
1017			    add hl, bc          ; Move to the next block 
1017			    inc de              ; Increment counter 
1017			 
1017			    ; Check if we have reached the end of heap 
1017			    ld a, e             ; Load low byte of heap end address 
1017			    cp (hl)             ; Compare with low byte of current address 
1017			    jr nz, free_search_loop  ; If not equal, continue searching 
1017			    ld a, d             ; Load high byte of heap end address 
1017			    cp 0                ; Check if it's zero (end of memory) 
1017			    jr nz, free_search_loop  ; If not zero, continue searching 
1017			 
1017			    ; If we reached here, pointer is not found in heap 
1017			    ret 
1017			 
1017			free_exit: 
1017			    ret                 ; Return 
1017			 
1017			; Define heap start and end addresses 
1017			;heap_start:    .dw 0xC000   ; Start of heap 
1017			;heap_end:      .dw 0xE000   ; End of heap 
1017			 
1017			endif 
1017			 
1017			 
1017			if MALLOC_1 
1017			 
1017			 
1017			 
1017			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
1017			 
1017			;moved to firmware.asm 
1017			;heap_start        .equ  0x9000      ; Starting address of heap 
1017			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1017			 
1017			;      .org 0 
1017			;      jp    main 
1017			 
1017			 
1017			;      .org  0x100 
1017			;main: 
1017			;      ld    HL, 0x8100 
1017			;      ld    SP, HL 
1017			; 
1017			;      call  heap_init 
1017			; 
1017			;      ; Make some allocations 
1017			;      ld    HL, 12 
1017			;      call  malloc            ; Allocates 0x9004 
1017			; 
1017			;      ld    HL, 12 
1017			;      call  malloc            ; Allocates 0x9014 
1017			; 
1017			;      ld    HL, 12 
1017			;      call  malloc            ; Allocates 0x9024 
1017			; 
1017			;      ; Free some allocations 
1017			;      ld    HL, 0x9014 
1017			;      call  free 
1017			; 
1017			;      ld    HL, 0x9004 
1017			;      call  free 
1017			; 
1017			;      ld    HL, 0x9024 
1017			;      call  free 
1017			; 
1017			; 
1017			;      halt 
1017			 
1017			 
1017			;------------------------------------------------------------------------------ 
1017			;     heap_init                                                               : 
1017			;                                                                             : 
1017			; Description                                                                 : 
1017			;     Initialise the heap and make it ready for malloc and free operations.   : 
1017			;                                                                             : 
1017			;     The heap is maintained as a linked list, starting with an initial       : 
1017			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1017			;     the first free block in the heap. Each block then points to the next    : 
1017			;     free block within the heap, and the free list ends at the first block   : 
1017			;     with a null pointer to the next free block.                             : 
1017			;                                                                             : 
1017			; Parameters                                                                  : 
1017			;     Inputs are compile-time only. Two defines which specify the starting    : 
1017			;     address of the heap and its size are required, along with a memory      : 
1017			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1017			;     principally stores a pointer to the first free block in the heap.       : 
1017			;                                                                             : 
1017			; Returns                                                                     : 
1017			;     Nothing                                                                 : 
1017			;------------------------------------------------------------------------------ 
1017			heap_init: 
1017 e5			      push  HL 
1018			 
1018			      ; Initialise free list struct 
1018 21 a2 59		      ld    HL, heap_start 
101b 22 9d 59		      ld    (free_list), HL 
101e 21 00 00		      ld    HL, 0 
1021 22 9f 59		      ld    (free_list+2), HL 
1024			 
1024			      ; Insert first free block at bottom of heap, consumes entire heap 
1024 21 42 e3		      ld    HL, heap_start+heap_size-4 
1027 22 a2 59		      ld    (heap_start), HL        ; Next block (end of free list) 
102a 21 a0 89		      ld    HL, heap_size-4 
102d 22 a4 59		      ld    (heap_start+2), HL      ; Block size 
1030			 
1030			      ; Insert end of free list block at top of heap - two null words will 
1030			      ; terminate the free list 
1030 21 00 00		      ld    HL, 0 
1033 22 44 e3		      ld    (heap_start+heap_size-2), HL 
1036 22 42 e3		      ld    (heap_start+heap_size-4), HL 
1039			 
1039 e1			      pop   HL 
103a			 
103a c9			      ret 
103b			 
103b			 
103b			;------------------------------------------------------------------------------ 
103b			;     malloc                                                                  : 
103b			;                                                                             : 
103b			; Description                                                                 : 
103b			;     Allocates the wanted space from the heap and returns the address of the : 
103b			;     first useable byte of the allocation.                                   : 
103b			;                                                                             : 
103b			;     Allocations can happen in one of two ways:                              : 
103b			;                                                                             : 
103b			;     1. A free block may be found which is the exact size wanted. In this    : 
103b			;        case the block is removed from the free list and retuedn to the      : 
103b			;        caller.                                                              : 
103b			;     2. A free block may be found which is larger than the size wanted. In   : 
103b			;        this case, the larger block is split into two. The first portion of  : 
103b			;        this block will become the requested space by the malloc call and    : 
103b			;        is returned to the caller. The second portion becomes a new free     : 
103b			;        block, and the free list is adjusted to maintain continuity via this : 
103b			;        newly created block.                                                 : 
103b			;                                                                             : 
103b			;     malloc does not set any initial value in the allocated space, the       : 
103b			;     caller is required to do this as required.                              : 
103b			;                                                                             : 
103b			;     This implementation of malloc uses the stack exclusively, and is        : 
103b			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
103b			;     advisable to disable interrupts before calling malloc, and recommended  : 
103b			;     to avoid the use of malloc inside ISRs in general.                      : 
103b			;                                                                             : 
103b			;     NOTE: heap_init must be called before malloc and free can be used.      : 
103b			;                                                                             : 
103b			; Parameters                                                                  : 
103b			;     HL  Number of bytes wanted                                              : 
103b			;                                                                             : 
103b			; Returns                                                                     : 
103b			;     HL  Address of the first useable byte of the allocation                 : 
103b			;                                                                             : 
103b			; Flags                                                                       : 
103b			;     Z   Set if the allocation did not succeed, clear otherwise              : 
103b			;                                                                             : 
103b			; Stack frame                                                                 : 
103b			;       |             |                                                       : 
103b			;       +-------------+                                                       : 
103b			;       |     BC      |                                                       : 
103b			;       +-------------+                                                       : 
103b			;       |     DE      |                                                       : 
103b			;       +-------------+                                                       : 
103b			;       |     IX      |                                                       : 
103b			;       +-------------+                                                       : 
103b			;       |  prev_free  |                                                       : 
103b			;   +4  +-------------+                                                       : 
103b			;       |  this_free  |                                                       : 
103b			;   +2  +-------------+                                                       : 
103b			;       |  next_free  |                                                       : 
103b			;   +0  +-------------+                                                       : 
103b			;       |             |                                                       : 
103b			;                                                                             : 
103b			;------------------------------------------------------------------------------ 
103b			 
103b			 
103b			;malloc: 
103b			; 
103b			;	SAVESP ON 1 
103b			; 
103b			;	call malloc_code 
103b			; 
103b			;	CHECKSP ON 1 
103b			;	ret 
103b			 
103b			 
103b			malloc: 
103b c5			      push  BC 
103c d5			      push  DE 
103d dd e5		      push  IX 
103f			if DEBUG_FORTH_MALLOC_HIGH 
103f			call malloc_guard_entry 
103f			endif 
103f			 
103f					if DEBUG_FORTH_MALLOC 
103f						DMARK "mal" 
103f						CALLMONITOR 
103f					endif 
103f 7c			      ld    A, H                    ; Exit if no space requested 
1040 b5			      or    L 
1041 ca 00 11		      jp    Z, malloc_early_exit 
1044			 
1044			;inc hl 
1044			;inc hl 
1044			;inc hl 
1044			; 
1044			;inc hl 
1044			;inc hl 
1044			;inc hl 
1044			;inc hl 
1044			;inc hl 
1044			;inc hl 
1044			;inc hl 
1044			;inc hl 
1044			;inc hl 
1044			 
1044			 
1044			 
1044			 
1044					if DEBUG_FORTH_MALLOC 
1044						DMARK "maA" 
1044						CALLMONITOR 
1044					endif 
1044			      ; Set up stack frame 
1044 eb			      ex    DE, HL 
1045 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1048 39			      add   HL, SP 
1049 f9			      ld    SP, HL 
104a dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
104e dd 39		      add   IX, SP 
1050			 
1050			      ; Setup initial state 
1050 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
1053 19			      add   HL, DE 
1054			 
1054 44			      ld    B, H                    ; Move want to BC 
1055 4d			      ld    C, L 
1056			 
1056 21 9d 59		      ld    HL, free_list           ; Store prev_free ptr to stack 
1059 dd 75 04		      ld    (IX+4), L 
105c dd 74 05		      ld    (IX+5), H 
105f			 
105f 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
1060 23			      inc   HL 
1061 56			      ld    D, (HL) 
1062 dd 73 02		      ld    (IX+2), E 
1065 dd 72 03		      ld    (IX+3), D 
1068 eb			      ex    DE, HL                  ; this_free ptr into HL 
1069			 
1069					if DEBUG_FORTH_MALLOC 
1069						DMARK "maB" 
1069						CALLMONITOR 
1069					endif 
1069			      ; Loop through free block list to find some space 
1069			malloc_find_space: 
1069 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
106a 23			      inc   HL 
106b 56			      ld    D, (HL) 
106c			 
106c 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
106d b3			      or    E 
106e ca fa 10		      jp    Z, malloc_no_space 
1071			 
1071 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
1074 dd 72 01		      ld    (IX+1), D 
1077			 
1077			      ; Does this block have enough space to make the allocation? 
1077 23			      inc   HL                      ; Load free block size into DE 
1078 5e			      ld    E, (HL) 
1079 23			      inc   HL 
107a 56			      ld    D, (HL) 
107b			 
107b eb			      ex    DE, HL                  ; Check size of block against want 
107c b7			      or    A                       ; Ensure carry flag clear 
107d ed 42		      sbc   HL, BC 
107f e5			      push  HL                      ; Store the result for later (new block size) 
1080			 
1080 ca cf 10		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1083 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1085			 
1085			      ; this_free block is not big enough, setup ptrs to test next free block 
1085 e1			      pop   HL                      ; Discard previous result 
1086			 
1086 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1089 dd 66 03		      ld    H, (IX+3) 
108c dd 75 04		      ld    (IX+4), L 
108f dd 74 05		      ld    (IX+5), H 
1092			 
1092 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1095 dd 66 01		      ld    H, (IX+1) 
1098 dd 75 02		      ld    (IX+2), L 
109b dd 74 03		      ld    (IX+3), H 
109e			 
109e					if DEBUG_FORTH_MALLOC 
109e						DMARK "MA>" 
109e						CALLMONITOR 
109e					endif 
109e 18 c9		      jr    malloc_find_space 
10a0			 
10a0			      ; split a bigger block into two - requested size and remaining size 
10a0			malloc_alloc_split: 
10a0					if DEBUG_FORTH_MALLOC 
10a0						DMARK "MAs" 
10a0						CALLMONITOR 
10a0					endif 
10a0 eb			      ex    DE, HL                  ; Calculate address of new free block 
10a1 2b			      dec   HL 
10a2 2b			      dec   HL 
10a3 2b			      dec   HL 
10a4 09			      add   HL, BC 
10a5			 
10a5			      ; Create a new block and point it at next_free 
10a5 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
10a8 dd 56 01		      ld    D, (IX+1) 
10ab			 
10ab 73			      ld    (HL), E                 ; Store next_free ptr into new block 
10ac 23			      inc   HL 
10ad 72			      ld    (HL), D 
10ae			 
10ae d1			      pop   DE                      ; Store size of new block into new block 
10af 23			      inc   HL 
10b0 73			      ld    (HL), E 
10b1 23			      inc   HL 
10b2 72			      ld    (HL), D 
10b3			 
10b3			      ; Update this_free ptr to point to new block 
10b3 2b			      dec   HL 
10b4 2b			      dec   HL 
10b5 2b			      dec   HL 
10b6			 
10b6 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
10b9 dd 56 03		      ld    D, (IX+3) 
10bc			 
10bc dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
10bf dd 74 03		      ld    (IX+3), H 
10c2			 
10c2			      ; Modify this_free block to be allocation 
10c2 eb			      ex    DE, HL 
10c3 af			      xor   A                       ; Null the next block ptr of allocated block 
10c4 77			      ld    (HL), A 
10c5 23			      inc   HL 
10c6 77			      ld    (HL), A 
10c7			 
10c7 23			      inc   HL                      ; Store want size into allocated block 
10c8 71			      ld    (HL), C 
10c9 23			      inc   HL 
10ca 70			      ld    (HL), B 
10cb 23			      inc   HL 
10cc e5			      push  HL                      ; Address of allocation to return 
10cd			 
10cd 18 19		      jr    malloc_update_links 
10cf			 
10cf			malloc_alloc_fit: 
10cf e1			      pop   HL                      ; Dont need new block size, want is exact fit 
10d0			 
10d0					if DEBUG_FORTH_MALLOC 
10d0						DMARK "MAf" 
10d0						CALLMONITOR 
10d0					endif 
10d0			      ; Modify this_free block to be allocation 
10d0 eb			      ex    DE, HL 
10d1 2b			      dec   HL 
10d2 2b			      dec   HL 
10d3 2b			      dec   HL 
10d4			 
10d4 af			      xor   A                       ; Null the next block ptr of allocated block 
10d5 77			      ld    (HL), A 
10d6 23			      inc   HL 
10d7 77			      ld    (HL), A 
10d8			 
10d8 23			      inc   HL                      ; Store address of allocation to return 
10d9 23			      inc   HL 
10da 23			      inc   HL 
10db e5			      push  HL 
10dc			 
10dc			      ; Copy next_free ptr to this_free, remove allocated block from free list 
10dc dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
10df dd 66 01		      ld    H, (IX+1) 
10e2			 
10e2 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
10e5 dd 74 03		      ld    (IX+3), H 
10e8			 
10e8			 
10e8			malloc_update_links: 
10e8			      ; Update prev_free ptr to point to this_free 
10e8 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
10eb dd 66 05		      ld    H, (IX+5) 
10ee			 
10ee dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
10f1 dd 56 03		      ld    D, (IX+3) 
10f4			 
10f4 73			      ld    (HL), E                 ; this_free ptr into prev_free 
10f5 23			      inc   HL 
10f6 72			      ld    (HL), D 
10f7			 
10f7					if DEBUG_FORTH_MALLOC 
10f7						DMARK "Mul" 
10f7						CALLMONITOR 
10f7					endif 
10f7			      ; Clear the Z flag to indicate successful allocation 
10f7 7a			      ld    A, D 
10f8 b3			      or    E 
10f9			 
10f9 d1			      pop   DE                      ; Address of allocation 
10fa					if DEBUG_FORTH_MALLOC 
10fa						DMARK "MAu" 
10fa						CALLMONITOR 
10fa					endif 
10fa			 
10fa			malloc_no_space: 
10fa 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
10fd 39			      add   HL, SP 
10fe f9			      ld    SP, HL 
10ff			 
10ff eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1100					if DEBUG_FORTH_MALLOC 
1100						DMARK "MAN" 
1100						CALLMONITOR 
1100					endif 
1100			 
1100			malloc_early_exit: 
1100					if DEBUG_FORTH_MALLOC 
1100						DMARK "MAx" 
1100						CALLMONITOR 
1100					endif 
1100 dd e1		      pop   IX 
1102 d1			      pop   DE 
1103 c1			      pop   BC 
1104			 
1104			if DEBUG_FORTH_MALLOC_HIGH 
1104			call malloc_guard_exit 
1104			call malloc_guard_zerolen 
1104			endif 
1104 c9			      ret 
1105			 
1105			 
1105			;------------------------------------------------------------------------------ 
1105			;     free                                                                    : 
1105			;                                                                             : 
1105			; Description                                                                 : 
1105			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1105			;     returned by malloc, otherwise the behaviour is undefined.               : 
1105			;                                                                             : 
1105			;     Where possible, directly adjacent free blocks will be merged together   : 
1105			;     into larger blocks to help ensure that the heap does not become         : 
1105			;     excessively fragmented.                                                 : 
1105			;                                                                             : 
1105			;     free does not clear or set any other value into the freed space, and    : 
1105			;     therefore its contents may be visible through subsequent malloc's. The  : 
1105			;     caller should clear the freed space as required.                        : 
1105			;                                                                             : 
1105			;     This implementation of free uses the stack exclusively, and is          : 
1105			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1105			;     advisable to disable interrupts before calling free, and recommended    : 
1105			;     to avoid the use of free inside ISRs in general.                        : 
1105			;                                                                             : 
1105			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1105			;                                                                             : 
1105			; Parameters                                                                  : 
1105			;     HL  Pointer to address of first byte of allocation to be freed          : 
1105			;                                                                             : 
1105			; Returns                                                                     : 
1105			;     Nothing                                                                 : 
1105			;                                                                             : 
1105			; Stack frame                                                                 : 
1105			;       |             |                                                       : 
1105			;       +-------------+                                                       : 
1105			;       |     BC      |                                                       : 
1105			;       +-------------+                                                       : 
1105			;       |     DE      |                                                       : 
1105			;       +-------------+                                                       : 
1105			;       |     IX      |                                                       : 
1105			;       +-------------+                                                       : 
1105			;       |  prev_free  |                                                       : 
1105			;   +2  +-------------+                                                       : 
1105			;       |  next_free  |                                                       : 
1105			;   +0  +-------------+                                                       : 
1105			;       |             |                                                       : 
1105			;                                                                             : 
1105			;------------------------------------------------------------------------------ 
1105			free: 
1105 c5			      push  BC 
1106 d5			      push  DE 
1107 dd e5		      push  IX 
1109			 
1109 7c			      ld    A, H                    ; Exit if ptr is null 
110a b5			      or    L 
110b ca cf 11		      jp    Z, free_early_exit 
110e			 
110e			      ; Set up stack frame 
110e eb			      ex    DE, HL 
110f 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1112 39			      add   HL, SP 
1113 f9			      ld    SP, HL 
1114 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1118 dd 39		      add   IX, SP 
111a			 
111a			      ; The address in HL points to the start of the useable allocated space, 
111a			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
111a			      ; address of the block itself. 
111a eb			      ex    DE, HL 
111b 11 fc ff		      ld    DE, -4 
111e 19			      add   HL, DE 
111f			 
111f			      ; An allocated block must have a null next block pointer in it 
111f 7e			      ld    A, (HL) 
1120 23			      inc   HL 
1121 b6			      or    (HL) 
1122 c2 ca 11		      jp    NZ, free_done 
1125			 
1125 2b			      dec   HL 
1126			 
1126 44			      ld    B, H                    ; Copy HL to BC 
1127 4d			      ld    C, L 
1128			 
1128			      ; Loop through the free list to find the first block with an address 
1128			      ; higher than the block being freed 
1128 21 9d 59		      ld    HL, free_list 
112b			 
112b			free_find_higher_block: 
112b 5e			      ld    E, (HL)                 ; Load next ptr from free block 
112c 23			      inc   HL 
112d 56			      ld    D, (HL) 
112e 2b			      dec   HL 
112f			 
112f dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
1132 dd 72 01		      ld    (IX+1), D 
1135 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
1138 dd 74 03		      ld    (IX+3), H 
113b			 
113b 78			      ld    A, B                    ; Check if DE is greater than BC 
113c ba			      cp    D                       ; Compare MSB first 
113d 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
113f 30 04		      jr    NC, free_find_higher_block_skip 
1141 79			      ld    A, C 
1142 bb			      cp    E                       ; Then compare LSB 
1143 38 08		      jr    C, free_found_higher_block 
1145			 
1145			free_find_higher_block_skip: 
1145 7a			      ld    A, D                    ; Reached the end of the free list? 
1146 b3			      or    E 
1147 ca ca 11		      jp    Z, free_done 
114a			 
114a eb			      ex    DE, HL 
114b			 
114b 18 de		      jr    free_find_higher_block 
114d			 
114d			free_found_higher_block: 
114d			      ; Insert freed block between prev and next free blocks 
114d 71			      ld    (HL), C                 ; Point prev free block to freed block 
114e 23			      inc   HL 
114f 70			      ld    (HL), B 
1150			 
1150 60			      ld    H, B                    ; Point freed block at next free block 
1151 69			      ld    L, C 
1152 73			      ld    (HL), E 
1153 23			      inc   HL 
1154 72			      ld    (HL), D 
1155			 
1155			      ; Check if the freed block is adjacent to the next free block 
1155 23			      inc   HL                      ; Load size of freed block into HL 
1156 5e			      ld    E, (HL) 
1157 23			      inc   HL 
1158 56			      ld    D, (HL) 
1159 eb			      ex    DE, HL 
115a			 
115a 09			      add   HL, BC                  ; Add addr of freed block and its size 
115b			 
115b dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
115e dd 56 01		      ld    D, (IX+1) 
1161			 
1161 b7			      or    A                       ; Clear the carry flag 
1162 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1164 20 22		      jr    NZ, free_check_adjacent_to_prev 
1166			 
1166			      ; Freed block is adjacent to next, merge into one bigger block 
1166 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
1167 5e			      ld    E, (HL) 
1168 23			      inc   HL 
1169 56			      ld    D, (HL) 
116a e5			      push  HL                      ; Save ptr to next block for later 
116b			 
116b 60			      ld    H, B                    ; Store ptr from next block into freed block 
116c 69			      ld    L, C 
116d 73			      ld    (HL), E 
116e 23			      inc   HL 
116f 72			      ld    (HL), D 
1170			 
1170 e1			      pop   HL                      ; Restore ptr to next block 
1171 23			      inc   HL                      ; Load size of next block into DE 
1172 5e			      ld    E, (HL) 
1173 23			      inc   HL 
1174 56			      ld    D, (HL) 
1175 d5			      push  DE                      ; Save next block size for later 
1176			 
1176 60			      ld    H, B                    ; Load size of freed block into HL 
1177 69			      ld    L, C 
1178 23			      inc   HL 
1179 23			      inc   HL 
117a 5e			      ld    E, (HL) 
117b 23			      inc   HL 
117c 56			      ld    D, (HL) 
117d eb			      ex    DE, HL 
117e			 
117e d1			      pop   DE                      ; Restore size of next block 
117f 19			      add   HL, DE                  ; Add sizes of both blocks 
1180 eb			      ex    DE, HL 
1181			 
1181 60			      ld    H, B                    ; Store new bigger size into freed block 
1182 69			      ld    L, C 
1183 23			      inc   HL 
1184 23			      inc   HL 
1185 73			      ld    (HL), E 
1186 23			      inc   HL 
1187 72			      ld    (HL), D 
1188			 
1188			free_check_adjacent_to_prev: 
1188			      ; Check if the freed block is adjacent to the prev free block 
1188 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
118b dd 66 03		      ld    H, (IX+3) 
118e			 
118e 23			      inc   HL                      ; Size of prev free block into DE 
118f 23			      inc   HL 
1190 5e			      ld    E, (HL) 
1191 23			      inc   HL 
1192 56			      ld    D, (HL) 
1193 2b			      dec   HL 
1194 2b			      dec   HL 
1195 2b			      dec   HL 
1196			 
1196 19			      add   HL, DE                  ; Add prev block addr and size 
1197			 
1197 b7			      or    A                       ; Clear the carry flag 
1198 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
119a 20 2e		      jr    NZ, free_done 
119c			 
119c			      ; Freed block is adjacent to prev, merge into one bigger block 
119c 60			      ld    H, B                    ; Load next ptr from freed block into DE 
119d 69			      ld    L, C 
119e 5e			      ld    E, (HL) 
119f 23			      inc   HL 
11a0 56			      ld    D, (HL) 
11a1 e5			      push  HL                      ; Save freed block ptr for later 
11a2			 
11a2 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
11a5 dd 66 03		      ld    H, (IX+3) 
11a8 73			      ld    (HL), E 
11a9 23			      inc   HL 
11aa 72			      ld    (HL), D 
11ab			 
11ab e1			      pop   HL                      ; Restore freed block ptr 
11ac 23			      inc   HL                      ; Load size of freed block into DE 
11ad 5e			      ld    E, (HL) 
11ae 23			      inc   HL 
11af 56			      ld    D, (HL) 
11b0 d5			      push  DE                      ; Save freed block size for later 
11b1			 
11b1 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
11b4 dd 66 03		      ld    H, (IX+3) 
11b7 23			      inc   HL 
11b8 23			      inc   HL 
11b9 5e			      ld    E, (HL) 
11ba 23			      inc   HL 
11bb 56			      ld    D, (HL) 
11bc			 
11bc e1			      pop   HL                      ; Add sizes of both blocks 
11bd 19			      add   HL, DE 
11be eb			      ex    DE, HL 
11bf			 
11bf dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
11c2 dd 66 03		      ld    H, (IX+3) 
11c5 23			      inc   HL 
11c6 23			      inc   HL 
11c7 73			      ld    (HL), E 
11c8 23			      inc   HL 
11c9 72			      ld    (HL), D 
11ca			 
11ca			free_done: 
11ca 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
11cd 39			      add   HL, SP 
11ce f9			      ld    SP, HL 
11cf			 
11cf			free_early_exit: 
11cf dd e1		      pop   IX 
11d1 d1			      pop   DE 
11d2 c1			      pop   BC 
11d3			 
11d3 c9			      ret 
11d4			 
11d4			; moved to firmware.asm 
11d4			; 
11d4			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
11d4			;                  .dw   0 
11d4			 
11d4			 
11d4			endif 
11d4			 
11d4			 
11d4			if MALLOC_3 
11d4			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
11d4			;heap_start        .equ  0x9000      ; Starting address of heap 
11d4			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
11d4			; 
11d4			 ;     .org 0 
11d4			  ;    jp    main 
11d4			; 
11d4			; 
11d4			 ;     .org  0x100 
11d4			;main: 
11d4			 ;     ld    HL, 0x8100 
11d4			  ;    ld    SP, HL 
11d4			; 
11d4			;      call  heap_init 
11d4			 
11d4			      ; Make some allocations 
11d4			;      ld    HL, 12 
11d4			;      call  malloc            ; Allocates 0x9004 
11d4			; 
11d4			 ;     ld    HL, 12 
11d4			;      call  malloc            ; Allocates 0x9014 
11d4			 
11d4			;      ld    HL, 12 
11d4			;      call  malloc            ; Allocates 0x9024 
11d4			 
11d4			      ; Free some allocations 
11d4			;      ld    HL, 0x9014 
11d4			;      call  free 
11d4			 
11d4			;      ld    HL, 0x9004 
11d4			;      call  free 
11d4			; 
11d4			;      ld    HL, 0x9024 
11d4			;      call  free 
11d4			 
11d4			 
11d4			 ;     halt 
11d4			 
11d4			 
11d4			;------------------------------------------------------------------------------ 
11d4			;     heap_init                                                               : 
11d4			;                                                                             : 
11d4			; Description                                                                 : 
11d4			;     Initialise the heap and make it ready for malloc and free operations.   : 
11d4			;                                                                             : 
11d4			;     The heap is maintained as a linked list, starting with an initial       : 
11d4			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
11d4			;     the first free block in the heap. Each block then points to the next    : 
11d4			;     free block within the heap, and the free list ends at the first block   : 
11d4			;     with a null pointer to the next free block.                             : 
11d4			;                                                                             : 
11d4			; Parameters                                                                  : 
11d4			;     Inputs are compile-time only. Two defines which specify the starting    : 
11d4			;     address of the heap and its size are required, along with a memory      : 
11d4			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
11d4			;     principally stores a pointer to the first free block in the heap.       : 
11d4			;                                                                             : 
11d4			; Returns                                                                     : 
11d4			;     Nothing                                                                 : 
11d4			;------------------------------------------------------------------------------ 
11d4			heap_init: 
11d4			      push  HL 
11d4			 
11d4			      ; Initialise free list struct 
11d4			      ld    HL, heap_start 
11d4			      ld    (free_list), HL 
11d4			      ld    HL, 0 
11d4			      ld    (free_list+2), HL 
11d4			 
11d4			      ; Insert first free block at bottom of heap, consumes entire heap 
11d4			      ld    HL, heap_start+heap_size-4 
11d4			      ld    (heap_start), HL        ; Next block (end of free list) 
11d4			      ld    HL, heap_size-4 
11d4			      ld    (heap_start+2), HL      ; Block size 
11d4			 
11d4			      ; Insert end of free list block at top of heap - two null words will 
11d4			      ; terminate the free list 
11d4			      ld    HL, 0 
11d4			      ld    (heap_start+heap_size-2), HL 
11d4			      ld    (heap_start+heap_size-4), HL 
11d4			 
11d4			      pop   HL 
11d4			 
11d4			      ret 
11d4			 
11d4			 
11d4			;------------------------------------------------------------------------------ 
11d4			;     malloc                                                                  : 
11d4			;                                                                             : 
11d4			; Description                                                                 : 
11d4			;     Allocates the wanted space from the heap and returns the address of the : 
11d4			;     first useable byte of the allocation.                                   : 
11d4			;                                                                             : 
11d4			;     Allocations can happen in one of two ways:                              : 
11d4			;                                                                             : 
11d4			;     1. A free block may be found which is the exact size wanted. In this    : 
11d4			;        case the block is removed from the free list and retuedn to the      : 
11d4			;        caller.                                                              : 
11d4			;     2. A free block may be found which is larger than the size wanted. In   : 
11d4			;        this case, the larger block is split into two. The first portion of  : 
11d4			;        this block will become the requested space by the malloc call and    : 
11d4			;        is returned to the caller. The second portion becomes a new free     : 
11d4			;        block, and the free list is adjusted to maintain continuity via this : 
11d4			;        newly created block.                                                 : 
11d4			;                                                                             : 
11d4			;     malloc does not set any initial value in the allocated space, the       : 
11d4			;     caller is required to do this as required.                              : 
11d4			;                                                                             : 
11d4			;     This implementation of malloc uses the stack exclusively, and is        : 
11d4			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
11d4			;     advisable to disable interrupts before calling malloc, and recommended  : 
11d4			;     to avoid the use of malloc inside ISRs in general.                      : 
11d4			;                                                                             : 
11d4			;     NOTE: heap_init must be called before malloc and free can be used.      : 
11d4			;                                                                             : 
11d4			; Parameters                                                                  : 
11d4			;     HL  Number of bytes wanted                                              : 
11d4			;                                                                             : 
11d4			; Returns                                                                     : 
11d4			;     HL  Address of the first useable byte of the allocation                 : 
11d4			;                                                                             : 
11d4			; Flags                                                                       : 
11d4			;     Z   Set if the allocation did not succeed, clear otherwise              : 
11d4			;                                                                             : 
11d4			; Stack frame                                                                 : 
11d4			;       |             |                                                       : 
11d4			;       +-------------+                                                       : 
11d4			;       |     BC      |                                                       : 
11d4			;       +-------------+                                                       : 
11d4			;       |     DE      |                                                       : 
11d4			;       +-------------+                                                       : 
11d4			;       |     IX      |                                                       : 
11d4			;       +-------------+                                                       : 
11d4			;       |  prev_free  |                                                       : 
11d4			;   +4  +-------------+                                                       : 
11d4			;       |  this_free  |                                                       : 
11d4			;   +2  +-------------+                                                       : 
11d4			;       |  next_free  |                                                       : 
11d4			;   +0  +-------------+                                                       : 
11d4			;       |             |                                                       : 
11d4			;                                                                             : 
11d4			;------------------------------------------------------------------------------ 
11d4			malloc: 
11d4			      push  BC 
11d4			      push  DE 
11d4			      push  IX 
11d4			 
11d4			      ld    A, H                    ; Exit if no space requested 
11d4			      or    L 
11d4			      jp    Z, malloc_early_exit 
11d4			 
11d4			      ; Set up stack frame 
11d4			      ex    DE, HL 
11d4			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
11d4			      add   HL, SP 
11d4			      ld    SP, HL 
11d4			      ld    IX, 0                   ; Use IX as a frame pointer 
11d4			      add   IX, SP 
11d4			 
11d4			      ; Setup initial state 
11d4			      ld    HL, 4                   ; want must also include space used by block struct 
11d4			      add   HL, DE 
11d4			 
11d4			      ld    B, H                    ; Move want to BC 
11d4			      ld    C, L 
11d4			 
11d4			      ld    HL, free_list           ; Store prev_free ptr to stack 
11d4			      ld    (IX+4), L 
11d4			      ld    (IX+5), H 
11d4			 
11d4			      ld    E, (HL)                 ; Store this_free ptr to stack 
11d4			      inc   HL 
11d4			      ld    D, (HL) 
11d4			      ld    (IX+2), E 
11d4			      ld    (IX+3), D 
11d4			      ex    DE, HL                  ; this_free ptr into HL 
11d4			 
11d4			      ; Loop through free block list to find some space 
11d4			malloc_find_space: 
11d4			      ld    E, (HL)                 ; Load next_free ptr into DE 
11d4			      inc   HL 
11d4			      ld    D, (HL) 
11d4			 
11d4			      ld    A, D                    ; Check for null next_free ptr - end of free list 
11d4			      or    E 
11d4			      jp    Z, malloc_no_space 
11d4			 
11d4			      ld    (IX+0), E               ; Store next_free ptr to stack 
11d4			      ld    (IX+1), D 
11d4			 
11d4			      ; Does this block have enough space to make the allocation? 
11d4			      inc   HL                      ; Load free block size into DE 
11d4			      ld    E, (HL) 
11d4			      inc   HL 
11d4			      ld    D, (HL) 
11d4			 
11d4			      ex    DE, HL                  ; Check size of block against want 
11d4			      or    A                       ; Ensure carry flag clear 
11d4			      sbc   HL, BC 
11d4			      push  HL                      ; Store the result for later (new block size) 
11d4			 
11d4			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
11d4			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
11d4			 
11d4			      ; this_free block is not big enough, setup ptrs to test next free block 
11d4			      pop   HL                      ; Discard previous result 
11d4			 
11d4			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
11d4			      ld    H, (IX+3) 
11d4			      ld    (IX+4), L 
11d4			      ld    (IX+5), H 
11d4			 
11d4			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
11d4			      ld    H, (IX+1) 
11d4			      ld    (IX+2), L 
11d4			      ld    (IX+3), H 
11d4			 
11d4			      jr    malloc_find_space 
11d4			 
11d4			      ; split a bigger block into two - requested size and remaining size 
11d4			malloc_alloc_split: 
11d4			      ex    DE, HL                  ; Calculate address of new free block 
11d4			      dec   HL 
11d4			      dec   HL 
11d4			      dec   HL 
11d4			      add   HL, BC 
11d4			 
11d4			      ; Create a new block and point it at next_free 
11d4			      ld    E, (IX+0)               ; Load next_free ptr into DE 
11d4			      ld    D, (IX+1) 
11d4			 
11d4			      ld    (HL), E                 ; Store next_free ptr into new block 
11d4			      inc   HL 
11d4			      ld    (HL), D 
11d4			 
11d4			      pop   DE                      ; Store size of new block into new block 
11d4			      inc   HL 
11d4			      ld    (HL), E 
11d4			      inc   HL 
11d4			      ld    (HL), D 
11d4			 
11d4			      ; Update this_free ptr to point to new block 
11d4			      dec   HL 
11d4			      dec   HL 
11d4			      dec   HL 
11d4			 
11d4			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
11d4			      ld    D, (IX+3) 
11d4			 
11d4			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
11d4			      ld    (IX+3), H 
11d4			 
11d4			      ; Modify this_free block to be allocation 
11d4			      ex    DE, HL 
11d4			      xor   A                       ; Null the next block ptr of allocated block 
11d4			      ld    (HL), A 
11d4			      inc   HL 
11d4			      ld    (HL), A 
11d4			 
11d4			      inc   HL                      ; Store want size into allocated block 
11d4			      ld    (HL), C 
11d4			      inc   HL 
11d4			      ld    (HL), B 
11d4			      inc   HL 
11d4			      push  HL                      ; Address of allocation to return 
11d4			 
11d4			      jr    malloc_update_links 
11d4			 
11d4			malloc_alloc_fit: 
11d4			      pop   HL                      ; Dont need new block size, want is exact fit 
11d4			 
11d4			      ; Modify this_free block to be allocation 
11d4			      ex    DE, HL 
11d4			      dec   HL 
11d4			      dec   HL 
11d4			      dec   HL 
11d4			 
11d4			      xor   A                       ; Null the next block ptr of allocated block 
11d4			      ld    (HL), A 
11d4			      inc   HL 
11d4			      ld    (HL), A 
11d4			 
11d4			      inc   HL                      ; Store address of allocation to return 
11d4			      inc   HL 
11d4			      inc   HL 
11d4			      push  HL 
11d4			 
11d4			      ; Copy next_free ptr to this_free, remove allocated block from free list 
11d4			      ld    L, (IX+0)               ; next_free to HL 
11d4			      ld    H, (IX+1) 
11d4			 
11d4			      ld    (IX+2), L               ; HL to this_free 
11d4			      ld    (IX+3), H 
11d4			 
11d4			 
11d4			malloc_update_links: 
11d4			      ; Update prev_free ptr to point to this_free 
11d4			      ld    L, (IX+4)               ; prev_free ptr to HL 
11d4			      ld    H, (IX+5) 
11d4			 
11d4			      ld    E, (IX+2)               ; this_free ptr to DE 
11d4			      ld    D, (IX+3) 
11d4			 
11d4			      ld    (HL), E                 ; this_free ptr into prev_free 
11d4			      inc   HL 
11d4			      ld    (HL), D 
11d4			 
11d4			      ; Clear the Z flag to indicate successful allocation 
11d4			      ld    A, D 
11d4			      or    E 
11d4			 
11d4			      pop   DE                      ; Address of allocation 
11d4			 
11d4			malloc_no_space: 
11d4			      ld    HL, 6                   ; Clean up stack frame 
11d4			      add   HL, SP 
11d4			      ld    SP, HL 
11d4			 
11d4			      ex    DE, HL                  ; Alloc addr into HL for return 
11d4			 
11d4			malloc_early_exit: 
11d4			      pop   IX 
11d4			      pop   DE 
11d4			      pop   BC 
11d4			 
11d4			      ret 
11d4			 
11d4			 
11d4			;------------------------------------------------------------------------------ 
11d4			;     free                                                                    : 
11d4			;                                                                             : 
11d4			; Description                                                                 : 
11d4			;     Return the space pointed to by HL to the heap. HL must be an address as : 
11d4			;     returned by malloc, otherwise the behaviour is undefined.               : 
11d4			;                                                                             : 
11d4			;     Where possible, directly adjacent free blocks will be merged together   : 
11d4			;     into larger blocks to help ensure that the heap does not become         : 
11d4			;     excessively fragmented.                                                 : 
11d4			;                                                                             : 
11d4			;     free does not clear or set any other value into the freed space, and    : 
11d4			;     therefore its contents may be visible through subsequent malloc's. The  : 
11d4			;     caller should clear the freed space as required.                        : 
11d4			;                                                                             : 
11d4			;     This implementation of free uses the stack exclusively, and is          : 
11d4			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
11d4			;     advisable to disable interrupts before calling free, and recommended    : 
11d4			;     to avoid the use of free inside ISRs in general.                        : 
11d4			;                                                                             : 
11d4			;     NOTE: heap_init must be called before malloc and free can be used.      : 
11d4			;                                                                             : 
11d4			; Parameters                                                                  : 
11d4			;     HL  Pointer to address of first byte of allocation to be freed          : 
11d4			;                                                                             : 
11d4			; Returns                                                                     : 
11d4			;     Nothing                                                                 : 
11d4			;                                                                             : 
11d4			; Stack frame                                                                 : 
11d4			;       |             |                                                       : 
11d4			;       +-------------+                                                       : 
11d4			;       |     BC      |                                                       : 
11d4			;       +-------------+                                                       : 
11d4			;       |     DE      |                                                       : 
11d4			;       +-------------+                                                       : 
11d4			;       |     IX      |                                                       : 
11d4			;       +-------------+                                                       : 
11d4			;       |  prev_free  |                                                       : 
11d4			;   +2  +-------------+                                                       : 
11d4			;       |  next_free  |                                                       : 
11d4			;   +0  +-------------+                                                       : 
11d4			;       |             |                                                       : 
11d4			;                                                                             : 
11d4			;------------------------------------------------------------------------------ 
11d4			free: 
11d4			      push  BC 
11d4			      push  DE 
11d4			      push  IX 
11d4			 
11d4			      ld    A, H                    ; Exit if ptr is null 
11d4			      or    L 
11d4			      jp    Z, free_early_exit 
11d4			 
11d4			      ; Set up stack frame 
11d4			      ex    DE, HL 
11d4			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
11d4			      add   HL, SP 
11d4			      ld    SP, HL 
11d4			      ld    IX, 0                   ; Use IX as a frame pointer 
11d4			      add   IX, SP 
11d4			 
11d4			      ; The address in HL points to the start of the useable allocated space, 
11d4			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
11d4			      ; address of the block itself. 
11d4			      ex    DE, HL 
11d4			      ld    DE, -4 
11d4			      add   HL, DE 
11d4			 
11d4			      ; An allocated block must have a null next block pointer in it 
11d4			      ld    A, (HL) 
11d4			      inc   HL 
11d4			      or    (HL) 
11d4			      jp    NZ, free_done 
11d4			 
11d4			      dec   HL 
11d4			 
11d4			      ld    B, H                    ; Copy HL to BC 
11d4			      ld    C, L 
11d4			 
11d4			      ; Loop through the free list to find the first block with an address 
11d4			      ; higher than the block being freed 
11d4			      ld    HL, free_list 
11d4			 
11d4			free_find_higher_block: 
11d4			      ld    E, (HL)                 ; Load next ptr from free block 
11d4			      inc   HL 
11d4			      ld    D, (HL) 
11d4			      dec   HL 
11d4			 
11d4			      ld    (IX+0), E               ; Save ptr to next free block 
11d4			      ld    (IX+1), D 
11d4			      ld    (IX+2), L               ; Save ptr to prev free block 
11d4			      ld    (IX+3), H 
11d4			 
11d4			      ld    A, B                    ; Check if DE is greater than BC 
11d4			      cp    D                       ; Compare MSB first 
11d4			      jr    Z, $+4                  ; MSB the same, compare LSB 
11d4			      jr    NC, free_find_higher_block_skip 
11d4			      ld    A, C 
11d4			      cp    E                       ; Then compare LSB 
11d4			      jr    C, free_found_higher_block 
11d4			 
11d4			free_find_higher_block_skip: 
11d4			      ld    A, D                    ; Reached the end of the free list? 
11d4			      or    E 
11d4			      jp    Z, free_done 
11d4			 
11d4			      ex    DE, HL 
11d4			 
11d4			      jr    free_find_higher_block 
11d4			 
11d4			free_found_higher_block: 
11d4			      ; Insert freed block between prev and next free blocks 
11d4			      ld    (HL), C                 ; Point prev free block to freed block 
11d4			      inc   HL 
11d4			      ld    (HL), B 
11d4			 
11d4			      ld    H, B                    ; Point freed block at next free block 
11d4			      ld    L, C 
11d4			      ld    (HL), E 
11d4			      inc   HL 
11d4			      ld    (HL), D 
11d4			 
11d4			      ; Check if the freed block is adjacent to the next free block 
11d4			      inc   HL                      ; Load size of freed block into HL 
11d4			      ld    E, (HL) 
11d4			      inc   HL 
11d4			      ld    D, (HL) 
11d4			      ex    DE, HL 
11d4			 
11d4			      add   HL, BC                  ; Add addr of freed block and its size 
11d4			 
11d4			      ld    E, (IX+0)               ; Load addr of next free block into DE 
11d4			      ld    D, (IX+1) 
11d4			 
11d4			      or    A                       ; Clear the carry flag 
11d4			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
11d4			      jr    NZ, free_check_adjacent_to_prev 
11d4			 
11d4			      ; Freed block is adjacent to next, merge into one bigger block 
11d4			      ex    DE, HL                  ; Load next ptr from next block into DE 
11d4			      ld    E, (HL) 
11d4			      inc   HL 
11d4			      ld    D, (HL) 
11d4			      push  HL                      ; Save ptr to next block for later 
11d4			 
11d4			      ld    H, B                    ; Store ptr from next block into freed block 
11d4			      ld    L, C 
11d4			      ld    (HL), E 
11d4			      inc   HL 
11d4			      ld    (HL), D 
11d4			 
11d4			      pop   HL                      ; Restore ptr to next block 
11d4			      inc   HL                      ; Load size of next block into DE 
11d4			      ld    E, (HL) 
11d4			      inc   HL 
11d4			      ld    D, (HL) 
11d4			      push  DE                      ; Save next block size for later 
11d4			 
11d4			      ld    H, B                    ; Load size of freed block into HL 
11d4			      ld    L, C 
11d4			      inc   HL 
11d4			      inc   HL 
11d4			      ld    E, (HL) 
11d4			      inc   HL 
11d4			      ld    D, (HL) 
11d4			      ex    DE, HL 
11d4			 
11d4			      pop   DE                      ; Restore size of next block 
11d4			      add   HL, DE                  ; Add sizes of both blocks 
11d4			      ex    DE, HL 
11d4			 
11d4			      ld    H, B                    ; Store new bigger size into freed block 
11d4			      ld    L, C 
11d4			      inc   HL 
11d4			      inc   HL 
11d4			      ld    (HL), E 
11d4			      inc   HL 
11d4			      ld    (HL), D 
11d4			 
11d4			free_check_adjacent_to_prev: 
11d4			      ; Check if the freed block is adjacent to the prev free block 
11d4			      ld    L, (IX+2)               ; Prev free block ptr into HL 
11d4			      ld    H, (IX+3) 
11d4			 
11d4			      inc   HL                      ; Size of prev free block into DE 
11d4			      inc   HL 
11d4			      ld    E, (HL) 
11d4			      inc   HL 
11d4			      ld    D, (HL) 
11d4			      dec   HL 
11d4			      dec   HL 
11d4			      dec   HL 
11d4			 
11d4			      add   HL, DE                  ; Add prev block addr and size 
11d4			 
11d4			      or    A                       ; Clear the carry flag 
11d4			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
11d4			      jr    NZ, free_done 
11d4			 
11d4			      ; Freed block is adjacent to prev, merge into one bigger block 
11d4			      ld    H, B                    ; Load next ptr from freed block into DE 
11d4			      ld    L, C 
11d4			      ld    E, (HL) 
11d4			      inc   HL 
11d4			      ld    D, (HL) 
11d4			      push  HL                      ; Save freed block ptr for later 
11d4			 
11d4			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
11d4			      ld    H, (IX+3) 
11d4			      ld    (HL), E 
11d4			      inc   HL 
11d4			      ld    (HL), D 
11d4			 
11d4			      pop   HL                      ; Restore freed block ptr 
11d4			      inc   HL                      ; Load size of freed block into DE 
11d4			      ld    E, (HL) 
11d4			      inc   HL 
11d4			      ld    D, (HL) 
11d4			      push  DE                      ; Save freed block size for later 
11d4			 
11d4			      ld    L, (IX+2)               ; Load size of prev block into DE 
11d4			      ld    H, (IX+3) 
11d4			      inc   HL 
11d4			      inc   HL 
11d4			      ld    E, (HL) 
11d4			      inc   HL 
11d4			      ld    D, (HL) 
11d4			 
11d4			      pop   HL                      ; Add sizes of both blocks 
11d4			      add   HL, DE 
11d4			      ex    DE, HL 
11d4			 
11d4			      ld    L, (IX+2)               ; Store new bigger size into prev block 
11d4			      ld    H, (IX+3) 
11d4			      inc   HL 
11d4			      inc   HL 
11d4			      ld    (HL), E 
11d4			      inc   HL 
11d4			      ld    (HL), D 
11d4			 
11d4			free_done: 
11d4			      ld    HL, 4                   ; Clean up stack frame 
11d4			      add   HL, SP 
11d4			      ld    SP, HL 
11d4			 
11d4			free_early_exit: 
11d4			      pop   IX 
11d4			      pop   DE 
11d4			      pop   BC 
11d4			 
11d4			      ret 
11d4			 
11d4			 
11d4			;      .org 0x8000 
11d4			; 
11d4			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
11d4			 ;                 .dw   0 
11d4			 
11d4			endif 
11d4			 
11d4			 
11d4			if MALLOC_4 
11d4			 
11d4			; My memory allocation code. Very very simple.... 
11d4			; allocate space under 250 chars 
11d4			 
11d4			heap_init: 
11d4				; init start of heap as zero 
11d4				;  
11d4			 
11d4				ld hl, heap_start 
11d4				ld a, 0 
11d4				ld (hl), a      ; empty block 
11d4				inc hl 
11d4				ld a, 0 
11d4				ld (hl), a      ; length of block 
11d4				; write end of list 
11d4				inc hl 
11d4				ld a,(hl) 
11d4				inc hl 
11d4				ld a,(hl) 
11d4				 
11d4			 
11d4				; init some malloc vars 
11d4			 
11d4				ld hl, 0 
11d4				ld (free_list), hl       ; store last malloc location 
11d4			 
11d4				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
11d4				ld a, 0 
11d4				ld (hl), a 
11d4			 
11d4			 
11d4				ld hl, heap_start 
11d4				;  
11d4				  
11d4				ret 
11d4			 
11d4			 
11d4			;    free block marker 
11d4			;    requested size  
11d4			;    pointer to next block 
11d4			;    .... 
11d4			;    next block marker 
11d4			 
11d4			 
11d4			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
11d4			; 
11d4			 
11d4			 
11d4			malloc:  
11d4				push de 
11d4				push bc 
11d4				push af 
11d4			 
11d4				; hl space required 
11d4				 
11d4				ld c, l    ; hold space   (TODO only a max of 255) 
11d4			 
11d4			;	inc c     ; TODO BUG need to fix memory leak on push str 
11d4			;	inc c 
11d4			;	inc c 
11d4			;	inc c 
11d4			;	inc c 
11d4			;	inc c 
11d4			;	inc c 
11d4			 
11d4			 
11d4			 
11d4				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
11d4			 
11d4				ld a, (free_list+3) 
11d4				cp 0 
11d4				jr z, .contheap 
11d4			 
11d4				ld hl, (free_list)     ; get last alloc 
11d4					if DEBUG_FORTH_MALLOC_INT 
11d4						DMARK "mrs" 
11d4						CALLMONITOR 
11d4					endif 
11d4				jr .startalloc 
11d4			 
11d4			.contheap: 
11d4				ld hl, heap_start 
11d4			 
11d4			.startalloc: 
11d4			 
11d4					if DEBUG_FORTH_MALLOC_INT 
11d4						DMARK "mym" 
11d4						CALLMONITOR 
11d4					endif 
11d4			.findblock: 
11d4					if DEBUG_FORTH_MALLOC_INT 
11d4						DMARK "mmf" 
11d4						CALLMONITOR 
11d4					endif 
11d4			 
11d4				ld a,(hl)  
11d4				; if byte is zero then clear to use 
11d4			 
11d4				cp 0 
11d4				jr z, .foundemptyblock 
11d4			 
11d4				; if byte is not clear 
11d4				;     then byte is offset to next block 
11d4			 
11d4				inc hl 
11d4				ld a, (hl) ; get size 
11d4			.nextblock:	inc hl 
11d4					ld e, (hl) 
11d4					inc hl 
11d4					ld d, (hl) 
11d4					ex de, hl 
11d4			;	inc hl  ; move past the store space 
11d4			;	inc hl  ; move past zero index  
11d4			 
11d4				; TODO detect no more space 
11d4			 
11d4				push hl 
11d4				ld de, heap_end 
11d4				call cmp16 
11d4				pop hl 
11d4				jr nc, .nospace 
11d4			 
11d4				jr .findblock 
11d4			 
11d4			.nospace: ld hl, 0 
11d4				jp .exit 
11d4			 
11d4			 
11d4			.foundemptyblock:	 
11d4					if DEBUG_FORTH_MALLOC_INT 
11d4						DMARK "mme" 
11d4						CALLMONITOR 
11d4					endif 
11d4			 
11d4			; TODO has block enough space if reusing??? 
11d4			 
11d4				;  
11d4			 
11d4			; see if this block has been previously used 
11d4				inc hl 
11d4				ld a, (hl) 
11d4				dec hl 
11d4				cp 0 
11d4				jr z, .newblock 
11d4			 
11d4					if DEBUG_FORTH_MALLOC_INT 
11d4						DMARK "meR" 
11d4						CALLMONITOR 
11d4					endif 
11d4			 
11d4			; no reusing previously allocated block 
11d4			 
11d4			; is it smaller than previously used? 
11d4				 
11d4				inc hl    ; move to size 
11d4				ld a, c 
11d4				sub (hl)        ; we want c < (hl) 
11d4				dec hl    ; move back to marker 
11d4			        jr z, .findblock 
11d4			 
11d4				; update with the new size which should be lower 
11d4			 
11d4			        ;inc  hl   ; negate next move. move back to size  
11d4			 
11d4			.newblock: 
11d4				; need to be at marker here 
11d4			 
11d4					if DEBUG_FORTH_MALLOC_INT 
11d4						DMARK "meN" 
11d4						CALLMONITOR 
11d4					endif 
11d4			 
11d4			 
11d4				ld a, c 
11d4			 
11d4				ld (free_list+3), a	 ; flag resume from last malloc  
11d4				ld (free_list), hl    ; save out last location 
11d4			 
11d4			 
11d4				;inc a     ; space for length byte 
11d4				ld (hl), a     ; save block in use marker 
11d4			 
11d4				inc hl   ; move to space marker 
11d4				ld (hl), a    ; save new space 
11d4			 
11d4				inc hl   ; move to start of allocated area 
11d4				 
11d4			;	push hl     ; save where we are - 1  
11d4			 
11d4			;	inc hl  ; move past zero index  
11d4				; skip space to set down new marker 
11d4			 
11d4				; provide some extra space for now 
11d4			 
11d4				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
11d4				inc a 
11d4				inc a 
11d4			 
11d4				push hl   ; save where we are in the node block 
11d4			 
11d4				call addatohl 
11d4			 
11d4				; write linked list point 
11d4			 
11d4				pop de     ; get our node position 
11d4				ex de, hl 
11d4			 
11d4				ld (hl), e 
11d4				inc hl 
11d4				ld (hl), d 
11d4			 
11d4				inc hl 
11d4			 
11d4				; now at start of allocated data so save pointer 
11d4			 
11d4				push hl 
11d4			 
11d4				; jump to position of next node and setup empty header in DE 
11d4			 
11d4				ex de, hl 
11d4			 
11d4			;	inc hl ; move past end of block 
11d4			 
11d4				ld a, 0 
11d4				ld (hl), a   ; empty marker 
11d4				inc hl 
11d4				ld (hl), a   ; size 
11d4				inc hl  
11d4				ld (hl), a   ; ptr 
11d4				inc hl 
11d4				ld (hl), a   ; ptr 
11d4			 
11d4			 
11d4				pop hl 
11d4			 
11d4					if DEBUG_FORTH_MALLOC_INT 
11d4						DMARK "mmr" 
11d4						CALLMONITOR 
11d4					endif 
11d4			 
11d4			.exit: 
11d4				pop af 
11d4				pop bc 
11d4				pop de  
11d4				ret 
11d4			 
11d4			 
11d4			 
11d4			 
11d4			free:  
11d4				push hl 
11d4				push af 
11d4				; get address in hl 
11d4			 
11d4					if DEBUG_FORTH_MALLOC_INT 
11d4						DMARK "fre" 
11d4						CALLMONITOR 
11d4					endif 
11d4				; data is at hl - move to block count 
11d4				dec hl 
11d4				dec hl    ; get past pointer 
11d4				dec hl 
11d4			 
11d4				ld a, (hl)    ; need this for a validation check 
11d4			 
11d4				dec hl    ; move to block marker 
11d4			 
11d4				; now check that the block count and block marker are the same  
11d4			        ; this checks that we are on a malloc node and not random memory 
11d4			        ; OK a faint chance this could be a problem but rare - famous last words! 
11d4			 
11d4				ld c, a 
11d4				ld a, (hl)    
11d4			 
11d4				cp c 
11d4				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
11d4			 
11d4				; yes good chance we are on a malloc node 
11d4			 
11d4				ld a, 0      
11d4				ld (hl), a   ; mark as free 
11d4			 
11d4				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
11d4			 
11d4			.freeignore:  
11d4			 
11d4				pop af 
11d4				pop hl 
11d4			 
11d4				ret 
11d4			 
11d4			 
11d4			 
11d4			endif 
11d4			 
11d4			; eof 
# End of file firmware_memory.asm
11d4			  
11d4			; device C  
11d4			if SOUND_ENABLE  
11d4				include "firmware_sound.asm"  
11d4			endif  
11d4			  
11d4			include "firmware_diags.asm"  
11d4			; Hardware diags menu 
11d4			 
11d4			 
11d4			config: 
11d4			 
11d4 3e 00			ld a, 0 
11d6 21 f5 11			ld hl, .configmn 
11d9 cd 78 09			call menu 
11dc			 
11dc fe 00			cp 0 
11de c8				ret z 
11df			 
11df fe 01			cp 1 
11e1 cc 7c 12			call z, .savetostore 
11e4			 
11e4 fe 03			cp 3 
11e6 cc 7b 12			call z, .selbank 
11e9 fe 05			cp 5 
11eb cc 7d 12			call z, .debug_tog 
11ee fe 06			cp 6 
11f0 cc a3 12			call z, hardware_diags 
11f3			 
11f3 18 df			jr config 
11f5			 
11f5			.configmn: 
11f5 03 12			dw .c3 
11f7 1f 12			dw .c2 
11f9 34 12			dw .c2b 
11fb 48 12			dw .c4 
11fd 51 12			dw .m4 
11ff 6c 12			dw .c1 
1201 00 00			dw 0 
1203				 
1203			 
1203 .. 00		.c3: db "Add User Dictionary To File",0 
121f .. 00		.c2: db "Select Autoload File",0 
1234 .. 00		.c2b: db "Select Storage Bank",0 
1248 .. 00		.c4: db "Settings",0 
1251 .. 00		.m4:   db "Debug & Breakpoints On/Off",0 
126c .. 00		.c1: db "Hardware Diags",0 
127b			 
127b			; Select storage bank 
127b			 
127b			.selbank: 
127b			 
127b				if STORAGE_SE 
127b				endif 
127b				 
127b c9				ret 
127c			 
127c			if STORAGE_SE 
127c			 
127c			.config_ldir:   
127c				; Load storage bank labels into menu array 
127c			 
127c				 
127c			 
127c			 
127c				ret 
127c			 
127c			 
127c			endif 
127c			 
127c			 
127c			; Save user words to storage 
127c			 
127c			.savetostore: 
127c			 
127c				if STORAGE_SE 
127c			 
127c					call config_dir 
127c				        ld hl, scratch 
127c					ld a, 0 
127c					call menu 
127c					 
127c					ld hl, scratch 
127c					call config_fdir 
127c			 
127c			 
127c				endif 
127c			 
127c c9				ret 
127d			 
127d			 
127d			 
127d			if STORAGE_SE 
127d			 
127d			config_fdir: 
127d				; using the scratch dir go through and release the memory allocated for each string 
127d				 
127d				ld hl, scratch 
127d			.cfdir:	ld e,(hl) 
127d				inc hl 
127d				ld d,(hl) 
127d				inc hl 
127d			 
127d				ex de, hl 
127d				call ishlzero 
127d				ret z     ; return on null pointer 
127d				call free 
127d				ex de, hl 
127d				jr .cfdir 
127d			 
127d			 
127d				ret 
127d			 
127d			 
127d			config_dir: 
127d			 
127d				; for the config menus that need to build a directory of storage call this routine 
127d				; it will construct a menu in scratch to pass to menu 
127d			 
127d				; open storage device 
127d			 
127d				; execute DIR to build a list of files and their ids into scratch in menu format 
127d				; once the menu has finished then will need to call config_fdir to release the strings 
127d				 
127d				; c = number items 
127d			 
127d				 
127d				call storage_get_block_0 
127d			 
127d				ld hl, store_page     ; get current id count 
127d				ld b, (hl) 
127d				ld c, 0    ; count of files   
127d			 
127d			 
127d				ld hl, scratch 
127d				ld (store_tmp2), hl    ; location to poke strings 
127d			 
127d				; check for empty drive 
127d			 
127d				ld a, 0 
127d				cp b 
127d				jp z, .dirdone 
127d			 
127d				 
127d					if DEBUG_FORTH_WORDS 
127d						DMARK "Cdc" 
127d						CALLMONITOR 
127d					endif 
127d			 
127d			 
127d			.diritem:	 
127d				push bc 
127d				; for each of the current ids do a search for them and if found push to stack 
127d			 
127d					ld hl, STORE_BLOCK_PHY 
127d					ld d, 0		 ; look for extent 0 of block id as this contains file name 
127d					ld e,b 
127d			 
127d					call storage_findnextid 
127d			 
127d			 
127d					; if found hl will be non zero 
127d			 
127d					call ishlzero 
127d					jr z, .dirnotfound 
127d			 
127d					; increase count 
127d			 
127d					pop bc	 
127d					inc c 
127d					push bc 
127d					 
127d			 
127d					; get file header and push the file name 
127d			 
127d					ld de, store_page 
127d					call storage_read_block 
127d			 
127d					; push file id to stack 
127d				 
127d					ld a, (store_page) 
127d					ld h, 0 
127d					ld l, a 
127d			 
127d					;call forth_push_numhl 
127d					; TODO store id 
127d			 
127d					push hl 
127d			 
127d					; push extent count to stack  
127d				 
127d					ld hl, store_page+3 
127d			 
127d					; get file name length 
127d			 
127d					call strlenz   
127d			 
127d					inc hl   ; cover zero term 
127d					inc hl  ; stick the id at the end of the area 
127d			 
127d					push hl 
127d					pop bc    ; move length to bc 
127d			 
127d					call malloc 
127d			 
127d					; TODO save malloc area to scratch 
127d			 
127d					ex de, hl 
127d					ld hl, (store_tmp2) 
127d					ld (hl), e 
127d					inc hl 
127d					ld (hl), d 
127d					inc hl 
127d					ld (store_tmp2), hl 
127d			 
127d					 
127d			 
127d					;pop hl   ; get source 
127d			;		ex de, hl    ; swap aronund	 
127d			 
127d					ld hl, store_page+3 
127d					if DEBUG_FORTH_WORDS 
127d						DMARK "CFd" 
127d						CALLMONITOR 
127d					endif 
127d					ldir 
127d			 
127d					; de is past string, move back one and store id 
127d					 
127d					dec de 
127d			 
127d					; store file id 
127d			 
127d					pop hl 
127d					ex de,hl 
127d					ld (hl), e 
127d			 
127d					if DEBUG_FORTH_WORDS 
127d						DMARK "Cdi" 
127d						CALLMONITOR 
127d					endif 
127d					 
127d			.dirnotfound: 
127d					pop bc     
127d					djnz .diritem 
127d				 
127d			.dirdone:	 
127d			 
127d					ld a, 0 
127d					ld hl, (store_tmp2) 
127d					ld (hl), a 
127d					inc hl 
127d					ld (hl), a 
127d					inc hl 
127d					; push a count of the dir items found 
127d			 
127d			;		ld h, 0 
127d			;		ld l, c 
127d			 
127d				ret 
127d			 
127d			endif 
127d			 
127d			 
127d			; Settings 
127d			; Run  
127d			 
127d			 
127d			 
127d			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
127d			;;hd_menu2:   db "        2: Editor",0   
127d			;hd_menu2:   db "        2: Editor       6: Menu",0   
127d			;hd_menu3:   db "        3: Storage",0 
127d			;hd_menu4:   db "0=quit  4: Debug",0 
127d			;hd_don:     db "ON",0 
127d			;hd_doff:     db "OFF",0 
127d			; 
127d			; 
127d			; 
127d			;hardware_diags_old:       
127d			; 
127d			;.diagmenu: 
127d			;	call clear_display 
127d			;	ld a, display_row_1 
127d			;	ld de, hd_menu1 
127d			;	call str_at_display 
127d			; 
127d			;	ld a, display_row_2 
127d			;	ld de, hd_menu2 
127d			;	call str_at_display 
127d			; 
127d			;	ld a, display_row_3 
127d			;	ld de, hd_menu3 
127d			;	call str_at_display 
127d			; 
127d			;	ld a,  display_row_4 
127d			;	ld de, hd_menu4 
127d			;	call str_at_display 
127d			; 
127d			;	; display debug state 
127d			; 
127d			;	ld de, hd_don 
127d			;	ld a, (os_view_disable) 
127d			;	cp 0 
127d			;	jr z, .distog 
127d			;	ld de, hd_doff 
127d			;.distog: ld a, display_row_4+17 
127d			;	call str_at_display 
127d			; 
127d			;	call update_display 
127d			; 
127d			;	call cin_wait 
127d			; 
127d			; 
127d			; 
127d			;	cp '4' 
127d			;	jr nz, .diagn1 
127d			; 
127d			;	; debug toggle 
127d			; 
127d			;	ld a, (os_view_disable) 
127d			;	ld b, '*' 
127d			;	cp 0 
127d			;	jr z, .debtog 
127d			;	ld b, 0 
127d			;.debtog:	 
127d			;	ld a,b 
127d			;	ld (os_view_disable),a 
127d			; 
127d			;.diagn1: cp '0' 
127d			;	 ret z 
127d			; 
127d			;;	cp '1' 
127d			;;       jp z, matrix	 
127d			;;   TODO keyboard matrix test 
127d			; 
127d			;	cp '2' 
127d			;	jp z, .diagedit 
127d			; 
127d			;;	cp '6' 
127d			;;	jp z, .menutest 
127d			;;if ENABLE_BASIC 
127d			;;	cp '6' 
127d			;;	jp z, basic 
127d			;;endif 
127d			 ; 
127d			;	jp .diagmenu 
127d			; 
127d			; 
127d			;	ret 
127d			 
127d			 
127d			.debug_tog: 
127d 21 c4 12			ld hl, .menudebug 
1280				 
1280 3a 51 e3			ld a, (os_view_disable) 
1283 fe 2a			cp '*' 
1285 20 04			jr nz,.tdon  
1287 3e 01			ld a, 1 
1289 18 02			jr .tog1 
128b 3e 00		.tdon: ld a, 0 
128d			 
128d			.tog1: 
128d cd 78 09			call menu 
1290 fe 00			cp 0 
1292 c8				ret z 
1293 fe 01			cp 1    ; disable debug 
1295 28 04			jr z, .dtog0 
1297 3e 2a			ld a, '*' 
1299 18 02			jr .dtogset 
129b 3e 00		.dtog0: ld a, 0 
129d 32 51 e3		.dtogset:  ld (os_view_disable), a 
12a0 c3 7d 12			jp .debug_tog 
12a3			 
12a3			 
12a3			hardware_diags:       
12a3			 
12a3			.diagm: 
12a3 21 b6 12			ld hl, .menuitems 
12a6 3e 00			ld a, 0 
12a8 cd 78 09			call menu 
12ab			 
12ab fe 00		         cp 0 
12ad c8				 ret z 
12ae			 
12ae fe 02			cp 2 
12b0 ca 0f 13			jp z, .diagedit 
12b3			 
12b3			;	cp '6' 
12b3			;	jp z, .menutest 
12b3			;if ENABLE_BASIC 
12b3			;	cp '6' 
12b3			;	jp z, basic 
12b3			;endif 
12b3			  
12b3 c3 a3 12			jp .diagm 
12b6			 
12b6				 
12b6 ca 12		.menuitems:   	dw .m1 
12b8 d5 12				dw .m2 
12ba dc 12				dw .m3 
12bc e4 12				dw .m5 
12be ea 12				dw .m5a 
12c0 f3 12				dw .m5b 
12c2 00 00				dw 0 
12c4			 
12c4			.menudebug: 
12c4 fc 12				dw .m6 
12c6 05 13				dw .m7 
12c8 00 00				dw 0 
12ca			 
12ca .. 00		.m1:   db "Key Matrix",0 
12d5 .. 00		.m2:   db "Editor",0 
12dc .. 00		.m3:   db "Storage",0 
12e4 .. 00		.m5:   db "Sound",0 
12ea .. 00		.m5a:  db "RAM Test",0 
12f3 .. 00		.m5b:  db "LCD Test",0 
12fc			 
12fc .. 00		.m6:   db "Debug ON",0 
1305 .. 00		.m7:   db "Debug OFF",0 
130f			 
130f			; debug editor 
130f			 
130f			.diagedit: 
130f			 
130f 21 60 e3			ld hl, scratch 
1312			;	ld bc, 250 
1312			;	ldir 
1312				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1312 3e 00			ld a, 0 
1314 77				ld (hl), a 
1315 23				inc hl 
1316 77				ld (hl), a 
1317 23				inc hl 
1318 77				ld (hl), a 
1319			 
1319 cd 47 09		        call clear_display 
131c cd 6a 09			call update_display 
131f 3e 01			ld a, 1 
1321 32 80 ee			ld (hardware_diag), a 
1324			.diloop: 
1324 3e 00			ld a, display_row_1 
1326 0e 00			ld c, 0 
1328 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
132a 1e 28			ld e, 40 
132c			 
132c 21 60 e3			ld hl, scratch	 
132f cd a1 0b			call input_str 
1332			 
1332 3e 28			ld a, display_row_2 
1334 11 60 e3			ld de, scratch 
1337 cd 5a 09			call str_at_display 
133a cd 6a 09			call update_display 
133d			 
133d c3 24 13			jp .diloop 
1340			 
1340			 
1340			; pass word in hl 
1340			; a has display location 
1340			display_word_at: 
1340 f5				push af 
1341 e5				push hl 
1342 7c				ld a,h 
1343 21 65 e6			ld hl, os_word_scratch 
1346 cd 75 0e			call hexout 
1349 e1				pop hl 
134a 7d				ld a,l 
134b 21 67 e6			ld hl, os_word_scratch+2 
134e cd 75 0e			call hexout 
1351 21 69 e6			ld hl, os_word_scratch+4 
1354 3e 00			ld a,0 
1356 77				ld (hl),a 
1357 11 65 e6			ld de,os_word_scratch 
135a f1				pop af 
135b cd 5a 09				call str_at_display 
135e c9				ret 
135f			 
135f			display_ptr_state: 
135f			 
135f				; to restore afterwards 
135f			 
135f d5				push de 
1360 c5				push bc 
1361 e5				push hl 
1362 f5				push af 
1363			 
1363				; for use in here 
1363			 
1363			;	push bc 
1363			;	push de 
1363			;	push hl 
1363			;	push af 
1363			 
1363 cd 47 09			call clear_display 
1366			 
1366 11 39 15			ld de, .ptrstate 
1369 3e 00			ld a, display_row_1 
136b cd 5a 09			call str_at_display 
136e			 
136e				; display debug step 
136e			 
136e			 
136e 11 7a ee			ld de, debug_mark 
1371 3e 26			ld a, display_row_1+display_cols-2 
1373 cd 5a 09			call str_at_display 
1376			 
1376				; display a 
1376 11 43 15			ld de, .ptrcliptr 
1379 3e 28			ld a, display_row_2 
137b cd 5a 09			call str_at_display 
137e			 
137e f1				pop af 
137f 2a 2b eb			ld hl,(cli_ptr) 
1382 3e 30			ld a, display_row_2+8 
1384 cd 40 13			call display_word_at 
1387			 
1387			 
1387				; display hl 
1387			 
1387			 
1387 11 4b 15			ld de, .ptrclioptr 
138a 3e 32			ld a, display_row_2+10 
138c cd 5a 09			call str_at_display 
138f			; 
138f			;	pop hl 
138f 3e 35			ld a, display_row_2+13 
1391 2a 29 eb			ld hl,(cli_origptr) 
1394 cd 40 13			call display_word_at 
1397			; 
1397			;	 
1397			;	; display de 
1397			 
1397			;	ld de, .regstatede 
1397			;	ld a, display_row_3 
1397			;	call str_at_display 
1397			 
1397			;	pop de 
1397			;	ld h,d 
1397			;	ld l, e 
1397			;	ld a, display_row_3+3 
1397			;	call display_word_at 
1397			 
1397			 
1397				; display bc 
1397			 
1397			;	ld de, .regstatebc 
1397			;	ld a, display_row_3+10 
1397			;	call str_at_display 
1397			 
1397			;	pop bc 
1397			;	ld h,b 
1397			;	ld l, c 
1397			;	ld a, display_row_3+13 
1397			;	call display_word_at 
1397			 
1397			 
1397				; display dsp 
1397			 
1397			;	ld de, .regstatedsp 
1397			;	ld a, display_row_4 
1397			;	call str_at_display 
1397			 
1397				 
1397			;	ld hl,(cli_data_sp) 
1397			;	ld a, display_row_4+4 
1397			;	call display_word_at 
1397			 
1397				; display rsp 
1397			 
1397 11 7a 15			ld de, .regstatersp 
139a 3e 82			ld a, display_row_4+10 
139c cd 5a 09			call str_at_display 
139f			 
139f				 
139f 2a 11 eb			ld hl,(cli_ret_sp) 
13a2 3e 86			ld a, display_row_4+14 
13a4 cd 40 13			call display_word_at 
13a7			 
13a7 cd 6a 09			call update_display 
13aa			 
13aa cd ea 08			call delay1s 
13ad cd ea 08			call delay1s 
13b0 cd ea 08			call delay1s 
13b3			 
13b3			 
13b3 cd c0 18			call next_page_prompt 
13b6			 
13b6				; restore  
13b6			 
13b6 f1				pop af 
13b7 e1				pop hl 
13b8 c1				pop bc 
13b9 d1				pop de 
13ba c9				ret 
13bb			 
13bb			break_point_state: 
13bb f5				push af 
13bc			 
13bc				; see if disabled 
13bc			 
13bc 3a 51 e3			ld a, (os_view_disable) 
13bf fe 2a			cp '*' 
13c1 20 02			jr nz, .bpsgo 
13c3 f1				pop af 
13c4 c9				ret 
13c5			 
13c5			.bpsgo: 
13c5 f1				pop af 
13c6 f5				push af 
13c7 22 4d e3			ld (os_view_hl), hl 
13ca ed 53 4b e3		ld (os_view_de), de 
13ce ed 43 49 e3		ld (os_view_bc), bc 
13d2 e5				push hl 
13d3 6f				ld l, a 
13d4 26 00			ld h, 0 
13d6 22 4f e3			ld (os_view_af),hl 
13d9			 
13d9 21 c0 ed				ld hl, display_fb0 
13dc 22 db eb				ld (display_fb_active), hl 
13df e1				pop hl	 
13e0			 
13e0 3e 31			ld a, '1' 
13e2 fe 2a		.bps1:  cp '*' 
13e4 20 03			jr nz, .bps1b 
13e6 32 51 e3			ld (os_view_disable),a 
13e9 fe 31		.bps1b:  cp '1' 
13eb 20 14			jr nz, .bps2 
13ed			 
13ed				; display reg 
13ed			 
13ed				 
13ed			 
13ed 3a 4f e3			ld a, (os_view_af) 
13f0 2a 4d e3			ld hl, (os_view_hl) 
13f3 ed 5b 4b e3		ld de, (os_view_de) 
13f7 ed 4b 49 e3		ld bc, (os_view_bc) 
13fb cd 95 14			call display_reg_state 
13fe c3 81 14			jp .bpschk 
1401			 
1401 fe 32		.bps2:  cp '2' 
1403 20 08			jr nz, .bps3 
1405				 
1405				; display hl 
1405 2a 4d e3			ld hl, (os_view_hl) 
1408 cd 7f 15			call display_dump_at_hl 
140b			 
140b 18 74			jr .bpschk 
140d			 
140d fe 33		.bps3:  cp '3' 
140f 20 08			jr nz, .bps4 
1411			 
1411			        ; display de 
1411 2a 4b e3			ld hl, (os_view_de) 
1414 cd 7f 15			call display_dump_at_hl 
1417			 
1417 18 68			jr .bpschk 
1419 fe 34		.bps4:  cp '4' 
141b 20 08			jr nz, .bps5 
141d			 
141d			        ; display bc 
141d 2a 49 e3			ld hl, (os_view_bc) 
1420 cd 7f 15			call display_dump_at_hl 
1423			 
1423 18 5c			jr .bpschk 
1425 fe 35		.bps5:  cp '5' 
1427 20 08		        jr nz, .bps7 
1429			 
1429				; display cur ptr 
1429 2a 2b eb			ld hl, (cli_ptr) 
142c cd 7f 15			call display_dump_at_hl 
142f			 
142f 18 50			jr .bpschk 
1431 fe 36		.bps7:  cp '6' 
1433 20 08			jr nz, .bps8b 
1435				 
1435				; display cur orig ptr 
1435 2a 29 eb			ld hl, (cli_origptr) 
1438 cd 7f 15			call display_dump_at_hl 
143b 18 44			jr .bpschk 
143d fe 37		.bps8b:  cp '7' 
143f 20 08			jr nz, .bps9 
1441				 
1441				; display dsp 
1441 2a 0d eb			ld hl, (cli_data_sp) 
1444 cd 7f 15			call display_dump_at_hl 
1447			 
1447 18 38			jr .bpschk 
1449 fe 39		.bps9:  cp '9' 
144b 20 05			jr nz, .bps8c 
144d				 
144d				; display SP 
144d			;	ld hl, sp 
144d cd 7f 15			call display_dump_at_hl 
1450			 
1450 18 2f			jr .bpschk 
1452 fe 38		.bps8c:  cp '8' 
1454 20 08			jr nz, .bps8d 
1456				 
1456				; display rsp 
1456 2a 11 eb			ld hl, (cli_ret_sp) 
1459 cd 7f 15			call display_dump_at_hl 
145c			 
145c 18 23			jr .bpschk 
145e fe 23		.bps8d:  cp '#'     ; access monitor sub system 
1460 20 05			jr nz, .bps8 
1462 cd b6 16			call monitor 
1465			 
1465 18 1a			jr .bpschk 
1467 fe 30		.bps8:  cp '0' 
1469 20 16			jr nz, .bpschk 
146b			 
146b 21 1f ed				ld hl, display_fb1 
146e 22 db eb				ld (display_fb_active), hl 
1471 cd 6a 09				call update_display 
1474			 
1474				;ld a, (os_view_af) 
1474 2a 4d e3			ld hl, (os_view_hl) 
1477 ed 5b 4b e3		ld de, (os_view_de) 
147b ed 4b 49 e3		ld bc, (os_view_bc) 
147f f1				pop af 
1480 c9				ret 
1481			 
1481			.bpschk:   
1481 cd ea 08			call delay1s 
1484 3e 9f		ld a,display_row_4 + display_cols - 1 
1486 11 be 18		        ld de, endprg 
1489 cd 5a 09			call str_at_display 
148c cd 6a 09			call update_display 
148f cd 72 59			call cin_wait 
1492			 
1492 c3 e2 13			jp .bps1 
1495			 
1495			 
1495			display_reg_state: 
1495			 
1495				; to restore afterwards 
1495			 
1495 d5				push de 
1496 c5				push bc 
1497 e5				push hl 
1498 f5				push af 
1499			 
1499				; for use in here 
1499			 
1499 c5				push bc 
149a d5				push de 
149b e5				push hl 
149c f5				push af 
149d			 
149d cd 47 09			call clear_display 
14a0			 
14a0 11 55 15			ld de, .regstate 
14a3 3e 00			ld a, display_row_1 
14a5 cd 5a 09			call str_at_display 
14a8			 
14a8				; display debug step 
14a8			 
14a8			 
14a8 11 7a ee			ld de, debug_mark 
14ab 3e 25			ld a, display_row_1+display_cols-3 
14ad cd 5a 09			call str_at_display 
14b0			 
14b0				; display a 
14b0 11 71 15			ld de, .regstatea 
14b3 3e 28			ld a, display_row_2 
14b5 cd 5a 09			call str_at_display 
14b8			 
14b8 e1				pop hl 
14b9			;	ld h,0 
14b9			;	ld l, a 
14b9 3e 2b			ld a, display_row_2+3 
14bb cd 40 13			call display_word_at 
14be			 
14be			 
14be				; display hl 
14be			 
14be			 
14be 11 65 15			ld de, .regstatehl 
14c1 3e 32			ld a, display_row_2+10 
14c3 cd 5a 09			call str_at_display 
14c6			 
14c6 e1				pop hl 
14c7 3e 35			ld a, display_row_2+13 
14c9 cd 40 13			call display_word_at 
14cc			 
14cc				 
14cc				; display de 
14cc			 
14cc 11 69 15			ld de, .regstatede 
14cf 3e 50			ld a, display_row_3 
14d1 cd 5a 09			call str_at_display 
14d4			 
14d4 e1				pop hl 
14d5			;	ld h,d 
14d5			;	ld l, e 
14d5 3e 53			ld a, display_row_3+3 
14d7 cd 40 13			call display_word_at 
14da			 
14da			 
14da				; display bc 
14da			 
14da 11 6d 15			ld de, .regstatebc 
14dd 3e 5a			ld a, display_row_3+10 
14df cd 5a 09			call str_at_display 
14e2			 
14e2 e1				pop hl 
14e3			;	ld h,b 
14e3			;	ld l, c 
14e3 3e 5d			ld a, display_row_3+13 
14e5 cd 40 13			call display_word_at 
14e8			 
14e8			 
14e8				; display dsp 
14e8			 
14e8 11 75 15			ld de, .regstatedsp 
14eb 3e 78			ld a, display_row_4 
14ed cd 5a 09			call str_at_display 
14f0			 
14f0				 
14f0 2a 0d eb			ld hl,(cli_data_sp) 
14f3 3e 7c			ld a, display_row_4+4 
14f5 cd 40 13			call display_word_at 
14f8			 
14f8				; display rsp 
14f8			 
14f8 11 7a 15			ld de, .regstatersp 
14fb 3e 82			ld a, display_row_4+10 
14fd cd 5a 09			call str_at_display 
1500			 
1500				 
1500 2a 11 eb			ld hl,(cli_ret_sp) 
1503 3e 86			ld a, display_row_4+14 
1505 cd 40 13			call display_word_at 
1508			 
1508 cd 6a 09			call update_display 
150b			 
150b			;	call delay1s 
150b			;	call delay1s 
150b			;	call delay1s 
150b			 
150b			 
150b			;	call next_page_prompt 
150b			 
150b				; restore  
150b			 
150b f1				pop af 
150c e1				pop hl 
150d c1				pop bc 
150e d1				pop de 
150f c9				ret 
1510			 
1510 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1524 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1539 .. 00		.ptrstate:	db "Ptr State",0 
1543 .. 00		.ptrcliptr:     db "cli_ptr",0 
154b .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1555 .. 00		.regstate:	db "Reg State (1/0)",0 
1565 .. 00		.regstatehl:	db "HL:",0 
1569 .. 00		.regstatede:	db "DE:",0 
156d .. 00		.regstatebc:	db "BC:",0 
1571 .. 00		.regstatea:	db "A :",0 
1575 .. 00		.regstatedsp:	db "DSP:",0 
157a .. 00		.regstatersp:	db "RSP:",0 
157f			 
157f			display_dump_at_hl: 
157f e5				push hl 
1580 d5				push de 
1581 c5				push bc 
1582 f5				push af 
1583			 
1583 22 83 e6			ld (os_cur_ptr),hl	 
1586 cd 47 09			call clear_display 
1589 cd c8 17			call dumpcont 
158c			;	call delay1s 
158c			;	call next_page_prompt 
158c			 
158c			 
158c f1				pop af 
158d c1				pop bc 
158e d1				pop de 
158f e1				pop hl 
1590 c9				ret 
1591			 
1591			;if ENABLE_BASIC 
1591			;	include "nascombasic.asm" 
1591			;	basic: 
1591			;	include "forth/FORTH.ASM" 
1591			;endif 
1591			 
1591			; eof 
1591			 
1591			 
# End of file firmware_diags.asm
1591			  
1591			  
1591			  
1591			  
1591			; eof  
1591			  
# End of file firmware.asm
1591			 
1591			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1591			;if BASE_KEV  
1591			;baseram: equ 08000h 
1591			;endif 
1591			 
1591			;if BASE_SC114 
1591			;baseram:     equ    endofcode 
1591			;endif 
1591			 
1591			 
1591			; start system 
1591			 
1591			coldstart: 
1591				; set sp 
1591				; di/ei 
1591			 
1591 f3				di 
1592 31 00 f0			ld sp, tos 
1595			;	ei 
1595			 
1595			 
1595				; disable breakpoint by default 
1595			 
1595 3e 2a			ld a,'*' 
1597 32 51 e3			ld (os_view_disable),a 
159a			 
159a				; init hardware 
159a			 
159a				; init keyboard and screen hardware 
159a			 
159a cd 03 01			call hardware_init 
159d			 
159d			 
159d				; detect if any keys are held down to enable breakpoints at start up 
159d			 
159d cd 7a 59			call cin  
15a0 fe 00			cp 0 
15a2 28 03			jr z, .nokeys 
15a4			 
15a4				;call hardware_diags 
15a4 cd d4 11			call config 
15a7			 
15a7			;	ld de, .bpen 
15a7			;	ld a, display_row_4 
15a7			;	call str_at_display 
15a7			;	call update_display 
15a7			; 
15a7			;	ld a,0 
15a7			;	ld (os_view_disable),a 
15a7			; 
15a7			;.bpwait: 
15a7			;	call cin 
15a7			;	cp 0 
15a7			;	jr z, .bpwait 
15a7			;	jr .nokeys 
15a7			; 
15a7			; 
15a7			;.bpen:  db "Break points enabled!",0 
15a7			 
15a7			 
15a7			 
15a7			 
15a7			 
15a7			 
15a7			.nokeys: 
15a7			 
15a7			 
15a7				 
15a7			 
15a7			;jp  testkey 
15a7			 
15a7			;call storage_get_block_0 
15a7			; 
15a7			;ld hl, 0 
15a7			;ld de, store_page 
15a7			;call storage_read_block 
15a7			 
15a7				 
15a7			;ld hl, 10 
15a7			;ld de, store_page 
15a7			;call storage_read_block 
15a7			 
15a7			 
15a7			 
15a7			 
15a7			 
15a7			;stop:	nop 
15a7			;	jp stop 
15a7			 
15a7			 
15a7			 
15a7			main: 
15a7 cd 47 09			call clear_display 
15aa cd 6a 09			call update_display 
15ad			 
15ad			 
15ad			 
15ad			;	call testlcd 
15ad			 
15ad			 
15ad			 
15ad cd 86 1c			call forth_init 
15b0			 
15b0			 
15b0			warmstart: 
15b0 cd 5c 1c			call forth_warmstart 
15b3			 
15b3				; run startup word load 
15b3			        ; TODO prevent this running at warmstart after crash  
15b3			 
15b3				if STARTUP_ENABLE 
15b3 cd c0 55				call forth_startup 
15b6				endif 
15b6			 
15b6				; show free memory after boot 
15b6 11 50 16			ld de, freeram 
15b9 3e 00			ld a, display_row_1 
15bb cd 5a 09			call str_at_display 
15be			 
15be			; Or use heap_size word???? 
15be 21 46 e3			ld hl, heap_end 
15c1 11 a2 59			ld de, heap_start 
15c4 ed 52			sbc hl, de 
15c6 e5				push hl 
15c7 7c				ld a,h	         	 
15c8 21 65 e6			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
15cb cd 75 0e			call hexout 
15ce e1			   	pop hl 
15cf			 
15cf 7d				ld a,l 
15d0 21 67 e6			ld hl, os_word_scratch+2 
15d3 cd 75 0e			call hexout 
15d6 21 69 e6			ld hl, os_word_scratch+4 
15d9 3e 00			ld a, 0 
15db 77				ld (hl),a 
15dc 11 65 e6			ld de, os_word_scratch 
15df 3e 0d			ld a, display_row_1 + 13 
15e1 cd 5a 09			call str_at_display 
15e4 cd 6a 09			call update_display 
15e7			 
15e7			 
15e7				;call demo 
15e7			 
15e7			 
15e7				; init scratch input area for cli commands 
15e7			 
15e7 21 87 e6			ld hl, os_cli_cmd 
15ea 3e 00			ld a,0 
15ec 77				ld (hl),a 
15ed 23				inc hl 
15ee 77				ld (hl),a 
15ef			 
15ef 3e 00			ld a,0 
15f1 32 86 e7			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
15f4			 
15f4 32 83 e6			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
15f7 32 84 e6			ld (os_cur_ptr+1),a	 
15fa			 
15fa 32 65 e6			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
15fd 32 66 e6			ld (os_word_scratch+1),a	 
1600				 
1600			 
1600				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1600 21 87 e6			ld hl, os_cli_cmd 
1603			 
1603 3e 00			ld a, 0		 ; init cli input 
1605 77				ld (hl), a 
1606 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1608			cli: 
1608				; show cli prompt 
1608				;push af 
1608				;ld a, 0 
1608				;ld de, prompt 
1608				;call str_at_display 
1608			 
1608				;call update_display 
1608				;pop af 
1608				;inc a 
1608				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1608 0e 00			ld c, 0 
160a 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
160c 1e 28			ld e, 40 
160e			 
160e 21 87 e6			ld hl, os_cli_cmd 
1611			 
1611				STACKFRAME OFF $fefe $9f9f 
1611				if DEBUG_STACK_IMB 
1611					if OFF 
1611						exx 
1611						ld de, $fefe 
1611						ld a, d 
1611						ld hl, curframe 
1611						call hexout 
1611						ld a, e 
1611						ld hl, curframe+2 
1611						call hexout 
1611						ld hl, $fefe 
1611						push hl 
1611						ld hl, $9f9f 
1611						push hl 
1611						exx 
1611					endif 
1611				endif 
1611			endm 
# End of macro STACKFRAME
1611			 
1611 cd a1 0b			call input_str 
1614			 
1614				STACKFRAMECHK OFF $fefe $9f9f 
1614				if DEBUG_STACK_IMB 
1614					if OFF 
1614						exx 
1614						ld hl, $9f9f 
1614						pop de   ; $9f9f 
1614						call cmp16 
1614						jr nz, .spnosame 
1614						ld hl, $fefe 
1614						pop de   ; $fefe 
1614						call cmp16 
1614						jr z, .spfrsame 
1614						.spnosame: call showsperror 
1614						.spfrsame: nop 
1614						exx 
1614					endif 
1614				endif 
1614			endm 
# End of macro STACKFRAMECHK
1614			 
1614				; copy input to last command 
1614			 
1614 21 87 e6			ld hl, os_cli_cmd 
1617 11 86 e7			ld de, os_last_cmd 
161a 01 ff 00			ld bc, 255 
161d ed b0			ldir 
161f			 
161f				; wipe current buffer 
161f			 
161f			;	ld a, 0 
161f			;	ld hl, os_cli_cmd 
161f			;	ld de, os_cli_cmd+1 
161f			;	ld bc, 254 
161f			;	ldir 
161f				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
161f			;	call strcpy 
161f			;	ld a, 0 
161f			;	ld (hl), a 
161f			;	inc hl 
161f			;	ld (hl), a 
161f			;	inc hl 
161f			;	ld (hl), a 
161f			 
161f				; switch frame buffer to program  
161f			 
161f 21 1f ed				ld hl, display_fb1 
1622 22 db eb				ld (display_fb_active), hl 
1625			 
1625			;	nop 
1625				STACKFRAME ON $fbfe $8f9f 
1625				if DEBUG_STACK_IMB 
1625					if ON 
1625						exx 
1625						ld de, $fbfe 
1625						ld a, d 
1625						ld hl, curframe 
1625						call hexout 
1625						ld a, e 
1625						ld hl, curframe+2 
1625						call hexout 
1625						ld hl, $fbfe 
1625						push hl 
1625						ld hl, $8f9f 
1625						push hl 
1625						exx 
1625					endif 
1625				endif 
1625			endm 
# End of macro STACKFRAME
1625				; first time into the parser so pass over the current scratch pad 
1625 21 87 e6			ld hl,os_cli_cmd 
1628				; tokenise the entered statement(s) in HL 
1628 cd ff 1c			call forthparse 
162b			        ; exec forth statements in top of return stack 
162b cd 3f 1d			call forthexec 
162e				;call forthexec_cleanup 
162e			;	call parsenext 
162e			 
162e				STACKFRAMECHK ON $fbfe $8f9f 
162e				if DEBUG_STACK_IMB 
162e					if ON 
162e						exx 
162e						ld hl, $8f9f 
162e						pop de   ; $8f9f 
162e						call cmp16 
162e						jr nz, .spnosame 
162e						ld hl, $fbfe 
162e						pop de   ; $fbfe 
162e						call cmp16 
162e						jr z, .spfrsame 
162e						.spnosame: call showsperror 
162e						.spfrsame: nop 
162e						exx 
162e					endif 
162e				endif 
162e			endm 
# End of macro STACKFRAMECHK
162e				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
162e			 
162e 3e 78			ld a, display_row_4 
1630 11 62 16			ld de, endprog 
1633			 
1633 cd 6a 09			call update_display		 
1636			 
1636 cd c0 18			call next_page_prompt 
1639			 
1639				; switch frame buffer to cli 
1639			 
1639 21 c0 ed				ld hl, display_fb0 
163c 22 db eb				ld (display_fb_active), hl 
163f			 
163f			 
163f cd 47 09		        call clear_display 
1642 cd 6a 09			call update_display		 
1645			 
1645 21 87 e6			ld hl, os_cli_cmd 
1648			 
1648 3e 00			ld a, 0		 ; init cli input 
164a 77				ld (hl), a 
164b			 
164b				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
164b			 
164b				; now on last line 
164b			 
164b				; TODO scroll screen up 
164b			 
164b				; TODO instead just clear screen and place at top of screen 
164b			 
164b			;	ld a, 0 
164b			;	ld (f_cursor_ptr),a 
164b			 
164b				;call clear_display 
164b				;call update_display 
164b			 
164b				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
164b 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
164d c3 08 16			jp cli 
1650			 
1650 .. 00		freeram: db "Free bytes: $",0 
165e ..			asc: db "1A2F" 
1662 .. 00		endprog: db "End prog...",0 
166e			 
166e			testenter2:   
166e 21 92 e3			ld hl,scratch+50 
1671 22 83 e6			ld (os_cur_ptr),hl 
1674 c3 08 16			jp cli 
1677			 
1677			testenter:  
1677			 
1677 21 5e 16			ld hl,asc 
167a			;	ld a,(hl) 
167a			;	call nibble2val 
167a cd cb 0e			call get_byte 
167d			 
167d			 
167d			;	ld a,(hl) 
167d			;	call atohex 
167d			 
167d			;	call fourehexhl 
167d 32 92 e3			ld (scratch+50),a 
1680			 
1680			 
1680			 
1680 21 60 16			ld hl,asc+2 
1683			;	ld a, (hl) 
1683			;	call nibble2val 
1683 cd cb 0e			call get_byte 
1686			 
1686			;	call fourehexhl 
1686 32 94 e3			ld (scratch+52),a 
1689				 
1689 21 92 e3			ld hl,scratch+50 
168c 22 83 e6			ld (os_cur_ptr),hl 
168f c3 08 16			jp cli 
1692			 
1692			enter:	 
1692 3a 64 e3			ld a,(scratch+4) 
1695 fe 00			cp 0 
1697 28 0c			jr z, .entercont 
1699				; no, not a null term line so has an address to work out.... 
1699			 
1699 21 62 e3			ld hl,scratch+2 
169c cd 2b 0f			call get_word_hl 
169f			 
169f 22 83 e6			ld (os_cur_ptr),hl	 
16a2 c3 08 16			jp cli 
16a5			 
16a5			 
16a5			.entercont:  
16a5			 
16a5 21 62 e3			ld hl, scratch+2 
16a8 cd cb 0e			call get_byte 
16ab			 
16ab 2a 83 e6		   	ld hl,(os_cur_ptr) 
16ae 77					ld (hl),a 
16af 23					inc hl 
16b0 22 83 e6				ld (os_cur_ptr),hl 
16b3				 
16b3			; get byte  
16b3			 
16b3			 
16b3 c3 08 16			jp cli 
16b6			 
16b6			 
16b6			; basic monitor support 
16b6			 
16b6			monitor: 
16b6				;  
16b6 cd 47 09			call clear_display 
16b9 3e 00			ld a, 0 
16bb 11 03 17			ld de, .monprompt 
16be cd 5a 09			call str_at_display 
16c1 cd 6a 09			call update_display 
16c4			 
16c4				; get a monitor command 
16c4			 
16c4 0e 00			ld c, 0     ; entry at top left 
16c6 16 64			ld d, 100   ; max buffer size 
16c8 1e 0f			ld e, 15    ; input scroll area 
16ca 3e 00			ld a, 0     ; init string 
16cc 21 5e e5			ld hl, os_input 
16cf 77				ld (hl), a 
16d0 23				inc hl 
16d1 77				ld (hl), a 
16d2 21 5e e5			ld hl, os_input 
16d5 3e 01			ld a, 1     ; init string 
16d7 cd a1 0b			call input_str 
16da			 
16da cd 47 09		        call clear_display 
16dd cd 6a 09			call update_display		 
16e0			 
16e0 3a 5e e5			ld a, (os_input) 
16e3 cd c9 0f			call toUpper 
16e6 fe 48		        cp 'H' 
16e8 28 6f		        jr z, .monhelp 
16ea fe 44			cp 'D'		; dump 
16ec ca 7a 17			jp z, .mondump	 
16ef fe 43			cp 'C'		; dump 
16f1 ca 94 17			jp z, .moncdump	 
16f4 fe 4d			cp 'M'		; dump 
16f6 ca 05 17			jp z, .moneditstart 
16f9 fe 55			cp 'U'		; dump 
16fb 28 14			jr z, .monedit	 
16fd fe 51			cp 'Q'		; dump 
16ff c8				ret z	 
1700			 
1700			 
1700				; TODO "S" to access symbol by name and not need the address 
1700				; TODO "F" to find a string in memory 
1700			 
1700 c3 b6 16			jp monitor 
1703			 
1703 .. 00		.monprompt: db ">", 0 
1705			 
1705			.moneditstart: 
1705				; get starting address 
1705			 
1705 21 60 e5			ld hl,os_input+2 
1708 cd 2b 0f			call get_word_hl 
170b			 
170b 22 83 e6			ld (os_cur_ptr),hl	 
170e			 
170e c3 b6 16			jp monitor 
1711			 
1711			.monedit: 
1711				; get byte to load 
1711			 
1711 21 60 e5			ld hl,os_input+2 
1714 cd cb 0e			call get_byte 
1717			 
1717				; get address to update 
1717 2a 83 e6			ld hl, (os_cur_ptr) 
171a			 
171a				; update byte 
171a			 
171a 77				ld (hl), a 
171b			 
171b				; move to next address and save it 
171b			 
171b 23				inc hl 
171c 22 83 e6			ld (os_cur_ptr),hl	 
171f			 
171f c3 b6 16			jp monitor 
1722			 
1722			 
1722 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1736 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1752 .. 00		.monhelptext3:  db "Q-Quit",0 
1759			        
1759			.monhelp: 
1759 3e 00			ld a, display_row_1 
175b 11 22 17		        ld de, .monhelptext1 
175e			 
175e cd 5a 09			call str_at_display 
1761 3e 28			ld a, display_row_2 
1763 11 36 17		        ld de, .monhelptext2 
1766					 
1766 cd 5a 09			call str_at_display 
1769 3e 50			ld a, display_row_3 
176b 11 52 17		        ld de, .monhelptext3 
176e					 
176e cd 5a 09			call str_at_display 
1771 cd 6a 09			call update_display		 
1774			 
1774 cd c0 18			call next_page_prompt 
1777 c3 b6 16			jp monitor 
177a			 
177a			.mondump:    
177a 21 60 e5			ld hl,os_input+2 
177d cd 2b 0f			call get_word_hl 
1780			 
1780 22 83 e6			ld (os_cur_ptr),hl	 
1783 cd c8 17			call dumpcont 
1786 3e 78			ld a, display_row_4 
1788 11 62 16			ld de, endprog 
178b			 
178b cd 6a 09			call update_display		 
178e			 
178e cd c0 18			call next_page_prompt 
1791 c3 b6 16			jp monitor 
1794			.moncdump: 
1794 cd c8 17			call dumpcont 
1797 3e 78			ld a, display_row_4 
1799 11 62 16			ld de, endprog 
179c			 
179c cd 6a 09			call update_display		 
179f			 
179f cd c0 18			call next_page_prompt 
17a2 c3 b6 16			jp monitor 
17a5			 
17a5			 
17a5			; TODO symbol access  
17a5			 
17a5			.symbols:     ;; A list of symbols that can be called up  
17a5 c0 ed			dw display_fb0 
17a7 .. 00			db "fb0",0  
17ab 65 eb		     	dw store_page 
17ad .. 00			db "store_page",0 
17b8			 
17b8			 
17b8			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
17b8			 
17b8 3a 61 e3			ld a,(scratch+1) 
17bb fe 00			cp 0 
17bd 28 09			jr z, dumpcont 
17bf			 
17bf				; no, not a null term line so has an address to work out.... 
17bf			 
17bf 21 62 e3			ld hl,scratch+2 
17c2 cd 2b 0f			call get_word_hl 
17c5			 
17c5 22 83 e6			ld (os_cur_ptr),hl	 
17c8			 
17c8			 
17c8			 
17c8			dumpcont: 
17c8			 
17c8				; dump bytes at ptr 
17c8			 
17c8			 
17c8 3e 00			ld a, display_row_1 
17ca 2a db eb			ld hl, (display_fb_active) 
17cd cd 74 0b			call addatohl 
17d0 cd f8 17			call .dumpbyterow 
17d3			 
17d3 3e 28			ld a, display_row_2 
17d5 2a db eb			ld hl, (display_fb_active) 
17d8 cd 74 0b			call addatohl 
17db cd f8 17			call .dumpbyterow 
17de			 
17de			 
17de 3e 50			ld a, display_row_3 
17e0 2a db eb			ld hl, (display_fb_active) 
17e3 cd 74 0b			call addatohl 
17e6 cd f8 17			call .dumpbyterow 
17e9			 
17e9 3e 78			ld a, display_row_4 
17eb 2a db eb			ld hl, (display_fb_active) 
17ee cd 74 0b			call addatohl 
17f1 cd f8 17			call .dumpbyterow 
17f4			 
17f4 cd 6a 09			call update_display 
17f7			;		jp cli 
17f7 c9				ret 
17f8			 
17f8			.dumpbyterow: 
17f8			 
17f8				;push af 
17f8			 
17f8 e5				push hl 
17f9			 
17f9				; calc where to poke the ascii 
17f9			if display_cols == 20 
17f9				ld a, 16 
17f9			else 
17f9 3e 1f			ld a, 31 
17fb			endif 
17fb			 
17fb cd 74 0b			call addatohl 
17fe 22 65 e6			ld (os_word_scratch),hl  		; save pos for later 
1801			 
1801			 
1801			; display decoding address 
1801 2a 83 e6		   	ld hl,(os_cur_ptr) 
1804			 
1804 7c				ld a,h 
1805 e1				pop hl 
1806 e5				push hl 
1807			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1807 cd 75 0e			call hexout 
180a 2a 83 e6		   	ld hl,(os_cur_ptr) 
180d			 
180d 7d				ld a,l 
180e e1				pop hl 
180f 23				inc hl 
1810 23				inc hl 
1811 e5				push hl 
1812			;	ld hl, os_word_scratch+2 
1812 cd 75 0e			call hexout 
1815 e1				pop hl 
1816 23				inc hl 
1817 23				inc hl 
1818				;ld hl, os_word_scratch+4 
1818 3e 3a			ld a, ':' 
181a 77				ld (hl),a 
181b 23				inc hl 
181c				;ld a, 0 
181c				;ld (hl),a 
181c				;ld de, os_word_scratch 
181c				;pop af 
181c				;push af 
181c			;		ld a, display_row_2 
181c			;		call str_at_display 
181c			;		call update_display 
181c			 
181c			 
181c			;pop af 
181c			;	add 5 
181c			 
181c			if display_cols == 20 
181c				ld b, 4 
181c			else 
181c 06 08			ld b, 8 
181e			endif	 
181e			 
181e			.dumpbyte: 
181e c5				push bc 
181f e5				push hl 
1820			 
1820			 
1820 2a 83 e6		   	ld hl,(os_cur_ptr) 
1823 7e					ld a,(hl) 
1824			 
1824					; poke the ascii to display 
1824 2a 65 e6				ld hl,(os_word_scratch) 
1827 77					ld (hl),a 
1828 23					inc hl 
1829 22 65 e6				ld (os_word_scratch),hl 
182c			 
182c					 
182c			 
182c			 
182c e1					pop hl 
182d e5					push hl 
182e			 
182e cd 75 0e				call hexout 
1831			 
1831					 
1831 2a 83 e6		   	ld hl,(os_cur_ptr) 
1834 23				inc hl 
1835 22 83 e6		   	ld (os_cur_ptr),hl 
1838			 
1838 e1					pop hl 
1839 23					inc hl 
183a 23					inc hl 
183b 23					inc hl 
183c			 
183c			 
183c			 
183c					;ld a,0 
183c					;ld (os_word_scratch+2),a 
183c					;pop af 
183c					;push af 
183c			 
183c					;ld de, os_word_scratch 
183c					;call str_at_display 
183c			;		call update_display 
183c			;		pop af 
183c c1					pop bc 
183d c6 03				add 3 
183f 10 dd			djnz .dumpbyte 
1841			 
1841				 
1841			 
1841 c9				ret 
1842			 
1842			jump:	 
1842			 
1842 21 62 e3			ld hl,scratch+2 
1845 cd 2b 0f			call get_word_hl 
1848				;ld hl,(scratch+2) 
1848				;call fourehexhl 
1848			 
1848 22 83 e6			ld (os_cur_ptr),hl	 
184b			 
184b e9				jp (hl) 
184c			 
184c			 
184c			 
184c			; TODO implement a basic monitor mode to start with 
184c			 
184c			 
184c			 
184c			 
184c			 
184c			 
184c			 
184c			 
184c			 
184c			; testing and demo code during development 
184c			 
184c			 
184c .. 00		str1: db "Enter some text...",0 
185f .. 00		clear: db "                    ",0 
1874			 
1874			demo: 
1874			 
1874			 
1874			 
1874			;	call update_display 
1874			 
1874				; init scratch input area for testing 
1874 21 60 e3			ld hl, scratch	 
1877 3e 00			ld a,0 
1879 77				ld (hl),a 
187a			 
187a			 
187a 3e 28		            LD   A, display_row_2 
187c			;            CALL fLCD_Pos       ;Position cursor to location in A 
187c 11 4c 18		            LD   DE, str1 
187f cd 5a 09			call str_at_display 
1882			 
1882			;            CALL fLCD_Str       ;Display string pointed to by DE 
1882			cloop:	 
1882 3e 50		            LD   A, display_row_3 
1884			;            CALL fLCD_Pos       ;Position cursor to location in A 
1884 11 5f 18		            LD   DE, clear 
1887			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1887 cd 5a 09				call str_at_display 
188a 3e 78			ld a, display_row_4 
188c 11 bc 18			ld de, prompt 
188f			 
188f cd 5a 09				call str_at_display 
1892 cd 6a 09			call update_display 
1895			 
1895 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1897 16 0a			ld d, 10 
1899 21 60 e3			ld hl, scratch	 
189c cd a1 0b			call input_str 
189f			 
189f			;	call clear_display 
189f			;'	call update_display 
189f			 
189f 3e 00		            LD   A, display_row_1 
18a1			;            CALL fLCD_Pos       ;Position cursor to location in A 
18a1 11 5f 18		            LD   DE, clear 
18a4 cd 5a 09				call str_at_display 
18a7			;            CALL fLCD_Str       ;Display string pointed to by DE 
18a7 3e 00		            LD   A, display_row_1 
18a9			;            CALL fLCD_Pos       ;Position cursor to location in A 
18a9 11 60 e3		            LD   DE, scratch 
18ac			;            CALL fLCD_Str       ;Display string pointed to by DE 
18ac cd 5a 09				call str_at_display 
18af cd 6a 09			call update_display 
18b2			 
18b2 3e 00				ld a,0 
18b4 21 60 e3			ld hl, scratch 
18b7 77				ld (hl),a 
18b8			 
18b8 00				nop 
18b9 c3 82 18			jp cloop 
18bc			 
18bc			 
18bc			 
18bc			; OS Prompt 
18bc			 
18bc .. 00		prompt: db ">",0 
18be .. 00		endprg: db "?",0 
18c0			 
18c0			 
18c0			; handy next page prompt 
18c0			next_page_prompt: 
18c0 e5				push hl 
18c1 d5				push de 
18c2 f5				push af 
18c3 c5				push bc 
18c4			 
18c4 3e 9f			ld a,display_row_4 + display_cols - 1 
18c6 11 be 18		        ld de, endprg 
18c9 cd 5a 09			call str_at_display 
18cc cd 6a 09			call update_display 
18cf cd 72 59			call cin_wait 
18d2 c1				pop bc 
18d3 f1				pop af 
18d4 d1				pop de 
18d5 e1				pop hl 
18d6			 
18d6			 
18d6 c9				ret 
18d7			 
18d7			 
18d7			; forth parser 
18d7			 
18d7			; My forth kernel 
18d7			include "forth_kernel.asm" 
18d7			; 
18d7			; kernel to the forth OS 
18d7			 
18d7			DS_TYPE_STR: equ 1     ; string type 
18d7			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
18d7			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
18d7			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
18d7			 
18d7			FORTH_PARSEV1: equ 0 
18d7			FORTH_PARSEV2: equ 0 
18d7			FORTH_PARSEV3: equ 0 
18d7			FORTH_PARSEV4: equ 0 
18d7			FORTH_PARSEV5: equ 1 
18d7			 
18d7			;if FORTH_PARSEV5 
18d7			;	FORTH_END_BUFFER: equ 0 
18d7			;else 
18d7			FORTH_END_BUFFER: equ 127 
18d7			;endif 
18d7			 
18d7			FORTH_TRUE: equ 1 
18d7			FORTH_FALSE: equ 0 
18d7			 
18d7			if FORTH_PARSEV4 
18d7			include "forth_stackops.asm" 
18d7			endif 
18d7			 
18d7			if FORTH_PARSEV5 
18d7			include "forth_stackopsv5.asm" 
18d7			 
18d7			; Stack operations for v5 parser on wards 
18d7			; * DATA stack 
18d7			; * LOOP stack 
18d7			; * RETURN stack 
18d7			 
18d7			 
18d7			 
18d7			FORTH_CHK_DSP_UNDER: macro 
18d7				push hl 
18d7				push de 
18d7				ld hl,(cli_data_sp) 
18d7				ld de, cli_data_stack 
18d7				call cmp16 
18d7				jp c, fault_dsp_under 
18d7				pop de 
18d7				pop hl 
18d7				endm 
18d7			 
18d7			 
18d7			FORTH_CHK_RSP_UNDER: macro 
18d7				push hl 
18d7				push de 
18d7				ld hl,(cli_ret_sp) 
18d7				ld de, cli_ret_stack 
18d7				call cmp16 
18d7				jp c, fault_rsp_under 
18d7				pop de 
18d7				pop hl 
18d7				endm 
18d7			 
18d7			FORTH_CHK_LOOP_UNDER: macro 
18d7				push hl 
18d7				push de 
18d7				ld hl,(cli_loop_sp) 
18d7				ld de, cli_loop_stack 
18d7				call cmp16 
18d7				jp c, fault_loop_under 
18d7				pop de 
18d7				pop hl 
18d7				endm 
18d7			 
18d7			FORTH_ERR_TOS_NOTSTR: macro 
18d7				; TOSO might need more for checks when used 
18d7				push af 
18d7				ld a,(hl) 
18d7				cp DS_TYPE_STR 
18d7				jp nz, type_faultn   
18d7				pop af 
18d7				endm 
18d7			 
18d7			FORTH_ERR_TOS_NOTNUM: macro 
18d7				push af 
18d7				ld a,(hl) 
18d7				cp DS_TYPE_INUM 
18d7				jp nz, type_faultn   
18d7				pop af 
18d7				endm 
18d7			 
18d7			 
18d7			; increase data stack pointer and save hl to it 
18d7				 
18d7			FORTH_DSP_NEXT: macro 
18d7				call macro_forth_dsp_next 
18d7				endm 
18d7			 
18d7			 
18d7			macro_forth_dsp_next: 
18d7				if DEBUG_FORTH_STACK_GUARD 
18d7 cd 8a 56				call check_stacks 
18da				endif 
18da e5				push hl 
18db d5				push de 
18dc eb				ex de,hl 
18dd 2a 0d eb			ld hl,(cli_data_sp) 
18e0 23				inc hl 
18e1 23				inc hl 
18e2			 
18e2			; PARSEV5 
18e2 23				inc hl 
18e3 22 0d eb			ld (cli_data_sp),hl 
18e6 73				ld (hl), e 
18e7 23				inc hl 
18e8 72				ld (hl), d 
18e9 d1				pop de 
18ea e1				pop hl 
18eb				if DEBUG_FORTH_STACK_GUARD 
18eb cd 8a 56				call check_stacks 
18ee				endif 
18ee c9				ret 
18ef			 
18ef			 
18ef			; increase ret stack pointer and save hl to it 
18ef				 
18ef			FORTH_RSP_NEXT: macro 
18ef				call macro_forth_rsp_next 
18ef				endm 
18ef			 
18ef			macro_forth_rsp_next: 
18ef				if DEBUG_FORTH_STACK_GUARD 
18ef cd 8a 56				call check_stacks 
18f2				endif 
18f2 e5				push hl 
18f3 d5				push de 
18f4 eb				ex de,hl 
18f5 2a 11 eb			ld hl,(cli_ret_sp) 
18f8 23				inc hl 
18f9 23				inc hl 
18fa 22 11 eb			ld (cli_ret_sp),hl 
18fd 73				ld (hl), e 
18fe 23				inc hl 
18ff 72				ld (hl), d 
1900 d1				pop de 
1901 e1				pop hl 
1902				if DEBUG_FORTH_STACK_GUARD 
1902 cd 8a 56				call check_stacks 
1905				endif 
1905 c9				ret 
1906			 
1906			; get current ret stack pointer and save to hl  
1906				 
1906			FORTH_RSP_TOS: macro 
1906				call macro_forth_rsp_tos 
1906				endm 
1906			 
1906			macro_forth_rsp_tos: 
1906				;push de 
1906 2a 11 eb			ld hl,(cli_ret_sp) 
1909 cd 41 19			call loadhlptrtohl 
190c				;ld e, (hl) 
190c				;inc hl 
190c				;ld d, (hl) 
190c				;ex de, hl 
190c					if DEBUG_FORTH_WORDS 
190c			;			DMARK "RST" 
190c						CALLMONITOR 
190c cd bb 13			call break_point_state  
190f				endm  
# End of macro CALLMONITOR
190f					endif 
190f				;pop de 
190f c9				ret 
1910			 
1910			; pop ret stack pointer 
1910				 
1910			FORTH_RSP_POP: macro 
1910				call macro_forth_rsp_pop 
1910				endm 
1910			 
1910			 
1910			macro_forth_rsp_pop: 
1910				if DEBUG_FORTH_STACK_GUARD 
1910			;		DMARK "RPP" 
1910 cd 8a 56				call check_stacks 
1913					FORTH_CHK_RSP_UNDER 
1913 e5				push hl 
1914 d5				push de 
1915 2a 11 eb			ld hl,(cli_ret_sp) 
1918 11 cb ea			ld de, cli_ret_stack 
191b cd 92 0b			call cmp16 
191e da 9e 57			jp c, fault_rsp_under 
1921 d1				pop de 
1922 e1				pop hl 
1923				endm 
# End of macro FORTH_CHK_RSP_UNDER
1923				endif 
1923 e5				push hl 
1924 2a 11 eb			ld hl,(cli_ret_sp) 
1927			 
1927			 
1927				if FORTH_ENABLE_FREE 
1927			 
1927					; get pointer 
1927			 
1927					push de 
1927					push hl 
1927			 
1927					ld e, (hl) 
1927					inc hl 
1927					ld d, (hl) 
1927			 
1927					ex de, hl 
1927					call free 
1927			 
1927					pop hl 
1927					pop de 
1927			 
1927			 
1927				endif 
1927			 
1927			 
1927 2b				dec hl 
1928 2b				dec hl 
1929 22 11 eb			ld (cli_ret_sp), hl 
192c				; do stack underflow checks 
192c e1				pop hl 
192d				if DEBUG_FORTH_STACK_GUARD 
192d cd 8a 56				call check_stacks 
1930					FORTH_CHK_RSP_UNDER 
1930 e5				push hl 
1931 d5				push de 
1932 2a 11 eb			ld hl,(cli_ret_sp) 
1935 11 cb ea			ld de, cli_ret_stack 
1938 cd 92 0b			call cmp16 
193b da 9e 57			jp c, fault_rsp_under 
193e d1				pop de 
193f e1				pop hl 
1940				endm 
# End of macro FORTH_CHK_RSP_UNDER
1940				endif 
1940 c9				ret 
1941			 
1941			 
1941			 
1941			; routine to load word pointed to by hl into hl 
1941			 
1941			loadhlptrtohl: 
1941			 
1941 d5				push de 
1942 5e				ld e, (hl) 
1943 23				inc hl 
1944 56				ld d, (hl) 
1945 eb				ex de, hl 
1946 d1				pop de 
1947			 
1947 c9				ret 
1948			 
1948			 
1948			 
1948			 
1948			 
1948			; push a number held in HL onto the data stack 
1948			; entry point for pushing a value when already in hl used in function above 
1948			 
1948			forth_push_numhl: 
1948			 
1948 e5				push hl    ; save value to push 
1949			 
1949			if DEBUG_FORTH_PUSH 
1949				; see if disabled 
1949			 
1949			 
1949 f5				push af 
194a 3a 51 e3			ld a, (os_view_disable) 
194d fe 2a			cp '*' 
194f 28 34			jr z, .pskip2 
1951 e5				push hl 
1952 e5			push hl 
1953 cd 47 09			call clear_display 
1956 e1			pop hl 
1957 7c				ld a,h 
1958 21 65 e6			ld hl, os_word_scratch 
195b cd 75 0e			call hexout 
195e e1				pop hl 
195f 7d				ld a,l 
1960 21 67 e6			ld hl, os_word_scratch+2 
1963 cd 75 0e			call hexout 
1966			 
1966 21 69 e6			ld hl, os_word_scratch+4 
1969 3e 00			ld a,0 
196b 77				ld (hl),a 
196c 11 65 e6			ld de,os_word_scratch 
196f 3e 28				ld a, display_row_2 
1971 cd 5a 09				call str_at_display 
1974 11 98 45			ld de, .push_num 
1977 3e 00			ld a, display_row_1 
1979			 
1979 cd 5a 09				call str_at_display 
197c			 
197c			 
197c cd 6a 09			call update_display 
197f cd ea 08			call delay1s 
1982 cd ea 08			call delay1s 
1985			.pskip2:  
1985			 
1985 f1				pop af 
1986			endif	 
1986			 
1986			 
1986				FORTH_DSP_NEXT 
1986 cd d7 18			call macro_forth_dsp_next 
1989				endm 
# End of macro FORTH_DSP_NEXT
1989			 
1989 2a 0d eb			ld hl, (cli_data_sp) 
198c			 
198c				; save item type 
198c 3e 02			ld a,  DS_TYPE_INUM 
198e 77				ld (hl), a 
198f 23				inc hl 
1990			 
1990				; get word off stack 
1990 d1				pop de 
1991 7b				ld a,e 
1992 77				ld (hl), a 
1993 23				inc hl 
1994 7a				ld a,d 
1995 77				ld (hl), a 
1996			 
1996			if DEBUG_FORTH_PUSH 
1996 2b				dec hl 
1997 2b				dec hl 
1998 2b				dec hl 
1999						DMARK "PH5" 
1999 f5				push af  
199a 3a ae 19			ld a, (.dmark)  
199d 32 7a ee			ld (debug_mark),a  
19a0 3a af 19			ld a, (.dmark+1)  
19a3 32 7b ee			ld (debug_mark+1),a  
19a6 3a b0 19			ld a, (.dmark+2)  
19a9 32 7c ee			ld (debug_mark+2),a  
19ac 18 03			jr .pastdmark  
19ae ..			.dmark: db "PH5"  
19b1 f1			.pastdmark: pop af  
19b2			endm  
# End of macro DMARK
19b2				CALLMONITOR 
19b2 cd bb 13			call break_point_state  
19b5				endm  
# End of macro CALLMONITOR
19b5			endif	 
19b5			 
19b5 c9				ret 
19b6			 
19b6			 
19b6			; Push a string to stack pointed to by hl 
19b6			 
19b6			forth_push_str: 
19b6			 
19b6			if DEBUG_FORTH_PUSH 
19b6						DMARK "PSQ" 
19b6 f5				push af  
19b7 3a cb 19			ld a, (.dmark)  
19ba 32 7a ee			ld (debug_mark),a  
19bd 3a cc 19			ld a, (.dmark+1)  
19c0 32 7b ee			ld (debug_mark+1),a  
19c3 3a cd 19			ld a, (.dmark+2)  
19c6 32 7c ee			ld (debug_mark+2),a  
19c9 18 03			jr .pastdmark  
19cb ..			.dmark: db "PSQ"  
19ce f1			.pastdmark: pop af  
19cf			endm  
# End of macro DMARK
19cf				CALLMONITOR 
19cf cd bb 13			call break_point_state  
19d2				endm  
# End of macro CALLMONITOR
19d2			endif	 
19d2			    
19d2 e5				push hl 
19d3 e5				push hl 
19d4			 
19d4			;	ld a, 0   ; find end of string 
19d4 cd d2 0f			call strlenz 
19d7			if DEBUG_FORTH_PUSH 
19d7						DMARK "PQ2" 
19d7 f5				push af  
19d8 3a ec 19			ld a, (.dmark)  
19db 32 7a ee			ld (debug_mark),a  
19de 3a ed 19			ld a, (.dmark+1)  
19e1 32 7b ee			ld (debug_mark+1),a  
19e4 3a ee 19			ld a, (.dmark+2)  
19e7 32 7c ee			ld (debug_mark+2),a  
19ea 18 03			jr .pastdmark  
19ec ..			.dmark: db "PQ2"  
19ef f1			.pastdmark: pop af  
19f0			endm  
# End of macro DMARK
19f0				CALLMONITOR 
19f0 cd bb 13			call break_point_state  
19f3				endm  
# End of macro CALLMONITOR
19f3			endif	 
19f3 eb				ex de, hl 
19f4 e1				pop hl   ; get ptr to start of string 
19f5			if DEBUG_FORTH_PUSH 
19f5						DMARK "PQ3" 
19f5 f5				push af  
19f6 3a 0a 1a			ld a, (.dmark)  
19f9 32 7a ee			ld (debug_mark),a  
19fc 3a 0b 1a			ld a, (.dmark+1)  
19ff 32 7b ee			ld (debug_mark+1),a  
1a02 3a 0c 1a			ld a, (.dmark+2)  
1a05 32 7c ee			ld (debug_mark+2),a  
1a08 18 03			jr .pastdmark  
1a0a ..			.dmark: db "PQ3"  
1a0d f1			.pastdmark: pop af  
1a0e			endm  
# End of macro DMARK
1a0e				CALLMONITOR 
1a0e cd bb 13			call break_point_state  
1a11				endm  
# End of macro CALLMONITOR
1a11			endif	 
1a11 19				add hl,de 
1a12			if DEBUG_FORTH_PUSH 
1a12						DMARK "PQE" 
1a12 f5				push af  
1a13 3a 27 1a			ld a, (.dmark)  
1a16 32 7a ee			ld (debug_mark),a  
1a19 3a 28 1a			ld a, (.dmark+1)  
1a1c 32 7b ee			ld (debug_mark+1),a  
1a1f 3a 29 1a			ld a, (.dmark+2)  
1a22 32 7c ee			ld (debug_mark+2),a  
1a25 18 03			jr .pastdmark  
1a27 ..			.dmark: db "PQE"  
1a2a f1			.pastdmark: pop af  
1a2b			endm  
# End of macro DMARK
1a2b				CALLMONITOR 
1a2b cd bb 13			call break_point_state  
1a2e				endm  
# End of macro CALLMONITOR
1a2e			endif	 
1a2e			 
1a2e 2b				dec hl    ; see if there is an optional trailing double quote 
1a2f 7e				ld a,(hl) 
1a30 fe 22			cp '"' 
1a32 20 03			jr nz, .strnoq 
1a34 3e 00			ld a, 0      ; get rid of double quote 
1a36 77				ld (hl), a 
1a37 23			.strnoq: inc hl 
1a38			 
1a38 3e 00			ld a, 0 
1a3a 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1a3b			 
1a3b 13				inc de ; add one for the type string 
1a3c 13				inc de ; add one for null term??? 
1a3d			 
1a3d				; tos is get string pointer again 
1a3d				; de contains space to allocate 
1a3d				 
1a3d d5				push de 
1a3e			 
1a3e eb				ex de, hl 
1a3f			 
1a3f				;push af 
1a3f			 
1a3f			if DEBUG_FORTH_PUSH 
1a3f						DMARK "PHm" 
1a3f f5				push af  
1a40 3a 54 1a			ld a, (.dmark)  
1a43 32 7a ee			ld (debug_mark),a  
1a46 3a 55 1a			ld a, (.dmark+1)  
1a49 32 7b ee			ld (debug_mark+1),a  
1a4c 3a 56 1a			ld a, (.dmark+2)  
1a4f 32 7c ee			ld (debug_mark+2),a  
1a52 18 03			jr .pastdmark  
1a54 ..			.dmark: db "PHm"  
1a57 f1			.pastdmark: pop af  
1a58			endm  
# End of macro DMARK
1a58				CALLMONITOR 
1a58 cd bb 13			call break_point_state  
1a5b				endm  
# End of macro CALLMONITOR
1a5b			endif	 
1a5b cd 3b 10			call malloc	; on ret hl now contains allocated memory 
1a5e				if DEBUG_FORTH_MALLOC_GUARD 
1a5e cc f0 45				call z,malloc_error 
1a61				endif 
1a61			 
1a61				 
1a61 c1				pop bc    ; get length 
1a62 d1				pop de   ;  get string start    
1a63			 
1a63				; hl has destination from malloc 
1a63			 
1a63 eb				ex de, hl    ; prep for ldir 
1a64			 
1a64 d5				push de   ; save malloc area for DSP later 
1a65				;push hl   ; save malloc area for DSP later 
1a65			 
1a65			if DEBUG_FORTH_PUSH 
1a65						DMARK "PHc" 
1a65 f5				push af  
1a66 3a 7a 1a			ld a, (.dmark)  
1a69 32 7a ee			ld (debug_mark),a  
1a6c 3a 7b 1a			ld a, (.dmark+1)  
1a6f 32 7b ee			ld (debug_mark+1),a  
1a72 3a 7c 1a			ld a, (.dmark+2)  
1a75 32 7c ee			ld (debug_mark+2),a  
1a78 18 03			jr .pastdmark  
1a7a ..			.dmark: db "PHc"  
1a7d f1			.pastdmark: pop af  
1a7e			endm  
# End of macro DMARK
1a7e				CALLMONITOR 
1a7e cd bb 13			call break_point_state  
1a81				endm  
# End of macro CALLMONITOR
1a81			endif	 
1a81			 
1a81			 
1a81 ed b0			ldir 
1a83			 
1a83			 
1a83				; push malloc to data stack     macro?????  
1a83			 
1a83				FORTH_DSP_NEXT 
1a83 cd d7 18			call macro_forth_dsp_next 
1a86				endm 
# End of macro FORTH_DSP_NEXT
1a86			 
1a86				; save value and type 
1a86			 
1a86 2a 0d eb			ld hl, (cli_data_sp) 
1a89			 
1a89				; save item type 
1a89 3e 01			ld a,  DS_TYPE_STR 
1a8b 77				ld (hl), a 
1a8c 23				inc hl 
1a8d			 
1a8d				; get malloc word off stack 
1a8d d1				pop de 
1a8e 73				ld (hl), e 
1a8f 23				inc hl 
1a90 72				ld (hl), d 
1a91			 
1a91			 
1a91			 
1a91			if DEBUG_FORTH_PUSH 
1a91 2a 0d eb			ld hl, (cli_data_sp) 
1a94						DMARK "PHS" 
1a94 f5				push af  
1a95 3a a9 1a			ld a, (.dmark)  
1a98 32 7a ee			ld (debug_mark),a  
1a9b 3a aa 1a			ld a, (.dmark+1)  
1a9e 32 7b ee			ld (debug_mark+1),a  
1aa1 3a ab 1a			ld a, (.dmark+2)  
1aa4 32 7c ee			ld (debug_mark+2),a  
1aa7 18 03			jr .pastdmark  
1aa9 ..			.dmark: db "PHS"  
1aac f1			.pastdmark: pop af  
1aad			endm  
# End of macro DMARK
1aad				CALLMONITOR 
1aad cd bb 13			call break_point_state  
1ab0				endm  
# End of macro CALLMONITOR
1ab0			;	ex de,hl 
1ab0			endif	 
1ab0				; in case of spaces, skip the ptr past the copied string 
1ab0				;pop af 
1ab0				;ld (cli_origptr),hl 
1ab0			 
1ab0 c9				ret 
1ab1			 
1ab1			 
1ab1			 
1ab1			; TODO ascii push input onto stack given hl to start of input 
1ab1			 
1ab1			; identify type 
1ab1			; if starts with a " then a string 
1ab1			; otherwise it is a number 
1ab1			;  
1ab1			; if a string 
1ab1			;     scan for ending " to get length of string to malloc for + 1 
1ab1			;     malloc 
1ab1			;     put pointer to string on stack first byte flags as string 
1ab1			; 
1ab1			; else a number 
1ab1			;    look for number format identifier 
1ab1			;    $xx hex 
1ab1			;    %xxxxx bin 
1ab1			;    xxxxx decimal 
1ab1			;    convert number to 16bit word.  
1ab1			;    malloc word + 1 with flag to identiy as num 
1ab1			;    put pointer to number on stack 
1ab1			;   
1ab1			;  
1ab1			  
1ab1			forth_apush: 
1ab1				; kernel push 
1ab1			 
1ab1			if DEBUG_FORTH_PUSH 
1ab1						DMARK "PSH" 
1ab1 f5				push af  
1ab2 3a c6 1a			ld a, (.dmark)  
1ab5 32 7a ee			ld (debug_mark),a  
1ab8 3a c7 1a			ld a, (.dmark+1)  
1abb 32 7b ee			ld (debug_mark+1),a  
1abe 3a c8 1a			ld a, (.dmark+2)  
1ac1 32 7c ee			ld (debug_mark+2),a  
1ac4 18 03			jr .pastdmark  
1ac6 ..			.dmark: db "PSH"  
1ac9 f1			.pastdmark: pop af  
1aca			endm  
# End of macro DMARK
1aca				CALLMONITOR 
1aca cd bb 13			call break_point_state  
1acd				endm  
# End of macro CALLMONITOR
1acd			endif	 
1acd				; identify input type 
1acd			 
1acd 7e				ld a,(hl) 
1ace fe 22			cp '"' 
1ad0 28 0a			jr z, .fapstr 
1ad2 fe 24			cp '$' 
1ad4 ca fc 1a			jp z, .faphex 
1ad7 fe 25			cp '%' 
1ad9 ca e4 1a			jp z, .fapbin 
1adc			;	cp 'b' 
1adc			;	jp z, .fabin 
1adc				; else decimal 
1adc			 
1adc				; TODO do decimal conversion 
1adc				; decimal is stored as a 16bit word 
1adc			 
1adc				; by default everything is a string if type is not detected 
1adc			.fapstr: ; 
1adc fe 22			cp '"' 
1ade 20 01			jr nz, .strnoqu 
1ae0 23				inc hl 
1ae1			.strnoqu: 
1ae1 c3 b6 19			jp forth_push_str 
1ae4			 
1ae4			 
1ae4			 
1ae4			.fapbin:    ; push a binary string.  
1ae4 11 00 00			ld de, 0   ; hold a 16bit value 
1ae7			 
1ae7 23			.fapbinshift:	inc hl  
1ae8 7e				ld a,(hl) 
1ae9 fe 00			cp 0     ; done scanning  
1aeb 28 0b			jr z, .fapbdone  	; got it in HL so push  
1aed			 
1aed				; left shift de 
1aed eb				ex de, hl	 
1aee 29				add hl, hl 
1aef			 
1aef				; is 1 
1aef fe 31			cp '1' 
1af1 20 02			jr nz, .binzero 
1af3 cb 4d			bit 1, l 
1af5			.binzero: 
1af5 eb				ex de, hl	 ; save current de 
1af6 18 ef			jr .fapbinshift 
1af8			 
1af8			.fapbdone: 
1af8 eb				ex de, hl 
1af9 c3 48 19			jp forth_push_numhl 
1afc			 
1afc			 
1afc			.faphex:   ; hex is always stored as a 16bit word 
1afc				; skip number prefix 
1afc 23				inc hl 
1afd				; turn ascii into number 
1afd cd 2b 0f			call get_word_hl	; ret 16bit word in hl 
1b00			 
1b00 c3 48 19			jp forth_push_numhl 
1b03			 
1b03 00				 nop 
1b04			 
1b04			.fabin:   ; TODO bin conversion 
1b04			 
1b04			 
1b04 c9				ret 
1b05			 
1b05			 
1b05			; get either a string ptr or a 16bit word from the data stack 
1b05			 
1b05			FORTH_DSP: macro 
1b05				call macro_forth_dsp 
1b05				endm 
1b05			 
1b05			macro_forth_dsp: 
1b05				; data stack pointer points to current word on tos 
1b05			 
1b05 2a 0d eb			ld hl,(cli_data_sp) 
1b08			 
1b08				if DEBUG_FORTH_PUSH 
1b08						DMARK "DSP" 
1b08 f5				push af  
1b09 3a 1d 1b			ld a, (.dmark)  
1b0c 32 7a ee			ld (debug_mark),a  
1b0f 3a 1e 1b			ld a, (.dmark+1)  
1b12 32 7b ee			ld (debug_mark+1),a  
1b15 3a 1f 1b			ld a, (.dmark+2)  
1b18 32 7c ee			ld (debug_mark+2),a  
1b1b 18 03			jr .pastdmark  
1b1d ..			.dmark: db "DSP"  
1b20 f1			.pastdmark: pop af  
1b21			endm  
# End of macro DMARK
1b21			 
1b21 cd 25 46				call display_data_sp 
1b24				;call break_point_state 
1b24				;rst 030h 
1b24				CALLMONITOR 
1b24 cd bb 13			call break_point_state  
1b27				endm  
# End of macro CALLMONITOR
1b27				endif 
1b27			 
1b27 c9				ret 
1b28			 
1b28			; return hl to start of value on stack 
1b28			 
1b28			FORTH_DSP_VALUE: macro 
1b28				call macro_forth_dsp_value 
1b28				endm 
1b28			 
1b28			macro_forth_dsp_value: 
1b28			 
1b28				FORTH_DSP 
1b28 cd 05 1b			call macro_forth_dsp 
1b2b				endm 
# End of macro FORTH_DSP
1b2b			 
1b2b d5				push de 
1b2c			 
1b2c 23				inc hl ; skip type 
1b2d			 
1b2d 5e				ld e, (hl) 
1b2e 23				inc hl 
1b2f 56				ld d, (hl) 
1b30 eb				ex de,hl  
1b31			 
1b31 d1				pop de 
1b32			 
1b32 c9				ret 
1b33			 
1b33			; return hl to start of value to second item on stack 
1b33			 
1b33			FORTH_DSP_VALUEM1: macro 
1b33				call macro_forth_dsp_value_m1 
1b33				endm 
1b33			 
1b33			macro_forth_dsp_value_m1: 
1b33			 
1b33				FORTH_DSP 
1b33 cd 05 1b			call macro_forth_dsp 
1b36				endm 
# End of macro FORTH_DSP
1b36			 
1b36 2b				dec hl 
1b37 2b				dec hl 
1b38			;	dec hl 
1b38			 
1b38 d5				push de 
1b39			 
1b39 5e				ld e, (hl) 
1b3a 23				inc hl 
1b3b 56				ld d, (hl) 
1b3c eb				ex de,hl  
1b3d			 
1b3d d1				pop de 
1b3e			 
1b3e c9				ret 
1b3f			 
1b3f				 
1b3f			 
1b3f			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1b3f			 
1b3f			FORTH_DSP_POP: macro 
1b3f				call macro_forth_dsp_pop 
1b3f				endm 
1b3f			 
1b3f			 
1b3f			; get the tos data type 
1b3f			 
1b3f			FORTH_DSP_TYPE:   macro 
1b3f			 
1b3f				;FORTH_DSP_VALUE 
1b3f				FORTH_DSP 
1b3f				 
1b3f				; hl points to value 
1b3f				; check type 
1b3f			 
1b3f				ld a,(hl) 
1b3f			 
1b3f				endm 
1b3f			 
1b3f			; load the tos value into hl 
1b3f			 
1b3f			 
1b3f			FORTH_DSP_VALUEHL:  macro 
1b3f				call macro_dsp_valuehl 
1b3f				endm 
1b3f			 
1b3f			 
1b3f			 
1b3f			macro_dsp_valuehl: 
1b3f				FORTH_DSP_VALUE 
1b3f cd 28 1b			call macro_forth_dsp_value 
1b42				endm 
# End of macro FORTH_DSP_VALUE
1b42			 
1b42				;FORTH_ERR_TOS_NOTNUM 
1b42			 
1b42				;inc hl   ; skip type id 
1b42			 
1b42			;	push de 
1b42			; 
1b42			;	ld e, (hl) 
1b42			;	inc hl 
1b42			;	ld d, (hl) 
1b42			;	ex de,hl  
1b42			 
1b42			;	pop de 
1b42			 
1b42				if DEBUG_FORTH_PUSH 
1b42						DMARK "DVL" 
1b42 f5				push af  
1b43 3a 57 1b			ld a, (.dmark)  
1b46 32 7a ee			ld (debug_mark),a  
1b49 3a 58 1b			ld a, (.dmark+1)  
1b4c 32 7b ee			ld (debug_mark+1),a  
1b4f 3a 59 1b			ld a, (.dmark+2)  
1b52 32 7c ee			ld (debug_mark+2),a  
1b55 18 03			jr .pastdmark  
1b57 ..			.dmark: db "DVL"  
1b5a f1			.pastdmark: pop af  
1b5b			endm  
# End of macro DMARK
1b5b				CALLMONITOR 
1b5b cd bb 13			call break_point_state  
1b5e				endm  
# End of macro CALLMONITOR
1b5e				endif 
1b5e c9				ret 
1b5f			 
1b5f			forth_apushstrhl:      
1b5f				; push of string requires use of cli_origptr 
1b5f				; bodge use 
1b5f			 
1b5f				; get current cli_origptr, save, update with temp pointer  
1b5f ed 5b 29 eb		ld de, (cli_origptr) 
1b63 22 29 eb			ld (cli_origptr), hl 
1b66 d5				push de 
1b67 cd b1 1a			call forth_apush 
1b6a d1				pop de 
1b6b ed 53 29 eb		ld (cli_origptr), de 
1b6f c9			        ret	 
1b70			 
1b70			 
1b70			; increase loop stack pointer and save hl to it 
1b70				 
1b70			FORTH_LOOP_NEXT: macro 
1b70				call macro_forth_loop_next 
1b70				;nop 
1b70				endm 
1b70			 
1b70			macro_forth_loop_next: 
1b70				if DEBUG_FORTH_STACK_GUARD 
1b70 cd 8a 56				call check_stacks 
1b73				endif 
1b73 e5				push hl 
1b74 d5				push de 
1b75 eb				ex de,hl 
1b76 2a 0f eb			ld hl,(cli_loop_sp) 
1b79 23				inc hl 
1b7a 23				inc hl 
1b7b					if DEBUG_FORTH_WORDS 
1b7b						DMARK "LNX" 
1b7b f5				push af  
1b7c 3a 90 1b			ld a, (.dmark)  
1b7f 32 7a ee			ld (debug_mark),a  
1b82 3a 91 1b			ld a, (.dmark+1)  
1b85 32 7b ee			ld (debug_mark+1),a  
1b88 3a 92 1b			ld a, (.dmark+2)  
1b8b 32 7c ee			ld (debug_mark+2),a  
1b8e 18 03			jr .pastdmark  
1b90 ..			.dmark: db "LNX"  
1b93 f1			.pastdmark: pop af  
1b94			endm  
# End of macro DMARK
1b94						CALLMONITOR 
1b94 cd bb 13			call break_point_state  
1b97				endm  
# End of macro CALLMONITOR
1b97					endif 
1b97 22 0f eb			ld (cli_loop_sp),hl 
1b9a 73				ld (hl), e 
1b9b 23				inc hl 
1b9c 72				ld (hl), d 
1b9d d1				pop de    ; been reversed so save a swap on restore 
1b9e e1				pop hl 
1b9f				if DEBUG_FORTH_STACK_GUARD 
1b9f cd 8a 56				call check_stacks 
1ba2				endif 
1ba2 c9				ret 
1ba3			 
1ba3			; get current ret stack pointer and save to hl  
1ba3				 
1ba3			FORTH_LOOP_TOS: macro 
1ba3				call macro_forth_loop_tos 
1ba3				endm 
1ba3			 
1ba3			macro_forth_loop_tos: 
1ba3 d5				push de 
1ba4 2a 0f eb			ld hl,(cli_loop_sp) 
1ba7 5e				ld e, (hl) 
1ba8 23				inc hl 
1ba9 56				ld d, (hl) 
1baa eb				ex de, hl 
1bab d1				pop de 
1bac c9				ret 
1bad			 
1bad			; pop loop stack pointer 
1bad				 
1bad			FORTH_LOOP_POP: macro 
1bad				call macro_forth_loop_pop 
1bad				endm 
1bad			 
1bad			 
1bad			macro_forth_loop_pop: 
1bad				if DEBUG_FORTH_STACK_GUARD 
1bad					DMARK "LPP" 
1bad f5				push af  
1bae 3a c2 1b			ld a, (.dmark)  
1bb1 32 7a ee			ld (debug_mark),a  
1bb4 3a c3 1b			ld a, (.dmark+1)  
1bb7 32 7b ee			ld (debug_mark+1),a  
1bba 3a c4 1b			ld a, (.dmark+2)  
1bbd 32 7c ee			ld (debug_mark+2),a  
1bc0 18 03			jr .pastdmark  
1bc2 ..			.dmark: db "LPP"  
1bc5 f1			.pastdmark: pop af  
1bc6			endm  
# End of macro DMARK
1bc6 cd 8a 56				call check_stacks 
1bc9					FORTH_CHK_LOOP_UNDER 
1bc9 e5				push hl 
1bca d5				push de 
1bcb 2a 0f eb			ld hl,(cli_loop_sp) 
1bce 11 c9 e9			ld de, cli_loop_stack 
1bd1 cd 92 0b			call cmp16 
1bd4 da a4 57			jp c, fault_loop_under 
1bd7 d1				pop de 
1bd8 e1				pop hl 
1bd9				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1bd9				endif 
1bd9 e5				push hl 
1bda 2a 0f eb			ld hl,(cli_loop_sp) 
1bdd 2b				dec hl 
1bde 2b				dec hl 
1bdf 22 0f eb			ld (cli_loop_sp), hl 
1be2				; TODO do stack underflow checks 
1be2 e1				pop hl 
1be3				if DEBUG_FORTH_STACK_GUARD 
1be3 cd 8a 56				call check_stacks 
1be6					FORTH_CHK_LOOP_UNDER 
1be6 e5				push hl 
1be7 d5				push de 
1be8 2a 0f eb			ld hl,(cli_loop_sp) 
1beb 11 c9 e9			ld de, cli_loop_stack 
1bee cd 92 0b			call cmp16 
1bf1 da a4 57			jp c, fault_loop_under 
1bf4 d1				pop de 
1bf5 e1				pop hl 
1bf6				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1bf6				endif 
1bf6 c9				ret 
1bf7			 
1bf7			macro_forth_dsp_pop: 
1bf7			 
1bf7 e5				push hl 
1bf8			 
1bf8				; release malloc data 
1bf8			 
1bf8				if DEBUG_FORTH_STACK_GUARD 
1bf8 cd 8a 56				call check_stacks 
1bfb					FORTH_CHK_DSP_UNDER 
1bfb e5				push hl 
1bfc d5				push de 
1bfd 2a 0d eb			ld hl,(cli_data_sp) 
1c00 11 c7 e8			ld de, cli_data_stack 
1c03 cd 92 0b			call cmp16 
1c06 da 98 57			jp c, fault_dsp_under 
1c09 d1				pop de 
1c0a e1				pop hl 
1c0b				endm 
# End of macro FORTH_CHK_DSP_UNDER
1c0b				endif 
1c0b				;ld hl,(cli_data_sp) 
1c0b			if DEBUG_FORTH_DOT 
1c0b				DMARK "DPP" 
1c0b				CALLMONITOR 
1c0b			endif	 
1c0b			 
1c0b			 
1c0b			if FORTH_ENABLE_DSPPOPFREE 
1c0b			 
1c0b				FORTH_DSP 
1c0b cd 05 1b			call macro_forth_dsp 
1c0e				endm 
# End of macro FORTH_DSP
1c0e			 
1c0e 7e				ld a, (hl) 
1c0f fe 01			cp DS_TYPE_STR 
1c11 20 07			jr nz, .skippopfree 
1c13			 
1c13				FORTH_DSP_VALUEHL 
1c13 cd 3f 1b			call macro_dsp_valuehl 
1c16				endm 
# End of macro FORTH_DSP_VALUEHL
1c16 00				nop 
1c17			if DEBUG_FORTH_DOT 
1c17				DMARK "DPf" 
1c17				CALLMONITOR 
1c17			endif	 
1c17 cd 05 11			call free 
1c1a			.skippopfree: 
1c1a				 
1c1a			 
1c1a			endif 
1c1a			 
1c1a			if DEBUG_FORTH_DOT_KEY 
1c1a				DMARK "DP2" 
1c1a				CALLMONITOR 
1c1a			endif	 
1c1a			 
1c1a				; move pointer down 
1c1a			 
1c1a 2a 0d eb			ld hl,(cli_data_sp) 
1c1d 2b				dec hl 
1c1e 2b				dec hl 
1c1f			; PARSEV5 
1c1f 2b				dec hl 
1c20 22 0d eb			ld (cli_data_sp), hl 
1c23			 
1c23				if DEBUG_FORTH_STACK_GUARD 
1c23 cd 8a 56				call check_stacks 
1c26					FORTH_CHK_DSP_UNDER 
1c26 e5				push hl 
1c27 d5				push de 
1c28 2a 0d eb			ld hl,(cli_data_sp) 
1c2b 11 c7 e8			ld de, cli_data_stack 
1c2e cd 92 0b			call cmp16 
1c31 da 98 57			jp c, fault_dsp_under 
1c34 d1				pop de 
1c35 e1				pop hl 
1c36				endm 
# End of macro FORTH_CHK_DSP_UNDER
1c36				endif 
1c36			 
1c36 e1				pop hl 
1c37			 
1c37 c9				ret 
1c38			 
1c38			getwordathl: 
1c38				; hl points to an address 
1c38				; load hl with the word at that address 
1c38			 
1c38 d5				push de 
1c39			 
1c39 5e				ld e, (hl) 
1c3a 23				inc hl 
1c3b 56				ld d, (hl) 
1c3c eb				ex de, hl 
1c3d			 
1c3d d1				pop de 
1c3e c9				ret 
1c3f			 
1c3f			 
1c3f			 
1c3f			 
1c3f			 
1c3f			; eof 
1c3f			 
# End of file forth_stackopsv5.asm
1c3f			endif 
1c3f			 
1c3f			user_word_eol:  
1c3f				; hl contains the pointer to where to create a linked list item from the end 
1c3f				; of the user dict to continue on at the system word dict 
1c3f				 
1c3f				; poke the stub of the word list linked list to repoint to rom words 
1c3f			 
1c3f				; stub format 
1c3f				; db   word id 
1c3f				; dw    link to next word 
1c3f			        ; db char length of token 
1c3f				; db string + 0 term 
1c3f				; db exec code....  
1c3f			 
1c3f 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1c41 77				ld (hl), a		; word id 
1c42 23				inc hl 
1c43			 
1c43 11 09 1e			ld de, sysdict 
1c46 73				ld (hl), e		; next word link ie system dict 
1c47 23				inc hl 
1c48 72				ld (hl), d		; next word link ie system dict 
1c49 23				inc hl	 
1c4a			 
1c4a			;	ld (hl), sysdict		; next word link ie system dict 
1c4a			;	inc hl 
1c4a			;	inc hl 
1c4a			 
1c4a			;	inc hl 
1c4a			;	inc hl 
1c4a			 
1c4a 3e 02			ld a, 2			; word length is 0 
1c4c 77				ld (hl), a	 
1c4d 23				inc hl 
1c4e			 
1c4e 3e 7e			ld a, '~'			; word length is 0 
1c50 77				ld (hl), a	 
1c51 23				inc hl 
1c52 3e 00			ld a, 0			; save empty word 
1c54 77				ld (hl), a 
1c55			 
1c55 c9				ret 
1c56			 
1c56				 
1c56			 
1c56			forthexec_cleanup: 
1c56				FORTH_RSP_POP 
1c56 cd 10 19			call macro_forth_rsp_pop 
1c59				endm 
# End of macro FORTH_RSP_POP
1c59 c9				ret 
1c5a			 
1c5a			forth_call_hl: 
1c5a				; taking hl 
1c5a e5				push hl 
1c5b c9				ret 
1c5c			 
1c5c			; this is called to reset Forth system but keep existing uwords etc 
1c5c			 
1c5c			forth_warmstart: 
1c5c				; setup stack over/under flow checks 
1c5c				if DEBUG_FORTH_STACK_GUARD 
1c5c cd 70 56				call chk_stk_init 
1c5f				endif 
1c5f			 
1c5f				; init stack pointers  - * these stacks go upwards *  
1c5f 21 cb ea			ld hl, cli_ret_stack 
1c62 22 11 eb			ld (cli_ret_sp), hl	 
1c65				; set bottom of stack 
1c65 3e 00			ld a,0 
1c67 77				ld (hl),a 
1c68 23				inc hl 
1c69 77				ld (hl),a 
1c6a			 
1c6a 21 c7 e8			ld hl, cli_data_stack 
1c6d 22 0d eb			ld (cli_data_sp), hl	 
1c70				; set bottom of stack 
1c70 3e 00			ld a,0 
1c72 77				ld (hl),a 
1c73 23				inc hl 
1c74 77				ld (hl),a 
1c75			 
1c75 21 c9 e9			ld hl, cli_loop_stack 
1c78 22 0f eb			ld (cli_loop_sp), hl	 
1c7b				; set bottom of stack 
1c7b 3e 00			ld a,0 
1c7d 77				ld (hl),a 
1c7e 23				inc hl 
1c7f 77				ld (hl),a 
1c80			 
1c80				; init extent of current open file 
1c80			 
1c80 3e 00			ld a, 0 
1c82 32 5c eb			ld (store_openext), a 
1c85			 
1c85 c9				ret 
1c86			 
1c86			 
1c86			; Cold Start - this is called to setup the whole Forth system 
1c86			 
1c86			forth_init: 
1c86			 
1c86				; setup stack over/under flow checks 
1c86			 
1c86			;	if DEBUG_FORTH_STACK_GUARD 
1c86			;		call chk_stk_init 
1c86			;	endif 
1c86			 
1c86				; enable auto display updates (slow.....) 
1c86			 
1c86 3e 01			ld a, 1 
1c88 32 27 eb			ld (cli_autodisplay), a 
1c8b			 
1c8b			 
1c8b			 
1c8b				; show start up screen 
1c8b			 
1c8b cd 47 09			call clear_display 
1c8e			 
1c8e 3e 00			ld a,0 
1c90 32 49 eb			ld (f_cursor_ptr), a 
1c93			 
1c93				; set start of word list in start of ram - for use when creating user words 
1c93			 
1c93 21 93 59			ld hl, baseram 
1c96 22 5d e6			ld (os_last_new_uword), hl 
1c99 cd 3f 1c			call user_word_eol 
1c9c				 
1c9c			;		call display_data_sp 
1c9c			;		call next_page_prompt 
1c9c			 
1c9c			 
1c9c			 
1c9c			 
1c9c c9				ret 
1c9d			 
1c9d .. 00		.bootforth: db " Forth Kernel Init ",0 
1cb1			 
1cb1			; TODO push to stack 
1cb1			 
1cb1			;  
1cb1			 
1cb1			if FORTH_PARSEV2 
1cb1			 
1cb1			 
1cb1				include "forth_parserv2.asm" 
1cb1			 
1cb1			endif 
1cb1			 
1cb1			 
1cb1			; parse cli version 1 
1cb1			 
1cb1			if FORTH_PARSEV1 
1cb1			 
1cb1			 
1cb1			 
1cb1			      include "forth_parserv1.asm" 
1cb1			endif 
1cb1				 
1cb1			if FORTH_PARSEV3 
1cb1			 
1cb1			 
1cb1			 
1cb1			      include "forth_parserv3.asm" 
1cb1				include "forth_wordsv3.asm" 
1cb1			endif 
1cb1			 
1cb1			if FORTH_PARSEV4 
1cb1			 
1cb1			 
1cb1			 
1cb1			      include "forth_parserv4.asm" 
1cb1				include "forth_wordsv4.asm" 
1cb1			endif 
1cb1			 
1cb1			if FORTH_PARSEV5 
1cb1			 
1cb1			 
1cb1			 
1cb1			      include "forth_parserv5.asm" 
1cb1			 
1cb1			 
1cb1			; A better parser without using malloc and string copies all over the place.  
1cb1			; Exec in situ should be faster 
1cb1			 
1cb1			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
1cb1			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
1cb1			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
1cb1			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
1cb1			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
1cb1			WORD_SYS_END: equ 0   ; Opcode for all user words 
1cb1			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
1cb1			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
1cb1			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
1cb1			 
1cb1			; Core word preamble macro 
1cb1			 
1cb1			CWHEAD:   macro nxtword opcode lit len opflags 
1cb1				db WORD_SYS_CORE+opcode             
1cb1				; internal op code number 
1cb1				dw nxtword            
1cb1				; link to next dict word block 
1cb1				db len + 1 
1cb1				; literal length of dict word inc zero term 
1cb1				db lit,0              
1cb1				; literal dict word 
1cb1			        ; TODO db opflags        
1cb1				endm 
1cb1			 
1cb1			 
1cb1			NEXTW: macro  
1cb1				jp macro_next 
1cb1				endm 
1cb1			 
1cb1			macro_next: 
1cb1			if DEBUG_FORTH_PARSE_KEY 
1cb1				DMARK "NXT" 
1cb1				CALLMONITOR 
1cb1			endif	 
1cb1			;	inc hl  ; skip token null term  
1cb1 ed 4b 2b eb		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1cb5 ed 5b 29 eb		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1cb9 2a 61 e6			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1cbc			if DEBUG_FORTH_PARSE_KEY 
1cbc				DMARK "}AA" 
1cbc				CALLMONITOR 
1cbc			endif	 
1cbc c3 bf 1d			jp execnext 
1cbf				;jp exec1 
1cbf			       
1cbf			 
1cbf			 
1cbf			; Another go at the parser to compile  
1cbf			 
1cbf			 
1cbf			; TODO rework parser to change all of the string words to byte tokens 
1cbf			; TODO do a search for  
1cbf			 
1cbf			; TODO first run normal parser to zero term sections 
1cbf			; TODO for each word do a token look up to get the op code 
1cbf			; TODO need some means to flag to the exec that this is a byte code form    
1cbf			 
1cbf			 
1cbf			forthcompile: 
1cbf			 
1cbf			; 
1cbf			; line parse: 
1cbf			;       parse raw input buffer 
1cbf			;       tokenise the words 
1cbf			;       malloc new copy (for looping etc) 
1cbf			;       copy to malloc + current pc in line to start of string and add line term 
1cbf			;       save on new rsp 
1cbf			; 
1cbf			 
1cbf			; hl to point to the line to tokenise 
1cbf			 
1cbf			;	push hl 
1cbf 22 61 e6			ld (os_tok_ptr), hl  ; save ptr to string 
1cc2			 
1cc2			;	ld a,0		; string term on input 
1cc2			;	call strlent 
1cc2			 
1cc2			;	ld (os_tok_len), hl	 ; save string length 
1cc2			 
1cc2			;if DEBUG_FORTH_TOK 
1cc2			;	ex de,hl		 
1cc2			;endif 
1cc2			 
1cc2			;	pop hl 		; get back string pointer 
1cc2			 
1cc2			if DEBUG_FORTH_TOK 
1cc2						DMARK "TOc" 
1cc2				CALLMONITOR 
1cc2			endif 
1cc2 7e			.cptoken2:    ld a,(hl) 
1cc3 23				inc hl 
1cc4 fe 7f			cp FORTH_END_BUFFER 
1cc6 28 29			jr z, .cptokendone2 
1cc8 fe 00			cp 0 
1cca 28 25			jr z, .cptokendone2 
1ccc fe 22			cp '"' 
1cce 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
1cd0 fe 20			cp ' ' 
1cd2 20 ee			jr nz,  .cptoken2 
1cd4			 
1cd4			; TODO consume comments held between ( and ) 
1cd4			 
1cd4				; we have a space so change to zero term for dict match later 
1cd4 2b				dec hl 
1cd5 3e 00			ld a,0 
1cd7 77				ld (hl), a 
1cd8 23				inc hl 
1cd9 18 e7			jr .cptoken2 
1cdb				 
1cdb			 
1cdb			.cptokenstr2: 
1cdb				; skip all white space until either eol (because forgot to term) or end double quote 
1cdb			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1cdb				;inc hl ; skip current double quote 
1cdb 7e				ld a,(hl) 
1cdc 23				inc hl 
1cdd fe 22			cp '"' 
1cdf 28 e1			jr z, .cptoken2 
1ce1 fe 7f			cp FORTH_END_BUFFER 
1ce3 28 0c			jr z, .cptokendone2 
1ce5 fe 00			cp 0 
1ce7 28 08			jr z, .cptokendone2 
1ce9 fe 20			cp ' ' 
1ceb 28 02			jr z, .cptmp2 
1ced 18 ec			jr .cptokenstr2 
1cef			 
1cef			.cptmp2:	; we have a space so change to zero term for dict match later 
1cef				;dec hl 
1cef				;ld a,"-"	; TODO remove this when working 
1cef				;ld (hl), a 
1cef				;inc hl 
1cef 18 ea			jr .cptokenstr2 
1cf1			 
1cf1			.cptokendone2: 
1cf1				;inc hl 
1cf1 3e 7f			ld a, FORTH_END_BUFFER 
1cf3 77				ld (hl),a 
1cf4 23				inc hl 
1cf5 3e 21			ld a, '!' 
1cf7 77				ld (hl),a 
1cf8			 
1cf8 2a 61 e6			ld hl,(os_tok_ptr) 
1cfb			         
1cfb			if DEBUG_FORTH_TOK 
1cfb						DMARK "Tc1" 
1cfb				CALLMONITOR 
1cfb			endif 
1cfb			 
1cfb				; push exec string to top of return stack 
1cfb				FORTH_RSP_NEXT 
1cfb cd ef 18			call macro_forth_rsp_next 
1cfe				endm 
# End of macro FORTH_RSP_NEXT
1cfe c9				ret 
1cff			 
1cff			; Another go at the parser need to simplify the process 
1cff			 
1cff			forthparse: 
1cff			 
1cff			; 
1cff			; line parse: 
1cff			;       parse raw input buffer 
1cff			;       tokenise the words 
1cff			;       malloc new copy (for looping etc) 
1cff			;       copy to malloc + current pc in line to start of string and add line term 
1cff			;       save on new rsp 
1cff			; 
1cff			 
1cff			; hl to point to the line to tokenise 
1cff			 
1cff			;	push hl 
1cff 22 61 e6			ld (os_tok_ptr), hl  ; save ptr to string 
1d02			 
1d02			;	ld a,0		; string term on input 
1d02			;	call strlent 
1d02			 
1d02			;	ld (os_tok_len), hl	 ; save string length 
1d02			 
1d02			;if DEBUG_FORTH_TOK 
1d02			;	ex de,hl		 
1d02			;endif 
1d02			 
1d02			;	pop hl 		; get back string pointer 
1d02			 
1d02			if DEBUG_FORTH_TOK 
1d02						DMARK "TOK" 
1d02				CALLMONITOR 
1d02			endif 
1d02 7e			.ptoken2:    ld a,(hl) 
1d03 23				inc hl 
1d04 fe 7f			cp FORTH_END_BUFFER 
1d06 28 29			jr z, .ptokendone2 
1d08 fe 00			cp 0 
1d0a 28 25			jr z, .ptokendone2 
1d0c fe 22			cp '"' 
1d0e 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
1d10 fe 20			cp ' ' 
1d12 20 ee			jr nz,  .ptoken2 
1d14			 
1d14			; TODO consume comments held between ( and ) 
1d14			 
1d14				; we have a space so change to zero term for dict match later 
1d14 2b				dec hl 
1d15 3e 00			ld a,0 
1d17 77				ld (hl), a 
1d18 23				inc hl 
1d19 18 e7			jr .ptoken2 
1d1b				 
1d1b			 
1d1b			.ptokenstr2: 
1d1b				; skip all white space until either eol (because forgot to term) or end double quote 
1d1b			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1d1b				;inc hl ; skip current double quote 
1d1b 7e				ld a,(hl) 
1d1c 23				inc hl 
1d1d fe 22			cp '"' 
1d1f 28 e1			jr z, .ptoken2 
1d21 fe 7f			cp FORTH_END_BUFFER 
1d23 28 0c			jr z, .ptokendone2 
1d25 fe 00			cp 0 
1d27 28 08			jr z, .ptokendone2 
1d29 fe 20			cp ' ' 
1d2b 28 02			jr z, .ptmp2 
1d2d 18 ec			jr .ptokenstr2 
1d2f			 
1d2f			.ptmp2:	; we have a space so change to zero term for dict match later 
1d2f				;dec hl 
1d2f				;ld a,"-"	; TODO remove this when working 
1d2f				;ld (hl), a 
1d2f				;inc hl 
1d2f 18 ea			jr .ptokenstr2 
1d31			 
1d31			.ptokendone2: 
1d31				;inc hl 
1d31 3e 7f			ld a, FORTH_END_BUFFER 
1d33 77				ld (hl),a 
1d34 23				inc hl 
1d35 3e 21			ld a, '!' 
1d37 77				ld (hl),a 
1d38			 
1d38 2a 61 e6			ld hl,(os_tok_ptr) 
1d3b			         
1d3b			if DEBUG_FORTH_TOK 
1d3b						DMARK "TK1" 
1d3b				CALLMONITOR 
1d3b			endif 
1d3b			 
1d3b				; push exec string to top of return stack 
1d3b				FORTH_RSP_NEXT 
1d3b cd ef 18			call macro_forth_rsp_next 
1d3e				endm 
# End of macro FORTH_RSP_NEXT
1d3e c9				ret 
1d3f			 
1d3f			; 
1d3f			;	; malloc size + buffer pointer + if is loop flag 
1d3f			;	ld hl,(os_tok_len) 		 ; get string length 
1d3f			; 
1d3f			;	ld a,l 
1d3f			; 
1d3f			;	cp 0			; we dont want to use a null string 
1d3f			;	ret z 
1d3f			; 
1d3f			;;	add 3    ; prefix malloc with buffer for current word ptr 
1d3f			; 
1d3f			;	add 5     ; TODO when certain not over writing memory remove 
1d3f			; 
1d3f			;		 
1d3f			; 
1d3f			;if DEBUG_FORTH_TOK 
1d3f			;			DMARK "TKE" 
1d3f			;	CALLMONITOR 
1d3f			;endif 
1d3f			; 
1d3f			;	ld l,a 
1d3f			;	ld h,0 
1d3f			;;	push hl   ; save required space for the copy later 
1d3f			;	call malloc 
1d3f			;if DEBUG_FORTH_TOK 
1d3f			;			DMARK "TKM" 
1d3f			;	CALLMONITOR 
1d3f			;endif 
1d3f			;	if DEBUG_FORTH_MALLOC_GUARD 
1d3f			;		push af 
1d3f			;		call ishlzero 
1d3f			;;		ld a, l 
1d3f			;;		add h 
1d3f			;;		cp 0 
1d3f			;		pop af 
1d3f			;		 
1d3f			;		call z,malloc_error 
1d3f			;	endif 
1d3f			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
1d3f			; 
1d3f			; 
1d3f			;if DEBUG_FORTH_TOK 
1d3f			;			DMARK "TKR" 
1d3f			;	CALLMONITOR 
1d3f			;endif 
1d3f			; 
1d3f			;	FORTH_RSP_NEXT 
1d3f			; 
1d3f			;	;inc hl	 ; go past current buffer pointer 
1d3f			;	;inc hl 
1d3f			;	;inc hl   ; and past if loop flag 
1d3f			;		; TODO Need to set flag  
1d3f			; 
1d3f			;	 
1d3f			;	 
1d3f			;	ex de,hl	; malloc is dest 
1d3f			;	ld hl, (os_tok_len) 
1d3f			;;	pop bc 
1d3f			;	ld c, l                
1d3f			;	ld b,0 
1d3f			;	ld hl, (os_tok_ptr) 
1d3f			; 
1d3f			;if DEBUG_FORTH_TOK 
1d3f			;			DMARK "TKT" 
1d3f			;	CALLMONITOR 
1d3f			;endif 
1d3f			; 
1d3f			;	; do str cpy 
1d3f			; 
1d3f			;	ldir      ; copy byte in hl to de 
1d3f			; 
1d3f			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
1d3f			; 
1d3f			;if DEBUG_FORTH_TOK 
1d3f			; 
1d3f			;			DMARK "TKY" 
1d3f			;	CALLMONITOR 
1d3f			;endif 
1d3f			;	;ld a,0 
1d3f			;	;ld a,FORTH_END_BUFFER 
1d3f			;	ex de, hl 
1d3f			;	;dec hl			 ; go back over the space delim at the end of word 
1d3f			;	;ld (hl),a 
1d3f			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
1d3f			;	ld a,FORTH_END_BUFFER 
1d3f			;	ld (hl),a 
1d3f			;	inc hl 
1d3f			;	ld a,FORTH_END_BUFFER 
1d3f			;	ld (hl),a 
1d3f			; 
1d3f			;	; init the malloc area data 
1d3f			;	; set pc for in current area 
1d3f			;	;ld hl, (os_tok_malloc) 
1d3f			;	;inc hl 
1d3f			;	;inc hl 
1d3f			;	;inc hl 
1d3f			;	;ex de,hl 
1d3f			;	;ld hl, (os_tok_malloc) 
1d3f			;	;ld (hl),e 
1d3f			;	;inc hl 
1d3f			;	;ld (hl),d 
1d3f			; 
1d3f			; 
1d3f			;	ld hl,(os_tok_malloc) 
1d3f			;if DEBUG_FORTH_PARSE_KEY 
1d3f			;			DMARK "TKU" 
1d3f			;	CALLMONITOR 
1d3f			;endif 
1d3f			; 
1d3f			;	ret 
1d3f			 
1d3f			forthexec: 
1d3f			 
1d3f			; line exec: 
1d3f			; forth parser 
1d3f			 
1d3f			; 
1d3f			;       get current exec line on rsp 
1d3f			 
1d3f				FORTH_RSP_TOS 
1d3f cd 06 19			call macro_forth_rsp_tos 
1d42				endm 
# End of macro FORTH_RSP_TOS
1d42			 
1d42			;       restore current pc - hl points to malloc of data 
1d42			 
1d42				;ld e, (hl) 
1d42				;inc hl 
1d42				;ld d, (hl) 
1d42				;ex de,hl 
1d42			 
1d42			 
1d42			exec1: 
1d42 22 61 e6			ld (os_tok_ptr), hl 
1d45			 
1d45				; copy our PC to working vars  
1d45 22 2b eb			ld (cli_ptr), hl 
1d48 22 29 eb			ld (cli_origptr), hl 
1d4b			 
1d4b 7e				ld a,(hl) 
1d4c fe 7f			cp FORTH_END_BUFFER 
1d4e c8				ret z 
1d4f			 
1d4f				; skip any nulls 
1d4f			 
1d4f fe 00			cp 0 
1d51 20 03			jr nz, .execword 
1d53 23				inc hl 
1d54 18 ec			jr exec1 
1d56			 
1d56			 
1d56			.execword: 
1d56			 
1d56			 
1d56			 
1d56			if DEBUG_FORTH_PARSE_KEY 
1d56						DMARK "KYQ" 
1d56				CALLMONITOR 
1d56			endif 
1d56			;       while at start of word: 
1d56			; get start of dict (in user area first) 
1d56			 
1d56 21 93 59		ld hl, baseram 
1d59			;ld hl, sysdict 
1d59 22 2d eb		ld (cli_nextword),hl 
1d5c			;           match word at pc 
1d5c			;           exec word 
1d5c			;           or push to dsp 
1d5c			;           forward to next token 
1d5c			;           if line term pop rsp and exit 
1d5c			;        
1d5c			 
1d5c			if DEBUG_FORTH_PARSE_KEY 
1d5c						DMARK "KYq" 
1d5c				CALLMONITOR 
1d5c			endif 
1d5c			 
1d5c			; 
1d5c			; word comp 
1d5c			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
1d5c			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
1d5c			;    move to start of word  
1d5c			;    compare word to cli_token 
1d5c			 
1d5c			.execpnword:	; HL at start of a word in the dictionary to check 
1d5c			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
1d5c			;	ld (cli_ptr), hl 
1d5c			 
1d5c 2a 2d eb			ld hl,(cli_nextword) 
1d5f			 
1d5f cd 02 1e			call forth_tok_next 
1d62			; tok next start here 
1d62			;	; TODO skip compiled symbol for now 
1d62			;	inc hl 
1d62			; 
1d62			;	; save pointer to next word 
1d62			; 
1d62			;	; hl now points to the address of the next word pointer  
1d62			;	ld e, (hl) 
1d62			;	inc hl 
1d62			;	ld d, (hl) 
1d62			;	inc l 
1d62			; 
1d62			;	ex de,hl 
1d62			;if DEBUG_FORTH_PARSE_NEXTWORD 
1d62			;	push bc 
1d62			;	ld bc, (cli_nextword) 
1d62			;			DMARK "NXW" 
1d62			;	CALLMONITOR 
1d62			;	pop bc 
1d62			;endif 
1d62			; tok next end here 
1d62 22 2d eb			ld (cli_nextword), hl     ; save for next check if no match on this word 
1d65 eb				ex de, hl 
1d66			 
1d66			 
1d66				; save the pointer of the current token - 1 to check against 
1d66				 
1d66 22 31 eb			ld (cli_token), hl   
1d69				; TODO maybe remove below save if no debug 
1d69				; save token string ptr for any debug later 
1d69 23				inc hl  
1d6a 22 33 eb			ld (cli_origtoken), hl 
1d6d 2b				dec hl 
1d6e				; save pointer to the start of the next dictionay word 
1d6e 7e				ld a,(hl)   ; get string length 
1d6f 47				ld b,a 
1d70			.execpnwordinc:  
1d70 23				inc hl 
1d71 10 fd			djnz .execpnwordinc 
1d73 22 2f eb			ld (cli_execword), hl      ; save start of this words code 
1d76			 
1d76				; now check the word token against the string being parsed 
1d76			 
1d76 2a 31 eb			ld hl,(cli_token) 
1d79 23				inc hl     ; skip string length (use zero term instead to end) 
1d7a 22 31 eb			ld (cli_token), hl 
1d7d			 
1d7d			if DEBUG_FORTH_PARSE_KEY 
1d7d						DMARK "KY2" 
1d7d			endif 
1d7d			if DEBUG_FORTH_PARSE_EXEC 
1d7d				; see if disabled 
1d7d			 
1d7d				ld a, (os_view_disable) 
1d7d				cp '*' 
1d7d				jr z, .skip 
1d7d			 
1d7d				push hl 
1d7d				push hl 
1d7d				call clear_display 
1d7d				ld de, .compword 
1d7d				ld a, display_row_1 
1d7d				call str_at_display 
1d7d				pop de 
1d7d				ld a, display_row_2 
1d7d				call str_at_display 
1d7d				ld hl,(cli_ptr) 
1d7d				ld a,(hl) 
1d7d			        ld hl, os_word_scratch 
1d7d				ld (hl),a 
1d7d				ld a,0 
1d7d				inc hl 
1d7d				ld (hl),a 	 
1d7d				ld de, os_word_scratch 
1d7d				ld a, display_row_2+10 
1d7d				call str_at_display 
1d7d				call update_display 
1d7d				ld a, 100 
1d7d				call aDelayInMS 
1d7d				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1d7d				call delay250ms 
1d7d				endif 
1d7d				pop hl 
1d7d			.skip:  
1d7d			endif	 
1d7d			.execpnchar:    ; compare char between token and string to parse 
1d7d			 
1d7d			if DEBUG_FORTH_PARSE_KEY 
1d7d						DMARK "Ky3" 
1d7d			endif 
1d7d			if DEBUG_FORTH_PARSE_EXEC 
1d7d				; see if disabled 
1d7d			 
1d7d				ld a, (os_view_disable) 
1d7d				cp '*' 
1d7d				jr z, .skip2 
1d7d			 
1d7d			;	call clear_display 
1d7d			ld hl,(cli_token) 
1d7d			ld a,(hl) 
1d7d			ld (os_word_scratch),a 
1d7d				ld hl,(cli_ptr) 
1d7d			ld a,(hl) 
1d7d				ld (os_word_scratch+1),a 
1d7d				ld a,0 
1d7d				ld (os_word_scratch+2),a 
1d7d				ld de,os_word_scratch 
1d7d				ld a,display_row_4 
1d7d				call str_at_display 
1d7d				call update_display 
1d7d			.skip2:  
1d7d			endif 
1d7d 2a 31 eb			ld hl,(cli_token) 
1d80 7e				ld a, (hl)	 ; char in word token 
1d81 23				inc hl 		; move to next char 
1d82 22 31 eb			ld (cli_token), hl ; and save it 
1d85 47				ld b,a 
1d86			 
1d86 2a 2b eb			ld hl,(cli_ptr) ;	get the char from the string to parse 
1d89 7e				ld a,(hl) 
1d8a 23				inc hl 
1d8b 22 2b eb			ld (cli_ptr), hl		; move to next char 
1d8e cd c9 0f			call toUpper 		; make sure the input string matches case 
1d91			 
1d91			if DEBUG_FORTH_PARSE 
1d91			endif 
1d91			 
1d91				; input stream end of token is a space so get rid of it 
1d91			 
1d91			;	cp ' ' 
1d91			;	jr nz, .pnskipspace 
1d91			; 
1d91			;	ld a, 0		; make same term as word token term 
1d91			; 
1d91			;.pnskipspace: 
1d91			 
1d91			if DEBUG_FORTH_PARSE_KEY 
1d91						DMARK "KY7" 
1d91			endif 
1d91 b8				cp b 
1d92 c2 a8 1d			jp nz, .execpnskipword	 ; no match so move to next word 
1d95				 
1d95			;    if same 
1d95			;       scan for string terms 0 for token and 32 for input 
1d95			 
1d95				 
1d95			if DEBUG_FORTH_PARSE_KEY 
1d95						DMARK "KY8" 
1d95			endif 
1d95			 
1d95 80				add b			 
1d96 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
1d98							; TODO need to make sure last word in zero term string is accounted for 
1d98 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
1d9a			 
1d9a			 
1d9a				; at end of both strings so both are exact match 
1d9a			 
1d9a			;       skip ptr for next word 
1d9a			 
1d9a 2a 2b eb			ld hl,(cli_ptr) 	; at input string term 
1d9d 23				inc hl			 ; at next char 
1d9e 22 2b eb			ld (cli_ptr), hl     ; save for next round of the parser 
1da1 22 29 eb			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
1da4				 
1da4				 
1da4			if DEBUG_FORTH_PARSE_KEY 
1da4						DMARK "KY3" 
1da4			endif 
1da4			 
1da4			 
1da4			 
1da4			;       exec code block 
1da4			if DEBUG_FORTH_JP 
1da4				call clear_display 
1da4				call update_display 
1da4				call delay1s 
1da4				ld hl, (cli_execword)     ; save for next check if no match on this word 
1da4				ld a,h 
1da4				ld hl, os_word_scratch 
1da4				call hexout 
1da4				ld hl, (cli_execword)     ; save for next check if no match on this word 
1da4				ld a,l 
1da4				ld hl, os_word_scratch+2 
1da4				call hexout 
1da4				ld hl, os_word_scratch+4 
1da4				ld a,0 
1da4				ld (hl),a 
1da4				ld de,os_word_scratch 
1da4				call str_at_display 
1da4					ld a, display_row_2 
1da4					call str_at_display 
1da4				ld de, (cli_origtoken) 
1da4				ld a, display_row_1+10 
1da4					call str_at_display 
1da4			 
1da4				ld a,display_row_1 
1da4				ld de, .foundword 
1da4				ld a, display_row_3 
1da4				call str_at_display 
1da4				call update_display 
1da4				call delay1s 
1da4				call delay1s 
1da4				call delay1s 
1da4			endif 
1da4			 
1da4			if DEBUG_FORTH_PARSE_KEY 
1da4						DMARK "KYj" 
1da4			endif 
1da4				; TODO save the word pointer in this exec 
1da4			 
1da4 2a 2f eb			ld hl,(cli_execword) 
1da7 e9				jp (hl) 
1da8			 
1da8			 
1da8			;    if not same 
1da8			;	scan for zero term 
1da8			;	get ptr for next word 
1da8			;	goto word comp 
1da8			 
1da8			.execpnskipword:	; get pointer to next word 
1da8 2a 2d eb			ld hl,(cli_nextword) 
1dab			 
1dab 7e				ld a,(hl) 
1dac fe 00			cp WORD_SYS_END 
1dae			;	cp 0 
1dae 28 09			jr z, .execendofdict			 ; at end of words 
1db0			 
1db0			if DEBUG_FORTH_PARSE_KEY 
1db0						DMARK "KY4" 
1db0			endif 
1db0			if DEBUG_FORTH_PARSE_EXEC 
1db0			 
1db0				; see if disabled 
1db0			 
1db0				ld a, (os_view_disable) 
1db0				cp '*' 
1db0				jr z, .noskip 
1db0			 
1db0			 
1db0				ld de, .nowordfound 
1db0				ld a, display_row_3 
1db0				call str_at_display 
1db0				call update_display 
1db0				ld a, 100 
1db0				call aDelayInMS 
1db0				 
1db0				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1db0					call delay250ms 
1db0				endif 
1db0			.noskip:  
1db0			 
1db0			endif	 
1db0			 
1db0 2a 29 eb			ld hl,(cli_origptr) 
1db3 22 2b eb			ld (cli_ptr),hl 
1db6			 
1db6			if DEBUG_FORTH_PARSE_KEY 
1db6						DMARK "KY5" 
1db6			endif 
1db6 c3 5c 1d			jp .execpnword			; else go to next word 
1db9			 
1db9			.execendofdict:  
1db9			 
1db9			if DEBUG_FORTH_PARSE_KEY 
1db9						DMARK "KYe" 
1db9			endif 
1db9			if DEBUG_FORTH_PARSE_EXEC 
1db9				; see if disabled 
1db9			 
1db9				ld a, (os_view_disable) 
1db9				cp '*' 
1db9				jr z, .ispskip 
1db9			 
1db9				call clear_display 
1db9				call update_display 
1db9				call delay1s 
1db9				ld de, (cli_origptr) 
1db9				ld a, display_row_1 
1db9				call str_at_display 
1db9				 
1db9				ld de, .enddict 
1db9				ld a, display_row_3 
1db9				call str_at_display 
1db9				call update_display 
1db9				ld a, 100 
1db9				call aDelayInMS 
1db9				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1db9				call delay1s 
1db9				call delay1s 
1db9				call delay1s 
1db9				endif 
1db9			.ispskip:  
1db9				 
1db9			endif	 
1db9			 
1db9			 
1db9			 
1db9				; if the word is not a keyword then must be a literal so push it to stack 
1db9			 
1db9			; push token to stack to end of word 
1db9			 
1db9				STACKFRAME ON $1efe $2f9f 
1db9				if DEBUG_STACK_IMB 
1db9					if ON 
1db9						exx 
1db9						ld de, $1efe 
1db9						ld a, d 
1db9						ld hl, curframe 
1db9						call hexout 
1db9						ld a, e 
1db9						ld hl, curframe+2 
1db9						call hexout 
1db9						ld hl, $1efe 
1db9						push hl 
1db9						ld hl, $2f9f 
1db9						push hl 
1db9						exx 
1db9					endif 
1db9				endif 
1db9			endm 
# End of macro STACKFRAME
1db9			 
1db9 2a 61 e6		ld hl,(os_tok_ptr) 
1dbc cd b1 1a		call forth_apush 
1dbf			 
1dbf				STACKFRAMECHK ON $1efe $2f9f 
1dbf				if DEBUG_STACK_IMB 
1dbf					if ON 
1dbf						exx 
1dbf						ld hl, $2f9f 
1dbf						pop de   ; $2f9f 
1dbf						call cmp16 
1dbf						jr nz, .spnosame 
1dbf						ld hl, $1efe 
1dbf						pop de   ; $1efe 
1dbf						call cmp16 
1dbf						jr z, .spfrsame 
1dbf						.spnosame: call showsperror 
1dbf						.spfrsame: nop 
1dbf						exx 
1dbf					endif 
1dbf				endif 
1dbf			endm 
# End of macro STACKFRAMECHK
1dbf			 
1dbf			execnext: 
1dbf			 
1dbf			if DEBUG_FORTH_PARSE_KEY 
1dbf						DMARK "KY>" 
1dbf			endif 
1dbf			; move past token to next word 
1dbf			 
1dbf 2a 61 e6		ld hl, (os_tok_ptr) 
1dc2 3e 00		ld a, 0 
1dc4 01 ff 00		ld bc, 255     ; input buffer size 
1dc7 ed b1		cpir 
1dc9			 
1dc9			if DEBUG_FORTH_PARSE_KEY 
1dc9						DMARK "KY!" 
1dc9				CALLMONITOR 
1dc9			endif	 
1dc9			; TODO this might place hl on the null, so will need to forward on??? 
1dc9			;inc hl   ; see if this gets onto the next item 
1dc9			 
1dc9			 
1dc9			; TODO pass a pointer to the buffer to push 
1dc9			; TODO call function to push 
1dc9			 
1dc9			; look for end of input 
1dc9			 
1dc9			;inc hl 
1dc9			;ld a,(hl) 
1dc9			;cp FORTH_END_BUFFER 
1dc9			;ret z 
1dc9			 
1dc9			 
1dc9 c3 42 1d		jp exec1 
1dcc			 
1dcc			 
1dcc			 
1dcc			 
1dcc			 
1dcc			 
1dcc			 
1dcc			 
1dcc			 
1dcc			findnexttok: 
1dcc			 
1dcc				; hl is pointer to move 
1dcc				; de is the token to locate 
1dcc			 
1dcc					if DEBUG_FORTH 
1dcc						DMARK "NTK" 
1dcc						CALLMONITOR 
1dcc					endif 
1dcc d5				push de 
1dcd			 
1dcd			.fnt1:	 
1dcd				; find first char of token to locate 
1dcd			 
1dcd 1a				ld a, (de) 
1dce 4f				ld c,a 
1dcf 7e				ld a,(hl) 
1dd0 cd c9 0f			call toUpper 
1dd3					if DEBUG_FORTH 
1dd3						DMARK "NT1" 
1dd3						CALLMONITOR 
1dd3					endif 
1dd3 b9				cp c 
1dd4			 
1dd4 28 03			jr z, .fnt2cmpmorefirst	 
1dd6			 
1dd6				; first char not found move to next char 
1dd6			 
1dd6 23				inc hl 
1dd7 18 f4			jr .fnt1 
1dd9			 
1dd9			.fnt2cmpmorefirst:	 
1dd9				; first char of token found.  
1dd9			 
1dd9 e5				push hl     ; save start of token just in case it is the right one 
1dda d9				exx 
1ddb e1				pop hl        ; save it to hl' 
1ddc d9				exx 
1ddd			 
1ddd			 
1ddd			.fnt2cmpmore:	 
1ddd				; compare the rest 
1ddd				 
1ddd 23				inc hl 
1dde 13				inc de 
1ddf				 
1ddf 1a				ld a, (de) 
1de0 4f				ld c,a 
1de1 7e				ld a,(hl) 
1de2 cd c9 0f			call toUpper 
1de5			 
1de5					if DEBUG_FORTH 
1de5						DMARK "NT2" 
1de5						CALLMONITOR 
1de5					endif 
1de5				; c has the token to find char 
1de5				; a has the mem to scan char 
1de5			 
1de5 b9				cp c 
1de6 28 04			jr z,.fntmatch1 
1de8			 
1de8				; they are not the same 
1de8			 
1de8					if DEBUG_FORTH 
1de8						DMARK "NT3" 
1de8						CALLMONITOR 
1de8					endif 
1de8 d1				pop de	; reset de token to look for 
1de9 d5				push de 
1dea 18 e1			jr .fnt1 
1dec				 
1dec			.fntmatch1: 
1dec			 
1dec				; is the same char a null which means we might have a full hit? 
1dec					if DEBUG_FORTH 
1dec						DMARK "NT4" 
1dec						CALLMONITOR 
1dec					endif 
1dec			 
1dec fe 00			cp 0 
1dee 28 0b			jr z, .fntmatchyes 
1df0			 
1df0				; are we at the end of the token to find? 
1df0			 
1df0					if DEBUG_FORTH 
1df0						DMARK "NT5" 
1df0						CALLMONITOR 
1df0					endif 
1df0 3e 00			ld a, 0 
1df2 b9				cp c 
1df3			 
1df3 c2 dd 1d			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
1df6			 
1df6					if DEBUG_FORTH 
1df6						DMARK "NT6" 
1df6						CALLMONITOR 
1df6					endif 
1df6				; token to find is exhusted but no match to stream 
1df6			 
1df6				; restore tok pointer and continue on 
1df6 d1				pop de 
1df7 d5				push de 
1df8 c3 cd 1d			jp .fnt1 
1dfb			 
1dfb			 
1dfb			.fntmatchyes: 
1dfb			 
1dfb				; hl now contains the end of the found token 
1dfb			 
1dfb				; get rid of saved token pointer to find 
1dfb			 
1dfb d1				pop de 
1dfc			 
1dfc					if DEBUG_FORTH 
1dfc						DMARK "NT9" 
1dfc						CALLMONITOR 
1dfc					endif 
1dfc			 
1dfc				; hl will be on the null term so forward on 
1dfc			 
1dfc				; get back the saved start of the token 
1dfc			 
1dfc d9				exx 
1dfd e5				push hl     ; save start of token just in case it is the right one 
1dfe d9				exx 
1dff e1				pop hl        ; save it to hl 
1e00			 
1e00 c9				ret 
1e01			 
1e01			 
1e01			; LIST needs to find a specific token   
1e01			; FORGET needs to find a spefici token 
1e01			 
1e01			; SAVE needs to find all tokens by flag 
1e01			; WORDS just needs to scan through all  by flag 
1e01			; UWORDS needs to scan through all by flag 
1e01			 
1e01			 
1e01			; given hl as pointer to start of dict look up string 
1e01			; return hl as pointer to start of word block 
1e01			; or 0 if not found 
1e01			 
1e01			forth_find_tok: 
1e01 c9				ret 
1e02			 
1e02			; given hl as pointer to dict structure 
1e02			; move to the next dict block structure 
1e02			 
1e02			forth_tok_next: 
1e02				; hl now points to the address of the next word pointer  
1e02				; TODO skip compiled symbol for now 
1e02			;	push de 
1e02 23				inc hl 
1e03 5e				ld e, (hl) 
1e04 23				inc hl 
1e05 56				ld d, (hl) 
1e06 23				inc hl 
1e07			 
1e07 eb				ex de,hl 
1e08			if DEBUG_FORTH_PARSE_NEXTWORD 
1e08				push bc 
1e08				ld bc, (cli_nextword) 
1e08						DMARK "NXW" 
1e08				CALLMONITOR 
1e08				pop bc 
1e08			endif 
1e08			;	pop de	 
1e08 c9				ret 
1e09			 
1e09			 
1e09			 
1e09			; eof 
# End of file forth_parserv5.asm
1e09				include "forth_wordsv4.asm" 
1e09			 
1e09			; the core word dictionary v4 
1e09			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
1e09			 
1e09			; this is a linked list for each of the system words used 
1e09			; user defined words will follow the same format but will be in ram 
1e09			 
1e09			 
1e09			; 
1e09			; 
1e09			; define linked list: 
1e09			; 
1e09			; 1. compiled byte op code 
1e09			; 2. len of text word 
1e09			; 3. text word 
1e09			; 4. ptr to next dictionary word 
1e09			; 5. asm, calls etc for the word 
1e09			; 
1e09			;  if 1 == 0 then last word in dict  
1e09			;   
1e09			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
1e09			;  
1e09			;  
1e09			; create basic standard set of words 
1e09			; 
1e09			;  
1e09			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
1e09			; 2DUP 2DROP 2SWAP  
1e09			; @ C@ - get byte  
1e09			; ! C! - store byte 
1e09			; 0< true if less than zero 
1e09			; 0= true if zero 
1e09			; < >  
1e09			; = true if same 
1e09			; variables 
1e09			 
1e09			 
1e09			; Hardware specific words I may need 
1e09			; 
1e09			; IN OUT  
1e09			; calls to key util functions 
1e09			; calls to hardward abstraction stuff 
1e09			; easy control of frame buffers and lcd i/o 
1e09			; keyboard  
1e09			 
1e09			 
1e09			;DICT: macro 
1e09			; op_code, len, word, next 
1e09			;    word: 
1e09			;    db op_code 
1e09			;    ds word zero term 
1e09			;    dw next 
1e09			;    endm 
1e09			 
1e09			 
1e09			 
1e09			 
1e09			; op code 1 is a flag for user define words which are to be handled differently 
1e09			 
1e09			 
1e09			; 
1e09			; 
1e09			;    TODO on entry to a word this should be the expected environment 
1e09			;    hl - tos value if number then held, if string this is the ptr 
1e09			;    de -  
1e09			 
1e09			 
1e09			; opcode ranges 
1e09			; 0 - end of word dict 
1e09			; 255 - user define words 
1e09			 
1e09			sysdict: 
1e09			include "forth_opcodes.asm" 
1e09			; op codes for forth keywords 
1e09			; free to use code 0  
1e09				OPCODE_HEAP: equ  1 
1e09				OPCODE_EXEC: equ 2 
1e09				OPCODE_DUP: equ 3 
1e09				OPCODE_SWAP: equ 4 
1e09				OPCODE_COLN: equ 5 
1e09				OPCODE_SCOLN: equ 6 
1e09				OPCODE_DROP: equ 7 
1e09				OPCODE_DUP2: equ 8 
1e09				OPCODE_DROP2: equ 9 
1e09				OPCODE_SWAP2: equ 10 
1e09				OPCODE_AT: equ 11 
1e09				OPCODE_CAT: equ 12 
1e09				OPCODE_BANG: equ 13 
1e09				OPCODE_CBANG: equ 14 
1e09				OPCODE_SCALL: equ 15 
1e09				OPCODE_DEPTH: equ 16 
1e09				OPCODE_OVER: equ 17 
1e09				OPCODE_PAUSE: equ 18 
1e09				OPCODE_PAUSES: equ 19 
1e09				OPCODE_ROT: equ 20 
1e09			;free to reuse	OPCODE_WORDS: equ 21 
1e09			        OPCODE_NOT: equ 21 
1e09				OPCODE_UWORDS: equ 22 
1e09				OPCODE_BP: equ 23 
1e09				OPCODE_MONITOR: equ 24  
1e09				OPCODE_MALLOC: equ 25 
1e09				OPCODE_FREE: equ 26 
1e09				OPCODE_LIST: equ 27 
1e09				OPCODE_FORGET: equ 28 
1e09				OPCODE_NOP: equ 29 
1e09				OPCODE_COMO: equ 30 
1e09				OPCODE_COMC: equ 31 
1e09			;free to reuse	OPCODE_ENDCORE: equ 32 
1e09				OPCODE_AFTERSOUND: equ 33 
1e09				OPCODE_GP2: equ 34 
1e09				OPCODE_GP3: equ 35 
1e09				OPCODE_GP4: equ 36 
1e09				OPCODE_SIN: equ 37 
1e09				OPCODE_SOUT: equ 38 
1e09				OPCODE_SPIO: equ 39 
1e09				OPCODE_SPICEH: equ 40 
1e09				OPCODE_SPIOb: equ 41 
1e09				OPCODE_SPII: equ 42 
1e09				OPCODE_SESEL: equ 43 
1e09				OPCODE_CARTDEV: equ 44 
1e09			; free to reuse	OPCODE_ENDDEVICE: equ 45 
1e09				OPCODE_FB: equ 46 
1e09				OPCODE_EMIT: equ 47 
1e09				OPCODE_DOTH: equ 48 
1e09				OPCODE_DOTF: equ 49 
1e09				OPCODE_DOT: equ 50 
1e09				OPCODE_CLS: equ 51 
1e09				OPCODE_DRAW: equ 52 
1e09				OPCODE_DUMP: equ 53 
1e09				OPCODE_CDUMP: equ 54 
1e09				OPCODE_DAT: equ 55 
1e09				OPCODE_HOME: equ 56 
1e09				OPCODE_SPACE: equ 57 
1e09				OPCODE_SPACES: equ 58 
1e09				OPCODE_SCROLL: equ 59 
1e09				OPCODE_ATQ: equ 60 
1e09				OPCODE_AUTODSP: equ 61 
1e09				OPCODE_MENU: equ 62 
1e09			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
1e09				OPCODE_THEN: equ 64 
1e09				OPCODE_ELSE: equ 65 
1e09				OPCODE_DO: equ 66 
1e09				OPCODE_LOOP: equ 67 
1e09				OPCODE_I: equ 68 
1e09				OPCODE_DLOOP: equ 69  
1e09				OPCODE_REPEAT: equ 70  
1e09				OPCODE_UNTIL: equ 71 
1e09				OPCODE_ENDFLOW: equ 72 
1e09				OPCODE_WAITK: equ 73 
1e09				OPCODE_ACCEPT: equ 74 
1e09				OPCODE_EDIT: equ 75 
1e09			;free to reuse	OPCODE_ENDKEY: equ 76 
1e09				OPCODE_LZERO: equ 77 
1e09				OPCODE_TZERO: equ 78 
1e09				OPCODE_LESS: equ 79 
1e09				OPCODE_GT: equ 80 
1e09				OPCODE_EQUAL: equ 81  
1e09			;free to reuse	OPCODE_ENDLOGIC: equ 82 
1e09				OPCODE_NEG: equ 83 
1e09				OPCODE_DIV: equ 84 
1e09				OPCODE_MUL: equ 85 
1e09				OPCODE_MIN: equ 86 
1e09				OPCODE_MAX: equ 87 
1e09				OPCODE_RND16: equ 88 
1e09				OPCODE_RND8: equ 89 
1e09				OPCODE_RND: equ 90 
1e09			;free to reuse	OPCODE_ENDMATHS: equ 91  
1e09				OPCODE_BYNAME: equ 92 
1e09				OPCODE_DIR: equ 93 
1e09				OPCODE_SAVE: equ 94 
1e09				OPCODE_LOAD: equ 95 
1e09				OPCODE_BSAVE: equ 96 
1e09				OPCODE_BLOAD: equ 97 
1e09				OPCODE_SEO: equ 98  
1e09				OPCODE_SEI: equ 99 
1e09				OPCODE_SFREE: equ 100 
1e09				OPCODE_SIZE: equ 101 
1e09				OPCODE_CREATE: equ 102 
1e09				OPCODE_APPEND: equ 103 
1e09				OPCODE_SDEL: equ 104 
1e09				OPCODE_OPEN: equ 105 
1e09				OPCODE_READ: equ 106 
1e09				OPCODE_EOF: equ 106 
1e09				OPCODE_FORMAT: equ 107 
1e09				OPCODE_LABEL: equ 108 
1e09				OPCODE_LABELS: equ 109 
1e09			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
1e09				OPCODE_UPPER: equ 111 
1e09				OPCODE_LOWER: equ 112 
1e09				OPCODE_SUBSTR: equ 113 
1e09				OPCODE_LEFT: equ 114 
1e09				OPCODE_RIGHT: equ 115 
1e09				OPCODE_STR2NUM: equ 116 
1e09				OPCODE_NUM2STR: equ 117 
1e09				OPCODE_CONCAT: equ 118 
1e09				OPCODE_FIND: equ 119 
1e09				OPCODE_LEN: equ 120 
1e09				OPCODE_CHAR: equ 121 
1e09			; free to reuse	OPCODE_STRLEN: equ 122 
1e09			; free to reuse	OPCODE_ENDSTR: equ 123 
1e09				OPCODE_V0S: equ 124 
1e09				OPCODE_V0Q: equ 125 
1e09				OPCODE_V1S: equ 126 
1e09				OPCODE_V1Q: equ 127 
1e09				OPCODE_V2S: equ 128 
1e09				OPCODE_V2Q: equ 129 
1e09				OPCODE_V3S: equ 130 
1e09				OPCODE_V3Q: equ 131 
1e09			;free to reuse	OPCODE_END: equ 132 
1e09				OPCODE_ZDUP: equ 133 
1e09			 
1e09			; eof 
# End of file forth_opcodes.asm
1e09			 
1e09			include "forth_words_core.asm" 
1e09			 
1e09			; | ## Core Words 
1e09			 
1e09			;if MALLOC_4 
1e09			 
1e09			.HEAP: 
1e09				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
1e09 15				db WORD_SYS_CORE+OPCODE_HEAP             
1e0a 48 1e			dw .EXEC            
1e0c 05				db 4 + 1 
1e0d .. 00			db "HEAP",0              
1e12				endm 
# End of macro CWHEAD
1e12			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
1e12			; | | u1 - Current number of bytes in the heap 
1e12			; | | u2 - Remaining bytes left on the heap 
1e12			; | |  
1e12			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
1e12			 
1e12			 
1e12					if DEBUG_FORTH_WORDS_KEY 
1e12						DMARK "HEP" 
1e12 f5				push af  
1e13 3a 27 1e			ld a, (.dmark)  
1e16 32 7a ee			ld (debug_mark),a  
1e19 3a 28 1e			ld a, (.dmark+1)  
1e1c 32 7b ee			ld (debug_mark+1),a  
1e1f 3a 29 1e			ld a, (.dmark+2)  
1e22 32 7c ee			ld (debug_mark+2),a  
1e25 18 03			jr .pastdmark  
1e27 ..			.dmark: db "HEP"  
1e2a f1			.pastdmark: pop af  
1e2b			endm  
# End of macro DMARK
1e2b						CALLMONITOR 
1e2b cd bb 13			call break_point_state  
1e2e				endm  
# End of macro CALLMONITOR
1e2e					endif 
1e2e 2a 9d 59				ld hl, (free_list )      
1e31 11 a2 59				ld de, heap_start 
1e34			 
1e34 ed 52				sbc hl, de  
1e36			 
1e36 cd 48 19				call forth_push_numhl 
1e39			 
1e39			 
1e39 ed 5b 9d 59			ld de, (free_list )      
1e3d 21 46 e3				ld hl, heap_end 
1e40			 
1e40 ed 52				sbc hl, de 
1e42			 
1e42 cd 48 19				call forth_push_numhl 
1e45					 
1e45			 
1e45					 
1e45			 
1e45			 
1e45			 
1e45					NEXTW 
1e45 c3 b1 1c			jp macro_next 
1e48				endm 
# End of macro NEXTW
1e48			;endif 
1e48			 
1e48			.EXEC: 
1e48				CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
1e48 16				db WORD_SYS_CORE+OPCODE_EXEC             
1e49 e4 1e			dw .STKEXEC            
1e4b 05				db 4 + 1 
1e4c .. 00			db "EXEC",0              
1e51				endm 
# End of macro CWHEAD
1e51			; | EXEC ( u -- )    Execs the string on TOS as a FORTH expression | CRASHES ON NEXTW 
1e51			; | | u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
1e51			; | | 
1e51			; | |   
1e51				STACKFRAME OFF $5efe $5f9f 
1e51				if DEBUG_STACK_IMB 
1e51					if OFF 
1e51						exx 
1e51						ld de, $5efe 
1e51						ld a, d 
1e51						ld hl, curframe 
1e51						call hexout 
1e51						ld a, e 
1e51						ld hl, curframe+2 
1e51						call hexout 
1e51						ld hl, $5efe 
1e51						push hl 
1e51						ld hl, $5f9f 
1e51						push hl 
1e51						exx 
1e51					endif 
1e51				endif 
1e51			endm 
# End of macro STACKFRAME
1e51			 
1e51					if DEBUG_FORTH_WORDS_KEY 
1e51						DMARK "EXE" 
1e51 f5				push af  
1e52 3a 66 1e			ld a, (.dmark)  
1e55 32 7a ee			ld (debug_mark),a  
1e58 3a 67 1e			ld a, (.dmark+1)  
1e5b 32 7b ee			ld (debug_mark+1),a  
1e5e 3a 68 1e			ld a, (.dmark+2)  
1e61 32 7c ee			ld (debug_mark+2),a  
1e64 18 03			jr .pastdmark  
1e66 ..			.dmark: db "EXE"  
1e69 f1			.pastdmark: pop af  
1e6a			endm  
# End of macro DMARK
1e6a						CALLMONITOR 
1e6a cd bb 13			call break_point_state  
1e6d				endm  
# End of macro CALLMONITOR
1e6d					endif 
1e6d			 
1e6d				FORTH_DSP_VALUEHL 
1e6d cd 3f 1b			call macro_dsp_valuehl 
1e70				endm 
# End of macro FORTH_DSP_VALUEHL
1e70			 
1e70				FORTH_DSP_POP 
1e70 cd f7 1b			call macro_forth_dsp_pop 
1e73				endm 
# End of macro FORTH_DSP_POP
1e73			 
1e73					if DEBUG_FORTH_WORDS 
1e73						DMARK "EX1" 
1e73 f5				push af  
1e74 3a 88 1e			ld a, (.dmark)  
1e77 32 7a ee			ld (debug_mark),a  
1e7a 3a 89 1e			ld a, (.dmark+1)  
1e7d 32 7b ee			ld (debug_mark+1),a  
1e80 3a 8a 1e			ld a, (.dmark+2)  
1e83 32 7c ee			ld (debug_mark+2),a  
1e86 18 03			jr .pastdmark  
1e88 ..			.dmark: db "EX1"  
1e8b f1			.pastdmark: pop af  
1e8c			endm  
# End of macro DMARK
1e8c						CALLMONITOR 
1e8c cd bb 13			call break_point_state  
1e8f				endm  
# End of macro CALLMONITOR
1e8f					endif 
1e8f			;	ld e,(hl) 
1e8f			;	inc hl 
1e8f			;	ld d,(hl) 
1e8f			;	ex de,hl 
1e8f			 
1e8f			;		if DEBUG_FORTH_WORDS 
1e8f			;			DMARK "EX2" 
1e8f			;			CALLMONITOR 
1e8f			;		endif 
1e8f e5				push hl 
1e90			 
1e90				;ld a, 0 
1e90				;ld a, FORTH_END_BUFFER 
1e90 cd d2 0f			call strlenz 
1e93 23				inc hl   ; include zero term to copy 
1e94 23				inc hl   ; include term 
1e95 23				inc hl   ; include term 
1e96 06 00			ld b,0 
1e98 4d				ld c,l 
1e99 e1				pop hl 
1e9a 11 5f e4			ld de, execscratch 
1e9d					if DEBUG_FORTH_WORDS 
1e9d						DMARK "EX3" 
1e9d f5				push af  
1e9e 3a b2 1e			ld a, (.dmark)  
1ea1 32 7a ee			ld (debug_mark),a  
1ea4 3a b3 1e			ld a, (.dmark+1)  
1ea7 32 7b ee			ld (debug_mark+1),a  
1eaa 3a b4 1e			ld a, (.dmark+2)  
1ead 32 7c ee			ld (debug_mark+2),a  
1eb0 18 03			jr .pastdmark  
1eb2 ..			.dmark: db "EX3"  
1eb5 f1			.pastdmark: pop af  
1eb6			endm  
# End of macro DMARK
1eb6						CALLMONITOR 
1eb6 cd bb 13			call break_point_state  
1eb9				endm  
# End of macro CALLMONITOR
1eb9					endif 
1eb9 ed b0			ldir 
1ebb			 
1ebb			 
1ebb 21 5f e4			ld hl, execscratch 
1ebe			 
1ebe					if DEBUG_FORTH_WORDS 
1ebe						DMARK "EXe" 
1ebe f5				push af  
1ebf 3a d3 1e			ld a, (.dmark)  
1ec2 32 7a ee			ld (debug_mark),a  
1ec5 3a d4 1e			ld a, (.dmark+1)  
1ec8 32 7b ee			ld (debug_mark+1),a  
1ecb 3a d5 1e			ld a, (.dmark+2)  
1ece 32 7c ee			ld (debug_mark+2),a  
1ed1 18 03			jr .pastdmark  
1ed3 ..			.dmark: db "EXe"  
1ed6 f1			.pastdmark: pop af  
1ed7			endm  
# End of macro DMARK
1ed7						CALLMONITOR 
1ed7 cd bb 13			call break_point_state  
1eda				endm  
# End of macro CALLMONITOR
1eda					endif 
1eda			 
1eda cd ff 1c			call forthparse 
1edd cd 3f 1d			call forthexec 
1ee0			;	call forthexec_cleanup 
1ee0			;	call forthparse 
1ee0			;	call forthexec 
1ee0			 
1ee0				STACKFRAMECHK OFF $5efe $5f9f 
1ee0				if DEBUG_STACK_IMB 
1ee0					if OFF 
1ee0						exx 
1ee0						ld hl, $5f9f 
1ee0						pop de   ; $5f9f 
1ee0						call cmp16 
1ee0						jr nz, .spnosame 
1ee0						ld hl, $5efe 
1ee0						pop de   ; $5efe 
1ee0						call cmp16 
1ee0						jr z, .spfrsame 
1ee0						.spnosame: call showsperror 
1ee0						.spfrsame: nop 
1ee0						exx 
1ee0					endif 
1ee0				endif 
1ee0			endm 
# End of macro STACKFRAMECHK
1ee0			 
1ee0				; an immediate word so no need to process any more words 
1ee0 c9				ret 
1ee1				NEXTW 
1ee1 c3 b1 1c			jp macro_next 
1ee4				endm 
# End of macro NEXTW
1ee4			 
1ee4			; dead code - old version  
1ee4			;	FORTH_RSP_NEXT 
1ee4			 
1ee4			;  
1ee4			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1ee4			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1ee4			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1ee4			;	push hl 
1ee4			;	push de 
1ee4			;	push bc 
1ee4			; 
1ee4			; 
1ee4			;		if DEBUG_FORTH_WORDS_KEY 
1ee4			;			DMARK "EXR" 
1ee4			;			CALLMONITOR 
1ee4			;		endif 
1ee4			; 
1ee4			; 
1ee4			; 
1ee4			;	;v5 FORTH_DSP_VALUE 
1ee4			;	FORTH_DSP_VALUEHL 
1ee4			; 
1ee4			;	; TODO do string type checks 
1ee4			; 
1ee4			;;v5	inc hl   ; skip type 
1ee4			; 
1ee4			;	push hl  ; source code  
1ee4			;		if DEBUG_FORTH_WORDS 
1ee4			;			DMARK "EX1" 
1ee4			;			CALLMONITOR 
1ee4			;		endif 
1ee4			;	ld a, 0 
1ee4			;	call strlent 
1ee4			; 
1ee4			;	inc hl 
1ee4			;	inc hl 
1ee4			;	inc hl 
1ee4			;	inc hl 
1ee4			; 
1ee4			;	push hl    ; size 
1ee4			; 
1ee4			;		if DEBUG_FORTH_WORDS 
1ee4			;			DMARK "EX2" 
1ee4			;			CALLMONITOR 
1ee4			;		endif 
1ee4			;	call malloc 
1ee4			; 
1ee4			;	ex de, hl    ; de now contains malloc area 
1ee4			;	pop bc   	; get byte count 
1ee4			;	pop hl      ; get string to copy 
1ee4			; 
1ee4			;	push de     ; save malloc for free later 
1ee4			; 
1ee4			;		if DEBUG_FORTH_WORDS 
1ee4			;			DMARK "EX3" 
1ee4			;			CALLMONITOR 
1ee4			;		endif 
1ee4			;	ldir       ; duplicate string 
1ee4			; 
1ee4			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
1ee4			;	 
1ee4			;	; TODO fix the parse would be better than this...  
1ee4			;	ex de, hl 
1ee4			;	dec hl 
1ee4			;	ld a, 0 
1ee4			;	ld (hl), a 
1ee4			;	dec hl 
1ee4			;	ld a, ' ' 
1ee4			;	ld (hl), a 
1ee4			;	dec hl 
1ee4			;	ld (hl), a 
1ee4			; 
1ee4			;	dec hl 
1ee4			;	ld (hl), a 
1ee4			; 
1ee4			; 
1ee4			;	FORTH_DSP_POP  
1ee4			; 
1ee4			;	pop hl     
1ee4			;	push hl    ; save malloc area 
1ee4			; 
1ee4			;		if DEBUG_FORTH_WORDS 
1ee4			;			DMARK "EX4" 
1ee4			;			CALLMONITOR 
1ee4			;		endif 
1ee4			; 
1ee4			;	call forthparse 
1ee4			;	call forthexec 
1ee4			;	 
1ee4			;	pop hl 
1ee4			;	if DEBUG_FORTH_WORDS 
1ee4			;		DMARK "EX5" 
1ee4			;		CALLMONITOR 
1ee4			;	endif 
1ee4			; 
1ee4			;	if FORTH_ENABLE_FREE 
1ee4			;	call free 
1ee4			;	endif 
1ee4			; 
1ee4			;	if DEBUG_FORTH_WORDS 
1ee4			;		DMARK "EX6" 
1ee4			;		CALLMONITOR 
1ee4			;	endif 
1ee4			; 
1ee4			;	pop bc 
1ee4			;	pop de 
1ee4			;	pop hl 
1ee4			;;	FORTH_RSP_POP	  
1ee4			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
1ee4			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
1ee4			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
1ee4			; 
1ee4			;	if DEBUG_FORTH_WORDS 
1ee4			;		DMARK "EX7" 
1ee4			;		CALLMONITOR 
1ee4			;	endif 
1ee4			;	NEXTW 
1ee4			 
1ee4			.STKEXEC: 
1ee4				CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
1ee4 3f				db WORD_SYS_CORE+43             
1ee5 2c 20			dw .ZDUP            
1ee7 08				db 7 + 1 
1ee8 .. 00			db "STKEXEC",0              
1ef0				endm 
# End of macro CWHEAD
1ef0			; | STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code | TO TEST 
1ef0			 
1ef0			 
1ef0					if DEBUG_FORTH_WORDS_KEY 
1ef0						DMARK "STX" 
1ef0 f5				push af  
1ef1 3a 05 1f			ld a, (.dmark)  
1ef4 32 7a ee			ld (debug_mark),a  
1ef7 3a 06 1f			ld a, (.dmark+1)  
1efa 32 7b ee			ld (debug_mark+1),a  
1efd 3a 07 1f			ld a, (.dmark+2)  
1f00 32 7c ee			ld (debug_mark+2),a  
1f03 18 03			jr .pastdmark  
1f05 ..			.dmark: db "STX"  
1f08 f1			.pastdmark: pop af  
1f09			endm  
# End of macro DMARK
1f09						CALLMONITOR 
1f09 cd bb 13			call break_point_state  
1f0c				endm  
# End of macro CALLMONITOR
1f0c					endif 
1f0c			 
1f0c				FORTH_DSP_VALUEHL 
1f0c cd 3f 1b			call macro_dsp_valuehl 
1f0f				endm 
# End of macro FORTH_DSP_VALUEHL
1f0f			 
1f0f 22 63 eb			ld (store_tmp1), hl    ; count 
1f12			 
1f12				FORTH_DSP_POP 
1f12 cd f7 1b			call macro_forth_dsp_pop 
1f15				endm 
# End of macro FORTH_DSP_POP
1f15			.stkexec1: 
1f15 2a 63 eb			ld hl, (store_tmp1)   ; count 
1f18 3e 00			ld a, 0 
1f1a bd				cp l 
1f1b c8				ret z 
1f1c			 
1f1c 2b				dec hl 
1f1d 22 63 eb			ld (store_tmp1), hl    ; count 
1f20				 
1f20				FORTH_DSP_VALUEHL 
1f20 cd 3f 1b			call macro_dsp_valuehl 
1f23				endm 
# End of macro FORTH_DSP_VALUEHL
1f23 e5				push hl 
1f24				 
1f24					if DEBUG_FORTH_WORDS 
1f24						DMARK "EXp" 
1f24 f5				push af  
1f25 3a 39 1f			ld a, (.dmark)  
1f28 32 7a ee			ld (debug_mark),a  
1f2b 3a 3a 1f			ld a, (.dmark+1)  
1f2e 32 7b ee			ld (debug_mark+1),a  
1f31 3a 3b 1f			ld a, (.dmark+2)  
1f34 32 7c ee			ld (debug_mark+2),a  
1f37 18 03			jr .pastdmark  
1f39 ..			.dmark: db "EXp"  
1f3c f1			.pastdmark: pop af  
1f3d			endm  
# End of macro DMARK
1f3d						CALLMONITOR 
1f3d cd bb 13			call break_point_state  
1f40				endm  
# End of macro CALLMONITOR
1f40					endif 
1f40				FORTH_DSP_POP 
1f40 cd f7 1b			call macro_forth_dsp_pop 
1f43				endm 
# End of macro FORTH_DSP_POP
1f43			 
1f43 cd d2 0f			call strlenz 
1f46 23				inc hl   ; include zero term to copy 
1f47 23				inc hl   ; include zero term to copy 
1f48 23				inc hl   ; include zero term to copy 
1f49 06 00			ld b,0 
1f4b 4d				ld c,l 
1f4c e1				pop hl 
1f4d 11 5f e4			ld de, execscratch 
1f50					if DEBUG_FORTH_WORDS 
1f50						DMARK "EX3" 
1f50 f5				push af  
1f51 3a 65 1f			ld a, (.dmark)  
1f54 32 7a ee			ld (debug_mark),a  
1f57 3a 66 1f			ld a, (.dmark+1)  
1f5a 32 7b ee			ld (debug_mark+1),a  
1f5d 3a 67 1f			ld a, (.dmark+2)  
1f60 32 7c ee			ld (debug_mark+2),a  
1f63 18 03			jr .pastdmark  
1f65 ..			.dmark: db "EX3"  
1f68 f1			.pastdmark: pop af  
1f69			endm  
# End of macro DMARK
1f69						CALLMONITOR 
1f69 cd bb 13			call break_point_state  
1f6c				endm  
# End of macro CALLMONITOR
1f6c					endif 
1f6c ed b0			ldir 
1f6e			 
1f6e			 
1f6e 21 5f e4			ld hl, execscratch 
1f71			 
1f71					if DEBUG_FORTH_WORDS 
1f71						DMARK "EXP" 
1f71 f5				push af  
1f72 3a 86 1f			ld a, (.dmark)  
1f75 32 7a ee			ld (debug_mark),a  
1f78 3a 87 1f			ld a, (.dmark+1)  
1f7b 32 7b ee			ld (debug_mark+1),a  
1f7e 3a 88 1f			ld a, (.dmark+2)  
1f81 32 7c ee			ld (debug_mark+2),a  
1f84 18 03			jr .pastdmark  
1f86 ..			.dmark: db "EXP"  
1f89 f1			.pastdmark: pop af  
1f8a			endm  
# End of macro DMARK
1f8a						CALLMONITOR 
1f8a cd bb 13			call break_point_state  
1f8d				endm  
# End of macro CALLMONITOR
1f8d					endif 
1f8d			 
1f8d cd ff 1c			call forthparse 
1f90 21 5f e4			ld hl, execscratch 
1f93					if DEBUG_FORTH_WORDS 
1f93						DMARK "EXx" 
1f93 f5				push af  
1f94 3a a8 1f			ld a, (.dmark)  
1f97 32 7a ee			ld (debug_mark),a  
1f9a 3a a9 1f			ld a, (.dmark+1)  
1f9d 32 7b ee			ld (debug_mark+1),a  
1fa0 3a aa 1f			ld a, (.dmark+2)  
1fa3 32 7c ee			ld (debug_mark+2),a  
1fa6 18 03			jr .pastdmark  
1fa8 ..			.dmark: db "EXx"  
1fab f1			.pastdmark: pop af  
1fac			endm  
# End of macro DMARK
1fac						CALLMONITOR 
1fac cd bb 13			call break_point_state  
1faf				endm  
# End of macro CALLMONITOR
1faf					endif 
1faf cd 3f 1d			call forthexec 
1fb2			 
1fb2 c3 15 1f			jp .stkexec1 
1fb5			 
1fb5 c9				ret 
1fb6			 
1fb6			 
1fb6			.DUP: 
1fb6				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
1fb6 17				db WORD_SYS_CORE+OPCODE_DUP             
1fb7 2c 20			dw .ZDUP            
1fb9 04				db 3 + 1 
1fba .. 00			db "DUP",0              
1fbe				endm 
# End of macro CWHEAD
1fbe			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
1fbe			 
1fbe					if DEBUG_FORTH_WORDS_KEY 
1fbe						DMARK "DUP" 
1fbe f5				push af  
1fbf 3a d3 1f			ld a, (.dmark)  
1fc2 32 7a ee			ld (debug_mark),a  
1fc5 3a d4 1f			ld a, (.dmark+1)  
1fc8 32 7b ee			ld (debug_mark+1),a  
1fcb 3a d5 1f			ld a, (.dmark+2)  
1fce 32 7c ee			ld (debug_mark+2),a  
1fd1 18 03			jr .pastdmark  
1fd3 ..			.dmark: db "DUP"  
1fd6 f1			.pastdmark: pop af  
1fd7			endm  
# End of macro DMARK
1fd7						CALLMONITOR 
1fd7 cd bb 13			call break_point_state  
1fda				endm  
# End of macro CALLMONITOR
1fda					endif 
1fda			 
1fda					FORTH_DSP 
1fda cd 05 1b			call macro_forth_dsp 
1fdd				endm 
# End of macro FORTH_DSP
1fdd			 
1fdd 7e					ld a, (HL) 
1fde fe 01				cp DS_TYPE_STR 
1fe0 20 25				jr nz, .dupinum 
1fe2			 
1fe2					; push another string 
1fe2			 
1fe2					FORTH_DSP_VALUEHL     		 
1fe2 cd 3f 1b			call macro_dsp_valuehl 
1fe5				endm 
# End of macro FORTH_DSP_VALUEHL
1fe5			 
1fe5				if DEBUG_FORTH_WORDS 
1fe5					DMARK "DUs" 
1fe5 f5				push af  
1fe6 3a fa 1f			ld a, (.dmark)  
1fe9 32 7a ee			ld (debug_mark),a  
1fec 3a fb 1f			ld a, (.dmark+1)  
1fef 32 7b ee			ld (debug_mark+1),a  
1ff2 3a fc 1f			ld a, (.dmark+2)  
1ff5 32 7c ee			ld (debug_mark+2),a  
1ff8 18 03			jr .pastdmark  
1ffa ..			.dmark: db "DUs"  
1ffd f1			.pastdmark: pop af  
1ffe			endm  
# End of macro DMARK
1ffe					CALLMONITOR 
1ffe cd bb 13			call break_point_state  
2001				endm  
# End of macro CALLMONITOR
2001				endif 
2001 cd b6 19				call forth_push_str 
2004			 
2004					NEXTW 
2004 c3 b1 1c			jp macro_next 
2007				endm 
# End of macro NEXTW
2007			 
2007			 
2007			.dupinum: 
2007					 
2007			 
2007			 
2007					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2007 cd 3f 1b			call macro_dsp_valuehl 
200a				endm 
# End of macro FORTH_DSP_VALUEHL
200a			 
200a				; TODO add floating point number detection 
200a			 
200a				if DEBUG_FORTH_WORDS 
200a					DMARK "DUi" 
200a f5				push af  
200b 3a 1f 20			ld a, (.dmark)  
200e 32 7a ee			ld (debug_mark),a  
2011 3a 20 20			ld a, (.dmark+1)  
2014 32 7b ee			ld (debug_mark+1),a  
2017 3a 21 20			ld a, (.dmark+2)  
201a 32 7c ee			ld (debug_mark+2),a  
201d 18 03			jr .pastdmark  
201f ..			.dmark: db "DUi"  
2022 f1			.pastdmark: pop af  
2023			endm  
# End of macro DMARK
2023					CALLMONITOR 
2023 cd bb 13			call break_point_state  
2026				endm  
# End of macro CALLMONITOR
2026				endif 
2026			 
2026 cd 48 19				call forth_push_numhl 
2029					NEXTW 
2029 c3 b1 1c			jp macro_next 
202c				endm 
# End of macro NEXTW
202c			.ZDUP: 
202c				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
202c 99				db WORD_SYS_CORE+OPCODE_ZDUP             
202d 64 20			dw .SWAP            
202f 05				db 4 + 1 
2030 .. 00			db "?DUP",0              
2035				endm 
# End of macro CWHEAD
2035			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
2035			 
2035					if DEBUG_FORTH_WORDS_KEY 
2035						DMARK "qDU" 
2035 f5				push af  
2036 3a 4a 20			ld a, (.dmark)  
2039 32 7a ee			ld (debug_mark),a  
203c 3a 4b 20			ld a, (.dmark+1)  
203f 32 7b ee			ld (debug_mark+1),a  
2042 3a 4c 20			ld a, (.dmark+2)  
2045 32 7c ee			ld (debug_mark+2),a  
2048 18 03			jr .pastdmark  
204a ..			.dmark: db "qDU"  
204d f1			.pastdmark: pop af  
204e			endm  
# End of macro DMARK
204e						CALLMONITOR 
204e cd bb 13			call break_point_state  
2051				endm  
# End of macro CALLMONITOR
2051					endif 
2051					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2051 cd 3f 1b			call macro_dsp_valuehl 
2054				endm 
# End of macro FORTH_DSP_VALUEHL
2054			 
2054 e5					push hl 
2055			 
2055					; is it a zero? 
2055			 
2055 3e 00				ld a, 0 
2057 84					add h 
2058 85					add l 
2059			 
2059 e1					pop hl 
205a			 
205a fe 00				cp 0 
205c 28 03				jr z, .dup2orig 
205e			 
205e			 
205e cd 48 19				call forth_push_numhl 
2061			 
2061			 
2061				; TODO add floating point number detection 
2061			 
2061			.dup2orig: 
2061			 
2061					NEXTW 
2061 c3 b1 1c			jp macro_next 
2064				endm 
# End of macro NEXTW
2064			.SWAP: 
2064				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
2064 18				db WORD_SYS_CORE+OPCODE_SWAP             
2065 a3 20			dw .COLN            
2067 05				db 4 + 1 
2068 .. 00			db "SWAP",0              
206d				endm 
# End of macro CWHEAD
206d			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
206d					if DEBUG_FORTH_WORDS_KEY 
206d						DMARK "SWP" 
206d f5				push af  
206e 3a 82 20			ld a, (.dmark)  
2071 32 7a ee			ld (debug_mark),a  
2074 3a 83 20			ld a, (.dmark+1)  
2077 32 7b ee			ld (debug_mark+1),a  
207a 3a 84 20			ld a, (.dmark+2)  
207d 32 7c ee			ld (debug_mark+2),a  
2080 18 03			jr .pastdmark  
2082 ..			.dmark: db "SWP"  
2085 f1			.pastdmark: pop af  
2086			endm  
# End of macro DMARK
2086						CALLMONITOR 
2086 cd bb 13			call break_point_state  
2089				endm  
# End of macro CALLMONITOR
2089					endif 
2089			 
2089					FORTH_DSP_VALUEHL 
2089 cd 3f 1b			call macro_dsp_valuehl 
208c				endm 
# End of macro FORTH_DSP_VALUEHL
208c e5					push hl     ; w2 
208d			 
208d					FORTH_DSP_POP 
208d cd f7 1b			call macro_forth_dsp_pop 
2090				endm 
# End of macro FORTH_DSP_POP
2090			 
2090					FORTH_DSP_VALUEHL 
2090 cd 3f 1b			call macro_dsp_valuehl 
2093				endm 
# End of macro FORTH_DSP_VALUEHL
2093			 
2093					FORTH_DSP_POP 
2093 cd f7 1b			call macro_forth_dsp_pop 
2096				endm 
# End of macro FORTH_DSP_POP
2096			 
2096 d1					pop de     ; w2	, hl = w1 
2097			 
2097 eb					ex de, hl 
2098 d5					push de 
2099			 
2099 cd 48 19				call forth_push_numhl 
209c			 
209c e1					pop hl 
209d			 
209d cd 48 19				call forth_push_numhl 
20a0					 
20a0			 
20a0					NEXTW 
20a0 c3 b1 1c			jp macro_next 
20a3				endm 
# End of macro NEXTW
20a3			.COLN: 
20a3				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
20a3 19				db WORD_SYS_CORE+OPCODE_COLN             
20a4 2f 22			dw .SCOLN            
20a6 02				db 1 + 1 
20a7 .. 00			db ":",0              
20a9				endm 
# End of macro CWHEAD
20a9			; | : ( -- )         Create new word | DONE 
20a9			 
20a9					if DEBUG_FORTH_WORDS_KEY 
20a9						DMARK "CLN" 
20a9 f5				push af  
20aa 3a be 20			ld a, (.dmark)  
20ad 32 7a ee			ld (debug_mark),a  
20b0 3a bf 20			ld a, (.dmark+1)  
20b3 32 7b ee			ld (debug_mark+1),a  
20b6 3a c0 20			ld a, (.dmark+2)  
20b9 32 7c ee			ld (debug_mark+2),a  
20bc 18 03			jr .pastdmark  
20be ..			.dmark: db "CLN"  
20c1 f1			.pastdmark: pop af  
20c2			endm  
# End of macro DMARK
20c2						CALLMONITOR 
20c2 cd bb 13			call break_point_state  
20c5				endm  
# End of macro CALLMONITOR
20c5					endif 
20c5				STACKFRAME OFF $8efe $989f 
20c5				if DEBUG_STACK_IMB 
20c5					if OFF 
20c5						exx 
20c5						ld de, $8efe 
20c5						ld a, d 
20c5						ld hl, curframe 
20c5						call hexout 
20c5						ld a, e 
20c5						ld hl, curframe+2 
20c5						call hexout 
20c5						ld hl, $8efe 
20c5						push hl 
20c5						ld hl, $989f 
20c5						push hl 
20c5						exx 
20c5					endif 
20c5				endif 
20c5			endm 
# End of macro STACKFRAME
20c5				; get parser buffer length  of new word 
20c5			 
20c5				 
20c5			 
20c5					; move tok past this to start of name defintition 
20c5					; TODO get word to define 
20c5					; TODO Move past word token 
20c5					; TODO get length of string up to the ';' 
20c5			 
20c5 2a 61 e6			ld hl, (os_tok_ptr) 
20c8 23				inc hl 
20c9 23				inc hl 
20ca			 
20ca 3e 3b			ld a, ';' 
20cc cd dd 0f			call strlent 
20cf			 
20cf 7d				ld a,l 
20d0 32 5c e3			ld (os_new_parse_len), a 
20d3			 
20d3			 
20d3			if DEBUG_FORTH_UWORD 
20d3 ed 5b 61 e6		ld de, (os_tok_ptr) 
20d7						DMARK ":01" 
20d7 f5				push af  
20d8 3a ec 20			ld a, (.dmark)  
20db 32 7a ee			ld (debug_mark),a  
20de 3a ed 20			ld a, (.dmark+1)  
20e1 32 7b ee			ld (debug_mark+1),a  
20e4 3a ee 20			ld a, (.dmark+2)  
20e7 32 7c ee			ld (debug_mark+2),a  
20ea 18 03			jr .pastdmark  
20ec ..			.dmark: db ":01"  
20ef f1			.pastdmark: pop af  
20f0			endm  
# End of macro DMARK
20f0				CALLMONITOR 
20f0 cd bb 13			call break_point_state  
20f3				endm  
# End of macro CALLMONITOR
20f3			endif 
20f3			 
20f3			; 
20f3			;  new word memory layout: 
20f3			;  
20f3			;    : adg 6666 ;  
20f3			; 
20f3			;    db   1     ; user defined word  
20f3 23				inc hl    
20f4			;    dw   sysdict 
20f4 23				inc hl 
20f5 23				inc hl 
20f6			;    db <word len>+1 (for null) 
20f6 23				inc hl 
20f7			;    db .... <word> 
20f7			; 
20f7			 
20f7 23				inc hl    ; some extras for the word preamble before the above 
20f8 23				inc hl 
20f9 23				inc hl 
20fa 23				inc hl 
20fb 23				inc hl 
20fc 23				inc hl 
20fd 23				inc hl  
20fe 23				inc hl 
20ff 23				inc hl 
2100 23				inc hl 
2101 23				inc hl 
2102 23				inc hl 
2103 23				inc hl 
2104 23				inc hl     ; TODO how many do we really need?     maybe only 6 
2105			;       exec word buffer 
2105			;	<ptr word>   
2105 23				inc hl 
2106 23				inc hl 
2107			;       <word list><null term> 7F final term 
2107			 
2107			 
2107			if DEBUG_FORTH_UWORD 
2107						DMARK ":02" 
2107 f5				push af  
2108 3a 1c 21			ld a, (.dmark)  
210b 32 7a ee			ld (debug_mark),a  
210e 3a 1d 21			ld a, (.dmark+1)  
2111 32 7b ee			ld (debug_mark+1),a  
2114 3a 1e 21			ld a, (.dmark+2)  
2117 32 7c ee			ld (debug_mark+2),a  
211a 18 03			jr .pastdmark  
211c ..			.dmark: db ":02"  
211f f1			.pastdmark: pop af  
2120			endm  
# End of macro DMARK
2120				CALLMONITOR 
2120 cd bb 13			call break_point_state  
2123				endm  
# End of macro CALLMONITOR
2123			endif 
2123			 
2123				 
2123					; malloc the size 
2123			 
2123 cd 3b 10				call malloc 
2126 22 5e e3				ld (os_new_malloc), hl     ; save malloc start 
2129			 
2129			;    db   1     ; user defined word  
2129 3e 01				ld a, WORD_SYS_UWORD  
212b 77					ld (hl), a 
212c				 
212c 23				inc hl    
212d			;    dw   sysdict 
212d 11 09 1e			ld de, sysdict       ; continue on with the scan to the system dict 
2130 73				ld (hl), e 
2131 23				inc hl 
2132 72				ld (hl), d 
2133 23				inc hl 
2134			 
2134			 
2134			;    Setup dict word 
2134			 
2134 23				inc hl 
2135 22 58 e3			ld (os_new_work_ptr), hl     ; save start of dict word  
2138			 
2138				; 1. get length of dict word 
2138			 
2138			 
2138 2a 61 e6			ld hl, (os_tok_ptr) 
213b 23				inc hl 
213c 23				inc hl    ; position to start of dict word 
213d 3e 00			ld a, 0 
213f cd dd 0f			call strlent 
2142			 
2142			 
2142 23				inc hl    ; to include null??? 
2143			 
2143				; write length of dict word 
2143			 
2143 ed 5b 58 e3		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2147 1b				dec de 
2148 eb				ex de, hl 
2149 73				ld (hl), e 
214a eb				ex de, hl 
214b			 
214b				 
214b			 
214b				; copy  
214b 4d				ld c, l 
214c 06 00			ld b, 0 
214e ed 5b 58 e3		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2152 2a 61 e6			ld hl, (os_tok_ptr) 
2155 23				inc hl 
2156 23				inc hl    ; position to start of dict word 
2157				 
2157			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
2157				 
2157				; TODO need to convert word to upper case 
2157			 
2157			ucasetok:	 
2157 7e				ld a,(hl) 
2158 cd c9 0f			call toUpper 
215b 77				ld (hl),a 
215c ed a0			ldi 
215e f2 57 21		 	jp p, ucasetok 
2161			 
2161			 
2161			 
2161				; de now points to start of where the word body code should be placed 
2161 ed 53 58 e3		ld (os_new_work_ptr), de 
2165				; hl now points to the words to throw at forthexec which needs to be copied 
2165 22 56 e3			ld (os_new_src_ptr), hl 
2168			 
2168				; TODO add 'call to forthexec' 
2168			 
2168			if DEBUG_FORTH_UWORD 
2168 c5				push bc 
2169 ed 4b 5e e3		ld bc, (os_new_malloc) 
216d						DMARK ":0x" 
216d f5				push af  
216e 3a 82 21			ld a, (.dmark)  
2171 32 7a ee			ld (debug_mark),a  
2174 3a 83 21			ld a, (.dmark+1)  
2177 32 7b ee			ld (debug_mark+1),a  
217a 3a 84 21			ld a, (.dmark+2)  
217d 32 7c ee			ld (debug_mark+2),a  
2180 18 03			jr .pastdmark  
2182 ..			.dmark: db ":0x"  
2185 f1			.pastdmark: pop af  
2186			endm  
# End of macro DMARK
2186				CALLMONITOR 
2186 cd bb 13			call break_point_state  
2189				endm  
# End of macro CALLMONITOR
2189 c1				pop bc 
218a			endif 
218a			 
218a			 
218a				; create word preamble which should be: 
218a			 
218a			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
218a			 
218a				;    ld hl, <word code> 
218a				;    jp user_exec 
218a			        ;    <word code bytes> 
218a			 
218a			 
218a			;	inc de     ; TODO ??? or are we already past the word's null 
218a eb				ex de, hl 
218b			 
218b 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
218d			 
218d 23				inc hl 
218e 22 52 e3			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
2191 23				inc hl 
2192			 
2192 23				inc hl 
2193 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
2195			 
2195 01 1e 45			ld bc, user_exec 
2198 23				inc hl 
2199 71				ld (hl), c     ; poke address of user_exec 
219a 23				inc hl 
219b 70				ld (hl), b     
219c			 ; 
219c			;	inc hl 
219c			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
219c			; 
219c			; 
219c			;	ld bc, macro_forth_rsp_next 
219c			;	inc hl 
219c			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
219c			;	inc hl 
219c			;	ld (hl), b     
219c			 ; 
219c			;	inc hl 
219c			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
219c			; 
219c			; 
219c			;	inc hl 
219c			;	ld bc, forthexec 
219c			;	ld (hl), c     ; poke address of forthexec 
219c			;	inc hl 
219c			;	ld (hl), b      
219c			; 
219c			;	inc hl 
219c			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
219c			; 
219c			;	ld bc, user_dict_next 
219c			;	inc hl 
219c			;	ld (hl), c     ; poke address of forthexec 
219c			;	inc hl 
219c			;	ld (hl), b      
219c			 
219c				; hl is now where we need to copy the word byte data to save this 
219c			 
219c 23				inc hl 
219d 22 54 e3			ld (os_new_exec), hl 
21a0				 
21a0				; copy definition 
21a0			 
21a0 eb				ex de, hl 
21a1			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
21a1			;	inc de    ; skip the PC for this parse 
21a1 3a 5c e3			ld a, (os_new_parse_len) 
21a4 4f				ld c, a 
21a5 06 00			ld b, 0 
21a7 ed b0			ldir		 ; copy defintion 
21a9			 
21a9			 
21a9				; poke the address of where the new word bytes live for forthexec 
21a9			 
21a9 2a 52 e3			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
21ac			 
21ac ed 5b 54 e3		ld de, (os_new_exec)      
21b0				 
21b0 73				ld (hl), e 
21b1 23				inc hl 
21b2 72				ld (hl), d 
21b3			 
21b3					; TODO copy last user dict word next link to this word 
21b3					; TODO update last user dict word to point to this word 
21b3			; 
21b3			; hl f923 de 812a ; bc 811a 
21b3			 
21b3			if DEBUG_FORTH_UWORD 
21b3 c5				push bc 
21b4 ed 4b 5e e3		ld bc, (os_new_malloc) 
21b8						DMARK ":0A" 
21b8 f5				push af  
21b9 3a cd 21			ld a, (.dmark)  
21bc 32 7a ee			ld (debug_mark),a  
21bf 3a ce 21			ld a, (.dmark+1)  
21c2 32 7b ee			ld (debug_mark+1),a  
21c5 3a cf 21			ld a, (.dmark+2)  
21c8 32 7c ee			ld (debug_mark+2),a  
21cb 18 03			jr .pastdmark  
21cd ..			.dmark: db ":0A"  
21d0 f1			.pastdmark: pop af  
21d1			endm  
# End of macro DMARK
21d1				CALLMONITOR 
21d1 cd bb 13			call break_point_state  
21d4				endm  
# End of macro CALLMONITOR
21d4 c1				pop bc 
21d5			endif 
21d5			if DEBUG_FORTH_UWORD 
21d5 c5				push bc 
21d6 ed 4b 5e e3		ld bc, (os_new_malloc) 
21da 03				inc bc 
21db 03				inc bc 
21dc 03				inc bc 
21dd 03				inc bc 
21de 03				inc bc 
21df 03				inc bc 
21e0 03				inc bc 
21e1 03				inc bc 
21e2			 
21e2						DMARK ":0B" 
21e2 f5				push af  
21e3 3a f7 21			ld a, (.dmark)  
21e6 32 7a ee			ld (debug_mark),a  
21e9 3a f8 21			ld a, (.dmark+1)  
21ec 32 7b ee			ld (debug_mark+1),a  
21ef 3a f9 21			ld a, (.dmark+2)  
21f2 32 7c ee			ld (debug_mark+2),a  
21f5 18 03			jr .pastdmark  
21f7 ..			.dmark: db ":0B"  
21fa f1			.pastdmark: pop af  
21fb			endm  
# End of macro DMARK
21fb				CALLMONITOR 
21fb cd bb 13			call break_point_state  
21fe				endm  
# End of macro CALLMONITOR
21fe c1				pop bc 
21ff			endif 
21ff			 
21ff			; update word dict linked list for new word 
21ff			 
21ff			 
21ff 2a 5d e6		ld hl, (os_last_new_uword)		; get the start of the last added uword 
2202 23			inc hl     ; move to next work linked list ptr 
2203			 
2203 ed 5b 5e e3	ld de, (os_new_malloc)		 ; new next word 
2207 73			ld (hl), e 
2208 23			inc hl 
2209 72			ld (hl), d 
220a			 
220a			if DEBUG_FORTH_UWORD 
220a ed 4b 5d e6		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
220e			endif 
220e			 
220e ed 53 5d e6	ld (os_last_new_uword), de      ; update last new uword ptr 
2212			 
2212			 
2212			if DEBUG_FORTH_UWORD 
2212						DMARK ":0+" 
2212 f5				push af  
2213 3a 27 22			ld a, (.dmark)  
2216 32 7a ee			ld (debug_mark),a  
2219 3a 28 22			ld a, (.dmark+1)  
221c 32 7b ee			ld (debug_mark+1),a  
221f 3a 29 22			ld a, (.dmark+2)  
2222 32 7c ee			ld (debug_mark+2),a  
2225 18 03			jr .pastdmark  
2227 ..			.dmark: db ":0+"  
222a f1			.pastdmark: pop af  
222b			endm  
# End of macro DMARK
222b				CALLMONITOR 
222b cd bb 13			call break_point_state  
222e				endm  
# End of macro CALLMONITOR
222e			endif 
222e			 
222e				STACKFRAMECHK OFF $8efe $989f 
222e				if DEBUG_STACK_IMB 
222e					if OFF 
222e						exx 
222e						ld hl, $989f 
222e						pop de   ; $989f 
222e						call cmp16 
222e						jr nz, .spnosame 
222e						ld hl, $8efe 
222e						pop de   ; $8efe 
222e						call cmp16 
222e						jr z, .spfrsame 
222e						.spnosame: call showsperror 
222e						.spfrsame: nop 
222e						exx 
222e					endif 
222e				endif 
222e			endm 
# End of macro STACKFRAMECHK
222e			 
222e c9			ret    ; dont process any remaining parser tokens as they form new word 
222f			 
222f			 
222f			 
222f			 
222f			;		NEXT 
222f			.SCOLN: 
222f			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
222f 06				db OPCODE_SCOLN 
2230 7b 22			dw .DROP 
2232 02				db 2 
2233 .. 00			db ";",0           
2235			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
2235					if DEBUG_FORTH_WORDS_KEY 
2235						DMARK "SCN" 
2235 f5				push af  
2236 3a 4a 22			ld a, (.dmark)  
2239 32 7a ee			ld (debug_mark),a  
223c 3a 4b 22			ld a, (.dmark+1)  
223f 32 7b ee			ld (debug_mark+1),a  
2242 3a 4c 22			ld a, (.dmark+2)  
2245 32 7c ee			ld (debug_mark+2),a  
2248 18 03			jr .pastdmark  
224a ..			.dmark: db "SCN"  
224d f1			.pastdmark: pop af  
224e			endm  
# End of macro DMARK
224e						CALLMONITOR 
224e cd bb 13			call break_point_state  
2251				endm  
# End of macro CALLMONITOR
2251					endif 
2251					FORTH_RSP_TOS 
2251 cd 06 19			call macro_forth_rsp_tos 
2254				endm 
# End of macro FORTH_RSP_TOS
2254 e5					push hl 
2255					FORTH_RSP_POP 
2255 cd 10 19			call macro_forth_rsp_pop 
2258				endm 
# End of macro FORTH_RSP_POP
2258 e1					pop hl 
2259			;		ex de,hl 
2259 22 61 e6				ld (os_tok_ptr),hl 
225c			 
225c			if DEBUG_FORTH_UWORD 
225c						DMARK "SCL" 
225c f5				push af  
225d 3a 71 22			ld a, (.dmark)  
2260 32 7a ee			ld (debug_mark),a  
2263 3a 72 22			ld a, (.dmark+1)  
2266 32 7b ee			ld (debug_mark+1),a  
2269 3a 73 22			ld a, (.dmark+2)  
226c 32 7c ee			ld (debug_mark+2),a  
226f 18 03			jr .pastdmark  
2271 ..			.dmark: db "SCL"  
2274 f1			.pastdmark: pop af  
2275			endm  
# End of macro DMARK
2275				CALLMONITOR 
2275 cd bb 13			call break_point_state  
2278				endm  
# End of macro CALLMONITOR
2278			endif 
2278					NEXTW 
2278 c3 b1 1c			jp macro_next 
227b				endm 
# End of macro NEXTW
227b			 
227b			.DROP: 
227b				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
227b 1b				db WORD_SYS_CORE+OPCODE_DROP             
227c a6 22			dw .DUP2            
227e 05				db 4 + 1 
227f .. 00			db "DROP",0              
2284				endm 
# End of macro CWHEAD
2284			; | DROP ( w -- )   drop the TOS item   | DONE 
2284					if DEBUG_FORTH_WORDS_KEY 
2284						DMARK "DRP" 
2284 f5				push af  
2285 3a 99 22			ld a, (.dmark)  
2288 32 7a ee			ld (debug_mark),a  
228b 3a 9a 22			ld a, (.dmark+1)  
228e 32 7b ee			ld (debug_mark+1),a  
2291 3a 9b 22			ld a, (.dmark+2)  
2294 32 7c ee			ld (debug_mark+2),a  
2297 18 03			jr .pastdmark  
2299 ..			.dmark: db "DRP"  
229c f1			.pastdmark: pop af  
229d			endm  
# End of macro DMARK
229d						CALLMONITOR 
229d cd bb 13			call break_point_state  
22a0				endm  
# End of macro CALLMONITOR
22a0					endif 
22a0					FORTH_DSP_POP 
22a0 cd f7 1b			call macro_forth_dsp_pop 
22a3				endm 
# End of macro FORTH_DSP_POP
22a3					NEXTW 
22a3 c3 b1 1c			jp macro_next 
22a6				endm 
# End of macro NEXTW
22a6			.DUP2: 
22a6				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
22a6 1c				db WORD_SYS_CORE+OPCODE_DUP2             
22a7 eb 22			dw .DROP2            
22a9 05				db 4 + 1 
22aa .. 00			db "2DUP",0              
22af				endm 
# End of macro CWHEAD
22af			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
22af					if DEBUG_FORTH_WORDS_KEY 
22af						DMARK "2DU" 
22af f5				push af  
22b0 3a c4 22			ld a, (.dmark)  
22b3 32 7a ee			ld (debug_mark),a  
22b6 3a c5 22			ld a, (.dmark+1)  
22b9 32 7b ee			ld (debug_mark+1),a  
22bc 3a c6 22			ld a, (.dmark+2)  
22bf 32 7c ee			ld (debug_mark+2),a  
22c2 18 03			jr .pastdmark  
22c4 ..			.dmark: db "2DU"  
22c7 f1			.pastdmark: pop af  
22c8			endm  
# End of macro DMARK
22c8						CALLMONITOR 
22c8 cd bb 13			call break_point_state  
22cb				endm  
# End of macro CALLMONITOR
22cb					endif 
22cb					FORTH_DSP_VALUEHL 
22cb cd 3f 1b			call macro_dsp_valuehl 
22ce				endm 
# End of macro FORTH_DSP_VALUEHL
22ce e5					push hl      ; 2 
22cf			 
22cf					FORTH_DSP_POP 
22cf cd f7 1b			call macro_forth_dsp_pop 
22d2				endm 
# End of macro FORTH_DSP_POP
22d2					 
22d2					FORTH_DSP_VALUEHL 
22d2 cd 3f 1b			call macro_dsp_valuehl 
22d5				endm 
# End of macro FORTH_DSP_VALUEHL
22d5			;		push hl      ; 1 
22d5			 
22d5					FORTH_DSP_POP 
22d5 cd f7 1b			call macro_forth_dsp_pop 
22d8				endm 
# End of macro FORTH_DSP_POP
22d8			 
22d8			;		pop hl       ; 1 
22d8 d1					pop de       ; 2 
22d9			 
22d9 cd 48 19				call forth_push_numhl 
22dc eb					ex de, hl 
22dd cd 48 19				call forth_push_numhl 
22e0			 
22e0					 
22e0 eb					ex de, hl 
22e1			 
22e1 cd 48 19				call forth_push_numhl 
22e4 eb					ex de, hl 
22e5 cd 48 19				call forth_push_numhl 
22e8			 
22e8			 
22e8					NEXTW 
22e8 c3 b1 1c			jp macro_next 
22eb				endm 
# End of macro NEXTW
22eb			.DROP2: 
22eb				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
22eb 1d				db WORD_SYS_CORE+OPCODE_DROP2             
22ec 1a 23			dw .SWAP2            
22ee 06				db 5 + 1 
22ef .. 00			db "2DROP",0              
22f5				endm 
# End of macro CWHEAD
22f5			; | 2DROP ( w w -- )    Double drop | DONE 
22f5					if DEBUG_FORTH_WORDS_KEY 
22f5						DMARK "2DR" 
22f5 f5				push af  
22f6 3a 0a 23			ld a, (.dmark)  
22f9 32 7a ee			ld (debug_mark),a  
22fc 3a 0b 23			ld a, (.dmark+1)  
22ff 32 7b ee			ld (debug_mark+1),a  
2302 3a 0c 23			ld a, (.dmark+2)  
2305 32 7c ee			ld (debug_mark+2),a  
2308 18 03			jr .pastdmark  
230a ..			.dmark: db "2DR"  
230d f1			.pastdmark: pop af  
230e			endm  
# End of macro DMARK
230e						CALLMONITOR 
230e cd bb 13			call break_point_state  
2311				endm  
# End of macro CALLMONITOR
2311					endif 
2311					FORTH_DSP_POP 
2311 cd f7 1b			call macro_forth_dsp_pop 
2314				endm 
# End of macro FORTH_DSP_POP
2314					FORTH_DSP_POP 
2314 cd f7 1b			call macro_forth_dsp_pop 
2317				endm 
# End of macro FORTH_DSP_POP
2317					NEXTW 
2317 c3 b1 1c			jp macro_next 
231a				endm 
# End of macro NEXTW
231a			.SWAP2: 
231a				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
231a 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
231b 43 23			dw .AT            
231d 06				db 5 + 1 
231e .. 00			db "2SWAP",0              
2324				endm 
# End of macro CWHEAD
2324			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
2324					if DEBUG_FORTH_WORDS_KEY 
2324						DMARK "2SW" 
2324 f5				push af  
2325 3a 39 23			ld a, (.dmark)  
2328 32 7a ee			ld (debug_mark),a  
232b 3a 3a 23			ld a, (.dmark+1)  
232e 32 7b ee			ld (debug_mark+1),a  
2331 3a 3b 23			ld a, (.dmark+2)  
2334 32 7c ee			ld (debug_mark+2),a  
2337 18 03			jr .pastdmark  
2339 ..			.dmark: db "2SW"  
233c f1			.pastdmark: pop af  
233d			endm  
# End of macro DMARK
233d						CALLMONITOR 
233d cd bb 13			call break_point_state  
2340				endm  
# End of macro CALLMONITOR
2340					endif 
2340					NEXTW 
2340 c3 b1 1c			jp macro_next 
2343				endm 
# End of macro NEXTW
2343			.AT: 
2343				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
2343 1f				db WORD_SYS_CORE+OPCODE_AT             
2344 75 23			dw .CAT            
2346 02				db 1 + 1 
2347 .. 00			db "@",0              
2349				endm 
# End of macro CWHEAD
2349			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
2349			 
2349					if DEBUG_FORTH_WORDS_KEY 
2349						DMARK "AT." 
2349 f5				push af  
234a 3a 5e 23			ld a, (.dmark)  
234d 32 7a ee			ld (debug_mark),a  
2350 3a 5f 23			ld a, (.dmark+1)  
2353 32 7b ee			ld (debug_mark+1),a  
2356 3a 60 23			ld a, (.dmark+2)  
2359 32 7c ee			ld (debug_mark+2),a  
235c 18 03			jr .pastdmark  
235e ..			.dmark: db "AT."  
2361 f1			.pastdmark: pop af  
2362			endm  
# End of macro DMARK
2362						CALLMONITOR 
2362 cd bb 13			call break_point_state  
2365				endm  
# End of macro CALLMONITOR
2365					endif 
2365			.getbyteat:	 
2365					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2365 cd 3f 1b			call macro_dsp_valuehl 
2368				endm 
# End of macro FORTH_DSP_VALUEHL
2368					 
2368			;		push hl 
2368				 
2368					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2368 cd f7 1b			call macro_forth_dsp_pop 
236b				endm 
# End of macro FORTH_DSP_POP
236b			 
236b			;		pop hl 
236b			 
236b 7e					ld a, (hl) 
236c			 
236c 6f					ld l, a 
236d 26 00				ld h, 0 
236f cd 48 19				call forth_push_numhl 
2372			 
2372					NEXTW 
2372 c3 b1 1c			jp macro_next 
2375				endm 
# End of macro NEXTW
2375			.CAT: 
2375				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
2375 20				db WORD_SYS_CORE+OPCODE_CAT             
2376 9e 23			dw .BANG            
2378 03				db 2 + 1 
2379 .. 00			db "C@",0              
237c				endm 
# End of macro CWHEAD
237c			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
237c					if DEBUG_FORTH_WORDS_KEY 
237c						DMARK "CAA" 
237c f5				push af  
237d 3a 91 23			ld a, (.dmark)  
2380 32 7a ee			ld (debug_mark),a  
2383 3a 92 23			ld a, (.dmark+1)  
2386 32 7b ee			ld (debug_mark+1),a  
2389 3a 93 23			ld a, (.dmark+2)  
238c 32 7c ee			ld (debug_mark+2),a  
238f 18 03			jr .pastdmark  
2391 ..			.dmark: db "CAA"  
2394 f1			.pastdmark: pop af  
2395			endm  
# End of macro DMARK
2395						CALLMONITOR 
2395 cd bb 13			call break_point_state  
2398				endm  
# End of macro CALLMONITOR
2398					endif 
2398 c3 65 23				jp .getbyteat 
239b					NEXTW 
239b c3 b1 1c			jp macro_next 
239e				endm 
# End of macro NEXTW
239e			.BANG: 
239e				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
239e 21				db WORD_SYS_CORE+OPCODE_BANG             
239f d4 23			dw .CBANG            
23a1 02				db 1 + 1 
23a2 .. 00			db "!",0              
23a4				endm 
# End of macro CWHEAD
23a4			; | ! ( x w -- ) Store x at address w      | DONE 
23a4					if DEBUG_FORTH_WORDS_KEY 
23a4						DMARK "BNG" 
23a4 f5				push af  
23a5 3a b9 23			ld a, (.dmark)  
23a8 32 7a ee			ld (debug_mark),a  
23ab 3a ba 23			ld a, (.dmark+1)  
23ae 32 7b ee			ld (debug_mark+1),a  
23b1 3a bb 23			ld a, (.dmark+2)  
23b4 32 7c ee			ld (debug_mark+2),a  
23b7 18 03			jr .pastdmark  
23b9 ..			.dmark: db "BNG"  
23bc f1			.pastdmark: pop af  
23bd			endm  
# End of macro DMARK
23bd						CALLMONITOR 
23bd cd bb 13			call break_point_state  
23c0				endm  
# End of macro CALLMONITOR
23c0					endif 
23c0			 
23c0			.storebyteat:		 
23c0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
23c0 cd 3f 1b			call macro_dsp_valuehl 
23c3				endm 
# End of macro FORTH_DSP_VALUEHL
23c3					 
23c3 e5					push hl 
23c4				 
23c4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
23c4 cd f7 1b			call macro_forth_dsp_pop 
23c7				endm 
# End of macro FORTH_DSP_POP
23c7			 
23c7					; get byte to poke 
23c7			 
23c7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
23c7 cd 3f 1b			call macro_dsp_valuehl 
23ca				endm 
# End of macro FORTH_DSP_VALUEHL
23ca e5					push hl 
23cb			 
23cb			 
23cb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
23cb cd f7 1b			call macro_forth_dsp_pop 
23ce				endm 
# End of macro FORTH_DSP_POP
23ce			 
23ce			 
23ce d1					pop de 
23cf e1					pop hl 
23d0			 
23d0 73					ld (hl),e 
23d1			 
23d1			 
23d1					NEXTW 
23d1 c3 b1 1c			jp macro_next 
23d4				endm 
# End of macro NEXTW
23d4			.CBANG: 
23d4				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
23d4 22				db WORD_SYS_CORE+OPCODE_CBANG             
23d5 fd 23			dw .SCALL            
23d7 03				db 2 + 1 
23d8 .. 00			db "C!",0              
23db				endm 
# End of macro CWHEAD
23db			; | C!  ( x w -- ) Store x at address w  | DONE 
23db					if DEBUG_FORTH_WORDS_KEY 
23db						DMARK "CBA" 
23db f5				push af  
23dc 3a f0 23			ld a, (.dmark)  
23df 32 7a ee			ld (debug_mark),a  
23e2 3a f1 23			ld a, (.dmark+1)  
23e5 32 7b ee			ld (debug_mark+1),a  
23e8 3a f2 23			ld a, (.dmark+2)  
23eb 32 7c ee			ld (debug_mark+2),a  
23ee 18 03			jr .pastdmark  
23f0 ..			.dmark: db "CBA"  
23f3 f1			.pastdmark: pop af  
23f4			endm  
# End of macro DMARK
23f4						CALLMONITOR 
23f4 cd bb 13			call break_point_state  
23f7				endm  
# End of macro CALLMONITOR
23f7					endif 
23f7 c3 c0 23				jp .storebyteat 
23fa					NEXTW 
23fa c3 b1 1c			jp macro_next 
23fd				endm 
# End of macro NEXTW
23fd			.SCALL: 
23fd				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
23fd 23				db WORD_SYS_CORE+OPCODE_SCALL             
23fe 31 24			dw .DEPTH            
2400 05				db 4 + 1 
2401 .. 00			db "CALL",0              
2406				endm 
# End of macro CWHEAD
2406			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
2406					if DEBUG_FORTH_WORDS_KEY 
2406						DMARK "CLL" 
2406 f5				push af  
2407 3a 1b 24			ld a, (.dmark)  
240a 32 7a ee			ld (debug_mark),a  
240d 3a 1c 24			ld a, (.dmark+1)  
2410 32 7b ee			ld (debug_mark+1),a  
2413 3a 1d 24			ld a, (.dmark+2)  
2416 32 7c ee			ld (debug_mark+2),a  
2419 18 03			jr .pastdmark  
241b ..			.dmark: db "CLL"  
241e f1			.pastdmark: pop af  
241f			endm  
# End of macro DMARK
241f						CALLMONITOR 
241f cd bb 13			call break_point_state  
2422				endm  
# End of macro CALLMONITOR
2422					endif 
2422			 
2422					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2422 cd 3f 1b			call macro_dsp_valuehl 
2425				endm 
# End of macro FORTH_DSP_VALUEHL
2425			 
2425			;		push hl 
2425			 
2425					; destroy value TOS 
2425			 
2425					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2425 cd f7 1b			call macro_forth_dsp_pop 
2428				endm 
# End of macro FORTH_DSP_POP
2428			 
2428						 
2428			;		pop hl 
2428			 
2428					; how to do a call with hl???? save SP? 
2428 cd 5a 1c				call forth_call_hl 
242b			 
242b			 
242b					; TODO push value back onto stack for another op etc 
242b			 
242b cd 48 19				call forth_push_numhl 
242e					NEXTW 
242e c3 b1 1c			jp macro_next 
2431				endm 
# End of macro NEXTW
2431			.DEPTH: 
2431				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2431 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2432 6e 24			dw .OVER            
2434 06				db 5 + 1 
2435 .. 00			db "DEPTH",0              
243b				endm 
# End of macro CWHEAD
243b			; | DEPTH ( -- u ) Push count of stack | DONE 
243b					; take current TOS and remove from base value div by two to get count 
243b					if DEBUG_FORTH_WORDS_KEY 
243b						DMARK "DEP" 
243b f5				push af  
243c 3a 50 24			ld a, (.dmark)  
243f 32 7a ee			ld (debug_mark),a  
2442 3a 51 24			ld a, (.dmark+1)  
2445 32 7b ee			ld (debug_mark+1),a  
2448 3a 52 24			ld a, (.dmark+2)  
244b 32 7c ee			ld (debug_mark+2),a  
244e 18 03			jr .pastdmark  
2450 ..			.dmark: db "DEP"  
2453 f1			.pastdmark: pop af  
2454			endm  
# End of macro DMARK
2454						CALLMONITOR 
2454 cd bb 13			call break_point_state  
2457				endm  
# End of macro CALLMONITOR
2457					endif 
2457			 
2457			 
2457 2a 0d eb			ld hl, (cli_data_sp) 
245a 11 c7 e8			ld de, cli_data_stack 
245d ed 52			sbc hl,de 
245f				 
245f				; div by size of stack item 
245f			 
245f 5d				ld e,l 
2460 0e 03			ld c, 3 
2462 cd 04 0b			call Div8 
2465			 
2465 6f				ld l,a 
2466 26 00			ld h,0 
2468			 
2468				;srl h 
2468				;rr l 
2468			 
2468 cd 48 19				call forth_push_numhl 
246b					NEXTW 
246b c3 b1 1c			jp macro_next 
246e				endm 
# End of macro NEXTW
246e			.OVER: 
246e				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
246e 42				db WORD_SYS_CORE+46             
246f b5 24			dw .PAUSE            
2471 05				db 4 + 1 
2472 .. 00			db "OVER",0              
2477				endm 
# End of macro CWHEAD
2477			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
2477					if DEBUG_FORTH_WORDS_KEY 
2477						DMARK "OVR" 
2477 f5				push af  
2478 3a 8c 24			ld a, (.dmark)  
247b 32 7a ee			ld (debug_mark),a  
247e 3a 8d 24			ld a, (.dmark+1)  
2481 32 7b ee			ld (debug_mark+1),a  
2484 3a 8e 24			ld a, (.dmark+2)  
2487 32 7c ee			ld (debug_mark+2),a  
248a 18 03			jr .pastdmark  
248c ..			.dmark: db "OVR"  
248f f1			.pastdmark: pop af  
2490			endm  
# End of macro DMARK
2490						CALLMONITOR 
2490 cd bb 13			call break_point_state  
2493				endm  
# End of macro CALLMONITOR
2493					endif 
2493			 
2493					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2493 cd 3f 1b			call macro_dsp_valuehl 
2496				endm 
# End of macro FORTH_DSP_VALUEHL
2496 e5					push hl    ; n2 
2497					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2497 cd f7 1b			call macro_forth_dsp_pop 
249a				endm 
# End of macro FORTH_DSP_POP
249a			 
249a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
249a cd 3f 1b			call macro_dsp_valuehl 
249d				endm 
# End of macro FORTH_DSP_VALUEHL
249d e5					push hl    ; n1 
249e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
249e cd f7 1b			call macro_forth_dsp_pop 
24a1				endm 
# End of macro FORTH_DSP_POP
24a1			 
24a1 d1					pop de     ; n1 
24a2 e1					pop hl     ; n2 
24a3			 
24a3 d5					push de 
24a4 e5					push hl 
24a5 d5					push de 
24a6			 
24a6					; push back  
24a6			 
24a6 e1					pop hl 
24a7 cd 48 19				call forth_push_numhl 
24aa e1					pop hl 
24ab cd 48 19				call forth_push_numhl 
24ae e1					pop hl 
24af cd 48 19				call forth_push_numhl 
24b2					NEXTW 
24b2 c3 b1 1c			jp macro_next 
24b5				endm 
# End of macro NEXTW
24b5			 
24b5			.PAUSE: 
24b5				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
24b5 43				db WORD_SYS_CORE+47             
24b6 ea 24			dw .PAUSES            
24b8 08				db 7 + 1 
24b9 .. 00			db "PAUSEMS",0              
24c1				endm 
# End of macro CWHEAD
24c1			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
24c1					if DEBUG_FORTH_WORDS_KEY 
24c1						DMARK "PMS" 
24c1 f5				push af  
24c2 3a d6 24			ld a, (.dmark)  
24c5 32 7a ee			ld (debug_mark),a  
24c8 3a d7 24			ld a, (.dmark+1)  
24cb 32 7b ee			ld (debug_mark+1),a  
24ce 3a d8 24			ld a, (.dmark+2)  
24d1 32 7c ee			ld (debug_mark+2),a  
24d4 18 03			jr .pastdmark  
24d6 ..			.dmark: db "PMS"  
24d9 f1			.pastdmark: pop af  
24da			endm  
# End of macro DMARK
24da						CALLMONITOR 
24da cd bb 13			call break_point_state  
24dd				endm  
# End of macro CALLMONITOR
24dd					endif 
24dd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
24dd cd 3f 1b			call macro_dsp_valuehl 
24e0				endm 
# End of macro FORTH_DSP_VALUEHL
24e0			;		push hl    ; n2 
24e0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
24e0 cd f7 1b			call macro_forth_dsp_pop 
24e3				endm 
# End of macro FORTH_DSP_POP
24e3			;		pop hl 
24e3			 
24e3 7d					ld a, l 
24e4 cd cf 08				call aDelayInMS 
24e7				       NEXTW 
24e7 c3 b1 1c			jp macro_next 
24ea				endm 
# End of macro NEXTW
24ea			.PAUSES:  
24ea				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
24ea 44				db WORD_SYS_CORE+48             
24eb 59 25			dw .ROT            
24ed 06				db 5 + 1 
24ee .. 00			db "PAUSE",0              
24f4				endm 
# End of macro CWHEAD
24f4			; | PAUSE ( n -- )  Pause for n seconds | DONE 
24f4					if DEBUG_FORTH_WORDS_KEY 
24f4						DMARK "PAU" 
24f4 f5				push af  
24f5 3a 09 25			ld a, (.dmark)  
24f8 32 7a ee			ld (debug_mark),a  
24fb 3a 0a 25			ld a, (.dmark+1)  
24fe 32 7b ee			ld (debug_mark+1),a  
2501 3a 0b 25			ld a, (.dmark+2)  
2504 32 7c ee			ld (debug_mark+2),a  
2507 18 03			jr .pastdmark  
2509 ..			.dmark: db "PAU"  
250c f1			.pastdmark: pop af  
250d			endm  
# End of macro DMARK
250d						CALLMONITOR 
250d cd bb 13			call break_point_state  
2510				endm  
# End of macro CALLMONITOR
2510					endif 
2510					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2510 cd 3f 1b			call macro_dsp_valuehl 
2513				endm 
# End of macro FORTH_DSP_VALUEHL
2513			;		push hl    ; n2 
2513					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2513 cd f7 1b			call macro_forth_dsp_pop 
2516				endm 
# End of macro FORTH_DSP_POP
2516			;		pop hl 
2516 45					ld b, l 
2517					if DEBUG_FORTH_WORDS 
2517						DMARK "PAU" 
2517 f5				push af  
2518 3a 2c 25			ld a, (.dmark)  
251b 32 7a ee			ld (debug_mark),a  
251e 3a 2d 25			ld a, (.dmark+1)  
2521 32 7b ee			ld (debug_mark+1),a  
2524 3a 2e 25			ld a, (.dmark+2)  
2527 32 7c ee			ld (debug_mark+2),a  
252a 18 03			jr .pastdmark  
252c ..			.dmark: db "PAU"  
252f f1			.pastdmark: pop af  
2530			endm  
# End of macro DMARK
2530						CALLMONITOR 
2530 cd bb 13			call break_point_state  
2533				endm  
# End of macro CALLMONITOR
2533					endif 
2533 c5			.pauses1:	push bc 
2534 cd ea 08				call delay1s 
2537 c1					pop bc 
2538					if DEBUG_FORTH_WORDS 
2538						DMARK "PA1" 
2538 f5				push af  
2539 3a 4d 25			ld a, (.dmark)  
253c 32 7a ee			ld (debug_mark),a  
253f 3a 4e 25			ld a, (.dmark+1)  
2542 32 7b ee			ld (debug_mark+1),a  
2545 3a 4f 25			ld a, (.dmark+2)  
2548 32 7c ee			ld (debug_mark+2),a  
254b 18 03			jr .pastdmark  
254d ..			.dmark: db "PA1"  
2550 f1			.pastdmark: pop af  
2551			endm  
# End of macro DMARK
2551						CALLMONITOR 
2551 cd bb 13			call break_point_state  
2554				endm  
# End of macro CALLMONITOR
2554					endif 
2554 10 dd				djnz .pauses1 
2556			 
2556				       NEXTW 
2556 c3 b1 1c			jp macro_next 
2559				endm 
# End of macro NEXTW
2559			.ROT: 
2559				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2559 45				db WORD_SYS_CORE+49             
255a a7 25			dw .UWORDS            
255c 04				db 3 + 1 
255d .. 00			db "ROT",0              
2561				endm 
# End of macro CWHEAD
2561			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2561					if DEBUG_FORTH_WORDS_KEY 
2561						DMARK "ROT" 
2561 f5				push af  
2562 3a 76 25			ld a, (.dmark)  
2565 32 7a ee			ld (debug_mark),a  
2568 3a 77 25			ld a, (.dmark+1)  
256b 32 7b ee			ld (debug_mark+1),a  
256e 3a 78 25			ld a, (.dmark+2)  
2571 32 7c ee			ld (debug_mark+2),a  
2574 18 03			jr .pastdmark  
2576 ..			.dmark: db "ROT"  
2579 f1			.pastdmark: pop af  
257a			endm  
# End of macro DMARK
257a						CALLMONITOR 
257a cd bb 13			call break_point_state  
257d				endm  
# End of macro CALLMONITOR
257d					endif 
257d			 
257d					FORTH_DSP_VALUEHL 
257d cd 3f 1b			call macro_dsp_valuehl 
2580				endm 
# End of macro FORTH_DSP_VALUEHL
2580 e5					push hl    ; u3  
2581			 
2581					FORTH_DSP_POP 
2581 cd f7 1b			call macro_forth_dsp_pop 
2584				endm 
# End of macro FORTH_DSP_POP
2584			   
2584					FORTH_DSP_VALUEHL 
2584 cd 3f 1b			call macro_dsp_valuehl 
2587				endm 
# End of macro FORTH_DSP_VALUEHL
2587 e5					push hl     ; u2 
2588			 
2588					FORTH_DSP_POP 
2588 cd f7 1b			call macro_forth_dsp_pop 
258b				endm 
# End of macro FORTH_DSP_POP
258b			 
258b					FORTH_DSP_VALUEHL 
258b cd 3f 1b			call macro_dsp_valuehl 
258e				endm 
# End of macro FORTH_DSP_VALUEHL
258e e5					push hl     ; u1 
258f			 
258f					FORTH_DSP_POP 
258f cd f7 1b			call macro_forth_dsp_pop 
2592				endm 
# End of macro FORTH_DSP_POP
2592			 
2592 c1					pop bc      ; u1 
2593 e1					pop hl      ; u2 
2594 d1					pop de      ; u3 
2595			 
2595			 
2595 c5					push bc 
2596 d5					push de 
2597 e5					push hl 
2598			 
2598			 
2598 e1					pop hl 
2599 cd 48 19				call forth_push_numhl 
259c			 
259c e1					pop hl 
259d cd 48 19				call forth_push_numhl 
25a0			 
25a0 e1					pop hl 
25a1 cd 48 19				call forth_push_numhl 
25a4					 
25a4			 
25a4			 
25a4			 
25a4			 
25a4			 
25a4				       NEXTW 
25a4 c3 b1 1c			jp macro_next 
25a7				endm 
# End of macro NEXTW
25a7			 
25a7			.UWORDS: 
25a7				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
25a7 50				db WORD_SYS_CORE+60             
25a8 69 26			dw .BP            
25aa 07				db 6 + 1 
25ab .. 00			db "UWORDS",0              
25b2				endm 
# End of macro CWHEAD
25b2			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
25b2			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
25b2			; | | Following the count are the individual words. 
25b2			; | | 
25b2			; | | e.g. UWORDS 
25b2			; | | BOX DIRLIST 2 
25b2			; | |  
25b2			; | | Can be used to save the words to storage via: 
25b2			; | | UWORDS $01 DO $01 APPEND LOOP 
25b2				if DEBUG_FORTH_WORDS_KEY 
25b2					DMARK "UWR" 
25b2 f5				push af  
25b3 3a c7 25			ld a, (.dmark)  
25b6 32 7a ee			ld (debug_mark),a  
25b9 3a c8 25			ld a, (.dmark+1)  
25bc 32 7b ee			ld (debug_mark+1),a  
25bf 3a c9 25			ld a, (.dmark+2)  
25c2 32 7c ee			ld (debug_mark+2),a  
25c5 18 03			jr .pastdmark  
25c7 ..			.dmark: db "UWR"  
25ca f1			.pastdmark: pop af  
25cb			endm  
# End of macro DMARK
25cb					CALLMONITOR 
25cb cd bb 13			call break_point_state  
25ce				endm  
# End of macro CALLMONITOR
25ce				endif 
25ce 21 93 59				ld hl, baseram 
25d1					;ld hl, baseusermem 
25d1 01 00 00				ld bc, 0    ; start a counter 
25d4			 
25d4				; skip dict stub 
25d4			 
25d4 cd 02 1e				call forth_tok_next 
25d7			 
25d7			 
25d7			; while we have words to look for 
25d7			 
25d7 7e			.douscan:	ld a, (hl)      
25d8				if DEBUG_FORTH_WORDS 
25d8					DMARK "UWs" 
25d8 f5				push af  
25d9 3a ed 25			ld a, (.dmark)  
25dc 32 7a ee			ld (debug_mark),a  
25df 3a ee 25			ld a, (.dmark+1)  
25e2 32 7b ee			ld (debug_mark+1),a  
25e5 3a ef 25			ld a, (.dmark+2)  
25e8 32 7c ee			ld (debug_mark+2),a  
25eb 18 03			jr .pastdmark  
25ed ..			.dmark: db "UWs"  
25f0 f1			.pastdmark: pop af  
25f1			endm  
# End of macro DMARK
25f1					CALLMONITOR 
25f1 cd bb 13			call break_point_state  
25f4				endm  
# End of macro CALLMONITOR
25f4				endif 
25f4 fe 00				cp WORD_SYS_END 
25f6 28 4d				jr z, .udone 
25f8 fe 01				cp WORD_SYS_UWORD 
25fa 20 44				jr nz, .nuword 
25fc			 
25fc				if DEBUG_FORTH_WORDS 
25fc					DMARK "UWu" 
25fc f5				push af  
25fd 3a 11 26			ld a, (.dmark)  
2600 32 7a ee			ld (debug_mark),a  
2603 3a 12 26			ld a, (.dmark+1)  
2606 32 7b ee			ld (debug_mark+1),a  
2609 3a 13 26			ld a, (.dmark+2)  
260c 32 7c ee			ld (debug_mark+2),a  
260f 18 03			jr .pastdmark  
2611 ..			.dmark: db "UWu"  
2614 f1			.pastdmark: pop af  
2615			endm  
# End of macro DMARK
2615					CALLMONITOR 
2615 cd bb 13			call break_point_state  
2618				endm  
# End of macro CALLMONITOR
2618				endif 
2618					; we have a uword so push its name to the stack 
2618			 
2618 e5				   	push hl  ; save so we can move to next dict block 
2619			 
2619					; skip opcode 
2619 23					inc hl  
261a					; skip next ptr 
261a 23					inc hl  
261b 23					inc hl 
261c					; skip len 
261c 23					inc hl 
261d				if DEBUG_FORTH_WORDS 
261d					DMARK "UWt" 
261d f5				push af  
261e 3a 32 26			ld a, (.dmark)  
2621 32 7a ee			ld (debug_mark),a  
2624 3a 33 26			ld a, (.dmark+1)  
2627 32 7b ee			ld (debug_mark+1),a  
262a 3a 34 26			ld a, (.dmark+2)  
262d 32 7c ee			ld (debug_mark+2),a  
2630 18 03			jr .pastdmark  
2632 ..			.dmark: db "UWt"  
2635 f1			.pastdmark: pop af  
2636			endm  
# End of macro DMARK
2636					CALLMONITOR 
2636 cd bb 13			call break_point_state  
2639				endm  
# End of macro CALLMONITOR
2639				endif 
2639 03					inc bc 
263a			 
263a c5					push bc 
263b cd b6 19				call forth_push_str 
263e c1					pop bc 
263f			 
263f e1					pop hl 	 
2640			 
2640 cd 02 1e		.nuword:	call forth_tok_next 
2643 18 92				jr .douscan  
2645			 
2645			.udone:		 ; push count of uwords found 
2645 c5					push bc 
2646 e1					pop hl 
2647			 
2647				if DEBUG_FORTH_WORDS 
2647					DMARK "UWc" 
2647 f5				push af  
2648 3a 5c 26			ld a, (.dmark)  
264b 32 7a ee			ld (debug_mark),a  
264e 3a 5d 26			ld a, (.dmark+1)  
2651 32 7b ee			ld (debug_mark+1),a  
2654 3a 5e 26			ld a, (.dmark+2)  
2657 32 7c ee			ld (debug_mark+2),a  
265a 18 03			jr .pastdmark  
265c ..			.dmark: db "UWc"  
265f f1			.pastdmark: pop af  
2660			endm  
# End of macro DMARK
2660					CALLMONITOR 
2660 cd bb 13			call break_point_state  
2663				endm  
# End of macro CALLMONITOR
2663				endif 
2663 cd 48 19				call forth_push_numhl 
2666			 
2666			 
2666				       NEXTW 
2666 c3 b1 1c			jp macro_next 
2669				endm 
# End of macro NEXTW
2669			 
2669			.BP: 
2669				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2669 54				db WORD_SYS_CORE+64             
266a 9f 26			dw .MONITOR            
266c 03				db 2 + 1 
266d .. 00			db "BP",0              
2670				endm 
# End of macro CWHEAD
2670			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2670			; | | $00 Will enable the break points within specific code paths 
2670			; | | $01 Will disable break points 
2670			; | |  
2670			; | | By default break points are off. Either the above can be used to enable them 
2670			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2670			; | | and on release of the pressed key a message will be disaplayed to notify 
2670			; | | that break points are enabled. Pressing any key will then continue boot process. 
2670					; get byte count 
2670					if DEBUG_FORTH_WORDS_KEY 
2670						DMARK "BP." 
2670 f5				push af  
2671 3a 85 26			ld a, (.dmark)  
2674 32 7a ee			ld (debug_mark),a  
2677 3a 86 26			ld a, (.dmark+1)  
267a 32 7b ee			ld (debug_mark+1),a  
267d 3a 87 26			ld a, (.dmark+2)  
2680 32 7c ee			ld (debug_mark+2),a  
2683 18 03			jr .pastdmark  
2685 ..			.dmark: db "BP."  
2688 f1			.pastdmark: pop af  
2689			endm  
# End of macro DMARK
2689						CALLMONITOR 
2689 cd bb 13			call break_point_state  
268c				endm  
# End of macro CALLMONITOR
268c					endif 
268c			 
268c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
268c cd 3f 1b			call macro_dsp_valuehl 
268f				endm 
# End of macro FORTH_DSP_VALUEHL
268f			 
268f			;		push hl 
268f			 
268f					; destroy value TOS 
268f			 
268f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
268f cd f7 1b			call macro_forth_dsp_pop 
2692				endm 
# End of macro FORTH_DSP_POP
2692			 
2692			;		pop hl 
2692			 
2692 3e 00				ld a,0 
2694 bd					cp l 
2695 28 02				jr z, .bpset 
2697 3e 2a				ld a, '*' 
2699			 
2699 32 51 e3		.bpset:		ld (os_view_disable), a 
269c			 
269c			 
269c					NEXTW 
269c c3 b1 1c			jp macro_next 
269f				endm 
# End of macro NEXTW
269f			 
269f			 
269f			.MONITOR: 
269f				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
269f 55				db WORD_SYS_CORE+65             
26a0 d2 26			dw .MALLOC            
26a2 08				db 7 + 1 
26a3 .. 00			db "MONITOR",0              
26ab				endm 
# End of macro CWHEAD
26ab			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
26ab			; | | At start the current various registers will be displayed with contents. 
26ab			; | | Top right corner will show the most recent debug marker seen. 
26ab			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
26ab			; | | and the return stack pointer (RSP). 
26ab			; | | Pressing: 
26ab			; | |    1 - Initial screen 
26ab			; | |    2 - Display a data dump of HL 
26ab			; | |    3 - Display a data dump of DE 
26ab			; | |    4 - Display a data dump of BC 
26ab			; | |    5 - Display a data dump of HL 
26ab			; | |    6 - Display a data dump of DSP 
26ab			; | |    7 - Display a data dump of RSP 
26ab			; | |    8 - Display a data dump of what is at DSP 
26ab			; | |    9 - Display a data dump of what is at RSP 
26ab			; | |    0 - Exit monitor and continue running. This will also enable break points 
26ab			; | |    * - Disable break points 
26ab			; | |    # - Enter traditional monitor mode 
26ab			; | | 
26ab			; | | Monitor Mode 
26ab			; | | ------------ 
26ab			; | | A prompt of '>' will be shown for various commands: 
26ab			; | |    D xxxx - Display a data dump starting from hex address xxxx 
26ab			; | |    C - Continue display a data dump from the last set address 
26ab			; | |    M xxxx - Set start of memory edit at address xx 
26ab			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
26ab			; | |    Q - Return to previous 
26ab					if DEBUG_FORTH_WORDS_KEY 
26ab						DMARK "MON" 
26ab f5				push af  
26ac 3a c0 26			ld a, (.dmark)  
26af 32 7a ee			ld (debug_mark),a  
26b2 3a c1 26			ld a, (.dmark+1)  
26b5 32 7b ee			ld (debug_mark+1),a  
26b8 3a c2 26			ld a, (.dmark+2)  
26bb 32 7c ee			ld (debug_mark+2),a  
26be 18 03			jr .pastdmark  
26c0 ..			.dmark: db "MON"  
26c3 f1			.pastdmark: pop af  
26c4			endm  
# End of macro DMARK
26c4						CALLMONITOR 
26c4 cd bb 13			call break_point_state  
26c7				endm  
# End of macro CALLMONITOR
26c7					endif 
26c7 3e 00				ld a, 0 
26c9 32 51 e3				ld (os_view_disable), a 
26cc			 
26cc					CALLMONITOR 
26cc cd bb 13			call break_point_state  
26cf				endm  
# End of macro CALLMONITOR
26cf			 
26cf			;	call monitor 
26cf			 
26cf					NEXTW 
26cf c3 b1 1c			jp macro_next 
26d2				endm 
# End of macro NEXTW
26d2			 
26d2			 
26d2			.MALLOC: 
26d2				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
26d2 56				db WORD_SYS_CORE+66             
26d3 fb 26			dw .MALLOC2            
26d5 06				db 5 + 1 
26d6 .. 00			db "ALLOT",0              
26dc				endm 
# End of macro CWHEAD
26dc			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
26dc					if DEBUG_FORTH_WORDS_KEY 
26dc						DMARK "ALL" 
26dc f5				push af  
26dd 3a f1 26			ld a, (.dmark)  
26e0 32 7a ee			ld (debug_mark),a  
26e3 3a f2 26			ld a, (.dmark+1)  
26e6 32 7b ee			ld (debug_mark+1),a  
26e9 3a f3 26			ld a, (.dmark+2)  
26ec 32 7c ee			ld (debug_mark+2),a  
26ef 18 03			jr .pastdmark  
26f1 ..			.dmark: db "ALL"  
26f4 f1			.pastdmark: pop af  
26f5			endm  
# End of macro DMARK
26f5						CALLMONITOR 
26f5 cd bb 13			call break_point_state  
26f8				endm  
# End of macro CALLMONITOR
26f8					endif 
26f8 c3 22 27				jp .mallocc 
26fb			.MALLOC2: 
26fb				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
26fb 56				db WORD_SYS_CORE+66             
26fc 39 27			dw .FREE            
26fe 07				db 6 + 1 
26ff .. 00			db "MALLOC",0              
2706				endm 
# End of macro CWHEAD
2706			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2706					; get byte count 
2706					if DEBUG_FORTH_WORDS_KEY 
2706						DMARK "MAL" 
2706 f5				push af  
2707 3a 1b 27			ld a, (.dmark)  
270a 32 7a ee			ld (debug_mark),a  
270d 3a 1c 27			ld a, (.dmark+1)  
2710 32 7b ee			ld (debug_mark+1),a  
2713 3a 1d 27			ld a, (.dmark+2)  
2716 32 7c ee			ld (debug_mark+2),a  
2719 18 03			jr .pastdmark  
271b ..			.dmark: db "MAL"  
271e f1			.pastdmark: pop af  
271f			endm  
# End of macro DMARK
271f						CALLMONITOR 
271f cd bb 13			call break_point_state  
2722				endm  
# End of macro CALLMONITOR
2722					endif 
2722			.mallocc: 
2722					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2722 cd 3f 1b			call macro_dsp_valuehl 
2725				endm 
# End of macro FORTH_DSP_VALUEHL
2725			 
2725			;		push hl 
2725			 
2725					; destroy value TOS 
2725			 
2725					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2725 cd f7 1b			call macro_forth_dsp_pop 
2728				endm 
# End of macro FORTH_DSP_POP
2728			 
2728			;		pop hl 
2728 cd 3b 10				call malloc 
272b				if DEBUG_FORTH_MALLOC_GUARD 
272b f5					push af 
272c cd 9d 0b				call ishlzero 
272f			;		ld a, l 
272f			;		add h 
272f			;		cp 0 
272f f1					pop af 
2730					 
2730 cc f0 45				call z,malloc_error 
2733				endif 
2733			 
2733 cd 48 19				call forth_push_numhl 
2736					NEXTW 
2736 c3 b1 1c			jp macro_next 
2739				endm 
# End of macro NEXTW
2739			 
2739			.FREE: 
2739				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2739 57				db WORD_SYS_CORE+67             
273a 6a 27			dw .LIST            
273c 05				db 4 + 1 
273d .. 00			db "FREE",0              
2742				endm 
# End of macro CWHEAD
2742			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2742					if DEBUG_FORTH_WORDS_KEY 
2742						DMARK "FRE" 
2742 f5				push af  
2743 3a 57 27			ld a, (.dmark)  
2746 32 7a ee			ld (debug_mark),a  
2749 3a 58 27			ld a, (.dmark+1)  
274c 32 7b ee			ld (debug_mark+1),a  
274f 3a 59 27			ld a, (.dmark+2)  
2752 32 7c ee			ld (debug_mark+2),a  
2755 18 03			jr .pastdmark  
2757 ..			.dmark: db "FRE"  
275a f1			.pastdmark: pop af  
275b			endm  
# End of macro DMARK
275b						CALLMONITOR 
275b cd bb 13			call break_point_state  
275e				endm  
# End of macro CALLMONITOR
275e					endif 
275e					; get address 
275e			 
275e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
275e cd 3f 1b			call macro_dsp_valuehl 
2761				endm 
# End of macro FORTH_DSP_VALUEHL
2761			 
2761			;		push hl 
2761			 
2761					; destroy value TOS 
2761			 
2761					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2761 cd f7 1b			call macro_forth_dsp_pop 
2764				endm 
# End of macro FORTH_DSP_POP
2764			 
2764			;		pop hl 
2764			if FORTH_ENABLE_MALLOCFREE 
2764 cd 05 11				call free 
2767			endif 
2767					NEXTW 
2767 c3 b1 1c			jp macro_next 
276a				endm 
# End of macro NEXTW
276a			.LIST: 
276a				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
276a 5c				db WORD_SYS_CORE+72             
276b 2d 29			dw .FORGET            
276d 05				db 4 + 1 
276e .. 00			db "LIST",0              
2773				endm 
# End of macro CWHEAD
2773			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2773			; | | The quoted word must be in upper case. 
2773				if DEBUG_FORTH_WORDS_KEY 
2773					DMARK "LST" 
2773 f5				push af  
2774 3a 88 27			ld a, (.dmark)  
2777 32 7a ee			ld (debug_mark),a  
277a 3a 89 27			ld a, (.dmark+1)  
277d 32 7b ee			ld (debug_mark+1),a  
2780 3a 8a 27			ld a, (.dmark+2)  
2783 32 7c ee			ld (debug_mark+2),a  
2786 18 03			jr .pastdmark  
2788 ..			.dmark: db "LST"  
278b f1			.pastdmark: pop af  
278c			endm  
# End of macro DMARK
278c					CALLMONITOR 
278c cd bb 13			call break_point_state  
278f				endm  
# End of macro CALLMONITOR
278f				endif 
278f			 
278f					FORTH_DSP_VALUEHL 
278f cd 3f 1b			call macro_dsp_valuehl 
2792				endm 
# End of macro FORTH_DSP_VALUEHL
2792			 
2792 e5					push hl 
2793 c1					pop bc 
2794			 
2794			; Start format of scratch string 
2794			 
2794 21 60 e3				ld hl, scratch 
2797			 
2797 3e 3a				ld a, ':' 
2799 77					ld (hl),a 
279a 23					inc hl 
279b 3e 20				ld a, ' ' 
279d 77					ld (hl), a 
279e			 
279e					; Get ptr to the word we need to look up 
279e			 
279e			;		FORTH_DSP_VALUEHL 
279e					;v5 FORTH_DSP_VALUE 
279e				; TODO type check 
279e			;		inc hl    ; Skip type check  
279e			;		push hl 
279e			;		ex de, hl    ; put into DE 
279e			 
279e			 
279e 21 93 59				ld hl, baseram 
27a1					;ld hl, baseusermem 
27a1			 
27a1 e5			push hl   ; sacreifical push 
27a2			 
27a2			.ldouscanm: 
27a2 e1				pop hl 
27a3			.ldouscan: 
27a3				if DEBUG_FORTH_WORDS 
27a3					DMARK "LSs" 
27a3 f5				push af  
27a4 3a b8 27			ld a, (.dmark)  
27a7 32 7a ee			ld (debug_mark),a  
27aa 3a b9 27			ld a, (.dmark+1)  
27ad 32 7b ee			ld (debug_mark+1),a  
27b0 3a ba 27			ld a, (.dmark+2)  
27b3 32 7c ee			ld (debug_mark+2),a  
27b6 18 03			jr .pastdmark  
27b8 ..			.dmark: db "LSs"  
27bb f1			.pastdmark: pop af  
27bc			endm  
# End of macro DMARK
27bc					CALLMONITOR 
27bc cd bb 13			call break_point_state  
27bf				endm  
# End of macro CALLMONITOR
27bf				endif 
27bf				; skip dict stub 
27bf cd 02 1e				call forth_tok_next 
27c2			 
27c2			 
27c2			; while we have words to look for 
27c2			 
27c2 7e				ld a, (hl)      
27c3				if DEBUG_FORTH_WORDS 
27c3					DMARK "LSk" 
27c3 f5				push af  
27c4 3a d8 27			ld a, (.dmark)  
27c7 32 7a ee			ld (debug_mark),a  
27ca 3a d9 27			ld a, (.dmark+1)  
27cd 32 7b ee			ld (debug_mark+1),a  
27d0 3a da 27			ld a, (.dmark+2)  
27d3 32 7c ee			ld (debug_mark+2),a  
27d6 18 03			jr .pastdmark  
27d8 ..			.dmark: db "LSk"  
27db f1			.pastdmark: pop af  
27dc			endm  
# End of macro DMARK
27dc					CALLMONITOR 
27dc cd bb 13			call break_point_state  
27df				endm  
# End of macro CALLMONITOR
27df				endif 
27df fe 00				cp WORD_SYS_END 
27e1 ca 14 29				jp z, .lunotfound 
27e4 fe 01				cp WORD_SYS_UWORD 
27e6 c2 a3 27				jp nz, .ldouscan 
27e9			 
27e9				if DEBUG_FORTH_WORDS 
27e9					DMARK "LSu" 
27e9 f5				push af  
27ea 3a fe 27			ld a, (.dmark)  
27ed 32 7a ee			ld (debug_mark),a  
27f0 3a ff 27			ld a, (.dmark+1)  
27f3 32 7b ee			ld (debug_mark+1),a  
27f6 3a 00 28			ld a, (.dmark+2)  
27f9 32 7c ee			ld (debug_mark+2),a  
27fc 18 03			jr .pastdmark  
27fe ..			.dmark: db "LSu"  
2801 f1			.pastdmark: pop af  
2802			endm  
# End of macro DMARK
2802					CALLMONITOR 
2802 cd bb 13			call break_point_state  
2805				endm  
# End of macro CALLMONITOR
2805				endif 
2805			 
2805					; found a uword but is it the one we want... 
2805			 
2805 c5					push bc     ; uword to find is on bc 
2806 d1					pop de 
2807			 
2807 e5					push hl  ; to save the ptr 
2808			 
2808					; skip opcode 
2808 23					inc hl  
2809					; skip next ptr 
2809 23					inc hl  
280a 23					inc hl 
280b					; skip len 
280b 23					inc hl 
280c			 
280c				if DEBUG_FORTH_WORDS 
280c					DMARK "LSc" 
280c f5				push af  
280d 3a 21 28			ld a, (.dmark)  
2810 32 7a ee			ld (debug_mark),a  
2813 3a 22 28			ld a, (.dmark+1)  
2816 32 7b ee			ld (debug_mark+1),a  
2819 3a 23 28			ld a, (.dmark+2)  
281c 32 7c ee			ld (debug_mark+2),a  
281f 18 03			jr .pastdmark  
2821 ..			.dmark: db "LSc"  
2824 f1			.pastdmark: pop af  
2825			endm  
# End of macro DMARK
2825					CALLMONITOR 
2825 cd bb 13			call break_point_state  
2828				endm  
# End of macro CALLMONITOR
2828				endif 
2828 cd 0a 10				call strcmp 
282b c2 a2 27				jp nz, .ldouscanm 
282e				 
282e			 
282e			 
282e					; we have a uword so push its name to the stack 
282e			 
282e			;	   	push hl  ; save so we can move to next dict block 
282e e1			pop hl 
282f			 
282f				if DEBUG_FORTH_WORDS 
282f					DMARK "LSm" 
282f f5				push af  
2830 3a 44 28			ld a, (.dmark)  
2833 32 7a ee			ld (debug_mark),a  
2836 3a 45 28			ld a, (.dmark+1)  
2839 32 7b ee			ld (debug_mark+1),a  
283c 3a 46 28			ld a, (.dmark+2)  
283f 32 7c ee			ld (debug_mark+2),a  
2842 18 03			jr .pastdmark  
2844 ..			.dmark: db "LSm"  
2847 f1			.pastdmark: pop af  
2848			endm  
# End of macro DMARK
2848					CALLMONITOR 
2848 cd bb 13			call break_point_state  
284b				endm  
# End of macro CALLMONITOR
284b				endif 
284b			 
284b					; skip opcode 
284b 23					inc hl  
284c					; skip next ptr 
284c 23					inc hl  
284d 23					inc hl 
284e					; skip len 
284e 7e					ld a, (hl)   ; save length to add 
284f				if DEBUG_FORTH_WORDS 
284f					DMARK "LS2" 
284f f5				push af  
2850 3a 64 28			ld a, (.dmark)  
2853 32 7a ee			ld (debug_mark),a  
2856 3a 65 28			ld a, (.dmark+1)  
2859 32 7b ee			ld (debug_mark+1),a  
285c 3a 66 28			ld a, (.dmark+2)  
285f 32 7c ee			ld (debug_mark+2),a  
2862 18 03			jr .pastdmark  
2864 ..			.dmark: db "LS2"  
2867 f1			.pastdmark: pop af  
2868			endm  
# End of macro DMARK
2868					CALLMONITOR 
2868 cd bb 13			call break_point_state  
286b				endm  
# End of macro CALLMONITOR
286b				endif 
286b			 
286b					; save this location 
286b				 
286b e5					push hl 
286c			 
286c 23					inc hl 
286d 11 62 e3				ld de, scratch+2 
2870 4f					ld c, a 
2871 06 00				ld b, 0 
2873			 
2873				if DEBUG_FORTH_WORDS 
2873					DMARK "LSn" 
2873 f5				push af  
2874 3a 88 28			ld a, (.dmark)  
2877 32 7a ee			ld (debug_mark),a  
287a 3a 89 28			ld a, (.dmark+1)  
287d 32 7b ee			ld (debug_mark+1),a  
2880 3a 8a 28			ld a, (.dmark+2)  
2883 32 7c ee			ld (debug_mark+2),a  
2886 18 03			jr .pastdmark  
2888 ..			.dmark: db "LSn"  
288b f1			.pastdmark: pop af  
288c			endm  
# End of macro DMARK
288c					CALLMONITOR 
288c cd bb 13			call break_point_state  
288f				endm  
# End of macro CALLMONITOR
288f				endif 
288f			 
288f					; copy uword name to scratch 
288f			 
288f ed b0				ldir 
2891			 
2891 1b					dec de 
2892 3e 20				ld a, ' '    ; change null to space 
2894 12					ld (de), a 
2895			 
2895 13					inc de 
2896			 
2896 d5					push de 
2897 c1					pop bc     ; move scratch pointer to end of word name and save it 
2898			 
2898 e1					pop hl 
2899 7e					ld a, (hl) 
289a					;inc hl 
289a					; skip word string 
289a cd 74 0b				call addatohl 
289d			 
289d 23					inc hl 
289e			 
289e				if DEBUG_FORTH_WORDS 
289e					DMARK "LS3" 
289e f5				push af  
289f 3a b3 28			ld a, (.dmark)  
28a2 32 7a ee			ld (debug_mark),a  
28a5 3a b4 28			ld a, (.dmark+1)  
28a8 32 7b ee			ld (debug_mark+1),a  
28ab 3a b5 28			ld a, (.dmark+2)  
28ae 32 7c ee			ld (debug_mark+2),a  
28b1 18 03			jr .pastdmark  
28b3 ..			.dmark: db "LS3"  
28b6 f1			.pastdmark: pop af  
28b7			endm  
# End of macro DMARK
28b7					CALLMONITOR 
28b7 cd bb 13			call break_point_state  
28ba				endm  
# End of macro CALLMONITOR
28ba				endif 
28ba					; should now be at the start of the machine code to setup the eval of the uword 
28ba					; now locate the ptr to the string defintion 
28ba			 
28ba					; skip ld hl, 
28ba					; then load the ptr 
28ba			 
28ba 23					inc hl 
28bb 5e					ld e, (hl) 
28bc 23					inc hl 
28bd 56					ld d, (hl) 
28be eb					ex de, hl 
28bf			 
28bf			 
28bf				if DEBUG_FORTH_WORDS 
28bf					DMARK "LSt" 
28bf f5				push af  
28c0 3a d4 28			ld a, (.dmark)  
28c3 32 7a ee			ld (debug_mark),a  
28c6 3a d5 28			ld a, (.dmark+1)  
28c9 32 7b ee			ld (debug_mark+1),a  
28cc 3a d6 28			ld a, (.dmark+2)  
28cf 32 7c ee			ld (debug_mark+2),a  
28d2 18 03			jr .pastdmark  
28d4 ..			.dmark: db "LSt"  
28d7 f1			.pastdmark: pop af  
28d8			endm  
# End of macro DMARK
28d8					CALLMONITOR 
28d8 cd bb 13			call break_point_state  
28db				endm  
# End of macro CALLMONITOR
28db				endif 
28db			 
28db			; cant push right now due to tokenised strings  
28db			 
28db			; get the destination of where to copy this definition to. 
28db			 
28db c5					push bc 
28dc d1					pop de 
28dd			 
28dd 7e			.listl:         ld a,(hl) 
28de fe 00				cp 0 
28e0 28 09				jr z, .lreplsp     ; replace zero with space 
28e2 fe 7f				cp FORTH_END_BUFFER 
28e4 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
28e6				 
28e6					; just copy this char as is then 
28e6			 
28e6 12					ld (de), a 
28e7			 
28e7 23			.listnxt:	inc hl 
28e8 13					inc de 
28e9 18 f2				jr .listl 
28eb			 
28eb 3e 20		.lreplsp:	ld a,' ' 
28ed 12					ld (de), a 
28ee 18 f7				jr .listnxt 
28f0			 
28f0			; close up uword def 
28f0			 
28f0			.listdone: 
28f0 3e 00				ld a, 0 
28f2 12					ld (de), a 
28f3			 
28f3			; now have def so clean up and push to stack 
28f3			 
28f3 21 60 e3				ld hl, scratch 
28f6				if DEBUG_FORTH_WORDS 
28f6					DMARK "Ltp" 
28f6 f5				push af  
28f7 3a 0b 29			ld a, (.dmark)  
28fa 32 7a ee			ld (debug_mark),a  
28fd 3a 0c 29			ld a, (.dmark+1)  
2900 32 7b ee			ld (debug_mark+1),a  
2903 3a 0d 29			ld a, (.dmark+2)  
2906 32 7c ee			ld (debug_mark+2),a  
2909 18 03			jr .pastdmark  
290b ..			.dmark: db "Ltp"  
290e f1			.pastdmark: pop af  
290f			endm  
# End of macro DMARK
290f					CALLMONITOR 
290f cd bb 13			call break_point_state  
2912				endm  
# End of macro CALLMONITOR
2912				endif 
2912			 
2912 18 06			jr .listpush 
2914			 
2914			;.lnuword:	pop hl 
2914			;		call forth_tok_next 
2914			;		jp .ldouscan  
2914			 
2914			.lunotfound:		  
2914			 
2914			 
2914					 
2914					FORTH_DSP_POP 
2914 cd f7 1b			call macro_forth_dsp_pop 
2917				endm 
# End of macro FORTH_DSP_POP
2917 21 20 29				ld hl, .luno 
291a						 
291a			 
291a			.listpush: 
291a cd b6 19				call forth_push_str 
291d			 
291d			 
291d			 
291d					NEXTW 
291d c3 b1 1c			jp macro_next 
2920				endm 
# End of macro NEXTW
2920			 
2920 .. 00		.luno:    db "Not found",0 
292a			 
292a			 
292a			 
292a			 
292a			 
292a			;		push hl   ; save pointer to start of uword def string 
292a			; 
292a			;; look for FORTH_EOL_LINE 
292a			;		ld a, FORTH_END_BUFFER 
292a			;		call strlent 
292a			; 
292a			;		inc hl		 ; space for coln def 
292a			;		inc hl 
292a			;		inc hl          ; space for terms 
292a			;		inc hl 
292a			; 
292a			;		ld a, 20   ; TODO get actual length 
292a			;		call addatohl    ; include a random amount of room for the uword name 
292a			; 
292a			;		 
292a			;	if DEBUG_FORTH_WORDS 
292a			;		DMARK "Lt1" 
292a			;		CALLMONITOR 
292a			;	endif 
292a			;		 
292a			; 
292a			;; malloc space for the string because we cant change it 
292a			; 
292a			;		call malloc 
292a			;	if DEBUG_FORTH_MALLOC_GUARD 
292a			;		push af 
292a			;		call ishlzero 
292a			;		pop af 
292a			;		 
292a			;		call z,malloc_error 
292a			;	endif 
292a			; 
292a			;	if DEBUG_FORTH_WORDS 
292a			;		DMARK "Lt2" 
292a			;		CALLMONITOR 
292a			;	endif 
292a			;		pop de 
292a			;		push hl    ; push the malloc to release later 
292a			;		push hl   ;  push back a copy for the later stack push 
292a			;		 
292a			;; copy the string swapping out the zero terms for spaces 
292a			; 
292a			;		; de has our source 
292a			;		; hl has our dest 
292a			; 
292a			;; add the coln def 
292a			; 
292a			;		ld a, ':' 
292a			;		ld (hl), a 
292a			;		inc hl 
292a			;		ld a, ' ' 
292a			;		ld (hl), a 
292a			;		inc hl 
292a			; 
292a			;; add the uname word 
292a			;		push de   ; save our string for now 
292a			;		ex de, hl 
292a			; 
292a			;		FORTH_DSP_VALUE 
292a			;		;v5 FORTH_DSP_VALUE 
292a			; 
292a			;		inc hl   ; skip type but we know by now this is OK 
292a			; 
292a			;.luword:	ld a,(hl) 
292a			;		cp 0 
292a			;		jr z, .luword2 
292a			;		ld (de), a 
292a			;		inc de 
292a			;		inc hl 
292a			;		jr .luword 
292a			; 
292a			;.luword2:	ld a, ' ' 
292a			;		ld (de), a 
292a			;;		inc hl 
292a			;;		inc de 
292a			;;		ld (de), a 
292a			;;		inc hl 
292a			;		inc de 
292a			; 
292a			;		ex de, hl 
292a			;		pop de 
292a			;		 
292a			;		 
292a			; 
292a			;; detoken that string and copy it 
292a			; 
292a			;	if DEBUG_FORTH_WORDS 
292a			;		DMARK "Lt2" 
292a			;		CALLMONITOR 
292a			;	endif 
292a			;.ldetok:	ld a, (de) 
292a			;		cp FORTH_END_BUFFER 
292a			;		jr z, .ldetokend 
292a			;		; swap out any zero term for space 
292a			;		cp 0 
292a			;		jr nz, .ldetoknext 
292a			;		ld a, ' ' 
292a			; 
292a			;	if DEBUG_FORTH_WORDS 
292a			;		DMARK "LtS" 
292a			;		CALLMONITOR 
292a			;	endif 
292a			;.ldetoknext:	ld (hl), a 
292a			;		inc de 
292a			;		inc hl 
292a			;		jr .ldetok 
292a			; 
292a			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
292a			;		ld (hl), a  
292a			; 
292a			;; free that temp malloc 
292a			; 
292a			;		pop hl    
292a			; 
292a			;	if DEBUG_FORTH_WORDS 
292a			;		DMARK "Lt4" 
292a			;		CALLMONITOR 
292a			;	endif 
292a			;		call forth_apushstrhl 
292a			; 
292a			;		; get rid of temp malloc area 
292a			; 
292a			;		pop hl 
292a			;		call free 
292a			; 
292a			;		jr .ludone 
292a			; 
292a			;.lnuword:	pop hl 
292a			;		call forth_tok_next 
292a			;		jp .ldouscan  
292a			; 
292a			;.ludone:		 pop hl 
292a			; 
292a					NEXTW 
292a c3 b1 1c			jp macro_next 
292d				endm 
# End of macro NEXTW
292d			 
292d			.FORGET: 
292d				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
292d 5d				db WORD_SYS_CORE+73             
292e a6 29			dw .NOP            
2930 07				db 6 + 1 
2931 .. 00			db "FORGET",0              
2938				endm 
# End of macro CWHEAD
2938			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2938			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2938			; | |  
2938			; | | e.g. "MORE" forget 
2938					if DEBUG_FORTH_WORDS_KEY 
2938						DMARK "FRG" 
2938 f5				push af  
2939 3a 4d 29			ld a, (.dmark)  
293c 32 7a ee			ld (debug_mark),a  
293f 3a 4e 29			ld a, (.dmark+1)  
2942 32 7b ee			ld (debug_mark+1),a  
2945 3a 4f 29			ld a, (.dmark+2)  
2948 32 7c ee			ld (debug_mark+2),a  
294b 18 03			jr .pastdmark  
294d ..			.dmark: db "FRG"  
2950 f1			.pastdmark: pop af  
2951			endm  
# End of macro DMARK
2951						CALLMONITOR 
2951 cd bb 13			call break_point_state  
2954				endm  
# End of macro CALLMONITOR
2954					endif 
2954			 
2954				; find uword 
2954			        ; update start of word with "_" 
2954				; replace uword with deleted flag 
2954			 
2954			 
2954			;	if DEBUG_FORTH_WORDS 
2954			;		DMARK "FOG" 
2954			;		CALLMONITOR 
2954			;	endif 
2954			 
2954			 
2954					; Get ptr to the word we need to look up 
2954			 
2954					FORTH_DSP_VALUEHL 
2954 cd 3f 1b			call macro_dsp_valuehl 
2957				endm 
# End of macro FORTH_DSP_VALUEHL
2957					;v5 FORTH_DSP_VALUE 
2957				; TODO type check 
2957			;		inc hl    ; Skip type check  
2957 e5					push hl 
2958 c1					pop bc 
2959			;		ex de, hl    ; put into DE 
2959			 
2959			 
2959 21 93 59				ld hl, baseram 
295c					;ld hl, baseusermem 
295c			 
295c				; skip dict stub 
295c			;	call forth_tok_next 
295c e5			push hl   ; sacreifical push 
295d			 
295d			.fldouscanm: 
295d e1				pop hl 
295e			.fldouscan: 
295e			;	if DEBUG_FORTH_WORDS 
295e			;		DMARK "LSs" 
295e			;		CALLMONITOR 
295e			;	endif 
295e				; skip dict stub 
295e cd 02 1e				call forth_tok_next 
2961			 
2961			 
2961			; while we have words to look for 
2961			 
2961 7e				ld a, (hl)      
2962			;	if DEBUG_FORTH_WORDS 
2962			;		DMARK "LSk" 
2962			;		CALLMONITOR 
2962			;	endif 
2962 fe 00				cp WORD_SYS_END 
2964 ca a0 29				jp z, .flunotfound 
2967 fe 01				cp WORD_SYS_UWORD 
2969 c2 5e 29				jp nz, .fldouscan 
296c			 
296c			;	if DEBUG_FORTH_WORDS 
296c			;		DMARK "LSu" 
296c			;		CALLMONITOR 
296c			;	endif 
296c			 
296c					; found a uword but is it the one we want... 
296c			 
296c c5					push bc     ; uword to find is on bc 
296d d1					pop de 
296e			 
296e e5					push hl  ; to save the ptr 
296f			 
296f					; skip opcode 
296f 23					inc hl  
2970					; skip next ptr 
2970 23					inc hl  
2971 23					inc hl 
2972					; skip len 
2972 23					inc hl 
2973			 
2973			;	if DEBUG_FORTH_WORDS 
2973			;		DMARK "LSc" 
2973			;		CALLMONITOR 
2973			;	endif 
2973 cd 0a 10				call strcmp 
2976 c2 5d 29				jp nz, .fldouscanm 
2979			; 
2979			; 
2979			;; while we have words to look for 
2979			; 
2979			;.fdouscan:	ld a, (hl)      
2979			;	if DEBUG_FORTH_WORDS 
2979			;		DMARK "LSs" 
2979			;		CALLMONITOR 
2979			;	endif 
2979			;		cp WORD_SYS_END 
2979			;		jp z, .fudone 
2979			;		cp WORD_SYS_UWORD 
2979			;		jp nz, .fnuword 
2979			; 
2979			;	if DEBUG_FORTH_WORDS 
2979			;		DMARK "FGu" 
2979			;		CALLMONITOR 
2979			;	endif 
2979			; 
2979			;		; found a uword but is it the one we want... 
2979			; 
2979			; 
2979			;	        pop de   ; get back the dsp name 
2979			;		push de 
2979			; 
2979			;		push hl  ; to save the ptr 
2979			; 
2979			;		; skip opcode 
2979			;		inc hl  
2979			;		; skip next ptr 
2979			;		inc hl  
2979			;		inc hl 
2979			;		; skip len 
2979			;		inc hl 
2979			; 
2979			;	if DEBUG_FORTH_WORDS 
2979			;		DMARK "FGc" 
2979			;		CALLMONITOR 
2979			;	endif 
2979			;		call strcmp 
2979			;		jp nz, .fnuword 
2979			 
2979			 
2979 e1			pop hl 
297a			 
297a				 
297a				if DEBUG_FORTH_WORDS 
297a					DMARK "FGm" 
297a f5				push af  
297b 3a 8f 29			ld a, (.dmark)  
297e 32 7a ee			ld (debug_mark),a  
2981 3a 90 29			ld a, (.dmark+1)  
2984 32 7b ee			ld (debug_mark+1),a  
2987 3a 91 29			ld a, (.dmark+2)  
298a 32 7c ee			ld (debug_mark+2),a  
298d 18 03			jr .pastdmark  
298f ..			.dmark: db "FGm"  
2992 f1			.pastdmark: pop af  
2993			endm  
# End of macro DMARK
2993					CALLMONITOR 
2993 cd bb 13			call break_point_state  
2996				endm  
# End of macro CALLMONITOR
2996				endif 
2996			 
2996			 
2996			 
2996					; we have a uword so push its name to the stack 
2996			 
2996			;	   	push hl  ; save so we can move to next dict block 
2996			;pop hl 
2996			 
2996					; update opcode to deleted 
2996 3e 03				ld a, WORD_SYS_DELETED 
2998 77					ld (hl), a 
2999			 
2999 23					inc hl  
299a					; skip next ptr 
299a 23					inc hl  
299b 23					inc hl 
299c					; skip len 
299c 23					inc hl 
299d			 
299d					; TODO change parser to skip deleted words but for now mark it out 
299d 3e 5f				ld a, "_" 
299f 77					ld  (hl),a 
29a0			 
29a0			;		jr .fudone 
29a0			; 
29a0			;.fnuword:	pop hl 
29a0			;		call forth_tok_next 
29a0			;		jp .fdouscan  
29a0			 
29a0			.flunotfound:		  
29a0			 
29a0			 
29a0					 
29a0					FORTH_DSP_POP 
29a0 cd f7 1b			call macro_forth_dsp_pop 
29a3				endm 
# End of macro FORTH_DSP_POP
29a3			;		ld hl, .luno 
29a3			;.fudone:		 pop hl 
29a3					NEXTW 
29a3 c3 b1 1c			jp macro_next 
29a6				endm 
# End of macro NEXTW
29a6			.NOP: 
29a6				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
29a6 61				db WORD_SYS_CORE+77             
29a7 cd 29			dw .COMO            
29a9 04				db 3 + 1 
29aa .. 00			db "NOP",0              
29ae				endm 
# End of macro CWHEAD
29ae			; | NOP (  --  ) Do nothing | DONE 
29ae					if DEBUG_FORTH_WORDS_KEY 
29ae						DMARK "NOP" 
29ae f5				push af  
29af 3a c3 29			ld a, (.dmark)  
29b2 32 7a ee			ld (debug_mark),a  
29b5 3a c4 29			ld a, (.dmark+1)  
29b8 32 7b ee			ld (debug_mark+1),a  
29bb 3a c5 29			ld a, (.dmark+2)  
29be 32 7c ee			ld (debug_mark+2),a  
29c1 18 03			jr .pastdmark  
29c3 ..			.dmark: db "NOP"  
29c6 f1			.pastdmark: pop af  
29c7			endm  
# End of macro DMARK
29c7						CALLMONITOR 
29c7 cd bb 13			call break_point_state  
29ca				endm  
# End of macro CALLMONITOR
29ca					endif 
29ca				       NEXTW 
29ca c3 b1 1c			jp macro_next 
29cd				endm 
# End of macro NEXTW
29cd			.COMO: 
29cd				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
29cd 6e				db WORD_SYS_CORE+90             
29ce 1f 2a			dw .COMC            
29d0 02				db 1 + 1 
29d1 .. 00			db "(",0              
29d3				endm 
# End of macro CWHEAD
29d3			; | ( ( -- )  Start of comment | DONE 
29d3			 
29d3			 
29d3 2a 61 e6				ld hl, ( os_tok_ptr) 
29d6 11 1a 2a			ld de, .closepar 
29d9					 
29d9					if DEBUG_FORTH_WORDS 
29d9						DMARK ").." 
29d9 f5				push af  
29da 3a ee 29			ld a, (.dmark)  
29dd 32 7a ee			ld (debug_mark),a  
29e0 3a ef 29			ld a, (.dmark+1)  
29e3 32 7b ee			ld (debug_mark+1),a  
29e6 3a f0 29			ld a, (.dmark+2)  
29e9 32 7c ee			ld (debug_mark+2),a  
29ec 18 03			jr .pastdmark  
29ee ..			.dmark: db ").."  
29f1 f1			.pastdmark: pop af  
29f2			endm  
# End of macro DMARK
29f2						CALLMONITOR 
29f2 cd bb 13			call break_point_state  
29f5				endm  
# End of macro CALLMONITOR
29f5					endif 
29f5 cd cc 1d			call findnexttok  
29f8			 
29f8					if DEBUG_FORTH_WORDS 
29f8						DMARK "IF5" 
29f8 f5				push af  
29f9 3a 0d 2a			ld a, (.dmark)  
29fc 32 7a ee			ld (debug_mark),a  
29ff 3a 0e 2a			ld a, (.dmark+1)  
2a02 32 7b ee			ld (debug_mark+1),a  
2a05 3a 0f 2a			ld a, (.dmark+2)  
2a08 32 7c ee			ld (debug_mark+2),a  
2a0b 18 03			jr .pastdmark  
2a0d ..			.dmark: db "IF5"  
2a10 f1			.pastdmark: pop af  
2a11			endm  
# End of macro DMARK
2a11						CALLMONITOR 
2a11 cd bb 13			call break_point_state  
2a14				endm  
# End of macro CALLMONITOR
2a14					endif 
2a14				; replace below with ) exec using tok_ptr 
2a14 22 61 e6			ld (os_tok_ptr), hl 
2a17 c3 42 1d			jp exec1 
2a1a			 
2a1a .. 00			.closepar:   db ")",0 
2a1c			 
2a1c				       NEXTW 
2a1c c3 b1 1c			jp macro_next 
2a1f				endm 
# End of macro NEXTW
2a1f			.COMC: 
2a1f				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2a1f 6f				db WORD_SYS_CORE+91             
2a20 28 2a			dw .SCRATCH            
2a22 02				db 1 + 1 
2a23 .. 00			db ")",0              
2a25				endm 
# End of macro CWHEAD
2a25			; | ) ( -- )  End of comment |  DONE  
2a25				       NEXTW 
2a25 c3 b1 1c			jp macro_next 
2a28				endm 
# End of macro NEXTW
2a28			 
2a28			.SCRATCH: 
2a28				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2a28 6f				db WORD_SYS_CORE+91             
2a29 63 2a			dw .INC            
2a2b 08				db 7 + 1 
2a2c .. 00			db "SCRATCH",0              
2a34				endm 
# End of macro CWHEAD
2a34			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2a34			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2a34			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2a34			; | |  
2a34			; | | e.g.    : score $00 scratch ; 
2a34			; | |  
2a34			; | | $00 score ! 
2a34			; | | $01 score +! 
2a34			; | |  
2a34			; | | e.g.   : varword $0a scratch ;  
2a34			; | | 
2a34			; | | $8000 varword ! 
2a34					if DEBUG_FORTH_WORDS_KEY 
2a34						DMARK "SCR" 
2a34 f5				push af  
2a35 3a 49 2a			ld a, (.dmark)  
2a38 32 7a ee			ld (debug_mark),a  
2a3b 3a 4a 2a			ld a, (.dmark+1)  
2a3e 32 7b ee			ld (debug_mark+1),a  
2a41 3a 4b 2a			ld a, (.dmark+2)  
2a44 32 7c ee			ld (debug_mark+2),a  
2a47 18 03			jr .pastdmark  
2a49 ..			.dmark: db "SCR"  
2a4c f1			.pastdmark: pop af  
2a4d			endm  
# End of macro DMARK
2a4d						CALLMONITOR 
2a4d cd bb 13			call break_point_state  
2a50				endm  
# End of macro CALLMONITOR
2a50					endif 
2a50			 
2a50					FORTH_DSP_VALUEHL 
2a50 cd 3f 1b			call macro_dsp_valuehl 
2a53				endm 
# End of macro FORTH_DSP_VALUEHL
2a53				 
2a53					FORTH_DSP_POP 
2a53 cd f7 1b			call macro_forth_dsp_pop 
2a56				endm 
# End of macro FORTH_DSP_POP
2a56			 
2a56 7d					ld a, l 
2a57 21 85 e8				ld hl, os_var_array 
2a5a cd 74 0b				call addatohl 
2a5d			 
2a5d cd 48 19				call forth_push_numhl 
2a60			 
2a60				       NEXTW 
2a60 c3 b1 1c			jp macro_next 
2a63				endm 
# End of macro NEXTW
2a63			 
2a63			.INC: 
2a63				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2a63 6f				db WORD_SYS_CORE+91             
2a64 b7 2a			dw .DEC            
2a66 03				db 2 + 1 
2a67 .. 00			db "+!",0              
2a6a				endm 
# End of macro CWHEAD
2a6a			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2a6a					if DEBUG_FORTH_WORDS_KEY 
2a6a						DMARK "+s_" 
2a6a f5				push af  
2a6b 3a 7f 2a			ld a, (.dmark)  
2a6e 32 7a ee			ld (debug_mark),a  
2a71 3a 80 2a			ld a, (.dmark+1)  
2a74 32 7b ee			ld (debug_mark+1),a  
2a77 3a 81 2a			ld a, (.dmark+2)  
2a7a 32 7c ee			ld (debug_mark+2),a  
2a7d 18 03			jr .pastdmark  
2a7f ..			.dmark: db "+s_"  
2a82 f1			.pastdmark: pop af  
2a83			endm  
# End of macro DMARK
2a83						CALLMONITOR 
2a83 cd bb 13			call break_point_state  
2a86				endm  
# End of macro CALLMONITOR
2a86					endif 
2a86			 
2a86					FORTH_DSP_VALUEHL 
2a86 cd 3f 1b			call macro_dsp_valuehl 
2a89				endm 
# End of macro FORTH_DSP_VALUEHL
2a89			 
2a89 e5					push hl   ; save address 
2a8a			 
2a8a					FORTH_DSP_POP 
2a8a cd f7 1b			call macro_forth_dsp_pop 
2a8d				endm 
# End of macro FORTH_DSP_POP
2a8d			 
2a8d					FORTH_DSP_VALUEHL 
2a8d cd 3f 1b			call macro_dsp_valuehl 
2a90				endm 
# End of macro FORTH_DSP_VALUEHL
2a90			 
2a90					FORTH_DSP_POP 
2a90 cd f7 1b			call macro_forth_dsp_pop 
2a93				endm 
# End of macro FORTH_DSP_POP
2a93			 
2a93					; hl contains value to add to byte at a 
2a93				 
2a93 eb					ex de, hl 
2a94			 
2a94 e1					pop hl 
2a95			 
2a95					if DEBUG_FORTH_WORDS 
2a95						DMARK "INC" 
2a95 f5				push af  
2a96 3a aa 2a			ld a, (.dmark)  
2a99 32 7a ee			ld (debug_mark),a  
2a9c 3a ab 2a			ld a, (.dmark+1)  
2a9f 32 7b ee			ld (debug_mark+1),a  
2aa2 3a ac 2a			ld a, (.dmark+2)  
2aa5 32 7c ee			ld (debug_mark+2),a  
2aa8 18 03			jr .pastdmark  
2aaa ..			.dmark: db "INC"  
2aad f1			.pastdmark: pop af  
2aae			endm  
# End of macro DMARK
2aae						CALLMONITOR 
2aae cd bb 13			call break_point_state  
2ab1				endm  
# End of macro CALLMONITOR
2ab1					endif 
2ab1			 
2ab1 7e					ld a,(hl) 
2ab2 83					add e 
2ab3 77					ld (hl),a 
2ab4			 
2ab4			 
2ab4			 
2ab4				       NEXTW 
2ab4 c3 b1 1c			jp macro_next 
2ab7				endm 
# End of macro NEXTW
2ab7			 
2ab7			.DEC: 
2ab7				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2ab7 6f				db WORD_SYS_CORE+91             
2ab8 08 2b			dw .INC2            
2aba 03				db 2 + 1 
2abb .. 00			db "-!",0              
2abe				endm 
# End of macro CWHEAD
2abe			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2abe					if DEBUG_FORTH_WORDS_KEY 
2abe						DMARK "-s_" 
2abe f5				push af  
2abf 3a d3 2a			ld a, (.dmark)  
2ac2 32 7a ee			ld (debug_mark),a  
2ac5 3a d4 2a			ld a, (.dmark+1)  
2ac8 32 7b ee			ld (debug_mark+1),a  
2acb 3a d5 2a			ld a, (.dmark+2)  
2ace 32 7c ee			ld (debug_mark+2),a  
2ad1 18 03			jr .pastdmark  
2ad3 ..			.dmark: db "-s_"  
2ad6 f1			.pastdmark: pop af  
2ad7			endm  
# End of macro DMARK
2ad7						CALLMONITOR 
2ad7 cd bb 13			call break_point_state  
2ada				endm  
# End of macro CALLMONITOR
2ada					endif 
2ada			 
2ada					FORTH_DSP_VALUEHL 
2ada cd 3f 1b			call macro_dsp_valuehl 
2add				endm 
# End of macro FORTH_DSP_VALUEHL
2add			 
2add e5					push hl   ; save address 
2ade			 
2ade					FORTH_DSP_POP 
2ade cd f7 1b			call macro_forth_dsp_pop 
2ae1				endm 
# End of macro FORTH_DSP_POP
2ae1			 
2ae1					FORTH_DSP_VALUEHL 
2ae1 cd 3f 1b			call macro_dsp_valuehl 
2ae4				endm 
# End of macro FORTH_DSP_VALUEHL
2ae4			 
2ae4					; hl contains value to add to byte at a 
2ae4				 
2ae4 eb					ex de, hl 
2ae5			 
2ae5 e1					pop hl 
2ae6			 
2ae6					if DEBUG_FORTH_WORDS 
2ae6						DMARK "DEC" 
2ae6 f5				push af  
2ae7 3a fb 2a			ld a, (.dmark)  
2aea 32 7a ee			ld (debug_mark),a  
2aed 3a fc 2a			ld a, (.dmark+1)  
2af0 32 7b ee			ld (debug_mark+1),a  
2af3 3a fd 2a			ld a, (.dmark+2)  
2af6 32 7c ee			ld (debug_mark+2),a  
2af9 18 03			jr .pastdmark  
2afb ..			.dmark: db "DEC"  
2afe f1			.pastdmark: pop af  
2aff			endm  
# End of macro DMARK
2aff						CALLMONITOR 
2aff cd bb 13			call break_point_state  
2b02				endm  
# End of macro CALLMONITOR
2b02					endif 
2b02			 
2b02 7e					ld a,(hl) 
2b03 93					sub e 
2b04 77					ld (hl),a 
2b05			 
2b05			 
2b05			 
2b05				       NEXTW 
2b05 c3 b1 1c			jp macro_next 
2b08				endm 
# End of macro NEXTW
2b08			 
2b08			.INC2: 
2b08				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2b08 6f				db WORD_SYS_CORE+91             
2b09 b2 2b			dw .DEC2            
2b0b 04				db 3 + 1 
2b0c .. 00			db "+2!",0              
2b10				endm 
# End of macro CWHEAD
2b10			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2b10			 
2b10					if DEBUG_FORTH_WORDS_KEY 
2b10						DMARK "+2s" 
2b10 f5				push af  
2b11 3a 25 2b			ld a, (.dmark)  
2b14 32 7a ee			ld (debug_mark),a  
2b17 3a 26 2b			ld a, (.dmark+1)  
2b1a 32 7b ee			ld (debug_mark+1),a  
2b1d 3a 27 2b			ld a, (.dmark+2)  
2b20 32 7c ee			ld (debug_mark+2),a  
2b23 18 03			jr .pastdmark  
2b25 ..			.dmark: db "+2s"  
2b28 f1			.pastdmark: pop af  
2b29			endm  
# End of macro DMARK
2b29						CALLMONITOR 
2b29 cd bb 13			call break_point_state  
2b2c				endm  
# End of macro CALLMONITOR
2b2c					endif 
2b2c			 
2b2c					; Address 
2b2c			 
2b2c					FORTH_DSP_VALUEHL 
2b2c cd 3f 1b			call macro_dsp_valuehl 
2b2f				endm 
# End of macro FORTH_DSP_VALUEHL
2b2f			 
2b2f e5					push hl    ; save address 
2b30			 
2b30					; load content into de 
2b30			 
2b30 5e					ld e,(hl) 
2b31 23					inc hl 
2b32 56					ld d, (hl) 
2b33			 
2b33					if DEBUG_FORTH_WORDS 
2b33						DMARK "+2a" 
2b33 f5				push af  
2b34 3a 48 2b			ld a, (.dmark)  
2b37 32 7a ee			ld (debug_mark),a  
2b3a 3a 49 2b			ld a, (.dmark+1)  
2b3d 32 7b ee			ld (debug_mark+1),a  
2b40 3a 4a 2b			ld a, (.dmark+2)  
2b43 32 7c ee			ld (debug_mark+2),a  
2b46 18 03			jr .pastdmark  
2b48 ..			.dmark: db "+2a"  
2b4b f1			.pastdmark: pop af  
2b4c			endm  
# End of macro DMARK
2b4c						CALLMONITOR 
2b4c cd bb 13			call break_point_state  
2b4f				endm  
# End of macro CALLMONITOR
2b4f					endif 
2b4f			 
2b4f					FORTH_DSP_POP 
2b4f cd f7 1b			call macro_forth_dsp_pop 
2b52				endm 
# End of macro FORTH_DSP_POP
2b52			 
2b52					; Get value to add 
2b52			 
2b52					FORTH_DSP_VALUE 
2b52 cd 28 1b			call macro_forth_dsp_value 
2b55				endm 
# End of macro FORTH_DSP_VALUE
2b55			 
2b55					if DEBUG_FORTH_WORDS 
2b55						DMARK "+2v" 
2b55 f5				push af  
2b56 3a 6a 2b			ld a, (.dmark)  
2b59 32 7a ee			ld (debug_mark),a  
2b5c 3a 6b 2b			ld a, (.dmark+1)  
2b5f 32 7b ee			ld (debug_mark+1),a  
2b62 3a 6c 2b			ld a, (.dmark+2)  
2b65 32 7c ee			ld (debug_mark+2),a  
2b68 18 03			jr .pastdmark  
2b6a ..			.dmark: db "+2v"  
2b6d f1			.pastdmark: pop af  
2b6e			endm  
# End of macro DMARK
2b6e						CALLMONITOR 
2b6e cd bb 13			call break_point_state  
2b71				endm  
# End of macro CALLMONITOR
2b71					endif 
2b71			 
2b71 19					add hl, de 
2b72			 
2b72					if DEBUG_FORTH_WORDS 
2b72						DMARK "+2+" 
2b72 f5				push af  
2b73 3a 87 2b			ld a, (.dmark)  
2b76 32 7a ee			ld (debug_mark),a  
2b79 3a 88 2b			ld a, (.dmark+1)  
2b7c 32 7b ee			ld (debug_mark+1),a  
2b7f 3a 89 2b			ld a, (.dmark+2)  
2b82 32 7c ee			ld (debug_mark+2),a  
2b85 18 03			jr .pastdmark  
2b87 ..			.dmark: db "+2+"  
2b8a f1			.pastdmark: pop af  
2b8b			endm  
# End of macro DMARK
2b8b						CALLMONITOR 
2b8b cd bb 13			call break_point_state  
2b8e				endm  
# End of macro CALLMONITOR
2b8e					endif 
2b8e			 
2b8e					; move result to de 
2b8e			 
2b8e eb					ex de, hl 
2b8f			 
2b8f					; Address 
2b8f			 
2b8f e1					pop hl 
2b90			 
2b90					; save it back 
2b90			 
2b90 73					ld (hl), e 
2b91 23					inc hl 
2b92 72					ld (hl), d 
2b93			 
2b93					if DEBUG_FORTH_WORDS 
2b93						DMARK "+2e" 
2b93 f5				push af  
2b94 3a a8 2b			ld a, (.dmark)  
2b97 32 7a ee			ld (debug_mark),a  
2b9a 3a a9 2b			ld a, (.dmark+1)  
2b9d 32 7b ee			ld (debug_mark+1),a  
2ba0 3a aa 2b			ld a, (.dmark+2)  
2ba3 32 7c ee			ld (debug_mark+2),a  
2ba6 18 03			jr .pastdmark  
2ba8 ..			.dmark: db "+2e"  
2bab f1			.pastdmark: pop af  
2bac			endm  
# End of macro DMARK
2bac						CALLMONITOR 
2bac cd bb 13			call break_point_state  
2baf				endm  
# End of macro CALLMONITOR
2baf					endif 
2baf			 
2baf			 
2baf			 
2baf			 
2baf			 
2baf				       NEXTW 
2baf c3 b1 1c			jp macro_next 
2bb2				endm 
# End of macro NEXTW
2bb2			 
2bb2			.DEC2: 
2bb2				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2bb2 6f				db WORD_SYS_CORE+91             
2bb3 5e 2c			dw .GET2            
2bb5 04				db 3 + 1 
2bb6 .. 00			db "-2!",0              
2bba				endm 
# End of macro CWHEAD
2bba			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2bba			 
2bba			 
2bba					if DEBUG_FORTH_WORDS_KEY 
2bba						DMARK "-2s" 
2bba f5				push af  
2bbb 3a cf 2b			ld a, (.dmark)  
2bbe 32 7a ee			ld (debug_mark),a  
2bc1 3a d0 2b			ld a, (.dmark+1)  
2bc4 32 7b ee			ld (debug_mark+1),a  
2bc7 3a d1 2b			ld a, (.dmark+2)  
2bca 32 7c ee			ld (debug_mark+2),a  
2bcd 18 03			jr .pastdmark  
2bcf ..			.dmark: db "-2s"  
2bd2 f1			.pastdmark: pop af  
2bd3			endm  
# End of macro DMARK
2bd3						CALLMONITOR 
2bd3 cd bb 13			call break_point_state  
2bd6				endm  
# End of macro CALLMONITOR
2bd6					endif 
2bd6			 
2bd6					; Address 
2bd6			 
2bd6					FORTH_DSP_VALUEHL 
2bd6 cd 3f 1b			call macro_dsp_valuehl 
2bd9				endm 
# End of macro FORTH_DSP_VALUEHL
2bd9			 
2bd9 e5					push hl    ; save address 
2bda			 
2bda					; load content into de 
2bda			 
2bda 5e					ld e,(hl) 
2bdb 23					inc hl 
2bdc 56					ld d, (hl) 
2bdd			 
2bdd					if DEBUG_FORTH_WORDS 
2bdd						DMARK "-2a" 
2bdd f5				push af  
2bde 3a f2 2b			ld a, (.dmark)  
2be1 32 7a ee			ld (debug_mark),a  
2be4 3a f3 2b			ld a, (.dmark+1)  
2be7 32 7b ee			ld (debug_mark+1),a  
2bea 3a f4 2b			ld a, (.dmark+2)  
2bed 32 7c ee			ld (debug_mark+2),a  
2bf0 18 03			jr .pastdmark  
2bf2 ..			.dmark: db "-2a"  
2bf5 f1			.pastdmark: pop af  
2bf6			endm  
# End of macro DMARK
2bf6						CALLMONITOR 
2bf6 cd bb 13			call break_point_state  
2bf9				endm  
# End of macro CALLMONITOR
2bf9					endif 
2bf9			 
2bf9					FORTH_DSP_POP 
2bf9 cd f7 1b			call macro_forth_dsp_pop 
2bfc				endm 
# End of macro FORTH_DSP_POP
2bfc			 
2bfc					; Get value to remove 
2bfc			 
2bfc					FORTH_DSP_VALUE 
2bfc cd 28 1b			call macro_forth_dsp_value 
2bff				endm 
# End of macro FORTH_DSP_VALUE
2bff			 
2bff					if DEBUG_FORTH_WORDS 
2bff						DMARK "-2v" 
2bff f5				push af  
2c00 3a 14 2c			ld a, (.dmark)  
2c03 32 7a ee			ld (debug_mark),a  
2c06 3a 15 2c			ld a, (.dmark+1)  
2c09 32 7b ee			ld (debug_mark+1),a  
2c0c 3a 16 2c			ld a, (.dmark+2)  
2c0f 32 7c ee			ld (debug_mark+2),a  
2c12 18 03			jr .pastdmark  
2c14 ..			.dmark: db "-2v"  
2c17 f1			.pastdmark: pop af  
2c18			endm  
# End of macro DMARK
2c18						CALLMONITOR 
2c18 cd bb 13			call break_point_state  
2c1b				endm  
# End of macro CALLMONITOR
2c1b					endif 
2c1b			 
2c1b eb					ex de, hl 
2c1c ed 52				sbc hl, de 
2c1e			 
2c1e					if DEBUG_FORTH_WORDS 
2c1e						DMARK "-2d" 
2c1e f5				push af  
2c1f 3a 33 2c			ld a, (.dmark)  
2c22 32 7a ee			ld (debug_mark),a  
2c25 3a 34 2c			ld a, (.dmark+1)  
2c28 32 7b ee			ld (debug_mark+1),a  
2c2b 3a 35 2c			ld a, (.dmark+2)  
2c2e 32 7c ee			ld (debug_mark+2),a  
2c31 18 03			jr .pastdmark  
2c33 ..			.dmark: db "-2d"  
2c36 f1			.pastdmark: pop af  
2c37			endm  
# End of macro DMARK
2c37						CALLMONITOR 
2c37 cd bb 13			call break_point_state  
2c3a				endm  
# End of macro CALLMONITOR
2c3a					endif 
2c3a			 
2c3a					; move result to de 
2c3a			 
2c3a eb					ex de, hl 
2c3b			 
2c3b					; Address 
2c3b			 
2c3b e1					pop hl 
2c3c			 
2c3c					; save it back 
2c3c			 
2c3c 73					ld (hl), e 
2c3d 23					inc hl 
2c3e 72					ld (hl), d 
2c3f			 
2c3f					if DEBUG_FORTH_WORDS 
2c3f						DMARK "-2e" 
2c3f f5				push af  
2c40 3a 54 2c			ld a, (.dmark)  
2c43 32 7a ee			ld (debug_mark),a  
2c46 3a 55 2c			ld a, (.dmark+1)  
2c49 32 7b ee			ld (debug_mark+1),a  
2c4c 3a 56 2c			ld a, (.dmark+2)  
2c4f 32 7c ee			ld (debug_mark+2),a  
2c52 18 03			jr .pastdmark  
2c54 ..			.dmark: db "-2e"  
2c57 f1			.pastdmark: pop af  
2c58			endm  
# End of macro DMARK
2c58						CALLMONITOR 
2c58 cd bb 13			call break_point_state  
2c5b				endm  
# End of macro CALLMONITOR
2c5b					endif 
2c5b			 
2c5b			 
2c5b			 
2c5b			 
2c5b			 
2c5b				       NEXTW 
2c5b c3 b1 1c			jp macro_next 
2c5e				endm 
# End of macro NEXTW
2c5e			.GET2: 
2c5e				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2c5e 6f				db WORD_SYS_CORE+91             
2c5f 8e 2c			dw .BANG2            
2c61 03				db 2 + 1 
2c62 .. 00			db "2@",0              
2c65				endm 
# End of macro CWHEAD
2c65			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2c65					if DEBUG_FORTH_WORDS_KEY 
2c65						DMARK "2A_" 
2c65 f5				push af  
2c66 3a 7a 2c			ld a, (.dmark)  
2c69 32 7a ee			ld (debug_mark),a  
2c6c 3a 7b 2c			ld a, (.dmark+1)  
2c6f 32 7b ee			ld (debug_mark+1),a  
2c72 3a 7c 2c			ld a, (.dmark+2)  
2c75 32 7c ee			ld (debug_mark+2),a  
2c78 18 03			jr .pastdmark  
2c7a ..			.dmark: db "2A_"  
2c7d f1			.pastdmark: pop af  
2c7e			endm  
# End of macro DMARK
2c7e						CALLMONITOR 
2c7e cd bb 13			call break_point_state  
2c81				endm  
# End of macro CALLMONITOR
2c81					endif 
2c81			 
2c81					FORTH_DSP_VALUEHL 
2c81 cd 3f 1b			call macro_dsp_valuehl 
2c84				endm 
# End of macro FORTH_DSP_VALUEHL
2c84			 
2c84 5e					ld e, (hl) 
2c85 23					inc hl 
2c86 56					ld d, (hl) 
2c87			 
2c87 eb					ex de, hl 
2c88			 
2c88 cd 48 19				call forth_push_numhl 
2c8b			 
2c8b				       NEXTW 
2c8b c3 b1 1c			jp macro_next 
2c8e				endm 
# End of macro NEXTW
2c8e			.BANG2: 
2c8e				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2c8e 6f				db WORD_SYS_CORE+91             
2c8f c6 2c			dw .CONFIG            
2c91 03				db 2 + 1 
2c92 .. 00			db "2!",0              
2c95				endm 
# End of macro CWHEAD
2c95			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2c95					if DEBUG_FORTH_WORDS_KEY 
2c95						DMARK "2S_" 
2c95 f5				push af  
2c96 3a aa 2c			ld a, (.dmark)  
2c99 32 7a ee			ld (debug_mark),a  
2c9c 3a ab 2c			ld a, (.dmark+1)  
2c9f 32 7b ee			ld (debug_mark+1),a  
2ca2 3a ac 2c			ld a, (.dmark+2)  
2ca5 32 7c ee			ld (debug_mark+2),a  
2ca8 18 03			jr .pastdmark  
2caa ..			.dmark: db "2S_"  
2cad f1			.pastdmark: pop af  
2cae			endm  
# End of macro DMARK
2cae						CALLMONITOR 
2cae cd bb 13			call break_point_state  
2cb1				endm  
# End of macro CALLMONITOR
2cb1					endif 
2cb1			 
2cb1					FORTH_DSP_VALUEHL 
2cb1 cd 3f 1b			call macro_dsp_valuehl 
2cb4				endm 
# End of macro FORTH_DSP_VALUEHL
2cb4			 
2cb4 e5					push hl   ; save address 
2cb5			 
2cb5			 
2cb5					FORTH_DSP_POP 
2cb5 cd f7 1b			call macro_forth_dsp_pop 
2cb8				endm 
# End of macro FORTH_DSP_POP
2cb8			 
2cb8					 
2cb8					FORTH_DSP_VALUEHL 
2cb8 cd 3f 1b			call macro_dsp_valuehl 
2cbb				endm 
# End of macro FORTH_DSP_VALUEHL
2cbb			 
2cbb					FORTH_DSP_POP 
2cbb cd f7 1b			call macro_forth_dsp_pop 
2cbe				endm 
# End of macro FORTH_DSP_POP
2cbe			 
2cbe eb					ex de, hl    ; value now in de 
2cbf			 
2cbf e1					pop hl 
2cc0			 
2cc0 73					ld (hl), e 
2cc1			 
2cc1 23					inc hl 
2cc2			 
2cc2 72					ld (hl), d 
2cc3			 
2cc3			 
2cc3				       NEXTW 
2cc3 c3 b1 1c			jp macro_next 
2cc6				endm 
# End of macro NEXTW
2cc6			.CONFIG: 
2cc6				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
2cc6 6f				db WORD_SYS_CORE+91             
2cc7 d7 2c			dw .ENDCORE            
2cc9 07				db 6 + 1 
2cca .. 00			db "CONFIG",0              
2cd1				endm 
# End of macro CWHEAD
2cd1			; | CONFIG ( -- )  Access the system configuration menu | TO DO 
2cd1			 
2cd1 cd d4 11				call config 
2cd4					NEXTW 
2cd4 c3 b1 1c			jp macro_next 
2cd7				endm 
# End of macro NEXTW
2cd7			.ENDCORE: 
2cd7			 
2cd7			; eof 
2cd7			 
2cd7			 
# End of file forth_words_core.asm
2cd7			include "forth_words_flow.asm" 
2cd7			 
2cd7			; | ## Program Flow Words 
2cd7			 
2cd7			.IF: 
2cd7				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2cd7 1e				db WORD_SYS_CORE+10             
2cd8 cc 2d			dw .THEN            
2cda 03				db 2 + 1 
2cdb .. 00			db "IF",0              
2cde				endm 
# End of macro CWHEAD
2cde			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2cde			; 
2cde					if DEBUG_FORTH_WORDS_KEY 
2cde						DMARK "IF." 
2cde f5				push af  
2cdf 3a f3 2c			ld a, (.dmark)  
2ce2 32 7a ee			ld (debug_mark),a  
2ce5 3a f4 2c			ld a, (.dmark+1)  
2ce8 32 7b ee			ld (debug_mark+1),a  
2ceb 3a f5 2c			ld a, (.dmark+2)  
2cee 32 7c ee			ld (debug_mark+2),a  
2cf1 18 03			jr .pastdmark  
2cf3 ..			.dmark: db "IF."  
2cf6 f1			.pastdmark: pop af  
2cf7			endm  
# End of macro DMARK
2cf7						CALLMONITOR 
2cf7 cd bb 13			call break_point_state  
2cfa				endm  
# End of macro CALLMONITOR
2cfa					endif 
2cfa			; eval TOS 
2cfa			 
2cfa				FORTH_DSP_VALUEHL 
2cfa cd 3f 1b			call macro_dsp_valuehl 
2cfd				endm 
# End of macro FORTH_DSP_VALUEHL
2cfd			 
2cfd			;	push hl 
2cfd				FORTH_DSP_POP 
2cfd cd f7 1b			call macro_forth_dsp_pop 
2d00				endm 
# End of macro FORTH_DSP_POP
2d00			;	pop hl 
2d00			 
2d00					if DEBUG_FORTH_WORDS 
2d00						DMARK "IF1" 
2d00 f5				push af  
2d01 3a 15 2d			ld a, (.dmark)  
2d04 32 7a ee			ld (debug_mark),a  
2d07 3a 16 2d			ld a, (.dmark+1)  
2d0a 32 7b ee			ld (debug_mark+1),a  
2d0d 3a 17 2d			ld a, (.dmark+2)  
2d10 32 7c ee			ld (debug_mark+2),a  
2d13 18 03			jr .pastdmark  
2d15 ..			.dmark: db "IF1"  
2d18 f1			.pastdmark: pop af  
2d19			endm  
# End of macro DMARK
2d19						CALLMONITOR 
2d19 cd bb 13			call break_point_state  
2d1c				endm  
# End of macro CALLMONITOR
2d1c					endif 
2d1c b7				or a        ; clear carry flag 
2d1d 11 00 00			ld de, 0 
2d20 eb				ex de,hl 
2d21 ed 52			sbc hl, de 
2d23 c2 ad 2d			jp nz, .iftrue 
2d26			 
2d26					if DEBUG_FORTH_WORDS 
2d26						DMARK "IF2" 
2d26 f5				push af  
2d27 3a 3b 2d			ld a, (.dmark)  
2d2a 32 7a ee			ld (debug_mark),a  
2d2d 3a 3c 2d			ld a, (.dmark+1)  
2d30 32 7b ee			ld (debug_mark+1),a  
2d33 3a 3d 2d			ld a, (.dmark+2)  
2d36 32 7c ee			ld (debug_mark+2),a  
2d39 18 03			jr .pastdmark  
2d3b ..			.dmark: db "IF2"  
2d3e f1			.pastdmark: pop af  
2d3f			endm  
# End of macro DMARK
2d3f						CALLMONITOR 
2d3f cd bb 13			call break_point_state  
2d42				endm  
# End of macro CALLMONITOR
2d42					endif 
2d42			 
2d42			; if not true then skip to THEN 
2d42			 
2d42				; TODO get tok_ptr 
2d42				; TODO consume toks until we get to THEN 
2d42			 
2d42 2a 61 e6			ld hl, (os_tok_ptr) 
2d45					if DEBUG_FORTH_WORDS 
2d45						DMARK "IF3" 
2d45 f5				push af  
2d46 3a 5a 2d			ld a, (.dmark)  
2d49 32 7a ee			ld (debug_mark),a  
2d4c 3a 5b 2d			ld a, (.dmark+1)  
2d4f 32 7b ee			ld (debug_mark+1),a  
2d52 3a 5c 2d			ld a, (.dmark+2)  
2d55 32 7c ee			ld (debug_mark+2),a  
2d58 18 03			jr .pastdmark  
2d5a ..			.dmark: db "IF3"  
2d5d f1			.pastdmark: pop af  
2d5e			endm  
# End of macro DMARK
2d5e						CALLMONITOR 
2d5e cd bb 13			call break_point_state  
2d61				endm  
# End of macro CALLMONITOR
2d61						 
2d61					endif 
2d61 11 a8 2d			ld de, .ifthen 
2d64					if DEBUG_FORTH_WORDS 
2d64						DMARK "IF4" 
2d64 f5				push af  
2d65 3a 79 2d			ld a, (.dmark)  
2d68 32 7a ee			ld (debug_mark),a  
2d6b 3a 7a 2d			ld a, (.dmark+1)  
2d6e 32 7b ee			ld (debug_mark+1),a  
2d71 3a 7b 2d			ld a, (.dmark+2)  
2d74 32 7c ee			ld (debug_mark+2),a  
2d77 18 03			jr .pastdmark  
2d79 ..			.dmark: db "IF4"  
2d7c f1			.pastdmark: pop af  
2d7d			endm  
# End of macro DMARK
2d7d						CALLMONITOR 
2d7d cd bb 13			call break_point_state  
2d80				endm  
# End of macro CALLMONITOR
2d80					endif 
2d80 cd cc 1d			call findnexttok  
2d83			 
2d83					if DEBUG_FORTH_WORDS 
2d83						DMARK "IF5" 
2d83 f5				push af  
2d84 3a 98 2d			ld a, (.dmark)  
2d87 32 7a ee			ld (debug_mark),a  
2d8a 3a 99 2d			ld a, (.dmark+1)  
2d8d 32 7b ee			ld (debug_mark+1),a  
2d90 3a 9a 2d			ld a, (.dmark+2)  
2d93 32 7c ee			ld (debug_mark+2),a  
2d96 18 03			jr .pastdmark  
2d98 ..			.dmark: db "IF5"  
2d9b f1			.pastdmark: pop af  
2d9c			endm  
# End of macro DMARK
2d9c						CALLMONITOR 
2d9c cd bb 13			call break_point_state  
2d9f				endm  
# End of macro CALLMONITOR
2d9f					endif 
2d9f				; TODO replace below with ; exec using tok_ptr 
2d9f 22 61 e6			ld (os_tok_ptr), hl 
2da2 c3 42 1d			jp exec1 
2da5				NEXTW 
2da5 c3 b1 1c			jp macro_next 
2da8				endm 
# End of macro NEXTW
2da8			 
2da8 .. 00		.ifthen:  db "THEN",0 
2dad			 
2dad			.iftrue:		 
2dad				; Exec next words normally 
2dad			 
2dad				; if true then exec following IF as normal 
2dad					if DEBUG_FORTH_WORDS 
2dad						DMARK "IFT" 
2dad f5				push af  
2dae 3a c2 2d			ld a, (.dmark)  
2db1 32 7a ee			ld (debug_mark),a  
2db4 3a c3 2d			ld a, (.dmark+1)  
2db7 32 7b ee			ld (debug_mark+1),a  
2dba 3a c4 2d			ld a, (.dmark+2)  
2dbd 32 7c ee			ld (debug_mark+2),a  
2dc0 18 03			jr .pastdmark  
2dc2 ..			.dmark: db "IFT"  
2dc5 f1			.pastdmark: pop af  
2dc6			endm  
# End of macro DMARK
2dc6						CALLMONITOR 
2dc6 cd bb 13			call break_point_state  
2dc9				endm  
# End of macro CALLMONITOR
2dc9					endif 
2dc9			 
2dc9					NEXTW 
2dc9 c3 b1 1c			jp macro_next 
2dcc				endm 
# End of macro NEXTW
2dcc			.THEN: 
2dcc				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
2dcc 1f				db WORD_SYS_CORE+11             
2dcd f4 2d			dw .ELSE            
2dcf 05				db 4 + 1 
2dd0 .. 00			db "THEN",0              
2dd5				endm 
# End of macro CWHEAD
2dd5			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
2dd5					if DEBUG_FORTH_WORDS_KEY 
2dd5						DMARK "THN" 
2dd5 f5				push af  
2dd6 3a ea 2d			ld a, (.dmark)  
2dd9 32 7a ee			ld (debug_mark),a  
2ddc 3a eb 2d			ld a, (.dmark+1)  
2ddf 32 7b ee			ld (debug_mark+1),a  
2de2 3a ec 2d			ld a, (.dmark+2)  
2de5 32 7c ee			ld (debug_mark+2),a  
2de8 18 03			jr .pastdmark  
2dea ..			.dmark: db "THN"  
2ded f1			.pastdmark: pop af  
2dee			endm  
# End of macro DMARK
2dee						CALLMONITOR 
2dee cd bb 13			call break_point_state  
2df1				endm  
# End of macro CALLMONITOR
2df1					endif 
2df1					NEXTW 
2df1 c3 b1 1c			jp macro_next 
2df4				endm 
# End of macro NEXTW
2df4			.ELSE: 
2df4				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
2df4 20				db WORD_SYS_CORE+12             
2df5 1c 2e			dw .DO            
2df7 03				db 2 + 1 
2df8 .. 00			db "ELSE",0              
2dfd				endm 
# End of macro CWHEAD
2dfd			; | ELSE ( -- ) Not supported - does nothing | TODO 
2dfd			 
2dfd					if DEBUG_FORTH_WORDS_KEY 
2dfd						DMARK "ELS" 
2dfd f5				push af  
2dfe 3a 12 2e			ld a, (.dmark)  
2e01 32 7a ee			ld (debug_mark),a  
2e04 3a 13 2e			ld a, (.dmark+1)  
2e07 32 7b ee			ld (debug_mark+1),a  
2e0a 3a 14 2e			ld a, (.dmark+2)  
2e0d 32 7c ee			ld (debug_mark+2),a  
2e10 18 03			jr .pastdmark  
2e12 ..			.dmark: db "ELS"  
2e15 f1			.pastdmark: pop af  
2e16			endm  
# End of macro DMARK
2e16						CALLMONITOR 
2e16 cd bb 13			call break_point_state  
2e19				endm  
# End of macro CALLMONITOR
2e19					endif 
2e19			 
2e19			 
2e19					NEXTW 
2e19 c3 b1 1c			jp macro_next 
2e1c				endm 
# End of macro NEXTW
2e1c			.DO: 
2e1c				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
2e1c 21				db WORD_SYS_CORE+13             
2e1d 43 2f			dw .LOOP            
2e1f 03				db 2 + 1 
2e20 .. 00			db "DO",0              
2e23				endm 
# End of macro CWHEAD
2e23			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
2e23			 
2e23					if DEBUG_FORTH_WORDS_KEY 
2e23						DMARK "DO." 
2e23 f5				push af  
2e24 3a 38 2e			ld a, (.dmark)  
2e27 32 7a ee			ld (debug_mark),a  
2e2a 3a 39 2e			ld a, (.dmark+1)  
2e2d 32 7b ee			ld (debug_mark+1),a  
2e30 3a 3a 2e			ld a, (.dmark+2)  
2e33 32 7c ee			ld (debug_mark+2),a  
2e36 18 03			jr .pastdmark  
2e38 ..			.dmark: db "DO."  
2e3b f1			.pastdmark: pop af  
2e3c			endm  
# End of macro DMARK
2e3c						CALLMONITOR 
2e3c cd bb 13			call break_point_state  
2e3f				endm  
# End of macro CALLMONITOR
2e3f					endif 
2e3f			;  push pc to rsp stack past the DO 
2e3f			 
2e3f 2a 61 e6				ld hl, (os_tok_ptr) 
2e42 23					inc hl   ; D 
2e43 23					inc hl  ; O 
2e44 23					inc hl   ; null 
2e45					if DEBUG_FORTH_WORDS 
2e45						DMARK "DO2" 
2e45 f5				push af  
2e46 3a 5a 2e			ld a, (.dmark)  
2e49 32 7a ee			ld (debug_mark),a  
2e4c 3a 5b 2e			ld a, (.dmark+1)  
2e4f 32 7b ee			ld (debug_mark+1),a  
2e52 3a 5c 2e			ld a, (.dmark+2)  
2e55 32 7c ee			ld (debug_mark+2),a  
2e58 18 03			jr .pastdmark  
2e5a ..			.dmark: db "DO2"  
2e5d f1			.pastdmark: pop af  
2e5e			endm  
# End of macro DMARK
2e5e						CALLMONITOR 
2e5e cd bb 13			call break_point_state  
2e61				endm  
# End of macro CALLMONITOR
2e61					endif 
2e61					FORTH_RSP_NEXT 
2e61 cd ef 18			call macro_forth_rsp_next 
2e64				endm 
# End of macro FORTH_RSP_NEXT
2e64					if DEBUG_FORTH_WORDS 
2e64						DMARK "DO3" 
2e64 f5				push af  
2e65 3a 79 2e			ld a, (.dmark)  
2e68 32 7a ee			ld (debug_mark),a  
2e6b 3a 7a 2e			ld a, (.dmark+1)  
2e6e 32 7b ee			ld (debug_mark+1),a  
2e71 3a 7b 2e			ld a, (.dmark+2)  
2e74 32 7c ee			ld (debug_mark+2),a  
2e77 18 03			jr .pastdmark  
2e79 ..			.dmark: db "DO3"  
2e7c f1			.pastdmark: pop af  
2e7d			endm  
# End of macro DMARK
2e7d						CALLMONITOR 
2e7d cd bb 13			call break_point_state  
2e80				endm  
# End of macro CALLMONITOR
2e80					endif 
2e80			 
2e80					;if DEBUG_FORTH_WORDS 
2e80				;		push hl 
2e80			;		endif  
2e80			 
2e80			; get counters from data stack 
2e80			 
2e80			 
2e80					FORTH_DSP_VALUEHL 
2e80 cd 3f 1b			call macro_dsp_valuehl 
2e83				endm 
# End of macro FORTH_DSP_VALUEHL
2e83 e5					push hl		 ; hl now has starting counter which needs to be tos 
2e84			 
2e84					if DEBUG_FORTH_WORDS 
2e84						DMARK "DO4" 
2e84 f5				push af  
2e85 3a 99 2e			ld a, (.dmark)  
2e88 32 7a ee			ld (debug_mark),a  
2e8b 3a 9a 2e			ld a, (.dmark+1)  
2e8e 32 7b ee			ld (debug_mark+1),a  
2e91 3a 9b 2e			ld a, (.dmark+2)  
2e94 32 7c ee			ld (debug_mark+2),a  
2e97 18 03			jr .pastdmark  
2e99 ..			.dmark: db "DO4"  
2e9c f1			.pastdmark: pop af  
2e9d			endm  
# End of macro DMARK
2e9d						CALLMONITOR 
2e9d cd bb 13			call break_point_state  
2ea0				endm  
# End of macro CALLMONITOR
2ea0					endif 
2ea0					FORTH_DSP_POP 
2ea0 cd f7 1b			call macro_forth_dsp_pop 
2ea3				endm 
# End of macro FORTH_DSP_POP
2ea3			 
2ea3					if DEBUG_FORTH_WORDS 
2ea3						DMARK "DO5" 
2ea3 f5				push af  
2ea4 3a b8 2e			ld a, (.dmark)  
2ea7 32 7a ee			ld (debug_mark),a  
2eaa 3a b9 2e			ld a, (.dmark+1)  
2ead 32 7b ee			ld (debug_mark+1),a  
2eb0 3a ba 2e			ld a, (.dmark+2)  
2eb3 32 7c ee			ld (debug_mark+2),a  
2eb6 18 03			jr .pastdmark  
2eb8 ..			.dmark: db "DO5"  
2ebb f1			.pastdmark: pop af  
2ebc			endm  
# End of macro DMARK
2ebc						CALLMONITOR 
2ebc cd bb 13			call break_point_state  
2ebf				endm  
# End of macro CALLMONITOR
2ebf					endif 
2ebf			 
2ebf					FORTH_DSP_VALUEHL 
2ebf cd 3f 1b			call macro_dsp_valuehl 
2ec2				endm 
# End of macro FORTH_DSP_VALUEHL
2ec2			;		push hl		 ; hl now has starting limit counter 
2ec2			 
2ec2					if DEBUG_FORTH_WORDS 
2ec2						DMARK "DO6" 
2ec2 f5				push af  
2ec3 3a d7 2e			ld a, (.dmark)  
2ec6 32 7a ee			ld (debug_mark),a  
2ec9 3a d8 2e			ld a, (.dmark+1)  
2ecc 32 7b ee			ld (debug_mark+1),a  
2ecf 3a d9 2e			ld a, (.dmark+2)  
2ed2 32 7c ee			ld (debug_mark+2),a  
2ed5 18 03			jr .pastdmark  
2ed7 ..			.dmark: db "DO6"  
2eda f1			.pastdmark: pop af  
2edb			endm  
# End of macro DMARK
2edb						CALLMONITOR 
2edb cd bb 13			call break_point_state  
2ede				endm  
# End of macro CALLMONITOR
2ede					endif 
2ede					FORTH_DSP_POP 
2ede cd f7 1b			call macro_forth_dsp_pop 
2ee1				endm 
# End of macro FORTH_DSP_POP
2ee1			 
2ee1			; put counters on the loop stack 
2ee1			 
2ee1			;		pop hl			 ; limit counter 
2ee1 d1					pop de			; start counter 
2ee2			 
2ee2					; push limit counter 
2ee2			 
2ee2					if DEBUG_FORTH_WORDS 
2ee2						DMARK "DO7" 
2ee2 f5				push af  
2ee3 3a f7 2e			ld a, (.dmark)  
2ee6 32 7a ee			ld (debug_mark),a  
2ee9 3a f8 2e			ld a, (.dmark+1)  
2eec 32 7b ee			ld (debug_mark+1),a  
2eef 3a f9 2e			ld a, (.dmark+2)  
2ef2 32 7c ee			ld (debug_mark+2),a  
2ef5 18 03			jr .pastdmark  
2ef7 ..			.dmark: db "DO7"  
2efa f1			.pastdmark: pop af  
2efb			endm  
# End of macro DMARK
2efb						CALLMONITOR 
2efb cd bb 13			call break_point_state  
2efe				endm  
# End of macro CALLMONITOR
2efe					endif 
2efe					FORTH_LOOP_NEXT 
2efe cd 70 1b			call macro_forth_loop_next 
2f01				endm 
# End of macro FORTH_LOOP_NEXT
2f01			 
2f01					; push start counter 
2f01			 
2f01 eb					ex de, hl 
2f02					if DEBUG_FORTH_WORDS 
2f02						DMARK "DO7" 
2f02 f5				push af  
2f03 3a 17 2f			ld a, (.dmark)  
2f06 32 7a ee			ld (debug_mark),a  
2f09 3a 18 2f			ld a, (.dmark+1)  
2f0c 32 7b ee			ld (debug_mark+1),a  
2f0f 3a 19 2f			ld a, (.dmark+2)  
2f12 32 7c ee			ld (debug_mark+2),a  
2f15 18 03			jr .pastdmark  
2f17 ..			.dmark: db "DO7"  
2f1a f1			.pastdmark: pop af  
2f1b			endm  
# End of macro DMARK
2f1b						CALLMONITOR 
2f1b cd bb 13			call break_point_state  
2f1e				endm  
# End of macro CALLMONITOR
2f1e					endif 
2f1e					FORTH_LOOP_NEXT 
2f1e cd 70 1b			call macro_forth_loop_next 
2f21				endm 
# End of macro FORTH_LOOP_NEXT
2f21			 
2f21			 
2f21					; init first round of I counter 
2f21			 
2f21 22 85 e6				ld (os_current_i), hl 
2f24			 
2f24					if DEBUG_FORTH_WORDS 
2f24						DMARK "DO8" 
2f24 f5				push af  
2f25 3a 39 2f			ld a, (.dmark)  
2f28 32 7a ee			ld (debug_mark),a  
2f2b 3a 3a 2f			ld a, (.dmark+1)  
2f2e 32 7b ee			ld (debug_mark+1),a  
2f31 3a 3b 2f			ld a, (.dmark+2)  
2f34 32 7c ee			ld (debug_mark+2),a  
2f37 18 03			jr .pastdmark  
2f39 ..			.dmark: db "DO8"  
2f3c f1			.pastdmark: pop af  
2f3d			endm  
# End of macro DMARK
2f3d						CALLMONITOR 
2f3d cd bb 13			call break_point_state  
2f40				endm  
# End of macro CALLMONITOR
2f40					endif 
2f40			 
2f40					NEXTW 
2f40 c3 b1 1c			jp macro_next 
2f43				endm 
# End of macro NEXTW
2f43			.LOOP: 
2f43				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
2f43 22				db WORD_SYS_CORE+14             
2f44 5b 30			dw .I            
2f46 05				db 4 + 1 
2f47 .. 00			db "LOOP",0              
2f4c				endm 
# End of macro CWHEAD
2f4c			; | LOOP ( -- ) Increment and test loop counter  | DONE 
2f4c			 
2f4c				; pop tos as current loop count to hl 
2f4c			 
2f4c				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
2f4c			 
2f4c				FORTH_LOOP_TOS 
2f4c cd a3 1b			call macro_forth_loop_tos 
2f4f				endm 
# End of macro FORTH_LOOP_TOS
2f4f e5				push hl 
2f50			 
2f50					if DEBUG_FORTH_WORDS_KEY 
2f50						DMARK "LOP" 
2f50 f5				push af  
2f51 3a 65 2f			ld a, (.dmark)  
2f54 32 7a ee			ld (debug_mark),a  
2f57 3a 66 2f			ld a, (.dmark+1)  
2f5a 32 7b ee			ld (debug_mark+1),a  
2f5d 3a 67 2f			ld a, (.dmark+2)  
2f60 32 7c ee			ld (debug_mark+2),a  
2f63 18 03			jr .pastdmark  
2f65 ..			.dmark: db "LOP"  
2f68 f1			.pastdmark: pop af  
2f69			endm  
# End of macro DMARK
2f69						CALLMONITOR 
2f69 cd bb 13			call break_point_state  
2f6c				endm  
# End of macro CALLMONITOR
2f6c					endif 
2f6c				; next item on the stack is the limit. get it 
2f6c			 
2f6c			 
2f6c				FORTH_LOOP_POP 
2f6c cd ad 1b			call macro_forth_loop_pop 
2f6f				endm 
# End of macro FORTH_LOOP_POP
2f6f			 
2f6f				FORTH_LOOP_TOS 
2f6f cd a3 1b			call macro_forth_loop_tos 
2f72				endm 
# End of macro FORTH_LOOP_TOS
2f72			 
2f72 d1				pop de		 ; de = i, hl = limit 
2f73			 
2f73					if DEBUG_FORTH_WORDS 
2f73						DMARK "LP1" 
2f73 f5				push af  
2f74 3a 88 2f			ld a, (.dmark)  
2f77 32 7a ee			ld (debug_mark),a  
2f7a 3a 89 2f			ld a, (.dmark+1)  
2f7d 32 7b ee			ld (debug_mark+1),a  
2f80 3a 8a 2f			ld a, (.dmark+2)  
2f83 32 7c ee			ld (debug_mark+2),a  
2f86 18 03			jr .pastdmark  
2f88 ..			.dmark: db "LP1"  
2f8b f1			.pastdmark: pop af  
2f8c			endm  
# End of macro DMARK
2f8c						CALLMONITOR 
2f8c cd bb 13			call break_point_state  
2f8f				endm  
# End of macro CALLMONITOR
2f8f					endif 
2f8f			 
2f8f				; go back to previous word 
2f8f			 
2f8f d5				push de    ; save I for inc later 
2f90			 
2f90			 
2f90				; get limit 
2f90				;  is I at limit? 
2f90			 
2f90			 
2f90					if DEBUG_FORTH_WORDS 
2f90						DMARK "LP1" 
2f90 f5				push af  
2f91 3a a5 2f			ld a, (.dmark)  
2f94 32 7a ee			ld (debug_mark),a  
2f97 3a a6 2f			ld a, (.dmark+1)  
2f9a 32 7b ee			ld (debug_mark+1),a  
2f9d 3a a7 2f			ld a, (.dmark+2)  
2fa0 32 7c ee			ld (debug_mark+2),a  
2fa3 18 03			jr .pastdmark  
2fa5 ..			.dmark: db "LP1"  
2fa8 f1			.pastdmark: pop af  
2fa9			endm  
# End of macro DMARK
2fa9						CALLMONITOR 
2fa9 cd bb 13			call break_point_state  
2fac				endm  
# End of macro CALLMONITOR
2fac					endif 
2fac			 
2fac ed 52			sbc hl, de 
2fae			 
2fae			 
2fae				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
2fae			 
2fae 20 26				jr nz, .loopnotdone 
2fb0			 
2fb0 e1				pop hl   ; get rid of saved I 
2fb1				FORTH_LOOP_POP     ; get rid of limit 
2fb1 cd ad 1b			call macro_forth_loop_pop 
2fb4				endm 
# End of macro FORTH_LOOP_POP
2fb4			 
2fb4				FORTH_RSP_POP     ; get rid of DO ptr 
2fb4 cd 10 19			call macro_forth_rsp_pop 
2fb7				endm 
# End of macro FORTH_RSP_POP
2fb7			 
2fb7			if DEBUG_FORTH_WORDS 
2fb7						DMARK "LP>" 
2fb7 f5				push af  
2fb8 3a cc 2f			ld a, (.dmark)  
2fbb 32 7a ee			ld (debug_mark),a  
2fbe 3a cd 2f			ld a, (.dmark+1)  
2fc1 32 7b ee			ld (debug_mark+1),a  
2fc4 3a ce 2f			ld a, (.dmark+2)  
2fc7 32 7c ee			ld (debug_mark+2),a  
2fca 18 03			jr .pastdmark  
2fcc ..			.dmark: db "LP>"  
2fcf f1			.pastdmark: pop af  
2fd0			endm  
# End of macro DMARK
2fd0				CALLMONITOR 
2fd0 cd bb 13			call break_point_state  
2fd3				endm  
# End of macro CALLMONITOR
2fd3			endif 
2fd3			 
2fd3					NEXTW 
2fd3 c3 b1 1c			jp macro_next 
2fd6				endm 
# End of macro NEXTW
2fd6				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
2fd6			 
2fd6			.loopnotdone: 
2fd6			 
2fd6 e1				pop hl    ; get I 
2fd7 23				inc hl 
2fd8			 
2fd8			   	; save new I 
2fd8			 
2fd8			 
2fd8					; set I counter 
2fd8			 
2fd8 22 85 e6				ld (os_current_i), hl 
2fdb			 
2fdb					if DEBUG_FORTH_WORDS 
2fdb						DMARK "LPN" 
2fdb f5				push af  
2fdc 3a f0 2f			ld a, (.dmark)  
2fdf 32 7a ee			ld (debug_mark),a  
2fe2 3a f1 2f			ld a, (.dmark+1)  
2fe5 32 7b ee			ld (debug_mark+1),a  
2fe8 3a f2 2f			ld a, (.dmark+2)  
2feb 32 7c ee			ld (debug_mark+2),a  
2fee 18 03			jr .pastdmark  
2ff0 ..			.dmark: db "LPN"  
2ff3 f1			.pastdmark: pop af  
2ff4			endm  
# End of macro DMARK
2ff4					CALLMONITOR 
2ff4 cd bb 13			call break_point_state  
2ff7				endm  
# End of macro CALLMONITOR
2ff7					endif 
2ff7					 
2ff7				FORTH_LOOP_NEXT 
2ff7 cd 70 1b			call macro_forth_loop_next 
2ffa				endm 
# End of macro FORTH_LOOP_NEXT
2ffa			 
2ffa			 
2ffa					if DEBUG_FORTH_WORDS 
2ffa eb						ex de,hl 
2ffb					endif 
2ffb			 
2ffb			;	; get DO ptr 
2ffb			; 
2ffb					if DEBUG_FORTH_WORDS 
2ffb						DMARK "LP7" 
2ffb f5				push af  
2ffc 3a 10 30			ld a, (.dmark)  
2fff 32 7a ee			ld (debug_mark),a  
3002 3a 11 30			ld a, (.dmark+1)  
3005 32 7b ee			ld (debug_mark+1),a  
3008 3a 12 30			ld a, (.dmark+2)  
300b 32 7c ee			ld (debug_mark+2),a  
300e 18 03			jr .pastdmark  
3010 ..			.dmark: db "LP7"  
3013 f1			.pastdmark: pop af  
3014			endm  
# End of macro DMARK
3014					CALLMONITOR 
3014 cd bb 13			call break_point_state  
3017				endm  
# End of macro CALLMONITOR
3017					endif 
3017				FORTH_RSP_TOS 
3017 cd 06 19			call macro_forth_rsp_tos 
301a				endm 
# End of macro FORTH_RSP_TOS
301a			 
301a					if DEBUG_FORTH_WORDS 
301a						DMARK "LP8" 
301a f5				push af  
301b 3a 2f 30			ld a, (.dmark)  
301e 32 7a ee			ld (debug_mark),a  
3021 3a 30 30			ld a, (.dmark+1)  
3024 32 7b ee			ld (debug_mark+1),a  
3027 3a 31 30			ld a, (.dmark+2)  
302a 32 7c ee			ld (debug_mark+2),a  
302d 18 03			jr .pastdmark  
302f ..			.dmark: db "LP8"  
3032 f1			.pastdmark: pop af  
3033			endm  
# End of macro DMARK
3033					CALLMONITOR 
3033 cd bb 13			call break_point_state  
3036				endm  
# End of macro CALLMONITOR
3036					endif 
3036				;push hl 
3036			 
3036				; not going to DO any more 
3036				; get rid of the RSP pointer as DO will add it back in 
3036				;FORTH_RSP_POP 
3036				;pop hl 
3036			 
3036				;ld hl,(cli_ret_sp) 
3036				;ld e, (hl) 
3036				;inc hl 
3036				;ld d, (hl) 
3036				;ex de,hl 
3036 22 61 e6			ld (os_tok_ptr), hl 
3039					if DEBUG_FORTH_WORDS 
3039						DMARK "LP<" 
3039 f5				push af  
303a 3a 4e 30			ld a, (.dmark)  
303d 32 7a ee			ld (debug_mark),a  
3040 3a 4f 30			ld a, (.dmark+1)  
3043 32 7b ee			ld (debug_mark+1),a  
3046 3a 50 30			ld a, (.dmark+2)  
3049 32 7c ee			ld (debug_mark+2),a  
304c 18 03			jr .pastdmark  
304e ..			.dmark: db "LP<"  
3051 f1			.pastdmark: pop af  
3052			endm  
# End of macro DMARK
3052					CALLMONITOR 
3052 cd bb 13			call break_point_state  
3055				endm  
# End of macro CALLMONITOR
3055				endif 
3055 c3 42 1d			jp exec1 
3058			 
3058					 
3058			 
3058			 
3058					NEXTW 
3058 c3 b1 1c			jp macro_next 
305b				endm 
# End of macro NEXTW
305b			.I:  
305b			 
305b				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
305b 5e				db WORD_SYS_CORE+74             
305c 86 30			dw .DLOOP            
305e 02				db 1 + 1 
305f .. 00			db "I",0              
3061				endm 
# End of macro CWHEAD
3061			; | I ( -- ) Current loop counter | DONE 
3061					if DEBUG_FORTH_WORDS_KEY 
3061						DMARK "I.." 
3061 f5				push af  
3062 3a 76 30			ld a, (.dmark)  
3065 32 7a ee			ld (debug_mark),a  
3068 3a 77 30			ld a, (.dmark+1)  
306b 32 7b ee			ld (debug_mark+1),a  
306e 3a 78 30			ld a, (.dmark+2)  
3071 32 7c ee			ld (debug_mark+2),a  
3074 18 03			jr .pastdmark  
3076 ..			.dmark: db "I.."  
3079 f1			.pastdmark: pop af  
307a			endm  
# End of macro DMARK
307a						CALLMONITOR 
307a cd bb 13			call break_point_state  
307d				endm  
# End of macro CALLMONITOR
307d					endif 
307d			 
307d 2a 85 e6				ld hl,(os_current_i) 
3080 cd 48 19				call forth_push_numhl 
3083			 
3083					NEXTW 
3083 c3 b1 1c			jp macro_next 
3086				endm 
# End of macro NEXTW
3086			.DLOOP: 
3086				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
3086 5f				db WORD_SYS_CORE+75             
3087 67 31			dw .REPEAT            
3089 06				db 5 + 1 
308a .. 00			db "-LOOP",0              
3090				endm 
# End of macro CWHEAD
3090			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
3090				; pop tos as current loop count to hl 
3090					if DEBUG_FORTH_WORDS_KEY 
3090						DMARK "-LP" 
3090 f5				push af  
3091 3a a5 30			ld a, (.dmark)  
3094 32 7a ee			ld (debug_mark),a  
3097 3a a6 30			ld a, (.dmark+1)  
309a 32 7b ee			ld (debug_mark+1),a  
309d 3a a7 30			ld a, (.dmark+2)  
30a0 32 7c ee			ld (debug_mark+2),a  
30a3 18 03			jr .pastdmark  
30a5 ..			.dmark: db "-LP"  
30a8 f1			.pastdmark: pop af  
30a9			endm  
# End of macro DMARK
30a9						CALLMONITOR 
30a9 cd bb 13			call break_point_state  
30ac				endm  
# End of macro CALLMONITOR
30ac					endif 
30ac			 
30ac				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
30ac			 
30ac				FORTH_LOOP_TOS 
30ac cd a3 1b			call macro_forth_loop_tos 
30af				endm 
# End of macro FORTH_LOOP_TOS
30af e5				push hl 
30b0			 
30b0					if DEBUG_FORTH_WORDS 
30b0						DMARK "-LP" 
30b0 f5				push af  
30b1 3a c5 30			ld a, (.dmark)  
30b4 32 7a ee			ld (debug_mark),a  
30b7 3a c6 30			ld a, (.dmark+1)  
30ba 32 7b ee			ld (debug_mark+1),a  
30bd 3a c7 30			ld a, (.dmark+2)  
30c0 32 7c ee			ld (debug_mark+2),a  
30c3 18 03			jr .pastdmark  
30c5 ..			.dmark: db "-LP"  
30c8 f1			.pastdmark: pop af  
30c9			endm  
# End of macro DMARK
30c9						CALLMONITOR 
30c9 cd bb 13			call break_point_state  
30cc				endm  
# End of macro CALLMONITOR
30cc					endif 
30cc				; next item on the stack is the limit. get it 
30cc			 
30cc			 
30cc				FORTH_LOOP_POP 
30cc cd ad 1b			call macro_forth_loop_pop 
30cf				endm 
# End of macro FORTH_LOOP_POP
30cf			 
30cf				FORTH_LOOP_TOS 
30cf cd a3 1b			call macro_forth_loop_tos 
30d2				endm 
# End of macro FORTH_LOOP_TOS
30d2			 
30d2 d1				pop de		 ; de = i, hl = limit 
30d3			 
30d3					if DEBUG_FORTH_WORDS 
30d3						DMARK "-L1" 
30d3 f5				push af  
30d4 3a e8 30			ld a, (.dmark)  
30d7 32 7a ee			ld (debug_mark),a  
30da 3a e9 30			ld a, (.dmark+1)  
30dd 32 7b ee			ld (debug_mark+1),a  
30e0 3a ea 30			ld a, (.dmark+2)  
30e3 32 7c ee			ld (debug_mark+2),a  
30e6 18 03			jr .pastdmark  
30e8 ..			.dmark: db "-L1"  
30eb f1			.pastdmark: pop af  
30ec			endm  
# End of macro DMARK
30ec						CALLMONITOR 
30ec cd bb 13			call break_point_state  
30ef				endm  
# End of macro CALLMONITOR
30ef					endif 
30ef			 
30ef				; go back to previous word 
30ef			 
30ef d5				push de    ; save I for inc later 
30f0			 
30f0			 
30f0				; get limit 
30f0				;  is I at limit? 
30f0			 
30f0			 
30f0					if DEBUG_FORTH_WORDS 
30f0						DMARK "-L1" 
30f0 f5				push af  
30f1 3a 05 31			ld a, (.dmark)  
30f4 32 7a ee			ld (debug_mark),a  
30f7 3a 06 31			ld a, (.dmark+1)  
30fa 32 7b ee			ld (debug_mark+1),a  
30fd 3a 07 31			ld a, (.dmark+2)  
3100 32 7c ee			ld (debug_mark+2),a  
3103 18 03			jr .pastdmark  
3105 ..			.dmark: db "-L1"  
3108 f1			.pastdmark: pop af  
3109			endm  
# End of macro DMARK
3109						CALLMONITOR 
3109 cd bb 13			call break_point_state  
310c				endm  
# End of macro CALLMONITOR
310c					endif 
310c			 
310c ed 52			sbc hl, de 
310e			 
310e			 
310e				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
310e			 
310e 20 26				jr nz, .mloopnotdone 
3110			 
3110 e1				pop hl   ; get rid of saved I 
3111				FORTH_LOOP_POP     ; get rid of limit 
3111 cd ad 1b			call macro_forth_loop_pop 
3114				endm 
# End of macro FORTH_LOOP_POP
3114			 
3114				FORTH_RSP_POP     ; get rid of DO ptr 
3114 cd 10 19			call macro_forth_rsp_pop 
3117				endm 
# End of macro FORTH_RSP_POP
3117			 
3117			if DEBUG_FORTH_WORDS 
3117						DMARK "-L>" 
3117 f5				push af  
3118 3a 2c 31			ld a, (.dmark)  
311b 32 7a ee			ld (debug_mark),a  
311e 3a 2d 31			ld a, (.dmark+1)  
3121 32 7b ee			ld (debug_mark+1),a  
3124 3a 2e 31			ld a, (.dmark+2)  
3127 32 7c ee			ld (debug_mark+2),a  
312a 18 03			jr .pastdmark  
312c ..			.dmark: db "-L>"  
312f f1			.pastdmark: pop af  
3130			endm  
# End of macro DMARK
3130				CALLMONITOR 
3130 cd bb 13			call break_point_state  
3133				endm  
# End of macro CALLMONITOR
3133			endif 
3133			 
3133					NEXTW 
3133 c3 b1 1c			jp macro_next 
3136				endm 
# End of macro NEXTW
3136				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3136			 
3136			.mloopnotdone: 
3136			 
3136 e1				pop hl    ; get I 
3137 2b				dec hl 
3138			 
3138			   	; save new I 
3138			 
3138			 
3138					; set I counter 
3138			 
3138 22 85 e6				ld (os_current_i), hl 
313b			 
313b					 
313b				FORTH_LOOP_NEXT 
313b cd 70 1b			call macro_forth_loop_next 
313e				endm 
# End of macro FORTH_LOOP_NEXT
313e			 
313e			 
313e					if DEBUG_FORTH_WORDS 
313e eb						ex de,hl 
313f					endif 
313f			 
313f			;	; get DO ptr 
313f			; 
313f				FORTH_RSP_TOS 
313f cd 06 19			call macro_forth_rsp_tos 
3142				endm 
# End of macro FORTH_RSP_TOS
3142			 
3142				;push hl 
3142			 
3142				; not going to DO any more 
3142				; get rid of the RSP pointer as DO will add it back in 
3142				;FORTH_RSP_POP 
3142				;pop hl 
3142			 
3142			 
3142 22 61 e6			ld (os_tok_ptr), hl 
3145					if DEBUG_FORTH_WORDS 
3145						DMARK "-L<" 
3145 f5				push af  
3146 3a 5a 31			ld a, (.dmark)  
3149 32 7a ee			ld (debug_mark),a  
314c 3a 5b 31			ld a, (.dmark+1)  
314f 32 7b ee			ld (debug_mark+1),a  
3152 3a 5c 31			ld a, (.dmark+2)  
3155 32 7c ee			ld (debug_mark+2),a  
3158 18 03			jr .pastdmark  
315a ..			.dmark: db "-L<"  
315d f1			.pastdmark: pop af  
315e			endm  
# End of macro DMARK
315e					CALLMONITOR 
315e cd bb 13			call break_point_state  
3161				endm  
# End of macro CALLMONITOR
3161				endif 
3161 c3 42 1d			jp exec1 
3164			 
3164					 
3164			 
3164			 
3164			 
3164				NEXTW 
3164 c3 b1 1c			jp macro_next 
3167				endm 
# End of macro NEXTW
3167			 
3167			 
3167			 
3167			 
3167			.REPEAT: 
3167				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
3167 71				db WORD_SYS_CORE+93             
3168 ba 31			dw .UNTIL            
316a 06				db 5 + 1 
316b .. 00			db "REPEAT",0              
3172				endm 
# End of macro CWHEAD
3172			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
3172			;  push pc to rsp stack past the REPEAT 
3172					if DEBUG_FORTH_WORDS_KEY 
3172						DMARK "REP" 
3172 f5				push af  
3173 3a 87 31			ld a, (.dmark)  
3176 32 7a ee			ld (debug_mark),a  
3179 3a 88 31			ld a, (.dmark+1)  
317c 32 7b ee			ld (debug_mark+1),a  
317f 3a 89 31			ld a, (.dmark+2)  
3182 32 7c ee			ld (debug_mark+2),a  
3185 18 03			jr .pastdmark  
3187 ..			.dmark: db "REP"  
318a f1			.pastdmark: pop af  
318b			endm  
# End of macro DMARK
318b						CALLMONITOR 
318b cd bb 13			call break_point_state  
318e				endm  
# End of macro CALLMONITOR
318e					endif 
318e			 
318e 2a 61 e6				ld hl, (os_tok_ptr) 
3191 23					inc hl   ; R 
3192 23					inc hl  ; E 
3193 23					inc hl   ; P 
3194 23					inc hl   ; E 
3195 23					inc hl   ; A 
3196 23					inc hl   ; T 
3197 23					inc hl   ; zero 
3198					FORTH_RSP_NEXT 
3198 cd ef 18			call macro_forth_rsp_next 
319b				endm 
# End of macro FORTH_RSP_NEXT
319b			 
319b			 
319b					if DEBUG_FORTH_WORDS 
319b						DMARK "REP" 
319b f5				push af  
319c 3a b0 31			ld a, (.dmark)  
319f 32 7a ee			ld (debug_mark),a  
31a2 3a b1 31			ld a, (.dmark+1)  
31a5 32 7b ee			ld (debug_mark+1),a  
31a8 3a b2 31			ld a, (.dmark+2)  
31ab 32 7c ee			ld (debug_mark+2),a  
31ae 18 03			jr .pastdmark  
31b0 ..			.dmark: db "REP"  
31b3 f1			.pastdmark: pop af  
31b4			endm  
# End of macro DMARK
31b4						;pop bc    ; TODO BUG ?????? what is this for???? 
31b4						CALLMONITOR 
31b4 cd bb 13			call break_point_state  
31b7				endm  
# End of macro CALLMONITOR
31b7					endif 
31b7			 
31b7					NEXTW 
31b7 c3 b1 1c			jp macro_next 
31ba				endm 
# End of macro NEXTW
31ba			;	       NEXTW 
31ba			 
31ba			.UNTIL: 
31ba				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
31ba 72				db WORD_SYS_CORE+94             
31bb 51 32			dw .ENDFLOW            
31bd 06				db 5 + 1 
31be .. 00			db "UNTIL",0              
31c4				endm 
# End of macro CWHEAD
31c4			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
31c4			 
31c4				; pop tos as check 
31c4			 
31c4				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
31c4			 
31c4				FORTH_DSP_VALUEHL 
31c4 cd 3f 1b			call macro_dsp_valuehl 
31c7				endm 
# End of macro FORTH_DSP_VALUEHL
31c7			 
31c7					if DEBUG_FORTH_WORDS_KEY 
31c7						DMARK "UNT" 
31c7 f5				push af  
31c8 3a dc 31			ld a, (.dmark)  
31cb 32 7a ee			ld (debug_mark),a  
31ce 3a dd 31			ld a, (.dmark+1)  
31d1 32 7b ee			ld (debug_mark+1),a  
31d4 3a de 31			ld a, (.dmark+2)  
31d7 32 7c ee			ld (debug_mark+2),a  
31da 18 03			jr .pastdmark  
31dc ..			.dmark: db "UNT"  
31df f1			.pastdmark: pop af  
31e0			endm  
# End of macro DMARK
31e0						CALLMONITOR 
31e0 cd bb 13			call break_point_state  
31e3				endm  
# End of macro CALLMONITOR
31e3					endif 
31e3			 
31e3			;	push hl 
31e3				FORTH_DSP_POP 
31e3 cd f7 1b			call macro_forth_dsp_pop 
31e6				endm 
# End of macro FORTH_DSP_POP
31e6			 
31e6			;	pop hl 
31e6			 
31e6				; test if true 
31e6			 
31e6 cd 9d 0b			call ishlzero 
31e9			;	ld a,l 
31e9			;	add h 
31e9			; 
31e9			;	cp 0 
31e9			 
31e9 20 3e			jr nz, .untilnotdone 
31eb			 
31eb					if DEBUG_FORTH_WORDS 
31eb						DMARK "UNf" 
31eb f5				push af  
31ec 3a 00 32			ld a, (.dmark)  
31ef 32 7a ee			ld (debug_mark),a  
31f2 3a 01 32			ld a, (.dmark+1)  
31f5 32 7b ee			ld (debug_mark+1),a  
31f8 3a 02 32			ld a, (.dmark+2)  
31fb 32 7c ee			ld (debug_mark+2),a  
31fe 18 03			jr .pastdmark  
3200 ..			.dmark: db "UNf"  
3203 f1			.pastdmark: pop af  
3204			endm  
# End of macro DMARK
3204						CALLMONITOR 
3204 cd bb 13			call break_point_state  
3207				endm  
# End of macro CALLMONITOR
3207					endif 
3207			 
3207			 
3207			 
3207				FORTH_RSP_POP     ; get rid of DO ptr 
3207 cd 10 19			call macro_forth_rsp_pop 
320a				endm 
# End of macro FORTH_RSP_POP
320a			 
320a			if DEBUG_FORTH_WORDS 
320a						DMARK "UN>" 
320a f5				push af  
320b 3a 1f 32			ld a, (.dmark)  
320e 32 7a ee			ld (debug_mark),a  
3211 3a 20 32			ld a, (.dmark+1)  
3214 32 7b ee			ld (debug_mark+1),a  
3217 3a 21 32			ld a, (.dmark+2)  
321a 32 7c ee			ld (debug_mark+2),a  
321d 18 03			jr .pastdmark  
321f ..			.dmark: db "UN>"  
3222 f1			.pastdmark: pop af  
3223			endm  
# End of macro DMARK
3223				CALLMONITOR 
3223 cd bb 13			call break_point_state  
3226				endm  
# End of macro CALLMONITOR
3226			endif 
3226			 
3226					NEXTW 
3226 c3 b1 1c			jp macro_next 
3229				endm 
# End of macro NEXTW
3229				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3229			 
3229			.untilnotdone: 
3229			 
3229			 
3229			;	; get DO ptr 
3229			; 
3229				FORTH_RSP_TOS 
3229 cd 06 19			call macro_forth_rsp_tos 
322c				endm 
# End of macro FORTH_RSP_TOS
322c			 
322c				;push hl 
322c			 
322c				; not going to DO any more 
322c				; get rid of the RSP pointer as DO will add it back in 
322c				;FORTH_RSP_POP 
322c				;pop hl 
322c			 
322c			 
322c 22 61 e6			ld (os_tok_ptr), hl 
322f					if DEBUG_FORTH_WORDS 
322f						DMARK "UN<" 
322f f5				push af  
3230 3a 44 32			ld a, (.dmark)  
3233 32 7a ee			ld (debug_mark),a  
3236 3a 45 32			ld a, (.dmark+1)  
3239 32 7b ee			ld (debug_mark+1),a  
323c 3a 46 32			ld a, (.dmark+2)  
323f 32 7c ee			ld (debug_mark+2),a  
3242 18 03			jr .pastdmark  
3244 ..			.dmark: db "UN<"  
3247 f1			.pastdmark: pop af  
3248			endm  
# End of macro DMARK
3248					CALLMONITOR 
3248 cd bb 13			call break_point_state  
324b				endm  
# End of macro CALLMONITOR
324b				endif 
324b c3 42 1d			jp exec1 
324e			 
324e					 
324e			 
324e			 
324e					NEXTW 
324e c3 b1 1c			jp macro_next 
3251				endm 
# End of macro NEXTW
3251			 
3251			 
3251			.ENDFLOW: 
3251			 
3251			; eof 
3251			 
# End of file forth_words_flow.asm
3251			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
3251			include "forth_words_logic.asm" 
3251			 
3251			; | ## Logic Words 
3251			 
3251			.NOT: 
3251				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
3251 2d				db WORD_SYS_CORE+25             
3252 99 32			dw .IS            
3254 04				db 3 + 1 
3255 .. 00			db "NOT",0              
3259				endm 
# End of macro CWHEAD
3259			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
3259					if DEBUG_FORTH_WORDS_KEY 
3259						DMARK "NOT" 
3259 f5				push af  
325a 3a 6e 32			ld a, (.dmark)  
325d 32 7a ee			ld (debug_mark),a  
3260 3a 6f 32			ld a, (.dmark+1)  
3263 32 7b ee			ld (debug_mark+1),a  
3266 3a 70 32			ld a, (.dmark+2)  
3269 32 7c ee			ld (debug_mark+2),a  
326c 18 03			jr .pastdmark  
326e ..			.dmark: db "NOT"  
3271 f1			.pastdmark: pop af  
3272			endm  
# End of macro DMARK
3272						CALLMONITOR 
3272 cd bb 13			call break_point_state  
3275				endm  
# End of macro CALLMONITOR
3275					endif 
3275					FORTH_DSP 
3275 cd 05 1b			call macro_forth_dsp 
3278				endm 
# End of macro FORTH_DSP
3278 7e					ld a,(hl)	; get type of value on TOS 
3279 fe 02				cp DS_TYPE_INUM  
327b 28 03				jr z, .noti 
327d					NEXTW 
327d c3 b1 1c			jp macro_next 
3280				endm 
# End of macro NEXTW
3280			.noti:          FORTH_DSP_VALUEHL 
3280 cd 3f 1b			call macro_dsp_valuehl 
3283				endm 
# End of macro FORTH_DSP_VALUEHL
3283			;		push hl 
3283					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3283 cd f7 1b			call macro_forth_dsp_pop 
3286				endm 
# End of macro FORTH_DSP_POP
3286			;		pop hl 
3286 3e 00				ld a,0 
3288 bd					cp l 
3289 28 04				jr z, .not2t 
328b 2e 00				ld l, 0 
328d 18 02				jr .notip 
328f			 
328f 2e ff		.not2t:		ld l, 255 
3291			 
3291 26 00		.notip:		ld h, 0	 
3293			 
3293 cd 48 19				call forth_push_numhl 
3296					NEXTW 
3296 c3 b1 1c			jp macro_next 
3299				endm 
# End of macro NEXTW
3299			 
3299			.IS: 
3299				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
3299 2d				db WORD_SYS_CORE+25             
329a bf 32			dw .LZERO            
329c 03				db 2 + 1 
329d .. 00			db "IS",0              
32a0				endm 
# End of macro CWHEAD
32a0			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
32a0					if DEBUG_FORTH_WORDS_KEY 
32a0						DMARK "IS." 
32a0 f5				push af  
32a1 3a b5 32			ld a, (.dmark)  
32a4 32 7a ee			ld (debug_mark),a  
32a7 3a b6 32			ld a, (.dmark+1)  
32aa 32 7b ee			ld (debug_mark+1),a  
32ad 3a b7 32			ld a, (.dmark+2)  
32b0 32 7c ee			ld (debug_mark+2),a  
32b3 18 03			jr .pastdmark  
32b5 ..			.dmark: db "IS."  
32b8 f1			.pastdmark: pop af  
32b9			endm  
# End of macro DMARK
32b9						CALLMONITOR 
32b9 cd bb 13			call break_point_state  
32bc				endm  
# End of macro CALLMONITOR
32bc					endif 
32bc					NEXTW 
32bc c3 b1 1c			jp macro_next 
32bf				endm 
# End of macro NEXTW
32bf			.LZERO: 
32bf				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
32bf 2d				db WORD_SYS_CORE+25             
32c0 c9 32			dw .TZERO            
32c2 03				db 2 + 1 
32c3 .. 00			db "0<",0              
32c6				endm 
# End of macro CWHEAD
32c6			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
32c6					NEXTW 
32c6 c3 b1 1c			jp macro_next 
32c9				endm 
# End of macro NEXTW
32c9			.TZERO: 
32c9				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
32c9 2e				db WORD_SYS_CORE+26             
32ca 10 33			dw .LESS            
32cc 03				db 2 + 1 
32cd .. 00			db "0=",0              
32d0				endm 
# End of macro CWHEAD
32d0			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
32d0				; TODO add floating point number detection 
32d0					;v5 FORTH_DSP_VALUE 
32d0					if DEBUG_FORTH_WORDS_KEY 
32d0						DMARK "0=." 
32d0 f5				push af  
32d1 3a e5 32			ld a, (.dmark)  
32d4 32 7a ee			ld (debug_mark),a  
32d7 3a e6 32			ld a, (.dmark+1)  
32da 32 7b ee			ld (debug_mark+1),a  
32dd 3a e7 32			ld a, (.dmark+2)  
32e0 32 7c ee			ld (debug_mark+2),a  
32e3 18 03			jr .pastdmark  
32e5 ..			.dmark: db "0=."  
32e8 f1			.pastdmark: pop af  
32e9			endm  
# End of macro DMARK
32e9						CALLMONITOR 
32e9 cd bb 13			call break_point_state  
32ec				endm  
# End of macro CALLMONITOR
32ec					endif 
32ec					FORTH_DSP 
32ec cd 05 1b			call macro_forth_dsp 
32ef				endm 
# End of macro FORTH_DSP
32ef 7e					ld a,(hl)	; get type of value on TOS 
32f0 fe 02				cp DS_TYPE_INUM  
32f2 28 00				jr z, .tz_inum 
32f4			 
32f4				if FORTH_ENABLE_FLOATMATH 
32f4					jr .tz_done 
32f4			 
32f4				endif 
32f4					 
32f4			 
32f4			.tz_inum: 
32f4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
32f4 cd 3f 1b			call macro_dsp_valuehl 
32f7				endm 
# End of macro FORTH_DSP_VALUEHL
32f7			 
32f7			;		push hl 
32f7			 
32f7					; destroy value TOS 
32f7			 
32f7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
32f7 cd f7 1b			call macro_forth_dsp_pop 
32fa				endm 
# End of macro FORTH_DSP_POP
32fa			 
32fa			;		pop hl 
32fa			 
32fa 3e 00				ld a,0 
32fc			 
32fc bd					cp l 
32fd 20 08				jr nz, .tz_notzero 
32ff			 
32ff bc					cp h 
3300			 
3300 20 05				jr nz, .tz_notzero 
3302			 
3302			 
3302 21 01 00				ld hl, FORTH_TRUE 
3305 18 03				jr .tz_done 
3307			 
3307 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
330a			 
330a					; push value back onto stack for another op etc 
330a			 
330a			.tz_done: 
330a cd 48 19				call forth_push_numhl 
330d			 
330d					NEXTW 
330d c3 b1 1c			jp macro_next 
3310				endm 
# End of macro NEXTW
3310			.LESS: 
3310				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3310 2f				db WORD_SYS_CORE+27             
3311 79 33			dw .GT            
3313 02				db 1 + 1 
3314 .. 00			db "<",0              
3316				endm 
# End of macro CWHEAD
3316			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3316				; TODO add floating point number detection 
3316					if DEBUG_FORTH_WORDS_KEY 
3316						DMARK "LES" 
3316 f5				push af  
3317 3a 2b 33			ld a, (.dmark)  
331a 32 7a ee			ld (debug_mark),a  
331d 3a 2c 33			ld a, (.dmark+1)  
3320 32 7b ee			ld (debug_mark+1),a  
3323 3a 2d 33			ld a, (.dmark+2)  
3326 32 7c ee			ld (debug_mark+2),a  
3329 18 03			jr .pastdmark  
332b ..			.dmark: db "LES"  
332e f1			.pastdmark: pop af  
332f			endm  
# End of macro DMARK
332f						CALLMONITOR 
332f cd bb 13			call break_point_state  
3332				endm  
# End of macro CALLMONITOR
3332					endif 
3332					FORTH_DSP 
3332 cd 05 1b			call macro_forth_dsp 
3335				endm 
# End of macro FORTH_DSP
3335					;v5 FORTH_DSP_VALUE 
3335 7e					ld a,(hl)	; get type of value on TOS 
3336 fe 02				cp DS_TYPE_INUM  
3338 28 00				jr z, .less_inum 
333a			 
333a				if FORTH_ENABLE_FLOATMATH 
333a					jr .less_done 
333a			 
333a				endif 
333a					 
333a			 
333a			.less_inum: 
333a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
333a cd 3f 1b			call macro_dsp_valuehl 
333d				endm 
# End of macro FORTH_DSP_VALUEHL
333d			 
333d e5					push hl  ; u2 
333e			 
333e					; destroy value TOS 
333e			 
333e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
333e cd f7 1b			call macro_forth_dsp_pop 
3341				endm 
# End of macro FORTH_DSP_POP
3341			 
3341			 
3341					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3341 cd 3f 1b			call macro_dsp_valuehl 
3344				endm 
# End of macro FORTH_DSP_VALUEHL
3344			 
3344 e5					push hl    ; u1 
3345			 
3345					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3345 cd f7 1b			call macro_forth_dsp_pop 
3348				endm 
# End of macro FORTH_DSP_POP
3348			 
3348			 
3348 b7			 or a      ;clear carry flag 
3349 01 00 00		 ld bc, FORTH_FALSE 
334c e1			  pop hl    ; u1 
334d d1			  pop de    ; u2 
334e ed 52		  sbc hl,de 
3350 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
3352			 
3352 01 01 00		 ld bc, FORTH_TRUE 
3355			.lscont:  
3355 c5					push bc 
3356 e1					pop hl 
3357			 
3357					if DEBUG_FORTH_WORDS 
3357						DMARK "LT1" 
3357 f5				push af  
3358 3a 6c 33			ld a, (.dmark)  
335b 32 7a ee			ld (debug_mark),a  
335e 3a 6d 33			ld a, (.dmark+1)  
3361 32 7b ee			ld (debug_mark+1),a  
3364 3a 6e 33			ld a, (.dmark+2)  
3367 32 7c ee			ld (debug_mark+2),a  
336a 18 03			jr .pastdmark  
336c ..			.dmark: db "LT1"  
336f f1			.pastdmark: pop af  
3370			endm  
# End of macro DMARK
3370						CALLMONITOR 
3370 cd bb 13			call break_point_state  
3373				endm  
# End of macro CALLMONITOR
3373					endif 
3373 cd 48 19				call forth_push_numhl 
3376			 
3376					NEXTW 
3376 c3 b1 1c			jp macro_next 
3379				endm 
# End of macro NEXTW
3379			.GT: 
3379				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
3379 30				db WORD_SYS_CORE+28             
337a e2 33			dw .EQUAL            
337c 02				db 1 + 1 
337d .. 00			db ">",0              
337f				endm 
# End of macro CWHEAD
337f			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
337f				; TODO add floating point number detection 
337f					if DEBUG_FORTH_WORDS_KEY 
337f						DMARK "GRT" 
337f f5				push af  
3380 3a 94 33			ld a, (.dmark)  
3383 32 7a ee			ld (debug_mark),a  
3386 3a 95 33			ld a, (.dmark+1)  
3389 32 7b ee			ld (debug_mark+1),a  
338c 3a 96 33			ld a, (.dmark+2)  
338f 32 7c ee			ld (debug_mark+2),a  
3392 18 03			jr .pastdmark  
3394 ..			.dmark: db "GRT"  
3397 f1			.pastdmark: pop af  
3398			endm  
# End of macro DMARK
3398						CALLMONITOR 
3398 cd bb 13			call break_point_state  
339b				endm  
# End of macro CALLMONITOR
339b					endif 
339b					FORTH_DSP 
339b cd 05 1b			call macro_forth_dsp 
339e				endm 
# End of macro FORTH_DSP
339e					;FORTH_DSP_VALUE 
339e 7e					ld a,(hl)	; get type of value on TOS 
339f fe 02				cp DS_TYPE_INUM  
33a1 28 00				jr z, .gt_inum 
33a3			 
33a3				if FORTH_ENABLE_FLOATMATH 
33a3					jr .gt_done 
33a3			 
33a3				endif 
33a3					 
33a3			 
33a3			.gt_inum: 
33a3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
33a3 cd 3f 1b			call macro_dsp_valuehl 
33a6				endm 
# End of macro FORTH_DSP_VALUEHL
33a6			 
33a6 e5					push hl  ; u2 
33a7			 
33a7					; destroy value TOS 
33a7			 
33a7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
33a7 cd f7 1b			call macro_forth_dsp_pop 
33aa				endm 
# End of macro FORTH_DSP_POP
33aa			 
33aa			 
33aa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
33aa cd 3f 1b			call macro_dsp_valuehl 
33ad				endm 
# End of macro FORTH_DSP_VALUEHL
33ad			 
33ad e5					push hl    ; u1 
33ae			 
33ae					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
33ae cd f7 1b			call macro_forth_dsp_pop 
33b1				endm 
# End of macro FORTH_DSP_POP
33b1			 
33b1			 
33b1 b7			 or a      ;clear carry flag 
33b2 01 00 00		 ld bc, FORTH_FALSE 
33b5 e1			  pop hl    ; u1 
33b6 d1			  pop de    ; u2 
33b7 ed 52		  sbc hl,de 
33b9 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
33bb			 
33bb 01 01 00		 ld bc, FORTH_TRUE 
33be			.gtcont:  
33be c5					push bc 
33bf e1					pop hl 
33c0			 
33c0					if DEBUG_FORTH_WORDS 
33c0						DMARK "GT1" 
33c0 f5				push af  
33c1 3a d5 33			ld a, (.dmark)  
33c4 32 7a ee			ld (debug_mark),a  
33c7 3a d6 33			ld a, (.dmark+1)  
33ca 32 7b ee			ld (debug_mark+1),a  
33cd 3a d7 33			ld a, (.dmark+2)  
33d0 32 7c ee			ld (debug_mark+2),a  
33d3 18 03			jr .pastdmark  
33d5 ..			.dmark: db "GT1"  
33d8 f1			.pastdmark: pop af  
33d9			endm  
# End of macro DMARK
33d9						CALLMONITOR 
33d9 cd bb 13			call break_point_state  
33dc				endm  
# End of macro CALLMONITOR
33dc					endif 
33dc cd 48 19				call forth_push_numhl 
33df			 
33df					NEXTW 
33df c3 b1 1c			jp macro_next 
33e2				endm 
# End of macro NEXTW
33e2			.EQUAL: 
33e2				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
33e2 31				db WORD_SYS_CORE+29             
33e3 4d 34			dw .ENDLOGIC            
33e5 02				db 1 + 1 
33e6 .. 00			db "=",0              
33e8				endm 
# End of macro CWHEAD
33e8			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
33e8				; TODO add floating point number detection 
33e8					if DEBUG_FORTH_WORDS_KEY 
33e8						DMARK "EQ." 
33e8 f5				push af  
33e9 3a fd 33			ld a, (.dmark)  
33ec 32 7a ee			ld (debug_mark),a  
33ef 3a fe 33			ld a, (.dmark+1)  
33f2 32 7b ee			ld (debug_mark+1),a  
33f5 3a ff 33			ld a, (.dmark+2)  
33f8 32 7c ee			ld (debug_mark+2),a  
33fb 18 03			jr .pastdmark  
33fd ..			.dmark: db "EQ."  
3400 f1			.pastdmark: pop af  
3401			endm  
# End of macro DMARK
3401						CALLMONITOR 
3401 cd bb 13			call break_point_state  
3404				endm  
# End of macro CALLMONITOR
3404					endif 
3404					FORTH_DSP 
3404 cd 05 1b			call macro_forth_dsp 
3407				endm 
# End of macro FORTH_DSP
3407					;v5 FORTH_DSP_VALUE 
3407 7e					ld a,(hl)	; get type of value on TOS 
3408 fe 02				cp DS_TYPE_INUM  
340a 28 00				jr z, .eq_inum 
340c			 
340c				if FORTH_ENABLE_FLOATMATH 
340c					jr .eq_done 
340c			 
340c				endif 
340c					 
340c			 
340c			.eq_inum: 
340c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
340c cd 3f 1b			call macro_dsp_valuehl 
340f				endm 
# End of macro FORTH_DSP_VALUEHL
340f			 
340f e5					push hl 
3410			 
3410					; destroy value TOS 
3410			 
3410					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3410 cd f7 1b			call macro_forth_dsp_pop 
3413				endm 
# End of macro FORTH_DSP_POP
3413			 
3413			 
3413					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3413 cd 3f 1b			call macro_dsp_valuehl 
3416				endm 
# End of macro FORTH_DSP_VALUEHL
3416			 
3416					; one value on hl get other one back 
3416			 
3416 e5					push hl 
3417			 
3417					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3417 cd f7 1b			call macro_forth_dsp_pop 
341a				endm 
# End of macro FORTH_DSP_POP
341a			 
341a 0e 00				ld c, FORTH_FALSE 
341c			 
341c e1					pop hl 
341d d1					pop de 
341e			 
341e 7b					ld a, e 
341f bd					cp l 
3420			 
3420 20 06				jr nz, .eq_done 
3422			 
3422 7a					ld a, d 
3423 bc					cp h 
3424			 
3424 20 02				jr nz, .eq_done 
3426			 
3426 0e 01				ld c, FORTH_TRUE 
3428					 
3428			 
3428			 
3428			.eq_done: 
3428			 
3428					; TODO push value back onto stack for another op etc 
3428			 
3428 26 00				ld h, 0 
342a 69					ld l, c 
342b					if DEBUG_FORTH_WORDS 
342b						DMARK "EQ1" 
342b f5				push af  
342c 3a 40 34			ld a, (.dmark)  
342f 32 7a ee			ld (debug_mark),a  
3432 3a 41 34			ld a, (.dmark+1)  
3435 32 7b ee			ld (debug_mark+1),a  
3438 3a 42 34			ld a, (.dmark+2)  
343b 32 7c ee			ld (debug_mark+2),a  
343e 18 03			jr .pastdmark  
3440 ..			.dmark: db "EQ1"  
3443 f1			.pastdmark: pop af  
3444			endm  
# End of macro DMARK
3444						CALLMONITOR 
3444 cd bb 13			call break_point_state  
3447				endm  
# End of macro CALLMONITOR
3447					endif 
3447 cd 48 19				call forth_push_numhl 
344a			 
344a					NEXTW 
344a c3 b1 1c			jp macro_next 
344d				endm 
# End of macro NEXTW
344d			 
344d			 
344d			.ENDLOGIC: 
344d			; eof 
344d			 
344d			 
# End of file forth_words_logic.asm
344d			include "forth_words_maths.asm" 
344d			 
344d			; | ## Maths Words 
344d			 
344d			.PLUS:	 
344d				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
344d 15				db WORD_SYS_CORE+1             
344e 8f 34			dw .NEG            
3450 02				db 1 + 1 
3451 .. 00			db "+",0              
3453				endm 
# End of macro CWHEAD
3453			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3453					if DEBUG_FORTH_WORDS_KEY 
3453						DMARK "PLU" 
3453 f5				push af  
3454 3a 68 34			ld a, (.dmark)  
3457 32 7a ee			ld (debug_mark),a  
345a 3a 69 34			ld a, (.dmark+1)  
345d 32 7b ee			ld (debug_mark+1),a  
3460 3a 6a 34			ld a, (.dmark+2)  
3463 32 7c ee			ld (debug_mark+2),a  
3466 18 03			jr .pastdmark  
3468 ..			.dmark: db "PLU"  
346b f1			.pastdmark: pop af  
346c			endm  
# End of macro DMARK
346c						CALLMONITOR 
346c cd bb 13			call break_point_state  
346f				endm  
# End of macro CALLMONITOR
346f					endif 
346f					; add top two values and push back result 
346f			 
346f					;for v5 FORTH_DSP_VALUE 
346f					FORTH_DSP 
346f cd 05 1b			call macro_forth_dsp 
3472				endm 
# End of macro FORTH_DSP
3472 7e					ld a,(hl)	; get type of value on TOS 
3473 fe 02				cp DS_TYPE_INUM  
3475 28 03				jr z, .dot_inum 
3477			 
3477					NEXTW 
3477 c3 b1 1c			jp macro_next 
347a				endm 
# End of macro NEXTW
347a			 
347a			; float maths 
347a			 
347a				if FORTH_ENABLE_FLOATMATH 
347a						inc hl      ; now at start of numeric as string 
347a			 
347a					if DEBUG_FORTH_MATHS 
347a						DMARK "ADD" 
347a				CALLMONITOR 
347a					endif 
347a			 
347a					;ld ix, hl 
347a					call CON 
347a			 
347a			 
347a					push hl 
347a					 
347a					 
347a			 
347a						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
347a			 
347a					; get next number 
347a			 
347a						FORTH_DSP_VALUE 
347a			 
347a						inc hl      ; now at start of numeric as string 
347a			 
347a					;ld ix, hl 
347a					call CON 
347a			 
347a					push hl 
347a			 
347a			 
347a						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
347a			 
347a						; TODO do add 
347a			 
347a						call IADD 
347a			 
347a						; TODO get result back as ascii 
347a			 
347a						; TODO push result  
347a			 
347a			 
347a			 
347a						jr .dot_done 
347a				endif 
347a			 
347a			.dot_inum: 
347a			 
347a			 
347a					if DEBUG_FORTH_DOT 
347a						DMARK "+IT" 
347a				CALLMONITOR 
347a					endif 
347a			 
347a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
347a cd 3f 1b			call macro_dsp_valuehl 
347d				endm 
# End of macro FORTH_DSP_VALUEHL
347d			 
347d				; TODO add floating point number detection 
347d			 
347d e5					push hl 
347e			 
347e					; destroy value TOS 
347e			 
347e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
347e cd f7 1b			call macro_forth_dsp_pop 
3481				endm 
# End of macro FORTH_DSP_POP
3481			 
3481			 
3481					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3481 cd 3f 1b			call macro_dsp_valuehl 
3484				endm 
# End of macro FORTH_DSP_VALUEHL
3484			 
3484					; one value on hl get other one back 
3484			 
3484 d1					pop de 
3485			 
3485					; do the add 
3485			 
3485 19					add hl,de 
3486			 
3486					; save it 
3486			 
3486			;		push hl	 
3486			 
3486					; 
3486			 
3486					; destroy value TOS 
3486			 
3486					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3486 cd f7 1b			call macro_forth_dsp_pop 
3489				endm 
# End of macro FORTH_DSP_POP
3489			 
3489					; TODO push value back onto stack for another op etc 
3489			 
3489			;		pop hl 
3489			 
3489			.dot_done: 
3489 cd 48 19				call forth_push_numhl 
348c			 
348c					NEXTW 
348c c3 b1 1c			jp macro_next 
348f				endm 
# End of macro NEXTW
348f			.NEG: 
348f			 
348f				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
348f 17				db WORD_SYS_CORE+3             
3490 d2 34			dw .DIV            
3492 02				db 1 + 1 
3493 .. 00			db "-",0              
3495				endm 
# End of macro CWHEAD
3495			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3495					if DEBUG_FORTH_WORDS_KEY 
3495						DMARK "SUB" 
3495 f5				push af  
3496 3a aa 34			ld a, (.dmark)  
3499 32 7a ee			ld (debug_mark),a  
349c 3a ab 34			ld a, (.dmark+1)  
349f 32 7b ee			ld (debug_mark+1),a  
34a2 3a ac 34			ld a, (.dmark+2)  
34a5 32 7c ee			ld (debug_mark+2),a  
34a8 18 03			jr .pastdmark  
34aa ..			.dmark: db "SUB"  
34ad f1			.pastdmark: pop af  
34ae			endm  
# End of macro DMARK
34ae						CALLMONITOR 
34ae cd bb 13			call break_point_state  
34b1				endm  
# End of macro CALLMONITOR
34b1					endif 
34b1			 
34b1			 
34b1				; TODO add floating point number detection 
34b1					; v5 FORTH_DSP_VALUE 
34b1					FORTH_DSP 
34b1 cd 05 1b			call macro_forth_dsp 
34b4				endm 
# End of macro FORTH_DSP
34b4 7e					ld a,(hl)	; get type of value on TOS 
34b5 fe 02				cp DS_TYPE_INUM  
34b7 28 03				jr z, .neg_inum 
34b9			 
34b9					NEXTW 
34b9 c3 b1 1c			jp macro_next 
34bc				endm 
# End of macro NEXTW
34bc			 
34bc			; float maths 
34bc			 
34bc				if FORTH_ENABLE_FLOATMATH 
34bc					jr .neg_done 
34bc			 
34bc				endif 
34bc					 
34bc			 
34bc			.neg_inum: 
34bc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
34bc cd 3f 1b			call macro_dsp_valuehl 
34bf				endm 
# End of macro FORTH_DSP_VALUEHL
34bf			 
34bf e5					push hl 
34c0			 
34c0					; destroy value TOS 
34c0			 
34c0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34c0 cd f7 1b			call macro_forth_dsp_pop 
34c3				endm 
# End of macro FORTH_DSP_POP
34c3			 
34c3			 
34c3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
34c3 cd 3f 1b			call macro_dsp_valuehl 
34c6				endm 
# End of macro FORTH_DSP_VALUEHL
34c6			 
34c6					; one value on hl get other one back 
34c6			 
34c6 d1					pop de 
34c7			 
34c7					; do the sub 
34c7			;		ex de, hl 
34c7			 
34c7 ed 52				sbc hl,de 
34c9			 
34c9					; save it 
34c9			 
34c9			;		push hl	 
34c9			 
34c9					; 
34c9			 
34c9					; destroy value TOS 
34c9			 
34c9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34c9 cd f7 1b			call macro_forth_dsp_pop 
34cc				endm 
# End of macro FORTH_DSP_POP
34cc			 
34cc					; TODO push value back onto stack for another op etc 
34cc			 
34cc			;		pop hl 
34cc			 
34cc cd 48 19				call forth_push_numhl 
34cf			.neg_done: 
34cf			 
34cf					NEXTW 
34cf c3 b1 1c			jp macro_next 
34d2				endm 
# End of macro NEXTW
34d2			.DIV: 
34d2				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
34d2 18				db WORD_SYS_CORE+4             
34d3 1f 35			dw .MUL            
34d5 02				db 1 + 1 
34d6 .. 00			db "/",0              
34d8				endm 
# End of macro CWHEAD
34d8			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
34d8					if DEBUG_FORTH_WORDS_KEY 
34d8						DMARK "DIV" 
34d8 f5				push af  
34d9 3a ed 34			ld a, (.dmark)  
34dc 32 7a ee			ld (debug_mark),a  
34df 3a ee 34			ld a, (.dmark+1)  
34e2 32 7b ee			ld (debug_mark+1),a  
34e5 3a ef 34			ld a, (.dmark+2)  
34e8 32 7c ee			ld (debug_mark+2),a  
34eb 18 03			jr .pastdmark  
34ed ..			.dmark: db "DIV"  
34f0 f1			.pastdmark: pop af  
34f1			endm  
# End of macro DMARK
34f1						CALLMONITOR 
34f1 cd bb 13			call break_point_state  
34f4				endm  
# End of macro CALLMONITOR
34f4					endif 
34f4				; TODO add floating point number detection 
34f4					; v5 FORTH_DSP_VALUE 
34f4					FORTH_DSP 
34f4 cd 05 1b			call macro_forth_dsp 
34f7				endm 
# End of macro FORTH_DSP
34f7 7e					ld a,(hl)	; get type of value on TOS 
34f8 fe 02				cp DS_TYPE_INUM  
34fa 28 03				jr z, .div_inum 
34fc			 
34fc				if FORTH_ENABLE_FLOATMATH 
34fc					jr .div_done 
34fc			 
34fc				endif 
34fc					NEXTW 
34fc c3 b1 1c			jp macro_next 
34ff				endm 
# End of macro NEXTW
34ff			.div_inum: 
34ff			 
34ff					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
34ff cd 3f 1b			call macro_dsp_valuehl 
3502				endm 
# End of macro FORTH_DSP_VALUEHL
3502			 
3502 e5					push hl    ; to go to bc 
3503			 
3503					; destroy value TOS 
3503			 
3503					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3503 cd f7 1b			call macro_forth_dsp_pop 
3506				endm 
# End of macro FORTH_DSP_POP
3506			 
3506			 
3506					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3506 cd 3f 1b			call macro_dsp_valuehl 
3509				endm 
# End of macro FORTH_DSP_VALUEHL
3509			 
3509					; hl to go to de 
3509			 
3509 e5					push hl 
350a			 
350a c1					pop bc 
350b d1					pop de		 
350c			 
350c			 
350c					if DEBUG_FORTH_MATHS 
350c						DMARK "DIV" 
350c				CALLMONITOR 
350c					endif 
350c					; one value on hl but move to a get other one back 
350c			 
350c			        
350c cd d1 0a			call Div16 
350f			 
350f			;	push af	 
350f e5				push hl 
3510 c5				push bc 
3511			 
3511					if DEBUG_FORTH_MATHS 
3511						DMARK "DI1" 
3511				CALLMONITOR 
3511					endif 
3511			 
3511					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3511 cd f7 1b			call macro_forth_dsp_pop 
3514				endm 
# End of macro FORTH_DSP_POP
3514			 
3514			 
3514			 
3514 e1					pop hl    ; result 
3515			 
3515 cd 48 19				call forth_push_numhl 
3518			 
3518 e1					pop hl    ; reminder 
3519			;		ld h,0 
3519			;		ld l,d 
3519			 
3519 cd 48 19				call forth_push_numhl 
351c			.div_done: 
351c					NEXTW 
351c c3 b1 1c			jp macro_next 
351f				endm 
# End of macro NEXTW
351f			.MUL: 
351f				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
351f 19				db WORD_SYS_CORE+5             
3520 64 35			dw .MIN            
3522 02				db 1 + 1 
3523 .. 00			db "*",0              
3525				endm 
# End of macro CWHEAD
3525			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3525				; TODO add floating point number detection 
3525					if DEBUG_FORTH_WORDS_KEY 
3525						DMARK "MUL" 
3525 f5				push af  
3526 3a 3a 35			ld a, (.dmark)  
3529 32 7a ee			ld (debug_mark),a  
352c 3a 3b 35			ld a, (.dmark+1)  
352f 32 7b ee			ld (debug_mark+1),a  
3532 3a 3c 35			ld a, (.dmark+2)  
3535 32 7c ee			ld (debug_mark+2),a  
3538 18 03			jr .pastdmark  
353a ..			.dmark: db "MUL"  
353d f1			.pastdmark: pop af  
353e			endm  
# End of macro DMARK
353e						CALLMONITOR 
353e cd bb 13			call break_point_state  
3541				endm  
# End of macro CALLMONITOR
3541					endif 
3541					FORTH_DSP 
3541 cd 05 1b			call macro_forth_dsp 
3544				endm 
# End of macro FORTH_DSP
3544					; v5 FORTH_DSP_VALUE 
3544 7e					ld a,(hl)	; get type of value on TOS 
3545 fe 02				cp DS_TYPE_INUM  
3547 28 03				jr z, .mul_inum 
3549			 
3549				if FORTH_ENABLE_FLOATMATH 
3549					jr .mul_done 
3549			 
3549				endif 
3549			 
3549					NEXTW 
3549 c3 b1 1c			jp macro_next 
354c				endm 
# End of macro NEXTW
354c			.mul_inum:	 
354c			 
354c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
354c cd 3f 1b			call macro_dsp_valuehl 
354f				endm 
# End of macro FORTH_DSP_VALUEHL
354f			 
354f e5					push hl 
3550			 
3550					; destroy value TOS 
3550			 
3550					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3550 cd f7 1b			call macro_forth_dsp_pop 
3553				endm 
# End of macro FORTH_DSP_POP
3553			 
3553			 
3553					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3553 cd 3f 1b			call macro_dsp_valuehl 
3556				endm 
# End of macro FORTH_DSP_VALUEHL
3556			 
3556					; one value on hl but move to a get other one back 
3556			 
3556 7d					ld a, l 
3557			 
3557 d1					pop de 
3558			 
3558					; do the mull 
3558			;		ex de, hl 
3558			 
3558 cd f7 0a				call Mult16 
355b					; save it 
355b			 
355b			;		push hl	 
355b			 
355b					; 
355b			 
355b					; destroy value TOS 
355b			 
355b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
355b cd f7 1b			call macro_forth_dsp_pop 
355e				endm 
# End of macro FORTH_DSP_POP
355e			 
355e					; TODO push value back onto stack for another op etc 
355e			 
355e			;		pop hl 
355e			 
355e cd 48 19				call forth_push_numhl 
3561			 
3561			.mul_done: 
3561					NEXTW 
3561 c3 b1 1c			jp macro_next 
3564				endm 
# End of macro NEXTW
3564			 
3564			 
3564			 
3564			 
3564			.MIN: 
3564				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3564 49				db WORD_SYS_CORE+53             
3565 e5 35			dw .MAX            
3567 04				db 3 + 1 
3568 .. 00			db "MIN",0              
356c				endm 
# End of macro CWHEAD
356c			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
356c					if DEBUG_FORTH_WORDS_KEY 
356c						DMARK "MIN" 
356c f5				push af  
356d 3a 81 35			ld a, (.dmark)  
3570 32 7a ee			ld (debug_mark),a  
3573 3a 82 35			ld a, (.dmark+1)  
3576 32 7b ee			ld (debug_mark+1),a  
3579 3a 83 35			ld a, (.dmark+2)  
357c 32 7c ee			ld (debug_mark+2),a  
357f 18 03			jr .pastdmark  
3581 ..			.dmark: db "MIN"  
3584 f1			.pastdmark: pop af  
3585			endm  
# End of macro DMARK
3585						CALLMONITOR 
3585 cd bb 13			call break_point_state  
3588				endm  
# End of macro CALLMONITOR
3588					endif 
3588					; get u2 
3588			 
3588					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3588 cd 3f 1b			call macro_dsp_valuehl 
358b				endm 
# End of macro FORTH_DSP_VALUEHL
358b			 
358b e5					push hl   ; u2 
358c			 
358c					; destroy value TOS 
358c			 
358c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
358c cd f7 1b			call macro_forth_dsp_pop 
358f				endm 
# End of macro FORTH_DSP_POP
358f			 
358f					; get u1 
358f			 
358f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
358f cd 3f 1b			call macro_dsp_valuehl 
3592				endm 
# End of macro FORTH_DSP_VALUEHL
3592			 
3592 e5					push hl  ; u1 
3593			 
3593					; destroy value TOS 
3593			 
3593					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3593 cd f7 1b			call macro_forth_dsp_pop 
3596				endm 
# End of macro FORTH_DSP_POP
3596			 
3596 b7			 or a      ;clear carry flag 
3597 e1			  pop hl    ; u1 
3598 d1			  pop de    ; u2 
3599 e5				push hl   ; saved in case hl is lowest 
359a ed 52		  sbc hl,de 
359c 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
359e			 
359e e1				pop hl 
359f					if DEBUG_FORTH_WORDS 
359f						DMARK "MIN" 
359f f5				push af  
35a0 3a b4 35			ld a, (.dmark)  
35a3 32 7a ee			ld (debug_mark),a  
35a6 3a b5 35			ld a, (.dmark+1)  
35a9 32 7b ee			ld (debug_mark+1),a  
35ac 3a b6 35			ld a, (.dmark+2)  
35af 32 7c ee			ld (debug_mark+2),a  
35b2 18 03			jr .pastdmark  
35b4 ..			.dmark: db "MIN"  
35b7 f1			.pastdmark: pop af  
35b8			endm  
# End of macro DMARK
35b8						CALLMONITOR 
35b8 cd bb 13			call break_point_state  
35bb				endm  
# End of macro CALLMONITOR
35bb					endif 
35bb cd 48 19				call forth_push_numhl 
35be			 
35be				       NEXTW 
35be c3 b1 1c			jp macro_next 
35c1				endm 
# End of macro NEXTW
35c1			 
35c1			.mincont:  
35c1 c1				pop bc   ; tidy up 
35c2 eb				ex de , hl  
35c3					if DEBUG_FORTH_WORDS 
35c3						DMARK "MI1" 
35c3 f5				push af  
35c4 3a d8 35			ld a, (.dmark)  
35c7 32 7a ee			ld (debug_mark),a  
35ca 3a d9 35			ld a, (.dmark+1)  
35cd 32 7b ee			ld (debug_mark+1),a  
35d0 3a da 35			ld a, (.dmark+2)  
35d3 32 7c ee			ld (debug_mark+2),a  
35d6 18 03			jr .pastdmark  
35d8 ..			.dmark: db "MI1"  
35db f1			.pastdmark: pop af  
35dc			endm  
# End of macro DMARK
35dc						CALLMONITOR 
35dc cd bb 13			call break_point_state  
35df				endm  
# End of macro CALLMONITOR
35df					endif 
35df cd 48 19				call forth_push_numhl 
35e2			 
35e2				       NEXTW 
35e2 c3 b1 1c			jp macro_next 
35e5				endm 
# End of macro NEXTW
35e5			.MAX: 
35e5				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
35e5 4a				db WORD_SYS_CORE+54             
35e6 66 36			dw .RND16            
35e8 04				db 3 + 1 
35e9 .. 00			db "MAX",0              
35ed				endm 
# End of macro CWHEAD
35ed			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
35ed					if DEBUG_FORTH_WORDS_KEY 
35ed						DMARK "MAX" 
35ed f5				push af  
35ee 3a 02 36			ld a, (.dmark)  
35f1 32 7a ee			ld (debug_mark),a  
35f4 3a 03 36			ld a, (.dmark+1)  
35f7 32 7b ee			ld (debug_mark+1),a  
35fa 3a 04 36			ld a, (.dmark+2)  
35fd 32 7c ee			ld (debug_mark+2),a  
3600 18 03			jr .pastdmark  
3602 ..			.dmark: db "MAX"  
3605 f1			.pastdmark: pop af  
3606			endm  
# End of macro DMARK
3606						CALLMONITOR 
3606 cd bb 13			call break_point_state  
3609				endm  
# End of macro CALLMONITOR
3609					endif 
3609					; get u2 
3609			 
3609					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3609 cd 3f 1b			call macro_dsp_valuehl 
360c				endm 
# End of macro FORTH_DSP_VALUEHL
360c			 
360c e5					push hl   ; u2 
360d			 
360d					; destroy value TOS 
360d			 
360d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
360d cd f7 1b			call macro_forth_dsp_pop 
3610				endm 
# End of macro FORTH_DSP_POP
3610			 
3610					; get u1 
3610			 
3610					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3610 cd 3f 1b			call macro_dsp_valuehl 
3613				endm 
# End of macro FORTH_DSP_VALUEHL
3613			 
3613 e5					push hl  ; u1 
3614			 
3614					; destroy value TOS 
3614			 
3614					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3614 cd f7 1b			call macro_forth_dsp_pop 
3617				endm 
# End of macro FORTH_DSP_POP
3617			 
3617 b7			 or a      ;clear carry flag 
3618 e1			  pop hl    ; u1 
3619 d1			  pop de    ; u2 
361a e5				push hl   ; saved in case hl is lowest 
361b ed 52		  sbc hl,de 
361d 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
361f			 
361f e1				pop hl 
3620					if DEBUG_FORTH_WORDS 
3620						DMARK "MAX" 
3620 f5				push af  
3621 3a 35 36			ld a, (.dmark)  
3624 32 7a ee			ld (debug_mark),a  
3627 3a 36 36			ld a, (.dmark+1)  
362a 32 7b ee			ld (debug_mark+1),a  
362d 3a 37 36			ld a, (.dmark+2)  
3630 32 7c ee			ld (debug_mark+2),a  
3633 18 03			jr .pastdmark  
3635 ..			.dmark: db "MAX"  
3638 f1			.pastdmark: pop af  
3639			endm  
# End of macro DMARK
3639						CALLMONITOR 
3639 cd bb 13			call break_point_state  
363c				endm  
# End of macro CALLMONITOR
363c					endif 
363c cd 48 19				call forth_push_numhl 
363f			 
363f				       NEXTW 
363f c3 b1 1c			jp macro_next 
3642				endm 
# End of macro NEXTW
3642			 
3642			.maxcont:  
3642 c1				pop bc   ; tidy up 
3643 eb				ex de , hl  
3644					if DEBUG_FORTH_WORDS 
3644						DMARK "MA1" 
3644 f5				push af  
3645 3a 59 36			ld a, (.dmark)  
3648 32 7a ee			ld (debug_mark),a  
364b 3a 5a 36			ld a, (.dmark+1)  
364e 32 7b ee			ld (debug_mark+1),a  
3651 3a 5b 36			ld a, (.dmark+2)  
3654 32 7c ee			ld (debug_mark+2),a  
3657 18 03			jr .pastdmark  
3659 ..			.dmark: db "MA1"  
365c f1			.pastdmark: pop af  
365d			endm  
# End of macro DMARK
365d						CALLMONITOR 
365d cd bb 13			call break_point_state  
3660				endm  
# End of macro CALLMONITOR
3660					endif 
3660 cd 48 19				call forth_push_numhl 
3663				       NEXTW 
3663 c3 b1 1c			jp macro_next 
3666				endm 
# End of macro NEXTW
3666			 
3666			.RND16: 
3666				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3666 4e				db WORD_SYS_CORE+58             
3667 95 36			dw .RND8            
3669 06				db 5 + 1 
366a .. 00			db "RND16",0              
3670				endm 
# End of macro CWHEAD
3670			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3670					if DEBUG_FORTH_WORDS_KEY 
3670						DMARK "R16" 
3670 f5				push af  
3671 3a 85 36			ld a, (.dmark)  
3674 32 7a ee			ld (debug_mark),a  
3677 3a 86 36			ld a, (.dmark+1)  
367a 32 7b ee			ld (debug_mark+1),a  
367d 3a 87 36			ld a, (.dmark+2)  
3680 32 7c ee			ld (debug_mark+2),a  
3683 18 03			jr .pastdmark  
3685 ..			.dmark: db "R16"  
3688 f1			.pastdmark: pop af  
3689			endm  
# End of macro DMARK
3689						CALLMONITOR 
3689 cd bb 13			call break_point_state  
368c				endm  
# End of macro CALLMONITOR
368c					endif 
368c cd 9b 0a				call prng16  
368f cd 48 19				call forth_push_numhl 
3692				       NEXTW 
3692 c3 b1 1c			jp macro_next 
3695				endm 
# End of macro NEXTW
3695			.RND8: 
3695				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3695 60				db WORD_SYS_CORE+76             
3696 ca 36			dw .RND            
3698 05				db 4 + 1 
3699 .. 00			db "RND8",0              
369e				endm 
# End of macro CWHEAD
369e			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
369e					if DEBUG_FORTH_WORDS_KEY 
369e						DMARK "RN8" 
369e f5				push af  
369f 3a b3 36			ld a, (.dmark)  
36a2 32 7a ee			ld (debug_mark),a  
36a5 3a b4 36			ld a, (.dmark+1)  
36a8 32 7b ee			ld (debug_mark+1),a  
36ab 3a b5 36			ld a, (.dmark+2)  
36ae 32 7c ee			ld (debug_mark+2),a  
36b1 18 03			jr .pastdmark  
36b3 ..			.dmark: db "RN8"  
36b6 f1			.pastdmark: pop af  
36b7			endm  
# End of macro DMARK
36b7						CALLMONITOR 
36b7 cd bb 13			call break_point_state  
36ba				endm  
# End of macro CALLMONITOR
36ba					endif 
36ba 2a bb eb				ld hl,(xrandc) 
36bd 23					inc hl 
36be cd b5 0a				call xrnd 
36c1 6f					ld l,a	 
36c2 26 00				ld h,0 
36c4 cd 48 19				call forth_push_numhl 
36c7				       NEXTW 
36c7 c3 b1 1c			jp macro_next 
36ca				endm 
# End of macro NEXTW
36ca			.RND: 
36ca				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
36ca 60				db WORD_SYS_CORE+76             
36cb d0 37			dw .ENDMATHS            
36cd 04				db 3 + 1 
36ce .. 00			db "RND",0              
36d2				endm 
# End of macro CWHEAD
36d2			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
36d2			 
36d2					if DEBUG_FORTH_WORDS_KEY 
36d2						DMARK "RND" 
36d2 f5				push af  
36d3 3a e7 36			ld a, (.dmark)  
36d6 32 7a ee			ld (debug_mark),a  
36d9 3a e8 36			ld a, (.dmark+1)  
36dc 32 7b ee			ld (debug_mark+1),a  
36df 3a e9 36			ld a, (.dmark+2)  
36e2 32 7c ee			ld (debug_mark+2),a  
36e5 18 03			jr .pastdmark  
36e7 ..			.dmark: db "RND"  
36ea f1			.pastdmark: pop af  
36eb			endm  
# End of macro DMARK
36eb						CALLMONITOR 
36eb cd bb 13			call break_point_state  
36ee				endm  
# End of macro CALLMONITOR
36ee					endif 
36ee					 
36ee					FORTH_DSP_VALUEHL    ; upper range 
36ee cd 3f 1b			call macro_dsp_valuehl 
36f1				endm 
# End of macro FORTH_DSP_VALUEHL
36f1			 
36f1 22 bf eb				ld (LFSRSeed), hl	 
36f4			 
36f4					if DEBUG_FORTH_WORDS 
36f4						DMARK "RN1" 
36f4 f5				push af  
36f5 3a 09 37			ld a, (.dmark)  
36f8 32 7a ee			ld (debug_mark),a  
36fb 3a 0a 37			ld a, (.dmark+1)  
36fe 32 7b ee			ld (debug_mark+1),a  
3701 3a 0b 37			ld a, (.dmark+2)  
3704 32 7c ee			ld (debug_mark+2),a  
3707 18 03			jr .pastdmark  
3709 ..			.dmark: db "RN1"  
370c f1			.pastdmark: pop af  
370d			endm  
# End of macro DMARK
370d						CALLMONITOR 
370d cd bb 13			call break_point_state  
3710				endm  
# End of macro CALLMONITOR
3710					endif 
3710					FORTH_DSP_POP 
3710 cd f7 1b			call macro_forth_dsp_pop 
3713				endm 
# End of macro FORTH_DSP_POP
3713			 
3713					FORTH_DSP_VALUEHL    ; low range 
3713 cd 3f 1b			call macro_dsp_valuehl 
3716				endm 
# End of macro FORTH_DSP_VALUEHL
3716			 
3716					if DEBUG_FORTH_WORDS 
3716						DMARK "RN2" 
3716 f5				push af  
3717 3a 2b 37			ld a, (.dmark)  
371a 32 7a ee			ld (debug_mark),a  
371d 3a 2c 37			ld a, (.dmark+1)  
3720 32 7b ee			ld (debug_mark+1),a  
3723 3a 2d 37			ld a, (.dmark+2)  
3726 32 7c ee			ld (debug_mark+2),a  
3729 18 03			jr .pastdmark  
372b ..			.dmark: db "RN2"  
372e f1			.pastdmark: pop af  
372f			endm  
# End of macro DMARK
372f						CALLMONITOR 
372f cd bb 13			call break_point_state  
3732				endm  
# End of macro CALLMONITOR
3732					endif 
3732 22 c1 eb				ld (LFSRSeed+2), hl 
3735			 
3735					FORTH_DSP_POP 
3735 cd f7 1b			call macro_forth_dsp_pop 
3738				endm 
# End of macro FORTH_DSP_POP
3738			 
3738 e5					push hl 
3739			 
3739 e1			.inrange:	pop hl 
373a cd 9b 0a				call prng16  
373d					if DEBUG_FORTH_WORDS 
373d						DMARK "RN3" 
373d f5				push af  
373e 3a 52 37			ld a, (.dmark)  
3741 32 7a ee			ld (debug_mark),a  
3744 3a 53 37			ld a, (.dmark+1)  
3747 32 7b ee			ld (debug_mark+1),a  
374a 3a 54 37			ld a, (.dmark+2)  
374d 32 7c ee			ld (debug_mark+2),a  
3750 18 03			jr .pastdmark  
3752 ..			.dmark: db "RN3"  
3755 f1			.pastdmark: pop af  
3756			endm  
# End of macro DMARK
3756						CALLMONITOR 
3756 cd bb 13			call break_point_state  
3759				endm  
# End of macro CALLMONITOR
3759					endif 
3759					 
3759					; if the range is 8bit knock out the high byte 
3759			 
3759 ed 5b bf eb			ld de, (LFSRSeed)     ; check high level 
375d			 
375d 3e 00				ld a, 0 
375f ba					cp d  
3760 20 1e				jr nz, .hirange 
3762 26 00				ld h, 0   ; knock it down to 8bit 
3764			 
3764					if DEBUG_FORTH_WORDS 
3764						DMARK "RNk" 
3764 f5				push af  
3765 3a 79 37			ld a, (.dmark)  
3768 32 7a ee			ld (debug_mark),a  
376b 3a 7a 37			ld a, (.dmark+1)  
376e 32 7b ee			ld (debug_mark+1),a  
3771 3a 7b 37			ld a, (.dmark+2)  
3774 32 7c ee			ld (debug_mark+2),a  
3777 18 03			jr .pastdmark  
3779 ..			.dmark: db "RNk"  
377c f1			.pastdmark: pop af  
377d			endm  
# End of macro DMARK
377d						CALLMONITOR 
377d cd bb 13			call break_point_state  
3780				endm  
# End of macro CALLMONITOR
3780					endif 
3780			.hirange:   
3780 e5					push hl  
3781 b7					or a  
3782 ed 52		                sbc hl, de 
3784			 
3784					;call cmp16 
3784			 
3784 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3786 e1					pop hl 
3787 e5					push hl 
3788			 
3788					if DEBUG_FORTH_WORDS 
3788						DMARK "RN4" 
3788 f5				push af  
3789 3a 9d 37			ld a, (.dmark)  
378c 32 7a ee			ld (debug_mark),a  
378f 3a 9e 37			ld a, (.dmark+1)  
3792 32 7b ee			ld (debug_mark+1),a  
3795 3a 9f 37			ld a, (.dmark+2)  
3798 32 7c ee			ld (debug_mark+2),a  
379b 18 03			jr .pastdmark  
379d ..			.dmark: db "RN4"  
37a0 f1			.pastdmark: pop af  
37a1			endm  
# End of macro DMARK
37a1						CALLMONITOR 
37a1 cd bb 13			call break_point_state  
37a4				endm  
# End of macro CALLMONITOR
37a4					endif 
37a4 ed 5b c1 eb			ld de, (LFSRSeed+2)   ; check low range 
37a8					;call cmp16 
37a8				 
37a8 b7					or a  
37a9 ed 52		                sbc hl, de 
37ab 38 8c				jr c, .inrange 
37ad			 
37ad e1					pop hl 
37ae					 
37ae					if DEBUG_FORTH_WORDS 
37ae						DMARK "RNd" 
37ae f5				push af  
37af 3a c3 37			ld a, (.dmark)  
37b2 32 7a ee			ld (debug_mark),a  
37b5 3a c4 37			ld a, (.dmark+1)  
37b8 32 7b ee			ld (debug_mark+1),a  
37bb 3a c5 37			ld a, (.dmark+2)  
37be 32 7c ee			ld (debug_mark+2),a  
37c1 18 03			jr .pastdmark  
37c3 ..			.dmark: db "RNd"  
37c6 f1			.pastdmark: pop af  
37c7			endm  
# End of macro DMARK
37c7						CALLMONITOR 
37c7 cd bb 13			call break_point_state  
37ca				endm  
# End of macro CALLMONITOR
37ca					endif 
37ca			 
37ca			 
37ca cd 48 19				call forth_push_numhl 
37cd				       NEXTW 
37cd c3 b1 1c			jp macro_next 
37d0				endm 
# End of macro NEXTW
37d0			 
37d0			.ENDMATHS: 
37d0			 
37d0			; eof 
37d0			 
# End of file forth_words_maths.asm
37d0			include "forth_words_display.asm" 
37d0			 
37d0			; | ## Display Words 
37d0			 
37d0			.ATP: 
37d0				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
37d0 62				db WORD_SYS_CORE+78             
37d1 47 38			dw .FB            
37d3 04				db 3 + 1 
37d4 .. 00			db "AT?",0              
37d8				endm 
# End of macro CWHEAD
37d8			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
37d8					if DEBUG_FORTH_WORDS_KEY 
37d8						DMARK "AT?" 
37d8 f5				push af  
37d9 3a ed 37			ld a, (.dmark)  
37dc 32 7a ee			ld (debug_mark),a  
37df 3a ee 37			ld a, (.dmark+1)  
37e2 32 7b ee			ld (debug_mark+1),a  
37e5 3a ef 37			ld a, (.dmark+2)  
37e8 32 7c ee			ld (debug_mark+2),a  
37eb 18 03			jr .pastdmark  
37ed ..			.dmark: db "AT?"  
37f0 f1			.pastdmark: pop af  
37f1			endm  
# End of macro DMARK
37f1						CALLMONITOR 
37f1 cd bb 13			call break_point_state  
37f4				endm  
# End of macro CALLMONITOR
37f4					endif 
37f4 3a 49 eb				ld a, (f_cursor_ptr) 
37f7			 
37f7			if DEBUG_FORTH_WORDS 
37f7				DMARK "AT?" 
37f7 f5				push af  
37f8 3a 0c 38			ld a, (.dmark)  
37fb 32 7a ee			ld (debug_mark),a  
37fe 3a 0d 38			ld a, (.dmark+1)  
3801 32 7b ee			ld (debug_mark+1),a  
3804 3a 0e 38			ld a, (.dmark+2)  
3807 32 7c ee			ld (debug_mark+2),a  
380a 18 03			jr .pastdmark  
380c ..			.dmark: db "AT?"  
380f f1			.pastdmark: pop af  
3810			endm  
# End of macro DMARK
3810				CALLMONITOR 
3810 cd bb 13			call break_point_state  
3813				endm  
# End of macro CALLMONITOR
3813			endif	 
3813					; count the number of rows 
3813			 
3813 06 00				ld b, 0 
3815 4f			.atpr:		ld c, a    ; save in case we go below zero 
3816 d6 28				sub display_cols 
3818 f2 1e 38				jp p, .atprunder 
381b 04					inc b 
381c 18 f7				jr .atpr 
381e			.atprunder:	 
381e			if DEBUG_FORTH_WORDS 
381e				DMARK "A?2" 
381e f5				push af  
381f 3a 33 38			ld a, (.dmark)  
3822 32 7a ee			ld (debug_mark),a  
3825 3a 34 38			ld a, (.dmark+1)  
3828 32 7b ee			ld (debug_mark+1),a  
382b 3a 35 38			ld a, (.dmark+2)  
382e 32 7c ee			ld (debug_mark+2),a  
3831 18 03			jr .pastdmark  
3833 ..			.dmark: db "A?2"  
3836 f1			.pastdmark: pop af  
3837			endm  
# End of macro DMARK
3837				CALLMONITOR 
3837 cd bb 13			call break_point_state  
383a				endm  
# End of macro CALLMONITOR
383a			endif	 
383a 26 00				ld h, 0 
383c 69					ld l, c 
383d cd 48 19				call forth_push_numhl 
3840 68					ld l, b  
3841 cd 48 19				call forth_push_numhl 
3844			 
3844			 
3844				NEXTW 
3844 c3 b1 1c			jp macro_next 
3847				endm 
# End of macro NEXTW
3847			 
3847			.FB: 
3847				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3847 1b				db WORD_SYS_CORE+7             
3848 95 38			dw .EMIT            
384a 03				db 2 + 1 
384b .. 00			db "FB",0              
384e				endm 
# End of macro CWHEAD
384e			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
384e			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
384e			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
384e			; | | If automatic display is off then updates will not be shown until DRAW is used. 
384e					if DEBUG_FORTH_WORDS_KEY 
384e						DMARK "FB." 
384e f5				push af  
384f 3a 63 38			ld a, (.dmark)  
3852 32 7a ee			ld (debug_mark),a  
3855 3a 64 38			ld a, (.dmark+1)  
3858 32 7b ee			ld (debug_mark+1),a  
385b 3a 65 38			ld a, (.dmark+2)  
385e 32 7c ee			ld (debug_mark+2),a  
3861 18 03			jr .pastdmark  
3863 ..			.dmark: db "FB."  
3866 f1			.pastdmark: pop af  
3867			endm  
# End of macro DMARK
3867						CALLMONITOR 
3867 cd bb 13			call break_point_state  
386a				endm  
# End of macro CALLMONITOR
386a					endif 
386a			 
386a					FORTH_DSP_VALUEHL 
386a cd 3f 1b			call macro_dsp_valuehl 
386d				endm 
# End of macro FORTH_DSP_VALUEHL
386d			 
386d 7d					ld a, l 
386e fe 01				cp 1 
3870 20 05				jr nz, .fbn1 
3872 21 1f ed				ld hl, display_fb1 
3875 18 15				jr .fbset 
3877 fe 02		.fbn1:		cp 2 
3879 20 05				jr nz, .fbn2 
387b 21 dd eb				ld hl, display_fb2 
387e 18 0c				jr .fbset 
3880 fe 03		.fbn2:		cp 3 
3882 20 05				jr nz, .fbn3 
3884 21 7e ec				ld hl, display_fb3 
3887 18 03				jr .fbset 
3889			.fbn3:		 ; if invalid number select first 
3889 21 1f ed				ld hl, display_fb1 
388c 22 db eb		.fbset:		ld (display_fb_active), hl 
388f			 
388f					FORTH_DSP_POP 
388f cd f7 1b			call macro_forth_dsp_pop 
3892				endm 
# End of macro FORTH_DSP_POP
3892			 
3892					NEXTW 
3892 c3 b1 1c			jp macro_next 
3895				endm 
# End of macro NEXTW
3895			 
3895			 
3895			.EMIT: 
3895				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3895 1b				db WORD_SYS_CORE+7             
3896 e6 38			dw .DOTH            
3898 05				db 4 + 1 
3899 .. 00			db "EMIT",0              
389e				endm 
# End of macro CWHEAD
389e			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
389e					; get value off TOS and display it 
389e			 
389e					if DEBUG_FORTH_WORDS_KEY 
389e						DMARK "EMT" 
389e f5				push af  
389f 3a b3 38			ld a, (.dmark)  
38a2 32 7a ee			ld (debug_mark),a  
38a5 3a b4 38			ld a, (.dmark+1)  
38a8 32 7b ee			ld (debug_mark+1),a  
38ab 3a b5 38			ld a, (.dmark+2)  
38ae 32 7c ee			ld (debug_mark+2),a  
38b1 18 03			jr .pastdmark  
38b3 ..			.dmark: db "EMT"  
38b6 f1			.pastdmark: pop af  
38b7			endm  
# End of macro DMARK
38b7						CALLMONITOR 
38b7 cd bb 13			call break_point_state  
38ba				endm  
# End of macro CALLMONITOR
38ba					endif 
38ba			 
38ba					FORTH_DSP_VALUEHL 
38ba cd 3f 1b			call macro_dsp_valuehl 
38bd				endm 
# End of macro FORTH_DSP_VALUEHL
38bd			 
38bd 7d					ld a,l 
38be			 
38be					; TODO write to display 
38be			 
38be 32 5e e5				ld (os_input), a 
38c1 3e 00				ld a, 0 
38c3 32 5f e5				ld (os_input+1), a 
38c6					 
38c6 3a 49 eb				ld a, (f_cursor_ptr) 
38c9 11 5e e5				ld de, os_input 
38cc cd 5a 09				call str_at_display 
38cf			 
38cf			 
38cf 3a 27 eb				ld a,(cli_autodisplay) 
38d2 fe 00				cp 0 
38d4 28 03				jr z, .enoupdate 
38d6 cd 6a 09						call update_display 
38d9					.enoupdate: 
38d9			 
38d9 3a 49 eb				ld a, (f_cursor_ptr) 
38dc 3c					inc a 
38dd 32 49 eb				ld (f_cursor_ptr), a   ; save new pos 
38e0			 
38e0			 
38e0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38e0 cd f7 1b			call macro_forth_dsp_pop 
38e3				endm 
# End of macro FORTH_DSP_POP
38e3			  
38e3			 
38e3					NEXTW 
38e3 c3 b1 1c			jp macro_next 
38e6				endm 
# End of macro NEXTW
38e6			.DOTH: 
38e6				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
38e6 1c				db WORD_SYS_CORE+8             
38e7 16 39			dw .DOTF            
38e9 03				db 2 + 1 
38ea .. 00			db ".-",0              
38ed				endm 
# End of macro CWHEAD
38ed			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
38ed					; get value off TOS and display it 
38ed					if DEBUG_FORTH_WORDS_KEY 
38ed						DMARK "DTD" 
38ed f5				push af  
38ee 3a 02 39			ld a, (.dmark)  
38f1 32 7a ee			ld (debug_mark),a  
38f4 3a 03 39			ld a, (.dmark+1)  
38f7 32 7b ee			ld (debug_mark+1),a  
38fa 3a 04 39			ld a, (.dmark+2)  
38fd 32 7c ee			ld (debug_mark+2),a  
3900 18 03			jr .pastdmark  
3902 ..			.dmark: db "DTD"  
3905 f1			.pastdmark: pop af  
3906			endm  
# End of macro DMARK
3906						CALLMONITOR 
3906 cd bb 13			call break_point_state  
3909				endm  
# End of macro CALLMONITOR
3909					endif 
3909 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
390b 3e 00			ld a, 0 
390d 32 28 eb			ld (cli_mvdot), a 
3910 c3 6d 39			jp .dotgo 
3913				NEXTW 
3913 c3 b1 1c			jp macro_next 
3916				endm 
# End of macro NEXTW
3916			.DOTF: 
3916				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3916 1c				db WORD_SYS_CORE+8             
3917 44 39			dw .DOT            
3919 03				db 2 + 1 
391a .. 00			db ".>",0              
391d				endm 
# End of macro CWHEAD
391d			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
391d					; get value off TOS and display it 
391d			        ; TODO BUG adds extra spaces 
391d			        ; TODO BUG handle numerics? 
391d					if DEBUG_FORTH_WORDS_KEY 
391d						DMARK "DTC" 
391d f5				push af  
391e 3a 32 39			ld a, (.dmark)  
3921 32 7a ee			ld (debug_mark),a  
3924 3a 33 39			ld a, (.dmark+1)  
3927 32 7b ee			ld (debug_mark+1),a  
392a 3a 34 39			ld a, (.dmark+2)  
392d 32 7c ee			ld (debug_mark+2),a  
3930 18 03			jr .pastdmark  
3932 ..			.dmark: db "DTC"  
3935 f1			.pastdmark: pop af  
3936			endm  
# End of macro DMARK
3936						CALLMONITOR 
3936 cd bb 13			call break_point_state  
3939				endm  
# End of macro CALLMONITOR
3939					endif 
3939 3e 01			ld a, 1 
393b 32 28 eb			ld (cli_mvdot), a 
393e c3 6d 39			jp .dotgo 
3941				NEXTW 
3941 c3 b1 1c			jp macro_next 
3944				endm 
# End of macro NEXTW
3944			 
3944			.DOT: 
3944				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3944 1c				db WORD_SYS_CORE+8             
3945 d0 39			dw .CLS            
3947 02				db 1 + 1 
3948 .. 00			db ".",0              
394a				endm 
# End of macro CWHEAD
394a			        ; | . ( u -- ) Display TOS | DONE 
394a					; get value off TOS and display it 
394a			 
394a					if DEBUG_FORTH_WORDS_KEY 
394a						DMARK "DOT" 
394a f5				push af  
394b 3a 5f 39			ld a, (.dmark)  
394e 32 7a ee			ld (debug_mark),a  
3951 3a 60 39			ld a, (.dmark+1)  
3954 32 7b ee			ld (debug_mark+1),a  
3957 3a 61 39			ld a, (.dmark+2)  
395a 32 7c ee			ld (debug_mark+2),a  
395d 18 03			jr .pastdmark  
395f ..			.dmark: db "DOT"  
3962 f1			.pastdmark: pop af  
3963			endm  
# End of macro DMARK
3963						CALLMONITOR 
3963 cd bb 13			call break_point_state  
3966				endm  
# End of macro CALLMONITOR
3966					endif 
3966 3e 00			ld a, 0 
3968 32 28 eb			ld (cli_mvdot), a 
396b 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
396d				 
396d			 
396d			.dotgo: 
396d			 
396d			; move up type to on stack for parserv5 
396d					FORTH_DSP 
396d cd 05 1b			call macro_forth_dsp 
3970				endm 
# End of macro FORTH_DSP
3970				;FORTH_DSP_VALUE  
3970			 
3970			if DEBUG_FORTH_DOT 
3970				DMARK "DOT" 
3970				CALLMONITOR 
3970			endif	 
3970			;		.print: 
3970			 
3970 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3971 23				inc hl   ; position to the actual value 
3972 fe 01			cp DS_TYPE_STR 
3974 20 06			jr nz, .dotnum1  
3976			 
3976			; display string 
3976				FORTH_DSP_VALUE  
3976 cd 28 1b			call macro_forth_dsp_value 
3979				endm 
# End of macro FORTH_DSP_VALUE
3979 eb				ex de,hl 
397a 18 11			jr .dotwrite 
397c			 
397c			.dotnum1: 
397c fe 02			cp DS_TYPE_INUM 
397e 20 0c			jr nz, .dotflot 
3980			 
3980			 
3980			; display number 
3980			 
3980			;	push hl 
3980			;	call clear_display 
3980			;	pop hl 
3980			 
3980 5e				ld e, (hl) 
3981 23				inc hl 
3982 56				ld d, (hl) 
3983 21 60 e3			ld hl, scratch 
3986			if DEBUG_FORTH_DOT 
3986				DMARK "DT1" 
3986				CALLMONITOR 
3986			endif	 
3986			 
3986 cd 81 0f			call uitoa_16 
3989 eb				ex de,hl 
398a			 
398a			if DEBUG_FORTH_DOT 
398a				DMARK "DT2" 
398a				CALLMONITOR 
398a			endif	 
398a			 
398a			;	ld de, os_word_scratch 
398a 18 01			jr .dotwrite 
398c			 
398c 00			.dotflot:   nop 
398d			; TODO print floating point number 
398d			 
398d			.dotwrite:		 
398d			 
398d					; if c is set then set all '-' to spaces 
398d					; need to also take into account .>  
398d			 
398d 3e 01				ld a, 1 
398f b9					cp c 
3990 20 13				jr nz, .nodashswap 
3992			 
3992					; DE has the string to write, working with HL 
3992			 
3992 06 ff				ld b, 255 
3994 d5					push de 
3995 e1					pop hl 
3996			 
3996			if DEBUG_FORTH_DOT 
3996				DMARK "DT-" 
3996				CALLMONITOR 
3996			endif	 
3996 7e			.dashscan:	ld a, (hl) 
3997 fe 00				cp 0 
3999 28 0a				jr z, .nodashswap 
399b fe 2d				cp '-' 
399d 20 03				jr nz, .dashskip 
399f 3e 20				ld a, ' ' 
39a1 77					ld (hl), a 
39a2 23			.dashskip:	inc hl 
39a3			if DEBUG_FORTH_DOT 
39a3				DMARK "D-2" 
39a3				CALLMONITOR 
39a3			endif	 
39a3 10 f1				djnz .dashscan 
39a5			 
39a5			if DEBUG_FORTH_DOT 
39a5				DMARK "D-1" 
39a5				CALLMONITOR 
39a5			endif	 
39a5			 
39a5			.nodashswap: 
39a5			 
39a5 e5					push hl   ; save string start in case we need to advance print 
39a6			 
39a6 3a 49 eb				ld a, (f_cursor_ptr) 
39a9 cd 5a 09				call str_at_display 
39ac 3a 27 eb				ld a,(cli_autodisplay) 
39af fe 00				cp 0 
39b1 28 03				jr z, .noupdate 
39b3 cd 6a 09						call update_display 
39b6					.noupdate: 
39b6			 
39b6			 
39b6					; see if we need to advance the print position 
39b6			 
39b6 e1					pop hl   ; get back string 
39b7			 
39b7 3a 28 eb				ld a, (cli_mvdot) 
39ba			if DEBUG_FORTH_DOT 
39ba					ld e,a 
39ba				DMARK "D>1" 
39ba				CALLMONITOR 
39ba			endif	 
39ba fe 00				cp 0 
39bc 28 0c				jr z, .noadv 
39be					; yes, lets advance the print position 
39be 3e 00				ld a, 0 
39c0 cd dd 0f				call strlent 
39c3 3a 49 eb				ld a, (f_cursor_ptr) 
39c6 85					add a,l 
39c7					;call addatohl 
39c7					;ld a, l 
39c7 32 49 eb				ld (f_cursor_ptr), a   ; save new pos 
39ca			 
39ca			if DEBUG_FORTH_DOT 
39ca				DMARK "D->" 
39ca				CALLMONITOR 
39ca			endif	 
39ca			 
39ca			.noadv:	 
39ca			 
39ca					if DEBUG_FORTH_DOT_WAIT 
39ca							call next_page_prompt 
39ca					endif	 
39ca			; TODO this pop off the stack causes a crash. i dont know why 
39ca			 
39ca			 
39ca			if DEBUG_FORTH_DOT 
39ca				DMARK "DTh" 
39ca				CALLMONITOR 
39ca			endif	 
39ca			 
39ca					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39ca cd f7 1b			call macro_forth_dsp_pop 
39cd				endm 
# End of macro FORTH_DSP_POP
39cd			 
39cd			if DEBUG_FORTH_DOT 
39cd				DMARK "DTi" 
39cd				CALLMONITOR 
39cd			endif	 
39cd			 
39cd			 
39cd					NEXTW 
39cd c3 b1 1c			jp macro_next 
39d0				endm 
# End of macro NEXTW
39d0			 
39d0			.CLS: 
39d0				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
39d0 35				db WORD_SYS_CORE+33             
39d1 fd 39			dw .DRAW            
39d3 04				db 3 + 1 
39d4 .. 00			db "CLS",0              
39d8				endm 
# End of macro CWHEAD
39d8			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
39d8					if DEBUG_FORTH_WORDS_KEY 
39d8						DMARK "CLS" 
39d8 f5				push af  
39d9 3a ed 39			ld a, (.dmark)  
39dc 32 7a ee			ld (debug_mark),a  
39df 3a ee 39			ld a, (.dmark+1)  
39e2 32 7b ee			ld (debug_mark+1),a  
39e5 3a ef 39			ld a, (.dmark+2)  
39e8 32 7c ee			ld (debug_mark+2),a  
39eb 18 03			jr .pastdmark  
39ed ..			.dmark: db "CLS"  
39f0 f1			.pastdmark: pop af  
39f1			endm  
# End of macro DMARK
39f1						CALLMONITOR 
39f1 cd bb 13			call break_point_state  
39f4				endm  
# End of macro CALLMONITOR
39f4					endif 
39f4 cd 47 09				call clear_display 
39f7 c3 0b 3b				jp .home		; and home cursor 
39fa					NEXTW 
39fa c3 b1 1c			jp macro_next 
39fd				endm 
# End of macro NEXTW
39fd			 
39fd			.DRAW: 
39fd				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
39fd 36				db WORD_SYS_CORE+34             
39fe 28 3a			dw .DUMP            
3a00 05				db 4 + 1 
3a01 .. 00			db "DRAW",0              
3a06				endm 
# End of macro CWHEAD
3a06			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3a06					if DEBUG_FORTH_WORDS_KEY 
3a06						DMARK "DRW" 
3a06 f5				push af  
3a07 3a 1b 3a			ld a, (.dmark)  
3a0a 32 7a ee			ld (debug_mark),a  
3a0d 3a 1c 3a			ld a, (.dmark+1)  
3a10 32 7b ee			ld (debug_mark+1),a  
3a13 3a 1d 3a			ld a, (.dmark+2)  
3a16 32 7c ee			ld (debug_mark+2),a  
3a19 18 03			jr .pastdmark  
3a1b ..			.dmark: db "DRW"  
3a1e f1			.pastdmark: pop af  
3a1f			endm  
# End of macro DMARK
3a1f						CALLMONITOR 
3a1f cd bb 13			call break_point_state  
3a22				endm  
# End of macro CALLMONITOR
3a22					endif 
3a22 cd 6a 09				call update_display 
3a25					NEXTW 
3a25 c3 b1 1c			jp macro_next 
3a28				endm 
# End of macro NEXTW
3a28			 
3a28			.DUMP: 
3a28				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3a28 37				db WORD_SYS_CORE+35             
3a29 60 3a			dw .CDUMP            
3a2b 05				db 4 + 1 
3a2c .. 00			db "DUMP",0              
3a31				endm 
# End of macro CWHEAD
3a31			; | DUMP ( x -- ) With address x display dump   | DONE 
3a31			; TODO pop address to use off of the stack 
3a31					if DEBUG_FORTH_WORDS_KEY 
3a31						DMARK "DUM" 
3a31 f5				push af  
3a32 3a 46 3a			ld a, (.dmark)  
3a35 32 7a ee			ld (debug_mark),a  
3a38 3a 47 3a			ld a, (.dmark+1)  
3a3b 32 7b ee			ld (debug_mark+1),a  
3a3e 3a 48 3a			ld a, (.dmark+2)  
3a41 32 7c ee			ld (debug_mark+2),a  
3a44 18 03			jr .pastdmark  
3a46 ..			.dmark: db "DUM"  
3a49 f1			.pastdmark: pop af  
3a4a			endm  
# End of macro DMARK
3a4a						CALLMONITOR 
3a4a cd bb 13			call break_point_state  
3a4d				endm  
# End of macro CALLMONITOR
3a4d					endif 
3a4d cd 47 09				call clear_display 
3a50			 
3a50					; get address 
3a50			 
3a50					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a50 cd 3f 1b			call macro_dsp_valuehl 
3a53				endm 
# End of macro FORTH_DSP_VALUEHL
3a53				 
3a53					; save it for cdump 
3a53			 
3a53 22 83 e6				ld (os_cur_ptr),hl 
3a56			 
3a56					; destroy value TOS 
3a56			 
3a56					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a56 cd f7 1b			call macro_forth_dsp_pop 
3a59				endm 
# End of macro FORTH_DSP_POP
3a59			 
3a59 cd c8 17				call dumpcont	; skip old style of param parsing	 
3a5c c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3a5d					NEXTW 
3a5d c3 b1 1c			jp macro_next 
3a60				endm 
# End of macro NEXTW
3a60			.CDUMP: 
3a60				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3a60 38				db WORD_SYS_CORE+36             
3a61 90 3a			dw .DAT            
3a63 06				db 5 + 1 
3a64 .. 00			db "CDUMP",0              
3a6a				endm 
# End of macro CWHEAD
3a6a			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3a6a					if DEBUG_FORTH_WORDS_KEY 
3a6a						DMARK "CDP" 
3a6a f5				push af  
3a6b 3a 7f 3a			ld a, (.dmark)  
3a6e 32 7a ee			ld (debug_mark),a  
3a71 3a 80 3a			ld a, (.dmark+1)  
3a74 32 7b ee			ld (debug_mark+1),a  
3a77 3a 81 3a			ld a, (.dmark+2)  
3a7a 32 7c ee			ld (debug_mark+2),a  
3a7d 18 03			jr .pastdmark  
3a7f ..			.dmark: db "CDP"  
3a82 f1			.pastdmark: pop af  
3a83			endm  
# End of macro DMARK
3a83						CALLMONITOR 
3a83 cd bb 13			call break_point_state  
3a86				endm  
# End of macro CALLMONITOR
3a86					endif 
3a86 cd 47 09				call clear_display 
3a89 cd c8 17				call dumpcont	 
3a8c c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3a8d					NEXTW 
3a8d c3 b1 1c			jp macro_next 
3a90				endm 
# End of macro NEXTW
3a90			 
3a90			 
3a90			 
3a90			 
3a90			.DAT: 
3a90				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3a90 3d				db WORD_SYS_CORE+41             
3a91 e6 3a			dw .HOME            
3a93 03				db 2 + 1 
3a94 .. 00			db "AT",0              
3a97				endm 
# End of macro CWHEAD
3a97			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3a97					if DEBUG_FORTH_WORDS_KEY 
3a97						DMARK "AT." 
3a97 f5				push af  
3a98 3a ac 3a			ld a, (.dmark)  
3a9b 32 7a ee			ld (debug_mark),a  
3a9e 3a ad 3a			ld a, (.dmark+1)  
3aa1 32 7b ee			ld (debug_mark+1),a  
3aa4 3a ae 3a			ld a, (.dmark+2)  
3aa7 32 7c ee			ld (debug_mark+2),a  
3aaa 18 03			jr .pastdmark  
3aac ..			.dmark: db "AT."  
3aaf f1			.pastdmark: pop af  
3ab0			endm  
# End of macro DMARK
3ab0						CALLMONITOR 
3ab0 cd bb 13			call break_point_state  
3ab3				endm  
# End of macro CALLMONITOR
3ab3					endif 
3ab3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ab3 cd 3f 1b			call macro_dsp_valuehl 
3ab6				endm 
# End of macro FORTH_DSP_VALUEHL
3ab6			 
3ab6			 
3ab6					; TODO save cursor row 
3ab6 7d					ld a,l 
3ab7 fe 02				cp 2 
3ab9 20 04				jr nz, .crow3 
3abb 3e 28				ld a, display_row_2 
3abd 18 12				jr .ccol1 
3abf fe 03		.crow3:		cp 3 
3ac1 20 04				jr nz, .crow4 
3ac3 3e 50				ld a, display_row_3 
3ac5 18 0a				jr .ccol1 
3ac7 fe 04		.crow4:		cp 4 
3ac9 20 04				jr nz, .crow1 
3acb 3e 78				ld a, display_row_4 
3acd 18 02				jr .ccol1 
3acf 3e 00		.crow1:		ld a,display_row_1 
3ad1 f5			.ccol1:		push af			; got row offset 
3ad2 6f					ld l,a 
3ad3 26 00				ld h,0 
3ad5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ad5 cd f7 1b			call macro_forth_dsp_pop 
3ad8				endm 
# End of macro FORTH_DSP_POP
3ad8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ad8 cd 3f 1b			call macro_dsp_valuehl 
3adb				endm 
# End of macro FORTH_DSP_VALUEHL
3adb					; TODO save cursor col 
3adb f1					pop af 
3adc 85					add l		; add col offset 
3add 32 49 eb				ld (f_cursor_ptr), a 
3ae0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ae0 cd f7 1b			call macro_forth_dsp_pop 
3ae3				endm 
# End of macro FORTH_DSP_POP
3ae3			 
3ae3					; calculate  
3ae3			 
3ae3					NEXTW 
3ae3 c3 b1 1c			jp macro_next 
3ae6				endm 
# End of macro NEXTW
3ae6			 
3ae6			 
3ae6			.HOME: 
3ae6				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3ae6 41				db WORD_SYS_CORE+45             
3ae7 13 3b			dw .SPACE            
3ae9 05				db 4 + 1 
3aea .. 00			db "HOME",0              
3aef				endm 
# End of macro CWHEAD
3aef			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3aef					if DEBUG_FORTH_WORDS_KEY 
3aef						DMARK "HOM" 
3aef f5				push af  
3af0 3a 04 3b			ld a, (.dmark)  
3af3 32 7a ee			ld (debug_mark),a  
3af6 3a 05 3b			ld a, (.dmark+1)  
3af9 32 7b ee			ld (debug_mark+1),a  
3afc 3a 06 3b			ld a, (.dmark+2)  
3aff 32 7c ee			ld (debug_mark+2),a  
3b02 18 03			jr .pastdmark  
3b04 ..			.dmark: db "HOM"  
3b07 f1			.pastdmark: pop af  
3b08			endm  
# End of macro DMARK
3b08						CALLMONITOR 
3b08 cd bb 13			call break_point_state  
3b0b				endm  
# End of macro CALLMONITOR
3b0b					endif 
3b0b 3e 00		.home:		ld a, 0		; and home cursor 
3b0d 32 49 eb				ld (f_cursor_ptr), a 
3b10					NEXTW 
3b10 c3 b1 1c			jp macro_next 
3b13				endm 
# End of macro NEXTW
3b13			 
3b13			 
3b13			.SPACE: 
3b13				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3b13 46				db WORD_SYS_CORE+50             
3b14 41 3b			dw .SPACES            
3b16 03				db 2 + 1 
3b17 .. 00			db "BL",0              
3b1a				endm 
# End of macro CWHEAD
3b1a			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3b1a					if DEBUG_FORTH_WORDS_KEY 
3b1a						DMARK "BL." 
3b1a f5				push af  
3b1b 3a 2f 3b			ld a, (.dmark)  
3b1e 32 7a ee			ld (debug_mark),a  
3b21 3a 30 3b			ld a, (.dmark+1)  
3b24 32 7b ee			ld (debug_mark+1),a  
3b27 3a 31 3b			ld a, (.dmark+2)  
3b2a 32 7c ee			ld (debug_mark+2),a  
3b2d 18 03			jr .pastdmark  
3b2f ..			.dmark: db "BL."  
3b32 f1			.pastdmark: pop af  
3b33			endm  
# End of macro DMARK
3b33						CALLMONITOR 
3b33 cd bb 13			call break_point_state  
3b36				endm  
# End of macro CALLMONITOR
3b36					endif 
3b36 21 3f 3b				ld hl, .blstr 
3b39 cd b6 19				call forth_push_str 
3b3c					 
3b3c				       NEXTW 
3b3c c3 b1 1c			jp macro_next 
3b3f				endm 
# End of macro NEXTW
3b3f			 
3b3f .. 00		.blstr: db " ", 0 
3b41			 
3b41			.SPACES: 
3b41				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3b41 47				db WORD_SYS_CORE+51             
3b42 dc 3b			dw .SCROLL            
3b44 07				db 6 + 1 
3b45 .. 00			db "SPACES",0              
3b4c				endm 
# End of macro CWHEAD
3b4c			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
3b4c					if DEBUG_FORTH_WORDS_KEY 
3b4c						DMARK "SPS" 
3b4c f5				push af  
3b4d 3a 61 3b			ld a, (.dmark)  
3b50 32 7a ee			ld (debug_mark),a  
3b53 3a 62 3b			ld a, (.dmark+1)  
3b56 32 7b ee			ld (debug_mark+1),a  
3b59 3a 63 3b			ld a, (.dmark+2)  
3b5c 32 7c ee			ld (debug_mark+2),a  
3b5f 18 03			jr .pastdmark  
3b61 ..			.dmark: db "SPS"  
3b64 f1			.pastdmark: pop af  
3b65			endm  
# End of macro DMARK
3b65						CALLMONITOR 
3b65 cd bb 13			call break_point_state  
3b68				endm  
# End of macro CALLMONITOR
3b68					endif 
3b68			 
3b68			 
3b68					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b68 cd 3f 1b			call macro_dsp_valuehl 
3b6b				endm 
# End of macro FORTH_DSP_VALUEHL
3b6b			 
3b6b			;		push hl    ; u 
3b6b					if DEBUG_FORTH_WORDS 
3b6b						DMARK "SPA" 
3b6b f5				push af  
3b6c 3a 80 3b			ld a, (.dmark)  
3b6f 32 7a ee			ld (debug_mark),a  
3b72 3a 81 3b			ld a, (.dmark+1)  
3b75 32 7b ee			ld (debug_mark+1),a  
3b78 3a 82 3b			ld a, (.dmark+2)  
3b7b 32 7c ee			ld (debug_mark+2),a  
3b7e 18 03			jr .pastdmark  
3b80 ..			.dmark: db "SPA"  
3b83 f1			.pastdmark: pop af  
3b84			endm  
# End of macro DMARK
3b84						CALLMONITOR 
3b84 cd bb 13			call break_point_state  
3b87				endm  
# End of macro CALLMONITOR
3b87					endif 
3b87			 
3b87					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b87 cd f7 1b			call macro_forth_dsp_pop 
3b8a				endm 
# End of macro FORTH_DSP_POP
3b8a			;		pop hl 
3b8a 4d					ld c, l 
3b8b 06 00				ld b, 0 
3b8d 21 60 e3				ld hl, scratch  
3b90			 
3b90					if DEBUG_FORTH_WORDS 
3b90						DMARK "SP2" 
3b90 f5				push af  
3b91 3a a5 3b			ld a, (.dmark)  
3b94 32 7a ee			ld (debug_mark),a  
3b97 3a a6 3b			ld a, (.dmark+1)  
3b9a 32 7b ee			ld (debug_mark+1),a  
3b9d 3a a7 3b			ld a, (.dmark+2)  
3ba0 32 7c ee			ld (debug_mark+2),a  
3ba3 18 03			jr .pastdmark  
3ba5 ..			.dmark: db "SP2"  
3ba8 f1			.pastdmark: pop af  
3ba9			endm  
# End of macro DMARK
3ba9						CALLMONITOR 
3ba9 cd bb 13			call break_point_state  
3bac				endm  
# End of macro CALLMONITOR
3bac					endif 
3bac 3e 20				ld a, ' ' 
3bae c5			.spaces1:	push bc 
3baf 77					ld (hl),a 
3bb0 23					inc hl 
3bb1 c1					pop bc 
3bb2 10 fa				djnz .spaces1 
3bb4 3e 00				ld a,0 
3bb6 77					ld (hl),a 
3bb7 21 60 e3				ld hl, scratch 
3bba					if DEBUG_FORTH_WORDS 
3bba						DMARK "SP3" 
3bba f5				push af  
3bbb 3a cf 3b			ld a, (.dmark)  
3bbe 32 7a ee			ld (debug_mark),a  
3bc1 3a d0 3b			ld a, (.dmark+1)  
3bc4 32 7b ee			ld (debug_mark+1),a  
3bc7 3a d1 3b			ld a, (.dmark+2)  
3bca 32 7c ee			ld (debug_mark+2),a  
3bcd 18 03			jr .pastdmark  
3bcf ..			.dmark: db "SP3"  
3bd2 f1			.pastdmark: pop af  
3bd3			endm  
# End of macro DMARK
3bd3						CALLMONITOR 
3bd3 cd bb 13			call break_point_state  
3bd6				endm  
# End of macro CALLMONITOR
3bd6					endif 
3bd6 cd b1 1a				call forth_apush 
3bd9			 
3bd9				       NEXTW 
3bd9 c3 b1 1c			jp macro_next 
3bdc				endm 
# End of macro NEXTW
3bdc			 
3bdc			 
3bdc			 
3bdc			.SCROLL: 
3bdc				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
3bdc 53				db WORD_SYS_CORE+63             
3bdd 09 3c			dw .SCROLLD            
3bdf 07				db 6 + 1 
3be0 .. 00			db "SCROLL",0              
3be7				endm 
# End of macro CWHEAD
3be7			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
3be7					if DEBUG_FORTH_WORDS_KEY 
3be7						DMARK "SCR" 
3be7 f5				push af  
3be8 3a fc 3b			ld a, (.dmark)  
3beb 32 7a ee			ld (debug_mark),a  
3bee 3a fd 3b			ld a, (.dmark+1)  
3bf1 32 7b ee			ld (debug_mark+1),a  
3bf4 3a fe 3b			ld a, (.dmark+2)  
3bf7 32 7c ee			ld (debug_mark+2),a  
3bfa 18 03			jr .pastdmark  
3bfc ..			.dmark: db "SCR"  
3bff f1			.pastdmark: pop af  
3c00			endm  
# End of macro DMARK
3c00						CALLMONITOR 
3c00 cd bb 13			call break_point_state  
3c03				endm  
# End of macro CALLMONITOR
3c03					endif 
3c03			 
3c03 cd 09 09			call scroll_up 
3c06			;	call update_display 
3c06			 
3c06					NEXTW 
3c06 c3 b1 1c			jp macro_next 
3c09				endm 
# End of macro NEXTW
3c09			 
3c09			 
3c09			 
3c09			;		; get dir 
3c09			; 
3c09			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c09			; 
3c09			;		push hl 
3c09			; 
3c09			;		; destroy value TOS 
3c09			; 
3c09			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c09			; 
3c09			;		; get count 
3c09			; 
3c09			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c09			; 
3c09			;		push hl 
3c09			; 
3c09			;		; destroy value TOS 
3c09			; 
3c09			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c09			; 
3c09			;		; one value on hl get other one back 
3c09			; 
3c09			;		pop bc    ; count 
3c09			; 
3c09			;		pop de   ; dir 
3c09			; 
3c09			; 
3c09			;		ld b, c 
3c09			; 
3c09			;.scrolldir:     push bc 
3c09			;		push de 
3c09			; 
3c09			;		ld a, 0 
3c09			;		cp e 
3c09			;		jr z, .scrollup  
3c09			;		call scroll_down 
3c09			;		jr .scrollnext 
3c09			;.scrollup:	call scroll_up 
3c09			; 
3c09			;		 
3c09			;.scrollnext: 
3c09			;		pop de 
3c09			;		pop bc 
3c09			;		djnz .scrolldir 
3c09			; 
3c09			; 
3c09			; 
3c09			; 
3c09			; 
3c09			;		NEXTW 
3c09			 
3c09			.SCROLLD: 
3c09				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
3c09 53				db WORD_SYS_CORE+63             
3c0a 37 3c			dw .ATQ            
3c0c 08				db 7 + 1 
3c0d .. 00			db "SCROLLD",0              
3c15				endm 
# End of macro CWHEAD
3c15			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
3c15					if DEBUG_FORTH_WORDS_KEY 
3c15						DMARK "SCD" 
3c15 f5				push af  
3c16 3a 2a 3c			ld a, (.dmark)  
3c19 32 7a ee			ld (debug_mark),a  
3c1c 3a 2b 3c			ld a, (.dmark+1)  
3c1f 32 7b ee			ld (debug_mark+1),a  
3c22 3a 2c 3c			ld a, (.dmark+2)  
3c25 32 7c ee			ld (debug_mark+2),a  
3c28 18 03			jr .pastdmark  
3c2a ..			.dmark: db "SCD"  
3c2d f1			.pastdmark: pop af  
3c2e			endm  
# End of macro DMARK
3c2e						CALLMONITOR 
3c2e cd bb 13			call break_point_state  
3c31				endm  
# End of macro CALLMONITOR
3c31					endif 
3c31			 
3c31 cd 2d 09			call scroll_down 
3c34			;	call update_display 
3c34			 
3c34					NEXTW 
3c34 c3 b1 1c			jp macro_next 
3c37				endm 
# End of macro NEXTW
3c37			 
3c37			 
3c37			.ATQ: 
3c37				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
3c37 62				db WORD_SYS_CORE+78             
3c38 95 3c			dw .AUTODSP            
3c3a 04				db 3 + 1 
3c3b .. 00			db "AT@",0              
3c3f				endm 
# End of macro CWHEAD
3c3f			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
3c3f					if DEBUG_FORTH_WORDS_KEY 
3c3f						DMARK "ATA" 
3c3f f5				push af  
3c40 3a 54 3c			ld a, (.dmark)  
3c43 32 7a ee			ld (debug_mark),a  
3c46 3a 55 3c			ld a, (.dmark+1)  
3c49 32 7b ee			ld (debug_mark+1),a  
3c4c 3a 56 3c			ld a, (.dmark+2)  
3c4f 32 7c ee			ld (debug_mark+2),a  
3c52 18 03			jr .pastdmark  
3c54 ..			.dmark: db "ATA"  
3c57 f1			.pastdmark: pop af  
3c58			endm  
# End of macro DMARK
3c58						CALLMONITOR 
3c58 cd bb 13			call break_point_state  
3c5b				endm  
# End of macro CALLMONITOR
3c5b					endif 
3c5b			 
3c5b			 
3c5b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c5b cd 3f 1b			call macro_dsp_valuehl 
3c5e				endm 
# End of macro FORTH_DSP_VALUEHL
3c5e			 
3c5e					; TODO save cursor row 
3c5e 7d					ld a,l 
3c5f fe 02				cp 2 
3c61 20 04				jr nz, .crow3aq 
3c63 3e 28				ld a, display_row_2 
3c65 18 12				jr .ccol1aq 
3c67 fe 03		.crow3aq:		cp 3 
3c69 20 04				jr nz, .crow4aq 
3c6b 3e 50				ld a, display_row_3 
3c6d 18 0a				jr .ccol1aq 
3c6f fe 04		.crow4aq:		cp 4 
3c71 20 04				jr nz, .crow1aq 
3c73 3e 78				ld a, display_row_4 
3c75 18 02				jr .ccol1aq 
3c77 3e 00		.crow1aq:		ld a,display_row_1 
3c79 f5			.ccol1aq:		push af			; got row offset 
3c7a 6f					ld l,a 
3c7b 26 00				ld h,0 
3c7d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c7d cd f7 1b			call macro_forth_dsp_pop 
3c80				endm 
# End of macro FORTH_DSP_POP
3c80					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c80 cd 3f 1b			call macro_dsp_valuehl 
3c83				endm 
# End of macro FORTH_DSP_VALUEHL
3c83					; TODO save cursor col 
3c83 f1					pop af 
3c84 85					add l		; add col offset 
3c85			 
3c85					; add current frame buffer address 
3c85 2a db eb				ld hl, (display_fb_active) 
3c88 cd 74 0b				call addatohl 
3c8b			 
3c8b			 
3c8b			 
3c8b			 
3c8b					; get char frame buffer location offset in hl 
3c8b			 
3c8b 7e					ld a,(hl) 
3c8c 26 00				ld h, 0 
3c8e 6f					ld l, a 
3c8f			 
3c8f cd 48 19				call forth_push_numhl 
3c92			 
3c92			 
3c92					NEXTW 
3c92 c3 b1 1c			jp macro_next 
3c95				endm 
# End of macro NEXTW
3c95			 
3c95			.AUTODSP: 
3c95				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
3c95 63				db WORD_SYS_CORE+79             
3c96 ab 3c			dw .MENU            
3c98 05				db 4 + 1 
3c99 .. 00			db "ADSP",0              
3c9e				endm 
# End of macro CWHEAD
3c9e			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
3c9e			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
3c9e			 
3c9e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c9e cd 3f 1b			call macro_dsp_valuehl 
3ca1				endm 
# End of macro FORTH_DSP_VALUEHL
3ca1			 
3ca1			;		push hl 
3ca1			 
3ca1					; destroy value TOS 
3ca1			 
3ca1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ca1 cd f7 1b			call macro_forth_dsp_pop 
3ca4				endm 
# End of macro FORTH_DSP_POP
3ca4			 
3ca4			;		pop hl 
3ca4			 
3ca4 7d					ld a,l 
3ca5 32 27 eb				ld (cli_autodisplay), a 
3ca8				       NEXTW 
3ca8 c3 b1 1c			jp macro_next 
3cab				endm 
# End of macro NEXTW
3cab			 
3cab			.MENU: 
3cab				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
3cab 70				db WORD_SYS_CORE+92             
3cac 54 3d			dw .ENDDISPLAY            
3cae 05				db 4 + 1 
3caf .. 00			db "MENU",0              
3cb4				endm 
# End of macro CWHEAD
3cb4			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
3cb4			 
3cb4			;		; get number of items on the stack 
3cb4			; 
3cb4				 
3cb4					FORTH_DSP_VALUEHL 
3cb4 cd 3f 1b			call macro_dsp_valuehl 
3cb7				endm 
# End of macro FORTH_DSP_VALUEHL
3cb7				 
3cb7					if DEBUG_FORTH_WORDS_KEY 
3cb7						DMARK "MNU" 
3cb7 f5				push af  
3cb8 3a cc 3c			ld a, (.dmark)  
3cbb 32 7a ee			ld (debug_mark),a  
3cbe 3a cd 3c			ld a, (.dmark+1)  
3cc1 32 7b ee			ld (debug_mark+1),a  
3cc4 3a ce 3c			ld a, (.dmark+2)  
3cc7 32 7c ee			ld (debug_mark+2),a  
3cca 18 03			jr .pastdmark  
3ccc ..			.dmark: db "MNU"  
3ccf f1			.pastdmark: pop af  
3cd0			endm  
# End of macro DMARK
3cd0						CALLMONITOR 
3cd0 cd bb 13			call break_point_state  
3cd3				endm  
# End of macro CALLMONITOR
3cd3					endif 
3cd3			 
3cd3 45					ld b, l	 
3cd4 05					dec b 
3cd5			 
3cd5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cd5 cd f7 1b			call macro_forth_dsp_pop 
3cd8				endm 
# End of macro FORTH_DSP_POP
3cd8			 
3cd8			 
3cd8					; go directly through the stack to pluck out the string pointers and build an array 
3cd8			 
3cd8			;		FORTH_DSP 
3cd8			 
3cd8					; hl contains top most stack item 
3cd8				 
3cd8 11 60 e3				ld de, scratch 
3cdb			 
3cdb			.mbuild: 
3cdb			 
3cdb					FORTH_DSP_VALUEHL 
3cdb cd 3f 1b			call macro_dsp_valuehl 
3cde				endm 
# End of macro FORTH_DSP_VALUEHL
3cde			 
3cde					if DEBUG_FORTH_WORDS 
3cde						DMARK "MN3" 
3cde f5				push af  
3cdf 3a f3 3c			ld a, (.dmark)  
3ce2 32 7a ee			ld (debug_mark),a  
3ce5 3a f4 3c			ld a, (.dmark+1)  
3ce8 32 7b ee			ld (debug_mark+1),a  
3ceb 3a f5 3c			ld a, (.dmark+2)  
3cee 32 7c ee			ld (debug_mark+2),a  
3cf1 18 03			jr .pastdmark  
3cf3 ..			.dmark: db "MN3"  
3cf6 f1			.pastdmark: pop af  
3cf7			endm  
# End of macro DMARK
3cf7						CALLMONITOR 
3cf7 cd bb 13			call break_point_state  
3cfa				endm  
# End of macro CALLMONITOR
3cfa					endif 
3cfa eb					ex de, hl 
3cfb 73					ld (hl), e 
3cfc 23					inc hl 
3cfd 72					ld (hl), d 
3cfe 23					inc hl 
3cff eb					ex de, hl 
3d00			 
3d00					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d00 cd f7 1b			call macro_forth_dsp_pop 
3d03				endm 
# End of macro FORTH_DSP_POP
3d03			 
3d03 10 d6				djnz .mbuild 
3d05			 
3d05					; done add term 
3d05			 
3d05 eb					ex de, hl 
3d06 36 00				ld (hl), 0 
3d08 23					inc hl 
3d09 36 00				ld (hl), 0 
3d0b			 
3d0b				 
3d0b					 
3d0b 21 60 e3				ld hl, scratch 
3d0e			 
3d0e					if DEBUG_FORTH_WORDS 
3d0e						DMARK "MNx" 
3d0e f5				push af  
3d0f 3a 23 3d			ld a, (.dmark)  
3d12 32 7a ee			ld (debug_mark),a  
3d15 3a 24 3d			ld a, (.dmark+1)  
3d18 32 7b ee			ld (debug_mark+1),a  
3d1b 3a 25 3d			ld a, (.dmark+2)  
3d1e 32 7c ee			ld (debug_mark+2),a  
3d21 18 03			jr .pastdmark  
3d23 ..			.dmark: db "MNx"  
3d26 f1			.pastdmark: pop af  
3d27			endm  
# End of macro DMARK
3d27						CALLMONITOR 
3d27 cd bb 13			call break_point_state  
3d2a				endm  
# End of macro CALLMONITOR
3d2a					endif 
3d2a			 
3d2a			 
3d2a			 
3d2a 3e 00				ld a, 0 
3d2c cd 78 09				call menu 
3d2f			 
3d2f			 
3d2f 6f					ld l, a 
3d30 26 00				ld h, 0 
3d32			 
3d32					if DEBUG_FORTH_WORDS 
3d32						DMARK "MNr" 
3d32 f5				push af  
3d33 3a 47 3d			ld a, (.dmark)  
3d36 32 7a ee			ld (debug_mark),a  
3d39 3a 48 3d			ld a, (.dmark+1)  
3d3c 32 7b ee			ld (debug_mark+1),a  
3d3f 3a 49 3d			ld a, (.dmark+2)  
3d42 32 7c ee			ld (debug_mark+2),a  
3d45 18 03			jr .pastdmark  
3d47 ..			.dmark: db "MNr"  
3d4a f1			.pastdmark: pop af  
3d4b			endm  
# End of macro DMARK
3d4b						CALLMONITOR 
3d4b cd bb 13			call break_point_state  
3d4e				endm  
# End of macro CALLMONITOR
3d4e					endif 
3d4e			 
3d4e cd 48 19				call forth_push_numhl 
3d51			 
3d51			 
3d51			 
3d51			 
3d51				       NEXTW 
3d51 c3 b1 1c			jp macro_next 
3d54				endm 
# End of macro NEXTW
3d54			 
3d54			 
3d54			.ENDDISPLAY: 
3d54			 
3d54			; eof 
# End of file forth_words_display.asm
3d54			include "forth_words_str.asm" 
3d54			 
3d54			; | ## String Words 
3d54			 
3d54			.PTR:   
3d54			 
3d54				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
3d54 48				db WORD_SYS_CORE+52             
3d55 81 3d			dw .STYPE            
3d57 04				db 3 + 1 
3d58 .. 00			db "PTR",0              
3d5c				endm 
# End of macro CWHEAD
3d5c			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
3d5c			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
3d5c			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
3d5c			 
3d5c					if DEBUG_FORTH_WORDS_KEY 
3d5c						DMARK "PTR" 
3d5c f5				push af  
3d5d 3a 71 3d			ld a, (.dmark)  
3d60 32 7a ee			ld (debug_mark),a  
3d63 3a 72 3d			ld a, (.dmark+1)  
3d66 32 7b ee			ld (debug_mark+1),a  
3d69 3a 73 3d			ld a, (.dmark+2)  
3d6c 32 7c ee			ld (debug_mark+2),a  
3d6f 18 03			jr .pastdmark  
3d71 ..			.dmark: db "PTR"  
3d74 f1			.pastdmark: pop af  
3d75			endm  
# End of macro DMARK
3d75						CALLMONITOR 
3d75 cd bb 13			call break_point_state  
3d78				endm  
# End of macro CALLMONITOR
3d78					endif 
3d78					FORTH_DSP_VALUEHL 
3d78 cd 3f 1b			call macro_dsp_valuehl 
3d7b				endm 
# End of macro FORTH_DSP_VALUEHL
3d7b cd 48 19				call forth_push_numhl 
3d7e			 
3d7e			 
3d7e					NEXTW 
3d7e c3 b1 1c			jp macro_next 
3d81				endm 
# End of macro NEXTW
3d81			.STYPE: 
3d81				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
3d81 48				db WORD_SYS_CORE+52             
3d82 d0 3d			dw .UPPER            
3d84 06				db 5 + 1 
3d85 .. 00			db "STYPE",0              
3d8b				endm 
# End of macro CWHEAD
3d8b			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
3d8b					if DEBUG_FORTH_WORDS_KEY 
3d8b						DMARK "STY" 
3d8b f5				push af  
3d8c 3a a0 3d			ld a, (.dmark)  
3d8f 32 7a ee			ld (debug_mark),a  
3d92 3a a1 3d			ld a, (.dmark+1)  
3d95 32 7b ee			ld (debug_mark+1),a  
3d98 3a a2 3d			ld a, (.dmark+2)  
3d9b 32 7c ee			ld (debug_mark+2),a  
3d9e 18 03			jr .pastdmark  
3da0 ..			.dmark: db "STY"  
3da3 f1			.pastdmark: pop af  
3da4			endm  
# End of macro DMARK
3da4						CALLMONITOR 
3da4 cd bb 13			call break_point_state  
3da7				endm  
# End of macro CALLMONITOR
3da7					endif 
3da7					FORTH_DSP 
3da7 cd 05 1b			call macro_forth_dsp 
3daa				endm 
# End of macro FORTH_DSP
3daa					;v5 FORTH_DSP_VALUE 
3daa			 
3daa 7e					ld a, (hl) 
3dab			 
3dab f5					push af 
3dac			 
3dac			; Dont destroy TOS		FORTH_DSP_POP 
3dac			 
3dac f1					pop af 
3dad			 
3dad fe 01				cp DS_TYPE_STR 
3daf 28 09				jr z, .typestr 
3db1			 
3db1 fe 02				cp DS_TYPE_INUM 
3db3 28 0a				jr z, .typeinum 
3db5			 
3db5 21 ce 3d				ld hl, .tna 
3db8 18 0a				jr .tpush 
3dba			 
3dba 21 ca 3d		.typestr:	ld hl, .tstr 
3dbd 18 05				jr .tpush 
3dbf 21 cc 3d		.typeinum:	ld hl, .tinum 
3dc2 18 00				jr .tpush 
3dc4			 
3dc4			.tpush: 
3dc4			 
3dc4 cd b6 19				call forth_push_str 
3dc7			 
3dc7					NEXTW 
3dc7 c3 b1 1c			jp macro_next 
3dca				endm 
# End of macro NEXTW
3dca .. 00		.tstr:	db "s",0 
3dcc .. 00		.tinum:  db "i",0 
3dce .. 00		.tna:   db "?", 0 
3dd0			 
3dd0			 
3dd0			.UPPER: 
3dd0				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
3dd0 48				db WORD_SYS_CORE+52             
3dd1 0b 3e			dw .LOWER            
3dd3 06				db 5 + 1 
3dd4 .. 00			db "UPPER",0              
3dda				endm 
# End of macro CWHEAD
3dda			; | UPPER ( s -- s ) Upper case string s  | DONE 
3dda					if DEBUG_FORTH_WORDS_KEY 
3dda						DMARK "UPR" 
3dda f5				push af  
3ddb 3a ef 3d			ld a, (.dmark)  
3dde 32 7a ee			ld (debug_mark),a  
3de1 3a f0 3d			ld a, (.dmark+1)  
3de4 32 7b ee			ld (debug_mark+1),a  
3de7 3a f1 3d			ld a, (.dmark+2)  
3dea 32 7c ee			ld (debug_mark+2),a  
3ded 18 03			jr .pastdmark  
3def ..			.dmark: db "UPR"  
3df2 f1			.pastdmark: pop af  
3df3			endm  
# End of macro DMARK
3df3						CALLMONITOR 
3df3 cd bb 13			call break_point_state  
3df6				endm  
# End of macro CALLMONITOR
3df6					endif 
3df6			 
3df6					FORTH_DSP 
3df6 cd 05 1b			call macro_forth_dsp 
3df9				endm 
# End of macro FORTH_DSP
3df9					 
3df9			; TODO check is string type 
3df9			 
3df9					FORTH_DSP_VALUEHL 
3df9 cd 3f 1b			call macro_dsp_valuehl 
3dfc				endm 
# End of macro FORTH_DSP_VALUEHL
3dfc			; get pointer to string in hl 
3dfc			 
3dfc 7e			.toup:		ld a, (hl) 
3dfd fe 00				cp 0 
3dff 28 07				jr z, .toupdone 
3e01			 
3e01 cd e1 0e				call to_upper 
3e04			 
3e04 77					ld (hl), a 
3e05 23					inc hl 
3e06 18 f4				jr .toup 
3e08			 
3e08					 
3e08			 
3e08			 
3e08			; for each char convert to upper 
3e08					 
3e08			.toupdone: 
3e08			 
3e08			 
3e08					NEXTW 
3e08 c3 b1 1c			jp macro_next 
3e0b				endm 
# End of macro NEXTW
3e0b			.LOWER: 
3e0b				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
3e0b 48				db WORD_SYS_CORE+52             
3e0c 46 3e			dw .TCASE            
3e0e 06				db 5 + 1 
3e0f .. 00			db "LOWER",0              
3e15				endm 
# End of macro CWHEAD
3e15			; | LOWER ( s -- s ) Lower case string s  | DONE 
3e15					if DEBUG_FORTH_WORDS_KEY 
3e15						DMARK "LWR" 
3e15 f5				push af  
3e16 3a 2a 3e			ld a, (.dmark)  
3e19 32 7a ee			ld (debug_mark),a  
3e1c 3a 2b 3e			ld a, (.dmark+1)  
3e1f 32 7b ee			ld (debug_mark+1),a  
3e22 3a 2c 3e			ld a, (.dmark+2)  
3e25 32 7c ee			ld (debug_mark+2),a  
3e28 18 03			jr .pastdmark  
3e2a ..			.dmark: db "LWR"  
3e2d f1			.pastdmark: pop af  
3e2e			endm  
# End of macro DMARK
3e2e						CALLMONITOR 
3e2e cd bb 13			call break_point_state  
3e31				endm  
# End of macro CALLMONITOR
3e31					endif 
3e31			 
3e31					FORTH_DSP 
3e31 cd 05 1b			call macro_forth_dsp 
3e34				endm 
# End of macro FORTH_DSP
3e34					 
3e34			; TODO check is string type 
3e34			 
3e34					FORTH_DSP_VALUEHL 
3e34 cd 3f 1b			call macro_dsp_valuehl 
3e37				endm 
# End of macro FORTH_DSP_VALUEHL
3e37			; get pointer to string in hl 
3e37			 
3e37 7e			.tolow:		ld a, (hl) 
3e38 fe 00				cp 0 
3e3a 28 07				jr z, .tolowdone 
3e3c			 
3e3c cd ea 0e				call to_lower 
3e3f			 
3e3f 77					ld (hl), a 
3e40 23					inc hl 
3e41 18 f4				jr .tolow 
3e43			 
3e43					 
3e43			 
3e43			 
3e43			; for each char convert to low 
3e43					 
3e43			.tolowdone: 
3e43					NEXTW 
3e43 c3 b1 1c			jp macro_next 
3e46				endm 
# End of macro NEXTW
3e46			.TCASE: 
3e46				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
3e46 48				db WORD_SYS_CORE+52             
3e47 7c 3f			dw .SUBSTR            
3e49 06				db 5 + 1 
3e4a .. 00			db "TCASE",0              
3e50				endm 
# End of macro CWHEAD
3e50			; | TCASE ( s -- s ) Title case string s  | DONE 
3e50					if DEBUG_FORTH_WORDS_KEY 
3e50						DMARK "TCS" 
3e50 f5				push af  
3e51 3a 65 3e			ld a, (.dmark)  
3e54 32 7a ee			ld (debug_mark),a  
3e57 3a 66 3e			ld a, (.dmark+1)  
3e5a 32 7b ee			ld (debug_mark+1),a  
3e5d 3a 67 3e			ld a, (.dmark+2)  
3e60 32 7c ee			ld (debug_mark+2),a  
3e63 18 03			jr .pastdmark  
3e65 ..			.dmark: db "TCS"  
3e68 f1			.pastdmark: pop af  
3e69			endm  
# End of macro DMARK
3e69						CALLMONITOR 
3e69 cd bb 13			call break_point_state  
3e6c				endm  
# End of macro CALLMONITOR
3e6c					endif 
3e6c			 
3e6c					FORTH_DSP 
3e6c cd 05 1b			call macro_forth_dsp 
3e6f				endm 
# End of macro FORTH_DSP
3e6f					 
3e6f			; TODO check is string type 
3e6f			 
3e6f					FORTH_DSP_VALUEHL 
3e6f cd 3f 1b			call macro_dsp_valuehl 
3e72				endm 
# End of macro FORTH_DSP_VALUEHL
3e72			; get pointer to string in hl 
3e72			 
3e72					if DEBUG_FORTH_WORDS 
3e72						DMARK "TC1" 
3e72 f5				push af  
3e73 3a 87 3e			ld a, (.dmark)  
3e76 32 7a ee			ld (debug_mark),a  
3e79 3a 88 3e			ld a, (.dmark+1)  
3e7c 32 7b ee			ld (debug_mark+1),a  
3e7f 3a 89 3e			ld a, (.dmark+2)  
3e82 32 7c ee			ld (debug_mark+2),a  
3e85 18 03			jr .pastdmark  
3e87 ..			.dmark: db "TC1"  
3e8a f1			.pastdmark: pop af  
3e8b			endm  
# End of macro DMARK
3e8b						CALLMONITOR 
3e8b cd bb 13			call break_point_state  
3e8e				endm  
# End of macro CALLMONITOR
3e8e					endif 
3e8e			 
3e8e					; first time in turn to upper case first char 
3e8e			 
3e8e 7e					ld a, (hl) 
3e8f c3 19 3f				jp .totsiptou 
3e92			 
3e92			 
3e92 7e			.tot:		ld a, (hl) 
3e93 fe 00				cp 0 
3e95 ca 5d 3f				jp z, .totdone 
3e98			 
3e98					if DEBUG_FORTH_WORDS 
3e98						DMARK "TC2" 
3e98 f5				push af  
3e99 3a ad 3e			ld a, (.dmark)  
3e9c 32 7a ee			ld (debug_mark),a  
3e9f 3a ae 3e			ld a, (.dmark+1)  
3ea2 32 7b ee			ld (debug_mark+1),a  
3ea5 3a af 3e			ld a, (.dmark+2)  
3ea8 32 7c ee			ld (debug_mark+2),a  
3eab 18 03			jr .pastdmark  
3ead ..			.dmark: db "TC2"  
3eb0 f1			.pastdmark: pop af  
3eb1			endm  
# End of macro DMARK
3eb1						CALLMONITOR 
3eb1 cd bb 13			call break_point_state  
3eb4				endm  
# End of macro CALLMONITOR
3eb4					endif 
3eb4					; check to see if current char is a space 
3eb4			 
3eb4 fe 20				cp ' ' 
3eb6 28 21				jr z, .totsp 
3eb8 cd ea 0e				call to_lower 
3ebb					if DEBUG_FORTH_WORDS 
3ebb						DMARK "TC3" 
3ebb f5				push af  
3ebc 3a d0 3e			ld a, (.dmark)  
3ebf 32 7a ee			ld (debug_mark),a  
3ec2 3a d1 3e			ld a, (.dmark+1)  
3ec5 32 7b ee			ld (debug_mark+1),a  
3ec8 3a d2 3e			ld a, (.dmark+2)  
3ecb 32 7c ee			ld (debug_mark+2),a  
3ece 18 03			jr .pastdmark  
3ed0 ..			.dmark: db "TC3"  
3ed3 f1			.pastdmark: pop af  
3ed4			endm  
# End of macro DMARK
3ed4						CALLMONITOR 
3ed4 cd bb 13			call break_point_state  
3ed7				endm  
# End of macro CALLMONITOR
3ed7					endif 
3ed7 18 63				jr .totnxt 
3ed9			 
3ed9			.totsp:         ; on a space, find next char which should be upper 
3ed9			 
3ed9					if DEBUG_FORTH_WORDS 
3ed9						DMARK "TC4" 
3ed9 f5				push af  
3eda 3a ee 3e			ld a, (.dmark)  
3edd 32 7a ee			ld (debug_mark),a  
3ee0 3a ef 3e			ld a, (.dmark+1)  
3ee3 32 7b ee			ld (debug_mark+1),a  
3ee6 3a f0 3e			ld a, (.dmark+2)  
3ee9 32 7c ee			ld (debug_mark+2),a  
3eec 18 03			jr .pastdmark  
3eee ..			.dmark: db "TC4"  
3ef1 f1			.pastdmark: pop af  
3ef2			endm  
# End of macro DMARK
3ef2						CALLMONITOR 
3ef2 cd bb 13			call break_point_state  
3ef5				endm  
# End of macro CALLMONITOR
3ef5					endif 
3ef5					;; 
3ef5			 
3ef5 fe 20				cp ' ' 
3ef7 20 20				jr nz, .totsiptou 
3ef9 23					inc hl 
3efa 7e					ld a, (hl) 
3efb					if DEBUG_FORTH_WORDS 
3efb						DMARK "TC5" 
3efb f5				push af  
3efc 3a 10 3f			ld a, (.dmark)  
3eff 32 7a ee			ld (debug_mark),a  
3f02 3a 11 3f			ld a, (.dmark+1)  
3f05 32 7b ee			ld (debug_mark+1),a  
3f08 3a 12 3f			ld a, (.dmark+2)  
3f0b 32 7c ee			ld (debug_mark+2),a  
3f0e 18 03			jr .pastdmark  
3f10 ..			.dmark: db "TC5"  
3f13 f1			.pastdmark: pop af  
3f14			endm  
# End of macro DMARK
3f14						CALLMONITOR 
3f14 cd bb 13			call break_point_state  
3f17				endm  
# End of macro CALLMONITOR
3f17					endif 
3f17 18 c0				jr .totsp 
3f19 fe 00		.totsiptou:    cp 0 
3f1b 28 40				jr z, .totdone 
3f1d					; not space and not zero term so upper case it 
3f1d cd e1 0e				call to_upper 
3f20			 
3f20					if DEBUG_FORTH_WORDS 
3f20						DMARK "TC6" 
3f20 f5				push af  
3f21 3a 35 3f			ld a, (.dmark)  
3f24 32 7a ee			ld (debug_mark),a  
3f27 3a 36 3f			ld a, (.dmark+1)  
3f2a 32 7b ee			ld (debug_mark+1),a  
3f2d 3a 37 3f			ld a, (.dmark+2)  
3f30 32 7c ee			ld (debug_mark+2),a  
3f33 18 03			jr .pastdmark  
3f35 ..			.dmark: db "TC6"  
3f38 f1			.pastdmark: pop af  
3f39			endm  
# End of macro DMARK
3f39						CALLMONITOR 
3f39 cd bb 13			call break_point_state  
3f3c				endm  
# End of macro CALLMONITOR
3f3c					endif 
3f3c			 
3f3c			 
3f3c			.totnxt: 
3f3c			 
3f3c 77					ld (hl), a 
3f3d 23					inc hl 
3f3e					if DEBUG_FORTH_WORDS 
3f3e						DMARK "TC7" 
3f3e f5				push af  
3f3f 3a 53 3f			ld a, (.dmark)  
3f42 32 7a ee			ld (debug_mark),a  
3f45 3a 54 3f			ld a, (.dmark+1)  
3f48 32 7b ee			ld (debug_mark+1),a  
3f4b 3a 55 3f			ld a, (.dmark+2)  
3f4e 32 7c ee			ld (debug_mark+2),a  
3f51 18 03			jr .pastdmark  
3f53 ..			.dmark: db "TC7"  
3f56 f1			.pastdmark: pop af  
3f57			endm  
# End of macro DMARK
3f57						CALLMONITOR 
3f57 cd bb 13			call break_point_state  
3f5a				endm  
# End of macro CALLMONITOR
3f5a					endif 
3f5a c3 92 3e				jp .tot 
3f5d			 
3f5d					 
3f5d			 
3f5d			 
3f5d			; for each char convert to low 
3f5d					 
3f5d			.totdone: 
3f5d					if DEBUG_FORTH_WORDS 
3f5d						DMARK "TCd" 
3f5d f5				push af  
3f5e 3a 72 3f			ld a, (.dmark)  
3f61 32 7a ee			ld (debug_mark),a  
3f64 3a 73 3f			ld a, (.dmark+1)  
3f67 32 7b ee			ld (debug_mark+1),a  
3f6a 3a 74 3f			ld a, (.dmark+2)  
3f6d 32 7c ee			ld (debug_mark+2),a  
3f70 18 03			jr .pastdmark  
3f72 ..			.dmark: db "TCd"  
3f75 f1			.pastdmark: pop af  
3f76			endm  
# End of macro DMARK
3f76						CALLMONITOR 
3f76 cd bb 13			call break_point_state  
3f79				endm  
# End of macro CALLMONITOR
3f79					endif 
3f79					NEXTW 
3f79 c3 b1 1c			jp macro_next 
3f7c				endm 
# End of macro NEXTW
3f7c			 
3f7c			.SUBSTR: 
3f7c				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
3f7c 48				db WORD_SYS_CORE+52             
3f7d da 3f			dw .LEFT            
3f7f 07				db 6 + 1 
3f80 .. 00			db "SUBSTR",0              
3f87				endm 
# End of macro CWHEAD
3f87			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
3f87			 
3f87					if DEBUG_FORTH_WORDS_KEY 
3f87						DMARK "SST" 
3f87 f5				push af  
3f88 3a 9c 3f			ld a, (.dmark)  
3f8b 32 7a ee			ld (debug_mark),a  
3f8e 3a 9d 3f			ld a, (.dmark+1)  
3f91 32 7b ee			ld (debug_mark+1),a  
3f94 3a 9e 3f			ld a, (.dmark+2)  
3f97 32 7c ee			ld (debug_mark+2),a  
3f9a 18 03			jr .pastdmark  
3f9c ..			.dmark: db "SST"  
3f9f f1			.pastdmark: pop af  
3fa0			endm  
# End of macro DMARK
3fa0						CALLMONITOR 
3fa0 cd bb 13			call break_point_state  
3fa3				endm  
# End of macro CALLMONITOR
3fa3					endif 
3fa3			; TODO check string type 
3fa3					FORTH_DSP_VALUEHL 
3fa3 cd 3f 1b			call macro_dsp_valuehl 
3fa6				endm 
# End of macro FORTH_DSP_VALUEHL
3fa6			 
3fa6 e5					push hl      ; string length 
3fa7			 
3fa7					FORTH_DSP_POP 
3fa7 cd f7 1b			call macro_forth_dsp_pop 
3faa				endm 
# End of macro FORTH_DSP_POP
3faa			 
3faa					FORTH_DSP_VALUEHL 
3faa cd 3f 1b			call macro_dsp_valuehl 
3fad				endm 
# End of macro FORTH_DSP_VALUEHL
3fad			 
3fad e5					push hl     ; start char 
3fae			 
3fae					FORTH_DSP_POP 
3fae cd f7 1b			call macro_forth_dsp_pop 
3fb1				endm 
# End of macro FORTH_DSP_POP
3fb1			 
3fb1			 
3fb1					FORTH_DSP_VALUE 
3fb1 cd 28 1b			call macro_forth_dsp_value 
3fb4				endm 
# End of macro FORTH_DSP_VALUE
3fb4			 
3fb4 d1					pop de    ; get start post offset 
3fb5			 
3fb5 19					add hl, de    ; starting offset 
3fb6			 
3fb6 c1					pop bc 
3fb7 c5					push bc      ; grab size of string 
3fb8			 
3fb8 e5					push hl    ; save string start  
3fb9			 
3fb9 26 00				ld h, 0 
3fbb 69					ld l, c 
3fbc 23					inc hl 
3fbd 23					inc hl 
3fbe			 
3fbe cd 3b 10				call malloc 
3fc1				if DEBUG_FORTH_MALLOC_GUARD 
3fc1 cc f0 45				call z,malloc_error 
3fc4				endif 
3fc4			 
3fc4 eb					ex de, hl      ; save malloc area for string copy 
3fc5 e1					pop hl    ; get back source 
3fc6 c1					pop bc    ; get length of string back 
3fc7			 
3fc7 d5					push de    ; save malloc area for after we push 
3fc8 ed b0				ldir     ; copy substr 
3fca			 
3fca			 
3fca eb					ex de, hl 
3fcb 3e 00				ld a, 0 
3fcd 77					ld (hl), a   ; term substr 
3fce			 
3fce					 
3fce e1					pop hl    ; get malloc so we can push it 
3fcf e5					push hl   ; save so we can free it afterwards 
3fd0			 
3fd0 cd b6 19				call forth_push_str 
3fd3			 
3fd3 e1					pop hl 
3fd4 cd 05 11				call free 
3fd7			 
3fd7					 
3fd7					 
3fd7			 
3fd7			 
3fd7					NEXTW 
3fd7 c3 b1 1c			jp macro_next 
3fda				endm 
# End of macro NEXTW
3fda			 
3fda			.LEFT: 
3fda				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
3fda 48				db WORD_SYS_CORE+52             
3fdb 02 40			dw .RIGHT            
3fdd 05				db 4 + 1 
3fde .. 00			db "LEFT",0              
3fe3				endm 
# End of macro CWHEAD
3fe3			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
3fe3					if DEBUG_FORTH_WORDS_KEY 
3fe3						DMARK "LEF" 
3fe3 f5				push af  
3fe4 3a f8 3f			ld a, (.dmark)  
3fe7 32 7a ee			ld (debug_mark),a  
3fea 3a f9 3f			ld a, (.dmark+1)  
3fed 32 7b ee			ld (debug_mark+1),a  
3ff0 3a fa 3f			ld a, (.dmark+2)  
3ff3 32 7c ee			ld (debug_mark+2),a  
3ff6 18 03			jr .pastdmark  
3ff8 ..			.dmark: db "LEF"  
3ffb f1			.pastdmark: pop af  
3ffc			endm  
# End of macro DMARK
3ffc						CALLMONITOR 
3ffc cd bb 13			call break_point_state  
3fff				endm  
# End of macro CALLMONITOR
3fff					endif 
3fff			 
3fff					NEXTW 
3fff c3 b1 1c			jp macro_next 
4002				endm 
# End of macro NEXTW
4002			.RIGHT: 
4002				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
4002 48				db WORD_SYS_CORE+52             
4003 2b 40			dw .STR2NUM            
4005 06				db 5 + 1 
4006 .. 00			db "RIGHT",0              
400c				endm 
# End of macro CWHEAD
400c			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
400c					if DEBUG_FORTH_WORDS_KEY 
400c						DMARK "RIG" 
400c f5				push af  
400d 3a 21 40			ld a, (.dmark)  
4010 32 7a ee			ld (debug_mark),a  
4013 3a 22 40			ld a, (.dmark+1)  
4016 32 7b ee			ld (debug_mark+1),a  
4019 3a 23 40			ld a, (.dmark+2)  
401c 32 7c ee			ld (debug_mark+2),a  
401f 18 03			jr .pastdmark  
4021 ..			.dmark: db "RIG"  
4024 f1			.pastdmark: pop af  
4025			endm  
# End of macro DMARK
4025						CALLMONITOR 
4025 cd bb 13			call break_point_state  
4028				endm  
# End of macro CALLMONITOR
4028					endif 
4028			 
4028					NEXTW 
4028 c3 b1 1c			jp macro_next 
402b				endm 
# End of macro NEXTW
402b			 
402b			 
402b			.STR2NUM: 
402b				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
402b 48				db WORD_SYS_CORE+52             
402c b7 40			dw .NUM2STR            
402e 08				db 7 + 1 
402f .. 00			db "STR2NUM",0              
4037				endm 
# End of macro CWHEAD
4037			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
4037			 
4037			 
4037			; TODO STR type check to do 
4037					if DEBUG_FORTH_WORDS_KEY 
4037						DMARK "S2N" 
4037 f5				push af  
4038 3a 4c 40			ld a, (.dmark)  
403b 32 7a ee			ld (debug_mark),a  
403e 3a 4d 40			ld a, (.dmark+1)  
4041 32 7b ee			ld (debug_mark+1),a  
4044 3a 4e 40			ld a, (.dmark+2)  
4047 32 7c ee			ld (debug_mark+2),a  
404a 18 03			jr .pastdmark  
404c ..			.dmark: db "S2N"  
404f f1			.pastdmark: pop af  
4050			endm  
# End of macro DMARK
4050						CALLMONITOR 
4050 cd bb 13			call break_point_state  
4053				endm  
# End of macro CALLMONITOR
4053					endif 
4053			 
4053					;FORTH_DSP 
4053					FORTH_DSP_VALUE 
4053 cd 28 1b			call macro_forth_dsp_value 
4056				endm 
# End of macro FORTH_DSP_VALUE
4056					;inc hl 
4056			 
4056 eb					ex de, hl 
4057					if DEBUG_FORTH_WORDS 
4057						DMARK "S2a" 
4057 f5				push af  
4058 3a 6c 40			ld a, (.dmark)  
405b 32 7a ee			ld (debug_mark),a  
405e 3a 6d 40			ld a, (.dmark+1)  
4061 32 7b ee			ld (debug_mark+1),a  
4064 3a 6e 40			ld a, (.dmark+2)  
4067 32 7c ee			ld (debug_mark+2),a  
406a 18 03			jr .pastdmark  
406c ..			.dmark: db "S2a"  
406f f1			.pastdmark: pop af  
4070			endm  
# End of macro DMARK
4070						CALLMONITOR 
4070 cd bb 13			call break_point_state  
4073				endm  
# End of macro CALLMONITOR
4073					endif 
4073 cd 69 0f				call string_to_uint16 
4076			 
4076					if DEBUG_FORTH_WORDS 
4076						DMARK "S2b" 
4076 f5				push af  
4077 3a 8b 40			ld a, (.dmark)  
407a 32 7a ee			ld (debug_mark),a  
407d 3a 8c 40			ld a, (.dmark+1)  
4080 32 7b ee			ld (debug_mark+1),a  
4083 3a 8d 40			ld a, (.dmark+2)  
4086 32 7c ee			ld (debug_mark+2),a  
4089 18 03			jr .pastdmark  
408b ..			.dmark: db "S2b"  
408e f1			.pastdmark: pop af  
408f			endm  
# End of macro DMARK
408f						CALLMONITOR 
408f cd bb 13			call break_point_state  
4092				endm  
# End of macro CALLMONITOR
4092					endif 
4092			;		push hl 
4092					FORTH_DSP_POP 
4092 cd f7 1b			call macro_forth_dsp_pop 
4095				endm 
# End of macro FORTH_DSP_POP
4095			;		pop hl 
4095					 
4095					if DEBUG_FORTH_WORDS 
4095						DMARK "S2b" 
4095 f5				push af  
4096 3a aa 40			ld a, (.dmark)  
4099 32 7a ee			ld (debug_mark),a  
409c 3a ab 40			ld a, (.dmark+1)  
409f 32 7b ee			ld (debug_mark+1),a  
40a2 3a ac 40			ld a, (.dmark+2)  
40a5 32 7c ee			ld (debug_mark+2),a  
40a8 18 03			jr .pastdmark  
40aa ..			.dmark: db "S2b"  
40ad f1			.pastdmark: pop af  
40ae			endm  
# End of macro DMARK
40ae						CALLMONITOR 
40ae cd bb 13			call break_point_state  
40b1				endm  
# End of macro CALLMONITOR
40b1					endif 
40b1 cd 48 19				call forth_push_numhl	 
40b4			 
40b4				 
40b4				       NEXTW 
40b4 c3 b1 1c			jp macro_next 
40b7				endm 
# End of macro NEXTW
40b7			.NUM2STR: 
40b7				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
40b7 48				db WORD_SYS_CORE+52             
40b8 c6 40			dw .CONCAT            
40ba 08				db 7 + 1 
40bb .. 00			db "NUM2STR",0              
40c3				endm 
# End of macro CWHEAD
40c3			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
40c3			 
40c3			;		; malloc a string to target 
40c3			;		ld hl, 10     ; TODO max string size should be fine 
40c3			;		call malloc 
40c3			;		push hl    ; save malloc location 
40c3			; 
40c3			; 
40c3			;; TODO check int type 
40c3			;		FORTH_DSP_VALUEHL 
40c3			;		ld a, l 
40c3			;		call DispAToASCII   
40c3			;;TODO need to chage above call to dump into string 
40c3			; 
40c3			; 
40c3			 
40c3				       NEXTW 
40c3 c3 b1 1c			jp macro_next 
40c6				endm 
# End of macro NEXTW
40c6			 
40c6			.CONCAT: 
40c6				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
40c6 48				db WORD_SYS_CORE+52             
40c7 79 41			dw .FIND            
40c9 07				db 6 + 1 
40ca .. 00			db "CONCAT",0              
40d1				endm 
# End of macro CWHEAD
40d1			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
40d1			 
40d1			; TODO check string type 
40d1			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
40d1			 
40d1					if DEBUG_FORTH_WORDS_KEY 
40d1						DMARK "CON" 
40d1 f5				push af  
40d2 3a e6 40			ld a, (.dmark)  
40d5 32 7a ee			ld (debug_mark),a  
40d8 3a e7 40			ld a, (.dmark+1)  
40db 32 7b ee			ld (debug_mark+1),a  
40de 3a e8 40			ld a, (.dmark+2)  
40e1 32 7c ee			ld (debug_mark+2),a  
40e4 18 03			jr .pastdmark  
40e6 ..			.dmark: db "CON"  
40e9 f1			.pastdmark: pop af  
40ea			endm  
# End of macro DMARK
40ea						CALLMONITOR 
40ea cd bb 13			call break_point_state  
40ed				endm  
# End of macro CALLMONITOR
40ed					endif 
40ed			 
40ed			 
40ed					FORTH_DSP_VALUE 
40ed cd 28 1b			call macro_forth_dsp_value 
40f0				endm 
# End of macro FORTH_DSP_VALUE
40f0 e5					push hl   ; s2 
40f1			 
40f1					FORTH_DSP_POP 
40f1 cd f7 1b			call macro_forth_dsp_pop 
40f4				endm 
# End of macro FORTH_DSP_POP
40f4			 
40f4					FORTH_DSP_VALUE 
40f4 cd 28 1b			call macro_forth_dsp_value 
40f7				endm 
# End of macro FORTH_DSP_VALUE
40f7			 
40f7 e5					push hl   ; s1 
40f8			 
40f8					FORTH_DSP_POP 
40f8 cd f7 1b			call macro_forth_dsp_pop 
40fb				endm 
# End of macro FORTH_DSP_POP
40fb					 
40fb			 
40fb					; copy s1 
40fb			 
40fb				 
40fb					; save ptr 
40fb e1					pop hl  
40fc e5					push hl 
40fd 3e 00				ld a, 0 
40ff cd dd 0f				call strlent 
4102					;inc hl    ; zer0 
4102 06 00				ld b, 0 
4104 4d					ld c, l 
4105 e1					pop hl		 
4106 11 60 e3				ld de, scratch	 
4109					if DEBUG_FORTH_WORDS 
4109						DMARK "CO1" 
4109 f5				push af  
410a 3a 1e 41			ld a, (.dmark)  
410d 32 7a ee			ld (debug_mark),a  
4110 3a 1f 41			ld a, (.dmark+1)  
4113 32 7b ee			ld (debug_mark+1),a  
4116 3a 20 41			ld a, (.dmark+2)  
4119 32 7c ee			ld (debug_mark+2),a  
411c 18 03			jr .pastdmark  
411e ..			.dmark: db "CO1"  
4121 f1			.pastdmark: pop af  
4122			endm  
# End of macro DMARK
4122						CALLMONITOR 
4122 cd bb 13			call break_point_state  
4125				endm  
# End of macro CALLMONITOR
4125					endif 
4125 ed b0				ldir 
4127			 
4127 e1					pop hl 
4128 e5					push hl 
4129 d5					push de 
412a			 
412a			 
412a 3e 00				ld a, 0 
412c cd dd 0f				call strlent 
412f 23					inc hl    ; zer0 
4130 23					inc hl 
4131 06 00				ld b, 0 
4133 4d					ld c, l 
4134 d1					pop de 
4135 e1					pop hl		 
4136					if DEBUG_FORTH_WORDS 
4136						DMARK "CO2" 
4136 f5				push af  
4137 3a 4b 41			ld a, (.dmark)  
413a 32 7a ee			ld (debug_mark),a  
413d 3a 4c 41			ld a, (.dmark+1)  
4140 32 7b ee			ld (debug_mark+1),a  
4143 3a 4d 41			ld a, (.dmark+2)  
4146 32 7c ee			ld (debug_mark+2),a  
4149 18 03			jr .pastdmark  
414b ..			.dmark: db "CO2"  
414e f1			.pastdmark: pop af  
414f			endm  
# End of macro DMARK
414f						CALLMONITOR 
414f cd bb 13			call break_point_state  
4152				endm  
# End of macro CALLMONITOR
4152					endif 
4152 ed b0				ldir 
4154			 
4154			 
4154			 
4154 21 60 e3				ld hl, scratch 
4157					if DEBUG_FORTH_WORDS 
4157						DMARK "CO5" 
4157 f5				push af  
4158 3a 6c 41			ld a, (.dmark)  
415b 32 7a ee			ld (debug_mark),a  
415e 3a 6d 41			ld a, (.dmark+1)  
4161 32 7b ee			ld (debug_mark+1),a  
4164 3a 6e 41			ld a, (.dmark+2)  
4167 32 7c ee			ld (debug_mark+2),a  
416a 18 03			jr .pastdmark  
416c ..			.dmark: db "CO5"  
416f f1			.pastdmark: pop af  
4170			endm  
# End of macro DMARK
4170						CALLMONITOR 
4170 cd bb 13			call break_point_state  
4173				endm  
# End of macro CALLMONITOR
4173					endif 
4173			 
4173 cd b6 19				call forth_push_str 
4176			 
4176			 
4176			 
4176			 
4176				       NEXTW 
4176 c3 b1 1c			jp macro_next 
4179				endm 
# End of macro NEXTW
4179			 
4179			 
4179			.FIND: 
4179				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
4179 4b				db WORD_SYS_CORE+55             
417a 37 42			dw .LEN            
417c 05				db 4 + 1 
417d .. 00			db "FIND",0              
4182				endm 
# End of macro CWHEAD
4182			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
4182			 
4182					if DEBUG_FORTH_WORDS_KEY 
4182						DMARK "FND" 
4182 f5				push af  
4183 3a 97 41			ld a, (.dmark)  
4186 32 7a ee			ld (debug_mark),a  
4189 3a 98 41			ld a, (.dmark+1)  
418c 32 7b ee			ld (debug_mark+1),a  
418f 3a 99 41			ld a, (.dmark+2)  
4192 32 7c ee			ld (debug_mark+2),a  
4195 18 03			jr .pastdmark  
4197 ..			.dmark: db "FND"  
419a f1			.pastdmark: pop af  
419b			endm  
# End of macro DMARK
419b						CALLMONITOR 
419b cd bb 13			call break_point_state  
419e				endm  
# End of macro CALLMONITOR
419e					endif 
419e			 
419e			; TODO check string type 
419e					FORTH_DSP_VALUE 
419e cd 28 1b			call macro_forth_dsp_value 
41a1				endm 
# End of macro FORTH_DSP_VALUE
41a1			 
41a1 e5					push hl    
41a2 7e					ld a,(hl)    ; char to find   
41a3			; TODO change char to substr 
41a3			 
41a3 f5					push af 
41a4					 
41a4			 
41a4			 
41a4					if DEBUG_FORTH_WORDS 
41a4						DMARK "FN1" 
41a4 f5				push af  
41a5 3a b9 41			ld a, (.dmark)  
41a8 32 7a ee			ld (debug_mark),a  
41ab 3a ba 41			ld a, (.dmark+1)  
41ae 32 7b ee			ld (debug_mark+1),a  
41b1 3a bb 41			ld a, (.dmark+2)  
41b4 32 7c ee			ld (debug_mark+2),a  
41b7 18 03			jr .pastdmark  
41b9 ..			.dmark: db "FN1"  
41bc f1			.pastdmark: pop af  
41bd			endm  
# End of macro DMARK
41bd						CALLMONITOR 
41bd cd bb 13			call break_point_state  
41c0				endm  
# End of macro CALLMONITOR
41c0					endif 
41c0			 
41c0					FORTH_DSP_POP 
41c0 cd f7 1b			call macro_forth_dsp_pop 
41c3				endm 
# End of macro FORTH_DSP_POP
41c3			 
41c3					; string to search 
41c3			 
41c3					FORTH_DSP_VALUE 
41c3 cd 28 1b			call macro_forth_dsp_value 
41c6				endm 
# End of macro FORTH_DSP_VALUE
41c6			 
41c6 d1					pop de  ; d is char to find  
41c7			 
41c7					if DEBUG_FORTH_WORDS 
41c7						DMARK "FN2" 
41c7 f5				push af  
41c8 3a dc 41			ld a, (.dmark)  
41cb 32 7a ee			ld (debug_mark),a  
41ce 3a dd 41			ld a, (.dmark+1)  
41d1 32 7b ee			ld (debug_mark+1),a  
41d4 3a de 41			ld a, (.dmark+2)  
41d7 32 7c ee			ld (debug_mark+2),a  
41da 18 03			jr .pastdmark  
41dc ..			.dmark: db "FN2"  
41df f1			.pastdmark: pop af  
41e0			endm  
# End of macro DMARK
41e0						CALLMONITOR 
41e0 cd bb 13			call break_point_state  
41e3				endm  
# End of macro CALLMONITOR
41e3					endif 
41e3					 
41e3 01 00 00				ld bc, 0 
41e6 7e			.findchar:      ld a,(hl) 
41e7 fe 00				cp 0   		 
41e9 28 27				jr z, .finddone     
41eb ba					cp d 
41ec 28 20				jr z, .foundchar 
41ee 03					inc bc 
41ef 23					inc hl 
41f0					if DEBUG_FORTH_WORDS 
41f0						DMARK "FN3" 
41f0 f5				push af  
41f1 3a 05 42			ld a, (.dmark)  
41f4 32 7a ee			ld (debug_mark),a  
41f7 3a 06 42			ld a, (.dmark+1)  
41fa 32 7b ee			ld (debug_mark+1),a  
41fd 3a 07 42			ld a, (.dmark+2)  
4200 32 7c ee			ld (debug_mark+2),a  
4203 18 03			jr .pastdmark  
4205 ..			.dmark: db "FN3"  
4208 f1			.pastdmark: pop af  
4209			endm  
# End of macro DMARK
4209						CALLMONITOR 
4209 cd bb 13			call break_point_state  
420c				endm  
# End of macro CALLMONITOR
420c					endif 
420c 18 d8				jr .findchar 
420e			 
420e			 
420e c5			.foundchar:	push bc 
420f e1					pop hl 
4210 18 03				jr .findexit 
4212			 
4212			 
4212							 
4212			 
4212			.finddone:     ; got to end of string with no find 
4212 21 00 00				ld hl, 0 
4215			.findexit: 
4215			 
4215					if DEBUG_FORTH_WORDS 
4215						DMARK "FNd" 
4215 f5				push af  
4216 3a 2a 42			ld a, (.dmark)  
4219 32 7a ee			ld (debug_mark),a  
421c 3a 2b 42			ld a, (.dmark+1)  
421f 32 7b ee			ld (debug_mark+1),a  
4222 3a 2c 42			ld a, (.dmark+2)  
4225 32 7c ee			ld (debug_mark+2),a  
4228 18 03			jr .pastdmark  
422a ..			.dmark: db "FNd"  
422d f1			.pastdmark: pop af  
422e			endm  
# End of macro DMARK
422e						CALLMONITOR 
422e cd bb 13			call break_point_state  
4231				endm  
# End of macro CALLMONITOR
4231					endif 
4231 cd 48 19			call forth_push_numhl 
4234			 
4234				       NEXTW 
4234 c3 b1 1c			jp macro_next 
4237				endm 
# End of macro NEXTW
4237			 
4237			.LEN: 
4237				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
4237 4c				db WORD_SYS_CORE+56             
4238 6c 42			dw .CHAR            
423a 06				db 5 + 1 
423b .. 00			db "COUNT",0              
4241				endm 
# End of macro CWHEAD
4241			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
4241			 
4241					if DEBUG_FORTH_WORDS_KEY 
4241						DMARK "CNT" 
4241 f5				push af  
4242 3a 56 42			ld a, (.dmark)  
4245 32 7a ee			ld (debug_mark),a  
4248 3a 57 42			ld a, (.dmark+1)  
424b 32 7b ee			ld (debug_mark+1),a  
424e 3a 58 42			ld a, (.dmark+2)  
4251 32 7c ee			ld (debug_mark+2),a  
4254 18 03			jr .pastdmark  
4256 ..			.dmark: db "CNT"  
4259 f1			.pastdmark: pop af  
425a			endm  
# End of macro DMARK
425a						CALLMONITOR 
425a cd bb 13			call break_point_state  
425d				endm  
# End of macro CALLMONITOR
425d					endif 
425d			; TODO check string type 
425d					FORTH_DSP 
425d cd 05 1b			call macro_forth_dsp 
4260				endm 
# End of macro FORTH_DSP
4260					;v5FORTH_DSP_VALUE 
4260			 
4260 23					inc hl 
4261			 
4261 3e 00				ld a, 0 
4263 cd dd 0f				call strlent 
4266			 
4266 cd 48 19				call forth_push_numhl 
4269			 
4269			 
4269			 
4269				       NEXTW 
4269 c3 b1 1c			jp macro_next 
426c				endm 
# End of macro NEXTW
426c			.CHAR: 
426c				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
426c 4d				db WORD_SYS_CORE+57             
426d a2 42			dw .ENDSTR            
426f 05				db 4 + 1 
4270 .. 00			db "CHAR",0              
4275				endm 
# End of macro CWHEAD
4275			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
4275					if DEBUG_FORTH_WORDS_KEY 
4275						DMARK "CHR" 
4275 f5				push af  
4276 3a 8a 42			ld a, (.dmark)  
4279 32 7a ee			ld (debug_mark),a  
427c 3a 8b 42			ld a, (.dmark+1)  
427f 32 7b ee			ld (debug_mark+1),a  
4282 3a 8c 42			ld a, (.dmark+2)  
4285 32 7c ee			ld (debug_mark+2),a  
4288 18 03			jr .pastdmark  
428a ..			.dmark: db "CHR"  
428d f1			.pastdmark: pop af  
428e			endm  
# End of macro DMARK
428e						CALLMONITOR 
428e cd bb 13			call break_point_state  
4291				endm  
# End of macro CALLMONITOR
4291					endif 
4291					FORTH_DSP 
4291 cd 05 1b			call macro_forth_dsp 
4294				endm 
# End of macro FORTH_DSP
4294					;v5 FORTH_DSP_VALUE 
4294 23					inc hl      ; now at start of numeric as string 
4295			 
4295			;		push hl 
4295			 
4295					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4295 cd f7 1b			call macro_forth_dsp_pop 
4298				endm 
# End of macro FORTH_DSP_POP
4298			 
4298			;		pop hl 
4298			 
4298					; push the content of a onto the stack as a value 
4298			 
4298 7e					ld a,(hl)   ; get char 
4299 26 00				ld h,0 
429b 6f					ld l,a 
429c cd 48 19				call forth_push_numhl 
429f			 
429f				       NEXTW 
429f c3 b1 1c			jp macro_next 
42a2				endm 
# End of macro NEXTW
42a2			 
42a2			 
42a2			 
42a2			 
42a2			.ENDSTR: 
42a2			; eof 
42a2			 
# End of file forth_words_str.asm
42a2			include "forth_words_key.asm" 
42a2			 
42a2			; | ## Keyboard Words 
42a2			 
42a2			.KEY: 
42a2				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
42a2 3e				db WORD_SYS_CORE+42             
42a3 d2 42			dw .WAITK            
42a5 04				db 3 + 1 
42a6 .. 00			db "KEY",0              
42aa				endm 
# End of macro CWHEAD
42aa			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
42aa			 
42aa					if DEBUG_FORTH_WORDS_KEY 
42aa						DMARK "KEY" 
42aa f5				push af  
42ab 3a bf 42			ld a, (.dmark)  
42ae 32 7a ee			ld (debug_mark),a  
42b1 3a c0 42			ld a, (.dmark+1)  
42b4 32 7b ee			ld (debug_mark+1),a  
42b7 3a c1 42			ld a, (.dmark+2)  
42ba 32 7c ee			ld (debug_mark+2),a  
42bd 18 03			jr .pastdmark  
42bf ..			.dmark: db "KEY"  
42c2 f1			.pastdmark: pop af  
42c3			endm  
# End of macro DMARK
42c3						CALLMONITOR 
42c3 cd bb 13			call break_point_state  
42c6				endm  
# End of macro CALLMONITOR
42c6					endif 
42c6			; TODO currently waits 
42c6 cd 7a 59				call cin 
42c9					;call cin_wait 
42c9 6f					ld l, a 
42ca 26 00				ld h, 0 
42cc cd 48 19				call forth_push_numhl 
42cf					NEXTW 
42cf c3 b1 1c			jp macro_next 
42d2				endm 
# End of macro NEXTW
42d2			.WAITK: 
42d2				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
42d2 3f				db WORD_SYS_CORE+43             
42d3 04 43			dw .ACCEPT            
42d5 06				db 5 + 1 
42d6 .. 00			db "WAITK",0              
42dc				endm 
# End of macro CWHEAD
42dc			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
42dc					if DEBUG_FORTH_WORDS_KEY 
42dc						DMARK "WAI" 
42dc f5				push af  
42dd 3a f1 42			ld a, (.dmark)  
42e0 32 7a ee			ld (debug_mark),a  
42e3 3a f2 42			ld a, (.dmark+1)  
42e6 32 7b ee			ld (debug_mark+1),a  
42e9 3a f3 42			ld a, (.dmark+2)  
42ec 32 7c ee			ld (debug_mark+2),a  
42ef 18 03			jr .pastdmark  
42f1 ..			.dmark: db "WAI"  
42f4 f1			.pastdmark: pop af  
42f5			endm  
# End of macro DMARK
42f5						CALLMONITOR 
42f5 cd bb 13			call break_point_state  
42f8				endm  
# End of macro CALLMONITOR
42f8					endif 
42f8 cd 72 59				call cin_wait 
42fb 6f					ld l, a 
42fc 26 00				ld h, 0 
42fe cd 48 19				call forth_push_numhl 
4301					NEXTW 
4301 c3 b1 1c			jp macro_next 
4304				endm 
# End of macro NEXTW
4304			.ACCEPT: 
4304				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4304 40				db WORD_SYS_CORE+44             
4305 62 43			dw .EDIT            
4307 07				db 6 + 1 
4308 .. 00			db "ACCEPT",0              
430f				endm 
# End of macro CWHEAD
430f			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
430f					; TODO crashes on push 
430f					if DEBUG_FORTH_WORDS_KEY 
430f						DMARK "ACC" 
430f f5				push af  
4310 3a 24 43			ld a, (.dmark)  
4313 32 7a ee			ld (debug_mark),a  
4316 3a 25 43			ld a, (.dmark+1)  
4319 32 7b ee			ld (debug_mark+1),a  
431c 3a 26 43			ld a, (.dmark+2)  
431f 32 7c ee			ld (debug_mark+2),a  
4322 18 03			jr .pastdmark  
4324 ..			.dmark: db "ACC"  
4327 f1			.pastdmark: pop af  
4328			endm  
# End of macro DMARK
4328						CALLMONITOR 
4328 cd bb 13			call break_point_state  
432b				endm  
# End of macro CALLMONITOR
432b					endif 
432b 21 5e e5				ld hl, os_input 
432e 3e 00				ld a, 0 
4330 77					ld (hl),a 
4331 3a 49 eb				ld a,(f_cursor_ptr) 
4334 16 64				ld d, 100 
4336 0e 00				ld c, 0 
4338 1e 28				ld e, 40 
433a cd a1 0b				call input_str 
433d					; TODO perhaps do a type check and wrap in quotes if not a number 
433d 21 5e e5				ld hl, os_input 
4340					if DEBUG_FORTH_WORDS 
4340						DMARK "AC1" 
4340 f5				push af  
4341 3a 55 43			ld a, (.dmark)  
4344 32 7a ee			ld (debug_mark),a  
4347 3a 56 43			ld a, (.dmark+1)  
434a 32 7b ee			ld (debug_mark+1),a  
434d 3a 57 43			ld a, (.dmark+2)  
4350 32 7c ee			ld (debug_mark+2),a  
4353 18 03			jr .pastdmark  
4355 ..			.dmark: db "AC1"  
4358 f1			.pastdmark: pop af  
4359			endm  
# End of macro DMARK
4359						CALLMONITOR 
4359 cd bb 13			call break_point_state  
435c				endm  
# End of macro CALLMONITOR
435c					endif 
435c cd b6 19				call forth_push_str 
435f					NEXTW 
435f c3 b1 1c			jp macro_next 
4362				endm 
# End of macro NEXTW
4362			 
4362			.EDIT: 
4362				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
4362 40				db WORD_SYS_CORE+44             
4363 eb 43			dw .ENDKEY            
4365 05				db 4 + 1 
4366 .. 00			db "EDIT",0              
436b				endm 
# End of macro CWHEAD
436b			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
436b			 
436b					; TODO does not copy from stack 
436b					if DEBUG_FORTH_WORDS_KEY 
436b						DMARK "EDT" 
436b f5				push af  
436c 3a 80 43			ld a, (.dmark)  
436f 32 7a ee			ld (debug_mark),a  
4372 3a 81 43			ld a, (.dmark+1)  
4375 32 7b ee			ld (debug_mark+1),a  
4378 3a 82 43			ld a, (.dmark+2)  
437b 32 7c ee			ld (debug_mark+2),a  
437e 18 03			jr .pastdmark  
4380 ..			.dmark: db "EDT"  
4383 f1			.pastdmark: pop af  
4384			endm  
# End of macro DMARK
4384						CALLMONITOR 
4384 cd bb 13			call break_point_state  
4387				endm  
# End of macro CALLMONITOR
4387					endif 
4387			 
4387					FORTH_DSP 
4387 cd 05 1b			call macro_forth_dsp 
438a				endm 
# End of macro FORTH_DSP
438a					;v5 FORTH_DSP_VALUE 
438a 23					inc hl    ; TODO do type check 
438b			 
438b e5					push hl 
438c 3e 00				ld a, 0 
438e cd dd 0f				call strlent 
4391 23					inc hl 
4392			 
4392 06 00				ld b, 0 
4394 4d					ld c, l 
4395			 
4395 e1					pop hl 
4396 11 5e e5				ld de, os_input 
4399					if DEBUG_FORTH_WORDS_KEY 
4399						DMARK "EDc" 
4399 f5				push af  
439a 3a ae 43			ld a, (.dmark)  
439d 32 7a ee			ld (debug_mark),a  
43a0 3a af 43			ld a, (.dmark+1)  
43a3 32 7b ee			ld (debug_mark+1),a  
43a6 3a b0 43			ld a, (.dmark+2)  
43a9 32 7c ee			ld (debug_mark+2),a  
43ac 18 03			jr .pastdmark  
43ae ..			.dmark: db "EDc"  
43b1 f1			.pastdmark: pop af  
43b2			endm  
# End of macro DMARK
43b2						CALLMONITOR 
43b2 cd bb 13			call break_point_state  
43b5				endm  
# End of macro CALLMONITOR
43b5					endif 
43b5 ed b0				ldir 
43b7			 
43b7			 
43b7 21 5e e5				ld hl, os_input 
43ba					;ld a, 0 
43ba					;ld (hl),a 
43ba 3a 49 eb				ld a,(f_cursor_ptr) 
43bd 16 64				ld d, 100 
43bf 0e 00				ld c, 0 
43c1 1e 28				ld e, 40 
43c3 cd a1 0b				call input_str 
43c6					; TODO perhaps do a type check and wrap in quotes if not a number 
43c6 21 5e e5				ld hl, os_input 
43c9					if DEBUG_FORTH_WORDS 
43c9						DMARK "ED1" 
43c9 f5				push af  
43ca 3a de 43			ld a, (.dmark)  
43cd 32 7a ee			ld (debug_mark),a  
43d0 3a df 43			ld a, (.dmark+1)  
43d3 32 7b ee			ld (debug_mark+1),a  
43d6 3a e0 43			ld a, (.dmark+2)  
43d9 32 7c ee			ld (debug_mark+2),a  
43dc 18 03			jr .pastdmark  
43de ..			.dmark: db "ED1"  
43e1 f1			.pastdmark: pop af  
43e2			endm  
# End of macro DMARK
43e2						CALLMONITOR 
43e2 cd bb 13			call break_point_state  
43e5				endm  
# End of macro CALLMONITOR
43e5					endif 
43e5 cd b6 19				call forth_push_str 
43e8					NEXTW 
43e8 c3 b1 1c			jp macro_next 
43eb				endm 
# End of macro NEXTW
43eb			 
43eb			 
43eb			 
43eb			.ENDKEY: 
43eb			; eof 
43eb			 
# End of file forth_words_key.asm
43eb			 
43eb			if STORAGE_SE 
43eb			   	include "forth_words_storage.asm" 
43eb			endif 
43eb				include "forth_words_device.asm" 
43eb			; Device related words 
43eb			 
43eb			; | ## Device Words 
43eb			 
43eb			if SOUND_ENABLE 
43eb			.NOTE: 
43eb				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
43eb			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
43eb					if DEBUG_FORTH_WORDS_KEY 
43eb						DMARK "NTE" 
43eb						CALLMONITOR 
43eb					endif 
43eb			 
43eb				 
43eb			 
43eb					NEXTW 
43eb			.AFTERSOUND: 
43eb			endif 
43eb			 
43eb			 
43eb			USE_GPIO: equ 0 
43eb			 
43eb			if USE_GPIO 
43eb			.GP1: 
43eb				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
43eb			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
43eb					NEXTW 
43eb			.GP2: 
43eb				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
43eb			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
43eb			 
43eb					NEXTW 
43eb			 
43eb			.GP3: 
43eb				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
43eb			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
43eb			 
43eb					NEXTW 
43eb			 
43eb			.GP4: 
43eb				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
43eb			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
43eb			 
43eb					NEXTW 
43eb			.SIN: 
43eb			 
43eb			 
43eb			endif 
43eb			 
43eb			 
43eb				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
43eb 33				db WORD_SYS_CORE+31             
43ec 20 44			dw .SOUT            
43ee 03				db 2 + 1 
43ef .. 00			db "IN",0              
43f2				endm 
# End of macro CWHEAD
43f2			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
43f2					if DEBUG_FORTH_WORDS_KEY 
43f2						DMARK "IN." 
43f2 f5				push af  
43f3 3a 07 44			ld a, (.dmark)  
43f6 32 7a ee			ld (debug_mark),a  
43f9 3a 08 44			ld a, (.dmark+1)  
43fc 32 7b ee			ld (debug_mark+1),a  
43ff 3a 09 44			ld a, (.dmark+2)  
4402 32 7c ee			ld (debug_mark+2),a  
4405 18 03			jr .pastdmark  
4407 ..			.dmark: db "IN."  
440a f1			.pastdmark: pop af  
440b			endm  
# End of macro DMARK
440b						CALLMONITOR 
440b cd bb 13			call break_point_state  
440e				endm  
# End of macro CALLMONITOR
440e					endif 
440e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
440e cd 3f 1b			call macro_dsp_valuehl 
4411				endm 
# End of macro FORTH_DSP_VALUEHL
4411			 
4411 e5					push hl 
4412			 
4412					; destroy value TOS 
4412			 
4412					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4412 cd f7 1b			call macro_forth_dsp_pop 
4415				endm 
# End of macro FORTH_DSP_POP
4415			 
4415					; one value on hl get other one back 
4415			 
4415 c1					pop bc 
4416			 
4416					; do the sub 
4416			;		ex de, hl 
4416			 
4416 ed 68				in l,(c) 
4418			 
4418					; save it 
4418			 
4418 26 00				ld h,0 
441a			 
441a					; TODO push value back onto stack for another op etc 
441a			 
441a cd 48 19				call forth_push_numhl 
441d					NEXTW 
441d c3 b1 1c			jp macro_next 
4420				endm 
# End of macro NEXTW
4420			.SOUT: 
4420				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
4420 34				db WORD_SYS_CORE+32             
4421 73 44			dw .SPIO            
4423 04				db 3 + 1 
4424 .. 00			db "OUT",0              
4428				endm 
# End of macro CWHEAD
4428			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
4428					if DEBUG_FORTH_WORDS_KEY 
4428						DMARK "OUT" 
4428 f5				push af  
4429 3a 3d 44			ld a, (.dmark)  
442c 32 7a ee			ld (debug_mark),a  
442f 3a 3e 44			ld a, (.dmark+1)  
4432 32 7b ee			ld (debug_mark+1),a  
4435 3a 3f 44			ld a, (.dmark+2)  
4438 32 7c ee			ld (debug_mark+2),a  
443b 18 03			jr .pastdmark  
443d ..			.dmark: db "OUT"  
4440 f1			.pastdmark: pop af  
4441			endm  
# End of macro DMARK
4441						CALLMONITOR 
4441 cd bb 13			call break_point_state  
4444				endm  
# End of macro CALLMONITOR
4444					endif 
4444			 
4444					; get port 
4444			 
4444					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4444 cd 3f 1b			call macro_dsp_valuehl 
4447				endm 
# End of macro FORTH_DSP_VALUEHL
4447			 
4447 e5					push hl 
4448			 
4448					; destroy value TOS 
4448			 
4448					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4448 cd f7 1b			call macro_forth_dsp_pop 
444b				endm 
# End of macro FORTH_DSP_POP
444b			 
444b					; get byte to send 
444b			 
444b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
444b cd 3f 1b			call macro_dsp_valuehl 
444e				endm 
# End of macro FORTH_DSP_VALUEHL
444e			 
444e			;		push hl 
444e			 
444e					; destroy value TOS 
444e			 
444e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
444e cd f7 1b			call macro_forth_dsp_pop 
4451				endm 
# End of macro FORTH_DSP_POP
4451			 
4451					; one value on hl get other one back 
4451			 
4451			;		pop hl 
4451			 
4451 c1					pop bc 
4452			 
4452					if DEBUG_FORTH_WORDS 
4452						DMARK "OUT" 
4452 f5				push af  
4453 3a 67 44			ld a, (.dmark)  
4456 32 7a ee			ld (debug_mark),a  
4459 3a 68 44			ld a, (.dmark+1)  
445c 32 7b ee			ld (debug_mark+1),a  
445f 3a 69 44			ld a, (.dmark+2)  
4462 32 7c ee			ld (debug_mark+2),a  
4465 18 03			jr .pastdmark  
4467 ..			.dmark: db "OUT"  
446a f1			.pastdmark: pop af  
446b			endm  
# End of macro DMARK
446b						CALLMONITOR 
446b cd bb 13			call break_point_state  
446e				endm  
# End of macro CALLMONITOR
446e					endif 
446e			 
446e ed 69				out (c), l 
4470			 
4470					NEXTW 
4470 c3 b1 1c			jp macro_next 
4473				endm 
# End of macro NEXTW
4473			 
4473			 
4473			.SPIO: 
4473			 
4473			if STORAGE_SE 
4473				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
4473			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
4473			 
4473					call spi_ce_low 
4473			    NEXTW 
4473			 
4473			.SPICEH: 
4473				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
4473			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
4473			 
4473					call spi_ce_high 
4473			    NEXTW 
4473			 
4473			 
4473			.SPIOb: 
4473			 
4473				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
4473			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
4473			 
4473					; get port 
4473			 
4473			 
4473					; get byte to send 
4473			 
4473					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4473			 
4473			;		push hl    ; u1  
4473			 
4473					; destroy value TOS 
4473			 
4473					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4473			 
4473					; one value on hl get other one back 
4473			 
4473			;		pop hl   ; u2 - addr 
4473			 
4473					; TODO Send SPI byte 
4473			 
4473					ld a, l 
4473					call spi_send_byte 
4473			 
4473					NEXTW 
4473			 
4473			.SPII: 
4473				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
4473			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
4473			 
4473					; TODO Get SPI byte 
4473			 
4473					call spi_read_byte 
4473			 
4473					ld h, 0 
4473					ld l, a 
4473					call forth_push_numhl 
4473			 
4473					NEXTW 
4473			 
4473			 
4473			 
4473			.SESEL: 
4473				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
4473			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
4473					if DEBUG_FORTH_WORDS_KEY 
4473						DMARK "BNK" 
4473						CALLMONITOR 
4473					endif 
4473			 
4473					ld a, 255 
4473					ld (spi_cartdev), a 
4473			 
4473					; get bank 
4473			 
4473					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4473			 
4473			;		push hl 
4473			 
4473					; destroy value TOS 
4473			 
4473					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4473			 
4473					; one value on hl get other one back 
4473			 
4473			;		pop hl 
4473			 
4473			 
4473					ld c, SPI_CE_HIGH 
4473					ld b, '0'    ; human readable bank number 
4473			 
4473					ld a, l 
4473			 
4473					if DEBUG_FORTH_WORDS 
4473						DMARK "BNK" 
4473						CALLMONITOR 
4473					endif 
4473			 
4473					; active low 
4473			 
4473					cp 0 
4473					jr z, .bset 
4473					cp 1 
4473					jr nz, .b2 
4473					res 0, c 
4473					ld b, '1'    ; human readable bank number 
4473			.b2:		cp 2 
4473					jr nz, .b3 
4473					res 1, c 
4473					ld b, '2'    ; human readable bank number 
4473			.b3:		cp 3 
4473					jr nz, .b4 
4473					res 2, c 
4473					ld b, '3'    ; human readable bank number 
4473			.b4:		cp 4 
4473					jr nz, .b5 
4473					res 3, c 
4473					ld b, '4'    ; human readable bank number 
4473			.b5:		cp 5 
4473					jr nz, .bset 
4473					res 4, c 
4473					ld b, '5'    ; human readable bank number 
4473			 
4473			.bset: 
4473					ld a, c 
4473					ld (spi_device),a 
4473					ld a, b 
4473					ld (spi_device_id),a 
4473					if DEBUG_FORTH_WORDS 
4473						DMARK "BN2" 
4473						CALLMONITOR 
4473					endif 
4473			 
4473					NEXTW 
4473			 
4473			.CARTDEV: 
4473				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
4473			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
4473					if DEBUG_FORTH_WORDS_KEY 
4473						DMARK "CDV" 
4473						CALLMONITOR 
4473					endif 
4473			 
4473					; disable se storage bank selection 
4473			 
4473					ld a, SPI_CE_HIGH		; ce high 
4473					ld (spi_device), a 
4473			 
4473					; get bank 
4473			 
4473					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4473			 
4473			;		push hl 
4473			 
4473					; destroy value TOS 
4473			 
4473					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4473			 
4473					; one value on hl get other one back 
4473			 
4473			;		pop hl 
4473			 
4473					; active low 
4473			 
4473					ld c, 255 
4473			 
4473					ld a, l 
4473					if DEBUG_FORTH_WORDS 
4473						DMARK "CDV" 
4473						CALLMONITOR 
4473					endif 
4473					cp 0 
4473					jr z, .cset 
4473					cp 1 
4473					jr nz, .c2 
4473					res 0, c 
4473			.c2:		cp 2 
4473					jr nz, .c3 
4473					res 1, c 
4473			.c3:		cp 3 
4473					jr nz, .c4 
4473					res 2, c 
4473			.c4:		cp 4 
4473					jr nz, .c5 
4473					res 3, c 
4473			.c5:		cp 5 
4473					jr nz, .c6 
4473					res 4, c 
4473			.c6:		cp 6 
4473					jr nz, .c7 
4473					res 5, c 
4473			.c7:		cp 7 
4473					jr nz, .c8 
4473					res 6, c 
4473			.c8:		cp 8 
4473					jr nz, .cset 
4473					res 7, c 
4473			.cset:		ld a, c 
4473					ld (spi_cartdev),a 
4473			 
4473					if DEBUG_FORTH_WORDS 
4473						DMARK "CD2" 
4473						CALLMONITOR 
4473					endif 
4473					NEXTW 
4473			endif 
4473			 
4473			.ENDDEVICE: 
4473			; eof 
4473			 
# End of file forth_words_device.asm
4473			 
4473			; var handler 
4473			 
4473			 
4473			.VARS: 
4473				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
4473 78				db WORD_SYS_CORE+100             
4474 8b 44			dw .V0Q            
4476 04				db 3 + 1 
4477 .. 00			db "V0!",0              
447b				endm 
# End of macro CWHEAD
447b			;| V0! ( u1 -- )  Store value to v0  | DONE 
447b			 
447b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
447b cd 3f 1b			call macro_dsp_valuehl 
447e				endm 
# End of macro FORTH_DSP_VALUEHL
447e			 
447e 11 13 eb				ld de, cli_var_array 
4481			 
4481 eb					ex de, hl 
4482 73					ld (hl), e 
4483 23					inc hl 
4484 72					ld (hl), d 
4485			 
4485					; destroy value TOS 
4485			 
4485					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4485 cd f7 1b			call macro_forth_dsp_pop 
4488				endm 
# End of macro FORTH_DSP_POP
4488			 
4488				       NEXTW 
4488 c3 b1 1c			jp macro_next 
448b				endm 
# End of macro NEXTW
448b			.V0Q: 
448b				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
448b 79				db WORD_SYS_CORE+101             
448c 9c 44			dw .V1S            
448e 04				db 3 + 1 
448f .. 00			db "V0@",0              
4493				endm 
# End of macro CWHEAD
4493			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
4493 2a 13 eb				ld hl, (cli_var_array) 
4496 cd 48 19				call forth_push_numhl 
4499			 
4499				       NEXTW 
4499 c3 b1 1c			jp macro_next 
449c				endm 
# End of macro NEXTW
449c			.V1S: 
449c				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
449c 7a				db WORD_SYS_CORE+102             
449d b4 44			dw .V1Q            
449f 04				db 3 + 1 
44a0 .. 00			db "V1!",0              
44a4				endm 
# End of macro CWHEAD
44a4			;| V1! ( u1 -- )  Store value to v1 | DONE 
44a4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
44a4 cd 3f 1b			call macro_dsp_valuehl 
44a7				endm 
# End of macro FORTH_DSP_VALUEHL
44a7			 
44a7 11 15 eb				ld de, cli_var_array+2 
44aa				 
44aa eb					ex de, hl 
44ab 73					ld (hl), e 
44ac 23					inc hl 
44ad 72					ld (hl), d 
44ae			 
44ae					; destroy value TOS 
44ae			 
44ae					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
44ae cd f7 1b			call macro_forth_dsp_pop 
44b1				endm 
# End of macro FORTH_DSP_POP
44b1				       NEXTW 
44b1 c3 b1 1c			jp macro_next 
44b4				endm 
# End of macro NEXTW
44b4			.V1Q: 
44b4				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
44b4 7b				db WORD_SYS_CORE+103             
44b5 c5 44			dw .V2S            
44b7 04				db 3 + 1 
44b8 .. 00			db "V1@",0              
44bc				endm 
# End of macro CWHEAD
44bc			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
44bc 2a 15 eb				ld hl, (cli_var_array+2) 
44bf cd 48 19				call forth_push_numhl 
44c2				       NEXTW 
44c2 c3 b1 1c			jp macro_next 
44c5				endm 
# End of macro NEXTW
44c5			.V2S: 
44c5				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
44c5 7c				db WORD_SYS_CORE+104             
44c6 dd 44			dw .V2Q            
44c8 04				db 3 + 1 
44c9 .. 00			db "V2!",0              
44cd				endm 
# End of macro CWHEAD
44cd			;| V2! ( u1 -- )  Store value to v2 | DONE 
44cd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
44cd cd 3f 1b			call macro_dsp_valuehl 
44d0				endm 
# End of macro FORTH_DSP_VALUEHL
44d0			 
44d0 11 17 eb				ld de, cli_var_array+4 
44d3				 
44d3 eb					ex de, hl 
44d4 73					ld (hl), e 
44d5 23					inc hl 
44d6 72					ld (hl), d 
44d7			 
44d7					; destroy value TOS 
44d7			 
44d7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
44d7 cd f7 1b			call macro_forth_dsp_pop 
44da				endm 
# End of macro FORTH_DSP_POP
44da				       NEXTW 
44da c3 b1 1c			jp macro_next 
44dd				endm 
# End of macro NEXTW
44dd			.V2Q: 
44dd				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
44dd 7d				db WORD_SYS_CORE+105             
44de ee 44			dw .V3S            
44e0 04				db 3 + 1 
44e1 .. 00			db "V2@",0              
44e5				endm 
# End of macro CWHEAD
44e5			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
44e5 2a 17 eb				ld hl, (cli_var_array+4) 
44e8 cd 48 19				call forth_push_numhl 
44eb				       NEXTW 
44eb c3 b1 1c			jp macro_next 
44ee				endm 
# End of macro NEXTW
44ee			.V3S: 
44ee				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
44ee 7c				db WORD_SYS_CORE+104             
44ef 06 45			dw .V3Q            
44f1 04				db 3 + 1 
44f2 .. 00			db "V3!",0              
44f6				endm 
# End of macro CWHEAD
44f6			;| V3! ( u1 -- )  Store value to v3 | DONE 
44f6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
44f6 cd 3f 1b			call macro_dsp_valuehl 
44f9				endm 
# End of macro FORTH_DSP_VALUEHL
44f9			 
44f9 11 19 eb				ld de, cli_var_array+6 
44fc				 
44fc eb					ex de, hl 
44fd 73					ld (hl), e 
44fe 23					inc hl 
44ff 72					ld (hl), d 
4500			 
4500					; destroy value TOS 
4500			 
4500					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4500 cd f7 1b			call macro_forth_dsp_pop 
4503				endm 
# End of macro FORTH_DSP_POP
4503				       NEXTW 
4503 c3 b1 1c			jp macro_next 
4506				endm 
# End of macro NEXTW
4506			.V3Q: 
4506				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
4506 7d				db WORD_SYS_CORE+105             
4507 17 45			dw .END            
4509 04				db 3 + 1 
450a .. 00			db "V3@",0              
450e				endm 
# End of macro CWHEAD
450e			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
450e 2a 19 eb				ld hl, (cli_var_array+6) 
4511 cd 48 19				call forth_push_numhl 
4514				       NEXTW 
4514 c3 b1 1c			jp macro_next 
4517				endm 
# End of macro NEXTW
4517			 
4517			 
4517			 
4517			 
4517			 
4517			; end of dict marker 
4517			 
4517 00			.END:    db WORD_SYS_END 
4518 00 00			dw 0 
451a 00				db 0 
451b			 
451b			; use to jp here for user dict words to save on macro expansion  
451b			 
451b			user_dict_next: 
451b				NEXTW 
451b c3 b1 1c			jp macro_next 
451e				endm 
# End of macro NEXTW
451e			 
451e			 
451e			user_exec: 
451e				;    ld hl, <word code> 
451e				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
451e				;    call forthexec 
451e				;    jp user_dict_next   (NEXT) 
451e			        ;    <word code bytes> 
451e eb				ex de, hl 
451f 2a 61 e6			ld hl,(os_tok_ptr) 
4522				 
4522				FORTH_RSP_NEXT 
4522 cd ef 18			call macro_forth_rsp_next 
4525				endm 
# End of macro FORTH_RSP_NEXT
4525			 
4525			if DEBUG_FORTH_UWORD 
4525						DMARK "UEX" 
4525 f5				push af  
4526 3a 3a 45			ld a, (.dmark)  
4529 32 7a ee			ld (debug_mark),a  
452c 3a 3b 45			ld a, (.dmark+1)  
452f 32 7b ee			ld (debug_mark+1),a  
4532 3a 3c 45			ld a, (.dmark+2)  
4535 32 7c ee			ld (debug_mark+2),a  
4538 18 03			jr .pastdmark  
453a ..			.dmark: db "UEX"  
453d f1			.pastdmark: pop af  
453e			endm  
# End of macro DMARK
453e				CALLMONITOR 
453e cd bb 13			call break_point_state  
4541				endm  
# End of macro CALLMONITOR
4541			endif 
4541			 
4541			 
4541			 
4541 eb				ex de, hl 
4542 22 61 e6			ld (os_tok_ptr), hl 
4545				 
4545				; Don't use next - Skips the first word in uword. 
4545			 
4545 c3 42 1d			jp exec1 
4548			;	NEXT 
4548			 
4548			 
4548			; eof 
# End of file forth_wordsv4.asm
4548			endif 
4548			;;;;;;;;;;;;;; Debug code 
4548			 
4548			 
4548			;if DEBUG_FORTH_PARSE 
4548 .. 00		.nowordfound: db "No match",0 
4551 .. 00		.compword:	db "Comparing word ",0 
4561 .. 00		.nextwordat:	db "Next word at",0 
456e .. 00		.charmatch:	db "Char match",0 
4579			;endif 
4579			if DEBUG_FORTH_JP 
4579			.foundword:	db "Word match. Exec..",0 
4579			endif 
4579			;if DEBUG_FORTH_PUSH 
4579 .. 00		.enddict:	db "Dict end. Push.",0 
4589 .. 00		.push_str:	db "Pushing string",0 
4598 .. 00		.push_num:	db "Pushing number",0 
45a7 .. 00		.data_sp:	db "SP:",0 
45ab .. 00		.wordinhl:	db "Word in HL (2/0):",0 
45bd .. 00		.wordinde:	db "Word in DE (3/0):",0 
45cf .. 00		.wordinbc:	db "Word in BC (4/0):",0 
45e1			;endif 
45e1			;if DEBUG_FORTH_MALLOC 
45e1 .. 00		.push_malloc:	db "Malloc address",0 
45f0			;endif 
45f0			 
45f0			 
45f0			 
45f0			; display malloc address and current data stack pointer  
45f0			 
45f0			malloc_error: 
45f0 d5				push de 
45f1 f5				push af 
45f2 e5				push hl 
45f3 cd 47 09			call clear_display 
45f6 11 18 46			ld de, .mallocerr 
45f9 3e 00			ld a,0 
45fb			;	ld de,os_word_scratch 
45fb cd 5a 09			call str_at_display 
45fe 3e 11			ld a, display_row_1+17 
4600 11 7a ee			ld de, debug_mark 
4603 cd 5a 09			call str_at_display 
4606 cd 6a 09			call update_display 
4609				;call break_point_state 
4609 cd 72 59			call cin_wait 
460c			 
460c 3e 20			ld a, ' ' 
460e 32 51 e3			ld (os_view_disable), a 
4611 e1				pop hl 
4612 f1				pop af 
4613 d1				pop de	 
4614				CALLMONITOR 
4614 cd bb 13			call break_point_state  
4617				endm  
# End of macro CALLMONITOR
4617 c9				ret 
4618			 
4618 .. 00		.mallocerr: 	db "Malloc Error",0 
4625			;if DEBUG_FORTH_PUSH 
4625			display_data_sp: 
4625 f5				push af 
4626			 
4626				; see if disabled 
4626			 
4626 3a 51 e3			ld a, (os_view_disable) 
4629 fe 2a			cp '*' 
462b 28 67			jr z, .skipdsp 
462d			 
462d e5				push hl 
462e e5				push hl 
462f e5			push hl 
4630 cd 47 09			call clear_display 
4633 e1			pop hl 
4634 7c				ld a,h 
4635 21 65 e6			ld hl, os_word_scratch 
4638 cd 75 0e			call hexout 
463b e1				pop hl 
463c 7d				ld a,l 
463d 21 67 e6			ld hl, os_word_scratch+2 
4640 cd 75 0e			call hexout 
4643 21 69 e6			ld hl, os_word_scratch+4 
4646 3e 00			ld a,0 
4648 77				ld (hl),a 
4649 11 65 e6			ld de,os_word_scratch 
464c 3e 28				ld a, display_row_2 
464e cd 5a 09				call str_at_display 
4651 11 ab 45			ld de, .wordinhl 
4654 3e 00			ld a, display_row_1 
4656			 
4656 cd 5a 09				call str_at_display 
4659 11 7a ee			ld de, debug_mark 
465c 3e 11			ld a, display_row_1+17 
465e			 
465e cd 5a 09				call str_at_display 
4661			 
4661				; display current data stack pointer 
4661 11 a7 45			ld de,.data_sp 
4664 3e 30				ld a, display_row_2 + 8 
4666 cd 5a 09				call str_at_display 
4669			 
4669 2a 0d eb			ld hl,(cli_data_sp) 
466c e5				push hl 
466d 7c				ld a,h 
466e 21 65 e6			ld hl, os_word_scratch 
4671 cd 75 0e			call hexout 
4674 e1				pop hl 
4675 7d				ld a,l 
4676 21 67 e6			ld hl, os_word_scratch+2 
4679 cd 75 0e			call hexout 
467c 21 69 e6			ld hl, os_word_scratch+4 
467f 3e 00			ld a,0 
4681 77				ld (hl),a 
4682 11 65 e6			ld de,os_word_scratch 
4685 3e 33				ld a, display_row_2 + 11 
4687 cd 5a 09				call str_at_display 
468a			 
468a			 
468a cd 6a 09			call update_display 
468d cd ea 08			call delay1s 
4690 cd ea 08			call delay1s 
4693 e1				pop hl 
4694			.skipdsp: 
4694 f1				pop af 
4695 c9				ret 
4696			 
4696			display_data_malloc: 
4696			 
4696 f5				push af 
4697 e5				push hl 
4698 e5				push hl 
4699 e5			push hl 
469a cd 47 09			call clear_display 
469d e1			pop hl 
469e 7c				ld a,h 
469f 21 65 e6			ld hl, os_word_scratch 
46a2 cd 75 0e			call hexout 
46a5 e1				pop hl 
46a6 7d				ld a,l 
46a7 21 67 e6			ld hl, os_word_scratch+2 
46aa cd 75 0e			call hexout 
46ad 21 69 e6			ld hl, os_word_scratch+4 
46b0 3e 00			ld a,0 
46b2 77				ld (hl),a 
46b3 11 65 e6			ld de,os_word_scratch 
46b6 3e 28				ld a, display_row_2 
46b8 cd 5a 09				call str_at_display 
46bb 11 e1 45			ld de, .push_malloc 
46be 3e 00			ld a, display_row_1 
46c0			 
46c0 cd 5a 09				call str_at_display 
46c3			 
46c3				; display current data stack pointer 
46c3 11 a7 45			ld de,.data_sp 
46c6 3e 30				ld a, display_row_2 + 8 
46c8 cd 5a 09				call str_at_display 
46cb			 
46cb 2a 0d eb			ld hl,(cli_data_sp) 
46ce e5				push hl 
46cf 7c				ld a,h 
46d0 21 65 e6			ld hl, os_word_scratch 
46d3 cd 75 0e			call hexout 
46d6 e1				pop hl 
46d7 7d				ld a,l 
46d8 21 67 e6			ld hl, os_word_scratch+2 
46db cd 75 0e			call hexout 
46de 21 69 e6			ld hl, os_word_scratch+4 
46e1 3e 00			ld a,0 
46e3 77				ld (hl),a 
46e4 11 65 e6			ld de,os_word_scratch 
46e7 3e 33				ld a, display_row_2 + 11 
46e9 cd 5a 09				call str_at_display 
46ec			 
46ec cd 6a 09			call update_display 
46ef cd ea 08			call delay1s 
46f2 cd ea 08			call delay1s 
46f5 e1				pop hl 
46f6 f1				pop af 
46f7 c9				ret 
46f8			;endif 
46f8			 
46f8			include "forth_autostart.asm" 
46f8			; list of commands to perform at system start up 
46f8			 
46f8			startcmds: 
46f8			;	dw test11 
46f8			;	dw test12 
46f8			;	dw test13 
46f8			;	dw test14 
46f8			;	dw test15 
46f8			;	dw test16 
46f8			;	dw test17 
46f8			;	dw ifthtest1 
46f8			;	dw ifthtest2 
46f8			;	dw ifthtest3 
46f8			;	dw mmtest1 
46f8			;	dw mmtest2 
46f8			;	dw mmtest3 
46f8			;	dw mmtest4 
46f8			;	dw mmtest5 
46f8			;	dw mmtest6 
46f8			;	dw iftest1 
46f8			;	dw iftest2 
46f8			;	dw iftest3 
46f8			;	dw looptest1 
46f8			;	dw looptest2 
46f8			;	dw test1 
46f8			;	dw test2 
46f8			;	dw test3 
46f8			;	dw test4 
46f8			;	dw game2r 
46f8			;	dw game2b1 
46f8			;	dw game2b2 
46f8			 
46f8				; start up words that are actually useful 
46f8			 
46f8 56 47			dw clrstack 
46fa 89 47			dw type 
46fc 4a 49			dw stest 
46fe ad 47			dw strncpy 
4700 eb 48			dw list 
4702 0e 48			dw start1 
4704 20 48			dw start2 
4706			;	dw start3 
4706 33 48			dw start3b 
4708 8b 48			dw start3c 
470a			 
470a				; (unit) testing words 
470a			 
470a c1 49			dw mtesta 
470c 76 4a			dw mtestb 
470e 19 4b			dw mtestc 
4710 ce 4b			dw mtestd 
4712 72 4c			dw mteste 
4714			 
4714				; demo/game words 
4714			 
4714 7e 53		        dw game3w 
4716 ac 53		        dw game3p 
4718 ca 53		        dw game3sc 
471a fb 53		        dw game3vsi 
471c 27 54		        dw game3vs 
471e				 
471e 71 51			dw game2b 
4720 df 51			dw game2bf 
4722 29 52			dw game2mba 
4724 bf 52			dw game2mbas 
4726 01 53			dw game2mb 
4728			 
4728 32 4e			dw game1 
472a 43 4e			dw game1a 
472c a5 4e			dw game1b 
472e da 4e			dw game1c 
4730 10 4f			dw game1d 
4732 41 4f			dw game1s 
4734 55 4f			dw game1t 
4736 6a 4f			dw game1f 
4738 9e 4f			dw game1z 
473a e2 4f			dw game1zz 
473c			 
473c 28 4d			dw test5 
473e 60 4d			dw test6 
4740 98 4d			dw test7 
4742 ac 4d			dw test8 
4744 d8 4d			dw test9 
4746 ee 4d			dw test10 
4748				 
4748 b9 50		        dw ssv5 
474a 9d 50		        dw ssv4 
474c 81 50		        dw ssv3 
474e 4b 50		        dw ssv2 
4750 d2 50		        dw ssv1 
4752 1a 51		        dw ssv1cpm 
4754			;	dw keyup 
4754			;	dw keydown 
4754			;	dw keyleft 
4754			;	dw keyright 
4754			;	dw 	keyf1 
4754			;	dw keyf2 
4754			;	dw keyf3 
4754			;	dw keyf4 
4754			;	dw keyf5 
4754			;	dw keyf6 
4754			;	dw keyf7 
4754			;	dw keyf8 
4754			;	dw keyf9 
4754			;	dw keyf10 
4754			;	dw keyf11 
4754			;	dw keyf12 
4754			;	dw keytab 
4754			;	dw keycr 
4754			;	dw keyhome 
4754			;	dw keyend 
4754			;	dw keybs 
4754 00 00			db 0, 0	 
4756			 
4756			 
4756			; clear stack  
4756			 
4756 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
4789			 
4789			; type ( addr count - ) 
4789 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
47ad			 
47ad			; some direct memory words 
47ad			; strncpy ( len t f -- t ) 
47ad			 
47ad .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
480e			 
480e .. 00		start1:     	db ": bpon $0000 bp ;",0 
4820 .. 00		start2:     	db ": bpoff $0001 bp ;",0 
4833			;start3:         db ": dirlist ir cls drop dup $00 > if $01 do .> BL .> .> BL .> .> BL .> loop then nop ;",0 
4833 .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 i at . $01 i at . $04 i at . loop then nop ;",0 
488b .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
48eb			 
48eb			 
48eb			; a handy word to list items on the stack 
48eb			 
48eb .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> accept drop depth 0= not until nop ;",0 
494a			 
494a			 
494a			; test stack  
494a			; rnd8 stest 
494a			 
494a .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
49c1			 
49c1			; random malloc and free cycles 
49c1			 
49c1 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
4a76			 
4a76			; fixed malloc and free cycles 
4a76			 
4a76 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
4b19			 
4b19			; fixed double string push and drop cycle  
4b19			 
4b19 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
4bce			 
4bce			; consistent fixed string push and drop cycle  
4bce			 
4bce .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
4c72			 
4c72 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
4d28			 
4d28			;test1:		db ": aa 1 2 3 ;", 0 
4d28			;test2:     	db "111 aa 888 999",0 
4d28			;test3:     	db ": bb 77 ;",0 
4d28			;test4:     	db "$02 $01 do i . loop bb",0 
4d28			 
4d28 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
4d60 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
4d98 .. 00		test7:     	db ": box hline vline ;",0 
4dac .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
4dd8 .. 00		test9:     	db ": sw $01 adsp world ;",0 
4dee .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
4e13 .. 00		test11:     	db "hello create .",0 
4e22 .. 00		test12:     	db "hello2 create .",0 
4e32			 
4e32			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
4e32			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
4e32			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
4e32			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
4e32			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
4e32			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
4e32			 
4e32			;iftest1:     	db "$0001 IF cls .",0 
4e32			;iftest2:     	db "$0000 IF cls .",0 
4e32			;iftest3:     	db "$0002 $0003 - IF cls .",0 
4e32			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
4e32			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
4e32			 
4e32			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
4e32			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
4e32			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
4e32			 
4e32			 
4e32			 
4e32			; a small guess the number game 
4e32			 
4e32 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
4e43 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
4ea5			 
4ea5 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
4eda .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
4f10 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
4f41 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
4f55 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
4f6a .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
4f9e .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
4fe2			 
4fe2			; Using 'ga' save a high score across multiple runs using external storage 
4fe2			 
4fe2 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
504b			 
504b			 
504b			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
504b			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
504b			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
504b			 
504b			; simple screen saver to test code memory reuse to destruction 
504b			 
504b .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
5081 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
509d .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
50b9 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
50d2 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
511a .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
5171			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
5171			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
5171			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
5171			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
5171			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
5171			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
5171			 
5171			 
5171			 
5171			; minesweeper/battleship finding game 
5171			; draws a game board of random ship/mine positions 
5171			; user enters coords to see if it hits on 
5171			; game ends when all are hit 
5171			; when hit or miss says how many may be in the area 
5171			 
5171			; setup the game board and then hide it 
5171 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
51df .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
5229			; prompt for where to target 
5229 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
52bf .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
52e4			; TODO see if the entered coords hits or misses pushes char hit of miss 
52e4 .. 00		game2mbht:      db ": mbckht nop ;",0 
52f3 .. 00		game2mbms:      db ": mbcms nop ;",0 
5301			; TODO how many might be near by 
5301 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
537e			 
537e			; Game 3 
537e			 
537e			; Vert scroller ski game - avoid the trees! 
537e			 
537e			; v0 score (ie turns) 
537e			; v1 player pos 
537e			; v2 left wall 
537e			; v3 right wall 
537e			 
537e			; Draw side walls randomly 
537e			 
537e .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
53ac			 
53ac			; Draw player 
53ac .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
53ca			 
53ca			; TODO Get Key 
53ca			 
53ca			; TODO Move left right 
53ca			 
53ca			; scroll and move walls a bit 
53ca			 
53ca .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
53fb			 
53fb			; main game loop 
53fb			 
53fb .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
5427 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
5466			 
5466			; key board defs 
5466			 
5466 .. 00		keyup:       db ": keyup $05 ;",0 
5474 .. 00		keydown:       db ": keydown $0a ;",0 
5484 .. 00		keyleft:       db ": keyleft $0b ;",0 
5494 .. 00		keyright:       db ": keyright $0c ;",0 
54a5 .. 00		keyf1:       db ": keyf1 $10 ;",0 
54b3 .. 00		keyf2:       db ": keyf2 $11 ;",0 
54c1 .. 00		keyf3:       db ": keyf3 $12 ;",0 
54cf .. 00		keyf4:       db ": keyf4 $13 ;",0 
54dd .. 00		keyf5:       db ": keyf5 $14 ;",0 
54eb .. 00		keyf6:       db ": keyf6 $15 ;",0 
54f9 .. 00		keyf7:       db ": keyf7 $16 ;",0 
5507 .. 00		keyf8:       db ": keyf8 $17 ;",0 
5515 .. 00		keyf9:       db ": keyf9 $18 ;",0 
5523 .. 00		keyf10:       db ": keyf10 $19 ;",0 
5532 .. 00		keyf11:       db ": keyf11 $1a ;",0 
5541 .. 00		keyf12:       db ": keyf12 $1b ;",0 
5550			 
5550 .. 00		keytab:       db ": keytab $09 ;",0 
555f .. 00		keycr:       db ": keycr $0d ;",0 
556d .. 00		keyhome:       db ": keyhome $0e ;",0 
557d .. 00		keyend:       db ": keyend $0f ;",0 
558c .. 00		keybs:       db ": keybs $08 ;",0 
559a			 
559a			   
559a			 
559a			 
559a			 
559a			; eof 
# End of file forth_autostart.asm
559a			 
559a .. 00		sprompt1: db "Startup load...",0 
55aa .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
55c0			 
55c0			forth_startup: 
55c0 21 f8 46			ld hl, startcmds 
55c3 3e 00			ld a, 0 
55c5 32 86 e7			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
55c8			 
55c8 e5			.start1:	push hl 
55c9 cd 47 09			call clear_display 
55cc 11 9a 55			ld de, sprompt1 
55cf 3e 00		        ld a, display_row_1 
55d1 cd 5a 09			call str_at_display 
55d4 11 aa 55			ld de, sprompt2 
55d7 3e 28		        ld a, display_row_2 
55d9 cd 5a 09			call str_at_display 
55dc e1				pop hl 
55dd e5				push hl 
55de 5e				ld e,(hl) 
55df 23				inc hl 
55e0 56				ld d,(hl) 
55e1 3e 50		        ld a, display_row_3 
55e3 cd 5a 09			call str_at_display 
55e6 cd 6a 09			call update_display 
55e9			 
55e9			 
55e9 3a 86 e7			ld a, (os_last_cmd) 
55ec fe 00			cp 0 
55ee 28 05			jr z, .startprompt 
55f0 cd de 08			call delay250ms 
55f3 18 24			jr .startdo 
55f5				 
55f5				 
55f5			 
55f5			.startprompt: 
55f5			 
55f5 3e 9f			ld a,display_row_4 + display_cols - 1 
55f7 11 be 18		        ld de, endprg 
55fa cd 5a 09			call str_at_display 
55fd cd 6a 09			call update_display 
5600 cd ea 08			call delay1s 
5603 cd 72 59			call cin_wait 
5606						 
5606 fe 2a			cp '*' 
5608 28 5e			jr z, .startupend1 
560a fe 23			cp '#' 
560c 20 07			jr nz, .startno 
560e 3e 01			ld a, 1 
5610 32 86 e7			ld (os_last_cmd),a 
5613 18 04			jr .startdo 
5615 fe 31		.startno:	cp '1' 
5617 28 3a			jr z,.startnxt  
5619			 
5619				; exec startup line 
5619			.startdo:	 
5619 e1				pop hl 
561a e5				push hl 
561b				 
561b 5e				ld e,(hl) 
561c 23				inc hl 
561d 56				ld d,(hl) 
561e eb				ex de,hl 
561f			 
561f e5				push hl 
5620			 
5620 3e 00			ld a, 0 
5622				;ld a, FORTH_END_BUFFER 
5622 cd dd 0f			call strlent 
5625 23				inc hl   ; include zero term to copy 
5626 06 00			ld b,0 
5628 4d				ld c,l 
5629 e1				pop hl 
562a 11 60 e3			ld de, scratch 
562d ed b0			ldir 
562f			 
562f			 
562f 21 60 e3			ld hl, scratch 
5632 cd ff 1c			call forthparse 
5635 cd 3f 1d			call forthexec 
5638 cd 56 1c			call forthexec_cleanup 
563b			 
563b 3e 78			ld a, display_row_4 
563d 11 62 16			ld de, endprog 
5640			 
5640 cd 6a 09			call update_display		 
5643			 
5643 3a 86 e7			ld a, (os_last_cmd) 
5646 fe 00			cp 0 
5648 20 09			jr nz, .startnxt 
564a cd c0 18			call next_page_prompt 
564d cd 47 09		        call clear_display 
5650 cd 6a 09			call update_display		 
5653			 
5653				; move onto next startup line? 
5653			.startnxt: 
5653			 
5653 cd de 08			call delay250ms 
5656 e1				pop hl 
5657			 
5657 23				inc hl 
5658 23				inc hl 
5659			 
5659 e5				push hl 
565a 5e				ld e, (hl) 
565b 23				inc hl 
565c 56				ld d, (hl) 
565d e1				pop hl 
565e				; TODO replace 0 test 
565e			 
565e eb				ex de, hl 
565f cd 9d 0b			call ishlzero 
5662			;	ld a,e 
5662			;	add d 
5662			;	cp 0    ; any left to do? 
5662 eb				ex de, hl 
5663 c2 c8 55			jp nz, .start1 
5666 18 01			jr .startupend 
5668			 
5668 e1			.startupend1: pop hl 
5669			.startupend: 
5669			 
5669 cd 47 09			call clear_display 
566c cd 6a 09			call update_display 
566f c9				ret 
5670			 
5670			 
5670			; stack over and underflow checks 
5670			 
5670			; init the words to detect the under/overflow 
5670			 
5670			chk_stk_init: 
5670				; a vague random number to check so we dont get any "lucky" hits 
5670 3e 2d			ld a, 45 
5672 6f				ld l, a 
5673 00				nop 
5674 3e 17			ld a, 23 
5676 67				ld h, a 
5677			 
5677 22 47 e3			ld (chk_word), hl     ; the word we need to check against 
567a			 
567a			;	ld (chk_stund), hl	; stack points.... 
567a 22 00 ef			ld (chk_stovr), hl 
567d 22 0b eb			ld (chk_ret_und), hl 
5680 22 c9 ea			ld (chk_ret_ovr), hl 
5683 22 c7 e9			ld (chk_loop_ovr), hl 
5686 22 c5 e8			ld (chk_data_ovr), hl 
5689 c9				ret 
568a				 
568a			check_stacks: 
568a				; check all stack words 
568a			 
568a e5				push hl 
568b d5				push de 
568c			 
568c			;	ld de,(chk_word) 
568c			;	ld hl, (chk_stund)	; stack points.... 
568c			;	if DEBUG_STK_FAULT 
568c			;		DMARK "FAa" 
568c			;		CALLMONITOR 
568c			;	endif 
568c			;	call cmp16 
568c			;	jp z, .chk_faulta 
568c			; 
568c			;	ld de, sfaultsu 
568c			;	jp .chk_fault 
568c			 
568c 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
568f ed 5b 47 e3		ld de,(chk_word) 
5693				if DEBUG_STK_FAULT 
5693					DMARK "FAb" 
5693					CALLMONITOR 
5693				endif 
5693 cd 92 0b			call cmp16 
5696 28 06			jr z, .chk_fault1 
5698 11 39 57			ld de, sfaultso 
569b c3 ed 56			jp .chk_fault 
569e			.chk_fault1:  
569e 2a 0b eb			ld hl, (chk_ret_und) 
56a1 ed 5b 47 e3		ld de,(chk_word) 
56a5				if DEBUG_STK_FAULT 
56a5					DMARK "FAU" 
56a5					CALLMONITOR 
56a5				endif 
56a5 cd 92 0b			call cmp16 
56a8 ca b1 56			jp z, .chk_fault2 
56ab 11 49 57			ld de, sfaultru 
56ae c3 ed 56			jp .chk_fault 
56b1			.chk_fault2:  
56b1 2a c9 ea			ld hl, (chk_ret_ovr) 
56b4 ed 5b 47 e3		ld de,(chk_word) 
56b8				if DEBUG_STK_FAULT 
56b8					DMARK "FA1" 
56b8					CALLMONITOR 
56b8				endif 
56b8 cd 92 0b			call cmp16 
56bb ca c4 56			jp z, .chk_fault3 
56be 11 57 57			ld de, sfaultro 
56c1 c3 ed 56			jp .chk_fault 
56c4			.chk_fault3:  
56c4 2a c7 e9			ld hl, (chk_loop_ovr) 
56c7 ed 5b 47 e3		ld de,(chk_word) 
56cb				if DEBUG_STK_FAULT 
56cb					DMARK "FA2" 
56cb					CALLMONITOR 
56cb				endif 
56cb cd 92 0b			call cmp16 
56ce ca d7 56			jp z, .chk_fault4 
56d1 11 71 57			ld de, sfaultlo 
56d4 c3 ed 56			jp .chk_fault 
56d7			.chk_fault4:  
56d7 2a c5 e8			ld hl, (chk_data_ovr) 
56da ed 5b 47 e3		ld de,(chk_word) 
56de				if DEBUG_STK_FAULT 
56de					DMARK "FA3" 
56de					CALLMONITOR 
56de				endif 
56de cd 92 0b			call cmp16 
56e1 ca ea 56			jp z, .chk_fault5 
56e4 11 8b 57			ld de, sfaultdo 
56e7 c3 ed 56			jp .chk_fault 
56ea			 
56ea			 
56ea			.chk_fault5:  
56ea d1				pop de 
56eb e1				pop hl 
56ec			 
56ec c9				ret 
56ed			 
56ed cd 47 09		.chk_fault: 	call clear_display 
56f0 3e 28				ld a, display_row_2 
56f2 cd 5a 09				call str_at_display 
56f5 11 1b 57				   ld de, .stackfault 
56f8 3e 00				ld a, display_row_1 
56fa cd 5a 09				call str_at_display 
56fd 11 7a ee				    ld de, debug_mark 
5700 3e 11				ld a, display_row_1+17 
5702 cd 5a 09				call str_at_display 
5705 cd 6a 09				call update_display 
5708			 
5708				; prompt before entering montior for investigating issue 
5708			 
5708 3e 78			ld a, display_row_4 
570a 11 62 16			ld de, endprog 
570d			 
570d cd 6a 09			call update_display		 
5710			 
5710 cd c0 18			call next_page_prompt 
5713			 
5713 d1				pop de 
5714 e1				pop hl 
5715 cd b6 16				call monitor 
5718 c3 b0 15				jp warmstart 
571b					;jp 0 
571b					;halt 
571b			 
571b			 
571b			 
571b .. 00		.stackfault: 	db "Stack fault:",0 
5728			 
5728 .. 00		sfaultsu: 	db	"Stack under flow",0 
5739 .. 00		sfaultso: 	db	"Stack over flow",0 
5749 .. 00		sfaultru:	db "RTS underflow",0 
5757 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
5771 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
578b .. 00		sfaultdo:	db "DTS overflow", 0 
5798			 
5798			 
5798			fault_dsp_under: 
5798 11 aa 57			ld de, .dsp_under 
579b c3 5a 58			jp .show_fault 
579e			 
579e			fault_rsp_under: 
579e 11 b8 57			ld de, .rsp_under 
57a1 c3 5a 58			jp .show_fault 
57a4			fault_loop_under: 
57a4 11 c6 57			ld de, .loop_under 
57a7 c3 5a 58			jp .show_fault 
57aa			 
57aa .. 00		.dsp_under: db "DSP Underflow",0 
57b8 .. 00		.rsp_under: db "RSP Underflow",0 
57c6 .. 00		.loop_under: db "LOOP Underflow",0 
57d5			 
57d5			 
57d5 d5			type_faultn: 	push de 
57d6 e5					push hl 
57d7 cd 47 09				call clear_display 
57da 11 01 58				   ld de, .typefaultn 
57dd 3e 00				ld a, display_row_1 
57df cd 5a 09				call str_at_display 
57e2 11 7a ee				    ld de, debug_mark 
57e5 3e 11				ld a, display_row_1+17 
57e7 cd 5a 09				call str_at_display 
57ea cd 6a 09				call update_display 
57ed			 
57ed				; prompt before entering montior for investigating issue 
57ed			 
57ed 3e 78			ld a, display_row_4 
57ef 11 62 16			ld de, endprog 
57f2			 
57f2 cd 6a 09			call update_display		 
57f5			 
57f5 cd c0 18			call next_page_prompt 
57f8			 
57f8 e5					push hl 
57f9 d5					push de 
57fa cd b6 16				call monitor 
57fd c3 b0 15				jp warmstart 
5800 76					halt 
5801			 
5801			 
5801 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
5818			 
5818 d5			type_faults: 	push de 
5819 e5					push hl 
581a cd 47 09				call clear_display 
581d 11 43 58				   ld de, .typefaults 
5820 3e 00				ld a, display_row_1 
5822 cd 5a 09				call str_at_display 
5825 11 7a ee				    ld de, debug_mark 
5828 3e 11				ld a, display_row_1+17 
582a cd 5a 09				call str_at_display 
582d cd 6a 09				call update_display 
5830			 
5830				; prompt before entering montior for investigating issue 
5830			 
5830 3e 78			ld a, display_row_4 
5832 11 62 16			ld de, endprog 
5835			 
5835 cd 6a 09			call update_display		 
5838			 
5838 cd c0 18			call next_page_prompt 
583b			 
583b e1					pop hl 
583c d1					pop de 
583d cd b6 16				call monitor 
5840 c3 b0 15				jp warmstart 
5843			 
5843			 
5843 .. 00		.typefaults: db "STR Type Expected TOS!",0 
585a			 
585a			.show_fault: 	 
585a d5					push de 
585b cd 47 09				call clear_display 
585e d1					pop de 
585f 3e 00				ld a, display_row_1 
5861 cd 5a 09				call str_at_display 
5864 11 7a ee				    ld de, debug_mark 
5867 3e 11				ld a, display_row_1+17 
5869 cd 5a 09				call str_at_display 
586c cd 6a 09				call update_display 
586f			 
586f				; prompt before entering montior for investigating issue 
586f			 
586f 3e 78			ld a, display_row_4 
5871 11 62 16			ld de, endprog 
5874			 
5874 cd 6a 09			call update_display		 
5877			 
5877 cd c0 18			call next_page_prompt 
587a			 
587a e1					pop hl 
587b d1					pop de 
587c cd b6 16				call monitor 
587f			; do a dump to cli and not warmstart so we preserve all of the uwords.  
587f			; TODO Make optional fault restart to cli or warm boot? 
587f					;jp warmstart 
587f c3 08 16				jp cli 
5882 76					halt 
5883			; eof 
# End of file forth_kernel.asm
5883			;include "nascombasic.asm" 
5883			 
5883			 
5883			; find out where the code ends if loaded into RAM (for SC114) 
5883			;endofcode:  
5883			;	nop 
5883			 
5883			 
5883			; eof 
5883			 
# End of file main.asm
5883			;include "firmware_lcd_4x40.asm" 
5883			;;include "firmware_lcd_4x20.asm" 
5883			include "firmware_cpm_display.asm" 
5883			 
5883			; Serial display interface for SC114 
5883			 
5883			 
5883			display_row_1: equ 0 
5883			display_row_2: equ display_row_1+display_cols 
5883			display_row_3: equ display_row_2 + display_cols 
5883			display_row_4: equ display_row_3 + display_cols 
5883			 
5883			kLCDWidth:  EQU display_cols             ;Width in characters 
5883			kLCD_Line1: EQU 0x00  
5883			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
5883			; E1 
5883			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
5883			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
5883			 
5883			lcd_init: 
5883				; no init as handled by the SCM bios 
5883 c9				ret 
5884			 
5884			 
5884			; low level functions for direct screen writes 
5884			 
5884			; output char at pos? 
5884			fLCD_Str: 
5884			        ;out (SC114_SIO_1_OUT),a 
5884 c5				push bc 
5885 d5				push de 
5886 5f				ld e, a 
5887			; TODO Replace with CP/M BIOS call 
5887 0e 02			ld c, $02 
5889 cd 05 00			call 5 
588c d1				pop de 
588d c1				pop bc 
588e c9				ret 
588f			 
588f			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
588f			fLCD_Pos: 
588f				; use ASCII escape to position 
588f			        ;out (SC114_SIO_1_OUT),a 
588f c5				push bc 
5890 d5				push de 
5891 5f				ld e, a 
5892 0e 02			ld c, $02 
5894			; TODO Replace with CP/M BIOS call 
5894 cd 05 00			call 5 
5897 d1				pop de 
5898 c1				pop bc 
5899			 
5899 c9				ret 
589a			 
589a			; output char at pos 
589a			fLCD_Data: 
589a			      ;  out (SC114_SIO_1_OUT),a 
589a c5				push bc 
589b d5				push de 
589c 0e 02			ld c, $02 
589e 5f				ld e, a 
589f			; TODO Replace with CP/M BIOS call 
589f cd 05 00			call 5 
58a2 d1				pop de 
58a3 c1				pop bc 
58a4			 
58a4 c9				ret 
58a5			 
58a5			; ascii cls  
58a5			 
58a5 1b 5b 48 24	.cls:   db 27, '[', 'H', "$" 
58a9			 
58a9 0d 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a ..	.clscpm: db 13, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,10,10,10,10,10,"$" 
58c0			;.clscpm: db 3, $3c,"$" 
58c0			 
58c0			; write the frame buffer given in hl to hardware  
58c0			write_display: 
58c0			 
58c0			API: equ 0 
58c0			 
58c0			if API 
58c0				push bc 
58c0				ld b, 4 
58c0			 
58c0			        ld (display_write_tmp), hl 	  
58c0			 
58c0				; clear and home cursor 
58c0			 
58c0				ld c, 9 
58c0				ld de, .cls 
58c0			; TODO Replace with CP/M BIOS call 
58c0				call 5 
58c0			 
58c0			 
58c0			.writeln: 
58c0			 
58c0				ld de, (display_write_tmp) 
58c0				ld c, 6 
58c0			; TODO Replace with CP/M BIOS call 
58c0				rst $30 
58c0				ld c, 7 
58c0				rst $30 
58c0			 
58c0				ld hl, (display_write_tmp) 
58c0				ld de, display_cols 
58c0				add hl,de 
58c0				ld (display_write_tmp),hl 
58c0			 
58c0				djnz  .writeln 
58c0			 
58c0				pop bc 
58c0			 
58c0			 
58c0				ret 
58c0			endif 
58c0 e5				push hl 
58c1 c5				push bc 
58c2 d5				push de 
58c3			 
58c3			;	ld c, 2 
58c3			;	;ld de, .cls 
58c3			;	ld a, 27 
58c3			;	rst $30 
58c3			;	ld c, 2 
58c3			;	;ld de, .cls 
58c3			;	ld a, '[' 
58c3			;	rst $30 
58c3			; 
58c3			;	ld c, 2 
58c3			;	;ld de, .cls 
58c3			;	ld a, 'H' 
58c3			;	rst $30 
58c3			; 
58c3			 
58c3			 
58c3			; lots of CR/LF 
58c3			;	ld c, 9 
58c3			;	ld de, .clscpm 
58c3			;	call 5 
58c3			 
58c3			; xterm cls 
58c3 0e 02			ld c, 2 
58c5 1e 1b			ld e, 27 
58c7 cd 05 00			call 5 
58ca			; cls causes too much flicker 
58ca			;	ld c, 2 
58ca			;	ld e, 'c' 
58ca			;	call 5 
58ca			 
58ca			; use xterm home instead 
58ca 0e 02			ld c, 2 
58cc 1e 5b			ld e, '[' 
58ce cd 05 00			call 5 
58d1 0e 02			ld c, 2 
58d3 1e 48			ld e, 'H' 
58d5 cd 05 00			call 5 
58d8			LLL: equ 0 
58d8			 
58d8			if LLL 
58d8			 
58d8				ld c, 2 
58d8				;ld de, .cls 
58d8				ld e, 27 
58d8			; TODO Replace with CP/M BIOS call 
58d8				call 5 
58d8			 
58d8			 
58d8				ld c, 2 
58d8				;ld de, .cls 
58d8				ld e, '[' 
58d8			; TODO Replace with CP/M BIOS call 
58d8				call 5 
58d8				ld c, 2 
58d8				;ld de, .cls 
58d8				ld e, '2' 
58d8			; TODO Replace with CP/M BIOS call 
58d8				call 5 
58d8				ld c, 2 
58d8				;ld de, .cls 
58d8				ld e, 'J' 
58d8			; TODO Replace with CP/M BIOS call 
58d8				call 5 
58d8			 
58d8			endif 
58d8			 
58d8 d1				pop de 
58d9 c1				pop bc 
58da e1				pop hl 
58db			 
58db			 
58db 22 d8 eb		        ld (display_write_tmp), hl 	  
58de 3e 00			ld a, kLCD_Line1 
58e0			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
58e0 06 28			ld b, display_cols 
58e2 ed 5b d8 eb		ld de, (display_write_tmp) 
58e6 cd 69 59			call write_len_string 
58e9				 
58e9			 
58e9 e5			push hl 
58ea d5			push de 
58eb c5			push bc 
58ec 0e 02			ld c, 2 
58ee 1e 0a			ld e, 10 
58f0 cd 05 00			call 5 
58f3 0e 02			ld c, 2 
58f5 1e 0d			ld e, 13 
58f7 cd 05 00			call 5 
58fa			; TODO Replace with CP/M BIOS call 
58fa				;rst $30 
58fa c1			pop bc 
58fb d1			pop de 
58fc e1			pop hl 
58fd			 
58fd				 
58fd 2a d8 eb			ld hl, (display_write_tmp) 
5900 11 28 00			ld de, display_cols 
5903 19				add hl,de 
5904 22 d8 eb			ld (display_write_tmp),hl 
5907			 
5907				 
5907 3e 28			ld a, kLCD_Line2 
5909			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
5909 06 28			ld b, display_cols 
590b ed 5b d8 eb		ld de, (display_write_tmp) 
590f cd 69 59			call write_len_string 
5912				 
5912 2a d8 eb			ld hl, (display_write_tmp) 
5915 11 28 00			ld de, display_cols 
5918 19				add hl,de 
5919 22 d8 eb			ld (display_write_tmp),hl 
591c			 
591c e5			push hl 
591d d5			push de 
591e c5			push bc 
591f 0e 07			ld c, 7 
5921			; TODO Replace with CP/M BIOS call 
5921				;rst $30 
5921 0e 02			ld c, 2 
5923 1e 0a			ld e, 10 
5925 cd 05 00			call 5 
5928 0e 02			ld c, 2 
592a 1e 0d			ld e, 13 
592c cd 05 00			call 5 
592f c1			pop bc 
5930 d1			pop de 
5931 e1			pop hl 
5932			 
5932				 
5932 3e 50			ld a, kLCD_Line3 
5934			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
5934 06 28			ld b, display_cols 
5936 ed 5b d8 eb		ld de, (display_write_tmp) 
593a cd 69 59			call write_len_string 
593d				 
593d 2a d8 eb			ld hl, (display_write_tmp) 
5940 11 28 00			ld de, display_cols 
5943 19				add hl,de 
5944 22 d8 eb			ld (display_write_tmp),hl 
5947			 
5947 e5			push hl 
5948 d5			push de 
5949 c5			push bc 
594a 0e 07			ld c, 7 
594c			; TODO Replace with CP/M BIOS call 
594c				;rst $30 
594c 0e 02			ld c, 2 
594e 1e 0a			ld e, 10 
5950 cd 05 00			call 5 
5953 0e 02			ld c, 2 
5955 1e 0d			ld e, 13 
5957 cd 05 00			call 5 
595a c1			pop bc 
595b d1			pop de 
595c e1			pop hl 
595d			 
595d				 
595d 3e 78			ld a, kLCD_Line4 
595f			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
595f 06 28			ld b, display_cols 
5961 ed 5b d8 eb		ld de, (display_write_tmp) 
5965 cd 69 59			call write_len_string 
5968 c9					ret 
5969			 
5969			 
5969				; write out a fixed length string given in b from de 
5969			 
5969 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
596a cd 9a 58		            CALL fLCD_Data      ;Write character to display 
596d 13				inc de 
596e 10 f9			djnz write_len_string 
5970 c9				ret 
5971			 
5971			 
5971			; eof 
# End of file firmware_cpm_display.asm
5971			;include "firmware_key_5x10.asm" 
5971			;;include "firmware_key_4x10.asm" 
5971			include "firmware_key_cpm.asm" 
5971			; Serial keyboard interface for SC114 
5971			 
5971			 
5971			key_init: 
5971				; no init as handled by the SCM bios 
5971 c9				ret 
5972			 
5972			 
5972			cin_wait: 
5972			;	ld a, 0 
5972			;	ret 
5972			 
5972				;in a,(SC114_SIO_1_IN) 
5972			        ; Use SCM API to get from whatever console device we are using 
5972			 
5972			; TODO Replace with CP/M BIOS call 
5972 c5				push bc 
5973 0e 01			ld c, $01 
5975 cd 05 00			call 5 
5978 c1				pop bc 
5979 c9				ret 
597a			 
597a			cin: 
597a			 
597a			 
597a c5				push bc 
597b			 
597b				; any key waiting to process? 
597b			; TODO Replace with CP/M BIOS call 
597b 0e 06			ld c, $06 
597d cd 05 00			call 5 
5980 28 0d			jr z, .cin_skip 
5982			 
5982				; yep, get it 
5982			 
5982 0e 01			ld c, $01 
5984			; TODO Replace with CP/M BIOS call 
5984 cd 05 00			call 5 
5987			 
5987 fe 7f			cp $7f     ; back space 
5989 20 02			jr nz, .skipbs 
598b 3e 08			ld a, KEY_BS 
598d			.skipbs: 
598d			 
598d c1				pop bc 
598e c9				ret 
598f			.cin_skip: 
598f 3e 00			ld a, 0 
5991 c1				pop bc 
5992 c9				ret 
5993			 
5993			 
5993			 
5993			 
# End of file firmware_key_cpm.asm
5993			endofcode:  
5993			baseram:  
5993 00				nop 
5994			 
5994			heap_start: equ baseram+15  ; Starting address of heap 
5994			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
5994			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
5994			;VDU:  EQU     endofcode           ; BASIC Work space 
5994			; eof 
5994			 
# End of file os_mega_cpm.asm
5994
