# File os_mega_sc114.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 1 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 1 
0000			STARTUP_V2: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
8000			endif 
8000			 
8000			if BASE_KEV = 1  
8000			 
8000				org 0h 
8000			endif 
8000			 
8000			if BASE_CPM = 1  
8000			 
8000				org 100h 
8000			endif 
8000 c3 b9 98			jp coldstart     ; rst 0 - cold boot 
8003			 
8003			 
8003 ..			buildtime: db   "Build: " 
800a					include "romtimestamp.asm" 
800a ..			db '2025-08-08 22:30' 
# End of file romtimestamp.asm
801a 00				   db 0 
801b			 
801b			 
801b			 
801b			;        nop  
801b			;        nop 
801b			;;	org 05h		; null out bdos call 
801b			; 
801b			;        nop  
801b			;        nop  
801b			;        nop 
801b			;;	org 08h 
801b			;;; 
801b			;;	jp cin		; rst 8 - char in 
801b			;;; 
801b			; 
801b			;        nop 
801b			;        nop 
801b			;        nop 
801b			;        nop 
801b			;        nop 
801b			;        nop 
801b			;        nop 
801b			;        nop 
801b			;	org 010h 
801b			;; 
801b			;	jp cout		; rest 010h  - char out 
801b			;; 
801b			;	org 01bh   
801b			; 
801b			;	;jp  		; rst 01bh   - write string to display 
801b			;	jp str_at_display 
801b			; 
801b			; 
801b			;	org 020h 
801b			; 
801b			;	; jp		 ; rst 020h - read char at screen location 
801b			; 
801b			;	org 028h 
801b			 
801b				; jp		 ; rst 028h  - storage i/o 
801b			 
801b			; 	org 030h 
801b			;	jp break_point_state 
801b			  
801b			; $30  
801b			; org 038h 
801b			; $38 
801b			 
801b			; TODO any more important entry points to add to jump table for easier coding use? 
801b			 
801b			if BASE_KEV = 1  
801b			 
801b				; need to be at $66 for nmi support 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255 
801b				jp nmi 
801b			endif 
801b			 
801b			include "firmware.asm" 
801b			  
801b			; main constants (used here and in firmware)  
801b			  
801b			; TODO have page 0 of storage as bios  
801b			  
801b			Device_A: equ 0h  
801b			Device_B: equ 040h          ; Sound  
801b			  
801b			if BASE_KEV  
801b			Device_C: equ 080h          ; Storage and ext cart devices  
801b			endif  
801b			  
801b			if BASE_SC114  
801b			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
801b			endif  
801b			  
801b			if BASE_CPM  
801b			; TODO fixup for CPM  
801b			Device_C: equ 080h          ; Storage and ext cart devices  
801b			endif  
801b			  
801b			Device_D: equ 0c0h             ; Keyboard and LCD  
801b			  
801b			; Odd specific debug points for testing hardware dev  
801b			  
801b			DEBUG_SOUND: equ 0       
801b			DEBUG_STK_FAULT: equ 0  
801b			DEBUG_INPUT: equ 0     ; Debug input entry code  
801b			DEBUG_INPUTV2: equ 1     ; Debug input entry code  
801b			DEBUG_KEYCINWAIT: equ 0  
801b			DEBUG_KEYCIN: equ 0  
801b			DEBUG_KEY: equ 0  
801b			DEBUG_KEY_MATRIX: equ 0  
801b			DEBUG_STORECF: equ 0  
801b			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
801b			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
801b			DEBUG_SPI: equ 0    ; low level spi tests  
801b			  
801b			; Enable many break points  
801b			  
801b			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
801b			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
801b			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
801b			DEBUG_FORTH_JP: equ 0    ; 4  
801b			DEBUG_FORTH_MALLOC: equ 0  
801b			DEBUG_FORTH_MALLOC_INT: equ 0  
801b			DEBUG_FORTH_DOT: equ 1  
801b			DEBUG_FORTH_DOT_WAIT: equ 0  
801b			DEBUG_FORTH_MATHS: equ 0  
801b			DEBUG_FORTH_TOK: equ 0    ; 4  
801b			DEBUG_FORTH_PARSE: equ 0    ; 3  
801b			DEBUG_FORTH: equ 0  ;2  
801b			DEBUG_FORTH_WORDS: equ 1   ; 1  
801b			DEBUG_FORTH_PUSH: equ 1   ; 1  
801b			DEBUG_FORTH_UWORD: equ 1   ; 1  
801b			  
801b			; Enable key point breakpoints  
801b			  
801b			DEBUG_FORTH_DOT_KEY: equ 0  
801b			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
801b			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
801b			  
801b			; Debug stack imbalances  
801b			  
801b			ON: equ 1  
801b			OFF: equ 0  
801b			  
801b			DEBUG_STACK_IMB: equ 0  
801b			STACK_IMB_STORE: equ 20  
801b			  
801b			; House keeping and protections  
801b			  
801b			DEBUG_FORTH_STACK_GUARD: equ 1  
801b			DEBUG_FORTH_MALLOC_GUARD: equ 1  
801b			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
801b			FORTH_ENABLE_FREE: equ 0  
801b			FORTH_ENABLE_MALLOCFREE: equ 1  
801b			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
801b			FORTH_ENABLE_FLOATMATH: equ 0  
801b			  
801b			  
801b			CALLMONITOR: macro  
801b			;	call break_point_state  
801b			; now use the break point debug vector  
801b				call debug_vector  
801b				endm  
801b			  
801b			MALLOC_1: equ 1        ; from dk88   
801b			MALLOC_2: equ 0           ; broke  
801b			MALLOC_3: equ 0           ; really broke  
801b			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
801b			  
801b			if BASE_KEV   
801b			;stacksize: equ 256  
801b			; each stack entry is three bytes (type + word)  
801b			stacksize: equ 3*150  
801b			  
801b			STACK_RET_SIZE: equ 64  
801b			STACK_LOOP_SIZE: equ 128  
801b			STACK_DATA_SIZE: equ 512  
801b			endif  
801b			if BASE_SC114  
801b			;tos:	equ 0f000h  
801b			stacksize: equ 256  
801b			STACK_RET_SIZE: equ 64  
801b			STACK_LOOP_SIZE: equ 128  
801b			STACK_DATA_SIZE: equ 256  
801b			endif  
801b			  
801b			if BASE_CPM  
801b			;tos:	equ 0f000h  
801b			stacksize: equ 256  
801b			STACK_RET_SIZE: equ 64  
801b			STACK_LOOP_SIZE: equ 128  
801b			STACK_DATA_SIZE: equ 256  
801b			endif  
801b			  
801b			;if STORAGE_SE == 0  
801b			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
801b			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
801b			;endif  
801b			  
801b			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
801b			  
801b			STORE_0_AUTORUN: equ $20  
801b			  
801b			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
801b			  
801b			STORE_0_AUTOFILE: equ $21  
801b			STORE_0_BANKRUN: equ $23  
801b			STORE_0_FILERUN: equ $24  
801b			  
801b			; Block 0 offsets for settings  
801b			  
801b			; if set then skip prompt for start up and accept all  
801b			  
801b			STORE_0_QUICKSTART: equ $25  
801b			  
801b			; Blocks where directory table is held  
801b			  
801b			; Reducing the number of entries increases the max file size  
801b			  
801b			;STORE_DIR_START: equ 1  
801b			;STORE_DIR_END: equ 33  
801b			  
801b			; Blocks from where file data is stored  
801b			  
801b			;STORE_DATA_START: equ STORE_DIR_END + 1  
801b			  
801b			; Block indicators (<32 are data files)  
801b			  
801b			;STORE_BLOCK_CFG: equ $8f       ; config block  
801b			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
801b			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
801b			;STORE_BLOCK_FREE: equ $85       ; data block free  
801b			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
801b			  
801b			  
801b			  
801b			; Directory entry flags  
801b			  
801b			;STORE_DIR_FREE: equ 0  
801b			;STORE_DIR_FILE:  equ 1  
801b			  
801b			; Structure offsets to directory entries  
801b			;STORE_DE_FLAG: equ 0  
801b			;STORE_DE_MAXEXT: equ 1  
801b			;STORE_DE_FILENAME: equ 2  
801b			  
801b			; Structure offsets to block 0  
801b			  
801b			;STORE_BK0_ISFOR: equ 1  
801b			;STORE_BK0_LABEL: equ 3  
801b			  
801b			; memory allocation   
801b			  
801b			chk_stund: equ tos+2           ; underflow check word  
801b			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
801b			  
801b			; keyscan table needs rows x cols buffer  
801b			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
801b			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
801b			  
801b			keyscan_table_row1: equ chk_stovr -key_cols-1  
801b			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
801b			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
801b			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
801b			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
801b			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
801b			keyscan_scancol: equ keyscan_table-key_cols  
801b			;keyscan_table_len: equ key_rows*key_cols  
801b			;keybufptr: equ keyscan_table - 2  
801b			;keysymbol: equ keybufptr - 1  
801b			key_held: equ keyscan_scancol-1	; currently held  
801b			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
801b			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
801b			key_fa: equ key_repeat_ct -1 ;  
801b			key_fb: equ key_fa -1 ;  
801b			key_fc: equ key_fb -1 ;  
801b			key_fd: equ key_fc -1 ;  
801b			key_face_held: equ key_fd - 1   
801b			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
801b			  
801b			hardware_config: equ key_face_held - 10  
801b			  
801b			; hardware config switches  
801b			; TODO add bitmasks on includes for hardware  
801b			; high byte for expansion ids  
801b			;     0000 0000  no card inserted  
801b			;     0000 0001  storage card inserted  
801b			;     0000 0010  spi sd card active  
801b			  
801b			;       
801b			; low byte:  
801b			;     0000 0001   4x4 keypad  
801b			;     0000 0010   full keyboard  
801b			;     0000 0011   spi/ext keyboard  
801b			;     0000 0100   20x4 lcd  
801b			;     0000 1000   40x4 lcd  
801b			;     0000 1100   spi/ext display  
801b			;     0001 0000   ide interface available  
801b			  
801b			hardware_word: equ hardware_config - 2  
801b			  
801b			; debug marker - optional display of debug point on the debug screens  
801b			  
801b			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
801b			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
801b			  
801b			debug_mark: equ debug_vector - 4  
801b			  
801b			; input_str vars  
801b			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
801b			input_start:  equ input_ptr - 2    ; ptr to the start of string   
801b			input_size: equ input_start -1  ; number of chars  
801b			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
801b			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
801b			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
801b			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
801b			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
801b			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
801b			input_len: equ input_cur_onoff - 5 ; length of current input  
801b			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
801b			  
801b			; cursor blink rate  
801b			CUR_BLINK_RATE: equ $09  
801b			;CUR_BLINK_RATE: equ 15  
801b			  
801b			key_actual_pressed: equ input_cursor - 1   
801b			key_symbol: equ key_actual_pressed - 1   
801b			key_shift: equ key_symbol - 1   
801b			  
801b			; Display allocation  
801b			  
801b			;display_rows: equ 4     ; move out to mini and mega files  
801b			;display_cols: equ 20  
801b			  
801b			display_fb_len: equ display_rows*display_cols  
801b			  
801b			; primary frame buffer     
801b			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
801b			; working frame buffers  
801b			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
801b			display_fb3: equ  display_fb1-display_fb_len - 1  
801b			display_fb2: equ  display_fb3-display_fb_len - 1  
801b			;  
801b			; pointer to active frame buffer  
801b			display_fb_active: equ display_fb2 - 2  
801b			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
801b			display_write_tmp: equ display_lcde1e2 - 2  
801b			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
801b			  
801b			;  
801b			  
801b			;; can load into de directory  
801b			cursor_col: equ display_active-1  
801b			cursor_row: equ cursor_col-1  
801b			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
801b			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
801b			  
801b			; maths vars  
801b			  
801b			LFSRSeed: equ cursor_shape -20   
801b			randData: equ LFSRSeed - 2  
801b			xrandc: equ randData - 2  
801b			stackstore: equ xrandc - 2  
801b			seed1: equ  stackstore -2   
801b			seed2: equ seed1 - 2  
801b			  
801b			; cf storage vars  
801b			  
801b			iErrorNum:  equ seed2-1         ;Error number  
801b			iErrorReg:  equ iErrorNum -1              ;Error register  
801b			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
801b			  
801b			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
801b			  
801b			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
801b			  
801b			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
801b			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
801b			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
801b			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
801b			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
801b			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
801b			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
801b			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
801b			store_tmpid: equ store_tmp3 - 1		; page temp id  
801b			store_tmpext: equ store_tmpid - 1		; file extent temp  
801b			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
801b			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
801b			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
801b			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
801b			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
801b			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
801b			;  
801b			; spi vars  
801b			  
801b			  
801b			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
801b			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
801b			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
801b			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
801b			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
801b			spi_device_id: equ spi_device - 1    ; human readable bank number  
801b			  
801b			;;;;; forth cli params  
801b			  
801b			; TODO use a different frame buffer for forth???  
801b			  
801b			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
801b			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
801b			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
801b			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
801b			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
801b			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
801b			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
801b			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
801b			  
801b			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
801b			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
801b			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
801b			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
801b			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
801b			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
801b			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
801b			  
801b			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
801b			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
801b			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
801b			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
801b			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
801b			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
801b			chk_data_ovr: equ cli_data_stack -2; overflow check word  
801b			  
801b			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
801b			  
801b			; os/forth token vars  
801b			  
801b			os_last_cmd: equ os_var_array-255  
801b			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
801b			os_current_i: equ os_cli_cmd-2  
801b			os_cur_ptr: equ os_current_i-2  
801b			os_word_scratch: equ os_cur_ptr-30  
801b			os_tok_len: equ os_word_scratch - 2  
801b			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
801b			os_tok_malloc: equ os_tok_ptr - 2  
801b			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
801b			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
801b			execscratch: equ os_input-255        ; exec cmd eval buffer  
801b			scratch: equ execscratch-255  
801b			  
801b			os_stack_1: equ scratch - 3       ; stack holding area 1  
801b			os_stack_2: equ os_stack_1 - 3       ; stack holding area 2  
801b			os_stack_3: equ os_stack_2 - 3       ; stack holding area 3  
801b			os_stack_4: equ os_stack_3 - 3       ; stack holding area 4  
801b			  
801b			  
801b			; temp locations for new word processing to save on adding more   
801b			  
801b			os_new_malloc: equ os_stack_4-2  
801b			os_new_parse_len: equ os_new_malloc - 2  
801b			os_new_word_len: equ os_new_parse_len - 2  
801b			os_new_work_ptr: equ os_new_word_len - 2  
801b			os_new_src_ptr: equ os_new_work_ptr - 2  
801b			os_new_exec: equ os_new_src_ptr - 2  
801b			os_new_exec_ptr: equ os_new_exec - 2  
801b			  
801b			; resume memory alloocations....  
801b			  
801b			;os_view_disable: equ os_new_exec_ptr - 1  
801b			os_view_af: equ os_new_exec_ptr - 2  
801b			os_view_hl: equ os_view_af -2  
801b			os_view_de: equ os_view_hl - 2  
801b			os_view_bc: equ os_view_de - 2  
801b			  
801b			; stack checksum word  
801b			if DEBUG_STACK_IMB  
801b				curframe: equ  os_view_de - 5  
801b				store_sp: equ curframe - (STACK_IMB_STORE*4)  
801b				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
801b			else  
801b				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
801b			endif  
801b			  
801b			; with data stack could see memory filled with junk. need some memory management   
801b			; malloc and free entry points added  
801b			  
801b			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
801b			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
801b			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
801b			;heap_end: equ free_list-1  ; Starting address of heap  
801b			;heap_start: equ free_list - heap_size  ; Starting address of heap  
801b			  
801b			;heap_start: equ free_list - heap_size  ; Starting address of heap  
801b			heap_end: equ chk_word-1  ; Starting address of heap  
801b			  
801b			  
801b			;if BASE_KEV   
801b			;heap_start: equ 0800eh  ; Starting address of heap  
801b			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
801b			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
801b			;endif  
801b			  
801b			;if BASE_SC114  
801b			;heap_start: equ baseram+15  ; Starting address of heap  
801b			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
801b			;endif  
801b			  
801b			  
801b			;;;;  
801b			  
801b			  
801b			; change below to point to last memory alloc above  
801b			topusermem:  equ   heap_start  
801b			  
801b			;if BASE_KEV   
801b			;baseusermem: equ 08000h  
801b			;endif  
801b			  
801b			;if BASE_SC114  
801b			;;aseusermem:     equ    12  
801b			;baseusermem:     equ    prompt  
801b			;;baseusermem:     equ    endofcode  
801b			;endif  
801b			  
801b			  
801b			; **********************************************************************  
801b			; **  Constants  
801b			; **********************************************************************  
801b			  
801b			; Constants used by this code module  
801b			kDataReg:   EQU Device_D           ;PIO port A data register  
801b			kContReg:   EQU Device_D+2           ;PIO port A control register  
801b			  
801b			  
801b			portbdata:  equ Device_D+1    ; port b data  
801b			portbctl:   equ Device_D+3    ; port b control  
801b			  
801b			  
801b			;KEY_SHIFT:   equ 5  
801b			;KEY_SYMBOLSHIFT:  equ 6  
801b			  
801b			KEY_SHIFTLOCK: equ 4  
801b			  
801b			  
801b			KEY_UP: equ 5  
801b			KEY_NEXTWORD: equ 6  
801b			KEY_PREVWORD: equ 7  
801b			KEY_BS: equ 8  
801b			KEY_TAB:  equ 9  
801b			KEY_DOWN: equ 10  
801b			KEY_LEFT: equ 11  
801b			KEY_RIGHT: equ 12  
801b			KEY_CR:   equ 13  
801b			KEY_HOME: equ 14  
801b			KEY_END: equ 15  
801b			  
801b			KEY_F1: equ 16  
801b			KEY_F2: equ 17  
801b			KEY_F3: equ 18  
801b			KEY_F4: equ 19  
801b			  
801b			KEY_F5: equ 20  
801b			KEY_F6: equ 21  
801b			KEY_F7: equ 22  
801b			KEY_F8: equ 23  
801b			  
801b			KEY_F9: equ 24  
801b			KEY_F10: equ 25  
801b			KEY_F11: equ 26  
801b			KEY_F12: equ 27  
801b			  
801b			;if DEBUG_KEY  
801b			;	KEY_MATRIX_NO_PRESS: equ '.'  
801b			;	KEY_SHIFT:   equ '.'  
801b			;	KEY_SYMBOLSHIFT:  equ '.'  
801b			;else  
801b				KEY_SHIFT:   equ '~'  
801b				KEY_SYMBOLSHIFT:  equ '~'  
801b				KEY_MATRIX_NO_PRESS: equ '~'  
801b			;endi  
801b			  
801b			  
801b			  
801b			  
801b			; Macro to make adding debug marks easier  
801b			  
801b			DMARK: macro str  
801b				push af  
801b				ld a, (.dmark)  
801b				ld (debug_mark),a  
801b				ld a, (.dmark+1)  
801b				ld (debug_mark+1),a  
801b				ld a, (.dmark+2)  
801b				ld (debug_mark+2),a  
801b				jr .pastdmark  
801b			.dmark: db str  
801b			.pastdmark: pop af  
801b			  
801b			endm  
801b			  
801b			  
801b			; macro to detect for stack imbalances  
801b			  
801b			include "stackimbal.asm"  
801b			; Macro and code to detect stock imbalances 
801b			 
801b			SPPUSH: equ 0 
801b			 
801b			; Add a stack frame which can be checked before return 
801b			 
801b			STACKFRAME: macro onoff frame1 frame2 
801b			 
801b				if DEBUG_STACK_IMB 
801b					if onoff 
801b						; save current SP 
801b						exx 
801b			 
801b						ld de, frame1 
801b						ld a, d 
801b						ld hl, curframe 
801b						call hexout 
801b						ld a, e 
801b						ld hl, curframe+2 
801b						call hexout 
801b			  
801b						ld hl, frame1 
801b						push hl 
801b						ld hl, frame2 
801b						push hl 
801b						exx 
801b					endif 
801b					 
801b				endif 
801b			endm 
801b			 
801b			STACKFRAMECHK: macro onoff frame1 frame2 
801b			 
801b					 
801b				if DEBUG_STACK_IMB 
801b					if onoff 
801b						exx 
801b						; check stack frame SP 
801b			 
801b						ld hl, frame2 
801b						pop de   ; frame2 
801b			 
801b						call cmp16 
801b						jr nz, .spnosame 
801b						 
801b			 
801b						ld hl, frame1 
801b						pop de   ; frame1 
801b			 
801b						call cmp16 
801b						jr z, .spfrsame 
801b			 
801b						.spnosame: call showsperror 
801b			 
801b						.spfrsame: nop 
801b			 
801b						exx 
801b					endif 
801b					 
801b				endif 
801b			 
801b			 
801b			endm 
801b			 
801b			 
801b			; for a sub routine, wrap SP collection and comparisons 
801b			 
801b			; Usage: 
801b			; 
801b			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
801b			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
801b			 
801b			SAVESP: macro onoff storeword 
801b			 
801b				if DEBUG_STACK_IMB 
801b					if onoff 
801b						; save current SP 
801b			 
801b						ld (store_sp+(storeword*4)), sp 
801b			 
801b					endif 
801b					 
801b				endif 
801b			 
801b			endm 
801b			 
801b			CHECKSP: macro onoff storeword 
801b			 
801b				if DEBUG_STACK_IMB 
801b					if onoff 
801b			 
801b						; save SP after last save 
801b				 
801b						ld (store_sp+(storeword*4)+2), sp 
801b			 
801b						push hl 
801b						ld hl, store_sp+(storeword*4) 
801b						call check_stack_sp  
801b						pop hl 
801b			 
801b			 
801b					endif 
801b					 
801b				endif 
801b			 
801b			endm 
801b			 
801b			if DEBUG_STACK_IMB 
801b			 
801b			check_stack_sp: 
801b					push de 
801b			 
801b					ld e, (hl) 
801b					inc hl 
801b					ld d, (hl) 
801b					inc hl 
801b			 
801b					push de 
801b			 
801b			 
801b					ld e, (hl) 
801b					inc hl 
801b					ld d, (hl) 
801b					inc hl 
801b			 
801b					pop hl 
801b			 
801b			 
801b					; check to see if the same 
801b			 
801b					call cmp16 
801b					jr z, .spsame 
801b			 
801b					; not same 
801b			 
801b					call showsperror 
801b			.spsame: 
801b			 
801b					pop de 
801b			 
801b					ret 
801b			 
801b			.sperr:  db "Stack imbalance",0 
801b			 
801b			 
801b			showsperror: 
801b			 
801b			 
801b				push hl 
801b				push af 
801b				push de 
801b				call clear_display 
801b				ld de, .sperr 
801b				ld a,0 
801b			;	ld de,os_word_scratch 
801b				call str_at_display 
801b				ld a, display_row_1+17 
801b				ld de, debug_mark 
801b				call str_at_display 
801b				ld a, 0 
801b				ld (curframe+4),a 
801b				ld hl, curframe 
801b				ld de, os_word_scratch 
801b				ld a, display_row_4 
801b				call str_at_display 
801b				call update_display 
801b				;call break_point_state 
801b				call cin_wait 
801b			 
801b			;	ld a, ' ' 
801b			;	ld (os_view_disable), a 
801b				call bp_on 
801b				pop de	 
801b				pop af 
801b				pop hl 
801b				CALLMONITOR 
801b				ret 
801b			 
801b			endif 
801b			 
801b			 
801b			 
801b			; eof 
# End of file stackimbal.asm
801b			  
801b			;TODO macro to calc col and row offset into screen  
801b			  
801b			  
801b			  
801b			hardware_init:  
801b			  
801b				  
801b			  
801b					;ld a, 0  
801b					;ld (hardware_diag), a  
801b			  
801b					; clear all the buffers  
801b			  
801b 21 10 ed				ld hl, display_fb1  
801e 22 cc eb				ld (display_fb_active), hl  
8021			  
8021 cd ae 8a				call clear_display  
8024			  
8024 21 ce eb				ld hl, display_fb2  
8027 22 cc eb				ld (display_fb_active), hl  
802a			  
802a cd ae 8a				call clear_display  
802d			  
802d					; init primary frame buffer area  
802d 21 b1 ed				ld hl, display_fb0  
8030 22 cc eb				ld (display_fb_active), hl  
8033			  
8033 cd ae 8a				call clear_display  
8036			  
8036			  
8036 cd 8b e5				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
8039			  
8039 cd 2d e6			call key_init  
803c cd 9e 80			call storage_init  
803f			  
803f				; setup malloc functions  
803f			  
803f				if MALLOC_1  
803f cd e9 92				call  heap_init  
8042				endif  
8042				if MALLOC_4  
8042					call  heap_init  
8042				endif  
8042			  
8042				; init sound hardware if present  
8042			  
8042				if SOUND_ENABLE  
8042					call sound_init  
8042				endif  
8042			  
8042				; lcd test sequence  
8042					  
8042 cd d1 8a			call update_display  
8045 cd f1 89			call delay1s  
8048 3e 2b			ld a,'+'  
804a cd b3 8a			call fill_display  
804d cd d1 8a			call update_display  
8050 cd f1 89			call delay1s  
8053 3e 2a			ld a,'*'  
8055 cd b3 8a			call fill_display  
8058 cd d1 8a			call update_display  
805b cd f1 89			call delay1s  
805e 3e 2d			ld a,'-'  
8060 cd b3 8a			call fill_display  
8063 cd d1 8a			call update_display  
8066 cd f1 89			call delay1s  
8069			  
8069			; boot splash screen  
8069			if display_cols == 20	  
8069			        ld a, display_row_1    
8069			else  
8069 3e 0a		        ld a, display_row_1 +10   
806b			endif  
806b 11 17 98			ld de, prom_bootmsg  
806e cd c1 8a			call str_at_display  
8071 cd d1 8a			call update_display  
8074			  
8074			  
8074 cd f1 89			call delay1s  
8077 cd f1 89			call delay1s  
807a			if display_cols == 20	  
807a			            LD   A, display_row_3+2  
807a			else  
807a 3e 5c		            LD   A, display_row_3+12  
807c			endif  
807c 11 2c 98			ld de, prom_bootmsg1  
807f cd c1 8a			call str_at_display  
8082 cd d1 8a			call update_display  
8085 cd f1 89			call delay1s  
8088 cd f1 89			call delay1s  
808b			  
808b			;	ld a, display_row_4+3  
808b			;	ld de, bootmsg2  
808b			;	call str_at_display  
808b			;	call update_display  
808b			;	call delay1s  
808b			;	call delay1s  
808b			  
808b			; debug mark setup  
808b			  
808b 3e 5f		ld a, '_'  
808d 32 6b ee		ld (debug_mark),a  
8090 32 6c ee		ld (debug_mark+1),a  
8093 32 6d ee		ld (debug_mark+2),a  
8096 3e 00		ld a,0  
8098 32 6e ee		ld (debug_mark+3),a  
809b			  
809b c9					ret  
809c			  
809c			  
809c			;bootmsg2:	db "Firmware v0.1",0  
809c			  
809c			; a 4x20 lcd  
809c			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
809c			  
809c			;if display_cols == 20  
809c			;	include "firmware_lcd_4x20.asm"  
809c			;endif  
809c			  
809c			;if display_cols == 40  
809c			;	include "firmware_lcd_4x40.asm"  
809c			;endif  
809c			  
809c			;  
809c			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
809c			; TODO abstract the bit bang video out interface for dual display  
809c			; TODO wire video out to tx pin on rc2014 bus  
809c			  
809c			; must supply cin, and cin_wait for low level hardware abstraction   
809c			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
809c			; test scancode  
809c			  
809c			;;;;;  
809c			;;;  
809c			; Moved out to mini and maxi versions  
809c			;  
809c			; include "firmware_key_4x4.asm"  
809c			; using existing 4 wire x 4 resistor array for input  
809c			;include "firmware_key_4x10.asm"  
809c			; need to mod the board for 5 rows due to resistor array  
809c			;include "firmware_key_5x10.asm"  
809c			  
809c			; storage hardware interface  
809c			  
809c			; use microchip serial eeprom for storage  
809c			  
809c			  
809c			if STORAGE_SE  
809c				include "firmware_spi.asm"  
809c				include "firmware_seeprom.asm"  
809c			else  
809c			   ; create some stubs for the labels  
809c c9			se_readbyte: ret  
809d c9			se_writebyte: ret  
809e c9			storage_init: ret  
809f			  
809f			endif  
809f			  
809f			; use cf card for storage - throwing timeout errors. Hardware or software?????  
809f			;include "firmware_cf.asm"  
809f			  
809f			; load up high level storage hardward abstractions  
809f			include "firmware_storage.asm"  
809f			 
809f			; persisent storage hardware abstraction layer  
809f			 
809f			 
809f			 
809f			; Block 0 on storage is a config state 
809f			 
809f			 
809f			 
809f			; TODO add read phy block and write phy block functions 
809f			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
809f			 
809f			; Abstraction layer  
809f			 
809f			; Logocial block size is same size as physical size - using tape concept 
809f			 
809f			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
809f			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
809f			 
809f			 
809f			 
809f			; Filesystem layout (Logical layout) 
809f			; 
809f			; Block 0 - Bank config  
809f			; 
809f			;      Byte - 0 file id counter 
809f			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
809f			;      Byte - 3-20 zero terminated bank label 
809f			; 
809f			; Block 1 > File storage 
809f			; 
809f			;      Byte 0 file id    - block 0 file details 
809f			;      Byte 1 block id - block 0 is file  
809f			;            Byte 2-15 - File name 
809f			; 
809f			;       - to end of block data 
809f			; 
809f			 
809f			; Get ID for the file named in pointer held HL 
809f			; Returns ID in HL = 255 if no file found 
809f			 
809f			storage_getid: 
809f			 
809f 22 73 ea			ld (store_tmp1), hl 
80a2			 
80a2				if DEBUG_STORESE 
80a2					DMARK "SGI" 
80a2 f5				push af  
80a3 3a b7 80			ld a, (.dmark)  
80a6 32 6b ee			ld (debug_mark),a  
80a9 3a b8 80			ld a, (.dmark+1)  
80ac 32 6c ee			ld (debug_mark+1),a  
80af 3a b9 80			ld a, (.dmark+2)  
80b2 32 6d ee			ld (debug_mark+2),a  
80b5 18 03			jr .pastdmark  
80b7 ..			.dmark: db "SGI"  
80ba f1			.pastdmark: pop af  
80bb			endm  
# End of macro DMARK
80bb					CALLMONITOR 
80bb cd 6f ee			call debug_vector  
80be				endm  
# End of macro CALLMONITOR
80be				endif 
80be				; get block 0 and set counter for number of files to scan 
80be			 
80be cd 29 82			call storage_get_block_0 
80c1			 
80c1 3a 7a ea			ld a, (store_page) 
80c4 47				ld b, a 
80c5			 
80c5				; get extent 0 of each file id 
80c5			 
80c5				if DEBUG_STORESE 
80c5					DMARK "SGc" 
80c5 f5				push af  
80c6 3a da 80			ld a, (.dmark)  
80c9 32 6b ee			ld (debug_mark),a  
80cc 3a db 80			ld a, (.dmark+1)  
80cf 32 6c ee			ld (debug_mark+1),a  
80d2 3a dc 80			ld a, (.dmark+2)  
80d5 32 6d ee			ld (debug_mark+2),a  
80d8 18 03			jr .pastdmark  
80da ..			.dmark: db "SGc"  
80dd f1			.pastdmark: pop af  
80de			endm  
# End of macro DMARK
80de					CALLMONITOR 
80de cd 6f ee			call debug_vector  
80e1				endm  
# End of macro CALLMONITOR
80e1				endif 
80e1 60			.getloop:	ld h, b 
80e2 2e 00				ld l, 0 
80e4 c5					push bc 
80e5			 
80e5 11 7a ea				ld de, store_page 
80e8				if DEBUG_STORESE 
80e8					DMARK "SGr" 
80e8 f5				push af  
80e9 3a fd 80			ld a, (.dmark)  
80ec 32 6b ee			ld (debug_mark),a  
80ef 3a fe 80			ld a, (.dmark+1)  
80f2 32 6c ee			ld (debug_mark+1),a  
80f5 3a ff 80			ld a, (.dmark+2)  
80f8 32 6d ee			ld (debug_mark+2),a  
80fb 18 03			jr .pastdmark  
80fd ..			.dmark: db "SGr"  
8100 f1			.pastdmark: pop af  
8101			endm  
# End of macro DMARK
8101					CALLMONITOR 
8101 cd 6f ee			call debug_vector  
8104				endm  
# End of macro CALLMONITOR
8104				endif 
8104 cd d1 86				call storage_read 
8107 cd 04 8d				call ishlzero 
810a 28 2d				jr z, .gap 
810c					 
810c					; have a file name read. Is it one we want. 
810c			 
810c 2a 73 ea				ld hl, (store_tmp1) 
810f 11 7d ea				ld de, store_page+3   ; file name 
8112			 
8112				if DEBUG_STORESE 
8112					DMARK "SGc" 
8112 f5				push af  
8113 3a 27 81			ld a, (.dmark)  
8116 32 6b ee			ld (debug_mark),a  
8119 3a 28 81			ld a, (.dmark+1)  
811c 32 6c ee			ld (debug_mark+1),a  
811f 3a 29 81			ld a, (.dmark+2)  
8122 32 6d ee			ld (debug_mark+2),a  
8125 18 03			jr .pastdmark  
8127 ..			.dmark: db "SGc"  
812a f1			.pastdmark: pop af  
812b			endm  
# End of macro DMARK
812b					CALLMONITOR 
812b cd 6f ee			call debug_vector  
812e				endm  
# End of macro CALLMONITOR
812e				endif 
812e cd d0 92				call strcmp 
8131 20 06				jr nz, .gap   ; not this one 
8133			 
8133 c1				        pop bc 
8134			 
8134 26 00				ld h, 0 
8136 68					ld l, b 
8137 18 22				jr .getdone 
8139						 
8139			 
8139			 
8139			 
8139			.gap: 
8139				if DEBUG_STORESE 
8139					DMARK "SGg" 
8139 f5				push af  
813a 3a 4e 81			ld a, (.dmark)  
813d 32 6b ee			ld (debug_mark),a  
8140 3a 4f 81			ld a, (.dmark+1)  
8143 32 6c ee			ld (debug_mark+1),a  
8146 3a 50 81			ld a, (.dmark+2)  
8149 32 6d ee			ld (debug_mark+2),a  
814c 18 03			jr .pastdmark  
814e ..			.dmark: db "SGg"  
8151 f1			.pastdmark: pop af  
8152			endm  
# End of macro DMARK
8152					CALLMONITOR 
8152 cd 6f ee			call debug_vector  
8155				endm  
# End of macro CALLMONITOR
8155				endif 
8155			 
8155 c1					pop bc 
8156 10 89				djnz .getloop 
8158 21 ff 00				ld hl, 255 
815b			.getdone: 
815b			 
815b				if DEBUG_STORESE 
815b					DMARK "SGe" 
815b f5				push af  
815c 3a 70 81			ld a, (.dmark)  
815f 32 6b ee			ld (debug_mark),a  
8162 3a 71 81			ld a, (.dmark+1)  
8165 32 6c ee			ld (debug_mark+1),a  
8168 3a 72 81			ld a, (.dmark+2)  
816b 32 6d ee			ld (debug_mark+2),a  
816e 18 03			jr .pastdmark  
8170 ..			.dmark: db "SGe"  
8173 f1			.pastdmark: pop af  
8174			endm  
# End of macro DMARK
8174					CALLMONITOR 
8174 cd 6f ee			call debug_vector  
8177				endm  
# End of macro CALLMONITOR
8177				endif 
8177			 
8177 c9				ret 
8178			 
8178			 
8178			 
8178			 
8178			 
8178			 
8178			 
8178			 
8178			; Read Block 
8178			; ---------- 
8178			; 
8178			; With current bank 
8178			;  
8178			; Get block number to read 
8178			; Load physical blocks starting at start block into buffer 
8178			 
8178			; de points to buffer to use 
8178			; hl holds logical block number  
8178			 
8178			storage_read_block: 
8178			 
8178				; TODO bank selection 
8178			 
8178				; for each of the physical blocks read it into the buffer 
8178 06 40			ld b, STORE_BLOCK_PHY 
817a			 
817a				if DEBUG_STORESE 
817a d5					push de 
817b				endif 
817b				 
817b			.rl1:    
817b			 
817b				; read physical block at hl into de 
817b			        ; increment hl and de to next read position on exit 
817b			 
817b e5				push hl 
817c d5				push de	 
817d c5				push bc 
817e			;	if DEBUG_STORESE 
817e			;		push af 
817e			;		ld a, 'R' 
817e			;		ld (debug_mark),a 
817e			;		pop af 
817e			;		CALLMONITOR 
817e			;	endif 
817e cd 9c 80			call se_readbyte 
8181			;	if DEBUG_STORESE 
8181			;		ld a,(spi_portbyte) 
8181			;		ld l, a 
8181			;		push af 
8181			;		ld a, '1' 
8181			;		ld (debug_mark),a 
8181			;		pop af 
8181			;		CALLMONITOR 
8181			;	endif 
8181 c1				pop bc 
8182 d1				pop de 
8183 e1				pop hl 
8184 12				ld (de),a 
8185 23				inc hl 
8186 13				inc de 
8187			 
8187			;	if DEBUG_STORESE 
8187			;		push af 
8187			;		ld a, 'r' 
8187			;		ld (debug_mark),a 
8187			;		pop af 
8187			;		CALLMONITOR 
8187			;	endif 
8187			 
8187 10 f2			djnz .rl1 
8189			 
8189				if DEBUG_STORESE 
8189					DMARK "SRB" 
8189 f5				push af  
818a 3a 9e 81			ld a, (.dmark)  
818d 32 6b ee			ld (debug_mark),a  
8190 3a 9f 81			ld a, (.dmark+1)  
8193 32 6c ee			ld (debug_mark+1),a  
8196 3a a0 81			ld a, (.dmark+2)  
8199 32 6d ee			ld (debug_mark+2),a  
819c 18 03			jr .pastdmark  
819e ..			.dmark: db "SRB"  
81a1 f1			.pastdmark: pop af  
81a2			endm  
# End of macro DMARK
81a2 d1					pop de 
81a3			; 
81a3			;		push af 
81a3			;		ld a, 'R' 
81a3			;		ld (debug_mark),a 
81a3			;		pop af 
81a3					CALLMONITOR 
81a3 cd 6f ee			call debug_vector  
81a6				endm  
# End of macro CALLMONITOR
81a6				endif 
81a6 c9				ret	 
81a7				 
81a7			 
81a7			; File Size 
81a7			; --------- 
81a7			; 
81a7			;   hl file id 
81a7			; 
81a7			;  returns in hl the number of blocks 
81a7			 
81a7			storage_file_size: 
81a7 5d				ld e, l 
81a8 16 00			ld d, 0 
81aa 21 40 00			ld hl, STORE_BLOCK_PHY 
81ad					if DEBUG_FORTH_WORDS 
81ad						DMARK "SIZ" 
81ad f5				push af  
81ae 3a c2 81			ld a, (.dmark)  
81b1 32 6b ee			ld (debug_mark),a  
81b4 3a c3 81			ld a, (.dmark+1)  
81b7 32 6c ee			ld (debug_mark+1),a  
81ba 3a c4 81			ld a, (.dmark+2)  
81bd 32 6d ee			ld (debug_mark+2),a  
81c0 18 03			jr .pastdmark  
81c2 ..			.dmark: db "SIZ"  
81c5 f1			.pastdmark: pop af  
81c6			endm  
# End of macro DMARK
81c6						CALLMONITOR 
81c6 cd 6f ee			call debug_vector  
81c9				endm  
# End of macro CALLMONITOR
81c9					endif 
81c9 cd ab 84			call storage_findnextid 
81cc			 
81cc cd 04 8d			call ishlzero 
81cf			;	ld a, l 
81cf			;	add h 
81cf			;	cp 0 
81cf c8				ret z			; block not found so EOF 
81d0			 
81d0 11 7a ea			ld de, store_page 
81d3 cd 78 81			call storage_read_block 
81d6			 
81d6 3a 7c ea			ld a, (store_page+2)	 ; get extent count 
81d9 6f				ld l, a 
81da 26 00			ld h, 0 
81dc c9			 	ret 
81dd			 
81dd			 
81dd			; Write Block 
81dd			; ----------- 
81dd			; 
81dd			; With current bank 
81dd			;  
81dd			; Get block number to write 
81dd			; Write physical blocks starting at start block from buffer 
81dd			  
81dd			storage_write_block: 
81dd				; TODO bank selection 
81dd			 
81dd				; for each of the physical blocks read it into the buffer 
81dd 06 40			ld b, STORE_BLOCK_PHY 
81df			 
81df				if DEBUG_STORESE 
81df					DMARK "SWB" 
81df f5				push af  
81e0 3a f4 81			ld a, (.dmark)  
81e3 32 6b ee			ld (debug_mark),a  
81e6 3a f5 81			ld a, (.dmark+1)  
81e9 32 6c ee			ld (debug_mark+1),a  
81ec 3a f6 81			ld a, (.dmark+2)  
81ef 32 6d ee			ld (debug_mark+2),a  
81f2 18 03			jr .pastdmark  
81f4 ..			.dmark: db "SWB"  
81f7 f1			.pastdmark: pop af  
81f8			endm  
# End of macro DMARK
81f8			 
81f8					;push af 
81f8					;ld a, 'W' 
81f8					;ld (debug_mark),a 
81f8					;pop af 
81f8					CALLMONITOR 
81f8 cd 6f ee			call debug_vector  
81fb				endm  
# End of macro CALLMONITOR
81fb				endif 
81fb			 
81fb			; might not be working 
81fb			;	call se_writepage 
81fb			 
81fb			;	ret 
81fb			; 
81fb			 
81fb			 
81fb			 
81fb			.wl1:    
81fb			 
81fb				; read physical block at hl into de 
81fb			        ; increment hl and de to next read position on exit 
81fb			 
81fb e5				push hl 
81fc d5				push de	 
81fd c5				push bc 
81fe 1a				ld a,(de) 
81ff				;if DEBUG_STORESE 
81ff			;		push af 
81ff			;		ld a, 'W' 
81ff			;		ld (debug_mark),a 
81ff			;		pop af 
81ff			;		CALLMONITOR 
81ff			;	endif 
81ff cd 9d 80			call se_writebyte 
8202			;	call delay250ms 
8202 00				nop 
8203 00				nop 
8204 00				nop 
8205			;	if DEBUG_STORESE 
8205			;		push af 
8205			;		ld a, 'w' 
8205			;		ld (debug_mark),a 
8205			;		pop af 
8205			;		CALLMONITOR 
8205			;	endif 
8205 c1				pop bc 
8206 d1				pop de 
8207 e1				pop hl 
8208 23				inc hl 
8209 13				inc de 
820a			 
820a			 
820a 10 ef			djnz .wl1 
820c			 
820c				if DEBUG_STORESE 
820c					DMARK "SW2" 
820c f5				push af  
820d 3a 21 82			ld a, (.dmark)  
8210 32 6b ee			ld (debug_mark),a  
8213 3a 22 82			ld a, (.dmark+1)  
8216 32 6c ee			ld (debug_mark+1),a  
8219 3a 23 82			ld a, (.dmark+2)  
821c 32 6d ee			ld (debug_mark+2),a  
821f 18 03			jr .pastdmark  
8221 ..			.dmark: db "SW2"  
8224 f1			.pastdmark: pop af  
8225			endm  
# End of macro DMARK
8225			 
8225					;push af 
8225					;ld a, 'W' 
8225					;ld (debug_mark),a 
8225					;pop af 
8225					CALLMONITOR 
8225 cd 6f ee			call debug_vector  
8228				endm  
# End of macro CALLMONITOR
8228				endif 
8228 c9				ret	 
8229			 
8229			; Init bank 
8229			; --------- 
8229			; 
8229			; With current bank 
8229			; 
8229			; Setup block 0 config 
8229			;     Set 0 file id counter 
8229			;     Set formatted byte pattern 
8229			;     Zero out bank label 
8229			;      
8229			; For every logical block write 0-1 byte as null 
8229			 
8229			storage_get_block_0: 
8229			 
8229				; TODO check presence 
8229			 
8229				; get block 0 config 
8229			 
8229 21 00 00			ld hl, 0 
822c 11 7a ea			ld de, store_page 
822f cd 78 81			call storage_read_block 
8232			 
8232				if DEBUG_STORESE 
8232					DMARK "SB0" 
8232 f5				push af  
8233 3a 47 82			ld a, (.dmark)  
8236 32 6b ee			ld (debug_mark),a  
8239 3a 48 82			ld a, (.dmark+1)  
823c 32 6c ee			ld (debug_mark+1),a  
823f 3a 49 82			ld a, (.dmark+2)  
8242 32 6d ee			ld (debug_mark+2),a  
8245 18 03			jr .pastdmark  
8247 ..			.dmark: db "SB0"  
824a f1			.pastdmark: pop af  
824b			endm  
# End of macro DMARK
824b 11 7a ea				ld de, store_page 
824e			;		push af 
824e			;		ld a, 'i' 
824e			;		ld (debug_mark),a 
824e			;		pop af 
824e					CALLMONITOR 
824e cd 6f ee			call debug_vector  
8251				endm  
# End of macro CALLMONITOR
8251				endif 
8251			 
8251				; is this area formatted? 
8251			 
8251			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
8251 2a 7b ea			ld hl, (store_page+1) 
8254 3e 80			ld a,0x80 
8256 bd				cp l 
8257 20 22			jr nz, .ininotformatted 
8259				; do a double check 
8259 3e 27			ld a, 0x27 
825b bc				cp h 
825c 20 1d			jr nz, .ininotformatted 
825e			 
825e				; formatted then 
825e			 
825e				if DEBUG_STORESE 
825e					DMARK "SB1" 
825e f5				push af  
825f 3a 73 82			ld a, (.dmark)  
8262 32 6b ee			ld (debug_mark),a  
8265 3a 74 82			ld a, (.dmark+1)  
8268 32 6c ee			ld (debug_mark+1),a  
826b 3a 75 82			ld a, (.dmark+2)  
826e 32 6d ee			ld (debug_mark+2),a  
8271 18 03			jr .pastdmark  
8273 ..			.dmark: db "SB1"  
8276 f1			.pastdmark: pop af  
8277			endm  
# End of macro DMARK
8277					;push af 
8277					;ld a, 'I' 
8277					;ld (debug_mark),a 
8277					;pop af 
8277					CALLMONITOR 
8277 cd 6f ee			call debug_vector  
827a				endm  
# End of macro CALLMONITOR
827a				endif 
827a c9				ret 
827b			 
827b			.ininotformatted: 
827b				; bank not formatted so poke various bits to make sure 
827b			 
827b				if DEBUG_STORESE 
827b					DMARK "SB2" 
827b f5				push af  
827c 3a 90 82			ld a, (.dmark)  
827f 32 6b ee			ld (debug_mark),a  
8282 3a 91 82			ld a, (.dmark+1)  
8285 32 6c ee			ld (debug_mark+1),a  
8288 3a 92 82			ld a, (.dmark+2)  
828b 32 6d ee			ld (debug_mark+2),a  
828e 18 03			jr .pastdmark  
8290 ..			.dmark: db "SB2"  
8293 f1			.pastdmark: pop af  
8294			endm  
# End of macro DMARK
8294					;push af 
8294					;ld a, 'f' 
8294					;ld (debug_mark),a 
8294					;pop af 
8294					CALLMONITOR 
8294 cd 6f ee			call debug_vector  
8297				endm  
# End of macro CALLMONITOR
8297				endif 
8297			 
8297 cd b4 89			call storage_clear_page 
829a			 
829a 21 7a ea			ld hl, store_page 
829d 3e 00			ld a, 0 
829f				 
829f 77				ld (hl),a   ; reset file counter 
82a0			 
82a0 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
82a3 22 7b ea		 	ld (store_page+1), hl	 
82a6			 
82a6				; set default label 
82a6			 
82a6 21 42 83			ld hl, .defaultbanklabl 
82a9 11 7d ea		 	ld de, store_page+3 
82ac 01 0f 00			ld bc, 15 
82af ed b0			ldir 
82b1			 
82b1				; Append the current bank id 
82b1 21 86 ea			ld hl, store_page+3+9 
82b4 3a 5f ea			ld a, (spi_device_id) 
82b7 77				ld (hl), a 
82b8			 
82b8				; save default page 0 
82b8			 
82b8 21 00 00			ld hl, 0 
82bb 11 7a ea			ld de, store_page 
82be				if DEBUG_STORESE 
82be					DMARK "SB3" 
82be f5				push af  
82bf 3a d3 82			ld a, (.dmark)  
82c2 32 6b ee			ld (debug_mark),a  
82c5 3a d4 82			ld a, (.dmark+1)  
82c8 32 6c ee			ld (debug_mark+1),a  
82cb 3a d5 82			ld a, (.dmark+2)  
82ce 32 6d ee			ld (debug_mark+2),a  
82d1 18 03			jr .pastdmark  
82d3 ..			.dmark: db "SB3"  
82d6 f1			.pastdmark: pop af  
82d7			endm  
# End of macro DMARK
82d7			;		push af 
82d7			;		ld a, 'F' 
82d7			;		ld (debug_mark),a 
82d7			;		pop af 
82d7					CALLMONITOR 
82d7 cd 6f ee			call debug_vector  
82da				endm  
# End of macro CALLMONITOR
82da				endif 
82da cd dd 81			call storage_write_block 
82dd				if DEBUG_STORESE 
82dd					DMARK "SB4" 
82dd f5				push af  
82de 3a f2 82			ld a, (.dmark)  
82e1 32 6b ee			ld (debug_mark),a  
82e4 3a f3 82			ld a, (.dmark+1)  
82e7 32 6c ee			ld (debug_mark+1),a  
82ea 3a f4 82			ld a, (.dmark+2)  
82ed 32 6d ee			ld (debug_mark+2),a  
82f0 18 03			jr .pastdmark  
82f2 ..			.dmark: db "SB4"  
82f5 f1			.pastdmark: pop af  
82f6			endm  
# End of macro DMARK
82f6			;		push af 
82f6			;		ld a, '>' 
82f6			;		ld (debug_mark),a 
82f6			;		pop af 
82f6					CALLMONITOR 
82f6 cd 6f ee			call debug_vector  
82f9				endm  
# End of macro CALLMONITOR
82f9				endif 
82f9			 
82f9 00				nop 
82fa 00				nop 
82fb 00				nop 
82fc			 
82fc				; now set 0 in every page to mark as a free block 
82fc			 
82fc 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
82fe 21 40 00			ld hl, STORE_BLOCK_PHY 
8301			 
8301 3e 00		.setmark1:   	ld a,0 
8303 e5					push hl 
8304 c5					push bc 
8305 cd 9d 80				call se_writebyte 
8308 3e 0a			ld a, 10 
830a cd d6 89			call aDelayInMS 
830d 23				inc hl 
830e cd 9d 80				call se_writebyte 
8311 3e 0a			ld a, 10 
8313 cd d6 89			call aDelayInMS 
8316 2b				dec hl 
8317 c1					pop bc 
8318 e1					pop hl 
8319 3e 40				ld a, STORE_BLOCK_PHY 
831b cd db 8c				call addatohl 
831e 10 e1				djnz .setmark1 
8320			 
8320 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8322 3e 00		.setmark2:   	ld a,0 
8324 e5					push hl 
8325 c5					push bc 
8326 cd 9d 80				call se_writebyte 
8329 3e 0a			ld a, 10 
832b cd d6 89			call aDelayInMS 
832e 23				inc hl 
832f cd 9d 80				call se_writebyte 
8332 3e 0a			ld a, 10 
8334 cd d6 89			call aDelayInMS 
8337 2b				dec hl 
8338 c1					pop bc 
8339 e1					pop hl 
833a 3e 40				ld a, STORE_BLOCK_PHY 
833c cd db 8c				call addatohl 
833f 10 e1				djnz .setmark2 
8341			 
8341					 
8341			 
8341			 
8341 c9				ret 
8342			 
8342			 
8342			 
8342			 
8342 .. 00		.defaultbanklabl:   db "BankLabel_",0 
834d			 
834d			 
834d			 
834d			; Label Bank 
834d			; ---------- 
834d			; 
834d			; With current bank 
834d			; Read block 0 
834d			; Set label 
834d			; Write block 0 
834d			 
834d			; label str pointer in hl 
834d			 
834d			storage_label:     
834d			 
834d				if DEBUG_STORESE 
834d					DMARK "LBL" 
834d f5				push af  
834e 3a 62 83			ld a, (.dmark)  
8351 32 6b ee			ld (debug_mark),a  
8354 3a 63 83			ld a, (.dmark+1)  
8357 32 6c ee			ld (debug_mark+1),a  
835a 3a 64 83			ld a, (.dmark+2)  
835d 32 6d ee			ld (debug_mark+2),a  
8360 18 03			jr .pastdmark  
8362 ..			.dmark: db "LBL"  
8365 f1			.pastdmark: pop af  
8366			endm  
# End of macro DMARK
8366					CALLMONITOR 
8366 cd 6f ee			call debug_vector  
8369				endm  
# End of macro CALLMONITOR
8369				endif 
8369			 
8369 e5				push hl 
836a			 
836a cd 29 82			call storage_get_block_0 
836d			 
836d				; set default label 
836d			 
836d e1				pop hl 
836e			 
836e 11 7d ea		 	ld de, store_page+3 
8371 01 0f 00			ld bc, 15 
8374				if DEBUG_STORESE 
8374					DMARK "LB3" 
8374 f5				push af  
8375 3a 89 83			ld a, (.dmark)  
8378 32 6b ee			ld (debug_mark),a  
837b 3a 8a 83			ld a, (.dmark+1)  
837e 32 6c ee			ld (debug_mark+1),a  
8381 3a 8b 83			ld a, (.dmark+2)  
8384 32 6d ee			ld (debug_mark+2),a  
8387 18 03			jr .pastdmark  
8389 ..			.dmark: db "LB3"  
838c f1			.pastdmark: pop af  
838d			endm  
# End of macro DMARK
838d					CALLMONITOR 
838d cd 6f ee			call debug_vector  
8390				endm  
# End of macro CALLMONITOR
8390				endif 
8390 ed b0			ldir 
8392				; save default page 0 
8392			 
8392 21 00 00			ld hl, 0 
8395 11 7a ea			ld de, store_page 
8398				if DEBUG_STORESE 
8398					DMARK "LBW" 
8398 f5				push af  
8399 3a ad 83			ld a, (.dmark)  
839c 32 6b ee			ld (debug_mark),a  
839f 3a ae 83			ld a, (.dmark+1)  
83a2 32 6c ee			ld (debug_mark+1),a  
83a5 3a af 83			ld a, (.dmark+2)  
83a8 32 6d ee			ld (debug_mark+2),a  
83ab 18 03			jr .pastdmark  
83ad ..			.dmark: db "LBW"  
83b0 f1			.pastdmark: pop af  
83b1			endm  
# End of macro DMARK
83b1					CALLMONITOR 
83b1 cd 6f ee			call debug_vector  
83b4				endm  
# End of macro CALLMONITOR
83b4				endif 
83b4 cd dd 81			call storage_write_block 
83b7			 
83b7 c9				ret 
83b8			 
83b8			 
83b8			 
83b8			; Read Block 0 - Config 
83b8			; --------------------- 
83b8			; 
83b8			; With current bank 
83b8			; Call presence test 
83b8			;    If not present format/init bank  
83b8			; Read block 0  
83b8			;  
83b8			 
83b8			 
83b8			; Dir 
83b8			; --- 
83b8			; 
83b8			; With current bank 
83b8			; Load Block 0 Config 
83b8			; Get max file id number 
83b8			; For each logical block 
83b8			;    Read block read byte 2 
83b8			;      if first block of file 
83b8			;         Display file name 
83b8			;         Display type flags for file 
83b8			;        
83b8			 
83b8			; moving to words as this requires stack control 
83b8			 
83b8			 
83b8			; Delete File 
83b8			; ----------- 
83b8			; 
83b8			; With current bank 
83b8			; 
83b8			; Load Block 0 Config 
83b8			; Get max file id number 
83b8			; For each logical block 
83b8			;    Read block file id 
83b8			;      If first block of file and dont have file id 
83b8			;         if file to delete 
83b8			;         Save file id 
83b8			;         Null file id 
83b8			;         Write this block back 
83b8			;      If file id is one saved 
83b8			;         Null file id 
83b8			;         Write this block back 
83b8			 
83b8			 
83b8			.se_done: 
83b8 e1				pop hl 
83b9 c9				ret 
83ba			 
83ba			storage_erase: 
83ba			 
83ba				; hl contains the file id 
83ba			 
83ba 5d				ld e, l 
83bb 16 00			ld d, 0 
83bd 21 40 00			ld hl, STORE_BLOCK_PHY 
83c0					if DEBUG_FORTH_WORDS 
83c0						DMARK "ERA" 
83c0 f5				push af  
83c1 3a d5 83			ld a, (.dmark)  
83c4 32 6b ee			ld (debug_mark),a  
83c7 3a d6 83			ld a, (.dmark+1)  
83ca 32 6c ee			ld (debug_mark+1),a  
83cd 3a d7 83			ld a, (.dmark+2)  
83d0 32 6d ee			ld (debug_mark+2),a  
83d3 18 03			jr .pastdmark  
83d5 ..			.dmark: db "ERA"  
83d8 f1			.pastdmark: pop af  
83d9			endm  
# End of macro DMARK
83d9						CALLMONITOR 
83d9 cd 6f ee			call debug_vector  
83dc				endm  
# End of macro CALLMONITOR
83dc					endif 
83dc cd ab 84			call storage_findnextid 
83df cd 04 8d			call ishlzero 
83e2 c8				ret z 
83e3			 
83e3 e5				push hl 
83e4			 
83e4				; TODO check file not found 
83e4			 
83e4 11 7a ea			ld de, store_page 
83e7 cd 78 81			call storage_read_block 
83ea			 
83ea cd 04 8d			call ishlzero 
83ed ca b8 83			jp z,.se_done 
83f0			 
83f0					if DEBUG_FORTH_WORDS 
83f0						DMARK "ER1" 
83f0 f5				push af  
83f1 3a 05 84			ld a, (.dmark)  
83f4 32 6b ee			ld (debug_mark),a  
83f7 3a 06 84			ld a, (.dmark+1)  
83fa 32 6c ee			ld (debug_mark+1),a  
83fd 3a 07 84			ld a, (.dmark+2)  
8400 32 6d ee			ld (debug_mark+2),a  
8403 18 03			jr .pastdmark  
8405 ..			.dmark: db "ER1"  
8408 f1			.pastdmark: pop af  
8409			endm  
# End of macro DMARK
8409						CALLMONITOR 
8409 cd 6f ee			call debug_vector  
840c				endm  
# End of macro CALLMONITOR
840c					endif 
840c 3a 7a ea			ld a, (store_page)	; get file id 
840f 32 6e ea			ld (store_tmpid), a 
8412			 
8412 3a 7c ea			ld a, (store_page+2)    ; get count of extends 
8415 32 6d ea			ld (store_tmpext), a 
8418			 
8418				; wipe file header 
8418			 
8418 e1				pop hl 
8419 3e 00			ld a, 0 
841b 32 7a ea			ld (store_page), a 
841e 32 7b ea			ld (store_page+1),a 
8421 11 7a ea			ld de, store_page 
8424					if DEBUG_FORTH_WORDS 
8424						DMARK "ER2" 
8424 f5				push af  
8425 3a 39 84			ld a, (.dmark)  
8428 32 6b ee			ld (debug_mark),a  
842b 3a 3a 84			ld a, (.dmark+1)  
842e 32 6c ee			ld (debug_mark+1),a  
8431 3a 3b 84			ld a, (.dmark+2)  
8434 32 6d ee			ld (debug_mark+2),a  
8437 18 03			jr .pastdmark  
8439 ..			.dmark: db "ER2"  
843c f1			.pastdmark: pop af  
843d			endm  
# End of macro DMARK
843d						CALLMONITOR 
843d cd 6f ee			call debug_vector  
8440				endm  
# End of macro CALLMONITOR
8440					endif 
8440 cd dd 81			call storage_write_block 
8443			 
8443			 
8443				; wipe file extents 
8443			 
8443 3a 6d ea			ld a, (store_tmpext) 
8446 47				ld b, a 
8447			 
8447			.eraext:	  
8447 c5				push bc 
8448			 
8448 21 40 00			ld hl, STORE_BLOCK_PHY 
844b 3a 6e ea			ld a,(store_tmpid) 
844e 5f				ld e, a 
844f 50				ld d, b	 
8450					if DEBUG_FORTH_WORDS 
8450						DMARK "ER3" 
8450 f5				push af  
8451 3a 65 84			ld a, (.dmark)  
8454 32 6b ee			ld (debug_mark),a  
8457 3a 66 84			ld a, (.dmark+1)  
845a 32 6c ee			ld (debug_mark+1),a  
845d 3a 67 84			ld a, (.dmark+2)  
8460 32 6d ee			ld (debug_mark+2),a  
8463 18 03			jr .pastdmark  
8465 ..			.dmark: db "ER3"  
8468 f1			.pastdmark: pop af  
8469			endm  
# End of macro DMARK
8469						CALLMONITOR 
8469 cd 6f ee			call debug_vector  
846c				endm  
# End of macro CALLMONITOR
846c					endif 
846c cd ab 84			call storage_findnextid 
846f cd 04 8d			call ishlzero 
8472 ca b8 83			jp z,.se_done 
8475			 
8475 e5				push hl 
8476 11 7a ea			ld de, store_page 
8479 cd 78 81			call storage_read_block 
847c			 
847c				; free block	 
847c			 
847c 3e 00			ld a, 0 
847e 32 7a ea			ld (store_page), a 
8481 32 7b ea			ld (store_page+1),a 
8484 11 7a ea			ld de, store_page 
8487 e1				pop hl 
8488					if DEBUG_FORTH_WORDS 
8488						DMARK "ER4" 
8488 f5				push af  
8489 3a 9d 84			ld a, (.dmark)  
848c 32 6b ee			ld (debug_mark),a  
848f 3a 9e 84			ld a, (.dmark+1)  
8492 32 6c ee			ld (debug_mark+1),a  
8495 3a 9f 84			ld a, (.dmark+2)  
8498 32 6d ee			ld (debug_mark+2),a  
849b 18 03			jr .pastdmark  
849d ..			.dmark: db "ER4"  
84a0 f1			.pastdmark: pop af  
84a1			endm  
# End of macro DMARK
84a1						CALLMONITOR 
84a1 cd 6f ee			call debug_vector  
84a4				endm  
# End of macro CALLMONITOR
84a4					endif 
84a4 cd dd 81			call storage_write_block 
84a7			 
84a7 c1				pop bc 
84a8 10 9d			djnz .eraext 
84aa			 
84aa c9				ret 
84ab			 
84ab			 
84ab			; Find Free Block 
84ab			; --------------- 
84ab			; 
84ab			; With current bank 
84ab			;  
84ab			; From given starting logical block 
84ab			;    Read block  
84ab			;    If no file id 
84ab			;         Return block id 
84ab			 
84ab			 
84ab			; hl starting page number 
84ab			; hl contains free page number or zero if no pages free 
84ab			; e contains the file id to locate 
84ab			; d contains the block number 
84ab			 
84ab			; TODO change to find file id and use zero for free block 
84ab			 
84ab			storage_findnextid: 
84ab			 
84ab				; now locate first 0 page to mark as a free block 
84ab			 
84ab 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84ad			;	ld hl, STORE_BLOCK_PHY 
84ad			 
84ad					if DEBUG_FORTH_WORDS 
84ad					DMARK "FNI" 
84ad f5				push af  
84ae 3a c2 84			ld a, (.dmark)  
84b1 32 6b ee			ld (debug_mark),a  
84b4 3a c3 84			ld a, (.dmark+1)  
84b7 32 6c ee			ld (debug_mark+1),a  
84ba 3a c4 84			ld a, (.dmark+2)  
84bd 32 6d ee			ld (debug_mark+2),a  
84c0 18 03			jr .pastdmark  
84c2 ..			.dmark: db "FNI"  
84c5 f1			.pastdmark: pop af  
84c6			endm  
# End of macro DMARK
84c6						CALLMONITOR 
84c6 cd 6f ee			call debug_vector  
84c9				endm  
# End of macro CALLMONITOR
84c9					endif 
84c9			.ff1:   	 
84c9 e5					push hl 
84ca c5					push bc 
84cb d5					push de 
84cc cd 9c 80				call se_readbyte 
84cf 5f					ld e,a 
84d0 23					inc hl 
84d1 cd 9c 80				call se_readbyte 
84d4 57					ld d, a 
84d5 e1					pop hl 
84d6 e5					push hl 
84d7 cd f9 8c				call cmp16 
84da 28 49				jr z, .fffound 
84dc			 
84dc d1					pop de 
84dd c1					pop bc 
84de e1					pop hl 
84df			 
84df					; is found? 
84df					;cp e 
84df					;ret z 
84df			 
84df 3e 40				ld a, STORE_BLOCK_PHY 
84e1 cd db 8c				call addatohl 
84e4 10 e3				djnz .ff1 
84e6			 
84e6 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84e8			.ff2:   	 
84e8			 
84e8 e5					push hl 
84e9 c5					push bc 
84ea d5					push de 
84eb cd 9c 80				call se_readbyte 
84ee 5f					ld e,a 
84ef 23					inc hl 
84f0 cd 9c 80				call se_readbyte 
84f3 57					ld d, a 
84f4			 
84f4 e1					pop hl 
84f5 e5					push hl 
84f6 cd f9 8c				call cmp16 
84f9 28 2a				jr z, .fffound 
84fb			 
84fb d1					pop de 
84fc c1					pop bc 
84fd e1					pop hl 
84fe					; is found? 
84fe					;cp e 
84fe					;ret z 
84fe			 
84fe 3e 40				ld a, STORE_BLOCK_PHY 
8500 cd db 8c				call addatohl 
8503 10 e3				djnz .ff2 
8505			 
8505			 
8505					if DEBUG_FORTH_WORDS 
8505					DMARK "FN-" 
8505 f5				push af  
8506 3a 1a 85			ld a, (.dmark)  
8509 32 6b ee			ld (debug_mark),a  
850c 3a 1b 85			ld a, (.dmark+1)  
850f 32 6c ee			ld (debug_mark+1),a  
8512 3a 1c 85			ld a, (.dmark+2)  
8515 32 6d ee			ld (debug_mark+2),a  
8518 18 03			jr .pastdmark  
851a ..			.dmark: db "FN-"  
851d f1			.pastdmark: pop af  
851e			endm  
# End of macro DMARK
851e					;	push af 
851e					;	ld a, 'n' 
851e					;	ld (debug_mark),a 
851e					;	pop af 
851e						CALLMONITOR 
851e cd 6f ee			call debug_vector  
8521				endm  
# End of macro CALLMONITOR
8521					endif 
8521				; no free marks! 
8521 21 00 00				ld hl, 0 
8524 c9				ret 
8525			.fffound: 
8525				 
8525			 
8525 d1					pop de 
8526 c1					pop bc 
8527 e1					pop hl 
8528					if DEBUG_FORTH_WORDS 
8528					DMARK "FNF" 
8528 f5				push af  
8529 3a 3d 85			ld a, (.dmark)  
852c 32 6b ee			ld (debug_mark),a  
852f 3a 3e 85			ld a, (.dmark+1)  
8532 32 6c ee			ld (debug_mark+1),a  
8535 3a 3f 85			ld a, (.dmark+2)  
8538 32 6d ee			ld (debug_mark+2),a  
853b 18 03			jr .pastdmark  
853d ..			.dmark: db "FNF"  
8540 f1			.pastdmark: pop af  
8541			endm  
# End of macro DMARK
8541					;	push af 
8541					;	ld a, 'n' 
8541					;	ld (debug_mark),a 
8541					;	pop af 
8541						CALLMONITOR 
8541 cd 6f ee			call debug_vector  
8544				endm  
# End of macro CALLMONITOR
8544					endif 
8544 c9				ret 
8545			 
8545			 
8545			 
8545			; Free Space 
8545			; ---------- 
8545			; 
8545			; With current bank 
8545			; 
8545			; Set block count to zero 
8545			; Starting with first logical block 
8545			;      Find free block  
8545			;      If block id given, increment block count 
8545			; 
8545			;  
8545			 
8545			 
8545			; hl contains count of free blocks 
8545			 
8545			storage_freeblocks: 
8545			 
8545				; now locate first 0 page to mark as a free block 
8545			 
8545 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8547 21 40 00			ld hl, STORE_BLOCK_PHY 
854a 11 00 00			ld de, 0 
854d			 
854d			.fb1:   	 
854d e5					push hl 
854e c5					push bc 
854f d5					push de 
8550 cd 9c 80				call se_readbyte 
8553 d1					pop de 
8554 c1					pop bc 
8555 e1					pop hl 
8556			 
8556					; is free? 
8556 fe 00				cp 0 
8558 20 01				jr nz, .ff1cont 
855a 13					inc de 
855b			 
855b			.ff1cont: 
855b			 
855b			 
855b 3e 40				ld a, STORE_BLOCK_PHY 
855d cd db 8c				call addatohl 
8560 10 eb				djnz .fb1 
8562			 
8562 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8564			.fb2:   	 
8564 e5					push hl 
8565 c5					push bc 
8566 d5					push de 
8567 cd 9c 80				call se_readbyte 
856a d1					pop de 
856b c1					pop bc 
856c e1					pop hl 
856d			 
856d					; is free? 
856d fe 00				cp 0 
856f 20 01				jr nz, .ff2cont 
8571 13					inc de 
8572			 
8572			.ff2cont: 
8572			 
8572 3e 40				ld a, STORE_BLOCK_PHY 
8574 cd db 8c				call addatohl 
8577 10 eb				djnz .fb2 
8579			 
8579 eb				ex de, hl 
857a c9				ret 
857b			 
857b			; Get File ID 
857b			; ----------- 
857b			; 
857b			; With current bank 
857b			;  
857b			; Load Block 0 Config 
857b			; Get max file id number 
857b			; For each logical block 
857b			;    Read block file id 
857b			;      If first block of file and dont have file id 
857b			;         if file get id and exit 
857b			 
857b			 
857b			 
857b			 
857b			; Create File 
857b			; ----------- 
857b			; 
857b			; With current bank  
857b			; Load Block 0 Config 
857b			; Get max file id number 
857b			; Increment file id number 
857b			; Save Config 
857b			; Find free block 
857b			; Set buffer with file name and file id 
857b			; Write buffer to free block  
857b			 
857b			 
857b			; hl point to file name 
857b			; hl returns file id 
857b			 
857b			; file format: 
857b			; byte 0 - file id 
857b			; byte 1 - extent number 
857b			; byte 2-> data 
857b			 
857b			; format for extent number 0: 
857b			; 
857b			; byte 0 - file id 
857b			; byte 1 - extent 0 
857b			; byte 2 - extent count 
857b			; byte 3 -> file name and meta data 
857b			 
857b			 
857b			storage_create: 
857b				if DEBUG_STORESE 
857b					DMARK "SCR" 
857b f5				push af  
857c 3a 90 85			ld a, (.dmark)  
857f 32 6b ee			ld (debug_mark),a  
8582 3a 91 85			ld a, (.dmark+1)  
8585 32 6c ee			ld (debug_mark+1),a  
8588 3a 92 85			ld a, (.dmark+2)  
858b 32 6d ee			ld (debug_mark+2),a  
858e 18 03			jr .pastdmark  
8590 ..			.dmark: db "SCR"  
8593 f1			.pastdmark: pop af  
8594			endm  
# End of macro DMARK
8594					CALLMONITOR 
8594 cd 6f ee			call debug_vector  
8597				endm  
# End of macro CALLMONITOR
8597				endif 
8597			 
8597 e5				push hl		; save file name pointer 
8598			 
8598 cd 29 82			call storage_get_block_0 
859b			 
859b 3a 7a ea			ld a,(store_page)	; get current file id 
859e 3c				inc a 
859f 32 7a ea			ld (store_page),a 
85a2				 
85a2 32 6e ea			ld (store_tmpid),a			; save id 
85a5			 
85a5 21 00 00			ld hl, 0 
85a8 11 7a ea			ld de, store_page 
85ab				if DEBUG_STORESE 
85ab					DMARK "SCw" 
85ab f5				push af  
85ac 3a c0 85			ld a, (.dmark)  
85af 32 6b ee			ld (debug_mark),a  
85b2 3a c1 85			ld a, (.dmark+1)  
85b5 32 6c ee			ld (debug_mark+1),a  
85b8 3a c2 85			ld a, (.dmark+2)  
85bb 32 6d ee			ld (debug_mark+2),a  
85be 18 03			jr .pastdmark  
85c0 ..			.dmark: db "SCw"  
85c3 f1			.pastdmark: pop af  
85c4			endm  
# End of macro DMARK
85c4					CALLMONITOR 
85c4 cd 6f ee			call debug_vector  
85c7				endm  
# End of macro CALLMONITOR
85c7				endif 
85c7 cd dd 81			call storage_write_block	 ; save update 
85ca			 
85ca				if DEBUG_STORESE 
85ca 11 7a ea				ld de, store_page 
85cd					DMARK "SCC" 
85cd f5				push af  
85ce 3a e2 85			ld a, (.dmark)  
85d1 32 6b ee			ld (debug_mark),a  
85d4 3a e3 85			ld a, (.dmark+1)  
85d7 32 6c ee			ld (debug_mark+1),a  
85da 3a e4 85			ld a, (.dmark+2)  
85dd 32 6d ee			ld (debug_mark+2),a  
85e0 18 03			jr .pastdmark  
85e2 ..			.dmark: db "SCC"  
85e5 f1			.pastdmark: pop af  
85e6			endm  
# End of macro DMARK
85e6					CALLMONITOR 
85e6 cd 6f ee			call debug_vector  
85e9				endm  
# End of macro CALLMONITOR
85e9				endif 
85e9				;  
85e9				 
85e9 21 40 00			ld hl, STORE_BLOCK_PHY 
85ec 11 00 00			ld de, 0 
85ef cd ab 84			call storage_findnextid 
85f2			 
85f2 22 65 ea			ld (store_tmppageid), hl    ; save page to use  
85f5			 
85f5				; TODO detect 0 = no spare blocks 
85f5			 
85f5				; hl now contains the free page to use for the file header page 
85f5			 
85f5				if DEBUG_STORESE 
85f5				DMARK "SCF" 
85f5 f5				push af  
85f6 3a 0a 86			ld a, (.dmark)  
85f9 32 6b ee			ld (debug_mark),a  
85fc 3a 0b 86			ld a, (.dmark+1)  
85ff 32 6c ee			ld (debug_mark+1),a  
8602 3a 0c 86			ld a, (.dmark+2)  
8605 32 6d ee			ld (debug_mark+2),a  
8608 18 03			jr .pastdmark  
860a ..			.dmark: db "SCF"  
860d f1			.pastdmark: pop af  
860e			endm  
# End of macro DMARK
860e					CALLMONITOR 
860e cd 6f ee			call debug_vector  
8611				endm  
# End of macro CALLMONITOR
8611				endif 
8611			 
8611 22 65 ea			ld (store_tmppageid), hl 
8614				 
8614 3a 6e ea			ld a,(store_tmpid)    ; get file id 
8617			;	ld a, (store_filecache)			; save to cache 
8617			 
8617 32 7a ea			ld (store_page),a    ; set page id 
861a 3e 00			ld a, 0			 ; extent 0 is file header 
861c 32 7b ea			ld (store_page+1), a   ; set file extent 
861f			 
861f 32 7c ea			ld (store_page+2), a   ; extent count for the file 
8622			 
8622			;	inc hl 		; init block 0 of file 
8622			;	inc hl   		; skip file and extent id 
8622			 ;       ld a, 0 
8622			;	ld (hl),a 
8622			;	ld a, (store_filecache+1)  	; save to cache 
8622			 
8622			;	inc hl    ; file name 
8622				 
8622				 
8622 11 7d ea			ld de, store_page+3    ; get buffer for term string to use as file name 
8625				if DEBUG_STORESE 
8625					DMARK "SCc" 
8625 f5				push af  
8626 3a 3a 86			ld a, (.dmark)  
8629 32 6b ee			ld (debug_mark),a  
862c 3a 3b 86			ld a, (.dmark+1)  
862f 32 6c ee			ld (debug_mark+1),a  
8632 3a 3c 86			ld a, (.dmark+2)  
8635 32 6d ee			ld (debug_mark+2),a  
8638 18 03			jr .pastdmark  
863a ..			.dmark: db "SCc"  
863d f1			.pastdmark: pop af  
863e			endm  
# End of macro DMARK
863e					CALLMONITOR 
863e cd 6f ee			call debug_vector  
8641				endm  
# End of macro CALLMONITOR
8641				endif 
8641 e1				pop hl    ; get zero term string 
8642 e5				push hl 
8643 3e 00			ld a, 0 
8645 cd a3 92			call strlent 
8648 23				inc hl   ; cover zero term 
8649 06 00			ld b,0 
864b 4d				ld c,l 
864c e1				pop hl 
864d				;ex de, hl 
864d				if DEBUG_STORESE 
864d					DMARK "SCa" 
864d f5				push af  
864e 3a 62 86			ld a, (.dmark)  
8651 32 6b ee			ld (debug_mark),a  
8654 3a 63 86			ld a, (.dmark+1)  
8657 32 6c ee			ld (debug_mark+1),a  
865a 3a 64 86			ld a, (.dmark+2)  
865d 32 6d ee			ld (debug_mark+2),a  
8660 18 03			jr .pastdmark  
8662 ..			.dmark: db "SCa"  
8665 f1			.pastdmark: pop af  
8666			endm  
# End of macro DMARK
8666					;push af 
8666					;ld a, 'a' 
8666					;ld (debug_mark),a 
8666					;pop af 
8666					CALLMONITOR 
8666 cd 6f ee			call debug_vector  
8669				endm  
# End of macro CALLMONITOR
8669				endif 
8669 ed b0			ldir    ; copy zero term string 
866b				if DEBUG_STORESE 
866b					DMARK "SCA" 
866b f5				push af  
866c 3a 80 86			ld a, (.dmark)  
866f 32 6b ee			ld (debug_mark),a  
8672 3a 81 86			ld a, (.dmark+1)  
8675 32 6c ee			ld (debug_mark+1),a  
8678 3a 82 86			ld a, (.dmark+2)  
867b 32 6d ee			ld (debug_mark+2),a  
867e 18 03			jr .pastdmark  
8680 ..			.dmark: db "SCA"  
8683 f1			.pastdmark: pop af  
8684			endm  
# End of macro DMARK
8684					CALLMONITOR 
8684 cd 6f ee			call debug_vector  
8687				endm  
# End of macro CALLMONITOR
8687				endif 
8687			 
8687				; write file header page 
8687			 
8687 2a 65 ea			ld hl,(store_tmppageid) 
868a 11 7a ea			ld de, store_page 
868d				if DEBUG_STORESE 
868d					DMARK "SCb" 
868d f5				push af  
868e 3a a2 86			ld a, (.dmark)  
8691 32 6b ee			ld (debug_mark),a  
8694 3a a3 86			ld a, (.dmark+1)  
8697 32 6c ee			ld (debug_mark+1),a  
869a 3a a4 86			ld a, (.dmark+2)  
869d 32 6d ee			ld (debug_mark+2),a  
86a0 18 03			jr .pastdmark  
86a2 ..			.dmark: db "SCb"  
86a5 f1			.pastdmark: pop af  
86a6			endm  
# End of macro DMARK
86a6					;push af 
86a6					;ld a, 'b' 
86a6					;ld (debug_mark),a 
86a6					;pop af 
86a6					CALLMONITOR 
86a6 cd 6f ee			call debug_vector  
86a9				endm  
# End of macro CALLMONITOR
86a9				endif 
86a9 cd dd 81			call storage_write_block 
86ac			 
86ac 3a 6e ea			ld a, (store_tmpid) 
86af 6f				ld l, a 
86b0 26 00			ld h,0 
86b2				if DEBUG_STORESE 
86b2					DMARK "SCz" 
86b2 f5				push af  
86b3 3a c7 86			ld a, (.dmark)  
86b6 32 6b ee			ld (debug_mark),a  
86b9 3a c8 86			ld a, (.dmark+1)  
86bc 32 6c ee			ld (debug_mark+1),a  
86bf 3a c9 86			ld a, (.dmark+2)  
86c2 32 6d ee			ld (debug_mark+2),a  
86c5 18 03			jr .pastdmark  
86c7 ..			.dmark: db "SCz"  
86ca f1			.pastdmark: pop af  
86cb			endm  
# End of macro DMARK
86cb					CALLMONITOR 
86cb cd 6f ee			call debug_vector  
86ce				endm  
# End of macro CALLMONITOR
86ce				endif 
86ce c9				ret 
86cf				 
86cf			 
86cf			 
86cf			; 
86cf			; Read File 
86cf			; 
86cf			; h - file id to locate 
86cf			; l - extent to locate 
86cf			; de - pointer to string to read into 
86cf			; 
86cf			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
86cf			 
86cf			.sr_fail: 
86cf d1				pop de 
86d0 c9				ret 
86d1			 
86d1			storage_read: 
86d1			 
86d1			 
86d1 d5				push de 
86d2			 
86d2			; TODO BUG the above push is it popped before the RET Z? 
86d2			 
86d2			; TODO how to handle multiple part blocks 
86d2			 
86d2				; locate file extent to read 
86d2			 
86d2 5c				ld e, h 
86d3 55				ld d, l 
86d4			 
86d4			.srext: 
86d4 22 78 ea			ld (store_readptr), hl     ; save the current extent to load 
86d7 ed 53 76 ea		ld (store_readbuf), de     ; save the current buffer to load in to 
86db			 
86db 21 40 00			ld hl, STORE_BLOCK_PHY 
86de				if DEBUG_STORESE 
86de					DMARK "sre" 
86de f5				push af  
86df 3a f3 86			ld a, (.dmark)  
86e2 32 6b ee			ld (debug_mark),a  
86e5 3a f4 86			ld a, (.dmark+1)  
86e8 32 6c ee			ld (debug_mark+1),a  
86eb 3a f5 86			ld a, (.dmark+2)  
86ee 32 6d ee			ld (debug_mark+2),a  
86f1 18 03			jr .pastdmark  
86f3 ..			.dmark: db "sre"  
86f6 f1			.pastdmark: pop af  
86f7			endm  
# End of macro DMARK
86f7					CALLMONITOR 
86f7 cd 6f ee			call debug_vector  
86fa				endm  
# End of macro CALLMONITOR
86fa				endif 
86fa cd ab 84			call storage_findnextid 
86fd			 
86fd				if DEBUG_STORESE 
86fd					DMARK "srf" 
86fd f5				push af  
86fe 3a 12 87			ld a, (.dmark)  
8701 32 6b ee			ld (debug_mark),a  
8704 3a 13 87			ld a, (.dmark+1)  
8707 32 6c ee			ld (debug_mark+1),a  
870a 3a 14 87			ld a, (.dmark+2)  
870d 32 6d ee			ld (debug_mark+2),a  
8710 18 03			jr .pastdmark  
8712 ..			.dmark: db "srf"  
8715 f1			.pastdmark: pop af  
8716			endm  
# End of macro DMARK
8716					CALLMONITOR 
8716 cd 6f ee			call debug_vector  
8719				endm  
# End of macro CALLMONITOR
8719				endif 
8719 cd 04 8d			call ishlzero 
871c			;	ld a, l 
871c			;	add h 
871c			;	cp 0 
871c 28 b1			jr z,.sr_fail			; block not found so EOF 
871e			 
871e				; save current address for use by higher level words etc 
871e			 
871e 22 6b ea			ld (store_openaddr),hl 
8721			 
8721			 
8721				; hl contains page number to load 
8721 d1				pop de   ; get storage 
8722 ed 53 76 ea		ld (store_readbuf), de     ; current buffer to load in to 
8726 d5				push de 
8727				if DEBUG_STORESE 
8727					DMARK "srg" 
8727 f5				push af  
8728 3a 3c 87			ld a, (.dmark)  
872b 32 6b ee			ld (debug_mark),a  
872e 3a 3d 87			ld a, (.dmark+1)  
8731 32 6c ee			ld (debug_mark+1),a  
8734 3a 3e 87			ld a, (.dmark+2)  
8737 32 6d ee			ld (debug_mark+2),a  
873a 18 03			jr .pastdmark  
873c ..			.dmark: db "srg"  
873f f1			.pastdmark: pop af  
8740			endm  
# End of macro DMARK
8740					CALLMONITOR 
8740 cd 6f ee			call debug_vector  
8743				endm  
# End of macro CALLMONITOR
8743				endif 
8743 cd 78 81			call storage_read_block 
8746			 
8746				; if this a continuation read??? 
8746			 
8746 2a 76 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
8749			 
8749 3e 3f			ld a, STORE_BLOCK_PHY-1 
874b cd db 8c			call addatohl 
874e 7e				ld a,(hl) 
874f fe 00			cp 0 
8751 28 02			jr z, .markiscont 
8753 3e ff			ld a, 255 
8755			 
8755			.markiscont: 
8755 32 6d ea			ld (store_readcont), a 
8758			 
8758				if DEBUG_STORESE 
8758					DMARK "srC" 
8758 f5				push af  
8759 3a 6d 87			ld a, (.dmark)  
875c 32 6b ee			ld (debug_mark),a  
875f 3a 6e 87			ld a, (.dmark+1)  
8762 32 6c ee			ld (debug_mark+1),a  
8765 3a 6f 87			ld a, (.dmark+2)  
8768 32 6d ee			ld (debug_mark+2),a  
876b 18 03			jr .pastdmark  
876d ..			.dmark: db "srC"  
8770 f1			.pastdmark: pop af  
8771			endm  
# End of macro DMARK
8771					CALLMONITOR 
8771 cd 6f ee			call debug_vector  
8774				endm  
# End of macro CALLMONITOR
8774				endif 
8774				; only short reads enabled 
8774			 
8774 3a 75 ea			ld a, (store_longread) 
8777 fe 00			cp 0 
8779 ca 46 88			jp z, .readdone 
877c			 
877c			; TODO if block has no zeros then need to read next block  
877c			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
877c			; check last byte of physical block. 
877c			; if not zero then the next block needs to be loaded 
877c			 
877c			 
877c 2a 76 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
877f			 
877f 3e 3f			ld a, STORE_BLOCK_PHY-1 
8781 cd db 8c			call addatohl 
8784				;dec hl 
8784 7e				ld a,(hl) 
8785				if DEBUG_STORESE 
8785					DMARK "sr?" 
8785 f5				push af  
8786 3a 9a 87			ld a, (.dmark)  
8789 32 6b ee			ld (debug_mark),a  
878c 3a 9b 87			ld a, (.dmark+1)  
878f 32 6c ee			ld (debug_mark+1),a  
8792 3a 9c 87			ld a, (.dmark+2)  
8795 32 6d ee			ld (debug_mark+2),a  
8798 18 03			jr .pastdmark  
879a ..			.dmark: db "sr?"  
879d f1			.pastdmark: pop af  
879e			endm  
# End of macro DMARK
879e					CALLMONITOR 
879e cd 6f ee			call debug_vector  
87a1				endm  
# End of macro CALLMONITOR
87a1				endif 
87a1 fe 00			cp 0 
87a3 ca 46 88			jp z, .readdone 
87a6			 
87a6				; last byte is not zero so there is more in the next extent. Load it on the end.	 
87a6			 
87a6 23				inc hl 
87a7			 
87a7 22 76 ea			ld (store_readbuf), hl     ; save the current buffer to load in to 
87aa			 
87aa ed 5b 78 ea		ld de, (store_readptr)     ; save the current extent to load 
87ae			 
87ae eb				ex de, hl 
87af			 
87af				; next ext 
87af			 
87af 23				inc hl 
87b0 22 78 ea			ld  (store_readptr), hl     ; save the current extent to load 
87b3			 
87b3				if DEBUG_STORESE 
87b3					DMARK "sF2" 
87b3 f5				push af  
87b4 3a c8 87			ld a, (.dmark)  
87b7 32 6b ee			ld (debug_mark),a  
87ba 3a c9 87			ld a, (.dmark+1)  
87bd 32 6c ee			ld (debug_mark+1),a  
87c0 3a ca 87			ld a, (.dmark+2)  
87c3 32 6d ee			ld (debug_mark+2),a  
87c6 18 03			jr .pastdmark  
87c8 ..			.dmark: db "sF2"  
87cb f1			.pastdmark: pop af  
87cc			endm  
# End of macro DMARK
87cc					CALLMONITOR 
87cc cd 6f ee			call debug_vector  
87cf				endm  
# End of macro CALLMONITOR
87cf				endif 
87cf			 
87cf				; get and load block 
87cf			 
87cf cd ab 84			call storage_findnextid 
87d2			 
87d2				if DEBUG_STORESE 
87d2					DMARK "sf2" 
87d2 f5				push af  
87d3 3a e7 87			ld a, (.dmark)  
87d6 32 6b ee			ld (debug_mark),a  
87d9 3a e8 87			ld a, (.dmark+1)  
87dc 32 6c ee			ld (debug_mark+1),a  
87df 3a e9 87			ld a, (.dmark+2)  
87e2 32 6d ee			ld (debug_mark+2),a  
87e5 18 03			jr .pastdmark  
87e7 ..			.dmark: db "sf2"  
87ea f1			.pastdmark: pop af  
87eb			endm  
# End of macro DMARK
87eb					CALLMONITOR 
87eb cd 6f ee			call debug_vector  
87ee				endm  
# End of macro CALLMONITOR
87ee				endif 
87ee cd 04 8d			call ishlzero 
87f1			;	ld a, l 
87f1			;	add h 
87f1			;	cp 0 
87f1 ca cf 86			jp z,.sr_fail			; block not found so EOF 
87f4				 
87f4				; save current address for use by higher level words etc 
87f4			 
87f4 22 6b ea			ld (store_openaddr),hl 
87f7			 
87f7 cd 78 81			call storage_read_block 
87fa			 
87fa				; on a continuation block, we now have the file id and ext in the middle of the block 
87fa				; we need to pull everything back  
87fa			 
87fa ed 5b 76 ea		ld de, (store_readbuf)     ; current buffer to nudge into 
87fe 2a 76 ea			ld hl, (store_readbuf)     ; current buffer where data actually exists 
8801 23				inc hl 
8802 23				inc hl     ; skip id and ext 
8803 01 40 00			ld bc, STORE_BLOCK_PHY 
8806				if DEBUG_STORESE 
8806					DMARK "SR<" 
8806 f5				push af  
8807 3a 1b 88			ld a, (.dmark)  
880a 32 6b ee			ld (debug_mark),a  
880d 3a 1c 88			ld a, (.dmark+1)  
8810 32 6c ee			ld (debug_mark+1),a  
8813 3a 1d 88			ld a, (.dmark+2)  
8816 32 6d ee			ld (debug_mark+2),a  
8819 18 03			jr .pastdmark  
881b ..			.dmark: db "SR<"  
881e f1			.pastdmark: pop af  
881f			endm  
# End of macro DMARK
881f					CALLMONITOR 
881f cd 6f ee			call debug_vector  
8822				endm  
# End of macro CALLMONITOR
8822				endif 
8822 ed b0			ldir     ; copy data 
8824			 
8824				; move the pointer back and pretend we have a full buffer for next recheck 
8824			 
8824 1b				dec de 
8825 1b				dec de 
8826			 
8826			; TODO do pop below now short circuit loop????? 
8826 c1				pop bc     ; get rid of spare de on stack 
8827				if DEBUG_STORESE 
8827					DMARK "SR>" 
8827 f5				push af  
8828 3a 3c 88			ld a, (.dmark)  
882b 32 6b ee			ld (debug_mark),a  
882e 3a 3d 88			ld a, (.dmark+1)  
8831 32 6c ee			ld (debug_mark+1),a  
8834 3a 3e 88			ld a, (.dmark+2)  
8837 32 6d ee			ld (debug_mark+2),a  
883a 18 03			jr .pastdmark  
883c ..			.dmark: db "SR>"  
883f f1			.pastdmark: pop af  
8840			endm  
# End of macro DMARK
8840					CALLMONITOR 
8840 cd 6f ee			call debug_vector  
8843				endm  
# End of macro CALLMONITOR
8843				endif 
8843 c3 d4 86			jp .srext 
8846			 
8846			 
8846			 
8846			 
8846			 
8846			.readdone:		 
8846 e1				pop hl 		 ; return start of data to show as not EOF 
8847 23				inc hl   ; past file id 
8848 23				inc hl   ; past ext 
8849				if DEBUG_STORESE 
8849					DMARK "SRe" 
8849 f5				push af  
884a 3a 5e 88			ld a, (.dmark)  
884d 32 6b ee			ld (debug_mark),a  
8850 3a 5f 88			ld a, (.dmark+1)  
8853 32 6c ee			ld (debug_mark+1),a  
8856 3a 60 88			ld a, (.dmark+2)  
8859 32 6d ee			ld (debug_mark+2),a  
885c 18 03			jr .pastdmark  
885e ..			.dmark: db "SRe"  
8861 f1			.pastdmark: pop af  
8862			endm  
# End of macro DMARK
8862					CALLMONITOR 
8862 cd 6f ee			call debug_vector  
8865				endm  
# End of macro CALLMONITOR
8865				endif 
8865 c9					ret 
8866			 
8866			 
8866			 
8866			; 
8866			; Append File 
8866			; 
8866			; hl - file id to locate 
8866			; de - pointer to (multi block) string to write 
8866			 
8866			.sa_notfound: 
8866 d1				pop de 
8867 c9				ret 
8868			 
8868			 
8868			storage_append: 
8868				; hl -  file id to append to 
8868				; de - string to append 
8868			 
8868 d5				push de 
8869				 
8869				if DEBUG_STORESE 
8869					DMARK "AP1" 
8869 f5				push af  
886a 3a 7e 88			ld a, (.dmark)  
886d 32 6b ee			ld (debug_mark),a  
8870 3a 7f 88			ld a, (.dmark+1)  
8873 32 6c ee			ld (debug_mark+1),a  
8876 3a 80 88			ld a, (.dmark+2)  
8879 32 6d ee			ld (debug_mark+2),a  
887c 18 03			jr .pastdmark  
887e ..			.dmark: db "AP1"  
8881 f1			.pastdmark: pop af  
8882			endm  
# End of macro DMARK
8882					CALLMONITOR 
8882 cd 6f ee			call debug_vector  
8885				endm  
# End of macro CALLMONITOR
8885				endif 
8885			 
8885 7d				ld a, l 
8886 32 6e ea			ld (store_tmpid), a 
8889			 
8889				; get file header  
8889			 
8889 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
888b 3a 6e ea			ld a, (store_tmpid) 
888e 5f				ld e, a 
888f			 
888f 21 40 00				ld hl, STORE_BLOCK_PHY 
8892 cd ab 84				call storage_findnextid 
8895			 
8895 cd 04 8d			call ishlzero 
8898 28 cc			jr z, .sa_notfound 
889a			 
889a 22 65 ea			ld (store_tmppageid), hl 
889d			 
889d				; TODO handle file id not found 
889d			 
889d				if DEBUG_STORESE 
889d					DMARK "AP2" 
889d f5				push af  
889e 3a b2 88			ld a, (.dmark)  
88a1 32 6b ee			ld (debug_mark),a  
88a4 3a b3 88			ld a, (.dmark+1)  
88a7 32 6c ee			ld (debug_mark+1),a  
88aa 3a b4 88			ld a, (.dmark+2)  
88ad 32 6d ee			ld (debug_mark+2),a  
88b0 18 03			jr .pastdmark  
88b2 ..			.dmark: db "AP2"  
88b5 f1			.pastdmark: pop af  
88b6			endm  
# End of macro DMARK
88b6					CALLMONITOR 
88b6 cd 6f ee			call debug_vector  
88b9				endm  
# End of macro CALLMONITOR
88b9				endif 
88b9			 
88b9				; update file extent count 
88b9			 
88b9 11 7a ea			ld de, store_page 
88bc			 
88bc cd 78 81			call storage_read_block 
88bf			 
88bf				if DEBUG_STORESE 
88bf					DMARK "AP3" 
88bf f5				push af  
88c0 3a d4 88			ld a, (.dmark)  
88c3 32 6b ee			ld (debug_mark),a  
88c6 3a d5 88			ld a, (.dmark+1)  
88c9 32 6c ee			ld (debug_mark+1),a  
88cc 3a d6 88			ld a, (.dmark+2)  
88cf 32 6d ee			ld (debug_mark+2),a  
88d2 18 03			jr .pastdmark  
88d4 ..			.dmark: db "AP3"  
88d7 f1			.pastdmark: pop af  
88d8			endm  
# End of macro DMARK
88d8					CALLMONITOR 
88d8 cd 6f ee			call debug_vector  
88db				endm  
# End of macro CALLMONITOR
88db				endif 
88db			;	ld (store_tmppageid), hl 
88db			 
88db 3a 7c ea			ld a, (store_page+2) 
88de 3c				inc a 
88df 32 7c ea			ld (store_page+2), a 
88e2 32 6d ea			ld (store_tmpext), a 
88e5				 
88e5				if DEBUG_STORESE 
88e5					DMARK "AP3" 
88e5 f5				push af  
88e6 3a fa 88			ld a, (.dmark)  
88e9 32 6b ee			ld (debug_mark),a  
88ec 3a fb 88			ld a, (.dmark+1)  
88ef 32 6c ee			ld (debug_mark+1),a  
88f2 3a fc 88			ld a, (.dmark+2)  
88f5 32 6d ee			ld (debug_mark+2),a  
88f8 18 03			jr .pastdmark  
88fa ..			.dmark: db "AP3"  
88fd f1			.pastdmark: pop af  
88fe			endm  
# End of macro DMARK
88fe					CALLMONITOR 
88fe cd 6f ee			call debug_vector  
8901				endm  
# End of macro CALLMONITOR
8901				endif 
8901 2a 65 ea			ld hl, (store_tmppageid) 
8904 11 7a ea			ld de, store_page 
8907 cd dd 81			call storage_write_block 
890a			 
890a				; find free block 
890a			 
890a 11 00 00			ld de, 0			 ; file extent to locate 
890d			 
890d 21 40 00				ld hl, STORE_BLOCK_PHY 
8910 cd ab 84				call storage_findnextid 
8913 cd 04 8d			call ishlzero 
8916 ca 66 88			jp z, .sa_notfound 
8919			 
8919					; TODO handle no space left 
8919					 
8919 22 65 ea				ld (store_tmppageid), hl 
891c			 
891c				if DEBUG_STORESE 
891c					DMARK "AP4" 
891c f5				push af  
891d 3a 31 89			ld a, (.dmark)  
8920 32 6b ee			ld (debug_mark),a  
8923 3a 32 89			ld a, (.dmark+1)  
8926 32 6c ee			ld (debug_mark+1),a  
8929 3a 33 89			ld a, (.dmark+2)  
892c 32 6d ee			ld (debug_mark+2),a  
892f 18 03			jr .pastdmark  
8931 ..			.dmark: db "AP4"  
8934 f1			.pastdmark: pop af  
8935			endm  
# End of macro DMARK
8935					CALLMONITOR 
8935 cd 6f ee			call debug_vector  
8938				endm  
# End of macro CALLMONITOR
8938				endif 
8938					; init the buffer with zeros so we can id if the buffer is full or not 
8938			 
8938 e5					push hl 
8939 c5					push bc 
893a			 
893a 21 7a ea				ld hl, store_page 
893d 06 40				ld b, STORE_BLOCK_PHY 
893f 3e 00				ld a, 0 
8941 77			.zeroblock:	ld (hl), a 
8942 23					inc hl 
8943 10 fc				djnz .zeroblock 
8945			 
8945 c1					pop bc 
8946 e1					pop hl 
8947			 
8947					; construct block 
8947			 
8947 3a 6e ea				ld a, (store_tmpid) 
894a 32 7a ea				ld (store_page), a   ; file id 
894d 3a 6d ea				ld a, (store_tmpext)   ; extent for this block 
8950 32 7b ea				ld (store_page+1), a 
8953			 
8953 e1					pop hl    ; get string to write 
8954 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
8956 11 7c ea				ld de, store_page+2 
8959			 
8959				if DEBUG_STORESE 
8959					DMARK "AP5" 
8959 f5				push af  
895a 3a 6e 89			ld a, (.dmark)  
895d 32 6b ee			ld (debug_mark),a  
8960 3a 6f 89			ld a, (.dmark+1)  
8963 32 6c ee			ld (debug_mark+1),a  
8966 3a 70 89			ld a, (.dmark+2)  
8969 32 6d ee			ld (debug_mark+2),a  
896c 18 03			jr .pastdmark  
896e ..			.dmark: db "AP5"  
8971 f1			.pastdmark: pop af  
8972			endm  
# End of macro DMARK
8972					CALLMONITOR 
8972 cd 6f ee			call debug_vector  
8975				endm  
# End of macro CALLMONITOR
8975				endif 
8975			 
8975			 
8975			 
8975					; fill buffer with data until end of string or full block 
8975			 
8975 7e			.appd:		ld a, (hl) 
8976 12					ld (de), a 
8977 fe 00				cp 0 
8979 28 04				jr z, .appdone 
897b 23					inc hl 
897c 13					inc de 
897d 10 f6				djnz .appd 
897f			 
897f e5			.appdone:	push hl		 	; save current source in case we need to go around again 
8980 f5					push af   		; save last byte dumped 
8981			 
8981			 
8981 2a 65 ea			ld hl, (store_tmppageid) 
8984 11 7a ea			ld de, store_page 
8987				if DEBUG_STORESE 
8987					DMARK "AP6" 
8987 f5				push af  
8988 3a 9c 89			ld a, (.dmark)  
898b 32 6b ee			ld (debug_mark),a  
898e 3a 9d 89			ld a, (.dmark+1)  
8991 32 6c ee			ld (debug_mark+1),a  
8994 3a 9e 89			ld a, (.dmark+2)  
8997 32 6d ee			ld (debug_mark+2),a  
899a 18 03			jr .pastdmark  
899c ..			.dmark: db "AP6"  
899f f1			.pastdmark: pop af  
89a0			endm  
# End of macro DMARK
89a0					CALLMONITOR 
89a0 cd 6f ee			call debug_vector  
89a3				endm  
# End of macro CALLMONITOR
89a3				endif 
89a3 cd dd 81				call storage_write_block 
89a6			 
89a6			 
89a6				; was that a full block of data written? 
89a6				; any more to write out? 
89a6			 
89a6				; if yes then set vars and jump to start of function again 
89a6			 
89a6 f1					pop af 
89a7 d1					pop de 
89a8			 
89a8 fe 00				cp 0		 ; no, string was fully written 
89aa c8					ret z 
89ab			 
89ab					; setup vars for next cycle 
89ab			 
89ab 3a 6e ea				ld a, (store_tmpid) 
89ae 6f					ld l, a 
89af 26 00				ld h, 0 
89b1			 
89b1 c3 68 88			 	jp storage_append	 ; yes, need to write out some more 
89b4			 
89b4			 
89b4			 
89b4			 
89b4			 
89b4			 
89b4			 
89b4			if DEBUG_STORECF 
89b4			storageput:	 
89b4					ret 
89b4			storageread: 
89b4					ld hl, store_page 
89b4					ld b, 200 
89b4					ld a,0 
89b4			.src:		ld (hl),a 
89b4					inc hl 
89b4					djnz .src 
89b4					 
89b4			 
89b4					ld de, 0 
89b4					ld bc, 1 
89b4					ld hl, store_page 
89b4					call cfRead 
89b4			 
89b4				call cfGetError 
89b4				ld hl,scratch 
89b4				call hexout 
89b4				ld hl, scratch+2 
89b4				ld a, 0 
89b4				ld (hl),a 
89b4				ld de, scratch 
89b4				ld a,display_row_1 
89b4				call str_at_display 
89b4				call update_display 
89b4			 
89b4					ld hl, store_page 
89b4					ld (os_cur_ptr),hl 
89b4			 
89b4					ret 
89b4			endif 
89b4			 
89b4			 
89b4			; Clear out the main buffer store (used to remove junk before writing a new block) 
89b4			 
89b4			storage_clear_page: 
89b4 e5				push hl 
89b5 d5				push de 
89b6 c5				push bc 
89b7 21 7a ea			ld hl, store_page 
89ba 3e 00			ld a, 0 
89bc 77				ld (hl), a 
89bd			 
89bd 11 7b ea			ld de, store_page+1 
89c0 01 19 01			ld bc, STORE_BLOCK_LOG+1 
89c3			 
89c3 ed b0			ldir 
89c5				 
89c5 c1				pop bc 
89c6 d1				pop de 
89c7 e1				pop hl 
89c8 c9				ret 
89c9			 
89c9			; eof 
# End of file firmware_storage.asm
89c9			  
89c9			; support routines for above hardware abstraction layer  
89c9			  
89c9			include "firmware_general.asm"        ; general support functions  
89c9			 
89c9			; word look up 
89c9			 
89c9			; in 
89c9			; a is the index 
89c9			; hl is pointer start of array 
89c9			; 
89c9			; returns 
89c9			; hl to the word 
89c9			; 
89c9			 
89c9			table_lookup:  
89c9 d5					push de 
89ca eb					ex de, hl 
89cb			 
89cb 6f					ld l, a 
89cc 26 00				ld h, 0 
89ce 29					add hl, hl 
89cf 19					add hl, de 
89d0 7e					ld a, (hl) 
89d1 23					inc hl 
89d2 66					ld h,(hl) 
89d3 6f					ld l, a 
89d4			 
89d4 d1					pop de 
89d5 c9					ret 
89d6			 
89d6			; Delay loops 
89d6			 
89d6			 
89d6			 
89d6			aDelayInMS: 
89d6 c5				push bc 
89d7 47				ld b,a 
89d8			msdelay: 
89d8 c5				push bc 
89d9				 
89d9			 
89d9 01 41 00			ld bc,041h 
89dc cd f4 89			call delayloop 
89df c1				pop bc 
89e0 05				dec b 
89e1 20 f5			jr nz,msdelay 
89e3			 
89e3			;if CPU_CLOCK_8MHZ 
89e3			;msdelay8: 
89e3			;	push bc 
89e3			;	 
89e3			; 
89e3			;	ld bc,041h 
89e3			;	call delayloop 
89e3			;	pop bc 
89e3			;	dec b 
89e3			;	jr nz,msdelay8 
89e3			;endif 
89e3			 
89e3			 
89e3 c1				pop bc 
89e4 c9				ret 
89e5			 
89e5			 
89e5			delay250ms: 
89e5				;push de 
89e5 01 00 40			ld bc, 04000h 
89e8 c3 f4 89			jp delayloop 
89eb			delay500ms: 
89eb				;push de 
89eb 01 00 80			ld bc, 08000h 
89ee c3 f4 89			jp delayloop 
89f1			delay1s: 
89f1				;push bc 
89f1			   ; Clobbers A, d and e 
89f1 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
89f4			delayloop: 
89f4 c5			    push bc 
89f5			 
89f5			if BASE_CPM 
89f5				ld bc, CPM_DELAY_TUNE 
89f5			.cpmloop: 
89f5				push bc 
89f5			 
89f5			endif 
89f5			 
89f5			 
89f5			 
89f5			delayloopi: 
89f5			;	push bc 
89f5			;.dl: 
89f5 cb 47		    bit     0,a    	; 8 
89f7 cb 47		    bit     0,a    	; 8 
89f9 cb 47		    bit     0,a    	; 8 
89fb e6 ff		    and     255  	; 7 
89fd 0b			    dec     bc      	; 6 
89fe 79			    ld      a,c     	; 4 
89ff b0			    or      b     	; 4 
8a00 c2 f5 89		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
8a03			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
8a03				;pop de 
8a03			;pop bc 
8a03			 
8a03			if BASE_CPM 
8a03				pop bc 
8a03				 
8a03			    dec     bc      	; 6 
8a03			    ld      a,c     	; 4 
8a03			    or      b     	; 4 
8a03			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
8a03				 
8a03			 
8a03			endif 
8a03			;if CPU_CLOCK_8MHZ 
8a03			;    pop bc 
8a03			;    push bc 
8a03			;.dl8: 
8a03			;    bit     0,a    	; 8 
8a03			;    bit     0,a    	; 8 
8a03			;    bit     0,a    	; 8 
8a03			;    and     255  	; 7 
8a03			;    dec     bc      	; 6 
8a03			;    ld      a,c     	; 4 
8a03			;    or      b     	; 4 
8a03			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8a03			;endif 
8a03			 
8a03			;if CPU_CLOCK_10MHZ 
8a03			;    pop bc 
8a03			;    push bc 
8a03			;.dl8: 
8a03			;    bit     0,a    	; 8 
8a03			;    bit     0,a    	; 8 
8a03			;    bit     0,a    	; 8 
8a03			;    and     255  	; 7 
8a03			;    dec     bc      	; 6 
8a03			;    ld      a,c     	; 4 
8a03			;    or      b     	; 4 
8a03			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8a03			;endif 
8a03 c1			    pop bc 
8a04			 
8a04 c9				ret 
8a05			 
8a05			 
8a05			 
8a05			; eof 
# End of file firmware_general.asm
8a05			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
8a05			; display routines that use the physical hardware abstraction layer 
8a05			 
8a05			 
8a05			; Display an activity indicator 
8a05			; Each call returns the new char pointed to in hl 
8a05			 
8a05			active: 
8a05 3a c6 eb			ld a, (display_active) 
8a08 fe 06			cp 6 
8a0a			 
8a0a 20 02			jr nz, .sne 
8a0c				; gone past the last one reset sequence 
8a0c 3e ff			ld a, 255 
8a0e			 
8a0e			.sne:   
8a0e				; get the next char in seq 
8a0e 3c				inc a 
8a0f 32 c6 eb			ld (display_active), a 
8a12			 
8a12				; look up the string in the table 
8a12 21 29 8a			ld hl, actseq 
8a15 cb 27			sla a 
8a17 cd db 8c			call addatohl 
8a1a cd d5 9f			call loadwordinhl 
8a1d			 
8a1d				; forth will write the to string when pushing so move from rom to ram 
8a1d			 
8a1d 11 c7 eb			ld de, display_active+1 
8a20 01 02 00			ld bc, 2 
8a23 ed b0			ldir 
8a25			 
8a25 21 c7 eb			ld hl, display_active+1 
8a28 c9				ret 
8a29				 
8a29				 
8a29			 
8a29			 
8a29			;db "|/-\|-\" 
8a29			 
8a29			actseq: 
8a29			 
8a29 37 8a		dw spin0 
8a2b 39 8a		dw spin1 
8a2d 3b 8a		dw spin2 
8a2f 3d 8a		dw spin3 
8a31 3b 8a		dw spin2 
8a33 39 8a		dw spin1 
8a35 37 8a		dw spin0 
8a37			 
8a37 .. 00		spin0: db " ", 0 
8a39 .. 00		spin1: db "-", 0 
8a3b .. 00		spin2: db "+", 0 
8a3d .. 00		spin3: db "#", 0 
8a3f			 
8a3f			 
8a3f			; information window 
8a3f			 
8a3f			; pass hl with 1st string to display 
8a3f			; pass de with 2nd string to display 
8a3f			 
8a3f			info_panel: 
8a3f e5				push hl 
8a40			 
8a40 2a cc eb			ld hl, (display_fb_active) 
8a43 e5				push hl    ; future de destination 
8a44 21 b1 ed				ld hl, display_fb0 
8a47 22 cc eb				ld (display_fb_active), hl 
8a4a			 
8a4a			;	call clear_display 
8a4a			 
8a4a				if BASE_CPM 
8a4a				ld a, '.' 
8a4a				else 
8a4a 3e a5			ld a, 165 
8a4c				endif 
8a4c cd b3 8a			call fill_display 
8a4f			 
8a4f			 
8a4f 3e 55			ld a, display_row_3 + 5 
8a51 cd c1 8a			call str_at_display 
8a54			 
8a54 e1				pop hl 
8a55 d1				pop de 
8a56			 
8a56 e5				push hl 
8a57			 
8a57			 
8a57 3e 2d			ld a, display_row_2 + 5 
8a59 cd c1 8a			call str_at_display 
8a5c			 
8a5c			 
8a5c cd d1 8a			call update_display 
8a5f cd 1e 9c			call next_page_prompt 
8a62 cd ae 8a			call clear_display 
8a65			 
8a65				 
8a65 21 10 ed				ld hl, display_fb1 
8a68 22 cc eb				ld (display_fb_active), hl 
8a6b cd d1 8a			call update_display 
8a6e			 
8a6e e1				pop hl 
8a6f			 
8a6f c9				ret 
8a70			 
8a70			 
8a70			 
8a70			 
8a70			; TODO windowing? 
8a70			 
8a70			; TODO scroll line up 
8a70			 
8a70			scroll_up: 
8a70			 
8a70 e5				push hl 
8a71 d5				push de 
8a72 c5				push bc 
8a73			 
8a73				; get frame buffer  
8a73			 
8a73 2a cc eb			ld hl, (display_fb_active) 
8a76 e5				push hl    ; future de destination 
8a77			 
8a77 11 28 00			ld  de, display_cols 
8a7a 19				add hl, de 
8a7b			 
8a7b d1				pop de 
8a7c			 
8a7c				;ex de, hl 
8a7c 01 9f 00			ld bc, display_fb_len -1  
8a7f			;if DEBUG_FORTH_WORDS 
8a7f			;	DMARK "SCL" 
8a7f			;	CALLMONITOR 
8a7f			;endif	 
8a7f ed b0			ldir 
8a81			 
8a81				; wipe bottom row 
8a81			 
8a81			 
8a81 2a cc eb			ld hl, (display_fb_active) 
8a84 11 a0 00			ld de, display_cols*display_rows 
8a87 19				add hl, de 
8a88 06 28			ld b, display_cols 
8a8a 3e 20			ld a, ' ' 
8a8c			.scwipe: 
8a8c 77				ld (hl), a 
8a8d 2b				dec hl 
8a8e 10 fc			djnz .scwipe 
8a90			 
8a90				;pop hl 
8a90			 
8a90 c1				pop bc 
8a91 d1				pop de 
8a92 e1				pop hl 
8a93			 
8a93 c9				ret 
8a94			 
8a94			 
8a94			;scroll_upo: 
8a94			;	ld de, display_row_1 
8a94			 ;	ld hl, display_row_2 
8a94			;	ld bc, display_cols 
8a94			;	ldir 
8a94			;	ld de, display_row_2 
8a94			 ;	ld hl, display_row_3 
8a94			;	ld bc, display_cols 
8a94			;	ldir 
8a94			;	ld de, display_row_3 
8a94			 ;	ld hl, display_row_4 
8a94			;	ld bc, display_cols 
8a94			;	ldir 
8a94			 
8a94			; TODO clear row 4 
8a94			 
8a94			;	ret 
8a94			 
8a94				 
8a94			scroll_down: 
8a94			 
8a94 e5				push hl 
8a95 d5				push de 
8a96 c5				push bc 
8a97			 
8a97				; get frame buffer  
8a97			 
8a97 2a cc eb			ld hl, (display_fb_active) 
8a9a			 
8a9a 11 9f 00			ld de, display_fb_len - 1 
8a9d 19				add hl, de 
8a9e			 
8a9e e5			push hl    ; future de destination 
8a9f			 
8a9f 11 28 00			ld  de, display_cols 
8aa2 ed 52			sbc hl, de 
8aa4			 
8aa4			 
8aa4 d1				pop de 
8aa5			 
8aa5			;	ex de, hl 
8aa5 01 9f 00			ld bc, display_fb_len -1  
8aa8			 
8aa8			 
8aa8				 
8aa8			 
8aa8 ed b0			ldir 
8aaa			 
8aaa				; wipe bottom row 
8aaa			 
8aaa			 
8aaa			;	ld hl, (display_fb_active) 
8aaa			;;	ld de, display_cols*display_rows 
8aaa			;;	add hl, de 
8aaa			;	ld b, display_cols 
8aaa			;	ld a, ' ' 
8aaa			;.scwiped: 
8aaa			;	ld (hl), a 
8aaa			;	dec hl 
8aaa			;	djnz .scwiped 
8aaa			 
8aaa				;pop hl 
8aaa			 
8aaa c1				pop bc 
8aab d1				pop de 
8aac e1				pop hl 
8aad			 
8aad c9				ret 
8aae			;scroll_down: 
8aae			;	ld de, display_row_4 
8aae			;	ld hl, display_row_3 
8aae			;	ld bc, display_cols 
8aae			;	ldir 
8aae			;	ld de, display_row_3 
8aae			; 	ld hl, display_row_2 
8aae			;	ld bc, display_cols 
8aae			;	ldir 
8aae			;	ld de, display_row_2 
8aae			;	ld hl, display_row_1 
8aae			;	ld bc, display_cols 
8aae			;	ldir 
8aae			;;; TODO clear row 1 
8aae			;	ret 
8aae			 
8aae			 
8aae			 
8aae			 
8aae			 
8aae			; clear active frame buffer 
8aae			 
8aae			clear_display: 
8aae 3e 20			ld a, ' ' 
8ab0 c3 b3 8a			jp fill_display 
8ab3			 
8ab3			; fill active frame buffer with a char in A 
8ab3			 
8ab3			fill_display: 
8ab3 06 a0			ld b,display_fb_len 
8ab5 2a cc eb			ld hl, (display_fb_active) 
8ab8 77			.fd1:	ld (hl),a 
8ab9 23				inc hl 
8aba 10 fc			djnz .fd1 
8abc 23				inc hl 
8abd 3e 00			ld a,0 
8abf 77				ld (hl),a 
8ac0			 
8ac0			 
8ac0 c9				ret 
8ac1			; Write string (DE) at pos (A) to active frame buffer 
8ac1			 
8ac1 2a cc eb		str_at_display:    ld hl,(display_fb_active) 
8ac4 06 00					ld b,0 
8ac6 4f					ld c,a 
8ac7 09					add hl,bc 
8ac8 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
8ac9 b7			            OR   A              ;Null terminator? 
8aca c8			            RET  Z              ;Yes, so finished 
8acb 77					ld (hl),a 
8acc 23				inc hl 
8acd 13			            INC  DE             ;Point to next character 
8ace 18 f8		            JR   .sad1     ;Repeat 
8ad0 c9					ret 
8ad1			 
8ad1			; using current frame buffer write to physical display 
8ad1			 
8ad1			update_display: 
8ad1 e5				push hl 
8ad2 2a cc eb			ld hl, (display_fb_active) 
8ad5 cd a2 e5			call write_display 
8ad8 e1				pop hl 
8ad9 c9				ret 
8ada			 
8ada			; TODO scrolling 
8ada			 
8ada			 
8ada			; move cursor right one char 
8ada			cursor_right: 
8ada			 
8ada				; TODO shift right 
8ada				; TODO if beyond max col 
8ada				; TODO       cursor_next_line 
8ada			 
8ada c9				ret 
8adb			 
8adb			 
8adb			cursor_next_line: 
8adb				; TODO first char 
8adb				; TODO line down 
8adb				; TODO if past last row 
8adb				; TODO    scroll up 
8adb			 
8adb c9				ret 
8adc			 
8adc			cursor_left: 
8adc				; TODO shift left 
8adc				; TODO if beyond left  
8adc				; TODO     cursor prev line 
8adc				 
8adc c9				ret 
8add			 
8add			cursor_prev_line: 
8add				; TODO last char 
8add				; TODO line up 
8add				; TODO if past first row 
8add				; TODO   scroll down 
8add			 
8add c9				ret 
8ade			 
8ade			 
8ade			cout: 
8ade				; A - char 
8ade c9				ret 
8adf			 
8adf			 
8adf			; Display a menu and allow item selection (optional toggle items) 
8adf			; 
8adf			; format: 
8adf			; hl pointer to word array with zero term for items 
8adf			; e.g.    db item1 
8adf			;         db .... 
8adf			;         db 0 
8adf			; 
8adf			; a = starting menu item  
8adf			; 
8adf			; de = pointer item toggle array   (todo) 
8adf			; 
8adf			; returns item selected in a 1-... 
8adf			; returns 0 if back button pressed 
8adf			; 
8adf			; NOTE: Uses system frame buffer to display 
8adf			; 
8adf			; LEFT, Q = go back 
8adf			; RIGHT, SPACE, CR = select 
8adf			; UP, A - Up 
8adf			; DOWN, Z - Down 
8adf			 
8adf			 
8adf			 
8adf			 
8adf			 
8adf			menu: 
8adf			 
8adf					; keep array pointer 
8adf			 
8adf 22 73 ea				ld (store_tmp1), hl 
8ae2 32 71 ea				ld (store_tmp2), a 
8ae5			 
8ae5					; check for key bounce 
8ae5			 
8ae5			if BASE_KEV 
8ae5			 
8ae5			.mbounce:	call cin 
8ae5					cp 0 
8ae5					jr nz, .mbounce 
8ae5			endif 
8ae5					; for ease use ex 
8ae5			 
8ae5					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
8ae5 21 b1 ed				ld hl, display_fb0 
8ae8 22 cc eb				ld (display_fb_active), hl 
8aeb			 
8aeb cd ae 8a		.mloop:		call clear_display 
8aee cd d1 8a				call update_display 
8af1			 
8af1					; draw selection id '>' at 1 
8af1			 
8af1					; init start of list display 
8af1			 
8af1 3e 05				ld a, 5 
8af3 32 6f ea				ld (store_tmp3), a   ; display row count 
8af6 3a 71 ea				ld a,( store_tmp2) 
8af9 32 72 ea				ld (store_tmp2+1), a   ; display item count 
8afc			 
8afc					 
8afc			.mitem:	 
8afc			 
8afc			 
8afc 3a 72 ea				ld a,(store_tmp2+1) 
8aff 6f					ld l, a 
8b00 26 00				ld h, 0 
8b02 29					add hl, hl 
8b03 ed 5b 73 ea			ld de, (store_tmp1) 
8b07 19					add hl, de 
8b08 7e					ld a, (hl) 
8b09 23					inc hl 
8b0a 66					ld h,(hl) 
8b0b 6f					ld l, a 
8b0c			 
8b0c cd 04 8d				call ishlzero 
8b0f 28 1a				jr z, .mdone 
8b11			 
8b11 eb					ex de, hl 
8b12 3a 6f ea				ld a, (store_tmp3) 
8b15 cd c1 8a				call str_at_display 
8b18					 
8b18			 
8b18					; next item 
8b18 3a 72 ea				ld a, (store_tmp2+1) 
8b1b 3c					inc a 
8b1c 32 72 ea				ld (store_tmp2+1), a   ; display item count 
8b1f			 
8b1f			 		; next row 
8b1f			 
8b1f 3a 6f ea				ld a, (store_tmp3) 
8b22 c6 28				add display_cols 
8b24 32 6f ea				ld (store_tmp3), a 
8b27			 
8b27					; at end of screen? 
8b27			 
8b27 fe 10				cp display_rows*4 
8b29 20 d1				jr nz, .mitem 
8b2b			 
8b2b			 
8b2b			.mdone: 
8b2b cd 04 8d				call ishlzero 
8b2e 28 08				jr z, .nodn 
8b30			 
8b30 3e 78				ld a, display_row_4 
8b32 11 b1 8b				ld de, .mdown 
8b35 cd c1 8a				call str_at_display 
8b38			 
8b38					; draw options to fill the screens with active item on line 1 
8b38					; if current option is 2 or more then display ^ in top 
8b38			 
8b38 3a 71 ea		.nodn:		ld a, (store_tmp2) 
8b3b fe 00				cp 0 
8b3d 28 08				jr z, .noup 
8b3f			 
8b3f 3e 00				ld a, 0 
8b41 11 af 8b				ld de, .mup 
8b44 cd c1 8a				call str_at_display 
8b47			 
8b47 3e 02		.noup:		ld a, 2 
8b49 11 ad 8b				ld de, .msel 
8b4c cd c1 8a				call str_at_display 
8b4f			 
8b4f					; if current option + 1 is not null then display V in bottom 
8b4f					; get key 
8b4f cd d1 8a				call update_display 
8b52			 
8b52			 
8b52					; handle key 
8b52			 
8b52 cd 2e e6				call cin_wait 
8b55			 
8b55 fe 05				cp KEY_UP 
8b57 28 2b				jr z, .mgoup 
8b59 fe 61				cp 'a' 
8b5b 28 27				jr z, .mgoup 
8b5d fe 0a				cp KEY_DOWN 
8b5f 28 32				jr z, .mgod 
8b61 fe 7a				cp 'z' 
8b63 28 2e				jr z, .mgod 
8b65 fe 20				cp ' ' 
8b67 28 34				jr z, .goend 
8b69 fe 0c				cp KEY_RIGHT 
8b6b 28 30				jr z, .goend 
8b6d fe 0d				cp KEY_CR 
8b6f 28 2c				jr z, .goend 
8b71 fe 71				cp 'q' 
8b73 28 0b				jr z, .goback 
8b75			 
8b75 fe 0b				cp KEY_LEFT 
8b77 28 07				jr z, .goback 
8b79 fe 08				cp KEY_BS 
8b7b 28 03				jr z, .goback 
8b7d c3 eb 8a				jp .mloop 
8b80			 
8b80			.goback: 
8b80 3e 00			ld a, 0 
8b82 18 1d			jr .goend2 
8b84			 
8b84				; move up one 
8b84			.mgoup: 
8b84 3a 71 ea				ld a, (store_tmp2) 
8b87 fe 00				cp 0 
8b89 ca eb 8a				jp z, .mloop 
8b8c 3d					dec a 
8b8d 32 71 ea				ld (store_tmp2), a 
8b90 c3 eb 8a				jp .mloop 
8b93			 
8b93				; move down one 
8b93			.mgod: 
8b93 3a 71 ea				ld a, (store_tmp2) 
8b96 3c					inc a 
8b97 32 71 ea				ld (store_tmp2), a 
8b9a c3 eb 8a				jp .mloop 
8b9d			 
8b9d			 
8b9d			.goend: 
8b9d					; get selected item number 
8b9d			 
8b9d 3a 71 ea				ld a, (store_tmp2) 
8ba0 3c					inc a 
8ba1			 
8ba1			.goend2: 
8ba1 f5					push af 
8ba2			 
8ba2					; restore active fb 
8ba2					; TODO BUG assumes fb1 
8ba2			 
8ba2 21 10 ed				ld hl, display_fb1 
8ba5 22 cc eb				ld (display_fb_active), hl 
8ba8			 
8ba8					; restore main regs 
8ba8			 
8ba8			 
8ba8 cd d1 8a				call update_display 
8bab			 
8bab f1					pop af 
8bac			 
8bac c9				ret 
8bad			 
8bad .. 00		.msel:   db ">",0 
8baf .. 00		.mup:   db "^",0 
8bb1 .. 00		.mdown:   db "v",0 
8bb3			 
8bb3			 
8bb3			; eof 
8bb3			 
# End of file firmware_display.asm
8bb3			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
8bb3			; random number generators 
8bb3			 
8bb3			 
8bb3			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
8bb3			 
8bb3			 
8bb3			;-----> Generate a random number 
8bb3			; output a=answer 0<=a<=255 
8bb3			; all registers are preserved except: af 
8bb3			random: 
8bb3 e5			        push    hl 
8bb4 d5			        push    de 
8bb5 2a ab eb		        ld      hl,(randData) 
8bb8 ed 5f		        ld      a,r 
8bba 57			        ld      d,a 
8bbb 5e			        ld      e,(hl) 
8bbc 19			        add     hl,de 
8bbd 85			        add     a,l 
8bbe ac			        xor     h 
8bbf 22 ab eb		        ld      (randData),hl 
8bc2 d1			        pop     de 
8bc3 e1			        pop     hl 
8bc4 c9			        ret 
8bc5			 
8bc5			 
8bc5			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
8bc5			 
8bc5			 
8bc5			 
8bc5			;------LFSR------ 
8bc5			;James Montelongo 
8bc5			;optimized by Spencer Putt 
8bc5			;out: 
8bc5			; a = 8 bit random number 
8bc5			RandLFSR: 
8bc5 21 b1 eb		        ld hl,LFSRSeed+4 
8bc8 5e			        ld e,(hl) 
8bc9 23			        inc hl 
8bca 56			        ld d,(hl) 
8bcb 23			        inc hl 
8bcc 4e			        ld c,(hl) 
8bcd 23			        inc hl 
8bce 7e			        ld a,(hl) 
8bcf 47			        ld b,a 
8bd0 cb 13		        rl e  
8bd2 cb 12			rl d 
8bd4 cb 11		        rl c  
8bd6 17				rla 
8bd7 cb 13		        rl e  
8bd9 cb 12			rl d 
8bdb cb 11		        rl c  
8bdd 17				rla 
8bde cb 13		        rl e  
8be0 cb 12			rl d 
8be2 cb 11		        rl c  
8be4 17				rla 
8be5 67			        ld h,a 
8be6 cb 13		        rl e  
8be8 cb 12			rl d 
8bea cb 11		        rl c  
8bec 17				rla 
8bed a8			        xor b 
8bee cb 13		        rl e  
8bf0 cb 12			rl d 
8bf2 ac			        xor h 
8bf3 a9			        xor c 
8bf4 aa			        xor d 
8bf5 21 b3 eb		        ld hl,LFSRSeed+6 
8bf8 11 b4 eb		        ld de,LFSRSeed+7 
8bfb 01 07 00		        ld bc,7 
8bfe ed b8		        lddr 
8c00 12			        ld (de),a 
8c01 c9			        ret 
8c02			 
8c02			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
8c02			 
8c02			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
8c02			 
8c02			 
8c02			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
8c02			 
8c02			prng16: 
8c02			;Inputs: 
8c02			;   (seed1) contains a 16-bit seed value 
8c02			;   (seed2) contains a NON-ZERO 16-bit seed value 
8c02			;Outputs: 
8c02			;   HL is the result 
8c02			;   BC is the result of the LCG, so not that great of quality 
8c02			;   DE is preserved 
8c02			;Destroys: 
8c02			;   AF 
8c02			;cycle: 4,294,901,760 (almost 4.3 billion) 
8c02			;160cc 
8c02			;26 bytes 
8c02 2a a5 eb		    ld hl,(seed1) 
8c05 44			    ld b,h 
8c06 4d			    ld c,l 
8c07 29			    add hl,hl 
8c08 29			    add hl,hl 
8c09 2c			    inc l 
8c0a 09			    add hl,bc 
8c0b 22 a5 eb		    ld (seed1),hl 
8c0e 2a a3 eb		    ld hl,(seed2) 
8c11 29			    add hl,hl 
8c12 9f			    sbc a,a 
8c13 e6 2d		    and %00101101 
8c15 ad			    xor l 
8c16 6f			    ld l,a 
8c17 22 a3 eb		    ld (seed2),hl 
8c1a 09			    add hl,bc 
8c1b c9			    ret 
8c1c			 
8c1c			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
8c1c			 
8c1c			rand32: 
8c1c			;Inputs: 
8c1c			;   (seed1_0) holds the lower 16 bits of the first seed 
8c1c			;   (seed1_1) holds the upper 16 bits of the first seed 
8c1c			;   (seed2_0) holds the lower 16 bits of the second seed 
8c1c			;   (seed2_1) holds the upper 16 bits of the second seed 
8c1c			;   **NOTE: seed2 must be non-zero 
8c1c			;Outputs: 
8c1c			;   HL is the result 
8c1c			;   BC,DE can be used as lower quality values, but are not independent of HL. 
8c1c			;Destroys: 
8c1c			;   AF 
8c1c			;Tested and passes all CAcert tests 
8c1c			;Uses a very simple 32-bit LCG and 32-bit LFSR 
8c1c			;it has a period of 18,446,744,069,414,584,320 
8c1c			;roughly 18.4 quintillion. 
8c1c			;LFSR taps: 0,2,6,7  = 11000101 
8c1c			;291cc 
8c1c			;seed1_0=$+1 
8c1c			;    ld hl,12345 
8c1c			;seed1_1=$+1 
8c1c			;    ld de,6789 
8c1c			;    ld b,h 
8c1c			;    ld c,l 
8c1c			;    add hl,hl \ rl e \ rl d 
8c1c			;    add hl,hl \ rl e \ rl d 
8c1c			;    inc l 
8c1c			;    add hl,bc 
8c1c			;    ld (seed1_0),hl 
8c1c			;    ld hl,(seed1_1) 
8c1c			;    adc hl,de 
8c1c			;    ld (seed1_1),hl 
8c1c			;    ex de,hl 
8c1c			;seed2_0=$+1 
8c1c			;    ld hl,9876 
8c1c			;seed2_1=$+1 
8c1c			;    ld bc,54321 
8c1c			;    add hl,hl \ rl c \ rl b 
8c1c			;    ld (seed2_1),bc 
8c1c			;    sbc a,a 
8c1c			;    and %11000101 
8c1c			;    xor l 
8c1c			;    ld l,a 
8c1c			;    ld (seed2_0),hl 
8c1c			;    ex de,hl 
8c1c			;    add hl,bc 
8c1c			;    ret 
8c1c			; 
8c1c			 
8c1c			; 16-bit xorshift pseudorandom number generator by John Metcalf 
8c1c			; 20 bytes, 86 cycles (excluding ret) 
8c1c			 
8c1c			; returns   hl = pseudorandom number 
8c1c			; corrupts   a 
8c1c			 
8c1c			; generates 16-bit pseudorandom numbers with a period of 65535 
8c1c			; using the xorshift method: 
8c1c			 
8c1c			; hl ^= hl << 7 
8c1c			; hl ^= hl >> 9 
8c1c			; hl ^= hl << 8 
8c1c			 
8c1c			; some alternative shift triplets which also perform well are: 
8c1c			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
8c1c			 
8c1c			;  org 32768 
8c1c			 
8c1c			xrnd: 
8c1c 2a a9 eb		  ld hl,(xrandc)       ; seed must not be 0 
8c1f 3e 00		  ld a,0 
8c21 bd			  cp l 
8c22 20 02		  jr nz, .xrnd1 
8c24 2e 01		  ld l, 1 
8c26			.xrnd1: 
8c26			 
8c26 7c			  ld a,h 
8c27 1f			  rra 
8c28 7d			  ld a,l 
8c29 1f			  rra 
8c2a ac			  xor h 
8c2b 67			  ld h,a 
8c2c 7d			  ld a,l 
8c2d 1f			  rra 
8c2e 7c			  ld a,h 
8c2f 1f			  rra 
8c30 ad			  xor l 
8c31 6f			  ld l,a 
8c32 ac			  xor h 
8c33 67			  ld h,a 
8c34			 
8c34 22 a9 eb		  ld (xrandc),hl 
8c37			 
8c37 c9			  ret 
8c38			;  
8c38			 
8c38			 
8c38			;;;; int maths 
8c38			 
8c38			; https://map.grauw.nl/articles/mult_div_shifts.php 
8c38			; Divide 16-bit values (with 16-bit result) 
8c38			; In: Divide BC by divider DE 
8c38			; Out: BC = result, HL = rest 
8c38			; 
8c38			Div16: 
8c38 21 00 00		    ld hl,0 
8c3b 78			    ld a,b 
8c3c 06 08		    ld b,8 
8c3e			Div16_Loop1: 
8c3e 17			    rla 
8c3f ed 6a		    adc hl,hl 
8c41 ed 52		    sbc hl,de 
8c43 30 01		    jr nc,Div16_NoAdd1 
8c45 19			    add hl,de 
8c46			Div16_NoAdd1: 
8c46 10 f6		    djnz Div16_Loop1 
8c48 17			    rla 
8c49 2f			    cpl 
8c4a 47			    ld b,a 
8c4b 79			    ld a,c 
8c4c 48			    ld c,b 
8c4d 06 08		    ld b,8 
8c4f			Div16_Loop2: 
8c4f 17			    rla 
8c50 ed 6a		    adc hl,hl 
8c52 ed 52		    sbc hl,de 
8c54 30 01		    jr nc,Div16_NoAdd2 
8c56 19			    add hl,de 
8c57			Div16_NoAdd2: 
8c57 10 f6		    djnz Div16_Loop2 
8c59 17			    rla 
8c5a 2f			    cpl 
8c5b 41			    ld b,c 
8c5c 4f			    ld c,a 
8c5d c9			ret 
8c5e			 
8c5e			 
8c5e			;http://z80-heaven.wikidot.com/math 
8c5e			; 
8c5e			;Inputs: 
8c5e			;     DE and A are factors 
8c5e			;Outputs: 
8c5e			;     A is not changed 
8c5e			;     B is 0 
8c5e			;     C is not changed 
8c5e			;     DE is not changed 
8c5e			;     HL is the product 
8c5e			;Time: 
8c5e			;     342+6x 
8c5e			; 
8c5e			Mult16: 
8c5e			 
8c5e 06 08		     ld b,8          ;7           7 
8c60 21 00 00		     ld hl,0         ;10         10 
8c63 29			       add hl,hl     ;11*8       88 
8c64 07			       rlca          ;4*8        32 
8c65 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
8c67 19			         add hl,de   ;--         -- 
8c68 10 f9		       djnz $-5      ;13*7+8     99 
8c6a c9			ret 
8c6b			 
8c6b			; 
8c6b			; Square root of 16-bit value 
8c6b			; In:  HL = value 
8c6b			; Out:  D = result (rounded down) 
8c6b			; 
8c6b			;Sqr16: 
8c6b			;    ld de,#0040 
8c6b			;    ld a,l 
8c6b			;    ld l,h 
8c6b			;    ld h,d 
8c6b			;    or a 
8c6b			;    ld b,8 
8c6b			;Sqr16_Loop: 
8c6b			;    sbc hl,de 
8c6b			;    jr nc,Sqr16_Skip 
8c6b			;    add hl,de 
8c6b			;Sqr16_Skip: 
8c6b			;    ccf 
8c6b			;    rl d 
8c6b			;    add a,a 
8c6b			;    adc hl,hl 
8c6b			;    add a,a 
8c6b			;    adc hl,hl 
8c6b			;    djnz Sqr16_Loop 
8c6b			;    ret 
8c6b			; 
8c6b			; 
8c6b			; Divide 8-bit values 
8c6b			; In: Divide E by divider C 
8c6b			; Out: A = result, B = rest 
8c6b			; 
8c6b			Div8: 
8c6b af			    xor a 
8c6c 06 08		    ld b,8 
8c6e			Div8_Loop: 
8c6e cb 13		    rl e 
8c70 17			    rla 
8c71 91			    sub c 
8c72 30 01		    jr nc,Div8_NoAdd 
8c74 81			    add a,c 
8c75			Div8_NoAdd: 
8c75 10 f7		    djnz Div8_Loop 
8c77 47			    ld b,a 
8c78 7b			    ld a,e 
8c79 17			    rla 
8c7a 2f			    cpl 
8c7b c9			    ret 
8c7c			 
8c7c			; 
8c7c			; Multiply 8-bit value with a 16-bit value (unrolled) 
8c7c			; In: Multiply A with DE 
8c7c			; Out: HL = result 
8c7c			; 
8c7c			Mult12U: 
8c7c 2e 00		    ld l,0 
8c7e 87			    add a,a 
8c7f 30 01		    jr nc,Mult12U_NoAdd0 
8c81 19			    add hl,de 
8c82			Mult12U_NoAdd0: 
8c82 29			    add hl,hl 
8c83 87			    add a,a 
8c84 30 01		    jr nc,Mult12U_NoAdd1 
8c86 19			    add hl,de 
8c87			Mult12U_NoAdd1: 
8c87 29			    add hl,hl 
8c88 87			    add a,a 
8c89 30 01		    jr nc,Mult12U_NoAdd2 
8c8b 19			    add hl,de 
8c8c			Mult12U_NoAdd2: 
8c8c 29			    add hl,hl 
8c8d 87			    add a,a 
8c8e 30 01		    jr nc,Mult12U_NoAdd3 
8c90 19			    add hl,de 
8c91			Mult12U_NoAdd3: 
8c91 29			    add hl,hl 
8c92 87			    add a,a 
8c93 30 01		    jr nc,Mult12U_NoAdd4 
8c95 19			    add hl,de 
8c96			Mult12U_NoAdd4: 
8c96 29			    add hl,hl 
8c97 87			    add a,a 
8c98 30 01		    jr nc,Mult12U_NoAdd5 
8c9a 19			    add hl,de 
8c9b			Mult12U_NoAdd5: 
8c9b 29			    add hl,hl 
8c9c 87			    add a,a 
8c9d 30 01		    jr nc,Mult12U_NoAdd6 
8c9f 19			    add hl,de 
8ca0			Mult12U_NoAdd6: 
8ca0 29			    add hl,hl 
8ca1 87			    add a,a 
8ca2 d0			    ret nc 
8ca3 19			    add hl,de 
8ca4 c9			    ret 
8ca5			 
8ca5			; 
8ca5			; Multiply 8-bit value with a 16-bit value (right rotating) 
8ca5			; In: Multiply A with DE 
8ca5			;      Put lowest value in A for most efficient calculation 
8ca5			; Out: HL = result 
8ca5			; 
8ca5			Mult12R: 
8ca5 21 00 00		    ld hl,0 
8ca8			Mult12R_Loop: 
8ca8 cb 3f		    srl a 
8caa 30 01		    jr nc,Mult12R_NoAdd 
8cac 19			    add hl,de 
8cad			Mult12R_NoAdd: 
8cad cb 23		    sla e 
8caf cb 12		    rl d 
8cb1 b7			    or a 
8cb2 c2 a8 8c		    jp nz,Mult12R_Loop 
8cb5 c9			    ret 
8cb6			 
8cb6			; 
8cb6			; Multiply 16-bit values (with 32-bit result) 
8cb6			; In: Multiply BC with DE 
8cb6			; Out: BCHL = result 
8cb6			; 
8cb6			Mult32: 
8cb6 79			    ld a,c 
8cb7 48			    ld c,b 
8cb8 21 00 00		    ld hl,0 
8cbb 06 10		    ld b,16 
8cbd			Mult32_Loop: 
8cbd 29			    add hl,hl 
8cbe 17			    rla 
8cbf cb 11		    rl c 
8cc1 30 07		    jr nc,Mult32_NoAdd 
8cc3 19			    add hl,de 
8cc4 ce 00		    adc a,0 
8cc6 d2 ca 8c		    jp nc,Mult32_NoAdd 
8cc9 0c			    inc c 
8cca			Mult32_NoAdd: 
8cca 10 f1		    djnz Mult32_Loop 
8ccc 41			    ld b,c 
8ccd 4f			    ld c,a 
8cce c9			    ret 
8ccf			 
8ccf			 
8ccf			 
8ccf			; 
8ccf			; Multiply 8-bit values 
8ccf			; In:  Multiply H with E 
8ccf			; Out: HL = result 
8ccf			; 
8ccf			Mult8: 
8ccf 16 00		    ld d,0 
8cd1 6a			    ld l,d 
8cd2 06 08		    ld b,8 
8cd4			Mult8_Loop: 
8cd4 29			    add hl,hl 
8cd5 30 01		    jr nc,Mult8_NoAdd 
8cd7 19			    add hl,de 
8cd8			Mult8_NoAdd: 
8cd8 10 fa		    djnz Mult8_Loop 
8cda c9			    ret 
8cdb			 
8cdb			 
8cdb			 
8cdb			 
8cdb			 
8cdb			 
8cdb			 
8cdb			 
8cdb			;;http://z80-heaven.wikidot.com/math 
8cdb			;;This divides DE by BC, storing the result in DE, remainder in HL 
8cdb			; 
8cdb			;DE_Div_BC:          ;1281-2x, x is at most 16 
8cdb			;     ld a,16        ;7 
8cdb			;     ld hl,0        ;10 
8cdb			;     jp $+5         ;10 
8cdb			;.DivLoop: 
8cdb			;       add hl,bc    ;-- 
8cdb			;       dec a        ;64 
8cdb			;       jr z,.DivLoopEnd        ;86 
8cdb			; 
8cdb			;       sla e        ;128 
8cdb			;       rl d         ;128 
8cdb			;       adc hl,hl    ;240 
8cdb			;       sbc hl,bc    ;240 
8cdb			;       jr nc,.DivLoop ;23|21 
8cdb			;       inc e        ;-- 
8cdb			;       jp .DivLoop+1 
8cdb			; 
8cdb			;.DivLoopEnd: 
8cdb			 
8cdb			;HL_Div_C: 
8cdb			;Inputs: 
8cdb			;     HL is the numerator 
8cdb			;     C is the denominator 
8cdb			;Outputs: 
8cdb			;     A is the remainder 
8cdb			;     B is 0 
8cdb			;     C is not changed 
8cdb			;     DE is not changed 
8cdb			;     HL is the quotient 
8cdb			; 
8cdb			;       ld b,16 
8cdb			;       xor a 
8cdb			;         add hl,hl 
8cdb			;         rla 
8cdb			;         cp c 
8cdb			;         jr c,$+4 
8cdb			;           inc l 
8cdb			;           sub c 
8cdb			;         djnz $-7 
8cdb			 
8cdb			; https://plutiedev.com/z80-add-8bit-to-16bit 
8cdb			 
8cdb			addatohl: 
8cdb 85			    add   a, l    ; A = A+L 
8cdc 6f			    ld    l, a    ; L = A+L 
8cdd 8c			    adc   a, h    ; A = A+L+H+carry 
8cde 95			    sub   l       ; A = H+carry 
8cdf 67			    ld    h, a    ; H = H+carry 
8ce0 c9			ret 
8ce1			 
8ce1			addatode: 
8ce1 83			    add   a, e    ; A = A+L 
8ce2 5f			    ld    e, a    ; L = A+L 
8ce3 8a			    adc   a, d    ; A = A+L+H+carry 
8ce4 93			    sub   e       ; A = H+carry 
8ce5 57			    ld    d, a    ; H = H+carry 
8ce6 c9			ret 
8ce7			 
8ce7			 
8ce7			addatobc: 
8ce7 81			    add   a, c    ; A = A+L 
8ce8 4f			    ld    c, a    ; L = A+L 
8ce9 88			    adc   a, b    ; A = A+L+H+carry 
8cea 91			    sub   c       ; A = H+carry 
8ceb 47			    ld    b, a    ; H = H+carry 
8cec c9			ret 
8ced			 
8ced			subafromhl: 
8ced			   ; If A=0 do nothing 
8ced			    ; Otherwise flip A's sign. Since 
8ced			    ; the upper byte becomes -1, also 
8ced			    ; substract 1 from H. 
8ced ed 44		    neg 
8cef ca f8 8c		    jp    z, Skip 
8cf2 25			    dec   h 
8cf3			     
8cf3			    ; Now add the low byte as usual 
8cf3			    ; Two's complement takes care of 
8cf3			    ; ensuring the result is correct 
8cf3 85			    add   a, l 
8cf4 6f			    ld    l, a 
8cf5 8c			    adc   a, h 
8cf6 95			    sub   l 
8cf7 67			    ld    h, a 
8cf8			Skip: 
8cf8 c9				ret 
8cf9			 
8cf9			 
8cf9			; compare hl and de 
8cf9			; returns:  
8cf9			; if hl = de, z=1, s=0, c0=0 
8cf9			; if hl > de, z=0, s=0, c=0 
8cf9			; if hl < de, z=0, s=1, c=1 
8cf9			cmp16:	 
8cf9 b7				or a 
8cfa ed 52			sbc hl,de 
8cfc e0				ret po 
8cfd 7c				ld a,h 
8cfe 1f				rra 
8cff ee 40			xor 01000000B 
8d01 37				scf 
8d02 8f				adc a,a 
8d03 c9				ret 
8d04			 
8d04			 
8d04			; test if hl contains zero   - A is destroyed 
8d04			 
8d04			ishlzero:    
8d04 b7				or a     ; reset flags 
8d05 7c				ld a, h 
8d06 b5				or l        	 
8d07			 
8d07 c9				ret 
8d08			 
8d08			 
8d08			 
8d08			 
8d08			if FORTH_ENABLE_FLOATMATH 
8d08			;include "float/bbcmath.z80" 
8d08			include "float/lpfpcalc.asm" 
8d08			endif 
8d08			 
8d08			 
8d08			; eof 
8d08			 
# End of file firmware_maths.asm
8d08			include "firmware_strings.asm"   ; string handling  
8d08			 
8d08			 
8d08			; TODO string len 
8d08			; input text string, end on cr with zero term 
8d08			; a offset into frame buffer to start prompt 
8d08			; d is max length 
8d08			; e is display size TODO 
8d08			; c is current cursor position 
8d08			; hl is ptr to where string will be stored and edited directly 
8d08			 
8d08			 
8d08			; TODO check limit of buffer for new inserts 
8d08			; TODO check insert does not push beyond buffer 
8d08			; TODO scroll in a limited display area 
8d08			; TODO scroll whole screen on page wrap 
8d08			 
8d08			 
8d08			; TODO handle KEY_PREVWORD 
8d08			; TODO handle KEY_NEXTWORD 
8d08			; TODO handle KEY_HOME 
8d08			; TODO handle KEY_END 
8d08			; TODO use LCD cursor? 
8d08			 
8d08			EDIT_V1: equ 0 
8d08			EDIT_V2: equ 1 
8d08			 
8d08			 
8d08			 
8d08			if EDIT_V2 
8d08			input_str: 
8d08			else 
8d08			input_str_new: 
8d08			endif 
8d08			 
8d08 32 64 ee			    	ld (input_at_pos),a      ; save display position to start 
8d0b			;		ld (input_at_cursor),a	; save draw pos of cursor relative to start 
8d0b 22 67 ee				ld (input_start), hl     ; save ptr to buffer 
8d0e			;		ld a, c 
8d0e			;		call addatohl 
8d0e			;		ld (input_ptr), hl     ; save ptr to point under the cursor 
8d0e 7a					ld a,d 
8d0f 32 66 ee			        ld (input_size), a       ; save length of input area 
8d12 79					ld a, c 
8d13 32 55 ee				ld (input_cursor),a      ; init cursor start position relative to start of string 
8d16 7b					ld a,e 
8d17 32 65 ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
8d1a			 
8d1a			 
8d1a					; add a trailing space to make screen refresh nicer 
8d1a			 
8d1a					;ld hl, (input_start) 
8d1a					;push hl 
8d1a					;ld a, 0 
8d1a					;call strlent 
8d1a					;ld a, l 
8d1a					;pop hl 
8d1a					;call addatohl 
8d1a					;dec hl 
8d1a					;ld a, ' ' 
8d1a					;ld (hl), a 
8d1a					;inc hl 
8d1a					;ld (hl), a 
8d1a					;inc hl 
8d1a					;ld a, 0 
8d1a					;ld (hl), a 
8d1a			 
8d1a			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
8d1a					; init cursor shape if not set by the cin routines 
8d1a 21 c1 eb				ld hl, cursor_shape 
8d1d			if BASE_KEV 
8d1d					ld a, 255 
8d1d			else 
8d1d 3e 23				ld a, '#' 
8d1f			endif 
8d1f 77					ld (hl), a 
8d20 23					inc hl 
8d21 3e 00				ld a, 0 
8d23 77					ld (hl), a 
8d24			 
8d24 3e 09				ld a, CUR_BLINK_RATE 
8d26 32 60 ee				ld (input_cur_flash), a 
8d29 3e 01				ld a, 1 
8d2b 32 5f ee				ld (input_cur_onoff),a 
8d2e			.inmain:	 
8d2e			 
8d2e 2a 67 ee				ld hl, (input_start) 
8d31 3e 00				ld a, 0 
8d33 cd a3 92				call strlent 
8d36 7d					ld a, l 
8d37 32 5a ee				ld (input_len),a 
8d3a cd e7 8d				call input_disp_ref 
8d3d					;call input_disp_oncur 
8d3d			 
8d3d					; TODO display current state of input buffer 
8d3d			 
8d3d			 
8d3d					; pause 1ms 
8d3d			 
8d3d 3e 01				ld a, 1 
8d3f cd d6 89				call aDelayInMS 
8d42			 
8d42			; display cursor if visible on this cycle 
8d42			 
8d42					; dec flash counter 
8d42 3a 60 ee				ld a, (input_cur_flash) 
8d45 3d					dec a 
8d46 32 60 ee				ld (input_cur_flash), a 
8d49 fe 00				cp 0 
8d4b 20 0d				jr nz, .inochgstate 
8d4d			 
8d4d			 
8d4d					; reset on change of state 
8d4d 3e 09				ld a, CUR_BLINK_RATE 
8d4f 32 60 ee				ld (input_cur_flash), a 
8d52			 
8d52					; change state 
8d52 3a 5f ee				ld a,(input_cur_onoff) 
8d55 ed 44				neg 
8d57 32 5f ee				ld (input_cur_onoff),a 
8d5a			 
8d5a			 
8d5a			 
8d5a			 
8d5a					; TODO is cursor visible? 
8d5a					; TODO if so then over write the char at curspos pos with the cursor shape 
8d5a			 
8d5a								 
8d5a			 
8d5a			.inochgstate: 
8d5a 3a 5f ee				ld a,(input_cur_onoff) 
8d5d fe ff				cp 255 
8d5f 28 0e				jr z, .skipcursor 
8d61 3a 64 ee				ld a, (input_at_pos) 
8d64 47					ld b, a 
8d65 3a 55 ee				ld a, (input_cursor) 
8d68 80					add b 
8d69 11 c1 eb				ld de, cursor_shape 
8d6c					 
8d6c cd c1 8a				call str_at_display 
8d6f			 
8d6f			.skipcursor: 
8d6f				if DEBUG_INPUTV2 
8d6f			 
8d6f 3a 64 ee				ld a,(input_at_pos) 
8d72 21 ad eb				ld hl, LFSRSeed 
8d75 cd 3b 91				call hexout 
8d78 3a 55 ee				ld a, (input_cursor) 
8d7b 21 af eb				ld hl, LFSRSeed+2 
8d7e cd 3b 91				call hexout 
8d81 3a 66 ee				ld a,(input_size) 
8d84 21 b1 eb				ld hl, LFSRSeed+4 
8d87 cd 3b 91				call hexout 
8d8a			 
8d8a 3a 5f ee				ld a,(input_cur_onoff) 
8d8d 21 b3 eb				ld hl, LFSRSeed+6 
8d90 cd 3b 91				call hexout 
8d93			 
8d93 3a 60 ee				ld a,(input_cur_flash) 
8d96 21 b5 eb				ld hl, LFSRSeed+8 
8d99 cd 3b 91				call hexout 
8d9c			 
8d9c 3a 5a ee				ld a,(input_len) 
8d9f 21 b7 eb				ld hl, LFSRSeed+10 
8da2 cd 3b 91				call hexout 
8da5 21 b9 eb				ld hl, LFSRSeed+12 
8da8 3e 00				ld a, 0 
8daa 77					ld (hl),a 
8dab 3e 78				ld a, display_row_4 
8dad 11 ad eb				ld de, LFSRSeed 
8db0 cd c1 8a				call str_at_display 
8db3				endif 
8db3 cd d1 8a				call update_display 
8db6			 
8db6					; TODO keyboard processing 
8db6			 
8db6			if BASE_CPM 
8db6					call cin_wait 
8db6			else 
8db6 cd 34 e6				call cin    ; _wait 
8db9			endif 
8db9 fe 00				cp 0 
8dbb ca 2e 8d				jp z, .inmain 
8dbe			 
8dbe fe 0b				cp KEY_LEFT    ; cursor left 
8dc0 ca d3 8d				jp z, input_left 
8dc3				 
8dc3 fe 0c				cp KEY_RIGHT      ; cursor right 
8dc5 ca dd 8d				jp z, input_right 
8dc8			 
8dc8 fe 0d				cp KEY_CR 
8dca c8					ret z 
8dcb			 
8dcb fe 08				cp KEY_BS 
8dcd ca 4a 8e				jp z, input_delchar 
8dd0			 
8dd0			;		cp KEY_HOME    ; jump to start of line 
8dd0			;		jr nz, .instr5 
8dd0			;		dec hl 
8dd0			;		ld (input_ptr),hl 
8dd0			;		jr .instr1 
8dd0			 
8dd0			;		cp KEY_END     ; jump to end of line 
8dd0			;		jr nz, .instr6 
8dd0			;		dec hl 
8dd0			;		ld (input_ptr),hl 
8dd0			;		jr .instr1 
8dd0			;	        cp KEY_UP      ; recall last command 
8dd0			;		jr nz, .instrnew 
8dd0			; 
8dd0			;	ld hl, scratch 
8dd0			;	ld de, os_last_cmd 
8dd0			;	call strcpy 
8dd0			;		jr .instr1 
8dd0			 
8dd0			 
8dd0					; if no special key then insert as a char 
8dd0			 
8dd0 c3 16 8e				jp input_inschr 
8dd3			 
8dd3				 
8dd3			 
8dd3			 
8dd3			 
8dd3			input_left: 
8dd3				; move cursor left 
8dd3 3a 55 ee			ld a, (input_cursor) 
8dd6			;	cp 0 
8dd6			;	jp z, .inmain    ; ignore left as at the start of the string 
8dd6 3d				dec a 
8dd7 32 55 ee			ld (input_cursor), a 
8dda c3 2e 8d			jp .inmain 
8ddd			 
8ddd			input_right: 
8ddd				; move cursor right 
8ddd				 
8ddd				;ld a, (input_size) 
8ddd				;ld b, a 
8ddd 3a 55 ee			ld a, (input_cursor) 
8de0				;dec b 
8de0				;cp 0 
8de0				;jp z, .inmain   ; ignore as at end of the string buffer 
8de0				;ld a, b 
8de0 3c				inc a 
8de1 32 55 ee			ld (input_cursor), a 
8de4 c3 2e 8d			jp .inmain 
8de7			 
8de7			 
8de7			 
8de7			input_disp_ref: 
8de7				; display the text from start of buffer (ie full refresh) 
8de7 3a 64 ee			ld a, (input_at_pos) 
8dea 2a 67 ee			ld hl,(input_start) 
8ded eb				ex de, hl 
8dee cd c1 8a			call str_at_display  
8df1 c9				ret 
8df2			input_disp_oncur: 
8df2				; display the text from cursor position to end of buffer 
8df2				; TODO position start of string at cursor position on screen 
8df2				; TODO draw from that point on 
8df2 3a 55 ee			ld a, (input_cursor) 
8df5 47				ld b, a 
8df6 3a 64 ee			ld a, (input_at_pos) 
8df9 80				add b 
8dfa 48				ld c, b     ; save a 
8dfb 78				ld a, b     ; inc string start for cursor 
8dfc 2a 67 ee			ld hl,(input_start) 
8dff cd db 8c			call addatohl 
8e02 eb				ex de, hl 
8e03 79				ld a, c 
8e04 cd c1 8a			call str_at_display  
8e07 c9				ret 
8e08			 
8e08			input_nxtw: 
8e08				; Find next word 
8e08 c9				ret 
8e09			 
8e09			input_prvw: 
8e09				; Find previous word 
8e09 c9				ret 
8e0a			 
8e0a			input_lenrem:   
8e0a				; Calculate the length of string remaining from current cursor 
8e0a				; position to end of buffer (exc null term) 
8e0a				 
8e0a 3a 55 ee			ld a, (input_cursor) 
8e0d 4f				ld c, a 
8e0e 3a 66 ee			ld a, (input_size) 
8e11 91				sub c 
8e12 06 00			ld b, 0 
8e14 0d				dec c 
8e15 c9				ret	 
8e16				 
8e16			 
8e16			input_inschr: 
8e16				; Insert char at cursor position 
8e16 f5				push af   ; save char 
8e17				;call input_lenrem    ; get bc length of remaining string 
8e17			 
8e17				 
8e17			 
8e17 2a 67 ee			ld hl, (input_start) 
8e1a 3a 55 ee			ld a, (input_cursor) 
8e1d cd db 8c			call addatohl 
8e20				;push hl   ; save to come back to 
8e20			 
8e20				; shift everything up one to end of buffer 
8e20			 
8e20				;push hl 
8e20				;dec de 
8e20				;inc de 
8e20			;	ldir 
8e20				 
8e20				;pop hl 
8e20			 
8e20				; are we adding to the end of line? 
8e20			 
8e20 3a 55 ee			ld a, (input_cursor) 
8e23 47				ld b, a 
8e24 3a 5a ee			ld a, (input_len) 
8e27 b8				cp b 
8e28 20 09			jr nz, .insmid   ; no, insert in middle of text 
8e2a			 
8e2a				; tack on the end of the line 
8e2a f1				pop af 
8e2b 77				ld (hl), a   ; save new char 
8e2c 23				inc hl 
8e2d 3e 00			ld a, 0 
8e2f 77				ld (hl), a 
8e30 c3 dd 8d			jp input_right 
8e33				 
8e33			.insmid: 
8e33				; hl has insertion point so move everything up one to allow for insertion 
8e33				;call input_shiftright 
8e33 f1				pop af 
8e34			 
8e34			.shufinsmid: 
8e34 47				ld b, a     ; b contains new char, c prev char at this position  
8e35 7e				ld a, (hl) 
8e36			 
8e36 fe 00			cp 0    ; at end of string need to then dump new char and add term 
8e38 28 07			jr z, .endinsmid 
8e3a 4f				ld c, a 
8e3b 78				ld a, b 
8e3c 77				ld (hl), a 
8e3d 23				inc hl 
8e3e 79				ld a, c 
8e3f 18 f3			jr .shufinsmid 
8e41				 
8e41			 
8e41			 
8e41			 
8e41			.endinsmid: 
8e41 78				ld a, b 
8e42 77				ld (hl), a 
8e43 23				inc hl 
8e44 3e 00			ld a, 0 
8e46 77				ld (hl), a 
8e47			 
8e47			 
8e47			;	ld (hl), a   ; save new char 
8e47			 
8e47 c3 dd 8d			jp input_right 
8e4a			 
8e4a			;input_shiftright: 
8e4a			;	; shift text right at cursor, hl has shift start 
8e4a			;	push hl 
8e4a			;	push de 
8e4a			;	push bc 
8e4a			; 
8e4a			; 
8e4a			;	; move to end of string past zero term 
8e4a			;	ld hl,(input_start) 
8e4a			;	ld a, (input_len) 
8e4a			;	call addatohl 
8e4a			;	inc hl 
8e4a			;;	inc hl 
8e4a			;;	inc hl 
8e4a			;	ld a, 0 
8e4a			;	ld (hl), a 
8e4a			;;	dec hl 
8e4a			;	 
8e4a			;;	ld (hl), a 
8e4a			;;	dec hl 
8e4a			; 
8e4a			;	push hl 
8e4a			;	pop de 
8e4a			;	inc de 
8e4a			;	 
8e4a			; 
8e4a			;;	ld hl,(input_start) 
8e4a			;;	ld a, (input_cursor) 
8e4a			;;	call addatohl 
8e4a			; 
8e4a			; 
8e4a			;	; calc how many bytes from cursor pos to end of string we need to shift 
8e4a			;	call input_lenrem    ; get bc length of remaining string 
8e4a			;	;ld a, (input_cursor) 
8e4a			;	;ld c, a 
8e4a			;	ld a, (input_len) 
8e4a			;	cp 2 
8e4a			;	jr z, .iskipzero	 
8e4a			;	;sub c 
8e4a			;	;inc a 
8e4a			;	;ld c, a 
8e4a			;	;ld b, 0 
8e4a			;	inc c 
8e4a			;	inc c 
8e4a			;	; move data 
8e4a			;	lddr 
8e4a			;.iskipzero: 
8e4a			; 
8e4a			;	pop bc 
8e4a			;	pop de 
8e4a			;	pop hl 
8e4a			;	ret	 
8e4a			 
8e4a			input_delchar: 
8e4a				; Delete char at cursor position 
8e4a cd 0a 8e			call input_lenrem    ; get bc length of remaining string 
8e4d 2a 67 ee			ld hl, (input_start) 
8e50 3a 55 ee			ld a, (input_cursor) 
8e53 cd db 8c			call addatohl 
8e56			 
8e56 e5				push hl 
8e57 d1				pop de 
8e58 1b				dec de 
8e59			 
8e59			.dl:	 
8e59 ed a0			ldi  
8e5b 7e				ld a, (hl) 
8e5c fe 00			cp 0 
8e5e 28 02			jr z, .dldone 
8e60 18 f7			jr .dl 
8e62			.dldone: 
8e62 ed a0			ldi 
8e64			 
8e64 c3 d3 8d			jp input_left 
8e67			 
8e67			 
8e67			 
8e67			 
8e67			 
8e67			if EDIT_V1 
8e67			input_str: 
8e67			else 
8e67			input_str_old: 
8e67			endif 
8e67			 
8e67 32 64 ee			    	ld (input_at_pos),a      ; save display position to start 
8e6a 81					add c 
8e6b 32 62 ee				ld (input_at_cursor),a	; save draw pos of cursor 
8e6e 22 67 ee				ld (input_start), hl     ; save ptr to buffer 
8e71 79					ld a, c 
8e72 cd db 8c				call addatohl 
8e75 22 69 ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
8e78 7a					ld a,d 
8e79 32 66 ee			        ld (input_size), a       ; save length of input area 
8e7c 79					ld a, c 
8e7d 32 55 ee				ld (input_cursor),a      ; init cursor start position  
8e80 7b					ld a,e 
8e81 32 65 ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
8e84					 
8e84					 
8e84			 
8e84			;		ld a,(input_ptr) 
8e84			;		ld (input_under_cursor),a 	; save what is under the cursor 
8e84			 
8e84			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
8e84					; init cursor shape if not set by the cin routines 
8e84 21 c1 eb				ld hl, cursor_shape 
8e87			if BASE_KEV 
8e87					ld a, 255 
8e87			else 
8e87 3e 23				ld a, '#' 
8e89			endif 
8e89 77					ld (hl), a 
8e8a 23					inc hl 
8e8b 3e 00				ld a, 0 
8e8d 77					ld (hl), a 
8e8e			 
8e8e 3e 09				ld a, CUR_BLINK_RATE 
8e90 32 60 ee				ld (input_cur_flash), a 
8e93 3e 01				ld a, 1 
8e95 32 5f ee				ld (input_cur_onoff),a 
8e98			 
8e98			;	if DEBUG_INPUT 
8e98			;		push af 
8e98			;		ld a, 'I' 
8e98			;		ld (debug_mark),a 
8e98			;		pop af 
8e98			;		CALLMONITOR 
8e98			;	endif 
8e98			.is1:		; main entry loop 
8e98			 
8e98			 
8e98			 
8e98					; pause 1ms 
8e98			 
8e98 3e 01				ld a, 1 
8e9a cd d6 89				call aDelayInMS 
8e9d			 
8e9d					; dec flash counter 
8e9d 3a 60 ee				ld a, (input_cur_flash) 
8ea0 3d					dec a 
8ea1 32 60 ee				ld (input_cur_flash), a 
8ea4 fe 00				cp 0 
8ea6 20 0d				jr nz, .nochgstate 
8ea8			 
8ea8			 
8ea8					; change state 
8ea8 3a 5f ee				ld a,(input_cur_onoff) 
8eab ed 44				neg 
8ead 32 5f ee				ld (input_cur_onoff),a 
8eb0			 
8eb0			 
8eb0					; reset on change of state 
8eb0 3e 09				ld a, CUR_BLINK_RATE 
8eb2 32 60 ee				ld (input_cur_flash), a 
8eb5			 
8eb5			.nochgstate: 
8eb5					 
8eb5					 
8eb5			 
8eb5					; display cursor  
8eb5			 
8eb5			;		ld hl, (input_start) 
8eb5			;		ld a, (input_cursor) 
8eb5			;		call addatohl 
8eb5			 
8eb5					; get char under cursor and replace with cursor 
8eb5 2a 69 ee		ld hl, (input_ptr) 
8eb8			;		ld a, (hl) 
8eb8			;		ld (input_under_cursor),a 
8eb8			;		ld a, '_' 
8eb8			;		ld (hl), a 
8eb8			 
8eb8					; display string 
8eb8			 
8eb8 ed 5b 67 ee			ld de, (input_start) 
8ebc 3a 64 ee				ld a, (input_at_pos) 
8ebf cd c1 8a				call str_at_display 
8ec2			;	        call update_display 
8ec2			 
8ec2					; find place to put the cursor 
8ec2			;		add h 
8ec2			;		ld l, display_row_1 
8ec2			;		sub l 
8ec2			; (input_at_pos) 
8ec2					;ld c, a 
8ec2			;		ld a, (input_cursor) 
8ec2			;		ld l, (input_at_pos) 
8ec2			;		;ld b, h 
8ec2			;		add l 
8ec2			;		ld (input_at_cursor),a 
8ec2					;ld l,h 
8ec2			 
8ec2			;		ld h, 0 
8ec2			;		ld l,(input_at_pos) 
8ec2			;		ld a, (input_cursor) 
8ec2			;		call addatohl 
8ec2			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
8ec2			;		call subafromhl 
8ec2			;		ld a,l 
8ec2			;		ld (input_at_cursor), a 
8ec2			 
8ec2				if DEBUG_INPUT 
8ec2					ld a, (hardware_diag) 
8ec2					cp 0 
8ec2					jr z, .skip_input_diag 
8ec2			 
8ec2					ld a,(input_at_pos) 
8ec2					ld hl, LFSRSeed 
8ec2					call hexout 
8ec2					ld a, (input_cursor) 
8ec2					ld hl, LFSRSeed+2 
8ec2					call hexout 
8ec2					ld a,(input_at_cursor) 
8ec2					ld hl, LFSRSeed+4 
8ec2					call hexout 
8ec2			 
8ec2					ld a,(input_cur_onoff) 
8ec2					ld hl, LFSRSeed+6 
8ec2					call hexout 
8ec2			 
8ec2					ld a,(input_cur_flash) 
8ec2					ld hl, LFSRSeed+8 
8ec2					call hexout 
8ec2			 
8ec2					ld a,(input_len) 
8ec2					ld hl, LFSRSeed+10 
8ec2					call hexout 
8ec2					ld hl, LFSRSeed+12 
8ec2					ld a, 0 
8ec2					ld (hl),a 
8ec2					ld a, display_row_4 
8ec2					ld de, LFSRSeed 
8ec2					call str_at_display 
8ec2					.skip_input_diag: 
8ec2				endif 
8ec2			 
8ec2					; decide on if we are showing the cursor this time round 
8ec2			 
8ec2 3a 5f ee				ld a, (input_cur_onoff) 
8ec5 fe ff				cp 255 
8ec7 28 13				jr z, .skipcur 
8ec9			 
8ec9			 
8ec9 3a 62 ee				ld a,(input_at_cursor) 
8ecc 11 c1 eb				ld de, cursor_shape 
8ecf cd c1 8a				call str_at_display 
8ed2			 
8ed2					; save length of current input string 
8ed2 2a 67 ee				ld hl, (input_start) 
8ed5 cd 98 92				call strlenz 
8ed8 7d					ld a,l 
8ed9 32 5a ee				ld (input_len),a 
8edc			 
8edc			.skipcur: 
8edc			 
8edc cd d1 8a			        call update_display 
8edf					 
8edf			 
8edf			 
8edf					; wait 
8edf				 
8edf					; TODO loop without wait to flash the cursor and char under cursor	 
8edf cd 34 e6				call cin    ; _wait 
8ee2			 
8ee2 fe 00				cp 0 
8ee4 ca 98 8e				jp z, .is1 
8ee7			 
8ee7					; get ptr to char to input into 
8ee7			 
8ee7 4f					ld c,a 
8ee8 2a 67 ee				ld hl, (input_start) 
8eeb 3a 55 ee				ld a, (input_cursor) 
8eee cd db 8c				call addatohl 
8ef1 22 69 ee				ld (input_ptr), hl 
8ef4 79					ld a,c 
8ef5			 
8ef5					; replace char under cursor 
8ef5			 
8ef5			;		ld hl, (input_ptr) 
8ef5			;		ld a, (input_under_cursor) 	; get what is under the cursor 
8ef5			;		ld (hl), a 
8ef5			 
8ef5			;	if DEBUG_INPUT 
8ef5			;		push af 
8ef5			;		ld a, 'i' 
8ef5			;		ld (debug_mark),a 
8ef5			;		pop af 
8ef5			;		CALLMONITOR 
8ef5			;	endif 
8ef5 fe 0e				cp KEY_HOME 
8ef7 20 0e				jr nz, .iske 
8ef9			 
8ef9 3a 64 ee				ld a, (input_at_pos) 
8efc 32 62 ee				ld (input_at_cursor),a 
8eff 3e 00				ld a, 0 
8f01 32 55 ee				ld (input_cursor), a 
8f04 c3 98 8e				jp .is1 
8f07					 
8f07 fe 0f		.iske:		cp KEY_END 
8f09 20 03				jr nz, .isknw 
8f0b c3 98 8e				jp .is1 
8f0e			 
8f0e fe 06		.isknw:		cp KEY_NEXTWORD 
8f10 20 1b				jr nz, .iskpw 
8f12			 
8f12 2a 69 ee		.isknwm:	ld hl, (input_ptr) 
8f15 7e					ld a,(hl)	 
8f16 fe 00				cp 0 
8f18 ca 98 8e				jp z, .is1    ; end of string 
8f1b fe 20				cp ' ' 
8f1d ca 98 8e				jp z, .is1    ; end of word 
8f20 23					inc hl 
8f21 22 69 ee				ld (input_ptr), hl 
8f24 3a 62 ee				ld a, (input_at_cursor) 
8f27 3c					inc a 
8f28 32 62 ee				ld (input_at_cursor), a 
8f2b 18 e5				jr .isknwm 
8f2d			 
8f2d fe 07		.iskpw:		cp KEY_PREVWORD 
8f2f 20 1b				jr nz, .iskl 
8f31			.iskpwm:	 
8f31 2a 69 ee				ld hl, (input_ptr) 
8f34 7e					ld a,(hl)	 
8f35 fe 00				cp 0  
8f37 ca 98 8e				jp z, .is1    ; end of string 
8f3a fe 20				cp ' ' 
8f3c ca 98 8e				jp z, .is1    ; end of word 
8f3f 2b					dec hl 
8f40 22 69 ee				ld (input_ptr), hl 
8f43 3a 62 ee				ld a, (input_at_cursor) 
8f46 3d					dec a 
8f47 32 62 ee				ld (input_at_cursor), a 
8f4a 18 e5				jr .iskpwm 
8f4c			 
8f4c			 
8f4c fe 0b		.iskl:		cp KEY_LEFT 
8f4e 20 27				jr nz, .isk1 
8f50			 
8f50 3a 55 ee				ld a, (input_cursor) 
8f53			 
8f53 fe 00				cp 0 
8f55 ca 98 8e				jp z, .is1 		; at start of line to ignore  
8f58			 
8f58 3d					dec  a 		; TODO check underflow 
8f59 32 55 ee				ld (input_cursor), a 
8f5c			 
8f5c 2a 69 ee				ld hl, (input_ptr) 
8f5f 2b					dec hl 
8f60 22 69 ee				ld (input_ptr), hl 
8f63					 
8f63 3a 62 ee				ld a, (input_at_cursor) 
8f66 3d					dec a 
8f67 32 62 ee				ld (input_at_cursor), a 
8f6a			 
8f6a 3e 01				ld a, 1		; show cursor moving 
8f6c 32 5f ee				ld (input_cur_onoff),a 
8f6f 3e 09				ld a, CUR_BLINK_RATE 
8f71 32 60 ee				ld (input_cur_flash), a 
8f74			 
8f74 c3 98 8e				jp .is1 
8f77			 
8f77 fe 0c		.isk1:		cp KEY_RIGHT 
8f79 20 2a				jr nz, .isk2 
8f7b			 
8f7b 3a 5a ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
8f7e 5f					ld e,a 
8f7f 3a 55 ee				ld a, (input_cursor) 
8f82 bb					cp e 
8f83 ca 98 8e				jp z, .is1		; at the end of string so dont go right 
8f86			 
8f86 3c					inc  a 		; TODO check overflow 
8f87 32 55 ee				ld (input_cursor), a 
8f8a			 
8f8a 3a 62 ee				ld a, (input_at_cursor) 
8f8d 3c					inc a 
8f8e 32 62 ee				ld (input_at_cursor), a 
8f91			 
8f91 2a 69 ee				ld hl, (input_ptr) 
8f94 23					inc hl 
8f95 22 69 ee				ld (input_ptr), hl 
8f98			 
8f98 3e 01				ld a, 1		; show cursor moving 
8f9a 32 5f ee				ld (input_cur_onoff),a 
8f9d 3e 09				ld a, CUR_BLINK_RATE 
8f9f 32 60 ee				ld (input_cur_flash), a 
8fa2			 
8fa2 c3 98 8e				jp .is1 
8fa5			 
8fa5 fe 05		.isk2:		cp KEY_UP 
8fa7			 
8fa7 20 26				jr nz, .isk3 
8fa9			 
8fa9					; swap last command with the current on 
8fa9			 
8fa9					; move cursor to start of string 
8fa9 2a 67 ee				ld hl, (input_start) 
8fac 22 69 ee				ld (input_ptr), hl 
8faf			 
8faf 3a 64 ee				ld a, (input_at_pos) 
8fb2 32 62 ee				ld (input_at_cursor), a 
8fb5			 
8fb5 3e 00				ld a, 0 
8fb7 32 55 ee				ld (input_cursor), a 
8fba					 
8fba					; swap input and last command buffers 
8fba			 
8fba 21 e8 e5				ld hl, os_cli_cmd 
8fbd 11 e7 e6				ld de, os_last_cmd 
8fc0 06 ff				ld b, 255 
8fc2 7e			.swap1:		ld a, (hl) 
8fc3 4f					ld c,a 
8fc4 1a					ld a, (de) 
8fc5 77					ld (hl), a 
8fc6 79					ld a,c 
8fc7 12					ld (de),a 
8fc8 23					inc hl 
8fc9 13					inc de 
8fca 10 f6				djnz .swap1 
8fcc			 
8fcc			 
8fcc			 
8fcc			 
8fcc			 
8fcc c3 98 8e				jp .is1 
8fcf			 
8fcf fe 08		.isk3:		cp KEY_BS 
8fd1 20 3c				jr nz, .isk4 
8fd3			 
8fd3 3a 55 ee				ld a, (input_cursor) 
8fd6			 
8fd6 fe 00				cp 0 
8fd8 ca 98 8e				jp z, .is1 		; at start of line to ignore  
8fdb			 
8fdb 3d					dec  a 		; TODO check underflow 
8fdc 32 55 ee				ld (input_cursor), a 
8fdf			 
8fdf					; hl is source 
8fdf					; de needs to be source - 1 
8fdf			 
8fdf			;		ld a, 0 
8fdf			;		dec hl 
8fdf			;		ld (hl), a 
8fdf			 
8fdf 2a 69 ee				ld hl, (input_ptr) 
8fe2 2b					dec hl 
8fe3 22 69 ee				ld (input_ptr), hl 
8fe6			 
8fe6					; shift all data 
8fe6			 
8fe6 e5					push hl 
8fe7 23					inc hl 
8fe8 d1					pop de 
8fe9 3a 5a ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
8fec 4f					ld c,a 
8fed 06 00				ld b,0 
8fef ed b0				ldir  
8ff1			 
8ff1			 
8ff1			 
8ff1			 
8ff1 3a 62 ee				ld a, (input_at_cursor) 
8ff4 3d					dec a 
8ff5 32 62 ee				ld (input_at_cursor), a 
8ff8			 
8ff8			 
8ff8 3e 01				ld a, 1		; show cursor moving 
8ffa 32 5f ee				ld (input_cur_onoff),a 
8ffd 3e 09				ld a, CUR_BLINK_RATE 
8fff 32 60 ee				ld (input_cur_flash), a 
9002			 
9002					; remove char 
9002 3a 62 ee				ld a, (input_at_cursor) 
9005 3c					inc a 
9006 11 90 90				ld de,.iblank 
9009 cd c1 8a				call str_at_display 
900c			 
900c c3 98 8e				jp .is1 
900f			 
900f fe 0d		.isk4:		cp KEY_CR 
9011 28 6c				jr z, .endinput 
9013			 
9013					; else add the key press to the end 
9013			 
9013 4f					ld c, a			; save key pressed 
9014			 
9014 7e					ld a,(hl)		; get what is currently under char 
9015			 
9015 fe 00				cp 0			; we are at the end of the string 
9017 20 2f				jr nz, .onchar 
9019					 
9019					; add a char to the end of the string 
9019				 
9019 71					ld (hl),c 
901a 23					inc hl 
901b			;		ld a,' ' 
901b			;		ld (hl),a 
901b			;		inc hl 
901b 3e 00				ld a,0 
901d 77					ld (hl),a 
901e 2b					dec hl 
901f			 
901f 3a 55 ee				ld a, (input_cursor) 
9022 3c					inc a				; TODO check max string length and scroll  
9023 32 55 ee				ld (input_cursor), a		; inc cursor pos 
9026							 
9026 3a 62 ee				ld a, (input_at_cursor) 
9029 3c					inc a 
902a 32 62 ee				ld (input_at_cursor), a 
902d			 
902d 2a 69 ee				ld hl, (input_ptr) 
9030 23					inc hl 
9031 22 69 ee				ld (input_ptr), hl 
9034			 
9034 2a 69 ee				ld hl, (input_ptr) 
9037 23					inc hl 
9038 22 69 ee				ld (input_ptr), hl 
903b			;	if DEBUG_INPUT 
903b			;		push af 
903b			;		ld a, '+' 
903b			;		ld (debug_mark),a 
903b			;		pop af 
903b			;		CALLMONITOR 
903b			;	endif 
903b 3e 01				ld a, 1		; show cursor moving 
903d 32 5f ee				ld (input_cur_onoff),a 
9040 3e 09				ld a, CUR_BLINK_RATE 
9042 32 60 ee				ld (input_cur_flash), a 
9045 c3 98 8e				jp .is1 
9048					 
9048			 
9048			 
9048					; if on a char then insert 
9048			.onchar: 
9048			 
9048					; TODO over flow check: make sure insert does not blow out buffer 
9048			 
9048					; need to do some maths to use lddr 
9048			 
9048 e5					push hl   ; save char pos 
9049 c5					push bc 
904a			 
904a 2a 67 ee				ld hl, (input_start) 
904d 3a 5a ee				ld a, (input_len) 
9050 cd db 8c				call addatohl  		; end of string 
9053 23					inc hl 
9054 23					inc hl		; past zero term 
9055 e5					push hl 
9056 23					inc hl 
9057 e5					push hl  
9058			 
9058								; start and end of lddr set, now how much to move? 
9058			 
9058							 
9058 3a 55 ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
905b 47					ld b,a 
905c 3a 5a ee				ld a,(input_len) 
905f 5f					ld e,a 
9060 90					sub b 
9061 3c					inc a		;?? 
9062 3c					inc a		;?? 
9063 3c					inc a		;?? 
9064			 
9064 06 00				ld b,0 
9066 4f					ld c,a 
9067			 
9067				if DEBUG_INPUT 
9067					push af 
9067					ld a, 'i' 
9067					ld (debug_mark),a 
9067					pop af 
9067			;		CALLMONITOR 
9067				endif 
9067 d1					pop de 
9068 e1					pop hl 
9069				if DEBUG_INPUT 
9069					push af 
9069					ld a, 'I' 
9069					ld (debug_mark),a 
9069					pop af 
9069			;		CALLMONITOR 
9069				endif 
9069 ed b8				lddr 
906b				 
906b			 
906b			 
906b					; TODO have a key for insert/overwrite mode???? 
906b c1					pop bc 
906c e1					pop hl 
906d 71					ld (hl), c		; otherwise overwrite current char 
906e					 
906e			 
906e			 
906e			 
906e 3a 55 ee				ld a, (input_cursor) 
9071 3c					inc  a 		; TODO check overflow 
9072 32 55 ee				ld (input_cursor), a 
9075			 
9075 3a 62 ee				ld a, (input_at_cursor) 
9078 3c					inc a 
9079 32 62 ee				ld (input_at_cursor), a 
907c			 
907c c3 98 8e				jp .is1 
907f			 
907f			.endinput:	; TODO look for end of string 
907f			 
907f					; add trailing space for end of token 
907f			 
907f 2a 67 ee				ld hl, (input_start) 
9082 3a 5a ee				ld a,(input_len) 
9085 cd db 8c				call addatohl 
9088 3e 20				ld a, ' ' 
908a 77					ld (hl),a 
908b					; TODO eof of parse marker 
908b			 
908b 23					inc hl 
908c 3e 00				ld a, 0 
908e 77					ld (hl),a 
908f			 
908f			 
908f c9					ret 
9090			 
9090 .. 00		.iblank: db " ",0 
9092			 
9092			 
9092 32 64 ee		input_str_prev:	ld (input_at_pos), a 
9095 22 67 ee				ld (input_start), hl 
9098 3e 01				ld a,1			; add cursor 
909a 77					ld (hl),a 
909b 23					inc hl 
909c 3e 00				ld a,0 
909e 77					ld (hl),a 
909f 22 69 ee				ld (input_ptr), hl 
90a2 7a					ld a,d 
90a3 32 66 ee				ld (input_size), a 
90a6 3e 00				ld a,0 
90a8 32 55 ee				ld (input_cursor),a 
90ab			.instr1:	 
90ab			 
90ab					; TODO do block cursor 
90ab					; TODO switch cursor depending on the modifer key 
90ab			 
90ab					; update cursor shape change on key hold 
90ab			 
90ab 2a 69 ee				ld hl, (input_ptr) 
90ae 2b					dec hl 
90af 3a c1 eb				ld a,(cursor_shape) 
90b2 77					ld (hl), a 
90b3			 
90b3					; display entered text 
90b3 3a 64 ee				ld a,(input_at_pos) 
90b6 cd 92 e5		            	CALL fLCD_Pos       ;Position cursor to location in A 
90b9 ed 5b 67 ee	            	LD   de, (input_start) 
90bd cd 8c e5		            	CALL fLCD_Str       ;Display string pointed to by DE 
90c0			 
90c0 cd 34 e6				call cin 
90c3 fe 00				cp 0 
90c5 28 e4				jr z, .instr1 
90c7			 
90c7					; proecess keyboard controls first 
90c7			 
90c7 2a 69 ee				ld hl,(input_ptr) 
90ca			 
90ca fe 0d				cp KEY_CR	 ; pressing enter ends input 
90cc 28 5a				jr z, .instrcr 
90ce			 
90ce fe 08				cp KEY_BS 	; back space 
90d0 20 0f				jr nz, .instr2 
90d2					; process back space 
90d2			 
90d2					; TODO stop back space if at start of string 
90d2 2b					dec hl 
90d3 2b					dec hl ; to over write cursor 
90d4 3a c1 eb				ld a,(cursor_shape) 
90d7					;ld a,0 
90d7 77					ld (hl),a 
90d8 23					inc hl 
90d9 3e 20				ld a," " 
90db 77					ld (hl),a 
90dc 22 69 ee				ld (input_ptr),hl 
90df					 
90df			 
90df 18 ca				jr .instr1 
90e1			 
90e1 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
90e3 20 06				jr nz, .instr3 
90e5 2b					dec hl 
90e6 22 69 ee				ld (input_ptr),hl 
90e9 18 c0				jr .instr1 
90eb				 
90eb fe 0c		.instr3:	cp KEY_RIGHT      ; cursor right 
90ed 20 06				jr nz, .instr4 
90ef 23					inc hl 
90f0 22 69 ee				ld (input_ptr),hl 
90f3 18 b6				jr .instr1 
90f5			 
90f5 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
90f7 20 06				jr nz, .instr5 
90f9 2b					dec hl 
90fa 22 69 ee				ld (input_ptr),hl 
90fd 18 ac				jr .instr1 
90ff			 
90ff fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
9101 20 06				jr nz, .instr6 
9103 2b					dec hl 
9104 22 69 ee				ld (input_ptr),hl 
9107 18 a2				jr .instr1 
9109 fe 05		.instr6:        cp KEY_UP      ; recall last command 
910b 20 0b				jr nz, .instrnew 
910d			 
910d 21 c1 e2			ld hl, scratch 
9110 11 e7 e6			ld de, os_last_cmd 
9113 cd 31 91			call strcpy 
9116 18 93				jr .instr1 
9118			 
9118			 
9118			.instrnew:	; no special key pressed to see if we have room to store it 
9118			 
9118					; TODO do string size test 
9118			 
9118 2b					dec hl ; to over write cursor 
9119 77					ld (hl),a 
911a 23					inc hl 
911b 3a c1 eb				ld a,(cursor_shape) 
911e 77					ld (hl),a 
911f 23					inc hl 
9120 3e 00				ld a,0 
9122 77					ld (hl),a 
9123			 
9123 22 69 ee				ld (input_ptr),hl 
9126					 
9126 18 83				jr .instr1 
9128 2b			.instrcr:	dec hl		; remove cursor 
9129 3e 20				ld a,' '	; TODO add a trailing space for safety 
912b 77					ld (hl),a 
912c 23					inc hl 
912d 3e 00				ld a,0 
912f 77					ld (hl),a 
9130			 
9130			 
9130					; if at end of line scroll up    
9130					; TODO detecting only end of line 4 for scroll up  
9130			 
9130					;ld   
9130			 
9130 c9					ret 
9131			 
9131			 
9131			; strcpy hl = dest, de source 
9131			 
9131 1a			strcpy:   LD   A, (DE)        ;Get character from string 
9132 b7			            OR   A              ;Null terminator? 
9133 c8			            RET  Z              ;Yes, so finished 
9134 1a					ld a,(de) 
9135 77					ld (hl),a 
9136 13			            INC  DE             ;Point to next character 
9137 23					inc hl 
9138 18 f7		            JR   strcpy       ;Repeat 
913a c9					ret 
913b			 
913b			 
913b			; TODO string_at  
913b			; pass string which starts with lcd offset address and then null term string 
913b			 
913b			; TODO string to dec 
913b			; TODO string to hex 
913b			; TODO byte to string hex 
913b			; TODO byte to string dec 
913b			 
913b			 
913b			 
913b			; from z80uartmonitor 
913b			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
913b			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
913b			; pass hl for where to put the text 
913b			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
913b c5			hexout:	PUSH BC 
913c f5					PUSH AF 
913d 47					LD B, A 
913e					; Upper nybble 
913e cb 3f				SRL A 
9140 cb 3f				SRL A 
9142 cb 3f				SRL A 
9144 cb 3f				SRL A 
9146 cd 56 91				CALL tohex 
9149 77					ld (hl),a 
914a 23					inc hl	 
914b					 
914b					; Lower nybble 
914b 78					LD A, B 
914c e6 0f				AND 0FH 
914e cd 56 91				CALL tohex 
9151 77					ld (hl),a 
9152 23					inc hl	 
9153					 
9153 f1					POP AF 
9154 c1					POP BC 
9155 c9					RET 
9156					 
9156			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
9156			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
9156			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
9156			tohex: 
9156 e5					PUSH HL 
9157 d5					PUSH DE 
9158 16 00				LD D, 0 
915a 5f					LD E, A 
915b 21 63 91				LD HL, .DATA 
915e 19					ADD HL, DE 
915f 7e					LD A, (HL) 
9160 d1					POP DE 
9161 e1					POP HL 
9162 c9					RET 
9163			 
9163			.DATA: 
9163 30					DEFB	30h	; 0 
9164 31					DEFB	31h	; 1 
9165 32					DEFB	32h	; 2 
9166 33					DEFB	33h	; 3 
9167 34					DEFB	34h	; 4 
9168 35					DEFB	35h	; 5 
9169 36					DEFB	36h	; 6 
916a 37					DEFB	37h	; 7 
916b 38					DEFB	38h	; 8 
916c 39					DEFB	39h	; 9 
916d 41					DEFB	41h	; A 
916e 42					DEFB	42h	; B 
916f 43					DEFB	43h	; C 
9170 44					DEFB	44h	; D 
9171 45					DEFB	45h	; E 
9172 46					DEFB	46h	; F 
9173			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
9173			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
9173			;;    subtract $30, if result > 9 then subtract $7 more 
9173			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
9173			atohex: 
9173 d6 30				SUB $30 
9175 fe 0a				CP 10 
9177 f8					RET M		; If result negative it was 0-9 so we're done 
9178 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
917a c9					RET		 
917b			 
917b			 
917b			 
917b			 
917b			; Get 2 ASCII characters as hex byte from pointer in hl 
917b			 
917b			BYTERD: 
917b 16 00			LD	D,00h		;Set up 
917d cd 85 91			CALL	HEXCON		;Get byte and convert to hex 
9180 87				ADD	A,A		;First nibble so 
9181 87				ADD	A,A		;multiply by 16 
9182 87				ADD	A,A		; 
9183 87				ADD	A,A		; 
9184 57				LD	D,A		;Save hi nibble in D 
9185			HEXCON: 
9185 7e				ld a, (hl)		;Get next chr 
9186 23				inc hl 
9187 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
9189 fe 0a			CP	00Ah		;Is it 0-9 ? 
918b 38 02			JR	C,NALPHA	;If so miss next bit 
918d d6 07			SUB	007h		;Else convert alpha 
918f			NALPHA: 
918f b2				OR	D		;Add hi nibble back 
9190 c9				RET			; 
9191			 
9191			 
9191			; 
9191			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
9191			; Since the routines get_byte and therefore get_nibble are called, only valid 
9191			; characters (0-9a-f) are accepted. 
9191			; 
9191			;get_word        push    af 
9191			;                call    get_byte        ; Get the upper byte 
9191			;                ld      h, a 
9191			;                call    get_byte        ; Get the lower byte 
9191			;                ld      l, a 
9191			;                pop     af 
9191			;                ret 
9191			; 
9191			; Get a byte in hexadecimal notation. The result is returned in A. Since 
9191			; the routine get_nibble is used only valid characters are accepted - the  
9191			; input routine only accepts characters 0-9a-f. 
9191			; 
9191 c5			get_byte:        push    bc              ; Save contents of B (and C) 
9192 7e					ld a,(hl) 
9193 23					inc hl 
9194 cd b9 91		                call    nibble2val      ; Get upper nibble 
9197 cb 07		                rlc     a 
9199 cb 07		                rlc     a 
919b cb 07		                rlc     a 
919d cb 07		                rlc     a 
919f 47			                ld      b, a            ; Save upper four bits 
91a0 7e					ld a,(hl) 
91a1 cd b9 91		                call    nibble2val      ; Get lower nibble 
91a4 b0			                or      b               ; Combine both nibbles 
91a5 c1			                pop     bc              ; Restore B (and C) 
91a6 c9			                ret 
91a7			; 
91a7			; Get a hexadecimal digit from the serial line. This routine blocks until 
91a7			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
91a7			; to the serial line interface. The lower 4 bits of A contain the value of  
91a7			; that particular digit. 
91a7			; 
91a7			;get_nibble      ld a,(hl)           ; Read a character 
91a7			;                call    to_upper        ; Convert to upper case 
91a7			;                call    is_hex          ; Was it a hex digit? 
91a7			;                jr      nc, get_nibble  ; No, get another character 
91a7			 ;               call    nibble2val      ; Convert nibble to value 
91a7			 ;               call    print_nibble 
91a7			 ;               ret 
91a7			; 
91a7			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
91a7			; A valid hexadecimal digit is denoted by a set C flag. 
91a7			; 
91a7			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
91a7			;                ret     nc              ; Yes 
91a7			;                cp      '0'             ; Less than '0'? 
91a7			;                jr      nc, is_hex_1    ; No, continue 
91a7			;                ccf                     ; Complement carry (i.e. clear it) 
91a7			;                ret 
91a7			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
91a7			;                ret     c               ; Yes 
91a7			;                cp      'A'             ; Less than 'A'? 
91a7			;                jr      nc, is_hex_2    ; No, continue 
91a7			;                ccf                     ; Yes - clear carry and return 
91a7			;                ret 
91a7			;is_hex_2        scf                     ; Set carry 
91a7			;                ret 
91a7			; 
91a7			; Convert a single character contained in A to upper case: 
91a7			; 
91a7 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
91a9 d8			                ret     c 
91aa fe 7b		                cp      'z' + 1         ; > 'z'? 
91ac d0			                ret     nc              ; Nothing to do, either 
91ad e6 5f		                and     $5f             ; Convert to upper case 
91af c9			                ret 
91b0			 
91b0			 
91b0			to_lower: 
91b0			 
91b0			   ; if char is in [A-Z] make it lower case 
91b0			 
91b0			   ; enter : a = char 
91b0			   ; exit  : a = lower case char 
91b0			   ; uses  : af 
91b0			 
91b0 fe 41		   cp 'A' 
91b2 d8			   ret c 
91b3			    
91b3 fe 5b		   cp 'Z'+1 
91b5 d0			   ret nc 
91b6			    
91b6 f6 20		   or $20 
91b8 c9			   ret 
91b9			 
91b9			; 
91b9			; Expects a hexadecimal digit (upper case!) in A and returns the 
91b9			; corresponding value in A. 
91b9			; 
91b9 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
91bb 38 02		                jr      c, nibble2val_1 ; Yes 
91bd d6 07		                sub     7               ; Adjust for A-F 
91bf d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
91c1 e6 0f		                and     $f              ; Only return lower 4 bits 
91c3 c9			                ret 
91c4			; 
91c4			; Print_nibble prints a single hex nibble which is contained in the lower  
91c4			; four bits of A: 
91c4			; 
91c4			;print_nibble    push    af              ; We won't destroy the contents of A 
91c4			;                and     $f              ; Just in case... 
91c4			;                add     a, '0'             ; If we have a digit we are done here. 
91c4			;                cp      '9' + 1         ; Is the result > 9? 
91c4			;                jr      c, print_nibble_1 
91c4			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
91c4			;print_nibble_1  call    putc            ; Print the nibble and 
91c4			;                pop     af              ; restore the original value of A 
91c4			;                ret 
91c4			;; 
91c4			;; Send a CR/LF pair: 
91c4			; 
91c4			;crlf            push    af 
91c4			;                ld      a, cr 
91c4			;                call    putc 
91c4			;                ld      a, lf 
91c4			;                call    putc 
91c4			;                pop     af 
91c4			;                ret 
91c4			; 
91c4			; Print_word prints the four hex digits of a word to the serial line. The  
91c4			; word is expected to be in HL. 
91c4			; 
91c4			;print_word      push    hl 
91c4			;                push    af 
91c4			;                ld      a, h 
91c4			;                call    print_byte 
91c4			;                ld      a, l 
91c4			;                call    print_byte 
91c4			;                pop     af 
91c4			;                pop     hl 
91c4			;                ret 
91c4			; 
91c4			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
91c4			; The byte to be printed is expected to be in A. 
91c4			; 
91c4			;print_byte      push    af              ; Save the contents of the registers 
91c4			;                push    bc 
91c4			;                ld      b, a 
91c4			;                rrca 
91c4			;                rrca 
91c4			;                rrca 
91c4			;                rrca 
91c4			;                call    print_nibble    ; Print high nibble 
91c4			;                ld      a, b 
91c4			;                call    print_nibble    ; Print low nibble 
91c4			;                pop     bc              ; Restore original register contents 
91c4			;                pop     af 
91c4			;                ret 
91c4			 
91c4			 
91c4			 
91c4			 
91c4			 
91c4			fourehexhl:  
91c4 7e				ld a,(hl) 
91c5 cd 73 91			call atohex 
91c8 cb 3f				SRL A 
91ca cb 3f				SRL A 
91cc cb 3f				SRL A 
91ce cb 3f				SRL A 
91d0 47				ld b, a 
91d1 23				inc hl 
91d2 7e				ld a,(hl) 
91d3 23				inc hl 
91d4 cd 73 91			call atohex 
91d7 80				add b 
91d8 57				ld d,a 
91d9 7e				ld a,(hl) 
91da cd 73 91			call atohex 
91dd cb 3f				SRL A 
91df cb 3f				SRL A 
91e1 cb 3f				SRL A 
91e3 cb 3f				SRL A 
91e5 47				ld b, a 
91e6 23				inc hl 
91e7 7e				ld a,(hl) 
91e8 23				inc hl 
91e9 cd 73 91			call atohex 
91ec 80				add b 
91ed 5f				ld e, a 
91ee d5				push de 
91ef e1				pop hl 
91f0 c9				ret 
91f1			 
91f1			; pass hl. returns z set if the byte at hl is a digit 
91f1			;isdigithl:  
91f1			;	push bc 
91f1			;	ld a,(hl) 
91f1			;	cp ':' 
91f1			;	jr nc, .isdf 		; > 
91f1			;	cp '0' 
91f1			;	jr c, .isdf		; < 
91f1			; 
91f1			;	; TODO find a better way to set z 
91f1			; 
91f1			;	ld b,a 
91f1			;	cp b 
91f1			;	pop bc 
91f1			;	ret 
91f1			; 
91f1			;.isdf:	; not digit so clear z 
91f1			; 
91f1			;	; TODO find a better way to unset z 
91f1			; 
91f1			;	ld b,a 
91f1			;	inc b 
91f1			;	cp b 
91f1			; 
91f1			;	pop bc 
91f1			;	ret 
91f1				 
91f1				 
91f1			 
91f1			 
91f1			; pass hl as the four byte address to load 
91f1			 
91f1			get_word_hl:  
91f1 e5				push hl 
91f2 cd 91 91			call get_byte 
91f5				 
91f5 47				ld b, a 
91f6			 
91f6 e1				pop hl 
91f7 23				inc hl 
91f8 23				inc hl 
91f9			 
91f9			; TODO not able to handle a-f  
91f9 7e				ld a,(hl) 
91fa			;	;cp ':' 
91fa			;	cp 'g' 
91fa			;	jr nc, .single_byte_hl 		; > 
91fa			;	cp 'G' 
91fa			;	jr nc, .single_byte_hl 		; > 
91fa			;	cp '0' 
91fa			;	jr c, .single_byte_hl		; < 
91fa			 
91fa				;call isdigithl 
91fa fe 00			cp 0 
91fc 28 06			jr z, .single_byte_hl 
91fe			 
91fe			.getwhln:   ; hex word so get next byte 
91fe			 
91fe cd 91 91			call get_byte 
9201 6f				ld l, a 
9202 60				ld h,b 
9203 c9				ret 
9204 68			.single_byte_hl:   ld l,b 
9205 26 00				ld h,0 
9207 c9					ret 
9208			 
9208			 
9208			 
9208			 
9208 21 95 99			ld hl,asc+1 
920b			;	ld a, (hl) 
920b			;	call nibble2val 
920b cd 91 91			call get_byte 
920e			 
920e			;	call fourehexhl 
920e 32 f5 e2			ld (scratch+52),a 
9211				 
9211 21 f3 e2			ld hl,scratch+50 
9214 22 e4 e5			ld (os_cur_ptr),hl 
9217			 
9217 c9				ret 
9218			 
9218			 
9218			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
9218			 
9218			; Decimal Unsigned Version 
9218			 
9218			;Number in a to decimal ASCII 
9218			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
9218			;Example: display a=56 as "056" 
9218			;input: a = number 
9218			;Output: a=0,value of a in the screen 
9218			;destroys af,bc (don't know about hl and de) 
9218			DispAToASCII: 
9218 0e 9c			ld	c,-100 
921a cd 24 92			call	.Na1 
921d 0e f6			ld	c,-10 
921f cd 24 92			call	.Na1 
9222 0e ff			ld	c,-1 
9224 06 2f		.Na1:	ld	b,'0'-1 
9226 04			.Na2:	inc	b 
9227 81				add	a,c 
9228 38 fc			jr	c,.Na2 
922a 91				sub	c		;works as add 100/10/1 
922b f5				push af		;safer than ld c,a 
922c 78				ld	a,b		;char is in b 
922d			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
922d f1				pop af		;safer than ld a,c 
922e c9				ret 
922f			 
922f			; Decimal Signed Version 
922f			 
922f			; DispA 
922f			; -------------------------------------------------------------- 
922f			; Converts a signed integer value to a zero-terminated ASCII 
922f			; string representative of that value (using radix 10). 
922f			; -------------------------------------------------------------- 
922f			; INPUTS: 
922f			;     HL     Value to convert (two's complement integer). 
922f			;     DE     Base address of string destination. (pointer). 
922f			; -------------------------------------------------------------- 
922f			; OUTPUTS: 
922f			;     None 
922f			; -------------------------------------------------------------- 
922f			; REGISTERS/MEMORY DESTROYED 
922f			; AF HL 
922f			; -------------------------------------------------------------- 
922f			 
922f			;DispHLToASCII: 
922f			;   push    de 
922f			;   push    bc 
922f			; 
922f			;; Detect sign of HL. 
922f			;    bit    7, h 
922f			;    jr     z, ._DoConvert 
922f			; 
922f			;; HL is negative. Output '-' to string and negate HL. 
922f			;    ld     a, '-' 
922f			;    ld     (de), a 
922f			;    inc    de 
922f			; 
922f			;; Negate HL (using two's complement) 
922f			;    xor    a 
922f			;    sub    l 
922f			;    ld     l, a 
922f			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
922f			;    sbc    a, h 
922f			;    ld     h, a 
922f			; 
922f			;; Convert HL to digit characters 
922f			;._DoConvert: 
922f			;    ld     b, 0     ; B will count character length of number 
922f			;-   ld     a, 10 
922f			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
922f			;    push   af 
922f			;    inc    b 
922f			;    ld     a, h 
922f			;    or     l 
922f			;    jr     nz, - 
922f			; 
922f			;; Retrieve digits from stack 
922f			;-   pop    af 
922f			;    or     $30 
922f			;    ld     (de), a 
922f			;    inc    de 
922f			;    djnz   - 
922f			; 
922f			;; Terminate string with NULL 
922f			;    xor    a 
922f			;    ld     (de), a 
922f			; 
922f			;    pop    bc 
922f			;    pop    de 
922f			;    ret 
922f			 
922f			;Comments 
922f			; 
922f			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
922f			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
922f			;    Note that the output string will not be fixed-width. 
922f			; 
922f			;Example Usage 
922f			; 
922f			;    ld    hl, -1004 
922f			;    ld    de, OP1 
922f			;    call  DispA 
922f			;    ld    hl, OP1 
922f			;    syscall  PutS 
922f			 
922f			 
922f			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
922f			 
922f			 
922f			;Converts an ASCII string to an unsigned 16-bit integer 
922f			;Quits when it reaches a non-decimal digit 
922f			 
922f			string_to_uint16: 
922f			atoui_16: 
922f			;Input: 
922f			;     DE points to the string 
922f			;Outputs: 
922f			;     HL is the result 
922f			;     A is the 8-bit value of the number 
922f			;     DE points to the byte after the number 
922f			;Destroys: 
922f			;     BC 
922f			;       if the string is non-empty, BC is HL/10 
922f			;Size:  24 bytes 
922f			;Speed: 42+d(104+{0,9}) 
922f			;       d is the number of digits in the number 
922f			;       max is 640 cycles for a 5 digit number 
922f			;Assuming no leading zeros: 
922f			;1 digit:  146cc 
922f			;2 digit:  250cc 
922f			;3 digit:  354cc or 363cc (avg: 354.126cc) 
922f			;4 digit:  458cc or 467cc (avg: 458.27cc) 
922f			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
922f			;avg: 544.81158447265625cc (544+13297/16384) 
922f			;=============================================================== 
922f 21 00 00		  ld hl,0 
9232			.u16a: 
9232 1a			  ld a,(de) 
9233 d6 30		  sub 30h 
9235 fe 0a		  cp 10 
9237 d0			  ret nc 
9238 13			  inc de 
9239 44			  ld b,h 
923a 4d			  ld c,l 
923b 29			  add hl,hl 
923c 29			  add hl,hl 
923d 09			  add hl,bc 
923e 29			  add hl,hl 
923f 85			  add a,l 
9240 6f			  ld l,a 
9241 30 ef		  jr nc,.u16a 
9243 24			  inc h 
9244 c3 32 92		  jp .u16a 
9247			 
9247			 
9247			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
9247			 
9247			;written by Zeda 
9247			;Converts a 16-bit unsigned integer to an ASCII string. 
9247			 
9247			uitoa_16: 
9247			;Input: 
9247			;   DE is the number to convert 
9247			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
9247			;Output: 
9247			;   HL points to the null-terminated ASCII string 
9247			;      NOTE: This isn't necessarily the same as the input HL. 
9247 d5			  push de 
9248 c5			  push bc 
9249 f5			  push af 
924a eb			  ex de,hl 
924b			 
924b 01 f0 d8		  ld bc,-10000 
924e 3e 2f		  ld a,'0'-1 
9250 3c			  inc a 
9251 09			  add hl,bc  
9252 38 fc		   jr c,$-2 
9254 12			  ld (de),a 
9255 13			  inc de 
9256			 
9256 01 e8 03		  ld bc,1000 
9259 3e 3a		  ld a,'9'+1 
925b 3d			  dec a  
925c 09			  add hl,bc  
925d 30 fc		   jr nc,$-2 
925f 12			  ld (de),a 
9260 13			  inc de 
9261			 
9261 01 9c ff		  ld bc,-100 
9264 3e 2f		  ld a,'0'-1 
9266 3c			  inc a  
9267 09			  add hl,bc  
9268 38 fc		   jr c,$-2 
926a 12			  ld (de),a 
926b 13			  inc de 
926c			 
926c 7d			  ld a,l 
926d 26 3a		  ld h,'9'+1 
926f 25			  dec h  
9270 c6 0a		  add a,10  
9272 30 fb		   jr nc,$-3 
9274 c6 30		  add a,'0' 
9276 eb			  ex de,hl 
9277 72			  ld (hl),d 
9278 23			  inc hl 
9279 77			  ld (hl),a 
927a 23			  inc hl 
927b 36 00		  ld (hl),0 
927d			 
927d			;Now strip the leading zeros 
927d 0e fa		  ld c,-6 
927f 09			  add hl,bc 
9280 3e 30		  ld a,'0' 
9282 23			  inc hl  
9283 be			  cp (hl)  
9284 28 fc		  jr z,$-2 
9286			 
9286			;Make sure that the string is non-empty! 
9286 7e			  ld a,(hl) 
9287 b7			  or a 
9288 20 01		  jr nz,.atoub 
928a 2b			  dec hl 
928b			.atoub: 
928b			 
928b f1			  pop af 
928c c1			  pop bc 
928d d1			  pop de 
928e c9			  ret 
928f			 
928f			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
928f			 
928f			toUpper: 
928f			;A is the char. 
928f			;If A is a lowercase letter, this sets it to the matching uppercase 
928f			;18cc or 30cc or 41cc 
928f			;avg: 26.75cc 
928f fe 61		  cp 'a' 
9291 d8			  ret c 
9292 fe 7b		  cp 'z'+1 
9294 d0			  ret nc 
9295 d6 20		  sub 'a'-'A' 
9297 c9			  ret 
9298			 
9298			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
9298			 
9298			; String Length 
9298			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
9298			 
9298			; Get the length of the null-terminated string starting at $8000 hl 
9298			;    LD     HL, $8000 
9298			 
9298			strlenz: 
9298			 
9298 af			    XOR    A               ; Zero is the value we are looking for. 
9299 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
929a 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
929b			                           ; 65, 536 bytes (the entire addressable memory space). 
929b ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
929d			 
929d			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
929d 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
929e 6f			    LD     L, A             ; number of bytes 
929f ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
92a1 2b			    DEC    HL              ; Compensate for null. 
92a2 c9				ret 
92a3			 
92a3			; Get the length of the A terminated string starting at $8000 hl 
92a3			;    LD     HL, $8000 
92a3			 
92a3			strlent: 
92a3			 
92a3			                  ; A is the value we are looking for. 
92a3 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
92a5 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
92a7			                           ; 65, 536 bytes (the entire addressable memory space). 
92a7 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
92a9			 
92a9			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
92a9 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
92ab 2e 00		    LD     L, 0             ; number of bytes 
92ad ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
92af 2b			    DEC    HL              ; Compensate for null. 
92b0 c9				ret 
92b1			 
92b1			 
92b1			;Comparing Strings 
92b1			 
92b1			;IN    HL     Address of string1. 
92b1			;      DE     Address of string2. 
92b1			 
92b1			; doc given but wrong??? 
92b1			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
92b1			;      carry  Set if string1 > string2, reset if string1 <= string2. 
92b1			; tested 
92b1			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
92b1			 
92b1			strcmp_old: 
92b1 e5			    PUSH   HL 
92b2 d5			    PUSH   DE 
92b3			 
92b3 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
92b4 be			    CP     (HL)            ; (want to minimize work). 
92b5 38 01		    JR     C, Str1IsBigger 
92b7 7e			    LD     A, (HL) 
92b8			 
92b8			Str1IsBigger: 
92b8 4f			    LD     C, A             ; Put length in BC 
92b9 06 00		    LD     B, 0 
92bb 13			    INC    DE              ; Increment pointers to meat of string. 
92bc 23			    INC    HL 
92bd			 
92bd			CmpLoop: 
92bd 1a			    LD     A, (DE)          ; Compare bytes. 
92be ed a1		    CPI 
92c0 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
92c2 13			    INC    DE              ; Update pointer. 
92c3 ea bd 92		    JP     PE, CmpLoop 
92c6			 
92c6 d1			    POP    DE 
92c7 e1			    POP    HL 
92c8 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
92c9 be			    CP     (HL) 
92ca c9			    RET 
92cb			 
92cb			NoMatch: 
92cb 2b			    DEC    HL 
92cc be			    CP     (HL)            ; Compare again to affect carry. 
92cd d1			    POP    DE 
92ce e1			    POP    HL 
92cf c9			    RET 
92d0			 
92d0			;; test strmp 
92d0			; 
92d0			;ld de, .str1 
92d0			;ld hl, .str2 
92d0			;call strcmp 
92d0			;jr z, .z1 
92d0			;;this 
92d0			;	if DEBUG_FORTH_WORDS 
92d0			;		DMARK "NZ1" 
92d0			;		CALLMONITOR 
92d0			;	endif 
92d0			;.z1: 
92d0			; 
92d0			;	if DEBUG_FORTH_WORDS 
92d0			;		DMARK "ZZ1" 
92d0			;		CALLMONITOR 
92d0			;	endif 
92d0			; 
92d0			;ld de, .str1 
92d0			;ld hl, .str1 
92d0			;call strcmp 
92d0			;jr z, .z2 
92d0			;;this 
92d0			;	if DEBUG_FORTH_WORDS 
92d0			;		DMARK "NZ2" 
92d0			;		CALLMONITOR 
92d0			;	endif 
92d0			;.z2: 
92d0			; 
92d0			;	if DEBUG_FORTH_WORDS 
92d0			;		DMARK "ZZ2" 
92d0			;		CALLMONITOR 
92d0			;	endif 
92d0			; 
92d0			;ld de, .str1 
92d0			;ld hl, .str2 
92d0			;call strcmp 
92d0			;jr c, .c1 
92d0			; 
92d0			;	if DEBUG_FORTH_WORDS 
92d0			;		DMARK "Nc1" 
92d0			;		CALLMONITOR 
92d0			;	endif 
92d0			;.c1: 
92d0			;;this 
92d0			;	if DEBUG_FORTH_WORDS 
92d0			;		DMARK "cc1" 
92d0			;		CALLMONITOR 
92d0			;	endif 
92d0			; 
92d0			;ld de, .str1 
92d0			;ld hl, .str1 
92d0			;call strcmp 
92d0			;jr c, .c2 
92d0			;;this 
92d0			;	if DEBUG_FORTH_WORDS 
92d0			;		DMARK "Nc2" 
92d0			;		CALLMONITOR 
92d0			;	endif 
92d0			;.c2: 
92d0			; 
92d0			;	if DEBUG_FORTH_WORDS 
92d0			;		DMARK "cc2" 
92d0			;		CALLMONITOR 
92d0			;	endif 
92d0			;	NEXTW 
92d0			;.str1:   db "string1",0 
92d0			;.str2:   db "string2",0 
92d0			 
92d0			; only care about direct match or not 
92d0			; hl and de strings 
92d0			; zero set if the same 
92d0			 
92d0			strcmp: 
92d0 1a				ld a, (de) 
92d1 be				cp (hl) 
92d2 28 02			jr z, .ssame 
92d4 b7				or a 
92d5 c9				ret 
92d6			 
92d6			.ssame:  
92d6 fe 00			cp 0 
92d8 c8				ret z 
92d9			 
92d9 23				inc hl 
92da 13				inc de 
92db 18 f3			jr strcmp 
92dd				 
92dd				 
92dd			 
92dd			;Copyright (c) 2014, Luke Maurits 
92dd			;All rights reserved. 
92dd			; 
92dd			;Redistribution and use in source and binary forms, with or without 
92dd			;modification, are permitted provided that the following conditions are met: 
92dd			; 
92dd			;* Redistributions of source code must retain the above copyright notice, this 
92dd			;  list of conditions and the following disclaimer. 
92dd			; 
92dd			;* Redistributions in binary form must reproduce the above copyright notice, 
92dd			;  this list of conditions and the following disclaimer in the documentation 
92dd			;  and/or other materials provided with the distribution. 
92dd			; 
92dd			;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
92dd			;AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
92dd			;IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
92dd			;DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE 
92dd			;FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
92dd			;DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
92dd			;SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
92dd			;CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
92dd			;OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
92dd			;OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
92dd			 
92dd			; https://github.com/lmaurits/lm512/blob/master/string.z80 
92dd			 
92dd			StrictStrCmp: 
92dd				; Load next chars of each string 
92dd 1a				ld a, (de) 
92de 47				ld b, a 
92df 7e				ld a, (hl) 
92e0				; Compare 
92e0 b8				cp b 
92e1				; Return non-zero if chars don't match 
92e1 c0				ret nz 
92e2				; Check for end of both strings 
92e2 fe 00			cp "\0" 
92e4				; Return if strings have ended 
92e4 c8				ret z 
92e5				; Otherwise, advance to next chars 
92e5 23				inc hl 
92e6 13				inc de 
92e7 18 f4			jr StrictStrCmp 
92e9			 
92e9			;end 
92e9			; eof 
92e9			 
92e9			 
92e9			 
92e9			 
92e9			 
92e9			 
# End of file firmware_strings.asm
92e9			include "firmware_memory.asm"   ; malloc and free  
92e9			 
92e9			if DEBUG_FORTH_MALLOC_HIGH 
92e9			.mallocsize: db "Wants malloc >256",0 
92e9			.mallocasize: db "MALLOC gives >256",0 
92e9			.malloczero: db "MALLOC gives zero",0 
92e9			 
92e9			malloc_guard_zerolen: 
92e9				push hl 
92e9				push de 
92e9				push af 
92e9			 
92e9				ld de, 0 
92e9			        call cmp16 
92e9				jr nz, .lowalloz 
92e9			 
92e9				push hl 
92e9				push de 
92e9					ld hl, display_fb0 
92e9					ld (display_fb_active), hl 
92e9				call clear_display 
92e9				ld a, 0 
92e9				ld de, .malloczero 
92e9				call str_at_display 
92e9				call update_display 
92e9				call delay1s 
92e9				call delay1s 
92e9				call bp_on 
92e9			;	ld a, 0 
92e9			;	ld (os_view_disable), a 
92e9			 
92e9				pop de 
92e9				pop hl 
92e9			 
92e9				 
92e9			 
92e9				CALLMONITOR 
92e9			.lowalloz: 
92e9			 
92e9			 
92e9				pop af 
92e9				pop de 
92e9				pop hl 
92e9			ret 
92e9			 
92e9			malloc_guard_entry: 
92e9				push hl 
92e9				push de 
92e9				push af 
92e9			 
92e9			 	or a      ;clear carry flag 
92e9				push hl 
92e9				ld de, 255 
92e9				sbc hl, de 
92e9				jr c, .lowalloc 
92e9			 
92e9				push de 
92e9					ld hl, display_fb0 
92e9					ld (display_fb_active), hl 
92e9				call clear_display 
92e9				ld a, 0 
92e9				ld de, .mallocsize 
92e9				call str_at_display 
92e9				call update_display 
92e9				call delay1s 
92e9				call delay1s 
92e9			;	ld a, 0 
92e9			;	ld (os_view_disable), a 
92e9				call bp_on 
92e9			 
92e9				pop de 
92e9				pop hl 
92e9			 
92e9				 
92e9			 
92e9				CALLMONITOR 
92e9				jr .lowdone 
92e9			.lowalloc: 
92e9			 
92e9			 
92e9				pop hl 
92e9			.lowdone:	pop af 
92e9				pop de 
92e9				pop hl 
92e9			ret 
92e9			 
92e9			malloc_guard_exit: 
92e9				push hl 
92e9				push de 
92e9				push af 
92e9			 
92e9			 	or a      ;clear carry flag 
92e9				push hl 
92e9				ld de, 255 
92e9				sbc hl, de 
92e9				jr c, .lowallocx 
92e9			 
92e9				push de 
92e9					ld hl, display_fb0 
92e9					ld (display_fb_active), hl 
92e9				call clear_display 
92e9				ld a, 0 
92e9				ld de, .mallocasize 
92e9				call str_at_display 
92e9				call update_display 
92e9				call delay1s 
92e9				call delay1s 
92e9			;	ld a, 0 
92e9			;	ld (os_view_disable), a 
92e9				call bp_on 
92e9				pop de 
92e9				pop hl 
92e9			 
92e9				CALLMONITOR 
92e9				jr .lowdonex 
92e9			.lowallocx: 
92e9			 
92e9				pop hl 
92e9			.lowdonex:	pop af 
92e9				pop de 
92e9				pop hl 
92e9			ret 
92e9			endif 
92e9			 
92e9			if MALLOC_2 
92e9			; Z80 Malloc and Free Functions 
92e9			 
92e9			; Malloc Function: 
92e9			; Input: 
92e9			;   HL: Size of block to allocate 
92e9			; Output: 
92e9			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
92e9			 
92e9			malloc: 
92e9				 
92e9			if DEBUG_FORTH_MALLOC_HIGH 
92e9			call malloc_guard_entry 
92e9			endif 
92e9			 
92e9			 
92e9			 
92e9			 
92e9					if DEBUG_FORTH_MALLOC 
92e9						DMARK "mal" 
92e9						CALLMONITOR 
92e9					endif 
92e9			    push af            ; Save AF register 
92e9			    ld a, l            ; Load low byte of size into A 
92e9			    or h               ; Check if size is zero 
92e9			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
92e9			 
92e9			    ; Allocate memory 
92e9			    ld hl, (heap_start) ; Load start of heap into HL 
92e9					if DEBUG_FORTH_MALLOC 
92e9						DMARK "ma1" 
92e9						CALLMONITOR 
92e9					endif 
92e9			    call malloc_internal ; Call internal malloc function 
92e9			    pop af             ; Restore AF register 
92e9			if DEBUG_FORTH_MALLOC_HIGH 
92e9			call malloc_guard_exit 
92e9			call malloc_guard_zerolen 
92e9			endif 
92e9			    ret                ; Return 
92e9			 
92e9			; Free Function: 
92e9			; Input: 
92e9			;   HL: Pointer to memory block to free 
92e9			; Output: 
92e9			;   None 
92e9			 
92e9			free: 
92e9			    push af            ; Save AF register 
92e9			    ld a, l            ; Load low byte of pointer into A 
92e9			    or h               ; Check if pointer is NULL 
92e9			    jp z, free_exit    ; If pointer is NULL, exit 
92e9			 
92e9			    ; Free memory 
92e9			    ld hl, (heap_start) ; Load start of heap into HL 
92e9			    call free_internal  ; Call internal free function 
92e9			    pop af             ; Restore AF register 
92e9			    ret                ; Return 
92e9			 
92e9			; Internal Malloc Function: 
92e9			; Input: 
92e9			;   HL: Size of block to allocate 
92e9			; Output: 
92e9			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
92e9			 
92e9			malloc_internal: 
92e9			    ld bc, 2           ; Number of bytes to allocate for management overhead 
92e9			    add hl, bc         ; Add management overhead to requested size 
92e9			    ex de, hl          ; Save total size in DE, and keep it in HL 
92e9					if DEBUG_FORTH_MALLOC 
92e9						DMARK "ma2" 
92e9						CALLMONITOR 
92e9					endif 
92e9			 
92e9			    ; Search for free memory block 
92e9			    ld de, (heap_end)  ; Load end of heap into DE 
92e9			    ld bc, 0           ; Initialize counter 
92e9			 
92e9					if DEBUG_FORTH_MALLOC 
92e9						DMARK "ma2" 
92e9						CALLMONITOR 
92e9					endif 
92e9			malloc_search_loop: 
92e9			    ; Check if current block is free 
92e9			    ld a, (hl)         ; Load current block's status (free or used) 
92e9			    cp 0               ; Compare with zero (free) 
92e9			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
92e9			 
92e9			    ; Check if current block is large enough 
92e9			    ld a, (hl+1)       ; Load high byte of block size 
92e9			    cp l               ; Compare with low byte of requested size 
92e9			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
92e9			 
92e9			    ld a, (hl+2)       ; Load low byte of block size 
92e9			    cp h               ; Compare with high byte of requested size 
92e9			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
92e9			 
92e9			    ; Mark block as used 
92e9			    ld (hl), 0xFF      ; Set status byte to indicate used block 
92e9			 
92e9			    ; Calculate remaining space in block 
92e9			    ld bc, 0           ; Clear BC 
92e9			    add hl, bc         ; Increment HL to point to start of data block 
92e9			    add hl, de         ; HL = HL + DE (total size) 
92e9			    ld bc, 1           ; Number of bytes to allocate for management overhead 
92e9			    add hl, bc         ; Add management overhead to start of data block 
92e9			 
92e9			    ; Save pointer to allocated block in HL 
92e9			if DEBUG_FORTH_MALLOC_HIGH 
92e9						DMARK "ma5" 
92e9			call malloc_guard_exit 
92e9			call malloc_guard_zerolen 
92e9			endif 
92e9			    ret 
92e9			 
92e9			malloc_skip_block_check: 
92e9			    ; Move to the next block 
92e9			    ld bc, 3           ; Size of management overhead 
92e9			    add hl, bc         ; Move to the next block 
92e9			    inc de             ; Increment counter 
92e9			 
92e9			    ; Check if we have reached the end of heap 
92e9			    ld a, e            ; Load low byte of heap end address 
92e9			    cp (hl)            ; Compare with low byte of current address 
92e9			    jr nz, malloc_search_loop  ; If not equal, continue searching 
92e9			    ld a, d            ; Load high byte of heap end address 
92e9			    cp 0               ; Check if it's zero (end of memory) 
92e9			    jr nz, malloc_search_loop  ; If not zero, continue searching 
92e9			 
92e9			    ; If we reached here, allocation failed 
92e9			    xor a              ; Set result to NULL 
92e9			if DEBUG_FORTH_MALLOC_HIGH 
92e9						DMARK "ma6" 
92e9			call malloc_guard_exit 
92e9			call malloc_guard_zerolen 
92e9			endif 
92e9			    ret 
92e9			malloc_exit: 
92e9			if DEBUG_FORTH_MALLOC_HIGH 
92e9						DMARK "ma7" 
92e9			call malloc_guard_exit 
92e9			call malloc_guard_zerolen 
92e9			endif 
92e9			    ret 
92e9			 
92e9			; Internal Free Function: 
92e9			; Input: 
92e9			;   HL: Pointer to memory block to free 
92e9			; Output: 
92e9			;   None 
92e9			 
92e9			free_internal: 
92e9			    ld de, (heap_start) ; Load start of heap into DE 
92e9			    ld bc, 0            ; Initialize counter 
92e9			 
92e9			free_search_loop: 
92e9			    ; Check if current block contains the pointer 
92e9			    ld a, l             ; Load low byte of pointer 
92e9			    cp (hl+1)           ; Compare with high byte of current block's address 
92e9			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
92e9			    ld a, h             ; Load high byte of pointer 
92e9			    cp (hl+2)           ; Compare with low byte of current block's address 
92e9			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
92e9			 
92e9			    ; Mark block as free 
92e9			    ld (hl), 0          ; Set status byte to indicate free block 
92e9			    ret                 ; Return 
92e9			 
92e9			free_skip_block_check: 
92e9			    ; Move to the next block 
92e9			    ld bc, 3            ; Size of management overhead 
92e9			    add hl, bc          ; Move to the next block 
92e9			    inc de              ; Increment counter 
92e9			 
92e9			    ; Check if we have reached the end of heap 
92e9			    ld a, e             ; Load low byte of heap end address 
92e9			    cp (hl)             ; Compare with low byte of current address 
92e9			    jr nz, free_search_loop  ; If not equal, continue searching 
92e9			    ld a, d             ; Load high byte of heap end address 
92e9			    cp 0                ; Check if it's zero (end of memory) 
92e9			    jr nz, free_search_loop  ; If not zero, continue searching 
92e9			 
92e9			    ; If we reached here, pointer is not found in heap 
92e9			    ret 
92e9			 
92e9			free_exit: 
92e9			    ret                 ; Return 
92e9			 
92e9			; Define heap start and end addresses 
92e9			;heap_start:    .dw 0xC000   ; Start of heap 
92e9			;heap_end:      .dw 0xE000   ; End of heap 
92e9			 
92e9			endif 
92e9			 
92e9			 
92e9			if MALLOC_1 
92e9			 
92e9			 
92e9			 
92e9			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
92e9			 
92e9			;moved to firmware.asm 
92e9			;heap_start        .equ  0x9000      ; Starting address of heap 
92e9			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
92e9			 
92e9			;      .org 0 
92e9			;      jp    main 
92e9			 
92e9			 
92e9			;      .org  0x100 
92e9			;main: 
92e9			;      ld    HL, 0x8100 
92e9			;      ld    SP, HL 
92e9			; 
92e9			;      call  heap_init 
92e9			; 
92e9			;      ; Make some allocations 
92e9			;      ld    HL, 12 
92e9			;      call  malloc            ; Allocates 0x9004 
92e9			; 
92e9			;      ld    HL, 12 
92e9			;      call  malloc            ; Allocates 0x9014 
92e9			; 
92e9			;      ld    HL, 12 
92e9			;      call  malloc            ; Allocates 0x9024 
92e9			; 
92e9			;      ; Free some allocations 
92e9			;      ld    HL, 0x9014 
92e9			;      call  free 
92e9			; 
92e9			;      ld    HL, 0x9004 
92e9			;      call  free 
92e9			; 
92e9			;      ld    HL, 0x9024 
92e9			;      call  free 
92e9			; 
92e9			; 
92e9			;      halt 
92e9			 
92e9			 
92e9			;------------------------------------------------------------------------------ 
92e9			;     heap_init                                                               : 
92e9			;                                                                             : 
92e9			; Description                                                                 : 
92e9			;     Initialise the heap and make it ready for malloc and free operations.   : 
92e9			;                                                                             : 
92e9			;     The heap is maintained as a linked list, starting with an initial       : 
92e9			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
92e9			;     the first free block in the heap. Each block then points to the next    : 
92e9			;     free block within the heap, and the free list ends at the first block   : 
92e9			;     with a null pointer to the next free block.                             : 
92e9			;                                                                             : 
92e9			; Parameters                                                                  : 
92e9			;     Inputs are compile-time only. Two defines which specify the starting    : 
92e9			;     address of the heap and its size are required, along with a memory      : 
92e9			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
92e9			;     principally stores a pointer to the first free block in the heap.       : 
92e9			;                                                                             : 
92e9			; Returns                                                                     : 
92e9			;     Nothing                                                                 : 
92e9			;------------------------------------------------------------------------------ 
92e9			heap_init: 
92e9 e5			      push  HL 
92ea			 
92ea			      ; Initialise free list struct 
92ea 21 52 e6		      ld    HL, heap_start 
92ed 22 4d e6		      ld    (free_list), HL 
92f0 21 00 00		      ld    HL, 0 
92f3 22 4f e6		      ld    (free_list+2), HL 
92f6			 
92f6			      ; Insert first free block at bottom of heap, consumes entire heap 
92f6 21 98 e2		      ld    HL, heap_start+heap_size-4 
92f9 22 52 e6		      ld    (heap_start), HL        ; Next block (end of free list) 
92fc 21 46 fc		      ld    HL, heap_size-4 
92ff 22 54 e6		      ld    (heap_start+2), HL      ; Block size 
9302			 
9302			      ; Insert end of free list block at top of heap - two null words will 
9302			      ; terminate the free list 
9302 21 00 00		      ld    HL, 0 
9305 22 9a e2		      ld    (heap_start+heap_size-2), HL 
9308 22 98 e2		      ld    (heap_start+heap_size-4), HL 
930b			 
930b e1			      pop   HL 
930c			 
930c c9			      ret 
930d			 
930d			 
930d			;------------------------------------------------------------------------------ 
930d			;     malloc                                                                  : 
930d			;                                                                             : 
930d			; Description                                                                 : 
930d			;     Allocates the wanted space from the heap and returns the address of the : 
930d			;     first useable byte of the allocation.                                   : 
930d			;                                                                             : 
930d			;     Allocations can happen in one of two ways:                              : 
930d			;                                                                             : 
930d			;     1. A free block may be found which is the exact size wanted. In this    : 
930d			;        case the block is removed from the free list and retuedn to the      : 
930d			;        caller.                                                              : 
930d			;     2. A free block may be found which is larger than the size wanted. In   : 
930d			;        this case, the larger block is split into two. The first portion of  : 
930d			;        this block will become the requested space by the malloc call and    : 
930d			;        is returned to the caller. The second portion becomes a new free     : 
930d			;        block, and the free list is adjusted to maintain continuity via this : 
930d			;        newly created block.                                                 : 
930d			;                                                                             : 
930d			;     malloc does not set any initial value in the allocated space, the       : 
930d			;     caller is required to do this as required.                              : 
930d			;                                                                             : 
930d			;     This implementation of malloc uses the stack exclusively, and is        : 
930d			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
930d			;     advisable to disable interrupts before calling malloc, and recommended  : 
930d			;     to avoid the use of malloc inside ISRs in general.                      : 
930d			;                                                                             : 
930d			;     NOTE: heap_init must be called before malloc and free can be used.      : 
930d			;                                                                             : 
930d			; Parameters                                                                  : 
930d			;     HL  Number of bytes wanted                                              : 
930d			;                                                                             : 
930d			; Returns                                                                     : 
930d			;     HL  Address of the first useable byte of the allocation                 : 
930d			;                                                                             : 
930d			; Flags                                                                       : 
930d			;     Z   Set if the allocation did not succeed, clear otherwise              : 
930d			;                                                                             : 
930d			; Stack frame                                                                 : 
930d			;       |             |                                                       : 
930d			;       +-------------+                                                       : 
930d			;       |     BC      |                                                       : 
930d			;       +-------------+                                                       : 
930d			;       |     DE      |                                                       : 
930d			;       +-------------+                                                       : 
930d			;       |     IX      |                                                       : 
930d			;       +-------------+                                                       : 
930d			;       |  prev_free  |                                                       : 
930d			;   +4  +-------------+                                                       : 
930d			;       |  this_free  |                                                       : 
930d			;   +2  +-------------+                                                       : 
930d			;       |  next_free  |                                                       : 
930d			;   +0  +-------------+                                                       : 
930d			;       |             |                                                       : 
930d			;                                                                             : 
930d			;------------------------------------------------------------------------------ 
930d			 
930d			 
930d			;malloc: 
930d			; 
930d			;	SAVESP ON 1 
930d			; 
930d			;	call malloc_code 
930d			; 
930d			;	CHECKSP ON 1 
930d			;	ret 
930d			 
930d			 
930d			malloc: 
930d c5			      push  BC 
930e d5			      push  DE 
930f dd e5		      push  IX 
9311			if DEBUG_FORTH_MALLOC_HIGH 
9311			call malloc_guard_entry 
9311			endif 
9311			 
9311					if DEBUG_FORTH_MALLOC 
9311						DMARK "mal" 
9311						CALLMONITOR 
9311					endif 
9311 7c			      ld    A, H                    ; Exit if no space requested 
9312 b5			      or    L 
9313 ca d2 93		      jp    Z, malloc_early_exit 
9316			 
9316			;inc hl 
9316			;inc hl 
9316			;inc hl 
9316			; 
9316			;inc hl 
9316			;inc hl 
9316			;inc hl 
9316			;inc hl 
9316			;inc hl 
9316			;inc hl 
9316			;inc hl 
9316			;inc hl 
9316			;inc hl 
9316			 
9316			 
9316			 
9316			 
9316					if DEBUG_FORTH_MALLOC 
9316						DMARK "maA" 
9316						CALLMONITOR 
9316					endif 
9316			      ; Set up stack frame 
9316 eb			      ex    DE, HL 
9317 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
931a 39			      add   HL, SP 
931b f9			      ld    SP, HL 
931c dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
9320 dd 39		      add   IX, SP 
9322			 
9322			      ; Setup initial state 
9322 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
9325 19			      add   HL, DE 
9326			 
9326 44			      ld    B, H                    ; Move want to BC 
9327 4d			      ld    C, L 
9328			 
9328 21 4d e6		      ld    HL, free_list           ; Store prev_free ptr to stack 
932b dd 75 04		      ld    (IX+4), L 
932e dd 74 05		      ld    (IX+5), H 
9331			 
9331 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
9332 23			      inc   HL 
9333 56			      ld    D, (HL) 
9334 dd 73 02		      ld    (IX+2), E 
9337 dd 72 03		      ld    (IX+3), D 
933a eb			      ex    DE, HL                  ; this_free ptr into HL 
933b			 
933b					if DEBUG_FORTH_MALLOC 
933b						DMARK "maB" 
933b						CALLMONITOR 
933b					endif 
933b			      ; Loop through free block list to find some space 
933b			malloc_find_space: 
933b 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
933c 23			      inc   HL 
933d 56			      ld    D, (HL) 
933e			 
933e 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
933f b3			      or    E 
9340 ca cc 93		      jp    Z, malloc_no_space 
9343			 
9343 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
9346 dd 72 01		      ld    (IX+1), D 
9349			 
9349			      ; Does this block have enough space to make the allocation? 
9349 23			      inc   HL                      ; Load free block size into DE 
934a 5e			      ld    E, (HL) 
934b 23			      inc   HL 
934c 56			      ld    D, (HL) 
934d			 
934d eb			      ex    DE, HL                  ; Check size of block against want 
934e b7			      or    A                       ; Ensure carry flag clear 
934f ed 42		      sbc   HL, BC 
9351 e5			      push  HL                      ; Store the result for later (new block size) 
9352			 
9352 ca a1 93		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
9355 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
9357			 
9357			      ; this_free block is not big enough, setup ptrs to test next free block 
9357 e1			      pop   HL                      ; Discard previous result 
9358			 
9358 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
935b dd 66 03		      ld    H, (IX+3) 
935e dd 75 04		      ld    (IX+4), L 
9361 dd 74 05		      ld    (IX+5), H 
9364			 
9364 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
9367 dd 66 01		      ld    H, (IX+1) 
936a dd 75 02		      ld    (IX+2), L 
936d dd 74 03		      ld    (IX+3), H 
9370			 
9370					if DEBUG_FORTH_MALLOC 
9370						DMARK "MA>" 
9370						CALLMONITOR 
9370					endif 
9370 18 c9		      jr    malloc_find_space 
9372			 
9372			      ; split a bigger block into two - requested size and remaining size 
9372			malloc_alloc_split: 
9372					if DEBUG_FORTH_MALLOC 
9372						DMARK "MAs" 
9372						CALLMONITOR 
9372					endif 
9372 eb			      ex    DE, HL                  ; Calculate address of new free block 
9373 2b			      dec   HL 
9374 2b			      dec   HL 
9375 2b			      dec   HL 
9376 09			      add   HL, BC 
9377			 
9377			      ; Create a new block and point it at next_free 
9377 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
937a dd 56 01		      ld    D, (IX+1) 
937d			 
937d 73			      ld    (HL), E                 ; Store next_free ptr into new block 
937e 23			      inc   HL 
937f 72			      ld    (HL), D 
9380			 
9380 d1			      pop   DE                      ; Store size of new block into new block 
9381 23			      inc   HL 
9382 73			      ld    (HL), E 
9383 23			      inc   HL 
9384 72			      ld    (HL), D 
9385			 
9385			      ; Update this_free ptr to point to new block 
9385 2b			      dec   HL 
9386 2b			      dec   HL 
9387 2b			      dec   HL 
9388			 
9388 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
938b dd 56 03		      ld    D, (IX+3) 
938e			 
938e dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
9391 dd 74 03		      ld    (IX+3), H 
9394			 
9394			      ; Modify this_free block to be allocation 
9394 eb			      ex    DE, HL 
9395 af			      xor   A                       ; Null the next block ptr of allocated block 
9396 77			      ld    (HL), A 
9397 23			      inc   HL 
9398 77			      ld    (HL), A 
9399			 
9399 23			      inc   HL                      ; Store want size into allocated block 
939a 71			      ld    (HL), C 
939b 23			      inc   HL 
939c 70			      ld    (HL), B 
939d 23			      inc   HL 
939e e5			      push  HL                      ; Address of allocation to return 
939f			 
939f 18 19		      jr    malloc_update_links 
93a1			 
93a1			malloc_alloc_fit: 
93a1 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
93a2			 
93a2					if DEBUG_FORTH_MALLOC 
93a2						DMARK "MAf" 
93a2						CALLMONITOR 
93a2					endif 
93a2			      ; Modify this_free block to be allocation 
93a2 eb			      ex    DE, HL 
93a3 2b			      dec   HL 
93a4 2b			      dec   HL 
93a5 2b			      dec   HL 
93a6			 
93a6 af			      xor   A                       ; Null the next block ptr of allocated block 
93a7 77			      ld    (HL), A 
93a8 23			      inc   HL 
93a9 77			      ld    (HL), A 
93aa			 
93aa 23			      inc   HL                      ; Store address of allocation to return 
93ab 23			      inc   HL 
93ac 23			      inc   HL 
93ad e5			      push  HL 
93ae			 
93ae			      ; Copy next_free ptr to this_free, remove allocated block from free list 
93ae dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
93b1 dd 66 01		      ld    H, (IX+1) 
93b4			 
93b4 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
93b7 dd 74 03		      ld    (IX+3), H 
93ba			 
93ba			 
93ba			malloc_update_links: 
93ba			      ; Update prev_free ptr to point to this_free 
93ba dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
93bd dd 66 05		      ld    H, (IX+5) 
93c0			 
93c0 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
93c3 dd 56 03		      ld    D, (IX+3) 
93c6			 
93c6 73			      ld    (HL), E                 ; this_free ptr into prev_free 
93c7 23			      inc   HL 
93c8 72			      ld    (HL), D 
93c9			 
93c9					if DEBUG_FORTH_MALLOC 
93c9						DMARK "Mul" 
93c9						CALLMONITOR 
93c9					endif 
93c9			      ; Clear the Z flag to indicate successful allocation 
93c9 7a			      ld    A, D 
93ca b3			      or    E 
93cb			 
93cb d1			      pop   DE                      ; Address of allocation 
93cc					if DEBUG_FORTH_MALLOC 
93cc						DMARK "MAu" 
93cc						CALLMONITOR 
93cc					endif 
93cc			 
93cc			malloc_no_space: 
93cc 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
93cf 39			      add   HL, SP 
93d0 f9			      ld    SP, HL 
93d1			 
93d1 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
93d2					if DEBUG_FORTH_MALLOC 
93d2						DMARK "MAN" 
93d2						CALLMONITOR 
93d2					endif 
93d2			 
93d2			malloc_early_exit: 
93d2					if DEBUG_FORTH_MALLOC 
93d2						DMARK "MAx" 
93d2						CALLMONITOR 
93d2					endif 
93d2 dd e1		      pop   IX 
93d4 d1			      pop   DE 
93d5 c1			      pop   BC 
93d6			 
93d6			if DEBUG_FORTH_MALLOC_HIGH 
93d6			call malloc_guard_exit 
93d6			call malloc_guard_zerolen 
93d6			endif 
93d6 c9			      ret 
93d7			 
93d7			 
93d7			;------------------------------------------------------------------------------ 
93d7			;     free                                                                    : 
93d7			;                                                                             : 
93d7			; Description                                                                 : 
93d7			;     Return the space pointed to by HL to the heap. HL must be an address as : 
93d7			;     returned by malloc, otherwise the behaviour is undefined.               : 
93d7			;                                                                             : 
93d7			;     Where possible, directly adjacent free blocks will be merged together   : 
93d7			;     into larger blocks to help ensure that the heap does not become         : 
93d7			;     excessively fragmented.                                                 : 
93d7			;                                                                             : 
93d7			;     free does not clear or set any other value into the freed space, and    : 
93d7			;     therefore its contents may be visible through subsequent malloc's. The  : 
93d7			;     caller should clear the freed space as required.                        : 
93d7			;                                                                             : 
93d7			;     This implementation of free uses the stack exclusively, and is          : 
93d7			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
93d7			;     advisable to disable interrupts before calling free, and recommended    : 
93d7			;     to avoid the use of free inside ISRs in general.                        : 
93d7			;                                                                             : 
93d7			;     NOTE: heap_init must be called before malloc and free can be used.      : 
93d7			;                                                                             : 
93d7			; Parameters                                                                  : 
93d7			;     HL  Pointer to address of first byte of allocation to be freed          : 
93d7			;                                                                             : 
93d7			; Returns                                                                     : 
93d7			;     Nothing                                                                 : 
93d7			;                                                                             : 
93d7			; Stack frame                                                                 : 
93d7			;       |             |                                                       : 
93d7			;       +-------------+                                                       : 
93d7			;       |     BC      |                                                       : 
93d7			;       +-------------+                                                       : 
93d7			;       |     DE      |                                                       : 
93d7			;       +-------------+                                                       : 
93d7			;       |     IX      |                                                       : 
93d7			;       +-------------+                                                       : 
93d7			;       |  prev_free  |                                                       : 
93d7			;   +2  +-------------+                                                       : 
93d7			;       |  next_free  |                                                       : 
93d7			;   +0  +-------------+                                                       : 
93d7			;       |             |                                                       : 
93d7			;                                                                             : 
93d7			;------------------------------------------------------------------------------ 
93d7			free: 
93d7 c5			      push  BC 
93d8 d5			      push  DE 
93d9 dd e5		      push  IX 
93db			 
93db 7c			      ld    A, H                    ; Exit if ptr is null 
93dc b5			      or    L 
93dd ca a1 94		      jp    Z, free_early_exit 
93e0			 
93e0			      ; Set up stack frame 
93e0 eb			      ex    DE, HL 
93e1 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
93e4 39			      add   HL, SP 
93e5 f9			      ld    SP, HL 
93e6 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
93ea dd 39		      add   IX, SP 
93ec			 
93ec			      ; The address in HL points to the start of the useable allocated space, 
93ec			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
93ec			      ; address of the block itself. 
93ec eb			      ex    DE, HL 
93ed 11 fc ff		      ld    DE, -4 
93f0 19			      add   HL, DE 
93f1			 
93f1			      ; An allocated block must have a null next block pointer in it 
93f1 7e			      ld    A, (HL) 
93f2 23			      inc   HL 
93f3 b6			      or    (HL) 
93f4 c2 9c 94		      jp    NZ, free_done 
93f7			 
93f7 2b			      dec   HL 
93f8			 
93f8 44			      ld    B, H                    ; Copy HL to BC 
93f9 4d			      ld    C, L 
93fa			 
93fa			      ; Loop through the free list to find the first block with an address 
93fa			      ; higher than the block being freed 
93fa 21 4d e6		      ld    HL, free_list 
93fd			 
93fd			free_find_higher_block: 
93fd 5e			      ld    E, (HL)                 ; Load next ptr from free block 
93fe 23			      inc   HL 
93ff 56			      ld    D, (HL) 
9400 2b			      dec   HL 
9401			 
9401 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
9404 dd 72 01		      ld    (IX+1), D 
9407 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
940a dd 74 03		      ld    (IX+3), H 
940d			 
940d 78			      ld    A, B                    ; Check if DE is greater than BC 
940e ba			      cp    D                       ; Compare MSB first 
940f 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
9411 30 04		      jr    NC, free_find_higher_block_skip 
9413 79			      ld    A, C 
9414 bb			      cp    E                       ; Then compare LSB 
9415 38 08		      jr    C, free_found_higher_block 
9417			 
9417			free_find_higher_block_skip: 
9417 7a			      ld    A, D                    ; Reached the end of the free list? 
9418 b3			      or    E 
9419 ca 9c 94		      jp    Z, free_done 
941c			 
941c eb			      ex    DE, HL 
941d			 
941d 18 de		      jr    free_find_higher_block 
941f			 
941f			free_found_higher_block: 
941f			      ; Insert freed block between prev and next free blocks 
941f 71			      ld    (HL), C                 ; Point prev free block to freed block 
9420 23			      inc   HL 
9421 70			      ld    (HL), B 
9422			 
9422 60			      ld    H, B                    ; Point freed block at next free block 
9423 69			      ld    L, C 
9424 73			      ld    (HL), E 
9425 23			      inc   HL 
9426 72			      ld    (HL), D 
9427			 
9427			      ; Check if the freed block is adjacent to the next free block 
9427 23			      inc   HL                      ; Load size of freed block into HL 
9428 5e			      ld    E, (HL) 
9429 23			      inc   HL 
942a 56			      ld    D, (HL) 
942b eb			      ex    DE, HL 
942c			 
942c 09			      add   HL, BC                  ; Add addr of freed block and its size 
942d			 
942d dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
9430 dd 56 01		      ld    D, (IX+1) 
9433			 
9433 b7			      or    A                       ; Clear the carry flag 
9434 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
9436 20 22		      jr    NZ, free_check_adjacent_to_prev 
9438			 
9438			      ; Freed block is adjacent to next, merge into one bigger block 
9438 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
9439 5e			      ld    E, (HL) 
943a 23			      inc   HL 
943b 56			      ld    D, (HL) 
943c e5			      push  HL                      ; Save ptr to next block for later 
943d			 
943d 60			      ld    H, B                    ; Store ptr from next block into freed block 
943e 69			      ld    L, C 
943f 73			      ld    (HL), E 
9440 23			      inc   HL 
9441 72			      ld    (HL), D 
9442			 
9442 e1			      pop   HL                      ; Restore ptr to next block 
9443 23			      inc   HL                      ; Load size of next block into DE 
9444 5e			      ld    E, (HL) 
9445 23			      inc   HL 
9446 56			      ld    D, (HL) 
9447 d5			      push  DE                      ; Save next block size for later 
9448			 
9448 60			      ld    H, B                    ; Load size of freed block into HL 
9449 69			      ld    L, C 
944a 23			      inc   HL 
944b 23			      inc   HL 
944c 5e			      ld    E, (HL) 
944d 23			      inc   HL 
944e 56			      ld    D, (HL) 
944f eb			      ex    DE, HL 
9450			 
9450 d1			      pop   DE                      ; Restore size of next block 
9451 19			      add   HL, DE                  ; Add sizes of both blocks 
9452 eb			      ex    DE, HL 
9453			 
9453 60			      ld    H, B                    ; Store new bigger size into freed block 
9454 69			      ld    L, C 
9455 23			      inc   HL 
9456 23			      inc   HL 
9457 73			      ld    (HL), E 
9458 23			      inc   HL 
9459 72			      ld    (HL), D 
945a			 
945a			free_check_adjacent_to_prev: 
945a			      ; Check if the freed block is adjacent to the prev free block 
945a dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
945d dd 66 03		      ld    H, (IX+3) 
9460			 
9460 23			      inc   HL                      ; Size of prev free block into DE 
9461 23			      inc   HL 
9462 5e			      ld    E, (HL) 
9463 23			      inc   HL 
9464 56			      ld    D, (HL) 
9465 2b			      dec   HL 
9466 2b			      dec   HL 
9467 2b			      dec   HL 
9468			 
9468 19			      add   HL, DE                  ; Add prev block addr and size 
9469			 
9469 b7			      or    A                       ; Clear the carry flag 
946a ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
946c 20 2e		      jr    NZ, free_done 
946e			 
946e			      ; Freed block is adjacent to prev, merge into one bigger block 
946e 60			      ld    H, B                    ; Load next ptr from freed block into DE 
946f 69			      ld    L, C 
9470 5e			      ld    E, (HL) 
9471 23			      inc   HL 
9472 56			      ld    D, (HL) 
9473 e5			      push  HL                      ; Save freed block ptr for later 
9474			 
9474 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
9477 dd 66 03		      ld    H, (IX+3) 
947a 73			      ld    (HL), E 
947b 23			      inc   HL 
947c 72			      ld    (HL), D 
947d			 
947d e1			      pop   HL                      ; Restore freed block ptr 
947e 23			      inc   HL                      ; Load size of freed block into DE 
947f 5e			      ld    E, (HL) 
9480 23			      inc   HL 
9481 56			      ld    D, (HL) 
9482 d5			      push  DE                      ; Save freed block size for later 
9483			 
9483 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
9486 dd 66 03		      ld    H, (IX+3) 
9489 23			      inc   HL 
948a 23			      inc   HL 
948b 5e			      ld    E, (HL) 
948c 23			      inc   HL 
948d 56			      ld    D, (HL) 
948e			 
948e e1			      pop   HL                      ; Add sizes of both blocks 
948f 19			      add   HL, DE 
9490 eb			      ex    DE, HL 
9491			 
9491 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
9494 dd 66 03		      ld    H, (IX+3) 
9497 23			      inc   HL 
9498 23			      inc   HL 
9499 73			      ld    (HL), E 
949a 23			      inc   HL 
949b 72			      ld    (HL), D 
949c			 
949c			free_done: 
949c 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
949f 39			      add   HL, SP 
94a0 f9			      ld    SP, HL 
94a1			 
94a1			free_early_exit: 
94a1 dd e1		      pop   IX 
94a3 d1			      pop   DE 
94a4 c1			      pop   BC 
94a5			 
94a5 c9			      ret 
94a6			 
94a6			; moved to firmware.asm 
94a6			; 
94a6			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
94a6			;                  .dw   0 
94a6			 
94a6			 
94a6			endif 
94a6			 
94a6			 
94a6			if MALLOC_3 
94a6			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
94a6			;heap_start        .equ  0x9000      ; Starting address of heap 
94a6			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
94a6			; 
94a6			 ;     .org 0 
94a6			  ;    jp    main 
94a6			; 
94a6			; 
94a6			 ;     .org  0x100 
94a6			;main: 
94a6			 ;     ld    HL, 0x8100 
94a6			  ;    ld    SP, HL 
94a6			; 
94a6			;      call  heap_init 
94a6			 
94a6			      ; Make some allocations 
94a6			;      ld    HL, 12 
94a6			;      call  malloc            ; Allocates 0x9004 
94a6			; 
94a6			 ;     ld    HL, 12 
94a6			;      call  malloc            ; Allocates 0x9014 
94a6			 
94a6			;      ld    HL, 12 
94a6			;      call  malloc            ; Allocates 0x9024 
94a6			 
94a6			      ; Free some allocations 
94a6			;      ld    HL, 0x9014 
94a6			;      call  free 
94a6			 
94a6			;      ld    HL, 0x9004 
94a6			;      call  free 
94a6			; 
94a6			;      ld    HL, 0x9024 
94a6			;      call  free 
94a6			 
94a6			 
94a6			 ;     halt 
94a6			 
94a6			 
94a6			;------------------------------------------------------------------------------ 
94a6			;     heap_init                                                               : 
94a6			;                                                                             : 
94a6			; Description                                                                 : 
94a6			;     Initialise the heap and make it ready for malloc and free operations.   : 
94a6			;                                                                             : 
94a6			;     The heap is maintained as a linked list, starting with an initial       : 
94a6			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
94a6			;     the first free block in the heap. Each block then points to the next    : 
94a6			;     free block within the heap, and the free list ends at the first block   : 
94a6			;     with a null pointer to the next free block.                             : 
94a6			;                                                                             : 
94a6			; Parameters                                                                  : 
94a6			;     Inputs are compile-time only. Two defines which specify the starting    : 
94a6			;     address of the heap and its size are required, along with a memory      : 
94a6			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
94a6			;     principally stores a pointer to the first free block in the heap.       : 
94a6			;                                                                             : 
94a6			; Returns                                                                     : 
94a6			;     Nothing                                                                 : 
94a6			;------------------------------------------------------------------------------ 
94a6			heap_init: 
94a6			      push  HL 
94a6			 
94a6			      ; Initialise free list struct 
94a6			      ld    HL, heap_start 
94a6			      ld    (free_list), HL 
94a6			      ld    HL, 0 
94a6			      ld    (free_list+2), HL 
94a6			 
94a6			      ; Insert first free block at bottom of heap, consumes entire heap 
94a6			      ld    HL, heap_start+heap_size-4 
94a6			      ld    (heap_start), HL        ; Next block (end of free list) 
94a6			      ld    HL, heap_size-4 
94a6			      ld    (heap_start+2), HL      ; Block size 
94a6			 
94a6			      ; Insert end of free list block at top of heap - two null words will 
94a6			      ; terminate the free list 
94a6			      ld    HL, 0 
94a6			      ld    (heap_start+heap_size-2), HL 
94a6			      ld    (heap_start+heap_size-4), HL 
94a6			 
94a6			      pop   HL 
94a6			 
94a6			      ret 
94a6			 
94a6			 
94a6			;------------------------------------------------------------------------------ 
94a6			;     malloc                                                                  : 
94a6			;                                                                             : 
94a6			; Description                                                                 : 
94a6			;     Allocates the wanted space from the heap and returns the address of the : 
94a6			;     first useable byte of the allocation.                                   : 
94a6			;                                                                             : 
94a6			;     Allocations can happen in one of two ways:                              : 
94a6			;                                                                             : 
94a6			;     1. A free block may be found which is the exact size wanted. In this    : 
94a6			;        case the block is removed from the free list and retuedn to the      : 
94a6			;        caller.                                                              : 
94a6			;     2. A free block may be found which is larger than the size wanted. In   : 
94a6			;        this case, the larger block is split into two. The first portion of  : 
94a6			;        this block will become the requested space by the malloc call and    : 
94a6			;        is returned to the caller. The second portion becomes a new free     : 
94a6			;        block, and the free list is adjusted to maintain continuity via this : 
94a6			;        newly created block.                                                 : 
94a6			;                                                                             : 
94a6			;     malloc does not set any initial value in the allocated space, the       : 
94a6			;     caller is required to do this as required.                              : 
94a6			;                                                                             : 
94a6			;     This implementation of malloc uses the stack exclusively, and is        : 
94a6			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
94a6			;     advisable to disable interrupts before calling malloc, and recommended  : 
94a6			;     to avoid the use of malloc inside ISRs in general.                      : 
94a6			;                                                                             : 
94a6			;     NOTE: heap_init must be called before malloc and free can be used.      : 
94a6			;                                                                             : 
94a6			; Parameters                                                                  : 
94a6			;     HL  Number of bytes wanted                                              : 
94a6			;                                                                             : 
94a6			; Returns                                                                     : 
94a6			;     HL  Address of the first useable byte of the allocation                 : 
94a6			;                                                                             : 
94a6			; Flags                                                                       : 
94a6			;     Z   Set if the allocation did not succeed, clear otherwise              : 
94a6			;                                                                             : 
94a6			; Stack frame                                                                 : 
94a6			;       |             |                                                       : 
94a6			;       +-------------+                                                       : 
94a6			;       |     BC      |                                                       : 
94a6			;       +-------------+                                                       : 
94a6			;       |     DE      |                                                       : 
94a6			;       +-------------+                                                       : 
94a6			;       |     IX      |                                                       : 
94a6			;       +-------------+                                                       : 
94a6			;       |  prev_free  |                                                       : 
94a6			;   +4  +-------------+                                                       : 
94a6			;       |  this_free  |                                                       : 
94a6			;   +2  +-------------+                                                       : 
94a6			;       |  next_free  |                                                       : 
94a6			;   +0  +-------------+                                                       : 
94a6			;       |             |                                                       : 
94a6			;                                                                             : 
94a6			;------------------------------------------------------------------------------ 
94a6			malloc: 
94a6			      push  BC 
94a6			      push  DE 
94a6			      push  IX 
94a6			 
94a6			      ld    A, H                    ; Exit if no space requested 
94a6			      or    L 
94a6			      jp    Z, malloc_early_exit 
94a6			 
94a6			      ; Set up stack frame 
94a6			      ex    DE, HL 
94a6			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
94a6			      add   HL, SP 
94a6			      ld    SP, HL 
94a6			      ld    IX, 0                   ; Use IX as a frame pointer 
94a6			      add   IX, SP 
94a6			 
94a6			      ; Setup initial state 
94a6			      ld    HL, 4                   ; want must also include space used by block struct 
94a6			      add   HL, DE 
94a6			 
94a6			      ld    B, H                    ; Move want to BC 
94a6			      ld    C, L 
94a6			 
94a6			      ld    HL, free_list           ; Store prev_free ptr to stack 
94a6			      ld    (IX+4), L 
94a6			      ld    (IX+5), H 
94a6			 
94a6			      ld    E, (HL)                 ; Store this_free ptr to stack 
94a6			      inc   HL 
94a6			      ld    D, (HL) 
94a6			      ld    (IX+2), E 
94a6			      ld    (IX+3), D 
94a6			      ex    DE, HL                  ; this_free ptr into HL 
94a6			 
94a6			      ; Loop through free block list to find some space 
94a6			malloc_find_space: 
94a6			      ld    E, (HL)                 ; Load next_free ptr into DE 
94a6			      inc   HL 
94a6			      ld    D, (HL) 
94a6			 
94a6			      ld    A, D                    ; Check for null next_free ptr - end of free list 
94a6			      or    E 
94a6			      jp    Z, malloc_no_space 
94a6			 
94a6			      ld    (IX+0), E               ; Store next_free ptr to stack 
94a6			      ld    (IX+1), D 
94a6			 
94a6			      ; Does this block have enough space to make the allocation? 
94a6			      inc   HL                      ; Load free block size into DE 
94a6			      ld    E, (HL) 
94a6			      inc   HL 
94a6			      ld    D, (HL) 
94a6			 
94a6			      ex    DE, HL                  ; Check size of block against want 
94a6			      or    A                       ; Ensure carry flag clear 
94a6			      sbc   HL, BC 
94a6			      push  HL                      ; Store the result for later (new block size) 
94a6			 
94a6			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
94a6			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
94a6			 
94a6			      ; this_free block is not big enough, setup ptrs to test next free block 
94a6			      pop   HL                      ; Discard previous result 
94a6			 
94a6			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
94a6			      ld    H, (IX+3) 
94a6			      ld    (IX+4), L 
94a6			      ld    (IX+5), H 
94a6			 
94a6			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
94a6			      ld    H, (IX+1) 
94a6			      ld    (IX+2), L 
94a6			      ld    (IX+3), H 
94a6			 
94a6			      jr    malloc_find_space 
94a6			 
94a6			      ; split a bigger block into two - requested size and remaining size 
94a6			malloc_alloc_split: 
94a6			      ex    DE, HL                  ; Calculate address of new free block 
94a6			      dec   HL 
94a6			      dec   HL 
94a6			      dec   HL 
94a6			      add   HL, BC 
94a6			 
94a6			      ; Create a new block and point it at next_free 
94a6			      ld    E, (IX+0)               ; Load next_free ptr into DE 
94a6			      ld    D, (IX+1) 
94a6			 
94a6			      ld    (HL), E                 ; Store next_free ptr into new block 
94a6			      inc   HL 
94a6			      ld    (HL), D 
94a6			 
94a6			      pop   DE                      ; Store size of new block into new block 
94a6			      inc   HL 
94a6			      ld    (HL), E 
94a6			      inc   HL 
94a6			      ld    (HL), D 
94a6			 
94a6			      ; Update this_free ptr to point to new block 
94a6			      dec   HL 
94a6			      dec   HL 
94a6			      dec   HL 
94a6			 
94a6			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
94a6			      ld    D, (IX+3) 
94a6			 
94a6			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
94a6			      ld    (IX+3), H 
94a6			 
94a6			      ; Modify this_free block to be allocation 
94a6			      ex    DE, HL 
94a6			      xor   A                       ; Null the next block ptr of allocated block 
94a6			      ld    (HL), A 
94a6			      inc   HL 
94a6			      ld    (HL), A 
94a6			 
94a6			      inc   HL                      ; Store want size into allocated block 
94a6			      ld    (HL), C 
94a6			      inc   HL 
94a6			      ld    (HL), B 
94a6			      inc   HL 
94a6			      push  HL                      ; Address of allocation to return 
94a6			 
94a6			      jr    malloc_update_links 
94a6			 
94a6			malloc_alloc_fit: 
94a6			      pop   HL                      ; Dont need new block size, want is exact fit 
94a6			 
94a6			      ; Modify this_free block to be allocation 
94a6			      ex    DE, HL 
94a6			      dec   HL 
94a6			      dec   HL 
94a6			      dec   HL 
94a6			 
94a6			      xor   A                       ; Null the next block ptr of allocated block 
94a6			      ld    (HL), A 
94a6			      inc   HL 
94a6			      ld    (HL), A 
94a6			 
94a6			      inc   HL                      ; Store address of allocation to return 
94a6			      inc   HL 
94a6			      inc   HL 
94a6			      push  HL 
94a6			 
94a6			      ; Copy next_free ptr to this_free, remove allocated block from free list 
94a6			      ld    L, (IX+0)               ; next_free to HL 
94a6			      ld    H, (IX+1) 
94a6			 
94a6			      ld    (IX+2), L               ; HL to this_free 
94a6			      ld    (IX+3), H 
94a6			 
94a6			 
94a6			malloc_update_links: 
94a6			      ; Update prev_free ptr to point to this_free 
94a6			      ld    L, (IX+4)               ; prev_free ptr to HL 
94a6			      ld    H, (IX+5) 
94a6			 
94a6			      ld    E, (IX+2)               ; this_free ptr to DE 
94a6			      ld    D, (IX+3) 
94a6			 
94a6			      ld    (HL), E                 ; this_free ptr into prev_free 
94a6			      inc   HL 
94a6			      ld    (HL), D 
94a6			 
94a6			      ; Clear the Z flag to indicate successful allocation 
94a6			      ld    A, D 
94a6			      or    E 
94a6			 
94a6			      pop   DE                      ; Address of allocation 
94a6			 
94a6			malloc_no_space: 
94a6			      ld    HL, 6                   ; Clean up stack frame 
94a6			      add   HL, SP 
94a6			      ld    SP, HL 
94a6			 
94a6			      ex    DE, HL                  ; Alloc addr into HL for return 
94a6			 
94a6			malloc_early_exit: 
94a6			      pop   IX 
94a6			      pop   DE 
94a6			      pop   BC 
94a6			 
94a6			      ret 
94a6			 
94a6			 
94a6			;------------------------------------------------------------------------------ 
94a6			;     free                                                                    : 
94a6			;                                                                             : 
94a6			; Description                                                                 : 
94a6			;     Return the space pointed to by HL to the heap. HL must be an address as : 
94a6			;     returned by malloc, otherwise the behaviour is undefined.               : 
94a6			;                                                                             : 
94a6			;     Where possible, directly adjacent free blocks will be merged together   : 
94a6			;     into larger blocks to help ensure that the heap does not become         : 
94a6			;     excessively fragmented.                                                 : 
94a6			;                                                                             : 
94a6			;     free does not clear or set any other value into the freed space, and    : 
94a6			;     therefore its contents may be visible through subsequent malloc's. The  : 
94a6			;     caller should clear the freed space as required.                        : 
94a6			;                                                                             : 
94a6			;     This implementation of free uses the stack exclusively, and is          : 
94a6			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
94a6			;     advisable to disable interrupts before calling free, and recommended    : 
94a6			;     to avoid the use of free inside ISRs in general.                        : 
94a6			;                                                                             : 
94a6			;     NOTE: heap_init must be called before malloc and free can be used.      : 
94a6			;                                                                             : 
94a6			; Parameters                                                                  : 
94a6			;     HL  Pointer to address of first byte of allocation to be freed          : 
94a6			;                                                                             : 
94a6			; Returns                                                                     : 
94a6			;     Nothing                                                                 : 
94a6			;                                                                             : 
94a6			; Stack frame                                                                 : 
94a6			;       |             |                                                       : 
94a6			;       +-------------+                                                       : 
94a6			;       |     BC      |                                                       : 
94a6			;       +-------------+                                                       : 
94a6			;       |     DE      |                                                       : 
94a6			;       +-------------+                                                       : 
94a6			;       |     IX      |                                                       : 
94a6			;       +-------------+                                                       : 
94a6			;       |  prev_free  |                                                       : 
94a6			;   +2  +-------------+                                                       : 
94a6			;       |  next_free  |                                                       : 
94a6			;   +0  +-------------+                                                       : 
94a6			;       |             |                                                       : 
94a6			;                                                                             : 
94a6			;------------------------------------------------------------------------------ 
94a6			free: 
94a6			      push  BC 
94a6			      push  DE 
94a6			      push  IX 
94a6			 
94a6			      ld    A, H                    ; Exit if ptr is null 
94a6			      or    L 
94a6			      jp    Z, free_early_exit 
94a6			 
94a6			      ; Set up stack frame 
94a6			      ex    DE, HL 
94a6			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
94a6			      add   HL, SP 
94a6			      ld    SP, HL 
94a6			      ld    IX, 0                   ; Use IX as a frame pointer 
94a6			      add   IX, SP 
94a6			 
94a6			      ; The address in HL points to the start of the useable allocated space, 
94a6			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
94a6			      ; address of the block itself. 
94a6			      ex    DE, HL 
94a6			      ld    DE, -4 
94a6			      add   HL, DE 
94a6			 
94a6			      ; An allocated block must have a null next block pointer in it 
94a6			      ld    A, (HL) 
94a6			      inc   HL 
94a6			      or    (HL) 
94a6			      jp    NZ, free_done 
94a6			 
94a6			      dec   HL 
94a6			 
94a6			      ld    B, H                    ; Copy HL to BC 
94a6			      ld    C, L 
94a6			 
94a6			      ; Loop through the free list to find the first block with an address 
94a6			      ; higher than the block being freed 
94a6			      ld    HL, free_list 
94a6			 
94a6			free_find_higher_block: 
94a6			      ld    E, (HL)                 ; Load next ptr from free block 
94a6			      inc   HL 
94a6			      ld    D, (HL) 
94a6			      dec   HL 
94a6			 
94a6			      ld    (IX+0), E               ; Save ptr to next free block 
94a6			      ld    (IX+1), D 
94a6			      ld    (IX+2), L               ; Save ptr to prev free block 
94a6			      ld    (IX+3), H 
94a6			 
94a6			      ld    A, B                    ; Check if DE is greater than BC 
94a6			      cp    D                       ; Compare MSB first 
94a6			      jr    Z, $+4                  ; MSB the same, compare LSB 
94a6			      jr    NC, free_find_higher_block_skip 
94a6			      ld    A, C 
94a6			      cp    E                       ; Then compare LSB 
94a6			      jr    C, free_found_higher_block 
94a6			 
94a6			free_find_higher_block_skip: 
94a6			      ld    A, D                    ; Reached the end of the free list? 
94a6			      or    E 
94a6			      jp    Z, free_done 
94a6			 
94a6			      ex    DE, HL 
94a6			 
94a6			      jr    free_find_higher_block 
94a6			 
94a6			free_found_higher_block: 
94a6			      ; Insert freed block between prev and next free blocks 
94a6			      ld    (HL), C                 ; Point prev free block to freed block 
94a6			      inc   HL 
94a6			      ld    (HL), B 
94a6			 
94a6			      ld    H, B                    ; Point freed block at next free block 
94a6			      ld    L, C 
94a6			      ld    (HL), E 
94a6			      inc   HL 
94a6			      ld    (HL), D 
94a6			 
94a6			      ; Check if the freed block is adjacent to the next free block 
94a6			      inc   HL                      ; Load size of freed block into HL 
94a6			      ld    E, (HL) 
94a6			      inc   HL 
94a6			      ld    D, (HL) 
94a6			      ex    DE, HL 
94a6			 
94a6			      add   HL, BC                  ; Add addr of freed block and its size 
94a6			 
94a6			      ld    E, (IX+0)               ; Load addr of next free block into DE 
94a6			      ld    D, (IX+1) 
94a6			 
94a6			      or    A                       ; Clear the carry flag 
94a6			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
94a6			      jr    NZ, free_check_adjacent_to_prev 
94a6			 
94a6			      ; Freed block is adjacent to next, merge into one bigger block 
94a6			      ex    DE, HL                  ; Load next ptr from next block into DE 
94a6			      ld    E, (HL) 
94a6			      inc   HL 
94a6			      ld    D, (HL) 
94a6			      push  HL                      ; Save ptr to next block for later 
94a6			 
94a6			      ld    H, B                    ; Store ptr from next block into freed block 
94a6			      ld    L, C 
94a6			      ld    (HL), E 
94a6			      inc   HL 
94a6			      ld    (HL), D 
94a6			 
94a6			      pop   HL                      ; Restore ptr to next block 
94a6			      inc   HL                      ; Load size of next block into DE 
94a6			      ld    E, (HL) 
94a6			      inc   HL 
94a6			      ld    D, (HL) 
94a6			      push  DE                      ; Save next block size for later 
94a6			 
94a6			      ld    H, B                    ; Load size of freed block into HL 
94a6			      ld    L, C 
94a6			      inc   HL 
94a6			      inc   HL 
94a6			      ld    E, (HL) 
94a6			      inc   HL 
94a6			      ld    D, (HL) 
94a6			      ex    DE, HL 
94a6			 
94a6			      pop   DE                      ; Restore size of next block 
94a6			      add   HL, DE                  ; Add sizes of both blocks 
94a6			      ex    DE, HL 
94a6			 
94a6			      ld    H, B                    ; Store new bigger size into freed block 
94a6			      ld    L, C 
94a6			      inc   HL 
94a6			      inc   HL 
94a6			      ld    (HL), E 
94a6			      inc   HL 
94a6			      ld    (HL), D 
94a6			 
94a6			free_check_adjacent_to_prev: 
94a6			      ; Check if the freed block is adjacent to the prev free block 
94a6			      ld    L, (IX+2)               ; Prev free block ptr into HL 
94a6			      ld    H, (IX+3) 
94a6			 
94a6			      inc   HL                      ; Size of prev free block into DE 
94a6			      inc   HL 
94a6			      ld    E, (HL) 
94a6			      inc   HL 
94a6			      ld    D, (HL) 
94a6			      dec   HL 
94a6			      dec   HL 
94a6			      dec   HL 
94a6			 
94a6			      add   HL, DE                  ; Add prev block addr and size 
94a6			 
94a6			      or    A                       ; Clear the carry flag 
94a6			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
94a6			      jr    NZ, free_done 
94a6			 
94a6			      ; Freed block is adjacent to prev, merge into one bigger block 
94a6			      ld    H, B                    ; Load next ptr from freed block into DE 
94a6			      ld    L, C 
94a6			      ld    E, (HL) 
94a6			      inc   HL 
94a6			      ld    D, (HL) 
94a6			      push  HL                      ; Save freed block ptr for later 
94a6			 
94a6			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
94a6			      ld    H, (IX+3) 
94a6			      ld    (HL), E 
94a6			      inc   HL 
94a6			      ld    (HL), D 
94a6			 
94a6			      pop   HL                      ; Restore freed block ptr 
94a6			      inc   HL                      ; Load size of freed block into DE 
94a6			      ld    E, (HL) 
94a6			      inc   HL 
94a6			      ld    D, (HL) 
94a6			      push  DE                      ; Save freed block size for later 
94a6			 
94a6			      ld    L, (IX+2)               ; Load size of prev block into DE 
94a6			      ld    H, (IX+3) 
94a6			      inc   HL 
94a6			      inc   HL 
94a6			      ld    E, (HL) 
94a6			      inc   HL 
94a6			      ld    D, (HL) 
94a6			 
94a6			      pop   HL                      ; Add sizes of both blocks 
94a6			      add   HL, DE 
94a6			      ex    DE, HL 
94a6			 
94a6			      ld    L, (IX+2)               ; Store new bigger size into prev block 
94a6			      ld    H, (IX+3) 
94a6			      inc   HL 
94a6			      inc   HL 
94a6			      ld    (HL), E 
94a6			      inc   HL 
94a6			      ld    (HL), D 
94a6			 
94a6			free_done: 
94a6			      ld    HL, 4                   ; Clean up stack frame 
94a6			      add   HL, SP 
94a6			      ld    SP, HL 
94a6			 
94a6			free_early_exit: 
94a6			      pop   IX 
94a6			      pop   DE 
94a6			      pop   BC 
94a6			 
94a6			      ret 
94a6			 
94a6			 
94a6			;      .org 0x8000 
94a6			; 
94a6			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
94a6			 ;                 .dw   0 
94a6			 
94a6			endif 
94a6			 
94a6			 
94a6			if MALLOC_4 
94a6			 
94a6			; My memory allocation code. Very very simple.... 
94a6			; allocate space under 250 chars 
94a6			 
94a6			heap_init: 
94a6				; init start of heap as zero 
94a6				;  
94a6			 
94a6				ld hl, heap_start 
94a6				ld a, 0 
94a6				ld (hl), a      ; empty block 
94a6				inc hl 
94a6				ld a, 0 
94a6				ld (hl), a      ; length of block 
94a6				; write end of list 
94a6				inc hl 
94a6				ld a,(hl) 
94a6				inc hl 
94a6				ld a,(hl) 
94a6				 
94a6			 
94a6				; init some malloc vars 
94a6			 
94a6				ld hl, 0 
94a6				ld (free_list), hl       ; store last malloc location 
94a6			 
94a6				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
94a6				ld a, 0 
94a6				ld (hl), a 
94a6			 
94a6			 
94a6				ld hl, heap_start 
94a6				;  
94a6				  
94a6				ret 
94a6			 
94a6			 
94a6			;    free block marker 
94a6			;    requested size  
94a6			;    pointer to next block 
94a6			;    .... 
94a6			;    next block marker 
94a6			 
94a6			 
94a6			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
94a6			; 
94a6			 
94a6			 
94a6			malloc:  
94a6				push de 
94a6				push bc 
94a6				push af 
94a6			 
94a6				; hl space required 
94a6				 
94a6				ld c, l    ; hold space   (TODO only a max of 255) 
94a6			 
94a6			;	inc c     ; TODO BUG need to fix memory leak on push str 
94a6			;	inc c 
94a6			;	inc c 
94a6			;	inc c 
94a6			;	inc c 
94a6			;	inc c 
94a6			;	inc c 
94a6			 
94a6			 
94a6			 
94a6				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
94a6			 
94a6				ld a, (free_list+3) 
94a6				cp 0 
94a6				jr z, .contheap 
94a6			 
94a6				ld hl, (free_list)     ; get last alloc 
94a6					if DEBUG_FORTH_MALLOC_INT 
94a6						DMARK "mrs" 
94a6						CALLMONITOR 
94a6					endif 
94a6				jr .startalloc 
94a6			 
94a6			.contheap: 
94a6				ld hl, heap_start 
94a6			 
94a6			.startalloc: 
94a6			 
94a6					if DEBUG_FORTH_MALLOC_INT 
94a6						DMARK "mym" 
94a6						CALLMONITOR 
94a6					endif 
94a6			.findblock: 
94a6					if DEBUG_FORTH_MALLOC_INT 
94a6						DMARK "mmf" 
94a6						CALLMONITOR 
94a6					endif 
94a6			 
94a6				ld a,(hl)  
94a6				; if byte is zero then clear to use 
94a6			 
94a6				cp 0 
94a6				jr z, .foundemptyblock 
94a6			 
94a6				; if byte is not clear 
94a6				;     then byte is offset to next block 
94a6			 
94a6				inc hl 
94a6				ld a, (hl) ; get size 
94a6			.nextblock:	inc hl 
94a6					ld e, (hl) 
94a6					inc hl 
94a6					ld d, (hl) 
94a6					ex de, hl 
94a6			;	inc hl  ; move past the store space 
94a6			;	inc hl  ; move past zero index  
94a6			 
94a6				; TODO detect no more space 
94a6			 
94a6				push hl 
94a6				ld de, heap_end 
94a6				call cmp16 
94a6				pop hl 
94a6				jr nc, .nospace 
94a6			 
94a6				jr .findblock 
94a6			 
94a6			.nospace: ld hl, 0 
94a6				jp .exit 
94a6			 
94a6			 
94a6			.foundemptyblock:	 
94a6					if DEBUG_FORTH_MALLOC_INT 
94a6						DMARK "mme" 
94a6						CALLMONITOR 
94a6					endif 
94a6			 
94a6			; TODO has block enough space if reusing??? 
94a6			 
94a6				;  
94a6			 
94a6			; see if this block has been previously used 
94a6				inc hl 
94a6				ld a, (hl) 
94a6				dec hl 
94a6				cp 0 
94a6				jr z, .newblock 
94a6			 
94a6					if DEBUG_FORTH_MALLOC_INT 
94a6						DMARK "meR" 
94a6						CALLMONITOR 
94a6					endif 
94a6			 
94a6			; no reusing previously allocated block 
94a6			 
94a6			; is it smaller than previously used? 
94a6				 
94a6				inc hl    ; move to size 
94a6				ld a, c 
94a6				sub (hl)        ; we want c < (hl) 
94a6				dec hl    ; move back to marker 
94a6			        jr z, .findblock 
94a6			 
94a6				; update with the new size which should be lower 
94a6			 
94a6			        ;inc  hl   ; negate next move. move back to size  
94a6			 
94a6			.newblock: 
94a6				; need to be at marker here 
94a6			 
94a6					if DEBUG_FORTH_MALLOC_INT 
94a6						DMARK "meN" 
94a6						CALLMONITOR 
94a6					endif 
94a6			 
94a6			 
94a6				ld a, c 
94a6			 
94a6				ld (free_list+3), a	 ; flag resume from last malloc  
94a6				ld (free_list), hl    ; save out last location 
94a6			 
94a6			 
94a6				;inc a     ; space for length byte 
94a6				ld (hl), a     ; save block in use marker 
94a6			 
94a6				inc hl   ; move to space marker 
94a6				ld (hl), a    ; save new space 
94a6			 
94a6				inc hl   ; move to start of allocated area 
94a6				 
94a6			;	push hl     ; save where we are - 1  
94a6			 
94a6			;	inc hl  ; move past zero index  
94a6				; skip space to set down new marker 
94a6			 
94a6				; provide some extra space for now 
94a6			 
94a6				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
94a6				inc a 
94a6				inc a 
94a6			 
94a6				push hl   ; save where we are in the node block 
94a6			 
94a6				call addatohl 
94a6			 
94a6				; write linked list point 
94a6			 
94a6				pop de     ; get our node position 
94a6				ex de, hl 
94a6			 
94a6				ld (hl), e 
94a6				inc hl 
94a6				ld (hl), d 
94a6			 
94a6				inc hl 
94a6			 
94a6				; now at start of allocated data so save pointer 
94a6			 
94a6				push hl 
94a6			 
94a6				; jump to position of next node and setup empty header in DE 
94a6			 
94a6				ex de, hl 
94a6			 
94a6			;	inc hl ; move past end of block 
94a6			 
94a6				ld a, 0 
94a6				ld (hl), a   ; empty marker 
94a6				inc hl 
94a6				ld (hl), a   ; size 
94a6				inc hl  
94a6				ld (hl), a   ; ptr 
94a6				inc hl 
94a6				ld (hl), a   ; ptr 
94a6			 
94a6			 
94a6				pop hl 
94a6			 
94a6					if DEBUG_FORTH_MALLOC_INT 
94a6						DMARK "mmr" 
94a6						CALLMONITOR 
94a6					endif 
94a6			 
94a6			.exit: 
94a6				pop af 
94a6				pop bc 
94a6				pop de  
94a6				ret 
94a6			 
94a6			 
94a6			 
94a6			 
94a6			free:  
94a6				push hl 
94a6				push af 
94a6				; get address in hl 
94a6			 
94a6					if DEBUG_FORTH_MALLOC_INT 
94a6						DMARK "fre" 
94a6						CALLMONITOR 
94a6					endif 
94a6				; data is at hl - move to block count 
94a6				dec hl 
94a6				dec hl    ; get past pointer 
94a6				dec hl 
94a6			 
94a6				ld a, (hl)    ; need this for a validation check 
94a6			 
94a6				dec hl    ; move to block marker 
94a6			 
94a6				; now check that the block count and block marker are the same  
94a6			        ; this checks that we are on a malloc node and not random memory 
94a6			        ; OK a faint chance this could be a problem but rare - famous last words! 
94a6			 
94a6				ld c, a 
94a6				ld a, (hl)    
94a6			 
94a6				cp c 
94a6				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
94a6			 
94a6				; yes good chance we are on a malloc node 
94a6			 
94a6				ld a, 0      
94a6				ld (hl), a   ; mark as free 
94a6			 
94a6				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
94a6			 
94a6			.freeignore:  
94a6			 
94a6				pop af 
94a6				pop hl 
94a6			 
94a6				ret 
94a6			 
94a6			 
94a6			 
94a6			endif 
94a6			 
94a6			; eof 
# End of file firmware_memory.asm
94a6			  
94a6			; device C  
94a6			; Now handled by SPI  
94a6			;if SOUND_ENABLE  
94a6			;	include "firmware_sound.asm"  
94a6			;endif  
94a6			  
94a6			include "firmware_diags.asm"  
94a6			; Hardware diags menu 
94a6			 
94a6			 
94a6			config: 
94a6			 
94a6 3e 00			ld a, 0 
94a8 21 cc 94			ld hl, .configmn 
94ab cd df 8a			call menu 
94ae			 
94ae fe 00			cp 0 
94b0 c8				ret z 
94b1			 
94b1			;	cp 1 
94b1			;	call z, .savetostore 
94b1			 
94b1 fe 01			cp 1 
94b3			if STARTUP_V1 
94b3 cc e2 94			call z, .selautoload 
94b6			endif 
94b6			 
94b6			if STARTUP_V2 
94b6				call z, .enautoload 
94b6			endif 
94b6 fe 02			cp 2 
94b8 cc d8 94			call z, .disautoload 
94bb			;	cp 3 
94bb			;	call z, .selbank 
94bb fe 03			cp 3 
94bd cc 00 95			call z, .debug_tog 
94c0 fe 04			cp 4 
94c2 cc 4e 96			call z, .bpsgo 
94c5 fe 05			cp 5 
94c7 cc 29 95			call z, hardware_diags 
94ca			if STARTUP_V2 
94ca				cp 6 
94ca				call z, create_startup 
94ca			endif 
94ca 18 da			jr config 
94cc			 
94cc			.configmn: 
94cc			;	dw prom_c3 
94cc 3c 98			dw prom_c2 
94ce 51 98			dw prom_c2a 
94d0			;	dw prom_c2b 
94d0			;	dw prom_c4 
94d0 70 98			dw prom_m4 
94d2 8b 98			dw prom_m4b 
94d4 93 98			dw prom_c1 
94d6			if STARTUP_V2 
94d6				dw prom_c9 
94d6			endif 
94d6 00 00			dw 0 
94d8				 
94d8			 
94d8			if STARTUP_V2 
94d8			.enautoload: 
94d8				if STORAGE_SE 
94d8				ld a, $fe      ; bit 0 clear 
94d8				ld (spi_device), a 
94d8			 
94d8				call storage_get_block_0 
94d8			 
94d8				ld a, 1 
94d8				ld (store_page+STORE_0_AUTOFILE), a 
94d8			 
94d8					ld hl, 0 
94d8					ld de, store_page 
94d8				call storage_write_block	 ; save update 
94d8				else 
94d8			 
94d8				ld hl, prom_notav 
94d8				ld de, prom_empty 
94d8				call info_panel 
94d8				endif 
94d8			 
94d8			 
94d8				ret 
94d8			endif 
94d8			 
94d8			.disautoload: 
94d8				if STORAGE_SE 
94d8				ld a, $fe      ; bit 0 clear 
94d8				ld (spi_device), a 
94d8			 
94d8				call storage_get_block_0 
94d8			 
94d8				ld a, 0 
94d8				ld (store_page+STORE_0_AUTOFILE), a 
94d8			 
94d8					ld hl, 0 
94d8					ld de, store_page 
94d8				call storage_write_block	 ; save update 
94d8				else 
94d8			 
94d8 21 a2 98			ld hl, prom_notav 
94db 11 b8 98			ld de, prom_empty 
94de cd 3f 8a			call info_panel 
94e1				endif 
94e1			 
94e1			 
94e1 c9				ret 
94e2			 
94e2			if STARTUP_V1 
94e2			 
94e2			; Select auto start 
94e2			 
94e2			.selautoload: 
94e2			 
94e2				 
94e2				if STORAGE_SE 
94e2			 
94e2					call config_dir 
94e2				        ld hl, scratch 
94e2					ld a, 0 
94e2					call menu 
94e2			 
94e2					cp 0 
94e2					ret z 
94e2			 
94e2					dec a 
94e2			 
94e2			 
94e2					; locate menu option 
94e2			 
94e2					ld hl, scratch 
94e2					call table_lookup 
94e2			 
94e2					if DEBUG_FORTH_WORDS 
94e2						DMARK "ALl" 
94e2						CALLMONITOR 
94e2					endif 
94e2					; with the pointer to the menu it, the byte following the zero term is the file id 
94e2			 
94e2					ld a, 0 
94e2					ld bc, 50   ; max of bytes to look at 
94e2					cpir  
94e2			 
94e2					if DEBUG_FORTH_WORDS 
94e2						DMARK "ALb" 
94e2						CALLMONITOR 
94e2					endif 
94e2					;inc hl 
94e2			 
94e2					ld a, (hl)   ; file id 
94e2					 
94e2				        ; save bank and file ids 
94e2			 
94e2					push af 
94e2			 
94e2			; TODO need to save to block 0 on bank 1	 
94e2			 
94e2					call storage_get_block_0 
94e2			 
94e2					if DEBUG_FORTH_WORDS 
94e2						DMARK "AL0" 
94e2						CALLMONITOR 
94e2					endif 
94e2					pop af 
94e2			 
94e2					ld (store_page+STORE_0_FILERUN),a 
94e2					 
94e2					; save bank id 
94e2			 
94e2					ld a,(spi_device) 
94e2					ld (store_page+STORE_0_BANKRUN),a 
94e2			 
94e2					; enable auto run of store file 
94e2			 
94e2					ld a, 1 
94e2					ld (store_page+STORE_0_AUTOFILE),a 
94e2			 
94e2					; save buffer 
94e2			 
94e2					ld hl, 0 
94e2					ld de, store_page 
94e2					if DEBUG_FORTH_WORDS 
94e2						DMARK "ALw" 
94e2						CALLMONITOR 
94e2					endif 
94e2				call storage_write_block	 ; save update 
94e2			  
94e2			 
94e2			 
94e2			 
94e2					ld hl, scratch 
94e2					call config_fdir 
94e2			 
94e2				else 
94e2			 
94e2 21 a2 98			ld hl, prom_notav 
94e5 11 b8 98			ld de, prom_empty 
94e8 cd 3f 8a			call info_panel 
94eb			 
94eb				endif 
94eb c9				ret 
94ec			endif 
94ec			 
94ec			 
94ec			; Select storage bank 
94ec			 
94ec			.selbank: 
94ec			 
94ec			;	if STORAGE_SE 
94ec			;	else 
94ec			 
94ec 21 a2 98			ld hl, prom_notav 
94ef 11 b8 98			ld de, prom_empty 
94f2 cd 3f 8a			call info_panel 
94f5			;	endif 
94f5				 
94f5 c9				ret 
94f6			 
94f6			if STORAGE_SE 
94f6			 
94f6			.config_ldir:   
94f6				; Load storage bank labels into menu array 
94f6			 
94f6				 
94f6			 
94f6			 
94f6				ret 
94f6			 
94f6			 
94f6			endif 
94f6			 
94f6			 
94f6			; Save user words to storage 
94f6			 
94f6			.savetostore: 
94f6			 
94f6			;	if STORAGE_SE 
94f6			; 
94f6			;		call config_dir 
94f6			;	        ld hl, scratch 
94f6			;		ld a, 0 
94f6			;		call menu 
94f6			;		 
94f6			;		ld hl, scratch 
94f6			;		call config_fdir 
94f6			; 
94f6			;	else 
94f6			 
94f6 21 a2 98			ld hl, prom_notav 
94f9 11 b8 98			ld de, prom_empty 
94fc cd 3f 8a			call info_panel 
94ff			 
94ff			;	endif 
94ff			 
94ff c9				ret 
9500			 
9500			if STARTUP_V2 
9500			 
9500			create_startup: 
9500			 
9500				ld a, 0 
9500				ld hl, .crstart 
9500				call menu 
9500			 
9500				cp 0 
9500				ret z 
9500			 
9500				cp 1 
9500				call z, .genlsword 
9500				cp 2 
9500				call z, .genedword 
9500			 
9500				cp 3 
9500				call z, .gendemword 
9500			 
9500				cp 4 
9500				call z, .genutlword 
9500				cp 5 
9500				call z, .genspiword 
9500				cp 6 
9500				call z, .genkeyword 
9500				cp 7 
9500				call z, .gensoundword 
9500				jr create_startup 
9500			 
9500			.gensoundword: 
9500				ld hl, crs_sound 
9500				ld de, .soundworddef 
9500				call .genfile 
9500				ret 
9500			.genlsword: 
9500				ld hl, crs_s1 
9500				ld de, .lsworddef 
9500				call .genfile 
9500				ret 
9500			 
9500			.genedword: 
9500				ld de, .edworddef 
9500				ld hl, crs_s2 
9500				call .genfile 
9500				ret 
9500			 
9500			.gendemword: 
9500				ld de, .demoworddef 
9500				ld hl, crs_s3 
9500				call .genfile 
9500				ret 
9500			 
9500			.genutlword: 
9500				ld hl, crs_s4 
9500				ld de, .utilwordef 
9500				call .genfile 
9500				ret 
9500			.genspiword: 
9500				ld hl, crs_s5 
9500				ld de, .spiworddef 
9500				call .genfile 
9500				ret 
9500			.genkeyword: 
9500				ld hl, crs_s6 
9500				ld de, .keyworddef 
9500				call .genfile 
9500				ret 
9500			 
9500			; hl - points to file name 
9500			; de - points to strings to add to file 
9500			 
9500			.genfile: 
9500				push hl 
9500				push de 
9500			 
9500				call clear_display 
9500				ld a, display_row_1 
9500				ld de, .genfiletxt 
9500				call str_at_display 
9500				call update_display 
9500			 
9500				pop de 
9500				pop hl 
9500			 
9500			 
9500				push de 
9500				call storage_create 
9500				; id in hl 
9500				pop de   ; table of strings to add 
9500			 
9500			.genloop: 
9500			 
9500				push hl ; save id for next time around 
9500				push de ; save de for next time around 
9500			 
9500				ex de, hl 
9500				call loadwordinhl 
9500				ex de, hl 
9500			 
9500				; need hl to be the id 
9500				; need de to be the string ptr 
9500				 
9500				call storage_append 
9500			 
9500				pop de 
9500				pop hl 
9500			 
9500				inc de 
9500				inc de 
9500			 
9500				ld a,(de) 
9500				cp 0 
9500				jr nz, .genloop 
9500				inc de 
9500				ld a, (de) 
9500				dec de 
9500				cp 0 
9500				jr nz, .genloop	 
9500			 
9500				ret 
9500			 
9500			.genfiletxt:  db "Creating file...",0 
9500			 
9500			.soundworddef: 
9500				dw sound1 
9500				dw sound2 
9500				dw sound3 
9500				dw sound4 
9500				dw sound5 
9500				dw sound6 
9500				dw sound7 
9500				dw sound8 
9500				dw sound9 
9500				dw 0 
9500			 
9500			.utilwordef: 
9500				dw strncpy 
9500				dw type 
9500				dw clrstack 
9500				dw longread 
9500				dw start1 
9500				dw start2 
9500			; duplicated 
9500			;	dw start3b 
9500			;	dw start3c 
9500				dw list 
9500				dw 0 
9500			 
9500			.lsworddef: 
9500				dw start3b 
9500				dw 0 
9500			 
9500			.edworddef: 
9500				dw edit1 
9500				dw edit2 
9500				dw edit3 
9500				dw 0 
9500			 
9500			.demoworddef: 
9500				dw test5 
9500				dw test6 
9500				dw test7 
9500				dw test8 
9500				dw test9 
9500				dw test10 
9500				dw game1 
9500				dw game1a 
9500				dw game1b 
9500				dw game1c 
9500				dw game1d 
9500				dw game1s 
9500				dw game1t 
9500				dw game1f 
9500				dw game1z 
9500				dw game1zz 
9500				dw ssv2 
9500				dw ssv3 
9500				dw ssv4 
9500				dw ssv5 
9500				dw ssv1 
9500				dw ssv1cpm	 
9500				dw game2b 
9500				dw game2bf 
9500				dw game2mba 
9500				dw game2mbas	 
9500				dw game2mbht 
9500				dw game2mbms 
9500				dw game2mb 
9500				dw game3w 
9500				dw game3p 
9500				dw game3sc 
9500				dw game3vsi 
9500				dw game3vs 
9500				dw 0 
9500			 
9500			 
9500			.spiworddef: 
9500			 
9500			    dw spi1 
9500			    dw spi2 
9500			    dw spi2b 
9500			    dw spi3 
9500			    dw spi4 
9500			    dw spi5 
9500			;    dw spi6 
9500			;    dw spi7 
9500			 
9500			;    dw spi8 
9500			;    dw spi9 
9500			;    dw spi10 
9500			    dw 0 
9500			 
9500			.keyworddef: 
9500			 
9500				dw keyup 
9500				dw keydown 
9500				dw keyleft 
9500				dw keyright 
9500				dw 	keyf1 
9500				dw keyf2 
9500				dw keyf3 
9500				dw keyf4 
9500				dw keyf5 
9500				dw keyf6 
9500				dw keyf7 
9500				dw keyf8 
9500				dw keyf9 
9500				dw keyf10 
9500				dw keyf11 
9500				dw keyf12 
9500				dw keytab 
9500				dw keycr 
9500				dw keyhome 
9500				dw keyend 
9500				dw keybs 
9500				dw 0 
9500			 
9500			.crstart: 
9500				dw crs_s1 
9500				dw crs_s2 
9500				dw crs_s3 
9500				dw crs_s4 
9500				dw crs_s5 
9500				dw crs_s6 
9500				dw crs_sound 
9500				dw 0 
9500			 
9500			endif 
9500			 
9500			 
9500			if STORAGE_SE 
9500			 
9500			config_fdir: 
9500				; using the scratch dir go through and release the memory allocated for each string 
9500				 
9500				ld hl, scratch 
9500			.cfdir:	ld e,(hl) 
9500				inc hl 
9500				ld d,(hl) 
9500				inc hl 
9500			 
9500				ex de, hl 
9500				call ishlzero 
9500				ret z     ; return on null pointer 
9500				call free 
9500				ex de, hl 
9500				jr .cfdir 
9500			 
9500			 
9500				ret 
9500			 
9500			 
9500			config_dir: 
9500			 
9500				; for the config menus that need to build a directory of storage call this routine 
9500				; it will construct a menu in scratch to pass to menu 
9500			 
9500				; open storage device 
9500			 
9500				; execute DIR to build a list of files and their ids into scratch in menu format 
9500				; once the menu has finished then will need to call config_fdir to release the strings 
9500				 
9500				; c = number items 
9500			 
9500				 
9500				call storage_get_block_0 
9500			 
9500				ld hl, store_page     ; get current id count 
9500				ld b, (hl) 
9500				ld c, 0    ; count of files   
9500			 
9500			 
9500				ld hl, scratch 
9500				ld (store_tmp2), hl    ; location to poke strings 
9500			 
9500				; check for empty drive 
9500			 
9500				ld a, 0 
9500				cp b 
9500				jp z, .dirdone 
9500			 
9500				 
9500					if DEBUG_FORTH_WORDS 
9500						DMARK "Cdc" 
9500						CALLMONITOR 
9500					endif 
9500			 
9500			 
9500			.diritem:	 
9500				push bc 
9500				; for each of the current ids do a search for them and if found push to stack 
9500			 
9500					ld hl, STORE_BLOCK_PHY 
9500					ld d, 0		 ; look for extent 0 of block id as this contains file name 
9500					ld e,b 
9500			 
9500					call storage_findnextid 
9500			 
9500			 
9500					; if found hl will be non zero 
9500			 
9500					call ishlzero 
9500					jr z, .dirnotfound 
9500			 
9500					; increase count 
9500			 
9500					pop bc	 
9500					inc c 
9500					push bc 
9500					 
9500			 
9500					; get file header and push the file name 
9500			 
9500					ld de, store_page 
9500					call storage_read_block 
9500			 
9500					; push file id to stack 
9500				 
9500					ld a, (store_page) 
9500					ld h, 0 
9500					ld l, a 
9500			 
9500					;call forth_push_numhl 
9500					; TODO store id 
9500			 
9500					push hl 
9500			 
9500					; push extent count to stack  
9500				 
9500					ld hl, store_page+3 
9500			 
9500					; get file name length 
9500			 
9500					call strlenz   
9500			 
9500					inc hl   ; cover zero term 
9500					inc hl  ; stick the id at the end of the area 
9500			 
9500					push hl 
9500					pop bc    ; move length to bc 
9500			 
9500					call malloc 
9500			 
9500					; TODO save malloc area to scratch 
9500			 
9500					ex de, hl 
9500					ld hl, (store_tmp2) 
9500					ld (hl), e 
9500					inc hl 
9500					ld (hl), d 
9500					inc hl 
9500					ld (store_tmp2), hl 
9500			 
9500					 
9500			 
9500					;pop hl   ; get source 
9500			;		ex de, hl    ; swap aronund	 
9500			 
9500					ld hl, store_page+3 
9500					if DEBUG_FORTH_WORDS 
9500						DMARK "CFd" 
9500						CALLMONITOR 
9500					endif 
9500					ldir 
9500			 
9500					; de is past string, move back one and store id 
9500					 
9500					dec de 
9500			 
9500					; store file id 
9500			 
9500					pop hl 
9500					ex de,hl 
9500					ld (hl), e 
9500			 
9500					if DEBUG_FORTH_WORDS 
9500						DMARK "Cdi" 
9500						CALLMONITOR 
9500					endif 
9500					 
9500			.dirnotfound: 
9500					pop bc     
9500					djnz .diritem 
9500				 
9500			.dirdone:	 
9500			 
9500					ld a, 0 
9500					ld hl, (store_tmp2) 
9500					ld (hl), a 
9500					inc hl 
9500					ld (hl), a 
9500					inc hl 
9500					; push a count of the dir items found 
9500			 
9500			;		ld h, 0 
9500			;		ld l, c 
9500			 
9500				ret 
9500			 
9500			endif 
9500			 
9500			 
9500			; Settings 
9500			; Run  
9500			 
9500			 
9500			 
9500			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
9500			;;hd_menu2:   db "        2: Editor",0   
9500			;hd_menu2:   db "        2: Editor       6: Menu",0   
9500			;hd_menu3:   db "        3: Storage",0 
9500			;hd_menu4:   db "0=quit  4: Debug",0 
9500			;hd_don:     db "ON",0 
9500			;hd_doff:     db "OFF",0 
9500			; 
9500			; 
9500			; 
9500			;hardware_diags_old:       
9500			; 
9500			;.diagmenu: 
9500			;	call clear_display 
9500			;	ld a, display_row_1 
9500			;	ld de, hd_menu1 
9500			;	call str_at_display 
9500			; 
9500			;	ld a, display_row_2 
9500			;	ld de, hd_menu2 
9500			;	call str_at_display 
9500			; 
9500			;	ld a, display_row_3 
9500			;	ld de, hd_menu3 
9500			;	call str_at_display 
9500			; 
9500			;	ld a,  display_row_4 
9500			;	ld de, hd_menu4 
9500			;	call str_at_display 
9500			; 
9500			;	; display debug state 
9500			; 
9500			;	ld de, hd_don 
9500			;	ld a, (os_view_disable) 
9500			;	cp 0 
9500			;	jr z, .distog 
9500			;	ld de, hd_doff 
9500			;.distog: ld a, display_row_4+17 
9500			;	call str_at_display 
9500			; 
9500			;	call update_display 
9500			; 
9500			;	call cin_wait 
9500			; 
9500			; 
9500			; 
9500			;	cp '4' 
9500			;	jr nz, .diagn1 
9500			; 
9500			;	; debug toggle 
9500			; 
9500			;	ld a, (os_view_disable) 
9500			;	ld b, '*' 
9500			;	cp 0 
9500			;	jr z, .debtog 
9500			;	ld b, 0 
9500			;.debtog:	 
9500			;	ld a,b 
9500			;	ld (os_view_disable),a 
9500			; 
9500			;.diagn1: cp '0' 
9500			;	 ret z 
9500			; 
9500			;;	cp '1' 
9500			;;       jp z, matrix	 
9500			;;   TODO keyboard matrix test 
9500			; 
9500			;	cp '2' 
9500			;	jp z, .diagedit 
9500			; 
9500			;;	cp '6' 
9500			;;	jp z, .menutest 
9500			;;if ENABLE_BASIC 
9500			;;	cp '6' 
9500			;;	jp z, basic 
9500			;;endif 
9500			 ; 
9500			;	jp .diagmenu 
9500			; 
9500			; 
9500			;	ret 
9500			 
9500			 
9500			.debug_tog: 
9500 21 4a 95			ld hl, .menudebug 
9503				 
9503			;	ld a, (os_view_disable) 
9503			;	cp '*' 
9503 3a 6f ee			ld a,(debug_vector) 
9506 fe c9			cp $C9   ; RET 
9508 20 04			jr nz,.tdon  
950a 3e 01			ld a, 1 
950c 18 02			jr .tog1 
950e 3e 00		.tdon: ld a, 0 
9510			 
9510			.tog1: 
9510 cd df 8a			call menu 
9513 fe 00			cp 0 
9515 c8				ret z 
9516 fe 01			cp 1    ; disable debug 
9518 28 04			jr z, .dtog0 
951a 3e 2a			ld a, '*' 
951c 18 05			jr .dtogset 
951e			.dtog0:  
951e				;ld a, 0 
951e cd 3c 96			call bp_on 
9521 18 dd			jr .debug_tog 
9523			.dtogset:  
9523				; ld (os_view_disable), a 
9523 cd 48 96			call bp_off 
9526 c3 00 95			jp .debug_tog 
9529			 
9529			 
9529			hardware_diags:       
9529			 
9529			.diagm: 
9529 21 3c 95			ld hl, .menuitems 
952c 3e 00			ld a, 0 
952e cd df 8a			call menu 
9531			 
9531 fe 00		         cp 0 
9533 c8				 ret z 
9534			 
9534 fe 02			cp 2 
9536 ca 95 95			jp z, .diagedit 
9539			 
9539			;	cp '6' 
9539			;	jp z, .menutest 
9539			;if ENABLE_BASIC 
9539			;	cp '6' 
9539			;	jp z, basic 
9539			;endif 
9539			  
9539 c3 29 95			jp .diagm 
953c			 
953c				 
953c 50 95		.menuitems:   	dw .m1 
953e 5b 95				dw .m2 
9540 62 95				dw .m3 
9542 6a 95				dw .m5 
9544 70 95				dw .m5a 
9546 79 95				dw .m5b 
9548 00 00				dw 0 
954a			 
954a			.menudebug: 
954a 82 95				dw .m6 
954c 8b 95				dw .m7 
954e 00 00				dw 0 
9550			 
9550 .. 00		.m1:   db "Key Matrix",0 
955b .. 00		.m2:   db "Editor",0 
9562 .. 00		.m3:   db "Storage",0 
956a .. 00		.m5:   db "Sound",0 
9570 .. 00		.m5a:  db "RAM Test",0 
9579 .. 00		.m5b:  db "LCD Test",0 
9582			 
9582 .. 00		.m6:   db "Debug ON",0 
958b .. 00		.m7:   db "Debug OFF",0 
9595			 
9595			; debug editor 
9595			 
9595			.diagedit: 
9595			 
9595 21 c1 e2			ld hl, scratch 
9598			;	ld bc, 250 
9598			;	ldir 
9598				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
9598 3e 00			ld a, 0 
959a 77				ld (hl), a 
959b 23				inc hl 
959c 77				ld (hl), a 
959d 23				inc hl 
959e 77				ld (hl), a 
959f			 
959f cd ae 8a		        call clear_display 
95a2 cd d1 8a			call update_display 
95a5				;ld a, 1 
95a5				;ld (hardware_diag), a 
95a5			.diloop: 
95a5 3e 00			ld a, display_row_1 
95a7 0e 00			ld c, 0 
95a9 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
95ab 1e 28			ld e, 40 
95ad			 
95ad 21 c1 e2			ld hl, scratch	 
95b0 cd 08 8d			call input_str 
95b3			 
95b3 3e 28			ld a, display_row_2 
95b5 11 c1 e2			ld de, scratch 
95b8 cd c1 8a			call str_at_display 
95bb cd d1 8a			call update_display 
95be			 
95be c3 a5 95			jp .diloop 
95c1			 
95c1			 
95c1			; pass word in hl 
95c1			; a has display location 
95c1			display_word_at: 
95c1 f5				push af 
95c2 e5				push hl 
95c3 7c				ld a,h 
95c4 21 c6 e5			ld hl, os_word_scratch 
95c7 cd 3b 91			call hexout 
95ca e1				pop hl 
95cb 7d				ld a,l 
95cc 21 c8 e5			ld hl, os_word_scratch+2 
95cf cd 3b 91			call hexout 
95d2 21 ca e5			ld hl, os_word_scratch+4 
95d5 3e 00			ld a,0 
95d7 77				ld (hl),a 
95d8 11 c6 e5			ld de,os_word_scratch 
95db f1				pop af 
95dc cd c1 8a				call str_at_display 
95df c9				ret 
95e0			 
95e0			display_ptr_state: 
95e0			 
95e0				; to restore afterwards 
95e0			 
95e0 d5				push de 
95e1 c5				push bc 
95e2 e5				push hl 
95e3 f5				push af 
95e4			 
95e4				; for use in here 
95e4			 
95e4			;	push bc 
95e4			;	push de 
95e4			;	push hl 
95e4			;	push af 
95e4			 
95e4 cd ae 8a			call clear_display 
95e7			 
95e7 11 bf 97			ld de, .ptrstate 
95ea 3e 00			ld a, display_row_1 
95ec cd c1 8a			call str_at_display 
95ef			 
95ef				; display debug step 
95ef			 
95ef			 
95ef 11 6b ee			ld de, debug_mark 
95f2 3e 26			ld a, display_row_1+display_cols-2 
95f4 cd c1 8a			call str_at_display 
95f7			 
95f7				; display a 
95f7 11 c9 97			ld de, .ptrcliptr 
95fa 3e 28			ld a, display_row_2 
95fc cd c1 8a			call str_at_display 
95ff			 
95ff f1				pop af 
9600 2a 40 ea			ld hl,(cli_ptr) 
9603 3e 30			ld a, display_row_2+8 
9605 cd c1 95			call display_word_at 
9608			 
9608			 
9608				; display hl 
9608			 
9608			 
9608 11 d1 97			ld de, .ptrclioptr 
960b 3e 32			ld a, display_row_2+10 
960d cd c1 8a			call str_at_display 
9610			; 
9610			;	pop hl 
9610 3e 35			ld a, display_row_2+13 
9612 2a 3e ea			ld hl,(cli_origptr) 
9615 cd c1 95			call display_word_at 
9618			; 
9618			;	 
9618			;	; display de 
9618			 
9618			;	ld de, .regstatede 
9618			;	ld a, display_row_3 
9618			;	call str_at_display 
9618			 
9618			;	pop de 
9618			;	ld h,d 
9618			;	ld l, e 
9618			;	ld a, display_row_3+3 
9618			;	call display_word_at 
9618			 
9618			 
9618				; display bc 
9618			 
9618			;	ld de, .regstatebc 
9618			;	ld a, display_row_3+10 
9618			;	call str_at_display 
9618			 
9618			;	pop bc 
9618			;	ld h,b 
9618			;	ld l, c 
9618			;	ld a, display_row_3+13 
9618			;	call display_word_at 
9618			 
9618			 
9618				; display dsp 
9618			 
9618			;	ld de, .regstatedsp 
9618			;	ld a, display_row_4 
9618			;	call str_at_display 
9618			 
9618				 
9618			;	ld hl,(cli_data_sp) 
9618			;	ld a, display_row_4+4 
9618			;	call display_word_at 
9618			 
9618				; display rsp 
9618			 
9618 11 00 98			ld de, .regstatersp 
961b 3e 82			ld a, display_row_4+10 
961d cd c1 8a			call str_at_display 
9620			 
9620				 
9620 2a f2 e9			ld hl,(cli_ret_sp) 
9623 3e 86			ld a, display_row_4+14 
9625 cd c1 95			call display_word_at 
9628			 
9628 cd d1 8a			call update_display 
962b			 
962b cd f1 89			call delay1s 
962e cd f1 89			call delay1s 
9631 cd f1 89			call delay1s 
9634			 
9634			 
9634 cd 1e 9c			call next_page_prompt 
9637			 
9637				; restore  
9637			 
9637 f1				pop af 
9638 e1				pop hl 
9639 c1				pop bc 
963a d1				pop de 
963b c9				ret 
963c			 
963c			; Update the break point vector so that the user can hook a new routine 
963c			 
963c			bp_on: 
963c 3e c3			ld a, $c3    ; JP 
963e 32 6f ee			ld (debug_vector), a 
9641 21 4e 96			ld hl, break_point_state 
9644 22 70 ee			ld (debug_vector+1), hl 
9647 c9				ret 
9648			 
9648			bp_off: 
9648 3e c9			ld a, $c9    ; RET 
964a 32 6f ee			ld (debug_vector), a 
964d c9				ret 
964e			 
964e			 
964e			break_point_state: 
964e			;	push af 
964e			; 
964e			;	; see if disabled 
964e			; 
964e			;	ld a, (os_view_disable) 
964e			;	cp '*' 
964e			;	jr nz, .bpsgo 
964e			;	pop af 
964e			;	ret 
964e			 
964e			.bpsgo: 
964e			;	pop af 
964e f5				push af 
964f 22 a3 e2			ld (os_view_hl), hl 
9652 ed 53 a1 e2		ld (os_view_de), de 
9656 ed 43 9f e2		ld (os_view_bc), bc 
965a e5				push hl 
965b 6f				ld l, a 
965c 26 00			ld h, 0 
965e 22 a5 e2			ld (os_view_af),hl 
9661			 
9661 21 b1 ed				ld hl, display_fb0 
9664 22 cc eb				ld (display_fb_active), hl 
9667 e1				pop hl	 
9668			 
9668 3e 31			ld a, '1' 
966a fe 2a		.bps1:  cp '*' 
966c cc 48 96			call z, bp_off 
966f			;	jr nz, .bps1b 
966f			;	ld (os_view_disable),a 
966f fe 31		.bps1b:  cp '1' 
9671 20 14			jr nz, .bps2 
9673			 
9673				; display reg 
9673			 
9673				 
9673			 
9673 3a a5 e2			ld a, (os_view_af) 
9676 2a a3 e2			ld hl, (os_view_hl) 
9679 ed 5b a1 e2		ld de, (os_view_de) 
967d ed 4b 9f e2		ld bc, (os_view_bc) 
9681 cd 1b 97			call display_reg_state 
9684 c3 07 97			jp .bpschk 
9687			 
9687 fe 32		.bps2:  cp '2' 
9689 20 08			jr nz, .bps3 
968b				 
968b				; display hl 
968b 2a a3 e2			ld hl, (os_view_hl) 
968e cd 05 98			call display_dump_at_hl 
9691			 
9691 18 74			jr .bpschk 
9693			 
9693 fe 33		.bps3:  cp '3' 
9695 20 08			jr nz, .bps4 
9697			 
9697			        ; display de 
9697 2a a1 e2			ld hl, (os_view_de) 
969a cd 05 98			call display_dump_at_hl 
969d			 
969d 18 68			jr .bpschk 
969f fe 34		.bps4:  cp '4' 
96a1 20 08			jr nz, .bps5 
96a3			 
96a3			        ; display bc 
96a3 2a 9f e2			ld hl, (os_view_bc) 
96a6 cd 05 98			call display_dump_at_hl 
96a9			 
96a9 18 5c			jr .bpschk 
96ab fe 35		.bps5:  cp '5' 
96ad 20 08		        jr nz, .bps7 
96af			 
96af				; display cur ptr 
96af 2a 40 ea			ld hl, (cli_ptr) 
96b2 cd 05 98			call display_dump_at_hl 
96b5			 
96b5 18 50			jr .bpschk 
96b7 fe 36		.bps7:  cp '6' 
96b9 20 08			jr nz, .bps8b 
96bb				 
96bb				; display cur orig ptr 
96bb 2a 3e ea			ld hl, (cli_origptr) 
96be cd 05 98			call display_dump_at_hl 
96c1 18 44			jr .bpschk 
96c3 fe 37		.bps8b:  cp '7' 
96c5 20 08			jr nz, .bps9 
96c7				 
96c7				; display dsp 
96c7 2a ee e9			ld hl, (cli_data_sp) 
96ca cd 05 98			call display_dump_at_hl 
96cd			 
96cd 18 38			jr .bpschk 
96cf fe 39		.bps9:  cp '9' 
96d1 20 05			jr nz, .bps8c 
96d3				 
96d3				; display SP 
96d3			;	ld hl, sp 
96d3 cd 05 98			call display_dump_at_hl 
96d6			 
96d6 18 2f			jr .bpschk 
96d8 fe 38		.bps8c:  cp '8' 
96da 20 08			jr nz, .bps8d 
96dc				 
96dc				; display rsp 
96dc 2a f2 e9			ld hl, (cli_ret_sp) 
96df cd 05 98			call display_dump_at_hl 
96e2			 
96e2 18 23			jr .bpschk 
96e4 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
96e6 20 05			jr nz, .bps8 
96e8 cd ec 99			call monitor 
96eb			 
96eb 18 1a			jr .bpschk 
96ed fe 30		.bps8:  cp '0' 
96ef 20 16			jr nz, .bpschk 
96f1			 
96f1 21 10 ed				ld hl, display_fb1 
96f4 22 cc eb				ld (display_fb_active), hl 
96f7 cd d1 8a				call update_display 
96fa			 
96fa				;ld a, (os_view_af) 
96fa 2a a3 e2			ld hl, (os_view_hl) 
96fd ed 5b a1 e2		ld de, (os_view_de) 
9701 ed 4b 9f e2		ld bc, (os_view_bc) 
9705 f1				pop af 
9706 c9				ret 
9707			 
9707			.bpschk:   
9707 cd f1 89			call delay1s 
970a 3e 9f		ld a,display_row_4 + display_cols - 1 
970c 11 1c 9c		        ld de, endprg 
970f cd c1 8a			call str_at_display 
9712 cd d1 8a			call update_display 
9715 cd 2e e6			call cin_wait 
9718			 
9718 c3 6a 96			jp .bps1 
971b			 
971b			 
971b			display_reg_state: 
971b			 
971b				; to restore afterwards 
971b			 
971b d5				push de 
971c c5				push bc 
971d e5				push hl 
971e f5				push af 
971f			 
971f				; for use in here 
971f			 
971f c5				push bc 
9720 d5				push de 
9721 e5				push hl 
9722 f5				push af 
9723			 
9723 cd ae 8a			call clear_display 
9726			 
9726 11 db 97			ld de, .regstate 
9729 3e 00			ld a, display_row_1 
972b cd c1 8a			call str_at_display 
972e			 
972e				; display debug step 
972e			 
972e			 
972e 11 6b ee			ld de, debug_mark 
9731 3e 25			ld a, display_row_1+display_cols-3 
9733 cd c1 8a			call str_at_display 
9736			 
9736				; display a 
9736 11 f7 97			ld de, .regstatea 
9739 3e 28			ld a, display_row_2 
973b cd c1 8a			call str_at_display 
973e			 
973e e1				pop hl 
973f			;	ld h,0 
973f			;	ld l, a 
973f 3e 2b			ld a, display_row_2+3 
9741 cd c1 95			call display_word_at 
9744			 
9744			 
9744				; display hl 
9744			 
9744			 
9744 11 eb 97			ld de, .regstatehl 
9747 3e 32			ld a, display_row_2+10 
9749 cd c1 8a			call str_at_display 
974c			 
974c e1				pop hl 
974d 3e 35			ld a, display_row_2+13 
974f cd c1 95			call display_word_at 
9752			 
9752				 
9752				; display de 
9752			 
9752 11 ef 97			ld de, .regstatede 
9755 3e 50			ld a, display_row_3 
9757 cd c1 8a			call str_at_display 
975a			 
975a e1				pop hl 
975b			;	ld h,d 
975b			;	ld l, e 
975b 3e 53			ld a, display_row_3+3 
975d cd c1 95			call display_word_at 
9760			 
9760			 
9760				; display bc 
9760			 
9760 11 f3 97			ld de, .regstatebc 
9763 3e 5a			ld a, display_row_3+10 
9765 cd c1 8a			call str_at_display 
9768			 
9768 e1				pop hl 
9769			;	ld h,b 
9769			;	ld l, c 
9769 3e 5d			ld a, display_row_3+13 
976b cd c1 95			call display_word_at 
976e			 
976e			 
976e				; display dsp 
976e			 
976e 11 fb 97			ld de, .regstatedsp 
9771 3e 78			ld a, display_row_4 
9773 cd c1 8a			call str_at_display 
9776			 
9776				 
9776 2a ee e9			ld hl,(cli_data_sp) 
9779 3e 7c			ld a, display_row_4+4 
977b cd c1 95			call display_word_at 
977e			 
977e				; display rsp 
977e			 
977e 11 00 98			ld de, .regstatersp 
9781 3e 82			ld a, display_row_4+10 
9783 cd c1 8a			call str_at_display 
9786			 
9786				 
9786 2a f2 e9			ld hl,(cli_ret_sp) 
9789 3e 86			ld a, display_row_4+14 
978b cd c1 95			call display_word_at 
978e			 
978e cd d1 8a			call update_display 
9791			 
9791			;	call delay1s 
9791			;	call delay1s 
9791			;	call delay1s 
9791			 
9791			 
9791			;	call next_page_prompt 
9791			 
9791				; restore  
9791			 
9791 f1				pop af 
9792 e1				pop hl 
9793 c1				pop bc 
9794 d1				pop de 
9795 c9				ret 
9796			 
9796 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
97aa .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
97bf .. 00		.ptrstate:	db "Ptr State",0 
97c9 .. 00		.ptrcliptr:     db "cli_ptr",0 
97d1 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
97db .. 00		.regstate:	db "Reg State (1/0)",0 
97eb .. 00		.regstatehl:	db "HL:",0 
97ef .. 00		.regstatede:	db "DE:",0 
97f3 .. 00		.regstatebc:	db "BC:",0 
97f7 .. 00		.regstatea:	db "A :",0 
97fb .. 00		.regstatedsp:	db "DSP:",0 
9800 .. 00		.regstatersp:	db "RSP:",0 
9805			 
9805			display_dump_at_hl: 
9805 e5				push hl 
9806 d5				push de 
9807 c5				push bc 
9808 f5				push af 
9809			 
9809 22 e4 e5			ld (os_cur_ptr),hl	 
980c cd ae 8a			call clear_display 
980f cd 26 9b			call dumpcont 
9812			;	call delay1s 
9812			;	call next_page_prompt 
9812			 
9812			 
9812 f1				pop af 
9813 c1				pop bc 
9814 d1				pop de 
9815 e1				pop hl 
9816 c9				ret 
9817			 
9817			;if ENABLE_BASIC 
9817			;	include "nascombasic.asm" 
9817			;	basic: 
9817			;	include "forth/FORTH.ASM" 
9817			;endif 
9817			 
9817			; eof 
9817			 
9817			 
# End of file firmware_diags.asm
9817			  
9817			include "firmware_prompts.asm"  
9817			; Prompts  
9817			 
9817			; boot messages 
9817			 
9817 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
982c .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
983c			 
983c			 
983c			; config menus 
983c			 
983c			;prom_c3: db "Add Dictionary To File",0 
983c			 
983c			if STARTUP_V1 
983c .. 00		prom_c2: db "Select Autoload File",0 
9851 .. 00		prom_c2a: db "Disable Autoload File", 0 
9867			endif 
9867			 
9867			if STARTUP_V2 
9867			prom_c2: db "Enable Autoload Files",0 
9867			prom_c2a: db "Disable Autoload Files", 0 
9867			 
9867			crs_s1: db "*ls-word", 0 
9867			crs_s2: db "*ed-word", 0 
9867			crs_s3: db "*Demo-Programs", 0 
9867			crs_s4: db "*Utils", 0 
9867			crs_s5: db "*SPI-Util", 0 
9867			crs_s6: db "*Key-constants", 0 
9867			crs_sound: db "*Sound-Util", 0 
9867			 
9867			 
9867			 
9867			endif 
9867			;prom_c2b: db "Select Storage Bank",0 
9867 .. 00		prom_c4: db "Settings",0 
9870 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
988b .. 00		prom_m4b:   db "Monitor",0 
9893 .. 00		prom_c1: db "Hardware Diags",0 
98a2			 
98a2			 
98a2			if STARTUP_V2 
98a2			prom_c9: db "Create Startup Files",0 
98a2			endif 
98a2			 
98a2 .. 00		prom_notav:    db "Feature not available",0 
98b8 .. 00		prom_empty:    db "",0 
98b9			 
98b9			; eof 
98b9			 
# End of file firmware_prompts.asm
98b9			  
98b9			  
98b9			; eof  
98b9			  
# End of file firmware.asm
98b9			 
98b9			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
98b9			;if BASE_KEV  
98b9			;baseram: equ 08000h 
98b9			;endif 
98b9			 
98b9			;if BASE_SC114 
98b9			;baseram:     equ    endofcode 
98b9			;endif 
98b9			 
98b9			 
98b9			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
98b9			 
98b9			; start system 
98b9			 
98b9			coldstart: 
98b9				; set sp 
98b9				; di/ei 
98b9			 
98b9 f3				di 
98ba 31 00 f0			ld sp, tos 
98bd cd 78 e5			call init_nmi 
98c0			;	ei 
98c0			 
98c0				; init spinner 
98c0 3e 00			ld a,0 
98c2 32 c6 eb			ld (display_active), a 
98c5			 
98c5				; disable breakpoint by default 
98c5			 
98c5				;ld a,'*' 
98c5			;	ld a,' ' 
98c5			;	ld (os_view_disable),a 
98c5			 
98c5				; set break point vector as new break point on or off 
98c5 cd 48 96			call bp_off 
98c8			 
98c8				; init hardware 
98c8			 
98c8				; init keyboard and screen hardware 
98c8			 
98c8 cd 1b 80			call hardware_init 
98cb			 
98cb			 
98cb cd f1 89			call delay1s 
98ce 3e 58			ld a, display_row_3+8 
98d0 11 03 80			ld de, buildtime 
98d3 cd c1 8a			call str_at_display 
98d6 cd d1 8a			call update_display 
98d9			 
98d9 cd f1 89			call delay1s 
98dc cd f1 89			call delay1s 
98df cd f1 89			call delay1s 
98e2			 
98e2				; detect if any keys are held down to enable breakpoints at start up 
98e2			 
98e2 cd 34 e6			call cin  
98e5 fe 00			cp 0 
98e7 28 03			jr z, .nokeys 
98e9			 
98e9				;call hardware_diags 
98e9 cd a6 94			call config 
98ec			 
98ec			;	ld de, .bpen 
98ec			;	ld a, display_row_4 
98ec			;	call str_at_display 
98ec			;	call update_display 
98ec			; 
98ec			;	ld a,0 
98ec			;	ld (os_view_disable),a 
98ec			; 
98ec			;.bpwait: 
98ec			;	call cin 
98ec			;	cp 0 
98ec			;	jr z, .bpwait 
98ec			;	jr .nokeys 
98ec			; 
98ec			; 
98ec			;.bpen:  db "Break points enabled!",0 
98ec			 
98ec			 
98ec			 
98ec			 
98ec			 
98ec			 
98ec			.nokeys: 
98ec			 
98ec			 
98ec				 
98ec			 
98ec			;jp  testkey 
98ec			 
98ec			;call storage_get_block_0 
98ec			; 
98ec			;ld hl, 0 
98ec			;ld de, store_page 
98ec			;call storage_read_block 
98ec			 
98ec				 
98ec			;ld hl, 10 
98ec			;ld de, store_page 
98ec			;call storage_read_block 
98ec			 
98ec			 
98ec			 
98ec			 
98ec			 
98ec			;stop:	nop 
98ec			;	jp stop 
98ec			 
98ec			 
98ec			 
98ec			main: 
98ec cd ae 8a			call clear_display 
98ef cd d1 8a			call update_display 
98f2			 
98f2			 
98f2			 
98f2			;	call testlcd 
98f2			 
98f2			 
98f2			 
98f2 cd 23 a0			call forth_init 
98f5			 
98f5			 
98f5			warmstart: 
98f5 cd f9 9f			call forth_warmstart 
98f8			 
98f8				; run startup word load 
98f8			        ; TODO prevent this running at warmstart after crash  
98f8			 
98f8				if STARTUP_ENABLE 
98f8			 
98f8					if STARTUP_V1 
98f8			 
98f8						if STORAGE_SE 
98f8							call forth_autoload 
98f8						endif 
98f8 cd c8 e4					call forth_startup 
98fb					endif 
98fb			 
98fb					if STARTUP_V2 
98fb			 
98fb						if STORAGE_SE 
98fb							call forth_autoload 
98fb						else 
98fb							call forth_startup 
98fb						endif 
98fb			 
98fb			 
98fb					endif 
98fb			 
98fb				endif 
98fb			 
98fb				; show free memory after boot 
98fb 11 87 99			ld de, freeram 
98fe 3e 00			ld a, display_row_1 
9900 cd c1 8a			call str_at_display 
9903			 
9903				; get current heap start after loading any uwords 
9903			 
9903				;ld de, (os_last_new_uword) 
9903				;ex de, hl 
9903			 
9903			; Or use heap_size word???? 
9903				;ld hl, heap_end 
9903				;ld hl, heap_size 
9903				;ld de, topusermem 
9903				;ld de, heap_start 
9903 ed 5b 4d e6			ld de, (free_list )      
9907 21 9c e2				ld hl, heap_end 
990a ed 52			sbc hl, de 
990c				;push hl 
990c				;ld a,h	         	 
990c				;ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
990c				;call hexout 
990c			   	;pop hl 
990c			; 
990c			;	ld a,l 
990c			;	ld hl, os_word_scratch+2 
990c			;	call hexout 
990c			;	ld hl, os_word_scratch+4 
990c			;	ld a, 0 
990c			;	ld (hl),a 
990c eb				ex de, hl 
990d 21 c6 e5			ld hl, os_word_scratch 
9910 cd 47 92			call uitoa_16 
9913			 
9913			 
9913 11 c6 e5			ld de, os_word_scratch 
9916 3e 0d			ld a, display_row_1 + 13 
9918 cd c1 8a			call str_at_display 
991b cd d1 8a			call update_display 
991e			 
991e			 
991e				;call demo 
991e			 
991e			 
991e				; init scratch input area for cli commands 
991e			 
991e 21 e8 e5			ld hl, os_cli_cmd 
9921 3e 00			ld a,0 
9923 77				ld (hl),a 
9924 23				inc hl 
9925 77				ld (hl),a 
9926			 
9926 3e 00			ld a,0 
9928 32 e7 e6			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
992b			 
992b 32 e4 e5			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
992e 32 e5 e5			ld (os_cur_ptr+1),a	 
9931			 
9931 32 c6 e5			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
9934 32 c7 e5			ld (os_word_scratch+1),a	 
9937				 
9937			 
9937				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9937 21 e8 e5			ld hl, os_cli_cmd 
993a			 
993a 3e 00			ld a, 0		 ; init cli input 
993c 77				ld (hl), a 
993d 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
993f			cli: 
993f				; show cli prompt 
993f				;push af 
993f				;ld a, 0 
993f				;ld de, prompt 
993f				;call str_at_display 
993f			 
993f				;call update_display 
993f				;pop af 
993f				;inc a 
993f				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
993f 0e 00			ld c, 0 
9941 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
9943 1e 28			ld e, 40 
9945			 
9945 21 e8 e5			ld hl, os_cli_cmd 
9948			 
9948				STACKFRAME OFF $fefe $9f9f 
9948				if DEBUG_STACK_IMB 
9948					if OFF 
9948						exx 
9948						ld de, $fefe 
9948						ld a, d 
9948						ld hl, curframe 
9948						call hexout 
9948						ld a, e 
9948						ld hl, curframe+2 
9948						call hexout 
9948						ld hl, $fefe 
9948						push hl 
9948						ld hl, $9f9f 
9948						push hl 
9948						exx 
9948					endif 
9948				endif 
9948			endm 
# End of macro STACKFRAME
9948			 
9948 cd 08 8d			call input_str 
994b			 
994b				STACKFRAMECHK OFF $fefe $9f9f 
994b				if DEBUG_STACK_IMB 
994b					if OFF 
994b						exx 
994b						ld hl, $9f9f 
994b						pop de   ; $9f9f 
994b						call cmp16 
994b						jr nz, .spnosame 
994b						ld hl, $fefe 
994b						pop de   ; $fefe 
994b						call cmp16 
994b						jr z, .spfrsame 
994b						.spnosame: call showsperror 
994b						.spfrsame: nop 
994b						exx 
994b					endif 
994b				endif 
994b			endm 
# End of macro STACKFRAMECHK
994b			 
994b				; copy input to last command 
994b			 
994b 21 e8 e5			ld hl, os_cli_cmd 
994e 11 e7 e6			ld de, os_last_cmd 
9951 01 ff 00			ld bc, 255 
9954 ed b0			ldir 
9956			 
9956				; wipe current buffer 
9956			 
9956			;	ld a, 0 
9956			;	ld hl, os_cli_cmd 
9956			;	ld de, os_cli_cmd+1 
9956			;	ld bc, 254 
9956			;	ldir 
9956				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
9956			;	call strcpy 
9956			;	ld a, 0 
9956			;	ld (hl), a 
9956			;	inc hl 
9956			;	ld (hl), a 
9956			;	inc hl 
9956			;	ld (hl), a 
9956			 
9956				; switch frame buffer to program  
9956			 
9956 21 10 ed				ld hl, display_fb1 
9959 22 cc eb				ld (display_fb_active), hl 
995c			 
995c			;	nop 
995c				STACKFRAME ON $fbfe $8f9f 
995c				if DEBUG_STACK_IMB 
995c					if ON 
995c						exx 
995c						ld de, $fbfe 
995c						ld a, d 
995c						ld hl, curframe 
995c						call hexout 
995c						ld a, e 
995c						ld hl, curframe+2 
995c						call hexout 
995c						ld hl, $fbfe 
995c						push hl 
995c						ld hl, $8f9f 
995c						push hl 
995c						exx 
995c					endif 
995c				endif 
995c			endm 
# End of macro STACKFRAME
995c				; first time into the parser so pass over the current scratch pad 
995c 21 e8 e5			ld hl,os_cli_cmd 
995f				; tokenise the entered statement(s) in HL 
995f cd a1 a0			call forthparse 
9962			        ; exec forth statements in top of return stack 
9962 cd e1 a0			call forthexec 
9965				;call forthexec_cleanup 
9965			;	call parsenext 
9965			 
9965				STACKFRAMECHK ON $fbfe $8f9f 
9965				if DEBUG_STACK_IMB 
9965					if ON 
9965						exx 
9965						ld hl, $8f9f 
9965						pop de   ; $8f9f 
9965						call cmp16 
9965						jr nz, .spnosame 
9965						ld hl, $fbfe 
9965						pop de   ; $fbfe 
9965						call cmp16 
9965						jr z, .spfrsame 
9965						.spnosame: call showsperror 
9965						.spfrsame: nop 
9965						exx 
9965					endif 
9965				endif 
9965			endm 
# End of macro STACKFRAMECHK
9965				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
9965			 
9965 3e 78			ld a, display_row_4 
9967 11 98 99			ld de, endprog 
996a			 
996a cd d1 8a			call update_display		 
996d			 
996d cd 1e 9c			call next_page_prompt 
9970			 
9970				; switch frame buffer to cli 
9970			 
9970 21 b1 ed				ld hl, display_fb0 
9973 22 cc eb				ld (display_fb_active), hl 
9976			 
9976			 
9976 cd ae 8a		        call clear_display 
9979 cd d1 8a			call update_display		 
997c			 
997c 21 e8 e5			ld hl, os_cli_cmd 
997f			 
997f 3e 00			ld a, 0		 ; init cli input 
9981 77				ld (hl), a 
9982			 
9982				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
9982			 
9982				; now on last line 
9982			 
9982				; TODO scroll screen up 
9982			 
9982				; TODO instead just clear screen and place at top of screen 
9982			 
9982			;	ld a, 0 
9982			;	ld (f_cursor_ptr),a 
9982			 
9982				;call clear_display 
9982				;call update_display 
9982			 
9982				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9982 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9984 c3 3f 99			jp cli 
9987			 
9987 .. 00		freeram: db "Free bytes: ",0 
9994 ..			asc: db "1A2F" 
9998 .. 00		endprog: db "End prog...",0 
99a4			 
99a4			testenter2:   
99a4 21 f3 e2			ld hl,scratch+50 
99a7 22 e4 e5			ld (os_cur_ptr),hl 
99aa c3 3f 99			jp cli 
99ad			 
99ad			testenter:  
99ad			 
99ad 21 94 99			ld hl,asc 
99b0			;	ld a,(hl) 
99b0			;	call nibble2val 
99b0 cd 91 91			call get_byte 
99b3			 
99b3			 
99b3			;	ld a,(hl) 
99b3			;	call atohex 
99b3			 
99b3			;	call fourehexhl 
99b3 32 f3 e2			ld (scratch+50),a 
99b6			 
99b6			 
99b6			 
99b6 21 96 99			ld hl,asc+2 
99b9			;	ld a, (hl) 
99b9			;	call nibble2val 
99b9 cd 91 91			call get_byte 
99bc			 
99bc			;	call fourehexhl 
99bc 32 f5 e2			ld (scratch+52),a 
99bf				 
99bf 21 f3 e2			ld hl,scratch+50 
99c2 22 e4 e5			ld (os_cur_ptr),hl 
99c5 c3 3f 99			jp cli 
99c8			 
99c8			enter:	 
99c8 3a c5 e2			ld a,(scratch+4) 
99cb fe 00			cp 0 
99cd 28 0c			jr z, .entercont 
99cf				; no, not a null term line so has an address to work out.... 
99cf			 
99cf 21 c3 e2			ld hl,scratch+2 
99d2 cd f1 91			call get_word_hl 
99d5			 
99d5 22 e4 e5			ld (os_cur_ptr),hl	 
99d8 c3 3f 99			jp cli 
99db			 
99db			 
99db			.entercont:  
99db			 
99db 21 c3 e2			ld hl, scratch+2 
99de cd 91 91			call get_byte 
99e1			 
99e1 2a e4 e5		   	ld hl,(os_cur_ptr) 
99e4 77					ld (hl),a 
99e5 23					inc hl 
99e6 22 e4 e5				ld (os_cur_ptr),hl 
99e9				 
99e9			; get byte  
99e9			 
99e9			 
99e9 c3 3f 99			jp cli 
99ec			 
99ec			 
99ec			; basic monitor support 
99ec			 
99ec			monitor: 
99ec				;  
99ec cd ae 8a			call clear_display 
99ef 3e 00			ld a, 0 
99f1 11 40 9a			ld de, .monprompt 
99f4 cd c1 8a			call str_at_display 
99f7 cd d1 8a			call update_display 
99fa			 
99fa				; get a monitor command 
99fa			 
99fa 0e 00			ld c, 0     ; entry at top left 
99fc 16 64			ld d, 100   ; max buffer size 
99fe 1e 0f			ld e, 15    ; input scroll area 
9a00 3e 00			ld a, 0     ; init string 
9a02 21 bf e4			ld hl, os_input 
9a05 77				ld (hl), a 
9a06 23				inc hl 
9a07 77				ld (hl), a 
9a08 21 bf e4			ld hl, os_input 
9a0b 3e 01			ld a, 1     ; init string 
9a0d cd 08 8d			call input_str 
9a10			 
9a10 cd ae 8a		        call clear_display 
9a13 cd d1 8a			call update_display		 
9a16			 
9a16 3a bf e4			ld a, (os_input) 
9a19 cd 8f 92			call toUpper 
9a1c fe 48		        cp 'H' 
9a1e ca a5 9a		        jp z, .monhelp 
9a21 fe 44			cp 'D'		; dump 
9a23 ca d8 9a			jp z, .mondump	 
9a26 fe 43			cp 'C'		; dump 
9a28 ca f2 9a			jp z, .moncdump	 
9a2b fe 4d			cp 'M'		; dump 
9a2d ca 42 9a			jp z, .moneditstart 
9a30 fe 55			cp 'U'		; dump 
9a32 ca 4e 9a			jp z, .monedit	 
9a35 fe 47			cp 'G'		; dump 
9a37 ca ce 9a			jp z, .monjump 
9a3a fe 51			cp 'Q'		; dump 
9a3c c8				ret z	 
9a3d			 
9a3d			 
9a3d				; TODO "S" to access symbol by name and not need the address 
9a3d				; TODO "F" to find a string in memory 
9a3d			 
9a3d c3 ec 99			jp monitor 
9a40			 
9a40 .. 00		.monprompt: db ">", 0 
9a42			 
9a42			.moneditstart: 
9a42				; get starting address 
9a42			 
9a42 21 c1 e4			ld hl,os_input+2 
9a45 cd f1 91			call get_word_hl 
9a48			 
9a48 22 e4 e5			ld (os_cur_ptr),hl	 
9a4b			 
9a4b c3 ec 99			jp monitor 
9a4e			 
9a4e			.monedit: 
9a4e				; get byte to load 
9a4e			 
9a4e 21 c1 e4			ld hl,os_input+2 
9a51 cd 91 91			call get_byte 
9a54			 
9a54				; get address to update 
9a54 2a e4 e5			ld hl, (os_cur_ptr) 
9a57			 
9a57				; update byte 
9a57			 
9a57 77				ld (hl), a 
9a58			 
9a58				; move to next address and save it 
9a58			 
9a58 23				inc hl 
9a59 22 e4 e5			ld (os_cur_ptr),hl	 
9a5c			 
9a5c c3 ec 99			jp monitor 
9a5f			 
9a5f			 
9a5f .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
9a73 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
9a8f .. 00		.monhelptext3:  db "G-Call address",0 
9a9e .. 00		.monhelptext4:  db "Q-Quit",0 
9aa5			        
9aa5			.monhelp: 
9aa5 3e 00			ld a, display_row_1 
9aa7 11 5f 9a		        ld de, .monhelptext1 
9aaa			 
9aaa cd c1 8a			call str_at_display 
9aad 3e 28			ld a, display_row_2 
9aaf 11 73 9a		        ld de, .monhelptext2 
9ab2					 
9ab2 cd c1 8a			call str_at_display 
9ab5 3e 50			ld a, display_row_3 
9ab7 11 8f 9a		        ld de, .monhelptext3 
9aba					 
9aba cd c1 8a			call str_at_display 
9abd 3e 78			ld a, display_row_4 
9abf 11 9e 9a		        ld de, .monhelptext4 
9ac2 cd c1 8a			call str_at_display 
9ac5			 
9ac5 cd d1 8a			call update_display		 
9ac8			 
9ac8 cd 1e 9c			call next_page_prompt 
9acb c3 ec 99			jp monitor 
9ace			 
9ace			.monjump:    
9ace 21 c1 e4			ld hl,os_input+2 
9ad1 cd f1 91			call get_word_hl 
9ad4			 
9ad4 e9				jp (hl) 
9ad5 c3 ec 99			jp monitor 
9ad8			 
9ad8			.mondump:    
9ad8 21 c1 e4			ld hl,os_input+2 
9adb cd f1 91			call get_word_hl 
9ade			 
9ade 22 e4 e5			ld (os_cur_ptr),hl	 
9ae1 cd 26 9b			call dumpcont 
9ae4 3e 78			ld a, display_row_4 
9ae6 11 98 99			ld de, endprog 
9ae9			 
9ae9 cd d1 8a			call update_display		 
9aec			 
9aec cd 1e 9c			call next_page_prompt 
9aef c3 ec 99			jp monitor 
9af2			.moncdump: 
9af2 cd 26 9b			call dumpcont 
9af5 3e 78			ld a, display_row_4 
9af7 11 98 99			ld de, endprog 
9afa			 
9afa cd d1 8a			call update_display		 
9afd			 
9afd cd 1e 9c			call next_page_prompt 
9b00 c3 ec 99			jp monitor 
9b03			 
9b03			 
9b03			; TODO symbol access  
9b03			 
9b03			.symbols:     ;; A list of symbols that can be called up  
9b03 b1 ed			dw display_fb0 
9b05 .. 00			db "fb0",0  
9b09 7a ea		     	dw store_page 
9b0b .. 00			db "store_page",0 
9b16			 
9b16			 
9b16			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
9b16			 
9b16 3a c2 e2			ld a,(scratch+1) 
9b19 fe 00			cp 0 
9b1b 28 09			jr z, dumpcont 
9b1d			 
9b1d				; no, not a null term line so has an address to work out.... 
9b1d			 
9b1d 21 c3 e2			ld hl,scratch+2 
9b20 cd f1 91			call get_word_hl 
9b23			 
9b23 22 e4 e5			ld (os_cur_ptr),hl	 
9b26			 
9b26			 
9b26			 
9b26			dumpcont: 
9b26			 
9b26				; dump bytes at ptr 
9b26			 
9b26			 
9b26 3e 00			ld a, display_row_1 
9b28 2a cc eb			ld hl, (display_fb_active) 
9b2b cd db 8c			call addatohl 
9b2e cd 56 9b			call .dumpbyterow 
9b31			 
9b31 3e 28			ld a, display_row_2 
9b33 2a cc eb			ld hl, (display_fb_active) 
9b36 cd db 8c			call addatohl 
9b39 cd 56 9b			call .dumpbyterow 
9b3c			 
9b3c			 
9b3c 3e 50			ld a, display_row_3 
9b3e 2a cc eb			ld hl, (display_fb_active) 
9b41 cd db 8c			call addatohl 
9b44 cd 56 9b			call .dumpbyterow 
9b47			 
9b47 3e 78			ld a, display_row_4 
9b49 2a cc eb			ld hl, (display_fb_active) 
9b4c cd db 8c			call addatohl 
9b4f cd 56 9b			call .dumpbyterow 
9b52			 
9b52 cd d1 8a			call update_display 
9b55			;		jp cli 
9b55 c9				ret 
9b56			 
9b56			.dumpbyterow: 
9b56			 
9b56				;push af 
9b56			 
9b56 e5				push hl 
9b57			 
9b57				; calc where to poke the ascii 
9b57			if display_cols == 20 
9b57				ld a, 16 
9b57			else 
9b57 3e 1f			ld a, 31 
9b59			endif 
9b59			 
9b59 cd db 8c			call addatohl 
9b5c 22 c6 e5			ld (os_word_scratch),hl  		; save pos for later 
9b5f			 
9b5f			 
9b5f			; display decoding address 
9b5f 2a e4 e5		   	ld hl,(os_cur_ptr) 
9b62			 
9b62 7c				ld a,h 
9b63 e1				pop hl 
9b64 e5				push hl 
9b65			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
9b65 cd 3b 91			call hexout 
9b68 2a e4 e5		   	ld hl,(os_cur_ptr) 
9b6b			 
9b6b 7d				ld a,l 
9b6c e1				pop hl 
9b6d 23				inc hl 
9b6e 23				inc hl 
9b6f e5				push hl 
9b70			;	ld hl, os_word_scratch+2 
9b70 cd 3b 91			call hexout 
9b73 e1				pop hl 
9b74 23				inc hl 
9b75 23				inc hl 
9b76				;ld hl, os_word_scratch+4 
9b76 3e 3a			ld a, ':' 
9b78 77				ld (hl),a 
9b79 23				inc hl 
9b7a				;ld a, 0 
9b7a				;ld (hl),a 
9b7a				;ld de, os_word_scratch 
9b7a				;pop af 
9b7a				;push af 
9b7a			;		ld a, display_row_2 
9b7a			;		call str_at_display 
9b7a			;		call update_display 
9b7a			 
9b7a			 
9b7a			;pop af 
9b7a			;	add 5 
9b7a			 
9b7a			if display_cols == 20 
9b7a				ld b, 4 
9b7a			else 
9b7a 06 08			ld b, 8 
9b7c			endif	 
9b7c			 
9b7c			.dumpbyte: 
9b7c c5				push bc 
9b7d e5				push hl 
9b7e			 
9b7e			 
9b7e 2a e4 e5		   	ld hl,(os_cur_ptr) 
9b81 7e					ld a,(hl) 
9b82			 
9b82					; poke the ascii to display 
9b82 2a c6 e5				ld hl,(os_word_scratch) 
9b85 77					ld (hl),a 
9b86 23					inc hl 
9b87 22 c6 e5				ld (os_word_scratch),hl 
9b8a			 
9b8a					 
9b8a			 
9b8a			 
9b8a e1					pop hl 
9b8b e5					push hl 
9b8c			 
9b8c cd 3b 91				call hexout 
9b8f			 
9b8f					 
9b8f 2a e4 e5		   	ld hl,(os_cur_ptr) 
9b92 23				inc hl 
9b93 22 e4 e5		   	ld (os_cur_ptr),hl 
9b96			 
9b96 e1					pop hl 
9b97 23					inc hl 
9b98 23					inc hl 
9b99 23					inc hl 
9b9a			 
9b9a			 
9b9a			 
9b9a					;ld a,0 
9b9a					;ld (os_word_scratch+2),a 
9b9a					;pop af 
9b9a					;push af 
9b9a			 
9b9a					;ld de, os_word_scratch 
9b9a					;call str_at_display 
9b9a			;		call update_display 
9b9a			;		pop af 
9b9a c1					pop bc 
9b9b c6 03				add 3 
9b9d 10 dd			djnz .dumpbyte 
9b9f			 
9b9f				 
9b9f			 
9b9f c9				ret 
9ba0			 
9ba0			jump:	 
9ba0			 
9ba0 21 c3 e2			ld hl,scratch+2 
9ba3 cd f1 91			call get_word_hl 
9ba6				;ld hl,(scratch+2) 
9ba6				;call fourehexhl 
9ba6			 
9ba6 22 e4 e5			ld (os_cur_ptr),hl	 
9ba9			 
9ba9 e9				jp (hl) 
9baa			 
9baa			 
9baa			 
9baa			; TODO implement a basic monitor mode to start with 
9baa			 
9baa			 
9baa			 
9baa			 
9baa			 
9baa			 
9baa			 
9baa			 
9baa			 
9baa			; testing and demo code during development 
9baa			 
9baa			 
9baa .. 00		str1: db "Enter some text...",0 
9bbd .. 00		clear: db "                    ",0 
9bd2			 
9bd2			demo: 
9bd2			 
9bd2			 
9bd2			 
9bd2			;	call update_display 
9bd2			 
9bd2				; init scratch input area for testing 
9bd2 21 c1 e2			ld hl, scratch	 
9bd5 3e 00			ld a,0 
9bd7 77				ld (hl),a 
9bd8			 
9bd8			 
9bd8 3e 28		            LD   A, display_row_2 
9bda			;            CALL fLCD_Pos       ;Position cursor to location in A 
9bda 11 aa 9b		            LD   DE, str1 
9bdd cd c1 8a			call str_at_display 
9be0			 
9be0			;            CALL fLCD_Str       ;Display string pointed to by DE 
9be0			cloop:	 
9be0 3e 50		            LD   A, display_row_3 
9be2			;            CALL fLCD_Pos       ;Position cursor to location in A 
9be2 11 bd 9b		            LD   DE, clear 
9be5			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
9be5 cd c1 8a				call str_at_display 
9be8 3e 78			ld a, display_row_4 
9bea 11 1a 9c			ld de, prompt 
9bed			 
9bed cd c1 8a				call str_at_display 
9bf0 cd d1 8a			call update_display 
9bf3			 
9bf3 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
9bf5 16 0a			ld d, 10 
9bf7 21 c1 e2			ld hl, scratch	 
9bfa cd 08 8d			call input_str 
9bfd			 
9bfd			;	call clear_display 
9bfd			;'	call update_display 
9bfd			 
9bfd 3e 00		            LD   A, display_row_1 
9bff			;            CALL fLCD_Pos       ;Position cursor to location in A 
9bff 11 bd 9b		            LD   DE, clear 
9c02 cd c1 8a				call str_at_display 
9c05			;            CALL fLCD_Str       ;Display string pointed to by DE 
9c05 3e 00		            LD   A, display_row_1 
9c07			;            CALL fLCD_Pos       ;Position cursor to location in A 
9c07 11 c1 e2		            LD   DE, scratch 
9c0a			;            CALL fLCD_Str       ;Display string pointed to by DE 
9c0a cd c1 8a				call str_at_display 
9c0d cd d1 8a			call update_display 
9c10			 
9c10 3e 00				ld a,0 
9c12 21 c1 e2			ld hl, scratch 
9c15 77				ld (hl),a 
9c16			 
9c16 00				nop 
9c17 c3 e0 9b			jp cloop 
9c1a			 
9c1a			 
9c1a			 
9c1a			; OS Prompt 
9c1a			 
9c1a .. 00		prompt: db ">",0 
9c1c .. 00		endprg: db "?",0 
9c1e			 
9c1e			 
9c1e			; handy next page prompt 
9c1e			next_page_prompt: 
9c1e e5				push hl 
9c1f d5				push de 
9c20 f5				push af 
9c21 c5				push bc 
9c22			 
9c22 3e 9f			ld a,display_row_4 + display_cols - 1 
9c24 11 1c 9c		        ld de, endprg 
9c27 cd c1 8a			call str_at_display 
9c2a cd d1 8a			call update_display 
9c2d cd 2e e6			call cin_wait 
9c30 c1				pop bc 
9c31 f1				pop af 
9c32 d1				pop de 
9c33 e1				pop hl 
9c34			 
9c34			 
9c34 c9				ret 
9c35			 
9c35			 
9c35			; forth parser 
9c35			 
9c35			; My forth kernel 
9c35			include "forth_kernel.asm" 
9c35			; 
9c35			; kernel to the forth OS 
9c35			 
9c35			DS_TYPE_STR: equ 1     ; string type 
9c35			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
9c35			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
9c35			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
9c35			 
9c35			FORTH_PARSEV1: equ 0 
9c35			FORTH_PARSEV2: equ 0 
9c35			FORTH_PARSEV3: equ 0 
9c35			FORTH_PARSEV4: equ 0 
9c35			FORTH_PARSEV5: equ 1 
9c35			 
9c35			;if FORTH_PARSEV5 
9c35			;	FORTH_END_BUFFER: equ 0 
9c35			;else 
9c35			FORTH_END_BUFFER: equ 127 
9c35			;endif 
9c35			 
9c35			FORTH_TRUE: equ 1 
9c35			FORTH_FALSE: equ 0 
9c35			 
9c35			if FORTH_PARSEV4 
9c35			include "forth_stackops.asm" 
9c35			endif 
9c35			 
9c35			if FORTH_PARSEV5 
9c35			include "forth_stackopsv5.asm" 
9c35			 
9c35			; Stack operations for v5 parser on wards 
9c35			; * DATA stack 
9c35			; * LOOP stack 
9c35			; * RETURN stack 
9c35			 
9c35			 
9c35			 
9c35			FORTH_CHK_DSP_UNDER: macro 
9c35				push hl 
9c35				push de 
9c35				ld hl,(cli_data_sp) 
9c35				ld de, cli_data_stack 
9c35				call cmp16 
9c35				jp c, fault_dsp_under 
9c35				pop de 
9c35				pop hl 
9c35				endm 
9c35			 
9c35			 
9c35			FORTH_CHK_RSP_UNDER: macro 
9c35				push hl 
9c35				push de 
9c35				ld hl,(cli_ret_sp) 
9c35				ld de, cli_ret_stack 
9c35				call cmp16 
9c35				jp c, fault_rsp_under 
9c35				pop de 
9c35				pop hl 
9c35				endm 
9c35			 
9c35			FORTH_CHK_LOOP_UNDER: macro 
9c35				push hl 
9c35				push de 
9c35				ld hl,(cli_loop_sp) 
9c35				ld de, cli_loop_stack 
9c35				call cmp16 
9c35				jp c, fault_loop_under 
9c35				pop de 
9c35				pop hl 
9c35				endm 
9c35			 
9c35			FORTH_ERR_TOS_NOTSTR: macro 
9c35				; TOSO might need more for checks when used 
9c35				push af 
9c35				ld a,(hl) 
9c35				cp DS_TYPE_STR 
9c35				jp nz, type_faultn   
9c35				pop af 
9c35				endm 
9c35			 
9c35			FORTH_ERR_TOS_NOTNUM: macro 
9c35				push af 
9c35				ld a,(hl) 
9c35				cp DS_TYPE_INUM 
9c35				jp nz, type_faultn   
9c35				pop af 
9c35				endm 
9c35			 
9c35			 
9c35			; increase data stack pointer and save hl to it 
9c35				 
9c35			FORTH_DSP_NEXT: macro 
9c35				call macro_forth_dsp_next 
9c35				endm 
9c35			 
9c35			 
9c35			macro_forth_dsp_next: 
9c35				if DEBUG_FORTH_STACK_GUARD 
9c35 cd a9 e2				call check_stacks 
9c38				endif 
9c38 e5				push hl 
9c39 d5				push de 
9c3a eb				ex de,hl 
9c3b 2a ee e9			ld hl,(cli_data_sp) 
9c3e 23				inc hl 
9c3f 23				inc hl 
9c40			 
9c40			; PARSEV5 
9c40 23				inc hl 
9c41 22 ee e9			ld (cli_data_sp),hl 
9c44 73				ld (hl), e 
9c45 23				inc hl 
9c46 72				ld (hl), d 
9c47 d1				pop de 
9c48 e1				pop hl 
9c49				if DEBUG_FORTH_STACK_GUARD 
9c49 cd a9 e2				call check_stacks 
9c4c				endif 
9c4c c9				ret 
9c4d			 
9c4d			 
9c4d			; increase ret stack pointer and save hl to it 
9c4d				 
9c4d			FORTH_RSP_NEXT: macro 
9c4d				call macro_forth_rsp_next 
9c4d				endm 
9c4d			 
9c4d			macro_forth_rsp_next: 
9c4d				if DEBUG_FORTH_STACK_GUARD 
9c4d cd a9 e2				call check_stacks 
9c50				endif 
9c50 e5				push hl 
9c51 d5				push de 
9c52 eb				ex de,hl 
9c53 2a f2 e9			ld hl,(cli_ret_sp) 
9c56 23				inc hl 
9c57 23				inc hl 
9c58 22 f2 e9			ld (cli_ret_sp),hl 
9c5b 73				ld (hl), e 
9c5c 23				inc hl 
9c5d 72				ld (hl), d 
9c5e d1				pop de 
9c5f e1				pop hl 
9c60				if DEBUG_FORTH_STACK_GUARD 
9c60 cd a9 e2				call check_stacks 
9c63				endif 
9c63 c9				ret 
9c64			 
9c64			; get current ret stack pointer and save to hl  
9c64				 
9c64			FORTH_RSP_TOS: macro 
9c64				call macro_forth_rsp_tos 
9c64				endm 
9c64			 
9c64			macro_forth_rsp_tos: 
9c64				;push de 
9c64 2a f2 e9			ld hl,(cli_ret_sp) 
9c67 cd 9f 9c			call loadhlptrtohl 
9c6a				;ld e, (hl) 
9c6a				;inc hl 
9c6a				;ld d, (hl) 
9c6a				;ex de, hl 
9c6a					if DEBUG_FORTH_WORDS 
9c6a			;			DMARK "RST" 
9c6a						CALLMONITOR 
9c6a cd 6f ee			call debug_vector  
9c6d				endm  
# End of macro CALLMONITOR
9c6d					endif 
9c6d				;pop de 
9c6d c9				ret 
9c6e			 
9c6e			; pop ret stack pointer 
9c6e				 
9c6e			FORTH_RSP_POP: macro 
9c6e				call macro_forth_rsp_pop 
9c6e				endm 
9c6e			 
9c6e			 
9c6e			macro_forth_rsp_pop: 
9c6e				if DEBUG_FORTH_STACK_GUARD 
9c6e			;		DMARK "RPP" 
9c6e cd a9 e2				call check_stacks 
9c71					FORTH_CHK_RSP_UNDER 
9c71 e5				push hl 
9c72 d5				push de 
9c73 2a f2 e9			ld hl,(cli_ret_sp) 
9c76 11 ac e9			ld de, cli_ret_stack 
9c79 cd f9 8c			call cmp16 
9c7c da bd e3			jp c, fault_rsp_under 
9c7f d1				pop de 
9c80 e1				pop hl 
9c81				endm 
# End of macro FORTH_CHK_RSP_UNDER
9c81				endif 
9c81 e5				push hl 
9c82 2a f2 e9			ld hl,(cli_ret_sp) 
9c85			 
9c85			 
9c85				if FORTH_ENABLE_FREE 
9c85			 
9c85					; get pointer 
9c85			 
9c85					push de 
9c85					push hl 
9c85			 
9c85					ld e, (hl) 
9c85					inc hl 
9c85					ld d, (hl) 
9c85			 
9c85					ex de, hl 
9c85					call free 
9c85			 
9c85					pop hl 
9c85					pop de 
9c85			 
9c85			 
9c85				endif 
9c85			 
9c85			 
9c85 2b				dec hl 
9c86 2b				dec hl 
9c87 22 f2 e9			ld (cli_ret_sp), hl 
9c8a				; do stack underflow checks 
9c8a e1				pop hl 
9c8b				if DEBUG_FORTH_STACK_GUARD 
9c8b cd a9 e2				call check_stacks 
9c8e					FORTH_CHK_RSP_UNDER 
9c8e e5				push hl 
9c8f d5				push de 
9c90 2a f2 e9			ld hl,(cli_ret_sp) 
9c93 11 ac e9			ld de, cli_ret_stack 
9c96 cd f9 8c			call cmp16 
9c99 da bd e3			jp c, fault_rsp_under 
9c9c d1				pop de 
9c9d e1				pop hl 
9c9e				endm 
# End of macro FORTH_CHK_RSP_UNDER
9c9e				endif 
9c9e c9				ret 
9c9f			 
9c9f			 
9c9f			 
9c9f			; routine to load word pointed to by hl into hl 
9c9f			 
9c9f			loadhlptrtohl: 
9c9f			 
9c9f d5				push de 
9ca0 5e				ld e, (hl) 
9ca1 23				inc hl 
9ca2 56				ld d, (hl) 
9ca3 eb				ex de, hl 
9ca4 d1				pop de 
9ca5			 
9ca5 c9				ret 
9ca6			 
9ca6			 
9ca6			 
9ca6			 
9ca6			 
9ca6			; push a number held in HL onto the data stack 
9ca6			; entry point for pushing a value when already in hl used in function above 
9ca6			 
9ca6			forth_push_numhl: 
9ca6			 
9ca6 e5				push hl    ; save value to push 
9ca7			 
9ca7			if DEBUG_FORTH_PUSH 
9ca7				; see if disabled 
9ca7			 
9ca7			 
9ca7 f5				push af 
9ca8 3a 6f ee			ld a,(debug_vector) 
9cab fe c9			cp $c9   ; ret 
9cad			;	ld a, (os_view_disable) 
9cad			;	cp '*' 
9cad 28 34			jr z, .pskip2 
9caf e5				push hl 
9cb0 e5			push hl 
9cb1 cd ae 8a			call clear_display 
9cb4 e1			pop hl 
9cb5 7c				ld a,h 
9cb6 21 c6 e5			ld hl, os_word_scratch 
9cb9 cd 3b 91			call hexout 
9cbc e1				pop hl 
9cbd 7d				ld a,l 
9cbe 21 c8 e5			ld hl, os_word_scratch+2 
9cc1 cd 3b 91			call hexout 
9cc4			 
9cc4 21 ca e5			ld hl, os_word_scratch+4 
9cc7 3e 00			ld a,0 
9cc9 77				ld (hl),a 
9cca 11 c6 e5			ld de,os_word_scratch 
9ccd 3e 28				ld a, display_row_2 
9ccf cd c1 8a				call str_at_display 
9cd2 11 bb cd			ld de, .push_num 
9cd5 3e 00			ld a, display_row_1 
9cd7			 
9cd7 cd c1 8a				call str_at_display 
9cda			 
9cda			 
9cda cd d1 8a			call update_display 
9cdd cd f1 89			call delay1s 
9ce0 cd f1 89			call delay1s 
9ce3			.pskip2:  
9ce3			 
9ce3 f1				pop af 
9ce4			endif	 
9ce4			 
9ce4			 
9ce4				FORTH_DSP_NEXT 
9ce4 cd 35 9c			call macro_forth_dsp_next 
9ce7				endm 
# End of macro FORTH_DSP_NEXT
9ce7			 
9ce7 2a ee e9			ld hl, (cli_data_sp) 
9cea			 
9cea				; save item type 
9cea 3e 02			ld a,  DS_TYPE_INUM 
9cec 77				ld (hl), a 
9ced 23				inc hl 
9cee			 
9cee				; get word off stack 
9cee d1				pop de 
9cef 7b				ld a,e 
9cf0 77				ld (hl), a 
9cf1 23				inc hl 
9cf2 7a				ld a,d 
9cf3 77				ld (hl), a 
9cf4			 
9cf4			if DEBUG_FORTH_PUSH 
9cf4 2b				dec hl 
9cf5 2b				dec hl 
9cf6 2b				dec hl 
9cf7						DMARK "PH5" 
9cf7 f5				push af  
9cf8 3a 0c 9d			ld a, (.dmark)  
9cfb 32 6b ee			ld (debug_mark),a  
9cfe 3a 0d 9d			ld a, (.dmark+1)  
9d01 32 6c ee			ld (debug_mark+1),a  
9d04 3a 0e 9d			ld a, (.dmark+2)  
9d07 32 6d ee			ld (debug_mark+2),a  
9d0a 18 03			jr .pastdmark  
9d0c ..			.dmark: db "PH5"  
9d0f f1			.pastdmark: pop af  
9d10			endm  
# End of macro DMARK
9d10				CALLMONITOR 
9d10 cd 6f ee			call debug_vector  
9d13				endm  
# End of macro CALLMONITOR
9d13			endif	 
9d13			 
9d13 c9				ret 
9d14			 
9d14			 
9d14			; Push a string to stack pointed to by hl 
9d14			 
9d14			forth_push_str: 
9d14			 
9d14			if DEBUG_FORTH_PUSH 
9d14						DMARK "PSQ" 
9d14 f5				push af  
9d15 3a 29 9d			ld a, (.dmark)  
9d18 32 6b ee			ld (debug_mark),a  
9d1b 3a 2a 9d			ld a, (.dmark+1)  
9d1e 32 6c ee			ld (debug_mark+1),a  
9d21 3a 2b 9d			ld a, (.dmark+2)  
9d24 32 6d ee			ld (debug_mark+2),a  
9d27 18 03			jr .pastdmark  
9d29 ..			.dmark: db "PSQ"  
9d2c f1			.pastdmark: pop af  
9d2d			endm  
# End of macro DMARK
9d2d				CALLMONITOR 
9d2d cd 6f ee			call debug_vector  
9d30				endm  
# End of macro CALLMONITOR
9d30			endif	 
9d30			    
9d30 e5				push hl 
9d31 e5				push hl 
9d32			 
9d32			;	ld a, 0   ; find end of string 
9d32 cd 98 92			call strlenz 
9d35			if DEBUG_FORTH_PUSH 
9d35						DMARK "PQ2" 
9d35 f5				push af  
9d36 3a 4a 9d			ld a, (.dmark)  
9d39 32 6b ee			ld (debug_mark),a  
9d3c 3a 4b 9d			ld a, (.dmark+1)  
9d3f 32 6c ee			ld (debug_mark+1),a  
9d42 3a 4c 9d			ld a, (.dmark+2)  
9d45 32 6d ee			ld (debug_mark+2),a  
9d48 18 03			jr .pastdmark  
9d4a ..			.dmark: db "PQ2"  
9d4d f1			.pastdmark: pop af  
9d4e			endm  
# End of macro DMARK
9d4e				CALLMONITOR 
9d4e cd 6f ee			call debug_vector  
9d51				endm  
# End of macro CALLMONITOR
9d51			endif	 
9d51 eb				ex de, hl 
9d52 e1				pop hl   ; get ptr to start of string 
9d53			if DEBUG_FORTH_PUSH 
9d53						DMARK "PQ3" 
9d53 f5				push af  
9d54 3a 68 9d			ld a, (.dmark)  
9d57 32 6b ee			ld (debug_mark),a  
9d5a 3a 69 9d			ld a, (.dmark+1)  
9d5d 32 6c ee			ld (debug_mark+1),a  
9d60 3a 6a 9d			ld a, (.dmark+2)  
9d63 32 6d ee			ld (debug_mark+2),a  
9d66 18 03			jr .pastdmark  
9d68 ..			.dmark: db "PQ3"  
9d6b f1			.pastdmark: pop af  
9d6c			endm  
# End of macro DMARK
9d6c				CALLMONITOR 
9d6c cd 6f ee			call debug_vector  
9d6f				endm  
# End of macro CALLMONITOR
9d6f			endif	 
9d6f 19				add hl,de 
9d70			if DEBUG_FORTH_PUSH 
9d70						DMARK "PQE" 
9d70 f5				push af  
9d71 3a 85 9d			ld a, (.dmark)  
9d74 32 6b ee			ld (debug_mark),a  
9d77 3a 86 9d			ld a, (.dmark+1)  
9d7a 32 6c ee			ld (debug_mark+1),a  
9d7d 3a 87 9d			ld a, (.dmark+2)  
9d80 32 6d ee			ld (debug_mark+2),a  
9d83 18 03			jr .pastdmark  
9d85 ..			.dmark: db "PQE"  
9d88 f1			.pastdmark: pop af  
9d89			endm  
# End of macro DMARK
9d89				CALLMONITOR 
9d89 cd 6f ee			call debug_vector  
9d8c				endm  
# End of macro CALLMONITOR
9d8c			endif	 
9d8c			 
9d8c 2b				dec hl    ; see if there is an optional trailing double quote 
9d8d 7e				ld a,(hl) 
9d8e fe 22			cp '"' 
9d90 20 03			jr nz, .strnoq 
9d92 3e 00			ld a, 0      ; get rid of double quote 
9d94 77				ld (hl), a 
9d95 23			.strnoq: inc hl 
9d96			 
9d96 3e 00			ld a, 0 
9d98 77				ld (hl), a     ; add null term and get rid of trailing double quote 
9d99			 
9d99 13				inc de ; add one for the type string 
9d9a 13				inc de ; add one for null term??? 
9d9b			 
9d9b				; tos is get string pointer again 
9d9b				; de contains space to allocate 
9d9b				 
9d9b d5				push de 
9d9c			 
9d9c eb				ex de, hl 
9d9d			 
9d9d				;push af 
9d9d			 
9d9d			if DEBUG_FORTH_PUSH 
9d9d						DMARK "PHm" 
9d9d f5				push af  
9d9e 3a b2 9d			ld a, (.dmark)  
9da1 32 6b ee			ld (debug_mark),a  
9da4 3a b3 9d			ld a, (.dmark+1)  
9da7 32 6c ee			ld (debug_mark+1),a  
9daa 3a b4 9d			ld a, (.dmark+2)  
9dad 32 6d ee			ld (debug_mark+2),a  
9db0 18 03			jr .pastdmark  
9db2 ..			.dmark: db "PHm"  
9db5 f1			.pastdmark: pop af  
9db6			endm  
# End of macro DMARK
9db6				CALLMONITOR 
9db6 cd 6f ee			call debug_vector  
9db9				endm  
# End of macro CALLMONITOR
9db9			endif	 
9db9 cd 0d 93			call malloc	; on ret hl now contains allocated memory 
9dbc				if DEBUG_FORTH_MALLOC_GUARD 
9dbc cc 13 ce				call z,malloc_error 
9dbf				endif 
9dbf			 
9dbf				 
9dbf c1				pop bc    ; get length 
9dc0 d1				pop de   ;  get string start    
9dc1			 
9dc1				; hl has destination from malloc 
9dc1			 
9dc1 eb				ex de, hl    ; prep for ldir 
9dc2			 
9dc2 d5				push de   ; save malloc area for DSP later 
9dc3				;push hl   ; save malloc area for DSP later 
9dc3			 
9dc3			if DEBUG_FORTH_PUSH 
9dc3						DMARK "PHc" 
9dc3 f5				push af  
9dc4 3a d8 9d			ld a, (.dmark)  
9dc7 32 6b ee			ld (debug_mark),a  
9dca 3a d9 9d			ld a, (.dmark+1)  
9dcd 32 6c ee			ld (debug_mark+1),a  
9dd0 3a da 9d			ld a, (.dmark+2)  
9dd3 32 6d ee			ld (debug_mark+2),a  
9dd6 18 03			jr .pastdmark  
9dd8 ..			.dmark: db "PHc"  
9ddb f1			.pastdmark: pop af  
9ddc			endm  
# End of macro DMARK
9ddc				CALLMONITOR 
9ddc cd 6f ee			call debug_vector  
9ddf				endm  
# End of macro CALLMONITOR
9ddf			endif	 
9ddf			 
9ddf			 
9ddf ed b0			ldir 
9de1			 
9de1			 
9de1				; push malloc to data stack     macro?????  
9de1			 
9de1				FORTH_DSP_NEXT 
9de1 cd 35 9c			call macro_forth_dsp_next 
9de4				endm 
# End of macro FORTH_DSP_NEXT
9de4			 
9de4				; save value and type 
9de4			 
9de4 2a ee e9			ld hl, (cli_data_sp) 
9de7			 
9de7				; save item type 
9de7 3e 01			ld a,  DS_TYPE_STR 
9de9 77				ld (hl), a 
9dea 23				inc hl 
9deb			 
9deb				; get malloc word off stack 
9deb d1				pop de 
9dec 73				ld (hl), e 
9ded 23				inc hl 
9dee 72				ld (hl), d 
9def			 
9def			 
9def			 
9def			if DEBUG_FORTH_PUSH 
9def 2a ee e9			ld hl, (cli_data_sp) 
9df2						DMARK "PHS" 
9df2 f5				push af  
9df3 3a 07 9e			ld a, (.dmark)  
9df6 32 6b ee			ld (debug_mark),a  
9df9 3a 08 9e			ld a, (.dmark+1)  
9dfc 32 6c ee			ld (debug_mark+1),a  
9dff 3a 09 9e			ld a, (.dmark+2)  
9e02 32 6d ee			ld (debug_mark+2),a  
9e05 18 03			jr .pastdmark  
9e07 ..			.dmark: db "PHS"  
9e0a f1			.pastdmark: pop af  
9e0b			endm  
# End of macro DMARK
9e0b				CALLMONITOR 
9e0b cd 6f ee			call debug_vector  
9e0e				endm  
# End of macro CALLMONITOR
9e0e			;	ex de,hl 
9e0e			endif	 
9e0e				; in case of spaces, skip the ptr past the copied string 
9e0e				;pop af 
9e0e				;ld (cli_origptr),hl 
9e0e			 
9e0e c9				ret 
9e0f			 
9e0f			 
9e0f			 
9e0f			; TODO ascii push input onto stack given hl to start of input 
9e0f			 
9e0f			; identify type 
9e0f			; if starts with a " then a string 
9e0f			; otherwise it is a number 
9e0f			;  
9e0f			; if a string 
9e0f			;     scan for ending " to get length of string to malloc for + 1 
9e0f			;     malloc 
9e0f			;     put pointer to string on stack first byte flags as string 
9e0f			; 
9e0f			; else a number 
9e0f			;    look for number format identifier 
9e0f			;    $xx hex 
9e0f			;    %xxxxx bin 
9e0f			;    xxxxx decimal 
9e0f			;    convert number to 16bit word.  
9e0f			;    malloc word + 1 with flag to identiy as num 
9e0f			;    put pointer to number on stack 
9e0f			;   
9e0f			;  
9e0f			  
9e0f			forth_apush: 
9e0f				; kernel push 
9e0f			 
9e0f			if DEBUG_FORTH_PUSH 
9e0f						DMARK "PSH" 
9e0f f5				push af  
9e10 3a 24 9e			ld a, (.dmark)  
9e13 32 6b ee			ld (debug_mark),a  
9e16 3a 25 9e			ld a, (.dmark+1)  
9e19 32 6c ee			ld (debug_mark+1),a  
9e1c 3a 26 9e			ld a, (.dmark+2)  
9e1f 32 6d ee			ld (debug_mark+2),a  
9e22 18 03			jr .pastdmark  
9e24 ..			.dmark: db "PSH"  
9e27 f1			.pastdmark: pop af  
9e28			endm  
# End of macro DMARK
9e28				CALLMONITOR 
9e28 cd 6f ee			call debug_vector  
9e2b				endm  
# End of macro CALLMONITOR
9e2b			endif	 
9e2b				; identify input type 
9e2b			 
9e2b 7e				ld a,(hl) 
9e2c fe 22			cp '"' 
9e2e 28 0a			jr z, .fapstr 
9e30 fe 24			cp '$' 
9e32 ca 5a 9e			jp z, .faphex 
9e35 fe 25			cp '%' 
9e37 ca 42 9e			jp z, .fapbin 
9e3a			;	cp 'b' 
9e3a			;	jp z, .fabin 
9e3a				; else decimal 
9e3a			 
9e3a				; TODO do decimal conversion 
9e3a				; decimal is stored as a 16bit word 
9e3a			 
9e3a				; by default everything is a string if type is not detected 
9e3a			.fapstr: ; 
9e3a fe 22			cp '"' 
9e3c 20 01			jr nz, .strnoqu 
9e3e 23				inc hl 
9e3f			.strnoqu: 
9e3f c3 14 9d			jp forth_push_str 
9e42			 
9e42			 
9e42			 
9e42			.fapbin:    ; push a binary string.  
9e42 11 00 00			ld de, 0   ; hold a 16bit value 
9e45			 
9e45 23			.fapbinshift:	inc hl  
9e46 7e				ld a,(hl) 
9e47 fe 00			cp 0     ; done scanning  
9e49 28 0b			jr z, .fapbdone  	; got it in HL so push  
9e4b			 
9e4b				; left shift de 
9e4b eb				ex de, hl	 
9e4c 29				add hl, hl 
9e4d			 
9e4d				; is 1 
9e4d fe 31			cp '1' 
9e4f 20 02			jr nz, .binzero 
9e51 cb 4d			bit 1, l 
9e53			.binzero: 
9e53 eb				ex de, hl	 ; save current de 
9e54 18 ef			jr .fapbinshift 
9e56			 
9e56			.fapbdone: 
9e56 eb				ex de, hl 
9e57 c3 a6 9c			jp forth_push_numhl 
9e5a			 
9e5a			 
9e5a			.faphex:   ; hex is always stored as a 16bit word 
9e5a				; skip number prefix 
9e5a 23				inc hl 
9e5b				; turn ascii into number 
9e5b cd f1 91			call get_word_hl	; ret 16bit word in hl 
9e5e			 
9e5e c3 a6 9c			jp forth_push_numhl 
9e61			 
9e61 00				 nop 
9e62			 
9e62			.fabin:   ; TODO bin conversion 
9e62			 
9e62			 
9e62 c9				ret 
9e63			 
9e63			 
9e63			; get either a string ptr or a 16bit word from the data stack 
9e63			 
9e63			FORTH_DSP: macro 
9e63				call macro_forth_dsp 
9e63				endm 
9e63			 
9e63			macro_forth_dsp: 
9e63				; data stack pointer points to current word on tos 
9e63			 
9e63 2a ee e9			ld hl,(cli_data_sp) 
9e66			 
9e66				if DEBUG_FORTH_PUSH 
9e66						DMARK "DSP" 
9e66 f5				push af  
9e67 3a 7b 9e			ld a, (.dmark)  
9e6a 32 6b ee			ld (debug_mark),a  
9e6d 3a 7c 9e			ld a, (.dmark+1)  
9e70 32 6c ee			ld (debug_mark+1),a  
9e73 3a 7d 9e			ld a, (.dmark+2)  
9e76 32 6d ee			ld (debug_mark+2),a  
9e79 18 03			jr .pastdmark  
9e7b ..			.dmark: db "DSP"  
9e7e f1			.pastdmark: pop af  
9e7f			endm  
# End of macro DMARK
9e7f			 
9e7f cd 46 ce				call display_data_sp 
9e82				;call break_point_state 
9e82				;rst 030h 
9e82				CALLMONITOR 
9e82 cd 6f ee			call debug_vector  
9e85				endm  
# End of macro CALLMONITOR
9e85				endif 
9e85			 
9e85 c9				ret 
9e86			 
9e86			; return hl to start of value on stack 
9e86			 
9e86			FORTH_DSP_VALUE: macro 
9e86				call macro_forth_dsp_value 
9e86				endm 
9e86			 
9e86			macro_forth_dsp_value: 
9e86			 
9e86				FORTH_DSP 
9e86 cd 63 9e			call macro_forth_dsp 
9e89				endm 
# End of macro FORTH_DSP
9e89			 
9e89 d5				push de 
9e8a			 
9e8a 23				inc hl ; skip type 
9e8b			 
9e8b 5e				ld e, (hl) 
9e8c 23				inc hl 
9e8d 56				ld d, (hl) 
9e8e eb				ex de,hl  
9e8f			 
9e8f d1				pop de 
9e90			 
9e90 c9				ret 
9e91			 
9e91			; return hl to start of value to second item on stack 
9e91			 
9e91			FORTH_DSP_VALUEM1: macro 
9e91				call macro_forth_dsp_value_m1 
9e91				endm 
9e91			 
9e91			macro_forth_dsp_value_m1: 
9e91			 
9e91				FORTH_DSP 
9e91 cd 63 9e			call macro_forth_dsp 
9e94				endm 
# End of macro FORTH_DSP
9e94			 
9e94 2b				dec hl 
9e95 2b				dec hl 
9e96			;	dec hl 
9e96			 
9e96 d5				push de 
9e97			 
9e97 5e				ld e, (hl) 
9e98 23				inc hl 
9e99 56				ld d, (hl) 
9e9a eb				ex de,hl  
9e9b			 
9e9b d1				pop de 
9e9c			 
9e9c c9				ret 
9e9d			 
9e9d				 
9e9d			 
9e9d			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
9e9d			 
9e9d			FORTH_DSP_POP: macro 
9e9d				call macro_forth_dsp_pop 
9e9d				endm 
9e9d			 
9e9d			 
9e9d			; get the tos data type 
9e9d			 
9e9d			FORTH_DSP_TYPE:   macro 
9e9d			 
9e9d				;FORTH_DSP_VALUE 
9e9d				FORTH_DSP 
9e9d				 
9e9d				; hl points to value 
9e9d				; check type 
9e9d			 
9e9d				ld a,(hl) 
9e9d			 
9e9d				endm 
9e9d			 
9e9d			; load the tos value into hl 
9e9d			 
9e9d			 
9e9d			FORTH_DSP_VALUEHL:  macro 
9e9d				call macro_dsp_valuehl 
9e9d				endm 
9e9d			 
9e9d			 
9e9d			 
9e9d			macro_dsp_valuehl: 
9e9d				FORTH_DSP_VALUE 
9e9d cd 86 9e			call macro_forth_dsp_value 
9ea0				endm 
# End of macro FORTH_DSP_VALUE
9ea0			 
9ea0				;FORTH_ERR_TOS_NOTNUM 
9ea0			 
9ea0				;inc hl   ; skip type id 
9ea0			 
9ea0			;	push de 
9ea0			; 
9ea0			;	ld e, (hl) 
9ea0			;	inc hl 
9ea0			;	ld d, (hl) 
9ea0			;	ex de,hl  
9ea0			 
9ea0			;	pop de 
9ea0			 
9ea0				if DEBUG_FORTH_PUSH 
9ea0						DMARK "DVL" 
9ea0 f5				push af  
9ea1 3a b5 9e			ld a, (.dmark)  
9ea4 32 6b ee			ld (debug_mark),a  
9ea7 3a b6 9e			ld a, (.dmark+1)  
9eaa 32 6c ee			ld (debug_mark+1),a  
9ead 3a b7 9e			ld a, (.dmark+2)  
9eb0 32 6d ee			ld (debug_mark+2),a  
9eb3 18 03			jr .pastdmark  
9eb5 ..			.dmark: db "DVL"  
9eb8 f1			.pastdmark: pop af  
9eb9			endm  
# End of macro DMARK
9eb9				CALLMONITOR 
9eb9 cd 6f ee			call debug_vector  
9ebc				endm  
# End of macro CALLMONITOR
9ebc				endif 
9ebc c9				ret 
9ebd			 
9ebd			forth_apushstrhl:      
9ebd				; push of string requires use of cli_origptr 
9ebd				; bodge use 
9ebd			 
9ebd				; get current cli_origptr, save, update with temp pointer  
9ebd ed 5b 3e ea		ld de, (cli_origptr) 
9ec1 22 3e ea			ld (cli_origptr), hl 
9ec4 d5				push de 
9ec5 cd 0f 9e			call forth_apush 
9ec8 d1				pop de 
9ec9 ed 53 3e ea		ld (cli_origptr), de 
9ecd c9			        ret	 
9ece			 
9ece			 
9ece			; increase loop stack pointer and save hl to it 
9ece				 
9ece			FORTH_LOOP_NEXT: macro 
9ece				call macro_forth_loop_next 
9ece				;nop 
9ece				endm 
9ece			 
9ece			macro_forth_loop_next: 
9ece				if DEBUG_FORTH_STACK_GUARD 
9ece cd a9 e2				call check_stacks 
9ed1				endif 
9ed1 e5				push hl 
9ed2 d5				push de 
9ed3 eb				ex de,hl 
9ed4 2a f0 e9			ld hl,(cli_loop_sp) 
9ed7 23				inc hl 
9ed8 23				inc hl 
9ed9					if DEBUG_FORTH_WORDS 
9ed9						DMARK "LNX" 
9ed9 f5				push af  
9eda 3a ee 9e			ld a, (.dmark)  
9edd 32 6b ee			ld (debug_mark),a  
9ee0 3a ef 9e			ld a, (.dmark+1)  
9ee3 32 6c ee			ld (debug_mark+1),a  
9ee6 3a f0 9e			ld a, (.dmark+2)  
9ee9 32 6d ee			ld (debug_mark+2),a  
9eec 18 03			jr .pastdmark  
9eee ..			.dmark: db "LNX"  
9ef1 f1			.pastdmark: pop af  
9ef2			endm  
# End of macro DMARK
9ef2						CALLMONITOR 
9ef2 cd 6f ee			call debug_vector  
9ef5				endm  
# End of macro CALLMONITOR
9ef5					endif 
9ef5 22 f0 e9			ld (cli_loop_sp),hl 
9ef8 73				ld (hl), e 
9ef9 23				inc hl 
9efa 72				ld (hl), d 
9efb d1				pop de    ; been reversed so save a swap on restore 
9efc e1				pop hl 
9efd				if DEBUG_FORTH_STACK_GUARD 
9efd cd a9 e2				call check_stacks 
9f00				endif 
9f00 c9				ret 
9f01			 
9f01			; get current ret stack pointer and save to hl  
9f01				 
9f01			FORTH_LOOP_TOS: macro 
9f01				call macro_forth_loop_tos 
9f01				endm 
9f01			 
9f01			macro_forth_loop_tos: 
9f01 d5				push de 
9f02 2a f0 e9			ld hl,(cli_loop_sp) 
9f05 5e				ld e, (hl) 
9f06 23				inc hl 
9f07 56				ld d, (hl) 
9f08 eb				ex de, hl 
9f09 d1				pop de 
9f0a c9				ret 
9f0b			 
9f0b			; pop loop stack pointer 
9f0b				 
9f0b			FORTH_LOOP_POP: macro 
9f0b				call macro_forth_loop_pop 
9f0b				endm 
9f0b			 
9f0b			 
9f0b			macro_forth_loop_pop: 
9f0b				if DEBUG_FORTH_STACK_GUARD 
9f0b					DMARK "LPP" 
9f0b f5				push af  
9f0c 3a 20 9f			ld a, (.dmark)  
9f0f 32 6b ee			ld (debug_mark),a  
9f12 3a 21 9f			ld a, (.dmark+1)  
9f15 32 6c ee			ld (debug_mark+1),a  
9f18 3a 22 9f			ld a, (.dmark+2)  
9f1b 32 6d ee			ld (debug_mark+2),a  
9f1e 18 03			jr .pastdmark  
9f20 ..			.dmark: db "LPP"  
9f23 f1			.pastdmark: pop af  
9f24			endm  
# End of macro DMARK
9f24 cd a9 e2				call check_stacks 
9f27					FORTH_CHK_LOOP_UNDER 
9f27 e5				push hl 
9f28 d5				push de 
9f29 2a f0 e9			ld hl,(cli_loop_sp) 
9f2c 11 2a e9			ld de, cli_loop_stack 
9f2f cd f9 8c			call cmp16 
9f32 da c3 e3			jp c, fault_loop_under 
9f35 d1				pop de 
9f36 e1				pop hl 
9f37				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9f37				endif 
9f37 e5				push hl 
9f38 2a f0 e9			ld hl,(cli_loop_sp) 
9f3b 2b				dec hl 
9f3c 2b				dec hl 
9f3d 22 f0 e9			ld (cli_loop_sp), hl 
9f40				; TODO do stack underflow checks 
9f40 e1				pop hl 
9f41				if DEBUG_FORTH_STACK_GUARD 
9f41 cd a9 e2				call check_stacks 
9f44					FORTH_CHK_LOOP_UNDER 
9f44 e5				push hl 
9f45 d5				push de 
9f46 2a f0 e9			ld hl,(cli_loop_sp) 
9f49 11 2a e9			ld de, cli_loop_stack 
9f4c cd f9 8c			call cmp16 
9f4f da c3 e3			jp c, fault_loop_under 
9f52 d1				pop de 
9f53 e1				pop hl 
9f54				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9f54				endif 
9f54 c9				ret 
9f55			 
9f55			macro_forth_dsp_pop: 
9f55			 
9f55 e5				push hl 
9f56			 
9f56				; release malloc data 
9f56			 
9f56				if DEBUG_FORTH_STACK_GUARD 
9f56 cd a9 e2				call check_stacks 
9f59					FORTH_CHK_DSP_UNDER 
9f59 e5				push hl 
9f5a d5				push de 
9f5b 2a ee e9			ld hl,(cli_data_sp) 
9f5e 11 28 e8			ld de, cli_data_stack 
9f61 cd f9 8c			call cmp16 
9f64 da b7 e3			jp c, fault_dsp_under 
9f67 d1				pop de 
9f68 e1				pop hl 
9f69				endm 
# End of macro FORTH_CHK_DSP_UNDER
9f69				endif 
9f69				;ld hl,(cli_data_sp) 
9f69			if DEBUG_FORTH_DOT 
9f69				DMARK "DPP" 
9f69 f5				push af  
9f6a 3a 7e 9f			ld a, (.dmark)  
9f6d 32 6b ee			ld (debug_mark),a  
9f70 3a 7f 9f			ld a, (.dmark+1)  
9f73 32 6c ee			ld (debug_mark+1),a  
9f76 3a 80 9f			ld a, (.dmark+2)  
9f79 32 6d ee			ld (debug_mark+2),a  
9f7c 18 03			jr .pastdmark  
9f7e ..			.dmark: db "DPP"  
9f81 f1			.pastdmark: pop af  
9f82			endm  
# End of macro DMARK
9f82				CALLMONITOR 
9f82 cd 6f ee			call debug_vector  
9f85				endm  
# End of macro CALLMONITOR
9f85			endif	 
9f85			 
9f85			 
9f85			if FORTH_ENABLE_DSPPOPFREE 
9f85			 
9f85				FORTH_DSP 
9f85 cd 63 9e			call macro_forth_dsp 
9f88				endm 
# End of macro FORTH_DSP
9f88			 
9f88 7e				ld a, (hl) 
9f89 fe 01			cp DS_TYPE_STR 
9f8b 20 23			jr nz, .skippopfree 
9f8d			 
9f8d				FORTH_DSP_VALUEHL 
9f8d cd 9d 9e			call macro_dsp_valuehl 
9f90				endm 
# End of macro FORTH_DSP_VALUEHL
9f90 00				nop 
9f91			if DEBUG_FORTH_DOT 
9f91				DMARK "DPf" 
9f91 f5				push af  
9f92 3a a6 9f			ld a, (.dmark)  
9f95 32 6b ee			ld (debug_mark),a  
9f98 3a a7 9f			ld a, (.dmark+1)  
9f9b 32 6c ee			ld (debug_mark+1),a  
9f9e 3a a8 9f			ld a, (.dmark+2)  
9fa1 32 6d ee			ld (debug_mark+2),a  
9fa4 18 03			jr .pastdmark  
9fa6 ..			.dmark: db "DPf"  
9fa9 f1			.pastdmark: pop af  
9faa			endm  
# End of macro DMARK
9faa				CALLMONITOR 
9faa cd 6f ee			call debug_vector  
9fad				endm  
# End of macro CALLMONITOR
9fad			endif	 
9fad cd d7 93			call free 
9fb0			.skippopfree: 
9fb0				 
9fb0			 
9fb0			endif 
9fb0			 
9fb0			if DEBUG_FORTH_DOT_KEY 
9fb0				DMARK "DP2" 
9fb0				CALLMONITOR 
9fb0			endif	 
9fb0			 
9fb0				; move pointer down 
9fb0			 
9fb0 2a ee e9			ld hl,(cli_data_sp) 
9fb3 2b				dec hl 
9fb4 2b				dec hl 
9fb5			; PARSEV5 
9fb5 2b				dec hl 
9fb6 22 ee e9			ld (cli_data_sp), hl 
9fb9			 
9fb9				if DEBUG_FORTH_STACK_GUARD 
9fb9 cd a9 e2				call check_stacks 
9fbc					FORTH_CHK_DSP_UNDER 
9fbc e5				push hl 
9fbd d5				push de 
9fbe 2a ee e9			ld hl,(cli_data_sp) 
9fc1 11 28 e8			ld de, cli_data_stack 
9fc4 cd f9 8c			call cmp16 
9fc7 da b7 e3			jp c, fault_dsp_under 
9fca d1				pop de 
9fcb e1				pop hl 
9fcc				endm 
# End of macro FORTH_CHK_DSP_UNDER
9fcc				endif 
9fcc			 
9fcc e1				pop hl 
9fcd			 
9fcd c9				ret 
9fce			 
9fce			getwordathl: 
9fce				; hl points to an address 
9fce				; load hl with the word at that address 
9fce			 
9fce d5				push de 
9fcf			 
9fcf 5e				ld e, (hl) 
9fd0 23				inc hl 
9fd1 56				ld d, (hl) 
9fd2 eb				ex de, hl 
9fd3			 
9fd3 d1				pop de 
9fd4 c9				ret 
9fd5			 
9fd5			 
9fd5			 
9fd5			 
9fd5			 
9fd5			; eof 
9fd5			 
# End of file forth_stackopsv5.asm
9fd5			endif 
9fd5			 
9fd5			loadwordinhl:	 
9fd5			 
9fd5 d5				push de 
9fd6			 
9fd6 5e				ld e, (hl) 
9fd7 23				inc hl 
9fd8 56				ld d, (hl) 
9fd9 eb				ex de,hl  
9fda			 
9fda d1				pop de 
9fdb			 
9fdb c9				ret 
9fdc			 
9fdc			user_word_eol:  
9fdc				; hl contains the pointer to where to create a linked list item from the end 
9fdc				; of the user dict to continue on at the system word dict 
9fdc				 
9fdc				; poke the stub of the word list linked list to repoint to rom words 
9fdc			 
9fdc				; stub format 
9fdc				; db   word id 
9fdc				; dw    link to next word 
9fdc			        ; db char length of token 
9fdc				; db string + 0 term 
9fdc				; db exec code....  
9fdc			 
9fdc 3e 00			ld a, WORD_SYS_ROOT     ; root word 
9fde 77				ld (hl), a		; word id 
9fdf 23				inc hl 
9fe0			 
9fe0 11 ab a1			ld de, sysdict 
9fe3 73				ld (hl), e		; next word link ie system dict 
9fe4 23				inc hl 
9fe5 72				ld (hl), d		; next word link ie system dict 
9fe6 23				inc hl	 
9fe7			 
9fe7			;	ld (hl), sysdict		; next word link ie system dict 
9fe7			;	inc hl 
9fe7			;	inc hl 
9fe7			 
9fe7			;	inc hl 
9fe7			;	inc hl 
9fe7			 
9fe7 3e 02			ld a, 2			; word length is 0 
9fe9 77				ld (hl), a	 
9fea 23				inc hl 
9feb			 
9feb 3e 7e			ld a, '~'			; word length is 0 
9fed 77				ld (hl), a	 
9fee 23				inc hl 
9fef 3e 00			ld a, 0			; save empty word 
9ff1 77				ld (hl), a 
9ff2			 
9ff2 c9				ret 
9ff3			 
9ff3				 
9ff3			 
9ff3			forthexec_cleanup: 
9ff3				FORTH_RSP_POP 
9ff3 cd 6e 9c			call macro_forth_rsp_pop 
9ff6				endm 
# End of macro FORTH_RSP_POP
9ff6 c9				ret 
9ff7			 
9ff7			forth_call_hl: 
9ff7				; taking hl 
9ff7 e5				push hl 
9ff8 c9				ret 
9ff9			 
9ff9			; this is called to reset Forth system but keep existing uwords etc 
9ff9			 
9ff9			forth_warmstart: 
9ff9				; setup stack over/under flow checks 
9ff9				if DEBUG_FORTH_STACK_GUARD 
9ff9 cd 8f e2				call chk_stk_init 
9ffc				endif 
9ffc			 
9ffc				; init stack pointers  - * these stacks go upwards *  
9ffc 21 ac e9			ld hl, cli_ret_stack 
9fff 22 f2 e9			ld (cli_ret_sp), hl	 
a002				; set bottom of stack 
a002 3e 00			ld a,0 
a004 77				ld (hl),a 
a005 23				inc hl 
a006 77				ld (hl),a 
a007			 
a007 21 28 e8			ld hl, cli_data_stack 
a00a 22 ee e9			ld (cli_data_sp), hl	 
a00d				; set bottom of stack 
a00d 3e 00			ld a,0 
a00f 77				ld (hl),a 
a010 23				inc hl 
a011 77				ld (hl),a 
a012			 
a012 21 2a e9			ld hl, cli_loop_stack 
a015 22 f0 e9			ld (cli_loop_sp), hl	 
a018				; set bottom of stack 
a018 3e 00			ld a,0 
a01a 77				ld (hl),a 
a01b 23				inc hl 
a01c 77				ld (hl),a 
a01d			 
a01d				; init extent of current open file 
a01d			 
a01d 3e 00			ld a, 0 
a01f 32 6a ea			ld (store_openext), a 
a022			 
a022 c9				ret 
a023			 
a023			 
a023			 
a023			; Cold Start - this is called to setup the whole Forth system 
a023			 
a023			forth_init: 
a023			 
a023				; setup stack over/under flow checks 
a023			 
a023			;	if DEBUG_FORTH_STACK_GUARD 
a023			;		call chk_stk_init 
a023			;	endif 
a023			 
a023				; enable auto display updates (slow.....) 
a023			 
a023 3e 01			ld a, 1 
a025 32 3c ea			ld (cli_autodisplay), a 
a028			 
a028				; if storage is in use disable long reads for now 
a028 3e 00			ld a, 0 
a02a 32 75 ea			ld (store_longread), a 
a02d			 
a02d			 
a02d				; show start up screen 
a02d			 
a02d cd ae 8a			call clear_display 
a030			 
a030 3e 00			ld a,0 
a032 32 5e ea			ld (f_cursor_ptr), a 
a035			 
a035				; set start of word list in start of ram - for use when creating user words 
a035			 
a035 21 43 e6			ld hl, baseram 
a038 22 be e5			ld (os_last_new_uword), hl 
a03b cd dc 9f			call user_word_eol 
a03e				 
a03e			;		call display_data_sp 
a03e			;		call next_page_prompt 
a03e			 
a03e			 
a03e			 
a03e			 
a03e c9				ret 
a03f			 
a03f .. 00		.bootforth: db " Forth Kernel Init ",0 
a053			 
a053			; TODO push to stack 
a053			 
a053			;  
a053			 
a053			if FORTH_PARSEV2 
a053			 
a053			 
a053				include "forth_parserv2.asm" 
a053			 
a053			endif 
a053			 
a053			 
a053			; parse cli version 1 
a053			 
a053			if FORTH_PARSEV1 
a053			 
a053			 
a053			 
a053			      include "forth_parserv1.asm" 
a053			endif 
a053				 
a053			if FORTH_PARSEV3 
a053			 
a053			 
a053			 
a053			      include "forth_parserv3.asm" 
a053				include "forth_wordsv3.asm" 
a053			endif 
a053			 
a053			if FORTH_PARSEV4 
a053			 
a053			 
a053			 
a053			      include "forth_parserv4.asm" 
a053				include "forth_wordsv4.asm" 
a053			endif 
a053			 
a053			if FORTH_PARSEV5 
a053			 
a053			 
a053			 
a053			      include "forth_parserv5.asm" 
a053			 
a053			 
a053			; A better parser without using malloc and string copies all over the place.  
a053			; Exec in situ should be faster 
a053			 
a053			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
a053			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
a053			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
a053			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
a053			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
a053			WORD_SYS_END: equ 0   ; Opcode for all user words 
a053			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
a053			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
a053			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
a053			 
a053			; Core word preamble macro 
a053			 
a053			CWHEAD:   macro nxtword opcode lit len opflags 
a053				db WORD_SYS_CORE+opcode             
a053				; internal op code number 
a053				dw nxtword            
a053				; link to next dict word block 
a053				db len + 1 
a053				; literal length of dict word inc zero term 
a053				db lit,0              
a053				; literal dict word 
a053			        ; TODO db opflags        
a053				endm 
a053			 
a053			 
a053			NEXTW: macro  
a053				jp macro_next 
a053				endm 
a053			 
a053			macro_next: 
a053			if DEBUG_FORTH_PARSE_KEY 
a053				DMARK "NXT" 
a053				CALLMONITOR 
a053			endif	 
a053			;	inc hl  ; skip token null term  
a053 ed 4b 40 ea		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
a057 ed 5b 3e ea		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
a05b 2a c2 e5			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
a05e			if DEBUG_FORTH_PARSE_KEY 
a05e				DMARK "}AA" 
a05e				CALLMONITOR 
a05e			endif	 
a05e c3 61 a1			jp execnext 
a061				;jp exec1 
a061			       
a061			 
a061			 
a061			; Another go at the parser to compile  
a061			 
a061			 
a061			; TODO rework parser to change all of the string words to byte tokens 
a061			; TODO do a search for  
a061			 
a061			; TODO first run normal parser to zero term sections 
a061			; TODO for each word do a token look up to get the op code 
a061			; TODO need some means to flag to the exec that this is a byte code form    
a061			 
a061			 
a061			forthcompile: 
a061			 
a061			; 
a061			; line parse: 
a061			;       parse raw input buffer 
a061			;       tokenise the words 
a061			;       malloc new copy (for looping etc) 
a061			;       copy to malloc + current pc in line to start of string and add line term 
a061			;       save on new rsp 
a061			; 
a061			 
a061			; hl to point to the line to tokenise 
a061			 
a061			;	push hl 
a061 22 c2 e5			ld (os_tok_ptr), hl  ; save ptr to string 
a064			 
a064			;	ld a,0		; string term on input 
a064			;	call strlent 
a064			 
a064			;	ld (os_tok_len), hl	 ; save string length 
a064			 
a064			;if DEBUG_FORTH_TOK 
a064			;	ex de,hl		 
a064			;endif 
a064			 
a064			;	pop hl 		; get back string pointer 
a064			 
a064			if DEBUG_FORTH_TOK 
a064						DMARK "TOc" 
a064				CALLMONITOR 
a064			endif 
a064 7e			.cptoken2:    ld a,(hl) 
a065 23				inc hl 
a066 fe 7f			cp FORTH_END_BUFFER 
a068 28 29			jr z, .cptokendone2 
a06a fe 00			cp 0 
a06c 28 25			jr z, .cptokendone2 
a06e fe 22			cp '"' 
a070 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
a072 fe 20			cp ' ' 
a074 20 ee			jr nz,  .cptoken2 
a076			 
a076			; TODO consume comments held between ( and ) 
a076			 
a076				; we have a space so change to zero term for dict match later 
a076 2b				dec hl 
a077 3e 00			ld a,0 
a079 77				ld (hl), a 
a07a 23				inc hl 
a07b 18 e7			jr .cptoken2 
a07d				 
a07d			 
a07d			.cptokenstr2: 
a07d				; skip all white space until either eol (because forgot to term) or end double quote 
a07d			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
a07d				;inc hl ; skip current double quote 
a07d 7e				ld a,(hl) 
a07e 23				inc hl 
a07f fe 22			cp '"' 
a081 28 e1			jr z, .cptoken2 
a083 fe 7f			cp FORTH_END_BUFFER 
a085 28 0c			jr z, .cptokendone2 
a087 fe 00			cp 0 
a089 28 08			jr z, .cptokendone2 
a08b fe 20			cp ' ' 
a08d 28 02			jr z, .cptmp2 
a08f 18 ec			jr .cptokenstr2 
a091			 
a091			.cptmp2:	; we have a space so change to zero term for dict match later 
a091				;dec hl 
a091				;ld a,"-"	; TODO remove this when working 
a091				;ld (hl), a 
a091				;inc hl 
a091 18 ea			jr .cptokenstr2 
a093			 
a093			.cptokendone2: 
a093				;inc hl 
a093 3e 7f			ld a, FORTH_END_BUFFER 
a095 77				ld (hl),a 
a096 23				inc hl 
a097 3e 21			ld a, '!' 
a099 77				ld (hl),a 
a09a			 
a09a 2a c2 e5			ld hl,(os_tok_ptr) 
a09d			         
a09d			if DEBUG_FORTH_TOK 
a09d						DMARK "Tc1" 
a09d				CALLMONITOR 
a09d			endif 
a09d			 
a09d				; push exec string to top of return stack 
a09d				FORTH_RSP_NEXT 
a09d cd 4d 9c			call macro_forth_rsp_next 
a0a0				endm 
# End of macro FORTH_RSP_NEXT
a0a0 c9				ret 
a0a1			 
a0a1			; Another go at the parser need to simplify the process 
a0a1			 
a0a1			forthparse: 
a0a1			 
a0a1			; 
a0a1			; line parse: 
a0a1			;       parse raw input buffer 
a0a1			;       tokenise the words 
a0a1			;       malloc new copy (for looping etc) 
a0a1			;       copy to malloc + current pc in line to start of string and add line term 
a0a1			;       save on new rsp 
a0a1			; 
a0a1			 
a0a1			; hl to point to the line to tokenise 
a0a1			 
a0a1			;	push hl 
a0a1 22 c2 e5			ld (os_tok_ptr), hl  ; save ptr to string 
a0a4			 
a0a4			;	ld a,0		; string term on input 
a0a4			;	call strlent 
a0a4			 
a0a4			;	ld (os_tok_len), hl	 ; save string length 
a0a4			 
a0a4			;if DEBUG_FORTH_TOK 
a0a4			;	ex de,hl		 
a0a4			;endif 
a0a4			 
a0a4			;	pop hl 		; get back string pointer 
a0a4			 
a0a4			if DEBUG_FORTH_TOK 
a0a4						DMARK "TOK" 
a0a4				CALLMONITOR 
a0a4			endif 
a0a4 7e			.ptoken2:    ld a,(hl) 
a0a5 23				inc hl 
a0a6 fe 7f			cp FORTH_END_BUFFER 
a0a8 28 29			jr z, .ptokendone2 
a0aa fe 00			cp 0 
a0ac 28 25			jr z, .ptokendone2 
a0ae fe 22			cp '"' 
a0b0 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
a0b2 fe 20			cp ' ' 
a0b4 20 ee			jr nz,  .ptoken2 
a0b6			 
a0b6			; TODO consume comments held between ( and ) 
a0b6			 
a0b6				; we have a space so change to zero term for dict match later 
a0b6 2b				dec hl 
a0b7 3e 00			ld a,0 
a0b9 77				ld (hl), a 
a0ba 23				inc hl 
a0bb 18 e7			jr .ptoken2 
a0bd				 
a0bd			 
a0bd			.ptokenstr2: 
a0bd				; skip all white space until either eol (because forgot to term) or end double quote 
a0bd			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
a0bd				;inc hl ; skip current double quote 
a0bd 7e				ld a,(hl) 
a0be 23				inc hl 
a0bf fe 22			cp '"' 
a0c1 28 e1			jr z, .ptoken2 
a0c3 fe 7f			cp FORTH_END_BUFFER 
a0c5 28 0c			jr z, .ptokendone2 
a0c7 fe 00			cp 0 
a0c9 28 08			jr z, .ptokendone2 
a0cb fe 20			cp ' ' 
a0cd 28 02			jr z, .ptmp2 
a0cf 18 ec			jr .ptokenstr2 
a0d1			 
a0d1			.ptmp2:	; we have a space so change to zero term for dict match later 
a0d1				;dec hl 
a0d1				;ld a,"-"	; TODO remove this when working 
a0d1				;ld (hl), a 
a0d1				;inc hl 
a0d1 18 ea			jr .ptokenstr2 
a0d3			 
a0d3			.ptokendone2: 
a0d3				;inc hl 
a0d3 3e 7f			ld a, FORTH_END_BUFFER 
a0d5 77				ld (hl),a 
a0d6 23				inc hl 
a0d7 3e 21			ld a, '!' 
a0d9 77				ld (hl),a 
a0da			 
a0da 2a c2 e5			ld hl,(os_tok_ptr) 
a0dd			         
a0dd			if DEBUG_FORTH_TOK 
a0dd						DMARK "TK1" 
a0dd				CALLMONITOR 
a0dd			endif 
a0dd			 
a0dd				; push exec string to top of return stack 
a0dd				FORTH_RSP_NEXT 
a0dd cd 4d 9c			call macro_forth_rsp_next 
a0e0				endm 
# End of macro FORTH_RSP_NEXT
a0e0 c9				ret 
a0e1			 
a0e1			; 
a0e1			;	; malloc size + buffer pointer + if is loop flag 
a0e1			;	ld hl,(os_tok_len) 		 ; get string length 
a0e1			; 
a0e1			;	ld a,l 
a0e1			; 
a0e1			;	cp 0			; we dont want to use a null string 
a0e1			;	ret z 
a0e1			; 
a0e1			;;	add 3    ; prefix malloc with buffer for current word ptr 
a0e1			; 
a0e1			;	add 5     ; TODO when certain not over writing memory remove 
a0e1			; 
a0e1			;		 
a0e1			; 
a0e1			;if DEBUG_FORTH_TOK 
a0e1			;			DMARK "TKE" 
a0e1			;	CALLMONITOR 
a0e1			;endif 
a0e1			; 
a0e1			;	ld l,a 
a0e1			;	ld h,0 
a0e1			;;	push hl   ; save required space for the copy later 
a0e1			;	call malloc 
a0e1			;if DEBUG_FORTH_TOK 
a0e1			;			DMARK "TKM" 
a0e1			;	CALLMONITOR 
a0e1			;endif 
a0e1			;	if DEBUG_FORTH_MALLOC_GUARD 
a0e1			;		push af 
a0e1			;		call ishlzero 
a0e1			;;		ld a, l 
a0e1			;;		add h 
a0e1			;;		cp 0 
a0e1			;		pop af 
a0e1			;		 
a0e1			;		call z,malloc_error 
a0e1			;	endif 
a0e1			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
a0e1			; 
a0e1			; 
a0e1			;if DEBUG_FORTH_TOK 
a0e1			;			DMARK "TKR" 
a0e1			;	CALLMONITOR 
a0e1			;endif 
a0e1			; 
a0e1			;	FORTH_RSP_NEXT 
a0e1			; 
a0e1			;	;inc hl	 ; go past current buffer pointer 
a0e1			;	;inc hl 
a0e1			;	;inc hl   ; and past if loop flag 
a0e1			;		; TODO Need to set flag  
a0e1			; 
a0e1			;	 
a0e1			;	 
a0e1			;	ex de,hl	; malloc is dest 
a0e1			;	ld hl, (os_tok_len) 
a0e1			;;	pop bc 
a0e1			;	ld c, l                
a0e1			;	ld b,0 
a0e1			;	ld hl, (os_tok_ptr) 
a0e1			; 
a0e1			;if DEBUG_FORTH_TOK 
a0e1			;			DMARK "TKT" 
a0e1			;	CALLMONITOR 
a0e1			;endif 
a0e1			; 
a0e1			;	; do str cpy 
a0e1			; 
a0e1			;	ldir      ; copy byte in hl to de 
a0e1			; 
a0e1			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
a0e1			; 
a0e1			;if DEBUG_FORTH_TOK 
a0e1			; 
a0e1			;			DMARK "TKY" 
a0e1			;	CALLMONITOR 
a0e1			;endif 
a0e1			;	;ld a,0 
a0e1			;	;ld a,FORTH_END_BUFFER 
a0e1			;	ex de, hl 
a0e1			;	;dec hl			 ; go back over the space delim at the end of word 
a0e1			;	;ld (hl),a 
a0e1			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
a0e1			;	ld a,FORTH_END_BUFFER 
a0e1			;	ld (hl),a 
a0e1			;	inc hl 
a0e1			;	ld a,FORTH_END_BUFFER 
a0e1			;	ld (hl),a 
a0e1			; 
a0e1			;	; init the malloc area data 
a0e1			;	; set pc for in current area 
a0e1			;	;ld hl, (os_tok_malloc) 
a0e1			;	;inc hl 
a0e1			;	;inc hl 
a0e1			;	;inc hl 
a0e1			;	;ex de,hl 
a0e1			;	;ld hl, (os_tok_malloc) 
a0e1			;	;ld (hl),e 
a0e1			;	;inc hl 
a0e1			;	;ld (hl),d 
a0e1			; 
a0e1			; 
a0e1			;	ld hl,(os_tok_malloc) 
a0e1			;if DEBUG_FORTH_PARSE_KEY 
a0e1			;			DMARK "TKU" 
a0e1			;	CALLMONITOR 
a0e1			;endif 
a0e1			; 
a0e1			;	ret 
a0e1			 
a0e1			forthexec: 
a0e1			 
a0e1			; line exec: 
a0e1			; forth parser 
a0e1			 
a0e1			; 
a0e1			;       get current exec line on rsp 
a0e1			 
a0e1				FORTH_RSP_TOS 
a0e1 cd 64 9c			call macro_forth_rsp_tos 
a0e4				endm 
# End of macro FORTH_RSP_TOS
a0e4			 
a0e4			;       restore current pc - hl points to malloc of data 
a0e4			 
a0e4				;ld e, (hl) 
a0e4				;inc hl 
a0e4				;ld d, (hl) 
a0e4				;ex de,hl 
a0e4			 
a0e4			 
a0e4			exec1: 
a0e4 22 c2 e5			ld (os_tok_ptr), hl 
a0e7			 
a0e7				; copy our PC to working vars  
a0e7 22 40 ea			ld (cli_ptr), hl 
a0ea 22 3e ea			ld (cli_origptr), hl 
a0ed			 
a0ed 7e				ld a,(hl) 
a0ee fe 7f			cp FORTH_END_BUFFER 
a0f0 c8				ret z 
a0f1			 
a0f1				; skip any nulls 
a0f1			 
a0f1 fe 00			cp 0 
a0f3 20 03			jr nz, .execword 
a0f5 23				inc hl 
a0f6 18 ec			jr exec1 
a0f8			 
a0f8			 
a0f8			.execword: 
a0f8			 
a0f8			 
a0f8			 
a0f8			if DEBUG_FORTH_PARSE_KEY 
a0f8						DMARK "KYQ" 
a0f8				CALLMONITOR 
a0f8			endif 
a0f8			;       while at start of word: 
a0f8			; get start of dict (in user area first) 
a0f8			 
a0f8 21 43 e6		ld hl, baseram 
a0fb			;ld hl, sysdict 
a0fb 22 42 ea		ld (cli_nextword),hl 
a0fe			;           match word at pc 
a0fe			;           exec word 
a0fe			;           or push to dsp 
a0fe			;           forward to next token 
a0fe			;           if line term pop rsp and exit 
a0fe			;        
a0fe			 
a0fe			if DEBUG_FORTH_PARSE_KEY 
a0fe						DMARK "KYq" 
a0fe				CALLMONITOR 
a0fe			endif 
a0fe			 
a0fe			; 
a0fe			; word comp 
a0fe			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
a0fe			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
a0fe			;    move to start of word  
a0fe			;    compare word to cli_token 
a0fe			 
a0fe			.execpnword:	; HL at start of a word in the dictionary to check 
a0fe			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
a0fe			;	ld (cli_ptr), hl 
a0fe			 
a0fe 2a 42 ea			ld hl,(cli_nextword) 
a101			 
a101 cd a4 a1			call forth_tok_next 
a104			; tok next start here 
a104			;	; TODO skip compiled symbol for now 
a104			;	inc hl 
a104			; 
a104			;	; save pointer to next word 
a104			; 
a104			;	; hl now points to the address of the next word pointer  
a104			;	ld e, (hl) 
a104			;	inc hl 
a104			;	ld d, (hl) 
a104			;	inc l 
a104			; 
a104			;	ex de,hl 
a104			;if DEBUG_FORTH_PARSE_NEXTWORD 
a104			;	push bc 
a104			;	ld bc, (cli_nextword) 
a104			;			DMARK "NXW" 
a104			;	CALLMONITOR 
a104			;	pop bc 
a104			;endif 
a104			; tok next end here 
a104 22 42 ea			ld (cli_nextword), hl     ; save for next check if no match on this word 
a107 eb				ex de, hl 
a108			 
a108			 
a108				; save the pointer of the current token - 1 to check against 
a108				 
a108 22 46 ea			ld (cli_token), hl   
a10b				; TODO maybe remove below save if no debug 
a10b				; save token string ptr for any debug later 
a10b 23				inc hl  
a10c 22 48 ea			ld (cli_origtoken), hl 
a10f 2b				dec hl 
a110				; save pointer to the start of the next dictionay word 
a110 7e				ld a,(hl)   ; get string length 
a111 47				ld b,a 
a112			.execpnwordinc:  
a112 23				inc hl 
a113 10 fd			djnz .execpnwordinc 
a115 22 44 ea			ld (cli_execword), hl      ; save start of this words code 
a118			 
a118				; now check the word token against the string being parsed 
a118			 
a118 2a 46 ea			ld hl,(cli_token) 
a11b 23				inc hl     ; skip string length (use zero term instead to end) 
a11c 22 46 ea			ld (cli_token), hl 
a11f			 
a11f			if DEBUG_FORTH_PARSE_KEY 
a11f						DMARK "KY2" 
a11f			endif 
a11f			if DEBUG_FORTH_PARSE_EXEC 
a11f				; see if disabled 
a11f			 
a11f			;	ld a, (os_view_disable) 
a11f			;	cp '*' 
a11f				ld a, (debug_vector) 
a11f				cp $c9   ; RET  
a11f				jr z, .skip 
a11f			 
a11f				push hl 
a11f				push hl 
a11f				call clear_display 
a11f				ld de, .compword 
a11f				ld a, display_row_1 
a11f				call str_at_display 
a11f				pop de 
a11f				ld a, display_row_2 
a11f				call str_at_display 
a11f				ld hl,(cli_ptr) 
a11f				ld a,(hl) 
a11f			        ld hl, os_word_scratch 
a11f				ld (hl),a 
a11f				ld a,0 
a11f				inc hl 
a11f				ld (hl),a 	 
a11f				ld de, os_word_scratch 
a11f				ld a, display_row_2+10 
a11f				call str_at_display 
a11f				call update_display 
a11f				ld a, 100 
a11f				call aDelayInMS 
a11f				if DEBUG_FORTH_PARSE_EXEC_SLOW 
a11f				call delay250ms 
a11f				endif 
a11f				pop hl 
a11f			.skip:  
a11f			endif	 
a11f			.execpnchar:    ; compare char between token and string to parse 
a11f			 
a11f			if DEBUG_FORTH_PARSE_KEY 
a11f						DMARK "Ky3" 
a11f			endif 
a11f			if DEBUG_FORTH_PARSE_EXEC 
a11f				; see if disabled 
a11f			 
a11f			;	ld a, (os_view_disable) 
a11f			;	cp '*' 
a11f				ld a, (debug_vector) 
a11f				cp $C9  ; RET 
a11f				jr z, .skip2 
a11f			 
a11f			;	call clear_display 
a11f			ld hl,(cli_token) 
a11f			ld a,(hl) 
a11f			ld (os_word_scratch),a 
a11f				ld hl,(cli_ptr) 
a11f			ld a,(hl) 
a11f				ld (os_word_scratch+1),a 
a11f				ld a,0 
a11f				ld (os_word_scratch+2),a 
a11f				ld de,os_word_scratch 
a11f				ld a,display_row_4 
a11f				call str_at_display 
a11f				call update_display 
a11f			.skip2:  
a11f			endif 
a11f 2a 46 ea			ld hl,(cli_token) 
a122 7e				ld a, (hl)	 ; char in word token 
a123 23				inc hl 		; move to next char 
a124 22 46 ea			ld (cli_token), hl ; and save it 
a127 47				ld b,a 
a128			 
a128 2a 40 ea			ld hl,(cli_ptr) ;	get the char from the string to parse 
a12b 7e				ld a,(hl) 
a12c 23				inc hl 
a12d 22 40 ea			ld (cli_ptr), hl		; move to next char 
a130 cd 8f 92			call toUpper 		; make sure the input string matches case 
a133			 
a133			if DEBUG_FORTH_PARSE 
a133			endif 
a133			 
a133				; input stream end of token is a space so get rid of it 
a133			 
a133			;	cp ' ' 
a133			;	jr nz, .pnskipspace 
a133			; 
a133			;	ld a, 0		; make same term as word token term 
a133			; 
a133			;.pnskipspace: 
a133			 
a133			if DEBUG_FORTH_PARSE_KEY 
a133						DMARK "KY7" 
a133			endif 
a133 b8				cp b 
a134 c2 4a a1			jp nz, .execpnskipword	 ; no match so move to next word 
a137				 
a137			;    if same 
a137			;       scan for string terms 0 for token and 32 for input 
a137			 
a137				 
a137			if DEBUG_FORTH_PARSE_KEY 
a137						DMARK "KY8" 
a137			endif 
a137			 
a137 80				add b			 
a138 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
a13a							; TODO need to make sure last word in zero term string is accounted for 
a13a 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
a13c			 
a13c			 
a13c				; at end of both strings so both are exact match 
a13c			 
a13c			;       skip ptr for next word 
a13c			 
a13c 2a 40 ea			ld hl,(cli_ptr) 	; at input string term 
a13f 23				inc hl			 ; at next char 
a140 22 40 ea			ld (cli_ptr), hl     ; save for next round of the parser 
a143 22 3e ea			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
a146				 
a146				 
a146			if DEBUG_FORTH_PARSE_KEY 
a146						DMARK "KY3" 
a146			endif 
a146			 
a146			 
a146			 
a146			;       exec code block 
a146			if DEBUG_FORTH_JP 
a146				call clear_display 
a146				call update_display 
a146				call delay1s 
a146				ld hl, (cli_execword)     ; save for next check if no match on this word 
a146				ld a,h 
a146				ld hl, os_word_scratch 
a146				call hexout 
a146				ld hl, (cli_execword)     ; save for next check if no match on this word 
a146				ld a,l 
a146				ld hl, os_word_scratch+2 
a146				call hexout 
a146				ld hl, os_word_scratch+4 
a146				ld a,0 
a146				ld (hl),a 
a146				ld de,os_word_scratch 
a146				call str_at_display 
a146					ld a, display_row_2 
a146					call str_at_display 
a146				ld de, (cli_origtoken) 
a146				ld a, display_row_1+10 
a146					call str_at_display 
a146			 
a146				ld a,display_row_1 
a146				ld de, .foundword 
a146				ld a, display_row_3 
a146				call str_at_display 
a146				call update_display 
a146				call delay1s 
a146				call delay1s 
a146				call delay1s 
a146			endif 
a146			 
a146			if DEBUG_FORTH_PARSE_KEY 
a146						DMARK "KYj" 
a146			endif 
a146				; TODO save the word pointer in this exec 
a146			 
a146 2a 44 ea			ld hl,(cli_execword) 
a149 e9				jp (hl) 
a14a			 
a14a			 
a14a			;    if not same 
a14a			;	scan for zero term 
a14a			;	get ptr for next word 
a14a			;	goto word comp 
a14a			 
a14a			.execpnskipword:	; get pointer to next word 
a14a 2a 42 ea			ld hl,(cli_nextword) 
a14d			 
a14d 7e				ld a,(hl) 
a14e fe 00			cp WORD_SYS_END 
a150			;	cp 0 
a150 28 09			jr z, .execendofdict			 ; at end of words 
a152			 
a152			if DEBUG_FORTH_PARSE_KEY 
a152						DMARK "KY4" 
a152			endif 
a152			if DEBUG_FORTH_PARSE_EXEC 
a152			 
a152				; see if disabled 
a152			 
a152			;	ld a, (os_view_disable) 
a152			;	cp '*' 
a152				ld a,(debug_vector) 
a152				cp $c9   ; RET 
a152				jr z, .noskip 
a152			 
a152			 
a152				ld de, .nowordfound 
a152				ld a, display_row_3 
a152				call str_at_display 
a152				call update_display 
a152				ld a, 100 
a152				call aDelayInMS 
a152				 
a152				if DEBUG_FORTH_PARSE_EXEC_SLOW 
a152					call delay250ms 
a152				endif 
a152			.noskip:  
a152			 
a152			endif	 
a152			 
a152 2a 3e ea			ld hl,(cli_origptr) 
a155 22 40 ea			ld (cli_ptr),hl 
a158			 
a158			if DEBUG_FORTH_PARSE_KEY 
a158						DMARK "KY5" 
a158			endif 
a158 c3 fe a0			jp .execpnword			; else go to next word 
a15b			 
a15b			.execendofdict:  
a15b			 
a15b			if DEBUG_FORTH_PARSE_KEY 
a15b						DMARK "KYe" 
a15b			endif 
a15b			if DEBUG_FORTH_PARSE_EXEC 
a15b				; see if disabled 
a15b			 
a15b			;	ld a, (os_view_disable) 
a15b			;	cp '*' 
a15b				ld a,(debug_vector) 
a15b				cp $c9   ; ret 
a15b				jr z, .ispskip 
a15b			 
a15b				call clear_display 
a15b				call update_display 
a15b				call delay1s 
a15b				ld de, (cli_origptr) 
a15b				ld a, display_row_1 
a15b				call str_at_display 
a15b				 
a15b				ld de, .enddict 
a15b				ld a, display_row_3 
a15b				call str_at_display 
a15b				call update_display 
a15b				ld a, 100 
a15b				call aDelayInMS 
a15b				if DEBUG_FORTH_PARSE_EXEC_SLOW 
a15b				call delay1s 
a15b				call delay1s 
a15b				call delay1s 
a15b				endif 
a15b			.ispskip:  
a15b				 
a15b			endif	 
a15b			 
a15b			 
a15b			 
a15b				; if the word is not a keyword then must be a literal so push it to stack 
a15b			 
a15b			; push token to stack to end of word 
a15b			 
a15b				STACKFRAME ON $1efe $2f9f 
a15b				if DEBUG_STACK_IMB 
a15b					if ON 
a15b						exx 
a15b						ld de, $1efe 
a15b						ld a, d 
a15b						ld hl, curframe 
a15b						call hexout 
a15b						ld a, e 
a15b						ld hl, curframe+2 
a15b						call hexout 
a15b						ld hl, $1efe 
a15b						push hl 
a15b						ld hl, $2f9f 
a15b						push hl 
a15b						exx 
a15b					endif 
a15b				endif 
a15b			endm 
# End of macro STACKFRAME
a15b			 
a15b 2a c2 e5		ld hl,(os_tok_ptr) 
a15e cd 0f 9e		call forth_apush 
a161			 
a161				STACKFRAMECHK ON $1efe $2f9f 
a161				if DEBUG_STACK_IMB 
a161					if ON 
a161						exx 
a161						ld hl, $2f9f 
a161						pop de   ; $2f9f 
a161						call cmp16 
a161						jr nz, .spnosame 
a161						ld hl, $1efe 
a161						pop de   ; $1efe 
a161						call cmp16 
a161						jr z, .spfrsame 
a161						.spnosame: call showsperror 
a161						.spfrsame: nop 
a161						exx 
a161					endif 
a161				endif 
a161			endm 
# End of macro STACKFRAMECHK
a161			 
a161			execnext: 
a161			 
a161			if DEBUG_FORTH_PARSE_KEY 
a161						DMARK "KY>" 
a161			endif 
a161			; move past token to next word 
a161			 
a161 2a c2 e5		ld hl, (os_tok_ptr) 
a164 3e 00		ld a, 0 
a166 01 ff 00		ld bc, 255     ; input buffer size 
a169 ed b1		cpir 
a16b			 
a16b			if DEBUG_FORTH_PARSE_KEY 
a16b						DMARK "KY!" 
a16b				CALLMONITOR 
a16b			endif	 
a16b			; TODO this might place hl on the null, so will need to forward on??? 
a16b			;inc hl   ; see if this gets onto the next item 
a16b			 
a16b			 
a16b			; TODO pass a pointer to the buffer to push 
a16b			; TODO call function to push 
a16b			 
a16b			; look for end of input 
a16b			 
a16b			;inc hl 
a16b			;ld a,(hl) 
a16b			;cp FORTH_END_BUFFER 
a16b			;ret z 
a16b			 
a16b			 
a16b c3 e4 a0		jp exec1 
a16e			 
a16e			 
a16e			 
a16e			 
a16e			 
a16e			 
a16e			 
a16e			 
a16e			 
a16e			findnexttok: 
a16e			 
a16e				; hl is pointer to move 
a16e				; de is the token to locate 
a16e			 
a16e					if DEBUG_FORTH 
a16e						DMARK "NTK" 
a16e						CALLMONITOR 
a16e					endif 
a16e d5				push de 
a16f			 
a16f			.fnt1:	 
a16f				; find first char of token to locate 
a16f			 
a16f 1a				ld a, (de) 
a170 4f				ld c,a 
a171 7e				ld a,(hl) 
a172 cd 8f 92			call toUpper 
a175					if DEBUG_FORTH 
a175						DMARK "NT1" 
a175						CALLMONITOR 
a175					endif 
a175 b9				cp c 
a176			 
a176 28 03			jr z, .fnt2cmpmorefirst	 
a178			 
a178				; first char not found move to next char 
a178			 
a178 23				inc hl 
a179 18 f4			jr .fnt1 
a17b			 
a17b			.fnt2cmpmorefirst:	 
a17b				; first char of token found.  
a17b			 
a17b e5				push hl     ; save start of token just in case it is the right one 
a17c d9				exx 
a17d e1				pop hl        ; save it to hl' 
a17e d9				exx 
a17f			 
a17f			 
a17f			.fnt2cmpmore:	 
a17f				; compare the rest 
a17f				 
a17f 23				inc hl 
a180 13				inc de 
a181				 
a181 1a				ld a, (de) 
a182 4f				ld c,a 
a183 7e				ld a,(hl) 
a184 cd 8f 92			call toUpper 
a187			 
a187					if DEBUG_FORTH 
a187						DMARK "NT2" 
a187						CALLMONITOR 
a187					endif 
a187				; c has the token to find char 
a187				; a has the mem to scan char 
a187			 
a187 b9				cp c 
a188 28 04			jr z,.fntmatch1 
a18a			 
a18a				; they are not the same 
a18a			 
a18a					if DEBUG_FORTH 
a18a						DMARK "NT3" 
a18a						CALLMONITOR 
a18a					endif 
a18a d1				pop de	; reset de token to look for 
a18b d5				push de 
a18c 18 e1			jr .fnt1 
a18e				 
a18e			.fntmatch1: 
a18e			 
a18e				; is the same char a null which means we might have a full hit? 
a18e					if DEBUG_FORTH 
a18e						DMARK "NT4" 
a18e						CALLMONITOR 
a18e					endif 
a18e			 
a18e fe 00			cp 0 
a190 28 0b			jr z, .fntmatchyes 
a192			 
a192				; are we at the end of the token to find? 
a192			 
a192					if DEBUG_FORTH 
a192						DMARK "NT5" 
a192						CALLMONITOR 
a192					endif 
a192 3e 00			ld a, 0 
a194 b9				cp c 
a195			 
a195 c2 7f a1			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
a198			 
a198					if DEBUG_FORTH 
a198						DMARK "NT6" 
a198						CALLMONITOR 
a198					endif 
a198				; token to find is exhusted but no match to stream 
a198			 
a198				; restore tok pointer and continue on 
a198 d1				pop de 
a199 d5				push de 
a19a c3 6f a1			jp .fnt1 
a19d			 
a19d			 
a19d			.fntmatchyes: 
a19d			 
a19d				; hl now contains the end of the found token 
a19d			 
a19d				; get rid of saved token pointer to find 
a19d			 
a19d d1				pop de 
a19e			 
a19e					if DEBUG_FORTH 
a19e						DMARK "NT9" 
a19e						CALLMONITOR 
a19e					endif 
a19e			 
a19e				; hl will be on the null term so forward on 
a19e			 
a19e				; get back the saved start of the token 
a19e			 
a19e d9				exx 
a19f e5				push hl     ; save start of token just in case it is the right one 
a1a0 d9				exx 
a1a1 e1				pop hl        ; save it to hl 
a1a2			 
a1a2 c9				ret 
a1a3			 
a1a3			 
a1a3			; LIST needs to find a specific token   
a1a3			; FORGET needs to find a spefici token 
a1a3			 
a1a3			; SAVE needs to find all tokens by flag 
a1a3			; WORDS just needs to scan through all  by flag 
a1a3			; UWORDS needs to scan through all by flag 
a1a3			 
a1a3			 
a1a3			; given hl as pointer to start of dict look up string 
a1a3			; return hl as pointer to start of word block 
a1a3			; or 0 if not found 
a1a3			 
a1a3			forth_find_tok: 
a1a3 c9				ret 
a1a4			 
a1a4			; given hl as pointer to dict structure 
a1a4			; move to the next dict block structure 
a1a4			 
a1a4			forth_tok_next: 
a1a4				; hl now points to the address of the next word pointer  
a1a4				; TODO skip compiled symbol for now 
a1a4			;	push de 
a1a4 23				inc hl 
a1a5 5e				ld e, (hl) 
a1a6 23				inc hl 
a1a7 56				ld d, (hl) 
a1a8 23				inc hl 
a1a9			 
a1a9 eb				ex de,hl 
a1aa			if DEBUG_FORTH_PARSE_NEXTWORD 
a1aa				push bc 
a1aa				ld bc, (cli_nextword) 
a1aa						DMARK "NXW" 
a1aa				CALLMONITOR 
a1aa				pop bc 
a1aa			endif 
a1aa			;	pop de	 
a1aa c9				ret 
a1ab			 
a1ab			 
a1ab			 
a1ab			; eof 
# End of file forth_parserv5.asm
a1ab				include "forth_wordsv4.asm" 
a1ab			 
a1ab			; the core word dictionary v4 
a1ab			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
a1ab			 
a1ab			; this is a linked list for each of the system words used 
a1ab			; user defined words will follow the same format but will be in ram 
a1ab			 
a1ab			 
a1ab			; 
a1ab			; 
a1ab			; define linked list: 
a1ab			; 
a1ab			; 1. compiled byte op code 
a1ab			; 2. len of text word 
a1ab			; 3. text word 
a1ab			; 4. ptr to next dictionary word 
a1ab			; 5. asm, calls etc for the word 
a1ab			; 
a1ab			;  if 1 == 0 then last word in dict  
a1ab			;   
a1ab			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
a1ab			;  
a1ab			;  
a1ab			; create basic standard set of words 
a1ab			; 
a1ab			;  
a1ab			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
a1ab			; 2DUP 2DROP 2SWAP  
a1ab			; @ C@ - get byte  
a1ab			; ! C! - store byte 
a1ab			; 0< true if less than zero 
a1ab			; 0= true if zero 
a1ab			; < >  
a1ab			; = true if same 
a1ab			; variables 
a1ab			 
a1ab			 
a1ab			; Hardware specific words I may need 
a1ab			; 
a1ab			; IN OUT  
a1ab			; calls to key util functions 
a1ab			; calls to hardward abstraction stuff 
a1ab			; easy control of frame buffers and lcd i/o 
a1ab			; keyboard  
a1ab			 
a1ab			 
a1ab			;DICT: macro 
a1ab			; op_code, len, word, next 
a1ab			;    word: 
a1ab			;    db op_code 
a1ab			;    ds word zero term 
a1ab			;    dw next 
a1ab			;    endm 
a1ab			 
a1ab			 
a1ab			 
a1ab			 
a1ab			; op code 1 is a flag for user define words which are to be handled differently 
a1ab			 
a1ab			 
a1ab			; 
a1ab			; 
a1ab			;    TODO on entry to a word this should be the expected environment 
a1ab			;    hl - tos value if number then held, if string this is the ptr 
a1ab			;    de -  
a1ab			 
a1ab			 
a1ab			; opcode ranges 
a1ab			; 0 - end of word dict 
a1ab			; 255 - user define words 
a1ab			 
a1ab			sysdict: 
a1ab			include "forth_opcodes.asm" 
a1ab			; op codes for forth keywords 
a1ab			; free to use code 0  
a1ab				OPCODE_HEAP: equ  1 
a1ab				OPCODE_EXEC: equ 2 
a1ab				OPCODE_DUP: equ 3 
a1ab				OPCODE_SWAP: equ 4 
a1ab				OPCODE_COLN: equ 5 
a1ab				OPCODE_SCOLN: equ 6 
a1ab				OPCODE_DROP: equ 7 
a1ab				OPCODE_DUP2: equ 8 
a1ab				OPCODE_DROP2: equ 9 
a1ab				OPCODE_SWAP2: equ 10 
a1ab				OPCODE_AT: equ 11 
a1ab				OPCODE_CAT: equ 12 
a1ab				OPCODE_BANG: equ 13 
a1ab				OPCODE_CBANG: equ 14 
a1ab				OPCODE_SCALL: equ 15 
a1ab				OPCODE_DEPTH: equ 16 
a1ab				OPCODE_OVER: equ 17 
a1ab				OPCODE_PAUSE: equ 18 
a1ab				OPCODE_PAUSES: equ 19 
a1ab				OPCODE_ROT: equ 20 
a1ab			;free to reuse	OPCODE_WORDS: equ 21 
a1ab			        OPCODE_NOT: equ 21 
a1ab				OPCODE_UWORDS: equ 22 
a1ab				OPCODE_BP: equ 23 
a1ab				OPCODE_MONITOR: equ 24  
a1ab				OPCODE_MALLOC: equ 25 
a1ab				OPCODE_FREE: equ 26 
a1ab				OPCODE_LIST: equ 27 
a1ab				OPCODE_FORGET: equ 28 
a1ab				OPCODE_NOP: equ 29 
a1ab				OPCODE_COMO: equ 30 
a1ab				OPCODE_COMC: equ 31 
a1ab			;free to reuse	OPCODE_ENDCORE: equ 32 
a1ab				OPCODE_AFTERSOUND: equ 33 
a1ab				OPCODE_GP2: equ 34 
a1ab				OPCODE_GP3: equ 35 
a1ab				OPCODE_GP4: equ 36 
a1ab				OPCODE_SIN: equ 37 
a1ab				OPCODE_SOUT: equ 38 
a1ab				OPCODE_SPIO: equ 39 
a1ab				OPCODE_SPICEH: equ 40 
a1ab				OPCODE_SPIOb: equ 41 
a1ab				OPCODE_SPII: equ 42 
a1ab				OPCODE_SESEL: equ 43 
a1ab				OPCODE_CARTDEV: equ 44 
a1ab			; free to reuse	OPCODE_ENDDEVICE: equ 45 
a1ab				OPCODE_FB: equ 46 
a1ab				OPCODE_EMIT: equ 47 
a1ab				OPCODE_DOTH: equ 48 
a1ab				OPCODE_DOTF: equ 49 
a1ab				OPCODE_DOT: equ 50 
a1ab				OPCODE_CLS: equ 51 
a1ab				OPCODE_DRAW: equ 52 
a1ab				OPCODE_DUMP: equ 53 
a1ab				OPCODE_CDUMP: equ 54 
a1ab				OPCODE_DAT: equ 55 
a1ab				OPCODE_HOME: equ 56 
a1ab				OPCODE_SPACE: equ 57 
a1ab				OPCODE_SPACES: equ 58 
a1ab				OPCODE_SCROLL: equ 59 
a1ab				OPCODE_ATQ: equ 60 
a1ab				OPCODE_AUTODSP: equ 61 
a1ab				OPCODE_MENU: equ 62 
a1ab			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
a1ab				OPCODE_THEN: equ 64 
a1ab				OPCODE_ELSE: equ 65 
a1ab				OPCODE_DO: equ 66 
a1ab				OPCODE_LOOP: equ 67 
a1ab				OPCODE_I: equ 68 
a1ab				OPCODE_DLOOP: equ 69  
a1ab				OPCODE_REPEAT: equ 70  
a1ab				OPCODE_UNTIL: equ 71 
a1ab				OPCODE_ENDFLOW: equ 72 
a1ab				OPCODE_WAITK: equ 73 
a1ab				OPCODE_ACCEPT: equ 74 
a1ab				OPCODE_EDIT: equ 75 
a1ab			;free to reuse	OPCODE_ENDKEY: equ 76 
a1ab				OPCODE_LZERO: equ 77 
a1ab				OPCODE_TZERO: equ 78 
a1ab				OPCODE_LESS: equ 79 
a1ab				OPCODE_GT: equ 80 
a1ab				OPCODE_EQUAL: equ 81  
a1ab			;free to reuse	OPCODE_ENDLOGIC: equ 82 
a1ab				OPCODE_NEG: equ 83 
a1ab				OPCODE_DIV: equ 84 
a1ab				OPCODE_MUL: equ 85 
a1ab				OPCODE_MIN: equ 86 
a1ab				OPCODE_MAX: equ 87 
a1ab				OPCODE_RND16: equ 88 
a1ab				OPCODE_RND8: equ 89 
a1ab				OPCODE_RND: equ 90 
a1ab			;free to reuse	OPCODE_ENDMATHS: equ 91  
a1ab				OPCODE_BYNAME: equ 92 
a1ab				OPCODE_DIR: equ 93 
a1ab				OPCODE_SAVE: equ 94 
a1ab				OPCODE_LOAD: equ 95 
a1ab				OPCODE_BSAVE: equ 96 
a1ab				OPCODE_BLOAD: equ 97 
a1ab				OPCODE_SEO: equ 98  
a1ab				OPCODE_SEI: equ 99 
a1ab				OPCODE_SFREE: equ 100 
a1ab				OPCODE_SIZE: equ 101 
a1ab				OPCODE_CREATE: equ 102 
a1ab				OPCODE_APPEND: equ 103 
a1ab				OPCODE_SDEL: equ 104 
a1ab				OPCODE_OPEN: equ 105 
a1ab				OPCODE_READ: equ 106 
a1ab				OPCODE_EOF: equ 106 
a1ab				OPCODE_FORMAT: equ 107 
a1ab				OPCODE_LABEL: equ 108 
a1ab				OPCODE_LABELS: equ 109 
a1ab			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
a1ab				OPCODE_UPPER: equ 111 
a1ab				OPCODE_LOWER: equ 112 
a1ab				OPCODE_SUBSTR: equ 113 
a1ab				OPCODE_LEFT: equ 114 
a1ab				OPCODE_RIGHT: equ 115 
a1ab				OPCODE_STR2NUM: equ 116 
a1ab				OPCODE_NUM2STR: equ 117 
a1ab				OPCODE_CONCAT: equ 118 
a1ab				OPCODE_FIND: equ 119 
a1ab				OPCODE_LEN: equ 120 
a1ab				OPCODE_CHAR: equ 121 
a1ab			; free to reuse	OPCODE_STRLEN: equ 122 
a1ab			; free to reuse	OPCODE_ENDSTR: equ 123 
a1ab				OPCODE_V0S: equ 124 
a1ab				OPCODE_V0Q: equ 125 
a1ab				OPCODE_V1S: equ 126 
a1ab				OPCODE_V1Q: equ 127 
a1ab				OPCODE_V2S: equ 128 
a1ab				OPCODE_V2Q: equ 129 
a1ab				OPCODE_V3S: equ 130 
a1ab				OPCODE_V3Q: equ 131 
a1ab			;free to reuse	OPCODE_END: equ 132 
a1ab				OPCODE_ZDUP: equ 133 
a1ab			 
a1ab			; eof 
# End of file forth_opcodes.asm
a1ab			 
a1ab			include "forth_words_core.asm" 
a1ab			 
a1ab			; | ## Core Words 
a1ab			 
a1ab			;if MALLOC_4 
a1ab			 
a1ab			.HEAP: 
a1ab			CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
a1ab 15				db WORD_SYS_CORE+OPCODE_HEAP             
a1ac ea a1			dw .EXEC            
a1ae 05				db 4 + 1 
a1af .. 00			db "HEAP",0              
a1b4				endm 
# End of macro CWHEAD
a1b4			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
a1b4			; | | u1 - Current number of bytes in the heap 
a1b4			; | | u2 - Remaining bytes left on the heap 
a1b4			; | |  
a1b4			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
a1b4			 
a1b4			 
a1b4				if DEBUG_FORTH_WORDS_KEY 
a1b4					DMARK "HEP" 
a1b4 f5				push af  
a1b5 3a c9 a1			ld a, (.dmark)  
a1b8 32 6b ee			ld (debug_mark),a  
a1bb 3a ca a1			ld a, (.dmark+1)  
a1be 32 6c ee			ld (debug_mark+1),a  
a1c1 3a cb a1			ld a, (.dmark+2)  
a1c4 32 6d ee			ld (debug_mark+2),a  
a1c7 18 03			jr .pastdmark  
a1c9 ..			.dmark: db "HEP"  
a1cc f1			.pastdmark: pop af  
a1cd			endm  
# End of macro DMARK
a1cd					CALLMONITOR 
a1cd cd 6f ee			call debug_vector  
a1d0				endm  
# End of macro CALLMONITOR
a1d0				endif 
a1d0 2a 4d e6			ld hl, (free_list )      
a1d3 11 52 e6			ld de, heap_start 
a1d6			 
a1d6 ed 52			sbc hl, de  
a1d8			 
a1d8 cd a6 9c			call forth_push_numhl 
a1db			 
a1db			 
a1db ed 5b 4d e6		ld de, (free_list )      
a1df 21 9c e2			ld hl, heap_end 
a1e2			 
a1e2 ed 52			sbc hl, de 
a1e4			 
a1e4 cd a6 9c			call forth_push_numhl 
a1e7				 
a1e7			 
a1e7				 
a1e7			 
a1e7			 
a1e7			 
a1e7				NEXTW 
a1e7 c3 53 a0			jp macro_next 
a1ea				endm 
# End of macro NEXTW
a1ea			;endif 
a1ea			 
a1ea			.EXEC: 
a1ea			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
a1ea			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
a1ea			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
a1ea			;; > > 
a1ea			;; > >   
a1ea			;	STACKFRAME OFF $5efe $5f9f 
a1ea			; 
a1ea			;		if DEBUG_FORTH_WORDS_KEY 
a1ea			;			DMARK "EXE" 
a1ea			;			CALLMONITOR 
a1ea			;		endif 
a1ea			; 
a1ea			;	FORTH_DSP_VALUEHL 
a1ea			; 
a1ea			;	FORTH_DSP_POP 
a1ea			; 
a1ea			;		if DEBUG_FORTH_WORDS 
a1ea			;			DMARK "EX1" 
a1ea			;			CALLMONITOR 
a1ea			;		endif 
a1ea			;;	ld e,(hl) 
a1ea			;;	inc hl 
a1ea			;;	ld d,(hl) 
a1ea			;;	ex de,hl 
a1ea			; 
a1ea			;;		if DEBUG_FORTH_WORDS 
a1ea			;;			DMARK "EX2" 
a1ea			;;			CALLMONITOR 
a1ea			;;		endif 
a1ea			;	push hl 
a1ea			; 
a1ea			;	;ld a, 0 
a1ea			;	;ld a, FORTH_END_BUFFER 
a1ea			;	call strlenz 
a1ea			;	inc hl   ; include zero term to copy 
a1ea			;	inc hl   ; include term 
a1ea			;	inc hl   ; include term 
a1ea			;	ld b,0 
a1ea			;	ld c,l 
a1ea			;	pop hl 
a1ea			;	ld de, execscratch 
a1ea			;		if DEBUG_FORTH_WORDS 
a1ea			;			DMARK "EX3" 
a1ea			;			CALLMONITOR 
a1ea			;		endif 
a1ea			;	ldir 
a1ea			; 
a1ea			; 
a1ea			;	ld hl, execscratch 
a1ea			; 
a1ea			;		if DEBUG_FORTH_WORDS 
a1ea			;			DMARK "EXe" 
a1ea			;			CALLMONITOR 
a1ea			;		endif 
a1ea			; 
a1ea			;	call forthparse 
a1ea			;	call forthexec 
a1ea			;;	call forthexec_cleanup 
a1ea			;;	call forthparse 
a1ea			;;	call forthexec 
a1ea			; 
a1ea			;	STACKFRAMECHK OFF $5efe $5f9f 
a1ea			; 
a1ea			;	; an immediate word so no need to process any more words 
a1ea			;	ret 
a1ea			;	NEXTW 
a1ea			 
a1ea			; dead code - old version  
a1ea			;	FORTH_RSP_NEXT 
a1ea			 
a1ea			;  
a1ea			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
a1ea			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
a1ea			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
a1ea			;	push hl 
a1ea			;	push de 
a1ea			;	push bc 
a1ea			; 
a1ea			; 
a1ea			;		if DEBUG_FORTH_WORDS_KEY 
a1ea			;			DMARK "EXR" 
a1ea			;			CALLMONITOR 
a1ea			;		endif 
a1ea			; 
a1ea			; 
a1ea			; 
a1ea			;	;v5 FORTH_DSP_VALUE 
a1ea			;	FORTH_DSP_VALUEHL 
a1ea			; 
a1ea			;	; TODO do string type checks 
a1ea			; 
a1ea			;;v5	inc hl   ; skip type 
a1ea			; 
a1ea			;	push hl  ; source code  
a1ea			;		if DEBUG_FORTH_WORDS 
a1ea			;			DMARK "EX1" 
a1ea			;			CALLMONITOR 
a1ea			;		endif 
a1ea			;	ld a, 0 
a1ea			;	call strlent 
a1ea			; 
a1ea			;	inc hl 
a1ea			;	inc hl 
a1ea			;	inc hl 
a1ea			;	inc hl 
a1ea			; 
a1ea			;	push hl    ; size 
a1ea			; 
a1ea			;		if DEBUG_FORTH_WORDS 
a1ea			;			DMARK "EX2" 
a1ea			;			CALLMONITOR 
a1ea			;		endif 
a1ea			;	call malloc 
a1ea			; 
a1ea			;	ex de, hl    ; de now contains malloc area 
a1ea			;	pop bc   	; get byte count 
a1ea			;	pop hl      ; get string to copy 
a1ea			; 
a1ea			;	push de     ; save malloc for free later 
a1ea			; 
a1ea			;		if DEBUG_FORTH_WORDS 
a1ea			;			DMARK "EX3" 
a1ea			;			CALLMONITOR 
a1ea			;		endif 
a1ea			;	ldir       ; duplicate string 
a1ea			; 
a1ea			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
a1ea			;	 
a1ea			;	; TODO fix the parse would be better than this...  
a1ea			;	ex de, hl 
a1ea			;	dec hl 
a1ea			;	ld a, 0 
a1ea			;	ld (hl), a 
a1ea			;	dec hl 
a1ea			;	ld a, ' ' 
a1ea			;	ld (hl), a 
a1ea			;	dec hl 
a1ea			;	ld (hl), a 
a1ea			; 
a1ea			;	dec hl 
a1ea			;	ld (hl), a 
a1ea			; 
a1ea			; 
a1ea			;	FORTH_DSP_POP  
a1ea			; 
a1ea			;	pop hl     
a1ea			;	push hl    ; save malloc area 
a1ea			; 
a1ea			;		if DEBUG_FORTH_WORDS 
a1ea			;			DMARK "EX4" 
a1ea			;			CALLMONITOR 
a1ea			;		endif 
a1ea			; 
a1ea			;	call forthparse 
a1ea			;	call forthexec 
a1ea			;	 
a1ea			;	pop hl 
a1ea			;	if DEBUG_FORTH_WORDS 
a1ea			;		DMARK "EX5" 
a1ea			;		CALLMONITOR 
a1ea			;	endif 
a1ea			; 
a1ea			;	if FORTH_ENABLE_FREE 
a1ea			;	call free 
a1ea			;	endif 
a1ea			; 
a1ea			;	if DEBUG_FORTH_WORDS 
a1ea			;		DMARK "EX6" 
a1ea			;		CALLMONITOR 
a1ea			;	endif 
a1ea			; 
a1ea			;	pop bc 
a1ea			;	pop de 
a1ea			;	pop hl 
a1ea			;;	FORTH_RSP_POP	  
a1ea			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
a1ea			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
a1ea			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
a1ea			; 
a1ea			;	if DEBUG_FORTH_WORDS 
a1ea			;		DMARK "EX7" 
a1ea			;		CALLMONITOR 
a1ea			;	endif 
a1ea			;	NEXTW 
a1ea			 
a1ea			;.STKEXEC: 
a1ea			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
a1ea			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
a1ea			; 
a1ea			; 
a1ea			;		if DEBUG_FORTH_WORDS_KEY 
a1ea			;			DMARK "STX" 
a1ea			;			CALLMONITOR 
a1ea			;		endif 
a1ea			; 
a1ea			;	FORTH_DSP_VALUEHL 
a1ea			; 
a1ea			;	ld (store_tmp1), hl    ; count 
a1ea			; 
a1ea			;	FORTH_DSP_POP 
a1ea			;.stkexec1: 
a1ea			;	ld hl, (store_tmp1)   ; count 
a1ea			;	ld a, 0 
a1ea			;	cp l 
a1ea			;	ret z 
a1ea			; 
a1ea			;	dec hl 
a1ea			;	ld (store_tmp1), hl    ; count 
a1ea			;	 
a1ea			;	FORTH_DSP_VALUEHL 
a1ea			;	push hl 
a1ea			;	 
a1ea			;		if DEBUG_FORTH_WORDS 
a1ea			;			DMARK "EXp" 
a1ea			;			CALLMONITOR 
a1ea			;		endif 
a1ea			;	FORTH_DSP_POP 
a1ea			; 
a1ea			;	call strlenz 
a1ea			;	inc hl   ; include zero term to copy 
a1ea			;	inc hl   ; include zero term to copy 
a1ea			;	inc hl   ; include zero term to copy 
a1ea			;	ld b,0 
a1ea			;	ld c,l 
a1ea			;	pop hl 
a1ea			;	ld de, execscratch 
a1ea			;		if DEBUG_FORTH_WORDS 
a1ea			;			DMARK "EX3" 
a1ea			;			CALLMONITOR 
a1ea			;		endif 
a1ea			;	ldir 
a1ea			; 
a1ea			; 
a1ea			;	ld hl, execscratch 
a1ea			; 
a1ea			;		if DEBUG_FORTH_WORDS 
a1ea			;			DMARK "EXP" 
a1ea			;			CALLMONITOR 
a1ea			;		endif 
a1ea			; 
a1ea			;	call forthparse 
a1ea			;	ld hl, execscratch 
a1ea			;		if DEBUG_FORTH_WORDS 
a1ea			;			DMARK "EXx" 
a1ea			;			CALLMONITOR 
a1ea			;		endif 
a1ea			;	call forthexec 
a1ea			; 
a1ea			;	jp .stkexec1 
a1ea			; 
a1ea			;	ret 
a1ea			 
a1ea			 
a1ea			.DUP: 
a1ea			CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
a1ea 17				db WORD_SYS_CORE+OPCODE_DUP             
a1eb 60 a2			dw .ZDUP            
a1ed 04				db 3 + 1 
a1ee .. 00			db "DUP",0              
a1f2				endm 
# End of macro CWHEAD
a1f2			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
a1f2			 
a1f2				if DEBUG_FORTH_WORDS_KEY 
a1f2					DMARK "DUP" 
a1f2 f5				push af  
a1f3 3a 07 a2			ld a, (.dmark)  
a1f6 32 6b ee			ld (debug_mark),a  
a1f9 3a 08 a2			ld a, (.dmark+1)  
a1fc 32 6c ee			ld (debug_mark+1),a  
a1ff 3a 09 a2			ld a, (.dmark+2)  
a202 32 6d ee			ld (debug_mark+2),a  
a205 18 03			jr .pastdmark  
a207 ..			.dmark: db "DUP"  
a20a f1			.pastdmark: pop af  
a20b			endm  
# End of macro DMARK
a20b					CALLMONITOR 
a20b cd 6f ee			call debug_vector  
a20e				endm  
# End of macro CALLMONITOR
a20e				endif 
a20e			 
a20e				FORTH_DSP 
a20e cd 63 9e			call macro_forth_dsp 
a211				endm 
# End of macro FORTH_DSP
a211			 
a211 7e				ld a, (HL) 
a212 fe 01			cp DS_TYPE_STR 
a214 20 25			jr nz, .dupinum 
a216			 
a216				; push another string 
a216			 
a216				FORTH_DSP_VALUEHL     		 
a216 cd 9d 9e			call macro_dsp_valuehl 
a219				endm 
# End of macro FORTH_DSP_VALUEHL
a219			 
a219			if DEBUG_FORTH_WORDS 
a219				DMARK "DUs" 
a219 f5				push af  
a21a 3a 2e a2			ld a, (.dmark)  
a21d 32 6b ee			ld (debug_mark),a  
a220 3a 2f a2			ld a, (.dmark+1)  
a223 32 6c ee			ld (debug_mark+1),a  
a226 3a 30 a2			ld a, (.dmark+2)  
a229 32 6d ee			ld (debug_mark+2),a  
a22c 18 03			jr .pastdmark  
a22e ..			.dmark: db "DUs"  
a231 f1			.pastdmark: pop af  
a232			endm  
# End of macro DMARK
a232				CALLMONITOR 
a232 cd 6f ee			call debug_vector  
a235				endm  
# End of macro CALLMONITOR
a235			endif 
a235 cd 14 9d			call forth_push_str 
a238			 
a238				NEXTW 
a238 c3 53 a0			jp macro_next 
a23b				endm 
# End of macro NEXTW
a23b			 
a23b			 
a23b			.dupinum: 
a23b				 
a23b			 
a23b			 
a23b				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a23b cd 9d 9e			call macro_dsp_valuehl 
a23e				endm 
# End of macro FORTH_DSP_VALUEHL
a23e			 
a23e			; TODO add floating point number detection 
a23e			 
a23e			if DEBUG_FORTH_WORDS 
a23e				DMARK "DUi" 
a23e f5				push af  
a23f 3a 53 a2			ld a, (.dmark)  
a242 32 6b ee			ld (debug_mark),a  
a245 3a 54 a2			ld a, (.dmark+1)  
a248 32 6c ee			ld (debug_mark+1),a  
a24b 3a 55 a2			ld a, (.dmark+2)  
a24e 32 6d ee			ld (debug_mark+2),a  
a251 18 03			jr .pastdmark  
a253 ..			.dmark: db "DUi"  
a256 f1			.pastdmark: pop af  
a257			endm  
# End of macro DMARK
a257				CALLMONITOR 
a257 cd 6f ee			call debug_vector  
a25a				endm  
# End of macro CALLMONITOR
a25a			endif 
a25a			 
a25a cd a6 9c			call forth_push_numhl 
a25d				NEXTW 
a25d c3 53 a0			jp macro_next 
a260				endm 
# End of macro NEXTW
a260			.ZDUP: 
a260			CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
a260 99				db WORD_SYS_CORE+OPCODE_ZDUP             
a261 98 a2			dw .SWAP            
a263 05				db 4 + 1 
a264 .. 00			db "?DUP",0              
a269				endm 
# End of macro CWHEAD
a269			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
a269			 
a269				if DEBUG_FORTH_WORDS_KEY 
a269					DMARK "qDU" 
a269 f5				push af  
a26a 3a 7e a2			ld a, (.dmark)  
a26d 32 6b ee			ld (debug_mark),a  
a270 3a 7f a2			ld a, (.dmark+1)  
a273 32 6c ee			ld (debug_mark+1),a  
a276 3a 80 a2			ld a, (.dmark+2)  
a279 32 6d ee			ld (debug_mark+2),a  
a27c 18 03			jr .pastdmark  
a27e ..			.dmark: db "qDU"  
a281 f1			.pastdmark: pop af  
a282			endm  
# End of macro DMARK
a282					CALLMONITOR 
a282 cd 6f ee			call debug_vector  
a285				endm  
# End of macro CALLMONITOR
a285				endif 
a285				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a285 cd 9d 9e			call macro_dsp_valuehl 
a288				endm 
# End of macro FORTH_DSP_VALUEHL
a288			 
a288 e5				push hl 
a289			 
a289				; is it a zero? 
a289			 
a289 3e 00			ld a, 0 
a28b 84				add h 
a28c 85				add l 
a28d			 
a28d e1				pop hl 
a28e			 
a28e fe 00			cp 0 
a290 28 03			jr z, .dup2orig 
a292			 
a292			 
a292 cd a6 9c			call forth_push_numhl 
a295			 
a295			 
a295			; TODO add floating point number detection 
a295			 
a295			.dup2orig: 
a295			 
a295				NEXTW 
a295 c3 53 a0			jp macro_next 
a298				endm 
# End of macro NEXTW
a298			.SWAP: 
a298			CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
a298 18				db WORD_SYS_CORE+OPCODE_SWAP             
a299 d7 a2			dw .COLN            
a29b 05				db 4 + 1 
a29c .. 00			db "SWAP",0              
a2a1				endm 
# End of macro CWHEAD
a2a1			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
a2a1				if DEBUG_FORTH_WORDS_KEY 
a2a1					DMARK "SWP" 
a2a1 f5				push af  
a2a2 3a b6 a2			ld a, (.dmark)  
a2a5 32 6b ee			ld (debug_mark),a  
a2a8 3a b7 a2			ld a, (.dmark+1)  
a2ab 32 6c ee			ld (debug_mark+1),a  
a2ae 3a b8 a2			ld a, (.dmark+2)  
a2b1 32 6d ee			ld (debug_mark+2),a  
a2b4 18 03			jr .pastdmark  
a2b6 ..			.dmark: db "SWP"  
a2b9 f1			.pastdmark: pop af  
a2ba			endm  
# End of macro DMARK
a2ba					CALLMONITOR 
a2ba cd 6f ee			call debug_vector  
a2bd				endm  
# End of macro CALLMONITOR
a2bd				endif 
a2bd			 
a2bd			; TODO Use os stack swap memory 
a2bd				FORTH_DSP_VALUEHL 
a2bd cd 9d 9e			call macro_dsp_valuehl 
a2c0				endm 
# End of macro FORTH_DSP_VALUEHL
a2c0 e5				push hl     ; w2 
a2c1			 
a2c1				FORTH_DSP_POP 
a2c1 cd 55 9f			call macro_forth_dsp_pop 
a2c4				endm 
# End of macro FORTH_DSP_POP
a2c4			 
a2c4				FORTH_DSP_VALUEHL 
a2c4 cd 9d 9e			call macro_dsp_valuehl 
a2c7				endm 
# End of macro FORTH_DSP_VALUEHL
a2c7			 
a2c7				FORTH_DSP_POP 
a2c7 cd 55 9f			call macro_forth_dsp_pop 
a2ca				endm 
# End of macro FORTH_DSP_POP
a2ca			 
a2ca d1				pop de     ; w2	, hl = w1 
a2cb			 
a2cb eb				ex de, hl 
a2cc d5				push de 
a2cd			 
a2cd cd a6 9c			call forth_push_numhl 
a2d0			 
a2d0 e1				pop hl 
a2d1			 
a2d1 cd a6 9c			call forth_push_numhl 
a2d4				 
a2d4			 
a2d4				NEXTW 
a2d4 c3 53 a0			jp macro_next 
a2d7				endm 
# End of macro NEXTW
a2d7			.COLN: 
a2d7			CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
a2d7 19				db WORD_SYS_CORE+OPCODE_COLN             
a2d8 63 a4			dw .SCOLN            
a2da 02				db 1 + 1 
a2db .. 00			db ":",0              
a2dd				endm 
# End of macro CWHEAD
a2dd			; | : ( -- )         Create new word | DONE 
a2dd			 
a2dd				if DEBUG_FORTH_WORDS_KEY 
a2dd					DMARK "CLN" 
a2dd f5				push af  
a2de 3a f2 a2			ld a, (.dmark)  
a2e1 32 6b ee			ld (debug_mark),a  
a2e4 3a f3 a2			ld a, (.dmark+1)  
a2e7 32 6c ee			ld (debug_mark+1),a  
a2ea 3a f4 a2			ld a, (.dmark+2)  
a2ed 32 6d ee			ld (debug_mark+2),a  
a2f0 18 03			jr .pastdmark  
a2f2 ..			.dmark: db "CLN"  
a2f5 f1			.pastdmark: pop af  
a2f6			endm  
# End of macro DMARK
a2f6					CALLMONITOR 
a2f6 cd 6f ee			call debug_vector  
a2f9				endm  
# End of macro CALLMONITOR
a2f9				endif 
a2f9			STACKFRAME OFF $8efe $989f 
a2f9				if DEBUG_STACK_IMB 
a2f9					if OFF 
a2f9						exx 
a2f9						ld de, $8efe 
a2f9						ld a, d 
a2f9						ld hl, curframe 
a2f9						call hexout 
a2f9						ld a, e 
a2f9						ld hl, curframe+2 
a2f9						call hexout 
a2f9						ld hl, $8efe 
a2f9						push hl 
a2f9						ld hl, $989f 
a2f9						push hl 
a2f9						exx 
a2f9					endif 
a2f9				endif 
a2f9			endm 
# End of macro STACKFRAME
a2f9			; get parser buffer length  of new word 
a2f9			 
a2f9			 
a2f9			 
a2f9				; move tok past this to start of name defintition 
a2f9				; TODO get word to define 
a2f9				; TODO Move past word token 
a2f9				; TODO get length of string up to the ';' 
a2f9			 
a2f9 2a c2 e5		ld hl, (os_tok_ptr) 
a2fc 23			inc hl 
a2fd 23			inc hl 
a2fe			 
a2fe 3e 3b		ld a, ';' 
a300 cd a3 92		call strlent 
a303			 
a303 7d			ld a,l 
a304 32 b1 e2		ld (os_new_parse_len), a 
a307			 
a307			 
a307			if DEBUG_FORTH_UWORD 
a307 ed 5b c2 e5	ld de, (os_tok_ptr) 
a30b					DMARK ":01" 
a30b f5				push af  
a30c 3a 20 a3			ld a, (.dmark)  
a30f 32 6b ee			ld (debug_mark),a  
a312 3a 21 a3			ld a, (.dmark+1)  
a315 32 6c ee			ld (debug_mark+1),a  
a318 3a 22 a3			ld a, (.dmark+2)  
a31b 32 6d ee			ld (debug_mark+2),a  
a31e 18 03			jr .pastdmark  
a320 ..			.dmark: db ":01"  
a323 f1			.pastdmark: pop af  
a324			endm  
# End of macro DMARK
a324			CALLMONITOR 
a324 cd 6f ee			call debug_vector  
a327				endm  
# End of macro CALLMONITOR
a327			endif 
a327			 
a327			; 
a327			;  new word memory layout: 
a327			;  
a327			;    : adg 6666 ;  
a327			; 
a327			;    db   1     ; user defined word  
a327 23			inc hl    
a328			;    dw   sysdict 
a328 23			inc hl 
a329 23			inc hl 
a32a			;    db <word len>+1 (for null) 
a32a 23			inc hl 
a32b			;    db .... <word> 
a32b			; 
a32b			 
a32b 23			inc hl    ; some extras for the word preamble before the above 
a32c 23			inc hl 
a32d 23			inc hl 
a32e 23			inc hl 
a32f 23			inc hl 
a330 23			inc hl 
a331 23			inc hl  
a332 23			inc hl 
a333 23			inc hl 
a334 23			inc hl 
a335 23			inc hl 
a336 23			inc hl 
a337 23			inc hl 
a338 23			inc hl     ; TODO how many do we really need?     maybe only 6 
a339			;       exec word buffer 
a339			;	<ptr word>   
a339 23			inc hl 
a33a 23			inc hl 
a33b			;       <word list><null term> 7F final term 
a33b			 
a33b			 
a33b			if DEBUG_FORTH_UWORD 
a33b					DMARK ":02" 
a33b f5				push af  
a33c 3a 50 a3			ld a, (.dmark)  
a33f 32 6b ee			ld (debug_mark),a  
a342 3a 51 a3			ld a, (.dmark+1)  
a345 32 6c ee			ld (debug_mark+1),a  
a348 3a 52 a3			ld a, (.dmark+2)  
a34b 32 6d ee			ld (debug_mark+2),a  
a34e 18 03			jr .pastdmark  
a350 ..			.dmark: db ":02"  
a353 f1			.pastdmark: pop af  
a354			endm  
# End of macro DMARK
a354			CALLMONITOR 
a354 cd 6f ee			call debug_vector  
a357				endm  
# End of macro CALLMONITOR
a357			endif 
a357			 
a357			 
a357				; malloc the size 
a357			 
a357 cd 0d 93			call malloc 
a35a 22 b3 e2			ld (os_new_malloc), hl     ; save malloc start 
a35d			 
a35d			;    db   1     ; user defined word  
a35d 3e 01			ld a, WORD_SYS_UWORD  
a35f 77				ld (hl), a 
a360			 
a360 23			inc hl    
a361			;    dw   sysdict 
a361 11 ab a1		ld de, sysdict       ; continue on with the scan to the system dict 
a364 73			ld (hl), e 
a365 23			inc hl 
a366 72			ld (hl), d 
a367 23			inc hl 
a368			 
a368			 
a368			;    Setup dict word 
a368			 
a368 23			inc hl 
a369 22 ad e2		ld (os_new_work_ptr), hl     ; save start of dict word  
a36c			 
a36c			; 1. get length of dict word 
a36c			 
a36c			 
a36c 2a c2 e5		ld hl, (os_tok_ptr) 
a36f 23			inc hl 
a370 23			inc hl    ; position to start of dict word 
a371 3e 00		ld a, 0 
a373 cd a3 92		call strlent 
a376			 
a376			 
a376 23			inc hl    ; to include null??? 
a377			 
a377			; write length of dict word 
a377			 
a377 ed 5b ad e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
a37b 1b			dec de 
a37c eb			ex de, hl 
a37d 73			ld (hl), e 
a37e eb			ex de, hl 
a37f			 
a37f			 
a37f			 
a37f			; copy  
a37f 4d			ld c, l 
a380 06 00		ld b, 0 
a382 ed 5b ad e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
a386 2a c2 e5		ld hl, (os_tok_ptr) 
a389 23			inc hl 
a38a 23			inc hl    ; position to start of dict word 
a38b			 
a38b			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
a38b			 
a38b			; TODO need to convert word to upper case 
a38b			 
a38b			ucasetok:	 
a38b 7e			ld a,(hl) 
a38c cd 8f 92		call toUpper 
a38f 77			ld (hl),a 
a390 ed a0		ldi 
a392 f2 8b a3		jp p, ucasetok 
a395			 
a395			 
a395			 
a395			; de now points to start of where the word body code should be placed 
a395 ed 53 ad e2	ld (os_new_work_ptr), de 
a399			; hl now points to the words to throw at forthexec which needs to be copied 
a399 22 ab e2		ld (os_new_src_ptr), hl 
a39c			 
a39c			; TODO add 'call to forthexec' 
a39c			 
a39c			if DEBUG_FORTH_UWORD 
a39c c5			push bc 
a39d ed 4b b3 e2	ld bc, (os_new_malloc) 
a3a1					DMARK ":0x" 
a3a1 f5				push af  
a3a2 3a b6 a3			ld a, (.dmark)  
a3a5 32 6b ee			ld (debug_mark),a  
a3a8 3a b7 a3			ld a, (.dmark+1)  
a3ab 32 6c ee			ld (debug_mark+1),a  
a3ae 3a b8 a3			ld a, (.dmark+2)  
a3b1 32 6d ee			ld (debug_mark+2),a  
a3b4 18 03			jr .pastdmark  
a3b6 ..			.dmark: db ":0x"  
a3b9 f1			.pastdmark: pop af  
a3ba			endm  
# End of macro DMARK
a3ba			CALLMONITOR 
a3ba cd 6f ee			call debug_vector  
a3bd				endm  
# End of macro CALLMONITOR
a3bd c1			pop bc 
a3be			endif 
a3be			 
a3be			 
a3be			; create word preamble which should be: 
a3be			 
a3be			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
a3be			 
a3be			;    ld hl, <word code> 
a3be			;    jp user_exec 
a3be			;    <word code bytes> 
a3be			 
a3be			 
a3be			;	inc de     ; TODO ??? or are we already past the word's null 
a3be eb			ex de, hl 
a3bf			 
a3bf 36 21		ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
a3c1			 
a3c1 23			inc hl 
a3c2 22 a7 e2		ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
a3c5 23			inc hl 
a3c6			 
a3c6 23			inc hl 
a3c7 36 c3		ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
a3c9			 
a3c9 01 41 cd		ld bc, user_exec 
a3cc 23			inc hl 
a3cd 71			ld (hl), c     ; poke address of user_exec 
a3ce 23			inc hl 
a3cf 70			ld (hl), b     
a3d0			; 
a3d0			;	inc hl 
a3d0			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a3d0			; 
a3d0			; 
a3d0			;	ld bc, macro_forth_rsp_next 
a3d0			;	inc hl 
a3d0			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
a3d0			;	inc hl 
a3d0			;	ld (hl), b     
a3d0			; 
a3d0			;	inc hl 
a3d0			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a3d0			; 
a3d0			; 
a3d0			;	inc hl 
a3d0			;	ld bc, forthexec 
a3d0			;	ld (hl), c     ; poke address of forthexec 
a3d0			;	inc hl 
a3d0			;	ld (hl), b      
a3d0			; 
a3d0			;	inc hl 
a3d0			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
a3d0			; 
a3d0			;	ld bc, user_dict_next 
a3d0			;	inc hl 
a3d0			;	ld (hl), c     ; poke address of forthexec 
a3d0			;	inc hl 
a3d0			;	ld (hl), b      
a3d0			 
a3d0			; hl is now where we need to copy the word byte data to save this 
a3d0			 
a3d0 23			inc hl 
a3d1 22 a9 e2		ld (os_new_exec), hl 
a3d4			 
a3d4			; copy definition 
a3d4			 
a3d4 eb			ex de, hl 
a3d5			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
a3d5			;	inc de    ; skip the PC for this parse 
a3d5 3a b1 e2		ld a, (os_new_parse_len) 
a3d8 4f			ld c, a 
a3d9 06 00		ld b, 0 
a3db ed b0		ldir		 ; copy defintion 
a3dd			 
a3dd			 
a3dd			; poke the address of where the new word bytes live for forthexec 
a3dd			 
a3dd 2a a7 e2		ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
a3e0			 
a3e0 ed 5b a9 e2	ld de, (os_new_exec)      
a3e4			 
a3e4 73			ld (hl), e 
a3e5 23			inc hl 
a3e6 72			ld (hl), d 
a3e7			 
a3e7				; TODO copy last user dict word next link to this word 
a3e7				; TODO update last user dict word to point to this word 
a3e7			; 
a3e7			; hl f923 de 812a ; bc 811a 
a3e7			 
a3e7			if DEBUG_FORTH_UWORD 
a3e7 c5			push bc 
a3e8 ed 4b b3 e2	ld bc, (os_new_malloc) 
a3ec					DMARK ":0A" 
a3ec f5				push af  
a3ed 3a 01 a4			ld a, (.dmark)  
a3f0 32 6b ee			ld (debug_mark),a  
a3f3 3a 02 a4			ld a, (.dmark+1)  
a3f6 32 6c ee			ld (debug_mark+1),a  
a3f9 3a 03 a4			ld a, (.dmark+2)  
a3fc 32 6d ee			ld (debug_mark+2),a  
a3ff 18 03			jr .pastdmark  
a401 ..			.dmark: db ":0A"  
a404 f1			.pastdmark: pop af  
a405			endm  
# End of macro DMARK
a405			CALLMONITOR 
a405 cd 6f ee			call debug_vector  
a408				endm  
# End of macro CALLMONITOR
a408 c1			pop bc 
a409			endif 
a409			if DEBUG_FORTH_UWORD 
a409 c5			push bc 
a40a ed 4b b3 e2	ld bc, (os_new_malloc) 
a40e 03			inc bc 
a40f 03			inc bc 
a410 03			inc bc 
a411 03			inc bc 
a412 03			inc bc 
a413 03			inc bc 
a414 03			inc bc 
a415 03			inc bc 
a416			 
a416					DMARK ":0B" 
a416 f5				push af  
a417 3a 2b a4			ld a, (.dmark)  
a41a 32 6b ee			ld (debug_mark),a  
a41d 3a 2c a4			ld a, (.dmark+1)  
a420 32 6c ee			ld (debug_mark+1),a  
a423 3a 2d a4			ld a, (.dmark+2)  
a426 32 6d ee			ld (debug_mark+2),a  
a429 18 03			jr .pastdmark  
a42b ..			.dmark: db ":0B"  
a42e f1			.pastdmark: pop af  
a42f			endm  
# End of macro DMARK
a42f			CALLMONITOR 
a42f cd 6f ee			call debug_vector  
a432				endm  
# End of macro CALLMONITOR
a432 c1			pop bc 
a433			endif 
a433			 
a433			; update word dict linked list for new word 
a433			 
a433			 
a433 2a be e5		ld hl, (os_last_new_uword)		; get the start of the last added uword 
a436 23			inc hl     ; move to next work linked list ptr 
a437			 
a437 ed 5b b3 e2	ld de, (os_new_malloc)		 ; new next word 
a43b 73			ld (hl), e 
a43c 23			inc hl 
a43d 72			ld (hl), d 
a43e			 
a43e			if DEBUG_FORTH_UWORD 
a43e ed 4b be e5	ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
a442			endif 
a442			 
a442 ed 53 be e5	ld (os_last_new_uword), de      ; update last new uword ptr 
a446			 
a446			 
a446			if DEBUG_FORTH_UWORD 
a446					DMARK ":0+" 
a446 f5				push af  
a447 3a 5b a4			ld a, (.dmark)  
a44a 32 6b ee			ld (debug_mark),a  
a44d 3a 5c a4			ld a, (.dmark+1)  
a450 32 6c ee			ld (debug_mark+1),a  
a453 3a 5d a4			ld a, (.dmark+2)  
a456 32 6d ee			ld (debug_mark+2),a  
a459 18 03			jr .pastdmark  
a45b ..			.dmark: db ":0+"  
a45e f1			.pastdmark: pop af  
a45f			endm  
# End of macro DMARK
a45f			CALLMONITOR 
a45f cd 6f ee			call debug_vector  
a462				endm  
# End of macro CALLMONITOR
a462			endif 
a462			 
a462			STACKFRAMECHK OFF $8efe $989f 
a462				if DEBUG_STACK_IMB 
a462					if OFF 
a462						exx 
a462						ld hl, $989f 
a462						pop de   ; $989f 
a462						call cmp16 
a462						jr nz, .spnosame 
a462						ld hl, $8efe 
a462						pop de   ; $8efe 
a462						call cmp16 
a462						jr z, .spfrsame 
a462						.spnosame: call showsperror 
a462						.spfrsame: nop 
a462						exx 
a462					endif 
a462				endif 
a462			endm 
# End of macro STACKFRAMECHK
a462			 
a462 c9			ret    ; dont process any remaining parser tokens as they form new word 
a463			 
a463			 
a463			 
a463			 
a463			;		NEXT 
a463			.SCOLN: 
a463			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
a463 06			db OPCODE_SCOLN 
a464 af a4		dw .DROP 
a466 02			db 2 
a467 .. 00		db ";",0           
a469			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
a469				if DEBUG_FORTH_WORDS_KEY 
a469					DMARK "SCN" 
a469 f5				push af  
a46a 3a 7e a4			ld a, (.dmark)  
a46d 32 6b ee			ld (debug_mark),a  
a470 3a 7f a4			ld a, (.dmark+1)  
a473 32 6c ee			ld (debug_mark+1),a  
a476 3a 80 a4			ld a, (.dmark+2)  
a479 32 6d ee			ld (debug_mark+2),a  
a47c 18 03			jr .pastdmark  
a47e ..			.dmark: db "SCN"  
a481 f1			.pastdmark: pop af  
a482			endm  
# End of macro DMARK
a482					CALLMONITOR 
a482 cd 6f ee			call debug_vector  
a485				endm  
# End of macro CALLMONITOR
a485				endif 
a485				FORTH_RSP_TOS 
a485 cd 64 9c			call macro_forth_rsp_tos 
a488				endm 
# End of macro FORTH_RSP_TOS
a488 e5				push hl 
a489				FORTH_RSP_POP 
a489 cd 6e 9c			call macro_forth_rsp_pop 
a48c				endm 
# End of macro FORTH_RSP_POP
a48c e1				pop hl 
a48d			;		ex de,hl 
a48d 22 c2 e5			ld (os_tok_ptr),hl 
a490			 
a490			if DEBUG_FORTH_UWORD 
a490					DMARK "SCL" 
a490 f5				push af  
a491 3a a5 a4			ld a, (.dmark)  
a494 32 6b ee			ld (debug_mark),a  
a497 3a a6 a4			ld a, (.dmark+1)  
a49a 32 6c ee			ld (debug_mark+1),a  
a49d 3a a7 a4			ld a, (.dmark+2)  
a4a0 32 6d ee			ld (debug_mark+2),a  
a4a3 18 03			jr .pastdmark  
a4a5 ..			.dmark: db "SCL"  
a4a8 f1			.pastdmark: pop af  
a4a9			endm  
# End of macro DMARK
a4a9			CALLMONITOR 
a4a9 cd 6f ee			call debug_vector  
a4ac				endm  
# End of macro CALLMONITOR
a4ac			endif 
a4ac				NEXTW 
a4ac c3 53 a0			jp macro_next 
a4af				endm 
# End of macro NEXTW
a4af			 
a4af			.DROP: 
a4af			CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
a4af 1b				db WORD_SYS_CORE+OPCODE_DROP             
a4b0 da a4			dw .DUP2            
a4b2 05				db 4 + 1 
a4b3 .. 00			db "DROP",0              
a4b8				endm 
# End of macro CWHEAD
a4b8			; | DROP ( w -- )   drop the TOS item   | DONE 
a4b8				if DEBUG_FORTH_WORDS_KEY 
a4b8					DMARK "DRP" 
a4b8 f5				push af  
a4b9 3a cd a4			ld a, (.dmark)  
a4bc 32 6b ee			ld (debug_mark),a  
a4bf 3a ce a4			ld a, (.dmark+1)  
a4c2 32 6c ee			ld (debug_mark+1),a  
a4c5 3a cf a4			ld a, (.dmark+2)  
a4c8 32 6d ee			ld (debug_mark+2),a  
a4cb 18 03			jr .pastdmark  
a4cd ..			.dmark: db "DRP"  
a4d0 f1			.pastdmark: pop af  
a4d1			endm  
# End of macro DMARK
a4d1					CALLMONITOR 
a4d1 cd 6f ee			call debug_vector  
a4d4				endm  
# End of macro CALLMONITOR
a4d4				endif 
a4d4				FORTH_DSP_POP 
a4d4 cd 55 9f			call macro_forth_dsp_pop 
a4d7				endm 
# End of macro FORTH_DSP_POP
a4d7				NEXTW 
a4d7 c3 53 a0			jp macro_next 
a4da				endm 
# End of macro NEXTW
a4da			.DUP2: 
a4da			CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
a4da 1c				db WORD_SYS_CORE+OPCODE_DUP2             
a4db 1f a5			dw .DROP2            
a4dd 05				db 4 + 1 
a4de .. 00			db "2DUP",0              
a4e3				endm 
# End of macro CWHEAD
a4e3			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
a4e3				if DEBUG_FORTH_WORDS_KEY 
a4e3					DMARK "2DU" 
a4e3 f5				push af  
a4e4 3a f8 a4			ld a, (.dmark)  
a4e7 32 6b ee			ld (debug_mark),a  
a4ea 3a f9 a4			ld a, (.dmark+1)  
a4ed 32 6c ee			ld (debug_mark+1),a  
a4f0 3a fa a4			ld a, (.dmark+2)  
a4f3 32 6d ee			ld (debug_mark+2),a  
a4f6 18 03			jr .pastdmark  
a4f8 ..			.dmark: db "2DU"  
a4fb f1			.pastdmark: pop af  
a4fc			endm  
# End of macro DMARK
a4fc					CALLMONITOR 
a4fc cd 6f ee			call debug_vector  
a4ff				endm  
# End of macro CALLMONITOR
a4ff				endif 
a4ff				FORTH_DSP_VALUEHL 
a4ff cd 9d 9e			call macro_dsp_valuehl 
a502				endm 
# End of macro FORTH_DSP_VALUEHL
a502 e5				push hl      ; 2 
a503			 
a503				FORTH_DSP_POP 
a503 cd 55 9f			call macro_forth_dsp_pop 
a506				endm 
# End of macro FORTH_DSP_POP
a506				 
a506				FORTH_DSP_VALUEHL 
a506 cd 9d 9e			call macro_dsp_valuehl 
a509				endm 
# End of macro FORTH_DSP_VALUEHL
a509			;		push hl      ; 1 
a509			 
a509				FORTH_DSP_POP 
a509 cd 55 9f			call macro_forth_dsp_pop 
a50c				endm 
# End of macro FORTH_DSP_POP
a50c			 
a50c			;		pop hl       ; 1 
a50c d1				pop de       ; 2 
a50d			 
a50d cd a6 9c			call forth_push_numhl 
a510 eb				ex de, hl 
a511 cd a6 9c			call forth_push_numhl 
a514			 
a514				 
a514 eb				ex de, hl 
a515			 
a515 cd a6 9c			call forth_push_numhl 
a518 eb				ex de, hl 
a519 cd a6 9c			call forth_push_numhl 
a51c			 
a51c			 
a51c				NEXTW 
a51c c3 53 a0			jp macro_next 
a51f				endm 
# End of macro NEXTW
a51f			.DROP2: 
a51f			CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
a51f 1d				db WORD_SYS_CORE+OPCODE_DROP2             
a520 4e a5			dw .SWAP2            
a522 06				db 5 + 1 
a523 .. 00			db "2DROP",0              
a529				endm 
# End of macro CWHEAD
a529			; | 2DROP ( w w -- )    Double drop | DONE 
a529				if DEBUG_FORTH_WORDS_KEY 
a529					DMARK "2DR" 
a529 f5				push af  
a52a 3a 3e a5			ld a, (.dmark)  
a52d 32 6b ee			ld (debug_mark),a  
a530 3a 3f a5			ld a, (.dmark+1)  
a533 32 6c ee			ld (debug_mark+1),a  
a536 3a 40 a5			ld a, (.dmark+2)  
a539 32 6d ee			ld (debug_mark+2),a  
a53c 18 03			jr .pastdmark  
a53e ..			.dmark: db "2DR"  
a541 f1			.pastdmark: pop af  
a542			endm  
# End of macro DMARK
a542					CALLMONITOR 
a542 cd 6f ee			call debug_vector  
a545				endm  
# End of macro CALLMONITOR
a545				endif 
a545				FORTH_DSP_POP 
a545 cd 55 9f			call macro_forth_dsp_pop 
a548				endm 
# End of macro FORTH_DSP_POP
a548				FORTH_DSP_POP 
a548 cd 55 9f			call macro_forth_dsp_pop 
a54b				endm 
# End of macro FORTH_DSP_POP
a54b				NEXTW 
a54b c3 53 a0			jp macro_next 
a54e				endm 
# End of macro NEXTW
a54e			.SWAP2: 
a54e			CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
a54e 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
a54f 77 a5			dw .AT            
a551 06				db 5 + 1 
a552 .. 00			db "2SWAP",0              
a558				endm 
# End of macro CWHEAD
a558			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
a558				if DEBUG_FORTH_WORDS_KEY 
a558					DMARK "2SW" 
a558 f5				push af  
a559 3a 6d a5			ld a, (.dmark)  
a55c 32 6b ee			ld (debug_mark),a  
a55f 3a 6e a5			ld a, (.dmark+1)  
a562 32 6c ee			ld (debug_mark+1),a  
a565 3a 6f a5			ld a, (.dmark+2)  
a568 32 6d ee			ld (debug_mark+2),a  
a56b 18 03			jr .pastdmark  
a56d ..			.dmark: db "2SW"  
a570 f1			.pastdmark: pop af  
a571			endm  
# End of macro DMARK
a571					CALLMONITOR 
a571 cd 6f ee			call debug_vector  
a574				endm  
# End of macro CALLMONITOR
a574				endif 
a574			; TODO Use os stack swap memory 
a574				NEXTW 
a574 c3 53 a0			jp macro_next 
a577				endm 
# End of macro NEXTW
a577			.AT: 
a577			CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
a577 1f				db WORD_SYS_CORE+OPCODE_AT             
a578 a9 a5			dw .CAT            
a57a 02				db 1 + 1 
a57b .. 00			db "@",0              
a57d				endm 
# End of macro CWHEAD
a57d			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
a57d			 
a57d				if DEBUG_FORTH_WORDS_KEY 
a57d					DMARK "AT." 
a57d f5				push af  
a57e 3a 92 a5			ld a, (.dmark)  
a581 32 6b ee			ld (debug_mark),a  
a584 3a 93 a5			ld a, (.dmark+1)  
a587 32 6c ee			ld (debug_mark+1),a  
a58a 3a 94 a5			ld a, (.dmark+2)  
a58d 32 6d ee			ld (debug_mark+2),a  
a590 18 03			jr .pastdmark  
a592 ..			.dmark: db "AT."  
a595 f1			.pastdmark: pop af  
a596			endm  
# End of macro DMARK
a596					CALLMONITOR 
a596 cd 6f ee			call debug_vector  
a599				endm  
# End of macro CALLMONITOR
a599				endif 
a599			.getbyteat:	 
a599				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a599 cd 9d 9e			call macro_dsp_valuehl 
a59c				endm 
# End of macro FORTH_DSP_VALUEHL
a59c				 
a59c			;		push hl 
a59c			 
a59c				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a59c cd 55 9f			call macro_forth_dsp_pop 
a59f				endm 
# End of macro FORTH_DSP_POP
a59f			 
a59f			;		pop hl 
a59f			 
a59f 7e				ld a, (hl) 
a5a0			 
a5a0 6f				ld l, a 
a5a1 26 00			ld h, 0 
a5a3 cd a6 9c			call forth_push_numhl 
a5a6			 
a5a6				NEXTW 
a5a6 c3 53 a0			jp macro_next 
a5a9				endm 
# End of macro NEXTW
a5a9			.CAT: 
a5a9			CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
a5a9 20				db WORD_SYS_CORE+OPCODE_CAT             
a5aa d2 a5			dw .BANG            
a5ac 03				db 2 + 1 
a5ad .. 00			db "C@",0              
a5b0				endm 
# End of macro CWHEAD
a5b0			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
a5b0				if DEBUG_FORTH_WORDS_KEY 
a5b0					DMARK "CAA" 
a5b0 f5				push af  
a5b1 3a c5 a5			ld a, (.dmark)  
a5b4 32 6b ee			ld (debug_mark),a  
a5b7 3a c6 a5			ld a, (.dmark+1)  
a5ba 32 6c ee			ld (debug_mark+1),a  
a5bd 3a c7 a5			ld a, (.dmark+2)  
a5c0 32 6d ee			ld (debug_mark+2),a  
a5c3 18 03			jr .pastdmark  
a5c5 ..			.dmark: db "CAA"  
a5c8 f1			.pastdmark: pop af  
a5c9			endm  
# End of macro DMARK
a5c9					CALLMONITOR 
a5c9 cd 6f ee			call debug_vector  
a5cc				endm  
# End of macro CALLMONITOR
a5cc				endif 
a5cc c3 99 a5			jp .getbyteat 
a5cf				NEXTW 
a5cf c3 53 a0			jp macro_next 
a5d2				endm 
# End of macro NEXTW
a5d2			.BANG: 
a5d2			CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
a5d2 21				db WORD_SYS_CORE+OPCODE_BANG             
a5d3 08 a6			dw .CBANG            
a5d5 02				db 1 + 1 
a5d6 .. 00			db "!",0              
a5d8				endm 
# End of macro CWHEAD
a5d8			; | ! ( x w -- ) Store x at address w      | DONE 
a5d8				if DEBUG_FORTH_WORDS_KEY 
a5d8					DMARK "BNG" 
a5d8 f5				push af  
a5d9 3a ed a5			ld a, (.dmark)  
a5dc 32 6b ee			ld (debug_mark),a  
a5df 3a ee a5			ld a, (.dmark+1)  
a5e2 32 6c ee			ld (debug_mark+1),a  
a5e5 3a ef a5			ld a, (.dmark+2)  
a5e8 32 6d ee			ld (debug_mark+2),a  
a5eb 18 03			jr .pastdmark  
a5ed ..			.dmark: db "BNG"  
a5f0 f1			.pastdmark: pop af  
a5f1			endm  
# End of macro DMARK
a5f1					CALLMONITOR 
a5f1 cd 6f ee			call debug_vector  
a5f4				endm  
# End of macro CALLMONITOR
a5f4				endif 
a5f4			 
a5f4			.storebyteat:		 
a5f4				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a5f4 cd 9d 9e			call macro_dsp_valuehl 
a5f7				endm 
# End of macro FORTH_DSP_VALUEHL
a5f7				 
a5f7 e5				push hl 
a5f8			 
a5f8				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a5f8 cd 55 9f			call macro_forth_dsp_pop 
a5fb				endm 
# End of macro FORTH_DSP_POP
a5fb			 
a5fb				; get byte to poke 
a5fb			 
a5fb				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a5fb cd 9d 9e			call macro_dsp_valuehl 
a5fe				endm 
# End of macro FORTH_DSP_VALUEHL
a5fe e5				push hl 
a5ff			 
a5ff			 
a5ff				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a5ff cd 55 9f			call macro_forth_dsp_pop 
a602				endm 
# End of macro FORTH_DSP_POP
a602			 
a602			 
a602 d1				pop de 
a603 e1				pop hl 
a604			 
a604 73				ld (hl),e 
a605			 
a605			 
a605				NEXTW 
a605 c3 53 a0			jp macro_next 
a608				endm 
# End of macro NEXTW
a608			.CBANG: 
a608			CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
a608 22				db WORD_SYS_CORE+OPCODE_CBANG             
a609 31 a6			dw .SCALL            
a60b 03				db 2 + 1 
a60c .. 00			db "C!",0              
a60f				endm 
# End of macro CWHEAD
a60f			; | C!  ( x w -- ) Store x at address w  | DONE 
a60f				if DEBUG_FORTH_WORDS_KEY 
a60f					DMARK "CBA" 
a60f f5				push af  
a610 3a 24 a6			ld a, (.dmark)  
a613 32 6b ee			ld (debug_mark),a  
a616 3a 25 a6			ld a, (.dmark+1)  
a619 32 6c ee			ld (debug_mark+1),a  
a61c 3a 26 a6			ld a, (.dmark+2)  
a61f 32 6d ee			ld (debug_mark+2),a  
a622 18 03			jr .pastdmark  
a624 ..			.dmark: db "CBA"  
a627 f1			.pastdmark: pop af  
a628			endm  
# End of macro DMARK
a628					CALLMONITOR 
a628 cd 6f ee			call debug_vector  
a62b				endm  
# End of macro CALLMONITOR
a62b				endif 
a62b c3 f4 a5			jp .storebyteat 
a62e				NEXTW 
a62e c3 53 a0			jp macro_next 
a631				endm 
# End of macro NEXTW
a631			.SCALL: 
a631			CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
a631 23				db WORD_SYS_CORE+OPCODE_SCALL             
a632 65 a6			dw .DEPTH            
a634 05				db 4 + 1 
a635 .. 00			db "CALL",0              
a63a				endm 
# End of macro CWHEAD
a63a			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
a63a				if DEBUG_FORTH_WORDS_KEY 
a63a					DMARK "CLL" 
a63a f5				push af  
a63b 3a 4f a6			ld a, (.dmark)  
a63e 32 6b ee			ld (debug_mark),a  
a641 3a 50 a6			ld a, (.dmark+1)  
a644 32 6c ee			ld (debug_mark+1),a  
a647 3a 51 a6			ld a, (.dmark+2)  
a64a 32 6d ee			ld (debug_mark+2),a  
a64d 18 03			jr .pastdmark  
a64f ..			.dmark: db "CLL"  
a652 f1			.pastdmark: pop af  
a653			endm  
# End of macro DMARK
a653					CALLMONITOR 
a653 cd 6f ee			call debug_vector  
a656				endm  
# End of macro CALLMONITOR
a656				endif 
a656			 
a656				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a656 cd 9d 9e			call macro_dsp_valuehl 
a659				endm 
# End of macro FORTH_DSP_VALUEHL
a659			 
a659			;		push hl 
a659			 
a659				; destroy value TOS 
a659			 
a659				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a659 cd 55 9f			call macro_forth_dsp_pop 
a65c				endm 
# End of macro FORTH_DSP_POP
a65c			 
a65c					 
a65c			;		pop hl 
a65c			 
a65c				; how to do a call with hl???? save SP? 
a65c cd f7 9f			call forth_call_hl 
a65f			 
a65f			 
a65f				; TODO push value back onto stack for another op etc 
a65f			 
a65f cd a6 9c			call forth_push_numhl 
a662				NEXTW 
a662 c3 53 a0			jp macro_next 
a665				endm 
# End of macro NEXTW
a665			.DEPTH: 
a665			CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
a665 24				db WORD_SYS_CORE+OPCODE_DEPTH             
a666 a2 a6			dw .OVER            
a668 06				db 5 + 1 
a669 .. 00			db "DEPTH",0              
a66f				endm 
# End of macro CWHEAD
a66f			; | DEPTH ( -- u ) Push count of stack | DONE 
a66f				; take current TOS and remove from base value div by two to get count 
a66f				if DEBUG_FORTH_WORDS_KEY 
a66f					DMARK "DEP" 
a66f f5				push af  
a670 3a 84 a6			ld a, (.dmark)  
a673 32 6b ee			ld (debug_mark),a  
a676 3a 85 a6			ld a, (.dmark+1)  
a679 32 6c ee			ld (debug_mark+1),a  
a67c 3a 86 a6			ld a, (.dmark+2)  
a67f 32 6d ee			ld (debug_mark+2),a  
a682 18 03			jr .pastdmark  
a684 ..			.dmark: db "DEP"  
a687 f1			.pastdmark: pop af  
a688			endm  
# End of macro DMARK
a688					CALLMONITOR 
a688 cd 6f ee			call debug_vector  
a68b				endm  
# End of macro CALLMONITOR
a68b				endif 
a68b			 
a68b			 
a68b 2a ee e9		ld hl, (cli_data_sp) 
a68e 11 28 e8		ld de, cli_data_stack 
a691 ed 52		sbc hl,de 
a693			 
a693			; div by size of stack item 
a693			 
a693 5d			ld e,l 
a694 0e 03		ld c, 3 
a696 cd 6b 8c		call Div8 
a699			 
a699 6f			ld l,a 
a69a 26 00		ld h,0 
a69c			 
a69c			;srl h 
a69c			;rr l 
a69c			 
a69c cd a6 9c			call forth_push_numhl 
a69f				NEXTW 
a69f c3 53 a0			jp macro_next 
a6a2				endm 
# End of macro NEXTW
a6a2			.OVER: 
a6a2			CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
a6a2 42				db WORD_SYS_CORE+46             
a6a3 e9 a6			dw .PAUSE            
a6a5 05				db 4 + 1 
a6a6 .. 00			db "OVER",0              
a6ab				endm 
# End of macro CWHEAD
a6ab			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
a6ab				if DEBUG_FORTH_WORDS_KEY 
a6ab					DMARK "OVR" 
a6ab f5				push af  
a6ac 3a c0 a6			ld a, (.dmark)  
a6af 32 6b ee			ld (debug_mark),a  
a6b2 3a c1 a6			ld a, (.dmark+1)  
a6b5 32 6c ee			ld (debug_mark+1),a  
a6b8 3a c2 a6			ld a, (.dmark+2)  
a6bb 32 6d ee			ld (debug_mark+2),a  
a6be 18 03			jr .pastdmark  
a6c0 ..			.dmark: db "OVR"  
a6c3 f1			.pastdmark: pop af  
a6c4			endm  
# End of macro DMARK
a6c4					CALLMONITOR 
a6c4 cd 6f ee			call debug_vector  
a6c7				endm  
# End of macro CALLMONITOR
a6c7				endif 
a6c7			 
a6c7			; TODO Use os stack swap memory 
a6c7				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a6c7 cd 9d 9e			call macro_dsp_valuehl 
a6ca				endm 
# End of macro FORTH_DSP_VALUEHL
a6ca e5				push hl    ; n2 
a6cb				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a6cb cd 55 9f			call macro_forth_dsp_pop 
a6ce				endm 
# End of macro FORTH_DSP_POP
a6ce			 
a6ce				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a6ce cd 9d 9e			call macro_dsp_valuehl 
a6d1				endm 
# End of macro FORTH_DSP_VALUEHL
a6d1 e5				push hl    ; n1 
a6d2				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a6d2 cd 55 9f			call macro_forth_dsp_pop 
a6d5				endm 
# End of macro FORTH_DSP_POP
a6d5			 
a6d5 d1				pop de     ; n1 
a6d6 e1				pop hl     ; n2 
a6d7			 
a6d7 d5				push de 
a6d8 e5				push hl 
a6d9 d5				push de 
a6da			 
a6da				; push back  
a6da			 
a6da e1				pop hl 
a6db cd a6 9c			call forth_push_numhl 
a6de e1				pop hl 
a6df cd a6 9c			call forth_push_numhl 
a6e2 e1				pop hl 
a6e3 cd a6 9c			call forth_push_numhl 
a6e6				NEXTW 
a6e6 c3 53 a0			jp macro_next 
a6e9				endm 
# End of macro NEXTW
a6e9			 
a6e9			.PAUSE: 
a6e9			CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
a6e9 43				db WORD_SYS_CORE+47             
a6ea 1e a7			dw .PAUSES            
a6ec 08				db 7 + 1 
a6ed .. 00			db "PAUSEMS",0              
a6f5				endm 
# End of macro CWHEAD
a6f5			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
a6f5				if DEBUG_FORTH_WORDS_KEY 
a6f5					DMARK "PMS" 
a6f5 f5				push af  
a6f6 3a 0a a7			ld a, (.dmark)  
a6f9 32 6b ee			ld (debug_mark),a  
a6fc 3a 0b a7			ld a, (.dmark+1)  
a6ff 32 6c ee			ld (debug_mark+1),a  
a702 3a 0c a7			ld a, (.dmark+2)  
a705 32 6d ee			ld (debug_mark+2),a  
a708 18 03			jr .pastdmark  
a70a ..			.dmark: db "PMS"  
a70d f1			.pastdmark: pop af  
a70e			endm  
# End of macro DMARK
a70e					CALLMONITOR 
a70e cd 6f ee			call debug_vector  
a711				endm  
# End of macro CALLMONITOR
a711				endif 
a711				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a711 cd 9d 9e			call macro_dsp_valuehl 
a714				endm 
# End of macro FORTH_DSP_VALUEHL
a714			;		push hl    ; n2 
a714				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a714 cd 55 9f			call macro_forth_dsp_pop 
a717				endm 
# End of macro FORTH_DSP_POP
a717			;		pop hl 
a717			 
a717 7d				ld a, l 
a718 cd d6 89			call aDelayInMS 
a71b			       NEXTW 
a71b c3 53 a0			jp macro_next 
a71e				endm 
# End of macro NEXTW
a71e			.PAUSES:  
a71e			CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
a71e 44				db WORD_SYS_CORE+48             
a71f 8d a7			dw .ROT            
a721 06				db 5 + 1 
a722 .. 00			db "PAUSE",0              
a728				endm 
# End of macro CWHEAD
a728			; | PAUSE ( n -- )  Pause for n seconds | DONE 
a728				if DEBUG_FORTH_WORDS_KEY 
a728					DMARK "PAU" 
a728 f5				push af  
a729 3a 3d a7			ld a, (.dmark)  
a72c 32 6b ee			ld (debug_mark),a  
a72f 3a 3e a7			ld a, (.dmark+1)  
a732 32 6c ee			ld (debug_mark+1),a  
a735 3a 3f a7			ld a, (.dmark+2)  
a738 32 6d ee			ld (debug_mark+2),a  
a73b 18 03			jr .pastdmark  
a73d ..			.dmark: db "PAU"  
a740 f1			.pastdmark: pop af  
a741			endm  
# End of macro DMARK
a741					CALLMONITOR 
a741 cd 6f ee			call debug_vector  
a744				endm  
# End of macro CALLMONITOR
a744				endif 
a744				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a744 cd 9d 9e			call macro_dsp_valuehl 
a747				endm 
# End of macro FORTH_DSP_VALUEHL
a747			;		push hl    ; n2 
a747				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a747 cd 55 9f			call macro_forth_dsp_pop 
a74a				endm 
# End of macro FORTH_DSP_POP
a74a			;		pop hl 
a74a 45				ld b, l 
a74b				if DEBUG_FORTH_WORDS 
a74b					DMARK "PAU" 
a74b f5				push af  
a74c 3a 60 a7			ld a, (.dmark)  
a74f 32 6b ee			ld (debug_mark),a  
a752 3a 61 a7			ld a, (.dmark+1)  
a755 32 6c ee			ld (debug_mark+1),a  
a758 3a 62 a7			ld a, (.dmark+2)  
a75b 32 6d ee			ld (debug_mark+2),a  
a75e 18 03			jr .pastdmark  
a760 ..			.dmark: db "PAU"  
a763 f1			.pastdmark: pop af  
a764			endm  
# End of macro DMARK
a764					CALLMONITOR 
a764 cd 6f ee			call debug_vector  
a767				endm  
# End of macro CALLMONITOR
a767				endif 
a767 c5			.pauses1:	push bc 
a768 cd f1 89			call delay1s 
a76b c1				pop bc 
a76c				if DEBUG_FORTH_WORDS 
a76c					DMARK "PA1" 
a76c f5				push af  
a76d 3a 81 a7			ld a, (.dmark)  
a770 32 6b ee			ld (debug_mark),a  
a773 3a 82 a7			ld a, (.dmark+1)  
a776 32 6c ee			ld (debug_mark+1),a  
a779 3a 83 a7			ld a, (.dmark+2)  
a77c 32 6d ee			ld (debug_mark+2),a  
a77f 18 03			jr .pastdmark  
a781 ..			.dmark: db "PA1"  
a784 f1			.pastdmark: pop af  
a785			endm  
# End of macro DMARK
a785					CALLMONITOR 
a785 cd 6f ee			call debug_vector  
a788				endm  
# End of macro CALLMONITOR
a788				endif 
a788 10 dd			djnz .pauses1 
a78a			 
a78a			       NEXTW 
a78a c3 53 a0			jp macro_next 
a78d				endm 
# End of macro NEXTW
a78d			.ROT: 
a78d			CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
a78d 45				db WORD_SYS_CORE+49             
a78e db a7			dw .UWORDS            
a790 04				db 3 + 1 
a791 .. 00			db "ROT",0              
a795				endm 
# End of macro CWHEAD
a795			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
a795				if DEBUG_FORTH_WORDS_KEY 
a795					DMARK "ROT" 
a795 f5				push af  
a796 3a aa a7			ld a, (.dmark)  
a799 32 6b ee			ld (debug_mark),a  
a79c 3a ab a7			ld a, (.dmark+1)  
a79f 32 6c ee			ld (debug_mark+1),a  
a7a2 3a ac a7			ld a, (.dmark+2)  
a7a5 32 6d ee			ld (debug_mark+2),a  
a7a8 18 03			jr .pastdmark  
a7aa ..			.dmark: db "ROT"  
a7ad f1			.pastdmark: pop af  
a7ae			endm  
# End of macro DMARK
a7ae					CALLMONITOR 
a7ae cd 6f ee			call debug_vector  
a7b1				endm  
# End of macro CALLMONITOR
a7b1				endif 
a7b1			 
a7b1			; TODO Use os stack swap memory 
a7b1				FORTH_DSP_VALUEHL 
a7b1 cd 9d 9e			call macro_dsp_valuehl 
a7b4				endm 
# End of macro FORTH_DSP_VALUEHL
a7b4 e5				push hl    ; u3  
a7b5			 
a7b5				FORTH_DSP_POP 
a7b5 cd 55 9f			call macro_forth_dsp_pop 
a7b8				endm 
# End of macro FORTH_DSP_POP
a7b8			 
a7b8				FORTH_DSP_VALUEHL 
a7b8 cd 9d 9e			call macro_dsp_valuehl 
a7bb				endm 
# End of macro FORTH_DSP_VALUEHL
a7bb e5				push hl     ; u2 
a7bc			 
a7bc				FORTH_DSP_POP 
a7bc cd 55 9f			call macro_forth_dsp_pop 
a7bf				endm 
# End of macro FORTH_DSP_POP
a7bf			 
a7bf				FORTH_DSP_VALUEHL 
a7bf cd 9d 9e			call macro_dsp_valuehl 
a7c2				endm 
# End of macro FORTH_DSP_VALUEHL
a7c2 e5				push hl     ; u1 
a7c3			 
a7c3				FORTH_DSP_POP 
a7c3 cd 55 9f			call macro_forth_dsp_pop 
a7c6				endm 
# End of macro FORTH_DSP_POP
a7c6			 
a7c6 c1				pop bc      ; u1 
a7c7 e1				pop hl      ; u2 
a7c8 d1				pop de      ; u3 
a7c9			 
a7c9			 
a7c9 c5				push bc 
a7ca d5				push de 
a7cb e5				push hl 
a7cc			 
a7cc			 
a7cc e1				pop hl 
a7cd cd a6 9c			call forth_push_numhl 
a7d0			 
a7d0 e1				pop hl 
a7d1 cd a6 9c			call forth_push_numhl 
a7d4			 
a7d4 e1				pop hl 
a7d5 cd a6 9c			call forth_push_numhl 
a7d8				 
a7d8			 
a7d8			 
a7d8			 
a7d8			 
a7d8			 
a7d8			       NEXTW 
a7d8 c3 53 a0			jp macro_next 
a7db				endm 
# End of macro NEXTW
a7db			 
a7db			.UWORDS: 
a7db			CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
a7db 50				db WORD_SYS_CORE+60             
a7dc 9d a8			dw .BP            
a7de 07				db 6 + 1 
a7df .. 00			db "UWORDS",0              
a7e6				endm 
# End of macro CWHEAD
a7e6			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
a7e6			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
a7e6			; | | Following the count are the individual words. 
a7e6			; | | 
a7e6			; | | e.g. UWORDS 
a7e6			; | | BOX DIRLIST 2 
a7e6			; | |  
a7e6			; | | Can be used to save the words to storage via: 
a7e6			; | | UWORDS $01 DO $01 APPEND LOOP 
a7e6			if DEBUG_FORTH_WORDS_KEY 
a7e6				DMARK "UWR" 
a7e6 f5				push af  
a7e7 3a fb a7			ld a, (.dmark)  
a7ea 32 6b ee			ld (debug_mark),a  
a7ed 3a fc a7			ld a, (.dmark+1)  
a7f0 32 6c ee			ld (debug_mark+1),a  
a7f3 3a fd a7			ld a, (.dmark+2)  
a7f6 32 6d ee			ld (debug_mark+2),a  
a7f9 18 03			jr .pastdmark  
a7fb ..			.dmark: db "UWR"  
a7fe f1			.pastdmark: pop af  
a7ff			endm  
# End of macro DMARK
a7ff				CALLMONITOR 
a7ff cd 6f ee			call debug_vector  
a802				endm  
# End of macro CALLMONITOR
a802			endif 
a802 21 43 e6			ld hl, baseram 
a805				;ld hl, baseusermem 
a805 01 00 00			ld bc, 0    ; start a counter 
a808			 
a808			; skip dict stub 
a808			 
a808 cd a4 a1			call forth_tok_next 
a80b			 
a80b			 
a80b			; while we have words to look for 
a80b			 
a80b 7e			.douscan:	ld a, (hl)      
a80c			if DEBUG_FORTH_WORDS 
a80c				DMARK "UWs" 
a80c f5				push af  
a80d 3a 21 a8			ld a, (.dmark)  
a810 32 6b ee			ld (debug_mark),a  
a813 3a 22 a8			ld a, (.dmark+1)  
a816 32 6c ee			ld (debug_mark+1),a  
a819 3a 23 a8			ld a, (.dmark+2)  
a81c 32 6d ee			ld (debug_mark+2),a  
a81f 18 03			jr .pastdmark  
a821 ..			.dmark: db "UWs"  
a824 f1			.pastdmark: pop af  
a825			endm  
# End of macro DMARK
a825				CALLMONITOR 
a825 cd 6f ee			call debug_vector  
a828				endm  
# End of macro CALLMONITOR
a828			endif 
a828 fe 00			cp WORD_SYS_END 
a82a 28 4d			jr z, .udone 
a82c fe 01			cp WORD_SYS_UWORD 
a82e 20 44			jr nz, .nuword 
a830			 
a830			if DEBUG_FORTH_WORDS 
a830				DMARK "UWu" 
a830 f5				push af  
a831 3a 45 a8			ld a, (.dmark)  
a834 32 6b ee			ld (debug_mark),a  
a837 3a 46 a8			ld a, (.dmark+1)  
a83a 32 6c ee			ld (debug_mark+1),a  
a83d 3a 47 a8			ld a, (.dmark+2)  
a840 32 6d ee			ld (debug_mark+2),a  
a843 18 03			jr .pastdmark  
a845 ..			.dmark: db "UWu"  
a848 f1			.pastdmark: pop af  
a849			endm  
# End of macro DMARK
a849				CALLMONITOR 
a849 cd 6f ee			call debug_vector  
a84c				endm  
# End of macro CALLMONITOR
a84c			endif 
a84c				; we have a uword so push its name to the stack 
a84c			 
a84c e5				push hl  ; save so we can move to next dict block 
a84d			 
a84d				; skip opcode 
a84d 23				inc hl  
a84e				; skip next ptr 
a84e 23				inc hl  
a84f 23				inc hl 
a850				; skip len 
a850 23				inc hl 
a851			if DEBUG_FORTH_WORDS 
a851				DMARK "UWt" 
a851 f5				push af  
a852 3a 66 a8			ld a, (.dmark)  
a855 32 6b ee			ld (debug_mark),a  
a858 3a 67 a8			ld a, (.dmark+1)  
a85b 32 6c ee			ld (debug_mark+1),a  
a85e 3a 68 a8			ld a, (.dmark+2)  
a861 32 6d ee			ld (debug_mark+2),a  
a864 18 03			jr .pastdmark  
a866 ..			.dmark: db "UWt"  
a869 f1			.pastdmark: pop af  
a86a			endm  
# End of macro DMARK
a86a				CALLMONITOR 
a86a cd 6f ee			call debug_vector  
a86d				endm  
# End of macro CALLMONITOR
a86d			endif 
a86d 03				inc bc 
a86e			 
a86e c5				push bc 
a86f cd 14 9d			call forth_push_str 
a872 c1				pop bc 
a873			 
a873 e1				pop hl 	 
a874			 
a874 cd a4 a1		.nuword:	call forth_tok_next 
a877 18 92			jr .douscan  
a879			 
a879			.udone:		 ; push count of uwords found 
a879 c5				push bc 
a87a e1				pop hl 
a87b			 
a87b			if DEBUG_FORTH_WORDS 
a87b				DMARK "UWc" 
a87b f5				push af  
a87c 3a 90 a8			ld a, (.dmark)  
a87f 32 6b ee			ld (debug_mark),a  
a882 3a 91 a8			ld a, (.dmark+1)  
a885 32 6c ee			ld (debug_mark+1),a  
a888 3a 92 a8			ld a, (.dmark+2)  
a88b 32 6d ee			ld (debug_mark+2),a  
a88e 18 03			jr .pastdmark  
a890 ..			.dmark: db "UWc"  
a893 f1			.pastdmark: pop af  
a894			endm  
# End of macro DMARK
a894				CALLMONITOR 
a894 cd 6f ee			call debug_vector  
a897				endm  
# End of macro CALLMONITOR
a897			endif 
a897 cd a6 9c			call forth_push_numhl 
a89a			 
a89a			 
a89a			       NEXTW 
a89a c3 53 a0			jp macro_next 
a89d				endm 
# End of macro NEXTW
a89d			 
a89d			.BP: 
a89d			CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
a89d 54				db WORD_SYS_CORE+64             
a89e d7 a8			dw .MONITOR            
a8a0 03				db 2 + 1 
a8a1 .. 00			db "BP",0              
a8a4				endm 
# End of macro CWHEAD
a8a4			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
a8a4			; | | $00 Will enable the break points within specific code paths 
a8a4			; | | $01 Will disable break points 
a8a4			; | |  
a8a4			; | | By default break points are off. Either the above can be used to enable them 
a8a4			; | | or if a key is held down during start up the spashscreen will appear to freeze 
a8a4			; | | and on release of the pressed key the CONFIG menu will be displayed where you 
a8a4			; | | can disable break points. Exiting will then continue boot process. 
a8a4				; get byte count 
a8a4				if DEBUG_FORTH_WORDS_KEY 
a8a4					DMARK "BP." 
a8a4 f5				push af  
a8a5 3a b9 a8			ld a, (.dmark)  
a8a8 32 6b ee			ld (debug_mark),a  
a8ab 3a ba a8			ld a, (.dmark+1)  
a8ae 32 6c ee			ld (debug_mark+1),a  
a8b1 3a bb a8			ld a, (.dmark+2)  
a8b4 32 6d ee			ld (debug_mark+2),a  
a8b7 18 03			jr .pastdmark  
a8b9 ..			.dmark: db "BP."  
a8bc f1			.pastdmark: pop af  
a8bd			endm  
# End of macro DMARK
a8bd					CALLMONITOR 
a8bd cd 6f ee			call debug_vector  
a8c0				endm  
# End of macro CALLMONITOR
a8c0				endif 
a8c0			 
a8c0				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a8c0 cd 9d 9e			call macro_dsp_valuehl 
a8c3				endm 
# End of macro FORTH_DSP_VALUEHL
a8c3			 
a8c3			;		push hl 
a8c3			 
a8c3				; destroy value TOS 
a8c3			 
a8c3				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a8c3 cd 55 9f			call macro_forth_dsp_pop 
a8c6				endm 
# End of macro FORTH_DSP_POP
a8c6			 
a8c6			;		pop hl 
a8c6			 
a8c6 3e 00			ld a,0 
a8c8 bd				cp l 
a8c9 28 06			jr z, .bpset 
a8cb			;		ld a, '*' 
a8cb cd 48 96			call bp_off 
a8ce				NEXTW 
a8ce c3 53 a0			jp macro_next 
a8d1				endm 
# End of macro NEXTW
a8d1			 
a8d1			.bpset:	 
a8d1				;	ld (os_view_disable), a 
a8d1 cd 3c 96			call bp_on 
a8d4			 
a8d4			 
a8d4				NEXTW 
a8d4 c3 53 a0			jp macro_next 
a8d7				endm 
# End of macro NEXTW
a8d7			 
a8d7			 
a8d7			.MONITOR: 
a8d7			CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
a8d7 55				db WORD_SYS_CORE+65             
a8d8 08 a9			dw .MALLOC            
a8da 08				db 7 + 1 
a8db .. 00			db "MONITOR",0              
a8e3				endm 
# End of macro CWHEAD
a8e3			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
a8e3			; | | At start the current various registers will be displayed with contents. 
a8e3			; | | Top right corner will show the most recent debug marker seen. 
a8e3			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
a8e3			; | | and the return stack pointer (RSP). 
a8e3			; | | Pressing: 
a8e3			; | |    1 - Initial screen 
a8e3			; | |    2 - Display a data dump of HL 
a8e3			; | |    3 - Display a data dump of DE 
a8e3			; | |    4 - Display a data dump of BC 
a8e3			; | |    5 - Display a data dump of HL 
a8e3			; | |    6 - Display a data dump of DSP 
a8e3			; | |    7 - Display a data dump of RSP 
a8e3			; | |    8 - Display a data dump of what is at DSP 
a8e3			; | |    9 - Display a data dump of what is at RSP 
a8e3			; | |    0 - Exit monitor and continue running. This will also enable break points 
a8e3			; | |    * - Disable break points 
a8e3			; | |    # - Enter traditional monitor mode 
a8e3			; | | 
a8e3			; | | Monitor Mode 
a8e3			; | | ------------ 
a8e3			; | | A prompt of '>' will be shown for various commands: 
a8e3			; | |    D xxxx - Display a data dump starting from hex address xxxx 
a8e3			; | |    C - Continue display a data dump from the last set address 
a8e3			; | |    M xxxx - Set start of memory edit at address xx 
a8e3			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
a8e3			; | |    G xxxx - Exec code at specific address 
a8e3			; | |    Q - Return to previous 
a8e3				if DEBUG_FORTH_WORDS_KEY 
a8e3					DMARK "MON" 
a8e3 f5				push af  
a8e4 3a f8 a8			ld a, (.dmark)  
a8e7 32 6b ee			ld (debug_mark),a  
a8ea 3a f9 a8			ld a, (.dmark+1)  
a8ed 32 6c ee			ld (debug_mark+1),a  
a8f0 3a fa a8			ld a, (.dmark+2)  
a8f3 32 6d ee			ld (debug_mark+2),a  
a8f6 18 03			jr .pastdmark  
a8f8 ..			.dmark: db "MON"  
a8fb f1			.pastdmark: pop af  
a8fc			endm  
# End of macro DMARK
a8fc					CALLMONITOR 
a8fc cd 6f ee			call debug_vector  
a8ff				endm  
# End of macro CALLMONITOR
a8ff				endif 
a8ff			;		ld a, 0 
a8ff			;		ld (os_view_disable), a 
a8ff cd 3c 96			call bp_on 
a902			 
a902				CALLMONITOR 
a902 cd 6f ee			call debug_vector  
a905				endm  
# End of macro CALLMONITOR
a905			 
a905			;	call monitor 
a905			 
a905				NEXTW 
a905 c3 53 a0			jp macro_next 
a908				endm 
# End of macro NEXTW
a908			 
a908			 
a908			.MALLOC: 
a908			CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
a908 56				db WORD_SYS_CORE+66             
a909 31 a9			dw .MALLOC2            
a90b 06				db 5 + 1 
a90c .. 00			db "ALLOT",0              
a912				endm 
# End of macro CWHEAD
a912			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a912				if DEBUG_FORTH_WORDS_KEY 
a912					DMARK "ALL" 
a912 f5				push af  
a913 3a 27 a9			ld a, (.dmark)  
a916 32 6b ee			ld (debug_mark),a  
a919 3a 28 a9			ld a, (.dmark+1)  
a91c 32 6c ee			ld (debug_mark+1),a  
a91f 3a 29 a9			ld a, (.dmark+2)  
a922 32 6d ee			ld (debug_mark+2),a  
a925 18 03			jr .pastdmark  
a927 ..			.dmark: db "ALL"  
a92a f1			.pastdmark: pop af  
a92b			endm  
# End of macro DMARK
a92b					CALLMONITOR 
a92b cd 6f ee			call debug_vector  
a92e				endm  
# End of macro CALLMONITOR
a92e				endif 
a92e c3 58 a9			jp .mallocc 
a931			.MALLOC2: 
a931			CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
a931 56				db WORD_SYS_CORE+66             
a932 6f a9			dw .FREE            
a934 07				db 6 + 1 
a935 .. 00			db "MALLOC",0              
a93c				endm 
# End of macro CWHEAD
a93c			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a93c				; get byte count 
a93c				if DEBUG_FORTH_WORDS_KEY 
a93c					DMARK "MAL" 
a93c f5				push af  
a93d 3a 51 a9			ld a, (.dmark)  
a940 32 6b ee			ld (debug_mark),a  
a943 3a 52 a9			ld a, (.dmark+1)  
a946 32 6c ee			ld (debug_mark+1),a  
a949 3a 53 a9			ld a, (.dmark+2)  
a94c 32 6d ee			ld (debug_mark+2),a  
a94f 18 03			jr .pastdmark  
a951 ..			.dmark: db "MAL"  
a954 f1			.pastdmark: pop af  
a955			endm  
# End of macro DMARK
a955					CALLMONITOR 
a955 cd 6f ee			call debug_vector  
a958				endm  
# End of macro CALLMONITOR
a958				endif 
a958			.mallocc: 
a958				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a958 cd 9d 9e			call macro_dsp_valuehl 
a95b				endm 
# End of macro FORTH_DSP_VALUEHL
a95b			 
a95b			;		push hl 
a95b			 
a95b				; destroy value TOS 
a95b			 
a95b				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a95b cd 55 9f			call macro_forth_dsp_pop 
a95e				endm 
# End of macro FORTH_DSP_POP
a95e			 
a95e			;		pop hl 
a95e cd 0d 93			call malloc 
a961			if DEBUG_FORTH_MALLOC_GUARD 
a961 f5				push af 
a962 cd 04 8d			call ishlzero 
a965			;		ld a, l 
a965			;		add h 
a965			;		cp 0 
a965 f1				pop af 
a966				 
a966 cc 13 ce			call z,malloc_error 
a969			endif 
a969			 
a969 cd a6 9c			call forth_push_numhl 
a96c				NEXTW 
a96c c3 53 a0			jp macro_next 
a96f				endm 
# End of macro NEXTW
a96f			 
a96f			.FREE: 
a96f			CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
a96f 57				db WORD_SYS_CORE+67             
a970 a0 a9			dw .LIST            
a972 05				db 4 + 1 
a973 .. 00			db "FREE",0              
a978				endm 
# End of macro CWHEAD
a978			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
a978				if DEBUG_FORTH_WORDS_KEY 
a978					DMARK "FRE" 
a978 f5				push af  
a979 3a 8d a9			ld a, (.dmark)  
a97c 32 6b ee			ld (debug_mark),a  
a97f 3a 8e a9			ld a, (.dmark+1)  
a982 32 6c ee			ld (debug_mark+1),a  
a985 3a 8f a9			ld a, (.dmark+2)  
a988 32 6d ee			ld (debug_mark+2),a  
a98b 18 03			jr .pastdmark  
a98d ..			.dmark: db "FRE"  
a990 f1			.pastdmark: pop af  
a991			endm  
# End of macro DMARK
a991					CALLMONITOR 
a991 cd 6f ee			call debug_vector  
a994				endm  
# End of macro CALLMONITOR
a994				endif 
a994				; get address 
a994			 
a994				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a994 cd 9d 9e			call macro_dsp_valuehl 
a997				endm 
# End of macro FORTH_DSP_VALUEHL
a997			 
a997			;		push hl 
a997			 
a997				; destroy value TOS 
a997			 
a997				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a997 cd 55 9f			call macro_forth_dsp_pop 
a99a				endm 
# End of macro FORTH_DSP_POP
a99a			 
a99a			;		pop hl 
a99a			if FORTH_ENABLE_MALLOCFREE 
a99a cd d7 93			call free 
a99d			endif 
a99d				NEXTW 
a99d c3 53 a0			jp macro_next 
a9a0				endm 
# End of macro NEXTW
a9a0			.LIST: 
a9a0			CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
a9a0 5c				db WORD_SYS_CORE+72             
a9a1 90 ab			dw .FORGET            
a9a3 05				db 4 + 1 
a9a4 .. 00			db "LIST",0              
a9a9				endm 
# End of macro CWHEAD
a9a9			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
a9a9			; | | The quoted word must be in upper case. 
a9a9			if DEBUG_FORTH_WORDS_KEY 
a9a9				DMARK "LST" 
a9a9 f5				push af  
a9aa 3a be a9			ld a, (.dmark)  
a9ad 32 6b ee			ld (debug_mark),a  
a9b0 3a bf a9			ld a, (.dmark+1)  
a9b3 32 6c ee			ld (debug_mark+1),a  
a9b6 3a c0 a9			ld a, (.dmark+2)  
a9b9 32 6d ee			ld (debug_mark+2),a  
a9bc 18 03			jr .pastdmark  
a9be ..			.dmark: db "LST"  
a9c1 f1			.pastdmark: pop af  
a9c2			endm  
# End of macro DMARK
a9c2				CALLMONITOR 
a9c2 cd 6f ee			call debug_vector  
a9c5				endm  
# End of macro CALLMONITOR
a9c5			endif 
a9c5			 
a9c5				FORTH_DSP_VALUEHL 
a9c5 cd 9d 9e			call macro_dsp_valuehl 
a9c8				endm 
# End of macro FORTH_DSP_VALUEHL
a9c8			 
a9c8 e5				push hl 
a9c9				FORTH_DSP_POP 
a9c9 cd 55 9f			call macro_forth_dsp_pop 
a9cc				endm 
# End of macro FORTH_DSP_POP
a9cc c1				pop bc 
a9cd			 
a9cd			; Start format of scratch string 
a9cd			 
a9cd 21 c1 e2			ld hl, scratch 
a9d0			 
a9d0 3e 3a			ld a, ':' 
a9d2 77				ld (hl),a 
a9d3 23				inc hl 
a9d4 3e 20			ld a, ' ' 
a9d6 77				ld (hl), a 
a9d7			 
a9d7				; Get ptr to the word we need to look up 
a9d7			 
a9d7			;		FORTH_DSP_VALUEHL 
a9d7				;v5 FORTH_DSP_VALUE 
a9d7			; TODO type check 
a9d7			;		inc hl    ; Skip type check  
a9d7			;		push hl 
a9d7			;		ex de, hl    ; put into DE 
a9d7			 
a9d7			 
a9d7 21 43 e6			ld hl, baseram 
a9da				;ld hl, baseusermem 
a9da			 
a9da e5			push hl   ; sacreifical push 
a9db			 
a9db			.ldouscanm: 
a9db e1			pop hl 
a9dc			.ldouscan: 
a9dc			if DEBUG_FORTH_WORDS 
a9dc				DMARK "LSs" 
a9dc f5				push af  
a9dd 3a f1 a9			ld a, (.dmark)  
a9e0 32 6b ee			ld (debug_mark),a  
a9e3 3a f2 a9			ld a, (.dmark+1)  
a9e6 32 6c ee			ld (debug_mark+1),a  
a9e9 3a f3 a9			ld a, (.dmark+2)  
a9ec 32 6d ee			ld (debug_mark+2),a  
a9ef 18 03			jr .pastdmark  
a9f1 ..			.dmark: db "LSs"  
a9f4 f1			.pastdmark: pop af  
a9f5			endm  
# End of macro DMARK
a9f5				CALLMONITOR 
a9f5 cd 6f ee			call debug_vector  
a9f8				endm  
# End of macro CALLMONITOR
a9f8			endif 
a9f8			; skip dict stub 
a9f8 cd a4 a1			call forth_tok_next 
a9fb			 
a9fb			 
a9fb			; while we have words to look for 
a9fb			 
a9fb 7e			ld a, (hl)      
a9fc			if DEBUG_FORTH_WORDS 
a9fc				DMARK "LSk" 
a9fc f5				push af  
a9fd 3a 11 aa			ld a, (.dmark)  
aa00 32 6b ee			ld (debug_mark),a  
aa03 3a 12 aa			ld a, (.dmark+1)  
aa06 32 6c ee			ld (debug_mark+1),a  
aa09 3a 13 aa			ld a, (.dmark+2)  
aa0c 32 6d ee			ld (debug_mark+2),a  
aa0f 18 03			jr .pastdmark  
aa11 ..			.dmark: db "LSk"  
aa14 f1			.pastdmark: pop af  
aa15			endm  
# End of macro DMARK
aa15				CALLMONITOR 
aa15 cd 6f ee			call debug_vector  
aa18				endm  
# End of macro CALLMONITOR
aa18			endif 
aa18				;cp WORD_SYS_END 
aa18				;jp z, .lunotfound 
aa18			 
aa18					; if we hit non uwords then gone too far 
aa18 fe 01				cp WORD_SYS_UWORD 
aa1a c2 4c ab				jp nz, .lunotfound 
aa1d			 
aa1d				if DEBUG_FORTH_WORDS 
aa1d					DMARK "LSu" 
aa1d f5				push af  
aa1e 3a 32 aa			ld a, (.dmark)  
aa21 32 6b ee			ld (debug_mark),a  
aa24 3a 33 aa			ld a, (.dmark+1)  
aa27 32 6c ee			ld (debug_mark+1),a  
aa2a 3a 34 aa			ld a, (.dmark+2)  
aa2d 32 6d ee			ld (debug_mark+2),a  
aa30 18 03			jr .pastdmark  
aa32 ..			.dmark: db "LSu"  
aa35 f1			.pastdmark: pop af  
aa36			endm  
# End of macro DMARK
aa36					CALLMONITOR 
aa36 cd 6f ee			call debug_vector  
aa39				endm  
# End of macro CALLMONITOR
aa39				endif 
aa39			 
aa39					; found a uword but is it the one we want... 
aa39			 
aa39 c5					push bc     ; uword to find is on bc 
aa3a d1					pop de 
aa3b			 
aa3b e5					push hl  ; to save the ptr 
aa3c			 
aa3c					; skip opcode 
aa3c 23					inc hl  
aa3d					; skip next ptr 
aa3d 23					inc hl  
aa3e 23					inc hl 
aa3f					; skip len 
aa3f 23					inc hl 
aa40			 
aa40				if DEBUG_FORTH_WORDS 
aa40					DMARK "LSc" 
aa40 f5				push af  
aa41 3a 55 aa			ld a, (.dmark)  
aa44 32 6b ee			ld (debug_mark),a  
aa47 3a 56 aa			ld a, (.dmark+1)  
aa4a 32 6c ee			ld (debug_mark+1),a  
aa4d 3a 57 aa			ld a, (.dmark+2)  
aa50 32 6d ee			ld (debug_mark+2),a  
aa53 18 03			jr .pastdmark  
aa55 ..			.dmark: db "LSc"  
aa58 f1			.pastdmark: pop af  
aa59			endm  
# End of macro DMARK
aa59					CALLMONITOR 
aa59 cd 6f ee			call debug_vector  
aa5c				endm  
# End of macro CALLMONITOR
aa5c				endif 
aa5c			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
aa5c			; ie. If WOO is defined first and then WO. Couldnt list WO. 
aa5c			; Nope that has gone the other way. It needs to be exact not on first zero 
aa5c			;		call strcmp 
aa5c c5					push bc 
aa5d cd dd 92				call StrictStrCmp 
aa60 c1					pop bc 
aa61 c2 db a9				jp nz, .ldouscanm 
aa64				 
aa64			 
aa64			 
aa64					; we have a uword so push its name to the stack 
aa64			 
aa64			;	   	push hl  ; save so we can move to next dict block 
aa64 e1			pop hl 
aa65			 
aa65				if DEBUG_FORTH_WORDS 
aa65					DMARK "LSm" 
aa65 f5				push af  
aa66 3a 7a aa			ld a, (.dmark)  
aa69 32 6b ee			ld (debug_mark),a  
aa6c 3a 7b aa			ld a, (.dmark+1)  
aa6f 32 6c ee			ld (debug_mark+1),a  
aa72 3a 7c aa			ld a, (.dmark+2)  
aa75 32 6d ee			ld (debug_mark+2),a  
aa78 18 03			jr .pastdmark  
aa7a ..			.dmark: db "LSm"  
aa7d f1			.pastdmark: pop af  
aa7e			endm  
# End of macro DMARK
aa7e					CALLMONITOR 
aa7e cd 6f ee			call debug_vector  
aa81				endm  
# End of macro CALLMONITOR
aa81				endif 
aa81			 
aa81					; skip opcode 
aa81 23					inc hl  
aa82					; skip next ptr 
aa82 23					inc hl  
aa83 23					inc hl 
aa84					; skip len 
aa84 7e					ld a, (hl)   ; save length to add 
aa85				if DEBUG_FORTH_WORDS 
aa85					DMARK "LS2" 
aa85 f5				push af  
aa86 3a 9a aa			ld a, (.dmark)  
aa89 32 6b ee			ld (debug_mark),a  
aa8c 3a 9b aa			ld a, (.dmark+1)  
aa8f 32 6c ee			ld (debug_mark+1),a  
aa92 3a 9c aa			ld a, (.dmark+2)  
aa95 32 6d ee			ld (debug_mark+2),a  
aa98 18 03			jr .pastdmark  
aa9a ..			.dmark: db "LS2"  
aa9d f1			.pastdmark: pop af  
aa9e			endm  
# End of macro DMARK
aa9e					CALLMONITOR 
aa9e cd 6f ee			call debug_vector  
aaa1				endm  
# End of macro CALLMONITOR
aaa1				endif 
aaa1			 
aaa1					; save this location 
aaa1				 
aaa1 e5					push hl 
aaa2			 
aaa2 23					inc hl 
aaa3 11 c3 e2				ld de, scratch+2 
aaa6 4f					ld c, a 
aaa7 06 00				ld b, 0 
aaa9			 
aaa9				if DEBUG_FORTH_WORDS 
aaa9					DMARK "LSn" 
aaa9 f5				push af  
aaaa 3a be aa			ld a, (.dmark)  
aaad 32 6b ee			ld (debug_mark),a  
aab0 3a bf aa			ld a, (.dmark+1)  
aab3 32 6c ee			ld (debug_mark+1),a  
aab6 3a c0 aa			ld a, (.dmark+2)  
aab9 32 6d ee			ld (debug_mark+2),a  
aabc 18 03			jr .pastdmark  
aabe ..			.dmark: db "LSn"  
aac1 f1			.pastdmark: pop af  
aac2			endm  
# End of macro DMARK
aac2					CALLMONITOR 
aac2 cd 6f ee			call debug_vector  
aac5				endm  
# End of macro CALLMONITOR
aac5				endif 
aac5			 
aac5					; copy uword name to scratch 
aac5			 
aac5 ed b0				ldir 
aac7			 
aac7 1b					dec de 
aac8 3e 20				ld a, ' '    ; change null to space 
aaca 12					ld (de), a 
aacb			 
aacb 13					inc de 
aacc			 
aacc d5					push de 
aacd c1					pop bc     ; move scratch pointer to end of word name and save it 
aace			 
aace e1					pop hl 
aacf 7e					ld a, (hl) 
aad0					;inc hl 
aad0					; skip word string 
aad0 cd db 8c				call addatohl 
aad3			 
aad3 23					inc hl 
aad4			 
aad4				if DEBUG_FORTH_WORDS 
aad4					DMARK "LS3" 
aad4 f5				push af  
aad5 3a e9 aa			ld a, (.dmark)  
aad8 32 6b ee			ld (debug_mark),a  
aadb 3a ea aa			ld a, (.dmark+1)  
aade 32 6c ee			ld (debug_mark+1),a  
aae1 3a eb aa			ld a, (.dmark+2)  
aae4 32 6d ee			ld (debug_mark+2),a  
aae7 18 03			jr .pastdmark  
aae9 ..			.dmark: db "LS3"  
aaec f1			.pastdmark: pop af  
aaed			endm  
# End of macro DMARK
aaed					CALLMONITOR 
aaed cd 6f ee			call debug_vector  
aaf0				endm  
# End of macro CALLMONITOR
aaf0				endif 
aaf0					; should now be at the start of the machine code to setup the eval of the uword 
aaf0					; now locate the ptr to the string defintion 
aaf0			 
aaf0					; skip ld hl, 
aaf0					; then load the ptr 
aaf0			; TODO use get from hl ptr 
aaf0 23					inc hl 
aaf1 5e					ld e, (hl) 
aaf2 23					inc hl 
aaf3 56					ld d, (hl) 
aaf4 eb					ex de, hl 
aaf5			 
aaf5			 
aaf5				if DEBUG_FORTH_WORDS 
aaf5					DMARK "LSt" 
aaf5 f5				push af  
aaf6 3a 0a ab			ld a, (.dmark)  
aaf9 32 6b ee			ld (debug_mark),a  
aafc 3a 0b ab			ld a, (.dmark+1)  
aaff 32 6c ee			ld (debug_mark+1),a  
ab02 3a 0c ab			ld a, (.dmark+2)  
ab05 32 6d ee			ld (debug_mark+2),a  
ab08 18 03			jr .pastdmark  
ab0a ..			.dmark: db "LSt"  
ab0d f1			.pastdmark: pop af  
ab0e			endm  
# End of macro DMARK
ab0e					CALLMONITOR 
ab0e cd 6f ee			call debug_vector  
ab11				endm  
# End of macro CALLMONITOR
ab11				endif 
ab11			 
ab11			; cant push right now due to tokenised strings  
ab11			 
ab11			; get the destination of where to copy this definition to. 
ab11			 
ab11 c5					push bc 
ab12 d1					pop de 
ab13			 
ab13 7e			.listl:         ld a,(hl) 
ab14 fe 00				cp 0 
ab16 28 09				jr z, .lreplsp     ; replace zero with space 
ab18					;cp FORTH_END_BUFFER 
ab18 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
ab1a 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
ab1c				 
ab1c					; just copy this char as is then 
ab1c			 
ab1c 12					ld (de), a 
ab1d			 
ab1d 23			.listnxt:	inc hl 
ab1e 13					inc de 
ab1f 18 f2				jr .listl 
ab21			 
ab21 3e 20		.lreplsp:	ld a,' ' 
ab23 12					ld (de), a 
ab24 18 f7				jr .listnxt 
ab26			 
ab26			; close up uword def 
ab26			 
ab26			.listdone: 
ab26 12					ld (de), a 
ab27 13					inc de 
ab28 3e 00				ld a, 0 
ab2a 12					ld (de), a 
ab2b			 
ab2b			; now have def so clean up and push to stack 
ab2b			 
ab2b 21 c1 e2				ld hl, scratch 
ab2e				if DEBUG_FORTH_WORDS 
ab2e					DMARK "Ltp" 
ab2e f5				push af  
ab2f 3a 43 ab			ld a, (.dmark)  
ab32 32 6b ee			ld (debug_mark),a  
ab35 3a 44 ab			ld a, (.dmark+1)  
ab38 32 6c ee			ld (debug_mark+1),a  
ab3b 3a 45 ab			ld a, (.dmark+2)  
ab3e 32 6d ee			ld (debug_mark+2),a  
ab41 18 03			jr .pastdmark  
ab43 ..			.dmark: db "Ltp"  
ab46 f1			.pastdmark: pop af  
ab47			endm  
# End of macro DMARK
ab47					CALLMONITOR 
ab47 cd 6f ee			call debug_vector  
ab4a				endm  
# End of macro CALLMONITOR
ab4a				endif 
ab4a			 
ab4a 18 1f			jr .listpush 
ab4c			 
ab4c			;.lnuword:	pop hl 
ab4c			;		call forth_tok_next 
ab4c			;		jp .ldouscan  
ab4c			 
ab4c			.lunotfound:		  
ab4c			 
ab4c				if DEBUG_FORTH_WORDS 
ab4c					DMARK "LSn" 
ab4c f5				push af  
ab4d 3a 61 ab			ld a, (.dmark)  
ab50 32 6b ee			ld (debug_mark),a  
ab53 3a 62 ab			ld a, (.dmark+1)  
ab56 32 6c ee			ld (debug_mark+1),a  
ab59 3a 63 ab			ld a, (.dmark+2)  
ab5c 32 6d ee			ld (debug_mark+2),a  
ab5f 18 03			jr .pastdmark  
ab61 ..			.dmark: db "LSn"  
ab64 f1			.pastdmark: pop af  
ab65			endm  
# End of macro DMARK
ab65					CALLMONITOR 
ab65 cd 6f ee			call debug_vector  
ab68				endm  
# End of macro CALLMONITOR
ab68				endif 
ab68			 
ab68					 
ab68			;		FORTH_DSP_POP 
ab68			;		ld hl, .luno 
ab68			 
ab68					NEXTW			 
ab68 c3 53 a0			jp macro_next 
ab6b				endm 
# End of macro NEXTW
ab6b			 
ab6b			.listpush: 
ab6b				if DEBUG_FORTH_WORDS 
ab6b					DMARK "LS>" 
ab6b f5				push af  
ab6c 3a 80 ab			ld a, (.dmark)  
ab6f 32 6b ee			ld (debug_mark),a  
ab72 3a 81 ab			ld a, (.dmark+1)  
ab75 32 6c ee			ld (debug_mark+1),a  
ab78 3a 82 ab			ld a, (.dmark+2)  
ab7b 32 6d ee			ld (debug_mark+2),a  
ab7e 18 03			jr .pastdmark  
ab80 ..			.dmark: db "LS>"  
ab83 f1			.pastdmark: pop af  
ab84			endm  
# End of macro DMARK
ab84					CALLMONITOR 
ab84 cd 6f ee			call debug_vector  
ab87				endm  
# End of macro CALLMONITOR
ab87				endif 
ab87 cd 14 9d				call forth_push_str 
ab8a			 
ab8a			 
ab8a			 
ab8a					NEXTW 
ab8a c3 53 a0			jp macro_next 
ab8d				endm 
# End of macro NEXTW
ab8d			 
ab8d			;.luno:    db "Word not found",0 
ab8d			 
ab8d			 
ab8d			 
ab8d			 
ab8d			 
ab8d			;		push hl   ; save pointer to start of uword def string 
ab8d			; 
ab8d			;; look for FORTH_EOL_LINE 
ab8d			;		ld a, FORTH_END_BUFFER 
ab8d			;		call strlent 
ab8d			; 
ab8d			;		inc hl		 ; space for coln def 
ab8d			;		inc hl 
ab8d			;		inc hl          ; space for terms 
ab8d			;		inc hl 
ab8d			; 
ab8d			;		ld a, 20   ; TODO get actual length 
ab8d			;		call addatohl    ; include a random amount of room for the uword name 
ab8d			; 
ab8d			;		 
ab8d			;	if DEBUG_FORTH_WORDS 
ab8d			;		DMARK "Lt1" 
ab8d			;		CALLMONITOR 
ab8d			;	endif 
ab8d			;		 
ab8d			; 
ab8d			;; malloc space for the string because we cant change it 
ab8d			; 
ab8d			;		call malloc 
ab8d			;	if DEBUG_FORTH_MALLOC_GUARD 
ab8d			;		push af 
ab8d			;		call ishlzero 
ab8d			;		pop af 
ab8d			;		 
ab8d			;		call z,malloc_error 
ab8d			;	endif 
ab8d			; 
ab8d			;	if DEBUG_FORTH_WORDS 
ab8d			;		DMARK "Lt2" 
ab8d			;		CALLMONITOR 
ab8d			;	endif 
ab8d			;		pop de 
ab8d			;		push hl    ; push the malloc to release later 
ab8d			;		push hl   ;  push back a copy for the later stack push 
ab8d			;		 
ab8d			;; copy the string swapping out the zero terms for spaces 
ab8d			; 
ab8d			;		; de has our source 
ab8d			;		; hl has our dest 
ab8d			; 
ab8d			;; add the coln def 
ab8d			; 
ab8d			;		ld a, ':' 
ab8d			;		ld (hl), a 
ab8d			;		inc hl 
ab8d			;		ld a, ' ' 
ab8d			;		ld (hl), a 
ab8d			;		inc hl 
ab8d			; 
ab8d			;; add the uname word 
ab8d			;		push de   ; save our string for now 
ab8d			;		ex de, hl 
ab8d			; 
ab8d			;		FORTH_DSP_VALUE 
ab8d			;		;v5 FORTH_DSP_VALUE 
ab8d			; 
ab8d			;		inc hl   ; skip type but we know by now this is OK 
ab8d			; 
ab8d			;.luword:	ld a,(hl) 
ab8d			;		cp 0 
ab8d			;		jr z, .luword2 
ab8d			;		ld (de), a 
ab8d			;		inc de 
ab8d			;		inc hl 
ab8d			;		jr .luword 
ab8d			; 
ab8d			;.luword2:	ld a, ' ' 
ab8d			;		ld (de), a 
ab8d			;;		inc hl 
ab8d			;;		inc de 
ab8d			;;		ld (de), a 
ab8d			;;		inc hl 
ab8d			;		inc de 
ab8d			; 
ab8d			;		ex de, hl 
ab8d			;		pop de 
ab8d			;		 
ab8d			;		 
ab8d			; 
ab8d			;; detoken that string and copy it 
ab8d			; 
ab8d			;	if DEBUG_FORTH_WORDS 
ab8d			;		DMARK "Lt2" 
ab8d			;		CALLMONITOR 
ab8d			;	endif 
ab8d			;.ldetok:	ld a, (de) 
ab8d			;		cp FORTH_END_BUFFER 
ab8d			;		jr z, .ldetokend 
ab8d			;		; swap out any zero term for space 
ab8d			;		cp 0 
ab8d			;		jr nz, .ldetoknext 
ab8d			;		ld a, ' ' 
ab8d			; 
ab8d			;	if DEBUG_FORTH_WORDS 
ab8d			;		DMARK "LtS" 
ab8d			;		CALLMONITOR 
ab8d			;	endif 
ab8d			;.ldetoknext:	ld (hl), a 
ab8d			;		inc de 
ab8d			;		inc hl 
ab8d			;		jr .ldetok 
ab8d			; 
ab8d			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
ab8d			;		ld (hl), a  
ab8d			; 
ab8d			;; free that temp malloc 
ab8d			; 
ab8d			;		pop hl    
ab8d			; 
ab8d			;	if DEBUG_FORTH_WORDS 
ab8d			;		DMARK "Lt4" 
ab8d			;		CALLMONITOR 
ab8d			;	endif 
ab8d			;		call forth_apushstrhl 
ab8d			; 
ab8d			;		; get rid of temp malloc area 
ab8d			; 
ab8d			;		pop hl 
ab8d			;		call free 
ab8d			; 
ab8d			;		jr .ludone 
ab8d			; 
ab8d			;.lnuword:	pop hl 
ab8d			;		call forth_tok_next 
ab8d			;		jp .ldouscan  
ab8d			; 
ab8d			;.ludone:		 pop hl 
ab8d			; 
ab8d					NEXTW 
ab8d c3 53 a0			jp macro_next 
ab90				endm 
# End of macro NEXTW
ab90			 
ab90			.FORGET: 
ab90				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
ab90 5d				db WORD_SYS_CORE+73             
ab91 09 ac			dw .NOP            
ab93 07				db 6 + 1 
ab94 .. 00			db "FORGET",0              
ab9b				endm 
# End of macro CWHEAD
ab9b			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
ab9b			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quoted uword name must be in caps. 
ab9b			; | |  
ab9b			; | | e.g. "MORE" forget 
ab9b					if DEBUG_FORTH_WORDS_KEY 
ab9b						DMARK "FRG" 
ab9b f5				push af  
ab9c 3a b0 ab			ld a, (.dmark)  
ab9f 32 6b ee			ld (debug_mark),a  
aba2 3a b1 ab			ld a, (.dmark+1)  
aba5 32 6c ee			ld (debug_mark+1),a  
aba8 3a b2 ab			ld a, (.dmark+2)  
abab 32 6d ee			ld (debug_mark+2),a  
abae 18 03			jr .pastdmark  
abb0 ..			.dmark: db "FRG"  
abb3 f1			.pastdmark: pop af  
abb4			endm  
# End of macro DMARK
abb4						CALLMONITOR 
abb4 cd 6f ee			call debug_vector  
abb7				endm  
# End of macro CALLMONITOR
abb7					endif 
abb7			 
abb7				; find uword 
abb7			        ; update start of word with "_" 
abb7				; replace uword with deleted flag 
abb7			 
abb7			 
abb7			;	if DEBUG_FORTH_WORDS 
abb7			;		DMARK "FOG" 
abb7			;		CALLMONITOR 
abb7			;	endif 
abb7			 
abb7			 
abb7					; Get ptr to the word we need to look up 
abb7			 
abb7					FORTH_DSP_VALUEHL 
abb7 cd 9d 9e			call macro_dsp_valuehl 
abba				endm 
# End of macro FORTH_DSP_VALUEHL
abba					;v5 FORTH_DSP_VALUE 
abba				; TODO type check 
abba			;		inc hl    ; Skip type check  
abba e5					push hl 
abbb c1					pop bc 
abbc			;		ex de, hl    ; put into DE 
abbc			 
abbc			 
abbc 21 43 e6				ld hl, baseram 
abbf					;ld hl, baseusermem 
abbf			 
abbf				; skip dict stub 
abbf			;	call forth_tok_next 
abbf e5			push hl   ; sacreifical push 
abc0			 
abc0			.fldouscanm: 
abc0 e1				pop hl 
abc1			.fldouscan: 
abc1			;	if DEBUG_FORTH_WORDS 
abc1			;		DMARK "LSs" 
abc1			;		CALLMONITOR 
abc1			;	endif 
abc1				; skip dict stub 
abc1 cd a4 a1				call forth_tok_next 
abc4			 
abc4			 
abc4			; while we have words to look for 
abc4			 
abc4 7e				ld a, (hl)      
abc5			;	if DEBUG_FORTH_WORDS 
abc5			;		DMARK "LSk" 
abc5			;		CALLMONITOR 
abc5			;	endif 
abc5 fe 00				cp WORD_SYS_END 
abc7 ca 03 ac				jp z, .flunotfound 
abca fe 01				cp WORD_SYS_UWORD 
abcc c2 c1 ab				jp nz, .fldouscan 
abcf			 
abcf			;	if DEBUG_FORTH_WORDS 
abcf			;		DMARK "LSu" 
abcf			;		CALLMONITOR 
abcf			;	endif 
abcf			 
abcf					; found a uword but is it the one we want... 
abcf			 
abcf c5					push bc     ; uword to find is on bc 
abd0 d1					pop de 
abd1			 
abd1 e5					push hl  ; to save the ptr 
abd2			 
abd2					; skip opcode 
abd2 23					inc hl  
abd3					; skip next ptr 
abd3 23					inc hl  
abd4 23					inc hl 
abd5					; skip len 
abd5 23					inc hl 
abd6			 
abd6			;	if DEBUG_FORTH_WORDS 
abd6			;		DMARK "LSc" 
abd6			;		CALLMONITOR 
abd6			;	endif 
abd6 cd d0 92				call strcmp 
abd9 c2 c0 ab				jp nz, .fldouscanm 
abdc			; 
abdc			; 
abdc			;; while we have words to look for 
abdc			; 
abdc			;.fdouscan:	ld a, (hl)      
abdc			;	if DEBUG_FORTH_WORDS 
abdc			;		DMARK "LSs" 
abdc			;		CALLMONITOR 
abdc			;	endif 
abdc			;		cp WORD_SYS_END 
abdc			;		jp z, .fudone 
abdc			;		cp WORD_SYS_UWORD 
abdc			;		jp nz, .fnuword 
abdc			; 
abdc			;	if DEBUG_FORTH_WORDS 
abdc			;		DMARK "FGu" 
abdc			;		CALLMONITOR 
abdc			;	endif 
abdc			; 
abdc			;		; found a uword but is it the one we want... 
abdc			; 
abdc			; 
abdc			;	        pop de   ; get back the dsp name 
abdc			;		push de 
abdc			; 
abdc			;		push hl  ; to save the ptr 
abdc			; 
abdc			;		; skip opcode 
abdc			;		inc hl  
abdc			;		; skip next ptr 
abdc			;		inc hl  
abdc			;		inc hl 
abdc			;		; skip len 
abdc			;		inc hl 
abdc			; 
abdc			;	if DEBUG_FORTH_WORDS 
abdc			;		DMARK "FGc" 
abdc			;		CALLMONITOR 
abdc			;	endif 
abdc			;		call strcmp 
abdc			;		jp nz, .fnuword 
abdc			 
abdc			 
abdc e1			pop hl 
abdd			 
abdd				 
abdd				if DEBUG_FORTH_WORDS 
abdd					DMARK "FGm" 
abdd f5				push af  
abde 3a f2 ab			ld a, (.dmark)  
abe1 32 6b ee			ld (debug_mark),a  
abe4 3a f3 ab			ld a, (.dmark+1)  
abe7 32 6c ee			ld (debug_mark+1),a  
abea 3a f4 ab			ld a, (.dmark+2)  
abed 32 6d ee			ld (debug_mark+2),a  
abf0 18 03			jr .pastdmark  
abf2 ..			.dmark: db "FGm"  
abf5 f1			.pastdmark: pop af  
abf6			endm  
# End of macro DMARK
abf6					CALLMONITOR 
abf6 cd 6f ee			call debug_vector  
abf9				endm  
# End of macro CALLMONITOR
abf9				endif 
abf9			 
abf9			 
abf9			 
abf9					; we have a uword so push its name to the stack 
abf9			 
abf9			;	   	push hl  ; save so we can move to next dict block 
abf9			;pop hl 
abf9			 
abf9					; update opcode to deleted 
abf9 3e 03				ld a, WORD_SYS_DELETED 
abfb 77					ld (hl), a 
abfc			 
abfc 23					inc hl  
abfd					; skip next ptr 
abfd 23					inc hl  
abfe 23					inc hl 
abff					; skip len 
abff 23					inc hl 
ac00			 
ac00					; TODO change parser to skip deleted words but for now mark it out 
ac00 3e 5f				ld a, "_" 
ac02 77					ld  (hl),a 
ac03			 
ac03			;		jr .fudone 
ac03			; 
ac03			;.fnuword:	pop hl 
ac03			;		call forth_tok_next 
ac03			;		jp .fdouscan  
ac03			 
ac03			.flunotfound:		  
ac03			 
ac03			 
ac03					 
ac03					FORTH_DSP_POP 
ac03 cd 55 9f			call macro_forth_dsp_pop 
ac06				endm 
# End of macro FORTH_DSP_POP
ac06			;		ld hl, .luno 
ac06			;.fudone:		 pop hl 
ac06					NEXTW 
ac06 c3 53 a0			jp macro_next 
ac09				endm 
# End of macro NEXTW
ac09			.NOP: 
ac09				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
ac09 61				db WORD_SYS_CORE+77             
ac0a 30 ac			dw .COMO            
ac0c 04				db 3 + 1 
ac0d .. 00			db "NOP",0              
ac11				endm 
# End of macro CWHEAD
ac11			; | NOP (  --  ) Do nothing | DONE 
ac11					if DEBUG_FORTH_WORDS_KEY 
ac11						DMARK "NOP" 
ac11 f5				push af  
ac12 3a 26 ac			ld a, (.dmark)  
ac15 32 6b ee			ld (debug_mark),a  
ac18 3a 27 ac			ld a, (.dmark+1)  
ac1b 32 6c ee			ld (debug_mark+1),a  
ac1e 3a 28 ac			ld a, (.dmark+2)  
ac21 32 6d ee			ld (debug_mark+2),a  
ac24 18 03			jr .pastdmark  
ac26 ..			.dmark: db "NOP"  
ac29 f1			.pastdmark: pop af  
ac2a			endm  
# End of macro DMARK
ac2a						CALLMONITOR 
ac2a cd 6f ee			call debug_vector  
ac2d				endm  
# End of macro CALLMONITOR
ac2d					endif 
ac2d				       NEXTW 
ac2d c3 53 a0			jp macro_next 
ac30				endm 
# End of macro NEXTW
ac30			.COMO: 
ac30				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
ac30 6e				db WORD_SYS_CORE+90             
ac31 82 ac			dw .COMC            
ac33 02				db 1 + 1 
ac34 .. 00			db "(",0              
ac36				endm 
# End of macro CWHEAD
ac36			; | ( ( -- )  Start of comment | DONE 
ac36			 
ac36			 
ac36 2a c2 e5				ld hl, ( os_tok_ptr) 
ac39 11 7d ac			ld de, .closepar 
ac3c					 
ac3c					if DEBUG_FORTH_WORDS 
ac3c						DMARK ").." 
ac3c f5				push af  
ac3d 3a 51 ac			ld a, (.dmark)  
ac40 32 6b ee			ld (debug_mark),a  
ac43 3a 52 ac			ld a, (.dmark+1)  
ac46 32 6c ee			ld (debug_mark+1),a  
ac49 3a 53 ac			ld a, (.dmark+2)  
ac4c 32 6d ee			ld (debug_mark+2),a  
ac4f 18 03			jr .pastdmark  
ac51 ..			.dmark: db ").."  
ac54 f1			.pastdmark: pop af  
ac55			endm  
# End of macro DMARK
ac55						CALLMONITOR 
ac55 cd 6f ee			call debug_vector  
ac58				endm  
# End of macro CALLMONITOR
ac58					endif 
ac58 cd 6e a1			call findnexttok  
ac5b			 
ac5b					if DEBUG_FORTH_WORDS 
ac5b						DMARK "IF5" 
ac5b f5				push af  
ac5c 3a 70 ac			ld a, (.dmark)  
ac5f 32 6b ee			ld (debug_mark),a  
ac62 3a 71 ac			ld a, (.dmark+1)  
ac65 32 6c ee			ld (debug_mark+1),a  
ac68 3a 72 ac			ld a, (.dmark+2)  
ac6b 32 6d ee			ld (debug_mark+2),a  
ac6e 18 03			jr .pastdmark  
ac70 ..			.dmark: db "IF5"  
ac73 f1			.pastdmark: pop af  
ac74			endm  
# End of macro DMARK
ac74						CALLMONITOR 
ac74 cd 6f ee			call debug_vector  
ac77				endm  
# End of macro CALLMONITOR
ac77					endif 
ac77				; replace below with ) exec using tok_ptr 
ac77 22 c2 e5			ld (os_tok_ptr), hl 
ac7a c3 e4 a0			jp exec1 
ac7d			 
ac7d .. 00			.closepar:   db ")",0 
ac7f			 
ac7f				       NEXTW 
ac7f c3 53 a0			jp macro_next 
ac82				endm 
# End of macro NEXTW
ac82			.COMC: 
ac82				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
ac82 6f				db WORD_SYS_CORE+91             
ac83 8b ac			dw .SCRATCH            
ac85 02				db 1 + 1 
ac86 .. 00			db ")",0              
ac88				endm 
# End of macro CWHEAD
ac88			; | ) ( -- )  End of comment |  DONE  
ac88				       NEXTW 
ac88 c3 53 a0			jp macro_next 
ac8b				endm 
# End of macro NEXTW
ac8b			 
ac8b			.SCRATCH: 
ac8b				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
ac8b 6f				db WORD_SYS_CORE+91             
ac8c c6 ac			dw .INC            
ac8e 08				db 7 + 1 
ac8f .. 00			db "SCRATCH",0              
ac97				endm 
# End of macro CWHEAD
ac97			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
ac97			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
ac97			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
ac97			; | |  
ac97			; | | e.g.    : score $00 scratch ; 
ac97			; | |  
ac97			; | | $00 score ! 
ac97			; | | $01 score +! 
ac97			; | |  
ac97			; | | e.g.   : varword $0a scratch ;  
ac97			; | | 
ac97			; | | $8000 varword ! 
ac97					if DEBUG_FORTH_WORDS_KEY 
ac97						DMARK "SCR" 
ac97 f5				push af  
ac98 3a ac ac			ld a, (.dmark)  
ac9b 32 6b ee			ld (debug_mark),a  
ac9e 3a ad ac			ld a, (.dmark+1)  
aca1 32 6c ee			ld (debug_mark+1),a  
aca4 3a ae ac			ld a, (.dmark+2)  
aca7 32 6d ee			ld (debug_mark+2),a  
acaa 18 03			jr .pastdmark  
acac ..			.dmark: db "SCR"  
acaf f1			.pastdmark: pop af  
acb0			endm  
# End of macro DMARK
acb0						CALLMONITOR 
acb0 cd 6f ee			call debug_vector  
acb3				endm  
# End of macro CALLMONITOR
acb3					endif 
acb3			 
acb3					FORTH_DSP_VALUEHL 
acb3 cd 9d 9e			call macro_dsp_valuehl 
acb6				endm 
# End of macro FORTH_DSP_VALUEHL
acb6				 
acb6					FORTH_DSP_POP 
acb6 cd 55 9f			call macro_forth_dsp_pop 
acb9				endm 
# End of macro FORTH_DSP_POP
acb9			 
acb9 7d					ld a, l 
acba 21 e6 e7				ld hl, os_var_array 
acbd cd db 8c				call addatohl 
acc0			 
acc0 cd a6 9c				call forth_push_numhl 
acc3			 
acc3				       NEXTW 
acc3 c3 53 a0			jp macro_next 
acc6				endm 
# End of macro NEXTW
acc6			 
acc6			.INC: 
acc6				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
acc6 6f				db WORD_SYS_CORE+91             
acc7 1c ad			dw .DEC            
acc9 03				db 2 + 1 
acca .. 00			db "+!",0              
accd				endm 
# End of macro CWHEAD
accd			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
accd					if DEBUG_FORTH_WORDS_KEY 
accd						DMARK "+s_" 
accd f5				push af  
acce 3a e2 ac			ld a, (.dmark)  
acd1 32 6b ee			ld (debug_mark),a  
acd4 3a e3 ac			ld a, (.dmark+1)  
acd7 32 6c ee			ld (debug_mark+1),a  
acda 3a e4 ac			ld a, (.dmark+2)  
acdd 32 6d ee			ld (debug_mark+2),a  
ace0 18 03			jr .pastdmark  
ace2 ..			.dmark: db "+s_"  
ace5 f1			.pastdmark: pop af  
ace6			endm  
# End of macro DMARK
ace6						CALLMONITOR 
ace6 cd 6f ee			call debug_vector  
ace9				endm  
# End of macro CALLMONITOR
ace9					endif 
ace9			 
ace9					FORTH_DSP_VALUEHL 
ace9 cd 9d 9e			call macro_dsp_valuehl 
acec				endm 
# End of macro FORTH_DSP_VALUEHL
acec			 
acec e5					push hl   ; save address 
aced			 
aced					FORTH_DSP_POP 
aced cd 55 9f			call macro_forth_dsp_pop 
acf0				endm 
# End of macro FORTH_DSP_POP
acf0			 
acf0					FORTH_DSP_VALUEHL 
acf0 cd 9d 9e			call macro_dsp_valuehl 
acf3				endm 
# End of macro FORTH_DSP_VALUEHL
acf3			 
acf3 e5					push hl 
acf4					FORTH_DSP_POP 
acf4 cd 55 9f			call macro_forth_dsp_pop 
acf7				endm 
# End of macro FORTH_DSP_POP
acf7 e1					pop hl 
acf8			 
acf8					; hl contains value to add to byte at a 
acf8				 
acf8 eb					ex de, hl 
acf9			 
acf9 e1					pop hl 
acfa			 
acfa					if DEBUG_FORTH_WORDS 
acfa						DMARK "INC" 
acfa f5				push af  
acfb 3a 0f ad			ld a, (.dmark)  
acfe 32 6b ee			ld (debug_mark),a  
ad01 3a 10 ad			ld a, (.dmark+1)  
ad04 32 6c ee			ld (debug_mark+1),a  
ad07 3a 11 ad			ld a, (.dmark+2)  
ad0a 32 6d ee			ld (debug_mark+2),a  
ad0d 18 03			jr .pastdmark  
ad0f ..			.dmark: db "INC"  
ad12 f1			.pastdmark: pop af  
ad13			endm  
# End of macro DMARK
ad13						CALLMONITOR 
ad13 cd 6f ee			call debug_vector  
ad16				endm  
# End of macro CALLMONITOR
ad16					endif 
ad16			 
ad16 7e					ld a,(hl) 
ad17 83					add e 
ad18 77					ld (hl),a 
ad19			 
ad19			 
ad19			 
ad19				       NEXTW 
ad19 c3 53 a0			jp macro_next 
ad1c				endm 
# End of macro NEXTW
ad1c			 
ad1c			.DEC: 
ad1c				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
ad1c 6f				db WORD_SYS_CORE+91             
ad1d 70 ad			dw .INC2            
ad1f 03				db 2 + 1 
ad20 .. 00			db "-!",0              
ad23				endm 
# End of macro CWHEAD
ad23			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
ad23					if DEBUG_FORTH_WORDS_KEY 
ad23						DMARK "-s_" 
ad23 f5				push af  
ad24 3a 38 ad			ld a, (.dmark)  
ad27 32 6b ee			ld (debug_mark),a  
ad2a 3a 39 ad			ld a, (.dmark+1)  
ad2d 32 6c ee			ld (debug_mark+1),a  
ad30 3a 3a ad			ld a, (.dmark+2)  
ad33 32 6d ee			ld (debug_mark+2),a  
ad36 18 03			jr .pastdmark  
ad38 ..			.dmark: db "-s_"  
ad3b f1			.pastdmark: pop af  
ad3c			endm  
# End of macro DMARK
ad3c						CALLMONITOR 
ad3c cd 6f ee			call debug_vector  
ad3f				endm  
# End of macro CALLMONITOR
ad3f					endif 
ad3f			 
ad3f					FORTH_DSP_VALUEHL 
ad3f cd 9d 9e			call macro_dsp_valuehl 
ad42				endm 
# End of macro FORTH_DSP_VALUEHL
ad42			 
ad42 e5					push hl   ; save address 
ad43			 
ad43					FORTH_DSP_POP 
ad43 cd 55 9f			call macro_forth_dsp_pop 
ad46				endm 
# End of macro FORTH_DSP_POP
ad46			 
ad46					FORTH_DSP_VALUEHL 
ad46 cd 9d 9e			call macro_dsp_valuehl 
ad49				endm 
# End of macro FORTH_DSP_VALUEHL
ad49			 
ad49					; hl contains value to add to byte at a 
ad49				 
ad49 eb					ex de, hl 
ad4a			 
ad4a e1					pop hl 
ad4b			 
ad4b					if DEBUG_FORTH_WORDS 
ad4b						DMARK "DEC" 
ad4b f5				push af  
ad4c 3a 60 ad			ld a, (.dmark)  
ad4f 32 6b ee			ld (debug_mark),a  
ad52 3a 61 ad			ld a, (.dmark+1)  
ad55 32 6c ee			ld (debug_mark+1),a  
ad58 3a 62 ad			ld a, (.dmark+2)  
ad5b 32 6d ee			ld (debug_mark+2),a  
ad5e 18 03			jr .pastdmark  
ad60 ..			.dmark: db "DEC"  
ad63 f1			.pastdmark: pop af  
ad64			endm  
# End of macro DMARK
ad64						CALLMONITOR 
ad64 cd 6f ee			call debug_vector  
ad67				endm  
# End of macro CALLMONITOR
ad67					endif 
ad67			 
ad67 7e					ld a,(hl) 
ad68 93					sub e 
ad69 77					ld (hl),a 
ad6a			 
ad6a			 
ad6a					FORTH_DSP_POP 
ad6a cd 55 9f			call macro_forth_dsp_pop 
ad6d				endm 
# End of macro FORTH_DSP_POP
ad6d			 
ad6d				       NEXTW 
ad6d c3 53 a0			jp macro_next 
ad70				endm 
# End of macro NEXTW
ad70			 
ad70			.INC2: 
ad70				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
ad70 6f				db WORD_SYS_CORE+91             
ad71 1d ae			dw .DEC2            
ad73 04				db 3 + 1 
ad74 .. 00			db "+2!",0              
ad78				endm 
# End of macro CWHEAD
ad78			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
ad78			 
ad78					if DEBUG_FORTH_WORDS_KEY 
ad78						DMARK "+2s" 
ad78 f5				push af  
ad79 3a 8d ad			ld a, (.dmark)  
ad7c 32 6b ee			ld (debug_mark),a  
ad7f 3a 8e ad			ld a, (.dmark+1)  
ad82 32 6c ee			ld (debug_mark+1),a  
ad85 3a 8f ad			ld a, (.dmark+2)  
ad88 32 6d ee			ld (debug_mark+2),a  
ad8b 18 03			jr .pastdmark  
ad8d ..			.dmark: db "+2s"  
ad90 f1			.pastdmark: pop af  
ad91			endm  
# End of macro DMARK
ad91						CALLMONITOR 
ad91 cd 6f ee			call debug_vector  
ad94				endm  
# End of macro CALLMONITOR
ad94					endif 
ad94			 
ad94					; Address 
ad94			 
ad94					FORTH_DSP_VALUEHL 
ad94 cd 9d 9e			call macro_dsp_valuehl 
ad97				endm 
# End of macro FORTH_DSP_VALUEHL
ad97			 
ad97 e5					push hl    ; save address 
ad98			 
ad98					; load content into de 
ad98			 
ad98 5e					ld e,(hl) 
ad99 23					inc hl 
ad9a 56					ld d, (hl) 
ad9b			 
ad9b					if DEBUG_FORTH_WORDS 
ad9b						DMARK "+2a" 
ad9b f5				push af  
ad9c 3a b0 ad			ld a, (.dmark)  
ad9f 32 6b ee			ld (debug_mark),a  
ada2 3a b1 ad			ld a, (.dmark+1)  
ada5 32 6c ee			ld (debug_mark+1),a  
ada8 3a b2 ad			ld a, (.dmark+2)  
adab 32 6d ee			ld (debug_mark+2),a  
adae 18 03			jr .pastdmark  
adb0 ..			.dmark: db "+2a"  
adb3 f1			.pastdmark: pop af  
adb4			endm  
# End of macro DMARK
adb4						CALLMONITOR 
adb4 cd 6f ee			call debug_vector  
adb7				endm  
# End of macro CALLMONITOR
adb7					endif 
adb7			 
adb7					FORTH_DSP_POP 
adb7 cd 55 9f			call macro_forth_dsp_pop 
adba				endm 
# End of macro FORTH_DSP_POP
adba			 
adba					; Get value to add 
adba			 
adba					FORTH_DSP_VALUE 
adba cd 86 9e			call macro_forth_dsp_value 
adbd				endm 
# End of macro FORTH_DSP_VALUE
adbd			 
adbd					if DEBUG_FORTH_WORDS 
adbd						DMARK "+2v" 
adbd f5				push af  
adbe 3a d2 ad			ld a, (.dmark)  
adc1 32 6b ee			ld (debug_mark),a  
adc4 3a d3 ad			ld a, (.dmark+1)  
adc7 32 6c ee			ld (debug_mark+1),a  
adca 3a d4 ad			ld a, (.dmark+2)  
adcd 32 6d ee			ld (debug_mark+2),a  
add0 18 03			jr .pastdmark  
add2 ..			.dmark: db "+2v"  
add5 f1			.pastdmark: pop af  
add6			endm  
# End of macro DMARK
add6						CALLMONITOR 
add6 cd 6f ee			call debug_vector  
add9				endm  
# End of macro CALLMONITOR
add9					endif 
add9			 
add9 19					add hl, de 
adda			 
adda					if DEBUG_FORTH_WORDS 
adda						DMARK "+2+" 
adda f5				push af  
addb 3a ef ad			ld a, (.dmark)  
adde 32 6b ee			ld (debug_mark),a  
ade1 3a f0 ad			ld a, (.dmark+1)  
ade4 32 6c ee			ld (debug_mark+1),a  
ade7 3a f1 ad			ld a, (.dmark+2)  
adea 32 6d ee			ld (debug_mark+2),a  
aded 18 03			jr .pastdmark  
adef ..			.dmark: db "+2+"  
adf2 f1			.pastdmark: pop af  
adf3			endm  
# End of macro DMARK
adf3						CALLMONITOR 
adf3 cd 6f ee			call debug_vector  
adf6				endm  
# End of macro CALLMONITOR
adf6					endif 
adf6			 
adf6					; move result to de 
adf6			 
adf6 eb					ex de, hl 
adf7			 
adf7					; Address 
adf7			 
adf7 e1					pop hl 
adf8			 
adf8					; save it back 
adf8			 
adf8 73					ld (hl), e 
adf9 23					inc hl 
adfa 72					ld (hl), d 
adfb			 
adfb					if DEBUG_FORTH_WORDS 
adfb						DMARK "+2e" 
adfb f5				push af  
adfc 3a 10 ae			ld a, (.dmark)  
adff 32 6b ee			ld (debug_mark),a  
ae02 3a 11 ae			ld a, (.dmark+1)  
ae05 32 6c ee			ld (debug_mark+1),a  
ae08 3a 12 ae			ld a, (.dmark+2)  
ae0b 32 6d ee			ld (debug_mark+2),a  
ae0e 18 03			jr .pastdmark  
ae10 ..			.dmark: db "+2e"  
ae13 f1			.pastdmark: pop af  
ae14			endm  
# End of macro DMARK
ae14						CALLMONITOR 
ae14 cd 6f ee			call debug_vector  
ae17				endm  
# End of macro CALLMONITOR
ae17					endif 
ae17			 
ae17			 
ae17			 
ae17					FORTH_DSP_POP 
ae17 cd 55 9f			call macro_forth_dsp_pop 
ae1a				endm 
# End of macro FORTH_DSP_POP
ae1a			 
ae1a			 
ae1a				       NEXTW 
ae1a c3 53 a0			jp macro_next 
ae1d				endm 
# End of macro NEXTW
ae1d			 
ae1d			.DEC2: 
ae1d				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
ae1d 6f				db WORD_SYS_CORE+91             
ae1e cc ae			dw .GET2            
ae20 04				db 3 + 1 
ae21 .. 00			db "-2!",0              
ae25				endm 
# End of macro CWHEAD
ae25			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
ae25			 
ae25			 
ae25					if DEBUG_FORTH_WORDS_KEY 
ae25						DMARK "-2s" 
ae25 f5				push af  
ae26 3a 3a ae			ld a, (.dmark)  
ae29 32 6b ee			ld (debug_mark),a  
ae2c 3a 3b ae			ld a, (.dmark+1)  
ae2f 32 6c ee			ld (debug_mark+1),a  
ae32 3a 3c ae			ld a, (.dmark+2)  
ae35 32 6d ee			ld (debug_mark+2),a  
ae38 18 03			jr .pastdmark  
ae3a ..			.dmark: db "-2s"  
ae3d f1			.pastdmark: pop af  
ae3e			endm  
# End of macro DMARK
ae3e						CALLMONITOR 
ae3e cd 6f ee			call debug_vector  
ae41				endm  
# End of macro CALLMONITOR
ae41					endif 
ae41			 
ae41					; Address 
ae41			 
ae41					FORTH_DSP_VALUEHL 
ae41 cd 9d 9e			call macro_dsp_valuehl 
ae44				endm 
# End of macro FORTH_DSP_VALUEHL
ae44			 
ae44 e5					push hl    ; save address 
ae45			 
ae45					; load content into de 
ae45			 
ae45 5e					ld e,(hl) 
ae46 23					inc hl 
ae47 56					ld d, (hl) 
ae48			 
ae48					if DEBUG_FORTH_WORDS 
ae48						DMARK "-2a" 
ae48 f5				push af  
ae49 3a 5d ae			ld a, (.dmark)  
ae4c 32 6b ee			ld (debug_mark),a  
ae4f 3a 5e ae			ld a, (.dmark+1)  
ae52 32 6c ee			ld (debug_mark+1),a  
ae55 3a 5f ae			ld a, (.dmark+2)  
ae58 32 6d ee			ld (debug_mark+2),a  
ae5b 18 03			jr .pastdmark  
ae5d ..			.dmark: db "-2a"  
ae60 f1			.pastdmark: pop af  
ae61			endm  
# End of macro DMARK
ae61						CALLMONITOR 
ae61 cd 6f ee			call debug_vector  
ae64				endm  
# End of macro CALLMONITOR
ae64					endif 
ae64			 
ae64					FORTH_DSP_POP 
ae64 cd 55 9f			call macro_forth_dsp_pop 
ae67				endm 
# End of macro FORTH_DSP_POP
ae67			 
ae67					; Get value to remove 
ae67			 
ae67					FORTH_DSP_VALUE 
ae67 cd 86 9e			call macro_forth_dsp_value 
ae6a				endm 
# End of macro FORTH_DSP_VALUE
ae6a			 
ae6a					if DEBUG_FORTH_WORDS 
ae6a						DMARK "-2v" 
ae6a f5				push af  
ae6b 3a 7f ae			ld a, (.dmark)  
ae6e 32 6b ee			ld (debug_mark),a  
ae71 3a 80 ae			ld a, (.dmark+1)  
ae74 32 6c ee			ld (debug_mark+1),a  
ae77 3a 81 ae			ld a, (.dmark+2)  
ae7a 32 6d ee			ld (debug_mark+2),a  
ae7d 18 03			jr .pastdmark  
ae7f ..			.dmark: db "-2v"  
ae82 f1			.pastdmark: pop af  
ae83			endm  
# End of macro DMARK
ae83						CALLMONITOR 
ae83 cd 6f ee			call debug_vector  
ae86				endm  
# End of macro CALLMONITOR
ae86					endif 
ae86			 
ae86 eb					ex de, hl 
ae87 ed 52				sbc hl, de 
ae89			 
ae89					if DEBUG_FORTH_WORDS 
ae89						DMARK "-2d" 
ae89 f5				push af  
ae8a 3a 9e ae			ld a, (.dmark)  
ae8d 32 6b ee			ld (debug_mark),a  
ae90 3a 9f ae			ld a, (.dmark+1)  
ae93 32 6c ee			ld (debug_mark+1),a  
ae96 3a a0 ae			ld a, (.dmark+2)  
ae99 32 6d ee			ld (debug_mark+2),a  
ae9c 18 03			jr .pastdmark  
ae9e ..			.dmark: db "-2d"  
aea1 f1			.pastdmark: pop af  
aea2			endm  
# End of macro DMARK
aea2						CALLMONITOR 
aea2 cd 6f ee			call debug_vector  
aea5				endm  
# End of macro CALLMONITOR
aea5					endif 
aea5			 
aea5					; move result to de 
aea5			 
aea5 eb					ex de, hl 
aea6			 
aea6					; Address 
aea6			 
aea6 e1					pop hl 
aea7			 
aea7					; save it back 
aea7			 
aea7 73					ld (hl), e 
aea8 23					inc hl 
aea9 72					ld (hl), d 
aeaa			 
aeaa					if DEBUG_FORTH_WORDS 
aeaa						DMARK "-2e" 
aeaa f5				push af  
aeab 3a bf ae			ld a, (.dmark)  
aeae 32 6b ee			ld (debug_mark),a  
aeb1 3a c0 ae			ld a, (.dmark+1)  
aeb4 32 6c ee			ld (debug_mark+1),a  
aeb7 3a c1 ae			ld a, (.dmark+2)  
aeba 32 6d ee			ld (debug_mark+2),a  
aebd 18 03			jr .pastdmark  
aebf ..			.dmark: db "-2e"  
aec2 f1			.pastdmark: pop af  
aec3			endm  
# End of macro DMARK
aec3						CALLMONITOR 
aec3 cd 6f ee			call debug_vector  
aec6				endm  
# End of macro CALLMONITOR
aec6					endif 
aec6			 
aec6			 
aec6					FORTH_DSP_POP 
aec6 cd 55 9f			call macro_forth_dsp_pop 
aec9				endm 
# End of macro FORTH_DSP_POP
aec9			 
aec9			 
aec9			 
aec9				       NEXTW 
aec9 c3 53 a0			jp macro_next 
aecc				endm 
# End of macro NEXTW
aecc			.GET2: 
aecc				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
aecc 6f				db WORD_SYS_CORE+91             
aecd 01 af			dw .BANG2            
aecf 03				db 2 + 1 
aed0 .. 00			db "2@",0              
aed3				endm 
# End of macro CWHEAD
aed3			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
aed3					if DEBUG_FORTH_WORDS_KEY 
aed3						DMARK "2A_" 
aed3 f5				push af  
aed4 3a e8 ae			ld a, (.dmark)  
aed7 32 6b ee			ld (debug_mark),a  
aeda 3a e9 ae			ld a, (.dmark+1)  
aedd 32 6c ee			ld (debug_mark+1),a  
aee0 3a ea ae			ld a, (.dmark+2)  
aee3 32 6d ee			ld (debug_mark+2),a  
aee6 18 03			jr .pastdmark  
aee8 ..			.dmark: db "2A_"  
aeeb f1			.pastdmark: pop af  
aeec			endm  
# End of macro DMARK
aeec						CALLMONITOR 
aeec cd 6f ee			call debug_vector  
aeef				endm  
# End of macro CALLMONITOR
aeef					endif 
aeef			 
aeef					FORTH_DSP_VALUEHL 
aeef cd 9d 9e			call macro_dsp_valuehl 
aef2				endm 
# End of macro FORTH_DSP_VALUEHL
aef2			 
aef2 e5					push hl   ; save address 
aef3			 
aef3					FORTH_DSP_POP 
aef3 cd 55 9f			call macro_forth_dsp_pop 
aef6				endm 
# End of macro FORTH_DSP_POP
aef6			 
aef6 e1					pop hl 
aef7			 
aef7 5e					ld e, (hl) 
aef8 23					inc hl 
aef9 56					ld d, (hl) 
aefa			 
aefa eb					ex de, hl 
aefb			 
aefb cd a6 9c				call forth_push_numhl 
aefe			 
aefe				       NEXTW 
aefe c3 53 a0			jp macro_next 
af01				endm 
# End of macro NEXTW
af01			.BANG2: 
af01				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
af01 6f				db WORD_SYS_CORE+91             
af02 39 af			dw .CONFIG            
af04 03				db 2 + 1 
af05 .. 00			db "2!",0              
af08				endm 
# End of macro CWHEAD
af08			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
af08					if DEBUG_FORTH_WORDS_KEY 
af08						DMARK "2S_" 
af08 f5				push af  
af09 3a 1d af			ld a, (.dmark)  
af0c 32 6b ee			ld (debug_mark),a  
af0f 3a 1e af			ld a, (.dmark+1)  
af12 32 6c ee			ld (debug_mark+1),a  
af15 3a 1f af			ld a, (.dmark+2)  
af18 32 6d ee			ld (debug_mark+2),a  
af1b 18 03			jr .pastdmark  
af1d ..			.dmark: db "2S_"  
af20 f1			.pastdmark: pop af  
af21			endm  
# End of macro DMARK
af21						CALLMONITOR 
af21 cd 6f ee			call debug_vector  
af24				endm  
# End of macro CALLMONITOR
af24					endif 
af24			 
af24					FORTH_DSP_VALUEHL 
af24 cd 9d 9e			call macro_dsp_valuehl 
af27				endm 
# End of macro FORTH_DSP_VALUEHL
af27			 
af27 e5					push hl   ; save address 
af28			 
af28			 
af28					FORTH_DSP_POP 
af28 cd 55 9f			call macro_forth_dsp_pop 
af2b				endm 
# End of macro FORTH_DSP_POP
af2b			 
af2b					 
af2b					FORTH_DSP_VALUEHL 
af2b cd 9d 9e			call macro_dsp_valuehl 
af2e				endm 
# End of macro FORTH_DSP_VALUEHL
af2e			 
af2e					FORTH_DSP_POP 
af2e cd 55 9f			call macro_forth_dsp_pop 
af31				endm 
# End of macro FORTH_DSP_POP
af31			 
af31 eb					ex de, hl    ; value now in de 
af32			 
af32 e1					pop hl 
af33			 
af33 73					ld (hl), e 
af34			 
af34 23					inc hl 
af35			 
af35 72					ld (hl), d 
af36			 
af36			 
af36				       NEXTW 
af36 c3 53 a0			jp macro_next 
af39				endm 
# End of macro NEXTW
af39			.CONFIG: 
af39				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
af39 6f				db WORD_SYS_CORE+91             
af3a 4a af			dw .ADTOS            
af3c 07				db 6 + 1 
af3d .. 00			db "CONFIG",0              
af44				endm 
# End of macro CWHEAD
af44			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
af44			 
af44 cd a6 94				call config 
af47					NEXTW 
af47 c3 53 a0			jp macro_next 
af4a				endm 
# End of macro NEXTW
af4a			 
af4a			.ADTOS: 
af4a				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
af4a 6f				db WORD_SYS_CORE+91             
af4b 60 af			dw .SBTOS            
af4d 03				db 2 + 1 
af4e .. 00			db "1+",0              
af51				endm 
# End of macro CWHEAD
af51			; | 1+ ( u -- u )  Increment value on TOS | DONE 
af51			 
af51					FORTH_DSP_VALUEHL 
af51 cd 9d 9e			call macro_dsp_valuehl 
af54				endm 
# End of macro FORTH_DSP_VALUEHL
af54 e5					push hl 
af55			 
af55					FORTH_DSP_POP 
af55 cd 55 9f			call macro_forth_dsp_pop 
af58				endm 
# End of macro FORTH_DSP_POP
af58 e1					pop hl 
af59			 
af59 23					inc hl 
af5a cd a6 9c				call forth_push_numhl 
af5d					 
af5d					NEXTW 
af5d c3 53 a0			jp macro_next 
af60				endm 
# End of macro NEXTW
af60			.SBTOS: 
af60				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
af60 6f				db WORD_SYS_CORE+91             
af61 76 af			dw .ADSTORE            
af63 03				db 2 + 1 
af64 .. 00			db "1-",0              
af67				endm 
# End of macro CWHEAD
af67			; | 1- ( u -- u )  Decrement value on TOS | DONE 
af67			 
af67					FORTH_DSP_VALUEHL 
af67 cd 9d 9e			call macro_dsp_valuehl 
af6a				endm 
# End of macro FORTH_DSP_VALUEHL
af6a e5					push hl 
af6b			 
af6b					FORTH_DSP_POP 
af6b cd 55 9f			call macro_forth_dsp_pop 
af6e				endm 
# End of macro FORTH_DSP_POP
af6e e1					pop hl 
af6f			 
af6f 2b					dec hl 
af70 cd a6 9c				call forth_push_numhl 
af73					 
af73					NEXTW 
af73 c3 53 a0			jp macro_next 
af76				endm 
# End of macro NEXTW
af76			.ADSTORE: 
af76				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
af76 6f				db WORD_SYS_CORE+91             
af77 8c af			dw .ADWSTORE            
af79 04				db 3 + 1 
af7a .. 00			db "1+!",0              
af7e				endm 
# End of macro CWHEAD
af7e			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
af7e			 
af7e					FORTH_DSP_VALUEHL 
af7e cd 9d 9e			call macro_dsp_valuehl 
af81				endm 
# End of macro FORTH_DSP_VALUEHL
af81 e5					push hl 
af82			 
af82					FORTH_DSP_POP 
af82 cd 55 9f			call macro_forth_dsp_pop 
af85				endm 
# End of macro FORTH_DSP_POP
af85 e1					pop hl 
af86			 
af86 7e					ld a, (hl) 
af87 3c					inc a 
af88 77					ld (hl), a 
af89					 
af89					NEXTW 
af89 c3 53 a0			jp macro_next 
af8c				endm 
# End of macro NEXTW
af8c			.ADWSTORE: 
af8c				CWHEAD .SBSTORE 91 "1+2!" 4 WORD_FLAG_CODE 
af8c 6f				db WORD_SYS_CORE+91             
af8d aa af			dw .SBSTORE            
af8f 05				db 4 + 1 
af90 .. 00			db "1+2!",0              
af95				endm 
# End of macro CWHEAD
af95			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
af95			 
af95					FORTH_DSP_VALUEHL 
af95 cd 9d 9e			call macro_dsp_valuehl 
af98				endm 
# End of macro FORTH_DSP_VALUEHL
af98 e5					push hl 
af99			 
af99					FORTH_DSP_POP 
af99 cd 55 9f			call macro_forth_dsp_pop 
af9c				endm 
# End of macro FORTH_DSP_POP
af9c e1					pop hl 
af9d			 
af9d e5					push hl 
af9e			 
af9e cd d5 9f				call loadwordinhl 
afa1 23					inc hl 
afa2			 
afa2 d1					pop de 
afa3 eb					ex de, hl 
afa4 73					ld (hl), e 
afa5 23					inc hl 
afa6 72					ld (hl), d 
afa7					 
afa7					NEXTW 
afa7 c3 53 a0			jp macro_next 
afaa				endm 
# End of macro NEXTW
afaa			.SBSTORE: 
afaa				CWHEAD .SBWSTORE 91 "1-!" 3 WORD_FLAG_CODE 
afaa 6f				db WORD_SYS_CORE+91             
afab c0 af			dw .SBWSTORE            
afad 04				db 3 + 1 
afae .. 00			db "1-!",0              
afb2				endm 
# End of macro CWHEAD
afb2			; | 1-! ( addr -- )  Decrement byte at address addr | DONE 
afb2			 
afb2					FORTH_DSP_VALUEHL 
afb2 cd 9d 9e			call macro_dsp_valuehl 
afb5				endm 
# End of macro FORTH_DSP_VALUEHL
afb5 e5					push hl 
afb6			 
afb6					FORTH_DSP_POP 
afb6 cd 55 9f			call macro_forth_dsp_pop 
afb9				endm 
# End of macro FORTH_DSP_POP
afb9 e1					pop hl 
afba			 
afba 7e					ld a, (hl) 
afbb 3d					dec a 
afbc 77					ld (hl), a 
afbd					 
afbd					NEXTW 
afbd c3 53 a0			jp macro_next 
afc0				endm 
# End of macro NEXTW
afc0			.SBWSTORE: 
afc0				CWHEAD .ENDCORE 91 "1-2!" 4 WORD_FLAG_CODE 
afc0 6f				db WORD_SYS_CORE+91             
afc1 de af			dw .ENDCORE            
afc3 05				db 4 + 1 
afc4 .. 00			db "1-2!",0              
afc9				endm 
# End of macro CWHEAD
afc9			; | 1-2! ( addr -- )  Decrement word at address addr | DONE 
afc9			 
afc9					FORTH_DSP_VALUEHL 
afc9 cd 9d 9e			call macro_dsp_valuehl 
afcc				endm 
# End of macro FORTH_DSP_VALUEHL
afcc e5					push hl 
afcd			 
afcd					FORTH_DSP_POP 
afcd cd 55 9f			call macro_forth_dsp_pop 
afd0				endm 
# End of macro FORTH_DSP_POP
afd0 e1					pop hl 
afd1			 
afd1 e5					push hl 
afd2			 
afd2 cd d5 9f				call loadwordinhl 
afd5 2b					dec hl 
afd6			 
afd6 d1					pop de 
afd7 eb					ex de, hl 
afd8 73					ld (hl), e 
afd9 23					inc hl 
afda 72					ld (hl), d 
afdb					 
afdb					NEXTW 
afdb c3 53 a0			jp macro_next 
afde				endm 
# End of macro NEXTW
afde			.ENDCORE: 
afde			 
afde			; eof 
afde			 
afde			 
# End of file forth_words_core.asm
afde			include "forth_words_flow.asm" 
afde			 
afde			; | ## Program Flow Words 
afde			 
afde			.IF: 
afde				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
afde 1e				db WORD_SYS_CORE+10             
afdf d3 b0			dw .THEN            
afe1 03				db 2 + 1 
afe2 .. 00			db "IF",0              
afe5				endm 
# End of macro CWHEAD
afe5			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
afe5			; 
afe5					if DEBUG_FORTH_WORDS_KEY 
afe5						DMARK "IF." 
afe5 f5				push af  
afe6 3a fa af			ld a, (.dmark)  
afe9 32 6b ee			ld (debug_mark),a  
afec 3a fb af			ld a, (.dmark+1)  
afef 32 6c ee			ld (debug_mark+1),a  
aff2 3a fc af			ld a, (.dmark+2)  
aff5 32 6d ee			ld (debug_mark+2),a  
aff8 18 03			jr .pastdmark  
affa ..			.dmark: db "IF."  
affd f1			.pastdmark: pop af  
affe			endm  
# End of macro DMARK
affe						CALLMONITOR 
affe cd 6f ee			call debug_vector  
b001				endm  
# End of macro CALLMONITOR
b001					endif 
b001			; eval TOS 
b001			 
b001				FORTH_DSP_VALUEHL 
b001 cd 9d 9e			call macro_dsp_valuehl 
b004				endm 
# End of macro FORTH_DSP_VALUEHL
b004			 
b004			;	push hl 
b004				FORTH_DSP_POP 
b004 cd 55 9f			call macro_forth_dsp_pop 
b007				endm 
# End of macro FORTH_DSP_POP
b007			;	pop hl 
b007			 
b007					if DEBUG_FORTH_WORDS 
b007						DMARK "IF1" 
b007 f5				push af  
b008 3a 1c b0			ld a, (.dmark)  
b00b 32 6b ee			ld (debug_mark),a  
b00e 3a 1d b0			ld a, (.dmark+1)  
b011 32 6c ee			ld (debug_mark+1),a  
b014 3a 1e b0			ld a, (.dmark+2)  
b017 32 6d ee			ld (debug_mark+2),a  
b01a 18 03			jr .pastdmark  
b01c ..			.dmark: db "IF1"  
b01f f1			.pastdmark: pop af  
b020			endm  
# End of macro DMARK
b020						CALLMONITOR 
b020 cd 6f ee			call debug_vector  
b023				endm  
# End of macro CALLMONITOR
b023					endif 
b023 b7				or a        ; clear carry flag 
b024 11 00 00			ld de, 0 
b027 eb				ex de,hl 
b028 ed 52			sbc hl, de 
b02a c2 b4 b0			jp nz, .iftrue 
b02d			 
b02d					if DEBUG_FORTH_WORDS 
b02d						DMARK "IF2" 
b02d f5				push af  
b02e 3a 42 b0			ld a, (.dmark)  
b031 32 6b ee			ld (debug_mark),a  
b034 3a 43 b0			ld a, (.dmark+1)  
b037 32 6c ee			ld (debug_mark+1),a  
b03a 3a 44 b0			ld a, (.dmark+2)  
b03d 32 6d ee			ld (debug_mark+2),a  
b040 18 03			jr .pastdmark  
b042 ..			.dmark: db "IF2"  
b045 f1			.pastdmark: pop af  
b046			endm  
# End of macro DMARK
b046						CALLMONITOR 
b046 cd 6f ee			call debug_vector  
b049				endm  
# End of macro CALLMONITOR
b049					endif 
b049			 
b049			; if not true then skip to THEN 
b049			 
b049				; TODO get tok_ptr 
b049				; TODO consume toks until we get to THEN 
b049			 
b049 2a c2 e5			ld hl, (os_tok_ptr) 
b04c					if DEBUG_FORTH_WORDS 
b04c						DMARK "IF3" 
b04c f5				push af  
b04d 3a 61 b0			ld a, (.dmark)  
b050 32 6b ee			ld (debug_mark),a  
b053 3a 62 b0			ld a, (.dmark+1)  
b056 32 6c ee			ld (debug_mark+1),a  
b059 3a 63 b0			ld a, (.dmark+2)  
b05c 32 6d ee			ld (debug_mark+2),a  
b05f 18 03			jr .pastdmark  
b061 ..			.dmark: db "IF3"  
b064 f1			.pastdmark: pop af  
b065			endm  
# End of macro DMARK
b065						CALLMONITOR 
b065 cd 6f ee			call debug_vector  
b068				endm  
# End of macro CALLMONITOR
b068						 
b068					endif 
b068 11 af b0			ld de, .ifthen 
b06b					if DEBUG_FORTH_WORDS 
b06b						DMARK "IF4" 
b06b f5				push af  
b06c 3a 80 b0			ld a, (.dmark)  
b06f 32 6b ee			ld (debug_mark),a  
b072 3a 81 b0			ld a, (.dmark+1)  
b075 32 6c ee			ld (debug_mark+1),a  
b078 3a 82 b0			ld a, (.dmark+2)  
b07b 32 6d ee			ld (debug_mark+2),a  
b07e 18 03			jr .pastdmark  
b080 ..			.dmark: db "IF4"  
b083 f1			.pastdmark: pop af  
b084			endm  
# End of macro DMARK
b084						CALLMONITOR 
b084 cd 6f ee			call debug_vector  
b087				endm  
# End of macro CALLMONITOR
b087					endif 
b087 cd 6e a1			call findnexttok  
b08a			 
b08a					if DEBUG_FORTH_WORDS 
b08a						DMARK "IF5" 
b08a f5				push af  
b08b 3a 9f b0			ld a, (.dmark)  
b08e 32 6b ee			ld (debug_mark),a  
b091 3a a0 b0			ld a, (.dmark+1)  
b094 32 6c ee			ld (debug_mark+1),a  
b097 3a a1 b0			ld a, (.dmark+2)  
b09a 32 6d ee			ld (debug_mark+2),a  
b09d 18 03			jr .pastdmark  
b09f ..			.dmark: db "IF5"  
b0a2 f1			.pastdmark: pop af  
b0a3			endm  
# End of macro DMARK
b0a3						CALLMONITOR 
b0a3 cd 6f ee			call debug_vector  
b0a6				endm  
# End of macro CALLMONITOR
b0a6					endif 
b0a6				; TODO replace below with ; exec using tok_ptr 
b0a6 22 c2 e5			ld (os_tok_ptr), hl 
b0a9 c3 e4 a0			jp exec1 
b0ac				NEXTW 
b0ac c3 53 a0			jp macro_next 
b0af				endm 
# End of macro NEXTW
b0af			 
b0af .. 00		.ifthen:  db "THEN",0 
b0b4			 
b0b4			.iftrue:		 
b0b4				; Exec next words normally 
b0b4			 
b0b4				; if true then exec following IF as normal 
b0b4					if DEBUG_FORTH_WORDS 
b0b4						DMARK "IFT" 
b0b4 f5				push af  
b0b5 3a c9 b0			ld a, (.dmark)  
b0b8 32 6b ee			ld (debug_mark),a  
b0bb 3a ca b0			ld a, (.dmark+1)  
b0be 32 6c ee			ld (debug_mark+1),a  
b0c1 3a cb b0			ld a, (.dmark+2)  
b0c4 32 6d ee			ld (debug_mark+2),a  
b0c7 18 03			jr .pastdmark  
b0c9 ..			.dmark: db "IFT"  
b0cc f1			.pastdmark: pop af  
b0cd			endm  
# End of macro DMARK
b0cd						CALLMONITOR 
b0cd cd 6f ee			call debug_vector  
b0d0				endm  
# End of macro CALLMONITOR
b0d0					endif 
b0d0			 
b0d0					NEXTW 
b0d0 c3 53 a0			jp macro_next 
b0d3				endm 
# End of macro NEXTW
b0d3			.THEN: 
b0d3				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
b0d3 1f				db WORD_SYS_CORE+11             
b0d4 fb b0			dw .ELSE            
b0d6 05				db 4 + 1 
b0d7 .. 00			db "THEN",0              
b0dc				endm 
# End of macro CWHEAD
b0dc			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
b0dc					if DEBUG_FORTH_WORDS_KEY 
b0dc						DMARK "THN" 
b0dc f5				push af  
b0dd 3a f1 b0			ld a, (.dmark)  
b0e0 32 6b ee			ld (debug_mark),a  
b0e3 3a f2 b0			ld a, (.dmark+1)  
b0e6 32 6c ee			ld (debug_mark+1),a  
b0e9 3a f3 b0			ld a, (.dmark+2)  
b0ec 32 6d ee			ld (debug_mark+2),a  
b0ef 18 03			jr .pastdmark  
b0f1 ..			.dmark: db "THN"  
b0f4 f1			.pastdmark: pop af  
b0f5			endm  
# End of macro DMARK
b0f5						CALLMONITOR 
b0f5 cd 6f ee			call debug_vector  
b0f8				endm  
# End of macro CALLMONITOR
b0f8					endif 
b0f8					NEXTW 
b0f8 c3 53 a0			jp macro_next 
b0fb				endm 
# End of macro NEXTW
b0fb			.ELSE: 
b0fb				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
b0fb 20				db WORD_SYS_CORE+12             
b0fc 23 b1			dw .DO            
b0fe 03				db 2 + 1 
b0ff .. 00			db "ELSE",0              
b104				endm 
# End of macro CWHEAD
b104			; | ELSE ( -- ) Not supported - does nothing | TODO 
b104			 
b104					if DEBUG_FORTH_WORDS_KEY 
b104						DMARK "ELS" 
b104 f5				push af  
b105 3a 19 b1			ld a, (.dmark)  
b108 32 6b ee			ld (debug_mark),a  
b10b 3a 1a b1			ld a, (.dmark+1)  
b10e 32 6c ee			ld (debug_mark+1),a  
b111 3a 1b b1			ld a, (.dmark+2)  
b114 32 6d ee			ld (debug_mark+2),a  
b117 18 03			jr .pastdmark  
b119 ..			.dmark: db "ELS"  
b11c f1			.pastdmark: pop af  
b11d			endm  
# End of macro DMARK
b11d						CALLMONITOR 
b11d cd 6f ee			call debug_vector  
b120				endm  
# End of macro CALLMONITOR
b120					endif 
b120			 
b120			 
b120					NEXTW 
b120 c3 53 a0			jp macro_next 
b123				endm 
# End of macro NEXTW
b123			.DO: 
b123				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
b123 21				db WORD_SYS_CORE+13             
b124 4a b2			dw .LOOP            
b126 03				db 2 + 1 
b127 .. 00			db "DO",0              
b12a				endm 
# End of macro CWHEAD
b12a			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
b12a			 
b12a					if DEBUG_FORTH_WORDS_KEY 
b12a						DMARK "DO." 
b12a f5				push af  
b12b 3a 3f b1			ld a, (.dmark)  
b12e 32 6b ee			ld (debug_mark),a  
b131 3a 40 b1			ld a, (.dmark+1)  
b134 32 6c ee			ld (debug_mark+1),a  
b137 3a 41 b1			ld a, (.dmark+2)  
b13a 32 6d ee			ld (debug_mark+2),a  
b13d 18 03			jr .pastdmark  
b13f ..			.dmark: db "DO."  
b142 f1			.pastdmark: pop af  
b143			endm  
# End of macro DMARK
b143						CALLMONITOR 
b143 cd 6f ee			call debug_vector  
b146				endm  
# End of macro CALLMONITOR
b146					endif 
b146			;  push pc to rsp stack past the DO 
b146			 
b146 2a c2 e5				ld hl, (os_tok_ptr) 
b149 23					inc hl   ; D 
b14a 23					inc hl  ; O 
b14b 23					inc hl   ; null 
b14c					if DEBUG_FORTH_WORDS 
b14c						DMARK "DO2" 
b14c f5				push af  
b14d 3a 61 b1			ld a, (.dmark)  
b150 32 6b ee			ld (debug_mark),a  
b153 3a 62 b1			ld a, (.dmark+1)  
b156 32 6c ee			ld (debug_mark+1),a  
b159 3a 63 b1			ld a, (.dmark+2)  
b15c 32 6d ee			ld (debug_mark+2),a  
b15f 18 03			jr .pastdmark  
b161 ..			.dmark: db "DO2"  
b164 f1			.pastdmark: pop af  
b165			endm  
# End of macro DMARK
b165						CALLMONITOR 
b165 cd 6f ee			call debug_vector  
b168				endm  
# End of macro CALLMONITOR
b168					endif 
b168					FORTH_RSP_NEXT 
b168 cd 4d 9c			call macro_forth_rsp_next 
b16b				endm 
# End of macro FORTH_RSP_NEXT
b16b					if DEBUG_FORTH_WORDS 
b16b						DMARK "DO3" 
b16b f5				push af  
b16c 3a 80 b1			ld a, (.dmark)  
b16f 32 6b ee			ld (debug_mark),a  
b172 3a 81 b1			ld a, (.dmark+1)  
b175 32 6c ee			ld (debug_mark+1),a  
b178 3a 82 b1			ld a, (.dmark+2)  
b17b 32 6d ee			ld (debug_mark+2),a  
b17e 18 03			jr .pastdmark  
b180 ..			.dmark: db "DO3"  
b183 f1			.pastdmark: pop af  
b184			endm  
# End of macro DMARK
b184						CALLMONITOR 
b184 cd 6f ee			call debug_vector  
b187				endm  
# End of macro CALLMONITOR
b187					endif 
b187			 
b187					;if DEBUG_FORTH_WORDS 
b187				;		push hl 
b187			;		endif  
b187			 
b187			; get counters from data stack 
b187			 
b187			 
b187					FORTH_DSP_VALUEHL 
b187 cd 9d 9e			call macro_dsp_valuehl 
b18a				endm 
# End of macro FORTH_DSP_VALUEHL
b18a e5					push hl		 ; hl now has starting counter which needs to be tos 
b18b			 
b18b					if DEBUG_FORTH_WORDS 
b18b						DMARK "DO4" 
b18b f5				push af  
b18c 3a a0 b1			ld a, (.dmark)  
b18f 32 6b ee			ld (debug_mark),a  
b192 3a a1 b1			ld a, (.dmark+1)  
b195 32 6c ee			ld (debug_mark+1),a  
b198 3a a2 b1			ld a, (.dmark+2)  
b19b 32 6d ee			ld (debug_mark+2),a  
b19e 18 03			jr .pastdmark  
b1a0 ..			.dmark: db "DO4"  
b1a3 f1			.pastdmark: pop af  
b1a4			endm  
# End of macro DMARK
b1a4						CALLMONITOR 
b1a4 cd 6f ee			call debug_vector  
b1a7				endm  
# End of macro CALLMONITOR
b1a7					endif 
b1a7					FORTH_DSP_POP 
b1a7 cd 55 9f			call macro_forth_dsp_pop 
b1aa				endm 
# End of macro FORTH_DSP_POP
b1aa			 
b1aa					if DEBUG_FORTH_WORDS 
b1aa						DMARK "DO5" 
b1aa f5				push af  
b1ab 3a bf b1			ld a, (.dmark)  
b1ae 32 6b ee			ld (debug_mark),a  
b1b1 3a c0 b1			ld a, (.dmark+1)  
b1b4 32 6c ee			ld (debug_mark+1),a  
b1b7 3a c1 b1			ld a, (.dmark+2)  
b1ba 32 6d ee			ld (debug_mark+2),a  
b1bd 18 03			jr .pastdmark  
b1bf ..			.dmark: db "DO5"  
b1c2 f1			.pastdmark: pop af  
b1c3			endm  
# End of macro DMARK
b1c3						CALLMONITOR 
b1c3 cd 6f ee			call debug_vector  
b1c6				endm  
# End of macro CALLMONITOR
b1c6					endif 
b1c6			 
b1c6					FORTH_DSP_VALUEHL 
b1c6 cd 9d 9e			call macro_dsp_valuehl 
b1c9				endm 
# End of macro FORTH_DSP_VALUEHL
b1c9			;		push hl		 ; hl now has starting limit counter 
b1c9			 
b1c9					if DEBUG_FORTH_WORDS 
b1c9						DMARK "DO6" 
b1c9 f5				push af  
b1ca 3a de b1			ld a, (.dmark)  
b1cd 32 6b ee			ld (debug_mark),a  
b1d0 3a df b1			ld a, (.dmark+1)  
b1d3 32 6c ee			ld (debug_mark+1),a  
b1d6 3a e0 b1			ld a, (.dmark+2)  
b1d9 32 6d ee			ld (debug_mark+2),a  
b1dc 18 03			jr .pastdmark  
b1de ..			.dmark: db "DO6"  
b1e1 f1			.pastdmark: pop af  
b1e2			endm  
# End of macro DMARK
b1e2						CALLMONITOR 
b1e2 cd 6f ee			call debug_vector  
b1e5				endm  
# End of macro CALLMONITOR
b1e5					endif 
b1e5					FORTH_DSP_POP 
b1e5 cd 55 9f			call macro_forth_dsp_pop 
b1e8				endm 
# End of macro FORTH_DSP_POP
b1e8			 
b1e8			; put counters on the loop stack 
b1e8			 
b1e8			;		pop hl			 ; limit counter 
b1e8 d1					pop de			; start counter 
b1e9			 
b1e9					; push limit counter 
b1e9			 
b1e9					if DEBUG_FORTH_WORDS 
b1e9						DMARK "DO7" 
b1e9 f5				push af  
b1ea 3a fe b1			ld a, (.dmark)  
b1ed 32 6b ee			ld (debug_mark),a  
b1f0 3a ff b1			ld a, (.dmark+1)  
b1f3 32 6c ee			ld (debug_mark+1),a  
b1f6 3a 00 b2			ld a, (.dmark+2)  
b1f9 32 6d ee			ld (debug_mark+2),a  
b1fc 18 03			jr .pastdmark  
b1fe ..			.dmark: db "DO7"  
b201 f1			.pastdmark: pop af  
b202			endm  
# End of macro DMARK
b202						CALLMONITOR 
b202 cd 6f ee			call debug_vector  
b205				endm  
# End of macro CALLMONITOR
b205					endif 
b205					FORTH_LOOP_NEXT 
b205 cd ce 9e			call macro_forth_loop_next 
b208				endm 
# End of macro FORTH_LOOP_NEXT
b208			 
b208					; push start counter 
b208			 
b208 eb					ex de, hl 
b209					if DEBUG_FORTH_WORDS 
b209						DMARK "DO7" 
b209 f5				push af  
b20a 3a 1e b2			ld a, (.dmark)  
b20d 32 6b ee			ld (debug_mark),a  
b210 3a 1f b2			ld a, (.dmark+1)  
b213 32 6c ee			ld (debug_mark+1),a  
b216 3a 20 b2			ld a, (.dmark+2)  
b219 32 6d ee			ld (debug_mark+2),a  
b21c 18 03			jr .pastdmark  
b21e ..			.dmark: db "DO7"  
b221 f1			.pastdmark: pop af  
b222			endm  
# End of macro DMARK
b222						CALLMONITOR 
b222 cd 6f ee			call debug_vector  
b225				endm  
# End of macro CALLMONITOR
b225					endif 
b225					FORTH_LOOP_NEXT 
b225 cd ce 9e			call macro_forth_loop_next 
b228				endm 
# End of macro FORTH_LOOP_NEXT
b228			 
b228			 
b228					; init first round of I counter 
b228			 
b228 22 e6 e5				ld (os_current_i), hl 
b22b			 
b22b					if DEBUG_FORTH_WORDS 
b22b						DMARK "DO8" 
b22b f5				push af  
b22c 3a 40 b2			ld a, (.dmark)  
b22f 32 6b ee			ld (debug_mark),a  
b232 3a 41 b2			ld a, (.dmark+1)  
b235 32 6c ee			ld (debug_mark+1),a  
b238 3a 42 b2			ld a, (.dmark+2)  
b23b 32 6d ee			ld (debug_mark+2),a  
b23e 18 03			jr .pastdmark  
b240 ..			.dmark: db "DO8"  
b243 f1			.pastdmark: pop af  
b244			endm  
# End of macro DMARK
b244						CALLMONITOR 
b244 cd 6f ee			call debug_vector  
b247				endm  
# End of macro CALLMONITOR
b247					endif 
b247			 
b247					NEXTW 
b247 c3 53 a0			jp macro_next 
b24a				endm 
# End of macro NEXTW
b24a			.LOOP: 
b24a				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
b24a 22				db WORD_SYS_CORE+14             
b24b 62 b3			dw .I            
b24d 05				db 4 + 1 
b24e .. 00			db "LOOP",0              
b253				endm 
# End of macro CWHEAD
b253			; | LOOP ( -- ) Increment and test loop counter  | DONE 
b253			 
b253				; pop tos as current loop count to hl 
b253			 
b253				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b253			 
b253				FORTH_LOOP_TOS 
b253 cd 01 9f			call macro_forth_loop_tos 
b256				endm 
# End of macro FORTH_LOOP_TOS
b256 e5				push hl 
b257			 
b257					if DEBUG_FORTH_WORDS_KEY 
b257						DMARK "LOP" 
b257 f5				push af  
b258 3a 6c b2			ld a, (.dmark)  
b25b 32 6b ee			ld (debug_mark),a  
b25e 3a 6d b2			ld a, (.dmark+1)  
b261 32 6c ee			ld (debug_mark+1),a  
b264 3a 6e b2			ld a, (.dmark+2)  
b267 32 6d ee			ld (debug_mark+2),a  
b26a 18 03			jr .pastdmark  
b26c ..			.dmark: db "LOP"  
b26f f1			.pastdmark: pop af  
b270			endm  
# End of macro DMARK
b270						CALLMONITOR 
b270 cd 6f ee			call debug_vector  
b273				endm  
# End of macro CALLMONITOR
b273					endif 
b273				; next item on the stack is the limit. get it 
b273			 
b273			 
b273				FORTH_LOOP_POP 
b273 cd 0b 9f			call macro_forth_loop_pop 
b276				endm 
# End of macro FORTH_LOOP_POP
b276			 
b276				FORTH_LOOP_TOS 
b276 cd 01 9f			call macro_forth_loop_tos 
b279				endm 
# End of macro FORTH_LOOP_TOS
b279			 
b279 d1				pop de		 ; de = i, hl = limit 
b27a			 
b27a					if DEBUG_FORTH_WORDS 
b27a						DMARK "LP1" 
b27a f5				push af  
b27b 3a 8f b2			ld a, (.dmark)  
b27e 32 6b ee			ld (debug_mark),a  
b281 3a 90 b2			ld a, (.dmark+1)  
b284 32 6c ee			ld (debug_mark+1),a  
b287 3a 91 b2			ld a, (.dmark+2)  
b28a 32 6d ee			ld (debug_mark+2),a  
b28d 18 03			jr .pastdmark  
b28f ..			.dmark: db "LP1"  
b292 f1			.pastdmark: pop af  
b293			endm  
# End of macro DMARK
b293						CALLMONITOR 
b293 cd 6f ee			call debug_vector  
b296				endm  
# End of macro CALLMONITOR
b296					endif 
b296			 
b296				; go back to previous word 
b296			 
b296 d5				push de    ; save I for inc later 
b297			 
b297			 
b297				; get limit 
b297				;  is I at limit? 
b297			 
b297			 
b297					if DEBUG_FORTH_WORDS 
b297						DMARK "LP1" 
b297 f5				push af  
b298 3a ac b2			ld a, (.dmark)  
b29b 32 6b ee			ld (debug_mark),a  
b29e 3a ad b2			ld a, (.dmark+1)  
b2a1 32 6c ee			ld (debug_mark+1),a  
b2a4 3a ae b2			ld a, (.dmark+2)  
b2a7 32 6d ee			ld (debug_mark+2),a  
b2aa 18 03			jr .pastdmark  
b2ac ..			.dmark: db "LP1"  
b2af f1			.pastdmark: pop af  
b2b0			endm  
# End of macro DMARK
b2b0						CALLMONITOR 
b2b0 cd 6f ee			call debug_vector  
b2b3				endm  
# End of macro CALLMONITOR
b2b3					endif 
b2b3			 
b2b3 ed 52			sbc hl, de 
b2b5			 
b2b5			 
b2b5				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b2b5			 
b2b5 20 26				jr nz, .loopnotdone 
b2b7			 
b2b7 e1				pop hl   ; get rid of saved I 
b2b8				FORTH_LOOP_POP     ; get rid of limit 
b2b8 cd 0b 9f			call macro_forth_loop_pop 
b2bb				endm 
# End of macro FORTH_LOOP_POP
b2bb			 
b2bb				FORTH_RSP_POP     ; get rid of DO ptr 
b2bb cd 6e 9c			call macro_forth_rsp_pop 
b2be				endm 
# End of macro FORTH_RSP_POP
b2be			 
b2be			if DEBUG_FORTH_WORDS 
b2be						DMARK "LP>" 
b2be f5				push af  
b2bf 3a d3 b2			ld a, (.dmark)  
b2c2 32 6b ee			ld (debug_mark),a  
b2c5 3a d4 b2			ld a, (.dmark+1)  
b2c8 32 6c ee			ld (debug_mark+1),a  
b2cb 3a d5 b2			ld a, (.dmark+2)  
b2ce 32 6d ee			ld (debug_mark+2),a  
b2d1 18 03			jr .pastdmark  
b2d3 ..			.dmark: db "LP>"  
b2d6 f1			.pastdmark: pop af  
b2d7			endm  
# End of macro DMARK
b2d7				CALLMONITOR 
b2d7 cd 6f ee			call debug_vector  
b2da				endm  
# End of macro CALLMONITOR
b2da			endif 
b2da			 
b2da					NEXTW 
b2da c3 53 a0			jp macro_next 
b2dd				endm 
# End of macro NEXTW
b2dd				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b2dd			 
b2dd			.loopnotdone: 
b2dd			 
b2dd e1				pop hl    ; get I 
b2de 23				inc hl 
b2df			 
b2df			   	; save new I 
b2df			 
b2df			 
b2df					; set I counter 
b2df			 
b2df 22 e6 e5				ld (os_current_i), hl 
b2e2			 
b2e2					if DEBUG_FORTH_WORDS 
b2e2						DMARK "LPN" 
b2e2 f5				push af  
b2e3 3a f7 b2			ld a, (.dmark)  
b2e6 32 6b ee			ld (debug_mark),a  
b2e9 3a f8 b2			ld a, (.dmark+1)  
b2ec 32 6c ee			ld (debug_mark+1),a  
b2ef 3a f9 b2			ld a, (.dmark+2)  
b2f2 32 6d ee			ld (debug_mark+2),a  
b2f5 18 03			jr .pastdmark  
b2f7 ..			.dmark: db "LPN"  
b2fa f1			.pastdmark: pop af  
b2fb			endm  
# End of macro DMARK
b2fb					CALLMONITOR 
b2fb cd 6f ee			call debug_vector  
b2fe				endm  
# End of macro CALLMONITOR
b2fe					endif 
b2fe					 
b2fe				FORTH_LOOP_NEXT 
b2fe cd ce 9e			call macro_forth_loop_next 
b301				endm 
# End of macro FORTH_LOOP_NEXT
b301			 
b301			 
b301					if DEBUG_FORTH_WORDS 
b301 eb						ex de,hl 
b302					endif 
b302			 
b302			;	; get DO ptr 
b302			; 
b302					if DEBUG_FORTH_WORDS 
b302						DMARK "LP7" 
b302 f5				push af  
b303 3a 17 b3			ld a, (.dmark)  
b306 32 6b ee			ld (debug_mark),a  
b309 3a 18 b3			ld a, (.dmark+1)  
b30c 32 6c ee			ld (debug_mark+1),a  
b30f 3a 19 b3			ld a, (.dmark+2)  
b312 32 6d ee			ld (debug_mark+2),a  
b315 18 03			jr .pastdmark  
b317 ..			.dmark: db "LP7"  
b31a f1			.pastdmark: pop af  
b31b			endm  
# End of macro DMARK
b31b					CALLMONITOR 
b31b cd 6f ee			call debug_vector  
b31e				endm  
# End of macro CALLMONITOR
b31e					endif 
b31e				FORTH_RSP_TOS 
b31e cd 64 9c			call macro_forth_rsp_tos 
b321				endm 
# End of macro FORTH_RSP_TOS
b321			 
b321					if DEBUG_FORTH_WORDS 
b321						DMARK "LP8" 
b321 f5				push af  
b322 3a 36 b3			ld a, (.dmark)  
b325 32 6b ee			ld (debug_mark),a  
b328 3a 37 b3			ld a, (.dmark+1)  
b32b 32 6c ee			ld (debug_mark+1),a  
b32e 3a 38 b3			ld a, (.dmark+2)  
b331 32 6d ee			ld (debug_mark+2),a  
b334 18 03			jr .pastdmark  
b336 ..			.dmark: db "LP8"  
b339 f1			.pastdmark: pop af  
b33a			endm  
# End of macro DMARK
b33a					CALLMONITOR 
b33a cd 6f ee			call debug_vector  
b33d				endm  
# End of macro CALLMONITOR
b33d					endif 
b33d				;push hl 
b33d			 
b33d				; not going to DO any more 
b33d				; get rid of the RSP pointer as DO will add it back in 
b33d				;FORTH_RSP_POP 
b33d				;pop hl 
b33d			 
b33d				;ld hl,(cli_ret_sp) 
b33d				;ld e, (hl) 
b33d				;inc hl 
b33d				;ld d, (hl) 
b33d				;ex de,hl 
b33d 22 c2 e5			ld (os_tok_ptr), hl 
b340					if DEBUG_FORTH_WORDS 
b340						DMARK "LP<" 
b340 f5				push af  
b341 3a 55 b3			ld a, (.dmark)  
b344 32 6b ee			ld (debug_mark),a  
b347 3a 56 b3			ld a, (.dmark+1)  
b34a 32 6c ee			ld (debug_mark+1),a  
b34d 3a 57 b3			ld a, (.dmark+2)  
b350 32 6d ee			ld (debug_mark+2),a  
b353 18 03			jr .pastdmark  
b355 ..			.dmark: db "LP<"  
b358 f1			.pastdmark: pop af  
b359			endm  
# End of macro DMARK
b359					CALLMONITOR 
b359 cd 6f ee			call debug_vector  
b35c				endm  
# End of macro CALLMONITOR
b35c				endif 
b35c c3 e4 a0			jp exec1 
b35f			 
b35f					 
b35f			 
b35f			 
b35f					NEXTW 
b35f c3 53 a0			jp macro_next 
b362				endm 
# End of macro NEXTW
b362			.I:  
b362			 
b362				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
b362 5e				db WORD_SYS_CORE+74             
b363 8d b3			dw .DLOOP            
b365 02				db 1 + 1 
b366 .. 00			db "I",0              
b368				endm 
# End of macro CWHEAD
b368			; | I ( -- ) Current loop counter | DONE 
b368					if DEBUG_FORTH_WORDS_KEY 
b368						DMARK "I.." 
b368 f5				push af  
b369 3a 7d b3			ld a, (.dmark)  
b36c 32 6b ee			ld (debug_mark),a  
b36f 3a 7e b3			ld a, (.dmark+1)  
b372 32 6c ee			ld (debug_mark+1),a  
b375 3a 7f b3			ld a, (.dmark+2)  
b378 32 6d ee			ld (debug_mark+2),a  
b37b 18 03			jr .pastdmark  
b37d ..			.dmark: db "I.."  
b380 f1			.pastdmark: pop af  
b381			endm  
# End of macro DMARK
b381						CALLMONITOR 
b381 cd 6f ee			call debug_vector  
b384				endm  
# End of macro CALLMONITOR
b384					endif 
b384			 
b384 2a e6 e5				ld hl,(os_current_i) 
b387 cd a6 9c				call forth_push_numhl 
b38a			 
b38a					NEXTW 
b38a c3 53 a0			jp macro_next 
b38d				endm 
# End of macro NEXTW
b38d			.DLOOP: 
b38d				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
b38d 5f				db WORD_SYS_CORE+75             
b38e 6e b4			dw .REPEAT            
b390 06				db 5 + 1 
b391 .. 00			db "-LOOP",0              
b397				endm 
# End of macro CWHEAD
b397			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
b397				; pop tos as current loop count to hl 
b397					if DEBUG_FORTH_WORDS_KEY 
b397						DMARK "-LP" 
b397 f5				push af  
b398 3a ac b3			ld a, (.dmark)  
b39b 32 6b ee			ld (debug_mark),a  
b39e 3a ad b3			ld a, (.dmark+1)  
b3a1 32 6c ee			ld (debug_mark+1),a  
b3a4 3a ae b3			ld a, (.dmark+2)  
b3a7 32 6d ee			ld (debug_mark+2),a  
b3aa 18 03			jr .pastdmark  
b3ac ..			.dmark: db "-LP"  
b3af f1			.pastdmark: pop af  
b3b0			endm  
# End of macro DMARK
b3b0						CALLMONITOR 
b3b0 cd 6f ee			call debug_vector  
b3b3				endm  
# End of macro CALLMONITOR
b3b3					endif 
b3b3			 
b3b3				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b3b3			 
b3b3				FORTH_LOOP_TOS 
b3b3 cd 01 9f			call macro_forth_loop_tos 
b3b6				endm 
# End of macro FORTH_LOOP_TOS
b3b6 e5				push hl 
b3b7			 
b3b7					if DEBUG_FORTH_WORDS 
b3b7						DMARK "-LP" 
b3b7 f5				push af  
b3b8 3a cc b3			ld a, (.dmark)  
b3bb 32 6b ee			ld (debug_mark),a  
b3be 3a cd b3			ld a, (.dmark+1)  
b3c1 32 6c ee			ld (debug_mark+1),a  
b3c4 3a ce b3			ld a, (.dmark+2)  
b3c7 32 6d ee			ld (debug_mark+2),a  
b3ca 18 03			jr .pastdmark  
b3cc ..			.dmark: db "-LP"  
b3cf f1			.pastdmark: pop af  
b3d0			endm  
# End of macro DMARK
b3d0						CALLMONITOR 
b3d0 cd 6f ee			call debug_vector  
b3d3				endm  
# End of macro CALLMONITOR
b3d3					endif 
b3d3				; next item on the stack is the limit. get it 
b3d3			 
b3d3			 
b3d3				FORTH_LOOP_POP 
b3d3 cd 0b 9f			call macro_forth_loop_pop 
b3d6				endm 
# End of macro FORTH_LOOP_POP
b3d6			 
b3d6				FORTH_LOOP_TOS 
b3d6 cd 01 9f			call macro_forth_loop_tos 
b3d9				endm 
# End of macro FORTH_LOOP_TOS
b3d9			 
b3d9 d1				pop de		 ; de = i, hl = limit 
b3da			 
b3da					if DEBUG_FORTH_WORDS 
b3da						DMARK "-L1" 
b3da f5				push af  
b3db 3a ef b3			ld a, (.dmark)  
b3de 32 6b ee			ld (debug_mark),a  
b3e1 3a f0 b3			ld a, (.dmark+1)  
b3e4 32 6c ee			ld (debug_mark+1),a  
b3e7 3a f1 b3			ld a, (.dmark+2)  
b3ea 32 6d ee			ld (debug_mark+2),a  
b3ed 18 03			jr .pastdmark  
b3ef ..			.dmark: db "-L1"  
b3f2 f1			.pastdmark: pop af  
b3f3			endm  
# End of macro DMARK
b3f3						CALLMONITOR 
b3f3 cd 6f ee			call debug_vector  
b3f6				endm  
# End of macro CALLMONITOR
b3f6					endif 
b3f6			 
b3f6				; go back to previous word 
b3f6			 
b3f6 d5				push de    ; save I for inc later 
b3f7			 
b3f7			 
b3f7				; get limit 
b3f7				;  is I at limit? 
b3f7			 
b3f7			 
b3f7					if DEBUG_FORTH_WORDS 
b3f7						DMARK "-L1" 
b3f7 f5				push af  
b3f8 3a 0c b4			ld a, (.dmark)  
b3fb 32 6b ee			ld (debug_mark),a  
b3fe 3a 0d b4			ld a, (.dmark+1)  
b401 32 6c ee			ld (debug_mark+1),a  
b404 3a 0e b4			ld a, (.dmark+2)  
b407 32 6d ee			ld (debug_mark+2),a  
b40a 18 03			jr .pastdmark  
b40c ..			.dmark: db "-L1"  
b40f f1			.pastdmark: pop af  
b410			endm  
# End of macro DMARK
b410						CALLMONITOR 
b410 cd 6f ee			call debug_vector  
b413				endm  
# End of macro CALLMONITOR
b413					endif 
b413			 
b413 ed 52			sbc hl, de 
b415			 
b415			 
b415				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b415			 
b415 20 26				jr nz, .mloopnotdone 
b417			 
b417 e1				pop hl   ; get rid of saved I 
b418				FORTH_LOOP_POP     ; get rid of limit 
b418 cd 0b 9f			call macro_forth_loop_pop 
b41b				endm 
# End of macro FORTH_LOOP_POP
b41b			 
b41b				FORTH_RSP_POP     ; get rid of DO ptr 
b41b cd 6e 9c			call macro_forth_rsp_pop 
b41e				endm 
# End of macro FORTH_RSP_POP
b41e			 
b41e			if DEBUG_FORTH_WORDS 
b41e						DMARK "-L>" 
b41e f5				push af  
b41f 3a 33 b4			ld a, (.dmark)  
b422 32 6b ee			ld (debug_mark),a  
b425 3a 34 b4			ld a, (.dmark+1)  
b428 32 6c ee			ld (debug_mark+1),a  
b42b 3a 35 b4			ld a, (.dmark+2)  
b42e 32 6d ee			ld (debug_mark+2),a  
b431 18 03			jr .pastdmark  
b433 ..			.dmark: db "-L>"  
b436 f1			.pastdmark: pop af  
b437			endm  
# End of macro DMARK
b437				CALLMONITOR 
b437 cd 6f ee			call debug_vector  
b43a				endm  
# End of macro CALLMONITOR
b43a			endif 
b43a			 
b43a					NEXTW 
b43a c3 53 a0			jp macro_next 
b43d				endm 
# End of macro NEXTW
b43d				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b43d			 
b43d			.mloopnotdone: 
b43d			 
b43d e1				pop hl    ; get I 
b43e 2b				dec hl 
b43f			 
b43f			   	; save new I 
b43f			 
b43f			 
b43f					; set I counter 
b43f			 
b43f 22 e6 e5				ld (os_current_i), hl 
b442			 
b442					 
b442				FORTH_LOOP_NEXT 
b442 cd ce 9e			call macro_forth_loop_next 
b445				endm 
# End of macro FORTH_LOOP_NEXT
b445			 
b445			 
b445					if DEBUG_FORTH_WORDS 
b445 eb						ex de,hl 
b446					endif 
b446			 
b446			;	; get DO ptr 
b446			; 
b446				FORTH_RSP_TOS 
b446 cd 64 9c			call macro_forth_rsp_tos 
b449				endm 
# End of macro FORTH_RSP_TOS
b449			 
b449				;push hl 
b449			 
b449				; not going to DO any more 
b449				; get rid of the RSP pointer as DO will add it back in 
b449				;FORTH_RSP_POP 
b449				;pop hl 
b449			 
b449			 
b449 22 c2 e5			ld (os_tok_ptr), hl 
b44c					if DEBUG_FORTH_WORDS 
b44c						DMARK "-L<" 
b44c f5				push af  
b44d 3a 61 b4			ld a, (.dmark)  
b450 32 6b ee			ld (debug_mark),a  
b453 3a 62 b4			ld a, (.dmark+1)  
b456 32 6c ee			ld (debug_mark+1),a  
b459 3a 63 b4			ld a, (.dmark+2)  
b45c 32 6d ee			ld (debug_mark+2),a  
b45f 18 03			jr .pastdmark  
b461 ..			.dmark: db "-L<"  
b464 f1			.pastdmark: pop af  
b465			endm  
# End of macro DMARK
b465					CALLMONITOR 
b465 cd 6f ee			call debug_vector  
b468				endm  
# End of macro CALLMONITOR
b468				endif 
b468 c3 e4 a0			jp exec1 
b46b			 
b46b					 
b46b			 
b46b			 
b46b			 
b46b				NEXTW 
b46b c3 53 a0			jp macro_next 
b46e				endm 
# End of macro NEXTW
b46e			 
b46e			 
b46e			 
b46e			 
b46e			.REPEAT: 
b46e				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
b46e 71				db WORD_SYS_CORE+93             
b46f c1 b4			dw .UNTIL            
b471 06				db 5 + 1 
b472 .. 00			db "REPEAT",0              
b479				endm 
# End of macro CWHEAD
b479			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
b479			;  push pc to rsp stack past the REPEAT 
b479					if DEBUG_FORTH_WORDS_KEY 
b479						DMARK "REP" 
b479 f5				push af  
b47a 3a 8e b4			ld a, (.dmark)  
b47d 32 6b ee			ld (debug_mark),a  
b480 3a 8f b4			ld a, (.dmark+1)  
b483 32 6c ee			ld (debug_mark+1),a  
b486 3a 90 b4			ld a, (.dmark+2)  
b489 32 6d ee			ld (debug_mark+2),a  
b48c 18 03			jr .pastdmark  
b48e ..			.dmark: db "REP"  
b491 f1			.pastdmark: pop af  
b492			endm  
# End of macro DMARK
b492						CALLMONITOR 
b492 cd 6f ee			call debug_vector  
b495				endm  
# End of macro CALLMONITOR
b495					endif 
b495			 
b495 2a c2 e5				ld hl, (os_tok_ptr) 
b498 23					inc hl   ; R 
b499 23					inc hl  ; E 
b49a 23					inc hl   ; P 
b49b 23					inc hl   ; E 
b49c 23					inc hl   ; A 
b49d 23					inc hl   ; T 
b49e 23					inc hl   ; zero 
b49f					FORTH_RSP_NEXT 
b49f cd 4d 9c			call macro_forth_rsp_next 
b4a2				endm 
# End of macro FORTH_RSP_NEXT
b4a2			 
b4a2			 
b4a2					if DEBUG_FORTH_WORDS 
b4a2						DMARK "REP" 
b4a2 f5				push af  
b4a3 3a b7 b4			ld a, (.dmark)  
b4a6 32 6b ee			ld (debug_mark),a  
b4a9 3a b8 b4			ld a, (.dmark+1)  
b4ac 32 6c ee			ld (debug_mark+1),a  
b4af 3a b9 b4			ld a, (.dmark+2)  
b4b2 32 6d ee			ld (debug_mark+2),a  
b4b5 18 03			jr .pastdmark  
b4b7 ..			.dmark: db "REP"  
b4ba f1			.pastdmark: pop af  
b4bb			endm  
# End of macro DMARK
b4bb						;pop bc    ; TODO BUG ?????? what is this for???? 
b4bb						CALLMONITOR 
b4bb cd 6f ee			call debug_vector  
b4be				endm  
# End of macro CALLMONITOR
b4be					endif 
b4be			 
b4be					NEXTW 
b4be c3 53 a0			jp macro_next 
b4c1				endm 
# End of macro NEXTW
b4c1			;	       NEXTW 
b4c1			 
b4c1			.UNTIL: 
b4c1				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
b4c1 72				db WORD_SYS_CORE+94             
b4c2 58 b5			dw .ENDFLOW            
b4c4 06				db 5 + 1 
b4c5 .. 00			db "UNTIL",0              
b4cb				endm 
# End of macro CWHEAD
b4cb			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
b4cb			 
b4cb				; pop tos as check 
b4cb			 
b4cb				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b4cb			 
b4cb				FORTH_DSP_VALUEHL 
b4cb cd 9d 9e			call macro_dsp_valuehl 
b4ce				endm 
# End of macro FORTH_DSP_VALUEHL
b4ce			 
b4ce					if DEBUG_FORTH_WORDS_KEY 
b4ce						DMARK "UNT" 
b4ce f5				push af  
b4cf 3a e3 b4			ld a, (.dmark)  
b4d2 32 6b ee			ld (debug_mark),a  
b4d5 3a e4 b4			ld a, (.dmark+1)  
b4d8 32 6c ee			ld (debug_mark+1),a  
b4db 3a e5 b4			ld a, (.dmark+2)  
b4de 32 6d ee			ld (debug_mark+2),a  
b4e1 18 03			jr .pastdmark  
b4e3 ..			.dmark: db "UNT"  
b4e6 f1			.pastdmark: pop af  
b4e7			endm  
# End of macro DMARK
b4e7						CALLMONITOR 
b4e7 cd 6f ee			call debug_vector  
b4ea				endm  
# End of macro CALLMONITOR
b4ea					endif 
b4ea			 
b4ea			;	push hl 
b4ea				FORTH_DSP_POP 
b4ea cd 55 9f			call macro_forth_dsp_pop 
b4ed				endm 
# End of macro FORTH_DSP_POP
b4ed			 
b4ed			;	pop hl 
b4ed			 
b4ed				; test if true 
b4ed			 
b4ed cd 04 8d			call ishlzero 
b4f0			;	ld a,l 
b4f0			;	add h 
b4f0			; 
b4f0			;	cp 0 
b4f0			 
b4f0 20 3e			jr nz, .untilnotdone 
b4f2			 
b4f2					if DEBUG_FORTH_WORDS 
b4f2						DMARK "UNf" 
b4f2 f5				push af  
b4f3 3a 07 b5			ld a, (.dmark)  
b4f6 32 6b ee			ld (debug_mark),a  
b4f9 3a 08 b5			ld a, (.dmark+1)  
b4fc 32 6c ee			ld (debug_mark+1),a  
b4ff 3a 09 b5			ld a, (.dmark+2)  
b502 32 6d ee			ld (debug_mark+2),a  
b505 18 03			jr .pastdmark  
b507 ..			.dmark: db "UNf"  
b50a f1			.pastdmark: pop af  
b50b			endm  
# End of macro DMARK
b50b						CALLMONITOR 
b50b cd 6f ee			call debug_vector  
b50e				endm  
# End of macro CALLMONITOR
b50e					endif 
b50e			 
b50e			 
b50e			 
b50e				FORTH_RSP_POP     ; get rid of DO ptr 
b50e cd 6e 9c			call macro_forth_rsp_pop 
b511				endm 
# End of macro FORTH_RSP_POP
b511			 
b511			if DEBUG_FORTH_WORDS 
b511						DMARK "UN>" 
b511 f5				push af  
b512 3a 26 b5			ld a, (.dmark)  
b515 32 6b ee			ld (debug_mark),a  
b518 3a 27 b5			ld a, (.dmark+1)  
b51b 32 6c ee			ld (debug_mark+1),a  
b51e 3a 28 b5			ld a, (.dmark+2)  
b521 32 6d ee			ld (debug_mark+2),a  
b524 18 03			jr .pastdmark  
b526 ..			.dmark: db "UN>"  
b529 f1			.pastdmark: pop af  
b52a			endm  
# End of macro DMARK
b52a				CALLMONITOR 
b52a cd 6f ee			call debug_vector  
b52d				endm  
# End of macro CALLMONITOR
b52d			endif 
b52d			 
b52d					NEXTW 
b52d c3 53 a0			jp macro_next 
b530				endm 
# End of macro NEXTW
b530				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b530			 
b530			.untilnotdone: 
b530			 
b530			 
b530			;	; get DO ptr 
b530			; 
b530				FORTH_RSP_TOS 
b530 cd 64 9c			call macro_forth_rsp_tos 
b533				endm 
# End of macro FORTH_RSP_TOS
b533			 
b533				;push hl 
b533			 
b533				; not going to DO any more 
b533				; get rid of the RSP pointer as DO will add it back in 
b533				;FORTH_RSP_POP 
b533				;pop hl 
b533			 
b533			 
b533 22 c2 e5			ld (os_tok_ptr), hl 
b536					if DEBUG_FORTH_WORDS 
b536						DMARK "UN<" 
b536 f5				push af  
b537 3a 4b b5			ld a, (.dmark)  
b53a 32 6b ee			ld (debug_mark),a  
b53d 3a 4c b5			ld a, (.dmark+1)  
b540 32 6c ee			ld (debug_mark+1),a  
b543 3a 4d b5			ld a, (.dmark+2)  
b546 32 6d ee			ld (debug_mark+2),a  
b549 18 03			jr .pastdmark  
b54b ..			.dmark: db "UN<"  
b54e f1			.pastdmark: pop af  
b54f			endm  
# End of macro DMARK
b54f					CALLMONITOR 
b54f cd 6f ee			call debug_vector  
b552				endm  
# End of macro CALLMONITOR
b552				endif 
b552 c3 e4 a0			jp exec1 
b555			 
b555					 
b555			 
b555			 
b555					NEXTW 
b555 c3 53 a0			jp macro_next 
b558				endm 
# End of macro NEXTW
b558			 
b558			 
b558			.ENDFLOW: 
b558			 
b558			; eof 
b558			 
# End of file forth_words_flow.asm
b558			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
b558			include "forth_words_logic.asm" 
b558			 
b558			; | ## Logic Words 
b558			 
b558			.NOT: 
b558				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
b558 2d				db WORD_SYS_CORE+25             
b559 a0 b5			dw .IS            
b55b 04				db 3 + 1 
b55c .. 00			db "NOT",0              
b560				endm 
# End of macro CWHEAD
b560			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
b560					if DEBUG_FORTH_WORDS_KEY 
b560						DMARK "NOT" 
b560 f5				push af  
b561 3a 75 b5			ld a, (.dmark)  
b564 32 6b ee			ld (debug_mark),a  
b567 3a 76 b5			ld a, (.dmark+1)  
b56a 32 6c ee			ld (debug_mark+1),a  
b56d 3a 77 b5			ld a, (.dmark+2)  
b570 32 6d ee			ld (debug_mark+2),a  
b573 18 03			jr .pastdmark  
b575 ..			.dmark: db "NOT"  
b578 f1			.pastdmark: pop af  
b579			endm  
# End of macro DMARK
b579						CALLMONITOR 
b579 cd 6f ee			call debug_vector  
b57c				endm  
# End of macro CALLMONITOR
b57c					endif 
b57c					FORTH_DSP 
b57c cd 63 9e			call macro_forth_dsp 
b57f				endm 
# End of macro FORTH_DSP
b57f 7e					ld a,(hl)	; get type of value on TOS 
b580 fe 02				cp DS_TYPE_INUM  
b582 28 03				jr z, .noti 
b584					NEXTW 
b584 c3 53 a0			jp macro_next 
b587				endm 
# End of macro NEXTW
b587			.noti:          FORTH_DSP_VALUEHL 
b587 cd 9d 9e			call macro_dsp_valuehl 
b58a				endm 
# End of macro FORTH_DSP_VALUEHL
b58a			;		push hl 
b58a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b58a cd 55 9f			call macro_forth_dsp_pop 
b58d				endm 
# End of macro FORTH_DSP_POP
b58d			;		pop hl 
b58d 3e 00				ld a,0 
b58f bd					cp l 
b590 28 04				jr z, .not2t 
b592 2e 00				ld l, 0 
b594 18 02				jr .notip 
b596			 
b596 2e ff		.not2t:		ld l, 255 
b598			 
b598 26 00		.notip:		ld h, 0	 
b59a			 
b59a cd a6 9c				call forth_push_numhl 
b59d					NEXTW 
b59d c3 53 a0			jp macro_next 
b5a0				endm 
# End of macro NEXTW
b5a0			 
b5a0			.IS: 
b5a0				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
b5a0 2d				db WORD_SYS_CORE+25             
b5a1 c6 b5			dw .LZERO            
b5a3 03				db 2 + 1 
b5a4 .. 00			db "IS",0              
b5a7				endm 
# End of macro CWHEAD
b5a7			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
b5a7					if DEBUG_FORTH_WORDS_KEY 
b5a7						DMARK "IS." 
b5a7 f5				push af  
b5a8 3a bc b5			ld a, (.dmark)  
b5ab 32 6b ee			ld (debug_mark),a  
b5ae 3a bd b5			ld a, (.dmark+1)  
b5b1 32 6c ee			ld (debug_mark+1),a  
b5b4 3a be b5			ld a, (.dmark+2)  
b5b7 32 6d ee			ld (debug_mark+2),a  
b5ba 18 03			jr .pastdmark  
b5bc ..			.dmark: db "IS."  
b5bf f1			.pastdmark: pop af  
b5c0			endm  
# End of macro DMARK
b5c0						CALLMONITOR 
b5c0 cd 6f ee			call debug_vector  
b5c3				endm  
# End of macro CALLMONITOR
b5c3					endif 
b5c3					NEXTW 
b5c3 c3 53 a0			jp macro_next 
b5c6				endm 
# End of macro NEXTW
b5c6			.LZERO: 
b5c6				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
b5c6 2d				db WORD_SYS_CORE+25             
b5c7 d0 b5			dw .TZERO            
b5c9 03				db 2 + 1 
b5ca .. 00			db "0<",0              
b5cd				endm 
# End of macro CWHEAD
b5cd			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
b5cd					NEXTW 
b5cd c3 53 a0			jp macro_next 
b5d0				endm 
# End of macro NEXTW
b5d0			.TZERO: 
b5d0				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
b5d0 2e				db WORD_SYS_CORE+26             
b5d1 17 b6			dw .LESS            
b5d3 03				db 2 + 1 
b5d4 .. 00			db "0=",0              
b5d7				endm 
# End of macro CWHEAD
b5d7			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
b5d7				; TODO add floating point number detection 
b5d7					;v5 FORTH_DSP_VALUE 
b5d7					if DEBUG_FORTH_WORDS_KEY 
b5d7						DMARK "0=." 
b5d7 f5				push af  
b5d8 3a ec b5			ld a, (.dmark)  
b5db 32 6b ee			ld (debug_mark),a  
b5de 3a ed b5			ld a, (.dmark+1)  
b5e1 32 6c ee			ld (debug_mark+1),a  
b5e4 3a ee b5			ld a, (.dmark+2)  
b5e7 32 6d ee			ld (debug_mark+2),a  
b5ea 18 03			jr .pastdmark  
b5ec ..			.dmark: db "0=."  
b5ef f1			.pastdmark: pop af  
b5f0			endm  
# End of macro DMARK
b5f0						CALLMONITOR 
b5f0 cd 6f ee			call debug_vector  
b5f3				endm  
# End of macro CALLMONITOR
b5f3					endif 
b5f3					FORTH_DSP 
b5f3 cd 63 9e			call macro_forth_dsp 
b5f6				endm 
# End of macro FORTH_DSP
b5f6 7e					ld a,(hl)	; get type of value on TOS 
b5f7 fe 02				cp DS_TYPE_INUM  
b5f9 28 00				jr z, .tz_inum 
b5fb			 
b5fb				if FORTH_ENABLE_FLOATMATH 
b5fb					jr .tz_done 
b5fb			 
b5fb				endif 
b5fb					 
b5fb			 
b5fb			.tz_inum: 
b5fb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b5fb cd 9d 9e			call macro_dsp_valuehl 
b5fe				endm 
# End of macro FORTH_DSP_VALUEHL
b5fe			 
b5fe			;		push hl 
b5fe			 
b5fe					; destroy value TOS 
b5fe			 
b5fe					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5fe cd 55 9f			call macro_forth_dsp_pop 
b601				endm 
# End of macro FORTH_DSP_POP
b601			 
b601			;		pop hl 
b601			 
b601 3e 00				ld a,0 
b603			 
b603 bd					cp l 
b604 20 08				jr nz, .tz_notzero 
b606			 
b606 bc					cp h 
b607			 
b607 20 05				jr nz, .tz_notzero 
b609			 
b609			 
b609 21 01 00				ld hl, FORTH_TRUE 
b60c 18 03				jr .tz_done 
b60e			 
b60e 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
b611			 
b611					; push value back onto stack for another op etc 
b611			 
b611			.tz_done: 
b611 cd a6 9c				call forth_push_numhl 
b614			 
b614					NEXTW 
b614 c3 53 a0			jp macro_next 
b617				endm 
# End of macro NEXTW
b617			.LESS: 
b617				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
b617 2f				db WORD_SYS_CORE+27             
b618 80 b6			dw .GT            
b61a 02				db 1 + 1 
b61b .. 00			db "<",0              
b61d				endm 
# End of macro CWHEAD
b61d			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
b61d				; TODO add floating point number detection 
b61d					if DEBUG_FORTH_WORDS_KEY 
b61d						DMARK "LES" 
b61d f5				push af  
b61e 3a 32 b6			ld a, (.dmark)  
b621 32 6b ee			ld (debug_mark),a  
b624 3a 33 b6			ld a, (.dmark+1)  
b627 32 6c ee			ld (debug_mark+1),a  
b62a 3a 34 b6			ld a, (.dmark+2)  
b62d 32 6d ee			ld (debug_mark+2),a  
b630 18 03			jr .pastdmark  
b632 ..			.dmark: db "LES"  
b635 f1			.pastdmark: pop af  
b636			endm  
# End of macro DMARK
b636						CALLMONITOR 
b636 cd 6f ee			call debug_vector  
b639				endm  
# End of macro CALLMONITOR
b639					endif 
b639					FORTH_DSP 
b639 cd 63 9e			call macro_forth_dsp 
b63c				endm 
# End of macro FORTH_DSP
b63c					;v5 FORTH_DSP_VALUE 
b63c 7e					ld a,(hl)	; get type of value on TOS 
b63d fe 02				cp DS_TYPE_INUM  
b63f 28 00				jr z, .less_inum 
b641			 
b641				if FORTH_ENABLE_FLOATMATH 
b641					jr .less_done 
b641			 
b641				endif 
b641					 
b641			 
b641			.less_inum: 
b641					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b641 cd 9d 9e			call macro_dsp_valuehl 
b644				endm 
# End of macro FORTH_DSP_VALUEHL
b644			 
b644 e5					push hl  ; u2 
b645			 
b645					; destroy value TOS 
b645			 
b645					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b645 cd 55 9f			call macro_forth_dsp_pop 
b648				endm 
# End of macro FORTH_DSP_POP
b648			 
b648			 
b648					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b648 cd 9d 9e			call macro_dsp_valuehl 
b64b				endm 
# End of macro FORTH_DSP_VALUEHL
b64b			 
b64b e5					push hl    ; u1 
b64c			 
b64c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b64c cd 55 9f			call macro_forth_dsp_pop 
b64f				endm 
# End of macro FORTH_DSP_POP
b64f			 
b64f			 
b64f b7			 or a      ;clear carry flag 
b650 01 00 00		 ld bc, FORTH_FALSE 
b653 e1			  pop hl    ; u1 
b654 d1			  pop de    ; u2 
b655 ed 52		  sbc hl,de 
b657 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
b659			 
b659 01 01 00		 ld bc, FORTH_TRUE 
b65c			.lscont:  
b65c c5					push bc 
b65d e1					pop hl 
b65e			 
b65e					if DEBUG_FORTH_WORDS 
b65e						DMARK "LT1" 
b65e f5				push af  
b65f 3a 73 b6			ld a, (.dmark)  
b662 32 6b ee			ld (debug_mark),a  
b665 3a 74 b6			ld a, (.dmark+1)  
b668 32 6c ee			ld (debug_mark+1),a  
b66b 3a 75 b6			ld a, (.dmark+2)  
b66e 32 6d ee			ld (debug_mark+2),a  
b671 18 03			jr .pastdmark  
b673 ..			.dmark: db "LT1"  
b676 f1			.pastdmark: pop af  
b677			endm  
# End of macro DMARK
b677						CALLMONITOR 
b677 cd 6f ee			call debug_vector  
b67a				endm  
# End of macro CALLMONITOR
b67a					endif 
b67a cd a6 9c				call forth_push_numhl 
b67d			 
b67d					NEXTW 
b67d c3 53 a0			jp macro_next 
b680				endm 
# End of macro NEXTW
b680			.GT: 
b680				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
b680 30				db WORD_SYS_CORE+28             
b681 e9 b6			dw .EQUAL            
b683 02				db 1 + 1 
b684 .. 00			db ">",0              
b686				endm 
# End of macro CWHEAD
b686			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
b686				; TODO add floating point number detection 
b686					if DEBUG_FORTH_WORDS_KEY 
b686						DMARK "GRT" 
b686 f5				push af  
b687 3a 9b b6			ld a, (.dmark)  
b68a 32 6b ee			ld (debug_mark),a  
b68d 3a 9c b6			ld a, (.dmark+1)  
b690 32 6c ee			ld (debug_mark+1),a  
b693 3a 9d b6			ld a, (.dmark+2)  
b696 32 6d ee			ld (debug_mark+2),a  
b699 18 03			jr .pastdmark  
b69b ..			.dmark: db "GRT"  
b69e f1			.pastdmark: pop af  
b69f			endm  
# End of macro DMARK
b69f						CALLMONITOR 
b69f cd 6f ee			call debug_vector  
b6a2				endm  
# End of macro CALLMONITOR
b6a2					endif 
b6a2					FORTH_DSP 
b6a2 cd 63 9e			call macro_forth_dsp 
b6a5				endm 
# End of macro FORTH_DSP
b6a5					;FORTH_DSP_VALUE 
b6a5 7e					ld a,(hl)	; get type of value on TOS 
b6a6 fe 02				cp DS_TYPE_INUM  
b6a8 28 00				jr z, .gt_inum 
b6aa			 
b6aa				if FORTH_ENABLE_FLOATMATH 
b6aa					jr .gt_done 
b6aa			 
b6aa				endif 
b6aa					 
b6aa			 
b6aa			.gt_inum: 
b6aa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b6aa cd 9d 9e			call macro_dsp_valuehl 
b6ad				endm 
# End of macro FORTH_DSP_VALUEHL
b6ad			 
b6ad e5					push hl  ; u2 
b6ae			 
b6ae					; destroy value TOS 
b6ae			 
b6ae					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b6ae cd 55 9f			call macro_forth_dsp_pop 
b6b1				endm 
# End of macro FORTH_DSP_POP
b6b1			 
b6b1			 
b6b1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b6b1 cd 9d 9e			call macro_dsp_valuehl 
b6b4				endm 
# End of macro FORTH_DSP_VALUEHL
b6b4			 
b6b4 e5					push hl    ; u1 
b6b5			 
b6b5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b6b5 cd 55 9f			call macro_forth_dsp_pop 
b6b8				endm 
# End of macro FORTH_DSP_POP
b6b8			 
b6b8			 
b6b8 b7			 or a      ;clear carry flag 
b6b9 01 00 00		 ld bc, FORTH_FALSE 
b6bc e1			  pop hl    ; u1 
b6bd d1			  pop de    ; u2 
b6be ed 52		  sbc hl,de 
b6c0 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
b6c2			 
b6c2 01 01 00		 ld bc, FORTH_TRUE 
b6c5			.gtcont:  
b6c5 c5					push bc 
b6c6 e1					pop hl 
b6c7			 
b6c7					if DEBUG_FORTH_WORDS 
b6c7						DMARK "GT1" 
b6c7 f5				push af  
b6c8 3a dc b6			ld a, (.dmark)  
b6cb 32 6b ee			ld (debug_mark),a  
b6ce 3a dd b6			ld a, (.dmark+1)  
b6d1 32 6c ee			ld (debug_mark+1),a  
b6d4 3a de b6			ld a, (.dmark+2)  
b6d7 32 6d ee			ld (debug_mark+2),a  
b6da 18 03			jr .pastdmark  
b6dc ..			.dmark: db "GT1"  
b6df f1			.pastdmark: pop af  
b6e0			endm  
# End of macro DMARK
b6e0						CALLMONITOR 
b6e0 cd 6f ee			call debug_vector  
b6e3				endm  
# End of macro CALLMONITOR
b6e3					endif 
b6e3 cd a6 9c				call forth_push_numhl 
b6e6			 
b6e6					NEXTW 
b6e6 c3 53 a0			jp macro_next 
b6e9				endm 
# End of macro NEXTW
b6e9			.EQUAL: 
b6e9				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
b6e9 31				db WORD_SYS_CORE+29             
b6ea 54 b7			dw .ENDLOGIC            
b6ec 02				db 1 + 1 
b6ed .. 00			db "=",0              
b6ef				endm 
# End of macro CWHEAD
b6ef			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
b6ef				; TODO add floating point number detection 
b6ef					if DEBUG_FORTH_WORDS_KEY 
b6ef						DMARK "EQ." 
b6ef f5				push af  
b6f0 3a 04 b7			ld a, (.dmark)  
b6f3 32 6b ee			ld (debug_mark),a  
b6f6 3a 05 b7			ld a, (.dmark+1)  
b6f9 32 6c ee			ld (debug_mark+1),a  
b6fc 3a 06 b7			ld a, (.dmark+2)  
b6ff 32 6d ee			ld (debug_mark+2),a  
b702 18 03			jr .pastdmark  
b704 ..			.dmark: db "EQ."  
b707 f1			.pastdmark: pop af  
b708			endm  
# End of macro DMARK
b708						CALLMONITOR 
b708 cd 6f ee			call debug_vector  
b70b				endm  
# End of macro CALLMONITOR
b70b					endif 
b70b					FORTH_DSP 
b70b cd 63 9e			call macro_forth_dsp 
b70e				endm 
# End of macro FORTH_DSP
b70e					;v5 FORTH_DSP_VALUE 
b70e 7e					ld a,(hl)	; get type of value on TOS 
b70f fe 02				cp DS_TYPE_INUM  
b711 28 00				jr z, .eq_inum 
b713			 
b713				if FORTH_ENABLE_FLOATMATH 
b713					jr .eq_done 
b713			 
b713				endif 
b713					 
b713			 
b713			.eq_inum: 
b713					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b713 cd 9d 9e			call macro_dsp_valuehl 
b716				endm 
# End of macro FORTH_DSP_VALUEHL
b716			 
b716 e5					push hl 
b717			 
b717					; destroy value TOS 
b717			 
b717					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b717 cd 55 9f			call macro_forth_dsp_pop 
b71a				endm 
# End of macro FORTH_DSP_POP
b71a			 
b71a			 
b71a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b71a cd 9d 9e			call macro_dsp_valuehl 
b71d				endm 
# End of macro FORTH_DSP_VALUEHL
b71d			 
b71d					; one value on hl get other one back 
b71d			 
b71d e5					push hl 
b71e			 
b71e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b71e cd 55 9f			call macro_forth_dsp_pop 
b721				endm 
# End of macro FORTH_DSP_POP
b721			 
b721 0e 00				ld c, FORTH_FALSE 
b723			 
b723 e1					pop hl 
b724 d1					pop de 
b725			 
b725 7b					ld a, e 
b726 bd					cp l 
b727			 
b727 20 06				jr nz, .eq_done 
b729			 
b729 7a					ld a, d 
b72a bc					cp h 
b72b			 
b72b 20 02				jr nz, .eq_done 
b72d			 
b72d 0e 01				ld c, FORTH_TRUE 
b72f					 
b72f			 
b72f			 
b72f			.eq_done: 
b72f			 
b72f					; TODO push value back onto stack for another op etc 
b72f			 
b72f 26 00				ld h, 0 
b731 69					ld l, c 
b732					if DEBUG_FORTH_WORDS 
b732						DMARK "EQ1" 
b732 f5				push af  
b733 3a 47 b7			ld a, (.dmark)  
b736 32 6b ee			ld (debug_mark),a  
b739 3a 48 b7			ld a, (.dmark+1)  
b73c 32 6c ee			ld (debug_mark+1),a  
b73f 3a 49 b7			ld a, (.dmark+2)  
b742 32 6d ee			ld (debug_mark+2),a  
b745 18 03			jr .pastdmark  
b747 ..			.dmark: db "EQ1"  
b74a f1			.pastdmark: pop af  
b74b			endm  
# End of macro DMARK
b74b						CALLMONITOR 
b74b cd 6f ee			call debug_vector  
b74e				endm  
# End of macro CALLMONITOR
b74e					endif 
b74e cd a6 9c				call forth_push_numhl 
b751			 
b751					NEXTW 
b751 c3 53 a0			jp macro_next 
b754				endm 
# End of macro NEXTW
b754			 
b754			 
b754			.ENDLOGIC: 
b754			; eof 
b754			 
b754			 
# End of file forth_words_logic.asm
b754			include "forth_words_maths.asm" 
b754			 
b754			; | ## Maths Words 
b754			 
b754			.PLUS:	 
b754				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
b754 15				db WORD_SYS_CORE+1             
b755 b2 b7			dw .NEG            
b757 02				db 1 + 1 
b758 .. 00			db "+",0              
b75a				endm 
# End of macro CWHEAD
b75a			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
b75a					if DEBUG_FORTH_WORDS_KEY 
b75a						DMARK "PLU" 
b75a f5				push af  
b75b 3a 6f b7			ld a, (.dmark)  
b75e 32 6b ee			ld (debug_mark),a  
b761 3a 70 b7			ld a, (.dmark+1)  
b764 32 6c ee			ld (debug_mark+1),a  
b767 3a 71 b7			ld a, (.dmark+2)  
b76a 32 6d ee			ld (debug_mark+2),a  
b76d 18 03			jr .pastdmark  
b76f ..			.dmark: db "PLU"  
b772 f1			.pastdmark: pop af  
b773			endm  
# End of macro DMARK
b773						CALLMONITOR 
b773 cd 6f ee			call debug_vector  
b776				endm  
# End of macro CALLMONITOR
b776					endif 
b776					; add top two values and push back result 
b776			 
b776					;for v5 FORTH_DSP_VALUE 
b776					FORTH_DSP 
b776 cd 63 9e			call macro_forth_dsp 
b779				endm 
# End of macro FORTH_DSP
b779 7e					ld a,(hl)	; get type of value on TOS 
b77a fe 02				cp DS_TYPE_INUM  
b77c 28 03				jr z, .dot_inum 
b77e			 
b77e					NEXTW 
b77e c3 53 a0			jp macro_next 
b781				endm 
# End of macro NEXTW
b781			 
b781			; float maths 
b781			 
b781				if FORTH_ENABLE_FLOATMATH 
b781						inc hl      ; now at start of numeric as string 
b781			 
b781					if DEBUG_FORTH_MATHS 
b781						DMARK "ADD" 
b781				CALLMONITOR 
b781					endif 
b781			 
b781					;ld ix, hl 
b781					call CON 
b781			 
b781			 
b781					push hl 
b781					 
b781					 
b781			 
b781						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
b781			 
b781					; get next number 
b781			 
b781						FORTH_DSP_VALUE 
b781			 
b781						inc hl      ; now at start of numeric as string 
b781			 
b781					;ld ix, hl 
b781					call CON 
b781			 
b781					push hl 
b781			 
b781			 
b781						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b781			 
b781						; TODO do add 
b781			 
b781						call IADD 
b781			 
b781						; TODO get result back as ascii 
b781			 
b781						; TODO push result  
b781			 
b781			 
b781			 
b781						jr .dot_done 
b781				endif 
b781			 
b781			.dot_inum: 
b781			 
b781			 
b781					if DEBUG_FORTH_DOT 
b781						DMARK "+IT" 
b781 f5				push af  
b782 3a 96 b7			ld a, (.dmark)  
b785 32 6b ee			ld (debug_mark),a  
b788 3a 97 b7			ld a, (.dmark+1)  
b78b 32 6c ee			ld (debug_mark+1),a  
b78e 3a 98 b7			ld a, (.dmark+2)  
b791 32 6d ee			ld (debug_mark+2),a  
b794 18 03			jr .pastdmark  
b796 ..			.dmark: db "+IT"  
b799 f1			.pastdmark: pop af  
b79a			endm  
# End of macro DMARK
b79a				CALLMONITOR 
b79a cd 6f ee			call debug_vector  
b79d				endm  
# End of macro CALLMONITOR
b79d					endif 
b79d			 
b79d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b79d cd 9d 9e			call macro_dsp_valuehl 
b7a0				endm 
# End of macro FORTH_DSP_VALUEHL
b7a0			 
b7a0				; TODO add floating point number detection 
b7a0			 
b7a0 e5					push hl 
b7a1			 
b7a1					; destroy value TOS 
b7a1			 
b7a1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b7a1 cd 55 9f			call macro_forth_dsp_pop 
b7a4				endm 
# End of macro FORTH_DSP_POP
b7a4			 
b7a4			 
b7a4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b7a4 cd 9d 9e			call macro_dsp_valuehl 
b7a7				endm 
# End of macro FORTH_DSP_VALUEHL
b7a7			 
b7a7					; one value on hl get other one back 
b7a7			 
b7a7 d1					pop de 
b7a8			 
b7a8					; do the add 
b7a8			 
b7a8 19					add hl,de 
b7a9			 
b7a9					; save it 
b7a9			 
b7a9			;		push hl	 
b7a9			 
b7a9					; 
b7a9			 
b7a9					; destroy value TOS 
b7a9			 
b7a9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b7a9 cd 55 9f			call macro_forth_dsp_pop 
b7ac				endm 
# End of macro FORTH_DSP_POP
b7ac			 
b7ac					; TODO push value back onto stack for another op etc 
b7ac			 
b7ac			;		pop hl 
b7ac			 
b7ac			.dot_done: 
b7ac cd a6 9c				call forth_push_numhl 
b7af			 
b7af					NEXTW 
b7af c3 53 a0			jp macro_next 
b7b2				endm 
# End of macro NEXTW
b7b2			.NEG: 
b7b2			 
b7b2				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
b7b2 17				db WORD_SYS_CORE+3             
b7b3 f5 b7			dw .DIV            
b7b5 02				db 1 + 1 
b7b6 .. 00			db "-",0              
b7b8				endm 
# End of macro CWHEAD
b7b8			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
b7b8					if DEBUG_FORTH_WORDS_KEY 
b7b8						DMARK "SUB" 
b7b8 f5				push af  
b7b9 3a cd b7			ld a, (.dmark)  
b7bc 32 6b ee			ld (debug_mark),a  
b7bf 3a ce b7			ld a, (.dmark+1)  
b7c2 32 6c ee			ld (debug_mark+1),a  
b7c5 3a cf b7			ld a, (.dmark+2)  
b7c8 32 6d ee			ld (debug_mark+2),a  
b7cb 18 03			jr .pastdmark  
b7cd ..			.dmark: db "SUB"  
b7d0 f1			.pastdmark: pop af  
b7d1			endm  
# End of macro DMARK
b7d1						CALLMONITOR 
b7d1 cd 6f ee			call debug_vector  
b7d4				endm  
# End of macro CALLMONITOR
b7d4					endif 
b7d4			 
b7d4			 
b7d4				; TODO add floating point number detection 
b7d4					; v5 FORTH_DSP_VALUE 
b7d4					FORTH_DSP 
b7d4 cd 63 9e			call macro_forth_dsp 
b7d7				endm 
# End of macro FORTH_DSP
b7d7 7e					ld a,(hl)	; get type of value on TOS 
b7d8 fe 02				cp DS_TYPE_INUM  
b7da 28 03				jr z, .neg_inum 
b7dc			 
b7dc					NEXTW 
b7dc c3 53 a0			jp macro_next 
b7df				endm 
# End of macro NEXTW
b7df			 
b7df			; float maths 
b7df			 
b7df				if FORTH_ENABLE_FLOATMATH 
b7df					jr .neg_done 
b7df			 
b7df				endif 
b7df					 
b7df			 
b7df			.neg_inum: 
b7df					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b7df cd 9d 9e			call macro_dsp_valuehl 
b7e2				endm 
# End of macro FORTH_DSP_VALUEHL
b7e2			 
b7e2 e5					push hl 
b7e3			 
b7e3					; destroy value TOS 
b7e3			 
b7e3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b7e3 cd 55 9f			call macro_forth_dsp_pop 
b7e6				endm 
# End of macro FORTH_DSP_POP
b7e6			 
b7e6			 
b7e6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b7e6 cd 9d 9e			call macro_dsp_valuehl 
b7e9				endm 
# End of macro FORTH_DSP_VALUEHL
b7e9			 
b7e9					; one value on hl get other one back 
b7e9			 
b7e9 d1					pop de 
b7ea			 
b7ea					; do the sub 
b7ea			;		ex de, hl 
b7ea			 
b7ea ed 52				sbc hl,de 
b7ec			 
b7ec					; save it 
b7ec			 
b7ec			;		push hl	 
b7ec			 
b7ec					; 
b7ec			 
b7ec					; destroy value TOS 
b7ec			 
b7ec					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b7ec cd 55 9f			call macro_forth_dsp_pop 
b7ef				endm 
# End of macro FORTH_DSP_POP
b7ef			 
b7ef					; TODO push value back onto stack for another op etc 
b7ef			 
b7ef			;		pop hl 
b7ef			 
b7ef cd a6 9c				call forth_push_numhl 
b7f2			.neg_done: 
b7f2			 
b7f2					NEXTW 
b7f2 c3 53 a0			jp macro_next 
b7f5				endm 
# End of macro NEXTW
b7f5			.DIV: 
b7f5				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
b7f5 18				db WORD_SYS_CORE+4             
b7f6 42 b8			dw .MUL            
b7f8 02				db 1 + 1 
b7f9 .. 00			db "/",0              
b7fb				endm 
# End of macro CWHEAD
b7fb			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
b7fb					if DEBUG_FORTH_WORDS_KEY 
b7fb						DMARK "DIV" 
b7fb f5				push af  
b7fc 3a 10 b8			ld a, (.dmark)  
b7ff 32 6b ee			ld (debug_mark),a  
b802 3a 11 b8			ld a, (.dmark+1)  
b805 32 6c ee			ld (debug_mark+1),a  
b808 3a 12 b8			ld a, (.dmark+2)  
b80b 32 6d ee			ld (debug_mark+2),a  
b80e 18 03			jr .pastdmark  
b810 ..			.dmark: db "DIV"  
b813 f1			.pastdmark: pop af  
b814			endm  
# End of macro DMARK
b814						CALLMONITOR 
b814 cd 6f ee			call debug_vector  
b817				endm  
# End of macro CALLMONITOR
b817					endif 
b817				; TODO add floating point number detection 
b817					; v5 FORTH_DSP_VALUE 
b817					FORTH_DSP 
b817 cd 63 9e			call macro_forth_dsp 
b81a				endm 
# End of macro FORTH_DSP
b81a 7e					ld a,(hl)	; get type of value on TOS 
b81b fe 02				cp DS_TYPE_INUM  
b81d 28 03				jr z, .div_inum 
b81f			 
b81f				if FORTH_ENABLE_FLOATMATH 
b81f					jr .div_done 
b81f			 
b81f				endif 
b81f					NEXTW 
b81f c3 53 a0			jp macro_next 
b822				endm 
# End of macro NEXTW
b822			.div_inum: 
b822			 
b822					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b822 cd 9d 9e			call macro_dsp_valuehl 
b825				endm 
# End of macro FORTH_DSP_VALUEHL
b825			 
b825 e5					push hl    ; to go to bc 
b826			 
b826					; destroy value TOS 
b826			 
b826					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b826 cd 55 9f			call macro_forth_dsp_pop 
b829				endm 
# End of macro FORTH_DSP_POP
b829			 
b829			 
b829					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b829 cd 9d 9e			call macro_dsp_valuehl 
b82c				endm 
# End of macro FORTH_DSP_VALUEHL
b82c			 
b82c					; hl to go to de 
b82c			 
b82c e5					push hl 
b82d			 
b82d c1					pop bc 
b82e d1					pop de		 
b82f			 
b82f			 
b82f					if DEBUG_FORTH_MATHS 
b82f						DMARK "DIV" 
b82f				CALLMONITOR 
b82f					endif 
b82f					; one value on hl but move to a get other one back 
b82f			 
b82f			        
b82f cd 38 8c			call Div16 
b832			 
b832			;	push af	 
b832 e5				push hl 
b833 c5				push bc 
b834			 
b834					if DEBUG_FORTH_MATHS 
b834						DMARK "DI1" 
b834				CALLMONITOR 
b834					endif 
b834			 
b834					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b834 cd 55 9f			call macro_forth_dsp_pop 
b837				endm 
# End of macro FORTH_DSP_POP
b837			 
b837			 
b837			 
b837 e1					pop hl    ; result 
b838			 
b838 cd a6 9c				call forth_push_numhl 
b83b			 
b83b e1					pop hl    ; reminder 
b83c			;		ld h,0 
b83c			;		ld l,d 
b83c			 
b83c cd a6 9c				call forth_push_numhl 
b83f			.div_done: 
b83f					NEXTW 
b83f c3 53 a0			jp macro_next 
b842				endm 
# End of macro NEXTW
b842			.MUL: 
b842				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
b842 19				db WORD_SYS_CORE+5             
b843 87 b8			dw .MIN            
b845 02				db 1 + 1 
b846 .. 00			db "*",0              
b848				endm 
# End of macro CWHEAD
b848			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
b848				; TODO add floating point number detection 
b848					if DEBUG_FORTH_WORDS_KEY 
b848						DMARK "MUL" 
b848 f5				push af  
b849 3a 5d b8			ld a, (.dmark)  
b84c 32 6b ee			ld (debug_mark),a  
b84f 3a 5e b8			ld a, (.dmark+1)  
b852 32 6c ee			ld (debug_mark+1),a  
b855 3a 5f b8			ld a, (.dmark+2)  
b858 32 6d ee			ld (debug_mark+2),a  
b85b 18 03			jr .pastdmark  
b85d ..			.dmark: db "MUL"  
b860 f1			.pastdmark: pop af  
b861			endm  
# End of macro DMARK
b861						CALLMONITOR 
b861 cd 6f ee			call debug_vector  
b864				endm  
# End of macro CALLMONITOR
b864					endif 
b864					FORTH_DSP 
b864 cd 63 9e			call macro_forth_dsp 
b867				endm 
# End of macro FORTH_DSP
b867					; v5 FORTH_DSP_VALUE 
b867 7e					ld a,(hl)	; get type of value on TOS 
b868 fe 02				cp DS_TYPE_INUM  
b86a 28 03				jr z, .mul_inum 
b86c			 
b86c				if FORTH_ENABLE_FLOATMATH 
b86c					jr .mul_done 
b86c			 
b86c				endif 
b86c			 
b86c					NEXTW 
b86c c3 53 a0			jp macro_next 
b86f				endm 
# End of macro NEXTW
b86f			.mul_inum:	 
b86f			 
b86f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b86f cd 9d 9e			call macro_dsp_valuehl 
b872				endm 
# End of macro FORTH_DSP_VALUEHL
b872			 
b872 e5					push hl 
b873			 
b873					; destroy value TOS 
b873			 
b873					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b873 cd 55 9f			call macro_forth_dsp_pop 
b876				endm 
# End of macro FORTH_DSP_POP
b876			 
b876			 
b876					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b876 cd 9d 9e			call macro_dsp_valuehl 
b879				endm 
# End of macro FORTH_DSP_VALUEHL
b879			 
b879					; one value on hl but move to a get other one back 
b879			 
b879 7d					ld a, l 
b87a			 
b87a d1					pop de 
b87b			 
b87b					; do the mull 
b87b			;		ex de, hl 
b87b			 
b87b cd 5e 8c				call Mult16 
b87e					; save it 
b87e			 
b87e			;		push hl	 
b87e			 
b87e					; 
b87e			 
b87e					; destroy value TOS 
b87e			 
b87e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b87e cd 55 9f			call macro_forth_dsp_pop 
b881				endm 
# End of macro FORTH_DSP_POP
b881			 
b881					; TODO push value back onto stack for another op etc 
b881			 
b881			;		pop hl 
b881			 
b881 cd a6 9c				call forth_push_numhl 
b884			 
b884			.mul_done: 
b884					NEXTW 
b884 c3 53 a0			jp macro_next 
b887				endm 
# End of macro NEXTW
b887			 
b887			 
b887			 
b887			 
b887			.MIN: 
b887				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
b887 49				db WORD_SYS_CORE+53             
b888 08 b9			dw .MAX            
b88a 04				db 3 + 1 
b88b .. 00			db "MIN",0              
b88f				endm 
# End of macro CWHEAD
b88f			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
b88f					if DEBUG_FORTH_WORDS_KEY 
b88f						DMARK "MIN" 
b88f f5				push af  
b890 3a a4 b8			ld a, (.dmark)  
b893 32 6b ee			ld (debug_mark),a  
b896 3a a5 b8			ld a, (.dmark+1)  
b899 32 6c ee			ld (debug_mark+1),a  
b89c 3a a6 b8			ld a, (.dmark+2)  
b89f 32 6d ee			ld (debug_mark+2),a  
b8a2 18 03			jr .pastdmark  
b8a4 ..			.dmark: db "MIN"  
b8a7 f1			.pastdmark: pop af  
b8a8			endm  
# End of macro DMARK
b8a8						CALLMONITOR 
b8a8 cd 6f ee			call debug_vector  
b8ab				endm  
# End of macro CALLMONITOR
b8ab					endif 
b8ab					; get u2 
b8ab			 
b8ab					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b8ab cd 9d 9e			call macro_dsp_valuehl 
b8ae				endm 
# End of macro FORTH_DSP_VALUEHL
b8ae			 
b8ae e5					push hl   ; u2 
b8af			 
b8af					; destroy value TOS 
b8af			 
b8af					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b8af cd 55 9f			call macro_forth_dsp_pop 
b8b2				endm 
# End of macro FORTH_DSP_POP
b8b2			 
b8b2					; get u1 
b8b2			 
b8b2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b8b2 cd 9d 9e			call macro_dsp_valuehl 
b8b5				endm 
# End of macro FORTH_DSP_VALUEHL
b8b5			 
b8b5 e5					push hl  ; u1 
b8b6			 
b8b6					; destroy value TOS 
b8b6			 
b8b6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b8b6 cd 55 9f			call macro_forth_dsp_pop 
b8b9				endm 
# End of macro FORTH_DSP_POP
b8b9			 
b8b9 b7			 or a      ;clear carry flag 
b8ba e1			  pop hl    ; u1 
b8bb d1			  pop de    ; u2 
b8bc e5				push hl   ; saved in case hl is lowest 
b8bd ed 52		  sbc hl,de 
b8bf 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
b8c1			 
b8c1 e1				pop hl 
b8c2					if DEBUG_FORTH_WORDS 
b8c2						DMARK "MIN" 
b8c2 f5				push af  
b8c3 3a d7 b8			ld a, (.dmark)  
b8c6 32 6b ee			ld (debug_mark),a  
b8c9 3a d8 b8			ld a, (.dmark+1)  
b8cc 32 6c ee			ld (debug_mark+1),a  
b8cf 3a d9 b8			ld a, (.dmark+2)  
b8d2 32 6d ee			ld (debug_mark+2),a  
b8d5 18 03			jr .pastdmark  
b8d7 ..			.dmark: db "MIN"  
b8da f1			.pastdmark: pop af  
b8db			endm  
# End of macro DMARK
b8db						CALLMONITOR 
b8db cd 6f ee			call debug_vector  
b8de				endm  
# End of macro CALLMONITOR
b8de					endif 
b8de cd a6 9c				call forth_push_numhl 
b8e1			 
b8e1				       NEXTW 
b8e1 c3 53 a0			jp macro_next 
b8e4				endm 
# End of macro NEXTW
b8e4			 
b8e4			.mincont:  
b8e4 c1				pop bc   ; tidy up 
b8e5 eb				ex de , hl  
b8e6					if DEBUG_FORTH_WORDS 
b8e6						DMARK "MI1" 
b8e6 f5				push af  
b8e7 3a fb b8			ld a, (.dmark)  
b8ea 32 6b ee			ld (debug_mark),a  
b8ed 3a fc b8			ld a, (.dmark+1)  
b8f0 32 6c ee			ld (debug_mark+1),a  
b8f3 3a fd b8			ld a, (.dmark+2)  
b8f6 32 6d ee			ld (debug_mark+2),a  
b8f9 18 03			jr .pastdmark  
b8fb ..			.dmark: db "MI1"  
b8fe f1			.pastdmark: pop af  
b8ff			endm  
# End of macro DMARK
b8ff						CALLMONITOR 
b8ff cd 6f ee			call debug_vector  
b902				endm  
# End of macro CALLMONITOR
b902					endif 
b902 cd a6 9c				call forth_push_numhl 
b905			 
b905				       NEXTW 
b905 c3 53 a0			jp macro_next 
b908				endm 
# End of macro NEXTW
b908			.MAX: 
b908				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
b908 4a				db WORD_SYS_CORE+54             
b909 89 b9			dw .RND16            
b90b 04				db 3 + 1 
b90c .. 00			db "MAX",0              
b910				endm 
# End of macro CWHEAD
b910			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
b910					if DEBUG_FORTH_WORDS_KEY 
b910						DMARK "MAX" 
b910 f5				push af  
b911 3a 25 b9			ld a, (.dmark)  
b914 32 6b ee			ld (debug_mark),a  
b917 3a 26 b9			ld a, (.dmark+1)  
b91a 32 6c ee			ld (debug_mark+1),a  
b91d 3a 27 b9			ld a, (.dmark+2)  
b920 32 6d ee			ld (debug_mark+2),a  
b923 18 03			jr .pastdmark  
b925 ..			.dmark: db "MAX"  
b928 f1			.pastdmark: pop af  
b929			endm  
# End of macro DMARK
b929						CALLMONITOR 
b929 cd 6f ee			call debug_vector  
b92c				endm  
# End of macro CALLMONITOR
b92c					endif 
b92c					; get u2 
b92c			 
b92c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b92c cd 9d 9e			call macro_dsp_valuehl 
b92f				endm 
# End of macro FORTH_DSP_VALUEHL
b92f			 
b92f e5					push hl   ; u2 
b930			 
b930					; destroy value TOS 
b930			 
b930					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b930 cd 55 9f			call macro_forth_dsp_pop 
b933				endm 
# End of macro FORTH_DSP_POP
b933			 
b933					; get u1 
b933			 
b933					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b933 cd 9d 9e			call macro_dsp_valuehl 
b936				endm 
# End of macro FORTH_DSP_VALUEHL
b936			 
b936 e5					push hl  ; u1 
b937			 
b937					; destroy value TOS 
b937			 
b937					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b937 cd 55 9f			call macro_forth_dsp_pop 
b93a				endm 
# End of macro FORTH_DSP_POP
b93a			 
b93a b7			 or a      ;clear carry flag 
b93b e1			  pop hl    ; u1 
b93c d1			  pop de    ; u2 
b93d e5				push hl   ; saved in case hl is lowest 
b93e ed 52		  sbc hl,de 
b940 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
b942			 
b942 e1				pop hl 
b943					if DEBUG_FORTH_WORDS 
b943						DMARK "MAX" 
b943 f5				push af  
b944 3a 58 b9			ld a, (.dmark)  
b947 32 6b ee			ld (debug_mark),a  
b94a 3a 59 b9			ld a, (.dmark+1)  
b94d 32 6c ee			ld (debug_mark+1),a  
b950 3a 5a b9			ld a, (.dmark+2)  
b953 32 6d ee			ld (debug_mark+2),a  
b956 18 03			jr .pastdmark  
b958 ..			.dmark: db "MAX"  
b95b f1			.pastdmark: pop af  
b95c			endm  
# End of macro DMARK
b95c						CALLMONITOR 
b95c cd 6f ee			call debug_vector  
b95f				endm  
# End of macro CALLMONITOR
b95f					endif 
b95f cd a6 9c				call forth_push_numhl 
b962			 
b962				       NEXTW 
b962 c3 53 a0			jp macro_next 
b965				endm 
# End of macro NEXTW
b965			 
b965			.maxcont:  
b965 c1				pop bc   ; tidy up 
b966 eb				ex de , hl  
b967					if DEBUG_FORTH_WORDS 
b967						DMARK "MA1" 
b967 f5				push af  
b968 3a 7c b9			ld a, (.dmark)  
b96b 32 6b ee			ld (debug_mark),a  
b96e 3a 7d b9			ld a, (.dmark+1)  
b971 32 6c ee			ld (debug_mark+1),a  
b974 3a 7e b9			ld a, (.dmark+2)  
b977 32 6d ee			ld (debug_mark+2),a  
b97a 18 03			jr .pastdmark  
b97c ..			.dmark: db "MA1"  
b97f f1			.pastdmark: pop af  
b980			endm  
# End of macro DMARK
b980						CALLMONITOR 
b980 cd 6f ee			call debug_vector  
b983				endm  
# End of macro CALLMONITOR
b983					endif 
b983 cd a6 9c				call forth_push_numhl 
b986				       NEXTW 
b986 c3 53 a0			jp macro_next 
b989				endm 
# End of macro NEXTW
b989			 
b989			.RND16: 
b989				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
b989 4e				db WORD_SYS_CORE+58             
b98a b8 b9			dw .RND8            
b98c 06				db 5 + 1 
b98d .. 00			db "RND16",0              
b993				endm 
# End of macro CWHEAD
b993			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
b993					if DEBUG_FORTH_WORDS_KEY 
b993						DMARK "R16" 
b993 f5				push af  
b994 3a a8 b9			ld a, (.dmark)  
b997 32 6b ee			ld (debug_mark),a  
b99a 3a a9 b9			ld a, (.dmark+1)  
b99d 32 6c ee			ld (debug_mark+1),a  
b9a0 3a aa b9			ld a, (.dmark+2)  
b9a3 32 6d ee			ld (debug_mark+2),a  
b9a6 18 03			jr .pastdmark  
b9a8 ..			.dmark: db "R16"  
b9ab f1			.pastdmark: pop af  
b9ac			endm  
# End of macro DMARK
b9ac						CALLMONITOR 
b9ac cd 6f ee			call debug_vector  
b9af				endm  
# End of macro CALLMONITOR
b9af					endif 
b9af cd 02 8c				call prng16  
b9b2 cd a6 9c				call forth_push_numhl 
b9b5				       NEXTW 
b9b5 c3 53 a0			jp macro_next 
b9b8				endm 
# End of macro NEXTW
b9b8			.RND8: 
b9b8				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
b9b8 60				db WORD_SYS_CORE+76             
b9b9 ed b9			dw .RND            
b9bb 05				db 4 + 1 
b9bc .. 00			db "RND8",0              
b9c1				endm 
# End of macro CWHEAD
b9c1			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
b9c1					if DEBUG_FORTH_WORDS_KEY 
b9c1						DMARK "RN8" 
b9c1 f5				push af  
b9c2 3a d6 b9			ld a, (.dmark)  
b9c5 32 6b ee			ld (debug_mark),a  
b9c8 3a d7 b9			ld a, (.dmark+1)  
b9cb 32 6c ee			ld (debug_mark+1),a  
b9ce 3a d8 b9			ld a, (.dmark+2)  
b9d1 32 6d ee			ld (debug_mark+2),a  
b9d4 18 03			jr .pastdmark  
b9d6 ..			.dmark: db "RN8"  
b9d9 f1			.pastdmark: pop af  
b9da			endm  
# End of macro DMARK
b9da						CALLMONITOR 
b9da cd 6f ee			call debug_vector  
b9dd				endm  
# End of macro CALLMONITOR
b9dd					endif 
b9dd 2a a9 eb				ld hl,(xrandc) 
b9e0 23					inc hl 
b9e1 cd 1c 8c				call xrnd 
b9e4 6f					ld l,a	 
b9e5 26 00				ld h,0 
b9e7 cd a6 9c				call forth_push_numhl 
b9ea				       NEXTW 
b9ea c3 53 a0			jp macro_next 
b9ed				endm 
# End of macro NEXTW
b9ed			.RND: 
b9ed				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
b9ed 60				db WORD_SYS_CORE+76             
b9ee f3 ba			dw .ENDMATHS            
b9f0 04				db 3 + 1 
b9f1 .. 00			db "RND",0              
b9f5				endm 
# End of macro CWHEAD
b9f5			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
b9f5			 
b9f5					if DEBUG_FORTH_WORDS_KEY 
b9f5						DMARK "RND" 
b9f5 f5				push af  
b9f6 3a 0a ba			ld a, (.dmark)  
b9f9 32 6b ee			ld (debug_mark),a  
b9fc 3a 0b ba			ld a, (.dmark+1)  
b9ff 32 6c ee			ld (debug_mark+1),a  
ba02 3a 0c ba			ld a, (.dmark+2)  
ba05 32 6d ee			ld (debug_mark+2),a  
ba08 18 03			jr .pastdmark  
ba0a ..			.dmark: db "RND"  
ba0d f1			.pastdmark: pop af  
ba0e			endm  
# End of macro DMARK
ba0e						CALLMONITOR 
ba0e cd 6f ee			call debug_vector  
ba11				endm  
# End of macro CALLMONITOR
ba11					endif 
ba11					 
ba11					FORTH_DSP_VALUEHL    ; upper range 
ba11 cd 9d 9e			call macro_dsp_valuehl 
ba14				endm 
# End of macro FORTH_DSP_VALUEHL
ba14			 
ba14 22 ad eb				ld (LFSRSeed), hl	 
ba17			 
ba17					if DEBUG_FORTH_WORDS 
ba17						DMARK "RN1" 
ba17 f5				push af  
ba18 3a 2c ba			ld a, (.dmark)  
ba1b 32 6b ee			ld (debug_mark),a  
ba1e 3a 2d ba			ld a, (.dmark+1)  
ba21 32 6c ee			ld (debug_mark+1),a  
ba24 3a 2e ba			ld a, (.dmark+2)  
ba27 32 6d ee			ld (debug_mark+2),a  
ba2a 18 03			jr .pastdmark  
ba2c ..			.dmark: db "RN1"  
ba2f f1			.pastdmark: pop af  
ba30			endm  
# End of macro DMARK
ba30						CALLMONITOR 
ba30 cd 6f ee			call debug_vector  
ba33				endm  
# End of macro CALLMONITOR
ba33					endif 
ba33					FORTH_DSP_POP 
ba33 cd 55 9f			call macro_forth_dsp_pop 
ba36				endm 
# End of macro FORTH_DSP_POP
ba36			 
ba36					FORTH_DSP_VALUEHL    ; low range 
ba36 cd 9d 9e			call macro_dsp_valuehl 
ba39				endm 
# End of macro FORTH_DSP_VALUEHL
ba39			 
ba39					if DEBUG_FORTH_WORDS 
ba39						DMARK "RN2" 
ba39 f5				push af  
ba3a 3a 4e ba			ld a, (.dmark)  
ba3d 32 6b ee			ld (debug_mark),a  
ba40 3a 4f ba			ld a, (.dmark+1)  
ba43 32 6c ee			ld (debug_mark+1),a  
ba46 3a 50 ba			ld a, (.dmark+2)  
ba49 32 6d ee			ld (debug_mark+2),a  
ba4c 18 03			jr .pastdmark  
ba4e ..			.dmark: db "RN2"  
ba51 f1			.pastdmark: pop af  
ba52			endm  
# End of macro DMARK
ba52						CALLMONITOR 
ba52 cd 6f ee			call debug_vector  
ba55				endm  
# End of macro CALLMONITOR
ba55					endif 
ba55 22 af eb				ld (LFSRSeed+2), hl 
ba58			 
ba58					FORTH_DSP_POP 
ba58 cd 55 9f			call macro_forth_dsp_pop 
ba5b				endm 
# End of macro FORTH_DSP_POP
ba5b			 
ba5b e5					push hl 
ba5c			 
ba5c e1			.inrange:	pop hl 
ba5d cd 02 8c				call prng16  
ba60					if DEBUG_FORTH_WORDS 
ba60						DMARK "RN3" 
ba60 f5				push af  
ba61 3a 75 ba			ld a, (.dmark)  
ba64 32 6b ee			ld (debug_mark),a  
ba67 3a 76 ba			ld a, (.dmark+1)  
ba6a 32 6c ee			ld (debug_mark+1),a  
ba6d 3a 77 ba			ld a, (.dmark+2)  
ba70 32 6d ee			ld (debug_mark+2),a  
ba73 18 03			jr .pastdmark  
ba75 ..			.dmark: db "RN3"  
ba78 f1			.pastdmark: pop af  
ba79			endm  
# End of macro DMARK
ba79						CALLMONITOR 
ba79 cd 6f ee			call debug_vector  
ba7c				endm  
# End of macro CALLMONITOR
ba7c					endif 
ba7c					 
ba7c					; if the range is 8bit knock out the high byte 
ba7c			 
ba7c ed 5b ad eb			ld de, (LFSRSeed)     ; check high level 
ba80			 
ba80 3e 00				ld a, 0 
ba82 ba					cp d  
ba83 20 1e				jr nz, .hirange 
ba85 26 00				ld h, 0   ; knock it down to 8bit 
ba87			 
ba87					if DEBUG_FORTH_WORDS 
ba87						DMARK "RNk" 
ba87 f5				push af  
ba88 3a 9c ba			ld a, (.dmark)  
ba8b 32 6b ee			ld (debug_mark),a  
ba8e 3a 9d ba			ld a, (.dmark+1)  
ba91 32 6c ee			ld (debug_mark+1),a  
ba94 3a 9e ba			ld a, (.dmark+2)  
ba97 32 6d ee			ld (debug_mark+2),a  
ba9a 18 03			jr .pastdmark  
ba9c ..			.dmark: db "RNk"  
ba9f f1			.pastdmark: pop af  
baa0			endm  
# End of macro DMARK
baa0						CALLMONITOR 
baa0 cd 6f ee			call debug_vector  
baa3				endm  
# End of macro CALLMONITOR
baa3					endif 
baa3			.hirange:   
baa3 e5					push hl  
baa4 b7					or a  
baa5 ed 52		                sbc hl, de 
baa7			 
baa7					;call cmp16 
baa7			 
baa7 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
baa9 e1					pop hl 
baaa e5					push hl 
baab			 
baab					if DEBUG_FORTH_WORDS 
baab						DMARK "RN4" 
baab f5				push af  
baac 3a c0 ba			ld a, (.dmark)  
baaf 32 6b ee			ld (debug_mark),a  
bab2 3a c1 ba			ld a, (.dmark+1)  
bab5 32 6c ee			ld (debug_mark+1),a  
bab8 3a c2 ba			ld a, (.dmark+2)  
babb 32 6d ee			ld (debug_mark+2),a  
babe 18 03			jr .pastdmark  
bac0 ..			.dmark: db "RN4"  
bac3 f1			.pastdmark: pop af  
bac4			endm  
# End of macro DMARK
bac4						CALLMONITOR 
bac4 cd 6f ee			call debug_vector  
bac7				endm  
# End of macro CALLMONITOR
bac7					endif 
bac7 ed 5b af eb			ld de, (LFSRSeed+2)   ; check low range 
bacb					;call cmp16 
bacb				 
bacb b7					or a  
bacc ed 52		                sbc hl, de 
bace 38 8c				jr c, .inrange 
bad0			 
bad0 e1					pop hl 
bad1					 
bad1					if DEBUG_FORTH_WORDS 
bad1						DMARK "RNd" 
bad1 f5				push af  
bad2 3a e6 ba			ld a, (.dmark)  
bad5 32 6b ee			ld (debug_mark),a  
bad8 3a e7 ba			ld a, (.dmark+1)  
badb 32 6c ee			ld (debug_mark+1),a  
bade 3a e8 ba			ld a, (.dmark+2)  
bae1 32 6d ee			ld (debug_mark+2),a  
bae4 18 03			jr .pastdmark  
bae6 ..			.dmark: db "RNd"  
bae9 f1			.pastdmark: pop af  
baea			endm  
# End of macro DMARK
baea						CALLMONITOR 
baea cd 6f ee			call debug_vector  
baed				endm  
# End of macro CALLMONITOR
baed					endif 
baed			 
baed			 
baed cd a6 9c				call forth_push_numhl 
baf0				       NEXTW 
baf0 c3 53 a0			jp macro_next 
baf3				endm 
# End of macro NEXTW
baf3			 
baf3			.ENDMATHS: 
baf3			 
baf3			; eof 
baf3			 
# End of file forth_words_maths.asm
baf3			include "forth_words_display.asm" 
baf3			 
baf3			; | ## Display Words 
baf3			 
baf3			.ACT: 
baf3			 
baf3				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
baf3 62				db WORD_SYS_CORE+78             
baf4 3f bb			dw .INFO            
baf6 07				db 6 + 1 
baf7 .. 00			db "ACTIVE",0              
bafe				endm 
# End of macro CWHEAD
bafe			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
bafe			;  
bafe			; | | To display a pulsing activity indicator in a processing loop do this... 
bafe			; | | e.g. $ff $00 do active . ..... Your code ..... loop 
bafe			 
bafe					if DEBUG_FORTH_WORDS_KEY 
bafe						DMARK "ACT" 
bafe f5				push af  
baff 3a 13 bb			ld a, (.dmark)  
bb02 32 6b ee			ld (debug_mark),a  
bb05 3a 14 bb			ld a, (.dmark+1)  
bb08 32 6c ee			ld (debug_mark+1),a  
bb0b 3a 15 bb			ld a, (.dmark+2)  
bb0e 32 6d ee			ld (debug_mark+2),a  
bb11 18 03			jr .pastdmark  
bb13 ..			.dmark: db "ACT"  
bb16 f1			.pastdmark: pop af  
bb17			endm  
# End of macro DMARK
bb17						CALLMONITOR 
bb17 cd 6f ee			call debug_vector  
bb1a				endm  
# End of macro CALLMONITOR
bb1a					endif 
bb1a cd 05 8a				call active 
bb1d					if DEBUG_FORTH_WORDS 
bb1d						DMARK "ACp" 
bb1d f5				push af  
bb1e 3a 32 bb			ld a, (.dmark)  
bb21 32 6b ee			ld (debug_mark),a  
bb24 3a 33 bb			ld a, (.dmark+1)  
bb27 32 6c ee			ld (debug_mark+1),a  
bb2a 3a 34 bb			ld a, (.dmark+2)  
bb2d 32 6d ee			ld (debug_mark+2),a  
bb30 18 03			jr .pastdmark  
bb32 ..			.dmark: db "ACp"  
bb35 f1			.pastdmark: pop af  
bb36			endm  
# End of macro DMARK
bb36						CALLMONITOR 
bb36 cd 6f ee			call debug_vector  
bb39				endm  
# End of macro CALLMONITOR
bb39					endif 
bb39 cd 14 9d				call forth_push_str 
bb3c			 
bb3c					NEXTW 
bb3c c3 53 a0			jp macro_next 
bb3f				endm 
# End of macro NEXTW
bb3f			.INFO: 
bb3f			 
bb3f				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
bb3f 62				db WORD_SYS_CORE+78             
bb40 5c bb			dw .ATP            
bb42 05				db 4 + 1 
bb43 .. 00			db "INFO",0              
bb48				endm 
# End of macro CWHEAD
bb48			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
bb48					FORTH_DSP_VALUEHL 
bb48 cd 9d 9e			call macro_dsp_valuehl 
bb4b				endm 
# End of macro FORTH_DSP_VALUEHL
bb4b			 
bb4b					FORTH_DSP_POP 
bb4b cd 55 9f			call macro_forth_dsp_pop 
bb4e				endm 
# End of macro FORTH_DSP_POP
bb4e			 
bb4e e5					push hl 
bb4f			 
bb4f					FORTH_DSP_VALUEHL 
bb4f cd 9d 9e			call macro_dsp_valuehl 
bb52				endm 
# End of macro FORTH_DSP_VALUEHL
bb52			 
bb52					FORTH_DSP_POP 
bb52 cd 55 9f			call macro_forth_dsp_pop 
bb55				endm 
# End of macro FORTH_DSP_POP
bb55			 
bb55 d1					pop de 
bb56			 
bb56 cd 3f 8a				call info_panel 
bb59			 
bb59			 
bb59					NEXTW 
bb59 c3 53 a0			jp macro_next 
bb5c				endm 
# End of macro NEXTW
bb5c			.ATP: 
bb5c				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
bb5c 62				db WORD_SYS_CORE+78             
bb5d d3 bb			dw .FB            
bb5f 04				db 3 + 1 
bb60 .. 00			db "AT?",0              
bb64				endm 
# End of macro CWHEAD
bb64			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
bb64					if DEBUG_FORTH_WORDS_KEY 
bb64						DMARK "AT?" 
bb64 f5				push af  
bb65 3a 79 bb			ld a, (.dmark)  
bb68 32 6b ee			ld (debug_mark),a  
bb6b 3a 7a bb			ld a, (.dmark+1)  
bb6e 32 6c ee			ld (debug_mark+1),a  
bb71 3a 7b bb			ld a, (.dmark+2)  
bb74 32 6d ee			ld (debug_mark+2),a  
bb77 18 03			jr .pastdmark  
bb79 ..			.dmark: db "AT?"  
bb7c f1			.pastdmark: pop af  
bb7d			endm  
# End of macro DMARK
bb7d						CALLMONITOR 
bb7d cd 6f ee			call debug_vector  
bb80				endm  
# End of macro CALLMONITOR
bb80					endif 
bb80 3a 5e ea				ld a, (f_cursor_ptr) 
bb83			 
bb83			if DEBUG_FORTH_WORDS 
bb83				DMARK "AT?" 
bb83 f5				push af  
bb84 3a 98 bb			ld a, (.dmark)  
bb87 32 6b ee			ld (debug_mark),a  
bb8a 3a 99 bb			ld a, (.dmark+1)  
bb8d 32 6c ee			ld (debug_mark+1),a  
bb90 3a 9a bb			ld a, (.dmark+2)  
bb93 32 6d ee			ld (debug_mark+2),a  
bb96 18 03			jr .pastdmark  
bb98 ..			.dmark: db "AT?"  
bb9b f1			.pastdmark: pop af  
bb9c			endm  
# End of macro DMARK
bb9c				CALLMONITOR 
bb9c cd 6f ee			call debug_vector  
bb9f				endm  
# End of macro CALLMONITOR
bb9f			endif	 
bb9f					; count the number of rows 
bb9f			 
bb9f 06 00				ld b, 0 
bba1 4f			.atpr:		ld c, a    ; save in case we go below zero 
bba2 d6 28				sub display_cols 
bba4 f2 aa bb				jp p, .atprunder 
bba7 04					inc b 
bba8 18 f7				jr .atpr 
bbaa			.atprunder:	 
bbaa			if DEBUG_FORTH_WORDS 
bbaa				DMARK "A?2" 
bbaa f5				push af  
bbab 3a bf bb			ld a, (.dmark)  
bbae 32 6b ee			ld (debug_mark),a  
bbb1 3a c0 bb			ld a, (.dmark+1)  
bbb4 32 6c ee			ld (debug_mark+1),a  
bbb7 3a c1 bb			ld a, (.dmark+2)  
bbba 32 6d ee			ld (debug_mark+2),a  
bbbd 18 03			jr .pastdmark  
bbbf ..			.dmark: db "A?2"  
bbc2 f1			.pastdmark: pop af  
bbc3			endm  
# End of macro DMARK
bbc3				CALLMONITOR 
bbc3 cd 6f ee			call debug_vector  
bbc6				endm  
# End of macro CALLMONITOR
bbc6			endif	 
bbc6 26 00				ld h, 0 
bbc8 69					ld l, c 
bbc9 cd a6 9c				call forth_push_numhl 
bbcc 68					ld l, b  
bbcd cd a6 9c				call forth_push_numhl 
bbd0			 
bbd0			 
bbd0				NEXTW 
bbd0 c3 53 a0			jp macro_next 
bbd3				endm 
# End of macro NEXTW
bbd3			 
bbd3			.FB: 
bbd3				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
bbd3 1b				db WORD_SYS_CORE+7             
bbd4 21 bc			dw .EMIT            
bbd6 03				db 2 + 1 
bbd7 .. 00			db "FB",0              
bbda				endm 
# End of macro CWHEAD
bbda			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
bbda			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
bbda			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
bbda			; | | If automatic display is off then updates will not be shown until DRAW is used. 
bbda					if DEBUG_FORTH_WORDS_KEY 
bbda						DMARK "FB." 
bbda f5				push af  
bbdb 3a ef bb			ld a, (.dmark)  
bbde 32 6b ee			ld (debug_mark),a  
bbe1 3a f0 bb			ld a, (.dmark+1)  
bbe4 32 6c ee			ld (debug_mark+1),a  
bbe7 3a f1 bb			ld a, (.dmark+2)  
bbea 32 6d ee			ld (debug_mark+2),a  
bbed 18 03			jr .pastdmark  
bbef ..			.dmark: db "FB."  
bbf2 f1			.pastdmark: pop af  
bbf3			endm  
# End of macro DMARK
bbf3						CALLMONITOR 
bbf3 cd 6f ee			call debug_vector  
bbf6				endm  
# End of macro CALLMONITOR
bbf6					endif 
bbf6			 
bbf6					FORTH_DSP_VALUEHL 
bbf6 cd 9d 9e			call macro_dsp_valuehl 
bbf9				endm 
# End of macro FORTH_DSP_VALUEHL
bbf9			 
bbf9 7d					ld a, l 
bbfa fe 01				cp 1 
bbfc 20 05				jr nz, .fbn1 
bbfe 21 10 ed				ld hl, display_fb1 
bc01 18 15				jr .fbset 
bc03 fe 02		.fbn1:		cp 2 
bc05 20 05				jr nz, .fbn2 
bc07 21 ce eb				ld hl, display_fb2 
bc0a 18 0c				jr .fbset 
bc0c fe 03		.fbn2:		cp 3 
bc0e 20 05				jr nz, .fbn3 
bc10 21 6f ec				ld hl, display_fb3 
bc13 18 03				jr .fbset 
bc15			.fbn3:		 ; if invalid number select first 
bc15 21 10 ed				ld hl, display_fb1 
bc18 22 cc eb		.fbset:		ld (display_fb_active), hl 
bc1b			 
bc1b					FORTH_DSP_POP 
bc1b cd 55 9f			call macro_forth_dsp_pop 
bc1e				endm 
# End of macro FORTH_DSP_POP
bc1e			 
bc1e					NEXTW 
bc1e c3 53 a0			jp macro_next 
bc21				endm 
# End of macro NEXTW
bc21			 
bc21			 
bc21			.EMIT: 
bc21				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
bc21 1b				db WORD_SYS_CORE+7             
bc22 72 bc			dw .DOTH            
bc24 05				db 4 + 1 
bc25 .. 00			db "EMIT",0              
bc2a				endm 
# End of macro CWHEAD
bc2a			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
bc2a					; get value off TOS and display it 
bc2a			 
bc2a					if DEBUG_FORTH_WORDS_KEY 
bc2a						DMARK "EMT" 
bc2a f5				push af  
bc2b 3a 3f bc			ld a, (.dmark)  
bc2e 32 6b ee			ld (debug_mark),a  
bc31 3a 40 bc			ld a, (.dmark+1)  
bc34 32 6c ee			ld (debug_mark+1),a  
bc37 3a 41 bc			ld a, (.dmark+2)  
bc3a 32 6d ee			ld (debug_mark+2),a  
bc3d 18 03			jr .pastdmark  
bc3f ..			.dmark: db "EMT"  
bc42 f1			.pastdmark: pop af  
bc43			endm  
# End of macro DMARK
bc43						CALLMONITOR 
bc43 cd 6f ee			call debug_vector  
bc46				endm  
# End of macro CALLMONITOR
bc46					endif 
bc46			 
bc46					FORTH_DSP_VALUEHL 
bc46 cd 9d 9e			call macro_dsp_valuehl 
bc49				endm 
# End of macro FORTH_DSP_VALUEHL
bc49			 
bc49 7d					ld a,l 
bc4a			 
bc4a					; TODO write to display 
bc4a			 
bc4a 32 bf e4				ld (os_input), a 
bc4d 3e 00				ld a, 0 
bc4f 32 c0 e4				ld (os_input+1), a 
bc52					 
bc52 3a 5e ea				ld a, (f_cursor_ptr) 
bc55 11 bf e4				ld de, os_input 
bc58 cd c1 8a				call str_at_display 
bc5b			 
bc5b			 
bc5b 3a 3c ea				ld a,(cli_autodisplay) 
bc5e fe 00				cp 0 
bc60 28 03				jr z, .enoupdate 
bc62 cd d1 8a						call update_display 
bc65					.enoupdate: 
bc65			 
bc65 3a 5e ea				ld a, (f_cursor_ptr) 
bc68 3c					inc a 
bc69 32 5e ea				ld (f_cursor_ptr), a   ; save new pos 
bc6c			 
bc6c			 
bc6c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bc6c cd 55 9f			call macro_forth_dsp_pop 
bc6f				endm 
# End of macro FORTH_DSP_POP
bc6f			  
bc6f			 
bc6f					NEXTW 
bc6f c3 53 a0			jp macro_next 
bc72				endm 
# End of macro NEXTW
bc72			.DOTH: 
bc72				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
bc72 1c				db WORD_SYS_CORE+8             
bc73 a2 bc			dw .DOTF            
bc75 03				db 2 + 1 
bc76 .. 00			db ".-",0              
bc79				endm 
# End of macro CWHEAD
bc79			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
bc79					; get value off TOS and display it 
bc79					if DEBUG_FORTH_WORDS_KEY 
bc79						DMARK "DTD" 
bc79 f5				push af  
bc7a 3a 8e bc			ld a, (.dmark)  
bc7d 32 6b ee			ld (debug_mark),a  
bc80 3a 8f bc			ld a, (.dmark+1)  
bc83 32 6c ee			ld (debug_mark+1),a  
bc86 3a 90 bc			ld a, (.dmark+2)  
bc89 32 6d ee			ld (debug_mark+2),a  
bc8c 18 03			jr .pastdmark  
bc8e ..			.dmark: db "DTD"  
bc91 f1			.pastdmark: pop af  
bc92			endm  
# End of macro DMARK
bc92						CALLMONITOR 
bc92 cd 6f ee			call debug_vector  
bc95				endm  
# End of macro CALLMONITOR
bc95					endif 
bc95 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
bc97 3e 00			ld a, 0 
bc99 32 3d ea			ld (cli_mvdot), a 
bc9c c3 f9 bc			jp .dotgo 
bc9f				NEXTW 
bc9f c3 53 a0			jp macro_next 
bca2				endm 
# End of macro NEXTW
bca2			.DOTF: 
bca2				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
bca2 1c				db WORD_SYS_CORE+8             
bca3 d0 bc			dw .DOT            
bca5 03				db 2 + 1 
bca6 .. 00			db ".>",0              
bca9				endm 
# End of macro CWHEAD
bca9			        ; | .> ( u -- ) Display TOS and move the next display point with display  | DONE 
bca9					; get value off TOS and display it 
bca9			        ; TODO BUG adds extra spaces 
bca9			        ; TODO BUG handle numerics? 
bca9					if DEBUG_FORTH_WORDS_KEY 
bca9						DMARK "DTC" 
bca9 f5				push af  
bcaa 3a be bc			ld a, (.dmark)  
bcad 32 6b ee			ld (debug_mark),a  
bcb0 3a bf bc			ld a, (.dmark+1)  
bcb3 32 6c ee			ld (debug_mark+1),a  
bcb6 3a c0 bc			ld a, (.dmark+2)  
bcb9 32 6d ee			ld (debug_mark+2),a  
bcbc 18 03			jr .pastdmark  
bcbe ..			.dmark: db "DTC"  
bcc1 f1			.pastdmark: pop af  
bcc2			endm  
# End of macro DMARK
bcc2						CALLMONITOR 
bcc2 cd 6f ee			call debug_vector  
bcc5				endm  
# End of macro CALLMONITOR
bcc5					endif 
bcc5 3e 01			ld a, 1 
bcc7 32 3d ea			ld (cli_mvdot), a 
bcca c3 f9 bc			jp .dotgo 
bccd				NEXTW 
bccd c3 53 a0			jp macro_next 
bcd0				endm 
# End of macro NEXTW
bcd0			 
bcd0			.DOT: 
bcd0				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
bcd0 1c				db WORD_SYS_CORE+8             
bcd1 ac be			dw .CLS            
bcd3 02				db 1 + 1 
bcd4 .. 00			db ".",0              
bcd6				endm 
# End of macro CWHEAD
bcd6			        ; | . ( u -- ) Display TOS. Does not move next print position. Use .> if you want that. | DONE 
bcd6					; get value off TOS and display it 
bcd6			 
bcd6					if DEBUG_FORTH_WORDS_KEY 
bcd6						DMARK "DOT" 
bcd6 f5				push af  
bcd7 3a eb bc			ld a, (.dmark)  
bcda 32 6b ee			ld (debug_mark),a  
bcdd 3a ec bc			ld a, (.dmark+1)  
bce0 32 6c ee			ld (debug_mark+1),a  
bce3 3a ed bc			ld a, (.dmark+2)  
bce6 32 6d ee			ld (debug_mark+2),a  
bce9 18 03			jr .pastdmark  
bceb ..			.dmark: db "DOT"  
bcee f1			.pastdmark: pop af  
bcef			endm  
# End of macro DMARK
bcef						CALLMONITOR 
bcef cd 6f ee			call debug_vector  
bcf2				endm  
# End of macro CALLMONITOR
bcf2					endif 
bcf2 3e 00			ld a, 0 
bcf4 32 3d ea			ld (cli_mvdot), a 
bcf7 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
bcf9				 
bcf9			 
bcf9			.dotgo: 
bcf9			 
bcf9			; move up type to on stack for parserv5 
bcf9					FORTH_DSP 
bcf9 cd 63 9e			call macro_forth_dsp 
bcfc				endm 
# End of macro FORTH_DSP
bcfc				;FORTH_DSP_VALUE  
bcfc			 
bcfc			if DEBUG_FORTH_DOT 
bcfc				DMARK "DOT" 
bcfc f5				push af  
bcfd 3a 11 bd			ld a, (.dmark)  
bd00 32 6b ee			ld (debug_mark),a  
bd03 3a 12 bd			ld a, (.dmark+1)  
bd06 32 6c ee			ld (debug_mark+1),a  
bd09 3a 13 bd			ld a, (.dmark+2)  
bd0c 32 6d ee			ld (debug_mark+2),a  
bd0f 18 03			jr .pastdmark  
bd11 ..			.dmark: db "DOT"  
bd14 f1			.pastdmark: pop af  
bd15			endm  
# End of macro DMARK
bd15				CALLMONITOR 
bd15 cd 6f ee			call debug_vector  
bd18				endm  
# End of macro CALLMONITOR
bd18			endif	 
bd18			;		.print: 
bd18			 
bd18 7e				ld a,(hl)  ; work out what type of value is on the TOS 
bd19 23				inc hl   ; position to the actual value 
bd1a fe 01			cp DS_TYPE_STR 
bd1c 20 06			jr nz, .dotnum1  
bd1e			 
bd1e			; display string 
bd1e				FORTH_DSP_VALUE  
bd1e cd 86 9e			call macro_forth_dsp_value 
bd21				endm 
# End of macro FORTH_DSP_VALUE
bd21 eb				ex de,hl 
bd22 18 49			jr .dotwrite 
bd24			 
bd24			.dotnum1: 
bd24 fe 02			cp DS_TYPE_INUM 
bd26 20 44			jr nz, .dotflot 
bd28			 
bd28			 
bd28			; display number 
bd28			 
bd28			;	push hl 
bd28			;	call clear_display 
bd28			;	pop hl 
bd28			 
bd28 5e				ld e, (hl) 
bd29 23				inc hl 
bd2a 56				ld d, (hl) 
bd2b 21 c1 e2			ld hl, scratch 
bd2e			if DEBUG_FORTH_DOT 
bd2e				DMARK "DT1" 
bd2e f5				push af  
bd2f 3a 43 bd			ld a, (.dmark)  
bd32 32 6b ee			ld (debug_mark),a  
bd35 3a 44 bd			ld a, (.dmark+1)  
bd38 32 6c ee			ld (debug_mark+1),a  
bd3b 3a 45 bd			ld a, (.dmark+2)  
bd3e 32 6d ee			ld (debug_mark+2),a  
bd41 18 03			jr .pastdmark  
bd43 ..			.dmark: db "DT1"  
bd46 f1			.pastdmark: pop af  
bd47			endm  
# End of macro DMARK
bd47				CALLMONITOR 
bd47 cd 6f ee			call debug_vector  
bd4a				endm  
# End of macro CALLMONITOR
bd4a			endif	 
bd4a			 
bd4a cd 47 92			call uitoa_16 
bd4d eb				ex de,hl 
bd4e			 
bd4e			if DEBUG_FORTH_DOT 
bd4e				DMARK "DT2" 
bd4e f5				push af  
bd4f 3a 63 bd			ld a, (.dmark)  
bd52 32 6b ee			ld (debug_mark),a  
bd55 3a 64 bd			ld a, (.dmark+1)  
bd58 32 6c ee			ld (debug_mark+1),a  
bd5b 3a 65 bd			ld a, (.dmark+2)  
bd5e 32 6d ee			ld (debug_mark+2),a  
bd61 18 03			jr .pastdmark  
bd63 ..			.dmark: db "DT2"  
bd66 f1			.pastdmark: pop af  
bd67			endm  
# End of macro DMARK
bd67				CALLMONITOR 
bd67 cd 6f ee			call debug_vector  
bd6a				endm  
# End of macro CALLMONITOR
bd6a			endif	 
bd6a			 
bd6a			;	ld de, os_word_scratch 
bd6a 18 01			jr .dotwrite 
bd6c			 
bd6c 00			.dotflot:   nop 
bd6d			; TODO print floating point number 
bd6d			 
bd6d			.dotwrite:		 
bd6d			 
bd6d					; if c is set then set all '-' to spaces 
bd6d					; need to also take into account .>  
bd6d			 
bd6d 3e 01				ld a, 1 
bd6f b9					cp c 
bd70 20 67				jr nz, .nodashswap 
bd72			 
bd72					; DE has the string to write, working with HL 
bd72			 
bd72 06 ff				ld b, 255 
bd74 d5					push de 
bd75 e1					pop hl 
bd76			 
bd76			if DEBUG_FORTH_DOT 
bd76				DMARK "DT-" 
bd76 f5				push af  
bd77 3a 8b bd			ld a, (.dmark)  
bd7a 32 6b ee			ld (debug_mark),a  
bd7d 3a 8c bd			ld a, (.dmark+1)  
bd80 32 6c ee			ld (debug_mark+1),a  
bd83 3a 8d bd			ld a, (.dmark+2)  
bd86 32 6d ee			ld (debug_mark+2),a  
bd89 18 03			jr .pastdmark  
bd8b ..			.dmark: db "DT-"  
bd8e f1			.pastdmark: pop af  
bd8f			endm  
# End of macro DMARK
bd8f				CALLMONITOR 
bd8f cd 6f ee			call debug_vector  
bd92				endm  
# End of macro CALLMONITOR
bd92			endif	 
bd92 7e			.dashscan:	ld a, (hl) 
bd93 fe 00				cp 0 
bd95 28 42				jr z, .nodashswap 
bd97 fe 2d				cp '-' 
bd99 20 03				jr nz, .dashskip 
bd9b 3e 20				ld a, ' ' 
bd9d 77					ld (hl), a 
bd9e 23			.dashskip:	inc hl 
bd9f			if DEBUG_FORTH_DOT 
bd9f				DMARK "D-2" 
bd9f f5				push af  
bda0 3a b4 bd			ld a, (.dmark)  
bda3 32 6b ee			ld (debug_mark),a  
bda6 3a b5 bd			ld a, (.dmark+1)  
bda9 32 6c ee			ld (debug_mark+1),a  
bdac 3a b6 bd			ld a, (.dmark+2)  
bdaf 32 6d ee			ld (debug_mark+2),a  
bdb2 18 03			jr .pastdmark  
bdb4 ..			.dmark: db "D-2"  
bdb7 f1			.pastdmark: pop af  
bdb8			endm  
# End of macro DMARK
bdb8				CALLMONITOR 
bdb8 cd 6f ee			call debug_vector  
bdbb				endm  
# End of macro CALLMONITOR
bdbb			endif	 
bdbb 10 d5				djnz .dashscan 
bdbd			 
bdbd			if DEBUG_FORTH_DOT 
bdbd				DMARK "D-1" 
bdbd f5				push af  
bdbe 3a d2 bd			ld a, (.dmark)  
bdc1 32 6b ee			ld (debug_mark),a  
bdc4 3a d3 bd			ld a, (.dmark+1)  
bdc7 32 6c ee			ld (debug_mark+1),a  
bdca 3a d4 bd			ld a, (.dmark+2)  
bdcd 32 6d ee			ld (debug_mark+2),a  
bdd0 18 03			jr .pastdmark  
bdd2 ..			.dmark: db "D-1"  
bdd5 f1			.pastdmark: pop af  
bdd6			endm  
# End of macro DMARK
bdd6				CALLMONITOR 
bdd6 cd 6f ee			call debug_vector  
bdd9				endm  
# End of macro CALLMONITOR
bdd9			endif	 
bdd9			 
bdd9			.nodashswap: 
bdd9			 
bdd9			if DEBUG_FORTH_DOT 
bdd9				DMARK "D-o" 
bdd9 f5				push af  
bdda 3a ee bd			ld a, (.dmark)  
bddd 32 6b ee			ld (debug_mark),a  
bde0 3a ef bd			ld a, (.dmark+1)  
bde3 32 6c ee			ld (debug_mark+1),a  
bde6 3a f0 bd			ld a, (.dmark+2)  
bde9 32 6d ee			ld (debug_mark+2),a  
bdec 18 03			jr .pastdmark  
bdee ..			.dmark: db "D-o"  
bdf1 f1			.pastdmark: pop af  
bdf2			endm  
# End of macro DMARK
bdf2				CALLMONITOR 
bdf2 cd 6f ee			call debug_vector  
bdf5				endm  
# End of macro CALLMONITOR
bdf5			endif	 
bdf5			 
bdf5 d5					push de   ; save string start in case we need to advance print 
bdf6			 
bdf6 3a 5e ea				ld a, (f_cursor_ptr) 
bdf9 cd c1 8a				call str_at_display 
bdfc 3a 3c ea				ld a,(cli_autodisplay) 
bdff fe 00				cp 0 
be01 28 03				jr z, .noupdate 
be03 cd d1 8a						call update_display 
be06					.noupdate: 
be06			 
be06			 
be06					; see if we need to advance the print position 
be06			 
be06 e1					pop hl   ; get back string 
be07			;		ex de,hl 
be07			 
be07 3a 3d ea				ld a, (cli_mvdot) 
be0a			if DEBUG_FORTH_DOT 
be0a			;		ld e,a 
be0a				DMARK "D>1" 
be0a f5				push af  
be0b 3a 1f be			ld a, (.dmark)  
be0e 32 6b ee			ld (debug_mark),a  
be11 3a 20 be			ld a, (.dmark+1)  
be14 32 6c ee			ld (debug_mark+1),a  
be17 3a 21 be			ld a, (.dmark+2)  
be1a 32 6d ee			ld (debug_mark+2),a  
be1d 18 03			jr .pastdmark  
be1f ..			.dmark: db "D>1"  
be22 f1			.pastdmark: pop af  
be23			endm  
# End of macro DMARK
be23				CALLMONITOR 
be23 cd 6f ee			call debug_vector  
be26				endm  
# End of macro CALLMONITOR
be26			endif	 
be26 fe 00				cp 0 
be28 28 44				jr z, .noadv 
be2a					; yes, lets advance the print position 
be2a 3e 00				ld a, 0 
be2c cd a3 92				call strlent 
be2f			if DEBUG_FORTH_DOT 
be2f				DMARK "D-?" 
be2f f5				push af  
be30 3a 44 be			ld a, (.dmark)  
be33 32 6b ee			ld (debug_mark),a  
be36 3a 45 be			ld a, (.dmark+1)  
be39 32 6c ee			ld (debug_mark+1),a  
be3c 3a 46 be			ld a, (.dmark+2)  
be3f 32 6d ee			ld (debug_mark+2),a  
be42 18 03			jr .pastdmark  
be44 ..			.dmark: db "D-?"  
be47 f1			.pastdmark: pop af  
be48			endm  
# End of macro DMARK
be48				CALLMONITOR 
be48 cd 6f ee			call debug_vector  
be4b				endm  
# End of macro CALLMONITOR
be4b			endif	 
be4b 3a 5e ea				ld a, (f_cursor_ptr) 
be4e 85					add a,l 
be4f					;call addatohl 
be4f					;ld a, l 
be4f 32 5e ea				ld (f_cursor_ptr), a   ; save new pos 
be52			 
be52			if DEBUG_FORTH_DOT 
be52				DMARK "D->" 
be52 f5				push af  
be53 3a 67 be			ld a, (.dmark)  
be56 32 6b ee			ld (debug_mark),a  
be59 3a 68 be			ld a, (.dmark+1)  
be5c 32 6c ee			ld (debug_mark+1),a  
be5f 3a 69 be			ld a, (.dmark+2)  
be62 32 6d ee			ld (debug_mark+2),a  
be65 18 03			jr .pastdmark  
be67 ..			.dmark: db "D->"  
be6a f1			.pastdmark: pop af  
be6b			endm  
# End of macro DMARK
be6b				CALLMONITOR 
be6b cd 6f ee			call debug_vector  
be6e				endm  
# End of macro CALLMONITOR
be6e			endif	 
be6e			 
be6e			.noadv:	 
be6e			 
be6e					if DEBUG_FORTH_DOT_WAIT 
be6e							call next_page_prompt 
be6e					endif	 
be6e			; TODO this pop off the stack causes a crash. i dont know why 
be6e			 
be6e			 
be6e			if DEBUG_FORTH_DOT 
be6e				DMARK "DTh" 
be6e f5				push af  
be6f 3a 83 be			ld a, (.dmark)  
be72 32 6b ee			ld (debug_mark),a  
be75 3a 84 be			ld a, (.dmark+1)  
be78 32 6c ee			ld (debug_mark+1),a  
be7b 3a 85 be			ld a, (.dmark+2)  
be7e 32 6d ee			ld (debug_mark+2),a  
be81 18 03			jr .pastdmark  
be83 ..			.dmark: db "DTh"  
be86 f1			.pastdmark: pop af  
be87			endm  
# End of macro DMARK
be87				CALLMONITOR 
be87 cd 6f ee			call debug_vector  
be8a				endm  
# End of macro CALLMONITOR
be8a			endif	 
be8a			 
be8a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
be8a cd 55 9f			call macro_forth_dsp_pop 
be8d				endm 
# End of macro FORTH_DSP_POP
be8d			 
be8d			if DEBUG_FORTH_DOT 
be8d				DMARK "DTi" 
be8d f5				push af  
be8e 3a a2 be			ld a, (.dmark)  
be91 32 6b ee			ld (debug_mark),a  
be94 3a a3 be			ld a, (.dmark+1)  
be97 32 6c ee			ld (debug_mark+1),a  
be9a 3a a4 be			ld a, (.dmark+2)  
be9d 32 6d ee			ld (debug_mark+2),a  
bea0 18 03			jr .pastdmark  
bea2 ..			.dmark: db "DTi"  
bea5 f1			.pastdmark: pop af  
bea6			endm  
# End of macro DMARK
bea6				CALLMONITOR 
bea6 cd 6f ee			call debug_vector  
bea9				endm  
# End of macro CALLMONITOR
bea9			endif	 
bea9			 
bea9			 
bea9					NEXTW 
bea9 c3 53 a0			jp macro_next 
beac				endm 
# End of macro NEXTW
beac			 
beac			.CLS: 
beac				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
beac 35				db WORD_SYS_CORE+33             
bead d9 be			dw .DRAW            
beaf 04				db 3 + 1 
beb0 .. 00			db "CLS",0              
beb4				endm 
# End of macro CWHEAD
beb4			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
beb4					if DEBUG_FORTH_WORDS_KEY 
beb4						DMARK "CLS" 
beb4 f5				push af  
beb5 3a c9 be			ld a, (.dmark)  
beb8 32 6b ee			ld (debug_mark),a  
bebb 3a ca be			ld a, (.dmark+1)  
bebe 32 6c ee			ld (debug_mark+1),a  
bec1 3a cb be			ld a, (.dmark+2)  
bec4 32 6d ee			ld (debug_mark+2),a  
bec7 18 03			jr .pastdmark  
bec9 ..			.dmark: db "CLS"  
becc f1			.pastdmark: pop af  
becd			endm  
# End of macro DMARK
becd						CALLMONITOR 
becd cd 6f ee			call debug_vector  
bed0				endm  
# End of macro CALLMONITOR
bed0					endif 
bed0 cd ae 8a				call clear_display 
bed3 c3 e7 bf				jp .home		; and home cursor 
bed6					NEXTW 
bed6 c3 53 a0			jp macro_next 
bed9				endm 
# End of macro NEXTW
bed9			 
bed9			.DRAW: 
bed9				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
bed9 36				db WORD_SYS_CORE+34             
beda 04 bf			dw .DUMP            
bedc 05				db 4 + 1 
bedd .. 00			db "DRAW",0              
bee2				endm 
# End of macro CWHEAD
bee2			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
bee2					if DEBUG_FORTH_WORDS_KEY 
bee2						DMARK "DRW" 
bee2 f5				push af  
bee3 3a f7 be			ld a, (.dmark)  
bee6 32 6b ee			ld (debug_mark),a  
bee9 3a f8 be			ld a, (.dmark+1)  
beec 32 6c ee			ld (debug_mark+1),a  
beef 3a f9 be			ld a, (.dmark+2)  
bef2 32 6d ee			ld (debug_mark+2),a  
bef5 18 03			jr .pastdmark  
bef7 ..			.dmark: db "DRW"  
befa f1			.pastdmark: pop af  
befb			endm  
# End of macro DMARK
befb						CALLMONITOR 
befb cd 6f ee			call debug_vector  
befe				endm  
# End of macro CALLMONITOR
befe					endif 
befe cd d1 8a				call update_display 
bf01					NEXTW 
bf01 c3 53 a0			jp macro_next 
bf04				endm 
# End of macro NEXTW
bf04			 
bf04			.DUMP: 
bf04				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
bf04 37				db WORD_SYS_CORE+35             
bf05 3c bf			dw .CDUMP            
bf07 05				db 4 + 1 
bf08 .. 00			db "DUMP",0              
bf0d				endm 
# End of macro CWHEAD
bf0d			; | DUMP ( x -- ) With address x display dump   | DONE 
bf0d			; TODO pop address to use off of the stack 
bf0d					if DEBUG_FORTH_WORDS_KEY 
bf0d						DMARK "DUM" 
bf0d f5				push af  
bf0e 3a 22 bf			ld a, (.dmark)  
bf11 32 6b ee			ld (debug_mark),a  
bf14 3a 23 bf			ld a, (.dmark+1)  
bf17 32 6c ee			ld (debug_mark+1),a  
bf1a 3a 24 bf			ld a, (.dmark+2)  
bf1d 32 6d ee			ld (debug_mark+2),a  
bf20 18 03			jr .pastdmark  
bf22 ..			.dmark: db "DUM"  
bf25 f1			.pastdmark: pop af  
bf26			endm  
# End of macro DMARK
bf26						CALLMONITOR 
bf26 cd 6f ee			call debug_vector  
bf29				endm  
# End of macro CALLMONITOR
bf29					endif 
bf29 cd ae 8a				call clear_display 
bf2c			 
bf2c					; get address 
bf2c			 
bf2c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bf2c cd 9d 9e			call macro_dsp_valuehl 
bf2f				endm 
# End of macro FORTH_DSP_VALUEHL
bf2f				 
bf2f					; save it for cdump 
bf2f			 
bf2f 22 e4 e5				ld (os_cur_ptr),hl 
bf32			 
bf32					; destroy value TOS 
bf32			 
bf32					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bf32 cd 55 9f			call macro_forth_dsp_pop 
bf35				endm 
# End of macro FORTH_DSP_POP
bf35			 
bf35 cd 26 9b				call dumpcont	; skip old style of param parsing	 
bf38 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
bf39					NEXTW 
bf39 c3 53 a0			jp macro_next 
bf3c				endm 
# End of macro NEXTW
bf3c			.CDUMP: 
bf3c				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
bf3c 38				db WORD_SYS_CORE+36             
bf3d 6c bf			dw .DAT            
bf3f 06				db 5 + 1 
bf40 .. 00			db "CDUMP",0              
bf46				endm 
# End of macro CWHEAD
bf46			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
bf46					if DEBUG_FORTH_WORDS_KEY 
bf46						DMARK "CDP" 
bf46 f5				push af  
bf47 3a 5b bf			ld a, (.dmark)  
bf4a 32 6b ee			ld (debug_mark),a  
bf4d 3a 5c bf			ld a, (.dmark+1)  
bf50 32 6c ee			ld (debug_mark+1),a  
bf53 3a 5d bf			ld a, (.dmark+2)  
bf56 32 6d ee			ld (debug_mark+2),a  
bf59 18 03			jr .pastdmark  
bf5b ..			.dmark: db "CDP"  
bf5e f1			.pastdmark: pop af  
bf5f			endm  
# End of macro DMARK
bf5f						CALLMONITOR 
bf5f cd 6f ee			call debug_vector  
bf62				endm  
# End of macro CALLMONITOR
bf62					endif 
bf62 cd ae 8a				call clear_display 
bf65 cd 26 9b				call dumpcont	 
bf68 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
bf69					NEXTW 
bf69 c3 53 a0			jp macro_next 
bf6c				endm 
# End of macro NEXTW
bf6c			 
bf6c			 
bf6c			 
bf6c			 
bf6c			.DAT: 
bf6c				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
bf6c 3d				db WORD_SYS_CORE+41             
bf6d c2 bf			dw .HOME            
bf6f 03				db 2 + 1 
bf70 .. 00			db "AT",0              
bf73				endm 
# End of macro CWHEAD
bf73			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
bf73					if DEBUG_FORTH_WORDS_KEY 
bf73						DMARK "AT." 
bf73 f5				push af  
bf74 3a 88 bf			ld a, (.dmark)  
bf77 32 6b ee			ld (debug_mark),a  
bf7a 3a 89 bf			ld a, (.dmark+1)  
bf7d 32 6c ee			ld (debug_mark+1),a  
bf80 3a 8a bf			ld a, (.dmark+2)  
bf83 32 6d ee			ld (debug_mark+2),a  
bf86 18 03			jr .pastdmark  
bf88 ..			.dmark: db "AT."  
bf8b f1			.pastdmark: pop af  
bf8c			endm  
# End of macro DMARK
bf8c						CALLMONITOR 
bf8c cd 6f ee			call debug_vector  
bf8f				endm  
# End of macro CALLMONITOR
bf8f					endif 
bf8f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bf8f cd 9d 9e			call macro_dsp_valuehl 
bf92				endm 
# End of macro FORTH_DSP_VALUEHL
bf92			 
bf92			 
bf92					; TODO save cursor row 
bf92 7d					ld a,l 
bf93 fe 02				cp 2 
bf95 20 04				jr nz, .crow3 
bf97 3e 28				ld a, display_row_2 
bf99 18 12				jr .ccol1 
bf9b fe 03		.crow3:		cp 3 
bf9d 20 04				jr nz, .crow4 
bf9f 3e 50				ld a, display_row_3 
bfa1 18 0a				jr .ccol1 
bfa3 fe 04		.crow4:		cp 4 
bfa5 20 04				jr nz, .crow1 
bfa7 3e 78				ld a, display_row_4 
bfa9 18 02				jr .ccol1 
bfab 3e 00		.crow1:		ld a,display_row_1 
bfad f5			.ccol1:		push af			; got row offset 
bfae 6f					ld l,a 
bfaf 26 00				ld h,0 
bfb1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bfb1 cd 55 9f			call macro_forth_dsp_pop 
bfb4				endm 
# End of macro FORTH_DSP_POP
bfb4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bfb4 cd 9d 9e			call macro_dsp_valuehl 
bfb7				endm 
# End of macro FORTH_DSP_VALUEHL
bfb7					; TODO save cursor col 
bfb7 f1					pop af 
bfb8 85					add l		; add col offset 
bfb9 32 5e ea				ld (f_cursor_ptr), a 
bfbc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bfbc cd 55 9f			call macro_forth_dsp_pop 
bfbf				endm 
# End of macro FORTH_DSP_POP
bfbf			 
bfbf					; calculate  
bfbf			 
bfbf					NEXTW 
bfbf c3 53 a0			jp macro_next 
bfc2				endm 
# End of macro NEXTW
bfc2			 
bfc2			 
bfc2			.HOME: 
bfc2				CWHEAD .CR 45 "HOME" 4 WORD_FLAG_CODE 
bfc2 41				db WORD_SYS_CORE+45             
bfc3 ef bf			dw .CR            
bfc5 05				db 4 + 1 
bfc6 .. 00			db "HOME",0              
bfcb				endm 
# End of macro CWHEAD
bfcb			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
bfcb					if DEBUG_FORTH_WORDS_KEY 
bfcb						DMARK "HOM" 
bfcb f5				push af  
bfcc 3a e0 bf			ld a, (.dmark)  
bfcf 32 6b ee			ld (debug_mark),a  
bfd2 3a e1 bf			ld a, (.dmark+1)  
bfd5 32 6c ee			ld (debug_mark+1),a  
bfd8 3a e2 bf			ld a, (.dmark+2)  
bfdb 32 6d ee			ld (debug_mark+2),a  
bfde 18 03			jr .pastdmark  
bfe0 ..			.dmark: db "HOM"  
bfe3 f1			.pastdmark: pop af  
bfe4			endm  
# End of macro DMARK
bfe4						CALLMONITOR 
bfe4 cd 6f ee			call debug_vector  
bfe7				endm  
# End of macro CALLMONITOR
bfe7					endif 
bfe7 3e 00		.home:		ld a, 0		; and home cursor 
bfe9 32 5e ea				ld (f_cursor_ptr), a 
bfec					NEXTW 
bfec c3 53 a0			jp macro_next 
bfef				endm 
# End of macro NEXTW
bfef			 
bfef			 
bfef			.CR: 
bfef				CWHEAD .SPACE 50 "CR" 2 WORD_FLAG_CODE 
bfef 46				db WORD_SYS_CORE+50             
bff0 2a c0			dw .SPACE            
bff2 03				db 2 + 1 
bff3 .. 00			db "CR",0              
bff6				endm 
# End of macro CWHEAD
bff6			; | CR (  -- s ) Push CR/LF pair onto the stack as a string  | DONE 
bff6					if DEBUG_FORTH_WORDS_KEY 
bff6						DMARK "CR." 
bff6 f5				push af  
bff7 3a 0b c0			ld a, (.dmark)  
bffa 32 6b ee			ld (debug_mark),a  
bffd 3a 0c c0			ld a, (.dmark+1)  
c000 32 6c ee			ld (debug_mark+1),a  
c003 3a 0d c0			ld a, (.dmark+2)  
c006 32 6d ee			ld (debug_mark+2),a  
c009 18 03			jr .pastdmark  
c00b ..			.dmark: db "CR."  
c00e f1			.pastdmark: pop af  
c00f			endm  
# End of macro DMARK
c00f						CALLMONITOR 
c00f cd 6f ee			call debug_vector  
c012				endm  
# End of macro CALLMONITOR
c012					endif 
c012 3e 0d				ld a, 13 
c014 32 c1 e2				ld (scratch),a 
c017 3e 0a				ld a, 10 
c019 32 c2 e2				ld (scratch+1),a 
c01c 3e 00				ld a, 0 
c01e 32 c3 e2				ld (scratch+2),a 
c021 21 c1 e2				ld hl, scratch 
c024 cd 14 9d				call forth_push_str 
c027					 
c027				       NEXTW 
c027 c3 53 a0			jp macro_next 
c02a				endm 
# End of macro NEXTW
c02a			.SPACE: 
c02a				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
c02a 46				db WORD_SYS_CORE+50             
c02b 60 c0			dw .SPACES            
c02d 03				db 2 + 1 
c02e .. 00			db "BL",0              
c031				endm 
# End of macro CWHEAD
c031			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
c031					if DEBUG_FORTH_WORDS_KEY 
c031						DMARK "BL." 
c031 f5				push af  
c032 3a 46 c0			ld a, (.dmark)  
c035 32 6b ee			ld (debug_mark),a  
c038 3a 47 c0			ld a, (.dmark+1)  
c03b 32 6c ee			ld (debug_mark+1),a  
c03e 3a 48 c0			ld a, (.dmark+2)  
c041 32 6d ee			ld (debug_mark+2),a  
c044 18 03			jr .pastdmark  
c046 ..			.dmark: db "BL."  
c049 f1			.pastdmark: pop af  
c04a			endm  
# End of macro DMARK
c04a						CALLMONITOR 
c04a cd 6f ee			call debug_vector  
c04d				endm  
# End of macro CALLMONITOR
c04d					endif 
c04d 3e 20				ld a, " " 
c04f 32 c1 e2				ld (scratch),a 
c052 3e 00				ld a, 0 
c054 32 c2 e2				ld (scratch+1),a 
c057 21 c1 e2				ld hl, scratch 
c05a cd 14 9d				call forth_push_str 
c05d					 
c05d				       NEXTW 
c05d c3 53 a0			jp macro_next 
c060				endm 
# End of macro NEXTW
c060			 
c060			;.blstr: db " ", 0 
c060			 
c060			.SPACES: 
c060				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
c060 47				db WORD_SYS_CORE+51             
c061 fb c0			dw .SCROLL            
c063 07				db 6 + 1 
c064 .. 00			db "SPACES",0              
c06b				endm 
# End of macro CWHEAD
c06b			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
c06b					if DEBUG_FORTH_WORDS_KEY 
c06b						DMARK "SPS" 
c06b f5				push af  
c06c 3a 80 c0			ld a, (.dmark)  
c06f 32 6b ee			ld (debug_mark),a  
c072 3a 81 c0			ld a, (.dmark+1)  
c075 32 6c ee			ld (debug_mark+1),a  
c078 3a 82 c0			ld a, (.dmark+2)  
c07b 32 6d ee			ld (debug_mark+2),a  
c07e 18 03			jr .pastdmark  
c080 ..			.dmark: db "SPS"  
c083 f1			.pastdmark: pop af  
c084			endm  
# End of macro DMARK
c084						CALLMONITOR 
c084 cd 6f ee			call debug_vector  
c087				endm  
# End of macro CALLMONITOR
c087					endif 
c087			 
c087			 
c087					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c087 cd 9d 9e			call macro_dsp_valuehl 
c08a				endm 
# End of macro FORTH_DSP_VALUEHL
c08a			 
c08a e5					push hl    ; u 
c08b					if DEBUG_FORTH_WORDS 
c08b						DMARK "SPA" 
c08b f5				push af  
c08c 3a a0 c0			ld a, (.dmark)  
c08f 32 6b ee			ld (debug_mark),a  
c092 3a a1 c0			ld a, (.dmark+1)  
c095 32 6c ee			ld (debug_mark+1),a  
c098 3a a2 c0			ld a, (.dmark+2)  
c09b 32 6d ee			ld (debug_mark+2),a  
c09e 18 03			jr .pastdmark  
c0a0 ..			.dmark: db "SPA"  
c0a3 f1			.pastdmark: pop af  
c0a4			endm  
# End of macro DMARK
c0a4						CALLMONITOR 
c0a4 cd 6f ee			call debug_vector  
c0a7				endm  
# End of macro CALLMONITOR
c0a7					endif 
c0a7			 
c0a7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c0a7 cd 55 9f			call macro_forth_dsp_pop 
c0aa				endm 
# End of macro FORTH_DSP_POP
c0aa e1					pop hl 
c0ab 0e 00				ld c, 0 
c0ad 45					ld b, l 
c0ae 21 c1 e2				ld hl, scratch  
c0b1			 
c0b1					if DEBUG_FORTH_WORDS 
c0b1						DMARK "SP2" 
c0b1 f5				push af  
c0b2 3a c6 c0			ld a, (.dmark)  
c0b5 32 6b ee			ld (debug_mark),a  
c0b8 3a c7 c0			ld a, (.dmark+1)  
c0bb 32 6c ee			ld (debug_mark+1),a  
c0be 3a c8 c0			ld a, (.dmark+2)  
c0c1 32 6d ee			ld (debug_mark+2),a  
c0c4 18 03			jr .pastdmark  
c0c6 ..			.dmark: db "SP2"  
c0c9 f1			.pastdmark: pop af  
c0ca			endm  
# End of macro DMARK
c0ca						CALLMONITOR 
c0ca cd 6f ee			call debug_vector  
c0cd				endm  
# End of macro CALLMONITOR
c0cd					endif 
c0cd 3e 20				ld a, ' ' 
c0cf			.spaces1:	 
c0cf 77					ld (hl),a 
c0d0 23					inc hl 
c0d1					 
c0d1 10 fc				djnz .spaces1 
c0d3 3e 00				ld a,0 
c0d5 77					ld (hl),a 
c0d6 21 c1 e2				ld hl, scratch 
c0d9					if DEBUG_FORTH_WORDS 
c0d9						DMARK "SP3" 
c0d9 f5				push af  
c0da 3a ee c0			ld a, (.dmark)  
c0dd 32 6b ee			ld (debug_mark),a  
c0e0 3a ef c0			ld a, (.dmark+1)  
c0e3 32 6c ee			ld (debug_mark+1),a  
c0e6 3a f0 c0			ld a, (.dmark+2)  
c0e9 32 6d ee			ld (debug_mark+2),a  
c0ec 18 03			jr .pastdmark  
c0ee ..			.dmark: db "SP3"  
c0f1 f1			.pastdmark: pop af  
c0f2			endm  
# End of macro DMARK
c0f2						CALLMONITOR 
c0f2 cd 6f ee			call debug_vector  
c0f5				endm  
# End of macro CALLMONITOR
c0f5					endif 
c0f5 cd 14 9d				call forth_push_str 
c0f8			 
c0f8				       NEXTW 
c0f8 c3 53 a0			jp macro_next 
c0fb				endm 
# End of macro NEXTW
c0fb			 
c0fb			 
c0fb			 
c0fb			.SCROLL: 
c0fb				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
c0fb 53				db WORD_SYS_CORE+63             
c0fc 28 c1			dw .SCROLLD            
c0fe 07				db 6 + 1 
c0ff .. 00			db "SCROLL",0              
c106				endm 
# End of macro CWHEAD
c106			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
c106					if DEBUG_FORTH_WORDS_KEY 
c106						DMARK "SCR" 
c106 f5				push af  
c107 3a 1b c1			ld a, (.dmark)  
c10a 32 6b ee			ld (debug_mark),a  
c10d 3a 1c c1			ld a, (.dmark+1)  
c110 32 6c ee			ld (debug_mark+1),a  
c113 3a 1d c1			ld a, (.dmark+2)  
c116 32 6d ee			ld (debug_mark+2),a  
c119 18 03			jr .pastdmark  
c11b ..			.dmark: db "SCR"  
c11e f1			.pastdmark: pop af  
c11f			endm  
# End of macro DMARK
c11f						CALLMONITOR 
c11f cd 6f ee			call debug_vector  
c122				endm  
# End of macro CALLMONITOR
c122					endif 
c122			 
c122 cd 70 8a			call scroll_up 
c125			;	call update_display 
c125			 
c125					NEXTW 
c125 c3 53 a0			jp macro_next 
c128				endm 
# End of macro NEXTW
c128			 
c128			 
c128			 
c128			;		; get dir 
c128			; 
c128			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c128			; 
c128			;		push hl 
c128			; 
c128			;		; destroy value TOS 
c128			; 
c128			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c128			; 
c128			;		; get count 
c128			; 
c128			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c128			; 
c128			;		push hl 
c128			; 
c128			;		; destroy value TOS 
c128			; 
c128			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c128			; 
c128			;		; one value on hl get other one back 
c128			; 
c128			;		pop bc    ; count 
c128			; 
c128			;		pop de   ; dir 
c128			; 
c128			; 
c128			;		ld b, c 
c128			; 
c128			;.scrolldir:     push bc 
c128			;		push de 
c128			; 
c128			;		ld a, 0 
c128			;		cp e 
c128			;		jr z, .scrollup  
c128			;		call scroll_down 
c128			;		jr .scrollnext 
c128			;.scrollup:	call scroll_up 
c128			; 
c128			;		 
c128			;.scrollnext: 
c128			;		pop de 
c128			;		pop bc 
c128			;		djnz .scrolldir 
c128			; 
c128			; 
c128			; 
c128			; 
c128			; 
c128			;		NEXTW 
c128			 
c128			.SCROLLD: 
c128				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
c128 53				db WORD_SYS_CORE+63             
c129 56 c1			dw .ATQ            
c12b 08				db 7 + 1 
c12c .. 00			db "SCROLLD",0              
c134				endm 
# End of macro CWHEAD
c134			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
c134					if DEBUG_FORTH_WORDS_KEY 
c134						DMARK "SCD" 
c134 f5				push af  
c135 3a 49 c1			ld a, (.dmark)  
c138 32 6b ee			ld (debug_mark),a  
c13b 3a 4a c1			ld a, (.dmark+1)  
c13e 32 6c ee			ld (debug_mark+1),a  
c141 3a 4b c1			ld a, (.dmark+2)  
c144 32 6d ee			ld (debug_mark+2),a  
c147 18 03			jr .pastdmark  
c149 ..			.dmark: db "SCD"  
c14c f1			.pastdmark: pop af  
c14d			endm  
# End of macro DMARK
c14d						CALLMONITOR 
c14d cd 6f ee			call debug_vector  
c150				endm  
# End of macro CALLMONITOR
c150					endif 
c150			 
c150 cd 94 8a			call scroll_down 
c153			;	call update_display 
c153			 
c153					NEXTW 
c153 c3 53 a0			jp macro_next 
c156				endm 
# End of macro NEXTW
c156			 
c156			 
c156			.ATQ: 
c156				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
c156 62				db WORD_SYS_CORE+78             
c157 b4 c1			dw .AUTODSP            
c159 04				db 3 + 1 
c15a .. 00			db "AT@",0              
c15e				endm 
# End of macro CWHEAD
c15e			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
c15e					if DEBUG_FORTH_WORDS_KEY 
c15e						DMARK "ATA" 
c15e f5				push af  
c15f 3a 73 c1			ld a, (.dmark)  
c162 32 6b ee			ld (debug_mark),a  
c165 3a 74 c1			ld a, (.dmark+1)  
c168 32 6c ee			ld (debug_mark+1),a  
c16b 3a 75 c1			ld a, (.dmark+2)  
c16e 32 6d ee			ld (debug_mark+2),a  
c171 18 03			jr .pastdmark  
c173 ..			.dmark: db "ATA"  
c176 f1			.pastdmark: pop af  
c177			endm  
# End of macro DMARK
c177						CALLMONITOR 
c177 cd 6f ee			call debug_vector  
c17a				endm  
# End of macro CALLMONITOR
c17a					endif 
c17a			 
c17a			 
c17a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c17a cd 9d 9e			call macro_dsp_valuehl 
c17d				endm 
# End of macro FORTH_DSP_VALUEHL
c17d			 
c17d					; TODO save cursor row 
c17d 7d					ld a,l 
c17e fe 02				cp 2 
c180 20 04				jr nz, .crow3aq 
c182 3e 28				ld a, display_row_2 
c184 18 12				jr .ccol1aq 
c186 fe 03		.crow3aq:		cp 3 
c188 20 04				jr nz, .crow4aq 
c18a 3e 50				ld a, display_row_3 
c18c 18 0a				jr .ccol1aq 
c18e fe 04		.crow4aq:		cp 4 
c190 20 04				jr nz, .crow1aq 
c192 3e 78				ld a, display_row_4 
c194 18 02				jr .ccol1aq 
c196 3e 00		.crow1aq:		ld a,display_row_1 
c198 f5			.ccol1aq:		push af			; got row offset 
c199 6f					ld l,a 
c19a 26 00				ld h,0 
c19c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c19c cd 55 9f			call macro_forth_dsp_pop 
c19f				endm 
# End of macro FORTH_DSP_POP
c19f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c19f cd 9d 9e			call macro_dsp_valuehl 
c1a2				endm 
# End of macro FORTH_DSP_VALUEHL
c1a2					; TODO save cursor col 
c1a2 f1					pop af 
c1a3 85					add l		; add col offset 
c1a4			 
c1a4					; add current frame buffer address 
c1a4 2a cc eb				ld hl, (display_fb_active) 
c1a7 cd db 8c				call addatohl 
c1aa			 
c1aa			 
c1aa			 
c1aa			 
c1aa					; get char frame buffer location offset in hl 
c1aa			 
c1aa 7e					ld a,(hl) 
c1ab 26 00				ld h, 0 
c1ad 6f					ld l, a 
c1ae			 
c1ae cd a6 9c				call forth_push_numhl 
c1b1			 
c1b1			 
c1b1					NEXTW 
c1b1 c3 53 a0			jp macro_next 
c1b4				endm 
# End of macro NEXTW
c1b4			 
c1b4			.AUTODSP: 
c1b4				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
c1b4 63				db WORD_SYS_CORE+79             
c1b5 ca c1			dw .MENU            
c1b7 05				db 4 + 1 
c1b8 .. 00			db "ADSP",0              
c1bd				endm 
# End of macro CWHEAD
c1bd			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
c1bd			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
c1bd			 
c1bd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c1bd cd 9d 9e			call macro_dsp_valuehl 
c1c0				endm 
# End of macro FORTH_DSP_VALUEHL
c1c0			 
c1c0			;		push hl 
c1c0			 
c1c0					; destroy value TOS 
c1c0			 
c1c0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c1c0 cd 55 9f			call macro_forth_dsp_pop 
c1c3				endm 
# End of macro FORTH_DSP_POP
c1c3			 
c1c3			;		pop hl 
c1c3			 
c1c3 7d					ld a,l 
c1c4 32 3c ea				ld (cli_autodisplay), a 
c1c7				       NEXTW 
c1c7 c3 53 a0			jp macro_next 
c1ca				endm 
# End of macro NEXTW
c1ca			 
c1ca			.MENU: 
c1ca				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
c1ca 70				db WORD_SYS_CORE+92             
c1cb 73 c2			dw .ENDDISPLAY            
c1cd 05				db 4 + 1 
c1ce .. 00			db "MENU",0              
c1d3				endm 
# End of macro CWHEAD
c1d3			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | DONE 
c1d3			 
c1d3			;		; get number of items on the stack 
c1d3			; 
c1d3				 
c1d3					FORTH_DSP_VALUEHL 
c1d3 cd 9d 9e			call macro_dsp_valuehl 
c1d6				endm 
# End of macro FORTH_DSP_VALUEHL
c1d6				 
c1d6					if DEBUG_FORTH_WORDS_KEY 
c1d6						DMARK "MNU" 
c1d6 f5				push af  
c1d7 3a eb c1			ld a, (.dmark)  
c1da 32 6b ee			ld (debug_mark),a  
c1dd 3a ec c1			ld a, (.dmark+1)  
c1e0 32 6c ee			ld (debug_mark+1),a  
c1e3 3a ed c1			ld a, (.dmark+2)  
c1e6 32 6d ee			ld (debug_mark+2),a  
c1e9 18 03			jr .pastdmark  
c1eb ..			.dmark: db "MNU"  
c1ee f1			.pastdmark: pop af  
c1ef			endm  
# End of macro DMARK
c1ef						CALLMONITOR 
c1ef cd 6f ee			call debug_vector  
c1f2				endm  
# End of macro CALLMONITOR
c1f2					endif 
c1f2			 
c1f2 45					ld b, l	 
c1f3 05					dec b 
c1f4			 
c1f4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c1f4 cd 55 9f			call macro_forth_dsp_pop 
c1f7				endm 
# End of macro FORTH_DSP_POP
c1f7			 
c1f7			 
c1f7					; go directly through the stack to pluck out the string pointers and build an array 
c1f7			 
c1f7			;		FORTH_DSP 
c1f7			 
c1f7					; hl contains top most stack item 
c1f7				 
c1f7 11 c1 e2				ld de, scratch 
c1fa			 
c1fa			.mbuild: 
c1fa			 
c1fa					FORTH_DSP_VALUEHL 
c1fa cd 9d 9e			call macro_dsp_valuehl 
c1fd				endm 
# End of macro FORTH_DSP_VALUEHL
c1fd			 
c1fd					if DEBUG_FORTH_WORDS 
c1fd						DMARK "MN3" 
c1fd f5				push af  
c1fe 3a 12 c2			ld a, (.dmark)  
c201 32 6b ee			ld (debug_mark),a  
c204 3a 13 c2			ld a, (.dmark+1)  
c207 32 6c ee			ld (debug_mark+1),a  
c20a 3a 14 c2			ld a, (.dmark+2)  
c20d 32 6d ee			ld (debug_mark+2),a  
c210 18 03			jr .pastdmark  
c212 ..			.dmark: db "MN3"  
c215 f1			.pastdmark: pop af  
c216			endm  
# End of macro DMARK
c216						CALLMONITOR 
c216 cd 6f ee			call debug_vector  
c219				endm  
# End of macro CALLMONITOR
c219					endif 
c219 eb					ex de, hl 
c21a 73					ld (hl), e 
c21b 23					inc hl 
c21c 72					ld (hl), d 
c21d 23					inc hl 
c21e eb					ex de, hl 
c21f			 
c21f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c21f cd 55 9f			call macro_forth_dsp_pop 
c222				endm 
# End of macro FORTH_DSP_POP
c222			 
c222 10 d6				djnz .mbuild 
c224			 
c224					; done add term 
c224			 
c224 eb					ex de, hl 
c225 36 00				ld (hl), 0 
c227 23					inc hl 
c228 36 00				ld (hl), 0 
c22a			 
c22a				 
c22a					 
c22a 21 c1 e2				ld hl, scratch 
c22d			 
c22d					if DEBUG_FORTH_WORDS 
c22d						DMARK "MNx" 
c22d f5				push af  
c22e 3a 42 c2			ld a, (.dmark)  
c231 32 6b ee			ld (debug_mark),a  
c234 3a 43 c2			ld a, (.dmark+1)  
c237 32 6c ee			ld (debug_mark+1),a  
c23a 3a 44 c2			ld a, (.dmark+2)  
c23d 32 6d ee			ld (debug_mark+2),a  
c240 18 03			jr .pastdmark  
c242 ..			.dmark: db "MNx"  
c245 f1			.pastdmark: pop af  
c246			endm  
# End of macro DMARK
c246						CALLMONITOR 
c246 cd 6f ee			call debug_vector  
c249				endm  
# End of macro CALLMONITOR
c249					endif 
c249			 
c249			 
c249			 
c249 3e 00				ld a, 0 
c24b cd df 8a				call menu 
c24e			 
c24e			 
c24e 6f					ld l, a 
c24f 26 00				ld h, 0 
c251			 
c251					if DEBUG_FORTH_WORDS 
c251						DMARK "MNr" 
c251 f5				push af  
c252 3a 66 c2			ld a, (.dmark)  
c255 32 6b ee			ld (debug_mark),a  
c258 3a 67 c2			ld a, (.dmark+1)  
c25b 32 6c ee			ld (debug_mark+1),a  
c25e 3a 68 c2			ld a, (.dmark+2)  
c261 32 6d ee			ld (debug_mark+2),a  
c264 18 03			jr .pastdmark  
c266 ..			.dmark: db "MNr"  
c269 f1			.pastdmark: pop af  
c26a			endm  
# End of macro DMARK
c26a						CALLMONITOR 
c26a cd 6f ee			call debug_vector  
c26d				endm  
# End of macro CALLMONITOR
c26d					endif 
c26d			 
c26d cd a6 9c				call forth_push_numhl 
c270			 
c270			 
c270			 
c270			 
c270				       NEXTW 
c270 c3 53 a0			jp macro_next 
c273				endm 
# End of macro NEXTW
c273			 
c273			 
c273			.ENDDISPLAY: 
c273			 
c273			; eof 
# End of file forth_words_display.asm
c273			include "forth_words_str.asm" 
c273			 
c273			; | ## String Words 
c273			 
c273			.PTR:   
c273			 
c273				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
c273 48				db WORD_SYS_CORE+52             
c274 a0 c2			dw .STYPE            
c276 04				db 3 + 1 
c277 .. 00			db "PTR",0              
c27b				endm 
# End of macro CWHEAD
c27b			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
c27b			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
c27b			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
c27b			 
c27b					if DEBUG_FORTH_WORDS_KEY 
c27b						DMARK "PTR" 
c27b f5				push af  
c27c 3a 90 c2			ld a, (.dmark)  
c27f 32 6b ee			ld (debug_mark),a  
c282 3a 91 c2			ld a, (.dmark+1)  
c285 32 6c ee			ld (debug_mark+1),a  
c288 3a 92 c2			ld a, (.dmark+2)  
c28b 32 6d ee			ld (debug_mark+2),a  
c28e 18 03			jr .pastdmark  
c290 ..			.dmark: db "PTR"  
c293 f1			.pastdmark: pop af  
c294			endm  
# End of macro DMARK
c294						CALLMONITOR 
c294 cd 6f ee			call debug_vector  
c297				endm  
# End of macro CALLMONITOR
c297					endif 
c297					FORTH_DSP_VALUEHL 
c297 cd 9d 9e			call macro_dsp_valuehl 
c29a				endm 
# End of macro FORTH_DSP_VALUEHL
c29a cd a6 9c				call forth_push_numhl 
c29d			 
c29d			 
c29d					NEXTW 
c29d c3 53 a0			jp macro_next 
c2a0				endm 
# End of macro NEXTW
c2a0			.STYPE: 
c2a0				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
c2a0 48				db WORD_SYS_CORE+52             
c2a1 ef c2			dw .UPPER            
c2a3 06				db 5 + 1 
c2a4 .. 00			db "STYPE",0              
c2aa				endm 
# End of macro CWHEAD
c2aa			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
c2aa					if DEBUG_FORTH_WORDS_KEY 
c2aa						DMARK "STY" 
c2aa f5				push af  
c2ab 3a bf c2			ld a, (.dmark)  
c2ae 32 6b ee			ld (debug_mark),a  
c2b1 3a c0 c2			ld a, (.dmark+1)  
c2b4 32 6c ee			ld (debug_mark+1),a  
c2b7 3a c1 c2			ld a, (.dmark+2)  
c2ba 32 6d ee			ld (debug_mark+2),a  
c2bd 18 03			jr .pastdmark  
c2bf ..			.dmark: db "STY"  
c2c2 f1			.pastdmark: pop af  
c2c3			endm  
# End of macro DMARK
c2c3						CALLMONITOR 
c2c3 cd 6f ee			call debug_vector  
c2c6				endm  
# End of macro CALLMONITOR
c2c6					endif 
c2c6					FORTH_DSP 
c2c6 cd 63 9e			call macro_forth_dsp 
c2c9				endm 
# End of macro FORTH_DSP
c2c9					;v5 FORTH_DSP_VALUE 
c2c9			 
c2c9 7e					ld a, (hl) 
c2ca			 
c2ca f5					push af 
c2cb			 
c2cb			; Dont destroy TOS		FORTH_DSP_POP 
c2cb			 
c2cb f1					pop af 
c2cc			 
c2cc fe 01				cp DS_TYPE_STR 
c2ce 28 09				jr z, .typestr 
c2d0			 
c2d0 fe 02				cp DS_TYPE_INUM 
c2d2 28 0a				jr z, .typeinum 
c2d4			 
c2d4 21 ed c2				ld hl, .tna 
c2d7 18 0a				jr .tpush 
c2d9			 
c2d9 21 e9 c2		.typestr:	ld hl, .tstr 
c2dc 18 05				jr .tpush 
c2de 21 eb c2		.typeinum:	ld hl, .tinum 
c2e1 18 00				jr .tpush 
c2e3			 
c2e3			.tpush: 
c2e3			 
c2e3 cd 14 9d				call forth_push_str 
c2e6			 
c2e6					NEXTW 
c2e6 c3 53 a0			jp macro_next 
c2e9				endm 
# End of macro NEXTW
c2e9 .. 00		.tstr:	db "s",0 
c2eb .. 00		.tinum:  db "i",0 
c2ed .. 00		.tna:   db "?", 0 
c2ef			 
c2ef			 
c2ef			.UPPER: 
c2ef				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
c2ef 48				db WORD_SYS_CORE+52             
c2f0 2a c3			dw .LOWER            
c2f2 06				db 5 + 1 
c2f3 .. 00			db "UPPER",0              
c2f9				endm 
# End of macro CWHEAD
c2f9			; | UPPER ( s -- s ) Upper case string s  | DONE 
c2f9					if DEBUG_FORTH_WORDS_KEY 
c2f9						DMARK "UPR" 
c2f9 f5				push af  
c2fa 3a 0e c3			ld a, (.dmark)  
c2fd 32 6b ee			ld (debug_mark),a  
c300 3a 0f c3			ld a, (.dmark+1)  
c303 32 6c ee			ld (debug_mark+1),a  
c306 3a 10 c3			ld a, (.dmark+2)  
c309 32 6d ee			ld (debug_mark+2),a  
c30c 18 03			jr .pastdmark  
c30e ..			.dmark: db "UPR"  
c311 f1			.pastdmark: pop af  
c312			endm  
# End of macro DMARK
c312						CALLMONITOR 
c312 cd 6f ee			call debug_vector  
c315				endm  
# End of macro CALLMONITOR
c315					endif 
c315			 
c315					FORTH_DSP 
c315 cd 63 9e			call macro_forth_dsp 
c318				endm 
# End of macro FORTH_DSP
c318					 
c318			; TODO check is string type 
c318			 
c318					FORTH_DSP_VALUEHL 
c318 cd 9d 9e			call macro_dsp_valuehl 
c31b				endm 
# End of macro FORTH_DSP_VALUEHL
c31b			; get pointer to string in hl 
c31b			 
c31b 7e			.toup:		ld a, (hl) 
c31c fe 00				cp 0 
c31e 28 07				jr z, .toupdone 
c320			 
c320 cd a7 91				call to_upper 
c323			 
c323 77					ld (hl), a 
c324 23					inc hl 
c325 18 f4				jr .toup 
c327			 
c327					 
c327			 
c327			 
c327			; for each char convert to upper 
c327					 
c327			.toupdone: 
c327			 
c327			 
c327					NEXTW 
c327 c3 53 a0			jp macro_next 
c32a				endm 
# End of macro NEXTW
c32a			.LOWER: 
c32a				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
c32a 48				db WORD_SYS_CORE+52             
c32b 65 c3			dw .TCASE            
c32d 06				db 5 + 1 
c32e .. 00			db "LOWER",0              
c334				endm 
# End of macro CWHEAD
c334			; | LOWER ( s -- s ) Lower case string s  | DONE 
c334					if DEBUG_FORTH_WORDS_KEY 
c334						DMARK "LWR" 
c334 f5				push af  
c335 3a 49 c3			ld a, (.dmark)  
c338 32 6b ee			ld (debug_mark),a  
c33b 3a 4a c3			ld a, (.dmark+1)  
c33e 32 6c ee			ld (debug_mark+1),a  
c341 3a 4b c3			ld a, (.dmark+2)  
c344 32 6d ee			ld (debug_mark+2),a  
c347 18 03			jr .pastdmark  
c349 ..			.dmark: db "LWR"  
c34c f1			.pastdmark: pop af  
c34d			endm  
# End of macro DMARK
c34d						CALLMONITOR 
c34d cd 6f ee			call debug_vector  
c350				endm  
# End of macro CALLMONITOR
c350					endif 
c350			 
c350					FORTH_DSP 
c350 cd 63 9e			call macro_forth_dsp 
c353				endm 
# End of macro FORTH_DSP
c353					 
c353			; TODO check is string type 
c353			 
c353					FORTH_DSP_VALUEHL 
c353 cd 9d 9e			call macro_dsp_valuehl 
c356				endm 
# End of macro FORTH_DSP_VALUEHL
c356			; get pointer to string in hl 
c356			 
c356 7e			.tolow:		ld a, (hl) 
c357 fe 00				cp 0 
c359 28 07				jr z, .tolowdone 
c35b			 
c35b cd b0 91				call to_lower 
c35e			 
c35e 77					ld (hl), a 
c35f 23					inc hl 
c360 18 f4				jr .tolow 
c362			 
c362					 
c362			 
c362			 
c362			; for each char convert to low 
c362					 
c362			.tolowdone: 
c362					NEXTW 
c362 c3 53 a0			jp macro_next 
c365				endm 
# End of macro NEXTW
c365			.TCASE: 
c365				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
c365 48				db WORD_SYS_CORE+52             
c366 9b c4			dw .SUBSTR            
c368 06				db 5 + 1 
c369 .. 00			db "TCASE",0              
c36f				endm 
# End of macro CWHEAD
c36f			; | TCASE ( s -- s ) Title case string s  | DONE 
c36f					if DEBUG_FORTH_WORDS_KEY 
c36f						DMARK "TCS" 
c36f f5				push af  
c370 3a 84 c3			ld a, (.dmark)  
c373 32 6b ee			ld (debug_mark),a  
c376 3a 85 c3			ld a, (.dmark+1)  
c379 32 6c ee			ld (debug_mark+1),a  
c37c 3a 86 c3			ld a, (.dmark+2)  
c37f 32 6d ee			ld (debug_mark+2),a  
c382 18 03			jr .pastdmark  
c384 ..			.dmark: db "TCS"  
c387 f1			.pastdmark: pop af  
c388			endm  
# End of macro DMARK
c388						CALLMONITOR 
c388 cd 6f ee			call debug_vector  
c38b				endm  
# End of macro CALLMONITOR
c38b					endif 
c38b			 
c38b					FORTH_DSP 
c38b cd 63 9e			call macro_forth_dsp 
c38e				endm 
# End of macro FORTH_DSP
c38e					 
c38e			; TODO check is string type 
c38e			 
c38e					FORTH_DSP_VALUEHL 
c38e cd 9d 9e			call macro_dsp_valuehl 
c391				endm 
# End of macro FORTH_DSP_VALUEHL
c391			; get pointer to string in hl 
c391			 
c391					if DEBUG_FORTH_WORDS 
c391						DMARK "TC1" 
c391 f5				push af  
c392 3a a6 c3			ld a, (.dmark)  
c395 32 6b ee			ld (debug_mark),a  
c398 3a a7 c3			ld a, (.dmark+1)  
c39b 32 6c ee			ld (debug_mark+1),a  
c39e 3a a8 c3			ld a, (.dmark+2)  
c3a1 32 6d ee			ld (debug_mark+2),a  
c3a4 18 03			jr .pastdmark  
c3a6 ..			.dmark: db "TC1"  
c3a9 f1			.pastdmark: pop af  
c3aa			endm  
# End of macro DMARK
c3aa						CALLMONITOR 
c3aa cd 6f ee			call debug_vector  
c3ad				endm  
# End of macro CALLMONITOR
c3ad					endif 
c3ad			 
c3ad					; first time in turn to upper case first char 
c3ad			 
c3ad 7e					ld a, (hl) 
c3ae c3 38 c4				jp .totsiptou 
c3b1			 
c3b1			 
c3b1 7e			.tot:		ld a, (hl) 
c3b2 fe 00				cp 0 
c3b4 ca 7c c4				jp z, .totdone 
c3b7			 
c3b7					if DEBUG_FORTH_WORDS 
c3b7						DMARK "TC2" 
c3b7 f5				push af  
c3b8 3a cc c3			ld a, (.dmark)  
c3bb 32 6b ee			ld (debug_mark),a  
c3be 3a cd c3			ld a, (.dmark+1)  
c3c1 32 6c ee			ld (debug_mark+1),a  
c3c4 3a ce c3			ld a, (.dmark+2)  
c3c7 32 6d ee			ld (debug_mark+2),a  
c3ca 18 03			jr .pastdmark  
c3cc ..			.dmark: db "TC2"  
c3cf f1			.pastdmark: pop af  
c3d0			endm  
# End of macro DMARK
c3d0						CALLMONITOR 
c3d0 cd 6f ee			call debug_vector  
c3d3				endm  
# End of macro CALLMONITOR
c3d3					endif 
c3d3					; check to see if current char is a space 
c3d3			 
c3d3 fe 20				cp ' ' 
c3d5 28 21				jr z, .totsp 
c3d7 cd b0 91				call to_lower 
c3da					if DEBUG_FORTH_WORDS 
c3da						DMARK "TC3" 
c3da f5				push af  
c3db 3a ef c3			ld a, (.dmark)  
c3de 32 6b ee			ld (debug_mark),a  
c3e1 3a f0 c3			ld a, (.dmark+1)  
c3e4 32 6c ee			ld (debug_mark+1),a  
c3e7 3a f1 c3			ld a, (.dmark+2)  
c3ea 32 6d ee			ld (debug_mark+2),a  
c3ed 18 03			jr .pastdmark  
c3ef ..			.dmark: db "TC3"  
c3f2 f1			.pastdmark: pop af  
c3f3			endm  
# End of macro DMARK
c3f3						CALLMONITOR 
c3f3 cd 6f ee			call debug_vector  
c3f6				endm  
# End of macro CALLMONITOR
c3f6					endif 
c3f6 18 63				jr .totnxt 
c3f8			 
c3f8			.totsp:         ; on a space, find next char which should be upper 
c3f8			 
c3f8					if DEBUG_FORTH_WORDS 
c3f8						DMARK "TC4" 
c3f8 f5				push af  
c3f9 3a 0d c4			ld a, (.dmark)  
c3fc 32 6b ee			ld (debug_mark),a  
c3ff 3a 0e c4			ld a, (.dmark+1)  
c402 32 6c ee			ld (debug_mark+1),a  
c405 3a 0f c4			ld a, (.dmark+2)  
c408 32 6d ee			ld (debug_mark+2),a  
c40b 18 03			jr .pastdmark  
c40d ..			.dmark: db "TC4"  
c410 f1			.pastdmark: pop af  
c411			endm  
# End of macro DMARK
c411						CALLMONITOR 
c411 cd 6f ee			call debug_vector  
c414				endm  
# End of macro CALLMONITOR
c414					endif 
c414					;; 
c414			 
c414 fe 20				cp ' ' 
c416 20 20				jr nz, .totsiptou 
c418 23					inc hl 
c419 7e					ld a, (hl) 
c41a					if DEBUG_FORTH_WORDS 
c41a						DMARK "TC5" 
c41a f5				push af  
c41b 3a 2f c4			ld a, (.dmark)  
c41e 32 6b ee			ld (debug_mark),a  
c421 3a 30 c4			ld a, (.dmark+1)  
c424 32 6c ee			ld (debug_mark+1),a  
c427 3a 31 c4			ld a, (.dmark+2)  
c42a 32 6d ee			ld (debug_mark+2),a  
c42d 18 03			jr .pastdmark  
c42f ..			.dmark: db "TC5"  
c432 f1			.pastdmark: pop af  
c433			endm  
# End of macro DMARK
c433						CALLMONITOR 
c433 cd 6f ee			call debug_vector  
c436				endm  
# End of macro CALLMONITOR
c436					endif 
c436 18 c0				jr .totsp 
c438 fe 00		.totsiptou:    cp 0 
c43a 28 40				jr z, .totdone 
c43c					; not space and not zero term so upper case it 
c43c cd a7 91				call to_upper 
c43f			 
c43f					if DEBUG_FORTH_WORDS 
c43f						DMARK "TC6" 
c43f f5				push af  
c440 3a 54 c4			ld a, (.dmark)  
c443 32 6b ee			ld (debug_mark),a  
c446 3a 55 c4			ld a, (.dmark+1)  
c449 32 6c ee			ld (debug_mark+1),a  
c44c 3a 56 c4			ld a, (.dmark+2)  
c44f 32 6d ee			ld (debug_mark+2),a  
c452 18 03			jr .pastdmark  
c454 ..			.dmark: db "TC6"  
c457 f1			.pastdmark: pop af  
c458			endm  
# End of macro DMARK
c458						CALLMONITOR 
c458 cd 6f ee			call debug_vector  
c45b				endm  
# End of macro CALLMONITOR
c45b					endif 
c45b			 
c45b			 
c45b			.totnxt: 
c45b			 
c45b 77					ld (hl), a 
c45c 23					inc hl 
c45d					if DEBUG_FORTH_WORDS 
c45d						DMARK "TC7" 
c45d f5				push af  
c45e 3a 72 c4			ld a, (.dmark)  
c461 32 6b ee			ld (debug_mark),a  
c464 3a 73 c4			ld a, (.dmark+1)  
c467 32 6c ee			ld (debug_mark+1),a  
c46a 3a 74 c4			ld a, (.dmark+2)  
c46d 32 6d ee			ld (debug_mark+2),a  
c470 18 03			jr .pastdmark  
c472 ..			.dmark: db "TC7"  
c475 f1			.pastdmark: pop af  
c476			endm  
# End of macro DMARK
c476						CALLMONITOR 
c476 cd 6f ee			call debug_vector  
c479				endm  
# End of macro CALLMONITOR
c479					endif 
c479 c3 b1 c3				jp .tot 
c47c			 
c47c					 
c47c			 
c47c			 
c47c			; for each char convert to low 
c47c					 
c47c			.totdone: 
c47c					if DEBUG_FORTH_WORDS 
c47c						DMARK "TCd" 
c47c f5				push af  
c47d 3a 91 c4			ld a, (.dmark)  
c480 32 6b ee			ld (debug_mark),a  
c483 3a 92 c4			ld a, (.dmark+1)  
c486 32 6c ee			ld (debug_mark+1),a  
c489 3a 93 c4			ld a, (.dmark+2)  
c48c 32 6d ee			ld (debug_mark+2),a  
c48f 18 03			jr .pastdmark  
c491 ..			.dmark: db "TCd"  
c494 f1			.pastdmark: pop af  
c495			endm  
# End of macro DMARK
c495						CALLMONITOR 
c495 cd 6f ee			call debug_vector  
c498				endm  
# End of macro CALLMONITOR
c498					endif 
c498					NEXTW 
c498 c3 53 a0			jp macro_next 
c49b				endm 
# End of macro NEXTW
c49b			 
c49b			.SUBSTR: 
c49b				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
c49b 48				db WORD_SYS_CORE+52             
c49c f9 c4			dw .LEFT            
c49e 07				db 6 + 1 
c49f .. 00			db "SUBSTR",0              
c4a6				endm 
# End of macro CWHEAD
c4a6			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
c4a6			 
c4a6					if DEBUG_FORTH_WORDS_KEY 
c4a6						DMARK "SST" 
c4a6 f5				push af  
c4a7 3a bb c4			ld a, (.dmark)  
c4aa 32 6b ee			ld (debug_mark),a  
c4ad 3a bc c4			ld a, (.dmark+1)  
c4b0 32 6c ee			ld (debug_mark+1),a  
c4b3 3a bd c4			ld a, (.dmark+2)  
c4b6 32 6d ee			ld (debug_mark+2),a  
c4b9 18 03			jr .pastdmark  
c4bb ..			.dmark: db "SST"  
c4be f1			.pastdmark: pop af  
c4bf			endm  
# End of macro DMARK
c4bf						CALLMONITOR 
c4bf cd 6f ee			call debug_vector  
c4c2				endm  
# End of macro CALLMONITOR
c4c2					endif 
c4c2			; TODO check string type 
c4c2					FORTH_DSP_VALUEHL 
c4c2 cd 9d 9e			call macro_dsp_valuehl 
c4c5				endm 
# End of macro FORTH_DSP_VALUEHL
c4c5			 
c4c5 e5					push hl      ; string length 
c4c6			 
c4c6					FORTH_DSP_POP 
c4c6 cd 55 9f			call macro_forth_dsp_pop 
c4c9				endm 
# End of macro FORTH_DSP_POP
c4c9			 
c4c9					FORTH_DSP_VALUEHL 
c4c9 cd 9d 9e			call macro_dsp_valuehl 
c4cc				endm 
# End of macro FORTH_DSP_VALUEHL
c4cc			 
c4cc e5					push hl     ; start char 
c4cd			 
c4cd					FORTH_DSP_POP 
c4cd cd 55 9f			call macro_forth_dsp_pop 
c4d0				endm 
# End of macro FORTH_DSP_POP
c4d0			 
c4d0			 
c4d0					FORTH_DSP_VALUE 
c4d0 cd 86 9e			call macro_forth_dsp_value 
c4d3				endm 
# End of macro FORTH_DSP_VALUE
c4d3			 
c4d3 d1					pop de    ; get start post offset 
c4d4			 
c4d4 19					add hl, de    ; starting offset 
c4d5			 
c4d5 c1					pop bc 
c4d6 c5					push bc      ; grab size of string 
c4d7			 
c4d7 e5					push hl    ; save string start  
c4d8			 
c4d8 26 00				ld h, 0 
c4da 69					ld l, c 
c4db 23					inc hl 
c4dc 23					inc hl 
c4dd			 
c4dd cd 0d 93				call malloc 
c4e0				if DEBUG_FORTH_MALLOC_GUARD 
c4e0 cc 13 ce				call z,malloc_error 
c4e3				endif 
c4e3			 
c4e3 eb					ex de, hl      ; save malloc area for string copy 
c4e4 e1					pop hl    ; get back source 
c4e5 c1					pop bc    ; get length of string back 
c4e6			 
c4e6 d5					push de    ; save malloc area for after we push 
c4e7 ed b0				ldir     ; copy substr 
c4e9			 
c4e9			 
c4e9 eb					ex de, hl 
c4ea 3e 00				ld a, 0 
c4ec 77					ld (hl), a   ; term substr 
c4ed			 
c4ed					 
c4ed e1					pop hl    ; get malloc so we can push it 
c4ee e5					push hl   ; save so we can free it afterwards 
c4ef			 
c4ef cd 14 9d				call forth_push_str 
c4f2			 
c4f2 e1					pop hl 
c4f3 cd d7 93				call free 
c4f6			 
c4f6					 
c4f6					 
c4f6			 
c4f6			 
c4f6					NEXTW 
c4f6 c3 53 a0			jp macro_next 
c4f9				endm 
# End of macro NEXTW
c4f9			 
c4f9			.LEFT: 
c4f9				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
c4f9 48				db WORD_SYS_CORE+52             
c4fa 21 c5			dw .RIGHT            
c4fc 05				db 4 + 1 
c4fd .. 00			db "LEFT",0              
c502				endm 
# End of macro CWHEAD
c502			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
c502					if DEBUG_FORTH_WORDS_KEY 
c502						DMARK "LEF" 
c502 f5				push af  
c503 3a 17 c5			ld a, (.dmark)  
c506 32 6b ee			ld (debug_mark),a  
c509 3a 18 c5			ld a, (.dmark+1)  
c50c 32 6c ee			ld (debug_mark+1),a  
c50f 3a 19 c5			ld a, (.dmark+2)  
c512 32 6d ee			ld (debug_mark+2),a  
c515 18 03			jr .pastdmark  
c517 ..			.dmark: db "LEF"  
c51a f1			.pastdmark: pop af  
c51b			endm  
# End of macro DMARK
c51b						CALLMONITOR 
c51b cd 6f ee			call debug_vector  
c51e				endm  
# End of macro CALLMONITOR
c51e					endif 
c51e			 
c51e					NEXTW 
c51e c3 53 a0			jp macro_next 
c521				endm 
# End of macro NEXTW
c521			.RIGHT: 
c521				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
c521 48				db WORD_SYS_CORE+52             
c522 4a c5			dw .STR2NUM            
c524 06				db 5 + 1 
c525 .. 00			db "RIGHT",0              
c52b				endm 
# End of macro CWHEAD
c52b			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
c52b					if DEBUG_FORTH_WORDS_KEY 
c52b						DMARK "RIG" 
c52b f5				push af  
c52c 3a 40 c5			ld a, (.dmark)  
c52f 32 6b ee			ld (debug_mark),a  
c532 3a 41 c5			ld a, (.dmark+1)  
c535 32 6c ee			ld (debug_mark+1),a  
c538 3a 42 c5			ld a, (.dmark+2)  
c53b 32 6d ee			ld (debug_mark+2),a  
c53e 18 03			jr .pastdmark  
c540 ..			.dmark: db "RIG"  
c543 f1			.pastdmark: pop af  
c544			endm  
# End of macro DMARK
c544						CALLMONITOR 
c544 cd 6f ee			call debug_vector  
c547				endm  
# End of macro CALLMONITOR
c547					endif 
c547			 
c547					NEXTW 
c547 c3 53 a0			jp macro_next 
c54a				endm 
# End of macro NEXTW
c54a			 
c54a			 
c54a			.STR2NUM: 
c54a				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
c54a 48				db WORD_SYS_CORE+52             
c54b d6 c5			dw .NUM2STR            
c54d 08				db 7 + 1 
c54e .. 00			db "STR2NUM",0              
c556				endm 
# End of macro CWHEAD
c556			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
c556			 
c556			 
c556			; TODO STR type check to do 
c556					if DEBUG_FORTH_WORDS_KEY 
c556						DMARK "S2N" 
c556 f5				push af  
c557 3a 6b c5			ld a, (.dmark)  
c55a 32 6b ee			ld (debug_mark),a  
c55d 3a 6c c5			ld a, (.dmark+1)  
c560 32 6c ee			ld (debug_mark+1),a  
c563 3a 6d c5			ld a, (.dmark+2)  
c566 32 6d ee			ld (debug_mark+2),a  
c569 18 03			jr .pastdmark  
c56b ..			.dmark: db "S2N"  
c56e f1			.pastdmark: pop af  
c56f			endm  
# End of macro DMARK
c56f						CALLMONITOR 
c56f cd 6f ee			call debug_vector  
c572				endm  
# End of macro CALLMONITOR
c572					endif 
c572			 
c572					;FORTH_DSP 
c572					FORTH_DSP_VALUE 
c572 cd 86 9e			call macro_forth_dsp_value 
c575				endm 
# End of macro FORTH_DSP_VALUE
c575					;inc hl 
c575			 
c575 eb					ex de, hl 
c576					if DEBUG_FORTH_WORDS 
c576						DMARK "S2a" 
c576 f5				push af  
c577 3a 8b c5			ld a, (.dmark)  
c57a 32 6b ee			ld (debug_mark),a  
c57d 3a 8c c5			ld a, (.dmark+1)  
c580 32 6c ee			ld (debug_mark+1),a  
c583 3a 8d c5			ld a, (.dmark+2)  
c586 32 6d ee			ld (debug_mark+2),a  
c589 18 03			jr .pastdmark  
c58b ..			.dmark: db "S2a"  
c58e f1			.pastdmark: pop af  
c58f			endm  
# End of macro DMARK
c58f						CALLMONITOR 
c58f cd 6f ee			call debug_vector  
c592				endm  
# End of macro CALLMONITOR
c592					endif 
c592 cd 2f 92				call string_to_uint16 
c595			 
c595					if DEBUG_FORTH_WORDS 
c595						DMARK "S2b" 
c595 f5				push af  
c596 3a aa c5			ld a, (.dmark)  
c599 32 6b ee			ld (debug_mark),a  
c59c 3a ab c5			ld a, (.dmark+1)  
c59f 32 6c ee			ld (debug_mark+1),a  
c5a2 3a ac c5			ld a, (.dmark+2)  
c5a5 32 6d ee			ld (debug_mark+2),a  
c5a8 18 03			jr .pastdmark  
c5aa ..			.dmark: db "S2b"  
c5ad f1			.pastdmark: pop af  
c5ae			endm  
# End of macro DMARK
c5ae						CALLMONITOR 
c5ae cd 6f ee			call debug_vector  
c5b1				endm  
# End of macro CALLMONITOR
c5b1					endif 
c5b1			;		push hl 
c5b1					FORTH_DSP_POP 
c5b1 cd 55 9f			call macro_forth_dsp_pop 
c5b4				endm 
# End of macro FORTH_DSP_POP
c5b4			;		pop hl 
c5b4					 
c5b4					if DEBUG_FORTH_WORDS 
c5b4						DMARK "S2b" 
c5b4 f5				push af  
c5b5 3a c9 c5			ld a, (.dmark)  
c5b8 32 6b ee			ld (debug_mark),a  
c5bb 3a ca c5			ld a, (.dmark+1)  
c5be 32 6c ee			ld (debug_mark+1),a  
c5c1 3a cb c5			ld a, (.dmark+2)  
c5c4 32 6d ee			ld (debug_mark+2),a  
c5c7 18 03			jr .pastdmark  
c5c9 ..			.dmark: db "S2b"  
c5cc f1			.pastdmark: pop af  
c5cd			endm  
# End of macro DMARK
c5cd						CALLMONITOR 
c5cd cd 6f ee			call debug_vector  
c5d0				endm  
# End of macro CALLMONITOR
c5d0					endif 
c5d0 cd a6 9c				call forth_push_numhl	 
c5d3			 
c5d3				 
c5d3				       NEXTW 
c5d3 c3 53 a0			jp macro_next 
c5d6				endm 
# End of macro NEXTW
c5d6			.NUM2STR: 
c5d6				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
c5d6 48				db WORD_SYS_CORE+52             
c5d7 e5 c5			dw .CONCAT            
c5d9 08				db 7 + 1 
c5da .. 00			db "NUM2STR",0              
c5e2				endm 
# End of macro CWHEAD
c5e2			; | NUM2STR ( n -- s ) Convert a number on TOS to string | TODO 
c5e2			 
c5e2			;		; malloc a string to target 
c5e2			;		ld hl, 10     ; TODO max string size should be fine 
c5e2			;		call malloc 
c5e2			;		push hl    ; save malloc location 
c5e2			; 
c5e2			; 
c5e2			;; TODO check int type 
c5e2			;		FORTH_DSP_VALUEHL 
c5e2			;		ld a, l 
c5e2			;		call DispAToASCII   
c5e2			;;TODO need to chage above call to dump into string 
c5e2			; 
c5e2			; 
c5e2			 
c5e2				       NEXTW 
c5e2 c3 53 a0			jp macro_next 
c5e5				endm 
# End of macro NEXTW
c5e5			 
c5e5			.CONCAT: 
c5e5				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
c5e5 48				db WORD_SYS_CORE+52             
c5e6 98 c6			dw .FIND            
c5e8 07				db 6 + 1 
c5e9 .. 00			db "CONCAT",0              
c5f0				endm 
# End of macro CWHEAD
c5f0			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
c5f0			 
c5f0			; TODO check string type 
c5f0			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
c5f0			 
c5f0					if DEBUG_FORTH_WORDS_KEY 
c5f0						DMARK "CON" 
c5f0 f5				push af  
c5f1 3a 05 c6			ld a, (.dmark)  
c5f4 32 6b ee			ld (debug_mark),a  
c5f7 3a 06 c6			ld a, (.dmark+1)  
c5fa 32 6c ee			ld (debug_mark+1),a  
c5fd 3a 07 c6			ld a, (.dmark+2)  
c600 32 6d ee			ld (debug_mark+2),a  
c603 18 03			jr .pastdmark  
c605 ..			.dmark: db "CON"  
c608 f1			.pastdmark: pop af  
c609			endm  
# End of macro DMARK
c609						CALLMONITOR 
c609 cd 6f ee			call debug_vector  
c60c				endm  
# End of macro CALLMONITOR
c60c					endif 
c60c			 
c60c			 
c60c					FORTH_DSP_VALUE 
c60c cd 86 9e			call macro_forth_dsp_value 
c60f				endm 
# End of macro FORTH_DSP_VALUE
c60f e5					push hl   ; s2 
c610			 
c610					FORTH_DSP_POP 
c610 cd 55 9f			call macro_forth_dsp_pop 
c613				endm 
# End of macro FORTH_DSP_POP
c613			 
c613					FORTH_DSP_VALUE 
c613 cd 86 9e			call macro_forth_dsp_value 
c616				endm 
# End of macro FORTH_DSP_VALUE
c616			 
c616 e5					push hl   ; s1 
c617			 
c617					FORTH_DSP_POP 
c617 cd 55 9f			call macro_forth_dsp_pop 
c61a				endm 
# End of macro FORTH_DSP_POP
c61a					 
c61a			 
c61a					; copy s1 
c61a			 
c61a				 
c61a					; save ptr 
c61a e1					pop hl  
c61b e5					push hl 
c61c 3e 00				ld a, 0 
c61e cd a3 92				call strlent 
c621					;inc hl    ; zer0 
c621 06 00				ld b, 0 
c623 4d					ld c, l 
c624 e1					pop hl		 
c625 11 c1 e2				ld de, scratch	 
c628					if DEBUG_FORTH_WORDS 
c628						DMARK "CO1" 
c628 f5				push af  
c629 3a 3d c6			ld a, (.dmark)  
c62c 32 6b ee			ld (debug_mark),a  
c62f 3a 3e c6			ld a, (.dmark+1)  
c632 32 6c ee			ld (debug_mark+1),a  
c635 3a 3f c6			ld a, (.dmark+2)  
c638 32 6d ee			ld (debug_mark+2),a  
c63b 18 03			jr .pastdmark  
c63d ..			.dmark: db "CO1"  
c640 f1			.pastdmark: pop af  
c641			endm  
# End of macro DMARK
c641						CALLMONITOR 
c641 cd 6f ee			call debug_vector  
c644				endm  
# End of macro CALLMONITOR
c644					endif 
c644 ed b0				ldir 
c646			 
c646 e1					pop hl 
c647 e5					push hl 
c648 d5					push de 
c649			 
c649			 
c649 3e 00				ld a, 0 
c64b cd a3 92				call strlent 
c64e 23					inc hl    ; zer0 
c64f 23					inc hl 
c650 06 00				ld b, 0 
c652 4d					ld c, l 
c653 d1					pop de 
c654 e1					pop hl		 
c655					if DEBUG_FORTH_WORDS 
c655						DMARK "CO2" 
c655 f5				push af  
c656 3a 6a c6			ld a, (.dmark)  
c659 32 6b ee			ld (debug_mark),a  
c65c 3a 6b c6			ld a, (.dmark+1)  
c65f 32 6c ee			ld (debug_mark+1),a  
c662 3a 6c c6			ld a, (.dmark+2)  
c665 32 6d ee			ld (debug_mark+2),a  
c668 18 03			jr .pastdmark  
c66a ..			.dmark: db "CO2"  
c66d f1			.pastdmark: pop af  
c66e			endm  
# End of macro DMARK
c66e						CALLMONITOR 
c66e cd 6f ee			call debug_vector  
c671				endm  
# End of macro CALLMONITOR
c671					endif 
c671 ed b0				ldir 
c673			 
c673			 
c673			 
c673 21 c1 e2				ld hl, scratch 
c676					if DEBUG_FORTH_WORDS 
c676						DMARK "CO5" 
c676 f5				push af  
c677 3a 8b c6			ld a, (.dmark)  
c67a 32 6b ee			ld (debug_mark),a  
c67d 3a 8c c6			ld a, (.dmark+1)  
c680 32 6c ee			ld (debug_mark+1),a  
c683 3a 8d c6			ld a, (.dmark+2)  
c686 32 6d ee			ld (debug_mark+2),a  
c689 18 03			jr .pastdmark  
c68b ..			.dmark: db "CO5"  
c68e f1			.pastdmark: pop af  
c68f			endm  
# End of macro DMARK
c68f						CALLMONITOR 
c68f cd 6f ee			call debug_vector  
c692				endm  
# End of macro CALLMONITOR
c692					endif 
c692			 
c692 cd 14 9d				call forth_push_str 
c695			 
c695			 
c695			 
c695			 
c695				       NEXTW 
c695 c3 53 a0			jp macro_next 
c698				endm 
# End of macro NEXTW
c698			 
c698			 
c698			.FIND: 
c698				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
c698 4b				db WORD_SYS_CORE+55             
c699 56 c7			dw .LEN            
c69b 05				db 4 + 1 
c69c .. 00			db "FIND",0              
c6a1				endm 
# End of macro CWHEAD
c6a1			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
c6a1			 
c6a1					if DEBUG_FORTH_WORDS_KEY 
c6a1						DMARK "FND" 
c6a1 f5				push af  
c6a2 3a b6 c6			ld a, (.dmark)  
c6a5 32 6b ee			ld (debug_mark),a  
c6a8 3a b7 c6			ld a, (.dmark+1)  
c6ab 32 6c ee			ld (debug_mark+1),a  
c6ae 3a b8 c6			ld a, (.dmark+2)  
c6b1 32 6d ee			ld (debug_mark+2),a  
c6b4 18 03			jr .pastdmark  
c6b6 ..			.dmark: db "FND"  
c6b9 f1			.pastdmark: pop af  
c6ba			endm  
# End of macro DMARK
c6ba						CALLMONITOR 
c6ba cd 6f ee			call debug_vector  
c6bd				endm  
# End of macro CALLMONITOR
c6bd					endif 
c6bd			 
c6bd			; TODO check string type 
c6bd					FORTH_DSP_VALUE 
c6bd cd 86 9e			call macro_forth_dsp_value 
c6c0				endm 
# End of macro FORTH_DSP_VALUE
c6c0			 
c6c0 e5					push hl    
c6c1 7e					ld a,(hl)    ; char to find   
c6c2			; TODO change char to substr 
c6c2			 
c6c2 f5					push af 
c6c3					 
c6c3			 
c6c3			 
c6c3					if DEBUG_FORTH_WORDS 
c6c3						DMARK "FN1" 
c6c3 f5				push af  
c6c4 3a d8 c6			ld a, (.dmark)  
c6c7 32 6b ee			ld (debug_mark),a  
c6ca 3a d9 c6			ld a, (.dmark+1)  
c6cd 32 6c ee			ld (debug_mark+1),a  
c6d0 3a da c6			ld a, (.dmark+2)  
c6d3 32 6d ee			ld (debug_mark+2),a  
c6d6 18 03			jr .pastdmark  
c6d8 ..			.dmark: db "FN1"  
c6db f1			.pastdmark: pop af  
c6dc			endm  
# End of macro DMARK
c6dc						CALLMONITOR 
c6dc cd 6f ee			call debug_vector  
c6df				endm  
# End of macro CALLMONITOR
c6df					endif 
c6df			 
c6df					FORTH_DSP_POP 
c6df cd 55 9f			call macro_forth_dsp_pop 
c6e2				endm 
# End of macro FORTH_DSP_POP
c6e2			 
c6e2					; string to search 
c6e2			 
c6e2					FORTH_DSP_VALUE 
c6e2 cd 86 9e			call macro_forth_dsp_value 
c6e5				endm 
# End of macro FORTH_DSP_VALUE
c6e5			 
c6e5 d1					pop de  ; d is char to find  
c6e6			 
c6e6					if DEBUG_FORTH_WORDS 
c6e6						DMARK "FN2" 
c6e6 f5				push af  
c6e7 3a fb c6			ld a, (.dmark)  
c6ea 32 6b ee			ld (debug_mark),a  
c6ed 3a fc c6			ld a, (.dmark+1)  
c6f0 32 6c ee			ld (debug_mark+1),a  
c6f3 3a fd c6			ld a, (.dmark+2)  
c6f6 32 6d ee			ld (debug_mark+2),a  
c6f9 18 03			jr .pastdmark  
c6fb ..			.dmark: db "FN2"  
c6fe f1			.pastdmark: pop af  
c6ff			endm  
# End of macro DMARK
c6ff						CALLMONITOR 
c6ff cd 6f ee			call debug_vector  
c702				endm  
# End of macro CALLMONITOR
c702					endif 
c702					 
c702 01 00 00				ld bc, 0 
c705 7e			.findchar:      ld a,(hl) 
c706 fe 00				cp 0   		 
c708 28 27				jr z, .finddone     
c70a ba					cp d 
c70b 28 20				jr z, .foundchar 
c70d 03					inc bc 
c70e 23					inc hl 
c70f					if DEBUG_FORTH_WORDS 
c70f						DMARK "FN3" 
c70f f5				push af  
c710 3a 24 c7			ld a, (.dmark)  
c713 32 6b ee			ld (debug_mark),a  
c716 3a 25 c7			ld a, (.dmark+1)  
c719 32 6c ee			ld (debug_mark+1),a  
c71c 3a 26 c7			ld a, (.dmark+2)  
c71f 32 6d ee			ld (debug_mark+2),a  
c722 18 03			jr .pastdmark  
c724 ..			.dmark: db "FN3"  
c727 f1			.pastdmark: pop af  
c728			endm  
# End of macro DMARK
c728						CALLMONITOR 
c728 cd 6f ee			call debug_vector  
c72b				endm  
# End of macro CALLMONITOR
c72b					endif 
c72b 18 d8				jr .findchar 
c72d			 
c72d			 
c72d c5			.foundchar:	push bc 
c72e e1					pop hl 
c72f 18 03				jr .findexit 
c731			 
c731			 
c731							 
c731			 
c731			.finddone:     ; got to end of string with no find 
c731 21 00 00				ld hl, 0 
c734			.findexit: 
c734			 
c734					if DEBUG_FORTH_WORDS 
c734						DMARK "FNd" 
c734 f5				push af  
c735 3a 49 c7			ld a, (.dmark)  
c738 32 6b ee			ld (debug_mark),a  
c73b 3a 4a c7			ld a, (.dmark+1)  
c73e 32 6c ee			ld (debug_mark+1),a  
c741 3a 4b c7			ld a, (.dmark+2)  
c744 32 6d ee			ld (debug_mark+2),a  
c747 18 03			jr .pastdmark  
c749 ..			.dmark: db "FNd"  
c74c f1			.pastdmark: pop af  
c74d			endm  
# End of macro DMARK
c74d						CALLMONITOR 
c74d cd 6f ee			call debug_vector  
c750				endm  
# End of macro CALLMONITOR
c750					endif 
c750 cd a6 9c			call forth_push_numhl 
c753			 
c753				       NEXTW 
c753 c3 53 a0			jp macro_next 
c756				endm 
# End of macro NEXTW
c756			 
c756			.LEN: 
c756				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
c756 4c				db WORD_SYS_CORE+56             
c757 c0 c7			dw .ASC            
c759 06				db 5 + 1 
c75a .. 00			db "COUNT",0              
c760				endm 
# End of macro CWHEAD
c760			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
c760			 
c760					if DEBUG_FORTH_WORDS_KEY 
c760						DMARK "CNT" 
c760 f5				push af  
c761 3a 75 c7			ld a, (.dmark)  
c764 32 6b ee			ld (debug_mark),a  
c767 3a 76 c7			ld a, (.dmark+1)  
c76a 32 6c ee			ld (debug_mark+1),a  
c76d 3a 77 c7			ld a, (.dmark+2)  
c770 32 6d ee			ld (debug_mark+2),a  
c773 18 03			jr .pastdmark  
c775 ..			.dmark: db "CNT"  
c778 f1			.pastdmark: pop af  
c779			endm  
# End of macro DMARK
c779						CALLMONITOR 
c779 cd 6f ee			call debug_vector  
c77c				endm  
# End of macro CALLMONITOR
c77c					endif 
c77c			; TODO check string type 
c77c					FORTH_DSP_VALUE 
c77c cd 86 9e			call macro_forth_dsp_value 
c77f				endm 
# End of macro FORTH_DSP_VALUE
c77f			 
c77f			 
c77f					if DEBUG_FORTH_WORDS 
c77f						DMARK "CN?" 
c77f f5				push af  
c780 3a 94 c7			ld a, (.dmark)  
c783 32 6b ee			ld (debug_mark),a  
c786 3a 95 c7			ld a, (.dmark+1)  
c789 32 6c ee			ld (debug_mark+1),a  
c78c 3a 96 c7			ld a, (.dmark+2)  
c78f 32 6d ee			ld (debug_mark+2),a  
c792 18 03			jr .pastdmark  
c794 ..			.dmark: db "CN?"  
c797 f1			.pastdmark: pop af  
c798			endm  
# End of macro DMARK
c798						CALLMONITOR 
c798 cd 6f ee			call debug_vector  
c79b				endm  
# End of macro CALLMONITOR
c79b					endif 
c79b cd 98 92				call strlenz 
c79e					if DEBUG_FORTH_WORDS 
c79e						DMARK "CNl" 
c79e f5				push af  
c79f 3a b3 c7			ld a, (.dmark)  
c7a2 32 6b ee			ld (debug_mark),a  
c7a5 3a b4 c7			ld a, (.dmark+1)  
c7a8 32 6c ee			ld (debug_mark+1),a  
c7ab 3a b5 c7			ld a, (.dmark+2)  
c7ae 32 6d ee			ld (debug_mark+2),a  
c7b1 18 03			jr .pastdmark  
c7b3 ..			.dmark: db "CNl"  
c7b6 f1			.pastdmark: pop af  
c7b7			endm  
# End of macro DMARK
c7b7						CALLMONITOR 
c7b7 cd 6f ee			call debug_vector  
c7ba				endm  
# End of macro CALLMONITOR
c7ba					endif 
c7ba			 
c7ba cd a6 9c				call forth_push_numhl 
c7bd			 
c7bd			 
c7bd			 
c7bd				       NEXTW 
c7bd c3 53 a0			jp macro_next 
c7c0				endm 
# End of macro NEXTW
c7c0			.ASC: 
c7c0				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
c7c0 4d				db WORD_SYS_CORE+57             
c7c1 2e c8			dw .CHR            
c7c3 04				db 3 + 1 
c7c4 .. 00			db "ASC",0              
c7c8				endm 
# End of macro CWHEAD
c7c8			; | ASC ( u -- n ) Get the ASCII value of the first character of the string on TOS | DONE 
c7c8					if DEBUG_FORTH_WORDS_KEY 
c7c8						DMARK "ASC" 
c7c8 f5				push af  
c7c9 3a dd c7			ld a, (.dmark)  
c7cc 32 6b ee			ld (debug_mark),a  
c7cf 3a de c7			ld a, (.dmark+1)  
c7d2 32 6c ee			ld (debug_mark+1),a  
c7d5 3a df c7			ld a, (.dmark+2)  
c7d8 32 6d ee			ld (debug_mark+2),a  
c7db 18 03			jr .pastdmark  
c7dd ..			.dmark: db "ASC"  
c7e0 f1			.pastdmark: pop af  
c7e1			endm  
# End of macro DMARK
c7e1						CALLMONITOR 
c7e1 cd 6f ee			call debug_vector  
c7e4				endm  
# End of macro CALLMONITOR
c7e4					endif 
c7e4					FORTH_DSP_VALUE 
c7e4 cd 86 9e			call macro_forth_dsp_value 
c7e7				endm 
# End of macro FORTH_DSP_VALUE
c7e7					;v5 FORTH_DSP_VALUE 
c7e7			;		inc hl      ; now at start of numeric as string 
c7e7			 
c7e7 e5					push hl 
c7e8			 
c7e8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c7e8 cd 55 9f			call macro_forth_dsp_pop 
c7eb				endm 
# End of macro FORTH_DSP_POP
c7eb			 
c7eb e1					pop hl 
c7ec			 
c7ec					if DEBUG_FORTH_WORDS 
c7ec						DMARK "AS1" 
c7ec f5				push af  
c7ed 3a 01 c8			ld a, (.dmark)  
c7f0 32 6b ee			ld (debug_mark),a  
c7f3 3a 02 c8			ld a, (.dmark+1)  
c7f6 32 6c ee			ld (debug_mark+1),a  
c7f9 3a 03 c8			ld a, (.dmark+2)  
c7fc 32 6d ee			ld (debug_mark+2),a  
c7ff 18 03			jr .pastdmark  
c801 ..			.dmark: db "AS1"  
c804 f1			.pastdmark: pop af  
c805			endm  
# End of macro DMARK
c805						CALLMONITOR 
c805 cd 6f ee			call debug_vector  
c808				endm  
# End of macro CALLMONITOR
c808					endif 
c808					; push the content of a onto the stack as a value 
c808			 
c808 7e					ld a,(hl)   ; get char 
c809 26 00				ld h,0 
c80b 6f					ld l,a 
c80c					if DEBUG_FORTH_WORDS 
c80c						DMARK "AS2" 
c80c f5				push af  
c80d 3a 21 c8			ld a, (.dmark)  
c810 32 6b ee			ld (debug_mark),a  
c813 3a 22 c8			ld a, (.dmark+1)  
c816 32 6c ee			ld (debug_mark+1),a  
c819 3a 23 c8			ld a, (.dmark+2)  
c81c 32 6d ee			ld (debug_mark+2),a  
c81f 18 03			jr .pastdmark  
c821 ..			.dmark: db "AS2"  
c824 f1			.pastdmark: pop af  
c825			endm  
# End of macro DMARK
c825						CALLMONITOR 
c825 cd 6f ee			call debug_vector  
c828				endm  
# End of macro CALLMONITOR
c828					endif 
c828 cd a6 9c				call forth_push_numhl 
c82b			 
c82b				       NEXTW 
c82b c3 53 a0			jp macro_next 
c82e				endm 
# End of macro NEXTW
c82e			 
c82e			.CHR: 
c82e				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
c82e 4d				db WORD_SYS_CORE+57             
c82f 6a c8			dw .ENDSTR            
c831 04				db 3 + 1 
c832 .. 00			db "CHR",0              
c836				endm 
# End of macro CWHEAD
c836			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
c836					if DEBUG_FORTH_WORDS_KEY 
c836						DMARK "CHR" 
c836 f5				push af  
c837 3a 4b c8			ld a, (.dmark)  
c83a 32 6b ee			ld (debug_mark),a  
c83d 3a 4c c8			ld a, (.dmark+1)  
c840 32 6c ee			ld (debug_mark+1),a  
c843 3a 4d c8			ld a, (.dmark+2)  
c846 32 6d ee			ld (debug_mark+2),a  
c849 18 03			jr .pastdmark  
c84b ..			.dmark: db "CHR"  
c84e f1			.pastdmark: pop af  
c84f			endm  
# End of macro DMARK
c84f						CALLMONITOR 
c84f cd 6f ee			call debug_vector  
c852				endm  
# End of macro CALLMONITOR
c852					endif 
c852					FORTH_DSP_VALUEHL 
c852 cd 9d 9e			call macro_dsp_valuehl 
c855				endm 
# End of macro FORTH_DSP_VALUEHL
c855			 
c855					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c855 cd 55 9f			call macro_forth_dsp_pop 
c858				endm 
# End of macro FORTH_DSP_POP
c858			 
c858					; save asci byte as a zero term string and push string 
c858			 
c858 7d					ld a,l 
c859 32 c1 e2				ld (scratch), a 
c85c			 
c85c 3e 00				ld a, 0 
c85e 32 c2 e2				ld (scratch+1), a 
c861			 
c861 21 c1 e2				ld hl, scratch 
c864 cd 14 9d				call forth_push_str 
c867			 
c867			 
c867				       NEXTW 
c867 c3 53 a0			jp macro_next 
c86a				endm 
# End of macro NEXTW
c86a			 
c86a			 
c86a			 
c86a			 
c86a			.ENDSTR: 
c86a			; eof 
c86a			 
# End of file forth_words_str.asm
c86a			include "forth_words_key.asm" 
c86a			 
c86a			; | ## Keyboard Words 
c86a			 
c86a			.KEY: 
c86a				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
c86a 3e				db WORD_SYS_CORE+42             
c86b 9a c8			dw .WAITK            
c86d 04				db 3 + 1 
c86e .. 00			db "KEY",0              
c872				endm 
# End of macro CWHEAD
c872			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
c872			 
c872					if DEBUG_FORTH_WORDS_KEY 
c872						DMARK "KEY" 
c872 f5				push af  
c873 3a 87 c8			ld a, (.dmark)  
c876 32 6b ee			ld (debug_mark),a  
c879 3a 88 c8			ld a, (.dmark+1)  
c87c 32 6c ee			ld (debug_mark+1),a  
c87f 3a 89 c8			ld a, (.dmark+2)  
c882 32 6d ee			ld (debug_mark+2),a  
c885 18 03			jr .pastdmark  
c887 ..			.dmark: db "KEY"  
c88a f1			.pastdmark: pop af  
c88b			endm  
# End of macro DMARK
c88b						CALLMONITOR 
c88b cd 6f ee			call debug_vector  
c88e				endm  
# End of macro CALLMONITOR
c88e					endif 
c88e			; TODO currently waits 
c88e cd 34 e6				call cin 
c891					;call cin_wait 
c891 6f					ld l, a 
c892 26 00				ld h, 0 
c894 cd a6 9c				call forth_push_numhl 
c897					NEXTW 
c897 c3 53 a0			jp macro_next 
c89a				endm 
# End of macro NEXTW
c89a			.WAITK: 
c89a				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
c89a 3f				db WORD_SYS_CORE+43             
c89b cc c8			dw .ACCEPT            
c89d 06				db 5 + 1 
c89e .. 00			db "WAITK",0              
c8a4				endm 
# End of macro CWHEAD
c8a4			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
c8a4					if DEBUG_FORTH_WORDS_KEY 
c8a4						DMARK "WAI" 
c8a4 f5				push af  
c8a5 3a b9 c8			ld a, (.dmark)  
c8a8 32 6b ee			ld (debug_mark),a  
c8ab 3a ba c8			ld a, (.dmark+1)  
c8ae 32 6c ee			ld (debug_mark+1),a  
c8b1 3a bb c8			ld a, (.dmark+2)  
c8b4 32 6d ee			ld (debug_mark+2),a  
c8b7 18 03			jr .pastdmark  
c8b9 ..			.dmark: db "WAI"  
c8bc f1			.pastdmark: pop af  
c8bd			endm  
# End of macro DMARK
c8bd						CALLMONITOR 
c8bd cd 6f ee			call debug_vector  
c8c0				endm  
# End of macro CALLMONITOR
c8c0					endif 
c8c0 cd 2e e6				call cin_wait 
c8c3 6f					ld l, a 
c8c4 26 00				ld h, 0 
c8c6 cd a6 9c				call forth_push_numhl 
c8c9					NEXTW 
c8c9 c3 53 a0			jp macro_next 
c8cc				endm 
# End of macro NEXTW
c8cc			.ACCEPT: 
c8cc				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
c8cc 40				db WORD_SYS_CORE+44             
c8cd 2a c9			dw .EDIT            
c8cf 07				db 6 + 1 
c8d0 .. 00			db "ACCEPT",0              
c8d7				endm 
# End of macro CWHEAD
c8d7			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
c8d7					; TODO crashes on push 
c8d7					if DEBUG_FORTH_WORDS_KEY 
c8d7						DMARK "ACC" 
c8d7 f5				push af  
c8d8 3a ec c8			ld a, (.dmark)  
c8db 32 6b ee			ld (debug_mark),a  
c8de 3a ed c8			ld a, (.dmark+1)  
c8e1 32 6c ee			ld (debug_mark+1),a  
c8e4 3a ee c8			ld a, (.dmark+2)  
c8e7 32 6d ee			ld (debug_mark+2),a  
c8ea 18 03			jr .pastdmark  
c8ec ..			.dmark: db "ACC"  
c8ef f1			.pastdmark: pop af  
c8f0			endm  
# End of macro DMARK
c8f0						CALLMONITOR 
c8f0 cd 6f ee			call debug_vector  
c8f3				endm  
# End of macro CALLMONITOR
c8f3					endif 
c8f3 21 bf e4				ld hl, os_input 
c8f6 3e 00				ld a, 0 
c8f8 77					ld (hl),a 
c8f9 3a 5e ea				ld a,(f_cursor_ptr) 
c8fc 16 64				ld d, 100 
c8fe 0e 00				ld c, 0 
c900 1e 28				ld e, 40 
c902 cd 08 8d				call input_str 
c905					; TODO perhaps do a type check and wrap in quotes if not a number 
c905 21 bf e4				ld hl, os_input 
c908					if DEBUG_FORTH_WORDS 
c908						DMARK "AC1" 
c908 f5				push af  
c909 3a 1d c9			ld a, (.dmark)  
c90c 32 6b ee			ld (debug_mark),a  
c90f 3a 1e c9			ld a, (.dmark+1)  
c912 32 6c ee			ld (debug_mark+1),a  
c915 3a 1f c9			ld a, (.dmark+2)  
c918 32 6d ee			ld (debug_mark+2),a  
c91b 18 03			jr .pastdmark  
c91d ..			.dmark: db "AC1"  
c920 f1			.pastdmark: pop af  
c921			endm  
# End of macro DMARK
c921						CALLMONITOR 
c921 cd 6f ee			call debug_vector  
c924				endm  
# End of macro CALLMONITOR
c924					endif 
c924 cd 14 9d				call forth_push_str 
c927					NEXTW 
c927 c3 53 a0			jp macro_next 
c92a				endm 
# End of macro NEXTW
c92a			 
c92a			.EDIT: 
c92a				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
c92a 40				db WORD_SYS_CORE+44             
c92b cc c9			dw .DEDIT            
c92d 05				db 4 + 1 
c92e .. 00			db "EDIT",0              
c933				endm 
# End of macro CWHEAD
c933			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
c933			 
c933					; TODO does not copy from stack 
c933					if DEBUG_FORTH_WORDS_KEY 
c933						DMARK "EDT" 
c933 f5				push af  
c934 3a 48 c9			ld a, (.dmark)  
c937 32 6b ee			ld (debug_mark),a  
c93a 3a 49 c9			ld a, (.dmark+1)  
c93d 32 6c ee			ld (debug_mark+1),a  
c940 3a 4a c9			ld a, (.dmark+2)  
c943 32 6d ee			ld (debug_mark+2),a  
c946 18 03			jr .pastdmark  
c948 ..			.dmark: db "EDT"  
c94b f1			.pastdmark: pop af  
c94c			endm  
# End of macro DMARK
c94c						CALLMONITOR 
c94c cd 6f ee			call debug_vector  
c94f				endm  
# End of macro CALLMONITOR
c94f					endif 
c94f			 
c94f					;FORTH_DSP 
c94f					FORTH_DSP_VALUEHL 
c94f cd 9d 9e			call macro_dsp_valuehl 
c952				endm 
# End of macro FORTH_DSP_VALUEHL
c952			;		inc hl    ; TODO do type check 
c952			 
c952			;		call get_word_hl 
c952 e5					push hl 
c953					if DEBUG_FORTH_WORDS 
c953						DMARK "EDp" 
c953 f5				push af  
c954 3a 68 c9			ld a, (.dmark)  
c957 32 6b ee			ld (debug_mark),a  
c95a 3a 69 c9			ld a, (.dmark+1)  
c95d 32 6c ee			ld (debug_mark+1),a  
c960 3a 6a c9			ld a, (.dmark+2)  
c963 32 6d ee			ld (debug_mark+2),a  
c966 18 03			jr .pastdmark  
c968 ..			.dmark: db "EDp"  
c96b f1			.pastdmark: pop af  
c96c			endm  
# End of macro DMARK
c96c						CALLMONITOR 
c96c cd 6f ee			call debug_vector  
c96f				endm  
# End of macro CALLMONITOR
c96f					endif 
c96f				;	ld a, 0 
c96f cd 98 92				call strlenz 
c972 23					inc hl 
c973			 
c973 06 00				ld b, 0 
c975 4d					ld c, l 
c976			 
c976 e1					pop hl 
c977 11 bf e4				ld de, os_input 
c97a					if DEBUG_FORTH_WORDS_KEY 
c97a						DMARK "EDc" 
c97a f5				push af  
c97b 3a 8f c9			ld a, (.dmark)  
c97e 32 6b ee			ld (debug_mark),a  
c981 3a 90 c9			ld a, (.dmark+1)  
c984 32 6c ee			ld (debug_mark+1),a  
c987 3a 91 c9			ld a, (.dmark+2)  
c98a 32 6d ee			ld (debug_mark+2),a  
c98d 18 03			jr .pastdmark  
c98f ..			.dmark: db "EDc"  
c992 f1			.pastdmark: pop af  
c993			endm  
# End of macro DMARK
c993						CALLMONITOR 
c993 cd 6f ee			call debug_vector  
c996				endm  
# End of macro CALLMONITOR
c996					endif 
c996 ed b0				ldir 
c998			 
c998			 
c998 21 bf e4				ld hl, os_input 
c99b					;ld a, 0 
c99b					;ld (hl),a 
c99b 3a 5e ea				ld a,(f_cursor_ptr) 
c99e 16 64				ld d, 100 
c9a0 0e 00				ld c, 0 
c9a2 1e 28				ld e, 40 
c9a4 cd 08 8d				call input_str 
c9a7					; TODO perhaps do a type check and wrap in quotes if not a number 
c9a7 21 bf e4				ld hl, os_input 
c9aa					if DEBUG_FORTH_WORDS 
c9aa						DMARK "ED1" 
c9aa f5				push af  
c9ab 3a bf c9			ld a, (.dmark)  
c9ae 32 6b ee			ld (debug_mark),a  
c9b1 3a c0 c9			ld a, (.dmark+1)  
c9b4 32 6c ee			ld (debug_mark+1),a  
c9b7 3a c1 c9			ld a, (.dmark+2)  
c9ba 32 6d ee			ld (debug_mark+2),a  
c9bd 18 03			jr .pastdmark  
c9bf ..			.dmark: db "ED1"  
c9c2 f1			.pastdmark: pop af  
c9c3			endm  
# End of macro DMARK
c9c3						CALLMONITOR 
c9c3 cd 6f ee			call debug_vector  
c9c6				endm  
# End of macro CALLMONITOR
c9c6					endif 
c9c6 cd 14 9d				call forth_push_str 
c9c9					NEXTW 
c9c9 c3 53 a0			jp macro_next 
c9cc				endm 
# End of macro NEXTW
c9cc			 
c9cc			.DEDIT: 
c9cc				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
c9cc 40				db WORD_SYS_CORE+44             
c9cd 2e ca			dw .ENDKEY            
c9cf 06				db 5 + 1 
c9d0 .. 00			db "DEDIT",0              
c9d6				endm 
# End of macro CWHEAD
c9d6			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
c9d6			 
c9d6					; TODO does not copy from stack 
c9d6					if DEBUG_FORTH_WORDS_KEY 
c9d6						DMARK "DED" 
c9d6 f5				push af  
c9d7 3a eb c9			ld a, (.dmark)  
c9da 32 6b ee			ld (debug_mark),a  
c9dd 3a ec c9			ld a, (.dmark+1)  
c9e0 32 6c ee			ld (debug_mark+1),a  
c9e3 3a ed c9			ld a, (.dmark+2)  
c9e6 32 6d ee			ld (debug_mark+2),a  
c9e9 18 03			jr .pastdmark  
c9eb ..			.dmark: db "DED"  
c9ee f1			.pastdmark: pop af  
c9ef			endm  
# End of macro DMARK
c9ef						CALLMONITOR 
c9ef cd 6f ee			call debug_vector  
c9f2				endm  
# End of macro CALLMONITOR
c9f2					endif 
c9f2			 
c9f2					;FORTH_DSP 
c9f2					FORTH_DSP_VALUEHL 
c9f2 cd 9d 9e			call macro_dsp_valuehl 
c9f5				endm 
# End of macro FORTH_DSP_VALUEHL
c9f5			;		inc hl    ; TODO do type check 
c9f5			 
c9f5			;		call get_word_hl 
c9f5 e5					push hl 
c9f6 e5					push hl 
c9f7					FORTH_DSP_POP 
c9f7 cd 55 9f			call macro_forth_dsp_pop 
c9fa				endm 
# End of macro FORTH_DSP_POP
c9fa e1					pop hl 
c9fb					if DEBUG_FORTH_WORDS 
c9fb						DMARK "EDp" 
c9fb f5				push af  
c9fc 3a 10 ca			ld a, (.dmark)  
c9ff 32 6b ee			ld (debug_mark),a  
ca02 3a 11 ca			ld a, (.dmark+1)  
ca05 32 6c ee			ld (debug_mark+1),a  
ca08 3a 12 ca			ld a, (.dmark+2)  
ca0b 32 6d ee			ld (debug_mark+2),a  
ca0e 18 03			jr .pastdmark  
ca10 ..			.dmark: db "EDp"  
ca13 f1			.pastdmark: pop af  
ca14			endm  
# End of macro DMARK
ca14						CALLMONITOR 
ca14 cd 6f ee			call debug_vector  
ca17				endm  
# End of macro CALLMONITOR
ca17					endif 
ca17				;	ld a, 0 
ca17 cd 98 92				call strlenz 
ca1a 23					inc hl 
ca1b			 
ca1b 06 00				ld b, 0 
ca1d 4d					ld c, l 
ca1e			 
ca1e e1					pop hl 
ca1f			 
ca1f					;ld a, 0 
ca1f					;ld (hl),a 
ca1f 3a 5e ea				ld a,(f_cursor_ptr) 
ca22 16 64				ld d, 100 
ca24 0e 00				ld c, 0 
ca26 1e 28				ld e, 40 
ca28 cd 08 8d				call input_str 
ca2b					; TODO perhaps do a type check and wrap in quotes if not a number 
ca2b					NEXTW 
ca2b c3 53 a0			jp macro_next 
ca2e				endm 
# End of macro NEXTW
ca2e			 
ca2e			 
ca2e			.ENDKEY: 
ca2e			; eof 
ca2e			 
# End of file forth_words_key.asm
ca2e			include "forth_words_const.asm" 
ca2e			 
ca2e			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
ca2e			 
ca2e			 
ca2e			.SPITIME: 
ca2e				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
ca2e 77				db WORD_SYS_CORE+99             
ca2f 43 ca			dw .VA            
ca31 08				db 7 + 1 
ca32 .. 00			db "SPITIME",0              
ca3a				endm 
# End of macro CWHEAD
ca3a			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack | DONE 
ca3a			; 
ca3a			; | | If using BANK devices then leave as is. 
ca3a			; | | Only really useful for the CARTDEV where other devices may be far too slow. In particular 
ca3a			; | | the multiplexing of the PicoSPINet addon which might not be running fast enough for all of the nodes 
ca3a			 
ca3a 21 64 ea				ld hl, spi_clktime  
ca3d cd a6 9c				call forth_push_numhl 
ca40			 
ca40					NEXTW 
ca40 c3 53 a0			jp macro_next 
ca43				endm 
# End of macro NEXTW
ca43			 
ca43			 
ca43			.VA: 
ca43				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
ca43 77				db WORD_SYS_CORE+99             
ca44 53 ca			dw .SYMBOL            
ca46 03				db 2 + 1 
ca47 .. 00			db "VA",0              
ca4a				endm 
# End of macro CWHEAD
ca4a			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 | DONE 
ca4a 21 28 ea				ld hl, cli_var_array 
ca4d cd a6 9c				call forth_push_numhl 
ca50			 
ca50					NEXTW 
ca50 c3 53 a0			jp macro_next 
ca53				endm 
# End of macro NEXTW
ca53			 
ca53			.SYMBOL: 
ca53				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
ca53 77				db WORD_SYS_CORE+99             
ca54 5d cb			dw .ENDCONST            
ca56 07				db 6 + 1 
ca57 .. 00			db "SYMBOL",0              
ca5e				endm 
# End of macro CWHEAD
ca5e			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
ca5e			; | 
ca5e			; | | The value is the number reference and the final address is pushed to stack 
ca5e			 
ca5e			; | | ``` 
ca5e			; | | dw sym_table 
ca5e			; | | dw nmi_vector 
ca5e			; | | dw cli_autodisplay 
ca5e			; | | dw cli_data_sp 
ca5e			; | | dw cli_data_stack 
ca5e			; | | dw cli_loop_sp 
ca5e			; | | dw cli_loop_stack 
ca5e			; | | dw cli_var_array 
ca5e			; | | dw cursor_col 
ca5e			; | | dw cursor_ptr 
ca5e			; | | ; 10 
ca5e			; | | dw cursor_row 
ca5e			; | | dw debug_mark 
ca5e			; | | dw display_fb0 
ca5e			; | | dw display_fb1 
ca5e			; | | dw display_fb2 
ca5e			; | | dw display_fb3 
ca5e			; | | dw display_fb_active 
ca5e			; | | dw execscratch 
ca5e			; | | dw f_cursor_ptr 
ca5e			; | | dw hardware_word 
ca5e			; | | ;20 
ca5e			; | | dw input_at_cursor 
ca5e			; | | dw input_at_pos 
ca5e			; | | dw input_cur_flash 
ca5e			; | | dw input_cur_onoff 
ca5e			; | | dw input_cursor 
ca5e			; | | dw input_display_size 
ca5e			; | | dw input_len 
ca5e			; | | dw input_ptr 
ca5e			; | | dw input_size 
ca5e			; | | dw input_start 
ca5e			; | | ; 30 
ca5e			; | | dw input_str 
ca5e			; | | dw input_under_cursor 
ca5e			; | | dw os_cli_cmd 
ca5e			; | | dw os_cur_ptr 
ca5e			; | | dw os_current_i 
ca5e			; | | dw os_input 
ca5e			; | | dw os_last_cmd 
ca5e			; | | dw os_last_new_uword 
ca5e			; | | dw debug_vector 
ca5e			; | | dw os_view_hl 
ca5e			; | | ;40 
ca5e			; | | dw os_word_scratch 
ca5e			; | | dw portbctl 
ca5e			; | | dw portbdata 
ca5e			; | | dw spi_cartdev 
ca5e			; | | dw spi_cartdev2 
ca5e			; | | dw spi_clktime 
ca5e			; | | dw spi_device 
ca5e			; | | dw spi_device_id 
ca5e			; | | dw spi_portbyte 
ca5e			; | | dw stackstore 
ca5e			; | | ; 50 
ca5e			; | | if STORAGE_SE 
ca5e			; | | dw storage_actl 
ca5e			; | | dw storage_adata 
ca5e			; | | else 
ca5e			; | | dw 0 
ca5e			; | | dw 0 
ca5e			; | | endif 
ca5e			; | | dw storage_append 
ca5e			; | | if STORAGE_SE 
ca5e			; | | dw storage_bctl 
ca5e			; | | else 
ca5e			; | | dw 0 
ca5e			; | | endif 
ca5e			; | | dw store_bank_active 
ca5e			; | | dw store_filecache 
ca5e			; | | dw store_longread 
ca5e			; | | dw store_openaddr 
ca5e			; | | dw store_openext 
ca5e			; | | dw store_openmaxext 
ca5e			; | | ; 60 
ca5e			; | | dw store_page 
ca5e			; | | dw store_readbuf 
ca5e			; | | dw store_readcont 
ca5e			; | | dw store_readptr 
ca5e			; | | dw store_tmpext 
ca5e			; | | dw store_tmpid 
ca5e			; | | dw store_tmppageid 
ca5e			; | | dw malloc 
ca5e			; | | dw free 
ca5e			; | | dw cin 
ca5e			; | | ; 70 
ca5e			; | | dw cin_wait 
ca5e			; | | dw forth_push_numhl 
ca5e			; | | dw forth_push_str 
ca5e			; | | ``` 
ca5e			 
ca5e					if DEBUG_FORTH_WORDS_KEY 
ca5e						DMARK "SYM" 
ca5e f5				push af  
ca5f 3a 73 ca			ld a, (.dmark)  
ca62 32 6b ee			ld (debug_mark),a  
ca65 3a 74 ca			ld a, (.dmark+1)  
ca68 32 6c ee			ld (debug_mark+1),a  
ca6b 3a 75 ca			ld a, (.dmark+2)  
ca6e 32 6d ee			ld (debug_mark+2),a  
ca71 18 03			jr .pastdmark  
ca73 ..			.dmark: db "SYM"  
ca76 f1			.pastdmark: pop af  
ca77			endm  
# End of macro DMARK
ca77						CALLMONITOR 
ca77 cd 6f ee			call debug_vector  
ca7a				endm  
# End of macro CALLMONITOR
ca7a					endif 
ca7a			 
ca7a					FORTH_DSP_VALUEHL 
ca7a cd 9d 9e			call macro_dsp_valuehl 
ca7d				endm 
# End of macro FORTH_DSP_VALUEHL
ca7d			 
ca7d 7d					ld a, l     
ca7e			 
ca7e			 
ca7e					if DEBUG_FORTH_WORDS 
ca7e						DMARK "SY1" 
ca7e f5				push af  
ca7f 3a 93 ca			ld a, (.dmark)  
ca82 32 6b ee			ld (debug_mark),a  
ca85 3a 94 ca			ld a, (.dmark+1)  
ca88 32 6c ee			ld (debug_mark+1),a  
ca8b 3a 95 ca			ld a, (.dmark+2)  
ca8e 32 6d ee			ld (debug_mark+2),a  
ca91 18 03			jr .pastdmark  
ca93 ..			.dmark: db "SY1"  
ca96 f1			.pastdmark: pop af  
ca97			endm  
# End of macro DMARK
ca97						CALLMONITOR 
ca97 cd 6f ee			call debug_vector  
ca9a				endm  
# End of macro CALLMONITOR
ca9a					endif 
ca9a					 
ca9a f5					push af	 
ca9b					FORTH_DSP_POP 
ca9b cd 55 9f			call macro_forth_dsp_pop 
ca9e				endm 
# End of macro FORTH_DSP_POP
ca9e f1					pop af 
ca9f			 
ca9f cb 27				sla a  
caa1				 
caa1					 
caa1					if DEBUG_FORTH_WORDS 
caa1						DMARK "SY" 
caa1 f5				push af  
caa2 3a b6 ca			ld a, (.dmark)  
caa5 32 6b ee			ld (debug_mark),a  
caa8 3a b7 ca			ld a, (.dmark+1)  
caab 32 6c ee			ld (debug_mark+1),a  
caae 3a b8 ca			ld a, (.dmark+2)  
cab1 32 6d ee			ld (debug_mark+2),a  
cab4 18 02			jr .pastdmark  
cab6 ..			.dmark: db "SY"  
cab8 f1			.pastdmark: pop af  
cab9			endm  
# End of macro DMARK
cab9						CALLMONITOR 
cab9 cd 6f ee			call debug_vector  
cabc				endm  
# End of macro CALLMONITOR
cabc					endif 
cabc			 
cabc 21 cb ca				ld hl, sym_table 
cabf cd db 8c				call addatohl 
cac2 cd d5 9f				call loadwordinhl 
cac5 cd a6 9c				call forth_push_numhl 
cac8			 
cac8			 
cac8				       NEXTW 
cac8 c3 53 a0			jp macro_next 
cacb				endm 
# End of macro NEXTW
cacb			 
cacb			sym_table: 
cacb			 
cacb			; 0 
cacb cb ca		dw sym_table 
cacd 72 ee		dw nmi_vector 
cacf 3c ea		dw cli_autodisplay 
cad1 ee e9		dw cli_data_sp 
cad3 28 e8		dw cli_data_stack 
cad5 f0 e9		dw cli_loop_sp 
cad7 2a e9		dw cli_loop_stack 
cad9 28 ea		dw cli_var_array 
cadb c5 eb		dw cursor_col 
cadd c3 eb		dw cursor_ptr 
cadf			; 10 
cadf c4 eb		dw cursor_row 
cae1 6b ee		dw debug_mark 
cae3 b1 ed		dw display_fb0 
cae5 10 ed		dw display_fb1 
cae7 ce eb		dw display_fb2 
cae9 6f ec		dw display_fb3 
caeb cc eb		dw display_fb_active 
caed c0 e3		dw execscratch 
caef 5e ea		dw f_cursor_ptr 
caf1 75 ee		dw hardware_word 
caf3			;20 
caf3 62 ee		dw input_at_cursor 
caf5 64 ee		dw input_at_pos 
caf7 60 ee		dw input_cur_flash 
caf9 5f ee		dw input_cur_onoff 
cafb 55 ee		dw input_cursor 
cafd 65 ee		dw input_display_size 
caff 5a ee		dw input_len 
cb01 69 ee		dw input_ptr 
cb03 66 ee		dw input_size 
cb05 67 ee		dw input_start 
cb07			; 30 
cb07 08 8d		dw input_str 
cb09 63 ee		dw input_under_cursor 
cb0b e8 e5		dw os_cli_cmd 
cb0d e4 e5		dw os_cur_ptr 
cb0f e6 e5		dw os_current_i 
cb11 bf e4		dw os_input 
cb13 e7 e6		dw os_last_cmd 
cb15 be e5		dw os_last_new_uword 
cb17 6f ee		dw debug_vector 
cb19 a3 e2		dw os_view_hl 
cb1b			;40 
cb1b c6 e5		dw os_word_scratch 
cb1d c3 00		dw portbctl 
cb1f c1 00		dw portbdata 
cb21 63 ea		dw spi_cartdev 
cb23 62 ea		dw spi_cartdev2 
cb25 64 ea		dw spi_clktime 
cb27 60 ea		dw spi_device 
cb29 5f ea		dw spi_device_id 
cb2b 61 ea		dw spi_portbyte 
cb2d a7 eb		dw stackstore 
cb2f			; 50 
cb2f			if STORAGE_SE 
cb2f			dw storage_actl 
cb2f			dw storage_adata 
cb2f			else 
cb2f 00 00		dw 0 
cb31 00 00		dw 0 
cb33			endif 
cb33 68 88		dw storage_append 
cb35			if STORAGE_SE 
cb35			dw storage_bctl 
cb35			else 
cb35 00 00		dw 0 
cb37			endif 
cb37 93 eb		dw store_bank_active 
cb39 67 ea		dw store_filecache 
cb3b 75 ea		dw store_longread 
cb3d 6b ea		dw store_openaddr 
cb3f 6a ea		dw store_openext 
cb41 69 ea		dw store_openmaxext 
cb43			; 60 
cb43 7a ea		dw store_page 
cb45 76 ea		dw store_readbuf 
cb47 6d ea		dw store_readcont 
cb49 78 ea		dw store_readptr 
cb4b 6d ea		dw store_tmpext 
cb4d 6e ea		dw store_tmpid 
cb4f 65 ea		dw store_tmppageid 
cb51 0d 93		dw malloc 
cb53 d7 93		dw free 
cb55 34 e6		dw cin 
cb57			; 70 
cb57 2e e6		dw cin_wait 
cb59 a6 9c		dw forth_push_numhl 
cb5b 14 9d		dw forth_push_str 
cb5d			 
cb5d			 
cb5d			.ENDCONST: 
cb5d			 
cb5d			; eof 
cb5d			 
cb5d			 
# End of file forth_words_const.asm
cb5d			 
cb5d			if STORAGE_SE 
cb5d			   	include "forth_words_storage.asm" 
cb5d			endif 
cb5d				include "forth_words_device.asm" 
cb5d			; Device related words 
cb5d			 
cb5d			; | ## Device Words 
cb5d			 
cb5d			;if SOUND_ENABLE 
cb5d			;.NOTE: 
cb5d			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
cb5d			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds  TODO 
cb5d			;		if DEBUG_FORTH_WORDS_KEY 
cb5d			;			DMARK "NTE" 
cb5d			;			CALLMONITOR 
cb5d			;		endif 
cb5d			; 
cb5d			;	 
cb5d			; 
cb5d			;		NEXTW 
cb5d			;.AFTERSOUND: 
cb5d			;endif 
cb5d			 
cb5d			 
cb5d			USE_GPIO: equ 0 
cb5d			 
cb5d			if USE_GPIO 
cb5d			.GP1: 
cb5d				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
cb5d			;  IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result   
cb5d					NEXTW 
cb5d			.GP2: 
cb5d				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
cb5d			;  IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2   
cb5d			 
cb5d					NEXTW 
cb5d			 
cb5d			.GP3: 
cb5d				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
cb5d			;  IOBYTE ( u1 --  )    Perform a GPIO write of byte u1   
cb5d			 
cb5d					NEXTW 
cb5d			 
cb5d			.GP4: 
cb5d				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
cb5d			;  IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin   
cb5d			 
cb5d					NEXTW 
cb5d			.SIN: 
cb5d			 
cb5d			 
cb5d			endif 
cb5d			 
cb5d			 
cb5d				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
cb5d 33				db WORD_SYS_CORE+31             
cb5e 92 cb			dw .SOUT            
cb60 03				db 2 + 1 
cb61 .. 00			db "IN",0              
cb64				endm 
# End of macro CWHEAD
cb64			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
cb64					if DEBUG_FORTH_WORDS_KEY 
cb64						DMARK "IN." 
cb64 f5				push af  
cb65 3a 79 cb			ld a, (.dmark)  
cb68 32 6b ee			ld (debug_mark),a  
cb6b 3a 7a cb			ld a, (.dmark+1)  
cb6e 32 6c ee			ld (debug_mark+1),a  
cb71 3a 7b cb			ld a, (.dmark+2)  
cb74 32 6d ee			ld (debug_mark+2),a  
cb77 18 03			jr .pastdmark  
cb79 ..			.dmark: db "IN."  
cb7c f1			.pastdmark: pop af  
cb7d			endm  
# End of macro DMARK
cb7d						CALLMONITOR 
cb7d cd 6f ee			call debug_vector  
cb80				endm  
# End of macro CALLMONITOR
cb80					endif 
cb80					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cb80 cd 9d 9e			call macro_dsp_valuehl 
cb83				endm 
# End of macro FORTH_DSP_VALUEHL
cb83			 
cb83 e5					push hl 
cb84			 
cb84					; destroy value TOS 
cb84			 
cb84					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cb84 cd 55 9f			call macro_forth_dsp_pop 
cb87				endm 
# End of macro FORTH_DSP_POP
cb87			 
cb87					; one value on hl get other one back 
cb87			 
cb87 c1					pop bc 
cb88			 
cb88					; do the sub 
cb88			;		ex de, hl 
cb88			 
cb88 ed 68				in l,(c) 
cb8a			 
cb8a					; save it 
cb8a			 
cb8a 26 00				ld h,0 
cb8c			 
cb8c					; TODO push value back onto stack for another op etc 
cb8c			 
cb8c cd a6 9c				call forth_push_numhl 
cb8f					NEXTW 
cb8f c3 53 a0			jp macro_next 
cb92				endm 
# End of macro NEXTW
cb92			.SOUT: 
cb92				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
cb92 34				db WORD_SYS_CORE+32             
cb93 e5 cb			dw .SPIO            
cb95 04				db 3 + 1 
cb96 .. 00			db "OUT",0              
cb9a				endm 
# End of macro CWHEAD
cb9a			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
cb9a					if DEBUG_FORTH_WORDS_KEY 
cb9a						DMARK "OUT" 
cb9a f5				push af  
cb9b 3a af cb			ld a, (.dmark)  
cb9e 32 6b ee			ld (debug_mark),a  
cba1 3a b0 cb			ld a, (.dmark+1)  
cba4 32 6c ee			ld (debug_mark+1),a  
cba7 3a b1 cb			ld a, (.dmark+2)  
cbaa 32 6d ee			ld (debug_mark+2),a  
cbad 18 03			jr .pastdmark  
cbaf ..			.dmark: db "OUT"  
cbb2 f1			.pastdmark: pop af  
cbb3			endm  
# End of macro DMARK
cbb3						CALLMONITOR 
cbb3 cd 6f ee			call debug_vector  
cbb6				endm  
# End of macro CALLMONITOR
cbb6					endif 
cbb6			 
cbb6					; get port 
cbb6			 
cbb6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cbb6 cd 9d 9e			call macro_dsp_valuehl 
cbb9				endm 
# End of macro FORTH_DSP_VALUEHL
cbb9			 
cbb9 e5					push hl 
cbba			 
cbba					; destroy value TOS 
cbba			 
cbba					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cbba cd 55 9f			call macro_forth_dsp_pop 
cbbd				endm 
# End of macro FORTH_DSP_POP
cbbd			 
cbbd					; get byte to send 
cbbd			 
cbbd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cbbd cd 9d 9e			call macro_dsp_valuehl 
cbc0				endm 
# End of macro FORTH_DSP_VALUEHL
cbc0			 
cbc0			;		push hl 
cbc0			 
cbc0					; destroy value TOS 
cbc0			 
cbc0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cbc0 cd 55 9f			call macro_forth_dsp_pop 
cbc3				endm 
# End of macro FORTH_DSP_POP
cbc3			 
cbc3					; one value on hl get other one back 
cbc3			 
cbc3			;		pop hl 
cbc3			 
cbc3 c1					pop bc 
cbc4			 
cbc4					if DEBUG_FORTH_WORDS 
cbc4						DMARK "OUT" 
cbc4 f5				push af  
cbc5 3a d9 cb			ld a, (.dmark)  
cbc8 32 6b ee			ld (debug_mark),a  
cbcb 3a da cb			ld a, (.dmark+1)  
cbce 32 6c ee			ld (debug_mark+1),a  
cbd1 3a db cb			ld a, (.dmark+2)  
cbd4 32 6d ee			ld (debug_mark+2),a  
cbd7 18 03			jr .pastdmark  
cbd9 ..			.dmark: db "OUT"  
cbdc f1			.pastdmark: pop af  
cbdd			endm  
# End of macro DMARK
cbdd						CALLMONITOR 
cbdd cd 6f ee			call debug_vector  
cbe0				endm  
# End of macro CALLMONITOR
cbe0					endif 
cbe0			 
cbe0 ed 69				out (c), l 
cbe2			 
cbe2					NEXTW 
cbe2 c3 53 a0			jp macro_next 
cbe5				endm 
# End of macro NEXTW
cbe5			 
cbe5			 
cbe5			.SPIO: 
cbe5			 
cbe5			if STORAGE_SE 
cbe5				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
cbe5			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
cbe5			 
cbe5					call spi_ce_low 
cbe5			    NEXTW 
cbe5			 
cbe5			.SPICEH: 
cbe5				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
cbe5			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
cbe5			 
cbe5					call spi_ce_high 
cbe5			    NEXTW 
cbe5			 
cbe5			 
cbe5			.SPIOb: 
cbe5			 
cbe5				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
cbe5			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
cbe5			 
cbe5					if DEBUG_FORTH_WORDS_KEY 
cbe5						DMARK "SPo" 
cbe5						CALLMONITOR 
cbe5					endif 
cbe5					; get port 
cbe5			 
cbe5			 
cbe5					; get byte to send 
cbe5			 
cbe5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cbe5			 
cbe5			;		push hl    ; u1  
cbe5			 
cbe5					; destroy value TOS 
cbe5			 
cbe5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cbe5			 
cbe5					; one value on hl get other one back 
cbe5			 
cbe5			;		pop hl   ; u2 - addr 
cbe5			 
cbe5					; TODO Send SPI byte 
cbe5			 
cbe5			;		push hl 
cbe5			;		call spi_ce_low 
cbe5			;		pop hl 
cbe5					ld a, l 
cbe5					call spi_send_byte 
cbe5			;		call spi_ce_high 
cbe5			 
cbe5					NEXTW 
cbe5			 
cbe5			.SPII: 
cbe5				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
cbe5			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
cbe5					if DEBUG_FORTH_WORDS_KEY 
cbe5						DMARK "SPi" 
cbe5						CALLMONITOR 
cbe5					endif 
cbe5			 
cbe5					; TODO Get SPI byte 
cbe5			 
cbe5					call spi_read_byte 
cbe5			 
cbe5					if DEBUG_FORTH_WORDS 
cbe5						DMARK "Si2" 
cbe5						CALLMONITOR 
cbe5					endif 
cbe5					ld h, 0 
cbe5					ld l, a 
cbe5					if DEBUG_FORTH_WORDS 
cbe5						DMARK "Si3" 
cbe5						CALLMONITOR 
cbe5					endif 
cbe5					call forth_push_numhl 
cbe5			 
cbe5					NEXTW 
cbe5			 
cbe5			 
cbe5			 
cbe5			.SESEL: 
cbe5				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
cbe5			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
cbe5					if DEBUG_FORTH_WORDS_KEY 
cbe5						DMARK "BNK" 
cbe5						CALLMONITOR 
cbe5					endif 
cbe5			 
cbe5					ld a, 255 
cbe5					ld (spi_cartdev), a 
cbe5			 
cbe5					; get bank 
cbe5			 
cbe5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cbe5			 
cbe5			;		push hl 
cbe5			 
cbe5					; destroy value TOS 
cbe5			 
cbe5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cbe5			 
cbe5					; one value on hl get other one back 
cbe5			 
cbe5			;		pop hl 
cbe5			 
cbe5			 
cbe5					ld c, SPI_CE_HIGH 
cbe5					ld b, '0'    ; human readable bank number 
cbe5			 
cbe5					ld a, l 
cbe5			 
cbe5					if DEBUG_FORTH_WORDS 
cbe5						DMARK "BNK" 
cbe5						CALLMONITOR 
cbe5					endif 
cbe5			 
cbe5					; active low 
cbe5			 
cbe5					cp 0 
cbe5					jr z, .bset 
cbe5					cp 1 
cbe5					jr nz, .b2 
cbe5					res 0, c 
cbe5					ld b, '1'    ; human readable bank number 
cbe5			.b2:		cp 2 
cbe5					jr nz, .b3 
cbe5					res 1, c 
cbe5					ld b, '2'    ; human readable bank number 
cbe5			.b3:		cp 3 
cbe5					jr nz, .b4 
cbe5					res 2, c 
cbe5					ld b, '3'    ; human readable bank number 
cbe5			.b4:		cp 4 
cbe5					jr nz, .b5 
cbe5					res 3, c 
cbe5					ld b, '4'    ; human readable bank number 
cbe5			.b5:		cp 5 
cbe5					jr nz, .bset 
cbe5					res 4, c 
cbe5					ld b, '5'    ; human readable bank number 
cbe5			 
cbe5			.bset: 
cbe5					ld a, c 
cbe5					ld (spi_device),a 
cbe5					ld a, b 
cbe5					ld (spi_device_id),a 
cbe5					if DEBUG_FORTH_WORDS 
cbe5						DMARK "BN2" 
cbe5						CALLMONITOR 
cbe5					endif 
cbe5			 
cbe5					; set default SPI clk pulse time as disabled for BANK use 
cbe5			 
cbe5					ld a, 0 
cbe5					ld (spi_clktime), a 
cbe5			 
cbe5					NEXTW 
cbe5			 
cbe5			.CARTDEV: 
cbe5				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
cbe5			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
cbe5					if DEBUG_FORTH_WORDS_KEY 
cbe5						DMARK "CDV" 
cbe5						CALLMONITOR 
cbe5					endif 
cbe5			 
cbe5					; disable se storage bank selection 
cbe5			 
cbe5					ld a, SPI_CE_HIGH		; ce high 
cbe5					ld (spi_device), a 
cbe5			 
cbe5					; get bank 
cbe5			 
cbe5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cbe5			 
cbe5			;		push hl 
cbe5			 
cbe5					; destroy value TOS 
cbe5			 
cbe5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cbe5			 
cbe5					; one value on hl get other one back 
cbe5			 
cbe5			;		pop hl 
cbe5			 
cbe5					; active low 
cbe5			 
cbe5					ld c, 255 
cbe5			 
cbe5					ld a, l 
cbe5					if DEBUG_FORTH_WORDS 
cbe5						DMARK "CDV" 
cbe5						CALLMONITOR 
cbe5					endif 
cbe5					cp 0 
cbe5					jr z, .cset 
cbe5					cp 1 
cbe5					jr nz, .c2 
cbe5					res 0, c 
cbe5			.c2:		cp 2 
cbe5					jr nz, .c3 
cbe5					res 1, c 
cbe5			.c3:		cp 3 
cbe5					jr nz, .c4 
cbe5					res 2, c 
cbe5			.c4:		cp 4 
cbe5					jr nz, .c5 
cbe5					res 3, c 
cbe5			.c5:		cp 5 
cbe5					jr nz, .c6 
cbe5					res 4, c 
cbe5			.c6:		cp 6 
cbe5					jr nz, .c7 
cbe5					res 5, c 
cbe5			.c7:		cp 7 
cbe5					jr nz, .c8 
cbe5					res 6, c 
cbe5			.c8:		cp 8 
cbe5					jr nz, .cset 
cbe5					res 7, c 
cbe5			.cset:		ld a, c 
cbe5					ld (spi_cartdev),a 
cbe5			 
cbe5					if DEBUG_FORTH_WORDS 
cbe5						DMARK "CD2" 
cbe5						CALLMONITOR 
cbe5					endif 
cbe5			 
cbe5					; set default SPI clk pulse time as 10ms for CARTDEV use 
cbe5			 
cbe5					ld a, $0a 
cbe5					ld (spi_clktime), a 
cbe5					NEXTW 
cbe5			endif 
cbe5			 
cbe5			.ENDDEVICE: 
cbe5			; eof 
cbe5			 
# End of file forth_words_device.asm
cbe5			 
cbe5			; var handler 
cbe5			 
cbe5			 
cbe5			.VARS: 
cbe5				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
cbe5 77				db WORD_SYS_CORE+99             
cbe6 96 cc			dw .V0            
cbe8 04				db 3 + 1 
cbe9 .. 00			db "VAR",0              
cbed				endm 
# End of macro CWHEAD
cbed			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
cbed			;| 
cbed			;| The variable name should consist of a single letter. e.g. "a" 
cbed			;! If a full string is passed then only the first char is looked at 
cbed			;| Any other char could exceed bounds checks!  
cbed			 
cbed					if DEBUG_FORTH_WORDS_KEY 
cbed						DMARK "VAR" 
cbed f5				push af  
cbee 3a 02 cc			ld a, (.dmark)  
cbf1 32 6b ee			ld (debug_mark),a  
cbf4 3a 03 cc			ld a, (.dmark+1)  
cbf7 32 6c ee			ld (debug_mark+1),a  
cbfa 3a 04 cc			ld a, (.dmark+2)  
cbfd 32 6d ee			ld (debug_mark+2),a  
cc00 18 03			jr .pastdmark  
cc02 ..			.dmark: db "VAR"  
cc05 f1			.pastdmark: pop af  
cc06			endm  
# End of macro DMARK
cc06						CALLMONITOR 
cc06 cd 6f ee			call debug_vector  
cc09				endm  
# End of macro CALLMONITOR
cc09					endif 
cc09			 
cc09					FORTH_DSP_VALUEHL 
cc09 cd 9d 9e			call macro_dsp_valuehl 
cc0c				endm 
# End of macro FORTH_DSP_VALUEHL
cc0c			 
cc0c 7e					ld a, (hl)    ; get first char on of the string 
cc0d			 
cc0d			 
cc0d					if DEBUG_FORTH_WORDS 
cc0d						DMARK "VR1" 
cc0d f5				push af  
cc0e 3a 22 cc			ld a, (.dmark)  
cc11 32 6b ee			ld (debug_mark),a  
cc14 3a 23 cc			ld a, (.dmark+1)  
cc17 32 6c ee			ld (debug_mark+1),a  
cc1a 3a 24 cc			ld a, (.dmark+2)  
cc1d 32 6d ee			ld (debug_mark+2),a  
cc20 18 03			jr .pastdmark  
cc22 ..			.dmark: db "VR1"  
cc25 f1			.pastdmark: pop af  
cc26			endm  
# End of macro DMARK
cc26						CALLMONITOR 
cc26 cd 6f ee			call debug_vector  
cc29				endm  
# End of macro CALLMONITOR
cc29					endif 
cc29					 
cc29 f5					push af	 
cc2a					FORTH_DSP_POP 
cc2a cd 55 9f			call macro_forth_dsp_pop 
cc2d				endm 
# End of macro FORTH_DSP_POP
cc2d f1					pop af 
cc2e			 
cc2e					; convert to upper 
cc2e			 
cc2e cd a7 91				call to_upper 
cc31					if DEBUG_FORTH_WORDS 
cc31						DMARK "Vaa" 
cc31 f5				push af  
cc32 3a 46 cc			ld a, (.dmark)  
cc35 32 6b ee			ld (debug_mark),a  
cc38 3a 47 cc			ld a, (.dmark+1)  
cc3b 32 6c ee			ld (debug_mark+1),a  
cc3e 3a 48 cc			ld a, (.dmark+2)  
cc41 32 6d ee			ld (debug_mark+2),a  
cc44 18 03			jr .pastdmark  
cc46 ..			.dmark: db "Vaa"  
cc49 f1			.pastdmark: pop af  
cc4a			endm  
# End of macro DMARK
cc4a						CALLMONITOR 
cc4a cd 6f ee			call debug_vector  
cc4d				endm  
# End of macro CALLMONITOR
cc4d					endif 
cc4d 06 41				ld b, 'A' 
cc4f 90					sub b			; set offset 
cc50					if DEBUG_FORTH_WORDS 
cc50						DMARK "Vbb" 
cc50 f5				push af  
cc51 3a 65 cc			ld a, (.dmark)  
cc54 32 6b ee			ld (debug_mark),a  
cc57 3a 66 cc			ld a, (.dmark+1)  
cc5a 32 6c ee			ld (debug_mark+1),a  
cc5d 3a 67 cc			ld a, (.dmark+2)  
cc60 32 6d ee			ld (debug_mark+2),a  
cc63 18 03			jr .pastdmark  
cc65 ..			.dmark: db "Vbb"  
cc68 f1			.pastdmark: pop af  
cc69			endm  
# End of macro DMARK
cc69						CALLMONITOR 
cc69 cd 6f ee			call debug_vector  
cc6c				endm  
# End of macro CALLMONITOR
cc6c					endif 
cc6c cb 27				sla a  
cc6e				 
cc6e					 
cc6e					if DEBUG_FORTH_WORDS 
cc6e						DMARK "VR2" 
cc6e f5				push af  
cc6f 3a 83 cc			ld a, (.dmark)  
cc72 32 6b ee			ld (debug_mark),a  
cc75 3a 84 cc			ld a, (.dmark+1)  
cc78 32 6c ee			ld (debug_mark+1),a  
cc7b 3a 85 cc			ld a, (.dmark+2)  
cc7e 32 6d ee			ld (debug_mark+2),a  
cc81 18 03			jr .pastdmark  
cc83 ..			.dmark: db "VR2"  
cc86 f1			.pastdmark: pop af  
cc87			endm  
# End of macro DMARK
cc87						CALLMONITOR 
cc87 cd 6f ee			call debug_vector  
cc8a				endm  
# End of macro CALLMONITOR
cc8a					endif 
cc8a			 
cc8a 21 f4 e9				ld hl, cli_var_array2 
cc8d cd db 8c				call addatohl 
cc90 cd a6 9c				call forth_push_numhl 
cc93			 
cc93			 
cc93				       NEXTW 
cc93 c3 53 a0			jp macro_next 
cc96				endm 
# End of macro NEXTW
cc96			.V0: 
cc96				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
cc96 78				db WORD_SYS_CORE+100             
cc97 ae cc			dw .V0Q            
cc99 04				db 3 + 1 
cc9a .. 00			db "V0!",0              
cc9e				endm 
# End of macro CWHEAD
cc9e			;| V0! ( u1 -- )  Store value to v0  | DONE 
cc9e			 
cc9e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cc9e cd 9d 9e			call macro_dsp_valuehl 
cca1				endm 
# End of macro FORTH_DSP_VALUEHL
cca1			 
cca1 11 28 ea				ld de, cli_var_array 
cca4			 
cca4 eb					ex de, hl 
cca5 73					ld (hl), e 
cca6 23					inc hl 
cca7 72					ld (hl), d 
cca8			 
cca8					; destroy value TOS 
cca8			 
cca8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cca8 cd 55 9f			call macro_forth_dsp_pop 
ccab				endm 
# End of macro FORTH_DSP_POP
ccab			 
ccab				       NEXTW 
ccab c3 53 a0			jp macro_next 
ccae				endm 
# End of macro NEXTW
ccae			.V0Q: 
ccae				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
ccae 79				db WORD_SYS_CORE+101             
ccaf bf cc			dw .V1S            
ccb1 04				db 3 + 1 
ccb2 .. 00			db "V0@",0              
ccb6				endm 
# End of macro CWHEAD
ccb6			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
ccb6 2a 28 ea				ld hl, (cli_var_array) 
ccb9 cd a6 9c				call forth_push_numhl 
ccbc			 
ccbc				       NEXTW 
ccbc c3 53 a0			jp macro_next 
ccbf				endm 
# End of macro NEXTW
ccbf			.V1S: 
ccbf				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
ccbf 7a				db WORD_SYS_CORE+102             
ccc0 d7 cc			dw .V1Q            
ccc2 04				db 3 + 1 
ccc3 .. 00			db "V1!",0              
ccc7				endm 
# End of macro CWHEAD
ccc7			;| V1! ( u1 -- )  Store value to v1 | DONE 
ccc7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ccc7 cd 9d 9e			call macro_dsp_valuehl 
ccca				endm 
# End of macro FORTH_DSP_VALUEHL
ccca			 
ccca 11 2a ea				ld de, cli_var_array+2 
cccd				 
cccd eb					ex de, hl 
ccce 73					ld (hl), e 
cccf 23					inc hl 
ccd0 72					ld (hl), d 
ccd1			 
ccd1					; destroy value TOS 
ccd1			 
ccd1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ccd1 cd 55 9f			call macro_forth_dsp_pop 
ccd4				endm 
# End of macro FORTH_DSP_POP
ccd4				       NEXTW 
ccd4 c3 53 a0			jp macro_next 
ccd7				endm 
# End of macro NEXTW
ccd7			.V1Q: 
ccd7				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
ccd7 7b				db WORD_SYS_CORE+103             
ccd8 e8 cc			dw .V2S            
ccda 04				db 3 + 1 
ccdb .. 00			db "V1@",0              
ccdf				endm 
# End of macro CWHEAD
ccdf			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
ccdf 2a 2a ea				ld hl, (cli_var_array+2) 
cce2 cd a6 9c				call forth_push_numhl 
cce5				       NEXTW 
cce5 c3 53 a0			jp macro_next 
cce8				endm 
# End of macro NEXTW
cce8			.V2S: 
cce8				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
cce8 7c				db WORD_SYS_CORE+104             
cce9 00 cd			dw .V2Q            
cceb 04				db 3 + 1 
ccec .. 00			db "V2!",0              
ccf0				endm 
# End of macro CWHEAD
ccf0			;| V2! ( u1 -- )  Store value to v2 | DONE 
ccf0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ccf0 cd 9d 9e			call macro_dsp_valuehl 
ccf3				endm 
# End of macro FORTH_DSP_VALUEHL
ccf3			 
ccf3 11 2c ea				ld de, cli_var_array+4 
ccf6				 
ccf6 eb					ex de, hl 
ccf7 73					ld (hl), e 
ccf8 23					inc hl 
ccf9 72					ld (hl), d 
ccfa			 
ccfa					; destroy value TOS 
ccfa			 
ccfa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ccfa cd 55 9f			call macro_forth_dsp_pop 
ccfd				endm 
# End of macro FORTH_DSP_POP
ccfd				       NEXTW 
ccfd c3 53 a0			jp macro_next 
cd00				endm 
# End of macro NEXTW
cd00			.V2Q: 
cd00				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
cd00 7d				db WORD_SYS_CORE+105             
cd01 11 cd			dw .V3S            
cd03 04				db 3 + 1 
cd04 .. 00			db "V2@",0              
cd08				endm 
# End of macro CWHEAD
cd08			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
cd08 2a 2c ea				ld hl, (cli_var_array+4) 
cd0b cd a6 9c				call forth_push_numhl 
cd0e				       NEXTW 
cd0e c3 53 a0			jp macro_next 
cd11				endm 
# End of macro NEXTW
cd11			.V3S: 
cd11				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
cd11 7c				db WORD_SYS_CORE+104             
cd12 29 cd			dw .V3Q            
cd14 04				db 3 + 1 
cd15 .. 00			db "V3!",0              
cd19				endm 
# End of macro CWHEAD
cd19			;| V3! ( u1 -- )  Store value to v3 | DONE 
cd19					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cd19 cd 9d 9e			call macro_dsp_valuehl 
cd1c				endm 
# End of macro FORTH_DSP_VALUEHL
cd1c			 
cd1c 11 2e ea				ld de, cli_var_array+6 
cd1f				 
cd1f eb					ex de, hl 
cd20 73					ld (hl), e 
cd21 23					inc hl 
cd22 72					ld (hl), d 
cd23			 
cd23					; destroy value TOS 
cd23			 
cd23					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cd23 cd 55 9f			call macro_forth_dsp_pop 
cd26				endm 
# End of macro FORTH_DSP_POP
cd26				       NEXTW 
cd26 c3 53 a0			jp macro_next 
cd29				endm 
# End of macro NEXTW
cd29			.V3Q: 
cd29				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
cd29 7d				db WORD_SYS_CORE+105             
cd2a 3a cd			dw .END            
cd2c 04				db 3 + 1 
cd2d .. 00			db "V3@",0              
cd31				endm 
# End of macro CWHEAD
cd31			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
cd31 2a 2e ea				ld hl, (cli_var_array+6) 
cd34 cd a6 9c				call forth_push_numhl 
cd37				       NEXTW 
cd37 c3 53 a0			jp macro_next 
cd3a				endm 
# End of macro NEXTW
cd3a			 
cd3a			 
cd3a			 
cd3a			 
cd3a			 
cd3a			; end of dict marker 
cd3a			 
cd3a 00			.END:    db WORD_SYS_END 
cd3b 00 00			dw 0 
cd3d 00				db 0 
cd3e			 
cd3e			; use to jp here for user dict words to save on macro expansion  
cd3e			 
cd3e			user_dict_next: 
cd3e				NEXTW 
cd3e c3 53 a0			jp macro_next 
cd41				endm 
# End of macro NEXTW
cd41			 
cd41			 
cd41			user_exec: 
cd41				;    ld hl, <word code> 
cd41				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
cd41				;    call forthexec 
cd41				;    jp user_dict_next   (NEXT) 
cd41			        ;    <word code bytes> 
cd41 eb				ex de, hl 
cd42 2a c2 e5			ld hl,(os_tok_ptr) 
cd45				 
cd45				FORTH_RSP_NEXT 
cd45 cd 4d 9c			call macro_forth_rsp_next 
cd48				endm 
# End of macro FORTH_RSP_NEXT
cd48			 
cd48			if DEBUG_FORTH_UWORD 
cd48						DMARK "UEX" 
cd48 f5				push af  
cd49 3a 5d cd			ld a, (.dmark)  
cd4c 32 6b ee			ld (debug_mark),a  
cd4f 3a 5e cd			ld a, (.dmark+1)  
cd52 32 6c ee			ld (debug_mark+1),a  
cd55 3a 5f cd			ld a, (.dmark+2)  
cd58 32 6d ee			ld (debug_mark+2),a  
cd5b 18 03			jr .pastdmark  
cd5d ..			.dmark: db "UEX"  
cd60 f1			.pastdmark: pop af  
cd61			endm  
# End of macro DMARK
cd61				CALLMONITOR 
cd61 cd 6f ee			call debug_vector  
cd64				endm  
# End of macro CALLMONITOR
cd64			endif 
cd64			 
cd64			 
cd64			 
cd64 eb				ex de, hl 
cd65 22 c2 e5			ld (os_tok_ptr), hl 
cd68				 
cd68				; Don't use next - Skips the first word in uword. 
cd68			 
cd68 c3 e4 a0			jp exec1 
cd6b			;	NEXT 
cd6b			 
cd6b			 
cd6b			; eof 
# End of file forth_wordsv4.asm
cd6b			endif 
cd6b			;;;;;;;;;;;;;; Debug code 
cd6b			 
cd6b			 
cd6b			;if DEBUG_FORTH_PARSE 
cd6b .. 00		.nowordfound: db "No match",0 
cd74 .. 00		.compword:	db "Comparing word ",0 
cd84 .. 00		.nextwordat:	db "Next word at",0 
cd91 .. 00		.charmatch:	db "Char match",0 
cd9c			;endif 
cd9c			if DEBUG_FORTH_JP 
cd9c			.foundword:	db "Word match. Exec..",0 
cd9c			endif 
cd9c			;if DEBUG_FORTH_PUSH 
cd9c .. 00		.enddict:	db "Dict end. Push.",0 
cdac .. 00		.push_str:	db "Pushing string",0 
cdbb .. 00		.push_num:	db "Pushing number",0 
cdca .. 00		.data_sp:	db "SP:",0 
cdce .. 00		.wordinhl:	db "Word in HL (2/0):",0 
cde0 .. 00		.wordinde:	db "Word in DE (3/0):",0 
cdf2 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
ce04			;endif 
ce04			;if DEBUG_FORTH_MALLOC 
ce04 .. 00		.push_malloc:	db "Malloc address",0 
ce13			;endif 
ce13			 
ce13			 
ce13			 
ce13			; display malloc address and current data stack pointer  
ce13			 
ce13			malloc_error: 
ce13 d5				push de 
ce14 f5				push af 
ce15 e5				push hl 
ce16 cd ae 8a			call clear_display 
ce19 11 39 ce			ld de, .mallocerr 
ce1c 3e 00			ld a,0 
ce1e			;	ld de,os_word_scratch 
ce1e cd c1 8a			call str_at_display 
ce21 3e 11			ld a, display_row_1+17 
ce23 11 6b ee			ld de, debug_mark 
ce26 cd c1 8a			call str_at_display 
ce29 cd d1 8a			call update_display 
ce2c				;call break_point_state 
ce2c cd 2e e6			call cin_wait 
ce2f			 
ce2f			;	ld a, ' ' 
ce2f			;	ld (os_view_disable), a 
ce2f cd 3c 96			call bp_on 
ce32 e1				pop hl 
ce33 f1				pop af 
ce34 d1				pop de	 
ce35				CALLMONITOR 
ce35 cd 6f ee			call debug_vector  
ce38				endm  
# End of macro CALLMONITOR
ce38 c9				ret 
ce39			 
ce39 .. 00		.mallocerr: 	db "Malloc Error",0 
ce46			;if DEBUG_FORTH_PUSH 
ce46			display_data_sp: 
ce46 f5				push af 
ce47			 
ce47				; see if disabled 
ce47			 
ce47			 
ce47 3a 6f ee			ld a, (debug_vector) 
ce4a fe c9			cp $C9  ; RET 
ce4c				;ld a, (os_view_disable) 
ce4c				;cp '*' 
ce4c 28 67			jr z, .skipdsp 
ce4e			 
ce4e e5				push hl 
ce4f e5				push hl 
ce50 e5			push hl 
ce51 cd ae 8a			call clear_display 
ce54 e1			pop hl 
ce55 7c				ld a,h 
ce56 21 c6 e5			ld hl, os_word_scratch 
ce59 cd 3b 91			call hexout 
ce5c e1				pop hl 
ce5d 7d				ld a,l 
ce5e 21 c8 e5			ld hl, os_word_scratch+2 
ce61 cd 3b 91			call hexout 
ce64 21 ca e5			ld hl, os_word_scratch+4 
ce67 3e 00			ld a,0 
ce69 77				ld (hl),a 
ce6a 11 c6 e5			ld de,os_word_scratch 
ce6d 3e 28				ld a, display_row_2 
ce6f cd c1 8a				call str_at_display 
ce72 11 ce cd			ld de, .wordinhl 
ce75 3e 00			ld a, display_row_1 
ce77			 
ce77 cd c1 8a				call str_at_display 
ce7a 11 6b ee			ld de, debug_mark 
ce7d 3e 11			ld a, display_row_1+17 
ce7f			 
ce7f cd c1 8a				call str_at_display 
ce82			 
ce82				; display current data stack pointer 
ce82 11 ca cd			ld de,.data_sp 
ce85 3e 30				ld a, display_row_2 + 8 
ce87 cd c1 8a				call str_at_display 
ce8a			 
ce8a 2a ee e9			ld hl,(cli_data_sp) 
ce8d e5				push hl 
ce8e 7c				ld a,h 
ce8f 21 c6 e5			ld hl, os_word_scratch 
ce92 cd 3b 91			call hexout 
ce95 e1				pop hl 
ce96 7d				ld a,l 
ce97 21 c8 e5			ld hl, os_word_scratch+2 
ce9a cd 3b 91			call hexout 
ce9d 21 ca e5			ld hl, os_word_scratch+4 
cea0 3e 00			ld a,0 
cea2 77				ld (hl),a 
cea3 11 c6 e5			ld de,os_word_scratch 
cea6 3e 33				ld a, display_row_2 + 11 
cea8 cd c1 8a				call str_at_display 
ceab			 
ceab			 
ceab cd d1 8a			call update_display 
ceae cd f1 89			call delay1s 
ceb1 cd f1 89			call delay1s 
ceb4 e1				pop hl 
ceb5			.skipdsp: 
ceb5 f1				pop af 
ceb6 c9				ret 
ceb7			 
ceb7			display_data_malloc: 
ceb7			 
ceb7 f5				push af 
ceb8 e5				push hl 
ceb9 e5				push hl 
ceba e5			push hl 
cebb cd ae 8a			call clear_display 
cebe e1			pop hl 
cebf 7c				ld a,h 
cec0 21 c6 e5			ld hl, os_word_scratch 
cec3 cd 3b 91			call hexout 
cec6 e1				pop hl 
cec7 7d				ld a,l 
cec8 21 c8 e5			ld hl, os_word_scratch+2 
cecb cd 3b 91			call hexout 
cece 21 ca e5			ld hl, os_word_scratch+4 
ced1 3e 00			ld a,0 
ced3 77				ld (hl),a 
ced4 11 c6 e5			ld de,os_word_scratch 
ced7 3e 28				ld a, display_row_2 
ced9 cd c1 8a				call str_at_display 
cedc 11 04 ce			ld de, .push_malloc 
cedf 3e 00			ld a, display_row_1 
cee1			 
cee1 cd c1 8a				call str_at_display 
cee4			 
cee4				; display current data stack pointer 
cee4 11 ca cd			ld de,.data_sp 
cee7 3e 30				ld a, display_row_2 + 8 
cee9 cd c1 8a				call str_at_display 
ceec			 
ceec 2a ee e9			ld hl,(cli_data_sp) 
ceef e5				push hl 
cef0 7c				ld a,h 
cef1 21 c6 e5			ld hl, os_word_scratch 
cef4 cd 3b 91			call hexout 
cef7 e1				pop hl 
cef8 7d				ld a,l 
cef9 21 c8 e5			ld hl, os_word_scratch+2 
cefc cd 3b 91			call hexout 
ceff 21 ca e5			ld hl, os_word_scratch+4 
cf02 3e 00			ld a,0 
cf04 77				ld (hl),a 
cf05 11 c6 e5			ld de,os_word_scratch 
cf08 3e 33				ld a, display_row_2 + 11 
cf0a cd c1 8a				call str_at_display 
cf0d			 
cf0d cd d1 8a			call update_display 
cf10 cd f1 89			call delay1s 
cf13 cd f1 89			call delay1s 
cf16 e1				pop hl 
cf17 f1				pop af 
cf18 c9				ret 
cf19			;endif 
cf19			 
cf19			include "forth_autostart.asm" 
cf19			; list of commands to perform at system start up 
cf19			 
cf19			startcmds: 
cf19			;	dw test11 
cf19			;	dw test12 
cf19			;	dw test13 
cf19			;	dw test14 
cf19			;	dw test15 
cf19			;	dw test16 
cf19			;	dw test17 
cf19			;	dw ifthtest1 
cf19			;	dw ifthtest2 
cf19			;	dw ifthtest3 
cf19			;	dw mmtest1 
cf19			;	dw mmtest2 
cf19			;	dw mmtest3 
cf19			;	dw mmtest4 
cf19			;	dw mmtest5 
cf19			;	dw mmtest6 
cf19			;	dw iftest1 
cf19			;	dw iftest2 
cf19			;	dw iftest3 
cf19			;	dw looptest1 
cf19			;	dw looptest2 
cf19			;	dw test1 
cf19			;	dw test2 
cf19			;	dw test3 
cf19			;	dw test4 
cf19			;	dw game2r 
cf19			;	dw game2b1 
cf19			;	dw game2b2 
cf19			 
cf19				; start up words that are actually useful 
cf19			 
cf19			;    dw spi1 
cf19			;    dw spi2 
cf19			;    dw spi3 
cf19			;    dw spi4 
cf19			;    dw spi5 
cf19			;    dw spi6 
cf19			;    dw spi7 
cf19			; 
cf19			;    dw spi8 
cf19			;    dw spi9 
cf19			;    dw spi10 
cf19			 
cf19			; file editor 
cf19			;	dw edit1 
cf19			;	dw edit2 
cf19			;	dw edit3 
cf19			 
cf19			;	dw longread 
cf19 43 d3			dw clrstack 
cf1b 77 d3			dw type 
cf1d			;	dw stest 
cf1d 9c d3			dw strncpy 
cf1f			;	dw list 
cf1f fd d3			dw start1 
cf21 0d d4			dw start2 
cf23			;	dw start3 
cf23			;	dw start3b 
cf23			;	dw start3c 
cf23			 
cf23				; (unit) testing words 
cf23			 
cf23			;	dw mtesta 
cf23			;	dw mtestb 
cf23			;	dw mtestc 
cf23			;	dw mtestd 
cf23			;	dw mteste 
cf23			 
cf23				; demo/game words 
cf23			 
cf23			;        dw game3w 
cf23			;        dw game3p 
cf23			;        dw game3sc 
cf23			;        dw game3vsi 
cf23			;        dw game3vs 
cf23				 
cf23 66 de			dw game2b 
cf25 d4 de			dw game2bf 
cf27 1e df			dw game2mba 
cf29 b4 df			dw game2mbas 
cf2b f6 df			dw game2mb 
cf2d			 
cf2d 27 db			dw game1 
cf2f 38 db			dw game1a 
cf31 9a db			dw game1b 
cf33 cf db			dw game1c 
cf35 05 dc			dw game1d 
cf37 36 dc			dw game1s 
cf39 4a dc			dw game1t 
cf3b 5f dc			dw game1f 
cf3d 93 dc			dw game1z 
cf3f d7 dc			dw game1zz 
cf41			 
cf41 41 d9			dw test5 
cf43 79 d9			dw test6 
cf45 b1 d9			dw test7 
cf47 c5 d9			dw test8 
cf49 f1 d9			dw test9 
cf4b 07 da			dw test10 
cf4d				 
cf4d ae dd		        dw ssv5 
cf4f 92 dd		        dw ssv4 
cf51 76 dd		        dw ssv3 
cf53 40 dd		        dw ssv2 
cf55 c7 dd		        dw ssv1 
cf57 0f de		        dw ssv1cpm 
cf59			;	dw keyup 
cf59			;	dw keydown 
cf59			;	dw keyleft 
cf59			;	dw keyright 
cf59			;	dw 	keyf1 
cf59			;	dw keyf2 
cf59			;	dw keyf3 
cf59			;	dw keyf4 
cf59			;	dw keyf5 
cf59			;	dw keyf6 
cf59			;	dw keyf7 
cf59			;	dw keyf8 
cf59			;	dw keyf9 
cf59			;	dw keyf10 
cf59			;	dw keyf11 
cf59			;	dw keyf12 
cf59			;	dw keytab 
cf59			;	dw keycr 
cf59			;	dw keyhome 
cf59			;	dw keyend 
cf59			;	dw keybs 
cf59 00 00			db 0, 0	 
cf5b			 
cf5b			 
cf5b			; File Editor 
cf5b			 
cf5b			; ( id - ) use 'e' to edit the displayed line 
cf5b .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
cf7c .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
cfb1			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
cfb1 .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
cfe9			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
cfe9			 
cfe9			; SPI Net support words 
cfe9			 
cfe9			; v0! = node to send to 
cfe9			; ( str count - ) 
cfe9 .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
d042			 
d042			; spiputc ( char node - ) 
d042 .. 00		spi2:       db ": spiputc spicel $10 spio spio ptr @ spio spiceh ; ",0 
d076			; spiputc ( u node - ) 
d076 .. 00		spi2b:       db ": spiputb spicel $10 spio spio spio spiceh ; ",0 
d0a4			 
d0a4			; spigetc ( - n ) 
d0a4 .. 00		spi4:       db ": spigetc spicel $11 spio spii spiceh ; ", 0 
d0cd			 
d0cd			; getnode ( - n ) 
d0cd .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
d0fa			 
d0fa			; ( str node - )  
d0fa .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
d160			; store string ( str i - ) 
d160			 
d160			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
d160 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
d1b5			 
d1b5			; get string ( addr i -  )    TO FIX 
d1b5			 
d1b5 .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
d20d			 
d20d			 
d20d			; NETCHAT (TODO) 
d20d			; Program to allow two nodes to chat with eachother 
d20d			; 
d20d			; v0 - target node 
d20d			;  
d20d			; accept input at 0,0 
d20d			; if input is string send spitype to target node 
d20d			; starting at row 2,0 , while spigetchr is not zero ->  
d20d			; 
d20d			; 
d20d			; TODO add paging of get request 
d20d			 
d20d			; ( node - ) 
d20d .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
d22c .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
d284 .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
d2fc			 
d2fc			 
d2fc			; Long read of currently open file 
d2fc .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
d343			 
d343			; clear stack  
d343			 
d343 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
d377			 
d377			; type ( addr count - ) 
d377 .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
d39c			 
d39c			; some direct memory words 
d39c			; strncpy ( len t f -- t ) 
d39c			 
d39c .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
d3fd			 
d3fd .. 00		start1:     	db ": bpon $00 bp ;",0 
d40d .. 00		start2:     	db ": bpoff $01 bp ;",0 
d41e .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
d499 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
d4f9			 
d4f9			 
d4f9			; a handy word to list items on the stack 
d4f9			 
d4f9 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
d563			 
d563			 
d563			; test stack  
d563			; rnd8 stest 
d563			 
d563 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
d5da			 
d5da			; random malloc and free cycles 
d5da			 
d5da .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
d68f			 
d68f			; fixed malloc and free cycles 
d68f			 
d68f .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
d732			 
d732			; fixed double string push and drop cycle  
d732			 
d732 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
d7e7			 
d7e7			; consistent fixed string push and drop cycle  
d7e7			 
d7e7 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
d88b			 
d88b .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
d941			 
d941			;test1:		db ": aa 1 2 3 ;", 0 
d941			;test2:     	db "111 aa 888 999",0 
d941			;test3:     	db ": bb 77 ;",0 
d941			;test4:     	db "$02 $01 do i . loop bb",0 
d941			 
d941 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
d979 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
d9b1 .. 00		test7:     	db ": box hline vline ;",0 
d9c5 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
d9f1 .. 00		test9:     	db ": sw $01 adsp world ;",0 
da07 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
da2c .. 00		test11:     	db "hello create .",0 
da3b .. 00		test12:     	db "hello2 create .",0 
da4b			 
da4b			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
da4b			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
da4b			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
da4b			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
da4b			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
da4b			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
da4b			 
da4b			;iftest1:     	db "$0001 IF cls .",0 
da4b			;iftest2:     	db "$0000 IF cls .",0 
da4b			;iftest3:     	db "$0002 $0003 - IF cls .",0 
da4b			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
da4b			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
da4b			 
da4b			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
da4b			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
da4b			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
da4b			 
da4b			 
da4b .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
da6f .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
da9f .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
dac4 .. 00		sound4: db ": cha $00 ; ",0 
dad1 .. 00		sound5: db ": chb $20 ; ",0 
dade .. 00		sound6: db ": chc $40 ; ",0 
daeb .. 00		sound7: db ": chd $60 ; ",0 
daf8 .. 00		sound8: db ": cnote $80 + + note ; ", 0 
db10 .. 00		sound9: db ": cvol $90 + + note ; ", 0 
db27			 
db27			 
db27			 
db27			 
db27			; a small guess the number game 
db27			 
db27 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
db38 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
db9a			 
db9a .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
dbcf .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
dc05 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
dc36 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
dc4a .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
dc5f .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
dc93 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
dcd7			 
dcd7			; Using 'ga' save a high score across multiple runs using external storage 
dcd7			 
dcd7 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
dd40			 
dd40			 
dd40			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
dd40			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
dd40			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
dd40			 
dd40			; simple screen saver to test code memory reuse to destruction 
dd40			 
dd40 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
dd76 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
dd92 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
ddae .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
ddc7 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
de0f .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
de66			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
de66			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
de66			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
de66			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
de66			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
de66			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
de66			 
de66			 
de66			 
de66			; minesweeper/battleship finding game 
de66			; draws a game board of random ship/mine positions 
de66			; user enters coords to see if it hits on 
de66			; game ends when all are hit 
de66			; when hit or miss says how many may be in the area 
de66			 
de66			; setup the game board and then hide it 
de66 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
ded4 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
df1e			; prompt for where to target 
df1e .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
dfb4 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
dfd9			; TODO see if the entered coords hits or misses pushes char hit of miss 
dfd9 .. 00		game2mbht:      db ": mbckht nop ;",0 
dfe8 .. 00		game2mbms:      db ": mbcms nop ;",0 
dff6			; TODO how many might be near by 
dff6 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
e073			 
e073			; Game 3 
e073			 
e073			; Vert scroller ski game - avoid the trees! 
e073			 
e073			; v0 score (ie turns) 
e073			; v1 player pos 
e073			; v2 left wall 
e073			; v3 right wall 
e073			 
e073			; Draw side walls randomly 
e073			 
e073 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
e0a1			 
e0a1			; Draw player 
e0a1 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
e0bf			 
e0bf			; TODO Get Key 
e0bf			 
e0bf			; TODO Move left right 
e0bf			 
e0bf			; scroll and move walls a bit 
e0bf			 
e0bf .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
e0f0			 
e0f0			; main game loop 
e0f0			 
e0f0 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
e11c .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
e15b			 
e15b			; key board defs 
e15b			 
e15b .. 00		keyup:       db ": keyup $05 ;",0 
e169 .. 00		keydown:       db ": keydown $0a ;",0 
e179 .. 00		keyleft:       db ": keyleft $0b ;",0 
e189 .. 00		keyright:       db ": keyright $0c ;",0 
e19a .. 00		keyf1:       db ": keyf1 $10 ;",0 
e1a8 .. 00		keyf2:       db ": keyf2 $11 ;",0 
e1b6 .. 00		keyf3:       db ": keyf3 $12 ;",0 
e1c4 .. 00		keyf4:       db ": keyf4 $13 ;",0 
e1d2 .. 00		keyf5:       db ": keyf5 $14 ;",0 
e1e0 .. 00		keyf6:       db ": keyf6 $15 ;",0 
e1ee .. 00		keyf7:       db ": keyf7 $16 ;",0 
e1fc .. 00		keyf8:       db ": keyf8 $17 ;",0 
e20a .. 00		keyf9:       db ": keyf9 $18 ;",0 
e218 .. 00		keyf10:       db ": keyf10 $19 ;",0 
e227 .. 00		keyf11:       db ": keyf11 $1a ;",0 
e236 .. 00		keyf12:       db ": keyf12 $1b ;",0 
e245			 
e245 .. 00		keytab:       db ": keytab $09 ;",0 
e254 .. 00		keycr:       db ": keycr $0d ;",0 
e262 .. 00		keyhome:       db ": keyhome $0e ;",0 
e272 .. 00		keyend:       db ": keyend $0f ;",0 
e281 .. 00		keybs:       db ": keybs $08 ;",0 
e28f			 
e28f			   
e28f			 
e28f			 
e28f			 
e28f			; eof 
# End of file forth_autostart.asm
e28f			 
e28f			 
e28f			 
e28f			; stack over and underflow checks 
e28f			 
e28f			; init the words to detect the under/overflow 
e28f			 
e28f			chk_stk_init: 
e28f				; a vague random number to check so we dont get any "lucky" hits 
e28f 3e 2d			ld a, 45 
e291 6f				ld l, a 
e292 00				nop 
e293 3e 17			ld a, 23 
e295 67				ld h, a 
e296			 
e296 22 9d e2			ld (chk_word), hl     ; the word we need to check against 
e299			 
e299			;	ld (chk_stund), hl	; stack points.... 
e299 22 00 ef			ld (chk_stovr), hl 
e29c 22 ec e9			ld (chk_ret_und), hl 
e29f 22 aa e9			ld (chk_ret_ovr), hl 
e2a2 22 28 e9			ld (chk_loop_ovr), hl 
e2a5 22 26 e8			ld (chk_data_ovr), hl 
e2a8 c9				ret 
e2a9				 
e2a9			check_stacks: 
e2a9				; check all stack words 
e2a9			 
e2a9 e5				push hl 
e2aa d5				push de 
e2ab			 
e2ab			;	ld de,(chk_word) 
e2ab			;	ld hl, (chk_stund)	; stack points.... 
e2ab			;	if DEBUG_STK_FAULT 
e2ab			;		DMARK "FAa" 
e2ab			;		CALLMONITOR 
e2ab			;	endif 
e2ab			;	call cmp16 
e2ab			;	jp z, .chk_faulta 
e2ab			; 
e2ab			;	ld de, sfaultsu 
e2ab			;	jp .chk_fault 
e2ab			 
e2ab 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
e2ae ed 5b 9d e2		ld de,(chk_word) 
e2b2				if DEBUG_STK_FAULT 
e2b2					DMARK "FAb" 
e2b2					CALLMONITOR 
e2b2				endif 
e2b2 cd f9 8c			call cmp16 
e2b5 28 06			jr z, .chk_fault1 
e2b7 11 58 e3			ld de, sfaultso 
e2ba c3 0c e3			jp .chk_fault 
e2bd			.chk_fault1:  
e2bd 2a ec e9			ld hl, (chk_ret_und) 
e2c0 ed 5b 9d e2		ld de,(chk_word) 
e2c4				if DEBUG_STK_FAULT 
e2c4					DMARK "FAU" 
e2c4					CALLMONITOR 
e2c4				endif 
e2c4 cd f9 8c			call cmp16 
e2c7 ca d0 e2			jp z, .chk_fault2 
e2ca 11 68 e3			ld de, sfaultru 
e2cd c3 0c e3			jp .chk_fault 
e2d0			.chk_fault2:  
e2d0 2a aa e9			ld hl, (chk_ret_ovr) 
e2d3 ed 5b 9d e2		ld de,(chk_word) 
e2d7				if DEBUG_STK_FAULT 
e2d7					DMARK "FA1" 
e2d7					CALLMONITOR 
e2d7				endif 
e2d7 cd f9 8c			call cmp16 
e2da ca e3 e2			jp z, .chk_fault3 
e2dd 11 76 e3			ld de, sfaultro 
e2e0 c3 0c e3			jp .chk_fault 
e2e3			.chk_fault3:  
e2e3 2a 28 e9			ld hl, (chk_loop_ovr) 
e2e6 ed 5b 9d e2		ld de,(chk_word) 
e2ea				if DEBUG_STK_FAULT 
e2ea					DMARK "FA2" 
e2ea					CALLMONITOR 
e2ea				endif 
e2ea cd f9 8c			call cmp16 
e2ed ca f6 e2			jp z, .chk_fault4 
e2f0 11 90 e3			ld de, sfaultlo 
e2f3 c3 0c e3			jp .chk_fault 
e2f6			.chk_fault4:  
e2f6 2a 26 e8			ld hl, (chk_data_ovr) 
e2f9 ed 5b 9d e2		ld de,(chk_word) 
e2fd				if DEBUG_STK_FAULT 
e2fd					DMARK "FA3" 
e2fd					CALLMONITOR 
e2fd				endif 
e2fd cd f9 8c			call cmp16 
e300 ca 09 e3			jp z, .chk_fault5 
e303 11 aa e3			ld de, sfaultdo 
e306 c3 0c e3			jp .chk_fault 
e309			 
e309			 
e309			.chk_fault5:  
e309 d1				pop de 
e30a e1				pop hl 
e30b			 
e30b c9				ret 
e30c			 
e30c cd ae 8a		.chk_fault: 	call clear_display 
e30f 3e 28				ld a, display_row_2 
e311 cd c1 8a				call str_at_display 
e314 11 3a e3				   ld de, .stackfault 
e317 3e 00				ld a, display_row_1 
e319 cd c1 8a				call str_at_display 
e31c 11 6b ee				    ld de, debug_mark 
e31f 3e 11				ld a, display_row_1+17 
e321 cd c1 8a				call str_at_display 
e324 cd d1 8a				call update_display 
e327			 
e327				; prompt before entering montior for investigating issue 
e327			 
e327 3e 78			ld a, display_row_4 
e329 11 98 99			ld de, endprog 
e32c			 
e32c cd d1 8a			call update_display		 
e32f			 
e32f cd 1e 9c			call next_page_prompt 
e332			 
e332 d1				pop de 
e333 e1				pop hl 
e334 cd ec 99				call monitor 
e337 c3 f5 98				jp warmstart 
e33a					;jp 0 
e33a					;halt 
e33a			 
e33a			 
e33a			 
e33a .. 00		.stackfault: 	db "Stack fault:",0 
e347			 
e347 .. 00		sfaultsu: 	db	"Stack under flow",0 
e358 .. 00		sfaultso: 	db	"Stack over flow",0 
e368 .. 00		sfaultru:	db "RTS underflow",0 
e376 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
e390 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
e3aa .. 00		sfaultdo:	db "DTS overflow", 0 
e3b7			 
e3b7			 
e3b7			fault_dsp_under: 
e3b7 11 c9 e3			ld de, .dsp_under 
e3ba c3 79 e4			jp .show_fault 
e3bd			 
e3bd			fault_rsp_under: 
e3bd 11 d7 e3			ld de, .rsp_under 
e3c0 c3 79 e4			jp .show_fault 
e3c3			fault_loop_under: 
e3c3 11 e5 e3			ld de, .loop_under 
e3c6 c3 79 e4			jp .show_fault 
e3c9			 
e3c9 .. 00		.dsp_under: db "DSP Underflow",0 
e3d7 .. 00		.rsp_under: db "RSP Underflow",0 
e3e5 .. 00		.loop_under: db "LOOP Underflow",0 
e3f4			 
e3f4			 
e3f4 d5			type_faultn: 	push de 
e3f5 e5					push hl 
e3f6 cd ae 8a				call clear_display 
e3f9 11 20 e4				   ld de, .typefaultn 
e3fc 3e 00				ld a, display_row_1 
e3fe cd c1 8a				call str_at_display 
e401 11 6b ee				    ld de, debug_mark 
e404 3e 11				ld a, display_row_1+17 
e406 cd c1 8a				call str_at_display 
e409 cd d1 8a				call update_display 
e40c			 
e40c				; prompt before entering montior for investigating issue 
e40c			 
e40c 3e 78			ld a, display_row_4 
e40e 11 98 99			ld de, endprog 
e411			 
e411 cd d1 8a			call update_display		 
e414			 
e414 cd 1e 9c			call next_page_prompt 
e417			 
e417 e5					push hl 
e418 d5					push de 
e419 cd ec 99				call monitor 
e41c c3 f5 98				jp warmstart 
e41f 76					halt 
e420			 
e420			 
e420 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
e437			 
e437 d5			type_faults: 	push de 
e438 e5					push hl 
e439 cd ae 8a				call clear_display 
e43c 11 62 e4				   ld de, .typefaults 
e43f 3e 00				ld a, display_row_1 
e441 cd c1 8a				call str_at_display 
e444 11 6b ee				    ld de, debug_mark 
e447 3e 11				ld a, display_row_1+17 
e449 cd c1 8a				call str_at_display 
e44c cd d1 8a				call update_display 
e44f			 
e44f				; prompt before entering montior for investigating issue 
e44f			 
e44f 3e 78			ld a, display_row_4 
e451 11 98 99			ld de, endprog 
e454			 
e454 cd d1 8a			call update_display		 
e457			 
e457 cd 1e 9c			call next_page_prompt 
e45a			 
e45a e1					pop hl 
e45b d1					pop de 
e45c cd ec 99				call monitor 
e45f c3 f5 98				jp warmstart 
e462			 
e462			 
e462 .. 00		.typefaults: db "STR Type Expected TOS!",0 
e479			 
e479			.show_fault: 	 
e479 d5					push de 
e47a cd ae 8a				call clear_display 
e47d d1					pop de 
e47e 3e 00				ld a, display_row_1 
e480 cd c1 8a				call str_at_display 
e483 11 6b ee				    ld de, debug_mark 
e486 3e 11				ld a, display_row_1+17 
e488 cd c1 8a				call str_at_display 
e48b cd d1 8a				call update_display 
e48e			 
e48e				; prompt before entering montior for investigating issue 
e48e			 
e48e 3e 78			ld a, display_row_4 
e490 11 98 99			ld de, endprog 
e493			 
e493 cd d1 8a			call update_display		 
e496			 
e496 cd 1e 9c			call next_page_prompt 
e499			 
e499 e1					pop hl 
e49a d1					pop de 
e49b cd ec 99				call monitor 
e49e			; do a dump to cli and not warmstart so we preserve all of the uwords.  
e49e			; TODO Make optional fault restart to cli or warm boot? 
e49e					;jp warmstart 
e49e c3 3f 99				jp cli 
e4a1 76					halt 
e4a2			 
e4a2			; handle the auto run of code from files in storage 
e4a2			 
e4a2			 
e4a2			include "forth_startup.asm" 
e4a2			; Which startup method to use? 
e4a2			; 
e4a2			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
e4a2			; followed by loading of a list of scripts in eeprom 
e4a2			 
e4a2			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
e4a2			; from eeprom 
e4a2			 
e4a2			; Select with define in main stubs 
e4a2			 
e4a2			if STARTUP_V1 
e4a2				include "forth_startupv1.asm" 
e4a2			; Startup script loading version 1 
e4a2			 
e4a2			; If SE storage is available first stage is to use the selected file 
e4a2			; then go through the eeprom list 
e4a2			 
e4a2 .. 00		sprompt1: db "Startup load...",0 
e4b2 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
e4c8			 
e4c8			 
e4c8			 
e4c8			 
e4c8			forth_startup: 
e4c8 21 19 cf			ld hl, startcmds 
e4cb 3e 00			ld a, 0 
e4cd 32 e7 e6			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
e4d0			 
e4d0 e5			.start1:	push hl 
e4d1 cd ae 8a			call clear_display 
e4d4 11 a2 e4			ld de, sprompt1 
e4d7 3e 00		        ld a, display_row_1 
e4d9 cd c1 8a			call str_at_display 
e4dc 11 b2 e4			ld de, sprompt2 
e4df 3e 28		        ld a, display_row_2 
e4e1 cd c1 8a			call str_at_display 
e4e4 e1				pop hl 
e4e5 e5				push hl 
e4e6 5e				ld e,(hl) 
e4e7 23				inc hl 
e4e8 56				ld d,(hl) 
e4e9 3e 50		        ld a, display_row_3 
e4eb cd c1 8a			call str_at_display 
e4ee cd d1 8a			call update_display 
e4f1			 
e4f1			 
e4f1 3a e7 e6			ld a, (os_last_cmd) 
e4f4 fe 00			cp 0 
e4f6 28 05			jr z, .startprompt 
e4f8 cd e5 89			call delay250ms 
e4fb 18 24			jr .startdo 
e4fd				 
e4fd				 
e4fd			 
e4fd			.startprompt: 
e4fd			 
e4fd 3e 9f			ld a,display_row_4 + display_cols - 1 
e4ff 11 1c 9c		        ld de, endprg 
e502 cd c1 8a			call str_at_display 
e505 cd d1 8a			call update_display 
e508 cd f1 89			call delay1s 
e50b cd 2e e6			call cin_wait 
e50e						 
e50e fe 2a			cp '*' 
e510 28 5e			jr z, .startupend1 
e512 fe 23			cp '#' 
e514 20 07			jr nz, .startno 
e516 3e 01			ld a, 1 
e518 32 e7 e6			ld (os_last_cmd),a 
e51b 18 04			jr .startdo 
e51d fe 31		.startno:	cp '1' 
e51f 28 3a			jr z,.startnxt  
e521			 
e521				; exec startup line 
e521			.startdo:	 
e521 e1				pop hl 
e522 e5				push hl 
e523				 
e523 5e				ld e,(hl) 
e524 23				inc hl 
e525 56				ld d,(hl) 
e526 eb				ex de,hl 
e527			 
e527 e5				push hl 
e528			 
e528 3e 00			ld a, 0 
e52a				;ld a, FORTH_END_BUFFER 
e52a cd a3 92			call strlent 
e52d 23				inc hl   ; include zero term to copy 
e52e 06 00			ld b,0 
e530 4d				ld c,l 
e531 e1				pop hl 
e532 11 c1 e2			ld de, scratch 
e535 ed b0			ldir 
e537			 
e537			 
e537 21 c1 e2			ld hl, scratch 
e53a cd a1 a0			call forthparse 
e53d cd e1 a0			call forthexec 
e540 cd f3 9f			call forthexec_cleanup 
e543			 
e543 3e 78			ld a, display_row_4 
e545 11 98 99			ld de, endprog 
e548			 
e548 cd d1 8a			call update_display		 
e54b			 
e54b 3a e7 e6			ld a, (os_last_cmd) 
e54e fe 00			cp 0 
e550 20 09			jr nz, .startnxt 
e552 cd 1e 9c			call next_page_prompt 
e555 cd ae 8a		        call clear_display 
e558 cd d1 8a			call update_display		 
e55b			 
e55b				; move onto next startup line? 
e55b			.startnxt: 
e55b			 
e55b cd e5 89			call delay250ms 
e55e e1				pop hl 
e55f			 
e55f 23				inc hl 
e560 23				inc hl 
e561			 
e561 e5				push hl 
e562 5e				ld e, (hl) 
e563 23				inc hl 
e564 56				ld d, (hl) 
e565 e1				pop hl 
e566				; TODO replace 0 test 
e566			 
e566 eb				ex de, hl 
e567 cd 04 8d			call ishlzero 
e56a			;	ld a,e 
e56a			;	add d 
e56a			;	cp 0    ; any left to do? 
e56a eb				ex de, hl 
e56b c2 d0 e4			jp nz, .start1 
e56e 18 01			jr .startupend 
e570			 
e570 e1			.startupend1: pop hl 
e571			.startupend: 
e571			 
e571 cd ae 8a			call clear_display 
e574 cd d1 8a			call update_display 
e577 c9				ret 
e578			if STORAGE_SE 
e578			 
e578			sprompt3: db "Loading from start-up file?:",0 
e578			sprompt4: db "(Y=Any key/N=No)",0 
e578			 
e578			 
e578			forth_autoload: 
e578			 
e578				; load block 0 of store 1 
e578				 
e578				ld a, $fe      ; bit 0 clear 
e578				ld (spi_device), a 
e578			 
e578				call storage_get_block_0 
e578			 
e578				ld a, (store_page+STORE_0_AUTOFILE) 
e578			 
e578				cp 0 
e578				ret z     ; auto start not enabled 
e578			 
e578				call clear_display 
e578			 
e578				; set bank 
e578			 
e578					ld a, (store_page+STORE_0_BANKRUN) 
e578					ld (spi_device), a 
e578			 
e578				; get file id to load from and get the file name to display 
e578			 
e578					ld a, (store_page+STORE_0_FILERUN) 
e578			 
e578					ld l, 0 
e578					ld h, a 
e578					ld de, store_page 
e578			 
e578					if DEBUG_FORTH_WORDS 
e578						DMARK "ASp" 
e578						CALLMONITOR 
e578					endif 
e578					call storage_read 
e578			 
e578					if DEBUG_FORTH_WORDS 
e578						DMARK "ASr" 
e578						CALLMONITOR 
e578					endif 
e578			 
e578					call ishlzero 
e578					ret z             ; file not found 
e578			 
e578					ld a, display_row_2 + 10 
e578					ld de, store_page+3 
e578					call str_at_display 
e578				 
e578			; 
e578			 
e578				ld a, display_row_1+5 
e578				ld de, sprompt3 
e578				call str_at_display 
e578				ld a, display_row_3+15 
e578				ld de, sprompt4 
e578				call str_at_display 
e578			 
e578				call update_display 
e578			 
e578				call cin_wait 
e578				cp 'n' 
e578				ret z 
e578				cp 'N' 
e578				ret z 
e578			 
e578				call delay1s 
e578			 
e578				ld a, (store_page+2) 
e578				ld (store_openmaxext), a    ; save count of ext 
e578				ld a, 1  
e578				ld (store_openext), a    ; save count of ext 
e578			 
e578			.autof:  
e578				ld l , a 
e578				 
e578				ld a, (store_page) 
e578				ld h, a	 
e578				ld de, store_page 
e578					if DEBUG_FORTH_WORDS 
e578						DMARK "ASl" 
e578						CALLMONITOR 
e578					endif 
e578					call storage_read 
e578				call ishlzero 
e578				ret z 
e578			;	jr z, .autoend 
e578			 
e578					if DEBUG_FORTH_WORDS 
e578						DMARK "ASc" 
e578						CALLMONITOR 
e578					endif 
e578				ld de, store_page+2 
e578				ld a, display_row_4 
e578				call str_at_display 
e578			 
e578				call update_display 
e578				call delay250ms 
e578			 
e578			 
e578			 
e578				ld hl, store_page+2 
e578				call forthparse 
e578				call forthexec 
e578				call forthexec_cleanup 
e578			 
e578				 
e578				ld a, (store_openext) 
e578				inc a 
e578				ld (store_openext), a    ; save count of ext 
e578			 
e578				jr .autof 
e578			;.autofdone: 
e578			; 
e578			;		if DEBUG_FORTH_WORDS 
e578			;			DMARK "ASx" 
e578			;			CALLMONITOR 
e578			;		endif 
e578			;;	call clear_display 
e578			;	ret 
e578			 
e578			 
e578			 
e578			endif 
# End of file forth_startupv1.asm
e578			endif 
e578			if STARTUP_V2 
e578				include "forth_startupv2.asm" 
e578			endif 
e578			 
# End of file forth_startup.asm
e578			 
e578			; eof 
# End of file forth_kernel.asm
e578			;include "nascombasic.asm" 
e578			 
e578			 
e578			; find out where the code ends if loaded into RAM (for SC114) 
e578			;endofcode:  
e578			;	nop 
e578			 
e578			 
e578			; jump to nmi vector 
e578			 
e578			init_nmi: 
e578 3e c9			ld a, $c9   ; RET 
e57a 32 72 ee			ld (nmi_vector), a 
e57d c9				ret 
e57e			nmi: 
e57e e5				push hl 
e57f d5				push de 
e580 c5				push bc 
e581 f5				push af 
e582 cd 72 ee			call nmi_vector 
e585 f5				push af 
e586 c5				push bc 
e587 d5				push de 
e588 e5				push hl 
e589 ed 4d			reti 
e58b			 
e58b			 
e58b			; eof 
e58b			 
# End of file main.asm
e58b			;include "firmware_lcd_4x40.asm" 
e58b			;;include "firmware_lcd_4x20.asm" 
e58b			include "firmware_serial_display.asm" 
e58b			 
e58b			; Serial display interface for SC114 
e58b			 
e58b			 
e58b			display_row_1: equ 0 
e58b			display_row_2: equ display_row_1+display_cols 
e58b			display_row_3: equ display_row_2 + display_cols 
e58b			display_row_4: equ display_row_3 + display_cols 
e58b			 
e58b			kLCDWidth:  EQU display_cols             ;Width in characters 
e58b			kLCD_Line1: EQU 0x00  
e58b			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
e58b			; E1 
e58b			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
e58b			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
e58b			 
e58b			lcd_init: 
e58b				; no init as handled by the SCM bios 
e58b c9				ret 
e58c			 
e58c			 
e58c			; low level functions for direct screen writes 
e58c			 
e58c			; output char at pos? 
e58c			fLCD_Str: 
e58c			        ;out (SC114_SIO_1_OUT),a 
e58c c5				push bc 
e58d 0e 02			ld c, $02 
e58f f7				rst $30 
e590 c1				pop bc 
e591 c9				ret 
e592			 
e592			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
e592			fLCD_Pos: 
e592				; use ASCII escape to position 
e592			        ;out (SC114_SIO_1_OUT),a 
e592 c5				push bc 
e593 0e 02			ld c, $02 
e595 f7				rst $30 
e596 c1				pop bc 
e597			 
e597 c9				ret 
e598			 
e598			; output char at pos 
e598			fLCD_Data: 
e598			      ;  out (SC114_SIO_1_OUT),a 
e598 c5				push bc 
e599 0e 02			ld c, $02 
e59b f7				rst $30 
e59c c1				pop bc 
e59d			 
e59d c9				ret 
e59e			 
e59e			; ascii cls  
e59e			 
e59e 1b 5b 48 00	.cls:   db 27, '[', 'H', 0 
e5a2			 
e5a2			; write the frame buffer given in hl to hardware  
e5a2			write_display: 
e5a2			 
e5a2			API: equ 0 
e5a2			 
e5a2			if API 
e5a2				push bc 
e5a2				ld b, 4 
e5a2			 
e5a2			        ld (display_write_tmp), hl 	  
e5a2			 
e5a2				; clear and home cursor 
e5a2			 
e5a2				ld c, 6 
e5a2				ld de, .cls 
e5a2				rst $30 
e5a2			 
e5a2			 
e5a2			.writeln: 
e5a2			 
e5a2				ld de, (display_write_tmp) 
e5a2				ld c, 6 
e5a2				rst $30 
e5a2				ld c, 7 
e5a2				rst $30 
e5a2			 
e5a2				ld hl, (display_write_tmp) 
e5a2				ld de, display_cols 
e5a2				add hl,de 
e5a2				ld (display_write_tmp),hl 
e5a2			 
e5a2				djnz  .writeln 
e5a2			 
e5a2				pop bc 
e5a2			 
e5a2			 
e5a2				ret 
e5a2			endif 
e5a2 e5				push hl 
e5a3 c5				push bc 
e5a4 d5				push de 
e5a5			 
e5a5			;	ld c, 2 
e5a5			;	;ld de, .cls 
e5a5			;	ld a, 27 
e5a5			;	rst $30 
e5a5			;	ld c, 2 
e5a5			;	;ld de, .cls 
e5a5			;	ld a, '[' 
e5a5			;	rst $30 
e5a5			; 
e5a5			;	ld c, 2 
e5a5			;	;ld de, .cls 
e5a5			;	ld a, 'H' 
e5a5			;	rst $30 
e5a5			; 
e5a5			 
e5a5 0e 02			ld c, 2 
e5a7				;ld de, .cls 
e5a7 3e 1b			ld a, 27 
e5a9 f7				rst $30 
e5aa			 
e5aa			 
e5aa 0e 02			ld c, 2 
e5ac				;ld de, .cls 
e5ac 3e 5b			ld a, '[' 
e5ae f7				rst $30 
e5af 0e 02			ld c, 2 
e5b1				;ld de, .cls 
e5b1 3e 32			ld a, '2' 
e5b3 f7				rst $30 
e5b4 0e 02			ld c, 2 
e5b6				;ld de, .cls 
e5b6 3e 4a			ld a, 'J' 
e5b8 f7				rst $30 
e5b9 d1				pop de 
e5ba c1				pop bc 
e5bb e1				pop hl 
e5bc			 
e5bc			 
e5bc 22 c9 eb		        ld (display_write_tmp), hl 	  
e5bf 3e 00			ld a, kLCD_Line1 
e5c1			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
e5c1 06 28			ld b, display_cols 
e5c3 ed 5b c9 eb		ld de, (display_write_tmp) 
e5c7 cd 25 e6			call write_len_string 
e5ca				 
e5ca			 
e5ca e5			push hl 
e5cb d5			push de 
e5cc c5			push bc 
e5cd 0e 07			ld c, 7 
e5cf f7				rst $30 
e5d0 c1			pop bc 
e5d1 d1			pop de 
e5d2 e1			pop hl 
e5d3			 
e5d3				 
e5d3 2a c9 eb			ld hl, (display_write_tmp) 
e5d6 11 28 00			ld de, display_cols 
e5d9 19				add hl,de 
e5da 22 c9 eb			ld (display_write_tmp),hl 
e5dd			 
e5dd				 
e5dd 3e 28			ld a, kLCD_Line2 
e5df			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
e5df 06 28			ld b, display_cols 
e5e1 ed 5b c9 eb		ld de, (display_write_tmp) 
e5e5 cd 25 e6			call write_len_string 
e5e8				 
e5e8 2a c9 eb			ld hl, (display_write_tmp) 
e5eb 11 28 00			ld de, display_cols 
e5ee 19				add hl,de 
e5ef 22 c9 eb			ld (display_write_tmp),hl 
e5f2			 
e5f2 e5			push hl 
e5f3 d5			push de 
e5f4 c5			push bc 
e5f5 0e 07			ld c, 7 
e5f7 f7				rst $30 
e5f8 c1			pop bc 
e5f9 d1			pop de 
e5fa e1			pop hl 
e5fb			 
e5fb				 
e5fb 3e 50			ld a, kLCD_Line3 
e5fd			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
e5fd 06 28			ld b, display_cols 
e5ff ed 5b c9 eb		ld de, (display_write_tmp) 
e603 cd 25 e6			call write_len_string 
e606				 
e606 2a c9 eb			ld hl, (display_write_tmp) 
e609 11 28 00			ld de, display_cols 
e60c 19				add hl,de 
e60d 22 c9 eb			ld (display_write_tmp),hl 
e610			 
e610 e5			push hl 
e611 d5			push de 
e612 c5			push bc 
e613 0e 07			ld c, 7 
e615 f7				rst $30 
e616 c1			pop bc 
e617 d1			pop de 
e618 e1			pop hl 
e619			 
e619				 
e619 3e 78			ld a, kLCD_Line4 
e61b			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
e61b 06 28			ld b, display_cols 
e61d ed 5b c9 eb		ld de, (display_write_tmp) 
e621 cd 25 e6			call write_len_string 
e624 c9					ret 
e625			 
e625			 
e625				; write out a fixed length string given in b from de 
e625			 
e625 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
e626 cd 98 e5		            CALL fLCD_Data      ;Write character to display 
e629 13				inc de 
e62a 10 f9			djnz write_len_string 
e62c c9				ret 
e62d			 
e62d			 
e62d			; eof 
# End of file firmware_serial_display.asm
e62d			;include "firmware_key_5x10.asm" 
e62d			;;include "firmware_key_4x10.asm" 
e62d			include "firmware_key_serial.asm" 
e62d			; Serial keyboard interface for SC114 
e62d			 
e62d			key_init: 
e62d				; no init as handled by the SCM bios 
e62d c9				ret 
e62e			 
e62e			 
e62e			cin_wait: 
e62e			;	ld a, 0 
e62e			;	ret 
e62e			 
e62e				;in a,(SC114_SIO_1_IN) 
e62e			        ; Use SCM API to get from whatever console device we are using 
e62e c5				push bc 
e62f 0e 01			ld c, $01 
e631 f7				rst $30 
e632 c1				pop bc 
e633 c9				ret 
e634			 
e634			cin: 
e634			 
e634			 
e634 c5				push bc 
e635			 
e635				; any key waiting to process? 
e635 0e 03			ld c, $03 
e637 f7				rst $30 
e638 28 05			jr z, .cin_skip 
e63a			 
e63a				; yep, get it 
e63a			 
e63a 0e 01			ld c, $01 
e63c f7				rst $30 
e63d c1				pop bc 
e63e c9				ret 
e63f			.cin_skip: 
e63f 3e 00			ld a, 0 
e641 c1				pop bc 
e642 c9				ret 
e643			 
e643			 
e643			 
e643			 
# End of file firmware_key_serial.asm
e643			endofcode:  
e643			baseram:  
e643 00				nop 
e644			 
e644			heap_start: equ baseram+15  ; Starting address of heap 
e644			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
e644			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
e644			;VDU:  EQU     endofcode           ; BASIC Work space 
e644			; eof 
e644			 
# End of file os_mega_sc114.asm
e644
