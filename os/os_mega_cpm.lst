# File debug_level2.asm
0000			 
0000			; DEBUG Level 2 - All useful debug on and memory courruption guards 
0000			 
0000			; Odd specific debug points for testing hardware dev 
0000			 
0000			;DEBUG_LEVEL0: equ 0 
0000			;DEBUG_LEVEL0: equ 0 
0000			;DEBUG_LEVEL2: equ 1 
0000			DEBUG_LEVEL: equ '2' 
0000			 
0000			DEBUG_SOUND: equ 0      
0000			DEBUG_STK_FAULT: equ 0 
0000			DEBUG_INPUT: equ 0     ; Debug input entry code 
0000			DEBUG_INPUTV2: equ 0     ; Debug input entry code 
0000			DEBUG_KEYCINWAIT: equ 0 
0000			DEBUG_KEYCIN: equ 0 
0000			DEBUG_KEY: equ 0 
0000			DEBUG_KEY_MATRIX: equ 0 
0000			DEBUG_STORECF: equ 0 
0000			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.  
0000			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A 
0000			DEBUG_SPI: equ 0    ; low level spi tests 
0000			 
0000			; Enable many break points 
0000			 
0000			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6 
0000			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6 
0000			DEBUG_FORTH_PARSE_NEXTWORD: equ 0 
0000			DEBUG_FORTH_JP: equ 0    ; 4 
0000			DEBUG_FORTH_MALLOC: equ 0 
0000			DEBUG_FORTH_MALLOC_INT: equ 0 
0000			DEBUG_FORTH_DOT: equ 1 
0000			DEBUG_FORTH_DOT_WAIT: equ 0 
0000			DEBUG_FORTH_MATHS: equ 0 
0000			DEBUG_FORTH_TOK: equ 0    ; 4 
0000			DEBUG_FORTH_PARSE: equ 0    ; 3 
0000			DEBUG_FORTH: equ 0  ;2 
0000			DEBUG_FORTH_WORDS: equ 1   ; 1 
0000			DEBUG_FORTH_PUSH: equ 1   ; 1 
0000			DEBUG_FORTH_UWORD: equ 1   ; 1 
0000			 
0000			; Enable key point breakpoints 
0000			 
0000			DEBUG_FORTH_DOT_KEY: equ 0 
0000			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5 
0000			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1 
0000			 
0000			; Debug stack imbalances 
0000			 
0000			ON: equ 1 
0000			OFF: equ 0 
0000			 
0000			DEBUG_STACK_IMB: equ 0 
0000			STACK_IMB_STORE: equ 20 
0000			 
0000			; House keeping and protections 
0000			 
0000			DEBUG_FORTH_STACK_GUARD: equ 1    ; under/over flows 
0000			DEBUG_FORTH_MALLOC_GUARD: equ 1 
0000			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual! 
0000			FORTH_ENABLE_FREE: equ 0 
0000			FORTH_ENABLE_MALLOCFREE: equ 1 
0000			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away 
0000			FORTH_ENABLE_FLOATMATH: equ 0 
0000			; eof 
# End of file debug_level2.asm
# File os_mega_cpm.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 1 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 1 
0000			STARTUP_V2: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; Use this to tune the delay functions if your CPU is a bit quick. i.e. RunCPM on a PC 
0000			 
0000			CPM_DELAY_TUNE: equ 4000 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0100			endif 
0100 c3 c4 16			jp coldstart     ; rst 0 - cold boot 
0103			 
0103			 
0103 ..			buildtime: db   "Build: " 
010a					include "romtimestamp.asm" 
010a ..			db '2025-09-19 10:42' 
# End of file romtimestamp.asm
011a 00				   db 0 
011b .. 32 00		debuglevel: db   "DL",DEBUG_LEVEL, 0 
011f			 
011f			 
011f			 
011f			;        nop  
011f			;        nop 
011f			;;	org 05h		; null out bdos call 
011f			; 
011f			;        nop  
011f			;        nop  
011f			;        nop 
011f			;;	org 08h 
011f			;;; 
011f			;;	jp cin		; rst 8 - char in 
011f			;;; 
011f			; 
011f			;        nop 
011f			;        nop 
011f			;        nop 
011f			;        nop 
011f			;        nop 
011f			;        nop 
011f			;        nop 
011f			;        nop 
011f			;	org 010h 
011f			;; 
011f			;	jp cout		; rest 010h  - char out 
011f			;; 
011f			;	org 01bh   
011f			; 
011f			;	;jp  		; rst 01bh   - write string to display 
011f			;	jp str_at_display 
011f			; 
011f			; 
011f			;	org 020h 
011f			; 
011f			;	; jp		 ; rst 020h - read char at screen location 
011f			; 
011f			;	org 028h 
011f			 
011f				; jp		 ; rst 028h  - storage i/o 
011f			 
011f			; 	org 030h 
011f			;	jp break_point_state 
011f			  
011f			; $30  
011f			; org 038h 
011f			; $38 
011f			 
011f			; TODO any more important entry points to add to jump table for easier coding use? 
011f			 
011f			if BASE_KEV = 1  
011f			 
011f				; need to be at $66 for nmi support 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255 
011f				jp nmi 
011f			endif 
011f			 
011f			include "firmware.asm" 
011f			  
011f			; main constants (used here and in firmware)  
011f			  
011f			; TODO have page 0 of storage as bios  
011f			  
011f			Device_A: equ 0h  
011f			Device_B: equ 040h          ; Sound  
011f			  
011f			if BASE_KEV  
011f			Device_C: equ 080h          ; Storage and ext cart devices  
011f			endif  
011f			  
011f			if BASE_SC114  
011f			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
011f			endif  
011f			  
011f			if BASE_CPM  
011f			; TODO fixup for CPM  
011f			Device_C: equ 080h          ; Storage and ext cart devices  
011f			endif  
011f			  
011f			Device_D: equ 0c0h             ; Keyboard and LCD  
011f			  
011f			; Odd specific debug points for testing hardware dev  
011f			  
011f			;if DEBUG_LEVEL0  
011f			;	include "debug_level0.asm"  
011f			;endif  
011f			;if DEBUG_LEVEL1  
011f			;	include "debug_level1.asm"  
011f			;endif  
011f			;if DEBUG_LEVEL2  
011f			;	include "debug_level2.asm"  
011f			;endif  
011f			  
011f			  
011f			CALLMONITOR: macro  
011f			;	call break_point_state  
011f			; now use the break point debug vector  
011f				call debug_vector  
011f				endm  
011f			  
011f			MALLOC_1: equ 1        ; from dk88   
011f			MALLOC_2: equ 0           ; broke  
011f			MALLOC_3: equ 0           ; really broke  
011f			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
011f			  
011f			if BASE_KEV   
011f			;stacksize: equ 256  
011f			; each stack entry is three bytes (type + word)  
011f			stacksize: equ 3*150  
011f			  
011f			STACK_RET_SIZE: equ 64  
011f			STACK_LOOP_SIZE: equ 128  
011f			STACK_DATA_SIZE: equ 512  
011f			endif  
011f			if BASE_SC114  
011f			;tos:	equ 0f000h  
011f			stacksize: equ 256  
011f			STACK_RET_SIZE: equ 64  
011f			STACK_LOOP_SIZE: equ 128  
011f			STACK_DATA_SIZE: equ 256  
011f			endif  
011f			  
011f			if BASE_CPM  
011f			;tos:	equ 0f000h  
011f			stacksize: equ 256  
011f			STACK_RET_SIZE: equ 64  
011f			STACK_LOOP_SIZE: equ 128  
011f			STACK_DATA_SIZE: equ 256  
011f			endif  
011f			  
011f			;if STORAGE_SE == 0  
011f			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
011f			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
011f			;endif  
011f			  
011f			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
011f			  
011f			STORE_0_AUTORUN: equ $20  
011f			  
011f			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
011f			  
011f			STORE_0_AUTOFILE: equ $21  
011f			STORE_0_BANKRUN: equ $23  
011f			STORE_0_FILERUN: equ $24  
011f			STORE_0_BANKRUNN: equ $25   ; human readable bank id  
011f			  
011f			; Block 0 offsets for settings  
011f			  
011f			; if set then skip prompt for start up and accept all  
011f			  
011f			STORE_0_QUICKSTART: equ $25  
011f			  
011f			; Blocks where directory table is held  
011f			  
011f			; Reducing the number of entries increases the max file size  
011f			  
011f			;STORE_DIR_START: equ 1  
011f			;STORE_DIR_END: equ 33  
011f			  
011f			; Blocks from where file data is stored  
011f			  
011f			;STORE_DATA_START: equ STORE_DIR_END + 1  
011f			  
011f			; Block indicators (<32 are data files)  
011f			  
011f			;STORE_BLOCK_CFG: equ $8f       ; config block  
011f			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
011f			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
011f			;STORE_BLOCK_FREE: equ $85       ; data block free  
011f			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
011f			  
011f			  
011f			  
011f			; Directory entry flags  
011f			  
011f			;STORE_DIR_FREE: equ 0  
011f			;STORE_DIR_FILE:  equ 1  
011f			  
011f			; Structure offsets to directory entries  
011f			;STORE_DE_FLAG: equ 0  
011f			;STORE_DE_MAXEXT: equ 1  
011f			;STORE_DE_FILENAME: equ 2  
011f			  
011f			; Structure offsets to block 0  
011f			  
011f			;STORE_BK0_ISFOR: equ 1  
011f			;STORE_BK0_LABEL: equ 3  
011f			  
011f			; memory allocation   
011f			  
011f			chk_stund: equ tos+2           ; underflow check word  
011f			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
011f			  
011f			; keyscan table needs rows x cols buffer  
011f			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
011f			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
011f			  
011f			key_macroroot:  equ chk_stovr - 2       ; root ptr for start of keyboard macro strings  
011f			key_macrolast:  equ key_macroroot - 2   ; last macro defined to aid linked list ptr  
011f			;  
011f			; Macro linked list format  
011f			; key code single byte   
011f			; ptr to next or zero if last in the list  
011f			; zero term string   
011f			  
011f			;keyscan_table_row1: equ chk_stovr -key_cols-1  
011f			keyscan_table_row1: equ key_macrolast -key_cols-1  
011f			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
011f			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
011f			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
011f			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
011f			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
011f			keyscan_scancol: equ keyscan_table-key_cols  
011f			;keyscan_table_len: equ key_rows*key_cols  
011f			;keybufptr: equ keyscan_table - 2  
011f			;keysymbol: equ keybufptr - 1  
011f			key_held: equ keyscan_scancol-1	; currently held  
011f			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
011f			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
011f			key_fa: equ key_repeat_ct -1 ;  
011f			key_fb: equ key_fa -1 ;  
011f			key_fc: equ key_fb -1 ;  
011f			key_fd: equ key_fc -1 ;  
011f			key_face_held: equ key_fd - 1   
011f			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
011f			  
011f			hardware_config: equ key_face_held - 10  
011f			  
011f			; hardware config switches  
011f			; TODO add bitmasks on includes for hardware  
011f			; high byte for expansion ids  
011f			;     0000 0000  no card inserted  
011f			;     0000 0001  storage card inserted  
011f			;     0000 0010  spi sd card active  
011f			  
011f			;       
011f			; low byte:  
011f			;     0000 0001   4x4 keypad  
011f			;     0000 0010   full keyboard  
011f			;     0000 0011   spi/ext keyboard  
011f			;     0000 0100   20x4 lcd  
011f			;     0000 1000   40x4 lcd  
011f			;     0000 1100   spi/ext display  
011f			;     0001 0000   ide interface available  
011f			  
011f			hardware_word: equ hardware_config - 2  
011f			  
011f			; debug marker - optional display of debug point on the debug screens  
011f			  
011f			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
011f			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
011f			parse_vector:  equ debug_vector - 3 ; vector to the parser vector  
011f			  
011f			debug_umark: equ parse_vector - 6  ; current user mark  
011f			debug_mark: equ debug_umark - 4    ; internal word debug points  
011f			  
011f			; input_str vars  
011f			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
011f			input_start:  equ input_ptr - 2    ; ptr to the start of string   
011f			input_size: equ input_start -1  ; number of chars  
011f			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
011f			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
011f			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
011f			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
011f			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
011f			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
011f			input_len: equ input_cur_onoff - 5 ; length of current input  
011f			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
011f			  
011f			; cursor blink rate  
011f			CUR_BLINK_RATE: equ $09  
011f			;CUR_BLINK_RATE: equ 15  
011f			  
011f			key_actual_pressed: equ input_cursor - 1   
011f			key_symbol: equ key_actual_pressed - 1   
011f			key_shift: equ key_symbol - 1   
011f			  
011f			; Display allocation  
011f			  
011f			;display_rows: equ 4     ; move out to mini and mega files  
011f			;display_cols: equ 20  
011f			  
011f			display_fb_len: equ display_rows*display_cols  
011f			  
011f			; primary frame buffer     
011f			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
011f			; working frame buffers  
011f			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
011f			display_fb3: equ  display_fb1-display_fb_len - 1  
011f			display_fb2: equ  display_fb3-display_fb_len - 1  
011f			;  
011f			; pointer to active frame buffer  
011f			display_fb_active: equ display_fb2 - 2  
011f			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
011f			display_write_tmp: equ display_lcde1e2 - 2  
011f			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
011f			  
011f			;  
011f			  
011f			;; can load into de directory  
011f			cursor_col: equ display_active-1  
011f			cursor_row: equ cursor_col-1  
011f			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
011f			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
011f			  
011f			; maths vars  
011f			  
011f			LFSRSeed: equ cursor_shape -20   
011f			randData: equ LFSRSeed - 2  
011f			xrandc: equ randData - 2  
011f			stackstore: equ xrandc - 2  
011f			seed1: equ  stackstore -2   
011f			seed2: equ seed1 - 2  
011f			  
011f			; cf storage vars  
011f			  
011f			iErrorNum:  equ seed2-1         ;Error number  
011f			iErrorReg:  equ iErrorNum -1              ;Error register  
011f			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
011f			  
011f			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
011f			  
011f			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
011f			  
011f			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
011f			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
011f			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
011f			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
011f			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
011f			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
011f			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
011f			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
011f			store_tmpid: equ store_tmp3 - 1		; page temp id  
011f			store_tmpext: equ store_tmpid - 1		; file extent temp  
011f			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
011f			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
011f			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
011f			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
011f			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
011f			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
011f			;  
011f			; spi vars  
011f			  
011f			  
011f			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
011f			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
011f			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
011f			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
011f			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
011f			spi_device_id: equ spi_device - 1    ; human readable bank number  
011f			  
011f			;;;;; forth cli params  
011f			  
011f			; TODO use a different frame buffer for forth???  
011f			  
011f			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
011f			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
011f			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
011f			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
011f			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
011f			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
011f			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
011f			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
011f			  
011f			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
011f			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
011f			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
011f			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
011f			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
011f			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
011f			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
011f			  
011f			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
011f			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011f			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
011f			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011f			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
011f			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
011f			chk_data_ovr: equ cli_data_stack -2; overflow check word  
011f			  
011f			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
011f			  
011f			; os/forth token vars  
011f			  
011f			os_last_cmd: equ os_var_array-255  
011f			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
011f			os_current_i: equ os_cli_cmd-2  
011f			os_cur_ptr: equ os_current_i-2  
011f			os_word_scratch: equ os_cur_ptr-30  
011f			os_tok_len: equ os_word_scratch - 2  
011f			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
011f			os_tok_malloc: equ os_tok_ptr - 2  
011f			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
011f			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
011f			execscratch: equ os_input-255        ; exec cmd eval buffer  
011f			scratch: equ execscratch-255  
011f			  
011f			os_stack_1: equ scratch - 3       ; stack holding area 1  
011f			os_stack_2: equ os_stack_1 - 3       ; stack holding area 2  
011f			os_stack_3: equ os_stack_2 - 3       ; stack holding area 3  
011f			os_stack_4: equ os_stack_3 - 3       ; stack holding area 4  
011f			  
011f			  
011f			; temp locations for new word processing to save on adding more   
011f			  
011f			os_new_malloc: equ os_stack_4-2  
011f			os_new_parse_len: equ os_new_malloc - 2  
011f			os_new_word_len: equ os_new_parse_len - 2  
011f			os_new_work_ptr: equ os_new_word_len - 2  
011f			os_new_src_ptr: equ os_new_work_ptr - 2  
011f			os_new_exec: equ os_new_src_ptr - 2  
011f			os_new_exec_ptr: equ os_new_exec - 2  
011f			  
011f			; resume memory alloocations....  
011f			  
011f			;os_view_disable: equ os_new_exec_ptr - 1  
011f			os_view_af: equ os_new_exec_ptr - 2  
011f			os_view_hl: equ os_view_af -2  
011f			os_view_de: equ os_view_hl - 2  
011f			os_view_bc: equ os_view_de - 2  
011f			  
011f			; stack checksum word  
011f			if DEBUG_STACK_IMB  
011f				curframe: equ  os_view_de - 5  
011f				store_sp: equ curframe - (STACK_IMB_STORE*4)  
011f				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011f			else  
011f				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011f			endif  
011f			  
011f			; with data stack could see memory filled with junk. need some memory management   
011f			; malloc and free entry points added  
011f			  
011f			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
011f			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
011f			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
011f			;heap_end: equ free_list-1  ; Starting address of heap  
011f			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011f			  
011f			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011f			heap_end: equ chk_word-1  ; Starting address of heap  
011f			  
011f			  
011f			;if BASE_KEV   
011f			;heap_start: equ 0800eh  ; Starting address of heap  
011f			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
011f			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
011f			;endif  
011f			  
011f			;if BASE_SC114  
011f			;heap_start: equ baseram+15  ; Starting address of heap  
011f			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
011f			;endif  
011f			  
011f			  
011f			;;;;  
011f			  
011f			  
011f			; change below to point to last memory alloc above  
011f			topusermem:  equ   heap_start  
011f			  
011f			;if BASE_KEV   
011f			;baseusermem: equ 08000h  
011f			;endif  
011f			  
011f			;if BASE_SC114  
011f			;;aseusermem:     equ    12  
011f			;baseusermem:     equ    prompt  
011f			;;baseusermem:     equ    endofcode  
011f			;endif  
011f			  
011f			  
011f			; **********************************************************************  
011f			; **  Constants  
011f			; **********************************************************************  
011f			  
011f			; Constants used by this code module  
011f			kDataReg:   EQU Device_D           ;PIO port A data register  
011f			kContReg:   EQU Device_D+2           ;PIO port A control register  
011f			  
011f			  
011f			portbdata:  equ Device_D+1    ; port b data  
011f			portbctl:   equ Device_D+3    ; port b control  
011f			  
011f			  
011f			;KEY_SHIFT:   equ 5  
011f			;KEY_SYMBOLSHIFT:  equ 6  
011f			  
011f			KEY_SHIFTLOCK: equ 4  
011f			  
011f			  
011f			KEY_UP: equ 5  
011f			KEY_NEXTWORD: equ 6  
011f			KEY_PREVWORD: equ 7  
011f			KEY_BS: equ 8  
011f			KEY_TAB:  equ 9  
011f			KEY_DOWN: equ 10  
011f			KEY_LEFT: equ 11  
011f			KEY_RIGHT: equ 12  
011f			KEY_CR:   equ 13  
011f			KEY_HOME: equ 14  
011f			KEY_END: equ 15  
011f			  
011f			KEY_F1: equ 16  
011f			KEY_F2: equ 17  
011f			KEY_F3: equ 18  
011f			KEY_F4: equ 19  
011f			  
011f			KEY_F5: equ 20  
011f			KEY_F6: equ 21  
011f			KEY_F7: equ 22  
011f			KEY_F8: equ 23  
011f			  
011f			KEY_F9: equ 24  
011f			KEY_F10: equ 25  
011f			KEY_F11: equ 26  
011f			KEY_F12: equ 27  
011f			  
011f			;if DEBUG_KEY  
011f			;	KEY_MATRIX_NO_PRESS: equ '.'  
011f			;	KEY_SHIFT:   equ '.'  
011f			;	KEY_SYMBOLSHIFT:  equ '.'  
011f			;else  
011f				KEY_SHIFT:   equ '~'  
011f				KEY_SYMBOLSHIFT:  equ '~'  
011f				KEY_MATRIX_NO_PRESS: equ '~'  
011f			;endi  
011f			  
011f			  
011f			  
011f			  
011f			; Macro to make adding debug marks easier  
011f			  
011f			DMARK: macro str  
011f				push af  
011f				ld a, (.dmark)  
011f				ld (debug_mark),a  
011f				ld a, (.dmark+1)  
011f				ld (debug_mark+1),a  
011f				ld a, (.dmark+2)  
011f				ld (debug_mark+2),a  
011f				jr .pastdmark  
011f			.dmark: db str  
011f			.pastdmark: pop af  
011f			  
011f			endm  
011f			  
011f			  
011f			; macro to detect for stack imbalances  
011f			  
011f			include "stackimbal.asm"  
011f			; Macro and code to detect stock imbalances 
011f			 
011f			SPPUSH: equ 0 
011f			 
011f			; Add a stack frame which can be checked before return 
011f			 
011f			STACKFRAME: macro onoff frame1 frame2 
011f			 
011f				if DEBUG_STACK_IMB 
011f					if onoff 
011f						; save current SP 
011f						exx 
011f			 
011f						ld de, frame1 
011f						ld a, d 
011f						ld hl, curframe 
011f						call hexout 
011f						ld a, e 
011f						ld hl, curframe+2 
011f						call hexout 
011f			  
011f						ld hl, frame1 
011f						push hl 
011f						ld hl, frame2 
011f						push hl 
011f						exx 
011f					endif 
011f					 
011f				endif 
011f			endm 
011f			 
011f			STACKFRAMECHK: macro onoff frame1 frame2 
011f			 
011f					 
011f				if DEBUG_STACK_IMB 
011f					if onoff 
011f						exx 
011f						; check stack frame SP 
011f			 
011f						ld hl, frame2 
011f						pop de   ; frame2 
011f			 
011f						call cmp16 
011f						jr nz, .spnosame 
011f						 
011f			 
011f						ld hl, frame1 
011f						pop de   ; frame1 
011f			 
011f						call cmp16 
011f						jr z, .spfrsame 
011f			 
011f						.spnosame: call showsperror 
011f			 
011f						.spfrsame: nop 
011f			 
011f						exx 
011f					endif 
011f					 
011f				endif 
011f			 
011f			 
011f			endm 
011f			 
011f			 
011f			; for a sub routine, wrap SP collection and comparisons 
011f			 
011f			; Usage: 
011f			; 
011f			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
011f			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
011f			 
011f			SAVESP: macro onoff storeword 
011f			 
011f				if DEBUG_STACK_IMB 
011f					if onoff 
011f						; save current SP 
011f			 
011f						ld (store_sp+(storeword*4)), sp 
011f			 
011f					endif 
011f					 
011f				endif 
011f			 
011f			endm 
011f			 
011f			CHECKSP: macro onoff storeword 
011f			 
011f				if DEBUG_STACK_IMB 
011f					if onoff 
011f			 
011f						; save SP after last save 
011f				 
011f						ld (store_sp+(storeword*4)+2), sp 
011f			 
011f						push hl 
011f						ld hl, store_sp+(storeword*4) 
011f						call check_stack_sp  
011f						pop hl 
011f			 
011f			 
011f					endif 
011f					 
011f				endif 
011f			 
011f			endm 
011f			 
011f			if DEBUG_STACK_IMB 
011f			 
011f			check_stack_sp: 
011f					push de 
011f			 
011f					ld e, (hl) 
011f					inc hl 
011f					ld d, (hl) 
011f					inc hl 
011f			 
011f					push de 
011f			 
011f			 
011f					ld e, (hl) 
011f					inc hl 
011f					ld d, (hl) 
011f					inc hl 
011f			 
011f					pop hl 
011f			 
011f			 
011f					; check to see if the same 
011f			 
011f					call cmp16 
011f					jr z, .spsame 
011f			 
011f					; not same 
011f			 
011f					call showsperror 
011f			.spsame: 
011f			 
011f					pop de 
011f			 
011f					ret 
011f			 
011f			.sperr:  db "Stack imbalance",0 
011f			 
011f			 
011f			showsperror: 
011f			 
011f			 
011f				push hl 
011f				push af 
011f				push de 
011f				call clear_display 
011f				ld de, .sperr 
011f				ld a,0 
011f			;	ld de,os_word_scratch 
011f				call str_at_display 
011f				ld a, display_row_1+17 
011f				ld de, debug_mark 
011f				call str_at_display 
011f				ld a, 0 
011f				ld (curframe+4),a 
011f				ld hl, curframe 
011f				ld de, os_word_scratch 
011f				ld a, display_row_4 
011f				call str_at_display 
011f				call update_display 
011f				;call break_point_state 
011f				call cin_wait 
011f			 
011f			;	ld a, ' ' 
011f			;	ld (os_view_disable), a 
011f				call bp_on 
011f				pop de	 
011f				pop af 
011f				pop hl 
011f				CALLMONITOR 
011f				ret 
011f			 
011f			endif 
011f			 
011f			 
011f			 
011f			; eof 
# End of file stackimbal.asm
011f			  
011f			;TODO macro to calc col and row offset into screen  
011f			  
011f			  
011f			  
011f			hardware_init:  
011f			  
011f				  
011f			  
011f					;ld a, 0  
011f					;ld (hardware_diag), a  
011f			  
011f					; clear all the buffers  
011f			  
011f 21 03 ed				ld hl, display_fb1  
0122 22 bf eb				ld (display_fb_active), hl  
0125			  
0125 cd bc 0b				call clear_display  
0128			  
0128 21 c1 eb				ld hl, display_fb2  
012b 22 bf eb				ld (display_fb_active), hl  
012e			  
012e cd bc 0b				call clear_display  
0131			  
0131					; init primary frame buffer area  
0131 21 a4 ed				ld hl, display_fb0  
0134 22 bf eb				ld (display_fb_active), hl  
0137			  
0137 cd bc 0b				call clear_display  
013a			  
013a			  
013a cd 86 66				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
013d			  
013d cd 74 67			call key_init  
0140 cd ad 01			call storage_init  
0143			  
0143				; setup malloc functions  
0143			  
0143				if MALLOC_1  
0143 cd 8e 11				call  heap_init  
0146				endif  
0146				if MALLOC_4  
0146					call  heap_init  
0146				endif  
0146			  
0146				; init sound hardware if present  
0146			  
0146				if SOUND_ENABLE  
0146					call sound_init  
0146				endif  
0146			  
0146				; lcd test sequence  
0146					  
0146 cd de 0b			call update_display  
0149 cd f0 0a			call delay1s  
014c 3e 2b			ld a,'+'  
014e cd c1 0b			call fill_display  
0151 cd de 0b			call update_display  
0154 cd f0 0a			call delay1s  
0157 3e 2a			ld a,'*'  
0159 cd c1 0b			call fill_display  
015c cd de 0b			call update_display  
015f cd f0 0a			call delay1s  
0162 3e 2d			ld a,'-'  
0164 cd c1 0b			call fill_display  
0167 cd de 0b			call update_display  
016a cd f0 0a			call delay1s  
016d			  
016d			; boot splash screen  
016d			if display_cols == 20	  
016d			        ld a, display_row_1    
016d			else  
016d 3e 0a		        ld a, display_row_1 +10   
016f			endif  
016f 11 31 16			ld de, prom_bootmsg  
0172 cd ce 0b			call str_at_display  
0175 cd de 0b			call update_display  
0178			  
0178			  
0178 cd f0 0a			call delay1s  
017b cd f0 0a			call delay1s  
017e			if display_cols == 20	  
017e			            LD   A, display_row_3+2  
017e			else  
017e 3e 5c		            LD   A, display_row_3+12  
0180			endif  
0180 11 46 16			ld de, prom_bootmsg1  
0183 cd ce 0b			call str_at_display  
0186			; display debug level  
0186 3e 78		            LD   A, display_row_4  
0188 11 1b 01			ld de, debuglevel  
018b cd ce 0b			call str_at_display  
018e			  
018e cd de 0b			call update_display  
0191 cd f0 0a			call delay1s  
0194 cd f0 0a			call delay1s  
0197			  
0197			;	ld a, display_row_4+3  
0197			;	ld de, bootmsg2  
0197			;	call str_at_display  
0197			;	call update_display  
0197			;	call delay1s  
0197			;	call delay1s  
0197			  
0197			; debug mark setup  
0197			  
0197 3e 5f		ld a, '_'  
0199 32 5e ee		ld (debug_mark),a  
019c 32 5f ee		ld (debug_mark+1),a  
019f 32 60 ee		ld (debug_mark+2),a  
01a2 3e 00		ld a,0  
01a4 32 61 ee		ld (debug_mark+3),a  
01a7 32 62 ee		ld (debug_umark),a  
01aa			  
01aa c9					ret  
01ab			  
01ab			  
01ab			;bootmsg2:	db "Firmware v0.1",0  
01ab			  
01ab			; a 4x20 lcd  
01ab			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
01ab			  
01ab			;if display_cols == 20  
01ab			;	include "firmware_lcd_4x20.asm"  
01ab			;endif  
01ab			  
01ab			;if display_cols == 40  
01ab			;	include "firmware_lcd_4x40.asm"  
01ab			;endif  
01ab			  
01ab			;  
01ab			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
01ab			; TODO abstract the bit bang video out interface for dual display  
01ab			; TODO wire video out to tx pin on rc2014 bus  
01ab			  
01ab			; must supply cin, and cin_wait for low level hardware abstraction   
01ab			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
01ab			; test scancode  
01ab			  
01ab			;;;;;  
01ab			;;;  
01ab			; Moved out to mini and maxi versions  
01ab			;  
01ab			; include "firmware_key_4x4.asm"  
01ab			; using existing 4 wire x 4 resistor array for input  
01ab			;include "firmware_key_4x10.asm"  
01ab			; need to mod the board for 5 rows due to resistor array  
01ab			;include "firmware_key_5x10.asm"  
01ab			  
01ab			; storage hardware interface  
01ab			  
01ab			; use microchip serial eeprom for storage  
01ab			  
01ab			  
01ab			if STORAGE_SE  
01ab				include "firmware_spi.asm"  
01ab				include "firmware_seeprom.asm"  
01ab			else  
01ab			   ; create some stubs for the labels  
01ab c9			se_readbyte: ret  
01ac c9			se_writebyte: ret  
01ad c9			storage_init: ret  
01ae			  
01ae			endif  
01ae			  
01ae			; use cf card for storage - throwing timeout errors. Hardware or software?????  
01ae			;include "firmware_cf.asm"  
01ae			  
01ae			; load up high level storage hardward abstractions  
01ae			include "firmware_storage.asm"  
01ae			 
01ae			; persisent storage hardware abstraction layer  
01ae			 
01ae			 
01ae			 
01ae			; Block 0 on storage is a config state 
01ae			 
01ae			 
01ae			 
01ae			; TODO add read phy block and write phy block functions 
01ae			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
01ae			 
01ae			; Abstraction layer  
01ae			 
01ae			; Logocial block size is same size as physical size - using tape concept 
01ae			 
01ae			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
01ae			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
01ae			 
01ae			 
01ae			 
01ae			; Filesystem layout (Logical layout) 
01ae			; 
01ae			; Block 0 - Bank config  
01ae			; 
01ae			;      Byte - 0 file id counter 
01ae			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
01ae			;      Byte - 3-20 zero terminated bank label 
01ae			; 
01ae			; Block 1 > File storage 
01ae			; 
01ae			;      Byte 0 file id    - block 0 file details 
01ae			;      Byte 1 block id - block 0 is file  
01ae			;            Byte 2-15 - File name 
01ae			; 
01ae			;       - to end of block data 
01ae			; 
01ae			 
01ae			; Get ID for the file named in pointer held HL 
01ae			; Returns ID in HL = 255 if no file found 
01ae			 
01ae			storage_getid: 
01ae			 
01ae 22 66 ea			ld (store_tmp1), hl 
01b1			 
01b1				if DEBUG_STORESE 
01b1					DMARK "SGI" 
01b1 f5				push af  
01b2 3a c6 01			ld a, (.dmark)  
01b5 32 5e ee			ld (debug_mark),a  
01b8 3a c7 01			ld a, (.dmark+1)  
01bb 32 5f ee			ld (debug_mark+1),a  
01be 3a c8 01			ld a, (.dmark+2)  
01c1 32 60 ee			ld (debug_mark+2),a  
01c4 18 03			jr .pastdmark  
01c6 ..			.dmark: db "SGI"  
01c9 f1			.pastdmark: pop af  
01ca			endm  
# End of macro DMARK
01ca					CALLMONITOR 
01ca cd 6b ee			call debug_vector  
01cd				endm  
# End of macro CALLMONITOR
01cd				endif 
01cd				; get block 0 and set counter for number of files to scan 
01cd			 
01cd cd 35 03			call storage_get_block_0 
01d0			 
01d0 3a 6d ea			ld a, (store_page) 
01d3 47				ld b, a 
01d4			 
01d4				; get extent 0 of each file id 
01d4			 
01d4				if DEBUG_STORESE 
01d4					DMARK "SGc" 
01d4 f5				push af  
01d5 3a e9 01			ld a, (.dmark)  
01d8 32 5e ee			ld (debug_mark),a  
01db 3a ea 01			ld a, (.dmark+1)  
01de 32 5f ee			ld (debug_mark+1),a  
01e1 3a eb 01			ld a, (.dmark+2)  
01e4 32 60 ee			ld (debug_mark+2),a  
01e7 18 03			jr .pastdmark  
01e9 ..			.dmark: db "SGc"  
01ec f1			.pastdmark: pop af  
01ed			endm  
# End of macro DMARK
01ed					CALLMONITOR 
01ed cd 6b ee			call debug_vector  
01f0				endm  
# End of macro CALLMONITOR
01f0				endif 
01f0 60			.getloop:	ld h, b 
01f1 2e 00				ld l, 0 
01f3 c5					push bc 
01f4			 
01f4 11 6d ea				ld de, store_page 
01f7				if DEBUG_STORESE 
01f7					DMARK "SGr" 
01f7 f5				push af  
01f8 3a 0c 02			ld a, (.dmark)  
01fb 32 5e ee			ld (debug_mark),a  
01fe 3a 0d 02			ld a, (.dmark+1)  
0201 32 5f ee			ld (debug_mark+1),a  
0204 3a 0e 02			ld a, (.dmark+2)  
0207 32 60 ee			ld (debug_mark+2),a  
020a 18 03			jr .pastdmark  
020c ..			.dmark: db "SGr"  
020f f1			.pastdmark: pop af  
0210			endm  
# End of macro DMARK
0210					CALLMONITOR 
0210 cd 6b ee			call debug_vector  
0213				endm  
# End of macro CALLMONITOR
0213				endif 
0213 cd d7 07				call storage_read 
0216 cd 0f 0e				call ishlzero 
0219 28 2d				jr z, .gap 
021b					 
021b					; have a file name read. Is it one we want. 
021b			 
021b 2a 66 ea				ld hl, (store_tmp1) 
021e 11 70 ea				ld de, store_page+3   ; file name 
0221			 
0221				if DEBUG_STORESE 
0221					DMARK "SGc" 
0221 f5				push af  
0222 3a 36 02			ld a, (.dmark)  
0225 32 5e ee			ld (debug_mark),a  
0228 3a 37 02			ld a, (.dmark+1)  
022b 32 5f ee			ld (debug_mark+1),a  
022e 3a 38 02			ld a, (.dmark+2)  
0231 32 60 ee			ld (debug_mark+2),a  
0234 18 03			jr .pastdmark  
0236 ..			.dmark: db "SGc"  
0239 f1			.pastdmark: pop af  
023a			endm  
# End of macro DMARK
023a					CALLMONITOR 
023a cd 6b ee			call debug_vector  
023d				endm  
# End of macro CALLMONITOR
023d				endif 
023d cd 76 11				call strcmp 
0240 20 06				jr nz, .gap   ; not this one 
0242			 
0242 c1				        pop bc 
0243			 
0243 26 00				ld h, 0 
0245 68					ld l, b 
0246 18 22				jr .getdone 
0248						 
0248			 
0248			 
0248			 
0248			.gap: 
0248				if DEBUG_STORESE 
0248					DMARK "SGg" 
0248 f5				push af  
0249 3a 5d 02			ld a, (.dmark)  
024c 32 5e ee			ld (debug_mark),a  
024f 3a 5e 02			ld a, (.dmark+1)  
0252 32 5f ee			ld (debug_mark+1),a  
0255 3a 5f 02			ld a, (.dmark+2)  
0258 32 60 ee			ld (debug_mark+2),a  
025b 18 03			jr .pastdmark  
025d ..			.dmark: db "SGg"  
0260 f1			.pastdmark: pop af  
0261			endm  
# End of macro DMARK
0261					CALLMONITOR 
0261 cd 6b ee			call debug_vector  
0264				endm  
# End of macro CALLMONITOR
0264				endif 
0264			 
0264 c1					pop bc 
0265 10 89				djnz .getloop 
0267 21 ff 00				ld hl, 255 
026a			.getdone: 
026a			 
026a				if DEBUG_STORESE 
026a					DMARK "SGe" 
026a f5				push af  
026b 3a 7f 02			ld a, (.dmark)  
026e 32 5e ee			ld (debug_mark),a  
0271 3a 80 02			ld a, (.dmark+1)  
0274 32 5f ee			ld (debug_mark+1),a  
0277 3a 81 02			ld a, (.dmark+2)  
027a 32 60 ee			ld (debug_mark+2),a  
027d 18 03			jr .pastdmark  
027f ..			.dmark: db "SGe"  
0282 f1			.pastdmark: pop af  
0283			endm  
# End of macro DMARK
0283					CALLMONITOR 
0283 cd 6b ee			call debug_vector  
0286				endm  
# End of macro CALLMONITOR
0286				endif 
0286			 
0286 c9				ret 
0287			 
0287			 
0287			 
0287			 
0287			 
0287			 
0287			 
0287			 
0287			; Read Block 
0287			; ---------- 
0287			; 
0287			; With current bank 
0287			;  
0287			; Get block number to read 
0287			; Load physical blocks starting at start block into buffer 
0287			 
0287			; de points to buffer to use 
0287			; hl holds logical block number  
0287			 
0287			storage_read_block: 
0287			 
0287				; TODO bank selection 
0287			 
0287				; for each of the physical blocks read it into the buffer 
0287 06 40			ld b, STORE_BLOCK_PHY 
0289			 
0289				if DEBUG_STORESE 
0289 d5					push de 
028a				endif 
028a				 
028a			.rl1:    
028a			 
028a				; read physical block at hl into de 
028a			        ; increment hl and de to next read position on exit 
028a			 
028a e5				push hl 
028b d5				push de	 
028c c5				push bc 
028d			;	if DEBUG_STORESE 
028d			;		push af 
028d			;		ld a, 'R' 
028d			;		ld (debug_mark),a 
028d			;		pop af 
028d			;		CALLMONITOR 
028d			;	endif 
028d cd ab 01			call se_readbyte 
0290			;	if DEBUG_STORESE 
0290			;		ld a,(spi_portbyte) 
0290			;		ld l, a 
0290			;		push af 
0290			;		ld a, '1' 
0290			;		ld (debug_mark),a 
0290			;		pop af 
0290			;		CALLMONITOR 
0290			;	endif 
0290 c1				pop bc 
0291 d1				pop de 
0292 e1				pop hl 
0293 12				ld (de),a 
0294 23				inc hl 
0295 13				inc de 
0296			 
0296			;	if DEBUG_STORESE 
0296			;		push af 
0296			;		ld a, 'r' 
0296			;		ld (debug_mark),a 
0296			;		pop af 
0296			;		CALLMONITOR 
0296			;	endif 
0296			 
0296 10 f2			djnz .rl1 
0298			 
0298				if DEBUG_STORESE 
0298					DMARK "SRB" 
0298 f5				push af  
0299 3a ad 02			ld a, (.dmark)  
029c 32 5e ee			ld (debug_mark),a  
029f 3a ae 02			ld a, (.dmark+1)  
02a2 32 5f ee			ld (debug_mark+1),a  
02a5 3a af 02			ld a, (.dmark+2)  
02a8 32 60 ee			ld (debug_mark+2),a  
02ab 18 03			jr .pastdmark  
02ad ..			.dmark: db "SRB"  
02b0 f1			.pastdmark: pop af  
02b1			endm  
# End of macro DMARK
02b1 d1					pop de 
02b2			; 
02b2			;		push af 
02b2			;		ld a, 'R' 
02b2			;		ld (debug_mark),a 
02b2			;		pop af 
02b2					CALLMONITOR 
02b2 cd 6b ee			call debug_vector  
02b5				endm  
# End of macro CALLMONITOR
02b5				endif 
02b5 c9				ret	 
02b6				 
02b6			 
02b6			; File Size 
02b6			; --------- 
02b6			; 
02b6			;   hl file id 
02b6			; 
02b6			;  returns in hl the number of blocks 
02b6			 
02b6			storage_file_size: 
02b6 5d				ld e, l 
02b7 16 00			ld d, 0 
02b9 21 40 00			ld hl, STORE_BLOCK_PHY 
02bc					if DEBUG_FORTH_WORDS 
02bc						DMARK "SIZ" 
02bc f5				push af  
02bd 3a d1 02			ld a, (.dmark)  
02c0 32 5e ee			ld (debug_mark),a  
02c3 3a d2 02			ld a, (.dmark+1)  
02c6 32 5f ee			ld (debug_mark+1),a  
02c9 3a d3 02			ld a, (.dmark+2)  
02cc 32 60 ee			ld (debug_mark+2),a  
02cf 18 03			jr .pastdmark  
02d1 ..			.dmark: db "SIZ"  
02d4 f1			.pastdmark: pop af  
02d5			endm  
# End of macro DMARK
02d5						CALLMONITOR 
02d5 cd 6b ee			call debug_vector  
02d8				endm  
# End of macro CALLMONITOR
02d8					endif 
02d8 cd b3 05			call storage_findnextid 
02db			 
02db cd 0f 0e			call ishlzero 
02de			;	ld a, l 
02de			;	add h 
02de			;	cp 0 
02de c8				ret z			; block not found so EOF 
02df			 
02df 11 6d ea			ld de, store_page 
02e2 cd 87 02			call storage_read_block 
02e5			 
02e5 3a 6f ea			ld a, (store_page+2)	 ; get extent count 
02e8 6f				ld l, a 
02e9 26 00			ld h, 0 
02eb c9			 	ret 
02ec			 
02ec			 
02ec			; Write Block 
02ec			; ----------- 
02ec			; 
02ec			; With current bank 
02ec			;  
02ec			; Get block number to write 
02ec			; Write physical blocks starting at start block from buffer 
02ec			  
02ec			storage_write_block: 
02ec				; TODO bank selection 
02ec			 
02ec				; for each of the physical blocks read it into the buffer 
02ec 06 40			ld b, STORE_BLOCK_PHY 
02ee			 
02ee				if DEBUG_STORESE 
02ee					DMARK "SWB" 
02ee f5				push af  
02ef 3a 03 03			ld a, (.dmark)  
02f2 32 5e ee			ld (debug_mark),a  
02f5 3a 04 03			ld a, (.dmark+1)  
02f8 32 5f ee			ld (debug_mark+1),a  
02fb 3a 05 03			ld a, (.dmark+2)  
02fe 32 60 ee			ld (debug_mark+2),a  
0301 18 03			jr .pastdmark  
0303 ..			.dmark: db "SWB"  
0306 f1			.pastdmark: pop af  
0307			endm  
# End of macro DMARK
0307			 
0307					;push af 
0307					;ld a, 'W' 
0307					;ld (debug_mark),a 
0307					;pop af 
0307					CALLMONITOR 
0307 cd 6b ee			call debug_vector  
030a				endm  
# End of macro CALLMONITOR
030a				endif 
030a			 
030a			; might not be working 
030a			;	call se_writepage 
030a			 
030a			;	ret 
030a			; 
030a			 
030a			 
030a			 
030a			.wl1:    
030a			 
030a				; read physical block at hl into de 
030a			        ; increment hl and de to next read position on exit 
030a			 
030a e5				push hl 
030b d5				push de	 
030c c5				push bc 
030d 1a				ld a,(de) 
030e				;if DEBUG_STORESE 
030e			;		push af 
030e			;		ld a, 'W' 
030e			;		ld (debug_mark),a 
030e			;		pop af 
030e			;		CALLMONITOR 
030e			;	endif 
030e cd ac 01			call se_writebyte 
0311			;	call delay250ms 
0311			;	nop 
0311			;	nop 
0311			;	nop 
0311			;	if DEBUG_STORESE 
0311			;		push af 
0311			;		ld a, 'w' 
0311			;		ld (debug_mark),a 
0311			;		pop af 
0311			;		CALLMONITOR 
0311			;	endif 
0311 c1				pop bc 
0312 d1				pop de 
0313 e1				pop hl 
0314 23				inc hl 
0315 13				inc de 
0316			 
0316			 
0316 10 f2			djnz .wl1 
0318			 
0318				if DEBUG_STORESE 
0318					DMARK "SW2" 
0318 f5				push af  
0319 3a 2d 03			ld a, (.dmark)  
031c 32 5e ee			ld (debug_mark),a  
031f 3a 2e 03			ld a, (.dmark+1)  
0322 32 5f ee			ld (debug_mark+1),a  
0325 3a 2f 03			ld a, (.dmark+2)  
0328 32 60 ee			ld (debug_mark+2),a  
032b 18 03			jr .pastdmark  
032d ..			.dmark: db "SW2"  
0330 f1			.pastdmark: pop af  
0331			endm  
# End of macro DMARK
0331			 
0331					;push af 
0331					;ld a, 'W' 
0331					;ld (debug_mark),a 
0331					;pop af 
0331					CALLMONITOR 
0331 cd 6b ee			call debug_vector  
0334				endm  
# End of macro CALLMONITOR
0334				endif 
0334 c9				ret	 
0335			 
0335			; Init bank 
0335			; --------- 
0335			; 
0335			; With current bank 
0335			; 
0335			; Setup block 0 config 
0335			;     Set 0 file id counter 
0335			;     Set formatted byte pattern 
0335			;     Zero out bank label 
0335			;      
0335			; For every logical block write 0-1 byte as null 
0335			 
0335			storage_get_block_0: 
0335			 
0335				; TODO check presence 
0335			 
0335				; get block 0 config 
0335			 
0335 21 00 00			ld hl, 0 
0338 11 6d ea			ld de, store_page 
033b cd 87 02			call storage_read_block 
033e			 
033e				if DEBUG_STORESE 
033e					DMARK "SB0" 
033e f5				push af  
033f 3a 53 03			ld a, (.dmark)  
0342 32 5e ee			ld (debug_mark),a  
0345 3a 54 03			ld a, (.dmark+1)  
0348 32 5f ee			ld (debug_mark+1),a  
034b 3a 55 03			ld a, (.dmark+2)  
034e 32 60 ee			ld (debug_mark+2),a  
0351 18 03			jr .pastdmark  
0353 ..			.dmark: db "SB0"  
0356 f1			.pastdmark: pop af  
0357			endm  
# End of macro DMARK
0357 11 6d ea				ld de, store_page 
035a			;		push af 
035a			;		ld a, 'i' 
035a			;		ld (debug_mark),a 
035a			;		pop af 
035a					CALLMONITOR 
035a cd 6b ee			call debug_vector  
035d				endm  
# End of macro CALLMONITOR
035d				endif 
035d			 
035d				; is this area formatted? 
035d			 
035d			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
035d 2a 6e ea			ld hl, (store_page+1) 
0360 3e 80			ld a,0x80 
0362 bd				cp l 
0363 20 22			jr nz, .ininotformatted 
0365				; do a double check 
0365 3e 27			ld a, 0x27 
0367 bc				cp h 
0368 20 1d			jr nz, .ininotformatted 
036a			 
036a				; formatted then 
036a			 
036a				if DEBUG_STORESE 
036a					DMARK "SB1" 
036a f5				push af  
036b 3a 7f 03			ld a, (.dmark)  
036e 32 5e ee			ld (debug_mark),a  
0371 3a 80 03			ld a, (.dmark+1)  
0374 32 5f ee			ld (debug_mark+1),a  
0377 3a 81 03			ld a, (.dmark+2)  
037a 32 60 ee			ld (debug_mark+2),a  
037d 18 03			jr .pastdmark  
037f ..			.dmark: db "SB1"  
0382 f1			.pastdmark: pop af  
0383			endm  
# End of macro DMARK
0383					;push af 
0383					;ld a, 'I' 
0383					;ld (debug_mark),a 
0383					;pop af 
0383					CALLMONITOR 
0383 cd 6b ee			call debug_vector  
0386				endm  
# End of macro CALLMONITOR
0386				endif 
0386 c9				ret 
0387			 
0387			.ininotformatted: 
0387				; bank not formatted so poke various bits to make sure 
0387			 
0387				if DEBUG_STORESE 
0387					DMARK "SB2" 
0387 f5				push af  
0388 3a 9c 03			ld a, (.dmark)  
038b 32 5e ee			ld (debug_mark),a  
038e 3a 9d 03			ld a, (.dmark+1)  
0391 32 5f ee			ld (debug_mark+1),a  
0394 3a 9e 03			ld a, (.dmark+2)  
0397 32 60 ee			ld (debug_mark+2),a  
039a 18 03			jr .pastdmark  
039c ..			.dmark: db "SB2"  
039f f1			.pastdmark: pop af  
03a0			endm  
# End of macro DMARK
03a0					;push af 
03a0					;ld a, 'f' 
03a0					;ld (debug_mark),a 
03a0					;pop af 
03a0					CALLMONITOR 
03a0 cd 6b ee			call debug_vector  
03a3				endm  
# End of macro CALLMONITOR
03a3				endif 
03a3			 
03a3 cd b4 0a			call storage_clear_page 
03a6			 
03a6 21 6d ea			ld hl, store_page 
03a9			;	ld a, 0 
03a9				 
03a9 36 00			ld (hl),0   ; reset file counter 
03ab			 
03ab 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03ae 22 6e ea		 	ld (store_page+1), hl	 
03b1			 
03b1				; set default label 
03b1			 
03b1 21 4a 04			ld hl, .defaultbanklabl 
03b4 11 70 ea		 	ld de, store_page+3 
03b7 01 0f 00			ld bc, 15 
03ba ed b0			ldir 
03bc			 
03bc				; Append the current bank id 
03bc 21 79 ea			ld hl, store_page+3+9 
03bf 3a 52 ea			ld a, (spi_device_id) 
03c2 77				ld (hl), a 
03c3			 
03c3				; save default page 0 
03c3			 
03c3 21 00 00			ld hl, 0 
03c6 11 6d ea			ld de, store_page 
03c9				if DEBUG_STORESE 
03c9					DMARK "SB3" 
03c9 f5				push af  
03ca 3a de 03			ld a, (.dmark)  
03cd 32 5e ee			ld (debug_mark),a  
03d0 3a df 03			ld a, (.dmark+1)  
03d3 32 5f ee			ld (debug_mark+1),a  
03d6 3a e0 03			ld a, (.dmark+2)  
03d9 32 60 ee			ld (debug_mark+2),a  
03dc 18 03			jr .pastdmark  
03de ..			.dmark: db "SB3"  
03e1 f1			.pastdmark: pop af  
03e2			endm  
# End of macro DMARK
03e2			;		push af 
03e2			;		ld a, 'F' 
03e2			;		ld (debug_mark),a 
03e2			;		pop af 
03e2					CALLMONITOR 
03e2 cd 6b ee			call debug_vector  
03e5				endm  
# End of macro CALLMONITOR
03e5				endif 
03e5 cd ec 02			call storage_write_block 
03e8				if DEBUG_STORESE 
03e8					DMARK "SB4" 
03e8 f5				push af  
03e9 3a fd 03			ld a, (.dmark)  
03ec 32 5e ee			ld (debug_mark),a  
03ef 3a fe 03			ld a, (.dmark+1)  
03f2 32 5f ee			ld (debug_mark+1),a  
03f5 3a ff 03			ld a, (.dmark+2)  
03f8 32 60 ee			ld (debug_mark+2),a  
03fb 18 03			jr .pastdmark  
03fd ..			.dmark: db "SB4"  
0400 f1			.pastdmark: pop af  
0401			endm  
# End of macro DMARK
0401			;		push af 
0401			;		ld a, '>' 
0401			;		ld (debug_mark),a 
0401			;		pop af 
0401					CALLMONITOR 
0401 cd 6b ee			call debug_vector  
0404				endm  
# End of macro CALLMONITOR
0404				endif 
0404			 
0404			;	nop 
0404			;	nop 
0404			;	nop 
0404			 
0404				; now set 0 in every page to mark as a free block 
0404			 
0404 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0406 21 40 00			ld hl, STORE_BLOCK_PHY 
0409			 
0409 3e 00		.setmark1:   	ld a,0 
040b e5					push hl 
040c c5					push bc 
040d cd ac 01				call se_writebyte 
0410 3e 0a			ld a, 10 
0412 cd d5 0a			call aDelayInMS 
0415 23				inc hl 
0416 cd ac 01				call se_writebyte 
0419 3e 0a			ld a, 10 
041b cd d5 0a			call aDelayInMS 
041e 2b				dec hl 
041f c1					pop bc 
0420 e1					pop hl 
0421 3e 40				ld a, STORE_BLOCK_PHY 
0423 cd e6 0d				call addatohl 
0426 10 e1				djnz .setmark1 
0428			 
0428 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
042a 3e 00		.setmark2:   	ld a,0 
042c e5					push hl 
042d c5					push bc 
042e cd ac 01				call se_writebyte 
0431 3e 0a			ld a, 10 
0433 cd d5 0a			call aDelayInMS 
0436 23				inc hl 
0437 cd ac 01				call se_writebyte 
043a 3e 0a			ld a, 10 
043c cd d5 0a			call aDelayInMS 
043f 2b				dec hl 
0440 c1					pop bc 
0441 e1					pop hl 
0442 3e 40				ld a, STORE_BLOCK_PHY 
0444 cd e6 0d				call addatohl 
0447 10 e1				djnz .setmark2 
0449			 
0449					 
0449			 
0449			 
0449 c9				ret 
044a			 
044a			 
044a			 
044a			 
044a .. 00		.defaultbanklabl:   db "BankLabel_",0 
0455			 
0455			 
0455			 
0455			; Label Bank 
0455			; ---------- 
0455			; 
0455			; With current bank 
0455			; Read block 0 
0455			; Set label 
0455			; Write block 0 
0455			 
0455			; label str pointer in hl 
0455			 
0455			storage_label:     
0455			 
0455				if DEBUG_STORESE 
0455					DMARK "LBL" 
0455 f5				push af  
0456 3a 6a 04			ld a, (.dmark)  
0459 32 5e ee			ld (debug_mark),a  
045c 3a 6b 04			ld a, (.dmark+1)  
045f 32 5f ee			ld (debug_mark+1),a  
0462 3a 6c 04			ld a, (.dmark+2)  
0465 32 60 ee			ld (debug_mark+2),a  
0468 18 03			jr .pastdmark  
046a ..			.dmark: db "LBL"  
046d f1			.pastdmark: pop af  
046e			endm  
# End of macro DMARK
046e					CALLMONITOR 
046e cd 6b ee			call debug_vector  
0471				endm  
# End of macro CALLMONITOR
0471				endif 
0471			 
0471 e5				push hl 
0472			 
0472 cd 35 03			call storage_get_block_0 
0475			 
0475				; set default label 
0475			 
0475 e1				pop hl 
0476			 
0476 11 70 ea		 	ld de, store_page+3 
0479 01 0f 00			ld bc, 15 
047c				if DEBUG_STORESE 
047c					DMARK "LB3" 
047c f5				push af  
047d 3a 91 04			ld a, (.dmark)  
0480 32 5e ee			ld (debug_mark),a  
0483 3a 92 04			ld a, (.dmark+1)  
0486 32 5f ee			ld (debug_mark+1),a  
0489 3a 93 04			ld a, (.dmark+2)  
048c 32 60 ee			ld (debug_mark+2),a  
048f 18 03			jr .pastdmark  
0491 ..			.dmark: db "LB3"  
0494 f1			.pastdmark: pop af  
0495			endm  
# End of macro DMARK
0495					CALLMONITOR 
0495 cd 6b ee			call debug_vector  
0498				endm  
# End of macro CALLMONITOR
0498				endif 
0498 ed b0			ldir 
049a				; save default page 0 
049a			 
049a 21 00 00			ld hl, 0 
049d 11 6d ea			ld de, store_page 
04a0				if DEBUG_STORESE 
04a0					DMARK "LBW" 
04a0 f5				push af  
04a1 3a b5 04			ld a, (.dmark)  
04a4 32 5e ee			ld (debug_mark),a  
04a7 3a b6 04			ld a, (.dmark+1)  
04aa 32 5f ee			ld (debug_mark+1),a  
04ad 3a b7 04			ld a, (.dmark+2)  
04b0 32 60 ee			ld (debug_mark+2),a  
04b3 18 03			jr .pastdmark  
04b5 ..			.dmark: db "LBW"  
04b8 f1			.pastdmark: pop af  
04b9			endm  
# End of macro DMARK
04b9					CALLMONITOR 
04b9 cd 6b ee			call debug_vector  
04bc				endm  
# End of macro CALLMONITOR
04bc				endif 
04bc cd ec 02			call storage_write_block 
04bf			 
04bf c9				ret 
04c0			 
04c0			 
04c0			 
04c0			; Read Block 0 - Config 
04c0			; --------------------- 
04c0			; 
04c0			; With current bank 
04c0			; Call presence test 
04c0			;    If not present format/init bank  
04c0			; Read block 0  
04c0			;  
04c0			 
04c0			 
04c0			; Dir 
04c0			; --- 
04c0			; 
04c0			; With current bank 
04c0			; Load Block 0 Config 
04c0			; Get max file id number 
04c0			; For each logical block 
04c0			;    Read block read byte 2 
04c0			;      if first block of file 
04c0			;         Display file name 
04c0			;         Display type flags for file 
04c0			;        
04c0			 
04c0			; moving to words as this requires stack control 
04c0			 
04c0			 
04c0			; Delete File 
04c0			; ----------- 
04c0			; 
04c0			; With current bank 
04c0			; 
04c0			; Load Block 0 Config 
04c0			; Get max file id number 
04c0			; For each logical block 
04c0			;    Read block file id 
04c0			;      If first block of file and dont have file id 
04c0			;         if file to delete 
04c0			;         Save file id 
04c0			;         Null file id 
04c0			;         Write this block back 
04c0			;      If file id is one saved 
04c0			;         Null file id 
04c0			;         Write this block back 
04c0			 
04c0			 
04c0			.se_done: 
04c0 e1				pop hl 
04c1 c9				ret 
04c2			 
04c2			storage_erase: 
04c2			 
04c2				; hl contains the file id 
04c2			 
04c2 5d				ld e, l 
04c3 16 00			ld d, 0 
04c5 21 40 00			ld hl, STORE_BLOCK_PHY 
04c8					if DEBUG_FORTH_WORDS 
04c8						DMARK "ERA" 
04c8 f5				push af  
04c9 3a dd 04			ld a, (.dmark)  
04cc 32 5e ee			ld (debug_mark),a  
04cf 3a de 04			ld a, (.dmark+1)  
04d2 32 5f ee			ld (debug_mark+1),a  
04d5 3a df 04			ld a, (.dmark+2)  
04d8 32 60 ee			ld (debug_mark+2),a  
04db 18 03			jr .pastdmark  
04dd ..			.dmark: db "ERA"  
04e0 f1			.pastdmark: pop af  
04e1			endm  
# End of macro DMARK
04e1						CALLMONITOR 
04e1 cd 6b ee			call debug_vector  
04e4				endm  
# End of macro CALLMONITOR
04e4					endif 
04e4 cd b3 05			call storage_findnextid 
04e7 cd 0f 0e			call ishlzero 
04ea c8				ret z 
04eb			 
04eb e5				push hl 
04ec			 
04ec				; TODO check file not found 
04ec			 
04ec 11 6d ea			ld de, store_page 
04ef cd 87 02			call storage_read_block 
04f2			 
04f2 cd 0f 0e			call ishlzero 
04f5 ca c0 04			jp z,.se_done 
04f8			 
04f8					if DEBUG_FORTH_WORDS 
04f8						DMARK "ER1" 
04f8 f5				push af  
04f9 3a 0d 05			ld a, (.dmark)  
04fc 32 5e ee			ld (debug_mark),a  
04ff 3a 0e 05			ld a, (.dmark+1)  
0502 32 5f ee			ld (debug_mark+1),a  
0505 3a 0f 05			ld a, (.dmark+2)  
0508 32 60 ee			ld (debug_mark+2),a  
050b 18 03			jr .pastdmark  
050d ..			.dmark: db "ER1"  
0510 f1			.pastdmark: pop af  
0511			endm  
# End of macro DMARK
0511						CALLMONITOR 
0511 cd 6b ee			call debug_vector  
0514				endm  
# End of macro CALLMONITOR
0514					endif 
0514 3a 6d ea			ld a, (store_page)	; get file id 
0517 32 61 ea			ld (store_tmpid), a 
051a			 
051a 3a 6f ea			ld a, (store_page+2)    ; get count of extends 
051d 32 60 ea			ld (store_tmpext), a 
0520			 
0520				; wipe file header 
0520			 
0520 e1				pop hl 
0521 3e 00			ld a, 0 
0523 32 6d ea			ld (store_page), a 
0526 32 6e ea			ld (store_page+1),a 
0529 11 6d ea			ld de, store_page 
052c					if DEBUG_FORTH_WORDS 
052c						DMARK "ER2" 
052c f5				push af  
052d 3a 41 05			ld a, (.dmark)  
0530 32 5e ee			ld (debug_mark),a  
0533 3a 42 05			ld a, (.dmark+1)  
0536 32 5f ee			ld (debug_mark+1),a  
0539 3a 43 05			ld a, (.dmark+2)  
053c 32 60 ee			ld (debug_mark+2),a  
053f 18 03			jr .pastdmark  
0541 ..			.dmark: db "ER2"  
0544 f1			.pastdmark: pop af  
0545			endm  
# End of macro DMARK
0545						CALLMONITOR 
0545 cd 6b ee			call debug_vector  
0548				endm  
# End of macro CALLMONITOR
0548					endif 
0548 cd ec 02			call storage_write_block 
054b			 
054b			 
054b				; wipe file extents 
054b			 
054b 3a 60 ea			ld a, (store_tmpext) 
054e 47				ld b, a 
054f			 
054f			.eraext:	  
054f c5				push bc 
0550			 
0550 21 40 00			ld hl, STORE_BLOCK_PHY 
0553 3a 61 ea			ld a,(store_tmpid) 
0556 5f				ld e, a 
0557 50				ld d, b	 
0558					if DEBUG_FORTH_WORDS 
0558						DMARK "ER3" 
0558 f5				push af  
0559 3a 6d 05			ld a, (.dmark)  
055c 32 5e ee			ld (debug_mark),a  
055f 3a 6e 05			ld a, (.dmark+1)  
0562 32 5f ee			ld (debug_mark+1),a  
0565 3a 6f 05			ld a, (.dmark+2)  
0568 32 60 ee			ld (debug_mark+2),a  
056b 18 03			jr .pastdmark  
056d ..			.dmark: db "ER3"  
0570 f1			.pastdmark: pop af  
0571			endm  
# End of macro DMARK
0571						CALLMONITOR 
0571 cd 6b ee			call debug_vector  
0574				endm  
# End of macro CALLMONITOR
0574					endif 
0574 cd b3 05			call storage_findnextid 
0577 cd 0f 0e			call ishlzero 
057a ca c0 04			jp z,.se_done 
057d			 
057d e5				push hl 
057e 11 6d ea			ld de, store_page 
0581 cd 87 02			call storage_read_block 
0584			 
0584				; free block	 
0584			 
0584 3e 00			ld a, 0 
0586 32 6d ea			ld (store_page), a 
0589 32 6e ea			ld (store_page+1),a 
058c 11 6d ea			ld de, store_page 
058f e1				pop hl 
0590					if DEBUG_FORTH_WORDS 
0590						DMARK "ER4" 
0590 f5				push af  
0591 3a a5 05			ld a, (.dmark)  
0594 32 5e ee			ld (debug_mark),a  
0597 3a a6 05			ld a, (.dmark+1)  
059a 32 5f ee			ld (debug_mark+1),a  
059d 3a a7 05			ld a, (.dmark+2)  
05a0 32 60 ee			ld (debug_mark+2),a  
05a3 18 03			jr .pastdmark  
05a5 ..			.dmark: db "ER4"  
05a8 f1			.pastdmark: pop af  
05a9			endm  
# End of macro DMARK
05a9						CALLMONITOR 
05a9 cd 6b ee			call debug_vector  
05ac				endm  
# End of macro CALLMONITOR
05ac					endif 
05ac cd ec 02			call storage_write_block 
05af			 
05af c1				pop bc 
05b0 10 9d			djnz .eraext 
05b2			 
05b2 c9				ret 
05b3			 
05b3			 
05b3			; Find Free Block 
05b3			; --------------- 
05b3			; 
05b3			; With current bank 
05b3			;  
05b3			; From given starting logical block 
05b3			;    Read block  
05b3			;    If no file id 
05b3			;         Return block id 
05b3			 
05b3			 
05b3			; hl starting page number 
05b3			; hl contains free page number or zero if no pages free 
05b3			; e contains the file id to locate 
05b3			; d contains the block number 
05b3			 
05b3			; TODO change to find file id and use zero for free block 
05b3			 
05b3			storage_findnextid: 
05b3			 
05b3				; now locate first 0 page to mark as a free block 
05b3			 
05b3 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05b5			;	ld hl, STORE_BLOCK_PHY 
05b5			 
05b5					if DEBUG_FORTH_WORDS 
05b5					DMARK "FNI" 
05b5 f5				push af  
05b6 3a ca 05			ld a, (.dmark)  
05b9 32 5e ee			ld (debug_mark),a  
05bc 3a cb 05			ld a, (.dmark+1)  
05bf 32 5f ee			ld (debug_mark+1),a  
05c2 3a cc 05			ld a, (.dmark+2)  
05c5 32 60 ee			ld (debug_mark+2),a  
05c8 18 03			jr .pastdmark  
05ca ..			.dmark: db "FNI"  
05cd f1			.pastdmark: pop af  
05ce			endm  
# End of macro DMARK
05ce						CALLMONITOR 
05ce cd 6b ee			call debug_vector  
05d1				endm  
# End of macro CALLMONITOR
05d1					endif 
05d1			.ff1:   	 
05d1 e5					push hl 
05d2 c5					push bc 
05d3 d5					push de 
05d4 cd ab 01				call se_readbyte 
05d7 5f					ld e,a 
05d8 23					inc hl 
05d9 cd ab 01				call se_readbyte 
05dc 57					ld d, a 
05dd e1					pop hl 
05de e5					push hl 
05df cd 04 0e				call cmp16 
05e2 28 49				jr z, .fffound 
05e4			 
05e4 d1					pop de 
05e5 c1					pop bc 
05e6 e1					pop hl 
05e7			 
05e7					; is found? 
05e7					;cp e 
05e7					;ret z 
05e7			 
05e7 3e 40				ld a, STORE_BLOCK_PHY 
05e9 cd e6 0d				call addatohl 
05ec 10 e3				djnz .ff1 
05ee			 
05ee 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05f0			.ff2:   	 
05f0			 
05f0 e5					push hl 
05f1 c5					push bc 
05f2 d5					push de 
05f3 cd ab 01				call se_readbyte 
05f6 5f					ld e,a 
05f7 23					inc hl 
05f8 cd ab 01				call se_readbyte 
05fb 57					ld d, a 
05fc			 
05fc e1					pop hl 
05fd e5					push hl 
05fe cd 04 0e				call cmp16 
0601 28 2a				jr z, .fffound 
0603			 
0603 d1					pop de 
0604 c1					pop bc 
0605 e1					pop hl 
0606					; is found? 
0606					;cp e 
0606					;ret z 
0606			 
0606 3e 40				ld a, STORE_BLOCK_PHY 
0608 cd e6 0d				call addatohl 
060b 10 e3				djnz .ff2 
060d			 
060d			 
060d					if DEBUG_FORTH_WORDS 
060d					DMARK "FN-" 
060d f5				push af  
060e 3a 22 06			ld a, (.dmark)  
0611 32 5e ee			ld (debug_mark),a  
0614 3a 23 06			ld a, (.dmark+1)  
0617 32 5f ee			ld (debug_mark+1),a  
061a 3a 24 06			ld a, (.dmark+2)  
061d 32 60 ee			ld (debug_mark+2),a  
0620 18 03			jr .pastdmark  
0622 ..			.dmark: db "FN-"  
0625 f1			.pastdmark: pop af  
0626			endm  
# End of macro DMARK
0626					;	push af 
0626					;	ld a, 'n' 
0626					;	ld (debug_mark),a 
0626					;	pop af 
0626						CALLMONITOR 
0626 cd 6b ee			call debug_vector  
0629				endm  
# End of macro CALLMONITOR
0629					endif 
0629				; no free marks! 
0629 21 00 00				ld hl, 0 
062c c9				ret 
062d			.fffound: 
062d				 
062d			 
062d d1					pop de 
062e c1					pop bc 
062f e1					pop hl 
0630					if DEBUG_FORTH_WORDS 
0630					DMARK "FNF" 
0630 f5				push af  
0631 3a 45 06			ld a, (.dmark)  
0634 32 5e ee			ld (debug_mark),a  
0637 3a 46 06			ld a, (.dmark+1)  
063a 32 5f ee			ld (debug_mark+1),a  
063d 3a 47 06			ld a, (.dmark+2)  
0640 32 60 ee			ld (debug_mark+2),a  
0643 18 03			jr .pastdmark  
0645 ..			.dmark: db "FNF"  
0648 f1			.pastdmark: pop af  
0649			endm  
# End of macro DMARK
0649					;	push af 
0649					;	ld a, 'n' 
0649					;	ld (debug_mark),a 
0649					;	pop af 
0649						CALLMONITOR 
0649 cd 6b ee			call debug_vector  
064c				endm  
# End of macro CALLMONITOR
064c					endif 
064c c9				ret 
064d			 
064d			 
064d			 
064d			; Free Space 
064d			; ---------- 
064d			; 
064d			; With current bank 
064d			; 
064d			; Set block count to zero 
064d			; Starting with first logical block 
064d			;      Find free block  
064d			;      If block id given, increment block count 
064d			; 
064d			;  
064d			 
064d			 
064d			; hl contains count of free blocks 
064d			 
064d			storage_freeblocks: 
064d			 
064d				; now locate first 0 page to mark as a free block 
064d			 
064d 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
064f 21 40 00			ld hl, STORE_BLOCK_PHY 
0652 11 00 00			ld de, 0 
0655			 
0655			.fb1:   	 
0655 e5					push hl 
0656 c5					push bc 
0657 d5					push de 
0658 cd ab 01				call se_readbyte 
065b d1					pop de 
065c c1					pop bc 
065d e1					pop hl 
065e			 
065e					; is free? 
065e			;		cp 0 
065e b7					or a 
065f 20 01				jr nz, .ff1cont 
0661 13					inc de 
0662			 
0662			.ff1cont: 
0662			 
0662			 
0662 3e 40				ld a, STORE_BLOCK_PHY 
0664 cd e6 0d				call addatohl 
0667 10 ec				djnz .fb1 
0669			 
0669 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
066b			.fb2:   	 
066b e5					push hl 
066c c5					push bc 
066d d5					push de 
066e cd ab 01				call se_readbyte 
0671 d1					pop de 
0672 c1					pop bc 
0673 e1					pop hl 
0674			 
0674					; is free? 
0674			;		cp 0 
0674 b7					or a 
0675 20 01				jr nz, .ff2cont 
0677 13					inc de 
0678			 
0678			.ff2cont: 
0678			 
0678 3e 40				ld a, STORE_BLOCK_PHY 
067a cd e6 0d				call addatohl 
067d 10 ec				djnz .fb2 
067f			 
067f eb				ex de, hl 
0680 c9				ret 
0681			 
0681			; Get File ID 
0681			; ----------- 
0681			; 
0681			; With current bank 
0681			;  
0681			; Load Block 0 Config 
0681			; Get max file id number 
0681			; For each logical block 
0681			;    Read block file id 
0681			;      If first block of file and dont have file id 
0681			;         if file get id and exit 
0681			 
0681			 
0681			 
0681			 
0681			; Create File 
0681			; ----------- 
0681			; 
0681			; With current bank  
0681			; Load Block 0 Config 
0681			; Get max file id number 
0681			; Increment file id number 
0681			; Save Config 
0681			; Find free block 
0681			; Set buffer with file name and file id 
0681			; Write buffer to free block  
0681			 
0681			 
0681			; hl point to file name 
0681			; hl returns file id 
0681			 
0681			; file format: 
0681			; byte 0 - file id 
0681			; byte 1 - extent number 
0681			; byte 2-> data 
0681			 
0681			; format for extent number 0: 
0681			; 
0681			; byte 0 - file id 
0681			; byte 1 - extent 0 
0681			; byte 2 - extent count 
0681			; byte 3 -> file name and meta data 
0681			 
0681			 
0681			storage_create: 
0681				if DEBUG_STORESE 
0681					DMARK "SCR" 
0681 f5				push af  
0682 3a 96 06			ld a, (.dmark)  
0685 32 5e ee			ld (debug_mark),a  
0688 3a 97 06			ld a, (.dmark+1)  
068b 32 5f ee			ld (debug_mark+1),a  
068e 3a 98 06			ld a, (.dmark+2)  
0691 32 60 ee			ld (debug_mark+2),a  
0694 18 03			jr .pastdmark  
0696 ..			.dmark: db "SCR"  
0699 f1			.pastdmark: pop af  
069a			endm  
# End of macro DMARK
069a					CALLMONITOR 
069a cd 6b ee			call debug_vector  
069d				endm  
# End of macro CALLMONITOR
069d				endif 
069d			 
069d e5				push hl		; save file name pointer 
069e			 
069e cd 35 03			call storage_get_block_0 
06a1			 
06a1 3a 6d ea			ld a,(store_page)	; get current file id 
06a4 3c				inc a 
06a5 32 6d ea			ld (store_page),a 
06a8				 
06a8 32 61 ea			ld (store_tmpid),a			; save id 
06ab			 
06ab 21 00 00			ld hl, 0 
06ae 11 6d ea			ld de, store_page 
06b1				if DEBUG_STORESE 
06b1					DMARK "SCw" 
06b1 f5				push af  
06b2 3a c6 06			ld a, (.dmark)  
06b5 32 5e ee			ld (debug_mark),a  
06b8 3a c7 06			ld a, (.dmark+1)  
06bb 32 5f ee			ld (debug_mark+1),a  
06be 3a c8 06			ld a, (.dmark+2)  
06c1 32 60 ee			ld (debug_mark+2),a  
06c4 18 03			jr .pastdmark  
06c6 ..			.dmark: db "SCw"  
06c9 f1			.pastdmark: pop af  
06ca			endm  
# End of macro DMARK
06ca					CALLMONITOR 
06ca cd 6b ee			call debug_vector  
06cd				endm  
# End of macro CALLMONITOR
06cd				endif 
06cd cd ec 02			call storage_write_block	 ; save update 
06d0			 
06d0				if DEBUG_STORESE 
06d0 11 6d ea				ld de, store_page 
06d3					DMARK "SCC" 
06d3 f5				push af  
06d4 3a e8 06			ld a, (.dmark)  
06d7 32 5e ee			ld (debug_mark),a  
06da 3a e9 06			ld a, (.dmark+1)  
06dd 32 5f ee			ld (debug_mark+1),a  
06e0 3a ea 06			ld a, (.dmark+2)  
06e3 32 60 ee			ld (debug_mark+2),a  
06e6 18 03			jr .pastdmark  
06e8 ..			.dmark: db "SCC"  
06eb f1			.pastdmark: pop af  
06ec			endm  
# End of macro DMARK
06ec					CALLMONITOR 
06ec cd 6b ee			call debug_vector  
06ef				endm  
# End of macro CALLMONITOR
06ef				endif 
06ef				;  
06ef				 
06ef 21 40 00			ld hl, STORE_BLOCK_PHY 
06f2 11 00 00			ld de, 0 
06f5 cd b3 05			call storage_findnextid 
06f8			 
06f8 22 58 ea			ld (store_tmppageid), hl    ; save page to use  
06fb			 
06fb				; TODO detect 0 = no spare blocks 
06fb			 
06fb				; hl now contains the free page to use for the file header page 
06fb			 
06fb				if DEBUG_STORESE 
06fb				DMARK "SCF" 
06fb f5				push af  
06fc 3a 10 07			ld a, (.dmark)  
06ff 32 5e ee			ld (debug_mark),a  
0702 3a 11 07			ld a, (.dmark+1)  
0705 32 5f ee			ld (debug_mark+1),a  
0708 3a 12 07			ld a, (.dmark+2)  
070b 32 60 ee			ld (debug_mark+2),a  
070e 18 03			jr .pastdmark  
0710 ..			.dmark: db "SCF"  
0713 f1			.pastdmark: pop af  
0714			endm  
# End of macro DMARK
0714					CALLMONITOR 
0714 cd 6b ee			call debug_vector  
0717				endm  
# End of macro CALLMONITOR
0717				endif 
0717			 
0717 22 58 ea			ld (store_tmppageid), hl 
071a				 
071a 3a 61 ea			ld a,(store_tmpid)    ; get file id 
071d			;	ld a, (store_filecache)			; save to cache 
071d			 
071d 32 6d ea			ld (store_page),a    ; set page id 
0720 3e 00			ld a, 0			 ; extent 0 is file header 
0722 32 6e ea			ld (store_page+1), a   ; set file extent 
0725			 
0725 32 6f ea			ld (store_page+2), a   ; extent count for the file 
0728			 
0728			;	inc hl 		; init block 0 of file 
0728			;	inc hl   		; skip file and extent id 
0728			 ;       ld a, 0 
0728			;	ld (hl),a 
0728			;	ld a, (store_filecache+1)  	; save to cache 
0728			 
0728			;	inc hl    ; file name 
0728				 
0728				 
0728 11 70 ea			ld de, store_page+3    ; get buffer for term string to use as file name 
072b				if DEBUG_STORESE 
072b					DMARK "SCc" 
072b f5				push af  
072c 3a 40 07			ld a, (.dmark)  
072f 32 5e ee			ld (debug_mark),a  
0732 3a 41 07			ld a, (.dmark+1)  
0735 32 5f ee			ld (debug_mark+1),a  
0738 3a 42 07			ld a, (.dmark+2)  
073b 32 60 ee			ld (debug_mark+2),a  
073e 18 03			jr .pastdmark  
0740 ..			.dmark: db "SCc"  
0743 f1			.pastdmark: pop af  
0744			endm  
# End of macro DMARK
0744					CALLMONITOR 
0744 cd 6b ee			call debug_vector  
0747				endm  
# End of macro CALLMONITOR
0747				endif 
0747 e1				pop hl    ; get zero term string 
0748 e5				push hl 
0749 3e 00			ld a, 0 
074b cd 49 11			call strlent 
074e 23				inc hl   ; cover zero term 
074f 06 00			ld b,0 
0751 4d				ld c,l 
0752 e1				pop hl 
0753				;ex de, hl 
0753				if DEBUG_STORESE 
0753					DMARK "SCa" 
0753 f5				push af  
0754 3a 68 07			ld a, (.dmark)  
0757 32 5e ee			ld (debug_mark),a  
075a 3a 69 07			ld a, (.dmark+1)  
075d 32 5f ee			ld (debug_mark+1),a  
0760 3a 6a 07			ld a, (.dmark+2)  
0763 32 60 ee			ld (debug_mark+2),a  
0766 18 03			jr .pastdmark  
0768 ..			.dmark: db "SCa"  
076b f1			.pastdmark: pop af  
076c			endm  
# End of macro DMARK
076c					;push af 
076c					;ld a, 'a' 
076c					;ld (debug_mark),a 
076c					;pop af 
076c					CALLMONITOR 
076c cd 6b ee			call debug_vector  
076f				endm  
# End of macro CALLMONITOR
076f				endif 
076f ed b0			ldir    ; copy zero term string 
0771				if DEBUG_STORESE 
0771					DMARK "SCA" 
0771 f5				push af  
0772 3a 86 07			ld a, (.dmark)  
0775 32 5e ee			ld (debug_mark),a  
0778 3a 87 07			ld a, (.dmark+1)  
077b 32 5f ee			ld (debug_mark+1),a  
077e 3a 88 07			ld a, (.dmark+2)  
0781 32 60 ee			ld (debug_mark+2),a  
0784 18 03			jr .pastdmark  
0786 ..			.dmark: db "SCA"  
0789 f1			.pastdmark: pop af  
078a			endm  
# End of macro DMARK
078a					CALLMONITOR 
078a cd 6b ee			call debug_vector  
078d				endm  
# End of macro CALLMONITOR
078d				endif 
078d			 
078d				; write file header page 
078d			 
078d 2a 58 ea			ld hl,(store_tmppageid) 
0790 11 6d ea			ld de, store_page 
0793				if DEBUG_STORESE 
0793					DMARK "SCb" 
0793 f5				push af  
0794 3a a8 07			ld a, (.dmark)  
0797 32 5e ee			ld (debug_mark),a  
079a 3a a9 07			ld a, (.dmark+1)  
079d 32 5f ee			ld (debug_mark+1),a  
07a0 3a aa 07			ld a, (.dmark+2)  
07a3 32 60 ee			ld (debug_mark+2),a  
07a6 18 03			jr .pastdmark  
07a8 ..			.dmark: db "SCb"  
07ab f1			.pastdmark: pop af  
07ac			endm  
# End of macro DMARK
07ac					;push af 
07ac					;ld a, 'b' 
07ac					;ld (debug_mark),a 
07ac					;pop af 
07ac					CALLMONITOR 
07ac cd 6b ee			call debug_vector  
07af				endm  
# End of macro CALLMONITOR
07af				endif 
07af cd ec 02			call storage_write_block 
07b2			 
07b2 3a 61 ea			ld a, (store_tmpid) 
07b5 6f				ld l, a 
07b6 26 00			ld h,0 
07b8				if DEBUG_STORESE 
07b8					DMARK "SCz" 
07b8 f5				push af  
07b9 3a cd 07			ld a, (.dmark)  
07bc 32 5e ee			ld (debug_mark),a  
07bf 3a ce 07			ld a, (.dmark+1)  
07c2 32 5f ee			ld (debug_mark+1),a  
07c5 3a cf 07			ld a, (.dmark+2)  
07c8 32 60 ee			ld (debug_mark+2),a  
07cb 18 03			jr .pastdmark  
07cd ..			.dmark: db "SCz"  
07d0 f1			.pastdmark: pop af  
07d1			endm  
# End of macro DMARK
07d1					CALLMONITOR 
07d1 cd 6b ee			call debug_vector  
07d4				endm  
# End of macro CALLMONITOR
07d4				endif 
07d4 c9				ret 
07d5				 
07d5			 
07d5			 
07d5			; 
07d5			; Read File 
07d5			; 
07d5			; h - file id to locate 
07d5			; l - extent to locate 
07d5			; de - pointer to string to read into 
07d5			; 
07d5			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
07d5			 
07d5			.sr_fail: 
07d5 d1				pop de 
07d6 c9				ret 
07d7			 
07d7			storage_read: 
07d7			 
07d7			 
07d7 d5				push de 
07d8			 
07d8			; TODO BUG the above push is it popped before the RET Z? 
07d8			 
07d8			; TODO how to handle multiple part blocks 
07d8			 
07d8				; locate file extent to read 
07d8			 
07d8 5c				ld e, h 
07d9 55				ld d, l 
07da			 
07da			.srext: 
07da 22 6b ea			ld (store_readptr), hl     ; save the current extent to load 
07dd ed 53 69 ea		ld (store_readbuf), de     ; save the current buffer to load in to 
07e1			 
07e1 21 40 00			ld hl, STORE_BLOCK_PHY 
07e4				if DEBUG_STORESE 
07e4					DMARK "sre" 
07e4 f5				push af  
07e5 3a f9 07			ld a, (.dmark)  
07e8 32 5e ee			ld (debug_mark),a  
07eb 3a fa 07			ld a, (.dmark+1)  
07ee 32 5f ee			ld (debug_mark+1),a  
07f1 3a fb 07			ld a, (.dmark+2)  
07f4 32 60 ee			ld (debug_mark+2),a  
07f7 18 03			jr .pastdmark  
07f9 ..			.dmark: db "sre"  
07fc f1			.pastdmark: pop af  
07fd			endm  
# End of macro DMARK
07fd					CALLMONITOR 
07fd cd 6b ee			call debug_vector  
0800				endm  
# End of macro CALLMONITOR
0800				endif 
0800 cd b3 05			call storage_findnextid 
0803			 
0803				if DEBUG_STORESE 
0803					DMARK "srf" 
0803 f5				push af  
0804 3a 18 08			ld a, (.dmark)  
0807 32 5e ee			ld (debug_mark),a  
080a 3a 19 08			ld a, (.dmark+1)  
080d 32 5f ee			ld (debug_mark+1),a  
0810 3a 1a 08			ld a, (.dmark+2)  
0813 32 60 ee			ld (debug_mark+2),a  
0816 18 03			jr .pastdmark  
0818 ..			.dmark: db "srf"  
081b f1			.pastdmark: pop af  
081c			endm  
# End of macro DMARK
081c					CALLMONITOR 
081c cd 6b ee			call debug_vector  
081f				endm  
# End of macro CALLMONITOR
081f				endif 
081f cd 0f 0e			call ishlzero 
0822			;	ld a, l 
0822			;	add h 
0822			;	cp 0 
0822 28 b1			jr z,.sr_fail			; block not found so EOF 
0824			 
0824				; save current address for use by higher level words etc 
0824			 
0824 22 5e ea			ld (store_openaddr),hl 
0827			 
0827			 
0827				; hl contains page number to load 
0827 d1				pop de   ; get storage 
0828 ed 53 69 ea		ld (store_readbuf), de     ; current buffer to load in to 
082c d5				push de 
082d				if DEBUG_STORESE 
082d					DMARK "srg" 
082d f5				push af  
082e 3a 42 08			ld a, (.dmark)  
0831 32 5e ee			ld (debug_mark),a  
0834 3a 43 08			ld a, (.dmark+1)  
0837 32 5f ee			ld (debug_mark+1),a  
083a 3a 44 08			ld a, (.dmark+2)  
083d 32 60 ee			ld (debug_mark+2),a  
0840 18 03			jr .pastdmark  
0842 ..			.dmark: db "srg"  
0845 f1			.pastdmark: pop af  
0846			endm  
# End of macro DMARK
0846					CALLMONITOR 
0846 cd 6b ee			call debug_vector  
0849				endm  
# End of macro CALLMONITOR
0849				endif 
0849 cd 87 02			call storage_read_block 
084c			 
084c				; if this a continuation read??? 
084c			 
084c 2a 69 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
084f			 
084f 3e 3f			ld a, STORE_BLOCK_PHY-1 
0851 cd e6 0d			call addatohl 
0854 7e				ld a,(hl) 
0855			;	cp 0 
0855 b7				or a 
0856 28 02			jr z, .markiscont 
0858 3e ff			ld a, 255 
085a			 
085a			.markiscont: 
085a 32 60 ea			ld (store_readcont), a 
085d			 
085d				if DEBUG_STORESE 
085d					DMARK "srC" 
085d f5				push af  
085e 3a 72 08			ld a, (.dmark)  
0861 32 5e ee			ld (debug_mark),a  
0864 3a 73 08			ld a, (.dmark+1)  
0867 32 5f ee			ld (debug_mark+1),a  
086a 3a 74 08			ld a, (.dmark+2)  
086d 32 60 ee			ld (debug_mark+2),a  
0870 18 03			jr .pastdmark  
0872 ..			.dmark: db "srC"  
0875 f1			.pastdmark: pop af  
0876			endm  
# End of macro DMARK
0876					CALLMONITOR 
0876 cd 6b ee			call debug_vector  
0879				endm  
# End of macro CALLMONITOR
0879				endif 
0879				; only short reads enabled 
0879			 
0879 3a 68 ea			ld a, (store_longread) 
087c			;	cp 0 
087c b7				or a 
087d ca 49 09			jp z, .readdone 
0880			 
0880			; TODO if block has no zeros then need to read next block  
0880			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
0880			; check last byte of physical block. 
0880			; if not zero then the next block needs to be loaded 
0880			 
0880			 
0880 2a 69 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
0883			 
0883 3e 3f			ld a, STORE_BLOCK_PHY-1 
0885 cd e6 0d			call addatohl 
0888				;dec hl 
0888 7e				ld a,(hl) 
0889				if DEBUG_STORESE 
0889					DMARK "sr?" 
0889 f5				push af  
088a 3a 9e 08			ld a, (.dmark)  
088d 32 5e ee			ld (debug_mark),a  
0890 3a 9f 08			ld a, (.dmark+1)  
0893 32 5f ee			ld (debug_mark+1),a  
0896 3a a0 08			ld a, (.dmark+2)  
0899 32 60 ee			ld (debug_mark+2),a  
089c 18 03			jr .pastdmark  
089e ..			.dmark: db "sr?"  
08a1 f1			.pastdmark: pop af  
08a2			endm  
# End of macro DMARK
08a2					CALLMONITOR 
08a2 cd 6b ee			call debug_vector  
08a5				endm  
# End of macro CALLMONITOR
08a5				endif 
08a5			;	cp 0 
08a5 b7				or a 
08a6 ca 49 09			jp z, .readdone 
08a9			 
08a9				; last byte is not zero so there is more in the next extent. Load it on the end.	 
08a9			 
08a9 23				inc hl 
08aa			 
08aa 22 69 ea			ld (store_readbuf), hl     ; save the current buffer to load in to 
08ad			 
08ad ed 5b 6b ea		ld de, (store_readptr)     ; save the current extent to load 
08b1			 
08b1 eb				ex de, hl 
08b2			 
08b2				; next ext 
08b2			 
08b2 23				inc hl 
08b3 22 6b ea			ld  (store_readptr), hl     ; save the current extent to load 
08b6			 
08b6				if DEBUG_STORESE 
08b6					DMARK "sF2" 
08b6 f5				push af  
08b7 3a cb 08			ld a, (.dmark)  
08ba 32 5e ee			ld (debug_mark),a  
08bd 3a cc 08			ld a, (.dmark+1)  
08c0 32 5f ee			ld (debug_mark+1),a  
08c3 3a cd 08			ld a, (.dmark+2)  
08c6 32 60 ee			ld (debug_mark+2),a  
08c9 18 03			jr .pastdmark  
08cb ..			.dmark: db "sF2"  
08ce f1			.pastdmark: pop af  
08cf			endm  
# End of macro DMARK
08cf					CALLMONITOR 
08cf cd 6b ee			call debug_vector  
08d2				endm  
# End of macro CALLMONITOR
08d2				endif 
08d2			 
08d2				; get and load block 
08d2			 
08d2 cd b3 05			call storage_findnextid 
08d5			 
08d5				if DEBUG_STORESE 
08d5					DMARK "sf2" 
08d5 f5				push af  
08d6 3a ea 08			ld a, (.dmark)  
08d9 32 5e ee			ld (debug_mark),a  
08dc 3a eb 08			ld a, (.dmark+1)  
08df 32 5f ee			ld (debug_mark+1),a  
08e2 3a ec 08			ld a, (.dmark+2)  
08e5 32 60 ee			ld (debug_mark+2),a  
08e8 18 03			jr .pastdmark  
08ea ..			.dmark: db "sf2"  
08ed f1			.pastdmark: pop af  
08ee			endm  
# End of macro DMARK
08ee					CALLMONITOR 
08ee cd 6b ee			call debug_vector  
08f1				endm  
# End of macro CALLMONITOR
08f1				endif 
08f1 cd 0f 0e			call ishlzero 
08f4			;	ld a, l 
08f4			;	add h 
08f4			;	cp 0 
08f4 ca d5 07			jp z,.sr_fail			; block not found so EOF 
08f7				 
08f7				; save current address for use by higher level words etc 
08f7			 
08f7 22 5e ea			ld (store_openaddr),hl 
08fa			 
08fa cd 87 02			call storage_read_block 
08fd			 
08fd				; on a continuation block, we now have the file id and ext in the middle of the block 
08fd				; we need to pull everything back  
08fd			 
08fd ed 5b 69 ea		ld de, (store_readbuf)     ; current buffer to nudge into 
0901 2a 69 ea			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0904 23				inc hl 
0905 23				inc hl     ; skip id and ext 
0906 01 40 00			ld bc, STORE_BLOCK_PHY 
0909				if DEBUG_STORESE 
0909					DMARK "SR<" 
0909 f5				push af  
090a 3a 1e 09			ld a, (.dmark)  
090d 32 5e ee			ld (debug_mark),a  
0910 3a 1f 09			ld a, (.dmark+1)  
0913 32 5f ee			ld (debug_mark+1),a  
0916 3a 20 09			ld a, (.dmark+2)  
0919 32 60 ee			ld (debug_mark+2),a  
091c 18 03			jr .pastdmark  
091e ..			.dmark: db "SR<"  
0921 f1			.pastdmark: pop af  
0922			endm  
# End of macro DMARK
0922					CALLMONITOR 
0922 cd 6b ee			call debug_vector  
0925				endm  
# End of macro CALLMONITOR
0925				endif 
0925 ed b0			ldir     ; copy data 
0927			 
0927				; move the pointer back and pretend we have a full buffer for next recheck 
0927			 
0927 1b				dec de 
0928 1b				dec de 
0929			 
0929			; TODO do pop below now short circuit loop????? 
0929 c1				pop bc     ; get rid of spare de on stack 
092a				if DEBUG_STORESE 
092a					DMARK "SR>" 
092a f5				push af  
092b 3a 3f 09			ld a, (.dmark)  
092e 32 5e ee			ld (debug_mark),a  
0931 3a 40 09			ld a, (.dmark+1)  
0934 32 5f ee			ld (debug_mark+1),a  
0937 3a 41 09			ld a, (.dmark+2)  
093a 32 60 ee			ld (debug_mark+2),a  
093d 18 03			jr .pastdmark  
093f ..			.dmark: db "SR>"  
0942 f1			.pastdmark: pop af  
0943			endm  
# End of macro DMARK
0943					CALLMONITOR 
0943 cd 6b ee			call debug_vector  
0946				endm  
# End of macro CALLMONITOR
0946				endif 
0946 c3 da 07			jp .srext 
0949			 
0949			 
0949			 
0949			 
0949			 
0949			.readdone:		 
0949 e1				pop hl 		 ; return start of data to show as not EOF 
094a 23				inc hl   ; past file id 
094b 23				inc hl   ; past ext 
094c				if DEBUG_STORESE 
094c					DMARK "SRe" 
094c f5				push af  
094d 3a 61 09			ld a, (.dmark)  
0950 32 5e ee			ld (debug_mark),a  
0953 3a 62 09			ld a, (.dmark+1)  
0956 32 5f ee			ld (debug_mark+1),a  
0959 3a 63 09			ld a, (.dmark+2)  
095c 32 60 ee			ld (debug_mark+2),a  
095f 18 03			jr .pastdmark  
0961 ..			.dmark: db "SRe"  
0964 f1			.pastdmark: pop af  
0965			endm  
# End of macro DMARK
0965					CALLMONITOR 
0965 cd 6b ee			call debug_vector  
0968				endm  
# End of macro CALLMONITOR
0968				endif 
0968 c9					ret 
0969			 
0969			 
0969			 
0969			; 
0969			; Append File 
0969			; 
0969			; hl - file id to locate 
0969			; de - pointer to (multi block) string to write 
0969			 
0969			.sa_notfound: 
0969 d1				pop de 
096a c9				ret 
096b			 
096b			 
096b			storage_append: 
096b				; hl -  file id to append to 
096b				; de - string to append 
096b			 
096b d5				push de 
096c				 
096c				if DEBUG_STORESE 
096c					DMARK "AP1" 
096c f5				push af  
096d 3a 81 09			ld a, (.dmark)  
0970 32 5e ee			ld (debug_mark),a  
0973 3a 82 09			ld a, (.dmark+1)  
0976 32 5f ee			ld (debug_mark+1),a  
0979 3a 83 09			ld a, (.dmark+2)  
097c 32 60 ee			ld (debug_mark+2),a  
097f 18 03			jr .pastdmark  
0981 ..			.dmark: db "AP1"  
0984 f1			.pastdmark: pop af  
0985			endm  
# End of macro DMARK
0985					CALLMONITOR 
0985 cd 6b ee			call debug_vector  
0988				endm  
# End of macro CALLMONITOR
0988				endif 
0988			 
0988 7d				ld a, l 
0989 32 61 ea			ld (store_tmpid), a 
098c			 
098c				; get file header  
098c			 
098c 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
098e 3a 61 ea			ld a, (store_tmpid) 
0991 5f				ld e, a 
0992			 
0992 21 40 00				ld hl, STORE_BLOCK_PHY 
0995 cd b3 05				call storage_findnextid 
0998			 
0998 cd 0f 0e			call ishlzero 
099b 28 cc			jr z, .sa_notfound 
099d			 
099d 22 58 ea			ld (store_tmppageid), hl 
09a0			 
09a0				; TODO handle file id not found 
09a0			 
09a0				if DEBUG_STORESE 
09a0					DMARK "AP2" 
09a0 f5				push af  
09a1 3a b5 09			ld a, (.dmark)  
09a4 32 5e ee			ld (debug_mark),a  
09a7 3a b6 09			ld a, (.dmark+1)  
09aa 32 5f ee			ld (debug_mark+1),a  
09ad 3a b7 09			ld a, (.dmark+2)  
09b0 32 60 ee			ld (debug_mark+2),a  
09b3 18 03			jr .pastdmark  
09b5 ..			.dmark: db "AP2"  
09b8 f1			.pastdmark: pop af  
09b9			endm  
# End of macro DMARK
09b9					CALLMONITOR 
09b9 cd 6b ee			call debug_vector  
09bc				endm  
# End of macro CALLMONITOR
09bc				endif 
09bc			 
09bc				; update file extent count 
09bc			 
09bc 11 6d ea			ld de, store_page 
09bf			 
09bf cd 87 02			call storage_read_block 
09c2			 
09c2				if DEBUG_STORESE 
09c2					DMARK "AP3" 
09c2 f5				push af  
09c3 3a d7 09			ld a, (.dmark)  
09c6 32 5e ee			ld (debug_mark),a  
09c9 3a d8 09			ld a, (.dmark+1)  
09cc 32 5f ee			ld (debug_mark+1),a  
09cf 3a d9 09			ld a, (.dmark+2)  
09d2 32 60 ee			ld (debug_mark+2),a  
09d5 18 03			jr .pastdmark  
09d7 ..			.dmark: db "AP3"  
09da f1			.pastdmark: pop af  
09db			endm  
# End of macro DMARK
09db					CALLMONITOR 
09db cd 6b ee			call debug_vector  
09de				endm  
# End of macro CALLMONITOR
09de				endif 
09de			;	ld (store_tmppageid), hl 
09de			 
09de 3a 6f ea			ld a, (store_page+2) 
09e1 3c				inc a 
09e2 32 6f ea			ld (store_page+2), a 
09e5 32 60 ea			ld (store_tmpext), a 
09e8				 
09e8				if DEBUG_STORESE 
09e8					DMARK "AP3" 
09e8 f5				push af  
09e9 3a fd 09			ld a, (.dmark)  
09ec 32 5e ee			ld (debug_mark),a  
09ef 3a fe 09			ld a, (.dmark+1)  
09f2 32 5f ee			ld (debug_mark+1),a  
09f5 3a ff 09			ld a, (.dmark+2)  
09f8 32 60 ee			ld (debug_mark+2),a  
09fb 18 03			jr .pastdmark  
09fd ..			.dmark: db "AP3"  
0a00 f1			.pastdmark: pop af  
0a01			endm  
# End of macro DMARK
0a01					CALLMONITOR 
0a01 cd 6b ee			call debug_vector  
0a04				endm  
# End of macro CALLMONITOR
0a04				endif 
0a04 2a 58 ea			ld hl, (store_tmppageid) 
0a07 11 6d ea			ld de, store_page 
0a0a cd ec 02			call storage_write_block 
0a0d			 
0a0d				; find free block 
0a0d			 
0a0d 11 00 00			ld de, 0			 ; file extent to locate 
0a10			 
0a10 21 40 00				ld hl, STORE_BLOCK_PHY 
0a13 cd b3 05				call storage_findnextid 
0a16 cd 0f 0e			call ishlzero 
0a19 ca 69 09			jp z, .sa_notfound 
0a1c			 
0a1c					; TODO handle no space left 
0a1c					 
0a1c 22 58 ea				ld (store_tmppageid), hl 
0a1f			 
0a1f				if DEBUG_STORESE 
0a1f					DMARK "AP4" 
0a1f f5				push af  
0a20 3a 34 0a			ld a, (.dmark)  
0a23 32 5e ee			ld (debug_mark),a  
0a26 3a 35 0a			ld a, (.dmark+1)  
0a29 32 5f ee			ld (debug_mark+1),a  
0a2c 3a 36 0a			ld a, (.dmark+2)  
0a2f 32 60 ee			ld (debug_mark+2),a  
0a32 18 03			jr .pastdmark  
0a34 ..			.dmark: db "AP4"  
0a37 f1			.pastdmark: pop af  
0a38			endm  
# End of macro DMARK
0a38					CALLMONITOR 
0a38 cd 6b ee			call debug_vector  
0a3b				endm  
# End of macro CALLMONITOR
0a3b				endif 
0a3b					; init the buffer with zeros so we can id if the buffer is full or not 
0a3b			 
0a3b e5					push hl 
0a3c c5					push bc 
0a3d			 
0a3d 21 6d ea				ld hl, store_page 
0a40 06 40				ld b, STORE_BLOCK_PHY 
0a42			;		ld a, 0 
0a42 36 00		.zeroblock:	ld (hl), 0 
0a44 23					inc hl 
0a45 10 fb				djnz .zeroblock 
0a47			 
0a47 c1					pop bc 
0a48 e1					pop hl 
0a49			 
0a49					; construct block 
0a49			 
0a49 3a 61 ea				ld a, (store_tmpid) 
0a4c 32 6d ea				ld (store_page), a   ; file id 
0a4f 3a 60 ea				ld a, (store_tmpext)   ; extent for this block 
0a52 32 6e ea				ld (store_page+1), a 
0a55			 
0a55 e1					pop hl    ; get string to write 
0a56 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0a58 11 6f ea				ld de, store_page+2 
0a5b			 
0a5b				if DEBUG_STORESE 
0a5b					DMARK "AP5" 
0a5b f5				push af  
0a5c 3a 70 0a			ld a, (.dmark)  
0a5f 32 5e ee			ld (debug_mark),a  
0a62 3a 71 0a			ld a, (.dmark+1)  
0a65 32 5f ee			ld (debug_mark+1),a  
0a68 3a 72 0a			ld a, (.dmark+2)  
0a6b 32 60 ee			ld (debug_mark+2),a  
0a6e 18 03			jr .pastdmark  
0a70 ..			.dmark: db "AP5"  
0a73 f1			.pastdmark: pop af  
0a74			endm  
# End of macro DMARK
0a74					CALLMONITOR 
0a74 cd 6b ee			call debug_vector  
0a77				endm  
# End of macro CALLMONITOR
0a77				endif 
0a77			 
0a77			 
0a77			 
0a77					; fill buffer with data until end of string or full block 
0a77			 
0a77 7e			.appd:		ld a, (hl) 
0a78 12					ld (de), a 
0a79			;		cp 0 
0a79 b7					or a 
0a7a 28 04				jr z, .appdone 
0a7c 23					inc hl 
0a7d 13					inc de 
0a7e 10 f7				djnz .appd 
0a80			 
0a80 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0a81 f5					push af   		; save last byte dumped 
0a82			 
0a82			 
0a82 2a 58 ea			ld hl, (store_tmppageid) 
0a85 11 6d ea			ld de, store_page 
0a88				if DEBUG_STORESE 
0a88					DMARK "AP6" 
0a88 f5				push af  
0a89 3a 9d 0a			ld a, (.dmark)  
0a8c 32 5e ee			ld (debug_mark),a  
0a8f 3a 9e 0a			ld a, (.dmark+1)  
0a92 32 5f ee			ld (debug_mark+1),a  
0a95 3a 9f 0a			ld a, (.dmark+2)  
0a98 32 60 ee			ld (debug_mark+2),a  
0a9b 18 03			jr .pastdmark  
0a9d ..			.dmark: db "AP6"  
0aa0 f1			.pastdmark: pop af  
0aa1			endm  
# End of macro DMARK
0aa1					CALLMONITOR 
0aa1 cd 6b ee			call debug_vector  
0aa4				endm  
# End of macro CALLMONITOR
0aa4				endif 
0aa4 cd ec 02				call storage_write_block 
0aa7			 
0aa7			 
0aa7				; was that a full block of data written? 
0aa7				; any more to write out? 
0aa7			 
0aa7				; if yes then set vars and jump to start of function again 
0aa7			 
0aa7 f1					pop af 
0aa8 d1					pop de 
0aa9			 
0aa9					;cp 0		 ; no, string was fully written 
0aa9 b7					or a 
0aaa c8					ret z 
0aab			 
0aab					; setup vars for next cycle 
0aab			 
0aab 3a 61 ea				ld a, (store_tmpid) 
0aae 6f					ld l, a 
0aaf 26 00				ld h, 0 
0ab1			 
0ab1 c3 6b 09			 	jp storage_append	 ; yes, need to write out some more 
0ab4			 
0ab4			 
0ab4			 
0ab4			 
0ab4			 
0ab4			 
0ab4			 
0ab4			if DEBUG_STORECF 
0ab4			storageput:	 
0ab4					ret 
0ab4			storageread: 
0ab4					ld hl, store_page 
0ab4					ld b, 200 
0ab4			;		ld a,0 
0ab4			.src:		ld (hl),0 
0ab4					inc hl 
0ab4					djnz .src 
0ab4					 
0ab4			 
0ab4					ld de, 0 
0ab4					ld bc, 1 
0ab4					ld hl, store_page 
0ab4					call cfRead 
0ab4			 
0ab4				call cfGetError 
0ab4				ld hl,scratch 
0ab4				call hexout 
0ab4				ld hl, scratch+2 
0ab4			;	ld a, 0 
0ab4				ld (hl),0 
0ab4				ld de, scratch 
0ab4				ld a,display_row_1 
0ab4				call str_at_display 
0ab4				call update_display 
0ab4			 
0ab4					ld hl, store_page 
0ab4					ld (os_cur_ptr),hl 
0ab4			 
0ab4					ret 
0ab4			endif 
0ab4			 
0ab4			 
0ab4			; Clear out the main buffer store (used to remove junk before writing a new block) 
0ab4			 
0ab4			storage_clear_page: 
0ab4 e5				push hl 
0ab5 d5				push de 
0ab6 c5				push bc 
0ab7 21 6d ea			ld hl, store_page 
0aba			;	ld a, 0 
0aba 36 00			ld (hl), 0 
0abc			 
0abc 11 6e ea			ld de, store_page+1 
0abf 01 19 01			ld bc, STORE_BLOCK_LOG+1 
0ac2			 
0ac2 ed b0			ldir 
0ac4				 
0ac4 c1				pop bc 
0ac5 d1				pop de 
0ac6 e1				pop hl 
0ac7 c9				ret 
0ac8			 
0ac8			; eof 
# End of file firmware_storage.asm
0ac8			  
0ac8			; support routines for above hardware abstraction layer  
0ac8			  
0ac8			include "firmware_general.asm"        ; general support functions  
0ac8			 
0ac8			; word look up 
0ac8			 
0ac8			; in 
0ac8			; a is the index 
0ac8			; hl is pointer start of array 
0ac8			; 
0ac8			; returns 
0ac8			; hl to the word 
0ac8			; 
0ac8			 
0ac8			table_lookup:  
0ac8 d5					push de 
0ac9 eb					ex de, hl 
0aca			 
0aca 6f					ld l, a 
0acb 26 00				ld h, 0 
0acd 29					add hl, hl 
0ace 19					add hl, de 
0acf 7e					ld a, (hl) 
0ad0 23					inc hl 
0ad1 66					ld h,(hl) 
0ad2 6f					ld l, a 
0ad3			 
0ad3 d1					pop de 
0ad4 c9					ret 
0ad5			 
0ad5			; Delay loops 
0ad5			 
0ad5			 
0ad5			 
0ad5			aDelayInMS: 
0ad5 c5				push bc 
0ad6 47				ld b,a 
0ad7			msdelay: 
0ad7 c5				push bc 
0ad8				 
0ad8			 
0ad8 01 41 00			ld bc,041h 
0adb cd f3 0a			call delayloop 
0ade c1				pop bc 
0adf 05				dec b 
0ae0 20 f5			jr nz,msdelay 
0ae2			 
0ae2			;if CPU_CLOCK_8MHZ 
0ae2			;msdelay8: 
0ae2			;	push bc 
0ae2			;	 
0ae2			; 
0ae2			;	ld bc,041h 
0ae2			;	call delayloop 
0ae2			;	pop bc 
0ae2			;	dec b 
0ae2			;	jr nz,msdelay8 
0ae2			;endif 
0ae2			 
0ae2			 
0ae2 c1				pop bc 
0ae3 c9				ret 
0ae4			 
0ae4			 
0ae4			delay250ms: 
0ae4				;push de 
0ae4 01 00 40			ld bc, 04000h 
0ae7 c3 f3 0a			jp delayloop 
0aea			delay500ms: 
0aea				;push de 
0aea 01 00 80			ld bc, 08000h 
0aed c3 f3 0a			jp delayloop 
0af0			delay1s: 
0af0				;push bc 
0af0			   ; Clobbers A, d and e 
0af0 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0af3			delayloop: 
0af3 c5			    push bc 
0af4			 
0af4			if BASE_CPM 
0af4 01 a0 0f			ld bc, CPM_DELAY_TUNE 
0af7			.cpmloop: 
0af7 c5				push bc 
0af8			 
0af8			endif 
0af8			 
0af8			 
0af8			 
0af8			delayloopi: 
0af8			;	push bc 
0af8			;.dl: 
0af8 cb 47		    bit     0,a    	; 8 
0afa cb 47		    bit     0,a    	; 8 
0afc cb 47		    bit     0,a    	; 8 
0afe e6 ff		    and     255  	; 7 
0b00 0b			    dec     bc      	; 6 
0b01 79			    ld      a,c     	; 4 
0b02 b0			    or      b     	; 4 
0b03 c2 f8 0a		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0b06			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0b06				;pop de 
0b06			;pop bc 
0b06			 
0b06			if BASE_CPM 
0b06 c1				pop bc 
0b07				 
0b07 0b			    dec     bc      	; 6 
0b08 79			    ld      a,c     	; 4 
0b09 b0			    or      b     	; 4 
0b0a c2 f7 0a		    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0b0d				 
0b0d			 
0b0d			endif 
0b0d			;if CPU_CLOCK_8MHZ 
0b0d			;    pop bc 
0b0d			;    push bc 
0b0d			;.dl8: 
0b0d			;    bit     0,a    	; 8 
0b0d			;    bit     0,a    	; 8 
0b0d			;    bit     0,a    	; 8 
0b0d			;    and     255  	; 7 
0b0d			;    dec     bc      	; 6 
0b0d			;    ld      a,c     	; 4 
0b0d			;    or      b     	; 4 
0b0d			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b0d			;endif 
0b0d			 
0b0d			;if CPU_CLOCK_10MHZ 
0b0d			;    pop bc 
0b0d			;    push bc 
0b0d			;.dl8: 
0b0d			;    bit     0,a    	; 8 
0b0d			;    bit     0,a    	; 8 
0b0d			;    bit     0,a    	; 8 
0b0d			;    and     255  	; 7 
0b0d			;    dec     bc      	; 6 
0b0d			;    ld      a,c     	; 4 
0b0d			;    or      b     	; 4 
0b0d			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b0d			;endif 
0b0d c1			    pop bc 
0b0e			 
0b0e c9				ret 
0b0f			 
0b0f			; look for any ldir blank calls and replace with 
0b0f			; hl is the start address 
0b0f			; b is the number of bytes 
0b0f			; a is the char to fill 
0b0f			 
0b0f			 
0b0f			filllen: 
0b0f 77				LD (HL),A      ;STORE BYTE 
0b10 23				INC HL      ; BUMP POINTER 
0b11 10 fc			DJNZ   filllen      ;  CONTINUE IF B NOT 0 
0b13 c9				ret 
0b14			 
0b14			; eof 
# End of file firmware_general.asm
0b14			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0b14			; display routines that use the physical hardware abstraction layer 
0b14			 
0b14			 
0b14			; Display an activity indicator 
0b14			; Each call returns the new char pointed to in hl 
0b14			 
0b14			active: 
0b14 3a b9 eb			ld a, (display_active) 
0b17 fe 06			cp 6 
0b19			 
0b19 20 02			jr nz, .sne 
0b1b				; gone past the last one reset sequence 
0b1b 3e ff			ld a, 255 
0b1d			 
0b1d			.sne:   
0b1d				; get the next char in seq 
0b1d 3c				inc a 
0b1e 32 b9 eb			ld (display_active), a 
0b21			 
0b21				; look up the string in the table 
0b21 21 38 0b			ld hl, actseq 
0b24 cb 27			sla a 
0b26 cd e6 0d			call addatohl 
0b29 cd 40 1e			call loadwordinhl 
0b2c			 
0b2c				; forth will write the to string when pushing so move from rom to ram 
0b2c			 
0b2c 11 ba eb			ld de, display_active+1 
0b2f 01 02 00			ld bc, 2 
0b32 ed b0			ldir 
0b34			 
0b34 21 ba eb			ld hl, display_active+1 
0b37 c9				ret 
0b38				 
0b38				 
0b38			 
0b38			 
0b38			;db "|/-\|-\" 
0b38			 
0b38			actseq: 
0b38			 
0b38 46 0b		dw spin0 
0b3a 48 0b		dw spin1 
0b3c 4a 0b		dw spin2 
0b3e 4c 0b		dw spin3 
0b40 4a 0b		dw spin2 
0b42 48 0b		dw spin1 
0b44 46 0b		dw spin0 
0b46			 
0b46 .. 00		spin0: db " ", 0 
0b48 .. 00		spin1: db "-", 0 
0b4a .. 00		spin2: db "+", 0 
0b4c .. 00		spin3: db "#", 0 
0b4e			 
0b4e			 
0b4e			; information window 
0b4e			 
0b4e			; pass hl with 1st string to display 
0b4e			; pass de with 2nd string to display 
0b4e			 
0b4e			info_panel: 
0b4e e5				push hl 
0b4f			 
0b4f 2a bf eb			ld hl, (display_fb_active) 
0b52 e5				push hl    ; future de destination 
0b53 21 a4 ed				ld hl, display_fb0 
0b56 22 bf eb				ld (display_fb_active), hl 
0b59			 
0b59			;	call clear_display 
0b59			 
0b59				if BASE_CPM 
0b59 3e 2e			ld a, '.' 
0b5b				else 
0b5b				ld a, 165 
0b5b				endif 
0b5b cd c1 0b			call fill_display 
0b5e			 
0b5e			 
0b5e 3e 55			ld a, display_row_3 + 5 
0b60 cd ce 0b			call str_at_display 
0b63			 
0b63 e1				pop hl 
0b64 d1				pop de 
0b65			 
0b65 e5				push hl 
0b66			 
0b66			 
0b66 3e 2d			ld a, display_row_2 + 5 
0b68 cd ce 0b			call str_at_display 
0b6b			 
0b6b			 
0b6b cd de 0b			call update_display 
0b6e cd 4f 1a			call next_page_prompt 
0b71 cd bc 0b			call clear_display 
0b74			 
0b74				 
0b74 21 03 ed				ld hl, display_fb1 
0b77 22 bf eb				ld (display_fb_active), hl 
0b7a cd de 0b			call update_display 
0b7d			 
0b7d e1				pop hl 
0b7e			 
0b7e c9				ret 
0b7f			 
0b7f			 
0b7f			 
0b7f			 
0b7f			; TODO windowing? 
0b7f			 
0b7f			; TODO scroll line up 
0b7f			 
0b7f			scroll_up: 
0b7f			 
0b7f e5				push hl 
0b80 d5				push de 
0b81 c5				push bc 
0b82			 
0b82				; get frame buffer  
0b82			 
0b82 2a bf eb			ld hl, (display_fb_active) 
0b85 e5				push hl    ; future de destination 
0b86			 
0b86 11 28 00			ld  de, display_cols 
0b89 19				add hl, de 
0b8a			 
0b8a d1				pop de 
0b8b			 
0b8b				;ex de, hl 
0b8b 01 9f 00			ld bc, display_fb_len -1  
0b8e			;if DEBUG_FORTH_WORDS 
0b8e			;	DMARK "SCL" 
0b8e			;	CALLMONITOR 
0b8e			;endif	 
0b8e ed b0			ldir 
0b90			 
0b90				; wipe bottom row 
0b90			 
0b90			 
0b90 2a bf eb			ld hl, (display_fb_active) 
0b93 11 a0 00			ld de, display_cols*display_rows 
0b96 19				add hl, de 
0b97 06 28			ld b, display_cols 
0b99			;	ld a, ' ' 
0b99			.scwipe: 
0b99 36 20			ld (hl), ' ' 
0b9b 2b				dec hl 
0b9c 10 fb			djnz .scwipe 
0b9e			 
0b9e				;pop hl 
0b9e			 
0b9e c1				pop bc 
0b9f d1				pop de 
0ba0 e1				pop hl 
0ba1			 
0ba1 c9				ret 
0ba2			 
0ba2			 
0ba2			;scroll_upo: 
0ba2			;	ld de, display_row_1 
0ba2			 ;	ld hl, display_row_2 
0ba2			;	ld bc, display_cols 
0ba2			;	ldir 
0ba2			;	ld de, display_row_2 
0ba2			 ;	ld hl, display_row_3 
0ba2			;	ld bc, display_cols 
0ba2			;	ldir 
0ba2			;	ld de, display_row_3 
0ba2			 ;	ld hl, display_row_4 
0ba2			;	ld bc, display_cols 
0ba2			;	ldir 
0ba2			 
0ba2			; TODO clear row 4 
0ba2			 
0ba2			;	ret 
0ba2			 
0ba2				 
0ba2			scroll_down: 
0ba2			 
0ba2 e5				push hl 
0ba3 d5				push de 
0ba4 c5				push bc 
0ba5			 
0ba5				; get frame buffer  
0ba5			 
0ba5 2a bf eb			ld hl, (display_fb_active) 
0ba8			 
0ba8 11 9f 00			ld de, display_fb_len - 1 
0bab 19				add hl, de 
0bac			 
0bac e5			push hl    ; future de destination 
0bad			 
0bad 11 28 00			ld  de, display_cols 
0bb0 ed 52			sbc hl, de 
0bb2			 
0bb2			 
0bb2 d1				pop de 
0bb3			 
0bb3			;	ex de, hl 
0bb3 01 9f 00			ld bc, display_fb_len -1  
0bb6			 
0bb6			 
0bb6				 
0bb6			 
0bb6 ed b0			ldir 
0bb8			 
0bb8				; wipe bottom row 
0bb8			 
0bb8			 
0bb8			;	ld hl, (display_fb_active) 
0bb8			;;	ld de, display_cols*display_rows 
0bb8			;;	add hl, de 
0bb8			;	ld b, display_cols 
0bb8			;	ld a, ' ' 
0bb8			;.scwiped: 
0bb8			;	ld (hl), a 
0bb8			;	dec hl 
0bb8			;	djnz .scwiped 
0bb8			 
0bb8				;pop hl 
0bb8			 
0bb8 c1				pop bc 
0bb9 d1				pop de 
0bba e1				pop hl 
0bbb			 
0bbb c9				ret 
0bbc			;scroll_down: 
0bbc			;	ld de, display_row_4 
0bbc			;	ld hl, display_row_3 
0bbc			;	ld bc, display_cols 
0bbc			;	ldir 
0bbc			;	ld de, display_row_3 
0bbc			; 	ld hl, display_row_2 
0bbc			;	ld bc, display_cols 
0bbc			;	ldir 
0bbc			;	ld de, display_row_2 
0bbc			;	ld hl, display_row_1 
0bbc			;	ld bc, display_cols 
0bbc			;	ldir 
0bbc			;;; TODO clear row 1 
0bbc			;	ret 
0bbc			 
0bbc			 
0bbc			 
0bbc			 
0bbc			 
0bbc			; clear active frame buffer 
0bbc			 
0bbc			clear_display: 
0bbc 3e 20			ld a, ' ' 
0bbe c3 c1 0b			jp fill_display 
0bc1			 
0bc1			; fill active frame buffer with a char in A 
0bc1			 
0bc1			fill_display: 
0bc1 06 a0			ld b,display_fb_len 
0bc3 2a bf eb			ld hl, (display_fb_active) 
0bc6 77			.fd1:	ld (hl),a 
0bc7 23				inc hl 
0bc8 10 fc			djnz .fd1 
0bca 23				inc hl 
0bcb			;	ld a,0 
0bcb 36 00			ld (hl),0 
0bcd			 
0bcd			 
0bcd c9				ret 
0bce			; Write string (DE) at pos (A) to active frame buffer 
0bce			 
0bce 2a bf eb		str_at_display:    ld hl,(display_fb_active) 
0bd1 06 00					ld b,0 
0bd3 4f					ld c,a 
0bd4 09					add hl,bc 
0bd5 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0bd6 b7			            OR   A              ;Null terminator? 
0bd7 c8			            RET  Z              ;Yes, so finished 
0bd8 77					ld (hl),a 
0bd9 23				inc hl 
0bda 13			            INC  DE             ;Point to next character 
0bdb 18 f8		            JR   .sad1     ;Repeat 
0bdd c9					ret 
0bde			 
0bde			; using current frame buffer write to physical display 
0bde			 
0bde			update_display: 
0bde e5				push hl 
0bdf 2a bf eb			ld hl, (display_fb_active) 
0be2 cd c3 66			call write_display 
0be5 e1				pop hl 
0be6 c9				ret 
0be7			 
0be7			; TODO scrolling 
0be7			 
0be7			 
0be7			; move cursor right one char 
0be7			cursor_right: 
0be7			 
0be7				; TODO shift right 
0be7				; TODO if beyond max col 
0be7				; TODO       cursor_next_line 
0be7			 
0be7 c9				ret 
0be8			 
0be8			 
0be8			cursor_next_line: 
0be8				; TODO first char 
0be8				; TODO line down 
0be8				; TODO if past last row 
0be8				; TODO    scroll up 
0be8			 
0be8 c9				ret 
0be9			 
0be9			cursor_left: 
0be9				; TODO shift left 
0be9				; TODO if beyond left  
0be9				; TODO     cursor prev line 
0be9				 
0be9 c9				ret 
0bea			 
0bea			cursor_prev_line: 
0bea				; TODO last char 
0bea				; TODO line up 
0bea				; TODO if past first row 
0bea				; TODO   scroll down 
0bea			 
0bea c9				ret 
0beb			 
0beb			 
0beb			cout: 
0beb				; A - char 
0beb c9				ret 
0bec			 
0bec			 
0bec			; Display a menu and allow item selection (optional toggle items) 
0bec			; 
0bec			; format: 
0bec			; hl pointer to word array with zero term for items 
0bec			; e.g.    db item1 
0bec			;         db .... 
0bec			;         db 0 
0bec			; 
0bec			; a = starting menu item  
0bec			; 
0bec			; de = pointer item toggle array   (todo) 
0bec			; 
0bec			; returns item selected in a 1-... 
0bec			; returns 0 if back button pressed 
0bec			; 
0bec			; NOTE: Uses system frame buffer to display 
0bec			; 
0bec			; LEFT, Q = go back 
0bec			; RIGHT, SPACE, CR = select 
0bec			; UP, A - Up 
0bec			; DOWN, Z - Down 
0bec			 
0bec			 
0bec			 
0bec			 
0bec			 
0bec			menu: 
0bec			 
0bec					; keep array pointer 
0bec			 
0bec 22 66 ea				ld (store_tmp1), hl 
0bef 32 64 ea				ld (store_tmp2), a 
0bf2			 
0bf2					; check for key bounce 
0bf2			 
0bf2			if BASE_KEV 
0bf2			 
0bf2			.mbounce:	call cin 
0bf2			;		cp 0 
0bf2					or a 
0bf2					jr nz, .mbounce 
0bf2			endif 
0bf2					; for ease use ex 
0bf2			 
0bf2					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0bf2 21 a4 ed				ld hl, display_fb0 
0bf5 22 bf eb				ld (display_fb_active), hl 
0bf8			 
0bf8 cd bc 0b		.mloop:		call clear_display 
0bfb cd de 0b				call update_display 
0bfe			 
0bfe					; draw selection id '>' at 1 
0bfe			 
0bfe					; init start of list display 
0bfe			 
0bfe 3e 05				ld a, 5 
0c00 32 62 ea				ld (store_tmp3), a   ; display row count 
0c03 3a 64 ea				ld a,( store_tmp2) 
0c06 32 65 ea				ld (store_tmp2+1), a   ; display item count 
0c09			 
0c09					 
0c09			.mitem:	 
0c09			 
0c09			 
0c09 3a 65 ea				ld a,(store_tmp2+1) 
0c0c 6f					ld l, a 
0c0d 26 00				ld h, 0 
0c0f 29					add hl, hl 
0c10 ed 5b 66 ea			ld de, (store_tmp1) 
0c14 19					add hl, de 
0c15 7e					ld a, (hl) 
0c16 23					inc hl 
0c17 66					ld h,(hl) 
0c18 6f					ld l, a 
0c19			 
0c19 cd 0f 0e				call ishlzero 
0c1c 28 1a				jr z, .mdone 
0c1e			 
0c1e eb					ex de, hl 
0c1f 3a 62 ea				ld a, (store_tmp3) 
0c22 cd ce 0b				call str_at_display 
0c25					 
0c25			 
0c25					; next item 
0c25 3a 65 ea				ld a, (store_tmp2+1) 
0c28 3c					inc a 
0c29 32 65 ea				ld (store_tmp2+1), a   ; display item count 
0c2c			 
0c2c			 		; next row 
0c2c			 
0c2c 3a 62 ea				ld a, (store_tmp3) 
0c2f c6 28				add display_cols 
0c31 32 62 ea				ld (store_tmp3), a 
0c34			 
0c34					; at end of screen? 
0c34			 
0c34 fe 10				cp display_rows*4 
0c36 20 d1				jr nz, .mitem 
0c38			 
0c38			 
0c38			.mdone: 
0c38 cd 0f 0e				call ishlzero 
0c3b 28 08				jr z, .nodn 
0c3d			 
0c3d 3e 78				ld a, display_row_4 
0c3f 11 bc 0c				ld de, .mdown 
0c42 cd ce 0b				call str_at_display 
0c45			 
0c45					; draw options to fill the screens with active item on line 1 
0c45					; if current option is 2 or more then display ^ in top 
0c45			 
0c45 3a 64 ea		.nodn:		ld a, (store_tmp2) 
0c48			;		cp 0 
0c48 b7					or a 
0c49 28 08				jr z, .noup 
0c4b			 
0c4b 3e 00				ld a, 0 
0c4d 11 ba 0c				ld de, .mup 
0c50 cd ce 0b				call str_at_display 
0c53			 
0c53 3e 02		.noup:		ld a, 2 
0c55 11 b8 0c				ld de, .msel 
0c58 cd ce 0b				call str_at_display 
0c5b			 
0c5b					; if current option + 1 is not null then display V in bottom 
0c5b					; get key 
0c5b cd de 0b				call update_display 
0c5e			 
0c5e			 
0c5e					; handle key 
0c5e			 
0c5e cd 7e 67				call cin_wait 
0c61			 
0c61 fe 05				cp KEY_UP 
0c63 28 2b				jr z, .mgoup 
0c65 fe 61				cp 'a' 
0c67 28 27				jr z, .mgoup 
0c69 fe 0a				cp KEY_DOWN 
0c6b 28 31				jr z, .mgod 
0c6d fe 7a				cp 'z' 
0c6f 28 2d				jr z, .mgod 
0c71 fe 20				cp ' ' 
0c73 28 33				jr z, .goend 
0c75 fe 0c				cp KEY_RIGHT 
0c77 28 2f				jr z, .goend 
0c79 fe 0d				cp KEY_CR 
0c7b 28 2b				jr z, .goend 
0c7d fe 71				cp 'q' 
0c7f 28 0b				jr z, .goback 
0c81			 
0c81 fe 0b				cp KEY_LEFT 
0c83 28 07				jr z, .goback 
0c85 fe 08				cp KEY_BS 
0c87 28 03				jr z, .goback 
0c89 c3 f8 0b				jp .mloop 
0c8c			 
0c8c			.goback: 
0c8c 3e 00			ld a, 0 
0c8e 18 1c			jr .goend2 
0c90			 
0c90				; move up one 
0c90			.mgoup: 
0c90 3a 64 ea				ld a, (store_tmp2) 
0c93			;		cp 0 
0c93 b7					or a 
0c94 ca f8 0b				jp z, .mloop 
0c97 3d					dec a 
0c98 32 64 ea				ld (store_tmp2), a 
0c9b c3 f8 0b				jp .mloop 
0c9e			 
0c9e				; move down one 
0c9e			.mgod: 
0c9e 3a 64 ea				ld a, (store_tmp2) 
0ca1 3c					inc a 
0ca2 32 64 ea				ld (store_tmp2), a 
0ca5 c3 f8 0b				jp .mloop 
0ca8			 
0ca8			 
0ca8			.goend: 
0ca8					; get selected item number 
0ca8			 
0ca8 3a 64 ea				ld a, (store_tmp2) 
0cab 3c					inc a 
0cac			 
0cac			.goend2: 
0cac f5					push af 
0cad			 
0cad					; restore active fb 
0cad					; TODO BUG assumes fb1 
0cad			 
0cad 21 03 ed				ld hl, display_fb1 
0cb0 22 bf eb				ld (display_fb_active), hl 
0cb3			 
0cb3					; restore main regs 
0cb3			 
0cb3			 
0cb3 cd de 0b				call update_display 
0cb6			 
0cb6 f1					pop af 
0cb7			 
0cb7 c9				ret 
0cb8			 
0cb8 .. 00		.msel:   db ">",0 
0cba .. 00		.mup:   db "^",0 
0cbc .. 00		.mdown:   db "v",0 
0cbe			 
0cbe			 
0cbe			; eof 
0cbe			 
# End of file firmware_display.asm
0cbe			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0cbe			; random number generators 
0cbe			 
0cbe			 
0cbe			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0cbe			 
0cbe			 
0cbe			;-----> Generate a random number 
0cbe			; output a=answer 0<=a<=255 
0cbe			; all registers are preserved except: af 
0cbe			random: 
0cbe e5			        push    hl 
0cbf d5			        push    de 
0cc0 2a 9e eb		        ld      hl,(randData) 
0cc3 ed 5f		        ld      a,r 
0cc5 57			        ld      d,a 
0cc6 5e			        ld      e,(hl) 
0cc7 19			        add     hl,de 
0cc8 85			        add     a,l 
0cc9 ac			        xor     h 
0cca 22 9e eb		        ld      (randData),hl 
0ccd d1			        pop     de 
0cce e1			        pop     hl 
0ccf c9			        ret 
0cd0			 
0cd0			 
0cd0			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0cd0			 
0cd0			 
0cd0			 
0cd0			;------LFSR------ 
0cd0			;James Montelongo 
0cd0			;optimized by Spencer Putt 
0cd0			;out: 
0cd0			; a = 8 bit random number 
0cd0			RandLFSR: 
0cd0 21 a4 eb		        ld hl,LFSRSeed+4 
0cd3 5e			        ld e,(hl) 
0cd4 23			        inc hl 
0cd5 56			        ld d,(hl) 
0cd6 23			        inc hl 
0cd7 4e			        ld c,(hl) 
0cd8 23			        inc hl 
0cd9 7e			        ld a,(hl) 
0cda 47			        ld b,a 
0cdb cb 13		        rl e  
0cdd cb 12			rl d 
0cdf cb 11		        rl c  
0ce1 17				rla 
0ce2 cb 13		        rl e  
0ce4 cb 12			rl d 
0ce6 cb 11		        rl c  
0ce8 17				rla 
0ce9 cb 13		        rl e  
0ceb cb 12			rl d 
0ced cb 11		        rl c  
0cef 17				rla 
0cf0 67			        ld h,a 
0cf1 cb 13		        rl e  
0cf3 cb 12			rl d 
0cf5 cb 11		        rl c  
0cf7 17				rla 
0cf8 a8			        xor b 
0cf9 cb 13		        rl e  
0cfb cb 12			rl d 
0cfd ac			        xor h 
0cfe a9			        xor c 
0cff aa			        xor d 
0d00 21 a6 eb		        ld hl,LFSRSeed+6 
0d03 11 a7 eb		        ld de,LFSRSeed+7 
0d06 01 07 00		        ld bc,7 
0d09 ed b8		        lddr 
0d0b 12			        ld (de),a 
0d0c c9			        ret 
0d0d			 
0d0d			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0d0d			 
0d0d			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0d0d			 
0d0d			 
0d0d			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0d0d			 
0d0d			prng16: 
0d0d			;Inputs: 
0d0d			;   (seed1) contains a 16-bit seed value 
0d0d			;   (seed2) contains a NON-ZERO 16-bit seed value 
0d0d			;Outputs: 
0d0d			;   HL is the result 
0d0d			;   BC is the result of the LCG, so not that great of quality 
0d0d			;   DE is preserved 
0d0d			;Destroys: 
0d0d			;   AF 
0d0d			;cycle: 4,294,901,760 (almost 4.3 billion) 
0d0d			;160cc 
0d0d			;26 bytes 
0d0d 2a 98 eb		    ld hl,(seed1) 
0d10 44			    ld b,h 
0d11 4d			    ld c,l 
0d12 29			    add hl,hl 
0d13 29			    add hl,hl 
0d14 2c			    inc l 
0d15 09			    add hl,bc 
0d16 22 98 eb		    ld (seed1),hl 
0d19 2a 96 eb		    ld hl,(seed2) 
0d1c 29			    add hl,hl 
0d1d 9f			    sbc a,a 
0d1e e6 2d		    and %00101101 
0d20 ad			    xor l 
0d21 6f			    ld l,a 
0d22 22 96 eb		    ld (seed2),hl 
0d25 09			    add hl,bc 
0d26 c9			    ret 
0d27			 
0d27			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0d27			 
0d27			rand32: 
0d27			;Inputs: 
0d27			;   (seed1_0) holds the lower 16 bits of the first seed 
0d27			;   (seed1_1) holds the upper 16 bits of the first seed 
0d27			;   (seed2_0) holds the lower 16 bits of the second seed 
0d27			;   (seed2_1) holds the upper 16 bits of the second seed 
0d27			;   **NOTE: seed2 must be non-zero 
0d27			;Outputs: 
0d27			;   HL is the result 
0d27			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0d27			;Destroys: 
0d27			;   AF 
0d27			;Tested and passes all CAcert tests 
0d27			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0d27			;it has a period of 18,446,744,069,414,584,320 
0d27			;roughly 18.4 quintillion. 
0d27			;LFSR taps: 0,2,6,7  = 11000101 
0d27			;291cc 
0d27			;seed1_0=$+1 
0d27			;    ld hl,12345 
0d27			;seed1_1=$+1 
0d27			;    ld de,6789 
0d27			;    ld b,h 
0d27			;    ld c,l 
0d27			;    add hl,hl \ rl e \ rl d 
0d27			;    add hl,hl \ rl e \ rl d 
0d27			;    inc l 
0d27			;    add hl,bc 
0d27			;    ld (seed1_0),hl 
0d27			;    ld hl,(seed1_1) 
0d27			;    adc hl,de 
0d27			;    ld (seed1_1),hl 
0d27			;    ex de,hl 
0d27			;seed2_0=$+1 
0d27			;    ld hl,9876 
0d27			;seed2_1=$+1 
0d27			;    ld bc,54321 
0d27			;    add hl,hl \ rl c \ rl b 
0d27			;    ld (seed2_1),bc 
0d27			;    sbc a,a 
0d27			;    and %11000101 
0d27			;    xor l 
0d27			;    ld l,a 
0d27			;    ld (seed2_0),hl 
0d27			;    ex de,hl 
0d27			;    add hl,bc 
0d27			;    ret 
0d27			; 
0d27			 
0d27			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0d27			; 20 bytes, 86 cycles (excluding ret) 
0d27			 
0d27			; returns   hl = pseudorandom number 
0d27			; corrupts   a 
0d27			 
0d27			; generates 16-bit pseudorandom numbers with a period of 65535 
0d27			; using the xorshift method: 
0d27			 
0d27			; hl ^= hl << 7 
0d27			; hl ^= hl >> 9 
0d27			; hl ^= hl << 8 
0d27			 
0d27			; some alternative shift triplets which also perform well are: 
0d27			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0d27			 
0d27			;  org 32768 
0d27			 
0d27			xrnd: 
0d27 2a 9c eb		  ld hl,(xrandc)       ; seed must not be 0 
0d2a 3e 00		  ld a,0 
0d2c bd			  cp l 
0d2d 20 02		  jr nz, .xrnd1 
0d2f 2e 01		  ld l, 1 
0d31			.xrnd1: 
0d31			 
0d31 7c			  ld a,h 
0d32 1f			  rra 
0d33 7d			  ld a,l 
0d34 1f			  rra 
0d35 ac			  xor h 
0d36 67			  ld h,a 
0d37 7d			  ld a,l 
0d38 1f			  rra 
0d39 7c			  ld a,h 
0d3a 1f			  rra 
0d3b ad			  xor l 
0d3c 6f			  ld l,a 
0d3d ac			  xor h 
0d3e 67			  ld h,a 
0d3f			 
0d3f 22 9c eb		  ld (xrandc),hl 
0d42			 
0d42 c9			  ret 
0d43			;  
0d43			 
0d43			 
0d43			;;;; int maths 
0d43			 
0d43			; https://map.grauw.nl/articles/mult_div_shifts.php 
0d43			; Divide 16-bit values (with 16-bit result) 
0d43			; In: Divide BC by divider DE 
0d43			; Out: BC = result, HL = rest 
0d43			; 
0d43			Div16: 
0d43 21 00 00		    ld hl,0 
0d46 78			    ld a,b 
0d47 06 08		    ld b,8 
0d49			Div16_Loop1: 
0d49 17			    rla 
0d4a ed 6a		    adc hl,hl 
0d4c ed 52		    sbc hl,de 
0d4e 30 01		    jr nc,Div16_NoAdd1 
0d50 19			    add hl,de 
0d51			Div16_NoAdd1: 
0d51 10 f6		    djnz Div16_Loop1 
0d53 17			    rla 
0d54 2f			    cpl 
0d55 47			    ld b,a 
0d56 79			    ld a,c 
0d57 48			    ld c,b 
0d58 06 08		    ld b,8 
0d5a			Div16_Loop2: 
0d5a 17			    rla 
0d5b ed 6a		    adc hl,hl 
0d5d ed 52		    sbc hl,de 
0d5f 30 01		    jr nc,Div16_NoAdd2 
0d61 19			    add hl,de 
0d62			Div16_NoAdd2: 
0d62 10 f6		    djnz Div16_Loop2 
0d64 17			    rla 
0d65 2f			    cpl 
0d66 41			    ld b,c 
0d67 4f			    ld c,a 
0d68 c9			ret 
0d69			 
0d69			 
0d69			;http://z80-heaven.wikidot.com/math 
0d69			; 
0d69			;Inputs: 
0d69			;     DE and A are factors 
0d69			;Outputs: 
0d69			;     A is not changed 
0d69			;     B is 0 
0d69			;     C is not changed 
0d69			;     DE is not changed 
0d69			;     HL is the product 
0d69			;Time: 
0d69			;     342+6x 
0d69			; 
0d69			Mult16: 
0d69			 
0d69 06 08		     ld b,8          ;7           7 
0d6b 21 00 00		     ld hl,0         ;10         10 
0d6e 29			       add hl,hl     ;11*8       88 
0d6f 07			       rlca          ;4*8        32 
0d70 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0d72 19			         add hl,de   ;--         -- 
0d73 10 f9		       djnz $-5      ;13*7+8     99 
0d75 c9			ret 
0d76			 
0d76			; 
0d76			; Square root of 16-bit value 
0d76			; In:  HL = value 
0d76			; Out:  D = result (rounded down) 
0d76			; 
0d76			;Sqr16: 
0d76			;    ld de,#0040 
0d76			;    ld a,l 
0d76			;    ld l,h 
0d76			;    ld h,d 
0d76			;    or a 
0d76			;    ld b,8 
0d76			;Sqr16_Loop: 
0d76			;    sbc hl,de 
0d76			;    jr nc,Sqr16_Skip 
0d76			;    add hl,de 
0d76			;Sqr16_Skip: 
0d76			;    ccf 
0d76			;    rl d 
0d76			;    add a,a 
0d76			;    adc hl,hl 
0d76			;    add a,a 
0d76			;    adc hl,hl 
0d76			;    djnz Sqr16_Loop 
0d76			;    ret 
0d76			; 
0d76			; 
0d76			; Divide 8-bit values 
0d76			; In: Divide E by divider C 
0d76			; Out: A = result, B = rest 
0d76			; 
0d76			Div8: 
0d76 af			    xor a 
0d77 06 08		    ld b,8 
0d79			Div8_Loop: 
0d79 cb 13		    rl e 
0d7b 17			    rla 
0d7c 91			    sub c 
0d7d 30 01		    jr nc,Div8_NoAdd 
0d7f 81			    add a,c 
0d80			Div8_NoAdd: 
0d80 10 f7		    djnz Div8_Loop 
0d82 47			    ld b,a 
0d83 7b			    ld a,e 
0d84 17			    rla 
0d85 2f			    cpl 
0d86 c9			    ret 
0d87			 
0d87			; 
0d87			; Multiply 8-bit value with a 16-bit value (unrolled) 
0d87			; In: Multiply A with DE 
0d87			; Out: HL = result 
0d87			; 
0d87			Mult12U: 
0d87 2e 00		    ld l,0 
0d89 87			    add a,a 
0d8a 30 01		    jr nc,Mult12U_NoAdd0 
0d8c 19			    add hl,de 
0d8d			Mult12U_NoAdd0: 
0d8d 29			    add hl,hl 
0d8e 87			    add a,a 
0d8f 30 01		    jr nc,Mult12U_NoAdd1 
0d91 19			    add hl,de 
0d92			Mult12U_NoAdd1: 
0d92 29			    add hl,hl 
0d93 87			    add a,a 
0d94 30 01		    jr nc,Mult12U_NoAdd2 
0d96 19			    add hl,de 
0d97			Mult12U_NoAdd2: 
0d97 29			    add hl,hl 
0d98 87			    add a,a 
0d99 30 01		    jr nc,Mult12U_NoAdd3 
0d9b 19			    add hl,de 
0d9c			Mult12U_NoAdd3: 
0d9c 29			    add hl,hl 
0d9d 87			    add a,a 
0d9e 30 01		    jr nc,Mult12U_NoAdd4 
0da0 19			    add hl,de 
0da1			Mult12U_NoAdd4: 
0da1 29			    add hl,hl 
0da2 87			    add a,a 
0da3 30 01		    jr nc,Mult12U_NoAdd5 
0da5 19			    add hl,de 
0da6			Mult12U_NoAdd5: 
0da6 29			    add hl,hl 
0da7 87			    add a,a 
0da8 30 01		    jr nc,Mult12U_NoAdd6 
0daa 19			    add hl,de 
0dab			Mult12U_NoAdd6: 
0dab 29			    add hl,hl 
0dac 87			    add a,a 
0dad d0			    ret nc 
0dae 19			    add hl,de 
0daf c9			    ret 
0db0			 
0db0			; 
0db0			; Multiply 8-bit value with a 16-bit value (right rotating) 
0db0			; In: Multiply A with DE 
0db0			;      Put lowest value in A for most efficient calculation 
0db0			; Out: HL = result 
0db0			; 
0db0			Mult12R: 
0db0 21 00 00		    ld hl,0 
0db3			Mult12R_Loop: 
0db3 cb 3f		    srl a 
0db5 30 01		    jr nc,Mult12R_NoAdd 
0db7 19			    add hl,de 
0db8			Mult12R_NoAdd: 
0db8 cb 23		    sla e 
0dba cb 12		    rl d 
0dbc b7			    or a 
0dbd c2 b3 0d		    jp nz,Mult12R_Loop 
0dc0 c9			    ret 
0dc1			 
0dc1			; 
0dc1			; Multiply 16-bit values (with 32-bit result) 
0dc1			; In: Multiply BC with DE 
0dc1			; Out: BCHL = result 
0dc1			; 
0dc1			Mult32: 
0dc1 79			    ld a,c 
0dc2 48			    ld c,b 
0dc3 21 00 00		    ld hl,0 
0dc6 06 10		    ld b,16 
0dc8			Mult32_Loop: 
0dc8 29			    add hl,hl 
0dc9 17			    rla 
0dca cb 11		    rl c 
0dcc 30 07		    jr nc,Mult32_NoAdd 
0dce 19			    add hl,de 
0dcf ce 00		    adc a,0 
0dd1 d2 d5 0d		    jp nc,Mult32_NoAdd 
0dd4 0c			    inc c 
0dd5			Mult32_NoAdd: 
0dd5 10 f1		    djnz Mult32_Loop 
0dd7 41			    ld b,c 
0dd8 4f			    ld c,a 
0dd9 c9			    ret 
0dda			 
0dda			 
0dda			 
0dda			; 
0dda			; Multiply 8-bit values 
0dda			; In:  Multiply H with E 
0dda			; Out: HL = result 
0dda			; 
0dda			Mult8: 
0dda 16 00		    ld d,0 
0ddc 6a			    ld l,d 
0ddd 06 08		    ld b,8 
0ddf			Mult8_Loop: 
0ddf 29			    add hl,hl 
0de0 30 01		    jr nc,Mult8_NoAdd 
0de2 19			    add hl,de 
0de3			Mult8_NoAdd: 
0de3 10 fa		    djnz Mult8_Loop 
0de5 c9			    ret 
0de6			 
0de6			 
0de6			 
0de6			 
0de6			 
0de6			 
0de6			 
0de6			 
0de6			;;http://z80-heaven.wikidot.com/math 
0de6			;;This divides DE by BC, storing the result in DE, remainder in HL 
0de6			; 
0de6			;DE_Div_BC:          ;1281-2x, x is at most 16 
0de6			;     ld a,16        ;7 
0de6			;     ld hl,0        ;10 
0de6			;     jp $+5         ;10 
0de6			;.DivLoop: 
0de6			;       add hl,bc    ;-- 
0de6			;       dec a        ;64 
0de6			;       jr z,.DivLoopEnd        ;86 
0de6			; 
0de6			;       sla e        ;128 
0de6			;       rl d         ;128 
0de6			;       adc hl,hl    ;240 
0de6			;       sbc hl,bc    ;240 
0de6			;       jr nc,.DivLoop ;23|21 
0de6			;       inc e        ;-- 
0de6			;       jp .DivLoop+1 
0de6			; 
0de6			;.DivLoopEnd: 
0de6			 
0de6			;HL_Div_C: 
0de6			;Inputs: 
0de6			;     HL is the numerator 
0de6			;     C is the denominator 
0de6			;Outputs: 
0de6			;     A is the remainder 
0de6			;     B is 0 
0de6			;     C is not changed 
0de6			;     DE is not changed 
0de6			;     HL is the quotient 
0de6			; 
0de6			;       ld b,16 
0de6			;       xor a 
0de6			;         add hl,hl 
0de6			;         rla 
0de6			;         cp c 
0de6			;         jr c,$+4 
0de6			;           inc l 
0de6			;           sub c 
0de6			;         djnz $-7 
0de6			 
0de6			; https://plutiedev.com/z80-add-8bit-to-16bit 
0de6			 
0de6			addatohl: 
0de6 85			    add   a, l    ; A = A+L 
0de7 6f			    ld    l, a    ; L = A+L 
0de8 8c			    adc   a, h    ; A = A+L+H+carry 
0de9 95			    sub   l       ; A = H+carry 
0dea 67			    ld    h, a    ; H = H+carry 
0deb c9			ret 
0dec			 
0dec			addatode: 
0dec 83			    add   a, e    ; A = A+L 
0ded 5f			    ld    e, a    ; L = A+L 
0dee 8a			    adc   a, d    ; A = A+L+H+carry 
0def 93			    sub   e       ; A = H+carry 
0df0 57			    ld    d, a    ; H = H+carry 
0df1 c9			ret 
0df2			 
0df2			 
0df2			addatobc: 
0df2 81			    add   a, c    ; A = A+L 
0df3 4f			    ld    c, a    ; L = A+L 
0df4 88			    adc   a, b    ; A = A+L+H+carry 
0df5 91			    sub   c       ; A = H+carry 
0df6 47			    ld    b, a    ; H = H+carry 
0df7 c9			ret 
0df8			 
0df8			subafromhl: 
0df8			   ; If A=0 do nothing 
0df8			    ; Otherwise flip A's sign. Since 
0df8			    ; the upper byte becomes -1, also 
0df8			    ; substract 1 from H. 
0df8 ed 44		    neg 
0dfa ca 03 0e		    jp    z, Skip 
0dfd 25			    dec   h 
0dfe			     
0dfe			    ; Now add the low byte as usual 
0dfe			    ; Two's complement takes care of 
0dfe			    ; ensuring the result is correct 
0dfe 85			    add   a, l 
0dff 6f			    ld    l, a 
0e00 8c			    adc   a, h 
0e01 95			    sub   l 
0e02 67			    ld    h, a 
0e03			Skip: 
0e03 c9				ret 
0e04			 
0e04			 
0e04			; compare hl and de 
0e04			; returns:  
0e04			; if hl = de, z=1, s=0, c0=0 
0e04			; if hl > de, z=0, s=0, c=0 
0e04			; if hl < de, z=0, s=1, c=1 
0e04			cmp16:	 
0e04 b7				or a 
0e05 ed 52			sbc hl,de 
0e07 e0				ret po 
0e08 7c				ld a,h 
0e09 1f				rra 
0e0a ee 40			xor 01000000B 
0e0c 37				scf 
0e0d 8f				adc a,a 
0e0e c9				ret 
0e0f			 
0e0f			 
0e0f			; test if hl contains zero   - A is destroyed 
0e0f			 
0e0f			ishlzero:    
0e0f b7				or a     ; reset flags 
0e10 7c				ld a, h 
0e11 b5				or l        	 
0e12			 
0e12 c9				ret 
0e13			 
0e13			 
0e13			 
0e13			 
0e13			if FORTH_ENABLE_FLOATMATH 
0e13			;include "float/bbcmath.z80" 
0e13			include "float/lpfpcalc.asm" 
0e13			endif 
0e13			 
0e13			 
0e13			; eof 
0e13			 
# End of file firmware_maths.asm
0e13			include "firmware_strings.asm"   ; string handling  
0e13			 
0e13			 
0e13			; TODO string len 
0e13			; input text string, end on cr with zero term 
0e13			; a offset into frame buffer to start prompt 
0e13			; d is max length 
0e13			; e is display size TODO 
0e13			; c is current cursor position 
0e13			; hl is ptr to where string will be stored and edited directly 
0e13			 
0e13			 
0e13			; TODO check limit of buffer for new inserts 
0e13			; TODO check insert does not push beyond buffer 
0e13			; TODO scroll in a limited display area 
0e13			; TODO scroll whole screen on page wrap 
0e13			 
0e13			 
0e13			; TODO use LCD cursor? 
0e13			 
0e13			EDIT_V1: equ 0 
0e13			EDIT_V2: equ 1 
0e13			 
0e13			 
0e13			 
0e13			if EDIT_V2 
0e13			input_str: 
0e13			 
0e13 32 57 ee			    	ld (input_at_pos),a      ; save display position to start 
0e16			;		ld (input_at_cursor),a	; save draw pos of cursor relative to start 
0e16 22 5a ee				ld (input_start), hl     ; save ptr to buffer 
0e19			;		ld a, c 
0e19			;		call addatohl 
0e19			;		ld (input_ptr), hl     ; save ptr to point under the cursor 
0e19 7a					ld a,d 
0e1a 32 59 ee			        ld (input_size), a       ; save length of input area 
0e1d 79					ld a, c 
0e1e 32 48 ee				ld (input_cursor),a      ; init cursor start position relative to start of string 
0e21 7b					ld a,e 
0e22 32 58 ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0e25			 
0e25			 
0e25					; add a trailing space to make screen refresh nicer 
0e25			 
0e25					;ld hl, (input_start) 
0e25					;push hl 
0e25					;ld a, 0 
0e25					;call strlent 
0e25					;ld a, l 
0e25					;pop hl 
0e25					;call addatohl 
0e25					;dec hl 
0e25					;ld a, ' ' 
0e25					;ld (hl), a 
0e25					;inc hl 
0e25					;ld (hl), a 
0e25					;inc hl 
0e25					;ld a, 0 
0e25					;ld (hl), a 
0e25			 
0e25			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0e25					; init cursor shape if not set by the cin routines 
0e25 21 b4 eb				ld hl, cursor_shape 
0e28			if BASE_KEV 
0e28			;		ld a, 255 
0e28					ld (hl), 255 
0e28			else 
0e28					;ld a, '#' 
0e28 36 23				ld (hl), '#' 
0e2a			endif 
0e2a 23					inc hl 
0e2b			;		ld a, 0 
0e2b 36 00				ld (hl), 0 
0e2d			 
0e2d 3e 09				ld a, CUR_BLINK_RATE 
0e2f 32 53 ee				ld (input_cur_flash), a 
0e32 3e 01				ld a, 1 
0e34 32 52 ee				ld (input_cur_onoff),a 
0e37			.inmain:	 
0e37			 
0e37 cd 58 0f				call input_disp_ref 
0e3a			 
0e3a					; save current length of string 
0e3a			 
0e3a 2a 5a ee				ld hl, (input_start) 
0e3d 3e 00				ld a, 0 
0e3f cd 49 11				call strlent 
0e42 7d					ld a,l 
0e43 32 4d ee				ld (input_len), a 
0e46			 
0e46					;call input_disp_oncur 
0e46			 
0e46					; display current state of input buffer 
0e46			 
0e46					; clean any backspace chars 
0e46			 
0e46 3e 20				ld a, " " 
0e48 32 b4 e2				ld (scratch),a 
0e4b 3e 00				ld a, 0 
0e4d 32 b5 e2				ld (scratch+1),a 
0e50 3a 57 ee				ld a,(input_at_pos) 
0e53 85					add l 
0e54 11 b4 e2				ld de, scratch 
0e57 cd ce 0b				call str_at_display 
0e5a			 
0e5a					; pause 1ms 
0e5a			 
0e5a 3e 01				ld a, 1 
0e5c cd d5 0a				call aDelayInMS 
0e5f			 
0e5f			; display cursor if visible on this cycle 
0e5f			 
0e5f					; dec flash counter 
0e5f 3a 53 ee				ld a, (input_cur_flash) 
0e62 3d					dec a 
0e63 32 53 ee				ld (input_cur_flash), a 
0e66			;		cp 0 
0e66 b7					or a 
0e67 20 0d				jr nz, .inochgstate 
0e69			 
0e69			 
0e69					; reset on change of state 
0e69 3e 09				ld a, CUR_BLINK_RATE 
0e6b 32 53 ee				ld (input_cur_flash), a 
0e6e			 
0e6e					; change state 
0e6e 3a 52 ee				ld a,(input_cur_onoff) 
0e71 ed 44				neg 
0e73 32 52 ee				ld (input_cur_onoff),a 
0e76			 
0e76			 
0e76			 
0e76			 
0e76					; TODO is cursor visible? 
0e76					; TODO if so then over write the char at curspos pos with the cursor shape 
0e76			 
0e76								 
0e76			 
0e76			.inochgstate: 
0e76 3a 52 ee				ld a,(input_cur_onoff) 
0e79 fe ff				cp 255 
0e7b 28 0e				jr z, .skipcursor 
0e7d 3a 57 ee				ld a, (input_at_pos) 
0e80 47					ld b, a 
0e81 3a 48 ee				ld a, (input_cursor) 
0e84 80					add b 
0e85 11 b4 eb				ld de, cursor_shape 
0e88					 
0e88 cd ce 0b				call str_at_display 
0e8b			 
0e8b			.skipcursor: 
0e8b				if DEBUG_INPUTV2 
0e8b			 
0e8b					ld a,(input_at_pos) 
0e8b					ld hl, LFSRSeed 
0e8b					call hexout 
0e8b					ld a, (input_cursor) 
0e8b					ld hl, LFSRSeed+2 
0e8b					call hexout 
0e8b					ld a,(input_size) 
0e8b					ld hl, LFSRSeed+4 
0e8b					call hexout 
0e8b			 
0e8b					ld a,(input_cur_onoff) 
0e8b					ld hl, LFSRSeed+6 
0e8b					call hexout 
0e8b			 
0e8b					ld a,(input_cur_flash) 
0e8b					ld hl, LFSRSeed+8 
0e8b					call hexout 
0e8b			 
0e8b					ld a,(input_len) 
0e8b					ld hl, LFSRSeed+10 
0e8b					call hexout 
0e8b					ld hl, LFSRSeed+12 
0e8b			;		ld a, 0 
0e8b					ld (hl),0 
0e8b					ld a, display_row_4 
0e8b					ld de, LFSRSeed 
0e8b					call str_at_display 
0e8b				endif 
0e8b cd de 0b				call update_display 
0e8e			 
0e8e					; TODO keyboard processing 
0e8e			 
0e8e			if BASE_CPM 
0e8e cd 7e 67				call cin_wait 
0e91			else 
0e91					call cin    ; _wait 
0e91			endif 
0e91			;		cp 0 
0e91 b7					or a 
0e92 ca 37 0e				jp z, .inmain 
0e95			 
0e95			 
0e95					; TODO handle macro 
0e95			 
0e95			 
0e95			 
0e95 fe 0b				cp KEY_LEFT    ; cursor left 
0e97 ca 4a 0f				jp z, input_left 
0e9a				 
0e9a fe 0c				cp KEY_RIGHT      ; cursor right 
0e9c ca 51 0f				jp z, input_right 
0e9f			 
0e9f fe 0d				cp KEY_CR 
0ea1 c8					ret z 
0ea2			 
0ea2 fe 08				cp KEY_BS 
0ea4 ca bc 0f				jp z, input_delchar 
0ea7			 
0ea7 fe 06				cp KEY_NEXTWORD 
0ea9 ca d0 0e				jp z, input_nxtword 
0eac			 
0eac fe 07				cp KEY_PREVWORD 
0eae ca f5 0e				jp z, input_prvword 
0eb1			 
0eb1 fe 0e				cp KEY_HOME    ; jump to start of line 
0eb3 20 08				jr nz, .ikh 
0eb5 3e 00				ld a, 0 
0eb7 32 48 ee				ld (input_cursor), a 
0eba ca 37 0e				jp z, .inmain 
0ebd			.ikh: 
0ebd			 
0ebd fe 0f				cp KEY_END     ; jump to end of line 
0ebf 20 09				jr nz, .ike 
0ec1 3a 4d ee				ld a, (input_len) 
0ec4 32 48 ee				ld (input_cursor),a 
0ec7 ca 37 0e				jp z, .inmain 
0eca			.ike: 
0eca fe 05			        cp KEY_UP      ; recall last command 
0ecc c8					ret z 
0ecd			;jr nz, .irec 
0ecd			; TODO next word 
0ecd			; TODO prev word 
0ecd			;  
0ecd			; 
0ecd			;	ld hl, scratch 
0ecd			;	ld de, os_last_cmd 
0ecd			;	call strcpy 
0ecd			;		jp  .inmain 
0ecd			.irec: 
0ecd			;		jr .instr1 
0ecd			 
0ecd			 
0ecd			 
0ecd					; if any keys not intercepted by above but are special keys like function keys then return them to the program 
0ecd			 
0ecd			; TODO return if any special keys are given 
0ecd			;		ld l, a 
0ecd			;		ld a, 28 ; KEY_F12   ; 27 
0ecd			;		sub l 
0ecd			;		ret m 
0ecd			;		ld a, l 
0ecd					; if no special key then insert as a char 
0ecd			 
0ecd			 
0ecd			 
0ecd c3 91 0f				jp input_inschr 
0ed0			 
0ed0				 
0ed0			input_nxtword: 
0ed0				; jump to start next word after the cursor 
0ed0			 
0ed0			.insknwn:	 
0ed0 cd 87 0f				call input_curptr	 
0ed3 7e					ld a,(hl)	 
0ed4			;		cp 0 
0ed4 b7					or a 
0ed5 ca 37 0e				jp z, .inmain    ; end of string 
0ed8			 
0ed8			; if we are on a word, then move off of it 
0ed8			 
0ed8 fe 20				cp ' ' 
0eda 28 06				jr z, .inspace     ; we are on space so eat the space until we hit non-space 
0edc 21 48 ee				ld hl, input_cursor 
0edf 34					inc (hl) 
0ee0 18 ee				jr .insknwn 
0ee2			 
0ee2			.inspace: 
0ee2			 
0ee2 cd 87 0f				call input_curptr	 
0ee5 7e					ld a,(hl)	 
0ee6			;		cp 0 
0ee6 b7					or a 
0ee7 ca 37 0e				jp z, .inmain    ; end of string 
0eea			 
0eea			; if we are on a word, then move off of it 
0eea			 
0eea fe 20				cp ' ' 
0eec c2 37 0e				jp nz, .inmain     ; we are on non space so at next word 
0eef 21 48 ee				ld hl, input_cursor 
0ef2 34					inc (hl) 
0ef3 18 ed				jr .inspace 
0ef5			 
0ef5			 
0ef5			 
0ef5			 
0ef5			input_prvword: 
0ef5				; jump to the start of previous word before the cursor 
0ef5			 
0ef5			; where are we to start with currently? 
0ef5			 
0ef5 cd 87 0f				call input_curptr	 
0ef8 7e					ld a, (hl) 
0ef9 fe 20				cp ' ' 
0efb 28 1c				jr z, .inspacep     ; we are on space so eat the space until we hit non-space 
0efd			 
0efd			 
0efd			 
0efd			.inskpwn:	 
0efd 3a 48 ee				ld a,(input_cursor) 
0f00			;		cp 0 
0f00 b7					or a 
0f01 ca 37 0e				jp z, .inmain    ; start of string 
0f04			 
0f04			;if we are on a word, then move off of it 
0f04			 
0f04 cd 87 0f				call input_curptr	 
0f07 7e					ld a, (hl) 
0f08 fe 20				cp ' ' 
0f0a 28 06				jr z, .iwstart     ; we are on space so eat the space until we hit non-space 
0f0c					;jp z, .inmain    ; start of string 
0f0c 21 48 ee				ld hl, input_cursor 
0f0f 35					dec (hl) 
0f10 18 eb				jr .inskpwn 
0f12			.iwstart: 
0f12 21 48 ee				ld hl, input_cursor 
0f15 34					inc (hl) 
0f16 c3 37 0e				jp .inmain 
0f19					 
0f19			 
0f19			.inspacep: 
0f19			 
0f19					;jp .inmain    ; start of string 
0f19			 
0f19			 
0f19			 
0f19 3a 48 ee				ld a,(input_cursor) 
0f1c			;		cp 0 
0f1c b7					or a 
0f1d ca 37 0e				jp z, .inmain    ; start of string 
0f20			 
0f20			; if we are on a word, then move off of it 
0f20			 
0f20 cd 87 0f				call input_curptr	 
0f23 7e					ld a, (hl) 
0f24 fe 20				cp ' ' 
0f26 c2 2f 0f				jp nz, .incharp     ; we are on non space so at end of prev word 
0f29 21 48 ee				ld hl, input_cursor 
0f2c 35					dec (hl) 
0f2d 18 ea				jr .inspacep 
0f2f			 
0f2f			 
0f2f			.incharp:	 
0f2f					; eat the word to get to the start 
0f2f 3a 48 ee				ld a,(input_cursor) 
0f32			;		cp 0 
0f32 b7					or a 
0f33 ca 37 0e				jp z, .inmain    ; start of string 
0f36			 
0f36			; if we are on a word, then move off of it 
0f36			 
0f36 cd 87 0f				call input_curptr	 
0f39 7e					ld a, (hl) 
0f3a fe 20				cp ' ' 
0f3c 28 06				jr z, .ipwordst     ; we are on space so eat the space until we hit non-space 
0f3e 21 48 ee				ld hl, input_cursor 
0f41 35					dec (hl) 
0f42 18 eb				jr .incharp 
0f44			.ipwordst: 
0f44					; at space before the prev word so reposition over it 
0f44 21 48 ee				ld hl, input_cursor 
0f47 34					inc (hl) 
0f48 18 b3				jr .inskpwn 
0f4a					 
0f4a			 
0f4a			 
0f4a			input_left: 
0f4a				; move cursor left 
0f4a 21 48 ee			ld hl, input_cursor 
0f4d 35				dec (hl) 
0f4e			;	cp 0 
0f4e			;	jp z, .inmain    ; ignore left as at the start of the string 
0f4e c3 37 0e			jp .inmain 
0f51			 
0f51			input_right: 
0f51				; move cursor right 
0f51				 
0f51				;ld a, (input_size) 
0f51				;ld b, a 
0f51 21 48 ee			ld hl, input_cursor 
0f54 34				inc (hl) 
0f55				;dec b 
0f55				;cp 0 
0f55				;jp z, .inmain   ; ignore as at end of the string buffer 
0f55				;ld a, b 
0f55				;inc a 
0f55				;ld (input_cursor), a 
0f55 c3 37 0e			jp .inmain 
0f58			 
0f58			 
0f58			 
0f58			input_disp_ref: 
0f58				; display the text from start of buffer (ie full refresh) 
0f58 3a 57 ee			ld a, (input_at_pos) 
0f5b 2a 5a ee			ld hl,(input_start) 
0f5e eb				ex de, hl 
0f5f cd ce 0b			call str_at_display  
0f62 c9				ret 
0f63			input_disp_oncur: 
0f63				; display the text from cursor position to end of buffer 
0f63				; TODO position start of string at cursor position on screen 
0f63				; TODO draw from that point on 
0f63 3a 48 ee			ld a, (input_cursor) 
0f66 47				ld b, a 
0f67 3a 57 ee			ld a, (input_at_pos) 
0f6a 80				add b 
0f6b 48				ld c, b     ; save a 
0f6c 78				ld a, b     ; inc string start for cursor 
0f6d 2a 5a ee			ld hl,(input_start) 
0f70 cd e6 0d			call addatohl 
0f73 eb				ex de, hl 
0f74 79				ld a, c 
0f75 cd ce 0b			call str_at_display  
0f78 c9				ret 
0f79			 
0f79			input_nxtw: 
0f79				; Find next word 
0f79 c9				ret 
0f7a			 
0f7a			input_prvw: 
0f7a				; Find previous word 
0f7a c9				ret 
0f7b			 
0f7b			input_lenrem:   
0f7b				; Calculate the length of string remaining from current cursor 
0f7b				; position to end of buffer (exc null term) 
0f7b				 
0f7b 3a 48 ee			ld a, (input_cursor) 
0f7e 4f				ld c, a 
0f7f 3a 59 ee			ld a, (input_size) 
0f82 91				sub c 
0f83 06 00			ld b, 0 
0f85 0d				dec c 
0f86 c9				ret	 
0f87			 
0f87			input_curptr: 
0f87				; calc address of the character under the cursor 
0f87				 
0f87 2a 5a ee			ld hl, (input_start) 
0f8a 3a 48 ee			ld a, (input_cursor) 
0f8d cd e6 0d			call addatohl 
0f90 c9				ret 
0f91			 
0f91			input_inschr: 
0f91				; Insert char at cursor position 
0f91 f5				push af   ; save char 
0f92				;call input_lenrem    ; get bc length of remaining string 
0f92			 
0f92				 
0f92 cd 87 0f			call input_curptr 
0f95			;	ld hl, (input_start) 
0f95			;	ld a, (input_cursor) 
0f95			;	call addatohl 
0f95				;push hl   ; save to come back to 
0f95			 
0f95				; shift everything up one to end of buffer 
0f95			 
0f95				;push hl 
0f95				;dec de 
0f95				;inc de 
0f95			;	ldir 
0f95				 
0f95				;pop hl 
0f95			 
0f95				; are we adding to the end of line? 
0f95			 
0f95 3a 48 ee			ld a, (input_cursor) 
0f98 47				ld b, a 
0f99 3a 4d ee			ld a, (input_len) 
0f9c b8				cp b 
0f9d 20 08			jr nz, .insmid   ; no, insert in middle of text 
0f9f			 
0f9f				; tack on the end of the line 
0f9f f1				pop af 
0fa0 77				ld (hl), a   ; save new char 
0fa1 23				inc hl 
0fa2			;	ld a, 0 
0fa2 36 00			ld (hl), 0 
0fa4 c3 51 0f			jp input_right 
0fa7				 
0fa7			.insmid: 
0fa7				; hl has insertion point so move everything up one to allow for insertion 
0fa7				;call input_shiftright 
0fa7 f1				pop af 
0fa8			 
0fa8			.shufinsmid: 
0fa8 47				ld b, a     ; b contains new char, c prev char at this position  
0fa9 7e				ld a, (hl) 
0faa			 
0faa			;	cp 0    ; at end of string need to then dump new char and add term 
0faa b7				or a 
0fab 28 07			jr z, .endinsmid 
0fad 4f				ld c, a 
0fae 78				ld a, b 
0faf 77				ld (hl), a 
0fb0 23				inc hl 
0fb1 79				ld a, c 
0fb2 18 f4			jr .shufinsmid 
0fb4				 
0fb4			 
0fb4			 
0fb4			 
0fb4			.endinsmid: 
0fb4 78				ld a, b 
0fb5 77				ld (hl), a 
0fb6 23				inc hl 
0fb7			;	ld a, 0 
0fb7 36 00			ld (hl), 0 
0fb9			 
0fb9			 
0fb9			;	ld (hl), a   ; save new char 
0fb9			 
0fb9 c3 51 0f			jp input_right 
0fbc			 
0fbc			;input_shiftright: 
0fbc			;	; shift text right at cursor, hl has shift start 
0fbc			;	push hl 
0fbc			;	push de 
0fbc			;	push bc 
0fbc			; 
0fbc			; 
0fbc			;	; move to end of string past zero term 
0fbc			;	ld hl,(input_start) 
0fbc			;	ld a, (input_len) 
0fbc			;	call addatohl 
0fbc			;	inc hl 
0fbc			;;	inc hl 
0fbc			;;	inc hl 
0fbc			;	ld a, 0 
0fbc			;	ld (hl), a 
0fbc			;;	dec hl 
0fbc			;	 
0fbc			;;	ld (hl), a 
0fbc			;;	dec hl 
0fbc			; 
0fbc			;	push hl 
0fbc			;	pop de 
0fbc			;	inc de 
0fbc			;	 
0fbc			; 
0fbc			;;	ld hl,(input_start) 
0fbc			;;	ld a, (input_cursor) 
0fbc			;;	call addatohl 
0fbc			; 
0fbc			; 
0fbc			;	; calc how many bytes from cursor pos to end of string we need to shift 
0fbc			;	call input_lenrem    ; get bc length of remaining string 
0fbc			;	;ld a, (input_cursor) 
0fbc			;	;ld c, a 
0fbc			;	ld a, (input_len) 
0fbc			;	cp 2 
0fbc			;	jr z, .iskipzero	 
0fbc			;	;sub c 
0fbc			;	;inc a 
0fbc			;	;ld c, a 
0fbc			;	;ld b, 0 
0fbc			;	inc c 
0fbc			;	inc c 
0fbc			;	; move data 
0fbc			;	lddr 
0fbc			;.iskipzero: 
0fbc			; 
0fbc			;	pop bc 
0fbc			;	pop de 
0fbc			;	pop hl 
0fbc			;	ret	 
0fbc			 
0fbc			input_delchar: 
0fbc				; Delete char at cursor position 
0fbc cd 7b 0f			call input_lenrem    ; get bc length of remaining string 
0fbf 2a 5a ee			ld hl, (input_start) 
0fc2 3a 48 ee			ld a, (input_cursor) 
0fc5 cd e6 0d			call addatohl 
0fc8			 
0fc8 e5				push hl 
0fc9 d1				pop de 
0fca 1b				dec de 
0fcb			 
0fcb			.dl:	 
0fcb ed a0			ldi  
0fcd 7e				ld a, (hl) 
0fce			;	cp 0 
0fce b7				or a 
0fcf 28 02			jr z, .dldone 
0fd1 18 f8			jr .dl 
0fd3			.dldone: 
0fd3 ed a0			ldi 
0fd5			 
0fd5 c3 4a 0f			jp input_left 
0fd8			 
0fd8			 
0fd8			endif 
0fd8			 
0fd8			 
0fd8			 
0fd8			if EDIT_V1 
0fd8			input_str: 
0fd8			 
0fd8				    	ld (input_at_pos),a      ; save display position to start 
0fd8					add c 
0fd8					ld (input_at_cursor),a	; save draw pos of cursor 
0fd8					ld (input_start), hl     ; save ptr to buffer 
0fd8					ld a, c 
0fd8					call addatohl 
0fd8					ld (input_ptr), hl     ; save ptr to point under the cursor 
0fd8					ld a,d 
0fd8				        ld (input_size), a       ; save length of input area 
0fd8					ld a, c 
0fd8					ld (input_cursor),a      ; init cursor start position  
0fd8					ld a,e 
0fd8				        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0fd8					 
0fd8					 
0fd8			 
0fd8			;		ld a,(input_ptr) 
0fd8			;		ld (input_under_cursor),a 	; save what is under the cursor 
0fd8			 
0fd8			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0fd8					; init cursor shape if not set by the cin routines 
0fd8					ld hl, cursor_shape 
0fd8			if BASE_KEV 
0fd8					ld a, 255 
0fd8			else 
0fd8					ld a, '#' 
0fd8			endif 
0fd8					ld (hl), a 
0fd8					inc hl 
0fd8					ld a, 0 
0fd8					ld (hl), a 
0fd8			 
0fd8					ld a, CUR_BLINK_RATE 
0fd8					ld (input_cur_flash), a 
0fd8					ld a, 1 
0fd8					ld (input_cur_onoff),a 
0fd8			 
0fd8			;	if DEBUG_INPUT 
0fd8			;		push af 
0fd8			;		ld a, 'I' 
0fd8			;		ld (debug_mark),a 
0fd8			;		pop af 
0fd8			;		CALLMONITOR 
0fd8			;	endif 
0fd8			.is1:		; main entry loop 
0fd8			 
0fd8			 
0fd8			 
0fd8					; pause 1ms 
0fd8			 
0fd8					ld a, 1 
0fd8					call aDelayInMS 
0fd8			 
0fd8					; dec flash counter 
0fd8					ld a, (input_cur_flash) 
0fd8					dec a 
0fd8					ld (input_cur_flash), a 
0fd8			;		cp 0 
0fd8					or a 
0fd8					jr nz, .nochgstate 
0fd8			 
0fd8			 
0fd8					; change state 
0fd8					ld a,(input_cur_onoff) 
0fd8					neg 
0fd8					ld (input_cur_onoff),a 
0fd8			 
0fd8			 
0fd8					; reset on change of state 
0fd8					ld a, CUR_BLINK_RATE 
0fd8					ld (input_cur_flash), a 
0fd8			 
0fd8			.nochgstate: 
0fd8					 
0fd8					 
0fd8			 
0fd8					; display cursor  
0fd8			 
0fd8			;		ld hl, (input_start) 
0fd8			;		ld a, (input_cursor) 
0fd8			;		call addatohl 
0fd8			 
0fd8					; get char under cursor and replace with cursor 
0fd8			ld hl, (input_ptr) 
0fd8			;		ld a, (hl) 
0fd8			;		ld (input_under_cursor),a 
0fd8			;		ld a, '_' 
0fd8			;		ld (hl), a 
0fd8			 
0fd8					; display string 
0fd8			 
0fd8					ld de, (input_start) 
0fd8					ld a, (input_at_pos) 
0fd8					call str_at_display 
0fd8			;	        call update_display 
0fd8			 
0fd8					; find place to put the cursor 
0fd8			;		add h 
0fd8			;		ld l, display_row_1 
0fd8			;		sub l 
0fd8			; (input_at_pos) 
0fd8					;ld c, a 
0fd8			;		ld a, (input_cursor) 
0fd8			;		ld l, (input_at_pos) 
0fd8			;		;ld b, h 
0fd8			;		add l 
0fd8			;		ld (input_at_cursor),a 
0fd8					;ld l,h 
0fd8			 
0fd8			;		ld h, 0 
0fd8			;		ld l,(input_at_pos) 
0fd8			;		ld a, (input_cursor) 
0fd8			;		call addatohl 
0fd8			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0fd8			;		call subafromhl 
0fd8			;		ld a,l 
0fd8			;		ld (input_at_cursor), a 
0fd8			 
0fd8				if DEBUG_INPUT 
0fd8					ld a, (hardware_diag) 
0fd8			;		cp 0 
0fd8					or a 
0fd8					jr z, .skip_input_diag 
0fd8			 
0fd8					ld a,(input_at_pos) 
0fd8					ld hl, LFSRSeed 
0fd8					call hexout 
0fd8					ld a, (input_cursor) 
0fd8					ld hl, LFSRSeed+2 
0fd8					call hexout 
0fd8					ld a,(input_at_cursor) 
0fd8					ld hl, LFSRSeed+4 
0fd8					call hexout 
0fd8			 
0fd8					ld a,(input_cur_onoff) 
0fd8					ld hl, LFSRSeed+6 
0fd8					call hexout 
0fd8			 
0fd8					ld a,(input_cur_flash) 
0fd8					ld hl, LFSRSeed+8 
0fd8					call hexout 
0fd8			 
0fd8					ld a,(input_len) 
0fd8					ld hl, LFSRSeed+10 
0fd8					call hexout 
0fd8					ld hl, LFSRSeed+12 
0fd8					ld a, 0 
0fd8					ld (hl),a 
0fd8					ld a, display_row_4 
0fd8					ld de, LFSRSeed 
0fd8					call str_at_display 
0fd8					.skip_input_diag: 
0fd8				endif 
0fd8			 
0fd8					; decide on if we are showing the cursor this time round 
0fd8			 
0fd8					ld a, (input_cur_onoff) 
0fd8					cp 255 
0fd8					jr z, .skipcur 
0fd8			 
0fd8			 
0fd8					ld a,(input_at_cursor) 
0fd8					ld de, cursor_shape 
0fd8					call str_at_display 
0fd8			 
0fd8					; save length of current input string 
0fd8					ld hl, (input_start) 
0fd8					ld a, 0 
0fd8					call strlent 
0fd8					ld a,l 
0fd8					ld (input_len),a 
0fd8			 
0fd8			.skipcur: 
0fd8			 
0fd8				        call update_display 
0fd8					 
0fd8			 
0fd8			 
0fd8					; wait 
0fd8				 
0fd8					; TODO loop without wait to flash the cursor and char under cursor	 
0fd8					call cin    ; _wait 
0fd8			 
0fd8			;		cp 0 
0fd8					or a 
0fd8					jp z, .is1 
0fd8			 
0fd8					; get ptr to char to input into 
0fd8			 
0fd8					ld c,a 
0fd8					ld hl, (input_start) 
0fd8					ld a, (input_cursor) 
0fd8					call addatohl 
0fd8					ld (input_ptr), hl 
0fd8					ld a,c 
0fd8			 
0fd8					; replace char under cursor 
0fd8			 
0fd8			;		ld hl, (input_ptr) 
0fd8			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0fd8			;		ld (hl), a 
0fd8			 
0fd8			;	if DEBUG_INPUT 
0fd8			;		push af 
0fd8			;		ld a, 'i' 
0fd8			;		ld (debug_mark),a 
0fd8			;		pop af 
0fd8			;		CALLMONITOR 
0fd8			;	endif 
0fd8					cp KEY_HOME 
0fd8					jr nz, .iske 
0fd8			 
0fd8					ld a, (input_at_pos) 
0fd8					ld (input_at_cursor),a 
0fd8					ld a, 0 
0fd8					ld (input_cursor), a 
0fd8					jp .is1 
0fd8					 
0fd8			.iske:		cp KEY_END 
0fd8					jr nz, .isknw 
0fd8					jp .is1 
0fd8			 
0fd8			.isknw:		cp KEY_NEXTWORD 
0fd8					jr nz, .iskpw 
0fd8			 
0fd8			.isknwm:	ld hl, (input_ptr) 
0fd8					ld a,(hl)	 
0fd8			;		cp 0 
0fd8					or a 
0fd8					jp z, .is1    ; end of string 
0fd8					cp ' ' 
0fd8					jp z, .is1    ; end of word 
0fd8					inc hl 
0fd8					ld (input_ptr), hl 
0fd8					ld a, (input_at_cursor) 
0fd8					inc a 
0fd8					ld (input_at_cursor), a 
0fd8					jr .isknwm 
0fd8			 
0fd8			.iskpw:		cp KEY_PREVWORD 
0fd8					jr nz, .iskl 
0fd8			.iskpwm:	 
0fd8					ld hl, (input_ptr) 
0fd8					ld a,(hl)	 
0fd8			;		cp 0  
0fd8					or a 
0fd8					jp z, .is1    ; end of string 
0fd8					cp ' ' 
0fd8					jp z, .is1    ; end of word 
0fd8					dec hl 
0fd8					ld (input_ptr), hl 
0fd8					ld a, (input_at_cursor) 
0fd8					dec a 
0fd8					ld (input_at_cursor), a 
0fd8					jr .iskpwm 
0fd8			 
0fd8			 
0fd8			.iskl:		cp KEY_LEFT 
0fd8					jr nz, .isk1 
0fd8			 
0fd8					ld a, (input_cursor) 
0fd8			 
0fd8			;		cp 0 
0fd8					or a 
0fd8					jp z, .is1 		; at start of line to ignore  
0fd8			 
0fd8					dec  a 		; TODO check underflow 
0fd8					ld (input_cursor), a 
0fd8			 
0fd8					ld hl, (input_ptr) 
0fd8					dec hl 
0fd8					ld (input_ptr), hl 
0fd8					 
0fd8					ld a, (input_at_cursor) 
0fd8					dec a 
0fd8					ld (input_at_cursor), a 
0fd8			 
0fd8					ld a, 1		; show cursor moving 
0fd8					ld (input_cur_onoff),a 
0fd8					ld a, CUR_BLINK_RATE 
0fd8					ld (input_cur_flash), a 
0fd8			 
0fd8					jp .is1 
0fd8			 
0fd8			.isk1:		cp KEY_RIGHT 
0fd8					jr nz, .isk2 
0fd8			 
0fd8					ld a,(input_len)		; TODO BUG why cant i load e direct? 
0fd8					ld e,a 
0fd8					ld a, (input_cursor) 
0fd8					cp e 
0fd8					jp z, .is1		; at the end of string so dont go right 
0fd8			 
0fd8					inc  a 		; TODO check overflow 
0fd8					ld (input_cursor), a 
0fd8			 
0fd8					ld a, (input_at_cursor) 
0fd8					inc a 
0fd8					ld (input_at_cursor), a 
0fd8			 
0fd8					ld hl, (input_ptr) 
0fd8					inc hl 
0fd8					ld (input_ptr), hl 
0fd8			 
0fd8					ld a, 1		; show cursor moving 
0fd8					ld (input_cur_onoff),a 
0fd8					ld a, CUR_BLINK_RATE 
0fd8					ld (input_cur_flash), a 
0fd8			 
0fd8					jp .is1 
0fd8			 
0fd8			.isk2:		cp KEY_UP 
0fd8			 
0fd8					jr nz, .isk3 
0fd8			 
0fd8					; swap last command with the current on 
0fd8			 
0fd8					; move cursor to start of string 
0fd8					ld hl, (input_start) 
0fd8					ld (input_ptr), hl 
0fd8			 
0fd8					ld a, (input_at_pos) 
0fd8					ld (input_at_cursor), a 
0fd8			 
0fd8					ld a, 0 
0fd8					ld (input_cursor), a 
0fd8					 
0fd8					; swap input and last command buffers 
0fd8			 
0fd8					ld hl, os_cli_cmd 
0fd8					ld de, os_last_cmd 
0fd8					ld b, 255 
0fd8			.swap1:		ld a, (hl) 
0fd8					ld c,a 
0fd8					ld a, (de) 
0fd8					ld (hl), a 
0fd8					ld a,c 
0fd8					ld (de),a 
0fd8					inc hl 
0fd8					inc de 
0fd8					djnz .swap1 
0fd8			 
0fd8			 
0fd8			 
0fd8			 
0fd8			 
0fd8					jp .is1 
0fd8			 
0fd8			.isk3:		cp KEY_BS 
0fd8					jr nz, .isk4 
0fd8			 
0fd8					ld a, (input_cursor) 
0fd8			 
0fd8			;		cp 0 
0fd8					or a 
0fd8					jp z, .is1 		; at start of line to ignore  
0fd8			 
0fd8					dec  a 		; TODO check underflow 
0fd8					ld (input_cursor), a 
0fd8			 
0fd8					; hl is source 
0fd8					; de needs to be source - 1 
0fd8			 
0fd8			;		ld a, 0 
0fd8			;		dec hl 
0fd8			;		ld (hl), a 
0fd8			 
0fd8					ld hl, (input_ptr) 
0fd8					dec hl 
0fd8					ld (input_ptr), hl 
0fd8			 
0fd8					; shift all data 
0fd8			 
0fd8					push hl 
0fd8					inc hl 
0fd8					pop de 
0fd8					ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0fd8					ld c,a 
0fd8					ld b,0 
0fd8					ldir  
0fd8			 
0fd8			 
0fd8			 
0fd8			 
0fd8					ld a, (input_at_cursor) 
0fd8					dec a 
0fd8					ld (input_at_cursor), a 
0fd8			 
0fd8			 
0fd8					ld a, 1		; show cursor moving 
0fd8					ld (input_cur_onoff),a 
0fd8					ld a, CUR_BLINK_RATE 
0fd8					ld (input_cur_flash), a 
0fd8			 
0fd8					; remove char 
0fd8					ld a, (input_at_cursor) 
0fd8					inc a 
0fd8					ld de,.iblank 
0fd8					call str_at_display 
0fd8			 
0fd8					jp .is1 
0fd8			 
0fd8			.isk4:		cp KEY_CR 
0fd8					jr z, .endinput 
0fd8			 
0fd8					; else add the key press to the end 
0fd8			 
0fd8					ld c, a			; save key pressed 
0fd8			 
0fd8					ld a,(hl)		; get what is currently under char 
0fd8			 
0fd8			;		cp 0			; we are at the end of the string 
0fd8					or a 
0fd8					jr nz, .onchar 
0fd8					 
0fd8					; add a char to the end of the string 
0fd8				 
0fd8					ld (hl),c 
0fd8					inc hl 
0fd8			;		ld a,' ' 
0fd8			;		ld (hl),a 
0fd8			;		inc hl 
0fd8					ld a,0 
0fd8					ld (hl),a 
0fd8					dec hl 
0fd8			 
0fd8					ld a, (input_cursor) 
0fd8					inc a				; TODO check max string length and scroll  
0fd8					ld (input_cursor), a		; inc cursor pos 
0fd8							 
0fd8					ld a, (input_at_cursor) 
0fd8					inc a 
0fd8					ld (input_at_cursor), a 
0fd8			 
0fd8					ld hl, (input_ptr) 
0fd8					inc hl 
0fd8					ld (input_ptr), hl 
0fd8			 
0fd8					ld hl, (input_ptr) 
0fd8					inc hl 
0fd8					ld (input_ptr), hl 
0fd8			;	if DEBUG_INPUT 
0fd8			;		push af 
0fd8			;		ld a, '+' 
0fd8			;		ld (debug_mark),a 
0fd8			;		pop af 
0fd8			;		CALLMONITOR 
0fd8			;	endif 
0fd8					ld a, 1		; show cursor moving 
0fd8					ld (input_cur_onoff),a 
0fd8					ld a, CUR_BLINK_RATE 
0fd8					ld (input_cur_flash), a 
0fd8					jp .is1 
0fd8					 
0fd8			 
0fd8			 
0fd8					; if on a char then insert 
0fd8			.onchar: 
0fd8			 
0fd8					; TODO over flow check: make sure insert does not blow out buffer 
0fd8			 
0fd8					; need to do some maths to use lddr 
0fd8			 
0fd8					push hl   ; save char pos 
0fd8					push bc 
0fd8			 
0fd8					ld hl, (input_start) 
0fd8					ld a, (input_len) 
0fd8					call addatohl  		; end of string 
0fd8					inc hl 
0fd8					inc hl		; past zero term 
0fd8					push hl 
0fd8					inc hl 
0fd8					push hl  
0fd8			 
0fd8								; start and end of lddr set, now how much to move? 
0fd8			 
0fd8							 
0fd8					ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0fd8					ld b,a 
0fd8					ld a,(input_len) 
0fd8					ld e,a 
0fd8					sub b 
0fd8					inc a		;?? 
0fd8					inc a		;?? 
0fd8					inc a		;?? 
0fd8			 
0fd8					ld b,0 
0fd8					ld c,a 
0fd8			 
0fd8				if DEBUG_INPUT 
0fd8					push af 
0fd8					ld a, 'i' 
0fd8					ld (debug_mark),a 
0fd8					pop af 
0fd8			;		CALLMONITOR 
0fd8				endif 
0fd8					pop de 
0fd8					pop hl 
0fd8				if DEBUG_INPUT 
0fd8					push af 
0fd8					ld a, 'I' 
0fd8					ld (debug_mark),a 
0fd8					pop af 
0fd8			;		CALLMONITOR 
0fd8				endif 
0fd8					lddr 
0fd8				 
0fd8			 
0fd8			 
0fd8					; TODO have a key for insert/overwrite mode???? 
0fd8					pop bc 
0fd8					pop hl 
0fd8					ld (hl), c		; otherwise overwrite current char 
0fd8					 
0fd8			 
0fd8			 
0fd8			 
0fd8					ld a, (input_cursor) 
0fd8					inc  a 		; TODO check overflow 
0fd8					ld (input_cursor), a 
0fd8			 
0fd8					ld a, (input_at_cursor) 
0fd8					inc a 
0fd8					ld (input_at_cursor), a 
0fd8			 
0fd8					jp .is1 
0fd8			 
0fd8			.endinput:	; TODO look for end of string 
0fd8			 
0fd8					; add trailing space for end of token 
0fd8			 
0fd8					ld hl, (input_start) 
0fd8					ld a,(input_len) 
0fd8					call addatohl 
0fd8					ld a, ' ' 
0fd8					ld (hl),a 
0fd8					; TODO eof of parse marker 
0fd8			 
0fd8					inc hl 
0fd8					ld a, 0 
0fd8					ld (hl),a 
0fd8			 
0fd8			 
0fd8					ret 
0fd8			 
0fd8			.iblank: db " ",0 
0fd8			 
0fd8			 
0fd8			input_str_prev:	ld (input_at_pos), a 
0fd8					ld (input_start), hl 
0fd8					ld a,1			; add cursor 
0fd8					ld (hl),a 
0fd8					inc hl 
0fd8					ld a,0 
0fd8					ld (hl),a 
0fd8					ld (input_ptr), hl 
0fd8					ld a,d 
0fd8					ld (input_size), a 
0fd8					ld a,0 
0fd8					ld (input_cursor),a 
0fd8			.instr1:	 
0fd8			 
0fd8					; TODO do block cursor 
0fd8					; TODO switch cursor depending on the modifer key 
0fd8			 
0fd8					; update cursor shape change on key hold 
0fd8			 
0fd8					ld hl, (input_ptr) 
0fd8					dec hl 
0fd8					ld a,(cursor_shape) 
0fd8					ld (hl), a 
0fd8			 
0fd8					; display entered text 
0fd8					ld a,(input_at_pos) 
0fd8			            	CALL fLCD_Pos       ;Position cursor to location in A 
0fd8			            	LD   de, (input_start) 
0fd8			            	CALL fLCD_Str       ;Display string pointed to by DE 
0fd8			 
0fd8					call cin 
0fd8			;		cp 0 
0fd8					or a 
0fd8					jr z, .instr1 
0fd8			 
0fd8					; proecess keyboard controls first 
0fd8			 
0fd8					ld hl,(input_ptr) 
0fd8			 
0fd8					cp KEY_CR	 ; pressing enter ends input 
0fd8					jr z, .instrcr 
0fd8			 
0fd8					cp KEY_BS 	; back space 
0fd8					jr nz, .instr2 
0fd8					; process back space 
0fd8			 
0fd8					; TODO stop back space if at start of string 
0fd8					dec hl 
0fd8					dec hl ; to over write cursor 
0fd8					ld a,(cursor_shape) 
0fd8					;ld a,0 
0fd8					ld (hl),a 
0fd8					inc hl 
0fd8					ld a," " 
0fd8					ld (hl),a 
0fd8					ld (input_ptr),hl 
0fd8					 
0fd8			 
0fd8					jr .instr1 
0fd8			 
0fd8			.instr2:	cp KEY_LEFT    ; cursor left 
0fd8					jr nz, .instr3 
0fd8					dec hl 
0fd8					ld (input_ptr),hl 
0fd8					jr .instr1 
0fd8				 
0fd8			.instr3:	cp KEY_RIGHT      ; cursor right 
0fd8					jr nz, .instr4 
0fd8					inc hl 
0fd8					ld (input_ptr),hl 
0fd8					jr .instr1 
0fd8			 
0fd8			.instr4:	cp KEY_HOME    ; jump to start of line 
0fd8					jr nz, .instr5 
0fd8					dec hl 
0fd8					ld (input_ptr),hl 
0fd8					jr .instr1 
0fd8			 
0fd8			.instr5:	cp KEY_END     ; jump to end of line 
0fd8					jr nz, .instr6 
0fd8					dec hl 
0fd8					ld (input_ptr),hl 
0fd8					jr .instr1 
0fd8			.instr6:        cp KEY_UP      ; recall last command 
0fd8					jr nz, .instrnew 
0fd8			 
0fd8				ld hl, scratch 
0fd8				ld de, os_last_cmd 
0fd8				call strcpy 
0fd8					jr .instr1 
0fd8			 
0fd8			 
0fd8			.instrnew:	; no special key pressed to see if we have room to store it 
0fd8			 
0fd8					; TODO do string size test 
0fd8			 
0fd8					dec hl ; to over write cursor 
0fd8					ld (hl),a 
0fd8					inc hl 
0fd8					ld a,(cursor_shape) 
0fd8					ld (hl),a 
0fd8					inc hl 
0fd8					ld a,0 
0fd8					ld (hl),a 
0fd8			 
0fd8					ld (input_ptr),hl 
0fd8					 
0fd8					jr .instr1 
0fd8			.instrcr:	dec hl		; remove cursor 
0fd8					ld a,' '	; TODO add a trailing space for safety 
0fd8					ld (hl),a 
0fd8					inc hl 
0fd8					ld a,0 
0fd8					ld (hl),a 
0fd8			 
0fd8			 
0fd8					; if at end of line scroll up    
0fd8					; TODO detecting only end of line 4 for scroll up  
0fd8			 
0fd8					;ld   
0fd8			 
0fd8					ret 
0fd8			 
0fd8			 
0fd8			endif 
0fd8			; strcpy hl = dest, de source 
0fd8			 
0fd8 1a			strcpy:   LD   A, (DE)        ;Get character from string 
0fd9 b7			            OR   A              ;Null terminator? 
0fda c8			            RET  Z              ;Yes, so finished 
0fdb 1a					ld a,(de) 
0fdc 77					ld (hl),a 
0fdd 13			            INC  DE             ;Point to next character 
0fde 23					inc hl 
0fdf 18 f7		            JR   strcpy       ;Repeat 
0fe1 c9					ret 
0fe2			 
0fe2			 
0fe2			; TODO string_at  
0fe2			; pass string which starts with lcd offset address and then null term string 
0fe2			 
0fe2			; TODO string to dec 
0fe2			; TODO string to hex 
0fe2			; TODO byte to string hex 
0fe2			; TODO byte to string dec 
0fe2			 
0fe2			 
0fe2			 
0fe2			; from z80uartmonitor 
0fe2			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0fe2			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
0fe2			; pass hl for where to put the text 
0fe2			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0fe2 c5			hexout:	PUSH BC 
0fe3 f5					PUSH AF 
0fe4 47					LD B, A 
0fe5					; Upper nybble 
0fe5 cb 3f				SRL A 
0fe7 cb 3f				SRL A 
0fe9 cb 3f				SRL A 
0feb cb 3f				SRL A 
0fed cd fd 0f				CALL tohex 
0ff0 77					ld (hl),a 
0ff1 23					inc hl	 
0ff2					 
0ff2					; Lower nybble 
0ff2 78					LD A, B 
0ff3 e6 0f				AND 0FH 
0ff5 cd fd 0f				CALL tohex 
0ff8 77					ld (hl),a 
0ff9 23					inc hl	 
0ffa					 
0ffa f1					POP AF 
0ffb c1					POP BC 
0ffc c9					RET 
0ffd					 
0ffd			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0ffd			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
0ffd			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0ffd			tohex: 
0ffd e5					PUSH HL 
0ffe d5					PUSH DE 
0fff 16 00				LD D, 0 
1001 5f					LD E, A 
1002 21 0a 10				LD HL, .DATA 
1005 19					ADD HL, DE 
1006 7e					LD A, (HL) 
1007 d1					POP DE 
1008 e1					POP HL 
1009 c9					RET 
100a			 
100a			.DATA: 
100a 30					DEFB	30h	; 0 
100b 31					DEFB	31h	; 1 
100c 32					DEFB	32h	; 2 
100d 33					DEFB	33h	; 3 
100e 34					DEFB	34h	; 4 
100f 35					DEFB	35h	; 5 
1010 36					DEFB	36h	; 6 
1011 37					DEFB	37h	; 7 
1012 38					DEFB	38h	; 8 
1013 39					DEFB	39h	; 9 
1014 41					DEFB	41h	; A 
1015 42					DEFB	42h	; B 
1016 43					DEFB	43h	; C 
1017 44					DEFB	44h	; D 
1018 45					DEFB	45h	; E 
1019 46					DEFB	46h	; F 
101a			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
101a			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
101a			;;    subtract $30, if result > 9 then subtract $7 more 
101a			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
101a			atohex: 
101a d6 30				SUB $30 
101c fe 0a				CP 10 
101e f8					RET M		; If result negative it was 0-9 so we're done 
101f d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
1021 c9					RET		 
1022			 
1022			 
1022			 
1022			 
1022			; Get 2 ASCII characters as hex byte from pointer in hl 
1022			 
1022			BYTERD: 
1022 16 00			LD	D,00h		;Set up 
1024 cd 2c 10			CALL	HEXCON		;Get byte and convert to hex 
1027 87				ADD	A,A		;First nibble so 
1028 87				ADD	A,A		;multiply by 16 
1029 87				ADD	A,A		; 
102a 87				ADD	A,A		; 
102b 57				LD	D,A		;Save hi nibble in D 
102c			HEXCON: 
102c 7e				ld a, (hl)		;Get next chr 
102d 23				inc hl 
102e d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
1030 fe 0a			CP	00Ah		;Is it 0-9 ? 
1032 38 02			JR	C,NALPHA	;If so miss next bit 
1034 d6 07			SUB	007h		;Else convert alpha 
1036			NALPHA: 
1036 b2				OR	D		;Add hi nibble back 
1037 c9				RET			; 
1038			 
1038			 
1038			; 
1038			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
1038			; Since the routines get_byte and therefore get_nibble are called, only valid 
1038			; characters (0-9a-f) are accepted. 
1038			; 
1038			;get_word        push    af 
1038			;                call    get_byte        ; Get the upper byte 
1038			;                ld      h, a 
1038			;                call    get_byte        ; Get the lower byte 
1038			;                ld      l, a 
1038			;                pop     af 
1038			;                ret 
1038			; 
1038			; Get a byte in hexadecimal notation. The result is returned in A. Since 
1038			; the routine get_nibble is used only valid characters are accepted - the  
1038			; input routine only accepts characters 0-9a-f. 
1038			; 
1038 c5			get_byte:        push    bc              ; Save contents of B (and C) 
1039 7e					ld a,(hl) 
103a 23					inc hl 
103b cd 60 10		                call    nibble2val      ; Get upper nibble 
103e cb 07		                rlc     a 
1040 cb 07		                rlc     a 
1042 cb 07		                rlc     a 
1044 cb 07		                rlc     a 
1046 47			                ld      b, a            ; Save upper four bits 
1047 7e					ld a,(hl) 
1048 cd 60 10		                call    nibble2val      ; Get lower nibble 
104b b0			                or      b               ; Combine both nibbles 
104c c1			                pop     bc              ; Restore B (and C) 
104d c9			                ret 
104e			; 
104e			; Get a hexadecimal digit from the serial line. This routine blocks until 
104e			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
104e			; to the serial line interface. The lower 4 bits of A contain the value of  
104e			; that particular digit. 
104e			; 
104e			;get_nibble      ld a,(hl)           ; Read a character 
104e			;                call    to_upper        ; Convert to upper case 
104e			;                call    is_hex          ; Was it a hex digit? 
104e			;                jr      nc, get_nibble  ; No, get another character 
104e			 ;               call    nibble2val      ; Convert nibble to value 
104e			 ;               call    print_nibble 
104e			 ;               ret 
104e			; 
104e			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
104e			; A valid hexadecimal digit is denoted by a set C flag. 
104e			; 
104e			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
104e			;                ret     nc              ; Yes 
104e			;                cp      '0'             ; Less than '0'? 
104e			;                jr      nc, is_hex_1    ; No, continue 
104e			;                ccf                     ; Complement carry (i.e. clear it) 
104e			;                ret 
104e			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
104e			;                ret     c               ; Yes 
104e			;                cp      'A'             ; Less than 'A'? 
104e			;                jr      nc, is_hex_2    ; No, continue 
104e			;                ccf                     ; Yes - clear carry and return 
104e			;                ret 
104e			;is_hex_2        scf                     ; Set carry 
104e			;                ret 
104e			; 
104e			; Convert a single character contained in A to upper case: 
104e			; 
104e fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
1050 d8			                ret     c 
1051 fe 7b		                cp      'z' + 1         ; > 'z'? 
1053 d0			                ret     nc              ; Nothing to do, either 
1054 e6 5f		                and     $5f             ; Convert to upper case 
1056 c9			                ret 
1057			 
1057			 
1057			to_lower: 
1057			 
1057			   ; if char is in [A-Z] make it lower case 
1057			 
1057			   ; enter : a = char 
1057			   ; exit  : a = lower case char 
1057			   ; uses  : af 
1057			 
1057 fe 41		   cp 'A' 
1059 d8			   ret c 
105a			    
105a fe 5b		   cp 'Z'+1 
105c d0			   ret nc 
105d			    
105d f6 20		   or $20 
105f c9			   ret 
1060			 
1060			; 
1060			; Expects a hexadecimal digit (upper case!) in A and returns the 
1060			; corresponding value in A. 
1060			; 
1060 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
1062 38 02		                jr      c, nibble2val_1 ; Yes 
1064 d6 07		                sub     7               ; Adjust for A-F 
1066 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
1068 e6 0f		                and     $f              ; Only return lower 4 bits 
106a c9			                ret 
106b			; 
106b			; Print_nibble prints a single hex nibble which is contained in the lower  
106b			; four bits of A: 
106b			; 
106b			;print_nibble    push    af              ; We won't destroy the contents of A 
106b			;                and     $f              ; Just in case... 
106b			;                add     a, '0'             ; If we have a digit we are done here. 
106b			;                cp      '9' + 1         ; Is the result > 9? 
106b			;                jr      c, print_nibble_1 
106b			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
106b			;print_nibble_1  call    putc            ; Print the nibble and 
106b			;                pop     af              ; restore the original value of A 
106b			;                ret 
106b			;; 
106b			;; Send a CR/LF pair: 
106b			; 
106b			;crlf            push    af 
106b			;                ld      a, cr 
106b			;                call    putc 
106b			;                ld      a, lf 
106b			;                call    putc 
106b			;                pop     af 
106b			;                ret 
106b			; 
106b			; Print_word prints the four hex digits of a word to the serial line. The  
106b			; word is expected to be in HL. 
106b			; 
106b			;print_word      push    hl 
106b			;                push    af 
106b			;                ld      a, h 
106b			;                call    print_byte 
106b			;                ld      a, l 
106b			;                call    print_byte 
106b			;                pop     af 
106b			;                pop     hl 
106b			;                ret 
106b			; 
106b			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
106b			; The byte to be printed is expected to be in A. 
106b			; 
106b			;print_byte      push    af              ; Save the contents of the registers 
106b			;                push    bc 
106b			;                ld      b, a 
106b			;                rrca 
106b			;                rrca 
106b			;                rrca 
106b			;                rrca 
106b			;                call    print_nibble    ; Print high nibble 
106b			;                ld      a, b 
106b			;                call    print_nibble    ; Print low nibble 
106b			;                pop     bc              ; Restore original register contents 
106b			;                pop     af 
106b			;                ret 
106b			 
106b			 
106b			 
106b			 
106b			 
106b			fourehexhl:  
106b 7e				ld a,(hl) 
106c cd 1a 10			call atohex 
106f cb 3f				SRL A 
1071 cb 3f				SRL A 
1073 cb 3f				SRL A 
1075 cb 3f				SRL A 
1077 47				ld b, a 
1078 23				inc hl 
1079 7e				ld a,(hl) 
107a 23				inc hl 
107b cd 1a 10			call atohex 
107e 80				add b 
107f 57				ld d,a 
1080 7e				ld a,(hl) 
1081 cd 1a 10			call atohex 
1084 cb 3f				SRL A 
1086 cb 3f				SRL A 
1088 cb 3f				SRL A 
108a cb 3f				SRL A 
108c 47				ld b, a 
108d 23				inc hl 
108e 7e				ld a,(hl) 
108f 23				inc hl 
1090 cd 1a 10			call atohex 
1093 80				add b 
1094 5f				ld e, a 
1095 d5				push de 
1096 e1				pop hl 
1097 c9				ret 
1098			 
1098			; pass hl. returns z set if the byte at hl is a digit 
1098			;isdigithl:  
1098			;	push bc 
1098			;	ld a,(hl) 
1098			;	cp ':' 
1098			;	jr nc, .isdf 		; > 
1098			;	cp '0' 
1098			;	jr c, .isdf		; < 
1098			; 
1098			;	; TODO find a better way to set z 
1098			; 
1098			;	ld b,a 
1098			;	cp b 
1098			;	pop bc 
1098			;	ret 
1098			; 
1098			;.isdf:	; not digit so clear z 
1098			; 
1098			;	; TODO find a better way to unset z 
1098			; 
1098			;	ld b,a 
1098			;	inc b 
1098			;	cp b 
1098			; 
1098			;	pop bc 
1098			;	ret 
1098				 
1098				 
1098			 
1098			 
1098			; pass hl as the four byte address to load 
1098			 
1098			get_word_hl:  
1098 e5				push hl 
1099 cd 38 10			call get_byte 
109c				 
109c 47				ld b, a 
109d			 
109d e1				pop hl 
109e 23				inc hl 
109f 23				inc hl 
10a0			 
10a0			; TODO not able to handle a-f  
10a0 7e				ld a,(hl) 
10a1			;	;cp ':' 
10a1			;	cp 'g' 
10a1			;	jr nc, .single_byte_hl 		; > 
10a1			;	cp 'G' 
10a1			;	jr nc, .single_byte_hl 		; > 
10a1			;	cp '0' 
10a1			;	jr c, .single_byte_hl		; < 
10a1			 
10a1				;call isdigithl 
10a1			;	cp 0 
10a1 b7				or a 
10a2 28 06			jr z, .single_byte_hl 
10a4			 
10a4			.getwhln:   ; hex word so get next byte 
10a4			 
10a4 cd 38 10			call get_byte 
10a7 6f				ld l, a 
10a8 60				ld h,b 
10a9 c9				ret 
10aa 68			.single_byte_hl:   ld l,b 
10ab 26 00				ld h,0 
10ad c9					ret 
10ae			 
10ae			 
10ae			 
10ae			 
10ae 21 b6 17			ld hl,asc+1 
10b1			;	ld a, (hl) 
10b1			;	call nibble2val 
10b1 cd 38 10			call get_byte 
10b4			 
10b4			;	call fourehexhl 
10b4 32 e8 e2			ld (scratch+52),a 
10b7				 
10b7 21 e6 e2			ld hl,scratch+50 
10ba 22 d7 e5			ld (os_cur_ptr),hl 
10bd			 
10bd c9				ret 
10be			 
10be			 
10be			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
10be			 
10be			; Decimal Unsigned Version 
10be			 
10be			;Number in a to decimal ASCII 
10be			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
10be			;Example: display a=56 as "056" 
10be			;input: a = number 
10be			;Output: a=0,value of a in the screen 
10be			;destroys af,bc (don't know about hl and de) 
10be			DispAToASCII: 
10be 0e 9c			ld	c,-100 
10c0 cd ca 10			call	.Na1 
10c3 0e f6			ld	c,-10 
10c5 cd ca 10			call	.Na1 
10c8 0e ff			ld	c,-1 
10ca 06 2f		.Na1:	ld	b,'0'-1 
10cc 04			.Na2:	inc	b 
10cd 81				add	a,c 
10ce 38 fc			jr	c,.Na2 
10d0 91				sub	c		;works as add 100/10/1 
10d1 f5				push af		;safer than ld c,a 
10d2 78				ld	a,b		;char is in b 
10d3			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
10d3 f1				pop af		;safer than ld a,c 
10d4 c9				ret 
10d5			 
10d5			; Decimal Signed Version 
10d5			 
10d5			; DispA 
10d5			; -------------------------------------------------------------- 
10d5			; Converts a signed integer value to a zero-terminated ASCII 
10d5			; string representative of that value (using radix 10). 
10d5			; -------------------------------------------------------------- 
10d5			; INPUTS: 
10d5			;     HL     Value to convert (two's complement integer). 
10d5			;     DE     Base address of string destination. (pointer). 
10d5			; -------------------------------------------------------------- 
10d5			; OUTPUTS: 
10d5			;     None 
10d5			; -------------------------------------------------------------- 
10d5			; REGISTERS/MEMORY DESTROYED 
10d5			; AF HL 
10d5			; -------------------------------------------------------------- 
10d5			 
10d5			;DispHLToASCII: 
10d5			;   push    de 
10d5			;   push    bc 
10d5			; 
10d5			;; Detect sign of HL. 
10d5			;    bit    7, h 
10d5			;    jr     z, ._DoConvert 
10d5			; 
10d5			;; HL is negative. Output '-' to string and negate HL. 
10d5			;    ld     a, '-' 
10d5			;    ld     (de), a 
10d5			;    inc    de 
10d5			; 
10d5			;; Negate HL (using two's complement) 
10d5			;    xor    a 
10d5			;    sub    l 
10d5			;    ld     l, a 
10d5			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
10d5			;    sbc    a, h 
10d5			;    ld     h, a 
10d5			; 
10d5			;; Convert HL to digit characters 
10d5			;._DoConvert: 
10d5			;    ld     b, 0     ; B will count character length of number 
10d5			;-   ld     a, 10 
10d5			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
10d5			;    push   af 
10d5			;    inc    b 
10d5			;    ld     a, h 
10d5			;    or     l 
10d5			;    jr     nz, - 
10d5			; 
10d5			;; Retrieve digits from stack 
10d5			;-   pop    af 
10d5			;    or     $30 
10d5			;    ld     (de), a 
10d5			;    inc    de 
10d5			;    djnz   - 
10d5			; 
10d5			;; Terminate string with NULL 
10d5			;    xor    a 
10d5			;    ld     (de), a 
10d5			; 
10d5			;    pop    bc 
10d5			;    pop    de 
10d5			;    ret 
10d5			 
10d5			;Comments 
10d5			; 
10d5			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
10d5			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
10d5			;    Note that the output string will not be fixed-width. 
10d5			; 
10d5			;Example Usage 
10d5			; 
10d5			;    ld    hl, -1004 
10d5			;    ld    de, OP1 
10d5			;    call  DispA 
10d5			;    ld    hl, OP1 
10d5			;    syscall  PutS 
10d5			 
10d5			 
10d5			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
10d5			 
10d5			 
10d5			;Converts an ASCII string to an unsigned 16-bit integer 
10d5			;Quits when it reaches a non-decimal digit 
10d5			 
10d5			string_to_uint16: 
10d5			atoui_16: 
10d5			;Input: 
10d5			;     DE points to the string 
10d5			;Outputs: 
10d5			;     HL is the result 
10d5			;     A is the 8-bit value of the number 
10d5			;     DE points to the byte after the number 
10d5			;Destroys: 
10d5			;     BC 
10d5			;       if the string is non-empty, BC is HL/10 
10d5			;Size:  24 bytes 
10d5			;Speed: 42+d(104+{0,9}) 
10d5			;       d is the number of digits in the number 
10d5			;       max is 640 cycles for a 5 digit number 
10d5			;Assuming no leading zeros: 
10d5			;1 digit:  146cc 
10d5			;2 digit:  250cc 
10d5			;3 digit:  354cc or 363cc (avg: 354.126cc) 
10d5			;4 digit:  458cc or 467cc (avg: 458.27cc) 
10d5			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
10d5			;avg: 544.81158447265625cc (544+13297/16384) 
10d5			;=============================================================== 
10d5 21 00 00		  ld hl,0 
10d8			.u16a: 
10d8 1a			  ld a,(de) 
10d9 d6 30		  sub 30h 
10db fe 0a		  cp 10 
10dd d0			  ret nc 
10de 13			  inc de 
10df 44			  ld b,h 
10e0 4d			  ld c,l 
10e1 29			  add hl,hl 
10e2 29			  add hl,hl 
10e3 09			  add hl,bc 
10e4 29			  add hl,hl 
10e5 85			  add a,l 
10e6 6f			  ld l,a 
10e7 30 ef		  jr nc,.u16a 
10e9 24			  inc h 
10ea c3 d8 10		  jp .u16a 
10ed			 
10ed			 
10ed			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
10ed			 
10ed			;written by Zeda 
10ed			;Converts a 16-bit unsigned integer to an ASCII string. 
10ed			 
10ed			uitoa_16: 
10ed			;Input: 
10ed			;   DE is the number to convert 
10ed			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
10ed			;Output: 
10ed			;   HL points to the null-terminated ASCII string 
10ed			;      NOTE: This isn't necessarily the same as the input HL. 
10ed d5			  push de 
10ee c5			  push bc 
10ef f5			  push af 
10f0 eb			  ex de,hl 
10f1			 
10f1 01 f0 d8		  ld bc,-10000 
10f4 3e 2f		  ld a,'0'-1 
10f6 3c			  inc a 
10f7 09			  add hl,bc  
10f8 38 fc		   jr c,$-2 
10fa 12			  ld (de),a 
10fb 13			  inc de 
10fc			 
10fc 01 e8 03		  ld bc,1000 
10ff 3e 3a		  ld a,'9'+1 
1101 3d			  dec a  
1102 09			  add hl,bc  
1103 30 fc		   jr nc,$-2 
1105 12			  ld (de),a 
1106 13			  inc de 
1107			 
1107 01 9c ff		  ld bc,-100 
110a 3e 2f		  ld a,'0'-1 
110c 3c			  inc a  
110d 09			  add hl,bc  
110e 38 fc		   jr c,$-2 
1110 12			  ld (de),a 
1111 13			  inc de 
1112			 
1112 7d			  ld a,l 
1113 26 3a		  ld h,'9'+1 
1115 25			  dec h  
1116 c6 0a		  add a,10  
1118 30 fb		   jr nc,$-3 
111a c6 30		  add a,'0' 
111c eb			  ex de,hl 
111d 72			  ld (hl),d 
111e 23			  inc hl 
111f 77			  ld (hl),a 
1120 23			  inc hl 
1121 36 00		  ld (hl),0 
1123			 
1123			;Now strip the leading zeros 
1123 0e fa		  ld c,-6 
1125 09			  add hl,bc 
1126 3e 30		  ld a,'0' 
1128 23			  inc hl  
1129 be			  cp (hl)  
112a 28 fc		  jr z,$-2 
112c			 
112c			;Make sure that the string is non-empty! 
112c 7e			  ld a,(hl) 
112d b7			  or a 
112e 20 01		  jr nz,.atoub 
1130 2b			  dec hl 
1131			.atoub: 
1131			 
1131 f1			  pop af 
1132 c1			  pop bc 
1133 d1			  pop de 
1134 c9			  ret 
1135			 
1135			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
1135			 
1135			toUpper: 
1135			;A is the char. 
1135			;If A is a lowercase letter, this sets it to the matching uppercase 
1135			;18cc or 30cc or 41cc 
1135			;avg: 26.75cc 
1135 fe 61		  cp 'a' 
1137 d8			  ret c 
1138 fe 7b		  cp 'z'+1 
113a d0			  ret nc 
113b d6 20		  sub 'a'-'A' 
113d c9			  ret 
113e			 
113e			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
113e			 
113e			; String Length 
113e			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
113e			 
113e			; Get the length of the null-terminated string starting at $8000 hl 
113e			;    LD     HL, $8000 
113e			 
113e			strlenz: 
113e			 
113e af			    XOR    A               ; Zero is the value we are looking for. 
113f 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1140 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1141			                           ; 65, 536 bytes (the entire addressable memory space). 
1141 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1143			 
1143			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1143 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
1144 6f			    LD     L, A             ; number of bytes 
1145 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1147 2b			    DEC    HL              ; Compensate for null. 
1148 c9				ret 
1149			 
1149			; Get the length of the A terminated string starting at $8000 hl 
1149			;    LD     HL, $8000 
1149			 
1149			strlent: 
1149			 
1149			                  ; A is the value we are looking for. 
1149 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
114b 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
114d			                           ; 65, 536 bytes (the entire addressable memory space). 
114d ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
114f			 
114f			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
114f 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1151 2e 00		    LD     L, 0             ; number of bytes 
1153 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1155 2b			    DEC    HL              ; Compensate for null. 
1156 c9				ret 
1157			 
1157			 
1157			;Comparing Strings 
1157			 
1157			;IN    HL     Address of string1. 
1157			;      DE     Address of string2. 
1157			 
1157			; doc given but wrong??? 
1157			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
1157			;      carry  Set if string1 > string2, reset if string1 <= string2. 
1157			; tested 
1157			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
1157			 
1157			strcmp_old: 
1157 e5			    PUSH   HL 
1158 d5			    PUSH   DE 
1159			 
1159 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
115a be			    CP     (HL)            ; (want to minimize work). 
115b 38 01		    JR     C, Str1IsBigger 
115d 7e			    LD     A, (HL) 
115e			 
115e			Str1IsBigger: 
115e 4f			    LD     C, A             ; Put length in BC 
115f 06 00		    LD     B, 0 
1161 13			    INC    DE              ; Increment pointers to meat of string. 
1162 23			    INC    HL 
1163			 
1163			CmpLoop: 
1163 1a			    LD     A, (DE)          ; Compare bytes. 
1164 ed a1		    CPI 
1166 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
1168 13			    INC    DE              ; Update pointer. 
1169 ea 63 11		    JP     PE, CmpLoop 
116c			 
116c d1			    POP    DE 
116d e1			    POP    HL 
116e 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
116f be			    CP     (HL) 
1170 c9			    RET 
1171			 
1171			NoMatch: 
1171 2b			    DEC    HL 
1172 be			    CP     (HL)            ; Compare again to affect carry. 
1173 d1			    POP    DE 
1174 e1			    POP    HL 
1175 c9			    RET 
1176			 
1176			;; test strmp 
1176			; 
1176			;ld de, .str1 
1176			;ld hl, .str2 
1176			;call strcmp 
1176			;jr z, .z1 
1176			;;this 
1176			;	if DEBUG_FORTH_WORDS 
1176			;		DMARK "NZ1" 
1176			;		CALLMONITOR 
1176			;	endif 
1176			;.z1: 
1176			; 
1176			;	if DEBUG_FORTH_WORDS 
1176			;		DMARK "ZZ1" 
1176			;		CALLMONITOR 
1176			;	endif 
1176			; 
1176			;ld de, .str1 
1176			;ld hl, .str1 
1176			;call strcmp 
1176			;jr z, .z2 
1176			;;this 
1176			;	if DEBUG_FORTH_WORDS 
1176			;		DMARK "NZ2" 
1176			;		CALLMONITOR 
1176			;	endif 
1176			;.z2: 
1176			; 
1176			;	if DEBUG_FORTH_WORDS 
1176			;		DMARK "ZZ2" 
1176			;		CALLMONITOR 
1176			;	endif 
1176			; 
1176			;ld de, .str1 
1176			;ld hl, .str2 
1176			;call strcmp 
1176			;jr c, .c1 
1176			; 
1176			;	if DEBUG_FORTH_WORDS 
1176			;		DMARK "Nc1" 
1176			;		CALLMONITOR 
1176			;	endif 
1176			;.c1: 
1176			;;this 
1176			;	if DEBUG_FORTH_WORDS 
1176			;		DMARK "cc1" 
1176			;		CALLMONITOR 
1176			;	endif 
1176			; 
1176			;ld de, .str1 
1176			;ld hl, .str1 
1176			;call strcmp 
1176			;jr c, .c2 
1176			;;this 
1176			;	if DEBUG_FORTH_WORDS 
1176			;		DMARK "Nc2" 
1176			;		CALLMONITOR 
1176			;	endif 
1176			;.c2: 
1176			; 
1176			;	if DEBUG_FORTH_WORDS 
1176			;		DMARK "cc2" 
1176			;		CALLMONITOR 
1176			;	endif 
1176			;	NEXTW 
1176			;.str1:   db "string1",0 
1176			;.str2:   db "string2",0 
1176			 
1176			; only care about direct match or not 
1176			; hl and de strings 
1176			; zero set if the same 
1176			 
1176			strcmp: 
1176 1a				ld a, (de) 
1177 be				cp (hl) 
1178 28 02			jr z, .ssame 
117a b7				or a 
117b c9				ret 
117c			 
117c			.ssame:  
117c			;	cp 0 
117c b7				or a 
117d c8				ret z 
117e			 
117e 23				inc hl 
117f 13				inc de 
1180 18 f4			jr strcmp 
1182				 
1182				 
1182			 
1182			;Copyright (c) 2014, Luke Maurits 
1182			;All rights reserved. 
1182			; 
1182			;Redistribution and use in source and binary forms, with or without 
1182			;modification, are permitted provided that the following conditions are met: 
1182			; 
1182			;* Redistributions of source code must retain the above copyright notice, this 
1182			;  list of conditions and the following disclaimer. 
1182			; 
1182			;* Redistributions in binary form must reproduce the above copyright notice, 
1182			;  this list of conditions and the following disclaimer in the documentation 
1182			;  and/or other materials provided with the distribution. 
1182			; 
1182			;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
1182			;AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
1182			;IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
1182			;DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE 
1182			;FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
1182			;DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
1182			;SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
1182			;CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
1182			;OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
1182			;OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
1182			 
1182			; https://github.com/lmaurits/lm512/blob/master/string.z80 
1182			 
1182			StrictStrCmp: 
1182				; Load next chars of each string 
1182 1a				ld a, (de) 
1183 47				ld b, a 
1184 7e				ld a, (hl) 
1185				; Compare 
1185 b8				cp b 
1186				; Return non-zero if chars don't match 
1186 c0				ret nz 
1187				; Check for end of both strings 
1187 fe 00			cp "\0" 
1189				; Return if strings have ended 
1189 c8				ret z 
118a				; Otherwise, advance to next chars 
118a 23				inc hl 
118b 13				inc de 
118c 18 f4			jr StrictStrCmp 
118e			 
118e			;end 
118e			; eof 
118e			 
118e			 
118e			 
118e			 
118e			 
118e			 
# End of file firmware_strings.asm
118e			include "firmware_memory.asm"   ; malloc and free  
118e			 
118e			if DEBUG_FORTH_MALLOC_HIGH 
118e			.mallocsize: db "Wants malloc >256",0 
118e			.mallocasize: db "MALLOC gives >256",0 
118e			.malloczero: db "MALLOC gives zero",0 
118e			 
118e			malloc_guard_zerolen: 
118e				push hl 
118e				push de 
118e				push af 
118e			 
118e				ld de, 0 
118e			        call cmp16 
118e				jr nz, .lowalloz 
118e			 
118e				push hl 
118e				push de 
118e					ld hl, display_fb0 
118e					ld (display_fb_active), hl 
118e				call clear_display 
118e				ld a, 0 
118e				ld de, .malloczero 
118e				call str_at_display 
118e				call update_display 
118e				call delay1s 
118e				call delay1s 
118e				call bp_on 
118e			;	ld a, 0 
118e			;	ld (os_view_disable), a 
118e			 
118e				pop de 
118e				pop hl 
118e			 
118e				 
118e			 
118e				CALLMONITOR 
118e			.lowalloz: 
118e			 
118e			 
118e				pop af 
118e				pop de 
118e				pop hl 
118e			ret 
118e			 
118e			malloc_guard_entry: 
118e				push hl 
118e				push de 
118e				push af 
118e			 
118e			 	or a      ;clear carry flag 
118e				push hl 
118e				ld de, 255 
118e				sbc hl, de 
118e				jr c, .lowalloc 
118e			 
118e				push de 
118e					ld hl, display_fb0 
118e					ld (display_fb_active), hl 
118e				call clear_display 
118e				ld a, 0 
118e				ld de, .mallocsize 
118e				call str_at_display 
118e				call update_display 
118e				call delay1s 
118e				call delay1s 
118e			;	ld a, 0 
118e			;	ld (os_view_disable), a 
118e				call bp_on 
118e			 
118e				pop de 
118e				pop hl 
118e			 
118e				 
118e			 
118e				CALLMONITOR 
118e				jr .lowdone 
118e			.lowalloc: 
118e			 
118e			 
118e				pop hl 
118e			.lowdone:	pop af 
118e				pop de 
118e				pop hl 
118e			ret 
118e			 
118e			malloc_guard_exit: 
118e				push hl 
118e				push de 
118e				push af 
118e			 
118e			 	or a      ;clear carry flag 
118e				push hl 
118e				ld de, 255 
118e				sbc hl, de 
118e				jr c, .lowallocx 
118e			 
118e				push de 
118e					ld hl, display_fb0 
118e					ld (display_fb_active), hl 
118e				call clear_display 
118e				ld a, 0 
118e				ld de, .mallocasize 
118e				call str_at_display 
118e				call update_display 
118e				call delay1s 
118e				call delay1s 
118e			;	ld a, 0 
118e			;	ld (os_view_disable), a 
118e				call bp_on 
118e				pop de 
118e				pop hl 
118e			 
118e				CALLMONITOR 
118e				jr .lowdonex 
118e			.lowallocx: 
118e			 
118e				pop hl 
118e			.lowdonex:	pop af 
118e				pop de 
118e				pop hl 
118e			ret 
118e			endif 
118e			 
118e			if MALLOC_2 
118e			; Z80 Malloc and Free Functions 
118e			 
118e			; Malloc Function: 
118e			; Input: 
118e			;   HL: Size of block to allocate 
118e			; Output: 
118e			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
118e			 
118e			malloc: 
118e				 
118e			if DEBUG_FORTH_MALLOC_HIGH 
118e			call malloc_guard_entry 
118e			endif 
118e			 
118e			 
118e			 
118e			 
118e					if DEBUG_FORTH_MALLOC 
118e						DMARK "mal" 
118e						CALLMONITOR 
118e					endif 
118e			    push af            ; Save AF register 
118e			    ld a, l            ; Load low byte of size into A 
118e			    or h               ; Check if size is zero 
118e			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
118e			 
118e			    ; Allocate memory 
118e			    ld hl, (heap_start) ; Load start of heap into HL 
118e					if DEBUG_FORTH_MALLOC 
118e						DMARK "ma1" 
118e						CALLMONITOR 
118e					endif 
118e			    call malloc_internal ; Call internal malloc function 
118e			    pop af             ; Restore AF register 
118e			if DEBUG_FORTH_MALLOC_HIGH 
118e			call malloc_guard_exit 
118e			call malloc_guard_zerolen 
118e			endif 
118e			    ret                ; Return 
118e			 
118e			; Free Function: 
118e			; Input: 
118e			;   HL: Pointer to memory block to free 
118e			; Output: 
118e			;   None 
118e			 
118e			free: 
118e			    push af            ; Save AF register 
118e			    ld a, l            ; Load low byte of pointer into A 
118e			    or h               ; Check if pointer is NULL 
118e			    jp z, free_exit    ; If pointer is NULL, exit 
118e			 
118e			    ; Free memory 
118e			    ld hl, (heap_start) ; Load start of heap into HL 
118e			    call free_internal  ; Call internal free function 
118e			    pop af             ; Restore AF register 
118e			    ret                ; Return 
118e			 
118e			; Internal Malloc Function: 
118e			; Input: 
118e			;   HL: Size of block to allocate 
118e			; Output: 
118e			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
118e			 
118e			malloc_internal: 
118e			    ld bc, 2           ; Number of bytes to allocate for management overhead 
118e			    add hl, bc         ; Add management overhead to requested size 
118e			    ex de, hl          ; Save total size in DE, and keep it in HL 
118e					if DEBUG_FORTH_MALLOC 
118e						DMARK "ma2" 
118e						CALLMONITOR 
118e					endif 
118e			 
118e			    ; Search for free memory block 
118e			    ld de, (heap_end)  ; Load end of heap into DE 
118e			    ld bc, 0           ; Initialize counter 
118e			 
118e					if DEBUG_FORTH_MALLOC 
118e						DMARK "ma2" 
118e						CALLMONITOR 
118e					endif 
118e			malloc_search_loop: 
118e			    ; Check if current block is free 
118e			    ld a, (hl)         ; Load current block's status (free or used) 
118e			;    cp 0               ; Compare with zero (free) 
118e				or a 
118e			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
118e			 
118e			    ; Check if current block is large enough 
118e			    ld a, (hl+1)       ; Load high byte of block size 
118e			    cp l               ; Compare with low byte of requested size 
118e			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
118e			 
118e			    ld a, (hl+2)       ; Load low byte of block size 
118e			    cp h               ; Compare with high byte of requested size 
118e			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
118e			 
118e			    ; Mark block as used 
118e			    ld (hl), 0xFF      ; Set status byte to indicate used block 
118e			 
118e			    ; Calculate remaining space in block 
118e			    ld bc, 0           ; Clear BC 
118e			    add hl, bc         ; Increment HL to point to start of data block 
118e			    add hl, de         ; HL = HL + DE (total size) 
118e			    ld bc, 1           ; Number of bytes to allocate for management overhead 
118e			    add hl, bc         ; Add management overhead to start of data block 
118e			 
118e			    ; Save pointer to allocated block in HL 
118e			if DEBUG_FORTH_MALLOC_HIGH 
118e						DMARK "ma5" 
118e			call malloc_guard_exit 
118e			call malloc_guard_zerolen 
118e			endif 
118e			    ret 
118e			 
118e			malloc_skip_block_check: 
118e			    ; Move to the next block 
118e			    ld bc, 3           ; Size of management overhead 
118e			    add hl, bc         ; Move to the next block 
118e			    inc de             ; Increment counter 
118e			 
118e			    ; Check if we have reached the end of heap 
118e			    ld a, e            ; Load low byte of heap end address 
118e			    cp (hl)            ; Compare with low byte of current address 
118e			    jr nz, malloc_search_loop  ; If not equal, continue searching 
118e			    ld a, d            ; Load high byte of heap end address 
118e			;    cp 0               ; Check if it's zero (end of memory) 
118e				or a 
118e			    jr nz, malloc_search_loop  ; If not zero, continue searching 
118e			 
118e			    ; If we reached here, allocation failed 
118e			    xor a              ; Set result to NULL 
118e			if DEBUG_FORTH_MALLOC_HIGH 
118e						DMARK "ma6" 
118e			call malloc_guard_exit 
118e			call malloc_guard_zerolen 
118e			endif 
118e			    ret 
118e			malloc_exit: 
118e			if DEBUG_FORTH_MALLOC_HIGH 
118e						DMARK "ma7" 
118e			call malloc_guard_exit 
118e			call malloc_guard_zerolen 
118e			endif 
118e			    ret 
118e			 
118e			; Internal Free Function: 
118e			; Input: 
118e			;   HL: Pointer to memory block to free 
118e			; Output: 
118e			;   None 
118e			 
118e			free_internal: 
118e			    ld de, (heap_start) ; Load start of heap into DE 
118e			    ld bc, 0            ; Initialize counter 
118e			 
118e			free_search_loop: 
118e			    ; Check if current block contains the pointer 
118e			    ld a, l             ; Load low byte of pointer 
118e			    cp (hl+1)           ; Compare with high byte of current block's address 
118e			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
118e			    ld a, h             ; Load high byte of pointer 
118e			    cp (hl+2)           ; Compare with low byte of current block's address 
118e			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
118e			 
118e			    ; Mark block as free 
118e			    ld (hl), 0          ; Set status byte to indicate free block 
118e			    ret                 ; Return 
118e			 
118e			free_skip_block_check: 
118e			    ; Move to the next block 
118e			    ld bc, 3            ; Size of management overhead 
118e			    add hl, bc          ; Move to the next block 
118e			    inc de              ; Increment counter 
118e			 
118e			    ; Check if we have reached the end of heap 
118e			    ld a, e             ; Load low byte of heap end address 
118e			    cp (hl)             ; Compare with low byte of current address 
118e			    jr nz, free_search_loop  ; If not equal, continue searching 
118e			    ld a, d             ; Load high byte of heap end address 
118e			;    cp 0                ; Check if it's zero (end of memory) 
118e				or a 
118e			    jr nz, free_search_loop  ; If not zero, continue searching 
118e			 
118e			    ; If we reached here, pointer is not found in heap 
118e			    ret 
118e			 
118e			free_exit: 
118e			    ret                 ; Return 
118e			 
118e			; Define heap start and end addresses 
118e			;heap_start:    .dw 0xC000   ; Start of heap 
118e			;heap_end:      .dw 0xE000   ; End of heap 
118e			 
118e			endif 
118e			 
118e			 
118e			if MALLOC_1 
118e			 
118e			 
118e			 
118e			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
118e			 
118e			;moved to firmware.asm 
118e			;heap_start        .equ  0x9000      ; Starting address of heap 
118e			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
118e			 
118e			;      .org 0 
118e			;      jp    main 
118e			 
118e			 
118e			;      .org  0x100 
118e			;main: 
118e			;      ld    HL, 0x8100 
118e			;      ld    SP, HL 
118e			; 
118e			;      call  heap_init 
118e			; 
118e			;      ; Make some allocations 
118e			;      ld    HL, 12 
118e			;      call  malloc            ; Allocates 0x9004 
118e			; 
118e			;      ld    HL, 12 
118e			;      call  malloc            ; Allocates 0x9014 
118e			; 
118e			;      ld    HL, 12 
118e			;      call  malloc            ; Allocates 0x9024 
118e			; 
118e			;      ; Free some allocations 
118e			;      ld    HL, 0x9014 
118e			;      call  free 
118e			; 
118e			;      ld    HL, 0x9004 
118e			;      call  free 
118e			; 
118e			;      ld    HL, 0x9024 
118e			;      call  free 
118e			; 
118e			; 
118e			;      halt 
118e			 
118e			 
118e			;------------------------------------------------------------------------------ 
118e			;     heap_init                                                               : 
118e			;                                                                             : 
118e			; Description                                                                 : 
118e			;     Initialise the heap and make it ready for malloc and free operations.   : 
118e			;                                                                             : 
118e			;     The heap is maintained as a linked list, starting with an initial       : 
118e			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
118e			;     the first free block in the heap. Each block then points to the next    : 
118e			;     free block within the heap, and the free list ends at the first block   : 
118e			;     with a null pointer to the next free block.                             : 
118e			;                                                                             : 
118e			; Parameters                                                                  : 
118e			;     Inputs are compile-time only. Two defines which specify the starting    : 
118e			;     address of the heap and its size are required, along with a memory      : 
118e			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
118e			;     principally stores a pointer to the first free block in the heap.       : 
118e			;                                                                             : 
118e			; Returns                                                                     : 
118e			;     Nothing                                                                 : 
118e			;------------------------------------------------------------------------------ 
118e			heap_init: 
118e e5			      push  HL 
118f			 
118f			      ; Initialise free list struct 
118f 21 ae 67		      ld    HL, heap_start 
1192 22 a9 67		      ld    (free_list), HL 
1195 21 00 00		      ld    HL, 0 
1198 22 ab 67		      ld    (free_list+2), HL 
119b			 
119b			      ; Insert first free block at bottom of heap, consumes entire heap 
119b 21 8b e2		      ld    HL, heap_start+heap_size-4 
119e 22 ae 67		      ld    (heap_start), HL        ; Next block (end of free list) 
11a1 21 dd 7a		      ld    HL, heap_size-4 
11a4 22 b0 67		      ld    (heap_start+2), HL      ; Block size 
11a7			 
11a7			      ; Insert end of free list block at top of heap - two null words will 
11a7			      ; terminate the free list 
11a7 21 00 00		      ld    HL, 0 
11aa 22 8d e2		      ld    (heap_start+heap_size-2), HL 
11ad 22 8b e2		      ld    (heap_start+heap_size-4), HL 
11b0			 
11b0 e1			      pop   HL 
11b1			 
11b1 c9			      ret 
11b2			 
11b2			 
11b2			;------------------------------------------------------------------------------ 
11b2			;     malloc                                                                  : 
11b2			;                                                                             : 
11b2			; Description                                                                 : 
11b2			;     Allocates the wanted space from the heap and returns the address of the : 
11b2			;     first useable byte of the allocation.                                   : 
11b2			;                                                                             : 
11b2			;     Allocations can happen in one of two ways:                              : 
11b2			;                                                                             : 
11b2			;     1. A free block may be found which is the exact size wanted. In this    : 
11b2			;        case the block is removed from the free list and retuedn to the      : 
11b2			;        caller.                                                              : 
11b2			;     2. A free block may be found which is larger than the size wanted. In   : 
11b2			;        this case, the larger block is split into two. The first portion of  : 
11b2			;        this block will become the requested space by the malloc call and    : 
11b2			;        is returned to the caller. The second portion becomes a new free     : 
11b2			;        block, and the free list is adjusted to maintain continuity via this : 
11b2			;        newly created block.                                                 : 
11b2			;                                                                             : 
11b2			;     malloc does not set any initial value in the allocated space, the       : 
11b2			;     caller is required to do this as required.                              : 
11b2			;                                                                             : 
11b2			;     This implementation of malloc uses the stack exclusively, and is        : 
11b2			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
11b2			;     advisable to disable interrupts before calling malloc, and recommended  : 
11b2			;     to avoid the use of malloc inside ISRs in general.                      : 
11b2			;                                                                             : 
11b2			;     NOTE: heap_init must be called before malloc and free can be used.      : 
11b2			;                                                                             : 
11b2			; Parameters                                                                  : 
11b2			;     HL  Number of bytes wanted                                              : 
11b2			;                                                                             : 
11b2			; Returns                                                                     : 
11b2			;     HL  Address of the first useable byte of the allocation                 : 
11b2			;                                                                             : 
11b2			; Flags                                                                       : 
11b2			;     Z   Set if the allocation did not succeed, clear otherwise              : 
11b2			;                                                                             : 
11b2			; Stack frame                                                                 : 
11b2			;       |             |                                                       : 
11b2			;       +-------------+                                                       : 
11b2			;       |     BC      |                                                       : 
11b2			;       +-------------+                                                       : 
11b2			;       |     DE      |                                                       : 
11b2			;       +-------------+                                                       : 
11b2			;       |     IX      |                                                       : 
11b2			;       +-------------+                                                       : 
11b2			;       |  prev_free  |                                                       : 
11b2			;   +4  +-------------+                                                       : 
11b2			;       |  this_free  |                                                       : 
11b2			;   +2  +-------------+                                                       : 
11b2			;       |  next_free  |                                                       : 
11b2			;   +0  +-------------+                                                       : 
11b2			;       |             |                                                       : 
11b2			;                                                                             : 
11b2			;------------------------------------------------------------------------------ 
11b2			 
11b2			 
11b2			;malloc: 
11b2			; 
11b2			;	SAVESP ON 1 
11b2			; 
11b2			;	call malloc_code 
11b2			; 
11b2			;	CHECKSP ON 1 
11b2			;	ret 
11b2			 
11b2			 
11b2			malloc: 
11b2 c5			      push  BC 
11b3 d5			      push  DE 
11b4 dd e5		      push  IX 
11b6			if DEBUG_FORTH_MALLOC_HIGH 
11b6			call malloc_guard_entry 
11b6			endif 
11b6			 
11b6					if DEBUG_FORTH_MALLOC 
11b6						DMARK "mal" 
11b6						CALLMONITOR 
11b6					endif 
11b6 7c			      ld    A, H                    ; Exit if no space requested 
11b7 b5			      or    L 
11b8 ca 77 12		      jp    Z, malloc_early_exit 
11bb			 
11bb			;inc hl 
11bb			;inc hl 
11bb			;inc hl 
11bb			; 
11bb			;inc hl 
11bb			;inc hl 
11bb			;inc hl 
11bb			;inc hl 
11bb			;inc hl 
11bb			;inc hl 
11bb			;inc hl 
11bb			;inc hl 
11bb			;inc hl 
11bb			 
11bb			 
11bb			 
11bb			 
11bb					if DEBUG_FORTH_MALLOC 
11bb						DMARK "maA" 
11bb						CALLMONITOR 
11bb					endif 
11bb			      ; Set up stack frame 
11bb eb			      ex    DE, HL 
11bc 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
11bf 39			      add   HL, SP 
11c0 f9			      ld    SP, HL 
11c1 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
11c5 dd 39		      add   IX, SP 
11c7			 
11c7			      ; Setup initial state 
11c7 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
11ca 19			      add   HL, DE 
11cb			 
11cb 44			      ld    B, H                    ; Move want to BC 
11cc 4d			      ld    C, L 
11cd			 
11cd 21 a9 67		      ld    HL, free_list           ; Store prev_free ptr to stack 
11d0 dd 75 04		      ld    (IX+4), L 
11d3 dd 74 05		      ld    (IX+5), H 
11d6			 
11d6 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
11d7 23			      inc   HL 
11d8 56			      ld    D, (HL) 
11d9 dd 73 02		      ld    (IX+2), E 
11dc dd 72 03		      ld    (IX+3), D 
11df eb			      ex    DE, HL                  ; this_free ptr into HL 
11e0			 
11e0					if DEBUG_FORTH_MALLOC 
11e0						DMARK "maB" 
11e0						CALLMONITOR 
11e0					endif 
11e0			      ; Loop through free block list to find some space 
11e0			malloc_find_space: 
11e0 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
11e1 23			      inc   HL 
11e2 56			      ld    D, (HL) 
11e3			 
11e3 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
11e4 b3			      or    E 
11e5 ca 71 12		      jp    Z, malloc_no_space 
11e8			 
11e8 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
11eb dd 72 01		      ld    (IX+1), D 
11ee			 
11ee			      ; Does this block have enough space to make the allocation? 
11ee 23			      inc   HL                      ; Load free block size into DE 
11ef 5e			      ld    E, (HL) 
11f0 23			      inc   HL 
11f1 56			      ld    D, (HL) 
11f2			 
11f2 eb			      ex    DE, HL                  ; Check size of block against want 
11f3 b7			      or    A                       ; Ensure carry flag clear 
11f4 ed 42		      sbc   HL, BC 
11f6 e5			      push  HL                      ; Store the result for later (new block size) 
11f7			 
11f7 ca 46 12		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
11fa 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
11fc			 
11fc			      ; this_free block is not big enough, setup ptrs to test next free block 
11fc e1			      pop   HL                      ; Discard previous result 
11fd			 
11fd dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1200 dd 66 03		      ld    H, (IX+3) 
1203 dd 75 04		      ld    (IX+4), L 
1206 dd 74 05		      ld    (IX+5), H 
1209			 
1209 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
120c dd 66 01		      ld    H, (IX+1) 
120f dd 75 02		      ld    (IX+2), L 
1212 dd 74 03		      ld    (IX+3), H 
1215			 
1215					if DEBUG_FORTH_MALLOC 
1215						DMARK "MA>" 
1215						CALLMONITOR 
1215					endif 
1215 18 c9		      jr    malloc_find_space 
1217			 
1217			      ; split a bigger block into two - requested size and remaining size 
1217			malloc_alloc_split: 
1217					if DEBUG_FORTH_MALLOC 
1217						DMARK "MAs" 
1217						CALLMONITOR 
1217					endif 
1217 eb			      ex    DE, HL                  ; Calculate address of new free block 
1218 2b			      dec   HL 
1219 2b			      dec   HL 
121a 2b			      dec   HL 
121b 09			      add   HL, BC 
121c			 
121c			      ; Create a new block and point it at next_free 
121c dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
121f dd 56 01		      ld    D, (IX+1) 
1222			 
1222 73			      ld    (HL), E                 ; Store next_free ptr into new block 
1223 23			      inc   HL 
1224 72			      ld    (HL), D 
1225			 
1225 d1			      pop   DE                      ; Store size of new block into new block 
1226 23			      inc   HL 
1227 73			      ld    (HL), E 
1228 23			      inc   HL 
1229 72			      ld    (HL), D 
122a			 
122a			      ; Update this_free ptr to point to new block 
122a 2b			      dec   HL 
122b 2b			      dec   HL 
122c 2b			      dec   HL 
122d			 
122d dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1230 dd 56 03		      ld    D, (IX+3) 
1233			 
1233 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1236 dd 74 03		      ld    (IX+3), H 
1239			 
1239			      ; Modify this_free block to be allocation 
1239 eb			      ex    DE, HL 
123a af			      xor   A                       ; Null the next block ptr of allocated block 
123b 77			      ld    (HL), A 
123c 23			      inc   HL 
123d 77			      ld    (HL), A 
123e			 
123e 23			      inc   HL                      ; Store want size into allocated block 
123f 71			      ld    (HL), C 
1240 23			      inc   HL 
1241 70			      ld    (HL), B 
1242 23			      inc   HL 
1243 e5			      push  HL                      ; Address of allocation to return 
1244			 
1244 18 19		      jr    malloc_update_links 
1246			 
1246			malloc_alloc_fit: 
1246 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1247			 
1247					if DEBUG_FORTH_MALLOC 
1247						DMARK "MAf" 
1247						CALLMONITOR 
1247					endif 
1247			      ; Modify this_free block to be allocation 
1247 eb			      ex    DE, HL 
1248 2b			      dec   HL 
1249 2b			      dec   HL 
124a 2b			      dec   HL 
124b			 
124b af			      xor   A                       ; Null the next block ptr of allocated block 
124c 77			      ld    (HL), A 
124d 23			      inc   HL 
124e 77			      ld    (HL), A 
124f			 
124f 23			      inc   HL                      ; Store address of allocation to return 
1250 23			      inc   HL 
1251 23			      inc   HL 
1252 e5			      push  HL 
1253			 
1253			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1253 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
1256 dd 66 01		      ld    H, (IX+1) 
1259			 
1259 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
125c dd 74 03		      ld    (IX+3), H 
125f			 
125f			 
125f			malloc_update_links: 
125f			      ; Update prev_free ptr to point to this_free 
125f dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1262 dd 66 05		      ld    H, (IX+5) 
1265			 
1265 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1268 dd 56 03		      ld    D, (IX+3) 
126b			 
126b 73			      ld    (HL), E                 ; this_free ptr into prev_free 
126c 23			      inc   HL 
126d 72			      ld    (HL), D 
126e			 
126e					if DEBUG_FORTH_MALLOC 
126e						DMARK "Mul" 
126e						CALLMONITOR 
126e					endif 
126e			      ; Clear the Z flag to indicate successful allocation 
126e 7a			      ld    A, D 
126f b3			      or    E 
1270			 
1270 d1			      pop   DE                      ; Address of allocation 
1271					if DEBUG_FORTH_MALLOC 
1271						DMARK "MAu" 
1271						CALLMONITOR 
1271					endif 
1271			 
1271			malloc_no_space: 
1271 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
1274 39			      add   HL, SP 
1275 f9			      ld    SP, HL 
1276			 
1276 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1277					if DEBUG_FORTH_MALLOC 
1277						DMARK "MAN" 
1277						CALLMONITOR 
1277					endif 
1277			 
1277			malloc_early_exit: 
1277					if DEBUG_FORTH_MALLOC 
1277						DMARK "MAx" 
1277						CALLMONITOR 
1277					endif 
1277 dd e1		      pop   IX 
1279 d1			      pop   DE 
127a c1			      pop   BC 
127b			 
127b			if DEBUG_FORTH_MALLOC_HIGH 
127b			call malloc_guard_exit 
127b			call malloc_guard_zerolen 
127b			endif 
127b c9			      ret 
127c			 
127c			 
127c			;------------------------------------------------------------------------------ 
127c			;     free                                                                    : 
127c			;                                                                             : 
127c			; Description                                                                 : 
127c			;     Return the space pointed to by HL to the heap. HL must be an address as : 
127c			;     returned by malloc, otherwise the behaviour is undefined.               : 
127c			;                                                                             : 
127c			;     Where possible, directly adjacent free blocks will be merged together   : 
127c			;     into larger blocks to help ensure that the heap does not become         : 
127c			;     excessively fragmented.                                                 : 
127c			;                                                                             : 
127c			;     free does not clear or set any other value into the freed space, and    : 
127c			;     therefore its contents may be visible through subsequent malloc's. The  : 
127c			;     caller should clear the freed space as required.                        : 
127c			;                                                                             : 
127c			;     This implementation of free uses the stack exclusively, and is          : 
127c			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
127c			;     advisable to disable interrupts before calling free, and recommended    : 
127c			;     to avoid the use of free inside ISRs in general.                        : 
127c			;                                                                             : 
127c			;     NOTE: heap_init must be called before malloc and free can be used.      : 
127c			;                                                                             : 
127c			; Parameters                                                                  : 
127c			;     HL  Pointer to address of first byte of allocation to be freed          : 
127c			;                                                                             : 
127c			; Returns                                                                     : 
127c			;     Nothing                                                                 : 
127c			;                                                                             : 
127c			; Stack frame                                                                 : 
127c			;       |             |                                                       : 
127c			;       +-------------+                                                       : 
127c			;       |     BC      |                                                       : 
127c			;       +-------------+                                                       : 
127c			;       |     DE      |                                                       : 
127c			;       +-------------+                                                       : 
127c			;       |     IX      |                                                       : 
127c			;       +-------------+                                                       : 
127c			;       |  prev_free  |                                                       : 
127c			;   +2  +-------------+                                                       : 
127c			;       |  next_free  |                                                       : 
127c			;   +0  +-------------+                                                       : 
127c			;       |             |                                                       : 
127c			;                                                                             : 
127c			;------------------------------------------------------------------------------ 
127c			free: 
127c c5			      push  BC 
127d d5			      push  DE 
127e dd e5		      push  IX 
1280			 
1280 7c			      ld    A, H                    ; Exit if ptr is null 
1281 b5			      or    L 
1282 ca 46 13		      jp    Z, free_early_exit 
1285			 
1285			      ; Set up stack frame 
1285 eb			      ex    DE, HL 
1286 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1289 39			      add   HL, SP 
128a f9			      ld    SP, HL 
128b dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
128f dd 39		      add   IX, SP 
1291			 
1291			      ; The address in HL points to the start of the useable allocated space, 
1291			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1291			      ; address of the block itself. 
1291 eb			      ex    DE, HL 
1292 11 fc ff		      ld    DE, -4 
1295 19			      add   HL, DE 
1296			 
1296			      ; An allocated block must have a null next block pointer in it 
1296 7e			      ld    A, (HL) 
1297 23			      inc   HL 
1298 b6			      or    (HL) 
1299 c2 41 13		      jp    NZ, free_done 
129c			 
129c 2b			      dec   HL 
129d			 
129d 44			      ld    B, H                    ; Copy HL to BC 
129e 4d			      ld    C, L 
129f			 
129f			      ; Loop through the free list to find the first block with an address 
129f			      ; higher than the block being freed 
129f 21 a9 67		      ld    HL, free_list 
12a2			 
12a2			free_find_higher_block: 
12a2 5e			      ld    E, (HL)                 ; Load next ptr from free block 
12a3 23			      inc   HL 
12a4 56			      ld    D, (HL) 
12a5 2b			      dec   HL 
12a6			 
12a6 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
12a9 dd 72 01		      ld    (IX+1), D 
12ac dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
12af dd 74 03		      ld    (IX+3), H 
12b2			 
12b2 78			      ld    A, B                    ; Check if DE is greater than BC 
12b3 ba			      cp    D                       ; Compare MSB first 
12b4 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
12b6 30 04		      jr    NC, free_find_higher_block_skip 
12b8 79			      ld    A, C 
12b9 bb			      cp    E                       ; Then compare LSB 
12ba 38 08		      jr    C, free_found_higher_block 
12bc			 
12bc			free_find_higher_block_skip: 
12bc 7a			      ld    A, D                    ; Reached the end of the free list? 
12bd b3			      or    E 
12be ca 41 13		      jp    Z, free_done 
12c1			 
12c1 eb			      ex    DE, HL 
12c2			 
12c2 18 de		      jr    free_find_higher_block 
12c4			 
12c4			free_found_higher_block: 
12c4			      ; Insert freed block between prev and next free blocks 
12c4 71			      ld    (HL), C                 ; Point prev free block to freed block 
12c5 23			      inc   HL 
12c6 70			      ld    (HL), B 
12c7			 
12c7 60			      ld    H, B                    ; Point freed block at next free block 
12c8 69			      ld    L, C 
12c9 73			      ld    (HL), E 
12ca 23			      inc   HL 
12cb 72			      ld    (HL), D 
12cc			 
12cc			      ; Check if the freed block is adjacent to the next free block 
12cc 23			      inc   HL                      ; Load size of freed block into HL 
12cd 5e			      ld    E, (HL) 
12ce 23			      inc   HL 
12cf 56			      ld    D, (HL) 
12d0 eb			      ex    DE, HL 
12d1			 
12d1 09			      add   HL, BC                  ; Add addr of freed block and its size 
12d2			 
12d2 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
12d5 dd 56 01		      ld    D, (IX+1) 
12d8			 
12d8 b7			      or    A                       ; Clear the carry flag 
12d9 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
12db 20 22		      jr    NZ, free_check_adjacent_to_prev 
12dd			 
12dd			      ; Freed block is adjacent to next, merge into one bigger block 
12dd eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
12de 5e			      ld    E, (HL) 
12df 23			      inc   HL 
12e0 56			      ld    D, (HL) 
12e1 e5			      push  HL                      ; Save ptr to next block for later 
12e2			 
12e2 60			      ld    H, B                    ; Store ptr from next block into freed block 
12e3 69			      ld    L, C 
12e4 73			      ld    (HL), E 
12e5 23			      inc   HL 
12e6 72			      ld    (HL), D 
12e7			 
12e7 e1			      pop   HL                      ; Restore ptr to next block 
12e8 23			      inc   HL                      ; Load size of next block into DE 
12e9 5e			      ld    E, (HL) 
12ea 23			      inc   HL 
12eb 56			      ld    D, (HL) 
12ec d5			      push  DE                      ; Save next block size for later 
12ed			 
12ed 60			      ld    H, B                    ; Load size of freed block into HL 
12ee 69			      ld    L, C 
12ef 23			      inc   HL 
12f0 23			      inc   HL 
12f1 5e			      ld    E, (HL) 
12f2 23			      inc   HL 
12f3 56			      ld    D, (HL) 
12f4 eb			      ex    DE, HL 
12f5			 
12f5 d1			      pop   DE                      ; Restore size of next block 
12f6 19			      add   HL, DE                  ; Add sizes of both blocks 
12f7 eb			      ex    DE, HL 
12f8			 
12f8 60			      ld    H, B                    ; Store new bigger size into freed block 
12f9 69			      ld    L, C 
12fa 23			      inc   HL 
12fb 23			      inc   HL 
12fc 73			      ld    (HL), E 
12fd 23			      inc   HL 
12fe 72			      ld    (HL), D 
12ff			 
12ff			free_check_adjacent_to_prev: 
12ff			      ; Check if the freed block is adjacent to the prev free block 
12ff dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
1302 dd 66 03		      ld    H, (IX+3) 
1305			 
1305 23			      inc   HL                      ; Size of prev free block into DE 
1306 23			      inc   HL 
1307 5e			      ld    E, (HL) 
1308 23			      inc   HL 
1309 56			      ld    D, (HL) 
130a 2b			      dec   HL 
130b 2b			      dec   HL 
130c 2b			      dec   HL 
130d			 
130d 19			      add   HL, DE                  ; Add prev block addr and size 
130e			 
130e b7			      or    A                       ; Clear the carry flag 
130f ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1311 20 2e		      jr    NZ, free_done 
1313			 
1313			      ; Freed block is adjacent to prev, merge into one bigger block 
1313 60			      ld    H, B                    ; Load next ptr from freed block into DE 
1314 69			      ld    L, C 
1315 5e			      ld    E, (HL) 
1316 23			      inc   HL 
1317 56			      ld    D, (HL) 
1318 e5			      push  HL                      ; Save freed block ptr for later 
1319			 
1319 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
131c dd 66 03		      ld    H, (IX+3) 
131f 73			      ld    (HL), E 
1320 23			      inc   HL 
1321 72			      ld    (HL), D 
1322			 
1322 e1			      pop   HL                      ; Restore freed block ptr 
1323 23			      inc   HL                      ; Load size of freed block into DE 
1324 5e			      ld    E, (HL) 
1325 23			      inc   HL 
1326 56			      ld    D, (HL) 
1327 d5			      push  DE                      ; Save freed block size for later 
1328			 
1328 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
132b dd 66 03		      ld    H, (IX+3) 
132e 23			      inc   HL 
132f 23			      inc   HL 
1330 5e			      ld    E, (HL) 
1331 23			      inc   HL 
1332 56			      ld    D, (HL) 
1333			 
1333 e1			      pop   HL                      ; Add sizes of both blocks 
1334 19			      add   HL, DE 
1335 eb			      ex    DE, HL 
1336			 
1336 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1339 dd 66 03		      ld    H, (IX+3) 
133c 23			      inc   HL 
133d 23			      inc   HL 
133e 73			      ld    (HL), E 
133f 23			      inc   HL 
1340 72			      ld    (HL), D 
1341			 
1341			free_done: 
1341 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
1344 39			      add   HL, SP 
1345 f9			      ld    SP, HL 
1346			 
1346			free_early_exit: 
1346 dd e1		      pop   IX 
1348 d1			      pop   DE 
1349 c1			      pop   BC 
134a			 
134a c9			      ret 
134b			 
134b			; moved to firmware.asm 
134b			; 
134b			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
134b			;                  .dw   0 
134b			 
134b			 
134b			endif 
134b			 
134b			 
134b			if MALLOC_3 
134b			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
134b			;heap_start        .equ  0x9000      ; Starting address of heap 
134b			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
134b			; 
134b			 ;     .org 0 
134b			  ;    jp    main 
134b			; 
134b			; 
134b			 ;     .org  0x100 
134b			;main: 
134b			 ;     ld    HL, 0x8100 
134b			  ;    ld    SP, HL 
134b			; 
134b			;      call  heap_init 
134b			 
134b			      ; Make some allocations 
134b			;      ld    HL, 12 
134b			;      call  malloc            ; Allocates 0x9004 
134b			; 
134b			 ;     ld    HL, 12 
134b			;      call  malloc            ; Allocates 0x9014 
134b			 
134b			;      ld    HL, 12 
134b			;      call  malloc            ; Allocates 0x9024 
134b			 
134b			      ; Free some allocations 
134b			;      ld    HL, 0x9014 
134b			;      call  free 
134b			 
134b			;      ld    HL, 0x9004 
134b			;      call  free 
134b			; 
134b			;      ld    HL, 0x9024 
134b			;      call  free 
134b			 
134b			 
134b			 ;     halt 
134b			 
134b			 
134b			;------------------------------------------------------------------------------ 
134b			;     heap_init                                                               : 
134b			;                                                                             : 
134b			; Description                                                                 : 
134b			;     Initialise the heap and make it ready for malloc and free operations.   : 
134b			;                                                                             : 
134b			;     The heap is maintained as a linked list, starting with an initial       : 
134b			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
134b			;     the first free block in the heap. Each block then points to the next    : 
134b			;     free block within the heap, and the free list ends at the first block   : 
134b			;     with a null pointer to the next free block.                             : 
134b			;                                                                             : 
134b			; Parameters                                                                  : 
134b			;     Inputs are compile-time only. Two defines which specify the starting    : 
134b			;     address of the heap and its size are required, along with a memory      : 
134b			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
134b			;     principally stores a pointer to the first free block in the heap.       : 
134b			;                                                                             : 
134b			; Returns                                                                     : 
134b			;     Nothing                                                                 : 
134b			;------------------------------------------------------------------------------ 
134b			heap_init: 
134b			      push  HL 
134b			 
134b			      ; Initialise free list struct 
134b			      ld    HL, heap_start 
134b			      ld    (free_list), HL 
134b			      ld    HL, 0 
134b			      ld    (free_list+2), HL 
134b			 
134b			      ; Insert first free block at bottom of heap, consumes entire heap 
134b			      ld    HL, heap_start+heap_size-4 
134b			      ld    (heap_start), HL        ; Next block (end of free list) 
134b			      ld    HL, heap_size-4 
134b			      ld    (heap_start+2), HL      ; Block size 
134b			 
134b			      ; Insert end of free list block at top of heap - two null words will 
134b			      ; terminate the free list 
134b			      ld    HL, 0 
134b			      ld    (heap_start+heap_size-2), HL 
134b			      ld    (heap_start+heap_size-4), HL 
134b			 
134b			      pop   HL 
134b			 
134b			      ret 
134b			 
134b			 
134b			;------------------------------------------------------------------------------ 
134b			;     malloc                                                                  : 
134b			;                                                                             : 
134b			; Description                                                                 : 
134b			;     Allocates the wanted space from the heap and returns the address of the : 
134b			;     first useable byte of the allocation.                                   : 
134b			;                                                                             : 
134b			;     Allocations can happen in one of two ways:                              : 
134b			;                                                                             : 
134b			;     1. A free block may be found which is the exact size wanted. In this    : 
134b			;        case the block is removed from the free list and retuedn to the      : 
134b			;        caller.                                                              : 
134b			;     2. A free block may be found which is larger than the size wanted. In   : 
134b			;        this case, the larger block is split into two. The first portion of  : 
134b			;        this block will become the requested space by the malloc call and    : 
134b			;        is returned to the caller. The second portion becomes a new free     : 
134b			;        block, and the free list is adjusted to maintain continuity via this : 
134b			;        newly created block.                                                 : 
134b			;                                                                             : 
134b			;     malloc does not set any initial value in the allocated space, the       : 
134b			;     caller is required to do this as required.                              : 
134b			;                                                                             : 
134b			;     This implementation of malloc uses the stack exclusively, and is        : 
134b			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
134b			;     advisable to disable interrupts before calling malloc, and recommended  : 
134b			;     to avoid the use of malloc inside ISRs in general.                      : 
134b			;                                                                             : 
134b			;     NOTE: heap_init must be called before malloc and free can be used.      : 
134b			;                                                                             : 
134b			; Parameters                                                                  : 
134b			;     HL  Number of bytes wanted                                              : 
134b			;                                                                             : 
134b			; Returns                                                                     : 
134b			;     HL  Address of the first useable byte of the allocation                 : 
134b			;                                                                             : 
134b			; Flags                                                                       : 
134b			;     Z   Set if the allocation did not succeed, clear otherwise              : 
134b			;                                                                             : 
134b			; Stack frame                                                                 : 
134b			;       |             |                                                       : 
134b			;       +-------------+                                                       : 
134b			;       |     BC      |                                                       : 
134b			;       +-------------+                                                       : 
134b			;       |     DE      |                                                       : 
134b			;       +-------------+                                                       : 
134b			;       |     IX      |                                                       : 
134b			;       +-------------+                                                       : 
134b			;       |  prev_free  |                                                       : 
134b			;   +4  +-------------+                                                       : 
134b			;       |  this_free  |                                                       : 
134b			;   +2  +-------------+                                                       : 
134b			;       |  next_free  |                                                       : 
134b			;   +0  +-------------+                                                       : 
134b			;       |             |                                                       : 
134b			;                                                                             : 
134b			;------------------------------------------------------------------------------ 
134b			malloc: 
134b			      push  BC 
134b			      push  DE 
134b			      push  IX 
134b			 
134b			      ld    A, H                    ; Exit if no space requested 
134b			      or    L 
134b			      jp    Z, malloc_early_exit 
134b			 
134b			      ; Set up stack frame 
134b			      ex    DE, HL 
134b			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
134b			      add   HL, SP 
134b			      ld    SP, HL 
134b			      ld    IX, 0                   ; Use IX as a frame pointer 
134b			      add   IX, SP 
134b			 
134b			      ; Setup initial state 
134b			      ld    HL, 4                   ; want must also include space used by block struct 
134b			      add   HL, DE 
134b			 
134b			      ld    B, H                    ; Move want to BC 
134b			      ld    C, L 
134b			 
134b			      ld    HL, free_list           ; Store prev_free ptr to stack 
134b			      ld    (IX+4), L 
134b			      ld    (IX+5), H 
134b			 
134b			      ld    E, (HL)                 ; Store this_free ptr to stack 
134b			      inc   HL 
134b			      ld    D, (HL) 
134b			      ld    (IX+2), E 
134b			      ld    (IX+3), D 
134b			      ex    DE, HL                  ; this_free ptr into HL 
134b			 
134b			      ; Loop through free block list to find some space 
134b			malloc_find_space: 
134b			      ld    E, (HL)                 ; Load next_free ptr into DE 
134b			      inc   HL 
134b			      ld    D, (HL) 
134b			 
134b			      ld    A, D                    ; Check for null next_free ptr - end of free list 
134b			      or    E 
134b			      jp    Z, malloc_no_space 
134b			 
134b			      ld    (IX+0), E               ; Store next_free ptr to stack 
134b			      ld    (IX+1), D 
134b			 
134b			      ; Does this block have enough space to make the allocation? 
134b			      inc   HL                      ; Load free block size into DE 
134b			      ld    E, (HL) 
134b			      inc   HL 
134b			      ld    D, (HL) 
134b			 
134b			      ex    DE, HL                  ; Check size of block against want 
134b			      or    A                       ; Ensure carry flag clear 
134b			      sbc   HL, BC 
134b			      push  HL                      ; Store the result for later (new block size) 
134b			 
134b			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
134b			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
134b			 
134b			      ; this_free block is not big enough, setup ptrs to test next free block 
134b			      pop   HL                      ; Discard previous result 
134b			 
134b			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
134b			      ld    H, (IX+3) 
134b			      ld    (IX+4), L 
134b			      ld    (IX+5), H 
134b			 
134b			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
134b			      ld    H, (IX+1) 
134b			      ld    (IX+2), L 
134b			      ld    (IX+3), H 
134b			 
134b			      jr    malloc_find_space 
134b			 
134b			      ; split a bigger block into two - requested size and remaining size 
134b			malloc_alloc_split: 
134b			      ex    DE, HL                  ; Calculate address of new free block 
134b			      dec   HL 
134b			      dec   HL 
134b			      dec   HL 
134b			      add   HL, BC 
134b			 
134b			      ; Create a new block and point it at next_free 
134b			      ld    E, (IX+0)               ; Load next_free ptr into DE 
134b			      ld    D, (IX+1) 
134b			 
134b			      ld    (HL), E                 ; Store next_free ptr into new block 
134b			      inc   HL 
134b			      ld    (HL), D 
134b			 
134b			      pop   DE                      ; Store size of new block into new block 
134b			      inc   HL 
134b			      ld    (HL), E 
134b			      inc   HL 
134b			      ld    (HL), D 
134b			 
134b			      ; Update this_free ptr to point to new block 
134b			      dec   HL 
134b			      dec   HL 
134b			      dec   HL 
134b			 
134b			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
134b			      ld    D, (IX+3) 
134b			 
134b			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
134b			      ld    (IX+3), H 
134b			 
134b			      ; Modify this_free block to be allocation 
134b			      ex    DE, HL 
134b			      xor   A                       ; Null the next block ptr of allocated block 
134b			      ld    (HL), A 
134b			      inc   HL 
134b			      ld    (HL), A 
134b			 
134b			      inc   HL                      ; Store want size into allocated block 
134b			      ld    (HL), C 
134b			      inc   HL 
134b			      ld    (HL), B 
134b			      inc   HL 
134b			      push  HL                      ; Address of allocation to return 
134b			 
134b			      jr    malloc_update_links 
134b			 
134b			malloc_alloc_fit: 
134b			      pop   HL                      ; Dont need new block size, want is exact fit 
134b			 
134b			      ; Modify this_free block to be allocation 
134b			      ex    DE, HL 
134b			      dec   HL 
134b			      dec   HL 
134b			      dec   HL 
134b			 
134b			      xor   A                       ; Null the next block ptr of allocated block 
134b			      ld    (HL), A 
134b			      inc   HL 
134b			      ld    (HL), A 
134b			 
134b			      inc   HL                      ; Store address of allocation to return 
134b			      inc   HL 
134b			      inc   HL 
134b			      push  HL 
134b			 
134b			      ; Copy next_free ptr to this_free, remove allocated block from free list 
134b			      ld    L, (IX+0)               ; next_free to HL 
134b			      ld    H, (IX+1) 
134b			 
134b			      ld    (IX+2), L               ; HL to this_free 
134b			      ld    (IX+3), H 
134b			 
134b			 
134b			malloc_update_links: 
134b			      ; Update prev_free ptr to point to this_free 
134b			      ld    L, (IX+4)               ; prev_free ptr to HL 
134b			      ld    H, (IX+5) 
134b			 
134b			      ld    E, (IX+2)               ; this_free ptr to DE 
134b			      ld    D, (IX+3) 
134b			 
134b			      ld    (HL), E                 ; this_free ptr into prev_free 
134b			      inc   HL 
134b			      ld    (HL), D 
134b			 
134b			      ; Clear the Z flag to indicate successful allocation 
134b			      ld    A, D 
134b			      or    E 
134b			 
134b			      pop   DE                      ; Address of allocation 
134b			 
134b			malloc_no_space: 
134b			      ld    HL, 6                   ; Clean up stack frame 
134b			      add   HL, SP 
134b			      ld    SP, HL 
134b			 
134b			      ex    DE, HL                  ; Alloc addr into HL for return 
134b			 
134b			malloc_early_exit: 
134b			      pop   IX 
134b			      pop   DE 
134b			      pop   BC 
134b			 
134b			      ret 
134b			 
134b			 
134b			;------------------------------------------------------------------------------ 
134b			;     free                                                                    : 
134b			;                                                                             : 
134b			; Description                                                                 : 
134b			;     Return the space pointed to by HL to the heap. HL must be an address as : 
134b			;     returned by malloc, otherwise the behaviour is undefined.               : 
134b			;                                                                             : 
134b			;     Where possible, directly adjacent free blocks will be merged together   : 
134b			;     into larger blocks to help ensure that the heap does not become         : 
134b			;     excessively fragmented.                                                 : 
134b			;                                                                             : 
134b			;     free does not clear or set any other value into the freed space, and    : 
134b			;     therefore its contents may be visible through subsequent malloc's. The  : 
134b			;     caller should clear the freed space as required.                        : 
134b			;                                                                             : 
134b			;     This implementation of free uses the stack exclusively, and is          : 
134b			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
134b			;     advisable to disable interrupts before calling free, and recommended    : 
134b			;     to avoid the use of free inside ISRs in general.                        : 
134b			;                                                                             : 
134b			;     NOTE: heap_init must be called before malloc and free can be used.      : 
134b			;                                                                             : 
134b			; Parameters                                                                  : 
134b			;     HL  Pointer to address of first byte of allocation to be freed          : 
134b			;                                                                             : 
134b			; Returns                                                                     : 
134b			;     Nothing                                                                 : 
134b			;                                                                             : 
134b			; Stack frame                                                                 : 
134b			;       |             |                                                       : 
134b			;       +-------------+                                                       : 
134b			;       |     BC      |                                                       : 
134b			;       +-------------+                                                       : 
134b			;       |     DE      |                                                       : 
134b			;       +-------------+                                                       : 
134b			;       |     IX      |                                                       : 
134b			;       +-------------+                                                       : 
134b			;       |  prev_free  |                                                       : 
134b			;   +2  +-------------+                                                       : 
134b			;       |  next_free  |                                                       : 
134b			;   +0  +-------------+                                                       : 
134b			;       |             |                                                       : 
134b			;                                                                             : 
134b			;------------------------------------------------------------------------------ 
134b			free: 
134b			      push  BC 
134b			      push  DE 
134b			      push  IX 
134b			 
134b			      ld    A, H                    ; Exit if ptr is null 
134b			      or    L 
134b			      jp    Z, free_early_exit 
134b			 
134b			      ; Set up stack frame 
134b			      ex    DE, HL 
134b			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
134b			      add   HL, SP 
134b			      ld    SP, HL 
134b			      ld    IX, 0                   ; Use IX as a frame pointer 
134b			      add   IX, SP 
134b			 
134b			      ; The address in HL points to the start of the useable allocated space, 
134b			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
134b			      ; address of the block itself. 
134b			      ex    DE, HL 
134b			      ld    DE, -4 
134b			      add   HL, DE 
134b			 
134b			      ; An allocated block must have a null next block pointer in it 
134b			      ld    A, (HL) 
134b			      inc   HL 
134b			      or    (HL) 
134b			      jp    NZ, free_done 
134b			 
134b			      dec   HL 
134b			 
134b			      ld    B, H                    ; Copy HL to BC 
134b			      ld    C, L 
134b			 
134b			      ; Loop through the free list to find the first block with an address 
134b			      ; higher than the block being freed 
134b			      ld    HL, free_list 
134b			 
134b			free_find_higher_block: 
134b			      ld    E, (HL)                 ; Load next ptr from free block 
134b			      inc   HL 
134b			      ld    D, (HL) 
134b			      dec   HL 
134b			 
134b			      ld    (IX+0), E               ; Save ptr to next free block 
134b			      ld    (IX+1), D 
134b			      ld    (IX+2), L               ; Save ptr to prev free block 
134b			      ld    (IX+3), H 
134b			 
134b			      ld    A, B                    ; Check if DE is greater than BC 
134b			      cp    D                       ; Compare MSB first 
134b			      jr    Z, $+4                  ; MSB the same, compare LSB 
134b			      jr    NC, free_find_higher_block_skip 
134b			      ld    A, C 
134b			      cp    E                       ; Then compare LSB 
134b			      jr    C, free_found_higher_block 
134b			 
134b			free_find_higher_block_skip: 
134b			      ld    A, D                    ; Reached the end of the free list? 
134b			      or    E 
134b			      jp    Z, free_done 
134b			 
134b			      ex    DE, HL 
134b			 
134b			      jr    free_find_higher_block 
134b			 
134b			free_found_higher_block: 
134b			      ; Insert freed block between prev and next free blocks 
134b			      ld    (HL), C                 ; Point prev free block to freed block 
134b			      inc   HL 
134b			      ld    (HL), B 
134b			 
134b			      ld    H, B                    ; Point freed block at next free block 
134b			      ld    L, C 
134b			      ld    (HL), E 
134b			      inc   HL 
134b			      ld    (HL), D 
134b			 
134b			      ; Check if the freed block is adjacent to the next free block 
134b			      inc   HL                      ; Load size of freed block into HL 
134b			      ld    E, (HL) 
134b			      inc   HL 
134b			      ld    D, (HL) 
134b			      ex    DE, HL 
134b			 
134b			      add   HL, BC                  ; Add addr of freed block and its size 
134b			 
134b			      ld    E, (IX+0)               ; Load addr of next free block into DE 
134b			      ld    D, (IX+1) 
134b			 
134b			      or    A                       ; Clear the carry flag 
134b			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
134b			      jr    NZ, free_check_adjacent_to_prev 
134b			 
134b			      ; Freed block is adjacent to next, merge into one bigger block 
134b			      ex    DE, HL                  ; Load next ptr from next block into DE 
134b			      ld    E, (HL) 
134b			      inc   HL 
134b			      ld    D, (HL) 
134b			      push  HL                      ; Save ptr to next block for later 
134b			 
134b			      ld    H, B                    ; Store ptr from next block into freed block 
134b			      ld    L, C 
134b			      ld    (HL), E 
134b			      inc   HL 
134b			      ld    (HL), D 
134b			 
134b			      pop   HL                      ; Restore ptr to next block 
134b			      inc   HL                      ; Load size of next block into DE 
134b			      ld    E, (HL) 
134b			      inc   HL 
134b			      ld    D, (HL) 
134b			      push  DE                      ; Save next block size for later 
134b			 
134b			      ld    H, B                    ; Load size of freed block into HL 
134b			      ld    L, C 
134b			      inc   HL 
134b			      inc   HL 
134b			      ld    E, (HL) 
134b			      inc   HL 
134b			      ld    D, (HL) 
134b			      ex    DE, HL 
134b			 
134b			      pop   DE                      ; Restore size of next block 
134b			      add   HL, DE                  ; Add sizes of both blocks 
134b			      ex    DE, HL 
134b			 
134b			      ld    H, B                    ; Store new bigger size into freed block 
134b			      ld    L, C 
134b			      inc   HL 
134b			      inc   HL 
134b			      ld    (HL), E 
134b			      inc   HL 
134b			      ld    (HL), D 
134b			 
134b			free_check_adjacent_to_prev: 
134b			      ; Check if the freed block is adjacent to the prev free block 
134b			      ld    L, (IX+2)               ; Prev free block ptr into HL 
134b			      ld    H, (IX+3) 
134b			 
134b			      inc   HL                      ; Size of prev free block into DE 
134b			      inc   HL 
134b			      ld    E, (HL) 
134b			      inc   HL 
134b			      ld    D, (HL) 
134b			      dec   HL 
134b			      dec   HL 
134b			      dec   HL 
134b			 
134b			      add   HL, DE                  ; Add prev block addr and size 
134b			 
134b			      or    A                       ; Clear the carry flag 
134b			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
134b			      jr    NZ, free_done 
134b			 
134b			      ; Freed block is adjacent to prev, merge into one bigger block 
134b			      ld    H, B                    ; Load next ptr from freed block into DE 
134b			      ld    L, C 
134b			      ld    E, (HL) 
134b			      inc   HL 
134b			      ld    D, (HL) 
134b			      push  HL                      ; Save freed block ptr for later 
134b			 
134b			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
134b			      ld    H, (IX+3) 
134b			      ld    (HL), E 
134b			      inc   HL 
134b			      ld    (HL), D 
134b			 
134b			      pop   HL                      ; Restore freed block ptr 
134b			      inc   HL                      ; Load size of freed block into DE 
134b			      ld    E, (HL) 
134b			      inc   HL 
134b			      ld    D, (HL) 
134b			      push  DE                      ; Save freed block size for later 
134b			 
134b			      ld    L, (IX+2)               ; Load size of prev block into DE 
134b			      ld    H, (IX+3) 
134b			      inc   HL 
134b			      inc   HL 
134b			      ld    E, (HL) 
134b			      inc   HL 
134b			      ld    D, (HL) 
134b			 
134b			      pop   HL                      ; Add sizes of both blocks 
134b			      add   HL, DE 
134b			      ex    DE, HL 
134b			 
134b			      ld    L, (IX+2)               ; Store new bigger size into prev block 
134b			      ld    H, (IX+3) 
134b			      inc   HL 
134b			      inc   HL 
134b			      ld    (HL), E 
134b			      inc   HL 
134b			      ld    (HL), D 
134b			 
134b			free_done: 
134b			      ld    HL, 4                   ; Clean up stack frame 
134b			      add   HL, SP 
134b			      ld    SP, HL 
134b			 
134b			free_early_exit: 
134b			      pop   IX 
134b			      pop   DE 
134b			      pop   BC 
134b			 
134b			      ret 
134b			 
134b			 
134b			;      .org 0x8000 
134b			; 
134b			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
134b			 ;                 .dw   0 
134b			 
134b			endif 
134b			 
134b			 
134b			if MALLOC_4 
134b			 
134b			; My memory allocation code. Very very simple.... 
134b			; allocate space under 250 chars 
134b			 
134b			heap_init: 
134b				; init start of heap as zero 
134b				;  
134b			 
134b				ld hl, heap_start 
134b			;	ld a, 0 
134b				ld (hl), 0      ; empty block 
134b				inc hl 
134b			;	ld a, 0 
134b				ld (hl), 0      ; length of block 
134b				; write end of list 
134b				inc hl 
134b				ld a,(hl) 
134b				inc hl 
134b				ld a,(hl) 
134b				 
134b			 
134b				; init some malloc vars 
134b			 
134b				ld hl, 0 
134b				ld (free_list), hl       ; store last malloc location 
134b			 
134b				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
134b			;	ld a, 0 
134b				ld (hl), 0 
134b			 
134b			 
134b				ld hl, heap_start 
134b				;  
134b				  
134b				ret 
134b			 
134b			 
134b			;    free block marker 
134b			;    requested size  
134b			;    pointer to next block 
134b			;    .... 
134b			;    next block marker 
134b			 
134b			 
134b			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
134b			; 
134b			 
134b			 
134b			malloc:  
134b				push de 
134b				push bc 
134b				push af 
134b			 
134b				; hl space required 
134b				 
134b				ld c, l    ; hold space   (TODO only a max of 255) 
134b			 
134b			;	inc c     ; TODO BUG need to fix memory leak on push str 
134b			;	inc c 
134b			;	inc c 
134b			;	inc c 
134b			;	inc c 
134b			;	inc c 
134b			;	inc c 
134b			 
134b			 
134b			 
134b				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
134b			 
134b				ld a, (free_list+3) 
134b			;	cp 0 
134b				or a 
134b				jr z, .contheap 
134b			 
134b				ld hl, (free_list)     ; get last alloc 
134b					if DEBUG_FORTH_MALLOC_INT 
134b						DMARK "mrs" 
134b						CALLMONITOR 
134b					endif 
134b				jr .startalloc 
134b			 
134b			.contheap: 
134b				ld hl, heap_start 
134b			 
134b			.startalloc: 
134b			 
134b					if DEBUG_FORTH_MALLOC_INT 
134b						DMARK "mym" 
134b						CALLMONITOR 
134b					endif 
134b			.findblock: 
134b					if DEBUG_FORTH_MALLOC_INT 
134b						DMARK "mmf" 
134b						CALLMONITOR 
134b					endif 
134b			 
134b				ld a,(hl)  
134b				; if byte is zero then clear to use 
134b			 
134b			;	cp 0 
134b				or a 
134b				jr z, .foundemptyblock 
134b			 
134b				; if byte is not clear 
134b				;     then byte is offset to next block 
134b			 
134b				inc hl 
134b				ld a, (hl) ; get size 
134b			.nextblock:	inc hl 
134b					ld e, (hl) 
134b					inc hl 
134b					ld d, (hl) 
134b					ex de, hl 
134b			;	inc hl  ; move past the store space 
134b			;	inc hl  ; move past zero index  
134b			 
134b				; TODO detect no more space 
134b			 
134b				push hl 
134b				ld de, heap_end 
134b				call cmp16 
134b				pop hl 
134b				jr nc, .nospace 
134b			 
134b				jr .findblock 
134b			 
134b			.nospace: ld hl, 0 
134b				jp .exit 
134b			 
134b			 
134b			.foundemptyblock:	 
134b					if DEBUG_FORTH_MALLOC_INT 
134b						DMARK "mme" 
134b						CALLMONITOR 
134b					endif 
134b			 
134b			; TODO has block enough space if reusing??? 
134b			 
134b				;  
134b			 
134b			; see if this block has been previously used 
134b				inc hl 
134b				ld a, (hl) 
134b				dec hl 
134b			;	cp 0 
134b				or a 
134b				jr z, .newblock 
134b			 
134b					if DEBUG_FORTH_MALLOC_INT 
134b						DMARK "meR" 
134b						CALLMONITOR 
134b					endif 
134b			 
134b			; no reusing previously allocated block 
134b			 
134b			; is it smaller than previously used? 
134b				 
134b				inc hl    ; move to size 
134b				ld a, c 
134b				sub (hl)        ; we want c < (hl) 
134b				dec hl    ; move back to marker 
134b			        jr z, .findblock 
134b			 
134b				; update with the new size which should be lower 
134b			 
134b			        ;inc  hl   ; negate next move. move back to size  
134b			 
134b			.newblock: 
134b				; need to be at marker here 
134b			 
134b					if DEBUG_FORTH_MALLOC_INT 
134b						DMARK "meN" 
134b						CALLMONITOR 
134b					endif 
134b			 
134b			 
134b				ld a, c 
134b			 
134b				ld (free_list+3), a	 ; flag resume from last malloc  
134b				ld (free_list), hl    ; save out last location 
134b			 
134b			 
134b				;inc a     ; space for length byte 
134b				ld (hl), a     ; save block in use marker 
134b			 
134b				inc hl   ; move to space marker 
134b				ld (hl), a    ; save new space 
134b			 
134b				inc hl   ; move to start of allocated area 
134b				 
134b			;	push hl     ; save where we are - 1  
134b			 
134b			;	inc hl  ; move past zero index  
134b				; skip space to set down new marker 
134b			 
134b				; provide some extra space for now 
134b			 
134b				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
134b				inc a 
134b				inc a 
134b			 
134b				push hl   ; save where we are in the node block 
134b			 
134b				call addatohl 
134b			 
134b				; write linked list point 
134b			 
134b				pop de     ; get our node position 
134b				ex de, hl 
134b			 
134b				ld (hl), e 
134b				inc hl 
134b				ld (hl), d 
134b			 
134b				inc hl 
134b			 
134b				; now at start of allocated data so save pointer 
134b			 
134b				push hl 
134b			 
134b				; jump to position of next node and setup empty header in DE 
134b			 
134b				ex de, hl 
134b			 
134b			;	inc hl ; move past end of block 
134b			 
134b			;	ld a, 0 
134b				ld (hl), 0   ; empty marker 
134b				inc hl 
134b				ld (hl), 0   ; size 
134b				inc hl  
134b				ld (hl), 0   ; ptr 
134b				inc hl 
134b				ld (hl), 0   ; ptr 
134b			 
134b			 
134b				pop hl 
134b			 
134b					if DEBUG_FORTH_MALLOC_INT 
134b						DMARK "mmr" 
134b						CALLMONITOR 
134b					endif 
134b			 
134b			.exit: 
134b				pop af 
134b				pop bc 
134b				pop de  
134b				ret 
134b			 
134b			 
134b			 
134b			 
134b			free:  
134b				push hl 
134b				push af 
134b				; get address in hl 
134b			 
134b					if DEBUG_FORTH_MALLOC_INT 
134b						DMARK "fre" 
134b						CALLMONITOR 
134b					endif 
134b				; data is at hl - move to block count 
134b				dec hl 
134b				dec hl    ; get past pointer 
134b				dec hl 
134b			 
134b				ld a, (hl)    ; need this for a validation check 
134b			 
134b				dec hl    ; move to block marker 
134b			 
134b				; now check that the block count and block marker are the same  
134b			        ; this checks that we are on a malloc node and not random memory 
134b			        ; OK a faint chance this could be a problem but rare - famous last words! 
134b			 
134b				ld c, a 
134b				ld a, (hl)    
134b			 
134b				cp c 
134b				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
134b			 
134b				; yes good chance we are on a malloc node 
134b			 
134b			;	ld a, 0      
134b				ld (hl), 0   ; mark as free 
134b			 
134b				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
134b			 
134b			.freeignore:  
134b			 
134b				pop af 
134b				pop hl 
134b			 
134b				ret 
134b			 
134b			 
134b			 
134b			endif 
134b			 
134b			; eof 
# End of file firmware_memory.asm
134b			  
134b			; device C  
134b			; Now handled by SPI  
134b			;if SOUND_ENABLE  
134b			;	include "firmware_sound.asm"  
134b			;endif  
134b			  
134b			include "firmware_diags.asm"  
134b			; Hardware diags menu 
134b			 
134b			 
134b			config: 
134b			 
134b 3e 00			ld a, 0 
134d 21 68 13			ld hl, .configmn 
1350 cd ec 0b			call menu 
1353			 
1353 fe 00			cp 0 
1355 c8				ret z 
1356			 
1356			;	cp 1 
1356			;	call z, .savetostore 
1356			 
1356 3d				dec a 
1357			if STARTUP_V1 
1357 cc 7c 13			call z, .selautoload 
135a			endif 
135a			 
135a			if STARTUP_V2 
135a				call z, .enautoload 
135a			endif 
135a				;cp 2 
135a 3d				dec a 
135b cc 72 13			call z, .disautoload 
135e			if STARTUP_V2 
135e				dec a 
135e				call z, .selbank 
135e			endif 
135e			;	cp 3 
135e			;	call z, .selbank 
135e			;	cp 3 
135e 3d				dec a 
135f cc 9a 13			call z, .debug_tog 
1362			;	cp 4 
1362 3d				dec a 
1363 cc 68 14			call z, .bpsgo 
1366			;	cp 5 
1366			;	call z, hardware_diags 
1366			if STARTUP_V2 
1366			;	cp 5 
1366				dec a 
1366				call z, create_startup 
1366			endif 
1366 18 e3			jr config 
1368			 
1368			.configmn: 
1368			;	dw prom_c3 
1368 56 16			dw prom_c2 
136a 6b 16			dw prom_c2a 
136c			if STARTUP_V2 
136c				dw prom_bsel  
136c			endif 
136c			;	dw prom_c2b 
136c			;	dw prom_c4 
136c 8a 16			dw prom_m4 
136e a5 16			dw prom_m4b 
1370			;	dw prom_c1 
1370			if STARTUP_V2 
1370				dw prom_c9 
1370			endif 
1370 00 00			dw 0 
1372				 
1372			 
1372			if STARTUP_V2 
1372			.enautoload: 
1372				if STORAGE_SE 
1372				ld a, $fe      ; bit 0 clear 
1372				ld (spi_device), a 
1372			 
1372				call storage_get_block_0 
1372			 
1372				ld a, 1 
1372				ld (store_page+STORE_0_AUTOFILE), a 
1372			 
1372					ld hl, 0 
1372					ld de, store_page 
1372				call storage_write_block	 ; save update 
1372				else 
1372			 
1372				ld hl, prom_notav 
1372				ld de, prom_empty 
1372				call info_panel 
1372				endif 
1372			 
1372			 
1372				ret 
1372			endif 
1372			 
1372			.disautoload: 
1372				if STORAGE_SE 
1372				ld a, $fe      ; bit 0 clear 
1372				ld (spi_device), a 
1372			 
1372				call storage_get_block_0 
1372			 
1372				ld a, 0 
1372				ld (store_page+STORE_0_AUTOFILE), a 
1372			 
1372					ld hl, 0 
1372					ld de, store_page 
1372				call storage_write_block	 ; save update 
1372				else 
1372			 
1372 21 ad 16			ld hl, prom_notav 
1375 11 c3 16			ld de, prom_empty 
1378 cd 4e 0b			call info_panel 
137b				endif 
137b			 
137b			 
137b c9				ret 
137c			 
137c			if STARTUP_V1 
137c			 
137c			; Select auto start 
137c			 
137c			.selautoload: 
137c			 
137c				 
137c				if STORAGE_SE 
137c			 
137c					call config_dir 
137c				        ld hl, scratch 
137c					ld a, 0 
137c					call menu 
137c			 
137c					cp 0 
137c					ret z 
137c			 
137c					dec a 
137c			 
137c			 
137c					; locate menu option 
137c			 
137c					ld hl, scratch 
137c					call table_lookup 
137c			 
137c					if DEBUG_FORTH_WORDS 
137c						DMARK "ALl" 
137c						CALLMONITOR 
137c					endif 
137c					; with the pointer to the menu it, the byte following the zero term is the file id 
137c			 
137c					ld a, 0 
137c					ld bc, 50   ; max of bytes to look at 
137c					cpir  
137c			 
137c					if DEBUG_FORTH_WORDS 
137c						DMARK "ALb" 
137c						CALLMONITOR 
137c					endif 
137c					;inc hl 
137c			 
137c					ld a, (hl)   ; file id 
137c					 
137c				        ; save bank and file ids 
137c			 
137c					push af 
137c			 
137c			; TODO need to save to block 0 on bank 1	 
137c			 
137c					call storage_get_block_0 
137c			 
137c					if DEBUG_FORTH_WORDS 
137c						DMARK "AL0" 
137c						CALLMONITOR 
137c					endif 
137c					pop af 
137c			 
137c					ld (store_page+STORE_0_FILERUN),a 
137c					 
137c					; save bank id 
137c			 
137c					ld a,(spi_device) 
137c					ld (store_page+STORE_0_BANKRUN),a 
137c			 
137c					; enable auto run of store file 
137c			 
137c					ld a, 1 
137c					ld (store_page+STORE_0_AUTOFILE),a 
137c			 
137c					; save buffer 
137c			 
137c					ld hl, 0 
137c					ld de, store_page 
137c					if DEBUG_FORTH_WORDS 
137c						DMARK "ALw" 
137c						CALLMONITOR 
137c					endif 
137c				call storage_write_block	 ; save update 
137c			  
137c			 
137c			 
137c			 
137c					ld hl, scratch 
137c					call config_fdir 
137c			 
137c				else 
137c			 
137c 21 ad 16			ld hl, prom_notav 
137f 11 c3 16			ld de, prom_empty 
1382 cd 4e 0b			call info_panel 
1385			 
1385				endif 
1385 c9				ret 
1386			endif 
1386			 
1386			 
1386			; Select storage bank 
1386			 
1386			.selbank: 
1386			 
1386			if STARTUP_V2 
1386			;	if STORAGE_SE 
1386			;	else 
1386			 
1386				ld hl, prom_banks 
1386				call menu 
1386				cp 0 
1386				ret z 
1386				 
1386				; set the bank number from the result 
1386			 
1386				 
1386					ld c, SPI_CE_HIGH 
1386					ld b, '0'    ; human readable bank number 
1386			 
1386			 
1386					; active low 
1386			 
1386			;		cp 0 
1386					or a 
1386					jr z, .bset 
1386					cp 1 
1386					jr nz, .b2 
1386					res 0, c 
1386					ld b, '1'    ; human readable bank number 
1386			.b2:		cp 2 
1386					jr nz, .b3 
1386					res 1, c 
1386					ld b, '2'    ; human readable bank number 
1386			.b3:		cp 3 
1386					jr nz, .b4 
1386					res 2, c 
1386					ld b, '3'    ; human readable bank number 
1386			.b4:		cp 4 
1386					jr nz, .b5 
1386					res 3, c 
1386					ld b, '4'    ; human readable bank number 
1386			.b5:		cp 5 
1386					jr nz, .bset 
1386					res 4, c 
1386					ld b, '5'    ; human readable bank number 
1386			 
1386			.bset: 
1386			 
1386					ld a, c 
1386			;		ld (spi_device),a 
1386					ld a, b 
1386			;		ld (spi_device_id),a 
1386					push bc 
1386			 
1386					; select bank 1 and load block 0  
1386			 
1386				ld a, $fe      ; bit 0 clear 
1386				ld (spi_device), a 
1386			 
1386				call storage_get_block_0 
1386			 
1386				pop bc 
1386				ld a,c 
1386				ld (store_page+STORE_0_BANKRUN), a 
1386				ld a,b 
1386				ld (store_page+STORE_0_BANKRUNN), a 
1386					ld hl, 0 
1386					ld de, store_page 
1386				call storage_write_block 
1386			 
1386			else 
1386 21 ad 16			ld hl, prom_notav 
1389 11 c3 16			ld de, prom_empty 
138c cd 4e 0b			call info_panel 
138f			;	endif 
138f				 
138f			endif 
138f c9				ret 
1390			 
1390			if STORAGE_SE 
1390			 
1390			.config_ldir:   
1390				; Load storage bank labels into menu array 
1390			 
1390				 
1390			 
1390			 
1390				ret 
1390			 
1390			 
1390			endif 
1390			 
1390			 
1390			; Save user words to storage 
1390			 
1390			.savetostore: 
1390			 
1390			;	if STORAGE_SE 
1390			; 
1390			;		call config_dir 
1390			;	        ld hl, scratch 
1390			;		ld a, 0 
1390			;		call menu 
1390			;		 
1390			;		ld hl, scratch 
1390			;		call config_fdir 
1390			; 
1390			;	else 
1390			 
1390 21 ad 16			ld hl, prom_notav 
1393 11 c3 16			ld de, prom_empty 
1396 cd 4e 0b			call info_panel 
1399			 
1399			;	endif 
1399			 
1399 c9				ret 
139a			 
139a			if STARTUP_V2 
139a			 
139a			create_startup: 
139a			 
139a				ld a, 0 
139a				ld hl, .crstart 
139a				call menu 
139a			 
139a				cp 0 
139a				ret z 
139a			 
139a				cp 1 
139a				call z, .genlsword 
139a				cp 2 
139a				call z, .genedword 
139a			 
139a				cp 3 
139a				call z, .gendemword 
139a			 
139a				cp 4 
139a				call z, .genutlword 
139a				cp 5 
139a				call z, .genspiword 
139a				cp 6 
139a				call z, .genkeyword 
139a				cp 7 
139a				call z, .gensoundword 
139a				cp 8 
139a				call z, .genhwword 
139a				jr create_startup 
139a			 
139a			.genhwword: 
139a				ld hl, crs_hw 
139a				ld de, .hwworddef 
139a				call .genfile 
139a				ret 
139a			.gensoundword: 
139a				ld hl, crs_sound 
139a				ld de, .soundworddef 
139a				call .genfile 
139a				ret 
139a			.genlsword: 
139a				ld hl, crs_s1 
139a				ld de, .lsworddef 
139a				call .genfile 
139a				ret 
139a			 
139a			.genedword: 
139a				ld de, .edworddef 
139a				ld hl, crs_s2 
139a				call .genfile 
139a				ret 
139a			 
139a			.gendemword: 
139a				ld de, .demoworddef 
139a				ld hl, crs_s3 
139a				call .genfile 
139a				ret 
139a			 
139a			.genutlword: 
139a				ld hl, crs_s4 
139a				ld de, .utilwordef 
139a				call .genfile 
139a				ret 
139a			.genspiword: 
139a				ld hl, crs_s5 
139a				ld de, .spiworddef 
139a				call .genfile 
139a				ret 
139a			.genkeyword: 
139a				ld hl, crs_s6 
139a				ld de, .keyworddef 
139a				call .genfile 
139a				ret 
139a			 
139a			; hl - points to file name 
139a			; de - points to strings to add to file 
139a			 
139a			.genfile: 
139a				push hl 
139a				push de 
139a			 
139a				call clear_display 
139a				ld a, display_row_1 
139a				ld de, .genfiletxt 
139a				call str_at_display 
139a				call update_display 
139a			 
139a				pop de 
139a				pop hl 
139a			 
139a			 
139a				push de 
139a				call storage_create 
139a				; id in hl 
139a				pop de   ; table of strings to add 
139a			 
139a			.genloop: 
139a			 
139a				push hl ; save id for next time around 
139a				push de ; save de for next time around 
139a			 
139a				ex de, hl 
139a				call loadwordinhl 
139a				ex de, hl 
139a			 
139a				; need hl to be the id 
139a				; need de to be the string ptr 
139a				 
139a				call storage_append 
139a			 
139a				pop de 
139a				pop hl 
139a			 
139a				inc de 
139a				inc de 
139a			 
139a				ld a,(de) 
139a				cp 0 
139a				jr nz, .genloop 
139a				inc de 
139a				ld a, (de) 
139a				dec de 
139a				cp 0 
139a				jr nz, .genloop	 
139a			 
139a				ret 
139a			 
139a			.genfiletxt:  db "Creating file...",0 
139a			 
139a			.hwworddef: 
139a				dw test5 
139a				dw test6 
139a				dw test7 
139a				dw test8 
139a				dw test9 
139a				dw test10 
139a				dw 0 
139a			 
139a			.soundworddef: 
139a				dw sound1 
139a				dw sound2 
139a				dw sound3 
139a				dw sound4 
139a				dw sound5 
139a				dw sound6 
139a				dw sound7 
139a				dw sound8 
139a				dw sound9 
139a				dw 0 
139a			 
139a			.utilwordef: 
139a				dw strncpy 
139a				dw type 
139a				dw ztype 
139a				dw tuck 
139a				dw nip 
139a				dw clrstack 
139a				dw longread 
139a				dw start1 
139a				dw start2 
139a			; duplicated 
139a			;	dw start3b 
139a			;	dw start3c 
139a				dw list 
139a				dw 0 
139a			 
139a			.lsworddef: 
139a				dw start3b 
139a				dw 0 
139a			 
139a			.edworddef: 
139a				dw edit1 
139a				dw edit2 
139a				dw edit3 
139a				dw 0 
139a			 
139a			.demoworddef: 
139a				dw game1 
139a				dw game1a 
139a				dw game1b 
139a				dw game1c 
139a				dw game1d 
139a				dw game1s 
139a				dw game1t 
139a				dw game1f 
139a				dw game1z 
139a				dw game1zz 
139a				dw ssv2 
139a				dw ssv3 
139a				dw ssv4 
139a				dw ssv5 
139a				dw ssv1 
139a				dw ssv1cpm	 
139a			;	dw game2b 
139a			;	dw game2bf 
139a			;	dw game2mba 
139a			;	dw game2mbas	 
139a			;	dw game2mbht 
139a			;	dw game2mbms 
139a			;	dw game2mb 
139a			;	dw game3w 
139a			;	dw game3p 
139a			;	dw game3sc 
139a			;	dw game3vsi 
139a			;	dw game3vs 
139a				dw 0 
139a			 
139a			 
139a			.spiworddef: 
139a			 
139a			    dw spi1 
139a			    dw spi2 
139a			    dw spi2b 
139a			    dw spi3 
139a			    dw spi4 
139a			    dw spi5 
139a			    dw spib1 
139a			    dw spib2 
139a			    dw spib3 
139a			    dw spib4 
139a			    dw spib5 
139a			;    dw spi6 
139a			;    dw spi7 
139a			 
139a			;    dw spi8 
139a			;    dw spi9 
139a			;    dw spi10 
139a			    dw 0 
139a			 
139a			.keyworddef: 
139a			 
139a				dw keyup 
139a				dw keydown 
139a				dw keyleft 
139a				dw keyright 
139a				dw 	keyf1 
139a				dw keyf2 
139a				dw keyf3 
139a				dw keyf4 
139a				dw keyf5 
139a				dw keyf6 
139a				dw keyf7 
139a				dw keyf8 
139a				dw keyf9 
139a				dw keyf10 
139a				dw keyf11 
139a				dw keyf12 
139a				dw keytab 
139a				dw keycr 
139a				dw keyhome 
139a				dw keyend 
139a				dw keybs 
139a				dw 0 
139a			 
139a			.crstart: 
139a				dw crs_s1 
139a				dw crs_s2 
139a				dw crs_s3 
139a				dw crs_s4 
139a				dw crs_s5 
139a				dw crs_s6 
139a				dw crs_sound 
139a				dw crs_hw 
139a				dw 0 
139a			 
139a			endif 
139a			 
139a			 
139a			if STORAGE_SE 
139a			 
139a			config_fdir: 
139a				; using the scratch dir go through and release the memory allocated for each string 
139a				 
139a				ld hl, scratch 
139a			.cfdir:	ld e,(hl) 
139a				inc hl 
139a				ld d,(hl) 
139a				inc hl 
139a			 
139a				ex de, hl 
139a				call ishlzero 
139a				ret z     ; return on null pointer 
139a				call free 
139a				ex de, hl 
139a				jr .cfdir 
139a			 
139a			 
139a				ret 
139a			 
139a			 
139a			config_dir: 
139a			 
139a				; for the config menus that need to build a directory of storage call this routine 
139a				; it will construct a menu in scratch to pass to menu 
139a			 
139a				; open storage device 
139a			 
139a				; execute DIR to build a list of files and their ids into scratch in menu format 
139a				; once the menu has finished then will need to call config_fdir to release the strings 
139a				 
139a				; c = number items 
139a			 
139a				 
139a				call storage_get_block_0 
139a			 
139a				ld hl, store_page     ; get current id count 
139a				ld b, (hl) 
139a				ld c, 0    ; count of files   
139a			 
139a			 
139a				ld hl, scratch 
139a				ld (store_tmp2), hl    ; location to poke strings 
139a			 
139a				; check for empty drive 
139a			 
139a				ld a, 0 
139a				cp b 
139a				jp z, .dirdone 
139a			 
139a				 
139a					if DEBUG_FORTH_WORDS 
139a						DMARK "Cdc" 
139a						CALLMONITOR 
139a					endif 
139a			 
139a			 
139a			.diritem:	 
139a				push bc 
139a				; for each of the current ids do a search for them and if found push to stack 
139a			 
139a					ld hl, STORE_BLOCK_PHY 
139a					ld d, 0		 ; look for extent 0 of block id as this contains file name 
139a					ld e,b 
139a			 
139a					call storage_findnextid 
139a			 
139a			 
139a					; if found hl will be non zero 
139a			 
139a					call ishlzero 
139a					jr z, .dirnotfound 
139a			 
139a					; increase count 
139a			 
139a					pop bc	 
139a					inc c 
139a					push bc 
139a					 
139a			 
139a					; get file header and push the file name 
139a			 
139a					ld de, store_page 
139a					call storage_read_block 
139a			 
139a					; push file id to stack 
139a				 
139a					ld a, (store_page) 
139a					ld h, 0 
139a					ld l, a 
139a			 
139a					;call forth_push_numhl 
139a					; TODO store id 
139a			 
139a					push hl 
139a			 
139a					; push extent count to stack  
139a				 
139a					ld hl, store_page+3 
139a			 
139a					; get file name length 
139a			 
139a					call strlenz   
139a			 
139a					inc hl   ; cover zero term 
139a					inc hl  ; stick the id at the end of the area 
139a			 
139a					push hl 
139a					pop bc    ; move length to bc 
139a			 
139a					call malloc 
139a			 
139a					; TODO save malloc area to scratch 
139a			 
139a					ex de, hl 
139a					ld hl, (store_tmp2) 
139a					ld (hl), e 
139a					inc hl 
139a					ld (hl), d 
139a					inc hl 
139a					ld (store_tmp2), hl 
139a			 
139a					 
139a			 
139a					;pop hl   ; get source 
139a			;		ex de, hl    ; swap aronund	 
139a			 
139a					ld hl, store_page+3 
139a					if DEBUG_FORTH_WORDS 
139a						DMARK "CFd" 
139a						CALLMONITOR 
139a					endif 
139a					ldir 
139a			 
139a					; de is past string, move back one and store id 
139a					 
139a					dec de 
139a			 
139a					; store file id 
139a			 
139a					pop hl 
139a					ex de,hl 
139a					ld (hl), e 
139a			 
139a					if DEBUG_FORTH_WORDS 
139a						DMARK "Cdi" 
139a						CALLMONITOR 
139a					endif 
139a					 
139a			.dirnotfound: 
139a					pop bc     
139a					djnz .diritem 
139a				 
139a			.dirdone:	 
139a			 
139a			;		ld a, 0 
139a					ld hl, (store_tmp2) 
139a					ld (hl), 0 
139a					inc hl 
139a					ld (hl), 0 
139a					inc hl 
139a					; push a count of the dir items found 
139a			 
139a			;		ld h, 0 
139a			;		ld l, c 
139a			 
139a				ret 
139a			 
139a			endif 
139a			 
139a			 
139a			; Settings 
139a			; Run  
139a			 
139a			 
139a			 
139a			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
139a			;;hd_menu2:   db "        2: Editor",0   
139a			;hd_menu2:   db "        2: Editor       6: Menu",0   
139a			;hd_menu3:   db "        3: Storage",0 
139a			;hd_menu4:   db "0=quit  4: Debug",0 
139a			;hd_don:     db "ON",0 
139a			;hd_doff:     db "OFF",0 
139a			; 
139a			; 
139a			; 
139a			;hardware_diags_old:       
139a			; 
139a			;.diagmenu: 
139a			;	call clear_display 
139a			;	ld a, display_row_1 
139a			;	ld de, hd_menu1 
139a			;	call str_at_display 
139a			; 
139a			;	ld a, display_row_2 
139a			;	ld de, hd_menu2 
139a			;	call str_at_display 
139a			; 
139a			;	ld a, display_row_3 
139a			;	ld de, hd_menu3 
139a			;	call str_at_display 
139a			; 
139a			;	ld a,  display_row_4 
139a			;	ld de, hd_menu4 
139a			;	call str_at_display 
139a			; 
139a			;	; display debug state 
139a			; 
139a			;	ld de, hd_don 
139a			;	ld a, (os_view_disable) 
139a			;	cp 0 
139a			;	jr z, .distog 
139a			;	ld de, hd_doff 
139a			;.distog: ld a, display_row_4+17 
139a			;	call str_at_display 
139a			; 
139a			;	call update_display 
139a			; 
139a			;	call cin_wait 
139a			; 
139a			; 
139a			; 
139a			;	cp '4' 
139a			;	jr nz, .diagn1 
139a			; 
139a			;	; debug toggle 
139a			; 
139a			;	ld a, (os_view_disable) 
139a			;	ld b, '*' 
139a			;	cp 0 
139a			;	jr z, .debtog 
139a			;	ld b, 0 
139a			;.debtog:	 
139a			;	ld a,b 
139a			;	ld (os_view_disable),a 
139a			; 
139a			;.diagn1: cp '0' 
139a			;	 ret z 
139a			; 
139a			;;	cp '1' 
139a			;;       jp z, matrix	 
139a			;;   TODO keyboard matrix test 
139a			; 
139a			;	cp '2' 
139a			;	jp z, .diagedit 
139a			; 
139a			;;	cp '6' 
139a			;;	jp z, .menutest 
139a			;;if ENABLE_BASIC 
139a			;;	cp '6' 
139a			;;	jp z, basic 
139a			;;endif 
139a			 ; 
139a			;	jp .diagmenu 
139a			; 
139a			; 
139a			;	ret 
139a			 
139a			 
139a			.debug_tog: 
139a 21 c3 13			ld hl, .menudebug 
139d				 
139d			;	ld a, (os_view_disable) 
139d			;	cp '*' 
139d 3a 6b ee			ld a,(debug_vector) 
13a0 fe c9			cp $C9   ; RET 
13a2 20 04			jr nz,.tdon  
13a4 3e 01			ld a, 1 
13a6 18 02			jr .tog1 
13a8 3e 00		.tdon: ld a, 0 
13aa			 
13aa			.tog1: 
13aa cd ec 0b			call menu 
13ad fe 00			cp 0 
13af c8				ret z 
13b0 fe 01			cp 1    ; disable debug 
13b2 28 04			jr z, .dtog0 
13b4 3e 2a			ld a, '*' 
13b6 18 05			jr .dtogset 
13b8			.dtog0:  
13b8				;ld a, 0 
13b8 cd 56 14			call bp_on 
13bb 18 dd			jr .debug_tog 
13bd			.dtogset:  
13bd				; ld (os_view_disable), a 
13bd cd 62 14			call bp_off 
13c0 c3 9a 13			jp .debug_tog 
13c3			 
13c3			 
13c3			.menudebug: 
13c3 c9 13				dw .m6 
13c5 d2 13				dw .m7 
13c7 00 00				dw 0 
13c9 .. 00		.m6:   db "Debug ON",0 
13d2 .. 00		.m7:   db "Debug OFF",0 
13dc			;hardware_diags:       
13dc			 
13dc			ENABLE_HDIAGS: equ 0 
13dc			 
13dc			if ENABLE_HDIAGS 
13dc			.diagm: 
13dc				ld hl, .menuitems 
13dc				ld a, 0 
13dc				call menu 
13dc			 
13dc			         cp 0 
13dc				 ret z 
13dc			 
13dc				cp 2 
13dc				jp z, .diagedit 
13dc			 
13dc			;	cp '6' 
13dc			;	jp z, .menutest 
13dc			;if ENABLE_BASIC 
13dc			;	cp '6' 
13dc			;	jp z, basic 
13dc			;endif 
13dc			  
13dc				jp .diagm 
13dc			 
13dc				 
13dc			.menuitems:   	dw .m1 
13dc					dw .m2 
13dc					dw .m3 
13dc					dw .m5 
13dc					dw .m5a 
13dc					dw .m5b 
13dc					dw 0 
13dc			 
13dc			 
13dc			.m1:   db "Key Matrix",0 
13dc			.m2:   db "Editor",0 
13dc			.m3:   db "Storage",0 
13dc			.m5:   db "Sound",0 
13dc			.m5a:  db "RAM Test",0 
13dc			.m5b:  db "LCD Test",0 
13dc			 
13dc			 
13dc			; debug editor 
13dc			 
13dc			.diagedit: 
13dc			 
13dc				ld hl, scratch 
13dc			;	ld bc, 250 
13dc			;	ldir 
13dc				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
13dc			;	ld a, 0 
13dc				ld (hl), 0 
13dc				inc hl 
13dc				ld (hl), 0 
13dc				inc hl 
13dc				ld (hl), 0 
13dc			 
13dc			        call clear_display 
13dc				call update_display 
13dc				;ld a, 1 
13dc				;ld (hardware_diag), a 
13dc			.diloop: 
13dc				ld a, display_row_1 
13dc				ld c, 0 
13dc				ld d, 255    ; TODO fix input_str to actually take note of max string input length 
13dc				ld e, 40 
13dc			 
13dc				ld hl, scratch	 
13dc				call input_str 
13dc			 
13dc				ld a, display_row_2 
13dc				ld de, scratch 
13dc				call str_at_display 
13dc				call update_display 
13dc			 
13dc				jp .diloop 
13dc			endif 
13dc			 
13dc			; pass word in hl 
13dc			; a has display location 
13dc			display_word_at: 
13dc f5				push af 
13dd e5				push hl 
13de 7c				ld a,h 
13df 21 b9 e5			ld hl, os_word_scratch 
13e2 cd e2 0f			call hexout 
13e5 e1				pop hl 
13e6 7d				ld a,l 
13e7 21 bb e5			ld hl, os_word_scratch+2 
13ea cd e2 0f			call hexout 
13ed 21 bd e5			ld hl, os_word_scratch+4 
13f0			;	ld a,0 
13f0 36 00			ld (hl),0 
13f2 11 b9 e5			ld de,os_word_scratch 
13f5 f1				pop af 
13f6 cd ce 0b				call str_at_display 
13f9 c9				ret 
13fa			 
13fa			display_ptr_state: 
13fa			 
13fa				; to restore afterwards 
13fa			 
13fa d5				push de 
13fb c5				push bc 
13fc e5				push hl 
13fd f5				push af 
13fe			 
13fe				; for use in here 
13fe			 
13fe			;	push bc 
13fe			;	push de 
13fe			;	push hl 
13fe			;	push af 
13fe			 
13fe cd bc 0b			call clear_display 
1401			 
1401 11 d9 15			ld de, .ptrstate 
1404 3e 00			ld a, display_row_1 
1406 cd ce 0b			call str_at_display 
1409			 
1409				; display debug step 
1409			 
1409			 
1409 11 5e ee			ld de, debug_mark 
140c 3e 26			ld a, display_row_1+display_cols-2 
140e cd ce 0b			call str_at_display 
1411			 
1411				; display a 
1411 11 e3 15			ld de, .ptrcliptr 
1414 3e 28			ld a, display_row_2 
1416 cd ce 0b			call str_at_display 
1419			 
1419 f1				pop af 
141a 2a 33 ea			ld hl,(cli_ptr) 
141d 3e 30			ld a, display_row_2+8 
141f cd dc 13			call display_word_at 
1422			 
1422			 
1422				; display hl 
1422			 
1422			 
1422 11 eb 15			ld de, .ptrclioptr 
1425 3e 32			ld a, display_row_2+10 
1427 cd ce 0b			call str_at_display 
142a			; 
142a			;	pop hl 
142a 3e 35			ld a, display_row_2+13 
142c 2a 31 ea			ld hl,(cli_origptr) 
142f cd dc 13			call display_word_at 
1432			; 
1432			;	 
1432			;	; display de 
1432			 
1432			;	ld de, .regstatede 
1432			;	ld a, display_row_3 
1432			;	call str_at_display 
1432			 
1432			;	pop de 
1432			;	ld h,d 
1432			;	ld l, e 
1432			;	ld a, display_row_3+3 
1432			;	call display_word_at 
1432			 
1432			 
1432				; display bc 
1432			 
1432			;	ld de, .regstatebc 
1432			;	ld a, display_row_3+10 
1432			;	call str_at_display 
1432			 
1432			;	pop bc 
1432			;	ld h,b 
1432			;	ld l, c 
1432			;	ld a, display_row_3+13 
1432			;	call display_word_at 
1432			 
1432			 
1432				; display dsp 
1432			 
1432			;	ld de, .regstatedsp 
1432			;	ld a, display_row_4 
1432			;	call str_at_display 
1432			 
1432				 
1432			;	ld hl,(cli_data_sp) 
1432			;	ld a, display_row_4+4 
1432			;	call display_word_at 
1432			 
1432				; display rsp 
1432			 
1432 11 1a 16			ld de, .regstatersp 
1435 3e 82			ld a, display_row_4+10 
1437 cd ce 0b			call str_at_display 
143a			 
143a				 
143a 2a e5 e9			ld hl,(cli_ret_sp) 
143d 3e 86			ld a, display_row_4+14 
143f cd dc 13			call display_word_at 
1442			 
1442 cd de 0b			call update_display 
1445			 
1445 cd f0 0a			call delay1s 
1448 cd f0 0a			call delay1s 
144b cd f0 0a			call delay1s 
144e			 
144e			 
144e cd 4f 1a			call next_page_prompt 
1451			 
1451				; restore  
1451			 
1451 f1				pop af 
1452 e1				pop hl 
1453 c1				pop bc 
1454 d1				pop de 
1455 c9				ret 
1456			 
1456			; Update the break point vector so that the user can hook a new routine 
1456			 
1456			bp_on: 
1456 3e c3			ld a, $c3    ; JP 
1458 32 6b ee			ld (debug_vector), a 
145b 21 68 14			ld hl, break_point_state 
145e 22 6c ee			ld (debug_vector+1), hl 
1461 c9				ret 
1462			 
1462			bp_off: 
1462 3e c9			ld a, $c9    ; RET 
1464 32 6b ee			ld (debug_vector), a 
1467 c9				ret 
1468			 
1468			 
1468			break_point_state: 
1468			;	push af 
1468			; 
1468			;	; see if disabled 
1468			; 
1468			;	ld a, (os_view_disable) 
1468			;	cp '*' 
1468			;	jr nz, .bpsgo 
1468			;	pop af 
1468			;	ret 
1468			 
1468			.bpsgo: 
1468			;	pop af 
1468 f5				push af 
1469 22 96 e2			ld (os_view_hl), hl 
146c ed 53 94 e2		ld (os_view_de), de 
1470 ed 43 92 e2		ld (os_view_bc), bc 
1474 e5				push hl 
1475 6f				ld l, a 
1476 26 00			ld h, 0 
1478 22 98 e2			ld (os_view_af),hl 
147b			 
147b 21 a4 ed				ld hl, display_fb0 
147e 22 bf eb				ld (display_fb_active), hl 
1481 e1				pop hl	 
1482			 
1482 3e 31			ld a, '1' 
1484 fe 2a		.bps1:  cp '*' 
1486 cc 62 14			call z, bp_off 
1489			;	jr nz, .bps1b 
1489			;	ld (os_view_disable),a 
1489 fe 31		.bps1b:  cp '1' 
148b 20 14			jr nz, .bps2 
148d			 
148d				; display reg 
148d			 
148d				 
148d			 
148d 3a 98 e2			ld a, (os_view_af) 
1490 2a 96 e2			ld hl, (os_view_hl) 
1493 ed 5b 94 e2		ld de, (os_view_de) 
1497 ed 4b 92 e2		ld bc, (os_view_bc) 
149b cd 35 15			call display_reg_state 
149e c3 21 15			jp .bpschk 
14a1			 
14a1 fe 32		.bps2:  cp '2' 
14a3 20 08			jr nz, .bps3 
14a5				 
14a5				; display hl 
14a5 2a 96 e2			ld hl, (os_view_hl) 
14a8 cd 1f 16			call display_dump_at_hl 
14ab			 
14ab 18 74			jr .bpschk 
14ad			 
14ad fe 33		.bps3:  cp '3' 
14af 20 08			jr nz, .bps4 
14b1			 
14b1			        ; display de 
14b1 2a 94 e2			ld hl, (os_view_de) 
14b4 cd 1f 16			call display_dump_at_hl 
14b7			 
14b7 18 68			jr .bpschk 
14b9 fe 34		.bps4:  cp '4' 
14bb 20 08			jr nz, .bps5 
14bd			 
14bd			        ; display bc 
14bd 2a 92 e2			ld hl, (os_view_bc) 
14c0 cd 1f 16			call display_dump_at_hl 
14c3			 
14c3 18 5c			jr .bpschk 
14c5 fe 35		.bps5:  cp '5' 
14c7 20 08		        jr nz, .bps7 
14c9			 
14c9				; display cur ptr 
14c9 2a 33 ea			ld hl, (cli_ptr) 
14cc cd 1f 16			call display_dump_at_hl 
14cf			 
14cf 18 50			jr .bpschk 
14d1 fe 36		.bps7:  cp '6' 
14d3 20 08			jr nz, .bps8b 
14d5				 
14d5				; display cur orig ptr 
14d5 2a 31 ea			ld hl, (cli_origptr) 
14d8 cd 1f 16			call display_dump_at_hl 
14db 18 44			jr .bpschk 
14dd fe 37		.bps8b:  cp '7' 
14df 20 08			jr nz, .bps9 
14e1				 
14e1				; display dsp 
14e1 2a e1 e9			ld hl, (cli_data_sp) 
14e4 cd 1f 16			call display_dump_at_hl 
14e7			 
14e7 18 38			jr .bpschk 
14e9 fe 39		.bps9:  cp '9' 
14eb 20 05			jr nz, .bps8c 
14ed				 
14ed				; display SP 
14ed			;	ld hl, sp 
14ed cd 1f 16			call display_dump_at_hl 
14f0			 
14f0 18 2f			jr .bpschk 
14f2 fe 38		.bps8c:  cp '8' 
14f4 20 08			jr nz, .bps8d 
14f6				 
14f6				; display rsp 
14f6 2a e5 e9			ld hl, (cli_ret_sp) 
14f9 cd 1f 16			call display_dump_at_hl 
14fc			 
14fc 18 23			jr .bpschk 
14fe fe 23		.bps8d:  cp '#'     ; access monitor sub system 
1500 20 05			jr nz, .bps8 
1502 cd 0d 18			call monitor 
1505			 
1505 18 1a			jr .bpschk 
1507 fe 30		.bps8:  cp '0' 
1509 20 16			jr nz, .bpschk 
150b			 
150b 21 03 ed				ld hl, display_fb1 
150e 22 bf eb				ld (display_fb_active), hl 
1511 cd de 0b				call update_display 
1514			 
1514				;ld a, (os_view_af) 
1514 2a 96 e2			ld hl, (os_view_hl) 
1517 ed 5b 94 e2		ld de, (os_view_de) 
151b ed 4b 92 e2		ld bc, (os_view_bc) 
151f f1				pop af 
1520 c9				ret 
1521			 
1521			.bpschk:   
1521 cd f0 0a			call delay1s 
1524 3e 9f		ld a,display_row_4 + display_cols - 1 
1526 11 4d 1a		        ld de, endprg 
1529 cd ce 0b			call str_at_display 
152c cd de 0b			call update_display 
152f cd 7e 67			call cin_wait 
1532			 
1532 c3 84 14			jp .bps1 
1535			 
1535			 
1535			display_reg_state: 
1535			 
1535				; to restore afterwards 
1535			 
1535 d5				push de 
1536 c5				push bc 
1537 e5				push hl 
1538 f5				push af 
1539			 
1539				; for use in here 
1539			 
1539 c5				push bc 
153a d5				push de 
153b e5				push hl 
153c f5				push af 
153d			 
153d cd bc 0b			call clear_display 
1540			 
1540 11 f5 15			ld de, .regstate 
1543 3e 00			ld a, display_row_1 
1545 cd ce 0b			call str_at_display 
1548			 
1548				; display debug step 
1548			 
1548			 
1548 11 5e ee			ld de, debug_mark 
154b 3e 25			ld a, display_row_1+display_cols-3 
154d cd ce 0b			call str_at_display 
1550			 
1550				; display a 
1550 11 11 16			ld de, .regstatea 
1553 3e 28			ld a, display_row_2 
1555 cd ce 0b			call str_at_display 
1558			 
1558 e1				pop hl 
1559			;	ld h,0 
1559			;	ld l, a 
1559 3e 2b			ld a, display_row_2+3 
155b cd dc 13			call display_word_at 
155e			 
155e			 
155e				; display hl 
155e			 
155e			 
155e 11 05 16			ld de, .regstatehl 
1561 3e 32			ld a, display_row_2+10 
1563 cd ce 0b			call str_at_display 
1566			 
1566 e1				pop hl 
1567 3e 35			ld a, display_row_2+13 
1569 cd dc 13			call display_word_at 
156c			 
156c				 
156c				; display de 
156c			 
156c 11 09 16			ld de, .regstatede 
156f 3e 50			ld a, display_row_3 
1571 cd ce 0b			call str_at_display 
1574			 
1574 e1				pop hl 
1575			;	ld h,d 
1575			;	ld l, e 
1575 3e 53			ld a, display_row_3+3 
1577 cd dc 13			call display_word_at 
157a			 
157a			 
157a				; display bc 
157a			 
157a 11 0d 16			ld de, .regstatebc 
157d 3e 5a			ld a, display_row_3+10 
157f cd ce 0b			call str_at_display 
1582			 
1582 e1				pop hl 
1583			;	ld h,b 
1583			;	ld l, c 
1583 3e 5d			ld a, display_row_3+13 
1585 cd dc 13			call display_word_at 
1588			 
1588			 
1588				; display dsp 
1588			 
1588 11 15 16			ld de, .regstatedsp 
158b 3e 78			ld a, display_row_4 
158d cd ce 0b			call str_at_display 
1590			 
1590				 
1590 2a e1 e9			ld hl,(cli_data_sp) 
1593 3e 7c			ld a, display_row_4+4 
1595 cd dc 13			call display_word_at 
1598			 
1598				; display rsp 
1598			 
1598 11 1a 16			ld de, .regstatersp 
159b 3e 82			ld a, display_row_4+10 
159d cd ce 0b			call str_at_display 
15a0			 
15a0				 
15a0 2a e5 e9			ld hl,(cli_ret_sp) 
15a3 3e 86			ld a, display_row_4+14 
15a5 cd dc 13			call display_word_at 
15a8			 
15a8 cd de 0b			call update_display 
15ab			 
15ab			;	call delay1s 
15ab			;	call delay1s 
15ab			;	call delay1s 
15ab			 
15ab			 
15ab			;	call next_page_prompt 
15ab			 
15ab				; restore  
15ab			 
15ab f1				pop af 
15ac e1				pop hl 
15ad c1				pop bc 
15ae d1				pop de 
15af c9				ret 
15b0			 
15b0 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
15c4 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
15d9 .. 00		.ptrstate:	db "Ptr State",0 
15e3 .. 00		.ptrcliptr:     db "cli_ptr",0 
15eb .. 00		.ptrclioptr:     db "cli_o_ptr",0 
15f5 .. 00		.regstate:	db "Reg State (1/0)",0 
1605 .. 00		.regstatehl:	db "HL:",0 
1609 .. 00		.regstatede:	db "DE:",0 
160d .. 00		.regstatebc:	db "BC:",0 
1611 .. 00		.regstatea:	db "A :",0 
1615 .. 00		.regstatedsp:	db "DSP:",0 
161a .. 00		.regstatersp:	db "RSP:",0 
161f			 
161f			display_dump_at_hl: 
161f e5				push hl 
1620 d5				push de 
1621 c5				push bc 
1622 f5				push af 
1623			 
1623 22 d7 e5			ld (os_cur_ptr),hl	 
1626 cd bc 0b			call clear_display 
1629 cd 5b 19			call dumpcont 
162c			;	call delay1s 
162c			;	call next_page_prompt 
162c			 
162c			 
162c f1				pop af 
162d c1				pop bc 
162e d1				pop de 
162f e1				pop hl 
1630 c9				ret 
1631			 
1631			;if ENABLE_BASIC 
1631			;	include "nascombasic.asm" 
1631			;	basic: 
1631			;	include "forth/FORTH.ASM" 
1631			;endif 
1631			 
1631			; eof 
1631			 
1631			 
# End of file firmware_diags.asm
1631			  
1631			include "firmware_prompts.asm"  
1631			; Prompts  
1631			 
1631			; boot messages 
1631			 
1631 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
1646 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
1656			 
1656			 
1656			; config menus 
1656			 
1656			;prom_c3: db "Add Dictionary To File",0 
1656			 
1656			if STARTUP_V1 
1656 .. 00		prom_c2: db "Select Autoload File",0 
166b .. 00		prom_c2a: db "Disable Autoload File", 0 
1681			endif 
1681			 
1681			if STARTUP_V2 
1681			prom_c2: db "Enable Autoload Files",0 
1681			prom_c2a: db "Disable Autoload Files", 0 
1681			 
1681			crs_s1: db "*ls-word", 0 
1681			crs_s2: db "*ed-word", 0 
1681			crs_s3: db "*Demo-Games", 0 
1681			crs_s4: db "*Utils", 0 
1681			crs_s5: db "*SPI-Util", 0 
1681			crs_s6: db "*Key-Constants", 0 
1681			crs_sound: db "*Sound-Util", 0 
1681			crs_hw: db "*Hello-World",0 
1681			 
1681			 
1681			 
1681			endif 
1681			;prom_c2b: db "Select Storage Bank",0 
1681 .. 00		prom_c4: db "Settings",0 
168a .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
16a5 .. 00		prom_m4b:   db "Monitor",0 
16ad			;prom_c1: db "Hardware Diags",0 
16ad			 
16ad			 
16ad			if STARTUP_V2 
16ad			prom_c9: db "Create Startup Files",0 
16ad			prom_bsel: db "Start From Bank...",0 
16ad			prom_bsel1: db "Bank 1",0 
16ad			prom_bsel2: db "Bank 2",0 
16ad			prom_bsel3: db "Bank 3",0 
16ad			prom_bsel4: db "Bank 4",0 
16ad			prom_bsel5: db "Bank 5",0 
16ad			 
16ad			prom_banks: 
16ad				dw prom_bsel1 
16ad				dw prom_bsel2 
16ad				dw prom_bsel3 
16ad				dw prom_bsel4 
16ad				dw prom_bsel5 
16ad				dw 0 
16ad			endif 
16ad			 
16ad .. 00		prom_notav:    db "Feature not available",0 
16c3 .. 00		prom_empty:    db "",0 
16c4			 
16c4			; eof 
16c4			 
# End of file firmware_prompts.asm
16c4			  
16c4			; eof  
16c4			  
# End of file firmware.asm
16c4			 
16c4			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
16c4			;if BASE_KEV  
16c4			;baseram: equ 08000h 
16c4			;endif 
16c4			 
16c4			;if BASE_SC114 
16c4			;baseram:     equ    endofcode 
16c4			;endif 
16c4			 
16c4			 
16c4			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
16c4			 
16c4			; start system 
16c4			 
16c4			coldstart: 
16c4				; set sp 
16c4				; di/ei 
16c4			 
16c4 f3				di 
16c5 31 00 f0			ld sp, tos 
16c8 cd 73 66			call init_nmi 
16cb			;	ei 
16cb			 
16cb				; init spinner 
16cb 3e 00			ld a,0 
16cd 32 b9 eb			ld (display_active), a 
16d0			 
16d0				; disable breakpoint by default 
16d0			 
16d0				;ld a,'*' 
16d0			;	ld a,' ' 
16d0			;	ld (os_view_disable),a 
16d0			 
16d0				; set break point vector as new break point on or off 
16d0 cd 62 14			call bp_off 
16d3			 
16d3			 
16d3				; default the parse vector to just a RET 
16d3 3e c9			ld a, $c9 
16d5 32 68 ee			ld (parse_vector), a 
16d8			 
16d8				; init hardware 
16d8			 
16d8				; init keyboard and screen hardware 
16d8			 
16d8 cd 1f 01			call hardware_init 
16db			 
16db			 
16db cd f0 0a			call delay1s 
16de 3e 58			ld a, display_row_3+8 
16e0 11 03 01			ld de, buildtime 
16e3 cd ce 0b			call str_at_display 
16e6 cd de 0b			call update_display 
16e9			 
16e9 cd f0 0a			call delay1s 
16ec cd f0 0a			call delay1s 
16ef cd f0 0a			call delay1s 
16f2			 
16f2				; detect if any keys are held down to enable breakpoints at start up 
16f2			 
16f2 cd 86 67			call cin  
16f5 fe 00			cp 0 
16f7 28 03			jr z, .nokeys 
16f9			 
16f9				;call hardware_diags 
16f9 cd 4b 13			call config 
16fc			 
16fc			;	ld de, .bpen 
16fc			;	ld a, display_row_4 
16fc			;	call str_at_display 
16fc			;	call update_display 
16fc			; 
16fc			;	ld a,0 
16fc			;	ld (os_view_disable),a 
16fc			; 
16fc			;.bpwait: 
16fc			;	call cin 
16fc			;	cp 0 
16fc			;	jr z, .bpwait 
16fc			;	jr .nokeys 
16fc			; 
16fc			; 
16fc			;.bpen:  db "Break points enabled!",0 
16fc			 
16fc			 
16fc			 
16fc			 
16fc			 
16fc			 
16fc			.nokeys: 
16fc			 
16fc			 
16fc				 
16fc			 
16fc			;jp  testkey 
16fc			 
16fc			;call storage_get_block_0 
16fc			; 
16fc			;ld hl, 0 
16fc			;ld de, store_page 
16fc			;call storage_read_block 
16fc			 
16fc				 
16fc			;ld hl, 10 
16fc			;ld de, store_page 
16fc			;call storage_read_block 
16fc			 
16fc			 
16fc			 
16fc			 
16fc			 
16fc			;stop:	nop 
16fc			;	jp stop 
16fc			 
16fc			 
16fc			 
16fc			main: 
16fc cd bc 0b			call clear_display 
16ff cd de 0b			call update_display 
1702			 
1702			 
1702			 
1702			;	call testlcd 
1702			 
1702			 
1702			 
1702 cd 8a 1e			call forth_init 
1705			 
1705			 
1705			warmstart: 
1705 cd 60 1e			call forth_warmstart 
1708			 
1708				; run startup word load 
1708			        ; TODO prevent this running at warmstart after crash  
1708			 
1708				if STARTUP_ENABLE 
1708			 
1708					if STARTUP_V1 
1708			 
1708						if STORAGE_SE 
1708							call forth_autoload 
1708						endif 
1708 cd c3 65					call forth_startup 
170b					endif 
170b			 
170b					if STARTUP_V2 
170b			 
170b						if STORAGE_SE 
170b							call forth_autoload 
170b						else 
170b							call forth_startup 
170b						endif 
170b			 
170b			 
170b					endif 
170b			 
170b				endif 
170b			 
170b			warmstart_afterauto: 
170b			 
170b				; show free memory after boot 
170b 11 a8 17			ld de, freeram 
170e 3e 00			ld a, display_row_1 
1710 cd ce 0b			call str_at_display 
1713			 
1713				; get current heap start after loading any uwords 
1713			 
1713				;ld de, (os_last_new_uword) 
1713				;ex de, hl 
1713			 
1713			; Or use heap_size word???? 
1713				;ld hl, heap_end 
1713				;ld hl, heap_size 
1713				;ld de, topusermem 
1713				;ld de, heap_start 
1713 ed 5b a9 67			ld de, (free_list )      
1717 21 8f e2				ld hl, heap_end 
171a ed 52			sbc hl, de 
171c				;push hl 
171c				;ld a,h	         	 
171c				;ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
171c				;call hexout 
171c			   	;pop hl 
171c			; 
171c			;	ld a,l 
171c			;	ld hl, os_word_scratch+2 
171c			;	call hexout 
171c			;	ld hl, os_word_scratch+4 
171c			;	ld a, 0 
171c			;	ld (hl),a 
171c eb				ex de, hl 
171d 21 b9 e5			ld hl, os_word_scratch 
1720 cd ed 10			call uitoa_16 
1723			 
1723			 
1723 11 b9 e5			ld de, os_word_scratch 
1726 3e 0d			ld a, display_row_1 + 13 
1728 cd ce 0b			call str_at_display 
172b cd de 0b			call update_display 
172e			 
172e			 
172e				;call demo 
172e			 
172e			 
172e				; init scratch input area for cli commands 
172e			 
172e 21 db e5			ld hl, os_cli_cmd 
1731			;	ld a,0 
1731 36 00			ld (hl),0 
1733 23				inc hl 
1734 36 00			ld (hl),0 
1736			 
1736 3e 00			ld a,0 
1738 32 da e6			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
173b			 
173b 32 d7 e5			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
173e 32 d8 e5			ld (os_cur_ptr+1),a	 
1741			 
1741 32 b9 e5			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1744 32 ba e5			ld (os_word_scratch+1),a	 
1747				 
1747			 
1747				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1747 21 db e5			ld hl, os_cli_cmd 
174a			 
174a			;	ld a, 0		 ; init cli input 
174a 36 00			ld (hl), 0 
174c 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
174e			cli: 
174e				; show cli prompt 
174e				;push af 
174e				;ld a, 0 
174e				;ld de, prompt 
174e				;call str_at_display 
174e			 
174e				;call update_display 
174e				;pop af 
174e				;inc a 
174e				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
174e			 
174e			.lastrecall: 
174e			 
174e 0e 00			ld c, 0 
1750 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1752 1e 28			ld e, 40 
1754			 
1754 21 db e5			ld hl, os_cli_cmd 
1757			 
1757				STACKFRAME OFF $fefe $9f9f 
1757				if DEBUG_STACK_IMB 
1757					if OFF 
1757						exx 
1757						ld de, $fefe 
1757						ld a, d 
1757						ld hl, curframe 
1757						call hexout 
1757						ld a, e 
1757						ld hl, curframe+2 
1757						call hexout 
1757						ld hl, $fefe 
1757						push hl 
1757						ld hl, $9f9f 
1757						push hl 
1757						exx 
1757					endif 
1757				endif 
1757			endm 
# End of macro STACKFRAME
1757			 
1757 cd 13 0e			call input_str 
175a			 
175a				STACKFRAMECHK OFF $fefe $9f9f 
175a				if DEBUG_STACK_IMB 
175a					if OFF 
175a						exx 
175a						ld hl, $9f9f 
175a						pop de   ; $9f9f 
175a						call cmp16 
175a						jr nz, .spnosame 
175a						ld hl, $fefe 
175a						pop de   ; $fefe 
175a						call cmp16 
175a						jr z, .spfrsame 
175a						.spnosame: call showsperror 
175a						.spfrsame: nop 
175a						exx 
175a					endif 
175a				endif 
175a			endm 
# End of macro STACKFRAMECHK
175a			 
175a			 
175a				; check to see if last line recall has been requested 
175a			 
175a			if EDIT_V2 
175a fe 05			cp KEY_UP 
175c 20 0f			jr nz, .noexecline 
175e			 
175e 11 db e5			ld de, os_cli_cmd 
1761 21 da e6			ld hl, os_last_cmd 
1764 01 ff 00			ld bc, 255 
1767 ed b0			ldir 
1769 3e 00			ld a, 0 
176b 18 e1			jr .lastrecall 
176d			endif 
176d			 
176d			.noexecline: 
176d				; no so exec the line		 
176d			 
176d				; copy input to last command 
176d			 
176d 21 db e5			ld hl, os_cli_cmd 
1770 11 da e6			ld de, os_last_cmd 
1773 01 ff 00			ld bc, 255 
1776 ed b0			ldir 
1778			 
1778				; wipe current buffer 
1778			 
1778			;	ld a, 0 
1778			;	ld hl, os_cli_cmd 
1778			;	ld de, os_cli_cmd+1 
1778			;	ld bc, 254 
1778			;	ldir 
1778				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1778			;	call strcpy 
1778			;	ld a, 0 
1778			;	ld (hl), a 
1778			;	inc hl 
1778			;	ld (hl), a 
1778			;	inc hl 
1778			;	ld (hl), a 
1778			 
1778				; switch frame buffer to program  
1778			 
1778 21 03 ed				ld hl, display_fb1 
177b 22 bf eb				ld (display_fb_active), hl 
177e			 
177e			;	nop 
177e				STACKFRAME ON $fbfe $8f9f 
177e				if DEBUG_STACK_IMB 
177e					if ON 
177e						exx 
177e						ld de, $fbfe 
177e						ld a, d 
177e						ld hl, curframe 
177e						call hexout 
177e						ld a, e 
177e						ld hl, curframe+2 
177e						call hexout 
177e						ld hl, $fbfe 
177e						push hl 
177e						ld hl, $8f9f 
177e						push hl 
177e						exx 
177e					endif 
177e				endif 
177e			endm 
# End of macro STACKFRAME
177e				; first time into the parser so pass over the current scratch pad 
177e 21 db e5			ld hl,os_cli_cmd 
1781				; tokenise the entered statement(s) in HL 
1781 cd 00 1f			call forthparse 
1784			        ; exec forth statements in top of return stack 
1784 cd 38 1f			call forthexec 
1787				;call forthexec_cleanup 
1787			;	call parsenext 
1787			 
1787				STACKFRAMECHK ON $fbfe $8f9f 
1787				if DEBUG_STACK_IMB 
1787					if ON 
1787						exx 
1787						ld hl, $8f9f 
1787						pop de   ; $8f9f 
1787						call cmp16 
1787						jr nz, .spnosame 
1787						ld hl, $fbfe 
1787						pop de   ; $fbfe 
1787						call cmp16 
1787						jr z, .spfrsame 
1787						.spnosame: call showsperror 
1787						.spfrsame: nop 
1787						exx 
1787					endif 
1787				endif 
1787			endm 
# End of macro STACKFRAMECHK
1787				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1787			 
1787 3e 78			ld a, display_row_4 
1789 11 b9 17			ld de, endprog 
178c			 
178c cd de 0b			call update_display		 
178f			 
178f cd 4f 1a			call next_page_prompt 
1792			 
1792				; switch frame buffer to cli 
1792			 
1792 21 a4 ed				ld hl, display_fb0 
1795 22 bf eb				ld (display_fb_active), hl 
1798			 
1798			 
1798 cd bc 0b		        call clear_display 
179b cd de 0b			call update_display		 
179e			 
179e 21 db e5			ld hl, os_cli_cmd 
17a1			 
17a1			;	ld a, 0		 ; init cli input 
17a1 36 00			ld (hl), 0 
17a3			 
17a3				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
17a3			 
17a3				; now on last line 
17a3			 
17a3				; TODO scroll screen up 
17a3			 
17a3				; TODO instead just clear screen and place at top of screen 
17a3			 
17a3			;	ld a, 0 
17a3			;	ld (f_cursor_ptr),a 
17a3			 
17a3				;call clear_display 
17a3				;call update_display 
17a3			 
17a3				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
17a3 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
17a5 c3 4e 17			jp cli 
17a8			 
17a8 .. 00		freeram: db "Free bytes: ",0 
17b5 ..			asc: db "1A2F" 
17b9 .. 00		endprog: db "End prog...",0 
17c5			 
17c5			testenter2:   
17c5 21 e6 e2			ld hl,scratch+50 
17c8 22 d7 e5			ld (os_cur_ptr),hl 
17cb c3 4e 17			jp cli 
17ce			 
17ce			testenter:  
17ce			 
17ce 21 b5 17			ld hl,asc 
17d1			;	ld a,(hl) 
17d1			;	call nibble2val 
17d1 cd 38 10			call get_byte 
17d4			 
17d4			 
17d4			;	ld a,(hl) 
17d4			;	call atohex 
17d4			 
17d4			;	call fourehexhl 
17d4 32 e6 e2			ld (scratch+50),a 
17d7			 
17d7			 
17d7			 
17d7 21 b7 17			ld hl,asc+2 
17da			;	ld a, (hl) 
17da			;	call nibble2val 
17da cd 38 10			call get_byte 
17dd			 
17dd			;	call fourehexhl 
17dd 32 e8 e2			ld (scratch+52),a 
17e0				 
17e0 21 e6 e2			ld hl,scratch+50 
17e3 22 d7 e5			ld (os_cur_ptr),hl 
17e6 c3 4e 17			jp cli 
17e9			 
17e9			enter:	 
17e9 3a b8 e2			ld a,(scratch+4) 
17ec fe 00			cp 0 
17ee 28 0c			jr z, .entercont 
17f0				; no, not a null term line so has an address to work out.... 
17f0			 
17f0 21 b6 e2			ld hl,scratch+2 
17f3 cd 98 10			call get_word_hl 
17f6			 
17f6 22 d7 e5			ld (os_cur_ptr),hl	 
17f9 c3 4e 17			jp cli 
17fc			 
17fc			 
17fc			.entercont:  
17fc			 
17fc 21 b6 e2			ld hl, scratch+2 
17ff cd 38 10			call get_byte 
1802			 
1802 2a d7 e5		   	ld hl,(os_cur_ptr) 
1805 77					ld (hl),a 
1806 23					inc hl 
1807 22 d7 e5				ld (os_cur_ptr),hl 
180a				 
180a			; get byte  
180a			 
180a			 
180a c3 4e 17			jp cli 
180d			 
180d			 
180d			; basic monitor support 
180d			 
180d			monitor: 
180d				;  
180d cd bc 0b			call clear_display 
1810 3e 00			ld a, 0 
1812 11 66 18			ld de, .monprompt 
1815 cd ce 0b			call str_at_display 
1818 cd de 0b			call update_display 
181b			 
181b				; get a monitor command 
181b			 
181b 0e 00			ld c, 0     ; entry at top left 
181d 16 64			ld d, 100   ; max buffer size 
181f 1e 0f			ld e, 15    ; input scroll area 
1821			;	ld a, 0     ; init string 
1821 21 b2 e4			ld hl, os_input 
1824 36 00			ld (hl), 0 
1826 23				inc hl 
1827 36 00			ld (hl), 0 
1829 21 b2 e4			ld hl, os_input 
182c 3e 01			ld a, 1     ; init string 
182e cd 13 0e			call input_str 
1831			 
1831 cd bc 0b		        call clear_display 
1834 cd de 0b			call update_display		 
1837			 
1837 3a b2 e4			ld a, (os_input) 
183a cd 35 11			call toUpper 
183d fe 48		        cp 'H' 
183f ca da 18		        jp z, .monhelp 
1842 fe 44			cp 'D'		; dump 
1844 ca 0d 19			jp z, .mondump	 
1847 fe 43			cp 'C'		; dump 
1849 ca 27 19			jp z, .moncdump	 
184c fe 4d			cp 'M'		; dump 
184e ca 68 18			jp z, .moneditstart 
1851 fe 55			cp 'U'		; dump 
1853 ca 74 18			jp z, .monedit	 
1856 fe 47			cp 'G'		; dump 
1858 ca 03 19			jp z, .monjump 
185b fe 42			cp 'B'		; forth breakpoint 
185d cc 68 14			call z, break_point_state 
1860 fe 51			cp 'Q'		; dump 
1862 c8				ret z	 
1863			 
1863			 
1863				; TODO "S" to access symbol by name and not need the address 
1863				; TODO "F" to find a string in memory 
1863			 
1863 c3 0d 18			jp monitor 
1866			 
1866 .. 00		.monprompt: db ">", 0 
1868			 
1868			.moneditstart: 
1868				; get starting address 
1868			 
1868 21 b4 e4			ld hl,os_input+2 
186b cd 98 10			call get_word_hl 
186e			 
186e 22 d7 e5			ld (os_cur_ptr),hl	 
1871			 
1871 c3 0d 18			jp monitor 
1874			 
1874			.monedit: 
1874				; get byte to load 
1874			 
1874 21 b4 e4			ld hl,os_input+2 
1877 cd 38 10			call get_byte 
187a			 
187a				; get address to update 
187a 2a d7 e5			ld hl, (os_cur_ptr) 
187d			 
187d				; update byte 
187d			 
187d 77				ld (hl), a 
187e			 
187e				; move to next address and save it 
187e			 
187e 23				inc hl 
187f 22 d7 e5			ld (os_cur_ptr),hl	 
1882			 
1882 c3 0d 18			jp monitor 
1885			 
1885			 
1885 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1899 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
18b5 .. 00		.monhelptext3:  db "G-Call address, B-Breakpoints",0 
18d3 .. 00		.monhelptext4:  db "Q-Quit",0 
18da			        
18da			.monhelp: 
18da 3e 00			ld a, display_row_1 
18dc 11 85 18		        ld de, .monhelptext1 
18df			 
18df cd ce 0b			call str_at_display 
18e2 3e 28			ld a, display_row_2 
18e4 11 99 18		        ld de, .monhelptext2 
18e7					 
18e7 cd ce 0b			call str_at_display 
18ea 3e 50			ld a, display_row_3 
18ec 11 b5 18		        ld de, .monhelptext3 
18ef					 
18ef cd ce 0b			call str_at_display 
18f2 3e 78			ld a, display_row_4 
18f4 11 d3 18		        ld de, .monhelptext4 
18f7 cd ce 0b			call str_at_display 
18fa			 
18fa cd de 0b			call update_display		 
18fd			 
18fd cd 4f 1a			call next_page_prompt 
1900 c3 0d 18			jp monitor 
1903			 
1903			.monjump:    
1903 21 b4 e4			ld hl,os_input+2 
1906 cd 98 10			call get_word_hl 
1909			 
1909 e9				jp (hl) 
190a c3 0d 18			jp monitor 
190d			 
190d			.mondump:    
190d 21 b4 e4			ld hl,os_input+2 
1910 cd 98 10			call get_word_hl 
1913			 
1913 22 d7 e5			ld (os_cur_ptr),hl	 
1916 cd 5b 19			call dumpcont 
1919 3e 78			ld a, display_row_4 
191b 11 b9 17			ld de, endprog 
191e			 
191e cd de 0b			call update_display		 
1921			 
1921 cd 4f 1a			call next_page_prompt 
1924 c3 0d 18			jp monitor 
1927			.moncdump: 
1927 cd 5b 19			call dumpcont 
192a 3e 78			ld a, display_row_4 
192c 11 b9 17			ld de, endprog 
192f			 
192f cd de 0b			call update_display		 
1932			 
1932 cd 4f 1a			call next_page_prompt 
1935 c3 0d 18			jp monitor 
1938			 
1938			 
1938			; TODO symbol access  
1938			 
1938			.symbols:     ;; A list of symbols that can be called up  
1938 a4 ed			dw display_fb0 
193a .. 00			db "fb0",0  
193e 6d ea		     	dw store_page 
1940 .. 00			db "store_page",0 
194b			 
194b			 
194b			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
194b			 
194b 3a b5 e2			ld a,(scratch+1) 
194e fe 00			cp 0 
1950 28 09			jr z, dumpcont 
1952			 
1952				; no, not a null term line so has an address to work out.... 
1952			 
1952 21 b6 e2			ld hl,scratch+2 
1955 cd 98 10			call get_word_hl 
1958			 
1958 22 d7 e5			ld (os_cur_ptr),hl	 
195b			 
195b			 
195b			 
195b			dumpcont: 
195b			 
195b				; dump bytes at ptr 
195b			 
195b			 
195b 3e 00			ld a, display_row_1 
195d 2a bf eb			ld hl, (display_fb_active) 
1960 cd e6 0d			call addatohl 
1963 cd 8b 19			call .dumpbyterow 
1966			 
1966 3e 28			ld a, display_row_2 
1968 2a bf eb			ld hl, (display_fb_active) 
196b cd e6 0d			call addatohl 
196e cd 8b 19			call .dumpbyterow 
1971			 
1971			 
1971 3e 50			ld a, display_row_3 
1973 2a bf eb			ld hl, (display_fb_active) 
1976 cd e6 0d			call addatohl 
1979 cd 8b 19			call .dumpbyterow 
197c			 
197c 3e 78			ld a, display_row_4 
197e 2a bf eb			ld hl, (display_fb_active) 
1981 cd e6 0d			call addatohl 
1984 cd 8b 19			call .dumpbyterow 
1987			 
1987 cd de 0b			call update_display 
198a			;		jp cli 
198a c9				ret 
198b			 
198b			.dumpbyterow: 
198b			 
198b				;push af 
198b			 
198b e5				push hl 
198c			 
198c				; calc where to poke the ascii 
198c			if display_cols == 20 
198c				ld a, 16 
198c			else 
198c 3e 1f			ld a, 31 
198e			endif 
198e			 
198e cd e6 0d			call addatohl 
1991 22 b9 e5			ld (os_word_scratch),hl  		; save pos for later 
1994			 
1994			 
1994			; display decoding address 
1994 2a d7 e5		   	ld hl,(os_cur_ptr) 
1997			 
1997 7c				ld a,h 
1998 e1				pop hl 
1999 e5				push hl 
199a			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
199a cd e2 0f			call hexout 
199d 2a d7 e5		   	ld hl,(os_cur_ptr) 
19a0			 
19a0 7d				ld a,l 
19a1 e1				pop hl 
19a2 23				inc hl 
19a3 23				inc hl 
19a4 e5				push hl 
19a5			;	ld hl, os_word_scratch+2 
19a5 cd e2 0f			call hexout 
19a8 e1				pop hl 
19a9 23				inc hl 
19aa 23				inc hl 
19ab				;ld hl, os_word_scratch+4 
19ab			;	ld a, ':' 
19ab 36 3a			ld (hl),':' 
19ad 23				inc hl 
19ae				;ld a, 0 
19ae				;ld (hl),a 
19ae				;ld de, os_word_scratch 
19ae				;pop af 
19ae				;push af 
19ae			;		ld a, display_row_2 
19ae			;		call str_at_display 
19ae			;		call update_display 
19ae			 
19ae			 
19ae			;pop af 
19ae			;	add 5 
19ae			 
19ae			if display_cols == 20 
19ae				ld b, 4 
19ae			else 
19ae 06 08			ld b, 8 
19b0			endif	 
19b0			 
19b0			.dumpbyte: 
19b0 c5				push bc 
19b1 e5				push hl 
19b2			 
19b2			 
19b2 2a d7 e5		   	ld hl,(os_cur_ptr) 
19b5 7e					ld a,(hl) 
19b6			 
19b6					; poke the ascii to display 
19b6 2a b9 e5				ld hl,(os_word_scratch) 
19b9 77					ld (hl),a 
19ba 23					inc hl 
19bb 22 b9 e5				ld (os_word_scratch),hl 
19be			 
19be					 
19be			 
19be			 
19be e1					pop hl 
19bf e5					push hl 
19c0			 
19c0 cd e2 0f				call hexout 
19c3			 
19c3					 
19c3 2a d7 e5		   	ld hl,(os_cur_ptr) 
19c6 23				inc hl 
19c7 22 d7 e5		   	ld (os_cur_ptr),hl 
19ca			 
19ca e1					pop hl 
19cb 23					inc hl 
19cc 23					inc hl 
19cd 23					inc hl 
19ce			 
19ce			 
19ce			 
19ce					;ld a,0 
19ce					;ld (os_word_scratch+2),a 
19ce					;pop af 
19ce					;push af 
19ce			 
19ce					;ld de, os_word_scratch 
19ce					;call str_at_display 
19ce			;		call update_display 
19ce			;		pop af 
19ce c1					pop bc 
19cf c6 03				add 3 
19d1 10 dd			djnz .dumpbyte 
19d3			 
19d3				 
19d3			 
19d3 c9				ret 
19d4			 
19d4			jump:	 
19d4			 
19d4 21 b6 e2			ld hl,scratch+2 
19d7 cd 98 10			call get_word_hl 
19da				;ld hl,(scratch+2) 
19da				;call fourehexhl 
19da			 
19da 22 d7 e5			ld (os_cur_ptr),hl	 
19dd			 
19dd e9				jp (hl) 
19de			 
19de			 
19de			 
19de			; TODO implement a basic monitor mode to start with 
19de			 
19de			 
19de			 
19de			 
19de			 
19de			 
19de			 
19de			 
19de			 
19de			; testing and demo code during development 
19de			 
19de			 
19de .. 00		str1: db "Enter some text...",0 
19f1 .. 00		clear: db "                    ",0 
1a06			 
1a06			demo: 
1a06			 
1a06			 
1a06			 
1a06			;	call update_display 
1a06			 
1a06				; init scratch input area for testing 
1a06 21 b4 e2			ld hl, scratch	 
1a09			;	ld a,0 
1a09 36 00			ld (hl),0 
1a0b			 
1a0b			 
1a0b 3e 28		            LD   A, display_row_2 
1a0d			;            CALL fLCD_Pos       ;Position cursor to location in A 
1a0d 11 de 19		            LD   DE, str1 
1a10 cd ce 0b			call str_at_display 
1a13			 
1a13			;            CALL fLCD_Str       ;Display string pointed to by DE 
1a13			cloop:	 
1a13 3e 50		            LD   A, display_row_3 
1a15			;            CALL fLCD_Pos       ;Position cursor to location in A 
1a15 11 f1 19		            LD   DE, clear 
1a18			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1a18 cd ce 0b				call str_at_display 
1a1b 3e 78			ld a, display_row_4 
1a1d 11 4b 1a			ld de, prompt 
1a20			 
1a20 cd ce 0b				call str_at_display 
1a23 cd de 0b			call update_display 
1a26			 
1a26 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1a28 16 0a			ld d, 10 
1a2a 21 b4 e2			ld hl, scratch	 
1a2d cd 13 0e			call input_str 
1a30			 
1a30			;	call clear_display 
1a30			;'	call update_display 
1a30			 
1a30 3e 00		            LD   A, display_row_1 
1a32			;            CALL fLCD_Pos       ;Position cursor to location in A 
1a32 11 f1 19		            LD   DE, clear 
1a35 cd ce 0b				call str_at_display 
1a38			;            CALL fLCD_Str       ;Display string pointed to by DE 
1a38 3e 00		            LD   A, display_row_1 
1a3a			;            CALL fLCD_Pos       ;Position cursor to location in A 
1a3a 11 b4 e2		            LD   DE, scratch 
1a3d			;            CALL fLCD_Str       ;Display string pointed to by DE 
1a3d cd ce 0b				call str_at_display 
1a40 cd de 0b			call update_display 
1a43			 
1a43			;		ld a,0 
1a43 21 b4 e2			ld hl, scratch 
1a46 36 00			ld (hl),0 
1a48			 
1a48			;	nop 
1a48 c3 13 1a			jp cloop 
1a4b			 
1a4b			 
1a4b			 
1a4b			; OS Prompt 
1a4b			 
1a4b .. 00		prompt: db ">",0 
1a4d .. 00		endprg: db "?",0 
1a4f			 
1a4f			 
1a4f			; handy next page prompt 
1a4f			next_page_prompt: 
1a4f e5				push hl 
1a50 d5				push de 
1a51 f5				push af 
1a52 c5				push bc 
1a53			 
1a53 3e 9f			ld a,display_row_4 + display_cols - 1 
1a55 11 4d 1a		        ld de, endprg 
1a58 cd ce 0b			call str_at_display 
1a5b cd de 0b			call update_display 
1a5e cd 7e 67			call cin_wait 
1a61 c1				pop bc 
1a62 f1				pop af 
1a63 d1				pop de 
1a64 e1				pop hl 
1a65			 
1a65			 
1a65 c9				ret 
1a66			 
1a66			 
1a66			; forth parser 
1a66			 
1a66			; My forth kernel 
1a66			include "forth_kernel.asm" 
1a66			; 
1a66			; kernel to the forth OS 
1a66			 
1a66			DS_TYPE_STR: equ 1     ; string type 
1a66			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1a66			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1a66			DS_TYPE_CONST: equ 4     ; string type that won't be freed on a POP 
1a66			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1a66			 
1a66			FORTH_PARSEV1: equ 0 
1a66			FORTH_PARSEV2: equ 0 
1a66			FORTH_PARSEV3: equ 0 
1a66			FORTH_PARSEV4: equ 0 
1a66			FORTH_PARSEV5: equ 0 
1a66			FORTH_PARSEV6: equ 1 
1a66			 
1a66			;if FORTH_PARSEV5 
1a66			;	FORTH_END_BUFFER: equ 0 
1a66			;else 
1a66			FORTH_END_BUFFER: equ 127 
1a66			;endif 
1a66			 
1a66			FORTH_TRUE: equ 1 
1a66			FORTH_FALSE: equ 0 
1a66			 
1a66			if FORTH_PARSEV4 
1a66			include "forth_stackops.asm" 
1a66			endif 
1a66			 
1a66			if FORTH_PARSEV5 
1a66			include "forth_stackopsv5.asm" 
1a66			endif 
1a66			 
1a66			if FORTH_PARSEV6 
1a66			include "forth_stackopsv5.asm" 
1a66			 
1a66			; Stack operations for v5 parser on wards 
1a66			; * DATA stack 
1a66			; * LOOP stack 
1a66			; * RETURN stack 
1a66			 
1a66			 
1a66			 
1a66			FORTH_CHK_DSP_UNDER: macro 
1a66				push hl 
1a66				push de 
1a66				ld hl,(cli_data_sp) 
1a66				ld de, cli_data_stack 
1a66				call cmp16 
1a66				jp c, fault_dsp_under 
1a66				pop de 
1a66				pop hl 
1a66				endm 
1a66			 
1a66			 
1a66			FORTH_CHK_RSP_UNDER: macro 
1a66				push hl 
1a66				push de 
1a66				ld hl,(cli_ret_sp) 
1a66				ld de, cli_ret_stack 
1a66				call cmp16 
1a66				jp c, fault_rsp_under 
1a66				pop de 
1a66				pop hl 
1a66				endm 
1a66			 
1a66			FORTH_CHK_LOOP_UNDER: macro 
1a66				push hl 
1a66				push de 
1a66				ld hl,(cli_loop_sp) 
1a66				ld de, cli_loop_stack 
1a66				call cmp16 
1a66				jp c, fault_loop_under 
1a66				pop de 
1a66				pop hl 
1a66				endm 
1a66			 
1a66			FORTH_ERR_TOS_NOTSTR: macro 
1a66				; TOSO might need more for checks when used 
1a66				push af 
1a66				ld a,(hl) 
1a66				cp DS_TYPE_STR 
1a66				jp nz, type_faultn   
1a66				pop af 
1a66				endm 
1a66			 
1a66			FORTH_ERR_TOS_NOTNUM: macro 
1a66				push af 
1a66				ld a,(hl) 
1a66				cp DS_TYPE_INUM 
1a66				jp nz, type_faultn   
1a66				pop af 
1a66				endm 
1a66			 
1a66			 
1a66			; increase data stack pointer and save hl to it 
1a66				 
1a66			FORTH_DSP_NEXT: macro 
1a66				call macro_forth_dsp_next 
1a66				endm 
1a66			 
1a66			 
1a66			macro_forth_dsp_next: 
1a66				if DEBUG_FORTH_STACK_GUARD 
1a66 cd 9b 63				call check_stacks 
1a69				endif 
1a69 e5				push hl 
1a6a d5				push de 
1a6b eb				ex de,hl 
1a6c 2a e1 e9			ld hl,(cli_data_sp) 
1a6f 23				inc hl 
1a70 23				inc hl 
1a71			 
1a71			; PARSEV5 
1a71 23				inc hl 
1a72 22 e1 e9			ld (cli_data_sp),hl 
1a75 73				ld (hl), e 
1a76 23				inc hl 
1a77 72				ld (hl), d 
1a78 d1				pop de 
1a79 e1				pop hl 
1a7a				if DEBUG_FORTH_STACK_GUARD 
1a7a cd 9b 63				call check_stacks 
1a7d				endif 
1a7d c9				ret 
1a7e			 
1a7e			 
1a7e			; increase ret stack pointer and save hl to it 
1a7e				 
1a7e			FORTH_RSP_NEXT: macro 
1a7e				call macro_forth_rsp_next 
1a7e				endm 
1a7e			 
1a7e			macro_forth_rsp_next: 
1a7e				if DEBUG_FORTH_STACK_GUARD 
1a7e cd 9b 63				call check_stacks 
1a81				endif 
1a81 e5				push hl 
1a82 d5				push de 
1a83 eb				ex de,hl 
1a84 2a e5 e9			ld hl,(cli_ret_sp) 
1a87 23				inc hl 
1a88 23				inc hl 
1a89 22 e5 e9			ld (cli_ret_sp),hl 
1a8c 73				ld (hl), e 
1a8d 23				inc hl 
1a8e 72				ld (hl), d 
1a8f d1				pop de 
1a90 e1				pop hl 
1a91				if DEBUG_FORTH_STACK_GUARD 
1a91 cd 9b 63				call check_stacks 
1a94				endif 
1a94 c9				ret 
1a95			 
1a95			; get current ret stack pointer and save to hl  
1a95				 
1a95			FORTH_RSP_TOS: macro 
1a95				call macro_forth_rsp_tos 
1a95				endm 
1a95			 
1a95			macro_forth_rsp_tos: 
1a95				;push de 
1a95 2a e5 e9			ld hl,(cli_ret_sp) 
1a98 cd d0 1a			call loadhlptrtohl 
1a9b				;ld e, (hl) 
1a9b				;inc hl 
1a9b				;ld d, (hl) 
1a9b				;ex de, hl 
1a9b					if DEBUG_FORTH_WORDS 
1a9b			;			DMARK "RST" 
1a9b						CALLMONITOR 
1a9b cd 6b ee			call debug_vector  
1a9e				endm  
# End of macro CALLMONITOR
1a9e					endif 
1a9e				;pop de 
1a9e c9				ret 
1a9f			 
1a9f			; pop ret stack pointer 
1a9f				 
1a9f			FORTH_RSP_POP: macro 
1a9f				call macro_forth_rsp_pop 
1a9f				endm 
1a9f			 
1a9f			 
1a9f			macro_forth_rsp_pop: 
1a9f				if DEBUG_FORTH_STACK_GUARD 
1a9f			;		DMARK "RPP" 
1a9f cd 9b 63				call check_stacks 
1aa2					FORTH_CHK_RSP_UNDER 
1aa2 e5				push hl 
1aa3 d5				push de 
1aa4 2a e5 e9			ld hl,(cli_ret_sp) 
1aa7 11 9f e9			ld de, cli_ret_stack 
1aaa cd 04 0e			call cmp16 
1aad da b2 64			jp c, fault_rsp_under 
1ab0 d1				pop de 
1ab1 e1				pop hl 
1ab2				endm 
# End of macro FORTH_CHK_RSP_UNDER
1ab2				endif 
1ab2 e5				push hl 
1ab3 2a e5 e9			ld hl,(cli_ret_sp) 
1ab6			 
1ab6			 
1ab6				if FORTH_ENABLE_FREE 
1ab6			 
1ab6					; get pointer 
1ab6			 
1ab6					push de 
1ab6					push hl 
1ab6			 
1ab6					ld e, (hl) 
1ab6					inc hl 
1ab6					ld d, (hl) 
1ab6			 
1ab6					ex de, hl 
1ab6					call free 
1ab6			 
1ab6					pop hl 
1ab6					pop de 
1ab6			 
1ab6			 
1ab6				endif 
1ab6			 
1ab6			 
1ab6 2b				dec hl 
1ab7 2b				dec hl 
1ab8 22 e5 e9			ld (cli_ret_sp), hl 
1abb				; do stack underflow checks 
1abb e1				pop hl 
1abc				if DEBUG_FORTH_STACK_GUARD 
1abc cd 9b 63				call check_stacks 
1abf					FORTH_CHK_RSP_UNDER 
1abf e5				push hl 
1ac0 d5				push de 
1ac1 2a e5 e9			ld hl,(cli_ret_sp) 
1ac4 11 9f e9			ld de, cli_ret_stack 
1ac7 cd 04 0e			call cmp16 
1aca da b2 64			jp c, fault_rsp_under 
1acd d1				pop de 
1ace e1				pop hl 
1acf				endm 
# End of macro FORTH_CHK_RSP_UNDER
1acf				endif 
1acf c9				ret 
1ad0			 
1ad0			 
1ad0			 
1ad0			; routine to load word pointed to by hl into hl 
1ad0			 
1ad0			loadhlptrtohl: 
1ad0			 
1ad0 d5				push de 
1ad1 5e				ld e, (hl) 
1ad2 23				inc hl 
1ad3 56				ld d, (hl) 
1ad4 eb				ex de, hl 
1ad5 d1				pop de 
1ad6			 
1ad6 c9				ret 
1ad7			 
1ad7			 
1ad7			 
1ad7			 
1ad7			 
1ad7			; push a number held in HL onto the data stack 
1ad7			; entry point for pushing a value when already in hl used in function above 
1ad7			 
1ad7			forth_push_numhl: 
1ad7			 
1ad7 e5				push hl    ; save value to push 
1ad8			 
1ad8			if DEBUG_FORTH_PUSH 
1ad8				; see if disabled 
1ad8			 
1ad8			 
1ad8 f5				push af 
1ad9 3a 6b ee			ld a,(debug_vector) 
1adc fe c9			cp $c9   ; ret 
1ade			;	ld a, (os_view_disable) 
1ade			;	cp '*' 
1ade 28 33			jr z, .pskip2 
1ae0 e5				push hl 
1ae1 e5			push hl 
1ae2 cd bc 0b			call clear_display 
1ae5 e1			pop hl 
1ae6 7c				ld a,h 
1ae7 21 b9 e5			ld hl, os_word_scratch 
1aea cd e2 0f			call hexout 
1aed e1				pop hl 
1aee 7d				ld a,l 
1aef 21 bb e5			ld hl, os_word_scratch+2 
1af2 cd e2 0f			call hexout 
1af5			 
1af5 21 bd e5			ld hl, os_word_scratch+4 
1af8			;	ld a,0 
1af8 36 00			ld (hl),0 
1afa 11 b9 e5			ld de,os_word_scratch 
1afd 3e 28				ld a, display_row_2 
1aff cd ce 0b				call str_at_display 
1b02 11 fc 53			ld de, .push_num 
1b05 3e 00			ld a, display_row_1 
1b07			 
1b07 cd ce 0b				call str_at_display 
1b0a			 
1b0a			 
1b0a cd de 0b			call update_display 
1b0d cd f0 0a			call delay1s 
1b10 cd f0 0a			call delay1s 
1b13			.pskip2:  
1b13			 
1b13 f1				pop af 
1b14			endif	 
1b14			 
1b14			 
1b14				FORTH_DSP_NEXT 
1b14 cd 66 1a			call macro_forth_dsp_next 
1b17				endm 
# End of macro FORTH_DSP_NEXT
1b17			 
1b17 2a e1 e9			ld hl, (cli_data_sp) 
1b1a			 
1b1a				; save item type 
1b1a			;	ld a,  DS_TYPE_INUM 
1b1a 36 02			ld (hl), DS_TYPE_INUM 
1b1c 23				inc hl 
1b1d			 
1b1d				; get word off stack 
1b1d d1				pop de 
1b1e				;ld a,e 
1b1e 73				ld (hl), e 
1b1f 23				inc hl 
1b20			;	ld a,d 
1b20 72				ld (hl), d 
1b21			 
1b21			if DEBUG_FORTH_PUSH 
1b21 2b				dec hl 
1b22 2b				dec hl 
1b23 2b				dec hl 
1b24						DMARK "PH5" 
1b24 f5				push af  
1b25 3a 39 1b			ld a, (.dmark)  
1b28 32 5e ee			ld (debug_mark),a  
1b2b 3a 3a 1b			ld a, (.dmark+1)  
1b2e 32 5f ee			ld (debug_mark+1),a  
1b31 3a 3b 1b			ld a, (.dmark+2)  
1b34 32 60 ee			ld (debug_mark+2),a  
1b37 18 03			jr .pastdmark  
1b39 ..			.dmark: db "PH5"  
1b3c f1			.pastdmark: pop af  
1b3d			endm  
# End of macro DMARK
1b3d				CALLMONITOR 
1b3d cd 6b ee			call debug_vector  
1b40				endm  
# End of macro CALLMONITOR
1b40			endif	 
1b40			 
1b40 c9				ret 
1b41			 
1b41			 
1b41			; Push a string to stack pointed to by hl 
1b41			 
1b41			forth_push_str: 
1b41			 
1b41			if DEBUG_FORTH_PUSH 
1b41						DMARK "PSQ" 
1b41 f5				push af  
1b42 3a 56 1b			ld a, (.dmark)  
1b45 32 5e ee			ld (debug_mark),a  
1b48 3a 57 1b			ld a, (.dmark+1)  
1b4b 32 5f ee			ld (debug_mark+1),a  
1b4e 3a 58 1b			ld a, (.dmark+2)  
1b51 32 60 ee			ld (debug_mark+2),a  
1b54 18 03			jr .pastdmark  
1b56 ..			.dmark: db "PSQ"  
1b59 f1			.pastdmark: pop af  
1b5a			endm  
# End of macro DMARK
1b5a				CALLMONITOR 
1b5a cd 6b ee			call debug_vector  
1b5d				endm  
# End of macro CALLMONITOR
1b5d			endif	 
1b5d			 
1b5d			 
1b5d			    
1b5d e5				push hl 
1b5e e5				push hl 
1b5f			 
1b5f			;	ld a, 0   ; find end of string 
1b5f cd 3e 11			call strlenz 
1b62			if DEBUG_FORTH_PUSH 
1b62						DMARK "PQ2" 
1b62 f5				push af  
1b63 3a 77 1b			ld a, (.dmark)  
1b66 32 5e ee			ld (debug_mark),a  
1b69 3a 78 1b			ld a, (.dmark+1)  
1b6c 32 5f ee			ld (debug_mark+1),a  
1b6f 3a 79 1b			ld a, (.dmark+2)  
1b72 32 60 ee			ld (debug_mark+2),a  
1b75 18 03			jr .pastdmark  
1b77 ..			.dmark: db "PQ2"  
1b7a f1			.pastdmark: pop af  
1b7b			endm  
# End of macro DMARK
1b7b				CALLMONITOR 
1b7b cd 6b ee			call debug_vector  
1b7e				endm  
# End of macro CALLMONITOR
1b7e			endif	 
1b7e eb				ex de, hl 
1b7f e1				pop hl   ; get ptr to start of string 
1b80			if DEBUG_FORTH_PUSH 
1b80						DMARK "PQ3" 
1b80 f5				push af  
1b81 3a 95 1b			ld a, (.dmark)  
1b84 32 5e ee			ld (debug_mark),a  
1b87 3a 96 1b			ld a, (.dmark+1)  
1b8a 32 5f ee			ld (debug_mark+1),a  
1b8d 3a 97 1b			ld a, (.dmark+2)  
1b90 32 60 ee			ld (debug_mark+2),a  
1b93 18 03			jr .pastdmark  
1b95 ..			.dmark: db "PQ3"  
1b98 f1			.pastdmark: pop af  
1b99			endm  
# End of macro DMARK
1b99				CALLMONITOR 
1b99 cd 6b ee			call debug_vector  
1b9c				endm  
# End of macro CALLMONITOR
1b9c			endif	 
1b9c 19				add hl,de 
1b9d			if DEBUG_FORTH_PUSH 
1b9d						DMARK "PQE" 
1b9d f5				push af  
1b9e 3a b2 1b			ld a, (.dmark)  
1ba1 32 5e ee			ld (debug_mark),a  
1ba4 3a b3 1b			ld a, (.dmark+1)  
1ba7 32 5f ee			ld (debug_mark+1),a  
1baa 3a b4 1b			ld a, (.dmark+2)  
1bad 32 60 ee			ld (debug_mark+2),a  
1bb0 18 03			jr .pastdmark  
1bb2 ..			.dmark: db "PQE"  
1bb5 f1			.pastdmark: pop af  
1bb6			endm  
# End of macro DMARK
1bb6				CALLMONITOR 
1bb6 cd 6b ee			call debug_vector  
1bb9				endm  
# End of macro CALLMONITOR
1bb9			endif	 
1bb9			 
1bb9 2b				dec hl    ; see if there is an optional trailing double quote 
1bba 7e				ld a,(hl) 
1bbb fe 22			cp '"' 
1bbd 20 02			jr nz, .strnoq 
1bbf			;	ld a, 0      ; get rid of double quote 
1bbf 36 00			ld (hl), 0 
1bc1 23			.strnoq: inc hl 
1bc2			 
1bc2			;	ld a, 0 
1bc2 36 00			ld (hl), 0     ; add null term and get rid of trailing double quote 
1bc4			 
1bc4 13				inc de ; add one for the type string 
1bc5 13				inc de ; add one for null term??? 
1bc6			 
1bc6				; tos is get string pointer again 
1bc6				; de contains space to allocate 
1bc6				 
1bc6 d5				push de 
1bc7			 
1bc7 eb				ex de, hl 
1bc8			 
1bc8				;push af 
1bc8			 
1bc8			if DEBUG_FORTH_PUSH 
1bc8						DMARK "PHm" 
1bc8 f5				push af  
1bc9 3a dd 1b			ld a, (.dmark)  
1bcc 32 5e ee			ld (debug_mark),a  
1bcf 3a de 1b			ld a, (.dmark+1)  
1bd2 32 5f ee			ld (debug_mark+1),a  
1bd5 3a df 1b			ld a, (.dmark+2)  
1bd8 32 60 ee			ld (debug_mark+2),a  
1bdb 18 03			jr .pastdmark  
1bdd ..			.dmark: db "PHm"  
1be0 f1			.pastdmark: pop af  
1be1			endm  
# End of macro DMARK
1be1				CALLMONITOR 
1be1 cd 6b ee			call debug_vector  
1be4				endm  
# End of macro CALLMONITOR
1be4			endif	 
1be4 cd b2 11			call malloc	; on ret hl now contains allocated memory 
1be7				if DEBUG_FORTH_MALLOC_GUARD 
1be7 cc 54 54				call z,malloc_error 
1bea				endif 
1bea			 
1bea				 
1bea c1				pop bc    ; get length 
1beb d1				pop de   ;  get string start    
1bec			 
1bec				; hl has destination from malloc 
1bec			 
1bec eb				ex de, hl    ; prep for ldir 
1bed			 
1bed d5				push de   ; save malloc area for DSP later 
1bee				;push hl   ; save malloc area for DSP later 
1bee			 
1bee			if DEBUG_FORTH_PUSH 
1bee						DMARK "PHc" 
1bee f5				push af  
1bef 3a 03 1c			ld a, (.dmark)  
1bf2 32 5e ee			ld (debug_mark),a  
1bf5 3a 04 1c			ld a, (.dmark+1)  
1bf8 32 5f ee			ld (debug_mark+1),a  
1bfb 3a 05 1c			ld a, (.dmark+2)  
1bfe 32 60 ee			ld (debug_mark+2),a  
1c01 18 03			jr .pastdmark  
1c03 ..			.dmark: db "PHc"  
1c06 f1			.pastdmark: pop af  
1c07			endm  
# End of macro DMARK
1c07				CALLMONITOR 
1c07 cd 6b ee			call debug_vector  
1c0a				endm  
# End of macro CALLMONITOR
1c0a			endif	 
1c0a			 
1c0a			 
1c0a ed b0			ldir 
1c0c			 
1c0c			 
1c0c				; push malloc to data stack     macro?????  
1c0c			 
1c0c				FORTH_DSP_NEXT 
1c0c cd 66 1a			call macro_forth_dsp_next 
1c0f				endm 
# End of macro FORTH_DSP_NEXT
1c0f			 
1c0f				; save value and type 
1c0f			 
1c0f 2a e1 e9			ld hl, (cli_data_sp) 
1c12			 
1c12				; save item type 
1c12			;	ld a,  DS_TYPE_STR 
1c12 36 01			ld (hl), DS_TYPE_STR 
1c14 23				inc hl 
1c15			 
1c15				; get malloc word off stack 
1c15 d1				pop de 
1c16 73				ld (hl), e 
1c17 23				inc hl 
1c18 72				ld (hl), d 
1c19			 
1c19			 
1c19			 
1c19			if DEBUG_FORTH_PUSH 
1c19 2a e1 e9			ld hl, (cli_data_sp) 
1c1c						DMARK "PHS" 
1c1c f5				push af  
1c1d 3a 31 1c			ld a, (.dmark)  
1c20 32 5e ee			ld (debug_mark),a  
1c23 3a 32 1c			ld a, (.dmark+1)  
1c26 32 5f ee			ld (debug_mark+1),a  
1c29 3a 33 1c			ld a, (.dmark+2)  
1c2c 32 60 ee			ld (debug_mark+2),a  
1c2f 18 03			jr .pastdmark  
1c31 ..			.dmark: db "PHS"  
1c34 f1			.pastdmark: pop af  
1c35			endm  
# End of macro DMARK
1c35				CALLMONITOR 
1c35 cd 6b ee			call debug_vector  
1c38				endm  
# End of macro CALLMONITOR
1c38			;	ex de,hl 
1c38			endif	 
1c38				; in case of spaces, skip the ptr past the copied string 
1c38				;pop af 
1c38				;ld (cli_origptr),hl 
1c38			 
1c38 c9				ret 
1c39			 
1c39			 
1c39			 
1c39			; TODO ascii push input onto stack given hl to start of input 
1c39			 
1c39			; identify type 
1c39			; if starts with a " then a string 
1c39			; otherwise it is a number 
1c39			;  
1c39			; if a string 
1c39			;     scan for ending " to get length of string to malloc for + 1 
1c39			;     malloc 
1c39			;     put pointer to string on stack first byte flags as string 
1c39			; 
1c39			; else a number 
1c39			;    look for number format identifier 
1c39			;    $xx hex 
1c39			;    %xxxxx bin 
1c39			;    xxxxx decimal 
1c39			;    convert number to 16bit word.  
1c39			;    malloc word + 1 with flag to identiy as num 
1c39			;    put pointer to number on stack 
1c39			;   
1c39			;  
1c39			  
1c39			forth_apush: 
1c39				; kernel push 
1c39			 
1c39			if DEBUG_FORTH_PUSH 
1c39						DMARK "PSH" 
1c39 f5				push af  
1c3a 3a 4e 1c			ld a, (.dmark)  
1c3d 32 5e ee			ld (debug_mark),a  
1c40 3a 4f 1c			ld a, (.dmark+1)  
1c43 32 5f ee			ld (debug_mark+1),a  
1c46 3a 50 1c			ld a, (.dmark+2)  
1c49 32 60 ee			ld (debug_mark+2),a  
1c4c 18 03			jr .pastdmark  
1c4e ..			.dmark: db "PSH"  
1c51 f1			.pastdmark: pop af  
1c52			endm  
# End of macro DMARK
1c52				CALLMONITOR 
1c52 cd 6b ee			call debug_vector  
1c55				endm  
# End of macro CALLMONITOR
1c55			endif	 
1c55				; identify input type 
1c55			 
1c55 7e				ld a,(hl) 
1c56			 
1c56 fe 23			cp '#' 
1c58 ca 90 1c			jp z, .fapdec 
1c5b			 
1c5b			 
1c5b fe 22			cp '"' 
1c5d 28 0a			jr z, .fapstr 
1c5f fe 24			cp '$' 
1c61 ca 88 1c			jp z, .faphex 
1c64 fe 25			cp '%' 
1c66 ca 71 1c			jp z, .fapbin 
1c69			;	cp 'b' 
1c69			;	jp z, .fabin 
1c69				; else decimal 
1c69			 
1c69				; TODO do decimal conversion 
1c69				; decimal is stored as a 16bit word 
1c69			 
1c69				; by default everything is a string if type is not detected 
1c69			.fapstr: ; 
1c69 fe 22			cp '"' 
1c6b 20 01			jr nz, .strnoqu 
1c6d 23				inc hl 
1c6e			.strnoqu: 
1c6e c3 41 1b			jp forth_push_str 
1c71			 
1c71			 
1c71			 
1c71			.fapbin:    ; push a binary string.  
1c71 11 00 00			ld de, 0   ; hold a 16bit value 
1c74			 
1c74 23			.fapbinshift:	inc hl  
1c75 7e				ld a,(hl) 
1c76			;	cp 0     ; done scanning  
1c76 b7				or a 
1c77 28 0b			jr z, .fapbdone  	; got it in HL so push  
1c79			 
1c79				; left shift de 
1c79 eb				ex de, hl	 
1c7a 29				add hl, hl 
1c7b			 
1c7b				; is 1 
1c7b fe 31			cp '1' 
1c7d 20 02			jr nz, .binzero 
1c7f cb 4d			bit 1, l 
1c81			.binzero: 
1c81 eb				ex de, hl	 ; save current de 
1c82 18 f0			jr .fapbinshift 
1c84			 
1c84			.fapbdone: 
1c84 eb				ex de, hl 
1c85 c3 d7 1a			jp forth_push_numhl 
1c88			 
1c88			 
1c88			.faphex:   ; hex is always stored as a 16bit word 
1c88				; skip number prefix 
1c88 23				inc hl 
1c89				; turn ascii into number 
1c89 cd 98 10			call get_word_hl	; ret 16bit word in hl 
1c8c			 
1c8c c3 d7 1a			jp forth_push_numhl 
1c8f			 
1c8f			;	 nop 
1c8f			 
1c8f			.fabin:   ; TODO bin conversion 
1c8f			 
1c8f			 
1c8f c9				ret 
1c90			.fapdec:	 
1c90				; string to dec conversion 
1c90 23				inc hl 
1c91 eb				ex de, hl 
1c92 cd d5 10			call string_to_uint16 
1c95 c3 d7 1a			jp forth_push_numhl 
1c98 c9				ret 
1c99				 
1c99			;atoui_16: 
1c99			 
1c99			; get either a string ptr or a 16bit word from the data stack 
1c99			 
1c99			FORTH_DSP: macro 
1c99				call macro_forth_dsp 
1c99				endm 
1c99			 
1c99			macro_forth_dsp: 
1c99				; data stack pointer points to current word on tos 
1c99			 
1c99 2a e1 e9			ld hl,(cli_data_sp) 
1c9c			 
1c9c				if DEBUG_FORTH_PUSH 
1c9c						DMARK "DSP" 
1c9c f5				push af  
1c9d 3a b1 1c			ld a, (.dmark)  
1ca0 32 5e ee			ld (debug_mark),a  
1ca3 3a b2 1c			ld a, (.dmark+1)  
1ca6 32 5f ee			ld (debug_mark+1),a  
1ca9 3a b3 1c			ld a, (.dmark+2)  
1cac 32 60 ee			ld (debug_mark+2),a  
1caf 18 03			jr .pastdmark  
1cb1 ..			.dmark: db "DSP"  
1cb4 f1			.pastdmark: pop af  
1cb5			endm  
# End of macro DMARK
1cb5			 
1cb5 cd 87 54				call display_data_sp 
1cb8				;call break_point_state 
1cb8				;rst 030h 
1cb8				CALLMONITOR 
1cb8 cd 6b ee			call debug_vector  
1cbb				endm  
# End of macro CALLMONITOR
1cbb				endif 
1cbb			 
1cbb c9				ret 
1cbc			 
1cbc			; return hl to start of value on stack 
1cbc			 
1cbc			FORTH_DSP_VALUE: macro 
1cbc				call macro_forth_dsp_value 
1cbc				endm 
1cbc			 
1cbc			macro_forth_dsp_value: 
1cbc			 
1cbc				FORTH_DSP 
1cbc cd 99 1c			call macro_forth_dsp 
1cbf				endm 
# End of macro FORTH_DSP
1cbf			 
1cbf d5				push de 
1cc0			 
1cc0 23				inc hl ; skip type 
1cc1			 
1cc1 5e				ld e, (hl) 
1cc2 23				inc hl 
1cc3 56				ld d, (hl) 
1cc4 eb				ex de,hl  
1cc5			 
1cc5 d1				pop de 
1cc6			 
1cc6 c9				ret 
1cc7			 
1cc7			; return hl to start of value to second item on stack 
1cc7			 
1cc7			FORTH_DSP_VALUEM1: macro 
1cc7				call macro_forth_dsp_value_m1 
1cc7				endm 
1cc7			 
1cc7			macro_forth_dsp_value_m1: 
1cc7			 
1cc7				FORTH_DSP 
1cc7 cd 99 1c			call macro_forth_dsp 
1cca				endm 
# End of macro FORTH_DSP
1cca			 
1cca 2b				dec hl 
1ccb 2b				dec hl 
1ccc			;	dec hl 
1ccc			 
1ccc d5				push de 
1ccd			 
1ccd 5e				ld e, (hl) 
1cce 23				inc hl 
1ccf 56				ld d, (hl) 
1cd0 eb				ex de,hl  
1cd1			 
1cd1 d1				pop de 
1cd2			 
1cd2 c9				ret 
1cd3			 
1cd3				 
1cd3			 
1cd3			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1cd3			 
1cd3			FORTH_DSP_POP: macro 
1cd3				call macro_forth_dsp_pop 
1cd3				endm 
1cd3			 
1cd3			 
1cd3			; get the tos data type 
1cd3			 
1cd3			FORTH_DSP_TYPE:   macro 
1cd3			 
1cd3				;FORTH_DSP_VALUE 
1cd3				FORTH_DSP 
1cd3				 
1cd3				; hl points to value 
1cd3				; check type 
1cd3			 
1cd3				ld a,(hl) 
1cd3			 
1cd3				endm 
1cd3			 
1cd3			; load the tos value into hl 
1cd3			 
1cd3			 
1cd3			FORTH_DSP_VALUEHL:  macro 
1cd3				call macro_dsp_valuehl 
1cd3				endm 
1cd3			 
1cd3			 
1cd3			 
1cd3			macro_dsp_valuehl: 
1cd3				FORTH_DSP_VALUE 
1cd3 cd bc 1c			call macro_forth_dsp_value 
1cd6				endm 
# End of macro FORTH_DSP_VALUE
1cd6			 
1cd6				;FORTH_ERR_TOS_NOTNUM 
1cd6			 
1cd6				;inc hl   ; skip type id 
1cd6			 
1cd6			;	push de 
1cd6			; 
1cd6			;	ld e, (hl) 
1cd6			;	inc hl 
1cd6			;	ld d, (hl) 
1cd6			;	ex de,hl  
1cd6			 
1cd6			;	pop de 
1cd6			 
1cd6				if DEBUG_FORTH_PUSH 
1cd6						DMARK "DVL" 
1cd6 f5				push af  
1cd7 3a eb 1c			ld a, (.dmark)  
1cda 32 5e ee			ld (debug_mark),a  
1cdd 3a ec 1c			ld a, (.dmark+1)  
1ce0 32 5f ee			ld (debug_mark+1),a  
1ce3 3a ed 1c			ld a, (.dmark+2)  
1ce6 32 60 ee			ld (debug_mark+2),a  
1ce9 18 03			jr .pastdmark  
1ceb ..			.dmark: db "DVL"  
1cee f1			.pastdmark: pop af  
1cef			endm  
# End of macro DMARK
1cef				CALLMONITOR 
1cef cd 6b ee			call debug_vector  
1cf2				endm  
# End of macro CALLMONITOR
1cf2				endif 
1cf2 c9				ret 
1cf3			 
1cf3			forth_apushstrhl:      
1cf3				; push of string requires use of cli_origptr 
1cf3				; bodge use 
1cf3			 
1cf3				; get current cli_origptr, save, update with temp pointer  
1cf3 ed 5b 31 ea		ld de, (cli_origptr) 
1cf7 22 31 ea			ld (cli_origptr), hl 
1cfa d5				push de 
1cfb cd 39 1c			call forth_apush 
1cfe d1				pop de 
1cff ed 53 31 ea		ld (cli_origptr), de 
1d03 c9			        ret	 
1d04			 
1d04			 
1d04			; increase loop stack pointer and save hl to it 
1d04				 
1d04			FORTH_LOOP_NEXT: macro 
1d04				call macro_forth_loop_next 
1d04				;nop 
1d04				endm 
1d04			 
1d04			macro_forth_loop_next: 
1d04				if DEBUG_FORTH_STACK_GUARD 
1d04 cd 9b 63				call check_stacks 
1d07				endif 
1d07 e5				push hl 
1d08 d5				push de 
1d09 eb				ex de,hl 
1d0a 2a e3 e9			ld hl,(cli_loop_sp) 
1d0d 23				inc hl 
1d0e 23				inc hl 
1d0f					if DEBUG_FORTH_WORDS 
1d0f						DMARK "LNX" 
1d0f f5				push af  
1d10 3a 24 1d			ld a, (.dmark)  
1d13 32 5e ee			ld (debug_mark),a  
1d16 3a 25 1d			ld a, (.dmark+1)  
1d19 32 5f ee			ld (debug_mark+1),a  
1d1c 3a 26 1d			ld a, (.dmark+2)  
1d1f 32 60 ee			ld (debug_mark+2),a  
1d22 18 03			jr .pastdmark  
1d24 ..			.dmark: db "LNX"  
1d27 f1			.pastdmark: pop af  
1d28			endm  
# End of macro DMARK
1d28						CALLMONITOR 
1d28 cd 6b ee			call debug_vector  
1d2b				endm  
# End of macro CALLMONITOR
1d2b					endif 
1d2b 22 e3 e9			ld (cli_loop_sp),hl 
1d2e 73				ld (hl), e 
1d2f 23				inc hl 
1d30 72				ld (hl), d 
1d31 d1				pop de    ; been reversed so save a swap on restore 
1d32 e1				pop hl 
1d33				if DEBUG_FORTH_STACK_GUARD 
1d33 cd 9b 63				call check_stacks 
1d36				endif 
1d36 c9				ret 
1d37			 
1d37			; get current ret stack pointer and save to hl  
1d37				 
1d37			FORTH_LOOP_TOS: macro 
1d37				call macro_forth_loop_tos 
1d37				endm 
1d37			 
1d37			macro_forth_loop_tos: 
1d37 d5				push de 
1d38 2a e3 e9			ld hl,(cli_loop_sp) 
1d3b 5e				ld e, (hl) 
1d3c 23				inc hl 
1d3d 56				ld d, (hl) 
1d3e eb				ex de, hl 
1d3f d1				pop de 
1d40 c9				ret 
1d41			 
1d41			; pop loop stack pointer 
1d41				 
1d41			FORTH_LOOP_POP: macro 
1d41				call macro_forth_loop_pop 
1d41				endm 
1d41			 
1d41			 
1d41			macro_forth_loop_pop: 
1d41				if DEBUG_FORTH_STACK_GUARD 
1d41					DMARK "LPP" 
1d41 f5				push af  
1d42 3a 56 1d			ld a, (.dmark)  
1d45 32 5e ee			ld (debug_mark),a  
1d48 3a 57 1d			ld a, (.dmark+1)  
1d4b 32 5f ee			ld (debug_mark+1),a  
1d4e 3a 58 1d			ld a, (.dmark+2)  
1d51 32 60 ee			ld (debug_mark+2),a  
1d54 18 03			jr .pastdmark  
1d56 ..			.dmark: db "LPP"  
1d59 f1			.pastdmark: pop af  
1d5a			endm  
# End of macro DMARK
1d5a cd 9b 63				call check_stacks 
1d5d					FORTH_CHK_LOOP_UNDER 
1d5d e5				push hl 
1d5e d5				push de 
1d5f 2a e3 e9			ld hl,(cli_loop_sp) 
1d62 11 1d e9			ld de, cli_loop_stack 
1d65 cd 04 0e			call cmp16 
1d68 da b8 64			jp c, fault_loop_under 
1d6b d1				pop de 
1d6c e1				pop hl 
1d6d				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1d6d				endif 
1d6d e5				push hl 
1d6e 2a e3 e9			ld hl,(cli_loop_sp) 
1d71 2b				dec hl 
1d72 2b				dec hl 
1d73 22 e3 e9			ld (cli_loop_sp), hl 
1d76				; TODO do stack underflow checks 
1d76 e1				pop hl 
1d77				if DEBUG_FORTH_STACK_GUARD 
1d77 cd 9b 63				call check_stacks 
1d7a					FORTH_CHK_LOOP_UNDER 
1d7a e5				push hl 
1d7b d5				push de 
1d7c 2a e3 e9			ld hl,(cli_loop_sp) 
1d7f 11 1d e9			ld de, cli_loop_stack 
1d82 cd 04 0e			call cmp16 
1d85 da b8 64			jp c, fault_loop_under 
1d88 d1				pop de 
1d89 e1				pop hl 
1d8a				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1d8a				endif 
1d8a c9				ret 
1d8b			 
1d8b			macro_forth_dsp_pop: 
1d8b			 
1d8b e5				push hl 
1d8c			 
1d8c				; release malloc data 
1d8c			 
1d8c				if DEBUG_FORTH_STACK_GUARD 
1d8c cd 9b 63				call check_stacks 
1d8f					FORTH_CHK_DSP_UNDER 
1d8f e5				push hl 
1d90 d5				push de 
1d91 2a e1 e9			ld hl,(cli_data_sp) 
1d94 11 1b e8			ld de, cli_data_stack 
1d97 cd 04 0e			call cmp16 
1d9a da ac 64			jp c, fault_dsp_under 
1d9d d1				pop de 
1d9e e1				pop hl 
1d9f				endm 
# End of macro FORTH_CHK_DSP_UNDER
1d9f				endif 
1d9f				;ld hl,(cli_data_sp) 
1d9f			if DEBUG_FORTH_DOT 
1d9f				DMARK "DPP" 
1d9f f5				push af  
1da0 3a b4 1d			ld a, (.dmark)  
1da3 32 5e ee			ld (debug_mark),a  
1da6 3a b5 1d			ld a, (.dmark+1)  
1da9 32 5f ee			ld (debug_mark+1),a  
1dac 3a b6 1d			ld a, (.dmark+2)  
1daf 32 60 ee			ld (debug_mark+2),a  
1db2 18 03			jr .pastdmark  
1db4 ..			.dmark: db "DPP"  
1db7 f1			.pastdmark: pop af  
1db8			endm  
# End of macro DMARK
1db8				CALLMONITOR 
1db8 cd 6b ee			call debug_vector  
1dbb				endm  
# End of macro CALLMONITOR
1dbb			endif	 
1dbb			 
1dbb			 
1dbb			if FORTH_ENABLE_DSPPOPFREE 
1dbb			 
1dbb				FORTH_DSP 
1dbb cd 99 1c			call macro_forth_dsp 
1dbe				endm 
# End of macro FORTH_DSP
1dbe			 
1dbe 7e				ld a, (hl) 
1dbf fe 01			cp DS_TYPE_STR             ; implies that DS_TYPE_CONST *WONT* be freed 
1dc1 20 22			jr nz, .skippopfree 
1dc3			 
1dc3				FORTH_DSP_VALUEHL 
1dc3 cd d3 1c			call macro_dsp_valuehl 
1dc6				endm 
# End of macro FORTH_DSP_VALUEHL
1dc6			;	nop 
1dc6			if DEBUG_FORTH_DOT 
1dc6				DMARK "DPf" 
1dc6 f5				push af  
1dc7 3a db 1d			ld a, (.dmark)  
1dca 32 5e ee			ld (debug_mark),a  
1dcd 3a dc 1d			ld a, (.dmark+1)  
1dd0 32 5f ee			ld (debug_mark+1),a  
1dd3 3a dd 1d			ld a, (.dmark+2)  
1dd6 32 60 ee			ld (debug_mark+2),a  
1dd9 18 03			jr .pastdmark  
1ddb ..			.dmark: db "DPf"  
1dde f1			.pastdmark: pop af  
1ddf			endm  
# End of macro DMARK
1ddf				CALLMONITOR 
1ddf cd 6b ee			call debug_vector  
1de2				endm  
# End of macro CALLMONITOR
1de2			endif	 
1de2 cd 7c 12			call free 
1de5			.skippopfree: 
1de5				 
1de5			 
1de5			endif 
1de5			 
1de5			if DEBUG_FORTH_DOT_KEY 
1de5				DMARK "DP2" 
1de5				CALLMONITOR 
1de5			endif	 
1de5			 
1de5				; move pointer down 
1de5			 
1de5 2a e1 e9			ld hl,(cli_data_sp) 
1de8 2b				dec hl 
1de9 2b				dec hl 
1dea			; PARSEV5 
1dea 2b				dec hl 
1deb 22 e1 e9			ld (cli_data_sp), hl 
1dee			 
1dee				if DEBUG_FORTH_STACK_GUARD 
1dee cd 9b 63				call check_stacks 
1df1					FORTH_CHK_DSP_UNDER 
1df1 e5				push hl 
1df2 d5				push de 
1df3 2a e1 e9			ld hl,(cli_data_sp) 
1df6 11 1b e8			ld de, cli_data_stack 
1df9 cd 04 0e			call cmp16 
1dfc da ac 64			jp c, fault_dsp_under 
1dff d1				pop de 
1e00 e1				pop hl 
1e01				endm 
# End of macro FORTH_CHK_DSP_UNDER
1e01				endif 
1e01			 
1e01 e1				pop hl 
1e02			 
1e02 c9				ret 
1e03			 
1e03			getwordathl: 
1e03				; hl points to an address 
1e03				; load hl with the word at that address 
1e03			 
1e03 d5				push de 
1e04			 
1e04 5e				ld e, (hl) 
1e05 23				inc hl 
1e06 56				ld d, (hl) 
1e07 eb				ex de, hl 
1e08			 
1e08 d1				pop de 
1e09 c9				ret 
1e0a			 
1e0a			 
1e0a			; functions to manuplite stack pointers 
1e0a			 
1e0a			; generate fragment to set hl to be pointer to a stack item 
1e0a			 
1e0a			FORTH_DSP_PTR: macro  x 
1e0a				ld hl,(cli_data_sp) 
1e0a				ld de, x * 3 
1e0a				sbc hl, de 
1e0a				endm 
1e0a			 
1e0a			 
1e0a			 
1e0a			; copy point in hl to stack tmp storage slots 1-4 
1e0a			hltostack1: 
1e0a 11 b1 e2			ld de, os_stack_1  
1e0d c3 38 1e			jp hltostackmv 
1e10			 
1e10			hltostack2:  
1e10 11 ae e2			ld de, os_stack_2 
1e13 c3 38 1e			jp hltostackmv 
1e16			 
1e16			hltostack3:  
1e16 11 ab e2			ld de, os_stack_3 
1e19 c3 38 1e			jp hltostackmv 
1e1c			 
1e1c			hltostack4:  
1e1c 11 a8 e2			ld de, os_stack_4  
1e1f c3 38 1e			jp hltostackmv 
1e22			 
1e22			; copy to point in hl from stack tmp storage slots 1-4 
1e22			hlfromstack1: 
1e22 11 b1 e2			ld de, os_stack_1 
1e25 c3 37 1e			jp hlfromsttackmv 
1e28			 
1e28			hlfromstack2:  
1e28 11 ae e2			ld de, os_stack_2 
1e2b c3 37 1e			jp hlfromsttackmv 
1e2e			 
1e2e			hlfromstack3:  
1e2e 11 ab e2			ld de, os_stack_3 
1e31 c3 37 1e			jp hlfromsttackmv 
1e34			 
1e34			hlfromstack4:  
1e34 11 a8 e2			ld de, os_stack_4 
1e37			 
1e37			hlfromsttackmv: 
1e37 eb				ex de, hl 
1e38			 
1e38			hltostackmv: 
1e38			 
1e38				; do stack move 
1e38 c5				push bc 
1e39 01 03 00			ld bc, 3 
1e3c ed b0			ldir  
1e3e c1				pop bc	 
1e3f c9				ret 
1e40			 
1e40			; eof 
1e40			 
# End of file forth_stackopsv5.asm
1e40			endif 
1e40			loadwordinhl:	 
1e40			 
1e40 d5				push de 
1e41			 
1e41 5e				ld e, (hl) 
1e42 23				inc hl 
1e43 56				ld d, (hl) 
1e44 eb				ex de,hl  
1e45			 
1e45 d1				pop de 
1e46			 
1e46 c9				ret 
1e47			 
1e47			user_word_eol:  
1e47				; hl contains the pointer to where to create a linked list item from the end 
1e47				; of the user dict to continue on at the system word dict 
1e47				 
1e47				; poke the stub of the word list linked list to repoint to rom words 
1e47			 
1e47				; stub format 
1e47				; db   word id 
1e47				; dw    link to next word 
1e47			        ; db char length of token 
1e47				; db string + 0 term 
1e47				; db exec code....  
1e47			 
1e47			;	ld a, WORD_SYS_ROOT     ; root word 
1e47 36 00			ld (hl), WORD_SYS_ROOT		; word id 
1e49 23				inc hl 
1e4a			 
1e4a 11 f3 1f			ld de, sysdict 
1e4d 73				ld (hl), e		; next word link ie system dict 
1e4e 23				inc hl 
1e4f 72				ld (hl), d		; next word link ie system dict 
1e50 23				inc hl	 
1e51			 
1e51			;	ld (hl), sysdict		; next word link ie system dict 
1e51			;	inc hl 
1e51			;	inc hl 
1e51			 
1e51			;	inc hl 
1e51			;	inc hl 
1e51			 
1e51			;	ld a, 2			; word length is 0 
1e51 36 02			ld (hl), 2 
1e53 23				inc hl 
1e54			 
1e54			;	ld a, '~'			; word length is 0 
1e54 36 7e			ld (hl), '~' 
1e56 23				inc hl 
1e57			;	ld a, 0			; save empty word 
1e57 36 00			ld (hl), 0 
1e59			 
1e59 c9				ret 
1e5a			 
1e5a				 
1e5a			 
1e5a			forthexec_cleanup: 
1e5a				FORTH_RSP_POP 
1e5a cd 9f 1a			call macro_forth_rsp_pop 
1e5d				endm 
# End of macro FORTH_RSP_POP
1e5d c9				ret 
1e5e			 
1e5e			forth_call_hl: 
1e5e				; taking hl 
1e5e e5				push hl 
1e5f c9				ret 
1e60			 
1e60			; this is called to reset Forth system but keep existing uwords etc 
1e60			 
1e60			forth_warmstart: 
1e60				; setup stack over/under flow checks 
1e60				if DEBUG_FORTH_STACK_GUARD 
1e60 cd 81 63				call chk_stk_init 
1e63				endif 
1e63			 
1e63				; init stack pointers  - * these stacks go upwards *  
1e63 21 9f e9			ld hl, cli_ret_stack 
1e66 22 e5 e9			ld (cli_ret_sp), hl	 
1e69				; set bottom of stack 
1e69			;	ld a,0 
1e69 36 00			ld (hl),0 
1e6b 23				inc hl 
1e6c 36 00			ld (hl),0 
1e6e			 
1e6e 21 1b e8			ld hl, cli_data_stack 
1e71 22 e1 e9			ld (cli_data_sp), hl	 
1e74				; set bottom of stack 
1e74			;	ld a,0 
1e74 36 00			ld (hl),0 
1e76 23				inc hl 
1e77 36 00			ld (hl),0 
1e79			 
1e79 21 1d e9			ld hl, cli_loop_stack 
1e7c 22 e3 e9			ld (cli_loop_sp), hl	 
1e7f				; set bottom of stack 
1e7f			;	ld a,0 
1e7f 36 00			ld (hl),0 
1e81 23				inc hl 
1e82 36 00			ld (hl),0 
1e84			 
1e84				; init extent of current open file 
1e84			 
1e84 3e 00			ld a, 0 
1e86 32 5d ea			ld (store_openext), a 
1e89			 
1e89 c9				ret 
1e8a			 
1e8a			 
1e8a			 
1e8a			; Cold Start - this is called to setup the whole Forth system 
1e8a			 
1e8a			forth_init: 
1e8a			 
1e8a				; setup stack over/under flow checks 
1e8a			 
1e8a			;	if DEBUG_FORTH_STACK_GUARD 
1e8a			;		call chk_stk_init 
1e8a			;	endif 
1e8a			 
1e8a				; enable auto display updates (slow.....) 
1e8a			 
1e8a 3e 01			ld a, 1 
1e8c 32 2f ea			ld (cli_autodisplay), a 
1e8f			 
1e8f				; if storage is in use disable long reads for now 
1e8f 3e 00			ld a, 0 
1e91 32 68 ea			ld (store_longread), a 
1e94			 
1e94			 
1e94				; show start up screen 
1e94			 
1e94 cd bc 0b			call clear_display 
1e97			 
1e97 3e 00			ld a,0 
1e99 32 51 ea			ld (f_cursor_ptr), a 
1e9c			 
1e9c				; set start of word list in start of ram - for use when creating user words 
1e9c			 
1e9c 21 9f 67			ld hl, baseram 
1e9f 22 b1 e5			ld (os_last_new_uword), hl 
1ea2 cd 47 1e			call user_word_eol 
1ea5				 
1ea5			;		call display_data_sp 
1ea5			;		call next_page_prompt 
1ea5			 
1ea5			 
1ea5			 
1ea5			 
1ea5 c9				ret 
1ea6			 
1ea6 .. 00		.bootforth: db " Forth Kernel Init ",0 
1eba			 
1eba			; TODO push to stack 
1eba			 
1eba			;  
1eba			 
1eba			if FORTH_PARSEV2 
1eba			 
1eba			 
1eba				include "forth_parserv2.asm" 
1eba			 
1eba			endif 
1eba			 
1eba			 
1eba			; parse cli version 1 
1eba			 
1eba			if FORTH_PARSEV1 
1eba			 
1eba			 
1eba			 
1eba			      include "forth_parserv1.asm" 
1eba			endif 
1eba				 
1eba			if FORTH_PARSEV3 
1eba			      include "forth_parserv3.asm" 
1eba				include "forth_wordsv3.asm" 
1eba			endif 
1eba			 
1eba			if FORTH_PARSEV4 
1eba			      include "forth_parserv4.asm" 
1eba				include "forth_wordsv4.asm" 
1eba			endif 
1eba			 
1eba			if FORTH_PARSEV5 
1eba			      include "forth_parserv5.asm" 
1eba				include "forth_wordsv4.asm" 
1eba			endif 
1eba			 
1eba			if FORTH_PARSEV6 
1eba			      include "forth_parserv6.asm" 
1eba			 
1eba			 
1eba			; A better parser without using malloc and string copies all over the place.  
1eba			; Exec in situ should be faster 
1eba			 
1eba			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
1eba			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
1eba			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
1eba			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
1eba			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
1eba			WORD_SYS_END: equ 0   ; Opcode for all user words 
1eba			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
1eba			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
1eba			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
1eba			 
1eba			; Core word preamble macro 
1eba			 
1eba			CWHEAD:   macro nxtword opcode lit len opflags 
1eba				db WORD_SYS_CORE+opcode             
1eba				; internal op code number 
1eba				dw nxtword            
1eba				; link to next dict word block 
1eba				db len + 1 
1eba				; literal length of dict word inc zero term 
1eba				db lit,0              
1eba				; literal dict word 
1eba			        ; TODO db opflags        
1eba				endm 
1eba			 
1eba			 
1eba			NEXTW: macro  
1eba				call parse_vector 
1eba				jp macro_next 
1eba				endm 
1eba			 
1eba			macro_next: 
1eba			if DEBUG_FORTH_PARSE_EXEC 
1eba				DMARK "NXT" 
1eba				CALLMONITOR 
1eba			endif	 
1eba			;	inc hl  ; skip token null term  
1eba ed 4b 33 ea		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1ebe ed 5b 31 ea		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1ec2 2a b5 e5			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1ec5			if DEBUG_FORTH_PARSE_EXEC 
1ec5				DMARK "}AA" 
1ec5				CALLMONITOR 
1ec5			endif	 
1ec5 c3 aa 1f			jp execnext 
1ec8				;jp exec1 
1ec8			       
1ec8			 
1ec8			 
1ec8			; Another go at the parser to compile  
1ec8			 
1ec8			 
1ec8			; TODO rework parser to change all of the string words to byte tokens 
1ec8			; TODO do a search for  
1ec8			 
1ec8			; TODO first run normal parser to zero term sections 
1ec8			; TODO for each word do a token look up to get the op code 
1ec8			; TODO need some means to flag to the exec that this is a byte code form    
1ec8			 
1ec8			 
1ec8			forthcompile: 
1ec8			 
1ec8			; 
1ec8			; line parse: 
1ec8			;       parse raw input buffer 
1ec8			;       tokenise the words 
1ec8			;       malloc new copy (for looping etc) 
1ec8			;       copy to malloc + current pc in line to start of string and add line term 
1ec8			;       save on new rsp 
1ec8			; 
1ec8			 
1ec8			; hl to point to the line to tokenise 
1ec8			 
1ec8			;	push hl 
1ec8 22 b5 e5			ld (os_tok_ptr), hl  ; save ptr to string 
1ecb			 
1ecb			;	ld a,0		; string term on input 
1ecb			;	call strlent 
1ecb			 
1ecb			;	ld (os_tok_len), hl	 ; save string length 
1ecb			 
1ecb			;if DEBUG_FORTH_TOK 
1ecb			;	ex de,hl		 
1ecb			;endif 
1ecb			 
1ecb			;	pop hl 		; get back string pointer 
1ecb			 
1ecb			if DEBUG_FORTH_TOK 
1ecb						DMARK "TOc" 
1ecb				CALLMONITOR 
1ecb			endif 
1ecb 7e			.cptoken2:    ld a,(hl) 
1ecc 23				inc hl 
1ecd fe 7f			cp FORTH_END_BUFFER 
1ecf 28 26			jr z, .cptokendone2 
1ed1			;	cp 0 
1ed1 b7				or a 
1ed2 28 23			jr z, .cptokendone2 
1ed4 fe 22			cp '"' 
1ed6 28 0a			jr z, .cptokenstr2     ; will want to skip until end of string delim 
1ed8 fe 20			cp ' ' 
1eda 20 ef			jr nz,  .cptoken2 
1edc			 
1edc			; TODO consume comments held between ( and ) 
1edc			 
1edc				; we have a space so change to zero term for dict match later 
1edc 2b				dec hl 
1edd			;	ld a,0 
1edd 36 00			ld (hl), 0 
1edf 23				inc hl 
1ee0 18 e9			jr .cptoken2 
1ee2				 
1ee2			 
1ee2			.cptokenstr2: 
1ee2				; skip all white space until either eol (because forgot to term) or end double quote 
1ee2			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1ee2				;inc hl ; skip current double quote 
1ee2 7e				ld a,(hl) 
1ee3 23				inc hl 
1ee4 fe 22			cp '"' 
1ee6 28 e3			jr z, .cptoken2 
1ee8 fe 7f			cp FORTH_END_BUFFER 
1eea 28 0b			jr z, .cptokendone2 
1eec			;	cp 0 
1eec b7				or a 
1eed 28 08			jr z, .cptokendone2 
1eef fe 20			cp ' ' 
1ef1 28 02			jr z, .cptmp2 
1ef3 18 ed			jr .cptokenstr2 
1ef5			 
1ef5			.cptmp2:	; we have a space so change to zero term for dict match later 
1ef5				;dec hl 
1ef5				;ld a,"-"	; TODO remove this when working 
1ef5				;ld (hl), a 
1ef5				;inc hl 
1ef5 18 eb			jr .cptokenstr2 
1ef7			 
1ef7			.cptokendone2: 
1ef7				;inc hl 
1ef7			;	ld a, FORTH_END_BUFFER 
1ef7 36 7f			ld (hl),FORTH_END_BUFFER 
1ef9			;	inc hl 
1ef9			;	ld a, '!' 
1ef9			;	ld (hl),a 
1ef9			 
1ef9 2a b5 e5			ld hl,(os_tok_ptr) 
1efc			         
1efc			if DEBUG_FORTH_TOK 
1efc						DMARK "Tc1" 
1efc				CALLMONITOR 
1efc			endif 
1efc			 
1efc				; push exec string to top of return stack 
1efc				FORTH_RSP_NEXT 
1efc cd 7e 1a			call macro_forth_rsp_next 
1eff				endm 
# End of macro FORTH_RSP_NEXT
1eff c9				ret 
1f00			 
1f00			; Another go at the parser need to simplify the process 
1f00			 
1f00			forthparse: 
1f00			 
1f00			; 
1f00			; line parse: 
1f00			;       parse raw input buffer 
1f00			;       tokenise the words 
1f00			;       malloc new copy (for looping etc) 
1f00			;       copy to malloc + current pc in line to start of string and add line term 
1f00			;       save on new rsp 
1f00			; 
1f00			 
1f00			; hl to point to the line to tokenise 
1f00			 
1f00			;	push hl 
1f00 22 b5 e5			ld (os_tok_ptr), hl  ; save ptr to string 
1f03			 
1f03			;	ld a,0		; string term on input 
1f03			;	call strlent 
1f03			 
1f03			;	ld (os_tok_len), hl	 ; save string length 
1f03			 
1f03			;if DEBUG_FORTH_TOK 
1f03			;	ex de,hl		 
1f03			;endif 
1f03			 
1f03			;	pop hl 		; get back string pointer 
1f03			 
1f03			if DEBUG_FORTH_TOK 
1f03						DMARK "TOK" 
1f03				CALLMONITOR 
1f03			endif 
1f03 7e			.ptoken2:    ld a,(hl) 
1f04 23				inc hl 
1f05 fe 7f			cp FORTH_END_BUFFER 
1f07 28 26			jr z, .ptokendone2 
1f09			;	cp 0 
1f09 b7				or a 
1f0a 28 23			jr z, .ptokendone2 
1f0c fe 22			cp '"' 
1f0e 28 0a			jr z, .ptokenstr2     ; will want to skip until end of string delim 
1f10 fe 20			cp ' ' 
1f12 20 ef			jr nz,  .ptoken2 
1f14			 
1f14			; TODO consume comments held between ( and ) 
1f14			 
1f14				; we have a space so change to zero term for dict match later 
1f14 2b				dec hl 
1f15			;	ld a,0 
1f15 36 00			ld (hl), 0 
1f17 23				inc hl 
1f18 18 e9			jr .ptoken2 
1f1a				 
1f1a			 
1f1a			.ptokenstr2: 
1f1a				; skip all white space until either eol (because forgot to term) or end double quote 
1f1a			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1f1a				;inc hl ; skip current double quote 
1f1a 7e				ld a,(hl) 
1f1b 23				inc hl 
1f1c fe 22			cp '"' 
1f1e 28 e3			jr z, .ptoken2 
1f20 fe 7f			cp FORTH_END_BUFFER 
1f22 28 0b			jr z, .ptokendone2 
1f24			;	cp 0 
1f24 b7				or a 
1f25 28 08			jr z, .ptokendone2 
1f27 fe 20			cp ' ' 
1f29 28 02			jr z, .ptmp2 
1f2b 18 ed			jr .ptokenstr2 
1f2d			 
1f2d			.ptmp2:	; we have a space so change to zero term for dict match later 
1f2d				;dec hl 
1f2d				;ld a,"-"	; TODO remove this when working 
1f2d				;ld (hl), a 
1f2d				;inc hl 
1f2d 18 eb			jr .ptokenstr2 
1f2f			 
1f2f			.ptokendone2: 
1f2f				;inc hl 
1f2f			;	ld a, FORTH_END_BUFFER 
1f2f 36 7f			ld (hl),FORTH_END_BUFFER 
1f31			;	inc hl 
1f31			;	ld a, '!' 
1f31			;	ld (hl),a 
1f31			 
1f31 2a b5 e5			ld hl,(os_tok_ptr) 
1f34			         
1f34			if DEBUG_FORTH_TOK 
1f34						DMARK "TK1" 
1f34				CALLMONITOR 
1f34			endif 
1f34			 
1f34				; push exec string to top of return stack 
1f34				FORTH_RSP_NEXT 
1f34 cd 7e 1a			call macro_forth_rsp_next 
1f37				endm 
# End of macro FORTH_RSP_NEXT
1f37 c9				ret 
1f38			 
1f38			; 
1f38			;	; malloc size + buffer pointer + if is loop flag 
1f38			;	ld hl,(os_tok_len) 		 ; get string length 
1f38			; 
1f38			;	ld a,l 
1f38			; 
1f38			;	cp 0			; we dont want to use a null string 
1f38			;	ret z 
1f38			; 
1f38			;;	add 3    ; prefix malloc with buffer for current word ptr 
1f38			; 
1f38			;	add 5     ; TODO when certain not over writing memory remove 
1f38			; 
1f38			;		 
1f38			; 
1f38			;if DEBUG_FORTH_TOK 
1f38			;			DMARK "TKE" 
1f38			;	CALLMONITOR 
1f38			;endif 
1f38			; 
1f38			;	ld l,a 
1f38			;	ld h,0 
1f38			;;	push hl   ; save required space for the copy later 
1f38			;	call malloc 
1f38			;if DEBUG_FORTH_TOK 
1f38			;			DMARK "TKM" 
1f38			;	CALLMONITOR 
1f38			;endif 
1f38			;	if DEBUG_FORTH_MALLOC_GUARD 
1f38			;		push af 
1f38			;		call ishlzero 
1f38			;;		ld a, l 
1f38			;;		add h 
1f38			;;		cp 0 
1f38			;		pop af 
1f38			;		 
1f38			;		call z,malloc_error 
1f38			;	endif 
1f38			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
1f38			; 
1f38			; 
1f38			;if DEBUG_FORTH_TOK 
1f38			;			DMARK "TKR" 
1f38			;	CALLMONITOR 
1f38			;endif 
1f38			; 
1f38			;	FORTH_RSP_NEXT 
1f38			; 
1f38			;	;inc hl	 ; go past current buffer pointer 
1f38			;	;inc hl 
1f38			;	;inc hl   ; and past if loop flag 
1f38			;		; TODO Need to set flag  
1f38			; 
1f38			;	 
1f38			;	 
1f38			;	ex de,hl	; malloc is dest 
1f38			;	ld hl, (os_tok_len) 
1f38			;;	pop bc 
1f38			;	ld c, l                
1f38			;	ld b,0 
1f38			;	ld hl, (os_tok_ptr) 
1f38			; 
1f38			;if DEBUG_FORTH_TOK 
1f38			;			DMARK "TKT" 
1f38			;	CALLMONITOR 
1f38			;endif 
1f38			; 
1f38			;	; do str cpy 
1f38			; 
1f38			;	ldir      ; copy byte in hl to de 
1f38			; 
1f38			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
1f38			; 
1f38			;if DEBUG_FORTH_TOK 
1f38			; 
1f38			;			DMARK "TKY" 
1f38			;	CALLMONITOR 
1f38			;endif 
1f38			;	;ld a,0 
1f38			;	;ld a,FORTH_END_BUFFER 
1f38			;	ex de, hl 
1f38			;	;dec hl			 ; go back over the space delim at the end of word 
1f38			;	;ld (hl),a 
1f38			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
1f38			;	ld a,FORTH_END_BUFFER 
1f38			;	ld (hl),a 
1f38			;	inc hl 
1f38			;	ld a,FORTH_END_BUFFER 
1f38			;	ld (hl),a 
1f38			; 
1f38			;	; init the malloc area data 
1f38			;	; set pc for in current area 
1f38			;	;ld hl, (os_tok_malloc) 
1f38			;	;inc hl 
1f38			;	;inc hl 
1f38			;	;inc hl 
1f38			;	;ex de,hl 
1f38			;	;ld hl, (os_tok_malloc) 
1f38			;	;ld (hl),e 
1f38			;	;inc hl 
1f38			;	;ld (hl),d 
1f38			; 
1f38			; 
1f38			;	ld hl,(os_tok_malloc) 
1f38			;if DEBUG_FORTH_PARSE_KEY 
1f38			;			DMARK "TKU" 
1f38			;	CALLMONITOR 
1f38			;endif 
1f38			; 
1f38			;	ret 
1f38			 
1f38			forthexec: 
1f38			 
1f38			; line exec: 
1f38			; forth parser 
1f38			 
1f38			; 
1f38			;       get current exec line on rsp 
1f38			 
1f38				FORTH_RSP_TOS 
1f38 cd 95 1a			call macro_forth_rsp_tos 
1f3b				endm 
# End of macro FORTH_RSP_TOS
1f3b			 
1f3b			;       restore current pc - hl points to malloc of data 
1f3b			 
1f3b				;ld e, (hl) 
1f3b				;inc hl 
1f3b				;ld d, (hl) 
1f3b				;ex de,hl 
1f3b			 
1f3b			 
1f3b			exec1: 
1f3b 22 b5 e5			ld (os_tok_ptr), hl                 ; here move out of repeated saving in this tight loop 
1f3e			 
1f3e				; copy our PC to working vars  
1f3e 22 33 ea			ld (cli_ptr), hl                    ; here 
1f41 22 31 ea			ld (cli_origptr), hl                ; here 
1f44			 
1f44 7e				ld a,(hl)                           ; here make hl be the ram ptr 
1f45 fe 7f			cp FORTH_END_BUFFER 
1f47 c8				ret z 
1f48			 
1f48				; skip any nulls 
1f48			 
1f48			;	cp 0 
1f48 b7				or a 
1f49 20 03			jr nz, .execword 
1f4b 23				inc hl 
1f4c 18 ed			jr exec1 
1f4e			 
1f4e			 
1f4e			.execword: 
1f4e			 
1f4e			 
1f4e			 
1f4e			if DEBUG_FORTH_PARSE_EXEC 
1f4e						DMARK "KYQ" 
1f4e				CALLMONITOR 
1f4e			endif 
1f4e			;       while at start of word: 
1f4e			; get start of dict (in user area first) 
1f4e			 
1f4e 21 9f 67		ld hl, baseram 
1f51			;ld hl, sysdict 
1f51 22 35 ea		ld (cli_nextword),hl                            ; here do we need to do this? 
1f54			;           match word at pc 
1f54			;           exec word 
1f54			;           or push to dsp 
1f54			;           forward to next token 
1f54			;           if line term pop rsp and exit 
1f54			;        
1f54			 
1f54			if DEBUG_FORTH_PARSE_EXEC 
1f54						DMARK "KYq" 
1f54				CALLMONITOR 
1f54			endif 
1f54			 
1f54			; 
1f54			; word comp 
1f54			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
1f54			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
1f54			;    move to start of word  
1f54			;    compare word to cli_token 
1f54			 
1f54			.execpnword:	; HL at start of a word in the dictionary to check 
1f54			 
1f54 2a 35 ea			ld hl,(cli_nextword)                  ; here remove the need to store???? 
1f57			 
1f57 cd ec 1f			call forth_tok_next 
1f5a			; tok next end here 
1f5a 22 35 ea			ld (cli_nextword), hl     ; save for next check if no match on this word 
1f5d eb				ex de, hl 
1f5e			 
1f5e			 
1f5e				; save the pointer of the current token - 1 to check against 
1f5e				 
1f5e 22 39 ea			ld (cli_token), hl   
1f61				; TODO maybe remove below save if no debug 
1f61				; save token string ptr for any debug later 
1f61 23				inc hl  
1f62 22 3b ea			ld (cli_origtoken), hl 
1f65 2b				dec hl 
1f66				; save pointer to the start of the next dictionay word 
1f66 7e				ld a,(hl)   ; get string length 
1f67			;	ld b,a 
1f67			;.execpnwordinc:  
1f67			;	inc hl 
1f67			;	djnz .execpnwordinc 
1f67 06 00			ld b, 0 
1f69 4f				ld c, a 
1f6a 09				add hl, bc 
1f6b 22 37 ea			ld (cli_execword), hl      ; save start of this words code 
1f6e			 
1f6e				; now check the word token against the string being parsed 
1f6e			 
1f6e 2a 39 ea			ld hl,(cli_token) 
1f71 23				inc hl     ; skip string length (use zero term instead to end) 
1f72				;ld (cli_token), hl 
1f72			 
1f72			.execpnchar:    ; compare char between token and string to parse 
1f72			 
1f72			 
1f72				;ld hl, (cli_token)     ; the dict word  
1f72 ed 5b 33 ea		ld de, (cli_ptr)     ; cli to parse 
1f76			 
1f76			 
1f76			.execpncharl:    ; compare char between token and string to parse (loop) 
1f76			 
1f76 1a				ld a,(de) 
1f77 cd 35 11			call toUpper 		; make sure the input string matches case 
1f7a be				cp (hl) 
1f7b			 
1f7b c2 93 1f			jp nz, .execpnskipword	 ; no match so move to next word 
1f7e				 
1f7e			;    if same 
1f7e			;       scan for string terms 0 for token and 32 for input 
1f7e 46				ld b,(hl) 
1f7f 80				add b			 
1f80 23				inc hl 
1f81 13				inc de 
1f82 b7				or a 
1f83			;	cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
1f83							; TODO need to make sure last word in zero term string is accounted for 
1f83 20 f1			jr nz, .execpncharl 		 ; not at end of strings yet 
1f85			 
1f85			 
1f85				; at end of both strings so both are exact match 
1f85			 
1f85			;       skip ptr for next word 
1f85			 
1f85 2a 33 ea			ld hl,(cli_ptr) 	; at input string term 
1f88 23				inc hl			 ; at next char 
1f89 22 33 ea			ld (cli_ptr), hl     ; save for next round of the parser 
1f8c 22 31 ea			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
1f8f				 
1f8f				 
1f8f			 
1f8f			 
1f8f			 
1f8f			;       exec code block 
1f8f			if DEBUG_FORTH_JP 
1f8f				call clear_display 
1f8f				call update_display 
1f8f				call delay1s 
1f8f				ld hl, (cli_execword)     ; save for next check if no match on this word 
1f8f				ld a,h 
1f8f				ld hl, os_word_scratch 
1f8f				call hexout 
1f8f				ld hl, (cli_execword)     ; save for next check if no match on this word 
1f8f				ld a,l 
1f8f				ld hl, os_word_scratch+2 
1f8f				call hexout 
1f8f				ld hl, os_word_scratch+4 
1f8f			;	ld a,0 
1f8f				ld (hl),0 
1f8f				ld de,os_word_scratch 
1f8f				call str_at_display 
1f8f					ld a, display_row_2 
1f8f					call str_at_display 
1f8f				ld de, (cli_origtoken) 
1f8f				ld a, display_row_1+10 
1f8f					call str_at_display 
1f8f			 
1f8f				ld a,display_row_1 
1f8f				ld de, .foundword 
1f8f				ld a, display_row_3 
1f8f				call str_at_display 
1f8f				call update_display 
1f8f				call delay1s 
1f8f				call delay1s 
1f8f				call delay1s 
1f8f			endif 
1f8f			 
1f8f			if DEBUG_FORTH_PARSE_EXEC 
1f8f						DMARK "KYj" 
1f8f			endif 
1f8f				; TODO save the word pointer in this exec 
1f8f			 
1f8f 2a 37 ea			ld hl,(cli_execword) 
1f92 e9				jp (hl) 
1f93			 
1f93			 
1f93			;    if not same 
1f93			;	scan for zero term 
1f93			;	get ptr for next word 
1f93			;	goto word comp 
1f93			 
1f93			.execpnskipword:	; get pointer to next word 
1f93 2a 35 ea			ld hl,(cli_nextword) 
1f96			 
1f96 7e				ld a,(hl) 
1f97 fe 00			cp WORD_SYS_END 
1f99			;	cp 0 
1f99 28 09			jr z, .execendofdict			 ; at end of words 
1f9b			 
1f9b			if DEBUG_FORTH_PARSE_EXEC 
1f9b						DMARK "KY4" 
1f9b			endif 
1f9b			if DEBUG_FORTH_PARSE_EXEC 
1f9b			 
1f9b				; see if disabled 
1f9b			 
1f9b			;	ld a, (os_view_disable) 
1f9b			;	cp '*' 
1f9b				ld a,(debug_vector) 
1f9b				cp $c9   ; RET 
1f9b				jr z, .noskip 
1f9b			 
1f9b			 
1f9b				ld de, .nowordfound 
1f9b				ld a, display_row_3 
1f9b				call str_at_display 
1f9b				call update_display 
1f9b				ld a, 100 
1f9b				call aDelayInMS 
1f9b				 
1f9b				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1f9b					call delay250ms 
1f9b				endif 
1f9b			.noskip:  
1f9b			 
1f9b			endif	 
1f9b			 
1f9b 2a 31 ea			ld hl,(cli_origptr) 
1f9e 22 33 ea			ld (cli_ptr),hl 
1fa1			 
1fa1			if DEBUG_FORTH_PARSE_EXEC 
1fa1						DMARK "KY5" 
1fa1			endif 
1fa1 c3 54 1f			jp .execpnword			; else go to next word 
1fa4			 
1fa4			.execendofdict:  
1fa4			 
1fa4			if DEBUG_FORTH_PARSE_EXEC 
1fa4						DMARK "KYe" 
1fa4			endif 
1fa4			if DEBUG_FORTH_PARSE_EXEC 
1fa4				; see if disabled 
1fa4			 
1fa4			;	ld a, (os_view_disable) 
1fa4			;	cp '*' 
1fa4				ld a,(debug_vector) 
1fa4				cp $c9   ; ret 
1fa4				jr z, .ispskip 
1fa4			 
1fa4				call clear_display 
1fa4				call update_display 
1fa4				call delay1s 
1fa4				ld de, (cli_origptr) 
1fa4				ld a, display_row_1 
1fa4				call str_at_display 
1fa4				 
1fa4				ld de, .enddict 
1fa4				ld a, display_row_3 
1fa4				call str_at_display 
1fa4				call update_display 
1fa4				ld a, 100 
1fa4				call aDelayInMS 
1fa4				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1fa4				call delay1s 
1fa4				call delay1s 
1fa4				call delay1s 
1fa4				endif 
1fa4			.ispskip:  
1fa4				 
1fa4			endif	 
1fa4			 
1fa4			 
1fa4			 
1fa4				; if the word is not a keyword then must be a literal so push it to stack 
1fa4			 
1fa4			; push token to stack to end of word 
1fa4			 
1fa4				STACKFRAME ON $1efe $2f9f 
1fa4				if DEBUG_STACK_IMB 
1fa4					if ON 
1fa4						exx 
1fa4						ld de, $1efe 
1fa4						ld a, d 
1fa4						ld hl, curframe 
1fa4						call hexout 
1fa4						ld a, e 
1fa4						ld hl, curframe+2 
1fa4						call hexout 
1fa4						ld hl, $1efe 
1fa4						push hl 
1fa4						ld hl, $2f9f 
1fa4						push hl 
1fa4						exx 
1fa4					endif 
1fa4				endif 
1fa4			endm 
# End of macro STACKFRAME
1fa4			 
1fa4 2a b5 e5		ld hl,(os_tok_ptr) 
1fa7 cd 39 1c		call forth_apush 
1faa			 
1faa				STACKFRAMECHK ON $1efe $2f9f 
1faa				if DEBUG_STACK_IMB 
1faa					if ON 
1faa						exx 
1faa						ld hl, $2f9f 
1faa						pop de   ; $2f9f 
1faa						call cmp16 
1faa						jr nz, .spnosame 
1faa						ld hl, $1efe 
1faa						pop de   ; $1efe 
1faa						call cmp16 
1faa						jr z, .spfrsame 
1faa						.spnosame: call showsperror 
1faa						.spfrsame: nop 
1faa						exx 
1faa					endif 
1faa				endif 
1faa			endm 
# End of macro STACKFRAMECHK
1faa			 
1faa			execnext: 
1faa			 
1faa			if DEBUG_FORTH_PARSE_EXEC 
1faa						DMARK "KY>" 
1faa			endif 
1faa			; move past token to next word 
1faa			 
1faa 2a b5 e5		ld hl, (os_tok_ptr) 
1fad 3e 00		ld a, 0 
1faf 01 ff 00		ld bc, 255     ; input buffer size 
1fb2 ed b1		cpir 
1fb4			 
1fb4			if DEBUG_FORTH_PARSE_EXEC 
1fb4						DMARK "KY!" 
1fb4				CALLMONITOR 
1fb4			endif	 
1fb4			; TODO this might place hl on the null, so will need to forward on??? 
1fb4			;inc hl   ; see if this gets onto the next item 
1fb4			 
1fb4			 
1fb4			; TODO pass a pointer to the buffer to push 
1fb4			; TODO call function to push 
1fb4			 
1fb4			; look for end of input 
1fb4			 
1fb4			;inc hl 
1fb4			;ld a,(hl) 
1fb4			;cp FORTH_END_BUFFER 
1fb4			;ret z 
1fb4			 
1fb4			 
1fb4 c3 3b 1f		jp exec1 
1fb7			 
1fb7			 
1fb7			 
1fb7			 
1fb7			 
1fb7			 
1fb7			 
1fb7			 
1fb7			 
1fb7			findnexttok: 
1fb7			 
1fb7				; hl is pointer to move 
1fb7				; de is the token to locate 
1fb7			 
1fb7					if DEBUG_FORTH 
1fb7						DMARK "NTK" 
1fb7						CALLMONITOR 
1fb7					endif 
1fb7 d5				push de 
1fb8			 
1fb8			.fnt1:	 
1fb8				; find first char of token to locate 
1fb8			 
1fb8 1a				ld a, (de) 
1fb9 4f				ld c,a 
1fba 7e				ld a,(hl) 
1fbb cd 35 11			call toUpper 
1fbe					if DEBUG_FORTH 
1fbe						DMARK "NT1" 
1fbe						CALLMONITOR 
1fbe					endif 
1fbe b9				cp c 
1fbf			 
1fbf 28 03			jr z, .fnt2cmpmorefirst	 
1fc1			 
1fc1				; first char not found move to next char 
1fc1			 
1fc1 23				inc hl 
1fc2 18 f4			jr .fnt1 
1fc4			 
1fc4			.fnt2cmpmorefirst:	 
1fc4				; first char of token found.  
1fc4			 
1fc4 e5				push hl     ; save start of token just in case it is the right one 
1fc5 d9				exx 
1fc6 e1				pop hl        ; save it to hl' 
1fc7 d9				exx 
1fc8			 
1fc8			 
1fc8			.fnt2cmpmore:	 
1fc8				; compare the rest 
1fc8				 
1fc8 23				inc hl 
1fc9 13				inc de 
1fca				 
1fca 1a				ld a, (de) 
1fcb 4f				ld c,a 
1fcc 7e				ld a,(hl) 
1fcd cd 35 11			call toUpper 
1fd0			 
1fd0					if DEBUG_FORTH 
1fd0						DMARK "NT2" 
1fd0						CALLMONITOR 
1fd0					endif 
1fd0				; c has the token to find char 
1fd0				; a has the mem to scan char 
1fd0			 
1fd0 b9				cp c 
1fd1 28 04			jr z,.fntmatch1 
1fd3			 
1fd3				; they are not the same 
1fd3			 
1fd3					if DEBUG_FORTH 
1fd3						DMARK "NT3" 
1fd3						CALLMONITOR 
1fd3					endif 
1fd3 d1				pop de	; reset de token to look for 
1fd4 d5				push de 
1fd5 18 e1			jr .fnt1 
1fd7				 
1fd7			.fntmatch1: 
1fd7			 
1fd7				; is the same char a null which means we might have a full hit? 
1fd7					if DEBUG_FORTH 
1fd7						DMARK "NT4" 
1fd7						CALLMONITOR 
1fd7					endif 
1fd7			 
1fd7			;	cp 0 
1fd7 b7				or a 
1fd8 28 0b			jr z, .fntmatchyes 
1fda			 
1fda				; are we at the end of the token to find? 
1fda			 
1fda					if DEBUG_FORTH 
1fda						DMARK "NT5" 
1fda						CALLMONITOR 
1fda					endif 
1fda 3e 00			ld a, 0 
1fdc b9				cp c 
1fdd			 
1fdd c2 c8 1f			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
1fe0			 
1fe0					if DEBUG_FORTH 
1fe0						DMARK "NT6" 
1fe0						CALLMONITOR 
1fe0					endif 
1fe0				; token to find is exhusted but no match to stream 
1fe0			 
1fe0				; restore tok pointer and continue on 
1fe0 d1				pop de 
1fe1 d5				push de 
1fe2 c3 b8 1f			jp .fnt1 
1fe5			 
1fe5			 
1fe5			.fntmatchyes: 
1fe5			 
1fe5				; hl now contains the end of the found token 
1fe5			 
1fe5				; get rid of saved token pointer to find 
1fe5			 
1fe5 d1				pop de 
1fe6			 
1fe6					if DEBUG_FORTH 
1fe6						DMARK "NT9" 
1fe6						CALLMONITOR 
1fe6					endif 
1fe6			 
1fe6				; hl will be on the null term so forward on 
1fe6			 
1fe6				; get back the saved start of the token 
1fe6			 
1fe6 d9				exx 
1fe7 e5				push hl     ; save start of token just in case it is the right one 
1fe8 d9				exx 
1fe9 e1				pop hl        ; save it to hl 
1fea			 
1fea c9				ret 
1feb			 
1feb			 
1feb			; LIST needs to find a specific token   
1feb			; FORGET needs to find a spefici token 
1feb			 
1feb			; SAVE needs to find all tokens by flag 
1feb			; WORDS just needs to scan through all  by flag 
1feb			; UWORDS needs to scan through all by flag 
1feb			 
1feb			 
1feb			; given hl as pointer to start of dict look up string 
1feb			; return hl as pointer to start of word block 
1feb			; or 0 if not found 
1feb			 
1feb			forth_find_tok: 
1feb c9				ret 
1fec			 
1fec			; given hl as pointer to dict structure 
1fec			; move to the next dict block structure 
1fec			 
1fec			forth_tok_next: 
1fec				; hl now points to the address of the next word pointer  
1fec				; TODO skip compiled symbol for now 
1fec			;	push de 
1fec 23				inc hl 
1fed 5e				ld e, (hl) 
1fee 23				inc hl 
1fef 56				ld d, (hl) 
1ff0 23				inc hl 
1ff1			 
1ff1 eb				ex de,hl 
1ff2			if DEBUG_FORTH_PARSE_NEXTWORD 
1ff2				push bc 
1ff2				ld bc, (cli_nextword) 
1ff2						DMARK "NXW" 
1ff2				CALLMONITOR 
1ff2				pop bc 
1ff2			endif 
1ff2			;	pop de	 
1ff2 c9				ret 
1ff3			 
1ff3			 
1ff3			 
1ff3			; eof 
# End of file forth_parserv6.asm
1ff3				include "forth_wordsv4.asm" 
1ff3			 
1ff3			; the core word dictionary v4 
1ff3			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
1ff3			 
1ff3			; this is a linked list for each of the system words used 
1ff3			; user defined words will follow the same format but will be in ram 
1ff3			 
1ff3			 
1ff3			; 
1ff3			; 
1ff3			; define linked list: 
1ff3			; 
1ff3			; 1. compiled byte op code 
1ff3			; 2. len of text word 
1ff3			; 3. text word 
1ff3			; 4. ptr to next dictionary word 
1ff3			; 5. asm, calls etc for the word 
1ff3			; 
1ff3			;  if 1 == 0 then last word in dict  
1ff3			;   
1ff3			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
1ff3			;  
1ff3			;  
1ff3			; create basic standard set of words 
1ff3			; 
1ff3			;  
1ff3			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
1ff3			; 2DUP 2DROP 2SWAP  
1ff3			; @ C@ - get byte  
1ff3			; ! C! - store byte 
1ff3			; 0< true if less than zero 
1ff3			; 0= true if zero 
1ff3			; < >  
1ff3			; = true if same 
1ff3			; variables 
1ff3			 
1ff3			 
1ff3			; Hardware specific words I may need 
1ff3			; 
1ff3			; IN OUT  
1ff3			; calls to key util functions 
1ff3			; calls to hardward abstraction stuff 
1ff3			; easy control of frame buffers and lcd i/o 
1ff3			; keyboard  
1ff3			 
1ff3			 
1ff3			;DICT: macro 
1ff3			; op_code, len, word, next 
1ff3			;    word: 
1ff3			;    db op_code 
1ff3			;    ds word zero term 
1ff3			;    dw next 
1ff3			;    endm 
1ff3			 
1ff3			 
1ff3			 
1ff3			 
1ff3			; op code 1 is a flag for user define words which are to be handled differently 
1ff3			 
1ff3			 
1ff3			; 
1ff3			; 
1ff3			;    TODO on entry to a word this should be the expected environment 
1ff3			;    hl - tos value if number then held, if string this is the ptr 
1ff3			;    de -  
1ff3			 
1ff3			 
1ff3			; opcode ranges 
1ff3			; 0 - end of word dict 
1ff3			; 255 - user define words 
1ff3			 
1ff3			sysdict: 
1ff3			include "forth_opcodes.asm" 
1ff3			; op codes for forth keywords 
1ff3			 
1ff3			; Changing use of opcodes to flag is the word exists in compiled form or not.  
1ff3			; This provides a means to compile uwords if required for higher performance 
1ff3			; by avoiding the use of the keyword parser and just jumping directly to the code 
1ff3			; Actually there is already a flag for if the code exists as binary thinking about it... 
1ff3			 
1ff3			 
1ff3			 
1ff3			 
1ff3			 
1ff3			; free to use code 0  
1ff3				OPCODE_HEAP: equ  1 
1ff3				OPCODE_EXEC: equ 2 
1ff3				OPCODE_DUP: equ 3 
1ff3				OPCODE_SWAP: equ 4 
1ff3				OPCODE_COLN: equ 5 
1ff3				OPCODE_SCOLN: equ 6 
1ff3				OPCODE_DROP: equ 7 
1ff3				OPCODE_DUP2: equ 8 
1ff3				OPCODE_DROP2: equ 9 
1ff3				OPCODE_SWAP2: equ 10 
1ff3				OPCODE_AT: equ 11 
1ff3				OPCODE_CAT: equ 12 
1ff3				OPCODE_BANG: equ 13 
1ff3				OPCODE_CBANG: equ 14 
1ff3				OPCODE_SCALL: equ 15 
1ff3				OPCODE_DEPTH: equ 16 
1ff3				OPCODE_OVER: equ 17 
1ff3				OPCODE_PAUSE: equ 18 
1ff3				OPCODE_PAUSES: equ 19 
1ff3				OPCODE_ROT: equ 20 
1ff3			;free to reuse	OPCODE_WORDS: equ 21 
1ff3			        OPCODE_NOT: equ 21 
1ff3				OPCODE_UWORDS: equ 22 
1ff3				OPCODE_BP: equ 23 
1ff3				OPCODE_MONITOR: equ 24  
1ff3				OPCODE_MALLOC: equ 25 
1ff3				OPCODE_FREE: equ 26 
1ff3				OPCODE_LIST: equ 27 
1ff3				OPCODE_FORGET: equ 28 
1ff3				OPCODE_NOP: equ 29 
1ff3				OPCODE_COMO: equ 30 
1ff3				OPCODE_COMC: equ 31 
1ff3			;free to reuse	OPCODE_ENDCORE: equ 32 
1ff3				OPCODE_AFTERSOUND: equ 33 
1ff3				OPCODE_GP2: equ 34 
1ff3				OPCODE_GP3: equ 35 
1ff3				OPCODE_GP4: equ 36 
1ff3				OPCODE_SIN: equ 37 
1ff3				OPCODE_SOUT: equ 38 
1ff3				OPCODE_SPIO: equ 39 
1ff3				OPCODE_SPICEH: equ 40 
1ff3				OPCODE_SPIOb: equ 41 
1ff3				OPCODE_SPII: equ 42 
1ff3				OPCODE_SESEL: equ 43 
1ff3				OPCODE_CARTDEV: equ 44 
1ff3			; free to reuse	OPCODE_ENDDEVICE: equ 45 
1ff3				OPCODE_FB: equ 46 
1ff3				OPCODE_EMIT: equ 47 
1ff3				OPCODE_DOTH: equ 48 
1ff3				OPCODE_DOTF: equ 49 
1ff3				OPCODE_DOT: equ 50 
1ff3				OPCODE_CLS: equ 51 
1ff3				OPCODE_DRAW: equ 52 
1ff3				OPCODE_DUMP: equ 53 
1ff3				OPCODE_CDUMP: equ 54 
1ff3				OPCODE_DAT: equ 55 
1ff3				OPCODE_HOME: equ 56 
1ff3				OPCODE_SPACE: equ 57 
1ff3				OPCODE_SPACES: equ 58 
1ff3				OPCODE_SCROLL: equ 59 
1ff3				OPCODE_ATQ: equ 60 
1ff3				OPCODE_AUTODSP: equ 61 
1ff3				OPCODE_MENU: equ 62 
1ff3			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
1ff3				OPCODE_THEN: equ 64 
1ff3				OPCODE_ELSE: equ 65 
1ff3				OPCODE_DO: equ 66 
1ff3				OPCODE_LOOP: equ 67 
1ff3				OPCODE_I: equ 68 
1ff3				OPCODE_DLOOP: equ 69  
1ff3				OPCODE_REPEAT: equ 70  
1ff3				OPCODE_UNTIL: equ 71 
1ff3				OPCODE_ENDFLOW: equ 72 
1ff3				OPCODE_WAITK: equ 73 
1ff3				OPCODE_ACCEPT: equ 74 
1ff3				OPCODE_EDIT: equ 75 
1ff3			;free to reuse	OPCODE_ENDKEY: equ 76 
1ff3				OPCODE_LZERO: equ 77 
1ff3				OPCODE_TZERO: equ 78 
1ff3				OPCODE_LESS: equ 79 
1ff3				OPCODE_GT: equ 80 
1ff3				OPCODE_EQUAL: equ 81  
1ff3			;free to reuse	OPCODE_ENDLOGIC: equ 82 
1ff3				OPCODE_NEG: equ 83 
1ff3				OPCODE_DIV: equ 84 
1ff3				OPCODE_MUL: equ 85 
1ff3				OPCODE_MIN: equ 86 
1ff3				OPCODE_MAX: equ 87 
1ff3				OPCODE_RND16: equ 88 
1ff3				OPCODE_RND8: equ 89 
1ff3				OPCODE_RND: equ 90 
1ff3			;free to reuse	OPCODE_ENDMATHS: equ 91  
1ff3				OPCODE_BYNAME: equ 92 
1ff3				OPCODE_DIR: equ 93 
1ff3				OPCODE_SAVE: equ 94 
1ff3				OPCODE_LOAD: equ 95 
1ff3				OPCODE_BSAVE: equ 96 
1ff3				OPCODE_BLOAD: equ 97 
1ff3				OPCODE_SEO: equ 98  
1ff3				OPCODE_SEI: equ 99 
1ff3				OPCODE_SFREE: equ 100 
1ff3				OPCODE_SIZE: equ 101 
1ff3				OPCODE_CREATE: equ 102 
1ff3				OPCODE_APPEND: equ 103 
1ff3				OPCODE_SDEL: equ 104 
1ff3				OPCODE_OPEN: equ 105 
1ff3				OPCODE_READ: equ 106 
1ff3				OPCODE_EOF: equ 106 
1ff3				OPCODE_FORMAT: equ 107 
1ff3				OPCODE_LABEL: equ 108 
1ff3				OPCODE_LABELS: equ 109 
1ff3			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
1ff3				OPCODE_UPPER: equ 111 
1ff3				OPCODE_LOWER: equ 112 
1ff3				OPCODE_SUBSTR: equ 113 
1ff3				OPCODE_LEFT: equ 114 
1ff3				OPCODE_RIGHT: equ 115 
1ff3				OPCODE_STR2NUM: equ 116 
1ff3				OPCODE_NUM2STR: equ 117 
1ff3				OPCODE_CONCAT: equ 118 
1ff3				OPCODE_FIND: equ 119 
1ff3				OPCODE_LEN: equ 120 
1ff3				OPCODE_CHAR: equ 121 
1ff3			; free to reuse	OPCODE_STRLEN: equ 122 
1ff3			; free to reuse	OPCODE_ENDSTR: equ 123 
1ff3				OPCODE_V0S: equ 124 
1ff3				OPCODE_V0Q: equ 125 
1ff3				OPCODE_V1S: equ 126 
1ff3				OPCODE_V1Q: equ 127 
1ff3				OPCODE_V2S: equ 128 
1ff3				OPCODE_V2Q: equ 129 
1ff3				OPCODE_V3S: equ 130 
1ff3				OPCODE_V3Q: equ 131 
1ff3			;free to reuse	OPCODE_END: equ 132 
1ff3				OPCODE_ZDUP: equ 133 
1ff3			 
1ff3			; eof 
# End of file forth_opcodes.asm
1ff3			 
1ff3			include "forth_words_core.asm" 
1ff3			 
1ff3			; | ## Core Words 
1ff3			 
1ff3			;if MALLOC_4 
1ff3			 
1ff3			.HEAP: 
1ff3			CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
1ff3 15				db WORD_SYS_CORE+OPCODE_HEAP             
1ff4 35 20			dw .EXEC            
1ff6 05				db 4 + 1 
1ff7 .. 00			db "HEAP",0              
1ffc				endm 
# End of macro CWHEAD
1ffc			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
1ffc			; | | u1 - Current number of bytes in the heap 
1ffc			; | | u2 - Remaining bytes left on the heap 
1ffc			; | |  
1ffc			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
1ffc			 
1ffc			 
1ffc				if DEBUG_FORTH_WORDS_KEY 
1ffc					DMARK "HEP" 
1ffc f5				push af  
1ffd 3a 11 20			ld a, (.dmark)  
2000 32 5e ee			ld (debug_mark),a  
2003 3a 12 20			ld a, (.dmark+1)  
2006 32 5f ee			ld (debug_mark+1),a  
2009 3a 13 20			ld a, (.dmark+2)  
200c 32 60 ee			ld (debug_mark+2),a  
200f 18 03			jr .pastdmark  
2011 ..			.dmark: db "HEP"  
2014 f1			.pastdmark: pop af  
2015			endm  
# End of macro DMARK
2015					CALLMONITOR 
2015 cd 6b ee			call debug_vector  
2018				endm  
# End of macro CALLMONITOR
2018				endif 
2018 2a a9 67			ld hl, (free_list )      
201b 11 ae 67			ld de, heap_start 
201e			 
201e ed 52			sbc hl, de  
2020			 
2020 cd d7 1a			call forth_push_numhl 
2023			 
2023			 
2023 ed 5b a9 67		ld de, (free_list )      
2027 21 8f e2			ld hl, heap_end 
202a			 
202a ed 52			sbc hl, de 
202c			 
202c cd d7 1a			call forth_push_numhl 
202f				 
202f			 
202f				 
202f			 
202f			 
202f			 
202f				NEXTW 
202f cd 68 ee			call parse_vector 
2032 c3 ba 1e			jp macro_next 
2035				endm 
# End of macro NEXTW
2035			;endif 
2035			 
2035			.EXEC: 
2035			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
2035			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
2035			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
2035			;; > > 
2035			;; > >   
2035			;	STACKFRAME OFF $5efe $5f9f 
2035			; 
2035			;		if DEBUG_FORTH_WORDS_KEY 
2035			;			DMARK "EXE" 
2035			;			CALLMONITOR 
2035			;		endif 
2035			; 
2035			;	FORTH_DSP_VALUEHL 
2035			; 
2035			;	FORTH_DSP_POP 
2035			; 
2035			;		if DEBUG_FORTH_WORDS 
2035			;			DMARK "EX1" 
2035			;			CALLMONITOR 
2035			;		endif 
2035			;;	ld e,(hl) 
2035			;;	inc hl 
2035			;;	ld d,(hl) 
2035			;;	ex de,hl 
2035			; 
2035			;;		if DEBUG_FORTH_WORDS 
2035			;;			DMARK "EX2" 
2035			;;			CALLMONITOR 
2035			;;		endif 
2035			;	push hl 
2035			; 
2035			;	;ld a, 0 
2035			;	;ld a, FORTH_END_BUFFER 
2035			;	call strlenz 
2035			;	inc hl   ; include zero term to copy 
2035			;	inc hl   ; include term 
2035			;	inc hl   ; include term 
2035			;	ld b,0 
2035			;	ld c,l 
2035			;	pop hl 
2035			;	ld de, execscratch 
2035			;		if DEBUG_FORTH_WORDS 
2035			;			DMARK "EX3" 
2035			;			CALLMONITOR 
2035			;		endif 
2035			;	ldir 
2035			; 
2035			; 
2035			;	ld hl, execscratch 
2035			; 
2035			;		if DEBUG_FORTH_WORDS 
2035			;			DMARK "EXe" 
2035			;			CALLMONITOR 
2035			;		endif 
2035			; 
2035			;	call forthparse 
2035			;	call forthexec 
2035			;;	call forthexec_cleanup 
2035			;;	call forthparse 
2035			;;	call forthexec 
2035			; 
2035			;	STACKFRAMECHK OFF $5efe $5f9f 
2035			; 
2035			;	; an immediate word so no need to process any more words 
2035			;	ret 
2035			;	NEXTW 
2035			 
2035			; dead code - old version  
2035			;	FORTH_RSP_NEXT 
2035			 
2035			;  
2035			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
2035			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
2035			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2035			;	push hl 
2035			;	push de 
2035			;	push bc 
2035			; 
2035			; 
2035			;		if DEBUG_FORTH_WORDS_KEY 
2035			;			DMARK "EXR" 
2035			;			CALLMONITOR 
2035			;		endif 
2035			; 
2035			; 
2035			; 
2035			;	;v5 FORTH_DSP_VALUE 
2035			;	FORTH_DSP_VALUEHL 
2035			; 
2035			;	; TODO do string type checks 
2035			; 
2035			;;v5	inc hl   ; skip type 
2035			; 
2035			;	push hl  ; source code  
2035			;		if DEBUG_FORTH_WORDS 
2035			;			DMARK "EX1" 
2035			;			CALLMONITOR 
2035			;		endif 
2035			;	ld a, 0 
2035			;	call strlent 
2035			; 
2035			;	inc hl 
2035			;	inc hl 
2035			;	inc hl 
2035			;	inc hl 
2035			; 
2035			;	push hl    ; size 
2035			; 
2035			;		if DEBUG_FORTH_WORDS 
2035			;			DMARK "EX2" 
2035			;			CALLMONITOR 
2035			;		endif 
2035			;	call malloc 
2035			; 
2035			;	ex de, hl    ; de now contains malloc area 
2035			;	pop bc   	; get byte count 
2035			;	pop hl      ; get string to copy 
2035			; 
2035			;	push de     ; save malloc for free later 
2035			; 
2035			;		if DEBUG_FORTH_WORDS 
2035			;			DMARK "EX3" 
2035			;			CALLMONITOR 
2035			;		endif 
2035			;	ldir       ; duplicate string 
2035			; 
2035			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
2035			;	 
2035			;	; TODO fix the parse would be better than this...  
2035			;	ex de, hl 
2035			;	dec hl 
2035			;	ld a, 0 
2035			;	ld (hl), a 
2035			;	dec hl 
2035			;	ld a, ' ' 
2035			;	ld (hl), a 
2035			;	dec hl 
2035			;	ld (hl), a 
2035			; 
2035			;	dec hl 
2035			;	ld (hl), a 
2035			; 
2035			; 
2035			;	FORTH_DSP_POP  
2035			; 
2035			;	pop hl     
2035			;	push hl    ; save malloc area 
2035			; 
2035			;		if DEBUG_FORTH_WORDS 
2035			;			DMARK "EX4" 
2035			;			CALLMONITOR 
2035			;		endif 
2035			; 
2035			;	call forthparse 
2035			;	call forthexec 
2035			;	 
2035			;	pop hl 
2035			;	if DEBUG_FORTH_WORDS 
2035			;		DMARK "EX5" 
2035			;		CALLMONITOR 
2035			;	endif 
2035			; 
2035			;	if FORTH_ENABLE_FREE 
2035			;	call free 
2035			;	endif 
2035			; 
2035			;	if DEBUG_FORTH_WORDS 
2035			;		DMARK "EX6" 
2035			;		CALLMONITOR 
2035			;	endif 
2035			; 
2035			;	pop bc 
2035			;	pop de 
2035			;	pop hl 
2035			;;	FORTH_RSP_POP	  
2035			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
2035			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
2035			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
2035			; 
2035			;	if DEBUG_FORTH_WORDS 
2035			;		DMARK "EX7" 
2035			;		CALLMONITOR 
2035			;	endif 
2035			;	NEXTW 
2035			 
2035			;.STKEXEC: 
2035			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
2035			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
2035			; 
2035			; 
2035			;		if DEBUG_FORTH_WORDS_KEY 
2035			;			DMARK "STX" 
2035			;			CALLMONITOR 
2035			;		endif 
2035			; 
2035			;	FORTH_DSP_VALUEHL 
2035			; 
2035			;	ld (store_tmp1), hl    ; count 
2035			; 
2035			;	FORTH_DSP_POP 
2035			;.stkexec1: 
2035			;	ld hl, (store_tmp1)   ; count 
2035			;	ld a, 0 
2035			;	cp l 
2035			;	ret z 
2035			; 
2035			;	dec hl 
2035			;	ld (store_tmp1), hl    ; count 
2035			;	 
2035			;	FORTH_DSP_VALUEHL 
2035			;	push hl 
2035			;	 
2035			;		if DEBUG_FORTH_WORDS 
2035			;			DMARK "EXp" 
2035			;			CALLMONITOR 
2035			;		endif 
2035			;	FORTH_DSP_POP 
2035			; 
2035			;	call strlenz 
2035			;	inc hl   ; include zero term to copy 
2035			;	inc hl   ; include zero term to copy 
2035			;	inc hl   ; include zero term to copy 
2035			;	ld b,0 
2035			;	ld c,l 
2035			;	pop hl 
2035			;	ld de, execscratch 
2035			;		if DEBUG_FORTH_WORDS 
2035			;			DMARK "EX3" 
2035			;			CALLMONITOR 
2035			;		endif 
2035			;	ldir 
2035			; 
2035			; 
2035			;	ld hl, execscratch 
2035			; 
2035			;		if DEBUG_FORTH_WORDS 
2035			;			DMARK "EXP" 
2035			;			CALLMONITOR 
2035			;		endif 
2035			; 
2035			;	call forthparse 
2035			;	ld hl, execscratch 
2035			;		if DEBUG_FORTH_WORDS 
2035			;			DMARK "EXx" 
2035			;			CALLMONITOR 
2035			;		endif 
2035			;	call forthexec 
2035			; 
2035			;	jp .stkexec1 
2035			; 
2035			;	ret 
2035			 
2035			 
2035			.DUP: 
2035			CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
2035 17				db WORD_SYS_CORE+OPCODE_DUP             
2036 b1 20			dw .ZDUP            
2038 04				db 3 + 1 
2039 .. 00			db "DUP",0              
203d				endm 
# End of macro CWHEAD
203d			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
203d			; | | >[!NOTE] 
203d			; | | > If the duplicated item is a string it is safely duplicated 
203d			 
203d				if DEBUG_FORTH_WORDS_KEY 
203d					DMARK "DUP" 
203d f5				push af  
203e 3a 52 20			ld a, (.dmark)  
2041 32 5e ee			ld (debug_mark),a  
2044 3a 53 20			ld a, (.dmark+1)  
2047 32 5f ee			ld (debug_mark+1),a  
204a 3a 54 20			ld a, (.dmark+2)  
204d 32 60 ee			ld (debug_mark+2),a  
2050 18 03			jr .pastdmark  
2052 ..			.dmark: db "DUP"  
2055 f1			.pastdmark: pop af  
2056			endm  
# End of macro DMARK
2056					CALLMONITOR 
2056 cd 6b ee			call debug_vector  
2059				endm  
# End of macro CALLMONITOR
2059				endif 
2059			 
2059				FORTH_DSP 
2059 cd 99 1c			call macro_forth_dsp 
205c				endm 
# End of macro FORTH_DSP
205c			 
205c 7e				ld a, (HL) 
205d fe 01			cp DS_TYPE_STR 
205f 20 28			jr nz, .dupinum 
2061			 
2061				; push another string 
2061			 
2061				FORTH_DSP_VALUEHL     		 
2061 cd d3 1c			call macro_dsp_valuehl 
2064				endm 
# End of macro FORTH_DSP_VALUEHL
2064			 
2064			if DEBUG_FORTH_WORDS 
2064				DMARK "DUs" 
2064 f5				push af  
2065 3a 79 20			ld a, (.dmark)  
2068 32 5e ee			ld (debug_mark),a  
206b 3a 7a 20			ld a, (.dmark+1)  
206e 32 5f ee			ld (debug_mark+1),a  
2071 3a 7b 20			ld a, (.dmark+2)  
2074 32 60 ee			ld (debug_mark+2),a  
2077 18 03			jr .pastdmark  
2079 ..			.dmark: db "DUs"  
207c f1			.pastdmark: pop af  
207d			endm  
# End of macro DMARK
207d				CALLMONITOR 
207d cd 6b ee			call debug_vector  
2080				endm  
# End of macro CALLMONITOR
2080			endif 
2080 cd 41 1b			call forth_push_str 
2083			 
2083				NEXTW 
2083 cd 68 ee			call parse_vector 
2086 c3 ba 1e			jp macro_next 
2089				endm 
# End of macro NEXTW
2089			 
2089			 
2089			.dupinum: 
2089				 
2089			 
2089			 
2089				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2089 cd d3 1c			call macro_dsp_valuehl 
208c				endm 
# End of macro FORTH_DSP_VALUEHL
208c			 
208c			; TODO add floating point number detection 
208c			 
208c			if DEBUG_FORTH_WORDS 
208c				DMARK "DUi" 
208c f5				push af  
208d 3a a1 20			ld a, (.dmark)  
2090 32 5e ee			ld (debug_mark),a  
2093 3a a2 20			ld a, (.dmark+1)  
2096 32 5f ee			ld (debug_mark+1),a  
2099 3a a3 20			ld a, (.dmark+2)  
209c 32 60 ee			ld (debug_mark+2),a  
209f 18 03			jr .pastdmark  
20a1 ..			.dmark: db "DUi"  
20a4 f1			.pastdmark: pop af  
20a5			endm  
# End of macro DMARK
20a5				CALLMONITOR 
20a5 cd 6b ee			call debug_vector  
20a8				endm  
# End of macro CALLMONITOR
20a8			endif 
20a8			 
20a8 cd d7 1a			call forth_push_numhl 
20ab				NEXTW 
20ab cd 68 ee			call parse_vector 
20ae c3 ba 1e			jp macro_next 
20b1				endm 
# End of macro NEXTW
20b1			.ZDUP: 
20b1			CWHEAD .DMRK OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
20b1 99				db WORD_SYS_CORE+OPCODE_ZDUP             
20b2 eb 20			dw .DMRK            
20b4 05				db 4 + 1 
20b5 .. 00			db "?DUP",0              
20ba				endm 
# End of macro CWHEAD
20ba			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero (Only works for numerics) | DONE 
20ba			; | | >[!NOTE] 
20ba			; | | > If the duplicated item is a string it is not safely duplicated and remain as pointer to the origin 
20ba			 
20ba				if DEBUG_FORTH_WORDS_KEY 
20ba					DMARK "qDU" 
20ba f5				push af  
20bb 3a cf 20			ld a, (.dmark)  
20be 32 5e ee			ld (debug_mark),a  
20c1 3a d0 20			ld a, (.dmark+1)  
20c4 32 5f ee			ld (debug_mark+1),a  
20c7 3a d1 20			ld a, (.dmark+2)  
20ca 32 60 ee			ld (debug_mark+2),a  
20cd 18 03			jr .pastdmark  
20cf ..			.dmark: db "qDU"  
20d2 f1			.pastdmark: pop af  
20d3			endm  
# End of macro DMARK
20d3					CALLMONITOR 
20d3 cd 6b ee			call debug_vector  
20d6				endm  
# End of macro CALLMONITOR
20d6				endif 
20d6				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
20d6 cd d3 1c			call macro_dsp_valuehl 
20d9				endm 
# End of macro FORTH_DSP_VALUEHL
20d9			 
20d9 e5				push hl 
20da			 
20da				; is it a zero? 
20da			 
20da 3e 00			ld a, 0 
20dc 84				add h 
20dd 85				add l 
20de			 
20de e1				pop hl 
20df			 
20df			;	cp 0 
20df b7				or a 
20e0 28 03			jr z, .dup2orig 
20e2			 
20e2			 
20e2 cd d7 1a			call forth_push_numhl 
20e5			 
20e5			 
20e5			; TODO add floating point number detection 
20e5			 
20e5			.dup2orig: 
20e5			 
20e5				NEXTW 
20e5 cd 68 ee			call parse_vector 
20e8 c3 ba 1e			jp macro_next 
20eb				endm 
# End of macro NEXTW
20eb			.DMRK: 
20eb			CWHEAD .LSHIFT OPCODE_ZDUP "DMARK" 5 WORD_FLAG_CODE 
20eb 99				db WORD_SYS_CORE+OPCODE_ZDUP             
20ec 2b 21			dw .LSHIFT            
20ee 06				db 5 + 1 
20ef .. 00			db "DMARK",0              
20f5				endm 
# End of macro CWHEAD
20f5			; | DMARK ( s --  )  Set the debug marker id to first three chars of s | DONE 
20f5			; | | Most useful for tracing your code for errors as you can set various markers to display when MONITOR is called 
20f5				if DEBUG_FORTH_WORDS_KEY 
20f5					DMARK "DMK" 
20f5 f5				push af  
20f6 3a 0a 21			ld a, (.dmark)  
20f9 32 5e ee			ld (debug_mark),a  
20fc 3a 0b 21			ld a, (.dmark+1)  
20ff 32 5f ee			ld (debug_mark+1),a  
2102 3a 0c 21			ld a, (.dmark+2)  
2105 32 60 ee			ld (debug_mark+2),a  
2108 18 03			jr .pastdmark  
210a ..			.dmark: db "DMK"  
210d f1			.pastdmark: pop af  
210e			endm  
# End of macro DMARK
210e					CALLMONITOR 
210e cd 6b ee			call debug_vector  
2111				endm  
# End of macro CALLMONITOR
2111				endif 
2111				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2111 cd d3 1c			call macro_dsp_valuehl 
2114				endm 
# End of macro FORTH_DSP_VALUEHL
2114			 
2114 7e				ld a, (hl) 
2115 32 5e ee			ld (debug_mark),a 
2118 23				inc hl 
2119 7e				ld a, (hl) 
211a 32 5f ee			ld (debug_mark+1),a 
211d 23				inc hl 
211e 7e				ld a, (hl) 
211f 32 60 ee			ld (debug_mark+2),a 
2122			 
2122			 
2122				FORTH_DSP_POP 
2122 cd 8b 1d			call macro_forth_dsp_pop 
2125				endm 
# End of macro FORTH_DSP_POP
2125				NEXTW 
2125 cd 68 ee			call parse_vector 
2128 c3 ba 1e			jp macro_next 
212b				endm 
# End of macro NEXTW
212b			.LSHIFT: 
212b			CWHEAD .RSHIFT OPCODE_ZDUP "LSHIFT" 6 WORD_FLAG_CODE 
212b 99				db WORD_SYS_CORE+OPCODE_ZDUP             
212c 62 21			dw .RSHIFT            
212e 07				db 6 + 1 
212f .. 00			db "LSHIFT",0              
2136				endm 
# End of macro CWHEAD
2136			; | LSHIFT ( w -- w )    16 bit left shift | DONE 
2136				if DEBUG_FORTH_WORDS_KEY 
2136					DMARK "LSH" 
2136 f5				push af  
2137 3a 4b 21			ld a, (.dmark)  
213a 32 5e ee			ld (debug_mark),a  
213d 3a 4c 21			ld a, (.dmark+1)  
2140 32 5f ee			ld (debug_mark+1),a  
2143 3a 4d 21			ld a, (.dmark+2)  
2146 32 60 ee			ld (debug_mark+2),a  
2149 18 03			jr .pastdmark  
214b ..			.dmark: db "LSH"  
214e f1			.pastdmark: pop af  
214f			endm  
# End of macro DMARK
214f					CALLMONITOR 
214f cd 6b ee			call debug_vector  
2152				endm  
# End of macro CALLMONITOR
2152				endif 
2152				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2152 cd d3 1c			call macro_dsp_valuehl 
2155				endm 
# End of macro FORTH_DSP_VALUEHL
2155				FORTH_DSP_POP 
2155 cd 8b 1d			call macro_forth_dsp_pop 
2158				endm 
# End of macro FORTH_DSP_POP
2158			 
2158 29				add hl, hl 
2159 cd d7 1a			call forth_push_numhl 
215c				NEXTW 
215c cd 68 ee			call parse_vector 
215f c3 ba 1e			jp macro_next 
2162				endm 
# End of macro NEXTW
2162			.RSHIFT: 
2162			CWHEAD .SWAP OPCODE_ZDUP "RSHIFT" 6 WORD_FLAG_CODE 
2162 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2163 9c 21			dw .SWAP            
2165 07				db 6 + 1 
2166 .. 00			db "RSHIFT",0              
216d				endm 
# End of macro CWHEAD
216d			; | RSHIFT ( w -- w )    16 bit right shift | DONE 
216d				if DEBUG_FORTH_WORDS_KEY 
216d					DMARK "RSH" 
216d f5				push af  
216e 3a 82 21			ld a, (.dmark)  
2171 32 5e ee			ld (debug_mark),a  
2174 3a 83 21			ld a, (.dmark+1)  
2177 32 5f ee			ld (debug_mark+1),a  
217a 3a 84 21			ld a, (.dmark+2)  
217d 32 60 ee			ld (debug_mark+2),a  
2180 18 03			jr .pastdmark  
2182 ..			.dmark: db "RSH"  
2185 f1			.pastdmark: pop af  
2186			endm  
# End of macro DMARK
2186					CALLMONITOR 
2186 cd 6b ee			call debug_vector  
2189				endm  
# End of macro CALLMONITOR
2189				endif 
2189				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2189 cd d3 1c			call macro_dsp_valuehl 
218c				endm 
# End of macro FORTH_DSP_VALUEHL
218c				FORTH_DSP_POP 
218c cd 8b 1d			call macro_forth_dsp_pop 
218f				endm 
# End of macro FORTH_DSP_POP
218f cb 3c			srl h 
2191 cb 1d			rr l 
2193 cd d7 1a			call forth_push_numhl 
2196				NEXTW 
2196 cd 68 ee			call parse_vector 
2199 c3 ba 1e			jp macro_next 
219c				endm 
# End of macro NEXTW
219c			.SWAP: 
219c			CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
219c 18				db WORD_SYS_CORE+OPCODE_SWAP             
219d f3 21			dw .COLN            
219f 05				db 4 + 1 
21a0 .. 00			db "SWAP",0              
21a5				endm 
# End of macro CWHEAD
21a5			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
21a5				if DEBUG_FORTH_WORDS_KEY 
21a5					DMARK "SWP" 
21a5 f5				push af  
21a6 3a ba 21			ld a, (.dmark)  
21a9 32 5e ee			ld (debug_mark),a  
21ac 3a bb 21			ld a, (.dmark+1)  
21af 32 5f ee			ld (debug_mark+1),a  
21b2 3a bc 21			ld a, (.dmark+2)  
21b5 32 60 ee			ld (debug_mark+2),a  
21b8 18 03			jr .pastdmark  
21ba ..			.dmark: db "SWP"  
21bd f1			.pastdmark: pop af  
21be			endm  
# End of macro DMARK
21be					CALLMONITOR 
21be cd 6b ee			call debug_vector  
21c1				endm  
# End of macro CALLMONITOR
21c1				endif 
21c1			 
21c1			; DONE Use os stack swap memory 
21c1			 
21c1				FORTH_DSP_PTR 0     ; TOS 
21c1 2a e1 e9			ld hl,(cli_data_sp) 
21c4 11 00 00			ld de, 0 * 3 
21c7 ed 52			sbc hl, de 
21c9				endm 
# End of macro FORTH_DSP_PTR
21c9 cd 0a 1e			call hltostack1 
21cc			  
21cc				FORTH_DSP_PTR 1     ; TOS 
21cc 2a e1 e9			ld hl,(cli_data_sp) 
21cf 11 03 00			ld de, 1 * 3 
21d2 ed 52			sbc hl, de 
21d4				endm 
# End of macro FORTH_DSP_PTR
21d4 cd 10 1e			call hltostack2 
21d7			 
21d7				FORTH_DSP_PTR 0     ; TOS 
21d7 2a e1 e9			ld hl,(cli_data_sp) 
21da 11 00 00			ld de, 0 * 3 
21dd ed 52			sbc hl, de 
21df				endm 
# End of macro FORTH_DSP_PTR
21df cd 28 1e			call hlfromstack2 
21e2			 
21e2				FORTH_DSP_PTR 1     ; TOS 
21e2 2a e1 e9			ld hl,(cli_data_sp) 
21e5 11 03 00			ld de, 1 * 3 
21e8 ed 52			sbc hl, de 
21ea				endm 
# End of macro FORTH_DSP_PTR
21ea cd 22 1e			call hlfromstack1 
21ed			;	FORTH_DSP_VALUEHL 
21ed			;	push hl     ; w2 
21ed			; 
21ed			;	FORTH_DSP_POP 
21ed			; 
21ed			;	FORTH_DSP_VALUEHL 
21ed			; 
21ed			;	FORTH_DSP_POP 
21ed			; 
21ed			;	pop de     ; w2	, hl = w1 
21ed			; 
21ed			;	ex de, hl 
21ed			;	push de 
21ed			; 
21ed			;	call forth_push_numhl 
21ed			; 
21ed			;	pop hl 
21ed			; 
21ed			;	call forth_push_numhl 
21ed				 
21ed			 
21ed				NEXTW 
21ed cd 68 ee			call parse_vector 
21f0 c3 ba 1e			jp macro_next 
21f3				endm 
# End of macro NEXTW
21f3			.COLN: 
21f3			CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
21f3 19				db WORD_SYS_CORE+OPCODE_COLN             
21f4 7e 23			dw .SCOLN            
21f6 02				db 1 + 1 
21f7 .. 00			db ":",0              
21f9				endm 
# End of macro CWHEAD
21f9			; | : ( -- )         Create new word | DONE 
21f9			 
21f9				if DEBUG_FORTH_WORDS_KEY 
21f9					DMARK "CLN" 
21f9 f5				push af  
21fa 3a 0e 22			ld a, (.dmark)  
21fd 32 5e ee			ld (debug_mark),a  
2200 3a 0f 22			ld a, (.dmark+1)  
2203 32 5f ee			ld (debug_mark+1),a  
2206 3a 10 22			ld a, (.dmark+2)  
2209 32 60 ee			ld (debug_mark+2),a  
220c 18 03			jr .pastdmark  
220e ..			.dmark: db "CLN"  
2211 f1			.pastdmark: pop af  
2212			endm  
# End of macro DMARK
2212					CALLMONITOR 
2212 cd 6b ee			call debug_vector  
2215				endm  
# End of macro CALLMONITOR
2215				endif 
2215			STACKFRAME OFF $8efe $989f 
2215				if DEBUG_STACK_IMB 
2215					if OFF 
2215						exx 
2215						ld de, $8efe 
2215						ld a, d 
2215						ld hl, curframe 
2215						call hexout 
2215						ld a, e 
2215						ld hl, curframe+2 
2215						call hexout 
2215						ld hl, $8efe 
2215						push hl 
2215						ld hl, $989f 
2215						push hl 
2215						exx 
2215					endif 
2215				endif 
2215			endm 
# End of macro STACKFRAME
2215			; get parser buffer length  of new word 
2215			 
2215			 
2215			 
2215				; move tok past this to start of name defintition 
2215				; TODO get word to define 
2215				; TODO Move past word token 
2215				; TODO get length of string up to the ';' 
2215			 
2215 2a b5 e5		ld hl, (os_tok_ptr) 
2218 23			inc hl 
2219 23			inc hl 
221a			 
221a 3e 3b		ld a, ';' 
221c cd 49 11		call strlent 
221f			 
221f 7d			ld a,l 
2220 32 a4 e2		ld (os_new_parse_len), a 
2223			 
2223			 
2223			if DEBUG_FORTH_UWORD 
2223 ed 5b b5 e5	ld de, (os_tok_ptr) 
2227					DMARK ":01" 
2227 f5				push af  
2228 3a 3c 22			ld a, (.dmark)  
222b 32 5e ee			ld (debug_mark),a  
222e 3a 3d 22			ld a, (.dmark+1)  
2231 32 5f ee			ld (debug_mark+1),a  
2234 3a 3e 22			ld a, (.dmark+2)  
2237 32 60 ee			ld (debug_mark+2),a  
223a 18 03			jr .pastdmark  
223c ..			.dmark: db ":01"  
223f f1			.pastdmark: pop af  
2240			endm  
# End of macro DMARK
2240			CALLMONITOR 
2240 cd 6b ee			call debug_vector  
2243				endm  
# End of macro CALLMONITOR
2243			endif 
2243			 
2243			; 
2243			;  new word memory layout: 
2243			;  
2243			;    : adg 6666 ;  
2243			; 
2243			;    db   1     ; user defined word  
2243 23			inc hl    
2244			;    dw   sysdict 
2244 23			inc hl 
2245 23			inc hl 
2246			;    db <word len>+1 (for null) 
2246 23			inc hl 
2247			;    db .... <word> 
2247			; 
2247			 
2247 23			inc hl    ; some extras for the word preamble before the above 
2248 23			inc hl 
2249 23			inc hl 
224a 23			inc hl 
224b 23			inc hl 
224c 23			inc hl 
224d 23			inc hl  
224e 23			inc hl 
224f 23			inc hl 
2250 23			inc hl 
2251 23			inc hl 
2252 23			inc hl 
2253 23			inc hl 
2254 23			inc hl     ; TODO how many do we really need?     maybe only 6 
2255			;       exec word buffer 
2255			;	<ptr word>   
2255 23			inc hl 
2256 23			inc hl 
2257			;       <word list><null term> 7F final term 
2257			 
2257			 
2257			if DEBUG_FORTH_UWORD 
2257					DMARK ":02" 
2257 f5				push af  
2258 3a 6c 22			ld a, (.dmark)  
225b 32 5e ee			ld (debug_mark),a  
225e 3a 6d 22			ld a, (.dmark+1)  
2261 32 5f ee			ld (debug_mark+1),a  
2264 3a 6e 22			ld a, (.dmark+2)  
2267 32 60 ee			ld (debug_mark+2),a  
226a 18 03			jr .pastdmark  
226c ..			.dmark: db ":02"  
226f f1			.pastdmark: pop af  
2270			endm  
# End of macro DMARK
2270			CALLMONITOR 
2270 cd 6b ee			call debug_vector  
2273				endm  
# End of macro CALLMONITOR
2273			endif 
2273			 
2273			 
2273				; malloc the size 
2273			 
2273 cd b2 11			call malloc 
2276 22 a6 e2			ld (os_new_malloc), hl     ; save malloc start 
2279			 
2279			;    db   1     ; user defined word  
2279			;	ld a, WORD_SYS_UWORD  
2279 36 01			ld (hl), WORD_SYS_UWORD 
227b			 
227b 23			inc hl    
227c			;    dw   sysdict 
227c 11 f3 1f		ld de, sysdict       ; continue on with the scan to the system dict 
227f 73			ld (hl), e 
2280 23			inc hl 
2281 72			ld (hl), d 
2282 23			inc hl 
2283			 
2283			 
2283			;    Setup dict word 
2283			 
2283 23			inc hl 
2284 22 a0 e2		ld (os_new_work_ptr), hl     ; save start of dict word  
2287			 
2287			; 1. get length of dict word 
2287			 
2287			 
2287 2a b5 e5		ld hl, (os_tok_ptr) 
228a 23			inc hl 
228b 23			inc hl    ; position to start of dict word 
228c 3e 00		ld a, 0 
228e cd 49 11		call strlent 
2291			 
2291			 
2291 23			inc hl    ; to include null??? 
2292			 
2292			; write length of dict word 
2292			 
2292 ed 5b a0 e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
2296 1b			dec de 
2297 eb			ex de, hl 
2298 73			ld (hl), e 
2299 eb			ex de, hl 
229a			 
229a			 
229a			 
229a			; copy  
229a 4d			ld c, l 
229b 06 00		ld b, 0 
229d ed 5b a0 e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
22a1 2a b5 e5		ld hl, (os_tok_ptr) 
22a4 23			inc hl 
22a5 23			inc hl    ; position to start of dict word 
22a6			 
22a6			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
22a6			 
22a6			; TODO need to convert word to upper case 
22a6			 
22a6			ucasetok:	 
22a6 7e			ld a,(hl) 
22a7 cd 35 11		call toUpper 
22aa 77			ld (hl),a 
22ab ed a0		ldi 
22ad f2 a6 22		jp p, ucasetok 
22b0			 
22b0			 
22b0			 
22b0			; de now points to start of where the word body code should be placed 
22b0 ed 53 a0 e2	ld (os_new_work_ptr), de 
22b4			; hl now points to the words to throw at forthexec which needs to be copied 
22b4 22 9e e2		ld (os_new_src_ptr), hl 
22b7			 
22b7			; TODO add 'call to forthexec' 
22b7			 
22b7			if DEBUG_FORTH_UWORD 
22b7 c5			push bc 
22b8 ed 4b a6 e2	ld bc, (os_new_malloc) 
22bc					DMARK ":0x" 
22bc f5				push af  
22bd 3a d1 22			ld a, (.dmark)  
22c0 32 5e ee			ld (debug_mark),a  
22c3 3a d2 22			ld a, (.dmark+1)  
22c6 32 5f ee			ld (debug_mark+1),a  
22c9 3a d3 22			ld a, (.dmark+2)  
22cc 32 60 ee			ld (debug_mark+2),a  
22cf 18 03			jr .pastdmark  
22d1 ..			.dmark: db ":0x"  
22d4 f1			.pastdmark: pop af  
22d5			endm  
# End of macro DMARK
22d5			CALLMONITOR 
22d5 cd 6b ee			call debug_vector  
22d8				endm  
# End of macro CALLMONITOR
22d8 c1			pop bc 
22d9			endif 
22d9			 
22d9			 
22d9			; create word preamble which should be: 
22d9			 
22d9			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
22d9			 
22d9			;    ld hl, <word code> 
22d9			;    jp user_exec 
22d9			;    <word code bytes> 
22d9			 
22d9			 
22d9			;	inc de     ; TODO ??? or are we already past the word's null 
22d9 eb			ex de, hl 
22da			 
22da 36 21		ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
22dc			 
22dc 23			inc hl 
22dd 22 9a e2		ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
22e0 23			inc hl 
22e1			 
22e1 23			inc hl 
22e2 36 c3		ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
22e4			 
22e4 01 82 53		ld bc, user_exec 
22e7 23			inc hl 
22e8 71			ld (hl), c     ; poke address of user_exec 
22e9 23			inc hl 
22ea 70			ld (hl), b     
22eb			; 
22eb			;	inc hl 
22eb			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
22eb			; 
22eb			; 
22eb			;	ld bc, macro_forth_rsp_next 
22eb			;	inc hl 
22eb			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
22eb			;	inc hl 
22eb			;	ld (hl), b     
22eb			; 
22eb			;	inc hl 
22eb			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
22eb			; 
22eb			; 
22eb			;	inc hl 
22eb			;	ld bc, forthexec 
22eb			;	ld (hl), c     ; poke address of forthexec 
22eb			;	inc hl 
22eb			;	ld (hl), b      
22eb			; 
22eb			;	inc hl 
22eb			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
22eb			; 
22eb			;	ld bc, user_dict_next 
22eb			;	inc hl 
22eb			;	ld (hl), c     ; poke address of forthexec 
22eb			;	inc hl 
22eb			;	ld (hl), b      
22eb			 
22eb			; hl is now where we need to copy the word byte data to save this 
22eb			 
22eb 23			inc hl 
22ec 22 9c e2		ld (os_new_exec), hl 
22ef			 
22ef			; copy definition 
22ef			 
22ef eb			ex de, hl 
22f0			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
22f0			;	inc de    ; skip the PC for this parse 
22f0 3a a4 e2		ld a, (os_new_parse_len) 
22f3 4f			ld c, a 
22f4 06 00		ld b, 0 
22f6 ed b0		ldir		 ; copy defintion 
22f8			 
22f8			 
22f8			; poke the address of where the new word bytes live for forthexec 
22f8			 
22f8 2a 9a e2		ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
22fb			 
22fb ed 5b 9c e2	ld de, (os_new_exec)      
22ff			 
22ff 73			ld (hl), e 
2300 23			inc hl 
2301 72			ld (hl), d 
2302			 
2302				; TODO copy last user dict word next link to this word 
2302				; TODO update last user dict word to point to this word 
2302			; 
2302			; hl f923 de 812a ; bc 811a 
2302			 
2302			if DEBUG_FORTH_UWORD 
2302 c5			push bc 
2303 ed 4b a6 e2	ld bc, (os_new_malloc) 
2307					DMARK ":0A" 
2307 f5				push af  
2308 3a 1c 23			ld a, (.dmark)  
230b 32 5e ee			ld (debug_mark),a  
230e 3a 1d 23			ld a, (.dmark+1)  
2311 32 5f ee			ld (debug_mark+1),a  
2314 3a 1e 23			ld a, (.dmark+2)  
2317 32 60 ee			ld (debug_mark+2),a  
231a 18 03			jr .pastdmark  
231c ..			.dmark: db ":0A"  
231f f1			.pastdmark: pop af  
2320			endm  
# End of macro DMARK
2320			CALLMONITOR 
2320 cd 6b ee			call debug_vector  
2323				endm  
# End of macro CALLMONITOR
2323 c1			pop bc 
2324			endif 
2324			if DEBUG_FORTH_UWORD 
2324 c5			push bc 
2325 ed 4b a6 e2	ld bc, (os_new_malloc) 
2329 03			inc bc 
232a 03			inc bc 
232b 03			inc bc 
232c 03			inc bc 
232d 03			inc bc 
232e 03			inc bc 
232f 03			inc bc 
2330 03			inc bc 
2331			 
2331					DMARK ":0B" 
2331 f5				push af  
2332 3a 46 23			ld a, (.dmark)  
2335 32 5e ee			ld (debug_mark),a  
2338 3a 47 23			ld a, (.dmark+1)  
233b 32 5f ee			ld (debug_mark+1),a  
233e 3a 48 23			ld a, (.dmark+2)  
2341 32 60 ee			ld (debug_mark+2),a  
2344 18 03			jr .pastdmark  
2346 ..			.dmark: db ":0B"  
2349 f1			.pastdmark: pop af  
234a			endm  
# End of macro DMARK
234a			CALLMONITOR 
234a cd 6b ee			call debug_vector  
234d				endm  
# End of macro CALLMONITOR
234d c1			pop bc 
234e			endif 
234e			 
234e			; update word dict linked list for new word 
234e			 
234e			 
234e 2a b1 e5		ld hl, (os_last_new_uword)		; get the start of the last added uword 
2351 23			inc hl     ; move to next work linked list ptr 
2352			 
2352 ed 5b a6 e2	ld de, (os_new_malloc)		 ; new next word 
2356 73			ld (hl), e 
2357 23			inc hl 
2358 72			ld (hl), d 
2359			 
2359			if DEBUG_FORTH_UWORD 
2359 ed 4b b1 e5	ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
235d			endif 
235d			 
235d ed 53 b1 e5	ld (os_last_new_uword), de      ; update last new uword ptr 
2361			 
2361			 
2361			if DEBUG_FORTH_UWORD 
2361					DMARK ":0+" 
2361 f5				push af  
2362 3a 76 23			ld a, (.dmark)  
2365 32 5e ee			ld (debug_mark),a  
2368 3a 77 23			ld a, (.dmark+1)  
236b 32 5f ee			ld (debug_mark+1),a  
236e 3a 78 23			ld a, (.dmark+2)  
2371 32 60 ee			ld (debug_mark+2),a  
2374 18 03			jr .pastdmark  
2376 ..			.dmark: db ":0+"  
2379 f1			.pastdmark: pop af  
237a			endm  
# End of macro DMARK
237a			CALLMONITOR 
237a cd 6b ee			call debug_vector  
237d				endm  
# End of macro CALLMONITOR
237d			endif 
237d			 
237d			STACKFRAMECHK OFF $8efe $989f 
237d				if DEBUG_STACK_IMB 
237d					if OFF 
237d						exx 
237d						ld hl, $989f 
237d						pop de   ; $989f 
237d						call cmp16 
237d						jr nz, .spnosame 
237d						ld hl, $8efe 
237d						pop de   ; $8efe 
237d						call cmp16 
237d						jr z, .spfrsame 
237d						.spnosame: call showsperror 
237d						.spfrsame: nop 
237d						exx 
237d					endif 
237d				endif 
237d			endm 
# End of macro STACKFRAMECHK
237d			 
237d c9			ret    ; dont process any remaining parser tokens as they form new word 
237e			 
237e			 
237e			 
237e			 
237e			;		NEXT 
237e			.SCOLN: 
237e			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
237e 06			db OPCODE_SCOLN 
237f cd 23		dw .DROP 
2381 02			db 2 
2382 .. 00		db ";",0           
2384			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
2384				if DEBUG_FORTH_WORDS_KEY 
2384					DMARK "SCN" 
2384 f5				push af  
2385 3a 99 23			ld a, (.dmark)  
2388 32 5e ee			ld (debug_mark),a  
238b 3a 9a 23			ld a, (.dmark+1)  
238e 32 5f ee			ld (debug_mark+1),a  
2391 3a 9b 23			ld a, (.dmark+2)  
2394 32 60 ee			ld (debug_mark+2),a  
2397 18 03			jr .pastdmark  
2399 ..			.dmark: db "SCN"  
239c f1			.pastdmark: pop af  
239d			endm  
# End of macro DMARK
239d					CALLMONITOR 
239d cd 6b ee			call debug_vector  
23a0				endm  
# End of macro CALLMONITOR
23a0				endif 
23a0				FORTH_RSP_TOS 
23a0 cd 95 1a			call macro_forth_rsp_tos 
23a3				endm 
# End of macro FORTH_RSP_TOS
23a3 e5				push hl 
23a4				FORTH_RSP_POP 
23a4 cd 9f 1a			call macro_forth_rsp_pop 
23a7				endm 
# End of macro FORTH_RSP_POP
23a7 e1				pop hl 
23a8			;		ex de,hl 
23a8 22 b5 e5			ld (os_tok_ptr),hl 
23ab			 
23ab			if DEBUG_FORTH_UWORD 
23ab					DMARK "SCL" 
23ab f5				push af  
23ac 3a c0 23			ld a, (.dmark)  
23af 32 5e ee			ld (debug_mark),a  
23b2 3a c1 23			ld a, (.dmark+1)  
23b5 32 5f ee			ld (debug_mark+1),a  
23b8 3a c2 23			ld a, (.dmark+2)  
23bb 32 60 ee			ld (debug_mark+2),a  
23be 18 03			jr .pastdmark  
23c0 ..			.dmark: db "SCL"  
23c3 f1			.pastdmark: pop af  
23c4			endm  
# End of macro DMARK
23c4			CALLMONITOR 
23c4 cd 6b ee			call debug_vector  
23c7				endm  
# End of macro CALLMONITOR
23c7			endif 
23c7				NEXTW 
23c7 cd 68 ee			call parse_vector 
23ca c3 ba 1e			jp macro_next 
23cd				endm 
# End of macro NEXTW
23cd			 
23cd			.DROP: 
23cd			CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
23cd 1b				db WORD_SYS_CORE+OPCODE_DROP             
23ce fb 23			dw .DUP2            
23d0 05				db 4 + 1 
23d1 .. 00			db "DROP",0              
23d6				endm 
# End of macro CWHEAD
23d6			; | DROP ( w -- )   drop the TOS item   | DONE 
23d6				if DEBUG_FORTH_WORDS_KEY 
23d6					DMARK "DRP" 
23d6 f5				push af  
23d7 3a eb 23			ld a, (.dmark)  
23da 32 5e ee			ld (debug_mark),a  
23dd 3a ec 23			ld a, (.dmark+1)  
23e0 32 5f ee			ld (debug_mark+1),a  
23e3 3a ed 23			ld a, (.dmark+2)  
23e6 32 60 ee			ld (debug_mark+2),a  
23e9 18 03			jr .pastdmark  
23eb ..			.dmark: db "DRP"  
23ee f1			.pastdmark: pop af  
23ef			endm  
# End of macro DMARK
23ef					CALLMONITOR 
23ef cd 6b ee			call debug_vector  
23f2				endm  
# End of macro CALLMONITOR
23f2				endif 
23f2				FORTH_DSP_POP 
23f2 cd 8b 1d			call macro_forth_dsp_pop 
23f5				endm 
# End of macro FORTH_DSP_POP
23f5				NEXTW 
23f5 cd 68 ee			call parse_vector 
23f8 c3 ba 1e			jp macro_next 
23fb				endm 
# End of macro NEXTW
23fb			.DUP2: 
23fb			CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
23fb 1c				db WORD_SYS_CORE+OPCODE_DUP2             
23fc 43 24			dw .DROP2            
23fe 05				db 4 + 1 
23ff .. 00			db "2DUP",0              
2404				endm 
# End of macro CWHEAD
2404			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  (Only works for numerics) | DONE 
2404			; | | >[!NOTE] 
2404			; | | > If the duplicated items are string pointers, string are not safely duplicated and remain as pointers to the origin 
2404				if DEBUG_FORTH_WORDS_KEY 
2404					DMARK "2DU" 
2404 f5				push af  
2405 3a 19 24			ld a, (.dmark)  
2408 32 5e ee			ld (debug_mark),a  
240b 3a 1a 24			ld a, (.dmark+1)  
240e 32 5f ee			ld (debug_mark+1),a  
2411 3a 1b 24			ld a, (.dmark+2)  
2414 32 60 ee			ld (debug_mark+2),a  
2417 18 03			jr .pastdmark  
2419 ..			.dmark: db "2DU"  
241c f1			.pastdmark: pop af  
241d			endm  
# End of macro DMARK
241d					CALLMONITOR 
241d cd 6b ee			call debug_vector  
2420				endm  
# End of macro CALLMONITOR
2420				endif 
2420				FORTH_DSP_VALUEHL 
2420 cd d3 1c			call macro_dsp_valuehl 
2423				endm 
# End of macro FORTH_DSP_VALUEHL
2423 e5				push hl      ; 2 
2424			 
2424				FORTH_DSP_POP 
2424 cd 8b 1d			call macro_forth_dsp_pop 
2427				endm 
# End of macro FORTH_DSP_POP
2427				 
2427				FORTH_DSP_VALUEHL 
2427 cd d3 1c			call macro_dsp_valuehl 
242a				endm 
# End of macro FORTH_DSP_VALUEHL
242a			;		push hl      ; 1 
242a			 
242a				FORTH_DSP_POP 
242a cd 8b 1d			call macro_forth_dsp_pop 
242d				endm 
# End of macro FORTH_DSP_POP
242d			 
242d			;		pop hl       ; 1 
242d d1				pop de       ; 2 
242e			 
242e cd d7 1a			call forth_push_numhl 
2431 eb				ex de, hl 
2432 cd d7 1a			call forth_push_numhl 
2435			 
2435				 
2435 eb				ex de, hl 
2436			 
2436 cd d7 1a			call forth_push_numhl 
2439 eb				ex de, hl 
243a cd d7 1a			call forth_push_numhl 
243d			 
243d			 
243d				NEXTW 
243d cd 68 ee			call parse_vector 
2440 c3 ba 1e			jp macro_next 
2443				endm 
# End of macro NEXTW
2443			.DROP2: 
2443			CWHEAD .PICK OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
2443 1d				db WORD_SYS_CORE+OPCODE_DROP2             
2444 75 24			dw .PICK            
2446 06				db 5 + 1 
2447 .. 00			db "2DROP",0              
244d				endm 
# End of macro CWHEAD
244d			; | 2DROP ( w w -- )    Double drop | DONE 
244d				if DEBUG_FORTH_WORDS_KEY 
244d					DMARK "2DR" 
244d f5				push af  
244e 3a 62 24			ld a, (.dmark)  
2451 32 5e ee			ld (debug_mark),a  
2454 3a 63 24			ld a, (.dmark+1)  
2457 32 5f ee			ld (debug_mark+1),a  
245a 3a 64 24			ld a, (.dmark+2)  
245d 32 60 ee			ld (debug_mark+2),a  
2460 18 03			jr .pastdmark  
2462 ..			.dmark: db "2DR"  
2465 f1			.pastdmark: pop af  
2466			endm  
# End of macro DMARK
2466					CALLMONITOR 
2466 cd 6b ee			call debug_vector  
2469				endm  
# End of macro CALLMONITOR
2469				endif 
2469				FORTH_DSP_POP 
2469 cd 8b 1d			call macro_forth_dsp_pop 
246c				endm 
# End of macro FORTH_DSP_POP
246c				FORTH_DSP_POP 
246c cd 8b 1d			call macro_forth_dsp_pop 
246f				endm 
# End of macro FORTH_DSP_POP
246f				NEXTW 
246f cd 68 ee			call parse_vector 
2472 c3 ba 1e			jp macro_next 
2475				endm 
# End of macro NEXTW
2475			.PICK: 
2475			CWHEAD .SWAP2 99 "PICK" 4 WORD_FLAG_CODE 
2475 77				db WORD_SYS_CORE+99             
2476 12 25			dw .SWAP2            
2478 05				db 4 + 1 
2479 .. 00			db "PICK",0              
247e				endm 
# End of macro CWHEAD
247e			; | PICK ( ux ... u x -- ux ... u n )    Replace x on stack with the item from position x on stack  | DONE 
247e			; | | >[!NOTE] 
247e			; | | > If the chosen item is a string the pointer is pushed to TOS. The string is not safely duplicated. 
247e				if DEBUG_FORTH_WORDS_KEY 
247e					DMARK "PIK" 
247e f5				push af  
247f 3a 93 24			ld a, (.dmark)  
2482 32 5e ee			ld (debug_mark),a  
2485 3a 94 24			ld a, (.dmark+1)  
2488 32 5f ee			ld (debug_mark+1),a  
248b 3a 95 24			ld a, (.dmark+2)  
248e 32 60 ee			ld (debug_mark+2),a  
2491 18 03			jr .pastdmark  
2493 ..			.dmark: db "PIK"  
2496 f1			.pastdmark: pop af  
2497			endm  
# End of macro DMARK
2497					CALLMONITOR 
2497 cd 6b ee			call debug_vector  
249a				endm  
# End of macro CALLMONITOR
249a				endif 
249a			 
249a				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
249a cd d3 1c			call macro_dsp_valuehl 
249d				endm 
# End of macro FORTH_DSP_VALUEHL
249d				 
249d				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
249d cd 8b 1d			call macro_forth_dsp_pop 
24a0				endm 
# End of macro FORTH_DSP_POP
24a0			 
24a0				; init from TOS 
24a0 e5				push hl 
24a1				FORTH_DSP 
24a1 cd 99 1c			call macro_forth_dsp 
24a4				endm 
# End of macro FORTH_DSP
24a4			;	ld hl, cli_data_sp 
24a4				if DEBUG_FORTH_WORDS 
24a4					DMARK "PK1" 
24a4 f5				push af  
24a5 3a b9 24			ld a, (.dmark)  
24a8 32 5e ee			ld (debug_mark),a  
24ab 3a ba 24			ld a, (.dmark+1)  
24ae 32 5f ee			ld (debug_mark+1),a  
24b1 3a bb 24			ld a, (.dmark+2)  
24b4 32 60 ee			ld (debug_mark+2),a  
24b7 18 03			jr .pastdmark  
24b9 ..			.dmark: db "PK1"  
24bc f1			.pastdmark: pop af  
24bd			endm  
# End of macro DMARK
24bd					CALLMONITOR 
24bd cd 6b ee			call debug_vector  
24c0				endm  
# End of macro CALLMONITOR
24c0				endif 
24c0 c1				pop bc 
24c1 41				ld b,c 
24c2 3e 00			ld a, 0 
24c4 b8				cp b 
24c5 28 21			jr z, .pdone	 
24c7			.pkl: 
24c7 2b				dec hl 
24c8 2b				dec hl 
24c9 2b				dec hl 
24ca			 
24ca				if DEBUG_FORTH_WORDS 
24ca					DMARK "PKl" 
24ca f5				push af  
24cb 3a df 24			ld a, (.dmark)  
24ce 32 5e ee			ld (debug_mark),a  
24d1 3a e0 24			ld a, (.dmark+1)  
24d4 32 5f ee			ld (debug_mark+1),a  
24d7 3a e1 24			ld a, (.dmark+2)  
24da 32 60 ee			ld (debug_mark+2),a  
24dd 18 03			jr .pastdmark  
24df ..			.dmark: db "PKl"  
24e2 f1			.pastdmark: pop af  
24e3			endm  
# End of macro DMARK
24e3					CALLMONITOR 
24e3 cd 6b ee			call debug_vector  
24e6				endm  
# End of macro CALLMONITOR
24e6				endif 
24e6 10 df			djnz .pkl 
24e8			.pdone: 
24e8				 
24e8				; TODO do type check with correct push 
24e8			 
24e8 23				inc hl 
24e9				;call loadwordinhl 
24e9 5e				ld e, (hl) 
24ea 23				inc hl 
24eb 56				ld d, (hl) 
24ec eb				ex de,hl 
24ed				if DEBUG_FORTH_WORDS 
24ed					DMARK "PKp" 
24ed f5				push af  
24ee 3a 02 25			ld a, (.dmark)  
24f1 32 5e ee			ld (debug_mark),a  
24f4 3a 03 25			ld a, (.dmark+1)  
24f7 32 5f ee			ld (debug_mark+1),a  
24fa 3a 04 25			ld a, (.dmark+2)  
24fd 32 60 ee			ld (debug_mark+2),a  
2500 18 03			jr .pastdmark  
2502 ..			.dmark: db "PKp"  
2505 f1			.pastdmark: pop af  
2506			endm  
# End of macro DMARK
2506					CALLMONITOR 
2506 cd 6b ee			call debug_vector  
2509				endm  
# End of macro CALLMONITOR
2509				endif 
2509 cd d7 1a			call forth_push_numhl 
250c			 
250c				NEXTW 
250c cd 68 ee			call parse_vector 
250f c3 ba 1e			jp macro_next 
2512				endm 
# End of macro NEXTW
2512			.SWAP2: 
2512			CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
2512 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
2513 96 25			dw .AT            
2515 06				db 5 + 1 
2516 .. 00			db "2SWAP",0              
251c				endm 
# End of macro CWHEAD
251c			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | DONE 
251c				if DEBUG_FORTH_WORDS_KEY 
251c					DMARK "2SW" 
251c f5				push af  
251d 3a 31 25			ld a, (.dmark)  
2520 32 5e ee			ld (debug_mark),a  
2523 3a 32 25			ld a, (.dmark+1)  
2526 32 5f ee			ld (debug_mark+1),a  
2529 3a 33 25			ld a, (.dmark+2)  
252c 32 60 ee			ld (debug_mark+2),a  
252f 18 03			jr .pastdmark  
2531 ..			.dmark: db "2SW"  
2534 f1			.pastdmark: pop af  
2535			endm  
# End of macro DMARK
2535					CALLMONITOR 
2535 cd 6b ee			call debug_vector  
2538				endm  
# End of macro CALLMONITOR
2538				endif 
2538			; TODO Use os stack swap memory 
2538			 
2538				FORTH_DSP_PTR 0     ; TOS    w4 
2538 2a e1 e9			ld hl,(cli_data_sp) 
253b 11 00 00			ld de, 0 * 3 
253e ed 52			sbc hl, de 
2540				endm 
# End of macro FORTH_DSP_PTR
2540 cd 0a 1e			call hltostack1 
2543			  
2543				FORTH_DSP_PTR 1     ; TOS    w3 
2543 2a e1 e9			ld hl,(cli_data_sp) 
2546 11 03 00			ld de, 1 * 3 
2549 ed 52			sbc hl, de 
254b				endm 
# End of macro FORTH_DSP_PTR
254b cd 10 1e			call hltostack2 
254e			 
254e			 
254e			 
254e				FORTH_DSP_PTR 2     ; TOS    w2 
254e 2a e1 e9			ld hl,(cli_data_sp) 
2551 11 06 00			ld de, 2 * 3 
2554 ed 52			sbc hl, de 
2556				endm 
# End of macro FORTH_DSP_PTR
2556 cd 16 1e			call hltostack3 
2559			 
2559				FORTH_DSP_PTR 3     ; TOS   w1 
2559 2a e1 e9			ld hl,(cli_data_sp) 
255c 11 09 00			ld de, 3 * 3 
255f ed 52			sbc hl, de 
2561				endm 
# End of macro FORTH_DSP_PTR
2561 cd 1c 1e			call hltostack4 
2564			 
2564			 
2564			 
2564			 
2564				FORTH_DSP_PTR 0     ; TOS 
2564 2a e1 e9			ld hl,(cli_data_sp) 
2567 11 00 00			ld de, 0 * 3 
256a ed 52			sbc hl, de 
256c				endm 
# End of macro FORTH_DSP_PTR
256c cd 2e 1e			call hlfromstack3 
256f			 
256f				FORTH_DSP_PTR 1     ; TOS 
256f 2a e1 e9			ld hl,(cli_data_sp) 
2572 11 03 00			ld de, 1 * 3 
2575 ed 52			sbc hl, de 
2577				endm 
# End of macro FORTH_DSP_PTR
2577 cd 34 1e			call hlfromstack4 
257a			 
257a			 
257a			 
257a				FORTH_DSP_PTR 2     ; TOS 
257a 2a e1 e9			ld hl,(cli_data_sp) 
257d 11 06 00			ld de, 2 * 3 
2580 ed 52			sbc hl, de 
2582				endm 
# End of macro FORTH_DSP_PTR
2582 cd 22 1e			call hlfromstack1 
2585			 
2585				FORTH_DSP_PTR 3     ; TOS 
2585 2a e1 e9			ld hl,(cli_data_sp) 
2588 11 09 00			ld de, 3 * 3 
258b ed 52			sbc hl, de 
258d				endm 
# End of macro FORTH_DSP_PTR
258d cd 28 1e			call hlfromstack2 
2590			 
2590				NEXTW 
2590 cd 68 ee			call parse_vector 
2593 c3 ba 1e			jp macro_next 
2596				endm 
# End of macro NEXTW
2596			.AT: 
2596			CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
2596 1f				db WORD_SYS_CORE+OPCODE_AT             
2597 cb 25			dw .CAT            
2599 02				db 1 + 1 
259a .. 00			db "@",0              
259c				endm 
# End of macro CWHEAD
259c			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
259c			 
259c				if DEBUG_FORTH_WORDS_KEY 
259c					DMARK "AT." 
259c f5				push af  
259d 3a b1 25			ld a, (.dmark)  
25a0 32 5e ee			ld (debug_mark),a  
25a3 3a b2 25			ld a, (.dmark+1)  
25a6 32 5f ee			ld (debug_mark+1),a  
25a9 3a b3 25			ld a, (.dmark+2)  
25ac 32 60 ee			ld (debug_mark+2),a  
25af 18 03			jr .pastdmark  
25b1 ..			.dmark: db "AT."  
25b4 f1			.pastdmark: pop af  
25b5			endm  
# End of macro DMARK
25b5					CALLMONITOR 
25b5 cd 6b ee			call debug_vector  
25b8				endm  
# End of macro CALLMONITOR
25b8				endif 
25b8			.getbyteat:	 
25b8				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25b8 cd d3 1c			call macro_dsp_valuehl 
25bb				endm 
# End of macro FORTH_DSP_VALUEHL
25bb				 
25bb			;		push hl 
25bb			 
25bb				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25bb cd 8b 1d			call macro_forth_dsp_pop 
25be				endm 
# End of macro FORTH_DSP_POP
25be			 
25be			;		pop hl 
25be			 
25be 7e				ld a, (hl) 
25bf			 
25bf 6f				ld l, a 
25c0 26 00			ld h, 0 
25c2 cd d7 1a			call forth_push_numhl 
25c5			 
25c5				NEXTW 
25c5 cd 68 ee			call parse_vector 
25c8 c3 ba 1e			jp macro_next 
25cb				endm 
# End of macro NEXTW
25cb			.CAT: 
25cb			CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
25cb 20				db WORD_SYS_CORE+OPCODE_CAT             
25cc f7 25			dw .BANG            
25ce 03				db 2 + 1 
25cf .. 00			db "C@",0              
25d2				endm 
# End of macro CWHEAD
25d2			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
25d2				if DEBUG_FORTH_WORDS_KEY 
25d2					DMARK "CAA" 
25d2 f5				push af  
25d3 3a e7 25			ld a, (.dmark)  
25d6 32 5e ee			ld (debug_mark),a  
25d9 3a e8 25			ld a, (.dmark+1)  
25dc 32 5f ee			ld (debug_mark+1),a  
25df 3a e9 25			ld a, (.dmark+2)  
25e2 32 60 ee			ld (debug_mark+2),a  
25e5 18 03			jr .pastdmark  
25e7 ..			.dmark: db "CAA"  
25ea f1			.pastdmark: pop af  
25eb			endm  
# End of macro DMARK
25eb					CALLMONITOR 
25eb cd 6b ee			call debug_vector  
25ee				endm  
# End of macro CALLMONITOR
25ee				endif 
25ee c3 b8 25			jp .getbyteat 
25f1				NEXTW 
25f1 cd 68 ee			call parse_vector 
25f4 c3 ba 1e			jp macro_next 
25f7				endm 
# End of macro NEXTW
25f7			.BANG: 
25f7			CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
25f7 21				db WORD_SYS_CORE+OPCODE_BANG             
25f8 30 26			dw .CBANG            
25fa 02				db 1 + 1 
25fb .. 00			db "!",0              
25fd				endm 
# End of macro CWHEAD
25fd			; | ! ( x w -- ) Store x at address w      | DONE 
25fd				if DEBUG_FORTH_WORDS_KEY 
25fd					DMARK "BNG" 
25fd f5				push af  
25fe 3a 12 26			ld a, (.dmark)  
2601 32 5e ee			ld (debug_mark),a  
2604 3a 13 26			ld a, (.dmark+1)  
2607 32 5f ee			ld (debug_mark+1),a  
260a 3a 14 26			ld a, (.dmark+2)  
260d 32 60 ee			ld (debug_mark+2),a  
2610 18 03			jr .pastdmark  
2612 ..			.dmark: db "BNG"  
2615 f1			.pastdmark: pop af  
2616			endm  
# End of macro DMARK
2616					CALLMONITOR 
2616 cd 6b ee			call debug_vector  
2619				endm  
# End of macro CALLMONITOR
2619				endif 
2619			 
2619			.storebyteat:		 
2619				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2619 cd d3 1c			call macro_dsp_valuehl 
261c				endm 
# End of macro FORTH_DSP_VALUEHL
261c				 
261c e5				push hl 
261d			 
261d				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
261d cd 8b 1d			call macro_forth_dsp_pop 
2620				endm 
# End of macro FORTH_DSP_POP
2620			 
2620				; get byte to poke 
2620			 
2620				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2620 cd d3 1c			call macro_dsp_valuehl 
2623				endm 
# End of macro FORTH_DSP_VALUEHL
2623 e5				push hl 
2624			 
2624			 
2624				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2624 cd 8b 1d			call macro_forth_dsp_pop 
2627				endm 
# End of macro FORTH_DSP_POP
2627			 
2627			 
2627 d1				pop de 
2628 e1				pop hl 
2629			 
2629 73				ld (hl),e 
262a			 
262a			 
262a				NEXTW 
262a cd 68 ee			call parse_vector 
262d c3 ba 1e			jp macro_next 
2630				endm 
# End of macro NEXTW
2630			.CBANG: 
2630			CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
2630 22				db WORD_SYS_CORE+OPCODE_CBANG             
2631 5c 26			dw .SCALL            
2633 03				db 2 + 1 
2634 .. 00			db "C!",0              
2637				endm 
# End of macro CWHEAD
2637			; | C!  ( x w -- ) Store x at address w  | DONE 
2637				if DEBUG_FORTH_WORDS_KEY 
2637					DMARK "CBA" 
2637 f5				push af  
2638 3a 4c 26			ld a, (.dmark)  
263b 32 5e ee			ld (debug_mark),a  
263e 3a 4d 26			ld a, (.dmark+1)  
2641 32 5f ee			ld (debug_mark+1),a  
2644 3a 4e 26			ld a, (.dmark+2)  
2647 32 60 ee			ld (debug_mark+2),a  
264a 18 03			jr .pastdmark  
264c ..			.dmark: db "CBA"  
264f f1			.pastdmark: pop af  
2650			endm  
# End of macro DMARK
2650					CALLMONITOR 
2650 cd 6b ee			call debug_vector  
2653				endm  
# End of macro CALLMONITOR
2653				endif 
2653 c3 19 26			jp .storebyteat 
2656				NEXTW 
2656 cd 68 ee			call parse_vector 
2659 c3 ba 1e			jp macro_next 
265c				endm 
# End of macro NEXTW
265c			.SCALL: 
265c			CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
265c 23				db WORD_SYS_CORE+OPCODE_SCALL             
265d 93 26			dw .DEPTH            
265f 05				db 4 + 1 
2660 .. 00			db "CALL",0              
2665				endm 
# End of macro CWHEAD
2665			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
2665				if DEBUG_FORTH_WORDS_KEY 
2665					DMARK "CLL" 
2665 f5				push af  
2666 3a 7a 26			ld a, (.dmark)  
2669 32 5e ee			ld (debug_mark),a  
266c 3a 7b 26			ld a, (.dmark+1)  
266f 32 5f ee			ld (debug_mark+1),a  
2672 3a 7c 26			ld a, (.dmark+2)  
2675 32 60 ee			ld (debug_mark+2),a  
2678 18 03			jr .pastdmark  
267a ..			.dmark: db "CLL"  
267d f1			.pastdmark: pop af  
267e			endm  
# End of macro DMARK
267e					CALLMONITOR 
267e cd 6b ee			call debug_vector  
2681				endm  
# End of macro CALLMONITOR
2681				endif 
2681			 
2681				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2681 cd d3 1c			call macro_dsp_valuehl 
2684				endm 
# End of macro FORTH_DSP_VALUEHL
2684			 
2684			;		push hl 
2684			 
2684				; destroy value TOS 
2684			 
2684				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2684 cd 8b 1d			call macro_forth_dsp_pop 
2687				endm 
# End of macro FORTH_DSP_POP
2687			 
2687					 
2687			;		pop hl 
2687			 
2687				; how to do a call with hl???? save SP? 
2687 cd 5e 1e			call forth_call_hl 
268a			 
268a			 
268a				; TODO push value back onto stack for another op etc 
268a			 
268a cd d7 1a			call forth_push_numhl 
268d				NEXTW 
268d cd 68 ee			call parse_vector 
2690 c3 ba 1e			jp macro_next 
2693				endm 
# End of macro NEXTW
2693			.DEPTH: 
2693			CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2693 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2694 d3 26			dw .OVER            
2696 06				db 5 + 1 
2697 .. 00			db "DEPTH",0              
269d				endm 
# End of macro CWHEAD
269d			; | DEPTH ( -- u ) Push count of stack | DONE 
269d				; take current TOS and remove from base value div by two to get count 
269d				if DEBUG_FORTH_WORDS_KEY 
269d					DMARK "DEP" 
269d f5				push af  
269e 3a b2 26			ld a, (.dmark)  
26a1 32 5e ee			ld (debug_mark),a  
26a4 3a b3 26			ld a, (.dmark+1)  
26a7 32 5f ee			ld (debug_mark+1),a  
26aa 3a b4 26			ld a, (.dmark+2)  
26ad 32 60 ee			ld (debug_mark+2),a  
26b0 18 03			jr .pastdmark  
26b2 ..			.dmark: db "DEP"  
26b5 f1			.pastdmark: pop af  
26b6			endm  
# End of macro DMARK
26b6					CALLMONITOR 
26b6 cd 6b ee			call debug_vector  
26b9				endm  
# End of macro CALLMONITOR
26b9				endif 
26b9			 
26b9			 
26b9 2a e1 e9		ld hl, (cli_data_sp) 
26bc 11 1b e8		ld de, cli_data_stack 
26bf ed 52		sbc hl,de 
26c1			 
26c1			; div by size of stack item 
26c1			 
26c1 5d			ld e,l 
26c2 0e 03		ld c, 3 
26c4 cd 76 0d		call Div8 
26c7			 
26c7 6f			ld l,a 
26c8 26 00		ld h,0 
26ca			 
26ca			;srl h 
26ca			;rr l 
26ca			 
26ca cd d7 1a			call forth_push_numhl 
26cd				NEXTW 
26cd cd 68 ee			call parse_vector 
26d0 c3 ba 1e			jp macro_next 
26d3				endm 
# End of macro NEXTW
26d3			.OVER: 
26d3			CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
26d3 42				db WORD_SYS_CORE+46             
26d4 23 27			dw .PAUSE            
26d6 05				db 4 + 1 
26d7 .. 00			db "OVER",0              
26dc				endm 
# End of macro CWHEAD
26dc			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
26dc			; | | >[!NOTE] 
26dc			; | | > If the copied item is a string it is properly duplicated allowing for a safe release after use.  
26dc				if DEBUG_FORTH_WORDS_KEY 
26dc					DMARK "OVR" 
26dc f5				push af  
26dd 3a f1 26			ld a, (.dmark)  
26e0 32 5e ee			ld (debug_mark),a  
26e3 3a f2 26			ld a, (.dmark+1)  
26e6 32 5f ee			ld (debug_mark+1),a  
26e9 3a f3 26			ld a, (.dmark+2)  
26ec 32 60 ee			ld (debug_mark+2),a  
26ef 18 03			jr .pastdmark  
26f1 ..			.dmark: db "OVR"  
26f4 f1			.pastdmark: pop af  
26f5			endm  
# End of macro DMARK
26f5					CALLMONITOR 
26f5 cd 6b ee			call debug_vector  
26f8				endm  
# End of macro CALLMONITOR
26f8				endif 
26f8			 
26f8			; TODO Use os stack swap memory 
26f8			 
26f8				; work out what type we are looking at 
26f8			 
26f8				FORTH_DSP_PTR 1 
26f8 2a e1 e9			ld hl,(cli_data_sp) 
26fb 11 03 00			ld de, 1 * 3 
26fe ed 52			sbc hl, de 
2700				endm 
# End of macro FORTH_DSP_PTR
2700			 
2700 7e				ld a, (hl) 
2701				 
2701 f5				push af 
2702				; whatever the type lets get the pointer or word 
2702 23				inc hl 
2703			;; 
2703			 
2703				; type check now to decide on how to push  
2703			 
2703 cd 40 1e			call loadwordinhl 
2706 f1				pop af 
2707 fe 01			cp DS_TYPE_STR 
2709 28 09			jr z, .ovstr 
270b			 
270b				; we have a numeric so load the word and push 
270b			;	ld e, (hl) 
270b			;	inc hl 
270b			;	ld d, (hl) 
270b			;	ex de, hl 
270b cd d7 1a			call forth_push_numhl 
270e				NEXTW 
270e cd 68 ee			call parse_vector 
2711 c3 ba 1e			jp macro_next 
2714				endm 
# End of macro NEXTW
2714			 
2714			.ovstr: 
2714				; ok, a string so get the pointer and push as a string 
2714			 
2714			;	call loadwordinhl 
2714 cd 41 1b			call forth_push_str 
2717				NEXTW 
2717 cd 68 ee			call parse_vector 
271a c3 ba 1e			jp macro_next 
271d				endm 
# End of macro NEXTW
271d			 
271d			;	FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
271d			;	push hl    ; n2 
271d			;	FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
271d			; 
271d			;	FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
271d			;	push hl    ; n1 
271d			;	FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
271d			; 
271d			;	pop de     ; n1 
271d			;	pop hl     ; n2 
271d			; 
271d			;	push de 
271d			;	push hl 
271d			;	push de 
271d			 
271d				; push back  
271d			 
271d			;	pop hl 
271d			;	call forth_push_numhl 
271d			;	pop hl 
271d			;	call forth_push_numhl 
271d			;	pop hl 
271d			;	call forth_push_numhl 
271d				NEXTW 
271d cd 68 ee			call parse_vector 
2720 c3 ba 1e			jp macro_next 
2723				endm 
# End of macro NEXTW
2723			 
2723			.PAUSE: 
2723			CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2723 43				db WORD_SYS_CORE+47             
2724 5b 27			dw .PAUSES            
2726 08				db 7 + 1 
2727 .. 00			db "PAUSEMS",0              
272f				endm 
# End of macro CWHEAD
272f			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
272f				if DEBUG_FORTH_WORDS_KEY 
272f					DMARK "PMS" 
272f f5				push af  
2730 3a 44 27			ld a, (.dmark)  
2733 32 5e ee			ld (debug_mark),a  
2736 3a 45 27			ld a, (.dmark+1)  
2739 32 5f ee			ld (debug_mark+1),a  
273c 3a 46 27			ld a, (.dmark+2)  
273f 32 60 ee			ld (debug_mark+2),a  
2742 18 03			jr .pastdmark  
2744 ..			.dmark: db "PMS"  
2747 f1			.pastdmark: pop af  
2748			endm  
# End of macro DMARK
2748					CALLMONITOR 
2748 cd 6b ee			call debug_vector  
274b				endm  
# End of macro CALLMONITOR
274b				endif 
274b				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
274b cd d3 1c			call macro_dsp_valuehl 
274e				endm 
# End of macro FORTH_DSP_VALUEHL
274e			;		push hl    ; n2 
274e				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
274e cd 8b 1d			call macro_forth_dsp_pop 
2751				endm 
# End of macro FORTH_DSP_POP
2751			;		pop hl 
2751			 
2751 7d				ld a, l 
2752 cd d5 0a			call aDelayInMS 
2755			       NEXTW 
2755 cd 68 ee			call parse_vector 
2758 c3 ba 1e			jp macro_next 
275b				endm 
# End of macro NEXTW
275b			.PAUSES:  
275b			CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
275b 44				db WORD_SYS_CORE+48             
275c cd 27			dw .ROT            
275e 06				db 5 + 1 
275f .. 00			db "PAUSE",0              
2765				endm 
# End of macro CWHEAD
2765			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2765				if DEBUG_FORTH_WORDS_KEY 
2765					DMARK "PAU" 
2765 f5				push af  
2766 3a 7a 27			ld a, (.dmark)  
2769 32 5e ee			ld (debug_mark),a  
276c 3a 7b 27			ld a, (.dmark+1)  
276f 32 5f ee			ld (debug_mark+1),a  
2772 3a 7c 27			ld a, (.dmark+2)  
2775 32 60 ee			ld (debug_mark+2),a  
2778 18 03			jr .pastdmark  
277a ..			.dmark: db "PAU"  
277d f1			.pastdmark: pop af  
277e			endm  
# End of macro DMARK
277e					CALLMONITOR 
277e cd 6b ee			call debug_vector  
2781				endm  
# End of macro CALLMONITOR
2781				endif 
2781				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2781 cd d3 1c			call macro_dsp_valuehl 
2784				endm 
# End of macro FORTH_DSP_VALUEHL
2784			;		push hl    ; n2 
2784				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2784 cd 8b 1d			call macro_forth_dsp_pop 
2787				endm 
# End of macro FORTH_DSP_POP
2787			;		pop hl 
2787 45				ld b, l 
2788				if DEBUG_FORTH_WORDS 
2788					DMARK "PAU" 
2788 f5				push af  
2789 3a 9d 27			ld a, (.dmark)  
278c 32 5e ee			ld (debug_mark),a  
278f 3a 9e 27			ld a, (.dmark+1)  
2792 32 5f ee			ld (debug_mark+1),a  
2795 3a 9f 27			ld a, (.dmark+2)  
2798 32 60 ee			ld (debug_mark+2),a  
279b 18 03			jr .pastdmark  
279d ..			.dmark: db "PAU"  
27a0 f1			.pastdmark: pop af  
27a1			endm  
# End of macro DMARK
27a1					CALLMONITOR 
27a1 cd 6b ee			call debug_vector  
27a4				endm  
# End of macro CALLMONITOR
27a4				endif 
27a4 c5			.pauses1:	push bc 
27a5 cd f0 0a			call delay1s 
27a8 c1				pop bc 
27a9				if DEBUG_FORTH_WORDS 
27a9					DMARK "PA1" 
27a9 f5				push af  
27aa 3a be 27			ld a, (.dmark)  
27ad 32 5e ee			ld (debug_mark),a  
27b0 3a bf 27			ld a, (.dmark+1)  
27b3 32 5f ee			ld (debug_mark+1),a  
27b6 3a c0 27			ld a, (.dmark+2)  
27b9 32 60 ee			ld (debug_mark+2),a  
27bc 18 03			jr .pastdmark  
27be ..			.dmark: db "PA1"  
27c1 f1			.pastdmark: pop af  
27c2			endm  
# End of macro DMARK
27c2					CALLMONITOR 
27c2 cd 6b ee			call debug_vector  
27c5				endm  
# End of macro CALLMONITOR
27c5				endif 
27c5 10 dd			djnz .pauses1 
27c7			 
27c7			       NEXTW 
27c7 cd 68 ee			call parse_vector 
27ca c3 ba 1e			jp macro_next 
27cd				endm 
# End of macro NEXTW
27cd			.ROT: 
27cd			CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
27cd 45				db WORD_SYS_CORE+49             
27ce 39 28			dw .UWORDS            
27d0 04				db 3 + 1 
27d1 .. 00			db "ROT",0              
27d5				endm 
# End of macro CWHEAD
27d5			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
27d5				if DEBUG_FORTH_WORDS_KEY 
27d5					DMARK "ROT" 
27d5 f5				push af  
27d6 3a ea 27			ld a, (.dmark)  
27d9 32 5e ee			ld (debug_mark),a  
27dc 3a eb 27			ld a, (.dmark+1)  
27df 32 5f ee			ld (debug_mark+1),a  
27e2 3a ec 27			ld a, (.dmark+2)  
27e5 32 60 ee			ld (debug_mark+2),a  
27e8 18 03			jr .pastdmark  
27ea ..			.dmark: db "ROT"  
27ed f1			.pastdmark: pop af  
27ee			endm  
# End of macro DMARK
27ee					CALLMONITOR 
27ee cd 6b ee			call debug_vector  
27f1				endm  
# End of macro CALLMONITOR
27f1				endif 
27f1			 
27f1			; DONE Use os stack swap memory 
27f1			 
27f1				FORTH_DSP_PTR 0     ; u3 
27f1 2a e1 e9			ld hl,(cli_data_sp) 
27f4 11 00 00			ld de, 0 * 3 
27f7 ed 52			sbc hl, de 
27f9				endm 
# End of macro FORTH_DSP_PTR
27f9 cd 0a 1e			call hltostack1     
27fc			  
27fc				FORTH_DSP_PTR 1     ; u2 
27fc 2a e1 e9			ld hl,(cli_data_sp) 
27ff 11 03 00			ld de, 1 * 3 
2802 ed 52			sbc hl, de 
2804				endm 
# End of macro FORTH_DSP_PTR
2804 cd 10 1e			call hltostack2      
2807			 
2807				FORTH_DSP_PTR 2     ; u1 
2807 2a e1 e9			ld hl,(cli_data_sp) 
280a 11 06 00			ld de, 2 * 3 
280d ed 52			sbc hl, de 
280f				endm 
# End of macro FORTH_DSP_PTR
280f cd 16 1e			call hltostack3 
2812			 
2812			 
2812				FORTH_DSP_PTR 0     ;  
2812 2a e1 e9			ld hl,(cli_data_sp) 
2815 11 00 00			ld de, 0 * 3 
2818 ed 52			sbc hl, de 
281a				endm 
# End of macro FORTH_DSP_PTR
281a cd 2e 1e			call hlfromstack3 
281d			 
281d				FORTH_DSP_PTR 1     ; TOS 
281d 2a e1 e9			ld hl,(cli_data_sp) 
2820 11 03 00			ld de, 1 * 3 
2823 ed 52			sbc hl, de 
2825				endm 
# End of macro FORTH_DSP_PTR
2825 cd 22 1e			call hlfromstack1 
2828			 
2828				FORTH_DSP_PTR 2     ; TOS 
2828 2a e1 e9			ld hl,(cli_data_sp) 
282b 11 06 00			ld de, 2 * 3 
282e ed 52			sbc hl, de 
2830				endm 
# End of macro FORTH_DSP_PTR
2830 cd 28 1e			call hlfromstack2 
2833			 
2833			 
2833			;	FORTH_DSP_VALUEHL 
2833			;	push hl    ; u3  
2833			; 
2833			;	FORTH_DSP_POP 
2833			; 
2833			;	FORTH_DSP_VALUEHL 
2833			;	push hl     ; u2 
2833			; 
2833			;	FORTH_DSP_POP 
2833			; 
2833			;	FORTH_DSP_VALUEHL 
2833			;	push hl     ; u1 
2833			; 
2833			;	FORTH_DSP_POP 
2833			; 
2833			;	pop bc      ; u1 
2833			;	pop hl      ; u2 
2833			;	pop de      ; u3 
2833			; 
2833			; 
2833			;	push bc 
2833			;	push de 
2833			;	push hl 
2833			; 
2833			; 
2833			;	pop hl 
2833			;	call forth_push_numhl 
2833			; 
2833			;	pop hl 
2833			;	call forth_push_numhl 
2833			; 
2833			;	pop hl 
2833			;	call forth_push_numhl 
2833				 
2833			 
2833			 
2833			 
2833			 
2833			 
2833			       NEXTW 
2833 cd 68 ee			call parse_vector 
2836 c3 ba 1e			jp macro_next 
2839				endm 
# End of macro NEXTW
2839			 
2839			.UWORDS: 
2839			CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2839 50				db WORD_SYS_CORE+60             
283a fe 28			dw .BP            
283c 07				db 6 + 1 
283d .. 00			db "UWORDS",0              
2844				endm 
# End of macro CWHEAD
2844			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2844			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2844			; | | Following the count are the individual words. 
2844			; | | 
2844			; | | e.g. UWORDS 
2844			; | | BOX DIRLIST 2 
2844			; | |  
2844			; | | Can be used to save the words to storage via: 
2844			; | | UWORDS $01 DO $01 APPEND LOOP 
2844			if DEBUG_FORTH_WORDS_KEY 
2844				DMARK "UWR" 
2844 f5				push af  
2845 3a 59 28			ld a, (.dmark)  
2848 32 5e ee			ld (debug_mark),a  
284b 3a 5a 28			ld a, (.dmark+1)  
284e 32 5f ee			ld (debug_mark+1),a  
2851 3a 5b 28			ld a, (.dmark+2)  
2854 32 60 ee			ld (debug_mark+2),a  
2857 18 03			jr .pastdmark  
2859 ..			.dmark: db "UWR"  
285c f1			.pastdmark: pop af  
285d			endm  
# End of macro DMARK
285d				CALLMONITOR 
285d cd 6b ee			call debug_vector  
2860				endm  
# End of macro CALLMONITOR
2860			endif 
2860 21 9f 67			ld hl, baseram 
2863				;ld hl, baseusermem 
2863 01 00 00			ld bc, 0    ; start a counter 
2866			 
2866			; skip dict stub 
2866			 
2866 cd ec 1f			call forth_tok_next 
2869			 
2869			 
2869			; while we have words to look for 
2869			 
2869 7e			.douscan:	ld a, (hl)      
286a			if DEBUG_FORTH_WORDS 
286a				DMARK "UWs" 
286a f5				push af  
286b 3a 7f 28			ld a, (.dmark)  
286e 32 5e ee			ld (debug_mark),a  
2871 3a 80 28			ld a, (.dmark+1)  
2874 32 5f ee			ld (debug_mark+1),a  
2877 3a 81 28			ld a, (.dmark+2)  
287a 32 60 ee			ld (debug_mark+2),a  
287d 18 03			jr .pastdmark  
287f ..			.dmark: db "UWs"  
2882 f1			.pastdmark: pop af  
2883			endm  
# End of macro DMARK
2883				CALLMONITOR 
2883 cd 6b ee			call debug_vector  
2886				endm  
# End of macro CALLMONITOR
2886			endif 
2886 fe 00			cp WORD_SYS_END 
2888 28 4d			jr z, .udone 
288a fe 01			cp WORD_SYS_UWORD 
288c 20 44			jr nz, .nuword 
288e			 
288e			if DEBUG_FORTH_WORDS 
288e				DMARK "UWu" 
288e f5				push af  
288f 3a a3 28			ld a, (.dmark)  
2892 32 5e ee			ld (debug_mark),a  
2895 3a a4 28			ld a, (.dmark+1)  
2898 32 5f ee			ld (debug_mark+1),a  
289b 3a a5 28			ld a, (.dmark+2)  
289e 32 60 ee			ld (debug_mark+2),a  
28a1 18 03			jr .pastdmark  
28a3 ..			.dmark: db "UWu"  
28a6 f1			.pastdmark: pop af  
28a7			endm  
# End of macro DMARK
28a7				CALLMONITOR 
28a7 cd 6b ee			call debug_vector  
28aa				endm  
# End of macro CALLMONITOR
28aa			endif 
28aa				; we have a uword so push its name to the stack 
28aa			 
28aa e5				push hl  ; save so we can move to next dict block 
28ab			 
28ab				; skip opcode 
28ab 23				inc hl  
28ac				; skip next ptr 
28ac 23				inc hl  
28ad 23				inc hl 
28ae				; skip len 
28ae 23				inc hl 
28af			if DEBUG_FORTH_WORDS 
28af				DMARK "UWt" 
28af f5				push af  
28b0 3a c4 28			ld a, (.dmark)  
28b3 32 5e ee			ld (debug_mark),a  
28b6 3a c5 28			ld a, (.dmark+1)  
28b9 32 5f ee			ld (debug_mark+1),a  
28bc 3a c6 28			ld a, (.dmark+2)  
28bf 32 60 ee			ld (debug_mark+2),a  
28c2 18 03			jr .pastdmark  
28c4 ..			.dmark: db "UWt"  
28c7 f1			.pastdmark: pop af  
28c8			endm  
# End of macro DMARK
28c8				CALLMONITOR 
28c8 cd 6b ee			call debug_vector  
28cb				endm  
# End of macro CALLMONITOR
28cb			endif 
28cb 03				inc bc 
28cc			 
28cc c5				push bc 
28cd cd 41 1b			call forth_push_str 
28d0 c1				pop bc 
28d1			 
28d1 e1				pop hl 	 
28d2			 
28d2 cd ec 1f		.nuword:	call forth_tok_next 
28d5 18 92			jr .douscan  
28d7			 
28d7			.udone:		 ; push count of uwords found 
28d7 c5				push bc 
28d8 e1				pop hl 
28d9			 
28d9			if DEBUG_FORTH_WORDS 
28d9				DMARK "UWc" 
28d9 f5				push af  
28da 3a ee 28			ld a, (.dmark)  
28dd 32 5e ee			ld (debug_mark),a  
28e0 3a ef 28			ld a, (.dmark+1)  
28e3 32 5f ee			ld (debug_mark+1),a  
28e6 3a f0 28			ld a, (.dmark+2)  
28e9 32 60 ee			ld (debug_mark+2),a  
28ec 18 03			jr .pastdmark  
28ee ..			.dmark: db "UWc"  
28f1 f1			.pastdmark: pop af  
28f2			endm  
# End of macro DMARK
28f2				CALLMONITOR 
28f2 cd 6b ee			call debug_vector  
28f5				endm  
# End of macro CALLMONITOR
28f5			endif 
28f5 cd d7 1a			call forth_push_numhl 
28f8			 
28f8			 
28f8			       NEXTW 
28f8 cd 68 ee			call parse_vector 
28fb c3 ba 1e			jp macro_next 
28fe				endm 
# End of macro NEXTW
28fe			 
28fe			.BP: 
28fe			CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
28fe 54				db WORD_SYS_CORE+64             
28ff 3e 29			dw .MONITOR            
2901 03				db 2 + 1 
2902 .. 00			db "BP",0              
2905				endm 
# End of macro CWHEAD
2905			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2905			; | | $00 Will enable the break points within specific code paths 
2905			; | | $01 Will disable break points 
2905			; | |  
2905			; | | By default break points are off. Either the above can be used to enable them 
2905			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2905			; | | and on release of the pressed key the CONFIG menu will be displayed where you 
2905			; | | can disable break points. Exiting will then continue boot process. 
2905				; get byte count 
2905				if DEBUG_FORTH_WORDS_KEY 
2905					DMARK "BP." 
2905 f5				push af  
2906 3a 1a 29			ld a, (.dmark)  
2909 32 5e ee			ld (debug_mark),a  
290c 3a 1b 29			ld a, (.dmark+1)  
290f 32 5f ee			ld (debug_mark+1),a  
2912 3a 1c 29			ld a, (.dmark+2)  
2915 32 60 ee			ld (debug_mark+2),a  
2918 18 03			jr .pastdmark  
291a ..			.dmark: db "BP."  
291d f1			.pastdmark: pop af  
291e			endm  
# End of macro DMARK
291e					CALLMONITOR 
291e cd 6b ee			call debug_vector  
2921				endm  
# End of macro CALLMONITOR
2921				endif 
2921			 
2921				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2921 cd d3 1c			call macro_dsp_valuehl 
2924				endm 
# End of macro FORTH_DSP_VALUEHL
2924			 
2924			;		push hl 
2924			 
2924				; destroy value TOS 
2924			 
2924				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2924 cd 8b 1d			call macro_forth_dsp_pop 
2927				endm 
# End of macro FORTH_DSP_POP
2927			 
2927			;		pop hl 
2927			 
2927 3e 00			ld a,0 
2929 bd				cp l 
292a 28 09			jr z, .bpset 
292c			;		ld a, '*' 
292c cd 62 14			call bp_off 
292f				NEXTW 
292f cd 68 ee			call parse_vector 
2932 c3 ba 1e			jp macro_next 
2935				endm 
# End of macro NEXTW
2935			 
2935			.bpset:	 
2935				;	ld (os_view_disable), a 
2935 cd 56 14			call bp_on 
2938			 
2938			 
2938				NEXTW 
2938 cd 68 ee			call parse_vector 
293b c3 ba 1e			jp macro_next 
293e				endm 
# End of macro NEXTW
293e			 
293e			 
293e			.MONITOR: 
293e			CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
293e 55				db WORD_SYS_CORE+65             
293f 72 29			dw .MALLOC            
2941 08				db 7 + 1 
2942 .. 00			db "MONITOR",0              
294a				endm 
# End of macro CWHEAD
294a			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
294a			; | | At start the current various registers will be displayed with contents. 
294a			; | | Top right corner will show the most recent debug marker seen. 
294a			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
294a			; | | and the return stack pointer (RSP). 
294a			; | | Pressing: 
294a			; | |  
294a			; | |    1 - Initial screen 
294a			; | |  
294a			; | |    2 - Display a data dump of HL 
294a			; | |  
294a			; | |    3 - Display a data dump of DE 
294a			; | |  
294a			; | |    4 - Display a data dump of BC 
294a			; | |  
294a			; | |    5 - Display a data dump of HL 
294a			; | |  
294a			; | |    6 - Display a data dump of DSP 
294a			; | |  
294a			; | |    7 - Display a data dump of RSP 
294a			; | |  
294a			; | |    8 - Display a data dump of what is at DSP 
294a			; | |  
294a			; | |    9 - Display a data dump of what is at RSP 
294a			; | |  
294a			; | |    0 - Exit monitor and continue running. This will also enable break points 
294a			; | |  
294a			; | |    * - Disable break points 
294a			; | |  
294a			; | |    # - Enter traditional monitor mode 
294a			; | |  
294a			; | | 
294a			; | | Monitor Mode 
294a			; | | ------------ 
294a			; | | A prompt of '>' will be shown for various commands: 
294a			; | |  
294a			; | |    D xxxx - Display a data dump starting from hex address xxxx 
294a			; | |  
294a			; | |    C - Continue display a data dump from the last set address 
294a			; | |  
294a			; | |    M xxxx - Set start of memory edit at address xx 
294a			; | |  
294a			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
294a			; | |  
294a			; | |    G xxxx - Exec code at specific address 
294a			; | |  
294a			; | |    Q - Return to previous 
294a				if DEBUG_FORTH_WORDS_KEY 
294a					DMARK "MON" 
294a f5				push af  
294b 3a 5f 29			ld a, (.dmark)  
294e 32 5e ee			ld (debug_mark),a  
2951 3a 60 29			ld a, (.dmark+1)  
2954 32 5f ee			ld (debug_mark+1),a  
2957 3a 61 29			ld a, (.dmark+2)  
295a 32 60 ee			ld (debug_mark+2),a  
295d 18 03			jr .pastdmark  
295f ..			.dmark: db "MON"  
2962 f1			.pastdmark: pop af  
2963			endm  
# End of macro DMARK
2963					CALLMONITOR 
2963 cd 6b ee			call debug_vector  
2966				endm  
# End of macro CALLMONITOR
2966				endif 
2966			;		ld a, 0 
2966			;		ld (os_view_disable), a 
2966 cd 56 14			call bp_on 
2969			 
2969				CALLMONITOR 
2969 cd 6b ee			call debug_vector  
296c				endm  
# End of macro CALLMONITOR
296c			 
296c			;	call monitor 
296c			 
296c				NEXTW 
296c cd 68 ee			call parse_vector 
296f c3 ba 1e			jp macro_next 
2972				endm 
# End of macro NEXTW
2972			 
2972			 
2972			.MALLOC: 
2972			CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2972 56				db WORD_SYS_CORE+66             
2973 9b 29			dw .MALLOC2            
2975 06				db 5 + 1 
2976 .. 00			db "ALLOT",0              
297c				endm 
# End of macro CWHEAD
297c			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
297c				if DEBUG_FORTH_WORDS_KEY 
297c					DMARK "ALL" 
297c f5				push af  
297d 3a 91 29			ld a, (.dmark)  
2980 32 5e ee			ld (debug_mark),a  
2983 3a 92 29			ld a, (.dmark+1)  
2986 32 5f ee			ld (debug_mark+1),a  
2989 3a 93 29			ld a, (.dmark+2)  
298c 32 60 ee			ld (debug_mark+2),a  
298f 18 03			jr .pastdmark  
2991 ..			.dmark: db "ALL"  
2994 f1			.pastdmark: pop af  
2995			endm  
# End of macro DMARK
2995					CALLMONITOR 
2995 cd 6b ee			call debug_vector  
2998				endm  
# End of macro CALLMONITOR
2998				endif 
2998 c3 c2 29			jp .mallocc 
299b			.MALLOC2: 
299b			CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
299b 56				db WORD_SYS_CORE+66             
299c dc 29			dw .FREE            
299e 07				db 6 + 1 
299f .. 00			db "MALLOC",0              
29a6				endm 
# End of macro CWHEAD
29a6			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
29a6				; get byte count 
29a6				if DEBUG_FORTH_WORDS_KEY 
29a6					DMARK "MAL" 
29a6 f5				push af  
29a7 3a bb 29			ld a, (.dmark)  
29aa 32 5e ee			ld (debug_mark),a  
29ad 3a bc 29			ld a, (.dmark+1)  
29b0 32 5f ee			ld (debug_mark+1),a  
29b3 3a bd 29			ld a, (.dmark+2)  
29b6 32 60 ee			ld (debug_mark+2),a  
29b9 18 03			jr .pastdmark  
29bb ..			.dmark: db "MAL"  
29be f1			.pastdmark: pop af  
29bf			endm  
# End of macro DMARK
29bf					CALLMONITOR 
29bf cd 6b ee			call debug_vector  
29c2				endm  
# End of macro CALLMONITOR
29c2				endif 
29c2			.mallocc: 
29c2				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29c2 cd d3 1c			call macro_dsp_valuehl 
29c5				endm 
# End of macro FORTH_DSP_VALUEHL
29c5			 
29c5			;		push hl 
29c5			 
29c5				; destroy value TOS 
29c5			 
29c5				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29c5 cd 8b 1d			call macro_forth_dsp_pop 
29c8				endm 
# End of macro FORTH_DSP_POP
29c8			 
29c8			;		pop hl 
29c8 cd b2 11			call malloc 
29cb			if DEBUG_FORTH_MALLOC_GUARD 
29cb f5				push af 
29cc cd 0f 0e			call ishlzero 
29cf			;		ld a, l 
29cf			;		add h 
29cf			;		cp 0 
29cf f1				pop af 
29d0				 
29d0 cc 54 54			call z,malloc_error 
29d3			endif 
29d3			 
29d3 cd d7 1a			call forth_push_numhl 
29d6				NEXTW 
29d6 cd 68 ee			call parse_vector 
29d9 c3 ba 1e			jp macro_next 
29dc				endm 
# End of macro NEXTW
29dc			 
29dc			.FREE: 
29dc			CWHEAD .UPTR 67 "FREE" 4 WORD_FLAG_CODE 
29dc 57				db WORD_SYS_CORE+67             
29dd 10 2a			dw .UPTR            
29df 05				db 4 + 1 
29e0 .. 00			db "FREE",0              
29e5				endm 
# End of macro CWHEAD
29e5			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
29e5				if DEBUG_FORTH_WORDS_KEY 
29e5					DMARK "FRE" 
29e5 f5				push af  
29e6 3a fa 29			ld a, (.dmark)  
29e9 32 5e ee			ld (debug_mark),a  
29ec 3a fb 29			ld a, (.dmark+1)  
29ef 32 5f ee			ld (debug_mark+1),a  
29f2 3a fc 29			ld a, (.dmark+2)  
29f5 32 60 ee			ld (debug_mark+2),a  
29f8 18 03			jr .pastdmark  
29fa ..			.dmark: db "FRE"  
29fd f1			.pastdmark: pop af  
29fe			endm  
# End of macro DMARK
29fe					CALLMONITOR 
29fe cd 6b ee			call debug_vector  
2a01				endm  
# End of macro CALLMONITOR
2a01				endif 
2a01				; get address 
2a01			 
2a01				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a01 cd d3 1c			call macro_dsp_valuehl 
2a04				endm 
# End of macro FORTH_DSP_VALUEHL
2a04			 
2a04			;		push hl 
2a04			 
2a04				; destroy value TOS 
2a04			 
2a04				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a04 cd 8b 1d			call macro_forth_dsp_pop 
2a07				endm 
# End of macro FORTH_DSP_POP
2a07			 
2a07			;		pop hl 
2a07			if FORTH_ENABLE_MALLOCFREE 
2a07 cd 7c 12			call free 
2a0a			endif 
2a0a				NEXTW 
2a0a cd 68 ee			call parse_vector 
2a0d c3 ba 1e			jp macro_next 
2a10				endm 
# End of macro NEXTW
2a10			.UPTR: 
2a10			CWHEAD .LIST 67 "UPTR" 4 WORD_FLAG_CODE 
2a10 57				db WORD_SYS_CORE+67             
2a11 16 2b			dw .LIST            
2a13 05				db 4 + 1 
2a14 .. 00			db "UPTR",0              
2a19				endm 
# End of macro CWHEAD
2a19			; | UPTR ( s -- u ) Push the address of the exec code for the quoted used word s  | TODO 
2a19				if DEBUG_FORTH_WORDS_KEY 
2a19					DMARK "UPT" 
2a19 f5				push af  
2a1a 3a 2e 2a			ld a, (.dmark)  
2a1d 32 5e ee			ld (debug_mark),a  
2a20 3a 2f 2a			ld a, (.dmark+1)  
2a23 32 5f ee			ld (debug_mark+1),a  
2a26 3a 30 2a			ld a, (.dmark+2)  
2a29 32 60 ee			ld (debug_mark+2),a  
2a2c 18 03			jr .pastdmark  
2a2e ..			.dmark: db "UPT"  
2a31 f1			.pastdmark: pop af  
2a32			endm  
# End of macro DMARK
2a32					CALLMONITOR 
2a32 cd 6b ee			call debug_vector  
2a35				endm  
# End of macro CALLMONITOR
2a35				endif 
2a35				FORTH_DSP_VALUEHL 
2a35 cd d3 1c			call macro_dsp_valuehl 
2a38				endm 
# End of macro FORTH_DSP_VALUEHL
2a38			 
2a38 e5				push hl 
2a39				FORTH_DSP_POP 
2a39 cd 8b 1d			call macro_forth_dsp_pop 
2a3c				endm 
# End of macro FORTH_DSP_POP
2a3c c1				pop bc 
2a3d			 
2a3d			 
2a3d				; Get ptr to the word we need to look up 
2a3d			 
2a3d			;		FORTH_DSP_VALUEHL 
2a3d				;v5 FORTH_DSP_VALUE 
2a3d			; TODO type check 
2a3d			;		inc hl    ; Skip type check  
2a3d			;		push hl 
2a3d			;		ex de, hl    ; put into DE 
2a3d			 
2a3d			 
2a3d 21 9f 67			ld hl, baseram 
2a40				;ld hl, baseusermem 
2a40			 
2a40 e5			push hl   ; sacreifical push 
2a41			 
2a41			.uldouscanm: 
2a41 e1			pop hl 
2a42			.uldouscan: 
2a42			if DEBUG_FORTH_WORDS 
2a42				DMARK "LSs" 
2a42 f5				push af  
2a43 3a 57 2a			ld a, (.dmark)  
2a46 32 5e ee			ld (debug_mark),a  
2a49 3a 58 2a			ld a, (.dmark+1)  
2a4c 32 5f ee			ld (debug_mark+1),a  
2a4f 3a 59 2a			ld a, (.dmark+2)  
2a52 32 60 ee			ld (debug_mark+2),a  
2a55 18 03			jr .pastdmark  
2a57 ..			.dmark: db "LSs"  
2a5a f1			.pastdmark: pop af  
2a5b			endm  
# End of macro DMARK
2a5b				CALLMONITOR 
2a5b cd 6b ee			call debug_vector  
2a5e				endm  
# End of macro CALLMONITOR
2a5e			endif 
2a5e			; skip dict stub 
2a5e cd ec 1f			call forth_tok_next 
2a61			 
2a61			 
2a61			; while we have words to look for 
2a61			 
2a61 7e			ld a, (hl)      
2a62			if DEBUG_FORTH_WORDS 
2a62				DMARK "LSk" 
2a62 f5				push af  
2a63 3a 77 2a			ld a, (.dmark)  
2a66 32 5e ee			ld (debug_mark),a  
2a69 3a 78 2a			ld a, (.dmark+1)  
2a6c 32 5f ee			ld (debug_mark+1),a  
2a6f 3a 79 2a			ld a, (.dmark+2)  
2a72 32 60 ee			ld (debug_mark+2),a  
2a75 18 03			jr .pastdmark  
2a77 ..			.dmark: db "LSk"  
2a7a f1			.pastdmark: pop af  
2a7b			endm  
# End of macro DMARK
2a7b				CALLMONITOR 
2a7b cd 6b ee			call debug_vector  
2a7e				endm  
# End of macro CALLMONITOR
2a7e			endif 
2a7e				;cp WORD_SYS_END 
2a7e				;jp z, .lunotfound 
2a7e			 
2a7e					; if we hit non uwords then gone too far 
2a7e fe 01				cp WORD_SYS_UWORD 
2a80 c2 0d 2b				jp nz, .ulunotfound 
2a83			 
2a83				if DEBUG_FORTH_WORDS 
2a83					DMARK "LSu" 
2a83 f5				push af  
2a84 3a 98 2a			ld a, (.dmark)  
2a87 32 5e ee			ld (debug_mark),a  
2a8a 3a 99 2a			ld a, (.dmark+1)  
2a8d 32 5f ee			ld (debug_mark+1),a  
2a90 3a 9a 2a			ld a, (.dmark+2)  
2a93 32 60 ee			ld (debug_mark+2),a  
2a96 18 03			jr .pastdmark  
2a98 ..			.dmark: db "LSu"  
2a9b f1			.pastdmark: pop af  
2a9c			endm  
# End of macro DMARK
2a9c					CALLMONITOR 
2a9c cd 6b ee			call debug_vector  
2a9f				endm  
# End of macro CALLMONITOR
2a9f				endif 
2a9f			 
2a9f					; found a uword but is it the one we want... 
2a9f			 
2a9f c5					push bc     ; uword to find is on bc 
2aa0 d1					pop de 
2aa1			 
2aa1 e5					push hl  ; to save the ptr 
2aa2			 
2aa2					; skip opcode 
2aa2 23					inc hl  
2aa3					; skip next ptr 
2aa3 23					inc hl  
2aa4 23					inc hl 
2aa5					; skip len 
2aa5 23					inc hl 
2aa6			 
2aa6				if DEBUG_FORTH_WORDS 
2aa6					DMARK "LSc" 
2aa6 f5				push af  
2aa7 3a bb 2a			ld a, (.dmark)  
2aaa 32 5e ee			ld (debug_mark),a  
2aad 3a bc 2a			ld a, (.dmark+1)  
2ab0 32 5f ee			ld (debug_mark+1),a  
2ab3 3a bd 2a			ld a, (.dmark+2)  
2ab6 32 60 ee			ld (debug_mark+2),a  
2ab9 18 03			jr .pastdmark  
2abb ..			.dmark: db "LSc"  
2abe f1			.pastdmark: pop af  
2abf			endm  
# End of macro DMARK
2abf					CALLMONITOR 
2abf cd 6b ee			call debug_vector  
2ac2				endm  
# End of macro CALLMONITOR
2ac2				endif 
2ac2			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
2ac2			; ie. If WOO is defined first and then WO. Couldnt list WO. 
2ac2			; Nope that has gone the other way. It needs to be exact not on first zero 
2ac2			;		call strcmp 
2ac2 c5					push bc 
2ac3 cd 82 11				call StrictStrCmp 
2ac6 c1					pop bc 
2ac7 c2 41 2a				jp nz, .uldouscanm 
2aca				 
2aca			 
2aca			 
2aca					; we have a uword so push its name to the stack 
2aca			 
2aca			;	   	push hl  ; save so we can move to next dict block 
2aca e1			pop hl 
2acb			 
2acb				if DEBUG_FORTH_WORDS 
2acb					DMARK "LSm" 
2acb f5				push af  
2acc 3a e0 2a			ld a, (.dmark)  
2acf 32 5e ee			ld (debug_mark),a  
2ad2 3a e1 2a			ld a, (.dmark+1)  
2ad5 32 5f ee			ld (debug_mark+1),a  
2ad8 3a e2 2a			ld a, (.dmark+2)  
2adb 32 60 ee			ld (debug_mark+2),a  
2ade 18 03			jr .pastdmark  
2ae0 ..			.dmark: db "LSm"  
2ae3 f1			.pastdmark: pop af  
2ae4			endm  
# End of macro DMARK
2ae4					CALLMONITOR 
2ae4 cd 6b ee			call debug_vector  
2ae7				endm  
# End of macro CALLMONITOR
2ae7				endif 
2ae7			 
2ae7					; skip opcode 
2ae7 23					inc hl  
2ae8					; skip next ptr 
2ae8 23					inc hl  
2ae9 23					inc hl 
2aea					; skip len 
2aea 7e					ld a, (hl)   ; save length to add 
2aeb				if DEBUG_FORTH_WORDS 
2aeb					DMARK "LS2" 
2aeb f5				push af  
2aec 3a 00 2b			ld a, (.dmark)  
2aef 32 5e ee			ld (debug_mark),a  
2af2 3a 01 2b			ld a, (.dmark+1)  
2af5 32 5f ee			ld (debug_mark+1),a  
2af8 3a 02 2b			ld a, (.dmark+2)  
2afb 32 60 ee			ld (debug_mark+2),a  
2afe 18 03			jr .pastdmark  
2b00 ..			.dmark: db "LS2"  
2b03 f1			.pastdmark: pop af  
2b04			endm  
# End of macro DMARK
2b04					CALLMONITOR 
2b04 cd 6b ee			call debug_vector  
2b07				endm  
# End of macro CALLMONITOR
2b07				endif 
2b07			 
2b07				; skip zero term and other uword defs to position right at the exec code 
2b07 06 04			ld b, 4 
2b09 80				add a,b 
2b0a			 
2b0a cd e6 0d			call addatohl 
2b0d					; save this location 
2b0d				 
2b0d			.ulunotfound: 
2b0d cd d7 1a			call forth_push_numhl 
2b10						 
2b10				NEXTW 
2b10 cd 68 ee			call parse_vector 
2b13 c3 ba 1e			jp macro_next 
2b16				endm 
# End of macro NEXTW
2b16			.LIST: 
2b16			CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2b16 5c				db WORD_SYS_CORE+72             
2b17 18 2d			dw .FORGET            
2b19 05				db 4 + 1 
2b1a .. 00			db "LIST",0              
2b1f				endm 
# End of macro CWHEAD
2b1f			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2b1f			; | | The quoted word must be in upper case. 
2b1f			if DEBUG_FORTH_WORDS_KEY 
2b1f				DMARK "LST" 
2b1f f5				push af  
2b20 3a 34 2b			ld a, (.dmark)  
2b23 32 5e ee			ld (debug_mark),a  
2b26 3a 35 2b			ld a, (.dmark+1)  
2b29 32 5f ee			ld (debug_mark+1),a  
2b2c 3a 36 2b			ld a, (.dmark+2)  
2b2f 32 60 ee			ld (debug_mark+2),a  
2b32 18 03			jr .pastdmark  
2b34 ..			.dmark: db "LST"  
2b37 f1			.pastdmark: pop af  
2b38			endm  
# End of macro DMARK
2b38				CALLMONITOR 
2b38 cd 6b ee			call debug_vector  
2b3b				endm  
# End of macro CALLMONITOR
2b3b			endif 
2b3b			 
2b3b				FORTH_DSP_VALUEHL 
2b3b cd d3 1c			call macro_dsp_valuehl 
2b3e				endm 
# End of macro FORTH_DSP_VALUEHL
2b3e			 
2b3e e5				push hl 
2b3f				FORTH_DSP_POP 
2b3f cd 8b 1d			call macro_forth_dsp_pop 
2b42				endm 
# End of macro FORTH_DSP_POP
2b42 c1				pop bc 
2b43			 
2b43			; Start format of scratch string 
2b43			 
2b43 21 b4 e2			ld hl, scratch 
2b46			 
2b46			;	ld a, ':' 
2b46 36 3a			ld (hl),':' 
2b48 23				inc hl 
2b49			;	ld a, ' ' 
2b49 36 20			ld (hl), ' ' 
2b4b			 
2b4b				; Get ptr to the word we need to look up 
2b4b			 
2b4b			;		FORTH_DSP_VALUEHL 
2b4b				;v5 FORTH_DSP_VALUE 
2b4b			; TODO type check 
2b4b			;		inc hl    ; Skip type check  
2b4b			;		push hl 
2b4b			;		ex de, hl    ; put into DE 
2b4b			 
2b4b			 
2b4b 21 9f 67			ld hl, baseram 
2b4e				;ld hl, baseusermem 
2b4e			 
2b4e e5			push hl   ; sacreifical push 
2b4f			 
2b4f			.ldouscanm: 
2b4f e1			pop hl 
2b50			.ldouscan: 
2b50			if DEBUG_FORTH_WORDS 
2b50				DMARK "LSs" 
2b50 f5				push af  
2b51 3a 65 2b			ld a, (.dmark)  
2b54 32 5e ee			ld (debug_mark),a  
2b57 3a 66 2b			ld a, (.dmark+1)  
2b5a 32 5f ee			ld (debug_mark+1),a  
2b5d 3a 67 2b			ld a, (.dmark+2)  
2b60 32 60 ee			ld (debug_mark+2),a  
2b63 18 03			jr .pastdmark  
2b65 ..			.dmark: db "LSs"  
2b68 f1			.pastdmark: pop af  
2b69			endm  
# End of macro DMARK
2b69				CALLMONITOR 
2b69 cd 6b ee			call debug_vector  
2b6c				endm  
# End of macro CALLMONITOR
2b6c			endif 
2b6c			; skip dict stub 
2b6c cd ec 1f			call forth_tok_next 
2b6f			 
2b6f			 
2b6f			; while we have words to look for 
2b6f			 
2b6f 7e			ld a, (hl)      
2b70			if DEBUG_FORTH_WORDS 
2b70				DMARK "LSk" 
2b70 f5				push af  
2b71 3a 85 2b			ld a, (.dmark)  
2b74 32 5e ee			ld (debug_mark),a  
2b77 3a 86 2b			ld a, (.dmark+1)  
2b7a 32 5f ee			ld (debug_mark+1),a  
2b7d 3a 87 2b			ld a, (.dmark+2)  
2b80 32 60 ee			ld (debug_mark+2),a  
2b83 18 03			jr .pastdmark  
2b85 ..			.dmark: db "LSk"  
2b88 f1			.pastdmark: pop af  
2b89			endm  
# End of macro DMARK
2b89				CALLMONITOR 
2b89 cd 6b ee			call debug_vector  
2b8c				endm  
# End of macro CALLMONITOR
2b8c			endif 
2b8c				;cp WORD_SYS_END 
2b8c				;jp z, .lunotfound 
2b8c			 
2b8c					; if we hit non uwords then gone too far 
2b8c fe 01				cp WORD_SYS_UWORD 
2b8e c2 cb 2c				jp nz, .lunotfound 
2b91			 
2b91				if DEBUG_FORTH_WORDS 
2b91					DMARK "LSu" 
2b91 f5				push af  
2b92 3a a6 2b			ld a, (.dmark)  
2b95 32 5e ee			ld (debug_mark),a  
2b98 3a a7 2b			ld a, (.dmark+1)  
2b9b 32 5f ee			ld (debug_mark+1),a  
2b9e 3a a8 2b			ld a, (.dmark+2)  
2ba1 32 60 ee			ld (debug_mark+2),a  
2ba4 18 03			jr .pastdmark  
2ba6 ..			.dmark: db "LSu"  
2ba9 f1			.pastdmark: pop af  
2baa			endm  
# End of macro DMARK
2baa					CALLMONITOR 
2baa cd 6b ee			call debug_vector  
2bad				endm  
# End of macro CALLMONITOR
2bad				endif 
2bad			 
2bad					; found a uword but is it the one we want... 
2bad			 
2bad c5					push bc     ; uword to find is on bc 
2bae d1					pop de 
2baf			 
2baf e5					push hl  ; to save the ptr 
2bb0			 
2bb0					; skip opcode 
2bb0 23					inc hl  
2bb1					; skip next ptr 
2bb1 23					inc hl  
2bb2 23					inc hl 
2bb3					; skip len 
2bb3 23					inc hl 
2bb4			 
2bb4				if DEBUG_FORTH_WORDS 
2bb4					DMARK "LSc" 
2bb4 f5				push af  
2bb5 3a c9 2b			ld a, (.dmark)  
2bb8 32 5e ee			ld (debug_mark),a  
2bbb 3a ca 2b			ld a, (.dmark+1)  
2bbe 32 5f ee			ld (debug_mark+1),a  
2bc1 3a cb 2b			ld a, (.dmark+2)  
2bc4 32 60 ee			ld (debug_mark+2),a  
2bc7 18 03			jr .pastdmark  
2bc9 ..			.dmark: db "LSc"  
2bcc f1			.pastdmark: pop af  
2bcd			endm  
# End of macro DMARK
2bcd					CALLMONITOR 
2bcd cd 6b ee			call debug_vector  
2bd0				endm  
# End of macro CALLMONITOR
2bd0				endif 
2bd0			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
2bd0			; ie. If WOO is defined first and then WO. Couldnt list WO. 
2bd0			; Nope that has gone the other way. It needs to be exact not on first zero 
2bd0			;		call strcmp 
2bd0 c5					push bc 
2bd1 cd 82 11				call StrictStrCmp 
2bd4 c1					pop bc 
2bd5 c2 4f 2b				jp nz, .ldouscanm 
2bd8				 
2bd8			 
2bd8			 
2bd8					; we have a uword so push its name to the stack 
2bd8			 
2bd8			;	   	push hl  ; save so we can move to next dict block 
2bd8 e1			pop hl 
2bd9			 
2bd9				if DEBUG_FORTH_WORDS 
2bd9					DMARK "LSm" 
2bd9 f5				push af  
2bda 3a ee 2b			ld a, (.dmark)  
2bdd 32 5e ee			ld (debug_mark),a  
2be0 3a ef 2b			ld a, (.dmark+1)  
2be3 32 5f ee			ld (debug_mark+1),a  
2be6 3a f0 2b			ld a, (.dmark+2)  
2be9 32 60 ee			ld (debug_mark+2),a  
2bec 18 03			jr .pastdmark  
2bee ..			.dmark: db "LSm"  
2bf1 f1			.pastdmark: pop af  
2bf2			endm  
# End of macro DMARK
2bf2					CALLMONITOR 
2bf2 cd 6b ee			call debug_vector  
2bf5				endm  
# End of macro CALLMONITOR
2bf5				endif 
2bf5			 
2bf5					; skip opcode 
2bf5 23					inc hl  
2bf6					; skip next ptr 
2bf6 23					inc hl  
2bf7 23					inc hl 
2bf8					; skip len 
2bf8 7e					ld a, (hl)   ; save length to add 
2bf9				if DEBUG_FORTH_WORDS 
2bf9					DMARK "LS2" 
2bf9 f5				push af  
2bfa 3a 0e 2c			ld a, (.dmark)  
2bfd 32 5e ee			ld (debug_mark),a  
2c00 3a 0f 2c			ld a, (.dmark+1)  
2c03 32 5f ee			ld (debug_mark+1),a  
2c06 3a 10 2c			ld a, (.dmark+2)  
2c09 32 60 ee			ld (debug_mark+2),a  
2c0c 18 03			jr .pastdmark  
2c0e ..			.dmark: db "LS2"  
2c11 f1			.pastdmark: pop af  
2c12			endm  
# End of macro DMARK
2c12					CALLMONITOR 
2c12 cd 6b ee			call debug_vector  
2c15				endm  
# End of macro CALLMONITOR
2c15				endif 
2c15			 
2c15					; save this location 
2c15				 
2c15 e5					push hl 
2c16			 
2c16 23					inc hl 
2c17 11 b6 e2				ld de, scratch+2 
2c1a 4f					ld c, a 
2c1b 06 00				ld b, 0 
2c1d			 
2c1d				if DEBUG_FORTH_WORDS 
2c1d					DMARK "LSn" 
2c1d f5				push af  
2c1e 3a 32 2c			ld a, (.dmark)  
2c21 32 5e ee			ld (debug_mark),a  
2c24 3a 33 2c			ld a, (.dmark+1)  
2c27 32 5f ee			ld (debug_mark+1),a  
2c2a 3a 34 2c			ld a, (.dmark+2)  
2c2d 32 60 ee			ld (debug_mark+2),a  
2c30 18 03			jr .pastdmark  
2c32 ..			.dmark: db "LSn"  
2c35 f1			.pastdmark: pop af  
2c36			endm  
# End of macro DMARK
2c36					CALLMONITOR 
2c36 cd 6b ee			call debug_vector  
2c39				endm  
# End of macro CALLMONITOR
2c39				endif 
2c39			 
2c39					; copy uword name to scratch 
2c39			 
2c39			;		ldir 
2c39			.licplw:	; copy uword name to scratch converting to lower case as we go 
2c39 ed a0				ldi 
2c3b 1b					dec de 
2c3c 1a					ld a, (de) 
2c3d cd 57 10				call to_lower 
2c40 12					ld (de),a 
2c41 13					inc de 
2c42 3e 00				ld a, 0 
2c44 b9					cp c 
2c45 20 f2				jr nz, .licplw 
2c47			 
2c47			 
2c47			 
2c47 1b					dec de 
2c48 3e 20				ld a, ' '    ; change null to space 
2c4a 12					ld (de), a 
2c4b			 
2c4b 13					inc de 
2c4c			 
2c4c d5					push de 
2c4d c1					pop bc     ; move scratch pointer to end of word name and save it 
2c4e			 
2c4e e1					pop hl 
2c4f 7e					ld a, (hl) 
2c50					;inc hl 
2c50					; skip word string 
2c50 cd e6 0d				call addatohl 
2c53			 
2c53 23					inc hl 
2c54			 
2c54				if DEBUG_FORTH_WORDS 
2c54					DMARK "LS3" 
2c54 f5				push af  
2c55 3a 69 2c			ld a, (.dmark)  
2c58 32 5e ee			ld (debug_mark),a  
2c5b 3a 6a 2c			ld a, (.dmark+1)  
2c5e 32 5f ee			ld (debug_mark+1),a  
2c61 3a 6b 2c			ld a, (.dmark+2)  
2c64 32 60 ee			ld (debug_mark+2),a  
2c67 18 03			jr .pastdmark  
2c69 ..			.dmark: db "LS3"  
2c6c f1			.pastdmark: pop af  
2c6d			endm  
# End of macro DMARK
2c6d					CALLMONITOR 
2c6d cd 6b ee			call debug_vector  
2c70				endm  
# End of macro CALLMONITOR
2c70				endif 
2c70					; should now be at the start of the machine code to setup the eval of the uword 
2c70					; now locate the ptr to the string defintion 
2c70			 
2c70					; skip ld hl, 
2c70					; then load the ptr 
2c70			; TODO use get from hl ptr 
2c70 23					inc hl 
2c71 5e					ld e, (hl) 
2c72 23					inc hl 
2c73 56					ld d, (hl) 
2c74 eb					ex de, hl 
2c75			 
2c75			 
2c75				if DEBUG_FORTH_WORDS 
2c75					DMARK "LSt" 
2c75 f5				push af  
2c76 3a 8a 2c			ld a, (.dmark)  
2c79 32 5e ee			ld (debug_mark),a  
2c7c 3a 8b 2c			ld a, (.dmark+1)  
2c7f 32 5f ee			ld (debug_mark+1),a  
2c82 3a 8c 2c			ld a, (.dmark+2)  
2c85 32 60 ee			ld (debug_mark+2),a  
2c88 18 03			jr .pastdmark  
2c8a ..			.dmark: db "LSt"  
2c8d f1			.pastdmark: pop af  
2c8e			endm  
# End of macro DMARK
2c8e					CALLMONITOR 
2c8e cd 6b ee			call debug_vector  
2c91				endm  
# End of macro CALLMONITOR
2c91				endif 
2c91			 
2c91			; cant push right now due to tokenised strings  
2c91			 
2c91			; get the destination of where to copy this definition to. 
2c91			 
2c91 c5					push bc 
2c92 d1					pop de 
2c93			 
2c93 7e			.listl:         ld a,(hl) 
2c94			;		cp 0 
2c94 b7					or a 
2c95 28 09				jr z, .lreplsp     ; replace zero with space 
2c97					;cp FORTH_END_BUFFER 
2c97 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2c99 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2c9b				 
2c9b					; just copy this char as is then 
2c9b			 
2c9b 12					ld (de), a 
2c9c			 
2c9c 23			.listnxt:	inc hl 
2c9d 13					inc de 
2c9e 18 f3				jr .listl 
2ca0			 
2ca0 3e 20		.lreplsp:	ld a,' ' 
2ca2 12					ld (de), a 
2ca3 18 f7				jr .listnxt 
2ca5			 
2ca5			; close up uword def 
2ca5			 
2ca5			.listdone: 
2ca5 12					ld (de), a 
2ca6 13					inc de 
2ca7 3e 00				ld a, 0 
2ca9 12					ld (de), a 
2caa			 
2caa			; now have def so clean up and push to stack 
2caa			 
2caa 21 b4 e2				ld hl, scratch 
2cad				if DEBUG_FORTH_WORDS 
2cad					DMARK "Ltp" 
2cad f5				push af  
2cae 3a c2 2c			ld a, (.dmark)  
2cb1 32 5e ee			ld (debug_mark),a  
2cb4 3a c3 2c			ld a, (.dmark+1)  
2cb7 32 5f ee			ld (debug_mark+1),a  
2cba 3a c4 2c			ld a, (.dmark+2)  
2cbd 32 60 ee			ld (debug_mark+2),a  
2cc0 18 03			jr .pastdmark  
2cc2 ..			.dmark: db "Ltp"  
2cc5 f1			.pastdmark: pop af  
2cc6			endm  
# End of macro DMARK
2cc6					CALLMONITOR 
2cc6 cd 6b ee			call debug_vector  
2cc9				endm  
# End of macro CALLMONITOR
2cc9				endif 
2cc9			 
2cc9 18 22			jr .listpush 
2ccb			 
2ccb			;.lnuword:	pop hl 
2ccb			;		call forth_tok_next 
2ccb			;		jp .ldouscan  
2ccb			 
2ccb			.lunotfound:		  
2ccb			 
2ccb				if DEBUG_FORTH_WORDS 
2ccb					DMARK "LSn" 
2ccb f5				push af  
2ccc 3a e0 2c			ld a, (.dmark)  
2ccf 32 5e ee			ld (debug_mark),a  
2cd2 3a e1 2c			ld a, (.dmark+1)  
2cd5 32 5f ee			ld (debug_mark+1),a  
2cd8 3a e2 2c			ld a, (.dmark+2)  
2cdb 32 60 ee			ld (debug_mark+2),a  
2cde 18 03			jr .pastdmark  
2ce0 ..			.dmark: db "LSn"  
2ce3 f1			.pastdmark: pop af  
2ce4			endm  
# End of macro DMARK
2ce4					CALLMONITOR 
2ce4 cd 6b ee			call debug_vector  
2ce7				endm  
# End of macro CALLMONITOR
2ce7				endif 
2ce7			 
2ce7					 
2ce7			;		FORTH_DSP_POP 
2ce7			;		ld hl, .luno 
2ce7			 
2ce7					NEXTW			 
2ce7 cd 68 ee			call parse_vector 
2cea c3 ba 1e			jp macro_next 
2ced				endm 
# End of macro NEXTW
2ced			 
2ced			.listpush: 
2ced				if DEBUG_FORTH_WORDS 
2ced					DMARK "LS>" 
2ced f5				push af  
2cee 3a 02 2d			ld a, (.dmark)  
2cf1 32 5e ee			ld (debug_mark),a  
2cf4 3a 03 2d			ld a, (.dmark+1)  
2cf7 32 5f ee			ld (debug_mark+1),a  
2cfa 3a 04 2d			ld a, (.dmark+2)  
2cfd 32 60 ee			ld (debug_mark+2),a  
2d00 18 03			jr .pastdmark  
2d02 ..			.dmark: db "LS>"  
2d05 f1			.pastdmark: pop af  
2d06			endm  
# End of macro DMARK
2d06					CALLMONITOR 
2d06 cd 6b ee			call debug_vector  
2d09				endm  
# End of macro CALLMONITOR
2d09				endif 
2d09 cd 41 1b				call forth_push_str 
2d0c			 
2d0c			 
2d0c			 
2d0c					NEXTW 
2d0c cd 68 ee			call parse_vector 
2d0f c3 ba 1e			jp macro_next 
2d12				endm 
# End of macro NEXTW
2d12			 
2d12			;.luno:    db "Word not found",0 
2d12			 
2d12			 
2d12			 
2d12			 
2d12			 
2d12			;		push hl   ; save pointer to start of uword def string 
2d12			; 
2d12			;; look for FORTH_EOL_LINE 
2d12			;		ld a, FORTH_END_BUFFER 
2d12			;		call strlent 
2d12			; 
2d12			;		inc hl		 ; space for coln def 
2d12			;		inc hl 
2d12			;		inc hl          ; space for terms 
2d12			;		inc hl 
2d12			; 
2d12			;		ld a, 20   ; TODO get actual length 
2d12			;		call addatohl    ; include a random amount of room for the uword name 
2d12			; 
2d12			;		 
2d12			;	if DEBUG_FORTH_WORDS 
2d12			;		DMARK "Lt1" 
2d12			;		CALLMONITOR 
2d12			;	endif 
2d12			;		 
2d12			; 
2d12			;; malloc space for the string because we cant change it 
2d12			; 
2d12			;		call malloc 
2d12			;	if DEBUG_FORTH_MALLOC_GUARD 
2d12			;		push af 
2d12			;		call ishlzero 
2d12			;		pop af 
2d12			;		 
2d12			;		call z,malloc_error 
2d12			;	endif 
2d12			; 
2d12			;	if DEBUG_FORTH_WORDS 
2d12			;		DMARK "Lt2" 
2d12			;		CALLMONITOR 
2d12			;	endif 
2d12			;		pop de 
2d12			;		push hl    ; push the malloc to release later 
2d12			;		push hl   ;  push back a copy for the later stack push 
2d12			;		 
2d12			;; copy the string swapping out the zero terms for spaces 
2d12			; 
2d12			;		; de has our source 
2d12			;		; hl has our dest 
2d12			; 
2d12			;; add the coln def 
2d12			; 
2d12			;		ld a, ':' 
2d12			;		ld (hl), a 
2d12			;		inc hl 
2d12			;		ld a, ' ' 
2d12			;		ld (hl), a 
2d12			;		inc hl 
2d12			; 
2d12			;; add the uname word 
2d12			;		push de   ; save our string for now 
2d12			;		ex de, hl 
2d12			; 
2d12			;		FORTH_DSP_VALUE 
2d12			;		;v5 FORTH_DSP_VALUE 
2d12			; 
2d12			;		inc hl   ; skip type but we know by now this is OK 
2d12			; 
2d12			;.luword:	ld a,(hl) 
2d12			;		cp 0 
2d12			;		jr z, .luword2 
2d12			;		ld (de), a 
2d12			;		inc de 
2d12			;		inc hl 
2d12			;		jr .luword 
2d12			; 
2d12			;.luword2:	ld a, ' ' 
2d12			;		ld (de), a 
2d12			;;		inc hl 
2d12			;;		inc de 
2d12			;;		ld (de), a 
2d12			;;		inc hl 
2d12			;		inc de 
2d12			; 
2d12			;		ex de, hl 
2d12			;		pop de 
2d12			;		 
2d12			;		 
2d12			; 
2d12			;; detoken that string and copy it 
2d12			; 
2d12			;	if DEBUG_FORTH_WORDS 
2d12			;		DMARK "Lt2" 
2d12			;		CALLMONITOR 
2d12			;	endif 
2d12			;.ldetok:	ld a, (de) 
2d12			;		cp FORTH_END_BUFFER 
2d12			;		jr z, .ldetokend 
2d12			;		; swap out any zero term for space 
2d12			;		cp 0 
2d12			;		jr nz, .ldetoknext 
2d12			;		ld a, ' ' 
2d12			; 
2d12			;	if DEBUG_FORTH_WORDS 
2d12			;		DMARK "LtS" 
2d12			;		CALLMONITOR 
2d12			;	endif 
2d12			;.ldetoknext:	ld (hl), a 
2d12			;		inc de 
2d12			;		inc hl 
2d12			;		jr .ldetok 
2d12			; 
2d12			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2d12			;		ld (hl), a  
2d12			; 
2d12			;; free that temp malloc 
2d12			; 
2d12			;		pop hl    
2d12			; 
2d12			;	if DEBUG_FORTH_WORDS 
2d12			;		DMARK "Lt4" 
2d12			;		CALLMONITOR 
2d12			;	endif 
2d12			;		call forth_apushstrhl 
2d12			; 
2d12			;		; get rid of temp malloc area 
2d12			; 
2d12			;		pop hl 
2d12			;		call free 
2d12			; 
2d12			;		jr .ludone 
2d12			; 
2d12			;.lnuword:	pop hl 
2d12			;		call forth_tok_next 
2d12			;		jp .ldouscan  
2d12			; 
2d12			;.ludone:		 pop hl 
2d12			; 
2d12					NEXTW 
2d12 cd 68 ee			call parse_vector 
2d15 c3 ba 1e			jp macro_next 
2d18				endm 
# End of macro NEXTW
2d18			 
2d18			.FORGET: 
2d18				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2d18 5d				db WORD_SYS_CORE+73             
2d19 93 2d			dw .NOP            
2d1b 07				db 6 + 1 
2d1c .. 00			db "FORGET",0              
2d23				endm 
# End of macro CWHEAD
2d23			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2d23			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quoted uword name must be in caps. 
2d23			; | |  
2d23			; | | e.g. "MORE" forget 
2d23					if DEBUG_FORTH_WORDS_KEY 
2d23						DMARK "FRG" 
2d23 f5				push af  
2d24 3a 38 2d			ld a, (.dmark)  
2d27 32 5e ee			ld (debug_mark),a  
2d2a 3a 39 2d			ld a, (.dmark+1)  
2d2d 32 5f ee			ld (debug_mark+1),a  
2d30 3a 3a 2d			ld a, (.dmark+2)  
2d33 32 60 ee			ld (debug_mark+2),a  
2d36 18 03			jr .pastdmark  
2d38 ..			.dmark: db "FRG"  
2d3b f1			.pastdmark: pop af  
2d3c			endm  
# End of macro DMARK
2d3c						CALLMONITOR 
2d3c cd 6b ee			call debug_vector  
2d3f				endm  
# End of macro CALLMONITOR
2d3f					endif 
2d3f			 
2d3f				; find uword 
2d3f			        ; update start of word with "_" 
2d3f				; replace uword with deleted flag 
2d3f			 
2d3f			 
2d3f			;	if DEBUG_FORTH_WORDS 
2d3f			;		DMARK "FOG" 
2d3f			;		CALLMONITOR 
2d3f			;	endif 
2d3f			 
2d3f			 
2d3f					; Get ptr to the word we need to look up 
2d3f			 
2d3f					FORTH_DSP_VALUEHL 
2d3f cd d3 1c			call macro_dsp_valuehl 
2d42				endm 
# End of macro FORTH_DSP_VALUEHL
2d42					;v5 FORTH_DSP_VALUE 
2d42				; TODO type check 
2d42			;		inc hl    ; Skip type check  
2d42 e5					push hl 
2d43 c1					pop bc 
2d44			;		ex de, hl    ; put into DE 
2d44			 
2d44			 
2d44 21 9f 67				ld hl, baseram 
2d47					;ld hl, baseusermem 
2d47			 
2d47				; skip dict stub 
2d47			;	call forth_tok_next 
2d47 e5			push hl   ; sacreifical push 
2d48			 
2d48			.fldouscanm: 
2d48 e1				pop hl 
2d49			.fldouscan: 
2d49			;	if DEBUG_FORTH_WORDS 
2d49			;		DMARK "LSs" 
2d49			;		CALLMONITOR 
2d49			;	endif 
2d49				; skip dict stub 
2d49 cd ec 1f				call forth_tok_next 
2d4c			 
2d4c			 
2d4c			; while we have words to look for 
2d4c			 
2d4c 7e				ld a, (hl)      
2d4d			;	if DEBUG_FORTH_WORDS 
2d4d			;		DMARK "LSk" 
2d4d			;		CALLMONITOR 
2d4d			;	endif 
2d4d fe 00				cp WORD_SYS_END 
2d4f ca 8a 2d				jp z, .flunotfound 
2d52 fe 01				cp WORD_SYS_UWORD 
2d54 c2 49 2d				jp nz, .fldouscan 
2d57			 
2d57			;	if DEBUG_FORTH_WORDS 
2d57			;		DMARK "LSu" 
2d57			;		CALLMONITOR 
2d57			;	endif 
2d57			 
2d57					; found a uword but is it the one we want... 
2d57			 
2d57 c5					push bc     ; uword to find is on bc 
2d58 d1					pop de 
2d59			 
2d59 e5					push hl  ; to save the ptr 
2d5a			 
2d5a					; skip opcode 
2d5a 23					inc hl  
2d5b					; skip next ptr 
2d5b 23					inc hl  
2d5c 23					inc hl 
2d5d					; skip len 
2d5d 23					inc hl 
2d5e			 
2d5e			;	if DEBUG_FORTH_WORDS 
2d5e			;		DMARK "LSc" 
2d5e			;		CALLMONITOR 
2d5e			;	endif 
2d5e cd 76 11				call strcmp 
2d61 c2 48 2d				jp nz, .fldouscanm 
2d64			; 
2d64			; 
2d64			;; while we have words to look for 
2d64			; 
2d64			;.fdouscan:	ld a, (hl)      
2d64			;	if DEBUG_FORTH_WORDS 
2d64			;		DMARK "LSs" 
2d64			;		CALLMONITOR 
2d64			;	endif 
2d64			;		cp WORD_SYS_END 
2d64			;		jp z, .fudone 
2d64			;		cp WORD_SYS_UWORD 
2d64			;		jp nz, .fnuword 
2d64			; 
2d64			;	if DEBUG_FORTH_WORDS 
2d64			;		DMARK "FGu" 
2d64			;		CALLMONITOR 
2d64			;	endif 
2d64			; 
2d64			;		; found a uword but is it the one we want... 
2d64			; 
2d64			; 
2d64			;	        pop de   ; get back the dsp name 
2d64			;		push de 
2d64			; 
2d64			;		push hl  ; to save the ptr 
2d64			; 
2d64			;		; skip opcode 
2d64			;		inc hl  
2d64			;		; skip next ptr 
2d64			;		inc hl  
2d64			;		inc hl 
2d64			;		; skip len 
2d64			;		inc hl 
2d64			; 
2d64			;	if DEBUG_FORTH_WORDS 
2d64			;		DMARK "FGc" 
2d64			;		CALLMONITOR 
2d64			;	endif 
2d64			;		call strcmp 
2d64			;		jp nz, .fnuword 
2d64			 
2d64			 
2d64 e1			pop hl 
2d65			 
2d65				 
2d65				if DEBUG_FORTH_WORDS 
2d65					DMARK "FGm" 
2d65 f5				push af  
2d66 3a 7a 2d			ld a, (.dmark)  
2d69 32 5e ee			ld (debug_mark),a  
2d6c 3a 7b 2d			ld a, (.dmark+1)  
2d6f 32 5f ee			ld (debug_mark+1),a  
2d72 3a 7c 2d			ld a, (.dmark+2)  
2d75 32 60 ee			ld (debug_mark+2),a  
2d78 18 03			jr .pastdmark  
2d7a ..			.dmark: db "FGm"  
2d7d f1			.pastdmark: pop af  
2d7e			endm  
# End of macro DMARK
2d7e					CALLMONITOR 
2d7e cd 6b ee			call debug_vector  
2d81				endm  
# End of macro CALLMONITOR
2d81				endif 
2d81			 
2d81			 
2d81			 
2d81					; we have a uword so push its name to the stack 
2d81			 
2d81			;	   	push hl  ; save so we can move to next dict block 
2d81			;pop hl 
2d81			 
2d81					; update opcode to deleted 
2d81			;		ld a, WORD_SYS_DELETED 
2d81 36 03				ld (hl), WORD_SYS_DELETED 
2d83			 
2d83 23					inc hl  
2d84					; skip next ptr 
2d84 23					inc hl  
2d85 23					inc hl 
2d86					; skip len 
2d86 23					inc hl 
2d87			 
2d87					; TODO change parser to skip deleted words but for now mark it out 
2d87 3e 5f				ld a, "_" 
2d89 77					ld  (hl),a 
2d8a			 
2d8a			;		jr .fudone 
2d8a			; 
2d8a			;.fnuword:	pop hl 
2d8a			;		call forth_tok_next 
2d8a			;		jp .fdouscan  
2d8a			 
2d8a			.flunotfound:		  
2d8a			 
2d8a			 
2d8a					 
2d8a					FORTH_DSP_POP 
2d8a cd 8b 1d			call macro_forth_dsp_pop 
2d8d				endm 
# End of macro FORTH_DSP_POP
2d8d			;		ld hl, .luno 
2d8d			;.fudone:		 pop hl 
2d8d					NEXTW 
2d8d cd 68 ee			call parse_vector 
2d90 c3 ba 1e			jp macro_next 
2d93				endm 
# End of macro NEXTW
2d93			.NOP: 
2d93				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2d93 61				db WORD_SYS_CORE+77             
2d94 bd 2d			dw .COMO            
2d96 04				db 3 + 1 
2d97 .. 00			db "NOP",0              
2d9b				endm 
# End of macro CWHEAD
2d9b			; | NOP (  --  ) Do nothing | DONE 
2d9b					if DEBUG_FORTH_WORDS_KEY 
2d9b						DMARK "NOP" 
2d9b f5				push af  
2d9c 3a b0 2d			ld a, (.dmark)  
2d9f 32 5e ee			ld (debug_mark),a  
2da2 3a b1 2d			ld a, (.dmark+1)  
2da5 32 5f ee			ld (debug_mark+1),a  
2da8 3a b2 2d			ld a, (.dmark+2)  
2dab 32 60 ee			ld (debug_mark+2),a  
2dae 18 03			jr .pastdmark  
2db0 ..			.dmark: db "NOP"  
2db3 f1			.pastdmark: pop af  
2db4			endm  
# End of macro DMARK
2db4						CALLMONITOR 
2db4 cd 6b ee			call debug_vector  
2db7				endm  
# End of macro CALLMONITOR
2db7					endif 
2db7				       NEXTW 
2db7 cd 68 ee			call parse_vector 
2dba c3 ba 1e			jp macro_next 
2dbd				endm 
# End of macro NEXTW
2dbd			.COMO: 
2dbd				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2dbd 6e				db WORD_SYS_CORE+90             
2dbe 12 2e			dw .COMC            
2dc0 02				db 1 + 1 
2dc1 .. 00			db "(",0              
2dc3				endm 
# End of macro CWHEAD
2dc3			; | ( ( -- )  Start of comment | DONE 
2dc3			 
2dc3			 
2dc3 2a b5 e5				ld hl, ( os_tok_ptr) 
2dc6 11 0a 2e			ld de, .closepar 
2dc9					 
2dc9					if DEBUG_FORTH_WORDS 
2dc9						DMARK ").." 
2dc9 f5				push af  
2dca 3a de 2d			ld a, (.dmark)  
2dcd 32 5e ee			ld (debug_mark),a  
2dd0 3a df 2d			ld a, (.dmark+1)  
2dd3 32 5f ee			ld (debug_mark+1),a  
2dd6 3a e0 2d			ld a, (.dmark+2)  
2dd9 32 60 ee			ld (debug_mark+2),a  
2ddc 18 03			jr .pastdmark  
2dde ..			.dmark: db ").."  
2de1 f1			.pastdmark: pop af  
2de2			endm  
# End of macro DMARK
2de2						CALLMONITOR 
2de2 cd 6b ee			call debug_vector  
2de5				endm  
# End of macro CALLMONITOR
2de5					endif 
2de5 cd b7 1f			call findnexttok  
2de8			 
2de8					if DEBUG_FORTH_WORDS 
2de8						DMARK "IF5" 
2de8 f5				push af  
2de9 3a fd 2d			ld a, (.dmark)  
2dec 32 5e ee			ld (debug_mark),a  
2def 3a fe 2d			ld a, (.dmark+1)  
2df2 32 5f ee			ld (debug_mark+1),a  
2df5 3a ff 2d			ld a, (.dmark+2)  
2df8 32 60 ee			ld (debug_mark+2),a  
2dfb 18 03			jr .pastdmark  
2dfd ..			.dmark: db "IF5"  
2e00 f1			.pastdmark: pop af  
2e01			endm  
# End of macro DMARK
2e01						CALLMONITOR 
2e01 cd 6b ee			call debug_vector  
2e04				endm  
# End of macro CALLMONITOR
2e04					endif 
2e04				; replace below with ) exec using tok_ptr 
2e04 22 b5 e5			ld (os_tok_ptr), hl 
2e07 c3 3b 1f			jp exec1 
2e0a			 
2e0a .. 00			.closepar:   db ")",0 
2e0c			 
2e0c				       NEXTW 
2e0c cd 68 ee			call parse_vector 
2e0f c3 ba 1e			jp macro_next 
2e12				endm 
# End of macro NEXTW
2e12			.COMC: 
2e12				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2e12 6f				db WORD_SYS_CORE+91             
2e13 1e 2e			dw .SCRATCH            
2e15 02				db 1 + 1 
2e16 .. 00			db ")",0              
2e18				endm 
# End of macro CWHEAD
2e18			; | ) ( -- )  End of comment |  DONE  
2e18				       NEXTW 
2e18 cd 68 ee			call parse_vector 
2e1b c3 ba 1e			jp macro_next 
2e1e				endm 
# End of macro NEXTW
2e1e			 
2e1e			.SCRATCH: 
2e1e				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2e1e 6f				db WORD_SYS_CORE+91             
2e1f 5c 2e			dw .INC            
2e21 08				db 7 + 1 
2e22 .. 00			db "SCRATCH",0              
2e2a				endm 
# End of macro CWHEAD
2e2a			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2e2a			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2e2a			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2e2a			; | |  
2e2a			; | | e.g.    : score $00 scratch ; 
2e2a			; | |  
2e2a			; | | $00 score ! 
2e2a			; | | $01 score +! 
2e2a			; | |  
2e2a			; | | e.g.   : varword $0a scratch ;  
2e2a			; | | 
2e2a			; | | $8000 varword ! 
2e2a					if DEBUG_FORTH_WORDS_KEY 
2e2a						DMARK "SCR" 
2e2a f5				push af  
2e2b 3a 3f 2e			ld a, (.dmark)  
2e2e 32 5e ee			ld (debug_mark),a  
2e31 3a 40 2e			ld a, (.dmark+1)  
2e34 32 5f ee			ld (debug_mark+1),a  
2e37 3a 41 2e			ld a, (.dmark+2)  
2e3a 32 60 ee			ld (debug_mark+2),a  
2e3d 18 03			jr .pastdmark  
2e3f ..			.dmark: db "SCR"  
2e42 f1			.pastdmark: pop af  
2e43			endm  
# End of macro DMARK
2e43						CALLMONITOR 
2e43 cd 6b ee			call debug_vector  
2e46				endm  
# End of macro CALLMONITOR
2e46					endif 
2e46			 
2e46					FORTH_DSP_VALUEHL 
2e46 cd d3 1c			call macro_dsp_valuehl 
2e49				endm 
# End of macro FORTH_DSP_VALUEHL
2e49				 
2e49					FORTH_DSP_POP 
2e49 cd 8b 1d			call macro_forth_dsp_pop 
2e4c				endm 
# End of macro FORTH_DSP_POP
2e4c			 
2e4c 7d					ld a, l 
2e4d 21 d9 e7				ld hl, os_var_array 
2e50 cd e6 0d				call addatohl 
2e53			 
2e53 cd d7 1a				call forth_push_numhl 
2e56			 
2e56				       NEXTW 
2e56 cd 68 ee			call parse_vector 
2e59 c3 ba 1e			jp macro_next 
2e5c				endm 
# End of macro NEXTW
2e5c			 
2e5c			.INC: 
2e5c				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2e5c 6f				db WORD_SYS_CORE+91             
2e5d b5 2e			dw .DEC            
2e5f 03				db 2 + 1 
2e60 .. 00			db "+!",0              
2e63				endm 
# End of macro CWHEAD
2e63			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2e63					if DEBUG_FORTH_WORDS_KEY 
2e63						DMARK "+s_" 
2e63 f5				push af  
2e64 3a 78 2e			ld a, (.dmark)  
2e67 32 5e ee			ld (debug_mark),a  
2e6a 3a 79 2e			ld a, (.dmark+1)  
2e6d 32 5f ee			ld (debug_mark+1),a  
2e70 3a 7a 2e			ld a, (.dmark+2)  
2e73 32 60 ee			ld (debug_mark+2),a  
2e76 18 03			jr .pastdmark  
2e78 ..			.dmark: db "+s_"  
2e7b f1			.pastdmark: pop af  
2e7c			endm  
# End of macro DMARK
2e7c						CALLMONITOR 
2e7c cd 6b ee			call debug_vector  
2e7f				endm  
# End of macro CALLMONITOR
2e7f					endif 
2e7f			 
2e7f					FORTH_DSP_VALUEHL 
2e7f cd d3 1c			call macro_dsp_valuehl 
2e82				endm 
# End of macro FORTH_DSP_VALUEHL
2e82			 
2e82 e5					push hl   ; save address 
2e83			 
2e83					FORTH_DSP_POP 
2e83 cd 8b 1d			call macro_forth_dsp_pop 
2e86				endm 
# End of macro FORTH_DSP_POP
2e86			 
2e86					FORTH_DSP_VALUEHL 
2e86 cd d3 1c			call macro_dsp_valuehl 
2e89				endm 
# End of macro FORTH_DSP_VALUEHL
2e89			 
2e89 e5					push hl 
2e8a					FORTH_DSP_POP 
2e8a cd 8b 1d			call macro_forth_dsp_pop 
2e8d				endm 
# End of macro FORTH_DSP_POP
2e8d e1					pop hl 
2e8e			 
2e8e					; hl contains value to add to byte at a 
2e8e				 
2e8e eb					ex de, hl 
2e8f			 
2e8f e1					pop hl 
2e90			 
2e90					if DEBUG_FORTH_WORDS 
2e90						DMARK "INC" 
2e90 f5				push af  
2e91 3a a5 2e			ld a, (.dmark)  
2e94 32 5e ee			ld (debug_mark),a  
2e97 3a a6 2e			ld a, (.dmark+1)  
2e9a 32 5f ee			ld (debug_mark+1),a  
2e9d 3a a7 2e			ld a, (.dmark+2)  
2ea0 32 60 ee			ld (debug_mark+2),a  
2ea3 18 03			jr .pastdmark  
2ea5 ..			.dmark: db "INC"  
2ea8 f1			.pastdmark: pop af  
2ea9			endm  
# End of macro DMARK
2ea9						CALLMONITOR 
2ea9 cd 6b ee			call debug_vector  
2eac				endm  
# End of macro CALLMONITOR
2eac					endif 
2eac			 
2eac 7e					ld a,(hl) 
2ead 83					add e 
2eae 77					ld (hl),a 
2eaf			 
2eaf			 
2eaf			 
2eaf				       NEXTW 
2eaf cd 68 ee			call parse_vector 
2eb2 c3 ba 1e			jp macro_next 
2eb5				endm 
# End of macro NEXTW
2eb5			 
2eb5			.DEC: 
2eb5				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2eb5 6f				db WORD_SYS_CORE+91             
2eb6 0c 2f			dw .INC2            
2eb8 03				db 2 + 1 
2eb9 .. 00			db "-!",0              
2ebc				endm 
# End of macro CWHEAD
2ebc			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2ebc					if DEBUG_FORTH_WORDS_KEY 
2ebc						DMARK "-s_" 
2ebc f5				push af  
2ebd 3a d1 2e			ld a, (.dmark)  
2ec0 32 5e ee			ld (debug_mark),a  
2ec3 3a d2 2e			ld a, (.dmark+1)  
2ec6 32 5f ee			ld (debug_mark+1),a  
2ec9 3a d3 2e			ld a, (.dmark+2)  
2ecc 32 60 ee			ld (debug_mark+2),a  
2ecf 18 03			jr .pastdmark  
2ed1 ..			.dmark: db "-s_"  
2ed4 f1			.pastdmark: pop af  
2ed5			endm  
# End of macro DMARK
2ed5						CALLMONITOR 
2ed5 cd 6b ee			call debug_vector  
2ed8				endm  
# End of macro CALLMONITOR
2ed8					endif 
2ed8			 
2ed8					FORTH_DSP_VALUEHL 
2ed8 cd d3 1c			call macro_dsp_valuehl 
2edb				endm 
# End of macro FORTH_DSP_VALUEHL
2edb			 
2edb e5					push hl   ; save address 
2edc			 
2edc					FORTH_DSP_POP 
2edc cd 8b 1d			call macro_forth_dsp_pop 
2edf				endm 
# End of macro FORTH_DSP_POP
2edf			 
2edf					FORTH_DSP_VALUEHL 
2edf cd d3 1c			call macro_dsp_valuehl 
2ee2				endm 
# End of macro FORTH_DSP_VALUEHL
2ee2			 
2ee2					; hl contains value to add to byte at a 
2ee2				 
2ee2 eb					ex de, hl 
2ee3			 
2ee3 e1					pop hl 
2ee4			 
2ee4					if DEBUG_FORTH_WORDS 
2ee4						DMARK "DEC" 
2ee4 f5				push af  
2ee5 3a f9 2e			ld a, (.dmark)  
2ee8 32 5e ee			ld (debug_mark),a  
2eeb 3a fa 2e			ld a, (.dmark+1)  
2eee 32 5f ee			ld (debug_mark+1),a  
2ef1 3a fb 2e			ld a, (.dmark+2)  
2ef4 32 60 ee			ld (debug_mark+2),a  
2ef7 18 03			jr .pastdmark  
2ef9 ..			.dmark: db "DEC"  
2efc f1			.pastdmark: pop af  
2efd			endm  
# End of macro DMARK
2efd						CALLMONITOR 
2efd cd 6b ee			call debug_vector  
2f00				endm  
# End of macro CALLMONITOR
2f00					endif 
2f00			 
2f00 7e					ld a,(hl) 
2f01 93					sub e 
2f02 77					ld (hl),a 
2f03			 
2f03			 
2f03					FORTH_DSP_POP 
2f03 cd 8b 1d			call macro_forth_dsp_pop 
2f06				endm 
# End of macro FORTH_DSP_POP
2f06			 
2f06				       NEXTW 
2f06 cd 68 ee			call parse_vector 
2f09 c3 ba 1e			jp macro_next 
2f0c				endm 
# End of macro NEXTW
2f0c			 
2f0c			.INC2: 
2f0c				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2f0c 6f				db WORD_SYS_CORE+91             
2f0d bc 2f			dw .DEC2            
2f0f 04				db 3 + 1 
2f10 .. 00			db "+2!",0              
2f14				endm 
# End of macro CWHEAD
2f14			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2f14			 
2f14					if DEBUG_FORTH_WORDS_KEY 
2f14						DMARK "+2s" 
2f14 f5				push af  
2f15 3a 29 2f			ld a, (.dmark)  
2f18 32 5e ee			ld (debug_mark),a  
2f1b 3a 2a 2f			ld a, (.dmark+1)  
2f1e 32 5f ee			ld (debug_mark+1),a  
2f21 3a 2b 2f			ld a, (.dmark+2)  
2f24 32 60 ee			ld (debug_mark+2),a  
2f27 18 03			jr .pastdmark  
2f29 ..			.dmark: db "+2s"  
2f2c f1			.pastdmark: pop af  
2f2d			endm  
# End of macro DMARK
2f2d						CALLMONITOR 
2f2d cd 6b ee			call debug_vector  
2f30				endm  
# End of macro CALLMONITOR
2f30					endif 
2f30			 
2f30					; Address 
2f30			 
2f30					FORTH_DSP_VALUEHL 
2f30 cd d3 1c			call macro_dsp_valuehl 
2f33				endm 
# End of macro FORTH_DSP_VALUEHL
2f33			 
2f33 e5					push hl    ; save address 
2f34			 
2f34					; load content into de 
2f34			 
2f34 5e					ld e,(hl) 
2f35 23					inc hl 
2f36 56					ld d, (hl) 
2f37			 
2f37					if DEBUG_FORTH_WORDS 
2f37						DMARK "+2a" 
2f37 f5				push af  
2f38 3a 4c 2f			ld a, (.dmark)  
2f3b 32 5e ee			ld (debug_mark),a  
2f3e 3a 4d 2f			ld a, (.dmark+1)  
2f41 32 5f ee			ld (debug_mark+1),a  
2f44 3a 4e 2f			ld a, (.dmark+2)  
2f47 32 60 ee			ld (debug_mark+2),a  
2f4a 18 03			jr .pastdmark  
2f4c ..			.dmark: db "+2a"  
2f4f f1			.pastdmark: pop af  
2f50			endm  
# End of macro DMARK
2f50						CALLMONITOR 
2f50 cd 6b ee			call debug_vector  
2f53				endm  
# End of macro CALLMONITOR
2f53					endif 
2f53			 
2f53					FORTH_DSP_POP 
2f53 cd 8b 1d			call macro_forth_dsp_pop 
2f56				endm 
# End of macro FORTH_DSP_POP
2f56			 
2f56					; Get value to add 
2f56			 
2f56					FORTH_DSP_VALUE 
2f56 cd bc 1c			call macro_forth_dsp_value 
2f59				endm 
# End of macro FORTH_DSP_VALUE
2f59			 
2f59					if DEBUG_FORTH_WORDS 
2f59						DMARK "+2v" 
2f59 f5				push af  
2f5a 3a 6e 2f			ld a, (.dmark)  
2f5d 32 5e ee			ld (debug_mark),a  
2f60 3a 6f 2f			ld a, (.dmark+1)  
2f63 32 5f ee			ld (debug_mark+1),a  
2f66 3a 70 2f			ld a, (.dmark+2)  
2f69 32 60 ee			ld (debug_mark+2),a  
2f6c 18 03			jr .pastdmark  
2f6e ..			.dmark: db "+2v"  
2f71 f1			.pastdmark: pop af  
2f72			endm  
# End of macro DMARK
2f72						CALLMONITOR 
2f72 cd 6b ee			call debug_vector  
2f75				endm  
# End of macro CALLMONITOR
2f75					endif 
2f75			 
2f75 19					add hl, de 
2f76			 
2f76					if DEBUG_FORTH_WORDS 
2f76						DMARK "+2+" 
2f76 f5				push af  
2f77 3a 8b 2f			ld a, (.dmark)  
2f7a 32 5e ee			ld (debug_mark),a  
2f7d 3a 8c 2f			ld a, (.dmark+1)  
2f80 32 5f ee			ld (debug_mark+1),a  
2f83 3a 8d 2f			ld a, (.dmark+2)  
2f86 32 60 ee			ld (debug_mark+2),a  
2f89 18 03			jr .pastdmark  
2f8b ..			.dmark: db "+2+"  
2f8e f1			.pastdmark: pop af  
2f8f			endm  
# End of macro DMARK
2f8f						CALLMONITOR 
2f8f cd 6b ee			call debug_vector  
2f92				endm  
# End of macro CALLMONITOR
2f92					endif 
2f92			 
2f92					; move result to de 
2f92			 
2f92 eb					ex de, hl 
2f93			 
2f93					; Address 
2f93			 
2f93 e1					pop hl 
2f94			 
2f94					; save it back 
2f94			 
2f94 73					ld (hl), e 
2f95 23					inc hl 
2f96 72					ld (hl), d 
2f97			 
2f97					if DEBUG_FORTH_WORDS 
2f97						DMARK "+2e" 
2f97 f5				push af  
2f98 3a ac 2f			ld a, (.dmark)  
2f9b 32 5e ee			ld (debug_mark),a  
2f9e 3a ad 2f			ld a, (.dmark+1)  
2fa1 32 5f ee			ld (debug_mark+1),a  
2fa4 3a ae 2f			ld a, (.dmark+2)  
2fa7 32 60 ee			ld (debug_mark+2),a  
2faa 18 03			jr .pastdmark  
2fac ..			.dmark: db "+2e"  
2faf f1			.pastdmark: pop af  
2fb0			endm  
# End of macro DMARK
2fb0						CALLMONITOR 
2fb0 cd 6b ee			call debug_vector  
2fb3				endm  
# End of macro CALLMONITOR
2fb3					endif 
2fb3			 
2fb3			 
2fb3			 
2fb3					FORTH_DSP_POP 
2fb3 cd 8b 1d			call macro_forth_dsp_pop 
2fb6				endm 
# End of macro FORTH_DSP_POP
2fb6			 
2fb6			 
2fb6				       NEXTW 
2fb6 cd 68 ee			call parse_vector 
2fb9 c3 ba 1e			jp macro_next 
2fbc				endm 
# End of macro NEXTW
2fbc			 
2fbc			.DEC2: 
2fbc				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2fbc 6f				db WORD_SYS_CORE+91             
2fbd 6e 30			dw .GET2            
2fbf 04				db 3 + 1 
2fc0 .. 00			db "-2!",0              
2fc4				endm 
# End of macro CWHEAD
2fc4			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2fc4			 
2fc4			 
2fc4					if DEBUG_FORTH_WORDS_KEY 
2fc4						DMARK "-2s" 
2fc4 f5				push af  
2fc5 3a d9 2f			ld a, (.dmark)  
2fc8 32 5e ee			ld (debug_mark),a  
2fcb 3a da 2f			ld a, (.dmark+1)  
2fce 32 5f ee			ld (debug_mark+1),a  
2fd1 3a db 2f			ld a, (.dmark+2)  
2fd4 32 60 ee			ld (debug_mark+2),a  
2fd7 18 03			jr .pastdmark  
2fd9 ..			.dmark: db "-2s"  
2fdc f1			.pastdmark: pop af  
2fdd			endm  
# End of macro DMARK
2fdd						CALLMONITOR 
2fdd cd 6b ee			call debug_vector  
2fe0				endm  
# End of macro CALLMONITOR
2fe0					endif 
2fe0			 
2fe0					; Address 
2fe0			 
2fe0					FORTH_DSP_VALUEHL 
2fe0 cd d3 1c			call macro_dsp_valuehl 
2fe3				endm 
# End of macro FORTH_DSP_VALUEHL
2fe3			 
2fe3 e5					push hl    ; save address 
2fe4			 
2fe4					; load content into de 
2fe4			 
2fe4 5e					ld e,(hl) 
2fe5 23					inc hl 
2fe6 56					ld d, (hl) 
2fe7			 
2fe7					if DEBUG_FORTH_WORDS 
2fe7						DMARK "-2a" 
2fe7 f5				push af  
2fe8 3a fc 2f			ld a, (.dmark)  
2feb 32 5e ee			ld (debug_mark),a  
2fee 3a fd 2f			ld a, (.dmark+1)  
2ff1 32 5f ee			ld (debug_mark+1),a  
2ff4 3a fe 2f			ld a, (.dmark+2)  
2ff7 32 60 ee			ld (debug_mark+2),a  
2ffa 18 03			jr .pastdmark  
2ffc ..			.dmark: db "-2a"  
2fff f1			.pastdmark: pop af  
3000			endm  
# End of macro DMARK
3000						CALLMONITOR 
3000 cd 6b ee			call debug_vector  
3003				endm  
# End of macro CALLMONITOR
3003					endif 
3003			 
3003					FORTH_DSP_POP 
3003 cd 8b 1d			call macro_forth_dsp_pop 
3006				endm 
# End of macro FORTH_DSP_POP
3006			 
3006					; Get value to remove 
3006			 
3006					FORTH_DSP_VALUE 
3006 cd bc 1c			call macro_forth_dsp_value 
3009				endm 
# End of macro FORTH_DSP_VALUE
3009			 
3009					if DEBUG_FORTH_WORDS 
3009						DMARK "-2v" 
3009 f5				push af  
300a 3a 1e 30			ld a, (.dmark)  
300d 32 5e ee			ld (debug_mark),a  
3010 3a 1f 30			ld a, (.dmark+1)  
3013 32 5f ee			ld (debug_mark+1),a  
3016 3a 20 30			ld a, (.dmark+2)  
3019 32 60 ee			ld (debug_mark+2),a  
301c 18 03			jr .pastdmark  
301e ..			.dmark: db "-2v"  
3021 f1			.pastdmark: pop af  
3022			endm  
# End of macro DMARK
3022						CALLMONITOR 
3022 cd 6b ee			call debug_vector  
3025				endm  
# End of macro CALLMONITOR
3025					endif 
3025			 
3025 eb					ex de, hl 
3026 ed 52				sbc hl, de 
3028			 
3028					if DEBUG_FORTH_WORDS 
3028						DMARK "-2d" 
3028 f5				push af  
3029 3a 3d 30			ld a, (.dmark)  
302c 32 5e ee			ld (debug_mark),a  
302f 3a 3e 30			ld a, (.dmark+1)  
3032 32 5f ee			ld (debug_mark+1),a  
3035 3a 3f 30			ld a, (.dmark+2)  
3038 32 60 ee			ld (debug_mark+2),a  
303b 18 03			jr .pastdmark  
303d ..			.dmark: db "-2d"  
3040 f1			.pastdmark: pop af  
3041			endm  
# End of macro DMARK
3041						CALLMONITOR 
3041 cd 6b ee			call debug_vector  
3044				endm  
# End of macro CALLMONITOR
3044					endif 
3044			 
3044					; move result to de 
3044			 
3044 eb					ex de, hl 
3045			 
3045					; Address 
3045			 
3045 e1					pop hl 
3046			 
3046					; save it back 
3046			 
3046 73					ld (hl), e 
3047 23					inc hl 
3048 72					ld (hl), d 
3049			 
3049					if DEBUG_FORTH_WORDS 
3049						DMARK "-2e" 
3049 f5				push af  
304a 3a 5e 30			ld a, (.dmark)  
304d 32 5e ee			ld (debug_mark),a  
3050 3a 5f 30			ld a, (.dmark+1)  
3053 32 5f ee			ld (debug_mark+1),a  
3056 3a 60 30			ld a, (.dmark+2)  
3059 32 60 ee			ld (debug_mark+2),a  
305c 18 03			jr .pastdmark  
305e ..			.dmark: db "-2e"  
3061 f1			.pastdmark: pop af  
3062			endm  
# End of macro DMARK
3062						CALLMONITOR 
3062 cd 6b ee			call debug_vector  
3065				endm  
# End of macro CALLMONITOR
3065					endif 
3065			 
3065			 
3065					FORTH_DSP_POP 
3065 cd 8b 1d			call macro_forth_dsp_pop 
3068				endm 
# End of macro FORTH_DSP_POP
3068			 
3068			 
3068			 
3068				       NEXTW 
3068 cd 68 ee			call parse_vector 
306b c3 ba 1e			jp macro_next 
306e				endm 
# End of macro NEXTW
306e			.GET2: 
306e				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
306e 6f				db WORD_SYS_CORE+91             
306f a6 30			dw .BANG2            
3071 03				db 2 + 1 
3072 .. 00			db "2@",0              
3075				endm 
# End of macro CWHEAD
3075			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
3075					if DEBUG_FORTH_WORDS_KEY 
3075						DMARK "2A_" 
3075 f5				push af  
3076 3a 8a 30			ld a, (.dmark)  
3079 32 5e ee			ld (debug_mark),a  
307c 3a 8b 30			ld a, (.dmark+1)  
307f 32 5f ee			ld (debug_mark+1),a  
3082 3a 8c 30			ld a, (.dmark+2)  
3085 32 60 ee			ld (debug_mark+2),a  
3088 18 03			jr .pastdmark  
308a ..			.dmark: db "2A_"  
308d f1			.pastdmark: pop af  
308e			endm  
# End of macro DMARK
308e						CALLMONITOR 
308e cd 6b ee			call debug_vector  
3091				endm  
# End of macro CALLMONITOR
3091					endif 
3091			 
3091					FORTH_DSP_VALUEHL 
3091 cd d3 1c			call macro_dsp_valuehl 
3094				endm 
# End of macro FORTH_DSP_VALUEHL
3094			 
3094 e5					push hl   ; save address 
3095			 
3095					FORTH_DSP_POP 
3095 cd 8b 1d			call macro_forth_dsp_pop 
3098				endm 
# End of macro FORTH_DSP_POP
3098			 
3098 e1					pop hl 
3099			 
3099 5e					ld e, (hl) 
309a 23					inc hl 
309b 56					ld d, (hl) 
309c			 
309c eb					ex de, hl 
309d			 
309d cd d7 1a				call forth_push_numhl 
30a0			 
30a0				       NEXTW 
30a0 cd 68 ee			call parse_vector 
30a3 c3 ba 1e			jp macro_next 
30a6				endm 
# End of macro NEXTW
30a6			.BANG2: 
30a6				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
30a6 6f				db WORD_SYS_CORE+91             
30a7 e1 30			dw .CONFIG            
30a9 03				db 2 + 1 
30aa .. 00			db "2!",0              
30ad				endm 
# End of macro CWHEAD
30ad			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
30ad					if DEBUG_FORTH_WORDS_KEY 
30ad						DMARK "2S_" 
30ad f5				push af  
30ae 3a c2 30			ld a, (.dmark)  
30b1 32 5e ee			ld (debug_mark),a  
30b4 3a c3 30			ld a, (.dmark+1)  
30b7 32 5f ee			ld (debug_mark+1),a  
30ba 3a c4 30			ld a, (.dmark+2)  
30bd 32 60 ee			ld (debug_mark+2),a  
30c0 18 03			jr .pastdmark  
30c2 ..			.dmark: db "2S_"  
30c5 f1			.pastdmark: pop af  
30c6			endm  
# End of macro DMARK
30c6						CALLMONITOR 
30c6 cd 6b ee			call debug_vector  
30c9				endm  
# End of macro CALLMONITOR
30c9					endif 
30c9			 
30c9					FORTH_DSP_VALUEHL 
30c9 cd d3 1c			call macro_dsp_valuehl 
30cc				endm 
# End of macro FORTH_DSP_VALUEHL
30cc			 
30cc e5					push hl   ; save address 
30cd			 
30cd			 
30cd					FORTH_DSP_POP 
30cd cd 8b 1d			call macro_forth_dsp_pop 
30d0				endm 
# End of macro FORTH_DSP_POP
30d0			 
30d0					 
30d0					FORTH_DSP_VALUEHL 
30d0 cd d3 1c			call macro_dsp_valuehl 
30d3				endm 
# End of macro FORTH_DSP_VALUEHL
30d3			 
30d3					FORTH_DSP_POP 
30d3 cd 8b 1d			call macro_forth_dsp_pop 
30d6				endm 
# End of macro FORTH_DSP_POP
30d6			 
30d6 eb					ex de, hl    ; value now in de 
30d7			 
30d7 e1					pop hl 
30d8			 
30d8 73					ld (hl), e 
30d9			 
30d9 23					inc hl 
30da			 
30da 72					ld (hl), d 
30db			 
30db			 
30db				       NEXTW 
30db cd 68 ee			call parse_vector 
30de c3 ba 1e			jp macro_next 
30e1				endm 
# End of macro NEXTW
30e1			.CONFIG: 
30e1				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
30e1 6f				db WORD_SYS_CORE+91             
30e2 f5 30			dw .ADTOS            
30e4 07				db 6 + 1 
30e5 .. 00			db "CONFIG",0              
30ec				endm 
# End of macro CWHEAD
30ec			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
30ec			 
30ec cd 4b 13				call config 
30ef					NEXTW 
30ef cd 68 ee			call parse_vector 
30f2 c3 ba 1e			jp macro_next 
30f5				endm 
# End of macro NEXTW
30f5			 
30f5			.ADTOS: 
30f5				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
30f5 6f				db WORD_SYS_CORE+91             
30f6 0e 31			dw .SBTOS            
30f8 03				db 2 + 1 
30f9 .. 00			db "1+",0              
30fc				endm 
# End of macro CWHEAD
30fc			; | 1+ ( u -- u )  Increment value on TOS | DONE 
30fc			 
30fc					FORTH_DSP_VALUEHL 
30fc cd d3 1c			call macro_dsp_valuehl 
30ff				endm 
# End of macro FORTH_DSP_VALUEHL
30ff e5					push hl 
3100			 
3100					FORTH_DSP_POP 
3100 cd 8b 1d			call macro_forth_dsp_pop 
3103				endm 
# End of macro FORTH_DSP_POP
3103 e1					pop hl 
3104			 
3104 23					inc hl 
3105 cd d7 1a				call forth_push_numhl 
3108					 
3108					NEXTW 
3108 cd 68 ee			call parse_vector 
310b c3 ba 1e			jp macro_next 
310e				endm 
# End of macro NEXTW
310e			.SBTOS: 
310e				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
310e 6f				db WORD_SYS_CORE+91             
310f 27 31			dw .ADSTORE            
3111 03				db 2 + 1 
3112 .. 00			db "1-",0              
3115				endm 
# End of macro CWHEAD
3115			; | 1- ( u -- u )  Decrement value on TOS | DONE 
3115			 
3115					FORTH_DSP_VALUEHL 
3115 cd d3 1c			call macro_dsp_valuehl 
3118				endm 
# End of macro FORTH_DSP_VALUEHL
3118 e5					push hl 
3119			 
3119					FORTH_DSP_POP 
3119 cd 8b 1d			call macro_forth_dsp_pop 
311c				endm 
# End of macro FORTH_DSP_POP
311c e1					pop hl 
311d			 
311d 2b					dec hl 
311e cd d7 1a				call forth_push_numhl 
3121					 
3121					NEXTW 
3121 cd 68 ee			call parse_vector 
3124 c3 ba 1e			jp macro_next 
3127				endm 
# End of macro NEXTW
3127			.ADSTORE: 
3127				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
3127 6f				db WORD_SYS_CORE+91             
3128 40 31			dw .ADWSTORE            
312a 04				db 3 + 1 
312b .. 00			db "1+!",0              
312f				endm 
# End of macro CWHEAD
312f			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
312f			 
312f					FORTH_DSP_VALUEHL 
312f cd d3 1c			call macro_dsp_valuehl 
3132				endm 
# End of macro FORTH_DSP_VALUEHL
3132 e5					push hl 
3133			 
3133					FORTH_DSP_POP 
3133 cd 8b 1d			call macro_forth_dsp_pop 
3136				endm 
# End of macro FORTH_DSP_POP
3136 e1					pop hl 
3137			 
3137 7e					ld a, (hl) 
3138 3c					inc a 
3139 77					ld (hl), a 
313a					 
313a					NEXTW 
313a cd 68 ee			call parse_vector 
313d c3 ba 1e			jp macro_next 
3140				endm 
# End of macro NEXTW
3140			.ADWSTORE: 
3140				CWHEAD .SBSTORE 91 "1+2!" 4 WORD_FLAG_CODE 
3140 6f				db WORD_SYS_CORE+91             
3141 61 31			dw .SBSTORE            
3143 05				db 4 + 1 
3144 .. 00			db "1+2!",0              
3149				endm 
# End of macro CWHEAD
3149			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
3149			 
3149					FORTH_DSP_VALUEHL 
3149 cd d3 1c			call macro_dsp_valuehl 
314c				endm 
# End of macro FORTH_DSP_VALUEHL
314c e5					push hl 
314d			 
314d					FORTH_DSP_POP 
314d cd 8b 1d			call macro_forth_dsp_pop 
3150				endm 
# End of macro FORTH_DSP_POP
3150 e1					pop hl 
3151			 
3151 e5					push hl 
3152			 
3152 cd 40 1e				call loadwordinhl 
3155 23					inc hl 
3156			 
3156 d1					pop de 
3157 eb					ex de, hl 
3158 73					ld (hl), e 
3159 23					inc hl 
315a 72					ld (hl), d 
315b					 
315b					NEXTW 
315b cd 68 ee			call parse_vector 
315e c3 ba 1e			jp macro_next 
3161				endm 
# End of macro NEXTW
3161			.SBSTORE: 
3161				CWHEAD .SBWSTORE 91 "1-!" 3 WORD_FLAG_CODE 
3161 6f				db WORD_SYS_CORE+91             
3162 7a 31			dw .SBWSTORE            
3164 04				db 3 + 1 
3165 .. 00			db "1-!",0              
3169				endm 
# End of macro CWHEAD
3169			; | 1-! ( addr -- )  Decrement byte at address addr | DONE 
3169			 
3169					FORTH_DSP_VALUEHL 
3169 cd d3 1c			call macro_dsp_valuehl 
316c				endm 
# End of macro FORTH_DSP_VALUEHL
316c e5					push hl 
316d			 
316d					FORTH_DSP_POP 
316d cd 8b 1d			call macro_forth_dsp_pop 
3170				endm 
# End of macro FORTH_DSP_POP
3170 e1					pop hl 
3171			 
3171 7e					ld a, (hl) 
3172 3d					dec a 
3173 77					ld (hl), a 
3174					 
3174					NEXTW 
3174 cd 68 ee			call parse_vector 
3177 c3 ba 1e			jp macro_next 
317a				endm 
# End of macro NEXTW
317a			.SBWSTORE: 
317a				CWHEAD .ENDCORE 91 "1-2!" 4 WORD_FLAG_CODE 
317a 6f				db WORD_SYS_CORE+91             
317b 9b 31			dw .ENDCORE            
317d 05				db 4 + 1 
317e .. 00			db "1-2!",0              
3183				endm 
# End of macro CWHEAD
3183			; | 1-2! ( addr -- )  Decrement word at address addr | DONE 
3183			 
3183					FORTH_DSP_VALUEHL 
3183 cd d3 1c			call macro_dsp_valuehl 
3186				endm 
# End of macro FORTH_DSP_VALUEHL
3186 e5					push hl 
3187			 
3187					FORTH_DSP_POP 
3187 cd 8b 1d			call macro_forth_dsp_pop 
318a				endm 
# End of macro FORTH_DSP_POP
318a e1					pop hl 
318b			 
318b e5					push hl 
318c			 
318c cd 40 1e				call loadwordinhl 
318f 2b					dec hl 
3190			 
3190 d1					pop de 
3191 eb					ex de, hl 
3192 73					ld (hl), e 
3193 23					inc hl 
3194 72					ld (hl), d 
3195					 
3195					NEXTW 
3195 cd 68 ee			call parse_vector 
3198 c3 ba 1e			jp macro_next 
319b				endm 
# End of macro NEXTW
319b			.ENDCORE: 
319b			 
319b			; eof 
319b			 
319b			 
# End of file forth_words_core.asm
319b			include "forth_words_flow.asm" 
319b			 
319b			; | ## Program Flow Words 
319b			 
319b			.IF: 
319b				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
319b 1e				db WORD_SYS_CORE+10             
319c 96 32			dw .THEN            
319e 03				db 2 + 1 
319f .. 00			db "IF",0              
31a2				endm 
# End of macro CWHEAD
31a2			; | IF ( w -- f ) If TOS is true exec code following up to THEN  | DONE 
31a2			; | | Note: currently not supporting ELSE or nested IF 
31a2			; 
31a2					if DEBUG_FORTH_WORDS_KEY 
31a2						DMARK "IF." 
31a2 f5				push af  
31a3 3a b7 31			ld a, (.dmark)  
31a6 32 5e ee			ld (debug_mark),a  
31a9 3a b8 31			ld a, (.dmark+1)  
31ac 32 5f ee			ld (debug_mark+1),a  
31af 3a b9 31			ld a, (.dmark+2)  
31b2 32 60 ee			ld (debug_mark+2),a  
31b5 18 03			jr .pastdmark  
31b7 ..			.dmark: db "IF."  
31ba f1			.pastdmark: pop af  
31bb			endm  
# End of macro DMARK
31bb						CALLMONITOR 
31bb cd 6b ee			call debug_vector  
31be				endm  
# End of macro CALLMONITOR
31be					endif 
31be			; eval TOS 
31be			 
31be				FORTH_DSP_VALUEHL 
31be cd d3 1c			call macro_dsp_valuehl 
31c1				endm 
# End of macro FORTH_DSP_VALUEHL
31c1			 
31c1			;	push hl 
31c1				FORTH_DSP_POP 
31c1 cd 8b 1d			call macro_forth_dsp_pop 
31c4				endm 
# End of macro FORTH_DSP_POP
31c4			;	pop hl 
31c4			 
31c4					if DEBUG_FORTH_WORDS 
31c4						DMARK "IF1" 
31c4 f5				push af  
31c5 3a d9 31			ld a, (.dmark)  
31c8 32 5e ee			ld (debug_mark),a  
31cb 3a da 31			ld a, (.dmark+1)  
31ce 32 5f ee			ld (debug_mark+1),a  
31d1 3a db 31			ld a, (.dmark+2)  
31d4 32 60 ee			ld (debug_mark+2),a  
31d7 18 03			jr .pastdmark  
31d9 ..			.dmark: db "IF1"  
31dc f1			.pastdmark: pop af  
31dd			endm  
# End of macro DMARK
31dd						CALLMONITOR 
31dd cd 6b ee			call debug_vector  
31e0				endm  
# End of macro CALLMONITOR
31e0					endif 
31e0 b7				or a        ; clear carry flag 
31e1 11 00 00			ld de, 0 
31e4 eb				ex de,hl 
31e5 ed 52			sbc hl, de 
31e7 c2 74 32			jp nz, .iftrue 
31ea			 
31ea					if DEBUG_FORTH_WORDS 
31ea						DMARK "IF2" 
31ea f5				push af  
31eb 3a ff 31			ld a, (.dmark)  
31ee 32 5e ee			ld (debug_mark),a  
31f1 3a 00 32			ld a, (.dmark+1)  
31f4 32 5f ee			ld (debug_mark+1),a  
31f7 3a 01 32			ld a, (.dmark+2)  
31fa 32 60 ee			ld (debug_mark+2),a  
31fd 18 03			jr .pastdmark  
31ff ..			.dmark: db "IF2"  
3202 f1			.pastdmark: pop af  
3203			endm  
# End of macro DMARK
3203						CALLMONITOR 
3203 cd 6b ee			call debug_vector  
3206				endm  
# End of macro CALLMONITOR
3206					endif 
3206			 
3206			; if not true then skip to THEN 
3206			 
3206				; TODO get tok_ptr 
3206				; TODO consume toks until we get to THEN 
3206			 
3206 2a b5 e5			ld hl, (os_tok_ptr) 
3209					if DEBUG_FORTH_WORDS 
3209						DMARK "IF3" 
3209 f5				push af  
320a 3a 1e 32			ld a, (.dmark)  
320d 32 5e ee			ld (debug_mark),a  
3210 3a 1f 32			ld a, (.dmark+1)  
3213 32 5f ee			ld (debug_mark+1),a  
3216 3a 20 32			ld a, (.dmark+2)  
3219 32 60 ee			ld (debug_mark+2),a  
321c 18 03			jr .pastdmark  
321e ..			.dmark: db "IF3"  
3221 f1			.pastdmark: pop af  
3222			endm  
# End of macro DMARK
3222						CALLMONITOR 
3222 cd 6b ee			call debug_vector  
3225				endm  
# End of macro CALLMONITOR
3225						 
3225					endif 
3225 11 6f 32			ld de, .ifthen 
3228					if DEBUG_FORTH_WORDS 
3228						DMARK "IF4" 
3228 f5				push af  
3229 3a 3d 32			ld a, (.dmark)  
322c 32 5e ee			ld (debug_mark),a  
322f 3a 3e 32			ld a, (.dmark+1)  
3232 32 5f ee			ld (debug_mark+1),a  
3235 3a 3f 32			ld a, (.dmark+2)  
3238 32 60 ee			ld (debug_mark+2),a  
323b 18 03			jr .pastdmark  
323d ..			.dmark: db "IF4"  
3240 f1			.pastdmark: pop af  
3241			endm  
# End of macro DMARK
3241						CALLMONITOR 
3241 cd 6b ee			call debug_vector  
3244				endm  
# End of macro CALLMONITOR
3244					endif 
3244 cd b7 1f			call findnexttok  
3247			 
3247					if DEBUG_FORTH_WORDS 
3247						DMARK "IF5" 
3247 f5				push af  
3248 3a 5c 32			ld a, (.dmark)  
324b 32 5e ee			ld (debug_mark),a  
324e 3a 5d 32			ld a, (.dmark+1)  
3251 32 5f ee			ld (debug_mark+1),a  
3254 3a 5e 32			ld a, (.dmark+2)  
3257 32 60 ee			ld (debug_mark+2),a  
325a 18 03			jr .pastdmark  
325c ..			.dmark: db "IF5"  
325f f1			.pastdmark: pop af  
3260			endm  
# End of macro DMARK
3260						CALLMONITOR 
3260 cd 6b ee			call debug_vector  
3263				endm  
# End of macro CALLMONITOR
3263					endif 
3263				; TODO replace below with ; exec using tok_ptr 
3263 22 b5 e5			ld (os_tok_ptr), hl 
3266 c3 3b 1f			jp exec1 
3269				NEXTW 
3269 cd 68 ee			call parse_vector 
326c c3 ba 1e			jp macro_next 
326f				endm 
# End of macro NEXTW
326f			 
326f .. 00		.ifthen:  db "THEN",0 
3274			 
3274			.iftrue:		 
3274				; Exec next words normally 
3274			 
3274				; if true then exec following IF as normal 
3274					if DEBUG_FORTH_WORDS 
3274						DMARK "IFT" 
3274 f5				push af  
3275 3a 89 32			ld a, (.dmark)  
3278 32 5e ee			ld (debug_mark),a  
327b 3a 8a 32			ld a, (.dmark+1)  
327e 32 5f ee			ld (debug_mark+1),a  
3281 3a 8b 32			ld a, (.dmark+2)  
3284 32 60 ee			ld (debug_mark+2),a  
3287 18 03			jr .pastdmark  
3289 ..			.dmark: db "IFT"  
328c f1			.pastdmark: pop af  
328d			endm  
# End of macro DMARK
328d						CALLMONITOR 
328d cd 6b ee			call debug_vector  
3290				endm  
# End of macro CALLMONITOR
3290					endif 
3290			 
3290					NEXTW 
3290 cd 68 ee			call parse_vector 
3293 c3 ba 1e			jp macro_next 
3296				endm 
# End of macro NEXTW
3296			.THEN: 
3296				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
3296 1f				db WORD_SYS_CORE+11             
3297 c1 32			dw .ELSE            
3299 05				db 4 + 1 
329a .. 00			db "THEN",0              
329f				endm 
# End of macro CWHEAD
329f			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
329f					if DEBUG_FORTH_WORDS_KEY 
329f						DMARK "THN" 
329f f5				push af  
32a0 3a b4 32			ld a, (.dmark)  
32a3 32 5e ee			ld (debug_mark),a  
32a6 3a b5 32			ld a, (.dmark+1)  
32a9 32 5f ee			ld (debug_mark+1),a  
32ac 3a b6 32			ld a, (.dmark+2)  
32af 32 60 ee			ld (debug_mark+2),a  
32b2 18 03			jr .pastdmark  
32b4 ..			.dmark: db "THN"  
32b7 f1			.pastdmark: pop af  
32b8			endm  
# End of macro DMARK
32b8						CALLMONITOR 
32b8 cd 6b ee			call debug_vector  
32bb				endm  
# End of macro CALLMONITOR
32bb					endif 
32bb					NEXTW 
32bb cd 68 ee			call parse_vector 
32be c3 ba 1e			jp macro_next 
32c1				endm 
# End of macro NEXTW
32c1			.ELSE: 
32c1				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
32c1 20				db WORD_SYS_CORE+12             
32c2 ec 32			dw .DO            
32c4 03				db 2 + 1 
32c5 .. 00			db "ELSE",0              
32ca				endm 
# End of macro CWHEAD
32ca			; | ELSE ( -- ) Not supported - does nothing | TODO 
32ca			 
32ca					if DEBUG_FORTH_WORDS_KEY 
32ca						DMARK "ELS" 
32ca f5				push af  
32cb 3a df 32			ld a, (.dmark)  
32ce 32 5e ee			ld (debug_mark),a  
32d1 3a e0 32			ld a, (.dmark+1)  
32d4 32 5f ee			ld (debug_mark+1),a  
32d7 3a e1 32			ld a, (.dmark+2)  
32da 32 60 ee			ld (debug_mark+2),a  
32dd 18 03			jr .pastdmark  
32df ..			.dmark: db "ELS"  
32e2 f1			.pastdmark: pop af  
32e3			endm  
# End of macro DMARK
32e3						CALLMONITOR 
32e3 cd 6b ee			call debug_vector  
32e6				endm  
# End of macro CALLMONITOR
32e6					endif 
32e6			 
32e6			 
32e6					NEXTW 
32e6 cd 68 ee			call parse_vector 
32e9 c3 ba 1e			jp macro_next 
32ec				endm 
# End of macro NEXTW
32ec			.DO: 
32ec				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
32ec 21				db WORD_SYS_CORE+13             
32ed 16 34			dw .LOOP            
32ef 03				db 2 + 1 
32f0 .. 00			db "DO",0              
32f3				endm 
# End of macro CWHEAD
32f3			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
32f3			 
32f3					if DEBUG_FORTH_WORDS_KEY 
32f3						DMARK "DO." 
32f3 f5				push af  
32f4 3a 08 33			ld a, (.dmark)  
32f7 32 5e ee			ld (debug_mark),a  
32fa 3a 09 33			ld a, (.dmark+1)  
32fd 32 5f ee			ld (debug_mark+1),a  
3300 3a 0a 33			ld a, (.dmark+2)  
3303 32 60 ee			ld (debug_mark+2),a  
3306 18 03			jr .pastdmark  
3308 ..			.dmark: db "DO."  
330b f1			.pastdmark: pop af  
330c			endm  
# End of macro DMARK
330c						CALLMONITOR 
330c cd 6b ee			call debug_vector  
330f				endm  
# End of macro CALLMONITOR
330f					endif 
330f			;  push pc to rsp stack past the DO 
330f			 
330f 2a b5 e5				ld hl, (os_tok_ptr) 
3312 23					inc hl   ; D 
3313 23					inc hl  ; O 
3314 23					inc hl   ; null 
3315					if DEBUG_FORTH_WORDS 
3315						DMARK "DO2" 
3315 f5				push af  
3316 3a 2a 33			ld a, (.dmark)  
3319 32 5e ee			ld (debug_mark),a  
331c 3a 2b 33			ld a, (.dmark+1)  
331f 32 5f ee			ld (debug_mark+1),a  
3322 3a 2c 33			ld a, (.dmark+2)  
3325 32 60 ee			ld (debug_mark+2),a  
3328 18 03			jr .pastdmark  
332a ..			.dmark: db "DO2"  
332d f1			.pastdmark: pop af  
332e			endm  
# End of macro DMARK
332e						CALLMONITOR 
332e cd 6b ee			call debug_vector  
3331				endm  
# End of macro CALLMONITOR
3331					endif 
3331					FORTH_RSP_NEXT 
3331 cd 7e 1a			call macro_forth_rsp_next 
3334				endm 
# End of macro FORTH_RSP_NEXT
3334					if DEBUG_FORTH_WORDS 
3334						DMARK "DO3" 
3334 f5				push af  
3335 3a 49 33			ld a, (.dmark)  
3338 32 5e ee			ld (debug_mark),a  
333b 3a 4a 33			ld a, (.dmark+1)  
333e 32 5f ee			ld (debug_mark+1),a  
3341 3a 4b 33			ld a, (.dmark+2)  
3344 32 60 ee			ld (debug_mark+2),a  
3347 18 03			jr .pastdmark  
3349 ..			.dmark: db "DO3"  
334c f1			.pastdmark: pop af  
334d			endm  
# End of macro DMARK
334d						CALLMONITOR 
334d cd 6b ee			call debug_vector  
3350				endm  
# End of macro CALLMONITOR
3350					endif 
3350			 
3350					;if DEBUG_FORTH_WORDS 
3350				;		push hl 
3350			;		endif  
3350			 
3350			; get counters from data stack 
3350			 
3350			 
3350					FORTH_DSP_VALUEHL 
3350 cd d3 1c			call macro_dsp_valuehl 
3353				endm 
# End of macro FORTH_DSP_VALUEHL
3353 e5					push hl		 ; hl now has starting counter which needs to be tos 
3354			 
3354					if DEBUG_FORTH_WORDS 
3354						DMARK "DO4" 
3354 f5				push af  
3355 3a 69 33			ld a, (.dmark)  
3358 32 5e ee			ld (debug_mark),a  
335b 3a 6a 33			ld a, (.dmark+1)  
335e 32 5f ee			ld (debug_mark+1),a  
3361 3a 6b 33			ld a, (.dmark+2)  
3364 32 60 ee			ld (debug_mark+2),a  
3367 18 03			jr .pastdmark  
3369 ..			.dmark: db "DO4"  
336c f1			.pastdmark: pop af  
336d			endm  
# End of macro DMARK
336d						CALLMONITOR 
336d cd 6b ee			call debug_vector  
3370				endm  
# End of macro CALLMONITOR
3370					endif 
3370					FORTH_DSP_POP 
3370 cd 8b 1d			call macro_forth_dsp_pop 
3373				endm 
# End of macro FORTH_DSP_POP
3373			 
3373					if DEBUG_FORTH_WORDS 
3373						DMARK "DO5" 
3373 f5				push af  
3374 3a 88 33			ld a, (.dmark)  
3377 32 5e ee			ld (debug_mark),a  
337a 3a 89 33			ld a, (.dmark+1)  
337d 32 5f ee			ld (debug_mark+1),a  
3380 3a 8a 33			ld a, (.dmark+2)  
3383 32 60 ee			ld (debug_mark+2),a  
3386 18 03			jr .pastdmark  
3388 ..			.dmark: db "DO5"  
338b f1			.pastdmark: pop af  
338c			endm  
# End of macro DMARK
338c						CALLMONITOR 
338c cd 6b ee			call debug_vector  
338f				endm  
# End of macro CALLMONITOR
338f					endif 
338f			 
338f					FORTH_DSP_VALUEHL 
338f cd d3 1c			call macro_dsp_valuehl 
3392				endm 
# End of macro FORTH_DSP_VALUEHL
3392			;		push hl		 ; hl now has starting limit counter 
3392			 
3392					if DEBUG_FORTH_WORDS 
3392						DMARK "DO6" 
3392 f5				push af  
3393 3a a7 33			ld a, (.dmark)  
3396 32 5e ee			ld (debug_mark),a  
3399 3a a8 33			ld a, (.dmark+1)  
339c 32 5f ee			ld (debug_mark+1),a  
339f 3a a9 33			ld a, (.dmark+2)  
33a2 32 60 ee			ld (debug_mark+2),a  
33a5 18 03			jr .pastdmark  
33a7 ..			.dmark: db "DO6"  
33aa f1			.pastdmark: pop af  
33ab			endm  
# End of macro DMARK
33ab						CALLMONITOR 
33ab cd 6b ee			call debug_vector  
33ae				endm  
# End of macro CALLMONITOR
33ae					endif 
33ae					FORTH_DSP_POP 
33ae cd 8b 1d			call macro_forth_dsp_pop 
33b1				endm 
# End of macro FORTH_DSP_POP
33b1			 
33b1			; put counters on the loop stack 
33b1			 
33b1			;		pop hl			 ; limit counter 
33b1 d1					pop de			; start counter 
33b2			 
33b2					; push limit counter 
33b2			 
33b2					if DEBUG_FORTH_WORDS 
33b2						DMARK "DO7" 
33b2 f5				push af  
33b3 3a c7 33			ld a, (.dmark)  
33b6 32 5e ee			ld (debug_mark),a  
33b9 3a c8 33			ld a, (.dmark+1)  
33bc 32 5f ee			ld (debug_mark+1),a  
33bf 3a c9 33			ld a, (.dmark+2)  
33c2 32 60 ee			ld (debug_mark+2),a  
33c5 18 03			jr .pastdmark  
33c7 ..			.dmark: db "DO7"  
33ca f1			.pastdmark: pop af  
33cb			endm  
# End of macro DMARK
33cb						CALLMONITOR 
33cb cd 6b ee			call debug_vector  
33ce				endm  
# End of macro CALLMONITOR
33ce					endif 
33ce					FORTH_LOOP_NEXT 
33ce cd 04 1d			call macro_forth_loop_next 
33d1				endm 
# End of macro FORTH_LOOP_NEXT
33d1			 
33d1					; push start counter 
33d1			 
33d1 eb					ex de, hl 
33d2					if DEBUG_FORTH_WORDS 
33d2						DMARK "DO7" 
33d2 f5				push af  
33d3 3a e7 33			ld a, (.dmark)  
33d6 32 5e ee			ld (debug_mark),a  
33d9 3a e8 33			ld a, (.dmark+1)  
33dc 32 5f ee			ld (debug_mark+1),a  
33df 3a e9 33			ld a, (.dmark+2)  
33e2 32 60 ee			ld (debug_mark+2),a  
33e5 18 03			jr .pastdmark  
33e7 ..			.dmark: db "DO7"  
33ea f1			.pastdmark: pop af  
33eb			endm  
# End of macro DMARK
33eb						CALLMONITOR 
33eb cd 6b ee			call debug_vector  
33ee				endm  
# End of macro CALLMONITOR
33ee					endif 
33ee					FORTH_LOOP_NEXT 
33ee cd 04 1d			call macro_forth_loop_next 
33f1				endm 
# End of macro FORTH_LOOP_NEXT
33f1			 
33f1			 
33f1					; init first round of I counter 
33f1			 
33f1 22 d9 e5				ld (os_current_i), hl 
33f4			 
33f4					if DEBUG_FORTH_WORDS 
33f4						DMARK "DO8" 
33f4 f5				push af  
33f5 3a 09 34			ld a, (.dmark)  
33f8 32 5e ee			ld (debug_mark),a  
33fb 3a 0a 34			ld a, (.dmark+1)  
33fe 32 5f ee			ld (debug_mark+1),a  
3401 3a 0b 34			ld a, (.dmark+2)  
3404 32 60 ee			ld (debug_mark+2),a  
3407 18 03			jr .pastdmark  
3409 ..			.dmark: db "DO8"  
340c f1			.pastdmark: pop af  
340d			endm  
# End of macro DMARK
340d						CALLMONITOR 
340d cd 6b ee			call debug_vector  
3410				endm  
# End of macro CALLMONITOR
3410					endif 
3410			 
3410					NEXTW 
3410 cd 68 ee			call parse_vector 
3413 c3 ba 1e			jp macro_next 
3416				endm 
# End of macro NEXTW
3416			.LOOP: 
3416				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
3416 22				db WORD_SYS_CORE+14             
3417 34 35			dw .I            
3419 05				db 4 + 1 
341a .. 00			db "LOOP",0              
341f				endm 
# End of macro CWHEAD
341f			; | LOOP ( -- ) Increment and test loop counter  | DONE 
341f			 
341f				; pop tos as current loop count to hl 
341f			 
341f				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
341f			 
341f				FORTH_LOOP_TOS 
341f cd 37 1d			call macro_forth_loop_tos 
3422				endm 
# End of macro FORTH_LOOP_TOS
3422 e5				push hl 
3423			 
3423					if DEBUG_FORTH_WORDS_KEY 
3423						DMARK "LOP" 
3423 f5				push af  
3424 3a 38 34			ld a, (.dmark)  
3427 32 5e ee			ld (debug_mark),a  
342a 3a 39 34			ld a, (.dmark+1)  
342d 32 5f ee			ld (debug_mark+1),a  
3430 3a 3a 34			ld a, (.dmark+2)  
3433 32 60 ee			ld (debug_mark+2),a  
3436 18 03			jr .pastdmark  
3438 ..			.dmark: db "LOP"  
343b f1			.pastdmark: pop af  
343c			endm  
# End of macro DMARK
343c						CALLMONITOR 
343c cd 6b ee			call debug_vector  
343f				endm  
# End of macro CALLMONITOR
343f					endif 
343f				; next item on the stack is the limit. get it 
343f			 
343f			 
343f				FORTH_LOOP_POP 
343f cd 41 1d			call macro_forth_loop_pop 
3442				endm 
# End of macro FORTH_LOOP_POP
3442			 
3442				FORTH_LOOP_TOS 
3442 cd 37 1d			call macro_forth_loop_tos 
3445				endm 
# End of macro FORTH_LOOP_TOS
3445			 
3445 d1				pop de		 ; de = i, hl = limit 
3446			 
3446					if DEBUG_FORTH_WORDS 
3446						DMARK "LP1" 
3446 f5				push af  
3447 3a 5b 34			ld a, (.dmark)  
344a 32 5e ee			ld (debug_mark),a  
344d 3a 5c 34			ld a, (.dmark+1)  
3450 32 5f ee			ld (debug_mark+1),a  
3453 3a 5d 34			ld a, (.dmark+2)  
3456 32 60 ee			ld (debug_mark+2),a  
3459 18 03			jr .pastdmark  
345b ..			.dmark: db "LP1"  
345e f1			.pastdmark: pop af  
345f			endm  
# End of macro DMARK
345f						CALLMONITOR 
345f cd 6b ee			call debug_vector  
3462				endm  
# End of macro CALLMONITOR
3462					endif 
3462			 
3462				; go back to previous word 
3462			 
3462 d5				push de    ; save I for inc later 
3463			 
3463			 
3463				; get limit 
3463				;  is I at limit? 
3463			 
3463			 
3463					if DEBUG_FORTH_WORDS 
3463						DMARK "LP1" 
3463 f5				push af  
3464 3a 78 34			ld a, (.dmark)  
3467 32 5e ee			ld (debug_mark),a  
346a 3a 79 34			ld a, (.dmark+1)  
346d 32 5f ee			ld (debug_mark+1),a  
3470 3a 7a 34			ld a, (.dmark+2)  
3473 32 60 ee			ld (debug_mark+2),a  
3476 18 03			jr .pastdmark  
3478 ..			.dmark: db "LP1"  
347b f1			.pastdmark: pop af  
347c			endm  
# End of macro DMARK
347c						CALLMONITOR 
347c cd 6b ee			call debug_vector  
347f				endm  
# End of macro CALLMONITOR
347f					endif 
347f			 
347f ed 52			sbc hl, de 
3481			 
3481			 
3481				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3481			 
3481 20 29				jr nz, .loopnotdone 
3483			 
3483 e1				pop hl   ; get rid of saved I 
3484				FORTH_LOOP_POP     ; get rid of limit 
3484 cd 41 1d			call macro_forth_loop_pop 
3487				endm 
# End of macro FORTH_LOOP_POP
3487			 
3487				FORTH_RSP_POP     ; get rid of DO ptr 
3487 cd 9f 1a			call macro_forth_rsp_pop 
348a				endm 
# End of macro FORTH_RSP_POP
348a			 
348a			if DEBUG_FORTH_WORDS 
348a						DMARK "LP>" 
348a f5				push af  
348b 3a 9f 34			ld a, (.dmark)  
348e 32 5e ee			ld (debug_mark),a  
3491 3a a0 34			ld a, (.dmark+1)  
3494 32 5f ee			ld (debug_mark+1),a  
3497 3a a1 34			ld a, (.dmark+2)  
349a 32 60 ee			ld (debug_mark+2),a  
349d 18 03			jr .pastdmark  
349f ..			.dmark: db "LP>"  
34a2 f1			.pastdmark: pop af  
34a3			endm  
# End of macro DMARK
34a3				CALLMONITOR 
34a3 cd 6b ee			call debug_vector  
34a6				endm  
# End of macro CALLMONITOR
34a6			endif 
34a6			 
34a6					NEXTW 
34a6 cd 68 ee			call parse_vector 
34a9 c3 ba 1e			jp macro_next 
34ac				endm 
# End of macro NEXTW
34ac				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
34ac			 
34ac			.loopnotdone: 
34ac			 
34ac e1				pop hl    ; get I 
34ad 23				inc hl 
34ae			 
34ae			   	; save new I 
34ae			 
34ae			 
34ae					; set I counter 
34ae			 
34ae 22 d9 e5				ld (os_current_i), hl 
34b1			 
34b1					if DEBUG_FORTH_WORDS 
34b1						DMARK "LPN" 
34b1 f5				push af  
34b2 3a c6 34			ld a, (.dmark)  
34b5 32 5e ee			ld (debug_mark),a  
34b8 3a c7 34			ld a, (.dmark+1)  
34bb 32 5f ee			ld (debug_mark+1),a  
34be 3a c8 34			ld a, (.dmark+2)  
34c1 32 60 ee			ld (debug_mark+2),a  
34c4 18 03			jr .pastdmark  
34c6 ..			.dmark: db "LPN"  
34c9 f1			.pastdmark: pop af  
34ca			endm  
# End of macro DMARK
34ca					CALLMONITOR 
34ca cd 6b ee			call debug_vector  
34cd				endm  
# End of macro CALLMONITOR
34cd					endif 
34cd					 
34cd				FORTH_LOOP_NEXT 
34cd cd 04 1d			call macro_forth_loop_next 
34d0				endm 
# End of macro FORTH_LOOP_NEXT
34d0			 
34d0			 
34d0					if DEBUG_FORTH_WORDS 
34d0 eb						ex de,hl 
34d1					endif 
34d1			 
34d1			;	; get DO ptr 
34d1			; 
34d1					if DEBUG_FORTH_WORDS 
34d1						DMARK "LP7" 
34d1 f5				push af  
34d2 3a e6 34			ld a, (.dmark)  
34d5 32 5e ee			ld (debug_mark),a  
34d8 3a e7 34			ld a, (.dmark+1)  
34db 32 5f ee			ld (debug_mark+1),a  
34de 3a e8 34			ld a, (.dmark+2)  
34e1 32 60 ee			ld (debug_mark+2),a  
34e4 18 03			jr .pastdmark  
34e6 ..			.dmark: db "LP7"  
34e9 f1			.pastdmark: pop af  
34ea			endm  
# End of macro DMARK
34ea					CALLMONITOR 
34ea cd 6b ee			call debug_vector  
34ed				endm  
# End of macro CALLMONITOR
34ed					endif 
34ed				FORTH_RSP_TOS 
34ed cd 95 1a			call macro_forth_rsp_tos 
34f0				endm 
# End of macro FORTH_RSP_TOS
34f0			 
34f0					if DEBUG_FORTH_WORDS 
34f0						DMARK "LP8" 
34f0 f5				push af  
34f1 3a 05 35			ld a, (.dmark)  
34f4 32 5e ee			ld (debug_mark),a  
34f7 3a 06 35			ld a, (.dmark+1)  
34fa 32 5f ee			ld (debug_mark+1),a  
34fd 3a 07 35			ld a, (.dmark+2)  
3500 32 60 ee			ld (debug_mark+2),a  
3503 18 03			jr .pastdmark  
3505 ..			.dmark: db "LP8"  
3508 f1			.pastdmark: pop af  
3509			endm  
# End of macro DMARK
3509					CALLMONITOR 
3509 cd 6b ee			call debug_vector  
350c				endm  
# End of macro CALLMONITOR
350c					endif 
350c				;push hl 
350c			 
350c				; not going to DO any more 
350c				; get rid of the RSP pointer as DO will add it back in 
350c				;FORTH_RSP_POP 
350c				;pop hl 
350c			 
350c				;ld hl,(cli_ret_sp) 
350c				;ld e, (hl) 
350c				;inc hl 
350c				;ld d, (hl) 
350c				;ex de,hl 
350c 22 b5 e5			ld (os_tok_ptr), hl 
350f					if DEBUG_FORTH_WORDS 
350f						DMARK "LP<" 
350f f5				push af  
3510 3a 24 35			ld a, (.dmark)  
3513 32 5e ee			ld (debug_mark),a  
3516 3a 25 35			ld a, (.dmark+1)  
3519 32 5f ee			ld (debug_mark+1),a  
351c 3a 26 35			ld a, (.dmark+2)  
351f 32 60 ee			ld (debug_mark+2),a  
3522 18 03			jr .pastdmark  
3524 ..			.dmark: db "LP<"  
3527 f1			.pastdmark: pop af  
3528			endm  
# End of macro DMARK
3528					CALLMONITOR 
3528 cd 6b ee			call debug_vector  
352b				endm  
# End of macro CALLMONITOR
352b				endif 
352b c3 3b 1f			jp exec1 
352e			 
352e					 
352e			 
352e			 
352e					NEXTW 
352e cd 68 ee			call parse_vector 
3531 c3 ba 1e			jp macro_next 
3534				endm 
# End of macro NEXTW
3534			.I:  
3534			 
3534				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
3534 5e				db WORD_SYS_CORE+74             
3535 62 35			dw .DLOOP            
3537 02				db 1 + 1 
3538 .. 00			db "I",0              
353a				endm 
# End of macro CWHEAD
353a			; | I ( -- ) Current loop counter | DONE 
353a					if DEBUG_FORTH_WORDS_KEY 
353a						DMARK "I.." 
353a f5				push af  
353b 3a 4f 35			ld a, (.dmark)  
353e 32 5e ee			ld (debug_mark),a  
3541 3a 50 35			ld a, (.dmark+1)  
3544 32 5f ee			ld (debug_mark+1),a  
3547 3a 51 35			ld a, (.dmark+2)  
354a 32 60 ee			ld (debug_mark+2),a  
354d 18 03			jr .pastdmark  
354f ..			.dmark: db "I.."  
3552 f1			.pastdmark: pop af  
3553			endm  
# End of macro DMARK
3553						CALLMONITOR 
3553 cd 6b ee			call debug_vector  
3556				endm  
# End of macro CALLMONITOR
3556					endif 
3556			 
3556 2a d9 e5				ld hl,(os_current_i) 
3559 cd d7 1a				call forth_push_numhl 
355c			 
355c					NEXTW 
355c cd 68 ee			call parse_vector 
355f c3 ba 1e			jp macro_next 
3562				endm 
# End of macro NEXTW
3562			.DLOOP: 
3562				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
3562 5f				db WORD_SYS_CORE+75             
3563 49 36			dw .REPEAT            
3565 06				db 5 + 1 
3566 .. 00			db "-LOOP",0              
356c				endm 
# End of macro CWHEAD
356c			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
356c				; pop tos as current loop count to hl 
356c					if DEBUG_FORTH_WORDS_KEY 
356c						DMARK "-LP" 
356c f5				push af  
356d 3a 81 35			ld a, (.dmark)  
3570 32 5e ee			ld (debug_mark),a  
3573 3a 82 35			ld a, (.dmark+1)  
3576 32 5f ee			ld (debug_mark+1),a  
3579 3a 83 35			ld a, (.dmark+2)  
357c 32 60 ee			ld (debug_mark+2),a  
357f 18 03			jr .pastdmark  
3581 ..			.dmark: db "-LP"  
3584 f1			.pastdmark: pop af  
3585			endm  
# End of macro DMARK
3585						CALLMONITOR 
3585 cd 6b ee			call debug_vector  
3588				endm  
# End of macro CALLMONITOR
3588					endif 
3588			 
3588				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3588			 
3588				FORTH_LOOP_TOS 
3588 cd 37 1d			call macro_forth_loop_tos 
358b				endm 
# End of macro FORTH_LOOP_TOS
358b e5				push hl 
358c			 
358c					if DEBUG_FORTH_WORDS 
358c						DMARK "-LP" 
358c f5				push af  
358d 3a a1 35			ld a, (.dmark)  
3590 32 5e ee			ld (debug_mark),a  
3593 3a a2 35			ld a, (.dmark+1)  
3596 32 5f ee			ld (debug_mark+1),a  
3599 3a a3 35			ld a, (.dmark+2)  
359c 32 60 ee			ld (debug_mark+2),a  
359f 18 03			jr .pastdmark  
35a1 ..			.dmark: db "-LP"  
35a4 f1			.pastdmark: pop af  
35a5			endm  
# End of macro DMARK
35a5						CALLMONITOR 
35a5 cd 6b ee			call debug_vector  
35a8				endm  
# End of macro CALLMONITOR
35a8					endif 
35a8				; next item on the stack is the limit. get it 
35a8			 
35a8			 
35a8				FORTH_LOOP_POP 
35a8 cd 41 1d			call macro_forth_loop_pop 
35ab				endm 
# End of macro FORTH_LOOP_POP
35ab			 
35ab				FORTH_LOOP_TOS 
35ab cd 37 1d			call macro_forth_loop_tos 
35ae				endm 
# End of macro FORTH_LOOP_TOS
35ae			 
35ae d1				pop de		 ; de = i, hl = limit 
35af			 
35af					if DEBUG_FORTH_WORDS 
35af						DMARK "-L1" 
35af f5				push af  
35b0 3a c4 35			ld a, (.dmark)  
35b3 32 5e ee			ld (debug_mark),a  
35b6 3a c5 35			ld a, (.dmark+1)  
35b9 32 5f ee			ld (debug_mark+1),a  
35bc 3a c6 35			ld a, (.dmark+2)  
35bf 32 60 ee			ld (debug_mark+2),a  
35c2 18 03			jr .pastdmark  
35c4 ..			.dmark: db "-L1"  
35c7 f1			.pastdmark: pop af  
35c8			endm  
# End of macro DMARK
35c8						CALLMONITOR 
35c8 cd 6b ee			call debug_vector  
35cb				endm  
# End of macro CALLMONITOR
35cb					endif 
35cb			 
35cb				; go back to previous word 
35cb			 
35cb d5				push de    ; save I for inc later 
35cc			 
35cc			 
35cc				; get limit 
35cc				;  is I at limit? 
35cc			 
35cc			 
35cc					if DEBUG_FORTH_WORDS 
35cc						DMARK "-L1" 
35cc f5				push af  
35cd 3a e1 35			ld a, (.dmark)  
35d0 32 5e ee			ld (debug_mark),a  
35d3 3a e2 35			ld a, (.dmark+1)  
35d6 32 5f ee			ld (debug_mark+1),a  
35d9 3a e3 35			ld a, (.dmark+2)  
35dc 32 60 ee			ld (debug_mark+2),a  
35df 18 03			jr .pastdmark  
35e1 ..			.dmark: db "-L1"  
35e4 f1			.pastdmark: pop af  
35e5			endm  
# End of macro DMARK
35e5						CALLMONITOR 
35e5 cd 6b ee			call debug_vector  
35e8				endm  
# End of macro CALLMONITOR
35e8					endif 
35e8			 
35e8 ed 52			sbc hl, de 
35ea			 
35ea			 
35ea				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
35ea			 
35ea 20 29				jr nz, .mloopnotdone 
35ec			 
35ec e1				pop hl   ; get rid of saved I 
35ed				FORTH_LOOP_POP     ; get rid of limit 
35ed cd 41 1d			call macro_forth_loop_pop 
35f0				endm 
# End of macro FORTH_LOOP_POP
35f0			 
35f0				FORTH_RSP_POP     ; get rid of DO ptr 
35f0 cd 9f 1a			call macro_forth_rsp_pop 
35f3				endm 
# End of macro FORTH_RSP_POP
35f3			 
35f3			if DEBUG_FORTH_WORDS 
35f3						DMARK "-L>" 
35f3 f5				push af  
35f4 3a 08 36			ld a, (.dmark)  
35f7 32 5e ee			ld (debug_mark),a  
35fa 3a 09 36			ld a, (.dmark+1)  
35fd 32 5f ee			ld (debug_mark+1),a  
3600 3a 0a 36			ld a, (.dmark+2)  
3603 32 60 ee			ld (debug_mark+2),a  
3606 18 03			jr .pastdmark  
3608 ..			.dmark: db "-L>"  
360b f1			.pastdmark: pop af  
360c			endm  
# End of macro DMARK
360c				CALLMONITOR 
360c cd 6b ee			call debug_vector  
360f				endm  
# End of macro CALLMONITOR
360f			endif 
360f			 
360f					NEXTW 
360f cd 68 ee			call parse_vector 
3612 c3 ba 1e			jp macro_next 
3615				endm 
# End of macro NEXTW
3615				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3615			 
3615			.mloopnotdone: 
3615			 
3615 e1				pop hl    ; get I 
3616 2b				dec hl 
3617			 
3617			   	; save new I 
3617			 
3617			 
3617					; set I counter 
3617			 
3617 22 d9 e5				ld (os_current_i), hl 
361a			 
361a					 
361a				FORTH_LOOP_NEXT 
361a cd 04 1d			call macro_forth_loop_next 
361d				endm 
# End of macro FORTH_LOOP_NEXT
361d			 
361d			 
361d					if DEBUG_FORTH_WORDS 
361d eb						ex de,hl 
361e					endif 
361e			 
361e			;	; get DO ptr 
361e			; 
361e				FORTH_RSP_TOS 
361e cd 95 1a			call macro_forth_rsp_tos 
3621				endm 
# End of macro FORTH_RSP_TOS
3621			 
3621				;push hl 
3621			 
3621				; not going to DO any more 
3621				; get rid of the RSP pointer as DO will add it back in 
3621				;FORTH_RSP_POP 
3621				;pop hl 
3621			 
3621			 
3621 22 b5 e5			ld (os_tok_ptr), hl 
3624					if DEBUG_FORTH_WORDS 
3624						DMARK "-L<" 
3624 f5				push af  
3625 3a 39 36			ld a, (.dmark)  
3628 32 5e ee			ld (debug_mark),a  
362b 3a 3a 36			ld a, (.dmark+1)  
362e 32 5f ee			ld (debug_mark+1),a  
3631 3a 3b 36			ld a, (.dmark+2)  
3634 32 60 ee			ld (debug_mark+2),a  
3637 18 03			jr .pastdmark  
3639 ..			.dmark: db "-L<"  
363c f1			.pastdmark: pop af  
363d			endm  
# End of macro DMARK
363d					CALLMONITOR 
363d cd 6b ee			call debug_vector  
3640				endm  
# End of macro CALLMONITOR
3640				endif 
3640 c3 3b 1f			jp exec1 
3643			 
3643					 
3643			 
3643			 
3643			 
3643				NEXTW 
3643 cd 68 ee			call parse_vector 
3646 c3 ba 1e			jp macro_next 
3649				endm 
# End of macro NEXTW
3649			 
3649			 
3649			 
3649			 
3649			.REPEAT: 
3649				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
3649 71				db WORD_SYS_CORE+93             
364a 9f 36			dw .UNTIL            
364c 06				db 5 + 1 
364d .. 00			db "REPEAT",0              
3654				endm 
# End of macro CWHEAD
3654			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
3654			;  push pc to rsp stack past the REPEAT 
3654					if DEBUG_FORTH_WORDS_KEY 
3654						DMARK "REP" 
3654 f5				push af  
3655 3a 69 36			ld a, (.dmark)  
3658 32 5e ee			ld (debug_mark),a  
365b 3a 6a 36			ld a, (.dmark+1)  
365e 32 5f ee			ld (debug_mark+1),a  
3661 3a 6b 36			ld a, (.dmark+2)  
3664 32 60 ee			ld (debug_mark+2),a  
3667 18 03			jr .pastdmark  
3669 ..			.dmark: db "REP"  
366c f1			.pastdmark: pop af  
366d			endm  
# End of macro DMARK
366d						CALLMONITOR 
366d cd 6b ee			call debug_vector  
3670				endm  
# End of macro CALLMONITOR
3670					endif 
3670			 
3670 2a b5 e5				ld hl, (os_tok_ptr) 
3673 23					inc hl   ; R 
3674 23					inc hl  ; E 
3675 23					inc hl   ; P 
3676 23					inc hl   ; E 
3677 23					inc hl   ; A 
3678 23					inc hl   ; T 
3679 23					inc hl   ; zero 
367a					FORTH_RSP_NEXT 
367a cd 7e 1a			call macro_forth_rsp_next 
367d				endm 
# End of macro FORTH_RSP_NEXT
367d			 
367d			 
367d					if DEBUG_FORTH_WORDS 
367d						DMARK "REP" 
367d f5				push af  
367e 3a 92 36			ld a, (.dmark)  
3681 32 5e ee			ld (debug_mark),a  
3684 3a 93 36			ld a, (.dmark+1)  
3687 32 5f ee			ld (debug_mark+1),a  
368a 3a 94 36			ld a, (.dmark+2)  
368d 32 60 ee			ld (debug_mark+2),a  
3690 18 03			jr .pastdmark  
3692 ..			.dmark: db "REP"  
3695 f1			.pastdmark: pop af  
3696			endm  
# End of macro DMARK
3696						;pop bc    ; TODO BUG ?????? what is this for???? 
3696						CALLMONITOR 
3696 cd 6b ee			call debug_vector  
3699				endm  
# End of macro CALLMONITOR
3699					endif 
3699			 
3699					NEXTW 
3699 cd 68 ee			call parse_vector 
369c c3 ba 1e			jp macro_next 
369f				endm 
# End of macro NEXTW
369f			;	       NEXTW 
369f			 
369f			.UNTIL: 
369f				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
369f 72				db WORD_SYS_CORE+94             
36a0 3c 37			dw .ENDFLOW            
36a2 06				db 5 + 1 
36a3 .. 00			db "UNTIL",0              
36a9				endm 
# End of macro CWHEAD
36a9			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
36a9			 
36a9				; pop tos as check 
36a9			 
36a9				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
36a9			 
36a9				FORTH_DSP_VALUEHL 
36a9 cd d3 1c			call macro_dsp_valuehl 
36ac				endm 
# End of macro FORTH_DSP_VALUEHL
36ac			 
36ac					if DEBUG_FORTH_WORDS_KEY 
36ac						DMARK "UNT" 
36ac f5				push af  
36ad 3a c1 36			ld a, (.dmark)  
36b0 32 5e ee			ld (debug_mark),a  
36b3 3a c2 36			ld a, (.dmark+1)  
36b6 32 5f ee			ld (debug_mark+1),a  
36b9 3a c3 36			ld a, (.dmark+2)  
36bc 32 60 ee			ld (debug_mark+2),a  
36bf 18 03			jr .pastdmark  
36c1 ..			.dmark: db "UNT"  
36c4 f1			.pastdmark: pop af  
36c5			endm  
# End of macro DMARK
36c5						CALLMONITOR 
36c5 cd 6b ee			call debug_vector  
36c8				endm  
# End of macro CALLMONITOR
36c8					endif 
36c8			 
36c8			;	push hl 
36c8				FORTH_DSP_POP 
36c8 cd 8b 1d			call macro_forth_dsp_pop 
36cb				endm 
# End of macro FORTH_DSP_POP
36cb			 
36cb			;	pop hl 
36cb			 
36cb				; test if true 
36cb			 
36cb cd 0f 0e			call ishlzero 
36ce			;	ld a,l 
36ce			;	add h 
36ce			; 
36ce			;	cp 0 
36ce			 
36ce 20 41			jr nz, .untilnotdone 
36d0			 
36d0					if DEBUG_FORTH_WORDS 
36d0						DMARK "UNf" 
36d0 f5				push af  
36d1 3a e5 36			ld a, (.dmark)  
36d4 32 5e ee			ld (debug_mark),a  
36d7 3a e6 36			ld a, (.dmark+1)  
36da 32 5f ee			ld (debug_mark+1),a  
36dd 3a e7 36			ld a, (.dmark+2)  
36e0 32 60 ee			ld (debug_mark+2),a  
36e3 18 03			jr .pastdmark  
36e5 ..			.dmark: db "UNf"  
36e8 f1			.pastdmark: pop af  
36e9			endm  
# End of macro DMARK
36e9						CALLMONITOR 
36e9 cd 6b ee			call debug_vector  
36ec				endm  
# End of macro CALLMONITOR
36ec					endif 
36ec			 
36ec			 
36ec			 
36ec				FORTH_RSP_POP     ; get rid of DO ptr 
36ec cd 9f 1a			call macro_forth_rsp_pop 
36ef				endm 
# End of macro FORTH_RSP_POP
36ef			 
36ef			if DEBUG_FORTH_WORDS 
36ef						DMARK "UN>" 
36ef f5				push af  
36f0 3a 04 37			ld a, (.dmark)  
36f3 32 5e ee			ld (debug_mark),a  
36f6 3a 05 37			ld a, (.dmark+1)  
36f9 32 5f ee			ld (debug_mark+1),a  
36fc 3a 06 37			ld a, (.dmark+2)  
36ff 32 60 ee			ld (debug_mark+2),a  
3702 18 03			jr .pastdmark  
3704 ..			.dmark: db "UN>"  
3707 f1			.pastdmark: pop af  
3708			endm  
# End of macro DMARK
3708				CALLMONITOR 
3708 cd 6b ee			call debug_vector  
370b				endm  
# End of macro CALLMONITOR
370b			endif 
370b			 
370b					NEXTW 
370b cd 68 ee			call parse_vector 
370e c3 ba 1e			jp macro_next 
3711				endm 
# End of macro NEXTW
3711				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3711			 
3711			.untilnotdone: 
3711			 
3711			 
3711			;	; get DO ptr 
3711			; 
3711				FORTH_RSP_TOS 
3711 cd 95 1a			call macro_forth_rsp_tos 
3714				endm 
# End of macro FORTH_RSP_TOS
3714			 
3714				;push hl 
3714			 
3714				; not going to DO any more 
3714				; get rid of the RSP pointer as DO will add it back in 
3714				;FORTH_RSP_POP 
3714				;pop hl 
3714			 
3714			 
3714 22 b5 e5			ld (os_tok_ptr), hl 
3717					if DEBUG_FORTH_WORDS 
3717						DMARK "UN<" 
3717 f5				push af  
3718 3a 2c 37			ld a, (.dmark)  
371b 32 5e ee			ld (debug_mark),a  
371e 3a 2d 37			ld a, (.dmark+1)  
3721 32 5f ee			ld (debug_mark+1),a  
3724 3a 2e 37			ld a, (.dmark+2)  
3727 32 60 ee			ld (debug_mark+2),a  
372a 18 03			jr .pastdmark  
372c ..			.dmark: db "UN<"  
372f f1			.pastdmark: pop af  
3730			endm  
# End of macro DMARK
3730					CALLMONITOR 
3730 cd 6b ee			call debug_vector  
3733				endm  
# End of macro CALLMONITOR
3733				endif 
3733 c3 3b 1f			jp exec1 
3736			 
3736					 
3736			 
3736			 
3736					NEXTW 
3736 cd 68 ee			call parse_vector 
3739 c3 ba 1e			jp macro_next 
373c				endm 
# End of macro NEXTW
373c			 
373c			 
373c			.ENDFLOW: 
373c			 
373c			; eof 
373c			 
# End of file forth_words_flow.asm
373c			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
373c			include "forth_words_logic.asm" 
373c			 
373c			; | ## Logic Words 
373c			 
373c			.NOT: 
373c				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
373c 2d				db WORD_SYS_CORE+25             
373d 8a 37			dw .IS            
373f 04				db 3 + 1 
3740 .. 00			db "NOT",0              
3744				endm 
# End of macro CWHEAD
3744			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
3744					if DEBUG_FORTH_WORDS_KEY 
3744						DMARK "NOT" 
3744 f5				push af  
3745 3a 59 37			ld a, (.dmark)  
3748 32 5e ee			ld (debug_mark),a  
374b 3a 5a 37			ld a, (.dmark+1)  
374e 32 5f ee			ld (debug_mark+1),a  
3751 3a 5b 37			ld a, (.dmark+2)  
3754 32 60 ee			ld (debug_mark+2),a  
3757 18 03			jr .pastdmark  
3759 ..			.dmark: db "NOT"  
375c f1			.pastdmark: pop af  
375d			endm  
# End of macro DMARK
375d						CALLMONITOR 
375d cd 6b ee			call debug_vector  
3760				endm  
# End of macro CALLMONITOR
3760					endif 
3760					FORTH_DSP 
3760 cd 99 1c			call macro_forth_dsp 
3763				endm 
# End of macro FORTH_DSP
3763 7e					ld a,(hl)	; get type of value on TOS 
3764 fe 02				cp DS_TYPE_INUM  
3766 28 06				jr z, .noti 
3768					NEXTW 
3768 cd 68 ee			call parse_vector 
376b c3 ba 1e			jp macro_next 
376e				endm 
# End of macro NEXTW
376e			.noti:          FORTH_DSP_VALUEHL 
376e cd d3 1c			call macro_dsp_valuehl 
3771				endm 
# End of macro FORTH_DSP_VALUEHL
3771			;		push hl 
3771					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3771 cd 8b 1d			call macro_forth_dsp_pop 
3774				endm 
# End of macro FORTH_DSP_POP
3774			;		pop hl 
3774 3e 00				ld a,0 
3776 bd					cp l 
3777 28 04				jr z, .not2t 
3779 2e 00				ld l, 0 
377b 18 02				jr .notip 
377d			 
377d 2e ff		.not2t:		ld l, 255 
377f			 
377f 26 00		.notip:		ld h, 0	 
3781			 
3781 cd d7 1a				call forth_push_numhl 
3784					NEXTW 
3784 cd 68 ee			call parse_vector 
3787 c3 ba 1e			jp macro_next 
378a				endm 
# End of macro NEXTW
378a			 
378a			.IS: 
378a				CWHEAD .LZERO 25 "COMPARE" 7 WORD_FLAG_CODE 
378a 2d				db WORD_SYS_CORE+25             
378b ce 37			dw .LZERO            
378d 08				db 7 + 1 
378e .. 00			db "COMPARE",0              
3796				endm 
# End of macro CWHEAD
3796			; | COMPARE ( s1 s2  -- f ) Push true if string s1 is the same as s2 | DONE 
3796					if DEBUG_FORTH_WORDS_KEY 
3796						DMARK "CMP" 
3796 f5				push af  
3797 3a ab 37			ld a, (.dmark)  
379a 32 5e ee			ld (debug_mark),a  
379d 3a ac 37			ld a, (.dmark+1)  
37a0 32 5f ee			ld (debug_mark+1),a  
37a3 3a ad 37			ld a, (.dmark+2)  
37a6 32 60 ee			ld (debug_mark+2),a  
37a9 18 03			jr .pastdmark  
37ab ..			.dmark: db "CMP"  
37ae f1			.pastdmark: pop af  
37af			endm  
# End of macro DMARK
37af						CALLMONITOR 
37af cd 6b ee			call debug_vector  
37b2				endm  
# End of macro CALLMONITOR
37b2					endif 
37b2			 
37b2					FORTH_DSP_VALUEHL 
37b2 cd d3 1c			call macro_dsp_valuehl 
37b5				endm 
# End of macro FORTH_DSP_VALUEHL
37b5			 
37b5 e5					push hl 
37b6			 
37b6					FORTH_DSP_VALUEM1 
37b6 cd c7 1c			call macro_forth_dsp_value_m1 
37b9				endm 
# End of macro FORTH_DSP_VALUEM1
37b9			 
37b9 d1					pop de 
37ba			 
37ba					; got pointers to both. Now check. 
37ba			 
37ba cd 76 11				call strcmp 
37bd				 
37bd 26 00				ld h, 0 
37bf 2e 00				ld l, 0 
37c1 20 02				jr nz, .compnsame 
37c3 2e 01				ld l, 1	 
37c5			.compnsame: 
37c5 cd d7 1a				call forth_push_numhl 
37c8			 
37c8					NEXTW 
37c8 cd 68 ee			call parse_vector 
37cb c3 ba 1e			jp macro_next 
37ce				endm 
# End of macro NEXTW
37ce			.LZERO: 
37ce				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
37ce 2d				db WORD_SYS_CORE+25             
37cf db 37			dw .TZERO            
37d1 03				db 2 + 1 
37d2 .. 00			db "0<",0              
37d5				endm 
# End of macro CWHEAD
37d5			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
37d5					NEXTW 
37d5 cd 68 ee			call parse_vector 
37d8 c3 ba 1e			jp macro_next 
37db				endm 
# End of macro NEXTW
37db			.TZERO: 
37db				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
37db 2e				db WORD_SYS_CORE+26             
37dc 25 38			dw .LESS            
37de 03				db 2 + 1 
37df .. 00			db "0=",0              
37e2				endm 
# End of macro CWHEAD
37e2			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
37e2				; TODO add floating point number detection 
37e2					;v5 FORTH_DSP_VALUE 
37e2					if DEBUG_FORTH_WORDS_KEY 
37e2						DMARK "0=." 
37e2 f5				push af  
37e3 3a f7 37			ld a, (.dmark)  
37e6 32 5e ee			ld (debug_mark),a  
37e9 3a f8 37			ld a, (.dmark+1)  
37ec 32 5f ee			ld (debug_mark+1),a  
37ef 3a f9 37			ld a, (.dmark+2)  
37f2 32 60 ee			ld (debug_mark+2),a  
37f5 18 03			jr .pastdmark  
37f7 ..			.dmark: db "0=."  
37fa f1			.pastdmark: pop af  
37fb			endm  
# End of macro DMARK
37fb						CALLMONITOR 
37fb cd 6b ee			call debug_vector  
37fe				endm  
# End of macro CALLMONITOR
37fe					endif 
37fe					FORTH_DSP 
37fe cd 99 1c			call macro_forth_dsp 
3801				endm 
# End of macro FORTH_DSP
3801 7e					ld a,(hl)	; get type of value on TOS 
3802 fe 02				cp DS_TYPE_INUM  
3804 28 00				jr z, .tz_inum 
3806			 
3806				if FORTH_ENABLE_FLOATMATH 
3806					jr .tz_done 
3806			 
3806				endif 
3806					 
3806			 
3806			.tz_inum: 
3806					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3806 cd d3 1c			call macro_dsp_valuehl 
3809				endm 
# End of macro FORTH_DSP_VALUEHL
3809			 
3809			;		push hl 
3809			 
3809					; destroy value TOS 
3809			 
3809					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3809 cd 8b 1d			call macro_forth_dsp_pop 
380c				endm 
# End of macro FORTH_DSP_POP
380c			 
380c			;		pop hl 
380c			 
380c 3e 00				ld a,0 
380e			 
380e bd					cp l 
380f 20 08				jr nz, .tz_notzero 
3811			 
3811 bc					cp h 
3812			 
3812 20 05				jr nz, .tz_notzero 
3814			 
3814			 
3814 21 01 00				ld hl, FORTH_TRUE 
3817 18 03				jr .tz_done 
3819			 
3819 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
381c			 
381c					; push value back onto stack for another op etc 
381c			 
381c			.tz_done: 
381c cd d7 1a				call forth_push_numhl 
381f			 
381f					NEXTW 
381f cd 68 ee			call parse_vector 
3822 c3 ba 1e			jp macro_next 
3825				endm 
# End of macro NEXTW
3825			.LESS: 
3825				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3825 2f				db WORD_SYS_CORE+27             
3826 91 38			dw .GT            
3828 02				db 1 + 1 
3829 .. 00			db "<",0              
382b				endm 
# End of macro CWHEAD
382b			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
382b				; TODO add floating point number detection 
382b					if DEBUG_FORTH_WORDS_KEY 
382b						DMARK "LES" 
382b f5				push af  
382c 3a 40 38			ld a, (.dmark)  
382f 32 5e ee			ld (debug_mark),a  
3832 3a 41 38			ld a, (.dmark+1)  
3835 32 5f ee			ld (debug_mark+1),a  
3838 3a 42 38			ld a, (.dmark+2)  
383b 32 60 ee			ld (debug_mark+2),a  
383e 18 03			jr .pastdmark  
3840 ..			.dmark: db "LES"  
3843 f1			.pastdmark: pop af  
3844			endm  
# End of macro DMARK
3844						CALLMONITOR 
3844 cd 6b ee			call debug_vector  
3847				endm  
# End of macro CALLMONITOR
3847					endif 
3847					FORTH_DSP 
3847 cd 99 1c			call macro_forth_dsp 
384a				endm 
# End of macro FORTH_DSP
384a					;v5 FORTH_DSP_VALUE 
384a 7e					ld a,(hl)	; get type of value on TOS 
384b fe 02				cp DS_TYPE_INUM  
384d 28 00				jr z, .less_inum 
384f			 
384f				if FORTH_ENABLE_FLOATMATH 
384f					jr .less_done 
384f			 
384f				endif 
384f					 
384f			 
384f			.less_inum: 
384f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
384f cd d3 1c			call macro_dsp_valuehl 
3852				endm 
# End of macro FORTH_DSP_VALUEHL
3852			 
3852 e5					push hl  ; u2 
3853			 
3853					; destroy value TOS 
3853			 
3853					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3853 cd 8b 1d			call macro_forth_dsp_pop 
3856				endm 
# End of macro FORTH_DSP_POP
3856			 
3856			 
3856					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3856 cd d3 1c			call macro_dsp_valuehl 
3859				endm 
# End of macro FORTH_DSP_VALUEHL
3859			 
3859 e5					push hl    ; u1 
385a			 
385a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
385a cd 8b 1d			call macro_forth_dsp_pop 
385d				endm 
# End of macro FORTH_DSP_POP
385d			 
385d			 
385d b7			 or a      ;clear carry flag 
385e 01 00 00		 ld bc, FORTH_FALSE 
3861 e1			  pop hl    ; u1 
3862 d1			  pop de    ; u2 
3863 ed 52		  sbc hl,de 
3865 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
3867			 
3867 01 01 00		 ld bc, FORTH_TRUE 
386a			.lscont:  
386a c5					push bc 
386b e1					pop hl 
386c			 
386c					if DEBUG_FORTH_WORDS 
386c						DMARK "LT1" 
386c f5				push af  
386d 3a 81 38			ld a, (.dmark)  
3870 32 5e ee			ld (debug_mark),a  
3873 3a 82 38			ld a, (.dmark+1)  
3876 32 5f ee			ld (debug_mark+1),a  
3879 3a 83 38			ld a, (.dmark+2)  
387c 32 60 ee			ld (debug_mark+2),a  
387f 18 03			jr .pastdmark  
3881 ..			.dmark: db "LT1"  
3884 f1			.pastdmark: pop af  
3885			endm  
# End of macro DMARK
3885						CALLMONITOR 
3885 cd 6b ee			call debug_vector  
3888				endm  
# End of macro CALLMONITOR
3888					endif 
3888 cd d7 1a				call forth_push_numhl 
388b			 
388b					NEXTW 
388b cd 68 ee			call parse_vector 
388e c3 ba 1e			jp macro_next 
3891				endm 
# End of macro NEXTW
3891			.GT: 
3891				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
3891 30				db WORD_SYS_CORE+28             
3892 fd 38			dw .EQUAL            
3894 02				db 1 + 1 
3895 .. 00			db ">",0              
3897				endm 
# End of macro CWHEAD
3897			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
3897				; TODO add floating point number detection 
3897					if DEBUG_FORTH_WORDS_KEY 
3897						DMARK "GRT" 
3897 f5				push af  
3898 3a ac 38			ld a, (.dmark)  
389b 32 5e ee			ld (debug_mark),a  
389e 3a ad 38			ld a, (.dmark+1)  
38a1 32 5f ee			ld (debug_mark+1),a  
38a4 3a ae 38			ld a, (.dmark+2)  
38a7 32 60 ee			ld (debug_mark+2),a  
38aa 18 03			jr .pastdmark  
38ac ..			.dmark: db "GRT"  
38af f1			.pastdmark: pop af  
38b0			endm  
# End of macro DMARK
38b0						CALLMONITOR 
38b0 cd 6b ee			call debug_vector  
38b3				endm  
# End of macro CALLMONITOR
38b3					endif 
38b3					FORTH_DSP 
38b3 cd 99 1c			call macro_forth_dsp 
38b6				endm 
# End of macro FORTH_DSP
38b6					;FORTH_DSP_VALUE 
38b6 7e					ld a,(hl)	; get type of value on TOS 
38b7 fe 02				cp DS_TYPE_INUM  
38b9 28 00				jr z, .gt_inum 
38bb			 
38bb				if FORTH_ENABLE_FLOATMATH 
38bb					jr .gt_done 
38bb			 
38bb				endif 
38bb					 
38bb			 
38bb			.gt_inum: 
38bb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38bb cd d3 1c			call macro_dsp_valuehl 
38be				endm 
# End of macro FORTH_DSP_VALUEHL
38be			 
38be e5					push hl  ; u2 
38bf			 
38bf					; destroy value TOS 
38bf			 
38bf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38bf cd 8b 1d			call macro_forth_dsp_pop 
38c2				endm 
# End of macro FORTH_DSP_POP
38c2			 
38c2			 
38c2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38c2 cd d3 1c			call macro_dsp_valuehl 
38c5				endm 
# End of macro FORTH_DSP_VALUEHL
38c5			 
38c5 e5					push hl    ; u1 
38c6			 
38c6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38c6 cd 8b 1d			call macro_forth_dsp_pop 
38c9				endm 
# End of macro FORTH_DSP_POP
38c9			 
38c9			 
38c9 b7			 or a      ;clear carry flag 
38ca 01 00 00		 ld bc, FORTH_FALSE 
38cd e1			  pop hl    ; u1 
38ce d1			  pop de    ; u2 
38cf ed 52		  sbc hl,de 
38d1 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
38d3			 
38d3 01 01 00		 ld bc, FORTH_TRUE 
38d6			.gtcont:  
38d6 c5					push bc 
38d7 e1					pop hl 
38d8			 
38d8					if DEBUG_FORTH_WORDS 
38d8						DMARK "GT1" 
38d8 f5				push af  
38d9 3a ed 38			ld a, (.dmark)  
38dc 32 5e ee			ld (debug_mark),a  
38df 3a ee 38			ld a, (.dmark+1)  
38e2 32 5f ee			ld (debug_mark+1),a  
38e5 3a ef 38			ld a, (.dmark+2)  
38e8 32 60 ee			ld (debug_mark+2),a  
38eb 18 03			jr .pastdmark  
38ed ..			.dmark: db "GT1"  
38f0 f1			.pastdmark: pop af  
38f1			endm  
# End of macro DMARK
38f1						CALLMONITOR 
38f1 cd 6b ee			call debug_vector  
38f4				endm  
# End of macro CALLMONITOR
38f4					endif 
38f4 cd d7 1a				call forth_push_numhl 
38f7			 
38f7					NEXTW 
38f7 cd 68 ee			call parse_vector 
38fa c3 ba 1e			jp macro_next 
38fd				endm 
# End of macro NEXTW
38fd			.EQUAL: 
38fd				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
38fd 31				db WORD_SYS_CORE+29             
38fe 6b 39			dw .ENDLOGIC            
3900 02				db 1 + 1 
3901 .. 00			db "=",0              
3903				endm 
# End of macro CWHEAD
3903			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3903				; TODO add floating point number detection 
3903					if DEBUG_FORTH_WORDS_KEY 
3903						DMARK "EQ." 
3903 f5				push af  
3904 3a 18 39			ld a, (.dmark)  
3907 32 5e ee			ld (debug_mark),a  
390a 3a 19 39			ld a, (.dmark+1)  
390d 32 5f ee			ld (debug_mark+1),a  
3910 3a 1a 39			ld a, (.dmark+2)  
3913 32 60 ee			ld (debug_mark+2),a  
3916 18 03			jr .pastdmark  
3918 ..			.dmark: db "EQ."  
391b f1			.pastdmark: pop af  
391c			endm  
# End of macro DMARK
391c						CALLMONITOR 
391c cd 6b ee			call debug_vector  
391f				endm  
# End of macro CALLMONITOR
391f					endif 
391f					FORTH_DSP 
391f cd 99 1c			call macro_forth_dsp 
3922				endm 
# End of macro FORTH_DSP
3922					;v5 FORTH_DSP_VALUE 
3922 7e					ld a,(hl)	; get type of value on TOS 
3923 fe 02				cp DS_TYPE_INUM  
3925 28 00				jr z, .eq_inum 
3927			 
3927				if FORTH_ENABLE_FLOATMATH 
3927					jr .eq_done 
3927			 
3927				endif 
3927					 
3927			 
3927			.eq_inum: 
3927					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3927 cd d3 1c			call macro_dsp_valuehl 
392a				endm 
# End of macro FORTH_DSP_VALUEHL
392a			 
392a e5					push hl 
392b			 
392b					; destroy value TOS 
392b			 
392b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
392b cd 8b 1d			call macro_forth_dsp_pop 
392e				endm 
# End of macro FORTH_DSP_POP
392e			 
392e			 
392e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
392e cd d3 1c			call macro_dsp_valuehl 
3931				endm 
# End of macro FORTH_DSP_VALUEHL
3931			 
3931					; one value on hl get other one back 
3931			 
3931 e5					push hl 
3932			 
3932					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3932 cd 8b 1d			call macro_forth_dsp_pop 
3935				endm 
# End of macro FORTH_DSP_POP
3935			 
3935 0e 00				ld c, FORTH_FALSE 
3937			 
3937 e1					pop hl 
3938 d1					pop de 
3939			 
3939 7b					ld a, e 
393a bd					cp l 
393b			 
393b 20 06				jr nz, .eq_done 
393d			 
393d 7a					ld a, d 
393e bc					cp h 
393f			 
393f 20 02				jr nz, .eq_done 
3941			 
3941 0e 01				ld c, FORTH_TRUE 
3943					 
3943			 
3943			 
3943			.eq_done: 
3943			 
3943					; TODO push value back onto stack for another op etc 
3943			 
3943 26 00				ld h, 0 
3945 69					ld l, c 
3946					if DEBUG_FORTH_WORDS 
3946						DMARK "EQ1" 
3946 f5				push af  
3947 3a 5b 39			ld a, (.dmark)  
394a 32 5e ee			ld (debug_mark),a  
394d 3a 5c 39			ld a, (.dmark+1)  
3950 32 5f ee			ld (debug_mark+1),a  
3953 3a 5d 39			ld a, (.dmark+2)  
3956 32 60 ee			ld (debug_mark+2),a  
3959 18 03			jr .pastdmark  
395b ..			.dmark: db "EQ1"  
395e f1			.pastdmark: pop af  
395f			endm  
# End of macro DMARK
395f						CALLMONITOR 
395f cd 6b ee			call debug_vector  
3962				endm  
# End of macro CALLMONITOR
3962					endif 
3962 cd d7 1a				call forth_push_numhl 
3965			 
3965					NEXTW 
3965 cd 68 ee			call parse_vector 
3968 c3 ba 1e			jp macro_next 
396b				endm 
# End of macro NEXTW
396b			 
396b			 
396b			.ENDLOGIC: 
396b			; eof 
396b			 
396b			 
# End of file forth_words_logic.asm
396b			include "forth_words_maths.asm" 
396b			 
396b			; | ## Maths Words 
396b			 
396b			.PLUS:	 
396b				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
396b 15				db WORD_SYS_CORE+1             
396c cf 39			dw .NEG            
396e 02				db 1 + 1 
396f .. 00			db "+",0              
3971				endm 
# End of macro CWHEAD
3971			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3971					if DEBUG_FORTH_WORDS_KEY 
3971						DMARK "PLU" 
3971 f5				push af  
3972 3a 86 39			ld a, (.dmark)  
3975 32 5e ee			ld (debug_mark),a  
3978 3a 87 39			ld a, (.dmark+1)  
397b 32 5f ee			ld (debug_mark+1),a  
397e 3a 88 39			ld a, (.dmark+2)  
3981 32 60 ee			ld (debug_mark+2),a  
3984 18 03			jr .pastdmark  
3986 ..			.dmark: db "PLU"  
3989 f1			.pastdmark: pop af  
398a			endm  
# End of macro DMARK
398a						CALLMONITOR 
398a cd 6b ee			call debug_vector  
398d				endm  
# End of macro CALLMONITOR
398d					endif 
398d					; add top two values and push back result 
398d			 
398d					;for v5 FORTH_DSP_VALUE 
398d					FORTH_DSP 
398d cd 99 1c			call macro_forth_dsp 
3990				endm 
# End of macro FORTH_DSP
3990 7e					ld a,(hl)	; get type of value on TOS 
3991 fe 02				cp DS_TYPE_INUM  
3993 28 06				jr z, .dot_inum 
3995			 
3995					NEXTW 
3995 cd 68 ee			call parse_vector 
3998 c3 ba 1e			jp macro_next 
399b				endm 
# End of macro NEXTW
399b			 
399b			; float maths 
399b			 
399b				if FORTH_ENABLE_FLOATMATH 
399b						inc hl      ; now at start of numeric as string 
399b			 
399b					if DEBUG_FORTH_MATHS 
399b						DMARK "ADD" 
399b				CALLMONITOR 
399b					endif 
399b			 
399b					;ld ix, hl 
399b					call CON 
399b			 
399b			 
399b					push hl 
399b					 
399b					 
399b			 
399b						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
399b			 
399b					; get next number 
399b			 
399b						FORTH_DSP_VALUE 
399b			 
399b						inc hl      ; now at start of numeric as string 
399b			 
399b					;ld ix, hl 
399b					call CON 
399b			 
399b					push hl 
399b			 
399b			 
399b						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
399b			 
399b						; TODO do add 
399b			 
399b						call IADD 
399b			 
399b						; TODO get result back as ascii 
399b			 
399b						; TODO push result  
399b			 
399b			 
399b			 
399b						jr .dot_done 
399b				endif 
399b			 
399b			.dot_inum: 
399b			 
399b			 
399b					if DEBUG_FORTH_DOT 
399b						DMARK "+IT" 
399b f5				push af  
399c 3a b0 39			ld a, (.dmark)  
399f 32 5e ee			ld (debug_mark),a  
39a2 3a b1 39			ld a, (.dmark+1)  
39a5 32 5f ee			ld (debug_mark+1),a  
39a8 3a b2 39			ld a, (.dmark+2)  
39ab 32 60 ee			ld (debug_mark+2),a  
39ae 18 03			jr .pastdmark  
39b0 ..			.dmark: db "+IT"  
39b3 f1			.pastdmark: pop af  
39b4			endm  
# End of macro DMARK
39b4				CALLMONITOR 
39b4 cd 6b ee			call debug_vector  
39b7				endm  
# End of macro CALLMONITOR
39b7					endif 
39b7			 
39b7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39b7 cd d3 1c			call macro_dsp_valuehl 
39ba				endm 
# End of macro FORTH_DSP_VALUEHL
39ba			 
39ba				; TODO add floating point number detection 
39ba			 
39ba e5					push hl 
39bb			 
39bb					; destroy value TOS 
39bb			 
39bb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39bb cd 8b 1d			call macro_forth_dsp_pop 
39be				endm 
# End of macro FORTH_DSP_POP
39be			 
39be			 
39be					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39be cd d3 1c			call macro_dsp_valuehl 
39c1				endm 
# End of macro FORTH_DSP_VALUEHL
39c1			 
39c1					; one value on hl get other one back 
39c1			 
39c1 d1					pop de 
39c2			 
39c2					; do the add 
39c2			 
39c2 19					add hl,de 
39c3			 
39c3					; save it 
39c3			 
39c3			;		push hl	 
39c3			 
39c3					; 
39c3			 
39c3					; destroy value TOS 
39c3			 
39c3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39c3 cd 8b 1d			call macro_forth_dsp_pop 
39c6				endm 
# End of macro FORTH_DSP_POP
39c6			 
39c6					; TODO push value back onto stack for another op etc 
39c6			 
39c6			;		pop hl 
39c6			 
39c6			.dot_done: 
39c6 cd d7 1a				call forth_push_numhl 
39c9			 
39c9					NEXTW 
39c9 cd 68 ee			call parse_vector 
39cc c3 ba 1e			jp macro_next 
39cf				endm 
# End of macro NEXTW
39cf			.NEG: 
39cf			 
39cf				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
39cf 17				db WORD_SYS_CORE+3             
39d0 18 3a			dw .DIV            
39d2 02				db 1 + 1 
39d3 .. 00			db "-",0              
39d5				endm 
# End of macro CWHEAD
39d5			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
39d5					if DEBUG_FORTH_WORDS_KEY 
39d5						DMARK "SUB" 
39d5 f5				push af  
39d6 3a ea 39			ld a, (.dmark)  
39d9 32 5e ee			ld (debug_mark),a  
39dc 3a eb 39			ld a, (.dmark+1)  
39df 32 5f ee			ld (debug_mark+1),a  
39e2 3a ec 39			ld a, (.dmark+2)  
39e5 32 60 ee			ld (debug_mark+2),a  
39e8 18 03			jr .pastdmark  
39ea ..			.dmark: db "SUB"  
39ed f1			.pastdmark: pop af  
39ee			endm  
# End of macro DMARK
39ee						CALLMONITOR 
39ee cd 6b ee			call debug_vector  
39f1				endm  
# End of macro CALLMONITOR
39f1					endif 
39f1			 
39f1			 
39f1				; TODO add floating point number detection 
39f1					; v5 FORTH_DSP_VALUE 
39f1					FORTH_DSP 
39f1 cd 99 1c			call macro_forth_dsp 
39f4				endm 
# End of macro FORTH_DSP
39f4 7e					ld a,(hl)	; get type of value on TOS 
39f5 fe 02				cp DS_TYPE_INUM  
39f7 28 06				jr z, .neg_inum 
39f9			 
39f9					NEXTW 
39f9 cd 68 ee			call parse_vector 
39fc c3 ba 1e			jp macro_next 
39ff				endm 
# End of macro NEXTW
39ff			 
39ff			; float maths 
39ff			 
39ff				if FORTH_ENABLE_FLOATMATH 
39ff					jr .neg_done 
39ff			 
39ff				endif 
39ff					 
39ff			 
39ff			.neg_inum: 
39ff					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39ff cd d3 1c			call macro_dsp_valuehl 
3a02				endm 
# End of macro FORTH_DSP_VALUEHL
3a02			 
3a02 e5					push hl 
3a03			 
3a03					; destroy value TOS 
3a03			 
3a03					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a03 cd 8b 1d			call macro_forth_dsp_pop 
3a06				endm 
# End of macro FORTH_DSP_POP
3a06			 
3a06			 
3a06					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a06 cd d3 1c			call macro_dsp_valuehl 
3a09				endm 
# End of macro FORTH_DSP_VALUEHL
3a09			 
3a09					; one value on hl get other one back 
3a09			 
3a09 d1					pop de 
3a0a			 
3a0a					; do the sub 
3a0a			;		ex de, hl 
3a0a			 
3a0a ed 52				sbc hl,de 
3a0c			 
3a0c					; save it 
3a0c			 
3a0c			;		push hl	 
3a0c			 
3a0c					; 
3a0c			 
3a0c					; destroy value TOS 
3a0c			 
3a0c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a0c cd 8b 1d			call macro_forth_dsp_pop 
3a0f				endm 
# End of macro FORTH_DSP_POP
3a0f			 
3a0f					; TODO push value back onto stack for another op etc 
3a0f			 
3a0f			;		pop hl 
3a0f			 
3a0f cd d7 1a				call forth_push_numhl 
3a12			.neg_done: 
3a12			 
3a12					NEXTW 
3a12 cd 68 ee			call parse_vector 
3a15 c3 ba 1e			jp macro_next 
3a18				endm 
# End of macro NEXTW
3a18			.DIV: 
3a18				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3a18 18				db WORD_SYS_CORE+4             
3a19 6b 3a			dw .MUL            
3a1b 02				db 1 + 1 
3a1c .. 00			db "/",0              
3a1e				endm 
# End of macro CWHEAD
3a1e			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3a1e					if DEBUG_FORTH_WORDS_KEY 
3a1e						DMARK "DIV" 
3a1e f5				push af  
3a1f 3a 33 3a			ld a, (.dmark)  
3a22 32 5e ee			ld (debug_mark),a  
3a25 3a 34 3a			ld a, (.dmark+1)  
3a28 32 5f ee			ld (debug_mark+1),a  
3a2b 3a 35 3a			ld a, (.dmark+2)  
3a2e 32 60 ee			ld (debug_mark+2),a  
3a31 18 03			jr .pastdmark  
3a33 ..			.dmark: db "DIV"  
3a36 f1			.pastdmark: pop af  
3a37			endm  
# End of macro DMARK
3a37						CALLMONITOR 
3a37 cd 6b ee			call debug_vector  
3a3a				endm  
# End of macro CALLMONITOR
3a3a					endif 
3a3a				; TODO add floating point number detection 
3a3a					; v5 FORTH_DSP_VALUE 
3a3a					FORTH_DSP 
3a3a cd 99 1c			call macro_forth_dsp 
3a3d				endm 
# End of macro FORTH_DSP
3a3d 7e					ld a,(hl)	; get type of value on TOS 
3a3e fe 02				cp DS_TYPE_INUM  
3a40 28 06				jr z, .div_inum 
3a42			 
3a42				if FORTH_ENABLE_FLOATMATH 
3a42					jr .div_done 
3a42			 
3a42				endif 
3a42					NEXTW 
3a42 cd 68 ee			call parse_vector 
3a45 c3 ba 1e			jp macro_next 
3a48				endm 
# End of macro NEXTW
3a48			.div_inum: 
3a48			 
3a48					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a48 cd d3 1c			call macro_dsp_valuehl 
3a4b				endm 
# End of macro FORTH_DSP_VALUEHL
3a4b			 
3a4b e5					push hl    ; to go to bc 
3a4c			 
3a4c					; destroy value TOS 
3a4c			 
3a4c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a4c cd 8b 1d			call macro_forth_dsp_pop 
3a4f				endm 
# End of macro FORTH_DSP_POP
3a4f			 
3a4f			 
3a4f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a4f cd d3 1c			call macro_dsp_valuehl 
3a52				endm 
# End of macro FORTH_DSP_VALUEHL
3a52			 
3a52					; hl to go to de 
3a52			 
3a52 e5					push hl 
3a53			 
3a53 c1					pop bc 
3a54 d1					pop de		 
3a55			 
3a55			 
3a55					if DEBUG_FORTH_MATHS 
3a55						DMARK "DIV" 
3a55				CALLMONITOR 
3a55					endif 
3a55					; one value on hl but move to a get other one back 
3a55			 
3a55			        
3a55 cd 43 0d			call Div16 
3a58			 
3a58			;	push af	 
3a58 e5				push hl 
3a59 c5				push bc 
3a5a			 
3a5a					if DEBUG_FORTH_MATHS 
3a5a						DMARK "DI1" 
3a5a				CALLMONITOR 
3a5a					endif 
3a5a			 
3a5a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a5a cd 8b 1d			call macro_forth_dsp_pop 
3a5d				endm 
# End of macro FORTH_DSP_POP
3a5d			 
3a5d			 
3a5d			 
3a5d e1					pop hl    ; result 
3a5e			 
3a5e cd d7 1a				call forth_push_numhl 
3a61			 
3a61 e1					pop hl    ; reminder 
3a62			;		ld h,0 
3a62			;		ld l,d 
3a62			 
3a62 cd d7 1a				call forth_push_numhl 
3a65			.div_done: 
3a65					NEXTW 
3a65 cd 68 ee			call parse_vector 
3a68 c3 ba 1e			jp macro_next 
3a6b				endm 
# End of macro NEXTW
3a6b			.MUL: 
3a6b				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3a6b 19				db WORD_SYS_CORE+5             
3a6c b6 3a			dw .MIN            
3a6e 02				db 1 + 1 
3a6f .. 00			db "*",0              
3a71				endm 
# End of macro CWHEAD
3a71			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3a71				; TODO add floating point number detection 
3a71					if DEBUG_FORTH_WORDS_KEY 
3a71						DMARK "MUL" 
3a71 f5				push af  
3a72 3a 86 3a			ld a, (.dmark)  
3a75 32 5e ee			ld (debug_mark),a  
3a78 3a 87 3a			ld a, (.dmark+1)  
3a7b 32 5f ee			ld (debug_mark+1),a  
3a7e 3a 88 3a			ld a, (.dmark+2)  
3a81 32 60 ee			ld (debug_mark+2),a  
3a84 18 03			jr .pastdmark  
3a86 ..			.dmark: db "MUL"  
3a89 f1			.pastdmark: pop af  
3a8a			endm  
# End of macro DMARK
3a8a						CALLMONITOR 
3a8a cd 6b ee			call debug_vector  
3a8d				endm  
# End of macro CALLMONITOR
3a8d					endif 
3a8d					FORTH_DSP 
3a8d cd 99 1c			call macro_forth_dsp 
3a90				endm 
# End of macro FORTH_DSP
3a90					; v5 FORTH_DSP_VALUE 
3a90 7e					ld a,(hl)	; get type of value on TOS 
3a91 fe 02				cp DS_TYPE_INUM  
3a93 28 06				jr z, .mul_inum 
3a95			 
3a95				if FORTH_ENABLE_FLOATMATH 
3a95					jr .mul_done 
3a95			 
3a95				endif 
3a95			 
3a95					NEXTW 
3a95 cd 68 ee			call parse_vector 
3a98 c3 ba 1e			jp macro_next 
3a9b				endm 
# End of macro NEXTW
3a9b			.mul_inum:	 
3a9b			 
3a9b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a9b cd d3 1c			call macro_dsp_valuehl 
3a9e				endm 
# End of macro FORTH_DSP_VALUEHL
3a9e			 
3a9e e5					push hl 
3a9f			 
3a9f					; destroy value TOS 
3a9f			 
3a9f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a9f cd 8b 1d			call macro_forth_dsp_pop 
3aa2				endm 
# End of macro FORTH_DSP_POP
3aa2			 
3aa2			 
3aa2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3aa2 cd d3 1c			call macro_dsp_valuehl 
3aa5				endm 
# End of macro FORTH_DSP_VALUEHL
3aa5			 
3aa5					; one value on hl but move to a get other one back 
3aa5			 
3aa5 7d					ld a, l 
3aa6			 
3aa6 d1					pop de 
3aa7			 
3aa7					; do the mull 
3aa7			;		ex de, hl 
3aa7			 
3aa7 cd 69 0d				call Mult16 
3aaa					; save it 
3aaa			 
3aaa			;		push hl	 
3aaa			 
3aaa					; 
3aaa			 
3aaa					; destroy value TOS 
3aaa			 
3aaa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3aaa cd 8b 1d			call macro_forth_dsp_pop 
3aad				endm 
# End of macro FORTH_DSP_POP
3aad			 
3aad					; TODO push value back onto stack for another op etc 
3aad			 
3aad			;		pop hl 
3aad			 
3aad cd d7 1a				call forth_push_numhl 
3ab0			 
3ab0			.mul_done: 
3ab0					NEXTW 
3ab0 cd 68 ee			call parse_vector 
3ab3 c3 ba 1e			jp macro_next 
3ab6				endm 
# End of macro NEXTW
3ab6			 
3ab6			 
3ab6			 
3ab6			 
3ab6			.MIN: 
3ab6				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3ab6 49				db WORD_SYS_CORE+53             
3ab7 3d 3b			dw .MAX            
3ab9 04				db 3 + 1 
3aba .. 00			db "MIN",0              
3abe				endm 
# End of macro CWHEAD
3abe			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3abe					if DEBUG_FORTH_WORDS_KEY 
3abe						DMARK "MIN" 
3abe f5				push af  
3abf 3a d3 3a			ld a, (.dmark)  
3ac2 32 5e ee			ld (debug_mark),a  
3ac5 3a d4 3a			ld a, (.dmark+1)  
3ac8 32 5f ee			ld (debug_mark+1),a  
3acb 3a d5 3a			ld a, (.dmark+2)  
3ace 32 60 ee			ld (debug_mark+2),a  
3ad1 18 03			jr .pastdmark  
3ad3 ..			.dmark: db "MIN"  
3ad6 f1			.pastdmark: pop af  
3ad7			endm  
# End of macro DMARK
3ad7						CALLMONITOR 
3ad7 cd 6b ee			call debug_vector  
3ada				endm  
# End of macro CALLMONITOR
3ada					endif 
3ada					; get u2 
3ada			 
3ada					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ada cd d3 1c			call macro_dsp_valuehl 
3add				endm 
# End of macro FORTH_DSP_VALUEHL
3add			 
3add e5					push hl   ; u2 
3ade			 
3ade					; destroy value TOS 
3ade			 
3ade					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ade cd 8b 1d			call macro_forth_dsp_pop 
3ae1				endm 
# End of macro FORTH_DSP_POP
3ae1			 
3ae1					; get u1 
3ae1			 
3ae1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ae1 cd d3 1c			call macro_dsp_valuehl 
3ae4				endm 
# End of macro FORTH_DSP_VALUEHL
3ae4			 
3ae4 e5					push hl  ; u1 
3ae5			 
3ae5					; destroy value TOS 
3ae5			 
3ae5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ae5 cd 8b 1d			call macro_forth_dsp_pop 
3ae8				endm 
# End of macro FORTH_DSP_POP
3ae8			 
3ae8 b7			 or a      ;clear carry flag 
3ae9 e1			  pop hl    ; u1 
3aea d1			  pop de    ; u2 
3aeb e5				push hl   ; saved in case hl is lowest 
3aec ed 52		  sbc hl,de 
3aee 30 26		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3af0			 
3af0 e1				pop hl 
3af1					if DEBUG_FORTH_WORDS 
3af1						DMARK "MIN" 
3af1 f5				push af  
3af2 3a 06 3b			ld a, (.dmark)  
3af5 32 5e ee			ld (debug_mark),a  
3af8 3a 07 3b			ld a, (.dmark+1)  
3afb 32 5f ee			ld (debug_mark+1),a  
3afe 3a 08 3b			ld a, (.dmark+2)  
3b01 32 60 ee			ld (debug_mark+2),a  
3b04 18 03			jr .pastdmark  
3b06 ..			.dmark: db "MIN"  
3b09 f1			.pastdmark: pop af  
3b0a			endm  
# End of macro DMARK
3b0a						CALLMONITOR 
3b0a cd 6b ee			call debug_vector  
3b0d				endm  
# End of macro CALLMONITOR
3b0d					endif 
3b0d cd d7 1a				call forth_push_numhl 
3b10			 
3b10				       NEXTW 
3b10 cd 68 ee			call parse_vector 
3b13 c3 ba 1e			jp macro_next 
3b16				endm 
# End of macro NEXTW
3b16			 
3b16			.mincont:  
3b16 c1				pop bc   ; tidy up 
3b17 eb				ex de , hl  
3b18					if DEBUG_FORTH_WORDS 
3b18						DMARK "MI1" 
3b18 f5				push af  
3b19 3a 2d 3b			ld a, (.dmark)  
3b1c 32 5e ee			ld (debug_mark),a  
3b1f 3a 2e 3b			ld a, (.dmark+1)  
3b22 32 5f ee			ld (debug_mark+1),a  
3b25 3a 2f 3b			ld a, (.dmark+2)  
3b28 32 60 ee			ld (debug_mark+2),a  
3b2b 18 03			jr .pastdmark  
3b2d ..			.dmark: db "MI1"  
3b30 f1			.pastdmark: pop af  
3b31			endm  
# End of macro DMARK
3b31						CALLMONITOR 
3b31 cd 6b ee			call debug_vector  
3b34				endm  
# End of macro CALLMONITOR
3b34					endif 
3b34 cd d7 1a				call forth_push_numhl 
3b37			 
3b37				       NEXTW 
3b37 cd 68 ee			call parse_vector 
3b3a c3 ba 1e			jp macro_next 
3b3d				endm 
# End of macro NEXTW
3b3d			.MAX: 
3b3d				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3b3d 4a				db WORD_SYS_CORE+54             
3b3e c4 3b			dw .RND16            
3b40 04				db 3 + 1 
3b41 .. 00			db "MAX",0              
3b45				endm 
# End of macro CWHEAD
3b45			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3b45					if DEBUG_FORTH_WORDS_KEY 
3b45						DMARK "MAX" 
3b45 f5				push af  
3b46 3a 5a 3b			ld a, (.dmark)  
3b49 32 5e ee			ld (debug_mark),a  
3b4c 3a 5b 3b			ld a, (.dmark+1)  
3b4f 32 5f ee			ld (debug_mark+1),a  
3b52 3a 5c 3b			ld a, (.dmark+2)  
3b55 32 60 ee			ld (debug_mark+2),a  
3b58 18 03			jr .pastdmark  
3b5a ..			.dmark: db "MAX"  
3b5d f1			.pastdmark: pop af  
3b5e			endm  
# End of macro DMARK
3b5e						CALLMONITOR 
3b5e cd 6b ee			call debug_vector  
3b61				endm  
# End of macro CALLMONITOR
3b61					endif 
3b61					; get u2 
3b61			 
3b61					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b61 cd d3 1c			call macro_dsp_valuehl 
3b64				endm 
# End of macro FORTH_DSP_VALUEHL
3b64			 
3b64 e5					push hl   ; u2 
3b65			 
3b65					; destroy value TOS 
3b65			 
3b65					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b65 cd 8b 1d			call macro_forth_dsp_pop 
3b68				endm 
# End of macro FORTH_DSP_POP
3b68			 
3b68					; get u1 
3b68			 
3b68					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b68 cd d3 1c			call macro_dsp_valuehl 
3b6b				endm 
# End of macro FORTH_DSP_VALUEHL
3b6b			 
3b6b e5					push hl  ; u1 
3b6c			 
3b6c					; destroy value TOS 
3b6c			 
3b6c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b6c cd 8b 1d			call macro_forth_dsp_pop 
3b6f				endm 
# End of macro FORTH_DSP_POP
3b6f			 
3b6f b7			 or a      ;clear carry flag 
3b70 e1			  pop hl    ; u1 
3b71 d1			  pop de    ; u2 
3b72 e5				push hl   ; saved in case hl is lowest 
3b73 ed 52		  sbc hl,de 
3b75 38 26		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3b77			 
3b77 e1				pop hl 
3b78					if DEBUG_FORTH_WORDS 
3b78						DMARK "MAX" 
3b78 f5				push af  
3b79 3a 8d 3b			ld a, (.dmark)  
3b7c 32 5e ee			ld (debug_mark),a  
3b7f 3a 8e 3b			ld a, (.dmark+1)  
3b82 32 5f ee			ld (debug_mark+1),a  
3b85 3a 8f 3b			ld a, (.dmark+2)  
3b88 32 60 ee			ld (debug_mark+2),a  
3b8b 18 03			jr .pastdmark  
3b8d ..			.dmark: db "MAX"  
3b90 f1			.pastdmark: pop af  
3b91			endm  
# End of macro DMARK
3b91						CALLMONITOR 
3b91 cd 6b ee			call debug_vector  
3b94				endm  
# End of macro CALLMONITOR
3b94					endif 
3b94 cd d7 1a				call forth_push_numhl 
3b97			 
3b97				       NEXTW 
3b97 cd 68 ee			call parse_vector 
3b9a c3 ba 1e			jp macro_next 
3b9d				endm 
# End of macro NEXTW
3b9d			 
3b9d			.maxcont:  
3b9d c1				pop bc   ; tidy up 
3b9e eb				ex de , hl  
3b9f					if DEBUG_FORTH_WORDS 
3b9f						DMARK "MA1" 
3b9f f5				push af  
3ba0 3a b4 3b			ld a, (.dmark)  
3ba3 32 5e ee			ld (debug_mark),a  
3ba6 3a b5 3b			ld a, (.dmark+1)  
3ba9 32 5f ee			ld (debug_mark+1),a  
3bac 3a b6 3b			ld a, (.dmark+2)  
3baf 32 60 ee			ld (debug_mark+2),a  
3bb2 18 03			jr .pastdmark  
3bb4 ..			.dmark: db "MA1"  
3bb7 f1			.pastdmark: pop af  
3bb8			endm  
# End of macro DMARK
3bb8						CALLMONITOR 
3bb8 cd 6b ee			call debug_vector  
3bbb				endm  
# End of macro CALLMONITOR
3bbb					endif 
3bbb cd d7 1a				call forth_push_numhl 
3bbe				       NEXTW 
3bbe cd 68 ee			call parse_vector 
3bc1 c3 ba 1e			jp macro_next 
3bc4				endm 
# End of macro NEXTW
3bc4			 
3bc4			.RND16: 
3bc4				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3bc4 4e				db WORD_SYS_CORE+58             
3bc5 f6 3b			dw .RND8            
3bc7 06				db 5 + 1 
3bc8 .. 00			db "RND16",0              
3bce				endm 
# End of macro CWHEAD
3bce			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3bce					if DEBUG_FORTH_WORDS_KEY 
3bce						DMARK "R16" 
3bce f5				push af  
3bcf 3a e3 3b			ld a, (.dmark)  
3bd2 32 5e ee			ld (debug_mark),a  
3bd5 3a e4 3b			ld a, (.dmark+1)  
3bd8 32 5f ee			ld (debug_mark+1),a  
3bdb 3a e5 3b			ld a, (.dmark+2)  
3bde 32 60 ee			ld (debug_mark+2),a  
3be1 18 03			jr .pastdmark  
3be3 ..			.dmark: db "R16"  
3be6 f1			.pastdmark: pop af  
3be7			endm  
# End of macro DMARK
3be7						CALLMONITOR 
3be7 cd 6b ee			call debug_vector  
3bea				endm  
# End of macro CALLMONITOR
3bea					endif 
3bea cd 0d 0d				call prng16  
3bed cd d7 1a				call forth_push_numhl 
3bf0				       NEXTW 
3bf0 cd 68 ee			call parse_vector 
3bf3 c3 ba 1e			jp macro_next 
3bf6				endm 
# End of macro NEXTW
3bf6			.RND8: 
3bf6				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3bf6 60				db WORD_SYS_CORE+76             
3bf7 2e 3c			dw .RND            
3bf9 05				db 4 + 1 
3bfa .. 00			db "RND8",0              
3bff				endm 
# End of macro CWHEAD
3bff			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3bff					if DEBUG_FORTH_WORDS_KEY 
3bff						DMARK "RN8" 
3bff f5				push af  
3c00 3a 14 3c			ld a, (.dmark)  
3c03 32 5e ee			ld (debug_mark),a  
3c06 3a 15 3c			ld a, (.dmark+1)  
3c09 32 5f ee			ld (debug_mark+1),a  
3c0c 3a 16 3c			ld a, (.dmark+2)  
3c0f 32 60 ee			ld (debug_mark+2),a  
3c12 18 03			jr .pastdmark  
3c14 ..			.dmark: db "RN8"  
3c17 f1			.pastdmark: pop af  
3c18			endm  
# End of macro DMARK
3c18						CALLMONITOR 
3c18 cd 6b ee			call debug_vector  
3c1b				endm  
# End of macro CALLMONITOR
3c1b					endif 
3c1b 2a 9c eb				ld hl,(xrandc) 
3c1e 23					inc hl 
3c1f cd 27 0d				call xrnd 
3c22 6f					ld l,a	 
3c23 26 00				ld h,0 
3c25 cd d7 1a				call forth_push_numhl 
3c28				       NEXTW 
3c28 cd 68 ee			call parse_vector 
3c2b c3 ba 1e			jp macro_next 
3c2e				endm 
# End of macro NEXTW
3c2e			.RND: 
3c2e				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3c2e 60				db WORD_SYS_CORE+76             
3c2f 37 3d			dw .ENDMATHS            
3c31 04				db 3 + 1 
3c32 .. 00			db "RND",0              
3c36				endm 
# End of macro CWHEAD
3c36			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3c36			 
3c36					if DEBUG_FORTH_WORDS_KEY 
3c36						DMARK "RND" 
3c36 f5				push af  
3c37 3a 4b 3c			ld a, (.dmark)  
3c3a 32 5e ee			ld (debug_mark),a  
3c3d 3a 4c 3c			ld a, (.dmark+1)  
3c40 32 5f ee			ld (debug_mark+1),a  
3c43 3a 4d 3c			ld a, (.dmark+2)  
3c46 32 60 ee			ld (debug_mark+2),a  
3c49 18 03			jr .pastdmark  
3c4b ..			.dmark: db "RND"  
3c4e f1			.pastdmark: pop af  
3c4f			endm  
# End of macro DMARK
3c4f						CALLMONITOR 
3c4f cd 6b ee			call debug_vector  
3c52				endm  
# End of macro CALLMONITOR
3c52					endif 
3c52					 
3c52					FORTH_DSP_VALUEHL    ; upper range 
3c52 cd d3 1c			call macro_dsp_valuehl 
3c55				endm 
# End of macro FORTH_DSP_VALUEHL
3c55			 
3c55 22 a0 eb				ld (LFSRSeed), hl	 
3c58			 
3c58					if DEBUG_FORTH_WORDS 
3c58						DMARK "RN1" 
3c58 f5				push af  
3c59 3a 6d 3c			ld a, (.dmark)  
3c5c 32 5e ee			ld (debug_mark),a  
3c5f 3a 6e 3c			ld a, (.dmark+1)  
3c62 32 5f ee			ld (debug_mark+1),a  
3c65 3a 6f 3c			ld a, (.dmark+2)  
3c68 32 60 ee			ld (debug_mark+2),a  
3c6b 18 03			jr .pastdmark  
3c6d ..			.dmark: db "RN1"  
3c70 f1			.pastdmark: pop af  
3c71			endm  
# End of macro DMARK
3c71						CALLMONITOR 
3c71 cd 6b ee			call debug_vector  
3c74				endm  
# End of macro CALLMONITOR
3c74					endif 
3c74					FORTH_DSP_POP 
3c74 cd 8b 1d			call macro_forth_dsp_pop 
3c77				endm 
# End of macro FORTH_DSP_POP
3c77			 
3c77					FORTH_DSP_VALUEHL    ; low range 
3c77 cd d3 1c			call macro_dsp_valuehl 
3c7a				endm 
# End of macro FORTH_DSP_VALUEHL
3c7a			 
3c7a					if DEBUG_FORTH_WORDS 
3c7a						DMARK "RN2" 
3c7a f5				push af  
3c7b 3a 8f 3c			ld a, (.dmark)  
3c7e 32 5e ee			ld (debug_mark),a  
3c81 3a 90 3c			ld a, (.dmark+1)  
3c84 32 5f ee			ld (debug_mark+1),a  
3c87 3a 91 3c			ld a, (.dmark+2)  
3c8a 32 60 ee			ld (debug_mark+2),a  
3c8d 18 03			jr .pastdmark  
3c8f ..			.dmark: db "RN2"  
3c92 f1			.pastdmark: pop af  
3c93			endm  
# End of macro DMARK
3c93						CALLMONITOR 
3c93 cd 6b ee			call debug_vector  
3c96				endm  
# End of macro CALLMONITOR
3c96					endif 
3c96 22 a2 eb				ld (LFSRSeed+2), hl 
3c99			 
3c99					FORTH_DSP_POP 
3c99 cd 8b 1d			call macro_forth_dsp_pop 
3c9c				endm 
# End of macro FORTH_DSP_POP
3c9c			 
3c9c e5					push hl 
3c9d			 
3c9d e1			.inrange:	pop hl 
3c9e cd 0d 0d				call prng16  
3ca1					if DEBUG_FORTH_WORDS 
3ca1						DMARK "RN3" 
3ca1 f5				push af  
3ca2 3a b6 3c			ld a, (.dmark)  
3ca5 32 5e ee			ld (debug_mark),a  
3ca8 3a b7 3c			ld a, (.dmark+1)  
3cab 32 5f ee			ld (debug_mark+1),a  
3cae 3a b8 3c			ld a, (.dmark+2)  
3cb1 32 60 ee			ld (debug_mark+2),a  
3cb4 18 03			jr .pastdmark  
3cb6 ..			.dmark: db "RN3"  
3cb9 f1			.pastdmark: pop af  
3cba			endm  
# End of macro DMARK
3cba						CALLMONITOR 
3cba cd 6b ee			call debug_vector  
3cbd				endm  
# End of macro CALLMONITOR
3cbd					endif 
3cbd					 
3cbd					; if the range is 8bit knock out the high byte 
3cbd			 
3cbd ed 5b a0 eb			ld de, (LFSRSeed)     ; check high level 
3cc1			 
3cc1 3e 00				ld a, 0 
3cc3 ba					cp d  
3cc4 20 1e				jr nz, .hirange 
3cc6 26 00				ld h, 0   ; knock it down to 8bit 
3cc8			 
3cc8					if DEBUG_FORTH_WORDS 
3cc8						DMARK "RNk" 
3cc8 f5				push af  
3cc9 3a dd 3c			ld a, (.dmark)  
3ccc 32 5e ee			ld (debug_mark),a  
3ccf 3a de 3c			ld a, (.dmark+1)  
3cd2 32 5f ee			ld (debug_mark+1),a  
3cd5 3a df 3c			ld a, (.dmark+2)  
3cd8 32 60 ee			ld (debug_mark+2),a  
3cdb 18 03			jr .pastdmark  
3cdd ..			.dmark: db "RNk"  
3ce0 f1			.pastdmark: pop af  
3ce1			endm  
# End of macro DMARK
3ce1						CALLMONITOR 
3ce1 cd 6b ee			call debug_vector  
3ce4				endm  
# End of macro CALLMONITOR
3ce4					endif 
3ce4			.hirange:   
3ce4 e5					push hl  
3ce5 b7					or a  
3ce6 ed 52		                sbc hl, de 
3ce8			 
3ce8					;call cmp16 
3ce8			 
3ce8 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3cea e1					pop hl 
3ceb e5					push hl 
3cec			 
3cec					if DEBUG_FORTH_WORDS 
3cec						DMARK "RN4" 
3cec f5				push af  
3ced 3a 01 3d			ld a, (.dmark)  
3cf0 32 5e ee			ld (debug_mark),a  
3cf3 3a 02 3d			ld a, (.dmark+1)  
3cf6 32 5f ee			ld (debug_mark+1),a  
3cf9 3a 03 3d			ld a, (.dmark+2)  
3cfc 32 60 ee			ld (debug_mark+2),a  
3cff 18 03			jr .pastdmark  
3d01 ..			.dmark: db "RN4"  
3d04 f1			.pastdmark: pop af  
3d05			endm  
# End of macro DMARK
3d05						CALLMONITOR 
3d05 cd 6b ee			call debug_vector  
3d08				endm  
# End of macro CALLMONITOR
3d08					endif 
3d08 ed 5b a2 eb			ld de, (LFSRSeed+2)   ; check low range 
3d0c					;call cmp16 
3d0c				 
3d0c b7					or a  
3d0d ed 52		                sbc hl, de 
3d0f 38 8c				jr c, .inrange 
3d11			 
3d11 e1					pop hl 
3d12					 
3d12					if DEBUG_FORTH_WORDS 
3d12						DMARK "RNd" 
3d12 f5				push af  
3d13 3a 27 3d			ld a, (.dmark)  
3d16 32 5e ee			ld (debug_mark),a  
3d19 3a 28 3d			ld a, (.dmark+1)  
3d1c 32 5f ee			ld (debug_mark+1),a  
3d1f 3a 29 3d			ld a, (.dmark+2)  
3d22 32 60 ee			ld (debug_mark+2),a  
3d25 18 03			jr .pastdmark  
3d27 ..			.dmark: db "RNd"  
3d2a f1			.pastdmark: pop af  
3d2b			endm  
# End of macro DMARK
3d2b						CALLMONITOR 
3d2b cd 6b ee			call debug_vector  
3d2e				endm  
# End of macro CALLMONITOR
3d2e					endif 
3d2e			 
3d2e			 
3d2e cd d7 1a				call forth_push_numhl 
3d31				       NEXTW 
3d31 cd 68 ee			call parse_vector 
3d34 c3 ba 1e			jp macro_next 
3d37				endm 
# End of macro NEXTW
3d37			 
3d37			.ENDMATHS: 
3d37			 
3d37			; eof 
3d37			 
# End of file forth_words_maths.asm
3d37			include "forth_words_display.asm" 
3d37			 
3d37			; | ## Display Words 
3d37			 
3d37			.ACT: 
3d37			 
3d37				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
3d37 62				db WORD_SYS_CORE+78             
3d38 86 3d			dw .INFO            
3d3a 07				db 6 + 1 
3d3b .. 00			db "ACTIVE",0              
3d42				endm 
# End of macro CWHEAD
3d42			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
3d42			;  
3d42			; | | To display a pulsing activity indicator in a processing loop do this... 
3d42			; | | e.g. $ff $00 do active . ..... Your code ..... loop 
3d42			 
3d42					if DEBUG_FORTH_WORDS_KEY 
3d42						DMARK "ACT" 
3d42 f5				push af  
3d43 3a 57 3d			ld a, (.dmark)  
3d46 32 5e ee			ld (debug_mark),a  
3d49 3a 58 3d			ld a, (.dmark+1)  
3d4c 32 5f ee			ld (debug_mark+1),a  
3d4f 3a 59 3d			ld a, (.dmark+2)  
3d52 32 60 ee			ld (debug_mark+2),a  
3d55 18 03			jr .pastdmark  
3d57 ..			.dmark: db "ACT"  
3d5a f1			.pastdmark: pop af  
3d5b			endm  
# End of macro DMARK
3d5b						CALLMONITOR 
3d5b cd 6b ee			call debug_vector  
3d5e				endm  
# End of macro CALLMONITOR
3d5e					endif 
3d5e cd 14 0b				call active 
3d61					if DEBUG_FORTH_WORDS 
3d61						DMARK "ACp" 
3d61 f5				push af  
3d62 3a 76 3d			ld a, (.dmark)  
3d65 32 5e ee			ld (debug_mark),a  
3d68 3a 77 3d			ld a, (.dmark+1)  
3d6b 32 5f ee			ld (debug_mark+1),a  
3d6e 3a 78 3d			ld a, (.dmark+2)  
3d71 32 60 ee			ld (debug_mark+2),a  
3d74 18 03			jr .pastdmark  
3d76 ..			.dmark: db "ACp"  
3d79 f1			.pastdmark: pop af  
3d7a			endm  
# End of macro DMARK
3d7a						CALLMONITOR 
3d7a cd 6b ee			call debug_vector  
3d7d				endm  
# End of macro CALLMONITOR
3d7d					endif 
3d7d cd 41 1b				call forth_push_str 
3d80			 
3d80					NEXTW 
3d80 cd 68 ee			call parse_vector 
3d83 c3 ba 1e			jp macro_next 
3d86				endm 
# End of macro NEXTW
3d86			.INFO: 
3d86			 
3d86				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3d86 62				db WORD_SYS_CORE+78             
3d87 a6 3d			dw .ATP            
3d89 05				db 4 + 1 
3d8a .. 00			db "INFO",0              
3d8f				endm 
# End of macro CWHEAD
3d8f			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3d8f					FORTH_DSP_VALUEHL 
3d8f cd d3 1c			call macro_dsp_valuehl 
3d92				endm 
# End of macro FORTH_DSP_VALUEHL
3d92			 
3d92					FORTH_DSP_POP 
3d92 cd 8b 1d			call macro_forth_dsp_pop 
3d95				endm 
# End of macro FORTH_DSP_POP
3d95			 
3d95 e5					push hl 
3d96			 
3d96					FORTH_DSP_VALUEHL 
3d96 cd d3 1c			call macro_dsp_valuehl 
3d99				endm 
# End of macro FORTH_DSP_VALUEHL
3d99			 
3d99					FORTH_DSP_POP 
3d99 cd 8b 1d			call macro_forth_dsp_pop 
3d9c				endm 
# End of macro FORTH_DSP_POP
3d9c			 
3d9c d1					pop de 
3d9d			 
3d9d cd 4e 0b				call info_panel 
3da0			 
3da0			 
3da0					NEXTW 
3da0 cd 68 ee			call parse_vector 
3da3 c3 ba 1e			jp macro_next 
3da6				endm 
# End of macro NEXTW
3da6			.ATP: 
3da6				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3da6 62				db WORD_SYS_CORE+78             
3da7 20 3e			dw .FB            
3da9 04				db 3 + 1 
3daa .. 00			db "AT?",0              
3dae				endm 
# End of macro CWHEAD
3dae			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3dae					if DEBUG_FORTH_WORDS_KEY 
3dae						DMARK "AT?" 
3dae f5				push af  
3daf 3a c3 3d			ld a, (.dmark)  
3db2 32 5e ee			ld (debug_mark),a  
3db5 3a c4 3d			ld a, (.dmark+1)  
3db8 32 5f ee			ld (debug_mark+1),a  
3dbb 3a c5 3d			ld a, (.dmark+2)  
3dbe 32 60 ee			ld (debug_mark+2),a  
3dc1 18 03			jr .pastdmark  
3dc3 ..			.dmark: db "AT?"  
3dc6 f1			.pastdmark: pop af  
3dc7			endm  
# End of macro DMARK
3dc7						CALLMONITOR 
3dc7 cd 6b ee			call debug_vector  
3dca				endm  
# End of macro CALLMONITOR
3dca					endif 
3dca 3a 51 ea				ld a, (f_cursor_ptr) 
3dcd			 
3dcd			if DEBUG_FORTH_WORDS 
3dcd				DMARK "AT?" 
3dcd f5				push af  
3dce 3a e2 3d			ld a, (.dmark)  
3dd1 32 5e ee			ld (debug_mark),a  
3dd4 3a e3 3d			ld a, (.dmark+1)  
3dd7 32 5f ee			ld (debug_mark+1),a  
3dda 3a e4 3d			ld a, (.dmark+2)  
3ddd 32 60 ee			ld (debug_mark+2),a  
3de0 18 03			jr .pastdmark  
3de2 ..			.dmark: db "AT?"  
3de5 f1			.pastdmark: pop af  
3de6			endm  
# End of macro DMARK
3de6				CALLMONITOR 
3de6 cd 6b ee			call debug_vector  
3de9				endm  
# End of macro CALLMONITOR
3de9			endif	 
3de9					; count the number of rows 
3de9			 
3de9 06 00				ld b, 0 
3deb 4f			.atpr:		ld c, a    ; save in case we go below zero 
3dec d6 28				sub display_cols 
3dee f2 f4 3d				jp p, .atprunder 
3df1 04					inc b 
3df2 18 f7				jr .atpr 
3df4			.atprunder:	 
3df4			if DEBUG_FORTH_WORDS 
3df4				DMARK "A?2" 
3df4 f5				push af  
3df5 3a 09 3e			ld a, (.dmark)  
3df8 32 5e ee			ld (debug_mark),a  
3dfb 3a 0a 3e			ld a, (.dmark+1)  
3dfe 32 5f ee			ld (debug_mark+1),a  
3e01 3a 0b 3e			ld a, (.dmark+2)  
3e04 32 60 ee			ld (debug_mark+2),a  
3e07 18 03			jr .pastdmark  
3e09 ..			.dmark: db "A?2"  
3e0c f1			.pastdmark: pop af  
3e0d			endm  
# End of macro DMARK
3e0d				CALLMONITOR 
3e0d cd 6b ee			call debug_vector  
3e10				endm  
# End of macro CALLMONITOR
3e10			endif	 
3e10 26 00				ld h, 0 
3e12 69					ld l, c 
3e13 cd d7 1a				call forth_push_numhl 
3e16 68					ld l, b  
3e17 cd d7 1a				call forth_push_numhl 
3e1a			 
3e1a			 
3e1a				NEXTW 
3e1a cd 68 ee			call parse_vector 
3e1d c3 ba 1e			jp macro_next 
3e20				endm 
# End of macro NEXTW
3e20			 
3e20			.FB: 
3e20				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3e20 1b				db WORD_SYS_CORE+7             
3e21 71 3e			dw .EMIT            
3e23 03				db 2 + 1 
3e24 .. 00			db "FB",0              
3e27				endm 
# End of macro CWHEAD
3e27			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3e27			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3e27			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3e27			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3e27					if DEBUG_FORTH_WORDS_KEY 
3e27						DMARK "FB." 
3e27 f5				push af  
3e28 3a 3c 3e			ld a, (.dmark)  
3e2b 32 5e ee			ld (debug_mark),a  
3e2e 3a 3d 3e			ld a, (.dmark+1)  
3e31 32 5f ee			ld (debug_mark+1),a  
3e34 3a 3e 3e			ld a, (.dmark+2)  
3e37 32 60 ee			ld (debug_mark+2),a  
3e3a 18 03			jr .pastdmark  
3e3c ..			.dmark: db "FB."  
3e3f f1			.pastdmark: pop af  
3e40			endm  
# End of macro DMARK
3e40						CALLMONITOR 
3e40 cd 6b ee			call debug_vector  
3e43				endm  
# End of macro CALLMONITOR
3e43					endif 
3e43			 
3e43					FORTH_DSP_VALUEHL 
3e43 cd d3 1c			call macro_dsp_valuehl 
3e46				endm 
# End of macro FORTH_DSP_VALUEHL
3e46			 
3e46 7d					ld a, l 
3e47 fe 01				cp 1 
3e49 20 05				jr nz, .fbn1 
3e4b 21 03 ed				ld hl, display_fb1 
3e4e 18 15				jr .fbset 
3e50 fe 02		.fbn1:		cp 2 
3e52 20 05				jr nz, .fbn2 
3e54 21 c1 eb				ld hl, display_fb2 
3e57 18 0c				jr .fbset 
3e59 fe 03		.fbn2:		cp 3 
3e5b 20 05				jr nz, .fbn3 
3e5d 21 62 ec				ld hl, display_fb3 
3e60 18 03				jr .fbset 
3e62			.fbn3:		 ; if invalid number select first 
3e62 21 03 ed				ld hl, display_fb1 
3e65 22 bf eb		.fbset:		ld (display_fb_active), hl 
3e68			 
3e68					FORTH_DSP_POP 
3e68 cd 8b 1d			call macro_forth_dsp_pop 
3e6b				endm 
# End of macro FORTH_DSP_POP
3e6b			 
3e6b					NEXTW 
3e6b cd 68 ee			call parse_vector 
3e6e c3 ba 1e			jp macro_next 
3e71				endm 
# End of macro NEXTW
3e71			 
3e71			 
3e71			.EMIT: 
3e71				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3e71 1b				db WORD_SYS_CORE+7             
3e72 c4 3e			dw .DOTH            
3e74 05				db 4 + 1 
3e75 .. 00			db "EMIT",0              
3e7a				endm 
# End of macro CWHEAD
3e7a			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3e7a					; get value off TOS and display it 
3e7a			 
3e7a					if DEBUG_FORTH_WORDS_KEY 
3e7a						DMARK "EMT" 
3e7a f5				push af  
3e7b 3a 8f 3e			ld a, (.dmark)  
3e7e 32 5e ee			ld (debug_mark),a  
3e81 3a 90 3e			ld a, (.dmark+1)  
3e84 32 5f ee			ld (debug_mark+1),a  
3e87 3a 91 3e			ld a, (.dmark+2)  
3e8a 32 60 ee			ld (debug_mark+2),a  
3e8d 18 03			jr .pastdmark  
3e8f ..			.dmark: db "EMT"  
3e92 f1			.pastdmark: pop af  
3e93			endm  
# End of macro DMARK
3e93						CALLMONITOR 
3e93 cd 6b ee			call debug_vector  
3e96				endm  
# End of macro CALLMONITOR
3e96					endif 
3e96			 
3e96					FORTH_DSP_VALUEHL 
3e96 cd d3 1c			call macro_dsp_valuehl 
3e99				endm 
# End of macro FORTH_DSP_VALUEHL
3e99			 
3e99 7d					ld a,l 
3e9a			 
3e9a					; TODO write to display 
3e9a			 
3e9a 32 b2 e4				ld (os_input), a 
3e9d 3e 00				ld a, 0 
3e9f 32 b3 e4				ld (os_input+1), a 
3ea2					 
3ea2 3a 51 ea				ld a, (f_cursor_ptr) 
3ea5 11 b2 e4				ld de, os_input 
3ea8 cd ce 0b				call str_at_display 
3eab			 
3eab			 
3eab 3a 2f ea				ld a,(cli_autodisplay) 
3eae			;		cp 0 
3eae b7					or a 
3eaf 28 03				jr z, .enoupdate 
3eb1 cd de 0b						call update_display 
3eb4					.enoupdate: 
3eb4			 
3eb4 3a 51 ea				ld a, (f_cursor_ptr) 
3eb7 3c					inc a 
3eb8 32 51 ea				ld (f_cursor_ptr), a   ; save new pos 
3ebb			 
3ebb			 
3ebb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ebb cd 8b 1d			call macro_forth_dsp_pop 
3ebe				endm 
# End of macro FORTH_DSP_POP
3ebe			  
3ebe			 
3ebe					NEXTW 
3ebe cd 68 ee			call parse_vector 
3ec1 c3 ba 1e			jp macro_next 
3ec4				endm 
# End of macro NEXTW
3ec4			.DOTH: 
3ec4				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3ec4 1c				db WORD_SYS_CORE+8             
3ec5 f7 3e			dw .DOTF            
3ec7 03				db 2 + 1 
3ec8 .. 00			db ".-",0              
3ecb				endm 
# End of macro CWHEAD
3ecb			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3ecb					; get value off TOS and display it 
3ecb					if DEBUG_FORTH_WORDS_KEY 
3ecb						DMARK "DTD" 
3ecb f5				push af  
3ecc 3a e0 3e			ld a, (.dmark)  
3ecf 32 5e ee			ld (debug_mark),a  
3ed2 3a e1 3e			ld a, (.dmark+1)  
3ed5 32 5f ee			ld (debug_mark+1),a  
3ed8 3a e2 3e			ld a, (.dmark+2)  
3edb 32 60 ee			ld (debug_mark+2),a  
3ede 18 03			jr .pastdmark  
3ee0 ..			.dmark: db "DTD"  
3ee3 f1			.pastdmark: pop af  
3ee4			endm  
# End of macro DMARK
3ee4						CALLMONITOR 
3ee4 cd 6b ee			call debug_vector  
3ee7				endm  
# End of macro CALLMONITOR
3ee7					endif 
3ee7 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3ee9 3e 00			ld a, 0 
3eeb 32 30 ea			ld (cli_mvdot), a 
3eee c3 51 3f			jp .dotgo 
3ef1				NEXTW 
3ef1 cd 68 ee			call parse_vector 
3ef4 c3 ba 1e			jp macro_next 
3ef7				endm 
# End of macro NEXTW
3ef7			.DOTF: 
3ef7				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3ef7 1c				db WORD_SYS_CORE+8             
3ef8 28 3f			dw .DOT            
3efa 03				db 2 + 1 
3efb .. 00			db ".>",0              
3efe				endm 
# End of macro CWHEAD
3efe			        ; | .> ( u -- ) Display TOS and move the next display point with display  | DONE 
3efe					; get value off TOS and display it 
3efe			        ; TODO BUG adds extra spaces 
3efe			        ; TODO BUG handle numerics? 
3efe					if DEBUG_FORTH_WORDS_KEY 
3efe						DMARK "DTC" 
3efe f5				push af  
3eff 3a 13 3f			ld a, (.dmark)  
3f02 32 5e ee			ld (debug_mark),a  
3f05 3a 14 3f			ld a, (.dmark+1)  
3f08 32 5f ee			ld (debug_mark+1),a  
3f0b 3a 15 3f			ld a, (.dmark+2)  
3f0e 32 60 ee			ld (debug_mark+2),a  
3f11 18 03			jr .pastdmark  
3f13 ..			.dmark: db "DTC"  
3f16 f1			.pastdmark: pop af  
3f17			endm  
# End of macro DMARK
3f17						CALLMONITOR 
3f17 cd 6b ee			call debug_vector  
3f1a				endm  
# End of macro CALLMONITOR
3f1a					endif 
3f1a 3e 01			ld a, 1 
3f1c 32 30 ea			ld (cli_mvdot), a 
3f1f c3 51 3f			jp .dotgo 
3f22				NEXTW 
3f22 cd 68 ee			call parse_vector 
3f25 c3 ba 1e			jp macro_next 
3f28				endm 
# End of macro NEXTW
3f28			 
3f28			.DOT: 
3f28				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3f28 1c				db WORD_SYS_CORE+8             
3f29 03 41			dw .CLS            
3f2b 02				db 1 + 1 
3f2c .. 00			db ".",0              
3f2e				endm 
# End of macro CWHEAD
3f2e			        ; | . ( u -- ) Display TOS. Does not move next print position. Use .> if you want that. | DONE 
3f2e					; get value off TOS and display it 
3f2e			 
3f2e					if DEBUG_FORTH_WORDS_KEY 
3f2e						DMARK "DOT" 
3f2e f5				push af  
3f2f 3a 43 3f			ld a, (.dmark)  
3f32 32 5e ee			ld (debug_mark),a  
3f35 3a 44 3f			ld a, (.dmark+1)  
3f38 32 5f ee			ld (debug_mark+1),a  
3f3b 3a 45 3f			ld a, (.dmark+2)  
3f3e 32 60 ee			ld (debug_mark+2),a  
3f41 18 03			jr .pastdmark  
3f43 ..			.dmark: db "DOT"  
3f46 f1			.pastdmark: pop af  
3f47			endm  
# End of macro DMARK
3f47						CALLMONITOR 
3f47 cd 6b ee			call debug_vector  
3f4a				endm  
# End of macro CALLMONITOR
3f4a					endif 
3f4a 3e 00			ld a, 0 
3f4c 32 30 ea			ld (cli_mvdot), a 
3f4f 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3f51				 
3f51			 
3f51			.dotgo: 
3f51			 
3f51			; move up type to on stack for parserv5 
3f51					FORTH_DSP 
3f51 cd 99 1c			call macro_forth_dsp 
3f54				endm 
# End of macro FORTH_DSP
3f54				;FORTH_DSP_VALUE  
3f54			 
3f54			if DEBUG_FORTH_DOT 
3f54				DMARK "DOT" 
3f54 f5				push af  
3f55 3a 69 3f			ld a, (.dmark)  
3f58 32 5e ee			ld (debug_mark),a  
3f5b 3a 6a 3f			ld a, (.dmark+1)  
3f5e 32 5f ee			ld (debug_mark+1),a  
3f61 3a 6b 3f			ld a, (.dmark+2)  
3f64 32 60 ee			ld (debug_mark+2),a  
3f67 18 03			jr .pastdmark  
3f69 ..			.dmark: db "DOT"  
3f6c f1			.pastdmark: pop af  
3f6d			endm  
# End of macro DMARK
3f6d				CALLMONITOR 
3f6d cd 6b ee			call debug_vector  
3f70				endm  
# End of macro CALLMONITOR
3f70			endif	 
3f70			;		.print: 
3f70			 
3f70 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3f71 23				inc hl   ; position to the actual value 
3f72 fe 01			cp DS_TYPE_STR 
3f74 20 06			jr nz, .dotnum1  
3f76			 
3f76			; display string 
3f76				FORTH_DSP_VALUE  
3f76 cd bc 1c			call macro_forth_dsp_value 
3f79				endm 
# End of macro FORTH_DSP_VALUE
3f79 eb				ex de,hl 
3f7a 18 49			jr .dotwrite 
3f7c			 
3f7c			.dotnum1: 
3f7c fe 02			cp DS_TYPE_INUM 
3f7e 20 44			jr nz, .dotflot 
3f80			 
3f80			 
3f80			; display number 
3f80			 
3f80			;	push hl 
3f80			;	call clear_display 
3f80			;	pop hl 
3f80			 
3f80 5e				ld e, (hl) 
3f81 23				inc hl 
3f82 56				ld d, (hl) 
3f83 21 b4 e2			ld hl, scratch 
3f86			if DEBUG_FORTH_DOT 
3f86				DMARK "DT1" 
3f86 f5				push af  
3f87 3a 9b 3f			ld a, (.dmark)  
3f8a 32 5e ee			ld (debug_mark),a  
3f8d 3a 9c 3f			ld a, (.dmark+1)  
3f90 32 5f ee			ld (debug_mark+1),a  
3f93 3a 9d 3f			ld a, (.dmark+2)  
3f96 32 60 ee			ld (debug_mark+2),a  
3f99 18 03			jr .pastdmark  
3f9b ..			.dmark: db "DT1"  
3f9e f1			.pastdmark: pop af  
3f9f			endm  
# End of macro DMARK
3f9f				CALLMONITOR 
3f9f cd 6b ee			call debug_vector  
3fa2				endm  
# End of macro CALLMONITOR
3fa2			endif	 
3fa2			 
3fa2 cd ed 10			call uitoa_16 
3fa5 eb				ex de,hl 
3fa6			 
3fa6			if DEBUG_FORTH_DOT 
3fa6				DMARK "DT2" 
3fa6 f5				push af  
3fa7 3a bb 3f			ld a, (.dmark)  
3faa 32 5e ee			ld (debug_mark),a  
3fad 3a bc 3f			ld a, (.dmark+1)  
3fb0 32 5f ee			ld (debug_mark+1),a  
3fb3 3a bd 3f			ld a, (.dmark+2)  
3fb6 32 60 ee			ld (debug_mark+2),a  
3fb9 18 03			jr .pastdmark  
3fbb ..			.dmark: db "DT2"  
3fbe f1			.pastdmark: pop af  
3fbf			endm  
# End of macro DMARK
3fbf				CALLMONITOR 
3fbf cd 6b ee			call debug_vector  
3fc2				endm  
# End of macro CALLMONITOR
3fc2			endif	 
3fc2			 
3fc2			;	ld de, os_word_scratch 
3fc2 18 01			jr .dotwrite 
3fc4			 
3fc4 00			.dotflot:   nop 
3fc5			; TODO print floating point number 
3fc5			 
3fc5			.dotwrite:		 
3fc5			 
3fc5					; if c is set then set all '-' to spaces 
3fc5					; need to also take into account .>  
3fc5			 
3fc5 3e 01				ld a, 1 
3fc7 b9					cp c 
3fc8 20 65				jr nz, .nodashswap 
3fca			 
3fca					; DE has the string to write, working with HL 
3fca			 
3fca 06 ff				ld b, 255 
3fcc d5					push de 
3fcd e1					pop hl 
3fce			 
3fce			if DEBUG_FORTH_DOT 
3fce				DMARK "DT-" 
3fce f5				push af  
3fcf 3a e3 3f			ld a, (.dmark)  
3fd2 32 5e ee			ld (debug_mark),a  
3fd5 3a e4 3f			ld a, (.dmark+1)  
3fd8 32 5f ee			ld (debug_mark+1),a  
3fdb 3a e5 3f			ld a, (.dmark+2)  
3fde 32 60 ee			ld (debug_mark+2),a  
3fe1 18 03			jr .pastdmark  
3fe3 ..			.dmark: db "DT-"  
3fe6 f1			.pastdmark: pop af  
3fe7			endm  
# End of macro DMARK
3fe7				CALLMONITOR 
3fe7 cd 6b ee			call debug_vector  
3fea				endm  
# End of macro CALLMONITOR
3fea			endif	 
3fea 7e			.dashscan:	ld a, (hl) 
3feb			;		cp 0 
3feb b7					or a 
3fec 28 41				jr z, .nodashswap 
3fee fe 2d				cp '-' 
3ff0 20 02				jr nz, .dashskip 
3ff2			;		ld a, ' ' 
3ff2 36 20				ld (hl), ' ' 
3ff4 23			.dashskip:	inc hl 
3ff5			if DEBUG_FORTH_DOT 
3ff5				DMARK "D-2" 
3ff5 f5				push af  
3ff6 3a 0a 40			ld a, (.dmark)  
3ff9 32 5e ee			ld (debug_mark),a  
3ffc 3a 0b 40			ld a, (.dmark+1)  
3fff 32 5f ee			ld (debug_mark+1),a  
4002 3a 0c 40			ld a, (.dmark+2)  
4005 32 60 ee			ld (debug_mark+2),a  
4008 18 03			jr .pastdmark  
400a ..			.dmark: db "D-2"  
400d f1			.pastdmark: pop af  
400e			endm  
# End of macro DMARK
400e				CALLMONITOR 
400e cd 6b ee			call debug_vector  
4011				endm  
# End of macro CALLMONITOR
4011			endif	 
4011 10 d7				djnz .dashscan 
4013			 
4013			if DEBUG_FORTH_DOT 
4013				DMARK "D-1" 
4013 f5				push af  
4014 3a 28 40			ld a, (.dmark)  
4017 32 5e ee			ld (debug_mark),a  
401a 3a 29 40			ld a, (.dmark+1)  
401d 32 5f ee			ld (debug_mark+1),a  
4020 3a 2a 40			ld a, (.dmark+2)  
4023 32 60 ee			ld (debug_mark+2),a  
4026 18 03			jr .pastdmark  
4028 ..			.dmark: db "D-1"  
402b f1			.pastdmark: pop af  
402c			endm  
# End of macro DMARK
402c				CALLMONITOR 
402c cd 6b ee			call debug_vector  
402f				endm  
# End of macro CALLMONITOR
402f			endif	 
402f			 
402f			.nodashswap: 
402f			 
402f			if DEBUG_FORTH_DOT 
402f				DMARK "D-o" 
402f f5				push af  
4030 3a 44 40			ld a, (.dmark)  
4033 32 5e ee			ld (debug_mark),a  
4036 3a 45 40			ld a, (.dmark+1)  
4039 32 5f ee			ld (debug_mark+1),a  
403c 3a 46 40			ld a, (.dmark+2)  
403f 32 60 ee			ld (debug_mark+2),a  
4042 18 03			jr .pastdmark  
4044 ..			.dmark: db "D-o"  
4047 f1			.pastdmark: pop af  
4048			endm  
# End of macro DMARK
4048				CALLMONITOR 
4048 cd 6b ee			call debug_vector  
404b				endm  
# End of macro CALLMONITOR
404b			endif	 
404b			 
404b d5					push de   ; save string start in case we need to advance print 
404c			 
404c 3a 51 ea				ld a, (f_cursor_ptr) 
404f cd ce 0b				call str_at_display 
4052 3a 2f ea				ld a,(cli_autodisplay) 
4055			;		cp 0 
4055 b7					or a 
4056 28 03				jr z, .noupdate 
4058 cd de 0b						call update_display 
405b					.noupdate: 
405b			 
405b			 
405b					; see if we need to advance the print position 
405b			 
405b e1					pop hl   ; get back string 
405c			;		ex de,hl 
405c			 
405c 3a 30 ea				ld a, (cli_mvdot) 
405f			if DEBUG_FORTH_DOT 
405f			;		ld e,a 
405f				DMARK "D>1" 
405f f5				push af  
4060 3a 74 40			ld a, (.dmark)  
4063 32 5e ee			ld (debug_mark),a  
4066 3a 75 40			ld a, (.dmark+1)  
4069 32 5f ee			ld (debug_mark+1),a  
406c 3a 76 40			ld a, (.dmark+2)  
406f 32 60 ee			ld (debug_mark+2),a  
4072 18 03			jr .pastdmark  
4074 ..			.dmark: db "D>1"  
4077 f1			.pastdmark: pop af  
4078			endm  
# End of macro DMARK
4078				CALLMONITOR 
4078 cd 6b ee			call debug_vector  
407b				endm  
# End of macro CALLMONITOR
407b			endif	 
407b			;		cp 0 
407b b7					or a 
407c 28 44				jr z, .noadv 
407e					; yes, lets advance the print position 
407e 3e 00				ld a, 0 
4080 cd 49 11				call strlent 
4083			if DEBUG_FORTH_DOT 
4083				DMARK "D-?" 
4083 f5				push af  
4084 3a 98 40			ld a, (.dmark)  
4087 32 5e ee			ld (debug_mark),a  
408a 3a 99 40			ld a, (.dmark+1)  
408d 32 5f ee			ld (debug_mark+1),a  
4090 3a 9a 40			ld a, (.dmark+2)  
4093 32 60 ee			ld (debug_mark+2),a  
4096 18 03			jr .pastdmark  
4098 ..			.dmark: db "D-?"  
409b f1			.pastdmark: pop af  
409c			endm  
# End of macro DMARK
409c				CALLMONITOR 
409c cd 6b ee			call debug_vector  
409f				endm  
# End of macro CALLMONITOR
409f			endif	 
409f 3a 51 ea				ld a, (f_cursor_ptr) 
40a2 85					add a,l 
40a3					;call addatohl 
40a3					;ld a, l 
40a3 32 51 ea				ld (f_cursor_ptr), a   ; save new pos 
40a6			 
40a6			if DEBUG_FORTH_DOT 
40a6				DMARK "D->" 
40a6 f5				push af  
40a7 3a bb 40			ld a, (.dmark)  
40aa 32 5e ee			ld (debug_mark),a  
40ad 3a bc 40			ld a, (.dmark+1)  
40b0 32 5f ee			ld (debug_mark+1),a  
40b3 3a bd 40			ld a, (.dmark+2)  
40b6 32 60 ee			ld (debug_mark+2),a  
40b9 18 03			jr .pastdmark  
40bb ..			.dmark: db "D->"  
40be f1			.pastdmark: pop af  
40bf			endm  
# End of macro DMARK
40bf				CALLMONITOR 
40bf cd 6b ee			call debug_vector  
40c2				endm  
# End of macro CALLMONITOR
40c2			endif	 
40c2			 
40c2			.noadv:	 
40c2			 
40c2					if DEBUG_FORTH_DOT_WAIT 
40c2							call next_page_prompt 
40c2					endif	 
40c2			; TODO this pop off the stack causes a crash. i dont know why 
40c2			 
40c2			 
40c2			if DEBUG_FORTH_DOT 
40c2				DMARK "DTh" 
40c2 f5				push af  
40c3 3a d7 40			ld a, (.dmark)  
40c6 32 5e ee			ld (debug_mark),a  
40c9 3a d8 40			ld a, (.dmark+1)  
40cc 32 5f ee			ld (debug_mark+1),a  
40cf 3a d9 40			ld a, (.dmark+2)  
40d2 32 60 ee			ld (debug_mark+2),a  
40d5 18 03			jr .pastdmark  
40d7 ..			.dmark: db "DTh"  
40da f1			.pastdmark: pop af  
40db			endm  
# End of macro DMARK
40db				CALLMONITOR 
40db cd 6b ee			call debug_vector  
40de				endm  
# End of macro CALLMONITOR
40de			endif	 
40de			 
40de					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40de cd 8b 1d			call macro_forth_dsp_pop 
40e1				endm 
# End of macro FORTH_DSP_POP
40e1			 
40e1			if DEBUG_FORTH_DOT 
40e1				DMARK "DTi" 
40e1 f5				push af  
40e2 3a f6 40			ld a, (.dmark)  
40e5 32 5e ee			ld (debug_mark),a  
40e8 3a f7 40			ld a, (.dmark+1)  
40eb 32 5f ee			ld (debug_mark+1),a  
40ee 3a f8 40			ld a, (.dmark+2)  
40f1 32 60 ee			ld (debug_mark+2),a  
40f4 18 03			jr .pastdmark  
40f6 ..			.dmark: db "DTi"  
40f9 f1			.pastdmark: pop af  
40fa			endm  
# End of macro DMARK
40fa				CALLMONITOR 
40fa cd 6b ee			call debug_vector  
40fd				endm  
# End of macro CALLMONITOR
40fd			endif	 
40fd			 
40fd			 
40fd					NEXTW 
40fd cd 68 ee			call parse_vector 
4100 c3 ba 1e			jp macro_next 
4103				endm 
# End of macro NEXTW
4103			 
4103			.CLS: 
4103				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
4103 35				db WORD_SYS_CORE+33             
4104 33 41			dw .DRAW            
4106 04				db 3 + 1 
4107 .. 00			db "CLS",0              
410b				endm 
# End of macro CWHEAD
410b			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
410b					if DEBUG_FORTH_WORDS_KEY 
410b						DMARK "CLS" 
410b f5				push af  
410c 3a 20 41			ld a, (.dmark)  
410f 32 5e ee			ld (debug_mark),a  
4112 3a 21 41			ld a, (.dmark+1)  
4115 32 5f ee			ld (debug_mark+1),a  
4118 3a 22 41			ld a, (.dmark+2)  
411b 32 60 ee			ld (debug_mark+2),a  
411e 18 03			jr .pastdmark  
4120 ..			.dmark: db "CLS"  
4123 f1			.pastdmark: pop af  
4124			endm  
# End of macro DMARK
4124						CALLMONITOR 
4124 cd 6b ee			call debug_vector  
4127				endm  
# End of macro CALLMONITOR
4127					endif 
4127 cd bc 0b				call clear_display 
412a c3 4d 42				jp .home		; and home cursor 
412d					NEXTW 
412d cd 68 ee			call parse_vector 
4130 c3 ba 1e			jp macro_next 
4133				endm 
# End of macro NEXTW
4133			 
4133			.DRAW: 
4133				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
4133 36				db WORD_SYS_CORE+34             
4134 61 41			dw .DUMP            
4136 05				db 4 + 1 
4137 .. 00			db "DRAW",0              
413c				endm 
# End of macro CWHEAD
413c			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
413c					if DEBUG_FORTH_WORDS_KEY 
413c						DMARK "DRW" 
413c f5				push af  
413d 3a 51 41			ld a, (.dmark)  
4140 32 5e ee			ld (debug_mark),a  
4143 3a 52 41			ld a, (.dmark+1)  
4146 32 5f ee			ld (debug_mark+1),a  
4149 3a 53 41			ld a, (.dmark+2)  
414c 32 60 ee			ld (debug_mark+2),a  
414f 18 03			jr .pastdmark  
4151 ..			.dmark: db "DRW"  
4154 f1			.pastdmark: pop af  
4155			endm  
# End of macro DMARK
4155						CALLMONITOR 
4155 cd 6b ee			call debug_vector  
4158				endm  
# End of macro CALLMONITOR
4158					endif 
4158 cd de 0b				call update_display 
415b					NEXTW 
415b cd 68 ee			call parse_vector 
415e c3 ba 1e			jp macro_next 
4161				endm 
# End of macro NEXTW
4161			 
4161			.DUMP: 
4161				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
4161 37				db WORD_SYS_CORE+35             
4162 9c 41			dw .CDUMP            
4164 05				db 4 + 1 
4165 .. 00			db "DUMP",0              
416a				endm 
# End of macro CWHEAD
416a			; | DUMP ( x -- ) With address x display dump   | DONE 
416a			; TODO pop address to use off of the stack 
416a					if DEBUG_FORTH_WORDS_KEY 
416a						DMARK "DUM" 
416a f5				push af  
416b 3a 7f 41			ld a, (.dmark)  
416e 32 5e ee			ld (debug_mark),a  
4171 3a 80 41			ld a, (.dmark+1)  
4174 32 5f ee			ld (debug_mark+1),a  
4177 3a 81 41			ld a, (.dmark+2)  
417a 32 60 ee			ld (debug_mark+2),a  
417d 18 03			jr .pastdmark  
417f ..			.dmark: db "DUM"  
4182 f1			.pastdmark: pop af  
4183			endm  
# End of macro DMARK
4183						CALLMONITOR 
4183 cd 6b ee			call debug_vector  
4186				endm  
# End of macro CALLMONITOR
4186					endif 
4186 cd bc 0b				call clear_display 
4189			 
4189					; get address 
4189			 
4189					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4189 cd d3 1c			call macro_dsp_valuehl 
418c				endm 
# End of macro FORTH_DSP_VALUEHL
418c				 
418c					; save it for cdump 
418c			 
418c 22 d7 e5				ld (os_cur_ptr),hl 
418f			 
418f					; destroy value TOS 
418f			 
418f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
418f cd 8b 1d			call macro_forth_dsp_pop 
4192				endm 
# End of macro FORTH_DSP_POP
4192			 
4192 cd 5b 19				call dumpcont	; skip old style of param parsing	 
4195 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
4196					NEXTW 
4196 cd 68 ee			call parse_vector 
4199 c3 ba 1e			jp macro_next 
419c				endm 
# End of macro NEXTW
419c			.CDUMP: 
419c				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
419c 38				db WORD_SYS_CORE+36             
419d cf 41			dw .DAT            
419f 06				db 5 + 1 
41a0 .. 00			db "CDUMP",0              
41a6				endm 
# End of macro CWHEAD
41a6			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
41a6					if DEBUG_FORTH_WORDS_KEY 
41a6						DMARK "CDP" 
41a6 f5				push af  
41a7 3a bb 41			ld a, (.dmark)  
41aa 32 5e ee			ld (debug_mark),a  
41ad 3a bc 41			ld a, (.dmark+1)  
41b0 32 5f ee			ld (debug_mark+1),a  
41b3 3a bd 41			ld a, (.dmark+2)  
41b6 32 60 ee			ld (debug_mark+2),a  
41b9 18 03			jr .pastdmark  
41bb ..			.dmark: db "CDP"  
41be f1			.pastdmark: pop af  
41bf			endm  
# End of macro DMARK
41bf						CALLMONITOR 
41bf cd 6b ee			call debug_vector  
41c2				endm  
# End of macro CALLMONITOR
41c2					endif 
41c2 cd bc 0b				call clear_display 
41c5 cd 5b 19				call dumpcont	 
41c8 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
41c9					NEXTW 
41c9 cd 68 ee			call parse_vector 
41cc c3 ba 1e			jp macro_next 
41cf				endm 
# End of macro NEXTW
41cf			 
41cf			 
41cf			 
41cf			 
41cf			.DAT: 
41cf				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
41cf 3d				db WORD_SYS_CORE+41             
41d0 28 42			dw .HOME            
41d2 03				db 2 + 1 
41d3 .. 00			db "AT",0              
41d6				endm 
# End of macro CWHEAD
41d6			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
41d6					if DEBUG_FORTH_WORDS_KEY 
41d6						DMARK "AT." 
41d6 f5				push af  
41d7 3a eb 41			ld a, (.dmark)  
41da 32 5e ee			ld (debug_mark),a  
41dd 3a ec 41			ld a, (.dmark+1)  
41e0 32 5f ee			ld (debug_mark+1),a  
41e3 3a ed 41			ld a, (.dmark+2)  
41e6 32 60 ee			ld (debug_mark+2),a  
41e9 18 03			jr .pastdmark  
41eb ..			.dmark: db "AT."  
41ee f1			.pastdmark: pop af  
41ef			endm  
# End of macro DMARK
41ef						CALLMONITOR 
41ef cd 6b ee			call debug_vector  
41f2				endm  
# End of macro CALLMONITOR
41f2					endif 
41f2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
41f2 cd d3 1c			call macro_dsp_valuehl 
41f5				endm 
# End of macro FORTH_DSP_VALUEHL
41f5			 
41f5			 
41f5					; TODO save cursor row 
41f5 7d					ld a,l 
41f6 fe 02				cp 2 
41f8 20 04				jr nz, .crow3 
41fa 3e 28				ld a, display_row_2 
41fc 18 12				jr .ccol1 
41fe fe 03		.crow3:		cp 3 
4200 20 04				jr nz, .crow4 
4202 3e 50				ld a, display_row_3 
4204 18 0a				jr .ccol1 
4206 fe 04		.crow4:		cp 4 
4208 20 04				jr nz, .crow1 
420a 3e 78				ld a, display_row_4 
420c 18 02				jr .ccol1 
420e 3e 00		.crow1:		ld a,display_row_1 
4210 f5			.ccol1:		push af			; got row offset 
4211 6f					ld l,a 
4212 26 00				ld h,0 
4214					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4214 cd 8b 1d			call macro_forth_dsp_pop 
4217				endm 
# End of macro FORTH_DSP_POP
4217					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4217 cd d3 1c			call macro_dsp_valuehl 
421a				endm 
# End of macro FORTH_DSP_VALUEHL
421a					; TODO save cursor col 
421a f1					pop af 
421b 85					add l		; add col offset 
421c 32 51 ea				ld (f_cursor_ptr), a 
421f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
421f cd 8b 1d			call macro_forth_dsp_pop 
4222				endm 
# End of macro FORTH_DSP_POP
4222			 
4222					; calculate  
4222			 
4222					NEXTW 
4222 cd 68 ee			call parse_vector 
4225 c3 ba 1e			jp macro_next 
4228				endm 
# End of macro NEXTW
4228			 
4228			 
4228			.HOME: 
4228				CWHEAD .CR 45 "HOME" 4 WORD_FLAG_CODE 
4228 41				db WORD_SYS_CORE+45             
4229 58 42			dw .CR            
422b 05				db 4 + 1 
422c .. 00			db "HOME",0              
4231				endm 
# End of macro CWHEAD
4231			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
4231					if DEBUG_FORTH_WORDS_KEY 
4231						DMARK "HOM" 
4231 f5				push af  
4232 3a 46 42			ld a, (.dmark)  
4235 32 5e ee			ld (debug_mark),a  
4238 3a 47 42			ld a, (.dmark+1)  
423b 32 5f ee			ld (debug_mark+1),a  
423e 3a 48 42			ld a, (.dmark+2)  
4241 32 60 ee			ld (debug_mark+2),a  
4244 18 03			jr .pastdmark  
4246 ..			.dmark: db "HOM"  
4249 f1			.pastdmark: pop af  
424a			endm  
# End of macro DMARK
424a						CALLMONITOR 
424a cd 6b ee			call debug_vector  
424d				endm  
# End of macro CALLMONITOR
424d					endif 
424d 3e 00		.home:		ld a, 0		; and home cursor 
424f 32 51 ea				ld (f_cursor_ptr), a 
4252					NEXTW 
4252 cd 68 ee			call parse_vector 
4255 c3 ba 1e			jp macro_next 
4258				endm 
# End of macro NEXTW
4258			 
4258			 
4258			.CR: 
4258				CWHEAD .SPACE 50 "CR" 2 WORD_FLAG_CODE 
4258 46				db WORD_SYS_CORE+50             
4259 96 42			dw .SPACE            
425b 03				db 2 + 1 
425c .. 00			db "CR",0              
425f				endm 
# End of macro CWHEAD
425f			; | CR (  -- s ) Push CR/LF pair onto the stack as a string  | DONE 
425f					if DEBUG_FORTH_WORDS_KEY 
425f						DMARK "CR." 
425f f5				push af  
4260 3a 74 42			ld a, (.dmark)  
4263 32 5e ee			ld (debug_mark),a  
4266 3a 75 42			ld a, (.dmark+1)  
4269 32 5f ee			ld (debug_mark+1),a  
426c 3a 76 42			ld a, (.dmark+2)  
426f 32 60 ee			ld (debug_mark+2),a  
4272 18 03			jr .pastdmark  
4274 ..			.dmark: db "CR."  
4277 f1			.pastdmark: pop af  
4278			endm  
# End of macro DMARK
4278						CALLMONITOR 
4278 cd 6b ee			call debug_vector  
427b				endm  
# End of macro CALLMONITOR
427b					endif 
427b 3e 0d				ld a, 13 
427d 32 b4 e2				ld (scratch),a 
4280 3e 0a				ld a, 10 
4282 32 b5 e2				ld (scratch+1),a 
4285 3e 00				ld a, 0 
4287 32 b6 e2				ld (scratch+2),a 
428a 21 b4 e2				ld hl, scratch 
428d cd 41 1b				call forth_push_str 
4290					 
4290				       NEXTW 
4290 cd 68 ee			call parse_vector 
4293 c3 ba 1e			jp macro_next 
4296				endm 
# End of macro NEXTW
4296			.SPACE: 
4296				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
4296 46				db WORD_SYS_CORE+50             
4297 cf 42			dw .SPACES            
4299 03				db 2 + 1 
429a .. 00			db "BL",0              
429d				endm 
# End of macro CWHEAD
429d			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
429d					if DEBUG_FORTH_WORDS_KEY 
429d						DMARK "BL." 
429d f5				push af  
429e 3a b2 42			ld a, (.dmark)  
42a1 32 5e ee			ld (debug_mark),a  
42a4 3a b3 42			ld a, (.dmark+1)  
42a7 32 5f ee			ld (debug_mark+1),a  
42aa 3a b4 42			ld a, (.dmark+2)  
42ad 32 60 ee			ld (debug_mark+2),a  
42b0 18 03			jr .pastdmark  
42b2 ..			.dmark: db "BL."  
42b5 f1			.pastdmark: pop af  
42b6			endm  
# End of macro DMARK
42b6						CALLMONITOR 
42b6 cd 6b ee			call debug_vector  
42b9				endm  
# End of macro CALLMONITOR
42b9					endif 
42b9 3e 20				ld a, " " 
42bb 32 b4 e2				ld (scratch),a 
42be 3e 00				ld a, 0 
42c0 32 b5 e2				ld (scratch+1),a 
42c3 21 b4 e2				ld hl, scratch 
42c6 cd 41 1b				call forth_push_str 
42c9					 
42c9				       NEXTW 
42c9 cd 68 ee			call parse_vector 
42cc c3 ba 1e			jp macro_next 
42cf				endm 
# End of macro NEXTW
42cf			 
42cf			;.blstr: db " ", 0 
42cf			 
42cf			.SPACES: 
42cf				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
42cf 47				db WORD_SYS_CORE+51             
42d0 6b 43			dw .SCROLL            
42d2 07				db 6 + 1 
42d3 .. 00			db "SPACES",0              
42da				endm 
# End of macro CWHEAD
42da			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
42da					if DEBUG_FORTH_WORDS_KEY 
42da						DMARK "SPS" 
42da f5				push af  
42db 3a ef 42			ld a, (.dmark)  
42de 32 5e ee			ld (debug_mark),a  
42e1 3a f0 42			ld a, (.dmark+1)  
42e4 32 5f ee			ld (debug_mark+1),a  
42e7 3a f1 42			ld a, (.dmark+2)  
42ea 32 60 ee			ld (debug_mark+2),a  
42ed 18 03			jr .pastdmark  
42ef ..			.dmark: db "SPS"  
42f2 f1			.pastdmark: pop af  
42f3			endm  
# End of macro DMARK
42f3						CALLMONITOR 
42f3 cd 6b ee			call debug_vector  
42f6				endm  
# End of macro CALLMONITOR
42f6					endif 
42f6			 
42f6			 
42f6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
42f6 cd d3 1c			call macro_dsp_valuehl 
42f9				endm 
# End of macro FORTH_DSP_VALUEHL
42f9			 
42f9 e5					push hl    ; u 
42fa					if DEBUG_FORTH_WORDS 
42fa						DMARK "SPA" 
42fa f5				push af  
42fb 3a 0f 43			ld a, (.dmark)  
42fe 32 5e ee			ld (debug_mark),a  
4301 3a 10 43			ld a, (.dmark+1)  
4304 32 5f ee			ld (debug_mark+1),a  
4307 3a 11 43			ld a, (.dmark+2)  
430a 32 60 ee			ld (debug_mark+2),a  
430d 18 03			jr .pastdmark  
430f ..			.dmark: db "SPA"  
4312 f1			.pastdmark: pop af  
4313			endm  
# End of macro DMARK
4313						CALLMONITOR 
4313 cd 6b ee			call debug_vector  
4316				endm  
# End of macro CALLMONITOR
4316					endif 
4316			 
4316					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4316 cd 8b 1d			call macro_forth_dsp_pop 
4319				endm 
# End of macro FORTH_DSP_POP
4319 e1					pop hl 
431a 0e 00				ld c, 0 
431c 45					ld b, l 
431d 21 b4 e2				ld hl, scratch  
4320			 
4320					if DEBUG_FORTH_WORDS 
4320						DMARK "SP2" 
4320 f5				push af  
4321 3a 35 43			ld a, (.dmark)  
4324 32 5e ee			ld (debug_mark),a  
4327 3a 36 43			ld a, (.dmark+1)  
432a 32 5f ee			ld (debug_mark+1),a  
432d 3a 37 43			ld a, (.dmark+2)  
4330 32 60 ee			ld (debug_mark+2),a  
4333 18 03			jr .pastdmark  
4335 ..			.dmark: db "SP2"  
4338 f1			.pastdmark: pop af  
4339			endm  
# End of macro DMARK
4339						CALLMONITOR 
4339 cd 6b ee			call debug_vector  
433c				endm  
# End of macro CALLMONITOR
433c					endif 
433c			;		ld a, ' ' 
433c			.spaces1:	 
433c 36 20				ld (hl),' ' 
433e 23					inc hl 
433f					 
433f 10 fb				djnz .spaces1 
4341			;		ld a,0 
4341 36 00				ld (hl),0 
4343 21 b4 e2				ld hl, scratch 
4346					if DEBUG_FORTH_WORDS 
4346						DMARK "SP3" 
4346 f5				push af  
4347 3a 5b 43			ld a, (.dmark)  
434a 32 5e ee			ld (debug_mark),a  
434d 3a 5c 43			ld a, (.dmark+1)  
4350 32 5f ee			ld (debug_mark+1),a  
4353 3a 5d 43			ld a, (.dmark+2)  
4356 32 60 ee			ld (debug_mark+2),a  
4359 18 03			jr .pastdmark  
435b ..			.dmark: db "SP3"  
435e f1			.pastdmark: pop af  
435f			endm  
# End of macro DMARK
435f						CALLMONITOR 
435f cd 6b ee			call debug_vector  
4362				endm  
# End of macro CALLMONITOR
4362					endif 
4362 cd 41 1b				call forth_push_str 
4365			 
4365				       NEXTW 
4365 cd 68 ee			call parse_vector 
4368 c3 ba 1e			jp macro_next 
436b				endm 
# End of macro NEXTW
436b			 
436b			 
436b			 
436b			.SCROLL: 
436b				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
436b 53				db WORD_SYS_CORE+63             
436c 9b 43			dw .SCROLLD            
436e 07				db 6 + 1 
436f .. 00			db "SCROLL",0              
4376				endm 
# End of macro CWHEAD
4376			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
4376					if DEBUG_FORTH_WORDS_KEY 
4376						DMARK "SCR" 
4376 f5				push af  
4377 3a 8b 43			ld a, (.dmark)  
437a 32 5e ee			ld (debug_mark),a  
437d 3a 8c 43			ld a, (.dmark+1)  
4380 32 5f ee			ld (debug_mark+1),a  
4383 3a 8d 43			ld a, (.dmark+2)  
4386 32 60 ee			ld (debug_mark+2),a  
4389 18 03			jr .pastdmark  
438b ..			.dmark: db "SCR"  
438e f1			.pastdmark: pop af  
438f			endm  
# End of macro DMARK
438f						CALLMONITOR 
438f cd 6b ee			call debug_vector  
4392				endm  
# End of macro CALLMONITOR
4392					endif 
4392			 
4392 cd 7f 0b			call scroll_up 
4395			;	call update_display 
4395			 
4395					NEXTW 
4395 cd 68 ee			call parse_vector 
4398 c3 ba 1e			jp macro_next 
439b				endm 
# End of macro NEXTW
439b			 
439b			 
439b			 
439b			;		; get dir 
439b			; 
439b			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
439b			; 
439b			;		push hl 
439b			; 
439b			;		; destroy value TOS 
439b			; 
439b			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
439b			; 
439b			;		; get count 
439b			; 
439b			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
439b			; 
439b			;		push hl 
439b			; 
439b			;		; destroy value TOS 
439b			; 
439b			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
439b			; 
439b			;		; one value on hl get other one back 
439b			; 
439b			;		pop bc    ; count 
439b			; 
439b			;		pop de   ; dir 
439b			; 
439b			; 
439b			;		ld b, c 
439b			; 
439b			;.scrolldir:     push bc 
439b			;		push de 
439b			; 
439b			;		ld a, 0 
439b			;		cp e 
439b			;		jr z, .scrollup  
439b			;		call scroll_down 
439b			;		jr .scrollnext 
439b			;.scrollup:	call scroll_up 
439b			; 
439b			;		 
439b			;.scrollnext: 
439b			;		pop de 
439b			;		pop bc 
439b			;		djnz .scrolldir 
439b			; 
439b			; 
439b			; 
439b			; 
439b			; 
439b			;		NEXTW 
439b			 
439b			.SCROLLD: 
439b				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
439b 53				db WORD_SYS_CORE+63             
439c cc 43			dw .ATQ            
439e 08				db 7 + 1 
439f .. 00			db "SCROLLD",0              
43a7				endm 
# End of macro CWHEAD
43a7			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
43a7					if DEBUG_FORTH_WORDS_KEY 
43a7						DMARK "SCD" 
43a7 f5				push af  
43a8 3a bc 43			ld a, (.dmark)  
43ab 32 5e ee			ld (debug_mark),a  
43ae 3a bd 43			ld a, (.dmark+1)  
43b1 32 5f ee			ld (debug_mark+1),a  
43b4 3a be 43			ld a, (.dmark+2)  
43b7 32 60 ee			ld (debug_mark+2),a  
43ba 18 03			jr .pastdmark  
43bc ..			.dmark: db "SCD"  
43bf f1			.pastdmark: pop af  
43c0			endm  
# End of macro DMARK
43c0						CALLMONITOR 
43c0 cd 6b ee			call debug_vector  
43c3				endm  
# End of macro CALLMONITOR
43c3					endif 
43c3			 
43c3 cd a2 0b			call scroll_down 
43c6			;	call update_display 
43c6			 
43c6					NEXTW 
43c6 cd 68 ee			call parse_vector 
43c9 c3 ba 1e			jp macro_next 
43cc				endm 
# End of macro NEXTW
43cc			 
43cc			 
43cc			.ATQ: 
43cc				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
43cc 62				db WORD_SYS_CORE+78             
43cd 2d 44			dw .AUTODSP            
43cf 04				db 3 + 1 
43d0 .. 00			db "AT@",0              
43d4				endm 
# End of macro CWHEAD
43d4			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
43d4					if DEBUG_FORTH_WORDS_KEY 
43d4						DMARK "ATA" 
43d4 f5				push af  
43d5 3a e9 43			ld a, (.dmark)  
43d8 32 5e ee			ld (debug_mark),a  
43db 3a ea 43			ld a, (.dmark+1)  
43de 32 5f ee			ld (debug_mark+1),a  
43e1 3a eb 43			ld a, (.dmark+2)  
43e4 32 60 ee			ld (debug_mark+2),a  
43e7 18 03			jr .pastdmark  
43e9 ..			.dmark: db "ATA"  
43ec f1			.pastdmark: pop af  
43ed			endm  
# End of macro DMARK
43ed						CALLMONITOR 
43ed cd 6b ee			call debug_vector  
43f0				endm  
# End of macro CALLMONITOR
43f0					endif 
43f0			 
43f0			 
43f0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
43f0 cd d3 1c			call macro_dsp_valuehl 
43f3				endm 
# End of macro FORTH_DSP_VALUEHL
43f3			 
43f3					; TODO save cursor row 
43f3 7d					ld a,l 
43f4 fe 02				cp 2 
43f6 20 04				jr nz, .crow3aq 
43f8 3e 28				ld a, display_row_2 
43fa 18 12				jr .ccol1aq 
43fc fe 03		.crow3aq:		cp 3 
43fe 20 04				jr nz, .crow4aq 
4400 3e 50				ld a, display_row_3 
4402 18 0a				jr .ccol1aq 
4404 fe 04		.crow4aq:		cp 4 
4406 20 04				jr nz, .crow1aq 
4408 3e 78				ld a, display_row_4 
440a 18 02				jr .ccol1aq 
440c 3e 00		.crow1aq:		ld a,display_row_1 
440e f5			.ccol1aq:		push af			; got row offset 
440f 6f					ld l,a 
4410 26 00				ld h,0 
4412					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4412 cd 8b 1d			call macro_forth_dsp_pop 
4415				endm 
# End of macro FORTH_DSP_POP
4415					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4415 cd d3 1c			call macro_dsp_valuehl 
4418				endm 
# End of macro FORTH_DSP_VALUEHL
4418					; TODO save cursor col 
4418 f1					pop af 
4419 85					add l		; add col offset 
441a			 
441a					; add current frame buffer address 
441a 2a bf eb				ld hl, (display_fb_active) 
441d cd e6 0d				call addatohl 
4420			 
4420			 
4420			 
4420			 
4420					; get char frame buffer location offset in hl 
4420			 
4420 7e					ld a,(hl) 
4421 26 00				ld h, 0 
4423 6f					ld l, a 
4424			 
4424 cd d7 1a				call forth_push_numhl 
4427			 
4427			 
4427					NEXTW 
4427 cd 68 ee			call parse_vector 
442a c3 ba 1e			jp macro_next 
442d				endm 
# End of macro NEXTW
442d			 
442d			.AUTODSP: 
442d				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
442d 63				db WORD_SYS_CORE+79             
442e 46 44			dw .MENU            
4430 05				db 4 + 1 
4431 .. 00			db "ADSP",0              
4436				endm 
# End of macro CWHEAD
4436			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
4436			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
4436			 
4436					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4436 cd d3 1c			call macro_dsp_valuehl 
4439				endm 
# End of macro FORTH_DSP_VALUEHL
4439			 
4439			;		push hl 
4439			 
4439					; destroy value TOS 
4439			 
4439					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4439 cd 8b 1d			call macro_forth_dsp_pop 
443c				endm 
# End of macro FORTH_DSP_POP
443c			 
443c			;		pop hl 
443c			 
443c 7d					ld a,l 
443d 32 2f ea				ld (cli_autodisplay), a 
4440				       NEXTW 
4440 cd 68 ee			call parse_vector 
4443 c3 ba 1e			jp macro_next 
4446				endm 
# End of macro NEXTW
4446			 
4446			.MENU: 
4446				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
4446 70				db WORD_SYS_CORE+92             
4447 f2 44			dw .ENDDISPLAY            
4449 05				db 4 + 1 
444a .. 00			db "MENU",0              
444f				endm 
# End of macro CWHEAD
444f			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | DONE 
444f			 
444f			;		; get number of items on the stack 
444f			; 
444f				 
444f					FORTH_DSP_VALUEHL 
444f cd d3 1c			call macro_dsp_valuehl 
4452				endm 
# End of macro FORTH_DSP_VALUEHL
4452				 
4452					if DEBUG_FORTH_WORDS_KEY 
4452						DMARK "MNU" 
4452 f5				push af  
4453 3a 67 44			ld a, (.dmark)  
4456 32 5e ee			ld (debug_mark),a  
4459 3a 68 44			ld a, (.dmark+1)  
445c 32 5f ee			ld (debug_mark+1),a  
445f 3a 69 44			ld a, (.dmark+2)  
4462 32 60 ee			ld (debug_mark+2),a  
4465 18 03			jr .pastdmark  
4467 ..			.dmark: db "MNU"  
446a f1			.pastdmark: pop af  
446b			endm  
# End of macro DMARK
446b						CALLMONITOR 
446b cd 6b ee			call debug_vector  
446e				endm  
# End of macro CALLMONITOR
446e					endif 
446e			 
446e 45					ld b, l	 
446f 05					dec b 
4470			 
4470					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4470 cd 8b 1d			call macro_forth_dsp_pop 
4473				endm 
# End of macro FORTH_DSP_POP
4473			 
4473			 
4473					; go directly through the stack to pluck out the string pointers and build an array 
4473			 
4473			;		FORTH_DSP 
4473			 
4473					; hl contains top most stack item 
4473				 
4473 11 b4 e2				ld de, scratch 
4476			 
4476			.mbuild: 
4476			 
4476					FORTH_DSP_VALUEHL 
4476 cd d3 1c			call macro_dsp_valuehl 
4479				endm 
# End of macro FORTH_DSP_VALUEHL
4479			 
4479					if DEBUG_FORTH_WORDS 
4479						DMARK "MN3" 
4479 f5				push af  
447a 3a 8e 44			ld a, (.dmark)  
447d 32 5e ee			ld (debug_mark),a  
4480 3a 8f 44			ld a, (.dmark+1)  
4483 32 5f ee			ld (debug_mark+1),a  
4486 3a 90 44			ld a, (.dmark+2)  
4489 32 60 ee			ld (debug_mark+2),a  
448c 18 03			jr .pastdmark  
448e ..			.dmark: db "MN3"  
4491 f1			.pastdmark: pop af  
4492			endm  
# End of macro DMARK
4492						CALLMONITOR 
4492 cd 6b ee			call debug_vector  
4495				endm  
# End of macro CALLMONITOR
4495					endif 
4495 eb					ex de, hl 
4496 73					ld (hl), e 
4497 23					inc hl 
4498 72					ld (hl), d 
4499 23					inc hl 
449a eb					ex de, hl 
449b			 
449b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
449b cd 8b 1d			call macro_forth_dsp_pop 
449e				endm 
# End of macro FORTH_DSP_POP
449e			 
449e 10 d6				djnz .mbuild 
44a0			 
44a0					; done add term 
44a0			 
44a0 eb					ex de, hl 
44a1 36 00				ld (hl), 0 
44a3 23					inc hl 
44a4 36 00				ld (hl), 0 
44a6			 
44a6				 
44a6					 
44a6 21 b4 e2				ld hl, scratch 
44a9			 
44a9					if DEBUG_FORTH_WORDS 
44a9						DMARK "MNx" 
44a9 f5				push af  
44aa 3a be 44			ld a, (.dmark)  
44ad 32 5e ee			ld (debug_mark),a  
44b0 3a bf 44			ld a, (.dmark+1)  
44b3 32 5f ee			ld (debug_mark+1),a  
44b6 3a c0 44			ld a, (.dmark+2)  
44b9 32 60 ee			ld (debug_mark+2),a  
44bc 18 03			jr .pastdmark  
44be ..			.dmark: db "MNx"  
44c1 f1			.pastdmark: pop af  
44c2			endm  
# End of macro DMARK
44c2						CALLMONITOR 
44c2 cd 6b ee			call debug_vector  
44c5				endm  
# End of macro CALLMONITOR
44c5					endif 
44c5			 
44c5			 
44c5			 
44c5 3e 00				ld a, 0 
44c7 cd ec 0b				call menu 
44ca			 
44ca			 
44ca 6f					ld l, a 
44cb 26 00				ld h, 0 
44cd			 
44cd					if DEBUG_FORTH_WORDS 
44cd						DMARK "MNr" 
44cd f5				push af  
44ce 3a e2 44			ld a, (.dmark)  
44d1 32 5e ee			ld (debug_mark),a  
44d4 3a e3 44			ld a, (.dmark+1)  
44d7 32 5f ee			ld (debug_mark+1),a  
44da 3a e4 44			ld a, (.dmark+2)  
44dd 32 60 ee			ld (debug_mark+2),a  
44e0 18 03			jr .pastdmark  
44e2 ..			.dmark: db "MNr"  
44e5 f1			.pastdmark: pop af  
44e6			endm  
# End of macro DMARK
44e6						CALLMONITOR 
44e6 cd 6b ee			call debug_vector  
44e9				endm  
# End of macro CALLMONITOR
44e9					endif 
44e9			 
44e9 cd d7 1a				call forth_push_numhl 
44ec			 
44ec			 
44ec			 
44ec			 
44ec				       NEXTW 
44ec cd 68 ee			call parse_vector 
44ef c3 ba 1e			jp macro_next 
44f2				endm 
# End of macro NEXTW
44f2			 
44f2			 
44f2			.ENDDISPLAY: 
44f2			 
44f2			; eof 
# End of file forth_words_display.asm
44f2			include "forth_words_str.asm" 
44f2			 
44f2			; | ## String Words 
44f2			 
44f2			.CONST: 
44f2				 
44f2				CWHEAD .MOVE 52 "CONST" 5 WORD_FLAG_CODE 
44f2 48				db WORD_SYS_CORE+52             
44f3 07 45			dw .MOVE            
44f5 06				db 5 + 1 
44f6 .. 00			db "CONST",0              
44fc				endm 
# End of macro CWHEAD
44fc			; | CONST ( u -- u ) Change the type of var on TOS to a constant. i.e. if a string it won't be freed on consuption, | TODO 
44fc					FORTH_DSP 
44fc cd 99 1c			call macro_forth_dsp 
44ff				endm 
# End of macro FORTH_DSP
44ff 36 04				ld (hl), DS_TYPE_CONST 
4501					NEXTW 
4501 cd 68 ee			call parse_vector 
4504 c3 ba 1e			jp macro_next 
4507				endm 
# End of macro NEXTW
4507			 
4507			.MOVE:   
4507			 
4507				CWHEAD .ZMOVE 52 "MOVE" 4 WORD_FLAG_CODE 
4507 48				db WORD_SYS_CORE+52             
4508 2e 45			dw .ZMOVE            
450a 05				db 4 + 1 
450b .. 00			db "MOVE",0              
4510				endm 
# End of macro CWHEAD
4510			; | MOVE ( a1 a2 c -- ) Copy from address a1 to address a2 for the length of c | DONE 
4510			 
4510					FORTH_DSP_VALUEHL 
4510 cd d3 1c			call macro_dsp_valuehl 
4513				endm 
# End of macro FORTH_DSP_VALUEHL
4513 e5					push hl    ; push count 
4514			 
4514					FORTH_DSP_POP 
4514 cd 8b 1d			call macro_forth_dsp_pop 
4517				endm 
# End of macro FORTH_DSP_POP
4517			 
4517					FORTH_DSP_VALUEHL 
4517 cd d3 1c			call macro_dsp_valuehl 
451a				endm 
# End of macro FORTH_DSP_VALUEHL
451a e5					push hl    ; dest 
451b			 
451b					FORTH_DSP_POP 
451b cd 8b 1d			call macro_forth_dsp_pop 
451e				endm 
# End of macro FORTH_DSP_POP
451e			 
451e					FORTH_DSP_VALUEHL 
451e cd d3 1c			call macro_dsp_valuehl 
4521				endm 
# End of macro FORTH_DSP_VALUEHL
4521			 
4521					FORTH_DSP_POP 
4521 cd 8b 1d			call macro_forth_dsp_pop 
4524				endm 
# End of macro FORTH_DSP_POP
4524			 
4524 d1					pop de 
4525 c1					pop bc 
4526				 
4526 ed b0				ldir 
4528				NEXTW 
4528 cd 68 ee			call parse_vector 
452b c3 ba 1e			jp macro_next 
452e				endm 
# End of macro NEXTW
452e			.ZMOVE:   
452e			 
452e				CWHEAD .TABLE 52 "ZMOVE" 5 WORD_FLAG_CODE 
452e 48				db WORD_SYS_CORE+52             
452f 57 45			dw .TABLE            
4531 06				db 5 + 1 
4532 .. 00			db "ZMOVE",0              
4538				endm 
# End of macro CWHEAD
4538					 
4538			; | ZMOVE ( a1 a2 -- ) Copy from address a1 to address a2 until a1 hits zero term string | DONE 
4538			; | | Ensure you have enough space! 
4538			 
4538			 
4538					FORTH_DSP_VALUEHL 
4538 cd d3 1c			call macro_dsp_valuehl 
453b				endm 
# End of macro FORTH_DSP_VALUEHL
453b e5					push hl    ; dest 
453c			 
453c					FORTH_DSP_POP 
453c cd 8b 1d			call macro_forth_dsp_pop 
453f				endm 
# End of macro FORTH_DSP_POP
453f			 
453f					FORTH_DSP_VALUEHL 
453f cd d3 1c			call macro_dsp_valuehl 
4542				endm 
# End of macro FORTH_DSP_VALUEHL
4542			 
4542					FORTH_DSP_POP 
4542 cd 8b 1d			call macro_forth_dsp_pop 
4545				endm 
# End of macro FORTH_DSP_POP
4545			 
4545 d1					pop de 
4546			 
4546 01 ff 00				ld bc, 255 
4549 ed a0		.zmovel:	ldi 
454b 2b					dec hl 
454c 7e					ld a,(hl) 
454d 23					inc hl 
454e b7					or a  
454f 20 f8				jr nz, .zmovel    
4551					 
4551			 
4551				NEXTW 
4551 cd 68 ee			call parse_vector 
4554 c3 ba 1e			jp macro_next 
4557				endm 
# End of macro NEXTW
4557			 
4557			.TABLE:   
4557			 
4557				CWHEAD .SPLIT 52 "TABLE" 5 WORD_FLAG_CODE 
4557 48				db WORD_SYS_CORE+52             
4558 bc 45			dw .SPLIT            
455a 06				db 5 + 1 
455b .. 00			db "TABLE",0              
4561				endm 
# End of macro CWHEAD
4561					 
4561			; | TABLE ( s .. sx c -- a) For the number c of strings s on the stack. Generate a look up table array a | DONE 
4561			; | | Takes a list of strings and creates a block of pointers to each string which can then be used 
4561			; | | in any kind of lookup or iteration.  
4561			; | | Last item in the array will be a zero pointer for ease of iteration 
4561			 
4561			 
4561				; get the count of strings 
4561			 
4561					FORTH_DSP_VALUEHL 
4561 cd d3 1c			call macro_dsp_valuehl 
4564				endm 
# End of macro FORTH_DSP_VALUEHL
4564			 
4564					FORTH_DSP_POP 
4564 cd 8b 1d			call macro_forth_dsp_pop 
4567				endm 
# End of macro FORTH_DSP_POP
4567			 
4567				; allocate memory for (count + 1 ) * 2 for word array plus zero pointer 
4567			 
4567					; l contains count 
4567			 
4567 7d					ld a,l 
4568 32 b4 e2				ld (scratch), a     ; save it for the loading loop 
456b			 
456b 2c					inc l  ; for zero pointer 
456c eb					ex de, hl 
456d 3e 02				ld a, 2 
456f cd 69 0d				call Mult16 
4572			 
4572					; hl is the size of block to allocate 
4572			 
4572 cd b2 11				call malloc 
4575				if DEBUG_FORTH_MALLOC_GUARD 
4575 cc 54 54				call z,malloc_error 
4578				endif 
4578					; hl is the pointer to the array block 
4578						 
4578 22 b5 e2				ld (scratch+1), hl    ; save the base for later push to stack 
457b 22 b7 e2				ld (scratch+3), hl    ; save the base for current string to push 
457e			 
457e 3a b4 e2				ld a, (scratch) 
4581 47					ld b, a 
4582			 
4582				; for each string 
4582			 
4582			.tablelop: 
4582			 
4582 c5					push bc 
4583			 
4583				;     get string pointer 
4583			 
4583					FORTH_DSP_VALUEHL 
4583 cd d3 1c			call macro_dsp_valuehl 
4586				endm 
# End of macro FORTH_DSP_VALUEHL
4586			 
4586 e5					push hl 
4587			 
4587				;     get string length 
4587			 
4587 3e 00				ld a,0 
4589 cd 49 11				call strlent 
458c			 
458c 23					inc hl 
458d e5					push hl 
458e			 
458e				;     allocate string length 
458e			 
458e cd b2 11				call malloc 
4591			 
4591			        ;     copy string to block 
4591			 
4591 c1					pop bc 
4592 eb					ex de, hl 
4593 e1					pop hl 
4594 d5					push de 
4595			 
4595 ed b0				ldir 
4597			 
4597			 
4597			        ;     add pointer to string to array block 
4597			 
4597 2a b7 e2				ld hl, (scratch+3)    ; save the base for current string to push 
459a			 
459a d1					pop de     ; the pointer to the newly copied string to add to the array 
459b 73					ld (hl), e 
459c 23					inc hl 
459d 72					ld (hl), d	 
459e 23					inc hl 
459f				 
459f 22 b7 e2				ld (scratch+3), hl    ; save the base for current string to push 
45a2			 
45a2					FORTH_DSP_POP 
45a2 cd 8b 1d			call macro_forth_dsp_pop 
45a5				endm 
# End of macro FORTH_DSP_POP
45a5			 
45a5 c1					pop bc 
45a6 10 da				djnz .tablelop 
45a8			 
45a8			        ;  push array block pointer 
45a8			 
45a8 2a b7 e2				ld hl, (scratch+3)    ; save the base for current string to push 
45ab 36 00				ld (hl), 0 
45ad 23					inc hl 
45ae 36 00				ld (hl), 0 
45b0			 
45b0			 
45b0				 
45b0 2a b5 e2				ld hl, (scratch+1)    ; save the base for current string to push 
45b3 cd d7 1a				call forth_push_numhl 
45b6			 
45b6				NEXTW 
45b6 cd 68 ee			call parse_vector 
45b9 c3 ba 1e			jp macro_next 
45bc				endm 
# End of macro NEXTW
45bc			 
45bc			.SPLIT:   
45bc			 
45bc				CWHEAD .PTR 52 "SPLIT" 5 WORD_FLAG_CODE 
45bc 48				db WORD_SYS_CORE+52             
45bd b3 46			dw .PTR            
45bf 06				db 5 + 1 
45c0 .. 00			db "SPLIT",0              
45c6				endm 
# End of macro CWHEAD
45c6			; | SPLIT ( s d -- s s...sn c ) Using delimter d, add strings found in s to stack pushing item count c | DONE 
45c6					if DEBUG_FORTH_WORDS_KEY 
45c6						DMARK "SPT" 
45c6 f5				push af  
45c7 3a db 45			ld a, (.dmark)  
45ca 32 5e ee			ld (debug_mark),a  
45cd 3a dc 45			ld a, (.dmark+1)  
45d0 32 5f ee			ld (debug_mark+1),a  
45d3 3a dd 45			ld a, (.dmark+2)  
45d6 32 60 ee			ld (debug_mark+2),a  
45d9 18 03			jr .pastdmark  
45db ..			.dmark: db "SPT"  
45de f1			.pastdmark: pop af  
45df			endm  
# End of macro DMARK
45df						CALLMONITOR 
45df cd 6b ee			call debug_vector  
45e2				endm  
# End of macro CALLMONITOR
45e2					endif 
45e2			 
45e2					; get delim 
45e2					FORTH_DSP_VALUEHL 
45e2 cd d3 1c			call macro_dsp_valuehl 
45e5				endm 
# End of macro FORTH_DSP_VALUEHL
45e5			 
45e5					FORTH_DSP_POP 
45e5 cd 8b 1d			call macro_forth_dsp_pop 
45e8				endm 
# End of macro FORTH_DSP_POP
45e8					 
45e8			 
45e8 45					ld b, l    ; move delim to b 
45e9 0e 01				ld c, 1   ; count of poritions 
45eb			 
45eb c5					push bc 
45ec			 
45ec					if DEBUG_FORTH_WORDS 
45ec						DMARK "SPa" 
45ec f5				push af  
45ed 3a 01 46			ld a, (.dmark)  
45f0 32 5e ee			ld (debug_mark),a  
45f3 3a 02 46			ld a, (.dmark+1)  
45f6 32 5f ee			ld (debug_mark+1),a  
45f9 3a 03 46			ld a, (.dmark+2)  
45fc 32 60 ee			ld (debug_mark+2),a  
45ff 18 03			jr .pastdmark  
4601 ..			.dmark: db "SPa"  
4604 f1			.pastdmark: pop af  
4605			endm  
# End of macro DMARK
4605						CALLMONITOR 
4605 cd 6b ee			call debug_vector  
4608				endm  
# End of macro CALLMONITOR
4608					endif 
4608					; get pointer to string to chop up 
4608					FORTH_DSP_VALUEHL 
4608 cd d3 1c			call macro_dsp_valuehl 
460b				endm 
# End of macro FORTH_DSP_VALUEHL
460b			 
460b			;		push hl 
460b 11 b4 e2				ld de, scratch 
460e			.spllop: 
460e c1					pop bc 
460f c5					push bc 
4610			;		pop hl 
4610					if DEBUG_FORTH_WORDS 
4610						DMARK "SPl" 
4610 f5				push af  
4611 3a 25 46			ld a, (.dmark)  
4614 32 5e ee			ld (debug_mark),a  
4617 3a 26 46			ld a, (.dmark+1)  
461a 32 5f ee			ld (debug_mark+1),a  
461d 3a 27 46			ld a, (.dmark+2)  
4620 32 60 ee			ld (debug_mark+2),a  
4623 18 03			jr .pastdmark  
4625 ..			.dmark: db "SPl"  
4628 f1			.pastdmark: pop af  
4629			endm  
# End of macro DMARK
4629						CALLMONITOR 
4629 cd 6b ee			call debug_vector  
462c				endm  
# End of macro CALLMONITOR
462c					endif 
462c 7e					ld a, (hl) 
462d b8					cp b 
462e 28 07				jr z, .splnxt 
4630			;		cp 0 
4630 b7					or a 
4631 28 34				jr z, .splend 
4633 ed a0				ldi 
4635 18 d7				jr .spllop 
4637			 
4637					; hit dlim 
4637			 
4637			.splnxt: 
4637					if DEBUG_FORTH_WORDS 
4637						DMARK "SPx" 
4637 f5				push af  
4638 3a 4c 46			ld a, (.dmark)  
463b 32 5e ee			ld (debug_mark),a  
463e 3a 4d 46			ld a, (.dmark+1)  
4641 32 5f ee			ld (debug_mark+1),a  
4644 3a 4e 46			ld a, (.dmark+2)  
4647 32 60 ee			ld (debug_mark+2),a  
464a 18 03			jr .pastdmark  
464c ..			.dmark: db "SPx"  
464f f1			.pastdmark: pop af  
4650			endm  
# End of macro DMARK
4650						CALLMONITOR 
4650 cd 6b ee			call debug_vector  
4653				endm  
# End of macro CALLMONITOR
4653					endif 
4653 3e 00				ld a, 0 
4655 12					ld (de), a 
4656					;ex de, hl 
4656 e5					push hl 
4657 21 b4 e2				ld hl, scratch 
465a cd 41 1b				call forth_push_str 
465d e1					pop hl 
465e					;ex de, hl 
465e 23					inc hl 
465f c1					pop bc 
4660 0c					inc c 
4661 c5					push bc 
4662 11 b4 e2				ld de, scratch 
4665 18 a7				jr .spllop 
4667			 
4667			.splend:		 
4667					if DEBUG_FORTH_WORDS 
4667						DMARK "SPe" 
4667 f5				push af  
4668 3a 7c 46			ld a, (.dmark)  
466b 32 5e ee			ld (debug_mark),a  
466e 3a 7d 46			ld a, (.dmark+1)  
4671 32 5f ee			ld (debug_mark+1),a  
4674 3a 7e 46			ld a, (.dmark+2)  
4677 32 60 ee			ld (debug_mark+2),a  
467a 18 03			jr .pastdmark  
467c ..			.dmark: db "SPe"  
467f f1			.pastdmark: pop af  
4680			endm  
# End of macro DMARK
4680						CALLMONITOR 
4680 cd 6b ee			call debug_vector  
4683				endm  
# End of macro CALLMONITOR
4683					endif 
4683 12					ld (de), a 
4684 eb					ex de, hl 
4685			;		push hl 
4685 21 b4 e2				ld hl, scratch 
4688 cd 41 1b				call forth_push_str 
468b					 
468b					if DEBUG_FORTH_WORDS 
468b						DMARK "SPc" 
468b f5				push af  
468c 3a a0 46			ld a, (.dmark)  
468f 32 5e ee			ld (debug_mark),a  
4692 3a a1 46			ld a, (.dmark+1)  
4695 32 5f ee			ld (debug_mark+1),a  
4698 3a a2 46			ld a, (.dmark+2)  
469b 32 60 ee			ld (debug_mark+2),a  
469e 18 03			jr .pastdmark  
46a0 ..			.dmark: db "SPc"  
46a3 f1			.pastdmark: pop af  
46a4			endm  
# End of macro DMARK
46a4						CALLMONITOR 
46a4 cd 6b ee			call debug_vector  
46a7				endm  
# End of macro CALLMONITOR
46a7					endif 
46a7			 
46a7 e1					pop hl    ; get counter from bc which has been push 
46a8 26 00				ld h, 0 
46aa			;		ld l, c 
46aa cd d7 1a				call forth_push_numhl 
46ad			 
46ad			 
46ad				NEXTW 
46ad cd 68 ee			call parse_vector 
46b0 c3 ba 1e			jp macro_next 
46b3				endm 
# End of macro NEXTW
46b3			.PTR:   
46b3			 
46b3				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
46b3 48				db WORD_SYS_CORE+52             
46b4 e3 46			dw .STYPE            
46b6 04				db 3 + 1 
46b7 .. 00			db "PTR",0              
46bb				endm 
# End of macro CWHEAD
46bb			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
46bb			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
46bb			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
46bb			 
46bb					if DEBUG_FORTH_WORDS_KEY 
46bb						DMARK "PTR" 
46bb f5				push af  
46bc 3a d0 46			ld a, (.dmark)  
46bf 32 5e ee			ld (debug_mark),a  
46c2 3a d1 46			ld a, (.dmark+1)  
46c5 32 5f ee			ld (debug_mark+1),a  
46c8 3a d2 46			ld a, (.dmark+2)  
46cb 32 60 ee			ld (debug_mark+2),a  
46ce 18 03			jr .pastdmark  
46d0 ..			.dmark: db "PTR"  
46d3 f1			.pastdmark: pop af  
46d4			endm  
# End of macro DMARK
46d4						CALLMONITOR 
46d4 cd 6b ee			call debug_vector  
46d7				endm  
# End of macro CALLMONITOR
46d7					endif 
46d7					FORTH_DSP_VALUEHL 
46d7 cd d3 1c			call macro_dsp_valuehl 
46da				endm 
# End of macro FORTH_DSP_VALUEHL
46da cd d7 1a				call forth_push_numhl 
46dd			 
46dd			 
46dd					NEXTW 
46dd cd 68 ee			call parse_vector 
46e0 c3 ba 1e			jp macro_next 
46e3				endm 
# End of macro NEXTW
46e3			.STYPE: 
46e3				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
46e3 48				db WORD_SYS_CORE+52             
46e4 40 47			dw .UPPER            
46e6 06				db 5 + 1 
46e7 .. 00			db "STYPE",0              
46ed				endm 
# End of macro CWHEAD
46ed			; | STYPE ( u -- u type ) Push type of value on TOS  | DONE 
46ed			; | | 's' string or 'i' integer or 'c' const 
46ed					if DEBUG_FORTH_WORDS_KEY 
46ed						DMARK "STY" 
46ed f5				push af  
46ee 3a 02 47			ld a, (.dmark)  
46f1 32 5e ee			ld (debug_mark),a  
46f4 3a 03 47			ld a, (.dmark+1)  
46f7 32 5f ee			ld (debug_mark+1),a  
46fa 3a 04 47			ld a, (.dmark+2)  
46fd 32 60 ee			ld (debug_mark+2),a  
4700 18 03			jr .pastdmark  
4702 ..			.dmark: db "STY"  
4705 f1			.pastdmark: pop af  
4706			endm  
# End of macro DMARK
4706						CALLMONITOR 
4706 cd 6b ee			call debug_vector  
4709				endm  
# End of macro CALLMONITOR
4709					endif 
4709					FORTH_DSP 
4709 cd 99 1c			call macro_forth_dsp 
470c				endm 
# End of macro FORTH_DSP
470c					;v5 FORTH_DSP_VALUE 
470c			 
470c 7e					ld a, (hl) 
470d			 
470d f5					push af 
470e			 
470e			; Dont destroy TOS		FORTH_DSP_POP 
470e			 
470e f1					pop af 
470f			 
470f fe 01				cp DS_TYPE_STR 
4711 28 12				jr z, .typestr 
4713 fe 04				cp DS_TYPE_CONST 
4715 28 09				jr z, .typeconst 
4717			 
4717 fe 02				cp DS_TYPE_INUM 
4719 28 0f				jr z, .typeinum 
471b			 
471b 21 3e 47				ld hl, .tna 
471e 18 0f				jr .tpush 
4720			 
4720 21 3a 47		.typeconst:	ld hl, .tconst 
4723 18 0a				jr .tpush 
4725 21 38 47		.typestr:	ld hl, .tstr 
4728 18 05				jr .tpush 
472a 21 3c 47		.typeinum:	ld hl, .tinum 
472d 18 00				jr .tpush 
472f			 
472f			.tpush: 
472f			 
472f cd 41 1b				call forth_push_str 
4732			 
4732					NEXTW 
4732 cd 68 ee			call parse_vector 
4735 c3 ba 1e			jp macro_next 
4738				endm 
# End of macro NEXTW
4738 .. 00		.tstr:	db "s",0 
473a .. 00		.tconst:	db "c",0 
473c .. 00		.tinum:  db "i",0 
473e .. 00		.tna:   db "?", 0 
4740			 
4740			 
4740			.UPPER: 
4740				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
4740 48				db WORD_SYS_CORE+52             
4741 7d 47			dw .LOWER            
4743 06				db 5 + 1 
4744 .. 00			db "UPPER",0              
474a				endm 
# End of macro CWHEAD
474a			; | UPPER ( s -- s ) Upper case string s  | DONE 
474a					if DEBUG_FORTH_WORDS_KEY 
474a						DMARK "UPR" 
474a f5				push af  
474b 3a 5f 47			ld a, (.dmark)  
474e 32 5e ee			ld (debug_mark),a  
4751 3a 60 47			ld a, (.dmark+1)  
4754 32 5f ee			ld (debug_mark+1),a  
4757 3a 61 47			ld a, (.dmark+2)  
475a 32 60 ee			ld (debug_mark+2),a  
475d 18 03			jr .pastdmark  
475f ..			.dmark: db "UPR"  
4762 f1			.pastdmark: pop af  
4763			endm  
# End of macro DMARK
4763						CALLMONITOR 
4763 cd 6b ee			call debug_vector  
4766				endm  
# End of macro CALLMONITOR
4766					endif 
4766			 
4766					FORTH_DSP 
4766 cd 99 1c			call macro_forth_dsp 
4769				endm 
# End of macro FORTH_DSP
4769					 
4769			; TODO check is string type 
4769			 
4769					FORTH_DSP_VALUEHL 
4769 cd d3 1c			call macro_dsp_valuehl 
476c				endm 
# End of macro FORTH_DSP_VALUEHL
476c			; get pointer to string in hl 
476c			 
476c 7e			.toup:		ld a, (hl) 
476d			;		cp 0 
476d b7					or a 
476e 28 07				jr z, .toupdone 
4770			 
4770 cd 4e 10				call to_upper 
4773			 
4773 77					ld (hl), a 
4774 23					inc hl 
4775 18 f5				jr .toup 
4777			 
4777					 
4777			 
4777			 
4777			; for each char convert to upper 
4777					 
4777			.toupdone: 
4777			 
4777			 
4777					NEXTW 
4777 cd 68 ee			call parse_vector 
477a c3 ba 1e			jp macro_next 
477d				endm 
# End of macro NEXTW
477d			.LOWER: 
477d				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
477d 48				db WORD_SYS_CORE+52             
477e ba 47			dw .TCASE            
4780 06				db 5 + 1 
4781 .. 00			db "LOWER",0              
4787				endm 
# End of macro CWHEAD
4787			; | LOWER ( s -- s ) Lower case string s  | DONE 
4787					if DEBUG_FORTH_WORDS_KEY 
4787						DMARK "LWR" 
4787 f5				push af  
4788 3a 9c 47			ld a, (.dmark)  
478b 32 5e ee			ld (debug_mark),a  
478e 3a 9d 47			ld a, (.dmark+1)  
4791 32 5f ee			ld (debug_mark+1),a  
4794 3a 9e 47			ld a, (.dmark+2)  
4797 32 60 ee			ld (debug_mark+2),a  
479a 18 03			jr .pastdmark  
479c ..			.dmark: db "LWR"  
479f f1			.pastdmark: pop af  
47a0			endm  
# End of macro DMARK
47a0						CALLMONITOR 
47a0 cd 6b ee			call debug_vector  
47a3				endm  
# End of macro CALLMONITOR
47a3					endif 
47a3			 
47a3					FORTH_DSP 
47a3 cd 99 1c			call macro_forth_dsp 
47a6				endm 
# End of macro FORTH_DSP
47a6					 
47a6			; TODO check is string type 
47a6			 
47a6					FORTH_DSP_VALUEHL 
47a6 cd d3 1c			call macro_dsp_valuehl 
47a9				endm 
# End of macro FORTH_DSP_VALUEHL
47a9			; get pointer to string in hl 
47a9			 
47a9 7e			.tolow:		ld a, (hl) 
47aa			;		cp 0 
47aa b7					or a 
47ab 28 07				jr z, .tolowdone 
47ad			 
47ad cd 57 10				call to_lower 
47b0			 
47b0 77					ld (hl), a 
47b1 23					inc hl 
47b2 18 f5				jr .tolow 
47b4			 
47b4					 
47b4			 
47b4			 
47b4			; for each char convert to low 
47b4					 
47b4			.tolowdone: 
47b4					NEXTW 
47b4 cd 68 ee			call parse_vector 
47b7 c3 ba 1e			jp macro_next 
47ba				endm 
# End of macro NEXTW
47ba			.TCASE: 
47ba				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
47ba 48				db WORD_SYS_CORE+52             
47bb f1 48			dw .SUBSTR            
47bd 06				db 5 + 1 
47be .. 00			db "TCASE",0              
47c4				endm 
# End of macro CWHEAD
47c4			; | TCASE ( s -- s ) Title case string s  | DONE 
47c4					if DEBUG_FORTH_WORDS_KEY 
47c4						DMARK "TCS" 
47c4 f5				push af  
47c5 3a d9 47			ld a, (.dmark)  
47c8 32 5e ee			ld (debug_mark),a  
47cb 3a da 47			ld a, (.dmark+1)  
47ce 32 5f ee			ld (debug_mark+1),a  
47d1 3a db 47			ld a, (.dmark+2)  
47d4 32 60 ee			ld (debug_mark+2),a  
47d7 18 03			jr .pastdmark  
47d9 ..			.dmark: db "TCS"  
47dc f1			.pastdmark: pop af  
47dd			endm  
# End of macro DMARK
47dd						CALLMONITOR 
47dd cd 6b ee			call debug_vector  
47e0				endm  
# End of macro CALLMONITOR
47e0					endif 
47e0			 
47e0					FORTH_DSP 
47e0 cd 99 1c			call macro_forth_dsp 
47e3				endm 
# End of macro FORTH_DSP
47e3					 
47e3			; TODO check is string type 
47e3			 
47e3					FORTH_DSP_VALUEHL 
47e3 cd d3 1c			call macro_dsp_valuehl 
47e6				endm 
# End of macro FORTH_DSP_VALUEHL
47e6			; get pointer to string in hl 
47e6			 
47e6					if DEBUG_FORTH_WORDS 
47e6						DMARK "TC1" 
47e6 f5				push af  
47e7 3a fb 47			ld a, (.dmark)  
47ea 32 5e ee			ld (debug_mark),a  
47ed 3a fc 47			ld a, (.dmark+1)  
47f0 32 5f ee			ld (debug_mark+1),a  
47f3 3a fd 47			ld a, (.dmark+2)  
47f6 32 60 ee			ld (debug_mark+2),a  
47f9 18 03			jr .pastdmark  
47fb ..			.dmark: db "TC1"  
47fe f1			.pastdmark: pop af  
47ff			endm  
# End of macro DMARK
47ff						CALLMONITOR 
47ff cd 6b ee			call debug_vector  
4802				endm  
# End of macro CALLMONITOR
4802					endif 
4802			 
4802					; first time in turn to upper case first char 
4802			 
4802 7e					ld a, (hl) 
4803 c3 8c 48				jp .totsiptou 
4806			 
4806			 
4806 7e			.tot:		ld a, (hl) 
4807			;		cp 0 
4807 b7					or a 
4808 ca cf 48				jp z, .totdone 
480b			 
480b					if DEBUG_FORTH_WORDS 
480b						DMARK "TC2" 
480b f5				push af  
480c 3a 20 48			ld a, (.dmark)  
480f 32 5e ee			ld (debug_mark),a  
4812 3a 21 48			ld a, (.dmark+1)  
4815 32 5f ee			ld (debug_mark+1),a  
4818 3a 22 48			ld a, (.dmark+2)  
481b 32 60 ee			ld (debug_mark+2),a  
481e 18 03			jr .pastdmark  
4820 ..			.dmark: db "TC2"  
4823 f1			.pastdmark: pop af  
4824			endm  
# End of macro DMARK
4824						CALLMONITOR 
4824 cd 6b ee			call debug_vector  
4827				endm  
# End of macro CALLMONITOR
4827					endif 
4827					; check to see if current char is a space 
4827			 
4827 fe 20				cp ' ' 
4829 28 21				jr z, .totsp 
482b cd 57 10				call to_lower 
482e					if DEBUG_FORTH_WORDS 
482e						DMARK "TC3" 
482e f5				push af  
482f 3a 43 48			ld a, (.dmark)  
4832 32 5e ee			ld (debug_mark),a  
4835 3a 44 48			ld a, (.dmark+1)  
4838 32 5f ee			ld (debug_mark+1),a  
483b 3a 45 48			ld a, (.dmark+2)  
483e 32 60 ee			ld (debug_mark+2),a  
4841 18 03			jr .pastdmark  
4843 ..			.dmark: db "TC3"  
4846 f1			.pastdmark: pop af  
4847			endm  
# End of macro DMARK
4847						CALLMONITOR 
4847 cd 6b ee			call debug_vector  
484a				endm  
# End of macro CALLMONITOR
484a					endif 
484a 18 62				jr .totnxt 
484c			 
484c			.totsp:         ; on a space, find next char which should be upper 
484c			 
484c					if DEBUG_FORTH_WORDS 
484c						DMARK "TC4" 
484c f5				push af  
484d 3a 61 48			ld a, (.dmark)  
4850 32 5e ee			ld (debug_mark),a  
4853 3a 62 48			ld a, (.dmark+1)  
4856 32 5f ee			ld (debug_mark+1),a  
4859 3a 63 48			ld a, (.dmark+2)  
485c 32 60 ee			ld (debug_mark+2),a  
485f 18 03			jr .pastdmark  
4861 ..			.dmark: db "TC4"  
4864 f1			.pastdmark: pop af  
4865			endm  
# End of macro DMARK
4865						CALLMONITOR 
4865 cd 6b ee			call debug_vector  
4868				endm  
# End of macro CALLMONITOR
4868					endif 
4868					;; 
4868			 
4868 fe 20				cp ' ' 
486a 20 20				jr nz, .totsiptou 
486c 23					inc hl 
486d 7e					ld a, (hl) 
486e					if DEBUG_FORTH_WORDS 
486e						DMARK "TC5" 
486e f5				push af  
486f 3a 83 48			ld a, (.dmark)  
4872 32 5e ee			ld (debug_mark),a  
4875 3a 84 48			ld a, (.dmark+1)  
4878 32 5f ee			ld (debug_mark+1),a  
487b 3a 85 48			ld a, (.dmark+2)  
487e 32 60 ee			ld (debug_mark+2),a  
4881 18 03			jr .pastdmark  
4883 ..			.dmark: db "TC5"  
4886 f1			.pastdmark: pop af  
4887			endm  
# End of macro DMARK
4887						CALLMONITOR 
4887 cd 6b ee			call debug_vector  
488a				endm  
# End of macro CALLMONITOR
488a					endif 
488a 18 c0				jr .totsp 
488c			.totsiptou:     
488c					;cp 0 
488c b7					or a 
488d 28 40				jr z, .totdone 
488f					; not space and not zero term so upper case it 
488f cd 4e 10				call to_upper 
4892			 
4892					if DEBUG_FORTH_WORDS 
4892						DMARK "TC6" 
4892 f5				push af  
4893 3a a7 48			ld a, (.dmark)  
4896 32 5e ee			ld (debug_mark),a  
4899 3a a8 48			ld a, (.dmark+1)  
489c 32 5f ee			ld (debug_mark+1),a  
489f 3a a9 48			ld a, (.dmark+2)  
48a2 32 60 ee			ld (debug_mark+2),a  
48a5 18 03			jr .pastdmark  
48a7 ..			.dmark: db "TC6"  
48aa f1			.pastdmark: pop af  
48ab			endm  
# End of macro DMARK
48ab						CALLMONITOR 
48ab cd 6b ee			call debug_vector  
48ae				endm  
# End of macro CALLMONITOR
48ae					endif 
48ae			 
48ae			 
48ae			.totnxt: 
48ae			 
48ae 77					ld (hl), a 
48af 23					inc hl 
48b0					if DEBUG_FORTH_WORDS 
48b0						DMARK "TC7" 
48b0 f5				push af  
48b1 3a c5 48			ld a, (.dmark)  
48b4 32 5e ee			ld (debug_mark),a  
48b7 3a c6 48			ld a, (.dmark+1)  
48ba 32 5f ee			ld (debug_mark+1),a  
48bd 3a c7 48			ld a, (.dmark+2)  
48c0 32 60 ee			ld (debug_mark+2),a  
48c3 18 03			jr .pastdmark  
48c5 ..			.dmark: db "TC7"  
48c8 f1			.pastdmark: pop af  
48c9			endm  
# End of macro DMARK
48c9						CALLMONITOR 
48c9 cd 6b ee			call debug_vector  
48cc				endm  
# End of macro CALLMONITOR
48cc					endif 
48cc c3 06 48				jp .tot 
48cf			 
48cf					 
48cf			 
48cf			 
48cf			; for each char convert to low 
48cf					 
48cf			.totdone: 
48cf					if DEBUG_FORTH_WORDS 
48cf						DMARK "TCd" 
48cf f5				push af  
48d0 3a e4 48			ld a, (.dmark)  
48d3 32 5e ee			ld (debug_mark),a  
48d6 3a e5 48			ld a, (.dmark+1)  
48d9 32 5f ee			ld (debug_mark+1),a  
48dc 3a e6 48			ld a, (.dmark+2)  
48df 32 60 ee			ld (debug_mark+2),a  
48e2 18 03			jr .pastdmark  
48e4 ..			.dmark: db "TCd"  
48e7 f1			.pastdmark: pop af  
48e8			endm  
# End of macro DMARK
48e8						CALLMONITOR 
48e8 cd 6b ee			call debug_vector  
48eb				endm  
# End of macro CALLMONITOR
48eb					endif 
48eb					NEXTW 
48eb cd 68 ee			call parse_vector 
48ee c3 ba 1e			jp macro_next 
48f1				endm 
# End of macro NEXTW
48f1			 
48f1			.SUBSTR: 
48f1				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
48f1 48				db WORD_SYS_CORE+52             
48f2 51 49			dw .LEFT            
48f4 07				db 6 + 1 
48f5 .. 00			db "SUBSTR",0              
48fc				endm 
# End of macro CWHEAD
48fc			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
48fc			 
48fc					if DEBUG_FORTH_WORDS_KEY 
48fc						DMARK "SST" 
48fc f5				push af  
48fd 3a 11 49			ld a, (.dmark)  
4900 32 5e ee			ld (debug_mark),a  
4903 3a 12 49			ld a, (.dmark+1)  
4906 32 5f ee			ld (debug_mark+1),a  
4909 3a 13 49			ld a, (.dmark+2)  
490c 32 60 ee			ld (debug_mark+2),a  
490f 18 03			jr .pastdmark  
4911 ..			.dmark: db "SST"  
4914 f1			.pastdmark: pop af  
4915			endm  
# End of macro DMARK
4915						CALLMONITOR 
4915 cd 6b ee			call debug_vector  
4918				endm  
# End of macro CALLMONITOR
4918					endif 
4918			; TODO check string type 
4918					FORTH_DSP_VALUEHL 
4918 cd d3 1c			call macro_dsp_valuehl 
491b				endm 
# End of macro FORTH_DSP_VALUEHL
491b			 
491b e5					push hl      ; string length 
491c			 
491c					FORTH_DSP_POP 
491c cd 8b 1d			call macro_forth_dsp_pop 
491f				endm 
# End of macro FORTH_DSP_POP
491f			 
491f					FORTH_DSP_VALUEHL 
491f cd d3 1c			call macro_dsp_valuehl 
4922				endm 
# End of macro FORTH_DSP_VALUEHL
4922			 
4922 e5					push hl     ; start char 
4923			 
4923					FORTH_DSP_POP 
4923 cd 8b 1d			call macro_forth_dsp_pop 
4926				endm 
# End of macro FORTH_DSP_POP
4926			 
4926			 
4926					FORTH_DSP_VALUE 
4926 cd bc 1c			call macro_forth_dsp_value 
4929				endm 
# End of macro FORTH_DSP_VALUE
4929			 
4929 d1					pop de    ; get start post offset 
492a			 
492a 19					add hl, de    ; starting offset 
492b			 
492b c1					pop bc 
492c c5					push bc      ; grab size of string 
492d			 
492d e5					push hl    ; save string start  
492e			 
492e 26 00				ld h, 0 
4930 69					ld l, c 
4931 23					inc hl 
4932 23					inc hl 
4933			 
4933 cd b2 11				call malloc 
4936				if DEBUG_FORTH_MALLOC_GUARD 
4936 cc 54 54				call z,malloc_error 
4939				endif 
4939			 
4939 eb					ex de, hl      ; save malloc area for string copy 
493a e1					pop hl    ; get back source 
493b c1					pop bc    ; get length of string back 
493c			 
493c d5					push de    ; save malloc area for after we push 
493d ed b0				ldir     ; copy substr 
493f			 
493f			 
493f eb					ex de, hl 
4940			;		ld a, 0 
4940 36 00				ld (hl), 0   ; term substr 
4942			 
4942					 
4942 e1					pop hl    ; get malloc so we can push it 
4943 e5					push hl   ; save so we can free it afterwards 
4944			 
4944 cd 41 1b				call forth_push_str 
4947			 
4947 e1					pop hl 
4948 cd 7c 12				call free 
494b			 
494b					 
494b					 
494b			 
494b			 
494b					NEXTW 
494b cd 68 ee			call parse_vector 
494e c3 ba 1e			jp macro_next 
4951				endm 
# End of macro NEXTW
4951			 
4951			.LEFT: 
4951				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
4951 48				db WORD_SYS_CORE+52             
4952 95 49			dw .RIGHT            
4954 05				db 4 + 1 
4955 .. 00			db "LEFT",0              
495a				endm 
# End of macro CWHEAD
495a			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | DONE 
495a					if DEBUG_FORTH_WORDS_KEY 
495a						DMARK "LEF" 
495a f5				push af  
495b 3a 6f 49			ld a, (.dmark)  
495e 32 5e ee			ld (debug_mark),a  
4961 3a 70 49			ld a, (.dmark+1)  
4964 32 5f ee			ld (debug_mark+1),a  
4967 3a 71 49			ld a, (.dmark+2)  
496a 32 60 ee			ld (debug_mark+2),a  
496d 18 03			jr .pastdmark  
496f ..			.dmark: db "LEF"  
4972 f1			.pastdmark: pop af  
4973			endm  
# End of macro DMARK
4973						CALLMONITOR 
4973 cd 6b ee			call debug_vector  
4976				endm  
# End of macro CALLMONITOR
4976					endif 
4976			 
4976					 
4976			; TODO check string type 
4976					FORTH_DSP_VALUEHL 
4976 cd d3 1c			call macro_dsp_valuehl 
4979				endm 
# End of macro FORTH_DSP_VALUEHL
4979			 
4979 e5					push hl      ; string length 
497a			 
497a					FORTH_DSP_POP 
497a cd 8b 1d			call macro_forth_dsp_pop 
497d				endm 
# End of macro FORTH_DSP_POP
497d			 
497d					FORTH_DSP_VALUEHL 
497d cd d3 1c			call macro_dsp_valuehl 
4980				endm 
# End of macro FORTH_DSP_VALUEHL
4980			 
4980 c1					pop bc 
4981			 
4981 11 b4 e2				ld de, scratch 
4984 ed b0				ldir 
4986 3e 00				ld a, 0 
4988 12					ld (de), a 
4989					 
4989 21 b4 e2				ld hl, scratch 
498c cd 41 1b				call forth_push_str 
498f			 
498f					NEXTW 
498f cd 68 ee			call parse_vector 
4992 c3 ba 1e			jp macro_next 
4995				endm 
# End of macro NEXTW
4995			.RIGHT: 
4995				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
4995 48				db WORD_SYS_CORE+52             
4996 56 4a			dw .STR2NUM            
4998 06				db 5 + 1 
4999 .. 00			db "RIGHT",0              
499f				endm 
# End of macro CWHEAD
499f			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | DONE 
499f					if DEBUG_FORTH_WORDS_KEY 
499f						DMARK "RIG" 
499f f5				push af  
49a0 3a b4 49			ld a, (.dmark)  
49a3 32 5e ee			ld (debug_mark),a  
49a6 3a b5 49			ld a, (.dmark+1)  
49a9 32 5f ee			ld (debug_mark+1),a  
49ac 3a b6 49			ld a, (.dmark+2)  
49af 32 60 ee			ld (debug_mark+2),a  
49b2 18 03			jr .pastdmark  
49b4 ..			.dmark: db "RIG"  
49b7 f1			.pastdmark: pop af  
49b8			endm  
# End of macro DMARK
49b8						CALLMONITOR 
49b8 cd 6b ee			call debug_vector  
49bb				endm  
# End of macro CALLMONITOR
49bb					endif 
49bb			 
49bb			; TODO check string type 
49bb					FORTH_DSP_VALUEHL 
49bb cd d3 1c			call macro_dsp_valuehl 
49be				endm 
# End of macro FORTH_DSP_VALUEHL
49be			 
49be e5					push hl      ; string length 
49bf			 
49bf					FORTH_DSP_POP 
49bf cd 8b 1d			call macro_forth_dsp_pop 
49c2				endm 
# End of macro FORTH_DSP_POP
49c2			 
49c2					FORTH_DSP_VALUEHL 
49c2 cd d3 1c			call macro_dsp_valuehl 
49c5				endm 
# End of macro FORTH_DSP_VALUEHL
49c5			 
49c5					if DEBUG_FORTH_WORDS 
49c5						DMARK "RI1" 
49c5 f5				push af  
49c6 3a da 49			ld a, (.dmark)  
49c9 32 5e ee			ld (debug_mark),a  
49cc 3a db 49			ld a, (.dmark+1)  
49cf 32 5f ee			ld (debug_mark+1),a  
49d2 3a dc 49			ld a, (.dmark+2)  
49d5 32 60 ee			ld (debug_mark+2),a  
49d8 18 03			jr .pastdmark  
49da ..			.dmark: db "RI1"  
49dd f1			.pastdmark: pop af  
49de			endm  
# End of macro DMARK
49de						CALLMONITOR 
49de cd 6b ee			call debug_vector  
49e1				endm  
# End of macro CALLMONITOR
49e1					endif 
49e1					; from the pointer to string get to the end of string 
49e1			 
49e1 01 ff 00				ld bc, 255 
49e4 3e 00				ld a, 0 
49e6 ed b1				cpir 
49e8 2b					dec hl 
49e9			 
49e9					;  
49e9			 
49e9					if DEBUG_FORTH_WORDS 
49e9						DMARK "RI2" 
49e9 f5				push af  
49ea 3a fe 49			ld a, (.dmark)  
49ed 32 5e ee			ld (debug_mark),a  
49f0 3a ff 49			ld a, (.dmark+1)  
49f3 32 5f ee			ld (debug_mark+1),a  
49f6 3a 00 4a			ld a, (.dmark+2)  
49f9 32 60 ee			ld (debug_mark+2),a  
49fc 18 03			jr .pastdmark  
49fe ..			.dmark: db "RI2"  
4a01 f1			.pastdmark: pop af  
4a02			endm  
# End of macro DMARK
4a02						CALLMONITOR 
4a02 cd 6b ee			call debug_vector  
4a05				endm  
# End of macro CALLMONITOR
4a05					endif 
4a05			 
4a05 c1					pop bc    ;  length of string to copy 
4a06			 
4a06 79					ld a, c 
4a07 eb					ex de, hl 
4a08 21 b4 e2				ld hl, scratch  
4a0b cd e6 0d				call addatohl 
4a0e			 
4a0e eb					ex de, hl 
4a0f			 
4a0f					if DEBUG_FORTH_WORDS 
4a0f						DMARK "RI3" 
4a0f f5				push af  
4a10 3a 24 4a			ld a, (.dmark)  
4a13 32 5e ee			ld (debug_mark),a  
4a16 3a 25 4a			ld a, (.dmark+1)  
4a19 32 5f ee			ld (debug_mark+1),a  
4a1c 3a 26 4a			ld a, (.dmark+2)  
4a1f 32 60 ee			ld (debug_mark+2),a  
4a22 18 03			jr .pastdmark  
4a24 ..			.dmark: db "RI3"  
4a27 f1			.pastdmark: pop af  
4a28			endm  
# End of macro DMARK
4a28						CALLMONITOR 
4a28 cd 6b ee			call debug_vector  
4a2b				endm  
# End of macro CALLMONITOR
4a2b					endif 
4a2b			 
4a2b 03					inc bc 
4a2c ed b8				lddr 
4a2e					 
4a2e 21 b4 e2				ld hl, scratch 
4a31					if DEBUG_FORTH_WORDS 
4a31						DMARK "RI4" 
4a31 f5				push af  
4a32 3a 46 4a			ld a, (.dmark)  
4a35 32 5e ee			ld (debug_mark),a  
4a38 3a 47 4a			ld a, (.dmark+1)  
4a3b 32 5f ee			ld (debug_mark+1),a  
4a3e 3a 48 4a			ld a, (.dmark+2)  
4a41 32 60 ee			ld (debug_mark+2),a  
4a44 18 03			jr .pastdmark  
4a46 ..			.dmark: db "RI4"  
4a49 f1			.pastdmark: pop af  
4a4a			endm  
# End of macro DMARK
4a4a						CALLMONITOR 
4a4a cd 6b ee			call debug_vector  
4a4d				endm  
# End of macro CALLMONITOR
4a4d					endif 
4a4d cd 41 1b				call forth_push_str 
4a50			 
4a50			 
4a50					NEXTW 
4a50 cd 68 ee			call parse_vector 
4a53 c3 ba 1e			jp macro_next 
4a56				endm 
# End of macro NEXTW
4a56			 
4a56			 
4a56			.STR2NUM: 
4a56				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
4a56 48				db WORD_SYS_CORE+52             
4a57 e5 4a			dw .NUM2STR            
4a59 08				db 7 + 1 
4a5a .. 00			db "STR2NUM",0              
4a62				endm 
# End of macro CWHEAD
4a62			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
4a62			 
4a62			 
4a62			; TODO STR type check to do 
4a62					if DEBUG_FORTH_WORDS_KEY 
4a62						DMARK "S2N" 
4a62 f5				push af  
4a63 3a 77 4a			ld a, (.dmark)  
4a66 32 5e ee			ld (debug_mark),a  
4a69 3a 78 4a			ld a, (.dmark+1)  
4a6c 32 5f ee			ld (debug_mark+1),a  
4a6f 3a 79 4a			ld a, (.dmark+2)  
4a72 32 60 ee			ld (debug_mark+2),a  
4a75 18 03			jr .pastdmark  
4a77 ..			.dmark: db "S2N"  
4a7a f1			.pastdmark: pop af  
4a7b			endm  
# End of macro DMARK
4a7b						CALLMONITOR 
4a7b cd 6b ee			call debug_vector  
4a7e				endm  
# End of macro CALLMONITOR
4a7e					endif 
4a7e			 
4a7e					;FORTH_DSP 
4a7e					FORTH_DSP_VALUE 
4a7e cd bc 1c			call macro_forth_dsp_value 
4a81				endm 
# End of macro FORTH_DSP_VALUE
4a81					;inc hl 
4a81			 
4a81 eb					ex de, hl 
4a82					if DEBUG_FORTH_WORDS 
4a82						DMARK "S2a" 
4a82 f5				push af  
4a83 3a 97 4a			ld a, (.dmark)  
4a86 32 5e ee			ld (debug_mark),a  
4a89 3a 98 4a			ld a, (.dmark+1)  
4a8c 32 5f ee			ld (debug_mark+1),a  
4a8f 3a 99 4a			ld a, (.dmark+2)  
4a92 32 60 ee			ld (debug_mark+2),a  
4a95 18 03			jr .pastdmark  
4a97 ..			.dmark: db "S2a"  
4a9a f1			.pastdmark: pop af  
4a9b			endm  
# End of macro DMARK
4a9b						CALLMONITOR 
4a9b cd 6b ee			call debug_vector  
4a9e				endm  
# End of macro CALLMONITOR
4a9e					endif 
4a9e cd d5 10				call string_to_uint16 
4aa1			 
4aa1					if DEBUG_FORTH_WORDS 
4aa1						DMARK "S2b" 
4aa1 f5				push af  
4aa2 3a b6 4a			ld a, (.dmark)  
4aa5 32 5e ee			ld (debug_mark),a  
4aa8 3a b7 4a			ld a, (.dmark+1)  
4aab 32 5f ee			ld (debug_mark+1),a  
4aae 3a b8 4a			ld a, (.dmark+2)  
4ab1 32 60 ee			ld (debug_mark+2),a  
4ab4 18 03			jr .pastdmark  
4ab6 ..			.dmark: db "S2b"  
4ab9 f1			.pastdmark: pop af  
4aba			endm  
# End of macro DMARK
4aba						CALLMONITOR 
4aba cd 6b ee			call debug_vector  
4abd				endm  
# End of macro CALLMONITOR
4abd					endif 
4abd			;		push hl 
4abd					FORTH_DSP_POP 
4abd cd 8b 1d			call macro_forth_dsp_pop 
4ac0				endm 
# End of macro FORTH_DSP_POP
4ac0			;		pop hl 
4ac0					 
4ac0					if DEBUG_FORTH_WORDS 
4ac0						DMARK "S2b" 
4ac0 f5				push af  
4ac1 3a d5 4a			ld a, (.dmark)  
4ac4 32 5e ee			ld (debug_mark),a  
4ac7 3a d6 4a			ld a, (.dmark+1)  
4aca 32 5f ee			ld (debug_mark+1),a  
4acd 3a d7 4a			ld a, (.dmark+2)  
4ad0 32 60 ee			ld (debug_mark+2),a  
4ad3 18 03			jr .pastdmark  
4ad5 ..			.dmark: db "S2b"  
4ad8 f1			.pastdmark: pop af  
4ad9			endm  
# End of macro DMARK
4ad9						CALLMONITOR 
4ad9 cd 6b ee			call debug_vector  
4adc				endm  
# End of macro CALLMONITOR
4adc					endif 
4adc cd d7 1a				call forth_push_numhl	 
4adf			 
4adf				 
4adf				       NEXTW 
4adf cd 68 ee			call parse_vector 
4ae2 c3 ba 1e			jp macro_next 
4ae5				endm 
# End of macro NEXTW
4ae5			.NUM2STR: 
4ae5				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
4ae5 48				db WORD_SYS_CORE+52             
4ae6 7a 4b			dw .CONCAT            
4ae8 08				db 7 + 1 
4ae9 .. 00			db "NUM2STR",0              
4af1				endm 
# End of macro CWHEAD
4af1			; | NUM2STR ( n -- s ) Convert a number on TOS to zero padded string | DONE 
4af1			 
4af1			;		; malloc a string to target 
4af1			;		ld hl, 10     ; TODO max string size should be fine 
4af1			;		call malloc 
4af1			;		push hl    ; save malloc location 
4af1			; 
4af1			; 
4af1			;; TODO check int type 
4af1					if DEBUG_FORTH_WORDS_KEY 
4af1						DMARK "N2S" 
4af1 f5				push af  
4af2 3a 06 4b			ld a, (.dmark)  
4af5 32 5e ee			ld (debug_mark),a  
4af8 3a 07 4b			ld a, (.dmark+1)  
4afb 32 5f ee			ld (debug_mark+1),a  
4afe 3a 08 4b			ld a, (.dmark+2)  
4b01 32 60 ee			ld (debug_mark+2),a  
4b04 18 03			jr .pastdmark  
4b06 ..			.dmark: db "N2S"  
4b09 f1			.pastdmark: pop af  
4b0a			endm  
# End of macro DMARK
4b0a						CALLMONITOR 
4b0a cd 6b ee			call debug_vector  
4b0d				endm  
# End of macro CALLMONITOR
4b0d					endif 
4b0d			 
4b0d					FORTH_DSP_VALUEHL 
4b0d cd d3 1c			call macro_dsp_valuehl 
4b10				endm 
# End of macro FORTH_DSP_VALUEHL
4b10			 
4b10					if DEBUG_FORTH_WORDS 
4b10						DMARK "NS1" 
4b10 f5				push af  
4b11 3a 25 4b			ld a, (.dmark)  
4b14 32 5e ee			ld (debug_mark),a  
4b17 3a 26 4b			ld a, (.dmark+1)  
4b1a 32 5f ee			ld (debug_mark+1),a  
4b1d 3a 27 4b			ld a, (.dmark+2)  
4b20 32 60 ee			ld (debug_mark+2),a  
4b23 18 03			jr .pastdmark  
4b25 ..			.dmark: db "NS1"  
4b28 f1			.pastdmark: pop af  
4b29			endm  
# End of macro DMARK
4b29						CALLMONITOR 
4b29 cd 6b ee			call debug_vector  
4b2c				endm  
# End of macro CALLMONITOR
4b2c					endif 
4b2c					FORTH_DSP_POP 
4b2c cd 8b 1d			call macro_forth_dsp_pop 
4b2f				endm 
# End of macro FORTH_DSP_POP
4b2f			 
4b2f eb					ex de, hl 
4b30 21 b4 e2				ld hl, scratch 
4b33					if DEBUG_FORTH_WORDS 
4b33						DMARK "NS2" 
4b33 f5				push af  
4b34 3a 48 4b			ld a, (.dmark)  
4b37 32 5e ee			ld (debug_mark),a  
4b3a 3a 49 4b			ld a, (.dmark+1)  
4b3d 32 5f ee			ld (debug_mark+1),a  
4b40 3a 4a 4b			ld a, (.dmark+2)  
4b43 32 60 ee			ld (debug_mark+2),a  
4b46 18 03			jr .pastdmark  
4b48 ..			.dmark: db "NS2"  
4b4b f1			.pastdmark: pop af  
4b4c			endm  
# End of macro DMARK
4b4c						CALLMONITOR 
4b4c cd 6b ee			call debug_vector  
4b4f				endm  
# End of macro CALLMONITOR
4b4f					endif 
4b4f cd ed 10				call uitoa_16 
4b52 21 b4 e2				ld hl, scratch 
4b55					if DEBUG_FORTH_WORDS 
4b55						DMARK "NS3" 
4b55 f5				push af  
4b56 3a 6a 4b			ld a, (.dmark)  
4b59 32 5e ee			ld (debug_mark),a  
4b5c 3a 6b 4b			ld a, (.dmark+1)  
4b5f 32 5f ee			ld (debug_mark+1),a  
4b62 3a 6c 4b			ld a, (.dmark+2)  
4b65 32 60 ee			ld (debug_mark+2),a  
4b68 18 03			jr .pastdmark  
4b6a ..			.dmark: db "NS3"  
4b6d f1			.pastdmark: pop af  
4b6e			endm  
# End of macro DMARK
4b6e						CALLMONITOR 
4b6e cd 6b ee			call debug_vector  
4b71				endm  
# End of macro CALLMONITOR
4b71					endif 
4b71 cd 41 1b				call forth_push_str 
4b74			;		ld a, l 
4b74			;		call DispAToASCII   
4b74			;;TODO need to chage above call to dump into string 
4b74			; 
4b74			; 
4b74			 
4b74				       NEXTW 
4b74 cd 68 ee			call parse_vector 
4b77 c3 ba 1e			jp macro_next 
4b7a				endm 
# End of macro NEXTW
4b7a			 
4b7a			.CONCAT: 
4b7a				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
4b7a 48				db WORD_SYS_CORE+52             
4b7b 30 4c			dw .FIND            
4b7d 07				db 6 + 1 
4b7e .. 00			db "CONCAT",0              
4b85				endm 
# End of macro CWHEAD
4b85			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
4b85			 
4b85			; TODO check string type 
4b85			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
4b85			 
4b85					if DEBUG_FORTH_WORDS_KEY 
4b85						DMARK "CON" 
4b85 f5				push af  
4b86 3a 9a 4b			ld a, (.dmark)  
4b89 32 5e ee			ld (debug_mark),a  
4b8c 3a 9b 4b			ld a, (.dmark+1)  
4b8f 32 5f ee			ld (debug_mark+1),a  
4b92 3a 9c 4b			ld a, (.dmark+2)  
4b95 32 60 ee			ld (debug_mark+2),a  
4b98 18 03			jr .pastdmark  
4b9a ..			.dmark: db "CON"  
4b9d f1			.pastdmark: pop af  
4b9e			endm  
# End of macro DMARK
4b9e						CALLMONITOR 
4b9e cd 6b ee			call debug_vector  
4ba1				endm  
# End of macro CALLMONITOR
4ba1					endif 
4ba1			 
4ba1			 
4ba1					FORTH_DSP_VALUE 
4ba1 cd bc 1c			call macro_forth_dsp_value 
4ba4				endm 
# End of macro FORTH_DSP_VALUE
4ba4 e5					push hl   ; s2 
4ba5			 
4ba5					FORTH_DSP_POP 
4ba5 cd 8b 1d			call macro_forth_dsp_pop 
4ba8				endm 
# End of macro FORTH_DSP_POP
4ba8			 
4ba8					FORTH_DSP_VALUE 
4ba8 cd bc 1c			call macro_forth_dsp_value 
4bab				endm 
# End of macro FORTH_DSP_VALUE
4bab			 
4bab e5					push hl   ; s1 
4bac			 
4bac					FORTH_DSP_POP 
4bac cd 8b 1d			call macro_forth_dsp_pop 
4baf				endm 
# End of macro FORTH_DSP_POP
4baf					 
4baf			 
4baf					; copy s1 
4baf			 
4baf				 
4baf					; save ptr 
4baf e1					pop hl  
4bb0 e5					push hl 
4bb1 3e 00				ld a, 0 
4bb3 cd 49 11				call strlent 
4bb6					;inc hl    ; zer0 
4bb6 06 00				ld b, 0 
4bb8 4d					ld c, l 
4bb9 e1					pop hl		 
4bba 11 b4 e2				ld de, scratch	 
4bbd					if DEBUG_FORTH_WORDS 
4bbd						DMARK "CO1" 
4bbd f5				push af  
4bbe 3a d2 4b			ld a, (.dmark)  
4bc1 32 5e ee			ld (debug_mark),a  
4bc4 3a d3 4b			ld a, (.dmark+1)  
4bc7 32 5f ee			ld (debug_mark+1),a  
4bca 3a d4 4b			ld a, (.dmark+2)  
4bcd 32 60 ee			ld (debug_mark+2),a  
4bd0 18 03			jr .pastdmark  
4bd2 ..			.dmark: db "CO1"  
4bd5 f1			.pastdmark: pop af  
4bd6			endm  
# End of macro DMARK
4bd6						CALLMONITOR 
4bd6 cd 6b ee			call debug_vector  
4bd9				endm  
# End of macro CALLMONITOR
4bd9					endif 
4bd9 ed b0				ldir 
4bdb			 
4bdb e1					pop hl 
4bdc e5					push hl 
4bdd d5					push de 
4bde			 
4bde			 
4bde 3e 00				ld a, 0 
4be0 cd 49 11				call strlent 
4be3 23					inc hl    ; zer0 
4be4 23					inc hl 
4be5 06 00				ld b, 0 
4be7 4d					ld c, l 
4be8 d1					pop de 
4be9 e1					pop hl		 
4bea					if DEBUG_FORTH_WORDS 
4bea						DMARK "CO2" 
4bea f5				push af  
4beb 3a ff 4b			ld a, (.dmark)  
4bee 32 5e ee			ld (debug_mark),a  
4bf1 3a 00 4c			ld a, (.dmark+1)  
4bf4 32 5f ee			ld (debug_mark+1),a  
4bf7 3a 01 4c			ld a, (.dmark+2)  
4bfa 32 60 ee			ld (debug_mark+2),a  
4bfd 18 03			jr .pastdmark  
4bff ..			.dmark: db "CO2"  
4c02 f1			.pastdmark: pop af  
4c03			endm  
# End of macro DMARK
4c03						CALLMONITOR 
4c03 cd 6b ee			call debug_vector  
4c06				endm  
# End of macro CALLMONITOR
4c06					endif 
4c06 ed b0				ldir 
4c08			 
4c08			 
4c08			 
4c08 21 b4 e2				ld hl, scratch 
4c0b					if DEBUG_FORTH_WORDS 
4c0b						DMARK "CO5" 
4c0b f5				push af  
4c0c 3a 20 4c			ld a, (.dmark)  
4c0f 32 5e ee			ld (debug_mark),a  
4c12 3a 21 4c			ld a, (.dmark+1)  
4c15 32 5f ee			ld (debug_mark+1),a  
4c18 3a 22 4c			ld a, (.dmark+2)  
4c1b 32 60 ee			ld (debug_mark+2),a  
4c1e 18 03			jr .pastdmark  
4c20 ..			.dmark: db "CO5"  
4c23 f1			.pastdmark: pop af  
4c24			endm  
# End of macro DMARK
4c24						CALLMONITOR 
4c24 cd 6b ee			call debug_vector  
4c27				endm  
# End of macro CALLMONITOR
4c27					endif 
4c27			 
4c27 cd 41 1b				call forth_push_str 
4c2a			 
4c2a			 
4c2a			 
4c2a			 
4c2a				       NEXTW 
4c2a cd 68 ee			call parse_vector 
4c2d c3 ba 1e			jp macro_next 
4c30				endm 
# End of macro NEXTW
4c30			 
4c30			 
4c30			.FIND: 
4c30				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
4c30 4b				db WORD_SYS_CORE+55             
4c31 f0 4c			dw .LEN            
4c33 05				db 4 + 1 
4c34 .. 00			db "FIND",0              
4c39				endm 
# End of macro CWHEAD
4c39			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
4c39			 
4c39					if DEBUG_FORTH_WORDS_KEY 
4c39						DMARK "FND" 
4c39 f5				push af  
4c3a 3a 4e 4c			ld a, (.dmark)  
4c3d 32 5e ee			ld (debug_mark),a  
4c40 3a 4f 4c			ld a, (.dmark+1)  
4c43 32 5f ee			ld (debug_mark+1),a  
4c46 3a 50 4c			ld a, (.dmark+2)  
4c49 32 60 ee			ld (debug_mark+2),a  
4c4c 18 03			jr .pastdmark  
4c4e ..			.dmark: db "FND"  
4c51 f1			.pastdmark: pop af  
4c52			endm  
# End of macro DMARK
4c52						CALLMONITOR 
4c52 cd 6b ee			call debug_vector  
4c55				endm  
# End of macro CALLMONITOR
4c55					endif 
4c55			 
4c55			; TODO check string type 
4c55					FORTH_DSP_VALUE 
4c55 cd bc 1c			call macro_forth_dsp_value 
4c58				endm 
# End of macro FORTH_DSP_VALUE
4c58			 
4c58 e5					push hl    
4c59 7e					ld a,(hl)    ; char to find   
4c5a			; TODO change char to substr 
4c5a			 
4c5a f5					push af 
4c5b					 
4c5b			 
4c5b			 
4c5b					if DEBUG_FORTH_WORDS 
4c5b						DMARK "FN1" 
4c5b f5				push af  
4c5c 3a 70 4c			ld a, (.dmark)  
4c5f 32 5e ee			ld (debug_mark),a  
4c62 3a 71 4c			ld a, (.dmark+1)  
4c65 32 5f ee			ld (debug_mark+1),a  
4c68 3a 72 4c			ld a, (.dmark+2)  
4c6b 32 60 ee			ld (debug_mark+2),a  
4c6e 18 03			jr .pastdmark  
4c70 ..			.dmark: db "FN1"  
4c73 f1			.pastdmark: pop af  
4c74			endm  
# End of macro DMARK
4c74						CALLMONITOR 
4c74 cd 6b ee			call debug_vector  
4c77				endm  
# End of macro CALLMONITOR
4c77					endif 
4c77			 
4c77					FORTH_DSP_POP 
4c77 cd 8b 1d			call macro_forth_dsp_pop 
4c7a				endm 
# End of macro FORTH_DSP_POP
4c7a			 
4c7a					; string to search 
4c7a			 
4c7a					FORTH_DSP_VALUE 
4c7a cd bc 1c			call macro_forth_dsp_value 
4c7d				endm 
# End of macro FORTH_DSP_VALUE
4c7d			 
4c7d d1					pop de  ; d is char to find  
4c7e			 
4c7e					if DEBUG_FORTH_WORDS 
4c7e						DMARK "FN2" 
4c7e f5				push af  
4c7f 3a 93 4c			ld a, (.dmark)  
4c82 32 5e ee			ld (debug_mark),a  
4c85 3a 94 4c			ld a, (.dmark+1)  
4c88 32 5f ee			ld (debug_mark+1),a  
4c8b 3a 95 4c			ld a, (.dmark+2)  
4c8e 32 60 ee			ld (debug_mark+2),a  
4c91 18 03			jr .pastdmark  
4c93 ..			.dmark: db "FN2"  
4c96 f1			.pastdmark: pop af  
4c97			endm  
# End of macro DMARK
4c97						CALLMONITOR 
4c97 cd 6b ee			call debug_vector  
4c9a				endm  
# End of macro CALLMONITOR
4c9a					endif 
4c9a					 
4c9a 01 00 00				ld bc, 0 
4c9d 7e			.findchar:      ld a,(hl) 
4c9e			;		cp 0   		 
4c9e b7					or a 
4c9f 28 27				jr z, .finddone     
4ca1 ba					cp d 
4ca2 28 20				jr z, .foundchar 
4ca4 03					inc bc 
4ca5 23					inc hl 
4ca6					if DEBUG_FORTH_WORDS 
4ca6						DMARK "FN3" 
4ca6 f5				push af  
4ca7 3a bb 4c			ld a, (.dmark)  
4caa 32 5e ee			ld (debug_mark),a  
4cad 3a bc 4c			ld a, (.dmark+1)  
4cb0 32 5f ee			ld (debug_mark+1),a  
4cb3 3a bd 4c			ld a, (.dmark+2)  
4cb6 32 60 ee			ld (debug_mark+2),a  
4cb9 18 03			jr .pastdmark  
4cbb ..			.dmark: db "FN3"  
4cbe f1			.pastdmark: pop af  
4cbf			endm  
# End of macro DMARK
4cbf						CALLMONITOR 
4cbf cd 6b ee			call debug_vector  
4cc2				endm  
# End of macro CALLMONITOR
4cc2					endif 
4cc2 18 d9				jr .findchar 
4cc4			 
4cc4			 
4cc4 c5			.foundchar:	push bc 
4cc5 e1					pop hl 
4cc6 18 03				jr .findexit 
4cc8			 
4cc8			 
4cc8							 
4cc8			 
4cc8			.finddone:     ; got to end of string with no find 
4cc8 21 00 00				ld hl, 0 
4ccb			.findexit: 
4ccb			 
4ccb					if DEBUG_FORTH_WORDS 
4ccb						DMARK "FNd" 
4ccb f5				push af  
4ccc 3a e0 4c			ld a, (.dmark)  
4ccf 32 5e ee			ld (debug_mark),a  
4cd2 3a e1 4c			ld a, (.dmark+1)  
4cd5 32 5f ee			ld (debug_mark+1),a  
4cd8 3a e2 4c			ld a, (.dmark+2)  
4cdb 32 60 ee			ld (debug_mark+2),a  
4cde 18 03			jr .pastdmark  
4ce0 ..			.dmark: db "FNd"  
4ce3 f1			.pastdmark: pop af  
4ce4			endm  
# End of macro DMARK
4ce4						CALLMONITOR 
4ce4 cd 6b ee			call debug_vector  
4ce7				endm  
# End of macro CALLMONITOR
4ce7					endif 
4ce7 cd d7 1a			call forth_push_numhl 
4cea			 
4cea				       NEXTW 
4cea cd 68 ee			call parse_vector 
4ced c3 ba 1e			jp macro_next 
4cf0				endm 
# End of macro NEXTW
4cf0			 
4cf0			.LEN: 
4cf0				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
4cf0 4c				db WORD_SYS_CORE+56             
4cf1 5d 4d			dw .ASC            
4cf3 06				db 5 + 1 
4cf4 .. 00			db "COUNT",0              
4cfa				endm 
# End of macro CWHEAD
4cfa			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
4cfa			 
4cfa					if DEBUG_FORTH_WORDS_KEY 
4cfa						DMARK "CNT" 
4cfa f5				push af  
4cfb 3a 0f 4d			ld a, (.dmark)  
4cfe 32 5e ee			ld (debug_mark),a  
4d01 3a 10 4d			ld a, (.dmark+1)  
4d04 32 5f ee			ld (debug_mark+1),a  
4d07 3a 11 4d			ld a, (.dmark+2)  
4d0a 32 60 ee			ld (debug_mark+2),a  
4d0d 18 03			jr .pastdmark  
4d0f ..			.dmark: db "CNT"  
4d12 f1			.pastdmark: pop af  
4d13			endm  
# End of macro DMARK
4d13						CALLMONITOR 
4d13 cd 6b ee			call debug_vector  
4d16				endm  
# End of macro CALLMONITOR
4d16					endif 
4d16			; TODO check string type 
4d16					FORTH_DSP_VALUE 
4d16 cd bc 1c			call macro_forth_dsp_value 
4d19				endm 
# End of macro FORTH_DSP_VALUE
4d19			 
4d19			 
4d19					if DEBUG_FORTH_WORDS 
4d19						DMARK "CN?" 
4d19 f5				push af  
4d1a 3a 2e 4d			ld a, (.dmark)  
4d1d 32 5e ee			ld (debug_mark),a  
4d20 3a 2f 4d			ld a, (.dmark+1)  
4d23 32 5f ee			ld (debug_mark+1),a  
4d26 3a 30 4d			ld a, (.dmark+2)  
4d29 32 60 ee			ld (debug_mark+2),a  
4d2c 18 03			jr .pastdmark  
4d2e ..			.dmark: db "CN?"  
4d31 f1			.pastdmark: pop af  
4d32			endm  
# End of macro DMARK
4d32						CALLMONITOR 
4d32 cd 6b ee			call debug_vector  
4d35				endm  
# End of macro CALLMONITOR
4d35					endif 
4d35 cd 3e 11				call strlenz 
4d38					if DEBUG_FORTH_WORDS 
4d38						DMARK "CNl" 
4d38 f5				push af  
4d39 3a 4d 4d			ld a, (.dmark)  
4d3c 32 5e ee			ld (debug_mark),a  
4d3f 3a 4e 4d			ld a, (.dmark+1)  
4d42 32 5f ee			ld (debug_mark+1),a  
4d45 3a 4f 4d			ld a, (.dmark+2)  
4d48 32 60 ee			ld (debug_mark+2),a  
4d4b 18 03			jr .pastdmark  
4d4d ..			.dmark: db "CNl"  
4d50 f1			.pastdmark: pop af  
4d51			endm  
# End of macro DMARK
4d51						CALLMONITOR 
4d51 cd 6b ee			call debug_vector  
4d54				endm  
# End of macro CALLMONITOR
4d54					endif 
4d54			 
4d54 cd d7 1a				call forth_push_numhl 
4d57			 
4d57			 
4d57			 
4d57				       NEXTW 
4d57 cd 68 ee			call parse_vector 
4d5a c3 ba 1e			jp macro_next 
4d5d				endm 
# End of macro NEXTW
4d5d			.ASC: 
4d5d				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
4d5d 4d				db WORD_SYS_CORE+57             
4d5e ce 4d			dw .CHR            
4d60 04				db 3 + 1 
4d61 .. 00			db "ASC",0              
4d65				endm 
# End of macro CWHEAD
4d65			; | ASC ( u -- n ) Get the ASCII value of the first character of the string on TOS | DONE 
4d65					if DEBUG_FORTH_WORDS_KEY 
4d65						DMARK "ASC" 
4d65 f5				push af  
4d66 3a 7a 4d			ld a, (.dmark)  
4d69 32 5e ee			ld (debug_mark),a  
4d6c 3a 7b 4d			ld a, (.dmark+1)  
4d6f 32 5f ee			ld (debug_mark+1),a  
4d72 3a 7c 4d			ld a, (.dmark+2)  
4d75 32 60 ee			ld (debug_mark+2),a  
4d78 18 03			jr .pastdmark  
4d7a ..			.dmark: db "ASC"  
4d7d f1			.pastdmark: pop af  
4d7e			endm  
# End of macro DMARK
4d7e						CALLMONITOR 
4d7e cd 6b ee			call debug_vector  
4d81				endm  
# End of macro CALLMONITOR
4d81					endif 
4d81					FORTH_DSP_VALUE 
4d81 cd bc 1c			call macro_forth_dsp_value 
4d84				endm 
# End of macro FORTH_DSP_VALUE
4d84					;v5 FORTH_DSP_VALUE 
4d84			;		inc hl      ; now at start of numeric as string 
4d84			 
4d84 e5					push hl 
4d85			 
4d85					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4d85 cd 8b 1d			call macro_forth_dsp_pop 
4d88				endm 
# End of macro FORTH_DSP_POP
4d88			 
4d88 e1					pop hl 
4d89			 
4d89					if DEBUG_FORTH_WORDS 
4d89						DMARK "AS1" 
4d89 f5				push af  
4d8a 3a 9e 4d			ld a, (.dmark)  
4d8d 32 5e ee			ld (debug_mark),a  
4d90 3a 9f 4d			ld a, (.dmark+1)  
4d93 32 5f ee			ld (debug_mark+1),a  
4d96 3a a0 4d			ld a, (.dmark+2)  
4d99 32 60 ee			ld (debug_mark+2),a  
4d9c 18 03			jr .pastdmark  
4d9e ..			.dmark: db "AS1"  
4da1 f1			.pastdmark: pop af  
4da2			endm  
# End of macro DMARK
4da2						CALLMONITOR 
4da2 cd 6b ee			call debug_vector  
4da5				endm  
# End of macro CALLMONITOR
4da5					endif 
4da5					; push the content of a onto the stack as a value 
4da5			 
4da5 7e					ld a,(hl)   ; get char 
4da6 26 00				ld h,0 
4da8 6f					ld l,a 
4da9					if DEBUG_FORTH_WORDS 
4da9						DMARK "AS2" 
4da9 f5				push af  
4daa 3a be 4d			ld a, (.dmark)  
4dad 32 5e ee			ld (debug_mark),a  
4db0 3a bf 4d			ld a, (.dmark+1)  
4db3 32 5f ee			ld (debug_mark+1),a  
4db6 3a c0 4d			ld a, (.dmark+2)  
4db9 32 60 ee			ld (debug_mark+2),a  
4dbc 18 03			jr .pastdmark  
4dbe ..			.dmark: db "AS2"  
4dc1 f1			.pastdmark: pop af  
4dc2			endm  
# End of macro DMARK
4dc2						CALLMONITOR 
4dc2 cd 6b ee			call debug_vector  
4dc5				endm  
# End of macro CALLMONITOR
4dc5					endif 
4dc5 cd d7 1a				call forth_push_numhl 
4dc8			 
4dc8				       NEXTW 
4dc8 cd 68 ee			call parse_vector 
4dcb c3 ba 1e			jp macro_next 
4dce				endm 
# End of macro NEXTW
4dce			 
4dce			.CHR: 
4dce				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
4dce 4d				db WORD_SYS_CORE+57             
4dcf 0d 4e			dw .ENDSTR            
4dd1 04				db 3 + 1 
4dd2 .. 00			db "CHR",0              
4dd6				endm 
# End of macro CWHEAD
4dd6			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
4dd6					if DEBUG_FORTH_WORDS_KEY 
4dd6						DMARK "CHR" 
4dd6 f5				push af  
4dd7 3a eb 4d			ld a, (.dmark)  
4dda 32 5e ee			ld (debug_mark),a  
4ddd 3a ec 4d			ld a, (.dmark+1)  
4de0 32 5f ee			ld (debug_mark+1),a  
4de3 3a ed 4d			ld a, (.dmark+2)  
4de6 32 60 ee			ld (debug_mark+2),a  
4de9 18 03			jr .pastdmark  
4deb ..			.dmark: db "CHR"  
4dee f1			.pastdmark: pop af  
4def			endm  
# End of macro DMARK
4def						CALLMONITOR 
4def cd 6b ee			call debug_vector  
4df2				endm  
# End of macro CALLMONITOR
4df2					endif 
4df2					FORTH_DSP_VALUEHL 
4df2 cd d3 1c			call macro_dsp_valuehl 
4df5				endm 
# End of macro FORTH_DSP_VALUEHL
4df5			 
4df5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4df5 cd 8b 1d			call macro_forth_dsp_pop 
4df8				endm 
# End of macro FORTH_DSP_POP
4df8			 
4df8					; save asci byte as a zero term string and push string 
4df8			 
4df8 7d					ld a,l 
4df9 32 b4 e2				ld (scratch), a 
4dfc			 
4dfc 3e 00				ld a, 0 
4dfe 32 b5 e2				ld (scratch+1), a 
4e01			 
4e01 21 b4 e2				ld hl, scratch 
4e04 cd 41 1b				call forth_push_str 
4e07			 
4e07			 
4e07				       NEXTW 
4e07 cd 68 ee			call parse_vector 
4e0a c3 ba 1e			jp macro_next 
4e0d				endm 
# End of macro NEXTW
4e0d			 
4e0d			 
4e0d			 
4e0d			 
4e0d			.ENDSTR: 
4e0d			; eof 
4e0d			 
# End of file forth_words_str.asm
4e0d			include "forth_words_key.asm" 
4e0d			 
4e0d			; | ## Keyboard Words 
4e0d			 
4e0d			.MACRO: 
4e0d			 
4e0d				CWHEAD .KEY 42 "MACRO" 5 WORD_FLAG_CODE 
4e0d 3e				db WORD_SYS_CORE+42             
4e0e 39 4e			dw .KEY            
4e10 06				db 5 + 1 
4e11 .. 00			db "MACRO",0              
4e17				endm 
# End of macro CWHEAD
4e17			; | MACRO ( s u -- ) Maps a string s against a key code u for use in the editor functions (CLI/EDIT/ACCEPT)  | TODO 
4e17			 
4e17					if DEBUG_FORTH_WORDS_KEY 
4e17						DMARK "MAC" 
4e17 f5				push af  
4e18 3a 2c 4e			ld a, (.dmark)  
4e1b 32 5e ee			ld (debug_mark),a  
4e1e 3a 2d 4e			ld a, (.dmark+1)  
4e21 32 5f ee			ld (debug_mark+1),a  
4e24 3a 2e 4e			ld a, (.dmark+2)  
4e27 32 60 ee			ld (debug_mark+2),a  
4e2a 18 03			jr .pastdmark  
4e2c ..			.dmark: db "MAC"  
4e2f f1			.pastdmark: pop af  
4e30			endm  
# End of macro DMARK
4e30						CALLMONITOR 
4e30 cd 6b ee			call debug_vector  
4e33				endm  
# End of macro CALLMONITOR
4e33					endif 
4e33			 
4e33					; get key code 
4e33					; calc string length 
4e33					; malloc string size 
4e33					; copy string 
4e33					; patch keyboard scan 
4e33			 
4e33					; maintain a linked list?  
4e33					; need a structure for root of key mappings 
4e33					; hold last defined macro so that link can be made to the next one 
4e33					; key_macroroot   is the first one 
4e33					; key_macrolast is location of the last macro defined 
4e33			 
4e33			 
4e33					NEXTW 
4e33 cd 68 ee			call parse_vector 
4e36 c3 ba 1e			jp macro_next 
4e39				endm 
# End of macro NEXTW
4e39			 
4e39			.KEY: 
4e39				CWHEAD .KEYDB 42 "KEY" 3 WORD_FLAG_CODE 
4e39 3e				db WORD_SYS_CORE+42             
4e3a 6c 4e			dw .KEYDB            
4e3c 04				db 3 + 1 
4e3d .. 00			db "KEY",0              
4e41				endm 
# End of macro CWHEAD
4e41			; | KEY ( -- u ) A non-blocking read of keypress | DONE 
4e41			; | | The ASCII key (or key code) is pushed to stack. If no key is currently held down then push a 0 
4e41			; | | Can use something like this to process: 
4e41			; | | > repeat active . key ?dup if emit then #1 until  
4e41			 
4e41					if DEBUG_FORTH_WORDS_KEY 
4e41						DMARK "KEY" 
4e41 f5				push af  
4e42 3a 56 4e			ld a, (.dmark)  
4e45 32 5e ee			ld (debug_mark),a  
4e48 3a 57 4e			ld a, (.dmark+1)  
4e4b 32 5f ee			ld (debug_mark+1),a  
4e4e 3a 58 4e			ld a, (.dmark+2)  
4e51 32 60 ee			ld (debug_mark+2),a  
4e54 18 03			jr .pastdmark  
4e56 ..			.dmark: db "KEY"  
4e59 f1			.pastdmark: pop af  
4e5a			endm  
# End of macro DMARK
4e5a						CALLMONITOR 
4e5a cd 6b ee			call debug_vector  
4e5d				endm  
# End of macro CALLMONITOR
4e5d					endif 
4e5d			; TODO currently waits 
4e5d cd 86 67				call cinndb 
4e60					;call cin_wait 
4e60 6f					ld l, a 
4e61 26 00				ld h, 0 
4e63 cd d7 1a				call forth_push_numhl 
4e66					NEXTW 
4e66 cd 68 ee			call parse_vector 
4e69 c3 ba 1e			jp macro_next 
4e6c				endm 
# End of macro NEXTW
4e6c			.KEYDB: 
4e6c				CWHEAD .WAITK 42 "KEYDB" 5 WORD_FLAG_CODE 
4e6c 3e				db WORD_SYS_CORE+42             
4e6d a1 4e			dw .WAITK            
4e6f 06				db 5 + 1 
4e70 .. 00			db "KEYDB",0              
4e76				endm 
# End of macro CWHEAD
4e76			; | KEYDB ( -- u ) A non-blocking read of keypress with key release debounce | DONE 
4e76			; | | The ASCII key (or key code) is pushed to stack. If no key is currently held down then push a 0 
4e76			; | | Can use something like this to process: 
4e76			; | | > repeat active . key ?dup if emit then #1 until  
4e76			 
4e76					if DEBUG_FORTH_WORDS_KEY 
4e76						DMARK "KEB" 
4e76 f5				push af  
4e77 3a 8b 4e			ld a, (.dmark)  
4e7a 32 5e ee			ld (debug_mark),a  
4e7d 3a 8c 4e			ld a, (.dmark+1)  
4e80 32 5f ee			ld (debug_mark+1),a  
4e83 3a 8d 4e			ld a, (.dmark+2)  
4e86 32 60 ee			ld (debug_mark+2),a  
4e89 18 03			jr .pastdmark  
4e8b ..			.dmark: db "KEB"  
4e8e f1			.pastdmark: pop af  
4e8f			endm  
# End of macro DMARK
4e8f						CALLMONITOR 
4e8f cd 6b ee			call debug_vector  
4e92				endm  
# End of macro CALLMONITOR
4e92					endif 
4e92			; TODO currently waits 
4e92 cd 86 67				call cin 
4e95					;call cin_wait 
4e95 6f					ld l, a 
4e96 26 00				ld h, 0 
4e98 cd d7 1a				call forth_push_numhl 
4e9b					NEXTW 
4e9b cd 68 ee			call parse_vector 
4e9e c3 ba 1e			jp macro_next 
4ea1				endm 
# End of macro NEXTW
4ea1			.WAITK: 
4ea1				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4ea1 3f				db WORD_SYS_CORE+43             
4ea2 d6 4e			dw .ACCEPT            
4ea4 06				db 5 + 1 
4ea5 .. 00			db "WAITK",0              
4eab				endm 
# End of macro CWHEAD
4eab			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4eab					if DEBUG_FORTH_WORDS_KEY 
4eab						DMARK "WAI" 
4eab f5				push af  
4eac 3a c0 4e			ld a, (.dmark)  
4eaf 32 5e ee			ld (debug_mark),a  
4eb2 3a c1 4e			ld a, (.dmark+1)  
4eb5 32 5f ee			ld (debug_mark+1),a  
4eb8 3a c2 4e			ld a, (.dmark+2)  
4ebb 32 60 ee			ld (debug_mark+2),a  
4ebe 18 03			jr .pastdmark  
4ec0 ..			.dmark: db "WAI"  
4ec3 f1			.pastdmark: pop af  
4ec4			endm  
# End of macro DMARK
4ec4						CALLMONITOR 
4ec4 cd 6b ee			call debug_vector  
4ec7				endm  
# End of macro CALLMONITOR
4ec7					endif 
4ec7 cd 7e 67				call cin_wait 
4eca 6f					ld l, a 
4ecb 26 00				ld h, 0 
4ecd cd d7 1a				call forth_push_numhl 
4ed0					NEXTW 
4ed0 cd 68 ee			call parse_vector 
4ed3 c3 ba 1e			jp macro_next 
4ed6				endm 
# End of macro NEXTW
4ed6			.ACCEPT: 
4ed6				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4ed6 40				db WORD_SYS_CORE+44             
4ed7 36 4f			dw .EDIT            
4ed9 07				db 6 + 1 
4eda .. 00			db "ACCEPT",0              
4ee1				endm 
# End of macro CWHEAD
4ee1			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
4ee1					; TODO crashes on push 
4ee1					if DEBUG_FORTH_WORDS_KEY 
4ee1						DMARK "ACC" 
4ee1 f5				push af  
4ee2 3a f6 4e			ld a, (.dmark)  
4ee5 32 5e ee			ld (debug_mark),a  
4ee8 3a f7 4e			ld a, (.dmark+1)  
4eeb 32 5f ee			ld (debug_mark+1),a  
4eee 3a f8 4e			ld a, (.dmark+2)  
4ef1 32 60 ee			ld (debug_mark+2),a  
4ef4 18 03			jr .pastdmark  
4ef6 ..			.dmark: db "ACC"  
4ef9 f1			.pastdmark: pop af  
4efa			endm  
# End of macro DMARK
4efa						CALLMONITOR 
4efa cd 6b ee			call debug_vector  
4efd				endm  
# End of macro CALLMONITOR
4efd					endif 
4efd 21 b2 e4				ld hl, os_input 
4f00			;		ld a, 0 
4f00 36 00				ld (hl),0 
4f02 3a 51 ea				ld a,(f_cursor_ptr) 
4f05 16 64				ld d, 100 
4f07 0e 00				ld c, 0 
4f09 1e 28				ld e, 40 
4f0b cd 13 0e				call input_str 
4f0e					; TODO perhaps do a type check and wrap in quotes if not a number 
4f0e 21 b2 e4				ld hl, os_input 
4f11					if DEBUG_FORTH_WORDS 
4f11						DMARK "AC1" 
4f11 f5				push af  
4f12 3a 26 4f			ld a, (.dmark)  
4f15 32 5e ee			ld (debug_mark),a  
4f18 3a 27 4f			ld a, (.dmark+1)  
4f1b 32 5f ee			ld (debug_mark+1),a  
4f1e 3a 28 4f			ld a, (.dmark+2)  
4f21 32 60 ee			ld (debug_mark+2),a  
4f24 18 03			jr .pastdmark  
4f26 ..			.dmark: db "AC1"  
4f29 f1			.pastdmark: pop af  
4f2a			endm  
# End of macro DMARK
4f2a						CALLMONITOR 
4f2a cd 6b ee			call debug_vector  
4f2d				endm  
# End of macro CALLMONITOR
4f2d					endif 
4f2d cd 41 1b				call forth_push_str 
4f30					NEXTW 
4f30 cd 68 ee			call parse_vector 
4f33 c3 ba 1e			jp macro_next 
4f36				endm 
# End of macro NEXTW
4f36			 
4f36			.EDIT: 
4f36				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
4f36 40				db WORD_SYS_CORE+44             
4f37 db 4f			dw .DEDIT            
4f39 05				db 4 + 1 
4f3a .. 00			db "EDIT",0              
4f3f				endm 
# End of macro CWHEAD
4f3f			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4f3f			 
4f3f					; TODO does not copy from stack 
4f3f					if DEBUG_FORTH_WORDS_KEY 
4f3f						DMARK "EDT" 
4f3f f5				push af  
4f40 3a 54 4f			ld a, (.dmark)  
4f43 32 5e ee			ld (debug_mark),a  
4f46 3a 55 4f			ld a, (.dmark+1)  
4f49 32 5f ee			ld (debug_mark+1),a  
4f4c 3a 56 4f			ld a, (.dmark+2)  
4f4f 32 60 ee			ld (debug_mark+2),a  
4f52 18 03			jr .pastdmark  
4f54 ..			.dmark: db "EDT"  
4f57 f1			.pastdmark: pop af  
4f58			endm  
# End of macro DMARK
4f58						CALLMONITOR 
4f58 cd 6b ee			call debug_vector  
4f5b				endm  
# End of macro CALLMONITOR
4f5b					endif 
4f5b			 
4f5b					;FORTH_DSP 
4f5b					FORTH_DSP_VALUEHL 
4f5b cd d3 1c			call macro_dsp_valuehl 
4f5e				endm 
# End of macro FORTH_DSP_VALUEHL
4f5e			;		inc hl    ; TODO do type check 
4f5e			 
4f5e			;		call get_word_hl 
4f5e e5					push hl 
4f5f					if DEBUG_FORTH_WORDS 
4f5f						DMARK "EDp" 
4f5f f5				push af  
4f60 3a 74 4f			ld a, (.dmark)  
4f63 32 5e ee			ld (debug_mark),a  
4f66 3a 75 4f			ld a, (.dmark+1)  
4f69 32 5f ee			ld (debug_mark+1),a  
4f6c 3a 76 4f			ld a, (.dmark+2)  
4f6f 32 60 ee			ld (debug_mark+2),a  
4f72 18 03			jr .pastdmark  
4f74 ..			.dmark: db "EDp"  
4f77 f1			.pastdmark: pop af  
4f78			endm  
# End of macro DMARK
4f78						CALLMONITOR 
4f78 cd 6b ee			call debug_vector  
4f7b				endm  
# End of macro CALLMONITOR
4f7b					endif 
4f7b				;	ld a, 0 
4f7b cd 3e 11				call strlenz 
4f7e 23					inc hl 
4f7f			 
4f7f 06 00				ld b, 0 
4f81 4d					ld c, l 
4f82			 
4f82 e1					pop hl 
4f83 11 b2 e4				ld de, os_input 
4f86					if DEBUG_FORTH_WORDS_KEY 
4f86						DMARK "EDc" 
4f86 f5				push af  
4f87 3a 9b 4f			ld a, (.dmark)  
4f8a 32 5e ee			ld (debug_mark),a  
4f8d 3a 9c 4f			ld a, (.dmark+1)  
4f90 32 5f ee			ld (debug_mark+1),a  
4f93 3a 9d 4f			ld a, (.dmark+2)  
4f96 32 60 ee			ld (debug_mark+2),a  
4f99 18 03			jr .pastdmark  
4f9b ..			.dmark: db "EDc"  
4f9e f1			.pastdmark: pop af  
4f9f			endm  
# End of macro DMARK
4f9f						CALLMONITOR 
4f9f cd 6b ee			call debug_vector  
4fa2				endm  
# End of macro CALLMONITOR
4fa2					endif 
4fa2 ed b0				ldir 
4fa4			 
4fa4			 
4fa4 21 b2 e4				ld hl, os_input 
4fa7					;ld a, 0 
4fa7					;ld (hl),a 
4fa7 3a 51 ea				ld a,(f_cursor_ptr) 
4faa 16 64				ld d, 100 
4fac 0e 00				ld c, 0 
4fae 1e 28				ld e, 40 
4fb0 cd 13 0e				call input_str 
4fb3					; TODO perhaps do a type check and wrap in quotes if not a number 
4fb3 21 b2 e4				ld hl, os_input 
4fb6					if DEBUG_FORTH_WORDS 
4fb6						DMARK "ED1" 
4fb6 f5				push af  
4fb7 3a cb 4f			ld a, (.dmark)  
4fba 32 5e ee			ld (debug_mark),a  
4fbd 3a cc 4f			ld a, (.dmark+1)  
4fc0 32 5f ee			ld (debug_mark+1),a  
4fc3 3a cd 4f			ld a, (.dmark+2)  
4fc6 32 60 ee			ld (debug_mark+2),a  
4fc9 18 03			jr .pastdmark  
4fcb ..			.dmark: db "ED1"  
4fce f1			.pastdmark: pop af  
4fcf			endm  
# End of macro DMARK
4fcf						CALLMONITOR 
4fcf cd 6b ee			call debug_vector  
4fd2				endm  
# End of macro CALLMONITOR
4fd2					endif 
4fd2 cd 41 1b				call forth_push_str 
4fd5					NEXTW 
4fd5 cd 68 ee			call parse_vector 
4fd8 c3 ba 1e			jp macro_next 
4fdb				endm 
# End of macro NEXTW
4fdb			 
4fdb			.DEDIT: 
4fdb				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
4fdb 40				db WORD_SYS_CORE+44             
4fdc 40 50			dw .ENDKEY            
4fde 06				db 5 + 1 
4fdf .. 00			db "DEDIT",0              
4fe5				endm 
# End of macro CWHEAD
4fe5			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | DONE 
4fe5			 
4fe5					; TODO does not copy from stack 
4fe5					if DEBUG_FORTH_WORDS_KEY 
4fe5						DMARK "DED" 
4fe5 f5				push af  
4fe6 3a fa 4f			ld a, (.dmark)  
4fe9 32 5e ee			ld (debug_mark),a  
4fec 3a fb 4f			ld a, (.dmark+1)  
4fef 32 5f ee			ld (debug_mark+1),a  
4ff2 3a fc 4f			ld a, (.dmark+2)  
4ff5 32 60 ee			ld (debug_mark+2),a  
4ff8 18 03			jr .pastdmark  
4ffa ..			.dmark: db "DED"  
4ffd f1			.pastdmark: pop af  
4ffe			endm  
# End of macro DMARK
4ffe						CALLMONITOR 
4ffe cd 6b ee			call debug_vector  
5001				endm  
# End of macro CALLMONITOR
5001					endif 
5001			 
5001					;FORTH_DSP 
5001					FORTH_DSP_VALUEHL 
5001 cd d3 1c			call macro_dsp_valuehl 
5004				endm 
# End of macro FORTH_DSP_VALUEHL
5004			;		inc hl    ; TODO do type check 
5004			 
5004			;		call get_word_hl 
5004 e5					push hl 
5005 e5					push hl 
5006					FORTH_DSP_POP 
5006 cd 8b 1d			call macro_forth_dsp_pop 
5009				endm 
# End of macro FORTH_DSP_POP
5009 e1					pop hl 
500a					if DEBUG_FORTH_WORDS 
500a						DMARK "EDp" 
500a f5				push af  
500b 3a 1f 50			ld a, (.dmark)  
500e 32 5e ee			ld (debug_mark),a  
5011 3a 20 50			ld a, (.dmark+1)  
5014 32 5f ee			ld (debug_mark+1),a  
5017 3a 21 50			ld a, (.dmark+2)  
501a 32 60 ee			ld (debug_mark+2),a  
501d 18 03			jr .pastdmark  
501f ..			.dmark: db "EDp"  
5022 f1			.pastdmark: pop af  
5023			endm  
# End of macro DMARK
5023						CALLMONITOR 
5023 cd 6b ee			call debug_vector  
5026				endm  
# End of macro CALLMONITOR
5026					endif 
5026				;	ld a, 0 
5026 cd 3e 11				call strlenz 
5029 23					inc hl 
502a			 
502a 06 00				ld b, 0 
502c 4d					ld c, l 
502d			 
502d e1					pop hl 
502e			 
502e					;ld a, 0 
502e					;ld (hl),a 
502e 3a 51 ea				ld a,(f_cursor_ptr) 
5031 16 64				ld d, 100 
5033 0e 00				ld c, 0 
5035 1e 28				ld e, 40 
5037 cd 13 0e				call input_str 
503a					; TODO perhaps do a type check and wrap in quotes if not a number 
503a					NEXTW 
503a cd 68 ee			call parse_vector 
503d c3 ba 1e			jp macro_next 
5040				endm 
# End of macro NEXTW
5040			 
5040			 
5040			.ENDKEY: 
5040			; eof 
5040			 
# End of file forth_words_key.asm
5040			include "forth_words_const.asm" 
5040			 
5040			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
5040			 
5040			 
5040			.SPITIME: 
5040				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
5040 77				db WORD_SYS_CORE+99             
5041 58 50			dw .VA            
5043 08				db 7 + 1 
5044 .. 00			db "SPITIME",0              
504c				endm 
# End of macro CWHEAD
504c			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack | DONE 
504c			; 
504c			; | | If using BANK devices then leave as is. 
504c			; | | Only really useful for the CARTDEV where other devices may be far too slow. In particular 
504c			; | | the multiplexing of the PicoSPINet addon which might not be running fast enough for all of the nodes 
504c			 
504c 21 57 ea				ld hl, spi_clktime  
504f cd d7 1a				call forth_push_numhl 
5052			 
5052					NEXTW 
5052 cd 68 ee			call parse_vector 
5055 c3 ba 1e			jp macro_next 
5058				endm 
# End of macro NEXTW
5058			 
5058			 
5058			.VA: 
5058				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
5058 77				db WORD_SYS_CORE+99             
5059 6b 50			dw .SYMBOL            
505b 03				db 2 + 1 
505c .. 00			db "VA",0              
505f				endm 
# End of macro CWHEAD
505f			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 | DONE 
505f 21 1b ea				ld hl, cli_var_array 
5062 cd d7 1a				call forth_push_numhl 
5065			 
5065					NEXTW 
5065 cd 68 ee			call parse_vector 
5068 c3 ba 1e			jp macro_next 
506b				endm 
# End of macro NEXTW
506b			 
506b			.SYMBOL: 
506b				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
506b 77				db WORD_SYS_CORE+99             
506c 7a 51			dw .ENDCONST            
506e 07				db 6 + 1 
506f .. 00			db "SYMBOL",0              
5076				endm 
# End of macro CWHEAD
5076			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
5076			; | 
5076			; | | The value is the number reference and the final address is pushed to stack 
5076			 
5076			; | | ``` 
5076			; | | dw sym_table 
5076			; | | dw nmi_vector 
5076			; | | dw cli_autodisplay 
5076			; | | dw cli_data_sp 
5076			; | | dw cli_data_stack 
5076			; | | dw cli_loop_sp 
5076			; | | dw cli_loop_stack 
5076			; | | dw cli_var_array 
5076			; | | dw cursor_col 
5076			; | | dw cursor_ptr 
5076			; | | ; 10 
5076			; | | dw cursor_row 
5076			; | | dw debug_mark 
5076			; | | dw display_fb0 
5076			; | | dw display_fb1 
5076			; | | dw display_fb2 
5076			; | | dw display_fb3 
5076			; | | dw display_fb_active 
5076			; | | dw execscratch 
5076			; | | dw f_cursor_ptr 
5076			; | | dw hardware_word 
5076			; | | ;20 
5076			; | | dw input_at_cursor 
5076			; | | dw input_at_pos 
5076			; | | dw input_cur_flash 
5076			; | | dw input_cur_onoff 
5076			; | | dw input_cursor 
5076			; | | dw input_display_size 
5076			; | | dw input_len 
5076			; | | dw input_ptr 
5076			; | | dw input_size 
5076			; | | dw input_start 
5076			; | | ; 30 
5076			; | | dw input_str 
5076			; | | dw input_under_cursor 
5076			; | | dw os_cli_cmd 
5076			; | | dw os_cur_ptr 
5076			; | | dw os_current_i 
5076			; | | dw os_input 
5076			; | | dw os_last_cmd 
5076			; | | dw os_last_new_uword 
5076			; | | dw debug_vector 
5076			; | | dw os_view_hl 
5076			; | | ;40 
5076			; | | dw os_word_scratch 
5076			; | | dw portbctl 
5076			; | | dw portbdata 
5076			; | | dw spi_cartdev 
5076			; | | dw spi_cartdev2 
5076			; | | dw spi_clktime 
5076			; | | dw spi_device 
5076			; | | dw spi_device_id 
5076			; | | dw spi_portbyte 
5076			; | | dw stackstore 
5076			; | | ; 50 
5076			; | | if STORAGE_SE 
5076			; | | dw storage_actl 
5076			; | | dw storage_adata 
5076			; | | else 
5076			; | | dw 0 
5076			; | | dw 0 
5076			; | | endif 
5076			; | | dw storage_append 
5076			; | | if STORAGE_SE 
5076			; | | dw storage_bctl 
5076			; | | else 
5076			; | | dw 0 
5076			; | | endif 
5076			; | | dw store_bank_active 
5076			; | | dw store_filecache 
5076			; | | dw store_longread 
5076			; | | dw store_openaddr 
5076			; | | dw store_openext 
5076			; | | dw store_openmaxext 
5076			; | | ; 60 
5076			; | | dw store_page 
5076			; | | dw store_readbuf 
5076			; | | dw store_readcont 
5076			; | | dw store_readptr 
5076			; | | dw store_tmpext 
5076			; | | dw store_tmpid 
5076			; | | dw store_tmppageid 
5076			; | | dw malloc 
5076			; | | dw free 
5076			; | | dw cin 
5076			; | | ; 70 
5076			; | | dw cin_wait 
5076			; | | dw forth_push_numhl 
5076			; | | dw forth_push_str 
5076			; | | dw parse_vector 
5076			; | | ``` 
5076			 
5076					if DEBUG_FORTH_WORDS_KEY 
5076						DMARK "SYM" 
5076 f5				push af  
5077 3a 8b 50			ld a, (.dmark)  
507a 32 5e ee			ld (debug_mark),a  
507d 3a 8c 50			ld a, (.dmark+1)  
5080 32 5f ee			ld (debug_mark+1),a  
5083 3a 8d 50			ld a, (.dmark+2)  
5086 32 60 ee			ld (debug_mark+2),a  
5089 18 03			jr .pastdmark  
508b ..			.dmark: db "SYM"  
508e f1			.pastdmark: pop af  
508f			endm  
# End of macro DMARK
508f						CALLMONITOR 
508f cd 6b ee			call debug_vector  
5092				endm  
# End of macro CALLMONITOR
5092					endif 
5092			 
5092					FORTH_DSP_VALUEHL 
5092 cd d3 1c			call macro_dsp_valuehl 
5095				endm 
# End of macro FORTH_DSP_VALUEHL
5095			 
5095 7d					ld a, l     
5096			 
5096			 
5096					if DEBUG_FORTH_WORDS 
5096						DMARK "SY1" 
5096 f5				push af  
5097 3a ab 50			ld a, (.dmark)  
509a 32 5e ee			ld (debug_mark),a  
509d 3a ac 50			ld a, (.dmark+1)  
50a0 32 5f ee			ld (debug_mark+1),a  
50a3 3a ad 50			ld a, (.dmark+2)  
50a6 32 60 ee			ld (debug_mark+2),a  
50a9 18 03			jr .pastdmark  
50ab ..			.dmark: db "SY1"  
50ae f1			.pastdmark: pop af  
50af			endm  
# End of macro DMARK
50af						CALLMONITOR 
50af cd 6b ee			call debug_vector  
50b2				endm  
# End of macro CALLMONITOR
50b2					endif 
50b2					 
50b2 f5					push af	 
50b3					FORTH_DSP_POP 
50b3 cd 8b 1d			call macro_forth_dsp_pop 
50b6				endm 
# End of macro FORTH_DSP_POP
50b6 f1					pop af 
50b7			 
50b7 cb 27				sla a  
50b9				 
50b9					 
50b9					if DEBUG_FORTH_WORDS 
50b9						DMARK "SY" 
50b9 f5				push af  
50ba 3a ce 50			ld a, (.dmark)  
50bd 32 5e ee			ld (debug_mark),a  
50c0 3a cf 50			ld a, (.dmark+1)  
50c3 32 5f ee			ld (debug_mark+1),a  
50c6 3a d0 50			ld a, (.dmark+2)  
50c9 32 60 ee			ld (debug_mark+2),a  
50cc 18 02			jr .pastdmark  
50ce ..			.dmark: db "SY"  
50d0 f1			.pastdmark: pop af  
50d1			endm  
# End of macro DMARK
50d1						CALLMONITOR 
50d1 cd 6b ee			call debug_vector  
50d4				endm  
# End of macro CALLMONITOR
50d4					endif 
50d4			 
50d4 21 e6 50				ld hl, sym_table 
50d7 cd e6 0d				call addatohl 
50da cd 40 1e				call loadwordinhl 
50dd cd d7 1a				call forth_push_numhl 
50e0			 
50e0			 
50e0				       NEXTW 
50e0 cd 68 ee			call parse_vector 
50e3 c3 ba 1e			jp macro_next 
50e6				endm 
# End of macro NEXTW
50e6			 
50e6			sym_table: 
50e6			 
50e6			; 0 
50e6 e6 50		dw sym_table 
50e8 6e ee		dw nmi_vector 
50ea 2f ea		dw cli_autodisplay 
50ec e1 e9		dw cli_data_sp 
50ee 1b e8		dw cli_data_stack 
50f0 e3 e9		dw cli_loop_sp 
50f2 1d e9		dw cli_loop_stack 
50f4 1b ea		dw cli_var_array 
50f6 b8 eb		dw cursor_col 
50f8 b6 eb		dw cursor_ptr 
50fa			; 10 
50fa b7 eb		dw cursor_row 
50fc 5e ee		dw debug_mark 
50fe a4 ed		dw display_fb0 
5100 03 ed		dw display_fb1 
5102 c1 eb		dw display_fb2 
5104 62 ec		dw display_fb3 
5106 bf eb		dw display_fb_active 
5108 b3 e3		dw execscratch 
510a 51 ea		dw f_cursor_ptr 
510c 71 ee		dw hardware_word 
510e			;20 
510e 55 ee		dw input_at_cursor 
5110 57 ee		dw input_at_pos 
5112 53 ee		dw input_cur_flash 
5114 52 ee		dw input_cur_onoff 
5116 48 ee		dw input_cursor 
5118 58 ee		dw input_display_size 
511a 4d ee		dw input_len 
511c 5c ee		dw input_ptr 
511e 59 ee		dw input_size 
5120 5a ee		dw input_start 
5122			; 30 
5122 13 0e		dw input_str 
5124 56 ee		dw input_under_cursor 
5126 db e5		dw os_cli_cmd 
5128 d7 e5		dw os_cur_ptr 
512a d9 e5		dw os_current_i 
512c b2 e4		dw os_input 
512e da e6		dw os_last_cmd 
5130 b1 e5		dw os_last_new_uword 
5132 6b ee		dw debug_vector 
5134 96 e2		dw os_view_hl 
5136			;40 
5136 b9 e5		dw os_word_scratch 
5138 c3 00		dw portbctl 
513a c1 00		dw portbdata 
513c 56 ea		dw spi_cartdev 
513e 55 ea		dw spi_cartdev2 
5140 57 ea		dw spi_clktime 
5142 53 ea		dw spi_device 
5144 52 ea		dw spi_device_id 
5146 54 ea		dw spi_portbyte 
5148 9a eb		dw stackstore 
514a			; 50 
514a			if STORAGE_SE 
514a			dw storage_actl 
514a			dw storage_adata 
514a			else 
514a 00 00		dw 0 
514c 00 00		dw 0 
514e			endif 
514e 6b 09		dw storage_append 
5150			if STORAGE_SE 
5150			dw storage_bctl 
5150			else 
5150 00 00		dw 0 
5152			endif 
5152 86 eb		dw store_bank_active 
5154 5a ea		dw store_filecache 
5156 68 ea		dw store_longread 
5158 5e ea		dw store_openaddr 
515a 5d ea		dw store_openext 
515c 5c ea		dw store_openmaxext 
515e			; 60 
515e 6d ea		dw store_page 
5160 69 ea		dw store_readbuf 
5162 60 ea		dw store_readcont 
5164 6b ea		dw store_readptr 
5166 60 ea		dw store_tmpext 
5168 61 ea		dw store_tmpid 
516a 58 ea		dw store_tmppageid 
516c b2 11		dw malloc 
516e 7c 12		dw free 
5170 86 67		dw cin 
5172			; 70 
5172 7e 67		dw cin_wait 
5174 d7 1a		dw forth_push_numhl 
5176 41 1b		dw forth_push_str 
5178 68 ee		dw parse_vector 
517a			 
517a			.ENDCONST: 
517a			 
517a			; eof 
517a			 
517a			 
# End of file forth_words_const.asm
517a			 
517a			if STORAGE_SE 
517a			   	include "forth_words_storage.asm" 
517a			endif 
517a				include "forth_words_device.asm" 
517a			; Device related words 
517a			 
517a			; | ## Device Words 
517a			 
517a			;if SOUND_ENABLE 
517a			;.NOTE: 
517a			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
517a			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds  TODO 
517a			;		if DEBUG_FORTH_WORDS_KEY 
517a			;			DMARK "NTE" 
517a			;			CALLMONITOR 
517a			;		endif 
517a			; 
517a			;	 
517a			; 
517a			;		NEXTW 
517a			;.AFTERSOUND: 
517a			;endif 
517a			 
517a			 
517a			USE_GPIO: equ 0 
517a			 
517a			if USE_GPIO 
517a			.GP1: 
517a				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
517a			;  IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result   
517a					NEXTW 
517a			.GP2: 
517a				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
517a			;  IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2   
517a			 
517a					NEXTW 
517a			 
517a			.GP3: 
517a				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
517a			;  IOBYTE ( u1 --  )    Perform a GPIO write of byte u1   
517a			 
517a					NEXTW 
517a			 
517a			.GP4: 
517a				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
517a			;  IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin   
517a			 
517a					NEXTW 
517a			.SIN: 
517a			 
517a			 
517a			endif 
517a			 
517a			 
517a				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
517a 33				db WORD_SYS_CORE+31             
517b b2 51			dw .SOUT            
517d 03				db 2 + 1 
517e .. 00			db "IN",0              
5181				endm 
# End of macro CWHEAD
5181			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
5181					if DEBUG_FORTH_WORDS_KEY 
5181						DMARK "IN." 
5181 f5				push af  
5182 3a 96 51			ld a, (.dmark)  
5185 32 5e ee			ld (debug_mark),a  
5188 3a 97 51			ld a, (.dmark+1)  
518b 32 5f ee			ld (debug_mark+1),a  
518e 3a 98 51			ld a, (.dmark+2)  
5191 32 60 ee			ld (debug_mark+2),a  
5194 18 03			jr .pastdmark  
5196 ..			.dmark: db "IN."  
5199 f1			.pastdmark: pop af  
519a			endm  
# End of macro DMARK
519a						CALLMONITOR 
519a cd 6b ee			call debug_vector  
519d				endm  
# End of macro CALLMONITOR
519d					endif 
519d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
519d cd d3 1c			call macro_dsp_valuehl 
51a0				endm 
# End of macro FORTH_DSP_VALUEHL
51a0			 
51a0 e5					push hl 
51a1			 
51a1					; destroy value TOS 
51a1			 
51a1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
51a1 cd 8b 1d			call macro_forth_dsp_pop 
51a4				endm 
# End of macro FORTH_DSP_POP
51a4			 
51a4					; one value on hl get other one back 
51a4			 
51a4 c1					pop bc 
51a5			 
51a5					; do the sub 
51a5			;		ex de, hl 
51a5			 
51a5 ed 68				in l,(c) 
51a7			 
51a7					; save it 
51a7			 
51a7 26 00				ld h,0 
51a9			 
51a9					; TODO push value back onto stack for another op etc 
51a9			 
51a9 cd d7 1a				call forth_push_numhl 
51ac					NEXTW 
51ac cd 68 ee			call parse_vector 
51af c3 ba 1e			jp macro_next 
51b2				endm 
# End of macro NEXTW
51b2			.SOUT: 
51b2				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
51b2 34				db WORD_SYS_CORE+32             
51b3 08 52			dw .SPIO            
51b5 04				db 3 + 1 
51b6 .. 00			db "OUT",0              
51ba				endm 
# End of macro CWHEAD
51ba			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
51ba					if DEBUG_FORTH_WORDS_KEY 
51ba						DMARK "OUT" 
51ba f5				push af  
51bb 3a cf 51			ld a, (.dmark)  
51be 32 5e ee			ld (debug_mark),a  
51c1 3a d0 51			ld a, (.dmark+1)  
51c4 32 5f ee			ld (debug_mark+1),a  
51c7 3a d1 51			ld a, (.dmark+2)  
51ca 32 60 ee			ld (debug_mark+2),a  
51cd 18 03			jr .pastdmark  
51cf ..			.dmark: db "OUT"  
51d2 f1			.pastdmark: pop af  
51d3			endm  
# End of macro DMARK
51d3						CALLMONITOR 
51d3 cd 6b ee			call debug_vector  
51d6				endm  
# End of macro CALLMONITOR
51d6					endif 
51d6			 
51d6					; get port 
51d6			 
51d6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
51d6 cd d3 1c			call macro_dsp_valuehl 
51d9				endm 
# End of macro FORTH_DSP_VALUEHL
51d9			 
51d9 e5					push hl 
51da			 
51da					; destroy value TOS 
51da			 
51da					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
51da cd 8b 1d			call macro_forth_dsp_pop 
51dd				endm 
# End of macro FORTH_DSP_POP
51dd			 
51dd					; get byte to send 
51dd			 
51dd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
51dd cd d3 1c			call macro_dsp_valuehl 
51e0				endm 
# End of macro FORTH_DSP_VALUEHL
51e0			 
51e0			;		push hl 
51e0			 
51e0					; destroy value TOS 
51e0			 
51e0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
51e0 cd 8b 1d			call macro_forth_dsp_pop 
51e3				endm 
# End of macro FORTH_DSP_POP
51e3			 
51e3					; one value on hl get other one back 
51e3			 
51e3			;		pop hl 
51e3			 
51e3 c1					pop bc 
51e4			 
51e4					if DEBUG_FORTH_WORDS 
51e4						DMARK "OUT" 
51e4 f5				push af  
51e5 3a f9 51			ld a, (.dmark)  
51e8 32 5e ee			ld (debug_mark),a  
51eb 3a fa 51			ld a, (.dmark+1)  
51ee 32 5f ee			ld (debug_mark+1),a  
51f1 3a fb 51			ld a, (.dmark+2)  
51f4 32 60 ee			ld (debug_mark+2),a  
51f7 18 03			jr .pastdmark  
51f9 ..			.dmark: db "OUT"  
51fc f1			.pastdmark: pop af  
51fd			endm  
# End of macro DMARK
51fd						CALLMONITOR 
51fd cd 6b ee			call debug_vector  
5200				endm  
# End of macro CALLMONITOR
5200					endif 
5200			 
5200 ed 69				out (c), l 
5202			 
5202					NEXTW 
5202 cd 68 ee			call parse_vector 
5205 c3 ba 1e			jp macro_next 
5208				endm 
# End of macro NEXTW
5208			 
5208			 
5208			.SPIO: 
5208			 
5208			if STORAGE_SE 
5208				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
5208			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
5208			 
5208					call spi_ce_low 
5208			    NEXTW 
5208			 
5208			.SPICEH: 
5208				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
5208			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
5208			 
5208					call spi_ce_high 
5208			    NEXTW 
5208			 
5208			 
5208			.SPIOb: 
5208			 
5208				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
5208			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
5208			 
5208					if DEBUG_FORTH_WORDS_KEY 
5208						DMARK "SPo" 
5208						CALLMONITOR 
5208					endif 
5208					; get port 
5208			 
5208			 
5208					; get byte to send 
5208			 
5208					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5208			 
5208			;		push hl    ; u1  
5208			 
5208					; destroy value TOS 
5208			 
5208					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5208			 
5208					; one value on hl get other one back 
5208			 
5208			;		pop hl   ; u2 - addr 
5208			 
5208					; TODO Send SPI byte 
5208			 
5208			;		push hl 
5208			;		call spi_ce_low 
5208			;		pop hl 
5208					ld a, l 
5208					call spi_send_byte 
5208			;		call spi_ce_high 
5208			 
5208					NEXTW 
5208			 
5208			.SPII: 
5208				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
5208			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
5208					if DEBUG_FORTH_WORDS_KEY 
5208						DMARK "SPi" 
5208						CALLMONITOR 
5208					endif 
5208			 
5208					; TODO Get SPI byte 
5208			 
5208					call spi_read_byte 
5208			 
5208					if DEBUG_FORTH_WORDS 
5208						DMARK "Si2" 
5208						CALLMONITOR 
5208					endif 
5208					ld h, 0 
5208					ld l, a 
5208					if DEBUG_FORTH_WORDS 
5208						DMARK "Si3" 
5208						CALLMONITOR 
5208					endif 
5208					call forth_push_numhl 
5208			 
5208					NEXTW 
5208			 
5208			 
5208			 
5208			.SESEL: 
5208				CWHEAD .SESELS 82 "BANK?" 5 WORD_FLAG_CODE 
5208			; | BANK? ( -- u ) Reports on the serial EEPROM Bank Device at bank address u1 1-5.  | DONE 
5208			; | | Zero is disabled storage. 
5208					if DEBUG_FORTH_WORDS_KEY 
5208						DMARK "BN?" 
5208						CALLMONITOR 
5208					endif 
5208					ld a, (spi_device_id) 
5208					sub '0' 
5208					ld h, 0 
5208					ld l, a 
5208					call forth_push_numhl 
5208					NEXTW 
5208			.SESELS: 
5208				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
5208			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV).  | DONE 
5208			; | | Set to zero to disable storage. 
5208					if DEBUG_FORTH_WORDS_KEY 
5208						DMARK "BNK" 
5208						CALLMONITOR 
5208					endif 
5208			 
5208					ld a, 255 
5208					ld (spi_cartdev), a 
5208			 
5208					; get bank 
5208			 
5208					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5208			 
5208			;		push hl 
5208			 
5208					; destroy value TOS 
5208			 
5208					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5208			 
5208					; one value on hl get other one back 
5208			 
5208			;		pop hl 
5208			 
5208			 
5208					ld c, SPI_CE_HIGH 
5208					ld b, '0'    ; human readable bank number 
5208			 
5208					ld a, l 
5208			 
5208					if DEBUG_FORTH_WORDS 
5208						DMARK "BNK" 
5208						CALLMONITOR 
5208					endif 
5208			 
5208					; active low 
5208			 
5208			;		cp 0 
5208					or a 
5208					jr z, .bset 
5208					cp 1 
5208					jr nz, .b2 
5208					res 0, c 
5208					ld b, '1'    ; human readable bank number 
5208			.b2:		cp 2 
5208					jr nz, .b3 
5208					res 1, c 
5208					ld b, '2'    ; human readable bank number 
5208			.b3:		cp 3 
5208					jr nz, .b4 
5208					res 2, c 
5208					ld b, '3'    ; human readable bank number 
5208			.b4:		cp 4 
5208					jr nz, .b5 
5208					res 3, c 
5208					ld b, '4'    ; human readable bank number 
5208			.b5:		cp 5 
5208					jr nz, .bset 
5208					res 4, c 
5208					ld b, '5'    ; human readable bank number 
5208			 
5208			.bset: 
5208					ld a, c 
5208					ld (spi_device),a 
5208					ld a, b 
5208					ld (spi_device_id),a 
5208					if DEBUG_FORTH_WORDS 
5208						DMARK "BN2" 
5208						CALLMONITOR 
5208					endif 
5208			 
5208					; set default SPI clk pulse time as disabled for BANK use 
5208			 
5208					ld a, 0 
5208					ld (spi_clktime), a 
5208			 
5208					NEXTW 
5208			 
5208			.CARTDEV: 
5208				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
5208			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). | DONE 
5208			; | | Set to zero to disable devices. 
5208					if DEBUG_FORTH_WORDS_KEY 
5208						DMARK "CDV" 
5208						CALLMONITOR 
5208					endif 
5208			 
5208					; disable se storage bank selection 
5208			 
5208					ld a, SPI_CE_HIGH		; ce high 
5208					ld (spi_device), a 
5208			 
5208					; get bank 
5208			 
5208					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5208			 
5208			;		push hl 
5208			 
5208					; destroy value TOS 
5208			 
5208					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5208			 
5208					; one value on hl get other one back 
5208			 
5208			;		pop hl 
5208			 
5208					; active low 
5208			 
5208					ld c, 255 
5208			 
5208					ld a, l 
5208					if DEBUG_FORTH_WORDS 
5208						DMARK "CDV" 
5208						CALLMONITOR 
5208					endif 
5208			;		cp 0 
5208					or a 
5208					jr z, .cset 
5208					cp 1 
5208					jr nz, .c2 
5208					res 0, c 
5208			.c2:		cp 2 
5208					jr nz, .c3 
5208					res 1, c 
5208			.c3:		cp 3 
5208					jr nz, .c4 
5208					res 2, c 
5208			.c4:		cp 4 
5208					jr nz, .c5 
5208					res 3, c 
5208			.c5:		cp 5 
5208					jr nz, .c6 
5208					res 4, c 
5208			.c6:		cp 6 
5208					jr nz, .c7 
5208					res 5, c 
5208			.c7:		cp 7 
5208					jr nz, .c8 
5208					res 6, c 
5208			.c8:		cp 8 
5208					jr nz, .cset 
5208					res 7, c 
5208			.cset:		ld a, c 
5208					ld (spi_cartdev),a 
5208			 
5208					if DEBUG_FORTH_WORDS 
5208						DMARK "CD2" 
5208						CALLMONITOR 
5208					endif 
5208			 
5208					; set default SPI clk pulse time as 10ms for CARTDEV use 
5208			 
5208					ld a, $0a 
5208					ld (spi_clktime), a 
5208					NEXTW 
5208			endif 
5208			 
5208			.ENDDEVICE: 
5208			; eof 
5208			 
# End of file forth_words_device.asm
5208			 
5208			; var handler 
5208			 
5208			 
5208			.VARS: 
5208				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
5208 77				db WORD_SYS_CORE+99             
5209 bc 52			dw .V0            
520b 04				db 3 + 1 
520c .. 00			db "VAR",0              
5210				endm 
# End of macro CWHEAD
5210			; | VAR ( u1 -- )  Get the address of the (word) variable referenced on TOS  | DONE 
5210			; | 
5210			; | | The variable name should consist of a single letter (a-z). e.g. "a" 
5210			; | |  
5210			; | | e.g. 
5210			; | |         #30 a var ! 
5210			; | |         a var @ . 
5210			; | |   
5210			; | |     Displays the number 30 
5210			; | | 
5210			; | | Each variable pointer is a word so can use for any words that use that:  
5210			; | |  
5210			; | | e.g. 
5210			; | |  
5210			; | |         #30 a var 2! 
5210			; | |         a var 2@ . 
5210			; | |   
5210			; | |     Displays the number 30 
5210			; | |  
5210			; | | > [!NOTE]  
5210			; ! | > If a full string is passed then only the first char is looked at 
5210			; | | > Any other char could exceed bounds checks!  
5210			; | | > 
5210			; | | > Each variable location follows the previous. Watch you don't clobber any others. 
5210			 
5210					if DEBUG_FORTH_WORDS_KEY 
5210						DMARK "VAR" 
5210 f5				push af  
5211 3a 25 52			ld a, (.dmark)  
5214 32 5e ee			ld (debug_mark),a  
5217 3a 26 52			ld a, (.dmark+1)  
521a 32 5f ee			ld (debug_mark+1),a  
521d 3a 27 52			ld a, (.dmark+2)  
5220 32 60 ee			ld (debug_mark+2),a  
5223 18 03			jr .pastdmark  
5225 ..			.dmark: db "VAR"  
5228 f1			.pastdmark: pop af  
5229			endm  
# End of macro DMARK
5229						CALLMONITOR 
5229 cd 6b ee			call debug_vector  
522c				endm  
# End of macro CALLMONITOR
522c					endif 
522c			 
522c					FORTH_DSP_VALUEHL 
522c cd d3 1c			call macro_dsp_valuehl 
522f				endm 
# End of macro FORTH_DSP_VALUEHL
522f			 
522f 7e					ld a, (hl)    ; get first char on of the string 
5230			 
5230			 
5230					if DEBUG_FORTH_WORDS 
5230						DMARK "VR1" 
5230 f5				push af  
5231 3a 45 52			ld a, (.dmark)  
5234 32 5e ee			ld (debug_mark),a  
5237 3a 46 52			ld a, (.dmark+1)  
523a 32 5f ee			ld (debug_mark+1),a  
523d 3a 47 52			ld a, (.dmark+2)  
5240 32 60 ee			ld (debug_mark+2),a  
5243 18 03			jr .pastdmark  
5245 ..			.dmark: db "VR1"  
5248 f1			.pastdmark: pop af  
5249			endm  
# End of macro DMARK
5249						CALLMONITOR 
5249 cd 6b ee			call debug_vector  
524c				endm  
# End of macro CALLMONITOR
524c					endif 
524c					 
524c f5					push af	 
524d					FORTH_DSP_POP 
524d cd 8b 1d			call macro_forth_dsp_pop 
5250				endm 
# End of macro FORTH_DSP_POP
5250 f1					pop af 
5251			 
5251					; convert to upper 
5251			 
5251 cd 4e 10				call to_upper 
5254					if DEBUG_FORTH_WORDS 
5254						DMARK "Vaa" 
5254 f5				push af  
5255 3a 69 52			ld a, (.dmark)  
5258 32 5e ee			ld (debug_mark),a  
525b 3a 6a 52			ld a, (.dmark+1)  
525e 32 5f ee			ld (debug_mark+1),a  
5261 3a 6b 52			ld a, (.dmark+2)  
5264 32 60 ee			ld (debug_mark+2),a  
5267 18 03			jr .pastdmark  
5269 ..			.dmark: db "Vaa"  
526c f1			.pastdmark: pop af  
526d			endm  
# End of macro DMARK
526d						CALLMONITOR 
526d cd 6b ee			call debug_vector  
5270				endm  
# End of macro CALLMONITOR
5270					endif 
5270 06 41				ld b, 'A' 
5272 90					sub b			; set offset 
5273					if DEBUG_FORTH_WORDS 
5273						DMARK "Vbb" 
5273 f5				push af  
5274 3a 88 52			ld a, (.dmark)  
5277 32 5e ee			ld (debug_mark),a  
527a 3a 89 52			ld a, (.dmark+1)  
527d 32 5f ee			ld (debug_mark+1),a  
5280 3a 8a 52			ld a, (.dmark+2)  
5283 32 60 ee			ld (debug_mark+2),a  
5286 18 03			jr .pastdmark  
5288 ..			.dmark: db "Vbb"  
528b f1			.pastdmark: pop af  
528c			endm  
# End of macro DMARK
528c						CALLMONITOR 
528c cd 6b ee			call debug_vector  
528f				endm  
# End of macro CALLMONITOR
528f					endif 
528f cb 27				sla a  
5291				 
5291					 
5291					if DEBUG_FORTH_WORDS 
5291						DMARK "VR2" 
5291 f5				push af  
5292 3a a6 52			ld a, (.dmark)  
5295 32 5e ee			ld (debug_mark),a  
5298 3a a7 52			ld a, (.dmark+1)  
529b 32 5f ee			ld (debug_mark+1),a  
529e 3a a8 52			ld a, (.dmark+2)  
52a1 32 60 ee			ld (debug_mark+2),a  
52a4 18 03			jr .pastdmark  
52a6 ..			.dmark: db "VR2"  
52a9 f1			.pastdmark: pop af  
52aa			endm  
# End of macro DMARK
52aa						CALLMONITOR 
52aa cd 6b ee			call debug_vector  
52ad				endm  
# End of macro CALLMONITOR
52ad					endif 
52ad			 
52ad 21 e7 e9				ld hl, cli_var_array2 
52b0 cd e6 0d				call addatohl 
52b3 cd d7 1a				call forth_push_numhl 
52b6			 
52b6			 
52b6				       NEXTW 
52b6 cd 68 ee			call parse_vector 
52b9 c3 ba 1e			jp macro_next 
52bc				endm 
# End of macro NEXTW
52bc			.V0: 
52bc				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
52bc 78				db WORD_SYS_CORE+100             
52bd d7 52			dw .V0Q            
52bf 04				db 3 + 1 
52c0 .. 00			db "V0!",0              
52c4				endm 
# End of macro CWHEAD
52c4			;| V0! ( u1 -- )  Store value to v0  | DONE 
52c4			 
52c4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
52c4 cd d3 1c			call macro_dsp_valuehl 
52c7				endm 
# End of macro FORTH_DSP_VALUEHL
52c7			 
52c7 11 1b ea				ld de, cli_var_array 
52ca			 
52ca eb					ex de, hl 
52cb 73					ld (hl), e 
52cc 23					inc hl 
52cd 72					ld (hl), d 
52ce			 
52ce					; destroy value TOS 
52ce			 
52ce					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
52ce cd 8b 1d			call macro_forth_dsp_pop 
52d1				endm 
# End of macro FORTH_DSP_POP
52d1			 
52d1				       NEXTW 
52d1 cd 68 ee			call parse_vector 
52d4 c3 ba 1e			jp macro_next 
52d7				endm 
# End of macro NEXTW
52d7			.V0Q: 
52d7				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
52d7 79				db WORD_SYS_CORE+101             
52d8 eb 52			dw .V1S            
52da 04				db 3 + 1 
52db .. 00			db "V0@",0              
52df				endm 
# End of macro CWHEAD
52df			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
52df 2a 1b ea				ld hl, (cli_var_array) 
52e2 cd d7 1a				call forth_push_numhl 
52e5			 
52e5				       NEXTW 
52e5 cd 68 ee			call parse_vector 
52e8 c3 ba 1e			jp macro_next 
52eb				endm 
# End of macro NEXTW
52eb			.V1S: 
52eb				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
52eb 7a				db WORD_SYS_CORE+102             
52ec 06 53			dw .V1Q            
52ee 04				db 3 + 1 
52ef .. 00			db "V1!",0              
52f3				endm 
# End of macro CWHEAD
52f3			;| V1! ( u1 -- )  Store value to v1 | DONE 
52f3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
52f3 cd d3 1c			call macro_dsp_valuehl 
52f6				endm 
# End of macro FORTH_DSP_VALUEHL
52f6			 
52f6 11 1d ea				ld de, cli_var_array+2 
52f9				 
52f9 eb					ex de, hl 
52fa 73					ld (hl), e 
52fb 23					inc hl 
52fc 72					ld (hl), d 
52fd			 
52fd					; destroy value TOS 
52fd			 
52fd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
52fd cd 8b 1d			call macro_forth_dsp_pop 
5300				endm 
# End of macro FORTH_DSP_POP
5300				       NEXTW 
5300 cd 68 ee			call parse_vector 
5303 c3 ba 1e			jp macro_next 
5306				endm 
# End of macro NEXTW
5306			.V1Q: 
5306				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
5306 7b				db WORD_SYS_CORE+103             
5307 1a 53			dw .V2S            
5309 04				db 3 + 1 
530a .. 00			db "V1@",0              
530e				endm 
# End of macro CWHEAD
530e			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
530e 2a 1d ea				ld hl, (cli_var_array+2) 
5311 cd d7 1a				call forth_push_numhl 
5314				       NEXTW 
5314 cd 68 ee			call parse_vector 
5317 c3 ba 1e			jp macro_next 
531a				endm 
# End of macro NEXTW
531a			.V2S: 
531a				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
531a 7c				db WORD_SYS_CORE+104             
531b 35 53			dw .V2Q            
531d 04				db 3 + 1 
531e .. 00			db "V2!",0              
5322				endm 
# End of macro CWHEAD
5322			;| V2! ( u1 -- )  Store value to v2 | DONE 
5322					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5322 cd d3 1c			call macro_dsp_valuehl 
5325				endm 
# End of macro FORTH_DSP_VALUEHL
5325			 
5325 11 1f ea				ld de, cli_var_array+4 
5328				 
5328 eb					ex de, hl 
5329 73					ld (hl), e 
532a 23					inc hl 
532b 72					ld (hl), d 
532c			 
532c					; destroy value TOS 
532c			 
532c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
532c cd 8b 1d			call macro_forth_dsp_pop 
532f				endm 
# End of macro FORTH_DSP_POP
532f				       NEXTW 
532f cd 68 ee			call parse_vector 
5332 c3 ba 1e			jp macro_next 
5335				endm 
# End of macro NEXTW
5335			.V2Q: 
5335				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
5335 7d				db WORD_SYS_CORE+105             
5336 49 53			dw .V3S            
5338 04				db 3 + 1 
5339 .. 00			db "V2@",0              
533d				endm 
# End of macro CWHEAD
533d			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
533d 2a 1f ea				ld hl, (cli_var_array+4) 
5340 cd d7 1a				call forth_push_numhl 
5343				       NEXTW 
5343 cd 68 ee			call parse_vector 
5346 c3 ba 1e			jp macro_next 
5349				endm 
# End of macro NEXTW
5349			.V3S: 
5349				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
5349 7c				db WORD_SYS_CORE+104             
534a 64 53			dw .V3Q            
534c 04				db 3 + 1 
534d .. 00			db "V3!",0              
5351				endm 
# End of macro CWHEAD
5351			;| V3! ( u1 -- )  Store value to v3 | DONE 
5351					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5351 cd d3 1c			call macro_dsp_valuehl 
5354				endm 
# End of macro FORTH_DSP_VALUEHL
5354			 
5354 11 21 ea				ld de, cli_var_array+6 
5357				 
5357 eb					ex de, hl 
5358 73					ld (hl), e 
5359 23					inc hl 
535a 72					ld (hl), d 
535b			 
535b					; destroy value TOS 
535b			 
535b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
535b cd 8b 1d			call macro_forth_dsp_pop 
535e				endm 
# End of macro FORTH_DSP_POP
535e				       NEXTW 
535e cd 68 ee			call parse_vector 
5361 c3 ba 1e			jp macro_next 
5364				endm 
# End of macro NEXTW
5364			.V3Q: 
5364				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
5364 7d				db WORD_SYS_CORE+105             
5365 78 53			dw .END            
5367 04				db 3 + 1 
5368 .. 00			db "V3@",0              
536c				endm 
# End of macro CWHEAD
536c			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
536c 2a 21 ea				ld hl, (cli_var_array+6) 
536f cd d7 1a				call forth_push_numhl 
5372				       NEXTW 
5372 cd 68 ee			call parse_vector 
5375 c3 ba 1e			jp macro_next 
5378				endm 
# End of macro NEXTW
5378			 
5378			 
5378			 
5378			 
5378			 
5378			; end of dict marker 
5378			 
5378 00			.END:    db WORD_SYS_END 
5379 00 00			dw 0 
537b 00				db 0 
537c			 
537c			; use to jp here for user dict words to save on macro expansion  
537c			 
537c			user_dict_next: 
537c				NEXTW 
537c cd 68 ee			call parse_vector 
537f c3 ba 1e			jp macro_next 
5382				endm 
# End of macro NEXTW
5382			 
5382			 
5382			user_exec: 
5382				;    ld hl, <word code> 
5382				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
5382				;    call forthexec 
5382				;    jp user_dict_next   (NEXT) 
5382			        ;    <word code bytes> 
5382 eb				ex de, hl 
5383 2a b5 e5			ld hl,(os_tok_ptr) 
5386				 
5386				FORTH_RSP_NEXT 
5386 cd 7e 1a			call macro_forth_rsp_next 
5389				endm 
# End of macro FORTH_RSP_NEXT
5389			 
5389			if DEBUG_FORTH_UWORD 
5389						DMARK "UEX" 
5389 f5				push af  
538a 3a 9e 53			ld a, (.dmark)  
538d 32 5e ee			ld (debug_mark),a  
5390 3a 9f 53			ld a, (.dmark+1)  
5393 32 5f ee			ld (debug_mark+1),a  
5396 3a a0 53			ld a, (.dmark+2)  
5399 32 60 ee			ld (debug_mark+2),a  
539c 18 03			jr .pastdmark  
539e ..			.dmark: db "UEX"  
53a1 f1			.pastdmark: pop af  
53a2			endm  
# End of macro DMARK
53a2				CALLMONITOR 
53a2 cd 6b ee			call debug_vector  
53a5				endm  
# End of macro CALLMONITOR
53a5			endif 
53a5			 
53a5			 
53a5			 
53a5 eb				ex de, hl 
53a6 22 b5 e5			ld (os_tok_ptr), hl 
53a9				 
53a9				; Don't use next - Skips the first word in uword. 
53a9			 
53a9 c3 3b 1f			jp exec1 
53ac			;	NEXT 
53ac			 
53ac			 
53ac			; eof 
# End of file forth_wordsv4.asm
53ac			endif 
53ac			;;;;;;;;;;;;;; Debug code 
53ac			 
53ac			 
53ac			;if DEBUG_FORTH_PARSE 
53ac .. 00		.nowordfound: db "No match",0 
53b5 .. 00		.compword:	db "Comparing word ",0 
53c5 .. 00		.nextwordat:	db "Next word at",0 
53d2 .. 00		.charmatch:	db "Char match",0 
53dd			;endif 
53dd			if DEBUG_FORTH_JP 
53dd			.foundword:	db "Word match. Exec..",0 
53dd			endif 
53dd			;if DEBUG_FORTH_PUSH 
53dd .. 00		.enddict:	db "Dict end. Push.",0 
53ed .. 00		.push_str:	db "Pushing string",0 
53fc .. 00		.push_num:	db "Pushing number",0 
540b .. 00		.data_sp:	db "SP:",0 
540f .. 00		.wordinhl:	db "Word in HL (2/0):",0 
5421 .. 00		.wordinde:	db "Word in DE (3/0):",0 
5433 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
5445			;endif 
5445			;if DEBUG_FORTH_MALLOC 
5445 .. 00		.push_malloc:	db "Malloc address",0 
5454			;endif 
5454			 
5454			 
5454			 
5454			; display malloc address and current data stack pointer  
5454			 
5454			malloc_error: 
5454 d5				push de 
5455 f5				push af 
5456 e5				push hl 
5457 cd bc 0b			call clear_display 
545a 11 7a 54			ld de, .mallocerr 
545d 3e 00			ld a,0 
545f			;	ld de,os_word_scratch 
545f cd ce 0b			call str_at_display 
5462 3e 11			ld a, display_row_1+17 
5464 11 5e ee			ld de, debug_mark 
5467 cd ce 0b			call str_at_display 
546a cd de 0b			call update_display 
546d				;call break_point_state 
546d cd 7e 67			call cin_wait 
5470			 
5470			;	ld a, ' ' 
5470			;	ld (os_view_disable), a 
5470 cd 56 14			call bp_on 
5473 e1				pop hl 
5474 f1				pop af 
5475 d1				pop de	 
5476				CALLMONITOR 
5476 cd 6b ee			call debug_vector  
5479				endm  
# End of macro CALLMONITOR
5479 c9				ret 
547a			 
547a .. 00		.mallocerr: 	db "Malloc Error",0 
5487			;if DEBUG_FORTH_PUSH 
5487			display_data_sp: 
5487 f5				push af 
5488			 
5488				; see if disabled 
5488			 
5488			 
5488 3a 6b ee			ld a, (debug_vector) 
548b fe c9			cp $C9  ; RET 
548d				;ld a, (os_view_disable) 
548d				;cp '*' 
548d 28 65			jr z, .skipdsp 
548f			 
548f e5				push hl 
5490 e5				push hl 
5491 e5			push hl 
5492 cd bc 0b			call clear_display 
5495 e1			pop hl 
5496 7c				ld a,h 
5497 21 b9 e5			ld hl, os_word_scratch 
549a cd e2 0f			call hexout 
549d e1				pop hl 
549e 7d				ld a,l 
549f 21 bb e5			ld hl, os_word_scratch+2 
54a2 cd e2 0f			call hexout 
54a5 21 bd e5			ld hl, os_word_scratch+4 
54a8			;	ld a,0 
54a8 36 00			ld (hl),0 
54aa 11 b9 e5			ld de,os_word_scratch 
54ad 3e 28				ld a, display_row_2 
54af cd ce 0b				call str_at_display 
54b2 11 0f 54			ld de, .wordinhl 
54b5 3e 00			ld a, display_row_1 
54b7			 
54b7 cd ce 0b				call str_at_display 
54ba 11 5e ee			ld de, debug_mark 
54bd 3e 11			ld a, display_row_1+17 
54bf			 
54bf cd ce 0b				call str_at_display 
54c2			 
54c2				; display current data stack pointer 
54c2 11 0b 54			ld de,.data_sp 
54c5 3e 30				ld a, display_row_2 + 8 
54c7 cd ce 0b				call str_at_display 
54ca			 
54ca 2a e1 e9			ld hl,(cli_data_sp) 
54cd e5				push hl 
54ce 7c				ld a,h 
54cf 21 b9 e5			ld hl, os_word_scratch 
54d2 cd e2 0f			call hexout 
54d5 e1				pop hl 
54d6 7d				ld a,l 
54d7 21 bb e5			ld hl, os_word_scratch+2 
54da cd e2 0f			call hexout 
54dd 21 bd e5			ld hl, os_word_scratch+4 
54e0			;	ld a,0 
54e0 36 00			ld (hl),0 
54e2 11 b9 e5			ld de,os_word_scratch 
54e5 3e 33				ld a, display_row_2 + 11 
54e7 cd ce 0b				call str_at_display 
54ea			 
54ea			 
54ea cd de 0b			call update_display 
54ed cd f0 0a			call delay1s 
54f0 cd f0 0a			call delay1s 
54f3 e1				pop hl 
54f4			.skipdsp: 
54f4 f1				pop af 
54f5 c9				ret 
54f6			 
54f6			display_data_malloc: 
54f6			 
54f6 f5				push af 
54f7 e5				push hl 
54f8 e5				push hl 
54f9 e5			push hl 
54fa cd bc 0b			call clear_display 
54fd e1			pop hl 
54fe 7c				ld a,h 
54ff 21 b9 e5			ld hl, os_word_scratch 
5502 cd e2 0f			call hexout 
5505 e1				pop hl 
5506 7d				ld a,l 
5507 21 bb e5			ld hl, os_word_scratch+2 
550a cd e2 0f			call hexout 
550d 21 bd e5			ld hl, os_word_scratch+4 
5510			;	ld a,0 
5510 36 00			ld (hl),0 
5512 11 b9 e5			ld de,os_word_scratch 
5515 3e 28				ld a, display_row_2 
5517 cd ce 0b				call str_at_display 
551a 11 45 54			ld de, .push_malloc 
551d 3e 00			ld a, display_row_1 
551f			 
551f cd ce 0b				call str_at_display 
5522			 
5522				; display current data stack pointer 
5522 11 0b 54			ld de,.data_sp 
5525 3e 30				ld a, display_row_2 + 8 
5527 cd ce 0b				call str_at_display 
552a			 
552a 2a e1 e9			ld hl,(cli_data_sp) 
552d e5				push hl 
552e 7c				ld a,h 
552f 21 b9 e5			ld hl, os_word_scratch 
5532 cd e2 0f			call hexout 
5535 e1				pop hl 
5536 7d				ld a,l 
5537 21 bb e5			ld hl, os_word_scratch+2 
553a cd e2 0f			call hexout 
553d 21 bd e5			ld hl, os_word_scratch+4 
5540			;	ld a,0 
5540 36 00			ld (hl),0 
5542 11 b9 e5			ld de,os_word_scratch 
5545 3e 33				ld a, display_row_2 + 11 
5547 cd ce 0b				call str_at_display 
554a			 
554a cd de 0b			call update_display 
554d cd f0 0a			call delay1s 
5550 cd f0 0a			call delay1s 
5553 e1				pop hl 
5554 f1				pop af 
5555 c9				ret 
5556			;endif 
5556			 
5556			include "forth_autostart.asm" 
5556			; list of commands to perform at system start up 
5556			 
5556			startcmds: 
5556			;	dw test11 
5556			;	dw test12 
5556			;	dw test13 
5556			;	dw test14 
5556			;	dw test15 
5556			;	dw test16 
5556			;	dw test17 
5556			;	dw ifthtest1 
5556			;	dw ifthtest2 
5556			;	dw ifthtest3 
5556			;	dw mmtest1 
5556			;	dw mmtest2 
5556			;	dw mmtest3 
5556			;	dw mmtest4 
5556			;	dw mmtest5 
5556			;	dw mmtest6 
5556			;	dw iftest1 
5556			;	dw iftest2 
5556			;	dw iftest3 
5556			;	dw looptest1 
5556			;	dw looptest2 
5556			;	dw test1 
5556			;	dw test2 
5556			;	dw test3 
5556			;	dw test4 
5556			;	dw game2r 
5556			;	dw game2b1 
5556			;	dw game2b2 
5556			 
5556				; start up words that are actually useful 
5556			 
5556			;    dw spi1 
5556			;    dw spi2 
5556			;    dw spi3 
5556			;    dw spi4 
5556			;    dw spi5 
5556			;    dw spi6 
5556			;    dw spi7 
5556			; 
5556			;    dw spi8 
5556			;    dw spi9 
5556			;    dw spi10 
5556			 
5556			; file editor 
5556			;	dw edit1 
5556			;	dw edit2 
5556			;	dw edit3 
5556			 
5556			;	dw longread 
5556 cb 5a			dw clrstack 
5558 ff 5a			dw type 
555a 24 5b			dw ztype 
555c cb 5c			dw nip 
555e b8 5c			dw tuck 
5560			;	dw stest 
5560 5b 5b			dw strncpy 
5562 dd 5c			dw list 
5564 bc 5b			dw start1 
5566 cc 5b			dw start2 
5568			;	dw start3 
5568			;	dw start3b 
5568			;	dw start3c 
5568			 
5568				; (unit) testing words 
5568			 
5568			;	dw mtesta 
5568			;	dw mtestb 
5568			;	dw mtestc 
5568			;	dw mtestd 
5568			;	dw mteste 
5568			 
5568				; demo/game words 
5568			 
5568			;        dw game3w 
5568			;        dw game3p 
5568			;        dw game3sc 
5568			;        dw game3vsi 
5568			;        dw game3vs 
5568				 
5568			;	dw game2b 
5568			;	dw game2bf 
5568			;	dw game2mba 
5568			;	dw game2mbas 
5568			;	dw game2mb 
5568			 
5568 0e 5f			dw game1 
556a 1f 5f			dw game1a 
556c 81 5f			dw game1b 
556e b6 5f			dw game1c 
5570 ec 5f			dw game1d 
5572 1d 60			dw game1s 
5574 31 60			dw game1t 
5576 46 60			dw game1f 
5578 7a 60			dw game1z 
557a be 60			dw game1zz 
557c			 
557c 47 5d			dw test5 
557e 7f 5d			dw test6 
5580 b7 5d			dw test7 
5582 cb 5d			dw test8 
5584 f7 5d			dw test9 
5586 0d 5e			dw test10 
5588				 
5588 95 61		        dw ssv5 
558a 79 61		        dw ssv4 
558c 5d 61		        dw ssv3 
558e 27 61		        dw ssv2 
5590 ae 61		        dw ssv1 
5592 f6 61		        dw ssv1cpm 
5594			;	dw keyup 
5594			;	dw keydown 
5594			;	dw keyleft 
5594			;	dw keyright 
5594			;	dw 	keyf1 
5594			;	dw keyf2 
5594			;	dw keyf3 
5594			;	dw keyf4 
5594			;	dw keyf5 
5594			;	dw keyf6 
5594			;	dw keyf7 
5594			;	dw keyf8 
5594			;	dw keyf9 
5594			;	dw keyf10 
5594			;	dw keyf11 
5594			;	dw keyf12 
5594			;	dw keytab 
5594			;	dw keycr 
5594			;	dw keyhome 
5594			;	dw keyend 
5594			;	dw keybs 
5594 00 00			db 0, 0	 
5596			 
5596			 
5596			; File Editor 
5596			 
5596			; ( id - ) use 'e' to edit the displayed line 
5596 .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
55b7 .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
55ec			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
55ec .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
5624			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
5624			 
5624			; SPI Net support words 
5624			 
5624			; v0! = node to send to 
5624			; ( str count - ) 
5624 .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
567d			 
567d			; spiputc ( char node - ) 
567d .. 00		spi2:       db ": spiputc spicel $10 spio spio ptr @ spio spiceh ; ",0 
56b1			; spiputc ( u node - ) 
56b1 .. 00		spi2b:       db ": spiputb spicel $10 spio spio spio spiceh ; ",0 
56df			 
56df			; spigetc ( - n ) 
56df .. 00		spi4:       db ": spigetc spicel $11 spio spii spiceh ; ", 0 
5708			 
5708			; getnode ( - n ) 
5708 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
5735			 
5735			; ( str node - )  
5735 .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
579b			; store string ( str i - ) 
579b			 
579b			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
579b .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
57f0			 
57f0			; get string ( addr i -  )    TO FIX 
57f0			 
57f0 .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
5848			 
5848			 
5848			; user word backup 
5848			; ubie 
5848			; ubiall 
5848			 
5848 .. 00		spib1: db ": UBIALL $01 do cls ptr count type list cr concat count soctype 2drop loop ;",0 
5895 .. 00		spib2: db ": UBIE $01 do cls ptr count type waitk $79 = if list cr concat count soctype drop then 2drop loop ;", 0 
58f9 .. 00		spib3: db ": SPISTRZ ptr count $00 do dup i + @ spio $01 pause loop ;",0 
5934 .. 00		spib4: db ": SOCCON spicel $22 spio spistrz ;",0 
5957 .. 00		spib5: db ": SOCTYPE spiceh spicel $00 do dup i + @ $20 spio spio loop ;",0 
5995			 
5995			 
5995			; NETCHAT (TODO) 
5995			; Program to allow two nodes to chat with eachother 
5995			; 
5995			; v0 - target node 
5995			;  
5995			; accept input at 0,0 
5995			; if input is string send spitype to target node 
5995			; starting at row 2,0 , while spigetchr is not zero ->  
5995			; 
5995			; 
5995			; TODO add paging of get request 
5995			 
5995			; ( node - ) 
5995 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
59b4 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
5a0c .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
5a84			 
5a84			 
5a84			; Long read of currently open file 
5a84 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
5acb			 
5acb			; clear stack  
5acb			 
5acb .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
5aff			 
5aff			; type ( addr count - ) 
5aff .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
5b24 .. 00		ztype:     db ": ztype repeat dup @ emit #1 + dup @ #0 = not until ; ", 0 
5b5b			 
5b5b			; some direct memory words 
5b5b			; strncpy ( len t f -- t ) 
5b5b			 
5b5b .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
5bbc			 
5bbc .. 00		start1:     	db ": bpon $00 bp ;",0 
5bcc .. 00		start2:     	db ": bpoff $01 bp ;",0 
5bdd .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
5c58 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
5cb8			 
5cb8 .. 00		tuck:         db ": tuck swap over ;", 0 
5ccb .. 00		nip:         db ": nip swap drop ;", 0 
5cdd			 
5cdd			; a handy word to list items on the stack 
5cdd			 
5cdd .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
5d47			 
5d47			 
5d47			; test stack  
5d47			; rnd8 stest 
5d47			 
5d47			;stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
5d47			 
5d47			; random malloc and free cycles 
5d47			 
5d47			;mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5d47			 
5d47			; fixed malloc and free cycles 
5d47			 
5d47			;mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5d47			 
5d47			; fixed double string push and drop cycle  
5d47			 
5d47			;mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
5d47			 
5d47			; consistent fixed string push and drop cycle  
5d47			 
5d47			;mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5d47			 
5d47			;mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5d47			 
5d47			;test1:		db ": aa 1 2 3 ;", 0 
5d47			;test2:     	db "111 aa 888 999",0 
5d47			;test3:     	db ": bb 77 ;",0 
5d47			;test4:     	db "$02 $01 do i . loop bb",0 
5d47			 
5d47 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
5d7f .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
5db7 .. 00		test7:     	db ": box hline vline ;",0 
5dcb .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
5df7 .. 00		test9:     	db ": sw $01 adsp world ;",0 
5e0d .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
5e32			;test11:     	db "hello create .",0 
5e32			;test12:     	db "hello2 create .",0 
5e32			 
5e32			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
5e32			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
5e32			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
5e32			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
5e32			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
5e32			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
5e32			 
5e32			;iftest1:     	db "$0001 IF cls .",0 
5e32			;iftest2:     	db "$0000 IF cls .",0 
5e32			;iftest3:     	db "$0002 $0003 - IF cls .",0 
5e32			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
5e32			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
5e32			 
5e32			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5e32			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5e32			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5e32			 
5e32			 
5e32 .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
5e56 .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
5e86 .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
5eab .. 00		sound4: db ": cha $00 ; ",0 
5eb8 .. 00		sound5: db ": chb $20 ; ",0 
5ec5 .. 00		sound6: db ": chc $40 ; ",0 
5ed2 .. 00		sound7: db ": chd $60 ; ",0 
5edf .. 00		sound8: db ": cnote $80 + + note ; ", 0 
5ef7 .. 00		sound9: db ": cvol $90 + + note ; ", 0 
5f0e			 
5f0e			 
5f0e			 
5f0e			 
5f0e			; a small guess the number game 
5f0e			 
5f0e .. 00		game1:          db ": gsn rnd8 v1! ;",0 
5f1f .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
5f81			 
5f81 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
5fb6 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
5fec .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
601d .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
6031 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
6046 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
607a .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
60be			 
60be			; Using 'ga' save a high score across multiple runs using external storage 
60be			 
60be .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
6127			 
6127			 
6127			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
6127			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
6127			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
6127			 
6127			; simple screen saver to test code memory reuse to destruction 
6127			 
6127 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
615d .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
6179 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
6195 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
61ae .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
61f6 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
624d			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
624d			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
624d			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
624d			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
624d			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
624d			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
624d			 
624d			 
624d			 
624d			; minesweeper/battleship finding game 
624d			; draws a game board of random ship/mine positions 
624d			; user enters coords to see if it hits on 
624d			; game ends when all are hit 
624d			; when hit or miss says how many may be in the area 
624d			 
624d			; setup the game board and then hide it 
624d			;game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
624d			;game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
624d			;; prompt for where to target 
624d			;game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
624d			;game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
624d			;; TODO see if the entered coords hits or misses pushes char hit of miss 
624d			;game2mbht:      db ": mbckht nop ;",0 
624d			;game2mbms:      db ": mbcms nop ;",0 
624d			; TODO how many might be near by 
624d			;game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
624d			 
624d			; Game 3 
624d			 
624d			; Vert scroller ski game - avoid the trees! 
624d			 
624d			; v0 score (ie turns) 
624d			; v1 player pos 
624d			; v2 left wall 
624d			; v3 right wall 
624d			 
624d			; Draw side walls randomly 
624d			 
624d			;game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
624d			 
624d			; Draw player 
624d			;game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
624d			 
624d			; TODO Get Key 
624d			 
624d			; TODO Move left right 
624d			 
624d			; scroll and move walls a bit 
624d			 
624d			;game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
624d			 
624d			; main game loop 
624d			 
624d			;game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
624d			;game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
624d			 
624d			; key board defs 
624d			 
624d .. 00		keyup:       db ": keyup $05 ;",0 
625b .. 00		keydown:       db ": keydown $0a ;",0 
626b .. 00		keyleft:       db ": keyleft $0b ;",0 
627b .. 00		keyright:       db ": keyright $0c ;",0 
628c .. 00		keyf1:       db ": keyf1 $10 ;",0 
629a .. 00		keyf2:       db ": keyf2 $11 ;",0 
62a8 .. 00		keyf3:       db ": keyf3 $12 ;",0 
62b6 .. 00		keyf4:       db ": keyf4 $13 ;",0 
62c4 .. 00		keyf5:       db ": keyf5 $14 ;",0 
62d2 .. 00		keyf6:       db ": keyf6 $15 ;",0 
62e0 .. 00		keyf7:       db ": keyf7 $16 ;",0 
62ee .. 00		keyf8:       db ": keyf8 $17 ;",0 
62fc .. 00		keyf9:       db ": keyf9 $18 ;",0 
630a .. 00		keyf10:       db ": keyf10 $19 ;",0 
6319 .. 00		keyf11:       db ": keyf11 $1a ;",0 
6328 .. 00		keyf12:       db ": keyf12 $1b ;",0 
6337			 
6337 .. 00		keytab:       db ": keytab $09 ;",0 
6346 .. 00		keycr:       db ": keycr $0d ;",0 
6354 .. 00		keyhome:       db ": keyhome $0e ;",0 
6364 .. 00		keyend:       db ": keyend $0f ;",0 
6373 .. 00		keybs:       db ": keybs $08 ;",0 
6381			 
6381			   
6381			 
6381			 
6381			 
6381			; eof 
# End of file forth_autostart.asm
6381			 
6381			 
6381			 
6381			; stack over and underflow checks 
6381			 
6381			; init the words to detect the under/overflow 
6381			 
6381			chk_stk_init: 
6381				; a vague random number to check so we dont get any "lucky" hits 
6381 3e 2d			ld a, 45 
6383 6f				ld l, a 
6384 00				nop 
6385 3e 17			ld a, 23 
6387 67				ld h, a 
6388			 
6388 22 90 e2			ld (chk_word), hl     ; the word we need to check against 
638b			 
638b			;	ld (chk_stund), hl	; stack points.... 
638b 22 00 ef			ld (chk_stovr), hl 
638e 22 df e9			ld (chk_ret_und), hl 
6391 22 9d e9			ld (chk_ret_ovr), hl 
6394 22 1b e9			ld (chk_loop_ovr), hl 
6397 22 19 e8			ld (chk_data_ovr), hl 
639a c9				ret 
639b				 
639b			check_stacks: 
639b				; check all stack words 
639b			 
639b e5				push hl 
639c d5				push de 
639d			 
639d			;	ld de,(chk_word) 
639d			;	ld hl, (chk_stund)	; stack points.... 
639d			;	if DEBUG_STK_FAULT 
639d			;		DMARK "FAa" 
639d			;		CALLMONITOR 
639d			;	endif 
639d			;	call cmp16 
639d			;	jp z, .chk_faulta 
639d			; 
639d			;	ld de, sfaultsu 
639d			;	jp .chk_fault 
639d			 
639d 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
63a0 ed 5b 90 e2		ld de,(chk_word) 
63a4				if DEBUG_STK_FAULT 
63a4					DMARK "FAb" 
63a4					CALLMONITOR 
63a4				endif 
63a4 cd 04 0e			call cmp16 
63a7 28 06			jr z, .chk_fault1 
63a9 11 4d 64			ld de, sfaultso 
63ac c3 fe 63			jp .chk_fault 
63af			.chk_fault1:  
63af 2a df e9			ld hl, (chk_ret_und) 
63b2 ed 5b 90 e2		ld de,(chk_word) 
63b6				if DEBUG_STK_FAULT 
63b6					DMARK "FAU" 
63b6					CALLMONITOR 
63b6				endif 
63b6 cd 04 0e			call cmp16 
63b9 ca c2 63			jp z, .chk_fault2 
63bc 11 5d 64			ld de, sfaultru 
63bf c3 fe 63			jp .chk_fault 
63c2			.chk_fault2:  
63c2 2a 9d e9			ld hl, (chk_ret_ovr) 
63c5 ed 5b 90 e2		ld de,(chk_word) 
63c9				if DEBUG_STK_FAULT 
63c9					DMARK "FA1" 
63c9					CALLMONITOR 
63c9				endif 
63c9 cd 04 0e			call cmp16 
63cc ca d5 63			jp z, .chk_fault3 
63cf 11 6b 64			ld de, sfaultro 
63d2 c3 fe 63			jp .chk_fault 
63d5			.chk_fault3:  
63d5 2a 1b e9			ld hl, (chk_loop_ovr) 
63d8 ed 5b 90 e2		ld de,(chk_word) 
63dc				if DEBUG_STK_FAULT 
63dc					DMARK "FA2" 
63dc					CALLMONITOR 
63dc				endif 
63dc cd 04 0e			call cmp16 
63df ca e8 63			jp z, .chk_fault4 
63e2 11 85 64			ld de, sfaultlo 
63e5 c3 fe 63			jp .chk_fault 
63e8			.chk_fault4:  
63e8 2a 19 e8			ld hl, (chk_data_ovr) 
63eb ed 5b 90 e2		ld de,(chk_word) 
63ef				if DEBUG_STK_FAULT 
63ef					DMARK "FA3" 
63ef					CALLMONITOR 
63ef				endif 
63ef cd 04 0e			call cmp16 
63f2 ca fb 63			jp z, .chk_fault5 
63f5 11 9f 64			ld de, sfaultdo 
63f8 c3 fe 63			jp .chk_fault 
63fb			 
63fb			 
63fb			.chk_fault5:  
63fb d1				pop de 
63fc e1				pop hl 
63fd			 
63fd c9				ret 
63fe			 
63fe cd bc 0b		.chk_fault: 	call clear_display 
6401 3e 28				ld a, display_row_2 
6403 cd ce 0b				call str_at_display 
6406 11 2f 64				   ld de, .stackfault 
6409 3e 00				ld a, display_row_1 
640b cd ce 0b				call str_at_display 
640e 11 5e ee				    ld de, debug_mark 
6411 3e 11				ld a, display_row_1+17 
6413 cd ce 0b				call str_at_display 
6416 cd de 0b				call update_display 
6419			 
6419				; prompt before entering montior for investigating issue 
6419			 
6419 3e 78			ld a, display_row_4 
641b 11 b9 17			ld de, endprog 
641e			 
641e cd de 0b			call update_display		 
6421			 
6421 cd 4f 1a			call next_page_prompt 
6424			 
6424 d1				pop de 
6425 e1				pop hl 
6426 cd 0d 18				call monitor 
6429 cd 60 1e				call forth_warmstart 
642c c3 0b 17				jp warmstart_afterauto 
642f					;jp 0 
642f					;halt 
642f			 
642f			 
642f			 
642f .. 00		.stackfault: 	db "Stack fault:",0 
643c			 
643c .. 00		sfaultsu: 	db	"Stack under flow",0 
644d .. 00		sfaultso: 	db	"Stack over flow",0 
645d .. 00		sfaultru:	db "RTS underflow",0 
646b .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
6485 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
649f .. 00		sfaultdo:	db "DTS overflow", 0 
64ac			 
64ac			 
64ac			fault_dsp_under: 
64ac 11 be 64			ld de, .dsp_under 
64af c3 74 65			jp .show_fault 
64b2			 
64b2			fault_rsp_under: 
64b2 11 cc 64			ld de, .rsp_under 
64b5 c3 74 65			jp .show_fault 
64b8			fault_loop_under: 
64b8 11 da 64			ld de, .loop_under 
64bb c3 74 65			jp .show_fault 
64be			 
64be .. 00		.dsp_under: db "DSP Underflow",0 
64cc .. 00		.rsp_under: db "RSP Underflow",0 
64da .. 00		.loop_under: db "LOOP Underflow",0 
64e9			 
64e9			 
64e9 d5			type_faultn: 	push de 
64ea e5					push hl 
64eb cd bc 0b				call clear_display 
64ee 11 18 65				   ld de, .typefaultn 
64f1 3e 00				ld a, display_row_1 
64f3 cd ce 0b				call str_at_display 
64f6 11 5e ee				    ld de, debug_mark 
64f9 3e 11				ld a, display_row_1+17 
64fb cd ce 0b				call str_at_display 
64fe cd de 0b				call update_display 
6501			 
6501				; prompt before entering montior for investigating issue 
6501			 
6501 3e 78			ld a, display_row_4 
6503 11 b9 17			ld de, endprog 
6506			 
6506 cd de 0b			call update_display		 
6509			 
6509 cd 4f 1a			call next_page_prompt 
650c			 
650c e5					push hl 
650d d5					push de 
650e cd 0d 18				call monitor 
6511 cd 60 1e				call forth_warmstart 
6514 c3 0b 17				jp warmstart_afterauto 
6517 76					halt 
6518			 
6518			 
6518 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
652f			 
652f d5			type_faults: 	push de 
6530 e5					push hl 
6531 cd bc 0b				call clear_display 
6534 11 5d 65				   ld de, .typefaults 
6537 3e 00				ld a, display_row_1 
6539 cd ce 0b				call str_at_display 
653c 11 5e ee				    ld de, debug_mark 
653f 3e 11				ld a, display_row_1+17 
6541 cd ce 0b				call str_at_display 
6544 cd de 0b				call update_display 
6547			 
6547				; prompt before entering montior for investigating issue 
6547			 
6547 3e 78			ld a, display_row_4 
6549 11 b9 17			ld de, endprog 
654c			 
654c cd de 0b			call update_display		 
654f			 
654f cd 4f 1a			call next_page_prompt 
6552			 
6552 e1					pop hl 
6553 d1					pop de 
6554 cd 0d 18				call monitor 
6557 cd 60 1e				call forth_warmstart 
655a c3 0b 17				jp warmstart_afterauto 
655d			 
655d			 
655d .. 00		.typefaults: db "STR Type Expected TOS!",0 
6574			 
6574			.show_fault: 	 
6574 d5					push de 
6575 cd bc 0b				call clear_display 
6578 d1					pop de 
6579 3e 00				ld a, display_row_1 
657b cd ce 0b				call str_at_display 
657e 11 5e ee				    ld de, debug_mark 
6581 3e 11				ld a, display_row_1+17 
6583 cd ce 0b				call str_at_display 
6586 cd de 0b				call update_display 
6589			 
6589				; prompt before entering montior for investigating issue 
6589			 
6589 3e 78			ld a, display_row_4 
658b 11 b9 17			ld de, endprog 
658e			 
658e cd de 0b			call update_display		 
6591			 
6591 cd 4f 1a			call next_page_prompt 
6594			 
6594 e1					pop hl 
6595 d1					pop de 
6596 cd 0d 18				call monitor 
6599			; do a dump to cli and not warmstart so we preserve all of the uwords.  
6599			; TODO Make optional fault restart to cli or warm boot? 
6599					;jp warmstart 
6599 c3 4e 17				jp cli 
659c 76					halt 
659d			 
659d			 
659d			; handle the auto run of code from files in storage 
659d			 
659d			 
659d			include "forth_startup.asm" 
659d			; Which startup method to use? 
659d			; 
659d			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
659d			; followed by loading of a list of scripts in eeprom 
659d			 
659d			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
659d			; from eeprom 
659d			 
659d			; Select with define in main stubs 
659d			 
659d			if STARTUP_V1 
659d				include "forth_startupv1.asm" 
659d			; Startup script loading version 1 
659d			 
659d			; If SE storage is available first stage is to use the selected file 
659d			; then go through the eeprom list 
659d			 
659d .. 00		sprompt1: db "Startup load...",0 
65ad .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
65c3			 
65c3			 
65c3			 
65c3			 
65c3			forth_startup: 
65c3 21 56 55			ld hl, startcmds 
65c6 3e 00			ld a, 0 
65c8 32 da e6			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
65cb			 
65cb e5			.start1:	push hl 
65cc cd bc 0b			call clear_display 
65cf 11 9d 65			ld de, sprompt1 
65d2 3e 00		        ld a, display_row_1 
65d4 cd ce 0b			call str_at_display 
65d7 11 ad 65			ld de, sprompt2 
65da 3e 28		        ld a, display_row_2 
65dc cd ce 0b			call str_at_display 
65df e1				pop hl 
65e0 e5				push hl 
65e1 5e				ld e,(hl) 
65e2 23				inc hl 
65e3 56				ld d,(hl) 
65e4 3e 50		        ld a, display_row_3 
65e6 cd ce 0b			call str_at_display 
65e9 cd de 0b			call update_display 
65ec			 
65ec			 
65ec 3a da e6			ld a, (os_last_cmd) 
65ef fe 00			cp 0 
65f1 28 05			jr z, .startprompt 
65f3 cd e4 0a			call delay250ms 
65f6 18 24			jr .startdo 
65f8				 
65f8				 
65f8			 
65f8			.startprompt: 
65f8			 
65f8 3e 9f			ld a,display_row_4 + display_cols - 1 
65fa 11 4d 1a		        ld de, endprg 
65fd cd ce 0b			call str_at_display 
6600 cd de 0b			call update_display 
6603 cd f0 0a			call delay1s 
6606 cd 7e 67			call cin_wait 
6609						 
6609 fe 2a			cp '*' 
660b 28 5e			jr z, .startupend1 
660d fe 23			cp '#' 
660f 20 07			jr nz, .startno 
6611 3e 01			ld a, 1 
6613 32 da e6			ld (os_last_cmd),a 
6616 18 04			jr .startdo 
6618 fe 31		.startno:	cp '1' 
661a 28 3a			jr z,.startnxt  
661c			 
661c				; exec startup line 
661c			.startdo:	 
661c e1				pop hl 
661d e5				push hl 
661e				 
661e 5e				ld e,(hl) 
661f 23				inc hl 
6620 56				ld d,(hl) 
6621 eb				ex de,hl 
6622			 
6622 e5				push hl 
6623			 
6623 3e 00			ld a, 0 
6625				;ld a, FORTH_END_BUFFER 
6625 cd 49 11			call strlent 
6628 23				inc hl   ; include zero term to copy 
6629 06 00			ld b,0 
662b 4d				ld c,l 
662c e1				pop hl 
662d 11 b4 e2			ld de, scratch 
6630 ed b0			ldir 
6632			 
6632			 
6632 21 b4 e2			ld hl, scratch 
6635 cd 00 1f			call forthparse 
6638 cd 38 1f			call forthexec 
663b cd 5a 1e			call forthexec_cleanup 
663e			 
663e 3e 78			ld a, display_row_4 
6640 11 b9 17			ld de, endprog 
6643			 
6643 cd de 0b			call update_display		 
6646			 
6646 3a da e6			ld a, (os_last_cmd) 
6649 fe 00			cp 0 
664b 20 09			jr nz, .startnxt 
664d cd 4f 1a			call next_page_prompt 
6650 cd bc 0b		        call clear_display 
6653 cd de 0b			call update_display		 
6656			 
6656				; move onto next startup line? 
6656			.startnxt: 
6656			 
6656 cd e4 0a			call delay250ms 
6659 e1				pop hl 
665a			 
665a 23				inc hl 
665b 23				inc hl 
665c			 
665c e5				push hl 
665d 5e				ld e, (hl) 
665e 23				inc hl 
665f 56				ld d, (hl) 
6660 e1				pop hl 
6661				; TODO replace 0 test 
6661			 
6661 eb				ex de, hl 
6662 cd 0f 0e			call ishlzero 
6665			;	ld a,e 
6665			;	add d 
6665			;	cp 0    ; any left to do? 
6665 eb				ex de, hl 
6666 c2 cb 65			jp nz, .start1 
6669 18 01			jr .startupend 
666b			 
666b e1			.startupend1: pop hl 
666c			.startupend: 
666c			 
666c cd bc 0b			call clear_display 
666f cd de 0b			call update_display 
6672 c9				ret 
6673			if STORAGE_SE 
6673			 
6673			sprompt3: db "Loading from start-up file?:",0 
6673			sprompt4: db "(Y=Any key/N=No)",0 
6673			 
6673			 
6673			forth_autoload: 
6673			 
6673				; load block 0 of store 1 
6673				 
6673				ld a, $fe      ; bit 0 clear 
6673				ld (spi_device), a 
6673			 
6673				call storage_get_block_0 
6673			 
6673				ld a, (store_page+STORE_0_AUTOFILE) 
6673			 
6673				cp 0 
6673				ret z     ; auto start not enabled 
6673			 
6673				call clear_display 
6673			 
6673				; set bank 
6673			 
6673					ld a, (store_page+STORE_0_BANKRUN) 
6673					ld (spi_device), a 
6673			 
6673				; get file id to load from and get the file name to display 
6673			 
6673					ld a, (store_page+STORE_0_FILERUN) 
6673			 
6673					ld l, 0 
6673					ld h, a 
6673					ld de, store_page 
6673			 
6673					if DEBUG_FORTH_WORDS 
6673						DMARK "ASp" 
6673						CALLMONITOR 
6673					endif 
6673					call storage_read 
6673			 
6673					if DEBUG_FORTH_WORDS 
6673						DMARK "ASr" 
6673						CALLMONITOR 
6673					endif 
6673			 
6673					call ishlzero 
6673					ret z             ; file not found 
6673			 
6673					ld a, display_row_2 + 10 
6673					ld de, store_page+3 
6673					call str_at_display 
6673				 
6673			; 
6673			 
6673				ld a, display_row_1+5 
6673				ld de, sprompt3 
6673				call str_at_display 
6673				ld a, display_row_3+15 
6673				ld de, sprompt4 
6673				call str_at_display 
6673			 
6673				call update_display 
6673			 
6673				call cin_wait 
6673				cp 'n' 
6673				ret z 
6673				cp 'N' 
6673				ret z 
6673			 
6673				call delay1s 
6673			 
6673				ld a, (store_page+2) 
6673				ld (store_openmaxext), a    ; save count of ext 
6673				ld a, 1  
6673				ld (store_openext), a    ; save count of ext 
6673			 
6673			.autof:  
6673				ld l , a 
6673				 
6673				ld a, (store_page) 
6673				ld h, a	 
6673				ld de, store_page 
6673					if DEBUG_FORTH_WORDS 
6673						DMARK "ASl" 
6673						CALLMONITOR 
6673					endif 
6673					call storage_read 
6673				call ishlzero 
6673				ret z 
6673			;	jr z, .autoend 
6673			 
6673					if DEBUG_FORTH_WORDS 
6673						DMARK "ASc" 
6673						CALLMONITOR 
6673					endif 
6673				ld de, store_page+2 
6673				ld a, display_row_4 
6673				call str_at_display 
6673			 
6673				call update_display 
6673				call delay250ms 
6673			 
6673			 
6673			 
6673				ld hl, store_page+2 
6673				call forthparse 
6673				call forthexec 
6673				call forthexec_cleanup 
6673			 
6673				 
6673				ld a, (store_openext) 
6673				inc a 
6673				ld (store_openext), a    ; save count of ext 
6673			 
6673				jr .autof 
6673			;.autofdone: 
6673			; 
6673			;		if DEBUG_FORTH_WORDS 
6673			;			DMARK "ASx" 
6673			;			CALLMONITOR 
6673			;		endif 
6673			;;	call clear_display 
6673			;	ret 
6673			 
6673			 
6673			 
6673			endif 
# End of file forth_startupv1.asm
6673			endif 
6673			if STARTUP_V2 
6673				include "forth_startupv2.asm" 
6673			endif 
6673			 
# End of file forth_startup.asm
6673			 
6673			; eof 
# End of file forth_kernel.asm
6673			;include "nascombasic.asm" 
6673			;include "basicZ80.asm" 
6673			 
6673			 
6673			 
6673			; find out where the code ends if loaded into RAM (for SC114) 
6673			;endofcode:  
6673			;	nop 
6673			 
6673			 
6673			; jump to nmi vector 
6673			 
6673			init_nmi: 
6673 3e c9			ld a, $c9   ; RET 
6675 32 6e ee			ld (nmi_vector), a 
6678 c9				ret 
6679			nmi: 
6679 e5				push hl 
667a d5				push de 
667b c5				push bc 
667c f5				push af 
667d cd 6e ee			call nmi_vector 
6680 f5				push af 
6681 c5				push bc 
6682 d5				push de 
6683 e5				push hl 
6684 ed 4d			reti 
6686			 
6686			 
6686			; eof 
6686			 
# End of file main.asm
6686			;include "firmware_lcd_4x40.asm" 
6686			;;include "firmware_lcd_4x20.asm" 
6686			include "firmware_cpm_display.asm" 
6686			 
6686			; Serial display interface for SC114 
6686			 
6686			 
6686			display_row_1: equ 0 
6686			display_row_2: equ display_row_1+display_cols 
6686			display_row_3: equ display_row_2 + display_cols 
6686			display_row_4: equ display_row_3 + display_cols 
6686			 
6686			kLCDWidth:  EQU display_cols             ;Width in characters 
6686			kLCD_Line1: EQU 0x00  
6686			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
6686			; E1 
6686			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
6686			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
6686			 
6686			lcd_init: 
6686				; no init as handled by the SCM bios 
6686 c9				ret 
6687			 
6687			 
6687			; low level functions for direct screen writes 
6687			 
6687			; output char at pos? 
6687			fLCD_Str: 
6687			        ;out (SC114_SIO_1_OUT),a 
6687 c5				push bc 
6688 d5				push de 
6689 5f				ld e, a 
668a			; TODO Replace with CP/M BIOS call 
668a 0e 02			ld c, $02 
668c cd 05 00			call 5 
668f d1				pop de 
6690 c1				pop bc 
6691 c9				ret 
6692			 
6692			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
6692			fLCD_Pos: 
6692				; use ASCII escape to position 
6692			        ;out (SC114_SIO_1_OUT),a 
6692 c5				push bc 
6693 d5				push de 
6694 5f				ld e, a 
6695 0e 02			ld c, $02 
6697			; TODO Replace with CP/M BIOS call 
6697 cd 05 00			call 5 
669a d1				pop de 
669b c1				pop bc 
669c			 
669c c9				ret 
669d			 
669d			; output char at pos 
669d			fLCD_Data: 
669d			      ;  out (SC114_SIO_1_OUT),a 
669d c5				push bc 
669e d5				push de 
669f 0e 02			ld c, $02 
66a1 5f				ld e, a 
66a2			; TODO Replace with CP/M BIOS call 
66a2 cd 05 00			call 5 
66a5 d1				pop de 
66a6 c1				pop bc 
66a7			 
66a7 c9				ret 
66a8			 
66a8			; ascii cls  
66a8			 
66a8 1b 5b 48 24	.cls:   db 27, '[', 'H', "$" 
66ac			 
66ac 0d 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a ..	.clscpm: db 13, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,10,10,10,10,10,"$" 
66c3			;.clscpm: db 3, $3c,"$" 
66c3			 
66c3			; write the frame buffer given in hl to hardware  
66c3			write_display: 
66c3			 
66c3			API: equ 0 
66c3			 
66c3			if API 
66c3				push bc 
66c3				ld b, 4 
66c3			 
66c3			        ld (display_write_tmp), hl 	  
66c3			 
66c3				; clear and home cursor 
66c3			 
66c3				ld c, 9 
66c3				ld de, .cls 
66c3			; TODO Replace with CP/M BIOS call 
66c3				call 5 
66c3			 
66c3			 
66c3			.writeln: 
66c3			 
66c3				ld de, (display_write_tmp) 
66c3				ld c, 6 
66c3			; TODO Replace with CP/M BIOS call 
66c3				rst $30 
66c3				ld c, 7 
66c3				rst $30 
66c3			 
66c3				ld hl, (display_write_tmp) 
66c3				ld de, display_cols 
66c3				add hl,de 
66c3				ld (display_write_tmp),hl 
66c3			 
66c3				djnz  .writeln 
66c3			 
66c3				pop bc 
66c3			 
66c3			 
66c3				ret 
66c3			endif 
66c3 e5				push hl 
66c4 c5				push bc 
66c5 d5				push de 
66c6			 
66c6			;	ld c, 2 
66c6			;	;ld de, .cls 
66c6			;	ld a, 27 
66c6			;	rst $30 
66c6			;	ld c, 2 
66c6			;	;ld de, .cls 
66c6			;	ld a, '[' 
66c6			;	rst $30 
66c6			; 
66c6			;	ld c, 2 
66c6			;	;ld de, .cls 
66c6			;	ld a, 'H' 
66c6			;	rst $30 
66c6			; 
66c6			 
66c6			 
66c6			; lots of CR/LF 
66c6			;	ld c, 9 
66c6			;	ld de, .clscpm 
66c6			;	call 5 
66c6			 
66c6			; xterm cls 
66c6 0e 02			ld c, 2 
66c8 1e 1b			ld e, 27 
66ca cd 05 00			call 5 
66cd			; cls causes too much flicker 
66cd			;	ld c, 2 
66cd			;	ld e, 'c' 
66cd			;	call 5 
66cd			 
66cd			; use xterm home instead 
66cd 0e 02			ld c, 2 
66cf 1e 5b			ld e, '[' 
66d1 cd 05 00			call 5 
66d4 0e 02			ld c, 2 
66d6 1e 48			ld e, 'H' 
66d8 cd 05 00			call 5 
66db			LLL: equ 0 
66db			 
66db			if LLL 
66db			 
66db				ld c, 2 
66db				;ld de, .cls 
66db				ld e, 27 
66db			; TODO Replace with CP/M BIOS call 
66db				call 5 
66db			 
66db			 
66db				ld c, 2 
66db				;ld de, .cls 
66db				ld e, '[' 
66db			; TODO Replace with CP/M BIOS call 
66db				call 5 
66db				ld c, 2 
66db				;ld de, .cls 
66db				ld e, '2' 
66db			; TODO Replace with CP/M BIOS call 
66db				call 5 
66db				ld c, 2 
66db				;ld de, .cls 
66db				ld e, 'J' 
66db			; TODO Replace with CP/M BIOS call 
66db				call 5 
66db			 
66db			endif 
66db			 
66db d1				pop de 
66dc c1				pop bc 
66dd e1				pop hl 
66de			 
66de			 
66de 22 bc eb		        ld (display_write_tmp), hl 	  
66e1 3e 00			ld a, kLCD_Line1 
66e3			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
66e3 06 28			ld b, display_cols 
66e5 ed 5b bc eb		ld de, (display_write_tmp) 
66e9 cd 6c 67			call write_len_string 
66ec				 
66ec			 
66ec e5			push hl 
66ed d5			push de 
66ee c5			push bc 
66ef 0e 02			ld c, 2 
66f1 1e 0a			ld e, 10 
66f3 cd 05 00			call 5 
66f6 0e 02			ld c, 2 
66f8 1e 0d			ld e, 13 
66fa cd 05 00			call 5 
66fd			; TODO Replace with CP/M BIOS call 
66fd				;rst $30 
66fd c1			pop bc 
66fe d1			pop de 
66ff e1			pop hl 
6700			 
6700				 
6700 2a bc eb			ld hl, (display_write_tmp) 
6703 11 28 00			ld de, display_cols 
6706 19				add hl,de 
6707 22 bc eb			ld (display_write_tmp),hl 
670a			 
670a				 
670a 3e 28			ld a, kLCD_Line2 
670c			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
670c 06 28			ld b, display_cols 
670e ed 5b bc eb		ld de, (display_write_tmp) 
6712 cd 6c 67			call write_len_string 
6715				 
6715 2a bc eb			ld hl, (display_write_tmp) 
6718 11 28 00			ld de, display_cols 
671b 19				add hl,de 
671c 22 bc eb			ld (display_write_tmp),hl 
671f			 
671f e5			push hl 
6720 d5			push de 
6721 c5			push bc 
6722 0e 07			ld c, 7 
6724			; TODO Replace with CP/M BIOS call 
6724				;rst $30 
6724 0e 02			ld c, 2 
6726 1e 0a			ld e, 10 
6728 cd 05 00			call 5 
672b 0e 02			ld c, 2 
672d 1e 0d			ld e, 13 
672f cd 05 00			call 5 
6732 c1			pop bc 
6733 d1			pop de 
6734 e1			pop hl 
6735			 
6735				 
6735 3e 50			ld a, kLCD_Line3 
6737			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
6737 06 28			ld b, display_cols 
6739 ed 5b bc eb		ld de, (display_write_tmp) 
673d cd 6c 67			call write_len_string 
6740				 
6740 2a bc eb			ld hl, (display_write_tmp) 
6743 11 28 00			ld de, display_cols 
6746 19				add hl,de 
6747 22 bc eb			ld (display_write_tmp),hl 
674a			 
674a e5			push hl 
674b d5			push de 
674c c5			push bc 
674d 0e 07			ld c, 7 
674f			; TODO Replace with CP/M BIOS call 
674f				;rst $30 
674f 0e 02			ld c, 2 
6751 1e 0a			ld e, 10 
6753 cd 05 00			call 5 
6756 0e 02			ld c, 2 
6758 1e 0d			ld e, 13 
675a cd 05 00			call 5 
675d c1			pop bc 
675e d1			pop de 
675f e1			pop hl 
6760			 
6760				 
6760 3e 78			ld a, kLCD_Line4 
6762			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
6762 06 28			ld b, display_cols 
6764 ed 5b bc eb		ld de, (display_write_tmp) 
6768 cd 6c 67			call write_len_string 
676b c9					ret 
676c			 
676c			 
676c				; write out a fixed length string given in b from de 
676c			 
676c 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
676d cd 9d 66		            CALL fLCD_Data      ;Write character to display 
6770 13				inc de 
6771 10 f9			djnz write_len_string 
6773 c9				ret 
6774			 
6774			 
6774			; eof 
# End of file firmware_cpm_display.asm
6774			;include "firmware_key_5x10.asm" 
6774			;;include "firmware_key_4x10.asm" 
6774			include "firmware_key_cpm.asm" 
6774			; Serial keyboard interface for SC114 
6774			 
6774			 
6774			key_init: 
6774				; init keyboard macro pointers 
6774 21 00 00			ld hl, 0 
6777 22 fe ee			ld (key_macroroot), hl 
677a 22 fc ee			ld (key_macrolast), hl 
677d				; no init as handled by the SCM bios 
677d c9				ret 
677e			 
677e			 
677e			cin_wait: 
677e			;	ld a, 0 
677e			;	ret 
677e			 
677e				;in a,(SC114_SIO_1_IN) 
677e			        ; Use SCM API to get from whatever console device we are using 
677e			 
677e			; TODO Replace with CP/M BIOS call 
677e c5				push bc 
677f 0e 01			ld c, $01 
6781 cd 05 00			call 5 
6784 c1				pop bc 
6785 c9				ret 
6786			 
6786			cinndb:  
6786			cin: 
6786			 
6786			 
6786 c5				push bc 
6787			 
6787				; any key waiting to process? 
6787			; TODO Replace with CP/M BIOS call 
6787 0e 06			ld c, $06 
6789 cd 05 00			call 5 
678c 28 0d			jr z, .cin_skip 
678e			 
678e				; yep, get it 
678e			 
678e 0e 01			ld c, $01 
6790			; TODO Replace with CP/M BIOS call 
6790 cd 05 00			call 5 
6793			 
6793 fe 7f			cp $7f     ; back space 
6795 20 02			jr nz, .skipbs 
6797 3e 08			ld a, KEY_BS 
6799			.skipbs: 
6799			 
6799 c1				pop bc 
679a c9				ret 
679b			.cin_skip: 
679b 3e 00			ld a, 0 
679d c1				pop bc 
679e c9				ret 
679f			 
679f			 
679f			 
679f			 
# End of file firmware_key_cpm.asm
679f			endofcode:  
679f			baseram:  
679f 00				nop 
67a0			 
67a0			heap_start: equ baseram+15  ; Starting address of heap 
67a0			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
67a0			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
67a0			;VDU:  EQU     endofcode           ; BASIC Work space 
67a0			; eof 
67a0			 
# End of file os_mega_cpm.asm
67a0
