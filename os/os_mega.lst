# File os_mega.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			tos:	equ 0fffdh 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			SOUND_ENABLE: equ 1 
0000			 
0000			; Number of bytes available in heap   TODO make all of user ram 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 d6 15			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			;        nop  
0003			;        nop 
0003			;;	org 05h		; null out bdos call 
0003			; 
0003			;        nop  
0003			;        nop  
0003			;        nop 
0003			;;	org 08h 
0003			;;; 
0003			;;	jp cin		; rst 8 - char in 
0003			;;; 
0003			; 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;	org 010h 
0003			;; 
0003			;	jp cout		; rest 010h  - char out 
0003			;; 
0003			;	org 01bh   
0003			; 
0003			;	;jp  		; rst 01bh   - write string to display 
0003			;	jp str_at_display 
0003			; 
0003			; 
0003			;	org 020h 
0003			; 
0003			;	; jp		 ; rst 020h - read char at screen location 
0003			; 
0003			;	org 028h 
0003			 
0003				; jp		 ; rst 028h  - storage i/o 
0003			 
0003			; 	org 030h 
0003			;	jp break_point_state 
0003			  
0003			; $30  
0003			; org 038h 
0003			; $38 
0003			 
0003			; TODO any more important entry points to add to jump table for easier coding use? 
0003			 
0003			 
0003			include "firmware.asm" 
0003			  
0003			; main constants (used here and in firmware)  
0003			  
0003			; TODO have page 0 of storage as bios  
0003			  
0003			Device_A: equ 0h  
0003			Device_B: equ 040h          ; Sound  
0003			  
0003			if BASE_KEV  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_SC114  
0003			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			; TODO fixup for CPM  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			Device_D: equ 0c0h             ; Keyboard and LCD  
0003			  
0003			; Odd specific debug points for testing hardware dev  
0003			  
0003			DEBUG_SOUND: equ 1  
0003			DEBUG_STK_FAULT: equ 0  
0003			DEBUG_INPUT: equ 0     ; Debug input entry code  
0003			DEBUG_KEYCINWAIT: equ 0  
0003			DEBUG_KEYCIN: equ 0  
0003			DEBUG_KEY: equ 0  
0003			DEBUG_KEY_MATRIX: equ 0  
0003			DEBUG_STORECF: equ 0  
0003			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
0003			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
0003			DEBUG_SPI: equ 0    ; low level spi tests  
0003			  
0003			; Enable many break points  
0003			  
0003			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
0003			DEBUG_FORTH_JP: equ 0    ; 4  
0003			DEBUG_FORTH_MALLOC: equ 0  
0003			DEBUG_FORTH_MALLOC_INT: equ 0  
0003			DEBUG_FORTH_DOT: equ 0  
0003			DEBUG_FORTH_DOT_WAIT: equ 0  
0003			DEBUG_FORTH_MATHS: equ 0  
0003			DEBUG_FORTH_TOK: equ 0    ; 4  
0003			DEBUG_FORTH_PARSE: equ 0    ; 3  
0003			DEBUG_FORTH: equ 0  ;2  
0003			DEBUG_FORTH_WORDS: equ 1   ; 1  
0003			DEBUG_FORTH_PUSH: equ 0   ; 1  
0003			DEBUG_FORTH_UWORD: equ 1   ; 1  
0003			  
0003			; Enable key point breakpoints  
0003			  
0003			DEBUG_FORTH_DOT_KEY: equ 0  
0003			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
0003			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
0003			  
0003			; Debug stack imbalances  
0003			  
0003			ON: equ 1  
0003			OFF: equ 0  
0003			  
0003			DEBUG_STACK_IMB: equ 0  
0003			STACK_IMB_STORE: equ 20  
0003			  
0003			; House keeping and protections  
0003			  
0003			DEBUG_FORTH_STACK_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
0003			FORTH_ENABLE_FREE: equ 0  
0003			FORTH_ENABLE_MALLOCFREE: equ 1  
0003			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
0003			FORTH_ENABLE_FLOATMATH: equ 0  
0003			  
0003			  
0003			CALLMONITOR: macro  
0003				call break_point_state  
0003				endm  
0003			  
0003			MALLOC_1: equ 1        ; from dk88   
0003			MALLOC_2: equ 0           ; broke  
0003			MALLOC_3: equ 0           ; really broke  
0003			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
0003			  
0003			if BASE_KEV   
0003			stacksize: equ 512*2  
0003			  
0003			STACK_RET_SIZE: equ 128  
0003			STACK_LOOP_SIZE: equ 512  
0003			STACK_DATA_SIZE: equ 512  
0003			endif  
0003			if BASE_SC114  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			;if STORAGE_SE == 0  
0003			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
0003			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
0003			;endif  
0003			  
0003			; Blocks where directory table is held  
0003			  
0003			; Reducing the number of entries increases the max file size  
0003			  
0003			;STORE_DIR_START: equ 1  
0003			;STORE_DIR_END: equ 33  
0003			  
0003			; Blocks from where file data is stored  
0003			  
0003			;STORE_DATA_START: equ STORE_DIR_END + 1  
0003			  
0003			; Block indicators (<32 are data files)  
0003			  
0003			;STORE_BLOCK_CFG: equ $8f       ; config block  
0003			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
0003			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
0003			;STORE_BLOCK_FREE: equ $85       ; data block free  
0003			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
0003			  
0003			  
0003			  
0003			; Directory entry flags  
0003			  
0003			;STORE_DIR_FREE: equ 0  
0003			;STORE_DIR_FILE:  equ 1  
0003			  
0003			; Structure offsets to directory entries  
0003			;STORE_DE_FLAG: equ 0  
0003			;STORE_DE_MAXEXT: equ 1  
0003			;STORE_DE_FILENAME: equ 2  
0003			  
0003			; Structure offsets to block 0  
0003			  
0003			;STORE_BK0_ISFOR: equ 1  
0003			;STORE_BK0_LABEL: equ 3  
0003			  
0003			; memory allocation   
0003			  
0003			chk_stund: equ tos+2           ; underflow check word  
0003			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
0003			  
0003			; keyscan table needs rows x cols buffer  
0003			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
0003			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
0003			  
0003			keyscan_table_row1: equ chk_stovr -key_cols-1  
0003			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
0003			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
0003			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
0003			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
0003			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
0003			keyscan_scancol: equ keyscan_table-key_cols  
0003			;keyscan_table_len: equ key_rows*key_cols  
0003			;keybufptr: equ keyscan_table - 2  
0003			;keysymbol: equ keybufptr - 1  
0003			key_held: equ keyscan_scancol-1	; currently held  
0003			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
0003			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
0003			key_fa: equ key_repeat_ct -1 ;  
0003			key_fb: equ key_fa -1 ;  
0003			key_fc: equ key_fb -1 ;  
0003			key_fd: equ key_fc -1 ;  
0003			key_face_held: equ key_fd - 1   
0003			  
0003			; flag for enabling/disabling various hardware diags   
0003			  
0003			hardware_diag: equ key_face_held - 1  
0003			  
0003			; hardware config switches  
0003			; TODO add bitmasks on includes for hardware  
0003			; high byte for expansion ids  
0003			;     0000 0000  no card inserted  
0003			;     0000 0001  storage card inserted  
0003			;     0000 0010  spi sd card active  
0003			  
0003			;       
0003			; low byte:  
0003			;     0000 0001   4x4 keypad  
0003			;     0000 0010   full keyboard  
0003			;     0000 0011   spi/ext keyboard  
0003			;     0000 0100   20x4 lcd  
0003			;     0000 1000   40x4 lcd  
0003			;     0000 1100   spi/ext display  
0003			;     0001 0000   ide interface available  
0003			  
0003			hardware_word: equ hardware_diag - 2  
0003			  
0003			; debug marker - optional display of debug point on the debug screens  
0003			  
0003			debug_mark: equ hardware_word - 4  
0003			  
0003			; input_str vars  
0003			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
0003			input_start:  equ input_ptr - 2    ; ptr to the start of string   
0003			input_size: equ input_start -1  ; number of chars  
0003			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
0003			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
0003			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
0003			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
0003			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
0003			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
0003			input_len: equ input_cur_onoff - 5 ; length of current input  
0003			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
0003			  
0003			CUR_BLINK_RATE: equ 15  
0003			  
0003			key_actual_pressed: equ input_cursor - 1   
0003			key_symbol: equ key_actual_pressed - 1   
0003			key_shift: equ key_symbol - 1   
0003			  
0003			; Display allocation  
0003			  
0003			;display_rows: equ 4     ; move out to mini and mega files  
0003			;display_cols: equ 20  
0003			  
0003			display_fb_len: equ display_rows*display_cols  
0003			  
0003			; primary frame buffer     
0003			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
0003			; working frame buffers  
0003			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
0003			display_fb3: equ  display_fb1-display_fb_len - 1  
0003			display_fb2: equ  display_fb3-display_fb_len - 1  
0003			;  
0003			; pointer to active frame buffer  
0003			display_fb_active: equ display_fb2 - 2  
0003			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
0003			display_write_tmp: equ display_lcde1e2 - 2  
0003			  
0003			  
0003			;  
0003			  
0003			;; can load into de directory  
0003			cursor_col: equ display_write_tmp-1  
0003			cursor_row: equ cursor_col-1  
0003			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
0003			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
0003			  
0003			; maths vars  
0003			  
0003			LFSRSeed: equ cursor_shape -20   
0003			randData: equ LFSRSeed - 2  
0003			xrandc: equ randData - 2  
0003			stackstore: equ xrandc - 2  
0003			seed1: equ  stackstore -2   
0003			seed2: equ seed1 - 2  
0003			  
0003			; cf storage vars  
0003			  
0003			iErrorNum:  equ seed2-1         ;Error number  
0003			iErrorReg:  equ iErrorNum -1              ;Error register  
0003			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
0003			  
0003			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
0003			  
0003			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
0003			  
0003			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
0003			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
0003			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
0003			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
0003			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
0003			store_tmpid: equ store_tmp3 - 1		; page temp id  
0003			store_tmpext: equ store_tmpid - 1		; file extent temp  
0003			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
0003			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
0003			store_filecache: equ store_openmaxext+(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
0003			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
0003			;  
0003			; spi vars  
0003			  
0003			  
0003			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
0003			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
0003			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
0003			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
0003			  
0003			;;;;; forth cli params  
0003			  
0003			; TODO use a different frame buffer for forth???  
0003			  
0003			f_cursor_ptr:  equ spi_device - 1  ; offset into frame buffer for any . or EMIT output  
0003			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
0003			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
0003			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
0003			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
0003			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
0003			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
0003			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
0003			  
0003			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
0003			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
0003			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
0003			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
0003			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
0003			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
0003			  
0003			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
0003			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
0003			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
0003			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
0003			chk_data_ovr: equ cli_data_stack -2; overflow check word  
0003			  
0003			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
0003			  
0003			; os/forth token vars  
0003			  
0003			os_last_cmd: equ os_var_array-255  
0003			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
0003			os_current_i: equ os_cli_cmd-2  
0003			os_cur_ptr: equ os_current_i-2  
0003			os_word_scratch: equ os_cur_ptr-30  
0003			os_tok_len: equ os_word_scratch - 2  
0003			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
0003			os_tok_malloc: equ os_tok_ptr - 2  
0003			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
0003			os_input: equ os_last_new_uword-255  
0003			execscratch: equ os_input-255        ; exec cmd eval buffer  
0003			scratch: equ execscratch-255  
0003			  
0003			  
0003			; temp locations for new word processing to save on adding more   
0003			  
0003			os_new_malloc: equ os_input  
0003			os_new_parse_len: equ os_new_malloc + 2  
0003			os_new_word_len: equ os_new_parse_len + 2  
0003			os_new_work_ptr: equ os_new_word_len + 2  
0003			os_new_src_ptr: equ os_new_work_ptr + 2  
0003			os_new_exec: equ os_new_src_ptr + 2  
0003			os_new_exec_ptr: equ os_new_exec + 2  
0003			  
0003			; resume memory alloocations....  
0003			  
0003			os_view_disable: equ scratch - 1  
0003			os_view_af: equ os_view_disable - 2  
0003			os_view_hl: equ os_view_af -2  
0003			os_view_de: equ os_view_hl - 2  
0003			os_view_bc: equ os_view_de - 2  
0003			  
0003			; stack checksum word  
0003			if DEBUG_STACK_IMB  
0003				curframe: equ  os_view_de - 5  
0003				store_sp: equ curframe - (STACK_IMB_STORE*4)  
0003				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			else  
0003				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			endif  
0003			  
0003			; with data stack could see memory filled with junk. need some memory management   
0003			; malloc and free entry points added  
0003			  
0003			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
0003			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			;heap_end: equ free_list-1  ; Starting address of heap  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			heap_end: equ chk_word-1  ; Starting address of heap  
0003			  
0003			  
0003			;if BASE_KEV   
0003			;heap_start: equ 0800eh  ; Starting address of heap  
0003			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;heap_start: equ baseram+15  ; Starting address of heap  
0003			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;endif  
0003			  
0003			  
0003			;;;;  
0003			  
0003			  
0003			; change below to point to last memory alloc above  
0003			topusermem:  equ   heap_start  
0003			  
0003			;if BASE_KEV   
0003			;baseusermem: equ 08000h  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;;aseusermem:     equ    12  
0003			;baseusermem:     equ    prompt  
0003			;;baseusermem:     equ    endofcode  
0003			;endif  
0003			  
0003			  
0003			; **********************************************************************  
0003			; **  Constants  
0003			; **********************************************************************  
0003			  
0003			; Constants used by this code module  
0003			kDataReg:   EQU Device_D           ;PIO port A data register  
0003			kContReg:   EQU Device_D+2           ;PIO port A control register  
0003			  
0003			  
0003			portbdata:  equ Device_D+1    ; port b data  
0003			portbctl:   equ Device_D+3    ; port b control  
0003			  
0003			  
0003			;KEY_SHIFT:   equ 5  
0003			;KEY_SYMBOLSHIFT:  equ 6  
0003			  
0003			KEY_SHIFTLOCK: equ 4  
0003			  
0003			  
0003			KEY_UP: equ 5  
0003			KEY_NEXTWORD: equ 6  
0003			KEY_PREVWORD: equ 7  
0003			KEY_BS: equ 8  
0003			KEY_TAB:  equ 9  
0003			KEY_DOWN: equ 10  
0003			KEY_LEFT: equ 11  
0003			KEY_RIGHT: equ 12  
0003			KEY_CR:   equ 13  
0003			KEY_HOME: equ 14  
0003			KEY_END: equ 15  
0003			  
0003			KEY_F1: equ 16  
0003			KEY_F2: equ 17  
0003			KEY_F3: equ 18  
0003			KEY_F4: equ 19  
0003			  
0003			KEY_F5: equ 20  
0003			KEY_F6: equ 21  
0003			KEY_F7: equ 22  
0003			KEY_F8: equ 23  
0003			  
0003			KEY_F9: equ 24  
0003			KEY_F10: equ 25  
0003			KEY_F11: equ 26  
0003			KEY_F12: equ 27  
0003			  
0003			;if DEBUG_KEY  
0003			;	KEY_MATRIX_NO_PRESS: equ '.'  
0003			;	KEY_SHIFT:   equ '.'  
0003			;	KEY_SYMBOLSHIFT:  equ '.'  
0003			;else  
0003				KEY_SHIFT:   equ '~'  
0003				KEY_SYMBOLSHIFT:  equ '~'  
0003				KEY_MATRIX_NO_PRESS: equ '~'  
0003			;endi  
0003			  
0003			  
0003			  
0003			  
0003			; Macro to make adding debug marks easier  
0003			  
0003			DMARK: macro str  
0003				push af  
0003				ld a, (.dmark)  
0003				ld (debug_mark),a  
0003				ld a, (.dmark+1)  
0003				ld (debug_mark+1),a  
0003				ld a, (.dmark+2)  
0003				ld (debug_mark+2),a  
0003				jr .pastdmark  
0003			.dmark: db str  
0003			.pastdmark: pop af  
0003			  
0003			endm  
0003			  
0003			  
0003			; macro to detect for stack imbalances  
0003			  
0003			include "stackimbal.asm"  
0003			; Macro and code to detect stock imbalances 
0003			 
0003			SPPUSH: equ 0 
0003			 
0003			; Add a stack frame which can be checked before return 
0003			 
0003			STACKFRAME: macro onoff frame1 frame2 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003						exx 
0003			 
0003						ld de, frame1 
0003						ld a, d 
0003						ld hl, curframe 
0003						call hexout 
0003						ld a, e 
0003						ld hl, curframe+2 
0003						call hexout 
0003			  
0003						ld hl, frame1 
0003						push hl 
0003						ld hl, frame2 
0003						push hl 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			endm 
0003			 
0003			STACKFRAMECHK: macro onoff frame1 frame2 
0003			 
0003					 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						exx 
0003						; check stack frame SP 
0003			 
0003						ld hl, frame2 
0003						pop de   ; frame2 
0003			 
0003						call cmp16 
0003						jr nz, .spnosame 
0003						 
0003			 
0003						ld hl, frame1 
0003						pop de   ; frame1 
0003			 
0003						call cmp16 
0003						jr z, .spfrsame 
0003			 
0003						.spnosame: call showsperror 
0003			 
0003						.spfrsame: nop 
0003			 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			 
0003			 
0003			endm 
0003			 
0003			 
0003			; for a sub routine, wrap SP collection and comparisons 
0003			 
0003			; Usage: 
0003			; 
0003			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
0003			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
0003			 
0003			SAVESP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003			 
0003						ld (store_sp+(storeword*4)), sp 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			CHECKSP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003			 
0003						; save SP after last save 
0003				 
0003						ld (store_sp+(storeword*4)+2), sp 
0003			 
0003						push hl 
0003						ld hl, store_sp+(storeword*4) 
0003						call check_stack_sp  
0003						pop hl 
0003			 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			if DEBUG_STACK_IMB 
0003			 
0003			check_stack_sp: 
0003					push de 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					push de 
0003			 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					pop hl 
0003			 
0003			 
0003					; check to see if the same 
0003			 
0003					call cmp16 
0003					jr z, .spsame 
0003			 
0003					; not same 
0003			 
0003					call showsperror 
0003			.spsame: 
0003			 
0003					pop de 
0003			 
0003					ret 
0003			 
0003			.sperr:  db "Stack imbalance",0 
0003			 
0003			 
0003			showsperror: 
0003			 
0003			 
0003				push hl 
0003				push af 
0003				push de 
0003				call clear_display 
0003				ld de, .sperr 
0003				ld a,0 
0003			;	ld de,os_word_scratch 
0003				call str_at_display 
0003				ld a, display_row_1+17 
0003				ld de, debug_mark 
0003				call str_at_display 
0003				ld a, 0 
0003				ld (curframe+4),a 
0003				ld hl, curframe 
0003				ld de, os_word_scratch 
0003				ld a, display_row_4 
0003				call str_at_display 
0003				call update_display 
0003				;call break_point_state 
0003				call cin_wait 
0003			 
0003				ld a, ' ' 
0003				ld (os_view_disable), a 
0003				pop de	 
0003				pop af 
0003				pop hl 
0003				CALLMONITOR 
0003				ret 
0003			 
0003			endif 
0003			 
0003			 
0003			 
0003			; eof 
# End of file stackimbal.asm
0003			  
0003			;TODO macro to calc col and row offset into screen  
0003			  
0003			  
0003			  
0003			hardware_init:  
0003			  
0003 3e 00				ld a, 0  
0005 32 7d fb				ld (hardware_diag), a  
0008			  
0008					; clear all the buffers  
0008			  
0008 21 1c fa				ld hl, display_fb1  
000b 22 d8 f8				ld (display_fb_active), hl  
000e			  
000e cd b9 0a				call clear_display  
0011			  
0011 21 da f8				ld hl, display_fb2  
0014 22 d8 f8				ld (display_fb_active), hl  
0017			  
0017 cd b9 0a				call clear_display  
001a			  
001a					; init primary frame buffer area  
001a 21 bd fa				ld hl, display_fb0  
001d 22 d8 f8				ld (display_fb_active), hl  
0020			  
0020 cd b9 0a				call clear_display  
0023			  
0023			  
0023 cd ed 5f				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0026			  
0026 cd 84 62			call key_init  
0029 cd cc 01			call storage_init  
002c			  
002c				; setup malloc functions  
002c			  
002c				if MALLOC_1  
002c cd b5 10				call  heap_init  
002f				endif  
002f				if MALLOC_4  
002f					call  heap_init  
002f				endif  
002f			  
002f				; init sound hardware if present  
002f			  
002f				if SOUND_ENABLE  
002f cd 72 12				call sound_init  
0032				endif  
0032			  
0032				; lcd test sequence  
0032					  
0032 cd dc 0a			call update_display  
0035 cd 3d 0a			call delay1s  
0038 3e 2b			ld a,'+'  
003a cd be 0a			call fill_display  
003d cd dc 0a			call update_display  
0040 cd 3d 0a			call delay1s  
0043 3e 2a			ld a,'*'  
0045 cd be 0a			call fill_display  
0048 cd dc 0a			call update_display  
004b cd 3d 0a			call delay1s  
004e 3e 2d			ld a,'-'  
0050 cd be 0a			call fill_display  
0053 cd dc 0a			call update_display  
0056 cd 3d 0a			call delay1s  
0059			  
0059			; boot splash screen  
0059			if display_cols == 20	  
0059			        ld a, display_row_1    
0059			else  
0059 3e 0a		        ld a, display_row_1 +10   
005b			endif  
005b 11 8c 00			ld de, bootmsg  
005e cd cc 0a			call str_at_display  
0061 cd dc 0a			call update_display  
0064			  
0064			  
0064 cd 3d 0a			call delay1s  
0067 cd 3d 0a			call delay1s  
006a			if display_cols == 20	  
006a			            LD   A, display_row_3+2  
006a			else  
006a 3e 5c		            LD   A, display_row_3+12  
006c			endif  
006c 11 a1 00			ld de, bootmsg1  
006f cd cc 0a			call str_at_display  
0072 cd dc 0a			call update_display  
0075 cd 3d 0a			call delay1s  
0078 cd 3d 0a			call delay1s  
007b			  
007b			;	ld a, display_row_4+3  
007b			;	ld de, bootmsg2  
007b			;	call str_at_display  
007b			;	call update_display  
007b			;	call delay1s  
007b			;	call delay1s  
007b			  
007b			; debug mark setup  
007b			  
007b 3e 5f		ld a, '_'  
007d 32 77 fb		ld (debug_mark),a  
0080 32 78 fb		ld (debug_mark+1),a  
0083 32 79 fb		ld (debug_mark+2),a  
0086 3e 00		ld a,0  
0088 32 7a fb		ld (debug_mark+3),a  
008b			  
008b c9					ret  
008c			  
008c			  
008c .. 00		bootmsg:	db "z80-homebrew OS v1.5",0  
00a1 .. 00		bootmsg1:	db "by Kevin Groves",0  
00b1			;bootmsg2:	db "Firmware v0.1",0  
00b1			  
00b1			; a 4x20 lcd  
00b1			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00b1			  
00b1			;if display_cols == 20  
00b1			;	include "firmware_lcd_4x20.asm"  
00b1			;endif  
00b1			  
00b1			;if display_cols == 40  
00b1			;	include "firmware_lcd_4x40.asm"  
00b1			;endif  
00b1			  
00b1			;  
00b1			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00b1			; TODO abstract the bit bang video out interface for dual display  
00b1			; TODO wire video out to tx pin on rc2014 bus  
00b1			  
00b1			; must supply cin, and cin_wait for low level hardware abstraction   
00b1			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00b1			; test scancode  
00b1			  
00b1			;;;;;  
00b1			;;;  
00b1			; Moved out to mini and maxi versions  
00b1			;  
00b1			; include "firmware_key_4x4.asm"  
00b1			; using existing 4 wire x 4 resistor array for input  
00b1			;include "firmware_key_4x10.asm"  
00b1			; need to mod the board for 5 rows due to resistor array  
00b1			;include "firmware_key_5x10.asm"  
00b1			  
00b1			; storage hardware interface  
00b1			  
00b1			; use microchip serial eeprom for storage  
00b1			  
00b1			  
00b1			if STORAGE_SE  
00b1				include "firmware_spi.asm"  
00b1			; my spi protocol (used by storage) 
00b1			 
00b1			; SPI pins 
00b1			 
00b1			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00b1			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00b1			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00b1			 
00b1			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00b1			; chip pin 4 gnd 
00b1			 
00b1			 
00b1			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00b1			SPI_CE1: equ 1      ;    port a1 pin 14  
00b1			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00b1			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00b1			SPI_CE4: equ 4      ; port a4     pin 10 
00b1			 
00b1			; active low AND masks 
00b1			 
00b1			;SPI_CE0_MASK: equ    255-1 
00b1			;SPI_CE1_MASK: equ   255-2 
00b1			;SPI_CE2_MASK: equ   255-4 
00b1			;SPI_CE3_MASK: equ   255-8 
00b1			;SPI_CE4_MASK: equ   255-16 
00b1			SPI_CE_HIGH:  equ 255 
00b1			 
00b1			 
00b1			 
00b1			 
00b1			; TODO store port id for spi device ie dev c 
00b1			; TODO store pin for SO 
00b1			; TODO store pin for SI 
00b1			; TODO store pin for SCLK 
00b1			 
00b1			; 
00b1			 
00b1			; ensure that spi bus is in a stable state with default pins  
00b1			 
00b1			se_stable_spi:   
00b1			 
00b1				 ; set DI high, CE high , SCLK low 
00b1				;ld a, SPI_DI | SPI_CE0 
00b1 3e 07			ld a, SPI_DI  
00b3 cd 87 01			call spi_ce_high 
00b6 d3 80			 out (storage_adata),a 
00b8 32 5d f8			ld (spi_portbyte),a 
00bb			 
00bb				if DEBUG_SPI 
00bb					push hl 
00bb					ld l, a 
00bb					DMARK "SPI" 
00bb					CALLMONITOR 
00bb					pop hl 
00bb				endif 
00bb c9				ret 
00bc			 
00bc			; byte to send in a 
00bc			 
00bc			spi_send_byte: 
00bc				; save byte to send for bit mask shift out 
00bc 4f			        ld c,a 
00bd 3a 5d f8			ld a,(spi_portbyte) 
00c0				  
00c0				; clock out	each bit of the byte msb first 
00c0			 
00c0 06 08			ld b, 8 
00c2			.ssb1: 
00c2				; clear so bit  
00c2 cb bf			res SPI_DI, a 
00c4 cb 11			rl c 
00c6				; if bit 7 is set then carry is set 
00c6 30 02			jr nc, .ssb2 
00c8 cb ff			set SPI_DI,a 
00ca			.ssb2:  ; output bit to ensure it is stable 
00ca d3 80			out (storage_adata),a 
00cc 00				nop 
00cd				; clock bit high 
00cd cb ef			set SPI_SCLK,a 
00cf d3 80			out (storage_adata),a 
00d1 00				nop 
00d2				; then low 
00d2 cb af			res SPI_SCLK,a 
00d4 d3 80			out (storage_adata),a 
00d6 00				nop 
00d7 10 e9			djnz .ssb1 
00d9			 
00d9 32 5d f8			ld (spi_portbyte),a 
00dc c9				ret 
00dd			 
00dd			; TODO low level get byte into A on spi 
00dd			 
00dd			spi_read_byte:  
00dd			 
00dd				; save byte to send for bit mask shift out 
00dd 0e 00		    ld c,0 
00df 3a 5d f8			ld a,(spi_portbyte) 
00e2				  
00e2				; clock out	each bit of the byte msb first 
00e2			 
00e2			 
00e2				; clock bit high 
00e2 cb ef			set SPI_SCLK,a 
00e4 d3 80			out (storage_adata),a 
00e6 00				nop 
00e7			 
00e7			    ; read DO  
00e7			 
00e7 cb f9		    set 7,c 
00e9 db 80			in a,(storage_adata) 
00eb cb 77		    bit SPI_DO,a 
00ed 20 02		    jr nz, .b7 
00ef cb b9		    res 7,c 
00f1			.b7: 
00f1				; then low 
00f1 cb af			res SPI_SCLK,a 
00f3 d3 80			out (storage_adata),a 
00f5 00				nop 
00f6			     
00f6			 
00f6				; clock bit high 
00f6 cb ef			set SPI_SCLK,a 
00f8 d3 80			out (storage_adata),a 
00fa 00				nop 
00fb			 
00fb			    ; read DO  
00fb			 
00fb cb f1		    set 6,c 
00fd db 80			in a,(storage_adata) 
00ff cb 77		    bit SPI_DO,a 
0101 20 02		    jr nz, .b6 
0103 cb b1		    res 6,c 
0105			.b6: 
0105				; then low 
0105 cb af			res SPI_SCLK,a 
0107 d3 80			out (storage_adata),a 
0109 00				nop 
010a			 
010a				; clock bit high 
010a cb ef			set SPI_SCLK,a 
010c d3 80			out (storage_adata),a 
010e 00				nop 
010f			 
010f			 
010f			    ; read DO  
010f			 
010f cb e9		    set 5,c 
0111 db 80			in a,(storage_adata) 
0113 cb 77		    bit SPI_DO,a 
0115 20 02		    jr nz, .b5 
0117 cb a9		    res 5,c 
0119			.b5: 
0119				; then low 
0119 cb af			res SPI_SCLK,a 
011b d3 80			out (storage_adata),a 
011d 00				nop 
011e				; clock bit high 
011e cb ef			set SPI_SCLK,a 
0120 d3 80			out (storage_adata),a 
0122 00				nop 
0123			 
0123			    ; read DO  
0123			 
0123 cb e1		    set 4,c 
0125 db 80			in a,(storage_adata) 
0127 cb 77		    bit SPI_DO,a 
0129 20 02		    jr nz, .b4 
012b cb a1		    res 4,c 
012d			.b4: 
012d				; then low 
012d cb af			res SPI_SCLK,a 
012f d3 80			out (storage_adata),a 
0131 00				nop 
0132				; clock bit high 
0132 cb ef			set SPI_SCLK,a 
0134 d3 80			out (storage_adata),a 
0136 00				nop 
0137			 
0137			    ; read DO  
0137			 
0137 cb d9		    set 3,c 
0139 db 80			in a,(storage_adata) 
013b cb 77		    bit SPI_DO,a 
013d 20 02		    jr nz, .b3 
013f cb 99		    res 3,c 
0141			.b3: 
0141				; then low 
0141 cb af			res SPI_SCLK,a 
0143 d3 80			out (storage_adata),a 
0145 00				nop 
0146				; clock bit high 
0146 cb ef			set SPI_SCLK,a 
0148 d3 80			out (storage_adata),a 
014a 00				nop 
014b			 
014b			    ; read DO  
014b			 
014b cb d1		    set 2,c 
014d db 80			in a,(storage_adata) 
014f cb 77		    bit SPI_DO,a 
0151 20 02		    jr nz, .b2 
0153 cb 91		    res 2,c 
0155			.b2: 
0155				; then low 
0155 cb af			res SPI_SCLK,a 
0157 d3 80			out (storage_adata),a 
0159 00				nop 
015a				; clock bit high 
015a cb ef			set SPI_SCLK,a 
015c d3 80			out (storage_adata),a 
015e 00				nop 
015f			 
015f			    ; read DO  
015f			 
015f cb c9		    set 1,c 
0161 db 80			in a,(storage_adata) 
0163 cb 77		    bit SPI_DO,a 
0165 20 02		    jr nz, .b1 
0167 cb 89		    res 1,c 
0169			.b1: 
0169				; then low 
0169 cb af			res SPI_SCLK,a 
016b d3 80			out (storage_adata),a 
016d 00				nop 
016e				; clock bit high 
016e cb ef			set SPI_SCLK,a 
0170 d3 80			out (storage_adata),a 
0172 00				nop 
0173			 
0173			    ; read DO  
0173			 
0173 cb c1		    set 0,c 
0175 db 80			in a,(storage_adata) 
0177 cb 77		    bit SPI_DO,a 
0179 20 02		    jr nz, .b0 
017b cb 81		    res 0,c 
017d			.b0: 
017d				; then low 
017d cb af			res SPI_SCLK,a 
017f d3 80			out (storage_adata),a 
0181 00				nop 
0182			 
0182			 
0182 32 5d f8			ld (spi_portbyte),a 
0185			 
0185			    ; return byte 
0185 79			    ld a,c 
0186			 
0186			 
0186 c9				ret 
0187			 
0187			 
0187			 
0187			spi_ce_high: 
0187			 
0187				if DEBUG_SPI_HARD_CE0 
0187			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0187					ret 
0187			 
0187				endif 
0187			 
0187			 
0187 f5				push af 
0188			 
0188				; send direct ce to port b 
0188 3e ff			ld a, 255 
018a d3 81			out (storage_bdata), a 
018c			 
018c f1				pop af 
018d			 
018d				; for port a that shares with spi lines AND the mask 
018d			  
018d				if DEBUG_SPI 
018d					push hl 
018d					ld h, a 
018d				endif 
018d			;	ld c, SPI_CE_HIGH 
018d			;	and c 
018d cb c7			set SPI_CE0, a 
018f cb cf			set SPI_CE1, a 
0191 cb d7			set SPI_CE2, a 
0193 cb df			set SPI_CE3, a 
0195 cb e7			set SPI_CE4, a 
0197			 
0197				if DEBUG_SPI 
0197					ld l, a 
0197					DMARK "CEh" 
0197					CALLMONITOR 
0197					pop hl 
0197				endif 
0197 c9				ret 
0198			 
0198			 
0198			spi_ce_low: 
0198			 
0198				if DEBUG_SPI_HARD_CE0 
0198			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0198					ret 
0198			 
0198				endif 
0198			 
0198 c5				push bc 
0199 f5				push af 
019a			 
019a				; send direct ce to port b 
019a 3a 5f f8			ld a, (spi_cartdev) 
019d d3 81			out (storage_bdata), a 
019f			 
019f			 
019f			 
019f				; for port a that shares with spi lines AND the mask 
019f			 
019f 3a 5c f8			ld a, (spi_device)  
01a2 4f				ld c, a 
01a3			 
01a3 f1				pop af 
01a4			 
01a4				; detect CEx 
01a4			 
01a4				if DEBUG_SPI 
01a4					push hl 
01a4					ld h, a 
01a4				endif 
01a4			 
01a4 cb 41			bit SPI_CE0, c 
01a6 20 04			jr nz, .cel1 
01a8 cb 87			res SPI_CE0, a 
01aa 18 1e			jr .celn 
01ac			.cel1: 
01ac cb 49			bit SPI_CE1, c 
01ae 20 04			jr nz, .cel2 
01b0 cb 8f			res SPI_CE1, a 
01b2 18 16			jr .celn 
01b4			.cel2: 
01b4 cb 51			bit SPI_CE2, c 
01b6 20 04			jr nz, .cel3 
01b8 cb 97			res SPI_CE2, a 
01ba 18 0e			jr .celn 
01bc			.cel3: 
01bc cb 59			bit SPI_CE3, c 
01be 20 04			jr nz, .cel4 
01c0 cb 9f			res SPI_CE3, a 
01c2 18 06			jr .celn 
01c4			.cel4: 
01c4 cb 61			bit SPI_CE4, c 
01c6 20 02			jr nz, .celn 
01c8 cb a7			res SPI_CE4, a 
01ca			.celn: 
01ca			 
01ca			 
01ca			 
01ca			;	add c 
01ca			 
01ca				if DEBUG_SPI 
01ca					ld l, a 
01ca					DMARK "CEl" 
01ca					CALLMONITOR 
01ca					pop hl 
01ca				endif 
01ca c1				pop bc 
01cb c9				ret 
01cc			 
01cc			 
01cc			 
01cc			; eof 
01cc			 
01cc			 
01cc			 
01cc			 
01cc			 
# End of file firmware_spi.asm
01cc				include "firmware_seeprom.asm"  
01cc			; 
01cc			; persisent storage interface via microchip serial eeprom 
01cc			 
01cc			; port a pio 2 
01cc			; pa 7 - si 
01cc			; pa 6 - sclk  
01cc			; pa 5 - so 
01cc			; pa 4 - cs 
01cc			; pa 3 - cs 
01cc			; pa 2 - cs 
01cc			; pa 1 - cs 
01cc			; pa 0 - cs 
01cc			; 
01cc			; TODO get block 
01cc			; TODO save block 
01cc			; TODO load file 
01cc			; TODO save file 
01cc			; TODO get dir  
01cc			 
01cc			;  
01cc			storage_adata: equ Device_C    ; device c port a - onboard storage 
01cc			storage_actl: equ Device_C+2     ; device c port a 
01cc			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
01cc			storage_bctl: equ Device_C+3     ; device c port b 
01cc			 
01cc			 
01cc			; TODO move these to hardware driver file 
01cc			 
01cc			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
01cc			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
01cc			; storage bank file system format 
01cc			; 
01cc			; first page of bank: 
01cc			; 	addr 0 - status check 
01cc			;       addr 1 - write protect flag 
01cc			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
01cc			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
01cc			;         TODO see if scanning whole of for available next file id is fast enough 
01cc			;	addr 4 > zero term string of bank label 
01cc			; 
01cc			;        
01cc			;  
01cc			; first page of any file: 
01cc			;      byte 0 - file id  
01cc			;      byte 1-17 - fixed file name  
01cc			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
01cc			; 
01cc			; other pages of any file: 
01cc			;      byte 0 - file id 
01cc			;      byte 1> - file data 
01cc			; 
01cc			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
01cc			;  
01cc			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
01cc			 
01cc			 
01cc			;storage_so_bit: 5 
01cc			;storage_si_bit: 7 
01cc			;storage_sclk_bit: 6 
01cc			  
01cc			 
01cc			; init storage pio 
01cc			 
01cc			storage_init: 
01cc			 
01cc 3e cf		            LD   A, 11001111b 
01ce d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
01d0 3e 00		            LD   A, 00000000b 
01d2 cb f7			set SPI_DO,a 
01d4			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
01d4 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
01d6			 
01d6 3e cf		            LD   A, 11001111b 
01d8 d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
01da 3e 00		            LD   A, 00000000b 
01dc d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
01de			 
01de				; set all external spi devices off 
01de 3e 00			ld a, 0 
01e0 32 5c f8			ld (spi_device), a 
01e3 32 5f f8			ld (spi_cartdev), a 
01e6			 
01e6					; ensure the spi bus is in a default stable state 
01e6 cd b1 00				call se_stable_spi 
01e9			 
01e9			; TODO scan spi bus and gather which storage banks are present 
01e9			 
01e9			; populate store_bank_active  
01e9			; for each ce line activate and attempt to write first byte of bank and read back 
01e9			; if zero is returned then bank is empty 
01e9			;   
01e9			; 
01e9			 
01e9					; init file extent cache to save on slow reads 
01e9			 
01e9			;	ld hl, store_filecache 
01e9			;	ld de, 0 
01e9			;	ld hl,(de)	 
01e9			 
01e9			 
01e9 c9			    ret 
01ea			 
01ea			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
01ea			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
01ea			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
01ea			 
01ea			; INSTRUCTION SET 
01ea			; READ 0000 0011 Read data from memory array beginning at selected address 
01ea			; WRITE 0000 0010 Write data to memory array beginning at selected address 
01ea			; WREN 0000 0110 Set the write enable latch (enable write operations) 
01ea			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
01ea			; RDSR 0000 0101 Read STATUS register 
01ea			; WRSR 0000 0001 Write STATUS register 
01ea			; PE 0100 0010 Page Erase – erase one page in memory array 
01ea			; SE 1101 1000 Sector Erase – erase one sector in memory array 
01ea			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
01ea			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
01ea			 
01ea			; TODO send byte steam for page without setting the address for every single byte 
01ea			; TODO read byte  
01ea			 
01ea			; byte in a 
01ea			; address in hl  
01ea			se_writebyte: 
01ea			        
01ea			    ;   ld c, a 
01ea f5			        push af 
01eb e5			        push hl 
01ec			 
01ec			    ; initi write mode 
01ec			    ; 
01ec			    ;CS low 
01ec			 
01ec 3a 5d f8		       ld a,(spi_portbyte) 
01ef cd 98 01			call spi_ce_low 
01f2			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01f2 d3 80		       out (storage_adata),a 
01f4 32 5d f8		       ld (spi_portbyte), a 
01f7			 
01f7			    ;clock out wren instruction 
01f7			 
01f7 3e 06		    ld a, store_wren_ins 
01f9 cd bc 00		    call spi_send_byte  
01fc			 
01fc			    ;cs high to enable write latch 
01fc			 
01fc 3a 5d f8		       ld a,(spi_portbyte) 
01ff cd 87 01			call spi_ce_high 
0202			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0202 d3 80		       out (storage_adata),a 
0204 32 5d f8		       ld (spi_portbyte), a 
0207			 
0207 00				nop 
0208			    ; 
0208			    ; intial write data 
0208			    ; 
0208			    ; cs low 
0208			     
0208 3a 5d f8		       ld a,(spi_portbyte) 
020b cd 98 01			call spi_ce_low 
020e			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
020e d3 80		       out (storage_adata),a 
0210 32 5d f8		       ld (spi_portbyte), a 
0213			 
0213			    ; clock out write instruction 
0213			     
0213 3e 02		    ld a, store_write_ins  
0215 cd bc 00		    call spi_send_byte  
0218			 
0218			    ; clock out address (depending on address size) 
0218			     
0218 e1			    pop hl 
0219 7c			    ld a,h    ; address out msb first 
021a cd bc 00		    call spi_send_byte  
021d 7d			    ld a,l 
021e cd bc 00		    call spi_send_byte  
0221			 
0221			    ; clock out byte(s) for page 
0221			 
0221 f1			    pop af 
0222 cd bc 00		    call spi_send_byte  
0225			 
0225			    ; end write with ce high 
0225 3a 5d f8		       ld a,(spi_portbyte) 
0228			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
0228 cd 87 01			call spi_ce_high 
022b d3 80		       out (storage_adata),a 
022d 32 5d f8		       ld (spi_portbyte), a 
0230			 
0230				; pause for internal write cycle 
0230 3e 0a			ld a, 10 
0232 cd 22 0a			call aDelayInMS 
0235 c9			    ret 
0236			 
0236			; buffer to write in de 
0236			; address in hl  
0236			se_writepage: 
0236			        
0236			    ;   ld c, a 
0236 d5				push de 
0237 e5			        push hl 
0238			 
0238			    ; initi write mode 
0238			    ; 
0238			    ;CS low 
0238			 
0238 3a 5d f8		       ld a,(spi_portbyte) 
023b cd 98 01			call spi_ce_low 
023e			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
023e d3 80		       out (storage_adata),a 
0240 32 5d f8		       ld (spi_portbyte), a 
0243			 
0243			    ;clock out wren instruction 
0243			 
0243 3e 06		    ld a, store_wren_ins 
0245 cd bc 00		    call spi_send_byte  
0248			 
0248			    ;cs high to enable write latch 
0248			 
0248 3a 5d f8		       ld a,(spi_portbyte) 
024b cd 87 01			call spi_ce_high 
024e			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
024e d3 80		       out (storage_adata),a 
0250 32 5d f8		       ld (spi_portbyte), a 
0253			 
0253 00				nop 
0254			    ; 
0254			    ; intial write data 
0254			    ; 
0254			    ; cs low 
0254			     
0254 3a 5d f8		       ld a,(spi_portbyte) 
0257			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0257 cd 98 01			call spi_ce_low 
025a d3 80		       out (storage_adata),a 
025c 32 5d f8		       ld (spi_portbyte), a 
025f			 
025f			    ; clock out write instruction 
025f			     
025f 3e 02		    ld a, store_write_ins  
0261 cd bc 00		    call spi_send_byte  
0264			 
0264			    ; clock out address (depending on address size) 
0264			     
0264 e1			    pop hl 
0265 7c			    ld a,h    ; address out msb first 
0266 cd bc 00		    call spi_send_byte  
0269 7d			    ld a,l 
026a cd bc 00		    call spi_send_byte  
026d			 
026d			    ; clock out byte(s) for page 
026d			 
026d e1				pop hl 
026e 06 40			ld b, STORE_BLOCK_PHY 
0270			.bytewrite: 
0270			 
0270 7e				ld a,(hl) 
0271 e5			    push hl 
0272 c5				push bc 
0273 cd bc 00		    call spi_send_byte  
0276 c1				pop bc 
0277 e1				pop hl 
0278			 
0278			    ; end write with ce high 
0278 3a 5d f8		       ld a,(spi_portbyte) 
027b cd 87 01			call spi_ce_high 
027e			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
027e d3 80		       out (storage_adata),a 
0280 32 5d f8		       ld (spi_portbyte), a 
0283			 
0283 23				inc hl 
0284 10 ea			djnz .bytewrite 
0286			 
0286				; pause for internal write cycle 
0286 3e 64			ld a, 100 
0288 cd 22 0a			call aDelayInMS 
028b c9			    ret 
028c			; returns byte in a 
028c			; address in hl  
028c			se_readbyte: 
028c d5				push de 
028d c5				push bc 
028e			 
028e			    ;   ld c, a 
028e e5			        push hl 
028f			 
028f			    ; initi write mode 
028f			    ; 
028f			    ;CS low 
028f			 
028f 3a 5d f8		       ld a,(spi_portbyte) 
0292 cd 98 01			call spi_ce_low 
0295			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0295 d3 80		       out (storage_adata),a 
0297 32 5d f8		       ld (spi_portbyte), a 
029a			 
029a			    ;clock out wren instruction 
029a			 
029a 3e 03		    ld a, store_read_ins 
029c cd bc 00		    call spi_send_byte  
029f			 
029f			 
029f			    ; clock out address (depending on address size) 
029f			     
029f e1			    pop hl 
02a0 7c			    ld a,h    ; address out msb first 
02a1 cd bc 00		    call spi_send_byte  
02a4 7d			    ld a,l 
02a5 cd bc 00		    call spi_send_byte  
02a8			 
02a8			    ; clock in byte(s) for page 
02a8			 
02a8 cd dd 00		    call spi_read_byte  
02ab f5				push af 
02ac			 
02ac			    ; end write with ce high 
02ac 3a 5d f8		       ld a,(spi_portbyte) 
02af			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02af cd 87 01			call spi_ce_high 
02b2 d3 80		       out (storage_adata),a 
02b4 32 5d f8		       ld (spi_portbyte), a 
02b7			 
02b7 f1				pop af 
02b8			 
02b8 c1				pop bc 
02b9 d1				pop de 
02ba			 
02ba c9			    ret 
02bb			 
02bb			if DEBUG_STORESE 
02bb			 
02bb			storageput:  
02bb			 
02bb			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
02bb			 
02bb 21 34 ee			ld hl,scratch+2 
02be cd c9 0f			call get_word_hl 
02c1			 
02c1				; stuff it here for the moment as it will be overwritten later anyway 
02c1			 
02c1 22 55 f1			ld (os_cur_ptr),hl	 
02c4			 
02c4			 
02c4			; get pointer to start of string 
02c4			 
02c4 21 39 ee			ld hl, scratch+7 
02c7			 
02c7			; loop writing char of string to eeprom 
02c7			 
02c7 7e			.writestr:	ld a,(hl) 
02c8 fe 00				cp 0 
02ca 28 12				jr z, .wsdone		; done writing 
02cc e5					push hl 
02cd 2a 55 f1				ld hl,(os_cur_ptr) 
02d0 cd ea 01				call se_writebyte 
02d3			 
02d3 2a 55 f1				ld hl,(os_cur_ptr)	 ; save next eeprom address 
02d6 23					inc hl 
02d7 22 55 f1				ld (os_cur_ptr),hl 
02da			 
02da					; restore string pointer and get next char 
02da			 
02da e1					pop hl 
02db 23					inc hl 
02dc 18 e9				jr .writestr 
02de			 
02de			 
02de			 
02de			.wsdone: 
02de			 
02de			 
02de			; when done load first page into a buffer  
02de			 
02de 21 00 80				ld hl,08000h		; start in ram 
02e1 22 55 f1				ld (os_cur_ptr),hl 
02e4 21 00 00				ld hl, 0		 ; start of page 
02e7 22 5a ee				ld (scratch+40),hl	; hang on to it 
02ea			 
02ea 06 80				ld b, 128		; actually get more then one page 
02ec c5			.wsload:	push bc 
02ed 2a 5a ee				ld hl,(scratch+40) 
02f0 e5					push hl 
02f1 cd 8c 02				call se_readbyte 
02f4			 
02f4					; a now as the byte 
02f4			 
02f4 2a 55 f1				ld hl,(os_cur_ptr) 
02f7 77					ld (hl),a 
02f8					; inc next buffer area 
02f8 23					inc hl 
02f9 22 55 f1				ld (os_cur_ptr),hl 
02fc			 
02fc					; get eeprom position, inc and save for next round 
02fc e1					pop hl		 
02fd 23					inc hl 
02fe 22 5a ee				ld (scratch+40),hl 
0301 c1					pop bc 
0302 10 e8				djnz .wsload 
0304			 
0304			; set 'd' pointer to start of buffer 
0304			 
0304 21 00 80				ld hl,08000h 
0307 22 55 f1				ld (os_cur_ptr),hl 
030a			 
030a			 
030a c9			ret 
030b			 
030b			 
030b c9			storageread: ret 
030c			 
030c			 
030c			 
030c			 
030c			 
030c			 
030c			endif 
030c			 
030c			 
030c			 
# End of file firmware_seeprom.asm
030c			else  
030c			   ; create some stubs for the labels  
030c			se_readbyte: ret  
030c			se_writebyte: ret  
030c			storage_init: ret  
030c			  
030c			endif  
030c			  
030c			; use cf card for storage - throwing timeout errors. Hardware or software?????  
030c			;include "firmware_cf.asm"  
030c			  
030c			; load up high level storage hardward abstractions  
030c			include "firmware_storage.asm"  
030c			 
030c			; persisent storage hardware abstraction layer  
030c			 
030c			 
030c			 
030c			; Block 0 on storage is a config state 
030c			 
030c			 
030c			 
030c			; TODO add read phy block and write phy block functions 
030c			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
030c			 
030c			; Abstraction layer  
030c			 
030c			; Logocial block size is same size as physical size - using tape concept 
030c			 
030c			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
030c			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
030c			 
030c			 
030c			 
030c			; Filesystem layout (Logical layout) 
030c			; 
030c			; Block 0 - Bank config  
030c			; 
030c			;      Byte - 0 file id counter 
030c			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
030c			;      Byte - 3-20 zero terminated bank label 
030c			; 
030c			; Block 1 > File storage 
030c			; 
030c			;      Byte 0 file id    - block 0 file details 
030c			;      Byte 1 block id - block 0 is file  
030c			;            Byte 2-15 - File name 
030c			; 
030c			;       - to end of block data 
030c			; 
030c			 
030c			 
030c			; Read Block 
030c			; ---------- 
030c			; 
030c			; With current bank 
030c			;  
030c			; Get block number to read 
030c			; Load physical blocks starting at start block into buffer 
030c			 
030c			; de points to buffer to use 
030c			; hl holds logical block number  
030c			 
030c			storage_read_block: 
030c			 
030c				; TODO bank selection 
030c			 
030c				; for each of the physical blocks read it into the buffer 
030c 06 40			ld b, STORE_BLOCK_PHY 
030e			 
030e				if DEBUG_STORESE 
030e d5					push de 
030f				endif 
030f				 
030f			.rl1:    
030f			 
030f				; read physical block at hl into de 
030f			        ; increment hl and de to next read position on exit 
030f			 
030f e5				push hl 
0310 d5				push de	 
0311 c5				push bc 
0312			;	if DEBUG_STORESE 
0312			;		push af 
0312			;		ld a, 'R' 
0312			;		ld (debug_mark),a 
0312			;		pop af 
0312			;		CALLMONITOR 
0312			;	endif 
0312 cd 8c 02			call se_readbyte 
0315			;	if DEBUG_STORESE 
0315			;		ld a,(spi_portbyte) 
0315			;		ld l, a 
0315			;		push af 
0315			;		ld a, '1' 
0315			;		ld (debug_mark),a 
0315			;		pop af 
0315			;		CALLMONITOR 
0315			;	endif 
0315 c1				pop bc 
0316 d1				pop de 
0317 e1				pop hl 
0318 12				ld (de),a 
0319 23				inc hl 
031a 13				inc de 
031b			 
031b			;	if DEBUG_STORESE 
031b			;		push af 
031b			;		ld a, 'r' 
031b			;		ld (debug_mark),a 
031b			;		pop af 
031b			;		CALLMONITOR 
031b			;	endif 
031b			 
031b 10 f2			djnz .rl1 
031d			 
031d				if DEBUG_STORESE 
031d					DMARK "SRB" 
031d f5				push af  
031e 3a 32 03			ld a, (.dmark)  
0321 32 77 fb			ld (debug_mark),a  
0324 3a 33 03			ld a, (.dmark+1)  
0327 32 78 fb			ld (debug_mark+1),a  
032a 3a 34 03			ld a, (.dmark+2)  
032d 32 79 fb			ld (debug_mark+2),a  
0330 18 03			jr .pastdmark  
0332 ..			.dmark: db "SRB"  
0335 f1			.pastdmark: pop af  
0336			endm  
# End of macro DMARK
0336 d1					pop de 
0337			; 
0337			;		push af 
0337			;		ld a, 'R' 
0337			;		ld (debug_mark),a 
0337			;		pop af 
0337					CALLMONITOR 
0337 cd 00 14			call break_point_state  
033a				endm  
# End of macro CALLMONITOR
033a				endif 
033a c9				ret	 
033b				 
033b			 
033b			; File Size 
033b			; --------- 
033b			; 
033b			;   hl file id 
033b			; 
033b			;  returns in hl the number of blocks 
033b			 
033b			storage_file_size: 
033b 5d				ld e, l 
033c 16 00			ld d, 0 
033e 21 40 00			ld hl, STORE_BLOCK_PHY 
0341					if DEBUG_FORTH_WORDS 
0341						DMARK "SIZ" 
0341 f5				push af  
0342 3a 56 03			ld a, (.dmark)  
0345 32 77 fb			ld (debug_mark),a  
0348 3a 57 03			ld a, (.dmark+1)  
034b 32 78 fb			ld (debug_mark+1),a  
034e 3a 58 03			ld a, (.dmark+2)  
0351 32 79 fb			ld (debug_mark+2),a  
0354 18 03			jr .pastdmark  
0356 ..			.dmark: db "SIZ"  
0359 f1			.pastdmark: pop af  
035a			endm  
# End of macro DMARK
035a						CALLMONITOR 
035a cd 00 14			call break_point_state  
035d				endm  
# End of macro CALLMONITOR
035d					endif 
035d cd 22 06			call storage_findnextid 
0360			 
0360 cd 3b 0c			call ishlzero 
0363			;	ld a, l 
0363			;	add h 
0363			;	cp 0 
0363 c8				ret z			; block not found so EOF 
0364			 
0364 11 62 f8			ld de, store_page 
0367 cd 0c 03			call storage_read_block 
036a			 
036a 3a 64 f8			ld a, (store_page+2)	 ; get extent count 
036d 6f				ld l, a 
036e 26 00			ld h, 0 
0370 c9			 	ret 
0371			 
0371			 
0371			; Write Block 
0371			; ----------- 
0371			; 
0371			; With current bank 
0371			;  
0371			; Get block number to write 
0371			; Write physical blocks starting at start block from buffer 
0371			  
0371			storage_write_block: 
0371				; TODO bank selection 
0371			 
0371				; for each of the physical blocks read it into the buffer 
0371 06 40			ld b, STORE_BLOCK_PHY 
0373			 
0373				if DEBUG_STORESE 
0373					DMARK "SWB" 
0373 f5				push af  
0374 3a 88 03			ld a, (.dmark)  
0377 32 77 fb			ld (debug_mark),a  
037a 3a 89 03			ld a, (.dmark+1)  
037d 32 78 fb			ld (debug_mark+1),a  
0380 3a 8a 03			ld a, (.dmark+2)  
0383 32 79 fb			ld (debug_mark+2),a  
0386 18 03			jr .pastdmark  
0388 ..			.dmark: db "SWB"  
038b f1			.pastdmark: pop af  
038c			endm  
# End of macro DMARK
038c			 
038c					;push af 
038c					;ld a, 'W' 
038c					;ld (debug_mark),a 
038c					;pop af 
038c					CALLMONITOR 
038c cd 00 14			call break_point_state  
038f				endm  
# End of macro CALLMONITOR
038f				endif 
038f			 
038f			; might not be working 
038f			;	call se_writepage 
038f			 
038f			;	ret 
038f			; 
038f			 
038f			 
038f			 
038f			.wl1:    
038f			 
038f				; read physical block at hl into de 
038f			        ; increment hl and de to next read position on exit 
038f			 
038f e5				push hl 
0390 d5				push de	 
0391 c5				push bc 
0392 1a				ld a,(de) 
0393				;if DEBUG_STORESE 
0393			;		push af 
0393			;		ld a, 'W' 
0393			;		ld (debug_mark),a 
0393			;		pop af 
0393			;		CALLMONITOR 
0393			;	endif 
0393 cd ea 01			call se_writebyte 
0396			;	call delay250ms 
0396 00				nop 
0397 00				nop 
0398 00				nop 
0399			;	if DEBUG_STORESE 
0399			;		push af 
0399			;		ld a, 'w' 
0399			;		ld (debug_mark),a 
0399			;		pop af 
0399			;		CALLMONITOR 
0399			;	endif 
0399 c1				pop bc 
039a d1				pop de 
039b e1				pop hl 
039c 23				inc hl 
039d 13				inc de 
039e			 
039e			 
039e 10 ef			djnz .wl1 
03a0			 
03a0				if DEBUG_STORESE 
03a0					DMARK "SW2" 
03a0 f5				push af  
03a1 3a b5 03			ld a, (.dmark)  
03a4 32 77 fb			ld (debug_mark),a  
03a7 3a b6 03			ld a, (.dmark+1)  
03aa 32 78 fb			ld (debug_mark+1),a  
03ad 3a b7 03			ld a, (.dmark+2)  
03b0 32 79 fb			ld (debug_mark+2),a  
03b3 18 03			jr .pastdmark  
03b5 ..			.dmark: db "SW2"  
03b8 f1			.pastdmark: pop af  
03b9			endm  
# End of macro DMARK
03b9			 
03b9					;push af 
03b9					;ld a, 'W' 
03b9					;ld (debug_mark),a 
03b9					;pop af 
03b9					CALLMONITOR 
03b9 cd 00 14			call break_point_state  
03bc				endm  
# End of macro CALLMONITOR
03bc				endif 
03bc c9				ret	 
03bd			 
03bd			; Init bank 
03bd			; --------- 
03bd			; 
03bd			; With current bank 
03bd			; 
03bd			; Setup block 0 config 
03bd			;     Set 0 file id counter 
03bd			;     Set formatted byte pattern 
03bd			;     Zero out bank label 
03bd			;      
03bd			; For every logical block write 0-1 byte as null 
03bd			 
03bd			storage_get_block_0: 
03bd			 
03bd				; TODO check presence 
03bd			 
03bd				; get block 0 config 
03bd			 
03bd 21 00 00			ld hl, 0 
03c0 11 62 f8			ld de, store_page 
03c3 cd 0c 03			call storage_read_block 
03c6			 
03c6				if DEBUG_STORESE 
03c6					DMARK "SB0" 
03c6 f5				push af  
03c7 3a db 03			ld a, (.dmark)  
03ca 32 77 fb			ld (debug_mark),a  
03cd 3a dc 03			ld a, (.dmark+1)  
03d0 32 78 fb			ld (debug_mark+1),a  
03d3 3a dd 03			ld a, (.dmark+2)  
03d6 32 79 fb			ld (debug_mark+2),a  
03d9 18 03			jr .pastdmark  
03db ..			.dmark: db "SB0"  
03de f1			.pastdmark: pop af  
03df			endm  
# End of macro DMARK
03df 11 62 f8				ld de, store_page 
03e2			;		push af 
03e2			;		ld a, 'i' 
03e2			;		ld (debug_mark),a 
03e2			;		pop af 
03e2					CALLMONITOR 
03e2 cd 00 14			call break_point_state  
03e5				endm  
# End of macro CALLMONITOR
03e5				endif 
03e5			 
03e5				; is this area formatted? 
03e5			 
03e5			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03e5 2a 63 f8			ld hl, (store_page+1) 
03e8 3e 80			ld a,0x80 
03ea bd				cp l 
03eb 20 22			jr nz, .ininotformatted 
03ed				; do a double check 
03ed 3e 27			ld a, 0x27 
03ef bc				cp h 
03f0 20 1d			jr nz, .ininotformatted 
03f2			 
03f2				; formatted then 
03f2			 
03f2				if DEBUG_STORESE 
03f2					DMARK "SB1" 
03f2 f5				push af  
03f3 3a 07 04			ld a, (.dmark)  
03f6 32 77 fb			ld (debug_mark),a  
03f9 3a 08 04			ld a, (.dmark+1)  
03fc 32 78 fb			ld (debug_mark+1),a  
03ff 3a 09 04			ld a, (.dmark+2)  
0402 32 79 fb			ld (debug_mark+2),a  
0405 18 03			jr .pastdmark  
0407 ..			.dmark: db "SB1"  
040a f1			.pastdmark: pop af  
040b			endm  
# End of macro DMARK
040b					;push af 
040b					;ld a, 'I' 
040b					;ld (debug_mark),a 
040b					;pop af 
040b					CALLMONITOR 
040b cd 00 14			call break_point_state  
040e				endm  
# End of macro CALLMONITOR
040e				endif 
040e c9				ret 
040f			 
040f			.ininotformatted: 
040f				; bank not formatted so poke various bits to make sure 
040f			 
040f				if DEBUG_STORESE 
040f					DMARK "SB2" 
040f f5				push af  
0410 3a 24 04			ld a, (.dmark)  
0413 32 77 fb			ld (debug_mark),a  
0416 3a 25 04			ld a, (.dmark+1)  
0419 32 78 fb			ld (debug_mark+1),a  
041c 3a 26 04			ld a, (.dmark+2)  
041f 32 79 fb			ld (debug_mark+2),a  
0422 18 03			jr .pastdmark  
0424 ..			.dmark: db "SB2"  
0427 f1			.pastdmark: pop af  
0428			endm  
# End of macro DMARK
0428					;push af 
0428					;ld a, 'f' 
0428					;ld (debug_mark),a 
0428					;pop af 
0428					CALLMONITOR 
0428 cd 00 14			call break_point_state  
042b				endm  
# End of macro CALLMONITOR
042b				endif 
042b			 
042b 21 62 f8			ld hl, store_page 
042e 3e 00			ld a, 0 
0430				 
0430 77				ld (hl),a   ; reset file counter 
0431			 
0431 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0434 22 63 f8		 	ld (store_page+1), hl	 
0437			 
0437				; set default label 
0437			 
0437 21 cc 04			ld hl, .defaultbanklabl 
043a 11 65 f8		 	ld de, store_page+3 
043d 01 0f 00			ld bc, 15 
0440 ed b0			ldir 
0442			 
0442				; save default page 0 
0442			 
0442 21 00 00			ld hl, 0 
0445 11 62 f8			ld de, store_page 
0448				if DEBUG_STORESE 
0448					DMARK "SB3" 
0448 f5				push af  
0449 3a 5d 04			ld a, (.dmark)  
044c 32 77 fb			ld (debug_mark),a  
044f 3a 5e 04			ld a, (.dmark+1)  
0452 32 78 fb			ld (debug_mark+1),a  
0455 3a 5f 04			ld a, (.dmark+2)  
0458 32 79 fb			ld (debug_mark+2),a  
045b 18 03			jr .pastdmark  
045d ..			.dmark: db "SB3"  
0460 f1			.pastdmark: pop af  
0461			endm  
# End of macro DMARK
0461			;		push af 
0461			;		ld a, 'F' 
0461			;		ld (debug_mark),a 
0461			;		pop af 
0461					CALLMONITOR 
0461 cd 00 14			call break_point_state  
0464				endm  
# End of macro CALLMONITOR
0464				endif 
0464 cd 71 03			call storage_write_block 
0467				if DEBUG_STORESE 
0467					DMARK "SB4" 
0467 f5				push af  
0468 3a 7c 04			ld a, (.dmark)  
046b 32 77 fb			ld (debug_mark),a  
046e 3a 7d 04			ld a, (.dmark+1)  
0471 32 78 fb			ld (debug_mark+1),a  
0474 3a 7e 04			ld a, (.dmark+2)  
0477 32 79 fb			ld (debug_mark+2),a  
047a 18 03			jr .pastdmark  
047c ..			.dmark: db "SB4"  
047f f1			.pastdmark: pop af  
0480			endm  
# End of macro DMARK
0480			;		push af 
0480			;		ld a, '>' 
0480			;		ld (debug_mark),a 
0480			;		pop af 
0480					CALLMONITOR 
0480 cd 00 14			call break_point_state  
0483				endm  
# End of macro CALLMONITOR
0483				endif 
0483			 
0483 00				nop 
0484 00				nop 
0485 00				nop 
0486			 
0486				; now set 0 in every page to mark as a free block 
0486			 
0486 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0488 21 40 00			ld hl, STORE_BLOCK_PHY 
048b			 
048b 3e 00		.setmark1:   	ld a,0 
048d e5					push hl 
048e c5					push bc 
048f cd ea 01				call se_writebyte 
0492 3e 0a			ld a, 10 
0494 cd 22 0a			call aDelayInMS 
0497 23				inc hl 
0498 cd ea 01				call se_writebyte 
049b 3e 0a			ld a, 10 
049d cd 22 0a			call aDelayInMS 
04a0 2b				dec hl 
04a1 c1					pop bc 
04a2 e1					pop hl 
04a3 3e 40				ld a, STORE_BLOCK_PHY 
04a5 cd 12 0c				call addatohl 
04a8 10 e1				djnz .setmark1 
04aa			 
04aa 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
04ac 3e 00		.setmark2:   	ld a,0 
04ae e5					push hl 
04af c5					push bc 
04b0 cd ea 01				call se_writebyte 
04b3 3e 0a			ld a, 10 
04b5 cd 22 0a			call aDelayInMS 
04b8 23				inc hl 
04b9 cd ea 01				call se_writebyte 
04bc 3e 0a			ld a, 10 
04be cd 22 0a			call aDelayInMS 
04c1 2b				dec hl 
04c2 c1					pop bc 
04c3 e1					pop hl 
04c4 3e 40				ld a, STORE_BLOCK_PHY 
04c6 cd 12 0c				call addatohl 
04c9 10 e1				djnz .setmark2 
04cb			 
04cb					 
04cb			 
04cb			 
04cb c9				ret 
04cc			 
04cc			 
04cc			 
04cc			 
04cc .. 00		.defaultbanklabl:   db "BankLabel",0 
04d6			 
04d6			 
04d6			 
04d6			; Label Bank 
04d6			; ---------- 
04d6			; 
04d6			; With current bank 
04d6			; Read block 0 
04d6			; Set label 
04d6			; Write block 0 
04d6			 
04d6			; label str pointer in hl 
04d6			 
04d6			storage_label:     
04d6			 
04d6				if DEBUG_STORESE 
04d6					DMARK "LBL" 
04d6 f5				push af  
04d7 3a eb 04			ld a, (.dmark)  
04da 32 77 fb			ld (debug_mark),a  
04dd 3a ec 04			ld a, (.dmark+1)  
04e0 32 78 fb			ld (debug_mark+1),a  
04e3 3a ed 04			ld a, (.dmark+2)  
04e6 32 79 fb			ld (debug_mark+2),a  
04e9 18 03			jr .pastdmark  
04eb ..			.dmark: db "LBL"  
04ee f1			.pastdmark: pop af  
04ef			endm  
# End of macro DMARK
04ef					CALLMONITOR 
04ef cd 00 14			call break_point_state  
04f2				endm  
# End of macro CALLMONITOR
04f2				endif 
04f2			 
04f2 e5				push hl 
04f3			 
04f3 cd bd 03			call storage_get_block_0 
04f6			 
04f6				; set default label 
04f6			 
04f6 e1				pop hl 
04f7			 
04f7 11 65 f8		 	ld de, store_page+3 
04fa 01 0f 00			ld bc, 15 
04fd				if DEBUG_STORESE 
04fd					DMARK "LB3" 
04fd f5				push af  
04fe 3a 12 05			ld a, (.dmark)  
0501 32 77 fb			ld (debug_mark),a  
0504 3a 13 05			ld a, (.dmark+1)  
0507 32 78 fb			ld (debug_mark+1),a  
050a 3a 14 05			ld a, (.dmark+2)  
050d 32 79 fb			ld (debug_mark+2),a  
0510 18 03			jr .pastdmark  
0512 ..			.dmark: db "LB3"  
0515 f1			.pastdmark: pop af  
0516			endm  
# End of macro DMARK
0516					CALLMONITOR 
0516 cd 00 14			call break_point_state  
0519				endm  
# End of macro CALLMONITOR
0519				endif 
0519 ed b0			ldir 
051b				; save default page 0 
051b			 
051b 21 00 00			ld hl, 0 
051e 11 62 f8			ld de, store_page 
0521				if DEBUG_STORESE 
0521					DMARK "LBW" 
0521 f5				push af  
0522 3a 36 05			ld a, (.dmark)  
0525 32 77 fb			ld (debug_mark),a  
0528 3a 37 05			ld a, (.dmark+1)  
052b 32 78 fb			ld (debug_mark+1),a  
052e 3a 38 05			ld a, (.dmark+2)  
0531 32 79 fb			ld (debug_mark+2),a  
0534 18 03			jr .pastdmark  
0536 ..			.dmark: db "LBW"  
0539 f1			.pastdmark: pop af  
053a			endm  
# End of macro DMARK
053a					CALLMONITOR 
053a cd 00 14			call break_point_state  
053d				endm  
# End of macro CALLMONITOR
053d				endif 
053d cd 71 03			call storage_write_block 
0540			 
0540 c9				ret 
0541			 
0541			 
0541			 
0541			; Read Block 0 - Config 
0541			; --------------------- 
0541			; 
0541			; With current bank 
0541			; Call presence test 
0541			;    If not present format/init bank  
0541			; Read block 0  
0541			;  
0541			 
0541			 
0541			; Dir 
0541			; --- 
0541			; 
0541			; With current bank 
0541			; Load Block 0 Config 
0541			; Get max file id number 
0541			; For each logical block 
0541			;    Read block read byte 2 
0541			;      if first block of file 
0541			;         Display file name 
0541			;         Display type flags for file 
0541			;        
0541			 
0541			; moving to words as this requires stack control 
0541			 
0541			 
0541			; Delete File 
0541			; ----------- 
0541			; 
0541			; With current bank 
0541			; 
0541			; Load Block 0 Config 
0541			; Get max file id number 
0541			; For each logical block 
0541			;    Read block file id 
0541			;      If first block of file and dont have file id 
0541			;         if file to delete 
0541			;         Save file id 
0541			;         Null file id 
0541			;         Write this block back 
0541			;      If file id is one saved 
0541			;         Null file id 
0541			;         Write this block back 
0541			 
0541			storage_erase: 
0541			 
0541				; hl contains the file id 
0541			 
0541 5d				ld e, l 
0542 16 00			ld d, 0 
0544 21 40 00			ld hl, STORE_BLOCK_PHY 
0547					if DEBUG_FORTH_WORDS 
0547						DMARK "ERA" 
0547 f5				push af  
0548 3a 5c 05			ld a, (.dmark)  
054b 32 77 fb			ld (debug_mark),a  
054e 3a 5d 05			ld a, (.dmark+1)  
0551 32 78 fb			ld (debug_mark+1),a  
0554 3a 5e 05			ld a, (.dmark+2)  
0557 32 79 fb			ld (debug_mark+2),a  
055a 18 03			jr .pastdmark  
055c ..			.dmark: db "ERA"  
055f f1			.pastdmark: pop af  
0560			endm  
# End of macro DMARK
0560						CALLMONITOR 
0560 cd 00 14			call break_point_state  
0563				endm  
# End of macro CALLMONITOR
0563					endif 
0563 cd 22 06			call storage_findnextid 
0566			 
0566 e5				push hl 
0567			 
0567				; TODO check file not found 
0567			 
0567 11 62 f8			ld de, store_page 
056a cd 0c 03			call storage_read_block 
056d			 
056d					if DEBUG_FORTH_WORDS 
056d						DMARK "ER1" 
056d f5				push af  
056e 3a 82 05			ld a, (.dmark)  
0571 32 77 fb			ld (debug_mark),a  
0574 3a 83 05			ld a, (.dmark+1)  
0577 32 78 fb			ld (debug_mark+1),a  
057a 3a 84 05			ld a, (.dmark+2)  
057d 32 79 fb			ld (debug_mark+2),a  
0580 18 03			jr .pastdmark  
0582 ..			.dmark: db "ER1"  
0585 f1			.pastdmark: pop af  
0586			endm  
# End of macro DMARK
0586						CALLMONITOR 
0586 cd 00 14			call break_point_state  
0589				endm  
# End of macro CALLMONITOR
0589					endif 
0589 3a 62 f8			ld a, (store_page)	; get file id 
058c 32 5b f8			ld (store_tmpid), a 
058f			 
058f 3a 64 f8			ld a, (store_page+2)    ; get count of extends 
0592 32 5a f8			ld (store_tmpext), a 
0595			 
0595				; wipe file header 
0595			 
0595 e1				pop hl 
0596 3e 00			ld a, 0 
0598 32 62 f8			ld (store_page), a 
059b 32 63 f8			ld (store_page+1),a 
059e 11 62 f8			ld de, store_page 
05a1					if DEBUG_FORTH_WORDS 
05a1						DMARK "ER2" 
05a1 f5				push af  
05a2 3a b6 05			ld a, (.dmark)  
05a5 32 77 fb			ld (debug_mark),a  
05a8 3a b7 05			ld a, (.dmark+1)  
05ab 32 78 fb			ld (debug_mark+1),a  
05ae 3a b8 05			ld a, (.dmark+2)  
05b1 32 79 fb			ld (debug_mark+2),a  
05b4 18 03			jr .pastdmark  
05b6 ..			.dmark: db "ER2"  
05b9 f1			.pastdmark: pop af  
05ba			endm  
# End of macro DMARK
05ba						CALLMONITOR 
05ba cd 00 14			call break_point_state  
05bd				endm  
# End of macro CALLMONITOR
05bd					endif 
05bd cd 71 03			call storage_write_block 
05c0			 
05c0			 
05c0				; wipe file extents 
05c0			 
05c0 3a 5a f8			ld a, (store_tmpext) 
05c3 47				ld b, a 
05c4			 
05c4			.eraext:	  
05c4 c5				push bc 
05c5			 
05c5 21 40 00			ld hl, STORE_BLOCK_PHY 
05c8 3a 5b f8			ld a,(store_tmpid) 
05cb 5f				ld e, a 
05cc 50				ld d, b	 
05cd					if DEBUG_FORTH_WORDS 
05cd						DMARK "ER3" 
05cd f5				push af  
05ce 3a e2 05			ld a, (.dmark)  
05d1 32 77 fb			ld (debug_mark),a  
05d4 3a e3 05			ld a, (.dmark+1)  
05d7 32 78 fb			ld (debug_mark+1),a  
05da 3a e4 05			ld a, (.dmark+2)  
05dd 32 79 fb			ld (debug_mark+2),a  
05e0 18 03			jr .pastdmark  
05e2 ..			.dmark: db "ER3"  
05e5 f1			.pastdmark: pop af  
05e6			endm  
# End of macro DMARK
05e6						CALLMONITOR 
05e6 cd 00 14			call break_point_state  
05e9				endm  
# End of macro CALLMONITOR
05e9					endif 
05e9 cd 22 06			call storage_findnextid 
05ec			 
05ec e5				push hl 
05ed 11 62 f8			ld de, store_page 
05f0 cd 0c 03			call storage_read_block 
05f3			 
05f3				; free block	 
05f3			 
05f3 3e 00			ld a, 0 
05f5 32 62 f8			ld (store_page), a 
05f8 32 63 f8			ld (store_page+1),a 
05fb 11 62 f8			ld de, store_page 
05fe e1				pop hl 
05ff					if DEBUG_FORTH_WORDS 
05ff						DMARK "ER4" 
05ff f5				push af  
0600 3a 14 06			ld a, (.dmark)  
0603 32 77 fb			ld (debug_mark),a  
0606 3a 15 06			ld a, (.dmark+1)  
0609 32 78 fb			ld (debug_mark+1),a  
060c 3a 16 06			ld a, (.dmark+2)  
060f 32 79 fb			ld (debug_mark+2),a  
0612 18 03			jr .pastdmark  
0614 ..			.dmark: db "ER4"  
0617 f1			.pastdmark: pop af  
0618			endm  
# End of macro DMARK
0618						CALLMONITOR 
0618 cd 00 14			call break_point_state  
061b				endm  
# End of macro CALLMONITOR
061b					endif 
061b cd 71 03			call storage_write_block 
061e			 
061e c1				pop bc 
061f 10 a3			djnz .eraext 
0621			 
0621 c9				ret 
0622			 
0622			 
0622			; Find Free Block 
0622			; --------------- 
0622			; 
0622			; With current bank 
0622			;  
0622			; From given starting logical block 
0622			;    Read block  
0622			;    If no file id 
0622			;         Return block id 
0622			 
0622			 
0622			; hl starting page number 
0622			; hl contains free page number or zero if no pages free 
0622			; e contains the file id to locate 
0622			; d contains the block number 
0622			 
0622			; TODO change to find file id and use zero for free block 
0622			 
0622			storage_findnextid: 
0622			 
0622				; now locate first 0 page to mark as a free block 
0622			 
0622 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0624			;	ld hl, STORE_BLOCK_PHY 
0624			 
0624					if DEBUG_FORTH_WORDS 
0624					DMARK "FNI" 
0624 f5				push af  
0625 3a 39 06			ld a, (.dmark)  
0628 32 77 fb			ld (debug_mark),a  
062b 3a 3a 06			ld a, (.dmark+1)  
062e 32 78 fb			ld (debug_mark+1),a  
0631 3a 3b 06			ld a, (.dmark+2)  
0634 32 79 fb			ld (debug_mark+2),a  
0637 18 03			jr .pastdmark  
0639 ..			.dmark: db "FNI"  
063c f1			.pastdmark: pop af  
063d			endm  
# End of macro DMARK
063d						CALLMONITOR 
063d cd 00 14			call break_point_state  
0640				endm  
# End of macro CALLMONITOR
0640					endif 
0640			.ff1:   	 
0640 e5					push hl 
0641 c5					push bc 
0642 d5					push de 
0643 cd 8c 02				call se_readbyte 
0646 5f					ld e,a 
0647 23					inc hl 
0648 cd 8c 02				call se_readbyte 
064b 57					ld d, a 
064c e1					pop hl 
064d e5					push hl 
064e cd 30 0c				call cmp16 
0651 28 49				jr z, .fffound 
0653			 
0653 d1					pop de 
0654 c1					pop bc 
0655 e1					pop hl 
0656			 
0656					; is found? 
0656					;cp e 
0656					;ret z 
0656			 
0656 3e 40				ld a, STORE_BLOCK_PHY 
0658 cd 12 0c				call addatohl 
065b 10 e3				djnz .ff1 
065d			 
065d 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
065f			.ff2:   	 
065f			 
065f e5					push hl 
0660 c5					push bc 
0661 d5					push de 
0662 cd 8c 02				call se_readbyte 
0665 5f					ld e,a 
0666 23					inc hl 
0667 cd 8c 02				call se_readbyte 
066a 57					ld d, a 
066b			 
066b e1					pop hl 
066c e5					push hl 
066d cd 30 0c				call cmp16 
0670 28 2a				jr z, .fffound 
0672			 
0672 d1					pop de 
0673 c1					pop bc 
0674 e1					pop hl 
0675					; is found? 
0675					;cp e 
0675					;ret z 
0675			 
0675 3e 40				ld a, STORE_BLOCK_PHY 
0677 cd 12 0c				call addatohl 
067a 10 e3				djnz .ff2 
067c			 
067c			 
067c					if DEBUG_FORTH_WORDS 
067c					DMARK "FN-" 
067c f5				push af  
067d 3a 91 06			ld a, (.dmark)  
0680 32 77 fb			ld (debug_mark),a  
0683 3a 92 06			ld a, (.dmark+1)  
0686 32 78 fb			ld (debug_mark+1),a  
0689 3a 93 06			ld a, (.dmark+2)  
068c 32 79 fb			ld (debug_mark+2),a  
068f 18 03			jr .pastdmark  
0691 ..			.dmark: db "FN-"  
0694 f1			.pastdmark: pop af  
0695			endm  
# End of macro DMARK
0695					;	push af 
0695					;	ld a, 'n' 
0695					;	ld (debug_mark),a 
0695					;	pop af 
0695						CALLMONITOR 
0695 cd 00 14			call break_point_state  
0698				endm  
# End of macro CALLMONITOR
0698					endif 
0698				; no free marks! 
0698 21 00 00				ld hl, 0 
069b c9				ret 
069c			.fffound: 
069c				 
069c			 
069c d1					pop de 
069d c1					pop bc 
069e e1					pop hl 
069f					if DEBUG_FORTH_WORDS 
069f					DMARK "FNF" 
069f f5				push af  
06a0 3a b4 06			ld a, (.dmark)  
06a3 32 77 fb			ld (debug_mark),a  
06a6 3a b5 06			ld a, (.dmark+1)  
06a9 32 78 fb			ld (debug_mark+1),a  
06ac 3a b6 06			ld a, (.dmark+2)  
06af 32 79 fb			ld (debug_mark+2),a  
06b2 18 03			jr .pastdmark  
06b4 ..			.dmark: db "FNF"  
06b7 f1			.pastdmark: pop af  
06b8			endm  
# End of macro DMARK
06b8					;	push af 
06b8					;	ld a, 'n' 
06b8					;	ld (debug_mark),a 
06b8					;	pop af 
06b8						CALLMONITOR 
06b8 cd 00 14			call break_point_state  
06bb				endm  
# End of macro CALLMONITOR
06bb					endif 
06bb c9				ret 
06bc			 
06bc			 
06bc			 
06bc			; Free Space 
06bc			; ---------- 
06bc			; 
06bc			; With current bank 
06bc			; 
06bc			; Set block count to zero 
06bc			; Starting with first logical block 
06bc			;      Find free block  
06bc			;      If block id given, increment block count 
06bc			; 
06bc			;  
06bc			 
06bc			 
06bc			; hl contains count of free blocks 
06bc			 
06bc			storage_freeblocks: 
06bc			 
06bc				; now locate first 0 page to mark as a free block 
06bc			 
06bc 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
06be 21 40 00			ld hl, STORE_BLOCK_PHY 
06c1 11 00 00			ld de, 0 
06c4			 
06c4			.fb1:   	 
06c4 e5					push hl 
06c5 c5					push bc 
06c6 d5					push de 
06c7 cd 8c 02				call se_readbyte 
06ca d1					pop de 
06cb c1					pop bc 
06cc e1					pop hl 
06cd			 
06cd					; is free? 
06cd fe 00				cp 0 
06cf 20 01				jr nz, .ff1cont 
06d1 13					inc de 
06d2			 
06d2			.ff1cont: 
06d2			 
06d2			 
06d2 3e 40				ld a, STORE_BLOCK_PHY 
06d4 cd 12 0c				call addatohl 
06d7 10 eb				djnz .fb1 
06d9			 
06d9 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
06db			.fb2:   	 
06db e5					push hl 
06dc c5					push bc 
06dd d5					push de 
06de cd 8c 02				call se_readbyte 
06e1 d1					pop de 
06e2 c1					pop bc 
06e3 e1					pop hl 
06e4			 
06e4					; is free? 
06e4 fe 00				cp 0 
06e6 20 01				jr nz, .ff2cont 
06e8 13					inc de 
06e9			 
06e9			.ff2cont: 
06e9			 
06e9 3e 40				ld a, STORE_BLOCK_PHY 
06eb cd 12 0c				call addatohl 
06ee 10 eb				djnz .fb2 
06f0			 
06f0 eb				ex de, hl 
06f1 c9				ret 
06f2			 
06f2			; Get File ID 
06f2			; ----------- 
06f2			; 
06f2			; With current bank 
06f2			;  
06f2			; Load Block 0 Config 
06f2			; Get max file id number 
06f2			; For each logical block 
06f2			;    Read block file id 
06f2			;      If first block of file and dont have file id 
06f2			;         if file get id and exit 
06f2			 
06f2			 
06f2			 
06f2			 
06f2			; Create File 
06f2			; ----------- 
06f2			; 
06f2			; With current bank  
06f2			; Load Block 0 Config 
06f2			; Get max file id number 
06f2			; Increment file id number 
06f2			; Save Config 
06f2			; Find free block 
06f2			; Set buffer with file name and file id 
06f2			; Write buffer to free block  
06f2			 
06f2			 
06f2			; hl point to file name 
06f2			; hl returns file id 
06f2			 
06f2			; file format: 
06f2			; byte 0 - file id 
06f2			; byte 1 - extent number 
06f2			; byte 2-> data 
06f2			 
06f2			; format for extent number 0: 
06f2			; 
06f2			; byte 0 - file id 
06f2			; byte 1 - extent 0 
06f2			; byte 2 - extent count 
06f2			; byte 3 -> file name and meta data 
06f2			 
06f2			 
06f2			storage_create: 
06f2				if DEBUG_STORESE 
06f2					DMARK "SCR" 
06f2 f5				push af  
06f3 3a 07 07			ld a, (.dmark)  
06f6 32 77 fb			ld (debug_mark),a  
06f9 3a 08 07			ld a, (.dmark+1)  
06fc 32 78 fb			ld (debug_mark+1),a  
06ff 3a 09 07			ld a, (.dmark+2)  
0702 32 79 fb			ld (debug_mark+2),a  
0705 18 03			jr .pastdmark  
0707 ..			.dmark: db "SCR"  
070a f1			.pastdmark: pop af  
070b			endm  
# End of macro DMARK
070b					CALLMONITOR 
070b cd 00 14			call break_point_state  
070e				endm  
# End of macro CALLMONITOR
070e				endif 
070e			 
070e e5				push hl		; save file name pointer 
070f			 
070f cd bd 03			call storage_get_block_0 
0712			 
0712 3a 62 f8			ld a,(store_page)	; get current file id 
0715 3c				inc a 
0716 32 62 f8			ld (store_page),a 
0719				 
0719 32 5b f8			ld (store_tmpid),a			; save id 
071c			 
071c 21 00 00			ld hl, 0 
071f 11 62 f8			ld de, store_page 
0722				if DEBUG_STORESE 
0722					DMARK "SCw" 
0722 f5				push af  
0723 3a 37 07			ld a, (.dmark)  
0726 32 77 fb			ld (debug_mark),a  
0729 3a 38 07			ld a, (.dmark+1)  
072c 32 78 fb			ld (debug_mark+1),a  
072f 3a 39 07			ld a, (.dmark+2)  
0732 32 79 fb			ld (debug_mark+2),a  
0735 18 03			jr .pastdmark  
0737 ..			.dmark: db "SCw"  
073a f1			.pastdmark: pop af  
073b			endm  
# End of macro DMARK
073b					CALLMONITOR 
073b cd 00 14			call break_point_state  
073e				endm  
# End of macro CALLMONITOR
073e				endif 
073e cd 71 03			call storage_write_block	 ; save update 
0741			 
0741				if DEBUG_STORESE 
0741 11 62 f8				ld de, store_page 
0744					DMARK "SCC" 
0744 f5				push af  
0745 3a 59 07			ld a, (.dmark)  
0748 32 77 fb			ld (debug_mark),a  
074b 3a 5a 07			ld a, (.dmark+1)  
074e 32 78 fb			ld (debug_mark+1),a  
0751 3a 5b 07			ld a, (.dmark+2)  
0754 32 79 fb			ld (debug_mark+2),a  
0757 18 03			jr .pastdmark  
0759 ..			.dmark: db "SCC"  
075c f1			.pastdmark: pop af  
075d			endm  
# End of macro DMARK
075d					CALLMONITOR 
075d cd 00 14			call break_point_state  
0760				endm  
# End of macro CALLMONITOR
0760				endif 
0760				;  
0760				 
0760 21 40 00			ld hl, STORE_BLOCK_PHY 
0763 11 00 00			ld de, 0 
0766 cd 22 06			call storage_findnextid 
0769			 
0769 22 60 f8			ld (store_tmppageid), hl    ; save page to use  
076c			 
076c				; TODO detect 0 = no spare blocks 
076c			 
076c				; hl now contains the free page to use for the file header page 
076c			 
076c				if DEBUG_STORESE 
076c				DMARK "SCF" 
076c f5				push af  
076d 3a 81 07			ld a, (.dmark)  
0770 32 77 fb			ld (debug_mark),a  
0773 3a 82 07			ld a, (.dmark+1)  
0776 32 78 fb			ld (debug_mark+1),a  
0779 3a 83 07			ld a, (.dmark+2)  
077c 32 79 fb			ld (debug_mark+2),a  
077f 18 03			jr .pastdmark  
0781 ..			.dmark: db "SCF"  
0784 f1			.pastdmark: pop af  
0785			endm  
# End of macro DMARK
0785					CALLMONITOR 
0785 cd 00 14			call break_point_state  
0788				endm  
# End of macro CALLMONITOR
0788				endif 
0788			 
0788 22 60 f8			ld (store_tmppageid), hl 
078b				 
078b 3a 5b f8			ld a,(store_tmpid)    ; get file id 
078e			;	ld a, (store_filecache)			; save to cache 
078e			 
078e 32 62 f8			ld (store_page),a    ; set page id 
0791 3e 00			ld a, 0			 ; extent 0 is file header 
0793 32 63 f8			ld (store_page+1), a   ; set file extent 
0796			 
0796 32 64 f8			ld (store_page+2), a   ; extent count for the file 
0799			 
0799			;	inc hl 		; init block 0 of file 
0799			;	inc hl   		; skip file and extent id 
0799			 ;       ld a, 0 
0799			;	ld (hl),a 
0799			;	ld a, (store_filecache+1)  	; save to cache 
0799			 
0799			;	inc hl    ; file name 
0799				 
0799				 
0799 11 65 f8			ld de, store_page+3    ; get buffer for term string to use as file name 
079c				if DEBUG_STORESE 
079c					DMARK "SCc" 
079c f5				push af  
079d 3a b1 07			ld a, (.dmark)  
07a0 32 77 fb			ld (debug_mark),a  
07a3 3a b2 07			ld a, (.dmark+1)  
07a6 32 78 fb			ld (debug_mark+1),a  
07a9 3a b3 07			ld a, (.dmark+2)  
07ac 32 79 fb			ld (debug_mark+2),a  
07af 18 03			jr .pastdmark  
07b1 ..			.dmark: db "SCc"  
07b4 f1			.pastdmark: pop af  
07b5			endm  
# End of macro DMARK
07b5					CALLMONITOR 
07b5 cd 00 14			call break_point_state  
07b8				endm  
# End of macro CALLMONITOR
07b8				endif 
07b8 e1				pop hl    ; get zero term string 
07b9 e5				push hl 
07ba 3e 00			ld a, 0 
07bc cd 7b 10			call strlent 
07bf 23				inc hl   ; cover zero term 
07c0 06 00			ld b,0 
07c2 4d				ld c,l 
07c3 e1				pop hl 
07c4				;ex de, hl 
07c4				if DEBUG_STORESE 
07c4					DMARK "SCa" 
07c4 f5				push af  
07c5 3a d9 07			ld a, (.dmark)  
07c8 32 77 fb			ld (debug_mark),a  
07cb 3a da 07			ld a, (.dmark+1)  
07ce 32 78 fb			ld (debug_mark+1),a  
07d1 3a db 07			ld a, (.dmark+2)  
07d4 32 79 fb			ld (debug_mark+2),a  
07d7 18 03			jr .pastdmark  
07d9 ..			.dmark: db "SCa"  
07dc f1			.pastdmark: pop af  
07dd			endm  
# End of macro DMARK
07dd					;push af 
07dd					;ld a, 'a' 
07dd					;ld (debug_mark),a 
07dd					;pop af 
07dd					CALLMONITOR 
07dd cd 00 14			call break_point_state  
07e0				endm  
# End of macro CALLMONITOR
07e0				endif 
07e0 ed b0			ldir    ; copy zero term string 
07e2				if DEBUG_STORESE 
07e2					DMARK "SCA" 
07e2 f5				push af  
07e3 3a f7 07			ld a, (.dmark)  
07e6 32 77 fb			ld (debug_mark),a  
07e9 3a f8 07			ld a, (.dmark+1)  
07ec 32 78 fb			ld (debug_mark+1),a  
07ef 3a f9 07			ld a, (.dmark+2)  
07f2 32 79 fb			ld (debug_mark+2),a  
07f5 18 03			jr .pastdmark  
07f7 ..			.dmark: db "SCA"  
07fa f1			.pastdmark: pop af  
07fb			endm  
# End of macro DMARK
07fb					CALLMONITOR 
07fb cd 00 14			call break_point_state  
07fe				endm  
# End of macro CALLMONITOR
07fe				endif 
07fe			 
07fe				; write file header page 
07fe			 
07fe 2a 60 f8			ld hl,(store_tmppageid) 
0801 11 62 f8			ld de, store_page 
0804				if DEBUG_STORESE 
0804					DMARK "SCb" 
0804 f5				push af  
0805 3a 19 08			ld a, (.dmark)  
0808 32 77 fb			ld (debug_mark),a  
080b 3a 1a 08			ld a, (.dmark+1)  
080e 32 78 fb			ld (debug_mark+1),a  
0811 3a 1b 08			ld a, (.dmark+2)  
0814 32 79 fb			ld (debug_mark+2),a  
0817 18 03			jr .pastdmark  
0819 ..			.dmark: db "SCb"  
081c f1			.pastdmark: pop af  
081d			endm  
# End of macro DMARK
081d					;push af 
081d					;ld a, 'b' 
081d					;ld (debug_mark),a 
081d					;pop af 
081d					CALLMONITOR 
081d cd 00 14			call break_point_state  
0820				endm  
# End of macro CALLMONITOR
0820				endif 
0820 cd 71 03			call storage_write_block 
0823			 
0823 3a 5b f8			ld a, (store_tmpid) 
0826 6f				ld l, a 
0827 26 00			ld h,0 
0829				if DEBUG_STORESE 
0829					DMARK "SCz" 
0829 f5				push af  
082a 3a 3e 08			ld a, (.dmark)  
082d 32 77 fb			ld (debug_mark),a  
0830 3a 3f 08			ld a, (.dmark+1)  
0833 32 78 fb			ld (debug_mark+1),a  
0836 3a 40 08			ld a, (.dmark+2)  
0839 32 79 fb			ld (debug_mark+2),a  
083c 18 03			jr .pastdmark  
083e ..			.dmark: db "SCz"  
0841 f1			.pastdmark: pop af  
0842			endm  
# End of macro DMARK
0842					CALLMONITOR 
0842 cd 00 14			call break_point_state  
0845				endm  
# End of macro CALLMONITOR
0845				endif 
0845 c9				ret 
0846				 
0846			 
0846			 
0846			; 
0846			; Read File 
0846			; 
0846			; h - file id to locate 
0846			; l - extent to locate 
0846			; de - pointer to string to read into 
0846			; 
0846			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
0846			storage_read: 
0846 d5				push de 
0847			 
0847			; TODO BUG the above push is it popped before the RET Z? 
0847			 
0847			; TODO how to handle multiple part blocks 
0847			 
0847				; locate file extent to read 
0847			 
0847 5c				ld e, h 
0848 55				ld d, l 
0849 21 40 00			ld hl, STORE_BLOCK_PHY 
084c				if DEBUG_STORESE 
084c					DMARK "SRE" 
084c f5				push af  
084d 3a 61 08			ld a, (.dmark)  
0850 32 77 fb			ld (debug_mark),a  
0853 3a 62 08			ld a, (.dmark+1)  
0856 32 78 fb			ld (debug_mark+1),a  
0859 3a 63 08			ld a, (.dmark+2)  
085c 32 79 fb			ld (debug_mark+2),a  
085f 18 03			jr .pastdmark  
0861 ..			.dmark: db "SRE"  
0864 f1			.pastdmark: pop af  
0865			endm  
# End of macro DMARK
0865					CALLMONITOR 
0865 cd 00 14			call break_point_state  
0868				endm  
# End of macro CALLMONITOR
0868				endif 
0868 cd 22 06			call storage_findnextid 
086b			 
086b				if DEBUG_STORESE 
086b					DMARK "SRf" 
086b f5				push af  
086c 3a 80 08			ld a, (.dmark)  
086f 32 77 fb			ld (debug_mark),a  
0872 3a 81 08			ld a, (.dmark+1)  
0875 32 78 fb			ld (debug_mark+1),a  
0878 3a 82 08			ld a, (.dmark+2)  
087b 32 79 fb			ld (debug_mark+2),a  
087e 18 03			jr .pastdmark  
0880 ..			.dmark: db "SRf"  
0883 f1			.pastdmark: pop af  
0884			endm  
# End of macro DMARK
0884					CALLMONITOR 
0884 cd 00 14			call break_point_state  
0887				endm  
# End of macro CALLMONITOR
0887				endif 
0887 cd 3b 0c			call ishlzero 
088a			;	ld a, l 
088a			;	add h 
088a			;	cp 0 
088a c8				ret z			; block not found so EOF 
088b			 
088b				; hl contains page number to load 
088b d1				pop de   ; get storage 
088c d5				push de 
088d				if DEBUG_STORESE 
088d					DMARK "SRg" 
088d f5				push af  
088e 3a a2 08			ld a, (.dmark)  
0891 32 77 fb			ld (debug_mark),a  
0894 3a a3 08			ld a, (.dmark+1)  
0897 32 78 fb			ld (debug_mark+1),a  
089a 3a a4 08			ld a, (.dmark+2)  
089d 32 79 fb			ld (debug_mark+2),a  
08a0 18 03			jr .pastdmark  
08a2 ..			.dmark: db "SRg"  
08a5 f1			.pastdmark: pop af  
08a6			endm  
# End of macro DMARK
08a6					CALLMONITOR 
08a6 cd 00 14			call break_point_state  
08a9				endm  
# End of macro CALLMONITOR
08a9				endif 
08a9 cd 0c 03			call storage_read_block 
08ac			 
08ac			 
08ac			; TODO if block has no zeros then need to read next block  
08ac			 
08ac			 
08ac					 
08ac e1				pop hl 		 ; return start of data to show as not EOF 
08ad 23				inc hl   ; past file id 
08ae 23				inc hl   ; past ext 
08af				if DEBUG_STORESE 
08af					DMARK "SRe" 
08af f5				push af  
08b0 3a c4 08			ld a, (.dmark)  
08b3 32 77 fb			ld (debug_mark),a  
08b6 3a c5 08			ld a, (.dmark+1)  
08b9 32 78 fb			ld (debug_mark+1),a  
08bc 3a c6 08			ld a, (.dmark+2)  
08bf 32 79 fb			ld (debug_mark+2),a  
08c2 18 03			jr .pastdmark  
08c4 ..			.dmark: db "SRe"  
08c7 f1			.pastdmark: pop af  
08c8			endm  
# End of macro DMARK
08c8					CALLMONITOR 
08c8 cd 00 14			call break_point_state  
08cb				endm  
# End of macro CALLMONITOR
08cb				endif 
08cb c9					ret 
08cc			 
08cc			 
08cc			 
08cc			; 
08cc			; Append File 
08cc			; 
08cc			; hl - file id to locate 
08cc			; de - pointer to (multi block) string to write 
08cc			 
08cc			 
08cc			storage_append: 
08cc				; hl -  file id to append to 
08cc				; de - string to append 
08cc			 
08cc d5				push de 
08cd				 
08cd				if DEBUG_STORESE 
08cd					DMARK "AP1" 
08cd f5				push af  
08ce 3a e2 08			ld a, (.dmark)  
08d1 32 77 fb			ld (debug_mark),a  
08d4 3a e3 08			ld a, (.dmark+1)  
08d7 32 78 fb			ld (debug_mark+1),a  
08da 3a e4 08			ld a, (.dmark+2)  
08dd 32 79 fb			ld (debug_mark+2),a  
08e0 18 03			jr .pastdmark  
08e2 ..			.dmark: db "AP1"  
08e5 f1			.pastdmark: pop af  
08e6			endm  
# End of macro DMARK
08e6					CALLMONITOR 
08e6 cd 00 14			call break_point_state  
08e9				endm  
# End of macro CALLMONITOR
08e9				endif 
08e9			 
08e9 7d				ld a, l 
08ea 32 5b f8			ld (store_tmpid), a 
08ed			 
08ed				; get file header  
08ed			 
08ed 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
08ef 3a 5b f8			ld a, (store_tmpid) 
08f2 5f				ld e, a 
08f3			 
08f3 21 40 00				ld hl, STORE_BLOCK_PHY 
08f6 cd 22 06				call storage_findnextid 
08f9			 
08f9 22 60 f8			ld (store_tmppageid), hl 
08fc			 
08fc				; TODO handle file id not found 
08fc			 
08fc				if DEBUG_STORESE 
08fc					DMARK "AP2" 
08fc f5				push af  
08fd 3a 11 09			ld a, (.dmark)  
0900 32 77 fb			ld (debug_mark),a  
0903 3a 12 09			ld a, (.dmark+1)  
0906 32 78 fb			ld (debug_mark+1),a  
0909 3a 13 09			ld a, (.dmark+2)  
090c 32 79 fb			ld (debug_mark+2),a  
090f 18 03			jr .pastdmark  
0911 ..			.dmark: db "AP2"  
0914 f1			.pastdmark: pop af  
0915			endm  
# End of macro DMARK
0915					CALLMONITOR 
0915 cd 00 14			call break_point_state  
0918				endm  
# End of macro CALLMONITOR
0918				endif 
0918			 
0918				; update file extent count 
0918			 
0918 11 62 f8			ld de, store_page 
091b			 
091b cd 0c 03			call storage_read_block 
091e			 
091e				if DEBUG_STORESE 
091e					DMARK "AP3" 
091e f5				push af  
091f 3a 33 09			ld a, (.dmark)  
0922 32 77 fb			ld (debug_mark),a  
0925 3a 34 09			ld a, (.dmark+1)  
0928 32 78 fb			ld (debug_mark+1),a  
092b 3a 35 09			ld a, (.dmark+2)  
092e 32 79 fb			ld (debug_mark+2),a  
0931 18 03			jr .pastdmark  
0933 ..			.dmark: db "AP3"  
0936 f1			.pastdmark: pop af  
0937			endm  
# End of macro DMARK
0937					CALLMONITOR 
0937 cd 00 14			call break_point_state  
093a				endm  
# End of macro CALLMONITOR
093a				endif 
093a			;	ld (store_tmppageid), hl 
093a			 
093a 3a 64 f8			ld a, (store_page+2) 
093d 3c				inc a 
093e 32 64 f8			ld (store_page+2), a 
0941 32 5a f8			ld (store_tmpext), a 
0944				 
0944				if DEBUG_STORESE 
0944					DMARK "AP3" 
0944 f5				push af  
0945 3a 59 09			ld a, (.dmark)  
0948 32 77 fb			ld (debug_mark),a  
094b 3a 5a 09			ld a, (.dmark+1)  
094e 32 78 fb			ld (debug_mark+1),a  
0951 3a 5b 09			ld a, (.dmark+2)  
0954 32 79 fb			ld (debug_mark+2),a  
0957 18 03			jr .pastdmark  
0959 ..			.dmark: db "AP3"  
095c f1			.pastdmark: pop af  
095d			endm  
# End of macro DMARK
095d					CALLMONITOR 
095d cd 00 14			call break_point_state  
0960				endm  
# End of macro CALLMONITOR
0960				endif 
0960 2a 60 f8			ld hl, (store_tmppageid) 
0963 11 62 f8			ld de, store_page 
0966 cd 71 03			call storage_write_block 
0969			 
0969				; find free block 
0969			 
0969 11 00 00			ld de, 0			 ; file extent to locate 
096c			 
096c 21 40 00				ld hl, STORE_BLOCK_PHY 
096f cd 22 06				call storage_findnextid 
0972			 
0972					; TODO handle no space left 
0972					 
0972 22 60 f8				ld (store_tmppageid), hl 
0975			 
0975				if DEBUG_STORESE 
0975					DMARK "AP4" 
0975 f5				push af  
0976 3a 8a 09			ld a, (.dmark)  
0979 32 77 fb			ld (debug_mark),a  
097c 3a 8b 09			ld a, (.dmark+1)  
097f 32 78 fb			ld (debug_mark+1),a  
0982 3a 8c 09			ld a, (.dmark+2)  
0985 32 79 fb			ld (debug_mark+2),a  
0988 18 03			jr .pastdmark  
098a ..			.dmark: db "AP4"  
098d f1			.pastdmark: pop af  
098e			endm  
# End of macro DMARK
098e					CALLMONITOR 
098e cd 00 14			call break_point_state  
0991				endm  
# End of macro CALLMONITOR
0991				endif 
0991					; init the buffer with zeros so we can id if the buffer is full or not 
0991			 
0991 e5					push hl 
0992 c5					push bc 
0993			 
0993 21 62 f8				ld hl, store_page 
0996 06 40				ld b, STORE_BLOCK_PHY 
0998 3e 00				ld a, 0 
099a 77			.zeroblock:	ld (hl), a 
099b 23					inc hl 
099c 10 fc				djnz .zeroblock 
099e			 
099e c1					pop bc 
099f e1					pop hl 
09a0			 
09a0					; construct block 
09a0			 
09a0 3a 5b f8				ld a, (store_tmpid) 
09a3 32 62 f8				ld (store_page), a   ; file id 
09a6 3a 5a f8				ld a, (store_tmpext)   ; extent for this block 
09a9 32 63 f8				ld (store_page+1), a 
09ac			 
09ac e1					pop hl    ; get string to write 
09ad 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
09af 11 64 f8				ld de, store_page+2 
09b2			 
09b2				if DEBUG_STORESE 
09b2					DMARK "AP5" 
09b2 f5				push af  
09b3 3a c7 09			ld a, (.dmark)  
09b6 32 77 fb			ld (debug_mark),a  
09b9 3a c8 09			ld a, (.dmark+1)  
09bc 32 78 fb			ld (debug_mark+1),a  
09bf 3a c9 09			ld a, (.dmark+2)  
09c2 32 79 fb			ld (debug_mark+2),a  
09c5 18 03			jr .pastdmark  
09c7 ..			.dmark: db "AP5"  
09ca f1			.pastdmark: pop af  
09cb			endm  
# End of macro DMARK
09cb					CALLMONITOR 
09cb cd 00 14			call break_point_state  
09ce				endm  
# End of macro CALLMONITOR
09ce				endif 
09ce			 
09ce			 
09ce			 
09ce					; fill buffer with data until end of string or full block 
09ce			 
09ce 7e			.appd:		ld a, (hl) 
09cf 12					ld (de), a 
09d0 fe 00				cp 0 
09d2 28 04				jr z, .appdone 
09d4 23					inc hl 
09d5 13					inc de 
09d6 10 f6				djnz .appd 
09d8			 
09d8 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
09d9 f5					push af   		; save last byte dumped 
09da			 
09da			 
09da 2a 60 f8			ld hl, (store_tmppageid) 
09dd 11 62 f8			ld de, store_page 
09e0				if DEBUG_STORESE 
09e0					DMARK "AP6" 
09e0 f5				push af  
09e1 3a f5 09			ld a, (.dmark)  
09e4 32 77 fb			ld (debug_mark),a  
09e7 3a f6 09			ld a, (.dmark+1)  
09ea 32 78 fb			ld (debug_mark+1),a  
09ed 3a f7 09			ld a, (.dmark+2)  
09f0 32 79 fb			ld (debug_mark+2),a  
09f3 18 03			jr .pastdmark  
09f5 ..			.dmark: db "AP6"  
09f8 f1			.pastdmark: pop af  
09f9			endm  
# End of macro DMARK
09f9					CALLMONITOR 
09f9 cd 00 14			call break_point_state  
09fc				endm  
# End of macro CALLMONITOR
09fc				endif 
09fc cd 71 03				call storage_write_block 
09ff			 
09ff			 
09ff				; was that a full block of data written? 
09ff				; any more to write out? 
09ff			 
09ff				; if yes then set vars and jump to start of function again 
09ff			 
09ff f1					pop af 
0a00 d1					pop de 
0a01			 
0a01 fe 00				cp 0		 ; no, string was fully written 
0a03 c8					ret z 
0a04			 
0a04					; setup vars for next cycle 
0a04			 
0a04 3a 5b f8				ld a, (store_tmpid) 
0a07 6f					ld l, a 
0a08 26 00				ld h, 0 
0a0a			 
0a0a c3 cc 08			 	jp storage_append	 ; yes, need to write out some more 
0a0d			 
0a0d			 
0a0d			 
0a0d			 
0a0d			 
0a0d			 
0a0d			 
0a0d			if DEBUG_STORECF 
0a0d			storageput:	 
0a0d					ret 
0a0d			storageread: 
0a0d					ld hl, store_page 
0a0d					ld b, 200 
0a0d					ld a,0 
0a0d			.src:		ld (hl),a 
0a0d					inc hl 
0a0d					djnz .src 
0a0d					 
0a0d			 
0a0d					ld de, 0 
0a0d					ld bc, 1 
0a0d					ld hl, store_page 
0a0d					call cfRead 
0a0d			 
0a0d				call cfGetError 
0a0d				ld hl,scratch 
0a0d				call hexout 
0a0d				ld hl, scratch+2 
0a0d				ld a, 0 
0a0d				ld (hl),a 
0a0d				ld de, scratch 
0a0d				ld a,display_row_1 
0a0d				call str_at_display 
0a0d				call update_display 
0a0d			 
0a0d					ld hl, store_page 
0a0d					ld (os_cur_ptr),hl 
0a0d			 
0a0d					ret 
0a0d			endif 
0a0d			 
0a0d			 
0a0d			; Clear out the main buffer store (used to remove junk before writing a new block) 
0a0d			 
0a0d			storage_clear_page: 
0a0d e5				push hl 
0a0e d5				push de 
0a0f c5				push bc 
0a10 21 62 f8			ld hl, store_page 
0a13 3e 00			ld a, 0 
0a15 77				ld (hl), a 
0a16			 
0a16 11 63 f8			ld de, store_page+1 
0a19 01 40 00			ld bc, STORE_BLOCK_PHY 
0a1c			 
0a1c ed b0			ldir 
0a1e				 
0a1e c1				pop bc 
0a1f d1				pop de 
0a20 e1				pop hl 
0a21 c9				ret 
0a22			 
0a22			; eof 
# End of file firmware_storage.asm
0a22			  
0a22			; support routines for above hardware abstraction layer  
0a22			  
0a22			include "firmware_general.asm"        ; general support functions  
0a22			 
0a22			 
0a22			 
0a22			; Delay loops 
0a22			 
0a22			 
0a22			 
0a22			aDelayInMS: 
0a22 c5				push bc 
0a23 47				ld b,a 
0a24			msdelay: 
0a24 c5				push bc 
0a25				 
0a25			 
0a25 01 41 00			ld bc,041h 
0a28 cd 40 0a			call delayloop 
0a2b c1				pop bc 
0a2c 05				dec b 
0a2d 20 f5			jr nz,msdelay 
0a2f			 
0a2f			;if CPU_CLOCK_8MHZ 
0a2f			;msdelay8: 
0a2f			;	push bc 
0a2f			;	 
0a2f			; 
0a2f			;	ld bc,041h 
0a2f			;	call delayloop 
0a2f			;	pop bc 
0a2f			;	dec b 
0a2f			;	jr nz,msdelay8 
0a2f			;endif 
0a2f			 
0a2f			 
0a2f c1				pop bc 
0a30 c9				ret 
0a31			 
0a31			 
0a31			delay250ms: 
0a31				;push de 
0a31 01 00 40			ld bc, 04000h 
0a34 c3 40 0a			jp delayloop 
0a37			delay500ms: 
0a37				;push de 
0a37 01 00 80			ld bc, 08000h 
0a3a c3 40 0a			jp delayloop 
0a3d			delay1s: 
0a3d				;push bc 
0a3d			   ; Clobbers A, d and e 
0a3d 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0a40			delayloop: 
0a40 c5			    push bc 
0a41			 
0a41			if BASE_CPM 
0a41				ld bc, CPM_DELAY_TUNE 
0a41			.cpmloop: 
0a41				push bc 
0a41			 
0a41			endif 
0a41			 
0a41			 
0a41			 
0a41			delayloopi: 
0a41			;	push bc 
0a41			;.dl: 
0a41 cb 47		    bit     0,a    	; 8 
0a43 cb 47		    bit     0,a    	; 8 
0a45 cb 47		    bit     0,a    	; 8 
0a47 e6 ff		    and     255  	; 7 
0a49 0b			    dec     bc      	; 6 
0a4a 79			    ld      a,c     	; 4 
0a4b b0			    or      b     	; 4 
0a4c c2 41 0a		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0a4f			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0a4f				;pop de 
0a4f			;pop bc 
0a4f			 
0a4f			if BASE_CPM 
0a4f				pop bc 
0a4f				 
0a4f			    dec     bc      	; 6 
0a4f			    ld      a,c     	; 4 
0a4f			    or      b     	; 4 
0a4f			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0a4f				 
0a4f			 
0a4f			endif 
0a4f			;if CPU_CLOCK_8MHZ 
0a4f			;    pop bc 
0a4f			;    push bc 
0a4f			;.dl8: 
0a4f			;    bit     0,a    	; 8 
0a4f			;    bit     0,a    	; 8 
0a4f			;    bit     0,a    	; 8 
0a4f			;    and     255  	; 7 
0a4f			;    dec     bc      	; 6 
0a4f			;    ld      a,c     	; 4 
0a4f			;    or      b     	; 4 
0a4f			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0a4f			;endif 
0a4f			 
0a4f			;if CPU_CLOCK_10MHZ 
0a4f			;    pop bc 
0a4f			;    push bc 
0a4f			;.dl8: 
0a4f			;    bit     0,a    	; 8 
0a4f			;    bit     0,a    	; 8 
0a4f			;    bit     0,a    	; 8 
0a4f			;    and     255  	; 7 
0a4f			;    dec     bc      	; 6 
0a4f			;    ld      a,c     	; 4 
0a4f			;    or      b     	; 4 
0a4f			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0a4f			;endif 
0a4f c1			    pop bc 
0a50			 
0a50 c9				ret 
0a51			 
0a51			 
0a51			 
0a51			; eof 
# End of file firmware_general.asm
0a51			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0a51			; display routines that use the physical hardware abstraction layer 
0a51			 
0a51			 
0a51			; TODO windowing? 
0a51			 
0a51			; TODO scroll line up 
0a51			 
0a51			scroll_up: 
0a51			 
0a51 e5				push hl 
0a52 d5				push de 
0a53 c5				push bc 
0a54			 
0a54				; get frame buffer  
0a54			 
0a54 2a d8 f8			ld hl, (display_fb_active) 
0a57 e5				push hl    ; future de destination 
0a58			 
0a58 11 28 00			ld  de, display_cols 
0a5b 19				add hl, de 
0a5c			 
0a5c d1				pop de 
0a5d			 
0a5d				;ex de, hl 
0a5d 01 9f 00			ld bc, display_fb_len -1  
0a60			;if DEBUG_FORTH_WORDS 
0a60			;	DMARK "SCL" 
0a60			;	CALLMONITOR 
0a60			;endif	 
0a60 ed b0			ldir 
0a62			 
0a62				; wipe bottom row 
0a62			 
0a62			 
0a62 2a d8 f8			ld hl, (display_fb_active) 
0a65 11 a0 00			ld de, display_cols*display_rows 
0a68 19				add hl, de 
0a69 06 28			ld b, display_cols 
0a6b 3e 20			ld a, ' ' 
0a6d			.scwipe: 
0a6d 77				ld (hl), a 
0a6e 2b				dec hl 
0a6f 10 fc			djnz .scwipe 
0a71			 
0a71				;pop hl 
0a71			 
0a71 c1				pop bc 
0a72 d1				pop de 
0a73 e1				pop hl 
0a74			 
0a74 c9				ret 
0a75			 
0a75			 
0a75			scroll_upo: 
0a75 11 00 00			ld de, display_row_1 
0a78 21 28 00		 	ld hl, display_row_2 
0a7b 01 28 00			ld bc, display_cols 
0a7e ed b0			ldir 
0a80 11 28 00			ld de, display_row_2 
0a83 21 50 00		 	ld hl, display_row_3 
0a86 01 28 00			ld bc, display_cols 
0a89 ed b0			ldir 
0a8b 11 50 00			ld de, display_row_3 
0a8e 21 78 00		 	ld hl, display_row_4 
0a91 01 28 00			ld bc, display_cols 
0a94 ed b0			ldir 
0a96			 
0a96			; TODO clear row 4 
0a96			 
0a96 c9				ret 
0a97				 
0a97			scroll_down: 
0a97 11 78 00			ld de, display_row_4 
0a9a 21 50 00		 	ld hl, display_row_3 
0a9d 01 28 00			ld bc, display_cols 
0aa0 ed b0			ldir 
0aa2 11 50 00			ld de, display_row_3 
0aa5 21 28 00		 	ld hl, display_row_2 
0aa8 01 28 00			ld bc, display_cols 
0aab ed b0			ldir 
0aad 11 28 00			ld de, display_row_2 
0ab0 21 00 00		 	ld hl, display_row_1 
0ab3 01 28 00			ld bc, display_cols 
0ab6 ed b0			ldir 
0ab8			; TODO clear row 1 
0ab8 c9				ret 
0ab9			 
0ab9			 
0ab9			 
0ab9			 
0ab9			 
0ab9			; clear active frame buffer 
0ab9			 
0ab9			clear_display: 
0ab9 3e 20			ld a, ' ' 
0abb c3 be 0a			jp fill_display 
0abe			 
0abe			; fill active frame buffer with a char in A 
0abe			 
0abe			fill_display: 
0abe 06 a0			ld b,display_fb_len 
0ac0 2a d8 f8			ld hl, (display_fb_active) 
0ac3 77			.fd1:	ld (hl),a 
0ac4 23				inc hl 
0ac5 10 fc			djnz .fd1 
0ac7 23				inc hl 
0ac8 3e 00			ld a,0 
0aca 77				ld (hl),a 
0acb			 
0acb			 
0acb c9				ret 
0acc			; Write string (DE) at pos (A) to active frame buffer 
0acc			 
0acc 2a d8 f8		str_at_display:    ld hl,(display_fb_active) 
0acf 06 00					ld b,0 
0ad1 4f					ld c,a 
0ad2 09					add hl,bc 
0ad3 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0ad4 b7			            OR   A              ;Null terminator? 
0ad5 c8			            RET  Z              ;Yes, so finished 
0ad6 77					ld (hl),a 
0ad7 23				inc hl 
0ad8 13			            INC  DE             ;Point to next character 
0ad9 18 f8		            JR   .sad1     ;Repeat 
0adb c9					ret 
0adc			 
0adc			; using current frame buffer write to physical display 
0adc			 
0adc			update_display: 
0adc e5				push hl 
0add 2a d8 f8			ld hl, (display_fb_active) 
0ae0 cd 19 60			call write_display 
0ae3 e1				pop hl 
0ae4 c9				ret 
0ae5			 
0ae5			; TODO scrolling 
0ae5			 
0ae5			 
0ae5			; move cursor right one char 
0ae5			cursor_right: 
0ae5			 
0ae5				; TODO shift right 
0ae5				; TODO if beyond max col 
0ae5				; TODO       cursor_next_line 
0ae5			 
0ae5 c9				ret 
0ae6			 
0ae6			 
0ae6			cursor_next_line: 
0ae6				; TODO first char 
0ae6				; TODO line down 
0ae6				; TODO if past last row 
0ae6				; TODO    scroll up 
0ae6			 
0ae6 c9				ret 
0ae7			 
0ae7			cursor_left: 
0ae7				; TODO shift left 
0ae7				; TODO if beyond left  
0ae7				; TODO     cursor prev line 
0ae7				 
0ae7 c9				ret 
0ae8			 
0ae8			cursor_prev_line: 
0ae8				; TODO last char 
0ae8				; TODO line up 
0ae8				; TODO if past first row 
0ae8				; TODO   scroll down 
0ae8			 
0ae8 c9				ret 
0ae9			 
0ae9			 
0ae9			cout: 
0ae9				; A - char 
0ae9 c9				ret 
0aea			 
0aea			; eof 
0aea			 
# End of file firmware_display.asm
0aea			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0aea			; random number generators 
0aea			 
0aea			 
0aea			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0aea			 
0aea			 
0aea			;-----> Generate a random number 
0aea			; output a=answer 0<=a<=255 
0aea			; all registers are preserved except: af 
0aea			random: 
0aea e5			        push    hl 
0aeb d5			        push    de 
0aec 2a ba f8		        ld      hl,(randData) 
0aef ed 5f		        ld      a,r 
0af1 57			        ld      d,a 
0af2 5e			        ld      e,(hl) 
0af3 19			        add     hl,de 
0af4 85			        add     a,l 
0af5 ac			        xor     h 
0af6 22 ba f8		        ld      (randData),hl 
0af9 d1			        pop     de 
0afa e1			        pop     hl 
0afb c9			        ret 
0afc			 
0afc			 
0afc			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0afc			 
0afc			 
0afc			 
0afc			;------LFSR------ 
0afc			;James Montelongo 
0afc			;optimized by Spencer Putt 
0afc			;out: 
0afc			; a = 8 bit random number 
0afc			RandLFSR: 
0afc 21 c0 f8		        ld hl,LFSRSeed+4 
0aff 5e			        ld e,(hl) 
0b00 23			        inc hl 
0b01 56			        ld d,(hl) 
0b02 23			        inc hl 
0b03 4e			        ld c,(hl) 
0b04 23			        inc hl 
0b05 7e			        ld a,(hl) 
0b06 47			        ld b,a 
0b07 cb 13		        rl e  
0b09 cb 12			rl d 
0b0b cb 11		        rl c  
0b0d 17				rla 
0b0e cb 13		        rl e  
0b10 cb 12			rl d 
0b12 cb 11		        rl c  
0b14 17				rla 
0b15 cb 13		        rl e  
0b17 cb 12			rl d 
0b19 cb 11		        rl c  
0b1b 17				rla 
0b1c 67			        ld h,a 
0b1d cb 13		        rl e  
0b1f cb 12			rl d 
0b21 cb 11		        rl c  
0b23 17				rla 
0b24 a8			        xor b 
0b25 cb 13		        rl e  
0b27 cb 12			rl d 
0b29 ac			        xor h 
0b2a a9			        xor c 
0b2b aa			        xor d 
0b2c 21 c2 f8		        ld hl,LFSRSeed+6 
0b2f 11 c3 f8		        ld de,LFSRSeed+7 
0b32 01 07 00		        ld bc,7 
0b35 ed b8		        lddr 
0b37 12			        ld (de),a 
0b38 c9			        ret 
0b39			 
0b39			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0b39			 
0b39			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0b39			 
0b39			 
0b39			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0b39			 
0b39			prng16: 
0b39			;Inputs: 
0b39			;   (seed1) contains a 16-bit seed value 
0b39			;   (seed2) contains a NON-ZERO 16-bit seed value 
0b39			;Outputs: 
0b39			;   HL is the result 
0b39			;   BC is the result of the LCG, so not that great of quality 
0b39			;   DE is preserved 
0b39			;Destroys: 
0b39			;   AF 
0b39			;cycle: 4,294,901,760 (almost 4.3 billion) 
0b39			;160cc 
0b39			;26 bytes 
0b39 2a b4 f8		    ld hl,(seed1) 
0b3c 44			    ld b,h 
0b3d 4d			    ld c,l 
0b3e 29			    add hl,hl 
0b3f 29			    add hl,hl 
0b40 2c			    inc l 
0b41 09			    add hl,bc 
0b42 22 b4 f8		    ld (seed1),hl 
0b45 2a b2 f8		    ld hl,(seed2) 
0b48 29			    add hl,hl 
0b49 9f			    sbc a,a 
0b4a e6 2d		    and %00101101 
0b4c ad			    xor l 
0b4d 6f			    ld l,a 
0b4e 22 b2 f8		    ld (seed2),hl 
0b51 09			    add hl,bc 
0b52 c9			    ret 
0b53			 
0b53			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0b53			 
0b53			rand32: 
0b53			;Inputs: 
0b53			;   (seed1_0) holds the lower 16 bits of the first seed 
0b53			;   (seed1_1) holds the upper 16 bits of the first seed 
0b53			;   (seed2_0) holds the lower 16 bits of the second seed 
0b53			;   (seed2_1) holds the upper 16 bits of the second seed 
0b53			;   **NOTE: seed2 must be non-zero 
0b53			;Outputs: 
0b53			;   HL is the result 
0b53			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0b53			;Destroys: 
0b53			;   AF 
0b53			;Tested and passes all CAcert tests 
0b53			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0b53			;it has a period of 18,446,744,069,414,584,320 
0b53			;roughly 18.4 quintillion. 
0b53			;LFSR taps: 0,2,6,7  = 11000101 
0b53			;291cc 
0b53			;seed1_0=$+1 
0b53			;    ld hl,12345 
0b53			;seed1_1=$+1 
0b53			;    ld de,6789 
0b53			;    ld b,h 
0b53			;    ld c,l 
0b53			;    add hl,hl \ rl e \ rl d 
0b53			;    add hl,hl \ rl e \ rl d 
0b53			;    inc l 
0b53			;    add hl,bc 
0b53			;    ld (seed1_0),hl 
0b53			;    ld hl,(seed1_1) 
0b53			;    adc hl,de 
0b53			;    ld (seed1_1),hl 
0b53			;    ex de,hl 
0b53			;seed2_0=$+1 
0b53			;    ld hl,9876 
0b53			;seed2_1=$+1 
0b53			;    ld bc,54321 
0b53			;    add hl,hl \ rl c \ rl b 
0b53			;    ld (seed2_1),bc 
0b53			;    sbc a,a 
0b53			;    and %11000101 
0b53			;    xor l 
0b53			;    ld l,a 
0b53			;    ld (seed2_0),hl 
0b53			;    ex de,hl 
0b53			;    add hl,bc 
0b53			;    ret 
0b53			; 
0b53			 
0b53			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0b53			; 20 bytes, 86 cycles (excluding ret) 
0b53			 
0b53			; returns   hl = pseudorandom number 
0b53			; corrupts   a 
0b53			 
0b53			; generates 16-bit pseudorandom numbers with a period of 65535 
0b53			; using the xorshift method: 
0b53			 
0b53			; hl ^= hl << 7 
0b53			; hl ^= hl >> 9 
0b53			; hl ^= hl << 8 
0b53			 
0b53			; some alternative shift triplets which also perform well are: 
0b53			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0b53			 
0b53			;  org 32768 
0b53			 
0b53			xrnd: 
0b53 2a b8 f8		  ld hl,(xrandc)       ; seed must not be 0 
0b56 3e 00		  ld a,0 
0b58 bd			  cp l 
0b59 20 02		  jr nz, .xrnd1 
0b5b 2e 01		  ld l, 1 
0b5d			.xrnd1: 
0b5d			 
0b5d 7c			  ld a,h 
0b5e 1f			  rra 
0b5f 7d			  ld a,l 
0b60 1f			  rra 
0b61 ac			  xor h 
0b62 67			  ld h,a 
0b63 7d			  ld a,l 
0b64 1f			  rra 
0b65 7c			  ld a,h 
0b66 1f			  rra 
0b67 ad			  xor l 
0b68 6f			  ld l,a 
0b69 ac			  xor h 
0b6a 67			  ld h,a 
0b6b			 
0b6b 22 b8 f8		  ld (xrandc),hl 
0b6e			 
0b6e c9			  ret 
0b6f			;  
0b6f			 
0b6f			 
0b6f			;;;; int maths 
0b6f			 
0b6f			; https://map.grauw.nl/articles/mult_div_shifts.php 
0b6f			; Divide 16-bit values (with 16-bit result) 
0b6f			; In: Divide BC by divider DE 
0b6f			; Out: BC = result, HL = rest 
0b6f			; 
0b6f			Div16: 
0b6f 21 00 00		    ld hl,0 
0b72 78			    ld a,b 
0b73 06 08		    ld b,8 
0b75			Div16_Loop1: 
0b75 17			    rla 
0b76 ed 6a		    adc hl,hl 
0b78 ed 52		    sbc hl,de 
0b7a 30 01		    jr nc,Div16_NoAdd1 
0b7c 19			    add hl,de 
0b7d			Div16_NoAdd1: 
0b7d 10 f6		    djnz Div16_Loop1 
0b7f 17			    rla 
0b80 2f			    cpl 
0b81 47			    ld b,a 
0b82 79			    ld a,c 
0b83 48			    ld c,b 
0b84 06 08		    ld b,8 
0b86			Div16_Loop2: 
0b86 17			    rla 
0b87 ed 6a		    adc hl,hl 
0b89 ed 52		    sbc hl,de 
0b8b 30 01		    jr nc,Div16_NoAdd2 
0b8d 19			    add hl,de 
0b8e			Div16_NoAdd2: 
0b8e 10 f6		    djnz Div16_Loop2 
0b90 17			    rla 
0b91 2f			    cpl 
0b92 41			    ld b,c 
0b93 4f			    ld c,a 
0b94 c9			ret 
0b95			 
0b95			 
0b95			;http://z80-heaven.wikidot.com/math 
0b95			; 
0b95			;Inputs: 
0b95			;     DE and A are factors 
0b95			;Outputs: 
0b95			;     A is not changed 
0b95			;     B is 0 
0b95			;     C is not changed 
0b95			;     DE is not changed 
0b95			;     HL is the product 
0b95			;Time: 
0b95			;     342+6x 
0b95			; 
0b95			Mult16: 
0b95			 
0b95 06 08		     ld b,8          ;7           7 
0b97 21 00 00		     ld hl,0         ;10         10 
0b9a 29			       add hl,hl     ;11*8       88 
0b9b 07			       rlca          ;4*8        32 
0b9c 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0b9e 19			         add hl,de   ;--         -- 
0b9f 10 f9		       djnz $-5      ;13*7+8     99 
0ba1 c9			ret 
0ba2			 
0ba2			; 
0ba2			; Square root of 16-bit value 
0ba2			; In:  HL = value 
0ba2			; Out:  D = result (rounded down) 
0ba2			; 
0ba2			;Sqr16: 
0ba2			;    ld de,#0040 
0ba2			;    ld a,l 
0ba2			;    ld l,h 
0ba2			;    ld h,d 
0ba2			;    or a 
0ba2			;    ld b,8 
0ba2			;Sqr16_Loop: 
0ba2			;    sbc hl,de 
0ba2			;    jr nc,Sqr16_Skip 
0ba2			;    add hl,de 
0ba2			;Sqr16_Skip: 
0ba2			;    ccf 
0ba2			;    rl d 
0ba2			;    add a,a 
0ba2			;    adc hl,hl 
0ba2			;    add a,a 
0ba2			;    adc hl,hl 
0ba2			;    djnz Sqr16_Loop 
0ba2			;    ret 
0ba2			; 
0ba2			; 
0ba2			; Divide 8-bit values 
0ba2			; In: Divide E by divider C 
0ba2			; Out: A = result, B = rest 
0ba2			; 
0ba2			Div8: 
0ba2 af			    xor a 
0ba3 06 08		    ld b,8 
0ba5			Div8_Loop: 
0ba5 cb 13		    rl e 
0ba7 17			    rla 
0ba8 91			    sub c 
0ba9 30 01		    jr nc,Div8_NoAdd 
0bab 81			    add a,c 
0bac			Div8_NoAdd: 
0bac 10 f7		    djnz Div8_Loop 
0bae 47			    ld b,a 
0baf 7b			    ld a,e 
0bb0 17			    rla 
0bb1 2f			    cpl 
0bb2 c9			    ret 
0bb3			 
0bb3			; 
0bb3			; Multiply 8-bit value with a 16-bit value (unrolled) 
0bb3			; In: Multiply A with DE 
0bb3			; Out: HL = result 
0bb3			; 
0bb3			Mult12U: 
0bb3 2e 00		    ld l,0 
0bb5 87			    add a,a 
0bb6 30 01		    jr nc,Mult12U_NoAdd0 
0bb8 19			    add hl,de 
0bb9			Mult12U_NoAdd0: 
0bb9 29			    add hl,hl 
0bba 87			    add a,a 
0bbb 30 01		    jr nc,Mult12U_NoAdd1 
0bbd 19			    add hl,de 
0bbe			Mult12U_NoAdd1: 
0bbe 29			    add hl,hl 
0bbf 87			    add a,a 
0bc0 30 01		    jr nc,Mult12U_NoAdd2 
0bc2 19			    add hl,de 
0bc3			Mult12U_NoAdd2: 
0bc3 29			    add hl,hl 
0bc4 87			    add a,a 
0bc5 30 01		    jr nc,Mult12U_NoAdd3 
0bc7 19			    add hl,de 
0bc8			Mult12U_NoAdd3: 
0bc8 29			    add hl,hl 
0bc9 87			    add a,a 
0bca 30 01		    jr nc,Mult12U_NoAdd4 
0bcc 19			    add hl,de 
0bcd			Mult12U_NoAdd4: 
0bcd 29			    add hl,hl 
0bce 87			    add a,a 
0bcf 30 01		    jr nc,Mult12U_NoAdd5 
0bd1 19			    add hl,de 
0bd2			Mult12U_NoAdd5: 
0bd2 29			    add hl,hl 
0bd3 87			    add a,a 
0bd4 30 01		    jr nc,Mult12U_NoAdd6 
0bd6 19			    add hl,de 
0bd7			Mult12U_NoAdd6: 
0bd7 29			    add hl,hl 
0bd8 87			    add a,a 
0bd9 d0			    ret nc 
0bda 19			    add hl,de 
0bdb c9			    ret 
0bdc			 
0bdc			; 
0bdc			; Multiply 8-bit value with a 16-bit value (right rotating) 
0bdc			; In: Multiply A with DE 
0bdc			;      Put lowest value in A for most efficient calculation 
0bdc			; Out: HL = result 
0bdc			; 
0bdc			Mult12R: 
0bdc 21 00 00		    ld hl,0 
0bdf			Mult12R_Loop: 
0bdf cb 3f		    srl a 
0be1 30 01		    jr nc,Mult12R_NoAdd 
0be3 19			    add hl,de 
0be4			Mult12R_NoAdd: 
0be4 cb 23		    sla e 
0be6 cb 12		    rl d 
0be8 b7			    or a 
0be9 c2 df 0b		    jp nz,Mult12R_Loop 
0bec c9			    ret 
0bed			 
0bed			; 
0bed			; Multiply 16-bit values (with 32-bit result) 
0bed			; In: Multiply BC with DE 
0bed			; Out: BCHL = result 
0bed			; 
0bed			Mult32: 
0bed 79			    ld a,c 
0bee 48			    ld c,b 
0bef 21 00 00		    ld hl,0 
0bf2 06 10		    ld b,16 
0bf4			Mult32_Loop: 
0bf4 29			    add hl,hl 
0bf5 17			    rla 
0bf6 cb 11		    rl c 
0bf8 30 07		    jr nc,Mult32_NoAdd 
0bfa 19			    add hl,de 
0bfb ce 00		    adc a,0 
0bfd d2 01 0c		    jp nc,Mult32_NoAdd 
0c00 0c			    inc c 
0c01			Mult32_NoAdd: 
0c01 10 f1		    djnz Mult32_Loop 
0c03 41			    ld b,c 
0c04 4f			    ld c,a 
0c05 c9			    ret 
0c06			 
0c06			 
0c06			 
0c06			; 
0c06			; Multiply 8-bit values 
0c06			; In:  Multiply H with E 
0c06			; Out: HL = result 
0c06			; 
0c06			Mult8: 
0c06 16 00		    ld d,0 
0c08 6a			    ld l,d 
0c09 06 08		    ld b,8 
0c0b			Mult8_Loop: 
0c0b 29			    add hl,hl 
0c0c 30 01		    jr nc,Mult8_NoAdd 
0c0e 19			    add hl,de 
0c0f			Mult8_NoAdd: 
0c0f 10 fa		    djnz Mult8_Loop 
0c11 c9			    ret 
0c12			 
0c12			 
0c12			 
0c12			 
0c12			 
0c12			 
0c12			 
0c12			 
0c12			;;http://z80-heaven.wikidot.com/math 
0c12			;;This divides DE by BC, storing the result in DE, remainder in HL 
0c12			; 
0c12			;DE_Div_BC:          ;1281-2x, x is at most 16 
0c12			;     ld a,16        ;7 
0c12			;     ld hl,0        ;10 
0c12			;     jp $+5         ;10 
0c12			;.DivLoop: 
0c12			;       add hl,bc    ;-- 
0c12			;       dec a        ;64 
0c12			;       jr z,.DivLoopEnd        ;86 
0c12			; 
0c12			;       sla e        ;128 
0c12			;       rl d         ;128 
0c12			;       adc hl,hl    ;240 
0c12			;       sbc hl,bc    ;240 
0c12			;       jr nc,.DivLoop ;23|21 
0c12			;       inc e        ;-- 
0c12			;       jp .DivLoop+1 
0c12			; 
0c12			;.DivLoopEnd: 
0c12			 
0c12			;HL_Div_C: 
0c12			;Inputs: 
0c12			;     HL is the numerator 
0c12			;     C is the denominator 
0c12			;Outputs: 
0c12			;     A is the remainder 
0c12			;     B is 0 
0c12			;     C is not changed 
0c12			;     DE is not changed 
0c12			;     HL is the quotient 
0c12			; 
0c12			;       ld b,16 
0c12			;       xor a 
0c12			;         add hl,hl 
0c12			;         rla 
0c12			;         cp c 
0c12			;         jr c,$+4 
0c12			;           inc l 
0c12			;           sub c 
0c12			;         djnz $-7 
0c12			 
0c12			; https://plutiedev.com/z80-add-8bit-to-16bit 
0c12			 
0c12			addatohl: 
0c12 85			    add   a, l    ; A = A+L 
0c13 6f			    ld    l, a    ; L = A+L 
0c14 8c			    adc   a, h    ; A = A+L+H+carry 
0c15 95			    sub   l       ; A = H+carry 
0c16 67			    ld    h, a    ; H = H+carry 
0c17 c9			ret 
0c18			 
0c18			addatode: 
0c18 83			    add   a, e    ; A = A+L 
0c19 5f			    ld    e, a    ; L = A+L 
0c1a 8a			    adc   a, d    ; A = A+L+H+carry 
0c1b 93			    sub   e       ; A = H+carry 
0c1c 57			    ld    d, a    ; H = H+carry 
0c1d c9			ret 
0c1e			 
0c1e			 
0c1e			addatobc: 
0c1e 81			    add   a, c    ; A = A+L 
0c1f 4f			    ld    c, a    ; L = A+L 
0c20 88			    adc   a, b    ; A = A+L+H+carry 
0c21 91			    sub   c       ; A = H+carry 
0c22 47			    ld    b, a    ; H = H+carry 
0c23 c9			ret 
0c24			 
0c24			subafromhl: 
0c24			   ; If A=0 do nothing 
0c24			    ; Otherwise flip A's sign. Since 
0c24			    ; the upper byte becomes -1, also 
0c24			    ; substract 1 from H. 
0c24 ed 44		    neg 
0c26 ca 2f 0c		    jp    z, Skip 
0c29 25			    dec   h 
0c2a			     
0c2a			    ; Now add the low byte as usual 
0c2a			    ; Two's complement takes care of 
0c2a			    ; ensuring the result is correct 
0c2a 85			    add   a, l 
0c2b 6f			    ld    l, a 
0c2c 8c			    adc   a, h 
0c2d 95			    sub   l 
0c2e 67			    ld    h, a 
0c2f			Skip: 
0c2f c9				ret 
0c30			 
0c30			 
0c30			; compare hl and de 
0c30			; returns:  
0c30			; if hl = de, z=1, s=0, c0=0 
0c30			; if hl > de, z=0, s=0, c=0 
0c30			; if hl < de, z=0, s=1, c=1 
0c30			cmp16:	 
0c30 b7				or a 
0c31 ed 52			sbc hl,de 
0c33 e0				ret po 
0c34 7c				ld a,h 
0c35 1f				rra 
0c36 ee 40			xor 01000000B 
0c38 37				scf 
0c39 8f				adc a,a 
0c3a c9				ret 
0c3b			 
0c3b			 
0c3b			; test if hl contains zero   - A is destroyed 
0c3b			 
0c3b			ishlzero:    
0c3b b7				or a     ; reset flags 
0c3c 7c				ld a, h 
0c3d b5				or l        	 
0c3e			 
0c3e c9				ret 
0c3f			 
0c3f			 
0c3f			 
0c3f			 
0c3f			if FORTH_ENABLE_FLOATMATH 
0c3f			;include "float/bbcmath.z80" 
0c3f			include "float/lpfpcalc.asm" 
0c3f			endif 
0c3f			 
0c3f			 
0c3f			; eof 
0c3f			 
# End of file firmware_maths.asm
0c3f			include "firmware_strings.asm"   ; string handling  
0c3f			 
0c3f			 
0c3f			; TODO string len 
0c3f			; input text string, end on cr with zero term 
0c3f			; a offset into frame buffer to start prompt 
0c3f			; d is max length 
0c3f			; e is display size TODO 
0c3f			; c is current cursor position 
0c3f			; hl is ptr to where string will be stored 
0c3f			 
0c3f			 
0c3f			; TODO check limit of buffer for new inserts 
0c3f			; TODO check insert does not push beyond buffer 
0c3f			; TODO scroll in a limited display area 
0c3f			; TODO scroll whole screen on page wrap 
0c3f			 
0c3f			 
0c3f			; TODO handle KEY_PREVWORD 
0c3f			; TODO handle KEY_NEXTWORD 
0c3f			; TODO handle KEY_HOME 
0c3f			; TODO handle KEY_END 
0c3f			; TODO use LCD cursor? 
0c3f			 
0c3f 32 70 fb		input_str:    	ld (input_at_pos),a      ; save display position to start 
0c42 81					add c 
0c43 32 6e fb				ld (input_at_cursor),a	; save draw pos of cursor 
0c46 22 73 fb				ld (input_start), hl     ; save ptr to buffer 
0c49 79					ld a, c 
0c4a cd 12 0c				call addatohl 
0c4d 22 75 fb				ld (input_ptr), hl     ; save ptr to point under the cursor 
0c50 7a					ld a,d 
0c51 32 72 fb			        ld (input_size), a       ; save length of input area 
0c54 79					ld a, c 
0c55 32 61 fb				ld (input_cursor),a      ; init cursor start position  
0c58 7b					ld a,e 
0c59 32 71 fb			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0c5c					 
0c5c					 
0c5c			 
0c5c			;		ld a,(input_ptr) 
0c5c			;		ld (input_under_cursor),a 	; save what is under the cursor 
0c5c			 
0c5c			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0c5c					; init cursor shape if not set by the cin routines 
0c5c 21 d0 f8				ld hl, cursor_shape 
0c5f 3e ff				ld a, 255 
0c61 77					ld (hl), a 
0c62 23					inc hl 
0c63 3e 00				ld a, 0 
0c65 77					ld (hl), a 
0c66			 
0c66 3e 0f				ld a, CUR_BLINK_RATE 
0c68 32 6c fb				ld (input_cur_flash), a 
0c6b 3e 01				ld a, 1 
0c6d 32 6b fb				ld (input_cur_onoff),a 
0c70			 
0c70			;	if DEBUG_INPUT 
0c70			;		push af 
0c70			;		ld a, 'I' 
0c70			;		ld (debug_mark),a 
0c70			;		pop af 
0c70			;		CALLMONITOR 
0c70			;	endif 
0c70			.is1:		; main entry loop 
0c70			 
0c70			 
0c70			 
0c70					; pause 1ms 
0c70			 
0c70 3e 01				ld a, 1 
0c72 cd 22 0a				call aDelayInMS 
0c75			 
0c75					; dec flash counter 
0c75 3a 6c fb				ld a, (input_cur_flash) 
0c78 3d					dec a 
0c79 32 6c fb				ld (input_cur_flash), a 
0c7c fe 00				cp 0 
0c7e 20 0d				jr nz, .nochgstate 
0c80			 
0c80			 
0c80					; change state 
0c80 3a 6b fb				ld a,(input_cur_onoff) 
0c83 ed 44				neg 
0c85 32 6b fb				ld (input_cur_onoff),a 
0c88			 
0c88			 
0c88					; reset on change of state 
0c88 3e 0f				ld a, CUR_BLINK_RATE 
0c8a 32 6c fb				ld (input_cur_flash), a 
0c8d			 
0c8d			.nochgstate: 
0c8d					 
0c8d					 
0c8d			 
0c8d					; display cursor  
0c8d			 
0c8d			;		ld hl, (input_start) 
0c8d			;		ld a, (input_cursor) 
0c8d			;		call addatohl 
0c8d			 
0c8d					; get char under cursor and replace with cursor 
0c8d 2a 75 fb		ld hl, (input_ptr) 
0c90			;		ld a, (hl) 
0c90			;		ld (input_under_cursor),a 
0c90			;		ld a, '_' 
0c90			;		ld (hl), a 
0c90			 
0c90					; display string 
0c90			 
0c90 ed 5b 73 fb			ld de, (input_start) 
0c94 3a 70 fb				ld a, (input_at_pos) 
0c97 cd cc 0a				call str_at_display 
0c9a			;	        call update_display 
0c9a			 
0c9a					; find place to put the cursor 
0c9a			;		add h 
0c9a			;		ld l, display_row_1 
0c9a			;		sub l 
0c9a			; (input_at_pos) 
0c9a					;ld c, a 
0c9a			;		ld a, (input_cursor) 
0c9a			;		ld l, (input_at_pos) 
0c9a			;		;ld b, h 
0c9a			;		add l 
0c9a			;		ld (input_at_cursor),a 
0c9a					;ld l,h 
0c9a			 
0c9a			;		ld h, 0 
0c9a			;		ld l,(input_at_pos) 
0c9a			;		ld a, (input_cursor) 
0c9a			;		call addatohl 
0c9a			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0c9a			;		call subafromhl 
0c9a			;		ld a,l 
0c9a			;		ld (input_at_cursor), a 
0c9a			 
0c9a				if DEBUG_INPUT 
0c9a					ld a, (hardware_diag) 
0c9a					cp 0 
0c9a					jr z, .skip_input_diag 
0c9a			 
0c9a					ld a,(input_at_pos) 
0c9a					ld hl, LFSRSeed 
0c9a					call hexout 
0c9a					ld a, (input_cursor) 
0c9a					ld hl, LFSRSeed+2 
0c9a					call hexout 
0c9a					ld a,(input_at_cursor) 
0c9a					ld hl, LFSRSeed+4 
0c9a					call hexout 
0c9a			 
0c9a					ld a,(input_cur_onoff) 
0c9a					ld hl, LFSRSeed+6 
0c9a					call hexout 
0c9a			 
0c9a					ld a,(input_cur_flash) 
0c9a					ld hl, LFSRSeed+8 
0c9a					call hexout 
0c9a			 
0c9a					ld a,(input_len) 
0c9a					ld hl, LFSRSeed+10 
0c9a					call hexout 
0c9a					ld hl, LFSRSeed+12 
0c9a					ld a, 0 
0c9a					ld (hl),a 
0c9a					ld a, display_row_4 
0c9a					ld de, LFSRSeed 
0c9a					call str_at_display 
0c9a					.skip_input_diag: 
0c9a				endif 
0c9a			 
0c9a					; decide on if we are showing the cursor this time round 
0c9a			 
0c9a 3a 6b fb				ld a, (input_cur_onoff) 
0c9d fe ff				cp 255 
0c9f 28 13				jr z, .skipcur 
0ca1			 
0ca1			 
0ca1 3a 6e fb				ld a,(input_at_cursor) 
0ca4 11 d0 f8				ld de, cursor_shape 
0ca7 cd cc 0a				call str_at_display 
0caa			 
0caa					; save length of current input string 
0caa 2a 73 fb				ld hl, (input_start) 
0cad cd 70 10				call strlenz 
0cb0 7d					ld a,l 
0cb1 32 66 fb				ld (input_len),a 
0cb4			 
0cb4			.skipcur: 
0cb4			 
0cb4 cd dc 0a			        call update_display 
0cb7					 
0cb7			 
0cb7			 
0cb7					; wait 
0cb7				 
0cb7					; TODO loop without wait to flash the cursor and char under cursor	 
0cb7 cd 64 63				call cin    ; _wait 
0cba			 
0cba fe 00				cp 0 
0cbc ca 70 0c				jp z, .is1 
0cbf			 
0cbf					; get ptr to char to input into 
0cbf			 
0cbf 4f					ld c,a 
0cc0 2a 73 fb				ld hl, (input_start) 
0cc3 3a 61 fb				ld a, (input_cursor) 
0cc6 cd 12 0c				call addatohl 
0cc9 22 75 fb				ld (input_ptr), hl 
0ccc 79					ld a,c 
0ccd			 
0ccd					; replace char under cursor 
0ccd			 
0ccd			;		ld hl, (input_ptr) 
0ccd			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0ccd			;		ld (hl), a 
0ccd			 
0ccd			;	if DEBUG_INPUT 
0ccd			;		push af 
0ccd			;		ld a, 'i' 
0ccd			;		ld (debug_mark),a 
0ccd			;		pop af 
0ccd			;		CALLMONITOR 
0ccd			;	endif 
0ccd fe 0e				cp KEY_HOME 
0ccf 20 0e				jr nz, .iske 
0cd1			 
0cd1 3a 70 fb				ld a, (input_at_pos) 
0cd4 32 6e fb				ld (input_at_cursor),a 
0cd7 3e 00				ld a, 0 
0cd9 32 61 fb				ld (input_cursor), a 
0cdc c3 70 0c				jp .is1 
0cdf					 
0cdf fe 0f		.iske:		cp KEY_END 
0ce1 20 03				jr nz, .isknw 
0ce3 c3 70 0c				jp .is1 
0ce6			 
0ce6 fe 06		.isknw:		cp KEY_NEXTWORD 
0ce8 20 1b				jr nz, .iskpw 
0cea			 
0cea 2a 75 fb		.isknwm:	ld hl, (input_ptr) 
0ced 7e					ld a,(hl)	 
0cee fe 00				cp 0 
0cf0 ca 70 0c				jp z, .is1    ; end of string 
0cf3 fe 20				cp ' ' 
0cf5 ca 70 0c				jp z, .is1    ; end of word 
0cf8 23					inc hl 
0cf9 22 75 fb				ld (input_ptr), hl 
0cfc 3a 6e fb				ld a, (input_at_cursor) 
0cff 3c					inc a 
0d00 32 6e fb				ld (input_at_cursor), a 
0d03 18 e5				jr .isknwm 
0d05			 
0d05 fe 07		.iskpw:		cp KEY_PREVWORD 
0d07 20 1b				jr nz, .iskl 
0d09			.iskpwm:	 
0d09 2a 75 fb				ld hl, (input_ptr) 
0d0c 7e					ld a,(hl)	 
0d0d fe 00				cp 0  
0d0f ca 70 0c				jp z, .is1    ; end of string 
0d12 fe 20				cp ' ' 
0d14 ca 70 0c				jp z, .is1    ; end of word 
0d17 2b					dec hl 
0d18 22 75 fb				ld (input_ptr), hl 
0d1b 3a 6e fb				ld a, (input_at_cursor) 
0d1e 3d					dec a 
0d1f 32 6e fb				ld (input_at_cursor), a 
0d22 18 e5				jr .iskpwm 
0d24			 
0d24			 
0d24 fe 0b		.iskl:		cp KEY_LEFT 
0d26 20 27				jr nz, .isk1 
0d28			 
0d28 3a 61 fb				ld a, (input_cursor) 
0d2b			 
0d2b fe 00				cp 0 
0d2d ca 70 0c				jp z, .is1 		; at start of line to ignore  
0d30			 
0d30 3d					dec  a 		; TODO check underflow 
0d31 32 61 fb				ld (input_cursor), a 
0d34			 
0d34 2a 75 fb				ld hl, (input_ptr) 
0d37 2b					dec hl 
0d38 22 75 fb				ld (input_ptr), hl 
0d3b					 
0d3b 3a 6e fb				ld a, (input_at_cursor) 
0d3e 3d					dec a 
0d3f 32 6e fb				ld (input_at_cursor), a 
0d42			 
0d42 3e 01				ld a, 1		; show cursor moving 
0d44 32 6b fb				ld (input_cur_onoff),a 
0d47 3e 0f				ld a, CUR_BLINK_RATE 
0d49 32 6c fb				ld (input_cur_flash), a 
0d4c			 
0d4c c3 70 0c				jp .is1 
0d4f			 
0d4f fe 0c		.isk1:		cp KEY_RIGHT 
0d51 20 2a				jr nz, .isk2 
0d53			 
0d53 3a 66 fb				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0d56 5f					ld e,a 
0d57 3a 61 fb				ld a, (input_cursor) 
0d5a bb					cp e 
0d5b ca 70 0c				jp z, .is1		; at the end of string so dont go right 
0d5e			 
0d5e 3c					inc  a 		; TODO check overflow 
0d5f 32 61 fb				ld (input_cursor), a 
0d62			 
0d62 3a 6e fb				ld a, (input_at_cursor) 
0d65 3c					inc a 
0d66 32 6e fb				ld (input_at_cursor), a 
0d69			 
0d69 2a 75 fb				ld hl, (input_ptr) 
0d6c 23					inc hl 
0d6d 22 75 fb				ld (input_ptr), hl 
0d70			 
0d70 3e 01				ld a, 1		; show cursor moving 
0d72 32 6b fb				ld (input_cur_onoff),a 
0d75 3e 0f				ld a, CUR_BLINK_RATE 
0d77 32 6c fb				ld (input_cur_flash), a 
0d7a			 
0d7a c3 70 0c				jp .is1 
0d7d			 
0d7d fe 05		.isk2:		cp KEY_UP 
0d7f			 
0d7f 20 26				jr nz, .isk3 
0d81			 
0d81					; swap last command with the current on 
0d81			 
0d81					; move cursor to start of string 
0d81 2a 73 fb				ld hl, (input_start) 
0d84 22 75 fb				ld (input_ptr), hl 
0d87			 
0d87 3a 70 fb				ld a, (input_at_pos) 
0d8a 32 6e fb				ld (input_at_cursor), a 
0d8d			 
0d8d 3e 00				ld a, 0 
0d8f 32 61 fb				ld (input_cursor), a 
0d92					 
0d92					; swap input and last command buffers 
0d92			 
0d92 21 59 f1				ld hl, os_cli_cmd 
0d95 11 58 f2				ld de, os_last_cmd 
0d98 06 ff				ld b, 255 
0d9a 7e			.swap1:		ld a, (hl) 
0d9b 4f					ld c,a 
0d9c 1a					ld a, (de) 
0d9d 77					ld (hl), a 
0d9e 79					ld a,c 
0d9f 12					ld (de),a 
0da0 23					inc hl 
0da1 13					inc de 
0da2 10 f6				djnz .swap1 
0da4			 
0da4			 
0da4			 
0da4			 
0da4			 
0da4 c3 70 0c				jp .is1 
0da7			 
0da7 fe 08		.isk3:		cp KEY_BS 
0da9 20 3c				jr nz, .isk4 
0dab			 
0dab 3a 61 fb				ld a, (input_cursor) 
0dae			 
0dae fe 00				cp 0 
0db0 ca 70 0c				jp z, .is1 		; at start of line to ignore  
0db3			 
0db3 3d					dec  a 		; TODO check underflow 
0db4 32 61 fb				ld (input_cursor), a 
0db7			 
0db7					; hl is source 
0db7					; de needs to be source - 1 
0db7			 
0db7			;		ld a, 0 
0db7			;		dec hl 
0db7			;		ld (hl), a 
0db7			 
0db7 2a 75 fb				ld hl, (input_ptr) 
0dba 2b					dec hl 
0dbb 22 75 fb				ld (input_ptr), hl 
0dbe			 
0dbe					; shift all data 
0dbe			 
0dbe e5					push hl 
0dbf 23					inc hl 
0dc0 d1					pop de 
0dc1 3a 66 fb				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0dc4 4f					ld c,a 
0dc5 06 00				ld b,0 
0dc7 ed b0				ldir  
0dc9			 
0dc9			 
0dc9			 
0dc9			 
0dc9 3a 6e fb				ld a, (input_at_cursor) 
0dcc 3d					dec a 
0dcd 32 6e fb				ld (input_at_cursor), a 
0dd0			 
0dd0			 
0dd0 3e 01				ld a, 1		; show cursor moving 
0dd2 32 6b fb				ld (input_cur_onoff),a 
0dd5 3e 0f				ld a, CUR_BLINK_RATE 
0dd7 32 6c fb				ld (input_cur_flash), a 
0dda			 
0dda					; remove char 
0dda 3a 6e fb				ld a, (input_at_cursor) 
0ddd 3c					inc a 
0dde 11 68 0e				ld de,.iblank 
0de1 cd cc 0a				call str_at_display 
0de4			 
0de4 c3 70 0c				jp .is1 
0de7			 
0de7 fe 0d		.isk4:		cp KEY_CR 
0de9 28 6c				jr z, .endinput 
0deb			 
0deb					; else add the key press to the end 
0deb			 
0deb 4f					ld c, a			; save key pressed 
0dec			 
0dec 7e					ld a,(hl)		; get what is currently under char 
0ded			 
0ded fe 00				cp 0			; we are at the end of the string 
0def 20 2f				jr nz, .onchar 
0df1					 
0df1					; add a char to the end of the string 
0df1				 
0df1 71					ld (hl),c 
0df2 23					inc hl 
0df3			;		ld a,' ' 
0df3			;		ld (hl),a 
0df3			;		inc hl 
0df3 3e 00				ld a,0 
0df5 77					ld (hl),a 
0df6 2b					dec hl 
0df7			 
0df7 3a 61 fb				ld a, (input_cursor) 
0dfa 3c					inc a				; TODO check max string length and scroll  
0dfb 32 61 fb				ld (input_cursor), a		; inc cursor pos 
0dfe							 
0dfe 3a 6e fb				ld a, (input_at_cursor) 
0e01 3c					inc a 
0e02 32 6e fb				ld (input_at_cursor), a 
0e05			 
0e05 2a 75 fb				ld hl, (input_ptr) 
0e08 23					inc hl 
0e09 22 75 fb				ld (input_ptr), hl 
0e0c			 
0e0c 2a 75 fb				ld hl, (input_ptr) 
0e0f 23					inc hl 
0e10 22 75 fb				ld (input_ptr), hl 
0e13			;	if DEBUG_INPUT 
0e13			;		push af 
0e13			;		ld a, '+' 
0e13			;		ld (debug_mark),a 
0e13			;		pop af 
0e13			;		CALLMONITOR 
0e13			;	endif 
0e13 3e 01				ld a, 1		; show cursor moving 
0e15 32 6b fb				ld (input_cur_onoff),a 
0e18 3e 0f				ld a, CUR_BLINK_RATE 
0e1a 32 6c fb				ld (input_cur_flash), a 
0e1d c3 70 0c				jp .is1 
0e20					 
0e20			 
0e20			 
0e20					; if on a char then insert 
0e20			.onchar: 
0e20			 
0e20					; TODO over flow check: make sure insert does not blow out buffer 
0e20			 
0e20					; need to do some maths to use lddr 
0e20			 
0e20 e5					push hl   ; save char pos 
0e21 c5					push bc 
0e22			 
0e22 2a 73 fb				ld hl, (input_start) 
0e25 3a 66 fb				ld a, (input_len) 
0e28 cd 12 0c				call addatohl  		; end of string 
0e2b 23					inc hl 
0e2c 23					inc hl		; past zero term 
0e2d e5					push hl 
0e2e 23					inc hl 
0e2f e5					push hl  
0e30			 
0e30								; start and end of lddr set, now how much to move? 
0e30			 
0e30							 
0e30 3a 61 fb				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0e33 47					ld b,a 
0e34 3a 66 fb				ld a,(input_len) 
0e37 5f					ld e,a 
0e38 90					sub b 
0e39 3c					inc a		;?? 
0e3a 3c					inc a		;?? 
0e3b 3c					inc a		;?? 
0e3c			 
0e3c 06 00				ld b,0 
0e3e 4f					ld c,a 
0e3f			 
0e3f				if DEBUG_INPUT 
0e3f					push af 
0e3f					ld a, 'i' 
0e3f					ld (debug_mark),a 
0e3f					pop af 
0e3f			;		CALLMONITOR 
0e3f				endif 
0e3f d1					pop de 
0e40 e1					pop hl 
0e41				if DEBUG_INPUT 
0e41					push af 
0e41					ld a, 'I' 
0e41					ld (debug_mark),a 
0e41					pop af 
0e41			;		CALLMONITOR 
0e41				endif 
0e41 ed b8				lddr 
0e43				 
0e43			 
0e43			 
0e43					; TODO have a key for insert/overwrite mode???? 
0e43 c1					pop bc 
0e44 e1					pop hl 
0e45 71					ld (hl), c		; otherwise overwrite current char 
0e46					 
0e46			 
0e46			 
0e46			 
0e46 3a 61 fb				ld a, (input_cursor) 
0e49 3c					inc  a 		; TODO check overflow 
0e4a 32 61 fb				ld (input_cursor), a 
0e4d			 
0e4d 3a 6e fb				ld a, (input_at_cursor) 
0e50 3c					inc a 
0e51 32 6e fb				ld (input_at_cursor), a 
0e54			 
0e54 c3 70 0c				jp .is1 
0e57			 
0e57			.endinput:	; TODO look for end of string 
0e57			 
0e57					; add trailing space for end of token 
0e57			 
0e57 2a 73 fb				ld hl, (input_start) 
0e5a 3a 66 fb				ld a,(input_len) 
0e5d cd 12 0c				call addatohl 
0e60 3e 20				ld a, ' ' 
0e62 77					ld (hl),a 
0e63					; TODO eof of parse marker 
0e63			 
0e63 23					inc hl 
0e64 3e 00				ld a, 0 
0e66 77					ld (hl),a 
0e67			 
0e67			 
0e67 c9					ret 
0e68			 
0e68 .. 00		.iblank: db " ",0 
0e6a			 
0e6a			 
0e6a 32 70 fb		input_str_prev:	ld (input_at_pos), a 
0e6d 22 73 fb				ld (input_start), hl 
0e70 3e 01				ld a,1			; add cursor 
0e72 77					ld (hl),a 
0e73 23					inc hl 
0e74 3e 00				ld a,0 
0e76 77					ld (hl),a 
0e77 22 75 fb				ld (input_ptr), hl 
0e7a 7a					ld a,d 
0e7b 32 72 fb				ld (input_size), a 
0e7e 3e 00				ld a,0 
0e80 32 61 fb				ld (input_cursor),a 
0e83			.instr1:	 
0e83			 
0e83					; TODO do block cursor 
0e83					; TODO switch cursor depending on the modifer key 
0e83			 
0e83					; update cursor shape change on key hold 
0e83			 
0e83 2a 75 fb				ld hl, (input_ptr) 
0e86 2b					dec hl 
0e87 3a d0 f8				ld a,(cursor_shape) 
0e8a 77					ld (hl), a 
0e8b			 
0e8b					; display entered text 
0e8b 3a 70 fb				ld a,(input_at_pos) 
0e8e cd 28 61		            	CALL fLCD_Pos       ;Position cursor to location in A 
0e91 ed 5b 73 fb	            	LD   de, (input_start) 
0e95 cd 4a 61		            	CALL fLCD_Str       ;Display string pointed to by DE 
0e98			 
0e98 cd 64 63				call cin 
0e9b fe 00				cp 0 
0e9d 28 e4				jr z, .instr1 
0e9f			 
0e9f					; proecess keyboard controls first 
0e9f			 
0e9f 2a 75 fb				ld hl,(input_ptr) 
0ea2			 
0ea2 fe 0d				cp KEY_CR	 ; pressing enter ends input 
0ea4 28 5a				jr z, .instrcr 
0ea6			 
0ea6 fe 08				cp KEY_BS 	; back space 
0ea8 20 0f				jr nz, .instr2 
0eaa					; process back space 
0eaa			 
0eaa					; TODO stop back space if at start of string 
0eaa 2b					dec hl 
0eab 2b					dec hl ; to over write cursor 
0eac 3a d0 f8				ld a,(cursor_shape) 
0eaf					;ld a,0 
0eaf 77					ld (hl),a 
0eb0 23					inc hl 
0eb1 3e 20				ld a," " 
0eb3 77					ld (hl),a 
0eb4 22 75 fb				ld (input_ptr),hl 
0eb7					 
0eb7			 
0eb7 18 ca				jr .instr1 
0eb9			 
0eb9 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
0ebb 20 06				jr nz, .instr3 
0ebd 2b					dec hl 
0ebe 22 75 fb				ld (input_ptr),hl 
0ec1 18 c0				jr .instr1 
0ec3				 
0ec3 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
0ec5 20 06				jr nz, .instr4 
0ec7 23					inc hl 
0ec8 22 75 fb				ld (input_ptr),hl 
0ecb 18 b6				jr .instr1 
0ecd			 
0ecd fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
0ecf 20 06				jr nz, .instr5 
0ed1 2b					dec hl 
0ed2 22 75 fb				ld (input_ptr),hl 
0ed5 18 ac				jr .instr1 
0ed7			 
0ed7 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
0ed9 20 06				jr nz, .instr6 
0edb 2b					dec hl 
0edc 22 75 fb				ld (input_ptr),hl 
0edf 18 a2				jr .instr1 
0ee1 fe 05		.instr6:        cp KEY_UP      ; recall last command 
0ee3 20 0b				jr nz, .instrnew 
0ee5			 
0ee5 21 32 ee			ld hl, scratch 
0ee8 11 58 f2			ld de, os_last_cmd 
0eeb cd 09 0f			call strcpy 
0eee 18 93				jr .instr1 
0ef0			 
0ef0			 
0ef0			.instrnew:	; no special key pressed to see if we have room to store it 
0ef0			 
0ef0					; TODO do string size test 
0ef0			 
0ef0 2b					dec hl ; to over write cursor 
0ef1 77					ld (hl),a 
0ef2 23					inc hl 
0ef3 3a d0 f8				ld a,(cursor_shape) 
0ef6 77					ld (hl),a 
0ef7 23					inc hl 
0ef8 3e 00				ld a,0 
0efa 77					ld (hl),a 
0efb			 
0efb 22 75 fb				ld (input_ptr),hl 
0efe					 
0efe 18 83				jr .instr1 
0f00 2b			.instrcr:	dec hl		; remove cursor 
0f01 3e 20				ld a,' '	; TODO add a trailing space for safety 
0f03 77					ld (hl),a 
0f04 23					inc hl 
0f05 3e 00				ld a,0 
0f07 77					ld (hl),a 
0f08			 
0f08			 
0f08					; if at end of line scroll up    
0f08					; TODO detecting only end of line 4 for scroll up  
0f08			 
0f08					;ld   
0f08			 
0f08 c9					ret 
0f09			 
0f09			 
0f09			; strcpy hl = dest, de source 
0f09			 
0f09 1a			strcpy:   LD   A, (DE)        ;Get character from string 
0f0a b7			            OR   A              ;Null terminator? 
0f0b c8			            RET  Z              ;Yes, so finished 
0f0c 1a					ld a,(de) 
0f0d 77					ld (hl),a 
0f0e 13			            INC  DE             ;Point to next character 
0f0f 23					inc hl 
0f10 18 f7		            JR   strcpy       ;Repeat 
0f12 c9					ret 
0f13			 
0f13			 
0f13			; TODO string_at  
0f13			; pass string which starts with lcd offset address and then null term string 
0f13			 
0f13			; TODO string to dec 
0f13			; TODO string to hex 
0f13			; TODO byte to string hex 
0f13			; TODO byte to string dec 
0f13			 
0f13			 
0f13			 
0f13			; from z80uartmonitor 
0f13			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0f13			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
0f13			; pass hl for where to put the text 
0f13			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0f13 c5			hexout:	PUSH BC 
0f14 f5					PUSH AF 
0f15 47					LD B, A 
0f16					; Upper nybble 
0f16 cb 3f				SRL A 
0f18 cb 3f				SRL A 
0f1a cb 3f				SRL A 
0f1c cb 3f				SRL A 
0f1e cd 2e 0f				CALL tohex 
0f21 77					ld (hl),a 
0f22 23					inc hl	 
0f23					 
0f23					; Lower nybble 
0f23 78					LD A, B 
0f24 e6 0f				AND 0FH 
0f26 cd 2e 0f				CALL tohex 
0f29 77					ld (hl),a 
0f2a 23					inc hl	 
0f2b					 
0f2b f1					POP AF 
0f2c c1					POP BC 
0f2d c9					RET 
0f2e					 
0f2e			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0f2e			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
0f2e			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0f2e			tohex: 
0f2e e5					PUSH HL 
0f2f d5					PUSH DE 
0f30 16 00				LD D, 0 
0f32 5f					LD E, A 
0f33 21 3b 0f				LD HL, .DATA 
0f36 19					ADD HL, DE 
0f37 7e					LD A, (HL) 
0f38 d1					POP DE 
0f39 e1					POP HL 
0f3a c9					RET 
0f3b			 
0f3b			.DATA: 
0f3b 30					DEFB	30h	; 0 
0f3c 31					DEFB	31h	; 1 
0f3d 32					DEFB	32h	; 2 
0f3e 33					DEFB	33h	; 3 
0f3f 34					DEFB	34h	; 4 
0f40 35					DEFB	35h	; 5 
0f41 36					DEFB	36h	; 6 
0f42 37					DEFB	37h	; 7 
0f43 38					DEFB	38h	; 8 
0f44 39					DEFB	39h	; 9 
0f45 41					DEFB	41h	; A 
0f46 42					DEFB	42h	; B 
0f47 43					DEFB	43h	; C 
0f48 44					DEFB	44h	; D 
0f49 45					DEFB	45h	; E 
0f4a 46					DEFB	46h	; F 
0f4b			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0f4b			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
0f4b			;;    subtract $30, if result > 9 then subtract $7 more 
0f4b			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0f4b			atohex: 
0f4b d6 30				SUB $30 
0f4d fe 0a				CP 10 
0f4f f8					RET M		; If result negative it was 0-9 so we're done 
0f50 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
0f52 c9					RET		 
0f53			 
0f53			 
0f53			 
0f53			 
0f53			; Get 2 ASCII characters as hex byte from pointer in hl 
0f53			 
0f53			BYTERD: 
0f53 16 00			LD	D,00h		;Set up 
0f55 cd 5d 0f			CALL	HEXCON		;Get byte and convert to hex 
0f58 87				ADD	A,A		;First nibble so 
0f59 87				ADD	A,A		;multiply by 16 
0f5a 87				ADD	A,A		; 
0f5b 87				ADD	A,A		; 
0f5c 57				LD	D,A		;Save hi nibble in D 
0f5d			HEXCON: 
0f5d 7e				ld a, (hl)		;Get next chr 
0f5e 23				inc hl 
0f5f d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
0f61 fe 0a			CP	00Ah		;Is it 0-9 ? 
0f63 38 02			JR	C,NALPHA	;If so miss next bit 
0f65 d6 07			SUB	007h		;Else convert alpha 
0f67			NALPHA: 
0f67 b2				OR	D		;Add hi nibble back 
0f68 c9				RET			; 
0f69			 
0f69			 
0f69			; 
0f69			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
0f69			; Since the routines get_byte and therefore get_nibble are called, only valid 
0f69			; characters (0-9a-f) are accepted. 
0f69			; 
0f69			;get_word        push    af 
0f69			;                call    get_byte        ; Get the upper byte 
0f69			;                ld      h, a 
0f69			;                call    get_byte        ; Get the lower byte 
0f69			;                ld      l, a 
0f69			;                pop     af 
0f69			;                ret 
0f69			; 
0f69			; Get a byte in hexadecimal notation. The result is returned in A. Since 
0f69			; the routine get_nibble is used only valid characters are accepted - the  
0f69			; input routine only accepts characters 0-9a-f. 
0f69			; 
0f69 c5			get_byte:        push    bc              ; Save contents of B (and C) 
0f6a 7e					ld a,(hl) 
0f6b 23					inc hl 
0f6c cd 91 0f		                call    nibble2val      ; Get upper nibble 
0f6f cb 07		                rlc     a 
0f71 cb 07		                rlc     a 
0f73 cb 07		                rlc     a 
0f75 cb 07		                rlc     a 
0f77 47			                ld      b, a            ; Save upper four bits 
0f78 7e					ld a,(hl) 
0f79 cd 91 0f		                call    nibble2val      ; Get lower nibble 
0f7c b0			                or      b               ; Combine both nibbles 
0f7d c1			                pop     bc              ; Restore B (and C) 
0f7e c9			                ret 
0f7f			; 
0f7f			; Get a hexadecimal digit from the serial line. This routine blocks until 
0f7f			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
0f7f			; to the serial line interface. The lower 4 bits of A contain the value of  
0f7f			; that particular digit. 
0f7f			; 
0f7f			;get_nibble      ld a,(hl)           ; Read a character 
0f7f			;                call    to_upper        ; Convert to upper case 
0f7f			;                call    is_hex          ; Was it a hex digit? 
0f7f			;                jr      nc, get_nibble  ; No, get another character 
0f7f			 ;               call    nibble2val      ; Convert nibble to value 
0f7f			 ;               call    print_nibble 
0f7f			 ;               ret 
0f7f			; 
0f7f			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
0f7f			; A valid hexadecimal digit is denoted by a set C flag. 
0f7f			; 
0f7f			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
0f7f			;                ret     nc              ; Yes 
0f7f			;                cp      '0'             ; Less than '0'? 
0f7f			;                jr      nc, is_hex_1    ; No, continue 
0f7f			;                ccf                     ; Complement carry (i.e. clear it) 
0f7f			;                ret 
0f7f			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
0f7f			;                ret     c               ; Yes 
0f7f			;                cp      'A'             ; Less than 'A'? 
0f7f			;                jr      nc, is_hex_2    ; No, continue 
0f7f			;                ccf                     ; Yes - clear carry and return 
0f7f			;                ret 
0f7f			;is_hex_2        scf                     ; Set carry 
0f7f			;                ret 
0f7f			; 
0f7f			; Convert a single character contained in A to upper case: 
0f7f			; 
0f7f fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
0f81 d8			                ret     c 
0f82 fe 7b		                cp      'z' + 1         ; > 'z'? 
0f84 d0			                ret     nc              ; Nothing to do, either 
0f85 e6 5f		                and     $5f             ; Convert to upper case 
0f87 c9			                ret 
0f88			 
0f88			 
0f88			to_lower: 
0f88			 
0f88			   ; if char is in [A-Z] make it lower case 
0f88			 
0f88			   ; enter : a = char 
0f88			   ; exit  : a = lower case char 
0f88			   ; uses  : af 
0f88			 
0f88 fe 41		   cp 'A' 
0f8a d8			   ret c 
0f8b			    
0f8b fe 5b		   cp 'Z'+1 
0f8d d0			   ret nc 
0f8e			    
0f8e f6 20		   or $20 
0f90 c9			   ret 
0f91			 
0f91			; 
0f91			; Expects a hexadecimal digit (upper case!) in A and returns the 
0f91			; corresponding value in A. 
0f91			; 
0f91 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
0f93 38 02		                jr      c, nibble2val_1 ; Yes 
0f95 d6 07		                sub     7               ; Adjust for A-F 
0f97 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
0f99 e6 0f		                and     $f              ; Only return lower 4 bits 
0f9b c9			                ret 
0f9c			; 
0f9c			; Print_nibble prints a single hex nibble which is contained in the lower  
0f9c			; four bits of A: 
0f9c			; 
0f9c			;print_nibble    push    af              ; We won't destroy the contents of A 
0f9c			;                and     $f              ; Just in case... 
0f9c			;                add     a, '0'             ; If we have a digit we are done here. 
0f9c			;                cp      '9' + 1         ; Is the result > 9? 
0f9c			;                jr      c, print_nibble_1 
0f9c			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
0f9c			;print_nibble_1  call    putc            ; Print the nibble and 
0f9c			;                pop     af              ; restore the original value of A 
0f9c			;                ret 
0f9c			;; 
0f9c			;; Send a CR/LF pair: 
0f9c			; 
0f9c			;crlf            push    af 
0f9c			;                ld      a, cr 
0f9c			;                call    putc 
0f9c			;                ld      a, lf 
0f9c			;                call    putc 
0f9c			;                pop     af 
0f9c			;                ret 
0f9c			; 
0f9c			; Print_word prints the four hex digits of a word to the serial line. The  
0f9c			; word is expected to be in HL. 
0f9c			; 
0f9c			;print_word      push    hl 
0f9c			;                push    af 
0f9c			;                ld      a, h 
0f9c			;                call    print_byte 
0f9c			;                ld      a, l 
0f9c			;                call    print_byte 
0f9c			;                pop     af 
0f9c			;                pop     hl 
0f9c			;                ret 
0f9c			; 
0f9c			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
0f9c			; The byte to be printed is expected to be in A. 
0f9c			; 
0f9c			;print_byte      push    af              ; Save the contents of the registers 
0f9c			;                push    bc 
0f9c			;                ld      b, a 
0f9c			;                rrca 
0f9c			;                rrca 
0f9c			;                rrca 
0f9c			;                rrca 
0f9c			;                call    print_nibble    ; Print high nibble 
0f9c			;                ld      a, b 
0f9c			;                call    print_nibble    ; Print low nibble 
0f9c			;                pop     bc              ; Restore original register contents 
0f9c			;                pop     af 
0f9c			;                ret 
0f9c			 
0f9c			 
0f9c			 
0f9c			 
0f9c			 
0f9c			fourehexhl:  
0f9c 7e				ld a,(hl) 
0f9d cd 4b 0f			call atohex 
0fa0 cb 3f				SRL A 
0fa2 cb 3f				SRL A 
0fa4 cb 3f				SRL A 
0fa6 cb 3f				SRL A 
0fa8 47				ld b, a 
0fa9 23				inc hl 
0faa 7e				ld a,(hl) 
0fab 23				inc hl 
0fac cd 4b 0f			call atohex 
0faf 80				add b 
0fb0 57				ld d,a 
0fb1 7e				ld a,(hl) 
0fb2 cd 4b 0f			call atohex 
0fb5 cb 3f				SRL A 
0fb7 cb 3f				SRL A 
0fb9 cb 3f				SRL A 
0fbb cb 3f				SRL A 
0fbd 47				ld b, a 
0fbe 23				inc hl 
0fbf 7e				ld a,(hl) 
0fc0 23				inc hl 
0fc1 cd 4b 0f			call atohex 
0fc4 80				add b 
0fc5 5f				ld e, a 
0fc6 d5				push de 
0fc7 e1				pop hl 
0fc8 c9				ret 
0fc9			 
0fc9			; pass hl. returns z set if the byte at hl is a digit 
0fc9			;isdigithl:  
0fc9			;	push bc 
0fc9			;	ld a,(hl) 
0fc9			;	cp ':' 
0fc9			;	jr nc, .isdf 		; > 
0fc9			;	cp '0' 
0fc9			;	jr c, .isdf		; < 
0fc9			; 
0fc9			;	; TODO find a better way to set z 
0fc9			; 
0fc9			;	ld b,a 
0fc9			;	cp b 
0fc9			;	pop bc 
0fc9			;	ret 
0fc9			; 
0fc9			;.isdf:	; not digit so clear z 
0fc9			; 
0fc9			;	; TODO find a better way to unset z 
0fc9			; 
0fc9			;	ld b,a 
0fc9			;	inc b 
0fc9			;	cp b 
0fc9			; 
0fc9			;	pop bc 
0fc9			;	ret 
0fc9				 
0fc9				 
0fc9			 
0fc9			 
0fc9			; pass hl as the four byte address to load 
0fc9			 
0fc9			get_word_hl:  
0fc9 e5				push hl 
0fca cd 69 0f			call get_byte 
0fcd				 
0fcd 47				ld b, a 
0fce			 
0fce e1				pop hl 
0fcf 23				inc hl 
0fd0 23				inc hl 
0fd1			 
0fd1			; TODO not able to handle a-f  
0fd1 7e				ld a,(hl) 
0fd2			;	;cp ':' 
0fd2			;	cp 'g' 
0fd2			;	jr nc, .single_byte_hl 		; > 
0fd2			;	cp 'G' 
0fd2			;	jr nc, .single_byte_hl 		; > 
0fd2			;	cp '0' 
0fd2			;	jr c, .single_byte_hl		; < 
0fd2			 
0fd2				;call isdigithl 
0fd2 fe 00			cp 0 
0fd4 28 06			jr z, .single_byte_hl 
0fd6			 
0fd6			.getwhln:   ; hex word so get next byte 
0fd6			 
0fd6 cd 69 0f			call get_byte 
0fd9 6f				ld l, a 
0fda 60				ld h,b 
0fdb c9				ret 
0fdc 68			.single_byte_hl:   ld l,b 
0fdd 26 00				ld h,0 
0fdf c9					ret 
0fe0			 
0fe0			 
0fe0			 
0fe0			 
0fe0 21 b1 16			ld hl,asc+1 
0fe3			;	ld a, (hl) 
0fe3			;	call nibble2val 
0fe3 cd 69 0f			call get_byte 
0fe6			 
0fe6			;	call fourehexhl 
0fe6 32 66 ee			ld (scratch+52),a 
0fe9				 
0fe9 21 64 ee			ld hl,scratch+50 
0fec 22 55 f1			ld (os_cur_ptr),hl 
0fef			 
0fef c9				ret 
0ff0			 
0ff0			 
0ff0			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
0ff0			 
0ff0			; Decimal Unsigned Version 
0ff0			 
0ff0			;Number in a to decimal ASCII 
0ff0			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
0ff0			;Example: display a=56 as "056" 
0ff0			;input: a = number 
0ff0			;Output: a=0,value of a in the screen 
0ff0			;destroys af,bc (don't know about hl and de) 
0ff0			DispAToASCII: 
0ff0 0e 9c			ld	c,-100 
0ff2 cd fc 0f			call	.Na1 
0ff5 0e f6			ld	c,-10 
0ff7 cd fc 0f			call	.Na1 
0ffa 0e ff			ld	c,-1 
0ffc 06 2f		.Na1:	ld	b,'0'-1 
0ffe 04			.Na2:	inc	b 
0fff 81				add	a,c 
1000 38 fc			jr	c,.Na2 
1002 91				sub	c		;works as add 100/10/1 
1003 f5				push af		;safer than ld c,a 
1004 78				ld	a,b		;char is in b 
1005			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
1005 f1				pop af		;safer than ld a,c 
1006 c9				ret 
1007			 
1007			; Decimal Signed Version 
1007			 
1007			; DispA 
1007			; -------------------------------------------------------------- 
1007			; Converts a signed integer value to a zero-terminated ASCII 
1007			; string representative of that value (using radix 10). 
1007			; -------------------------------------------------------------- 
1007			; INPUTS: 
1007			;     HL     Value to convert (two's complement integer). 
1007			;     DE     Base address of string destination. (pointer). 
1007			; -------------------------------------------------------------- 
1007			; OUTPUTS: 
1007			;     None 
1007			; -------------------------------------------------------------- 
1007			; REGISTERS/MEMORY DESTROYED 
1007			; AF HL 
1007			; -------------------------------------------------------------- 
1007			 
1007			;DispHLToASCII: 
1007			;   push    de 
1007			;   push    bc 
1007			; 
1007			;; Detect sign of HL. 
1007			;    bit    7, h 
1007			;    jr     z, ._DoConvert 
1007			; 
1007			;; HL is negative. Output '-' to string and negate HL. 
1007			;    ld     a, '-' 
1007			;    ld     (de), a 
1007			;    inc    de 
1007			; 
1007			;; Negate HL (using two's complement) 
1007			;    xor    a 
1007			;    sub    l 
1007			;    ld     l, a 
1007			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
1007			;    sbc    a, h 
1007			;    ld     h, a 
1007			; 
1007			;; Convert HL to digit characters 
1007			;._DoConvert: 
1007			;    ld     b, 0     ; B will count character length of number 
1007			;-   ld     a, 10 
1007			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
1007			;    push   af 
1007			;    inc    b 
1007			;    ld     a, h 
1007			;    or     l 
1007			;    jr     nz, - 
1007			; 
1007			;; Retrieve digits from stack 
1007			;-   pop    af 
1007			;    or     $30 
1007			;    ld     (de), a 
1007			;    inc    de 
1007			;    djnz   - 
1007			; 
1007			;; Terminate string with NULL 
1007			;    xor    a 
1007			;    ld     (de), a 
1007			; 
1007			;    pop    bc 
1007			;    pop    de 
1007			;    ret 
1007			 
1007			;Comments 
1007			; 
1007			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
1007			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
1007			;    Note that the output string will not be fixed-width. 
1007			; 
1007			;Example Usage 
1007			; 
1007			;    ld    hl, -1004 
1007			;    ld    de, OP1 
1007			;    call  DispA 
1007			;    ld    hl, OP1 
1007			;    syscall  PutS 
1007			 
1007			 
1007			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
1007			 
1007			 
1007			;Converts an ASCII string to an unsigned 16-bit integer 
1007			;Quits when it reaches a non-decimal digit 
1007			 
1007			string_to_uint16: 
1007			atoui_16: 
1007			;Input: 
1007			;     DE points to the string 
1007			;Outputs: 
1007			;     HL is the result 
1007			;     A is the 8-bit value of the number 
1007			;     DE points to the byte after the number 
1007			;Destroys: 
1007			;     BC 
1007			;       if the string is non-empty, BC is HL/10 
1007			;Size:  24 bytes 
1007			;Speed: 42+d(104+{0,9}) 
1007			;       d is the number of digits in the number 
1007			;       max is 640 cycles for a 5 digit number 
1007			;Assuming no leading zeros: 
1007			;1 digit:  146cc 
1007			;2 digit:  250cc 
1007			;3 digit:  354cc or 363cc (avg: 354.126cc) 
1007			;4 digit:  458cc or 467cc (avg: 458.27cc) 
1007			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
1007			;avg: 544.81158447265625cc (544+13297/16384) 
1007			;=============================================================== 
1007 21 00 00		  ld hl,0 
100a			.u16a: 
100a 1a			  ld a,(de) 
100b d6 30		  sub 30h 
100d fe 0a		  cp 10 
100f d0			  ret nc 
1010 13			  inc de 
1011 44			  ld b,h 
1012 4d			  ld c,l 
1013 29			  add hl,hl 
1014 29			  add hl,hl 
1015 09			  add hl,bc 
1016 29			  add hl,hl 
1017 85			  add a,l 
1018 6f			  ld l,a 
1019 30 ef		  jr nc,.u16a 
101b 24			  inc h 
101c c3 0a 10		  jp .u16a 
101f			 
101f			 
101f			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
101f			 
101f			;written by Zeda 
101f			;Converts a 16-bit unsigned integer to an ASCII string. 
101f			 
101f			uitoa_16: 
101f			;Input: 
101f			;   DE is the number to convert 
101f			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
101f			;Output: 
101f			;   HL points to the null-terminated ASCII string 
101f			;      NOTE: This isn't necessarily the same as the input HL. 
101f d5			  push de 
1020 c5			  push bc 
1021 f5			  push af 
1022 eb			  ex de,hl 
1023			 
1023 01 f0 d8		  ld bc,-10000 
1026 3e 2f		  ld a,'0'-1 
1028 3c			  inc a 
1029 09			  add hl,bc  
102a 38 fc		   jr c,$-2 
102c 12			  ld (de),a 
102d 13			  inc de 
102e			 
102e 01 e8 03		  ld bc,1000 
1031 3e 3a		  ld a,'9'+1 
1033 3d			  dec a  
1034 09			  add hl,bc  
1035 30 fc		   jr nc,$-2 
1037 12			  ld (de),a 
1038 13			  inc de 
1039			 
1039 01 9c ff		  ld bc,-100 
103c 3e 2f		  ld a,'0'-1 
103e 3c			  inc a  
103f 09			  add hl,bc  
1040 38 fc		   jr c,$-2 
1042 12			  ld (de),a 
1043 13			  inc de 
1044			 
1044 7d			  ld a,l 
1045 26 3a		  ld h,'9'+1 
1047 25			  dec h  
1048 c6 0a		  add a,10  
104a 30 fb		   jr nc,$-3 
104c c6 30		  add a,'0' 
104e eb			  ex de,hl 
104f 72			  ld (hl),d 
1050 23			  inc hl 
1051 77			  ld (hl),a 
1052 23			  inc hl 
1053 36 00		  ld (hl),0 
1055			 
1055			;Now strip the leading zeros 
1055 0e fa		  ld c,-6 
1057 09			  add hl,bc 
1058 3e 30		  ld a,'0' 
105a 23			  inc hl  
105b be			  cp (hl)  
105c 28 fc		  jr z,$-2 
105e			 
105e			;Make sure that the string is non-empty! 
105e 7e			  ld a,(hl) 
105f b7			  or a 
1060 20 01		  jr nz,.atoub 
1062 2b			  dec hl 
1063			.atoub: 
1063			 
1063 f1			  pop af 
1064 c1			  pop bc 
1065 d1			  pop de 
1066 c9			  ret 
1067			 
1067			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
1067			 
1067			toUpper: 
1067			;A is the char. 
1067			;If A is a lowercase letter, this sets it to the matching uppercase 
1067			;18cc or 30cc or 41cc 
1067			;avg: 26.75cc 
1067 fe 61		  cp 'a' 
1069 d8			  ret c 
106a fe 7b		  cp 'z'+1 
106c d0			  ret nc 
106d d6 20		  sub 'a'-'A' 
106f c9			  ret 
1070			 
1070			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1070			 
1070			; String Length 
1070			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1070			 
1070			; Get the length of the null-terminated string starting at $8000 hl 
1070			;    LD     HL, $8000 
1070			 
1070			strlenz: 
1070			 
1070 af			    XOR    A               ; Zero is the value we are looking for. 
1071 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1072 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1073			                           ; 65, 536 bytes (the entire addressable memory space). 
1073 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1075			 
1075			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1075 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
1076 6f			    LD     L, A             ; number of bytes 
1077 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1079 2b			    DEC    HL              ; Compensate for null. 
107a c9				ret 
107b			 
107b			; Get the length of the A terminated string starting at $8000 hl 
107b			;    LD     HL, $8000 
107b			 
107b			strlent: 
107b			 
107b			                  ; A is the value we are looking for. 
107b 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
107d 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
107f			                           ; 65, 536 bytes (the entire addressable memory space). 
107f ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1081			 
1081			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1081 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1083 2e 00		    LD     L, 0             ; number of bytes 
1085 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1087 2b			    DEC    HL              ; Compensate for null. 
1088 c9				ret 
1089			 
1089			 
1089			;Comparing Strings 
1089			 
1089			;IN    HL     Address of string1. 
1089			;      DE     Address of string2. 
1089			 
1089			; doc given but wrong??? 
1089			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
1089			;      carry  Set if string1 > string2, reset if string1 <= string2. 
1089			; tested 
1089			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
1089			 
1089			strcmp_old: 
1089 e5			    PUSH   HL 
108a d5			    PUSH   DE 
108b			 
108b 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
108c be			    CP     (HL)            ; (want to minimize work). 
108d 38 01		    JR     C, Str1IsBigger 
108f 7e			    LD     A, (HL) 
1090			 
1090			Str1IsBigger: 
1090 4f			    LD     C, A             ; Put length in BC 
1091 06 00		    LD     B, 0 
1093 13			    INC    DE              ; Increment pointers to meat of string. 
1094 23			    INC    HL 
1095			 
1095			CmpLoop: 
1095 1a			    LD     A, (DE)          ; Compare bytes. 
1096 ed a1		    CPI 
1098 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
109a 13			    INC    DE              ; Update pointer. 
109b ea 95 10		    JP     PE, CmpLoop 
109e			 
109e d1			    POP    DE 
109f e1			    POP    HL 
10a0 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
10a1 be			    CP     (HL) 
10a2 c9			    RET 
10a3			 
10a3			NoMatch: 
10a3 2b			    DEC    HL 
10a4 be			    CP     (HL)            ; Compare again to affect carry. 
10a5 d1			    POP    DE 
10a6 e1			    POP    HL 
10a7 c9			    RET 
10a8			 
10a8			;; test strmp 
10a8			; 
10a8			;ld de, .str1 
10a8			;ld hl, .str2 
10a8			;call strcmp 
10a8			;jr z, .z1 
10a8			;;this 
10a8			;	if DEBUG_FORTH_WORDS 
10a8			;		DMARK "NZ1" 
10a8			;		CALLMONITOR 
10a8			;	endif 
10a8			;.z1: 
10a8			; 
10a8			;	if DEBUG_FORTH_WORDS 
10a8			;		DMARK "ZZ1" 
10a8			;		CALLMONITOR 
10a8			;	endif 
10a8			; 
10a8			;ld de, .str1 
10a8			;ld hl, .str1 
10a8			;call strcmp 
10a8			;jr z, .z2 
10a8			;;this 
10a8			;	if DEBUG_FORTH_WORDS 
10a8			;		DMARK "NZ2" 
10a8			;		CALLMONITOR 
10a8			;	endif 
10a8			;.z2: 
10a8			; 
10a8			;	if DEBUG_FORTH_WORDS 
10a8			;		DMARK "ZZ2" 
10a8			;		CALLMONITOR 
10a8			;	endif 
10a8			; 
10a8			;ld de, .str1 
10a8			;ld hl, .str2 
10a8			;call strcmp 
10a8			;jr c, .c1 
10a8			; 
10a8			;	if DEBUG_FORTH_WORDS 
10a8			;		DMARK "Nc1" 
10a8			;		CALLMONITOR 
10a8			;	endif 
10a8			;.c1: 
10a8			;;this 
10a8			;	if DEBUG_FORTH_WORDS 
10a8			;		DMARK "cc1" 
10a8			;		CALLMONITOR 
10a8			;	endif 
10a8			; 
10a8			;ld de, .str1 
10a8			;ld hl, .str1 
10a8			;call strcmp 
10a8			;jr c, .c2 
10a8			;;this 
10a8			;	if DEBUG_FORTH_WORDS 
10a8			;		DMARK "Nc2" 
10a8			;		CALLMONITOR 
10a8			;	endif 
10a8			;.c2: 
10a8			; 
10a8			;	if DEBUG_FORTH_WORDS 
10a8			;		DMARK "cc2" 
10a8			;		CALLMONITOR 
10a8			;	endif 
10a8			;	NEXTW 
10a8			;.str1:   db "string1",0 
10a8			;.str2:   db "string2",0 
10a8			 
10a8			; only care about direct match or not 
10a8			; hl and de strings 
10a8			; zero set if the same 
10a8			 
10a8			strcmp: 
10a8 1a				ld a, (de) 
10a9 be				cp (hl) 
10aa 28 02			jr z, .ssame 
10ac b7				or a 
10ad c9				ret 
10ae			 
10ae			.ssame:  
10ae fe 00			cp 0 
10b0 c8				ret z 
10b1			 
10b1 23				inc hl 
10b2 13				inc de 
10b3 18 f3			jr strcmp 
10b5				 
10b5				 
10b5			 
10b5			 
10b5			 
10b5			 
10b5			; eof 
10b5			 
10b5			 
10b5			 
10b5			 
10b5			 
10b5			 
# End of file firmware_strings.asm
10b5			include "firmware_memory.asm"   ; malloc and free  
10b5			 
10b5			if DEBUG_FORTH_MALLOC_HIGH 
10b5			.mallocsize: db "Wants malloc >256",0 
10b5			.mallocasize: db "MALLOC gives >256",0 
10b5			.malloczero: db "MALLOC gives zero",0 
10b5			 
10b5			malloc_guard_zerolen: 
10b5				push hl 
10b5				push de 
10b5				push af 
10b5			 
10b5				ld de, 0 
10b5			        call cmp16 
10b5				jr nz, .lowalloz 
10b5			 
10b5				push hl 
10b5				push de 
10b5					ld hl, display_fb0 
10b5					ld (display_fb_active), hl 
10b5				call clear_display 
10b5				ld a, 0 
10b5				ld de, .malloczero 
10b5				call str_at_display 
10b5				call update_display 
10b5				call delay1s 
10b5				call delay1s 
10b5				ld a, 0 
10b5				ld (os_view_disable), a 
10b5			 
10b5				pop de 
10b5				pop hl 
10b5			 
10b5				 
10b5			 
10b5				CALLMONITOR 
10b5			.lowalloz: 
10b5			 
10b5			 
10b5				pop af 
10b5				pop de 
10b5				pop hl 
10b5			ret 
10b5			 
10b5			malloc_guard_entry: 
10b5				push hl 
10b5				push de 
10b5				push af 
10b5			 
10b5			 	or a      ;clear carry flag 
10b5				push hl 
10b5				ld de, 255 
10b5				sbc hl, de 
10b5				jr c, .lowalloc 
10b5			 
10b5				push de 
10b5					ld hl, display_fb0 
10b5					ld (display_fb_active), hl 
10b5				call clear_display 
10b5				ld a, 0 
10b5				ld de, .mallocsize 
10b5				call str_at_display 
10b5				call update_display 
10b5				call delay1s 
10b5				call delay1s 
10b5				ld a, 0 
10b5				ld (os_view_disable), a 
10b5			 
10b5				pop de 
10b5				pop hl 
10b5			 
10b5				 
10b5			 
10b5				CALLMONITOR 
10b5				jr .lowdone 
10b5			.lowalloc: 
10b5			 
10b5			 
10b5				pop hl 
10b5			.lowdone:	pop af 
10b5				pop de 
10b5				pop hl 
10b5			ret 
10b5			 
10b5			malloc_guard_exit: 
10b5				push hl 
10b5				push de 
10b5				push af 
10b5			 
10b5			 	or a      ;clear carry flag 
10b5				push hl 
10b5				ld de, 255 
10b5				sbc hl, de 
10b5				jr c, .lowallocx 
10b5			 
10b5				push de 
10b5					ld hl, display_fb0 
10b5					ld (display_fb_active), hl 
10b5				call clear_display 
10b5				ld a, 0 
10b5				ld de, .mallocasize 
10b5				call str_at_display 
10b5				call update_display 
10b5				call delay1s 
10b5				call delay1s 
10b5				ld a, 0 
10b5				ld (os_view_disable), a 
10b5				pop de 
10b5				pop hl 
10b5			 
10b5				CALLMONITOR 
10b5				jr .lowdonex 
10b5			.lowallocx: 
10b5			 
10b5				pop hl 
10b5			.lowdonex:	pop af 
10b5				pop de 
10b5				pop hl 
10b5			ret 
10b5			endif 
10b5			 
10b5			if MALLOC_2 
10b5			; Z80 Malloc and Free Functions 
10b5			 
10b5			; Malloc Function: 
10b5			; Input: 
10b5			;   HL: Size of block to allocate 
10b5			; Output: 
10b5			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
10b5			 
10b5			malloc: 
10b5				 
10b5			if DEBUG_FORTH_MALLOC_HIGH 
10b5			call malloc_guard_entry 
10b5			endif 
10b5			 
10b5			 
10b5			 
10b5			 
10b5					if DEBUG_FORTH_MALLOC 
10b5						DMARK "mal" 
10b5						CALLMONITOR 
10b5					endif 
10b5			    push af            ; Save AF register 
10b5			    ld a, l            ; Load low byte of size into A 
10b5			    or h               ; Check if size is zero 
10b5			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
10b5			 
10b5			    ; Allocate memory 
10b5			    ld hl, (heap_start) ; Load start of heap into HL 
10b5					if DEBUG_FORTH_MALLOC 
10b5						DMARK "ma1" 
10b5						CALLMONITOR 
10b5					endif 
10b5			    call malloc_internal ; Call internal malloc function 
10b5			    pop af             ; Restore AF register 
10b5			if DEBUG_FORTH_MALLOC_HIGH 
10b5			call malloc_guard_exit 
10b5			call malloc_guard_zerolen 
10b5			endif 
10b5			    ret                ; Return 
10b5			 
10b5			; Free Function: 
10b5			; Input: 
10b5			;   HL: Pointer to memory block to free 
10b5			; Output: 
10b5			;   None 
10b5			 
10b5			free: 
10b5			    push af            ; Save AF register 
10b5			    ld a, l            ; Load low byte of pointer into A 
10b5			    or h               ; Check if pointer is NULL 
10b5			    jp z, free_exit    ; If pointer is NULL, exit 
10b5			 
10b5			    ; Free memory 
10b5			    ld hl, (heap_start) ; Load start of heap into HL 
10b5			    call free_internal  ; Call internal free function 
10b5			    pop af             ; Restore AF register 
10b5			    ret                ; Return 
10b5			 
10b5			; Internal Malloc Function: 
10b5			; Input: 
10b5			;   HL: Size of block to allocate 
10b5			; Output: 
10b5			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
10b5			 
10b5			malloc_internal: 
10b5			    ld bc, 2           ; Number of bytes to allocate for management overhead 
10b5			    add hl, bc         ; Add management overhead to requested size 
10b5			    ex de, hl          ; Save total size in DE, and keep it in HL 
10b5					if DEBUG_FORTH_MALLOC 
10b5						DMARK "ma2" 
10b5						CALLMONITOR 
10b5					endif 
10b5			 
10b5			    ; Search for free memory block 
10b5			    ld de, (heap_end)  ; Load end of heap into DE 
10b5			    ld bc, 0           ; Initialize counter 
10b5			 
10b5					if DEBUG_FORTH_MALLOC 
10b5						DMARK "ma2" 
10b5						CALLMONITOR 
10b5					endif 
10b5			malloc_search_loop: 
10b5			    ; Check if current block is free 
10b5			    ld a, (hl)         ; Load current block's status (free or used) 
10b5			    cp 0               ; Compare with zero (free) 
10b5			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
10b5			 
10b5			    ; Check if current block is large enough 
10b5			    ld a, (hl+1)       ; Load high byte of block size 
10b5			    cp l               ; Compare with low byte of requested size 
10b5			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
10b5			 
10b5			    ld a, (hl+2)       ; Load low byte of block size 
10b5			    cp h               ; Compare with high byte of requested size 
10b5			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
10b5			 
10b5			    ; Mark block as used 
10b5			    ld (hl), 0xFF      ; Set status byte to indicate used block 
10b5			 
10b5			    ; Calculate remaining space in block 
10b5			    ld bc, 0           ; Clear BC 
10b5			    add hl, bc         ; Increment HL to point to start of data block 
10b5			    add hl, de         ; HL = HL + DE (total size) 
10b5			    ld bc, 1           ; Number of bytes to allocate for management overhead 
10b5			    add hl, bc         ; Add management overhead to start of data block 
10b5			 
10b5			    ; Save pointer to allocated block in HL 
10b5			if DEBUG_FORTH_MALLOC_HIGH 
10b5						DMARK "ma5" 
10b5			call malloc_guard_exit 
10b5			call malloc_guard_zerolen 
10b5			endif 
10b5			    ret 
10b5			 
10b5			malloc_skip_block_check: 
10b5			    ; Move to the next block 
10b5			    ld bc, 3           ; Size of management overhead 
10b5			    add hl, bc         ; Move to the next block 
10b5			    inc de             ; Increment counter 
10b5			 
10b5			    ; Check if we have reached the end of heap 
10b5			    ld a, e            ; Load low byte of heap end address 
10b5			    cp (hl)            ; Compare with low byte of current address 
10b5			    jr nz, malloc_search_loop  ; If not equal, continue searching 
10b5			    ld a, d            ; Load high byte of heap end address 
10b5			    cp 0               ; Check if it's zero (end of memory) 
10b5			    jr nz, malloc_search_loop  ; If not zero, continue searching 
10b5			 
10b5			    ; If we reached here, allocation failed 
10b5			    xor a              ; Set result to NULL 
10b5			if DEBUG_FORTH_MALLOC_HIGH 
10b5						DMARK "ma6" 
10b5			call malloc_guard_exit 
10b5			call malloc_guard_zerolen 
10b5			endif 
10b5			    ret 
10b5			malloc_exit: 
10b5			if DEBUG_FORTH_MALLOC_HIGH 
10b5						DMARK "ma7" 
10b5			call malloc_guard_exit 
10b5			call malloc_guard_zerolen 
10b5			endif 
10b5			    ret 
10b5			 
10b5			; Internal Free Function: 
10b5			; Input: 
10b5			;   HL: Pointer to memory block to free 
10b5			; Output: 
10b5			;   None 
10b5			 
10b5			free_internal: 
10b5			    ld de, (heap_start) ; Load start of heap into DE 
10b5			    ld bc, 0            ; Initialize counter 
10b5			 
10b5			free_search_loop: 
10b5			    ; Check if current block contains the pointer 
10b5			    ld a, l             ; Load low byte of pointer 
10b5			    cp (hl+1)           ; Compare with high byte of current block's address 
10b5			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
10b5			    ld a, h             ; Load high byte of pointer 
10b5			    cp (hl+2)           ; Compare with low byte of current block's address 
10b5			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
10b5			 
10b5			    ; Mark block as free 
10b5			    ld (hl), 0          ; Set status byte to indicate free block 
10b5			    ret                 ; Return 
10b5			 
10b5			free_skip_block_check: 
10b5			    ; Move to the next block 
10b5			    ld bc, 3            ; Size of management overhead 
10b5			    add hl, bc          ; Move to the next block 
10b5			    inc de              ; Increment counter 
10b5			 
10b5			    ; Check if we have reached the end of heap 
10b5			    ld a, e             ; Load low byte of heap end address 
10b5			    cp (hl)             ; Compare with low byte of current address 
10b5			    jr nz, free_search_loop  ; If not equal, continue searching 
10b5			    ld a, d             ; Load high byte of heap end address 
10b5			    cp 0                ; Check if it's zero (end of memory) 
10b5			    jr nz, free_search_loop  ; If not zero, continue searching 
10b5			 
10b5			    ; If we reached here, pointer is not found in heap 
10b5			    ret 
10b5			 
10b5			free_exit: 
10b5			    ret                 ; Return 
10b5			 
10b5			; Define heap start and end addresses 
10b5			;heap_start:    .dw 0xC000   ; Start of heap 
10b5			;heap_end:      .dw 0xE000   ; End of heap 
10b5			 
10b5			endif 
10b5			 
10b5			 
10b5			if MALLOC_1 
10b5			 
10b5			 
10b5			 
10b5			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
10b5			 
10b5			;moved to firmware.asm 
10b5			;heap_start        .equ  0x9000      ; Starting address of heap 
10b5			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
10b5			 
10b5			;      .org 0 
10b5			;      jp    main 
10b5			 
10b5			 
10b5			;      .org  0x100 
10b5			;main: 
10b5			;      ld    HL, 0x8100 
10b5			;      ld    SP, HL 
10b5			; 
10b5			;      call  heap_init 
10b5			; 
10b5			;      ; Make some allocations 
10b5			;      ld    HL, 12 
10b5			;      call  malloc            ; Allocates 0x9004 
10b5			; 
10b5			;      ld    HL, 12 
10b5			;      call  malloc            ; Allocates 0x9014 
10b5			; 
10b5			;      ld    HL, 12 
10b5			;      call  malloc            ; Allocates 0x9024 
10b5			; 
10b5			;      ; Free some allocations 
10b5			;      ld    HL, 0x9014 
10b5			;      call  free 
10b5			; 
10b5			;      ld    HL, 0x9004 
10b5			;      call  free 
10b5			; 
10b5			;      ld    HL, 0x9024 
10b5			;      call  free 
10b5			; 
10b5			; 
10b5			;      halt 
10b5			 
10b5			 
10b5			;------------------------------------------------------------------------------ 
10b5			;     heap_init                                                               : 
10b5			;                                                                             : 
10b5			; Description                                                                 : 
10b5			;     Initialise the heap and make it ready for malloc and free operations.   : 
10b5			;                                                                             : 
10b5			;     The heap is maintained as a linked list, starting with an initial       : 
10b5			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
10b5			;     the first free block in the heap. Each block then points to the next    : 
10b5			;     free block within the heap, and the free list ends at the first block   : 
10b5			;     with a null pointer to the next free block.                             : 
10b5			;                                                                             : 
10b5			; Parameters                                                                  : 
10b5			;     Inputs are compile-time only. Two defines which specify the starting    : 
10b5			;     address of the heap and its size are required, along with a memory      : 
10b5			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
10b5			;     principally stores a pointer to the first free block in the heap.       : 
10b5			;                                                                             : 
10b5			; Returns                                                                     : 
10b5			;     Nothing                                                                 : 
10b5			;------------------------------------------------------------------------------ 
10b5			heap_init: 
10b5 e5			      push  HL 
10b6			 
10b6			      ; Initialise free list struct 
10b6 21 0e 80		      ld    HL, heap_start 
10b9 22 0a 80		      ld    (free_list), HL 
10bc 21 00 00		      ld    HL, 0 
10bf 22 0c 80		      ld    (free_list+2), HL 
10c2			 
10c2			      ; Insert first free block at bottom of heap, consumes entire heap 
10c2 21 22 ee		      ld    HL, heap_start+heap_size-4 
10c5 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
10c8 21 14 6e		      ld    HL, heap_size-4 
10cb 22 10 80		      ld    (heap_start+2), HL      ; Block size 
10ce			 
10ce			      ; Insert end of free list block at top of heap - two null words will 
10ce			      ; terminate the free list 
10ce 21 00 00		      ld    HL, 0 
10d1 22 24 ee		      ld    (heap_start+heap_size-2), HL 
10d4 22 22 ee		      ld    (heap_start+heap_size-4), HL 
10d7			 
10d7 e1			      pop   HL 
10d8			 
10d8 c9			      ret 
10d9			 
10d9			 
10d9			;------------------------------------------------------------------------------ 
10d9			;     malloc                                                                  : 
10d9			;                                                                             : 
10d9			; Description                                                                 : 
10d9			;     Allocates the wanted space from the heap and returns the address of the : 
10d9			;     first useable byte of the allocation.                                   : 
10d9			;                                                                             : 
10d9			;     Allocations can happen in one of two ways:                              : 
10d9			;                                                                             : 
10d9			;     1. A free block may be found which is the exact size wanted. In this    : 
10d9			;        case the block is removed from the free list and retuedn to the      : 
10d9			;        caller.                                                              : 
10d9			;     2. A free block may be found which is larger than the size wanted. In   : 
10d9			;        this case, the larger block is split into two. The first portion of  : 
10d9			;        this block will become the requested space by the malloc call and    : 
10d9			;        is returned to the caller. The second portion becomes a new free     : 
10d9			;        block, and the free list is adjusted to maintain continuity via this : 
10d9			;        newly created block.                                                 : 
10d9			;                                                                             : 
10d9			;     malloc does not set any initial value in the allocated space, the       : 
10d9			;     caller is required to do this as required.                              : 
10d9			;                                                                             : 
10d9			;     This implementation of malloc uses the stack exclusively, and is        : 
10d9			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
10d9			;     advisable to disable interrupts before calling malloc, and recommended  : 
10d9			;     to avoid the use of malloc inside ISRs in general.                      : 
10d9			;                                                                             : 
10d9			;     NOTE: heap_init must be called before malloc and free can be used.      : 
10d9			;                                                                             : 
10d9			; Parameters                                                                  : 
10d9			;     HL  Number of bytes wanted                                              : 
10d9			;                                                                             : 
10d9			; Returns                                                                     : 
10d9			;     HL  Address of the first useable byte of the allocation                 : 
10d9			;                                                                             : 
10d9			; Flags                                                                       : 
10d9			;     Z   Set if the allocation did not succeed, clear otherwise              : 
10d9			;                                                                             : 
10d9			; Stack frame                                                                 : 
10d9			;       |             |                                                       : 
10d9			;       +-------------+                                                       : 
10d9			;       |     BC      |                                                       : 
10d9			;       +-------------+                                                       : 
10d9			;       |     DE      |                                                       : 
10d9			;       +-------------+                                                       : 
10d9			;       |     IX      |                                                       : 
10d9			;       +-------------+                                                       : 
10d9			;       |  prev_free  |                                                       : 
10d9			;   +4  +-------------+                                                       : 
10d9			;       |  this_free  |                                                       : 
10d9			;   +2  +-------------+                                                       : 
10d9			;       |  next_free  |                                                       : 
10d9			;   +0  +-------------+                                                       : 
10d9			;       |             |                                                       : 
10d9			;                                                                             : 
10d9			;------------------------------------------------------------------------------ 
10d9			 
10d9			 
10d9			;malloc: 
10d9			; 
10d9			;	SAVESP ON 1 
10d9			; 
10d9			;	call malloc_code 
10d9			; 
10d9			;	CHECKSP ON 1 
10d9			;	ret 
10d9			 
10d9			 
10d9			malloc: 
10d9 c5			      push  BC 
10da d5			      push  DE 
10db dd e5		      push  IX 
10dd			if DEBUG_FORTH_MALLOC_HIGH 
10dd			call malloc_guard_entry 
10dd			endif 
10dd			 
10dd					if DEBUG_FORTH_MALLOC 
10dd						DMARK "mal" 
10dd						CALLMONITOR 
10dd					endif 
10dd 7c			      ld    A, H                    ; Exit if no space requested 
10de b5			      or    L 
10df ca 9e 11		      jp    Z, malloc_early_exit 
10e2			 
10e2			;inc hl 
10e2			;inc hl 
10e2			;inc hl 
10e2			; 
10e2			;inc hl 
10e2			;inc hl 
10e2			;inc hl 
10e2			;inc hl 
10e2			;inc hl 
10e2			;inc hl 
10e2			;inc hl 
10e2			;inc hl 
10e2			;inc hl 
10e2			 
10e2			 
10e2			 
10e2			 
10e2					if DEBUG_FORTH_MALLOC 
10e2						DMARK "maA" 
10e2						CALLMONITOR 
10e2					endif 
10e2			      ; Set up stack frame 
10e2 eb			      ex    DE, HL 
10e3 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
10e6 39			      add   HL, SP 
10e7 f9			      ld    SP, HL 
10e8 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
10ec dd 39		      add   IX, SP 
10ee			 
10ee			      ; Setup initial state 
10ee 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
10f1 19			      add   HL, DE 
10f2			 
10f2 44			      ld    B, H                    ; Move want to BC 
10f3 4d			      ld    C, L 
10f4			 
10f4 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
10f7 dd 75 04		      ld    (IX+4), L 
10fa dd 74 05		      ld    (IX+5), H 
10fd			 
10fd 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
10fe 23			      inc   HL 
10ff 56			      ld    D, (HL) 
1100 dd 73 02		      ld    (IX+2), E 
1103 dd 72 03		      ld    (IX+3), D 
1106 eb			      ex    DE, HL                  ; this_free ptr into HL 
1107			 
1107					if DEBUG_FORTH_MALLOC 
1107						DMARK "maB" 
1107						CALLMONITOR 
1107					endif 
1107			      ; Loop through free block list to find some space 
1107			malloc_find_space: 
1107 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
1108 23			      inc   HL 
1109 56			      ld    D, (HL) 
110a			 
110a 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
110b b3			      or    E 
110c ca 98 11		      jp    Z, malloc_no_space 
110f			 
110f dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
1112 dd 72 01		      ld    (IX+1), D 
1115			 
1115			      ; Does this block have enough space to make the allocation? 
1115 23			      inc   HL                      ; Load free block size into DE 
1116 5e			      ld    E, (HL) 
1117 23			      inc   HL 
1118 56			      ld    D, (HL) 
1119			 
1119 eb			      ex    DE, HL                  ; Check size of block against want 
111a b7			      or    A                       ; Ensure carry flag clear 
111b ed 42		      sbc   HL, BC 
111d e5			      push  HL                      ; Store the result for later (new block size) 
111e			 
111e ca 6d 11		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1121 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1123			 
1123			      ; this_free block is not big enough, setup ptrs to test next free block 
1123 e1			      pop   HL                      ; Discard previous result 
1124			 
1124 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1127 dd 66 03		      ld    H, (IX+3) 
112a dd 75 04		      ld    (IX+4), L 
112d dd 74 05		      ld    (IX+5), H 
1130			 
1130 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1133 dd 66 01		      ld    H, (IX+1) 
1136 dd 75 02		      ld    (IX+2), L 
1139 dd 74 03		      ld    (IX+3), H 
113c			 
113c					if DEBUG_FORTH_MALLOC 
113c						DMARK "MA>" 
113c						CALLMONITOR 
113c					endif 
113c 18 c9		      jr    malloc_find_space 
113e			 
113e			      ; split a bigger block into two - requested size and remaining size 
113e			malloc_alloc_split: 
113e					if DEBUG_FORTH_MALLOC 
113e						DMARK "MAs" 
113e						CALLMONITOR 
113e					endif 
113e eb			      ex    DE, HL                  ; Calculate address of new free block 
113f 2b			      dec   HL 
1140 2b			      dec   HL 
1141 2b			      dec   HL 
1142 09			      add   HL, BC 
1143			 
1143			      ; Create a new block and point it at next_free 
1143 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
1146 dd 56 01		      ld    D, (IX+1) 
1149			 
1149 73			      ld    (HL), E                 ; Store next_free ptr into new block 
114a 23			      inc   HL 
114b 72			      ld    (HL), D 
114c			 
114c d1			      pop   DE                      ; Store size of new block into new block 
114d 23			      inc   HL 
114e 73			      ld    (HL), E 
114f 23			      inc   HL 
1150 72			      ld    (HL), D 
1151			 
1151			      ; Update this_free ptr to point to new block 
1151 2b			      dec   HL 
1152 2b			      dec   HL 
1153 2b			      dec   HL 
1154			 
1154 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1157 dd 56 03		      ld    D, (IX+3) 
115a			 
115a dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
115d dd 74 03		      ld    (IX+3), H 
1160			 
1160			      ; Modify this_free block to be allocation 
1160 eb			      ex    DE, HL 
1161 af			      xor   A                       ; Null the next block ptr of allocated block 
1162 77			      ld    (HL), A 
1163 23			      inc   HL 
1164 77			      ld    (HL), A 
1165			 
1165 23			      inc   HL                      ; Store want size into allocated block 
1166 71			      ld    (HL), C 
1167 23			      inc   HL 
1168 70			      ld    (HL), B 
1169 23			      inc   HL 
116a e5			      push  HL                      ; Address of allocation to return 
116b			 
116b 18 19		      jr    malloc_update_links 
116d			 
116d			malloc_alloc_fit: 
116d e1			      pop   HL                      ; Dont need new block size, want is exact fit 
116e			 
116e					if DEBUG_FORTH_MALLOC 
116e						DMARK "MAf" 
116e						CALLMONITOR 
116e					endif 
116e			      ; Modify this_free block to be allocation 
116e eb			      ex    DE, HL 
116f 2b			      dec   HL 
1170 2b			      dec   HL 
1171 2b			      dec   HL 
1172			 
1172 af			      xor   A                       ; Null the next block ptr of allocated block 
1173 77			      ld    (HL), A 
1174 23			      inc   HL 
1175 77			      ld    (HL), A 
1176			 
1176 23			      inc   HL                      ; Store address of allocation to return 
1177 23			      inc   HL 
1178 23			      inc   HL 
1179 e5			      push  HL 
117a			 
117a			      ; Copy next_free ptr to this_free, remove allocated block from free list 
117a dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
117d dd 66 01		      ld    H, (IX+1) 
1180			 
1180 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1183 dd 74 03		      ld    (IX+3), H 
1186			 
1186			 
1186			malloc_update_links: 
1186			      ; Update prev_free ptr to point to this_free 
1186 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1189 dd 66 05		      ld    H, (IX+5) 
118c			 
118c dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
118f dd 56 03		      ld    D, (IX+3) 
1192			 
1192 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1193 23			      inc   HL 
1194 72			      ld    (HL), D 
1195			 
1195					if DEBUG_FORTH_MALLOC 
1195						DMARK "Mul" 
1195						CALLMONITOR 
1195					endif 
1195			      ; Clear the Z flag to indicate successful allocation 
1195 7a			      ld    A, D 
1196 b3			      or    E 
1197			 
1197 d1			      pop   DE                      ; Address of allocation 
1198					if DEBUG_FORTH_MALLOC 
1198						DMARK "MAu" 
1198						CALLMONITOR 
1198					endif 
1198			 
1198			malloc_no_space: 
1198 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
119b 39			      add   HL, SP 
119c f9			      ld    SP, HL 
119d			 
119d eb			      ex    DE, HL                  ; Alloc addr into HL for return 
119e					if DEBUG_FORTH_MALLOC 
119e						DMARK "MAN" 
119e						CALLMONITOR 
119e					endif 
119e			 
119e			malloc_early_exit: 
119e					if DEBUG_FORTH_MALLOC 
119e						DMARK "MAx" 
119e						CALLMONITOR 
119e					endif 
119e dd e1		      pop   IX 
11a0 d1			      pop   DE 
11a1 c1			      pop   BC 
11a2			 
11a2			if DEBUG_FORTH_MALLOC_HIGH 
11a2			call malloc_guard_exit 
11a2			call malloc_guard_zerolen 
11a2			endif 
11a2 c9			      ret 
11a3			 
11a3			 
11a3			;------------------------------------------------------------------------------ 
11a3			;     free                                                                    : 
11a3			;                                                                             : 
11a3			; Description                                                                 : 
11a3			;     Return the space pointed to by HL to the heap. HL must be an address as : 
11a3			;     returned by malloc, otherwise the behaviour is undefined.               : 
11a3			;                                                                             : 
11a3			;     Where possible, directly adjacent free blocks will be merged together   : 
11a3			;     into larger blocks to help ensure that the heap does not become         : 
11a3			;     excessively fragmented.                                                 : 
11a3			;                                                                             : 
11a3			;     free does not clear or set any other value into the freed space, and    : 
11a3			;     therefore its contents may be visible through subsequent malloc's. The  : 
11a3			;     caller should clear the freed space as required.                        : 
11a3			;                                                                             : 
11a3			;     This implementation of free uses the stack exclusively, and is          : 
11a3			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
11a3			;     advisable to disable interrupts before calling free, and recommended    : 
11a3			;     to avoid the use of free inside ISRs in general.                        : 
11a3			;                                                                             : 
11a3			;     NOTE: heap_init must be called before malloc and free can be used.      : 
11a3			;                                                                             : 
11a3			; Parameters                                                                  : 
11a3			;     HL  Pointer to address of first byte of allocation to be freed          : 
11a3			;                                                                             : 
11a3			; Returns                                                                     : 
11a3			;     Nothing                                                                 : 
11a3			;                                                                             : 
11a3			; Stack frame                                                                 : 
11a3			;       |             |                                                       : 
11a3			;       +-------------+                                                       : 
11a3			;       |     BC      |                                                       : 
11a3			;       +-------------+                                                       : 
11a3			;       |     DE      |                                                       : 
11a3			;       +-------------+                                                       : 
11a3			;       |     IX      |                                                       : 
11a3			;       +-------------+                                                       : 
11a3			;       |  prev_free  |                                                       : 
11a3			;   +2  +-------------+                                                       : 
11a3			;       |  next_free  |                                                       : 
11a3			;   +0  +-------------+                                                       : 
11a3			;       |             |                                                       : 
11a3			;                                                                             : 
11a3			;------------------------------------------------------------------------------ 
11a3			free: 
11a3 c5			      push  BC 
11a4 d5			      push  DE 
11a5 dd e5		      push  IX 
11a7			 
11a7 7c			      ld    A, H                    ; Exit if ptr is null 
11a8 b5			      or    L 
11a9 ca 6d 12		      jp    Z, free_early_exit 
11ac			 
11ac			      ; Set up stack frame 
11ac eb			      ex    DE, HL 
11ad 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
11b0 39			      add   HL, SP 
11b1 f9			      ld    SP, HL 
11b2 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
11b6 dd 39		      add   IX, SP 
11b8			 
11b8			      ; The address in HL points to the start of the useable allocated space, 
11b8			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
11b8			      ; address of the block itself. 
11b8 eb			      ex    DE, HL 
11b9 11 fc ff		      ld    DE, -4 
11bc 19			      add   HL, DE 
11bd			 
11bd			      ; An allocated block must have a null next block pointer in it 
11bd 7e			      ld    A, (HL) 
11be 23			      inc   HL 
11bf b6			      or    (HL) 
11c0 c2 68 12		      jp    NZ, free_done 
11c3			 
11c3 2b			      dec   HL 
11c4			 
11c4 44			      ld    B, H                    ; Copy HL to BC 
11c5 4d			      ld    C, L 
11c6			 
11c6			      ; Loop through the free list to find the first block with an address 
11c6			      ; higher than the block being freed 
11c6 21 0a 80		      ld    HL, free_list 
11c9			 
11c9			free_find_higher_block: 
11c9 5e			      ld    E, (HL)                 ; Load next ptr from free block 
11ca 23			      inc   HL 
11cb 56			      ld    D, (HL) 
11cc 2b			      dec   HL 
11cd			 
11cd dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
11d0 dd 72 01		      ld    (IX+1), D 
11d3 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
11d6 dd 74 03		      ld    (IX+3), H 
11d9			 
11d9 78			      ld    A, B                    ; Check if DE is greater than BC 
11da ba			      cp    D                       ; Compare MSB first 
11db 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
11dd 30 04		      jr    NC, free_find_higher_block_skip 
11df 79			      ld    A, C 
11e0 bb			      cp    E                       ; Then compare LSB 
11e1 38 08		      jr    C, free_found_higher_block 
11e3			 
11e3			free_find_higher_block_skip: 
11e3 7a			      ld    A, D                    ; Reached the end of the free list? 
11e4 b3			      or    E 
11e5 ca 68 12		      jp    Z, free_done 
11e8			 
11e8 eb			      ex    DE, HL 
11e9			 
11e9 18 de		      jr    free_find_higher_block 
11eb			 
11eb			free_found_higher_block: 
11eb			      ; Insert freed block between prev and next free blocks 
11eb 71			      ld    (HL), C                 ; Point prev free block to freed block 
11ec 23			      inc   HL 
11ed 70			      ld    (HL), B 
11ee			 
11ee 60			      ld    H, B                    ; Point freed block at next free block 
11ef 69			      ld    L, C 
11f0 73			      ld    (HL), E 
11f1 23			      inc   HL 
11f2 72			      ld    (HL), D 
11f3			 
11f3			      ; Check if the freed block is adjacent to the next free block 
11f3 23			      inc   HL                      ; Load size of freed block into HL 
11f4 5e			      ld    E, (HL) 
11f5 23			      inc   HL 
11f6 56			      ld    D, (HL) 
11f7 eb			      ex    DE, HL 
11f8			 
11f8 09			      add   HL, BC                  ; Add addr of freed block and its size 
11f9			 
11f9 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
11fc dd 56 01		      ld    D, (IX+1) 
11ff			 
11ff b7			      or    A                       ; Clear the carry flag 
1200 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1202 20 22		      jr    NZ, free_check_adjacent_to_prev 
1204			 
1204			      ; Freed block is adjacent to next, merge into one bigger block 
1204 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
1205 5e			      ld    E, (HL) 
1206 23			      inc   HL 
1207 56			      ld    D, (HL) 
1208 e5			      push  HL                      ; Save ptr to next block for later 
1209			 
1209 60			      ld    H, B                    ; Store ptr from next block into freed block 
120a 69			      ld    L, C 
120b 73			      ld    (HL), E 
120c 23			      inc   HL 
120d 72			      ld    (HL), D 
120e			 
120e e1			      pop   HL                      ; Restore ptr to next block 
120f 23			      inc   HL                      ; Load size of next block into DE 
1210 5e			      ld    E, (HL) 
1211 23			      inc   HL 
1212 56			      ld    D, (HL) 
1213 d5			      push  DE                      ; Save next block size for later 
1214			 
1214 60			      ld    H, B                    ; Load size of freed block into HL 
1215 69			      ld    L, C 
1216 23			      inc   HL 
1217 23			      inc   HL 
1218 5e			      ld    E, (HL) 
1219 23			      inc   HL 
121a 56			      ld    D, (HL) 
121b eb			      ex    DE, HL 
121c			 
121c d1			      pop   DE                      ; Restore size of next block 
121d 19			      add   HL, DE                  ; Add sizes of both blocks 
121e eb			      ex    DE, HL 
121f			 
121f 60			      ld    H, B                    ; Store new bigger size into freed block 
1220 69			      ld    L, C 
1221 23			      inc   HL 
1222 23			      inc   HL 
1223 73			      ld    (HL), E 
1224 23			      inc   HL 
1225 72			      ld    (HL), D 
1226			 
1226			free_check_adjacent_to_prev: 
1226			      ; Check if the freed block is adjacent to the prev free block 
1226 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
1229 dd 66 03		      ld    H, (IX+3) 
122c			 
122c 23			      inc   HL                      ; Size of prev free block into DE 
122d 23			      inc   HL 
122e 5e			      ld    E, (HL) 
122f 23			      inc   HL 
1230 56			      ld    D, (HL) 
1231 2b			      dec   HL 
1232 2b			      dec   HL 
1233 2b			      dec   HL 
1234			 
1234 19			      add   HL, DE                  ; Add prev block addr and size 
1235			 
1235 b7			      or    A                       ; Clear the carry flag 
1236 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1238 20 2e		      jr    NZ, free_done 
123a			 
123a			      ; Freed block is adjacent to prev, merge into one bigger block 
123a 60			      ld    H, B                    ; Load next ptr from freed block into DE 
123b 69			      ld    L, C 
123c 5e			      ld    E, (HL) 
123d 23			      inc   HL 
123e 56			      ld    D, (HL) 
123f e5			      push  HL                      ; Save freed block ptr for later 
1240			 
1240 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1243 dd 66 03		      ld    H, (IX+3) 
1246 73			      ld    (HL), E 
1247 23			      inc   HL 
1248 72			      ld    (HL), D 
1249			 
1249 e1			      pop   HL                      ; Restore freed block ptr 
124a 23			      inc   HL                      ; Load size of freed block into DE 
124b 5e			      ld    E, (HL) 
124c 23			      inc   HL 
124d 56			      ld    D, (HL) 
124e d5			      push  DE                      ; Save freed block size for later 
124f			 
124f dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1252 dd 66 03		      ld    H, (IX+3) 
1255 23			      inc   HL 
1256 23			      inc   HL 
1257 5e			      ld    E, (HL) 
1258 23			      inc   HL 
1259 56			      ld    D, (HL) 
125a			 
125a e1			      pop   HL                      ; Add sizes of both blocks 
125b 19			      add   HL, DE 
125c eb			      ex    DE, HL 
125d			 
125d dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1260 dd 66 03		      ld    H, (IX+3) 
1263 23			      inc   HL 
1264 23			      inc   HL 
1265 73			      ld    (HL), E 
1266 23			      inc   HL 
1267 72			      ld    (HL), D 
1268			 
1268			free_done: 
1268 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
126b 39			      add   HL, SP 
126c f9			      ld    SP, HL 
126d			 
126d			free_early_exit: 
126d dd e1		      pop   IX 
126f d1			      pop   DE 
1270 c1			      pop   BC 
1271			 
1271 c9			      ret 
1272			 
1272			; moved to firmware.asm 
1272			; 
1272			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1272			;                  .dw   0 
1272			 
1272			 
1272			endif 
1272			 
1272			 
1272			if MALLOC_3 
1272			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1272			;heap_start        .equ  0x9000      ; Starting address of heap 
1272			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1272			; 
1272			 ;     .org 0 
1272			  ;    jp    main 
1272			; 
1272			; 
1272			 ;     .org  0x100 
1272			;main: 
1272			 ;     ld    HL, 0x8100 
1272			  ;    ld    SP, HL 
1272			; 
1272			;      call  heap_init 
1272			 
1272			      ; Make some allocations 
1272			;      ld    HL, 12 
1272			;      call  malloc            ; Allocates 0x9004 
1272			; 
1272			 ;     ld    HL, 12 
1272			;      call  malloc            ; Allocates 0x9014 
1272			 
1272			;      ld    HL, 12 
1272			;      call  malloc            ; Allocates 0x9024 
1272			 
1272			      ; Free some allocations 
1272			;      ld    HL, 0x9014 
1272			;      call  free 
1272			 
1272			;      ld    HL, 0x9004 
1272			;      call  free 
1272			; 
1272			;      ld    HL, 0x9024 
1272			;      call  free 
1272			 
1272			 
1272			 ;     halt 
1272			 
1272			 
1272			;------------------------------------------------------------------------------ 
1272			;     heap_init                                                               : 
1272			;                                                                             : 
1272			; Description                                                                 : 
1272			;     Initialise the heap and make it ready for malloc and free operations.   : 
1272			;                                                                             : 
1272			;     The heap is maintained as a linked list, starting with an initial       : 
1272			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1272			;     the first free block in the heap. Each block then points to the next    : 
1272			;     free block within the heap, and the free list ends at the first block   : 
1272			;     with a null pointer to the next free block.                             : 
1272			;                                                                             : 
1272			; Parameters                                                                  : 
1272			;     Inputs are compile-time only. Two defines which specify the starting    : 
1272			;     address of the heap and its size are required, along with a memory      : 
1272			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1272			;     principally stores a pointer to the first free block in the heap.       : 
1272			;                                                                             : 
1272			; Returns                                                                     : 
1272			;     Nothing                                                                 : 
1272			;------------------------------------------------------------------------------ 
1272			heap_init: 
1272			      push  HL 
1272			 
1272			      ; Initialise free list struct 
1272			      ld    HL, heap_start 
1272			      ld    (free_list), HL 
1272			      ld    HL, 0 
1272			      ld    (free_list+2), HL 
1272			 
1272			      ; Insert first free block at bottom of heap, consumes entire heap 
1272			      ld    HL, heap_start+heap_size-4 
1272			      ld    (heap_start), HL        ; Next block (end of free list) 
1272			      ld    HL, heap_size-4 
1272			      ld    (heap_start+2), HL      ; Block size 
1272			 
1272			      ; Insert end of free list block at top of heap - two null words will 
1272			      ; terminate the free list 
1272			      ld    HL, 0 
1272			      ld    (heap_start+heap_size-2), HL 
1272			      ld    (heap_start+heap_size-4), HL 
1272			 
1272			      pop   HL 
1272			 
1272			      ret 
1272			 
1272			 
1272			;------------------------------------------------------------------------------ 
1272			;     malloc                                                                  : 
1272			;                                                                             : 
1272			; Description                                                                 : 
1272			;     Allocates the wanted space from the heap and returns the address of the : 
1272			;     first useable byte of the allocation.                                   : 
1272			;                                                                             : 
1272			;     Allocations can happen in one of two ways:                              : 
1272			;                                                                             : 
1272			;     1. A free block may be found which is the exact size wanted. In this    : 
1272			;        case the block is removed from the free list and retuedn to the      : 
1272			;        caller.                                                              : 
1272			;     2. A free block may be found which is larger than the size wanted. In   : 
1272			;        this case, the larger block is split into two. The first portion of  : 
1272			;        this block will become the requested space by the malloc call and    : 
1272			;        is returned to the caller. The second portion becomes a new free     : 
1272			;        block, and the free list is adjusted to maintain continuity via this : 
1272			;        newly created block.                                                 : 
1272			;                                                                             : 
1272			;     malloc does not set any initial value in the allocated space, the       : 
1272			;     caller is required to do this as required.                              : 
1272			;                                                                             : 
1272			;     This implementation of malloc uses the stack exclusively, and is        : 
1272			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1272			;     advisable to disable interrupts before calling malloc, and recommended  : 
1272			;     to avoid the use of malloc inside ISRs in general.                      : 
1272			;                                                                             : 
1272			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1272			;                                                                             : 
1272			; Parameters                                                                  : 
1272			;     HL  Number of bytes wanted                                              : 
1272			;                                                                             : 
1272			; Returns                                                                     : 
1272			;     HL  Address of the first useable byte of the allocation                 : 
1272			;                                                                             : 
1272			; Flags                                                                       : 
1272			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1272			;                                                                             : 
1272			; Stack frame                                                                 : 
1272			;       |             |                                                       : 
1272			;       +-------------+                                                       : 
1272			;       |     BC      |                                                       : 
1272			;       +-------------+                                                       : 
1272			;       |     DE      |                                                       : 
1272			;       +-------------+                                                       : 
1272			;       |     IX      |                                                       : 
1272			;       +-------------+                                                       : 
1272			;       |  prev_free  |                                                       : 
1272			;   +4  +-------------+                                                       : 
1272			;       |  this_free  |                                                       : 
1272			;   +2  +-------------+                                                       : 
1272			;       |  next_free  |                                                       : 
1272			;   +0  +-------------+                                                       : 
1272			;       |             |                                                       : 
1272			;                                                                             : 
1272			;------------------------------------------------------------------------------ 
1272			malloc: 
1272			      push  BC 
1272			      push  DE 
1272			      push  IX 
1272			 
1272			      ld    A, H                    ; Exit if no space requested 
1272			      or    L 
1272			      jp    Z, malloc_early_exit 
1272			 
1272			      ; Set up stack frame 
1272			      ex    DE, HL 
1272			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1272			      add   HL, SP 
1272			      ld    SP, HL 
1272			      ld    IX, 0                   ; Use IX as a frame pointer 
1272			      add   IX, SP 
1272			 
1272			      ; Setup initial state 
1272			      ld    HL, 4                   ; want must also include space used by block struct 
1272			      add   HL, DE 
1272			 
1272			      ld    B, H                    ; Move want to BC 
1272			      ld    C, L 
1272			 
1272			      ld    HL, free_list           ; Store prev_free ptr to stack 
1272			      ld    (IX+4), L 
1272			      ld    (IX+5), H 
1272			 
1272			      ld    E, (HL)                 ; Store this_free ptr to stack 
1272			      inc   HL 
1272			      ld    D, (HL) 
1272			      ld    (IX+2), E 
1272			      ld    (IX+3), D 
1272			      ex    DE, HL                  ; this_free ptr into HL 
1272			 
1272			      ; Loop through free block list to find some space 
1272			malloc_find_space: 
1272			      ld    E, (HL)                 ; Load next_free ptr into DE 
1272			      inc   HL 
1272			      ld    D, (HL) 
1272			 
1272			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1272			      or    E 
1272			      jp    Z, malloc_no_space 
1272			 
1272			      ld    (IX+0), E               ; Store next_free ptr to stack 
1272			      ld    (IX+1), D 
1272			 
1272			      ; Does this block have enough space to make the allocation? 
1272			      inc   HL                      ; Load free block size into DE 
1272			      ld    E, (HL) 
1272			      inc   HL 
1272			      ld    D, (HL) 
1272			 
1272			      ex    DE, HL                  ; Check size of block against want 
1272			      or    A                       ; Ensure carry flag clear 
1272			      sbc   HL, BC 
1272			      push  HL                      ; Store the result for later (new block size) 
1272			 
1272			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1272			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1272			 
1272			      ; this_free block is not big enough, setup ptrs to test next free block 
1272			      pop   HL                      ; Discard previous result 
1272			 
1272			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1272			      ld    H, (IX+3) 
1272			      ld    (IX+4), L 
1272			      ld    (IX+5), H 
1272			 
1272			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1272			      ld    H, (IX+1) 
1272			      ld    (IX+2), L 
1272			      ld    (IX+3), H 
1272			 
1272			      jr    malloc_find_space 
1272			 
1272			      ; split a bigger block into two - requested size and remaining size 
1272			malloc_alloc_split: 
1272			      ex    DE, HL                  ; Calculate address of new free block 
1272			      dec   HL 
1272			      dec   HL 
1272			      dec   HL 
1272			      add   HL, BC 
1272			 
1272			      ; Create a new block and point it at next_free 
1272			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1272			      ld    D, (IX+1) 
1272			 
1272			      ld    (HL), E                 ; Store next_free ptr into new block 
1272			      inc   HL 
1272			      ld    (HL), D 
1272			 
1272			      pop   DE                      ; Store size of new block into new block 
1272			      inc   HL 
1272			      ld    (HL), E 
1272			      inc   HL 
1272			      ld    (HL), D 
1272			 
1272			      ; Update this_free ptr to point to new block 
1272			      dec   HL 
1272			      dec   HL 
1272			      dec   HL 
1272			 
1272			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1272			      ld    D, (IX+3) 
1272			 
1272			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1272			      ld    (IX+3), H 
1272			 
1272			      ; Modify this_free block to be allocation 
1272			      ex    DE, HL 
1272			      xor   A                       ; Null the next block ptr of allocated block 
1272			      ld    (HL), A 
1272			      inc   HL 
1272			      ld    (HL), A 
1272			 
1272			      inc   HL                      ; Store want size into allocated block 
1272			      ld    (HL), C 
1272			      inc   HL 
1272			      ld    (HL), B 
1272			      inc   HL 
1272			      push  HL                      ; Address of allocation to return 
1272			 
1272			      jr    malloc_update_links 
1272			 
1272			malloc_alloc_fit: 
1272			      pop   HL                      ; Dont need new block size, want is exact fit 
1272			 
1272			      ; Modify this_free block to be allocation 
1272			      ex    DE, HL 
1272			      dec   HL 
1272			      dec   HL 
1272			      dec   HL 
1272			 
1272			      xor   A                       ; Null the next block ptr of allocated block 
1272			      ld    (HL), A 
1272			      inc   HL 
1272			      ld    (HL), A 
1272			 
1272			      inc   HL                      ; Store address of allocation to return 
1272			      inc   HL 
1272			      inc   HL 
1272			      push  HL 
1272			 
1272			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1272			      ld    L, (IX+0)               ; next_free to HL 
1272			      ld    H, (IX+1) 
1272			 
1272			      ld    (IX+2), L               ; HL to this_free 
1272			      ld    (IX+3), H 
1272			 
1272			 
1272			malloc_update_links: 
1272			      ; Update prev_free ptr to point to this_free 
1272			      ld    L, (IX+4)               ; prev_free ptr to HL 
1272			      ld    H, (IX+5) 
1272			 
1272			      ld    E, (IX+2)               ; this_free ptr to DE 
1272			      ld    D, (IX+3) 
1272			 
1272			      ld    (HL), E                 ; this_free ptr into prev_free 
1272			      inc   HL 
1272			      ld    (HL), D 
1272			 
1272			      ; Clear the Z flag to indicate successful allocation 
1272			      ld    A, D 
1272			      or    E 
1272			 
1272			      pop   DE                      ; Address of allocation 
1272			 
1272			malloc_no_space: 
1272			      ld    HL, 6                   ; Clean up stack frame 
1272			      add   HL, SP 
1272			      ld    SP, HL 
1272			 
1272			      ex    DE, HL                  ; Alloc addr into HL for return 
1272			 
1272			malloc_early_exit: 
1272			      pop   IX 
1272			      pop   DE 
1272			      pop   BC 
1272			 
1272			      ret 
1272			 
1272			 
1272			;------------------------------------------------------------------------------ 
1272			;     free                                                                    : 
1272			;                                                                             : 
1272			; Description                                                                 : 
1272			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1272			;     returned by malloc, otherwise the behaviour is undefined.               : 
1272			;                                                                             : 
1272			;     Where possible, directly adjacent free blocks will be merged together   : 
1272			;     into larger blocks to help ensure that the heap does not become         : 
1272			;     excessively fragmented.                                                 : 
1272			;                                                                             : 
1272			;     free does not clear or set any other value into the freed space, and    : 
1272			;     therefore its contents may be visible through subsequent malloc's. The  : 
1272			;     caller should clear the freed space as required.                        : 
1272			;                                                                             : 
1272			;     This implementation of free uses the stack exclusively, and is          : 
1272			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1272			;     advisable to disable interrupts before calling free, and recommended    : 
1272			;     to avoid the use of free inside ISRs in general.                        : 
1272			;                                                                             : 
1272			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1272			;                                                                             : 
1272			; Parameters                                                                  : 
1272			;     HL  Pointer to address of first byte of allocation to be freed          : 
1272			;                                                                             : 
1272			; Returns                                                                     : 
1272			;     Nothing                                                                 : 
1272			;                                                                             : 
1272			; Stack frame                                                                 : 
1272			;       |             |                                                       : 
1272			;       +-------------+                                                       : 
1272			;       |     BC      |                                                       : 
1272			;       +-------------+                                                       : 
1272			;       |     DE      |                                                       : 
1272			;       +-------------+                                                       : 
1272			;       |     IX      |                                                       : 
1272			;       +-------------+                                                       : 
1272			;       |  prev_free  |                                                       : 
1272			;   +2  +-------------+                                                       : 
1272			;       |  next_free  |                                                       : 
1272			;   +0  +-------------+                                                       : 
1272			;       |             |                                                       : 
1272			;                                                                             : 
1272			;------------------------------------------------------------------------------ 
1272			free: 
1272			      push  BC 
1272			      push  DE 
1272			      push  IX 
1272			 
1272			      ld    A, H                    ; Exit if ptr is null 
1272			      or    L 
1272			      jp    Z, free_early_exit 
1272			 
1272			      ; Set up stack frame 
1272			      ex    DE, HL 
1272			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1272			      add   HL, SP 
1272			      ld    SP, HL 
1272			      ld    IX, 0                   ; Use IX as a frame pointer 
1272			      add   IX, SP 
1272			 
1272			      ; The address in HL points to the start of the useable allocated space, 
1272			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1272			      ; address of the block itself. 
1272			      ex    DE, HL 
1272			      ld    DE, -4 
1272			      add   HL, DE 
1272			 
1272			      ; An allocated block must have a null next block pointer in it 
1272			      ld    A, (HL) 
1272			      inc   HL 
1272			      or    (HL) 
1272			      jp    NZ, free_done 
1272			 
1272			      dec   HL 
1272			 
1272			      ld    B, H                    ; Copy HL to BC 
1272			      ld    C, L 
1272			 
1272			      ; Loop through the free list to find the first block with an address 
1272			      ; higher than the block being freed 
1272			      ld    HL, free_list 
1272			 
1272			free_find_higher_block: 
1272			      ld    E, (HL)                 ; Load next ptr from free block 
1272			      inc   HL 
1272			      ld    D, (HL) 
1272			      dec   HL 
1272			 
1272			      ld    (IX+0), E               ; Save ptr to next free block 
1272			      ld    (IX+1), D 
1272			      ld    (IX+2), L               ; Save ptr to prev free block 
1272			      ld    (IX+3), H 
1272			 
1272			      ld    A, B                    ; Check if DE is greater than BC 
1272			      cp    D                       ; Compare MSB first 
1272			      jr    Z, $+4                  ; MSB the same, compare LSB 
1272			      jr    NC, free_find_higher_block_skip 
1272			      ld    A, C 
1272			      cp    E                       ; Then compare LSB 
1272			      jr    C, free_found_higher_block 
1272			 
1272			free_find_higher_block_skip: 
1272			      ld    A, D                    ; Reached the end of the free list? 
1272			      or    E 
1272			      jp    Z, free_done 
1272			 
1272			      ex    DE, HL 
1272			 
1272			      jr    free_find_higher_block 
1272			 
1272			free_found_higher_block: 
1272			      ; Insert freed block between prev and next free blocks 
1272			      ld    (HL), C                 ; Point prev free block to freed block 
1272			      inc   HL 
1272			      ld    (HL), B 
1272			 
1272			      ld    H, B                    ; Point freed block at next free block 
1272			      ld    L, C 
1272			      ld    (HL), E 
1272			      inc   HL 
1272			      ld    (HL), D 
1272			 
1272			      ; Check if the freed block is adjacent to the next free block 
1272			      inc   HL                      ; Load size of freed block into HL 
1272			      ld    E, (HL) 
1272			      inc   HL 
1272			      ld    D, (HL) 
1272			      ex    DE, HL 
1272			 
1272			      add   HL, BC                  ; Add addr of freed block and its size 
1272			 
1272			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1272			      ld    D, (IX+1) 
1272			 
1272			      or    A                       ; Clear the carry flag 
1272			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1272			      jr    NZ, free_check_adjacent_to_prev 
1272			 
1272			      ; Freed block is adjacent to next, merge into one bigger block 
1272			      ex    DE, HL                  ; Load next ptr from next block into DE 
1272			      ld    E, (HL) 
1272			      inc   HL 
1272			      ld    D, (HL) 
1272			      push  HL                      ; Save ptr to next block for later 
1272			 
1272			      ld    H, B                    ; Store ptr from next block into freed block 
1272			      ld    L, C 
1272			      ld    (HL), E 
1272			      inc   HL 
1272			      ld    (HL), D 
1272			 
1272			      pop   HL                      ; Restore ptr to next block 
1272			      inc   HL                      ; Load size of next block into DE 
1272			      ld    E, (HL) 
1272			      inc   HL 
1272			      ld    D, (HL) 
1272			      push  DE                      ; Save next block size for later 
1272			 
1272			      ld    H, B                    ; Load size of freed block into HL 
1272			      ld    L, C 
1272			      inc   HL 
1272			      inc   HL 
1272			      ld    E, (HL) 
1272			      inc   HL 
1272			      ld    D, (HL) 
1272			      ex    DE, HL 
1272			 
1272			      pop   DE                      ; Restore size of next block 
1272			      add   HL, DE                  ; Add sizes of both blocks 
1272			      ex    DE, HL 
1272			 
1272			      ld    H, B                    ; Store new bigger size into freed block 
1272			      ld    L, C 
1272			      inc   HL 
1272			      inc   HL 
1272			      ld    (HL), E 
1272			      inc   HL 
1272			      ld    (HL), D 
1272			 
1272			free_check_adjacent_to_prev: 
1272			      ; Check if the freed block is adjacent to the prev free block 
1272			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1272			      ld    H, (IX+3) 
1272			 
1272			      inc   HL                      ; Size of prev free block into DE 
1272			      inc   HL 
1272			      ld    E, (HL) 
1272			      inc   HL 
1272			      ld    D, (HL) 
1272			      dec   HL 
1272			      dec   HL 
1272			      dec   HL 
1272			 
1272			      add   HL, DE                  ; Add prev block addr and size 
1272			 
1272			      or    A                       ; Clear the carry flag 
1272			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1272			      jr    NZ, free_done 
1272			 
1272			      ; Freed block is adjacent to prev, merge into one bigger block 
1272			      ld    H, B                    ; Load next ptr from freed block into DE 
1272			      ld    L, C 
1272			      ld    E, (HL) 
1272			      inc   HL 
1272			      ld    D, (HL) 
1272			      push  HL                      ; Save freed block ptr for later 
1272			 
1272			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1272			      ld    H, (IX+3) 
1272			      ld    (HL), E 
1272			      inc   HL 
1272			      ld    (HL), D 
1272			 
1272			      pop   HL                      ; Restore freed block ptr 
1272			      inc   HL                      ; Load size of freed block into DE 
1272			      ld    E, (HL) 
1272			      inc   HL 
1272			      ld    D, (HL) 
1272			      push  DE                      ; Save freed block size for later 
1272			 
1272			      ld    L, (IX+2)               ; Load size of prev block into DE 
1272			      ld    H, (IX+3) 
1272			      inc   HL 
1272			      inc   HL 
1272			      ld    E, (HL) 
1272			      inc   HL 
1272			      ld    D, (HL) 
1272			 
1272			      pop   HL                      ; Add sizes of both blocks 
1272			      add   HL, DE 
1272			      ex    DE, HL 
1272			 
1272			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1272			      ld    H, (IX+3) 
1272			      inc   HL 
1272			      inc   HL 
1272			      ld    (HL), E 
1272			      inc   HL 
1272			      ld    (HL), D 
1272			 
1272			free_done: 
1272			      ld    HL, 4                   ; Clean up stack frame 
1272			      add   HL, SP 
1272			      ld    SP, HL 
1272			 
1272			free_early_exit: 
1272			      pop   IX 
1272			      pop   DE 
1272			      pop   BC 
1272			 
1272			      ret 
1272			 
1272			 
1272			;      .org 0x8000 
1272			; 
1272			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1272			 ;                 .dw   0 
1272			 
1272			endif 
1272			 
1272			 
1272			if MALLOC_4 
1272			 
1272			; My memory allocation code. Very very simple.... 
1272			; allocate space under 250 chars 
1272			 
1272			heap_init: 
1272				; init start of heap as zero 
1272				;  
1272			 
1272				ld hl, heap_start 
1272				ld a, 0 
1272				ld (hl), a      ; empty block 
1272				inc hl 
1272				ld a, 0 
1272				ld (hl), a      ; length of block 
1272				; write end of list 
1272				inc hl 
1272				ld a,(hl) 
1272				inc hl 
1272				ld a,(hl) 
1272				 
1272			 
1272				; init some malloc vars 
1272			 
1272				ld hl, 0 
1272				ld (free_list), hl       ; store last malloc location 
1272			 
1272				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1272				ld a, 0 
1272				ld (hl), a 
1272			 
1272			 
1272				ld hl, heap_start 
1272				;  
1272				  
1272				ret 
1272			 
1272			 
1272			;    free block marker 
1272			;    requested size  
1272			;    pointer to next block 
1272			;    .... 
1272			;    next block marker 
1272			 
1272			 
1272			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1272			; 
1272			 
1272			 
1272			malloc:  
1272				push de 
1272				push bc 
1272				push af 
1272			 
1272				; hl space required 
1272				 
1272				ld c, l    ; hold space   (TODO only a max of 255) 
1272			 
1272			;	inc c     ; TODO BUG need to fix memory leak on push str 
1272			;	inc c 
1272			;	inc c 
1272			;	inc c 
1272			;	inc c 
1272			;	inc c 
1272			;	inc c 
1272			 
1272			 
1272			 
1272				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1272			 
1272				ld a, (free_list+3) 
1272				cp 0 
1272				jr z, .contheap 
1272			 
1272				ld hl, (free_list)     ; get last alloc 
1272					if DEBUG_FORTH_MALLOC_INT 
1272						DMARK "mrs" 
1272						CALLMONITOR 
1272					endif 
1272				jr .startalloc 
1272			 
1272			.contheap: 
1272				ld hl, heap_start 
1272			 
1272			.startalloc: 
1272			 
1272					if DEBUG_FORTH_MALLOC_INT 
1272						DMARK "mym" 
1272						CALLMONITOR 
1272					endif 
1272			.findblock: 
1272					if DEBUG_FORTH_MALLOC_INT 
1272						DMARK "mmf" 
1272						CALLMONITOR 
1272					endif 
1272			 
1272				ld a,(hl)  
1272				; if byte is zero then clear to use 
1272			 
1272				cp 0 
1272				jr z, .foundemptyblock 
1272			 
1272				; if byte is not clear 
1272				;     then byte is offset to next block 
1272			 
1272				inc hl 
1272				ld a, (hl) ; get size 
1272			.nextblock:	inc hl 
1272					ld e, (hl) 
1272					inc hl 
1272					ld d, (hl) 
1272					ex de, hl 
1272			;	inc hl  ; move past the store space 
1272			;	inc hl  ; move past zero index  
1272			 
1272				; TODO detect no more space 
1272			 
1272				push hl 
1272				ld de, heap_end 
1272				call cmp16 
1272				pop hl 
1272				jr nc, .nospace 
1272			 
1272				jr .findblock 
1272			 
1272			.nospace: ld hl, 0 
1272				jp .exit 
1272			 
1272			 
1272			.foundemptyblock:	 
1272					if DEBUG_FORTH_MALLOC_INT 
1272						DMARK "mme" 
1272						CALLMONITOR 
1272					endif 
1272			 
1272			; TODO has block enough space if reusing??? 
1272			 
1272				;  
1272			 
1272			; see if this block has been previously used 
1272				inc hl 
1272				ld a, (hl) 
1272				dec hl 
1272				cp 0 
1272				jr z, .newblock 
1272			 
1272					if DEBUG_FORTH_MALLOC_INT 
1272						DMARK "meR" 
1272						CALLMONITOR 
1272					endif 
1272			 
1272			; no reusing previously allocated block 
1272			 
1272			; is it smaller than previously used? 
1272				 
1272				inc hl    ; move to size 
1272				ld a, c 
1272				sub (hl)        ; we want c < (hl) 
1272				dec hl    ; move back to marker 
1272			        jr z, .findblock 
1272			 
1272				; update with the new size which should be lower 
1272			 
1272			        ;inc  hl   ; negate next move. move back to size  
1272			 
1272			.newblock: 
1272				; need to be at marker here 
1272			 
1272					if DEBUG_FORTH_MALLOC_INT 
1272						DMARK "meN" 
1272						CALLMONITOR 
1272					endif 
1272			 
1272			 
1272				ld a, c 
1272			 
1272				ld (free_list+3), a	 ; flag resume from last malloc  
1272				ld (free_list), hl    ; save out last location 
1272			 
1272			 
1272				;inc a     ; space for length byte 
1272				ld (hl), a     ; save block in use marker 
1272			 
1272				inc hl   ; move to space marker 
1272				ld (hl), a    ; save new space 
1272			 
1272				inc hl   ; move to start of allocated area 
1272				 
1272			;	push hl     ; save where we are - 1  
1272			 
1272			;	inc hl  ; move past zero index  
1272				; skip space to set down new marker 
1272			 
1272				; provide some extra space for now 
1272			 
1272				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1272				inc a 
1272				inc a 
1272			 
1272				push hl   ; save where we are in the node block 
1272			 
1272				call addatohl 
1272			 
1272				; write linked list point 
1272			 
1272				pop de     ; get our node position 
1272				ex de, hl 
1272			 
1272				ld (hl), e 
1272				inc hl 
1272				ld (hl), d 
1272			 
1272				inc hl 
1272			 
1272				; now at start of allocated data so save pointer 
1272			 
1272				push hl 
1272			 
1272				; jump to position of next node and setup empty header in DE 
1272			 
1272				ex de, hl 
1272			 
1272			;	inc hl ; move past end of block 
1272			 
1272				ld a, 0 
1272				ld (hl), a   ; empty marker 
1272				inc hl 
1272				ld (hl), a   ; size 
1272				inc hl  
1272				ld (hl), a   ; ptr 
1272				inc hl 
1272				ld (hl), a   ; ptr 
1272			 
1272			 
1272				pop hl 
1272			 
1272					if DEBUG_FORTH_MALLOC_INT 
1272						DMARK "mmr" 
1272						CALLMONITOR 
1272					endif 
1272			 
1272			.exit: 
1272				pop af 
1272				pop bc 
1272				pop de  
1272				ret 
1272			 
1272			 
1272			 
1272			 
1272			free:  
1272				push hl 
1272				push af 
1272				; get address in hl 
1272			 
1272					if DEBUG_FORTH_MALLOC_INT 
1272						DMARK "fre" 
1272						CALLMONITOR 
1272					endif 
1272				; data is at hl - move to block count 
1272				dec hl 
1272				dec hl    ; get past pointer 
1272				dec hl 
1272			 
1272				ld a, (hl)    ; need this for a validation check 
1272			 
1272				dec hl    ; move to block marker 
1272			 
1272				; now check that the block count and block marker are the same  
1272			        ; this checks that we are on a malloc node and not random memory 
1272			        ; OK a faint chance this could be a problem but rare - famous last words! 
1272			 
1272				ld c, a 
1272				ld a, (hl)    
1272			 
1272				cp c 
1272				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1272			 
1272				; yes good chance we are on a malloc node 
1272			 
1272				ld a, 0      
1272				ld (hl), a   ; mark as free 
1272			 
1272				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1272			 
1272			.freeignore:  
1272			 
1272				pop af 
1272				pop hl 
1272			 
1272				ret 
1272			 
1272			 
1272			 
1272			endif 
1272			 
1272			; eof 
# End of file firmware_memory.asm
1272			  
1272			; device C  
1272			if SOUND_ENABLE  
1272				include "firmware_sound.asm"  
1272			; Sound abstraction layer 
1272			 
1272			; support different sound chips through common interface 
1272			 
1272			SOUND_DEVICE_AY: equ 0 
1272			 
1272			SOUND_DEVICE: equ Device_A 
1272			 
1272			 
1272			 
1272			if SOUND_DEVICE_AY 
1272				include "firmware_sound_ay38910.asm" 
1272			else 
1272				include "firmware_sound_sn76489an.asm" 
1272			 
1272			; Device support for SN76489AN sound chip 
1272			 
1272			; https://arduinoplusplus.wordpress.com/2019/10/05/making-noise-with-a-sn76489-digital-sound-generator-part-1/ 
1272			; http://danceswithferrets.org/geekblog/?p=93 
1272			; https://www.smspower.org/Development/SN76489 
1272			 
1272			; D0 [ 3] 
1272			; D1 [ 2] 
1272			; D2 [ 1] 
1272			; D3 [15] 
1272			; D4 [13] 
1272			; D5 [12] 
1272			; D6 [11] 
1272			; D7 [10] 
1272			; /WE [ 5] 
1272			; CLK [14] 
1272			; /OE [ 6] 
1272			; AUDIO [ 7] 
1272			; GND 8 
1272			; +5 16 
1272			; 
1272			 
1272			; Write sequence: 
1272			; CE low 
1272			; Data bus 
1272			; WE low then high 
1272			; 32 clock cycles / 8ns write time at 4mhz 
1272			; 
1272			; https://github.com/jblang/SN76489 
1272			; Shows that the clock needs to be enabled when required. Noticed that with the clock connected it interupted the bus 
1272			; Tried: 
1272			; 
1272			; CE/OE -> Both pins of NAND -> To one pin of second NAND and second pin to full clock -> CLK on chip 
1272			; 
1272			; Connected WE to OR too 
1272			;  
1272			; That enabled the clock when required 
1272			; However still random bus corruption. Need further investigation 
1272			 
1272			 
1272			SOUND_LATCH: equ 10000000B 
1272			SOUND_DATA: equ 0B 
1272			SOUND_CH0:  equ 0B    ; Tone 
1272			SOUND_CH1: equ 0100000B        ; Tone 
1272			SOUND_CH2: equ 1000000B   ; Tone 
1272			SOUND_CH3: equ 1100000B    ; Noise 
1272			SOUND_VOL: equ 10000B 
1272			SOUND_TONE: equ 0B 
1272			 
1272			 
1272			sound_init: 
1272 3e 1f			ld a, SOUND_DATA | SOUND_CH0 | SOUND_VOL | 1111B 
1274 cd 89 12			call note_send_byte 
1277 3e 07			ld a, SOUND_DATA | SOUND_CH0 | SOUND_TONE | 0111B 
1279 cd 89 12			call note_send_byte 
127c cd 31 0a			call delay250ms 
127f 3e 05			ld a, SOUND_DATA | SOUND_CH0 | SOUND_TONE | 0101B 
1281 cd 89 12			call note_send_byte 
1284 cd 31 0a			call delay250ms 
1287 c9				ret 
1288			 
1288			; Play a note 
1288			; h = note 
1288			; l = duration 
1288			; a = channel 
1288			 
1288			 
1288			;  frequ = clock / ( 2 x reg valu x 32 )  
1288			 
1288			note:  
1288				 
1288			 
1288 c9				ret 
1289			 
1289			note_send_byte: 
1289				; byte in a 
1289			 
1289				; we high 
1289 d3 40			out (Device_B), a 
128b			;	ld a, 1 
128b			;	call aDelayInMS 
128b 00				nop  
128c 00				nop  
128d 00				nop  
128e 00				nop  
128f				; we low 
128f d3 40			out (Device_B), a 
1291			;	ld a, 1 
1291			;	call aDelayInMS 
1291 00				nop  
1292 00				nop  
1293 00				nop  
1294 00				nop  
1295				; we high 
1295 d3 40			out (Device_B), a 
1297			;	ld a, 1 
1297			;	call aDelayInMS 
1297 00				nop  
1298 00				nop  
1299 00				nop  
129a 00				nop  
129b			 
129b			 
129b c9				ret 
129c			 
129c			;void SilenceAllChannels() 
129c			;{ 
129c			;  SendByte(0x9f); 
129c			;  SendByte(0xbf); 
129c			;  SendByte(0xdf); 
129c			;  SendByte(0xff); 
129c			;} 
129c			 
129c			 
129c			; eof 
129c			 
# End of file firmware_sound_sn76489an.asm
129c			endif 
129c			 
129c			 
129c			; Abstraction entry points 
129c			 
129c			; init  
129c			 
129c			; sound_init in specific hardware files 
129c			 
129c			; Play a note 
129c			; h = note 
129c			; l = duration 
129c			; a = channel 
129c			 
129c			;note:     
129c			;	ret 
129c			 
129c			 
129c			 
129c			 
129c			; eof 
129c			 
# End of file firmware_sound.asm
129c			endif  
129c			  
129c			include "firmware_diags.asm"  
129c			; Hardware diags menu 
129c			 
129c			 
129c .. 00		hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
12bd .. 00		hd_menu2:   db "        2: Editor",0   
12cf			;hd_menu2:   db "        2: Editor       6: BASIC",0   
12cf .. 00		hd_menu3:   db "        3: Storage",0 
12e2 .. 00		hd_menu4:   db "0=quit  4: Debug",0 
12f3 .. 00		hd_don:     db "ON",0 
12f6 .. 00		hd_doff:     db "OFF",0 
12fa			 
12fa			 
12fa			 
12fa			hardware_diags:       
12fa			 
12fa			.diagmenu: 
12fa cd b9 0a			call clear_display 
12fd 3e 00			ld a, display_row_1 
12ff 11 9c 12			ld de, hd_menu1 
1302 cd cc 0a			call str_at_display 
1305			 
1305 3e 28			ld a, display_row_2 
1307 11 bd 12			ld de, hd_menu2 
130a cd cc 0a			call str_at_display 
130d			 
130d 3e 50			ld a, display_row_3 
130f 11 cf 12			ld de, hd_menu3 
1312 cd cc 0a			call str_at_display 
1315			 
1315 3e 78			ld a,  display_row_4 
1317 11 e2 12			ld de, hd_menu4 
131a cd cc 0a			call str_at_display 
131d			 
131d				; display debug state 
131d			 
131d 11 f3 12			ld de, hd_don 
1320 3a 31 ee			ld a, (os_view_disable) 
1323 fe 00			cp 0 
1325 28 03			jr z, .distog 
1327 11 f6 12			ld de, hd_doff 
132a 3e 89		.distog: ld a, display_row_4+17 
132c cd cc 0a			call str_at_display 
132f			 
132f cd dc 0a			call update_display 
1332			 
1332 cd 53 63			call cin_wait 
1335			 
1335			 
1335			 
1335 fe 34			cp '4' 
1337 20 0f			jr nz, .diagn1 
1339			 
1339				; debug toggle 
1339			 
1339 3a 31 ee			ld a, (os_view_disable) 
133c 06 2a			ld b, '*' 
133e fe 00			cp 0 
1340 28 02			jr z, .debtog 
1342 06 00			ld b, 0 
1344			.debtog:	 
1344 78				ld a,b 
1345 32 31 ee			ld (os_view_disable),a 
1348			 
1348 fe 30		.diagn1: cp '0' 
134a c8				 ret z 
134b			 
134b			;	cp '1' 
134b			;       jp z, matrix	 
134b			;   TODO keyboard matrix test 
134b			 
134b fe 32			cp '2' 
134d ca 54 13			jp z, .diagedit 
1350			 
1350			;if ENABLE_BASIC 
1350			;	cp '6' 
1350			;	jp z, basic 
1350			;endif 
1350			  
1350 c3 fa 12			jp .diagmenu 
1353			 
1353			 
1353 c9				ret 
1354			 
1354			; debug editor 
1354			 
1354			.diagedit: 
1354			 
1354 21 32 ee			ld hl, scratch 
1357			;	ld bc, 250 
1357			;	ldir 
1357				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1357 3e 00			ld a, 0 
1359 77				ld (hl), a 
135a 23				inc hl 
135b 77				ld (hl), a 
135c 23				inc hl 
135d 77				ld (hl), a 
135e			 
135e cd b9 0a		        call clear_display 
1361 cd dc 0a			call update_display 
1364 3e 01			ld a, 1 
1366 32 7d fb			ld (hardware_diag), a 
1369			.diloop: 
1369 3e 00			ld a, display_row_1 
136b 0e 00			ld c, 0 
136d 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
136f 1e 28			ld e, 40 
1371			 
1371 21 32 ee			ld hl, scratch	 
1374 cd 3f 0c			call input_str 
1377			 
1377 3e 28			ld a, display_row_2 
1379 11 32 ee			ld de, scratch 
137c cd cc 0a			call str_at_display 
137f cd dc 0a			call update_display 
1382			 
1382 c3 69 13			jp .diloop 
1385			 
1385			 
1385			; pass word in hl 
1385			; a has display location 
1385			display_word_at: 
1385 f5				push af 
1386 e5				push hl 
1387 7c				ld a,h 
1388 21 37 f1			ld hl, os_word_scratch 
138b cd 13 0f			call hexout 
138e e1				pop hl 
138f 7d				ld a,l 
1390 21 39 f1			ld hl, os_word_scratch+2 
1393 cd 13 0f			call hexout 
1396 21 3b f1			ld hl, os_word_scratch+4 
1399 3e 00			ld a,0 
139b 77				ld (hl),a 
139c 11 37 f1			ld de,os_word_scratch 
139f f1				pop af 
13a0 cd cc 0a				call str_at_display 
13a3 c9				ret 
13a4			 
13a4			display_ptr_state: 
13a4			 
13a4				; to restore afterwards 
13a4			 
13a4 d5				push de 
13a5 c5				push bc 
13a6 e5				push hl 
13a7 f5				push af 
13a8			 
13a8				; for use in here 
13a8			 
13a8			;	push bc 
13a8			;	push de 
13a8			;	push hl 
13a8			;	push af 
13a8			 
13a8 cd b9 0a			call clear_display 
13ab			 
13ab 11 7e 15			ld de, .ptrstate 
13ae 3e 00			ld a, display_row_1 
13b0 cd cc 0a			call str_at_display 
13b3			 
13b3				; display debug step 
13b3			 
13b3			 
13b3 11 77 fb			ld de, debug_mark 
13b6 3e 26			ld a, display_row_1+display_cols-2 
13b8 cd cc 0a			call str_at_display 
13bb			 
13bb				; display a 
13bb 11 88 15			ld de, .ptrcliptr 
13be 3e 28			ld a, display_row_2 
13c0 cd cc 0a			call str_at_display 
13c3			 
13c3 f1				pop af 
13c4 2a 3d f8			ld hl,(cli_ptr) 
13c7 3e 30			ld a, display_row_2+8 
13c9 cd 85 13			call display_word_at 
13cc			 
13cc			 
13cc				; display hl 
13cc			 
13cc			 
13cc 11 90 15			ld de, .ptrclioptr 
13cf 3e 32			ld a, display_row_2+10 
13d1 cd cc 0a			call str_at_display 
13d4			; 
13d4			;	pop hl 
13d4 3e 35			ld a, display_row_2+13 
13d6 2a 3b f8			ld hl,(cli_origptr) 
13d9 cd 85 13			call display_word_at 
13dc			; 
13dc			;	 
13dc			;	; display de 
13dc			 
13dc			;	ld de, .regstatede 
13dc			;	ld a, display_row_3 
13dc			;	call str_at_display 
13dc			 
13dc			;	pop de 
13dc			;	ld h,d 
13dc			;	ld l, e 
13dc			;	ld a, display_row_3+3 
13dc			;	call display_word_at 
13dc			 
13dc			 
13dc				; display bc 
13dc			 
13dc			;	ld de, .regstatebc 
13dc			;	ld a, display_row_3+10 
13dc			;	call str_at_display 
13dc			 
13dc			;	pop bc 
13dc			;	ld h,b 
13dc			;	ld l, c 
13dc			;	ld a, display_row_3+13 
13dc			;	call display_word_at 
13dc			 
13dc			 
13dc				; display dsp 
13dc			 
13dc			;	ld de, .regstatedsp 
13dc			;	ld a, display_row_4 
13dc			;	call str_at_display 
13dc			 
13dc				 
13dc			;	ld hl,(cli_data_sp) 
13dc			;	ld a, display_row_4+4 
13dc			;	call display_word_at 
13dc			 
13dc				; display rsp 
13dc			 
13dc 11 bf 15			ld de, .regstatersp 
13df 3e 82			ld a, display_row_4+10 
13e1 cd cc 0a			call str_at_display 
13e4			 
13e4				 
13e4 2a 23 f8			ld hl,(cli_ret_sp) 
13e7 3e 86			ld a, display_row_4+14 
13e9 cd 85 13			call display_word_at 
13ec			 
13ec cd dc 0a			call update_display 
13ef			 
13ef cd 3d 0a			call delay1s 
13f2 cd 3d 0a			call delay1s 
13f5 cd 3d 0a			call delay1s 
13f8			 
13f8			 
13f8 cd 12 19			call next_page_prompt 
13fb			 
13fb				; restore  
13fb			 
13fb f1				pop af 
13fc e1				pop hl 
13fd c1				pop bc 
13fe d1				pop de 
13ff c9				ret 
1400			 
1400			break_point_state: 
1400 f5				push af 
1401			 
1401				; see if disabled 
1401			 
1401 3a 31 ee			ld a, (os_view_disable) 
1404 fe 2a			cp '*' 
1406 20 02			jr nz, .bpsgo 
1408 f1				pop af 
1409 c9				ret 
140a			 
140a			.bpsgo: 
140a f1				pop af 
140b f5				push af 
140c 22 2d ee			ld (os_view_hl), hl 
140f ed 53 2b ee		ld (os_view_de), de 
1413 ed 43 29 ee		ld (os_view_bc), bc 
1417 e5				push hl 
1418 6f				ld l, a 
1419 26 00			ld h, 0 
141b 22 2f ee			ld (os_view_af),hl 
141e			 
141e 21 bd fa				ld hl, display_fb0 
1421 22 d8 f8				ld (display_fb_active), hl 
1424 e1				pop hl	 
1425			 
1425 3e 31			ld a, '1' 
1427 fe 2a		.bps1:  cp '*' 
1429 20 03			jr nz, .bps1b 
142b 32 31 ee			ld (os_view_disable),a 
142e fe 31		.bps1b:  cp '1' 
1430 20 14			jr nz, .bps2 
1432			 
1432				; display reg 
1432			 
1432				 
1432			 
1432 3a 2f ee			ld a, (os_view_af) 
1435 2a 2d ee			ld hl, (os_view_hl) 
1438 ed 5b 2b ee		ld de, (os_view_de) 
143c ed 4b 29 ee		ld bc, (os_view_bc) 
1440 cd da 14			call display_reg_state 
1443 c3 c6 14			jp .bpschk 
1446			 
1446 fe 32		.bps2:  cp '2' 
1448 20 08			jr nz, .bps3 
144a				 
144a				; display hl 
144a 2a 2d ee			ld hl, (os_view_hl) 
144d cd c4 15			call display_dump_at_hl 
1450			 
1450 18 74			jr .bpschk 
1452			 
1452 fe 33		.bps3:  cp '3' 
1454 20 08			jr nz, .bps4 
1456			 
1456			        ; display de 
1456 2a 2b ee			ld hl, (os_view_de) 
1459 cd c4 15			call display_dump_at_hl 
145c			 
145c 18 68			jr .bpschk 
145e fe 34		.bps4:  cp '4' 
1460 20 08			jr nz, .bps5 
1462			 
1462			        ; display bc 
1462 2a 29 ee			ld hl, (os_view_bc) 
1465 cd c4 15			call display_dump_at_hl 
1468			 
1468 18 5c			jr .bpschk 
146a fe 35		.bps5:  cp '5' 
146c 20 08		        jr nz, .bps7 
146e			 
146e				; display cur ptr 
146e 2a 3d f8			ld hl, (cli_ptr) 
1471 cd c4 15			call display_dump_at_hl 
1474			 
1474 18 50			jr .bpschk 
1476 fe 36		.bps7:  cp '6' 
1478 20 08			jr nz, .bps8b 
147a				 
147a				; display cur orig ptr 
147a 2a 3b f8			ld hl, (cli_origptr) 
147d cd c4 15			call display_dump_at_hl 
1480 18 44			jr .bpschk 
1482 fe 37		.bps8b:  cp '7' 
1484 20 08			jr nz, .bps9 
1486				 
1486				; display dsp 
1486 2a 1f f8			ld hl, (cli_data_sp) 
1489 cd c4 15			call display_dump_at_hl 
148c			 
148c 18 38			jr .bpschk 
148e fe 39		.bps9:  cp '9' 
1490 20 05			jr nz, .bps8c 
1492				 
1492				; display SP 
1492			;	ld hl, sp 
1492 cd c4 15			call display_dump_at_hl 
1495			 
1495 18 2f			jr .bpschk 
1497 fe 38		.bps8c:  cp '8' 
1499 20 08			jr nz, .bps8d 
149b				 
149b				; display rsp 
149b 2a 23 f8			ld hl, (cli_ret_sp) 
149e cd c4 15			call display_dump_at_hl 
14a1			 
14a1 18 23			jr .bpschk 
14a3 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
14a5 20 05			jr nz, .bps8 
14a7 cd 08 17			call monitor 
14aa			 
14aa 18 1a			jr .bpschk 
14ac fe 30		.bps8:  cp '0' 
14ae 20 16			jr nz, .bpschk 
14b0			 
14b0 21 1c fa				ld hl, display_fb1 
14b3 22 d8 f8				ld (display_fb_active), hl 
14b6 cd dc 0a				call update_display 
14b9			 
14b9				;ld a, (os_view_af) 
14b9 2a 2d ee			ld hl, (os_view_hl) 
14bc ed 5b 2b ee		ld de, (os_view_de) 
14c0 ed 4b 29 ee		ld bc, (os_view_bc) 
14c4 f1				pop af 
14c5 c9				ret 
14c6			 
14c6			.bpschk:   
14c6 cd 3d 0a			call delay1s 
14c9 3e 9f		ld a,display_row_4 + display_cols - 1 
14cb 11 10 19		        ld de, endprg 
14ce cd cc 0a			call str_at_display 
14d1 cd dc 0a			call update_display 
14d4 cd 53 63			call cin_wait 
14d7			 
14d7 c3 27 14			jp .bps1 
14da			 
14da			 
14da			display_reg_state: 
14da			 
14da				; to restore afterwards 
14da			 
14da d5				push de 
14db c5				push bc 
14dc e5				push hl 
14dd f5				push af 
14de			 
14de				; for use in here 
14de			 
14de c5				push bc 
14df d5				push de 
14e0 e5				push hl 
14e1 f5				push af 
14e2			 
14e2 cd b9 0a			call clear_display 
14e5			 
14e5 11 9a 15			ld de, .regstate 
14e8 3e 00			ld a, display_row_1 
14ea cd cc 0a			call str_at_display 
14ed			 
14ed				; display debug step 
14ed			 
14ed			 
14ed 11 77 fb			ld de, debug_mark 
14f0 3e 25			ld a, display_row_1+display_cols-3 
14f2 cd cc 0a			call str_at_display 
14f5			 
14f5				; display a 
14f5 11 b6 15			ld de, .regstatea 
14f8 3e 28			ld a, display_row_2 
14fa cd cc 0a			call str_at_display 
14fd			 
14fd e1				pop hl 
14fe			;	ld h,0 
14fe			;	ld l, a 
14fe 3e 2b			ld a, display_row_2+3 
1500 cd 85 13			call display_word_at 
1503			 
1503			 
1503				; display hl 
1503			 
1503			 
1503 11 aa 15			ld de, .regstatehl 
1506 3e 32			ld a, display_row_2+10 
1508 cd cc 0a			call str_at_display 
150b			 
150b e1				pop hl 
150c 3e 35			ld a, display_row_2+13 
150e cd 85 13			call display_word_at 
1511			 
1511				 
1511				; display de 
1511			 
1511 11 ae 15			ld de, .regstatede 
1514 3e 50			ld a, display_row_3 
1516 cd cc 0a			call str_at_display 
1519			 
1519 e1				pop hl 
151a			;	ld h,d 
151a			;	ld l, e 
151a 3e 53			ld a, display_row_3+3 
151c cd 85 13			call display_word_at 
151f			 
151f			 
151f				; display bc 
151f			 
151f 11 b2 15			ld de, .regstatebc 
1522 3e 5a			ld a, display_row_3+10 
1524 cd cc 0a			call str_at_display 
1527			 
1527 e1				pop hl 
1528			;	ld h,b 
1528			;	ld l, c 
1528 3e 5d			ld a, display_row_3+13 
152a cd 85 13			call display_word_at 
152d			 
152d			 
152d				; display dsp 
152d			 
152d 11 ba 15			ld de, .regstatedsp 
1530 3e 78			ld a, display_row_4 
1532 cd cc 0a			call str_at_display 
1535			 
1535				 
1535 2a 1f f8			ld hl,(cli_data_sp) 
1538 3e 7c			ld a, display_row_4+4 
153a cd 85 13			call display_word_at 
153d			 
153d				; display rsp 
153d			 
153d 11 bf 15			ld de, .regstatersp 
1540 3e 82			ld a, display_row_4+10 
1542 cd cc 0a			call str_at_display 
1545			 
1545				 
1545 2a 23 f8			ld hl,(cli_ret_sp) 
1548 3e 86			ld a, display_row_4+14 
154a cd 85 13			call display_word_at 
154d			 
154d cd dc 0a			call update_display 
1550			 
1550			;	call delay1s 
1550			;	call delay1s 
1550			;	call delay1s 
1550			 
1550			 
1550			;	call next_page_prompt 
1550			 
1550				; restore  
1550			 
1550 f1				pop af 
1551 e1				pop hl 
1552 c1				pop bc 
1553 d1				pop de 
1554 c9				ret 
1555			 
1555 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1569 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
157e .. 00		.ptrstate:	db "Ptr State",0 
1588 .. 00		.ptrcliptr:     db "cli_ptr",0 
1590 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
159a .. 00		.regstate:	db "Reg State (1/0)",0 
15aa .. 00		.regstatehl:	db "HL:",0 
15ae .. 00		.regstatede:	db "DE:",0 
15b2 .. 00		.regstatebc:	db "BC:",0 
15b6 .. 00		.regstatea:	db "A :",0 
15ba .. 00		.regstatedsp:	db "DSP:",0 
15bf .. 00		.regstatersp:	db "RSP:",0 
15c4			 
15c4			display_dump_at_hl: 
15c4 e5				push hl 
15c5 d5				push de 
15c6 c5				push bc 
15c7 f5				push af 
15c8			 
15c8 22 55 f1			ld (os_cur_ptr),hl	 
15cb cd b9 0a			call clear_display 
15ce cd 1a 18			call dumpcont 
15d1			;	call delay1s 
15d1			;	call next_page_prompt 
15d1			 
15d1			 
15d1 f1				pop af 
15d2 c1				pop bc 
15d3 d1				pop de 
15d4 e1				pop hl 
15d5 c9				ret 
15d6			 
15d6			;if ENABLE_BASIC 
15d6			;	include "nascombasic.asm" 
15d6			;	basic: 
15d6			;	include "forth/FORTH.ASM" 
15d6			;endif 
15d6			 
15d6			; eof 
15d6			 
15d6			 
# End of file firmware_diags.asm
15d6			  
15d6			  
15d6			  
15d6			  
15d6			; eof  
15d6			  
# End of file firmware.asm
15d6			 
15d6			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
15d6			;if BASE_KEV  
15d6			;baseram: equ 08000h 
15d6			;endif 
15d6			 
15d6			;if BASE_SC114 
15d6			;baseram:     equ    endofcode 
15d6			;endif 
15d6			 
15d6			 
15d6			; start system 
15d6			 
15d6			coldstart: 
15d6				; set sp 
15d6				; di/ei 
15d6			 
15d6 f3				di 
15d7 31 fd ff			ld sp, tos 
15da			;	ei 
15da			 
15da			 
15da				; disable breakpoint by default 
15da			 
15da 3e 2a			ld a,'*' 
15dc 32 31 ee			ld (os_view_disable),a 
15df			 
15df				; init hardware 
15df			 
15df				; init keyboard and screen hardware 
15df			 
15df cd 03 00			call hardware_init 
15e2			 
15e2			 
15e2				; detect if any keys are held down to enable breakpoints at start up 
15e2			 
15e2 cd 64 63			call cin  
15e5 fe 00			cp 0 
15e7 28 03			jr z, .nokeys 
15e9			 
15e9 cd fa 12			call hardware_diags 
15ec			 
15ec			;	ld de, .bpen 
15ec			;	ld a, display_row_4 
15ec			;	call str_at_display 
15ec			;	call update_display 
15ec			; 
15ec			;	ld a,0 
15ec			;	ld (os_view_disable),a 
15ec			; 
15ec			;.bpwait: 
15ec			;	call cin 
15ec			;	cp 0 
15ec			;	jr z, .bpwait 
15ec			;	jr .nokeys 
15ec			; 
15ec			; 
15ec			;.bpen:  db "Break points enabled!",0 
15ec			 
15ec			 
15ec			 
15ec			 
15ec			 
15ec			 
15ec			.nokeys: 
15ec			 
15ec			 
15ec				 
15ec			 
15ec			;jp  testkey 
15ec			 
15ec			;call storage_get_block_0 
15ec			; 
15ec			;ld hl, 0 
15ec			;ld de, store_page 
15ec			;call storage_read_block 
15ec			 
15ec				 
15ec			;ld hl, 10 
15ec			;ld de, store_page 
15ec			;call storage_read_block 
15ec			 
15ec			 
15ec			 
15ec			 
15ec			 
15ec			;stop:	nop 
15ec			;	jp stop 
15ec			 
15ec			 
15ec			 
15ec			main: 
15ec cd b9 0a			call clear_display 
15ef cd dc 0a			call update_display 
15f2			 
15f2			 
15f2			 
15f2			;	call testlcd 
15f2			 
15f2			 
15f2			 
15f2 cd 60 1b			call forth_init 
15f5			 
15f5			 
15f5			warmstart: 
15f5 cd 36 1b			call forth_warmstart 
15f8			 
15f8				; run startup word load 
15f8			        ; TODO prevent this running at warmstart after crash  
15f8			 
15f8				if STARTUP_ENABLE 
15f8 cd 2a 5d				call forth_startup 
15fb				endif 
15fb			 
15fb				; show free memory after boot 
15fb 11 a2 16			ld de, freeram 
15fe 3e 00			ld a, display_row_1 
1600 cd cc 0a			call str_at_display 
1603			 
1603			; Or use heap_size word???? 
1603 21 26 ee			ld hl, heap_end 
1606 11 0e 80			ld de, heap_start 
1609 ed 52			sbc hl, de 
160b e5				push hl 
160c 7c				ld a,h	         	 
160d 21 37 f1			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1610 cd 13 0f			call hexout 
1613 e1			   	pop hl 
1614			 
1614 7d				ld a,l 
1615 21 39 f1			ld hl, os_word_scratch+2 
1618 cd 13 0f			call hexout 
161b 21 3b f1			ld hl, os_word_scratch+4 
161e 3e 00			ld a, 0 
1620 77				ld (hl),a 
1621 11 37 f1			ld de, os_word_scratch 
1624 3e 0d			ld a, display_row_1 + 13 
1626 cd cc 0a			call str_at_display 
1629 cd dc 0a			call update_display 
162c			 
162c			 
162c				;call demo 
162c			 
162c			 
162c				; init scratch input area for cli commands 
162c			 
162c 21 59 f1			ld hl, os_cli_cmd 
162f 3e 00			ld a,0 
1631 77				ld (hl),a 
1632 23				inc hl 
1633 77				ld (hl),a 
1634			 
1634 3e 00			ld a,0 
1636 32 58 f2			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1639			 
1639 32 55 f1			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
163c 32 56 f1			ld (os_cur_ptr+1),a	 
163f			 
163f 32 37 f1			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1642 32 38 f1			ld (os_word_scratch+1),a	 
1645				 
1645			 
1645				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1645 21 59 f1			ld hl, os_cli_cmd 
1648			 
1648 3e 00			ld a, 0		 ; init cli input 
164a 77				ld (hl), a 
164b 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
164d			cli: 
164d				; show cli prompt 
164d				;push af 
164d				;ld a, 0 
164d				;ld de, prompt 
164d				;call str_at_display 
164d			 
164d				;call update_display 
164d				;pop af 
164d				;inc a 
164d				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
164d 0e 00			ld c, 0 
164f 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1651 1e 28			ld e, 40 
1653			 
1653 21 59 f1			ld hl, os_cli_cmd 
1656			 
1656				STACKFRAME OFF $fefe $9f9f 
1656				if DEBUG_STACK_IMB 
1656					if OFF 
1656						exx 
1656						ld de, $fefe 
1656						ld a, d 
1656						ld hl, curframe 
1656						call hexout 
1656						ld a, e 
1656						ld hl, curframe+2 
1656						call hexout 
1656						ld hl, $fefe 
1656						push hl 
1656						ld hl, $9f9f 
1656						push hl 
1656						exx 
1656					endif 
1656				endif 
1656			endm 
# End of macro STACKFRAME
1656			 
1656 cd 3f 0c			call input_str 
1659			 
1659				STACKFRAMECHK OFF $fefe $9f9f 
1659				if DEBUG_STACK_IMB 
1659					if OFF 
1659						exx 
1659						ld hl, $9f9f 
1659						pop de   ; $9f9f 
1659						call cmp16 
1659						jr nz, .spnosame 
1659						ld hl, $fefe 
1659						pop de   ; $fefe 
1659						call cmp16 
1659						jr z, .spfrsame 
1659						.spnosame: call showsperror 
1659						.spfrsame: nop 
1659						exx 
1659					endif 
1659				endif 
1659			endm 
# End of macro STACKFRAMECHK
1659			 
1659				; copy input to last command 
1659			 
1659 21 59 f1			ld hl, os_cli_cmd 
165c 11 58 f2			ld de, os_last_cmd 
165f 01 ff 00			ld bc, 255 
1662 ed b0			ldir 
1664			 
1664				; wipe current buffer 
1664			 
1664 3e 00			ld a, 0 
1666 21 59 f1			ld hl, os_cli_cmd 
1669 11 5a f1			ld de, os_cli_cmd+1 
166c 01 fe 00			ld bc, 254 
166f ed b0			ldir 
1671				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1671			;	call strcpy 
1671			;	ld a, 0 
1671			;	ld (hl), a 
1671			;	inc hl 
1671			;	ld (hl), a 
1671			;	inc hl 
1671			;	ld (hl), a 
1671			 
1671				; switch frame buffer to program  
1671			 
1671 21 1c fa				ld hl, display_fb1 
1674 22 d8 f8				ld (display_fb_active), hl 
1677			 
1677			;	nop 
1677				STACKFRAME ON $fbfe $8f9f 
1677				if DEBUG_STACK_IMB 
1677					if ON 
1677						exx 
1677						ld de, $fbfe 
1677						ld a, d 
1677						ld hl, curframe 
1677						call hexout 
1677						ld a, e 
1677						ld hl, curframe+2 
1677						call hexout 
1677						ld hl, $fbfe 
1677						push hl 
1677						ld hl, $8f9f 
1677						push hl 
1677						exx 
1677					endif 
1677				endif 
1677			endm 
# End of macro STACKFRAME
1677				; first time into the parser so pass over the current scratch pad 
1677 21 59 f1			ld hl,os_cli_cmd 
167a				; tokenise the entered statement(s) in HL 
167a cd d9 1b			call forthparse 
167d			        ; exec forth statements in top of return stack 
167d cd 19 1c			call forthexec 
1680				;call forthexec_cleanup 
1680			;	call parsenext 
1680			 
1680				STACKFRAMECHK ON $fbfe $8f9f 
1680				if DEBUG_STACK_IMB 
1680					if ON 
1680						exx 
1680						ld hl, $8f9f 
1680						pop de   ; $8f9f 
1680						call cmp16 
1680						jr nz, .spnosame 
1680						ld hl, $fbfe 
1680						pop de   ; $fbfe 
1680						call cmp16 
1680						jr z, .spfrsame 
1680						.spnosame: call showsperror 
1680						.spfrsame: nop 
1680						exx 
1680					endif 
1680				endif 
1680			endm 
# End of macro STACKFRAMECHK
1680				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1680			 
1680 3e 78			ld a, display_row_4 
1682 11 b4 16			ld de, endprog 
1685			 
1685 cd dc 0a			call update_display		 
1688			 
1688 cd 12 19			call next_page_prompt 
168b			 
168b				; switch frame buffer to cli 
168b			 
168b 21 bd fa				ld hl, display_fb0 
168e 22 d8 f8				ld (display_fb_active), hl 
1691			 
1691			 
1691 cd b9 0a		        call clear_display 
1694 cd dc 0a			call update_display		 
1697			 
1697 21 59 f1			ld hl, os_cli_cmd 
169a			 
169a 3e 00			ld a, 0		 ; init cli input 
169c 77				ld (hl), a 
169d			 
169d				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
169d			 
169d				; now on last line 
169d			 
169d				; TODO scroll screen up 
169d			 
169d				; TODO instead just clear screen and place at top of screen 
169d			 
169d			;	ld a, 0 
169d			;	ld (f_cursor_ptr),a 
169d			 
169d				;call clear_display 
169d				;call update_display 
169d			 
169d				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
169d 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
169f c3 4d 16			jp cli 
16a2			 
16a2 .. 00		freeram: db "Free bytes: $",0 
16b0 ..			asc: db "1A2F" 
16b4 .. 00		endprog: db "End prog...",0 
16c0			 
16c0			testenter2:   
16c0 21 64 ee			ld hl,scratch+50 
16c3 22 55 f1			ld (os_cur_ptr),hl 
16c6 c3 4d 16			jp cli 
16c9			 
16c9			testenter:  
16c9			 
16c9 21 b0 16			ld hl,asc 
16cc			;	ld a,(hl) 
16cc			;	call nibble2val 
16cc cd 69 0f			call get_byte 
16cf			 
16cf			 
16cf			;	ld a,(hl) 
16cf			;	call atohex 
16cf			 
16cf			;	call fourehexhl 
16cf 32 64 ee			ld (scratch+50),a 
16d2			 
16d2			 
16d2			 
16d2 21 b2 16			ld hl,asc+2 
16d5			;	ld a, (hl) 
16d5			;	call nibble2val 
16d5 cd 69 0f			call get_byte 
16d8			 
16d8			;	call fourehexhl 
16d8 32 66 ee			ld (scratch+52),a 
16db				 
16db 21 64 ee			ld hl,scratch+50 
16de 22 55 f1			ld (os_cur_ptr),hl 
16e1 c3 4d 16			jp cli 
16e4			 
16e4			enter:	 
16e4 3a 36 ee			ld a,(scratch+4) 
16e7 fe 00			cp 0 
16e9 28 0c			jr z, .entercont 
16eb				; no, not a null term line so has an address to work out.... 
16eb			 
16eb 21 34 ee			ld hl,scratch+2 
16ee cd c9 0f			call get_word_hl 
16f1			 
16f1 22 55 f1			ld (os_cur_ptr),hl	 
16f4 c3 4d 16			jp cli 
16f7			 
16f7			 
16f7			.entercont:  
16f7			 
16f7 21 34 ee			ld hl, scratch+2 
16fa cd 69 0f			call get_byte 
16fd			 
16fd 2a 55 f1		   	ld hl,(os_cur_ptr) 
1700 77					ld (hl),a 
1701 23					inc hl 
1702 22 55 f1				ld (os_cur_ptr),hl 
1705				 
1705			; get byte  
1705			 
1705			 
1705 c3 4d 16			jp cli 
1708			 
1708			 
1708			; basic monitor support 
1708			 
1708			monitor: 
1708				;  
1708 cd b9 0a			call clear_display 
170b 3e 00			ld a, 0 
170d 11 55 17			ld de, .monprompt 
1710 cd cc 0a			call str_at_display 
1713 cd dc 0a			call update_display 
1716			 
1716				; get a monitor command 
1716			 
1716 0e 00			ld c, 0     ; entry at top left 
1718 16 64			ld d, 100   ; max buffer size 
171a 1e 0f			ld e, 15    ; input scroll area 
171c 3e 00			ld a, 0     ; init string 
171e 21 30 f0			ld hl, os_input 
1721 77				ld (hl), a 
1722 23				inc hl 
1723 77				ld (hl), a 
1724 21 30 f0			ld hl, os_input 
1727 3e 01			ld a, 1     ; init string 
1729 cd 3f 0c			call input_str 
172c			 
172c cd b9 0a		        call clear_display 
172f cd dc 0a			call update_display		 
1732			 
1732 3a 30 f0			ld a, (os_input) 
1735 cd 67 10			call toUpper 
1738 fe 48		        cp 'H' 
173a 28 6f		        jr z, .monhelp 
173c fe 44			cp 'D'		; dump 
173e ca cc 17			jp z, .mondump	 
1741 fe 43			cp 'C'		; dump 
1743 ca e6 17			jp z, .moncdump	 
1746 fe 4d			cp 'M'		; dump 
1748 ca 57 17			jp z, .moneditstart 
174b fe 55			cp 'U'		; dump 
174d 28 14			jr z, .monedit	 
174f fe 51			cp 'Q'		; dump 
1751 c8				ret z	 
1752			 
1752			 
1752				; TODO "S" to access symbol by name and not need the address 
1752				; TODO "F" to find a string in memory 
1752			 
1752 c3 08 17			jp monitor 
1755			 
1755 .. 00		.monprompt: db ">", 0 
1757			 
1757			.moneditstart: 
1757				; get starting address 
1757			 
1757 21 32 f0			ld hl,os_input+2 
175a cd c9 0f			call get_word_hl 
175d			 
175d 22 55 f1			ld (os_cur_ptr),hl	 
1760			 
1760 c3 08 17			jp monitor 
1763			 
1763			.monedit: 
1763				; get byte to load 
1763			 
1763 21 32 f0			ld hl,os_input+2 
1766 cd 69 0f			call get_byte 
1769			 
1769				; get address to update 
1769 2a 55 f1			ld hl, (os_cur_ptr) 
176c			 
176c				; update byte 
176c			 
176c 77				ld (hl), a 
176d			 
176d				; move to next address and save it 
176d			 
176d 23				inc hl 
176e 22 55 f1			ld (os_cur_ptr),hl	 
1771			 
1771 c3 08 17			jp monitor 
1774			 
1774			 
1774 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1788 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
17a4 .. 00		.monhelptext3:  db "Q-Quit",0 
17ab			        
17ab			.monhelp: 
17ab 3e 00			ld a, display_row_1 
17ad 11 74 17		        ld de, .monhelptext1 
17b0			 
17b0 cd cc 0a			call str_at_display 
17b3 3e 28			ld a, display_row_2 
17b5 11 88 17		        ld de, .monhelptext2 
17b8					 
17b8 cd cc 0a			call str_at_display 
17bb 3e 50			ld a, display_row_3 
17bd 11 a4 17		        ld de, .monhelptext3 
17c0					 
17c0 cd cc 0a			call str_at_display 
17c3 cd dc 0a			call update_display		 
17c6			 
17c6 cd 12 19			call next_page_prompt 
17c9 c3 08 17			jp monitor 
17cc			 
17cc			.mondump:    
17cc 21 32 f0			ld hl,os_input+2 
17cf cd c9 0f			call get_word_hl 
17d2			 
17d2 22 55 f1			ld (os_cur_ptr),hl	 
17d5 cd 1a 18			call dumpcont 
17d8 3e 78			ld a, display_row_4 
17da 11 b4 16			ld de, endprog 
17dd			 
17dd cd dc 0a			call update_display		 
17e0			 
17e0 cd 12 19			call next_page_prompt 
17e3 c3 08 17			jp monitor 
17e6			.moncdump: 
17e6 cd 1a 18			call dumpcont 
17e9 3e 78			ld a, display_row_4 
17eb 11 b4 16			ld de, endprog 
17ee			 
17ee cd dc 0a			call update_display		 
17f1			 
17f1 cd 12 19			call next_page_prompt 
17f4 c3 08 17			jp monitor 
17f7			 
17f7			 
17f7			; TODO symbol access  
17f7			 
17f7			.symbols:     ;; A list of symbols that can be called up  
17f7 bd fa			dw display_fb0 
17f9 .. 00			db "fb0",0  
17fd 62 f8		     	dw store_page 
17ff .. 00			db "store_page",0 
180a			 
180a			 
180a			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
180a			 
180a 3a 33 ee			ld a,(scratch+1) 
180d fe 00			cp 0 
180f 28 09			jr z, dumpcont 
1811			 
1811				; no, not a null term line so has an address to work out.... 
1811			 
1811 21 34 ee			ld hl,scratch+2 
1814 cd c9 0f			call get_word_hl 
1817			 
1817 22 55 f1			ld (os_cur_ptr),hl	 
181a			 
181a			 
181a			 
181a			dumpcont: 
181a			 
181a				; dump bytes at ptr 
181a			 
181a			 
181a 3e 00			ld a, display_row_1 
181c 2a d8 f8			ld hl, (display_fb_active) 
181f cd 12 0c			call addatohl 
1822 cd 4a 18			call .dumpbyterow 
1825			 
1825 3e 28			ld a, display_row_2 
1827 2a d8 f8			ld hl, (display_fb_active) 
182a cd 12 0c			call addatohl 
182d cd 4a 18			call .dumpbyterow 
1830			 
1830			 
1830 3e 50			ld a, display_row_3 
1832 2a d8 f8			ld hl, (display_fb_active) 
1835 cd 12 0c			call addatohl 
1838 cd 4a 18			call .dumpbyterow 
183b			 
183b 3e 78			ld a, display_row_4 
183d 2a d8 f8			ld hl, (display_fb_active) 
1840 cd 12 0c			call addatohl 
1843 cd 4a 18			call .dumpbyterow 
1846			 
1846 cd dc 0a			call update_display 
1849			;		jp cli 
1849 c9				ret 
184a			 
184a			.dumpbyterow: 
184a			 
184a				;push af 
184a			 
184a e5				push hl 
184b			 
184b				; calc where to poke the ascii 
184b			if display_cols == 20 
184b				ld a, 16 
184b			else 
184b 3e 1f			ld a, 31 
184d			endif 
184d			 
184d cd 12 0c			call addatohl 
1850 22 37 f1			ld (os_word_scratch),hl  		; save pos for later 
1853			 
1853			 
1853			; display decoding address 
1853 2a 55 f1		   	ld hl,(os_cur_ptr) 
1856			 
1856 7c				ld a,h 
1857 e1				pop hl 
1858 e5				push hl 
1859			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1859 cd 13 0f			call hexout 
185c 2a 55 f1		   	ld hl,(os_cur_ptr) 
185f			 
185f 7d				ld a,l 
1860 e1				pop hl 
1861 23				inc hl 
1862 23				inc hl 
1863 e5				push hl 
1864			;	ld hl, os_word_scratch+2 
1864 cd 13 0f			call hexout 
1867 e1				pop hl 
1868 23				inc hl 
1869 23				inc hl 
186a				;ld hl, os_word_scratch+4 
186a 3e 3a			ld a, ':' 
186c 77				ld (hl),a 
186d 23				inc hl 
186e				;ld a, 0 
186e				;ld (hl),a 
186e				;ld de, os_word_scratch 
186e				;pop af 
186e				;push af 
186e			;		ld a, display_row_2 
186e			;		call str_at_display 
186e			;		call update_display 
186e			 
186e			 
186e			;pop af 
186e			;	add 5 
186e			 
186e			if display_cols == 20 
186e				ld b, 4 
186e			else 
186e 06 08			ld b, 8 
1870			endif	 
1870			 
1870			.dumpbyte: 
1870 c5				push bc 
1871 e5				push hl 
1872			 
1872			 
1872 2a 55 f1		   	ld hl,(os_cur_ptr) 
1875 7e					ld a,(hl) 
1876			 
1876					; poke the ascii to display 
1876 2a 37 f1				ld hl,(os_word_scratch) 
1879 77					ld (hl),a 
187a 23					inc hl 
187b 22 37 f1				ld (os_word_scratch),hl 
187e			 
187e					 
187e			 
187e			 
187e e1					pop hl 
187f e5					push hl 
1880			 
1880 cd 13 0f				call hexout 
1883			 
1883					 
1883 2a 55 f1		   	ld hl,(os_cur_ptr) 
1886 23				inc hl 
1887 22 55 f1		   	ld (os_cur_ptr),hl 
188a			 
188a e1					pop hl 
188b 23					inc hl 
188c 23					inc hl 
188d 23					inc hl 
188e			 
188e			 
188e			 
188e					;ld a,0 
188e					;ld (os_word_scratch+2),a 
188e					;pop af 
188e					;push af 
188e			 
188e					;ld de, os_word_scratch 
188e					;call str_at_display 
188e			;		call update_display 
188e			;		pop af 
188e c1					pop bc 
188f c6 03				add 3 
1891 10 dd			djnz .dumpbyte 
1893			 
1893				 
1893			 
1893 c9				ret 
1894			 
1894			jump:	 
1894			 
1894 21 34 ee			ld hl,scratch+2 
1897 cd c9 0f			call get_word_hl 
189a				;ld hl,(scratch+2) 
189a				;call fourehexhl 
189a			 
189a 22 55 f1			ld (os_cur_ptr),hl	 
189d			 
189d e9				jp (hl) 
189e			 
189e			 
189e			 
189e			; TODO implement a basic monitor mode to start with 
189e			 
189e			 
189e			 
189e			 
189e			 
189e			 
189e			 
189e			 
189e			 
189e			; testing and demo code during development 
189e			 
189e			 
189e .. 00		str1: db "Enter some text...",0 
18b1 .. 00		clear: db "                    ",0 
18c6			 
18c6			demo: 
18c6			 
18c6			 
18c6			 
18c6			;	call update_display 
18c6			 
18c6				; init scratch input area for testing 
18c6 21 32 ee			ld hl, scratch	 
18c9 3e 00			ld a,0 
18cb 77				ld (hl),a 
18cc			 
18cc			 
18cc 3e 28		            LD   A, display_row_2 
18ce			;            CALL fLCD_Pos       ;Position cursor to location in A 
18ce 11 9e 18		            LD   DE, str1 
18d1 cd cc 0a			call str_at_display 
18d4			 
18d4			;            CALL fLCD_Str       ;Display string pointed to by DE 
18d4			cloop:	 
18d4 3e 50		            LD   A, display_row_3 
18d6			;            CALL fLCD_Pos       ;Position cursor to location in A 
18d6 11 b1 18		            LD   DE, clear 
18d9			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
18d9 cd cc 0a				call str_at_display 
18dc 3e 78			ld a, display_row_4 
18de 11 0e 19			ld de, prompt 
18e1			 
18e1 cd cc 0a				call str_at_display 
18e4 cd dc 0a			call update_display 
18e7			 
18e7 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
18e9 16 0a			ld d, 10 
18eb 21 32 ee			ld hl, scratch	 
18ee cd 3f 0c			call input_str 
18f1			 
18f1			;	call clear_display 
18f1			;'	call update_display 
18f1			 
18f1 3e 00		            LD   A, display_row_1 
18f3			;            CALL fLCD_Pos       ;Position cursor to location in A 
18f3 11 b1 18		            LD   DE, clear 
18f6 cd cc 0a				call str_at_display 
18f9			;            CALL fLCD_Str       ;Display string pointed to by DE 
18f9 3e 00		            LD   A, display_row_1 
18fb			;            CALL fLCD_Pos       ;Position cursor to location in A 
18fb 11 32 ee		            LD   DE, scratch 
18fe			;            CALL fLCD_Str       ;Display string pointed to by DE 
18fe cd cc 0a				call str_at_display 
1901 cd dc 0a			call update_display 
1904			 
1904 3e 00				ld a,0 
1906 21 32 ee			ld hl, scratch 
1909 77				ld (hl),a 
190a			 
190a 00				nop 
190b c3 d4 18			jp cloop 
190e			 
190e			 
190e			 
190e			; OS Prompt 
190e			 
190e .. 00		prompt: db ">",0 
1910 .. 00		endprg: db "?",0 
1912			 
1912			 
1912			; handy next page prompt 
1912			next_page_prompt: 
1912 e5				push hl 
1913 d5				push de 
1914 f5				push af 
1915 c5				push bc 
1916			 
1916 3e 9f			ld a,display_row_4 + display_cols - 1 
1918 11 10 19		        ld de, endprg 
191b cd cc 0a			call str_at_display 
191e cd dc 0a			call update_display 
1921 cd 53 63			call cin_wait 
1924 c1				pop bc 
1925 f1				pop af 
1926 d1				pop de 
1927 e1				pop hl 
1928			 
1928			 
1928 c9				ret 
1929			 
1929			 
1929			; forth parser 
1929			 
1929			; My forth kernel 
1929			include "forth_kernel.asm" 
1929			; 
1929			; kernel to the forth OS 
1929			 
1929			DS_TYPE_STR: equ 1     ; string type 
1929			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1929			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1929			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1929			 
1929			FORTH_PARSEV1: equ 0 
1929			FORTH_PARSEV2: equ 0 
1929			FORTH_PARSEV3: equ 0 
1929			FORTH_PARSEV4: equ 0 
1929			FORTH_PARSEV5: equ 1 
1929			 
1929			;if FORTH_PARSEV5 
1929			;	FORTH_END_BUFFER: equ 0 
1929			;else 
1929			FORTH_END_BUFFER: equ 127 
1929			;endif 
1929			 
1929			FORTH_TRUE: equ 1 
1929			FORTH_FALSE: equ 0 
1929			 
1929			if FORTH_PARSEV4 
1929			include "forth_stackops.asm" 
1929			endif 
1929			 
1929			if FORTH_PARSEV5 
1929			include "forth_stackopsv5.asm" 
1929			 
1929			; Stack operations for v5 parser on wards 
1929			; * DATA stack 
1929			; * LOOP stack 
1929			; * RETURN stack 
1929			 
1929			 
1929			 
1929			FORTH_CHK_DSP_UNDER: macro 
1929				push hl 
1929				push de 
1929				ld hl,(cli_data_sp) 
1929				ld de, cli_data_stack 
1929				call cmp16 
1929				jp c, fault_dsp_under 
1929				pop de 
1929				pop hl 
1929				endm 
1929			 
1929			 
1929			FORTH_CHK_RSP_UNDER: macro 
1929				push hl 
1929				push de 
1929				ld hl,(cli_ret_sp) 
1929				ld de, cli_ret_stack 
1929				call cmp16 
1929				jp c, fault_rsp_under 
1929				pop de 
1929				pop hl 
1929				endm 
1929			 
1929			FORTH_CHK_LOOP_UNDER: macro 
1929				push hl 
1929				push de 
1929				ld hl,(cli_loop_sp) 
1929				ld de, cli_loop_stack 
1929				call cmp16 
1929				jp c, fault_loop_under 
1929				pop de 
1929				pop hl 
1929				endm 
1929			 
1929			FORTH_ERR_TOS_NOTSTR: macro 
1929				; TOSO might need more for checks when used 
1929				push af 
1929				ld a,(hl) 
1929				cp DS_TYPE_STR 
1929				jp nz, type_faultn   
1929				pop af 
1929				endm 
1929			 
1929			FORTH_ERR_TOS_NOTNUM: macro 
1929				push af 
1929				ld a,(hl) 
1929				cp DS_TYPE_INUM 
1929				jp nz, type_faultn   
1929				pop af 
1929				endm 
1929			 
1929			 
1929			; increase data stack pointer and save hl to it 
1929				 
1929			FORTH_DSP_NEXT: macro 
1929				call macro_forth_dsp_next 
1929				endm 
1929			 
1929			 
1929			macro_forth_dsp_next: 
1929				if DEBUG_FORTH_STACK_GUARD 
1929 cd f4 5d				call check_stacks 
192c				endif 
192c e5				push hl 
192d d5				push de 
192e eb				ex de,hl 
192f 2a 1f f8			ld hl,(cli_data_sp) 
1932 23				inc hl 
1933 23				inc hl 
1934			 
1934			; PARSEV5 
1934 23				inc hl 
1935 22 1f f8			ld (cli_data_sp),hl 
1938 73				ld (hl), e 
1939 23				inc hl 
193a 72				ld (hl), d 
193b d1				pop de 
193c e1				pop hl 
193d				if DEBUG_FORTH_STACK_GUARD 
193d cd f4 5d				call check_stacks 
1940				endif 
1940 c9				ret 
1941			 
1941			 
1941			; increase ret stack pointer and save hl to it 
1941				 
1941			FORTH_RSP_NEXT: macro 
1941				call macro_forth_rsp_next 
1941				endm 
1941			 
1941			macro_forth_rsp_next: 
1941				if DEBUG_FORTH_STACK_GUARD 
1941 cd f4 5d				call check_stacks 
1944				endif 
1944 e5				push hl 
1945 d5				push de 
1946 eb				ex de,hl 
1947 2a 23 f8			ld hl,(cli_ret_sp) 
194a 23				inc hl 
194b 23				inc hl 
194c 22 23 f8			ld (cli_ret_sp),hl 
194f 73				ld (hl), e 
1950 23				inc hl 
1951 72				ld (hl), d 
1952 d1				pop de 
1953 e1				pop hl 
1954				if DEBUG_FORTH_STACK_GUARD 
1954 cd f4 5d				call check_stacks 
1957				endif 
1957 c9				ret 
1958			 
1958			; get current ret stack pointer and save to hl  
1958				 
1958			FORTH_RSP_TOS: macro 
1958				call macro_forth_rsp_tos 
1958				endm 
1958			 
1958			macro_forth_rsp_tos: 
1958				;push de 
1958 2a 23 f8			ld hl,(cli_ret_sp) 
195b cd 93 19			call loadhlptrtohl 
195e				;ld e, (hl) 
195e				;inc hl 
195e				;ld d, (hl) 
195e				;ex de, hl 
195e					if DEBUG_FORTH_WORDS 
195e			;			DMARK "RST" 
195e						CALLMONITOR 
195e cd 00 14			call break_point_state  
1961				endm  
# End of macro CALLMONITOR
1961					endif 
1961				;pop de 
1961 c9				ret 
1962			 
1962			; pop ret stack pointer 
1962				 
1962			FORTH_RSP_POP: macro 
1962				call macro_forth_rsp_pop 
1962				endm 
1962			 
1962			 
1962			macro_forth_rsp_pop: 
1962				if DEBUG_FORTH_STACK_GUARD 
1962			;		DMARK "RPP" 
1962 cd f4 5d				call check_stacks 
1965					FORTH_CHK_RSP_UNDER 
1965 e5				push hl 
1966 d5				push de 
1967 2a 23 f8			ld hl,(cli_ret_sp) 
196a 11 9d f7			ld de, cli_ret_stack 
196d cd 30 0c			call cmp16 
1970 da 08 5f			jp c, fault_rsp_under 
1973 d1				pop de 
1974 e1				pop hl 
1975				endm 
# End of macro FORTH_CHK_RSP_UNDER
1975				endif 
1975 e5				push hl 
1976 2a 23 f8			ld hl,(cli_ret_sp) 
1979			 
1979			 
1979				if FORTH_ENABLE_FREE 
1979			 
1979					; get pointer 
1979			 
1979					push de 
1979					push hl 
1979			 
1979					ld e, (hl) 
1979					inc hl 
1979					ld d, (hl) 
1979			 
1979					ex de, hl 
1979					call free 
1979			 
1979					pop hl 
1979					pop de 
1979			 
1979			 
1979				endif 
1979			 
1979			 
1979 2b				dec hl 
197a 2b				dec hl 
197b 22 23 f8			ld (cli_ret_sp), hl 
197e				; do stack underflow checks 
197e e1				pop hl 
197f				if DEBUG_FORTH_STACK_GUARD 
197f cd f4 5d				call check_stacks 
1982					FORTH_CHK_RSP_UNDER 
1982 e5				push hl 
1983 d5				push de 
1984 2a 23 f8			ld hl,(cli_ret_sp) 
1987 11 9d f7			ld de, cli_ret_stack 
198a cd 30 0c			call cmp16 
198d da 08 5f			jp c, fault_rsp_under 
1990 d1				pop de 
1991 e1				pop hl 
1992				endm 
# End of macro FORTH_CHK_RSP_UNDER
1992				endif 
1992 c9				ret 
1993			 
1993			 
1993			 
1993			; routine to load word pointed to by hl into hl 
1993			 
1993			loadhlptrtohl: 
1993			 
1993 d5				push de 
1994 5e				ld e, (hl) 
1995 23				inc hl 
1996 56				ld d, (hl) 
1997 eb				ex de, hl 
1998 d1				pop de 
1999			 
1999 c9				ret 
199a			 
199a			 
199a			 
199a			 
199a			 
199a			; push a number held in HL onto the data stack 
199a			; entry point for pushing a value when already in hl used in function above 
199a			 
199a			forth_push_numhl: 
199a			 
199a e5				push hl    ; save value to push 
199b			 
199b			if DEBUG_FORTH_PUSH 
199b				; see if disabled 
199b			 
199b			 
199b				push af 
199b				ld a, (os_view_disable) 
199b				cp '*' 
199b				jr z, .pskip2 
199b				push hl 
199b			push hl 
199b				call clear_display 
199b			pop hl 
199b				ld a,h 
199b				ld hl, os_word_scratch 
199b				call hexout 
199b				pop hl 
199b				ld a,l 
199b				ld hl, os_word_scratch+2 
199b				call hexout 
199b			 
199b				ld hl, os_word_scratch+4 
199b				ld a,0 
199b				ld (hl),a 
199b				ld de,os_word_scratch 
199b					ld a, display_row_2 
199b					call str_at_display 
199b				ld de, .push_num 
199b				ld a, display_row_1 
199b			 
199b					call str_at_display 
199b			 
199b			 
199b				call update_display 
199b				call delay1s 
199b				call delay1s 
199b			.pskip2:  
199b			 
199b				pop af 
199b			endif	 
199b			 
199b			 
199b				FORTH_DSP_NEXT 
199b cd 29 19			call macro_forth_dsp_next 
199e				endm 
# End of macro FORTH_DSP_NEXT
199e			 
199e 2a 1f f8			ld hl, (cli_data_sp) 
19a1			 
19a1				; save item type 
19a1 3e 02			ld a,  DS_TYPE_INUM 
19a3 77				ld (hl), a 
19a4 23				inc hl 
19a5			 
19a5				; get word off stack 
19a5 d1				pop de 
19a6 7b				ld a,e 
19a7 77				ld (hl), a 
19a8 23				inc hl 
19a9 7a				ld a,d 
19aa 77				ld (hl), a 
19ab			 
19ab			if DEBUG_FORTH_PUSH 
19ab				dec hl 
19ab				dec hl 
19ab				dec hl 
19ab						DMARK "PH5" 
19ab				CALLMONITOR 
19ab			endif	 
19ab			 
19ab c9				ret 
19ac			 
19ac			 
19ac			; Push a string to stack pointed to by hl 
19ac			 
19ac			forth_push_str: 
19ac			 
19ac			if DEBUG_FORTH_PUSH 
19ac						DMARK "PSQ" 
19ac				CALLMONITOR 
19ac			endif	 
19ac			    
19ac e5				push hl 
19ad e5				push hl 
19ae			 
19ae 3e 00			ld a, 0   ; find end of string 
19b0 cd 7b 10			call strlent       
19b3			if DEBUG_FORTH_PUSH 
19b3						DMARK "PQ2" 
19b3				CALLMONITOR 
19b3			endif	 
19b3 eb				ex de, hl 
19b4 e1				pop hl   ; get ptr to start of string 
19b5			if DEBUG_FORTH_PUSH 
19b5						DMARK "PQ3" 
19b5				CALLMONITOR 
19b5			endif	 
19b5 19				add hl,de 
19b6			if DEBUG_FORTH_PUSH 
19b6						DMARK "PQE" 
19b6				CALLMONITOR 
19b6			endif	 
19b6			 
19b6 2b				dec hl    ; see if there is an optional trailing double quote 
19b7 7e				ld a,(hl) 
19b8 fe 22			cp '"' 
19ba 20 03			jr nz, .strnoq 
19bc 3e 00			ld a, 0      ; get rid of double quote 
19be 77				ld (hl), a 
19bf 23			.strnoq: inc hl 
19c0			 
19c0 3e 00			ld a, 0 
19c2 77				ld (hl), a     ; add null term and get rid of trailing double quote 
19c3			 
19c3 13				inc de ; add one for the type string 
19c4 13				inc de ; add one for null term??? 
19c5			 
19c5				; tos is get string pointer again 
19c5				; de contains space to allocate 
19c5				 
19c5 d5				push de 
19c6			 
19c6 eb				ex de, hl 
19c7			 
19c7				;push af 
19c7			 
19c7			if DEBUG_FORTH_PUSH 
19c7						DMARK "PHm" 
19c7				CALLMONITOR 
19c7			endif	 
19c7 cd d9 10			call malloc	; on ret hl now contains allocated memory 
19ca				if DEBUG_FORTH_MALLOC_GUARD 
19ca cc 5a 4d				call z,malloc_error 
19cd				endif 
19cd			 
19cd				 
19cd c1				pop bc    ; get length 
19ce d1				pop de   ;  get string start    
19cf			 
19cf				; hl has destination from malloc 
19cf			 
19cf eb				ex de, hl    ; prep for ldir 
19d0			 
19d0 e5				push hl   ; save malloc area for DSP later 
19d1			 
19d1			if DEBUG_FORTH_PUSH 
19d1						DMARK "PHc" 
19d1				CALLMONITOR 
19d1			endif	 
19d1			 
19d1			 
19d1 ed b0			ldir 
19d3			 
19d3			 
19d3				; push malloc to data stack     macro?????  
19d3			 
19d3				FORTH_DSP_NEXT 
19d3 cd 29 19			call macro_forth_dsp_next 
19d6				endm 
# End of macro FORTH_DSP_NEXT
19d6			 
19d6				; save value and type 
19d6			 
19d6 2a 1f f8			ld hl, (cli_data_sp) 
19d9			 
19d9				; save item type 
19d9 3e 01			ld a,  DS_TYPE_STR 
19db 77				ld (hl), a 
19dc 23				inc hl 
19dd			 
19dd				; get malloc word off stack 
19dd d1				pop de 
19de 73				ld (hl), e 
19df 23				inc hl 
19e0 72				ld (hl), d 
19e1			 
19e1			 
19e1			 
19e1			if DEBUG_FORTH_PUSH 
19e1				ld hl, (cli_data_sp) 
19e1						DMARK "PHS" 
19e1				CALLMONITOR 
19e1			;	ex de,hl 
19e1			endif	 
19e1				; in case of spaces, skip the ptr past the copied string 
19e1				;pop af 
19e1				;ld (cli_origptr),hl 
19e1			 
19e1 c9				ret 
19e2			 
19e2			 
19e2			 
19e2			; TODO ascii push input onto stack given hl to start of input 
19e2			 
19e2			; identify type 
19e2			; if starts with a " then a string 
19e2			; otherwise it is a number 
19e2			;  
19e2			; if a string 
19e2			;     scan for ending " to get length of string to malloc for + 1 
19e2			;     malloc 
19e2			;     put pointer to string on stack first byte flags as string 
19e2			; 
19e2			; else a number 
19e2			;    look for number format identifier 
19e2			;    $xx hex 
19e2			;    %xxxxx bin 
19e2			;    xxxxx decimal 
19e2			;    convert number to 16bit word.  
19e2			;    malloc word + 1 with flag to identiy as num 
19e2			;    put pointer to number on stack 
19e2			;   
19e2			;  
19e2			  
19e2			forth_apush: 
19e2				; kernel push 
19e2			 
19e2			if DEBUG_FORTH_PUSH 
19e2						DMARK "PSH" 
19e2				CALLMONITOR 
19e2			endif	 
19e2				; identify input type 
19e2			 
19e2 7e				ld a,(hl) 
19e3 fe 22			cp '"' 
19e5 28 0a			jr z, .fapstr 
19e7 fe 24			cp '$' 
19e9 ca 11 1a			jp z, .faphex 
19ec fe 25			cp '%' 
19ee ca f9 19			jp z, .fapbin 
19f1			;	cp 'b' 
19f1			;	jp z, .fabin 
19f1				; else decimal 
19f1			 
19f1				; TODO do decimal conversion 
19f1				; decimal is stored as a 16bit word 
19f1			 
19f1				; by default everything is a string if type is not detected 
19f1			.fapstr: ; 
19f1 fe 22			cp '"' 
19f3 20 01			jr nz, .strnoqu 
19f5 23				inc hl 
19f6			.strnoqu: 
19f6 c3 ac 19			jp forth_push_str 
19f9			 
19f9			 
19f9			 
19f9			.fapbin:    ; push a binary string.  
19f9 11 00 00			ld de, 0   ; hold a 16bit value 
19fc			 
19fc 23			.fapbinshift:	inc hl  
19fd 7e				ld a,(hl) 
19fe fe 00			cp 0     ; done scanning  
1a00 28 0b			jr z, .fapbdone  	; got it in HL so push  
1a02			 
1a02				; left shift de 
1a02 eb				ex de, hl	 
1a03 29				add hl, hl 
1a04			 
1a04				; is 1 
1a04 fe 31			cp '1' 
1a06 20 02			jr nz, .binzero 
1a08 cb 4d			bit 1, l 
1a0a			.binzero: 
1a0a eb				ex de, hl	 ; save current de 
1a0b 18 ef			jr .fapbinshift 
1a0d			 
1a0d			.fapbdone: 
1a0d eb				ex de, hl 
1a0e c3 9a 19			jp forth_push_numhl 
1a11			 
1a11			 
1a11			.faphex:   ; hex is always stored as a 16bit word 
1a11				; skip number prefix 
1a11 23				inc hl 
1a12				; turn ascii into number 
1a12 cd c9 0f			call get_word_hl	; ret 16bit word in hl 
1a15			 
1a15 c3 9a 19			jp forth_push_numhl 
1a18			 
1a18 00				 nop 
1a19			 
1a19			.fabin:   ; TODO bin conversion 
1a19			 
1a19			 
1a19 c9				ret 
1a1a			 
1a1a			 
1a1a			; get either a string ptr or a 16bit word from the data stack 
1a1a			 
1a1a			FORTH_DSP: macro 
1a1a				call macro_forth_dsp 
1a1a				endm 
1a1a			 
1a1a			macro_forth_dsp: 
1a1a				; data stack pointer points to current word on tos 
1a1a			 
1a1a 2a 1f f8			ld hl,(cli_data_sp) 
1a1d			 
1a1d				if DEBUG_FORTH_PUSH 
1a1d						DMARK "DSP" 
1a1d			 
1a1d					call display_data_sp 
1a1d				;call break_point_state 
1a1d				;rst 030h 
1a1d				CALLMONITOR 
1a1d				endif 
1a1d			 
1a1d c9				ret 
1a1e			 
1a1e			; return hl to start of value on stack 
1a1e			 
1a1e			FORTH_DSP_VALUE: macro 
1a1e				call macro_forth_dsp_value 
1a1e				endm 
1a1e			 
1a1e			macro_forth_dsp_value: 
1a1e			 
1a1e				FORTH_DSP 
1a1e cd 1a 1a			call macro_forth_dsp 
1a21				endm 
# End of macro FORTH_DSP
1a21			 
1a21 d5				push de 
1a22			 
1a22 23				inc hl ; skip type 
1a23			 
1a23 5e				ld e, (hl) 
1a24 23				inc hl 
1a25 56				ld d, (hl) 
1a26 eb				ex de,hl  
1a27			 
1a27 d1				pop de 
1a28			 
1a28 c9				ret 
1a29			 
1a29			; return hl to start of value to second item on stack 
1a29			 
1a29			FORTH_DSP_VALUEM1: macro 
1a29				call macro_forth_dsp_value_m1 
1a29				endm 
1a29			 
1a29			macro_forth_dsp_value_m1: 
1a29			 
1a29				FORTH_DSP 
1a29 cd 1a 1a			call macro_forth_dsp 
1a2c				endm 
# End of macro FORTH_DSP
1a2c			 
1a2c 2b				dec hl 
1a2d 2b				dec hl 
1a2e			;	dec hl 
1a2e			 
1a2e d5				push de 
1a2f			 
1a2f 5e				ld e, (hl) 
1a30 23				inc hl 
1a31 56				ld d, (hl) 
1a32 eb				ex de,hl  
1a33			 
1a33 d1				pop de 
1a34			 
1a34 c9				ret 
1a35			 
1a35				 
1a35			 
1a35			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1a35			 
1a35			FORTH_DSP_POP: macro 
1a35				call macro_forth_dsp_pop 
1a35				endm 
1a35			 
1a35			 
1a35			; get the tos data type 
1a35			 
1a35			FORTH_DSP_TYPE:   macro 
1a35			 
1a35				;FORTH_DSP_VALUE 
1a35				FORTH_DSP 
1a35				 
1a35				; hl points to value 
1a35				; check type 
1a35			 
1a35				ld a,(hl) 
1a35			 
1a35				endm 
1a35			 
1a35			; load the tos value into hl 
1a35			 
1a35			 
1a35			FORTH_DSP_VALUEHL:  macro 
1a35				call macro_dsp_valuehl 
1a35				endm 
1a35			 
1a35			 
1a35			 
1a35			macro_dsp_valuehl: 
1a35				FORTH_DSP_VALUE 
1a35 cd 1e 1a			call macro_forth_dsp_value 
1a38				endm 
# End of macro FORTH_DSP_VALUE
1a38			 
1a38				;FORTH_ERR_TOS_NOTNUM 
1a38			 
1a38				;inc hl   ; skip type id 
1a38			 
1a38			;	push de 
1a38			; 
1a38			;	ld e, (hl) 
1a38			;	inc hl 
1a38			;	ld d, (hl) 
1a38			;	ex de,hl  
1a38			 
1a38			;	pop de 
1a38			 
1a38				if DEBUG_FORTH_PUSH 
1a38						DMARK "DVL" 
1a38				CALLMONITOR 
1a38				endif 
1a38 c9				ret 
1a39			 
1a39			forth_apushstrhl:      
1a39				; push of string requires use of cli_origptr 
1a39				; bodge use 
1a39			 
1a39				; get current cli_origptr, save, update with temp pointer  
1a39 ed 5b 3b f8		ld de, (cli_origptr) 
1a3d 22 3b f8			ld (cli_origptr), hl 
1a40 d5				push de 
1a41 cd e2 19			call forth_apush 
1a44 d1				pop de 
1a45 ed 53 3b f8		ld (cli_origptr), de 
1a49 c9			        ret	 
1a4a			 
1a4a			 
1a4a			; increase loop stack pointer and save hl to it 
1a4a				 
1a4a			FORTH_LOOP_NEXT: macro 
1a4a				call macro_forth_loop_next 
1a4a				;nop 
1a4a				endm 
1a4a			 
1a4a			macro_forth_loop_next: 
1a4a				if DEBUG_FORTH_STACK_GUARD 
1a4a cd f4 5d				call check_stacks 
1a4d				endif 
1a4d e5				push hl 
1a4e d5				push de 
1a4f eb				ex de,hl 
1a50 2a 21 f8			ld hl,(cli_loop_sp) 
1a53 23				inc hl 
1a54 23				inc hl 
1a55					if DEBUG_FORTH_WORDS 
1a55						DMARK "LNX" 
1a55 f5				push af  
1a56 3a 6a 1a			ld a, (.dmark)  
1a59 32 77 fb			ld (debug_mark),a  
1a5c 3a 6b 1a			ld a, (.dmark+1)  
1a5f 32 78 fb			ld (debug_mark+1),a  
1a62 3a 6c 1a			ld a, (.dmark+2)  
1a65 32 79 fb			ld (debug_mark+2),a  
1a68 18 03			jr .pastdmark  
1a6a ..			.dmark: db "LNX"  
1a6d f1			.pastdmark: pop af  
1a6e			endm  
# End of macro DMARK
1a6e						CALLMONITOR 
1a6e cd 00 14			call break_point_state  
1a71				endm  
# End of macro CALLMONITOR
1a71					endif 
1a71 22 21 f8			ld (cli_loop_sp),hl 
1a74 73				ld (hl), e 
1a75 23				inc hl 
1a76 72				ld (hl), d 
1a77 d1				pop de    ; been reversed so save a swap on restore 
1a78 e1				pop hl 
1a79				if DEBUG_FORTH_STACK_GUARD 
1a79 cd f4 5d				call check_stacks 
1a7c				endif 
1a7c c9				ret 
1a7d			 
1a7d			; get current ret stack pointer and save to hl  
1a7d				 
1a7d			FORTH_LOOP_TOS: macro 
1a7d				call macro_forth_loop_tos 
1a7d				endm 
1a7d			 
1a7d			macro_forth_loop_tos: 
1a7d d5				push de 
1a7e 2a 21 f8			ld hl,(cli_loop_sp) 
1a81 5e				ld e, (hl) 
1a82 23				inc hl 
1a83 56				ld d, (hl) 
1a84 eb				ex de, hl 
1a85 d1				pop de 
1a86 c9				ret 
1a87			 
1a87			; pop loop stack pointer 
1a87				 
1a87			FORTH_LOOP_POP: macro 
1a87				call macro_forth_loop_pop 
1a87				endm 
1a87			 
1a87			 
1a87			macro_forth_loop_pop: 
1a87				if DEBUG_FORTH_STACK_GUARD 
1a87					DMARK "LPP" 
1a87 f5				push af  
1a88 3a 9c 1a			ld a, (.dmark)  
1a8b 32 77 fb			ld (debug_mark),a  
1a8e 3a 9d 1a			ld a, (.dmark+1)  
1a91 32 78 fb			ld (debug_mark+1),a  
1a94 3a 9e 1a			ld a, (.dmark+2)  
1a97 32 79 fb			ld (debug_mark+2),a  
1a9a 18 03			jr .pastdmark  
1a9c ..			.dmark: db "LPP"  
1a9f f1			.pastdmark: pop af  
1aa0			endm  
# End of macro DMARK
1aa0 cd f4 5d				call check_stacks 
1aa3					FORTH_CHK_LOOP_UNDER 
1aa3 e5				push hl 
1aa4 d5				push de 
1aa5 2a 21 f8			ld hl,(cli_loop_sp) 
1aa8 11 9b f5			ld de, cli_loop_stack 
1aab cd 30 0c			call cmp16 
1aae da 0e 5f			jp c, fault_loop_under 
1ab1 d1				pop de 
1ab2 e1				pop hl 
1ab3				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1ab3				endif 
1ab3 e5				push hl 
1ab4 2a 21 f8			ld hl,(cli_loop_sp) 
1ab7 2b				dec hl 
1ab8 2b				dec hl 
1ab9 22 21 f8			ld (cli_loop_sp), hl 
1abc				; TODO do stack underflow checks 
1abc e1				pop hl 
1abd				if DEBUG_FORTH_STACK_GUARD 
1abd cd f4 5d				call check_stacks 
1ac0					FORTH_CHK_LOOP_UNDER 
1ac0 e5				push hl 
1ac1 d5				push de 
1ac2 2a 21 f8			ld hl,(cli_loop_sp) 
1ac5 11 9b f5			ld de, cli_loop_stack 
1ac8 cd 30 0c			call cmp16 
1acb da 0e 5f			jp c, fault_loop_under 
1ace d1				pop de 
1acf e1				pop hl 
1ad0				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1ad0				endif 
1ad0 c9				ret 
1ad1			 
1ad1			macro_forth_dsp_pop: 
1ad1			 
1ad1 e5				push hl 
1ad2			 
1ad2				; release malloc data 
1ad2			 
1ad2				if DEBUG_FORTH_STACK_GUARD 
1ad2 cd f4 5d				call check_stacks 
1ad5					FORTH_CHK_DSP_UNDER 
1ad5 e5				push hl 
1ad6 d5				push de 
1ad7 2a 1f f8			ld hl,(cli_data_sp) 
1ada 11 99 f3			ld de, cli_data_stack 
1add cd 30 0c			call cmp16 
1ae0 da 02 5f			jp c, fault_dsp_under 
1ae3 d1				pop de 
1ae4 e1				pop hl 
1ae5				endm 
# End of macro FORTH_CHK_DSP_UNDER
1ae5				endif 
1ae5				;ld hl,(cli_data_sp) 
1ae5			if DEBUG_FORTH_DOT 
1ae5				DMARK "DPP" 
1ae5				CALLMONITOR 
1ae5			endif	 
1ae5			 
1ae5			 
1ae5			if FORTH_ENABLE_DSPPOPFREE 
1ae5			 
1ae5				FORTH_DSP 
1ae5 cd 1a 1a			call macro_forth_dsp 
1ae8				endm 
# End of macro FORTH_DSP
1ae8			 
1ae8 7e				ld a, (hl) 
1ae9 fe 01			cp DS_TYPE_STR 
1aeb 20 07			jr nz, .skippopfree 
1aed			 
1aed				FORTH_DSP_VALUEHL 
1aed cd 35 1a			call macro_dsp_valuehl 
1af0				endm 
# End of macro FORTH_DSP_VALUEHL
1af0 00				nop 
1af1			if DEBUG_FORTH_DOT 
1af1				DMARK "DPf" 
1af1				CALLMONITOR 
1af1			endif	 
1af1 cd a3 11			call free 
1af4			.skippopfree: 
1af4				 
1af4			 
1af4			endif 
1af4			 
1af4			if DEBUG_FORTH_DOT_KEY 
1af4				DMARK "DP2" 
1af4				CALLMONITOR 
1af4			endif	 
1af4			 
1af4				; move pointer down 
1af4			 
1af4 2a 1f f8			ld hl,(cli_data_sp) 
1af7 2b				dec hl 
1af8 2b				dec hl 
1af9			; PARSEV5 
1af9 2b				dec hl 
1afa 22 1f f8			ld (cli_data_sp), hl 
1afd			 
1afd				if DEBUG_FORTH_STACK_GUARD 
1afd cd f4 5d				call check_stacks 
1b00					FORTH_CHK_DSP_UNDER 
1b00 e5				push hl 
1b01 d5				push de 
1b02 2a 1f f8			ld hl,(cli_data_sp) 
1b05 11 99 f3			ld de, cli_data_stack 
1b08 cd 30 0c			call cmp16 
1b0b da 02 5f			jp c, fault_dsp_under 
1b0e d1				pop de 
1b0f e1				pop hl 
1b10				endm 
# End of macro FORTH_CHK_DSP_UNDER
1b10				endif 
1b10			 
1b10 e1				pop hl 
1b11			 
1b11 c9				ret 
1b12			 
1b12			getwordathl: 
1b12				; hl points to an address 
1b12				; load hl with the word at that address 
1b12			 
1b12 d5				push de 
1b13			 
1b13 5e				ld e, (hl) 
1b14 23				inc hl 
1b15 56				ld d, (hl) 
1b16 eb				ex de, hl 
1b17			 
1b17 d1				pop de 
1b18 c9				ret 
1b19			 
1b19			 
1b19			 
1b19			 
1b19			 
1b19			; eof 
1b19			 
# End of file forth_stackopsv5.asm
1b19			endif 
1b19			 
1b19			user_word_eol:  
1b19				; hl contains the pointer to where to create a linked list item from the end 
1b19				; of the user dict to continue on at the system word dict 
1b19				 
1b19				; poke the stub of the word list linked list to repoint to rom words 
1b19			 
1b19				; stub format 
1b19				; db   word id 
1b19				; dw    link to next word 
1b19			        ; db char length of token 
1b19				; db string + 0 term 
1b19				; db exec code....  
1b19			 
1b19 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1b1b 77				ld (hl), a		; word id 
1b1c 23				inc hl 
1b1d			 
1b1d 11 e3 1c			ld de, sysdict 
1b20 73				ld (hl), e		; next word link ie system dict 
1b21 23				inc hl 
1b22 72				ld (hl), d		; next word link ie system dict 
1b23 23				inc hl	 
1b24			 
1b24			;	ld (hl), sysdict		; next word link ie system dict 
1b24			;	inc hl 
1b24			;	inc hl 
1b24			 
1b24			;	inc hl 
1b24			;	inc hl 
1b24			 
1b24 3e 02			ld a, 2			; word length is 0 
1b26 77				ld (hl), a	 
1b27 23				inc hl 
1b28			 
1b28 3e 7e			ld a, '~'			; word length is 0 
1b2a 77				ld (hl), a	 
1b2b 23				inc hl 
1b2c 3e 00			ld a, 0			; save empty word 
1b2e 77				ld (hl), a 
1b2f			 
1b2f c9				ret 
1b30			 
1b30				 
1b30			 
1b30			forthexec_cleanup: 
1b30				FORTH_RSP_POP 
1b30 cd 62 19			call macro_forth_rsp_pop 
1b33				endm 
# End of macro FORTH_RSP_POP
1b33 c9				ret 
1b34			 
1b34			forth_call_hl: 
1b34				; taking hl 
1b34 e5				push hl 
1b35 c9				ret 
1b36			 
1b36			; this is called to reset Forth system but keep existing uwords etc 
1b36			 
1b36			forth_warmstart: 
1b36				; setup stack over/under flow checks 
1b36				if DEBUG_FORTH_STACK_GUARD 
1b36 cd da 5d				call chk_stk_init 
1b39				endif 
1b39			 
1b39				; init stack pointers  - * these stacks go upwards *  
1b39 21 9d f7			ld hl, cli_ret_stack 
1b3c 22 23 f8			ld (cli_ret_sp), hl	 
1b3f				; set bottom of stack 
1b3f 3e 00			ld a,0 
1b41 77				ld (hl),a 
1b42 23				inc hl 
1b43 77				ld (hl),a 
1b44			 
1b44 21 99 f3			ld hl, cli_data_stack 
1b47 22 1f f8			ld (cli_data_sp), hl	 
1b4a				; set bottom of stack 
1b4a 3e 00			ld a,0 
1b4c 77				ld (hl),a 
1b4d 23				inc hl 
1b4e 77				ld (hl),a 
1b4f			 
1b4f 21 9b f5			ld hl, cli_loop_stack 
1b52 22 21 f8			ld (cli_loop_sp), hl	 
1b55				; set bottom of stack 
1b55 3e 00			ld a,0 
1b57 77				ld (hl),a 
1b58 23				inc hl 
1b59 77				ld (hl),a 
1b5a			 
1b5a				; init extent of current open file 
1b5a			 
1b5a 3e 00			ld a, 0 
1b5c 32 59 f8			ld (store_openext), a 
1b5f			 
1b5f c9				ret 
1b60			 
1b60			 
1b60			; Cold Start - this is called to setup the whole Forth system 
1b60			 
1b60			forth_init: 
1b60			 
1b60				; setup stack over/under flow checks 
1b60			 
1b60			;	if DEBUG_FORTH_STACK_GUARD 
1b60			;		call chk_stk_init 
1b60			;	endif 
1b60			 
1b60				; enable auto display updates (slow.....) 
1b60			 
1b60 3e 01			ld a, 1 
1b62 32 39 f8			ld (cli_autodisplay), a 
1b65			 
1b65			 
1b65			 
1b65				; show start up screen 
1b65			 
1b65 cd b9 0a			call clear_display 
1b68			 
1b68 3e 00			ld a,0 
1b6a 32 5b f8			ld (f_cursor_ptr), a 
1b6d			 
1b6d				; set start of word list in start of ram - for use when creating user words 
1b6d			 
1b6d 21 00 80			ld hl, baseram 
1b70 22 2f f1			ld (os_last_new_uword), hl 
1b73 cd 19 1b			call user_word_eol 
1b76				 
1b76			;		call display_data_sp 
1b76			;		call next_page_prompt 
1b76			 
1b76			 
1b76			 
1b76			 
1b76 c9				ret 
1b77			 
1b77 .. 00		.bootforth: db " Forth Kernel Init ",0 
1b8b			 
1b8b			; TODO push to stack 
1b8b			 
1b8b			;  
1b8b			 
1b8b			if FORTH_PARSEV2 
1b8b			 
1b8b			 
1b8b				include "forth_parserv2.asm" 
1b8b			 
1b8b			endif 
1b8b			 
1b8b			 
1b8b			; parse cli version 1 
1b8b			 
1b8b			if FORTH_PARSEV1 
1b8b			 
1b8b			 
1b8b			 
1b8b			      include "forth_parserv1.asm" 
1b8b			endif 
1b8b				 
1b8b			if FORTH_PARSEV3 
1b8b			 
1b8b			 
1b8b			 
1b8b			      include "forth_parserv3.asm" 
1b8b				include "forth_wordsv3.asm" 
1b8b			endif 
1b8b			 
1b8b			if FORTH_PARSEV4 
1b8b			 
1b8b			 
1b8b			 
1b8b			      include "forth_parserv4.asm" 
1b8b				include "forth_wordsv4.asm" 
1b8b			endif 
1b8b			 
1b8b			if FORTH_PARSEV5 
1b8b			 
1b8b			 
1b8b			 
1b8b			      include "forth_parserv5.asm" 
1b8b			 
1b8b			 
1b8b			; A better parser without using malloc and string copies all over the place.  
1b8b			; Exec in situ should be faster 
1b8b			 
1b8b			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
1b8b			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
1b8b			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
1b8b			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
1b8b			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
1b8b			WORD_SYS_END: equ 0   ; Opcode for all user words 
1b8b			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
1b8b			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
1b8b			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
1b8b			 
1b8b			; Core word preamble macro 
1b8b			 
1b8b			CWHEAD:   macro nxtword opcode lit len opflags 
1b8b				db WORD_SYS_CORE+opcode             
1b8b				; internal op code number 
1b8b				dw nxtword            
1b8b				; link to next dict word block 
1b8b				db len + 1 
1b8b				; literal length of dict word inc zero term 
1b8b				db lit,0              
1b8b				; literal dict word 
1b8b			        ; TODO db opflags        
1b8b				endm 
1b8b			 
1b8b			 
1b8b			NEXTW: macro  
1b8b				jp macro_next 
1b8b				endm 
1b8b			 
1b8b			macro_next: 
1b8b			if DEBUG_FORTH_PARSE_KEY 
1b8b				DMARK "NXT" 
1b8b				CALLMONITOR 
1b8b			endif	 
1b8b			;	inc hl  ; skip token null term  
1b8b ed 4b 3d f8		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1b8f ed 5b 3b f8		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1b93 2a 33 f1			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1b96			if DEBUG_FORTH_PARSE_KEY 
1b96				DMARK "}AA" 
1b96				CALLMONITOR 
1b96			endif	 
1b96 c3 99 1c			jp execnext 
1b99				;jp exec1 
1b99			       
1b99			 
1b99			 
1b99			; Another go at the parser to compile  
1b99			 
1b99			 
1b99			; TODO rework parser to change all of the string words to byte tokens 
1b99			; TODO do a search for  
1b99			 
1b99			; TODO first run normal parser to zero term sections 
1b99			; TODO for each word do a token look up to get the op code 
1b99			; TODO need some means to flag to the exec that this is a byte code form    
1b99			 
1b99			 
1b99			forthcompile: 
1b99			 
1b99			; 
1b99			; line parse: 
1b99			;       parse raw input buffer 
1b99			;       tokenise the words 
1b99			;       malloc new copy (for looping etc) 
1b99			;       copy to malloc + current pc in line to start of string and add line term 
1b99			;       save on new rsp 
1b99			; 
1b99			 
1b99			; hl to point to the line to tokenise 
1b99			 
1b99			;	push hl 
1b99 22 33 f1			ld (os_tok_ptr), hl  ; save ptr to string 
1b9c			 
1b9c			;	ld a,0		; string term on input 
1b9c			;	call strlent 
1b9c			 
1b9c			;	ld (os_tok_len), hl	 ; save string length 
1b9c			 
1b9c			;if DEBUG_FORTH_TOK 
1b9c			;	ex de,hl		 
1b9c			;endif 
1b9c			 
1b9c			;	pop hl 		; get back string pointer 
1b9c			 
1b9c			if DEBUG_FORTH_TOK 
1b9c						DMARK "TOc" 
1b9c				CALLMONITOR 
1b9c			endif 
1b9c 7e			.cptoken2:    ld a,(hl) 
1b9d 23				inc hl 
1b9e fe 7f			cp FORTH_END_BUFFER 
1ba0 28 29			jr z, .cptokendone2 
1ba2 fe 00			cp 0 
1ba4 28 25			jr z, .cptokendone2 
1ba6 fe 22			cp '"' 
1ba8 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
1baa fe 20			cp ' ' 
1bac 20 ee			jr nz,  .cptoken2 
1bae			 
1bae			; TODO consume comments held between ( and ) 
1bae			 
1bae				; we have a space so change to zero term for dict match later 
1bae 2b				dec hl 
1baf 3e 00			ld a,0 
1bb1 77				ld (hl), a 
1bb2 23				inc hl 
1bb3 18 e7			jr .cptoken2 
1bb5				 
1bb5			 
1bb5			.cptokenstr2: 
1bb5				; skip all white space until either eol (because forgot to term) or end double quote 
1bb5			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1bb5				;inc hl ; skip current double quote 
1bb5 7e				ld a,(hl) 
1bb6 23				inc hl 
1bb7 fe 22			cp '"' 
1bb9 28 e1			jr z, .cptoken2 
1bbb fe 7f			cp FORTH_END_BUFFER 
1bbd 28 0c			jr z, .cptokendone2 
1bbf fe 00			cp 0 
1bc1 28 08			jr z, .cptokendone2 
1bc3 fe 20			cp ' ' 
1bc5 28 02			jr z, .cptmp2 
1bc7 18 ec			jr .cptokenstr2 
1bc9			 
1bc9			.cptmp2:	; we have a space so change to zero term for dict match later 
1bc9				;dec hl 
1bc9				;ld a,"-"	; TODO remove this when working 
1bc9				;ld (hl), a 
1bc9				;inc hl 
1bc9 18 ea			jr .cptokenstr2 
1bcb			 
1bcb			.cptokendone2: 
1bcb				;inc hl 
1bcb 3e 7f			ld a, FORTH_END_BUFFER 
1bcd 77				ld (hl),a 
1bce 23				inc hl 
1bcf 3e 21			ld a, '!' 
1bd1 77				ld (hl),a 
1bd2			 
1bd2 2a 33 f1			ld hl,(os_tok_ptr) 
1bd5			         
1bd5			if DEBUG_FORTH_TOK 
1bd5						DMARK "Tc1" 
1bd5				CALLMONITOR 
1bd5			endif 
1bd5			 
1bd5				; push exec string to top of return stack 
1bd5				FORTH_RSP_NEXT 
1bd5 cd 41 19			call macro_forth_rsp_next 
1bd8				endm 
# End of macro FORTH_RSP_NEXT
1bd8 c9				ret 
1bd9			 
1bd9			; Another go at the parser need to simplify the process 
1bd9			 
1bd9			forthparse: 
1bd9			 
1bd9			; 
1bd9			; line parse: 
1bd9			;       parse raw input buffer 
1bd9			;       tokenise the words 
1bd9			;       malloc new copy (for looping etc) 
1bd9			;       copy to malloc + current pc in line to start of string and add line term 
1bd9			;       save on new rsp 
1bd9			; 
1bd9			 
1bd9			; hl to point to the line to tokenise 
1bd9			 
1bd9			;	push hl 
1bd9 22 33 f1			ld (os_tok_ptr), hl  ; save ptr to string 
1bdc			 
1bdc			;	ld a,0		; string term on input 
1bdc			;	call strlent 
1bdc			 
1bdc			;	ld (os_tok_len), hl	 ; save string length 
1bdc			 
1bdc			;if DEBUG_FORTH_TOK 
1bdc			;	ex de,hl		 
1bdc			;endif 
1bdc			 
1bdc			;	pop hl 		; get back string pointer 
1bdc			 
1bdc			if DEBUG_FORTH_TOK 
1bdc						DMARK "TOK" 
1bdc				CALLMONITOR 
1bdc			endif 
1bdc 7e			.ptoken2:    ld a,(hl) 
1bdd 23				inc hl 
1bde fe 7f			cp FORTH_END_BUFFER 
1be0 28 29			jr z, .ptokendone2 
1be2 fe 00			cp 0 
1be4 28 25			jr z, .ptokendone2 
1be6 fe 22			cp '"' 
1be8 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
1bea fe 20			cp ' ' 
1bec 20 ee			jr nz,  .ptoken2 
1bee			 
1bee			; TODO consume comments held between ( and ) 
1bee			 
1bee				; we have a space so change to zero term for dict match later 
1bee 2b				dec hl 
1bef 3e 00			ld a,0 
1bf1 77				ld (hl), a 
1bf2 23				inc hl 
1bf3 18 e7			jr .ptoken2 
1bf5				 
1bf5			 
1bf5			.ptokenstr2: 
1bf5				; skip all white space until either eol (because forgot to term) or end double quote 
1bf5			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1bf5				;inc hl ; skip current double quote 
1bf5 7e				ld a,(hl) 
1bf6 23				inc hl 
1bf7 fe 22			cp '"' 
1bf9 28 e1			jr z, .ptoken2 
1bfb fe 7f			cp FORTH_END_BUFFER 
1bfd 28 0c			jr z, .ptokendone2 
1bff fe 00			cp 0 
1c01 28 08			jr z, .ptokendone2 
1c03 fe 20			cp ' ' 
1c05 28 02			jr z, .ptmp2 
1c07 18 ec			jr .ptokenstr2 
1c09			 
1c09			.ptmp2:	; we have a space so change to zero term for dict match later 
1c09				;dec hl 
1c09				;ld a,"-"	; TODO remove this when working 
1c09				;ld (hl), a 
1c09				;inc hl 
1c09 18 ea			jr .ptokenstr2 
1c0b			 
1c0b			.ptokendone2: 
1c0b				;inc hl 
1c0b 3e 7f			ld a, FORTH_END_BUFFER 
1c0d 77				ld (hl),a 
1c0e 23				inc hl 
1c0f 3e 21			ld a, '!' 
1c11 77				ld (hl),a 
1c12			 
1c12 2a 33 f1			ld hl,(os_tok_ptr) 
1c15			         
1c15			if DEBUG_FORTH_TOK 
1c15						DMARK "TK1" 
1c15				CALLMONITOR 
1c15			endif 
1c15			 
1c15				; push exec string to top of return stack 
1c15				FORTH_RSP_NEXT 
1c15 cd 41 19			call macro_forth_rsp_next 
1c18				endm 
# End of macro FORTH_RSP_NEXT
1c18 c9				ret 
1c19			 
1c19			; 
1c19			;	; malloc size + buffer pointer + if is loop flag 
1c19			;	ld hl,(os_tok_len) 		 ; get string length 
1c19			; 
1c19			;	ld a,l 
1c19			; 
1c19			;	cp 0			; we dont want to use a null string 
1c19			;	ret z 
1c19			; 
1c19			;;	add 3    ; prefix malloc with buffer for current word ptr 
1c19			; 
1c19			;	add 5     ; TODO when certain not over writing memory remove 
1c19			; 
1c19			;		 
1c19			; 
1c19			;if DEBUG_FORTH_TOK 
1c19			;			DMARK "TKE" 
1c19			;	CALLMONITOR 
1c19			;endif 
1c19			; 
1c19			;	ld l,a 
1c19			;	ld h,0 
1c19			;;	push hl   ; save required space for the copy later 
1c19			;	call malloc 
1c19			;if DEBUG_FORTH_TOK 
1c19			;			DMARK "TKM" 
1c19			;	CALLMONITOR 
1c19			;endif 
1c19			;	if DEBUG_FORTH_MALLOC_GUARD 
1c19			;		push af 
1c19			;		call ishlzero 
1c19			;;		ld a, l 
1c19			;;		add h 
1c19			;;		cp 0 
1c19			;		pop af 
1c19			;		 
1c19			;		call z,malloc_error 
1c19			;	endif 
1c19			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
1c19			; 
1c19			; 
1c19			;if DEBUG_FORTH_TOK 
1c19			;			DMARK "TKR" 
1c19			;	CALLMONITOR 
1c19			;endif 
1c19			; 
1c19			;	FORTH_RSP_NEXT 
1c19			; 
1c19			;	;inc hl	 ; go past current buffer pointer 
1c19			;	;inc hl 
1c19			;	;inc hl   ; and past if loop flag 
1c19			;		; TODO Need to set flag  
1c19			; 
1c19			;	 
1c19			;	 
1c19			;	ex de,hl	; malloc is dest 
1c19			;	ld hl, (os_tok_len) 
1c19			;;	pop bc 
1c19			;	ld c, l                
1c19			;	ld b,0 
1c19			;	ld hl, (os_tok_ptr) 
1c19			; 
1c19			;if DEBUG_FORTH_TOK 
1c19			;			DMARK "TKT" 
1c19			;	CALLMONITOR 
1c19			;endif 
1c19			; 
1c19			;	; do str cpy 
1c19			; 
1c19			;	ldir      ; copy byte in hl to de 
1c19			; 
1c19			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
1c19			; 
1c19			;if DEBUG_FORTH_TOK 
1c19			; 
1c19			;			DMARK "TKY" 
1c19			;	CALLMONITOR 
1c19			;endif 
1c19			;	;ld a,0 
1c19			;	;ld a,FORTH_END_BUFFER 
1c19			;	ex de, hl 
1c19			;	;dec hl			 ; go back over the space delim at the end of word 
1c19			;	;ld (hl),a 
1c19			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
1c19			;	ld a,FORTH_END_BUFFER 
1c19			;	ld (hl),a 
1c19			;	inc hl 
1c19			;	ld a,FORTH_END_BUFFER 
1c19			;	ld (hl),a 
1c19			; 
1c19			;	; init the malloc area data 
1c19			;	; set pc for in current area 
1c19			;	;ld hl, (os_tok_malloc) 
1c19			;	;inc hl 
1c19			;	;inc hl 
1c19			;	;inc hl 
1c19			;	;ex de,hl 
1c19			;	;ld hl, (os_tok_malloc) 
1c19			;	;ld (hl),e 
1c19			;	;inc hl 
1c19			;	;ld (hl),d 
1c19			; 
1c19			; 
1c19			;	ld hl,(os_tok_malloc) 
1c19			;if DEBUG_FORTH_PARSE_KEY 
1c19			;			DMARK "TKU" 
1c19			;	CALLMONITOR 
1c19			;endif 
1c19			; 
1c19			;	ret 
1c19			 
1c19			forthexec: 
1c19			 
1c19			; line exec: 
1c19			; forth parser 
1c19			 
1c19			; 
1c19			;       get current exec line on rsp 
1c19			 
1c19				FORTH_RSP_TOS 
1c19 cd 58 19			call macro_forth_rsp_tos 
1c1c				endm 
# End of macro FORTH_RSP_TOS
1c1c			 
1c1c			;       restore current pc - hl points to malloc of data 
1c1c			 
1c1c				;ld e, (hl) 
1c1c				;inc hl 
1c1c				;ld d, (hl) 
1c1c				;ex de,hl 
1c1c			 
1c1c			 
1c1c			exec1: 
1c1c 22 33 f1			ld (os_tok_ptr), hl 
1c1f			 
1c1f				; copy our PC to working vars  
1c1f 22 3d f8			ld (cli_ptr), hl 
1c22 22 3b f8			ld (cli_origptr), hl 
1c25			 
1c25 7e				ld a,(hl) 
1c26 fe 7f			cp FORTH_END_BUFFER 
1c28 c8				ret z 
1c29			 
1c29				; skip any nulls 
1c29			 
1c29 fe 00			cp 0 
1c2b 20 03			jr nz, .execword 
1c2d 23				inc hl 
1c2e 18 ec			jr exec1 
1c30			 
1c30			 
1c30			.execword: 
1c30			 
1c30			 
1c30			 
1c30			if DEBUG_FORTH_PARSE_KEY 
1c30						DMARK "KYQ" 
1c30				CALLMONITOR 
1c30			endif 
1c30			;       while at start of word: 
1c30			; get start of dict (in user area first) 
1c30			 
1c30 21 00 80		ld hl, baseram 
1c33			;ld hl, sysdict 
1c33 22 3f f8		ld (cli_nextword),hl 
1c36			;           match word at pc 
1c36			;           exec word 
1c36			;           or push to dsp 
1c36			;           forward to next token 
1c36			;           if line term pop rsp and exit 
1c36			;        
1c36			 
1c36			if DEBUG_FORTH_PARSE_KEY 
1c36						DMARK "KYq" 
1c36				CALLMONITOR 
1c36			endif 
1c36			 
1c36			; 
1c36			; word comp 
1c36			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
1c36			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
1c36			;    move to start of word  
1c36			;    compare word to cli_token 
1c36			 
1c36			.execpnword:	; HL at start of a word in the dictionary to check 
1c36			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
1c36			;	ld (cli_ptr), hl 
1c36			 
1c36 2a 3f f8			ld hl,(cli_nextword) 
1c39			 
1c39 cd dc 1c			call forth_tok_next 
1c3c			; tok next start here 
1c3c			;	; TODO skip compiled symbol for now 
1c3c			;	inc hl 
1c3c			; 
1c3c			;	; save pointer to next word 
1c3c			; 
1c3c			;	; hl now points to the address of the next word pointer  
1c3c			;	ld e, (hl) 
1c3c			;	inc hl 
1c3c			;	ld d, (hl) 
1c3c			;	inc l 
1c3c			; 
1c3c			;	ex de,hl 
1c3c			;if DEBUG_FORTH_PARSE_NEXTWORD 
1c3c			;	push bc 
1c3c			;	ld bc, (cli_nextword) 
1c3c			;			DMARK "NXW" 
1c3c			;	CALLMONITOR 
1c3c			;	pop bc 
1c3c			;endif 
1c3c			; tok next end here 
1c3c 22 3f f8			ld (cli_nextword), hl     ; save for next check if no match on this word 
1c3f eb				ex de, hl 
1c40			 
1c40			 
1c40				; save the pointer of the current token - 1 to check against 
1c40				 
1c40 22 43 f8			ld (cli_token), hl   
1c43				; TODO maybe remove below save if no debug 
1c43				; save token string ptr for any debug later 
1c43 23				inc hl  
1c44 22 45 f8			ld (cli_origtoken), hl 
1c47 2b				dec hl 
1c48				; save pointer to the start of the next dictionay word 
1c48 7e				ld a,(hl)   ; get string length 
1c49 47				ld b,a 
1c4a			.execpnwordinc:  
1c4a 23				inc hl 
1c4b 10 fd			djnz .execpnwordinc 
1c4d 22 41 f8			ld (cli_execword), hl      ; save start of this words code 
1c50			 
1c50				; now check the word token against the string being parsed 
1c50			 
1c50 2a 43 f8			ld hl,(cli_token) 
1c53 23				inc hl     ; skip string length (use zero term instead to end) 
1c54 22 43 f8			ld (cli_token), hl 
1c57			 
1c57			if DEBUG_FORTH_PARSE_KEY 
1c57						DMARK "KY2" 
1c57			endif 
1c57			if DEBUG_FORTH_PARSE_EXEC 
1c57				; see if disabled 
1c57			 
1c57				ld a, (os_view_disable) 
1c57				cp '*' 
1c57				jr z, .skip 
1c57			 
1c57				push hl 
1c57				push hl 
1c57				call clear_display 
1c57				ld de, .compword 
1c57				ld a, display_row_1 
1c57				call str_at_display 
1c57				pop de 
1c57				ld a, display_row_2 
1c57				call str_at_display 
1c57				ld hl,(cli_ptr) 
1c57				ld a,(hl) 
1c57			        ld hl, os_word_scratch 
1c57				ld (hl),a 
1c57				ld a,0 
1c57				inc hl 
1c57				ld (hl),a 	 
1c57				ld de, os_word_scratch 
1c57				ld a, display_row_2+10 
1c57				call str_at_display 
1c57				call update_display 
1c57				ld a, 100 
1c57				call aDelayInMS 
1c57				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1c57				call delay250ms 
1c57				endif 
1c57				pop hl 
1c57			.skip:  
1c57			endif	 
1c57			.execpnchar:    ; compare char between token and string to parse 
1c57			 
1c57			if DEBUG_FORTH_PARSE_KEY 
1c57						DMARK "Ky3" 
1c57			endif 
1c57			if DEBUG_FORTH_PARSE_EXEC 
1c57				; see if disabled 
1c57			 
1c57				ld a, (os_view_disable) 
1c57				cp '*' 
1c57				jr z, .skip2 
1c57			 
1c57			;	call clear_display 
1c57			ld hl,(cli_token) 
1c57			ld a,(hl) 
1c57			ld (os_word_scratch),a 
1c57				ld hl,(cli_ptr) 
1c57			ld a,(hl) 
1c57				ld (os_word_scratch+1),a 
1c57				ld a,0 
1c57				ld (os_word_scratch+2),a 
1c57				ld de,os_word_scratch 
1c57				ld a,display_row_4 
1c57				call str_at_display 
1c57				call update_display 
1c57			.skip2:  
1c57			endif 
1c57 2a 43 f8			ld hl,(cli_token) 
1c5a 7e				ld a, (hl)	 ; char in word token 
1c5b 23				inc hl 		; move to next char 
1c5c 22 43 f8			ld (cli_token), hl ; and save it 
1c5f 47				ld b,a 
1c60			 
1c60 2a 3d f8			ld hl,(cli_ptr) ;	get the char from the string to parse 
1c63 7e				ld a,(hl) 
1c64 23				inc hl 
1c65 22 3d f8			ld (cli_ptr), hl		; move to next char 
1c68 cd 67 10			call toUpper 		; make sure the input string matches case 
1c6b			 
1c6b			if DEBUG_FORTH_PARSE 
1c6b			endif 
1c6b			 
1c6b				; input stream end of token is a space so get rid of it 
1c6b			 
1c6b			;	cp ' ' 
1c6b			;	jr nz, .pnskipspace 
1c6b			; 
1c6b			;	ld a, 0		; make same term as word token term 
1c6b			; 
1c6b			;.pnskipspace: 
1c6b			 
1c6b			if DEBUG_FORTH_PARSE_KEY 
1c6b						DMARK "KY7" 
1c6b			endif 
1c6b b8				cp b 
1c6c c2 82 1c			jp nz, .execpnskipword	 ; no match so move to next word 
1c6f				 
1c6f			;    if same 
1c6f			;       scan for string terms 0 for token and 32 for input 
1c6f			 
1c6f				 
1c6f			if DEBUG_FORTH_PARSE_KEY 
1c6f						DMARK "KY8" 
1c6f			endif 
1c6f			 
1c6f 80				add b			 
1c70 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
1c72							; TODO need to make sure last word in zero term string is accounted for 
1c72 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
1c74			 
1c74			 
1c74				; at end of both strings so both are exact match 
1c74			 
1c74			;       skip ptr for next word 
1c74			 
1c74 2a 3d f8			ld hl,(cli_ptr) 	; at input string term 
1c77 23				inc hl			 ; at next char 
1c78 22 3d f8			ld (cli_ptr), hl     ; save for next round of the parser 
1c7b 22 3b f8			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
1c7e				 
1c7e				 
1c7e			if DEBUG_FORTH_PARSE_KEY 
1c7e						DMARK "KY3" 
1c7e			endif 
1c7e			 
1c7e			 
1c7e			 
1c7e			;       exec code block 
1c7e			if DEBUG_FORTH_JP 
1c7e				call clear_display 
1c7e				call update_display 
1c7e				call delay1s 
1c7e				ld hl, (cli_execword)     ; save for next check if no match on this word 
1c7e				ld a,h 
1c7e				ld hl, os_word_scratch 
1c7e				call hexout 
1c7e				ld hl, (cli_execword)     ; save for next check if no match on this word 
1c7e				ld a,l 
1c7e				ld hl, os_word_scratch+2 
1c7e				call hexout 
1c7e				ld hl, os_word_scratch+4 
1c7e				ld a,0 
1c7e				ld (hl),a 
1c7e				ld de,os_word_scratch 
1c7e				call str_at_display 
1c7e					ld a, display_row_2 
1c7e					call str_at_display 
1c7e				ld de, (cli_origtoken) 
1c7e				ld a, display_row_1+10 
1c7e					call str_at_display 
1c7e			 
1c7e				ld a,display_row_1 
1c7e				ld de, .foundword 
1c7e				ld a, display_row_3 
1c7e				call str_at_display 
1c7e				call update_display 
1c7e				call delay1s 
1c7e				call delay1s 
1c7e				call delay1s 
1c7e			endif 
1c7e			 
1c7e			if DEBUG_FORTH_PARSE_KEY 
1c7e						DMARK "KYj" 
1c7e			endif 
1c7e				; TODO save the word pointer in this exec 
1c7e			 
1c7e 2a 41 f8			ld hl,(cli_execword) 
1c81 e9				jp (hl) 
1c82			 
1c82			 
1c82			;    if not same 
1c82			;	scan for zero term 
1c82			;	get ptr for next word 
1c82			;	goto word comp 
1c82			 
1c82			.execpnskipword:	; get pointer to next word 
1c82 2a 3f f8			ld hl,(cli_nextword) 
1c85			 
1c85 7e				ld a,(hl) 
1c86 fe 00			cp WORD_SYS_END 
1c88			;	cp 0 
1c88 28 09			jr z, .execendofdict			 ; at end of words 
1c8a			 
1c8a			if DEBUG_FORTH_PARSE_KEY 
1c8a						DMARK "KY4" 
1c8a			endif 
1c8a			if DEBUG_FORTH_PARSE_EXEC 
1c8a			 
1c8a				; see if disabled 
1c8a			 
1c8a				ld a, (os_view_disable) 
1c8a				cp '*' 
1c8a				jr z, .noskip 
1c8a			 
1c8a			 
1c8a				ld de, .nowordfound 
1c8a				ld a, display_row_3 
1c8a				call str_at_display 
1c8a				call update_display 
1c8a				ld a, 100 
1c8a				call aDelayInMS 
1c8a				 
1c8a				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1c8a					call delay250ms 
1c8a				endif 
1c8a			.noskip:  
1c8a			 
1c8a			endif	 
1c8a			 
1c8a 2a 3b f8			ld hl,(cli_origptr) 
1c8d 22 3d f8			ld (cli_ptr),hl 
1c90			 
1c90			if DEBUG_FORTH_PARSE_KEY 
1c90						DMARK "KY5" 
1c90			endif 
1c90 c3 36 1c			jp .execpnword			; else go to next word 
1c93			 
1c93			.execendofdict:  
1c93			 
1c93			if DEBUG_FORTH_PARSE_KEY 
1c93						DMARK "KYe" 
1c93			endif 
1c93			if DEBUG_FORTH_PARSE_EXEC 
1c93				; see if disabled 
1c93			 
1c93				ld a, (os_view_disable) 
1c93				cp '*' 
1c93				jr z, .ispskip 
1c93			 
1c93				call clear_display 
1c93				call update_display 
1c93				call delay1s 
1c93				ld de, (cli_origptr) 
1c93				ld a, display_row_1 
1c93				call str_at_display 
1c93				 
1c93				ld de, .enddict 
1c93				ld a, display_row_3 
1c93				call str_at_display 
1c93				call update_display 
1c93				ld a, 100 
1c93				call aDelayInMS 
1c93				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1c93				call delay1s 
1c93				call delay1s 
1c93				call delay1s 
1c93				endif 
1c93			.ispskip:  
1c93				 
1c93			endif	 
1c93			 
1c93			 
1c93			 
1c93				; if the word is not a keyword then must be a literal so push it to stack 
1c93			 
1c93			; push token to stack to end of word 
1c93			 
1c93				STACKFRAME ON $1efe $2f9f 
1c93				if DEBUG_STACK_IMB 
1c93					if ON 
1c93						exx 
1c93						ld de, $1efe 
1c93						ld a, d 
1c93						ld hl, curframe 
1c93						call hexout 
1c93						ld a, e 
1c93						ld hl, curframe+2 
1c93						call hexout 
1c93						ld hl, $1efe 
1c93						push hl 
1c93						ld hl, $2f9f 
1c93						push hl 
1c93						exx 
1c93					endif 
1c93				endif 
1c93			endm 
# End of macro STACKFRAME
1c93			 
1c93 2a 33 f1		ld hl,(os_tok_ptr) 
1c96 cd e2 19		call forth_apush 
1c99			 
1c99				STACKFRAMECHK ON $1efe $2f9f 
1c99				if DEBUG_STACK_IMB 
1c99					if ON 
1c99						exx 
1c99						ld hl, $2f9f 
1c99						pop de   ; $2f9f 
1c99						call cmp16 
1c99						jr nz, .spnosame 
1c99						ld hl, $1efe 
1c99						pop de   ; $1efe 
1c99						call cmp16 
1c99						jr z, .spfrsame 
1c99						.spnosame: call showsperror 
1c99						.spfrsame: nop 
1c99						exx 
1c99					endif 
1c99				endif 
1c99			endm 
# End of macro STACKFRAMECHK
1c99			 
1c99			execnext: 
1c99			 
1c99			if DEBUG_FORTH_PARSE_KEY 
1c99						DMARK "KY>" 
1c99			endif 
1c99			; move past token to next word 
1c99			 
1c99 2a 33 f1		ld hl, (os_tok_ptr) 
1c9c 3e 00		ld a, 0 
1c9e 01 ff 00		ld bc, 255     ; input buffer size 
1ca1 ed b1		cpir 
1ca3			 
1ca3			if DEBUG_FORTH_PARSE_KEY 
1ca3						DMARK "KY!" 
1ca3				CALLMONITOR 
1ca3			endif	 
1ca3			; TODO this might place hl on the null, so will need to forward on??? 
1ca3			;inc hl   ; see if this gets onto the next item 
1ca3			 
1ca3			 
1ca3			; TODO pass a pointer to the buffer to push 
1ca3			; TODO call function to push 
1ca3			 
1ca3			; look for end of input 
1ca3			 
1ca3			;inc hl 
1ca3			;ld a,(hl) 
1ca3			;cp FORTH_END_BUFFER 
1ca3			;ret z 
1ca3			 
1ca3			 
1ca3 c3 1c 1c		jp exec1 
1ca6			 
1ca6			 
1ca6			 
1ca6			 
1ca6			 
1ca6			 
1ca6			 
1ca6			 
1ca6			 
1ca6			findnexttok: 
1ca6			 
1ca6				; hl is pointer to move 
1ca6				; de is the token to locate 
1ca6			 
1ca6					if DEBUG_FORTH 
1ca6						DMARK "NTK" 
1ca6						CALLMONITOR 
1ca6					endif 
1ca6 d5				push de 
1ca7			 
1ca7			.fnt1:	 
1ca7				; find first char of token to locate 
1ca7			 
1ca7 1a				ld a, (de) 
1ca8 4f				ld c,a 
1ca9 7e				ld a,(hl) 
1caa cd 67 10			call toUpper 
1cad					if DEBUG_FORTH 
1cad						DMARK "NT1" 
1cad						CALLMONITOR 
1cad					endif 
1cad b9				cp c 
1cae			 
1cae 28 03			jr z, .fnt2cmpmorefirst	 
1cb0			 
1cb0				; first char not found move to next char 
1cb0			 
1cb0 23				inc hl 
1cb1 18 f4			jr .fnt1 
1cb3			 
1cb3			.fnt2cmpmorefirst:	 
1cb3				; first char of token found.  
1cb3			 
1cb3 e5				push hl     ; save start of token just in case it is the right one 
1cb4 d9				exx 
1cb5 e1				pop hl        ; save it to hl' 
1cb6 d9				exx 
1cb7			 
1cb7			 
1cb7			.fnt2cmpmore:	 
1cb7				; compare the rest 
1cb7				 
1cb7 23				inc hl 
1cb8 13				inc de 
1cb9				 
1cb9 1a				ld a, (de) 
1cba 4f				ld c,a 
1cbb 7e				ld a,(hl) 
1cbc cd 67 10			call toUpper 
1cbf			 
1cbf					if DEBUG_FORTH 
1cbf						DMARK "NT2" 
1cbf						CALLMONITOR 
1cbf					endif 
1cbf				; c has the token to find char 
1cbf				; a has the mem to scan char 
1cbf			 
1cbf b9				cp c 
1cc0 28 04			jr z,.fntmatch1 
1cc2			 
1cc2				; they are not the same 
1cc2			 
1cc2					if DEBUG_FORTH 
1cc2						DMARK "NT3" 
1cc2						CALLMONITOR 
1cc2					endif 
1cc2 d1				pop de	; reset de token to look for 
1cc3 d5				push de 
1cc4 18 e1			jr .fnt1 
1cc6				 
1cc6			.fntmatch1: 
1cc6			 
1cc6				; is the same char a null which means we might have a full hit? 
1cc6					if DEBUG_FORTH 
1cc6						DMARK "NT4" 
1cc6						CALLMONITOR 
1cc6					endif 
1cc6			 
1cc6 fe 00			cp 0 
1cc8 28 0b			jr z, .fntmatchyes 
1cca			 
1cca				; are we at the end of the token to find? 
1cca			 
1cca					if DEBUG_FORTH 
1cca						DMARK "NT5" 
1cca						CALLMONITOR 
1cca					endif 
1cca 3e 00			ld a, 0 
1ccc b9				cp c 
1ccd			 
1ccd c2 b7 1c			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
1cd0			 
1cd0					if DEBUG_FORTH 
1cd0						DMARK "NT6" 
1cd0						CALLMONITOR 
1cd0					endif 
1cd0				; token to find is exhusted but no match to stream 
1cd0			 
1cd0				; restore tok pointer and continue on 
1cd0 d1				pop de 
1cd1 d5				push de 
1cd2 c3 a7 1c			jp .fnt1 
1cd5			 
1cd5			 
1cd5			.fntmatchyes: 
1cd5			 
1cd5				; hl now contains the end of the found token 
1cd5			 
1cd5				; get rid of saved token pointer to find 
1cd5			 
1cd5 d1				pop de 
1cd6			 
1cd6					if DEBUG_FORTH 
1cd6						DMARK "NT9" 
1cd6						CALLMONITOR 
1cd6					endif 
1cd6			 
1cd6				; hl will be on the null term so forward on 
1cd6			 
1cd6				; get back the saved start of the token 
1cd6			 
1cd6 d9				exx 
1cd7 e5				push hl     ; save start of token just in case it is the right one 
1cd8 d9				exx 
1cd9 e1				pop hl        ; save it to hl 
1cda			 
1cda c9				ret 
1cdb			 
1cdb			 
1cdb			; LIST needs to find a specific token   
1cdb			; FORGET needs to find a spefici token 
1cdb			 
1cdb			; SAVE needs to find all tokens by flag 
1cdb			; WORDS just needs to scan through all  by flag 
1cdb			; UWORDS needs to scan through all by flag 
1cdb			 
1cdb			 
1cdb			; given hl as pointer to start of dict look up string 
1cdb			; return hl as pointer to start of word block 
1cdb			; or 0 if not found 
1cdb			 
1cdb			forth_find_tok: 
1cdb c9				ret 
1cdc			 
1cdc			; given hl as pointer to dict structure 
1cdc			; move to the next dict block structure 
1cdc			 
1cdc			forth_tok_next: 
1cdc				; hl now points to the address of the next word pointer  
1cdc				; TODO skip compiled symbol for now 
1cdc			;	push de 
1cdc 23				inc hl 
1cdd 5e				ld e, (hl) 
1cde 23				inc hl 
1cdf 56				ld d, (hl) 
1ce0 23				inc hl 
1ce1			 
1ce1 eb				ex de,hl 
1ce2			if DEBUG_FORTH_PARSE_NEXTWORD 
1ce2				push bc 
1ce2				ld bc, (cli_nextword) 
1ce2						DMARK "NXW" 
1ce2				CALLMONITOR 
1ce2				pop bc 
1ce2			endif 
1ce2			;	pop de	 
1ce2 c9				ret 
1ce3			 
1ce3			 
1ce3			 
1ce3			; eof 
# End of file forth_parserv5.asm
1ce3				include "forth_wordsv4.asm" 
1ce3			 
1ce3			; the core word dictionary v4 
1ce3			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
1ce3			 
1ce3			; this is a linked list for each of the system words used 
1ce3			; user defined words will follow the same format but will be in ram 
1ce3			 
1ce3			 
1ce3			; 
1ce3			; 
1ce3			; define linked list: 
1ce3			; 
1ce3			; 1. compiled byte op code 
1ce3			; 2. len of text word 
1ce3			; 3. text word 
1ce3			; 4. ptr to next dictionary word 
1ce3			; 5. asm, calls etc for the word 
1ce3			; 
1ce3			;  if 1 == 0 then last word in dict  
1ce3			;   
1ce3			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
1ce3			;  
1ce3			;  
1ce3			; create basic standard set of words 
1ce3			; 
1ce3			;  
1ce3			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
1ce3			; 2DUP 2DROP 2SWAP  
1ce3			; @ C@ - get byte  
1ce3			; ! C! - store byte 
1ce3			; 0< true if less than zero 
1ce3			; 0= true if zero 
1ce3			; < >  
1ce3			; = true if same 
1ce3			; variables 
1ce3			 
1ce3			 
1ce3			; Hardware specific words I may need 
1ce3			; 
1ce3			; IN OUT  
1ce3			; calls to key util functions 
1ce3			; calls to hardward abstraction stuff 
1ce3			; easy control of frame buffers and lcd i/o 
1ce3			; keyboard  
1ce3			 
1ce3			 
1ce3			;DICT: macro 
1ce3			; op_code, len, word, next 
1ce3			;    word: 
1ce3			;    db op_code 
1ce3			;    ds word zero term 
1ce3			;    dw next 
1ce3			;    endm 
1ce3			 
1ce3			 
1ce3			 
1ce3			 
1ce3			; op code 1 is a flag for user define words which are to be handled differently 
1ce3			 
1ce3			 
1ce3			; 
1ce3			; 
1ce3			;    TODO on entry to a word this should be the expected environment 
1ce3			;    hl - tos value if number then held, if string this is the ptr 
1ce3			;    de -  
1ce3			 
1ce3			 
1ce3			; opcode ranges 
1ce3			; 0 - end of word dict 
1ce3			; 255 - user define words 
1ce3			 
1ce3			sysdict: 
1ce3			include "forth_opcodes.asm" 
1ce3			; op codes for forth keywords 
1ce3			; free to use code 0  
1ce3				OPCODE_HEAP: equ  1 
1ce3				OPCODE_EXEC: equ 2 
1ce3				OPCODE_DUP: equ 3 
1ce3				OPCODE_SWAP: equ 4 
1ce3				OPCODE_COLN: equ 5 
1ce3				OPCODE_SCOLN: equ 6 
1ce3				OPCODE_DROP: equ 7 
1ce3				OPCODE_DUP2: equ 8 
1ce3				OPCODE_DROP2: equ 9 
1ce3				OPCODE_SWAP2: equ 10 
1ce3				OPCODE_AT: equ 11 
1ce3				OPCODE_CAT: equ 12 
1ce3				OPCODE_BANG: equ 13 
1ce3				OPCODE_CBANG: equ 14 
1ce3				OPCODE_SCALL: equ 15 
1ce3				OPCODE_DEPTH: equ 16 
1ce3				OPCODE_OVER: equ 17 
1ce3				OPCODE_PAUSE: equ 18 
1ce3				OPCODE_PAUSES: equ 19 
1ce3				OPCODE_ROT: equ 20 
1ce3			;free to reuse	OPCODE_WORDS: equ 21 
1ce3			        OPCODE_NOT: equ 21 
1ce3				OPCODE_UWORDS: equ 22 
1ce3				OPCODE_BP: equ 23 
1ce3				OPCODE_MONITOR: equ 24  
1ce3				OPCODE_MALLOC: equ 25 
1ce3				OPCODE_FREE: equ 26 
1ce3				OPCODE_LIST: equ 27 
1ce3				OPCODE_FORGET: equ 28 
1ce3				OPCODE_NOP: equ 29 
1ce3				OPCODE_COMO: equ 30 
1ce3				OPCODE_COMC: equ 31 
1ce3			;free to reuse	OPCODE_ENDCORE: equ 32 
1ce3				OPCODE_AFTERSOUND: equ 33 
1ce3				OPCODE_GP2: equ 34 
1ce3				OPCODE_GP3: equ 35 
1ce3				OPCODE_GP4: equ 36 
1ce3				OPCODE_SIN: equ 37 
1ce3				OPCODE_SOUT: equ 38 
1ce3				OPCODE_SPIO: equ 39 
1ce3				OPCODE_SPICEH: equ 40 
1ce3				OPCODE_SPIOb: equ 41 
1ce3				OPCODE_SPII: equ 42 
1ce3				OPCODE_SESEL: equ 43 
1ce3				OPCODE_CARTDEV: equ 44 
1ce3			; free to reuse	OPCODE_ENDDEVICE: equ 45 
1ce3				OPCODE_FB: equ 46 
1ce3				OPCODE_EMIT: equ 47 
1ce3				OPCODE_DOTH: equ 48 
1ce3				OPCODE_DOTF: equ 49 
1ce3				OPCODE_DOT: equ 50 
1ce3				OPCODE_CLS: equ 51 
1ce3				OPCODE_DRAW: equ 52 
1ce3				OPCODE_DUMP: equ 53 
1ce3				OPCODE_CDUMP: equ 54 
1ce3				OPCODE_DAT: equ 55 
1ce3				OPCODE_HOME: equ 56 
1ce3				OPCODE_SPACE: equ 57 
1ce3				OPCODE_SPACES: equ 58 
1ce3				OPCODE_SCROLL: equ 59 
1ce3				OPCODE_ATQ: equ 60 
1ce3				OPCODE_AUTODSP: equ 61 
1ce3				OPCODE_MENU: equ 62 
1ce3			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
1ce3				OPCODE_THEN: equ 64 
1ce3				OPCODE_ELSE: equ 65 
1ce3				OPCODE_DO: equ 66 
1ce3				OPCODE_LOOP: equ 67 
1ce3				OPCODE_I: equ 68 
1ce3				OPCODE_DLOOP: equ 69  
1ce3				OPCODE_REPEAT: equ 70  
1ce3				OPCODE_UNTIL: equ 71 
1ce3				OPCODE_ENDFLOW: equ 72 
1ce3				OPCODE_WAITK: equ 73 
1ce3				OPCODE_ACCEPT: equ 74 
1ce3				OPCODE_EDIT: equ 75 
1ce3			;free to reuse	OPCODE_ENDKEY: equ 76 
1ce3				OPCODE_LZERO: equ 77 
1ce3				OPCODE_TZERO: equ 78 
1ce3				OPCODE_LESS: equ 79 
1ce3				OPCODE_GT: equ 80 
1ce3				OPCODE_EQUAL: equ 81  
1ce3			;free to reuse	OPCODE_ENDLOGIC: equ 82 
1ce3				OPCODE_NEG: equ 83 
1ce3				OPCODE_DIV: equ 84 
1ce3				OPCODE_MUL: equ 85 
1ce3				OPCODE_MIN: equ 86 
1ce3				OPCODE_MAX: equ 87 
1ce3				OPCODE_RND16: equ 88 
1ce3				OPCODE_RND8: equ 89 
1ce3				OPCODE_RND: equ 90 
1ce3			;free to reuse	OPCODE_ENDMATHS: equ 91  
1ce3				OPCODE_BYNAME: equ 92 
1ce3				OPCODE_DIR: equ 93 
1ce3				OPCODE_SAVE: equ 94 
1ce3				OPCODE_LOAD: equ 95 
1ce3				OPCODE_BSAVE: equ 96 
1ce3				OPCODE_BLOAD: equ 97 
1ce3				OPCODE_SEO: equ 98  
1ce3				OPCODE_SEI: equ 99 
1ce3				OPCODE_SFREE: equ 100 
1ce3				OPCODE_SIZE: equ 101 
1ce3				OPCODE_CREATE: equ 102 
1ce3				OPCODE_APPEND: equ 103 
1ce3				OPCODE_SDEL: equ 104 
1ce3				OPCODE_OPEN: equ 105 
1ce3				OPCODE_READ: equ 106 
1ce3				OPCODE_EOF: equ 106 
1ce3				OPCODE_FORMAT: equ 107 
1ce3				OPCODE_LABEL: equ 108 
1ce3				OPCODE_LABELS: equ 109 
1ce3			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
1ce3				OPCODE_UPPER: equ 111 
1ce3				OPCODE_LOWER: equ 112 
1ce3				OPCODE_SUBSTR: equ 113 
1ce3				OPCODE_LEFT: equ 114 
1ce3				OPCODE_RIGHT: equ 115 
1ce3				OPCODE_STR2NUM: equ 116 
1ce3				OPCODE_NUM2STR: equ 117 
1ce3				OPCODE_CONCAT: equ 118 
1ce3				OPCODE_FIND: equ 119 
1ce3				OPCODE_LEN: equ 120 
1ce3				OPCODE_CHAR: equ 121 
1ce3			; free to reuse	OPCODE_STRLEN: equ 122 
1ce3			; free to reuse	OPCODE_ENDSTR: equ 123 
1ce3				OPCODE_V0S: equ 124 
1ce3				OPCODE_V0Q: equ 125 
1ce3				OPCODE_V1S: equ 126 
1ce3				OPCODE_V1Q: equ 127 
1ce3				OPCODE_V2S: equ 128 
1ce3				OPCODE_V2Q: equ 129 
1ce3				OPCODE_V3S: equ 130 
1ce3				OPCODE_V3Q: equ 131 
1ce3			;free to reuse	OPCODE_END: equ 132 
1ce3				OPCODE_ZDUP: equ 133 
1ce3			 
1ce3			; eof 
# End of file forth_opcodes.asm
1ce3			 
1ce3			include "forth_words_core.asm" 
1ce3			 
1ce3			; | ## Core Words 
1ce3			 
1ce3			;if MALLOC_4 
1ce3			 
1ce3			.HEAP: 
1ce3				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
1ce3 15				db WORD_SYS_CORE+OPCODE_HEAP             
1ce4 22 1d			dw .EXEC            
1ce6 05				db 4 + 1 
1ce7 .. 00			db "HEAP",0              
1cec				endm 
# End of macro CWHEAD
1cec			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
1cec			; | | u1 - Current number of bytes in the heap 
1cec			; | | u2 - Remaining bytes left on the heap 
1cec			; | |  
1cec			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
1cec			 
1cec			 
1cec					if DEBUG_FORTH_WORDS_KEY 
1cec						DMARK "HEP" 
1cec f5				push af  
1ced 3a 01 1d			ld a, (.dmark)  
1cf0 32 77 fb			ld (debug_mark),a  
1cf3 3a 02 1d			ld a, (.dmark+1)  
1cf6 32 78 fb			ld (debug_mark+1),a  
1cf9 3a 03 1d			ld a, (.dmark+2)  
1cfc 32 79 fb			ld (debug_mark+2),a  
1cff 18 03			jr .pastdmark  
1d01 ..			.dmark: db "HEP"  
1d04 f1			.pastdmark: pop af  
1d05			endm  
# End of macro DMARK
1d05						CALLMONITOR 
1d05 cd 00 14			call break_point_state  
1d08				endm  
# End of macro CALLMONITOR
1d08					endif 
1d08 2a 0a 80				ld hl, (free_list )      
1d0b 11 0e 80				ld de, heap_start 
1d0e			 
1d0e ed 52				sbc hl, de  
1d10			 
1d10 cd 9a 19				call forth_push_numhl 
1d13			 
1d13			 
1d13 ed 5b 0a 80			ld de, (free_list )      
1d17 21 26 ee				ld hl, heap_end 
1d1a			 
1d1a ed 52				sbc hl, de 
1d1c			 
1d1c cd 9a 19				call forth_push_numhl 
1d1f					 
1d1f			 
1d1f					 
1d1f			 
1d1f			 
1d1f			 
1d1f					NEXTW 
1d1f c3 8b 1b			jp macro_next 
1d22				endm 
# End of macro NEXTW
1d22			;endif 
1d22			 
1d22			.EXEC: 
1d22				CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
1d22 16				db WORD_SYS_CORE+OPCODE_EXEC             
1d23 be 1d			dw .STKEXEC            
1d25 05				db 4 + 1 
1d26 .. 00			db "EXEC",0              
1d2b				endm 
# End of macro CWHEAD
1d2b			; | EXEC ( u -- )    Execs the string on TOS as a FORTH expression | CRASHES ON NEXTW 
1d2b			; | | u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
1d2b			; | | 
1d2b			; | |   
1d2b				STACKFRAME OFF $5efe $5f9f 
1d2b				if DEBUG_STACK_IMB 
1d2b					if OFF 
1d2b						exx 
1d2b						ld de, $5efe 
1d2b						ld a, d 
1d2b						ld hl, curframe 
1d2b						call hexout 
1d2b						ld a, e 
1d2b						ld hl, curframe+2 
1d2b						call hexout 
1d2b						ld hl, $5efe 
1d2b						push hl 
1d2b						ld hl, $5f9f 
1d2b						push hl 
1d2b						exx 
1d2b					endif 
1d2b				endif 
1d2b			endm 
# End of macro STACKFRAME
1d2b			 
1d2b					if DEBUG_FORTH_WORDS_KEY 
1d2b						DMARK "EXE" 
1d2b f5				push af  
1d2c 3a 40 1d			ld a, (.dmark)  
1d2f 32 77 fb			ld (debug_mark),a  
1d32 3a 41 1d			ld a, (.dmark+1)  
1d35 32 78 fb			ld (debug_mark+1),a  
1d38 3a 42 1d			ld a, (.dmark+2)  
1d3b 32 79 fb			ld (debug_mark+2),a  
1d3e 18 03			jr .pastdmark  
1d40 ..			.dmark: db "EXE"  
1d43 f1			.pastdmark: pop af  
1d44			endm  
# End of macro DMARK
1d44						CALLMONITOR 
1d44 cd 00 14			call break_point_state  
1d47				endm  
# End of macro CALLMONITOR
1d47					endif 
1d47			 
1d47				FORTH_DSP_VALUEHL 
1d47 cd 35 1a			call macro_dsp_valuehl 
1d4a				endm 
# End of macro FORTH_DSP_VALUEHL
1d4a			 
1d4a				FORTH_DSP_POP 
1d4a cd d1 1a			call macro_forth_dsp_pop 
1d4d				endm 
# End of macro FORTH_DSP_POP
1d4d			 
1d4d					if DEBUG_FORTH_WORDS 
1d4d						DMARK "EX1" 
1d4d f5				push af  
1d4e 3a 62 1d			ld a, (.dmark)  
1d51 32 77 fb			ld (debug_mark),a  
1d54 3a 63 1d			ld a, (.dmark+1)  
1d57 32 78 fb			ld (debug_mark+1),a  
1d5a 3a 64 1d			ld a, (.dmark+2)  
1d5d 32 79 fb			ld (debug_mark+2),a  
1d60 18 03			jr .pastdmark  
1d62 ..			.dmark: db "EX1"  
1d65 f1			.pastdmark: pop af  
1d66			endm  
# End of macro DMARK
1d66						CALLMONITOR 
1d66 cd 00 14			call break_point_state  
1d69				endm  
# End of macro CALLMONITOR
1d69					endif 
1d69			;	ld e,(hl) 
1d69			;	inc hl 
1d69			;	ld d,(hl) 
1d69			;	ex de,hl 
1d69			 
1d69			;		if DEBUG_FORTH_WORDS 
1d69			;			DMARK "EX2" 
1d69			;			CALLMONITOR 
1d69			;		endif 
1d69 e5				push hl 
1d6a			 
1d6a				;ld a, 0 
1d6a				;ld a, FORTH_END_BUFFER 
1d6a cd 70 10			call strlenz 
1d6d 23				inc hl   ; include zero term to copy 
1d6e 23				inc hl   ; include term 
1d6f 23				inc hl   ; include term 
1d70 06 00			ld b,0 
1d72 4d				ld c,l 
1d73 e1				pop hl 
1d74 11 31 ef			ld de, execscratch 
1d77					if DEBUG_FORTH_WORDS 
1d77						DMARK "EX3" 
1d77 f5				push af  
1d78 3a 8c 1d			ld a, (.dmark)  
1d7b 32 77 fb			ld (debug_mark),a  
1d7e 3a 8d 1d			ld a, (.dmark+1)  
1d81 32 78 fb			ld (debug_mark+1),a  
1d84 3a 8e 1d			ld a, (.dmark+2)  
1d87 32 79 fb			ld (debug_mark+2),a  
1d8a 18 03			jr .pastdmark  
1d8c ..			.dmark: db "EX3"  
1d8f f1			.pastdmark: pop af  
1d90			endm  
# End of macro DMARK
1d90						CALLMONITOR 
1d90 cd 00 14			call break_point_state  
1d93				endm  
# End of macro CALLMONITOR
1d93					endif 
1d93 ed b0			ldir 
1d95			 
1d95			 
1d95 21 31 ef			ld hl, execscratch 
1d98			 
1d98					if DEBUG_FORTH_WORDS 
1d98						DMARK "EXe" 
1d98 f5				push af  
1d99 3a ad 1d			ld a, (.dmark)  
1d9c 32 77 fb			ld (debug_mark),a  
1d9f 3a ae 1d			ld a, (.dmark+1)  
1da2 32 78 fb			ld (debug_mark+1),a  
1da5 3a af 1d			ld a, (.dmark+2)  
1da8 32 79 fb			ld (debug_mark+2),a  
1dab 18 03			jr .pastdmark  
1dad ..			.dmark: db "EXe"  
1db0 f1			.pastdmark: pop af  
1db1			endm  
# End of macro DMARK
1db1						CALLMONITOR 
1db1 cd 00 14			call break_point_state  
1db4				endm  
# End of macro CALLMONITOR
1db4					endif 
1db4			 
1db4 cd d9 1b			call forthparse 
1db7 cd 19 1c			call forthexec 
1dba			;	call forthexec_cleanup 
1dba			;	call forthparse 
1dba			;	call forthexec 
1dba			 
1dba				STACKFRAMECHK OFF $5efe $5f9f 
1dba				if DEBUG_STACK_IMB 
1dba					if OFF 
1dba						exx 
1dba						ld hl, $5f9f 
1dba						pop de   ; $5f9f 
1dba						call cmp16 
1dba						jr nz, .spnosame 
1dba						ld hl, $5efe 
1dba						pop de   ; $5efe 
1dba						call cmp16 
1dba						jr z, .spfrsame 
1dba						.spnosame: call showsperror 
1dba						.spfrsame: nop 
1dba						exx 
1dba					endif 
1dba				endif 
1dba			endm 
# End of macro STACKFRAMECHK
1dba			 
1dba				; an immediate word so no need to process any more words 
1dba c9				ret 
1dbb				NEXTW 
1dbb c3 8b 1b			jp macro_next 
1dbe				endm 
# End of macro NEXTW
1dbe			 
1dbe			; dead code - old version  
1dbe			;	FORTH_RSP_NEXT 
1dbe			 
1dbe			;  
1dbe			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1dbe			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1dbe			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1dbe			;	push hl 
1dbe			;	push de 
1dbe			;	push bc 
1dbe			; 
1dbe			; 
1dbe			;		if DEBUG_FORTH_WORDS_KEY 
1dbe			;			DMARK "EXR" 
1dbe			;			CALLMONITOR 
1dbe			;		endif 
1dbe			; 
1dbe			; 
1dbe			; 
1dbe			;	;v5 FORTH_DSP_VALUE 
1dbe			;	FORTH_DSP_VALUEHL 
1dbe			; 
1dbe			;	; TODO do string type checks 
1dbe			; 
1dbe			;;v5	inc hl   ; skip type 
1dbe			; 
1dbe			;	push hl  ; source code  
1dbe			;		if DEBUG_FORTH_WORDS 
1dbe			;			DMARK "EX1" 
1dbe			;			CALLMONITOR 
1dbe			;		endif 
1dbe			;	ld a, 0 
1dbe			;	call strlent 
1dbe			; 
1dbe			;	inc hl 
1dbe			;	inc hl 
1dbe			;	inc hl 
1dbe			;	inc hl 
1dbe			; 
1dbe			;	push hl    ; size 
1dbe			; 
1dbe			;		if DEBUG_FORTH_WORDS 
1dbe			;			DMARK "EX2" 
1dbe			;			CALLMONITOR 
1dbe			;		endif 
1dbe			;	call malloc 
1dbe			; 
1dbe			;	ex de, hl    ; de now contains malloc area 
1dbe			;	pop bc   	; get byte count 
1dbe			;	pop hl      ; get string to copy 
1dbe			; 
1dbe			;	push de     ; save malloc for free later 
1dbe			; 
1dbe			;		if DEBUG_FORTH_WORDS 
1dbe			;			DMARK "EX3" 
1dbe			;			CALLMONITOR 
1dbe			;		endif 
1dbe			;	ldir       ; duplicate string 
1dbe			; 
1dbe			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
1dbe			;	 
1dbe			;	; TODO fix the parse would be better than this...  
1dbe			;	ex de, hl 
1dbe			;	dec hl 
1dbe			;	ld a, 0 
1dbe			;	ld (hl), a 
1dbe			;	dec hl 
1dbe			;	ld a, ' ' 
1dbe			;	ld (hl), a 
1dbe			;	dec hl 
1dbe			;	ld (hl), a 
1dbe			; 
1dbe			;	dec hl 
1dbe			;	ld (hl), a 
1dbe			; 
1dbe			; 
1dbe			;	FORTH_DSP_POP  
1dbe			; 
1dbe			;	pop hl     
1dbe			;	push hl    ; save malloc area 
1dbe			; 
1dbe			;		if DEBUG_FORTH_WORDS 
1dbe			;			DMARK "EX4" 
1dbe			;			CALLMONITOR 
1dbe			;		endif 
1dbe			; 
1dbe			;	call forthparse 
1dbe			;	call forthexec 
1dbe			;	 
1dbe			;	pop hl 
1dbe			;	if DEBUG_FORTH_WORDS 
1dbe			;		DMARK "EX5" 
1dbe			;		CALLMONITOR 
1dbe			;	endif 
1dbe			; 
1dbe			;	if FORTH_ENABLE_FREE 
1dbe			;	call free 
1dbe			;	endif 
1dbe			; 
1dbe			;	if DEBUG_FORTH_WORDS 
1dbe			;		DMARK "EX6" 
1dbe			;		CALLMONITOR 
1dbe			;	endif 
1dbe			; 
1dbe			;	pop bc 
1dbe			;	pop de 
1dbe			;	pop hl 
1dbe			;;	FORTH_RSP_POP	  
1dbe			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
1dbe			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
1dbe			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
1dbe			; 
1dbe			;	if DEBUG_FORTH_WORDS 
1dbe			;		DMARK "EX7" 
1dbe			;		CALLMONITOR 
1dbe			;	endif 
1dbe			;	NEXTW 
1dbe			 
1dbe			.STKEXEC: 
1dbe				CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
1dbe 3f				db WORD_SYS_CORE+43             
1dbf 06 1f			dw .ZDUP            
1dc1 08				db 7 + 1 
1dc2 .. 00			db "STKEXEC",0              
1dca				endm 
# End of macro CWHEAD
1dca			; | STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code | TO TEST 
1dca			 
1dca			 
1dca					if DEBUG_FORTH_WORDS_KEY 
1dca						DMARK "STX" 
1dca f5				push af  
1dcb 3a df 1d			ld a, (.dmark)  
1dce 32 77 fb			ld (debug_mark),a  
1dd1 3a e0 1d			ld a, (.dmark+1)  
1dd4 32 78 fb			ld (debug_mark+1),a  
1dd7 3a e1 1d			ld a, (.dmark+2)  
1dda 32 79 fb			ld (debug_mark+2),a  
1ddd 18 03			jr .pastdmark  
1ddf ..			.dmark: db "STX"  
1de2 f1			.pastdmark: pop af  
1de3			endm  
# End of macro DMARK
1de3						CALLMONITOR 
1de3 cd 00 14			call break_point_state  
1de6				endm  
# End of macro CALLMONITOR
1de6					endif 
1de6			 
1de6				FORTH_DSP_VALUEHL 
1de6 cd 35 1a			call macro_dsp_valuehl 
1de9				endm 
# End of macro FORTH_DSP_VALUEHL
1de9			 
1de9 22 60 f8			ld (store_tmp1), hl    ; count 
1dec			 
1dec				FORTH_DSP_POP 
1dec cd d1 1a			call macro_forth_dsp_pop 
1def				endm 
# End of macro FORTH_DSP_POP
1def			.stkexec1: 
1def 2a 60 f8			ld hl, (store_tmp1)   ; count 
1df2 3e 00			ld a, 0 
1df4 bd				cp l 
1df5 c8				ret z 
1df6			 
1df6 2b				dec hl 
1df7 22 60 f8			ld (store_tmp1), hl    ; count 
1dfa				 
1dfa				FORTH_DSP_VALUEHL 
1dfa cd 35 1a			call macro_dsp_valuehl 
1dfd				endm 
# End of macro FORTH_DSP_VALUEHL
1dfd e5				push hl 
1dfe				 
1dfe					if DEBUG_FORTH_WORDS 
1dfe						DMARK "EXp" 
1dfe f5				push af  
1dff 3a 13 1e			ld a, (.dmark)  
1e02 32 77 fb			ld (debug_mark),a  
1e05 3a 14 1e			ld a, (.dmark+1)  
1e08 32 78 fb			ld (debug_mark+1),a  
1e0b 3a 15 1e			ld a, (.dmark+2)  
1e0e 32 79 fb			ld (debug_mark+2),a  
1e11 18 03			jr .pastdmark  
1e13 ..			.dmark: db "EXp"  
1e16 f1			.pastdmark: pop af  
1e17			endm  
# End of macro DMARK
1e17						CALLMONITOR 
1e17 cd 00 14			call break_point_state  
1e1a				endm  
# End of macro CALLMONITOR
1e1a					endif 
1e1a				FORTH_DSP_POP 
1e1a cd d1 1a			call macro_forth_dsp_pop 
1e1d				endm 
# End of macro FORTH_DSP_POP
1e1d			 
1e1d cd 70 10			call strlenz 
1e20 23				inc hl   ; include zero term to copy 
1e21 23				inc hl   ; include zero term to copy 
1e22 23				inc hl   ; include zero term to copy 
1e23 06 00			ld b,0 
1e25 4d				ld c,l 
1e26 e1				pop hl 
1e27 11 31 ef			ld de, execscratch 
1e2a					if DEBUG_FORTH_WORDS 
1e2a						DMARK "EX3" 
1e2a f5				push af  
1e2b 3a 3f 1e			ld a, (.dmark)  
1e2e 32 77 fb			ld (debug_mark),a  
1e31 3a 40 1e			ld a, (.dmark+1)  
1e34 32 78 fb			ld (debug_mark+1),a  
1e37 3a 41 1e			ld a, (.dmark+2)  
1e3a 32 79 fb			ld (debug_mark+2),a  
1e3d 18 03			jr .pastdmark  
1e3f ..			.dmark: db "EX3"  
1e42 f1			.pastdmark: pop af  
1e43			endm  
# End of macro DMARK
1e43						CALLMONITOR 
1e43 cd 00 14			call break_point_state  
1e46				endm  
# End of macro CALLMONITOR
1e46					endif 
1e46 ed b0			ldir 
1e48			 
1e48			 
1e48 21 31 ef			ld hl, execscratch 
1e4b			 
1e4b					if DEBUG_FORTH_WORDS 
1e4b						DMARK "EXP" 
1e4b f5				push af  
1e4c 3a 60 1e			ld a, (.dmark)  
1e4f 32 77 fb			ld (debug_mark),a  
1e52 3a 61 1e			ld a, (.dmark+1)  
1e55 32 78 fb			ld (debug_mark+1),a  
1e58 3a 62 1e			ld a, (.dmark+2)  
1e5b 32 79 fb			ld (debug_mark+2),a  
1e5e 18 03			jr .pastdmark  
1e60 ..			.dmark: db "EXP"  
1e63 f1			.pastdmark: pop af  
1e64			endm  
# End of macro DMARK
1e64						CALLMONITOR 
1e64 cd 00 14			call break_point_state  
1e67				endm  
# End of macro CALLMONITOR
1e67					endif 
1e67			 
1e67 cd d9 1b			call forthparse 
1e6a 21 31 ef			ld hl, execscratch 
1e6d					if DEBUG_FORTH_WORDS 
1e6d						DMARK "EXx" 
1e6d f5				push af  
1e6e 3a 82 1e			ld a, (.dmark)  
1e71 32 77 fb			ld (debug_mark),a  
1e74 3a 83 1e			ld a, (.dmark+1)  
1e77 32 78 fb			ld (debug_mark+1),a  
1e7a 3a 84 1e			ld a, (.dmark+2)  
1e7d 32 79 fb			ld (debug_mark+2),a  
1e80 18 03			jr .pastdmark  
1e82 ..			.dmark: db "EXx"  
1e85 f1			.pastdmark: pop af  
1e86			endm  
# End of macro DMARK
1e86						CALLMONITOR 
1e86 cd 00 14			call break_point_state  
1e89				endm  
# End of macro CALLMONITOR
1e89					endif 
1e89 cd 19 1c			call forthexec 
1e8c			 
1e8c c3 ef 1d			jp .stkexec1 
1e8f			 
1e8f c9				ret 
1e90			 
1e90			 
1e90			.DUP: 
1e90				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
1e90 17				db WORD_SYS_CORE+OPCODE_DUP             
1e91 06 1f			dw .ZDUP            
1e93 04				db 3 + 1 
1e94 .. 00			db "DUP",0              
1e98				endm 
# End of macro CWHEAD
1e98			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
1e98			 
1e98					if DEBUG_FORTH_WORDS_KEY 
1e98						DMARK "DUP" 
1e98 f5				push af  
1e99 3a ad 1e			ld a, (.dmark)  
1e9c 32 77 fb			ld (debug_mark),a  
1e9f 3a ae 1e			ld a, (.dmark+1)  
1ea2 32 78 fb			ld (debug_mark+1),a  
1ea5 3a af 1e			ld a, (.dmark+2)  
1ea8 32 79 fb			ld (debug_mark+2),a  
1eab 18 03			jr .pastdmark  
1ead ..			.dmark: db "DUP"  
1eb0 f1			.pastdmark: pop af  
1eb1			endm  
# End of macro DMARK
1eb1						CALLMONITOR 
1eb1 cd 00 14			call break_point_state  
1eb4				endm  
# End of macro CALLMONITOR
1eb4					endif 
1eb4			 
1eb4					FORTH_DSP 
1eb4 cd 1a 1a			call macro_forth_dsp 
1eb7				endm 
# End of macro FORTH_DSP
1eb7			 
1eb7 7e					ld a, (HL) 
1eb8 fe 01				cp DS_TYPE_STR 
1eba 20 25				jr nz, .dupinum 
1ebc			 
1ebc					; push another string 
1ebc			 
1ebc					FORTH_DSP_VALUEHL     		 
1ebc cd 35 1a			call macro_dsp_valuehl 
1ebf				endm 
# End of macro FORTH_DSP_VALUEHL
1ebf			 
1ebf				if DEBUG_FORTH_WORDS 
1ebf					DMARK "DUs" 
1ebf f5				push af  
1ec0 3a d4 1e			ld a, (.dmark)  
1ec3 32 77 fb			ld (debug_mark),a  
1ec6 3a d5 1e			ld a, (.dmark+1)  
1ec9 32 78 fb			ld (debug_mark+1),a  
1ecc 3a d6 1e			ld a, (.dmark+2)  
1ecf 32 79 fb			ld (debug_mark+2),a  
1ed2 18 03			jr .pastdmark  
1ed4 ..			.dmark: db "DUs"  
1ed7 f1			.pastdmark: pop af  
1ed8			endm  
# End of macro DMARK
1ed8					CALLMONITOR 
1ed8 cd 00 14			call break_point_state  
1edb				endm  
# End of macro CALLMONITOR
1edb				endif 
1edb cd ac 19				call forth_push_str 
1ede			 
1ede					NEXTW 
1ede c3 8b 1b			jp macro_next 
1ee1				endm 
# End of macro NEXTW
1ee1			 
1ee1			 
1ee1			.dupinum: 
1ee1					 
1ee1			 
1ee1			 
1ee1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
1ee1 cd 35 1a			call macro_dsp_valuehl 
1ee4				endm 
# End of macro FORTH_DSP_VALUEHL
1ee4			 
1ee4				; TODO add floating point number detection 
1ee4			 
1ee4				if DEBUG_FORTH_WORDS 
1ee4					DMARK "DUi" 
1ee4 f5				push af  
1ee5 3a f9 1e			ld a, (.dmark)  
1ee8 32 77 fb			ld (debug_mark),a  
1eeb 3a fa 1e			ld a, (.dmark+1)  
1eee 32 78 fb			ld (debug_mark+1),a  
1ef1 3a fb 1e			ld a, (.dmark+2)  
1ef4 32 79 fb			ld (debug_mark+2),a  
1ef7 18 03			jr .pastdmark  
1ef9 ..			.dmark: db "DUi"  
1efc f1			.pastdmark: pop af  
1efd			endm  
# End of macro DMARK
1efd					CALLMONITOR 
1efd cd 00 14			call break_point_state  
1f00				endm  
# End of macro CALLMONITOR
1f00				endif 
1f00			 
1f00 cd 9a 19				call forth_push_numhl 
1f03					NEXTW 
1f03 c3 8b 1b			jp macro_next 
1f06				endm 
# End of macro NEXTW
1f06			.ZDUP: 
1f06				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
1f06 99				db WORD_SYS_CORE+OPCODE_ZDUP             
1f07 3e 1f			dw .SWAP            
1f09 05				db 4 + 1 
1f0a .. 00			db "?DUP",0              
1f0f				endm 
# End of macro CWHEAD
1f0f			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
1f0f			 
1f0f					if DEBUG_FORTH_WORDS_KEY 
1f0f						DMARK "qDU" 
1f0f f5				push af  
1f10 3a 24 1f			ld a, (.dmark)  
1f13 32 77 fb			ld (debug_mark),a  
1f16 3a 25 1f			ld a, (.dmark+1)  
1f19 32 78 fb			ld (debug_mark+1),a  
1f1c 3a 26 1f			ld a, (.dmark+2)  
1f1f 32 79 fb			ld (debug_mark+2),a  
1f22 18 03			jr .pastdmark  
1f24 ..			.dmark: db "qDU"  
1f27 f1			.pastdmark: pop af  
1f28			endm  
# End of macro DMARK
1f28						CALLMONITOR 
1f28 cd 00 14			call break_point_state  
1f2b				endm  
# End of macro CALLMONITOR
1f2b					endif 
1f2b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
1f2b cd 35 1a			call macro_dsp_valuehl 
1f2e				endm 
# End of macro FORTH_DSP_VALUEHL
1f2e			 
1f2e e5					push hl 
1f2f			 
1f2f					; is it a zero? 
1f2f			 
1f2f 3e 00				ld a, 0 
1f31 84					add h 
1f32 85					add l 
1f33			 
1f33 e1					pop hl 
1f34			 
1f34 fe 00				cp 0 
1f36 28 03				jr z, .dup2orig 
1f38			 
1f38			 
1f38 cd 9a 19				call forth_push_numhl 
1f3b			 
1f3b			 
1f3b				; TODO add floating point number detection 
1f3b			 
1f3b			.dup2orig: 
1f3b			 
1f3b					NEXTW 
1f3b c3 8b 1b			jp macro_next 
1f3e				endm 
# End of macro NEXTW
1f3e			.SWAP: 
1f3e				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
1f3e 18				db WORD_SYS_CORE+OPCODE_SWAP             
1f3f 7d 1f			dw .COLN            
1f41 05				db 4 + 1 
1f42 .. 00			db "SWAP",0              
1f47				endm 
# End of macro CWHEAD
1f47			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
1f47					if DEBUG_FORTH_WORDS_KEY 
1f47						DMARK "SWP" 
1f47 f5				push af  
1f48 3a 5c 1f			ld a, (.dmark)  
1f4b 32 77 fb			ld (debug_mark),a  
1f4e 3a 5d 1f			ld a, (.dmark+1)  
1f51 32 78 fb			ld (debug_mark+1),a  
1f54 3a 5e 1f			ld a, (.dmark+2)  
1f57 32 79 fb			ld (debug_mark+2),a  
1f5a 18 03			jr .pastdmark  
1f5c ..			.dmark: db "SWP"  
1f5f f1			.pastdmark: pop af  
1f60			endm  
# End of macro DMARK
1f60						CALLMONITOR 
1f60 cd 00 14			call break_point_state  
1f63				endm  
# End of macro CALLMONITOR
1f63					endif 
1f63			 
1f63					FORTH_DSP_VALUEHL 
1f63 cd 35 1a			call macro_dsp_valuehl 
1f66				endm 
# End of macro FORTH_DSP_VALUEHL
1f66 e5					push hl     ; w2 
1f67			 
1f67					FORTH_DSP_POP 
1f67 cd d1 1a			call macro_forth_dsp_pop 
1f6a				endm 
# End of macro FORTH_DSP_POP
1f6a			 
1f6a					FORTH_DSP_VALUEHL 
1f6a cd 35 1a			call macro_dsp_valuehl 
1f6d				endm 
# End of macro FORTH_DSP_VALUEHL
1f6d			 
1f6d					FORTH_DSP_POP 
1f6d cd d1 1a			call macro_forth_dsp_pop 
1f70				endm 
# End of macro FORTH_DSP_POP
1f70			 
1f70 d1					pop de     ; w2	, hl = w1 
1f71			 
1f71 eb					ex de, hl 
1f72 d5					push de 
1f73			 
1f73 cd 9a 19				call forth_push_numhl 
1f76			 
1f76 e1					pop hl 
1f77			 
1f77 cd 9a 19				call forth_push_numhl 
1f7a					 
1f7a			 
1f7a					NEXTW 
1f7a c3 8b 1b			jp macro_next 
1f7d				endm 
# End of macro NEXTW
1f7d			.COLN: 
1f7d				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
1f7d 19				db WORD_SYS_CORE+OPCODE_COLN             
1f7e 09 21			dw .SCOLN            
1f80 02				db 1 + 1 
1f81 .. 00			db ":",0              
1f83				endm 
# End of macro CWHEAD
1f83			; | : ( -- )         Create new word | DONE 
1f83			 
1f83					if DEBUG_FORTH_WORDS_KEY 
1f83						DMARK "CLN" 
1f83 f5				push af  
1f84 3a 98 1f			ld a, (.dmark)  
1f87 32 77 fb			ld (debug_mark),a  
1f8a 3a 99 1f			ld a, (.dmark+1)  
1f8d 32 78 fb			ld (debug_mark+1),a  
1f90 3a 9a 1f			ld a, (.dmark+2)  
1f93 32 79 fb			ld (debug_mark+2),a  
1f96 18 03			jr .pastdmark  
1f98 ..			.dmark: db "CLN"  
1f9b f1			.pastdmark: pop af  
1f9c			endm  
# End of macro DMARK
1f9c						CALLMONITOR 
1f9c cd 00 14			call break_point_state  
1f9f				endm  
# End of macro CALLMONITOR
1f9f					endif 
1f9f				STACKFRAME OFF $8efe $989f 
1f9f				if DEBUG_STACK_IMB 
1f9f					if OFF 
1f9f						exx 
1f9f						ld de, $8efe 
1f9f						ld a, d 
1f9f						ld hl, curframe 
1f9f						call hexout 
1f9f						ld a, e 
1f9f						ld hl, curframe+2 
1f9f						call hexout 
1f9f						ld hl, $8efe 
1f9f						push hl 
1f9f						ld hl, $989f 
1f9f						push hl 
1f9f						exx 
1f9f					endif 
1f9f				endif 
1f9f			endm 
# End of macro STACKFRAME
1f9f				; get parser buffer length  of new word 
1f9f			 
1f9f				 
1f9f			 
1f9f					; move tok past this to start of name defintition 
1f9f					; TODO get word to define 
1f9f					; TODO Move past word token 
1f9f					; TODO get length of string up to the ';' 
1f9f			 
1f9f 2a 33 f1			ld hl, (os_tok_ptr) 
1fa2 23				inc hl 
1fa3 23				inc hl 
1fa4			 
1fa4 3e 3b			ld a, ';' 
1fa6 cd 7b 10			call strlent 
1fa9			 
1fa9 7d				ld a,l 
1faa 32 32 f0			ld (os_new_parse_len), a 
1fad			 
1fad			 
1fad			if DEBUG_FORTH_UWORD 
1fad ed 5b 33 f1		ld de, (os_tok_ptr) 
1fb1						DMARK ":01" 
1fb1 f5				push af  
1fb2 3a c6 1f			ld a, (.dmark)  
1fb5 32 77 fb			ld (debug_mark),a  
1fb8 3a c7 1f			ld a, (.dmark+1)  
1fbb 32 78 fb			ld (debug_mark+1),a  
1fbe 3a c8 1f			ld a, (.dmark+2)  
1fc1 32 79 fb			ld (debug_mark+2),a  
1fc4 18 03			jr .pastdmark  
1fc6 ..			.dmark: db ":01"  
1fc9 f1			.pastdmark: pop af  
1fca			endm  
# End of macro DMARK
1fca				CALLMONITOR 
1fca cd 00 14			call break_point_state  
1fcd				endm  
# End of macro CALLMONITOR
1fcd			endif 
1fcd			 
1fcd			; 
1fcd			;  new word memory layout: 
1fcd			;  
1fcd			;    : adg 6666 ;  
1fcd			; 
1fcd			;    db   1     ; user defined word  
1fcd 23				inc hl    
1fce			;    dw   sysdict 
1fce 23				inc hl 
1fcf 23				inc hl 
1fd0			;    db <word len>+1 (for null) 
1fd0 23				inc hl 
1fd1			;    db .... <word> 
1fd1			; 
1fd1			 
1fd1 23				inc hl    ; some extras for the word preamble before the above 
1fd2 23				inc hl 
1fd3 23				inc hl 
1fd4 23				inc hl 
1fd5 23				inc hl 
1fd6 23				inc hl 
1fd7 23				inc hl  
1fd8 23				inc hl 
1fd9 23				inc hl 
1fda 23				inc hl 
1fdb 23				inc hl 
1fdc 23				inc hl 
1fdd 23				inc hl 
1fde 23				inc hl     ; TODO how many do we really need?     maybe only 6 
1fdf			;       exec word buffer 
1fdf			;	<ptr word>   
1fdf 23				inc hl 
1fe0 23				inc hl 
1fe1			;       <word list><null term> 7F final term 
1fe1			 
1fe1			 
1fe1			if DEBUG_FORTH_UWORD 
1fe1						DMARK ":02" 
1fe1 f5				push af  
1fe2 3a f6 1f			ld a, (.dmark)  
1fe5 32 77 fb			ld (debug_mark),a  
1fe8 3a f7 1f			ld a, (.dmark+1)  
1feb 32 78 fb			ld (debug_mark+1),a  
1fee 3a f8 1f			ld a, (.dmark+2)  
1ff1 32 79 fb			ld (debug_mark+2),a  
1ff4 18 03			jr .pastdmark  
1ff6 ..			.dmark: db ":02"  
1ff9 f1			.pastdmark: pop af  
1ffa			endm  
# End of macro DMARK
1ffa				CALLMONITOR 
1ffa cd 00 14			call break_point_state  
1ffd				endm  
# End of macro CALLMONITOR
1ffd			endif 
1ffd			 
1ffd				 
1ffd					; malloc the size 
1ffd			 
1ffd cd d9 10				call malloc 
2000 22 30 f0				ld (os_new_malloc), hl     ; save malloc start 
2003			 
2003			;    db   1     ; user defined word  
2003 3e 01				ld a, WORD_SYS_UWORD  
2005 77					ld (hl), a 
2006				 
2006 23				inc hl    
2007			;    dw   sysdict 
2007 11 e3 1c			ld de, sysdict       ; continue on with the scan to the system dict 
200a 73				ld (hl), e 
200b 23				inc hl 
200c 72				ld (hl), d 
200d 23				inc hl 
200e			 
200e			 
200e			;    Setup dict word 
200e			 
200e 23				inc hl 
200f 22 36 f0			ld (os_new_work_ptr), hl     ; save start of dict word  
2012			 
2012				; 1. get length of dict word 
2012			 
2012			 
2012 2a 33 f1			ld hl, (os_tok_ptr) 
2015 23				inc hl 
2016 23				inc hl    ; position to start of dict word 
2017 3e 00			ld a, 0 
2019 cd 7b 10			call strlent 
201c			 
201c			 
201c 23				inc hl    ; to include null??? 
201d			 
201d				; write length of dict word 
201d			 
201d ed 5b 36 f0		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2021 1b				dec de 
2022 eb				ex de, hl 
2023 73				ld (hl), e 
2024 eb				ex de, hl 
2025			 
2025				 
2025			 
2025				; copy  
2025 4d				ld c, l 
2026 06 00			ld b, 0 
2028 ed 5b 36 f0		ld de, (os_new_work_ptr)   ; get dest for copy of word 
202c 2a 33 f1			ld hl, (os_tok_ptr) 
202f 23				inc hl 
2030 23				inc hl    ; position to start of dict word 
2031				 
2031			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
2031				 
2031				; TODO need to convert word to upper case 
2031			 
2031			ucasetok:	 
2031 7e				ld a,(hl) 
2032 cd 67 10			call toUpper 
2035 77				ld (hl),a 
2036 ed a0			ldi 
2038 f2 31 20		 	jp p, ucasetok 
203b			 
203b			 
203b			 
203b				; de now points to start of where the word body code should be placed 
203b ed 53 36 f0		ld (os_new_work_ptr), de 
203f				; hl now points to the words to throw at forthexec which needs to be copied 
203f 22 38 f0			ld (os_new_src_ptr), hl 
2042			 
2042				; TODO add 'call to forthexec' 
2042			 
2042			if DEBUG_FORTH_UWORD 
2042 c5				push bc 
2043 ed 4b 30 f0		ld bc, (os_new_malloc) 
2047						DMARK ":0x" 
2047 f5				push af  
2048 3a 5c 20			ld a, (.dmark)  
204b 32 77 fb			ld (debug_mark),a  
204e 3a 5d 20			ld a, (.dmark+1)  
2051 32 78 fb			ld (debug_mark+1),a  
2054 3a 5e 20			ld a, (.dmark+2)  
2057 32 79 fb			ld (debug_mark+2),a  
205a 18 03			jr .pastdmark  
205c ..			.dmark: db ":0x"  
205f f1			.pastdmark: pop af  
2060			endm  
# End of macro DMARK
2060				CALLMONITOR 
2060 cd 00 14			call break_point_state  
2063				endm  
# End of macro CALLMONITOR
2063 c1				pop bc 
2064			endif 
2064			 
2064			 
2064				; create word preamble which should be: 
2064			 
2064			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
2064			 
2064				;    ld hl, <word code> 
2064				;    jp user_exec 
2064			        ;    <word code bytes> 
2064			 
2064			 
2064			;	inc de     ; TODO ??? or are we already past the word's null 
2064 eb				ex de, hl 
2065			 
2065 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
2067			 
2067 23				inc hl 
2068 22 3c f0			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
206b 23				inc hl 
206c			 
206c 23				inc hl 
206d 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
206f			 
206f 01 88 4c			ld bc, user_exec 
2072 23				inc hl 
2073 71				ld (hl), c     ; poke address of user_exec 
2074 23				inc hl 
2075 70				ld (hl), b     
2076			 ; 
2076			;	inc hl 
2076			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2076			; 
2076			; 
2076			;	ld bc, macro_forth_rsp_next 
2076			;	inc hl 
2076			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
2076			;	inc hl 
2076			;	ld (hl), b     
2076			 ; 
2076			;	inc hl 
2076			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2076			; 
2076			; 
2076			;	inc hl 
2076			;	ld bc, forthexec 
2076			;	ld (hl), c     ; poke address of forthexec 
2076			;	inc hl 
2076			;	ld (hl), b      
2076			; 
2076			;	inc hl 
2076			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
2076			; 
2076			;	ld bc, user_dict_next 
2076			;	inc hl 
2076			;	ld (hl), c     ; poke address of forthexec 
2076			;	inc hl 
2076			;	ld (hl), b      
2076			 
2076				; hl is now where we need to copy the word byte data to save this 
2076			 
2076 23				inc hl 
2077 22 3a f0			ld (os_new_exec), hl 
207a				 
207a				; copy definition 
207a			 
207a eb				ex de, hl 
207b			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
207b			;	inc de    ; skip the PC for this parse 
207b 3a 32 f0			ld a, (os_new_parse_len) 
207e 4f				ld c, a 
207f 06 00			ld b, 0 
2081 ed b0			ldir		 ; copy defintion 
2083			 
2083			 
2083				; poke the address of where the new word bytes live for forthexec 
2083			 
2083 2a 3c f0			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
2086			 
2086 ed 5b 3a f0		ld de, (os_new_exec)      
208a				 
208a 73				ld (hl), e 
208b 23				inc hl 
208c 72				ld (hl), d 
208d			 
208d					; TODO copy last user dict word next link to this word 
208d					; TODO update last user dict word to point to this word 
208d			; 
208d			; hl f923 de 812a ; bc 811a 
208d			 
208d			if DEBUG_FORTH_UWORD 
208d c5				push bc 
208e ed 4b 30 f0		ld bc, (os_new_malloc) 
2092						DMARK ":0A" 
2092 f5				push af  
2093 3a a7 20			ld a, (.dmark)  
2096 32 77 fb			ld (debug_mark),a  
2099 3a a8 20			ld a, (.dmark+1)  
209c 32 78 fb			ld (debug_mark+1),a  
209f 3a a9 20			ld a, (.dmark+2)  
20a2 32 79 fb			ld (debug_mark+2),a  
20a5 18 03			jr .pastdmark  
20a7 ..			.dmark: db ":0A"  
20aa f1			.pastdmark: pop af  
20ab			endm  
# End of macro DMARK
20ab				CALLMONITOR 
20ab cd 00 14			call break_point_state  
20ae				endm  
# End of macro CALLMONITOR
20ae c1				pop bc 
20af			endif 
20af			if DEBUG_FORTH_UWORD 
20af c5				push bc 
20b0 ed 4b 30 f0		ld bc, (os_new_malloc) 
20b4 03				inc bc 
20b5 03				inc bc 
20b6 03				inc bc 
20b7 03				inc bc 
20b8 03				inc bc 
20b9 03				inc bc 
20ba 03				inc bc 
20bb 03				inc bc 
20bc			 
20bc						DMARK ":0B" 
20bc f5				push af  
20bd 3a d1 20			ld a, (.dmark)  
20c0 32 77 fb			ld (debug_mark),a  
20c3 3a d2 20			ld a, (.dmark+1)  
20c6 32 78 fb			ld (debug_mark+1),a  
20c9 3a d3 20			ld a, (.dmark+2)  
20cc 32 79 fb			ld (debug_mark+2),a  
20cf 18 03			jr .pastdmark  
20d1 ..			.dmark: db ":0B"  
20d4 f1			.pastdmark: pop af  
20d5			endm  
# End of macro DMARK
20d5				CALLMONITOR 
20d5 cd 00 14			call break_point_state  
20d8				endm  
# End of macro CALLMONITOR
20d8 c1				pop bc 
20d9			endif 
20d9			 
20d9			; update word dict linked list for new word 
20d9			 
20d9			 
20d9 2a 2f f1		ld hl, (os_last_new_uword)		; get the start of the last added uword 
20dc 23			inc hl     ; move to next work linked list ptr 
20dd			 
20dd ed 5b 30 f0	ld de, (os_new_malloc)		 ; new next word 
20e1 73			ld (hl), e 
20e2 23			inc hl 
20e3 72			ld (hl), d 
20e4			 
20e4			if DEBUG_FORTH_UWORD 
20e4 ed 4b 2f f1		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
20e8			endif 
20e8			 
20e8 ed 53 2f f1	ld (os_last_new_uword), de      ; update last new uword ptr 
20ec			 
20ec			 
20ec			if DEBUG_FORTH_UWORD 
20ec						DMARK ":0+" 
20ec f5				push af  
20ed 3a 01 21			ld a, (.dmark)  
20f0 32 77 fb			ld (debug_mark),a  
20f3 3a 02 21			ld a, (.dmark+1)  
20f6 32 78 fb			ld (debug_mark+1),a  
20f9 3a 03 21			ld a, (.dmark+2)  
20fc 32 79 fb			ld (debug_mark+2),a  
20ff 18 03			jr .pastdmark  
2101 ..			.dmark: db ":0+"  
2104 f1			.pastdmark: pop af  
2105			endm  
# End of macro DMARK
2105				CALLMONITOR 
2105 cd 00 14			call break_point_state  
2108				endm  
# End of macro CALLMONITOR
2108			endif 
2108			 
2108				STACKFRAMECHK OFF $8efe $989f 
2108				if DEBUG_STACK_IMB 
2108					if OFF 
2108						exx 
2108						ld hl, $989f 
2108						pop de   ; $989f 
2108						call cmp16 
2108						jr nz, .spnosame 
2108						ld hl, $8efe 
2108						pop de   ; $8efe 
2108						call cmp16 
2108						jr z, .spfrsame 
2108						.spnosame: call showsperror 
2108						.spfrsame: nop 
2108						exx 
2108					endif 
2108				endif 
2108			endm 
# End of macro STACKFRAMECHK
2108			 
2108 c9			ret    ; dont process any remaining parser tokens as they form new word 
2109			 
2109			 
2109			 
2109			 
2109			;		NEXT 
2109			.SCOLN: 
2109			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
2109 06				db OPCODE_SCOLN 
210a 55 21			dw .DROP 
210c 02				db 2 
210d .. 00			db ";",0           
210f			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
210f					if DEBUG_FORTH_WORDS_KEY 
210f						DMARK "SCN" 
210f f5				push af  
2110 3a 24 21			ld a, (.dmark)  
2113 32 77 fb			ld (debug_mark),a  
2116 3a 25 21			ld a, (.dmark+1)  
2119 32 78 fb			ld (debug_mark+1),a  
211c 3a 26 21			ld a, (.dmark+2)  
211f 32 79 fb			ld (debug_mark+2),a  
2122 18 03			jr .pastdmark  
2124 ..			.dmark: db "SCN"  
2127 f1			.pastdmark: pop af  
2128			endm  
# End of macro DMARK
2128						CALLMONITOR 
2128 cd 00 14			call break_point_state  
212b				endm  
# End of macro CALLMONITOR
212b					endif 
212b					FORTH_RSP_TOS 
212b cd 58 19			call macro_forth_rsp_tos 
212e				endm 
# End of macro FORTH_RSP_TOS
212e e5					push hl 
212f					FORTH_RSP_POP 
212f cd 62 19			call macro_forth_rsp_pop 
2132				endm 
# End of macro FORTH_RSP_POP
2132 e1					pop hl 
2133			;		ex de,hl 
2133 22 33 f1				ld (os_tok_ptr),hl 
2136			 
2136			if DEBUG_FORTH_UWORD 
2136						DMARK "SCL" 
2136 f5				push af  
2137 3a 4b 21			ld a, (.dmark)  
213a 32 77 fb			ld (debug_mark),a  
213d 3a 4c 21			ld a, (.dmark+1)  
2140 32 78 fb			ld (debug_mark+1),a  
2143 3a 4d 21			ld a, (.dmark+2)  
2146 32 79 fb			ld (debug_mark+2),a  
2149 18 03			jr .pastdmark  
214b ..			.dmark: db "SCL"  
214e f1			.pastdmark: pop af  
214f			endm  
# End of macro DMARK
214f				CALLMONITOR 
214f cd 00 14			call break_point_state  
2152				endm  
# End of macro CALLMONITOR
2152			endif 
2152					NEXTW 
2152 c3 8b 1b			jp macro_next 
2155				endm 
# End of macro NEXTW
2155			 
2155			.DROP: 
2155				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
2155 1b				db WORD_SYS_CORE+OPCODE_DROP             
2156 80 21			dw .DUP2            
2158 05				db 4 + 1 
2159 .. 00			db "DROP",0              
215e				endm 
# End of macro CWHEAD
215e			; | DROP ( w -- )   drop the TOS item   | DONE 
215e					if DEBUG_FORTH_WORDS_KEY 
215e						DMARK "DRP" 
215e f5				push af  
215f 3a 73 21			ld a, (.dmark)  
2162 32 77 fb			ld (debug_mark),a  
2165 3a 74 21			ld a, (.dmark+1)  
2168 32 78 fb			ld (debug_mark+1),a  
216b 3a 75 21			ld a, (.dmark+2)  
216e 32 79 fb			ld (debug_mark+2),a  
2171 18 03			jr .pastdmark  
2173 ..			.dmark: db "DRP"  
2176 f1			.pastdmark: pop af  
2177			endm  
# End of macro DMARK
2177						CALLMONITOR 
2177 cd 00 14			call break_point_state  
217a				endm  
# End of macro CALLMONITOR
217a					endif 
217a					FORTH_DSP_POP 
217a cd d1 1a			call macro_forth_dsp_pop 
217d				endm 
# End of macro FORTH_DSP_POP
217d					NEXTW 
217d c3 8b 1b			jp macro_next 
2180				endm 
# End of macro NEXTW
2180			.DUP2: 
2180				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
2180 1c				db WORD_SYS_CORE+OPCODE_DUP2             
2181 c5 21			dw .DROP2            
2183 05				db 4 + 1 
2184 .. 00			db "2DUP",0              
2189				endm 
# End of macro CWHEAD
2189			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
2189					if DEBUG_FORTH_WORDS_KEY 
2189						DMARK "2DU" 
2189 f5				push af  
218a 3a 9e 21			ld a, (.dmark)  
218d 32 77 fb			ld (debug_mark),a  
2190 3a 9f 21			ld a, (.dmark+1)  
2193 32 78 fb			ld (debug_mark+1),a  
2196 3a a0 21			ld a, (.dmark+2)  
2199 32 79 fb			ld (debug_mark+2),a  
219c 18 03			jr .pastdmark  
219e ..			.dmark: db "2DU"  
21a1 f1			.pastdmark: pop af  
21a2			endm  
# End of macro DMARK
21a2						CALLMONITOR 
21a2 cd 00 14			call break_point_state  
21a5				endm  
# End of macro CALLMONITOR
21a5					endif 
21a5					FORTH_DSP_VALUEHL 
21a5 cd 35 1a			call macro_dsp_valuehl 
21a8				endm 
# End of macro FORTH_DSP_VALUEHL
21a8 e5					push hl      ; 2 
21a9			 
21a9					FORTH_DSP_POP 
21a9 cd d1 1a			call macro_forth_dsp_pop 
21ac				endm 
# End of macro FORTH_DSP_POP
21ac					 
21ac					FORTH_DSP_VALUEHL 
21ac cd 35 1a			call macro_dsp_valuehl 
21af				endm 
# End of macro FORTH_DSP_VALUEHL
21af			;		push hl      ; 1 
21af			 
21af					FORTH_DSP_POP 
21af cd d1 1a			call macro_forth_dsp_pop 
21b2				endm 
# End of macro FORTH_DSP_POP
21b2			 
21b2			;		pop hl       ; 1 
21b2 d1					pop de       ; 2 
21b3			 
21b3 cd 9a 19				call forth_push_numhl 
21b6 eb					ex de, hl 
21b7 cd 9a 19				call forth_push_numhl 
21ba			 
21ba					 
21ba eb					ex de, hl 
21bb			 
21bb cd 9a 19				call forth_push_numhl 
21be eb					ex de, hl 
21bf cd 9a 19				call forth_push_numhl 
21c2			 
21c2			 
21c2					NEXTW 
21c2 c3 8b 1b			jp macro_next 
21c5				endm 
# End of macro NEXTW
21c5			.DROP2: 
21c5				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
21c5 1d				db WORD_SYS_CORE+OPCODE_DROP2             
21c6 f4 21			dw .SWAP2            
21c8 06				db 5 + 1 
21c9 .. 00			db "2DROP",0              
21cf				endm 
# End of macro CWHEAD
21cf			; | 2DROP ( w w -- )    Double drop | DONE 
21cf					if DEBUG_FORTH_WORDS_KEY 
21cf						DMARK "2DR" 
21cf f5				push af  
21d0 3a e4 21			ld a, (.dmark)  
21d3 32 77 fb			ld (debug_mark),a  
21d6 3a e5 21			ld a, (.dmark+1)  
21d9 32 78 fb			ld (debug_mark+1),a  
21dc 3a e6 21			ld a, (.dmark+2)  
21df 32 79 fb			ld (debug_mark+2),a  
21e2 18 03			jr .pastdmark  
21e4 ..			.dmark: db "2DR"  
21e7 f1			.pastdmark: pop af  
21e8			endm  
# End of macro DMARK
21e8						CALLMONITOR 
21e8 cd 00 14			call break_point_state  
21eb				endm  
# End of macro CALLMONITOR
21eb					endif 
21eb					FORTH_DSP_POP 
21eb cd d1 1a			call macro_forth_dsp_pop 
21ee				endm 
# End of macro FORTH_DSP_POP
21ee					FORTH_DSP_POP 
21ee cd d1 1a			call macro_forth_dsp_pop 
21f1				endm 
# End of macro FORTH_DSP_POP
21f1					NEXTW 
21f1 c3 8b 1b			jp macro_next 
21f4				endm 
# End of macro NEXTW
21f4			.SWAP2: 
21f4				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
21f4 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
21f5 1d 22			dw .AT            
21f7 06				db 5 + 1 
21f8 .. 00			db "2SWAP",0              
21fe				endm 
# End of macro CWHEAD
21fe			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
21fe					if DEBUG_FORTH_WORDS_KEY 
21fe						DMARK "2SW" 
21fe f5				push af  
21ff 3a 13 22			ld a, (.dmark)  
2202 32 77 fb			ld (debug_mark),a  
2205 3a 14 22			ld a, (.dmark+1)  
2208 32 78 fb			ld (debug_mark+1),a  
220b 3a 15 22			ld a, (.dmark+2)  
220e 32 79 fb			ld (debug_mark+2),a  
2211 18 03			jr .pastdmark  
2213 ..			.dmark: db "2SW"  
2216 f1			.pastdmark: pop af  
2217			endm  
# End of macro DMARK
2217						CALLMONITOR 
2217 cd 00 14			call break_point_state  
221a				endm  
# End of macro CALLMONITOR
221a					endif 
221a					NEXTW 
221a c3 8b 1b			jp macro_next 
221d				endm 
# End of macro NEXTW
221d			.AT: 
221d				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
221d 1f				db WORD_SYS_CORE+OPCODE_AT             
221e 4f 22			dw .CAT            
2220 02				db 1 + 1 
2221 .. 00			db "@",0              
2223				endm 
# End of macro CWHEAD
2223			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
2223			 
2223					if DEBUG_FORTH_WORDS_KEY 
2223						DMARK "AT." 
2223 f5				push af  
2224 3a 38 22			ld a, (.dmark)  
2227 32 77 fb			ld (debug_mark),a  
222a 3a 39 22			ld a, (.dmark+1)  
222d 32 78 fb			ld (debug_mark+1),a  
2230 3a 3a 22			ld a, (.dmark+2)  
2233 32 79 fb			ld (debug_mark+2),a  
2236 18 03			jr .pastdmark  
2238 ..			.dmark: db "AT."  
223b f1			.pastdmark: pop af  
223c			endm  
# End of macro DMARK
223c						CALLMONITOR 
223c cd 00 14			call break_point_state  
223f				endm  
# End of macro CALLMONITOR
223f					endif 
223f			.getbyteat:	 
223f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
223f cd 35 1a			call macro_dsp_valuehl 
2242				endm 
# End of macro FORTH_DSP_VALUEHL
2242					 
2242			;		push hl 
2242				 
2242					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2242 cd d1 1a			call macro_forth_dsp_pop 
2245				endm 
# End of macro FORTH_DSP_POP
2245			 
2245			;		pop hl 
2245			 
2245 7e					ld a, (hl) 
2246			 
2246 6f					ld l, a 
2247 26 00				ld h, 0 
2249 cd 9a 19				call forth_push_numhl 
224c			 
224c					NEXTW 
224c c3 8b 1b			jp macro_next 
224f				endm 
# End of macro NEXTW
224f			.CAT: 
224f				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
224f 20				db WORD_SYS_CORE+OPCODE_CAT             
2250 78 22			dw .BANG            
2252 03				db 2 + 1 
2253 .. 00			db "C@",0              
2256				endm 
# End of macro CWHEAD
2256			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
2256					if DEBUG_FORTH_WORDS_KEY 
2256						DMARK "CAA" 
2256 f5				push af  
2257 3a 6b 22			ld a, (.dmark)  
225a 32 77 fb			ld (debug_mark),a  
225d 3a 6c 22			ld a, (.dmark+1)  
2260 32 78 fb			ld (debug_mark+1),a  
2263 3a 6d 22			ld a, (.dmark+2)  
2266 32 79 fb			ld (debug_mark+2),a  
2269 18 03			jr .pastdmark  
226b ..			.dmark: db "CAA"  
226e f1			.pastdmark: pop af  
226f			endm  
# End of macro DMARK
226f						CALLMONITOR 
226f cd 00 14			call break_point_state  
2272				endm  
# End of macro CALLMONITOR
2272					endif 
2272 c3 3f 22				jp .getbyteat 
2275					NEXTW 
2275 c3 8b 1b			jp macro_next 
2278				endm 
# End of macro NEXTW
2278			.BANG: 
2278				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
2278 21				db WORD_SYS_CORE+OPCODE_BANG             
2279 ae 22			dw .CBANG            
227b 02				db 1 + 1 
227c .. 00			db "!",0              
227e				endm 
# End of macro CWHEAD
227e			; | ! ( x w -- ) Store x at address w      | DONE 
227e					if DEBUG_FORTH_WORDS_KEY 
227e						DMARK "BNG" 
227e f5				push af  
227f 3a 93 22			ld a, (.dmark)  
2282 32 77 fb			ld (debug_mark),a  
2285 3a 94 22			ld a, (.dmark+1)  
2288 32 78 fb			ld (debug_mark+1),a  
228b 3a 95 22			ld a, (.dmark+2)  
228e 32 79 fb			ld (debug_mark+2),a  
2291 18 03			jr .pastdmark  
2293 ..			.dmark: db "BNG"  
2296 f1			.pastdmark: pop af  
2297			endm  
# End of macro DMARK
2297						CALLMONITOR 
2297 cd 00 14			call break_point_state  
229a				endm  
# End of macro CALLMONITOR
229a					endif 
229a			 
229a			.storebyteat:		 
229a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
229a cd 35 1a			call macro_dsp_valuehl 
229d				endm 
# End of macro FORTH_DSP_VALUEHL
229d					 
229d e5					push hl 
229e				 
229e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
229e cd d1 1a			call macro_forth_dsp_pop 
22a1				endm 
# End of macro FORTH_DSP_POP
22a1			 
22a1					; get byte to poke 
22a1			 
22a1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
22a1 cd 35 1a			call macro_dsp_valuehl 
22a4				endm 
# End of macro FORTH_DSP_VALUEHL
22a4 e5					push hl 
22a5			 
22a5			 
22a5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
22a5 cd d1 1a			call macro_forth_dsp_pop 
22a8				endm 
# End of macro FORTH_DSP_POP
22a8			 
22a8			 
22a8 d1					pop de 
22a9 e1					pop hl 
22aa			 
22aa 73					ld (hl),e 
22ab			 
22ab			 
22ab					NEXTW 
22ab c3 8b 1b			jp macro_next 
22ae				endm 
# End of macro NEXTW
22ae			.CBANG: 
22ae				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
22ae 22				db WORD_SYS_CORE+OPCODE_CBANG             
22af d7 22			dw .SCALL            
22b1 03				db 2 + 1 
22b2 .. 00			db "C!",0              
22b5				endm 
# End of macro CWHEAD
22b5			; | C!  ( x w -- ) Store x at address w  | DONE 
22b5					if DEBUG_FORTH_WORDS_KEY 
22b5						DMARK "CBA" 
22b5 f5				push af  
22b6 3a ca 22			ld a, (.dmark)  
22b9 32 77 fb			ld (debug_mark),a  
22bc 3a cb 22			ld a, (.dmark+1)  
22bf 32 78 fb			ld (debug_mark+1),a  
22c2 3a cc 22			ld a, (.dmark+2)  
22c5 32 79 fb			ld (debug_mark+2),a  
22c8 18 03			jr .pastdmark  
22ca ..			.dmark: db "CBA"  
22cd f1			.pastdmark: pop af  
22ce			endm  
# End of macro DMARK
22ce						CALLMONITOR 
22ce cd 00 14			call break_point_state  
22d1				endm  
# End of macro CALLMONITOR
22d1					endif 
22d1 c3 9a 22				jp .storebyteat 
22d4					NEXTW 
22d4 c3 8b 1b			jp macro_next 
22d7				endm 
# End of macro NEXTW
22d7			.SCALL: 
22d7				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
22d7 23				db WORD_SYS_CORE+OPCODE_SCALL             
22d8 0b 23			dw .DEPTH            
22da 05				db 4 + 1 
22db .. 00			db "CALL",0              
22e0				endm 
# End of macro CWHEAD
22e0			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
22e0					if DEBUG_FORTH_WORDS_KEY 
22e0						DMARK "CLL" 
22e0 f5				push af  
22e1 3a f5 22			ld a, (.dmark)  
22e4 32 77 fb			ld (debug_mark),a  
22e7 3a f6 22			ld a, (.dmark+1)  
22ea 32 78 fb			ld (debug_mark+1),a  
22ed 3a f7 22			ld a, (.dmark+2)  
22f0 32 79 fb			ld (debug_mark+2),a  
22f3 18 03			jr .pastdmark  
22f5 ..			.dmark: db "CLL"  
22f8 f1			.pastdmark: pop af  
22f9			endm  
# End of macro DMARK
22f9						CALLMONITOR 
22f9 cd 00 14			call break_point_state  
22fc				endm  
# End of macro CALLMONITOR
22fc					endif 
22fc			 
22fc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
22fc cd 35 1a			call macro_dsp_valuehl 
22ff				endm 
# End of macro FORTH_DSP_VALUEHL
22ff			 
22ff			;		push hl 
22ff			 
22ff					; destroy value TOS 
22ff			 
22ff					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
22ff cd d1 1a			call macro_forth_dsp_pop 
2302				endm 
# End of macro FORTH_DSP_POP
2302			 
2302						 
2302			;		pop hl 
2302			 
2302					; how to do a call with hl???? save SP? 
2302 cd 34 1b				call forth_call_hl 
2305			 
2305			 
2305					; TODO push value back onto stack for another op etc 
2305			 
2305 cd 9a 19				call forth_push_numhl 
2308					NEXTW 
2308 c3 8b 1b			jp macro_next 
230b				endm 
# End of macro NEXTW
230b			.DEPTH: 
230b				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
230b 24				db WORD_SYS_CORE+OPCODE_DEPTH             
230c 48 23			dw .OVER            
230e 06				db 5 + 1 
230f .. 00			db "DEPTH",0              
2315				endm 
# End of macro CWHEAD
2315			; | DEPTH ( -- u ) Push count of stack | DONE 
2315					; take current TOS and remove from base value div by two to get count 
2315					if DEBUG_FORTH_WORDS_KEY 
2315						DMARK "DEP" 
2315 f5				push af  
2316 3a 2a 23			ld a, (.dmark)  
2319 32 77 fb			ld (debug_mark),a  
231c 3a 2b 23			ld a, (.dmark+1)  
231f 32 78 fb			ld (debug_mark+1),a  
2322 3a 2c 23			ld a, (.dmark+2)  
2325 32 79 fb			ld (debug_mark+2),a  
2328 18 03			jr .pastdmark  
232a ..			.dmark: db "DEP"  
232d f1			.pastdmark: pop af  
232e			endm  
# End of macro DMARK
232e						CALLMONITOR 
232e cd 00 14			call break_point_state  
2331				endm  
# End of macro CALLMONITOR
2331					endif 
2331			 
2331			 
2331 2a 1f f8			ld hl, (cli_data_sp) 
2334 11 99 f3			ld de, cli_data_stack 
2337 ed 52			sbc hl,de 
2339				 
2339				; div by size of stack item 
2339			 
2339 5d				ld e,l 
233a 0e 03			ld c, 3 
233c cd a2 0b			call Div8 
233f			 
233f 6f				ld l,a 
2340 26 00			ld h,0 
2342			 
2342				;srl h 
2342				;rr l 
2342			 
2342 cd 9a 19				call forth_push_numhl 
2345					NEXTW 
2345 c3 8b 1b			jp macro_next 
2348				endm 
# End of macro NEXTW
2348			.OVER: 
2348				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2348 42				db WORD_SYS_CORE+46             
2349 8f 23			dw .PAUSE            
234b 05				db 4 + 1 
234c .. 00			db "OVER",0              
2351				endm 
# End of macro CWHEAD
2351			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
2351					if DEBUG_FORTH_WORDS_KEY 
2351						DMARK "OVR" 
2351 f5				push af  
2352 3a 66 23			ld a, (.dmark)  
2355 32 77 fb			ld (debug_mark),a  
2358 3a 67 23			ld a, (.dmark+1)  
235b 32 78 fb			ld (debug_mark+1),a  
235e 3a 68 23			ld a, (.dmark+2)  
2361 32 79 fb			ld (debug_mark+2),a  
2364 18 03			jr .pastdmark  
2366 ..			.dmark: db "OVR"  
2369 f1			.pastdmark: pop af  
236a			endm  
# End of macro DMARK
236a						CALLMONITOR 
236a cd 00 14			call break_point_state  
236d				endm  
# End of macro CALLMONITOR
236d					endif 
236d			 
236d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
236d cd 35 1a			call macro_dsp_valuehl 
2370				endm 
# End of macro FORTH_DSP_VALUEHL
2370 e5					push hl    ; n2 
2371					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2371 cd d1 1a			call macro_forth_dsp_pop 
2374				endm 
# End of macro FORTH_DSP_POP
2374			 
2374					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2374 cd 35 1a			call macro_dsp_valuehl 
2377				endm 
# End of macro FORTH_DSP_VALUEHL
2377 e5					push hl    ; n1 
2378					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2378 cd d1 1a			call macro_forth_dsp_pop 
237b				endm 
# End of macro FORTH_DSP_POP
237b			 
237b d1					pop de     ; n1 
237c e1					pop hl     ; n2 
237d			 
237d d5					push de 
237e e5					push hl 
237f d5					push de 
2380			 
2380					; push back  
2380			 
2380 e1					pop hl 
2381 cd 9a 19				call forth_push_numhl 
2384 e1					pop hl 
2385 cd 9a 19				call forth_push_numhl 
2388 e1					pop hl 
2389 cd 9a 19				call forth_push_numhl 
238c					NEXTW 
238c c3 8b 1b			jp macro_next 
238f				endm 
# End of macro NEXTW
238f			 
238f			.PAUSE: 
238f				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
238f 43				db WORD_SYS_CORE+47             
2390 c4 23			dw .PAUSES            
2392 08				db 7 + 1 
2393 .. 00			db "PAUSEMS",0              
239b				endm 
# End of macro CWHEAD
239b			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
239b					if DEBUG_FORTH_WORDS_KEY 
239b						DMARK "PMS" 
239b f5				push af  
239c 3a b0 23			ld a, (.dmark)  
239f 32 77 fb			ld (debug_mark),a  
23a2 3a b1 23			ld a, (.dmark+1)  
23a5 32 78 fb			ld (debug_mark+1),a  
23a8 3a b2 23			ld a, (.dmark+2)  
23ab 32 79 fb			ld (debug_mark+2),a  
23ae 18 03			jr .pastdmark  
23b0 ..			.dmark: db "PMS"  
23b3 f1			.pastdmark: pop af  
23b4			endm  
# End of macro DMARK
23b4						CALLMONITOR 
23b4 cd 00 14			call break_point_state  
23b7				endm  
# End of macro CALLMONITOR
23b7					endif 
23b7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
23b7 cd 35 1a			call macro_dsp_valuehl 
23ba				endm 
# End of macro FORTH_DSP_VALUEHL
23ba			;		push hl    ; n2 
23ba					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
23ba cd d1 1a			call macro_forth_dsp_pop 
23bd				endm 
# End of macro FORTH_DSP_POP
23bd			;		pop hl 
23bd			 
23bd 7d					ld a, l 
23be cd 22 0a				call aDelayInMS 
23c1				       NEXTW 
23c1 c3 8b 1b			jp macro_next 
23c4				endm 
# End of macro NEXTW
23c4			.PAUSES:  
23c4				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
23c4 44				db WORD_SYS_CORE+48             
23c5 33 24			dw .ROT            
23c7 06				db 5 + 1 
23c8 .. 00			db "PAUSE",0              
23ce				endm 
# End of macro CWHEAD
23ce			; | PAUSE ( n -- )  Pause for n seconds | DONE 
23ce					if DEBUG_FORTH_WORDS_KEY 
23ce						DMARK "PAU" 
23ce f5				push af  
23cf 3a e3 23			ld a, (.dmark)  
23d2 32 77 fb			ld (debug_mark),a  
23d5 3a e4 23			ld a, (.dmark+1)  
23d8 32 78 fb			ld (debug_mark+1),a  
23db 3a e5 23			ld a, (.dmark+2)  
23de 32 79 fb			ld (debug_mark+2),a  
23e1 18 03			jr .pastdmark  
23e3 ..			.dmark: db "PAU"  
23e6 f1			.pastdmark: pop af  
23e7			endm  
# End of macro DMARK
23e7						CALLMONITOR 
23e7 cd 00 14			call break_point_state  
23ea				endm  
# End of macro CALLMONITOR
23ea					endif 
23ea					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
23ea cd 35 1a			call macro_dsp_valuehl 
23ed				endm 
# End of macro FORTH_DSP_VALUEHL
23ed			;		push hl    ; n2 
23ed					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
23ed cd d1 1a			call macro_forth_dsp_pop 
23f0				endm 
# End of macro FORTH_DSP_POP
23f0			;		pop hl 
23f0 45					ld b, l 
23f1					if DEBUG_FORTH_WORDS 
23f1						DMARK "PAU" 
23f1 f5				push af  
23f2 3a 06 24			ld a, (.dmark)  
23f5 32 77 fb			ld (debug_mark),a  
23f8 3a 07 24			ld a, (.dmark+1)  
23fb 32 78 fb			ld (debug_mark+1),a  
23fe 3a 08 24			ld a, (.dmark+2)  
2401 32 79 fb			ld (debug_mark+2),a  
2404 18 03			jr .pastdmark  
2406 ..			.dmark: db "PAU"  
2409 f1			.pastdmark: pop af  
240a			endm  
# End of macro DMARK
240a						CALLMONITOR 
240a cd 00 14			call break_point_state  
240d				endm  
# End of macro CALLMONITOR
240d					endif 
240d c5			.pauses1:	push bc 
240e cd 3d 0a				call delay1s 
2411 c1					pop bc 
2412					if DEBUG_FORTH_WORDS 
2412						DMARK "PA1" 
2412 f5				push af  
2413 3a 27 24			ld a, (.dmark)  
2416 32 77 fb			ld (debug_mark),a  
2419 3a 28 24			ld a, (.dmark+1)  
241c 32 78 fb			ld (debug_mark+1),a  
241f 3a 29 24			ld a, (.dmark+2)  
2422 32 79 fb			ld (debug_mark+2),a  
2425 18 03			jr .pastdmark  
2427 ..			.dmark: db "PA1"  
242a f1			.pastdmark: pop af  
242b			endm  
# End of macro DMARK
242b						CALLMONITOR 
242b cd 00 14			call break_point_state  
242e				endm  
# End of macro CALLMONITOR
242e					endif 
242e 10 dd				djnz .pauses1 
2430			 
2430				       NEXTW 
2430 c3 8b 1b			jp macro_next 
2433				endm 
# End of macro NEXTW
2433			.ROT: 
2433				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2433 45				db WORD_SYS_CORE+49             
2434 81 24			dw .UWORDS            
2436 04				db 3 + 1 
2437 .. 00			db "ROT",0              
243b				endm 
# End of macro CWHEAD
243b			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
243b					if DEBUG_FORTH_WORDS_KEY 
243b						DMARK "ROT" 
243b f5				push af  
243c 3a 50 24			ld a, (.dmark)  
243f 32 77 fb			ld (debug_mark),a  
2442 3a 51 24			ld a, (.dmark+1)  
2445 32 78 fb			ld (debug_mark+1),a  
2448 3a 52 24			ld a, (.dmark+2)  
244b 32 79 fb			ld (debug_mark+2),a  
244e 18 03			jr .pastdmark  
2450 ..			.dmark: db "ROT"  
2453 f1			.pastdmark: pop af  
2454			endm  
# End of macro DMARK
2454						CALLMONITOR 
2454 cd 00 14			call break_point_state  
2457				endm  
# End of macro CALLMONITOR
2457					endif 
2457			 
2457					FORTH_DSP_VALUEHL 
2457 cd 35 1a			call macro_dsp_valuehl 
245a				endm 
# End of macro FORTH_DSP_VALUEHL
245a e5					push hl    ; u3  
245b			 
245b					FORTH_DSP_POP 
245b cd d1 1a			call macro_forth_dsp_pop 
245e				endm 
# End of macro FORTH_DSP_POP
245e			   
245e					FORTH_DSP_VALUEHL 
245e cd 35 1a			call macro_dsp_valuehl 
2461				endm 
# End of macro FORTH_DSP_VALUEHL
2461 e5					push hl     ; u2 
2462			 
2462					FORTH_DSP_POP 
2462 cd d1 1a			call macro_forth_dsp_pop 
2465				endm 
# End of macro FORTH_DSP_POP
2465			 
2465					FORTH_DSP_VALUEHL 
2465 cd 35 1a			call macro_dsp_valuehl 
2468				endm 
# End of macro FORTH_DSP_VALUEHL
2468 e5					push hl     ; u1 
2469			 
2469					FORTH_DSP_POP 
2469 cd d1 1a			call macro_forth_dsp_pop 
246c				endm 
# End of macro FORTH_DSP_POP
246c			 
246c c1					pop bc      ; u1 
246d e1					pop hl      ; u2 
246e d1					pop de      ; u3 
246f			 
246f			 
246f c5					push bc 
2470 d5					push de 
2471 e5					push hl 
2472			 
2472			 
2472 e1					pop hl 
2473 cd 9a 19				call forth_push_numhl 
2476			 
2476 e1					pop hl 
2477 cd 9a 19				call forth_push_numhl 
247a			 
247a e1					pop hl 
247b cd 9a 19				call forth_push_numhl 
247e					 
247e			 
247e			 
247e			 
247e			 
247e			 
247e				       NEXTW 
247e c3 8b 1b			jp macro_next 
2481				endm 
# End of macro NEXTW
2481			 
2481			.UWORDS: 
2481				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2481 50				db WORD_SYS_CORE+60             
2482 43 25			dw .BP            
2484 07				db 6 + 1 
2485 .. 00			db "UWORDS",0              
248c				endm 
# End of macro CWHEAD
248c			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
248c			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
248c			; | | Following the count are the individual words. 
248c			; | | 
248c			; | | e.g. UWORDS 
248c			; | | BOX DIRLIST 2 
248c			; | |  
248c			; | | Can be used to save the words to storage via: 
248c			; | | UWORDS $01 DO $01 APPEND LOOP 
248c				if DEBUG_FORTH_WORDS_KEY 
248c					DMARK "UWR" 
248c f5				push af  
248d 3a a1 24			ld a, (.dmark)  
2490 32 77 fb			ld (debug_mark),a  
2493 3a a2 24			ld a, (.dmark+1)  
2496 32 78 fb			ld (debug_mark+1),a  
2499 3a a3 24			ld a, (.dmark+2)  
249c 32 79 fb			ld (debug_mark+2),a  
249f 18 03			jr .pastdmark  
24a1 ..			.dmark: db "UWR"  
24a4 f1			.pastdmark: pop af  
24a5			endm  
# End of macro DMARK
24a5					CALLMONITOR 
24a5 cd 00 14			call break_point_state  
24a8				endm  
# End of macro CALLMONITOR
24a8				endif 
24a8 21 00 80				ld hl, baseram 
24ab					;ld hl, baseusermem 
24ab 01 00 00				ld bc, 0    ; start a counter 
24ae			 
24ae				; skip dict stub 
24ae			 
24ae cd dc 1c				call forth_tok_next 
24b1			 
24b1			 
24b1			; while we have words to look for 
24b1			 
24b1 7e			.douscan:	ld a, (hl)      
24b2				if DEBUG_FORTH_WORDS 
24b2					DMARK "UWs" 
24b2 f5				push af  
24b3 3a c7 24			ld a, (.dmark)  
24b6 32 77 fb			ld (debug_mark),a  
24b9 3a c8 24			ld a, (.dmark+1)  
24bc 32 78 fb			ld (debug_mark+1),a  
24bf 3a c9 24			ld a, (.dmark+2)  
24c2 32 79 fb			ld (debug_mark+2),a  
24c5 18 03			jr .pastdmark  
24c7 ..			.dmark: db "UWs"  
24ca f1			.pastdmark: pop af  
24cb			endm  
# End of macro DMARK
24cb					CALLMONITOR 
24cb cd 00 14			call break_point_state  
24ce				endm  
# End of macro CALLMONITOR
24ce				endif 
24ce fe 00				cp WORD_SYS_END 
24d0 28 4d				jr z, .udone 
24d2 fe 01				cp WORD_SYS_UWORD 
24d4 20 44				jr nz, .nuword 
24d6			 
24d6				if DEBUG_FORTH_WORDS 
24d6					DMARK "UWu" 
24d6 f5				push af  
24d7 3a eb 24			ld a, (.dmark)  
24da 32 77 fb			ld (debug_mark),a  
24dd 3a ec 24			ld a, (.dmark+1)  
24e0 32 78 fb			ld (debug_mark+1),a  
24e3 3a ed 24			ld a, (.dmark+2)  
24e6 32 79 fb			ld (debug_mark+2),a  
24e9 18 03			jr .pastdmark  
24eb ..			.dmark: db "UWu"  
24ee f1			.pastdmark: pop af  
24ef			endm  
# End of macro DMARK
24ef					CALLMONITOR 
24ef cd 00 14			call break_point_state  
24f2				endm  
# End of macro CALLMONITOR
24f2				endif 
24f2					; we have a uword so push its name to the stack 
24f2			 
24f2 e5				   	push hl  ; save so we can move to next dict block 
24f3			 
24f3					; skip opcode 
24f3 23					inc hl  
24f4					; skip next ptr 
24f4 23					inc hl  
24f5 23					inc hl 
24f6					; skip len 
24f6 23					inc hl 
24f7				if DEBUG_FORTH_WORDS 
24f7					DMARK "UWt" 
24f7 f5				push af  
24f8 3a 0c 25			ld a, (.dmark)  
24fb 32 77 fb			ld (debug_mark),a  
24fe 3a 0d 25			ld a, (.dmark+1)  
2501 32 78 fb			ld (debug_mark+1),a  
2504 3a 0e 25			ld a, (.dmark+2)  
2507 32 79 fb			ld (debug_mark+2),a  
250a 18 03			jr .pastdmark  
250c ..			.dmark: db "UWt"  
250f f1			.pastdmark: pop af  
2510			endm  
# End of macro DMARK
2510					CALLMONITOR 
2510 cd 00 14			call break_point_state  
2513				endm  
# End of macro CALLMONITOR
2513				endif 
2513 03					inc bc 
2514			 
2514 c5					push bc 
2515 cd ac 19				call forth_push_str 
2518 c1					pop bc 
2519			 
2519 e1					pop hl 	 
251a			 
251a cd dc 1c		.nuword:	call forth_tok_next 
251d 18 92				jr .douscan  
251f			 
251f			.udone:		 ; push count of uwords found 
251f c5					push bc 
2520 e1					pop hl 
2521			 
2521				if DEBUG_FORTH_WORDS 
2521					DMARK "UWc" 
2521 f5				push af  
2522 3a 36 25			ld a, (.dmark)  
2525 32 77 fb			ld (debug_mark),a  
2528 3a 37 25			ld a, (.dmark+1)  
252b 32 78 fb			ld (debug_mark+1),a  
252e 3a 38 25			ld a, (.dmark+2)  
2531 32 79 fb			ld (debug_mark+2),a  
2534 18 03			jr .pastdmark  
2536 ..			.dmark: db "UWc"  
2539 f1			.pastdmark: pop af  
253a			endm  
# End of macro DMARK
253a					CALLMONITOR 
253a cd 00 14			call break_point_state  
253d				endm  
# End of macro CALLMONITOR
253d				endif 
253d cd 9a 19				call forth_push_numhl 
2540			 
2540			 
2540				       NEXTW 
2540 c3 8b 1b			jp macro_next 
2543				endm 
# End of macro NEXTW
2543			 
2543			.BP: 
2543				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2543 54				db WORD_SYS_CORE+64             
2544 79 25			dw .MONITOR            
2546 03				db 2 + 1 
2547 .. 00			db "BP",0              
254a				endm 
# End of macro CWHEAD
254a			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
254a			; | | $00 Will enable the break points within specific code paths 
254a			; | | $01 Will disable break points 
254a			; | |  
254a			; | | By default break points are off. Either the above can be used to enable them 
254a			; | | or if a key is held down during start up the spashscreen will appear to freeze 
254a			; | | and on release of the pressed key a message will be disaplayed to notify 
254a			; | | that break points are enabled. Pressing any key will then continue boot process. 
254a					; get byte count 
254a					if DEBUG_FORTH_WORDS_KEY 
254a						DMARK "BP." 
254a f5				push af  
254b 3a 5f 25			ld a, (.dmark)  
254e 32 77 fb			ld (debug_mark),a  
2551 3a 60 25			ld a, (.dmark+1)  
2554 32 78 fb			ld (debug_mark+1),a  
2557 3a 61 25			ld a, (.dmark+2)  
255a 32 79 fb			ld (debug_mark+2),a  
255d 18 03			jr .pastdmark  
255f ..			.dmark: db "BP."  
2562 f1			.pastdmark: pop af  
2563			endm  
# End of macro DMARK
2563						CALLMONITOR 
2563 cd 00 14			call break_point_state  
2566				endm  
# End of macro CALLMONITOR
2566					endif 
2566			 
2566					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2566 cd 35 1a			call macro_dsp_valuehl 
2569				endm 
# End of macro FORTH_DSP_VALUEHL
2569			 
2569			;		push hl 
2569			 
2569					; destroy value TOS 
2569			 
2569					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2569 cd d1 1a			call macro_forth_dsp_pop 
256c				endm 
# End of macro FORTH_DSP_POP
256c			 
256c			;		pop hl 
256c			 
256c 3e 00				ld a,0 
256e bd					cp l 
256f 28 02				jr z, .bpset 
2571 3e 2a				ld a, '*' 
2573			 
2573 32 31 ee		.bpset:		ld (os_view_disable), a 
2576			 
2576			 
2576					NEXTW 
2576 c3 8b 1b			jp macro_next 
2579				endm 
# End of macro NEXTW
2579			 
2579			 
2579			.MONITOR: 
2579				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2579 55				db WORD_SYS_CORE+65             
257a ac 25			dw .MALLOC            
257c 08				db 7 + 1 
257d .. 00			db "MONITOR",0              
2585				endm 
# End of macro CWHEAD
2585			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2585			; | | At start the current various registers will be displayed with contents. 
2585			; | | Top right corner will show the most recent debug marker seen. 
2585			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2585			; | | and the return stack pointer (RSP). 
2585			; | | Pressing: 
2585			; | |    1 - Initial screen 
2585			; | |    2 - Display a data dump of HL 
2585			; | |    3 - Display a data dump of DE 
2585			; | |    4 - Display a data dump of BC 
2585			; | |    5 - Display a data dump of HL 
2585			; | |    6 - Display a data dump of DSP 
2585			; | |    7 - Display a data dump of RSP 
2585			; | |    8 - Display a data dump of what is at DSP 
2585			; | |    9 - Display a data dump of what is at RSP 
2585			; | |    0 - Exit monitor and continue running. This will also enable break points 
2585			; | |    * - Disable break points 
2585			; | |    # - Enter traditional monitor mode 
2585			; | | 
2585			; | | Monitor Mode 
2585			; | | ------------ 
2585			; | | A prompt of '>' will be shown for various commands: 
2585			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2585			; | |    C - Continue display a data dump from the last set address 
2585			; | |    M xxxx - Set start of memory edit at address xx 
2585			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2585			; | |    Q - Return to previous 
2585					if DEBUG_FORTH_WORDS_KEY 
2585						DMARK "MON" 
2585 f5				push af  
2586 3a 9a 25			ld a, (.dmark)  
2589 32 77 fb			ld (debug_mark),a  
258c 3a 9b 25			ld a, (.dmark+1)  
258f 32 78 fb			ld (debug_mark+1),a  
2592 3a 9c 25			ld a, (.dmark+2)  
2595 32 79 fb			ld (debug_mark+2),a  
2598 18 03			jr .pastdmark  
259a ..			.dmark: db "MON"  
259d f1			.pastdmark: pop af  
259e			endm  
# End of macro DMARK
259e						CALLMONITOR 
259e cd 00 14			call break_point_state  
25a1				endm  
# End of macro CALLMONITOR
25a1					endif 
25a1 3e 00				ld a, 0 
25a3 32 31 ee				ld (os_view_disable), a 
25a6			 
25a6					CALLMONITOR 
25a6 cd 00 14			call break_point_state  
25a9				endm  
# End of macro CALLMONITOR
25a9			 
25a9			;	call monitor 
25a9			 
25a9					NEXTW 
25a9 c3 8b 1b			jp macro_next 
25ac				endm 
# End of macro NEXTW
25ac			 
25ac			 
25ac			.MALLOC: 
25ac				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
25ac 56				db WORD_SYS_CORE+66             
25ad d5 25			dw .MALLOC2            
25af 06				db 5 + 1 
25b0 .. 00			db "ALLOT",0              
25b6				endm 
# End of macro CWHEAD
25b6			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
25b6					if DEBUG_FORTH_WORDS_KEY 
25b6						DMARK "ALL" 
25b6 f5				push af  
25b7 3a cb 25			ld a, (.dmark)  
25ba 32 77 fb			ld (debug_mark),a  
25bd 3a cc 25			ld a, (.dmark+1)  
25c0 32 78 fb			ld (debug_mark+1),a  
25c3 3a cd 25			ld a, (.dmark+2)  
25c6 32 79 fb			ld (debug_mark+2),a  
25c9 18 03			jr .pastdmark  
25cb ..			.dmark: db "ALL"  
25ce f1			.pastdmark: pop af  
25cf			endm  
# End of macro DMARK
25cf						CALLMONITOR 
25cf cd 00 14			call break_point_state  
25d2				endm  
# End of macro CALLMONITOR
25d2					endif 
25d2 c3 fc 25				jp .mallocc 
25d5			.MALLOC2: 
25d5				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
25d5 56				db WORD_SYS_CORE+66             
25d6 13 26			dw .FREE            
25d8 07				db 6 + 1 
25d9 .. 00			db "MALLOC",0              
25e0				endm 
# End of macro CWHEAD
25e0			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
25e0					; get byte count 
25e0					if DEBUG_FORTH_WORDS_KEY 
25e0						DMARK "MAL" 
25e0 f5				push af  
25e1 3a f5 25			ld a, (.dmark)  
25e4 32 77 fb			ld (debug_mark),a  
25e7 3a f6 25			ld a, (.dmark+1)  
25ea 32 78 fb			ld (debug_mark+1),a  
25ed 3a f7 25			ld a, (.dmark+2)  
25f0 32 79 fb			ld (debug_mark+2),a  
25f3 18 03			jr .pastdmark  
25f5 ..			.dmark: db "MAL"  
25f8 f1			.pastdmark: pop af  
25f9			endm  
# End of macro DMARK
25f9						CALLMONITOR 
25f9 cd 00 14			call break_point_state  
25fc				endm  
# End of macro CALLMONITOR
25fc					endif 
25fc			.mallocc: 
25fc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25fc cd 35 1a			call macro_dsp_valuehl 
25ff				endm 
# End of macro FORTH_DSP_VALUEHL
25ff			 
25ff			;		push hl 
25ff			 
25ff					; destroy value TOS 
25ff			 
25ff					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25ff cd d1 1a			call macro_forth_dsp_pop 
2602				endm 
# End of macro FORTH_DSP_POP
2602			 
2602			;		pop hl 
2602 cd d9 10				call malloc 
2605				if DEBUG_FORTH_MALLOC_GUARD 
2605 f5					push af 
2606 cd 3b 0c				call ishlzero 
2609			;		ld a, l 
2609			;		add h 
2609			;		cp 0 
2609 f1					pop af 
260a					 
260a cc 5a 4d				call z,malloc_error 
260d				endif 
260d			 
260d cd 9a 19				call forth_push_numhl 
2610					NEXTW 
2610 c3 8b 1b			jp macro_next 
2613				endm 
# End of macro NEXTW
2613			 
2613			.FREE: 
2613				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2613 57				db WORD_SYS_CORE+67             
2614 44 26			dw .LIST            
2616 05				db 4 + 1 
2617 .. 00			db "FREE",0              
261c				endm 
# End of macro CWHEAD
261c			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
261c					if DEBUG_FORTH_WORDS_KEY 
261c						DMARK "FRE" 
261c f5				push af  
261d 3a 31 26			ld a, (.dmark)  
2620 32 77 fb			ld (debug_mark),a  
2623 3a 32 26			ld a, (.dmark+1)  
2626 32 78 fb			ld (debug_mark+1),a  
2629 3a 33 26			ld a, (.dmark+2)  
262c 32 79 fb			ld (debug_mark+2),a  
262f 18 03			jr .pastdmark  
2631 ..			.dmark: db "FRE"  
2634 f1			.pastdmark: pop af  
2635			endm  
# End of macro DMARK
2635						CALLMONITOR 
2635 cd 00 14			call break_point_state  
2638				endm  
# End of macro CALLMONITOR
2638					endif 
2638					; get address 
2638			 
2638					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2638 cd 35 1a			call macro_dsp_valuehl 
263b				endm 
# End of macro FORTH_DSP_VALUEHL
263b			 
263b			;		push hl 
263b			 
263b					; destroy value TOS 
263b			 
263b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
263b cd d1 1a			call macro_forth_dsp_pop 
263e				endm 
# End of macro FORTH_DSP_POP
263e			 
263e			;		pop hl 
263e			if FORTH_ENABLE_MALLOCFREE 
263e cd a3 11				call free 
2641			endif 
2641					NEXTW 
2641 c3 8b 1b			jp macro_next 
2644				endm 
# End of macro NEXTW
2644			.LIST: 
2644				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2644 5c				db WORD_SYS_CORE+72             
2645 07 28			dw .FORGET            
2647 05				db 4 + 1 
2648 .. 00			db "LIST",0              
264d				endm 
# End of macro CWHEAD
264d			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
264d			; | | The quoted word must be in upper case. 
264d				if DEBUG_FORTH_WORDS_KEY 
264d					DMARK "LST" 
264d f5				push af  
264e 3a 62 26			ld a, (.dmark)  
2651 32 77 fb			ld (debug_mark),a  
2654 3a 63 26			ld a, (.dmark+1)  
2657 32 78 fb			ld (debug_mark+1),a  
265a 3a 64 26			ld a, (.dmark+2)  
265d 32 79 fb			ld (debug_mark+2),a  
2660 18 03			jr .pastdmark  
2662 ..			.dmark: db "LST"  
2665 f1			.pastdmark: pop af  
2666			endm  
# End of macro DMARK
2666					CALLMONITOR 
2666 cd 00 14			call break_point_state  
2669				endm  
# End of macro CALLMONITOR
2669				endif 
2669			 
2669					FORTH_DSP_VALUEHL 
2669 cd 35 1a			call macro_dsp_valuehl 
266c				endm 
# End of macro FORTH_DSP_VALUEHL
266c			 
266c e5					push hl 
266d c1					pop bc 
266e			 
266e			; Start format of scratch string 
266e			 
266e 21 32 ee				ld hl, scratch 
2671			 
2671 3e 3a				ld a, ':' 
2673 77					ld (hl),a 
2674 23					inc hl 
2675 3e 20				ld a, ' ' 
2677 77					ld (hl), a 
2678			 
2678					; Get ptr to the word we need to look up 
2678			 
2678			;		FORTH_DSP_VALUEHL 
2678					;v5 FORTH_DSP_VALUE 
2678				; TODO type check 
2678			;		inc hl    ; Skip type check  
2678			;		push hl 
2678			;		ex de, hl    ; put into DE 
2678			 
2678			 
2678 21 00 80				ld hl, baseram 
267b					;ld hl, baseusermem 
267b			 
267b e5			push hl   ; sacreifical push 
267c			 
267c			.ldouscanm: 
267c e1				pop hl 
267d			.ldouscan: 
267d				if DEBUG_FORTH_WORDS 
267d					DMARK "LSs" 
267d f5				push af  
267e 3a 92 26			ld a, (.dmark)  
2681 32 77 fb			ld (debug_mark),a  
2684 3a 93 26			ld a, (.dmark+1)  
2687 32 78 fb			ld (debug_mark+1),a  
268a 3a 94 26			ld a, (.dmark+2)  
268d 32 79 fb			ld (debug_mark+2),a  
2690 18 03			jr .pastdmark  
2692 ..			.dmark: db "LSs"  
2695 f1			.pastdmark: pop af  
2696			endm  
# End of macro DMARK
2696					CALLMONITOR 
2696 cd 00 14			call break_point_state  
2699				endm  
# End of macro CALLMONITOR
2699				endif 
2699				; skip dict stub 
2699 cd dc 1c				call forth_tok_next 
269c			 
269c			 
269c			; while we have words to look for 
269c			 
269c 7e				ld a, (hl)      
269d				if DEBUG_FORTH_WORDS 
269d					DMARK "LSk" 
269d f5				push af  
269e 3a b2 26			ld a, (.dmark)  
26a1 32 77 fb			ld (debug_mark),a  
26a4 3a b3 26			ld a, (.dmark+1)  
26a7 32 78 fb			ld (debug_mark+1),a  
26aa 3a b4 26			ld a, (.dmark+2)  
26ad 32 79 fb			ld (debug_mark+2),a  
26b0 18 03			jr .pastdmark  
26b2 ..			.dmark: db "LSk"  
26b5 f1			.pastdmark: pop af  
26b6			endm  
# End of macro DMARK
26b6					CALLMONITOR 
26b6 cd 00 14			call break_point_state  
26b9				endm  
# End of macro CALLMONITOR
26b9				endif 
26b9 fe 00				cp WORD_SYS_END 
26bb ca ee 27				jp z, .lunotfound 
26be fe 01				cp WORD_SYS_UWORD 
26c0 c2 7d 26				jp nz, .ldouscan 
26c3			 
26c3				if DEBUG_FORTH_WORDS 
26c3					DMARK "LSu" 
26c3 f5				push af  
26c4 3a d8 26			ld a, (.dmark)  
26c7 32 77 fb			ld (debug_mark),a  
26ca 3a d9 26			ld a, (.dmark+1)  
26cd 32 78 fb			ld (debug_mark+1),a  
26d0 3a da 26			ld a, (.dmark+2)  
26d3 32 79 fb			ld (debug_mark+2),a  
26d6 18 03			jr .pastdmark  
26d8 ..			.dmark: db "LSu"  
26db f1			.pastdmark: pop af  
26dc			endm  
# End of macro DMARK
26dc					CALLMONITOR 
26dc cd 00 14			call break_point_state  
26df				endm  
# End of macro CALLMONITOR
26df				endif 
26df			 
26df					; found a uword but is it the one we want... 
26df			 
26df c5					push bc     ; uword to find is on bc 
26e0 d1					pop de 
26e1			 
26e1 e5					push hl  ; to save the ptr 
26e2			 
26e2					; skip opcode 
26e2 23					inc hl  
26e3					; skip next ptr 
26e3 23					inc hl  
26e4 23					inc hl 
26e5					; skip len 
26e5 23					inc hl 
26e6			 
26e6				if DEBUG_FORTH_WORDS 
26e6					DMARK "LSc" 
26e6 f5				push af  
26e7 3a fb 26			ld a, (.dmark)  
26ea 32 77 fb			ld (debug_mark),a  
26ed 3a fc 26			ld a, (.dmark+1)  
26f0 32 78 fb			ld (debug_mark+1),a  
26f3 3a fd 26			ld a, (.dmark+2)  
26f6 32 79 fb			ld (debug_mark+2),a  
26f9 18 03			jr .pastdmark  
26fb ..			.dmark: db "LSc"  
26fe f1			.pastdmark: pop af  
26ff			endm  
# End of macro DMARK
26ff					CALLMONITOR 
26ff cd 00 14			call break_point_state  
2702				endm  
# End of macro CALLMONITOR
2702				endif 
2702 cd a8 10				call strcmp 
2705 c2 7c 26				jp nz, .ldouscanm 
2708				 
2708			 
2708			 
2708					; we have a uword so push its name to the stack 
2708			 
2708			;	   	push hl  ; save so we can move to next dict block 
2708 e1			pop hl 
2709			 
2709				if DEBUG_FORTH_WORDS 
2709					DMARK "LSm" 
2709 f5				push af  
270a 3a 1e 27			ld a, (.dmark)  
270d 32 77 fb			ld (debug_mark),a  
2710 3a 1f 27			ld a, (.dmark+1)  
2713 32 78 fb			ld (debug_mark+1),a  
2716 3a 20 27			ld a, (.dmark+2)  
2719 32 79 fb			ld (debug_mark+2),a  
271c 18 03			jr .pastdmark  
271e ..			.dmark: db "LSm"  
2721 f1			.pastdmark: pop af  
2722			endm  
# End of macro DMARK
2722					CALLMONITOR 
2722 cd 00 14			call break_point_state  
2725				endm  
# End of macro CALLMONITOR
2725				endif 
2725			 
2725					; skip opcode 
2725 23					inc hl  
2726					; skip next ptr 
2726 23					inc hl  
2727 23					inc hl 
2728					; skip len 
2728 7e					ld a, (hl)   ; save length to add 
2729				if DEBUG_FORTH_WORDS 
2729					DMARK "LS2" 
2729 f5				push af  
272a 3a 3e 27			ld a, (.dmark)  
272d 32 77 fb			ld (debug_mark),a  
2730 3a 3f 27			ld a, (.dmark+1)  
2733 32 78 fb			ld (debug_mark+1),a  
2736 3a 40 27			ld a, (.dmark+2)  
2739 32 79 fb			ld (debug_mark+2),a  
273c 18 03			jr .pastdmark  
273e ..			.dmark: db "LS2"  
2741 f1			.pastdmark: pop af  
2742			endm  
# End of macro DMARK
2742					CALLMONITOR 
2742 cd 00 14			call break_point_state  
2745				endm  
# End of macro CALLMONITOR
2745				endif 
2745			 
2745					; save this location 
2745				 
2745 e5					push hl 
2746			 
2746 23					inc hl 
2747 11 34 ee				ld de, scratch+2 
274a 4f					ld c, a 
274b 06 00				ld b, 0 
274d			 
274d				if DEBUG_FORTH_WORDS 
274d					DMARK "LSn" 
274d f5				push af  
274e 3a 62 27			ld a, (.dmark)  
2751 32 77 fb			ld (debug_mark),a  
2754 3a 63 27			ld a, (.dmark+1)  
2757 32 78 fb			ld (debug_mark+1),a  
275a 3a 64 27			ld a, (.dmark+2)  
275d 32 79 fb			ld (debug_mark+2),a  
2760 18 03			jr .pastdmark  
2762 ..			.dmark: db "LSn"  
2765 f1			.pastdmark: pop af  
2766			endm  
# End of macro DMARK
2766					CALLMONITOR 
2766 cd 00 14			call break_point_state  
2769				endm  
# End of macro CALLMONITOR
2769				endif 
2769			 
2769					; copy uword name to scratch 
2769			 
2769 ed b0				ldir 
276b			 
276b 1b					dec de 
276c 3e 20				ld a, ' '    ; change null to space 
276e 12					ld (de), a 
276f			 
276f 13					inc de 
2770			 
2770 d5					push de 
2771 c1					pop bc     ; move scratch pointer to end of word name and save it 
2772			 
2772 e1					pop hl 
2773 7e					ld a, (hl) 
2774					;inc hl 
2774					; skip word string 
2774 cd 12 0c				call addatohl 
2777			 
2777 23					inc hl 
2778			 
2778				if DEBUG_FORTH_WORDS 
2778					DMARK "LS3" 
2778 f5				push af  
2779 3a 8d 27			ld a, (.dmark)  
277c 32 77 fb			ld (debug_mark),a  
277f 3a 8e 27			ld a, (.dmark+1)  
2782 32 78 fb			ld (debug_mark+1),a  
2785 3a 8f 27			ld a, (.dmark+2)  
2788 32 79 fb			ld (debug_mark+2),a  
278b 18 03			jr .pastdmark  
278d ..			.dmark: db "LS3"  
2790 f1			.pastdmark: pop af  
2791			endm  
# End of macro DMARK
2791					CALLMONITOR 
2791 cd 00 14			call break_point_state  
2794				endm  
# End of macro CALLMONITOR
2794				endif 
2794					; should now be at the start of the machine code to setup the eval of the uword 
2794					; now locate the ptr to the string defintion 
2794			 
2794					; skip ld hl, 
2794					; then load the ptr 
2794			 
2794 23					inc hl 
2795 5e					ld e, (hl) 
2796 23					inc hl 
2797 56					ld d, (hl) 
2798 eb					ex de, hl 
2799			 
2799			 
2799				if DEBUG_FORTH_WORDS 
2799					DMARK "LSt" 
2799 f5				push af  
279a 3a ae 27			ld a, (.dmark)  
279d 32 77 fb			ld (debug_mark),a  
27a0 3a af 27			ld a, (.dmark+1)  
27a3 32 78 fb			ld (debug_mark+1),a  
27a6 3a b0 27			ld a, (.dmark+2)  
27a9 32 79 fb			ld (debug_mark+2),a  
27ac 18 03			jr .pastdmark  
27ae ..			.dmark: db "LSt"  
27b1 f1			.pastdmark: pop af  
27b2			endm  
# End of macro DMARK
27b2					CALLMONITOR 
27b2 cd 00 14			call break_point_state  
27b5				endm  
# End of macro CALLMONITOR
27b5				endif 
27b5			 
27b5			; cant push right now due to tokenised strings  
27b5			 
27b5			; get the destination of where to copy this definition to. 
27b5			 
27b5 c5					push bc 
27b6 d1					pop de 
27b7			 
27b7 7e			.listl:         ld a,(hl) 
27b8 fe 00				cp 0 
27ba 28 09				jr z, .lreplsp     ; replace zero with space 
27bc fe 7f				cp FORTH_END_BUFFER 
27be 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
27c0				 
27c0					; just copy this char as is then 
27c0			 
27c0 12					ld (de), a 
27c1			 
27c1 23			.listnxt:	inc hl 
27c2 13					inc de 
27c3 18 f2				jr .listl 
27c5			 
27c5 3e 20		.lreplsp:	ld a,' ' 
27c7 12					ld (de), a 
27c8 18 f7				jr .listnxt 
27ca			 
27ca			; close up uword def 
27ca			 
27ca			.listdone: 
27ca 3e 00				ld a, 0 
27cc 12					ld (de), a 
27cd			 
27cd			; now have def so clean up and push to stack 
27cd			 
27cd 21 32 ee				ld hl, scratch 
27d0				if DEBUG_FORTH_WORDS 
27d0					DMARK "Ltp" 
27d0 f5				push af  
27d1 3a e5 27			ld a, (.dmark)  
27d4 32 77 fb			ld (debug_mark),a  
27d7 3a e6 27			ld a, (.dmark+1)  
27da 32 78 fb			ld (debug_mark+1),a  
27dd 3a e7 27			ld a, (.dmark+2)  
27e0 32 79 fb			ld (debug_mark+2),a  
27e3 18 03			jr .pastdmark  
27e5 ..			.dmark: db "Ltp"  
27e8 f1			.pastdmark: pop af  
27e9			endm  
# End of macro DMARK
27e9					CALLMONITOR 
27e9 cd 00 14			call break_point_state  
27ec				endm  
# End of macro CALLMONITOR
27ec				endif 
27ec			 
27ec 18 06			jr .listpush 
27ee			 
27ee			;.lnuword:	pop hl 
27ee			;		call forth_tok_next 
27ee			;		jp .ldouscan  
27ee			 
27ee			.lunotfound:		  
27ee			 
27ee			 
27ee					 
27ee					FORTH_DSP_POP 
27ee cd d1 1a			call macro_forth_dsp_pop 
27f1				endm 
# End of macro FORTH_DSP_POP
27f1 21 fa 27				ld hl, .luno 
27f4						 
27f4			 
27f4			.listpush: 
27f4 cd ac 19				call forth_push_str 
27f7			 
27f7			 
27f7			 
27f7					NEXTW 
27f7 c3 8b 1b			jp macro_next 
27fa				endm 
# End of macro NEXTW
27fa			 
27fa .. 00		.luno:    db "Not found",0 
2804			 
2804			 
2804			 
2804			 
2804			 
2804			;		push hl   ; save pointer to start of uword def string 
2804			; 
2804			;; look for FORTH_EOL_LINE 
2804			;		ld a, FORTH_END_BUFFER 
2804			;		call strlent 
2804			; 
2804			;		inc hl		 ; space for coln def 
2804			;		inc hl 
2804			;		inc hl          ; space for terms 
2804			;		inc hl 
2804			; 
2804			;		ld a, 20   ; TODO get actual length 
2804			;		call addatohl    ; include a random amount of room for the uword name 
2804			; 
2804			;		 
2804			;	if DEBUG_FORTH_WORDS 
2804			;		DMARK "Lt1" 
2804			;		CALLMONITOR 
2804			;	endif 
2804			;		 
2804			; 
2804			;; malloc space for the string because we cant change it 
2804			; 
2804			;		call malloc 
2804			;	if DEBUG_FORTH_MALLOC_GUARD 
2804			;		push af 
2804			;		call ishlzero 
2804			;		pop af 
2804			;		 
2804			;		call z,malloc_error 
2804			;	endif 
2804			; 
2804			;	if DEBUG_FORTH_WORDS 
2804			;		DMARK "Lt2" 
2804			;		CALLMONITOR 
2804			;	endif 
2804			;		pop de 
2804			;		push hl    ; push the malloc to release later 
2804			;		push hl   ;  push back a copy for the later stack push 
2804			;		 
2804			;; copy the string swapping out the zero terms for spaces 
2804			; 
2804			;		; de has our source 
2804			;		; hl has our dest 
2804			; 
2804			;; add the coln def 
2804			; 
2804			;		ld a, ':' 
2804			;		ld (hl), a 
2804			;		inc hl 
2804			;		ld a, ' ' 
2804			;		ld (hl), a 
2804			;		inc hl 
2804			; 
2804			;; add the uname word 
2804			;		push de   ; save our string for now 
2804			;		ex de, hl 
2804			; 
2804			;		FORTH_DSP_VALUE 
2804			;		;v5 FORTH_DSP_VALUE 
2804			; 
2804			;		inc hl   ; skip type but we know by now this is OK 
2804			; 
2804			;.luword:	ld a,(hl) 
2804			;		cp 0 
2804			;		jr z, .luword2 
2804			;		ld (de), a 
2804			;		inc de 
2804			;		inc hl 
2804			;		jr .luword 
2804			; 
2804			;.luword2:	ld a, ' ' 
2804			;		ld (de), a 
2804			;;		inc hl 
2804			;;		inc de 
2804			;;		ld (de), a 
2804			;;		inc hl 
2804			;		inc de 
2804			; 
2804			;		ex de, hl 
2804			;		pop de 
2804			;		 
2804			;		 
2804			; 
2804			;; detoken that string and copy it 
2804			; 
2804			;	if DEBUG_FORTH_WORDS 
2804			;		DMARK "Lt2" 
2804			;		CALLMONITOR 
2804			;	endif 
2804			;.ldetok:	ld a, (de) 
2804			;		cp FORTH_END_BUFFER 
2804			;		jr z, .ldetokend 
2804			;		; swap out any zero term for space 
2804			;		cp 0 
2804			;		jr nz, .ldetoknext 
2804			;		ld a, ' ' 
2804			; 
2804			;	if DEBUG_FORTH_WORDS 
2804			;		DMARK "LtS" 
2804			;		CALLMONITOR 
2804			;	endif 
2804			;.ldetoknext:	ld (hl), a 
2804			;		inc de 
2804			;		inc hl 
2804			;		jr .ldetok 
2804			; 
2804			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2804			;		ld (hl), a  
2804			; 
2804			;; free that temp malloc 
2804			; 
2804			;		pop hl    
2804			; 
2804			;	if DEBUG_FORTH_WORDS 
2804			;		DMARK "Lt4" 
2804			;		CALLMONITOR 
2804			;	endif 
2804			;		call forth_apushstrhl 
2804			; 
2804			;		; get rid of temp malloc area 
2804			; 
2804			;		pop hl 
2804			;		call free 
2804			; 
2804			;		jr .ludone 
2804			; 
2804			;.lnuword:	pop hl 
2804			;		call forth_tok_next 
2804			;		jp .ldouscan  
2804			; 
2804			;.ludone:		 pop hl 
2804			; 
2804					NEXTW 
2804 c3 8b 1b			jp macro_next 
2807				endm 
# End of macro NEXTW
2807			 
2807			.FORGET: 
2807				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2807 5d				db WORD_SYS_CORE+73             
2808 80 28			dw .NOP            
280a 07				db 6 + 1 
280b .. 00			db "FORGET",0              
2812				endm 
# End of macro CWHEAD
2812			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2812			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2812			; | |  
2812			; | | e.g. "MORE" forget 
2812					if DEBUG_FORTH_WORDS_KEY 
2812						DMARK "FRG" 
2812 f5				push af  
2813 3a 27 28			ld a, (.dmark)  
2816 32 77 fb			ld (debug_mark),a  
2819 3a 28 28			ld a, (.dmark+1)  
281c 32 78 fb			ld (debug_mark+1),a  
281f 3a 29 28			ld a, (.dmark+2)  
2822 32 79 fb			ld (debug_mark+2),a  
2825 18 03			jr .pastdmark  
2827 ..			.dmark: db "FRG"  
282a f1			.pastdmark: pop af  
282b			endm  
# End of macro DMARK
282b						CALLMONITOR 
282b cd 00 14			call break_point_state  
282e				endm  
# End of macro CALLMONITOR
282e					endif 
282e			 
282e				; find uword 
282e			        ; update start of word with "_" 
282e				; replace uword with deleted flag 
282e			 
282e			 
282e			;	if DEBUG_FORTH_WORDS 
282e			;		DMARK "FOG" 
282e			;		CALLMONITOR 
282e			;	endif 
282e			 
282e			 
282e					; Get ptr to the word we need to look up 
282e			 
282e					FORTH_DSP_VALUEHL 
282e cd 35 1a			call macro_dsp_valuehl 
2831				endm 
# End of macro FORTH_DSP_VALUEHL
2831					;v5 FORTH_DSP_VALUE 
2831				; TODO type check 
2831			;		inc hl    ; Skip type check  
2831 e5					push hl 
2832 c1					pop bc 
2833			;		ex de, hl    ; put into DE 
2833			 
2833			 
2833 21 00 80				ld hl, baseram 
2836					;ld hl, baseusermem 
2836			 
2836				; skip dict stub 
2836			;	call forth_tok_next 
2836 e5			push hl   ; sacreifical push 
2837			 
2837			.fldouscanm: 
2837 e1				pop hl 
2838			.fldouscan: 
2838			;	if DEBUG_FORTH_WORDS 
2838			;		DMARK "LSs" 
2838			;		CALLMONITOR 
2838			;	endif 
2838				; skip dict stub 
2838 cd dc 1c				call forth_tok_next 
283b			 
283b			 
283b			; while we have words to look for 
283b			 
283b 7e				ld a, (hl)      
283c			;	if DEBUG_FORTH_WORDS 
283c			;		DMARK "LSk" 
283c			;		CALLMONITOR 
283c			;	endif 
283c fe 00				cp WORD_SYS_END 
283e ca 7a 28				jp z, .flunotfound 
2841 fe 01				cp WORD_SYS_UWORD 
2843 c2 38 28				jp nz, .fldouscan 
2846			 
2846			;	if DEBUG_FORTH_WORDS 
2846			;		DMARK "LSu" 
2846			;		CALLMONITOR 
2846			;	endif 
2846			 
2846					; found a uword but is it the one we want... 
2846			 
2846 c5					push bc     ; uword to find is on bc 
2847 d1					pop de 
2848			 
2848 e5					push hl  ; to save the ptr 
2849			 
2849					; skip opcode 
2849 23					inc hl  
284a					; skip next ptr 
284a 23					inc hl  
284b 23					inc hl 
284c					; skip len 
284c 23					inc hl 
284d			 
284d			;	if DEBUG_FORTH_WORDS 
284d			;		DMARK "LSc" 
284d			;		CALLMONITOR 
284d			;	endif 
284d cd a8 10				call strcmp 
2850 c2 37 28				jp nz, .fldouscanm 
2853			; 
2853			; 
2853			;; while we have words to look for 
2853			; 
2853			;.fdouscan:	ld a, (hl)      
2853			;	if DEBUG_FORTH_WORDS 
2853			;		DMARK "LSs" 
2853			;		CALLMONITOR 
2853			;	endif 
2853			;		cp WORD_SYS_END 
2853			;		jp z, .fudone 
2853			;		cp WORD_SYS_UWORD 
2853			;		jp nz, .fnuword 
2853			; 
2853			;	if DEBUG_FORTH_WORDS 
2853			;		DMARK "FGu" 
2853			;		CALLMONITOR 
2853			;	endif 
2853			; 
2853			;		; found a uword but is it the one we want... 
2853			; 
2853			; 
2853			;	        pop de   ; get back the dsp name 
2853			;		push de 
2853			; 
2853			;		push hl  ; to save the ptr 
2853			; 
2853			;		; skip opcode 
2853			;		inc hl  
2853			;		; skip next ptr 
2853			;		inc hl  
2853			;		inc hl 
2853			;		; skip len 
2853			;		inc hl 
2853			; 
2853			;	if DEBUG_FORTH_WORDS 
2853			;		DMARK "FGc" 
2853			;		CALLMONITOR 
2853			;	endif 
2853			;		call strcmp 
2853			;		jp nz, .fnuword 
2853			 
2853			 
2853 e1			pop hl 
2854			 
2854				 
2854				if DEBUG_FORTH_WORDS 
2854					DMARK "FGm" 
2854 f5				push af  
2855 3a 69 28			ld a, (.dmark)  
2858 32 77 fb			ld (debug_mark),a  
285b 3a 6a 28			ld a, (.dmark+1)  
285e 32 78 fb			ld (debug_mark+1),a  
2861 3a 6b 28			ld a, (.dmark+2)  
2864 32 79 fb			ld (debug_mark+2),a  
2867 18 03			jr .pastdmark  
2869 ..			.dmark: db "FGm"  
286c f1			.pastdmark: pop af  
286d			endm  
# End of macro DMARK
286d					CALLMONITOR 
286d cd 00 14			call break_point_state  
2870				endm  
# End of macro CALLMONITOR
2870				endif 
2870			 
2870			 
2870			 
2870					; we have a uword so push its name to the stack 
2870			 
2870			;	   	push hl  ; save so we can move to next dict block 
2870			;pop hl 
2870			 
2870					; update opcode to deleted 
2870 3e 03				ld a, WORD_SYS_DELETED 
2872 77					ld (hl), a 
2873			 
2873 23					inc hl  
2874					; skip next ptr 
2874 23					inc hl  
2875 23					inc hl 
2876					; skip len 
2876 23					inc hl 
2877			 
2877					; TODO change parser to skip deleted words but for now mark it out 
2877 3e 5f				ld a, "_" 
2879 77					ld  (hl),a 
287a			 
287a			;		jr .fudone 
287a			; 
287a			;.fnuword:	pop hl 
287a			;		call forth_tok_next 
287a			;		jp .fdouscan  
287a			 
287a			.flunotfound:		  
287a			 
287a			 
287a					 
287a					FORTH_DSP_POP 
287a cd d1 1a			call macro_forth_dsp_pop 
287d				endm 
# End of macro FORTH_DSP_POP
287d			;		ld hl, .luno 
287d			;.fudone:		 pop hl 
287d					NEXTW 
287d c3 8b 1b			jp macro_next 
2880				endm 
# End of macro NEXTW
2880			.NOP: 
2880				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2880 61				db WORD_SYS_CORE+77             
2881 a7 28			dw .COMO            
2883 04				db 3 + 1 
2884 .. 00			db "NOP",0              
2888				endm 
# End of macro CWHEAD
2888			; | NOP (  --  ) Do nothing | DONE 
2888					if DEBUG_FORTH_WORDS_KEY 
2888						DMARK "NOP" 
2888 f5				push af  
2889 3a 9d 28			ld a, (.dmark)  
288c 32 77 fb			ld (debug_mark),a  
288f 3a 9e 28			ld a, (.dmark+1)  
2892 32 78 fb			ld (debug_mark+1),a  
2895 3a 9f 28			ld a, (.dmark+2)  
2898 32 79 fb			ld (debug_mark+2),a  
289b 18 03			jr .pastdmark  
289d ..			.dmark: db "NOP"  
28a0 f1			.pastdmark: pop af  
28a1			endm  
# End of macro DMARK
28a1						CALLMONITOR 
28a1 cd 00 14			call break_point_state  
28a4				endm  
# End of macro CALLMONITOR
28a4					endif 
28a4				       NEXTW 
28a4 c3 8b 1b			jp macro_next 
28a7				endm 
# End of macro NEXTW
28a7			.COMO: 
28a7				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
28a7 6e				db WORD_SYS_CORE+90             
28a8 f9 28			dw .COMC            
28aa 02				db 1 + 1 
28ab .. 00			db "(",0              
28ad				endm 
# End of macro CWHEAD
28ad			; | ( ( -- )  Start of comment | DONE 
28ad			 
28ad			 
28ad 2a 33 f1				ld hl, ( os_tok_ptr) 
28b0 11 f4 28			ld de, .closepar 
28b3					 
28b3					if DEBUG_FORTH_WORDS 
28b3						DMARK ").." 
28b3 f5				push af  
28b4 3a c8 28			ld a, (.dmark)  
28b7 32 77 fb			ld (debug_mark),a  
28ba 3a c9 28			ld a, (.dmark+1)  
28bd 32 78 fb			ld (debug_mark+1),a  
28c0 3a ca 28			ld a, (.dmark+2)  
28c3 32 79 fb			ld (debug_mark+2),a  
28c6 18 03			jr .pastdmark  
28c8 ..			.dmark: db ").."  
28cb f1			.pastdmark: pop af  
28cc			endm  
# End of macro DMARK
28cc						CALLMONITOR 
28cc cd 00 14			call break_point_state  
28cf				endm  
# End of macro CALLMONITOR
28cf					endif 
28cf cd a6 1c			call findnexttok  
28d2			 
28d2					if DEBUG_FORTH_WORDS 
28d2						DMARK "IF5" 
28d2 f5				push af  
28d3 3a e7 28			ld a, (.dmark)  
28d6 32 77 fb			ld (debug_mark),a  
28d9 3a e8 28			ld a, (.dmark+1)  
28dc 32 78 fb			ld (debug_mark+1),a  
28df 3a e9 28			ld a, (.dmark+2)  
28e2 32 79 fb			ld (debug_mark+2),a  
28e5 18 03			jr .pastdmark  
28e7 ..			.dmark: db "IF5"  
28ea f1			.pastdmark: pop af  
28eb			endm  
# End of macro DMARK
28eb						CALLMONITOR 
28eb cd 00 14			call break_point_state  
28ee				endm  
# End of macro CALLMONITOR
28ee					endif 
28ee				; replace below with ) exec using tok_ptr 
28ee 22 33 f1			ld (os_tok_ptr), hl 
28f1 c3 1c 1c			jp exec1 
28f4			 
28f4 .. 00			.closepar:   db ")",0 
28f6			 
28f6				       NEXTW 
28f6 c3 8b 1b			jp macro_next 
28f9				endm 
# End of macro NEXTW
28f9			.COMC: 
28f9				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
28f9 6f				db WORD_SYS_CORE+91             
28fa 02 29			dw .SCRATCH            
28fc 02				db 1 + 1 
28fd .. 00			db ")",0              
28ff				endm 
# End of macro CWHEAD
28ff			; | ) ( -- )  End of comment |  DONE  
28ff				       NEXTW 
28ff c3 8b 1b			jp macro_next 
2902				endm 
# End of macro NEXTW
2902			 
2902			.SCRATCH: 
2902				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2902 6f				db WORD_SYS_CORE+91             
2903 3d 29			dw .INC            
2905 08				db 7 + 1 
2906 .. 00			db "SCRATCH",0              
290e				endm 
# End of macro CWHEAD
290e			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
290e			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
290e			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
290e			; | |  
290e			; | | e.g.    : score $00 scratch ; 
290e			; | |  
290e			; | | $00 score ! 
290e			; | | $01 score +! 
290e			; | |  
290e			; | | e.g.   : varword $0a scratch ;  
290e			; | | 
290e			; | | $8000 varword ! 
290e					if DEBUG_FORTH_WORDS_KEY 
290e						DMARK "SCR" 
290e f5				push af  
290f 3a 23 29			ld a, (.dmark)  
2912 32 77 fb			ld (debug_mark),a  
2915 3a 24 29			ld a, (.dmark+1)  
2918 32 78 fb			ld (debug_mark+1),a  
291b 3a 25 29			ld a, (.dmark+2)  
291e 32 79 fb			ld (debug_mark+2),a  
2921 18 03			jr .pastdmark  
2923 ..			.dmark: db "SCR"  
2926 f1			.pastdmark: pop af  
2927			endm  
# End of macro DMARK
2927						CALLMONITOR 
2927 cd 00 14			call break_point_state  
292a				endm  
# End of macro CALLMONITOR
292a					endif 
292a			 
292a					FORTH_DSP_VALUEHL 
292a cd 35 1a			call macro_dsp_valuehl 
292d				endm 
# End of macro FORTH_DSP_VALUEHL
292d				 
292d					FORTH_DSP_POP 
292d cd d1 1a			call macro_forth_dsp_pop 
2930				endm 
# End of macro FORTH_DSP_POP
2930			 
2930 7d					ld a, l 
2931 21 57 f3				ld hl, os_var_array 
2934 cd 12 0c				call addatohl 
2937			 
2937 cd 9a 19				call forth_push_numhl 
293a			 
293a				       NEXTW 
293a c3 8b 1b			jp macro_next 
293d				endm 
# End of macro NEXTW
293d			 
293d			.INC: 
293d				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
293d 6f				db WORD_SYS_CORE+91             
293e 91 29			dw .DEC            
2940 03				db 2 + 1 
2941 .. 00			db "+!",0              
2944				endm 
# End of macro CWHEAD
2944			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2944					if DEBUG_FORTH_WORDS_KEY 
2944						DMARK "+s_" 
2944 f5				push af  
2945 3a 59 29			ld a, (.dmark)  
2948 32 77 fb			ld (debug_mark),a  
294b 3a 5a 29			ld a, (.dmark+1)  
294e 32 78 fb			ld (debug_mark+1),a  
2951 3a 5b 29			ld a, (.dmark+2)  
2954 32 79 fb			ld (debug_mark+2),a  
2957 18 03			jr .pastdmark  
2959 ..			.dmark: db "+s_"  
295c f1			.pastdmark: pop af  
295d			endm  
# End of macro DMARK
295d						CALLMONITOR 
295d cd 00 14			call break_point_state  
2960				endm  
# End of macro CALLMONITOR
2960					endif 
2960			 
2960					FORTH_DSP_VALUEHL 
2960 cd 35 1a			call macro_dsp_valuehl 
2963				endm 
# End of macro FORTH_DSP_VALUEHL
2963			 
2963 e5					push hl   ; save address 
2964			 
2964					FORTH_DSP_POP 
2964 cd d1 1a			call macro_forth_dsp_pop 
2967				endm 
# End of macro FORTH_DSP_POP
2967			 
2967					FORTH_DSP_VALUEHL 
2967 cd 35 1a			call macro_dsp_valuehl 
296a				endm 
# End of macro FORTH_DSP_VALUEHL
296a			 
296a					FORTH_DSP_POP 
296a cd d1 1a			call macro_forth_dsp_pop 
296d				endm 
# End of macro FORTH_DSP_POP
296d			 
296d					; hl contains value to add to byte at a 
296d				 
296d eb					ex de, hl 
296e			 
296e e1					pop hl 
296f			 
296f					if DEBUG_FORTH_WORDS 
296f						DMARK "INC" 
296f f5				push af  
2970 3a 84 29			ld a, (.dmark)  
2973 32 77 fb			ld (debug_mark),a  
2976 3a 85 29			ld a, (.dmark+1)  
2979 32 78 fb			ld (debug_mark+1),a  
297c 3a 86 29			ld a, (.dmark+2)  
297f 32 79 fb			ld (debug_mark+2),a  
2982 18 03			jr .pastdmark  
2984 ..			.dmark: db "INC"  
2987 f1			.pastdmark: pop af  
2988			endm  
# End of macro DMARK
2988						CALLMONITOR 
2988 cd 00 14			call break_point_state  
298b				endm  
# End of macro CALLMONITOR
298b					endif 
298b			 
298b 7e					ld a,(hl) 
298c 83					add e 
298d 77					ld (hl),a 
298e			 
298e			 
298e			 
298e				       NEXTW 
298e c3 8b 1b			jp macro_next 
2991				endm 
# End of macro NEXTW
2991			 
2991			.DEC: 
2991				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2991 6f				db WORD_SYS_CORE+91             
2992 e2 29			dw .INC2            
2994 03				db 2 + 1 
2995 .. 00			db "-!",0              
2998				endm 
# End of macro CWHEAD
2998			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2998					if DEBUG_FORTH_WORDS_KEY 
2998						DMARK "-s_" 
2998 f5				push af  
2999 3a ad 29			ld a, (.dmark)  
299c 32 77 fb			ld (debug_mark),a  
299f 3a ae 29			ld a, (.dmark+1)  
29a2 32 78 fb			ld (debug_mark+1),a  
29a5 3a af 29			ld a, (.dmark+2)  
29a8 32 79 fb			ld (debug_mark+2),a  
29ab 18 03			jr .pastdmark  
29ad ..			.dmark: db "-s_"  
29b0 f1			.pastdmark: pop af  
29b1			endm  
# End of macro DMARK
29b1						CALLMONITOR 
29b1 cd 00 14			call break_point_state  
29b4				endm  
# End of macro CALLMONITOR
29b4					endif 
29b4			 
29b4					FORTH_DSP_VALUEHL 
29b4 cd 35 1a			call macro_dsp_valuehl 
29b7				endm 
# End of macro FORTH_DSP_VALUEHL
29b7			 
29b7 e5					push hl   ; save address 
29b8			 
29b8					FORTH_DSP_POP 
29b8 cd d1 1a			call macro_forth_dsp_pop 
29bb				endm 
# End of macro FORTH_DSP_POP
29bb			 
29bb					FORTH_DSP_VALUEHL 
29bb cd 35 1a			call macro_dsp_valuehl 
29be				endm 
# End of macro FORTH_DSP_VALUEHL
29be			 
29be					; hl contains value to add to byte at a 
29be				 
29be eb					ex de, hl 
29bf			 
29bf e1					pop hl 
29c0			 
29c0					if DEBUG_FORTH_WORDS 
29c0						DMARK "DEC" 
29c0 f5				push af  
29c1 3a d5 29			ld a, (.dmark)  
29c4 32 77 fb			ld (debug_mark),a  
29c7 3a d6 29			ld a, (.dmark+1)  
29ca 32 78 fb			ld (debug_mark+1),a  
29cd 3a d7 29			ld a, (.dmark+2)  
29d0 32 79 fb			ld (debug_mark+2),a  
29d3 18 03			jr .pastdmark  
29d5 ..			.dmark: db "DEC"  
29d8 f1			.pastdmark: pop af  
29d9			endm  
# End of macro DMARK
29d9						CALLMONITOR 
29d9 cd 00 14			call break_point_state  
29dc				endm  
# End of macro CALLMONITOR
29dc					endif 
29dc			 
29dc 7e					ld a,(hl) 
29dd 93					sub e 
29de 77					ld (hl),a 
29df			 
29df			 
29df			 
29df				       NEXTW 
29df c3 8b 1b			jp macro_next 
29e2				endm 
# End of macro NEXTW
29e2			 
29e2			.INC2: 
29e2				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
29e2 6f				db WORD_SYS_CORE+91             
29e3 8c 2a			dw .DEC2            
29e5 04				db 3 + 1 
29e6 .. 00			db "+2!",0              
29ea				endm 
# End of macro CWHEAD
29ea			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
29ea			 
29ea					if DEBUG_FORTH_WORDS_KEY 
29ea						DMARK "+2s" 
29ea f5				push af  
29eb 3a ff 29			ld a, (.dmark)  
29ee 32 77 fb			ld (debug_mark),a  
29f1 3a 00 2a			ld a, (.dmark+1)  
29f4 32 78 fb			ld (debug_mark+1),a  
29f7 3a 01 2a			ld a, (.dmark+2)  
29fa 32 79 fb			ld (debug_mark+2),a  
29fd 18 03			jr .pastdmark  
29ff ..			.dmark: db "+2s"  
2a02 f1			.pastdmark: pop af  
2a03			endm  
# End of macro DMARK
2a03						CALLMONITOR 
2a03 cd 00 14			call break_point_state  
2a06				endm  
# End of macro CALLMONITOR
2a06					endif 
2a06			 
2a06					; Address 
2a06			 
2a06					FORTH_DSP_VALUEHL 
2a06 cd 35 1a			call macro_dsp_valuehl 
2a09				endm 
# End of macro FORTH_DSP_VALUEHL
2a09			 
2a09 e5					push hl    ; save address 
2a0a			 
2a0a					; load content into de 
2a0a			 
2a0a 5e					ld e,(hl) 
2a0b 23					inc hl 
2a0c 56					ld d, (hl) 
2a0d			 
2a0d					if DEBUG_FORTH_WORDS 
2a0d						DMARK "+2a" 
2a0d f5				push af  
2a0e 3a 22 2a			ld a, (.dmark)  
2a11 32 77 fb			ld (debug_mark),a  
2a14 3a 23 2a			ld a, (.dmark+1)  
2a17 32 78 fb			ld (debug_mark+1),a  
2a1a 3a 24 2a			ld a, (.dmark+2)  
2a1d 32 79 fb			ld (debug_mark+2),a  
2a20 18 03			jr .pastdmark  
2a22 ..			.dmark: db "+2a"  
2a25 f1			.pastdmark: pop af  
2a26			endm  
# End of macro DMARK
2a26						CALLMONITOR 
2a26 cd 00 14			call break_point_state  
2a29				endm  
# End of macro CALLMONITOR
2a29					endif 
2a29			 
2a29					FORTH_DSP_POP 
2a29 cd d1 1a			call macro_forth_dsp_pop 
2a2c				endm 
# End of macro FORTH_DSP_POP
2a2c			 
2a2c					; Get value to add 
2a2c			 
2a2c					FORTH_DSP_VALUE 
2a2c cd 1e 1a			call macro_forth_dsp_value 
2a2f				endm 
# End of macro FORTH_DSP_VALUE
2a2f			 
2a2f					if DEBUG_FORTH_WORDS 
2a2f						DMARK "+2v" 
2a2f f5				push af  
2a30 3a 44 2a			ld a, (.dmark)  
2a33 32 77 fb			ld (debug_mark),a  
2a36 3a 45 2a			ld a, (.dmark+1)  
2a39 32 78 fb			ld (debug_mark+1),a  
2a3c 3a 46 2a			ld a, (.dmark+2)  
2a3f 32 79 fb			ld (debug_mark+2),a  
2a42 18 03			jr .pastdmark  
2a44 ..			.dmark: db "+2v"  
2a47 f1			.pastdmark: pop af  
2a48			endm  
# End of macro DMARK
2a48						CALLMONITOR 
2a48 cd 00 14			call break_point_state  
2a4b				endm  
# End of macro CALLMONITOR
2a4b					endif 
2a4b			 
2a4b 19					add hl, de 
2a4c			 
2a4c					if DEBUG_FORTH_WORDS 
2a4c						DMARK "+2+" 
2a4c f5				push af  
2a4d 3a 61 2a			ld a, (.dmark)  
2a50 32 77 fb			ld (debug_mark),a  
2a53 3a 62 2a			ld a, (.dmark+1)  
2a56 32 78 fb			ld (debug_mark+1),a  
2a59 3a 63 2a			ld a, (.dmark+2)  
2a5c 32 79 fb			ld (debug_mark+2),a  
2a5f 18 03			jr .pastdmark  
2a61 ..			.dmark: db "+2+"  
2a64 f1			.pastdmark: pop af  
2a65			endm  
# End of macro DMARK
2a65						CALLMONITOR 
2a65 cd 00 14			call break_point_state  
2a68				endm  
# End of macro CALLMONITOR
2a68					endif 
2a68			 
2a68					; move result to de 
2a68			 
2a68 eb					ex de, hl 
2a69			 
2a69					; Address 
2a69			 
2a69 e1					pop hl 
2a6a			 
2a6a					; save it back 
2a6a			 
2a6a 73					ld (hl), e 
2a6b 23					inc hl 
2a6c 72					ld (hl), d 
2a6d			 
2a6d					if DEBUG_FORTH_WORDS 
2a6d						DMARK "+2e" 
2a6d f5				push af  
2a6e 3a 82 2a			ld a, (.dmark)  
2a71 32 77 fb			ld (debug_mark),a  
2a74 3a 83 2a			ld a, (.dmark+1)  
2a77 32 78 fb			ld (debug_mark+1),a  
2a7a 3a 84 2a			ld a, (.dmark+2)  
2a7d 32 79 fb			ld (debug_mark+2),a  
2a80 18 03			jr .pastdmark  
2a82 ..			.dmark: db "+2e"  
2a85 f1			.pastdmark: pop af  
2a86			endm  
# End of macro DMARK
2a86						CALLMONITOR 
2a86 cd 00 14			call break_point_state  
2a89				endm  
# End of macro CALLMONITOR
2a89					endif 
2a89			 
2a89			 
2a89			 
2a89			 
2a89			 
2a89				       NEXTW 
2a89 c3 8b 1b			jp macro_next 
2a8c				endm 
# End of macro NEXTW
2a8c			 
2a8c			.DEC2: 
2a8c				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2a8c 6f				db WORD_SYS_CORE+91             
2a8d 38 2b			dw .GET2            
2a8f 04				db 3 + 1 
2a90 .. 00			db "-2!",0              
2a94				endm 
# End of macro CWHEAD
2a94			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2a94			 
2a94			 
2a94					if DEBUG_FORTH_WORDS_KEY 
2a94						DMARK "-2s" 
2a94 f5				push af  
2a95 3a a9 2a			ld a, (.dmark)  
2a98 32 77 fb			ld (debug_mark),a  
2a9b 3a aa 2a			ld a, (.dmark+1)  
2a9e 32 78 fb			ld (debug_mark+1),a  
2aa1 3a ab 2a			ld a, (.dmark+2)  
2aa4 32 79 fb			ld (debug_mark+2),a  
2aa7 18 03			jr .pastdmark  
2aa9 ..			.dmark: db "-2s"  
2aac f1			.pastdmark: pop af  
2aad			endm  
# End of macro DMARK
2aad						CALLMONITOR 
2aad cd 00 14			call break_point_state  
2ab0				endm  
# End of macro CALLMONITOR
2ab0					endif 
2ab0			 
2ab0					; Address 
2ab0			 
2ab0					FORTH_DSP_VALUEHL 
2ab0 cd 35 1a			call macro_dsp_valuehl 
2ab3				endm 
# End of macro FORTH_DSP_VALUEHL
2ab3			 
2ab3 e5					push hl    ; save address 
2ab4			 
2ab4					; load content into de 
2ab4			 
2ab4 5e					ld e,(hl) 
2ab5 23					inc hl 
2ab6 56					ld d, (hl) 
2ab7			 
2ab7					if DEBUG_FORTH_WORDS 
2ab7						DMARK "-2a" 
2ab7 f5				push af  
2ab8 3a cc 2a			ld a, (.dmark)  
2abb 32 77 fb			ld (debug_mark),a  
2abe 3a cd 2a			ld a, (.dmark+1)  
2ac1 32 78 fb			ld (debug_mark+1),a  
2ac4 3a ce 2a			ld a, (.dmark+2)  
2ac7 32 79 fb			ld (debug_mark+2),a  
2aca 18 03			jr .pastdmark  
2acc ..			.dmark: db "-2a"  
2acf f1			.pastdmark: pop af  
2ad0			endm  
# End of macro DMARK
2ad0						CALLMONITOR 
2ad0 cd 00 14			call break_point_state  
2ad3				endm  
# End of macro CALLMONITOR
2ad3					endif 
2ad3			 
2ad3					FORTH_DSP_POP 
2ad3 cd d1 1a			call macro_forth_dsp_pop 
2ad6				endm 
# End of macro FORTH_DSP_POP
2ad6			 
2ad6					; Get value to remove 
2ad6			 
2ad6					FORTH_DSP_VALUE 
2ad6 cd 1e 1a			call macro_forth_dsp_value 
2ad9				endm 
# End of macro FORTH_DSP_VALUE
2ad9			 
2ad9					if DEBUG_FORTH_WORDS 
2ad9						DMARK "-2v" 
2ad9 f5				push af  
2ada 3a ee 2a			ld a, (.dmark)  
2add 32 77 fb			ld (debug_mark),a  
2ae0 3a ef 2a			ld a, (.dmark+1)  
2ae3 32 78 fb			ld (debug_mark+1),a  
2ae6 3a f0 2a			ld a, (.dmark+2)  
2ae9 32 79 fb			ld (debug_mark+2),a  
2aec 18 03			jr .pastdmark  
2aee ..			.dmark: db "-2v"  
2af1 f1			.pastdmark: pop af  
2af2			endm  
# End of macro DMARK
2af2						CALLMONITOR 
2af2 cd 00 14			call break_point_state  
2af5				endm  
# End of macro CALLMONITOR
2af5					endif 
2af5			 
2af5 eb					ex de, hl 
2af6 ed 52				sbc hl, de 
2af8			 
2af8					if DEBUG_FORTH_WORDS 
2af8						DMARK "-2d" 
2af8 f5				push af  
2af9 3a 0d 2b			ld a, (.dmark)  
2afc 32 77 fb			ld (debug_mark),a  
2aff 3a 0e 2b			ld a, (.dmark+1)  
2b02 32 78 fb			ld (debug_mark+1),a  
2b05 3a 0f 2b			ld a, (.dmark+2)  
2b08 32 79 fb			ld (debug_mark+2),a  
2b0b 18 03			jr .pastdmark  
2b0d ..			.dmark: db "-2d"  
2b10 f1			.pastdmark: pop af  
2b11			endm  
# End of macro DMARK
2b11						CALLMONITOR 
2b11 cd 00 14			call break_point_state  
2b14				endm  
# End of macro CALLMONITOR
2b14					endif 
2b14			 
2b14					; move result to de 
2b14			 
2b14 eb					ex de, hl 
2b15			 
2b15					; Address 
2b15			 
2b15 e1					pop hl 
2b16			 
2b16					; save it back 
2b16			 
2b16 73					ld (hl), e 
2b17 23					inc hl 
2b18 72					ld (hl), d 
2b19			 
2b19					if DEBUG_FORTH_WORDS 
2b19						DMARK "-2e" 
2b19 f5				push af  
2b1a 3a 2e 2b			ld a, (.dmark)  
2b1d 32 77 fb			ld (debug_mark),a  
2b20 3a 2f 2b			ld a, (.dmark+1)  
2b23 32 78 fb			ld (debug_mark+1),a  
2b26 3a 30 2b			ld a, (.dmark+2)  
2b29 32 79 fb			ld (debug_mark+2),a  
2b2c 18 03			jr .pastdmark  
2b2e ..			.dmark: db "-2e"  
2b31 f1			.pastdmark: pop af  
2b32			endm  
# End of macro DMARK
2b32						CALLMONITOR 
2b32 cd 00 14			call break_point_state  
2b35				endm  
# End of macro CALLMONITOR
2b35					endif 
2b35			 
2b35			 
2b35			 
2b35			 
2b35			 
2b35				       NEXTW 
2b35 c3 8b 1b			jp macro_next 
2b38				endm 
# End of macro NEXTW
2b38			.GET2: 
2b38				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2b38 6f				db WORD_SYS_CORE+91             
2b39 68 2b			dw .BANG2            
2b3b 03				db 2 + 1 
2b3c .. 00			db "2@",0              
2b3f				endm 
# End of macro CWHEAD
2b3f			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2b3f					if DEBUG_FORTH_WORDS_KEY 
2b3f						DMARK "2A_" 
2b3f f5				push af  
2b40 3a 54 2b			ld a, (.dmark)  
2b43 32 77 fb			ld (debug_mark),a  
2b46 3a 55 2b			ld a, (.dmark+1)  
2b49 32 78 fb			ld (debug_mark+1),a  
2b4c 3a 56 2b			ld a, (.dmark+2)  
2b4f 32 79 fb			ld (debug_mark+2),a  
2b52 18 03			jr .pastdmark  
2b54 ..			.dmark: db "2A_"  
2b57 f1			.pastdmark: pop af  
2b58			endm  
# End of macro DMARK
2b58						CALLMONITOR 
2b58 cd 00 14			call break_point_state  
2b5b				endm  
# End of macro CALLMONITOR
2b5b					endif 
2b5b			 
2b5b					FORTH_DSP_VALUEHL 
2b5b cd 35 1a			call macro_dsp_valuehl 
2b5e				endm 
# End of macro FORTH_DSP_VALUEHL
2b5e			 
2b5e 5e					ld e, (hl) 
2b5f 23					inc hl 
2b60 56					ld d, (hl) 
2b61			 
2b61 eb					ex de, hl 
2b62			 
2b62 cd 9a 19				call forth_push_numhl 
2b65			 
2b65				       NEXTW 
2b65 c3 8b 1b			jp macro_next 
2b68				endm 
# End of macro NEXTW
2b68			.BANG2: 
2b68				CWHEAD .ENDCORE 91 "2!" 2 WORD_FLAG_CODE 
2b68 6f				db WORD_SYS_CORE+91             
2b69 a0 2b			dw .ENDCORE            
2b6b 03				db 2 + 1 
2b6c .. 00			db "2!",0              
2b6f				endm 
# End of macro CWHEAD
2b6f			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2b6f					if DEBUG_FORTH_WORDS_KEY 
2b6f						DMARK "2S_" 
2b6f f5				push af  
2b70 3a 84 2b			ld a, (.dmark)  
2b73 32 77 fb			ld (debug_mark),a  
2b76 3a 85 2b			ld a, (.dmark+1)  
2b79 32 78 fb			ld (debug_mark+1),a  
2b7c 3a 86 2b			ld a, (.dmark+2)  
2b7f 32 79 fb			ld (debug_mark+2),a  
2b82 18 03			jr .pastdmark  
2b84 ..			.dmark: db "2S_"  
2b87 f1			.pastdmark: pop af  
2b88			endm  
# End of macro DMARK
2b88						CALLMONITOR 
2b88 cd 00 14			call break_point_state  
2b8b				endm  
# End of macro CALLMONITOR
2b8b					endif 
2b8b			 
2b8b					FORTH_DSP_VALUEHL 
2b8b cd 35 1a			call macro_dsp_valuehl 
2b8e				endm 
# End of macro FORTH_DSP_VALUEHL
2b8e			 
2b8e e5					push hl   ; save address 
2b8f			 
2b8f			 
2b8f					FORTH_DSP_POP 
2b8f cd d1 1a			call macro_forth_dsp_pop 
2b92				endm 
# End of macro FORTH_DSP_POP
2b92			 
2b92					 
2b92					FORTH_DSP_VALUEHL 
2b92 cd 35 1a			call macro_dsp_valuehl 
2b95				endm 
# End of macro FORTH_DSP_VALUEHL
2b95			 
2b95					FORTH_DSP_POP 
2b95 cd d1 1a			call macro_forth_dsp_pop 
2b98				endm 
# End of macro FORTH_DSP_POP
2b98			 
2b98 eb					ex de, hl    ; value now in de 
2b99			 
2b99 e1					pop hl 
2b9a			 
2b9a 73					ld (hl), e 
2b9b			 
2b9b 23					inc hl 
2b9c			 
2b9c 72					ld (hl), d 
2b9d			 
2b9d			 
2b9d				       NEXTW 
2b9d c3 8b 1b			jp macro_next 
2ba0				endm 
# End of macro NEXTW
2ba0			.ENDCORE: 
2ba0			 
2ba0			; eof 
2ba0			 
2ba0			 
# End of file forth_words_core.asm
2ba0			include "forth_words_flow.asm" 
2ba0			 
2ba0			; | ## Program Flow Words 
2ba0			 
2ba0			.IF: 
2ba0				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2ba0 1e				db WORD_SYS_CORE+10             
2ba1 95 2c			dw .THEN            
2ba3 03				db 2 + 1 
2ba4 .. 00			db "IF",0              
2ba7				endm 
# End of macro CWHEAD
2ba7			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2ba7			; 
2ba7					if DEBUG_FORTH_WORDS_KEY 
2ba7						DMARK "IF." 
2ba7 f5				push af  
2ba8 3a bc 2b			ld a, (.dmark)  
2bab 32 77 fb			ld (debug_mark),a  
2bae 3a bd 2b			ld a, (.dmark+1)  
2bb1 32 78 fb			ld (debug_mark+1),a  
2bb4 3a be 2b			ld a, (.dmark+2)  
2bb7 32 79 fb			ld (debug_mark+2),a  
2bba 18 03			jr .pastdmark  
2bbc ..			.dmark: db "IF."  
2bbf f1			.pastdmark: pop af  
2bc0			endm  
# End of macro DMARK
2bc0						CALLMONITOR 
2bc0 cd 00 14			call break_point_state  
2bc3				endm  
# End of macro CALLMONITOR
2bc3					endif 
2bc3			; eval TOS 
2bc3			 
2bc3				FORTH_DSP_VALUEHL 
2bc3 cd 35 1a			call macro_dsp_valuehl 
2bc6				endm 
# End of macro FORTH_DSP_VALUEHL
2bc6			 
2bc6			;	push hl 
2bc6				FORTH_DSP_POP 
2bc6 cd d1 1a			call macro_forth_dsp_pop 
2bc9				endm 
# End of macro FORTH_DSP_POP
2bc9			;	pop hl 
2bc9			 
2bc9					if DEBUG_FORTH_WORDS 
2bc9						DMARK "IF1" 
2bc9 f5				push af  
2bca 3a de 2b			ld a, (.dmark)  
2bcd 32 77 fb			ld (debug_mark),a  
2bd0 3a df 2b			ld a, (.dmark+1)  
2bd3 32 78 fb			ld (debug_mark+1),a  
2bd6 3a e0 2b			ld a, (.dmark+2)  
2bd9 32 79 fb			ld (debug_mark+2),a  
2bdc 18 03			jr .pastdmark  
2bde ..			.dmark: db "IF1"  
2be1 f1			.pastdmark: pop af  
2be2			endm  
# End of macro DMARK
2be2						CALLMONITOR 
2be2 cd 00 14			call break_point_state  
2be5				endm  
# End of macro CALLMONITOR
2be5					endif 
2be5 b7				or a        ; clear carry flag 
2be6 11 00 00			ld de, 0 
2be9 eb				ex de,hl 
2bea ed 52			sbc hl, de 
2bec c2 76 2c			jp nz, .iftrue 
2bef			 
2bef					if DEBUG_FORTH_WORDS 
2bef						DMARK "IF2" 
2bef f5				push af  
2bf0 3a 04 2c			ld a, (.dmark)  
2bf3 32 77 fb			ld (debug_mark),a  
2bf6 3a 05 2c			ld a, (.dmark+1)  
2bf9 32 78 fb			ld (debug_mark+1),a  
2bfc 3a 06 2c			ld a, (.dmark+2)  
2bff 32 79 fb			ld (debug_mark+2),a  
2c02 18 03			jr .pastdmark  
2c04 ..			.dmark: db "IF2"  
2c07 f1			.pastdmark: pop af  
2c08			endm  
# End of macro DMARK
2c08						CALLMONITOR 
2c08 cd 00 14			call break_point_state  
2c0b				endm  
# End of macro CALLMONITOR
2c0b					endif 
2c0b			 
2c0b			; if not true then skip to THEN 
2c0b			 
2c0b				; TODO get tok_ptr 
2c0b				; TODO consume toks until we get to THEN 
2c0b			 
2c0b 2a 33 f1			ld hl, (os_tok_ptr) 
2c0e					if DEBUG_FORTH_WORDS 
2c0e						DMARK "IF3" 
2c0e f5				push af  
2c0f 3a 23 2c			ld a, (.dmark)  
2c12 32 77 fb			ld (debug_mark),a  
2c15 3a 24 2c			ld a, (.dmark+1)  
2c18 32 78 fb			ld (debug_mark+1),a  
2c1b 3a 25 2c			ld a, (.dmark+2)  
2c1e 32 79 fb			ld (debug_mark+2),a  
2c21 18 03			jr .pastdmark  
2c23 ..			.dmark: db "IF3"  
2c26 f1			.pastdmark: pop af  
2c27			endm  
# End of macro DMARK
2c27						CALLMONITOR 
2c27 cd 00 14			call break_point_state  
2c2a				endm  
# End of macro CALLMONITOR
2c2a						 
2c2a					endif 
2c2a 11 71 2c			ld de, .ifthen 
2c2d					if DEBUG_FORTH_WORDS 
2c2d						DMARK "IF4" 
2c2d f5				push af  
2c2e 3a 42 2c			ld a, (.dmark)  
2c31 32 77 fb			ld (debug_mark),a  
2c34 3a 43 2c			ld a, (.dmark+1)  
2c37 32 78 fb			ld (debug_mark+1),a  
2c3a 3a 44 2c			ld a, (.dmark+2)  
2c3d 32 79 fb			ld (debug_mark+2),a  
2c40 18 03			jr .pastdmark  
2c42 ..			.dmark: db "IF4"  
2c45 f1			.pastdmark: pop af  
2c46			endm  
# End of macro DMARK
2c46						CALLMONITOR 
2c46 cd 00 14			call break_point_state  
2c49				endm  
# End of macro CALLMONITOR
2c49					endif 
2c49 cd a6 1c			call findnexttok  
2c4c			 
2c4c					if DEBUG_FORTH_WORDS 
2c4c						DMARK "IF5" 
2c4c f5				push af  
2c4d 3a 61 2c			ld a, (.dmark)  
2c50 32 77 fb			ld (debug_mark),a  
2c53 3a 62 2c			ld a, (.dmark+1)  
2c56 32 78 fb			ld (debug_mark+1),a  
2c59 3a 63 2c			ld a, (.dmark+2)  
2c5c 32 79 fb			ld (debug_mark+2),a  
2c5f 18 03			jr .pastdmark  
2c61 ..			.dmark: db "IF5"  
2c64 f1			.pastdmark: pop af  
2c65			endm  
# End of macro DMARK
2c65						CALLMONITOR 
2c65 cd 00 14			call break_point_state  
2c68				endm  
# End of macro CALLMONITOR
2c68					endif 
2c68				; TODO replace below with ; exec using tok_ptr 
2c68 22 33 f1			ld (os_tok_ptr), hl 
2c6b c3 1c 1c			jp exec1 
2c6e				NEXTW 
2c6e c3 8b 1b			jp macro_next 
2c71				endm 
# End of macro NEXTW
2c71			 
2c71 .. 00		.ifthen:  db "THEN",0 
2c76			 
2c76			.iftrue:		 
2c76				; Exec next words normally 
2c76			 
2c76				; if true then exec following IF as normal 
2c76					if DEBUG_FORTH_WORDS 
2c76						DMARK "IFT" 
2c76 f5				push af  
2c77 3a 8b 2c			ld a, (.dmark)  
2c7a 32 77 fb			ld (debug_mark),a  
2c7d 3a 8c 2c			ld a, (.dmark+1)  
2c80 32 78 fb			ld (debug_mark+1),a  
2c83 3a 8d 2c			ld a, (.dmark+2)  
2c86 32 79 fb			ld (debug_mark+2),a  
2c89 18 03			jr .pastdmark  
2c8b ..			.dmark: db "IFT"  
2c8e f1			.pastdmark: pop af  
2c8f			endm  
# End of macro DMARK
2c8f						CALLMONITOR 
2c8f cd 00 14			call break_point_state  
2c92				endm  
# End of macro CALLMONITOR
2c92					endif 
2c92			 
2c92					NEXTW 
2c92 c3 8b 1b			jp macro_next 
2c95				endm 
# End of macro NEXTW
2c95			.THEN: 
2c95				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
2c95 1f				db WORD_SYS_CORE+11             
2c96 bd 2c			dw .ELSE            
2c98 05				db 4 + 1 
2c99 .. 00			db "THEN",0              
2c9e				endm 
# End of macro CWHEAD
2c9e			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
2c9e					if DEBUG_FORTH_WORDS_KEY 
2c9e						DMARK "THN" 
2c9e f5				push af  
2c9f 3a b3 2c			ld a, (.dmark)  
2ca2 32 77 fb			ld (debug_mark),a  
2ca5 3a b4 2c			ld a, (.dmark+1)  
2ca8 32 78 fb			ld (debug_mark+1),a  
2cab 3a b5 2c			ld a, (.dmark+2)  
2cae 32 79 fb			ld (debug_mark+2),a  
2cb1 18 03			jr .pastdmark  
2cb3 ..			.dmark: db "THN"  
2cb6 f1			.pastdmark: pop af  
2cb7			endm  
# End of macro DMARK
2cb7						CALLMONITOR 
2cb7 cd 00 14			call break_point_state  
2cba				endm  
# End of macro CALLMONITOR
2cba					endif 
2cba					NEXTW 
2cba c3 8b 1b			jp macro_next 
2cbd				endm 
# End of macro NEXTW
2cbd			.ELSE: 
2cbd				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
2cbd 20				db WORD_SYS_CORE+12             
2cbe e5 2c			dw .DO            
2cc0 03				db 2 + 1 
2cc1 .. 00			db "ELSE",0              
2cc6				endm 
# End of macro CWHEAD
2cc6			; | ELSE ( -- ) Not supported - does nothing | TODO 
2cc6			 
2cc6					if DEBUG_FORTH_WORDS_KEY 
2cc6						DMARK "ELS" 
2cc6 f5				push af  
2cc7 3a db 2c			ld a, (.dmark)  
2cca 32 77 fb			ld (debug_mark),a  
2ccd 3a dc 2c			ld a, (.dmark+1)  
2cd0 32 78 fb			ld (debug_mark+1),a  
2cd3 3a dd 2c			ld a, (.dmark+2)  
2cd6 32 79 fb			ld (debug_mark+2),a  
2cd9 18 03			jr .pastdmark  
2cdb ..			.dmark: db "ELS"  
2cde f1			.pastdmark: pop af  
2cdf			endm  
# End of macro DMARK
2cdf						CALLMONITOR 
2cdf cd 00 14			call break_point_state  
2ce2				endm  
# End of macro CALLMONITOR
2ce2					endif 
2ce2			 
2ce2			 
2ce2					NEXTW 
2ce2 c3 8b 1b			jp macro_next 
2ce5				endm 
# End of macro NEXTW
2ce5			.DO: 
2ce5				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
2ce5 21				db WORD_SYS_CORE+13             
2ce6 0c 2e			dw .LOOP            
2ce8 03				db 2 + 1 
2ce9 .. 00			db "DO",0              
2cec				endm 
# End of macro CWHEAD
2cec			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
2cec			 
2cec					if DEBUG_FORTH_WORDS_KEY 
2cec						DMARK "DO." 
2cec f5				push af  
2ced 3a 01 2d			ld a, (.dmark)  
2cf0 32 77 fb			ld (debug_mark),a  
2cf3 3a 02 2d			ld a, (.dmark+1)  
2cf6 32 78 fb			ld (debug_mark+1),a  
2cf9 3a 03 2d			ld a, (.dmark+2)  
2cfc 32 79 fb			ld (debug_mark+2),a  
2cff 18 03			jr .pastdmark  
2d01 ..			.dmark: db "DO."  
2d04 f1			.pastdmark: pop af  
2d05			endm  
# End of macro DMARK
2d05						CALLMONITOR 
2d05 cd 00 14			call break_point_state  
2d08				endm  
# End of macro CALLMONITOR
2d08					endif 
2d08			;  push pc to rsp stack past the DO 
2d08			 
2d08 2a 33 f1				ld hl, (os_tok_ptr) 
2d0b 23					inc hl   ; D 
2d0c 23					inc hl  ; O 
2d0d 23					inc hl   ; null 
2d0e					if DEBUG_FORTH_WORDS 
2d0e						DMARK "DO2" 
2d0e f5				push af  
2d0f 3a 23 2d			ld a, (.dmark)  
2d12 32 77 fb			ld (debug_mark),a  
2d15 3a 24 2d			ld a, (.dmark+1)  
2d18 32 78 fb			ld (debug_mark+1),a  
2d1b 3a 25 2d			ld a, (.dmark+2)  
2d1e 32 79 fb			ld (debug_mark+2),a  
2d21 18 03			jr .pastdmark  
2d23 ..			.dmark: db "DO2"  
2d26 f1			.pastdmark: pop af  
2d27			endm  
# End of macro DMARK
2d27						CALLMONITOR 
2d27 cd 00 14			call break_point_state  
2d2a				endm  
# End of macro CALLMONITOR
2d2a					endif 
2d2a					FORTH_RSP_NEXT 
2d2a cd 41 19			call macro_forth_rsp_next 
2d2d				endm 
# End of macro FORTH_RSP_NEXT
2d2d					if DEBUG_FORTH_WORDS 
2d2d						DMARK "DO3" 
2d2d f5				push af  
2d2e 3a 42 2d			ld a, (.dmark)  
2d31 32 77 fb			ld (debug_mark),a  
2d34 3a 43 2d			ld a, (.dmark+1)  
2d37 32 78 fb			ld (debug_mark+1),a  
2d3a 3a 44 2d			ld a, (.dmark+2)  
2d3d 32 79 fb			ld (debug_mark+2),a  
2d40 18 03			jr .pastdmark  
2d42 ..			.dmark: db "DO3"  
2d45 f1			.pastdmark: pop af  
2d46			endm  
# End of macro DMARK
2d46						CALLMONITOR 
2d46 cd 00 14			call break_point_state  
2d49				endm  
# End of macro CALLMONITOR
2d49					endif 
2d49			 
2d49					;if DEBUG_FORTH_WORDS 
2d49				;		push hl 
2d49			;		endif  
2d49			 
2d49			; get counters from data stack 
2d49			 
2d49			 
2d49					FORTH_DSP_VALUEHL 
2d49 cd 35 1a			call macro_dsp_valuehl 
2d4c				endm 
# End of macro FORTH_DSP_VALUEHL
2d4c e5					push hl		 ; hl now has starting counter which needs to be tos 
2d4d			 
2d4d					if DEBUG_FORTH_WORDS 
2d4d						DMARK "DO4" 
2d4d f5				push af  
2d4e 3a 62 2d			ld a, (.dmark)  
2d51 32 77 fb			ld (debug_mark),a  
2d54 3a 63 2d			ld a, (.dmark+1)  
2d57 32 78 fb			ld (debug_mark+1),a  
2d5a 3a 64 2d			ld a, (.dmark+2)  
2d5d 32 79 fb			ld (debug_mark+2),a  
2d60 18 03			jr .pastdmark  
2d62 ..			.dmark: db "DO4"  
2d65 f1			.pastdmark: pop af  
2d66			endm  
# End of macro DMARK
2d66						CALLMONITOR 
2d66 cd 00 14			call break_point_state  
2d69				endm  
# End of macro CALLMONITOR
2d69					endif 
2d69					FORTH_DSP_POP 
2d69 cd d1 1a			call macro_forth_dsp_pop 
2d6c				endm 
# End of macro FORTH_DSP_POP
2d6c			 
2d6c					if DEBUG_FORTH_WORDS 
2d6c						DMARK "DO5" 
2d6c f5				push af  
2d6d 3a 81 2d			ld a, (.dmark)  
2d70 32 77 fb			ld (debug_mark),a  
2d73 3a 82 2d			ld a, (.dmark+1)  
2d76 32 78 fb			ld (debug_mark+1),a  
2d79 3a 83 2d			ld a, (.dmark+2)  
2d7c 32 79 fb			ld (debug_mark+2),a  
2d7f 18 03			jr .pastdmark  
2d81 ..			.dmark: db "DO5"  
2d84 f1			.pastdmark: pop af  
2d85			endm  
# End of macro DMARK
2d85						CALLMONITOR 
2d85 cd 00 14			call break_point_state  
2d88				endm  
# End of macro CALLMONITOR
2d88					endif 
2d88			 
2d88					FORTH_DSP_VALUEHL 
2d88 cd 35 1a			call macro_dsp_valuehl 
2d8b				endm 
# End of macro FORTH_DSP_VALUEHL
2d8b			;		push hl		 ; hl now has starting limit counter 
2d8b			 
2d8b					if DEBUG_FORTH_WORDS 
2d8b						DMARK "DO6" 
2d8b f5				push af  
2d8c 3a a0 2d			ld a, (.dmark)  
2d8f 32 77 fb			ld (debug_mark),a  
2d92 3a a1 2d			ld a, (.dmark+1)  
2d95 32 78 fb			ld (debug_mark+1),a  
2d98 3a a2 2d			ld a, (.dmark+2)  
2d9b 32 79 fb			ld (debug_mark+2),a  
2d9e 18 03			jr .pastdmark  
2da0 ..			.dmark: db "DO6"  
2da3 f1			.pastdmark: pop af  
2da4			endm  
# End of macro DMARK
2da4						CALLMONITOR 
2da4 cd 00 14			call break_point_state  
2da7				endm  
# End of macro CALLMONITOR
2da7					endif 
2da7					FORTH_DSP_POP 
2da7 cd d1 1a			call macro_forth_dsp_pop 
2daa				endm 
# End of macro FORTH_DSP_POP
2daa			 
2daa			; put counters on the loop stack 
2daa			 
2daa			;		pop hl			 ; limit counter 
2daa d1					pop de			; start counter 
2dab			 
2dab					; push limit counter 
2dab			 
2dab					if DEBUG_FORTH_WORDS 
2dab						DMARK "DO7" 
2dab f5				push af  
2dac 3a c0 2d			ld a, (.dmark)  
2daf 32 77 fb			ld (debug_mark),a  
2db2 3a c1 2d			ld a, (.dmark+1)  
2db5 32 78 fb			ld (debug_mark+1),a  
2db8 3a c2 2d			ld a, (.dmark+2)  
2dbb 32 79 fb			ld (debug_mark+2),a  
2dbe 18 03			jr .pastdmark  
2dc0 ..			.dmark: db "DO7"  
2dc3 f1			.pastdmark: pop af  
2dc4			endm  
# End of macro DMARK
2dc4						CALLMONITOR 
2dc4 cd 00 14			call break_point_state  
2dc7				endm  
# End of macro CALLMONITOR
2dc7					endif 
2dc7					FORTH_LOOP_NEXT 
2dc7 cd 4a 1a			call macro_forth_loop_next 
2dca				endm 
# End of macro FORTH_LOOP_NEXT
2dca			 
2dca					; push start counter 
2dca			 
2dca eb					ex de, hl 
2dcb					if DEBUG_FORTH_WORDS 
2dcb						DMARK "DO7" 
2dcb f5				push af  
2dcc 3a e0 2d			ld a, (.dmark)  
2dcf 32 77 fb			ld (debug_mark),a  
2dd2 3a e1 2d			ld a, (.dmark+1)  
2dd5 32 78 fb			ld (debug_mark+1),a  
2dd8 3a e2 2d			ld a, (.dmark+2)  
2ddb 32 79 fb			ld (debug_mark+2),a  
2dde 18 03			jr .pastdmark  
2de0 ..			.dmark: db "DO7"  
2de3 f1			.pastdmark: pop af  
2de4			endm  
# End of macro DMARK
2de4						CALLMONITOR 
2de4 cd 00 14			call break_point_state  
2de7				endm  
# End of macro CALLMONITOR
2de7					endif 
2de7					FORTH_LOOP_NEXT 
2de7 cd 4a 1a			call macro_forth_loop_next 
2dea				endm 
# End of macro FORTH_LOOP_NEXT
2dea			 
2dea			 
2dea					; init first round of I counter 
2dea			 
2dea 22 57 f1				ld (os_current_i), hl 
2ded			 
2ded					if DEBUG_FORTH_WORDS 
2ded						DMARK "DO8" 
2ded f5				push af  
2dee 3a 02 2e			ld a, (.dmark)  
2df1 32 77 fb			ld (debug_mark),a  
2df4 3a 03 2e			ld a, (.dmark+1)  
2df7 32 78 fb			ld (debug_mark+1),a  
2dfa 3a 04 2e			ld a, (.dmark+2)  
2dfd 32 79 fb			ld (debug_mark+2),a  
2e00 18 03			jr .pastdmark  
2e02 ..			.dmark: db "DO8"  
2e05 f1			.pastdmark: pop af  
2e06			endm  
# End of macro DMARK
2e06						CALLMONITOR 
2e06 cd 00 14			call break_point_state  
2e09				endm  
# End of macro CALLMONITOR
2e09					endif 
2e09			 
2e09					NEXTW 
2e09 c3 8b 1b			jp macro_next 
2e0c				endm 
# End of macro NEXTW
2e0c			.LOOP: 
2e0c				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
2e0c 22				db WORD_SYS_CORE+14             
2e0d 24 2f			dw .I            
2e0f 05				db 4 + 1 
2e10 .. 00			db "LOOP",0              
2e15				endm 
# End of macro CWHEAD
2e15			; | LOOP ( -- ) Increment and test loop counter  | DONE 
2e15			 
2e15				; pop tos as current loop count to hl 
2e15			 
2e15				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
2e15			 
2e15				FORTH_LOOP_TOS 
2e15 cd 7d 1a			call macro_forth_loop_tos 
2e18				endm 
# End of macro FORTH_LOOP_TOS
2e18 e5				push hl 
2e19			 
2e19					if DEBUG_FORTH_WORDS_KEY 
2e19						DMARK "LOP" 
2e19 f5				push af  
2e1a 3a 2e 2e			ld a, (.dmark)  
2e1d 32 77 fb			ld (debug_mark),a  
2e20 3a 2f 2e			ld a, (.dmark+1)  
2e23 32 78 fb			ld (debug_mark+1),a  
2e26 3a 30 2e			ld a, (.dmark+2)  
2e29 32 79 fb			ld (debug_mark+2),a  
2e2c 18 03			jr .pastdmark  
2e2e ..			.dmark: db "LOP"  
2e31 f1			.pastdmark: pop af  
2e32			endm  
# End of macro DMARK
2e32						CALLMONITOR 
2e32 cd 00 14			call break_point_state  
2e35				endm  
# End of macro CALLMONITOR
2e35					endif 
2e35				; next item on the stack is the limit. get it 
2e35			 
2e35			 
2e35				FORTH_LOOP_POP 
2e35 cd 87 1a			call macro_forth_loop_pop 
2e38				endm 
# End of macro FORTH_LOOP_POP
2e38			 
2e38				FORTH_LOOP_TOS 
2e38 cd 7d 1a			call macro_forth_loop_tos 
2e3b				endm 
# End of macro FORTH_LOOP_TOS
2e3b			 
2e3b d1				pop de		 ; de = i, hl = limit 
2e3c			 
2e3c					if DEBUG_FORTH_WORDS 
2e3c						DMARK "LP1" 
2e3c f5				push af  
2e3d 3a 51 2e			ld a, (.dmark)  
2e40 32 77 fb			ld (debug_mark),a  
2e43 3a 52 2e			ld a, (.dmark+1)  
2e46 32 78 fb			ld (debug_mark+1),a  
2e49 3a 53 2e			ld a, (.dmark+2)  
2e4c 32 79 fb			ld (debug_mark+2),a  
2e4f 18 03			jr .pastdmark  
2e51 ..			.dmark: db "LP1"  
2e54 f1			.pastdmark: pop af  
2e55			endm  
# End of macro DMARK
2e55						CALLMONITOR 
2e55 cd 00 14			call break_point_state  
2e58				endm  
# End of macro CALLMONITOR
2e58					endif 
2e58			 
2e58				; go back to previous word 
2e58			 
2e58 d5				push de    ; save I for inc later 
2e59			 
2e59			 
2e59				; get limit 
2e59				;  is I at limit? 
2e59			 
2e59			 
2e59					if DEBUG_FORTH_WORDS 
2e59						DMARK "LP1" 
2e59 f5				push af  
2e5a 3a 6e 2e			ld a, (.dmark)  
2e5d 32 77 fb			ld (debug_mark),a  
2e60 3a 6f 2e			ld a, (.dmark+1)  
2e63 32 78 fb			ld (debug_mark+1),a  
2e66 3a 70 2e			ld a, (.dmark+2)  
2e69 32 79 fb			ld (debug_mark+2),a  
2e6c 18 03			jr .pastdmark  
2e6e ..			.dmark: db "LP1"  
2e71 f1			.pastdmark: pop af  
2e72			endm  
# End of macro DMARK
2e72						CALLMONITOR 
2e72 cd 00 14			call break_point_state  
2e75				endm  
# End of macro CALLMONITOR
2e75					endif 
2e75			 
2e75 ed 52			sbc hl, de 
2e77			 
2e77			 
2e77				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
2e77			 
2e77 20 26				jr nz, .loopnotdone 
2e79			 
2e79 e1				pop hl   ; get rid of saved I 
2e7a				FORTH_LOOP_POP     ; get rid of limit 
2e7a cd 87 1a			call macro_forth_loop_pop 
2e7d				endm 
# End of macro FORTH_LOOP_POP
2e7d			 
2e7d				FORTH_RSP_POP     ; get rid of DO ptr 
2e7d cd 62 19			call macro_forth_rsp_pop 
2e80				endm 
# End of macro FORTH_RSP_POP
2e80			 
2e80			if DEBUG_FORTH_WORDS 
2e80						DMARK "LP>" 
2e80 f5				push af  
2e81 3a 95 2e			ld a, (.dmark)  
2e84 32 77 fb			ld (debug_mark),a  
2e87 3a 96 2e			ld a, (.dmark+1)  
2e8a 32 78 fb			ld (debug_mark+1),a  
2e8d 3a 97 2e			ld a, (.dmark+2)  
2e90 32 79 fb			ld (debug_mark+2),a  
2e93 18 03			jr .pastdmark  
2e95 ..			.dmark: db "LP>"  
2e98 f1			.pastdmark: pop af  
2e99			endm  
# End of macro DMARK
2e99				CALLMONITOR 
2e99 cd 00 14			call break_point_state  
2e9c				endm  
# End of macro CALLMONITOR
2e9c			endif 
2e9c			 
2e9c					NEXTW 
2e9c c3 8b 1b			jp macro_next 
2e9f				endm 
# End of macro NEXTW
2e9f				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
2e9f			 
2e9f			.loopnotdone: 
2e9f			 
2e9f e1				pop hl    ; get I 
2ea0 23				inc hl 
2ea1			 
2ea1			   	; save new I 
2ea1			 
2ea1			 
2ea1					; set I counter 
2ea1			 
2ea1 22 57 f1				ld (os_current_i), hl 
2ea4			 
2ea4					if DEBUG_FORTH_WORDS 
2ea4						DMARK "LPN" 
2ea4 f5				push af  
2ea5 3a b9 2e			ld a, (.dmark)  
2ea8 32 77 fb			ld (debug_mark),a  
2eab 3a ba 2e			ld a, (.dmark+1)  
2eae 32 78 fb			ld (debug_mark+1),a  
2eb1 3a bb 2e			ld a, (.dmark+2)  
2eb4 32 79 fb			ld (debug_mark+2),a  
2eb7 18 03			jr .pastdmark  
2eb9 ..			.dmark: db "LPN"  
2ebc f1			.pastdmark: pop af  
2ebd			endm  
# End of macro DMARK
2ebd					CALLMONITOR 
2ebd cd 00 14			call break_point_state  
2ec0				endm  
# End of macro CALLMONITOR
2ec0					endif 
2ec0					 
2ec0				FORTH_LOOP_NEXT 
2ec0 cd 4a 1a			call macro_forth_loop_next 
2ec3				endm 
# End of macro FORTH_LOOP_NEXT
2ec3			 
2ec3			 
2ec3					if DEBUG_FORTH_WORDS 
2ec3 eb						ex de,hl 
2ec4					endif 
2ec4			 
2ec4			;	; get DO ptr 
2ec4			; 
2ec4					if DEBUG_FORTH_WORDS 
2ec4						DMARK "LP7" 
2ec4 f5				push af  
2ec5 3a d9 2e			ld a, (.dmark)  
2ec8 32 77 fb			ld (debug_mark),a  
2ecb 3a da 2e			ld a, (.dmark+1)  
2ece 32 78 fb			ld (debug_mark+1),a  
2ed1 3a db 2e			ld a, (.dmark+2)  
2ed4 32 79 fb			ld (debug_mark+2),a  
2ed7 18 03			jr .pastdmark  
2ed9 ..			.dmark: db "LP7"  
2edc f1			.pastdmark: pop af  
2edd			endm  
# End of macro DMARK
2edd					CALLMONITOR 
2edd cd 00 14			call break_point_state  
2ee0				endm  
# End of macro CALLMONITOR
2ee0					endif 
2ee0				FORTH_RSP_TOS 
2ee0 cd 58 19			call macro_forth_rsp_tos 
2ee3				endm 
# End of macro FORTH_RSP_TOS
2ee3			 
2ee3					if DEBUG_FORTH_WORDS 
2ee3						DMARK "LP8" 
2ee3 f5				push af  
2ee4 3a f8 2e			ld a, (.dmark)  
2ee7 32 77 fb			ld (debug_mark),a  
2eea 3a f9 2e			ld a, (.dmark+1)  
2eed 32 78 fb			ld (debug_mark+1),a  
2ef0 3a fa 2e			ld a, (.dmark+2)  
2ef3 32 79 fb			ld (debug_mark+2),a  
2ef6 18 03			jr .pastdmark  
2ef8 ..			.dmark: db "LP8"  
2efb f1			.pastdmark: pop af  
2efc			endm  
# End of macro DMARK
2efc					CALLMONITOR 
2efc cd 00 14			call break_point_state  
2eff				endm  
# End of macro CALLMONITOR
2eff					endif 
2eff				;push hl 
2eff			 
2eff				; not going to DO any more 
2eff				; get rid of the RSP pointer as DO will add it back in 
2eff				;FORTH_RSP_POP 
2eff				;pop hl 
2eff			 
2eff				;ld hl,(cli_ret_sp) 
2eff				;ld e, (hl) 
2eff				;inc hl 
2eff				;ld d, (hl) 
2eff				;ex de,hl 
2eff 22 33 f1			ld (os_tok_ptr), hl 
2f02					if DEBUG_FORTH_WORDS 
2f02						DMARK "LP<" 
2f02 f5				push af  
2f03 3a 17 2f			ld a, (.dmark)  
2f06 32 77 fb			ld (debug_mark),a  
2f09 3a 18 2f			ld a, (.dmark+1)  
2f0c 32 78 fb			ld (debug_mark+1),a  
2f0f 3a 19 2f			ld a, (.dmark+2)  
2f12 32 79 fb			ld (debug_mark+2),a  
2f15 18 03			jr .pastdmark  
2f17 ..			.dmark: db "LP<"  
2f1a f1			.pastdmark: pop af  
2f1b			endm  
# End of macro DMARK
2f1b					CALLMONITOR 
2f1b cd 00 14			call break_point_state  
2f1e				endm  
# End of macro CALLMONITOR
2f1e				endif 
2f1e c3 1c 1c			jp exec1 
2f21			 
2f21					 
2f21			 
2f21			 
2f21					NEXTW 
2f21 c3 8b 1b			jp macro_next 
2f24				endm 
# End of macro NEXTW
2f24			.I:  
2f24			 
2f24				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
2f24 5e				db WORD_SYS_CORE+74             
2f25 4f 2f			dw .DLOOP            
2f27 02				db 1 + 1 
2f28 .. 00			db "I",0              
2f2a				endm 
# End of macro CWHEAD
2f2a			; | I ( -- ) Current loop counter | DONE 
2f2a					if DEBUG_FORTH_WORDS_KEY 
2f2a						DMARK "I.." 
2f2a f5				push af  
2f2b 3a 3f 2f			ld a, (.dmark)  
2f2e 32 77 fb			ld (debug_mark),a  
2f31 3a 40 2f			ld a, (.dmark+1)  
2f34 32 78 fb			ld (debug_mark+1),a  
2f37 3a 41 2f			ld a, (.dmark+2)  
2f3a 32 79 fb			ld (debug_mark+2),a  
2f3d 18 03			jr .pastdmark  
2f3f ..			.dmark: db "I.."  
2f42 f1			.pastdmark: pop af  
2f43			endm  
# End of macro DMARK
2f43						CALLMONITOR 
2f43 cd 00 14			call break_point_state  
2f46				endm  
# End of macro CALLMONITOR
2f46					endif 
2f46			 
2f46 2a 57 f1				ld hl,(os_current_i) 
2f49 cd 9a 19				call forth_push_numhl 
2f4c			 
2f4c					NEXTW 
2f4c c3 8b 1b			jp macro_next 
2f4f				endm 
# End of macro NEXTW
2f4f			.DLOOP: 
2f4f				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
2f4f 5f				db WORD_SYS_CORE+75             
2f50 30 30			dw .REPEAT            
2f52 06				db 5 + 1 
2f53 .. 00			db "-LOOP",0              
2f59				endm 
# End of macro CWHEAD
2f59			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
2f59				; pop tos as current loop count to hl 
2f59					if DEBUG_FORTH_WORDS_KEY 
2f59						DMARK "-LP" 
2f59 f5				push af  
2f5a 3a 6e 2f			ld a, (.dmark)  
2f5d 32 77 fb			ld (debug_mark),a  
2f60 3a 6f 2f			ld a, (.dmark+1)  
2f63 32 78 fb			ld (debug_mark+1),a  
2f66 3a 70 2f			ld a, (.dmark+2)  
2f69 32 79 fb			ld (debug_mark+2),a  
2f6c 18 03			jr .pastdmark  
2f6e ..			.dmark: db "-LP"  
2f71 f1			.pastdmark: pop af  
2f72			endm  
# End of macro DMARK
2f72						CALLMONITOR 
2f72 cd 00 14			call break_point_state  
2f75				endm  
# End of macro CALLMONITOR
2f75					endif 
2f75			 
2f75				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
2f75			 
2f75				FORTH_LOOP_TOS 
2f75 cd 7d 1a			call macro_forth_loop_tos 
2f78				endm 
# End of macro FORTH_LOOP_TOS
2f78 e5				push hl 
2f79			 
2f79					if DEBUG_FORTH_WORDS 
2f79						DMARK "-LP" 
2f79 f5				push af  
2f7a 3a 8e 2f			ld a, (.dmark)  
2f7d 32 77 fb			ld (debug_mark),a  
2f80 3a 8f 2f			ld a, (.dmark+1)  
2f83 32 78 fb			ld (debug_mark+1),a  
2f86 3a 90 2f			ld a, (.dmark+2)  
2f89 32 79 fb			ld (debug_mark+2),a  
2f8c 18 03			jr .pastdmark  
2f8e ..			.dmark: db "-LP"  
2f91 f1			.pastdmark: pop af  
2f92			endm  
# End of macro DMARK
2f92						CALLMONITOR 
2f92 cd 00 14			call break_point_state  
2f95				endm  
# End of macro CALLMONITOR
2f95					endif 
2f95				; next item on the stack is the limit. get it 
2f95			 
2f95			 
2f95				FORTH_LOOP_POP 
2f95 cd 87 1a			call macro_forth_loop_pop 
2f98				endm 
# End of macro FORTH_LOOP_POP
2f98			 
2f98				FORTH_LOOP_TOS 
2f98 cd 7d 1a			call macro_forth_loop_tos 
2f9b				endm 
# End of macro FORTH_LOOP_TOS
2f9b			 
2f9b d1				pop de		 ; de = i, hl = limit 
2f9c			 
2f9c					if DEBUG_FORTH_WORDS 
2f9c						DMARK "-L1" 
2f9c f5				push af  
2f9d 3a b1 2f			ld a, (.dmark)  
2fa0 32 77 fb			ld (debug_mark),a  
2fa3 3a b2 2f			ld a, (.dmark+1)  
2fa6 32 78 fb			ld (debug_mark+1),a  
2fa9 3a b3 2f			ld a, (.dmark+2)  
2fac 32 79 fb			ld (debug_mark+2),a  
2faf 18 03			jr .pastdmark  
2fb1 ..			.dmark: db "-L1"  
2fb4 f1			.pastdmark: pop af  
2fb5			endm  
# End of macro DMARK
2fb5						CALLMONITOR 
2fb5 cd 00 14			call break_point_state  
2fb8				endm  
# End of macro CALLMONITOR
2fb8					endif 
2fb8			 
2fb8				; go back to previous word 
2fb8			 
2fb8 d5				push de    ; save I for inc later 
2fb9			 
2fb9			 
2fb9				; get limit 
2fb9				;  is I at limit? 
2fb9			 
2fb9			 
2fb9					if DEBUG_FORTH_WORDS 
2fb9						DMARK "-L1" 
2fb9 f5				push af  
2fba 3a ce 2f			ld a, (.dmark)  
2fbd 32 77 fb			ld (debug_mark),a  
2fc0 3a cf 2f			ld a, (.dmark+1)  
2fc3 32 78 fb			ld (debug_mark+1),a  
2fc6 3a d0 2f			ld a, (.dmark+2)  
2fc9 32 79 fb			ld (debug_mark+2),a  
2fcc 18 03			jr .pastdmark  
2fce ..			.dmark: db "-L1"  
2fd1 f1			.pastdmark: pop af  
2fd2			endm  
# End of macro DMARK
2fd2						CALLMONITOR 
2fd2 cd 00 14			call break_point_state  
2fd5				endm  
# End of macro CALLMONITOR
2fd5					endif 
2fd5			 
2fd5 ed 52			sbc hl, de 
2fd7			 
2fd7			 
2fd7				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
2fd7			 
2fd7 20 26				jr nz, .mloopnotdone 
2fd9			 
2fd9 e1				pop hl   ; get rid of saved I 
2fda				FORTH_LOOP_POP     ; get rid of limit 
2fda cd 87 1a			call macro_forth_loop_pop 
2fdd				endm 
# End of macro FORTH_LOOP_POP
2fdd			 
2fdd				FORTH_RSP_POP     ; get rid of DO ptr 
2fdd cd 62 19			call macro_forth_rsp_pop 
2fe0				endm 
# End of macro FORTH_RSP_POP
2fe0			 
2fe0			if DEBUG_FORTH_WORDS 
2fe0						DMARK "-L>" 
2fe0 f5				push af  
2fe1 3a f5 2f			ld a, (.dmark)  
2fe4 32 77 fb			ld (debug_mark),a  
2fe7 3a f6 2f			ld a, (.dmark+1)  
2fea 32 78 fb			ld (debug_mark+1),a  
2fed 3a f7 2f			ld a, (.dmark+2)  
2ff0 32 79 fb			ld (debug_mark+2),a  
2ff3 18 03			jr .pastdmark  
2ff5 ..			.dmark: db "-L>"  
2ff8 f1			.pastdmark: pop af  
2ff9			endm  
# End of macro DMARK
2ff9				CALLMONITOR 
2ff9 cd 00 14			call break_point_state  
2ffc				endm  
# End of macro CALLMONITOR
2ffc			endif 
2ffc			 
2ffc					NEXTW 
2ffc c3 8b 1b			jp macro_next 
2fff				endm 
# End of macro NEXTW
2fff				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
2fff			 
2fff			.mloopnotdone: 
2fff			 
2fff e1				pop hl    ; get I 
3000 2b				dec hl 
3001			 
3001			   	; save new I 
3001			 
3001			 
3001					; set I counter 
3001			 
3001 22 57 f1				ld (os_current_i), hl 
3004			 
3004					 
3004				FORTH_LOOP_NEXT 
3004 cd 4a 1a			call macro_forth_loop_next 
3007				endm 
# End of macro FORTH_LOOP_NEXT
3007			 
3007			 
3007					if DEBUG_FORTH_WORDS 
3007 eb						ex de,hl 
3008					endif 
3008			 
3008			;	; get DO ptr 
3008			; 
3008				FORTH_RSP_TOS 
3008 cd 58 19			call macro_forth_rsp_tos 
300b				endm 
# End of macro FORTH_RSP_TOS
300b			 
300b				;push hl 
300b			 
300b				; not going to DO any more 
300b				; get rid of the RSP pointer as DO will add it back in 
300b				;FORTH_RSP_POP 
300b				;pop hl 
300b			 
300b			 
300b 22 33 f1			ld (os_tok_ptr), hl 
300e					if DEBUG_FORTH_WORDS 
300e						DMARK "-L<" 
300e f5				push af  
300f 3a 23 30			ld a, (.dmark)  
3012 32 77 fb			ld (debug_mark),a  
3015 3a 24 30			ld a, (.dmark+1)  
3018 32 78 fb			ld (debug_mark+1),a  
301b 3a 25 30			ld a, (.dmark+2)  
301e 32 79 fb			ld (debug_mark+2),a  
3021 18 03			jr .pastdmark  
3023 ..			.dmark: db "-L<"  
3026 f1			.pastdmark: pop af  
3027			endm  
# End of macro DMARK
3027					CALLMONITOR 
3027 cd 00 14			call break_point_state  
302a				endm  
# End of macro CALLMONITOR
302a				endif 
302a c3 1c 1c			jp exec1 
302d			 
302d					 
302d			 
302d			 
302d			 
302d				NEXTW 
302d c3 8b 1b			jp macro_next 
3030				endm 
# End of macro NEXTW
3030			 
3030			 
3030			 
3030			 
3030			.REPEAT: 
3030				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
3030 71				db WORD_SYS_CORE+93             
3031 83 30			dw .UNTIL            
3033 06				db 5 + 1 
3034 .. 00			db "REPEAT",0              
303b				endm 
# End of macro CWHEAD
303b			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
303b			;  push pc to rsp stack past the REPEAT 
303b					if DEBUG_FORTH_WORDS_KEY 
303b						DMARK "REP" 
303b f5				push af  
303c 3a 50 30			ld a, (.dmark)  
303f 32 77 fb			ld (debug_mark),a  
3042 3a 51 30			ld a, (.dmark+1)  
3045 32 78 fb			ld (debug_mark+1),a  
3048 3a 52 30			ld a, (.dmark+2)  
304b 32 79 fb			ld (debug_mark+2),a  
304e 18 03			jr .pastdmark  
3050 ..			.dmark: db "REP"  
3053 f1			.pastdmark: pop af  
3054			endm  
# End of macro DMARK
3054						CALLMONITOR 
3054 cd 00 14			call break_point_state  
3057				endm  
# End of macro CALLMONITOR
3057					endif 
3057			 
3057 2a 33 f1				ld hl, (os_tok_ptr) 
305a 23					inc hl   ; R 
305b 23					inc hl  ; E 
305c 23					inc hl   ; P 
305d 23					inc hl   ; E 
305e 23					inc hl   ; A 
305f 23					inc hl   ; T 
3060 23					inc hl   ; zero 
3061					FORTH_RSP_NEXT 
3061 cd 41 19			call macro_forth_rsp_next 
3064				endm 
# End of macro FORTH_RSP_NEXT
3064			 
3064			 
3064					if DEBUG_FORTH_WORDS 
3064						DMARK "REP" 
3064 f5				push af  
3065 3a 79 30			ld a, (.dmark)  
3068 32 77 fb			ld (debug_mark),a  
306b 3a 7a 30			ld a, (.dmark+1)  
306e 32 78 fb			ld (debug_mark+1),a  
3071 3a 7b 30			ld a, (.dmark+2)  
3074 32 79 fb			ld (debug_mark+2),a  
3077 18 03			jr .pastdmark  
3079 ..			.dmark: db "REP"  
307c f1			.pastdmark: pop af  
307d			endm  
# End of macro DMARK
307d						;pop bc    ; TODO BUG ?????? what is this for???? 
307d						CALLMONITOR 
307d cd 00 14			call break_point_state  
3080				endm  
# End of macro CALLMONITOR
3080					endif 
3080			 
3080					NEXTW 
3080 c3 8b 1b			jp macro_next 
3083				endm 
# End of macro NEXTW
3083			;	       NEXTW 
3083			 
3083			.UNTIL: 
3083				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
3083 72				db WORD_SYS_CORE+94             
3084 1a 31			dw .ENDFLOW            
3086 06				db 5 + 1 
3087 .. 00			db "UNTIL",0              
308d				endm 
# End of macro CWHEAD
308d			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
308d			 
308d				; pop tos as check 
308d			 
308d				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
308d			 
308d				FORTH_DSP_VALUEHL 
308d cd 35 1a			call macro_dsp_valuehl 
3090				endm 
# End of macro FORTH_DSP_VALUEHL
3090			 
3090					if DEBUG_FORTH_WORDS_KEY 
3090						DMARK "UNT" 
3090 f5				push af  
3091 3a a5 30			ld a, (.dmark)  
3094 32 77 fb			ld (debug_mark),a  
3097 3a a6 30			ld a, (.dmark+1)  
309a 32 78 fb			ld (debug_mark+1),a  
309d 3a a7 30			ld a, (.dmark+2)  
30a0 32 79 fb			ld (debug_mark+2),a  
30a3 18 03			jr .pastdmark  
30a5 ..			.dmark: db "UNT"  
30a8 f1			.pastdmark: pop af  
30a9			endm  
# End of macro DMARK
30a9						CALLMONITOR 
30a9 cd 00 14			call break_point_state  
30ac				endm  
# End of macro CALLMONITOR
30ac					endif 
30ac			 
30ac			;	push hl 
30ac				FORTH_DSP_POP 
30ac cd d1 1a			call macro_forth_dsp_pop 
30af				endm 
# End of macro FORTH_DSP_POP
30af			 
30af			;	pop hl 
30af			 
30af				; test if true 
30af			 
30af cd 3b 0c			call ishlzero 
30b2			;	ld a,l 
30b2			;	add h 
30b2			; 
30b2			;	cp 0 
30b2			 
30b2 20 3e			jr nz, .untilnotdone 
30b4			 
30b4					if DEBUG_FORTH_WORDS 
30b4						DMARK "UNf" 
30b4 f5				push af  
30b5 3a c9 30			ld a, (.dmark)  
30b8 32 77 fb			ld (debug_mark),a  
30bb 3a ca 30			ld a, (.dmark+1)  
30be 32 78 fb			ld (debug_mark+1),a  
30c1 3a cb 30			ld a, (.dmark+2)  
30c4 32 79 fb			ld (debug_mark+2),a  
30c7 18 03			jr .pastdmark  
30c9 ..			.dmark: db "UNf"  
30cc f1			.pastdmark: pop af  
30cd			endm  
# End of macro DMARK
30cd						CALLMONITOR 
30cd cd 00 14			call break_point_state  
30d0				endm  
# End of macro CALLMONITOR
30d0					endif 
30d0			 
30d0			 
30d0			 
30d0				FORTH_RSP_POP     ; get rid of DO ptr 
30d0 cd 62 19			call macro_forth_rsp_pop 
30d3				endm 
# End of macro FORTH_RSP_POP
30d3			 
30d3			if DEBUG_FORTH_WORDS 
30d3						DMARK "UN>" 
30d3 f5				push af  
30d4 3a e8 30			ld a, (.dmark)  
30d7 32 77 fb			ld (debug_mark),a  
30da 3a e9 30			ld a, (.dmark+1)  
30dd 32 78 fb			ld (debug_mark+1),a  
30e0 3a ea 30			ld a, (.dmark+2)  
30e3 32 79 fb			ld (debug_mark+2),a  
30e6 18 03			jr .pastdmark  
30e8 ..			.dmark: db "UN>"  
30eb f1			.pastdmark: pop af  
30ec			endm  
# End of macro DMARK
30ec				CALLMONITOR 
30ec cd 00 14			call break_point_state  
30ef				endm  
# End of macro CALLMONITOR
30ef			endif 
30ef			 
30ef					NEXTW 
30ef c3 8b 1b			jp macro_next 
30f2				endm 
# End of macro NEXTW
30f2				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
30f2			 
30f2			.untilnotdone: 
30f2			 
30f2			 
30f2			;	; get DO ptr 
30f2			; 
30f2				FORTH_RSP_TOS 
30f2 cd 58 19			call macro_forth_rsp_tos 
30f5				endm 
# End of macro FORTH_RSP_TOS
30f5			 
30f5				;push hl 
30f5			 
30f5				; not going to DO any more 
30f5				; get rid of the RSP pointer as DO will add it back in 
30f5				;FORTH_RSP_POP 
30f5				;pop hl 
30f5			 
30f5			 
30f5 22 33 f1			ld (os_tok_ptr), hl 
30f8					if DEBUG_FORTH_WORDS 
30f8						DMARK "UN<" 
30f8 f5				push af  
30f9 3a 0d 31			ld a, (.dmark)  
30fc 32 77 fb			ld (debug_mark),a  
30ff 3a 0e 31			ld a, (.dmark+1)  
3102 32 78 fb			ld (debug_mark+1),a  
3105 3a 0f 31			ld a, (.dmark+2)  
3108 32 79 fb			ld (debug_mark+2),a  
310b 18 03			jr .pastdmark  
310d ..			.dmark: db "UN<"  
3110 f1			.pastdmark: pop af  
3111			endm  
# End of macro DMARK
3111					CALLMONITOR 
3111 cd 00 14			call break_point_state  
3114				endm  
# End of macro CALLMONITOR
3114				endif 
3114 c3 1c 1c			jp exec1 
3117			 
3117					 
3117			 
3117			 
3117					NEXTW 
3117 c3 8b 1b			jp macro_next 
311a				endm 
# End of macro NEXTW
311a			 
311a			 
311a			.ENDFLOW: 
311a			 
311a			; eof 
311a			 
# End of file forth_words_flow.asm
311a			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
311a			include "forth_words_logic.asm" 
311a			 
311a			; | ## Logic Words 
311a			 
311a			.NOT: 
311a				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
311a 2d				db WORD_SYS_CORE+25             
311b 62 31			dw .IS            
311d 04				db 3 + 1 
311e .. 00			db "NOT",0              
3122				endm 
# End of macro CWHEAD
3122			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
3122					if DEBUG_FORTH_WORDS_KEY 
3122						DMARK "NOT" 
3122 f5				push af  
3123 3a 37 31			ld a, (.dmark)  
3126 32 77 fb			ld (debug_mark),a  
3129 3a 38 31			ld a, (.dmark+1)  
312c 32 78 fb			ld (debug_mark+1),a  
312f 3a 39 31			ld a, (.dmark+2)  
3132 32 79 fb			ld (debug_mark+2),a  
3135 18 03			jr .pastdmark  
3137 ..			.dmark: db "NOT"  
313a f1			.pastdmark: pop af  
313b			endm  
# End of macro DMARK
313b						CALLMONITOR 
313b cd 00 14			call break_point_state  
313e				endm  
# End of macro CALLMONITOR
313e					endif 
313e					FORTH_DSP 
313e cd 1a 1a			call macro_forth_dsp 
3141				endm 
# End of macro FORTH_DSP
3141 7e					ld a,(hl)	; get type of value on TOS 
3142 fe 02				cp DS_TYPE_INUM  
3144 28 03				jr z, .noti 
3146					NEXTW 
3146 c3 8b 1b			jp macro_next 
3149				endm 
# End of macro NEXTW
3149			.noti:          FORTH_DSP_VALUEHL 
3149 cd 35 1a			call macro_dsp_valuehl 
314c				endm 
# End of macro FORTH_DSP_VALUEHL
314c			;		push hl 
314c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
314c cd d1 1a			call macro_forth_dsp_pop 
314f				endm 
# End of macro FORTH_DSP_POP
314f			;		pop hl 
314f 3e 00				ld a,0 
3151 bd					cp l 
3152 28 04				jr z, .not2t 
3154 2e 00				ld l, 0 
3156 18 02				jr .notip 
3158			 
3158 2e ff		.not2t:		ld l, 255 
315a			 
315a 26 00		.notip:		ld h, 0	 
315c			 
315c cd 9a 19				call forth_push_numhl 
315f					NEXTW 
315f c3 8b 1b			jp macro_next 
3162				endm 
# End of macro NEXTW
3162			 
3162			.IS: 
3162				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
3162 2d				db WORD_SYS_CORE+25             
3163 88 31			dw .LZERO            
3165 03				db 2 + 1 
3166 .. 00			db "IS",0              
3169				endm 
# End of macro CWHEAD
3169			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
3169					if DEBUG_FORTH_WORDS_KEY 
3169						DMARK "IS." 
3169 f5				push af  
316a 3a 7e 31			ld a, (.dmark)  
316d 32 77 fb			ld (debug_mark),a  
3170 3a 7f 31			ld a, (.dmark+1)  
3173 32 78 fb			ld (debug_mark+1),a  
3176 3a 80 31			ld a, (.dmark+2)  
3179 32 79 fb			ld (debug_mark+2),a  
317c 18 03			jr .pastdmark  
317e ..			.dmark: db "IS."  
3181 f1			.pastdmark: pop af  
3182			endm  
# End of macro DMARK
3182						CALLMONITOR 
3182 cd 00 14			call break_point_state  
3185				endm  
# End of macro CALLMONITOR
3185					endif 
3185					NEXTW 
3185 c3 8b 1b			jp macro_next 
3188				endm 
# End of macro NEXTW
3188			.LZERO: 
3188				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
3188 2d				db WORD_SYS_CORE+25             
3189 92 31			dw .TZERO            
318b 03				db 2 + 1 
318c .. 00			db "0<",0              
318f				endm 
# End of macro CWHEAD
318f			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
318f					NEXTW 
318f c3 8b 1b			jp macro_next 
3192				endm 
# End of macro NEXTW
3192			.TZERO: 
3192				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
3192 2e				db WORD_SYS_CORE+26             
3193 d9 31			dw .LESS            
3195 03				db 2 + 1 
3196 .. 00			db "0=",0              
3199				endm 
# End of macro CWHEAD
3199			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
3199				; TODO add floating point number detection 
3199					;v5 FORTH_DSP_VALUE 
3199					if DEBUG_FORTH_WORDS_KEY 
3199						DMARK "0=." 
3199 f5				push af  
319a 3a ae 31			ld a, (.dmark)  
319d 32 77 fb			ld (debug_mark),a  
31a0 3a af 31			ld a, (.dmark+1)  
31a3 32 78 fb			ld (debug_mark+1),a  
31a6 3a b0 31			ld a, (.dmark+2)  
31a9 32 79 fb			ld (debug_mark+2),a  
31ac 18 03			jr .pastdmark  
31ae ..			.dmark: db "0=."  
31b1 f1			.pastdmark: pop af  
31b2			endm  
# End of macro DMARK
31b2						CALLMONITOR 
31b2 cd 00 14			call break_point_state  
31b5				endm  
# End of macro CALLMONITOR
31b5					endif 
31b5					FORTH_DSP 
31b5 cd 1a 1a			call macro_forth_dsp 
31b8				endm 
# End of macro FORTH_DSP
31b8 7e					ld a,(hl)	; get type of value on TOS 
31b9 fe 02				cp DS_TYPE_INUM  
31bb 28 00				jr z, .tz_inum 
31bd			 
31bd				if FORTH_ENABLE_FLOATMATH 
31bd					jr .tz_done 
31bd			 
31bd				endif 
31bd					 
31bd			 
31bd			.tz_inum: 
31bd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
31bd cd 35 1a			call macro_dsp_valuehl 
31c0				endm 
# End of macro FORTH_DSP_VALUEHL
31c0			 
31c0			;		push hl 
31c0			 
31c0					; destroy value TOS 
31c0			 
31c0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
31c0 cd d1 1a			call macro_forth_dsp_pop 
31c3				endm 
# End of macro FORTH_DSP_POP
31c3			 
31c3			;		pop hl 
31c3			 
31c3 3e 00				ld a,0 
31c5			 
31c5 bd					cp l 
31c6 20 08				jr nz, .tz_notzero 
31c8			 
31c8 bc					cp h 
31c9			 
31c9 20 05				jr nz, .tz_notzero 
31cb			 
31cb			 
31cb 21 01 00				ld hl, FORTH_TRUE 
31ce 18 03				jr .tz_done 
31d0			 
31d0 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
31d3			 
31d3					; push value back onto stack for another op etc 
31d3			 
31d3			.tz_done: 
31d3 cd 9a 19				call forth_push_numhl 
31d6			 
31d6					NEXTW 
31d6 c3 8b 1b			jp macro_next 
31d9				endm 
# End of macro NEXTW
31d9			.LESS: 
31d9				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
31d9 2f				db WORD_SYS_CORE+27             
31da 42 32			dw .GT            
31dc 02				db 1 + 1 
31dd .. 00			db "<",0              
31df				endm 
# End of macro CWHEAD
31df			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
31df				; TODO add floating point number detection 
31df					if DEBUG_FORTH_WORDS_KEY 
31df						DMARK "LES" 
31df f5				push af  
31e0 3a f4 31			ld a, (.dmark)  
31e3 32 77 fb			ld (debug_mark),a  
31e6 3a f5 31			ld a, (.dmark+1)  
31e9 32 78 fb			ld (debug_mark+1),a  
31ec 3a f6 31			ld a, (.dmark+2)  
31ef 32 79 fb			ld (debug_mark+2),a  
31f2 18 03			jr .pastdmark  
31f4 ..			.dmark: db "LES"  
31f7 f1			.pastdmark: pop af  
31f8			endm  
# End of macro DMARK
31f8						CALLMONITOR 
31f8 cd 00 14			call break_point_state  
31fb				endm  
# End of macro CALLMONITOR
31fb					endif 
31fb					FORTH_DSP 
31fb cd 1a 1a			call macro_forth_dsp 
31fe				endm 
# End of macro FORTH_DSP
31fe					;v5 FORTH_DSP_VALUE 
31fe 7e					ld a,(hl)	; get type of value on TOS 
31ff fe 02				cp DS_TYPE_INUM  
3201 28 00				jr z, .less_inum 
3203			 
3203				if FORTH_ENABLE_FLOATMATH 
3203					jr .less_done 
3203			 
3203				endif 
3203					 
3203			 
3203			.less_inum: 
3203					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3203 cd 35 1a			call macro_dsp_valuehl 
3206				endm 
# End of macro FORTH_DSP_VALUEHL
3206			 
3206 e5					push hl  ; u2 
3207			 
3207					; destroy value TOS 
3207			 
3207					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3207 cd d1 1a			call macro_forth_dsp_pop 
320a				endm 
# End of macro FORTH_DSP_POP
320a			 
320a			 
320a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
320a cd 35 1a			call macro_dsp_valuehl 
320d				endm 
# End of macro FORTH_DSP_VALUEHL
320d			 
320d e5					push hl    ; u1 
320e			 
320e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
320e cd d1 1a			call macro_forth_dsp_pop 
3211				endm 
# End of macro FORTH_DSP_POP
3211			 
3211			 
3211 b7			 or a      ;clear carry flag 
3212 01 00 00		 ld bc, FORTH_FALSE 
3215 e1			  pop hl    ; u1 
3216 d1			  pop de    ; u2 
3217 ed 52		  sbc hl,de 
3219 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
321b			 
321b 01 01 00		 ld bc, FORTH_TRUE 
321e			.lscont:  
321e c5					push bc 
321f e1					pop hl 
3220			 
3220					if DEBUG_FORTH_WORDS 
3220						DMARK "LT1" 
3220 f5				push af  
3221 3a 35 32			ld a, (.dmark)  
3224 32 77 fb			ld (debug_mark),a  
3227 3a 36 32			ld a, (.dmark+1)  
322a 32 78 fb			ld (debug_mark+1),a  
322d 3a 37 32			ld a, (.dmark+2)  
3230 32 79 fb			ld (debug_mark+2),a  
3233 18 03			jr .pastdmark  
3235 ..			.dmark: db "LT1"  
3238 f1			.pastdmark: pop af  
3239			endm  
# End of macro DMARK
3239						CALLMONITOR 
3239 cd 00 14			call break_point_state  
323c				endm  
# End of macro CALLMONITOR
323c					endif 
323c cd 9a 19				call forth_push_numhl 
323f			 
323f					NEXTW 
323f c3 8b 1b			jp macro_next 
3242				endm 
# End of macro NEXTW
3242			.GT: 
3242				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
3242 30				db WORD_SYS_CORE+28             
3243 ab 32			dw .EQUAL            
3245 02				db 1 + 1 
3246 .. 00			db ">",0              
3248				endm 
# End of macro CWHEAD
3248			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
3248				; TODO add floating point number detection 
3248					if DEBUG_FORTH_WORDS_KEY 
3248						DMARK "GRT" 
3248 f5				push af  
3249 3a 5d 32			ld a, (.dmark)  
324c 32 77 fb			ld (debug_mark),a  
324f 3a 5e 32			ld a, (.dmark+1)  
3252 32 78 fb			ld (debug_mark+1),a  
3255 3a 5f 32			ld a, (.dmark+2)  
3258 32 79 fb			ld (debug_mark+2),a  
325b 18 03			jr .pastdmark  
325d ..			.dmark: db "GRT"  
3260 f1			.pastdmark: pop af  
3261			endm  
# End of macro DMARK
3261						CALLMONITOR 
3261 cd 00 14			call break_point_state  
3264				endm  
# End of macro CALLMONITOR
3264					endif 
3264					FORTH_DSP 
3264 cd 1a 1a			call macro_forth_dsp 
3267				endm 
# End of macro FORTH_DSP
3267					;FORTH_DSP_VALUE 
3267 7e					ld a,(hl)	; get type of value on TOS 
3268 fe 02				cp DS_TYPE_INUM  
326a 28 00				jr z, .gt_inum 
326c			 
326c				if FORTH_ENABLE_FLOATMATH 
326c					jr .gt_done 
326c			 
326c				endif 
326c					 
326c			 
326c			.gt_inum: 
326c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
326c cd 35 1a			call macro_dsp_valuehl 
326f				endm 
# End of macro FORTH_DSP_VALUEHL
326f			 
326f e5					push hl  ; u2 
3270			 
3270					; destroy value TOS 
3270			 
3270					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3270 cd d1 1a			call macro_forth_dsp_pop 
3273				endm 
# End of macro FORTH_DSP_POP
3273			 
3273			 
3273					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3273 cd 35 1a			call macro_dsp_valuehl 
3276				endm 
# End of macro FORTH_DSP_VALUEHL
3276			 
3276 e5					push hl    ; u1 
3277			 
3277					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3277 cd d1 1a			call macro_forth_dsp_pop 
327a				endm 
# End of macro FORTH_DSP_POP
327a			 
327a			 
327a b7			 or a      ;clear carry flag 
327b 01 00 00		 ld bc, FORTH_FALSE 
327e e1			  pop hl    ; u1 
327f d1			  pop de    ; u2 
3280 ed 52		  sbc hl,de 
3282 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
3284			 
3284 01 01 00		 ld bc, FORTH_TRUE 
3287			.gtcont:  
3287 c5					push bc 
3288 e1					pop hl 
3289			 
3289					if DEBUG_FORTH_WORDS 
3289						DMARK "GT1" 
3289 f5				push af  
328a 3a 9e 32			ld a, (.dmark)  
328d 32 77 fb			ld (debug_mark),a  
3290 3a 9f 32			ld a, (.dmark+1)  
3293 32 78 fb			ld (debug_mark+1),a  
3296 3a a0 32			ld a, (.dmark+2)  
3299 32 79 fb			ld (debug_mark+2),a  
329c 18 03			jr .pastdmark  
329e ..			.dmark: db "GT1"  
32a1 f1			.pastdmark: pop af  
32a2			endm  
# End of macro DMARK
32a2						CALLMONITOR 
32a2 cd 00 14			call break_point_state  
32a5				endm  
# End of macro CALLMONITOR
32a5					endif 
32a5 cd 9a 19				call forth_push_numhl 
32a8			 
32a8					NEXTW 
32a8 c3 8b 1b			jp macro_next 
32ab				endm 
# End of macro NEXTW
32ab			.EQUAL: 
32ab				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
32ab 31				db WORD_SYS_CORE+29             
32ac 16 33			dw .ENDLOGIC            
32ae 02				db 1 + 1 
32af .. 00			db "=",0              
32b1				endm 
# End of macro CWHEAD
32b1			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
32b1				; TODO add floating point number detection 
32b1					if DEBUG_FORTH_WORDS_KEY 
32b1						DMARK "EQ." 
32b1 f5				push af  
32b2 3a c6 32			ld a, (.dmark)  
32b5 32 77 fb			ld (debug_mark),a  
32b8 3a c7 32			ld a, (.dmark+1)  
32bb 32 78 fb			ld (debug_mark+1),a  
32be 3a c8 32			ld a, (.dmark+2)  
32c1 32 79 fb			ld (debug_mark+2),a  
32c4 18 03			jr .pastdmark  
32c6 ..			.dmark: db "EQ."  
32c9 f1			.pastdmark: pop af  
32ca			endm  
# End of macro DMARK
32ca						CALLMONITOR 
32ca cd 00 14			call break_point_state  
32cd				endm  
# End of macro CALLMONITOR
32cd					endif 
32cd					FORTH_DSP 
32cd cd 1a 1a			call macro_forth_dsp 
32d0				endm 
# End of macro FORTH_DSP
32d0					;v5 FORTH_DSP_VALUE 
32d0 7e					ld a,(hl)	; get type of value on TOS 
32d1 fe 02				cp DS_TYPE_INUM  
32d3 28 00				jr z, .eq_inum 
32d5			 
32d5				if FORTH_ENABLE_FLOATMATH 
32d5					jr .eq_done 
32d5			 
32d5				endif 
32d5					 
32d5			 
32d5			.eq_inum: 
32d5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
32d5 cd 35 1a			call macro_dsp_valuehl 
32d8				endm 
# End of macro FORTH_DSP_VALUEHL
32d8			 
32d8 e5					push hl 
32d9			 
32d9					; destroy value TOS 
32d9			 
32d9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
32d9 cd d1 1a			call macro_forth_dsp_pop 
32dc				endm 
# End of macro FORTH_DSP_POP
32dc			 
32dc			 
32dc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
32dc cd 35 1a			call macro_dsp_valuehl 
32df				endm 
# End of macro FORTH_DSP_VALUEHL
32df			 
32df					; one value on hl get other one back 
32df			 
32df e5					push hl 
32e0			 
32e0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
32e0 cd d1 1a			call macro_forth_dsp_pop 
32e3				endm 
# End of macro FORTH_DSP_POP
32e3			 
32e3 0e 00				ld c, FORTH_FALSE 
32e5			 
32e5 e1					pop hl 
32e6 d1					pop de 
32e7			 
32e7 7b					ld a, e 
32e8 bd					cp l 
32e9			 
32e9 20 06				jr nz, .eq_done 
32eb			 
32eb 7a					ld a, d 
32ec bc					cp h 
32ed			 
32ed 20 02				jr nz, .eq_done 
32ef			 
32ef 0e 01				ld c, FORTH_TRUE 
32f1					 
32f1			 
32f1			 
32f1			.eq_done: 
32f1			 
32f1					; TODO push value back onto stack for another op etc 
32f1			 
32f1 26 00				ld h, 0 
32f3 69					ld l, c 
32f4					if DEBUG_FORTH_WORDS 
32f4						DMARK "EQ1" 
32f4 f5				push af  
32f5 3a 09 33			ld a, (.dmark)  
32f8 32 77 fb			ld (debug_mark),a  
32fb 3a 0a 33			ld a, (.dmark+1)  
32fe 32 78 fb			ld (debug_mark+1),a  
3301 3a 0b 33			ld a, (.dmark+2)  
3304 32 79 fb			ld (debug_mark+2),a  
3307 18 03			jr .pastdmark  
3309 ..			.dmark: db "EQ1"  
330c f1			.pastdmark: pop af  
330d			endm  
# End of macro DMARK
330d						CALLMONITOR 
330d cd 00 14			call break_point_state  
3310				endm  
# End of macro CALLMONITOR
3310					endif 
3310 cd 9a 19				call forth_push_numhl 
3313			 
3313					NEXTW 
3313 c3 8b 1b			jp macro_next 
3316				endm 
# End of macro NEXTW
3316			 
3316			 
3316			.ENDLOGIC: 
3316			; eof 
3316			 
3316			 
# End of file forth_words_logic.asm
3316			include "forth_words_maths.asm" 
3316			 
3316			; | ## Maths Words 
3316			 
3316			.PLUS:	 
3316				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3316 15				db WORD_SYS_CORE+1             
3317 58 33			dw .NEG            
3319 02				db 1 + 1 
331a .. 00			db "+",0              
331c				endm 
# End of macro CWHEAD
331c			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
331c					if DEBUG_FORTH_WORDS_KEY 
331c						DMARK "PLU" 
331c f5				push af  
331d 3a 31 33			ld a, (.dmark)  
3320 32 77 fb			ld (debug_mark),a  
3323 3a 32 33			ld a, (.dmark+1)  
3326 32 78 fb			ld (debug_mark+1),a  
3329 3a 33 33			ld a, (.dmark+2)  
332c 32 79 fb			ld (debug_mark+2),a  
332f 18 03			jr .pastdmark  
3331 ..			.dmark: db "PLU"  
3334 f1			.pastdmark: pop af  
3335			endm  
# End of macro DMARK
3335						CALLMONITOR 
3335 cd 00 14			call break_point_state  
3338				endm  
# End of macro CALLMONITOR
3338					endif 
3338					; add top two values and push back result 
3338			 
3338					;for v5 FORTH_DSP_VALUE 
3338					FORTH_DSP 
3338 cd 1a 1a			call macro_forth_dsp 
333b				endm 
# End of macro FORTH_DSP
333b 7e					ld a,(hl)	; get type of value on TOS 
333c fe 02				cp DS_TYPE_INUM  
333e 28 03				jr z, .dot_inum 
3340			 
3340					NEXTW 
3340 c3 8b 1b			jp macro_next 
3343				endm 
# End of macro NEXTW
3343			 
3343			; float maths 
3343			 
3343				if FORTH_ENABLE_FLOATMATH 
3343						inc hl      ; now at start of numeric as string 
3343			 
3343					if DEBUG_FORTH_MATHS 
3343						DMARK "ADD" 
3343				CALLMONITOR 
3343					endif 
3343			 
3343					;ld ix, hl 
3343					call CON 
3343			 
3343			 
3343					push hl 
3343					 
3343					 
3343			 
3343						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
3343			 
3343					; get next number 
3343			 
3343						FORTH_DSP_VALUE 
3343			 
3343						inc hl      ; now at start of numeric as string 
3343			 
3343					;ld ix, hl 
3343					call CON 
3343			 
3343					push hl 
3343			 
3343			 
3343						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3343			 
3343						; TODO do add 
3343			 
3343						call IADD 
3343			 
3343						; TODO get result back as ascii 
3343			 
3343						; TODO push result  
3343			 
3343			 
3343			 
3343						jr .dot_done 
3343				endif 
3343			 
3343			.dot_inum: 
3343			 
3343			 
3343					if DEBUG_FORTH_DOT 
3343						DMARK "+IT" 
3343				CALLMONITOR 
3343					endif 
3343			 
3343					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3343 cd 35 1a			call macro_dsp_valuehl 
3346				endm 
# End of macro FORTH_DSP_VALUEHL
3346			 
3346				; TODO add floating point number detection 
3346			 
3346 e5					push hl 
3347			 
3347					; destroy value TOS 
3347			 
3347					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3347 cd d1 1a			call macro_forth_dsp_pop 
334a				endm 
# End of macro FORTH_DSP_POP
334a			 
334a			 
334a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
334a cd 35 1a			call macro_dsp_valuehl 
334d				endm 
# End of macro FORTH_DSP_VALUEHL
334d			 
334d					; one value on hl get other one back 
334d			 
334d d1					pop de 
334e			 
334e					; do the add 
334e			 
334e 19					add hl,de 
334f			 
334f					; save it 
334f			 
334f			;		push hl	 
334f			 
334f					; 
334f			 
334f					; destroy value TOS 
334f			 
334f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
334f cd d1 1a			call macro_forth_dsp_pop 
3352				endm 
# End of macro FORTH_DSP_POP
3352			 
3352					; TODO push value back onto stack for another op etc 
3352			 
3352			;		pop hl 
3352			 
3352			.dot_done: 
3352 cd 9a 19				call forth_push_numhl 
3355			 
3355					NEXTW 
3355 c3 8b 1b			jp macro_next 
3358				endm 
# End of macro NEXTW
3358			.NEG: 
3358			 
3358				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
3358 17				db WORD_SYS_CORE+3             
3359 9b 33			dw .DIV            
335b 02				db 1 + 1 
335c .. 00			db "-",0              
335e				endm 
# End of macro CWHEAD
335e			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
335e					if DEBUG_FORTH_WORDS_KEY 
335e						DMARK "SUB" 
335e f5				push af  
335f 3a 73 33			ld a, (.dmark)  
3362 32 77 fb			ld (debug_mark),a  
3365 3a 74 33			ld a, (.dmark+1)  
3368 32 78 fb			ld (debug_mark+1),a  
336b 3a 75 33			ld a, (.dmark+2)  
336e 32 79 fb			ld (debug_mark+2),a  
3371 18 03			jr .pastdmark  
3373 ..			.dmark: db "SUB"  
3376 f1			.pastdmark: pop af  
3377			endm  
# End of macro DMARK
3377						CALLMONITOR 
3377 cd 00 14			call break_point_state  
337a				endm  
# End of macro CALLMONITOR
337a					endif 
337a			 
337a			 
337a				; TODO add floating point number detection 
337a					; v5 FORTH_DSP_VALUE 
337a					FORTH_DSP 
337a cd 1a 1a			call macro_forth_dsp 
337d				endm 
# End of macro FORTH_DSP
337d 7e					ld a,(hl)	; get type of value on TOS 
337e fe 02				cp DS_TYPE_INUM  
3380 28 03				jr z, .neg_inum 
3382			 
3382					NEXTW 
3382 c3 8b 1b			jp macro_next 
3385				endm 
# End of macro NEXTW
3385			 
3385			; float maths 
3385			 
3385				if FORTH_ENABLE_FLOATMATH 
3385					jr .neg_done 
3385			 
3385				endif 
3385					 
3385			 
3385			.neg_inum: 
3385					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3385 cd 35 1a			call macro_dsp_valuehl 
3388				endm 
# End of macro FORTH_DSP_VALUEHL
3388			 
3388 e5					push hl 
3389			 
3389					; destroy value TOS 
3389			 
3389					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3389 cd d1 1a			call macro_forth_dsp_pop 
338c				endm 
# End of macro FORTH_DSP_POP
338c			 
338c			 
338c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
338c cd 35 1a			call macro_dsp_valuehl 
338f				endm 
# End of macro FORTH_DSP_VALUEHL
338f			 
338f					; one value on hl get other one back 
338f			 
338f d1					pop de 
3390			 
3390					; do the sub 
3390			;		ex de, hl 
3390			 
3390 ed 52				sbc hl,de 
3392			 
3392					; save it 
3392			 
3392			;		push hl	 
3392			 
3392					; 
3392			 
3392					; destroy value TOS 
3392			 
3392					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3392 cd d1 1a			call macro_forth_dsp_pop 
3395				endm 
# End of macro FORTH_DSP_POP
3395			 
3395					; TODO push value back onto stack for another op etc 
3395			 
3395			;		pop hl 
3395			 
3395 cd 9a 19				call forth_push_numhl 
3398			.neg_done: 
3398			 
3398					NEXTW 
3398 c3 8b 1b			jp macro_next 
339b				endm 
# End of macro NEXTW
339b			.DIV: 
339b				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
339b 18				db WORD_SYS_CORE+4             
339c e8 33			dw .MUL            
339e 02				db 1 + 1 
339f .. 00			db "/",0              
33a1				endm 
# End of macro CWHEAD
33a1			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
33a1					if DEBUG_FORTH_WORDS_KEY 
33a1						DMARK "DIV" 
33a1 f5				push af  
33a2 3a b6 33			ld a, (.dmark)  
33a5 32 77 fb			ld (debug_mark),a  
33a8 3a b7 33			ld a, (.dmark+1)  
33ab 32 78 fb			ld (debug_mark+1),a  
33ae 3a b8 33			ld a, (.dmark+2)  
33b1 32 79 fb			ld (debug_mark+2),a  
33b4 18 03			jr .pastdmark  
33b6 ..			.dmark: db "DIV"  
33b9 f1			.pastdmark: pop af  
33ba			endm  
# End of macro DMARK
33ba						CALLMONITOR 
33ba cd 00 14			call break_point_state  
33bd				endm  
# End of macro CALLMONITOR
33bd					endif 
33bd				; TODO add floating point number detection 
33bd					; v5 FORTH_DSP_VALUE 
33bd					FORTH_DSP 
33bd cd 1a 1a			call macro_forth_dsp 
33c0				endm 
# End of macro FORTH_DSP
33c0 7e					ld a,(hl)	; get type of value on TOS 
33c1 fe 02				cp DS_TYPE_INUM  
33c3 28 03				jr z, .div_inum 
33c5			 
33c5				if FORTH_ENABLE_FLOATMATH 
33c5					jr .div_done 
33c5			 
33c5				endif 
33c5					NEXTW 
33c5 c3 8b 1b			jp macro_next 
33c8				endm 
# End of macro NEXTW
33c8			.div_inum: 
33c8			 
33c8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
33c8 cd 35 1a			call macro_dsp_valuehl 
33cb				endm 
# End of macro FORTH_DSP_VALUEHL
33cb			 
33cb e5					push hl    ; to go to bc 
33cc			 
33cc					; destroy value TOS 
33cc			 
33cc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
33cc cd d1 1a			call macro_forth_dsp_pop 
33cf				endm 
# End of macro FORTH_DSP_POP
33cf			 
33cf			 
33cf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
33cf cd 35 1a			call macro_dsp_valuehl 
33d2				endm 
# End of macro FORTH_DSP_VALUEHL
33d2			 
33d2					; hl to go to de 
33d2			 
33d2 e5					push hl 
33d3			 
33d3 c1					pop bc 
33d4 d1					pop de		 
33d5			 
33d5			 
33d5					if DEBUG_FORTH_MATHS 
33d5						DMARK "DIV" 
33d5				CALLMONITOR 
33d5					endif 
33d5					; one value on hl but move to a get other one back 
33d5			 
33d5			        
33d5 cd 6f 0b			call Div16 
33d8			 
33d8			;	push af	 
33d8 e5				push hl 
33d9 c5				push bc 
33da			 
33da					if DEBUG_FORTH_MATHS 
33da						DMARK "DI1" 
33da				CALLMONITOR 
33da					endif 
33da			 
33da					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
33da cd d1 1a			call macro_forth_dsp_pop 
33dd				endm 
# End of macro FORTH_DSP_POP
33dd			 
33dd			 
33dd			 
33dd e1					pop hl    ; result 
33de			 
33de cd 9a 19				call forth_push_numhl 
33e1			 
33e1 e1					pop hl    ; reminder 
33e2			;		ld h,0 
33e2			;		ld l,d 
33e2			 
33e2 cd 9a 19				call forth_push_numhl 
33e5			.div_done: 
33e5					NEXTW 
33e5 c3 8b 1b			jp macro_next 
33e8				endm 
# End of macro NEXTW
33e8			.MUL: 
33e8				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
33e8 19				db WORD_SYS_CORE+5             
33e9 2d 34			dw .MIN            
33eb 02				db 1 + 1 
33ec .. 00			db "*",0              
33ee				endm 
# End of macro CWHEAD
33ee			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
33ee				; TODO add floating point number detection 
33ee					if DEBUG_FORTH_WORDS_KEY 
33ee						DMARK "MUL" 
33ee f5				push af  
33ef 3a 03 34			ld a, (.dmark)  
33f2 32 77 fb			ld (debug_mark),a  
33f5 3a 04 34			ld a, (.dmark+1)  
33f8 32 78 fb			ld (debug_mark+1),a  
33fb 3a 05 34			ld a, (.dmark+2)  
33fe 32 79 fb			ld (debug_mark+2),a  
3401 18 03			jr .pastdmark  
3403 ..			.dmark: db "MUL"  
3406 f1			.pastdmark: pop af  
3407			endm  
# End of macro DMARK
3407						CALLMONITOR 
3407 cd 00 14			call break_point_state  
340a				endm  
# End of macro CALLMONITOR
340a					endif 
340a					FORTH_DSP 
340a cd 1a 1a			call macro_forth_dsp 
340d				endm 
# End of macro FORTH_DSP
340d					; v5 FORTH_DSP_VALUE 
340d 7e					ld a,(hl)	; get type of value on TOS 
340e fe 02				cp DS_TYPE_INUM  
3410 28 03				jr z, .mul_inum 
3412			 
3412				if FORTH_ENABLE_FLOATMATH 
3412					jr .mul_done 
3412			 
3412				endif 
3412			 
3412					NEXTW 
3412 c3 8b 1b			jp macro_next 
3415				endm 
# End of macro NEXTW
3415			.mul_inum:	 
3415			 
3415					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3415 cd 35 1a			call macro_dsp_valuehl 
3418				endm 
# End of macro FORTH_DSP_VALUEHL
3418			 
3418 e5					push hl 
3419			 
3419					; destroy value TOS 
3419			 
3419					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3419 cd d1 1a			call macro_forth_dsp_pop 
341c				endm 
# End of macro FORTH_DSP_POP
341c			 
341c			 
341c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
341c cd 35 1a			call macro_dsp_valuehl 
341f				endm 
# End of macro FORTH_DSP_VALUEHL
341f			 
341f					; one value on hl but move to a get other one back 
341f			 
341f 7d					ld a, l 
3420			 
3420 d1					pop de 
3421			 
3421					; do the mull 
3421			;		ex de, hl 
3421			 
3421 cd 95 0b				call Mult16 
3424					; save it 
3424			 
3424			;		push hl	 
3424			 
3424					; 
3424			 
3424					; destroy value TOS 
3424			 
3424					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3424 cd d1 1a			call macro_forth_dsp_pop 
3427				endm 
# End of macro FORTH_DSP_POP
3427			 
3427					; TODO push value back onto stack for another op etc 
3427			 
3427			;		pop hl 
3427			 
3427 cd 9a 19				call forth_push_numhl 
342a			 
342a			.mul_done: 
342a					NEXTW 
342a c3 8b 1b			jp macro_next 
342d				endm 
# End of macro NEXTW
342d			 
342d			 
342d			 
342d			 
342d			.MIN: 
342d				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
342d 49				db WORD_SYS_CORE+53             
342e ae 34			dw .MAX            
3430 04				db 3 + 1 
3431 .. 00			db "MIN",0              
3435				endm 
# End of macro CWHEAD
3435			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3435					if DEBUG_FORTH_WORDS_KEY 
3435						DMARK "MIN" 
3435 f5				push af  
3436 3a 4a 34			ld a, (.dmark)  
3439 32 77 fb			ld (debug_mark),a  
343c 3a 4b 34			ld a, (.dmark+1)  
343f 32 78 fb			ld (debug_mark+1),a  
3442 3a 4c 34			ld a, (.dmark+2)  
3445 32 79 fb			ld (debug_mark+2),a  
3448 18 03			jr .pastdmark  
344a ..			.dmark: db "MIN"  
344d f1			.pastdmark: pop af  
344e			endm  
# End of macro DMARK
344e						CALLMONITOR 
344e cd 00 14			call break_point_state  
3451				endm  
# End of macro CALLMONITOR
3451					endif 
3451					; get u2 
3451			 
3451					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3451 cd 35 1a			call macro_dsp_valuehl 
3454				endm 
# End of macro FORTH_DSP_VALUEHL
3454			 
3454 e5					push hl   ; u2 
3455			 
3455					; destroy value TOS 
3455			 
3455					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3455 cd d1 1a			call macro_forth_dsp_pop 
3458				endm 
# End of macro FORTH_DSP_POP
3458			 
3458					; get u1 
3458			 
3458					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3458 cd 35 1a			call macro_dsp_valuehl 
345b				endm 
# End of macro FORTH_DSP_VALUEHL
345b			 
345b e5					push hl  ; u1 
345c			 
345c					; destroy value TOS 
345c			 
345c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
345c cd d1 1a			call macro_forth_dsp_pop 
345f				endm 
# End of macro FORTH_DSP_POP
345f			 
345f b7			 or a      ;clear carry flag 
3460 e1			  pop hl    ; u1 
3461 d1			  pop de    ; u2 
3462 e5				push hl   ; saved in case hl is lowest 
3463 ed 52		  sbc hl,de 
3465 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3467			 
3467 e1				pop hl 
3468					if DEBUG_FORTH_WORDS 
3468						DMARK "MIN" 
3468 f5				push af  
3469 3a 7d 34			ld a, (.dmark)  
346c 32 77 fb			ld (debug_mark),a  
346f 3a 7e 34			ld a, (.dmark+1)  
3472 32 78 fb			ld (debug_mark+1),a  
3475 3a 7f 34			ld a, (.dmark+2)  
3478 32 79 fb			ld (debug_mark+2),a  
347b 18 03			jr .pastdmark  
347d ..			.dmark: db "MIN"  
3480 f1			.pastdmark: pop af  
3481			endm  
# End of macro DMARK
3481						CALLMONITOR 
3481 cd 00 14			call break_point_state  
3484				endm  
# End of macro CALLMONITOR
3484					endif 
3484 cd 9a 19				call forth_push_numhl 
3487			 
3487				       NEXTW 
3487 c3 8b 1b			jp macro_next 
348a				endm 
# End of macro NEXTW
348a			 
348a			.mincont:  
348a c1				pop bc   ; tidy up 
348b eb				ex de , hl  
348c					if DEBUG_FORTH_WORDS 
348c						DMARK "MI1" 
348c f5				push af  
348d 3a a1 34			ld a, (.dmark)  
3490 32 77 fb			ld (debug_mark),a  
3493 3a a2 34			ld a, (.dmark+1)  
3496 32 78 fb			ld (debug_mark+1),a  
3499 3a a3 34			ld a, (.dmark+2)  
349c 32 79 fb			ld (debug_mark+2),a  
349f 18 03			jr .pastdmark  
34a1 ..			.dmark: db "MI1"  
34a4 f1			.pastdmark: pop af  
34a5			endm  
# End of macro DMARK
34a5						CALLMONITOR 
34a5 cd 00 14			call break_point_state  
34a8				endm  
# End of macro CALLMONITOR
34a8					endif 
34a8 cd 9a 19				call forth_push_numhl 
34ab			 
34ab				       NEXTW 
34ab c3 8b 1b			jp macro_next 
34ae				endm 
# End of macro NEXTW
34ae			.MAX: 
34ae				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
34ae 4a				db WORD_SYS_CORE+54             
34af 2f 35			dw .RND16            
34b1 04				db 3 + 1 
34b2 .. 00			db "MAX",0              
34b6				endm 
# End of macro CWHEAD
34b6			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
34b6					if DEBUG_FORTH_WORDS_KEY 
34b6						DMARK "MAX" 
34b6 f5				push af  
34b7 3a cb 34			ld a, (.dmark)  
34ba 32 77 fb			ld (debug_mark),a  
34bd 3a cc 34			ld a, (.dmark+1)  
34c0 32 78 fb			ld (debug_mark+1),a  
34c3 3a cd 34			ld a, (.dmark+2)  
34c6 32 79 fb			ld (debug_mark+2),a  
34c9 18 03			jr .pastdmark  
34cb ..			.dmark: db "MAX"  
34ce f1			.pastdmark: pop af  
34cf			endm  
# End of macro DMARK
34cf						CALLMONITOR 
34cf cd 00 14			call break_point_state  
34d2				endm  
# End of macro CALLMONITOR
34d2					endif 
34d2					; get u2 
34d2			 
34d2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
34d2 cd 35 1a			call macro_dsp_valuehl 
34d5				endm 
# End of macro FORTH_DSP_VALUEHL
34d5			 
34d5 e5					push hl   ; u2 
34d6			 
34d6					; destroy value TOS 
34d6			 
34d6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34d6 cd d1 1a			call macro_forth_dsp_pop 
34d9				endm 
# End of macro FORTH_DSP_POP
34d9			 
34d9					; get u1 
34d9			 
34d9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
34d9 cd 35 1a			call macro_dsp_valuehl 
34dc				endm 
# End of macro FORTH_DSP_VALUEHL
34dc			 
34dc e5					push hl  ; u1 
34dd			 
34dd					; destroy value TOS 
34dd			 
34dd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34dd cd d1 1a			call macro_forth_dsp_pop 
34e0				endm 
# End of macro FORTH_DSP_POP
34e0			 
34e0 b7			 or a      ;clear carry flag 
34e1 e1			  pop hl    ; u1 
34e2 d1			  pop de    ; u2 
34e3 e5				push hl   ; saved in case hl is lowest 
34e4 ed 52		  sbc hl,de 
34e6 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
34e8			 
34e8 e1				pop hl 
34e9					if DEBUG_FORTH_WORDS 
34e9						DMARK "MAX" 
34e9 f5				push af  
34ea 3a fe 34			ld a, (.dmark)  
34ed 32 77 fb			ld (debug_mark),a  
34f0 3a ff 34			ld a, (.dmark+1)  
34f3 32 78 fb			ld (debug_mark+1),a  
34f6 3a 00 35			ld a, (.dmark+2)  
34f9 32 79 fb			ld (debug_mark+2),a  
34fc 18 03			jr .pastdmark  
34fe ..			.dmark: db "MAX"  
3501 f1			.pastdmark: pop af  
3502			endm  
# End of macro DMARK
3502						CALLMONITOR 
3502 cd 00 14			call break_point_state  
3505				endm  
# End of macro CALLMONITOR
3505					endif 
3505 cd 9a 19				call forth_push_numhl 
3508			 
3508				       NEXTW 
3508 c3 8b 1b			jp macro_next 
350b				endm 
# End of macro NEXTW
350b			 
350b			.maxcont:  
350b c1				pop bc   ; tidy up 
350c eb				ex de , hl  
350d					if DEBUG_FORTH_WORDS 
350d						DMARK "MA1" 
350d f5				push af  
350e 3a 22 35			ld a, (.dmark)  
3511 32 77 fb			ld (debug_mark),a  
3514 3a 23 35			ld a, (.dmark+1)  
3517 32 78 fb			ld (debug_mark+1),a  
351a 3a 24 35			ld a, (.dmark+2)  
351d 32 79 fb			ld (debug_mark+2),a  
3520 18 03			jr .pastdmark  
3522 ..			.dmark: db "MA1"  
3525 f1			.pastdmark: pop af  
3526			endm  
# End of macro DMARK
3526						CALLMONITOR 
3526 cd 00 14			call break_point_state  
3529				endm  
# End of macro CALLMONITOR
3529					endif 
3529 cd 9a 19				call forth_push_numhl 
352c				       NEXTW 
352c c3 8b 1b			jp macro_next 
352f				endm 
# End of macro NEXTW
352f			 
352f			.RND16: 
352f				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
352f 4e				db WORD_SYS_CORE+58             
3530 5e 35			dw .RND8            
3532 06				db 5 + 1 
3533 .. 00			db "RND16",0              
3539				endm 
# End of macro CWHEAD
3539			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3539					if DEBUG_FORTH_WORDS_KEY 
3539						DMARK "R16" 
3539 f5				push af  
353a 3a 4e 35			ld a, (.dmark)  
353d 32 77 fb			ld (debug_mark),a  
3540 3a 4f 35			ld a, (.dmark+1)  
3543 32 78 fb			ld (debug_mark+1),a  
3546 3a 50 35			ld a, (.dmark+2)  
3549 32 79 fb			ld (debug_mark+2),a  
354c 18 03			jr .pastdmark  
354e ..			.dmark: db "R16"  
3551 f1			.pastdmark: pop af  
3552			endm  
# End of macro DMARK
3552						CALLMONITOR 
3552 cd 00 14			call break_point_state  
3555				endm  
# End of macro CALLMONITOR
3555					endif 
3555 cd 39 0b				call prng16  
3558 cd 9a 19				call forth_push_numhl 
355b				       NEXTW 
355b c3 8b 1b			jp macro_next 
355e				endm 
# End of macro NEXTW
355e			.RND8: 
355e				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
355e 60				db WORD_SYS_CORE+76             
355f 93 35			dw .RND            
3561 05				db 4 + 1 
3562 .. 00			db "RND8",0              
3567				endm 
# End of macro CWHEAD
3567			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3567					if DEBUG_FORTH_WORDS_KEY 
3567						DMARK "RN8" 
3567 f5				push af  
3568 3a 7c 35			ld a, (.dmark)  
356b 32 77 fb			ld (debug_mark),a  
356e 3a 7d 35			ld a, (.dmark+1)  
3571 32 78 fb			ld (debug_mark+1),a  
3574 3a 7e 35			ld a, (.dmark+2)  
3577 32 79 fb			ld (debug_mark+2),a  
357a 18 03			jr .pastdmark  
357c ..			.dmark: db "RN8"  
357f f1			.pastdmark: pop af  
3580			endm  
# End of macro DMARK
3580						CALLMONITOR 
3580 cd 00 14			call break_point_state  
3583				endm  
# End of macro CALLMONITOR
3583					endif 
3583 2a b8 f8				ld hl,(xrandc) 
3586 23					inc hl 
3587 cd 53 0b				call xrnd 
358a 6f					ld l,a	 
358b 26 00				ld h,0 
358d cd 9a 19				call forth_push_numhl 
3590				       NEXTW 
3590 c3 8b 1b			jp macro_next 
3593				endm 
# End of macro NEXTW
3593			.RND: 
3593				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3593 60				db WORD_SYS_CORE+76             
3594 99 36			dw .ENDMATHS            
3596 04				db 3 + 1 
3597 .. 00			db "RND",0              
359b				endm 
# End of macro CWHEAD
359b			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
359b			 
359b					if DEBUG_FORTH_WORDS_KEY 
359b						DMARK "RND" 
359b f5				push af  
359c 3a b0 35			ld a, (.dmark)  
359f 32 77 fb			ld (debug_mark),a  
35a2 3a b1 35			ld a, (.dmark+1)  
35a5 32 78 fb			ld (debug_mark+1),a  
35a8 3a b2 35			ld a, (.dmark+2)  
35ab 32 79 fb			ld (debug_mark+2),a  
35ae 18 03			jr .pastdmark  
35b0 ..			.dmark: db "RND"  
35b3 f1			.pastdmark: pop af  
35b4			endm  
# End of macro DMARK
35b4						CALLMONITOR 
35b4 cd 00 14			call break_point_state  
35b7				endm  
# End of macro CALLMONITOR
35b7					endif 
35b7					 
35b7					FORTH_DSP_VALUEHL    ; upper range 
35b7 cd 35 1a			call macro_dsp_valuehl 
35ba				endm 
# End of macro FORTH_DSP_VALUEHL
35ba			 
35ba 22 bc f8				ld (LFSRSeed), hl	 
35bd			 
35bd					if DEBUG_FORTH_WORDS 
35bd						DMARK "RN1" 
35bd f5				push af  
35be 3a d2 35			ld a, (.dmark)  
35c1 32 77 fb			ld (debug_mark),a  
35c4 3a d3 35			ld a, (.dmark+1)  
35c7 32 78 fb			ld (debug_mark+1),a  
35ca 3a d4 35			ld a, (.dmark+2)  
35cd 32 79 fb			ld (debug_mark+2),a  
35d0 18 03			jr .pastdmark  
35d2 ..			.dmark: db "RN1"  
35d5 f1			.pastdmark: pop af  
35d6			endm  
# End of macro DMARK
35d6						CALLMONITOR 
35d6 cd 00 14			call break_point_state  
35d9				endm  
# End of macro CALLMONITOR
35d9					endif 
35d9					FORTH_DSP_POP 
35d9 cd d1 1a			call macro_forth_dsp_pop 
35dc				endm 
# End of macro FORTH_DSP_POP
35dc			 
35dc					FORTH_DSP_VALUEHL    ; low range 
35dc cd 35 1a			call macro_dsp_valuehl 
35df				endm 
# End of macro FORTH_DSP_VALUEHL
35df			 
35df					if DEBUG_FORTH_WORDS 
35df						DMARK "RN2" 
35df f5				push af  
35e0 3a f4 35			ld a, (.dmark)  
35e3 32 77 fb			ld (debug_mark),a  
35e6 3a f5 35			ld a, (.dmark+1)  
35e9 32 78 fb			ld (debug_mark+1),a  
35ec 3a f6 35			ld a, (.dmark+2)  
35ef 32 79 fb			ld (debug_mark+2),a  
35f2 18 03			jr .pastdmark  
35f4 ..			.dmark: db "RN2"  
35f7 f1			.pastdmark: pop af  
35f8			endm  
# End of macro DMARK
35f8						CALLMONITOR 
35f8 cd 00 14			call break_point_state  
35fb				endm  
# End of macro CALLMONITOR
35fb					endif 
35fb 22 be f8				ld (LFSRSeed+2), hl 
35fe			 
35fe					FORTH_DSP_POP 
35fe cd d1 1a			call macro_forth_dsp_pop 
3601				endm 
# End of macro FORTH_DSP_POP
3601			 
3601 e5					push hl 
3602			 
3602 e1			.inrange:	pop hl 
3603 cd 39 0b				call prng16  
3606					if DEBUG_FORTH_WORDS 
3606						DMARK "RN3" 
3606 f5				push af  
3607 3a 1b 36			ld a, (.dmark)  
360a 32 77 fb			ld (debug_mark),a  
360d 3a 1c 36			ld a, (.dmark+1)  
3610 32 78 fb			ld (debug_mark+1),a  
3613 3a 1d 36			ld a, (.dmark+2)  
3616 32 79 fb			ld (debug_mark+2),a  
3619 18 03			jr .pastdmark  
361b ..			.dmark: db "RN3"  
361e f1			.pastdmark: pop af  
361f			endm  
# End of macro DMARK
361f						CALLMONITOR 
361f cd 00 14			call break_point_state  
3622				endm  
# End of macro CALLMONITOR
3622					endif 
3622					 
3622					; if the range is 8bit knock out the high byte 
3622			 
3622 ed 5b bc f8			ld de, (LFSRSeed)     ; check high level 
3626			 
3626 3e 00				ld a, 0 
3628 ba					cp d  
3629 20 1e				jr nz, .hirange 
362b 26 00				ld h, 0   ; knock it down to 8bit 
362d			 
362d					if DEBUG_FORTH_WORDS 
362d						DMARK "RNk" 
362d f5				push af  
362e 3a 42 36			ld a, (.dmark)  
3631 32 77 fb			ld (debug_mark),a  
3634 3a 43 36			ld a, (.dmark+1)  
3637 32 78 fb			ld (debug_mark+1),a  
363a 3a 44 36			ld a, (.dmark+2)  
363d 32 79 fb			ld (debug_mark+2),a  
3640 18 03			jr .pastdmark  
3642 ..			.dmark: db "RNk"  
3645 f1			.pastdmark: pop af  
3646			endm  
# End of macro DMARK
3646						CALLMONITOR 
3646 cd 00 14			call break_point_state  
3649				endm  
# End of macro CALLMONITOR
3649					endif 
3649			.hirange:   
3649 e5					push hl  
364a b7					or a  
364b ed 52		                sbc hl, de 
364d			 
364d					;call cmp16 
364d			 
364d 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
364f e1					pop hl 
3650 e5					push hl 
3651			 
3651					if DEBUG_FORTH_WORDS 
3651						DMARK "RN4" 
3651 f5				push af  
3652 3a 66 36			ld a, (.dmark)  
3655 32 77 fb			ld (debug_mark),a  
3658 3a 67 36			ld a, (.dmark+1)  
365b 32 78 fb			ld (debug_mark+1),a  
365e 3a 68 36			ld a, (.dmark+2)  
3661 32 79 fb			ld (debug_mark+2),a  
3664 18 03			jr .pastdmark  
3666 ..			.dmark: db "RN4"  
3669 f1			.pastdmark: pop af  
366a			endm  
# End of macro DMARK
366a						CALLMONITOR 
366a cd 00 14			call break_point_state  
366d				endm  
# End of macro CALLMONITOR
366d					endif 
366d ed 5b be f8			ld de, (LFSRSeed+2)   ; check low range 
3671					;call cmp16 
3671				 
3671 b7					or a  
3672 ed 52		                sbc hl, de 
3674 38 8c				jr c, .inrange 
3676			 
3676 e1					pop hl 
3677					 
3677					if DEBUG_FORTH_WORDS 
3677						DMARK "RNd" 
3677 f5				push af  
3678 3a 8c 36			ld a, (.dmark)  
367b 32 77 fb			ld (debug_mark),a  
367e 3a 8d 36			ld a, (.dmark+1)  
3681 32 78 fb			ld (debug_mark+1),a  
3684 3a 8e 36			ld a, (.dmark+2)  
3687 32 79 fb			ld (debug_mark+2),a  
368a 18 03			jr .pastdmark  
368c ..			.dmark: db "RNd"  
368f f1			.pastdmark: pop af  
3690			endm  
# End of macro DMARK
3690						CALLMONITOR 
3690 cd 00 14			call break_point_state  
3693				endm  
# End of macro CALLMONITOR
3693					endif 
3693			 
3693			 
3693 cd 9a 19				call forth_push_numhl 
3696				       NEXTW 
3696 c3 8b 1b			jp macro_next 
3699				endm 
# End of macro NEXTW
3699			 
3699			.ENDMATHS: 
3699			 
3699			; eof 
3699			 
# End of file forth_words_maths.asm
3699			include "forth_words_display.asm" 
3699			 
3699			; | ## Display Words 
3699			 
3699			.ATP: 
3699				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3699 62				db WORD_SYS_CORE+78             
369a 10 37			dw .FB            
369c 04				db 3 + 1 
369d .. 00			db "AT?",0              
36a1				endm 
# End of macro CWHEAD
36a1			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
36a1					if DEBUG_FORTH_WORDS_KEY 
36a1						DMARK "AT?" 
36a1 f5				push af  
36a2 3a b6 36			ld a, (.dmark)  
36a5 32 77 fb			ld (debug_mark),a  
36a8 3a b7 36			ld a, (.dmark+1)  
36ab 32 78 fb			ld (debug_mark+1),a  
36ae 3a b8 36			ld a, (.dmark+2)  
36b1 32 79 fb			ld (debug_mark+2),a  
36b4 18 03			jr .pastdmark  
36b6 ..			.dmark: db "AT?"  
36b9 f1			.pastdmark: pop af  
36ba			endm  
# End of macro DMARK
36ba						CALLMONITOR 
36ba cd 00 14			call break_point_state  
36bd				endm  
# End of macro CALLMONITOR
36bd					endif 
36bd 3a 5b f8				ld a, (f_cursor_ptr) 
36c0			 
36c0			if DEBUG_FORTH_WORDS 
36c0				DMARK "AT?" 
36c0 f5				push af  
36c1 3a d5 36			ld a, (.dmark)  
36c4 32 77 fb			ld (debug_mark),a  
36c7 3a d6 36			ld a, (.dmark+1)  
36ca 32 78 fb			ld (debug_mark+1),a  
36cd 3a d7 36			ld a, (.dmark+2)  
36d0 32 79 fb			ld (debug_mark+2),a  
36d3 18 03			jr .pastdmark  
36d5 ..			.dmark: db "AT?"  
36d8 f1			.pastdmark: pop af  
36d9			endm  
# End of macro DMARK
36d9				CALLMONITOR 
36d9 cd 00 14			call break_point_state  
36dc				endm  
# End of macro CALLMONITOR
36dc			endif	 
36dc					; count the number of rows 
36dc			 
36dc 06 00				ld b, 0 
36de 4f			.atpr:		ld c, a    ; save in case we go below zero 
36df d6 28				sub display_cols 
36e1 f2 e7 36				jp p, .atprunder 
36e4 04					inc b 
36e5 18 f7				jr .atpr 
36e7			.atprunder:	 
36e7			if DEBUG_FORTH_WORDS 
36e7				DMARK "A?2" 
36e7 f5				push af  
36e8 3a fc 36			ld a, (.dmark)  
36eb 32 77 fb			ld (debug_mark),a  
36ee 3a fd 36			ld a, (.dmark+1)  
36f1 32 78 fb			ld (debug_mark+1),a  
36f4 3a fe 36			ld a, (.dmark+2)  
36f7 32 79 fb			ld (debug_mark+2),a  
36fa 18 03			jr .pastdmark  
36fc ..			.dmark: db "A?2"  
36ff f1			.pastdmark: pop af  
3700			endm  
# End of macro DMARK
3700				CALLMONITOR 
3700 cd 00 14			call break_point_state  
3703				endm  
# End of macro CALLMONITOR
3703			endif	 
3703 26 00				ld h, 0 
3705 69					ld l, c 
3706 cd 9a 19				call forth_push_numhl 
3709 68					ld l, b  
370a cd 9a 19				call forth_push_numhl 
370d			 
370d			 
370d				NEXTW 
370d c3 8b 1b			jp macro_next 
3710				endm 
# End of macro NEXTW
3710			 
3710			.FB: 
3710				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3710 1b				db WORD_SYS_CORE+7             
3711 5e 37			dw .EMIT            
3713 03				db 2 + 1 
3714 .. 00			db "FB",0              
3717				endm 
# End of macro CWHEAD
3717			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3717			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3717			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3717			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3717					if DEBUG_FORTH_WORDS_KEY 
3717						DMARK "FB." 
3717 f5				push af  
3718 3a 2c 37			ld a, (.dmark)  
371b 32 77 fb			ld (debug_mark),a  
371e 3a 2d 37			ld a, (.dmark+1)  
3721 32 78 fb			ld (debug_mark+1),a  
3724 3a 2e 37			ld a, (.dmark+2)  
3727 32 79 fb			ld (debug_mark+2),a  
372a 18 03			jr .pastdmark  
372c ..			.dmark: db "FB."  
372f f1			.pastdmark: pop af  
3730			endm  
# End of macro DMARK
3730						CALLMONITOR 
3730 cd 00 14			call break_point_state  
3733				endm  
# End of macro CALLMONITOR
3733					endif 
3733			 
3733					FORTH_DSP_VALUEHL 
3733 cd 35 1a			call macro_dsp_valuehl 
3736				endm 
# End of macro FORTH_DSP_VALUEHL
3736			 
3736 7d					ld a, l 
3737 fe 01				cp 1 
3739 20 05				jr nz, .fbn1 
373b 21 1c fa				ld hl, display_fb1 
373e 18 15				jr .fbset 
3740 fe 02		.fbn1:		cp 2 
3742 20 05				jr nz, .fbn2 
3744 21 da f8				ld hl, display_fb2 
3747 18 0c				jr .fbset 
3749 fe 03		.fbn2:		cp 3 
374b 20 05				jr nz, .fbn3 
374d 21 7b f9				ld hl, display_fb3 
3750 18 03				jr .fbset 
3752			.fbn3:		 ; if invalid number select first 
3752 21 1c fa				ld hl, display_fb1 
3755 22 d8 f8		.fbset:		ld (display_fb_active), hl 
3758			 
3758					FORTH_DSP_POP 
3758 cd d1 1a			call macro_forth_dsp_pop 
375b				endm 
# End of macro FORTH_DSP_POP
375b			 
375b					NEXTW 
375b c3 8b 1b			jp macro_next 
375e				endm 
# End of macro NEXTW
375e			 
375e			 
375e			.EMIT: 
375e				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
375e 1b				db WORD_SYS_CORE+7             
375f af 37			dw .DOTH            
3761 05				db 4 + 1 
3762 .. 00			db "EMIT",0              
3767				endm 
# End of macro CWHEAD
3767			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3767					; get value off TOS and display it 
3767			 
3767					if DEBUG_FORTH_WORDS_KEY 
3767						DMARK "EMT" 
3767 f5				push af  
3768 3a 7c 37			ld a, (.dmark)  
376b 32 77 fb			ld (debug_mark),a  
376e 3a 7d 37			ld a, (.dmark+1)  
3771 32 78 fb			ld (debug_mark+1),a  
3774 3a 7e 37			ld a, (.dmark+2)  
3777 32 79 fb			ld (debug_mark+2),a  
377a 18 03			jr .pastdmark  
377c ..			.dmark: db "EMT"  
377f f1			.pastdmark: pop af  
3780			endm  
# End of macro DMARK
3780						CALLMONITOR 
3780 cd 00 14			call break_point_state  
3783				endm  
# End of macro CALLMONITOR
3783					endif 
3783			 
3783					FORTH_DSP_VALUEHL 
3783 cd 35 1a			call macro_dsp_valuehl 
3786				endm 
# End of macro FORTH_DSP_VALUEHL
3786			 
3786 7d					ld a,l 
3787			 
3787					; TODO write to display 
3787			 
3787 32 30 f0				ld (os_input), a 
378a 3e 00				ld a, 0 
378c 32 31 f0				ld (os_input+1), a 
378f					 
378f 3a 5b f8				ld a, (f_cursor_ptr) 
3792 11 30 f0				ld de, os_input 
3795 cd cc 0a				call str_at_display 
3798			 
3798			 
3798 3a 39 f8				ld a,(cli_autodisplay) 
379b fe 00				cp 0 
379d 28 03				jr z, .enoupdate 
379f cd dc 0a						call update_display 
37a2					.enoupdate: 
37a2			 
37a2 3a 5b f8				ld a, (f_cursor_ptr) 
37a5 3c					inc a 
37a6 32 5b f8				ld (f_cursor_ptr), a   ; save new pos 
37a9			 
37a9			 
37a9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37a9 cd d1 1a			call macro_forth_dsp_pop 
37ac				endm 
# End of macro FORTH_DSP_POP
37ac			  
37ac			 
37ac					NEXTW 
37ac c3 8b 1b			jp macro_next 
37af				endm 
# End of macro NEXTW
37af			.DOTH: 
37af				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
37af 1c				db WORD_SYS_CORE+8             
37b0 df 37			dw .DOTF            
37b2 03				db 2 + 1 
37b3 .. 00			db ".-",0              
37b6				endm 
# End of macro CWHEAD
37b6			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
37b6					; get value off TOS and display it 
37b6					if DEBUG_FORTH_WORDS_KEY 
37b6						DMARK "DTD" 
37b6 f5				push af  
37b7 3a cb 37			ld a, (.dmark)  
37ba 32 77 fb			ld (debug_mark),a  
37bd 3a cc 37			ld a, (.dmark+1)  
37c0 32 78 fb			ld (debug_mark+1),a  
37c3 3a cd 37			ld a, (.dmark+2)  
37c6 32 79 fb			ld (debug_mark+2),a  
37c9 18 03			jr .pastdmark  
37cb ..			.dmark: db "DTD"  
37ce f1			.pastdmark: pop af  
37cf			endm  
# End of macro DMARK
37cf						CALLMONITOR 
37cf cd 00 14			call break_point_state  
37d2				endm  
# End of macro CALLMONITOR
37d2					endif 
37d2 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
37d4 3e 00			ld a, 0 
37d6 32 3a f8			ld (cli_mvdot), a 
37d9 c3 36 38			jp .dotgo 
37dc				NEXTW 
37dc c3 8b 1b			jp macro_next 
37df				endm 
# End of macro NEXTW
37df			.DOTF: 
37df				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
37df 1c				db WORD_SYS_CORE+8             
37e0 0d 38			dw .DOT            
37e2 03				db 2 + 1 
37e3 .. 00			db ".>",0              
37e6				endm 
# End of macro CWHEAD
37e6			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
37e6					; get value off TOS and display it 
37e6			        ; TODO BUG adds extra spaces 
37e6			        ; TODO BUG handle numerics? 
37e6					if DEBUG_FORTH_WORDS_KEY 
37e6						DMARK "DTC" 
37e6 f5				push af  
37e7 3a fb 37			ld a, (.dmark)  
37ea 32 77 fb			ld (debug_mark),a  
37ed 3a fc 37			ld a, (.dmark+1)  
37f0 32 78 fb			ld (debug_mark+1),a  
37f3 3a fd 37			ld a, (.dmark+2)  
37f6 32 79 fb			ld (debug_mark+2),a  
37f9 18 03			jr .pastdmark  
37fb ..			.dmark: db "DTC"  
37fe f1			.pastdmark: pop af  
37ff			endm  
# End of macro DMARK
37ff						CALLMONITOR 
37ff cd 00 14			call break_point_state  
3802				endm  
# End of macro CALLMONITOR
3802					endif 
3802 3e 01			ld a, 1 
3804 32 3a f8			ld (cli_mvdot), a 
3807 c3 36 38			jp .dotgo 
380a				NEXTW 
380a c3 8b 1b			jp macro_next 
380d				endm 
# End of macro NEXTW
380d			 
380d			.DOT: 
380d				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
380d 1c				db WORD_SYS_CORE+8             
380e 99 38			dw .CLS            
3810 02				db 1 + 1 
3811 .. 00			db ".",0              
3813				endm 
# End of macro CWHEAD
3813			        ; | . ( u -- ) Display TOS | DONE 
3813					; get value off TOS and display it 
3813			 
3813					if DEBUG_FORTH_WORDS_KEY 
3813						DMARK "DOT" 
3813 f5				push af  
3814 3a 28 38			ld a, (.dmark)  
3817 32 77 fb			ld (debug_mark),a  
381a 3a 29 38			ld a, (.dmark+1)  
381d 32 78 fb			ld (debug_mark+1),a  
3820 3a 2a 38			ld a, (.dmark+2)  
3823 32 79 fb			ld (debug_mark+2),a  
3826 18 03			jr .pastdmark  
3828 ..			.dmark: db "DOT"  
382b f1			.pastdmark: pop af  
382c			endm  
# End of macro DMARK
382c						CALLMONITOR 
382c cd 00 14			call break_point_state  
382f				endm  
# End of macro CALLMONITOR
382f					endif 
382f 3e 00			ld a, 0 
3831 32 3a f8			ld (cli_mvdot), a 
3834 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3836				 
3836			 
3836			.dotgo: 
3836			 
3836			; move up type to on stack for parserv5 
3836					FORTH_DSP 
3836 cd 1a 1a			call macro_forth_dsp 
3839				endm 
# End of macro FORTH_DSP
3839				;FORTH_DSP_VALUE  
3839			 
3839			if DEBUG_FORTH_DOT 
3839				DMARK "DOT" 
3839				CALLMONITOR 
3839			endif	 
3839			;		.print: 
3839			 
3839 7e				ld a,(hl)  ; work out what type of value is on the TOS 
383a 23				inc hl   ; position to the actual value 
383b fe 01			cp DS_TYPE_STR 
383d 20 06			jr nz, .dotnum1  
383f			 
383f			; display string 
383f				FORTH_DSP_VALUE  
383f cd 1e 1a			call macro_forth_dsp_value 
3842				endm 
# End of macro FORTH_DSP_VALUE
3842 eb				ex de,hl 
3843 18 11			jr .dotwrite 
3845			 
3845			.dotnum1: 
3845 fe 02			cp DS_TYPE_INUM 
3847 20 0c			jr nz, .dotflot 
3849			 
3849			 
3849			; display number 
3849			 
3849			;	push hl 
3849			;	call clear_display 
3849			;	pop hl 
3849			 
3849 5e				ld e, (hl) 
384a 23				inc hl 
384b 56				ld d, (hl) 
384c 21 32 ee			ld hl, scratch 
384f			if DEBUG_FORTH_DOT 
384f				DMARK "DT1" 
384f				CALLMONITOR 
384f			endif	 
384f			 
384f cd 1f 10			call uitoa_16 
3852 eb				ex de,hl 
3853			 
3853			if DEBUG_FORTH_DOT 
3853				DMARK "DT2" 
3853				CALLMONITOR 
3853			endif	 
3853			 
3853			;	ld de, os_word_scratch 
3853 18 01			jr .dotwrite 
3855			 
3855 00			.dotflot:   nop 
3856			; TODO print floating point number 
3856			 
3856			.dotwrite:		 
3856			 
3856					; if c is set then set all '-' to spaces 
3856					; need to also take into account .>  
3856			 
3856 3e 01				ld a, 1 
3858 b9					cp c 
3859 20 13				jr nz, .nodashswap 
385b			 
385b					; DE has the string to write, working with HL 
385b			 
385b 06 ff				ld b, 255 
385d d5					push de 
385e e1					pop hl 
385f			 
385f			if DEBUG_FORTH_DOT 
385f				DMARK "DT-" 
385f				CALLMONITOR 
385f			endif	 
385f 7e			.dashscan:	ld a, (hl) 
3860 fe 00				cp 0 
3862 28 0a				jr z, .nodashswap 
3864 fe 2d				cp '-' 
3866 20 03				jr nz, .dashskip 
3868 3e 20				ld a, ' ' 
386a 77					ld (hl), a 
386b 23			.dashskip:	inc hl 
386c			if DEBUG_FORTH_DOT 
386c				DMARK "D-2" 
386c				CALLMONITOR 
386c			endif	 
386c 10 f1				djnz .dashscan 
386e			 
386e			if DEBUG_FORTH_DOT 
386e				DMARK "D-1" 
386e				CALLMONITOR 
386e			endif	 
386e			 
386e			.nodashswap: 
386e			 
386e e5					push hl   ; save string start in case we need to advance print 
386f			 
386f 3a 5b f8				ld a, (f_cursor_ptr) 
3872 cd cc 0a				call str_at_display 
3875 3a 39 f8				ld a,(cli_autodisplay) 
3878 fe 00				cp 0 
387a 28 03				jr z, .noupdate 
387c cd dc 0a						call update_display 
387f					.noupdate: 
387f			 
387f			 
387f					; see if we need to advance the print position 
387f			 
387f e1					pop hl   ; get back string 
3880			 
3880 3a 3a f8				ld a, (cli_mvdot) 
3883			if DEBUG_FORTH_DOT 
3883					ld e,a 
3883				DMARK "D>1" 
3883				CALLMONITOR 
3883			endif	 
3883 fe 00				cp 0 
3885 28 0c				jr z, .noadv 
3887					; yes, lets advance the print position 
3887 3e 00				ld a, 0 
3889 cd 7b 10				call strlent 
388c 3a 5b f8				ld a, (f_cursor_ptr) 
388f 85					add a,l 
3890					;call addatohl 
3890					;ld a, l 
3890 32 5b f8				ld (f_cursor_ptr), a   ; save new pos 
3893			 
3893			if DEBUG_FORTH_DOT 
3893				DMARK "D->" 
3893				CALLMONITOR 
3893			endif	 
3893			 
3893			.noadv:	 
3893			 
3893					if DEBUG_FORTH_DOT_WAIT 
3893							call next_page_prompt 
3893					endif	 
3893			; TODO this pop off the stack causes a crash. i dont know why 
3893			 
3893			 
3893			if DEBUG_FORTH_DOT 
3893				DMARK "DTh" 
3893				CALLMONITOR 
3893			endif	 
3893			 
3893					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3893 cd d1 1a			call macro_forth_dsp_pop 
3896				endm 
# End of macro FORTH_DSP_POP
3896			 
3896			if DEBUG_FORTH_DOT 
3896				DMARK "DTi" 
3896				CALLMONITOR 
3896			endif	 
3896			 
3896			 
3896					NEXTW 
3896 c3 8b 1b			jp macro_next 
3899				endm 
# End of macro NEXTW
3899			 
3899			.CLS: 
3899				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3899 35				db WORD_SYS_CORE+33             
389a c6 38			dw .DRAW            
389c 04				db 3 + 1 
389d .. 00			db "CLS",0              
38a1				endm 
# End of macro CWHEAD
38a1			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
38a1					if DEBUG_FORTH_WORDS_KEY 
38a1						DMARK "CLS" 
38a1 f5				push af  
38a2 3a b6 38			ld a, (.dmark)  
38a5 32 77 fb			ld (debug_mark),a  
38a8 3a b7 38			ld a, (.dmark+1)  
38ab 32 78 fb			ld (debug_mark+1),a  
38ae 3a b8 38			ld a, (.dmark+2)  
38b1 32 79 fb			ld (debug_mark+2),a  
38b4 18 03			jr .pastdmark  
38b6 ..			.dmark: db "CLS"  
38b9 f1			.pastdmark: pop af  
38ba			endm  
# End of macro DMARK
38ba						CALLMONITOR 
38ba cd 00 14			call break_point_state  
38bd				endm  
# End of macro CALLMONITOR
38bd					endif 
38bd cd b9 0a				call clear_display 
38c0 c3 d4 39				jp .home		; and home cursor 
38c3					NEXTW 
38c3 c3 8b 1b			jp macro_next 
38c6				endm 
# End of macro NEXTW
38c6			 
38c6			.DRAW: 
38c6				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
38c6 36				db WORD_SYS_CORE+34             
38c7 f1 38			dw .DUMP            
38c9 05				db 4 + 1 
38ca .. 00			db "DRAW",0              
38cf				endm 
# End of macro CWHEAD
38cf			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
38cf					if DEBUG_FORTH_WORDS_KEY 
38cf						DMARK "DRW" 
38cf f5				push af  
38d0 3a e4 38			ld a, (.dmark)  
38d3 32 77 fb			ld (debug_mark),a  
38d6 3a e5 38			ld a, (.dmark+1)  
38d9 32 78 fb			ld (debug_mark+1),a  
38dc 3a e6 38			ld a, (.dmark+2)  
38df 32 79 fb			ld (debug_mark+2),a  
38e2 18 03			jr .pastdmark  
38e4 ..			.dmark: db "DRW"  
38e7 f1			.pastdmark: pop af  
38e8			endm  
# End of macro DMARK
38e8						CALLMONITOR 
38e8 cd 00 14			call break_point_state  
38eb				endm  
# End of macro CALLMONITOR
38eb					endif 
38eb cd dc 0a				call update_display 
38ee					NEXTW 
38ee c3 8b 1b			jp macro_next 
38f1				endm 
# End of macro NEXTW
38f1			 
38f1			.DUMP: 
38f1				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
38f1 37				db WORD_SYS_CORE+35             
38f2 29 39			dw .CDUMP            
38f4 05				db 4 + 1 
38f5 .. 00			db "DUMP",0              
38fa				endm 
# End of macro CWHEAD
38fa			; | DUMP ( x -- ) With address x display dump   | DONE 
38fa			; TODO pop address to use off of the stack 
38fa					if DEBUG_FORTH_WORDS_KEY 
38fa						DMARK "DUM" 
38fa f5				push af  
38fb 3a 0f 39			ld a, (.dmark)  
38fe 32 77 fb			ld (debug_mark),a  
3901 3a 10 39			ld a, (.dmark+1)  
3904 32 78 fb			ld (debug_mark+1),a  
3907 3a 11 39			ld a, (.dmark+2)  
390a 32 79 fb			ld (debug_mark+2),a  
390d 18 03			jr .pastdmark  
390f ..			.dmark: db "DUM"  
3912 f1			.pastdmark: pop af  
3913			endm  
# End of macro DMARK
3913						CALLMONITOR 
3913 cd 00 14			call break_point_state  
3916				endm  
# End of macro CALLMONITOR
3916					endif 
3916 cd b9 0a				call clear_display 
3919			 
3919					; get address 
3919			 
3919					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3919 cd 35 1a			call macro_dsp_valuehl 
391c				endm 
# End of macro FORTH_DSP_VALUEHL
391c				 
391c					; save it for cdump 
391c			 
391c 22 55 f1				ld (os_cur_ptr),hl 
391f			 
391f					; destroy value TOS 
391f			 
391f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
391f cd d1 1a			call macro_forth_dsp_pop 
3922				endm 
# End of macro FORTH_DSP_POP
3922			 
3922 cd 1a 18				call dumpcont	; skip old style of param parsing	 
3925 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3926					NEXTW 
3926 c3 8b 1b			jp macro_next 
3929				endm 
# End of macro NEXTW
3929			.CDUMP: 
3929				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3929 38				db WORD_SYS_CORE+36             
392a 59 39			dw .DAT            
392c 06				db 5 + 1 
392d .. 00			db "CDUMP",0              
3933				endm 
# End of macro CWHEAD
3933			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3933					if DEBUG_FORTH_WORDS_KEY 
3933						DMARK "CDP" 
3933 f5				push af  
3934 3a 48 39			ld a, (.dmark)  
3937 32 77 fb			ld (debug_mark),a  
393a 3a 49 39			ld a, (.dmark+1)  
393d 32 78 fb			ld (debug_mark+1),a  
3940 3a 4a 39			ld a, (.dmark+2)  
3943 32 79 fb			ld (debug_mark+2),a  
3946 18 03			jr .pastdmark  
3948 ..			.dmark: db "CDP"  
394b f1			.pastdmark: pop af  
394c			endm  
# End of macro DMARK
394c						CALLMONITOR 
394c cd 00 14			call break_point_state  
394f				endm  
# End of macro CALLMONITOR
394f					endif 
394f cd b9 0a				call clear_display 
3952 cd 1a 18				call dumpcont	 
3955 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3956					NEXTW 
3956 c3 8b 1b			jp macro_next 
3959				endm 
# End of macro NEXTW
3959			 
3959			 
3959			 
3959			 
3959			.DAT: 
3959				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3959 3d				db WORD_SYS_CORE+41             
395a af 39			dw .HOME            
395c 03				db 2 + 1 
395d .. 00			db "AT",0              
3960				endm 
# End of macro CWHEAD
3960			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3960					if DEBUG_FORTH_WORDS_KEY 
3960						DMARK "AT." 
3960 f5				push af  
3961 3a 75 39			ld a, (.dmark)  
3964 32 77 fb			ld (debug_mark),a  
3967 3a 76 39			ld a, (.dmark+1)  
396a 32 78 fb			ld (debug_mark+1),a  
396d 3a 77 39			ld a, (.dmark+2)  
3970 32 79 fb			ld (debug_mark+2),a  
3973 18 03			jr .pastdmark  
3975 ..			.dmark: db "AT."  
3978 f1			.pastdmark: pop af  
3979			endm  
# End of macro DMARK
3979						CALLMONITOR 
3979 cd 00 14			call break_point_state  
397c				endm  
# End of macro CALLMONITOR
397c					endif 
397c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
397c cd 35 1a			call macro_dsp_valuehl 
397f				endm 
# End of macro FORTH_DSP_VALUEHL
397f			 
397f			 
397f					; TODO save cursor row 
397f 7d					ld a,l 
3980 fe 02				cp 2 
3982 20 04				jr nz, .crow3 
3984 3e 28				ld a, display_row_2 
3986 18 12				jr .ccol1 
3988 fe 03		.crow3:		cp 3 
398a 20 04				jr nz, .crow4 
398c 3e 50				ld a, display_row_3 
398e 18 0a				jr .ccol1 
3990 fe 04		.crow4:		cp 4 
3992 20 04				jr nz, .crow1 
3994 3e 78				ld a, display_row_4 
3996 18 02				jr .ccol1 
3998 3e 00		.crow1:		ld a,display_row_1 
399a f5			.ccol1:		push af			; got row offset 
399b 6f					ld l,a 
399c 26 00				ld h,0 
399e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
399e cd d1 1a			call macro_forth_dsp_pop 
39a1				endm 
# End of macro FORTH_DSP_POP
39a1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39a1 cd 35 1a			call macro_dsp_valuehl 
39a4				endm 
# End of macro FORTH_DSP_VALUEHL
39a4					; TODO save cursor col 
39a4 f1					pop af 
39a5 85					add l		; add col offset 
39a6 32 5b f8				ld (f_cursor_ptr), a 
39a9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39a9 cd d1 1a			call macro_forth_dsp_pop 
39ac				endm 
# End of macro FORTH_DSP_POP
39ac			 
39ac					; calculate  
39ac			 
39ac					NEXTW 
39ac c3 8b 1b			jp macro_next 
39af				endm 
# End of macro NEXTW
39af			 
39af			 
39af			.HOME: 
39af				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
39af 41				db WORD_SYS_CORE+45             
39b0 dc 39			dw .SPACE            
39b2 05				db 4 + 1 
39b3 .. 00			db "HOME",0              
39b8				endm 
# End of macro CWHEAD
39b8			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
39b8					if DEBUG_FORTH_WORDS_KEY 
39b8						DMARK "HOM" 
39b8 f5				push af  
39b9 3a cd 39			ld a, (.dmark)  
39bc 32 77 fb			ld (debug_mark),a  
39bf 3a ce 39			ld a, (.dmark+1)  
39c2 32 78 fb			ld (debug_mark+1),a  
39c5 3a cf 39			ld a, (.dmark+2)  
39c8 32 79 fb			ld (debug_mark+2),a  
39cb 18 03			jr .pastdmark  
39cd ..			.dmark: db "HOM"  
39d0 f1			.pastdmark: pop af  
39d1			endm  
# End of macro DMARK
39d1						CALLMONITOR 
39d1 cd 00 14			call break_point_state  
39d4				endm  
# End of macro CALLMONITOR
39d4					endif 
39d4 3e 00		.home:		ld a, 0		; and home cursor 
39d6 32 5b f8				ld (f_cursor_ptr), a 
39d9					NEXTW 
39d9 c3 8b 1b			jp macro_next 
39dc				endm 
# End of macro NEXTW
39dc			 
39dc			 
39dc			.SPACE: 
39dc				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
39dc 46				db WORD_SYS_CORE+50             
39dd 0a 3a			dw .SPACES            
39df 03				db 2 + 1 
39e0 .. 00			db "BL",0              
39e3				endm 
# End of macro CWHEAD
39e3			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
39e3					if DEBUG_FORTH_WORDS_KEY 
39e3						DMARK "BL." 
39e3 f5				push af  
39e4 3a f8 39			ld a, (.dmark)  
39e7 32 77 fb			ld (debug_mark),a  
39ea 3a f9 39			ld a, (.dmark+1)  
39ed 32 78 fb			ld (debug_mark+1),a  
39f0 3a fa 39			ld a, (.dmark+2)  
39f3 32 79 fb			ld (debug_mark+2),a  
39f6 18 03			jr .pastdmark  
39f8 ..			.dmark: db "BL."  
39fb f1			.pastdmark: pop af  
39fc			endm  
# End of macro DMARK
39fc						CALLMONITOR 
39fc cd 00 14			call break_point_state  
39ff				endm  
# End of macro CALLMONITOR
39ff					endif 
39ff 21 08 3a				ld hl, .blstr 
3a02 cd ac 19				call forth_push_str 
3a05					 
3a05				       NEXTW 
3a05 c3 8b 1b			jp macro_next 
3a08				endm 
# End of macro NEXTW
3a08			 
3a08 .. 00		.blstr: db " ", 0 
3a0a			 
3a0a			.SPACES: 
3a0a				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3a0a 47				db WORD_SYS_CORE+51             
3a0b a5 3a			dw .SCROLL            
3a0d 07				db 6 + 1 
3a0e .. 00			db "SPACES",0              
3a15				endm 
# End of macro CWHEAD
3a15			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
3a15					if DEBUG_FORTH_WORDS_KEY 
3a15						DMARK "SPS" 
3a15 f5				push af  
3a16 3a 2a 3a			ld a, (.dmark)  
3a19 32 77 fb			ld (debug_mark),a  
3a1c 3a 2b 3a			ld a, (.dmark+1)  
3a1f 32 78 fb			ld (debug_mark+1),a  
3a22 3a 2c 3a			ld a, (.dmark+2)  
3a25 32 79 fb			ld (debug_mark+2),a  
3a28 18 03			jr .pastdmark  
3a2a ..			.dmark: db "SPS"  
3a2d f1			.pastdmark: pop af  
3a2e			endm  
# End of macro DMARK
3a2e						CALLMONITOR 
3a2e cd 00 14			call break_point_state  
3a31				endm  
# End of macro CALLMONITOR
3a31					endif 
3a31			 
3a31			 
3a31					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a31 cd 35 1a			call macro_dsp_valuehl 
3a34				endm 
# End of macro FORTH_DSP_VALUEHL
3a34			 
3a34			;		push hl    ; u 
3a34					if DEBUG_FORTH_WORDS 
3a34						DMARK "SPA" 
3a34 f5				push af  
3a35 3a 49 3a			ld a, (.dmark)  
3a38 32 77 fb			ld (debug_mark),a  
3a3b 3a 4a 3a			ld a, (.dmark+1)  
3a3e 32 78 fb			ld (debug_mark+1),a  
3a41 3a 4b 3a			ld a, (.dmark+2)  
3a44 32 79 fb			ld (debug_mark+2),a  
3a47 18 03			jr .pastdmark  
3a49 ..			.dmark: db "SPA"  
3a4c f1			.pastdmark: pop af  
3a4d			endm  
# End of macro DMARK
3a4d						CALLMONITOR 
3a4d cd 00 14			call break_point_state  
3a50				endm  
# End of macro CALLMONITOR
3a50					endif 
3a50			 
3a50					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a50 cd d1 1a			call macro_forth_dsp_pop 
3a53				endm 
# End of macro FORTH_DSP_POP
3a53			;		pop hl 
3a53 4d					ld c, l 
3a54 06 00				ld b, 0 
3a56 21 32 ee				ld hl, scratch  
3a59			 
3a59					if DEBUG_FORTH_WORDS 
3a59						DMARK "SP2" 
3a59 f5				push af  
3a5a 3a 6e 3a			ld a, (.dmark)  
3a5d 32 77 fb			ld (debug_mark),a  
3a60 3a 6f 3a			ld a, (.dmark+1)  
3a63 32 78 fb			ld (debug_mark+1),a  
3a66 3a 70 3a			ld a, (.dmark+2)  
3a69 32 79 fb			ld (debug_mark+2),a  
3a6c 18 03			jr .pastdmark  
3a6e ..			.dmark: db "SP2"  
3a71 f1			.pastdmark: pop af  
3a72			endm  
# End of macro DMARK
3a72						CALLMONITOR 
3a72 cd 00 14			call break_point_state  
3a75				endm  
# End of macro CALLMONITOR
3a75					endif 
3a75 3e 20				ld a, ' ' 
3a77 c5			.spaces1:	push bc 
3a78 77					ld (hl),a 
3a79 23					inc hl 
3a7a c1					pop bc 
3a7b 10 fa				djnz .spaces1 
3a7d 3e 00				ld a,0 
3a7f 77					ld (hl),a 
3a80 21 32 ee				ld hl, scratch 
3a83					if DEBUG_FORTH_WORDS 
3a83						DMARK "SP3" 
3a83 f5				push af  
3a84 3a 98 3a			ld a, (.dmark)  
3a87 32 77 fb			ld (debug_mark),a  
3a8a 3a 99 3a			ld a, (.dmark+1)  
3a8d 32 78 fb			ld (debug_mark+1),a  
3a90 3a 9a 3a			ld a, (.dmark+2)  
3a93 32 79 fb			ld (debug_mark+2),a  
3a96 18 03			jr .pastdmark  
3a98 ..			.dmark: db "SP3"  
3a9b f1			.pastdmark: pop af  
3a9c			endm  
# End of macro DMARK
3a9c						CALLMONITOR 
3a9c cd 00 14			call break_point_state  
3a9f				endm  
# End of macro CALLMONITOR
3a9f					endif 
3a9f cd e2 19				call forth_apush 
3aa2			 
3aa2				       NEXTW 
3aa2 c3 8b 1b			jp macro_next 
3aa5				endm 
# End of macro NEXTW
3aa5			 
3aa5			 
3aa5			 
3aa5			.SCROLL: 
3aa5				CWHEAD .ATQ 63 "SCROLL" 6 WORD_FLAG_CODE 
3aa5 53				db WORD_SYS_CORE+63             
3aa6 d2 3a			dw .ATQ            
3aa8 07				db 6 + 1 
3aa9 .. 00			db "SCROLL",0              
3ab0				endm 
# End of macro CWHEAD
3ab0			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
3ab0					if DEBUG_FORTH_WORDS_KEY 
3ab0						DMARK "SCR" 
3ab0 f5				push af  
3ab1 3a c5 3a			ld a, (.dmark)  
3ab4 32 77 fb			ld (debug_mark),a  
3ab7 3a c6 3a			ld a, (.dmark+1)  
3aba 32 78 fb			ld (debug_mark+1),a  
3abd 3a c7 3a			ld a, (.dmark+2)  
3ac0 32 79 fb			ld (debug_mark+2),a  
3ac3 18 03			jr .pastdmark  
3ac5 ..			.dmark: db "SCR"  
3ac8 f1			.pastdmark: pop af  
3ac9			endm  
# End of macro DMARK
3ac9						CALLMONITOR 
3ac9 cd 00 14			call break_point_state  
3acc				endm  
# End of macro CALLMONITOR
3acc					endif 
3acc			 
3acc cd 51 0a			call scroll_up 
3acf			;	call update_display 
3acf			 
3acf					NEXTW 
3acf c3 8b 1b			jp macro_next 
3ad2				endm 
# End of macro NEXTW
3ad2			 
3ad2			 
3ad2			 
3ad2			;		; get dir 
3ad2			; 
3ad2			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ad2			; 
3ad2			;		push hl 
3ad2			; 
3ad2			;		; destroy value TOS 
3ad2			; 
3ad2			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ad2			; 
3ad2			;		; get count 
3ad2			; 
3ad2			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ad2			; 
3ad2			;		push hl 
3ad2			; 
3ad2			;		; destroy value TOS 
3ad2			; 
3ad2			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ad2			; 
3ad2			;		; one value on hl get other one back 
3ad2			; 
3ad2			;		pop bc    ; count 
3ad2			; 
3ad2			;		pop de   ; dir 
3ad2			; 
3ad2			; 
3ad2			;		ld b, c 
3ad2			; 
3ad2			;.scrolldir:     push bc 
3ad2			;		push de 
3ad2			; 
3ad2			;		ld a, 0 
3ad2			;		cp e 
3ad2			;		jr z, .scrollup  
3ad2			;		call scroll_down 
3ad2			;		jr .scrollnext 
3ad2			;.scrollup:	call scroll_up 
3ad2			; 
3ad2			;		 
3ad2			;.scrollnext: 
3ad2			;		pop de 
3ad2			;		pop bc 
3ad2			;		djnz .scrolldir 
3ad2			; 
3ad2			; 
3ad2			; 
3ad2			; 
3ad2			; 
3ad2			;		NEXTW 
3ad2			 
3ad2			 
3ad2			 
3ad2			 
3ad2			.ATQ: 
3ad2				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
3ad2 62				db WORD_SYS_CORE+78             
3ad3 30 3b			dw .AUTODSP            
3ad5 04				db 3 + 1 
3ad6 .. 00			db "AT@",0              
3ada				endm 
# End of macro CWHEAD
3ada			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
3ada					if DEBUG_FORTH_WORDS_KEY 
3ada						DMARK "ATA" 
3ada f5				push af  
3adb 3a ef 3a			ld a, (.dmark)  
3ade 32 77 fb			ld (debug_mark),a  
3ae1 3a f0 3a			ld a, (.dmark+1)  
3ae4 32 78 fb			ld (debug_mark+1),a  
3ae7 3a f1 3a			ld a, (.dmark+2)  
3aea 32 79 fb			ld (debug_mark+2),a  
3aed 18 03			jr .pastdmark  
3aef ..			.dmark: db "ATA"  
3af2 f1			.pastdmark: pop af  
3af3			endm  
# End of macro DMARK
3af3						CALLMONITOR 
3af3 cd 00 14			call break_point_state  
3af6				endm  
# End of macro CALLMONITOR
3af6					endif 
3af6			 
3af6			 
3af6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3af6 cd 35 1a			call macro_dsp_valuehl 
3af9				endm 
# End of macro FORTH_DSP_VALUEHL
3af9			 
3af9					; TODO save cursor row 
3af9 7d					ld a,l 
3afa fe 02				cp 2 
3afc 20 04				jr nz, .crow3aq 
3afe 3e 28				ld a, display_row_2 
3b00 18 12				jr .ccol1aq 
3b02 fe 03		.crow3aq:		cp 3 
3b04 20 04				jr nz, .crow4aq 
3b06 3e 50				ld a, display_row_3 
3b08 18 0a				jr .ccol1aq 
3b0a fe 04		.crow4aq:		cp 4 
3b0c 20 04				jr nz, .crow1aq 
3b0e 3e 78				ld a, display_row_4 
3b10 18 02				jr .ccol1aq 
3b12 3e 00		.crow1aq:		ld a,display_row_1 
3b14 f5			.ccol1aq:		push af			; got row offset 
3b15 6f					ld l,a 
3b16 26 00				ld h,0 
3b18					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b18 cd d1 1a			call macro_forth_dsp_pop 
3b1b				endm 
# End of macro FORTH_DSP_POP
3b1b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b1b cd 35 1a			call macro_dsp_valuehl 
3b1e				endm 
# End of macro FORTH_DSP_VALUEHL
3b1e					; TODO save cursor col 
3b1e f1					pop af 
3b1f 85					add l		; add col offset 
3b20			 
3b20					; add current frame buffer address 
3b20 2a d8 f8				ld hl, (display_fb_active) 
3b23 cd 12 0c				call addatohl 
3b26			 
3b26			 
3b26			 
3b26			 
3b26					; get char frame buffer location offset in hl 
3b26			 
3b26 7e					ld a,(hl) 
3b27 26 00				ld h, 0 
3b29 6f					ld l, a 
3b2a			 
3b2a cd 9a 19				call forth_push_numhl 
3b2d			 
3b2d			 
3b2d					NEXTW 
3b2d c3 8b 1b			jp macro_next 
3b30				endm 
# End of macro NEXTW
3b30			 
3b30			.AUTODSP: 
3b30				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
3b30 63				db WORD_SYS_CORE+79             
3b31 46 3b			dw .MENU            
3b33 05				db 4 + 1 
3b34 .. 00			db "ADSP",0              
3b39				endm 
# End of macro CWHEAD
3b39			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
3b39			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
3b39			 
3b39					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b39 cd 35 1a			call macro_dsp_valuehl 
3b3c				endm 
# End of macro FORTH_DSP_VALUEHL
3b3c			 
3b3c			;		push hl 
3b3c			 
3b3c					; destroy value TOS 
3b3c			 
3b3c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b3c cd d1 1a			call macro_forth_dsp_pop 
3b3f				endm 
# End of macro FORTH_DSP_POP
3b3f			 
3b3f			;		pop hl 
3b3f			 
3b3f 7d					ld a,l 
3b40 32 39 f8				ld (cli_autodisplay), a 
3b43				       NEXTW 
3b43 c3 8b 1b			jp macro_next 
3b46				endm 
# End of macro NEXTW
3b46			 
3b46			.MENU: 
3b46				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
3b46 70				db WORD_SYS_CORE+92             
3b47 52 3b			dw .ENDDISPLAY            
3b49 05				db 4 + 1 
3b4a .. 00			db "MENU",0              
3b4f				endm 
# End of macro CWHEAD
3b4f			; | MENU ( u1....ux n ut -- n ) Create a menu. Ut is the title, n is the number of menu items on stack. Push number selection to TOS | TODO 
3b4f			 
3b4f					; get the title address and save it 
3b4f			 
3b4f			;		FORTH_DSP_VALUEHL 
3b4f			;		push hl 
3b4f			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b4f			; 
3b4f			;		; get number of items on the stack 
3b4f			; 
3b4f			;	 
3b4f			;		FORTH_DSP_VALUEHL 
3b4f			;		push hl 
3b4f			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b4f			 
3b4f			 
3b4f			 
3b4f			 
3b4f				       NEXTW 
3b4f c3 8b 1b			jp macro_next 
3b52				endm 
# End of macro NEXTW
3b52			 
3b52			 
3b52			.ENDDISPLAY: 
3b52			 
3b52			; eof 
# End of file forth_words_display.asm
3b52			include "forth_words_str.asm" 
3b52			 
3b52			; | ## String Words 
3b52			 
3b52			.PTR:   
3b52			 
3b52				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
3b52 48				db WORD_SYS_CORE+52             
3b53 7f 3b			dw .STYPE            
3b55 04				db 3 + 1 
3b56 .. 00			db "PTR",0              
3b5a				endm 
# End of macro CWHEAD
3b5a			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
3b5a			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
3b5a			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
3b5a			 
3b5a					if DEBUG_FORTH_WORDS_KEY 
3b5a						DMARK "PTR" 
3b5a f5				push af  
3b5b 3a 6f 3b			ld a, (.dmark)  
3b5e 32 77 fb			ld (debug_mark),a  
3b61 3a 70 3b			ld a, (.dmark+1)  
3b64 32 78 fb			ld (debug_mark+1),a  
3b67 3a 71 3b			ld a, (.dmark+2)  
3b6a 32 79 fb			ld (debug_mark+2),a  
3b6d 18 03			jr .pastdmark  
3b6f ..			.dmark: db "PTR"  
3b72 f1			.pastdmark: pop af  
3b73			endm  
# End of macro DMARK
3b73						CALLMONITOR 
3b73 cd 00 14			call break_point_state  
3b76				endm  
# End of macro CALLMONITOR
3b76					endif 
3b76					FORTH_DSP_VALUEHL 
3b76 cd 35 1a			call macro_dsp_valuehl 
3b79				endm 
# End of macro FORTH_DSP_VALUEHL
3b79 cd 9a 19				call forth_push_numhl 
3b7c			 
3b7c			 
3b7c					NEXTW 
3b7c c3 8b 1b			jp macro_next 
3b7f				endm 
# End of macro NEXTW
3b7f			.STYPE: 
3b7f				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
3b7f 48				db WORD_SYS_CORE+52             
3b80 ce 3b			dw .UPPER            
3b82 06				db 5 + 1 
3b83 .. 00			db "STYPE",0              
3b89				endm 
# End of macro CWHEAD
3b89			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
3b89					if DEBUG_FORTH_WORDS_KEY 
3b89						DMARK "STY" 
3b89 f5				push af  
3b8a 3a 9e 3b			ld a, (.dmark)  
3b8d 32 77 fb			ld (debug_mark),a  
3b90 3a 9f 3b			ld a, (.dmark+1)  
3b93 32 78 fb			ld (debug_mark+1),a  
3b96 3a a0 3b			ld a, (.dmark+2)  
3b99 32 79 fb			ld (debug_mark+2),a  
3b9c 18 03			jr .pastdmark  
3b9e ..			.dmark: db "STY"  
3ba1 f1			.pastdmark: pop af  
3ba2			endm  
# End of macro DMARK
3ba2						CALLMONITOR 
3ba2 cd 00 14			call break_point_state  
3ba5				endm  
# End of macro CALLMONITOR
3ba5					endif 
3ba5					FORTH_DSP 
3ba5 cd 1a 1a			call macro_forth_dsp 
3ba8				endm 
# End of macro FORTH_DSP
3ba8					;v5 FORTH_DSP_VALUE 
3ba8			 
3ba8 7e					ld a, (hl) 
3ba9			 
3ba9 f5					push af 
3baa			 
3baa			; Dont destroy TOS		FORTH_DSP_POP 
3baa			 
3baa f1					pop af 
3bab			 
3bab fe 01				cp DS_TYPE_STR 
3bad 28 09				jr z, .typestr 
3baf			 
3baf fe 02				cp DS_TYPE_INUM 
3bb1 28 0a				jr z, .typeinum 
3bb3			 
3bb3 21 cc 3b				ld hl, .tna 
3bb6 18 0a				jr .tpush 
3bb8			 
3bb8 21 c8 3b		.typestr:	ld hl, .tstr 
3bbb 18 05				jr .tpush 
3bbd 21 ca 3b		.typeinum:	ld hl, .tinum 
3bc0 18 00				jr .tpush 
3bc2			 
3bc2			.tpush: 
3bc2			 
3bc2 cd ac 19				call forth_push_str 
3bc5			 
3bc5					NEXTW 
3bc5 c3 8b 1b			jp macro_next 
3bc8				endm 
# End of macro NEXTW
3bc8 .. 00		.tstr:	db "s",0 
3bca .. 00		.tinum:  db "i",0 
3bcc .. 00		.tna:   db "?", 0 
3bce			 
3bce			 
3bce			.UPPER: 
3bce				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
3bce 48				db WORD_SYS_CORE+52             
3bcf 09 3c			dw .LOWER            
3bd1 06				db 5 + 1 
3bd2 .. 00			db "UPPER",0              
3bd8				endm 
# End of macro CWHEAD
3bd8			; | UPPER ( s -- s ) Upper case string s  | DONE 
3bd8					if DEBUG_FORTH_WORDS_KEY 
3bd8						DMARK "UPR" 
3bd8 f5				push af  
3bd9 3a ed 3b			ld a, (.dmark)  
3bdc 32 77 fb			ld (debug_mark),a  
3bdf 3a ee 3b			ld a, (.dmark+1)  
3be2 32 78 fb			ld (debug_mark+1),a  
3be5 3a ef 3b			ld a, (.dmark+2)  
3be8 32 79 fb			ld (debug_mark+2),a  
3beb 18 03			jr .pastdmark  
3bed ..			.dmark: db "UPR"  
3bf0 f1			.pastdmark: pop af  
3bf1			endm  
# End of macro DMARK
3bf1						CALLMONITOR 
3bf1 cd 00 14			call break_point_state  
3bf4				endm  
# End of macro CALLMONITOR
3bf4					endif 
3bf4			 
3bf4					FORTH_DSP 
3bf4 cd 1a 1a			call macro_forth_dsp 
3bf7				endm 
# End of macro FORTH_DSP
3bf7					 
3bf7			; TODO check is string type 
3bf7			 
3bf7					FORTH_DSP_VALUEHL 
3bf7 cd 35 1a			call macro_dsp_valuehl 
3bfa				endm 
# End of macro FORTH_DSP_VALUEHL
3bfa			; get pointer to string in hl 
3bfa			 
3bfa 7e			.toup:		ld a, (hl) 
3bfb fe 00				cp 0 
3bfd 28 07				jr z, .toupdone 
3bff			 
3bff cd 7f 0f				call to_upper 
3c02			 
3c02 77					ld (hl), a 
3c03 23					inc hl 
3c04 18 f4				jr .toup 
3c06			 
3c06					 
3c06			 
3c06			 
3c06			; for each char convert to upper 
3c06					 
3c06			.toupdone: 
3c06			 
3c06			 
3c06					NEXTW 
3c06 c3 8b 1b			jp macro_next 
3c09				endm 
# End of macro NEXTW
3c09			.LOWER: 
3c09				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
3c09 48				db WORD_SYS_CORE+52             
3c0a 44 3c			dw .TCASE            
3c0c 06				db 5 + 1 
3c0d .. 00			db "LOWER",0              
3c13				endm 
# End of macro CWHEAD
3c13			; | LOWER ( s -- s ) Lower case string s  | DONE 
3c13					if DEBUG_FORTH_WORDS_KEY 
3c13						DMARK "LWR" 
3c13 f5				push af  
3c14 3a 28 3c			ld a, (.dmark)  
3c17 32 77 fb			ld (debug_mark),a  
3c1a 3a 29 3c			ld a, (.dmark+1)  
3c1d 32 78 fb			ld (debug_mark+1),a  
3c20 3a 2a 3c			ld a, (.dmark+2)  
3c23 32 79 fb			ld (debug_mark+2),a  
3c26 18 03			jr .pastdmark  
3c28 ..			.dmark: db "LWR"  
3c2b f1			.pastdmark: pop af  
3c2c			endm  
# End of macro DMARK
3c2c						CALLMONITOR 
3c2c cd 00 14			call break_point_state  
3c2f				endm  
# End of macro CALLMONITOR
3c2f					endif 
3c2f			 
3c2f					FORTH_DSP 
3c2f cd 1a 1a			call macro_forth_dsp 
3c32				endm 
# End of macro FORTH_DSP
3c32					 
3c32			; TODO check is string type 
3c32			 
3c32					FORTH_DSP_VALUEHL 
3c32 cd 35 1a			call macro_dsp_valuehl 
3c35				endm 
# End of macro FORTH_DSP_VALUEHL
3c35			; get pointer to string in hl 
3c35			 
3c35 7e			.tolow:		ld a, (hl) 
3c36 fe 00				cp 0 
3c38 28 07				jr z, .tolowdone 
3c3a			 
3c3a cd 88 0f				call to_lower 
3c3d			 
3c3d 77					ld (hl), a 
3c3e 23					inc hl 
3c3f 18 f4				jr .tolow 
3c41			 
3c41					 
3c41			 
3c41			 
3c41			; for each char convert to low 
3c41					 
3c41			.tolowdone: 
3c41					NEXTW 
3c41 c3 8b 1b			jp macro_next 
3c44				endm 
# End of macro NEXTW
3c44			.TCASE: 
3c44				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
3c44 48				db WORD_SYS_CORE+52             
3c45 7a 3d			dw .SUBSTR            
3c47 06				db 5 + 1 
3c48 .. 00			db "TCASE",0              
3c4e				endm 
# End of macro CWHEAD
3c4e			; | TCASE ( s -- s ) Title case string s  | DONE 
3c4e					if DEBUG_FORTH_WORDS_KEY 
3c4e						DMARK "TCS" 
3c4e f5				push af  
3c4f 3a 63 3c			ld a, (.dmark)  
3c52 32 77 fb			ld (debug_mark),a  
3c55 3a 64 3c			ld a, (.dmark+1)  
3c58 32 78 fb			ld (debug_mark+1),a  
3c5b 3a 65 3c			ld a, (.dmark+2)  
3c5e 32 79 fb			ld (debug_mark+2),a  
3c61 18 03			jr .pastdmark  
3c63 ..			.dmark: db "TCS"  
3c66 f1			.pastdmark: pop af  
3c67			endm  
# End of macro DMARK
3c67						CALLMONITOR 
3c67 cd 00 14			call break_point_state  
3c6a				endm  
# End of macro CALLMONITOR
3c6a					endif 
3c6a			 
3c6a					FORTH_DSP 
3c6a cd 1a 1a			call macro_forth_dsp 
3c6d				endm 
# End of macro FORTH_DSP
3c6d					 
3c6d			; TODO check is string type 
3c6d			 
3c6d					FORTH_DSP_VALUEHL 
3c6d cd 35 1a			call macro_dsp_valuehl 
3c70				endm 
# End of macro FORTH_DSP_VALUEHL
3c70			; get pointer to string in hl 
3c70			 
3c70					if DEBUG_FORTH_WORDS 
3c70						DMARK "TC1" 
3c70 f5				push af  
3c71 3a 85 3c			ld a, (.dmark)  
3c74 32 77 fb			ld (debug_mark),a  
3c77 3a 86 3c			ld a, (.dmark+1)  
3c7a 32 78 fb			ld (debug_mark+1),a  
3c7d 3a 87 3c			ld a, (.dmark+2)  
3c80 32 79 fb			ld (debug_mark+2),a  
3c83 18 03			jr .pastdmark  
3c85 ..			.dmark: db "TC1"  
3c88 f1			.pastdmark: pop af  
3c89			endm  
# End of macro DMARK
3c89						CALLMONITOR 
3c89 cd 00 14			call break_point_state  
3c8c				endm  
# End of macro CALLMONITOR
3c8c					endif 
3c8c			 
3c8c					; first time in turn to upper case first char 
3c8c			 
3c8c 7e					ld a, (hl) 
3c8d c3 17 3d				jp .totsiptou 
3c90			 
3c90			 
3c90 7e			.tot:		ld a, (hl) 
3c91 fe 00				cp 0 
3c93 ca 5b 3d				jp z, .totdone 
3c96			 
3c96					if DEBUG_FORTH_WORDS 
3c96						DMARK "TC2" 
3c96 f5				push af  
3c97 3a ab 3c			ld a, (.dmark)  
3c9a 32 77 fb			ld (debug_mark),a  
3c9d 3a ac 3c			ld a, (.dmark+1)  
3ca0 32 78 fb			ld (debug_mark+1),a  
3ca3 3a ad 3c			ld a, (.dmark+2)  
3ca6 32 79 fb			ld (debug_mark+2),a  
3ca9 18 03			jr .pastdmark  
3cab ..			.dmark: db "TC2"  
3cae f1			.pastdmark: pop af  
3caf			endm  
# End of macro DMARK
3caf						CALLMONITOR 
3caf cd 00 14			call break_point_state  
3cb2				endm  
# End of macro CALLMONITOR
3cb2					endif 
3cb2					; check to see if current char is a space 
3cb2			 
3cb2 fe 20				cp ' ' 
3cb4 28 21				jr z, .totsp 
3cb6 cd 88 0f				call to_lower 
3cb9					if DEBUG_FORTH_WORDS 
3cb9						DMARK "TC3" 
3cb9 f5				push af  
3cba 3a ce 3c			ld a, (.dmark)  
3cbd 32 77 fb			ld (debug_mark),a  
3cc0 3a cf 3c			ld a, (.dmark+1)  
3cc3 32 78 fb			ld (debug_mark+1),a  
3cc6 3a d0 3c			ld a, (.dmark+2)  
3cc9 32 79 fb			ld (debug_mark+2),a  
3ccc 18 03			jr .pastdmark  
3cce ..			.dmark: db "TC3"  
3cd1 f1			.pastdmark: pop af  
3cd2			endm  
# End of macro DMARK
3cd2						CALLMONITOR 
3cd2 cd 00 14			call break_point_state  
3cd5				endm  
# End of macro CALLMONITOR
3cd5					endif 
3cd5 18 63				jr .totnxt 
3cd7			 
3cd7			.totsp:         ; on a space, find next char which should be upper 
3cd7			 
3cd7					if DEBUG_FORTH_WORDS 
3cd7						DMARK "TC4" 
3cd7 f5				push af  
3cd8 3a ec 3c			ld a, (.dmark)  
3cdb 32 77 fb			ld (debug_mark),a  
3cde 3a ed 3c			ld a, (.dmark+1)  
3ce1 32 78 fb			ld (debug_mark+1),a  
3ce4 3a ee 3c			ld a, (.dmark+2)  
3ce7 32 79 fb			ld (debug_mark+2),a  
3cea 18 03			jr .pastdmark  
3cec ..			.dmark: db "TC4"  
3cef f1			.pastdmark: pop af  
3cf0			endm  
# End of macro DMARK
3cf0						CALLMONITOR 
3cf0 cd 00 14			call break_point_state  
3cf3				endm  
# End of macro CALLMONITOR
3cf3					endif 
3cf3					;; 
3cf3			 
3cf3 fe 20				cp ' ' 
3cf5 20 20				jr nz, .totsiptou 
3cf7 23					inc hl 
3cf8 7e					ld a, (hl) 
3cf9					if DEBUG_FORTH_WORDS 
3cf9						DMARK "TC5" 
3cf9 f5				push af  
3cfa 3a 0e 3d			ld a, (.dmark)  
3cfd 32 77 fb			ld (debug_mark),a  
3d00 3a 0f 3d			ld a, (.dmark+1)  
3d03 32 78 fb			ld (debug_mark+1),a  
3d06 3a 10 3d			ld a, (.dmark+2)  
3d09 32 79 fb			ld (debug_mark+2),a  
3d0c 18 03			jr .pastdmark  
3d0e ..			.dmark: db "TC5"  
3d11 f1			.pastdmark: pop af  
3d12			endm  
# End of macro DMARK
3d12						CALLMONITOR 
3d12 cd 00 14			call break_point_state  
3d15				endm  
# End of macro CALLMONITOR
3d15					endif 
3d15 18 c0				jr .totsp 
3d17 fe 00		.totsiptou:    cp 0 
3d19 28 40				jr z, .totdone 
3d1b					; not space and not zero term so upper case it 
3d1b cd 7f 0f				call to_upper 
3d1e			 
3d1e					if DEBUG_FORTH_WORDS 
3d1e						DMARK "TC6" 
3d1e f5				push af  
3d1f 3a 33 3d			ld a, (.dmark)  
3d22 32 77 fb			ld (debug_mark),a  
3d25 3a 34 3d			ld a, (.dmark+1)  
3d28 32 78 fb			ld (debug_mark+1),a  
3d2b 3a 35 3d			ld a, (.dmark+2)  
3d2e 32 79 fb			ld (debug_mark+2),a  
3d31 18 03			jr .pastdmark  
3d33 ..			.dmark: db "TC6"  
3d36 f1			.pastdmark: pop af  
3d37			endm  
# End of macro DMARK
3d37						CALLMONITOR 
3d37 cd 00 14			call break_point_state  
3d3a				endm  
# End of macro CALLMONITOR
3d3a					endif 
3d3a			 
3d3a			 
3d3a			.totnxt: 
3d3a			 
3d3a 77					ld (hl), a 
3d3b 23					inc hl 
3d3c					if DEBUG_FORTH_WORDS 
3d3c						DMARK "TC7" 
3d3c f5				push af  
3d3d 3a 51 3d			ld a, (.dmark)  
3d40 32 77 fb			ld (debug_mark),a  
3d43 3a 52 3d			ld a, (.dmark+1)  
3d46 32 78 fb			ld (debug_mark+1),a  
3d49 3a 53 3d			ld a, (.dmark+2)  
3d4c 32 79 fb			ld (debug_mark+2),a  
3d4f 18 03			jr .pastdmark  
3d51 ..			.dmark: db "TC7"  
3d54 f1			.pastdmark: pop af  
3d55			endm  
# End of macro DMARK
3d55						CALLMONITOR 
3d55 cd 00 14			call break_point_state  
3d58				endm  
# End of macro CALLMONITOR
3d58					endif 
3d58 c3 90 3c				jp .tot 
3d5b			 
3d5b					 
3d5b			 
3d5b			 
3d5b			; for each char convert to low 
3d5b					 
3d5b			.totdone: 
3d5b					if DEBUG_FORTH_WORDS 
3d5b						DMARK "TCd" 
3d5b f5				push af  
3d5c 3a 70 3d			ld a, (.dmark)  
3d5f 32 77 fb			ld (debug_mark),a  
3d62 3a 71 3d			ld a, (.dmark+1)  
3d65 32 78 fb			ld (debug_mark+1),a  
3d68 3a 72 3d			ld a, (.dmark+2)  
3d6b 32 79 fb			ld (debug_mark+2),a  
3d6e 18 03			jr .pastdmark  
3d70 ..			.dmark: db "TCd"  
3d73 f1			.pastdmark: pop af  
3d74			endm  
# End of macro DMARK
3d74						CALLMONITOR 
3d74 cd 00 14			call break_point_state  
3d77				endm  
# End of macro CALLMONITOR
3d77					endif 
3d77					NEXTW 
3d77 c3 8b 1b			jp macro_next 
3d7a				endm 
# End of macro NEXTW
3d7a			 
3d7a			.SUBSTR: 
3d7a				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
3d7a 48				db WORD_SYS_CORE+52             
3d7b d8 3d			dw .LEFT            
3d7d 07				db 6 + 1 
3d7e .. 00			db "SUBSTR",0              
3d85				endm 
# End of macro CWHEAD
3d85			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
3d85			 
3d85					if DEBUG_FORTH_WORDS_KEY 
3d85						DMARK "SST" 
3d85 f5				push af  
3d86 3a 9a 3d			ld a, (.dmark)  
3d89 32 77 fb			ld (debug_mark),a  
3d8c 3a 9b 3d			ld a, (.dmark+1)  
3d8f 32 78 fb			ld (debug_mark+1),a  
3d92 3a 9c 3d			ld a, (.dmark+2)  
3d95 32 79 fb			ld (debug_mark+2),a  
3d98 18 03			jr .pastdmark  
3d9a ..			.dmark: db "SST"  
3d9d f1			.pastdmark: pop af  
3d9e			endm  
# End of macro DMARK
3d9e						CALLMONITOR 
3d9e cd 00 14			call break_point_state  
3da1				endm  
# End of macro CALLMONITOR
3da1					endif 
3da1			; TODO check string type 
3da1					FORTH_DSP_VALUEHL 
3da1 cd 35 1a			call macro_dsp_valuehl 
3da4				endm 
# End of macro FORTH_DSP_VALUEHL
3da4			 
3da4 e5					push hl      ; string length 
3da5			 
3da5					FORTH_DSP_POP 
3da5 cd d1 1a			call macro_forth_dsp_pop 
3da8				endm 
# End of macro FORTH_DSP_POP
3da8			 
3da8					FORTH_DSP_VALUEHL 
3da8 cd 35 1a			call macro_dsp_valuehl 
3dab				endm 
# End of macro FORTH_DSP_VALUEHL
3dab			 
3dab e5					push hl     ; start char 
3dac			 
3dac					FORTH_DSP_POP 
3dac cd d1 1a			call macro_forth_dsp_pop 
3daf				endm 
# End of macro FORTH_DSP_POP
3daf			 
3daf			 
3daf					FORTH_DSP_VALUE 
3daf cd 1e 1a			call macro_forth_dsp_value 
3db2				endm 
# End of macro FORTH_DSP_VALUE
3db2			 
3db2 d1					pop de    ; get start post offset 
3db3			 
3db3 19					add hl, de    ; starting offset 
3db4			 
3db4 c1					pop bc 
3db5 c5					push bc      ; grab size of string 
3db6			 
3db6 e5					push hl    ; save string start  
3db7			 
3db7 26 00				ld h, 0 
3db9 69					ld l, c 
3dba 23					inc hl 
3dbb 23					inc hl 
3dbc			 
3dbc cd d9 10				call malloc 
3dbf				if DEBUG_FORTH_MALLOC_GUARD 
3dbf cc 5a 4d				call z,malloc_error 
3dc2				endif 
3dc2			 
3dc2 eb					ex de, hl      ; save malloc area for string copy 
3dc3 e1					pop hl    ; get back source 
3dc4 c1					pop bc    ; get length of string back 
3dc5			 
3dc5 d5					push de    ; save malloc area for after we push 
3dc6 ed b0				ldir     ; copy substr 
3dc8			 
3dc8			 
3dc8 eb					ex de, hl 
3dc9 3e 00				ld a, 0 
3dcb 77					ld (hl), a   ; term substr 
3dcc			 
3dcc					 
3dcc e1					pop hl    ; get malloc so we can push it 
3dcd e5					push hl   ; save so we can free it afterwards 
3dce			 
3dce cd ac 19				call forth_push_str 
3dd1			 
3dd1 e1					pop hl 
3dd2 cd a3 11				call free 
3dd5			 
3dd5					 
3dd5					 
3dd5			 
3dd5			 
3dd5					NEXTW 
3dd5 c3 8b 1b			jp macro_next 
3dd8				endm 
# End of macro NEXTW
3dd8			 
3dd8			.LEFT: 
3dd8				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
3dd8 48				db WORD_SYS_CORE+52             
3dd9 00 3e			dw .RIGHT            
3ddb 05				db 4 + 1 
3ddc .. 00			db "LEFT",0              
3de1				endm 
# End of macro CWHEAD
3de1			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
3de1					if DEBUG_FORTH_WORDS_KEY 
3de1						DMARK "LEF" 
3de1 f5				push af  
3de2 3a f6 3d			ld a, (.dmark)  
3de5 32 77 fb			ld (debug_mark),a  
3de8 3a f7 3d			ld a, (.dmark+1)  
3deb 32 78 fb			ld (debug_mark+1),a  
3dee 3a f8 3d			ld a, (.dmark+2)  
3df1 32 79 fb			ld (debug_mark+2),a  
3df4 18 03			jr .pastdmark  
3df6 ..			.dmark: db "LEF"  
3df9 f1			.pastdmark: pop af  
3dfa			endm  
# End of macro DMARK
3dfa						CALLMONITOR 
3dfa cd 00 14			call break_point_state  
3dfd				endm  
# End of macro CALLMONITOR
3dfd					endif 
3dfd			 
3dfd					NEXTW 
3dfd c3 8b 1b			jp macro_next 
3e00				endm 
# End of macro NEXTW
3e00			.RIGHT: 
3e00				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
3e00 48				db WORD_SYS_CORE+52             
3e01 29 3e			dw .STR2NUM            
3e03 06				db 5 + 1 
3e04 .. 00			db "RIGHT",0              
3e0a				endm 
# End of macro CWHEAD
3e0a			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
3e0a					if DEBUG_FORTH_WORDS_KEY 
3e0a						DMARK "RIG" 
3e0a f5				push af  
3e0b 3a 1f 3e			ld a, (.dmark)  
3e0e 32 77 fb			ld (debug_mark),a  
3e11 3a 20 3e			ld a, (.dmark+1)  
3e14 32 78 fb			ld (debug_mark+1),a  
3e17 3a 21 3e			ld a, (.dmark+2)  
3e1a 32 79 fb			ld (debug_mark+2),a  
3e1d 18 03			jr .pastdmark  
3e1f ..			.dmark: db "RIG"  
3e22 f1			.pastdmark: pop af  
3e23			endm  
# End of macro DMARK
3e23						CALLMONITOR 
3e23 cd 00 14			call break_point_state  
3e26				endm  
# End of macro CALLMONITOR
3e26					endif 
3e26			 
3e26					NEXTW 
3e26 c3 8b 1b			jp macro_next 
3e29				endm 
# End of macro NEXTW
3e29			 
3e29			 
3e29			.STR2NUM: 
3e29				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
3e29 48				db WORD_SYS_CORE+52             
3e2a b5 3e			dw .NUM2STR            
3e2c 08				db 7 + 1 
3e2d .. 00			db "STR2NUM",0              
3e35				endm 
# End of macro CWHEAD
3e35			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
3e35			 
3e35			 
3e35			; TODO STR type check to do 
3e35					if DEBUG_FORTH_WORDS_KEY 
3e35						DMARK "S2N" 
3e35 f5				push af  
3e36 3a 4a 3e			ld a, (.dmark)  
3e39 32 77 fb			ld (debug_mark),a  
3e3c 3a 4b 3e			ld a, (.dmark+1)  
3e3f 32 78 fb			ld (debug_mark+1),a  
3e42 3a 4c 3e			ld a, (.dmark+2)  
3e45 32 79 fb			ld (debug_mark+2),a  
3e48 18 03			jr .pastdmark  
3e4a ..			.dmark: db "S2N"  
3e4d f1			.pastdmark: pop af  
3e4e			endm  
# End of macro DMARK
3e4e						CALLMONITOR 
3e4e cd 00 14			call break_point_state  
3e51				endm  
# End of macro CALLMONITOR
3e51					endif 
3e51			 
3e51					;FORTH_DSP 
3e51					FORTH_DSP_VALUE 
3e51 cd 1e 1a			call macro_forth_dsp_value 
3e54				endm 
# End of macro FORTH_DSP_VALUE
3e54					;inc hl 
3e54			 
3e54 eb					ex de, hl 
3e55					if DEBUG_FORTH_WORDS 
3e55						DMARK "S2a" 
3e55 f5				push af  
3e56 3a 6a 3e			ld a, (.dmark)  
3e59 32 77 fb			ld (debug_mark),a  
3e5c 3a 6b 3e			ld a, (.dmark+1)  
3e5f 32 78 fb			ld (debug_mark+1),a  
3e62 3a 6c 3e			ld a, (.dmark+2)  
3e65 32 79 fb			ld (debug_mark+2),a  
3e68 18 03			jr .pastdmark  
3e6a ..			.dmark: db "S2a"  
3e6d f1			.pastdmark: pop af  
3e6e			endm  
# End of macro DMARK
3e6e						CALLMONITOR 
3e6e cd 00 14			call break_point_state  
3e71				endm  
# End of macro CALLMONITOR
3e71					endif 
3e71 cd 07 10				call string_to_uint16 
3e74			 
3e74					if DEBUG_FORTH_WORDS 
3e74						DMARK "S2b" 
3e74 f5				push af  
3e75 3a 89 3e			ld a, (.dmark)  
3e78 32 77 fb			ld (debug_mark),a  
3e7b 3a 8a 3e			ld a, (.dmark+1)  
3e7e 32 78 fb			ld (debug_mark+1),a  
3e81 3a 8b 3e			ld a, (.dmark+2)  
3e84 32 79 fb			ld (debug_mark+2),a  
3e87 18 03			jr .pastdmark  
3e89 ..			.dmark: db "S2b"  
3e8c f1			.pastdmark: pop af  
3e8d			endm  
# End of macro DMARK
3e8d						CALLMONITOR 
3e8d cd 00 14			call break_point_state  
3e90				endm  
# End of macro CALLMONITOR
3e90					endif 
3e90			;		push hl 
3e90					FORTH_DSP_POP 
3e90 cd d1 1a			call macro_forth_dsp_pop 
3e93				endm 
# End of macro FORTH_DSP_POP
3e93			;		pop hl 
3e93					 
3e93					if DEBUG_FORTH_WORDS 
3e93						DMARK "S2b" 
3e93 f5				push af  
3e94 3a a8 3e			ld a, (.dmark)  
3e97 32 77 fb			ld (debug_mark),a  
3e9a 3a a9 3e			ld a, (.dmark+1)  
3e9d 32 78 fb			ld (debug_mark+1),a  
3ea0 3a aa 3e			ld a, (.dmark+2)  
3ea3 32 79 fb			ld (debug_mark+2),a  
3ea6 18 03			jr .pastdmark  
3ea8 ..			.dmark: db "S2b"  
3eab f1			.pastdmark: pop af  
3eac			endm  
# End of macro DMARK
3eac						CALLMONITOR 
3eac cd 00 14			call break_point_state  
3eaf				endm  
# End of macro CALLMONITOR
3eaf					endif 
3eaf cd 9a 19				call forth_push_numhl	 
3eb2			 
3eb2				 
3eb2				       NEXTW 
3eb2 c3 8b 1b			jp macro_next 
3eb5				endm 
# End of macro NEXTW
3eb5			.NUM2STR: 
3eb5				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
3eb5 48				db WORD_SYS_CORE+52             
3eb6 c4 3e			dw .CONCAT            
3eb8 08				db 7 + 1 
3eb9 .. 00			db "NUM2STR",0              
3ec1				endm 
# End of macro CWHEAD
3ec1			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
3ec1			 
3ec1			;		; malloc a string to target 
3ec1			;		ld hl, 10     ; TODO max string size should be fine 
3ec1			;		call malloc 
3ec1			;		push hl    ; save malloc location 
3ec1			; 
3ec1			; 
3ec1			;; TODO check int type 
3ec1			;		FORTH_DSP_VALUEHL 
3ec1			;		ld a, l 
3ec1			;		call DispAToASCII   
3ec1			;;TODO need to chage above call to dump into string 
3ec1			; 
3ec1			; 
3ec1			 
3ec1				       NEXTW 
3ec1 c3 8b 1b			jp macro_next 
3ec4				endm 
# End of macro NEXTW
3ec4			 
3ec4			.CONCAT: 
3ec4				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
3ec4 48				db WORD_SYS_CORE+52             
3ec5 77 3f			dw .FIND            
3ec7 07				db 6 + 1 
3ec8 .. 00			db "CONCAT",0              
3ecf				endm 
# End of macro CWHEAD
3ecf			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
3ecf			 
3ecf			; TODO check string type 
3ecf			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
3ecf			 
3ecf					if DEBUG_FORTH_WORDS_KEY 
3ecf						DMARK "CON" 
3ecf f5				push af  
3ed0 3a e4 3e			ld a, (.dmark)  
3ed3 32 77 fb			ld (debug_mark),a  
3ed6 3a e5 3e			ld a, (.dmark+1)  
3ed9 32 78 fb			ld (debug_mark+1),a  
3edc 3a e6 3e			ld a, (.dmark+2)  
3edf 32 79 fb			ld (debug_mark+2),a  
3ee2 18 03			jr .pastdmark  
3ee4 ..			.dmark: db "CON"  
3ee7 f1			.pastdmark: pop af  
3ee8			endm  
# End of macro DMARK
3ee8						CALLMONITOR 
3ee8 cd 00 14			call break_point_state  
3eeb				endm  
# End of macro CALLMONITOR
3eeb					endif 
3eeb			 
3eeb			 
3eeb					FORTH_DSP_VALUE 
3eeb cd 1e 1a			call macro_forth_dsp_value 
3eee				endm 
# End of macro FORTH_DSP_VALUE
3eee e5					push hl   ; s2 
3eef			 
3eef					FORTH_DSP_POP 
3eef cd d1 1a			call macro_forth_dsp_pop 
3ef2				endm 
# End of macro FORTH_DSP_POP
3ef2			 
3ef2					FORTH_DSP_VALUE 
3ef2 cd 1e 1a			call macro_forth_dsp_value 
3ef5				endm 
# End of macro FORTH_DSP_VALUE
3ef5			 
3ef5 e5					push hl   ; s1 
3ef6			 
3ef6					FORTH_DSP_POP 
3ef6 cd d1 1a			call macro_forth_dsp_pop 
3ef9				endm 
# End of macro FORTH_DSP_POP
3ef9					 
3ef9			 
3ef9					; copy s1 
3ef9			 
3ef9				 
3ef9					; save ptr 
3ef9 e1					pop hl  
3efa e5					push hl 
3efb 3e 00				ld a, 0 
3efd cd 7b 10				call strlent 
3f00					;inc hl    ; zer0 
3f00 06 00				ld b, 0 
3f02 4d					ld c, l 
3f03 e1					pop hl		 
3f04 11 32 ee				ld de, scratch	 
3f07					if DEBUG_FORTH_WORDS 
3f07						DMARK "CO1" 
3f07 f5				push af  
3f08 3a 1c 3f			ld a, (.dmark)  
3f0b 32 77 fb			ld (debug_mark),a  
3f0e 3a 1d 3f			ld a, (.dmark+1)  
3f11 32 78 fb			ld (debug_mark+1),a  
3f14 3a 1e 3f			ld a, (.dmark+2)  
3f17 32 79 fb			ld (debug_mark+2),a  
3f1a 18 03			jr .pastdmark  
3f1c ..			.dmark: db "CO1"  
3f1f f1			.pastdmark: pop af  
3f20			endm  
# End of macro DMARK
3f20						CALLMONITOR 
3f20 cd 00 14			call break_point_state  
3f23				endm  
# End of macro CALLMONITOR
3f23					endif 
3f23 ed b0				ldir 
3f25			 
3f25 e1					pop hl 
3f26 e5					push hl 
3f27 d5					push de 
3f28			 
3f28			 
3f28 3e 00				ld a, 0 
3f2a cd 7b 10				call strlent 
3f2d 23					inc hl    ; zer0 
3f2e 23					inc hl 
3f2f 06 00				ld b, 0 
3f31 4d					ld c, l 
3f32 d1					pop de 
3f33 e1					pop hl		 
3f34					if DEBUG_FORTH_WORDS 
3f34						DMARK "CO2" 
3f34 f5				push af  
3f35 3a 49 3f			ld a, (.dmark)  
3f38 32 77 fb			ld (debug_mark),a  
3f3b 3a 4a 3f			ld a, (.dmark+1)  
3f3e 32 78 fb			ld (debug_mark+1),a  
3f41 3a 4b 3f			ld a, (.dmark+2)  
3f44 32 79 fb			ld (debug_mark+2),a  
3f47 18 03			jr .pastdmark  
3f49 ..			.dmark: db "CO2"  
3f4c f1			.pastdmark: pop af  
3f4d			endm  
# End of macro DMARK
3f4d						CALLMONITOR 
3f4d cd 00 14			call break_point_state  
3f50				endm  
# End of macro CALLMONITOR
3f50					endif 
3f50 ed b0				ldir 
3f52			 
3f52			 
3f52			 
3f52 21 32 ee				ld hl, scratch 
3f55					if DEBUG_FORTH_WORDS 
3f55						DMARK "CO5" 
3f55 f5				push af  
3f56 3a 6a 3f			ld a, (.dmark)  
3f59 32 77 fb			ld (debug_mark),a  
3f5c 3a 6b 3f			ld a, (.dmark+1)  
3f5f 32 78 fb			ld (debug_mark+1),a  
3f62 3a 6c 3f			ld a, (.dmark+2)  
3f65 32 79 fb			ld (debug_mark+2),a  
3f68 18 03			jr .pastdmark  
3f6a ..			.dmark: db "CO5"  
3f6d f1			.pastdmark: pop af  
3f6e			endm  
# End of macro DMARK
3f6e						CALLMONITOR 
3f6e cd 00 14			call break_point_state  
3f71				endm  
# End of macro CALLMONITOR
3f71					endif 
3f71			 
3f71 cd ac 19				call forth_push_str 
3f74			 
3f74			 
3f74			 
3f74			 
3f74				       NEXTW 
3f74 c3 8b 1b			jp macro_next 
3f77				endm 
# End of macro NEXTW
3f77			 
3f77			 
3f77			.FIND: 
3f77				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
3f77 4b				db WORD_SYS_CORE+55             
3f78 35 40			dw .LEN            
3f7a 05				db 4 + 1 
3f7b .. 00			db "FIND",0              
3f80				endm 
# End of macro CWHEAD
3f80			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
3f80			 
3f80					if DEBUG_FORTH_WORDS_KEY 
3f80						DMARK "FND" 
3f80 f5				push af  
3f81 3a 95 3f			ld a, (.dmark)  
3f84 32 77 fb			ld (debug_mark),a  
3f87 3a 96 3f			ld a, (.dmark+1)  
3f8a 32 78 fb			ld (debug_mark+1),a  
3f8d 3a 97 3f			ld a, (.dmark+2)  
3f90 32 79 fb			ld (debug_mark+2),a  
3f93 18 03			jr .pastdmark  
3f95 ..			.dmark: db "FND"  
3f98 f1			.pastdmark: pop af  
3f99			endm  
# End of macro DMARK
3f99						CALLMONITOR 
3f99 cd 00 14			call break_point_state  
3f9c				endm  
# End of macro CALLMONITOR
3f9c					endif 
3f9c			 
3f9c			; TODO check string type 
3f9c					FORTH_DSP_VALUE 
3f9c cd 1e 1a			call macro_forth_dsp_value 
3f9f				endm 
# End of macro FORTH_DSP_VALUE
3f9f			 
3f9f e5					push hl    
3fa0 7e					ld a,(hl)    ; char to find   
3fa1			; TODO change char to substr 
3fa1			 
3fa1 f5					push af 
3fa2					 
3fa2			 
3fa2			 
3fa2					if DEBUG_FORTH_WORDS 
3fa2						DMARK "FN1" 
3fa2 f5				push af  
3fa3 3a b7 3f			ld a, (.dmark)  
3fa6 32 77 fb			ld (debug_mark),a  
3fa9 3a b8 3f			ld a, (.dmark+1)  
3fac 32 78 fb			ld (debug_mark+1),a  
3faf 3a b9 3f			ld a, (.dmark+2)  
3fb2 32 79 fb			ld (debug_mark+2),a  
3fb5 18 03			jr .pastdmark  
3fb7 ..			.dmark: db "FN1"  
3fba f1			.pastdmark: pop af  
3fbb			endm  
# End of macro DMARK
3fbb						CALLMONITOR 
3fbb cd 00 14			call break_point_state  
3fbe				endm  
# End of macro CALLMONITOR
3fbe					endif 
3fbe			 
3fbe					FORTH_DSP_POP 
3fbe cd d1 1a			call macro_forth_dsp_pop 
3fc1				endm 
# End of macro FORTH_DSP_POP
3fc1			 
3fc1					; string to search 
3fc1			 
3fc1					FORTH_DSP_VALUE 
3fc1 cd 1e 1a			call macro_forth_dsp_value 
3fc4				endm 
# End of macro FORTH_DSP_VALUE
3fc4			 
3fc4 d1					pop de  ; d is char to find  
3fc5			 
3fc5					if DEBUG_FORTH_WORDS 
3fc5						DMARK "FN2" 
3fc5 f5				push af  
3fc6 3a da 3f			ld a, (.dmark)  
3fc9 32 77 fb			ld (debug_mark),a  
3fcc 3a db 3f			ld a, (.dmark+1)  
3fcf 32 78 fb			ld (debug_mark+1),a  
3fd2 3a dc 3f			ld a, (.dmark+2)  
3fd5 32 79 fb			ld (debug_mark+2),a  
3fd8 18 03			jr .pastdmark  
3fda ..			.dmark: db "FN2"  
3fdd f1			.pastdmark: pop af  
3fde			endm  
# End of macro DMARK
3fde						CALLMONITOR 
3fde cd 00 14			call break_point_state  
3fe1				endm  
# End of macro CALLMONITOR
3fe1					endif 
3fe1					 
3fe1 01 00 00				ld bc, 0 
3fe4 7e			.findchar:      ld a,(hl) 
3fe5 fe 00				cp 0   		 
3fe7 28 27				jr z, .finddone     
3fe9 ba					cp d 
3fea 28 20				jr z, .foundchar 
3fec 03					inc bc 
3fed 23					inc hl 
3fee					if DEBUG_FORTH_WORDS 
3fee						DMARK "FN3" 
3fee f5				push af  
3fef 3a 03 40			ld a, (.dmark)  
3ff2 32 77 fb			ld (debug_mark),a  
3ff5 3a 04 40			ld a, (.dmark+1)  
3ff8 32 78 fb			ld (debug_mark+1),a  
3ffb 3a 05 40			ld a, (.dmark+2)  
3ffe 32 79 fb			ld (debug_mark+2),a  
4001 18 03			jr .pastdmark  
4003 ..			.dmark: db "FN3"  
4006 f1			.pastdmark: pop af  
4007			endm  
# End of macro DMARK
4007						CALLMONITOR 
4007 cd 00 14			call break_point_state  
400a				endm  
# End of macro CALLMONITOR
400a					endif 
400a 18 d8				jr .findchar 
400c			 
400c			 
400c c5			.foundchar:	push bc 
400d e1					pop hl 
400e 18 03				jr .findexit 
4010			 
4010			 
4010							 
4010			 
4010			.finddone:     ; got to end of string with no find 
4010 21 00 00				ld hl, 0 
4013			.findexit: 
4013			 
4013					if DEBUG_FORTH_WORDS 
4013						DMARK "FNd" 
4013 f5				push af  
4014 3a 28 40			ld a, (.dmark)  
4017 32 77 fb			ld (debug_mark),a  
401a 3a 29 40			ld a, (.dmark+1)  
401d 32 78 fb			ld (debug_mark+1),a  
4020 3a 2a 40			ld a, (.dmark+2)  
4023 32 79 fb			ld (debug_mark+2),a  
4026 18 03			jr .pastdmark  
4028 ..			.dmark: db "FNd"  
402b f1			.pastdmark: pop af  
402c			endm  
# End of macro DMARK
402c						CALLMONITOR 
402c cd 00 14			call break_point_state  
402f				endm  
# End of macro CALLMONITOR
402f					endif 
402f cd 9a 19			call forth_push_numhl 
4032			 
4032				       NEXTW 
4032 c3 8b 1b			jp macro_next 
4035				endm 
# End of macro NEXTW
4035			 
4035			.LEN: 
4035				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
4035 4c				db WORD_SYS_CORE+56             
4036 6a 40			dw .CHAR            
4038 06				db 5 + 1 
4039 .. 00			db "COUNT",0              
403f				endm 
# End of macro CWHEAD
403f			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
403f			 
403f					if DEBUG_FORTH_WORDS_KEY 
403f						DMARK "CNT" 
403f f5				push af  
4040 3a 54 40			ld a, (.dmark)  
4043 32 77 fb			ld (debug_mark),a  
4046 3a 55 40			ld a, (.dmark+1)  
4049 32 78 fb			ld (debug_mark+1),a  
404c 3a 56 40			ld a, (.dmark+2)  
404f 32 79 fb			ld (debug_mark+2),a  
4052 18 03			jr .pastdmark  
4054 ..			.dmark: db "CNT"  
4057 f1			.pastdmark: pop af  
4058			endm  
# End of macro DMARK
4058						CALLMONITOR 
4058 cd 00 14			call break_point_state  
405b				endm  
# End of macro CALLMONITOR
405b					endif 
405b			; TODO check string type 
405b					FORTH_DSP 
405b cd 1a 1a			call macro_forth_dsp 
405e				endm 
# End of macro FORTH_DSP
405e					;v5FORTH_DSP_VALUE 
405e			 
405e 23					inc hl 
405f			 
405f 3e 00				ld a, 0 
4061 cd 7b 10				call strlent 
4064			 
4064 cd 9a 19				call forth_push_numhl 
4067			 
4067			 
4067			 
4067				       NEXTW 
4067 c3 8b 1b			jp macro_next 
406a				endm 
# End of macro NEXTW
406a			.CHAR: 
406a				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
406a 4d				db WORD_SYS_CORE+57             
406b a0 40			dw .ENDSTR            
406d 05				db 4 + 1 
406e .. 00			db "CHAR",0              
4073				endm 
# End of macro CWHEAD
4073			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
4073					if DEBUG_FORTH_WORDS_KEY 
4073						DMARK "CHR" 
4073 f5				push af  
4074 3a 88 40			ld a, (.dmark)  
4077 32 77 fb			ld (debug_mark),a  
407a 3a 89 40			ld a, (.dmark+1)  
407d 32 78 fb			ld (debug_mark+1),a  
4080 3a 8a 40			ld a, (.dmark+2)  
4083 32 79 fb			ld (debug_mark+2),a  
4086 18 03			jr .pastdmark  
4088 ..			.dmark: db "CHR"  
408b f1			.pastdmark: pop af  
408c			endm  
# End of macro DMARK
408c						CALLMONITOR 
408c cd 00 14			call break_point_state  
408f				endm  
# End of macro CALLMONITOR
408f					endif 
408f					FORTH_DSP 
408f cd 1a 1a			call macro_forth_dsp 
4092				endm 
# End of macro FORTH_DSP
4092					;v5 FORTH_DSP_VALUE 
4092 23					inc hl      ; now at start of numeric as string 
4093			 
4093			;		push hl 
4093			 
4093					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4093 cd d1 1a			call macro_forth_dsp_pop 
4096				endm 
# End of macro FORTH_DSP_POP
4096			 
4096			;		pop hl 
4096			 
4096					; push the content of a onto the stack as a value 
4096			 
4096 7e					ld a,(hl)   ; get char 
4097 26 00				ld h,0 
4099 6f					ld l,a 
409a cd 9a 19				call forth_push_numhl 
409d			 
409d				       NEXTW 
409d c3 8b 1b			jp macro_next 
40a0				endm 
# End of macro NEXTW
40a0			 
40a0			 
40a0			 
40a0			 
40a0			.ENDSTR: 
40a0			; eof 
40a0			 
# End of file forth_words_str.asm
40a0			include "forth_words_key.asm" 
40a0			 
40a0			; | ## Keyboard Words 
40a0			 
40a0			.KEY: 
40a0				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
40a0 3e				db WORD_SYS_CORE+42             
40a1 d0 40			dw .WAITK            
40a3 04				db 3 + 1 
40a4 .. 00			db "KEY",0              
40a8				endm 
# End of macro CWHEAD
40a8			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
40a8			 
40a8					if DEBUG_FORTH_WORDS_KEY 
40a8						DMARK "KEY" 
40a8 f5				push af  
40a9 3a bd 40			ld a, (.dmark)  
40ac 32 77 fb			ld (debug_mark),a  
40af 3a be 40			ld a, (.dmark+1)  
40b2 32 78 fb			ld (debug_mark+1),a  
40b5 3a bf 40			ld a, (.dmark+2)  
40b8 32 79 fb			ld (debug_mark+2),a  
40bb 18 03			jr .pastdmark  
40bd ..			.dmark: db "KEY"  
40c0 f1			.pastdmark: pop af  
40c1			endm  
# End of macro DMARK
40c1						CALLMONITOR 
40c1 cd 00 14			call break_point_state  
40c4				endm  
# End of macro CALLMONITOR
40c4					endif 
40c4			; TODO currently waits 
40c4 cd 64 63				call cin 
40c7					;call cin_wait 
40c7 6f					ld l, a 
40c8 26 00				ld h, 0 
40ca cd 9a 19				call forth_push_numhl 
40cd					NEXTW 
40cd c3 8b 1b			jp macro_next 
40d0				endm 
# End of macro NEXTW
40d0			.WAITK: 
40d0				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
40d0 3f				db WORD_SYS_CORE+43             
40d1 02 41			dw .ACCEPT            
40d3 06				db 5 + 1 
40d4 .. 00			db "WAITK",0              
40da				endm 
# End of macro CWHEAD
40da			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
40da					if DEBUG_FORTH_WORDS_KEY 
40da						DMARK "WAI" 
40da f5				push af  
40db 3a ef 40			ld a, (.dmark)  
40de 32 77 fb			ld (debug_mark),a  
40e1 3a f0 40			ld a, (.dmark+1)  
40e4 32 78 fb			ld (debug_mark+1),a  
40e7 3a f1 40			ld a, (.dmark+2)  
40ea 32 79 fb			ld (debug_mark+2),a  
40ed 18 03			jr .pastdmark  
40ef ..			.dmark: db "WAI"  
40f2 f1			.pastdmark: pop af  
40f3			endm  
# End of macro DMARK
40f3						CALLMONITOR 
40f3 cd 00 14			call break_point_state  
40f6				endm  
# End of macro CALLMONITOR
40f6					endif 
40f6 cd 53 63				call cin_wait 
40f9 6f					ld l, a 
40fa 26 00				ld h, 0 
40fc cd 9a 19				call forth_push_numhl 
40ff					NEXTW 
40ff c3 8b 1b			jp macro_next 
4102				endm 
# End of macro NEXTW
4102			.ACCEPT: 
4102				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4102 40				db WORD_SYS_CORE+44             
4103 60 41			dw .EDIT            
4105 07				db 6 + 1 
4106 .. 00			db "ACCEPT",0              
410d				endm 
# End of macro CWHEAD
410d			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
410d					; TODO crashes on push 
410d					if DEBUG_FORTH_WORDS_KEY 
410d						DMARK "ACC" 
410d f5				push af  
410e 3a 22 41			ld a, (.dmark)  
4111 32 77 fb			ld (debug_mark),a  
4114 3a 23 41			ld a, (.dmark+1)  
4117 32 78 fb			ld (debug_mark+1),a  
411a 3a 24 41			ld a, (.dmark+2)  
411d 32 79 fb			ld (debug_mark+2),a  
4120 18 03			jr .pastdmark  
4122 ..			.dmark: db "ACC"  
4125 f1			.pastdmark: pop af  
4126			endm  
# End of macro DMARK
4126						CALLMONITOR 
4126 cd 00 14			call break_point_state  
4129				endm  
# End of macro CALLMONITOR
4129					endif 
4129 21 30 f0				ld hl, os_input 
412c 3e 00				ld a, 0 
412e 77					ld (hl),a 
412f 3a 5b f8				ld a,(f_cursor_ptr) 
4132 16 64				ld d, 100 
4134 0e 00				ld c, 0 
4136 1e 28				ld e, 40 
4138 cd 3f 0c				call input_str 
413b					; TODO perhaps do a type check and wrap in quotes if not a number 
413b 21 30 f0				ld hl, os_input 
413e					if DEBUG_FORTH_WORDS 
413e						DMARK "AC1" 
413e f5				push af  
413f 3a 53 41			ld a, (.dmark)  
4142 32 77 fb			ld (debug_mark),a  
4145 3a 54 41			ld a, (.dmark+1)  
4148 32 78 fb			ld (debug_mark+1),a  
414b 3a 55 41			ld a, (.dmark+2)  
414e 32 79 fb			ld (debug_mark+2),a  
4151 18 03			jr .pastdmark  
4153 ..			.dmark: db "AC1"  
4156 f1			.pastdmark: pop af  
4157			endm  
# End of macro DMARK
4157						CALLMONITOR 
4157 cd 00 14			call break_point_state  
415a				endm  
# End of macro CALLMONITOR
415a					endif 
415a cd ac 19				call forth_push_str 
415d					NEXTW 
415d c3 8b 1b			jp macro_next 
4160				endm 
# End of macro NEXTW
4160			 
4160			.EDIT: 
4160				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
4160 40				db WORD_SYS_CORE+44             
4161 e9 41			dw .ENDKEY            
4163 05				db 4 + 1 
4164 .. 00			db "EDIT",0              
4169				endm 
# End of macro CWHEAD
4169			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4169			 
4169					; TODO does not copy from stack 
4169					if DEBUG_FORTH_WORDS_KEY 
4169						DMARK "EDT" 
4169 f5				push af  
416a 3a 7e 41			ld a, (.dmark)  
416d 32 77 fb			ld (debug_mark),a  
4170 3a 7f 41			ld a, (.dmark+1)  
4173 32 78 fb			ld (debug_mark+1),a  
4176 3a 80 41			ld a, (.dmark+2)  
4179 32 79 fb			ld (debug_mark+2),a  
417c 18 03			jr .pastdmark  
417e ..			.dmark: db "EDT"  
4181 f1			.pastdmark: pop af  
4182			endm  
# End of macro DMARK
4182						CALLMONITOR 
4182 cd 00 14			call break_point_state  
4185				endm  
# End of macro CALLMONITOR
4185					endif 
4185			 
4185					FORTH_DSP 
4185 cd 1a 1a			call macro_forth_dsp 
4188				endm 
# End of macro FORTH_DSP
4188					;v5 FORTH_DSP_VALUE 
4188 23					inc hl    ; TODO do type check 
4189			 
4189 e5					push hl 
418a 3e 00				ld a, 0 
418c cd 7b 10				call strlent 
418f 23					inc hl 
4190			 
4190 06 00				ld b, 0 
4192 4d					ld c, l 
4193			 
4193 e1					pop hl 
4194 11 30 f0				ld de, os_input 
4197					if DEBUG_FORTH_WORDS_KEY 
4197						DMARK "EDc" 
4197 f5				push af  
4198 3a ac 41			ld a, (.dmark)  
419b 32 77 fb			ld (debug_mark),a  
419e 3a ad 41			ld a, (.dmark+1)  
41a1 32 78 fb			ld (debug_mark+1),a  
41a4 3a ae 41			ld a, (.dmark+2)  
41a7 32 79 fb			ld (debug_mark+2),a  
41aa 18 03			jr .pastdmark  
41ac ..			.dmark: db "EDc"  
41af f1			.pastdmark: pop af  
41b0			endm  
# End of macro DMARK
41b0						CALLMONITOR 
41b0 cd 00 14			call break_point_state  
41b3				endm  
# End of macro CALLMONITOR
41b3					endif 
41b3 ed b0				ldir 
41b5			 
41b5			 
41b5 21 30 f0				ld hl, os_input 
41b8					;ld a, 0 
41b8					;ld (hl),a 
41b8 3a 5b f8				ld a,(f_cursor_ptr) 
41bb 16 64				ld d, 100 
41bd 0e 00				ld c, 0 
41bf 1e 28				ld e, 40 
41c1 cd 3f 0c				call input_str 
41c4					; TODO perhaps do a type check and wrap in quotes if not a number 
41c4 21 30 f0				ld hl, os_input 
41c7					if DEBUG_FORTH_WORDS 
41c7						DMARK "ED1" 
41c7 f5				push af  
41c8 3a dc 41			ld a, (.dmark)  
41cb 32 77 fb			ld (debug_mark),a  
41ce 3a dd 41			ld a, (.dmark+1)  
41d1 32 78 fb			ld (debug_mark+1),a  
41d4 3a de 41			ld a, (.dmark+2)  
41d7 32 79 fb			ld (debug_mark+2),a  
41da 18 03			jr .pastdmark  
41dc ..			.dmark: db "ED1"  
41df f1			.pastdmark: pop af  
41e0			endm  
# End of macro DMARK
41e0						CALLMONITOR 
41e0 cd 00 14			call break_point_state  
41e3				endm  
# End of macro CALLMONITOR
41e3					endif 
41e3 cd ac 19				call forth_push_str 
41e6					NEXTW 
41e6 c3 8b 1b			jp macro_next 
41e9				endm 
# End of macro NEXTW
41e9			 
41e9			 
41e9			 
41e9			.ENDKEY: 
41e9			; eof 
41e9			 
# End of file forth_words_key.asm
41e9			 
41e9			if STORAGE_SE 
41e9			   	include "forth_words_storage.asm" 
41e9			 
41e9			; | ## Fixed Storage Words 
41e9			 
41e9			 
41e9			.BREAD: 
41e9			  
41e9				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
41e9 3a				db WORD_SYS_CORE+38             
41ea 62 42			dw .BWRITE            
41ec 06				db 5 + 1 
41ed .. 00			db "BREAD",0              
41f3				endm 
# End of macro CWHEAD
41f3			; | BREAD ( u -- u ) With the current bank, read a block from block address u (1-512) and push to stack  | TO TEST 
41f3				 
41f3					if DEBUG_FORTH_WORDS_KEY 
41f3						DMARK "BRD" 
41f3 f5				push af  
41f4 3a 08 42			ld a, (.dmark)  
41f7 32 77 fb			ld (debug_mark),a  
41fa 3a 09 42			ld a, (.dmark+1)  
41fd 32 78 fb			ld (debug_mark+1),a  
4200 3a 0a 42			ld a, (.dmark+2)  
4203 32 79 fb			ld (debug_mark+2),a  
4206 18 03			jr .pastdmark  
4208 ..			.dmark: db "BRD"  
420b f1			.pastdmark: pop af  
420c			endm  
# End of macro DMARK
420c						CALLMONITOR 
420c cd 00 14			call break_point_state  
420f				endm  
# End of macro CALLMONITOR
420f					endif 
420f			 
420f				FORTH_DSP_VALUEHL 
420f cd 35 1a			call macro_dsp_valuehl 
4212				endm 
# End of macro FORTH_DSP_VALUEHL
4212			 
4212				FORTH_DSP_POP 
4212 cd d1 1a			call macro_forth_dsp_pop 
4215				endm 
# End of macro FORTH_DSP_POP
4215			 
4215				; calc block address 
4215			 
4215 eb				ex de, hl 
4216 3e 40			ld a, STORE_BLOCK_PHY 
4218 cd 95 0b			call Mult16 
421b			 
421b			 
421b 11 62 f8			ld de, store_page 
421e			 
421e					if DEBUG_FORTH_WORDS 
421e						DMARK "BR1" 
421e f5				push af  
421f 3a 33 42			ld a, (.dmark)  
4222 32 77 fb			ld (debug_mark),a  
4225 3a 34 42			ld a, (.dmark+1)  
4228 32 78 fb			ld (debug_mark+1),a  
422b 3a 35 42			ld a, (.dmark+2)  
422e 32 79 fb			ld (debug_mark+2),a  
4231 18 03			jr .pastdmark  
4233 ..			.dmark: db "BR1"  
4236 f1			.pastdmark: pop af  
4237			endm  
# End of macro DMARK
4237						CALLMONITOR 
4237 cd 00 14			call break_point_state  
423a				endm  
# End of macro CALLMONITOR
423a					endif 
423a			 
423a cd 0c 03			call storage_read_block 
423d			 
423d 21 64 f8		        ld hl, store_page+2 
4240					if DEBUG_FORTH_WORDS 
4240						DMARK "BR2" 
4240 f5				push af  
4241 3a 55 42			ld a, (.dmark)  
4244 32 77 fb			ld (debug_mark),a  
4247 3a 56 42			ld a, (.dmark+1)  
424a 32 78 fb			ld (debug_mark+1),a  
424d 3a 57 42			ld a, (.dmark+2)  
4250 32 79 fb			ld (debug_mark+2),a  
4253 18 03			jr .pastdmark  
4255 ..			.dmark: db "BR2"  
4258 f1			.pastdmark: pop af  
4259			endm  
# End of macro DMARK
4259						CALLMONITOR 
4259 cd 00 14			call break_point_state  
425c				endm  
# End of macro CALLMONITOR
425c					endif 
425c cd ac 19			call forth_push_str 
425f			 
425f			 
425f					NEXTW 
425f c3 8b 1b			jp macro_next 
4262				endm 
# End of macro NEXTW
4262			.BWRITE: 
4262				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
4262 3a				db WORD_SYS_CORE+38             
4263 f7 42			dw .BUPD            
4265 07				db 6 + 1 
4266 .. 00			db "BWRITE",0              
426d				endm 
# End of macro CWHEAD
426d			; | BWRITE ( s u -- ) With the current bank, write the string s to address u | TO TEST 
426d			 
426d					if DEBUG_FORTH_WORDS_KEY 
426d						DMARK "BWR" 
426d f5				push af  
426e 3a 82 42			ld a, (.dmark)  
4271 32 77 fb			ld (debug_mark),a  
4274 3a 83 42			ld a, (.dmark+1)  
4277 32 78 fb			ld (debug_mark+1),a  
427a 3a 84 42			ld a, (.dmark+2)  
427d 32 79 fb			ld (debug_mark+2),a  
4280 18 03			jr .pastdmark  
4282 ..			.dmark: db "BWR"  
4285 f1			.pastdmark: pop af  
4286			endm  
# End of macro DMARK
4286						CALLMONITOR 
4286 cd 00 14			call break_point_state  
4289				endm  
# End of macro CALLMONITOR
4289					endif 
4289			 
4289				FORTH_DSP_VALUEHL 
4289 cd 35 1a			call macro_dsp_valuehl 
428c				endm 
# End of macro FORTH_DSP_VALUEHL
428c			 
428c				; calc block address 
428c			 
428c eb				ex de, hl 
428d 3e 40			ld a, STORE_BLOCK_PHY 
428f cd 95 0b			call Mult16 
4292			 
4292 e5				push hl         ; address 
4293			 
4293				FORTH_DSP_POP 
4293 cd d1 1a			call macro_forth_dsp_pop 
4296				endm 
# End of macro FORTH_DSP_POP
4296			 
4296				FORTH_DSP_VALUEHL 
4296 cd 35 1a			call macro_dsp_valuehl 
4299				endm 
# End of macro FORTH_DSP_VALUEHL
4299			 
4299				FORTH_DSP_POP 
4299 cd d1 1a			call macro_forth_dsp_pop 
429c				endm 
# End of macro FORTH_DSP_POP
429c			 
429c cd 0d 0a			call storage_clear_page 
429f			 
429f				; copy string to store page 
429f			 
429f e5				push hl     ; save string address 
42a0			 
42a0 3e 00			ld a, 0 
42a2 cd 7b 10			call strlent 
42a5			 
42a5 23				inc hl 
42a6			 
42a6 4d				ld c, l 
42a7 06 00			ld b, 0 
42a9			 
42a9 e1				pop hl 
42aa 11 64 f8			ld de, store_page + 2 
42ad					if DEBUG_FORTH_WORDS 
42ad						DMARK "BW1" 
42ad f5				push af  
42ae 3a c2 42			ld a, (.dmark)  
42b1 32 77 fb			ld (debug_mark),a  
42b4 3a c3 42			ld a, (.dmark+1)  
42b7 32 78 fb			ld (debug_mark+1),a  
42ba 3a c4 42			ld a, (.dmark+2)  
42bd 32 79 fb			ld (debug_mark+2),a  
42c0 18 03			jr .pastdmark  
42c2 ..			.dmark: db "BW1"  
42c5 f1			.pastdmark: pop af  
42c6			endm  
# End of macro DMARK
42c6						CALLMONITOR 
42c6 cd 00 14			call break_point_state  
42c9				endm  
# End of macro CALLMONITOR
42c9					endif 
42c9 ed b0			ldir 
42cb			 
42cb			 
42cb				; poke the start of the block with flags to prevent high level file ops hitting the block 
42cb			 
42cb 21 ff ff			ld hl, $ffff 
42ce			 
42ce 22 62 f8			ld (store_page), hl	 
42d1				 
42d1 e1				pop hl    ; get address 
42d2 11 62 f8			ld de, store_page 
42d5			 
42d5					if DEBUG_FORTH_WORDS 
42d5						DMARK "BW2" 
42d5 f5				push af  
42d6 3a ea 42			ld a, (.dmark)  
42d9 32 77 fb			ld (debug_mark),a  
42dc 3a eb 42			ld a, (.dmark+1)  
42df 32 78 fb			ld (debug_mark+1),a  
42e2 3a ec 42			ld a, (.dmark+2)  
42e5 32 79 fb			ld (debug_mark+2),a  
42e8 18 03			jr .pastdmark  
42ea ..			.dmark: db "BW2"  
42ed f1			.pastdmark: pop af  
42ee			endm  
# End of macro DMARK
42ee						CALLMONITOR 
42ee cd 00 14			call break_point_state  
42f1				endm  
# End of macro CALLMONITOR
42f1					endif 
42f1			 
42f1 cd 71 03			call storage_write_block 
42f4			 
42f4					NEXTW 
42f4 c3 8b 1b			jp macro_next 
42f7				endm 
# End of macro NEXTW
42f7			 
42f7			.BUPD: 
42f7				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
42f7 3a				db WORD_SYS_CORE+38             
42f8 4d 43			dw .BYID            
42fa 05				db 4 + 1 
42fb .. 00			db "BUPD",0              
4300				endm 
# End of macro CWHEAD
4300			; | BUPD ( u -- ) Write the contents of the current file system storage buffer directly to address u | TO TEST 
4300			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
4300			; | | or completely different file system structure. 
4300			 
4300					if DEBUG_FORTH_WORDS_KEY 
4300						DMARK "BUD" 
4300 f5				push af  
4301 3a 15 43			ld a, (.dmark)  
4304 32 77 fb			ld (debug_mark),a  
4307 3a 16 43			ld a, (.dmark+1)  
430a 32 78 fb			ld (debug_mark+1),a  
430d 3a 17 43			ld a, (.dmark+2)  
4310 32 79 fb			ld (debug_mark+2),a  
4313 18 03			jr .pastdmark  
4315 ..			.dmark: db "BUD"  
4318 f1			.pastdmark: pop af  
4319			endm  
# End of macro DMARK
4319						CALLMONITOR 
4319 cd 00 14			call break_point_state  
431c				endm  
# End of macro CALLMONITOR
431c					endif 
431c			 
431c				FORTH_DSP_VALUEHL 
431c cd 35 1a			call macro_dsp_valuehl 
431f				endm 
# End of macro FORTH_DSP_VALUEHL
431f			 
431f				; calc block address 
431f			 
431f eb				ex de, hl 
4320 3e 40			ld a, STORE_BLOCK_PHY 
4322 cd 95 0b			call Mult16 
4325			 
4325				FORTH_DSP_POP 
4325 cd d1 1a			call macro_forth_dsp_pop 
4328				endm 
# End of macro FORTH_DSP_POP
4328			 
4328			 
4328 11 62 f8			ld de, store_page 
432b			 
432b					if DEBUG_FORTH_WORDS 
432b						DMARK "BUe" 
432b f5				push af  
432c 3a 40 43			ld a, (.dmark)  
432f 32 77 fb			ld (debug_mark),a  
4332 3a 41 43			ld a, (.dmark+1)  
4335 32 78 fb			ld (debug_mark+1),a  
4338 3a 42 43			ld a, (.dmark+2)  
433b 32 79 fb			ld (debug_mark+2),a  
433e 18 03			jr .pastdmark  
4340 ..			.dmark: db "BUe"  
4343 f1			.pastdmark: pop af  
4344			endm  
# End of macro DMARK
4344						CALLMONITOR 
4344 cd 00 14			call break_point_state  
4347				endm  
# End of macro CALLMONITOR
4347					endif 
4347			 
4347 cd 71 03			call storage_write_block 
434a			 
434a					NEXTW 
434a c3 8b 1b			jp macro_next 
434d				endm 
# End of macro NEXTW
434d			 
434d			.BYID: 
434d			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
434d			;; | BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u | TODO 
434d			; 
434d			;		 
434d			;		if DEBUG_FORTH_WORDS_KEY 
434d			;			DMARK "BYID" 
434d			;			CALLMONITOR 
434d			;		endif 
434d			; 
434d			;		; get direct address 
434d			; 
434d			;		FORTH_DSP_VALUEHL 
434d			; 
434d			;		FORTH_DSP_POP 
434d			; 
434d			;	; calc block address 
434d			; 
434d			;	ex de, hl 
434d			;	ld a, STORE_BLOCK_PHY 
434d			;	call Mult16 
434d			;	;	do BREAD with number as param 
434d			;	; push the file name	 
434d			;	ld de, store_page 
434d			;	call storage_read_block 
434d			 ;       ld hl, store_page+2 
434d			; 
434d			; 
434d			;		NEXTW 
434d			;.BYNAME: 
434d			;	CWHEAD .DIR 38 "BYNAME" 6 WORD_FLAG_CODE 
434d			;; | BYNAME ( s -- u ) Get the file ID in the current BANK of the file named s | TODO 
434d			;		NEXTW 
434d			; 
434d			.DIR: 
434d				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
434d 3a				db WORD_SYS_CORE+38             
434e 51 44			dw .SAVE            
4350 04				db 3 + 1 
4351 .. 00			db "DIR",0              
4355				endm 
# End of macro CWHEAD
4355			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
4355			 
4355					if DEBUG_FORTH_WORDS_KEY 
4355						DMARK "DIR" 
4355 f5				push af  
4356 3a 6a 43			ld a, (.dmark)  
4359 32 77 fb			ld (debug_mark),a  
435c 3a 6b 43			ld a, (.dmark+1)  
435f 32 78 fb			ld (debug_mark+1),a  
4362 3a 6c 43			ld a, (.dmark+2)  
4365 32 79 fb			ld (debug_mark+2),a  
4368 18 03			jr .pastdmark  
436a ..			.dmark: db "DIR"  
436d f1			.pastdmark: pop af  
436e			endm  
# End of macro DMARK
436e						CALLMONITOR 
436e cd 00 14			call break_point_state  
4371				endm  
# End of macro CALLMONITOR
4371					endif 
4371 cd bd 03			call storage_get_block_0 
4374			 
4374 21 62 f8			ld hl, store_page     ; get current id count 
4377 46				ld b, (hl) 
4378 0e 00			ld c, 0    ; count of files   
437a					if DEBUG_FORTH_WORDS 
437a						DMARK "DI1" 
437a f5				push af  
437b 3a 8f 43			ld a, (.dmark)  
437e 32 77 fb			ld (debug_mark),a  
4381 3a 90 43			ld a, (.dmark+1)  
4384 32 78 fb			ld (debug_mark+1),a  
4387 3a 91 43			ld a, (.dmark+2)  
438a 32 79 fb			ld (debug_mark+2),a  
438d 18 03			jr .pastdmark  
438f ..			.dmark: db "DI1"  
4392 f1			.pastdmark: pop af  
4393			endm  
# End of macro DMARK
4393						CALLMONITOR 
4393 cd 00 14			call break_point_state  
4396				endm  
# End of macro CALLMONITOR
4396					endif 
4396			 
4396				; check for empty drive 
4396			 
4396 3e 00			ld a, 0 
4398 b8				cp b 
4399 ca 07 44			jp z, .dirdone 
439c			 
439c				; for each of the current ids do a search for them and if found push to stack 
439c			 
439c c5			.diritem:	push bc 
439d 21 40 00				ld hl, STORE_BLOCK_PHY 
43a0 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
43a2 58					ld e,b 
43a3			 
43a3			;		if DEBUG_FORTH_WORDS 
43a3			;			DMARK "DI2" 
43a3			;			CALLMONITOR 
43a3			;		endif 
43a3			 
43a3 cd 22 06				call storage_findnextid 
43a6			 
43a6			;		if DEBUG_FORTH_WORDS 
43a6			;			DMARK "DI3" 
43a6			;			CALLMONITOR 
43a6			;		endif 
43a6			 
43a6					; if found hl will be non zero 
43a6			 
43a6 cd 3b 0c				call ishlzero 
43a9			;		ld a, l 
43a9			;		add h 
43a9			; 
43a9			;		cp 0 
43a9 28 59				jr z, .dirnotfound 
43ab			 
43ab					; increase count 
43ab			 
43ab c1					pop bc	 
43ac 0c					inc c 
43ad c5					push bc 
43ae					 
43ae			 
43ae					; get file header and push the file name 
43ae			 
43ae 11 62 f8				ld de, store_page 
43b1 cd 0c 03				call storage_read_block 
43b4			 
43b4					; push file id to stack 
43b4				 
43b4 3a 62 f8				ld a, (store_page) 
43b7 26 00				ld h, 0 
43b9 6f					ld l, a 
43ba cd 9a 19				call forth_push_numhl 
43bd			 
43bd					; push extent count to stack  
43bd				 
43bd 3a 64 f8				ld a, (store_page+2) 
43c0 26 00				ld h, 0 
43c2 6f					ld l, a 
43c3 cd 9a 19				call forth_push_numhl 
43c6			 
43c6					; push file name 
43c6			 
43c6 21 65 f8				ld hl, store_page+3 
43c9					if DEBUG_FORTH_WORDS 
43c9						DMARK "DI5" 
43c9 f5				push af  
43ca 3a de 43			ld a, (.dmark)  
43cd 32 77 fb			ld (debug_mark),a  
43d0 3a df 43			ld a, (.dmark+1)  
43d3 32 78 fb			ld (debug_mark+1),a  
43d6 3a e0 43			ld a, (.dmark+2)  
43d9 32 79 fb			ld (debug_mark+2),a  
43dc 18 03			jr .pastdmark  
43de ..			.dmark: db "DI5"  
43e1 f1			.pastdmark: pop af  
43e2			endm  
# End of macro DMARK
43e2						CALLMONITOR 
43e2 cd 00 14			call break_point_state  
43e5				endm  
# End of macro CALLMONITOR
43e5					endif 
43e5 cd ac 19				call forth_push_str 
43e8					if DEBUG_FORTH_WORDS 
43e8						DMARK "DI6" 
43e8 f5				push af  
43e9 3a fd 43			ld a, (.dmark)  
43ec 32 77 fb			ld (debug_mark),a  
43ef 3a fe 43			ld a, (.dmark+1)  
43f2 32 78 fb			ld (debug_mark+1),a  
43f5 3a ff 43			ld a, (.dmark+2)  
43f8 32 79 fb			ld (debug_mark+2),a  
43fb 18 03			jr .pastdmark  
43fd ..			.dmark: db "DI6"  
4400 f1			.pastdmark: pop af  
4401			endm  
# End of macro DMARK
4401						CALLMONITOR 
4401 cd 00 14			call break_point_state  
4404				endm  
# End of macro CALLMONITOR
4404					endif 
4404			.dirnotfound: 
4404 c1					pop bc     
4405 10 95				djnz .diritem 
4407				 
4407			.dirdone:	 
4407					if DEBUG_FORTH_WORDS 
4407						DMARK "DI7" 
4407 f5				push af  
4408 3a 1c 44			ld a, (.dmark)  
440b 32 77 fb			ld (debug_mark),a  
440e 3a 1d 44			ld a, (.dmark+1)  
4411 32 78 fb			ld (debug_mark+1),a  
4414 3a 1e 44			ld a, (.dmark+2)  
4417 32 79 fb			ld (debug_mark+2),a  
441a 18 03			jr .pastdmark  
441c ..			.dmark: db "DI7"  
441f f1			.pastdmark: pop af  
4420			endm  
# End of macro DMARK
4420						CALLMONITOR 
4420 cd 00 14			call break_point_state  
4423				endm  
# End of macro CALLMONITOR
4423					endif 
4423			 
4423					; push a count of the dir items found 
4423			 
4423 26 00				ld h, 0 
4425 69					ld l, c 
4426 cd 9a 19				call forth_push_numhl 
4429			 
4429					; push the bank label 
4429			 
4429 cd bd 03				call storage_get_block_0 
442c			 
442c				 
442c 21 65 f8		 		ld hl, store_page+3 
442f			 
442f					if DEBUG_FORTH_WORDS 
442f						DMARK "DI8" 
442f f5				push af  
4430 3a 44 44			ld a, (.dmark)  
4433 32 77 fb			ld (debug_mark),a  
4436 3a 45 44			ld a, (.dmark+1)  
4439 32 78 fb			ld (debug_mark+1),a  
443c 3a 46 44			ld a, (.dmark+2)  
443f 32 79 fb			ld (debug_mark+2),a  
4442 18 03			jr .pastdmark  
4444 ..			.dmark: db "DI8"  
4447 f1			.pastdmark: pop af  
4448			endm  
# End of macro DMARK
4448						CALLMONITOR 
4448 cd 00 14			call break_point_state  
444b				endm  
# End of macro CALLMONITOR
444b					endif 
444b cd ac 19				call forth_push_str 
444e			 
444e			 
444e				 
444e					NEXTW 
444e c3 8b 1b			jp macro_next 
4451				endm 
# End of macro NEXTW
4451			.SAVE: 
4451			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
4451			;; | SAVE  ( w u -- )    Save user word memory to file name w on bank u | TODO 
4451			;		NEXTW 
4451			;.LOAD: 
4451			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
4451			;; | LOAD ( u -- )    Load user word memory from file id on current bank | TODO 
4451			;; | | The indivdual records being loaded can be both uword word difintions or interactive commands. 
4451			;; | | The LOAD command can not be used in any user words or compound lines. 
4451			; 
4451			;		; store_openext use it. If zero it is EOF 
4451			; 
4451			;		; read block from current stream id 
4451			;		; if the block does not contain zero term keep reading blocks until zero found 
4451			;		; push the block to stack 
4451			;		; save the block id to stream 
4451			; 
4451			; 
4451			;		FORTH_DSP_VALUEHL 
4451			; 
4451			;;		push hl 
4451			; 
4451			;	if DEBUG_STORESE 
4451			;		DMARK "LOA" 
4451			;		CALLMONITOR 
4451			;	endif 
4451			;		FORTH_DSP_POP 
4451			; 
4451			;;		pop hl 
4451			; 
4451			;		ld h, l 
4451			;		ld l, 0 
4451			; 
4451			;		push hl     ; stack holds current file id and extent to work with 
4451			; 
4451			; 
4451			;		ld de, store_page      ; get block zero of file 
4451			;	if DEBUG_STORESE 
4451			;		DMARK "LO0" 
4451			;		CALLMONITOR 
4451			;	endif 
4451			;		call storage_read 
4451			; 
4451			;		ld a, (store_page+2)    ; max extents for this file 
4451			;		ld  (store_openmaxext),a   ; get our limit 
4451			; 
4451			;	if DEBUG_STORESE 
4451			;		DMARK "LOE" 
4451			;		CALLMONITOR 
4451			;	endif 
4451			; 
4451			;; TODO dont know why max extents are not present 
4451			;;		cp 0 
4451			;;		jp z, .loadeof     ; dont read past eof 
4451			; 
4451			;;		ld a, 1   ; start from the head of the file 
4451			; 
4451			;.loadline:	pop hl 
4451			;		inc hl 
4451			;		ld  a, (store_openmaxext)   ; get our limit 
4451			;	if DEBUG_STORESE 
4451			;		DMARK "LOx" 
4451			;		CALLMONITOR 
4451			;	endif 
4451			;		inc a 
4451			;		cp l 
4451			;		jp z, .loadeof 
4451			;		push hl    ; save current extent 
4451			; 
4451			;		ld de, store_page 
4451			; 
4451			;	if DEBUG_STORESE 
4451			;		DMARK "LO1" 
4451			;		CALLMONITOR 
4451			;	endif 
4451			;		call storage_read 
4451			; 
4451			;	if DEBUG_STORESE 
4451			;		DMARK "LO2" 
4451			;		CALLMONITOR 
4451			;	endif 
4451			;	call ishlzero 
4451			;	ld a, l 
4451			;	add h 
4451			;	cp 0 
4451			;	jr z, .loadeof 
4451			; 
4451			;	; not eof so hl should point to data to exec 
4451			; 
4451			;	; will need to add the FORTH_END_BUFFER flag 
4451			 ; 
4451			;	ld hl, store_page+2 
4451			;	ld bc, 255 
4451			;	ld a, 0 
4451			;	cpir 
4451			;	if DEBUG_STORESE 
4451			;		DMARK "LOt" 
4451			;		CALLMONITOR 
4451			;	endif 
4451			;	dec hl 
4451			;	ld a, ' ' 
4451			;	ld (hl), a 
4451			;	inc hl 
4451			;	ld (hl), a 
4451			;	inc hl 
4451			;	ld (hl), a 
4451			;	inc hl 
4451			;	ld a, FORTH_END_BUFFER 
4451			;	ld (hl), a 
4451			; 
4451			;	; TODO handle more than a single block read 
4451			; 
4451			; 
4451			;	ld hl, store_page+2 
4451			; 
4451			;	ld (os_tok_ptr), hl 
4451			; 
4451			;	if DEBUG_STORESE 
4451			;		DMARK "LO3" 
4451			;		CALLMONITOR 
4451			;	endif 
4451			; 
4451			;	call forthparse 
4451			;	call forthexec 
4451			;	call forthexec_cleanup 
4451			; 
4451			;	; go to next extent 
4451			; 
4451			;	; get next block  or mark as eof 
4451			;	jp .loadline 
4451			; 
4451			; 
4451			; 
4451			;	       NEXTW 
4451			;.loadeof:	ld a, 0 
4451			;		ld (store_openext), a 
4451			; 
4451			;	if DEBUG_STORESE 
4451			;		DMARK "LOF" 
4451			;		CALLMONITOR 
4451			;	endif 
4451			;		ret 
4451			;		;NEXTW 
4451			;.BSAVE:   
4451			; 
4451			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
4451			;; | BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes | TODO 
4451			;		NEXTW 
4451			;.BLOAD: 
4451			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
4451			;; | BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u | TODO 
4451			;		NEXTW 
4451			;;;; counter gap 
4451			 
4451			 
4451			.SEO: 
4451				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
4451 64				db WORD_SYS_CORE+80             
4452 70 44			dw .SEI            
4454 04				db 3 + 1 
4455 .. 00			db "SEO",0              
4459				endm 
# End of macro CWHEAD
4459			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
4459			 
4459					; get port 
4459			 
4459					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4459 cd 35 1a			call macro_dsp_valuehl 
445c				endm 
# End of macro FORTH_DSP_VALUEHL
445c			 
445c e5					push hl    ; u2 - byte 
445d			 
445d					; destroy value TOS 
445d			 
445d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
445d cd d1 1a			call macro_forth_dsp_pop 
4460				endm 
# End of macro FORTH_DSP_POP
4460			 
4460					; get byte to send 
4460			 
4460					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4460 cd 35 1a			call macro_dsp_valuehl 
4463				endm 
# End of macro FORTH_DSP_VALUEHL
4463			 
4463 e5					push hl    ; u1 - addr 
4464			 
4464					; destroy value TOS 
4464			 
4464					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4464 cd d1 1a			call macro_forth_dsp_pop 
4467				endm 
# End of macro FORTH_DSP_POP
4467			 
4467					; one value on hl get other one back 
4467			 
4467 d1					pop de   ; u1 - byte 
4468			 
4468 e1					pop hl   ; u2 - addr 
4469			 
4469					; TODO Send SPI byte 
4469			 
4469			 
4469 7b					ld a, e 
446a cd ea 01				call se_writebyte 
446d			 
446d					 
446d			 
446d					NEXTW 
446d c3 8b 1b			jp macro_next 
4470				endm 
# End of macro NEXTW
4470			 
4470			.SEI: 
4470				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
4470 65				db WORD_SYS_CORE+81             
4471 8a 44			dw .SFREE            
4473 04				db 3 + 1 
4474 .. 00			db "SEI",0              
4478				endm 
# End of macro CWHEAD
4478			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
4478			 
4478					; get port 
4478			 
4478					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4478 cd 35 1a			call macro_dsp_valuehl 
447b				endm 
# End of macro FORTH_DSP_VALUEHL
447b			 
447b			;		push hl 
447b			 
447b					; destroy value TOS 
447b			 
447b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
447b cd d1 1a			call macro_forth_dsp_pop 
447e				endm 
# End of macro FORTH_DSP_POP
447e			 
447e					; one value on hl get other one back 
447e			 
447e			;		pop hl 
447e			 
447e			 
447e					; TODO Get SPI byte 
447e			 
447e cd 8c 02				call se_readbyte 
4481			 
4481 26 00				ld h, 0 
4483 6f					ld l, a 
4484 cd 9a 19				call forth_push_numhl 
4487			 
4487					NEXTW 
4487 c3 8b 1b			jp macro_next 
448a				endm 
# End of macro NEXTW
448a			 
448a			.SFREE: 
448a				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
448a 67				db WORD_SYS_CORE+83             
448b b9 44			dw .SIZE            
448d 06				db 5 + 1 
448e .. 00			db "FFREE",0              
4494				endm 
# End of macro CWHEAD
4494			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
4494					if DEBUG_FORTH_WORDS_KEY 
4494						DMARK "FFR" 
4494 f5				push af  
4495 3a a9 44			ld a, (.dmark)  
4498 32 77 fb			ld (debug_mark),a  
449b 3a aa 44			ld a, (.dmark+1)  
449e 32 78 fb			ld (debug_mark+1),a  
44a1 3a ab 44			ld a, (.dmark+2)  
44a4 32 79 fb			ld (debug_mark+2),a  
44a7 18 03			jr .pastdmark  
44a9 ..			.dmark: db "FFR"  
44ac f1			.pastdmark: pop af  
44ad			endm  
# End of macro DMARK
44ad						CALLMONITOR 
44ad cd 00 14			call break_point_state  
44b0				endm  
# End of macro CALLMONITOR
44b0					endif 
44b0			 
44b0 cd bc 06				call storage_freeblocks 
44b3			 
44b3 cd 9a 19				call forth_push_numhl 
44b6			 
44b6				       NEXTW 
44b6 c3 8b 1b			jp macro_next 
44b9				endm 
# End of macro NEXTW
44b9			.SIZE: 
44b9				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
44b9 67				db WORD_SYS_CORE+83             
44ba ed 44			dw .CREATE            
44bc 05				db 4 + 1 
44bd .. 00			db "SIZE",0              
44c2				endm 
# End of macro CWHEAD
44c2			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
44c2					if DEBUG_FORTH_WORDS_KEY 
44c2						DMARK "SIZ" 
44c2 f5				push af  
44c3 3a d7 44			ld a, (.dmark)  
44c6 32 77 fb			ld (debug_mark),a  
44c9 3a d8 44			ld a, (.dmark+1)  
44cc 32 78 fb			ld (debug_mark+1),a  
44cf 3a d9 44			ld a, (.dmark+2)  
44d2 32 79 fb			ld (debug_mark+2),a  
44d5 18 03			jr .pastdmark  
44d7 ..			.dmark: db "SIZ"  
44da f1			.pastdmark: pop af  
44db			endm  
# End of macro DMARK
44db						CALLMONITOR 
44db cd 00 14			call break_point_state  
44de				endm  
# End of macro CALLMONITOR
44de					endif 
44de			 
44de					FORTH_DSP_VALUEHL 
44de cd 35 1a			call macro_dsp_valuehl 
44e1				endm 
# End of macro FORTH_DSP_VALUEHL
44e1			;		push hl 
44e1					FORTH_DSP_POP 
44e1 cd d1 1a			call macro_forth_dsp_pop 
44e4				endm 
# End of macro FORTH_DSP_POP
44e4			;		pop hl 
44e4 cd 3b 03				call storage_file_size 
44e7			 
44e7 cd 9a 19				call forth_push_numhl 
44ea			  
44ea			 
44ea				       NEXTW 
44ea c3 8b 1b			jp macro_next 
44ed				endm 
# End of macro NEXTW
44ed			 
44ed			.CREATE: 
44ed				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
44ed 68				db WORD_SYS_CORE+84             
44ee 5b 45			dw .APPEND            
44f0 07				db 6 + 1 
44f1 .. 00			db "CREATE",0              
44f8				endm 
# End of macro CWHEAD
44f8			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
44f8			; | | e.g.  
44f8			; | | TestProgram CREATE 
44f8			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
44f8			; | |  
44f8			; | | Max file IDs are 255. 
44f8			; | |  
44f8					 
44f8					if DEBUG_FORTH_WORDS_KEY 
44f8						DMARK "CRT" 
44f8 f5				push af  
44f9 3a 0d 45			ld a, (.dmark)  
44fc 32 77 fb			ld (debug_mark),a  
44ff 3a 0e 45			ld a, (.dmark+1)  
4502 32 78 fb			ld (debug_mark+1),a  
4505 3a 0f 45			ld a, (.dmark+2)  
4508 32 79 fb			ld (debug_mark+2),a  
450b 18 03			jr .pastdmark  
450d ..			.dmark: db "CRT"  
4510 f1			.pastdmark: pop af  
4511			endm  
# End of macro DMARK
4511						CALLMONITOR 
4511 cd 00 14			call break_point_state  
4514				endm  
# End of macro CALLMONITOR
4514					endif 
4514			;		call storage_get_block_0 
4514			 
4514					; TODO pop hl 
4514			 
4514					;v5 FORTH_DSP_VALUE 
4514					FORTH_DSP_VALUE 
4514 cd 1e 1a			call macro_forth_dsp_value 
4517				endm 
# End of macro FORTH_DSP_VALUE
4517			 
4517				if DEBUG_STORESE 
4517					DMARK "CR1" 
4517 f5				push af  
4518 3a 2c 45			ld a, (.dmark)  
451b 32 77 fb			ld (debug_mark),a  
451e 3a 2d 45			ld a, (.dmark+1)  
4521 32 78 fb			ld (debug_mark+1),a  
4524 3a 2e 45			ld a, (.dmark+2)  
4527 32 79 fb			ld (debug_mark+2),a  
452a 18 03			jr .pastdmark  
452c ..			.dmark: db "CR1"  
452f f1			.pastdmark: pop af  
4530			endm  
# End of macro DMARK
4530					CALLMONITOR 
4530 cd 00 14			call break_point_state  
4533				endm  
# End of macro CALLMONITOR
4533				endif 
4533			;		push hl 
4533			;		FORTH_DSP_POP 
4533			;		pop hl 
4533			 
4533			;		inc hl   ; move past the type marker 
4533			 
4533 cd f2 06				call storage_create 
4536			 
4536				if DEBUG_STORESE 
4536					DMARK "CT1" 
4536 f5				push af  
4537 3a 4b 45			ld a, (.dmark)  
453a 32 77 fb			ld (debug_mark),a  
453d 3a 4c 45			ld a, (.dmark+1)  
4540 32 78 fb			ld (debug_mark+1),a  
4543 3a 4d 45			ld a, (.dmark+2)  
4546 32 79 fb			ld (debug_mark+2),a  
4549 18 03			jr .pastdmark  
454b ..			.dmark: db "CT1"  
454e f1			.pastdmark: pop af  
454f			endm  
# End of macro DMARK
454f					CALLMONITOR 
454f cd 00 14			call break_point_state  
4552				endm  
# End of macro CALLMONITOR
4552				endif 
4552			;		push hl 
4552					FORTH_DSP_POP 
4552 cd d1 1a			call macro_forth_dsp_pop 
4555				endm 
# End of macro FORTH_DSP_POP
4555			;		pop hl 
4555					; push file id to stack 
4555 cd 9a 19				call forth_push_numhl 
4558			 
4558			 
4558			 
4558				       NEXTW 
4558 c3 8b 1b			jp macro_next 
455b				endm 
# End of macro NEXTW
455b			 
455b			.APPEND: 
455b				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
455b 69				db WORD_SYS_CORE+85             
455c ec 45			dw .SDEL            
455e 07				db 6 + 1 
455f .. 00			db "APPEND",0              
4566				endm 
# End of macro CWHEAD
4566			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
4566			; | | e.g. 
4566			; | | Test CREATE      -> $01 
4566			; | | "A string to add to file" $01 APPEND 
4566			; | |  
4566			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
4566					if DEBUG_FORTH_WORDS_KEY 
4566						DMARK "APP" 
4566 f5				push af  
4567 3a 7b 45			ld a, (.dmark)  
456a 32 77 fb			ld (debug_mark),a  
456d 3a 7c 45			ld a, (.dmark+1)  
4570 32 78 fb			ld (debug_mark+1),a  
4573 3a 7d 45			ld a, (.dmark+2)  
4576 32 79 fb			ld (debug_mark+2),a  
4579 18 03			jr .pastdmark  
457b ..			.dmark: db "APP"  
457e f1			.pastdmark: pop af  
457f			endm  
# End of macro DMARK
457f						CALLMONITOR 
457f cd 00 14			call break_point_state  
4582				endm  
# End of macro CALLMONITOR
4582					endif 
4582			 
4582					FORTH_DSP_VALUEHL 
4582 cd 35 1a			call macro_dsp_valuehl 
4585				endm 
# End of macro FORTH_DSP_VALUEHL
4585 e5					push hl 	; save file id 
4586			 
4586				if DEBUG_STORESE 
4586					DMARK "AP1" 
4586 f5				push af  
4587 3a 9b 45			ld a, (.dmark)  
458a 32 77 fb			ld (debug_mark),a  
458d 3a 9c 45			ld a, (.dmark+1)  
4590 32 78 fb			ld (debug_mark+1),a  
4593 3a 9d 45			ld a, (.dmark+2)  
4596 32 79 fb			ld (debug_mark+2),a  
4599 18 03			jr .pastdmark  
459b ..			.dmark: db "AP1"  
459e f1			.pastdmark: pop af  
459f			endm  
# End of macro DMARK
459f					CALLMONITOR 
459f cd 00 14			call break_point_state  
45a2				endm  
# End of macro CALLMONITOR
45a2				endif 
45a2					FORTH_DSP_POP 
45a2 cd d1 1a			call macro_forth_dsp_pop 
45a5				endm 
# End of macro FORTH_DSP_POP
45a5			 
45a5					FORTH_DSP_VALUEHL 
45a5 cd 35 1a			call macro_dsp_valuehl 
45a8				endm 
# End of macro FORTH_DSP_VALUEHL
45a8					;v5 FORTH_DSP_VALUE 
45a8 e5					push hl 	; save ptr to string to save 
45a9			 
45a9				if DEBUG_STORESE 
45a9					DMARK "AP1" 
45a9 f5				push af  
45aa 3a be 45			ld a, (.dmark)  
45ad 32 77 fb			ld (debug_mark),a  
45b0 3a bf 45			ld a, (.dmark+1)  
45b3 32 78 fb			ld (debug_mark+1),a  
45b6 3a c0 45			ld a, (.dmark+2)  
45b9 32 79 fb			ld (debug_mark+2),a  
45bc 18 03			jr .pastdmark  
45be ..			.dmark: db "AP1"  
45c1 f1			.pastdmark: pop af  
45c2			endm  
# End of macro DMARK
45c2					CALLMONITOR 
45c2 cd 00 14			call break_point_state  
45c5				endm  
# End of macro CALLMONITOR
45c5				endif 
45c5					FORTH_DSP_POP 
45c5 cd d1 1a			call macro_forth_dsp_pop 
45c8				endm 
# End of macro FORTH_DSP_POP
45c8			 
45c8 d1					pop de 
45c9 e1					pop hl 
45ca				if DEBUG_STORESE 
45ca					DMARK "AP2" 
45ca f5				push af  
45cb 3a df 45			ld a, (.dmark)  
45ce 32 77 fb			ld (debug_mark),a  
45d1 3a e0 45			ld a, (.dmark+1)  
45d4 32 78 fb			ld (debug_mark+1),a  
45d7 3a e1 45			ld a, (.dmark+2)  
45da 32 79 fb			ld (debug_mark+2),a  
45dd 18 03			jr .pastdmark  
45df ..			.dmark: db "AP2"  
45e2 f1			.pastdmark: pop af  
45e3			endm  
# End of macro DMARK
45e3					CALLMONITOR 
45e3 cd 00 14			call break_point_state  
45e6				endm  
# End of macro CALLMONITOR
45e6				endif 
45e6					;inc de ; skip var type indicator 
45e6			 
45e6					; TODO how to append numerics???? 
45e6			 
45e6 cd cc 08				call storage_append		 
45e9			 
45e9				       NEXTW 
45e9 c3 8b 1b			jp macro_next 
45ec				endm 
# End of macro NEXTW
45ec			.SDEL: 
45ec				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
45ec 6a				db WORD_SYS_CORE+86             
45ed 38 46			dw .OPEN            
45ef 05				db 4 + 1 
45f0 .. 00			db "ERA",0              
45f4				endm 
# End of macro CWHEAD
45f4			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
45f4					FORTH_DSP_VALUEHL 
45f4 cd 35 1a			call macro_dsp_valuehl 
45f7				endm 
# End of macro FORTH_DSP_VALUEHL
45f7			;		push hl 	; save file id 
45f7			 
45f7					if DEBUG_FORTH_WORDS_KEY 
45f7						DMARK "ERA" 
45f7 f5				push af  
45f8 3a 0c 46			ld a, (.dmark)  
45fb 32 77 fb			ld (debug_mark),a  
45fe 3a 0d 46			ld a, (.dmark+1)  
4601 32 78 fb			ld (debug_mark+1),a  
4604 3a 0e 46			ld a, (.dmark+2)  
4607 32 79 fb			ld (debug_mark+2),a  
460a 18 03			jr .pastdmark  
460c ..			.dmark: db "ERA"  
460f f1			.pastdmark: pop af  
4610			endm  
# End of macro DMARK
4610						CALLMONITOR 
4610 cd 00 14			call break_point_state  
4613				endm  
# End of macro CALLMONITOR
4613					endif 
4613				if DEBUG_STORESE 
4613					DMARK "ER1" 
4613 f5				push af  
4614 3a 28 46			ld a, (.dmark)  
4617 32 77 fb			ld (debug_mark),a  
461a 3a 29 46			ld a, (.dmark+1)  
461d 32 78 fb			ld (debug_mark+1),a  
4620 3a 2a 46			ld a, (.dmark+2)  
4623 32 79 fb			ld (debug_mark+2),a  
4626 18 03			jr .pastdmark  
4628 ..			.dmark: db "ER1"  
462b f1			.pastdmark: pop af  
462c			endm  
# End of macro DMARK
462c					CALLMONITOR 
462c cd 00 14			call break_point_state  
462f				endm  
# End of macro CALLMONITOR
462f				endif 
462f					FORTH_DSP_POP 
462f cd d1 1a			call macro_forth_dsp_pop 
4632				endm 
# End of macro FORTH_DSP_POP
4632			 
4632			;		pop hl 
4632			 
4632 cd 41 05				call storage_erase 
4635				       NEXTW 
4635 c3 8b 1b			jp macro_next 
4638				endm 
# End of macro NEXTW
4638			 
4638			.OPEN: 
4638				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
4638 6b				db WORD_SYS_CORE+87             
4639 bf 46			dw .READ            
463b 05				db 4 + 1 
463c .. 00			db "OPEN",0              
4641				endm 
# End of macro CWHEAD
4641			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
4641			; | | e.g. 
4641			; | | $01 OPEN $01 DO $01 READ . LOOP 
4641			 
4641					if DEBUG_FORTH_WORDS_KEY 
4641						DMARK "OPN" 
4641 f5				push af  
4642 3a 56 46			ld a, (.dmark)  
4645 32 77 fb			ld (debug_mark),a  
4648 3a 57 46			ld a, (.dmark+1)  
464b 32 78 fb			ld (debug_mark+1),a  
464e 3a 58 46			ld a, (.dmark+2)  
4651 32 79 fb			ld (debug_mark+2),a  
4654 18 03			jr .pastdmark  
4656 ..			.dmark: db "OPN"  
4659 f1			.pastdmark: pop af  
465a			endm  
# End of macro DMARK
465a						CALLMONITOR 
465a cd 00 14			call break_point_state  
465d				endm  
# End of macro CALLMONITOR
465d					endif 
465d					; TODO handle multiple file opens 
465d			 
465d 3e 01			       	ld a, 1 
465f 32 59 f8				ld (store_openext), a 
4662			 
4662					; get max extents for this file 
4662				 
4662								 
4662					FORTH_DSP_VALUEHL 
4662 cd 35 1a			call macro_dsp_valuehl 
4665				endm 
# End of macro FORTH_DSP_VALUEHL
4665			 
4665 65					ld h, l 
4666 2e 00				ld l, 0 
4668			 
4668				if DEBUG_STORESE 
4668					DMARK "OPN" 
4668 f5				push af  
4669 3a 7d 46			ld a, (.dmark)  
466c 32 77 fb			ld (debug_mark),a  
466f 3a 7e 46			ld a, (.dmark+1)  
4672 32 78 fb			ld (debug_mark+1),a  
4675 3a 7f 46			ld a, (.dmark+2)  
4678 32 79 fb			ld (debug_mark+2),a  
467b 18 03			jr .pastdmark  
467d ..			.dmark: db "OPN"  
4680 f1			.pastdmark: pop af  
4681			endm  
# End of macro DMARK
4681					CALLMONITOR 
4681 cd 00 14			call break_point_state  
4684				endm  
# End of macro CALLMONITOR
4684				endif 
4684			;		push hl 
4684					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
4684 cd d1 1a			call macro_forth_dsp_pop 
4687				endm 
# End of macro FORTH_DSP_POP
4687			;		pop hl 
4687						 
4687 11 62 f8				ld de, store_page      ; get block zero of file 
468a cd 46 08				call storage_read 
468d			 
468d			 
468d 3a 64 f8				ld a, (store_page+2)    ; max extents for this file 
4690 32 58 f8				ld  (store_openmaxext), a   ; get our limit and push 
4693					 
4693				if DEBUG_STORESE 
4693					DMARK "OPx" 
4693 f5				push af  
4694 3a a8 46			ld a, (.dmark)  
4697 32 77 fb			ld (debug_mark),a  
469a 3a a9 46			ld a, (.dmark+1)  
469d 32 78 fb			ld (debug_mark+1),a  
46a0 3a aa 46			ld a, (.dmark+2)  
46a3 32 79 fb			ld (debug_mark+2),a  
46a6 18 03			jr .pastdmark  
46a8 ..			.dmark: db "OPx"  
46ab f1			.pastdmark: pop af  
46ac			endm  
# End of macro DMARK
46ac					CALLMONITOR 
46ac cd 00 14			call break_point_state  
46af				endm  
# End of macro CALLMONITOR
46af				endif 
46af fe 00				cp 0 
46b1 20 03				jr nz, .skipopeneof 
46b3					; have opened an empty file 
46b3					 
46b3 32 59 f8				ld (store_openext), a 
46b6			 
46b6			.skipopeneof: 
46b6			 
46b6 6f					ld l, a 
46b7 26 00				ld h, 0 
46b9 cd 9a 19				call forth_push_numhl 
46bc			 
46bc			 
46bc				       NEXTW 
46bc c3 8b 1b			jp macro_next 
46bf				endm 
# End of macro NEXTW
46bf			.READ: 
46bf				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
46bf 6c				db WORD_SYS_CORE+88             
46c0 06 48			dw .EOF            
46c2 05				db 4 + 1 
46c3 .. 00			db "READ",0              
46c8				endm 
# End of macro CWHEAD
46c8			; | READ ( n -- n  )  Reads next page of file id and push to stack | DONE 
46c8			; | | e.g. 
46c8			; | | $01 OPEN $01 DO $01 READ . LOOP 
46c8			 
46c8					if DEBUG_FORTH_WORDS_KEY 
46c8						DMARK "REA" 
46c8 f5				push af  
46c9 3a dd 46			ld a, (.dmark)  
46cc 32 77 fb			ld (debug_mark),a  
46cf 3a de 46			ld a, (.dmark+1)  
46d2 32 78 fb			ld (debug_mark+1),a  
46d5 3a df 46			ld a, (.dmark+2)  
46d8 32 79 fb			ld (debug_mark+2),a  
46db 18 03			jr .pastdmark  
46dd ..			.dmark: db "REA"  
46e0 f1			.pastdmark: pop af  
46e1			endm  
# End of macro DMARK
46e1						CALLMONITOR 
46e1 cd 00 14			call break_point_state  
46e4				endm  
# End of macro CALLMONITOR
46e4					endif 
46e4					; store_openext use it. If zero it is EOF 
46e4			 
46e4					; read block from current stream id 
46e4					; if the block does not contain zero term keep reading blocks until zero found 
46e4					; push the block to stack 
46e4					; save the block id to stream 
46e4			 
46e4			 
46e4					FORTH_DSP_VALUEHL 
46e4 cd 35 1a			call macro_dsp_valuehl 
46e7				endm 
# End of macro FORTH_DSP_VALUEHL
46e7			 
46e7			;		push hl 
46e7			 
46e7				if DEBUG_STORESE 
46e7					DMARK "REA" 
46e7 f5				push af  
46e8 3a fc 46			ld a, (.dmark)  
46eb 32 77 fb			ld (debug_mark),a  
46ee 3a fd 46			ld a, (.dmark+1)  
46f1 32 78 fb			ld (debug_mark+1),a  
46f4 3a fe 46			ld a, (.dmark+2)  
46f7 32 79 fb			ld (debug_mark+2),a  
46fa 18 03			jr .pastdmark  
46fc ..			.dmark: db "REA"  
46ff f1			.pastdmark: pop af  
4700			endm  
# End of macro DMARK
4700					CALLMONITOR 
4700 cd 00 14			call break_point_state  
4703				endm  
# End of macro CALLMONITOR
4703				endif 
4703					FORTH_DSP_POP 
4703 cd d1 1a			call macro_forth_dsp_pop 
4706				endm 
# End of macro FORTH_DSP_POP
4706			 
4706			;		pop hl 
4706				 
4706 65					ld h,l 
4707			 
4707 3a 59 f8				ld a, (store_openext) 
470a 6f					ld l, a 
470b					 
470b fe 00				cp 0 
470d ca d8 47				jp z, .ateof     ; dont read past eof 
4710			 
4710			 
4710 11 62 f8				ld de, store_page 
4713				if DEBUG_STORESE 
4713					DMARK "RE1" 
4713 f5				push af  
4714 3a 28 47			ld a, (.dmark)  
4717 32 77 fb			ld (debug_mark),a  
471a 3a 29 47			ld a, (.dmark+1)  
471d 32 78 fb			ld (debug_mark+1),a  
4720 3a 2a 47			ld a, (.dmark+2)  
4723 32 79 fb			ld (debug_mark+2),a  
4726 18 03			jr .pastdmark  
4728 ..			.dmark: db "RE1"  
472b f1			.pastdmark: pop af  
472c			endm  
# End of macro DMARK
472c					CALLMONITOR 
472c cd 00 14			call break_point_state  
472f				endm  
# End of macro CALLMONITOR
472f				endif 
472f cd 46 08				call storage_read 
4732			 
4732				if DEBUG_STORESE 
4732					DMARK "RE2" 
4732 f5				push af  
4733 3a 47 47			ld a, (.dmark)  
4736 32 77 fb			ld (debug_mark),a  
4739 3a 48 47			ld a, (.dmark+1)  
473c 32 78 fb			ld (debug_mark+1),a  
473f 3a 49 47			ld a, (.dmark+2)  
4742 32 79 fb			ld (debug_mark+2),a  
4745 18 03			jr .pastdmark  
4747 ..			.dmark: db "RE2"  
474a f1			.pastdmark: pop af  
474b			endm  
# End of macro DMARK
474b					CALLMONITOR 
474b cd 00 14			call break_point_state  
474e				endm  
# End of macro CALLMONITOR
474e				endif 
474e cd 3b 0c			call ishlzero 
4751			;	ld a, l 
4751			;	add h 
4751			;	cp 0 
4751 ca de 47			jp z, .readeof 
4754			 
4754				; not eof so hl should point to data to push to stack 
4754			 
4754				if DEBUG_STORESE 
4754					DMARK "RE3" 
4754 f5				push af  
4755 3a 69 47			ld a, (.dmark)  
4758 32 77 fb			ld (debug_mark),a  
475b 3a 6a 47			ld a, (.dmark+1)  
475e 32 78 fb			ld (debug_mark+1),a  
4761 3a 6b 47			ld a, (.dmark+2)  
4764 32 79 fb			ld (debug_mark+2),a  
4767 18 03			jr .pastdmark  
4769 ..			.dmark: db "RE3"  
476c f1			.pastdmark: pop af  
476d			endm  
# End of macro DMARK
476d					CALLMONITOR 
476d cd 00 14			call break_point_state  
4770				endm  
# End of macro CALLMONITOR
4770				endif 
4770 cd ac 19			call forth_push_str 
4773			 
4773				if DEBUG_STORESE 
4773					DMARK "RE4" 
4773 f5				push af  
4774 3a 88 47			ld a, (.dmark)  
4777 32 77 fb			ld (debug_mark),a  
477a 3a 89 47			ld a, (.dmark+1)  
477d 32 78 fb			ld (debug_mark+1),a  
4780 3a 8a 47			ld a, (.dmark+2)  
4783 32 79 fb			ld (debug_mark+2),a  
4786 18 03			jr .pastdmark  
4788 ..			.dmark: db "RE4"  
478b f1			.pastdmark: pop af  
478c			endm  
# End of macro DMARK
478c					CALLMONITOR 
478c cd 00 14			call break_point_state  
478f				endm  
# End of macro CALLMONITOR
478f				endif 
478f				; get next block  or mark as eof 
478f			 
478f 3a 58 f8			ld a, (store_openmaxext)   ; get our limit 
4792 4f				ld c, a	 
4793 3a 59 f8			ld a, (store_openext) 
4796			 
4796				if DEBUG_STORESE 
4796					DMARK "RE5" 
4796 f5				push af  
4797 3a ab 47			ld a, (.dmark)  
479a 32 77 fb			ld (debug_mark),a  
479d 3a ac 47			ld a, (.dmark+1)  
47a0 32 78 fb			ld (debug_mark+1),a  
47a3 3a ad 47			ld a, (.dmark+2)  
47a6 32 79 fb			ld (debug_mark+2),a  
47a9 18 03			jr .pastdmark  
47ab ..			.dmark: db "RE5"  
47ae f1			.pastdmark: pop af  
47af			endm  
# End of macro DMARK
47af					CALLMONITOR 
47af cd 00 14			call break_point_state  
47b2				endm  
# End of macro CALLMONITOR
47b2				endif 
47b2 b9				cp c 
47b3 28 29			jr z, .readeof     ; at last extent 
47b5			 
47b5 3c					inc a 
47b6 32 59 f8				ld (store_openext), a 
47b9			 
47b9				if DEBUG_STORESE 
47b9					DMARK "RE6" 
47b9 f5				push af  
47ba 3a ce 47			ld a, (.dmark)  
47bd 32 77 fb			ld (debug_mark),a  
47c0 3a cf 47			ld a, (.dmark+1)  
47c3 32 78 fb			ld (debug_mark+1),a  
47c6 3a d0 47			ld a, (.dmark+2)  
47c9 32 79 fb			ld (debug_mark+2),a  
47cc 18 03			jr .pastdmark  
47ce ..			.dmark: db "RE6"  
47d1 f1			.pastdmark: pop af  
47d2			endm  
# End of macro DMARK
47d2					CALLMONITOR 
47d2 cd 00 14			call break_point_state  
47d5				endm  
# End of macro CALLMONITOR
47d5				endif 
47d5			 
47d5			 
47d5				       NEXTW 
47d5 c3 8b 1b			jp macro_next 
47d8				endm 
# End of macro NEXTW
47d8			.ateof: 
47d8 21 02 48				ld hl, .showeof 
47db cd ac 19				call forth_push_str 
47de 3e 00		.readeof:	ld a, 0 
47e0 32 59 f8				ld (store_openext), a 
47e3			 
47e3					 
47e3				if DEBUG_STORESE 
47e3					DMARK "REF" 
47e3 f5				push af  
47e4 3a f8 47			ld a, (.dmark)  
47e7 32 77 fb			ld (debug_mark),a  
47ea 3a f9 47			ld a, (.dmark+1)  
47ed 32 78 fb			ld (debug_mark+1),a  
47f0 3a fa 47			ld a, (.dmark+2)  
47f3 32 79 fb			ld (debug_mark+2),a  
47f6 18 03			jr .pastdmark  
47f8 ..			.dmark: db "REF"  
47fb f1			.pastdmark: pop af  
47fc			endm  
# End of macro DMARK
47fc					CALLMONITOR 
47fc cd 00 14			call break_point_state  
47ff				endm  
# End of macro CALLMONITOR
47ff				endif 
47ff				       NEXTW 
47ff c3 8b 1b			jp macro_next 
4802				endm 
# End of macro NEXTW
4802			 
4802 .. 00		.showeof:   db "eof", 0 
4806			 
4806			 
4806			.EOF: 
4806				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
4806 6d				db WORD_SYS_CORE+89             
4807 47 48			dw .FORMAT            
4809 04				db 3 + 1 
480a .. 00			db "EOF",0              
480e				endm 
# End of macro CWHEAD
480e			; | EOF ( n -- u )  Returns EOF logical state of file id n - CURRENTLY n IS IGNORED AND ONLY ONE STREAM IS SUPPORTED | DONE 
480e			; | | e.g. 
480e			; | | $01 OPEN REPEAT $01 READ $01 EOF $00 IF LOOP 
480e					; TODO if current block id for stream is zero then push true else false 
480e			 
480e					if DEBUG_FORTH_WORDS_KEY 
480e						DMARK "EOF" 
480e f5				push af  
480f 3a 23 48			ld a, (.dmark)  
4812 32 77 fb			ld (debug_mark),a  
4815 3a 24 48			ld a, (.dmark+1)  
4818 32 78 fb			ld (debug_mark+1),a  
481b 3a 25 48			ld a, (.dmark+2)  
481e 32 79 fb			ld (debug_mark+2),a  
4821 18 03			jr .pastdmark  
4823 ..			.dmark: db "EOF"  
4826 f1			.pastdmark: pop af  
4827			endm  
# End of macro DMARK
4827						CALLMONITOR 
4827 cd 00 14			call break_point_state  
482a				endm  
# End of macro CALLMONITOR
482a					endif 
482a			 
482a					; TODO handlue multiple file streams 
482a			 
482a					FORTH_DSP_POP     ; for now just get rid of stream id 
482a cd d1 1a			call macro_forth_dsp_pop 
482d				endm 
# End of macro FORTH_DSP_POP
482d			 
482d 2e 01				ld l, 1 
482f 3a 58 f8				ld a, (store_openmaxext) 
4832 fe 00				cp 0 
4834 28 09				jr  z, .eofdone   ; empty file 
4836 3a 59 f8				ld a, (store_openext) 
4839 fe 00				cp 0 
483b 28 02				jr  z, .eofdone 
483d 2e 00				ld l, 0 
483f 26 00		.eofdone:	ld h, 0 
4841 cd 9a 19				call forth_push_numhl 
4844			 
4844			 
4844				       NEXTW 
4844 c3 8b 1b			jp macro_next 
4847				endm 
# End of macro NEXTW
4847			 
4847			.FORMAT: 
4847				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
4847 6d				db WORD_SYS_CORE+89             
4848 98 48			dw .LABEL            
484a 07				db 6 + 1 
484b .. 00			db "FORMAT",0              
4852				endm 
# End of macro CWHEAD
4852			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
4852					; TODO if current block id for stream is zero then push true else false 
4852				 
4852				if DEBUG_STORESE 
4852					DMARK "FOR" 
4852 f5				push af  
4853 3a 67 48			ld a, (.dmark)  
4856 32 77 fb			ld (debug_mark),a  
4859 3a 68 48			ld a, (.dmark+1)  
485c 32 78 fb			ld (debug_mark+1),a  
485f 3a 69 48			ld a, (.dmark+2)  
4862 32 79 fb			ld (debug_mark+2),a  
4865 18 03			jr .pastdmark  
4867 ..			.dmark: db "FOR"  
486a f1			.pastdmark: pop af  
486b			endm  
# End of macro DMARK
486b					CALLMONITOR 
486b cd 00 14			call break_point_state  
486e				endm  
# End of macro CALLMONITOR
486e				endif 
486e					; Wipes the bank check flags to cause a reformat on next block 0 read 
486e			 
486e 21 01 00				ld hl, 1 
4871 3e 00				ld a, 0 
4873 cd ea 01				call se_writebyte 
4876			 
4876				if DEBUG_STORESE 
4876					DMARK "FO0" 
4876 f5				push af  
4877 3a 8b 48			ld a, (.dmark)  
487a 32 77 fb			ld (debug_mark),a  
487d 3a 8c 48			ld a, (.dmark+1)  
4880 32 78 fb			ld (debug_mark+1),a  
4883 3a 8d 48			ld a, (.dmark+2)  
4886 32 79 fb			ld (debug_mark+2),a  
4889 18 03			jr .pastdmark  
488b ..			.dmark: db "FO0"  
488e f1			.pastdmark: pop af  
488f			endm  
# End of macro DMARK
488f					CALLMONITOR 
488f cd 00 14			call break_point_state  
4892				endm  
# End of macro CALLMONITOR
4892				endif 
4892					; force bank init 
4892			 
4892 cd bd 03				call storage_get_block_0 
4895					 
4895				       NEXTW 
4895 c3 8b 1b			jp macro_next 
4898				endm 
# End of macro NEXTW
4898			.LABEL: 
4898				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
4898 6d				db WORD_SYS_CORE+89             
4899 e6 48			dw .STOREPAGE            
489b 06				db 5 + 1 
489c .. 00			db "LABEL",0              
48a2				endm 
# End of macro CWHEAD
48a2			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
48a2					; TODO test to see if bank is selected 
48a2				 
48a2					if DEBUG_FORTH_WORDS_KEY 
48a2						DMARK "LBL" 
48a2 f5				push af  
48a3 3a b7 48			ld a, (.dmark)  
48a6 32 77 fb			ld (debug_mark),a  
48a9 3a b8 48			ld a, (.dmark+1)  
48ac 32 78 fb			ld (debug_mark+1),a  
48af 3a b9 48			ld a, (.dmark+2)  
48b2 32 79 fb			ld (debug_mark+2),a  
48b5 18 03			jr .pastdmark  
48b7 ..			.dmark: db "LBL"  
48ba f1			.pastdmark: pop af  
48bb			endm  
# End of macro DMARK
48bb						CALLMONITOR 
48bb cd 00 14			call break_point_state  
48be				endm  
# End of macro CALLMONITOR
48be					endif 
48be			;	if DEBUG_STORESE 
48be			;		DMARK "LBL" 
48be			;		CALLMONITOR 
48be			;	endif 
48be					FORTH_DSP_VALUEHL 
48be cd 35 1a			call macro_dsp_valuehl 
48c1				endm 
# End of macro FORTH_DSP_VALUEHL
48c1					;v5FORTH_DSP_VALUE 
48c1					 
48c1			;		push hl 
48c1					FORTH_DSP_POP 
48c1 cd d1 1a			call macro_forth_dsp_pop 
48c4				endm 
# End of macro FORTH_DSP_POP
48c4			;		pop hl 
48c4			 
48c4			;v5		inc hl   ; move past the type marker 
48c4			 
48c4				if DEBUG_STORESE 
48c4					DMARK "LBl" 
48c4 f5				push af  
48c5 3a d9 48			ld a, (.dmark)  
48c8 32 77 fb			ld (debug_mark),a  
48cb 3a da 48			ld a, (.dmark+1)  
48ce 32 78 fb			ld (debug_mark+1),a  
48d1 3a db 48			ld a, (.dmark+2)  
48d4 32 79 fb			ld (debug_mark+2),a  
48d7 18 03			jr .pastdmark  
48d9 ..			.dmark: db "LBl"  
48dc f1			.pastdmark: pop af  
48dd			endm  
# End of macro DMARK
48dd					CALLMONITOR 
48dd cd 00 14			call break_point_state  
48e0				endm  
# End of macro CALLMONITOR
48e0				endif 
48e0 cd d6 04				call storage_label 
48e3			 
48e3				       NEXTW 
48e3 c3 8b 1b			jp macro_next 
48e6				endm 
# End of macro NEXTW
48e6			.STOREPAGE: 
48e6				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
48e6 6d				db WORD_SYS_CORE+89             
48e7 19 49			dw .LABELS            
48e9 0a				db 9 + 1 
48ea .. 00			db "STOREPAGE",0              
48f4				endm 
# End of macro CWHEAD
48f4			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
48f4					; TODO test to see if bank is selected 
48f4				 
48f4					if DEBUG_FORTH_WORDS_KEY 
48f4						DMARK "STP" 
48f4 f5				push af  
48f5 3a 09 49			ld a, (.dmark)  
48f8 32 77 fb			ld (debug_mark),a  
48fb 3a 0a 49			ld a, (.dmark+1)  
48fe 32 78 fb			ld (debug_mark+1),a  
4901 3a 0b 49			ld a, (.dmark+2)  
4904 32 79 fb			ld (debug_mark+2),a  
4907 18 03			jr .pastdmark  
4909 ..			.dmark: db "STP"  
490c f1			.pastdmark: pop af  
490d			endm  
# End of macro DMARK
490d						CALLMONITOR 
490d cd 00 14			call break_point_state  
4910				endm  
# End of macro CALLMONITOR
4910					endif 
4910			;	if DEBUG_STORESE 
4910			;		DMARK "STP" 
4910			;		CALLMONITOR 
4910			;	endif 
4910			 
4910 21 62 f8			ld hl, store_page 
4913 cd 9a 19			call forth_push_numhl 
4916			 
4916			 
4916				       NEXTW 
4916 c3 8b 1b			jp macro_next 
4919				endm 
# End of macro NEXTW
4919			.LABELS: 
4919				CWHEAD .ENDSTORAGE 89 "LABELS" 6 WORD_FLAG_CODE 
4919 6d				db WORD_SYS_CORE+89             
491a a3 49			dw .ENDSTORAGE            
491c 07				db 6 + 1 
491d .. 00			db "LABELS",0              
4924				endm 
# End of macro CWHEAD
4924			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | TO TEST 
4924					;  
4924			 
4924					; save the current device selected to restore afterwards 
4924				 
4924 3a 5c f8				ld a, (spi_device) 
4927 f5					push af 
4928			 
4928			 
4928					; run through each of the banks 
4928			 
4928 21 01 00				ld hl, 1 
492b cd 9a 19				call forth_push_numhl 
492e 3e ff				ld a, SPI_CE_HIGH 
4930 cb 87				res SPI_CE0, a 
4932 32 5c f8				ld (spi_device), a 
4935 cd bd 03				call storage_get_block_0 
4938 21 65 f8				ld hl, store_page+3 
493b cd ac 19				call forth_push_str 
493e			 
493e					 
493e 21 02 00				ld hl, 2 
4941 cd 9a 19				call forth_push_numhl 
4944 3e ff				ld a, SPI_CE_HIGH 
4946 cb 8f				res SPI_CE1, a 
4948 32 5c f8				ld (spi_device), a 
494b cd bd 03				call storage_get_block_0 
494e 21 65 f8				ld hl, store_page+3 
4951 cd ac 19				call forth_push_str 
4954			 
4954					 
4954 21 03 00				ld hl, 3 
4957 cd 9a 19				call forth_push_numhl 
495a 3e ff				ld a, SPI_CE_HIGH 
495c cb 97				res SPI_CE2, a 
495e 32 5c f8				ld (spi_device), a 
4961 cd bd 03				call storage_get_block_0 
4964 21 65 f8				ld hl, store_page+3 
4967 cd ac 19				call forth_push_str 
496a			 
496a			 
496a 21 04 00				ld hl, 4 
496d cd 9a 19				call forth_push_numhl 
4970 3e ff				ld a, SPI_CE_HIGH 
4972 cb 9f				res SPI_CE3, a 
4974 32 5c f8				ld (spi_device), a 
4977 cd bd 03				call storage_get_block_0 
497a 21 65 f8				ld hl, store_page+3 
497d cd ac 19				call forth_push_str 
4980			 
4980					 
4980			 
4980 21 05 00				ld hl, 5 
4983 cd 9a 19				call forth_push_numhl 
4986 3e ff				ld a, SPI_CE_HIGH 
4988 cb a7				res SPI_CE4, a 
498a 32 5c f8				ld (spi_device), a 
498d cd bd 03				call storage_get_block_0 
4990 21 65 f8				ld hl, store_page+3 
4993 cd ac 19				call forth_push_str 
4996			 
4996					 
4996					; push fixed count of storage devices (on board) for now 
4996			 
4996 21 05 00				ld hl, 5 
4999 cd 9a 19				call forth_push_numhl 
499c			 
499c					; restore selected device  
499c				 
499c f1					pop af 
499d 32 5c f8				ld (spi_device), a 
49a0			 
49a0				       NEXTW 
49a0 c3 8b 1b			jp macro_next 
49a3				endm 
# End of macro NEXTW
49a3			 
49a3			.ENDSTORAGE: 
49a3			; eof 
# End of file forth_words_storage.asm
49a3			endif 
49a3				include "forth_words_device.asm" 
49a3			; Device related words 
49a3			 
49a3			; | ## Device Words 
49a3			 
49a3			if SOUND_ENABLE 
49a3			.NOTE: 
49a3				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
49a3 33				db WORD_SYS_CORE+31             
49a4 cb 49			dw .AFTERSOUND            
49a6 05				db 4 + 1 
49a7 .. 00			db "NOTE",0              
49ac				endm 
# End of macro CWHEAD
49ac			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
49ac					if DEBUG_FORTH_WORDS_KEY 
49ac						DMARK "NTE" 
49ac f5				push af  
49ad 3a c1 49			ld a, (.dmark)  
49b0 32 77 fb			ld (debug_mark),a  
49b3 3a c2 49			ld a, (.dmark+1)  
49b6 32 78 fb			ld (debug_mark+1),a  
49b9 3a c3 49			ld a, (.dmark+2)  
49bc 32 79 fb			ld (debug_mark+2),a  
49bf 18 03			jr .pastdmark  
49c1 ..			.dmark: db "NTE"  
49c4 f1			.pastdmark: pop af  
49c5			endm  
# End of macro DMARK
49c5						CALLMONITOR 
49c5 cd 00 14			call break_point_state  
49c8				endm  
# End of macro CALLMONITOR
49c8					endif 
49c8			 
49c8				 
49c8			 
49c8					NEXTW 
49c8 c3 8b 1b			jp macro_next 
49cb				endm 
# End of macro NEXTW
49cb			.AFTERSOUND: 
49cb			endif 
49cb			 
49cb			 
49cb			USE_GPIO: equ 0 
49cb			 
49cb			if USE_GPIO 
49cb			.GP1: 
49cb				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
49cb			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
49cb					NEXTW 
49cb			.GP2: 
49cb				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
49cb			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
49cb			 
49cb					NEXTW 
49cb			 
49cb			.GP3: 
49cb				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
49cb			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
49cb			 
49cb					NEXTW 
49cb			 
49cb			.GP4: 
49cb				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
49cb			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
49cb			 
49cb					NEXTW 
49cb			.SIN: 
49cb			 
49cb			 
49cb			endif 
49cb			 
49cb			 
49cb				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
49cb 33				db WORD_SYS_CORE+31             
49cc 00 4a			dw .SOUT            
49ce 03				db 2 + 1 
49cf .. 00			db "IN",0              
49d2				endm 
# End of macro CWHEAD
49d2			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
49d2					if DEBUG_FORTH_WORDS_KEY 
49d2						DMARK "IN." 
49d2 f5				push af  
49d3 3a e7 49			ld a, (.dmark)  
49d6 32 77 fb			ld (debug_mark),a  
49d9 3a e8 49			ld a, (.dmark+1)  
49dc 32 78 fb			ld (debug_mark+1),a  
49df 3a e9 49			ld a, (.dmark+2)  
49e2 32 79 fb			ld (debug_mark+2),a  
49e5 18 03			jr .pastdmark  
49e7 ..			.dmark: db "IN."  
49ea f1			.pastdmark: pop af  
49eb			endm  
# End of macro DMARK
49eb						CALLMONITOR 
49eb cd 00 14			call break_point_state  
49ee				endm  
# End of macro CALLMONITOR
49ee					endif 
49ee					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
49ee cd 35 1a			call macro_dsp_valuehl 
49f1				endm 
# End of macro FORTH_DSP_VALUEHL
49f1			 
49f1 e5					push hl 
49f2			 
49f2					; destroy value TOS 
49f2			 
49f2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
49f2 cd d1 1a			call macro_forth_dsp_pop 
49f5				endm 
# End of macro FORTH_DSP_POP
49f5			 
49f5					; one value on hl get other one back 
49f5			 
49f5 c1					pop bc 
49f6			 
49f6					; do the sub 
49f6			;		ex de, hl 
49f6			 
49f6 ed 68				in l,(c) 
49f8			 
49f8					; save it 
49f8			 
49f8 26 00				ld h,0 
49fa			 
49fa					; TODO push value back onto stack for another op etc 
49fa			 
49fa cd 9a 19				call forth_push_numhl 
49fd					NEXTW 
49fd c3 8b 1b			jp macro_next 
4a00				endm 
# End of macro NEXTW
4a00			.SOUT: 
4a00				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
4a00 34				db WORD_SYS_CORE+32             
4a01 53 4a			dw .SPIO            
4a03 04				db 3 + 1 
4a04 .. 00			db "OUT",0              
4a08				endm 
# End of macro CWHEAD
4a08			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
4a08					if DEBUG_FORTH_WORDS_KEY 
4a08						DMARK "OUT" 
4a08 f5				push af  
4a09 3a 1d 4a			ld a, (.dmark)  
4a0c 32 77 fb			ld (debug_mark),a  
4a0f 3a 1e 4a			ld a, (.dmark+1)  
4a12 32 78 fb			ld (debug_mark+1),a  
4a15 3a 1f 4a			ld a, (.dmark+2)  
4a18 32 79 fb			ld (debug_mark+2),a  
4a1b 18 03			jr .pastdmark  
4a1d ..			.dmark: db "OUT"  
4a20 f1			.pastdmark: pop af  
4a21			endm  
# End of macro DMARK
4a21						CALLMONITOR 
4a21 cd 00 14			call break_point_state  
4a24				endm  
# End of macro CALLMONITOR
4a24					endif 
4a24			 
4a24					; get port 
4a24			 
4a24					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4a24 cd 35 1a			call macro_dsp_valuehl 
4a27				endm 
# End of macro FORTH_DSP_VALUEHL
4a27			 
4a27 e5					push hl 
4a28			 
4a28					; destroy value TOS 
4a28			 
4a28					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4a28 cd d1 1a			call macro_forth_dsp_pop 
4a2b				endm 
# End of macro FORTH_DSP_POP
4a2b			 
4a2b					; get byte to send 
4a2b			 
4a2b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4a2b cd 35 1a			call macro_dsp_valuehl 
4a2e				endm 
# End of macro FORTH_DSP_VALUEHL
4a2e			 
4a2e			;		push hl 
4a2e			 
4a2e					; destroy value TOS 
4a2e			 
4a2e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4a2e cd d1 1a			call macro_forth_dsp_pop 
4a31				endm 
# End of macro FORTH_DSP_POP
4a31			 
4a31					; one value on hl get other one back 
4a31			 
4a31			;		pop hl 
4a31			 
4a31 c1					pop bc 
4a32			 
4a32					if DEBUG_FORTH_WORDS 
4a32						DMARK "OUT" 
4a32 f5				push af  
4a33 3a 47 4a			ld a, (.dmark)  
4a36 32 77 fb			ld (debug_mark),a  
4a39 3a 48 4a			ld a, (.dmark+1)  
4a3c 32 78 fb			ld (debug_mark+1),a  
4a3f 3a 49 4a			ld a, (.dmark+2)  
4a42 32 79 fb			ld (debug_mark+2),a  
4a45 18 03			jr .pastdmark  
4a47 ..			.dmark: db "OUT"  
4a4a f1			.pastdmark: pop af  
4a4b			endm  
# End of macro DMARK
4a4b						CALLMONITOR 
4a4b cd 00 14			call break_point_state  
4a4e				endm  
# End of macro CALLMONITOR
4a4e					endif 
4a4e			 
4a4e ed 69				out (c), l 
4a50			 
4a50					NEXTW 
4a50 c3 8b 1b			jp macro_next 
4a53				endm 
# End of macro NEXTW
4a53			 
4a53			 
4a53			.SPIO: 
4a53			 
4a53			if STORAGE_SE 
4a53				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
4a53 51				db WORD_SYS_CORE+61             
4a54 64 4a			dw .SPICEH            
4a56 07				db 6 + 1 
4a57 .. 00			db "SPICEL",0              
4a5e				endm 
# End of macro CWHEAD
4a5e			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
4a5e			 
4a5e cd 98 01				call spi_ce_low 
4a61			    NEXTW 
4a61 c3 8b 1b			jp macro_next 
4a64				endm 
# End of macro NEXTW
4a64			 
4a64			.SPICEH: 
4a64				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
4a64 51				db WORD_SYS_CORE+61             
4a65 75 4a			dw .SPIOb            
4a67 07				db 6 + 1 
4a68 .. 00			db "SPICEH",0              
4a6f				endm 
# End of macro CWHEAD
4a6f			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
4a6f			 
4a6f cd 87 01				call spi_ce_high 
4a72			    NEXTW 
4a72 c3 8b 1b			jp macro_next 
4a75				endm 
# End of macro NEXTW
4a75			 
4a75			 
4a75			.SPIOb: 
4a75			 
4a75				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
4a75 51				db WORD_SYS_CORE+61             
4a76 8b 4a			dw .SPII            
4a78 05				db 4 + 1 
4a79 .. 00			db "SPIO",0              
4a7e				endm 
# End of macro CWHEAD
4a7e			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
4a7e			 
4a7e					; get port 
4a7e			 
4a7e			 
4a7e					; get byte to send 
4a7e			 
4a7e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4a7e cd 35 1a			call macro_dsp_valuehl 
4a81				endm 
# End of macro FORTH_DSP_VALUEHL
4a81			 
4a81			;		push hl    ; u1  
4a81			 
4a81					; destroy value TOS 
4a81			 
4a81					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4a81 cd d1 1a			call macro_forth_dsp_pop 
4a84				endm 
# End of macro FORTH_DSP_POP
4a84			 
4a84					; one value on hl get other one back 
4a84			 
4a84			;		pop hl   ; u2 - addr 
4a84			 
4a84					; TODO Send SPI byte 
4a84			 
4a84 7d					ld a, l 
4a85 cd bc 00				call spi_send_byte 
4a88			 
4a88					NEXTW 
4a88 c3 8b 1b			jp macro_next 
4a8b				endm 
# End of macro NEXTW
4a8b			 
4a8b			.SPII: 
4a8b				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
4a8b 52				db WORD_SYS_CORE+62             
4a8c a0 4a			dw .SESEL            
4a8e 06				db 5 + 1 
4a8f .. 00			db "SPII",0              
4a94				endm 
# End of macro CWHEAD
4a94			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
4a94			 
4a94					; TODO Get SPI byte 
4a94			 
4a94 cd dd 00				call spi_read_byte 
4a97			 
4a97 26 00				ld h, 0 
4a99 6f					ld l, a 
4a9a cd 9a 19				call forth_push_numhl 
4a9d			 
4a9d					NEXTW 
4a9d c3 8b 1b			jp macro_next 
4aa0				endm 
# End of macro NEXTW
4aa0			 
4aa0			 
4aa0			 
4aa0			.SESEL: 
4aa0				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
4aa0 66				db WORD_SYS_CORE+82             
4aa1 34 4b			dw .CARTDEV            
4aa3 05				db 4 + 1 
4aa4 .. 00			db "BANK",0              
4aa9				endm 
# End of macro CWHEAD
4aa9			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
4aa9					if DEBUG_FORTH_WORDS_KEY 
4aa9						DMARK "BNK" 
4aa9 f5				push af  
4aaa 3a be 4a			ld a, (.dmark)  
4aad 32 77 fb			ld (debug_mark),a  
4ab0 3a bf 4a			ld a, (.dmark+1)  
4ab3 32 78 fb			ld (debug_mark+1),a  
4ab6 3a c0 4a			ld a, (.dmark+2)  
4ab9 32 79 fb			ld (debug_mark+2),a  
4abc 18 03			jr .pastdmark  
4abe ..			.dmark: db "BNK"  
4ac1 f1			.pastdmark: pop af  
4ac2			endm  
# End of macro DMARK
4ac2						CALLMONITOR 
4ac2 cd 00 14			call break_point_state  
4ac5				endm  
# End of macro CALLMONITOR
4ac5					endif 
4ac5			 
4ac5 3e ff				ld a, 255 
4ac7 32 5f f8				ld (spi_cartdev), a 
4aca			 
4aca					; get bank 
4aca			 
4aca					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4aca cd 35 1a			call macro_dsp_valuehl 
4acd				endm 
# End of macro FORTH_DSP_VALUEHL
4acd			 
4acd			;		push hl 
4acd			 
4acd					; destroy value TOS 
4acd			 
4acd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4acd cd d1 1a			call macro_forth_dsp_pop 
4ad0				endm 
# End of macro FORTH_DSP_POP
4ad0			 
4ad0					; one value on hl get other one back 
4ad0			 
4ad0			;		pop hl 
4ad0			 
4ad0			 
4ad0 0e ff				ld c, SPI_CE_HIGH 
4ad2			 
4ad2 7d					ld a, l 
4ad3			 
4ad3					if DEBUG_FORTH_WORDS 
4ad3						DMARK "BNK" 
4ad3 f5				push af  
4ad4 3a e8 4a			ld a, (.dmark)  
4ad7 32 77 fb			ld (debug_mark),a  
4ada 3a e9 4a			ld a, (.dmark+1)  
4add 32 78 fb			ld (debug_mark+1),a  
4ae0 3a ea 4a			ld a, (.dmark+2)  
4ae3 32 79 fb			ld (debug_mark+2),a  
4ae6 18 03			jr .pastdmark  
4ae8 ..			.dmark: db "BNK"  
4aeb f1			.pastdmark: pop af  
4aec			endm  
# End of macro DMARK
4aec						CALLMONITOR 
4aec cd 00 14			call break_point_state  
4aef				endm  
# End of macro CALLMONITOR
4aef					endif 
4aef			 
4aef					; active low 
4aef			 
4aef fe 00				cp 0 
4af1 28 1e				jr z, .bset 
4af3 fe 01				cp 1 
4af5 20 02				jr nz, .b2 
4af7 cb 81				res 0, c 
4af9 fe 02		.b2:		cp 2 
4afb 20 02				jr nz, .b3 
4afd cb 89				res 1, c 
4aff fe 03		.b3:		cp 3 
4b01 20 02				jr nz, .b4 
4b03 cb 91				res 2, c 
4b05 fe 04		.b4:		cp 4 
4b07 20 02				jr nz, .b5 
4b09 cb 99				res 3, c 
4b0b fe 05		.b5:		cp 5 
4b0d 20 02				jr nz, .bset 
4b0f cb a1				res 4, c 
4b11			 
4b11			.bset: 
4b11 79					ld a, c 
4b12 32 5c f8				ld (spi_device),a 
4b15					if DEBUG_FORTH_WORDS 
4b15						DMARK "BN2" 
4b15 f5				push af  
4b16 3a 2a 4b			ld a, (.dmark)  
4b19 32 77 fb			ld (debug_mark),a  
4b1c 3a 2b 4b			ld a, (.dmark+1)  
4b1f 32 78 fb			ld (debug_mark+1),a  
4b22 3a 2c 4b			ld a, (.dmark+2)  
4b25 32 79 fb			ld (debug_mark+2),a  
4b28 18 03			jr .pastdmark  
4b2a ..			.dmark: db "BN2"  
4b2d f1			.pastdmark: pop af  
4b2e			endm  
# End of macro DMARK
4b2e						CALLMONITOR 
4b2e cd 00 14			call break_point_state  
4b31				endm  
# End of macro CALLMONITOR
4b31					endif 
4b31			 
4b31					NEXTW 
4b31 c3 8b 1b			jp macro_next 
4b34				endm 
# End of macro NEXTW
4b34			 
4b34			.CARTDEV: 
4b34				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
4b34 66				db WORD_SYS_CORE+82             
4b35 dd 4b			dw .ENDDEVICE            
4b37 08				db 7 + 1 
4b38 .. 00			db "CARTDEV",0              
4b40				endm 
# End of macro CWHEAD
4b40			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
4b40					if DEBUG_FORTH_WORDS_KEY 
4b40						DMARK "CDV" 
4b40 f5				push af  
4b41 3a 55 4b			ld a, (.dmark)  
4b44 32 77 fb			ld (debug_mark),a  
4b47 3a 56 4b			ld a, (.dmark+1)  
4b4a 32 78 fb			ld (debug_mark+1),a  
4b4d 3a 57 4b			ld a, (.dmark+2)  
4b50 32 79 fb			ld (debug_mark+2),a  
4b53 18 03			jr .pastdmark  
4b55 ..			.dmark: db "CDV"  
4b58 f1			.pastdmark: pop af  
4b59			endm  
# End of macro DMARK
4b59						CALLMONITOR 
4b59 cd 00 14			call break_point_state  
4b5c				endm  
# End of macro CALLMONITOR
4b5c					endif 
4b5c			 
4b5c					; disable se storage bank selection 
4b5c			 
4b5c 3e ff				ld a, SPI_CE_HIGH		; ce high 
4b5e 32 5c f8				ld (spi_device), a 
4b61			 
4b61					; get bank 
4b61			 
4b61					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b61 cd 35 1a			call macro_dsp_valuehl 
4b64				endm 
# End of macro FORTH_DSP_VALUEHL
4b64			 
4b64			;		push hl 
4b64			 
4b64					; destroy value TOS 
4b64			 
4b64					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b64 cd d1 1a			call macro_forth_dsp_pop 
4b67				endm 
# End of macro FORTH_DSP_POP
4b67			 
4b67					; one value on hl get other one back 
4b67			 
4b67			;		pop hl 
4b67			 
4b67					; active low 
4b67			 
4b67 0e ff				ld c, 255 
4b69			 
4b69 7d					ld a, l 
4b6a					if DEBUG_FORTH_WORDS 
4b6a						DMARK "CDV" 
4b6a f5				push af  
4b6b 3a 7f 4b			ld a, (.dmark)  
4b6e 32 77 fb			ld (debug_mark),a  
4b71 3a 80 4b			ld a, (.dmark+1)  
4b74 32 78 fb			ld (debug_mark+1),a  
4b77 3a 81 4b			ld a, (.dmark+2)  
4b7a 32 79 fb			ld (debug_mark+2),a  
4b7d 18 03			jr .pastdmark  
4b7f ..			.dmark: db "CDV"  
4b82 f1			.pastdmark: pop af  
4b83			endm  
# End of macro DMARK
4b83						CALLMONITOR 
4b83 cd 00 14			call break_point_state  
4b86				endm  
# End of macro CALLMONITOR
4b86					endif 
4b86 fe 00				cp 0 
4b88 28 30				jr z, .cset 
4b8a fe 01				cp 1 
4b8c 20 02				jr nz, .c2 
4b8e cb 81				res 0, c 
4b90 fe 02		.c2:		cp 2 
4b92 20 02				jr nz, .c3 
4b94 cb 89				res 1, c 
4b96 fe 03		.c3:		cp 3 
4b98 20 02				jr nz, .c4 
4b9a cb 91				res 2, c 
4b9c fe 04		.c4:		cp 4 
4b9e 20 02				jr nz, .c5 
4ba0 cb 99				res 3, c 
4ba2 fe 05		.c5:		cp 5 
4ba4 20 02				jr nz, .c6 
4ba6 cb a1				res 4, c 
4ba8 fe 06		.c6:		cp 6 
4baa 20 02				jr nz, .c7 
4bac cb a9				res 5, c 
4bae fe 07		.c7:		cp 7 
4bb0 20 02				jr nz, .c8 
4bb2 cb b1				res 6, c 
4bb4 fe 08		.c8:		cp 8 
4bb6 20 02				jr nz, .cset 
4bb8 cb b9				res 7, c 
4bba 79			.cset:		ld a, c 
4bbb 32 5f f8				ld (spi_cartdev),a 
4bbe			 
4bbe					if DEBUG_FORTH_WORDS 
4bbe						DMARK "CD2" 
4bbe f5				push af  
4bbf 3a d3 4b			ld a, (.dmark)  
4bc2 32 77 fb			ld (debug_mark),a  
4bc5 3a d4 4b			ld a, (.dmark+1)  
4bc8 32 78 fb			ld (debug_mark+1),a  
4bcb 3a d5 4b			ld a, (.dmark+2)  
4bce 32 79 fb			ld (debug_mark+2),a  
4bd1 18 03			jr .pastdmark  
4bd3 ..			.dmark: db "CD2"  
4bd6 f1			.pastdmark: pop af  
4bd7			endm  
# End of macro DMARK
4bd7						CALLMONITOR 
4bd7 cd 00 14			call break_point_state  
4bda				endm  
# End of macro CALLMONITOR
4bda					endif 
4bda					NEXTW 
4bda c3 8b 1b			jp macro_next 
4bdd				endm 
# End of macro NEXTW
4bdd			endif 
4bdd			 
4bdd			.ENDDEVICE: 
4bdd			; eof 
4bdd			 
# End of file forth_words_device.asm
4bdd			 
4bdd			; var handler 
4bdd			 
4bdd			 
4bdd			.VARS: 
4bdd				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
4bdd 78				db WORD_SYS_CORE+100             
4bde f5 4b			dw .V0Q            
4be0 04				db 3 + 1 
4be1 .. 00			db "V0!",0              
4be5				endm 
# End of macro CWHEAD
4be5			;| V0! ( u1 -- )  Store value to v0  | DONE 
4be5			 
4be5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4be5 cd 35 1a			call macro_dsp_valuehl 
4be8				endm 
# End of macro FORTH_DSP_VALUEHL
4be8			 
4be8 11 25 f8				ld de, cli_var_array 
4beb			 
4beb eb					ex de, hl 
4bec 73					ld (hl), e 
4bed 23					inc hl 
4bee 72					ld (hl), d 
4bef			 
4bef					; destroy value TOS 
4bef			 
4bef					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4bef cd d1 1a			call macro_forth_dsp_pop 
4bf2				endm 
# End of macro FORTH_DSP_POP
4bf2			 
4bf2				       NEXTW 
4bf2 c3 8b 1b			jp macro_next 
4bf5				endm 
# End of macro NEXTW
4bf5			.V0Q: 
4bf5				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
4bf5 79				db WORD_SYS_CORE+101             
4bf6 06 4c			dw .V1S            
4bf8 04				db 3 + 1 
4bf9 .. 00			db "V0@",0              
4bfd				endm 
# End of macro CWHEAD
4bfd			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
4bfd 2a 25 f8				ld hl, (cli_var_array) 
4c00 cd 9a 19				call forth_push_numhl 
4c03			 
4c03				       NEXTW 
4c03 c3 8b 1b			jp macro_next 
4c06				endm 
# End of macro NEXTW
4c06			.V1S: 
4c06				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
4c06 7a				db WORD_SYS_CORE+102             
4c07 1e 4c			dw .V1Q            
4c09 04				db 3 + 1 
4c0a .. 00			db "V1!",0              
4c0e				endm 
# End of macro CWHEAD
4c0e			;| V1! ( u1 -- )  Store value to v1 | DONE 
4c0e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4c0e cd 35 1a			call macro_dsp_valuehl 
4c11				endm 
# End of macro FORTH_DSP_VALUEHL
4c11			 
4c11 11 27 f8				ld de, cli_var_array+2 
4c14				 
4c14 eb					ex de, hl 
4c15 73					ld (hl), e 
4c16 23					inc hl 
4c17 72					ld (hl), d 
4c18			 
4c18					; destroy value TOS 
4c18			 
4c18					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c18 cd d1 1a			call macro_forth_dsp_pop 
4c1b				endm 
# End of macro FORTH_DSP_POP
4c1b				       NEXTW 
4c1b c3 8b 1b			jp macro_next 
4c1e				endm 
# End of macro NEXTW
4c1e			.V1Q: 
4c1e				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
4c1e 7b				db WORD_SYS_CORE+103             
4c1f 2f 4c			dw .V2S            
4c21 04				db 3 + 1 
4c22 .. 00			db "V1@",0              
4c26				endm 
# End of macro CWHEAD
4c26			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
4c26 2a 27 f8				ld hl, (cli_var_array+2) 
4c29 cd 9a 19				call forth_push_numhl 
4c2c				       NEXTW 
4c2c c3 8b 1b			jp macro_next 
4c2f				endm 
# End of macro NEXTW
4c2f			.V2S: 
4c2f				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
4c2f 7c				db WORD_SYS_CORE+104             
4c30 47 4c			dw .V2Q            
4c32 04				db 3 + 1 
4c33 .. 00			db "V2!",0              
4c37				endm 
# End of macro CWHEAD
4c37			;| V2! ( u1 -- )  Store value to v2 | DONE 
4c37					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4c37 cd 35 1a			call macro_dsp_valuehl 
4c3a				endm 
# End of macro FORTH_DSP_VALUEHL
4c3a			 
4c3a 11 29 f8				ld de, cli_var_array+4 
4c3d				 
4c3d eb					ex de, hl 
4c3e 73					ld (hl), e 
4c3f 23					inc hl 
4c40 72					ld (hl), d 
4c41			 
4c41					; destroy value TOS 
4c41			 
4c41					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c41 cd d1 1a			call macro_forth_dsp_pop 
4c44				endm 
# End of macro FORTH_DSP_POP
4c44				       NEXTW 
4c44 c3 8b 1b			jp macro_next 
4c47				endm 
# End of macro NEXTW
4c47			.V2Q: 
4c47				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
4c47 7d				db WORD_SYS_CORE+105             
4c48 58 4c			dw .V3S            
4c4a 04				db 3 + 1 
4c4b .. 00			db "V2@",0              
4c4f				endm 
# End of macro CWHEAD
4c4f			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
4c4f 2a 29 f8				ld hl, (cli_var_array+4) 
4c52 cd 9a 19				call forth_push_numhl 
4c55				       NEXTW 
4c55 c3 8b 1b			jp macro_next 
4c58				endm 
# End of macro NEXTW
4c58			.V3S: 
4c58				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
4c58 7c				db WORD_SYS_CORE+104             
4c59 70 4c			dw .V3Q            
4c5b 04				db 3 + 1 
4c5c .. 00			db "V3!",0              
4c60				endm 
# End of macro CWHEAD
4c60			;| V3! ( u1 -- )  Store value to v3 | DONE 
4c60					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4c60 cd 35 1a			call macro_dsp_valuehl 
4c63				endm 
# End of macro FORTH_DSP_VALUEHL
4c63			 
4c63 11 2b f8				ld de, cli_var_array+6 
4c66				 
4c66 eb					ex de, hl 
4c67 73					ld (hl), e 
4c68 23					inc hl 
4c69 72					ld (hl), d 
4c6a			 
4c6a					; destroy value TOS 
4c6a			 
4c6a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c6a cd d1 1a			call macro_forth_dsp_pop 
4c6d				endm 
# End of macro FORTH_DSP_POP
4c6d				       NEXTW 
4c6d c3 8b 1b			jp macro_next 
4c70				endm 
# End of macro NEXTW
4c70			.V3Q: 
4c70				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
4c70 7d				db WORD_SYS_CORE+105             
4c71 81 4c			dw .END            
4c73 04				db 3 + 1 
4c74 .. 00			db "V3@",0              
4c78				endm 
# End of macro CWHEAD
4c78			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
4c78 2a 2b f8				ld hl, (cli_var_array+6) 
4c7b cd 9a 19				call forth_push_numhl 
4c7e				       NEXTW 
4c7e c3 8b 1b			jp macro_next 
4c81				endm 
# End of macro NEXTW
4c81			 
4c81			 
4c81			 
4c81			 
4c81			 
4c81			; end of dict marker 
4c81			 
4c81 00			.END:    db WORD_SYS_END 
4c82 00 00			dw 0 
4c84 00				db 0 
4c85			 
4c85			; use to jp here for user dict words to save on macro expansion  
4c85			 
4c85			user_dict_next: 
4c85				NEXTW 
4c85 c3 8b 1b			jp macro_next 
4c88				endm 
# End of macro NEXTW
4c88			 
4c88			 
4c88			user_exec: 
4c88				;    ld hl, <word code> 
4c88				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
4c88				;    call forthexec 
4c88				;    jp user_dict_next   (NEXT) 
4c88			        ;    <word code bytes> 
4c88 eb				ex de, hl 
4c89 2a 33 f1			ld hl,(os_tok_ptr) 
4c8c				 
4c8c				FORTH_RSP_NEXT 
4c8c cd 41 19			call macro_forth_rsp_next 
4c8f				endm 
# End of macro FORTH_RSP_NEXT
4c8f			 
4c8f			if DEBUG_FORTH_UWORD 
4c8f						DMARK "UEX" 
4c8f f5				push af  
4c90 3a a4 4c			ld a, (.dmark)  
4c93 32 77 fb			ld (debug_mark),a  
4c96 3a a5 4c			ld a, (.dmark+1)  
4c99 32 78 fb			ld (debug_mark+1),a  
4c9c 3a a6 4c			ld a, (.dmark+2)  
4c9f 32 79 fb			ld (debug_mark+2),a  
4ca2 18 03			jr .pastdmark  
4ca4 ..			.dmark: db "UEX"  
4ca7 f1			.pastdmark: pop af  
4ca8			endm  
# End of macro DMARK
4ca8				CALLMONITOR 
4ca8 cd 00 14			call break_point_state  
4cab				endm  
# End of macro CALLMONITOR
4cab			endif 
4cab			 
4cab			 
4cab			 
4cab eb				ex de, hl 
4cac 22 33 f1			ld (os_tok_ptr), hl 
4caf				 
4caf				; Don't use next - Skips the first word in uword. 
4caf			 
4caf c3 1c 1c			jp exec1 
4cb2			;	NEXT 
4cb2			 
4cb2			 
4cb2			; eof 
# End of file forth_wordsv4.asm
4cb2			endif 
4cb2			;;;;;;;;;;;;;; Debug code 
4cb2			 
4cb2			 
4cb2			;if DEBUG_FORTH_PARSE 
4cb2 .. 00		.nowordfound: db "No match",0 
4cbb .. 00		.compword:	db "Comparing word ",0 
4ccb .. 00		.nextwordat:	db "Next word at",0 
4cd8 .. 00		.charmatch:	db "Char match",0 
4ce3			;endif 
4ce3			if DEBUG_FORTH_JP 
4ce3			.foundword:	db "Word match. Exec..",0 
4ce3			endif 
4ce3			;if DEBUG_FORTH_PUSH 
4ce3 .. 00		.enddict:	db "Dict end. Push.",0 
4cf3 .. 00		.push_str:	db "Pushing string",0 
4d02 .. 00		.push_num:	db "Pushing number",0 
4d11 .. 00		.data_sp:	db "SP:",0 
4d15 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
4d27 .. 00		.wordinde:	db "Word in DE (3/0):",0 
4d39 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
4d4b			;endif 
4d4b			;if DEBUG_FORTH_MALLOC 
4d4b .. 00		.push_malloc:	db "Malloc address",0 
4d5a			;endif 
4d5a			 
4d5a			 
4d5a			 
4d5a			; display malloc address and current data stack pointer  
4d5a			 
4d5a			malloc_error: 
4d5a d5				push de 
4d5b f5				push af 
4d5c e5				push hl 
4d5d cd b9 0a			call clear_display 
4d60 11 82 4d			ld de, .mallocerr 
4d63 3e 00			ld a,0 
4d65			;	ld de,os_word_scratch 
4d65 cd cc 0a			call str_at_display 
4d68 3e 11			ld a, display_row_1+17 
4d6a 11 77 fb			ld de, debug_mark 
4d6d cd cc 0a			call str_at_display 
4d70 cd dc 0a			call update_display 
4d73				;call break_point_state 
4d73 cd 53 63			call cin_wait 
4d76			 
4d76 3e 20			ld a, ' ' 
4d78 32 31 ee			ld (os_view_disable), a 
4d7b e1				pop hl 
4d7c f1				pop af 
4d7d d1				pop de	 
4d7e				CALLMONITOR 
4d7e cd 00 14			call break_point_state  
4d81				endm  
# End of macro CALLMONITOR
4d81 c9				ret 
4d82			 
4d82 .. 00		.mallocerr: 	db "Malloc Error",0 
4d8f			;if DEBUG_FORTH_PUSH 
4d8f			display_data_sp: 
4d8f f5				push af 
4d90			 
4d90				; see if disabled 
4d90			 
4d90 3a 31 ee			ld a, (os_view_disable) 
4d93 fe 2a			cp '*' 
4d95 28 67			jr z, .skipdsp 
4d97			 
4d97 e5				push hl 
4d98 e5				push hl 
4d99 e5			push hl 
4d9a cd b9 0a			call clear_display 
4d9d e1			pop hl 
4d9e 7c				ld a,h 
4d9f 21 37 f1			ld hl, os_word_scratch 
4da2 cd 13 0f			call hexout 
4da5 e1				pop hl 
4da6 7d				ld a,l 
4da7 21 39 f1			ld hl, os_word_scratch+2 
4daa cd 13 0f			call hexout 
4dad 21 3b f1			ld hl, os_word_scratch+4 
4db0 3e 00			ld a,0 
4db2 77				ld (hl),a 
4db3 11 37 f1			ld de,os_word_scratch 
4db6 3e 28				ld a, display_row_2 
4db8 cd cc 0a				call str_at_display 
4dbb 11 15 4d			ld de, .wordinhl 
4dbe 3e 00			ld a, display_row_1 
4dc0			 
4dc0 cd cc 0a				call str_at_display 
4dc3 11 77 fb			ld de, debug_mark 
4dc6 3e 11			ld a, display_row_1+17 
4dc8			 
4dc8 cd cc 0a				call str_at_display 
4dcb			 
4dcb				; display current data stack pointer 
4dcb 11 11 4d			ld de,.data_sp 
4dce 3e 30				ld a, display_row_2 + 8 
4dd0 cd cc 0a				call str_at_display 
4dd3			 
4dd3 2a 1f f8			ld hl,(cli_data_sp) 
4dd6 e5				push hl 
4dd7 7c				ld a,h 
4dd8 21 37 f1			ld hl, os_word_scratch 
4ddb cd 13 0f			call hexout 
4dde e1				pop hl 
4ddf 7d				ld a,l 
4de0 21 39 f1			ld hl, os_word_scratch+2 
4de3 cd 13 0f			call hexout 
4de6 21 3b f1			ld hl, os_word_scratch+4 
4de9 3e 00			ld a,0 
4deb 77				ld (hl),a 
4dec 11 37 f1			ld de,os_word_scratch 
4def 3e 33				ld a, display_row_2 + 11 
4df1 cd cc 0a				call str_at_display 
4df4			 
4df4			 
4df4 cd dc 0a			call update_display 
4df7 cd 3d 0a			call delay1s 
4dfa cd 3d 0a			call delay1s 
4dfd e1				pop hl 
4dfe			.skipdsp: 
4dfe f1				pop af 
4dff c9				ret 
4e00			 
4e00			display_data_malloc: 
4e00			 
4e00 f5				push af 
4e01 e5				push hl 
4e02 e5				push hl 
4e03 e5			push hl 
4e04 cd b9 0a			call clear_display 
4e07 e1			pop hl 
4e08 7c				ld a,h 
4e09 21 37 f1			ld hl, os_word_scratch 
4e0c cd 13 0f			call hexout 
4e0f e1				pop hl 
4e10 7d				ld a,l 
4e11 21 39 f1			ld hl, os_word_scratch+2 
4e14 cd 13 0f			call hexout 
4e17 21 3b f1			ld hl, os_word_scratch+4 
4e1a 3e 00			ld a,0 
4e1c 77				ld (hl),a 
4e1d 11 37 f1			ld de,os_word_scratch 
4e20 3e 28				ld a, display_row_2 
4e22 cd cc 0a				call str_at_display 
4e25 11 4b 4d			ld de, .push_malloc 
4e28 3e 00			ld a, display_row_1 
4e2a			 
4e2a cd cc 0a				call str_at_display 
4e2d			 
4e2d				; display current data stack pointer 
4e2d 11 11 4d			ld de,.data_sp 
4e30 3e 30				ld a, display_row_2 + 8 
4e32 cd cc 0a				call str_at_display 
4e35			 
4e35 2a 1f f8			ld hl,(cli_data_sp) 
4e38 e5				push hl 
4e39 7c				ld a,h 
4e3a 21 37 f1			ld hl, os_word_scratch 
4e3d cd 13 0f			call hexout 
4e40 e1				pop hl 
4e41 7d				ld a,l 
4e42 21 39 f1			ld hl, os_word_scratch+2 
4e45 cd 13 0f			call hexout 
4e48 21 3b f1			ld hl, os_word_scratch+4 
4e4b 3e 00			ld a,0 
4e4d 77				ld (hl),a 
4e4e 11 37 f1			ld de,os_word_scratch 
4e51 3e 33				ld a, display_row_2 + 11 
4e53 cd cc 0a				call str_at_display 
4e56			 
4e56 cd dc 0a			call update_display 
4e59 cd 3d 0a			call delay1s 
4e5c cd 3d 0a			call delay1s 
4e5f e1				pop hl 
4e60 f1				pop af 
4e61 c9				ret 
4e62			;endif 
4e62			 
4e62			include "forth_autostart.asm" 
4e62			; list of commands to perform at system start up 
4e62			 
4e62			startcmds: 
4e62			;	dw test11 
4e62			;	dw test12 
4e62			;	dw test13 
4e62			;	dw test14 
4e62			;	dw test15 
4e62			;	dw test16 
4e62			;	dw test17 
4e62			;	dw ifthtest1 
4e62			;	dw ifthtest2 
4e62			;	dw ifthtest3 
4e62			;	dw mmtest1 
4e62			;	dw mmtest2 
4e62			;	dw mmtest3 
4e62			;	dw mmtest4 
4e62			;	dw mmtest5 
4e62			;	dw mmtest6 
4e62			;	dw iftest1 
4e62			;	dw iftest2 
4e62			;	dw iftest3 
4e62			;	dw looptest1 
4e62			;	dw looptest2 
4e62			;	dw test1 
4e62			;	dw test2 
4e62			;	dw test3 
4e62			;	dw test4 
4e62			;	dw game2r 
4e62			;	dw game2b1 
4e62			;	dw game2b2 
4e62			 
4e62				; start up words that are actually useful 
4e62			 
4e62 c0 4e			dw clrstack 
4e64 f3 4e			dw type 
4e66 b4 50			dw stest 
4e68 17 4f			dw strncpy 
4e6a 55 50			dw list 
4e6c 78 4f			dw start1 
4e6e 8a 4f			dw start2 
4e70			;	dw start3 
4e70 9d 4f			dw start3b 
4e72 f5 4f			dw start3c 
4e74			 
4e74				; (unit) testing words 
4e74			 
4e74 2b 51			dw mtesta 
4e76 e0 51			dw mtestb 
4e78 83 52			dw mtestc 
4e7a 38 53			dw mtestd 
4e7c dc 53			dw mteste 
4e7e			 
4e7e				; demo/game words 
4e7e			 
4e7e e8 5a		        dw game3w 
4e80 16 5b		        dw game3p 
4e82 34 5b		        dw game3sc 
4e84 65 5b		        dw game3vsi 
4e86 91 5b		        dw game3vs 
4e88				 
4e88 db 58			dw game2b 
4e8a 49 59			dw game2bf 
4e8c 93 59			dw game2mba 
4e8e 29 5a			dw game2mbas 
4e90 6b 5a			dw game2mb 
4e92			 
4e92 9c 55			dw game1 
4e94 ad 55			dw game1a 
4e96 0f 56			dw game1b 
4e98 44 56			dw game1c 
4e9a 7a 56			dw game1d 
4e9c ab 56			dw game1s 
4e9e bf 56			dw game1t 
4ea0 d4 56			dw game1f 
4ea2 08 57			dw game1z 
4ea4 4c 57			dw game1zz 
4ea6			 
4ea6 92 54			dw test5 
4ea8 ca 54			dw test6 
4eaa 02 55			dw test7 
4eac 16 55			dw test8 
4eae 42 55			dw test9 
4eb0 58 55			dw test10 
4eb2				 
4eb2 23 58		        dw ssv5 
4eb4 07 58		        dw ssv4 
4eb6 eb 57		        dw ssv3 
4eb8 b5 57		        dw ssv2 
4eba 3c 58		        dw ssv1 
4ebc 84 58		        dw ssv1cpm 
4ebe			;	dw keyup 
4ebe			;	dw keydown 
4ebe			;	dw keyleft 
4ebe			;	dw keyright 
4ebe			;	dw 	keyf1 
4ebe			;	dw keyf2 
4ebe			;	dw keyf3 
4ebe			;	dw keyf4 
4ebe			;	dw keyf5 
4ebe			;	dw keyf6 
4ebe			;	dw keyf7 
4ebe			;	dw keyf8 
4ebe			;	dw keyf9 
4ebe			;	dw keyf10 
4ebe			;	dw keyf11 
4ebe			;	dw keyf12 
4ebe			;	dw keytab 
4ebe			;	dw keycr 
4ebe			;	dw keyhome 
4ebe			;	dw keyend 
4ebe			;	dw keybs 
4ebe 00 00			db 0, 0	 
4ec0			 
4ec0			 
4ec0			; clear stack  
4ec0			 
4ec0 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
4ef3			 
4ef3			; type ( addr count - ) 
4ef3 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
4f17			 
4f17			; some direct memory words 
4f17			; strncpy ( len t f -- t ) 
4f17			 
4f17 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
4f78			 
4f78 .. 00		start1:     	db ": bpon $0000 bp ;",0 
4f8a .. 00		start2:     	db ": bpoff $0001 bp ;",0 
4f9d			;start3:         db ": dirlist ir cls drop dup $00 > if $01 do .> BL .> .> BL .> .> BL .> loop then nop ;",0 
4f9d .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 i at . $01 i at . $04 i at . loop then nop ;",0 
4ff5 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
5055			 
5055			 
5055			; a handy word to list items on the stack 
5055			 
5055 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> accept drop depth 0= not until nop ;",0 
50b4			 
50b4			 
50b4			; test stack  
50b4			; rnd8 stest 
50b4			 
50b4 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
512b			 
512b			; random malloc and free cycles 
512b			 
512b .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
51e0			 
51e0			; fixed malloc and free cycles 
51e0			 
51e0 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5283			 
5283			; fixed double string push and drop cycle  
5283			 
5283 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
5338			 
5338			; consistent fixed string push and drop cycle  
5338			 
5338 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
53dc			 
53dc .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5492			 
5492			;test1:		db ": aa 1 2 3 ;", 0 
5492			;test2:     	db "111 aa 888 999",0 
5492			;test3:     	db ": bb 77 ;",0 
5492			;test4:     	db "$02 $01 do i . loop bb",0 
5492			 
5492 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
54ca .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
5502 .. 00		test7:     	db ": box hline vline ;",0 
5516 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
5542 .. 00		test9:     	db ": sw $01 adsp world ;",0 
5558 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
557d .. 00		test11:     	db "hello create .",0 
558c .. 00		test12:     	db "hello2 create .",0 
559c			 
559c			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
559c			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
559c			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
559c			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
559c			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
559c			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
559c			 
559c			;iftest1:     	db "$0001 IF cls .",0 
559c			;iftest2:     	db "$0000 IF cls .",0 
559c			;iftest3:     	db "$0002 $0003 - IF cls .",0 
559c			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
559c			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
559c			 
559c			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
559c			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
559c			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
559c			 
559c			 
559c			 
559c			; a small guess the number game 
559c			 
559c .. 00		game1:          db ": gsn rnd8 v1! ;",0 
55ad .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
560f			 
560f .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
5644 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
567a .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
56ab .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
56bf .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
56d4 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5708 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
574c			 
574c			; Using 'ga' save a high score across multiple runs using external storage 
574c			 
574c .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
57b5			 
57b5			 
57b5			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
57b5			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
57b5			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
57b5			 
57b5			; simple screen saver to test code memory reuse to destruction 
57b5			 
57b5 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
57eb .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
5807 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
5823 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
583c .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
5884 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
58db			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
58db			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
58db			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
58db			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
58db			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
58db			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
58db			 
58db			 
58db			 
58db			; minesweeper/battleship finding game 
58db			; draws a game board of random ship/mine positions 
58db			; user enters coords to see if it hits on 
58db			; game ends when all are hit 
58db			; when hit or miss says how many may be in the area 
58db			 
58db			; setup the game board and then hide it 
58db .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
5949 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
5993			; prompt for where to target 
5993 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
5a29 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
5a4e			; TODO see if the entered coords hits or misses pushes char hit of miss 
5a4e .. 00		game2mbht:      db ": mbckht nop ;",0 
5a5d .. 00		game2mbms:      db ": mbcms nop ;",0 
5a6b			; TODO how many might be near by 
5a6b .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
5ae8			 
5ae8			; Game 3 
5ae8			 
5ae8			; Vert scroller ski game - avoid the trees! 
5ae8			 
5ae8			; v0 score (ie turns) 
5ae8			; v1 player pos 
5ae8			; v2 left wall 
5ae8			; v3 right wall 
5ae8			 
5ae8			; Draw side walls randomly 
5ae8			 
5ae8 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
5b16			 
5b16			; Draw player 
5b16 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
5b34			 
5b34			; TODO Get Key 
5b34			 
5b34			; TODO Move left right 
5b34			 
5b34			; scroll and move walls a bit 
5b34			 
5b34 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
5b65			 
5b65			; main game loop 
5b65			 
5b65 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
5b91 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
5bd0			 
5bd0			; key board defs 
5bd0			 
5bd0 .. 00		keyup:       db ": keyup $05 ;",0 
5bde .. 00		keydown:       db ": keydown $0a ;",0 
5bee .. 00		keyleft:       db ": keyleft $0b ;",0 
5bfe .. 00		keyright:       db ": keyright $0c ;",0 
5c0f .. 00		keyf1:       db ": keyf1 $10 ;",0 
5c1d .. 00		keyf2:       db ": keyf2 $11 ;",0 
5c2b .. 00		keyf3:       db ": keyf3 $12 ;",0 
5c39 .. 00		keyf4:       db ": keyf4 $13 ;",0 
5c47 .. 00		keyf5:       db ": keyf5 $14 ;",0 
5c55 .. 00		keyf6:       db ": keyf6 $15 ;",0 
5c63 .. 00		keyf7:       db ": keyf7 $16 ;",0 
5c71 .. 00		keyf8:       db ": keyf8 $17 ;",0 
5c7f .. 00		keyf9:       db ": keyf9 $18 ;",0 
5c8d .. 00		keyf10:       db ": keyf10 $19 ;",0 
5c9c .. 00		keyf11:       db ": keyf11 $1a ;",0 
5cab .. 00		keyf12:       db ": keyf12 $1b ;",0 
5cba			 
5cba .. 00		keytab:       db ": keytab $09 ;",0 
5cc9 .. 00		keycr:       db ": keycr $0d ;",0 
5cd7 .. 00		keyhome:       db ": keyhome $0e ;",0 
5ce7 .. 00		keyend:       db ": keyend $0f ;",0 
5cf6 .. 00		keybs:       db ": keybs $08 ;",0 
5d04			 
5d04			   
5d04			 
5d04			 
5d04			 
5d04			; eof 
# End of file forth_autostart.asm
5d04			 
5d04 .. 00		sprompt1: db "Startup load...",0 
5d14 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
5d2a			 
5d2a			forth_startup: 
5d2a 21 62 4e			ld hl, startcmds 
5d2d 3e 00			ld a, 0 
5d2f 32 58 f2			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
5d32			 
5d32 e5			.start1:	push hl 
5d33 cd b9 0a			call clear_display 
5d36 11 04 5d			ld de, sprompt1 
5d39 3e 00		        ld a, display_row_1 
5d3b cd cc 0a			call str_at_display 
5d3e 11 14 5d			ld de, sprompt2 
5d41 3e 28		        ld a, display_row_2 
5d43 cd cc 0a			call str_at_display 
5d46 e1				pop hl 
5d47 e5				push hl 
5d48 5e				ld e,(hl) 
5d49 23				inc hl 
5d4a 56				ld d,(hl) 
5d4b 3e 50		        ld a, display_row_3 
5d4d cd cc 0a			call str_at_display 
5d50 cd dc 0a			call update_display 
5d53			 
5d53			 
5d53 3a 58 f2			ld a, (os_last_cmd) 
5d56 fe 00			cp 0 
5d58 28 05			jr z, .startprompt 
5d5a cd 31 0a			call delay250ms 
5d5d 18 24			jr .startdo 
5d5f				 
5d5f				 
5d5f			 
5d5f			.startprompt: 
5d5f			 
5d5f 3e 9f			ld a,display_row_4 + display_cols - 1 
5d61 11 10 19		        ld de, endprg 
5d64 cd cc 0a			call str_at_display 
5d67 cd dc 0a			call update_display 
5d6a cd 3d 0a			call delay1s 
5d6d cd 53 63			call cin_wait 
5d70						 
5d70 fe 2a			cp '*' 
5d72 28 5e			jr z, .startupend1 
5d74 fe 23			cp '#' 
5d76 20 07			jr nz, .startno 
5d78 3e 01			ld a, 1 
5d7a 32 58 f2			ld (os_last_cmd),a 
5d7d 18 04			jr .startdo 
5d7f fe 31		.startno:	cp '1' 
5d81 28 3a			jr z,.startnxt  
5d83			 
5d83				; exec startup line 
5d83			.startdo:	 
5d83 e1				pop hl 
5d84 e5				push hl 
5d85				 
5d85 5e				ld e,(hl) 
5d86 23				inc hl 
5d87 56				ld d,(hl) 
5d88 eb				ex de,hl 
5d89			 
5d89 e5				push hl 
5d8a			 
5d8a 3e 00			ld a, 0 
5d8c				;ld a, FORTH_END_BUFFER 
5d8c cd 7b 10			call strlent 
5d8f 23				inc hl   ; include zero term to copy 
5d90 06 00			ld b,0 
5d92 4d				ld c,l 
5d93 e1				pop hl 
5d94 11 32 ee			ld de, scratch 
5d97 ed b0			ldir 
5d99			 
5d99			 
5d99 21 32 ee			ld hl, scratch 
5d9c cd d9 1b			call forthparse 
5d9f cd 19 1c			call forthexec 
5da2 cd 30 1b			call forthexec_cleanup 
5da5			 
5da5 3e 78			ld a, display_row_4 
5da7 11 b4 16			ld de, endprog 
5daa			 
5daa cd dc 0a			call update_display		 
5dad			 
5dad 3a 58 f2			ld a, (os_last_cmd) 
5db0 fe 00			cp 0 
5db2 20 09			jr nz, .startnxt 
5db4 cd 12 19			call next_page_prompt 
5db7 cd b9 0a		        call clear_display 
5dba cd dc 0a			call update_display		 
5dbd			 
5dbd				; move onto next startup line? 
5dbd			.startnxt: 
5dbd			 
5dbd cd 31 0a			call delay250ms 
5dc0 e1				pop hl 
5dc1			 
5dc1 23				inc hl 
5dc2 23				inc hl 
5dc3			 
5dc3 e5				push hl 
5dc4 5e				ld e, (hl) 
5dc5 23				inc hl 
5dc6 56				ld d, (hl) 
5dc7 e1				pop hl 
5dc8				; TODO replace 0 test 
5dc8			 
5dc8 eb				ex de, hl 
5dc9 cd 3b 0c			call ishlzero 
5dcc			;	ld a,e 
5dcc			;	add d 
5dcc			;	cp 0    ; any left to do? 
5dcc eb				ex de, hl 
5dcd c2 32 5d			jp nz, .start1 
5dd0 18 01			jr .startupend 
5dd2			 
5dd2 e1			.startupend1: pop hl 
5dd3			.startupend: 
5dd3			 
5dd3 cd b9 0a			call clear_display 
5dd6 cd dc 0a			call update_display 
5dd9 c9				ret 
5dda			 
5dda			 
5dda			; stack over and underflow checks 
5dda			 
5dda			; init the words to detect the under/overflow 
5dda			 
5dda			chk_stk_init: 
5dda				; a vague random number to check so we dont get any "lucky" hits 
5dda 3e 2d			ld a, 45 
5ddc 6f				ld l, a 
5ddd 00				nop 
5dde 3e 17			ld a, 23 
5de0 67				ld h, a 
5de1			 
5de1 22 27 ee			ld (chk_word), hl     ; the word we need to check against 
5de4			 
5de4			;	ld (chk_stund), hl	; stack points.... 
5de4 22 fd fb			ld (chk_stovr), hl 
5de7 22 1d f8			ld (chk_ret_und), hl 
5dea 22 9b f7			ld (chk_ret_ovr), hl 
5ded 22 99 f5			ld (chk_loop_ovr), hl 
5df0 22 97 f3			ld (chk_data_ovr), hl 
5df3 c9				ret 
5df4				 
5df4			check_stacks: 
5df4				; check all stack words 
5df4			 
5df4 e5				push hl 
5df5 d5				push de 
5df6			 
5df6			;	ld de,(chk_word) 
5df6			;	ld hl, (chk_stund)	; stack points.... 
5df6			;	if DEBUG_STK_FAULT 
5df6			;		DMARK "FAa" 
5df6			;		CALLMONITOR 
5df6			;	endif 
5df6			;	call cmp16 
5df6			;	jp z, .chk_faulta 
5df6			; 
5df6			;	ld de, sfaultsu 
5df6			;	jp .chk_fault 
5df6			 
5df6 2a fd fb		.chk_faulta: ld hl, (chk_stovr) 
5df9 ed 5b 27 ee		ld de,(chk_word) 
5dfd				if DEBUG_STK_FAULT 
5dfd					DMARK "FAb" 
5dfd					CALLMONITOR 
5dfd				endif 
5dfd cd 30 0c			call cmp16 
5e00 28 06			jr z, .chk_fault1 
5e02 11 a3 5e			ld de, sfaultso 
5e05 c3 57 5e			jp .chk_fault 
5e08			.chk_fault1:  
5e08 2a 1d f8			ld hl, (chk_ret_und) 
5e0b ed 5b 27 ee		ld de,(chk_word) 
5e0f				if DEBUG_STK_FAULT 
5e0f					DMARK "FAU" 
5e0f					CALLMONITOR 
5e0f				endif 
5e0f cd 30 0c			call cmp16 
5e12 ca 1b 5e			jp z, .chk_fault2 
5e15 11 b3 5e			ld de, sfaultru 
5e18 c3 57 5e			jp .chk_fault 
5e1b			.chk_fault2:  
5e1b 2a 9b f7			ld hl, (chk_ret_ovr) 
5e1e ed 5b 27 ee		ld de,(chk_word) 
5e22				if DEBUG_STK_FAULT 
5e22					DMARK "FA1" 
5e22					CALLMONITOR 
5e22				endif 
5e22 cd 30 0c			call cmp16 
5e25 ca 2e 5e			jp z, .chk_fault3 
5e28 11 c1 5e			ld de, sfaultro 
5e2b c3 57 5e			jp .chk_fault 
5e2e			.chk_fault3:  
5e2e 2a 99 f5			ld hl, (chk_loop_ovr) 
5e31 ed 5b 27 ee		ld de,(chk_word) 
5e35				if DEBUG_STK_FAULT 
5e35					DMARK "FA2" 
5e35					CALLMONITOR 
5e35				endif 
5e35 cd 30 0c			call cmp16 
5e38 ca 41 5e			jp z, .chk_fault4 
5e3b 11 db 5e			ld de, sfaultlo 
5e3e c3 57 5e			jp .chk_fault 
5e41			.chk_fault4:  
5e41 2a 97 f3			ld hl, (chk_data_ovr) 
5e44 ed 5b 27 ee		ld de,(chk_word) 
5e48				if DEBUG_STK_FAULT 
5e48					DMARK "FA3" 
5e48					CALLMONITOR 
5e48				endif 
5e48 cd 30 0c			call cmp16 
5e4b ca 54 5e			jp z, .chk_fault5 
5e4e 11 f5 5e			ld de, sfaultdo 
5e51 c3 57 5e			jp .chk_fault 
5e54			 
5e54			 
5e54			.chk_fault5:  
5e54 d1				pop de 
5e55 e1				pop hl 
5e56			 
5e56 c9				ret 
5e57			 
5e57 cd b9 0a		.chk_fault: 	call clear_display 
5e5a 3e 28				ld a, display_row_2 
5e5c cd cc 0a				call str_at_display 
5e5f 11 85 5e				   ld de, .stackfault 
5e62 3e 00				ld a, display_row_1 
5e64 cd cc 0a				call str_at_display 
5e67 11 77 fb				    ld de, debug_mark 
5e6a 3e 11				ld a, display_row_1+17 
5e6c cd cc 0a				call str_at_display 
5e6f cd dc 0a				call update_display 
5e72			 
5e72				; prompt before entering montior for investigating issue 
5e72			 
5e72 3e 78			ld a, display_row_4 
5e74 11 b4 16			ld de, endprog 
5e77			 
5e77 cd dc 0a			call update_display		 
5e7a			 
5e7a cd 12 19			call next_page_prompt 
5e7d			 
5e7d d1				pop de 
5e7e e1				pop hl 
5e7f cd 08 17				call monitor 
5e82 c3 f5 15				jp warmstart 
5e85					;jp 0 
5e85					;halt 
5e85			 
5e85			 
5e85			 
5e85 .. 00		.stackfault: 	db "Stack fault:",0 
5e92			 
5e92 .. 00		sfaultsu: 	db	"Stack under flow",0 
5ea3 .. 00		sfaultso: 	db	"Stack over flow",0 
5eb3 .. 00		sfaultru:	db "RTS underflow",0 
5ec1 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
5edb .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
5ef5 .. 00		sfaultdo:	db "DTS overflow", 0 
5f02			 
5f02			 
5f02			fault_dsp_under: 
5f02 11 14 5f			ld de, .dsp_under 
5f05 c3 c4 5f			jp .show_fault 
5f08			 
5f08			fault_rsp_under: 
5f08 11 22 5f			ld de, .rsp_under 
5f0b c3 c4 5f			jp .show_fault 
5f0e			fault_loop_under: 
5f0e 11 30 5f			ld de, .loop_under 
5f11 c3 c4 5f			jp .show_fault 
5f14			 
5f14 .. 00		.dsp_under: db "DSP Underflow",0 
5f22 .. 00		.rsp_under: db "RSP Underflow",0 
5f30 .. 00		.loop_under: db "LOOP Underflow",0 
5f3f			 
5f3f			 
5f3f d5			type_faultn: 	push de 
5f40 e5					push hl 
5f41 cd b9 0a				call clear_display 
5f44 11 6b 5f				   ld de, .typefaultn 
5f47 3e 00				ld a, display_row_1 
5f49 cd cc 0a				call str_at_display 
5f4c 11 77 fb				    ld de, debug_mark 
5f4f 3e 11				ld a, display_row_1+17 
5f51 cd cc 0a				call str_at_display 
5f54 cd dc 0a				call update_display 
5f57			 
5f57				; prompt before entering montior for investigating issue 
5f57			 
5f57 3e 78			ld a, display_row_4 
5f59 11 b4 16			ld de, endprog 
5f5c			 
5f5c cd dc 0a			call update_display		 
5f5f			 
5f5f cd 12 19			call next_page_prompt 
5f62			 
5f62 e5					push hl 
5f63 d5					push de 
5f64 cd 08 17				call monitor 
5f67 c3 f5 15				jp warmstart 
5f6a 76					halt 
5f6b			 
5f6b			 
5f6b .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
5f82			 
5f82 d5			type_faults: 	push de 
5f83 e5					push hl 
5f84 cd b9 0a				call clear_display 
5f87 11 ad 5f				   ld de, .typefaults 
5f8a 3e 00				ld a, display_row_1 
5f8c cd cc 0a				call str_at_display 
5f8f 11 77 fb				    ld de, debug_mark 
5f92 3e 11				ld a, display_row_1+17 
5f94 cd cc 0a				call str_at_display 
5f97 cd dc 0a				call update_display 
5f9a			 
5f9a				; prompt before entering montior for investigating issue 
5f9a			 
5f9a 3e 78			ld a, display_row_4 
5f9c 11 b4 16			ld de, endprog 
5f9f			 
5f9f cd dc 0a			call update_display		 
5fa2			 
5fa2 cd 12 19			call next_page_prompt 
5fa5			 
5fa5 e1					pop hl 
5fa6 d1					pop de 
5fa7 cd 08 17				call monitor 
5faa c3 f5 15				jp warmstart 
5fad			 
5fad			 
5fad .. 00		.typefaults: db "STR Type Expected TOS!",0 
5fc4			 
5fc4			.show_fault: 	 
5fc4 d5					push de 
5fc5 cd b9 0a				call clear_display 
5fc8 d1					pop de 
5fc9 3e 00				ld a, display_row_1 
5fcb cd cc 0a				call str_at_display 
5fce 11 77 fb				    ld de, debug_mark 
5fd1 3e 11				ld a, display_row_1+17 
5fd3 cd cc 0a				call str_at_display 
5fd6 cd dc 0a				call update_display 
5fd9			 
5fd9				; prompt before entering montior for investigating issue 
5fd9			 
5fd9 3e 78			ld a, display_row_4 
5fdb 11 b4 16			ld de, endprog 
5fde			 
5fde cd dc 0a			call update_display		 
5fe1			 
5fe1 cd 12 19			call next_page_prompt 
5fe4			 
5fe4 e1					pop hl 
5fe5 d1					pop de 
5fe6 cd 08 17				call monitor 
5fe9			; do a dump to cli and not warmstart so we preserve all of the uwords.  
5fe9			; TODO Make optional fault restart to cli or warm boot? 
5fe9					;jp warmstart 
5fe9 c3 4d 16				jp cli 
5fec 76					halt 
5fed			; eof 
# End of file forth_kernel.asm
5fed			;include "nascombasic.asm" 
5fed			 
5fed			 
5fed			; find out where the code ends if loaded into RAM (for SC114) 
5fed			;endofcode:  
5fed			;	nop 
5fed			 
5fed			 
5fed			; eof 
5fed			 
# End of file main.asm
5fed			include "firmware_lcd_4x40.asm" 
5fed			; **********************************************************************  
5fed			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
5fed			; **********************************************************************  
5fed			;  
5fed			; **  Written as a Small Computer Monitor App  
5fed			; **  www.scc.me.uk  
5fed			;  
5fed			; History  
5fed			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
5fed			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
5fed			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
5fed			;  
5fed			; **********************************************************************  
5fed			;  
5fed			; This program is an example of one of the methods of interfacing an   
5fed			; alphanumeric LCD module.   
5fed			;  
5fed			; In this example the display is connected to either a Z80 PIO or a   
5fed			; simple 8-bit output port.   
5fed			;  
5fed			; This interfacing method uses 4-bit data mode and uses time delays  
5fed			; rather than polling the display's ready status. As a result the   
5fed			; interface only requires 6 simple output lines:  
5fed			;   Output bit 0 = not used  
5fed			;   Output bit 1 = not used  
5fed			;   Output bit 2 = RS         High = data, Low = instruction  
5fed			;   Output bit 3 = E          Active high  
5fed			;   Output bit 4 = DB4  
5fed			;   Output bit 5 = DB5  
5fed			;   Output bit 6 = DB6  
5fed			;   Output bit 7 = DB7  
5fed			; Display's R/W is connected to 0v so it is always in write mode  
5fed			;  
5fed			; This set up should work with any system supporting the RC2014 bus  
5fed			  
5fed			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
5fed			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
5fed			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
5fed			;  
5fed			; **********************************************************************  
5fed			  
5fed			; Additonal for 4x40. E1 and E2 instead of just E   
5fed			; TODO swipe vidout signal on port a to activate E2  
5fed			  
5fed			; **********************************************************************  
5fed			; **  Constants  
5fed			; **********************************************************************  
5fed			; LCD constants required by LCD support module  
5fed			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
5fed			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
5fed			kLCDBitE:   EQU 3              ;Port bit for LCD E signal             
5fed			kLCDBitE2:   EQU 0              ;Port bit for LCD E2 signal            VIDOUT  
5fed			; TODO Decide which E is being set  
5fed			kLCDWidth:  EQU display_cols             ;Width in characters  
5fed			  
5fed			; **********************************************************************  
5fed			; **  Code library usage  
5fed			; **********************************************************************  
5fed			  
5fed			; send character to current cursor position  
5fed			; wraps and/or scrolls screen automatically  
5fed			  
5fed			  
5fed			  
5fed			lcd_init:  
5fed			  
5fed			; SCMonAPI functions used  
5fed			  
5fed			; Alphanumeric LCD functions used  
5fed			; no need to specify specific functions for this module  
5fed			  
5fed 3e cf		            LD   A, 11001111b  
5fef d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
5ff1 3e 00		            LD   A, 00000000b  
5ff3 d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
5ff5			  
5ff5			; Initialise alphanumeric LCD module  
5ff5 3e 00				ld a, 0  
5ff7 32 d7 f8				ld (display_lcde1e2), a  
5ffa cd 7b 60		            CALL fLCD_Init      ;Initialise LCD module  
5ffd 3e 01				ld a, 1  
5fff 32 d7 f8				ld (display_lcde1e2), a  
6002 cd 7b 60		            CALL fLCD_Init      ;Initialise LCD module  
6005			  
6005 c9				ret  
6006			  
6006			;  
6006			;;  
6006			; lcd functions  
6006			;  
6006			;  
6006			  
6006			; what is at cursor position   
6006			  
6006			;get_cursor:	ld de, (cursor_row)   ;  row + col  
6006			;		call curptr  
6006			;		ret  
6006			  
6006			  
6006			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
6006			  
6006			curptr:  
6006 c5				push bc  
6007 21 bd fa			ld hl, display_fb0  
600a			cpr:	  
600a				; loop for cursor whole row  
600a 0e 28			ld c, display_cols  
600c 23			cpr1:	inc hl  
600d 0d				dec c  
600e 20 fc			jr nz, cpr1  
6010 05				dec b  
6011 20 f7			jr nz, cpr  
6013			  
6013				; add col	  
6013			  
6013 23			cpr2:	inc hl  
6014 1d				dec e  
6015 20 fc			jr nz, cpr2  
6017			  
6017 c1				pop bc  
6018 c9				ret  
6019				  
6019			  
6019			  
6019			  
6019			  
6019			; write the frame buffer given in hl to hardware   
6019 22 d5 f8		write_display: ld (display_write_tmp), hl 	   
601c 3e 00			ld a, kLCD_Line1  
601e cd 28 61		            CALL fLCD_Pos       ;Position cursor to location in A  
6021 06 28			ld b, display_cols  
6023 ed 5b d5 f8		ld de, (display_write_tmp)  
6027 cd 73 60			call write_len_string  
602a				  
602a				  
602a 2a d5 f8			ld hl, (display_write_tmp)  
602d 11 28 00			ld de, display_cols  
6030 19				add hl,de  
6031 22 d5 f8			ld (display_write_tmp),hl  
6034			  
6034				  
6034 3e 28			ld a, kLCD_Line2  
6036 cd 28 61		            CALL fLCD_Pos       ;Position cursor to location in A  
6039 06 28			ld b, display_cols  
603b ed 5b d5 f8		ld de, (display_write_tmp)  
603f cd 73 60			call write_len_string  
6042				  
6042 2a d5 f8			ld hl, (display_write_tmp)  
6045 11 28 00			ld de, display_cols  
6048 19				add hl,de  
6049 22 d5 f8			ld (display_write_tmp),hl  
604c			  
604c				  
604c 3e 50			ld a, kLCD_Line3  
604e cd 28 61		            CALL fLCD_Pos       ;Position cursor to location in A  
6051 06 28			ld b, display_cols  
6053 ed 5b d5 f8		ld de, (display_write_tmp)  
6057 cd 73 60			call write_len_string  
605a				  
605a 2a d5 f8			ld hl, (display_write_tmp)  
605d 11 28 00			ld de, display_cols  
6060 19				add hl,de  
6061 22 d5 f8			ld (display_write_tmp),hl  
6064			  
6064				  
6064 3e 78			ld a, kLCD_Line4  
6066 cd 28 61		            CALL fLCD_Pos       ;Position cursor to location in A  
6069 06 28			ld b, display_cols  
606b ed 5b d5 f8		ld de, (display_write_tmp)  
606f cd 73 60			call write_len_string  
6072 c9					ret  
6073				  
6073				; write out a fixed length string given in b from de  
6073			  
6073 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
6074 cd e0 60		            CALL fLCD_Data      ;Write character to display  
6077 13				inc de  
6078 10 f9			djnz write_len_string  
607a c9				ret  
607b			  
607b			; Some other things to do  
607b			;            LD   A, kLCD_Clear ;Display clear  
607b			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
607b			;            LD   A, kLCD_Under ;Display on with underscore cursor  
607b			;            LD   A, kLCD_On     ;Display on with no cursor  
607b			;            ;LD   A, kLCD_Off   ;Display off  
607b			;            CALL fLCD_Inst      ;Send instruction to display  
607b			;  
607b			;  
607b			;            halt  
607b			;  
607b			;  
607b			;MsgHello:   DB  "Hello World!",0  
607b			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
607b			  
607b			; Custom characters 5 pixels wide by 8 pixels high  
607b			; Up to 8 custom characters can be defined  
607b			;BitMaps:      
607b			;; Character 0x00 = Battery icon  
607b			;            DB  01110b  
607b			;            DB  11011b  
607b			;            DB  10001b  
607b			;            DB  10001b  
607b			;            DB  11111b  
607b			;            DB  11111b  
607b			;            DB  11111b  
607b			;            DB  11111b  
607b			;; Character 0x01 = Bluetooth icon  
607b			;            DB  01100b  
607b			;            DB  01010b  
607b			;            DB  11100b  
607b			;            DB  01000b  
607b			;            DB  11100b  
607b			;            DB  01010b  
607b			;            DB  01100b  
607b			;            DB  00000b  
607b			;  
607b			  
607b			  
607b			; **********************************************************************  
607b			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
607b			; **********************************************************************  
607b			;  
607b			; **  Written as a Small Computer Monitor App   
607b			; **  Version 0.1 SCC 2018-05-16  
607b			; **  www.scc.me.uk  
607b			;  
607b			; **********************************************************************  
607b			;  
607b			; This module provides support for alphanumeric LCD modules using with  
607b			; *  HD44780 (or compatible) controller  
607b			; *  5 x 7 pixel fonts  
607b			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
607b			; *  Interface via six digital outputs to the display (see below)  
607b			;  
607b			; LCD module pinout:  
607b			;   1  Vss   0v supply  
607b			;   2  Vdd   5v supply  
607b			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
607b			;   4  RS    High = data, Low = instruction  
607b			;   5  R/W   High = Read, Low = Write  
607b			;   6  E     Enable signal (active high)  
607b			;   7  DB0   Data bit 0  
607b			;   8  DB1   Data bit 1  
607b			;   9  DB2   Data bit 2  
607b			;  10  DB3   Data bit 3  
607b			;  11  DB4   Data bit 4  
607b			;  12  DB5   Data bit 5  
607b			;  13  DB6   Data bit 6  
607b			;  14  DB7   Data bit 7  
607b			;  15  A     Backlight anode (+)  
607b			;  16  K     Backlight cathode (-)  
607b			;  
607b			; This interfacing method uses 4-bit data mode and uses time delays  
607b			; rather than polling the display's ready status. As a result the   
607b			; interface only requires 6 simple output lines:  
607b			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
607b			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
607b			;   LCD DB4 = Microcomputer output port bit 4  
607b			;   LCD DB5 = Microcomputer output port bit 5  
607b			;   LCD DB6 = Microcomputer output port bit 6  
607b			;   LCD DB7 = Microcomputer output port bit 7  
607b			; Display's R/W is connected to 0v so it is always in write mode  
607b			; All 6 connections must be on the same port address <kLCDPrt>  
607b			; This method also allows a decent length of cable from micro to LCD  
607b			;  
607b			; **********************************************************************  
607b			;  
607b			; To include the code for any given function provided by this module,   
607b			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
607b			; the parent source file.  
607b			; For example:  #REQUIRES   uHexPrefix  
607b			;  
607b			; Also #INCLUDE this file at some point after the #REQUIRES statements  
607b			; in the parent source file.  
607b			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
607b			;  
607b			; These are the function names provided by this module:  
607b			; fLCD_Init                     ;Initialise LCD  
607b			; fLCD_Inst                     ;Send instruction to LCD  
607b			; fLCD_Data                     ;Send data byte to LCD  
607b			; fLCD_Pos                      ;Position cursor  
607b			; fLCD_Str                      ;Display string  
607b			; fLCD_Def                      ;Define custom character  
607b			;  
607b			; **********************************************************************  
607b			;  
607b			; Requires SCMonAPI.asm to also be included in the project  
607b			;  
607b			  
607b			  
607b			; **********************************************************************  
607b			; **  Constants  
607b			; **********************************************************************  
607b			  
607b			; Constants that must be defined externally  
607b			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
607b			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
607b			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
607b			;kLCDWidth: EQU 20             ;Width in characters  
607b			  
607b			; general line offsets in any frame buffer  
607b			  
607b			  
607b			display_row_1: equ 0  
607b			display_row_2: equ display_row_1+display_cols  
607b			display_row_3: equ display_row_2 + display_cols  
607b			display_row_4: equ display_row_3 + display_cols  
607b			;display_row_4_eol:   
607b			  
607b			  
607b			; Cursor position values for the start of each line  
607b			  
607b			; E  
607b			kLCD_Line1: EQU 0x00   
607b			kLCD_Line2: EQU kLCD_Line1+kLCDWidth  
607b			; E1  
607b			kLCD_Line3: EQU kLCD_Line2+kLCDWidth  
607b			kLCD_Line4: EQU kLCD_Line3+kLCDWidth   
607b			  
607b			; Instructions to send as A register to fLCD_Inst  
607b			kLCD_Clear: EQU 00000001b     ;LCD clear  
607b			kLCD_Off:   EQU 00001000b     ;LCD off  
607b			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
607b			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
607b			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
607b			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
607b			  
607b			; Constants used by this code module  
607b			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
607b			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
607b			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
607b			  
607b			  
607b			  
607b			; **********************************************************************  
607b			; **  LCD support functions  
607b			; **********************************************************************  
607b			  
607b			; Initialise alphanumeric LCD module  
607b			; LCD control register codes:  
607b			;   DL   0 = 4-bit mode        1 = 8-bit mode  
607b			;   N    0 = 1-line mode       1 = 2-line mode  
607b			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
607b			;   D    0 = Display off       1 = Display on  
607b			;   C    0 = Cursor off        1 = Cursor on  
607b			;   B    0 = Blinking off      1 = Blinking on  
607b			;   ID   0 = Decrement mode    1 = Increment mode  
607b			;   SH   0 = Entire shift off  1 = Entire shift on  
607b 3e 28		fLCD_Init:  LD   A, 40  
607d cd a2 61		            CALL LCDDelay       ;Delay 40ms after power up  
6080			; For reliable reset set 8-bit mode - 3 times  
6080 cd 72 61		            CALL WrFn8bit       ;Function = 8-bit mode  
6083 cd 72 61		            CALL WrFn8bit       ;Function = 8-bit mode  
6086 cd 72 61		            CALL WrFn8bit       ;Function = 8-bit mode  
6089			; Set 4-bit mode  
6089 cd 6e 61		            CALL WrFn4bit       ;Function = 4-bit mode  
608c cd a0 61		            CALL LCDDelay1      ;Delay 37 us or more  
608f			; Function set  
608f 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
6091 cd a4 60		            CALL fLCD_Inst      ;2 line, display on  
6094			; Display On/Off control  
6094 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
6096 cd a4 60		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
6099			; Display Clear  
6099 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
609b cd a4 60		            CALL fLCD_Inst      ;Clear display  
609e			; Entry mode  
609e 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
60a0 cd a4 60		            CALL fLCD_Inst      ;Increment mode, shift off  
60a3			; Display module now initialised  
60a3 c9			            RET  
60a4			; ok to here  
60a4			  
60a4			; Write instruction to LCD  
60a4			;   On entry: A = Instruction byte to be written  
60a4			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
60a4 f5			fLCD_Inst:  PUSH AF  
60a5 f5			            PUSH AF  
60a6 cd b8 60		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
60a9 f1			            POP  AF  
60aa 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
60ab 17			            RLA  
60ac 17			            RLA  
60ad 17			            RLA  
60ae cd b8 60		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
60b1 3e 02		            LD   A, 2  
60b3 cd a2 61		            CALL LCDDelay       ;Delay 2 ms to complete   
60b6 f1			            POP  AF  
60b7 c9			            RET  
60b8			Wr4bits:   
60b8 f5					push af  
60b9 3a d7 f8				ld a, (display_lcde1e2)  
60bc fe 00				cp 0     ; e  
60be 20 10				jr nz, .wea2	  
60c0 f1					pop af  
60c1 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
60c3 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
60c5 cb df		            SET  kLCDBitE, A	    ; TODO decide which E is being set  
60c7 cb 87		            res  kLCDBitE2, A	    ; TODO decide which E is being set  
60c9 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
60cb cb 9f		            RES  kLCDBitE, A        ; TODO decide which E is being set  
60cd d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
60cf c9			            RET  
60d0 f1			.wea2:		pop af  
60d1 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
60d3 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
60d5 cb c7		            SET  kLCDBitE2, A	    ; TODO decide which E is being set  
60d7 cb 9f		            res  kLCDBitE, A	    ; TODO decide which E is being set  
60d9 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
60db cb 87		            RES  kLCDBitE2, A        ; TODO decide which E is being set  
60dd d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
60df c9			            RET  
60e0			  
60e0			  
60e0			; Write data to LCD  
60e0			;   On entry: A = Data byte to be written  
60e0			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
60e0 f5			fLCD_Data:  PUSH AF  
60e1 f5			            PUSH AF  
60e2 cd f4 60		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
60e5 f1			            POP  AF  
60e6 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
60e7 17			            RLA  
60e8 17			            RLA  
60e9 17			            RLA  
60ea cd f4 60		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
60ed 3e 96		            LD   A, 150  
60ef 3d			Wait:      DEC  A              ;Wait a while to allow data   
60f0 20 fd		            JR   NZ, Wait      ;  write to complete  
60f2 f1			            POP  AF  
60f3 c9			            RET  
60f4			Wr4bitsa:     
60f4 f5					push af  
60f5 3a d7 f8				ld a, (display_lcde1e2)  
60f8 fe 00				cp 0     ; e1  
60fa 20 16				jr nz, .we2	  
60fc f1					pop af  
60fd e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
60ff cb d7		            SET  kLCDBitRS, A  
6101 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
6103 cb df		            SET  kLCDBitE, A      ; TODO Decide which E is being set  
6105 cb 87		            res  kLCDBitE2, A      ; TODO Decide which E is being set  
6107 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
6109 cb 9f		            RES  kLCDBitE, A       ; TODO Decide which E is being set  
610b d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
610d cb 97		            RES  kLCDBitRS, A  
610f d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6111 c9			            RET  
6112 f1			.we2:		pop af  
6113 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
6115 cb d7		            SET  kLCDBitRS, A  
6117 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
6119 cb c7		            SET  kLCDBitE2, A      ; TODO Decide which E is being set  
611b cb 9f		            res  kLCDBitE, A      ; TODO Decide which E is being set  
611d d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
611f cb 87		            RES  kLCDBitE2, A       ; TODO Decide which E is being set  
6121 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
6123 cb 97		            RES  kLCDBitRS, A  
6125 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6127 c9			            RET  
6128			  
6128			  
6128			; Position cursor to specified location  
6128			;   On entry: A = Cursor position  
6128			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6128 f5			fLCD_Pos:   PUSH AF  
6129					; at this point set the E1 or E2 flag depending on position  
6129			  
6129 c5					push bc  
612a			;		push af  
612a 06 00				ld b, 0  
612c 4f					ld c, a  
612d 3e 4f				ld a, kLCD_Line3-1  
612f b7			 		or a      ;clear carry flag  
6130 99					sbc a,c    ; TODO may need to sub 80 from a to put in context of current frame    
6131 38 04				jr c, .pe1  
6133			  
6133					; E selection  
6133 cb 80				res 0, b         ; bit 0 unset e  
6135			;		pop af    ; before line 3 so recover orig pos  
6135			;		ld c, a    ; save for poking back  
6135 18 06				jr .peset	          
6137			.pe1:          	; E2 selection  
6137 cb c0				set 0, b         ; bit 0 set e1  
6139 79					ld a, c  
613a de 4f				sbc a, kLCD_Line3-1  
613c 4f					ld c, a	         ; save caculated offset  
613d			;		pop af     ; bin this original value now we have calculated form  
613d			  
613d			.peset:		; set bit  
613d 78					ld a, b  
613e 32 d7 f8				ld (display_lcde1e2), a 	  
6141 79					ld a, c  
6142 c1					pop bc  
6143			  
6143 f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
6145 cd a4 60		            CALL fLCD_Inst      ;Write instruction to LCD  
6148 f1			            POP  AF  
6149 c9			            RET  
614a			  
614a			  
614a			; Output text string to LCD  
614a			;   On entry: DE = Pointer to null terminated text string  
614a			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
614a 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
614b b7			            OR   A              ;Null terminator?  
614c c8			            RET  Z              ;Yes, so finished  
614d cd e0 60		            CALL fLCD_Data      ;Write character to display  
6150 13			            INC  DE             ;Point to next character  
6151 18 f7		            JR   fLCD_Str       ;Repeat  
6153 c9					ret  
6154			  
6154			; Define custom character  
6154			;   On entry: A = Character number (0 to 7)  
6154			;             DE = Pointer to character bitmap data  
6154			;   On exit:  A = Next character number  
6154			;             DE = Next location following bitmap  
6154			;             BC HL IX IY I AF' BC' DE' HL' preserved  
6154			; Character is   
6154 c5			fLCD_Def:   PUSH BC  
6155 f5			            PUSH AF  
6156 07			            RLCA                ;Calculate location  
6157 07			            RLCA                ;  for bitmap data  
6158 07			            RLCA                ;  = 8 x CharacterNumber  
6159 f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
615b cd a4 60		            CALL fLCD_Inst      ;Write instruction to LCD  
615e 06 00		            LD   B, 0  
6160 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
6161 cd e0 60		            CALL fLCD_Data      ;Write byte to display  
6164 13			            INC  DE             ;Point to next byte  
6165 04			            INC  B              ;Count bytes  
6166 cb 58		            BIT  3, B           ;Finish all 8 bytes?  
6168 28 f6		            JR   Z, Loop       ;No, so repeat  
616a f1			            POP  AF  
616b 3c			            INC  A              ;Increment character number  
616c c1			            POP  BC  
616d c9			            RET  
616e			  
616e			  
616e			; **********************************************************************  
616e			; **  Private functions  
616e			; **********************************************************************  
616e			  
616e			; Write function to LCD  
616e			;   On entry: A = Function byte to be written  
616e			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
616e 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
6170 18 02		            JR   WrFunc  
6172 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
6174 f5			WrFunc:     PUSH AF  
6175 f5					push af  
6176 3a d7 f8				ld a, (display_lcde1e2)  
6179 fe 00				cp 0     ; e1  
617b 20 0f				jr nz, .wfea2	  
617d f1					pop af  
617e d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6180 cb df		            SET  kLCDBitE, A     ; TODO Decide which E is being set  
6182 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
6184 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6186 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
6188 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
618a 18 0d			jr .wfskip  
618c f1			.wfea2:		pop af  
618d d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
618f cb c7		            SET  kLCDBitE2, A     ; TODO Decide which E is being set  
6191 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
6193 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6195 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
6197 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6199 3e 05		.wfskip:            LD  A, 5  
619b cd a2 61		            CALL LCDDelay       ;Delay 5 ms to complete  
619e f1			            POP  AF  
619f c9			            RET  
61a0			  
61a0			  
61a0			; Delay in milliseconds  
61a0			;   On entry: A = Number of milliseconds delay  
61a0			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
61a0 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
61a2 d5			LCDDelay:   PUSH DE  
61a3 5f			            LD   E, A           ;Delay by 'A' ms  
61a4 16 00		            LD   D, 0  
61a6 cd 22 0a		            CALL aDelayInMS  
61a9 d1			            POP  DE  
61aa c9			            RET  
61ab			  
61ab			  
61ab			testlcd:  
61ab 3e 00			ld a, kLCD_Line1  
61ad cd 28 61			call fLCD_Pos  
61b0 06 28			ld b, 40  
61b2 11 e0 61			ld de, .ttext1  
61b5 cd 73 60			call write_len_string  
61b8			  
61b8 3e 28			ld a, kLCD_Line2  
61ba cd 28 61			call fLCD_Pos  
61bd 06 28			ld b, 40  
61bf 11 09 62			ld de, .ttext2  
61c2 cd 73 60			call write_len_string  
61c5 3e 50			ld a, kLCD_Line3  
61c7 cd 28 61			call fLCD_Pos  
61ca 06 28			ld b, 40  
61cc 11 32 62			ld de, .ttext3  
61cf cd 73 60			call write_len_string  
61d2 3e 78			ld a, kLCD_Line4  
61d4 cd 28 61			call fLCD_Pos  
61d7 06 28			ld b, 40  
61d9 11 5b 62			ld de, .ttext4  
61dc cd 73 60			call write_len_string  
61df			  
61df 76				halt  
61e0			  
61e0			  
61e0 .. 00		.ttext1: db "A234567890123456789012345678901234567890",0  
6209 .. 00		.ttext2: db "B234567890123456789012345678901234567890",0  
6232 .. 00		.ttext3: db "C234567890123456789012345678901234567890",0  
625b .. 00		.ttext4: db "D234567890123456789012345678901234567890",0  
6284			   
6284			  
6284			  
6284			; eof  
6284			  
# End of file firmware_lcd_4x40.asm
6284			;include "firmware_lcd_4x20.asm" 
6284			include "firmware_key_5x10.asm" 
6284			; 5 x 10 decade counter scanner  
6284			  
6284			  
6284			; TODO do cursor shape change for shift keys  
6284			; TODO hard coded positions for the shift keys. Change to work like 4x4 and detect and then hide them  
6284			  
6284			  
6284			; bit mask for each scan column and row for teing the matrix  
6284			  
6284			  
6284			key_init:  
6284			  
6284			; SCMonAPI functions used  
6284			  
6284			; Alphanumeric LCD functions used  
6284			; no need to specify specific functions for this module  
6284			  
6284			  
6284 3e cf		            LD   A, 11001111b  
6286 d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
6288			;            LD   A, 00000000b  
6288 3e 1f		            LD   A, 00011111b  
628a d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
628c			  
628c			  
628c				; TODO Configure cursor shapes  
628c			  
628c				; Load cursor shapes   
628c 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
628e 11 9e 62		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
6291 06 02		            LD   B, 2           ;Number of characters to define  
6293 cd 54 61		.DefLoop:   CALL fLCD_Def       ;Define custom character  
6296 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
6298			  
6298 3e 01				ld a, 1  
629a 32 d0 f8			ld (cursor_shape),a  
629d c9				ret  
629e			  
629e			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
629e			; Up to 8 custom characters can be defined  
629e			.cursor_shapes:      
629e			;; Character 0x00 = Normal  
629e 1f			            DB  11111b  
629f 1f			            DB  11111b  
62a0 1f			            DB  11111b  
62a1 1f			            DB  11111b  
62a2 1f			            DB  11111b  
62a3 1f			            DB  11111b  
62a4 1f			            DB  11111b  
62a5 1f			            DB  11111b  
62a6			;; Character 0x01 = Modifier  
62a6 1f			            DB  11111b  
62a7 1b			            DB  11011b  
62a8 1b			            DB  11011b  
62a9 1b			            DB  11011b  
62aa 1b			            DB  11011b  
62ab 1f			            DB  11111b  
62ac 1b			            DB  11011b  
62ad 1f			            DB  11111b  
62ae			  
62ae			  
62ae			  
62ae			  
62ae			; Display custom character 0  
62ae			;            LD   A, kLCD_Line1+14  
62ae			;            CALL fLCD_Pos       ;Position cursor to location in A  
62ae			;            LD   A, 0  
62ae			;            CALL fLCD_Data      ;Write character in A at cursor  
62ae			  
62ae			; Display custom character 1  
62ae			;            LD   A, kLCD_Line2+14  
62ae			;            CALL fLCD_Pos      ;Position cursor to location in A  
62ae			;            LD   A, 1  
62ae			;            CALL fLCD_Data     ;Write character in A at cursor  
62ae			  
62ae			; keyboard scanning   
62ae			  
62ae			; character in from keyboard  
62ae			  
62ae			; mapping for the pcb layout  
62ae			  
62ae			.matrix_to_char:  
62ae .. 08 05 0a 00			db "1357890",KEY_BS,KEY_UP,KEY_DOWN,0  
62b9 .. 0b 0c 00			db "qweryiop",KEY_LEFT,KEY_RIGHT,0  
62c4 7e .. 0d 00			db KEY_SYMBOLSHIFT,"asdfghjk",KEY_CR,0  
62cf 7e .. 7e 00			db KEY_SHIFT,"zxcvbnm ",KEY_SHIFT,0  
62da .. 10 11 12 .. 13 00			db "246tu",KEY_F1,KEY_F2,KEY_F3,"l",KEY_F4,0  
62e5			.matrix_to_shift:  
62e5			  
62e5 .. 08 05 0a 00			db "!#%&*()",KEY_BS,KEY_UP,KEY_DOWN,0  
62f0 .. 07 06 00			db "QWERYIOP",KEY_PREVWORD,KEY_NEXTWORD,0  
62fb 7e .. 0d 00			db KEY_SYMBOLSHIFT,"ASDFGHJK",KEY_CR,0  
6306 7e .. 7e 00			db KEY_SHIFT,"ZXCVBNM|",KEY_SHIFT,0  
6311 .. .. 14 15 16 .. 17 00			db '"',"$^TU",KEY_F5,KEY_F6,KEY_F7,"L",KEY_F8,0  
631c			  
631c			.matrix_to_symbolshift:  
631c			  
631c fc ed .. f7 08 05 0a 00			db 252,237,"5789",247,KEY_BS,KEY_UP,KEY_DOWN,0  
6327 .. b0 0e 0f 00			db "-+/=_?~",176,KEY_HOME,KEY_END,0  
6332 7e .. a5 7c db ff 0d 00			db KEY_SYMBOLSHIFT,"[]{}",165,124,219,255,KEY_CR,0  
633d 7e .. 7e 00			db KEY_SHIFT,"<>,.:;'\\",KEY_SHIFT,0  
6348 .. f6 eb 7d 7e 18 19 1a df 1b 00			db "@",246,235,125,126,KEY_F9,KEY_F10,KEY_F11,223,KEY_F12,0  
6353			  
6353			  
6353			  
6353			; mapping for a simple straight through breadboard layout  
6353			  
6353			;.matrix_to_char:  
6353			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
6353			;		db KEY_SHIFT,"zxcvbnm ",KEY_SYMBOLSHIFT,0  
6353			;		db "asdfghjkl",KEY_CR,0  
6353			;		db "qwertyuiop",0  
6353			;		 db "1234567890",0  
6353			;.matrix_to_shift:  
6353			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_HOME, KEY_END,0  
6353			;		db KEY_SHIFT,"ZXCVBNM",KEY_BS,KEY_SYMBOLSHIFT,0  
6353			;		db "ASDFGHJKL",KEY_CR,0  
6353			;		db "QWERTYUIOP",0  
6353			;		 db "!",'"',"#$%^&*()",0  
6353			;.matrix_to_symbolshift:  
6353			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
6353			;		db KEY_SHIFT,"<>:;b,.",KEY_BS,KEY_SYMBOLSHIFT,0  
6353			;		db "_?*fghjk=",KEY_CR,0  
6353			;		db "-/+*[]{}@#",0  
6353			;		 db "1234567890",0  
6353			  
6353			;.matrix_to_char: db "D#0*C987B654A321"  
6353			  
6353			  
6353				  
6353			  
6353			; add cin and cin_wait  
6353			  
6353 cd 64 63		cin_wait: 	call cin  
6356						if DEBUG_KEYCINWAIT  
6356							push af  
6356							  
6356							ld hl,key_repeat_ct  
6356							ld (hl),a  
6356							inc hl  
6356							call hexout  
6356							ld hl,key_repeat_ct+3  
6356							ld a,0  
6356							ld (hl),a  
6356			  
6356							    LD   A, kLCD_Line1+11  
6356							    CALL fLCD_Pos       ;Position cursor to location in A  
6356							    LD   DE, key_repeat_ct  
6356							    ;LD   DE, MsgHello  
6356							    CALL fLCD_Str       ;Display string pointed to by DE  
6356			  
6356			  
6356			  
6356							pop af  
6356						endif  
6356 fe 00			cp 0  
6358 28 f9			jr z, cin_wait   ; block until key press  
635a			  
635a							if DEBUG_KEYCINWAIT  
635a								push af  
635a			  
635a								ld a, 'A'	  
635a								ld hl,key_repeat_ct  
635a								ld (hl),a  
635a								inc hl  
635a								ld a,0  
635a								ld (hl),a  
635a			  
635a								    LD   A, kLCD_Line2+11  
635a								    CALL fLCD_Pos       ;Position cursor to location in A  
635a								    LD   DE, key_repeat_ct  
635a								    ;LD   DE, MsgHello  
635a								    CALL fLCD_Str       ;Display string pointed to by DE  
635a			  
635a							call delay500ms  
635a			  
635a								pop af  
635a							endif  
635a f5				push af   ; save key pressed  
635b			  
635b			.cin_wait1:	  
635b							if DEBUG_KEYCINWAIT  
635b								push af  
635b			  
635b								ld a, 'b'	  
635b								ld hl,key_repeat_ct  
635b								ld (hl),a  
635b								inc hl  
635b								ld a,0  
635b								ld (hl),a  
635b			  
635b								    LD   A, kLCD_Line2+11  
635b								    CALL fLCD_Pos       ;Position cursor to location in A  
635b								    LD   DE, key_repeat_ct  
635b								    ;LD   DE, MsgHello  
635b								    CALL fLCD_Str       ;Display string pointed to by DE  
635b			  
635b			  
635b							call delay500ms  
635b			  
635b								pop af  
635b							endif  
635b			  
635b cd 64 63		call cin  
635e fe 00			cp 0  
6360 20 f9			jr nz, .cin_wait1  	; wait for key release  
6362			if DEBUG_KEYCINWAIT  
6362				push af  
6362			  
6362				ld a, '3'	  
6362				ld hl,key_repeat_ct  
6362				ld (hl),a  
6362				inc hl  
6362				ld a,0  
6362				ld (hl),a  
6362			  
6362			            LD   A, kLCD_Line2+11  
6362			            CALL fLCD_Pos       ;Position cursor to location in A  
6362			            LD   DE, key_repeat_ct  
6362			            ;LD   DE, MsgHello  
6362			            CALL fLCD_Str       ;Display string pointed to by DE  
6362			  
6362			  
6362			call delay500ms  
6362			  
6362				pop af  
6362			endif  
6362			  
6362 f1				pop af   ; get key  
6363 c9				ret  
6364			  
6364			  
6364 cd 78 63		cin: 	call .mtoc  
6367			  
6367			if DEBUG_KEYCIN  
6367				push af  
6367				  
6367				ld hl,key_repeat_ct  
6367				ld (hl),a  
6367				inc hl  
6367				call hexout  
6367				ld hl,key_repeat_ct+3  
6367				ld a,0  
6367				ld (hl),a  
6367			  
6367			            LD   A, kLCD_Line3+15  
6367			            CALL fLCD_Pos       ;Position cursor to location in A  
6367			            LD   DE, key_repeat_ct  
6367			            ;LD   DE, MsgHello  
6367			            CALL fLCD_Str       ;Display string pointed to by DE  
6367			  
6367			  
6367			call delay500ms  
6367			  
6367				pop af  
6367			endif  
6367			  
6367			  
6367				; no key held  
6367 fe 00			cp 0  
6369 c8				ret z  
636a			  
636a			if DEBUG_KEYCIN  
636a				push af  
636a			  
636a				ld a, '1'	  
636a				ld hl,key_repeat_ct  
636a				ld (hl),a  
636a				inc hl  
636a				ld a,0  
636a				ld (hl),a  
636a			  
636a			            LD   A, kLCD_Line4+15  
636a			            CALL fLCD_Pos       ;Position cursor to location in A  
636a			            LD   DE, key_repeat_ct  
636a			            ;LD   DE, MsgHello  
636a			            CALL fLCD_Str       ;Display string pointed to by DE  
636a			  
636a			  
636a			call delay500ms  
636a			  
636a				pop af  
636a			endif  
636a			  
636a				; stop key bounce  
636a			  
636a 32 88 fb			ld (key_held),a		 ; save it  
636d 47				ld b, a  
636e			  
636e c5			.cina1:	push bc  
636f			if DEBUG_KEYCIN  
636f				push af  
636f			  
636f				ld hl,key_repeat_ct  
636f				inc hl  
636f				call hexout  
636f				ld hl,key_repeat_ct+3  
636f				ld a,0  
636f				ld (hl),a  
636f				ld hl,key_repeat_ct  
636f				ld a, '2'	  
636f				ld (hl),a  
636f			  
636f			            LD   A, kLCD_Line4+15  
636f			            CALL fLCD_Pos       ;Position cursor to location in A  
636f			            LD   DE, key_repeat_ct  
636f			            ;LD   DE, MsgHello  
636f			            CALL fLCD_Str       ;Display string pointed to by DE  
636f			  
636f				pop af  
636f			endif  
636f cd 78 63			call .mtoc  
6372 c1				pop bc  
6373 b8				cp b  
6374 28 f8			jr z, .cina1  
6376 78				ld a,b		  
6377			if DEBUG_KEYCIN  
6377				push af  
6377			  
6377				ld hl,key_repeat_ct  
6377				inc hl  
6377				call hexout  
6377				ld hl,key_repeat_ct+3  
6377				ld a,0  
6377				ld (hl),a  
6377				ld hl,key_repeat_ct  
6377				ld a, '3'	  
6377				ld (hl),a  
6377			  
6377			            LD   A, kLCD_Line4+15  
6377			            CALL fLCD_Pos       ;Position cursor to location in A  
6377			            LD   DE, key_repeat_ct  
6377			            ;LD   DE, MsgHello  
6377			            CALL fLCD_Str       ;Display string pointed to by DE  
6377			  
6377				pop af  
6377			endif  
6377 c9				ret  
6378			  
6378			; detect keyboard modifier key press and apply new overlay to the face key held  
6378			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
6378			  
6378			;.cin_map_modifier:   
6378			;	ld a, (hl)  
6378			;	and 255  
6378			;	ret NZ		; modifier key not flagged  
6378			;  
6378			;	; get key face  
6378			;  
6378			;	ld b,(key_face_held)  
6378			;  
6378			;	ld b, key_cols * key_rows  
6378			;  
6378			;	push de  
6378			;	pop hl  
6378			;  
6378			;.mmod1: ld a,(hl)   ; get map test  
6378			;	cp b  
6378			;	jr z, .mmod2  
6378			;  
6378			;  
6378			;  
6378			;.mmod2: inc hl    ;   
6378			;  
6378			;	  
6378			;  
6378			;	  
6378			;  
6378			;	ld hl,key_actual_pressed  
6378			;	ld (hl),a,  
6378			;	ret  
6378			  
6378			; map matrix key held to char on face of key  
6378			  
6378			.mtoc:  
6378			  
6378			; test decade counter strobes  
6378			  
6378			;.decadetest1:  
6378			  
6378			; reset counter  
6378			;ld a, 128  
6378			;out (portbdata),a  
6378			  
6378			  
6378			;ld b, 5  
6378			;.dec1:  
6378			;ld a, 0  
6378			;out (portbdata),a  
6378			;call delay1s  
6378			  
6378			;ld a, 32  
6378			;out (portbdata),a  
6378			;call delay1s  
6378			;call delay1s  
6378			;call delay1s  
6378			;  
6378			;ld a, 64+32  
6378			;out (portbdata),a  
6378			;call delay1s  
6378			;;djnz .dec1  
6378			;  
6378			;jp .decadetest1  
6378			  
6378			  
6378			  
6378			  
6378			  
6378			  
6378			  
6378			  
6378			  
6378			  
6378				; scan keyboard matrix and generate raw scan map  
6378 cd 0b 64			call matrix  
637b			  
637b				; reuse c bit 0 left modifer button - ie shift  
637b			        ; reuse c bit 1 for right modifer button - ie symbol shift  
637b				; both can be used with their other mappings and if seen together can do extra mappings (forth keywords????)  
637b			  
637b 0e 00			ld c, 0  
637d			  
637d				; TODO set flags for modifer key presses   
637d				; TODO do a search for modifer key...  
637d			  
637d				;ld hl,keyscan_table_row4  
637d 21 e7 fb			ld hl,keyscan_table_row2  
6380			  
6380 7e				ld a, (hl)  
6381 fe 23			cp '#'  
6383 20 07			jr nz, .nextmodcheck  
6385 cb c1			set 0, c  
6387 21 e5 62			ld hl, .matrix_to_shift  
638a 18 21			jr .dokeymap  
638c				; TODO for now igonre  
638c			.nextmodcheck:  
638c 21 dc fb			ld hl,keyscan_table_row3  
638f			  
638f 7e				ld a, (hl)  
6390 fe 23			cp '#'  
6392 20 07			jr nz, .nextmodcheck2  
6394 cb c9			set 1, c   
6396 21 1c 63			ld hl, .matrix_to_symbolshift  
6399 18 12			jr .dokeymap  
639b			.nextmodcheck2:  
639b 21 f0 fb			ld hl,keyscan_table_row2+9    ; right shift  
639e			  
639e 7e				ld a, (hl)  
639f fe 23			cp '#'  
63a1 20 07			jr nz, .donemodcheck  
63a3 cb c9			set 1, c   
63a5 21 e5 62			ld hl, .matrix_to_shift  
63a8 18 03			jr .dokeymap  
63aa			  
63aa				; no modifer found so just map to normal keys  
63aa				; get mtoc map matrix to respective keys  
63aa			;	ld hl, .matrix_to_char  
63aa			;	ld hl, .matrix_to_char  
63aa			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
63aa			;	ld a, KEY_SHIFT  
63aa			;	call findchar  
63aa			;  
63aa			;	; got offset to key modifer in b  
63aa			;  
63aa			;	ld hl,keyscan_table_row5  
63aa			;  
63aa			;	ld a,b  
63aa			;	call addatohl  
63aa			;	ld a,(hl)  
63aa			;  
63aa			;	cp '#'  
63aa			;	jr nz, .nextmodcheck  
63aa			;	set 0, c  
63aa			;	ld hl, .matrix_to_char  
63aa			;	jr .dokeymap  
63aa			;	; TODO for now igonre  
63aa			;.nextmodcheck:  
63aa			;	ld hl, .matrix_to_symbolshift  
63aa			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
63aa			;	ld a, KEY_SYMBOLSHIFT  
63aa			;	call findchar  
63aa			;  
63aa			;  
63aa			;	; got offset to key modifer in b  
63aa			;  
63aa			;	ld hl,keyscan_table_row5  
63aa			;  
63aa			;	ld a,b  
63aa			;	call addatohl  
63aa			;	ld a,(hl)  
63aa			;  
63aa			;	cp '#'  
63aa			;	jr nz, .donemodcheck  
63aa			;	set 1, c   
63aa			;	ld hl, .matrix_to_symbolshift  
63aa			;	jr .dokeymap  
63aa			  
63aa			  
63aa			  
63aa			.donemodcheck:  
63aa				; no modifer found so just map to normal keys  
63aa				; get mtoc map matrix to respective keys  
63aa 21 ae 62			ld hl, .matrix_to_char  
63ad			  
63ad			.dokeymap:  
63ad				;ld (key_fa), c   
63ad cd c6 63			call .mapkeys  
63b0			  
63b0			  
63b0			if DEBUG_KEY  
63b0			  
63b0			; Display text on first line  
63b0			            LD   A, kLCD_Line1  
63b0			            CALL fLCD_Pos       ;Position cursor to location in A  
63b0			            LD   DE, keyscan_table_row1  
63b0			            ;LD   DE, MsgHello  
63b0			            CALL fLCD_Str       ;Display string pointed to by DE  
63b0			  
63b0			; Display text on second line  
63b0			            LD   A, kLCD_Line2  
63b0			            CALL fLCD_Pos       ;Position cursor to location in A  
63b0			            LD   DE, keyscan_table_row2  
63b0			            CALL fLCD_Str       ;Display string pointed to by DE  
63b0			            LD   A, kLCD_Line3  
63b0			            CALL fLCD_Pos       ;Position cursor to location in A  
63b0			            LD   DE, keyscan_table_row3  
63b0			            CALL fLCD_Str       ;Display string pointed to by DE  
63b0			            LD   A, kLCD_Line4  
63b0			            CALL fLCD_Pos       ;Position cursor to location in A  
63b0			            LD   DE, keyscan_table_row4  
63b0			            CALL fLCD_Str       ;Display string pointed to by DE  
63b0			            LD   A, kLCD_Line1+10  
63b0			            CALL fLCD_Pos       ;Position cursor to location in A  
63b0			            LD   DE, keyscan_table_row5  
63b0			            CALL fLCD_Str       ;Display string pointed to by DE  
63b0			  
63b0				;call delay250ms  
63b0			endif  
63b0			;	jp testkey  
63b0			  
63b0			; get first char reported  
63b0			  
63b0 21 c6 fb			ld hl,keyscan_table_row5  
63b3			  
63b3				;ld b, 46   ; 30 keys to remap + 8 nulls   
63b3 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
63b5			.findkey:  
63b5 7e				ld a,(hl)  
63b6 fe 00			cp 0  
63b8 28 04			jr z, .nextkey  
63ba fe 7e			cp KEY_MATRIX_NO_PRESS  
63bc 20 06			jr nz, .foundkey  
63be			.nextkey:  
63be 23				inc hl  
63bf 10 f4			djnz .findkey  
63c1 3e 00			ld a,0  
63c3 c9				ret  
63c4			.foundkey:  
63c4 7e				ld a,(hl)  
63c5 c9				ret  
63c6				  
63c6			  
63c6			; convert the raw key map given hl for destination key  
63c6			.mapkeys:  
63c6 11 c6 fb			ld de,keyscan_table_row5  
63c9			  
63c9 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
63cb			.remap:  
63cb 1a				ld a,(de)  
63cc fe 23			cp '#'  
63ce 20 02			jr nz, .remapnext  
63d0				;CALLMONITOR  
63d0 7e				ld a,(hl)  
63d1 12				ld (de),a  
63d2			  
63d2			  
63d2			  
63d2			.remapnext:  
63d2 23				inc hl  
63d3 13				inc de  
63d4 10 f5			djnz .remap  
63d6				  
63d6 c9				ret  
63d7			  
63d7			  
63d7			  
63d7			.mtocold2:  
63d7			  
63d7			;	; flag if key D is held down and remove from reporting  
63d7			;	ld bc, .key_map_fd    
63d7			;	ld hl, keyscan_table  
63d7			;	ld de, key_fd  
63d7			;	call .key_shift_hold  
63d7			;	cp 255  
63d7			;	jr z, .cinmap  
63d7			;	; flag if key C is held down and remove from reporting  
63d7			;	ld bc, .key_map_fc    
63d7			;	ld hl, keyscan_table+key_cols  
63d7			;	ld de, key_fc  
63d7			;	call .key_shift_hold  
63d7			;	cp 255  
63d7			;	jr z, .cinmap  
63d7			;	; flag if key B is held down and remove from reporting  
63d7			;	ld bc, .key_map_fb    
63d7			;	ld hl, keyscan_table+(key_cols*2)  
63d7			;	ld de, key_fb  
63d7			;	call .key_shift_hold  
63d7			;	cp 255  
63d7			;	jr z, .cinmap  
63d7			;	; flag if key A is held down and remove from reporting  
63d7			;	ld bc, .key_map_fa    
63d7			;	ld hl, keyscan_table+(key_cols*3)  
63d7			;	ld de, key_fa  
63d7			;	call .key_shift_hold  
63d7			;	cp 255  
63d7			;	jr z, .cinmap  
63d7			  
63d7 11 ae 62			ld de, .matrix_to_char  
63da			  
63da			  
63da			.cinmap1:   
63da				if DEBUG_KEY  
63da			            LD   A, kLCD_Line4  
63da			            CALL fLCD_Pos       ;Position cursor to location in A  
63da					push de  
63da			            LD   DE, keyscan_table  
63da			            CALL fLCD_Str       ;Display string pointed to by DE  
63da					pop de  
63da				endif  
63da			  
63da				; scan key matrix table for any held key  
63da			  
63da				; de holds either the default matrix or one selected above  
63da			  
63da 21 93 fb			ld hl, keyscan_table  
63dd 06 32			ld b,key_cols*key_rows  
63df			  
63df 7e			.cin11:	ld a,(hl)  
63e0 fe 23			cp '#'  
63e2 28 08			jr z, .cinhit1  
63e4 23				inc hl  
63e5 13				inc de  
63e6 05				dec b  
63e7 20 f6			jr nz, .cin11  
63e9				; no key found held  
63e9 3e 00			ld a,0  
63eb c9				ret  
63ec d5			.cinhit1: push de  
63ed e1				pop hl  
63ee 7e				ld a,(hl)  
63ef c9				ret  
63f0			  
63f0			; flag a control key is held   
63f0			; hl is key pin, de is flag indicator  
63f0			  
63f0			.key_shift_hold1:  
63f0 c5				push bc  
63f1 3e 01			ld a, 1  
63f3 32 d0 f8			ld (cursor_shape),a  
63f6 06 00			ld b, 0  
63f8 7e				ld a, (hl)  
63f9 fe 2e			cp '.'  
63fb 28 0a			jr z, .key_shift11  
63fd 06 ff			ld b, 255  
63ff 3e 2b			ld a, '+'    ; hide key from later scans  
6401 77				ld (hl),a  
6402 3e 02			ld a, 2  
6404 32 d0 f8			ld (cursor_shape),a  
6407			.key_shift11:  
6407				; write flag indicator  
6407 78				ld a,b  
6408 12				ld (de),a  
6409			  
6409 d1				pop de    ; de now holds the key map ptr  
640a c9				ret  
640b			  
640b				  
640b			  
640b			; scans keyboard matrix and flags key press in memory array	  
640b				  
640b			matrix:  
640b				;call matrix  
640b				; TODO optimise the code....  
640b			  
640b			  
640b			;ld hl, keyscan_table_row1  
640b			;ld de, keyscan_table_row1+1  
640b			;ld bc,46  
640b			;ld a,KEY_MATRIX_NO_PRESS  
640b			;ldir  
640b			  
640b			  
640b			  
640b			; reset counter  
640b 3e 80		ld a, 128  
640d d3 c1		out (portbdata),a  
640f			  
640f 06 0a		ld b, 10  
6411 0e 00		ld c, 0       ; current clock toggle  
6413			  
6413			.colscan:  
6413			  
6413			; set current column  
6413			; disable clock enable and set clock low  
6413			  
6413			;ld a, 0  
6413			;out (portbdata),a  
6413			  
6413			; For each column scan for switches  
6413			  
6413 c5			push bc  
6414 21 89 fb		ld hl, keyscan_scancol  
6417 cd 20 65		call .rowscan  
641a c1			pop bc  
641b			  
641b			  
641b			; get back current column  
641b			  
641b			; translate the row scan  
641b			  
641b			;   
641b			; row 1  
641b			  
641b 78			ld a,b  
641c			  
641c 21 fc fb		LD   hl, keyscan_table_row1+10  
641f			  
641f cd 24 0c		call subafromhl  
6422			;call addatohl  
6422			  
6422 11 89 fb		ld de, keyscan_scancol  
6425			  
6425 1a			ld a,(de)  
6426 77			ld (hl),a  
6427			  
6427			  
6427			  
6427			  
6427			; row 2  
6427			  
6427 78			ld a,b  
6428			  
6428 21 f1 fb		LD   hl, keyscan_table_row2+10  
642b			  
642b			;call addatohl  
642b cd 24 0c		call subafromhl  
642e			  
642e			  
642e 11 8a fb		ld de, keyscan_scancol+1  
6431			  
6431 1a			ld a,(de)  
6432 77			ld (hl),a  
6433			  
6433			  
6433			; row 3  
6433			  
6433 78			ld a,b  
6434			  
6434 21 e6 fb		LD   hl, keyscan_table_row3+10  
6437			  
6437			;call addatohl  
6437 cd 24 0c		call subafromhl  
643a			  
643a 11 8b fb		ld de, keyscan_scancol+2  
643d			  
643d 1a			ld a,(de)  
643e 77			ld (hl),a  
643f			  
643f			  
643f			  
643f			; row 4  
643f			  
643f 78			ld a,b  
6440			  
6440 21 db fb		LD   hl, keyscan_table_row4+10  
6443			  
6443			;call addatohl  
6443 cd 24 0c		call subafromhl  
6446			  
6446 11 8c fb		ld de, keyscan_scancol+3  
6449			  
6449 1a			ld a,(de)  
644a 77			ld (hl),a  
644b			  
644b			; row 5  
644b			  
644b 78			ld a,b  
644c			  
644c 21 d0 fb		LD   hl, keyscan_table_row5+10  
644f			  
644f			;call addatohl  
644f cd 24 0c		call subafromhl  
6452			  
6452 11 8d fb		ld de, keyscan_scancol+4  
6455			  
6455 1a			ld a,(de)  
6456 77			ld (hl),a  
6457			  
6457			; handshake next column  
6457			  
6457			  
6457 3e 40		ld a, 64  
6459 d3 c1		out (portbdata),a  
645b			  
645b 3e 00		ld a, 0  
645d d3 c1		out (portbdata),a  
645f			  
645f			; toggle clk and move to next column  
645f			;ld a, 64  
645f			;cp c  
645f			;  
645f			;jr z, .coltoglow  
645f			;ld c, a  
645f			;jr .coltog  
645f			;.coltoglow:  
645f			;ld c, 0  
645f			;.coltog:  
645f			;ld a, c  
645f			;out (portbdata),a  
645f			  
645f 10 b2		djnz .colscan  
6461			  
6461 3e 0a		ld a,10  
6463 21 f2 fb		LD   hl, keyscan_table_row1  
6466 cd 12 0c		call addatohl  
6469 3e 00		ld a, 0  
646b 77			ld (hl), a  
646c			  
646c			  
646c 3e 0a		ld a,10  
646e 21 e7 fb		LD   hl, keyscan_table_row2  
6471 cd 12 0c		call addatohl  
6474 3e 00		ld a, 0  
6476 77			ld (hl), a  
6477			  
6477 3e 0a		ld a,10  
6479 21 dc fb		LD   hl, keyscan_table_row3  
647c cd 12 0c		call addatohl  
647f 3e 00		ld a, 0  
6481 77			ld (hl), a  
6482			  
6482 3e 0a		ld a,10  
6484 21 d1 fb		LD   hl, keyscan_table_row4  
6487 cd 12 0c		call addatohl  
648a 3e 00		ld a, 0  
648c 77			ld (hl), a  
648d			  
648d 3e 0a		ld a,10  
648f 21 c6 fb		LD   hl, keyscan_table_row5  
6492 cd 12 0c		call addatohl  
6495 3e 00		ld a, 0  
6497 77			ld (hl), a  
6498			  
6498			if DEBUG_KEY_MATRIX  
6498			  
6498			; Display text on first line  
6498			            LD   A, kLCD_Line1  
6498			            CALL fLCD_Pos       ;Position cursor to location in A  
6498			            LD   DE, keyscan_table_row1  
6498			            ;LD   DE, MsgHello  
6498			            CALL fLCD_Str       ;Display string pointed to by DE  
6498			  
6498			; Display text on second line  
6498			            LD   A, kLCD_Line2  
6498			            CALL fLCD_Pos       ;Position cursor to location in A  
6498			            LD   DE, keyscan_table_row2  
6498			            CALL fLCD_Str       ;Display string pointed to by DE  
6498			            LD   A, kLCD_Line3  
6498			            CALL fLCD_Pos       ;Position cursor to location in A  
6498			            LD   DE, keyscan_table_row3  
6498			            CALL fLCD_Str       ;Display string pointed to by DE  
6498			            LD   A, kLCD_Line4  
6498			            CALL fLCD_Pos       ;Position cursor to location in A  
6498			            LD   DE, keyscan_table_row4  
6498			            CALL fLCD_Str       ;Display string pointed to by DE  
6498			            LD   A, kLCD_Line4+10  
6498			            CALL fLCD_Pos       ;Position cursor to location in A  
6498			            LD   DE, keyscan_table_row5  
6498			            CALL fLCD_Str       ;Display string pointed to by DE  
6498			  
6498			;call delay250ms  
6498				jp matrix  
6498			endif  
6498 c9			ret  
6499			  
6499			; using decade counter....  
6499			  
6499			  
6499			; TODO reset decade counter to start of scan  
6499			  
6499			; reset 15  
6499			; clock 14  
6499			; ce 13  
6499			  
6499			; 1 - q5  
6499			; 2 - q1  
6499			; 3 - q0  
6499			; 4 - q2  
6499			; 5 - q6  
6499			; 6 - q7  
6499			; 7 - q3  
6499			; 8 - vss  
6499			; 9 - q8  
6499			; 10 - q4  
6499			; 11 - q9  
6499			; 12 - cout  
6499			; 16 - vdd  
6499			  
6499			; clock      ce       reset     output  
6499			; 0          x        0         n  
6499			; x          1        0         n  
6499			; x          x        1         q0  
6499			; rising     0        0         n+1  
6499			; falling    x        0         n  
6499			; x          rising   0         n  
6499			; 1          falling  0         x+1  
6499			;  
6499			; x = dont care, if n < 5 carry = 1 otherwise 0  
6499			  
6499			;   
6499			; reset   
6499			; 13=0, 14=0, 15=1 .. 15=0  
6499			;  
6499			; handshake line  
6499			; 14=1.... read line 14=0  
6499			  
6499			  
6499			  
6499			  
6499			  
6499			; TODO hand shake clock for next column scan  
6499			; TODO detect each row  
6499			  
6499			  
6499			  
6499			  
6499			; reset 128  
6499			; clock 64  
6499			; ce 32  
6499			  
6499			  
6499			.cyclestart:  
6499			  
6499			; reset counter  
6499 3e 80		ld a, 128  
649b d3 c1		out (portbdata),a  
649d			  
649d			; loop leds  
649d 06 0a		ld b,10  
649f			  
649f			.cycle1:  
649f c5			push bc  
64a0 3e 00		ld a, 0  
64a2 d3 c1		out (portbdata),a  
64a4 cd 31 0a		call delay250ms  
64a7			  
64a7 3e 40		ld a, 64  
64a9 d3 c1		out (portbdata),a  
64ab cd 31 0a		call delay250ms  
64ae			  
64ae 3e 00		ld a, 0  
64b0 d3 c1		out (portbdata),a  
64b2 cd 31 0a		call delay250ms  
64b5			  
64b5 c1			pop bc  
64b6 10 e7		djnz .cycle1  
64b8			  
64b8			  
64b8 18 df		jr .cyclestart  
64ba			  
64ba			  
64ba			  
64ba			  
64ba			  
64ba			  
64ba			  
64ba			  
64ba			  
64ba			; map matrix key held to char on face of key  
64ba			  
64ba			;.mtocold:  
64ba			;  
64ba			;  
64ba			;; reset counter  
64ba			;ld a, 128  
64ba			;out (portbdata),a  
64ba			;  
64ba			;  
64ba			;; scan keyboard row 1  
64ba			;ld a, 0  
64ba			;out (portbdata),a  
64ba			;;ld a, 64  
64ba			;;out (portbdata),a  
64ba			;  
64ba			;  
64ba			;	ld a, 128  
64ba			;	ld hl, keyscan_table  
64ba			;	call .rowscan  
64ba			;  
64ba			;;ld a, 0  
64ba			;;out (portbdata),a  
64ba			;ld a, 64  
64ba			;out (portbdata),a  
64ba			;  
64ba			;	ld a, 64  
64ba			;	ld hl, keyscan_table+key_cols  
64ba			;	call .rowscan  
64ba			;  
64ba			;ld a, 0  
64ba			;out (portbdata),a  
64ba			;;ld a, 64  
64ba			;;out (portbdata),a  
64ba			;	ld a, 32  
64ba			;	ld hl, keyscan_table+(key_cols*2)  
64ba			;	call .rowscan  
64ba			;  
64ba			;  
64ba			;;ld a, 0  
64ba			;;out (portbdata),a  
64ba			;ld a, 64  
64ba			;out (portbdata),a  
64ba			;  
64ba			;	ld a, 16  
64ba			;	ld hl, keyscan_table+(key_cols*3)  
64ba			;	call .rowscan  
64ba			;  
64ba			;  
64ba			;	; flag if key D is held down and remove from reporting  
64ba			;	ld bc, .key_map_fd    
64ba			;	ld hl, keyscan_table  
64ba			;	ld de, key_fd  
64ba			;	call .key_shift_hold  
64ba			;	cp 255  
64ba			;	jr z, .cinmap  
64ba			;	; flag if key C is held down and remove from reporting  
64ba			;	ld bc, .key_map_fc    
64ba			;	ld hl, keyscan_table+key_cols  
64ba			;	ld de, key_fc  
64ba			;	call .key_shift_hold  
64ba			;	cp 255  
64ba			;	jr z, .cinmap  
64ba			;	; flag if key B is held down and remove from reporting  
64ba			;	ld bc, .key_map_fb    
64ba			;	ld hl, keyscan_table+(key_cols*2)  
64ba			;	ld de, key_fb  
64ba			;	call .key_shift_hold  
64ba			;	cp 255  
64ba			;	jr z, .cinmap  
64ba			;	; flag if key A is held down and remove from reporting  
64ba			;	ld bc, .key_map_fa    
64ba			;	ld hl, keyscan_table+(key_cols*3)  
64ba			;	ld de, key_fa  
64ba			;	call .key_shift_hold  
64ba			;	cp 255  
64ba			;	jr z, .cinmap  
64ba			;  
64ba			;	ld de, .matrix_to_char  
64ba			;  
64ba			;  
64ba			;.cinmap:   
64ba			;	if DEBUG_KEY  
64ba			;            LD   A, kLCD_Line4  
64ba			;            CALL fLCD_Pos       ;Position cursor to location in A  
64ba			;		push de  
64ba			;            LD   DE, keyscan_table  
64ba			;            CALL fLCD_Str       ;Display string pointed to by DE  
64ba			;		pop de  
64ba			;	endif  
64ba			  
64ba				; scan key matrix table for any held key  
64ba			  
64ba				; de holds either the default matrix or one selected above  
64ba			  
64ba			;	ld hl, keyscan_table  
64ba			;	ld b,key_cols*key_rows  
64ba			;  
64ba			;.cin1:	ld a,(hl)  
64ba			;	cp '#'  
64ba			;	jr z, .cinhit  
64ba			;	inc hl  
64ba			;	inc de  
64ba			;	dec b  
64ba			;	jr nz, .cin1  
64ba			;	; no key found held  
64ba			;	ld a,0  
64ba			;	ret  
64ba			;.cinhit: push de  
64ba			;	pop hl  
64ba			;	ld a,(hl)  
64ba			;	ret  
64ba			  
64ba			; flag a control key is held   
64ba			; hl is key pin, de is flag indicator  
64ba			  
64ba			;.key_shift_hold:  
64ba			;	push bc  
64ba			;	ld a, 1  
64ba			;	ld (cursor_shape),a  
64ba			;	ld b, 0  
64ba			;	ld a, (hl)  
64ba			;	cp '.'  
64ba			;	jr z, .key_shift1  
64ba			;	ld b, 255  
64ba			;	ld a, '+'    ; hide key from later scans  
64ba			;	ld (hl),a  
64ba			;	ld a, 2  
64ba			;	ld (cursor_shape),a  
64ba			;.key_shift1:  
64ba			;	; write flag indicator  
64ba			;	ld a,b  
64ba			;	ld (de),a  
64ba			;  
64ba			;	pop de    ; de now holds the key map ptr  
64ba			;	ret  
64ba			  
64ba				  
64ba				  
64ba			  
64ba			  
64ba			  
64ba			  
64ba			  
64ba			  
64ba			  
64ba			  
64ba			  
64ba			  
64ba			  
64ba			;	push hl  
64ba			;	push de  
64ba			;	push bc  
64ba			;	call keyscan  
64ba			;	; map key matrix to ascii value of key face  
64ba			;  
64ba			;	ld hl, key_face_map  
64ba			;	ld de, keyscan_table  
64ba			;  
64ba			;	; get how many keys to look at  
64ba			;	ld b, keyscan_table_len  
64ba			;	  
64ba			;  
64ba			;	; at this stage fall out on first key hit  
64ba			;	; TODO handle multiple key press  
64ba			;  
64ba			;map1:	ld a,(hl)  
64ba			;	cp '#'  
64ba			;	jr z, keyhit  
64ba			;	inc hl  
64ba			;	inc de  
64ba			;	dec b  
64ba			;	jr nz, map1  
64ba			;nohit:	ld a, 0  
64ba			;	jr keydone  
64ba			;keyhit: push de  
64ba			;	pop hl  
64ba			;	ld a,(hl)  
64ba			;keydone:  
64ba			;	push bc  
64ba			;	push de  
64ba			; 	push hl  
64ba			;	ret   
64ba			;  
64ba			  
64ba			  
64ba			  
64ba			  
64ba			; scan physical key matrix  
64ba			  
64ba			  
64ba			;keyscan:  
64ba			;  
64ba			;; for each key_row use keyscanr bit mask for out  
64ba			;; then read in for keyscanc bitmask  
64ba			;; save result of row scan to keyscantable  
64ba			;  
64ba			;; scan keyboard row 1  
64ba			;  
64ba			;	ld b, key_rows  
64ba			;	ld hl, key_scanr  
64ba			;	ld de, keyscan_table  
64ba			;  
64ba			;rowloop:  
64ba			;  
64ba			;	ld a,(hl)		; out bit mask to energise keyboard row  
64ba			;	call rowscan  
64ba			;	inc hl  
64ba			;	dec b  
64ba			;	jr nz, rowloop  
64ba			;  
64ba			;	ret  
64ba			;  
64ba			;  
64ba			;; pass a out bitmask, b row number  
64ba			;arowscan:   
64ba			;	push bc  
64ba			;  
64ba			;	ld d, b  
64ba			;  
64ba			;	; calculate buffer location for this row  
64ba			;  
64ba			;	ld hl, keyscan_table	  
64ba			;kbufr:  ld e, key_cols  
64ba			;kbufc:	inc hl  
64ba			;	dec e  
64ba			;	jr nz, kbufc  
64ba			;	dec d  
64ba			;	jr nz, kbufr  
64ba			;  
64ba			;	; energise row and read columns  
64ba			;  
64ba			;	out (portbdata),a  
64ba			;	in a,(portbdata)  
64ba			;	ld c,a  
64ba			;  
64ba			;  
64ba			;	; save buffer loc  
64ba			;  
64ba			;	ld (keybufptr), hl  
64ba			;  
64ba			;	ld hl, key_scanc  
64ba			;	ld d, key_cols  
64ba			;  
64ba			;	; for each column check each bit mask  
64ba			;  
64ba			;colloop:  
64ba			;	  
64ba			;  
64ba			;	; reset flags for the row   
64ba			;  
64ba			;	ld b,'.'  
64ba			;	and (hl)  
64ba			;	jr z, maskskip  
64ba			;	ld b,'#'  
64ba			;maskskip:  
64ba			;	; save  key state  
64ba			;	push hl  
64ba			;	ld hl, (keybufptr)  
64ba			;	ld (hl), b  
64ba			;	inc hl  
64ba			;	ld (keybufptr), hl  
64ba			;  
64ba			;	; move to next bit mask  
64ba			;	pop hl  
64ba			;	inc hl  
64ba			;  
64ba			;	dec d  
64ba			;	jr nz, colloop  
64ba			;  
64ba			;	ret  
64ba			;  
64ba			;  
64ba			;;  
64ba			; lcd functions  
64ba			;  
64ba			;  
64ba			  
64ba			;if DEBUG_KEY_MATRIX  
64ba			  
64ba			; test function to display hardware view of matrix state  
64ba			  
64ba			matrixold:  
64ba			  
64ba			  
64ba			  
64ba			; reset counter  
64ba 3e 80		ld a, 128  
64bc d3 c1		out (portbdata),a  
64be			; scan keyboard row 1  
64be 3e 00		ld a, 0  
64c0 d3 c1		out (portbdata),a  
64c2			;ld a, 64  
64c2			;out (portbdata),a  
64c2 3e 80			ld a, 128  
64c4 21 f2 fb			ld hl, keyscan_table_row1  
64c7 cd 20 65			call .rowscan  
64ca			  
64ca			;ld a, 0  
64ca			;out (portbdata),a  
64ca 3e 40		ld a, 64  
64cc d3 c1		out (portbdata),a  
64ce 3e 40			ld a, 64  
64d0 21 e7 fb			ld hl, keyscan_table_row2  
64d3 cd 20 65			call .rowscan  
64d6			  
64d6 3e 00		ld a, 0  
64d8 d3 c1		out (portbdata),a  
64da			;ld a, 64  
64da			;out (portbdata),a  
64da 3e 20			ld a, 32  
64dc 21 dc fb			ld hl, keyscan_table_row3  
64df cd 20 65			call .rowscan  
64e2			  
64e2			;ld a, 0  
64e2			;out (portbdata),a  
64e2 3e 40		ld a, 64  
64e4 d3 c1		out (portbdata),a  
64e6 3e 10			ld a, 16  
64e8 21 d1 fb			ld hl, keyscan_table_row4  
64eb cd 20 65			call .rowscan  
64ee			  
64ee			; Display text on first line  
64ee 3e 00		            LD   A, kLCD_Line1  
64f0 cd 28 61		            CALL fLCD_Pos       ;Position cursor to location in A  
64f3 11 f2 fb		            LD   DE, keyscan_table_row1  
64f6			            ;LD   DE, MsgHello  
64f6 cd 4a 61		            CALL fLCD_Str       ;Display string pointed to by DE  
64f9			  
64f9			; Display text on second line  
64f9 3e 28		            LD   A, kLCD_Line2  
64fb cd 28 61		            CALL fLCD_Pos       ;Position cursor to location in A  
64fe 11 e7 fb		            LD   DE, keyscan_table_row2  
6501 cd 4a 61		            CALL fLCD_Str       ;Display string pointed to by DE  
6504 3e 50		            LD   A, kLCD_Line3  
6506 cd 28 61		            CALL fLCD_Pos       ;Position cursor to location in A  
6509 11 dc fb		            LD   DE, keyscan_table_row3  
650c cd 4a 61		            CALL fLCD_Str       ;Display string pointed to by DE  
650f 3e 78		            LD   A, kLCD_Line4  
6511 cd 28 61		            CALL fLCD_Pos       ;Position cursor to location in A  
6514 11 d1 fb		            LD   DE, keyscan_table_row4  
6517 cd 4a 61		            CALL fLCD_Str       ;Display string pointed to by DE  
651a			  
651a cd 31 0a			call delay250ms  
651d c3 0b 64			jp matrix  
6520			  
6520			; pass de as row display flags  
6520			.rowscan:   
6520			;	out (portbdata),a  
6520 db c1			in a,(portbdata)  
6522 4f				ld c,a  
6523				; reset flags for the row   
6523 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6525 e6 01			and 1  
6527 28 02			jr z, .p1on  
6529 06 23			ld b,'#'  
652b			.p1on:  
652b 70				ld (hl), b  
652c 23				inc hl  
652d			  
652d 06 7e			ld b,KEY_MATRIX_NO_PRESS  
652f 79				ld a,c  
6530 e6 02			and 2  
6532			;	bit 0,a  
6532 28 02			jr z, .p2on  
6534 06 23			ld b,'#'  
6536			.p2on:  
6536 70				ld (hl), b  
6537 23				inc hl  
6538			;  
6538 06 7e			ld b,KEY_MATRIX_NO_PRESS  
653a 79				ld a,c  
653b e6 04			and 4  
653d			;;	bit 0,a  
653d 28 02			jr z, .p3on  
653f 06 23			ld b,'#'  
6541			.p3on:  
6541 70				ld (hl), b  
6542 23				inc hl  
6543			;;  
6543 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6545			;;	bit 0,a  
6545 79				ld a,c  
6546 e6 08			and 8  
6548 28 02			jr z, .p4on  
654a 06 23			ld b,'#'  
654c			.p4on:  
654c 70				ld (hl), b  
654d 23				inc hl  
654e			  
654e 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6550			;;	bit 0,a  
6550 79				ld a,c  
6551 e6 10			and 16  
6553 28 02			jr z, .p5on  
6555 06 23			ld b,'#'  
6557			.p5on:  
6557 70				ld (hl), b  
6558 23				inc hl  
6559			; zero term  
6559 06 00			ld b,0  
655b 70				ld (hl), b  
655c			  
655c c9			.rscandone: ret  
655d			  
655d			;addatohl:  
655d			;  
655d			 ;add   a, l    ; A = A+L  
655d			  ;  ld    l, a    ; L = A+L  
655d			   ; adc   a, h    ; A = A+L+H+carry  
655d			   ; sub   l       ; A = H+carry  
655d			   ; ld    h, a    ; H = H+carry  
655d			  
655d			;ret  
655d			; eof  
# End of file firmware_key_5x10.asm
655d			;include "firmware_key_4x10.asm" 
655d			 
655d			heap_size:    equ heap_end - heap_start 
655d			;eof 
# End of file os_mega.asm
655d
